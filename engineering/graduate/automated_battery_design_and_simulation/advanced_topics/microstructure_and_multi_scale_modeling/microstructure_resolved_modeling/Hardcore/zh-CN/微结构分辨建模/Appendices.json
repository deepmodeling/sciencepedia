{
    "hands_on_practices": [
        {
            "introduction": "在构建复杂的仿真模型之前，验证其潜在的物理假设至关重要。本练习将探讨德拜长度（$ \\lambda_{D} $）的概念，这是电化学中的一个基本长度尺度。通过推导和计算$ \\lambda_{D} $，您将学习如何通过将其与微观结构的特征孔径进行比较，来定量地证明电中性假设的合理性，而电中性假设是电池模型中一个常用且强大的简化方法。",
            "id": "3928427",
            "problem": "在锂离子电池电极和隔膜的微观结构解析建模中，当特征静电屏蔽长度远小于特征孔径时，通常会假设宏观电中性。请从第一性原理出发，通过结合静电泊松方程和麦克斯韦-玻尔兹曼离子数密度，在小电势假设 $|z e \\phi| \\ll k_{B} T$ 下，推导对称单价电解质的静电屏蔽长度（德拜长度）$\\lambda_{D}$ 的表达式。请用绝对介电常数 $\\epsilon$、温度 $T$、离子强度 $I$、元电荷 $e$ 和阿伏伽德罗常数 $N_{A}$ 来表示 $\\lambda_{D}$。假设理想解离，对于对称的 1:1 型电解质，离子强度等于盐浓度，$I = c_{s}$，其中 $c_{s}$ 的单位是 $\\mathrm{mol \\, m^{-3}}$。\n\n然后，使用您推导的表达式，计算在温度 $T = 298 \\ \\mathrm{K}$ 和宏观盐浓度 $c_{s} = 1.0 \\ \\mathrm{mol \\, L^{-1}}$ 条件下，相对介电常数 $\\epsilon_{r} = 18$ 的碳酸酯基电解质的 $\\lambda_{D}$ 值。取真空介电常数 $\\epsilon_{0} = 8.854187817 \\times 10^{-12} \\ \\mathrm{F \\, m^{-1}}$，玻尔兹曼常数 $k_{B} = 1.380649 \\times 10^{-23} \\ \\mathrm{J \\, K^{-1}}$，元电荷 $e = 1.602176634 \\times 10^{-19} \\ \\mathrm{C}$，以及阿伏伽德罗常数 $N_{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}}$。考虑两种微观结构：平均孔半径 $R_{\\mathrm{sep}} = 50 \\ \\mathrm{nm}$ 的隔膜和平均孔半径 $R_{\\mathrm{elec}} = 500 \\ \\mathrm{nm}$ 的电极。计算 $\\lambda_{D} / R_{\\mathrm{sep}}$ 和 $\\lambda_{D} / R_{\\mathrm{elec}}$ 这两个比率，并将两者中较大的一个作为最终答案报告，即\n$$\nr_{\\max} = \\max\\!\\left( \\frac{\\lambda_{D}}{R_{\\mathrm{sep}}}, \\frac{\\lambda_{D}}{R_{\\mathrm{elec}}} \\right).\n$$\n将您的最终答案四舍五入至三位有效数字。以无单位的无量纲数形式表示您的最终答案。",
            "solution": "该问题要求推导对称单价电解质的德拜长度 $\\lambda_{D}$，并随后使用一组与锂离子电池建模相关的特定参数进行数值计算。该过程从第一性原理开始，结合了静电学和统计力学。\n\n**第一部分：德拜长度 $\\lambda_{D}$ 的推导**\n\n推导从泊松方程开始，该方程将静电势 $\\phi$ 与局部净电荷密度 $\\rho_{e}$ 联系起来：\n$$\n\\nabla^2 \\phi = - \\frac{\\rho_{e}}{\\epsilon}\n$$\n此处，$\\epsilon$ 是电解质介质的绝对介电常数。\n\n对于对称单价电解质（1:1型电解质），电荷密度 $\\rho_{e}$ 来自于带电荷 $+e$ 的阳离子和带电荷 $-e$ 的阴离子。电荷密度由所有物种的电荷总和给出：\n$$\n\\rho_{e} = z_{+} e n_{+} + z_{-} e n_{-}\n$$\n其中 $n_{+}$ 和 $n_{-}$ 分别是阳离子和阴离子的局部数密度（单位体积内的离子数），$z_{+} = +1$ 和 $z_{-} = -1$ 是它们的化合价。因此：\n$$\n\\rho_{e} = e(n_{+} - n_{-})\n$$\n离子的局部数密度由麦克斯韦-玻尔兹曼分布描述，该分布将局部密度与局部势能 $z e \\phi$ 联系起来：\n$$\nn_{i} = n_{i, \\infty} \\exp\\left(-\\frac{z_{i} e \\phi}{k_{B} T}\\right)\n$$\n此处，$n_{i, \\infty}$ 是远离任何带电表面（其中 $\\phi \\rightarrow 0$）时物种 $i$ 的宏观数密度，$k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度。对于中性的宏观电解质，阳离子和阴离子的宏观数密度必须相等：$n_{+, \\infty} = n_{-, \\infty} = n_{\\infty}$。\n\n将麦克斯韦-玻尔兹曼分布应用于我们的系统：\n$$\nn_{+} = n_{\\infty} \\exp\\left(-\\frac{e \\phi}{k_{B} T}\\right)\n$$\n$$\nn_{-} = n_{\\infty} \\exp\\left(\\frac{e \\phi}{k_{B} T}\\right)\n$$\n将这些表达式代入电荷密度方程，得到：\n$$\n\\rho_{e} = e n_{\\infty} \\left[ \\exp\\left(-\\frac{e \\phi}{k_{B} T}\\right) - \\exp\\left(\\frac{e \\phi}{k_{B} T}\\right) \\right]\n$$\n问题指定使用小电势假设 $|z e \\phi| \\ll k_{B} T$。由于 $z = \\pm 1$，即 $|e \\phi| \\ll k_{B} T$。这允许我们使用泰勒级数展开 $\\exp(x) \\approx 1 + x$（对于小 $x$）来对指数函数进行线性化：\n$$\n\\exp\\left(-\\frac{e \\phi}{k_{B} T}\\right) \\approx 1 - \\frac{e \\phi}{k_{B} T}\n$$\n$$\n\\exp\\left(\\frac{e \\phi}{k_{B} T}\\right) \\approx 1 + \\frac{e \\phi}{k_{B} T}\n$$\n将这些近似值代入 $\\rho_{e}$ 的表达式中：\n$$\n\\rho_{e} \\approx e n_{\\infty} \\left[ \\left(1 - \\frac{e \\phi}{k_{B} T}\\right) - \\left(1 + \\frac{e \\phi}{k_{B} T}\\right) \\right] = e n_{\\infty} \\left(-\\frac{2e\\phi}{k_{B} T}\\right) = - \\frac{2 n_{\\infty} e^2}{k_{B} T} \\phi\n$$\n现在，我们将这个线性化的 $\\rho_{e}$ 表达式代回泊松方程，得到线性化的泊松-玻尔兹曼方程：\n$$\n\\nabla^2 \\phi = - \\frac{1}{\\epsilon} \\left( - \\frac{2 n_{\\infty} e^2}{k_{B} T} \\phi \\right) = \\left( \\frac{2 n_{\\infty} e^2}{\\epsilon k_{B} T} \\right) \\phi\n$$\n该方程的形式为 $\\nabla^2 \\phi = \\kappa^2 \\phi$，其中 $\\kappa^{-1}$ 是电势衰减的特征长度尺度。这个长度尺度被定义为德拜长度 $\\lambda_{D}$。因此，我们有：\n$$\n\\frac{1}{\\lambda_{D}^2} = \\frac{2 n_{\\infty} e^2}{\\epsilon k_{B} T} \\quad \\implies \\quad \\lambda_{D} = \\sqrt{\\frac{\\epsilon k_{B} T}{2 n_{\\infty} e^2}}\n$$\n问题要求用离子强度 $I$ 来表示表达式。对于一般电解质，离子强度用摩尔浓度 $c_i$ 定义为 $I = \\frac{1}{2} \\sum_i c_i z_i^2$。数密度 $n_i$ 和摩尔浓度 $c_i$ 通过 $n_i = c_i N_A$ 相关联。德拜长度平方倒数的一般表达式是 $\\lambda_D^{-2} = \\frac{e^2}{\\epsilon k_B T} \\sum_i n_{i,\\infty}z_i^2$。求和项可以与离子强度相关联：$\\sum_i n_{i,\\infty}z_i^2 = N_A \\sum_i c_{i,\\infty}z_i^2 = 2 N_A I$。将此代入一般表达式，得到：\n$$\n\\frac{1}{\\lambda_{D}^2} = \\frac{e^2}{\\epsilon k_{B} T} (2 N_{A} I) = \\frac{2 N_A e^2 I}{\\epsilon k_B T}\n$$\n求解 $\\lambda_{D}$ 得到所需的表达式：\n$$\n\\lambda_{D} = \\sqrt{\\frac{\\epsilon k_{B} T}{2 N_{A} e^2 I}}\n$$\n对于盐浓度为 $c_s$ 的对称 1:1 型电解质，$I=c_s$，因此我们在后续计算中使用此关系。\n\n**第二部分：数值计算**\n\n给定以下参数：\n-   相对介电常数: $\\epsilon_{r} = 18$\n-   温度: $T = 298 \\ \\mathrm{K}$\n-   宏观盐浓度: $c_{s} = 1.0 \\ \\mathrm{mol \\, L^{-1}}$。我们必须将其转换为国际单位制（SI）单位（$\\mathrm{mol \\, m^{-3}}$）。由于 $1 \\ \\mathrm{L} = 10^{-3} \\ \\mathrm{m^3}$，我们有 $c_{s} = \\frac{1.0 \\ \\mathrm{mol}}{10^{-3} \\ \\mathrm{m^3}} = 1000 \\ \\mathrm{mol \\, m^{-3}}$。由于 $I=c_s$，$I = 1000 \\ \\mathrm{mol \\, m^{-3}}$。\n-   真空介电常数: $\\epsilon_{0} = 8.854187817 \\times 10^{-12} \\ \\mathrm{F \\, m^{-1}}$\n-   玻尔兹曼常数: $k_{B} = 1.380649 \\times 10^{-23} \\ \\mathrm{J \\, K^{-1}}$\n-   元电荷: $e = 1.602176634 \\times 10^{-19} \\ \\mathrm{C}$\n-   阿伏伽德罗常数: $N_{A} = 6.02214076 \\times 10^{23} \\ \\mathrm{mol^{-1}}$\n\n首先，计算绝对介电常数 $\\epsilon$：\n$$\n\\epsilon = \\epsilon_{r} \\epsilon_{0} = 18 \\times (8.854187817 \\times 10^{-12} \\ \\mathrm{F \\, m^{-1}}) = 1.5937538... \\times 10^{-10} \\ \\mathrm{F \\, m^{-1}}\n$$\n现在，将所有值代入 $\\lambda_{D}$ 的表达式中：\n$$\n\\lambda_{D} = \\sqrt{\\frac{(1.59375... \\times 10^{-10}) \\times (1.380649 \\times 10^{-23}) \\times 298}{2 \\times (6.02214076 \\times 10^{23}) \\times (1.602176634 \\times 10^{-19})^2 \\times 1000}}\n$$\n分别计算分子和分母：\n$$\n\\mathrm{Numerator} = \\epsilon k_{B} T = (1.59375... \\times 10^{-10}) \\times (1.380649 \\times 10^{-23}) \\times 298 = 6.55683... \\times 10^{-31} \\ \\mathrm{J \\cdot F \\cdot m^{-1}}\n$$\n$$\n\\mathrm{Denominator} = 2 N_{A} e^2 I = 2 \\times (6.02214076 \\times 10^{23}) \\times (1.602176634 \\times 10^{-19})^2 \\times 1000 = 3.09163... \\times 10^{-11} \\ \\mathrm{C^2 \\cdot m^{-3}}\n$$\n现在，我们计算比值并取平方根：\n$$\n\\lambda_{D}^2 = \\frac{6.55683... \\times 10^{-31}}{3.09163... \\times 10^{-11}} = 2.12086... \\times 10^{-20} \\ \\mathrm{m^2}\n$$\n$$\n\\lambda_{D} = \\sqrt{2.12086... \\times 10^{-20}} = 1.45631... \\times 10^{-10} \\ \\mathrm{m}\n$$\n\n**第三部分：比率计算与最终答案**\n\n给定两种微观结构的平均孔半径：\n-   隔膜: $R_{\\mathrm{sep}} = 50 \\ \\mathrm{nm} = 50 \\times 10^{-9} \\ \\mathrm{m}$\n-   电极: $R_{\\mathrm{elec}} = 500 \\ \\mathrm{nm} = 500 \\times 10^{-9} \\ \\mathrm{m}$\n\n我们计算所需的比率：\n$$\n\\frac{\\lambda_{D}}{R_{\\mathrm{sep}}} = \\frac{1.45631... \\times 10^{-10} \\ \\mathrm{m}}{50 \\times 10^{-9} \\ \\mathrm{m}} = 0.0029126...\n$$\n$$\n\\frac{\\lambda_{D}}{R_{\\mathrm{elec}}} = \\frac{1.45631... \\times 10^{-10} \\ \\mathrm{m}}{500 \\times 10^{-9} \\ \\mathrm{m}} = 0.00029126...\n$$\n问题要求的是这两个比率中较大的一个，$r_{\\max}$：\n$$\nr_{\\max} = \\max\\left( \\frac{\\lambda_{D}}{R_{\\mathrm{sep}}}, \\frac{\\lambda_{D}}{R_{\\mathrm{elec}}} \\right) = \\max(0.0029126..., 0.00029126...) = 0.0029126...\n$$\n最后，将结果四舍五入到三位有效数字：\n$$\nr_{\\max} \\approx 0.00291\n$$\n用标准科学记数法表示，这是 $2.91 \\times 10^{-3}$。两个比率都远小于 1，这验证了在给定条件下这些微观结构中宏观电中性的假设是成立的。",
            "answer": "$$\\boxed{2.91 \\times 10^{-3}}$$"
        },
        {
            "introduction": "微观结构解析模型依赖于对电极复杂几何形状的精确数字表示。本练习提供了微观结构分析中一项核心任务的动手实践：量化电解质相的连通性。您将实现一个算法来计算逾渗分数，这是一个关键指标，用于确定离子传输路径是否存在于整个电极中，并分析其对图像分割阈值的敏感性。",
            "id": "3928283",
            "problem": "给定代表电池电极微观结构灰度信号的三维体素化样本，其中较高的强度值表示该体素为电解质相的可能性更高。对于给定的分割阈值，电解质相被定义为强度大于或等于该阈值的体素集合。我们关注的两个相对面是与第三轴（通常称为$z$轴）正交的面，即对于一个尺寸为$L_x \\times L_y \\times L_z$的体积，这两个平面分别是$z=0$和$z=L_z-1$。您的任务是构建一个算法，对于每个提供的样本和每组阈值，计算电解质相在这两个相对面之间的渗流分数，并量化其对分割阈值的灵敏度。\n\n请从以下基本定义出发：\n- 将体素晶格表示为一个图，其顶点为体素，其边连接在三维空间中共享一个面的体素（六邻域连通性）。也就是说，如果$|i-i'|+|j-j'|+|k-k'|=1$，则索引为$(i,j,k)$和$(i',j',k')$的体素是相邻的。\n- 给定一个阈值$\\tau$，定义二元指示符$I_{\\tau}(i,j,k)$，如果强度$A(i,j,k)$满足$A(i,j,k)\\ge \\tau$，则其值为$1$，否则为$0$。\n- 定义由$I_{\\tau}(i,j,k)=1$的顶点诱导的子图$G_{\\tau}$。使用六邻域连通性在$G_{\\tau}$中定义一个连通分量。\n- 在面$z=0$和$z=L_z-1$之间的一个渗流分量是$G_{\\tau}$中的任何一个连通分量，它至少包含一个$k=0$的体素和至少一个$k=L_z-1$的体素。\n- 渗流集$C_{\\tau}$是所有渗流分量的并集。渗流分数为\n$$\n\\mathrm{PF}(\\tau)=\n\\begin{cases}\n\\frac{|C_{\\tau}|}{|\\{(i,j,k): I_{\\tau}(i,j,k)=1\\}|},  \\text{若 } |\\{(i,j,k): I_{\\tau}(i,j,k)=1\\}|>0,\\\\\n0,  \\text{其它情况}.\n\\end{cases}\n$$\n- 对于一个严格递增的阈值列表$\\{\\tau_0,\\tau_1,\\ldots,\\tau_{N-1}\\}$，使用有限差分定义在$\\tau_i$处的灵敏度：\n$$\nS(\\tau_i)=\n\\begin{cases}\n\\frac{\\mathrm{PF}(\\tau_{i+1})-\\mathrm{PF}(\\tau_i)}{\\tau_{i+1}-\\tau_i},  \\text{若 } i=0 \\text{ 且 } N\\ge 2,\\\\\n\\frac{\\mathrm{PF}(\\tau_{i+1})-\\mathrm{PF}(\\tau_{i-1})}{\\tau_{i+1}-\\tau_{i-1}},  \\text{若 } 0",
            "solution": "用户提供了一个问题，要求计算三维体素化微观结构的渗流分数及其对分割阈值的灵敏度。该问题定义明确，具有渗流理论和计算材料科学的科学基础，并提供了所有必要的定义和数据。因此，该问题被认为是有效的。\n\n问题的核心是识别贯穿3D体积两个相对面的电解质相的连通路径。这是一个在网格图上的经典连通分量问题。将遵循直接从所提供定义中推导出的、有原则的、循序渐进的算法来实现解决方案。\n\n首先，我们必须建立一个一致的坐标系。问题指定了一个尺寸为$L_x \\times L_y \\times L_z$的体积，体素由$(i,j,k)$索引。我们关注的面与第三轴$k$正交，位于$k=0$和$k=L_z-1$处。我们将使用三维NumPy数组来表示体积数据$A(i,j,k)$。将3D数据切片映射到NumPy数组的标准约定是使用形状$(L_z, L_y, L_x)$，其中第一个索引对应于切片索引。因此，我们将通过 `A[k, j, i]` 来访问与空间坐标$(x,y,z)$关联的体素$(i,j,k)$的强度。\n\n对于每个测试用例（由一个体积$A$和一组阈值$\\{\\tau_0, \\tau_1, \\ldots, \\tau_{N-1}\\}$组成），算法按以下步骤进行：\n\n1.  **遍历阈值以计算渗流分数**：对于集合中的每个阈值$\\tau_m$，我们计算渗流分数$\\mathrm{PF}(\\tau_m)$。\n    -   **二值化**：我们首先将灰度体积$A$分割成一个二元体积$B$。根据$I_{\\tau}(i,j,k)$的定义，如果体素$(i,j,k)$的强度$A(i,j,k)$大于或等于阈值$\\tau_m$，则该体素属于电解质相。这将生成一个二元数组，其中如果$A[k,j,i] \\ge \\tau_m$，则$B[k,j,i] = 1$，否则为$0$。\n    -   **处理空相**：如果电解质体素的总数 $|\\{(i,j,k): I_{\\tau_m}(i,j,k)=1\\}|$ 为零，则根据定义，渗流分数$\\mathrm{PF}(\\tau_m)$为$0$。算法继续处理下一个阈值。\n    -   **连通分量标记**：为了找到电解质相中的连通分量，我们利用 `scipy.ndimage.label` 函数。该函数能高效地识别并标记数组中所有非零体素的连通簇。我们通过使用由 `scipy.ndimage.generate_binary_structure(3, 1)` 生成的结构元素来指定六邻域连通性，这对应于问题陈述所要求的共享面的邻居：$|i-i'|+|j-j'|+|k-k'|=1$。该函数返回一个 `labeled_array`，其中每个不同的分量都用一个唯一的正整数标签标记，并返回找到的分量数量 `num_features`。\n    -   **识别渗流分量**：如果一个分量从$z=0$面延伸到$z=L_z-1$面，则该分量被定义为渗流分量。在我们的$(L_z, L_y, L_x)$数组结构中，这些面对应于切片 `labeled_array[0, :, :]` 和 `labeled_array[L_z-1, :, :]`。我们识别出在$z=0$面上存在的唯一分量标签和在$z=L_z-1$面上存在的唯一标签。渗流标签的集合是这两组标签的交集（不包括背景标签$0$）。\n    -   **计算渗流分数 $\\mathrm{PF}(\\tau_m)$**：渗流集$C_{\\tau_m}$是属于已识别的渗流分量的所有体素的并集。其大小$|C_{\\tau_m}|$通过计算 `labeled_array` 中具有渗流标签的体素总数来找到。然后使用提供的公式计算渗流分数：\n        $$\n        \\mathrm{PF}(\\tau_m) = \\frac{|C_{\\tau_m}|}{|\\{(i,j,k): I_{\\tau_m}(i,j,k)=1\\}|}\n        $$\n\n2.  **计算灵敏度**：在计算出渗流分数列表$[\\mathrm{PF}(\\tau_0), \\mathrm{PF}(\\tau_1), \\ldots, \\mathrm{PF}(\\tau_{N-1})]$之后，我们为每个阈值计算灵敏度$S(\\tau_i)$。计算严格遵循提供的有限差分格式：\n    -   对于$N=1$，$S(\\tau_0) = 0$。\n    -   对于$N \\ge 2$：\n        -   在第一个点$i=0$（前向差分）：$S(\\tau_0) = \\frac{\\mathrm{PF}(\\tau_1)-\\mathrm{PF}(\\tau_0)}{\\tau_1-\\tau_0}$。\n        -   对于内部点$0",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label, generate_binary_structure\n\ndef compute_percolating_fraction(volume, threshold):\n    \"\"\"\n    Computes the percolating fraction for a given volume and threshold.\n    \n    Args:\n        volume (np.ndarray): The 3D voxelized data.\n        threshold (float): The segmentation threshold.\n        \n    Returns:\n        float: The percolating fraction PF(tau).\n    \"\"\"\n    # Binarize the volume based on the threshold\n    # A voxel is electrolyte if its intensity is >= threshold\n    binary_volume = (volume >= threshold).astype(int)\n    \n    total_electrolyte_voxels = np.sum(binary_volume)\n    \n    # If no electrolyte phase, PF is 0 by definition\n    if total_electrolyte_voxels == 0:\n        return 0.0\n        \n    # Define 6-neighbor connectivity (face-sharing)\n    # This is connectivity=1 in SciPy's terms for a 3D structure\n    structure = generate_binary_structure(3, 1)\n    \n    # Find and label all connected components\n    # The shape of the volume is assumed (Lz, Ly, Lx)\n    labeled_volume, num_features = label(binary_volume, structure=structure)\n    \n    if num_features == 0:\n        return 0.0\n        \n    # Identify component labels on the z=0 and z=Lz-1 faces\n    z_dim = volume.shape[0]\n    labels_at_z0 = np.unique(labeled_volume[0, :, :])\n    labels_at_z_end = np.unique(labeled_volume[z_dim - 1, :, :])\n    \n    # Filter out the background label 0\n    labels_at_z0 = labels_at_z0[labels_at_z0 != 0]\n    labels_at_z_end = labels_at_z_end[labels_at_z_end != 0]\n    \n    # Find labels present on both faces (percolating components)\n    percolating_labels = np.intersect1d(labels_at_z0, labels_at_z_end, assume_unique=True)\n    \n    if percolating_labels.size == 0:\n        return 0.0\n        \n    # Calculate the total size of all percolating components |C_tau|\n    percolating_set_mask = np.isin(labeled_volume, percolating_labels)\n    percolating_voxels_count = np.sum(percolating_set_mask)\n    \n    # Compute the percolating fraction\n    pf = percolating_voxels_count / total_electrolyte_voxels\n    \n    return pf\n\ndef compute_sensitivity(pf_values, thresholds):\n    \"\"\"\n    Computes the sensitivity of the percolating fraction to the threshold.\n    \n    Args:\n        pf_values (list): A list of percolating fraction values.\n        thresholds (list): A list of corresponding thresholds.\n        \n    Returns:\n        list: A list of sensitivity values S(tau).\n    \"\"\"\n    N = len(thresholds)\n    if N == 0:\n        return []\n    if N == 1:\n        return [0.0]\n        \n    sensitivities = []\n    \n    # i = 0 (forward difference)\n    s_0 = (pf_values[1] - pf_values[0]) / (thresholds[1] - thresholds[0])\n    sensitivities.append(s_0)\n    \n    # 0  i  N-1 (central difference)\n    for i in range(1, N - 1):\n        s_i = (pf_values[i + 1] - pf_values[i - 1]) / (thresholds[i + 1] - thresholds[i - 1])\n        sensitivities.append(s_i)\n        \n    # i = N-1 (backward difference)\n    s_last = (pf_values[N - 1] - pf_values[N - 2]) / (thresholds[N - 1] - thresholds[N - 2])\n    sensitivities.append(s_last)\n    \n    return sensitivities\n\ndef solve():\n    \"\"\"\n    Main solver function to process all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # The volumes are structured as numpy arrays with shape (Lz, Ly, Lx)\n    test_cases = [\n        (\n            np.array([\n                [[0.9, 0.1, 0.1], [0.1, 0.9, 0.1], [0.1, 0.1, 0.1]], # k=0\n                [[0.1, 0.1, 0.1], [0.1, 0.65, 0.1], [0.1, 0.1, 0.1]], # k=1\n                [[0.1, 0.1, 0.1], [0.1, 0.9, 0.1], [0.1, 0.1, 0.9]]  # k=2\n            ]),\n            [0.2, 0.6, 0.8]\n        ),\n        (\n            np.full((3, 3, 3), 0.0),\n            [0.2, 0.6, 0.8]\n        ),\n        (\n            np.full((3, 3, 3), 1.0),\n            [0.2, 0.6, 0.8]\n        )\n    ]\n\n    all_results = []\n    for volume, thresholds in test_cases:\n        pf_results = [compute_percolating_fraction(volume, t) for t in thresholds]\n        s_results = compute_sensitivity(pf_results, thresholds)\n        \n        # Rounding for consistent float representation\n        pf_results_rounded = [round(p, 4) for p in pf_results]\n        s_results_rounded = [round(s, 4) for s in s_results]\n\n        all_results.append([pf_results_rounded, s_results_rounded])\n\n    # Convert final results to string, respecting the specified format\n    # Using str() on lists produces the required '[...]' format.\n    # The join then assembles the outer list.\n    results_str =','.join(map(str, all_results))\n    print(f\"[{results_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦物理原理被定义、几何结构被表征，最后的步骤就是求解控制输运的方程。这项高级实践解决了一个在模拟真实微观结构时的关键挑战：如何处理孤立的、非逾渗的电解质区域以确保全局电荷守恒。您将开发一种有限体积法，该方法能够将边界条件正确地应用于复杂域，为精确的电化学模拟提供坚实的基础。",
            "id": "3928365",
            "problem": "您的任务是为多孔电池电极电解质域中的微观结构解析电导问题建立边界条件，以确保即使当部分电解质被孤立孔隙和非贯通区域隔离时，全局电荷守恒也始终得到满足。基本依据必须是具有线性本构行为的稳态离子电荷守恒定律：\n\n- 稳态守恒定律由离子电流密度的散度在电解质体相中等于零给出，其中不存在体源：$$\\nabla \\cdot \\mathbf{j}_e = 0.$$\n- 离子电流密度通过线性本构关系与电解质电势相关联：$$\\mathbf{j}_e = -\\kappa \\nabla \\phi_e,$$ 其中 $\\kappa$ 是离子电导率（单位为 $\\mathrm{S/m}$），$\\phi_e$ 是电解质电势（单位为 $\\mathrm{V}$）。\n- 在发生电化学反应的固-电解质界面上，施加一个线性化的类Butler-Volmer边界条件（Robin型），该条件将法向通量与过电势关联起来：$$-\\mathbf{n} \\cdot \\mathbf{j}_e = k \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right),$$ 其中 $k$ 是界面反应电导（单位为 $\\mathrm{A/(m^2 \\cdot V)}$），$\\phi_{\\mathrm{eq}}$ 是平衡电势（单位为 $\\mathrm{V}$），$\\mathbf{n}$ 是电解质域的外向单位法向量。\n- 在外部储库边界上，强制执行Dirichlet条件：$$\\phi_e = \\phi_{\\mathrm{L}} \\text{ 在左边界上,} \\quad \\phi_e = \\phi_{\\mathrm{R}} \\text{ 在右边界上},$$ 其中 $\\phi_{\\mathrm{L}}$ 和 $\\phi_{\\mathrm{R}}$ 的单位为 $\\mathrm{V}$。\n- 在非反应边界上（例如，如果指定为不导电的域的顶部和底部），强制执行零通量Neumann条件：$$-\\mathbf{n} \\cdot \\mathbf{j}_e = 0.$$\n\n不贯通到任何储库边界的孤立电解质组分，其与固相的净离子交换必须为零；也就是说，必须通过在其所有固相界面上设置 $k=0$ 来停用那里的反应边界条件。这强制要求没有净电荷能够进入或离开那些孤立区域，这是全局电荷守恒所要求的。\n\n构建一个纯粹的数学和算法流程，该流程：\n1. 识别相连的电解质组分，并确定哪些组分贯通到左侧或右侧的储库。\n2. 使用在均匀笛卡尔网格上的有限体积离散化方法，组装并求解得到的关于 $\\phi_e$ 的线性系统。网格单元尺寸为 $dx$（单位为 $\\mathrm{m}$），平面外厚度为 $t$（单位为 $\\mathrm{m}$），其中每个面的传导率为 $$T = \\kappa \\, t.$$ 每个电解质-固相界面的反应通量贡献为 $$F_{\\mathrm{rxn}} = k \\, t \\, dx \\, \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right).$$\n3. 在所有与孤立电解质组分相邻的固相界面上强制 $k=0$。\n4. 计算全局守恒残差，定义为所有电解质边界外通量和所有反应外通量的代数和：\n   $$\\mathcal{R} = \\sum_{\\text{reservoir faces}} T \\left(\\phi_e - \\phi_{\\mathrm{res}}\\right) + \\sum_{\\text{reactive faces}} k \\, t \\, dx \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right),$$\n   其中 $\\phi_{\\mathrm{res}}$ 根据储库面是 $\\phi_{\\mathrm{L}}$ 或 $\\phi_{\\mathrm{R}}$。由于内部面通量的抵消和稳态守恒定律，当边界条件一致时，量 $\\mathcal{R}$ 在数值上必须接近于零。\n\n程序必须为一组二维微观结构掩模实现上述过程，将顶部和底部边界视为零通量Neumann边界。平面外厚度 $t$ 必须用于将面通量密度转换为电流，因此所有电流的单位都是 $\\mathrm{A}$。如果任何电解质组分完全孤立（没有储库接触，也没有反应界面，因为 $k$ 被设置为零），则在该组分中直接指定 $\\phi_e = \\phi_{\\mathrm{eq}}$，以避免奇异性，而不引入任何人为通量。\n\n物理单位和参数：\n- $\\kappa$ 的单位是 $\\mathrm{S/m}$；使用 $\\kappa = 1.0 \\, \\mathrm{S/m}$。\n- $k$ 的单位是 $\\mathrm{A/(m^2 \\cdot V)}$；对于贯通组分的反应界面，使用 $k = 1.0 \\times 10^{6} \\, \\mathrm{A/(m^2 \\cdot V)}$，对于孤立组分，使用 $k = 0$。\n- $dx = 1.0 \\times 10^{-5} \\, \\mathrm{m}$（网格单元尺寸）。\n- $t = 5.0 \\times 10^{-6} \\, \\mathrm{m}$（平面外厚度）。\n- $\\phi_{\\mathrm{eq}} = 0.0 \\, \\mathrm{V}$，$\\phi_{\\mathrm{L}} = 0.1 \\, \\mathrm{V}$，$\\phi_{\\mathrm{R}} = 0.0 \\, \\mathrm{V}$。\n\n角度单位不适用。所有输出电流必须以 $\\mathrm{A}$ 表示。\n\n测试套件：\n- 案例1（理想情况）：网格尺寸 $8 \\times 6$；沿中间行的贯通电解质通道连接左右储库；通道外有额外的孤立区域。期望全局残差接近 $0 \\, \\mathrm{A}$。\n- 案例2（孤立边缘情况）：网格尺寸 $5 \\times 5$；一个不接触任何储库的单单元孤立电解质区域；反应被停用。期望残差恰好为 $0 \\, \\mathrm{A}$。\n- 案例3（仅左侧贯通）：网格尺寸 $7 \\times 6$；一个电解质区域仅接触左侧储库，在到达右边界之前终止；其固相界面上的反应是活动的。期望残差接近 $0 \\, \\mathrm{A}$。\n- 案例4（窄路径边界情况）：网格尺寸 $3 \\times 3$；一个横跨中间行的单单元宽度的电解质路径连接左右储库；反应是活动的。期望残差接近 $0 \\, \\mathrm{A}$。\n\n您的程序必须生成单行输出，其中包含四个案例的全局残差，格式为方括号括起来的逗号分隔列表，例如，“[r1,r2,r3,r4]”。列表中的每个条目必须是单位为 $\\mathrm{A}$ 的浮点数。不应打印任何额外文本。",
            "solution": "所提出的问题是一个定义明确的电化学边界值问题，其基础是稳态电荷守恒的基本原理。它要求解一个线性椭圆型偏微分方程，特别是关于电解质电势 $\\phi_e$ 的拉普拉斯方程，该方程受Dirichlet、Neumann和Robin边界条件的组合约束。该问题在科学上和数学上都是合理的。\n\n核心挑战在于在一个具有复杂、可能不连通的微观结构的域中满足全局电荷守恒。未连接到外部电流储库的电解质区域（即非贯通组分）不能作为电荷的净源或净汇。该问题通过要求这些孤立区域与固相的净离子交换为零，正确地形式化了这一物理约束。这是通过在其边界上将界面反应电导 $k$ 设置为 $0$ 来停用电化学反应实现的。此过程不是任意简化，而是确保问题在物理上有意义且在数学上适定的必要条件。\n\n如果一个电解质组分完全与两个储库和所有反应性固相界面断开（无论是由于几何形状还是因为 $k$ 已被设置为 $0$），其电势 $\\phi_e$ 仅能确定到一个相加常数。该问题通过规定在这些区域中 $\\phi_e = \\phi_{\\mathrm{eq}}$ 来解决这种模糊性，这是一个物理上合理的选择，它将电势设置为一个不存在净反应驱动力的参考值，从而确保不会引入人为通量，并且得到的线性系统不是奇异的。\n\n解决方案将按规定，使用在均匀笛卡尔网格上的有限体积法（FVM）来实现。该方法本身是守恒的，因此非常适合解决此问题。总体算法如下：\n\n1.  **组分识别**：离散的微观结构被视为一个图，其中电解质单元是节点，相邻的电解质单元共享一条边。采用图遍历算法，如广度优先搜索（BFS），来识别电解质相内的所有连通组分。对于每个组分，我们确定它是否贯通到左侧储库（列 $j=0$）、右侧储库（列 $j=N-1$），或两者都不是。如果一个组分至少连接到一个储库，则认为它是“贯通的”。\n\n2.  **线性系统组装**：构建一个形式为 $\\mathbf{A}\\boldsymbol{\\phi} = \\mathbf{b}$ 的线性方程组，其中 $\\boldsymbol{\\phi}$ 是每个电解质单元中心的未知电势向量。矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$ 是通过将守恒定律应用于每个电解质单元（控制体）来组装的。\n    - 对于属于非贯通组分的电解质单元 $p$，没有参考点，其电势是不确定的。我们通过创建一个平凡方程 $1 \\cdot \\phi_p = \\phi_{\\mathrm{eq}}$ 来强制执行条件 $\\phi_p = \\phi_{\\mathrm{eq}}$。这将 $\\mathbf{A}$ 中对应的行在对角线上设置为 $1$，其他位置为 $0$，并将 $\\mathbf{b}$ 中对应的条目设置为 $\\phi_{\\mathrm{eq}}$。\n    - 对于贯通组分中的电解质单元 $p$，通过对其四个面流出的所有电流求和来建立FVM方程。\n        - **传导通量**：流向相邻电解质单元 $q$ 的电流为 $I_{p \\to q} = T (\\phi_p - \\phi_q)$，其中 $T = \\kappa t$ 是面传导率。\n        - **反应通量**：流向相邻固相单元的电流为 $I_{p \\to \\text{solid}} = k \\, t \\, dx (\\phi_p - \\phi_{\\mathrm{eq}})$。这里，$k > 0$ 因为该组分是贯通的。\n        - **储库通量**：流向相邻储库（例如，左侧）的电流为 $I_{p \\to \\text{res}} = T (\\phi_p - \\phi_{\\mathrm{L}})$。\n        - **Neumann边界通量**：跨越非反应（例如，顶部/底部）边界的电流为零。\n    单元 $p$ 的FVM方程为 $\\sum_{\\text{faces}} I_{\\text{out}} = 0$。将包含未知电势的项组合在左侧，常数项组合在右侧，即可得到系统 $\\mathbf{A}\\boldsymbol{\\phi} = \\mathbf{b}$ 的第 $p$ 行。\n\n3.  **系统求解**：得到的线性系统是大型稀疏矩阵。使用稀疏线性代数求解器可以高效地求解 $\\boldsymbol{\\phi}$。\n\n4.  **残差计算**：获得电势场 $\\phi_e$ 后，通过对穿过域外部边界（储库和反应界面）的所有电流求和来计算全局守恒残差 $\\mathcal{R}$，使用提供的公式：\n    $$\\mathcal{R} = \\sum_{\\text{reservoir faces}} T \\left(\\phi_e - \\phi_{\\mathrm{res}}\\right) + \\sum_{\\text{reactive faces}} k \\, t \\, dx \\left(\\phi_e - \\phi_{\\mathrm{eq}}\\right)$$\n    此总和中的反应电导 $k$ 是模拟中使用的有效值（对于贯通组分 $k > 0$，对于孤立组分 $k=0$）。根据FVM的原理，如果问题被正确地建立和求解，这个总和在数值上必须接近于零。\n\n这个系统化的流程保证了对于任意微观结构，全局电荷守恒都得到遵守，正确处理了孤立域的物理和数学复杂性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Validates and solves the microstructure-resolved conduction problem.\n    \"\"\"\n    \n    # --- PHYSICAL PARAMETERS ---\n    KAPPA = 1.0  # S/m\n    K_RXN = 1.0e6  # A/(m^2 * V)\n    DX = 1.0e-5  # m\n    T_THICKNESS = 5.0e-6  # m\n    PHI_EQ = 0.0  # V\n    PHI_L = 0.1  # V\n    PHI_R = 0.0  # V\n\n    T = KAPPA * T_THICKNESS  # Transmissibility (S)\n\n    # --- TEST SUITE DEFINITION ---\n    # 1: electrolyte, 0: solid\n    case1_grid = np.zeros((8, 6), dtype=int)\n    case1_grid[3:5, :] = 1  # Percolating channel\n    case1_grid[0:2, 0:2] = 1 # Isolated pocket\n\n    case2_grid = np.zeros((5, 5), dtype=int)\n    case2_grid[2, 2] = 1  # Single isolated cell\n\n    case3_grid = np.zeros((7, 6), dtype=int)\n    case3_grid[2:5, 0:3] = 1 # Left-only percolation\n\n    case4_grid = np.zeros((3, 3), dtype=int)\n    case4_grid[1, :] = 1 # Thin percolating path\n\n    test_cases = [\n        {\"grid\": case1_grid},\n        {\"grid\": case2_grid},\n        {\"grid\": case3_grid},\n        {\"grid\": case4_grid},\n    ]\n\n    results = []\n    \n    for case_data in test_cases:\n        grid = case_data[\"grid\"]\n        M, N = grid.shape\n\n        # Step 1: Identify connected components using BFS\n        visited = np.zeros_like(grid, dtype=bool)\n        component_map = np.full_like(grid, -1, dtype=int)\n        component_props = []\n        component_id_counter = 0\n\n        for r_start in range(M):\n            for c_start in range(N):\n                if grid[r_start, c_start] == 1 and not visited[r_start, c_start]:\n                    q = deque([(r_start, c_start)])\n                    visited[r_start, c_start] = True\n                    \n                    is_left_percolating = False\n                    is_right_percolating = False\n                    \n                    while q:\n                        r, c = q.popleft()\n                        component_map[r, c] = component_id_counter\n                        if c == 0:\n                            is_left_percolating = True\n                        if c == N - 1:\n                            is_right_percolating = True\n                        \n                        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                            nr, nc = r + dr, c + dc\n                            if 0 = nr  M and 0 = nc  N and grid[nr, nc] == 1 and not visited[nr, nc]:\n                                visited[nr, nc] = True\n                                q.append((nr, nc))\n                    \n                    is_percolating = is_left_percolating or is_right_percolating\n                    component_props.append({\"percolating\": is_percolating})\n                    component_id_counter += 1\n\n        # Map electrolyte cell coordinates to linear system indices\n        electrolyte_cells = np.argwhere(grid == 1)\n        num_vars = len(electrolyte_cells)\n        coord_to_idx = {tuple(coord): i for i, coord in enumerate(electrolyte_cells)}\n\n        if num_vars == 0:\n            results.append(0.0)\n            continue\n            \n        # Step 2: Assemble the linear system A*phi = b\n        A = lil_matrix((num_vars, num_vars), dtype=float)\n        b = np.zeros(num_vars, dtype=float)\n\n        for idx, (r, c) in enumerate(electrolyte_cells):\n            comp_id = component_map[r, c]\n            is_percolating = component_props[comp_id][\"percolating\"]\n\n            if not is_percolating:\n                # Enforce phi_e = phi_eq for non-percolating components\n                A[idx, idx] = 1.0\n                b[idx] = PHI_EQ\n                continue\n\n            # Assemble FVM equation for percolating cells\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n\n                # Neighbor is a boundary\n                if not (0 = nr  M and 0 = nc  N):\n                    # Left reservoir boundary\n                    if nc  0:\n                        A[idx, idx] += T\n                        b[idx] += T * PHI_L\n                    # Right reservoir boundary\n                    elif nc >= N:\n                        A[idx, idx] += T\n                        b[idx] += T * PHI_R\n                    # Top/Bottom are Neumann (zero flux), no contribution\n                else:\n                    # Neighbor is an electrolyte cell\n                    if grid[nr, nc] == 1:\n                        neighbor_idx = coord_to_idx[(nr, nc)]\n                        A[idx, idx] += T\n                        A[idx, neighbor_idx] -= T\n                    # Neighbor is a solid (reactive boundary)\n                    else:\n                        A[idx, idx] += K_RXN * T_THICKNESS * DX\n                        b[idx] += K_RXN * T_THICKNESS * DX * PHI_EQ\n\n        # Step 3: Solve the system\n        A = A.tocsr()\n        phi_vec = spsolve(A, b)\n\n        # Create a potential grid for easier residual calculation\n        potential_grid = np.full_like(grid, np.nan, dtype=float)\n        for idx, (r, c) in enumerate(electrolyte_cells):\n            potential_grid[r, c] = phi_vec[idx]\n            \n        # Step 4: Compute global conservation residual\n        residual = 0.0\n        for r, c in electrolyte_cells:\n            phi_p = potential_grid[r, c]\n            \n            # Reservoir fluxes\n            if c == 0:\n                residual += T * (phi_p - PHI_L)\n            if c == N - 1:\n                residual += T * (phi_p - PHI_R)\n\n            # Reaction fluxes\n            k_eff = 0.0\n            comp_id = component_map[r,c]\n            if component_props[comp_id][\"percolating\"]:\n                k_eff = K_RXN\n\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if 0 = nr  M and 0 = nc  N and grid[nr, nc] == 0:\n                     residual += k_eff * T_THICKNESS * DX * (phi_p - PHI_EQ)\n\n        results.append(residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}