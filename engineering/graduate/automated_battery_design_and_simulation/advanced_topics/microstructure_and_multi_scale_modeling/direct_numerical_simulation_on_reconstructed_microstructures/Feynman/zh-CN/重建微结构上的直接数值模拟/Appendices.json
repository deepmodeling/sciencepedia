{
    "hands_on_practices": [
        {
            "introduction": "直接数值模拟的第一步是将从计算机断层扫描（CT）等技术获得的灰度图像转化为清晰的数字几何模型。这个过程，即图像分割，对于后续模拟的准确性至关重要。本练习将引导您实践Otsu方法，这是一种强大且客观的自动化阈值选择技术，它通过最大化类间方差来寻找最佳分割阈值，从而将孔隙相和固相精确地区分开来。通过完成这个练习，您将掌握从原始图像数据中提取高质量微结构信息的关键技能。",
            "id": "3907165",
            "problem": "一幅由X射线计算机断层扫描（XCT）重建的多孔锂离子电池正极的灰度微观结构图像需要被分割为孔隙相和固相，以便进行离子输运的直接数值模拟（DNS）。分割通过对$8$位灰度强度应用单个全局阈值来执行，从而将所有强度$\\leq t$的体素分配给孔隙相，所有强度$> t$的体素分配给固相。观察到的灰度直方图是双峰的，并且仅在以下$8$个灰度级上具有非零计数：$(g_i, n_i)$对为$(30, 400)$, $(60, 800)$, $(90, 1200)$, $(120, 600)$, $(150, 300)$, $(180, 600)$, $(210, 900)$, $(240, 450)$，其中$g_i$是灰度级，$n_i$是该灰度级的体素数。\n\n仅从离散分布的概率、均值和方差的定义出发，并利用总方差可以写为类内和类间贡献之和的方差分解恒等式，推导Otsu法中通过最大化阈值化引起的两个类别的类间方差来选择最佳阈值$t$的准则。然后，将推导出的准则应用于所提供的直方图，以在候选灰度级$t \\in \\{30, 60, 90, 120, 150, 180, 210\\}$中确定最大化类间方差的唯一阈值$t^{\\star}$。\n\n将最终阈值表示为一个$8$位尺度上的整数灰度级。无需四舍五入。",
            "solution": "本任务是首先推导用于图像阈值分割的Otsu法的准则，然后将其应用于给定的直方图以找到最佳阈值。\n\n### 第1部分：Otsu法准则的推导\n\n设离散灰度级用$i$表示，其中$i \\in \\{0, 1, \\dots, L-1\\}$。对于$8$位图像，$L=256$。设$n_i$是图像中灰度级为$i$的体素数，设$N$是总的体素数，$N = \\sum_{i=0}^{L-1} n_i$。\n\n根据离散分布的概率定义，一个体素具有灰度级$i$的概率是：\n$$\np_i = \\frac{n_i}{N}\n$$\n这些概率满足$\\sum_{i=0}^{L-1} p_i = 1$。\n\n根据离散分布的均值定义，图像的总平均灰度级是：\n$$\n\\mu_T = \\sum_{i=0}^{L-1} i \\cdot p_i\n$$\n\n灰度级为$t$的阈值将体素划分为两类：\n- 类别1 ($C_1$)：孔隙相，包含灰度级为$\\{0, 1, \\dots, t\\}$的体素。\n- 类别2 ($C_2$)：固相，包含灰度级为$\\{t+1, \\dots, L-1\\}$的体素。\n\n一个随机选择的体素属于类别1的概率$\\omega_1(t)$，是$C_1$中各灰度级概率的总和：\n$$\n\\omega_1(t) = P(C_1) = \\sum_{i=0}^{t} p_i\n$$\n类似地，属于类别2的概率$\\omega_2(t)$是：\n$$\n\\omega_2(t) = P(C_2) = \\sum_{i=t+1}^{L-1} p_i\n$$\n由此可得 $\\omega_1(t) + \\omega_2(t) = 1$。\n\n每个类别的平均灰度级按条件期望计算：\n$$\n\\mu_1(t) = \\frac{\\sum_{i=0}^{t} i \\cdot p_i}{\\omega_1(t)} \\quad \\text{和} \\quad \\mu_2(t) = \\frac{\\sum_{i=t+1}^{L-1} i \\cdot p_i}{\\omega_2(t)}\n$$\n总均值$\\mu_T$可以表示为类别均值的加权平均：$\\mu_T = \\omega_1(t)\\mu_1(t) + \\omega_2(t)\\mu_2(t)$。\n\n问题陈述我们必须使用方差分解恒等式，它将图像灰度级分布的总方差$\\sigma_T^2$表示为两个分量的和：类内方差$\\sigma_W^2(t)$和类间方差$\\sigma_B^2(t)$。\n$$\n\\sigma_T^2 = \\sigma_W^2(t) + \\sigma_B^2(t)\n$$\n总方差$\\sigma_T^2 = \\sum_{i=0}^{L-1} (i - \\mu_T)^2 p_i$对于给定图像是一个常数，不依赖于阈值$t$。\n\n类内方差$\\sigma_W^2(t)$是各类方差的加权平均：$\\sigma_W^2(t) = \\omega_1(t)\\sigma_1^2(t) + \\omega_2(t)\\sigma_2^2(t)$，其中$\\sigma_1^2(t)$和$\\sigma_2^2(t)$分别是$C_1$和$C_2$内部的方差。它衡量了类别内部的同质性。好的分割应该产生同质的类别，因此目标是最小化$\\sigma_W^2(t)$。\n\n类间方差$\\sigma_B^2(t)$定义为：\n$$\n\\sigma_B^2(t) = \\omega_1(t)(\\mu_1(t) - \\mu_T)^2 + \\omega_2(t)(\\mu_2(t) - \\mu_T)^2\n$$\n这衡量了两个类别之间的可分离性。\n\n由于$\\sigma_T^2$是常数，最小化类内方差$\\sigma_W^2(t)$在数学上等同于最大化类间方差$\\sigma_B^2(t)$。Otsu法正是基于此原理定义的。因此，选择最佳阈值$t^\\star$的准则是最大化类间方差：\n$$\nt^\\star = \\arg\\max_{t} \\left\\{ \\sigma_B^2(t) \\right\\}\n$$\n为了计算方便，$\\sigma_B^2(t)$的表达式可以被简化。使用$\\mu_T = \\omega_1\\mu_1 + \\omega_2\\mu_2$和$\\omega_1+\\omega_2=1$：\n$$\n\\begin{align*} \\sigma_B^2(t) = \\omega_1(\\mu_1 - (\\omega_1\\mu_1 + \\omega_2\\mu_2))^2 + \\omega_2(\\mu_2 - (\\omega_1\\mu_1 + \\omega_2\\mu_2))^2 \\\\ = \\omega_1((1-\\omega_1)\\mu_1 - \\omega_2\\mu_2)^2 + \\omega_2(-\\omega_1\\mu_1 + (1-\\omega_2)\\mu_2)^2 \\\\ = \\omega_1(\\omega_2\\mu_1 - \\omega_2\\mu_2)^2 + \\omega_2(-\\omega_1\\mu_1 + \\omega_1\\mu_2)^2 \\\\ = \\omega_1\\omega_2^2(\\mu_1 - \\mu_2)^2 + \\omega_2\\omega_1^2(\\mu_1 - \\mu_2)^2 \\\\ = (\\omega_1\\omega_2^2 + \\omega_2\\omega_1^2)(\\mu_1 - \\mu_2)^2 \\\\ = \\omega_1\\omega_2(\\omega_2 + \\omega_1)(\\mu_1 - \\mu_2)^2 \\\\ = \\omega_1(t)\\omega_2(t)(\\mu_1(t) - \\mu_2(t))^2 \\end{align*}\n$$\n准则的推导至此完成。\n\n### 第2部分：应用于给定数据\n\n提供的直方图数据为：\n$(g_i, n_i) \\in \\{(30, 400), (60, 800), (90, 1200), (120, 600), (150, 300), (180, 600), (210, 900), (240, 450)\\}$.\n\n首先，我们计算总的体素数$N$：\n$$\nN = 400 + 800 + 1200 + 600 + 300 + 600 + 900 + 450 = 5250\n$$\n总的一阶矩（$g_i \\cdot n_i$的和）是：\n$$\nM_T = (30)(400) + (60)(800) + (90)(1200) + (120)(600) + (150)(300) + (180)(600) + (210)(900) + (240)(450)\n$$\n$$\nM_T = 12000 + 48000 + 108000 + 72000 + 45000 + 108000 + 189000 + 108000 = 690000\n$$\n我们将测试每个候选阈值$t \\in \\{30, 60, 90, 120, 150, 180, 210\\}$。对于每个$t$，我们计算$C_1$（灰度级$\\le t$）和$C_2$（灰度级$> t$）的必要量。设$N_1(t)$和$M_1(t)$分别是$C_1$的体素数和一阶矩。则$\\omega_1(t) = N_1(t)/N$，$\\mu_1(t) = M_1(t)/N_1(t)$，$\\omega_2(t) = (N - N_1(t))/N$，以及$\\mu_2(t) = (M_T - M_1(t))/(N-N_1(t))$。\n\n为了计算效率，预先计算计数（$N_1$）和矩（$M_1$）的累积和：\n- $g_i \\le 30$：$N_1=400$， $M_1=12000$\n- $g_i \\le 60$：$N_1=1200$， $M_1=60000$\n- $g_i \\le 90$：$N_1=2400$， $M_1=168000$\n- $g_i \\le 120$：$N_1=3000$， $M_1=240000$\n- $g_i \\le 150$：$N_1=3300$， $M_1=285000$\n- $g_i \\le 180$：$N_1=3900$， $M_1=393000$\n- $g_i \\le 210$：$N_1=4800$， $M_1=582000$\n\n现在，我们为每个候选$t$计算$\\sigma_B^2(t) = \\omega_1(t)\\omega_2(t)(\\mu_1(t) - \\mu_2(t))^2$。\n\n- **对于 $t=30$:**\n  $N_1=400$, $M_1=12000 \\implies \\mu_1=\\frac{12000}{400}=30$。\n  $N_2=4850$, $M_2=678000 \\implies \\mu_2=\\frac{678000}{4850} \\approx 139.79$。\n  $\\sigma_B^2(30) = \\left(\\frac{400}{5250}\\right)\\left(\\frac{4850}{5250}\\right)(30-139.79)^2 \\approx 848.7$\n\n- **对于 $t=60$:**\n  $N_1=1200$, $M_1=60000 \\implies \\mu_1=\\frac{60000}{1200}=50$。\n  $N_2=4050$, $M_2=630000 \\implies \\mu_2=\\frac{630000}{4050} \\approx 155.56$。\n  $\\sigma_B^2(60) = \\left(\\frac{1200}{5250}\\right)\\left(\\frac{4050}{5250}\\right)(50-155.56)^2 \\approx 1965.7$\n\n- **对于 $t=90$:**\n  $N_1=2400$, $M_1=168000 \\implies \\mu_1=\\frac{168000}{2400}=70$。\n  $N_2=2850$, $M_2=522000 \\implies \\mu_2=\\frac{522000}{2850} \\approx 183.16$。\n  $\\sigma_B^2(90) = \\left(\\frac{2400}{5250}\\right)\\left(\\frac{2850}{5250}\\right)(70-183.16)^2 \\approx 3179.5$\n\n- **对于 $t=120$:**\n  $N_1=3000$, $M_1=240000 \\implies \\mu_1=\\frac{240000}{3000}=80$。\n  $N_2=2250$, $M_2=450000 \\implies \\mu_2=\\frac{450000}{2250}=200$。\n  $\\sigma_B^2(120) = \\left(\\frac{3000}{5250}\\right)\\left(\\frac{2250}{5250}\\right)(80-200)^2 = \\left(\\frac{4}{7}\\right)\\left(\\frac{3}{7}\\right)(-120)^2 = \\frac{12}{49}(14400) = \\frac{172800}{49} \\approx 3526.5$\n\n- **对于 $t=150$:**\n  $N_1=3300$, $M_1=285000 \\implies \\mu_1=\\frac{285000}{3300} \\approx 86.36$。\n  $N_2=1950$, $M_2=405000 \\implies \\mu_2=\\frac{405000}{1950} \\approx 207.69$。\n  $\\sigma_B^2(150) = \\left(\\frac{3300}{5250}\\right)\\left(\\frac{1950}{5250}\\right)(86.36-207.69)^2 \\approx 3435.3$\n\n- **对于 $t=180$:**\n  $N_1=3900$, $M_1=393000 \\implies \\mu_1=\\frac{393000}{3900} \\approx 100.77$。\n  $N_2=1350$, $M_2=297000 \\implies \\mu_2=\\frac{297000}{1350}=220$。\n  $\\sigma_B^2(180) = \\left(\\frac{3900}{5250}\\right)\\left(\\frac{1350}{5250}\\right)(100.77-220)^2 \\approx 2715.2$\n\n- **对于 $t=210$:**\n  $N_1=4800$, $M_1=582000 \\implies \\mu_1=\\frac{582000}{4800}=121.25$。\n  $N_2=450$, $M_2=108000 \\implies \\mu_2=\\frac{108000}{450}=240$。\n  $\\sigma_B^2(210) = \\left(\\frac{4800}{5250}\\right)\\left(\\frac{450}{5250}\\right)(121.25-240)^2 \\approx 1109.5$\n\n比较计算出的类间方差值：\n- $\\sigma_B^2(30) \\approx 848.7$\n- $\\sigma_B^2(60) \\approx 1965.7$\n- $\\sigma_B^2(90) \\approx 3179.5$\n- $\\sigma_B^2(120) \\approx 3526.5$\n- $\\sigma_B^2(150) \\approx 3435.3$\n- $\\sigma_B^2(180) \\approx 2715.2$\n- $\\sigma_B^2(210) \\approx 1109.5$\n\n$\\sigma_B^2(t)$的最大值在$t=120$时取得。因此，最佳阈值是$t^\\star = 120$。",
            "answer": "$$\\boxed{120}$$"
        },
        {
            "introduction": "在对真实的、复杂的微结构进行模拟之前，我们必须回答一个基本问题：“我们的代码是否正确地求解了它所设计的数学方程？”制造解法（Method of Manufactured Solutions, MMS）是回答这个问题的黄金标准。本练习将指导您为一个具有挑战性的各向异性扩散问题推导并实现MMS，通过将数值解与已知的精确解进行比较来严格地验证代码的准确性。掌握MMS是计算科学家验证其数值工具可靠性的核心能力。",
            "id": "3907242",
            "problem": "考虑一个在重建体素网格上的各向异性扩散模型，该网格代表了锂离子电池电极中的均质化微观结构切片。设域为单位正方形 $\\Omega = (0,1) \\times (0,1)$，其边界为 $\\partial \\Omega$。对于一个标量浓度场 $u(x,y)$，在各向异性、常数、对称、正定张量 $\\boldsymbol{K}$ 作用下的稳态扩散方程由偏微分方程 (PDE) $-\\nabla \\cdot \\left( \\boldsymbol{K} \\nabla u \\right) = f$ 在 $\\Omega$ 中给出，并带有狄利克雷边界条件 $u = u_{\\text{exact}}$ on $\\partial \\Omega$。该张量表示为 $\\boldsymbol{K} = \\begin{bmatrix} k_{xx}  k_{xy} \\\\ k_{xy}  k_{yy} \\end{bmatrix}$，其中 $k_{xx} > 0$，$k_{yy} > 0$ 且 $k_{xx} k_{yy} - k_{xy}^{2} > 0$。\n\n您的任务是：\n- 从质量守恒 $\\nabla \\cdot \\mathbf{J} = -f$（其中通量 $\\mathbf{J} = - \\boldsymbol{K} \\nabla u$）出发，并使用一个制造的精确解 $u_{\\text{exact}}(x,y) = \\sin(\\pi x) \\sin(2\\pi y)$，推导出源项 $f(x,y)$，使得对于任何满足所述条件的常数张量 $\\boldsymbol{K}$，$u_{\\text{exact}}$ 都是该偏微分方程的精确解。除了对称性和正定性之外，不要假定任何特殊结构。\n- 在一个包含 $N \\times N$ 个节点（包括边界节点）的均匀体素网格上，使用与各向异性算子一致的二阶精确中心差分离散方法对偏微分方程进行离散化，包括由张量非对角线项所引出的混合导数。通过将边界节点设置为精确解并为内部节点组装线性系统来施加狄利克雷边界条件。\n- 对于给定的参数集 $\\left(k_{xx}, k_{xy}, k_{yy}, \\{N_{\\ell}\\}_{\\ell=1}^{L}\\right)$，对每个 $N_{\\ell}$ 求解离散问题，计算离散 $L^{2}$ 误差 $E_{N} = \\left( h^{2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{ij}^{\\text{num}} - u_{\\text{exact}}(x_{i}, y_{j}) \\right)^{2} \\right)^{1/2}$（其中 $h = 1/(N-1)$），并通过对数据 $\\left(\\log h, \\log E_{N}\\right)$ 使用最小二乘法拟合一条直线 $y = p x + c$ 来估计观测精度阶 (OOA)，并报告其斜率 $p$。\n- 将上述步骤实现为一个无需任何外部输入的完整、可运行的程序。\n\n使用以下参数值测试套件来检验不同的体系：\n- 测试用例 1（正常路径，各向同性）：$(k_{xx}, k_{xy}, k_{yy}) = (1.0, 0.0, 1.0)$，其中 $N \\in \\{16, 32, 64, 128\\}$。\n- 测试用例 2（强对角各向异性）：$(k_{xx}, k_{xy}, k_{yy}) = (1.0, 0.0, 100.0)$，其中 $N \\in \\{16, 32, 64, 128\\}$。\n- 测试用例 3（带交叉耦合的各向异性）：$(k_{xx}, k_{xy}, k_{yy}) = (2.0, 0.3, 3.0)$，其中 $N \\in \\{16, 32, 64, 128\\}$。\n- 测试用例 4（具有粗糙级别和近退化耦合但仍保持正定性的边缘情况）：$(k_{xx}, k_{xy}, k_{yy}) = (1.0, 0.09, 0.1)$，其中 $N \\in \\{8, 16, 32, 64\\}$。\n\n您的程序必须：\n- 构建由 $u_{\\text{exact}}(x,y)$ 所蕴含的制造源项 $f(x,y)$。\n- 在每个测试用例中，为每个 $N$ 组装并求解线性系统，计算 $E_{N}$，然后通过对该测试用例所有可用级别的最小二乘拟合来估计 OOA $p$。\n- 生成单行输出，其中包含与四个测试用例相对应的四个 OOA 值，顺序与上述规定相同，四舍五入到三位小数，并以逗号分隔列表的形式置于方括号内，例如 $\\left[\\text{p}_{1},\\text{p}_{2},\\text{p}_{3},\\text{p}_{4}\\right]$。\n\n由于问题已经无量纲化，因此不需要物理单位。三角函数中出现的角度，按照惯例以弧度为单位。最终输出格式必须严格符合规定，为单行文本，不得包含额外文字。",
            "solution": "用户提供的问题已经过验证，被认为是合理的。它具有科学依据、是适定的、客观的，并包含了获得唯一解所需的所有信息。指定的物理和数值参数是一致且可行的。该任务是偏微分方程数值分析中的一个标准练习，使用制造解方法进行代码验证。\n\n解决方案分三个阶段进行：\n1.  源项 $f(x,y)$ 的解析推导。\n2.  使用二阶精确的有限差分格式对控制偏微分方程(PDE)进行离散化。\n3.  构建数值算法，用于组装和求解离散系统，计算误差，并估计精度阶。\n\n### 1. 源项的推导\n\n控制性偏微分方程是稳态各向异性扩散方程：\n$$\n-\\nabla \\cdot (\\boldsymbol{K} \\nabla u) = f\n$$\n其中 $u(x,y)$ 是标量浓度场，$f(x,y)$ 是源项，$\\boldsymbol{K}$ 是一个常数、对称、正定的扩散张量：\n$$\n\\boldsymbol{K} = \\begin{bmatrix} k_{xx}  k_{xy} \\\\ k_{xy}  k_{yy} \\end{bmatrix}\n$$\n展开散度算子，我们得到：\n$$\n-\\left[ \\frac{\\partial}{\\partial x} \\left( k_{xx} \\frac{\\partial u}{\\partial x} + k_{xy} \\frac{\\partial u}{\\partial y} \\right) + \\frac{\\partial}{\\partial y} \\left( k_{xy} \\frac{\\partial u}{\\partial x} + k_{yy} \\frac{\\partial u}{\\partial y} \\right) \\right] = f(x,y)\n$$\n由于 $\\boldsymbol{K}$ 的分量是常数，导数仅作用于 $u$ 的偏导数：\n$$\n-\\left[ k_{xx} \\frac{\\partial^2 u}{\\partial x^2} + k_{xy} \\frac{\\partial^2 u}{\\partial x \\partial y} + k_{xy} \\frac{\\partial^2 u}{\\partial y \\partial x} + k_{yy} \\frac{\\partial^2 u}{\\partial y^2} \\right] = f(x,y)\n$$\n根据 Clairaut 定理，对于一个足够光滑的函数 $u$，混合偏导数相等，即 $\\frac{\\partial^2 u}{\\partial x \\partial y} = \\frac{\\partial^2 u}{\\partial y \\partial x}$。因此，源项 $f(x,y)$ 由下式给出：\n$$\nf(x,y) = -k_{xx} \\frac{\\partial^2 u}{\\partial x^2} - 2k_{xy} \\frac{\\partial^2 u}{\\partial x \\partial y} - k_{yy} \\frac{\\partial^2 u}{\\partial y^2}\n$$\n我们使用制造解方法，给定精确解为 $u_{\\text{exact}}(x,y) = \\sin(\\pi x) \\sin(2\\pi y)$。我们计算其偏导数：\n\\begin{align*}\n\\frac{\\partial u_{\\text{exact}}}{\\partial x} = \\pi \\cos(\\pi x) \\sin(2\\pi y) \\\\\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x) \\sin(2\\pi y) \\\\\n\\frac{\\partial u_{\\text{exact}}}{\\partial y} = 2\\pi \\sin(\\pi x) \\cos(2\\pi y) \\\\\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial y^2} = -4\\pi^2 \\sin(\\pi x) \\sin(2\\pi y) \\\\\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial x \\partial y} = \\frac{\\partial}{\\partial y} (\\pi \\cos(\\pi x) \\sin(2\\pi y)) = 2\\pi^2 \\cos(\\pi x) \\cos(2\\pi y)\n\\end{align*}\n将这些代入 $f(x,y)$ 的表达式中：\n$$\nf(x,y) = -k_{xx} (-\\pi^2 \\sin(\\pi x) \\sin(2\\pi y)) - 2k_{xy} (2\\pi^2 \\cos(\\pi x) \\cos(2\\pi y)) - k_{yy} (-4\\pi^2 \\sin(\\pi x) \\sin(2\\pi y))\n$$\n化简后，我们得到源项的解析表达式：\n$$\nf(x,y) = \\pi^2 \\left[ (k_{xx} + 4k_{yy}) \\sin(\\pi x) \\sin(2\\pi y) - 4k_{xy} \\cos(\\pi x) \\cos(2\\pi y) \\right]\n$$\n\n### 2. 有限差分离散化\n\n我们使用一个具有 $N \\times N$ 个节点的均匀网格来离散化域 $\\Omega = (0,1) \\times (0,1)$。节点 $(i,j)$ 的坐标为 $(x_i, y_j) = (ih, jh)$，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 1/(N-1)$。节点上解的值记为 $u_{ij} \\approx u(x_i, y_j)$。\n\n我们使用二阶精确的中心差分公式来近似内部节点 $(i,j)$ 处的偏导数：\n\\begin{align*}\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} \\\\\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{ij} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\\\\n\\frac{\\partial^2 u}{\\partial x \\partial y}\\bigg|_{ij} \\approx \\frac{u_{i+1,j+1} - u_{i-1,j+1} - u_{i+1,j-1} + u_{i-1,j-1}}{4h^2}\n\\end{align*}\n将这些代入 PDE $f_{ij} = -k_{xx} u''_{xx} - 2k_{xy} u''_{xy} - k_{yy} u''_{yy}$，得到每个内部节点 $(i,j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$）处的离散方程：\n$$\nf_{ij} \\approx -\\frac{k_{xx}}{h^2}(u_{i+1,j} - 2u_{i,j} + u_{i-1,j}) - \\frac{k_{yy}}{h^2}(u_{i,j+1} - 2u_{i,j} + u_{i,j-1}) - \\frac{2k_{xy}}{4h^2}(u_{i+1,j+1} - u_{i-1,j+1} - u_{i+1,j-1} + u_{i-1,j-1})\n$$\n乘以 $h^2$ 并重新整理各项，以对 $u_{kl}$ 的系数进行分组：\n\\begin{align*}\nh^2 f_{ij} \\approx ~ [2(k_{xx} + k_{yy})] u_{i,j} \\\\\n -k_{xx} u_{i+1,j} - k_{xx} u_{i-1,j} \\\\\n -k_{yy} u_{i,j+1} - k_{yy} u_{i,j-1} \\\\\n -\\frac{k_{xy}}{2} u_{i+1,j+1} + \\frac{k_{xy}}{2} u_{i-1,j+1} + \\frac{k_{xy}}{2} u_{i+1,j-1} - \\frac{k_{xy}}{2} u_{i-1,j-1}\n\\end{align*}\n该方程定义了一个 9 点模板。所有 $(N-2)^2$ 个内部节点的方程组构成一个大型稀疏线性方程组 $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$，其中 $\\mathbf{u}_{\\text{int}}$ 是由 $(N-2)^2$ 个未知内部节点值组成的向量。\n\n### 3. 数值算法与误差分析\n\n算法流程如下：\n1.  **系统组装**：对于给定的网格尺寸 $N$，我们构建 $(N-2)^2 \\times (N-2)^2$ 的矩阵 $A$ 和右端向量 $\\mathbf{b}$。未知数 $u_{ij}$ 被映射到一个一维向量。对于每个内部节点 $(i,j)$，构建其在系统中的对应行。$A$ 的对角线元素是 $u_{ij}$ 的系数，即 $2(k_{xx} + k_{yy})$。非对角线元素是相邻节点的系数。如果一个邻居是另一个内部节点，其系数被放置在 $A$ 的相应列中。如果一个邻居在边界上（即 $i=0, N-1$ 或 $j=0, N-1$），其值由狄利克雷边界条件 $u|_{\\partial\\Omega} = u_{\\text{exact}}$ 确定。涉及此已知边界值的项被移到方程的右侧。因此，节点 $(i,j)$ 对应的向量 $\\mathbf{b}$ 包含源项 $h^2 f(x_i, y_j)$ 以及经过所有相邻边界节点贡献调整后的值。\n\n2.  **系统求解**：使用直接稀疏求解器求解得到的稀疏线性系统 $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$，以获得内部节点值的向量 $\\mathbf{u}_{\\text{int}}$。\n\n3.  **误差计算**：将一维解向量 $\\mathbf{u}_{\\text{int}}$ 重塑回一个二维 $(N-2) \\times (N-2)$ 数组，并嵌入到一个 $N \\times N$ 的网格 $u^{\\text{num}}$ 中，该网格的边界填充了精确解的值。然后使用给定公式计算离散 $L^2$ 误差 $E_N$：\n    $$\n    E_{N} = \\left( h^{2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{ij}^{\\text{num}} - u_{\\text{exact}}(x_{i}, y_{j}) \\right)^{2} \\right)^{1/2}\n    $$\n\n4.  **精度阶 (OOA) 估计**：对于每个测试用例，为一系列网格分辨率 $\\{N_{\\ell}\\}_{\\ell=1}^{L}$ 计算误差 $E_{N}$。对于一个 $p$ 阶精度的方法，理论误差的行为类似于 $E_N \\approx C h^p = C (N-1)^{-p}$，其中 $C$ 是一个常数。取对数得到 $\\log E_N \\approx p \\log h + \\log C$。这是 $\\log E_N$ 和 $\\log h$ 之间的线性关系。我们对数据点 $(\\log h_{\\ell}, \\log E_{N_{\\ell}})$ 进行线性最小二乘拟合。所得直线的斜率提供了对观测精度阶 (OOA) $p$ 的估计。由于我们的离散格式是二阶精确的，我们期望 OOA 接近 $2.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, isotropic)\n        {'k_xx': 1.0, 'k_xy': 0.0, 'k_yy': 1.0, 'N_levels': [16, 32, 64, 128]},\n        # Test case 2 (strong diagonal anisotropy)\n        {'k_xx': 1.0, 'k_xy': 0.0, 'k_yy': 100.0, 'N_levels': [16, 32, 64, 128]},\n        # Test case 3 (anisotropy with cross coupling)\n        {'k_xx': 2.0, 'k_xy': 0.3, 'k_yy': 3.0, 'N_levels': [16, 32, 64, 128]},\n        # Test case 4 (edge case near-degenerate)\n        {'k_xx': 1.0, 'k_xy': 0.09, 'k_yy': 0.1, 'N_levels': [8, 16, 32, 64]}\n    ]\n\n    ooa_results = []\n    for params in test_cases:\n        ooa = compute_ooa_for_case(params['k_xx'], params['k_xy'], params['k_yy'], params['N_levels'])\n        ooa_results.append(ooa)\n\n    # Format and print the final output\n    formatted_results = [f\"{res:.3f}\" for res in ooa_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_ooa_for_case(k_xx, k_xy, k_yy, N_levels):\n    \"\"\"\n    Computes the Observed Order of Accuracy (OOA) for a single test case.\n    \"\"\"\n    h_values = []\n    error_values = []\n\n    # Define exact solution and source term functions\n    def u_exact_func(x, y):\n        return np.sin(np.pi * x) * np.sin(2 * np.pi * y)\n\n    def f_source_func(x, y, kxx, kxy, kyy):\n        term1 = (kxx + 4 * kyy) * np.sin(np.pi * x) * np.sin(2 * np.pi * y)\n        term2 = -4 * kxy * np.cos(np.pi * x) * np.cos(2 * np.pi * y)\n        return np.pi**2 * (term1 + term2)\n\n    for N in N_levels:\n        h = 1.0 / (N - 1)\n        h_values.append(h)\n\n        # Create grid\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        # Evaluate exact solution and source term on the grid\n        u_exact_grid = u_exact_func(X, Y)\n        f_grid = f_source_func(X, Y, k_xx, k_xy, k_yy)\n\n        # Assemble the linear system A * u_int = b\n        N_int = N - 2\n        num_unknowns = N_int * N_int\n\n        if num_unknowns == 0:\n            error_values.append(0.0)\n            continue\n            \n        A = lil_matrix((num_unknowns, num_unknowns), dtype=np.float64)\n        b = np.zeros(num_unknowns, dtype=np.float64)\n        \n        # Stencil coefficients\n        c_center = 2.0 * (k_xx + k_yy)\n        c_ew = -k_xx\n        c_ns = -k_yy\n        c_ne_sw = -k_xy / 2.0\n        c_nw_se = k_xy / 2.0\n\n        stencil_coeffs = {\n            (0, 0): c_center,\n            (1, 0): c_ew, (-1, 0): c_ew,\n            (0, 1): c_ns, (0, -1): c_ns,\n            (1, 1): c_ne_sw, (-1, -1): c_ne_sw,\n            (-1, 1): c_nw_se, (1, -1): c_nw_se,\n        }\n\n        for i_int in range(N_int):\n            for j_int in range(N_int):\n                k_glob = i_int * N_int + j_int\n                i_grid, j_grid = i_int + 1, j_int + 1\n                \n                b[k_glob] = h**2 * f_grid[i_grid, j_grid]\n\n                for (di, dj), coeff in stencil_coeffs.items():\n                    ni, nj = i_grid + di, j_grid + dj\n                    \n                    is_interior = (1 = ni  N - 1) and (1 = nj  N - 1)\n\n                    if (di, dj) == (0, 0):\n                        A[k_glob, k_glob] = coeff\n                    elif is_interior:\n                        ni_int, nj_int = ni - 1, nj - 1\n                        nk_glob = ni_int * N_int + nj_int\n                        A[k_glob, nk_glob] = coeff\n                    else: # Boundary node\n                        u_boundary = u_exact_grid[ni, nj]\n                        b[k_glob] -= coeff * u_boundary\n\n        # Solve the system\n        A_csr = A.tocsr()\n        u_int = spsolve(A_csr, b)\n        \n        # Reconstruct full solution grid\n        u_num = np.copy(u_exact_grid)\n        if num_unknowns > 0:\n            u_num[1:-1, 1:-1] = u_int.reshape((N_int, N_int))\n\n        # Compute L2 error\n        error = h * np.linalg.norm(u_num - u_exact_grid)\n        error_values.append(error)\n\n    # Perform linear regression on log-log data to find OOA\n    log_h = np.log(np.array(h_values))\n    log_E = np.log(np.array(error_values))\n    \n    # Use polyfit to find the slope (order of accuracy)\n    p, _ = np.polyfit(log_h, log_E, 1)\n\n    return p\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "任何数值模拟的结果都不可避免地包含由离散化（例如，网格分辨率）引入的误差。一个可信的模拟研究不仅要提供预测值，还必须量化其数值不确定性。本练习介绍了网格收敛指数（Grid Convergence Index, GCI）这一标准化方法，用于通过系统性的网格加密研究来估计离散误差。通过这个实践，您将学会如何为您的模拟结果（如计算出的有效电导率）提供严谨的置信区间，这是确保计算结果可信度和可重复性的关键一步。",
            "id": "3907212",
            "problem": "您正在研究重构电池电极微观结构中热传导的直接数值模拟（DNS），以预测各向同性有效热导率，记为 $k_{\\mathrm{eff}}$。在稳态条件和施加的微小热梯度下，均质化（体积平均）层面上的傅里叶定律可写作 $\\mathbf{q} = -k_{\\mathrm{eff}} \\nabla T$，其中 $\\mathbf{q}$ 是热通量，$T$ 是温度。在数值实践中，$k_{\\mathrm{eff}}$ 在具有特征间距 $h$ 的计算网格上进行近似；将网格近似的有效热导率记为 $k_h$。对于足够精细的网格和一致的离散化，离散误差可以通过领头阶代数模型 $k_h = k_{\\infty} + C h^{p}$ 很好地近似，其中 $k_{\\infty}$ 是精确（网格无关）值，$C$ 是一个与 $h$ 无关的常数，$p$ 是精度阶。\n\n给定三个间距分别为 $h_1$、$h_2$ 和 $h_3$ 的嵌套网格，满足 $h_2 = r h_1$ 和 $h_3 = r h_2$（其中公共加密比 $r  1$），以及它们对应的有效热导率估计值 $k_{h_1}$、$k_{h_2}$ 和 $k_{h_3}$，您的任务是：\n- 从领头阶离散误差模型中，推导出一个三解理查森外推程序，用以估计观测到的精度阶 $p$ 和外推热导率 $k_{\\infty}$。\n- 使用网格收敛指数（GCI）的标准定义，并将安全系数 $1.25$ 应用于细-中网格对，以小数形式（而非百分比）计算细网格的 GCI。\n- 根据 GCI，报告最细网格估计值 $k_{h_1}$ 的对称不确定性区间 $[k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$，单位为瓦特每米开尔文 (W m$^{-1}$ K$^{-1}$)。将所有报告的热导率和区间均以 W m$^{-1}$ K$^{-1}$ 为单位表示，并将所有输出四舍五入到 $6$ 位小数。\n\n假设：\n- 在三个网格上收敛是单调的（无奇偶振荡）。\n- 连续网格级别之间的加密比 $r$ 是相同的。\n- 对于足够精细的网格，离散误差遵循领头阶代数模型。\n\n每个测试用例的输入由元组 $(r, k_{h_1}, k_{h_2}, k_{h_3})$ 组成，所有 $k$ 值的单位均为 W m$^{-1}$ K$^{-1}$。请使用以下四个测试用例（测试套件），它们被选择用于探查典型情况、非整数加密比情况、从下方收敛的情况以及接近收敛的边缘情况：\n- 案例 $1$：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,2\\,,\\,1.52\\,,\\,1.58\\,,\\,1.82\\,)$\n- 案例 $2$：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,1.5\\,,\\,0.85\\,,\\,0.891856\\,,\\,0.96875\\,)$\n- 案例 $3$：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,2\\,,\\,1.92\\,,\\,1.6324\\,,\\,0.5298\\,)$\n- 案例 $4$：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,2\\,,\\,1.001\\,,\\,1.004\\,,\\,1.016\\,)$\n\n您的程序必须：\n- 实现推导过程，为每个测试用例计算：观测阶 $p$、外推热导率 $k_{\\infty}$、细网格的 GCI（以小数形式表示），以及围绕 $k_{h_1}$ 的对称不确定性区间 $[k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$（单位为 W m$^{-1}$ K$^{-1}$）。\n- 将所有报告的浮点数输出四舍五入到 $6$ 位小数。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个列表 $[p, k_{\\infty}, \\mathrm{GCI}, k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$，所有条目均为浮点数。例如：$[[p_1,k_{\\infty,1},\\mathrm{GCI}_1,k_{\\mathrm{lower},1},k_{\\mathrm{upper},1}],[p_2,\\dots],\\dots]$。\n\n注意：不涉及角度，因此不需要指定角度单位。百分比必须表示为小数（例如，使用 $0.05$ 而非 $5$ 百分之）。",
            "solution": "该问题被评估为有效，因为它的科学基础是数值分析的原理（具体来说是离散误差分析），问题是适定且客观的。它提供了一套完整且一致的数据和假设，以便使用标准的、可验证的方法推导出唯一的解。\n\n任务是根据在一系列嵌套网格上进行的三次数值模拟，来估计网格无关的有效热导率 $k_{\\infty}$ 和观测到的精度阶 $p$。我们还被要求计算网格收敛指数（GCI）以及最细网格解的相应不确定性区间。\n\n出发点是所提供的针对数值近似的有效热导率 $k_h$ 的领头阶代数误差模型：\n$$k_h = k_{\\infty} + C h^{p}$$\n其中 $k_{\\infty}$ 是精确的、网格无关的值，$h$ 是特征网格间距，$p$ 是精度阶，$C$ 是一个常数。\n\n我们得到三个热导率估计值 $k_{h_1}$、$k_{h_2}$ 和 $k_{h_3}$，它们是在三个间距分别为 $h_1$（细）、$h_2$（中）和 $h_3$（粗）的网格上计算得出的。这些网格通过一个公共加密比 $r  1$ 关联，使得 $h_2 = r h_1$ 且 $h_3 = r h_2 = r^2 h_1$。\n\n我们可以为这三个网格分别写出误差模型：\n$$k_{h_1} = k_{\\infty} + C h_1^p \\quad (1)$$\n$$k_{h_2} = k_{\\infty} + C h_2^p = k_{\\infty} + C (r h_1)^p \\quad (2)$$\n$$k_{h_3} = k_{\\infty} + C h_3^p = k_{\\infty} + C (r^2 h_1)^p \\quad (3)$$\n\n为了求出观测到的精度阶 $p$，我们首先通过对连续方程作差来消去未知数 $k_{\\infty}$。\n(2)式减去(1)式：\n$$k_{h_2} - k_{h_1} = C ((r h_1)^p - h_1^p) = C h_1^p (r^p - 1) \\quad (4)$$\n(3)式减去(2)式：\n$$k_{h_3} - k_{h_2} = C ((r^2 h_1)^p - (r h_1)^p) = C (r h_1)^p (r^p - 1) = C h_1^p r^p (r^p - 1) \\quad (5)$$\n\n现在，为了消去 $C$ 和 $h_1$，我们将方程(5)除以方程(4)：\n$$\\frac{k_{h_3} - k_{h_2}}{k_{h_2} - k_{h_1}} = \\frac{C h_1^p r^p (r^p - 1)}{C h_1^p (r^p - 1)} = r^p$$\n这使我们能够通过对两边取自然对数来解出 $p$：\n$$\\ln\\left(\\frac{k_{h_3} - k_{h_2}}{k_{h_2} - k_{h_1}}\\right) = \\ln(r^p) = p \\ln(r)$$\n因此，观测到的精度阶为：\n$$p = \\frac{\\ln\\left(\\frac{k_{h_3} - k_{h_2}}{k_{h_2} - k_{h_1}}\\right)}{\\ln(r)}$$\n\n在确定了 $p$ 的值之后，我们可以使用理查森外推法来估计网格无关解 $k_{\\infty}$。重新整理方程(4)可以得到细网格上的误差项 $C h_1^p$ 的表达式：\n$$C h_1^p = \\frac{k_{h_2} - k_{h_1}}{r^p - 1}$$\n将此代回方程(1)：\n$$k_{h_1} = k_{\\infty} + \\frac{k_{h_2} - k_{h_1}}{r^p - 1}$$\n求解 $k_{\\infty}$：\n$$k_{\\infty} = k_{h_1} - \\frac{k_{h_2} - k_{h_1}}{r^p - 1} = \\frac{k_{h_1}(r^p - 1) - (k_{h_2} - k_{h_1})}{r^p - 1} = \\frac{k_{h_1}r^p - k_{h_1} - k_{h_2} + k_{h_1}}{r^p - 1}$$\n这可以简化为理查森外推公式：\n$$k_{\\infty} = \\frac{r^p k_{h_1} - k_{h_2}}{r^p - 1}$$\n\n接下来，我们基于细-中网格对（$h_1, h_2$）计算细网格解的网格收敛指数（GCI）。GCI 提供了数值不确定性的一个估计。使用安全系数 $F_s = 1.25$，GCI 定义为小数形式：\n$$\\mathrm{GCI} = F_s \\left| \\frac{\\epsilon_a}{r^p - 1} \\right|$$\n其中 $\\epsilon_a$ 是细网格解与中等网格解之间的近似相对误差：\n$$\\epsilon_a = \\frac{k_{h_1} - k_{h_2}}{k_{h_1}}$$\n将 $\\epsilon_a$ 代入 GCI 公式：\n$$\\mathrm{GCI} = 1.25 \\left| \\frac{(k_{h_1} - k_{h_2})/k_{h_1}}{r^p - 1} \\right| = \\frac{1.25}{|r^p - 1|} \\left| \\frac{k_{h_1} - k_{h_2}}{k_{h_1}} \\right|$$\n\n最后，我们确定最细网格估计值 $k_{h_1}$ 的对称不确定性区间。GCI 代表解 $k_{h_1}$ 的相对不确定性。绝对不确定性为 $\\Delta k = \\mathrm{GCI} \\times |k_{h_1}|$。由于热导率是一个正量，所以 $|k_{h_1}| = k_{h_1}$。因此，对称不确定性区间 $[k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$ 为：\n$$k_{\\mathrm{lower}} = k_{h_1} - \\mathrm{GCI} \\cdot k_{h_1} = k_{h_1} (1 - \\mathrm{GCI})$$\n$$k_{\\mathrm{upper}} = k_{h_1} + \\mathrm{GCI} \\cdot k_{h_1} = k_{h_1} (1 + \\mathrm{GCI})$$\n\n这些推导出的公式将为每个测试用例实现，所有最终的浮点数值都将四舍五入到 $6$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grid convergence analysis problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, k_h1, k_h2, k_h3)\n        (2.0, 1.52, 1.58, 1.82),\n        (1.5, 0.85, 0.891856, 0.96875),\n        (2.0, 1.92, 1.6324, 0.5298),\n        (2.0, 1.001, 1.004, 1.016),\n    ]\n\n    all_results = []\n    \n    # Safety factor for GCI calculation\n    F_s = 1.25\n\n    for case in test_cases:\n        r, k_h1, k_h2, k_h3 = case\n\n        # Step 1: Calculate the observed order of accuracy 'p'\n        # p = ln((k_h3 - k_h2) / (k_h2 - k_h1)) / ln(r)\n        # Check for division by zero, although problem data avoids this.\n        diff_21 = k_h2 - k_h1\n        if diff_21 == 0:\n            # If the two finer solutions are identical, p cannot be determined from this formula.\n            # This indicates convergence or issues. For this problem, we assume diff_21 != 0.\n            # In a real scenario, one might have to handle this (e.g., assume p is the theoretical order).\n            # For this problem, we can continue as the test data is well-behaved.\n            pass\n        \n        ratio_of_diffs = (k_h3 - k_h2) / diff_21\n        # The argument to log must be positive. Monotonic convergence ensures this.\n        p = np.log(ratio_of_diffs) / np.log(r)\n\n        # Step 2: Calculate the extrapolated grid-independent solution 'k_inf'\n        # k_inf = (r^p * k_h1 - k_h2) / (r^p - 1)\n        rp = r**p\n        k_inf = (rp * k_h1 - k_h2) / (rp - 1)\n\n        # Step 3: Calculate the Grid Convergence Index (GCI) for the fine grid\n        # GCI = F_s * | (k_h1 - k_h2) / k_h1 | / (r^p - 1)\n        approx_rel_err = (k_h1 - k_h2) / k_h1\n        gci = F_s * np.abs(approx_rel_err) / np.abs(rp - 1)\n        \n        # Step 4: Calculate the symmetric uncertainty bounds for k_h1\n        # k_lower = k_h1 * (1 - GCI)\n        # k_upper = k_h1 * (1 + GCI)\n        k_lower = k_h1 * (1.0 - gci)\n        k_upper = k_h1 * (1.0 + gci)\n\n        # Append the results for the current test case, after rounding\n        all_results.append([\n            round(p, 6),\n            round(k_inf, 6),\n            round(gci, 6),\n            round(k_lower, 6),\n            round(k_upper, 6),\n        ])\n\n    # Format the final output string as a list of lists.\n    # e.g., [[p1, k_inf1, ...], [p2, k_inf2, ...]]\n    inner_list_strings = []\n    for result_list in all_results:\n        # Convert each float in the list to a string with 6 decimal places.\n        str_list = [f\"{val:.6f}\" for val in result_list]\n        inner_list_strings.append(f\"[{','.join(str_list)}]\")\n    \n    final_output = f\"[{','.join(inner_list_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}