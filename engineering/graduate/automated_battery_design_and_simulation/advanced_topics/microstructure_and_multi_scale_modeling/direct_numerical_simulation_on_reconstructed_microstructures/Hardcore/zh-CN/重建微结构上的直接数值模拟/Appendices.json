{
    "hands_on_practices": [
        {
            "introduction": "在对重建微结构进行直接数值模拟之前，首要任务是将来自X射线断层扫描等技术的三维灰度图像转换为可用于模拟的离散几何。这个转换过程通常依赖于图像分割，即根据体素的灰度值将其划分为不同的相（例如，固相和孔隙相）。本练习将引导您从第一性原理推导并应用大津法（Otsu's method），这是一种通过最大化类间方差来自动确定最佳分割阈值的经典算法。通过这个实践，您将掌握将原始图像数据处理成模拟所需几何模型的关键一步。",
            "id": "3907165",
            "problem": "需要将一张通过X射线计算机断层扫描（XCT）重建的多孔锂离子电池正极的灰度微观结构图像分割成孔隙相和固相，以便对离子输运进行直接数值模拟（DNS）。分割通过对8位灰度强度应用单一全局阈值来执行，从而将强度 $\\leq t$ 的所有体素分配给孔隙相，而将强度 $> t$ 的所有体素分配给固相。观测到的灰度直方图呈双峰分布，且仅在以下8个灰度级上具有非零计数：$(g_i, n_i)$ 对为 $(30, 400)$、$(60, 800)$、$(90, 1200)$、$(120, 600)$、$(150, 300)$、$(180, 600)$、$(210, 900)$、$(240, 450)$，其中 $g_i$ 是灰度级，$n_i$ 是该灰度级的体素数量。\n\n仅从离散分布的概率、均值和方差的定义，以及总方差可以写为类内和类间贡献之和的方差分解恒等式出发，推导Otsu方法中用于选择最佳阈值 $t$ 的准则，该准则通过最大化阈值分割产生的两个类别的类间方差来实现。然后，将推导出的准则应用于所提供的直方图，以确定在候选灰度级 $t \\in \\{30, 60, 90, 120, 150, 180, 210\\}$ 中使类间方差最大化的唯一阈值 $t^{\\star}$。\n\n将最终阈值表示为8位尺度上的整数灰度级。无需四舍五入。",
            "solution": "该任务首先是推导Otsu图像阈值分割法的准则，然后将其应用于给定的直方图以找到最佳阈值。\n\n### 第1部分：Otsu方法准则的推导\n\n设离散灰度级用 $i$ 表示，其中 $i \\in \\{0, 1, \\dots, L-1\\}$。对于8位图像，$L=256$。设 $n_i$ 是图像中灰度级为 $i$ 的体素数量，设 $N$ 是体素总数，$N = \\sum_{i=0}^{L-1} n_i$。\n\n根据离散分布的概率定义，一个体素具有灰度级 $i$ 的概率是：\n$$\np_i = \\frac{n_i}{N}\n$$\n这些概率满足 $\\sum_{i=0}^{L-1} p_i = 1$。\n\n根据离散分布的均值定义，图像的总平均灰度级为：\n$$\n\\mu_T = \\sum_{i=0}^{L-1} i \\cdot p_i\n$$\n\n灰度级为 $t$ 的阈值将体素划分为两个类别：\n- 类别1 ($C_1$)：孔隙相，包含灰度级为 $\\{0, 1, \\dots, t\\}$ 的体素。\n- 类别2 ($C_2$)：固相，包含灰度级为 $\\{t+1, \\dots, L-1\\}$ 的体素。\n\n随机选择的体素属于类别1的概率 $\\omega_1(t)$ 是 $C_1$ 中各灰度级概率的总和：\n$$\n\\omega_1(t) = P(C_1) = \\sum_{i=0}^{t} p_i\n$$\n同样，属于类别2的概率 $\\omega_2(t)$ 是：\n$$\n\\omega_2(t) = P(C_2) = \\sum_{i=t+1}^{L-1} p_i\n$$\n由此可知 $\\omega_1(t) + \\omega_2(t) = 1$。\n\n每个类别的平均灰度级通过条件期望计算得出：\n$$\n\\mu_1(t) = \\frac{\\sum_{i=0}^{t} i \\cdot p_i}{\\omega_1(t)} \\quad \\text{和} \\quad \\mu_2(t) = \\frac{\\sum_{i=t+1}^{L-1} i \\cdot p_i}{\\omega_2(t)}\n$$\n总均值 $\\mu_T$ 可以表示为类别均值的加权平均：$\\mu_T = \\omega_1(t)\\mu_1(t) + \\omega_2(t)\\mu_2(t)$。\n\n问题陈述我们必须使用方差分解恒等式，该恒等式将图像灰度级分布的总方差 $\\sigma_T^2$ 表示为两个分量的和：类内方差 $\\sigma_W^2(t)$ 和类间方差 $\\sigma_B^2(t)$。\n$$\n\\sigma_T^2 = \\sigma_W^2(t) + \\sigma_B^2(t)\n$$\n总方差 $\\sigma_T^2 = \\sum_{i=0}^{L-1} (i - \\mu_T)^2 p_i$ 对于给定图像是一个常数，不依赖于阈值 $t$。\n\n类内方差 $\\sigma_W^2(t)$ 是每个类别方差的加权平均：$\\sigma_W^2(t) = \\omega_1(t)\\sigma_1^2(t) + \\omega_2(t)\\sigma_2^2(t)$，其中 $\\sigma_1^2(t)$ 和 $\\sigma_2^2(t)$ 分别是 $C_1$ 和 $C_2$ 内部的方差。它衡量了类别内部的同质性。一个好的分割应该产生同质的类别，因此目标是最小化 $\\sigma_W^2(t)$。\n\n类间方差 $\\sigma_B^2(t)$ 定义为：\n$$\n\\sigma_B^2(t) = \\omega_1(t)(\\mu_1(t) - \\mu_T)^2 + \\omega_2(t)(\\mu_2(t) - \\mu_T)^2\n$$\n这个量度衡量了两个类别的可分性。\n\n由于 $\\sigma_T^2$ 是常数，最小化类内方差 $\\sigma_W^2(t)$ 在数学上等同于最大化类间方差 $\\sigma_B^2(t)$。Otsu方法就是基于这一原理定义的。因此，选择最佳阈值 $t^\\star$ 的准则是最大化类间方差：\n$$\nt^\\star = \\arg\\max_{t} \\left\\{ \\sigma_B^2(t) \\right\\}\n$$\n为了计算方便，可以简化 $\\sigma_B^2(t)$ 的表达式。使用 $\\mu_T = \\omega_1\\mu_1 + \\omega_2\\mu_2$ 和 $\\omega_1+\\omega_2=1$：\n$$\n\\begin{align*} \\sigma_B^2(t) = \\omega_1(\\mu_1 - (\\omega_1\\mu_1 + \\omega_2\\mu_2))^2 + \\omega_2(\\mu_2 - (\\omega_1\\mu_1 + \\omega_2\\mu_2))^2 \\\\ = \\omega_1((1-\\omega_1)\\mu_1 - \\omega_2\\mu_2)^2 + \\omega_2(-\\omega_1\\mu_1 + (1-\\omega_2)\\mu_2)^2 \\\\ = \\omega_1(\\omega_2\\mu_1 - \\omega_2\\mu_2)^2 + \\omega_2(-\\omega_1\\mu_1 + \\omega_1\\mu_2)^2 \\\\ = \\omega_1\\omega_2^2(\\mu_1 - \\mu_2)^2 + \\omega_2\\omega_1^2(\\mu_1 - \\mu_2)^2 \\\\ = (\\omega_1\\omega_2^2 + \\omega_2\\omega_1^2)(\\mu_1 - \\mu_2)^2 \\\\ = \\omega_1\\omega_2(\\omega_2 + \\omega_1)(\\mu_1 - \\mu_2)^2 \\\\ = \\omega_1(t)\\omega_2(t)(\\mu_1(t) - \\mu_2(t))^2 \\end{align*}\n$$\n至此，准则的推导完成。\n\n### 第2部分：应用于给定数据\n\n提供的直方图数据为：\n$(g_i, n_i) \\in \\{(30, 400), (60, 800), (90, 1200), (120, 600), (150, 300), (180, 600), (210, 900), (240, 450)\\}$。\n\n首先，我们计算体素总数 $N$：\n$$\nN = 400 + 800 + 1200 + 600 + 300 + 600 + 900 + 450 = 5250\n$$\n总一阶矩（$g_i \\cdot n_i$ 的和）是：\n$$\nM_T = (30)(400) + (60)(800) + (90)(1200) + (120)(600) + (150)(300) + (180)(600) + (210)(900) + (240)(450)\n$$\n$$\nM_T = 12000 + 48000 + 108000 + 72000 + 45000 + 108000 + 189000 + 108000 = 690000\n$$\n我们将测试每个候选阈值 $t \\in \\{30, 60, 90, 120, 150, 180, 210\\}$。对于每个 $t$，我们计算 $C_1$（灰度级 $\\le t$）和 $C_2$（灰度级 $> t$）的必要量。设 $N_1(t)$ 和 $M_1(t)$ 分别是 $C_1$ 的体素数量和一阶矩。则 $\\omega_1(t) = N_1(t)/N$，$\\mu_1(t) = M_1(t)/N_1(t)$，$\\omega_2(t) = (N - N_1(t))/N$，以及 $\\mu_2(t) = (M_T - M_1(t))/(N-N_1(t))$。\n\n为了提高效率，预先计算计数（$N_1$）和矩（$M_1$）的累积和：\n- $g_i \\le 30$：$N_1=400$， $M_1=12000$\n- $g_i \\le 60$：$N_1=1200$， $M_1=60000$\n- $g_i \\le 90$：$N_1=2400$， $M_1=168000$\n- $g_i \\le 120$：$N_1=3000$， $M_1=240000$\n- $g_i \\le 150$：$N_1=3300$， $M_1=285000$\n- $g_i \\le 180$：$N_1=3900$， $M_1=393000$\n- $g_i \\le 210$：$N_1=4800$， $M_1=582000$\n\n现在，我们为每个候选 $t$ 计算 $\\sigma_B^2(t) = \\omega_1(t)\\omega_2(t)(\\mu_1(t) - \\mu_2(t))^2$。\n\n- **对于 $t=30$：**\n  $N_1=400$, $M_1=12000 \\implies \\mu_1=\\frac{12000}{400}=30$。\n  $N_2=4850$, $M_2=678000 \\implies \\mu_2=\\frac{678000}{4850} \\approx 139.79$。\n  $\\sigma_B^2(30) = \\left(\\frac{400}{5250}\\right)\\left(\\frac{4850}{5250}\\right)(30-139.79)^2 \\approx 848.7$\n\n- **对于 $t=60$：**\n  $N_1=1200$, $M_1=60000 \\implies \\mu_1=\\frac{60000}{1200}=50$。\n  $N_2=4050$, $M_2=630000 \\implies \\mu_2=\\frac{630000}{4050} \\approx 155.56$。\n  $\\sigma_B^2(60) = \\left(\\frac{1200}{5250}\\right)\\left(\\frac{4050}{5250}\\right)(50-155.56)^2 \\approx 1965.7$\n\n- **对于 $t=90$：**\n  $N_1=2400$, $M_1=168000 \\implies \\mu_1=\\frac{168000}{2400}=70$。\n  $N_2=2850$, $M_2=522000 \\implies \\mu_2=\\frac{522000}{2850} \\approx 183.16$。\n  $\\sigma_B^2(90) = \\left(\\frac{2400}{5250}\\right)\\left(\\frac{2850}{5250}\\right)(70-183.16)^2 \\approx 3179.5$\n\n- **对于 $t=120$：**\n  $N_1=3000$, $M_1=240000 \\implies \\mu_1=\\frac{240000}{3000}=80$。\n  $N_2=2250$, $M_2=450000 \\implies \\mu_2=\\frac{450000}{2250}=200$。\n  $\\sigma_B^2(120) = \\left(\\frac{3000}{5250}\\right)\\left(\\frac{2250}{5250}\\right)(80-200)^2 = \\left(\\frac{4}{7}\\right)\\left(\\frac{3}{7}\\right)(-120)^2 = \\frac{12}{49}(14400) = \\frac{172800}{49} \\approx 3526.5$\n\n- **对于 $t=150$：**\n  $N_1=3300$, $M_1=285000 \\implies \\mu_1=\\frac{285000}{3300} \\approx 86.36$。\n  $N_2=1950$, $M_2=405000 \\implies \\mu_2=\\frac{405000}{1950} \\approx 207.69$。\n  $\\sigma_B^2(150) = \\left(\\frac{3300}{5250}\\right)\\left(\\frac{1950}{5250}\\right)(86.36-207.69)^2 \\approx 3435.3$\n\n- **对于 $t=180$：**\n  $N_1=3900$, $M_1=393000 \\implies \\mu_1=\\frac{393000}{3900} \\approx 100.77$。\n  $N_2=1350$, $M_2=297000 \\implies \\mu_2=\\frac{297000}{1350}=220$。\n  $\\sigma_B^2(180) = \\left(\\frac{3900}{5250}\\right)\\left(\\frac{1350}{5250}\\right)(100.77-220)^2 \\approx 2715.2$\n\n- **对于 $t=210$：**\n  $N_1=4800$, $M_1=582000 \\implies \\mu_1=\\frac{582000}{4800}=121.25$。\n  $N_2=450$, $M_2=108000 \\implies \\mu_2=\\frac{108000}{450}=240$。\n  $\\sigma_B^2(210) = \\left(\\frac{4800}{5250}\\right)\\left(\\frac{450}{5250}\\right)(121.25-240)^2 \\approx 1109.5$\n\n比较计算出的类间方差值：\n- $\\sigma_B^2(30) \\approx 848.7$\n- $\\sigma_B^2(60) \\approx 1965.7$\n- $\\sigma_B^2(90) \\approx 3179.5$\n- $\\sigma_B^2(120) \\approx 3526.5$\n- $\\sigma_B^2(150) \\approx 3435.3$\n- $\\sigma_B^2(180) \\approx 2715.2$\n- $\\sigma_B^2(210) \\approx 1109.5$\n\n$\\sigma_B^2(t)$ 的最大值出现在 $t=120$ 时。因此，最佳阈值为 $t^\\star = 120$。",
            "answer": "$$\\boxed{120}$$"
        },
        {
            "introduction": "拥有几何模型后，下一步是利用数值求解器来模拟其中的物理过程。然而，在将求解器应用于复杂的真实微结构之前，我们必须确保代码本身能够准确地求解其所基于的数学方程，这个过程称为代码验证。本练习将向您介绍一种严谨的代码验证技术——制造解方法（Method of Manufactured Solutions, MMS）。您将通过为一个具有已知解析解的物理问题推导源项并实现一个数值求解器，来系统地检验代码的收敛阶，从而建立对模拟结果的信心。",
            "id": "3907242",
            "problem": "考虑一个在重建体素网格上的各向异性扩散模型，该网格代表了锂离子电池电极中的均质化微结构切片。设域为单位正方形 $\\Omega = (0,1) \\times (0,1)$，其边界为 $\\partial \\Omega$。对于标量浓度场 $u(x,y)$，在各向异性、常数、对称、正定张量 $\\boldsymbol{K}$ 作用下的稳态扩散方程由偏微分方程(PDE) $-\\nabla \\cdot \\left( \\boldsymbol{K} \\nabla u \\right) = f$ 在 $\\Omega$ 中给出，并带有狄利克雷边界条件 $u = u_{\\text{exact}}$ 在 $\\partial \\Omega$ 上。张量表示为 $\\boldsymbol{K} = \\begin{bmatrix} k_{xx}  k_{xy} \\\\ k_{xy}  k_{yy} \\end{bmatrix}$，其中 $k_{xx} > 0$，$k_{yy} > 0$ 且 $k_{xx} k_{yy} - k_{xy}^{2} > 0$。\n\n您的任务是：\n- 从质量守恒 $\\nabla \\cdot \\mathbf{J} = -f$（其中通量 $\\mathbf{J} = - \\boldsymbol{K} \\nabla u$）出发，并使用一个构造的精确解 $u_{\\text{exact}}(x,y) = \\sin(\\pi x) \\sin(2\\pi y)$，推导源项 $f(x,y)$，使得对于任何满足所述条件的常数张量 $\\boldsymbol{K}$，$u_{\\text{exact}}$ 都是该偏微分方程的精确解。除对称性和正定性外，不要假设任何特殊结构。\n- 在一个包含 $N \\times N$ 个节点（包括边界节点）的均匀体素网格上，使用与各向异性算子一致的二阶精度中心差分格式对该偏微分方程进行离散化，包括由张量非对角线项所引入的混合导数。通过将边界节点设置为精确解来施加狄利克雷边界条件，并为内部节点组装线性系统。\n- 对于给定的参数集 $\\left(k_{xx}, k_{xy}, k_{yy}, \\{N_{\\ell}\\}_{\\ell=1}^{L}\\right)$，对每个 $N_{\\ell}$ 求解离散问题，计算离散 $L^{2}$ 误差 $E_{N} = \\left( h^{2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{ij}^{\\text{num}} - u_{\\text{exact}}(x_{i}, y_{j}) \\right)^{2} \\right)^{1/2}$（其中 $h = 1/(N-1)$），并通过对数据 $\\left(\\log h, \\log E_{N}\\right)$ 进行最小二乘法拟合直线 $y = p x + c$ 来估计观测精度阶（OOA），并报告斜率 $p$。\n- 将上述步骤实现为一个完整的、可运行的程序，该程序无需任何外部输入即可执行这些步骤。\n\n使用以下参数值测试套件来检验不同的体系：\n- 测试用例1（理想情况，各向同性）：$(k_{xx}, k_{xy}, k_{yy}) = (1.0, 0.0, 1.0)$，其中 $N \\in \\{16, 32, 64, 128\\}$。\n- 测试用例2（强对角各向异性）：$(k_{xx}, k_{xy}, k_{yy}) = (1.0, 0.0, 100.0)$，其中 $N \\in \\{16, 32, 64, 128\\}$。\n- 测试用例3（带交叉耦合的各向异性）：$(k_{xx}, k_{xy}, k_{yy}) = (2.0, 0.3, 3.0)$，其中 $N \\in \\{16, 32, 64, 128\\}$。\n- 测试用例4（粗糙网格层级和近简并耦合的边缘情况，同时保持正定性）：$(k_{xx}, k_{xy}, k_{yy}) = (1.0, 0.09, 0.1)$，其中 $N \\in \\{8, 16, 32, 64\\}$。\n\n您的程序必须：\n- 构建由 $u_{\\text{exact}}(x,y)$ 隐含的构造源项 $f(x,y)$。\n- 在每个测试用例中，为每个 $N$ 组装并求解线性系统，计算 $E_{N}$，然后通过对该测试用例所有可用层级进行最小二乘拟合来估计 OOA $p$。\n- 生成单行输出，其中包含与四个测试用例相对应的四个 OOA 值，顺序与上述指定顺序相同，四舍五入到三位小数，并以方括号括起来的逗号分隔列表形式表示，例如 $\\left[\\text{p}_{1},\\text{p}_{2},\\text{p}_{3},\\text{p}_{4}\\right]$。\n\n由于问题是无量纲化的，因此不需要物理单位。三角函数中出现的角度按惯例以弧度为单位。最终输出格式必须严格遵守规定，为单行文本，无任何附加文字。",
            "solution": "用户提供的问题已经过验证，被认为是可靠的。它具有科学依据，是适定的、客观的，并包含了唯一解所需的所有必要信息。指定的物理和数值参数是一致且可行的。该任务是偏微分方程数值分析中的一个标准练习，使用构造解方法进行代码验证。\n\n求解过程分为三个阶段：\n1.  源项 $f(x,y)$ 的解析推导。\n2.  使用二阶精度有限差分格式对控制偏微分方程 (PDE) 进行离散化。\n3.  构建用于组装和求解离散系统、计算误差以及估计精度阶的数值算法。\n\n### 1. 源项的推导\n\n控制偏微分方程是稳态各向异性扩散方程：\n$$\n-\\nabla \\cdot (\\boldsymbol{K} \\nabla u) = f\n$$\n其中 $u(x,y)$ 是标量浓度场，$f(x,y)$ 是源项，$\\boldsymbol{K}$ 是一个常数、对称、正定的扩散张量：\n$$\n\\boldsymbol{K} = \\begin{bmatrix} k_{xx}  k_{xy} \\\\ k_{xy}  k_{yy} \\end{bmatrix}\n$$\n展开散度算子，我们得到：\n$$\n-\\left[ \\frac{\\partial}{\\partial x} \\left( k_{xx} \\frac{\\partial u}{\\partial x} + k_{xy} \\frac{\\partial u}{\\partial y} \\right) + \\frac{\\partial}{\\partial y} \\left( k_{xy} \\frac{\\partial u}{\\partial x} + k_{yy} \\frac{\\partial u}{\\partial y} \\right) \\right] = f(x,y)\n$$\n由于 $\\boldsymbol{K}$ 的分量是常数，导数仅作用于 $u$ 的偏导数：\n$$\n-\\left[ k_{xx} \\frac{\\partial^2 u}{\\partial x^2} + k_{xy} \\frac{\\partial^2 u}{\\partial x \\partial y} + k_{xy} \\frac{\\partial^2 u}{\\partial y \\partial x} + k_{yy} \\frac{\\partial^2 u}{\\partial y^2} \\right] = f(x,y)\n$$\n根据克莱罗定理，对于一个足够光滑的函数 $u$，混合偏导数相等，即 $\\frac{\\partial^2 u}{\\partial x \\partial y} = \\frac{\\partial^2 u}{\\partial y \\partial x}$。因此，源项 $f(x,y)$ 由下式给出：\n$$\nf(x,y) = -k_{xx} \\frac{\\partial^2 u}{\\partial x^2} - 2k_{xy} \\frac{\\partial^2 u}{\\partial x \\partial y} - k_{yy} \\frac{\\partial^2 u}{\\partial y^2}\n$$\n我们使用构造解方法，给定精确解为 $u_{\\text{exact}}(x,y) = \\sin(\\pi x) \\sin(2\\pi y)$。我们计算其偏导数：\n\\begin{align*}\n\\frac{\\partial u_{\\text{exact}}}{\\partial x} = \\pi \\cos(\\pi x) \\sin(2\\pi y) \\\\\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x) \\sin(2\\pi y) \\\\\n\\frac{\\partial u_{\\text{exact}}}{\\partial y} = 2\\pi \\sin(\\pi x) \\cos(2\\pi y) \\\\\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial y^2} = -4\\pi^2 \\sin(\\pi x) \\sin(2\\pi y) \\\\\n\\frac{\\partial^2 u_{\\text{exact}}}{\\partial x \\partial y} = \\frac{\\partial}{\\partial y} (\\pi \\cos(\\pi x) \\sin(2\\pi y)) = 2\\pi^2 \\cos(\\pi x) \\cos(2\\pi y)\n\\end{align*}\n将这些偏导数代入 $f(x,y)$ 的表达式中：\n$$\nf(x,y) = -k_{xx} (-\\pi^2 \\sin(\\pi x) \\sin(2\\pi y)) - 2k_{xy} (2\\pi^2 \\cos(\\pi x) \\cos(2\\pi y)) - k_{yy} (-4\\pi^2 \\sin(\\pi x) \\sin(2\\pi y))\n$$\n化简后，我们得到源项的解析表达式：\n$$\nf(x,y) = \\pi^2 \\left[ (k_{xx} + 4k_{yy}) \\sin(\\pi x) \\sin(2\\pi y) - 4k_{xy} \\cos(\\pi x) \\cos(2\\pi y) \\right]\n$$\n\n### 2. 有限差分离散化\n\n我们使用一个具有 $N \\times N$ 个节点的均匀网格对域 $\\Omega = (0,1) \\times (0,1)$ 进行离散化。节点 $(i,j)$ 的坐标为 $(x_i, y_j) = (ih, jh)$，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 1/(N-1)$。节点上的解值表示为 $u_{ij} \\approx u(x_i, y_j)$。\n\n我们使用二阶精度的中心差分公式来近似内部节点 $(i,j)$ 处的偏导数：\n\\begin{align*}\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{ij} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} \\\\\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{ij} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} \\\\\n\\frac{\\partial^2 u}{\\partial x \\partial y}\\bigg|_{ij} \\approx \\frac{u_{i+1,j+1} - u_{i-1,j+1} - u_{i+1,j-1} + u_{i-1,j-1}}{4h^2}\n\\end{align*}\n将这些近似代入 PDE，$f_{ij} = -k_{xx} u''_{xx} - 2k_{xy} u''_{xy} - k_{yy} u''_{yy}$，得到每个内部节点 $(i,j)$ 处的离散方程，其中 $i,j \\in \\{1, \\dots, N-2\\}$：\n$$\nf_{ij} \\approx -\\frac{k_{xx}}{h^2}(u_{i+1,j} - 2u_{i,j} + u_{i-1,j}) - \\frac{k_{yy}}{h^2}(u_{i,j+1} - 2u_{i,j} + u_{i,j-1}) - \\frac{2k_{xy}}{4h^2}(u_{i+1,j+1} - u_{i-1,j+1} - u_{i+1,j-1} + u_{i-1,j-1})\n$$\n两边乘以 $h^2$ 并重新整理各项，将 $u_{kl}$ 的系数归类：\n\\begin{align*}\nh^2 f_{ij} \\approx ~ [2(k_{xx} + k_{yy})] u_{i,j} \\\\\n -k_{xx} u_{i+1,j} - k_{xx} u_{i-1,j} \\\\\n -k_{yy} u_{i,j+1} - k_{yy} u_{i,j-1} \\\\\n -\\frac{k_{xy}}{2} u_{i+1,j+1} + \\frac{k_{xy}}{2} u_{i-1,j+1} + \\frac{k_{xy}}{2} u_{i+1,j-1} - \\frac{k_{xy}}{2} u_{i-1,j-1}\n\\end{align*}\n这个方程定义了一个9点格式（9-point stencil）。所有 $(N-2)^2$ 个内部节点的方程组构成一个大型稀疏线性方程组 $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$，其中 $\\mathbf{u}_{\\text{int}}$ 是由 $(N-2)^2$ 个未知的内部节点值组成的向量。\n\n### 3. 数值算法与误差分析\n\n算法流程如下：\n1.  **系统组装**：对于给定的网格尺寸 $N$，我们构建 $(N-2)^2 \\times (N-2)^2$ 的矩阵 $A$ 和右端向量 $\\mathbf{b}$。未知数 $u_{ij}$ 被映射到一个一维向量中。对于每个内部节点 $(i,j)$，构建其在系统中的对应行。矩阵 $A$ 的对角线元素是 $u_{ij}$ 的系数，即 $2(k_{xx} + k_{yy})$。非对角线元素是相邻节点的系数。如果一个邻居是另一个内部节点，其系数被放置在 $A$ 的相应列中。如果一个邻居在边界上（即 $i=0, N-1$ 或 $j=0, N-1$），其值由狄利克雷边界条件 $u|_{\\partial\\Omega} = u_{\\text{exact}}$ 给出，是已知的。涉及此已知边界值的项被移到方程的右侧。因此，节点 $(i,j)$ 的向量 $\\mathbf{b}$ 包含源项 $h^2 f(x_i, y_j)$ 以及所有相邻边界节点贡献的调整项。\n\n2.  **系统求解**：使用直接稀疏求解器求解得到的稀疏线性系统 $A\\mathbf{u}_{\\text{int}} = \\mathbf{b}$，以获得内部节点值的向量 $\\mathbf{u}_{\\text{int}}$。\n\n3.  **误差计算**：将一维解向量 $\\mathbf{u}_{\\text{int}}$ 重新变形成一个二维 $(N-2) \\times (N-2)$ 数组，并嵌入到一个 $N \\times N$ 的网格 $u^{\\text{num}}$ 中，该网格的边界填充了精确解的值。然后使用给定公式计算离散 $L^2$ 误差 $E_N$：\n    $$\n    E_{N} = \\left( h^{2} \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{ij}^{\\text{num}} - u_{\\text{exact}}(x_{i}, y_{j}) \\right)^{2} \\right)^{1/2}\n    $$\n\n4.  **精度阶（OOA）估计**：对于每个测试用例，为一系列网格分辨率 $\\{N_{\\ell}\\}_{\\ell=1}^{L}$ 计算误差 $E_{N}$。一个 $p$ 阶精度方法的理论误差行为符合 $E_N \\approx C h^p = C (N-1)^{-p}$，其中 $C$ 是一个常数。取对数得到 $\\log E_N \\approx p \\log h + \\log C$。这是 $\\log E_N$ 和 $\\log h$ 之间的一个线性关系。我们对数据点 $(\\log h_{\\ell}, \\log E_{N_{\\ell}})$ 进行线性最小二乘拟合。所得直线的斜率提供了观测精度阶（OOA）的估计值 $p$。由于我们的离散格式是二阶精度的，我们期望 OOA 接近 2.0。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, isotropic)\n        {'k_xx': 1.0, 'k_xy': 0.0, 'k_yy': 1.0, 'N_levels': [16, 32, 64, 128]},\n        # Test case 2 (strong diagonal anisotropy)\n        {'k_xx': 1.0, 'k_xy': 0.0, 'k_yy': 100.0, 'N_levels': [16, 32, 64, 128]},\n        # Test case 3 (anisotropy with cross coupling)\n        {'k_xx': 2.0, 'k_xy': 0.3, 'k_yy': 3.0, 'N_levels': [16, 32, 64, 128]},\n        # Test case 4 (edge case near-degenerate)\n        {'k_xx': 1.0, 'k_xy': 0.09, 'k_yy': 0.1, 'N_levels': [8, 16, 32, 64]}\n    ]\n\n    ooa_results = []\n    for params in test_cases:\n        ooa = compute_ooa_for_case(params['k_xx'], params['k_xy'], params['k_yy'], params['N_levels'])\n        ooa_results.append(ooa)\n\n    # Format and print the final output\n    formatted_results = [f\"{res:.3f}\" for res in ooa_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_ooa_for_case(k_xx, k_xy, k_yy, N_levels):\n    \"\"\"\n    Computes the Observed Order of Accuracy (OOA) for a single test case.\n    \"\"\"\n    h_values = []\n    error_values = []\n\n    # Define exact solution and source term functions\n    def u_exact_func(x, y):\n        return np.sin(np.pi * x) * np.sin(2 * np.pi * y)\n\n    def f_source_func(x, y, kxx, kxy, kyy):\n        term1 = (kxx + 4 * kyy) * np.sin(np.pi * x) * np.sin(2 * np.pi * y)\n        term2 = -4 * kxy * np.cos(np.pi * x) * np.cos(2 * np.pi * y)\n        return np.pi**2 * (term1 + term2)\n\n    for N in N_levels:\n        h = 1.0 / (N - 1)\n        h_values.append(h)\n\n        # Create grid\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        X, Y = np.meshgrid(x, y, indexing='ij')\n\n        # Evaluate exact solution and source term on the grid\n        u_exact_grid = u_exact_func(X, Y)\n        f_grid = f_source_func(X, Y, k_xx, k_xy, k_yy)\n\n        # Assemble the linear system A * u_int = b\n        N_int = N - 2\n        num_unknowns = N_int * N_int\n\n        if num_unknowns == 0:\n            error_values.append(0.0)\n            continue\n            \n        A = lil_matrix((num_unknowns, num_unknowns), dtype=np.float64)\n        b = np.zeros(num_unknowns, dtype=np.float64)\n        \n        # Stencil coefficients\n        c_center = 2.0 * (k_xx + k_yy)\n        c_ew = -k_xx\n        c_ns = -k_yy\n        c_ne_sw = -k_xy / 2.0\n        c_nw_se = k_xy / 2.0\n\n        stencil_coeffs = {\n            (0, 0): c_center,\n            (1, 0): c_ew, (-1, 0): c_ew,\n            (0, 1): c_ns, (0, -1): c_ns,\n            (1, 1): c_ne_sw, (-1, -1): c_ne_sw,\n            (-1, 1): c_nw_se, (1, -1): c_nw_se,\n        }\n\n        for i_int in range(N_int):\n            for j_int in range(N_int):\n                k_glob = i_int * N_int + j_int\n                i_grid, j_grid = i_int + 1, j_int + 1\n                \n                b[k_glob] = h**2 * f_grid[i_grid, j_grid]\n\n                for (di, dj), coeff in stencil_coeffs.items():\n                    ni, nj = i_grid + di, j_grid + dj\n                    \n                    is_interior = (1 = ni  N - 1) and (1 = nj  N - 1)\n\n                    if (di, dj) == (0, 0):\n                        A[k_glob, k_glob] = coeff\n                    elif is_interior:\n                        ni_int, nj_int = ni - 1, nj - 1\n                        nk_glob = ni_int * N_int + nj_int\n                        A[k_glob, nk_glob] = coeff\n                    else: # Boundary node\n                        u_boundary = u_exact_grid[ni, nj]\n                        b[k_glob] -= coeff * u_boundary\n\n        # Solve the system\n        A_csr = A.tocsr()\n        u_int = spsolve(A_csr, b)\n        \n        # Reconstruct full solution grid\n        u_num = np.copy(u_exact_grid)\n        if num_unknowns  0:\n            u_num[1:-1, 1:-1] = u_int.reshape((N_int, N_int))\n\n        # Compute L2 error\n        error = h * np.linalg.norm(u_num - u_exact_grid)\n        error_values.append(error)\n\n    # Perform linear regression on log-log data to find OOA\n    log_h = np.log(np.array(h_values))\n    log_E = np.log(np.array(error_values))\n    \n    # Use polyfit to find the slope (order of accuracy)\n    p, _ = np.polyfit(log_h, log_E, 1)\n\n    return p\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "即使是经过验证的代码，在离散的计算网格上求解时仍然会引入数值误差，这主要是由网格分辨率不足引起的离散误差。为了确保模拟结果的科学可信度，量化这种不确定性至关重要。本练习将介绍网格收敛指数（Grid Convergence Index, GCI）方法，这是一种评估离散误差并为模拟预测提供置信区间的标准化程序。通过对一系列不同网格分辨率下的模拟结果进行分析，您将学会如何评估数值解的收敛性并以严谨的方式报告其不确定性，这是任何计算研究中不可或缺的一环。",
            "id": "3907212",
            "problem": "您正在研究重建电池电极微观结构中热传导的直接数值模拟（DNS），以预测各向同性有效导热系数，记为 $k_{\\mathrm{eff}}$。在稳态条件和施加较小热梯度的情况下，均质化（体积平均）层面上的傅里叶定律为 $\\mathbf{q} = -k_{\\mathrm{eff}} \\nabla T$，其中 $\\mathbf{q}$ 是热通量，$T$ 是温度。在数值实践中，$k_{\\mathrm{eff}}$ 在具有特征间距 $h$ 的计算网格上进行近似；将网格近似的有效导热系数记为 $k_h$。对于足够精细的网格和一致的离散化，离散误差可以很好地由主阶代数模型 $k_h = k_{\\infty} + C h^{p}$ 近似，其中 $k_{\\infty}$ 是精确（网格无关）值，$C$ 是一个与 $h$ 无关的常数，$p$ 是精度阶数。\n\n给定三个嵌套网格，其间距分别为 $h_1$、$h_2$ 和 $h_3$，满足 $h_2 = r h_1$ 和 $h_3 = r h_2$（其中公共加密比 $r  1$），以及它们对应的有效导热系数估计值 $k_{h_1}$、$k_{h_2}$ 和 $k_{h_3}$，您的任务是：\n- 从主阶离散误差模型出发，推导一个三解理查森外推程序，以估计观测到的精度阶数 $p$ 和外推导热系数 $k_{\\infty}$。\n- 使用网格收敛指数（GCI）的标准定义，将安全系数 $1.25$ 应用于精细-中等网格对，计算精细网格的 GCI，结果表示为小数（而非百分比）。\n- 根据 GCI，报告最精细网格估计值 $k_{h_1}$ 的对称不确定性界限 $[k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$，单位为瓦特每米开尔文（W m$^{-1}$ K$^{-1}$）。所有报告的导热系数和界限均以 W m$^{-1}$ K$^{-1}$ 为单位，并将所有输出四舍五入到 $6$ 位小数。\n\n假设：\n- 在三个网格上收敛是单调的（无奇偶振荡）。\n- 连续网格级别之间的加密比 $r$ 相同。\n- 对于足够精细的网格，离散误差遵循主阶代数模型。\n\n每个测试用例的输入是一个元组 $(r, k_{h_1}, k_{h_2}, k_{h_3})$，其中所有 $k$ 值的单位均为 W m$^{-1}$ K$^{-1}$。请使用以下四个测试用例（测试套件），它们分别用于探究典型情况、非整数加密比情况、从下方收敛情况以及接近收敛的边缘情况：\n- 情况 1：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,2\\,,\\,1.52\\,,\\,1.58\\,,\\,1.82\\,)$\n- 情况 2：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,1.5\\,,\\,0.85\\,,\\,0.891856\\,,\\,0.96875\\,)$\n- 情况 3：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,2\\,,\\,1.92\\,,\\,1.6324\\,,\\,0.5298\\,)$\n- 情况 4：$(r, k_{h_1}, k_{h_2}, k_{h_3}) = (\\,2\\,,\\,1.001\\,,\\,1.004\\,,\\,1.016\\,)$\n\n您的程序必须：\n- 实现该推导过程，为每个测试用例计算：观测到的阶数 $p$、外推导热系数 $k_{\\infty}$、精细网格的 GCI（以小数形式表示），以及围绕 $k_{h_1}$ 的对称不确定性界限 $[k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$，单位为 W m$^{-1}$ K$^{-1}$。\n- 将所有报告的浮点数输出四舍五入到 $6$ 位小数。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身也是一个列表 $[p, k_{\\infty}, \\mathrm{GCI}, k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$，所有条目均为浮点数。例如：$[[p_1,k_{\\infty,1},\\mathrm{GCI}_1,k_{\\mathrm{lower},1},k_{\\mathrm{upper},1}],[p_2,\\dots],\\dots]$。\n\n注意：不涉及角度，因此无需指定角度单位。百分比必须表示为小数（例如，使用 $0.05$ 而不是 $5$ 百分之）。",
            "solution": "该问题被评估为有效，因为它在科学上基于数值分析（特别是离散误差分析）的原理，问题陈述清晰且客观。它提供了一套完整且一致的数据和假设，可以使用标准、可验证的方法推导出唯一的解。\n\n任务是从一系列在嵌套网格上进行的三次数值模拟中，估算与网格无关的有效导热系数 $k_{\\infty}$ 和观测到的精度阶数 $p$。我们还需要计算网格收敛指数（GCI）以及最精细网格解的相应不确定性区间。\n\n出发点是问题中提供的用于数值近似有效导热系数 $k_h$ 的主阶代数误差模型：\n$$k_h = k_{\\infty} + C h^{p}$$\n其中 $k_{\\infty}$ 是精确的、与网格无关的值，$h$ 是特征网格间距，$p$ 是精度阶数，$C$ 是一个常数。\n\n我们已知三个导热系数估计值 $k_{h_1}$、$k_{h_2}$ 和 $k_{h_3}$，它们是在三个间距分别为 $h_1$（精细）、$h_2$（中等）和 $h_3$（粗糙）的网格上计算得出的。这些网格通过一个公共加密比 $r  1$ 相关联，使得 $h_2 = r h_1$ 且 $h_3 = r h_2 = r^2 h_1$。\n\n我们可以为这三个网格分别写出误差模型：\n$$k_{h_1} = k_{\\infty} + C h_1^p \\quad (1)$$\n$$k_{h_2} = k_{\\infty} + C h_2^p = k_{\\infty} + C (r h_1)^p \\quad (2)$$\n$$k_{h_3} = k_{\\infty} + C h_3^p = k_{\\infty} + C (r^2 h_1)^p \\quad (3)$$\n\n为了求出观测到的精度阶数 $p$，我们首先通过对连续方程作差来消去未知数 $k_{\\infty}$。\n用 $(2)$ 减去 $(1)$：\n$$k_{h_2} - k_{h_1} = C ((r h_1)^p - h_1^p) = C h_1^p (r^p - 1) \\quad (4)$$\n用 $(3)$ 减去 $(2)$：\n$$k_{h_3} - k_{h_2} = C ((r^2 h_1)^p - (r h_1)^p) = C (r h_1)^p (r^p - 1) = C h_1^p r^p (r^p - 1) \\quad (5)$$\n\n现在，为了消去 $C$ 和 $h_1$，我们将方程 $(5)$ 与方程 $(4)$ 相除：\n$$\\frac{k_{h_3} - k_{h_2}}{k_{h_2} - k_{h_1}} = \\frac{C h_1^p r^p (r^p - 1)}{C h_1^p (r^p - 1)} = r^p$$\n这使我们能够通过对两边取自然对数来求解 $p$：\n$$\\ln\\left(\\frac{k_{h_3} - k_{h_2}}{k_{h_2} - k_{h_1}}\\right) = \\ln(r^p) = p \\ln(r)$$\n因此，观测到的精度阶数为：\n$$p = \\frac{\\ln\\left(\\frac{k_{h_3} - k_{h_2}}{k_{h_2} - k_{h_1}}\\right)}{\\ln(r)}$$\n\n在确定 $p$ 的值之后，我们可以使用理查森外推法（Richardson extrapolation）来估计与网格无关的解 $k_{\\infty}$。\n重排方程 $(4)$ 得到精细网格上的误差项 $C h_1^p$ 的表达式：\n$$C h_1^p = \\frac{k_{h_2} - k_{h_1}}{r^p - 1}$$\n将此代回方程 $(1)$：\n$$k_{h_1} = k_{\\infty} + \\frac{k_{h_2} - k_{h_1}}{r^p - 1}$$\n求解 $k_{\\infty}$：\n$$k_{\\infty} = k_{h_1} - \\frac{k_{h_2} - k_{h_1}}{r^p - 1} = \\frac{k_{h_1}(r^p - 1) - (k_{h_2} - k_{h_1})}{r^p - 1} = \\frac{k_{h_1}r^p - k_{h_1} - k_{h_2} + k_{h_1}}{r^p - 1}$$\n这可以简化为理查森外推公式：\n$$k_{\\infty} = \\frac{r^p k_{h_1} - k_{h_2}}{r^p - 1}$$\n\n接下来，我们基于精细-中等网格对（$h_1, h_2$）计算精细网格解的网格收敛指数（GCI）。GCI 提供了数值不确定性的估计。使用安全系数 $F_s = 1.25$，GCI 定义为一个小数：\n$$\\mathrm{GCI} = F_s \\left| \\frac{\\epsilon_a}{r^p - 1} \\right|$$\n其中 $\\epsilon_a$ 是精细网格解和中等网格解之间的近似相对误差：\n$$\\epsilon_a = \\frac{k_{h_1} - k_{h_2}}{k_{h_1}}$$\n将 $\\epsilon_a$ 代入 GCI 公式：\n$$\\mathrm{GCI} = 1.25 \\left| \\frac{(k_{h_1} - k_{h_2})/k_{h_1}}{r^p - 1} \\right| = \\frac{1.25}{|r^p - 1|} \\left| \\frac{k_{h_1} - k_{h_2}}{k_{h_1}} \\right|$$\n\n最后，我们确定最精细网格估计值 $k_{h_1}$ 的对称不确定性界限。GCI 代表解 $k_{h_1}$ 的相对不确定性。绝对不确定性为 $\\Delta k = \\mathrm{GCI} \\times |k_{h_1}| $。由于导热系数是正值，所以 $|k_{h_1}| = k_{h_1}$。因此，对称不确定性区间 $[k_{\\mathrm{lower}}, k_{\\mathrm{upper}}]$ 为：\n$$k_{\\mathrm{lower}} = k_{h_1} - \\mathrm{GCI} \\cdot k_{h_1} = k_{h_1} (1 - \\mathrm{GCI})$$\n$$k_{\\mathrm{upper}} = k_{h_1} + \\mathrm{GCI} \\cdot k_{h_1} = k_{h_1} (1 + \\mathrm{GCI})$$\n\n将对每个测试用例实施这些推导出的公式，所有最终浮点值都四舍五入到 $6$ 位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the grid convergence analysis problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (r, k_h1, k_h2, k_h3)\n        (2.0, 1.52, 1.58, 1.82),\n        (1.5, 0.85, 0.891856, 0.96875),\n        (2.0, 1.92, 1.6324, 0.5298),\n        (2.0, 1.001, 1.004, 1.016),\n    ]\n\n    all_results = []\n    \n    # Safety factor for GCI calculation\n    F_s = 1.25\n\n    for case in test_cases:\n        r, k_h1, k_h2, k_h3 = case\n\n        # Step 1: Calculate the observed order of accuracy 'p'\n        # p = ln((k_h3 - k_h2) / (k_h2 - k_h1)) / ln(r)\n        # Check for division by zero, although problem data avoids this.\n        diff_21 = k_h2 - k_h1\n        if diff_21 == 0:\n            # If the two finer solutions are identical, p cannot be determined from this formula.\n            # This indicates convergence or issues. For this problem, we assume diff_21 != 0.\n            # In a real scenario, one might have to handle this (e.g., assume p is the theoretical order).\n            # For this problem, we can continue as the test data is well-behaved.\n            pass\n        \n        ratio_of_diffs = (k_h3 - k_h2) / diff_21\n        # The argument to log must be positive. Monotonic convergence ensures this.\n        p = np.log(ratio_of_diffs) / np.log(r)\n\n        # Step 2: Calculate the extrapolated grid-independent solution 'k_inf'\n        # k_inf = (r^p * k_h1 - k_h2) / (r^p - 1)\n        rp = r**p\n        k_inf = (rp * k_h1 - k_h2) / (rp - 1)\n\n        # Step 3: Calculate the Grid Convergence Index (GCI) for the fine grid\n        # GCI = F_s * | (k_h1 - k_h2) / k_h1 | / (r^p - 1)\n        approx_rel_err = (k_h1 - k_h2) / k_h1\n        gci = F_s * np.abs(approx_rel_err) / (rp - 1)\n        \n        # Step 4: Calculate the symmetric uncertainty bounds for k_h1\n        # k_lower = k_h1 * (1 - GCI)\n        # k_upper = k_h1 * (1 + GCI)\n        k_lower = k_h1 * (1.0 - gci)\n        k_upper = k_h1 * (1.0 + gci)\n\n        # Append the results for the current test case, after rounding\n        all_results.append([\n            round(p, 6),\n            round(k_inf, 6),\n            round(gci, 6),\n            round(k_lower, 6),\n            round(k_upper, 6),\n        ])\n\n    # Format the final output string as a list of lists.\n    # e.g., [[p1, k_inf1, ...], [p2, k_inf2, ...]]\n    inner_list_strings = []\n    for result_list in all_results:\n        # Convert each float in the list to a string. `str()` handles `2.0` vs `2.123` correctly.\n        str_list = [f\"{val:.6f}\" for val in result_list]\n        inner_list_strings.append(f\"[{','.join(str_list)}]\")\n    \n    final_output = f\"[{','.join(inner_list_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}