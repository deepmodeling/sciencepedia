{
    "hands_on_practices": [
        {
            "introduction": "在电池的自动化测试与仿真中，最基础的任务之一就是根据离散的测量数据计算总的充放电量和能量。实际的测试系统并不能连续记录数据，而是以离散的时间点进行采样，并且采样间隔未必均匀。本练习旨在提供处理此类实际情况所需的基本数值工具，不仅教会你如何计算这些关键指标，还通过误差分析让你学会量化计算结果的可信度，这是进行严谨的电池数据分析的基石。",
            "id": "3902321",
            "problem": "考虑一个电池循环情景，其中可测量的物理量是作为时间 $t$（秒）的函数的电流 $I(t)$（安培）和端电压 $V(t)$（伏特）。在一个时间范围 $[0,T]$ 内，电荷吞吐量 $Q$ 定义为积分 $Q=\\int_0^T I(t)\\,dt$（库仑），能量吞吐量 $E$ 定义为 $E=\\int_0^T V(t)I(t)\\,dt$（焦耳）。在自动化电池设计和仿真中，通常只有具有时变采样间隔的离散采样数据。您的任务是通过一种有原则的数值方法从非均匀样本中重构 $Q$ 和 $E$，并基于基本原理推导误差界。所有物理量均使用国际单位制 (SI)；$Q$ 以库仑表示，$E$ 以焦耳表示，所有输出均表示为十进制数。\n\n从电荷和能量吞吐量的核心定义以及标准数值分析基础出发，完成以下任务：\n\n1. 推导一种方法，用于从离散采样值 $\\{t_k\\}_{k=0}^N$、$I_k=I(t_k)$ 和 $V_k=V(t_k)$ 重构积分 $Q=\\int_0^T I(t)\\,dt$ 和 $E=\\int_0^T V(t)I(t)\\,dt$，其中时间戳满足 $0=t_0 < t_1 < \\dots < t_N = T$。\n2. 推导使用您的方法时，重构的电荷 $\\widehat{Q}$ 和能量 $\\widehat{E}$ 的绝对误差的理论上界 $B_Q$ 和 $B_E$。您的界限应取决于时间步长和被积函数导数的最大值。\n3. 对于以下指定的 $I(t)$ 和 $V(t)$ 函数形式，通过符号计算求出精确的 $Q$ 和 $E$ 积分。\n4. 实现一个程序，对于每个测试用例，从给定的参数计算以下八个值：重构电荷 $\\widehat{Q}$、重构能量 $\\widehat{E}$、电荷的绝对误差 $\\text{err}_Q = |\\widehat{Q}-Q|$、电荷的误差界 $B_Q$、能量的绝对误差 $\\text{err}_E = |\\widehat{E}-E|$、能量的误差界 $B_E$，以及两个布尔值，指示 $\\text{err}_Q \\le B_Q$ 和 $\\text{err}_E \\le B_E$ 是否成立。\n\n电流和电压函数由以下公式给出：\n$I(t) = I_0 + I_1 \\sin(at)$\n$V(t) = V_0 + V_1 \\cos(bt)$\n\n测试套件（每个用例为 $(T, N, \\alpha, I_0, I_1, a, V_0, V_1, b)$，数值如指定的 SI 单位）：\n1. Case A (均匀采样): $(1000.0, 64, 0.0, 2.0, 1.5, 0.02, 3.7, 0.2, 0.015)$\n2. Case B (非均匀采样): $(1000.0, 16, 0.9, 2.0, 0.8, 0.05, 3.8, 0.15, 0.03)$\n3. Case C (常数): $(500.0, 50, 0.5, 2.5, 0.0, 0.1, 4.0, 0.0, 0.2)$\n4. Case D (高度非均匀采样): $(200.0, 64, 0.7, 1.8, 1.2, 0.2, 3.6, 0.25, 0.18)$\n\n您的程序应生成一个单行输出，其中包含一个用方括号括起来的逗号分隔的八元组列表，每个元组代表一个测试用例，按顺序排列。",
            "solution": "该问题陈述被评估为有效，因为它基于物理学和数值分析的基本原理，具有科学依据；问题设定良好，目标明确，数据充分；并且没有歧义或矛盾。\n\n### 分析框架\n\n问题的核心在于从离散数据近似定积分并界定相关误差。给定一个在非均匀间隔时间点 $\\{t_k\\}_{k=0}^N$（其中 $0=t_0 < t_1 < \\dots < t_N = T$）采样的函数 $f(t)$，我们的目标是计算积分 $J = \\int_0^T f(t) \\, dt$ 的近似值。\n\n#### 1. 通过复合梯形法则进行数值重构\n\n在整个时间范围 $[0, T]$ 上的积分可以表示为在各个子区间 $[t_k, t_{k+1}]$ 上积分的和：\n$$J = \\int_0^T f(t) \\, dt = \\sum_{k=0}^{N-1} \\int_{t_k}^{t_{k+1}} f(t) \\, dt$$\n梯形法则通过计算一个顶点为 $(t_k, 0)$、$(t_{k+1}, 0)$、$(t_k, f(t_k))$ 和 $(t_{k+1}, f(t_{k+1}))$ 的梯形面积，来近似单个子区间 $[t_k, t_{k+1}]$ 上的积分。令 $h_k = t_{k+1} - t_k$ 为子区间的长度，$f_k = f(t_k)$ 为函数采样值，则该面积由以下公式给出：\n$$\\int_{t_k}^{t_{k+1}} f(t) \\, dt \\approx \\frac{h_k}{2} (f_k + f_{k+1})$$\n复合梯形法则将此近似应用于每个子区间并将结果求和，从而得到总估计积分值 $\\widehat{J}$：\n$$\\widehat{J} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (f_k + f_{k+1})$$\n该公式直接适用于计算重构电荷 $\\widehat{Q}$ 和能量 $\\widehat{E}$。\n\n对于电荷，$f(t) = I(t)$，所以 $f_k = I_k = I(t_k)$。\n$$\\widehat{Q} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (I_k + I_{k+1})$$\n\n对于能量，被积函数是瞬时功率 $P(t) = V(t)I(t)$，所以 $f_k = P_k = V_k I_k$。\n$$\\widehat{E} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (P_k + P_{k+1}) = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (V_k I_k + V_{k+1} I_{k+1})$$\n\n#### 2. 误差界的推导\n\n根据标准数值分析理论，对于一个二阶连续可微函数 $f(t)$，在单个区间 $[a, b]$（宽度 $h = b-a$）上梯形法则的误差为：\n$$E_{trap} = \\int_a^b f(t) \\, dt - \\frac{h}{2}(f(a) + f(b)) = -\\frac{h^3}{12} f''(\\xi)$$\n其中某个 $\\xi \\in (a, b)$。因此绝对误差的界为 $|E_{trap}| \\le \\frac{h^3}{12} \\max_{t \\in [a, b]} |f''(t)|$。\n\n对于非均匀网格 $\\{t_k\\}$ 上的复合规则，总绝对误差的界是每个子区间上绝对误差之和：\n$$|\\text{Total Error}| \\le \\sum_{k=0}^{N-1} \\frac{h_k^3}{12} |f''(\\xi_k)| \\quad \\text{其中 } \\xi_k \\in (t_k, t_{k+1})$$\n为了获得一个可计算的上界 $B_f$，我们使用二阶导数幅值的全局最大值 $M_2 = \\max_{t \\in [0,T]} |f''(t)|$：\n$$B_f = \\frac{M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\n这为数值积分方案提供了一个实用的误差界。\n\n**电荷的误差界 ($B_Q$):**\n被积函数是 $I(t) = I_0 + I_1 \\sin(at)$。其导数为：\n$I'(t) = a I_1 \\cos(at)$\n$I''(t) = -a^2 I_1 \\sin(at)$\n二阶导数的最大幅值为 $M_{2,I} = \\max_{t \\in [0,T]} |-a^2 I_1 \\sin(at)| = a^2 |I_1|$。\n电荷的误差界为：\n$$B_Q = \\frac{a^2 |I_1|}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n**能量的误差界 ($B_E$):**\n被积函数是 $P(t) = V(t)I(t)$。我们使用乘法法则求其二阶导数：\n$P'(t) = V'(t)I(t) + V(t)I'(t)$\n$P''(t) = V''(t)I(t) + 2V'(t)I'(t) + V(t)I''(t)$\n使用三角不等式，我们界定其幅值：\n$|P''(t)| \\le |V''(t)||I(t)| + 2|V'(t)||I'(t)| + |V(t)||I''(t)|$\n我们建立 $I(t)$、$V(t)$ 及其前两阶导数在 $[0,T]$ 上的幅值上界：\n$I(t) = I_0 + I_1 \\sin(at) \\Rightarrow |I(t)| \\le |I_0| + |I_1| \\equiv M_0$\n$|I'(t)| \\le a|I_1| \\equiv M_1$\n$|I''(t)| \\le a^2|I_1| \\equiv M_2$\n$V(t) = V_0 + V_1 \\cos(bt) \\Rightarrow |V(t)| \\le |V_0| + |V_1| \\equiv N_0$\n$|V'(t)| = |-bV_1\\sin(bt)| \\le b|V_1| \\equiv N_1$\n$|V''(t)| = |-b^2V_1\\cos(bt)| \\le b^2|V_1| \\equiv N_2$\n$|P''(t)|$ 的全局界则为 $M_{2,P} = N_2 M_0 + 2 N_1 M_1 + N_0 M_2$。\n能量的误差界为：\n$$B_E = \\frac{M_{2,P}}{12} \\sum_{k=0}^{N-1} h_k^3 = \\frac{N_2 M_0 + 2 N_1 M_1 + N_0 M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n#### 3. 精确解析积分\n\n为了验证，我们符号化地计算精确积分。\n**精确电荷 ($Q$):**\n$$Q = \\int_0^T (I_0 + I_1 \\sin(at)) \\, dt = \\left[I_0 t - \\frac{I_1}{a} \\cos(at)\\right]_0^T = I_0 T - \\frac{I_1}{a}(\\cos(aT) - 1)$$\n**精确能量 ($E$):**\n$$E = \\int_0^T (V_0 + V_1 \\cos(bt))(I_0 + I_1 \\sin(at)) \\, dt$$\n展开乘积并逐项积分得到：\n$E = \\int_0^T \\left(I_0 V_0 + V_0 I_1 \\sin(at) + I_0 V_1 \\cos(bt) + I_1 V_1 \\sin(at)\\cos(bt)\\right) \\, dt$\n使用恒等式 $\\sin(A)\\cos(B) = \\frac{1}{2}(\\sin(A+B) + \\sin(A-B))$ 并假设 $a \\neq b$：\n$$E = I_0 V_0 T - \\frac{V_0 I_1}{a}(\\cos(aT) - 1) + \\frac{I_0 V_1}{b}\\sin(bT) + \\frac{I_1 V_1}{2}\\left[\\frac{1-\\cos((a+b)T)}{a+b} + \\frac{1-\\cos((a-b)T)}{a-b}\\right]$$\n\n#### 4. 非均匀采样网格\n\n时间步长 $\\{h_k\\}$ 通过权重 $w_k = 1 + \\alpha \\cos^2(\\frac{\\pi k}{N})$（对于 $k \\in \\{0, \\dots, N-1\\}$）构造。权重的和可以解析计算：\n$\\sum_{j=0}^{N-1} w_j = \\sum_{j=0}^{N-1} \\left(1 + \\alpha \\frac{1+\\cos(2\\pi j/N)}{2}\\right) = N + \\frac{\\alpha}{2}\\left(N + \\sum_{j=0}^{N-1}\\cos(2\\pi j/N)\\right)$。\n由于N次单位根之和为零，其实部之和也为零，即 $\\sum_{j=0}^{N-1}\\cos(2\\pi j/N) = 0$。\n因此，$\\sum_{j=0}^{N-1} w_j = N(1 + \\alpha/2)$。\n时间步长为 $h_k = \\frac{T w_k}{\\sum w_j} = \\frac{T(1 + \\alpha \\cos^2(\\pi k/N))}{N(1 + \\alpha/2)}$，时间样本为 $t_0=0$, $t_{k+1}=t_k+h_k$。这确保了 $\\sum h_k = t_N = T$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes reconstructed charge and energy from simulated nonuniform battery data,\n    along with their exact values, absolute errors, and theoretical error bounds.\n    \"\"\"\n    test_cases = [\n        # (T, N, alpha, I0, I1, a, V0, V1, b)\n        (1000.0, 64, 0.0, 2.0, 1.5, 0.02, 3.7, 0.2, 0.015),\n        (1000.0, 16, 0.9, 2.0, 0.8, 0.05, 3.8, 0.15, 0.03),\n        (500.0, 50, 0.5, 2.5, 0.0, 0.10, 4.0, 0.0, 0.20),\n        (200.0, 64, 0.7, 1.8, 1.2, 0.20, 3.6, 0.25, 0.18),\n    ]\n\n    all_results = []\n\n    for T, N, alpha, I0, I1, a, V0, V1, b in test_cases:\n        # Part 1: Generate the non-uniform time grid\n        k_indices = np.arange(N)\n        # Using the analytic simplification for the sum of weights\n        sum_of_weights = N * (1 + alpha / 2.0)\n        weights_k = 1 + alpha * np.cos(np.pi * k_indices / N)**2\n        h_steps = (T * weights_k) / sum_of_weights\n        time_stamps = np.concatenate(([0.0], np.cumsum(h_steps)))\n\n        # Part 2: Generate sampled signal data\n        I_samples = I0 + I1 * np.sin(a * time_stamps)\n        V_samples = V0 + V1 * np.cos(b * time_stamps)\n        P_samples = I_samples * V_samples\n\n        # Part 3: Numerical Reconstruction (Composite Trapezoidal Rule)\n        Q_hat = 0.5 * np.sum(h_steps * (I_samples[:-1] + I_samples[1:]))\n        E_hat = 0.5 * np.sum(h_steps * (P_samples[:-1] + P_samples[1:]))\n\n        # Part 4: Analytical Integration (Exact Values)\n        Q_exact = I0 * T\n        if I1 != 0.0 and a != 0.0:\n            Q_exact -= (I1 / a) * (np.cos(a * T) - 1.0)\n\n        E_exact = I0 * V0 * T\n        if V0 != 0.0 and I1 != 0.0 and a != 0.0:\n            E_exact -= (V0 * I1 / a) * (np.cos(a * T) - 1.0)\n        if I0 != 0.0 and V1 != 0.0 and b != 0.0:\n            E_exact += (I0 * V1 / b) * np.sin(b * T)\n        if I1 != 0.0 and V1 != 0.0 and a != b and a != 0.0 and b != 0.0: # a != b is true for all test cases\n            apb = a + b\n            amb = a - b\n            term4 = (I1 * V1 / 2.0) * ((1.0 - np.cos(apb * T)) / apb + (1.0 - np.cos(amb * T)) / amb)\n            E_exact += term4\n        \n        # Part 5: Compute Absolute Errors\n        error_Q = np.abs(Q_hat - Q_exact)\n        error_E = np.abs(E_hat - E_exact)\n\n        # Part 6: Compute Error Bounds\n        sum_h3 = np.sum(h_steps**3)\n        \n        # Bound for Charge (B_Q)\n        M2_I = a**2 * np.abs(I1)\n        B_Q = (M2_I / 12.0) * sum_h3\n        \n        # Bound for Energy (B_E)\n        M0_I = np.abs(I0) + np.abs(I1)\n        M1_I = np.abs(a) * np.abs(I1)\n        \n        N0_V = np.abs(V0) + np.abs(V1)\n        N1_V = np.abs(b) * np.abs(V1)\n        N2_V = b**2 * np.abs(V1)\n        \n        M2_P = N2_V * M0_I + 2.0 * N1_V * M1_I + N0_V * M2_I\n        B_E = (M2_P / 12.0) * sum_h3\n\n        # Part 7: Verify if actual error is within the bound\n        error_Q_within_bound = error_Q = B_Q\n        error_E_within_bound = error_E = B_E\n\n        # Part 8: Collate results for the current test case\n        all_results.append([\n            Q_hat, E_hat, error_Q, B_Q, error_E, B_E,\n            error_Q_within_bound, error_E_within_bound\n        ])\n\n    # Format and print the final output as a single line string\n    case_strings = []\n    for case_result in all_results:\n        value_strings = [str(v) for v in case_result]\n        case_strings.append(f\"[{','.join(value_strings)}]\")\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何处理实验数据后，我们转向利用模型来预测电池性能。本练习将作为一座桥梁，连接复杂的电化学理论（如Doyle-Fuller-Newman模型）与实际可计算的工程模型。通过这个实践，你将了解到电池内部的物理过程——例如反应动力学、欧姆电阻和副反应——是如何共同决定电芯的端电压，并最终影响其能量效率。",
            "id": "3902251",
            "problem": "考虑一个由多孔电极的 Doyle-Fuller-Newman (DFN) 模型描述的锂离子电池。利用固相和电解质中的电荷与质量守恒，以及通过 Butler-Volmer 关系的界面反应动力学，推导出恒流放电期间的端电压和内部过电位的表达式。然后，您将积分电流和过电位的乘积，以计算给定电流下模型预测的能量效率。构建一个程序，在明确指定的近似和参数集下对这些量进行数值评估。\n\n从以下 DFN 模型基础开始：\n\n- 电极区域中的固相电流守恒：$$\\nabla \\cdot \\left(\\sigma \\nabla \\phi_{s}\\right) + a_{s} F j = 0,$$ 其中 $\\sigma$ 是固相电导率，$\\phi_{s}$ 是固相电位， $a_{s}$ 是比表面积， $F$ 是法拉第常数， $j$ 是界面摩尔反应电流密度。\n- 电解质相电流守恒：$$\\nabla \\cdot \\left(\\kappa \\nabla \\phi_{e}\\right) - a_{s} F j = 0,$$ 其中 $\\kappa$ 是电解质电导率， $\\phi_{e}$ 是电解质电位。\n- 通过 Butler-Volmer 的界面反应动力学：$$j = i_{0} \\left[\\exp\\left(\\frac{\\alpha_{a} F \\eta}{R T}\\right) - \\exp\\left(-\\frac{\\alpha_{c} F \\eta}{R T}\\right)\\right],$$ 其中 $i_{0}$ 是交换电流密度，$\\alpha_{a}$ 和 $\\alpha_{c}$ 是阳极和阴极传递系数，$\\eta$ 是局部活化过电位， $R$ 是普适气体常数， $T$ 是温度。\n\n在一维、恒流、等温条件下，假设动力学对称 $\\alpha_{a} = \\alpha_{c} = 0.5$ 且忽略电解质浓度梯度，推导出电池在放电期间的端电压表达式，用开路电压 (OCV)、欧姆电阻和活化过电位表示。假设每个电极贡献大小相等的活化过电位，并且总活化过电位是两个电极贡献之和。对于放电电流 $I$，外部端电压定义为\n$$V(t) = U_{\\mathrm{ocv}}(x(t)) - \\eta_{\\mathrm{act,tot}}(I) - I R_{\\mathrm{ohm}},$$\n其中 $U_{\\mathrm{ocv}}(x)$ 是作为电池荷电状态 $x$ 函数的开路电压，$\\eta_{\\mathrm{act,tot}}(I)$ 是来自两个电极的总活化过电位， $R_{\\mathrm{ohm}}$ 是集总欧姆电阻。\n\n假设总活化过电位具有以下形式\n$$\\eta_{\\mathrm{act,tot}}(I) = 2 \\cdot \\left(\\frac{2 R T}{F}\\right) \\operatorname{asinh}\\left(\\frac{j_{\\mathrm{main}}}{2 i_{0}}\\right),$$\n其中主反应电流密度 $j_{\\mathrm{main}} = \\frac{I_{\\mathrm{main}}}{A}$， $A$ 是总活性界面面积， $I_{\\mathrm{main}} = (1 - f_{\\mathrm{side}}) I$ 是促成主嵌入反应的外部电流部分。这里，$f_{\\mathrm{side}}$ 是分流到副反应且对锂嵌入无贡献的 $I$ 的恒定分数。荷电状态 $x(t)$ 根据以下公式演变\n$$\\frac{d x}{d t} = -\\frac{I_{\\mathrm{main}}}{Q_{\\mathrm{cell}}},$$\n其中 $Q_{\\mathrm{cell}}$ 是以库仑为单位的总容量，初始条件为 $x(0) = x_{0}$。开路电压作为荷电状态的平滑单调函数提供：\n$$U_{\\mathrm{ocv}}(x) = U_{0} + a_{1} \\tanh\\big(b (x - x_{\\mathrm{mid}})\\big) - a_{2} (x - x_{\\mathrm{mid}}).$$\n\n将可逆电能速率定义为 $P_{\\mathrm{rev}}(t) = I \\, U_{\\mathrm{ocv}}(x(t))$，瞬时不可逆损耗速率定义为 $P_{\\mathrm{loss}}(t) = I \\, \\eta_{\\mathrm{act,tot}}(I) + I^{2} R_{\\mathrm{ohm}}$。在时间范围 $[0, T]$ 内，输送到外部电路的放电能量为 $E_{\\mathrm{out}} = \\int_{0}^{T} I \\, V(t) \\, dt$，可逆能量为 $E_{\\mathrm{rev}} = \\int_{0}^{T} I \\, U_{\\mathrm{ocv}}(x(t)) \\, dt$。能量效率，表示为小数（非百分比），为\n$$\\varepsilon_{\\mathrm{energy}} = \\frac{E_{\\mathrm{out}}}{E_{\\mathrm{rev}}} = 1 - \\frac{\\int_{0}^{T} P_{\\mathrm{loss}}(t) \\, dt}{\\int_{0}^{T} P_{\\mathrm{rev}}(t) \\, dt}.$$\n库伦效率，表示为小数，对于这种具有恒定副反应分数的放电过程为\n$$\\varepsilon_{\\mathrm{coulomb}} = \\frac{\\int_{0}^{T} I_{\\mathrm{main}} \\, dt}{\\int_{0}^{T} I \\, dt} = 1 - f_{\\mathrm{side}}.$$\n\n您必须实现一个程序，使用均匀时间步长的数值积分，为下面的测试套件中的每个参数集数值计算 $\\varepsilon_{\\mathrm{energy}}$、$\\varepsilon_{\\mathrm{coulomb}}$ 和放电结束时的端电压 $V(T)$。物理参数值如下：\n\n- 法拉第常数: $F = 96485 \\, \\mathrm{C \\, mol^{-1}}$。\n- 普适气体常数: $R = 8.314 \\, \\mathrm{J \\, mol^{-1} \\, K^{-1}}$。\n- 温度: $T = 298 \\, \\mathrm{K}$。\n- 电池容量: $Q_{\\mathrm{cell}} = 7200 \\, \\mathrm{C}$。\n- OCV 参数: $U_{0} = 3.6 \\, \\mathrm{V}$， $a_{1} = 0.4 \\, \\mathrm{V}$， $b = 12$， $x_{\\mathrm{mid}} = 0.5$，$a_{2} = 0.05 \\, \\mathrm{V}$。\n- 初始荷电状态: $x_{0}$ 因测试用例而异。\n- 时间范围: $T$ 因测试用例而异。\n- 界面面积: $A$ 因测试用例而异。\n- 交换电流密度: $i_{0}$ 因测试用例而异。\n- 欧姆电阻: $R_{\\mathrm{ohm}}$ 因测试用例而异。\n- 副反应分数: $f_{\\mathrm{side}}$ 因测试用例而异。\n- 外部放电电流: $I$ 因测试用例而异。\n\n不使用角度。所有物理量必须使用国际单位制 (SI) 处理。电压以 $\\mathrm{V}$ 为单位报告，能量效率和库伦效率以小数形式报告。时间变量必须以 $\\mathrm{s}$ 为单位。\n\n测试套件（每个用例为 $(I, f_{\\mathrm{side}}, R_{\\mathrm{ohm}}, i_{0}, A, T, x_{0})$，数值如指定的 SI 单位）：\n\n1. Case A（中等电流，小副反应，有限的动力学和电阻）: $(5.0, 0.02, 0.05, 50.0, 0.02, 600.0, 0.9)$。\n2. Case B（接近理想的动力学和零欧姆电阻，小电流）: $(0.5, 0.0, 0.0, 1000.0, 0.02, 600.0, 0.9)$。\n3. Case C（高电流，较大电阻，较慢动力学）: $(20.0, 0.05, 0.1, 20.0, 0.02, 200.0, 0.9)$。\n4. Case D（中等电流，大副反应分数）: $(5.0, 0.5, 0.05, 50.0, 0.02, 600.0, 0.9)$。\n\n您的程序必须：\n- 通过线性常微分方程使用 $I_{\\mathrm{main}} = (1 - f_{\\mathrm{side}}) I$ 来演化 $x(t)$。\n- 在每个时间步计算 $U_{\\mathrm{ocv}}(x(t))$。\n- 对于给定的测试用例，基于恒定的 $j_{\\mathrm{main}}$ 和 $i_{0}$，将 $\\eta_{\\mathrm{act,tot}}(I)$ 视为时间上恒定。\n- 使用均匀时间步长 $\\Delta t$ 在 $[0, T]$ 上数值近似积分。\n- 在评估 $U_{\\mathrm{ocv}}(x)$ 时，将 $x(t)$ 限制在物理上有意义的区间 $[0, 1]$ 内。\n- 为每个用例以浮点数形式返回 $\\varepsilon_{\\mathrm{energy}}$、$\\varepsilon_{\\mathrm{coulomb}}$ 和 $V(T)$。\n\n最终输出格式要求：\n您的程序应生成单行输出，其中包含一个逗号分隔的三元组列表，列表用方括号括起来，每个三元组格式化为 $[E_{\\mathrm{energy}},E_{\\mathrm{coulomb}},V_{T}]$ 并且没有空格。对于上述四个测试用例，输出必须类似于 $[[e_{A},c_{A},v_{A}],[e_{B},c_{B},v_{B}],[e_{C},c_{C},v_{C}],[e_{D},c_{D},v_{D}]]$，其中 $e_{\\cdot}$、$c_{\\cdot}$ 和 $v_{\\cdot}$ 是十进制浮点数。",
            "solution": "问题已经过分析，被认为是有效的。它科学地基于成熟的锂离子电池 Doyle-Fuller-Newman (DFN) 电化学模型，尽管进行了一些指定的简化。该问题是适定的，提供了所有必要的参数、初始条件和函数形式，以得出一个唯一的、可计算的解。所有量都经过精确的数学定义，数值任务也已明确指定。\n\n解决方案首先分析性地简化模型中与时间无关的组件，然后构建一个数值方案来评估计算能量效率所需的时间依赖积分。\n\n**1. 理论构建**\n\n该模型描述了锂离子电池在恒流（恒定电流 $I$）放电期间的端电压 $V(t)$：\n$$V(t) = U_{\\mathrm{ocv}}(x(t)) - \\eta_{\\mathrm{loss}}(I)$$\n其中 $U_{\\mathrm{ocv}}(x(t))$ 是依赖于荷电状态 $x(t)$ 的开路电压，而 $\\eta_{\\mathrm{loss}}(I)$ 代表由内部阻抗引起的总电压损失。该损失项由活化过电位和欧姆损失组成：\n$$\\eta_{\\mathrm{loss}}(I) = \\eta_{\\mathrm{act,tot}}(I) + I R_{\\mathrm{ohm}}$$\n其中 $R_{\\mathrm{ohm}}$ 是欧姆电阻。由于恒定的主反应电流 $I_{\\mathrm{main}}$，荷电状态 $x(t)$ 从其初始值 $x_0$ 开始随时间线性演变：\n$$I_{\\mathrm{main}} = (1 - f_{\\mathrm{side}}) I$$\n$$\\frac{d x}{d t} = -\\frac{I_{\\mathrm{main}}}{Q_{\\mathrm{cell}}} \\Rightarrow x(t) = x(0) - \\frac{I_{\\mathrm{main}}}{Q_{\\mathrm{cell}}} t = x_0 - \\frac{(1 - f_{\\mathrm{side}}) I}{Q_{\\mathrm{cell}}} t$$\n开路电压 $U_{\\mathrm{ocv}}$ 由指定的 $x$ 的函数给出：\n$$U_{\\mathrm{ocv}}(x) = U_{0} + a_{1} \\tanh\\big(b (x - x_{\\mathrm{mid}})\\big) - a_{2} (x - x_{\\mathrm{mid}})$$\n荷电状态的物理意义区间是 $x \\in [0, 1]$。在评估 $U_{\\mathrm{ocv}}$ 之前，任何计算出的超出此范围的 $x(t)$ 值都必须被限制在这些边界内。\n\n总活化过电位 $\\eta_{\\mathrm{act,tot}}$ 是从对称动力学（$\\alpha_a = \\alpha_c = 0.5$）的 Butler-Volmer 方程推导出来的。局部电流密度 $j$ 通过 $j = 2 i_0 \\sinh(\\frac{F \\eta}{2 R T})$ 与局部过电位 $\\eta$ 相关。为 $\\eta$ 反解此式，并假设有两个相等的贡献（来自正极和负极），得到总过电位：\n$$\\eta_{\\mathrm{act,tot}}(I) = 2 \\cdot \\left(\\frac{2 R T}{F}\\right) \\operatorname{asinh}\\left(\\frac{j_{\\mathrm{main}}}{2 i_{0}}\\right)$$\n其中 $j_{\\mathrm{main}} = I_{\\mathrm{main}} / A = (1 - f_{\\mathrm{side}})I / A$。由于对于给定的放电场景，$I$、$f_{\\mathrm{side}}$、$i_0$ 和 $A$ 是恒定的，因此 $\\eta_{\\mathrm{act,tot}}$ 在时间上也是恒定的。\n\n**2. 效率和最终电压计算**\n\n库伦效率 $\\varepsilon_{\\mathrm{coulomb}}$ 是贡献于主反应的电荷与总抽取电荷的比率。对于在时间范围 $[0, T_f]$ 内的恒定电流 $I$ 和 $I_{\\mathrm{main}}$：\n$$\\varepsilon_{\\mathrm{coulomb}} = \\frac{\\int_{0}^{T_f} I_{\\mathrm{main}} \\, dt}{\\int_{0}^{T_f} I \\, dt} = \\frac{I_{\\mathrm{main}} T_f}{I T_f} = \\frac{(1 - f_{\\mathrm{side}})I}{I} = 1 - f_{\\mathrm{side}}$$\n\n能量效率 $\\varepsilon_{\\mathrm{energy}}$ 是外部输送的能量与可用可逆能量的比率。\n$$\\varepsilon_{\\mathrm{energy}} = \\frac{E_{\\mathrm{out}}}{E_{\\mathrm{rev}}} = \\frac{\\int_{0}^{T_f} I V(t) \\, dt}{\\int_{0}^{T_f} I U_{\\mathrm{ocv}}(x(t)) \\, dt}$$\n由于 $I$ 是恒定的，它可以从分子和分母中消去：\n$$\\varepsilon_{\\mathrm{energy}} = \\frac{\\int_{0}^{T_f} V(t) \\, dt}{\\int_{0}^{T_f} U_{\\mathrm{ocv}}(x(t)) \\, dt} = \\frac{\\int_{0}^{T_f} [U_{\\mathrm{ocv}}(x(t)) - \\eta_{\\mathrm{loss}}(I)] \\, dt}{\\int_{0}^{T_f} U_{\\mathrm{ocv}}(x(t)) \\, dt}$$\n总损失 $\\eta_{\\mathrm{loss}}(I)$ 是恒定的，所以我们可以分离积分：\n$$\\varepsilon_{\\mathrm{energy}} = \\frac{\\int_{0}^{T_f} U_{\\mathrm{ocv}}(x(t)) \\, dt - \\eta_{\\mathrm{loss}}(I) T_f}{\\int_{0}^{T_f} U_{\\mathrm{ocv}}(x(t)) \\, dt} = 1 - \\frac{\\eta_{\\mathrm{loss}}(I) T_f}{\\int_{0}^{T_f} U_{\\mathrm{ocv}}(x(t)) \\, dt}$$\n其中 $\\eta_{\\mathrm{loss}}(I) = \\eta_{\\mathrm{act,tot}}(I) + I R_{\\mathrm{ohm}}$。\n\n放电结束时的端电压 $V(T_f)$ 是通过在时间 $t = T_f$ 评估电压方程得到的：\n$$V(T_f) = U_{\\mathrm{ocv}}(x(T_f)) - \\eta_{\\mathrm{act,tot}}(I) - I R_{\\mathrm{ohm}}$$\n其中 $x(T_f) = x_0 - \\frac{(1 - f_{\\mathrm{side}}) I}{Q_{\\mathrm{cell}}} T_f$。\n\n**3. 数值实现**\n\n积分 $\\int_{0}^{T_f} U_{\\mathrm{ocv}}(x(t)) \\, dt$ 通常没有闭合形式的解，必须进行数值计算。为此，我们使用梯形法则。时间区间 $[0, T_f]$ 被离散化为 $N$ 个大小为 $\\Delta t = T_f / N$ 的均匀步长。时间点为 $t_k = k \\Delta t$，其中 $k = 0, 1, \\dots, N$。\n\n每个测试用例的算法如下：\n1.  定义所有物理常数 ($F, R$)、电池参数 ($Q_{\\mathrm{cell}}, U_0, a_1, b, x_{\\mathrm{mid}}, a_2$) 和环境参数（温度 $T$）。\n2.  对于一个给定的测试用例，其参数为 $(I, f_{\\mathrm{side}}, R_{\\mathrm{ohm}}, i_{0}, A, T_f, x_{0})$：\n3.  计算恒定的库伦效率：$\\varepsilon_{\\mathrm{coulomb}} = 1 - f_{\\mathrm{side}}$。\n4.  计算恒定的主反应电流和电流密度：$I_{\\mathrm{main}} = (1 - f_{\\mathrm{side}})I$ 和 $j_{\\mathrm{main}} = I_{\\mathrm{main}} / A$。\n5.  计算恒定的总活化过电位：$\\eta_{\\mathrm{act,tot}} = \\frac{4RT}{F} \\operatorname{asinh}\\left(\\frac{j_{\\mathrm{main}}}{2 i_{0}}\\right)$。\n6.  创建一个从 $0$ 到 $T_f$ 的离散时间向量 $\\mathbf{t} = [t_0, t_1, \\dots, t_N]$。\n7.  在每个时间点计算荷电状态向量 $\\mathbf{x}$：$x_k = x_0 - (I_{\\mathrm{main}}/Q_{\\mathrm{cell}}) t_k$。\n8.  将 $\\mathbf{x}$ 中的值限制在区间 $[0, 1]$ 内，得到 $\\mathbf{x}_{\\text{clamped}}$。\n9.  通过将 $U_{\\mathrm{ocv}}$ 函数应用于 $\\mathbf{x}_{\\text{clamped}}$ 的每个元素来计算 OCV 向量 $\\mathbf{U}_{\\text{ocv}}$。\n10. 对 $\\mathbf{U}_{\\text{ocv}}$ 关于时间 $\\mathbf{t}$ 进行数值积分，以找到积分可逆电压：$U_{\\text{int}} = \\int_{0}^{T_f} U_{\\mathrm{ocv}}(x(t)) \\, dt \\approx \\text{trapz}(\\mathbf{U}_{\\text{ocv}}, \\mathbf{t})$。\n11. 计算总电压损失：$\\eta_{\\mathrm{loss}} = \\eta_{\\mathrm{act,tot}} + I R_{\\mathrm{ohm}}$。\n12. 计算能量效率：$\\varepsilon_{\\mathrm{energy}} = 1 - (\\eta_{\\mathrm{loss}} T_f) / U_{\\text{int}}$。处理 $U_{\\text{int}}=0$ 的情况以避免除以零。\n13. 计算最终端电压：$V(T_f) = U_{\\mathrm{ocv}}(x(T_f, \\text{clamped})) - \\eta_{\\mathrm{loss}}$。值 $U_{\\mathrm{ocv}}(x(T_f, \\text{clamped}))$ 是向量 $\\mathbf{U}_{\\text{ocv}}$ 的最后一个元素。\n14. 存储得到的三元组 $[\\varepsilon_{\\mathrm{energy}}, \\varepsilon_{\\mathrm{coulomb}}, V(T_f)]$。\n\n处理完所有测试用例后，将结果格式化为指定的字符串格式。一个大的 $N$ 值（例如，$10000$）确保数值积分有足够的精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates energy efficiency, coulombic efficiency, and final terminal voltage\n    for a simplified lithium-ion cell model under galvanostatic discharge.\n    \"\"\"\n    \n    # Physical and cell-wide parameter definitions in SI units\n    F = 96485  # Faraday constant (C/mol)\n    R = 8.314  # Universal gas constant (J/mol/K)\n    TEMP = 298  # Temperature (K)\n    \n    Q_CELL = 7200  # Cell capacity (C)\n    \n    # OCV function parameters\n    U0 = 3.6  # V\n    A1 = 0.4  # V\n    B = 12.0  # unitless\n    X_MID = 0.5  # unitless\n    A2 = 0.05  # V\n\n    def u_ocv(x):\n        \"\"\"\n        Calculates the Open-Circuit Voltage (OCV) as a function of state-of-charge (x).\n        The input x is assumed to be already clamped to the [0, 1] range.\n        \"\"\"\n        return U0 + A1 * np.tanh(B * (x - X_MID)) - A2 * (x - X_MID)\n\n    # Test suite: (I, f_side, R_ohm, i0, A, T_final, x0)\n    # Units are SI: A, unitless, Ohm, A/m^2, m^2, s, unitless\n    test_cases = [\n        (5.0, 0.02, 0.05, 50.0, 0.02, 600.0, 0.9),    # Case A\n        (0.5, 0.0, 0.0, 1000.0, 0.02, 600.0, 0.9),   # Case B\n        (20.0, 0.05, 0.1, 20.0, 0.02, 200.0, 0.9),   # Case C\n        (5.0, 0.5, 0.05, 50.0, 0.02, 600.0, 0.9),    # Case D\n    ]\n\n    all_results = []\n    \n    # Number of steps for numerical integration\n    N_steps = 10000\n\n    for case in test_cases:\n        I, f_side, R_ohm, i0, A, T_final, x0 = case\n\n        # 1. Calculate time-independent quantities\n        eps_coulomb = 1.0 - f_side\n        I_main = (1.0 - f_side) * I\n        \n        # Avoid division by zero if interfacial area is zero\n        j_main = I_main / A if A > 0 else 0.0\n        \n        # Calculate total activation overpotential. Avoid math domain error if i0 is zero.\n        # asinh(x) is well-defined for all real x.\n        eta_act_tot = 0.0\n        if i0 > 0:\n            arg = j_main / (2.0 * i0)\n            eta_act_tot = 2.0 * (2.0 * R * TEMP / F) * np.asinh(arg)\n        \n        # Total voltage loss (overpotential) term\n        eta_loss = eta_act_tot + I * R_ohm\n\n        # 2. Set up time discretization for numerical integration\n        t_vec = np.linspace(0, T_final, N_steps)\n        \n        # 3. Calculate SOC evolution over time\n        x_vec = x0 - (I_main / Q_CELL) * t_vec\n        \n        # 4. Clamp SOC to physical bounds [0, 1] for OCV calculation\n        x_vec_clamped = np.clip(x_vec, 0.0, 1.0)\n        \n        # 5. Calculate OCV at each time step\n        u_ocv_vec = u_ocv(x_vec_clamped)\n        \n        # 6. Numerically integrate U_ocv(t) using the trapezoidal rule\n        # This is integral of U_ocv over the time horizon [0, T_final]\n        integral_u_ocv = np.trapz(u_ocv_vec, t_vec)\n        \n        # 7. Calculate energy efficiency\n        eps_energy = 0.0\n        if integral_u_ocv != 0:\n            total_loss_term = eta_loss * T_final\n            eps_energy = 1.0 - (total_loss_term / integral_u_ocv)\n        \n        # 8. Calculate final terminal voltage V(T)\n        u_ocv_final = u_ocv_vec[-1]\n        V_final = u_ocv_final - eta_loss\n        \n        # Format the result triplet for this case\n        result_str = f\"[{eps_energy},{eps_coulomb},{V_final}]\"\n        all_results.append(result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从单个电芯扩展到由多个电芯组成的电池包，会引入新的复杂性，例如电芯之间的不一致性和均衡问题。本练习可视为一个综合性项目，它将建模与控制理论相结合。你的任务是设计一个智能充电策略，在满足关键的安全（温度）和性能（均衡）约束的同时，最大化整个电池包的能量效率，这是现代电池管理系统（BMS）设计中的一项核心挑战。",
            "id": "3902258",
            "problem": "您的任务是开发、指定和实施一种控制策略，在一个自动化的电池设计和仿真背景下，该策略能够调度充电电流和每个电芯的平衡旁路，以在现实约束下最大化电池包的往返能量效率。电池包由串联电芯组成，模型必须包含库仑效率和能量效率以及热限制。您的程序必须在一个离散化的时间范围内计算最优策略，并为每个测试用例报告由此产生的往返能量效率，结果以十进制数表示。\n\n使用的基本原理：\n- 能量守恒：输入的电能为 $E_{\\text{in}} = \\int I(t) V_{\\text{pack}}(t) \\, dt$，电阻热遵循焦耳定律 $P_{\\text{Joule}}(t) = I(t)^2 R_{\\text{pack}}$。\n- 荷电状态（SOC）变化：对于每个电芯 $j$，考虑库仑效率的充电存储电荷增量为 $\\Delta q_j = \\eta_{\\text{C}} \\int \\left(I(t) - b_j(t)\\right) \\, dt$，其中 $\\eta_{\\text{C}}$ 是库仑效率，$b_j(t)$ 是电芯 $j$ 的旁路电流。\n- 一阶集总热模型：对于每个电芯 $j$，温度动态特性为 $C_{\\text{th},j} \\frac{dT_j}{dt} = Q_{\\text{gen},j} - h_j \\left(T_j - T_{\\text{amb}}\\right)$，其中产热 $Q_{\\text{gen},j}(t) \\approx I(t)^2 R_j + b_j(t) V_{0,j}$。\n- 电池包电压近似：采用广泛使用的线性近似 $V_{\\text{pack}}(t) \\approx \\sum_{j=1}^{N} V_{0,j} + I(t) \\sum_{j=1}^{N} R_j$，其中 $V_{0,j}$ 是工作窗口内开路电压的恒定近似值，$R_j$ 是电芯 $j$ 的内阻。\n\n首次出现的缩略语定义：\n- 往返能量（RTE）效率：放电时回收的能量相对于充电时输入能量的比例。我们用 $\\eta_{\\text{RTE}}$ 表示，并在此近似为有用存储能量与输入能量之比，假设在感兴趣的窗口内放电效率接近于1。\n- 荷电状态（SOC）：电芯已用容量的比例，对于电芯 $j$ 表示为 $s_j \\in [0,1]$。\n- 库仑效率（CE）：充电期间有效存储的电荷比例，用 $\\eta_{\\text{C}}$ 表示。\n\n离散化和决策变量：\n- 考虑 $N$ 个串联电芯，索引为 $j \\in \\{1,\\dots,N\\}$，以及一个离散化的充电时间范围，包含 $K$ 个时间步，索引为 $k \\in \\{0,\\dots,K-1\\}$，每个时间步的持续时间为 $\\Delta t$。\n- 每个时间步 $k$ 的决策变量是电池包充电电流 $I_k \\geq 0$ 和每个电芯的旁路电流 $b_{j,k} \\geq 0$，并带有物理约束 $b_{j,k} \\leq I_k$（一个电芯旁路的电流不能超过串联充电电流）。\n- 每个电芯 $j$ 的SOC更新模型为 $s_{j,k+1} = s_{j,k} + \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j}\\left(I_k - b_{j,k}\\right)$，其中 $Q_j$ 是电芯 $j$ 的容量，单位为 $\\text{A}\\cdot\\text{s}$。\n- 每个电芯 $j$ 的温度更新为 $T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right)$。\n\n目标和约束：\n- 输入能量为 $E_{\\text{in}} = \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right)$。\n- 有用存储能量（在恒定开路电压近似下可用于后续放电）为 $E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\, \\eta_{\\text{C}} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right)$。\n- 往返能量效率为 $\\eta_{\\text{RTE}} = \\frac{E_{\\text{stored}}}{E_{\\text{in}}}$。\n- 为了将问题转化为数学上易于处理的形式，在目标SOC均衡约束下最大化 $\\eta_{\\text{RTE}}$。这等效于在满足所有 $j$ 的线性等式约束 $s_{j,K} = s_{\\text{target}}$（由SOC更新模型强制执行）和所有 $j,k$ 的热不等式约束 $T_{j,k} \\leq T_{\\max}$ 的前提下，最小化 $E_{\\text{in}}$。\n\n您的程序必须：\n- 使用数值优化器制定并求解上述离散化优化问题，以获得最小化 $E_{\\text{in}}$ 同时满足所有约束的 $\\{I_k\\}_{k=0}^{K-1}$ 和 $\\{b_{j,k}\\}_{j=1,k=0}^{N,K-1}$。\n- 使用上述定义计算最终的 $\\eta_{\\text{RTE}}$。\n- 物理单位：电流单位为 $\\text{A}$，电压为 $\\text{V}$，电阻为 $\\Omega$，容量为 $\\text{A}\\cdot\\text{s}$，时间为 $\\text{s}$，温度为摄氏度。\n- 将每个最终结果表示为四舍五入到 $6$ 位小数的十进制数。\n\n测试套件和参数：\n提供一个包含三个案例的测试套件。对于每个案例，电池包大小为 $N=3$ 个串联电芯。参数如下：\n\n- 案例1（一般可行情况）：\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$，$R = [0.01, 0.01, 0.01]$ $\\Omega$，$V_0 = [3.70, 3.71, 3.69]$ $\\text{V}$。\n  - $s_0 = [0.30, 0.32, 0.28]$，$s_{\\text{target}} = 0.80$，$\\eta_{\\text{C}} = 0.995$。\n  - $T_0 = [25.0, 25.0, 25.0]$ $\\degree\\text{C}$，$T_{\\text{amb}} = 25.0$ $\\degree\\text{C}$，$T_{\\max} = 40.0$ $\\degree\\text{C}$。\n  - $C_{\\text{th}} = [12000, 12000, 12000]$ $\\text{J}/\\degree\\text{C}$，$h = [12, 12, 12]$ $\\text{W}/\\degree\\text{C}$。\n  - 时间范围：$K=6$，$\\Delta t = 60$ $\\text{s}$，电流边界 $0 \\leq I_k \\leq 20$ $\\text{A}$。\n\n- 案例2（边界温度情况）：\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$，$R = [0.02, 0.02, 0.02]$ $\\Omega$，$V_0 = [3.65, 3.66, 3.64]$ $\\text{V}$。\n  - $s_0 = [0.40, 0.39, 0.41]$，$s_{\\text{target}} = 0.85$，$\\eta_{\\text{C}} = 0.992$。\n  - $T_0 = [35.0, 35.0, 35.0]$ $\\degree\\text{C}$，$T_{\\text{amb}} = 35.0$ $\\degree\\text{C}$，$T_{\\max} = 40.0$ $\\degree\\text{C}$。\n  - $C_{\\text{th}} = [9000, 9000, 9000]$ $\\text{J}/\\degree\\text{C}$，$h = [8, 8, 8]$ $\\text{W}/\\degree\\text{C}$。\n  - 时间范围：$K=5$，$\\Delta t = 60$ $\\text{s}$，电流边界 $0 \\leq I_k \\leq 22$ $\\text{A}$。\n\n- 案例3（低库仑效率情况）：\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$，$R = [0.015, 0.015, 0.015]$ $\\Omega$，$V_0 = [3.68, 3.69, 3.67]$ $\\text{V}$。\n  - $s_0 = [0.20, 0.22, 0.18]$，$s_{\\text{target}} = 0.70$，$\\eta_{\\text{C}} = 0.970$。\n  - $T_0 = [20.0, 20.0, 20.0]$ $\\degree\\text{C}$，$T_{\\text{amb}} = 20.0$ $\\degree\\text{C}$，$T_{\\max} = 50.0$ $\\degree\\text{C}$。\n  - $C_{\\text{th}} = [15000, 15000, 15000]$ $\\text{J}/\\degree\\text{C}$，$h = [15, 15, 15]$ $\\text{W}/\\degree\\text{C}$。\n  - 时间范围：$K=8$，$\\Delta t = 60$ $\\text{s}$，电流边界 $0 \\leq I_k \\leq 15$ $\\text{A}$。\n\n答案规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $\\left[ r_1, r_2, r_3 \\right]$，其中 $r_i$ 是案例 $i$ 的优化后 $\\eta_{\\text{RTE}}$，表示为十进制数并四舍五入到 $6$ 位小数。",
            "solution": "用户提供了一个科学上合理且定义明确的问题。该问题已根据所需标准进行验证，下面提供了完整的解决方案。\n\n任务是为串联电池包设计一种充电策略，以最大化往返能量（RTE）效率，记为 $\\eta_{\\text{RTE}}$。这是通过在 $K$ 个步骤的离散时间范围内控制电池包充电电流 $I_k$ 和每个电芯的旁路电流 $b_{j,k}$ 来实现的。该策略必须遵守物理约束，包括最终荷电状态（SOC）目标和最高电芯温度。\n\n首先，我们将其形式化为一个数学优化问题。问题陈述指出，最大化 $\\eta_{\\text{RTE}} = E_{\\text{stored}}/E_{\\text{in}}$ 等效于最小化输入能量 $E_{\\text{in}}$，因为对于任何可行解，存储的能量 $E_{\\text{stored}}$ 都是恒定的。这是因为每个电芯的最终SOC是一个固定的目标，$s_{j,K} = s_{\\text{target}}$。存储的能量由下式给出：\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_{\\text{C}} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right) $$\n\n从SOC更新方程，$s_{j,K} = s_{j,0} + \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j} \\sum_{k=0}^{K-1} (I_k - b_{j,k})$，我们可以代入总电荷转移项：\n\n$$ \\sum_{k=0}^{K-1} \\Delta t (I_k - b_{j,k}) = \\frac{Q_j (s_{j,K} - s_{j,0})}{\\eta_{\\text{C}}} $$\n\n将此代入 $E_{\\text{stored}}$ 的表达式中，得到：\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_{\\text{C}} \\left( \\frac{Q_j (s_{\\text{target}} - s_{j,0})}{\\eta_{\\text{C}}} \\right) = \\sum_{j=1}^{N} V_{0,j} Q_j (s_{\\text{target}} - s_{j,0}) $$\n\n由于 $V_{0,j}$、$Q_j$、$s_{\\text{target}}$ 和 $s_{j,0}$ 在给定情况下都是固定参数，因此 $E_{\\text{stored}}$ 是一个常数。因此，最大化 $\\eta_{\\text{RTE}}$ 确实等同于最小化输入能量 $E_{\\text{in}}$。\n\n因此，该优化问题可以表述为：\n\n**1. 决策变量**\n需要优化的变量是每个时间步 $k$ 的充电电流 $I_k$ 和每个电芯 $j$ 在每个时间步 $k$ 的旁路电流 $b_{j,k}$。我们将它们排列成一个大小为 $K(N+1)$ 的单一向量 $\\mathbf{x}$：\n$$ \\mathbf{x} = [I_0, \\dots, I_{K-1}, b_{1,0}, \\dots, b_{1,K-1}, \\dots, b_{N,0}, \\dots, b_{N,K-1}] $$\n\n**2. 目标函数**\n目标是最小化总输入能量 $E_{\\text{in}}$，它是决策变量的函数。$E_{\\text{in}}$ 的离散形式为：\n$$ \\min_{\\mathbf{x}} E_{\\text{in}}(\\mathbf{x}) = \\min_{I_k} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right) $$\n这是关于电流 $I_k$ 的二次函数。\n\n**3. 约束**\n该优化受到从电池包物理模型导出的几个约束。\n\n- **变量边界**：电流必须为非负值，且充电电流受最大值 $I_{\\max}$ 限制。电芯的旁路电流不能超过电池包的电流。\n    - $0 \\le I_k \\le I_{\\max}$ for $k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\ge 0$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\le I_k$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n\n- **SOC等式约束**：在时间范围结束时（$k=K$），每个电芯 $j$ 的SOC必须等于目标SOC，$s_{\\text{target}}$。\n    $$ s_{j,0} + \\sum_{k=0}^{K-1} \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j} (I_k - b_{j,k}) = s_{\\text{target}} \\quad \\text{for } j \\in \\{1, \\dots, N\\} $$\n    这 $N$ 个约束对于决策变量 $I_k$ 和 $b_{j,k}$ 是线性的。\n\n- **热不等式约束**：在任何时间步 $k \\in \\{1, \\dots, K\\}$，每个电芯 $j$ 的温度都不得超过 $T_{\\max}$。温度 $T_{j,k}$ 由离散时间热模型确定：\n    $$ T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right) $$\n    这种递推关系意味着 $T_{j,k}$ 是决策变量 $\\{I_m, b_{j,m}\\}$（对于 $m  k$）的非线性函数。因此，这 $N \\times K$ 个约束为：\n    $$ T_{j,k}(\\mathbf{x}) \\le T_{\\max} \\quad \\text{for } j \\in \\{1, \\dots, N\\}, k \\in \\{1, \\dots, K\\} $$\n\n**数值求解策略**\n由于目标函数和热约束的性质，此问题是一个非线性规划（NLP）问题，具体来说是一个二次约束二次规划（QCQP）问题。我们将使用 `scipy.optimize` 库中的 `minimize` 函数，并采用序列最小二乘规划（`SLSQP`）算法，该算法非常适合此类问题。\n\n实现过程包括：\n1.  定义代表目标函数和每组约束的Python函数。这些函数以决策变量向量 $\\mathbf{x}$ 作为输入。\n2.  在约束评估函数内，迭代计算每个时间步的温度。\n3.  将边界和约束以 `minimize` 函数要求的格式（一个包含字典的列表）传递给它。\n4.  数值优化成功收敛的关键步骤是提供一个好的初始猜测值 $\\mathbf{x}_0$。我们基于需要最多充电的电芯来构建一个猜测值。我们计算该电芯所需的平均恒定电流（假设没有旁路），然后确定其他电芯为达到其目标所需的旁路电流。这提供了一个物理上合理的、接近可行域的起点。\n5.  优化器找到最优解向量 $\\mathbf{x}^*$ 后，最小输入能量 $E_{\\text{in}}^*$ 是该点处的目标函数值。\n6.  最终的往返能量效率 $\\eta_{\\text{RTE}}$ 计算为 $\\eta_{\\text{RTE}} = E_{\\text{stored}} / E_{\\text{in}}^*$，其中 $E_{\\text{stored}}$ 是预先计算的常数值。然后将此结果四舍五入到所需精度。\n\n这种结构化的方法将复杂的多物理场电池充电问题转化为一个可解的数值优化任务，从而得出最优控制策略和相应的最大可实现效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the optimization for each.\n    \"\"\"\n    # Case 1: General feasible case\n    case1 = {\n        'N': 3, 'K': 6, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.01, 0.01, 0.01]),\n        'V0': np.array([3.70, 3.71, 3.69]),\n        's0': np.array([0.30, 0.32, 0.28]),\n        's_target': 0.80,\n        'eta_C': 0.995,\n        'T0': np.array([25.0, 25.0, 25.0]),\n        'Tamb': 25.0,\n        'Tmax': 40.0,\n        'C_th': np.array([12000.0, 12000.0, 12000.0]),\n        'h': np.array([12.0, 12.0, 12.0]),\n        'I_max': 20.0\n    }\n\n    # Case 2: Boundary temperature case\n    case2 = {\n        'N': 3, 'K': 5, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.02, 0.02, 0.02]),\n        'V0': np.array([3.65, 3.66, 3.64]),\n        's0': np.array([0.40, 0.39, 0.41]),\n        's_target': 0.85,\n        'eta_C': 0.992,\n        'T0': np.array([35.0, 35.0, 35.0]),\n        'Tamb': 35.0,\n        'Tmax': 40.0,\n        'C_th': np.array([9000.0, 9000.0, 9000.0]),\n        'h': np.array([8.0, 8.0, 8.0]),\n        'I_max': 22.0\n    }\n\n    # Case 3: Low Coulombic efficiency case\n    case3 = {\n        'N': 3, 'K': 8, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.015, 0.015, 0.015]),\n        'V0': np.array([3.68, 3.69, 3.67]),\n        's0': np.array([0.20, 0.22, 0.18]),\n        's_target': 0.70,\n        'eta_C': 0.970,\n        'T0': np.array([20.0, 20.0, 20.0]),\n        'Tamb': 20.0,\n        'Tmax': 50.0,\n        'C_th': np.array([15000.0, 15000.0, 15000.0]),\n        'h': np.array([15.0, 15.0, 15.0]),\n        'I_max': 15.0\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for params in test_cases:\n        result_rte = run_optimization_case(params)\n        results.append(f\"{result_rte:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_optimization_case(params):\n    \"\"\"\n    Sets up and solves the optimization problem for a single test case.\n    \"\"\"\n    N, K, dt = params['N'], params['K'], params['dt']\n    Q, R, V0 = params['Q'], params['R'], params['V0']\n    s0, s_target, eta_C = params['s0'], params['s_target'], params['eta_C']\n    T0, Tamb, Tmax = params['T0'], params['Tamb'], params['Tmax']\n    C_th, h = params['C_th'], params['h']\n    I_max = params['I_max']\n\n    V0_sum = np.sum(V0)\n    R_sum = np.sum(R)\n    \n    num_vars = K * (N + 1)\n\n    # Objective function: Minimize Ein\n    def objective_function(x):\n        I_vars = x[:K]\n        return dt * np.sum(I_vars * V0_sum + I_vars**2 * R_sum)\n\n    # Helper to calculate temperatures\n    def calculate_temperatures(x):\n        I_vars = x[:K]\n        b_vars = x[K:].reshape((N, K))\n        T = np.zeros((N, K + 1))\n        T[:, 0] = T0\n        for k in range(K):\n            Q_gen_k = I_vars[k]**2 * R + b_vars[:, k] * V0\n            T_dot_k = (Q_gen_k - h * (T[:, k] - Tamb)) / C_th\n            T[:, k + 1] = T[:, k] + T_dot_k * dt\n        return T\n\n    # Constraints\n    constraints = []\n\n    # 1. SOC equality constraints: s_j,K = s_target\n    soc_target_charge_integral = Q * (s_target - s0) / (eta_C * dt)\n    for j in range(N):\n        def soc_constraint(x, j=j):\n            I_vars = x[:K]\n            b_j_vars = x[K + j * K : K + (j + 1) * K]\n            return np.sum(I_vars - b_j_vars) - soc_target_charge_integral[j]\n        constraints.append({'type': 'eq', 'fun': soc_constraint})\n\n    # 2. Bypass current inequality: b_j,k = I_k  (or I_k - b_j,k >= 0)\n    for j in range(N):\n        for k in range(K):\n            def bypass_constraint(x, j=j, k=k):\n                return x[k] - x[K + j * K + k]\n            constraints.append({'type': 'ineq', 'fun': bypass_constraint})\n            \n    # 3. Temperature inequality: T_j,k = Tmax (or Tmax - T_j,k >= 0)\n    def temp_constraints(x):\n        temps = calculate_temperatures(x)\n        # Constraints on T_j,k for k=1...K\n        return (Tmax - temps[:, 1:]).flatten()\n    constraints.append({'type': 'ineq', 'fun': temp_constraints})\n\n    # Bounds for decision variables\n    bounds_I = [(0, I_max)] * K\n    bounds_b = [(0, None)] * (N * K) # b_jk >= 0, b_jk = I_k is a separate constraint\n    bounds = bounds_I + bounds_b\n\n    # Initial guess (x0)\n    delta_s = s_target - s0\n    j_star = np.argmax(delta_s)\n    \n    required_charge_integral_star = Q[j_star] * delta_s[j_star] / (eta_C * dt)\n    I_const = np.clip(required_charge_integral_star / K, 0, I_max)\n    \n    x0_I = np.full(K, I_const)\n    x0_b = np.zeros((N, K))\n\n    total_I_integral = K * I_const\n    for j in range(N):\n        if j != j_star:\n            required_charge_integral_j = Q[j] * delta_s[j] / (eta_C * dt)\n            total_bypass_j = total_I_integral - required_charge_integral_j\n            if total_bypass_j > 0:\n                x0_b[j, :] = total_bypass_j / K\n    \n    x0 = np.concatenate([x0_I, x0_b.flatten()])\n    \n    # Run optimization\n    result = minimize(objective_function, x0, method='SLSQP', bounds=bounds, constraints=constraints)\n\n    if not result.success:\n        # Fallback to simpler guess if smart guess was problematic\n        x0_simple = np.full(num_vars, 1e-3)\n        result = minimize(objective_function, x0_simple, method='SLSQP', bounds=bounds, constraints=constraints)\n        if not result.success: # Raise if still fails\n             raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n\n    # Calculate final RTE_efficiency\n    E_in_opt = result.fun\n    E_stored = np.sum(V0 * Q * (s_target - s0))\n    eta_RTE = E_stored / E_in_opt\n    \n    return eta_RTE\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}