{
    "hands_on_practices": [
        {
            "introduction": "In battery science, key performance metrics like charge and energy throughput are defined by continuous integrals, yet all experimental and simulation data are discrete. This practice bridges that gap by applying numerical integration to estimate these crucial quantities from finite data points. By implementing the trapezoidal rule on a non-uniform time grid and deriving the corresponding error bounds, you will gain essential skills for processing real-world battery data with quantitative confidence in the results .",
            "id": "3902321",
            "problem": "Consider a battery cycling scenario where the measurable quantities are the electric current $I(t)$ in amperes and the terminal voltage $V(t)$ in volts as functions of time $t$ in seconds. The charge throughput $Q$ over a time horizon $[0,T]$ is defined by the integral $Q=\\int_0^T I(t)\\,dt$ in coulombs, and the energy throughput $E$ is defined by $E=\\int_0^T V(t)I(t)\\,dt$ in joules. In automated battery design and simulation, one typically only has discretely sampled data with time-varying sampling intervals. Your task is to reconstruct $Q$ and $E$ from nonuniform samples via a principled numerical method and to derive error bounds based on fundamental principles. Use International System of Units (SI) for all physical quantities; express $Q$ in coulombs and $E$ in joules, and express all outputs as decimal numbers.\n\nStarting from core definitions of charge and energy throughput and from standard numerical analysis fundamentals, do the following:\n\n1. Derive a method to reconstruct the integrals $Q=\\int_0^T I(t)\\,dt$ and $E=\\int_0^T V(t)I(t)\\,dt$ from discretely sampled values $\\{t_k\\}_{k=0}^N$, $I_k=I(t_k)$, and $V_k=V(t_k)$, where the time stamps satisfy $0=t_0t_1\\cdotst_N=T$ and the sampling intervals $h_k=t_{k+1}-t_k$ vary with $k$. The method must be based on the trapezoidal rule applied over each subinterval $[t_k,t_{k+1}]$ without assuming uniform spacing.\n2. Using Taylor expansions and well-tested error estimates for numerical integration, derive a computable upper bound on the absolute integration error for the composite trapezoidal rule on a nonuniform mesh: for a twice continuously differentiable integrand $f$, the absolute error over $[0,T]$ is bounded by a quantity that depends on an upper bound on $\\max_{t\\in[0,T]}|f''(t)|$ and on the sampling intervals $\\{h_k\\}$. Apply this to both $f(t)=I(t)$ for the charge integral and $f(t)=P(t)=V(t)I(t)$ for the energy integral. Present a bound for the energy case in terms of bounds on $|I(t)|$, $|V(t)|$, $|I'(t)|$, $|V'(t)|$, $|I''(t)|$, and $|V''(t)|$.\n3. Implement the reconstruction and bound computation in a single program. For verification, use analytically defined test signals $I(t)$ and $V(t)$ so that the exact integrals $Q$ and $E$ can be computed symbolically from first principles. For each test case, compute: the reconstructed charge $\\widehat{Q}$, the reconstructed energy $\\widehat{E}$, the absolute errors $|\\widehat{Q}-Q|$ and $|\\widehat{E}-E|$, and the corresponding trapezoidal error bounds $B_Q$ and $B_E$. Also report two booleans indicating whether the actual errors are within the bounds, that is, whether $|\\widehat{Q}-Q| \\le B_Q$ and $|\\widehat{E}-E| \\le B_E$.\n4. Use the following nonuniform sampling construction. Given a desired number of samples $N+1$ and horizon $T$, define weights $w_k=1+\\alpha\\cos^2\\left(\\frac{\\pi k}{N}\\right)$ for $k\\in\\{0,1,\\dots,N-1\\}$, and set $h_k=\\frac{T\\,w_k}{\\sum_{j=0}^{N-1} w_j}$. Then set $t_0=0$ and $t_{k+1}=t_k+h_k$ for $k=0,1,\\dots,N-1$ so that $t_N=T$. This yields time-varying sampling intervals while controlling the total duration. The integrands are specified as trigonometric signals:\n   - $I(t)=I_0+I_1\\sin(a t)$\n   - $V(t)=V_0+V_1\\cos(b t)$\n   with $I_0$, $I_1$, $a$, $V_0$, $V_1$, and $b$ real constants. Assume $a>0$ and $b>0$. From these, deduce bounds on $|I(t)|$, $|I'(t)|$, $|I''(t)|$, $|V(t)|$, $|V'(t)|$, and $|V''(t)|$ and use them to bound $|P''(t)|$ for $P(t)=V(t)I(t)$.\n\nYour program must produce results for the following four test cases, each specified by $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)$:\n\n- Case $1$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(1000,64,0.6,2.0,1.5,0.02,3.7,0.2,0.015\\right)$.\n- Case $2$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(1000,16,0.9,2.0,0.8,0.05,3.8,0.15,0.03\\right)$.\n- Case $3$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(500,50,0.5,2.5,0.0,0.10,4.0,0.0,0.20\\right)$.\n- Case $4$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(200,64,0.7,1.8,1.2,0.20,3.6,0.25,0.18\\right)$.\n\nFor each case, compute:\n- The reconstructed charge $\\widehat{Q}$ in coulombs and the reconstructed energy $\\widehat{E}$ in joules using the composite trapezoidal rule on the nonuniform grid.\n- The exact charge $Q$ and exact energy $E$ from analytic integration of the given signals over $[0,T]$, and the absolute errors $|\\widehat{Q}-Q|$ and $|\\widehat{E}-E|$.\n- The trapezoidal error bounds $B_Q$ and $B_E$ using the nonuniform interval error bound with an upper bound on $|I''(t)|$ and on $|P''(t)|$ constructed from the given signal parameters.\n- Two booleans indicating whether the actual errors are within the computed bounds.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list for a test case in the order of the cases. Each test case list must contain eight entries: $[\\widehat{Q},\\widehat{E},|\\widehat{Q}-Q|,B_Q,|\\widehat{E}-E|,B_E,\\text{error\\_Q\\_within\\_bound},\\text{error\\_E\\_within\\_bound}]$. All numeric values must be decimals in International System of Units (SI) and the booleans must be logical values.",
            "solution": "The problem statement is assessed to be valid as it is scientifically grounded in fundamental principles of physics and numerical analysis, is well-posed with a clear objective and sufficient data, and is free from ambiguity or contradiction.\n\n### Analytical Framework\n\nThe core of the problem lies in approximating definite integrals from discrete data and bounding the associated error. Given a function $f(t)$ sampled at non-uniformly spaced time points $\\{t_k\\}_{k=0}^N$ such that $0=t_0  t_1  \\dots  t_N = T$, we aim to compute an approximation of the integral $J = \\int_0^T f(t) \\, dt$.\n\n#### 1. Numerical Reconstruction via the Composite Trapezoidal Rule\n\nThe integral over the full time horizon $[0, T]$ can be expressed as a sum of integrals over the subintervals $[t_k, t_{k+1}]$:\n$$J = \\int_0^T f(t) \\, dt = \\sum_{k=0}^{N-1} \\int_{t_k}^{t_{k+1}} f(t) \\, dt$$\nThe trapezoidal rule approximates the integral over a single subinterval $[t_k, t_{k+1}]$ by calculating the area of a trapezoid with vertices at $(t_k, 0)$, $(t_{k+1}, 0)$, $(t_k, f(t_k))$, and $(t_{k+1}, f(t_{k+1}))$. Letting $h_k = t_{k+1} - t_k$ be the length of the subinterval and $f_k = f(t_k)$ be the sampled function value, this area is given by:\n$$\\int_{t_k}^{t_{k+1}} f(t) \\, dt \\approx \\frac{h_k}{2} (f_k + f_{k+1})$$\nThe composite trapezoidal rule applies this approximation to each subinterval and sums the results to yield the total estimated integral, $\\widehat{J}$:\n$$\\widehat{J} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (f_k + f_{k+1})$$\nThis formula is directly applicable to the computation of reconstructed charge $\\widehat{Q}$ and energy $\\widehat{E}$.\n\nFor charge, $f(t) = I(t)$, so $f_k = I_k = I(t_k)$.\n$$\\widehat{Q} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (I_k + I_{k+1})$$\n\nFor energy, the integrand is the instantaneous power $P(t) = V(t)I(t)$, so $f_k = P_k = V_k I_k$.\n$$\\widehat{E} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (P_k + P_{k+1}) = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (V_k I_k + V_{k+1} I_{k+1})$$\n\n#### 2. Derivation of Error Bounds\n\nThe error of the trapezoidal rule on a single interval $[a, b]$ with width $h = b-a$ for a twice continuously differentiable function $f(t)$ is given by standard numerical analysis theory:\n$$E_{trap} = \\int_a^b f(t) \\, dt - \\frac{h}{2}(f(a) + f(b)) = -\\frac{h^3}{12} f''(\\xi)$$\nfor some $\\xi \\in (a, b)$. The absolute error is thus bounded by $|E_{trap}| \\le \\frac{h^3}{12} \\max_{t \\in [a, b]} |f''(t)|$.\n\nFor the composite rule on the non-uniform grid $\\{t_k\\}$, the total absolute error is bounded by the sum of the absolute errors on each subinterval:\n$$|\\text{Total Error}| \\le \\sum_{k=0}^{N-1} \\frac{h_k^3}{12} |f''(\\xi_k)| \\quad \\text{for } \\xi_k \\in (t_k, t_{k+1})$$\nTo obtain a computable upper bound $B_f$, we use the global maximum of the second derivative's magnitude, $M_2 = \\max_{t \\in [0,T]} |f''(t)|$:\n$$B_f = \\frac{M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\nThis provides a practical error bound for the numerical integration scheme.\n\n**Error Bound for Charge ($B_Q$):**\nThe integrand is $I(t) = I_0 + I_1 \\sin(at)$. Its derivatives are:\n$I'(t) = a I_1 \\cos(at)$\n$I''(t) = -a^2 I_1 \\sin(at)$\nThe maximum magnitude of the second derivative is $M_{2,I} = \\max_{t \\in [0,T]} |-a^2 I_1 \\sin(at)| = a^2 |I_1|$.\nThe error bound for charge is:\n$$B_Q = \\frac{a^2 |I_1|}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n**Error Bound for Energy ($B_E$):**\nThe integrand is $P(t) = V(t)I(t)$. We find its second derivative using the product rule:\n$P'(t) = V'(t)I(t) + V(t)I'(t)$\n$P''(t) = V''(t)I(t) + 2V'(t)I'(t) + V(t)I''(t)$\nUsing the triangle inequality, we bound its magnitude:\n$|P''(t)| \\le |V''(t)||I(t)| + 2|V'(t)||I'(t)| + |V(t)||I''(t)|$\nWe establish upper bounds for the magnitudes of $I(t)$, $V(t)$, and their first two derivatives over $[0,T]$:\n$I(t) = I_0 + I_1 \\sin(at) \\Rightarrow |I(t)| \\le |I_0| + |I_1| \\equiv M_0$\n$|I'(t)| \\le a|I_1| \\equiv M_1$\n$|I''(t)| \\le a^2|I_1| \\equiv M_2$\n$V(t) = V_0 + V_1 \\cos(bt) \\Rightarrow |V(t)| \\le |V_0| + |V_1| \\equiv N_0$\n$|V'(t)| = |-bV_1\\sin(bt)| \\le b|V_1| \\equiv N_1$\n$|V''(t)| = |-b^2V_1\\cos(bt)| \\le b^2|V_1| \\equiv N_2$\nThe global bound on $|P''(t)|$ is then $M_{2,P} = N_2 M_0 + 2 N_1 M_1 + N_0 M_2$.\nThe error bound for energy is:\n$$B_E = \\frac{M_{2,P}}{12} \\sum_{k=0}^{N-1} h_k^3 = \\frac{N_2 M_0 + 2 N_1 M_1 + N_0 M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n#### 3. Exact Analytic Integrals\n\nFor verification, we compute the exact integrals symbolically.\n**Exact Charge ($Q$):**\n$$Q = \\int_0^T (I_0 + I_1 \\sin(at)) \\, dt = \\left[I_0 t - \\frac{I_1}{a} \\cos(at)\\right]_0^T = I_0 T - \\frac{I_1}{a}(\\cos(aT) - 1)$$\n**Exact Energy ($E$):**\n$$E = \\int_0^T (V_0 + V_1 \\cos(bt))(I_0 + I_1 \\sin(at)) \\, dt$$\nExpanding the product and integrating term-by-term yields:\n$E = \\int_0^T \\left(I_0 V_0 + V_0 I_1 \\sin(at) + I_0 V_1 \\cos(bt) + I_1 V_1 \\sin(at)\\cos(bt)\\right) \\, dt$\nUsing the identity $\\sin(A)\\cos(B) = \\frac{1}{2}(\\sin(A+B) + \\sin(A-B))$ and assuming $a \\neq b$:\n$$E = I_0 V_0 T - \\frac{V_0 I_1}{a}(\\cos(aT) - 1) + \\frac{I_0 V_1}{b}\\sin(bT) + \\frac{I_1 V_1}{2}\\left[\\frac{1-\\cos((a+b)T)}{a+b} + \\frac{1-\\cos((a-b)T)}{a-b}\\right]$$\n\n#### 4. Non-uniform Sampling Grid\n\nThe time steps $\\{h_k\\}$ are constructed via weights $w_k = 1 + \\alpha \\cos^2(\\frac{\\pi k}{N})$ for $k \\in \\{0, \\dots, N-1\\}$. The sum of weights can be computed analytically:\n$\\sum_{j=0}^{N-1} w_j = \\sum_{j=0}^{N-1} \\left(1 + \\alpha \\frac{1+\\cos(2\\pi j/N)}{2}\\right) = N + \\frac{\\alpha}{2}\\left(N + \\sum_{j=0}^{N-1}\\cos(2\\pi j/N)\\right)$.\nSince the sum of the $N$-th roots of unity is zero, their real parts also sum to zero, i.e., $\\sum_{j=0}^{N-1}\\cos(2\\pi j/N) = 0$.\nThus, $\\sum_{j=0}^{N-1} w_j = N(1 + \\alpha/2)$.\nThe time steps are $h_k = \\frac{T w_k}{\\sum w_j} = \\frac{T(1 + \\alpha \\cos^2(\\pi k/N))}{N(1 + \\alpha/2)}$, and the time samples are $t_0=0$, $t_{k+1}=t_k+h_k$. This ensures $\\sum h_k = t_N = T$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes reconstructed charge and energy from simulated nonuniform battery data,\n    along with their exact values, absolute errors, and theoretical error bounds.\n    \"\"\"\n    test_cases = [\n        # (T, N, alpha, I0, I1, a, V0, V1, b)\n        (1000.0, 64, 0.6, 2.0, 1.5, 0.02, 3.7, 0.2, 0.015),\n        (1000.0, 16, 0.9, 2.0, 0.8, 0.05, 3.8, 0.15, 0.03),\n        (500.0, 50, 0.5, 2.5, 0.0, 0.10, 4.0, 0.0, 0.20),\n        (200.0, 64, 0.7, 1.8, 1.2, 0.20, 3.6, 0.25, 0.18),\n    ]\n\n    all_results = []\n\n    for T, N, alpha, I0, I1, a, V0, V1, b in test_cases:\n        # Part 1: Generate the non-uniform time grid\n        k_indices = np.arange(N)\n        # Using the analytic simplification for the sum of weights\n        sum_of_weights = N * (1 + alpha / 2.0)\n        weights_k = 1 + alpha * np.cos(np.pi * k_indices / N)**2\n        h_steps = (T * weights_k) / sum_of_weights\n        time_stamps = np.concatenate(([0.0], np.cumsum(h_steps)))\n\n        # Part 2: Generate sampled signal data\n        I_samples = I0 + I1 * np.sin(a * time_stamps)\n        V_samples = V0 + V1 * np.cos(b * time_stamps)\n        P_samples = I_samples * V_samples\n\n        # Part 3: Numerical Reconstruction (Composite Trapezoidal Rule)\n        Q_hat = 0.5 * np.sum(h_steps * (I_samples[:-1] + I_samples[1:]))\n        E_hat = 0.5 * np.sum(h_steps * (P_samples[:-1] + P_samples[1:]))\n\n        # Part 4: Analytical Integration (Exact Values)\n        Q_exact = I0 * T\n        if I1 != 0.0 and a != 0.0:\n            Q_exact -= (I1 / a) * (np.cos(a * T) - 1.0)\n\n        E_exact = I0 * V0 * T\n        if V0 != 0.0 and I1 != 0.0 and a != 0.0:\n            E_exact -= (V0 * I1 / a) * (np.cos(a * T) - 1.0)\n        if I0 != 0.0 and V1 != 0.0 and b != 0.0:\n            E_exact += (I0 * V1 / b) * np.sin(b * T)\n        if I1 != 0.0 and V1 != 0.0 and a != b and a != 0.0 and b != 0.0: # a != b is true for all test cases\n            apb = a + b\n            amb = a - b\n            term4 = (I1 * V1 / 2.0) * ((1.0 - np.cos(apb * T)) / apb + (1.0 - np.cos(amb * T)) / amb)\n            E_exact += term4\n        \n        # Part 5: Compute Absolute Errors\n        error_Q = np.abs(Q_hat - Q_exact)\n        error_E = np.abs(E_hat - E_exact)\n\n        # Part 6: Compute Error Bounds\n        sum_h3 = np.sum(h_steps**3)\n        \n        # Bound for Charge (B_Q)\n        M2_I = a**2 * np.abs(I1)\n        B_Q = (M2_I / 12.0) * sum_h3\n        \n        # Bound for Energy (B_E)\n        M0_I = np.abs(I0) + np.abs(I1)\n        M1_I = np.abs(a) * np.abs(I1)\n        \n        N0_V = np.abs(V0) + np.abs(V1)\n        N1_V = np.abs(b) * np.abs(V1)\n        N2_V = b**2 * np.abs(V1)\n        \n        M2_P = N2_V * M0_I + 2.0 * N1_V * M1_I + N0_V * M2_I\n        B_E = (M2_P / 12.0) * sum_h3\n\n        # Part 7: Verify if actual error is within the bound\n        error_Q_within_bound = error_Q = B_Q\n        error_E_within_bound = error_E = B_E\n\n        # Part 8: Collate results for the current test case\n        all_results.append([\n            Q_hat, E_hat, error_Q, B_Q, error_E, B_E,\n            error_Q_within_bound, error_E_within_bound\n        ])\n\n    # Format and print the final output as a single line string\n    case_strings = []\n    for case_result in all_results:\n        value_strings = [str(v) for v in case_result]\n        case_strings.append(f\"[{','.join(value_strings)}]\")\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Coulombic inefficiency often originates from parasitic side reactions whose rates depend on the local potential within an electrode. This exercise advances from lumped-parameter models to a more physically insightful porous electrode model, accounting for potential distribution across the electrode's thickness. By numerically integrating the side-reaction current over both space and time, you will develop a quantitative understanding of how electrode architecture and operating conditions contribute to capacity loss and impact coulombic efficiency .",
            "id": "3902291",
            "problem": "Consider a one-dimensional porous electrode of thickness $L$ and geometric area $A$ undergoing a constant-current charge over time $t \\in [0,t_c]$. The applied current is $I_{\\mathrm{app}}$ (positive for charging; note that this is a local convention for this problem, differing from the main article's standard), and the solid-phase potential along the thickness coordinate $x \\in [0,L]$ is modeled using Ohm's law in the solid phase with uniform current density. Assume the solid-phase conductivity is $\\sigma_s$ and the main reversible reaction potential evolves as a prescribed function $E_{\\mathrm{main}}(t)$ due to the change in state-of-charge. Let the local solid-phase potential be approximated by a linear profile\n$$\n\\phi_s(x,t) = E_{\\mathrm{main}}(t) - \\frac{I_{\\mathrm{app}}}{A} \\frac{x}{\\sigma_s},\n$$\nreferenced to the electrolyte potential, which is taken as the zero reference. A parasitic side reaction (e.g., Solid Electrolyte Interphase (SEI) formation) occurs with interfacial current density $j_{\\mathrm{side}}(x,t)$ described by an anodic Tafel relation,\n$$\nj_{\\mathrm{side}}(x,t) = j_{0,\\mathrm{side}} \\exp\\left(\\frac{\\alpha_{\\mathrm{side}} F}{R T} \\, \\eta_{\\mathrm{side}}(x,t)\\right),\n$$\nwhere $j_{0,\\mathrm{side}}$ is the side-reaction exchange current density, $\\alpha_{\\mathrm{side}}$ is the charge transfer coefficient, $F$ is the Faraday constant, $R$ is the universal gas constant, $T$ is the absolute temperature, and the overpotential for the side reaction is\n$$\n\\eta_{\\mathrm{side}}(x,t) = \\phi_s(x,t) - U_{\\mathrm{side}},\n$$\nwith $U_{\\mathrm{side}}$ being the equilibrium potential for the side reaction. The porous electrode has specific surface area $a_s$ (interfacial area per unit volume), so the volumetric side-reaction current density is $i_{\\mathrm{side}}(x,t) = a_s j_{\\mathrm{side}}(x,t)$.\n\nFrom conservation of charge, the total charge input during charge is $Q_{\\mathrm{in}} = I_{\\mathrm{app}} t_c$, and the charge lost to the side reaction is\n$$\nQ_{\\mathrm{loss}} = \\int_{0}^{t_c} \\int_{0}^{L} i_{\\mathrm{side}}(x,t) \\, A \\, dx \\, dt.\n$$\nDefine the reversibly stored charge as $Q_{\\mathrm{main}} = Q_{\\mathrm{in}} - Q_{\\mathrm{loss}}$, and the coulombic efficiency as the ratio\n$$\n\\mathrm{CE} = \\frac{Q_{\\mathrm{main}}}{Q_{\\mathrm{in}}}.\n$$\nFor energy efficiency, approximate the terminal voltage during charge as\n$$\nV_{\\mathrm{term}}^{\\mathrm{ch}}(t) = E_{\\mathrm{main}}(t) + \\Delta V_{\\mathrm{ohm}},\n$$\nwhere the average ohmic contribution is $\\Delta V_{\\mathrm{ohm}} = \\frac{I_{\\mathrm{app}}}{A} \\frac{L}{2 \\sigma_s}$ due to the linear potential profile. The electrical energy input is\n$$\nW_{\\mathrm{in}} = \\int_{0}^{t_c} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{ch}}(t) \\, dt.\n$$\nAssume discharge occurs at the same magnitude of current $I_{\\mathrm{app}}$ for a duration $t_d = \\frac{Q_{\\mathrm{main}}}{I_{\\mathrm{app}}}$, and the main reaction potential retraces along the state-of-charge path in reverse, i.e.,\n$$\nE_{\\mathrm{main}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}(t_c - t),\n$$\nwith terminal voltage\n$$\nV_{\\mathrm{term}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}^{\\mathrm{dis}}(t) - \\Delta V_{\\mathrm{ohm}}.\n$$\nThe electrical energy delivered on discharge is\n$$\nW_{\\mathrm{out}} = \\int_{0}^{t_d} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{dis}}(t) \\, dt,\n$$\nand the energy efficiency is $\\mathrm{EE} = \\frac{W_{\\mathrm{out}}}{W_{\\mathrm{in}}}$. All energies $W_{\\mathrm{in}}$ and $W_{\\mathrm{out}}$ are in joules.\n\nYour task is to implement a program that, for each parameter set, computes the coulombic efficiency $\\mathrm{CE}$ and energy efficiency $\\mathrm{EE}$ by numerically evaluating the above integrals in space and time. Use numerical quadrature that is sufficiently resolved to capture the exponential dependence in the side-reaction kinetics. Express both $\\mathrm{CE}$ and $\\mathrm{EE}$ as decimals rounded to six decimal places (no percentage sign). The terminal voltage approximations and the assumed discharge policy must be used as stated.\n\nUse the following test suite of parameter sets. In each case, the function $E_{\\mathrm{main}}(t)$ is prescribed as $E_{\\mathrm{main}}(t) = E_0 + k_\\eta t$ with $E_0$ and $k_\\eta$ given:\n\n- Test Case $1$ (general case):\n  - $A = 0.01 \\ \\mathrm{m}^2$\n  - $L = 1.0 \\times 10^{-4} \\ \\mathrm{m}$\n  - $\\sigma_s = 1000 \\ \\mathrm{S/m}$\n  - $a_s = 8.0 \\times 10^{4} \\ \\mathrm{m}^2/\\mathrm{m}^3$\n  - $I_{\\mathrm{app}} = 2.0 \\ \\mathrm{A}$\n  - $t_c = 1800 \\ \\mathrm{s}$\n  - $E_0 = 3.6 \\ \\mathrm{V}$\n  - $k_\\eta = 2.0 \\times 10^{-4} \\ \\mathrm{V/s}$\n  - $U_{\\mathrm{side}} = 4.0 \\ \\mathrm{V}$\n  - $j_{0,\\mathrm{side}} = 2.0 \\times 10^{-2} \\ \\mathrm{A/m}^2$\n  - $\\alpha_{\\mathrm{side}} = 0.5$\n  - $T = 298 \\ \\mathrm{K}$\n\n- Test Case $2$ (no side reaction edge case):\n  - Same as Test Case $1$ except $j_{0,\\mathrm{side}} = 0.0 \\ \\mathrm{A/m}^2$\n\n- Test Case $3$ (low conductivity and closer side-reaction potential):\n  - $A = 0.01 \\ \\mathrm{m}^2$\n  - $L = 1.5 \\times 10^{-4} \\ \\mathrm{m}$\n  - $\\sigma_s = 200 \\ \\mathrm{S/m}$\n  - $a_s = 1.2 \\times 10^{5} \\ \\mathrm{m}^2/\\mathrm{m}^3$\n  - $I_{\\mathrm{app}} = 3.0 \\ \\mathrm{A}$\n  - $t_c = 1200 \\ \\mathrm{s}$\n  - $E_0 = 3.5 \\ \\mathrm{V}$\n  - $k_\\eta = 3.0 \\times 10^{-4} \\ \\mathrm{V/s}$\n  - $U_{\\mathrm{side}} = 3.85 \\ \\mathrm{V}$\n  - $j_{0,\\mathrm{side}} = 2.0 \\times 10^{-2} \\ \\mathrm{A/m}^2$\n  - $\\alpha_{\\mathrm{side}} = 0.5$\n  - $T = 298 \\ \\mathrm{K}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\mathrm{CE}_1,\\mathrm{EE}_1,\\mathrm{CE}_2,\\mathrm{EE}_2,\\mathrm{CE}_3,\\mathrm{EE}_3]$, where the subscript denotes the test case number. Each entry must be rounded to six decimal places. Units: $\\mathrm{CE}$ and $\\mathrm{EE}$ are dimensionless decimals; energies are internal to the computation in joules; potentials in volts; time in seconds; length in meters; area in square meters; conductivity in siemens per meter; temperature in kelvin.",
            "solution": "The problem statement has been meticulously reviewed and is determined to be valid. It is scientifically grounded in established electrochemical principles, mathematically well-posed, and provides a complete and consistent set of parameters and definitions. The problem constitutes a simplified yet non-trivial exercise in battery modeling, requiring the calculation of key performance metrics from a given physical model.\n\nThe task is to compute the coulombic efficiency ($\\mathrm{CE}$) and energy efficiency ($\\mathrm{EE}$) for a one-dimensional porous electrode under specified charging and discharging conditions. The solution proceeds by first deriving the expressions for the necessary quantities and then outlining the computational approach.\n\n**1. Coulombic Efficiency ($\\mathrm{CE}$)**\n\nThe coulombic efficiency is defined as the ratio of the reversibly stored charge to the total input charge, $\\mathrm{CE} = Q_{\\mathrm{main}} / Q_{\\mathrm{in}}$.\n\nThe total charge supplied to the electrode during the charging time $t_c$ at a constant current $I_{\\mathrm{app}}$ is:\n$$\nQ_{\\mathrm{in}} = I_{\\mathrm{app}} t_c\n$$\n\nA portion of this charge, $Q_{\\mathrm{loss}}$, is consumed by a parasitic side reaction. This lost charge must be calculated by integrating the volumetric side-reaction current density, $i_{\\mathrm{side}}(x,t)$, over the electrode volume and the charging duration:\n$$\nQ_{\\mathrm{loss}} = \\int_{0}^{t_c} \\int_{0}^{L} i_{\\mathrm{side}}(x,t) \\, A \\, dx \\, dt\n$$\nThe volumetric current density is given as $i_{\\mathrm{side}}(x,t) = a_s j_{\\mathrm{side}}(x,t)$, where $a_s$ is the specific surface area and $j_{\\mathrm{side}}(x,t)$ is the interfacial current density. The latter is described by a Tafel relation:\n$$\nj_{\\mathrm{side}}(x,t) = j_{0,\\mathrm{side}} \\exp\\left(\\frac{\\alpha_{\\mathrm{side}} F}{R T} \\, \\eta_{\\mathrm{side}}(x,t)\\right)\n$$\nThe overpotential for the side reaction, $\\eta_{\\mathrm{side}}(x,t)$, depends on the local solid-phase potential $\\phi_s(x,t)$ and the side reaction's equilibrium potential $U_{\\mathrm{side}}$:\n$$\n\\eta_{\\mathrm{side}}(x,t) = \\phi_s(x,t) - U_{\\mathrm{side}}\n$$\nSubstituting the given models for $\\phi_s(x,t) = E_{\\mathrm{main}}(t) - \\frac{I_{\\mathrm{app}}}{A} \\frac{x}{\\sigma_s}$ and $E_{\\mathrm{main}}(t) = E_0 + k_\\eta t$, the overpotential becomes:\n$$\n\\eta_{\\mathrm{side}}(x,t) = \\left(E_0 + k_\\eta t - \\frac{I_{\\mathrm{app}}}{A \\sigma_s} x\\right) - U_{\\mathrm{side}}\n$$\nThe full integrand for $Q_{\\mathrm{loss}}$ is therefore:\n$$\nA \\, i_{\\mathrm{side}}(x,t) = A \\, a_s \\, j_{0,\\mathrm{side}} \\exp\\left(\\frac{\\alpha_{\\mathrm{side}} F}{R T} \\left(E_0 - U_{\\mathrm{side}} + k_\\eta t - \\frac{I_{\\mathrm{app}}}{A \\sigma_s} x\\right)\\right)\n$$\nThis double integral for $Q_{\\mathrm{loss}}$ must be evaluated. While it is analytically tractable due to the separability of the exponential function's argument in $x$ and $t$, the problem statement specifies a numerical evaluation, which will be performed using standard quadrature methods.\n\nThe reversibly stored charge is $Q_{\\mathrm{main}} = Q_{\\mathrm{in}} - Q_{\\mathrm{loss}}$. The coulombic efficiency is then:\n$$\n\\mathrm{CE} = \\frac{Q_{\\mathrm{in}} - Q_{\\mathrm{loss}}}{Q_{\\mathrm{in}}} = 1 - \\frac{Q_{\\mathrm{loss}}}{Q_{\\mathrm{in}}}\n$$\nFor the special case where $j_{0,\\mathrm{side}} = 0$, $Q_{\\mathrm{loss}}$ is trivially $0$ and $\\mathrm{CE} = 1$.\n\n**2. Energy Efficiency ($\\mathrm{EE}$)**\n\nThe energy efficiency is the ratio of energy delivered during discharge to the energy consumed during charge, $\\mathrm{EE} = W_{\\mathrm{out}} / W_{\\mathrm{in}}$.\n\nThe energy input during charge, $W_{\\mathrm{in}}$, is the integral of the electrical power over the charging time:\n$$\nW_{\\mathrm{in}} = \\int_{0}^{t_c} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{ch}}(t) \\, dt\n$$\nUsing the given approximation for the charge terminal voltage, $V_{\\mathrm{term}}^{\\mathrm{ch}}(t) = E_{\\mathrm{main}}(t) + \\Delta V_{\\mathrm{ohm}}$, where $\\Delta V_{\\mathrm{ohm}} = \\frac{I_{\\mathrm{app}} L}{2 A \\sigma_s}$, and $E_{\\mathrm{main}}(t) = E_0 + k_\\eta t$:\n$$\nW_{\\mathrm{in}} = I_{\\mathrm{app}} \\int_{0}^{t_c} \\left(E_0 + k_\\eta t + \\Delta V_{\\mathrm{ohm}}\\right) dt\n$$\nThis integral is readily evaluated analytically:\n$$\nW_{\\mathrm{in}} = I_{\\mathrm{app}} \\left[ (E_0 + \\Delta V_{\\mathrm{ohm}})t + \\frac{1}{2} k_\\eta t^2 \\right]_0^{t_c} = I_{\\mathrm{app}} \\left( (E_0 + \\Delta V_{\\mathrm{ohm}})t_c + \\frac{1}{2} k_\\eta t_c^2 \\right)\n$$\n\nThe energy output during discharge, $W_{\\mathrm{out}}$, is calculated over the discharge duration $t_d$. This duration is determined by the amount of charge stored reversibly, such that $t_d = Q_{\\mathrm{main}} / I_{\\mathrm{app}} = (\\mathrm{CE} \\cdot Q_{\\mathrm{in}}) / I_{\\mathrm{app}} = \\mathrm{CE} \\cdot t_c$.\n$$\nW_{\\mathrm{out}} = \\int_{0}^{t_d} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{dis}}(t) \\, dt\n$$\nThe discharge terminal voltage is $V_{\\mathrm{term}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}^{\\mathrm{dis}}(t) - \\Delta V_{\\mathrm{ohm}}$, with the main potential retracing its path: $E_{\\mathrm{main}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}(t_c - t) = E_0 + k_\\eta (t_c - t)$.\n$$\nW_{\\mathrm{out}} = I_{\\mathrm{app}} \\int_{0}^{t_d} \\left( E_0 + k_\\eta (t_c - t) - \\Delta V_{\\mathrm{ohm}} \\right) dt = I_{\\mathrm{app}} \\int_{0}^{t_d} \\left( (E_0 + k_\\eta t_c - \\Delta V_{\\mathrm{ohm}}) - k_\\eta t \\right) dt\n$$\nEvaluating this integral analytically gives:\n$$\nW_{\\mathrm{out}} = I_{\\mathrm{app}} \\left[ (E_0 + k_\\eta t_c - \\Delta V_{\\mathrm{ohm}})t - \\frac{1}{2} k_\\eta t^2 \\right]_0^{t_d} = I_{\\mathrm{app}} \\left( (E_0 + k_\\eta t_c - \\Delta V_{\\mathrm{ohm}})t_d - \\frac{1}{2} k_\\eta t_d^2 \\right)\n$$\n\nFinally, the energy efficiency is computed as the ratio of these two energies:\n$$\n\\mathrm{EE} = \\frac{W_{\\mathrm{out}}}{W_{\\mathrm{in}}}\n$$\n\n**3. Computational Strategy**\n\nFor each test case, the following procedure is implemented:\n1.  Define all physical constants ($F$, $R$) and test-case specific parameters.\n2.  Numerically compute $Q_{\\mathrm{loss}}$ by evaluating the double integral of $A \\, i_{\\mathrm{side}}(x,t)$ over $x \\in [0, L]$ and $t \\in [0, t_c]$ using a suitable quadrature routine. If $j_{0,\\mathrm{side}} = 0$, $Q_{\\mathrm{loss}}$ is set to $0$ directly.\n3.  Calculate $Q_{\\mathrm{in}} = I_{\\mathrm{app}} t_c$.\n4.  Calculate $\\mathrm{CE} = 1 - Q_{\\mathrm{loss}} / Q_{\\mathrm{in}}$.\n5.  Calculate the average ohmic contribution $\\Delta V_{\\mathrm{ohm}} = \\frac{I_{\\mathrm{app}} L}{2 A \\sigma_s}$.\n6.  Calculate the input energy $W_{\\mathrm{in}}$ using its analytical formula.\n7.  Calculate the discharge time $t_d = \\mathrm{CE} \\cdot t_c$.\n8.  Calculate the output energy $W_{\\mathrm{out}}$ using its analytical formula with the computed $t_d$.\n9.  Calculate $\\mathrm{EE} = W_{\\mathrm{out}} / W_{\\mathrm{in}}$.\n10. Store the resulting $\\mathrm{CE}$ and $\\mathrm{EE}$ values, rounded to six decimal places, for final output.\n\nThis procedure is applied to each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Computes the coulombic and energy efficiencies for a porous electrode\n    based on a simplified electrochemical model.\n    \"\"\"\n    \n    # Physical Constants\n    F = 96485.33212  # Faraday constant in C/mol\n    R = 8.314462618  # Universal gas constant in J/(mol K)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: general case\n        {\n            \"A\": 0.01, \"L\": 1.0e-4, \"sigma_s\": 1000, \"a_s\": 8.0e4,\n            \"I_app\": 2.0, \"t_c\": 1800, \"E0\": 3.6, \"k_eta\": 2.0e-4,\n            \"U_side\": 4.0, \"j0_side\": 2.0e-2, \"alpha_side\": 0.5, \"T\": 298\n        },\n        # Test Case 2: no side reaction edge case\n        {\n            \"A\": 0.01, \"L\": 1.0e-4, \"sigma_s\": 1000, \"a_s\": 8.0e4,\n            \"I_app\": 2.0, \"t_c\": 1800, \"E0\": 3.6, \"k_eta\": 2.0e-4,\n            \"U_side\": 4.0, \"j0_side\": 0.0, \"alpha_side\": 0.5, \"T\": 298\n        },\n        # Test Case 3: low conductivity and closer side-reaction potential\n        {\n            \"A\": 0.01, \"L\": 1.5e-4, \"sigma_s\": 200, \"a_s\": 1.2e5,\n            \"I_app\": 3.0, \"t_c\": 1200, \"E0\": 3.5, \"k_eta\": 3.0e-4,\n            \"U_side\": 3.85, \"j0_side\": 2.0e-2, \"alpha_side\": 0.5, \"T\": 298\n        }\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Unpack parameters for clarity\n        A = params[\"A\"]\n        L = params[\"L\"]\n        sigma_s = params[\"sigma_s\"]\n        a_s = params[\"a_s\"]\n        I_app = params[\"I_app\"]\n        t_c = params[\"t_c\"]\n        E0 = params[\"E0\"]\n        k_eta = params[\"k_eta\"]\n        U_side = params[\"U_side\"]\n        j0_side = params[\"j0_side\"]\n        alpha_side = params[\"alpha_side\"]\n        T = params[\"T\"]\n        \n        # --- 1. Coulombic Efficiency (CE) Calculation ---\n        \n        Q_in = I_app * t_c\n        \n        if j0_side == 0.0:\n            Q_loss = 0.0\n        else:\n            # Define the integrand for Q_loss\n            # Integrand is A * i_side(x, t)\n            # Order of arguments for dblquad is func(y, x), here func(t, x).\n            # func's first arg is the inner integral variable, second is outer.\n            # We integrate dx dt, so inner is x, outer is t. dblquad expect (y,x) so (t,x).\n            # dblquad(func, x_min, x_max, y_min, y_max)\n            # So, func(t,x) and dblquad(..., 0, L, 0, t_c).\n            \n            beta_factor = (alpha_side * F) / (R * T)\n            \n            def integrand_q_loss(t, x):\n                eta_side = (E0 + k_eta * t - (I_app / (A * sigma_s)) * x) - U_side\n                i_side_vol = a_s * j0_side * np.exp(beta_factor * eta_side)\n                return A * i_side_vol\n\n            # Numerical integration for Q_loss\n            Q_loss, _ = dblquad(integrand_q_loss, 0, L, 0, t_c)\n\n        CE = 1 - (Q_loss / Q_in)\n        \n        # --- 2. Energy Efficiency (EE) Calculation ---\n        \n        # Average ohmic contribution\n        delta_V_ohm = (I_app * L) / (2 * A * sigma_s)\n        \n        # Input energy (analytical)\n        W_in = I_app * ((E0 + delta_V_ohm) * t_c + 0.5 * k_eta * t_c**2)\n\n        # Discharge duration\n        t_d = CE * t_c\n        \n        # Output energy (analytical)\n        if W_in > 0: # Avoid division by zero if there's no input energy\n            W_out = I_app * ((E0 + k_eta * t_c - delta_V_ohm) * t_d - 0.5 * k_eta * t_d**2)\n            EE = W_out / W_in\n        else:\n            EE = 0.0\n\n        # Append results rounded to six decimal places\n        results.append(f\"{CE:.6f}\")\n        results.append(f\"{EE:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Transitioning from cell-level analysis to pack-level control is a critical step in battery engineering. This advanced practice challenges you to design an optimal charging strategy for a multi-cell battery pack, a core function of a modern Battery Management System (BMS). By formulating the problem computationally and using numerical optimization, you will learn to schedule charging currents and cell balancing to maximize round-trip energy efficiency while respecting crucial thermal and state-of-charge constraints, reflecting a real-world automated design task .",
            "id": "3902258",
            "problem": "You are tasked with developing, specifying, and implementing a control strategy that schedules charging current and per-cell balancing bypass to maximize pack round-trip energy efficiency under realistic constraints for an automated battery design and simulation context. The pack consists of series-connected cells, and the model must incorporate coulombic and energy efficiency as well as thermal limits. Your program must compute the optimal strategy on a discretized horizon and report the resulting round-trip energy efficiency as a decimal number for each test case.\n\nFundamental base to be used:\n- Energy conservation: the input electrical energy is $E_{\\text{in}} = \\int I(t) V_{\\text{pack}}(t) \\, dt$ and resistive heat follows Joule's law $P_{\\text{Joule}}(t) = I(t)^2 R_{\\text{pack}}$.\n- State of charge (SOC) change: for each cell $j$, the stored charge increment due to charging with coulombic efficiency is $\\Delta q_j = \\eta_C \\int \\left(I(t) - b_j(t)\\right) \\, dt$, where $\\eta_C$ is the Coulombic efficiency and $b_j(t)$ is the cell $j$ bypass current.\n- Thermal first-order lumped model: for each cell $j$, the temperature dynamics are $C_{\\text{th},j} \\frac{dT_j}{dt} = Q_{\\text{gen},j} - h_j \\left(T_j - T_{\\text{amb}}\\right)$, with heat generation $Q_{\\text{gen},j}(t) \\approx I(t)^2 R_j + b_j(t) V_{0,j}$.\n- Pack voltage approximation: adopt the widely used linear approximation $V_{\\text{pack}}(t) \\approx \\sum_{j=1}^{N} V_{0,j} + I(t) \\sum_{j=1}^{N} R_j$, where $V_{0,j}$ is a constant approximation of the open-circuit voltage over the operating window and $R_j$ is the internal resistance of cell $j$.\n\nDefinition of acronyms on first appearance:\n- Round-Trip Energy (RTE) efficiency: the fraction of energy recovered on discharge relative to energy input on charge. We denote it by $\\eta_{\\text{RTE}}$ and approximate it here by the ratio of useful stored energy to input energy, assuming near-unit discharge efficiency over the window of interest.\n- State of Charge (SOC): the fraction of cell capacity utilized, denoted by $s_j \\in [0,1]$ for cell $j$.\n- Coulombic Efficiency (CE): the fraction of charge that is effectively stored during charging, denoted by $\\eta_C$.\n\nDiscretization and decision variables:\n- Consider $N$ series cells indexed by $j \\in \\{1,\\dots,N\\}$, and a discretized charging horizon with $K$ steps indexed by $k \\in \\{0,\\dots,K-1\\}$, each of duration $\\Delta t$.\n- Decision variables at each step $k$ are the pack charging current $I_k \\geq 0$ and per-cell bypass currents $b_{j,k} \\geq 0$, with the physical constraint $b_{j,k} \\leq I_k$ (a cell cannot bypass more current than the series charging current).\n- SOC update for each cell $j$ is modeled as $s_{j,k+1} = s_{j,k} + \\frac{\\eta_C \\Delta t}{Q_j}\\left(I_k - b_{j,k}\\right)$, where $Q_j$ is the capacity of cell $j$ in $\\text{A}\\cdot\\text{s}$.\n- Temperature update for each cell $j$ is $T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right)$.\n\nObjective and constraints:\n- The input energy is $E_{\\text{in}} = \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right)$.\n- The useful stored energy (available for later discharge under the constant open-circuit voltage approximation) is $E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\, \\eta_C \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right)$.\n- The Round-Trip Energy efficiency is $\\eta_{\\text{RTE}} = \\frac{E_{\\text{stored}}}{E_{\\text{in}}}$.\n- To place the problem into a mathematically tractable form, maximize $\\eta_{\\text{RTE}}$ subject to target SOC equalization constraints. Equivalently, minimize $E_{\\text{in}}$ subject to the linear equality constraints $s_{j,K} = s_{\\text{target}}$ for all $j$, enforced by the SOC update model, and thermal inequality constraints $T_{j,k} \\leq T_{\\max}$ for all $j,k$.\n\nYour program must:\n- Formulate and solve the discretized optimization described above using a numerical optimizer to obtain $\\{I_k\\}_{k=0}^{K-1}$ and $\\{b_{j,k}\\}_{j=1,k=0}^{N,K-1}$ that minimize $E_{\\text{in}}$ subject to all constraints.\n- Compute the resulting $\\eta_{\\text{RTE}}$ using the definitions above.\n- For physical units: currents in $\\text{A}$, voltages in $\\text{V}$, resistances in $\\Omega$, capacity in $\\text{A}\\cdot\\text{s}$, time in $\\text{s}$, temperatures in degrees Celsius.\n- Express each final result as a decimal number rounded to $6$ decimal digits.\n\nTest suite and parameters:\nProvide a test suite with three cases. For each case, pack size is $N=3$ cells in series. The parameters are:\n\n- Case $1$ (general feasible case):\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$, $R = [0.01, 0.01, 0.01]$ $\\Omega$, $V_0 = [3.70, 3.71, 3.69]$ $\\text{V}$.\n  - $s_0 = [0.30, 0.32, 0.28]$, $s_{\\text{target}} = 0.80$, $\\eta_C = 0.995$.\n  - $T_0 = [25.0, 25.0, 25.0]$ °C, $T_{\\text{amb}} = 25.0$ °C, $T_{\\max} = 40.0$ °C.\n  - $C_{\\text{th}} = [12000, 12000, 12000]$ J/°C, $h = [12, 12, 12]$ W/°C.\n  - Horizon: $K=6$, $\\Delta t = 60$ $\\text{s}$, current bound $0 \\leq I_k \\leq 20$ $\\text{A}$.\n\n- Case $2$ (boundary temperature case):\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$, $R = [0.02, 0.02, 0.02]$ $\\Omega$, $V_0 = [3.65, 3.66, 3.64]$ $\\text{V}$.\n  - $s_0 = [0.40, 0.39, 0.41]$, $s_{\\text{target}} = 0.85$, $\\eta_C = 0.992$.\n  - $T_0 = [35.0, 35.0, 35.0]$ °C, $T_{\\text{amb}} = 35.0$ °C, $T_{\\max} = 40.0$ °C.\n  - $C_{\\text{th}} = [9000, 9000, 9000]$ J/°C, $h = [8, 8, 8]$ W/°C.\n  - Horizon: $K=5$, $\\Delta t = 60$ $\\text{s}$, current bound $0 \\leq I_k \\leq 22$ $\\text{A}$.\n\n- Case $3$ (low Coulombic efficiency case):\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$, $R = [0.015, 0.015, 0.015]$ $\\Omega$, $V_0 = [3.68, 3.69, 3.67]$ $\\text{V}$.\n  - $s_0 = [0.20, 0.22, 0.18]$, $s_{\\text{target}} = 0.70$, $\\eta_C = 0.970$.\n  - $T_0 = [20.0, 20.0, 20.0]$ °C, $T_{\\text{amb}} = 20.0$ °C, $T_{\\max} = 50.0$ °C.\n  - $C_{\\text{th}} = [15000, 15000, 15000]$ J/°C, $h = [15, 15, 15]$ W/°C.\n  - Horizon: $K=8$, $\\Delta t = 60$ $\\text{s}$, current bound $0 \\leq I_k \\leq 15$ $\\text{A}$.\n\nAnswer specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $[r_1, r_2, r_3]$, where $r_i$ is the optimized $\\eta_{\\text{RTE}}$ for case $i$, expressed as a decimal and rounded to $6$ decimal digits.",
            "solution": "The user has provided a scientifically sound and well-posed problem. The problem is validated as per the required criteria and a complete solution is provided below.\n\nThe task is to devise a charging strategy for a series-connected battery pack that maximizes the Round-Trip Energy (RTE) efficiency, denoted as $\\eta_{\\text{RTE}}$. This is achieved by controlling the pack charging current $I_k$ and the per-cell bypass currents $b_{j,k}$ over a discrete time horizon of $K$ steps. The strategy must adhere to physical constraints, including final State of Charge (SOC) targets and maximum cell temperatures.\n\nFirst, we formalize this as a mathematical optimization problem. The problem statement specifies that maximizing $\\eta_{\\text{RTE}} = E_{\\text{stored}}/E_{\\text{in}}$ is equivalent to minimizing the input energy $E_{\\text{in}}$ because the stored energy, $E_{\\text{stored}}$, is constant for any feasible solution. This holds because the final SOC for each cell is a fixed target, $s_{j,K} = s_{\\text{target}}$. The stored energy is given by:\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_C \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right) $$\n\nFrom the SOC update equation, $s_{j,K} = s_{j,0} + \\frac{\\eta_C \\Delta t}{Q_j} \\sum_{k=0}^{K-1} (I_k - b_{j,k})$, we can substitute the term for the total charge transferred:\n\n$$ \\sum_{k=0}^{K-1} \\Delta t (I_k - b_{j,k}) = \\frac{Q_j (s_{j,K} - s_{j,0})}{\\eta_C} $$\n\nSubstituting this into the expression for $E_{\\text{stored}}$ gives:\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_C \\left( \\frac{Q_j (s_{\\text{target}} - s_{j,0})}{\\eta_C} \\right) = \\sum_{j=1}^{N} V_{0,j} Q_j (s_{\\text{target}} - s_{j,0}) $$\n\nSince $V_{0,j}$, $Q_j$, $s_{\\text{target}}$, and $s_{j,0}$ are all fixed parameters for a given case, $E_{\\text{stored}}$ is a constant. Therefore, maximizing $\\eta_{\\text{RTE}}$ is indeed equivalent to minimizing the input energy $E_{\\text{in}}$.\n\nThe optimization problem can thus be stated as:\n\n**1. Decision Variables**\nThe variables to be optimized are the charging currents $I_k$ for each time step $k$ and the bypass currents $b_{j,k}$ for each cell $j$ at each time step $k$. We arrange these into a single vector $\\mathbf{x}$ of size $K(N+1)$:\n$$ \\mathbf{x} = [I_0, \\dots, I_{K-1}, b_{1,0}, \\dots, b_{1,K-1}, \\dots, b_{N,0}, \\dots, b_{N,K-1}] $$\n\n**2. Objective Function**\nThe objective is to minimize the total input energy $E_{\\text{in}}$, which is a function of the decision variables. The discretized form of $E_{\\text{in}}$ is:\n$$ \\min_{\\mathbf{x}} E_{\\text{in}}(\\mathbf{x}) = \\min_{I_k} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right) $$\nThis is a quadratic function of the currents $I_k$.\n\n**3. Constraints**\nThe optimization is subject to several constraints derived from the physical model of the battery pack.\n\n- **Bounds on Variables**: The currents must be non-negative, and the charging current is limited by a maximum value $I_{\\max}$. The bypass current for a cell cannot exceed the pack current.\n    - $0 \\le I_k \\le I_{\\max}$ for $k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\ge 0$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\le I_k$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n\n- **SOC Equality Constraints**: At the end of the horizon ($k=K$), the SOC of each cell $j$ must equal the target SOC, $s_{\\text{target}}$.\n    $$ s_{j,0} + \\sum_{k=0}^{K-1} \\frac{\\eta_C \\Delta t}{Q_j} (I_k - b_{j,k}) = s_{\\text{target}} \\quad \\text{for } j \\in \\{1, \\dots, N\\} $$\n    These $N$ constraints are linear in the decision variables $I_k$ and $b_{j,k}$.\n\n- **Thermal Inequality Constraints**: The temperature of each cell $j$ must not exceed $T_{\\max}$ at any time step $k \\in \\{1, \\dots, K\\}$. The temperature $T_{j,k}$ is determined by the discrete-time thermal model:\n    $$ T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right) $$\n    This recurrence relation means that $T_{j,k}$ is a non-linear function of the decision variables $\\{I_m, b_{j,m}\\}$ for $m  k$. The $N \\times K$ constraints are therefore:\n    $$ T_{j,k}(\\mathbf{x}) \\le T_{\\max} \\quad \\text{for } j \\in \\{1, \\dots, N\\}, k \\in \\{1, \\dots, K\\} $$\n\n**Numerical Solution Strategy**\nThis problem is a Non-Linear Programming (NLP) problem because the thermal constraints are non-linear functions of the decision variables. We will use the `minimize` function from the `scipy.optimize` library with the Sequential Least Squares Programming (`SLSQP`) algorithm, which is well-suited for such problems.\n\nThe implementation involves:\n1.  Defining Python functions that represent the objective function and each set of constraints. These functions take the decision variable vector $\\mathbf{x}$ as input.\n2.  The temperature at each time step is calculated iteratively within the constraint evaluation function.\n3.  The bounds and constraints are passed to the `minimize` function in the format it requires (a list of dictionaries for constraints).\n4.  A crucial step for successful convergence of numerical optimization is providing a good initial guess, $\\mathbf{x}_0$. We construct a guess based on the cell that requires the most charging. We calculate the average constant current needed for this cell (assuming no bypass) and then determine the necessary bypass currents for other cells to meet their targets. This provides a physically-motivated starting point close to the feasible region.\n5.  After the optimizer finds the optimal solution vector $\\mathbf{x}^*$, the minimum input energy $E_{\\text{in}}^*$ is the value of the objective function at this point.\n6.  The final Round-Trip Energy efficiency $\\eta_{\\text{RTE}}$ is computed as $\\eta_{\\text{RTE}} = E_{\\text{stored}} / E_{\\text{in}}^*$, where $E_{\\text{stored}}$ is the pre-calculated constant value. This result is then rounded to the required precision.\n\nThis structured approach translates the complex, multi-physics battery charging problem into a solvable numerical optimization task, yielding the optimal control strategy and the corresponding maximum achievable efficiency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the optimization for each.\n    \"\"\"\n    # Case 1: General feasible case\n    case1 = {\n        'N': 3, 'K': 6, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.01, 0.01, 0.01]),\n        'V0': np.array([3.70, 3.71, 3.69]),\n        's0': np.array([0.30, 0.32, 0.28]),\n        's_target': 0.80,\n        'eta_C': 0.995,\n        'T0': np.array([25.0, 25.0, 25.0]),\n        'Tamb': 25.0,\n        'Tmax': 40.0,\n        'C_th': np.array([12000.0, 12000.0, 12000.0]),\n        'h': np.array([12.0, 12.0, 12.0]),\n        'I_max': 20.0\n    }\n\n    # Case 2: Boundary temperature case\n    case2 = {\n        'N': 3, 'K': 5, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.02, 0.02, 0.02]),\n        'V0': np.array([3.65, 3.66, 3.64]),\n        's0': np.array([0.40, 0.39, 0.41]),\n        's_target': 0.85,\n        'eta_C': 0.992,\n        'T0': np.array([35.0, 35.0, 35.0]),\n        'Tamb': 35.0,\n        'Tmax': 40.0,\n        'C_th': np.array([9000.0, 9000.0, 9000.0]),\n        'h': np.array([8.0, 8.0, 8.0]),\n        'I_max': 22.0\n    }\n\n    # Case 3: Low Coulombic efficiency case\n    case3 = {\n        'N': 3, 'K': 8, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.015, 0.015, 0.015]),\n        'V0': np.array([3.68, 3.69, 3.67]),\n        's0': np.array([0.20, 0.22, 0.18]),\n        's_target': 0.70,\n        'eta_C': 0.970,\n        'T0': np.array([20.0, 20.0, 20.0]),\n        'Tamb': 20.0,\n        'Tmax': 50.0,\n        'C_th': np.array([15000.0, 15000.0, 15000.0]),\n        'h': np.array([15.0, 15.0, 15.0]),\n        'I_max': 15.0\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for params in test_cases:\n        result_rte = run_optimization_case(params)\n        results.append(f\"{result_rte:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_optimization_case(params):\n    \"\"\"\n    Sets up and solves the optimization problem for a single test case.\n    \"\"\"\n    N, K, dt = params['N'], params['K'], params['dt']\n    Q, R, V0 = params['Q'], params['R'], params['V0']\n    s0, s_target, eta_C = params['s0'], params['s_target'], params['eta_C']\n    T0, Tamb, Tmax = params['T0'], params['Tamb'], params['Tmax']\n    C_th, h = params['C_th'], params['h']\n    I_max = params['I_max']\n\n    V0_sum = np.sum(V0)\n    R_sum = np.sum(R)\n    \n    num_vars = K * (N + 1)\n\n    # Objective function: Minimize Ein\n    def objective_function(x):\n        I_vars = x[:K]\n        return dt * np.sum(I_vars * V0_sum + I_vars**2 * R_sum)\n\n    # Helper to calculate temperatures\n    def calculate_temperatures(x):\n        I_vars = x[:K]\n        b_vars = x[K:].reshape((N, K))\n        T = np.zeros((N, K + 1))\n        T[:, 0] = T0\n        for k in range(K):\n            Q_gen_k = I_vars[k]**2 * R + b_vars[:, k] * V0\n            T_dot_k = (Q_gen_k - h * (T[:, k] - Tamb)) / C_th\n            T[:, k + 1] = T[:, k] + T_dot_k * dt\n        return T\n\n    # Constraints\n    constraints = []\n\n    # 1. SOC equality constraints: s_j,K = s_target\n    soc_target_charge_integral = Q * (s_target - s0) / (eta_C * dt)\n    for j in range(N):\n        def soc_constraint(x, j=j):\n            I_vars = x[:K]\n            b_j_vars = x[K + j * K : K + (j + 1) * K]\n            return np.sum(I_vars - b_j_vars) - soc_target_charge_integral[j]\n        constraints.append({'type': 'eq', 'fun': soc_constraint})\n\n    # 2. Bypass current inequality: b_j,k = I_k  (or I_k - b_j,k >= 0)\n    for j in range(N):\n        for k in range(K):\n            def bypass_constraint(x, j=j, k=k):\n                return x[k] - x[K + j * K + k]\n            constraints.append({'type': 'ineq', 'fun': bypass_constraint})\n            \n    # 3. Temperature inequality: T_j,k = Tmax (or Tmax - T_j,k >= 0)\n    def temp_constraints(x):\n        temps = calculate_temperatures(x)\n        # Constraints on T_j,k for k=1...K\n        return (Tmax - temps[:, 1:]).flatten()\n    constraints.append({'type': 'ineq', 'fun': temp_constraints})\n\n    # Bounds for decision variables\n    bounds_I = [(0, I_max)] * K\n    bounds_b = [(0, None)] * (N * K) # b_jk >= 0, b_jk = I_k is a separate constraint\n    bounds = bounds_I + bounds_b\n\n    # Initial guess (x0)\n    delta_s = s_target - s0\n    j_star = np.argmax(delta_s)\n    \n    required_charge_integral_star = Q[j_star] * delta_s[j_star] / (eta_C * dt)\n    I_const = np.clip(required_charge_integral_star / K, 0, I_max)\n    \n    x0_I = np.full(K, I_const)\n    x0_b = np.zeros((N, K))\n\n    total_I_integral = K * I_const\n    for j in range(N):\n        if j != j_star:\n            required_charge_integral_j = Q[j] * delta_s[j] / (eta_C * dt)\n            total_bypass_j = total_I_integral - required_charge_integral_j\n            if total_bypass_j > 0:\n                x0_b[j, :] = total_bypass_j / K\n    \n    x0 = np.concatenate([x0_I, x0_b.flatten()])\n    \n    # Run optimization\n    result = minimize(objective_function, x0, method='SLSQP', bounds=bounds, constraints=constraints)\n\n    if not result.success:\n        # Fallback to simpler guess if smart guess was problematic\n        x0_simple = np.full(num_vars, 1e-3)\n        result = minimize(objective_function, x0_simple, method='SLSQP', bounds=bounds, constraints=constraints)\n        if not result.success: # Raise if still fails\n            raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n\n    # Calculate final RTE_efficiency\n    E_in_opt = result.fun\n    E_stored = np.sum(V0 * Q * (s_target - s0))\n    eta_RTE = E_stored / E_in_opt\n    \n    return eta_RTE\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}