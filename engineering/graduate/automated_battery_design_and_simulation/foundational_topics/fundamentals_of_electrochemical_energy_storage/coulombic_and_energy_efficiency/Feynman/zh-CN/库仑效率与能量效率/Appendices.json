{
    "hands_on_practices": [
        {
            "introduction": "在电池测试和运行中，我们获得的是离散的、非均匀采样的时间序列数据。本练习将指导您应用梯形法则等数值积分方法，从这些离散数据点中重建电荷通量 $Q = \\int I\\,dt$ 和能量通量 $E = \\int VI\\,dt$。这项实践旨在培养从原始实验数据中精确计算关键性能指标的基本技能，并让你深入理解该过程中涉及的数值误差，这是任何数据驱动电池分析的第一步 。",
            "id": "3902321",
            "problem": "考虑一个电池循环场景，其中可测量为电流 $I(t)$（单位：安培）和端电压 $V(t)$（单位：伏特），二者均为时间 $t$（单位：秒）的函数。在时间范围 $[0,T]$ 内的电荷吞吐量 $Q$ 定义为积分 $Q=\\int_0^T I(t)\\,dt$（单位：库仑），能量吞吐量 $E$ 定义为 $E=\\int_0^T V(t)I(t)\\,dt$（单位：焦耳）。在自动化电池设计和仿真中，通常只有具有时变采样间隔的离散采样数据。您的任务是通过一种基于基本原理的数值方法，从非均匀样本中重建 $Q$ 和 $E$，并基于基本原理推导误差界。所有物理量均使用国际单位制 (SI)；$Q$ 以库仑表示，$E$ 以焦耳表示，所有输出均表示为十进制数。\n\n从电荷和能量吞吐量的核心定义以及标准数值分析基础出发，完成以下任务：\n\n1. 推导一种方法，从离散采样值 $\\{t_k\\}_{k=0}^N$、$I_k=I(t_k)$ 和 $V_k=V(t_k)$ 重建积分 $Q=\\int_0^T I(t)\\,dt$ 和 $E=\\int_0^T V(t)I(t)\\,dt$。其中时间戳满足 $0=t_0  t_1  \\dots  t_N = T$。\n2. 对于每种积分，推导其数值近似的理论误差界。\n3. 实现一个程序，对于一组给定的非均匀时间戳和相应的 $I(t_k)$ 和 $V(t_k)$ 值，计算 (1) 重建的电荷 $\\widehat{Q}$，(2) 重建的能量 $\\widehat{E}$，(3) 电荷的绝对误差 $|\\widehat{Q} - Q_{\\text{exact}}|$，(4) 电荷的误差界 $B_Q$，(5) 能量的绝对误差 $|\\widehat{E} - E_{\\text{exact}}|$，(6) 能量的误差界 $B_E$，以及 (7, 8) 两个布尔值，验证误差是否分别在界内。\n4. 使用以下参数和函数形式测试您的程序，生成单行输出，其中包含一个包含所有四个测试用例结果的嵌套列表。$I(t) = I_0 + I_1 \\sin(at)$ 和 $V(t) = V_0 + V_1 \\cos(bt)$。\n\n测试套件：\n- 案例 1：$T=1000.0, N=64, \\alpha=0.6, I_0=2.0, I_1=1.5, a=0.02, V_0=3.7, V_1=0.2, b=0.015$\n- 案例 2：$T=1000.0, N=16, \\alpha=0.9, I_0=2.0, I_1=0.8, a=0.05, V_0=3.8, V_1=0.15, b=0.03$\n- 案例 3：$T=500.0, N=50, \\alpha=0.5, I_0=2.5, I_1=0.0, a=0.1, V_0=4.0, V_1=0.0, b=0.2$\n- 案例 4：$T=200.0, N=64, \\alpha=0.7, I_1=1.8, I_1=1.2, a=0.2, V_0=3.6, V_1=0.25, b=0.18$",
            "solution": "问题陈述被评估为有效，因为它在科学上基于物理学和数值分析的基本原理，问题设定良好，目标明确，数据充分，且没有歧义或矛盾。\n\n### 分析框架\n\n问题的核心在于根据离散数据近似定积分，并对相关误差进行界定。给定一个在非均匀间隔时间点 $\\{t_k\\}_{k=0}^N$（满足 $0=t_0  t_1  \\dots  t_N = T$）上采样的函数 $f(t)$，我们的目标是计算积分 $J = \\int_0^T f(t) \\, dt$ 的近似值。\n\n#### 1. 通过复合梯形法则进行数值重建\n\n在整个时间范围 $[0, T]$ 上的积分可以表示为在各个子区间 $[t_k, t_{k+1}]$ 上的积分之和：\n$$J = \\int_0^T f(t) \\, dt = \\sum_{k=0}^{N-1} \\int_{t_k}^{t_{k+1}} f(t) \\, dt$$\n梯形法则通过计算一个梯形的面积来近似单个子区间 $[t_k, t_{k+1}]$ 上的积分，该梯形的顶点为 $(t_k, 0)$、$(t_{k+1}, 0)$、$(t_k, f(t_k))$ 和 $(t_{k+1}, f(t_{k+1}))$。设 $h_k = t_{k+1} - t_k$ 为子区间的长度，$f_k = f(t_k)$ 为采样函数值，则该面积由下式给出：\n$$\\int_{t_k}^{t_{k+1}} f(t) \\, dt \\approx \\frac{h_k}{2} (f_k + f_{k+1})$$\n复合梯形法则将此近似应用于每个子区间并将结果求和，得到总估计积分 $\\widehat{J}$：\n$$\\widehat{J} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (f_k + f_{k+1})$$\n该公式可直接应用于重建电荷 $\\widehat{Q}$ 和能量 $\\widehat{E}$ 的计算。\n\n对于电荷，$f(t) = I(t)$，因此 $f_k = I_k = I(t_k)$。\n$$\\widehat{Q} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (I_k + I_{k+1})$$\n\n对于能量，被积函数是瞬时功率 $P(t) = V(t)I(t)$，因此 $f_k = P_k = V_k I_k$。\n$$\\widehat{E} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (P_k + P_{k+1}) = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (V_k I_k + V_{k+1} I_{k+1})$$\n\n#### 2. 误差界的推导\n\n根据标准数值分析理论，对于一个二次连续可微函数 $f(t)$，梯形法则在宽度为 $h = b-a$ 的单个区间 $[a, b]$ 上的误差由下式给出：\n$$E_{trap} = \\int_a^b f(t) \\, dt - \\frac{h}{2}(f(a) + f(b)) = -\\frac{h^3}{12} f''(\\xi)$$\n其中某个 $\\xi \\in (a, b)$。因此，绝对误差的界为 $|E_{trap}| \\le \\frac{h^3}{12} \\max_{t \\in [a, b]} |f''(t)|$。\n\n对于非均匀网格 $\\{t_k\\}$ 上的复合法则，总绝对误差受每个子区间上绝对误差之和的界定：\n$$|\\text{Total Error}| \\le \\sum_{k=0}^{N-1} \\frac{h_k^3}{12} |f''(\\xi_k)| \\quad \\text{for } \\xi_k \\in (t_k, t_{k+1})$$\n为获得一个可计算的上界 $B_f$，我们使用二阶导数幅值的全局最大值 $M_2 = \\max_{t \\in [0,T]} |f''(t)|$：\n$$B_f = \\frac{M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\n这为数值积分方案提供了一个实用的误差界。\n\n**电荷的误差界 ($B_Q$):**\n被积函数为 $I(t) = I_0 + I_1 \\sin(at)$。其导数为：\n$I'(t) = a I_1 \\cos(at)$\n$I''(t) = -a^2 I_1 \\sin(at)$\n二阶导数的最大幅值为 $M_{2,I} = \\max_{t \\in [0,T]} |-a^2 I_1 \\sin(at)| = a^2 |I_1|$。\n电荷的误差界为：\n$$B_Q = \\frac{a^2 |I_1|}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n**能量的误差界 ($B_E$):**\n被积函数为 $P(t) = V(t)I(t)$。我们使用乘法法则求其二阶导数：\n$P'(t) = V'(t)I(t) + V(t)I'(t)$\n$P''(t) = V''(t)I(t) + 2V'(t)I'(t) + V(t)I''(t)$\n使用三角不等式，我们界定其幅值：\n$|P''(t)| \\le |V''(t)||I(t)| + 2|V'(t)||I'(t)| + |V(t)||I''(t)|$\n我们在 $[0,T]$ 上为 $I(t)$、$V(t)$ 及其前两阶导数的幅值建立上界：\n$I(t) = I_0 + I_1 \\sin(at) \\Rightarrow |I(t)| \\le |I_0| + |I_1| \\equiv M_0$\n$|I'(t)| \\le a|I_1| \\equiv M_1$\n$|I''(t)| \\le a^2|I_1| \\equiv M_2$\n$V(t) = V_0 + V_1 \\cos(bt) \\Rightarrow |V(t)| \\le |V_0| + |V_1| \\equiv N_0$\n$|V'(t)| = |-bV_1\\sin(bt)| \\le b|V_1| \\equiv N_1$\n$|V''(t)| = |-b^2V_1\\cos(bt)| \\le b^2|V_1| \\equiv N_2$\n$|P''(t)|$ 的全局界则为 $M_{2,P} = N_2 M_0 + 2 N_1 M_1 + N_0 M_2$。\n能量的误差界为：\n$$B_E = \\frac{M_{2,P}}{12} \\sum_{k=0}^{N-1} h_k^3 = \\frac{N_2 M_0 + 2 N_1 M_1 + N_0 M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n#### 3. 精确解析积分\n\n为了验证，我们以符号方式计算精确积分。\n**精确电荷 ($Q$):**\n$$Q = \\int_0^T (I_0 + I_1 \\sin(at)) \\, dt = \\left[I_0 t - \\frac{I_1}{a} \\cos(at)\\right]_0^T = I_0 T - \\frac{I_1}{a}(\\cos(aT) - 1)$$\n**精确能量 ($E$):**\n$$E = \\int_0^T (V_0 + V_1 \\cos(bt))(I_0 + I_1 \\sin(at)) \\, dt$$\n展开乘积并逐项积分得到：\n$E = \\int_0^T \\left(I_0 V_0 + V_0 I_1 \\sin(at) + I_0 V_1 \\cos(bt) + I_1 V_1 \\sin(at)\\cos(bt)\\right) \\, dt$\n使用恒等式 $\\sin(A)\\cos(B) = \\frac{1}{2}(\\sin(A+B) + \\sin(A-B))$ 并假设 $a \\neq b$：\n$$E = I_0 V_0 T - \\frac{V_0 I_1}{a}(\\cos(aT) - 1) + \\frac{I_0 V_1}{b}\\sin(bT) + \\frac{I_1 V_1}{2}\\left[\\frac{1-\\cos((a+b)T)}{a+b} + \\frac{1-\\cos((a-b)T)}{a-b}\\right]$$\n\n#### 4. 非均匀采样网格\n\n时间步长 $\\{h_k\\}$ 通过权重 $w_k = 1 + \\alpha \\cos^2(\\frac{\\pi k}{N})$（对于 $k \\in \\{0, \\dots, N-1\\}$）构造。权重的和可以解析计算：\n$\\sum_{j=0}^{N-1} w_j = \\sum_{j=0}^{N-1} \\left(1 + \\alpha \\frac{1+\\cos(2\\pi j/N)}{2}\\right) = N + \\frac{\\alpha}{2}\\left(N + \\sum_{j=0}^{N-1}\\cos(2\\pi j/N)\\right)$。\n由于 $N$ 次单位根之和为零，其实部之和也为零，即 $\\sum_{j=0}^{N-1}\\cos(2\\pi j/N) = 0$。\n因此，$\\sum_{j=0}^{N-1} w_j = N(1 + \\alpha/2)$。\n时间步长为 $h_k = \\frac{T w_k}{\\sum w_j} = \\frac{T(1 + \\alpha \\cos^2(\\pi k/N))}{N(1 + \\alpha/2)}$，时间样本为 $t_0=0$，$t_{k+1}=t_k+h_k$。这确保了 $\\sum h_k = t_N = T$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes reconstructed charge and energy from simulated nonuniform battery data,\n    along with their exact values, absolute errors, and theoretical error bounds.\n    \"\"\"\n    test_cases = [\n        # (T, N, alpha, I0, I1, a, V0, V1, b)\n        (1000.0, 64, 0.6, 2.0, 1.5, 0.02, 3.7, 0.2, 0.015),\n        (1000.0, 16, 0.9, 2.0, 0.8, 0.05, 3.8, 0.15, 0.03),\n        (500.0, 50, 0.5, 2.5, 0.0, 0.10, 4.0, 0.0, 0.20),\n        (200.0, 64, 0.7, 1.8, 1.2, 0.20, 3.6, 0.25, 0.18),\n    ]\n\n    all_results = []\n\n    for T, N, alpha, I0, I1, a, V0, V1, b in test_cases:\n        # Part 1: Generate the non-uniform time grid\n        k_indices = np.arange(N)\n        # Using the analytic simplification for the sum of weights\n        sum_of_weights = N * (1 + alpha / 2.0)\n        weights_k = 1 + alpha * np.cos(np.pi * k_indices / N)**2\n        h_steps = (T * weights_k) / sum_of_weights\n        time_stamps = np.concatenate(([0.0], np.cumsum(h_steps)))\n\n        # Part 2: Generate sampled signal data\n        I_samples = I0 + I1 * np.sin(a * time_stamps)\n        V_samples = V0 + V1 * np.cos(b * time_stamps)\n        P_samples = I_samples * V_samples\n\n        # Part 3: Numerical Reconstruction (Composite Trapezoidal Rule)\n        Q_hat = 0.5 * np.sum(h_steps * (I_samples[:-1] + I_samples[1:]))\n        E_hat = 0.5 * np.sum(h_steps * (P_samples[:-1] + P_samples[1:]))\n\n        # Part 4: Analytical Integration (Exact Values)\n        Q_exact = I0 * T\n        if I1 != 0.0 and a != 0.0:\n            Q_exact -= (I1 / a) * (np.cos(a * T) - 1.0)\n\n        E_exact = I0 * V0 * T\n        if V0 != 0.0 and I1 != 0.0 and a != 0.0:\n            E_exact -= (V0 * I1 / a) * (np.cos(a * T) - 1.0)\n        if I0 != 0.0 and V1 != 0.0 and b != 0.0:\n            E_exact += (I0 * V1 / b) * np.sin(b * T)\n        if I1 != 0.0 and V1 != 0.0 and a != b and a != 0.0 and b != 0.0:\n            apb = a + b\n            amb = a - b\n            term4 = (I1 * V1 / 2.0) * ((1.0 - np.cos(apb * T)) / apb + (1.0 - np.cos(amb * T)) / amb)\n            E_exact += term4\n        \n        # Part 5: Compute Absolute Errors\n        error_Q = np.abs(Q_hat - Q_exact)\n        error_E = np.abs(E_hat - E_exact)\n\n        # Part 6: Compute Error Bounds\n        sum_h3 = np.sum(h_steps**3)\n        \n        # Bound for Charge (B_Q)\n        M2_I = a**2 * np.abs(I1)\n        B_Q = (M2_I / 12.0) * sum_h3\n        \n        # Bound for Energy (B_E)\n        M0_I = np.abs(I0) + np.abs(I1)\n        M1_I = np.abs(a) * np.abs(I1)\n        \n        N0_V = np.abs(V0) + np.abs(V1)\n        N1_V = np.abs(b) * np.abs(V1)\n        N2_V = b**2 * np.abs(V1)\n        \n        M2_P = N2_V * M0_I + 2.0 * N1_V * M1_I + N0_V * M2_I\n        B_E = (M2_P / 12.0) * sum_h3\n\n        # Part 7: Verify if actual error is within the bound\n        error_Q_within_bound = error_Q = B_Q\n        error_E_within_bound = error_E = B_E\n\n        # Part 8: Collate results for the current test case\n        all_results.append([\n            Q_hat, E_hat, error_Q, B_Q, error_E, B_E,\n            error_Q_within_bound, error_E_within_bound\n        ])\n\n    # Format and print the final output as a single line string\n    case_strings = []\n    for case_result in all_results:\n        value_strings = [str(v) for v in case_result]\n        case_strings.append(f\"[{','.join(value_strings)}]\")\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "库仑效率损失通常源于寄生副反应，而这些反应在电极内部的发生并非均匀。本练习将引导您使用Tafel方程来模拟副反应速率，该速率取决于局部电化学电势，而电势在电极厚度方向上存在分布。通过在空间（电极厚度）和时间两个维度上对寄生副反应电流进行积分，您将更深入地理解电极内部电势梯度如何驱动依赖于空间位置的衰退，并最终影响整体库仑效率 。",
            "id": "3902291",
            "problem": "考虑一个厚度为 $L$、几何面积为 $A$ 的一维多孔电极，在时间 $t \\in [0,t_c]$ 内进行恒流充电。施加的电流为 $I_{\\mathrm{app}}$（充电时为正），固相电势沿厚度坐标 $x \\in [0,L]$ 的分布采用固相欧姆定律和均匀电流密度进行建模。假设固相电导率为 $\\sigma_s$，主可逆反应电势因荷电状态的变化而随一个给定的函数 $E_{\\mathrm{main}}(t)$ 演化。设局部固相电势可由以下线性分布近似：\n$$\n\\phi_s(x,t) = E_{\\mathrm{main}}(t) - \\frac{I_{\\mathrm{app}}}{A} \\frac{x}{\\sigma_s},\n$$\n该电势以电解质电势为参考，电解质电势被设为零参考。发生了一个寄生副反应（例如，固体电解质界面膜（SEI）的形成），其界面电流密度 $j_{\\mathrm{side}}(x,t)$ 由阳极塔菲尔关系描述：\n$$\nj_{\\mathrm{side}}(x,t) = j_{0,\\mathrm{side}} \\exp\\left(\\frac{\\alpha_{\\mathrm{side}} F}{R T} \\, \\eta_{\\mathrm{side}}(x,t)\\right),\n$$\n其中 $j_{0,\\mathrm{side}}$ 是副反应交换电流密度，$\\alpha_{\\mathrm{side}}$ 是电荷转移系数，$F$ 是法拉第常数，$R$ 是普适气体常数，$T$ 是绝对温度，副反应的过电势为：\n$$\n\\eta_{\\mathrm{side}}(x,t) = \\phi_s(x,t) - U_{\\mathrm{side}},\n$$\n其中 $U_{\\mathrm{side}}$ 是副反应的平衡电势。多孔电极的比表面积为 $a_s$（单位体积的界面面积），因此体积副反应电流密度为 $i_{\\mathrm{side}}(x,t) = a_s j_{\\mathrm{side}}(x,t)$。\n\n根据电荷守恒，充电过程中的总输入电荷为 $Q_{\\mathrm{in}} = I_{\\mathrm{app}} t_c$，因副反应损失的电荷为：\n$$\nQ_{\\mathrm{loss}} = \\int_{0}^{t_c} \\int_{0}^{L} i_{\\mathrm{side}}(x,t) \\, A \\, dx \\, dt.\n$$\n定义可逆存储的电荷为 $Q_{\\mathrm{main}} = Q_{\\mathrm{in}} - Q_{\\mathrm{loss}}$，库仑效率定义为以下比值：\n$$\n\\mathrm{CE} = \\frac{Q_{\\mathrm{main}}}{Q_{\\mathrm{in}}}.\n$$\n对于能量效率，将充电期间的端电压近似为：\n$$\nV_{\\mathrm{term}}^{\\mathrm{ch}}(t) = E_{\\mathrm{main}}(t) + \\Delta V_{\\mathrm{ohm}},\n$$\n其中，由线性电势分布引起的平均欧姆贡献为 $\\Delta V_{\\mathrm{ohm}} = \\frac{I_{\\mathrm{app}}}{A} \\frac{L}{2 \\sigma_s}$。输入的电能为：\n$$\nW_{\\mathrm{in}} = \\int_{0}^{t_c} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{ch}}(t) \\, dt.\n$$\n假设放电以相同大小的电流 $I_{\\mathrm{app}}$ 进行，持续时间为 $t_d = \\frac{Q_{\\mathrm{main}}}{I_{\\mathrm{app}}}$，并且主反应电势沿荷电状态路径反向追溯，即：\n$$\nE_{\\mathrm{main}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}(t_c - t),\n$$\n端电压为：\n$$\nV_{\\mathrm{term}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}^{\\mathrm{dis}}(t) - \\Delta V_{\\mathrm{ohm}}.\n$$\n放电时输出的电能为：\n$$\nW_{\\mathrm{out}} = \\int_{0}^{t_d} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{dis}}(t) \\, dt,\n$$\n能量效率为 $\\mathrm{EE} = \\frac{W_{\\mathrm{out}}}{W_{\\mathrm{in}}}$。所有能量 $W_{\\mathrm{in}}$ 和 $W_{\\mathrm{out}}$ 的单位均为焦耳。\n\n你的任务是实现一个程序，对于每组参数，通过在空间和时间上对上述积分进行数值计算，来计算库仑效率 $\\mathrm{CE}$ 和能量效率 $\\mathrm{EE}$。使用具有足够分辨率的数值积分方法，以捕捉副反应动力学中的指数依赖性。将 $\\mathrm{CE}$ 和 $\\mathrm{EE}$ 均表示为保留六位小数的小数（不加百分号）。必须按规定使用端电压的近似和假设的放电策略。\n\n使用以下参数集测试套件。在每种情况下，函数 $E_{\\mathrm{main}}(t)$ 被规定为 $E_{\\mathrm{main}}(t) = E_0 + k_\\eta t$，其中 $E_0$ 和 $k_\\eta$ 已给出：\n\n- 测试用例 1（一般情况）：\n  - $A = 0.01 \\ \\mathrm{m}^2$\n  - $L = 1.0 \\times 10^{-4} \\ \\mathrm{m}$\n  - $\\sigma_s = 1000 \\ \\mathrm{S/m}$\n  - $a_s = 8.0 \\times 10^{4} \\ \\mathrm{m}^2/\\mathrm{m}^3$\n  - $I_{\\mathrm{app}} = 2.0 \\ \\mathrm{A}$\n  - $t_c = 1800 \\ \\mathrm{s}$\n  - $E_0 = 3.6 \\ \\mathrm{V}$\n  - $k_\\eta = 2.0 \\times 10^{-4} \\ \\mathrm{V/s}$\n  - $U_{\\mathrm{side}} = 4.0 \\ \\mathrm{V}$\n  - $j_{0,\\mathrm{side}} = 2.0 \\times 10^{-2} \\ \\mathrm{A/m}^2$\n  - $\\alpha_{\\mathrm{side}} = 0.5$\n  - $T = 298 \\ \\mathrm{K}$\n\n- 测试用例 2（无副反应的边界情况）：\n  - 与测试用例 1 相同，除了 $j_{0,\\mathrm{side}} = 0.0 \\ \\mathrm{A/m}^2$\n\n- 测试用例 3（低电导率和更接近的副反应电势）：\n  - $A = 0.01 \\ \\mathrm{m}^2$\n  - $L = 1.5 \\times 10^{-4} \\ \\mathrm{m}$\n  - $\\sigma_s = 200 \\ \\mathrm{S/m}$\n  - $a_s = 1.2 \\times 10^{5} \\ \\mathrm{m}^2/\\mathrm{m}^3$\n  - $I_{\\mathrm{app}} = 3.0 \\ \\mathrm{A}$\n  - $t_c = 1200 \\ \\mathrm{s}$\n  - $E_0 = 3.5 \\ \\mathrm{V}$\n  - $k_\\eta = 3.0 \\times 10^{-4} \\ \\mathrm{V/s}$\n  - $U_{\\mathrm{side}} = 3.85 \\ \\mathrm{V}$\n  - $j_{0,\\mathrm{side}} = 2.0 \\times 10^{-2} \\ \\mathrm{A/m}^2$\n  - $\\alpha_{\\mathrm{side}} = 0.5$\n  - $T = 298 \\ \\mathrm{K}$\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序为 $[\\mathrm{CE}_1,\\mathrm{EE}_1,\\mathrm{CE}_2,\\mathrm{EE}_2,\\mathrm{CE}_3,\\mathrm{EE}_3]$，其中下标表示测试用例编号。每个条目必须四舍五入到六位小数。单位：$\\mathrm{CE}$ 和 $\\mathrm{EE}$ 是无量纲小数；能量在计算内部使用焦耳；电势单位为伏特；时间单位为秒；长度单位为米；面积单位为平方米；电导率单位为西门子/米；温度单位为开尔文。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它在科学上基于已确立的电化学原理，在数学上是适定的，并提供了一套完整且一致的参数和定义。该问题构成了一个简化但并非微不足道的电池建模练习，要求从给定的物理模型中计算关键性能指标。\n\n任务是在指定的充放电条件下，计算一维多孔电极的库仑效率（$\\mathrm{CE}$）和能量效率（$\\mathrm{EE}$）。解决方案的步骤是，首先推导所需物理量的表达式，然后概述计算方法。\n\n**1. 库仑效率（$\\mathrm{CE}$）**\n\n库仑效率定义为可逆存储电荷与总输入电荷之比，即 $\\mathrm{CE} = Q_{\\mathrm{main}} / Q_{\\mathrm{in}}$。\n\n在充电时间 $t_c$ 内以恒定电流 $I_{\\mathrm{app}}$ 供给电极的总电荷为：\n$$\nQ_{\\mathrm{in}} = I_{\\mathrm{app}} t_c\n$$\n\n这部分电荷中的一部分 $Q_{\\mathrm{loss}}$ 会被寄生副反应消耗。这个损失的电荷必须通过对体积副反应电流密度 $i_{\\mathrm{side}}(x,t)$ 在整个电极体积和充电时长上进行积分来计算：\n$$\nQ_{\\mathrm{loss}} = \\int_{0}^{t_c} \\int_{0}^{L} i_{\\mathrm{side}}(x,t) \\, A \\, dx \\, dt\n$$\n体积电流密度由 $i_{\\mathrm{side}}(x,t) = a_s j_{\\mathrm{side}}(x,t)$ 给出，其中 $a_s$ 是比表面积，$j_{\\mathrm{side}}(x,t)$ 是界面电流密度。后者由塔菲尔关系描述：\n$$\nj_{\\mathrm{side}}(x,t) = j_{0,\\mathrm{side}} \\exp\\left(\\frac{\\alpha_{\\mathrm{side}} F}{R T} \\, \\eta_{\\mathrm{side}}(x,t)\\right)\n$$\n副反应的过电势 $\\eta_{\\mathrm{side}}(x,t)$ 取决于局部固相电势 $\\phi_s(x,t)$ 和副反应的平衡电势 $U_{\\mathrm{side}}$：\n$$\n\\eta_{\\mathrm{side}}(x,t) = \\phi_s(x,t) - U_{\\mathrm{side}}\n$$\n将给定的模型 $\\phi_s(x,t) = E_{\\mathrm{main}}(t) - \\frac{I_{\\mathrm{app}}}{A} \\frac{x}{\\sigma_s}$ 和 $E_{\\mathrm{main}}(t) = E_0 + k_\\eta t$ 代入，过电势变为：\n$$\n\\eta_{\\mathrm{side}}(x,t) = \\left(E_0 + k_\\eta t - \\frac{I_{\\mathrm{app}}}{A \\sigma_s} x\\right) - U_{\\mathrm{side}}\n$$\n因此，$Q_{\\mathrm{loss}}$ 的完整被积函数为：\n$$\nA \\, i_{\\mathrm{side}}(x,t) = A \\, a_s \\, j_{0,\\mathrm{side}} \\exp\\left(\\frac{\\alpha_{\\mathrm{side}} F}{R T} \\left(E_0 - U_{\\mathrm{side}} + k_\\eta t - \\frac{I_{\\mathrm{app}}}{A \\sigma_s} x\\right)\\right)\n$$\n必须计算 $Q_{\\mathrm{loss}}$ 的这个二重积分。尽管由于指数函数的自变量在 $x$ 和 $t$ 上是可分离的，该积分可以解析求解，但问题陈述指定了进行数值计算，我们将使用标准的求积方法来完成。\n\n可逆存储的电荷为 $Q_{\\mathrm{main}} = Q_{\\mathrm{in}} - Q_{\\mathrm{loss}}$。则库仑效率为：\n$$\n\\mathrm{CE} = \\frac{Q_{\\mathrm{in}} - Q_{\\mathrm{loss}}}{Q_{\\mathrm{in}}} = 1 - \\frac{Q_{\\mathrm{loss}}}{Q_{\\mathrm{in}}}\n$$\n对于 $j_{0,\\mathrm{side}} = 0$ 的特殊情况，$Q_{\\mathrm{loss}}$ 显然为 $0$，且 $\\mathrm{CE} = 1$。\n\n**2. 能量效率（$\\mathrm{EE}$）**\n\n能量效率是放电期间输出的能量与充电期间消耗的能量之比，即 $\\mathrm{EE} = W_{\\mathrm{out}} / W_{\\mathrm{in}}$。\n\n充电期间的能量输入 $W_{\\mathrm{in}}$ 是电功率在充电时间上的积分：\n$$\nW_{\\mathrm{in}} = \\int_{0}^{t_c} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{ch}}(t) \\, dt\n$$\n使用给定的充电端电压近似 $V_{\\mathrm{term}}^{\\mathrm{ch}}(t) = E_{\\mathrm{main}}(t) + \\Delta V_{\\mathrm{ohm}}$，其中 $\\Delta V_{\\mathrm{ohm}} = \\frac{I_{\\mathrm{app}} L}{2 A \\sigma_s}$ 且 $E_{\\mathrm{main}}(t) = E_0 + k_\\eta t$：\n$$\nW_{\\mathrm{in}} = I_{\\mathrm{app}} \\int_{0}^{t_c} \\left(E_0 + k_\\eta t + \\Delta V_{\\mathrm{ohm}}\\right) dt\n$$\n该积分可以很容易地解析计算：\n$$\nW_{\\mathrm{in}} = I_{\\mathrm{app}} \\left[ (E_0 + \\Delta V_{\\mathrm{ohm}})t + \\frac{1}{2} k_\\eta t^2 \\right]_0^{t_c} = I_{\\mathrm{app}} \\left( (E_0 + \\Delta V_{\\mathrm{ohm}})t_c + \\frac{1}{2} k_\\eta t_c^2 \\right)\n$$\n\n放电期间的能量输出 $W_{\\mathrm{out}}$ 是在放电时长 $t_d$ 内计算的。该时长由可逆存储的电荷量决定，即 $t_d = Q_{\\mathrm{main}} / I_{\\mathrm{app}} = (\\mathrm{CE} \\cdot Q_{\\mathrm{in}}) / I_{\\mathrm{app}} = \\mathrm{CE} \\cdot t_c$。\n$$\nW_{\\mathrm{out}} = \\int_{0}^{t_d} I_{\\mathrm{app}} \\, V_{\\mathrm{term}}^{\\mathrm{dis}}(t) \\, dt\n$$\n放电端电压为 $V_{\\mathrm{term}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}^{\\mathrm{dis}}(t) - \\Delta V_{\\mathrm{ohm}}$，主电势沿其路径回溯：$E_{\\mathrm{main}}^{\\mathrm{dis}}(t) = E_{\\mathrm{main}}(t_c - t) = E_0 + k_\\eta (t_c - t)$。\n$$\nW_{\\mathrm{out}} = I_{\\mathrm{app}} \\int_{0}^{t_d} \\left( E_0 + k_\\eta (t_c - t) - \\Delta V_{\\mathrm{ohm}} \\right) dt = I_{\\mathrm{app}} \\int_{0}^{t_d} \\left( (E_0 + k_\\eta t_c - \\Delta V_{\\text{ohm}}) - k_\\eta t \\right) dt\n$$\n对此积分进行解析计算可得：\n$$\nW_{\\mathrm{out}} = I_{\\mathrm{app}} \\left[ (E_0 + k_\\eta t_c - \\Delta V_{\\mathrm{ohm}})t - \\frac{1}{2} k_\\eta t^2 \\right]_0^{t_d} = I_{\\mathrm{app}} \\left( (E_0 + k_\\eta t_c - \\Delta V_{\\mathrm{ohm}})t_d - \\frac{1}{2} k_\\eta t_d^2 \\right)\n$$\n\n最后，能量效率计算为这两种能量之比：\n$$\n\\mathrm{EE} = \\frac{W_{\\mathrm{out}}}{W_{\\mathrm{in}}}\n$$\n\n**3. 计算策略**\n\n对每个测试用例，实施以下步骤：\n1.  定义所有物理常数（$F$，$R$）和特定于测试用例的参数。\n2.  使用合适的求积程序，通过计算 $A \\, i_{\\mathrm{side}}(x,t)$ 在 $x \\in [0, L]$ 和 $t \\in [0, t_c]$ 上的二重积分来数值计算 $Q_{\\mathrm{loss}}$。如果 $j_{0,\\mathrm{side}} = 0$，则直接将 $Q_{\\mathrm{loss}}$ 设为 $0$。\n3.  计算 $Q_{\\mathrm{in}} = I_{\\mathrm{app}} t_c$。\n4.  计算 $\\mathrm{CE} = 1 - Q_{\\mathrm{loss}} / Q_{\\mathrm{in}}$。\n5.  计算平均欧姆贡献 $\\Delta V_{\\mathrm{ohm}} = \\frac{I_{\\mathrm{app}} L}{2 A \\sigma_s}$。\n6.  使用其解析公式计算输入能量 $W_{\\mathrm{in}}$。\n7.  计算放电时间 $t_d = \\mathrm{CE} \\cdot t_c$。\n8.  使用其解析公式和计算出的 $t_d$ 计算输出能量 $W_{\\mathrm{out}}$。\n9.  计算 $\\mathrm{EE} = W_{\\mathrm{out}} / W_{\\mathrm{in}}$。\n10. 存储最终输出的结果 $\\mathrm{CE}$ 和 $\\mathrm{EE}$ 值，四舍五入至六位小数。\n\n此过程将应用于所提供的三个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Computes the coulombic and energy efficiencies for a porous electrode\n    based on a simplified electrochemical model.\n    \"\"\"\n    \n    # Physical Constants\n    F = 96485.33212  # Faraday constant in C/mol\n    R = 8.314462618  # Universal gas constant in J/(mol K)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: general case\n        {\n            \"A\": 0.01, \"L\": 1.0e-4, \"sigma_s\": 1000, \"a_s\": 8.0e4,\n            \"I_app\": 2.0, \"t_c\": 1800, \"E0\": 3.6, \"k_eta\": 2.0e-4,\n            \"U_side\": 4.0, \"j0_side\": 2.0e-2, \"alpha_side\": 0.5, \"T\": 298\n        },\n        # Test Case 2: no side reaction edge case\n        {\n            \"A\": 0.01, \"L\": 1.0e-4, \"sigma_s\": 1000, \"a_s\": 8.0e4,\n            \"I_app\": 2.0, \"t_c\": 1800, \"E0\": 3.6, \"k_eta\": 2.0e-4,\n            \"U_side\": 4.0, \"j0_side\": 0.0, \"alpha_side\": 0.5, \"T\": 298\n        },\n        # Test Case 3: low conductivity and closer side-reaction potential\n        {\n            \"A\": 0.01, \"L\": 1.5e-4, \"sigma_s\": 200, \"a_s\": 1.2e5,\n            \"I_app\": 3.0, \"t_c\": 1200, \"E0\": 3.5, \"k_eta\": 3.0e-4,\n            \"U_side\": 3.85, \"j0_side\": 2.0e-2, \"alpha_side\": 0.5, \"T\": 298\n        }\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Unpack parameters for clarity\n        A = params[\"A\"]\n        L = params[\"L\"]\n        sigma_s = params[\"sigma_s\"]\n        a_s = params[\"a_s\"]\n        I_app = params[\"I_app\"]\n        t_c = params[\"t_c\"]\n        E0 = params[\"E0\"]\n        k_eta = params[\"k_eta\"]\n        U_side = params[\"U_side\"]\n        j0_side = params[\"j0_side\"]\n        alpha_side = params[\"alpha_side\"]\n        T = params[\"T\"]\n        \n        # --- 1. Coulombic Efficiency (CE) Calculation ---\n        \n        Q_in = I_app * t_c\n        \n        if j0_side == 0.0:\n            Q_loss = 0.0\n        else:\n            # Define the integrand for Q_loss\n            # Integrand is A * i_side(x, t)\n            # Order of arguments for dblquad is func(y, x), here func(x, t).\n            # func's first arg is the inner integral variable, second is outer.\n            # We integrate dx dt, so inner is x, outer is t. dblquad expect (y,x) so (t,x).\n            # dblquad(func, x_min, x_max, y_min, y_max)\n            # So, func(t,x) and dblquad(..., 0, L, 0, t_c).\n            \n            beta_factor = (alpha_side * F) / (R * T)\n            \n            def integrand_q_loss(t, x):\n                eta_side = (E0 + k_eta * t - (I_app / (A * sigma_s)) * x) - U_side\n                i_side_vol = a_s * j0_side * np.exp(beta_factor * eta_side)\n                return A * i_side_vol\n\n            # Numerical integration for Q_loss\n            Q_loss, _ = dblquad(integrand_q_loss, 0, L, 0, t_c)\n\n        CE = 1 - (Q_loss / Q_in)\n        \n        # --- 2. Energy Efficiency (EE) Calculation ---\n        \n        # Average ohmic contribution\n        delta_V_ohm = (I_app * L) / (2 * A * sigma_s)\n        \n        # Input energy (analytical)\n        W_in = I_app * ((E0 + delta_V_ohm) * t_c + 0.5 * k_eta * t_c**2)\n\n        # Discharge duration\n        t_d = CE * t_c\n        \n        # Output energy (analytical)\n        if W_in > 0: # Avoid division by zero if there's no input energy\n            W_out = I_app * ((E0 + k_eta * t_c - delta_V_ohm) * t_d - 0.5 * k_eta * t_d**2)\n            EE = W_out / W_in\n        else:\n            EE = 0.0\n\n        # Append results rounded to six decimal places\n        results.append(f\"{CE:.6f}\")\n        results.append(f\"{EE:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为电池包设计高效的充电策略，需要在充电速度、能量效率和运行安全（如温度限制）等多个相互制约的目标之间取得平衡。本练习将充电问题构建为一个正式的优化任务，您将利用一个面向控制的电池包模型，来寻找最优的充电电流和电芯均衡策略，以在满足所有运行约束的前提下最小化能量损失。这项综合性练习连接了效率建模与系统控制，展示了如何运用库仑和能量效率模型来设计智能、高性能的电池管理系统 。",
            "id": "3902258",
            "problem": "您的任务是为自动化电池设计和仿真环境开发、指定和实施一种控制策略，该策略调度充电电流和每个电芯的旁路平衡电流，以在实际约束下最大化电池包的往返能量效率。电池包由串联电芯组成，模型必须包含库仑效率、能量效率以及热限制。您的程序必须在离散化的时间范围内计算最优策略，并为每个测试案例以小数形式报告最终的往返能量效率。\n\n使用的基本原理：\n- 能量守恒：输入电能为 $E_{\\text{in}} = \\int I(t) V_{\\text{pack}}(t) \\, dt$，电阻热遵循焦耳定律 $P_{\\text{Joule}}(t) = I(t)^2 R_{\\text{pack}}$。\n- 荷电状态 (SOC) 变化：对于每个电芯 $j$，考虑库仑效率的充电所存储的电荷增量为 $\\Delta q_j = \\eta_{\\text{C}} \\int \\left(I(t) - b_j(t)\\right) \\, dt$，其中 $\\eta_{\\text{C}}$ 是库仑效率，$b_j(t)$ 是电芯 $j$ 的旁路电流。\n- 一阶集总热模型：对于每个电芯 $j$，温度动态特性为 $C_{\\text{th},j} \\frac{dT_j}{dt} = Q_{\\text{gen},j} - h_j \\left(T_j - T_{\\text{amb}}\\right)$，其中产热 $Q_{\\text{gen},j}(t) \\approx I(t)^2 R_j + b_j(t) V_{0,j}$。\n- 电池包电压近似：采用广泛使用的线性近似 $V_{\\text{pack}}(t) \\approx \\sum_{j=1}^{N} V_{0,j} + I(t) \\sum_{j=1}^{N} R_j$，其中 $V_{0,j}$ 是工作窗口内开路电压的恒定近似值，$R_j$ 是电芯 $j$ 的内阻。\n\n首次出现的缩略语定义：\n- 往返能量 (RTE) 效率：放电时回收的能量相对于充电时输入能量的比例。我们用 $\\eta_{\\text{RTE}}$ 表示，在此近似为有效存储能量与输入能量之比，假设在感兴趣的窗口内放电效率接近于 1。\n- 荷电状态 (SOC)：已用电芯容量的比例，对于电芯 $j$ 表示为 $s_j \\in [0,1]$。\n- 库仑效率 (CE)：充电期间有效存储的电荷比例，表示为 $\\eta_{\\text{C}}$。\n\n离散化与决策变量：\n- 考虑 $N$ 个串联电芯，索引为 $j \\in \\{1,\\dots,N\\}$，以及一个离散化的充电时间范围，包含 $K$ 个时间步，索引为 $k \\in \\{0,\\dots,K-1\\}$，每个时间步的持续时间为 $\\Delta t$。\n- 每个时间步 $k$ 的决策变量是电池包充电电流 $I_k \\geq 0$ 和每个电芯的旁路电流 $b_{j,k} \\geq 0$，并满足物理约束 $b_{j,k} \\leq I_k$（电芯旁路的电流不能超过串联充电电流）。\n- 每个电芯 $j$ 的 SOC 更新模型为 $s_{j,k+1} = s_{j,k} + \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j}\\left(I_k - b_{j,k}\\right)$，其中 $Q_j$ 是电芯 $j$ 的容量，单位为 $\\text{A}\\cdot\\text{s}$。\n- 每个电芯 $j$ 的温度更新模型为 $T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right)$。\n\n目标与约束：\n- 输入能量为 $E_{\\text{in}} = \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right)$。\n- 有效存储能量（在恒定开路电压近似下可用于后续放电的能量）为 $E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\, \\eta_{\\text{C}} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right)$。\n- 往返能量效率为 $\\eta_{\\text{RTE}} = \\frac{E_{\\text{stored}}}{E_{\\text{in}}}$。\n- 为了将问题转化为数学上易于处理的形式，目标是在满足目标 SOC 均衡约束的条件下最大化 $\\eta_{\\text{RTE}}$。这等同于在满足所有 $j$ 的线性等式约束 $s_{j,K} = s_{\\text{target}}$（由 SOC 更新模型强制执行）和所有 $j,k$ 的热不等式约束 $T_{j,k} \\leq T_{\\max}$ 的条件下最小化 $E_{\\text{in}}$。\n\n您的程序必须：\n- 使用数值优化器来构建并求解上述离散化优化问题，以获得最小化 $E_{\\text{in}}$ 且满足所有约束的 $\\{I_k\\}_{k=0}^{K-1}$ 和 $\\{b_{j,k}\\}_{j=1,k=0}^{N,K-1}$。\n- 使用上述定义计算最终的 $\\eta_{\\text{RTE}}$。\n- 物理单位：电流单位 A，电压单位 V，电阻单位 $\\Omega$，容量单位 $\\text{A}\\cdot\\text{s}$，时间单位 s，温度单位摄氏度。\n- 将每个最终结果表示为四舍五入到 $6$ 位小数的十进制数。\n\n测试套件与参数：\n提供一个包含三个案例的测试套件。对于每个案例，电池包大小为 $N=3$ 个串联电芯。参数如下：\n\n- 案例 1 (一般可行案例)：\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$，$R = [0.01, 0.01, 0.01]$ $\\Omega$，$V_0 = [3.70, 3.71, 3.69]$ $\\text{V}$。\n  - $s_0 = [0.30, 0.32, 0.28]$，$s_{\\text{target}} = 0.80$，$\\eta_{\\text{C}} = 0.995$。\n  - $T_0 = [25.0, 25.0, 25.0]$ ${}^{\\circ}\\text{C}$，$T_{\\text{amb}} = 25.0$ ${}^{\\circ}\\text{C}$，$T_{\\max} = 40.0$ ${}^{\\circ}\\text{C}$。\n  - $C_{\\text{th}} = [12000, 12000, 12000]$ $\\text{J}/{}^{\\circ}\\text{C}$，$h = [12, 12, 12]$ $\\text{W}/{}^{\\circ}\\text{C}$。\n  - 时间范围：$K=6$，$\\Delta t = 60$ $\\text{s}$，电流边界 $0 \\leq I_k \\leq 20$ $\\text{A}$。\n\n- 案例 2 (边界温度案例)：\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$，$R = [0.02, 0.02, 0.02]$ $\\Omega$，$V_0 = [3.65, 3.66, 3.64]$ $\\text{V}$。\n  - $s_0 = [0.40, 0.39, 0.41]$，$s_{\\text{target}} = 0.85$，$\\eta_{\\text{C}} = 0.992$。\n  - $T_0 = [35.0, 35.0, 35.0]$ ${}^{\\circ}\\text{C}$，$T_{\\text{amb}} = 35.0$ ${}^{\\circ}\\text{C}$，$T_{\\max} = 40.0$ ${}^{\\circ}\\text{C}$。\n  - $C_{\\text{th}} = [9000, 9000, 9000]$ $\\text{J}/{}^{\\circ}\\text{C}$，$h = [8, 8, 8]$ $\\text{W}/{}^{\\circ}\\text{C}$。\n  - 时间范围：$K=5$，$\\Delta t = 60$ $\\text{s}$，电流边界 $0 \\leq I_k \\leq 22$ $\\text{A}$。\n\n- 案例 3 (低库仑效率案例)：\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$，$R = [0.015, 0.015, 0.015]$ $\\Omega$，$V_0 = [3.68, 3.69, 3.67]$ $\\text{V}$。\n  - $s_0 = [0.20, 0.22, 0.18]$，$s_{\\text{target}} = 0.70$，$\\eta_{\\text{C}} = 0.970$。\n  - $T_0 = [20.0, 20.0, 20.0]$ ${}^{\\circ}\\text{C}$，$T_{\\text{amb}} = 20.0$ ${}^{\\circ}\\text{C}$，$T_{\\max} = 50.0$ ${}^{\\circ}\\text{C}$。\n  - $C_{\\text{th}} = [15000, 15000, 15000]$ $\\text{J}/{}^{\\circ}\\text{C}$，$h = [15, 15, 15]$ $\\text{W}/{}^{\\circ}\\text{C}$。\n  - 时间范围：$K=8$，$\\Delta t = 60$ $\\text{s}$，电流边界 $0 \\leq I_k \\leq 15$ $\\text{A}$。\n\n答案规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\left[ r_1, r_2, r_3 \\right]$，其中 $r_i$ 是案例 $i$ 优化后的 $\\eta_{\\text{RTE}}$，表示为小数并四舍五入到 $6$ 位小数。",
            "solution": "用户提供了一个科学上合理且定义明确的问题。该问题已根据所需标准进行验证，下面提供了完整的解决方案。\n\n任务是为串联电池包设计一种充电策略，以最大化往返能量 (RTE) 效率，表示为 $\\eta_{\\text{RTE}}$。这是通过在 $K$ 个步骤的离散时间范围内控制电池包充电电流 $I_k$ 和每个电芯的旁路电流 $b_{j,k}$ 来实现的。该策略必须遵守物理约束，包括最终荷电状态 (SOC) 目标和最高电芯温度。\n\n首先，我们将其形式化为一个数学优化问题。问题陈述指明，最大化 $\\eta_{\\text{RTE}} = E_{\\text{stored}}/E_{\\text{in}}$ 等同于最小化输入能量 $E_{\\text{in}}$，因为对于任何可行解，存储的能量 $E_{\\text{stored}}$ 是一个常数。这一点成立是因为每个电芯的最终 SOC 是一个固定的目标值，$s_{j,K} = s_{\\text{target}}$。存储的能量由下式给出：\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_{\\text{C}} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right) $$\n\n从 SOC 更新方程 $s_{j,K} = s_{j,0} + \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j} \\sum_{k=0}^{K-1} (I_k - b_{j,k})$，我们可以代入总转移电荷的项：\n\n$$ \\sum_{k=0}^{K-1} \\Delta t (I_k - b_{j,k}) = \\frac{Q_j (s_{j,K} - s_{j,0})}{\\eta_{\\text{C}}} $$\n\n将此代入 $E_{\\text{stored}}$ 的表达式中可得：\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_{\\text{C}} \\left( \\frac{Q_j (s_{\\text{target}} - s_{j,0})}{\\eta_{\\text{C}}} \\right) = \\sum_{j=1}^{N} V_{0,j} Q_j (s_{\\text{target}} - s_{j,0}) $$\n\n由于对于给定案例，$V_{0,j}$、$Q_j$、$s_{\\text{target}}$ 和 $s_{j,0}$ 都是固定参数，因此 $E_{\\text{stored}}$ 是一个常数。所以，最大化 $\\eta_{\\text{RTE}}$ 确实等同于最小化输入能量 $E_{\\text{in}}$。\n\n因此，该优化问题可以表述为：\n\n**1. 决策变量**\n需要优化的变量是每个时间步 $k$ 的充电电流 $I_k$ 和每个电芯 $j$ 在每个时间步 $k$ 的旁路电流 $b_{j,k}$。我们将这些变量排列成一个大小为 $K(N+1)$ 的向量 $\\mathbf{x}$：\n$$ \\mathbf{x} = [I_0, \\dots, I_{K-1}, b_{1,0}, \\dots, b_{1,K-1}, \\dots, b_{N,0}, \\dots, b_{N,K-1}] $$\n\n**2. 目标函数**\n目标是最小化总输入能量 $E_{\\text{in}}$，它是决策变量的函数。$E_{\\text{in}}$ 的离散形式是：\n$$ \\min_{\\mathbf{x}} E_{\\text{in}}(\\mathbf{x}) = \\min_{I_k} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right) $$\n这是一个关于电流 $I_k$ 的二次函数。\n\n**3. 约束条件**\n优化过程受到几个源于电池包物理模型的约束。\n\n- **变量边界**：电流必须为非负值，且充电电流受最大值 $I_{\\max}$ 的限制。电芯的旁路电流不能超过电池包电流。\n    - $0 \\le I_k \\le I_{\\max}$ for $k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\ge 0$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\le I_k$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n\n- **SOC 等式约束**：在时间范围结束时 ($k=K$)，每个电芯 $j$ 的 SOC 必须等于目标 SOC，$s_{\\text{target}}$。\n    $$ s_{j,0} + \\sum_{k=0}^{K-1} \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j} (I_k - b_{j,k}) = s_{\\text{target}} \\quad \\text{for } j \\in \\{1, \\dots, N\\} $$\n    这 $N$ 个约束对于决策变量 $I_k$ 和 $b_{j,k}$ 是线性的。\n\n- **热不等式约束**：在任何时间步 $k \\in \\{1, \\dots, K\\}$，每个电芯 $j$ 的温度不得超过 $T_{\\max}$。温度 $T_{j,k}$ 由离散时间热模型确定：\n    $$ T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right) $$\n    这个递推关系意味着 $T_{j,k}$ 是决策变量 $\\{I_m, b_{j,m}\\}$ (其中 $m  k$) 的非线性函数。因此，$N \\times K$ 个约束为：\n    $$ T_{j,k}(\\mathbf{x}) \\le T_{\\max} \\quad \\text{for } j \\in \\{1, \\dots, N\\}, k \\in \\{1, \\dots, K\\} $$\n\n**数值求解策略**\n此问题是一个非线性规划 (NLP) 问题，具体来说，由于目标函数和热约束的性质，它是一个二次约束二次规划 (QCQP) 问题。我们将使用 `scipy.optimize` 库中的 `minimize` 函数，并采用序列最小二乘规划 (`SLSQP`) 算法，该算法非常适合此类问题。\n\n实施过程包括：\n1.  定义代表目标函数和每组约束的 Python 函数。这些函数将决策变量向量 $\\mathbf{x}$ 作为输入。\n2.  在约束评估函数内，每个时间步的温度都是迭代计算的。\n3.  边界和约束以 `minimize` 函数要求的格式（一个包含字典的列表，用于约束）传递给它。\n4.  数值优化成功收敛的一个关键步骤是提供一个好的初始猜测值 $\\mathbf{x}_0$。我们基于需要最多充电量的电芯来构建猜测值。我们计算该电芯所需的平均恒定电流（假设没有旁路），然后确定其他电芯为达到其目标所需的旁路电流。这提供了一个物理上合理的、接近可行域的起点。\n5.  在优化器找到最优解向量 $\\mathbf{x}^*$ 后，最小输入能量 $E_{\\text{in}}^*$ 就是目标函数在该点的值。\n6.  最终的往返能量效率 $\\eta_{\\text{RTE}}$ 计算公式为 $\\eta_{\\text{RTE}} = E_{\\text{stored}} / E_{\\text{in}}^*$，其中 $E_{\\text{stored}}$ 是预先计算的常数值。然后将此结果四舍五入到所需精度。\n\n这种结构化的方法将复杂的多物理场电池充电问题转化为一个可解的数值优化任务，从而得出最优控制策略和相应的最大可实现效率。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the optimization for each.\n    \"\"\"\n    # Case 1: General feasible case\n    case1 = {\n        'N': 3, 'K': 6, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.01, 0.01, 0.01]),\n        'V0': np.array([3.70, 3.71, 3.69]),\n        's0': np.array([0.30, 0.32, 0.28]),\n        's_target': 0.80,\n        'eta_C': 0.995,\n        'T0': np.array([25.0, 25.0, 25.0]),\n        'Tamb': 25.0,\n        'Tmax': 40.0,\n        'C_th': np.array([12000.0, 12000.0, 12000.0]),\n        'h': np.array([12.0, 12.0, 12.0]),\n        'I_max': 20.0\n    }\n\n    # Case 2: Boundary temperature case\n    case2 = {\n        'N': 3, 'K': 5, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.02, 0.02, 0.02]),\n        'V0': np.array([3.65, 3.66, 3.64]),\n        's0': np.array([0.40, 0.39, 0.41]),\n        's_target': 0.85,\n        'eta_C': 0.992,\n        'T0': np.array([35.0, 35.0, 35.0]),\n        'Tamb': 35.0,\n        'Tmax': 40.0,\n        'C_th': np.array([9000.0, 9000.0, 9000.0]),\n        'h': np.array([8.0, 8.0, 8.0]),\n        'I_max': 22.0\n    }\n\n    # Case 3: Low Coulombic efficiency case\n    case3 = {\n        'N': 3, 'K': 8, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.015, 0.015, 0.015]),\n        'V0': np.array([3.68, 3.69, 3.67]),\n        's0': np.array([0.20, 0.22, 0.18]),\n        's_target': 0.70,\n        'eta_C': 0.970,\n        'T0': np.array([20.0, 20.0, 20.0]),\n        'Tamb': 20.0,\n        'Tmax': 50.0,\n        'C_th': np.array([15000.0, 15000.0, 15000.0]),\n        'h': np.array([15.0, 15.0, 15.0]),\n        'I_max': 15.0\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for params in test_cases:\n        result_rte = run_optimization_case(params)\n        results.append(f\"{result_rte:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_optimization_case(params):\n    \"\"\"\n    Sets up and solves the optimization problem for a single test case.\n    \"\"\"\n    N, K, dt = params['N'], params['K'], params['dt']\n    Q, R, V0 = params['Q'], params['R'], params['V0']\n    s0, s_target, eta_C = params['s0'], params['s_target'], params['eta_C']\n    T0, Tamb, Tmax = params['T0'], params['Tamb'], params['Tmax']\n    C_th, h = params['C_th'], params['h']\n    I_max = params['I_max']\n\n    V0_sum = np.sum(V0)\n    R_sum = np.sum(R)\n    \n    num_vars = K * (N + 1)\n\n    # Objective function: Minimize Ein\n    def objective_function(x):\n        I_vars = x[:K]\n        return dt * np.sum(I_vars * V0_sum + I_vars**2 * R_sum)\n\n    # Helper to calculate temperatures\n    def calculate_temperatures(x):\n        I_vars = x[:K]\n        b_vars = x[K:].reshape((N, K))\n        T = np.zeros((N, K + 1))\n        T[:, 0] = T0\n        for k in range(K):\n            Q_gen_k = I_vars[k]**2 * R + b_vars[:, k] * V0\n            T_dot_k = (Q_gen_k - h * (T[:, k] - Tamb)) / C_th\n            T[:, k + 1] = T[:, k] + T_dot_k * dt\n        return T\n\n    # Constraints\n    constraints = []\n\n    # 1. SOC equality constraints: s_j,K = s_target\n    soc_target_charge_integral = Q * (s_target - s0) / (eta_C * dt)\n    for j in range(N):\n        def soc_constraint(x, j=j):\n            I_vars = x[:K]\n            b_j_vars = x[K + j * K : K + (j + 1) * K]\n            return np.sum(I_vars - b_j_vars) - soc_target_charge_integral[j]\n        constraints.append({'type': 'eq', 'fun': soc_constraint})\n\n    # 2. Bypass current inequality: b_j,k = I_k  (or I_k - b_j,k >= 0)\n    for j in range(N):\n        for k in range(K):\n            def bypass_constraint(x, j=j, k=k):\n                return x[k] - x[K + j * K + k]\n            constraints.append({'type': 'ineq', 'fun': bypass_constraint})\n            \n    # 3. Temperature inequality: T_j,k = Tmax (or Tmax - T_j,k >= 0)\n    def temp_constraints(x):\n        temps = calculate_temperatures(x)\n        # Constraints on T_j,k for k=1...K\n        return (Tmax - temps[:, 1:]).flatten()\n    constraints.append({'type': 'ineq', 'fun': temp_constraints})\n\n    # Bounds for decision variables\n    bounds_I = [(0, I_max)] * K\n    bounds_b = [(0, None)] * (N * K) # b_jk >= 0, b_jk = I_k is a separate constraint\n    bounds = bounds_I + bounds_b\n\n    # Initial guess (x0)\n    delta_s = s_target - s0\n    j_star = np.argmax(delta_s)\n    \n    required_charge_integral_star = Q[j_star] * delta_s[j_star] / (eta_C * dt)\n    I_const = np.clip(required_charge_integral_star / K, 0, I_max)\n    \n    x0_I = np.full(K, I_const)\n    x0_b = np.zeros((N, K))\n\n    total_I_integral = K * I_const\n    for j in range(N):\n        if j != j_star:\n            required_charge_integral_j = Q[j] * delta_s[j] / (eta_C * dt)\n            total_bypass_j = total_I_integral - required_charge_integral_j\n            if total_bypass_j > 0:\n                x0_b[j, :] = total_bypass_j / K\n    \n    x0 = np.concatenate([x0_I, x0_b.flatten()])\n    \n    # Run optimization\n    result = minimize(objective_function, x0, method='SLSQP', bounds=bounds, constraints=constraints)\n\n    if not result.success:\n        # Fallback to simpler guess if smart guess was problematic\n        x0_simple = np.full(num_vars, 1e-3)\n        result = minimize(objective_function, x0_simple, method='SLSQP', bounds=bounds, constraints=constraints)\n        if not result.success: # Raise if still fails\n             raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n\n    # Calculate final RTE_efficiency\n    E_in_opt = result.fun\n    E_stored = np.sum(V0 * Q * (s_target - s0))\n    eta_RTE = E_stored / E_in_opt\n    \n    return eta_RTE\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}