{
    "hands_on_practices": [
        {
            "introduction": "In automated battery testing and simulation, we work with data that is inherently discrete, sampled at specific points in time. However, core quantities like charge ($Q$) and energy ($E$) are defined by continuous integrals. This exercise  bridges that gap by tasking you with reconstructing these integral quantities from non-uniformly sampled current and voltage data. More importantly, it challenges you to derive and apply theoretical error bounds, a crucial skill for ensuring the numerical integrity and accuracy of any data analysis or simulation result.",
            "id": "3902321",
            "problem": "Consider a battery cycling scenario where the measurable quantities are the electric current $I(t)$ in amperes and the terminal voltage $V(t)$ in volts as functions of time $t$ in seconds. The charge throughput $Q$ over a time horizon $[0,T]$ is defined by the integral $Q=\\int_0^T I(t)\\,dt$ in coulombs, and the energy throughput $E$ is defined by $E=\\int_0^T V(t)I(t)\\,dt$ in joules. In automated battery design and simulation, one typically only has discretely sampled data with time-varying sampling intervals. Your task is to reconstruct $Q$ and $E$ from nonuniform samples via a principled numerical method and to derive error bounds based on fundamental principles. Use International System of Units (SI) for all physical quantities; express $Q$ in coulombs and $E$ in joules, and express all outputs as decimal numbers.\n\nStarting from core definitions of charge and energy throughput and from standard numerical analysis fundamentals, do the following:\n\n1. Derive a method to reconstruct the integrals $Q=\\int_0^T I(t)\\,dt$ and $E=\\int_0^T V(t)I(t)\\,dt$ from discretely sampled values $\\{t_k\\}_{k=0}^N$, $I_k=I(t_k)$, and $V_k=V(t_k)$, where the time stamps satisfy $0=t_0t_1\\cdotst_N=T$ and the sampling intervals $h_k=t_{k+1}-t_k$ vary with $k$. The method must be based on the trapezoidal rule applied over each subinterval $[t_k,t_{k+1}]$ without assuming uniform spacing.\n2. Using Taylor expansions and well-tested error estimates for numerical integration, derive a computable upper bound on the absolute integration error for the composite trapezoidal rule on a nonuniform mesh: for a twice continuously differentiable integrand $f$, the absolute error over $[0,T]$ is bounded by a quantity that depends on an upper bound on $\\max_{t\\in[0,T]}|f''(t)|$ and on the sampling intervals $\\{h_k\\}$. Apply this to both $f(t)=I(t)$ for the charge integral and $f(t)=P(t)=V(t)I(t)$ for the energy integral. Present a bound for the energy case in terms of bounds on $|I(t)|$, $|V(t)|$, $|I'(t)|$, $|V'(t)|$, $|I''(t)|$, and $|V''(t)|$.\n3. Implement the reconstruction and bound computation in a single program. For verification, use analytically defined test signals $I(t)$ and $V(t)$ so that the exact integrals $Q$ and $E$ can be computed symbolically from first principles. For each test case, compute: the reconstructed charge $\\widehat{Q}$, the reconstructed energy $\\widehat{E}$, the absolute errors $|\\widehat{Q}-Q|$ and $|\\widehat{E}-E|$, and the corresponding trapezoidal error bounds $B_Q$ and $B_E$. Also report two booleans indicating whether the actual errors are within the bounds, that is, whether $|\\widehat{Q}-Q|\\le B_Q$ and $|\\widehat{E}-E|\\le B_E$.\n4. Use the following nonuniform sampling construction. Given a desired number of samples $N+1$ and horizon $T$, define weights $w_k=1+\\alpha\\cos^2\\!\\left(\\frac{\\pi k}{N}\\right)$ for $k\\in\\{0,1,\\dots,N-1\\}$, and set $h_k=\\frac{T\\,w_k}{\\sum_{j=0}^{N-1} w_j}$. Then set $t_0=0$ and $t_{k+1}=t_k+h_k$ for $k=0,1,\\dots,N-1$ so that $t_N=T$. This yields time-varying sampling intervals while controlling the total duration. The integrands are specified as trigonometric signals:\n   - $I(t)=I_0+I_1\\sin(a t)$\n   - $V(t)=V_0+V_1\\cos(b t)$\n   with $I_0$, $I_1$, $a$, $V_0$, $V_1$, and $b$ real constants. Assume $a0$ and $b0$. From these, deduce bounds on $|I(t)|$, $|I'(t)|$, $|I''(t)|$, $|V(t)|$, $|V'(t)|$, and $|V''(t)|$ and use them to bound $|P''(t)|$ for $P(t)=V(t)I(t)$.\n\nYour program must produce results for the following four test cases, each specified by $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)$:\n\n- Case $1$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(1000,64,0.6,2.0,1.5,0.02,3.7,0.2,0.015\\right)$.\n- Case $2$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(1000,16,0.9,2.0,0.8,0.05,3.8,0.15,0.03\\right)$.\n- Case $3$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(500,50,0.5,2.5,0.0,0.10,4.0,0.0,0.20\\right)$.\n- Case $4$: $(T,N,\\alpha,I_0,I_1,a,V_0,V_1,b)=\\left(200,64,0.7,1.8,1.2,0.20,3.6,0.25,0.18\\right)$.\n\nFor each case, compute:\n- The reconstructed charge $\\widehat{Q}$ in coulombs and the reconstructed energy $\\widehat{E}$ in joules using the composite trapezoidal rule on the nonuniform grid.\n- The exact charge $Q$ and exact energy $E$ from analytic integration of the given signals over $[0,T]$, and the absolute errors $|\\widehat{Q}-Q|$ and $|\\widehat{E}-E|$.\n- The trapezoidal error bounds $B_Q$ and $B_E$ using the nonuniform interval error bound with an upper bound on $|I''(t)|$ and on $|P''(t)|$ constructed from the given signal parameters.\n- Two booleans indicating whether the actual errors are within the computed bounds.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list for a test case in the order of the cases. Each test case list must contain eight entries: $[\\widehat{Q},\\widehat{E},|\\widehat{Q}-Q|,B_Q,|\\widehat{E}-E|,B_E,\\text{error\\_Q\\_within\\_bound},\\text{error\\_E\\_within\\_bound}]$. All numeric values must be decimals in International System of Units (SI) and the booleans must be logical values.",
            "solution": "The problem statement is assessed to be valid as it is scientifically grounded in fundamental principles of physics and numerical analysis, is well-posed with a clear objective and sufficient data, and is free from ambiguity or contradiction.\n\n### Analytical Framework\n\nThe core of the problem lies in approximating definite integrals from discrete data and bounding the associated error. Given a function $f(t)$ sampled at non-uniformly spaced time points $\\{t_k\\}_{k=0}^N$ such that $0=t_0  t_1  \\dots  t_N = T$, we aim to compute an approximation of the integral $J = \\int_0^T f(t) \\, dt$.\n\n#### 1. Numerical Reconstruction via the Composite Trapezoidal Rule\n\nThe integral over the full time horizon $[0, T]$ can be expressed as a sum of integrals over the subintervals $[t_k, t_{k+1}]$:\n$$J = \\int_0^T f(t) \\, dt = \\sum_{k=0}^{N-1} \\int_{t_k}^{t_{k+1}} f(t) \\, dt$$\nThe trapezoidal rule approximates the integral over a single subinterval $[t_k, t_{k+1}]$ by calculating the area of a trapezoid with vertices at $(t_k, 0)$, $(t_{k+1}, 0)$, $(t_k, f(t_k))$, and $(t_{k+1}, f(t_{k+1}))$. Letting $h_k = t_{k+1} - t_k$ be the length of the subinterval and $f_k = f(t_k)$ be the sampled function value, this area is given by:\n$$\\int_{t_k}^{t_{k+1}} f(t) \\, dt \\approx \\frac{h_k}{2} (f_k + f_{k+1})$$\nThe composite trapezoidal rule applies this approximation to each subinterval and sums the results to yield the total estimated integral, $\\widehat{J}$:\n$$\\widehat{J} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (f_k + f_{k+1})$$\nThis formula is directly applicable to the computation of reconstructed charge $\\widehat{Q}$ and energy $\\widehat{E}$.\n\nFor charge, $f(t) = I(t)$, so $f_k = I_k = I(t_k)$.\n$$\\widehat{Q} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (I_k + I_{k+1})$$\n\nFor energy, the integrand is the instantaneous power $P(t) = V(t)I(t)$, so $f_k = P_k = V_k I_k$.\n$$\\widehat{E} = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (P_k + P_{k+1}) = \\sum_{k=0}^{N-1} \\frac{h_k}{2} (V_k I_k + V_{k+1} I_{k+1})$$\n\n#### 2. Derivation of Error Bounds\n\nThe error of the trapezoidal rule on a single interval $[a, b]$ with width $h = b-a$ for a twice continuously differentiable function $f(t)$ is given by standard numerical analysis theory:\n$$E_{trap} = \\int_a^b f(t) \\, dt - \\frac{h}{2}(f(a) + f(b)) = -\\frac{h^3}{12} f''(\\xi)$$\nfor some $\\xi \\in (a, b)$. The absolute error is thus bounded by $|E_{trap}| \\le \\frac{h^3}{12} \\max_{t \\in [a, b]} |f''(t)|$.\n\nFor the composite rule on the non-uniform grid $\\{t_k\\}$, the total absolute error is bounded by the sum of the absolute errors on each subinterval:\n$$|\\text{Total Error}| \\le \\sum_{k=0}^{N-1} \\frac{h_k^3}{12} |f''(\\xi_k)| \\quad \\text{for } \\xi_k \\in (t_k, t_{k+1})$$\nTo obtain a computable upper bound $B_f$, we use the global maximum of the second derivative's magnitude, $M_2 = \\max_{t \\in [0,T]} |f''(t)|$:\n$$B_f = \\frac{M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\nThis provides a practical error bound for the numerical integration scheme.\n\n**Error Bound for Charge ($B_Q$):**\nThe integrand is $I(t) = I_0 + I_1 \\sin(at)$. Its derivatives are:\n$I'(t) = a I_1 \\cos(at)$\n$I''(t) = -a^2 I_1 \\sin(at)$\nThe maximum magnitude of the second derivative is $M_{2,I} = \\max_{t \\in [0,T]} |-a^2 I_1 \\sin(at)| = a^2 |I_1|$.\nThe error bound for charge is:\n$$B_Q = \\frac{a^2 |I_1|}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n**Error Bound for Energy ($B_E$):**\nThe integrand is $P(t) = V(t)I(t)$. We find its second derivative using the product rule:\n$P'(t) = V'(t)I(t) + V(t)I'(t)$\n$P''(t) = V''(t)I(t) + 2V'(t)I'(t) + V(t)I''(t)$\nUsing the triangle inequality, we bound its magnitude:\n$|P''(t)| \\le |V''(t)||I(t)| + 2|V'(t)||I'(t)| + |V(t)||I''(t)|$\nWe establish upper bounds for the magnitudes of $I(t)$, $V(t)$, and their first two derivatives over $[0,T]$:\n$I(t) = I_0 + I_1 \\sin(at) \\Rightarrow |I(t)| \\le |I_0| + |I_1| \\equiv M_0$\n$|I'(t)| \\le a|I_1| \\equiv M_1$\n$|I''(t)| \\le a^2|I_1| \\equiv M_2$\n$V(t) = V_0 + V_1 \\cos(bt) \\Rightarrow |V(t)| \\le |V_0| + |V_1| \\equiv N_0$\n$|V'(t)| = |-bV_1\\sin(bt)| \\le b|V_1| \\equiv N_1$\n$|V''(t)| = |-b^2V_1\\cos(bt)| \\le b^2|V_1| \\equiv N_2$\nThe global bound on $|P''(t)|$ is then $M_{2,P} = N_2 M_0 + 2 N_1 M_1 + N_0 M_2$.\nThe error bound for energy is:\n$$B_E = \\frac{M_{2,P}}{12} \\sum_{k=0}^{N-1} h_k^3 = \\frac{N_2 M_0 + 2 N_1 M_1 + N_0 M_2}{12} \\sum_{k=0}^{N-1} h_k^3$$\n\n#### 3. Exact Analytic Integrals\n\nFor verification, we compute the exact integrals symbolically.\n**Exact Charge ($Q$):**\n$$Q = \\int_0^T (I_0 + I_1 \\sin(at)) \\, dt = \\left[I_0 t - \\frac{I_1}{a} \\cos(at)\\right]_0^T = I_0 T - \\frac{I_1}{a}(\\cos(aT) - 1)$$\n**Exact Energy ($E$):**\n$$E = \\int_0^T (V_0 + V_1 \\cos(bt))(I_0 + I_1 \\sin(at)) \\, dt$$\nExpanding the product and integrating term-by-term yields:\n$E = \\int_0^T \\left(I_0 V_0 + V_0 I_1 \\sin(at) + I_0 V_1 \\cos(bt) + I_1 V_1 \\sin(at)\\cos(bt)\\right) \\, dt$\nUsing the identity $\\sin(A)\\cos(B) = \\frac{1}{2}(\\sin(A+B) + \\sin(A-B))$ and assuming $a \\neq b$:\n$$E = I_0 V_0 T - \\frac{V_0 I_1}{a}(\\cos(aT) - 1) + \\frac{I_0 V_1}{b}\\sin(bT) + \\frac{I_1 V_1}{2}\\left[\\frac{1-\\cos((a+b)T)}{a+b} + \\frac{1-\\cos((a-b)T)}{a-b}\\right]$$\n\n#### 4. Non-uniform Sampling Grid\n\nThe time steps $\\{h_k\\}$ are constructed via weights $w_k = 1 + \\alpha \\cos^2(\\frac{\\pi k}{N})$ for $k \\in \\{0, \\dots, N-1\\}$. The sum of weights can be computed analytically:\n$\\sum_{j=0}^{N-1} w_j = \\sum_{j=0}^{N-1} \\left(1 + \\alpha \\frac{1+\\cos(2\\pi j/N)}{2}\\right) = N + \\frac{\\alpha}{2}\\left(N + \\sum_{j=0}^{N-1}\\cos(2\\pi j/N)\\right)$.\nSince the sum of the $N$-th roots of unity is zero, their real parts also sum to zero, i.e., $\\sum_{j=0}^{N-1}\\cos(2\\pi j/N) = 0$.\nThus, $\\sum_{j=0}^{N-1} w_j = N(1 + \\alpha/2)$.\nThe time steps are $h_k = \\frac{T w_k}{\\sum w_j} = \\frac{T(1 + \\alpha \\cos^2(\\pi k/N))}{N(1 + \\alpha/2)}$, and the time samples are $t_0=0$, $t_{k+1}=t_k+h_k$. This ensures $\\sum h_k = t_N = T$.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes reconstructed charge and energy from simulated nonuniform battery data,\n    along with their exact values, absolute errors, and theoretical error bounds.\n    \"\"\"\n    test_cases = [\n        # (T, N, alpha, I0, I1, a, V0, V1, b)\n        (1000.0, 64, 0.6, 2.0, 1.5, 0.02, 3.7, 0.2, 0.015),\n        (1000.0, 16, 0.9, 2.0, 0.8, 0.05, 3.8, 0.15, 0.03),\n        (500.0, 50, 0.5, 2.5, 0.0, 0.10, 4.0, 0.0, 0.20),\n        (200.0, 64, 0.7, 1.8, 1.2, 0.20, 3.6, 0.25, 0.18),\n    ]\n\n    all_results = []\n\n    for T, N, alpha, I0, I1, a, V0, V1, b in test_cases:\n        # Part 1: Generate the non-uniform time grid\n        k_indices = np.arange(N)\n        # Using the analytic simplification for the sum of weights\n        sum_of_weights = N * (1 + alpha / 2.0)\n        weights_k = 1 + alpha * np.cos(np.pi * k_indices / N)**2\n        h_steps = (T * weights_k) / sum_of_weights\n        time_stamps = np.concatenate(([0.0], np.cumsum(h_steps)))\n\n        # Part 2: Generate sampled signal data\n        I_samples = I0 + I1 * np.sin(a * time_stamps)\n        V_samples = V0 + V1 * np.cos(b * time_stamps)\n        P_samples = I_samples * V_samples\n\n        # Part 3: Numerical Reconstruction (Composite Trapezoidal Rule)\n        Q_hat = 0.5 * np.sum(h_steps * (I_samples[:-1] + I_samples[1:]))\n        E_hat = 0.5 * np.sum(h_steps * (P_samples[:-1] + P_samples[1:]))\n\n        # Part 4: Analytical Integration (Exact Values)\n        Q_exact = I0 * T\n        if I1 != 0.0 and a != 0.0:\n            Q_exact -= (I1 / a) * (np.cos(a * T) - 1.0)\n\n        E_exact = I0 * V0 * T\n        if V0 != 0.0 and I1 != 0.0 and a != 0.0:\n            E_exact -= (V0 * I1 / a) * (np.cos(a * T) - 1.0)\n        if I0 != 0.0 and V1 != 0.0 and b != 0.0:\n            E_exact += (I0 * V1 / b) * np.sin(b * T)\n        if I1 != 0.0 and V1 != 0.0 and a != b and a != 0.0 and b != 0.0: # a != b is true for all test cases\n            apb = a + b\n            amb = a - b\n            term4 = (I1 * V1 / 2.0) * ((1.0 - np.cos(apb * T)) / apb + (1.0 - np.cos(amb * T)) / amb)\n            E_exact += term4\n        \n        # Part 5: Compute Absolute Errors\n        error_Q = np.abs(Q_hat - Q_exact)\n        error_E = np.abs(E_hat - E_exact)\n\n        # Part 6: Compute Error Bounds\n        sum_h3 = np.sum(h_steps**3)\n        \n        # Bound for Charge (B_Q)\n        M2_I = a**2 * np.abs(I1)\n        B_Q = (M2_I / 12.0) * sum_h3\n        \n        # Bound for Energy (B_E)\n        M0_I = np.abs(I0) + np.abs(I1)\n        M1_I = np.abs(a) * np.abs(I1)\n        \n        N0_V = np.abs(V0) + np.abs(V1)\n        N1_V = np.abs(b) * np.abs(V1)\n        N2_V = b**2 * np.abs(V1)\n        \n        M2_P = N2_V * M0_I + 2.0 * N1_V * M1_I + N0_V * M2_I\n        B_E = (M2_P / 12.0) * sum_h3\n\n        # Part 7: Verify if actual error is within the bound\n        error_Q_within_bound = error_Q = B_Q\n        error_E_within_bound = error_E = B_E\n\n        # Part 8: Collate results for the current test case\n        all_results.append([\n            Q_hat, E_hat, error_Q, B_Q, error_E, B_E,\n            error_Q_within_bound, error_E_within_bound\n        ])\n\n    # Format and print the final output as a single line string\n    case_strings = []\n    for case_result in all_results:\n        value_strings = [str(v) for v in case_result]\n        case_strings.append(f\"[{','.join(value_strings)}]\")\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "After mastering the calculation of coulombic efficiency (CE) from raw data, the next critical step is to interpret its physical meaning correctly. A measured CE approaching unity is often mistaken for a sign of a perfectly healthy cell, but this can be a dangerously misleading assumption. This conceptual practice  uses a simplified but physically insightful model to demonstrate how significant, continuous degradation—such as cyclable lithium loss—can be masked by certain cycling protocols, yielding a deceptively high CE. Working through this problem will sharpen your ability to critically assess battery health diagnostics and understand the limitations of standard performance metrics.",
            "id": "3902299",
            "problem": "Consider a rechargeable lithium-ion cell cycled by an automated test platform under a symmetric protocol about a mid State of Charge (SOC). The State of Charge (SOC) is denoted by $\\theta \\in [0,1]$ and the Depth of Discharge (DoD) window is a small symmetric interval $\\Delta \\theta$ about a center $\\theta_{0}$, so that charge proceeds from $\\theta_{0} - \\Delta \\theta/2$ to $\\theta_{0} + \\Delta \\theta/2$ and discharge returns to $\\theta_{0} - \\Delta \\theta/2$. Let the cell be driven galvanostatically at constant magnitude current $I0$ on both half cycles (external current $+I$ during charge and $-I$ during discharge). The total cyclable lithium inventory corresponds to an effective capacity $Q_{\\max}$, so in the absence of parasitic processes the intercalation (or deintercalation) current would change SOC according to Faraday’s law.\n\nAssume there is an irreversible parasitic side reaction current $i_{s}0$ at the negative electrode that continuously consumes cyclable lithium and is approximately constant over the small DoD and the potential range near $\\theta_{0}$. This $i_{s}$ does not reverse with cycling direction: it adds to the charge passed internally during charge (reducing the intercalation current available to move SOC) and subtracts from the deintercalation current during discharge (again reducing the current available to move SOC). The automated tester estimates Coulombic Efficiency (CE) per cycle as the ratio of the measured discharged charge to the measured charged charge, $CE = Q_{\\text{out}}/Q_{\\text{in}}$, where $Q_{\\text{in}}$ is the externally delivered charge during the charge half cycle and $Q_{\\text{out}}$ is the externally recovered charge during the discharge half cycle. The tester also estimates Energy Efficiency (EE) per cycle as $EE = E_{\\text{out}}/E_{\\text{in}}$, where $E_{\\text{in}}$ and $E_{\\text{out}}$ are the integrals of external power over the respective half cycles. Let the average cell voltage during charge be $\\overline{V}_{c}$ and during discharge be $\\overline{V}_{d}$ over this small window, with negligible hysteresis beyond these averages.\n\nFrom first principles, write and use the SOC evolution under galvanostatic control with current partitioning between intercalation/deintercalation and the side reaction, and then determine the implications for the measured $CE$ and $EE$ under this symmetric, small-DoD protocol. The following statements are proposed; select all that are correct under the stated assumptions.\n\nA. Under symmetric cycling about mid SOC with small $\\Delta \\theta$ and constant $i_{s}$, the measured per-cycle Coulombic Efficiency is $CE = \\dfrac{I - i_{s}}{I + i_{s}}$, which approaches unity as $i_{s}/I \\to 0$, even though the cyclable lithium inventory decays continuously at a rate proportional to $i_{s}$.\n\nB. The measured per-cycle Coulombic Efficiency is $CE = 1 - \\dfrac{i_{s}}{I}$ and therefore exactly underestimates inventory loss by a factor of $\\dfrac{i_{s}}{I}$, independently of $\\Delta \\theta$.\n\nC. Because the parasitic side reaction does not deliver power to the external circuit, Energy Efficiency equals Coulombic Efficiency under this protocol and is therefore unaffected by $i_{s}$.\n\nD. For small DoD windows, the total cyclable lithium loss per cycle scales linearly with $\\Delta \\theta$ via the total time spent in the window, thereby diminishing short-horizon observable capacity fade as $\\Delta \\theta$ decreases, even when $i_{s}0$.\n\nE. If $i_{s}$ is constant and $i_{s} \\ll I$, the apparent per-cycle capacity measured between fixed voltage limits remains exactly constant over repeated cycles, so capacity fade cannot occur under the protocol; only the mid-SOC open-circuit potential shifts over long times.\n\nF. The per-cycle Energy Efficiency under the protocol is $EE = \\left(\\dfrac{\\overline{V}_{d}}{\\overline{V}_{c}}\\right)\\left(\\dfrac{I - i_{s}}{I + i_{s}}\\right)$, so in the limit of small overpotentials where $\\overline{V}_{d} \\approx \\overline{V}_{c}$ and $i_{s}/I \\ll 1$, both $CE$ and $EE$ are near unity while inventory still decays slowly and is detectable only over long horizons.",
            "solution": "The problem statement describes a simplified but physically representative model of a lithium-ion cell undergoing galvanostatic cycling with a parasitic side reaction. The core of the problem lies in correctly partitioning the externally applied current between the main electrochemical reaction that changes the state of charge (SOC) and the irreversible side reaction that consumes cyclable lithium.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n- Cell type: Rechargeable lithium-ion.\n- Cycling protocol: Symmetric, galvanostatic, about a mid-SOC $\\theta_{0}$.\n- SOC range: Cycling occurs over $\\theta \\in [\\theta_0 - \\Delta\\theta/2, \\theta_0 + \\Delta\\theta/2]$, where $\\Delta\\theta$ is small.\n- External current: Constant magnitude $I  0$. $+I$ for charge, $-I$ for discharge.\n- Total cyclable capacity: $Q_{\\max}$.\n- SOC evolution (ideal): Governed by Faraday's law.\n- Parasitic reaction: Irreversible side reaction current $i_s  0$ at the negative electrode, consuming cyclable lithium.\n- $i_s$ is assumed constant over the small $\\Delta\\theta$.\n- Current partitioning (charge): $i_s$ reduces the intercalation current available to change SOC.\n- Current partitioning (discharge): $i_s$ subtracts from the deintercalation current, reducing the current available to move SOC. (This statement is linguistically ambiguous, as will be addressed).\n- Coulombic Efficiency definition: $CE = Q_{\\text{out}}/Q_{\\text{in}}$.\n- Energy Efficiency definition: $EE = E_{\\text{out}}/E_{\\text{in}}$.\n- Average voltages: $\\overline{V}_{c}$ for charge, $\\overline{V}_{d}$ for discharge.\n- Hysteresis: Assumed negligible beyond the difference in average voltages.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, modeling a common degradation mechanism in batteries. It is well-posed and objective. A minor point of ambiguity exists in the description of current partitioning during discharge: \"$i_s$ ... subtracts from the deintercalation current during discharge (again reducing the current available to move SOC)\". A literal interpretation, suggesting the rate of SOC change is proportional to $-(I-i_s)$, would be physically incorrect, as the main reaction must supply *both* the external load ($I$) and the parasitic load ($i_s$). The physically correct model requires the deintercalation current to be $I+i_s$, making the rate of SOC change proportional to $-(I+i_s)$. The phrase \"reducing the current available to move SOC\" appears to be an error in wording. However, the overall problem structure and the forms of the equations proposed in the options strongly imply that the standard, physically correct model is intended. The problem is thus considered valid under this necessary clarification.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid and solvable, proceeding under the physically correct interpretation of current partitioning.\n\n**Derivation from First Principles**\n\nLet $\\theta$ be the state of charge, such that the total charge stored in the cell is $Q = \\theta Q_{\\max}$. The rate of change of stored charge is $\\frac{dQ}{dt} = Q_{\\max}\\frac{d\\theta}{dt}$. This rate is equal to the net current contributing to intercalation or deintercalation.\n\n**1. Charge Half-Cycle:**\nThe external current $I$ is applied. This current is split between the intercalation current $i_{int}$ which increases the SOC, and the parasitic side reaction current $i_s$.\n$$I = i_{int} + i_s$$\nThe current that changes the SOC is $i_{int} = I - i_s$. The SOC evolution is:\n$$Q_{\\max}\\frac{d\\theta}{dt} = I - i_s \\implies \\frac{d\\theta}{dt} = \\frac{I - i_s}{Q_{\\max}}$$\nThe charge half-cycle covers an SOC range of $\\Delta\\theta$. The time required, $t_c$, is:\n$$t_c = \\frac{\\Delta\\theta}{\\frac{d\\theta}{dt}} = \\frac{\\Delta\\theta Q_{\\max}}{I - i_s}$$\nThe total charge delivered by the tester is $Q_{in}$:\n$$Q_{in} = I \\cdot t_c = I \\frac{\\Delta\\theta Q_{\\max}}{I - i_s}$$\nThe energy delivered by the tester is $E_{in}$:\n$$E_{in} = Q_{in} \\overline{V}_{c} = \\left(I \\frac{\\Delta\\theta Q_{\\max}}{I - i_s}\\right) \\overline{V}_{c}$$\n\n**2. Discharge Half-Cycle:**\nThe external circuit draws a current $I$. The main deintercalation reaction must provide this current *plus* the current consumed by the continuous parasitic reaction, $i_s$. The total deintercalation current is $i_{deint} = I + i_s$. This current depletes the stored charge.\n$$Q_{\\max}\\frac{d\\theta}{dt} = -i_{deint} = -(I + i_s) \\implies \\frac{d\\theta}{dt} = -\\frac{I + i_s}{Q_{\\max}}$$\nThe discharge half-cycle also covers an SOC range of $\\Delta\\theta$. The time required, $t_d$, is:\n$$t_d = \\frac{\\Delta\\theta}{|\\frac{d\\theta}{dt}|} = \\frac{\\Delta\\theta Q_{\\max}}{I + i_s}$$\nThe total charge recovered by the tester is $Q_{out}$:\n$$Q_{out} = I \\cdot t_d = I \\frac{\\Delta\\theta Q_{\\max}}{I + i_s}$$\nThe energy recovered by the tester is $E_{out}$:\n$$E_{out} = Q_{out} \\overline{V}_{d} = \\left(I \\frac{\\Delta\\theta Q_{\\max}}{I + i_s}\\right) \\overline{V}_{d}$$\n\n**3. Calculation of CE, EE, and Inventory Loss**\nUsing the definitions provided:\n- **Coulombic Efficiency (CE):**\n$$CE = \\frac{Q_{out}}{Q_{in}} = \\frac{I \\frac{\\Delta\\theta Q_{\\max}}{I + i_s}}{I \\frac{\\Delta\\theta Q_{\\max}}{I - i_s}} = \\frac{I - i_s}{I + i_s}$$\n- **Energy Efficiency (EE):**\n$$EE = \\frac{E_{out}}{E_{in}} = \\frac{\\left(I \\frac{\\Delta\\theta Q_{\\max}}{I + i_s}\\right) \\overline{V}_{d}}{\\left(I \\frac{\\Delta\\theta Q_{\\max}}{I - i_s}\\right) \\overline{V}_{c}} = \\left(\\frac{\\overline{V}_{d}}{\\overline{V}_{c}}\\right) \\left(\\frac{I - i_s}{I + i_s}\\right) = CE \\cdot \\frac{\\overline{V}_{d}}{\\overline{V}_{c}}$$\n- **Cyclable Lithium Inventory Loss per Cycle ($Q_{loss}$):**\nThe parasitic reaction runs for the total cycle time $t_{cycle} = t_c + t_d$. The charge lost per cycle is:\n$$Q_{loss} = i_s \\cdot t_{cycle} = i_s (t_c + t_d) = i_s \\left(\\frac{\\Delta\\theta Q_{\\max}}{I - i_s} + \\frac{\\Delta\\theta Q_{\\max}}{I + i_s}\\right)$$\n$$Q_{loss} = i_s \\Delta\\theta Q_{\\max} \\left(\\frac{(I+i_s) + (I-i_s)}{(I-i_s)(I+i_s)}\\right) = i_s \\Delta\\theta Q_{\\max} \\frac{2I}{I^2 - i_s^2}$$\nThis $Q_{loss}$ represents the reduction in $Q_{\\max}$ for each cycle.\n\n**Option-by-Option Analysis**\n\n**A. Under symmetric cycling about mid SOC with small $\\Delta \\theta$ and constant $i_{s}$, the measured per-cycle Coulombic Efficiency is $CE = \\dfrac{I - i_{s}}{I + i_{s}}$, which approaches unity as $i_{s}/I \\to 0$, even though the cyclable lithium inventory decays continuously at a rate proportional to $i_{s}$.**\nThe derived formula for CE is indeed $CE = \\frac{I - i_s}{I + i_s}$.\nThe limit as $i_s/I \\to 0$ is $\\lim_{i_s/I \\to 0} \\frac{1-i_s/I}{1+i_s/I} = \\frac{1}{1} = 1$.\nThe inventory loss per cycle is $Q_{loss} = i_s \\cdot t_{cycle}$. Since $t_{cycle}  0$, the inventory decays continuously if $i_s  0$. The overall rate of loss is determined by $i_s$. This statement is fully consistent with the derivations.\nVerdict: **Correct**.\n\n**B. The measured per-cycle Coulombic Efficiency is $CE = 1 - \\dfrac{i_{s}}{I}$ and therefore exactly underestimates inventory loss by a factor of $\\dfrac{i_{s}}{I}$, independently of $\\Delta \\theta$.**\nThe derived formula is $CE = \\frac{I - i_s}{I + i_s}$. For small $x=i_s/I$, a Taylor expansion gives $\\frac{1-x}{1+x} \\approx (1-x)(1-x) \\approx 1-2x = 1-2\\frac{i_s}{I}$. The formula given in the option, $CE = 1 - \\frac{i_s}{I}$, is incorrect; it is off by a factor of approximately $2$ for small $i_s/I$. The rest of the statement is based on this false premise.\nVerdict: **Incorrect**.\n\n**C. Because the parasitic side reaction does not deliver power to the external circuit, Energy Efficiency equals Coulombic Efficiency under this protocol and is therefore unaffected by $i_{s}$.**\nThe derived relationship is $EE = CE \\cdot \\frac{\\overline{V}_{d}}{\\overline{V}_{c}}$. For any cell with non-zero internal resistance and operated at a non-zero current $I$, there will be overpotentials. Thus, the average charge voltage $\\overline{V}_{c}$ will be greater than the average discharge voltage $\\overline{V}_{d}$, making the voltage efficiency term $\\frac{\\overline{V}_{d}}{\\overline{V}_{c}}  1$. Therefore, $EE  CE$. The claim that $EE = CE$ is false. Furthermore, since $CE = \\frac{I - i_s}{I + i_s}$, both $CE$ and $EE$ are functions of $i_s$. The statement is incorrect on two counts.\nVerdict: **Incorrect**.\n\n**D. For small DoD windows, the total cyclable lithium loss per cycle scales linearly with $\\Delta \\theta$ via the total time spent in the window, thereby diminishing short-horizon observable capacity fade as $\\Delta \\theta$ decreases, even when $i_{s}0$.**\nThe loss per cycle is $Q_{loss} = i_s \\Delta\\theta Q_{\\max} \\frac{2I}{I^2 - i_s^2}$. For a given cell and test condition ($Q_{\\max}, I, i_s$ are params), $Q_{loss}$ is directly proportional to $\\Delta\\theta$. The total time per cycle, $t_{cycle} = \\Delta\\theta Q_{\\max} \\frac{2I}{I^2-i_s^2}$, is also proportional to $\\Delta\\theta$. As $\\Delta\\theta \\to 0$, $t_{cycle} \\to 0$ and consequently $Q_{loss} \\to 0$. This means the degradation *per cycle* becomes smaller for smaller cycling windows. This corresponds to diminishing observable capacity fade per cycle. The statement is fully consistent with the derived model.\nVerdict: **Correct**.\n\n**E. If $i_{s}$ is constant and $i_{s} \\ll I$, the apparent per-cycle capacity measured between fixed voltage limits remains exactly constant over repeated cycles, so capacity fade cannot occur under the protocol; only the mid-SOC open-circuit potential shifts over long times.**\nThis statement is flawed. The problem protocol is based on cycling between fixed SOC limits ($\\theta_0 \\pm \\Delta\\theta/2$), not fixed voltage limits. Even if the protocol were based on voltage limits, capacity fade ($Q_{max}$ reduction) would still occur as long as $i_s  0$. The statement \"capacity fade cannot occur\" is fundamentally incorrect. The apparent discharged capacity per cycle, $Q_{out} = I \\frac{\\Delta\\theta Q_{\\max}}{I + i_s}$, explicitly depends on $Q_{\\max}$. As $Q_{\\max}$ decreases from cycle to cycle due to $Q_{loss}$, $Q_{out}$ will also decrease. Therefore, apparent capacity does not remain constant.\nVerdict: **Incorrect**.\n\n**F. The per-cycle Energy Efficiency under the protocol is $EE = \\left(\\dfrac{\\overline{V}_{d}}{\\overline{V}_{c}}\\right)\\left(\\dfrac{I - i_{s}}{I + i_{s}}\\right)$, so in the limit of small overpotentials where $\\overline{V}_{d} \\approx \\overline{V}_{c}$ and $i_{s}/I \\ll 1$, both $CE$ and $EE$ are near unity while inventory still decays slowly and is detectable only over long horizons.**\nThe formula for EE, $EE = \\left(\\frac{\\overline{V}_{d}}{\\overline{V}_{c}}\\right)\\left(\\frac{I - i_s}{I + i_s}\\right)$, matches our derivation.\nIn the specified limit:\n- $\\overline{V}_{d} \\approx \\overline{V}_{c} \\implies \\frac{\\overline{V}_{d}}{\\overline{V}_{c}} \\approx 1$.\n- $i_s/I \\ll 1 \\implies CE = \\frac{I - i_s}{I + i_s} = \\frac{1-i_s/I}{1+i_s/I} \\approx 1$.\n- Combining these, $EE = \\left(\\frac{\\overline{V}_{d}}{\\overline{V}_{c}}\\right)CE \\approx 1 \\cdot 1 = 1$.\nSo, both $CE$ and $EE$ are near unity.\nInventory decay is governed by $Q_{loss} = i_s t_{cycle}$. For $i_s/I \\ll 1$, the fractional loss per cycle is $\\frac{Q_{loss}}{Q_{max}} = \\frac{2I i_s \\Delta\\theta}{I^2-i_s^2} \\approx 2\\Delta\\theta\\frac{i_s}{I}$. Since $i_s/I$ is small, the loss per cycle is small, meaning the decay is slow. Such slow decay typically requires many cycles (long horizons) to become a significant and easily measurable percentage of the total capacity. The statement is entirely consistent with the derivations.\nVerdict: **Correct**.",
            "answer": "$$\\boxed{ADF}$$"
        },
        {
            "introduction": "Moving from the analysis of a single cell to the design of a multi-cell system, this final practice challenges you to synthesize your understanding of efficiency into a practical control problem. Here, you will design an optimal charging and balancing strategy for a battery pack to maximize its overall round-trip energy efficiency ($\\eta_{\\text{RTE}}$). This exercise  requires you to formulate and solve a constrained optimization problem, integrating electrical behavior, thermal dynamics, and cell-to-cell variations. This task mirrors the complex, multi-objective design trade-offs faced by engineers developing advanced Battery Management Systems (BMS).",
            "id": "3902258",
            "problem": "You are tasked with developing, specifying, and implementing a control strategy that schedules charging current and per-cell balancing bypass to maximize pack round-trip energy efficiency under realistic constraints for an automated battery design and simulation context. The pack consists of series-connected cells, and the model must incorporate coulombic and energy efficiency as well as thermal limits. Your program must compute the optimal strategy on a discretized horizon and report the resulting round-trip energy efficiency as a decimal number for each test case.\n\nFundamental base to be used:\n- Energy conservation: the input electrical energy is $E_{\\text{in}} = \\int I(t) V_{\\text{pack}}(t) \\, dt$ and resistive heat follows Joule's law $P_{\\text{Joule}}(t) = I(t)^2 R_{\\text{pack}}$.\n- State of charge (SOC) change: for each cell $j$, the stored charge increment due to charging with coulombic efficiency is $\\Delta q_j = \\eta_{\\text{C}} \\int \\left(I(t) - b_j(t)\\right) \\, dt$, where $\\eta_{\\text{C}}$ is the Coulombic efficiency and $b_j(t)$ is the cell $j$ bypass current.\n- Thermal first-order lumped model: for each cell $j$, the temperature dynamics are $C_{\\text{th},j} \\frac{dT_j}{dt} = Q_{\\text{gen},j} - h_j \\left(T_j - T_{\\text{amb}}\\right)$, with heat generation $Q_{\\text{gen},j}(t) \\approx I(t)^2 R_j + b_j(t) V_{0,j}$.\n- Pack voltage approximation: adopt the widely used linear approximation $V_{\\text{pack}}(t) \\approx \\sum_{j=1}^{N} V_{0,j} + I(t) \\sum_{j=1}^{N} R_j$, where $V_{0,j}$ is a constant approximation of the open-circuit voltage over the operating window and $R_j$ is the internal resistance of cell $j$.\n\nDefinition of acronyms on first appearance:\n- Round-Trip Energy (RTE) efficiency: the fraction of energy recovered on discharge relative to energy input on charge. We denote it by $\\eta_{\\text{RTE}}$ and approximate it here by the ratio of useful stored energy to input energy, assuming near-unit discharge efficiency over the window of interest.\n- State of Charge (SOC): the fraction of cell capacity utilized, denoted by $s_j \\in [0,1]$ for cell $j$.\n- Coulombic Efficiency (CE): the fraction of charge that is effectively stored during charging, denoted by $\\eta_{\\text{C}}$.\n\nDiscretization and decision variables:\n- Consider $N$ series cells indexed by $j \\in \\{1,\\dots,N\\}$, and a discretized charging horizon with $K$ steps indexed by $k \\in \\{0,\\dots,K-1\\}$, each of duration $\\Delta t$.\n- Decision variables at each step $k$ are the pack charging current $I_k \\ge 0$ and per-cell bypass currents $b_{j,k} \\ge 0$, with the physical constraint $b_{j,k} \\le I_k$ (a cell cannot bypass more current than the series charging current).\n- SOC update for each cell $j$ is modeled as $s_{j,k+1} = s_{j,k} + \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j}\\left(I_k - b_{j,k}\\right)$, where $Q_j$ is the capacity of cell $j$ in $\\text{A}\\cdot\\text{s}$.\n- Temperature update for each cell $j$ is $T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right)$.\n\nObjective and constraints:\n- The input energy is $E_{\\text{in}} = \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right)$.\n- The useful stored energy (available for later discharge under the constant open-circuit voltage approximation) is $E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\, \\eta_{\\text{C}} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right)$.\n- The Round-Trip Energy efficiency is $\\eta_{\\text{RTE}} = \\frac{E_{\\text{stored}}}{E_{\\text{in}}}$.\n- To place the problem into a mathematically tractable form, maximize $\\eta_{\\text{RTE}}$ subject to target SOC equalization constraints. Equivalently, minimize $E_{\\text{in}}$ subject to the linear equality constraints $s_{j,K} = s_{\\text{target}}$ for all $j$, enforced by the SOC update model, and thermal inequality constraints $T_{j,k} \\le T_{\\max}$ for all $j,k$.\n\nYour program must:\n- Formulate and solve the discretized optimization described above using a numerical optimizer to obtain $\\{I_k\\}_{k=0}^{K-1}$ and $\\{b_{j,k}\\}_{j=1,k=0}^{N,K-1}$ that minimize $E_{\\text{in}}$ subject to all constraints.\n- Compute the resulting $\\eta_{\\text{RTE}}$ using the definitions above.\n- For physical units: currents in $\\text{A}$, voltages in $\\text{V}$, resistances in $\\Omega$, capacity in $\\text{A}\\cdot\\text{s}$, time in $\\text{s}$, temperatures in degrees Celsius.\n- Express each final result as a decimal number rounded to $6$ decimal digits.\n\nTest suite and parameters:\nProvide a test suite with three cases. For each case, pack size is $N=3$ cells in series. The parameters are:\n\n- Case $1$ (general feasible case):\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$, $R = [0.01, 0.01, 0.01]$ $\\Omega$, $V_0 = [3.70, 3.71, 3.69]$ $\\text{V}$.\n  - $s_0 = [0.30, 0.32, 0.28]$, $s_{\\text{target}} = 0.80$, $\\eta_{\\text{C}} = 0.995$.\n  - $T_0 = [25.0, 25.0, 25.0]$ $\\degree\\text{C}$, $T_{\\text{amb}} = 25.0$ $\\degree\\text{C}$, $T_{\\max} = 40.0$ $\\degree\\text{C}$.\n  - $C_{\\text{th}} = [12000, 12000, 12000]$ $\\text{J}/\\degree\\text{C}$, $h = [12, 12, 12]$ $\\text{W}/\\degree\\text{C}$.\n  - Horizon: $K=6$, $\\Delta t = 60$ $\\text{s}$, current bound $0 \\le I_k \\le 20$ $\\text{A}$.\n\n- Case $2$ (boundary temperature case):\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$, $R = [0.02, 0.02, 0.02]$ $\\Omega$, $V_0 = [3.65, 3.66, 3.64]$ $\\text{V}$.\n  - $s_0 = [0.40, 0.39, 0.41]$, $s_{\\text{target}} = 0.85$, $\\eta_{\\text{C}} = 0.992$.\n  - $T_0 = [35.0, 35.0, 35.0]$ $\\degree\\text{C}$, $T_{\\text{amb}} = 35.0$ $\\degree\\text{C}$, $T_{\\max} = 40.0$ $\\degree\\text{C}$.\n  - $C_{\\text{th}} = [9000, 9000, 9000]$ $\\text{J}/\\degree\\text{C}$, $h = [8, 8, 8]$ $\\text{W}/\\degree\\text{C}$.\n  - Horizon: $K=5$, $\\Delta t = 60$ $\\text{s}$, current bound $0 \\le I_k \\le 22$ $\\text{A}$.\n\n- Case $3$ (low Coulombic efficiency case):\n  - $Q = [10800, 10800, 10800]$ $\\text{A}\\cdot\\text{s}$, $R = [0.015, 0.015, 0.015]$ $\\Omega$, $V_0 = [3.68, 3.69, 3.67]$ $\\text{V}$.\n  - $s_0 = [0.20, 0.22, 0.18]$, $s_{\\text{target}} = 0.70$, $\\eta_{\\text{C}} = 0.970$.\n  - $T_0 = [20.0, 20.0, 20.0]$ $\\degree\\text{C}$, $T_{\\text{amb}} = 20.0$ $\\degree\\text{C}$, $T_{\\max} = 50.0$ $\\degree\\text{C}$.\n  - $C_{\\text{th}} = [15000, 15000, 15000]$ $\\text{J}/\\degree\\text{C}$, $h = [15, 15, 15]$ $\\text{W}/\\degree\\text{C}$.\n  - Horizon: $K=8$, $\\Delta t = 60$ $\\text{s}$, current bound $0 \\le I_k \\le 15$ $\\text{A}$.\n\nAnswer specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $\\left[ r_1, r_2, r_3 \\right]$, where $r_i$ is the optimized $\\eta_{\\text{RTE}}$ for case $i$, expressed as a decimal and rounded to $6$ decimal digits.",
            "solution": "The user has provided a scientifically sound and well-posed problem. The problem is validated as per the required criteria and a complete solution is provided below.\n\nThe task is to devise a charging strategy for a series-connected battery pack that maximizes the Round-Trip Energy (RTE) efficiency, denoted as $\\eta_{\\text{RTE}}$. This is achieved by controlling the pack charging current $I_k$ and the per-cell bypass currents $b_{j,k}$ over a discrete time horizon of $K$ steps. The strategy must adhere to physical constraints, including final State of Charge (SOC) targets and maximum cell temperatures.\n\nFirst, we formalize this as a mathematical optimization problem. The problem statement specifies that maximizing $\\eta_{\\text{RTE}} = E_{\\text{stored}}/E_{\\text{in}}$ is equivalent to minimizing the input energy $E_{\\text{in}}$ because the stored energy, $E_{\\text{stored}}$, is constant for any feasible solution. This holds because the final SOC for each cell is a fixed target, $s_{j,K} = s_{\\text{target}}$. The stored energy is given by:\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_{\\text{C}} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k - b_{j,k}\\right) $$\n\nFrom the SOC update equation, $s_{j,K} = s_{j,0} + \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j} \\sum_{k=0}^{K-1} (I_k - b_{j,k})$, we can substitute the term for the total charge transferred:\n\n$$ \\sum_{k=0}^{K-1} \\Delta t (I_k - b_{j,k}) = \\frac{Q_j (s_{j,K} - s_{j,0})}{\\eta_{\\text{C}}} $$\n\nSubstituting this into the expression for $E_{\\text{stored}}$ gives:\n\n$$ E_{\\text{stored}} = \\sum_{j=1}^{N} V_{0,j} \\eta_{\\text{C}} \\left( \\frac{Q_j (s_{\\text{target}} - s_{j,0})}{\\eta_{\\text{C}}} \\right) = \\sum_{j=1}^{N} V_{0,j} Q_j (s_{\\text{target}} - s_{j,0}) $$\n\nSince $V_{0,j}$, $Q_j$, $s_{\\text{target}}$, and $s_{j,0}$ are all fixed parameters for a given case, $E_{\\text{stored}}$ is a constant. Therefore, maximizing $\\eta_{\\text{RTE}}$ is indeed equivalent to minimizing the input energy $E_{\\text{in}}$.\n\nThe optimization problem can thus be stated as:\n\n**1. Decision Variables**\nThe variables to be optimized are the charging currents $I_k$ for each time step $k$ and the bypass currents $b_{j,k}$ for each cell $j$ at each time step $k$. We arrange these into a single vector $\\mathbf{x}$ of size $K(N+1)$:\n$$ \\mathbf{x} = [I_0, \\dots, I_{K-1}, b_{1,0}, \\dots, b_{1,K-1}, \\dots, b_{N,0}, \\dots, b_{N,K-1}] $$\n\n**2. Objective Function**\nThe objective is to minimize the total input energy $E_{\\text{in}}$, which is a function of the decision variables. The discretized form of $E_{\\text{in}}$ is:\n$$ \\min_{\\mathbf{x}} E_{\\text{in}}(\\mathbf{x}) = \\min_{I_k} \\sum_{k=0}^{K-1} \\Delta t \\left(I_k \\sum_{j=1}^{N} V_{0,j} + I_k^2 \\sum_{j=1}^{N} R_j\\right) $$\nThis is a quadratic function of the currents $I_k$.\n\n**3. Constraints**\nThe optimization is subject to several constraints derived from the physical model of the battery pack.\n\n- **Bounds on Variables**: The currents must be non-negative, and the charging current is limited by a maximum value $I_{\\max}$. The bypass current for a cell cannot exceed the pack current.\n    - $0 \\le I_k \\le I_{\\max}$ for $k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\ge 0$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n    - $b_{j,k} \\le I_k$ for $j \\in \\{1, \\dots, N\\}, k \\in \\{0, \\dots, K-1\\}$\n\n- **SOC Equality Constraints**: At the end of the horizon ($k=K$), the SOC of each cell $j$ must equal the target SOC, $s_{\\text{target}}$.\n    $$ s_{j,0} + \\sum_{k=0}^{K-1} \\frac{\\eta_{\\text{C}} \\Delta t}{Q_j} (I_k - b_{j,k}) = s_{\\text{target}} \\quad \\text{for } j \\in \\{1, \\dots, N\\} $$\n    These $N$ constraints are linear in the decision variables $I_k$ and $b_{j,k}$.\n\n- **Thermal Inequality Constraints**: The temperature of each cell $j$ must not exceed $T_{\\max}$ at any time step $k \\in \\{1, \\dots, K\\}$. The temperature $T_{j,k}$ is determined by the discrete-time thermal model:\n    $$ T_{j,k+1} = T_{j,k} + \\frac{\\Delta t}{C_{\\text{th},j}}\\left(I_k^2 R_j + b_{j,k} V_{0,j} - h_j \\left(T_{j,k} - T_{\\text{amb}}\\right)\\right) $$\n    This recurrence relation means that $T_{j,k}$ is a non-linear function of the decision variables $\\{I_m, b_{j,m}\\}$ for $m  k$. The $N \\times K$ constraints are therefore:\n    $$ T_{j,k}(\\mathbf{x}) \\le T_{\\max} \\quad \\text{for } j \\in \\{1, \\dots, N\\}, k \\in \\{1, \\dots, K\\} $$\n\n**Numerical Solution Strategy**\nThis problem is a Non-Linear Programming (NLP) problem, specifically a Quadratically Constrained Quadratic Program (QCQP) due to the nature of the objective function and thermal constraints. We will use the `minimize` function from the `scipy.optimize` library with the Sequential Least Squares Programming (`SLSQP`) algorithm, which is well-suited for such problems.\n\nThe implementation involves:\n1.  Defining Python functions that represent the objective function and each set of constraints. These functions take the decision variable vector $\\mathbf{x}$ as input.\n2.  The temperature at each time step is calculated iteratively within the constraint evaluation function.\n3.  The bounds and constraints are passed to the `minimize` function in the format it requires (a list of dictionaries for constraints).\n4.  A crucial step for successful convergence of numerical optimization is providing a good initial guess, $\\mathbf{x}_0$. We construct a guess based on the cell that requires the most charging. We calculate the average constant current needed for this cell (assuming no bypass) and then determine the necessary bypass currents for other cells to meet their targets. This provides a physically-motivated starting point close to the feasible region.\n5.  After the optimizer finds the optimal solution vector $\\mathbf{x}^*$, the minimum input energy $E_{\\text{in}}^*$ is the value of the objective function at this point.\n6.  The final Round-Trip Energy efficiency $\\eta_{\\text{RTE}}$ is computed as $\\eta_{\\text{RTE}} = E_{\\text{stored}} / E_{\\text{in}}^*$, where $E_{\\text{stored}}$ is the pre-calculated constant value. This result is then rounded to the required precision.\n\nThis structured approach translates the complex, multi-physics battery charging problem into a solvable numerical optimization task, yielding the optimal control strategy and the corresponding maximum achievable efficiency.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the optimization for each.\n    \"\"\"\n    # Case 1: General feasible case\n    case1 = {\n        'N': 3, 'K': 6, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.01, 0.01, 0.01]),\n        'V0': np.array([3.70, 3.71, 3.69]),\n        's0': np.array([0.30, 0.32, 0.28]),\n        's_target': 0.80,\n        'eta_C': 0.995,\n        'T0': np.array([25.0, 25.0, 25.0]),\n        'Tamb': 25.0,\n        'Tmax': 40.0,\n        'C_th': np.array([12000.0, 12000.0, 12000.0]),\n        'h': np.array([12.0, 12.0, 12.0]),\n        'I_max': 20.0\n    }\n\n    # Case 2: Boundary temperature case\n    case2 = {\n        'N': 3, 'K': 5, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.02, 0.02, 0.02]),\n        'V0': np.array([3.65, 3.66, 3.64]),\n        's0': np.array([0.40, 0.39, 0.41]),\n        's_target': 0.85,\n        'eta_C': 0.992,\n        'T0': np.array([35.0, 35.0, 35.0]),\n        'Tamb': 35.0,\n        'Tmax': 40.0,\n        'C_th': np.array([9000.0, 9000.0, 9000.0]),\n        'h': np.array([8.0, 8.0, 8.0]),\n        'I_max': 22.0\n    }\n\n    # Case 3: Low Coulombic efficiency case\n    case3 = {\n        'N': 3, 'K': 8, 'dt': 60.0,\n        'Q': np.array([10800.0, 10800.0, 10800.0]),\n        'R': np.array([0.015, 0.015, 0.015]),\n        'V0': np.array([3.68, 3.69, 3.67]),\n        's0': np.array([0.20, 0.22, 0.18]),\n        's_target': 0.70,\n        'eta_C': 0.970,\n        'T0': np.array([20.0, 20.0, 20.0]),\n        'Tamb': 20.0,\n        'Tmax': 50.0,\n        'C_th': np.array([15000.0, 15000.0, 15000.0]),\n        'h': np.array([15.0, 15.0, 15.0]),\n        'I_max': 15.0\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for params in test_cases:\n        result_rte = run_optimization_case(params)\n        results.append(f\"{result_rte:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_optimization_case(params):\n    \"\"\"\n    Sets up and solves the optimization problem for a single test case.\n    \"\"\"\n    N, K, dt = params['N'], params['K'], params['dt']\n    Q, R, V0 = params['Q'], params['R'], params['V0']\n    s0, s_target, eta_C = params['s0'], params['s_target'], params['eta_C']\n    T0, Tamb, Tmax = params['T0'], params['Tamb'], params['Tmax']\n    C_th, h = params['C_th'], params['h']\n    I_max = params['I_max']\n\n    V0_sum = np.sum(V0)\n    R_sum = np.sum(R)\n    \n    num_vars = K * (N + 1)\n\n    # Objective function: Minimize Ein\n    def objective_function(x):\n        I_vars = x[:K]\n        return dt * np.sum(I_vars * V0_sum + I_vars**2 * R_sum)\n\n    # Helper to calculate temperatures\n    def calculate_temperatures(x):\n        I_vars = x[:K]\n        b_vars = x[K:].reshape((N, K))\n        T = np.zeros((N, K + 1))\n        T[:, 0] = T0\n        for k in range(K):\n            Q_gen_k = I_vars[k]**2 * R + b_vars[:, k] * V0\n            T_dot_k = (Q_gen_k - h * (T[:, k] - Tamb)) / C_th\n            T[:, k + 1] = T[:, k] + T_dot_k * dt\n        return T\n\n    # Constraints\n    constraints = []\n\n    # 1. SOC equality constraints: s_j,K = s_target\n    soc_target_charge_integral = Q * (s_target - s0) / (eta_C * dt)\n    for j in range(N):\n        def soc_constraint(x, j=j):\n            I_vars = x[:K]\n            b_j_vars = x[K + j * K : K + (j + 1) * K]\n            return np.sum(I_vars - b_j_vars) - soc_target_charge_integral[j]\n        constraints.append({'type': 'eq', 'fun': soc_constraint})\n\n    # 2. Bypass current inequality: b_j,k = I_k  (or I_k - b_j,k = 0)\n    for j in range(N):\n        for k in range(K):\n            def bypass_constraint(x, j=j, k=k):\n                return x[k] - x[K + j * K + k]\n            constraints.append({'type': 'ineq', 'fun': bypass_constraint})\n            \n    # 3. Temperature inequality: T_j,k = Tmax (or Tmax - T_j,k = 0)\n    def temp_constraints(x):\n        temps = calculate_temperatures(x)\n        # Constraints on T_j,k for k=1...K\n        return (Tmax - temps[:, 1:]).flatten()\n    constraints.append({'type': 'ineq', 'fun': temp_constraints})\n\n    # Bounds for decision variables\n    bounds_I = [(0, I_max)] * K\n    bounds_b = [(0, None)] * (N * K) # b_jk = 0, b_jk = I_k is a separate constraint\n    bounds = bounds_I + bounds_b\n\n    # Initial guess (x0)\n    delta_s = s_target - s0\n    j_star = np.argmax(delta_s)\n    \n    required_charge_integral_star = Q[j_star] * delta_s[j_star] / (eta_C * dt)\n    I_const = np.clip(required_charge_integral_star / K, 0, I_max)\n    \n    x0_I = np.full(K, I_const)\n    x0_b = np.zeros((N, K))\n\n    total_I_integral = K * I_const\n    for j in range(N):\n        if j != j_star:\n            required_charge_integral_j = Q[j] * delta_s[j] / (eta_C * dt)\n            total_bypass_j = total_I_integral - required_charge_integral_j\n            if total_bypass_j  0:\n                x0_b[j, :] = total_bypass_j / K\n    \n    x0 = np.concatenate([x0_I, x0_b.flatten()])\n    \n    # Run optimization\n    result = minimize(objective_function, x0, method='SLSQP', bounds=bounds, constraints=constraints)\n\n    if not result.success:\n        # Fallback to simpler guess if smart guess was problematic\n        x0_simple = np.full(num_vars, 1e-3)\n        result = minimize(objective_function, x0_simple, method='SLSQP', bounds=bounds, constraints=constraints)\n        if not result.success: # Raise if still fails\n             raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n\n    # Calculate final RTE_efficiency\n    E_in_opt = result.fun\n    E_stored = np.sum(V0 * Q * (s_target - s0))\n    eta_RTE = E_stored / E_in_opt\n    \n    return eta_RTE\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}