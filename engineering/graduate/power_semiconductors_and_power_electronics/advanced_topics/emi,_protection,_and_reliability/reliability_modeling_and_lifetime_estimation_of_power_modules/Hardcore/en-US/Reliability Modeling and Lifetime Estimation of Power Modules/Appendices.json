{
    "hands_on_practices": [
        {
            "introduction": "The foundation of any power module reliability assessment is a thorough understanding of its thermal behavior. The junction temperature $T_j$, which is a direct consequence of power dissipation, is the primary driver of most degradation mechanisms. This practice will allow you to apply the concept of transient thermal impedance $Z_{th,JC}(t)$, often represented by a Foster network, to calculate the junction temperature response to a power step, a fundamental skill for thermal characterization and simulation .",
            "id": "3873421",
            "problem": "A power module die mounted on a cold plate is subjected to a step of dissipated power at the silicon junction. The heat flow path from the junction to the case behaves as a linear, time-invariant thermal network over the operating range of interest, and the case is maintained isothermal by the cold plate. The measured junction-to-case transient thermal impedance, defined as the junction-to-case temperature rise per unit step of power, is captured by a three-term Foster representation consistent with a diffusive multilayer heat-flow path.\n\nAt time $t=0^{+}$, a constant power $P=100~\\mathrm{W}$ is applied at the junction. The case temperature is held constant at $T_{c}=60\\,^{\\circ}\\mathrm{C}$. The measured junction-to-case transient thermal impedance is\n$$\nZ_{th,JC}(t)=\\sum_{i=1}^{3} R_{i}\\left(1-\\exp\\!\\left(-\\frac{t}{\\tau_{i}}\\right)\\right),\n$$\nwith parameters\n$$\nR_{1}=0.06~\\mathrm{K/W},\\quad \\tau_{1}=0.012~\\mathrm{s},\\quad R_{2}=0.09~\\mathrm{K/W},\\quad \\tau_{2}=0.18~\\mathrm{s},\\quad R_{3}=0.08~\\mathrm{K/W},\\quad \\tau_{3}=6.0~\\mathrm{s}.\n$$\n\nUsing only the assumptions of linearity and time invariance of the junction-to-case thermal network and the definition of transient thermal impedance as the step response of junction-to-case temperature rise per unit power, derive the closed-form expression of the junction temperature $T_{j}(t)$ for $t\\ge 0$ and compute the steady-state junction-to-case thermal resistance $R_{th,JC}$.\n\nExpress $T_{j}(t)$ in $^{\\circ}\\mathrm{C}$ (with $t$ in $\\mathrm{s}$) and $R_{th,JC}$ in $\\mathrm{K/W}$. Round $R_{th,JC}$ to three significant figures. The final answer must be provided as a single row matrix whose first entry is the closed-form expression for $T_{j}(t)$ and whose second entry is the rounded value of $R_{th,JC}$.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n### Step 1: Extract Givens\n- **System**: A power module's thermal path from junction to case is a linear, time-invariant (LTI) network.\n- **Power Input**: A constant power step $P = 100~\\mathrm{W}$ is applied at the junction for $t \\ge 0$.\n- **Boundary Condition**: The case temperature is constant, $T_{c} = 60\\,^{\\circ}\\mathrm{C}$.\n- **Transient Thermal Impedance**: The junction-to-case transient thermal impedance, defined as the junction-to-case temperature rise per unit step of power, is given by a three-term Foster model:\n$$Z_{th,JC}(t) = \\sum_{i=1}^{3} R_{i}\\left(1-\\exp\\left(-\\frac{t}{\\tau_{i}}\\right)\\right)$$\n- **Parameters**:\n  - $R_{1} = 0.06~\\mathrm{K/W}$, $\\tau_{1} = 0.012~\\mathrm{s}$\n  - $R_{2} = 0.09~\\mathrm{K/W}$, $\\tau_{2} = 0.18~\\mathrm{s}$\n  - $R_{3} = 0.08~\\mathrm{K/W}$, $\\tau_{3} = 6.0~\\mathrm{s}$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as it employs the standard LTI system theory and the Foster network model, which are fundamental and widely accepted tools for thermal analysis in power electronics. The provided numerical values for thermal resistances and time constants are physically realistic for a power module. The problem is well-posed, providing all necessary information and clear definitions to arrive at a unique solution. The language is objective and free of ambiguity. The problem is self-contained and internally consistent. Therefore, the problem is deemed valid.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete solution will be provided.\n\n### Solution Derivation\n\nThe junction temperature $T_j(t)$ is the sum of the constant case temperature $T_c$ and the time-dependent junction-to-case temperature rise, $\\Delta T_{JC}(t)$.\n$$T_{j}(t) = T_{c} + \\Delta T_{JC}(t)$$\nThe problem states that the junction-to-case thermal network is linear and time-invariant (LTI). The transient thermal impedance, $Z_{th,JC}(t)$, is defined as the system's response (junction-to-case temperature rise) to a unit step power input. For a general power step input of magnitude $P$ applied at $t=0$, the principle of superposition for LTI systems dictates that the temperature rise response is the unit step response scaled by the magnitude of the power step.\n$$\\Delta T_{JC}(t) = P \\cdot Z_{th,JC}(t)$$\nCombining these two equations gives the expression for the junction temperature:\n$$T_{j}(t) = T_{c} + P \\cdot Z_{th,JC}(t)$$\nSubstituting the given expression for $Z_{th,JC}(t)$:\n$$T_{j}(t) = T_{c} + P \\sum_{i=1}^{3} R_{i}\\left(1-\\exp\\left(-\\frac{t}{\\tau_{i}}\\right)\\right)$$\nNow, we substitute the provided numerical values: $P = 100~\\mathrm{W}$, $T_c = 60\\,^{\\circ}\\mathrm{C}$, and the sets of $(R_i, \\tau_i)$. Note that a temperature difference in Kelvin ($\\mathrm{K}$) is equivalent to a temperature difference in degrees Celsius ($^{\\circ}\\mathrm{C}$), so the units are consistent.\n$$T_{j}(t) = 60 + 100 \\left[ 0.06\\left(1-\\exp\\left(-\\frac{t}{0.012}\\right)\\right) + 0.09\\left(1-\\exp\\left(-\\frac{t}{0.18}\\right)\\right) + 0.08\\left(1-\\exp\\left(-\\frac{t}{6.0}\\right)\\right) \\right]$$\nWe can distribute the power value $P=100$ into the sum:\n$$T_{j}(t) = 60 + 100 \\cdot 0.06\\left(1-\\exp\\left(-\\frac{t}{0.012}\\right)\\right) + 100 \\cdot 0.09\\left(1-\\exp\\left(-\\frac{t}{0.18}\\right)\\right) + 100 \\cdot 0.08\\left(1-\\exp\\left(-\\frac{t}{6.0}\\right)\\right)$$\n$$T_{j}(t) = 60 + 6\\left(1-\\exp\\left(-\\frac{t}{0.012}\\right)\\right) + 9\\left(1-\\exp\\left(-\\frac{t}{0.18}\\right)\\right) + 8\\left(1-\\exp\\left(-\\frac{t}{6.0}\\right)\\right)$$\nExpanding and grouping the constant and time-dependent terms:\n$$T_{j}(t) = 60 + 6 + 9 + 8 - 6\\exp\\left(-\\frac{t}{0.012}\\right) - 9\\exp\\left(-\\frac{t}{0.18}\\right) - 8\\exp\\left(-\\frac{t}{6.0}\\right)$$\n$$T_{j}(t) = 83 - 6\\exp\\left(-\\frac{t}{0.012}\\right) - 9\\exp\\left(-\\frac{t}{0.18}\\right) - 8\\exp\\left(-\\frac{t}{6.0}\\right)$$\nThis is the closed-form expression for the junction temperature $T_{j}(t)$ in $^{\\circ}\\mathrm{C}$ for $t \\ge 0$.\n\nNext, we compute the steady-state junction-to-case thermal resistance, $R_{th,JC}$. By definition, this is the value of the transient thermal impedance as time approaches infinity:\n$$R_{th,JC} = \\lim_{t \\to \\infty} Z_{th,JC}(t)$$\nApplying this limit to the Foster representation:\n$$R_{th,JC} = \\lim_{t \\to \\infty} \\sum_{i=1}^{3} R_{i}\\left(1-\\exp\\left(-\\frac{t}{\\tau_{i}}\\right)\\right)$$\nSince all time constants $\\tau_i$ are positive, the exponential term $\\exp(-t/\\tau_i)$ approaches $0$ as $t \\to \\infty$.\n$$R_{th,JC} = \\sum_{i=1}^{3} R_{i} \\left(1-0\\right) = \\sum_{i=1}^{3} R_{i}$$\nSubstituting the given resistance values:\n$$R_{th,JC} = R_{1} + R_{2} + R_{3} = 0.06 + 0.09 + 0.08 = 0.23~\\mathrm{K/W}$$\nThe problem requires this value to be rounded to three significant figures.\n$$R_{th,JC} = 0.230~\\mathrm{K/W}$$\n\nThe two requested results are the expression for $T_j(t)$ and the numerical value of $R_{th,JC}$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 83 - 6\\exp\\left(-\\frac{t}{0.012}\\right) - 9\\exp\\left(-\\frac{t}{0.18}\\right) - 8\\exp\\left(-\\frac{t}{6.0}\\right)  0.230 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Once the thermal environment is characterized, we can predict lifetime using physics-based models. These models typically depend on both the magnitude of temperature swings ($\\Delta T_j$) and the mean temperature ($T_{j,mean}$). This exercise isolates the critical influence of mean temperature, demonstrating how the Arrhenius relationship leads to a powerful, exponential acceleration of damage at higher operating temperatures, even when the cyclic swing is held constant .",
            "id": "3873422",
            "problem": "A wire-bonded Insulated Gate Bipolar Transistor (IGBT) power module is evaluated under two cyclic thermal stress profiles intended to excite the same dominant thermomechanical fatigue mechanism in the interconnect system. In both profiles, the temperature swing amplitude is the same, but the mean temperature differs:\n\n- Profile 1 (power cycling): junction temperature excursions of amplitude $\\Delta T_j = 50\\,\\mathrm{K}$ about a mean junction temperature $T_{j,\\mathrm{mean}} = 100\\,^{\\circ}\\mathrm{C}$.\n- Profile 2 (temperature cycling): controlled ambient or case temperature excursions of amplitude $\\Delta T = 50\\,\\mathrm{K}$ about a mean temperature $T_{\\mathrm{mean}} = 60\\,^{\\circ}\\mathrm{C}$.\n\nAssume the following scientifically grounded conditions:\n- The cyclic plastic strain range that drives fatigue is primarily governed by the temperature swing amplitude, so the amplitude-dependent component of per-cycle damage is identical in the two profiles because $\\Delta T$ is the same.\n- The rate of the underlying microstructural degradation process that modulates per-cycle damage (for example, creep-assisted crack growth or intermetallic diffusion) is thermally activated and follows an Arrhenius-type temperature dependence characterized by an activation energy $E_a$; thus, the rate increases with higher mean temperature.\n- Cycles to failure $N_f$ scale inversely with the per-cycle damage rate of the thermally activated process (i.e., when the process rate doubles, the expected $N_f$ halves), and the cycle period and dwell times are comparable in the two profiles so that frequency effects do not confound the comparison.\n\nUse a representative activation energy $E_a = 0.7\\,\\mathrm{eV}$ for the dominant damage mechanism and the Boltzmann constant $k_B = 8.617 \\times 10^{-5}\\,\\mathrm{eV/K}$. Based solely on the role of mean temperature in thermally activated damage laws, which statement best approximates the expected ratio of lifetimes in cycles for Profile 2 relative to Profile 1?\n\nA. Profile 2 (mean $60\\,^{\\circ}\\mathrm{C}$) yields approximately $14\\times$ more cycles to failure than Profile 1 (mean $100\\,^{\\circ}\\mathrm{C}$).\n\nB. The lifetimes are approximately equal because the temperature swing $\\Delta T$ is the same.\n\nC. Profile 2 yields only about $1.4\\times$ more cycles to failure than Profile 1.\n\nD. Profile 1 yields longer life by roughly an order of magnitude because higher mean junction temperature reduces cyclic thermal gradients.",
            "solution": "The problem statement will first be validated for scientific soundness, completeness, and objectivity before a solution is attempted.\n\n### Step 1: Extract Givens\nVerbatim extraction of the provided information:\n-   **Device:** Wire-bonded Insulated Gate Bipolar Transistor (IGBT) power module.\n-   **Fatigue Mechanism:** The same dominant thermomechanical fatigue mechanism is excited in both test profiles.\n-   **Profile 1 (power cycling):**\n    -   Junction temperature swing amplitude: $\\Delta T_j = 50\\,\\mathrm{K}$.\n    -   Mean junction temperature: $T_{j,\\mathrm{mean}} = 100\\,^{\\circ}\\mathrm{C}$.\n-   **Profile 2 (temperature cycling):**\n    -   Temperature swing amplitude: $\\Delta T = 50\\,\\mathrm{K}$.\n    -   Mean temperature: $T_{\\mathrm{mean}} = 60\\,^{\\circ}\\mathrm{C}$.\n-   **Assumptions:**\n    1.  The cyclic plastic strain range is primarily governed by the temperature swing amplitude. The amplitude-dependent component of per-cycle damage is identical for both profiles.\n    2.  The rate of the underlying microstructural degradation process is thermally activated and follows an Arrhenius-type temperature dependence with activation energy $E_a$.\n    3.  Cycles to failure, $N_f$, scale inversely with the per-cycle damage rate of this thermally activated process.\n    4.  Cycle period and dwell times are comparable, ruling out frequency effects.\n-   **Constants:**\n    -   Activation energy: $E_a = 0.7\\,\\mathrm{eV}$.\n    -   Boltzmann constant: $k_B = 8.617 \\times 10^{-5}\\,\\mathrm{eV/K}$.\n-   **Question:** Determine the approximate ratio of lifetimes in cycles for Profile 2 ($N_{f,2}$) relative to Profile 1 ($N_{f,1}$), i.e., $N_{f,2} / N_{f,1}$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded:** The problem is firmly grounded in the field of reliability physics for power electronics. The concepts of thermomechanical fatigue, temperature swing ($\\Delta T$), mean temperature ($T_{\\mathrm{mean}}$), and their influence on device lifetime are central to this field. The use of an Arrhenius model to describe the temperature dependence of degradation mechanisms (e.g., creep, intermetallic compound growth, diffusion) is a standard and well-established scientific practice. An activation energy of $E_a = 0.7\\,\\mathrm{eV}$ is a realistic value for such processes in electronic assemblies.\n2.  **Well-Posed:** The problem is well-posed. It provides all necessary data ($T_{j,\\mathrm{mean},1}$, $T_{\\mathrm{mean},2}$, $E_a$, $k_B$) and a clear set of assumptions that define a formalizable physical model. The question asks for a specific, calculable ratio, for which a unique solution exists based on the provided model.\n3.  **Objective:** The problem is stated in precise, objective, and technical language. It makes explicit assumptions to isolate the specific physical effect under investigation (the role of mean temperature), avoiding ambiguity.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. It is scientifically sound, well-posed, and objective. I will proceed with the derivation of the solution.\n\n### Solution Derivation\n\nThe problem states that the number of cycles to failure, $N_f$, is inversely proportional to the rate of a thermally activated degradation process. Let this rate be denoted by $R$.\n$$ N_f \\propto \\frac{1}{R} $$\nThe rate $R$ of a thermally activated process is described by the Arrhenius equation:\n$$ R = A \\exp\\left(-\\frac{E_a}{k_B T}\\right) $$\nwhere $A$ is a pre-exponential factor, $E_a$ is the activation energy, $k_B$ is the Boltzmann constant, and $T$ is the absolute temperature. The problem specifies that the mean temperature of the cycle is the relevant temperature governing this rate.\n\nCombining these two relations, the lifetime $N_f$ is proportional to the reciprocal of the Arrhenius rate factor:\n$$ N_f \\propto \\frac{1}{\\exp\\left(-\\frac{E_a}{k_B T}\\right)} = \\exp\\left(\\frac{E_a}{k_B T}\\right) $$\nThe constant of proportionality would depend on factors like the temperature swing amplitude $\\Delta T$, which is stated to be the same for both profiles. Therefore, this constant will cancel out when we take the ratio of lifetimes.\n\nLet $N_{f,1}$ and $T_1$ be the lifetime and mean absolute temperature for Profile 1, and $N_{f,2}$ and $T_2$ be the corresponding values for Profile 2.\n\nThe mean temperatures must be converted to the absolute scale (Kelvin):\n-   Profile 1: $T_1 = 100\\,^{\\circ}\\mathrm{C} + 273.15 = 373.15\\,\\mathrm{K}$\n-   Profile 2: $T_2 = 60\\,^{\\circ}\\mathrm{C} + 273.15 = 333.15\\,\\mathrm{K}$\n\nThe ratio of the lifetimes, $N_{f,2} / N_{f,1}$, can be expressed as:\n$$ \\frac{N_{f,2}}{N_{f,1}} = \\frac{\\exp\\left(\\frac{E_a}{k_B T_2}\\right)}{\\exp\\left(\\frac{E_a}{k_B T_1}\\right)} $$\nUsing the property of exponents, $\\exp(a)/\\exp(b) = \\exp(a-b)$:\n$$ \\frac{N_{f,2}}{N_{f,1}} = \\exp\\left(\\frac{E_a}{k_B T_2} - \\frac{E_a}{k_B T_1}\\right) = \\exp\\left[ \\frac{E_a}{k_B} \\left( \\frac{1}{T_2} - \\frac{1}{T_1} \\right) \\right] $$\nNow, we substitute the given values:\n-   $E_a = 0.7\\,\\mathrm{eV}$\n-   $k_B = 8.617 \\times 10^{-5}\\,\\mathrm{eV/K}$\n-   $T_1 = 373.15\\,\\mathrm{K}$\n-   $T_2 = 333.15\\,\\mathrm{K}$\n\nFirst, calculate the term $E_a/k_B$:\n$$ \\frac{E_a}{k_B} = \\frac{0.7\\,\\mathrm{eV}}{8.617 \\times 10^{-5}\\,\\mathrm{eV/K}} \\approx 8123.48\\,\\mathrm{K} $$\nNext, calculate the temperature term:\n$$ \\frac{1}{T_2} - \\frac{1}{T_1} = \\frac{1}{333.15\\,\\mathrm{K}} - \\frac{1}{373.15\\,\\mathrm{K}} \\approx (0.00300165 - 0.00267989)\\,\\mathrm{K}^{-1} \\approx 0.00032176\\,\\mathrm{K}^{-1} $$\nNow, compute the exponent:\n$$ \\text{Exponent} = \\left( \\frac{E_a}{k_B} \\right) \\left( \\frac{1}{T_2} - \\frac{1}{T_1} \\right) \\approx (8123.48\\,\\mathrm{K}) \\times (0.00032176\\,\\mathrm{K}^{-1}) \\approx 2.6142 $$\nFinally, calculate the ratio:\n$$ \\frac{N_{f,2}}{N_{f,1}} = \\exp(2.6142) \\approx 13.656 $$\nThus, Profile 2 is expected to yield approximately $13.7$ times more cycles to failure than Profile 1.\n\n### Option-by-Option Analysis\n\n**A. Profile 2 (mean $60\\,^{\\circ}\\mathrm{C}$) yields approximately $14\\times$ more cycles to failure than Profile 1 (mean $100\\,^{\\circ}\\mathrm{C}$).**\nOur calculation resulted in a lifetime ratio of approximately $13.7$. The value $14$ is a reasonable approximation of this result. The physical reasoning is correct: the lower mean temperature of Profile 2 leads to a significantly slower rate of the thermally activated degradation process, thus resulting in a much longer lifetime.\n**Verdict: Correct**\n\n**B. The lifetimes are approximately equal because the temperature swing $\\Delta T$ is the same.**\nThis statement is incorrect. It ignores the explicit premise that a thermally activated process, dependent on mean temperature, modulates the damage per cycle. While $\\Delta T$ is a primary driver of fatigue (the amplitude-dependent component), the problem clearly states that the mean temperature also plays a critical role via an Arrhenius relationship. This option contradicts the problem's setup.\n**Verdict: Incorrect**\n\n**C. Profile 2 yields only about $1.4\\times$ more cycles to failure than Profile 1.**\nThis is a quantitative error. Our calculation shows the factor is close to $14$, not $1.4$. A factor of $1.4$ would correspond to $\\ln(1.4) \\approx 0.336$ for the exponent, which would imply a much smaller activation energy (around $E_a \\approx 0.09\\ \\mathrm{eV}$) or a much smaller difference in mean temperatures.\n**Verdict: Incorrect**\n\n**D. Profile 1 yields longer life by roughly an order of magnitude because higher mean junction temperature reduces cyclic thermal gradients.**\nThis statement is incorrect on two counts. First, it claims Profile 1 (higher mean temperature) has a longer life, which is the opposite of the prediction from the Arrhenius model. Higher temperatures accelerate degradation, leading to shorter lifetimes. Second, the provided reasoning that \"higher mean junction temperature reduces cyclic thermal gradients\" is physically unfounded and contradicts the problem's givens, which state that the temperature swing amplitude ($\\Delta T$), the driver of cyclic gradients, is the same for both profiles.\n**Verdict: Incorrect**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Real-world power converters rarely experience simple, uniform thermal cycles; instead, they follow complex \"mission profiles\" with varying load and ambient conditions. To assess reliability in such scenarios, we must dissect an arbitrary temperature waveform into a set of equivalent stress cycles. This capstone practice guides you through the implementation of a complete analysis pipeline, combining the industry-standard rainflow counting algorithm with the Palmgren–Miner rule to compute a cumulative damage index from a raw temperature signal .",
            "id": "3873435",
            "problem": "A waveform of the junction temperature $T_j(t)$ of a power semiconductor module is recorded over $10$ hours at a sampling rate of $1$ Hz, producing $36000$ samples in Kelvin. Consider a cycle-based thermo-mechanical fatigue model for solder layers and interconnects where cumulative damage is assessed by combining rainflow counting and the Palmgren–Miner linear damage hypothesis. The task is to implement, from first principles, an algorithm that transforms the sampled waveform into a cycle set and computes a dimensionless damage index.\n\nFundamental base:\n- Define local extrema and turning points on a sampled signal $x_i = T_j(t_i)$, where $t_i$ is uniform with $\\Delta t = 1\\,\\mathrm{s}$. A turning point is a sample $x_i$ that is either a local maximum or a local minimum when considering immediate neighboring samples, after eliminating consecutive duplicates.\n- Utilize the American Society for Testing and Materials (ASTM) standard E1049-85 (ASTM) conceptual procedure for rainflow counting: interpret the sequence of turning points and identify closed cycles by comparing adjacent ranges, and attribute half cycles to residual ranges at the sequence ends.\n- Use the Palmgren–Miner linear damage hypothesis, which states that cumulative damage $D$ is the sum over counted cycles of the fraction of consumed life $n_k / N(\\Delta T_{j,k}, T_{\\text{mean},k})$, where each cycle has amplitude $\\Delta T_{j,k}$, mean temperature $T_{\\text{mean},k}$, and count $n_k$ equal to $1$ for closed (full) cycles and $1/2$ for residual (half) cycles.\n- Employ a widely used thermo-mechanical life model of the form\n$$\nN(\\Delta T, T_{\\text{mean}}) = A \\, (\\Delta T)^{-b} \\, \\exp\\!\\left(\\frac{E_a}{k_B \\, T_{\\text{mean}}}\\right),\n$$\nwhere $A$ is a positive calibration constant (cycles), $b$ is a positive exponent, $E_a$ is the activation energy in electronvolts, and $k_B$ is the Boltzmann constant in electronvolts per Kelvin. All temperatures must be in Kelvin. The damage $D$ is dimensionless.\n\nProgram requirements:\n- Derive and implement an algorithm that:\n  1. Extracts turning points from $T_j(t)$ by removing consecutive duplicates and selecting samples where the discrete slope changes sign.\n  2. Performs rainflow counting by iteratively applying a closure criterion on the last four turning points to identify closed cycles and by assigning half cycles to remaining adjacent ranges after the traversal. For each identified cycle, compute the cycle amplitude $\\Delta T_{j,k}$ as the absolute difference of the two reversal levels and the cycle mean temperature $T_{\\text{mean},k}$ as the arithmetic mean of the two reversal levels.\n  3. Computes cumulative damage\n  $$\n  D = \\sum_{k} \\frac{n_k}{N(\\Delta T_{j,k}, T_{\\text{mean},k})}\n  $$\n  using the provided $N(\\cdot)$ relationship. Ignore cycles with $\\Delta T_{j,k} = 0$.\n- Use $k_B = 8.617333262145 \\times 10^{-5}$ electronvolts per Kelvin.\n- Ensure all temperatures are in Kelvin, activation energy $E_a$ in electronvolts, and $A$ in cycles. The output damage $D$ must be dimensionless.\n\nTest suite:\nImplement the algorithm and evaluate the cumulative damage $D$ for the following five test cases. Each case uses $A = 5 \\times 10^{8}$ cycles, $b = 5.5$, and $E_a = 0.35\\,\\mathrm{eV}$.\n- Case $1$ (happy path, nested cycling): $T_j(t) = 375 + 40 \\sin(2\\pi t/600) + 10 \\sin(2\\pi t/150)$ for $t = 0,1,\\dots,35999$ seconds.\n- Case $2$ (boundary, no cycling): $T_j(t) = 350$ for all $t$.\n- Case $3$ (edge, two half cycles): A piecewise linear ramp up and down over $10$ hours: for $t = 0,\\dots,17999$, linearly ramp from $350\\,\\mathrm{K}$ to $400\\,\\mathrm{K}$; for $t = 18000,\\dots,35999$, linearly ramp from $400\\,\\mathrm{K}$ to $360\\,\\mathrm{K}$.\n- Case $4$ (low-amplitude stochastic cycling): Let a zero-mean Gaussian white noise $\\eta(t)$ be generated with a fixed seed and low-pass filtered by a moving average of window $60\\,\\mathrm{s}$. Define $T_j(t) = 370 + 2 \\, \\eta_{\\text{LP}}(t)$ for $t = 0,1,\\dots,35999$.\n- Case $5$ (Arrhenius sensitivity with higher mean): $T_j(t) = 420 + 40 \\sin(2\\pi t/600) + 10 \\sin(2\\pi t/150)$ for $t = 0,1,\\dots,35999$ seconds.\n\nFinal output format:\n- Your program should produce a single line of output containing the damage results for the five cases as a comma-separated list of floating-point numbers enclosed in square brackets, in the order of Cases $1$ through $5$, for example, $[d_1,d_2,d_3,d_4,d_5]$. The output values must be dimensionless and represented as Python floating-point literals.",
            "solution": "The problem requires the implementation of a standard thermo-mechanical fatigue analysis for a power semiconductor module. The analysis is based on a recorded junction temperature waveform, $T_j(t)$. The cumulative damage is quantified using a well-established procedure involving three main steps: extraction of turning points from the temperature signal, rainflow counting to identify stress cycles, and damage accumulation via the Palmgren–Miner linear damage hypothesis with a specified lifetime model. The entire process will be implemented from first principles as specified.\n\n### Step 1: Turning Point Extraction\n\nThe raw temperature signal $T_j(t_i)$ is first processed to identify the significant reversals that cause mechanical stress. This involves two sub-steps:\n\n1.  **Removal of Consecutive Duplicates**: The sampled signal may contain plateaus where $T_j(t_i) = T_j(t_{i+1})$. These segments do not contribute to temperature swings and are removed to create a condensed signal, let's call it $x$, where $x_j \\neq x_{j-1}$ for all $j$.\n\n2.  **Identification of Extrema**: From the condensed signal $x$, the turning points are extracted. A point $x_i$ is a turning point if it is a local maximum or a local minimum. This is determined by checking if the sign of the discrete temperature gradient changes at that point. Mathematically, for $i$ not at the ends of the sequence, $x_i$ is a turning point if $(x_i - x_{i-1}) \\cdot (x_{i+1} - x_i)  0$. The first and last points of the condensed signal are always treated as turning points to ensure all temperature excursions are included in the analysis. The output of this step is an ordered sequence of temperature reversals, $P = (p_1, p_2, \\dots, p_m)$.\n\n### Step 2: Rainflow Cycle Counting\n\nThe sequence of turning points $P$ is processed to identify closed fatigue cycles using a rainflow counting algorithm, consistent with the ASTM E1049-85 standard. The implemented method is the \"four-point\" algorithm, which operates as follows:\n\n1.  A temporary list, called the residue stack $S$, is initialized.\n2.  The algorithm iterates through the turning points $p_i \\in P$, appending each one to the stack $S$.\n3.  After each addition, a check is performed as long as the stack $S$ contains at least four points. Let the last four points be $(p_a, p_b, p_c, p_d)$.\n4.  A closed cycle is identified based on the ranges formed by these points. Let the range of the central pair be $\\Delta T_{bc} = |p_c - p_b|$ and the ranges of the adjacent pairs be $\\Delta T_{ab} = |p_b - p_a|$ and $\\Delta T_{cd} = |p_d - p_c|$. If $\\Delta T_{bc} \\le \\Delta T_{ab}$ and $\\Delta T_{bc} \\le \\Delta T_{cd}$, a full cycle is considered \"closed\".\n5.  When a full cycle is identified, its characteristics are recorded:\n    -   Cycle amplitude: $\\Delta T_{j,k} = \\Delta T_{bc}$\n    -   Cycle mean temperature: $T_{\\text{mean},k} = (p_b + p_c) / 2$\n    -   Cycle count: $n_k = 1$\n    The points $p_b$ and $p_c$ are then removed from the stack $S$, and the four-point check is repeated on the new stack configuration. If the condition in step 4 is not met, the inner loop terminates, and the algorithm proceeds to the next turning point from $P$.\n6.  After all turning points from $P$ have been processed, the remaining points in the residue stack $S$ do not form any more closed cycles. The excursions between adjacent points in $S$, say $(s_i, s_{i+1})$, are treated as half-cycles. For each such pair, a cycle is recorded with amplitude $\\Delta T_{j,k} = |s_{i+1} - s_i|$, mean temperature $T_{\\text{mean},k} = (s_i + s_{i+1})/2$, and a count of $n_k = 1/2$.\n\n### Step 3: Cumulative Damage Calculation\n\nThe final step is to compute the total damage index $D$ by summing the damage contributions from all identified full and half-cycles, following the Palmgren–Miner linear damage hypothesis.\n\n1.  For each cycle $k$ (characterized by $\\Delta T_{j,k}$, $T_{\\text{mean},k}$, and $n_k$), the number of cycles to failure, $N_k$, is calculated using the provided thermo-mechanical lifetime model:\n    $$\n    N(\\Delta T_{j,k}, T_{\\text{mean},k}) = A \\, (\\Delta T_{j,k})^{-b} \\, \\exp\\!\\left(\\frac{E_a}{k_B \\, T_{\\text{mean},k}}\\right)\n    $$\n    The model parameters are given as $A = 5 \\times 10^{8}$ cycles, $b = 5.5$, $E_a = 0.35\\,\\mathrm{eV}$, and the Boltzmann constant $k_B = 8.617333262145 \\times 10^{-5}$ eV/K. Cycles with zero amplitude ($\\Delta T_{j,k} = 0$) are disregarded as they induce no damage.\n\n2.  The damage accumulated from each cycle type is the ratio of the number of applied cycles to the number of cycles to failure for that cycle type, i.e., $D_k = n_k / N_k$.\n\n3.  The total cumulative damage $D$ is the linear sum of these individual contributions:\n    $$\n    D = \\sum_{k} D_k = \\sum_{k} \\frac{n_k}{N(\\Delta T_{j,k}, T_{\\text{mean},k})}\n    $$\nThis dimensionless index $D$ represents the fraction of the component's useful life that has been consumed under the given temperature profile. An index of $D \\ge 1$ would predict failure.\n\nThe algorithm is implemented in Python, leveraging the `numpy` library for efficient array manipulations, particularly for generating the test case waveforms and for vectorizing the final damage summation across all identified cycles.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the damage calculation for all test cases.\n    \"\"\"\n    # Define physical and model constants from the problem statement.\n    A = 5e8        # cycles\n    B = 5.5        # dimensionless exponent\n    EA = 0.35      # eV\n    KB = 8.617333262145e-5  # eV/K\n    N_SAMPLES = 36000\n    T_VALUES = np.arange(N_SAMPLES)\n\n    def extract_turning_points(series):\n        \"\"\"\n        Extracts turning points from a time series by removing duplicates\n        and finding local extrema.\n        \"\"\"\n        if len(series) == 0:\n            return []\n        \n        # 1. Remove consecutive duplicates\n        dedup_series = [series[0]]\n        for i in range(1, len(series)):\n            if series[i] != series[i-1]:\n                dedup_series.append(series[i])\n\n        if len(dedup_series)  3:\n            return dedup_series\n\n        # 2. Identify local extrema (turning points)\n        turning_points = [dedup_series[0]]\n        for i in range(1, len(dedup_series) - 1):\n            p_prev, p_curr, p_next = dedup_series[i-1], dedup_series[i], dedup_series[i+1]\n            # Check if discrete slope changes sign\n            if (p_curr  p_prev and p_curr  p_next) or \\\n               (p_curr  p_prev and p_curr  p_next):\n                turning_points.append(p_curr)\n        turning_points.append(dedup_series[-1])\n        \n        return turning_points\n\n    def rainflow_counting(turning_points):\n        \"\"\"\n        Performs rainflow counting on a sequence of turning points using the\n        4-point ASTM E1049-85 method.\n        \"\"\"\n        if len(turning_points)  2:\n            return []\n\n        cycles = []\n        residues = []\n        \n        for point in turning_points:\n            residues.append(point)\n            while len(residues) = 4:\n                p1, p2, p3, p4 = residues[-4], residues[-3], residues[-2], residues[-1]\n                range23 = abs(p2 - p3)\n                range12 = abs(p1 - p2)\n                range34 = abs(p3 - p4)\n                \n                # Check for a closed cycle\n                if range23 = range12 and range23 = range34:\n                    delta_T = range23\n                    T_mean = (p2 + p3) / 2.0\n                    cycles.append({'delta_T': delta_T, 'T_mean': T_mean, 'n': 1.0})\n                    # Remove the two inner points that form the cycle\n                    residues.pop(-2)\n                    residues.pop(-2)\n                else:\n                    break\n    \n        # Process remaining residues as half-cycles\n        for i in range(len(residues) - 1):\n            p1, p2 = residues[i], residues[i+1]\n            delta_T = abs(p1 - p2)\n            T_mean = (p1 + p2) / 2.0\n            cycles.append({'delta_T': delta_T, 'T_mean': T_mean, 'n': 0.5})\n            \n        return cycles\n\n    def calculate_damage(T_j):\n        \"\"\"\n        Calculates the cumulative damage index for a given temperature waveform.\n        \"\"\"\n        # Step 1: Extract turning points\n        tp = extract_turning_points(T_j)\n\n        # Step 2: Perform rainflow counting\n        cycles = rainflow_counting(tp)\n        \n        if not cycles:\n            return 0.0\n\n        # Step 3: Compute cumulative damage using vectorization\n        delta_T_arr = np.array([c['delta_T'] for c in cycles])\n        T_mean_arr = np.array([c['T_mean'] for c in cycles])\n        n_arr = np.array([c['n'] for c in cycles])\n\n        # Filter out cycles with zero amplitude, as they cause no damage\n        valid_mask = delta_T_arr  0\n        if not np.any(valid_mask):\n            return 0.0\n        \n        delta_T_arr = delta_T_arr[valid_mask]\n        T_mean_arr = T_mean_arr[valid_mask]\n        n_arr = n_arr[valid_mask]\n\n        # Calculate number of cycles to failure, N\n        # Ensure T_mean is not zero to avoid division by zero\n        T_mean_arr[T_mean_arr = 0] = np.inf # Avoids division by zero, N - infinity, damage - 0\n        \n        N_arr = A * (delta_T_arr)**(-B) * np.exp(EA / (KB * T_mean_arr))\n        \n        # Sum damage contributions\n        total_damage = np.sum(n_arr / N_arr)\n        \n        return total_damage\n\n    # Define the 5 test cases from the problem statement.\n    test_cases_data = []\n\n    # Case 1: Happy path, nested cycling\n    t = T_VALUES\n    T_j1 = 375.0 + 40.0 * np.sin(2 * np.pi * t / 600.0) + 10.0 * np.sin(2 * np.pi * t / 150.0)\n    test_cases_data.append(T_j1)\n\n    # Case 2: Boundary, no cycling\n    T_j2 = np.full(N_SAMPLES, 350.0)\n    test_cases_data.append(T_j2)\n\n    # Case 3: Edge, two half cycles\n    N_ramp = 18000\n    T_j3_part1 = np.linspace(350.0, 400.0, N_ramp)\n    T_j3_part2 = np.linspace(400.0, 360.0, N_ramp)\n    T_j3 = np.concatenate((T_j3_part1, T_j3_part2))\n    test_cases_data.append(T_j3)\n    \n    # Case 4: Low-amplitude stochastic cycling\n    np.random.seed(42)  # Use a fixed seed for reproducibility\n    noise = np.random.normal(loc=0.0, scale=1.0, size=N_SAMPLES)\n    window_size = 60\n    weights = np.ones(window_size) / window_size\n    eta_lp = np.convolve(noise, weights, mode='same')\n    T_j4 = 370.0 + 2.0 * eta_lp\n    test_cases_data.append(T_j4)\n\n    # Case 5: Arrhenius sensitivity with higher mean\n    T_j5 = 420.0 + 40.0 * np.sin(2 * np.pi * t / 600.0) + 10.0 * np.sin(2 * np.pi * t / 150.0)\n    test_cases_data.append(T_j5)\n\n    # Calculate damage for each case and collect results.\n    results = []\n    for T_j in test_cases_data:\n        damage = calculate_damage(T_j)\n        results.append(damage)\n\n    # Print the final output in the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}