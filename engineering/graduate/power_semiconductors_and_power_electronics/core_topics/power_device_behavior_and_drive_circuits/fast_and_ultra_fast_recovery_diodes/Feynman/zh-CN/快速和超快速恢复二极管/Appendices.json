{
    "hands_on_practices": [
        {
            "introduction": "这项基础练习将演示如何利用反向恢复电荷 ($Q_{rr}$) 和电流变化率 ($di/dt$) 等关键数据手册参数，来估算二极管承受的峰值压力。你将计算峰值反向电流 ($I_{RM}$) 及其产生的瞬时功耗，这对于器件的热管理和确保其在安全工作区内运行至关重要。我们将采用一个简化的“硬恢复”模型，以阐明电荷守恒这一核心物理原理。",
            "id": "3838674",
            "problem": "一个快速和超快速恢复硅二极管在一个硬开关桥臂中换向。在二极管关断期间，外部电路施加一个恒定的电流变化率 $d i / d t$，同时一个钳位电路将二极管的电压保持在一个近似恒定的反向电压 $V_{R}$。器件数据手册给出了在相同电流变化率下的反向恢复电荷 $Q_{\\mathrm{rr}}$。假设在硬恢复极限下，反向电流以斜率 $d i / d t$ 从零线性上升到峰值反向恢复电流 $I_{RM}$，然后突然降至零。忽略电容位移电流，因此反向恢复电流主要由复合的少数载流子决定，并且在上升期间二极管电压保持在 $V_{R}$。\n\n给定 $d i / d t = 250\\,\\mathrm{A}/\\mu\\mathrm{s}$，$Q_{\\mathrm{rr}} = 30\\,\\mu\\mathrm{C}$，以及 $V_{R} = 500\\,\\mathrm{V}$，使用电荷守恒和所述的线性关系来确定峰值反向恢复电流 $I_{RM}$，以及当 $I_{RM}$ 发生时二极管在 $V_{R}$ 电压下的瞬时峰值功耗。\n\n将两个结果都四舍五入到四位有效数字。$I_{RM}$ 以安培为单位表示，峰值功率以瓦特为单位表示。",
            "solution": "物理上的基本出发点是电荷守恒，它通过时间积分将电荷和电流联系起来，\n$$\nQ = \\int i(t)\\, d t.\n$$\n在所述的硬恢复假设下，反向电流以斜率 $d i / d t = s$ 从 $i(0)=0$ 线性上升到 $i(t_{r})=I_{RM}$，这里我们定义 $s \\equiv d i / d t$ 为外部电路施加的常数。因此，在上升期间，\n$$\ni(t) = s\\, t, \\quad 0 \\le t \\le t_{r},\n$$\n并在以下时刻达到峰值\n$$\nI_{RM} = s\\, t_{r} \\quad \\Rightarrow \\quad t_{r} = \\frac{I_{RM}}{s}.\n$$\n在硬恢复极限下，下降时间可以忽略不计，因此反向恢复电荷主要由线性上升曲线下的面积决定。因此，\n$$\nQ_{\\mathrm{rr}} = \\int_{0}^{t_{r}} i(t)\\, d t = \\int_{0}^{t_{r}} s\\, t\\, d t = \\frac{1}{2} s\\, t_{r}^{2}.\n$$\n使用 $t_{r} = I_{RM}/s$ 消去 $t_{r}$ 得到\n$$\nQ_{\\mathrm{rr}} = \\frac{1}{2} s \\left(\\frac{I_{RM}}{s}\\right)^{2} = \\frac{1}{2} \\frac{I_{RM}^{2}}{s}.\n$$\n解出 $I_{RM}$ 可得\n$$\nI_{RM} = \\sqrt{2\\, Q_{\\mathrm{rr}}\\, s}.\n$$\n接下来我们数值计算 $I_{RM}$，注意将单位转换为国际单位制。给定的参数是\n$$\nQ_{\\mathrm{rr}} = 30\\,\\mu\\mathrm{C} = 30 \\times 10^{-6}\\,\\mathrm{C}, \\quad s = \\frac{d i}{d t} = 250\\,\\mathrm{A}/\\mu\\mathrm{s} = 250 \\times 10^{6}\\,\\mathrm{A/s}.\n$$\n因此，\n$$\n2\\, Q_{\\mathrm{rr}}\\, s = 2 \\times \\left(30 \\times 10^{-6}\\right) \\times \\left(250 \\times 10^{6}\\right)\n= 2 \\times 30 \\times 250 \\times 10^{-6+6}\n= 15000.\n$$\n因此，\n$$\nI_{RM} = \\sqrt{15000} \\,\\mathrm{A} \\approx 122.474\\,\\mathrm{A}.\n$$\n四舍五入到四位有效数字，\n$$\nI_{RM} \\approx 122.5\\,\\mathrm{A}.\n$$\n\n对于瞬时功耗，基本关系是瞬时功率 $p(t) = v(t)\\, i(t)$。在上升期间二极管两端的反向电压近似恒定在 $V_{R}$ 的假设下，瞬时功率为\n$$\np(t) \\approx V_{R} \\, i(t),\n$$\n其峰值出现在峰值电流处：\n$$\np_{\\text{peak}} = V_{R} \\, I_{RM}.\n$$\n当 $V_{R} = 500\\,\\mathrm{V}$ 时，\n$$\np_{\\text{peak}} = 500 \\times 122.474 \\,\\mathrm{W} \\approx 61236.988\\,\\mathrm{W}.\n$$\n四舍五入到四位有效数字，\n$$\np_{\\text{peak}} \\approx 6.124 \\times 10^{4}\\,\\mathrm{W}.\n$$\n\n因此，计算得到的四位有效数字的量为 $I_{RM} \\approx 122.5\\,\\mathrm{A}$ 和 $p_{\\text{peak}} \\approx 6.124 \\times 10^{4}\\,\\mathrm{W}$。",
            "answer": "$$\\boxed{\\begin{pmatrix}122.5  6.124 \\times 10^{4}\\end{pmatrix}}$$"
        },
        {
            "introduction": "除了幅值大小，反向恢复电流波形的*形状*也具有重要的实际意义。本练习引入“软度因子”($S$) 来量化电流衰减曲线的特征，并探讨其如何通过在寄生电感中产生感应电压尖峰，直接影响电磁干扰 (EMI) 。通过比较“硬”恢复 (低 $S$) 和“软”恢复 (高 $S$) 的二极管，你将量化器件选择对系统级电磁兼容性的影响。",
            "id": "3838681",
            "problem": "考虑两个硅快恢复二极管，二极管A和二极管B，在一个大电流开关回路中用作续流元件。在相同的正向电流 $I_{m}$ 和换向条件下测量时，两个二极管表现出相同的反向恢复时间 $t_{rr}$。在反向恢复期间，反向恢复电流的下降阶段由一个两段近似模型来描述：一个持续时间为 $t_{s}$ 的初始准线性衰减，电流从大约 $I_{m}$ 下降到一个小的拐点电流；随后是一个持续时间为 $t_{t}$ 的较慢的拖尾阶段，与基区电荷的清除有关。在用于定义 $t_{rr}$ 的测量条件下，将软度因子 $S$ 定义为比率 $S = t_{s}/t_{t}$，并假设 $t_{rr} = t_{s} + t_{t}$。\n\n在此模型下，初始下降阶段的斜率大小 $|\\mathrm{d} i/\\mathrm{d} t|$ 主要由准线性段决定，并且可以很好地近似为 $I_{m}/t_{s}$。该回路具有一个杂散电感 $L_{\\ell}$，在下降阶段该电感上感应出的电压为 $v_{L}(t) = L_{\\ell}\\,\\mathrm{d} i/\\mathrm{d} t$。对于相同的 $L_{\\ell}$ 和 $t_{rr}$，$S$ 的差异会导致不同的 $|\\mathrm{d} i/\\mathrm{d} t|$，从而产生不同的感应电压幅值，这与高频电磁干扰（EMI）相关。\n\n给定以下测量和建模参数：$I_{m} = 25\\,\\mathrm{A}$，$t_{rr} = 35 \\times 10^{-9}\\,\\mathrm{s}$，$L_{\\ell} = 80 \\times 10^{-9}\\,\\mathrm{H}$，二极管A的 $S_{A} = 0.5$，二极管B的 $S_{B} = 3.0$，并采用上述定义的 $S = t_{s}/t_{t}$ 的两段模型，计算在下降阶段开始时，二极管A的峰值感应电压 $|v_{L}|$ 与二极管B的峰值感应电压之比 $R$。将您计算出的 $R$ 的最终答案表示为一个无量纲的数。无需四舍五入。",
            "solution": "目标是计算二极管A与二极管B在杂散电感上产生的峰值感应电压之比 $R$。峰值感应电压 $|v_{L}|$ 由回路杂散电感 $L_{\\ell}$ 与反向恢复下降阶段开始时的电流变化率大小 $|\\mathrm{d}i/\\mathrm{d}t|_{peak}$ 的乘积给出。\n$$|v_{L}|_{peak} = L_{\\ell} \\left|\\frac{\\mathrm{d}i}{\\mathrm{d}t}\\right|_{peak}$$\n根据问题的模型，这个峰值变化率可以很好地近似为正向电流 $I_{m}$ 与初始准线性衰减段时间 $t_{s}$ 的比值：\n$$\\left|\\frac{\\mathrm{d}i}{\\mathrm{d}t}\\right|_{peak} \\approx \\frac{I_{m}}{t_{s}}$$\n将这些结合起来，峰值感应电压为：\n$$|v_{L}|_{peak} \\approx L_{\\ell} \\frac{I_{m}}{t_{s}}$$\n为了继续计算，我们必须用给定的参数来表示 $t_{s}$：总反向恢复时间 $t_{rr}$ 和软度因子 $S$。提供的定义是：\n$$t_{rr} = t_{s} + t_{t}$$\n$$S = \\frac{t_{s}}{t_{t}}$$\n根据软度因子 $S$ 的定义，我们可以将拖尾电流的持续时间 $t_{t}$ 表示为 $t_{t} = \\frac{t_{s}}{S}$。将此代入 $t_{rr}$ 的方程中：\n$$t_{rr} = t_{s} + \\frac{t_{s}}{S} = t_{s} \\left(1 + \\frac{1}{S}\\right) = t_{s} \\left(\\frac{S+1}{S}\\right)$$\n求解 $t_{s}$ 得出：\n$$t_{s} = t_{rr} \\left(\\frac{S}{S+1}\\right)$$\n现在我们将这个 $t_{s}$ 的表达式代入峰值电压的方程中：\n$$|v_{L}|_{peak} \\approx L_{\\ell} \\frac{I_{m}}{t_{rr} \\left(\\frac{S}{S+1}\\right)} = \\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S+1}{S}\\right)$$\n这个方程将峰值电压与软度因子 $S$ 以及对两个二极管都相同的其他参数（$L_{\\ell}$、$I_{m}$、$t_{rr}$）联系起来。我们现在可以使用它们各自的软度因子 $S_{A}$ 和 $S_{B}$ 来写出二极管A（$|v_{L,A}|_{peak}$）和二极管B（$|v_{L,B}|_{peak}$）的峰值电压表达式：\n$$|v_{L,A}|_{peak} \\approx \\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{A}+1}{S_{A}}\\right)$$\n$$|v_{L,B}|_{peak} \\approx \\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{B}+1}{S_{B}}\\right)$$\n比率 $R$ 定义为：\n$$R = \\frac{|v_{L,A}|_{peak}}{|v_{L,B}|_{peak}}$$\n代入峰值电压的表达式：\n$$R = \\frac{\\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{A}+1}{S_{A}}\\right)}{\\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{B}+1}{S_{B}}\\right)}$$\n公共乘法因子 $\\frac{L_{\\ell} I_{m}}{t_{rr}}$ 被消去，留下一个仅依赖于软度因子的 $R$ 的简化表达式：\n$$R = \\frac{\\frac{S_{A}+1}{S_{A}}}{\\frac{S_{B}+1}{S_{B}}} = \\left(\\frac{S_{A}+1}{S_{A}}\\right) \\left(\\frac{S_{B}}{S_{B}+1}\\right)$$\n问题提供了数值 $S_{A} = 0.5$ 和 $S_{B} = 3.0$。将这些值代入 $R$ 的方程中：\n$$R = \\left(\\frac{0.5+1}{0.5}\\right) \\left(\\frac{3.0}{3.0+1}\\right)$$\n$$R = \\left(\\frac{1.5}{0.5}\\right) \\left(\\frac{3.0}{4.0}\\right)$$\n$$R = (3) \\left(\\frac{3}{4}\\right)$$\n$$R = \\frac{9}{4} = 2.25$$\n二极管A与二极管B的峰值感应电压之比为 $2.25$。这表明，在总反向恢复时间相同的情况下，与具有较大软度因子（二极管B，即“软”恢复二极管）的二极管相比，具有较小软度因子（二极管A，即“硬”恢复二极管）的二极管在杂散电感上产生明显更大的电压尖峰。",
            "answer": "$$\\boxed{2.25}$$"
        },
        {
            "introduction": "理论模型虽不可或缺，但其参数最终必须源于实际测量，而测量数据总是会受到噪声和离散采样的影响。最后的这项实践旨在连接理论与实验，要求你处理一组带噪声的时间采样电流数据，以计算反向恢复电荷 ($Q_{rr}$) 。更重要的是，本练习将指导你建立一套估算结果不确定度的系统方法，这对于任何实验研究工作都是一项至关重要的技能。",
            "id": "3838700",
            "problem": "给定一个二极管中反向恢复电流 $i_{RR}(t)$ 的离散采样测量值，该测量值覆盖了整个反向恢复事件的时间区间。反向恢复电荷 $Q_{rr}$ 定义为在反向恢复期间移出的总电荷。从电流 $i(t)$ 和电荷 $Q(t)$ 之间的基本关系式 $i(t) = \\frac{dQ(t)}{dt}$ 出发，并根据 $Q_{rr}$ 是恢复区间内反向电流幅值的时间积分的定义，你的任务是使用一种有原则的数值积分方法，从提供的离散样本中计算 $Q_{rr}$，并估计由有限采样（离散化）和测量噪声引起的不确定度。\n\n具体来说，假设测量样本的形式为 $i_n = i_{RR}(t_n) + \\epsilon_n$，其中 $t_n$ 是采样时间，$i_{RR}(t)$ 是潜在的反向恢复电流波形，而 $\\epsilon_n$ 是附加的零均值测量噪声。你必须：\n- 计算 $Q_{rr}$，即反向电流幅值对时间的积分，单位为 $\\mathrm{C}$ (库仑)。\n- 估计一个以 $\\mathrm{C}$ 为单位的一倍标准差不确定度，该不确定度要同时考虑由有限采样网格引起的数值积分的离散化效应和样本中存在的测量噪声。你的设计必须从第一性原理出发进行论证，从 $i(t) = \\frac{dQ(t)}{dt}$ 开始，并将积分估计量视为样本的线性泛函。\n\n你的程序必须为以下测试套件实现计算。对于每种情况，严格按照描述生成测量数据，然后计算所要求的输出。所有时间单位必须是 $\\mathrm{s}$ (秒)，电流单位是 $\\mathrm{A}$ (安培)，电荷单位是 $\\mathrm{C}$ (库仑)。噪声实现必须使用指定的随机种子生成。本问题不使用角度。\n\n测试套件：\n1. 理想情况（精细均匀采样，指数衰减）：\n   - 采样时间：$t_n = n \\cdot 2 \\times 10^{-8}\\,\\mathrm{s}$，其中 $n = 0,1,\\dots,250$。\n   - 潜在波形：$i_{RR}(t) = -I_0 \\exp(-t/\\tau)$，其中 $I_0 = 10\\,\\mathrm{A}$ 且 $\\tau = 4 \\times 10^{-7}\\,\\mathrm{s}$。\n   - 测量噪声：$\\epsilon_n$ 为高斯分布，均值为零，标准差为 $\\sigma = 0.05\\,\\mathrm{A}$。\n   - 随机种子：$12345$。\n   - 测量样本：$i_n = i_{RR}(t_n) + \\epsilon_n$。\n\n2. 粗糙均匀采样（相同波形，更大的离散化影响）：\n   - 采样时间：$t_n = n \\cdot 2 \\times 10^{-7}\\,\\mathrm{s}$，其中 $n = 0,1,\\dots,25$。\n   - 潜在波形：$i_{RR}(t) = -I_0 \\exp(-t/\\tau)$，其中 $I_0 = 10\\,\\mathrm{A}$ 且 $\\tau = 4 \\times 10^{-7}\\,\\mathrm{s}$。\n   - 测量噪声：$\\epsilon_n$ 为高斯分布，均值为零，标准差为 $\\sigma = 0.05\\,\\mathrm{A}$。\n   - 随机种子：$13579$。\n   - 测量样本：$i_n = i_{RR}(t_n) + \\epsilon_n$。\n\n3. 边缘情况（非均匀采样，三角形幅值波形，短恢复时间）：\n   - 采样时间（非均匀）：$t = [0, 1\\times 10^{-7}, 2.5\\times 10^{-7}, 2.6\\times 10^{-7}, 4\\times 10^{-7}, 8\\times 10^{-7}, 9\\times 10^{-7}]\\,\\mathrm{s}$。\n   - 潜在幅值（分段线性）：$j_{\\text{true}}(t)$ 从 $t=0$ 时的 $0\\,\\mathrm{A}$ 线性上升到 $t=4\\times 10^{-7}\\,\\mathrm{s}$ 时的 $8\\,\\mathrm{A}$，然后线性下降到 $t=9\\times 10^{-7}\\,\\mathrm{s}$ 时的 $0\\,\\mathrm{A}$。反向恢复电流波形为 $i_{RR}(t) = -j_{\\text{true}}(t)$。\n   - 测量噪声：$\\epsilon_n$ 为高斯分布，均值为零，标准差为 $\\sigma = 0.02\\,\\mathrm{A}$。\n   - 随机种子：$24680$。\n   - 测量样本：$i_n = i_{RR}(t_n) + \\epsilon_n$。\n\n对于每个测试用例，计算：\n- 反向恢复电荷 $Q_{rr}$，单位为 $\\mathrm{C}$，为一个正浮点数。\n- 一倍标准差不确定度 $u$，单位为 $\\mathrm{C}$，该不确定度要同时考虑离散化和测量噪声。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其中每个测试用例的结果是一个双元素列表 $[Q_{rr},u]$，两个条目的单位都是 $\\mathrm{C}$，例如 $[[q_1,u_1],[q_2,u_2],[q_3,u_3]]$。输出行中不得有空格。",
            "solution": "基本出发点是电流和电荷之间的关系，$i(t) = \\frac{dQ(t)}{dt}$，其积分为 $Q(t_2) - Q(t_1) = \\int_{t_1}^{t_2} i(t)\\,dt$。反向恢复电荷 $Q_{rr}$ 定义为恢复事件期间反向电流幅值的时间积分。如果反向电流表示为一个在恢复脉冲期间为负的有符号量 $i_{RR}(t)$，那么 $Q_{rr}$ 可以写为\n$$\nQ_{rr} = \\int_{t_s}^{t_e} \\left|i_{RR}(t)\\right|\\,dt = \\int_{t_s}^{t_e} \\max\\left(0, -i_{RR}(t)\\right)\\,dt,\n$$\n其中 $[t_s,t_e]$ 是恢复区间。在所提供的数据中，采样时间 $t_n$ 是已知的，测量值为 $i_n = i_{RR}(t_n) + \\epsilon_n$，其中 $\\epsilon_n$ 是零均值噪声。\n\n为了从离散样本计算积分，我们采用一种基于黎曼和的复合数值积分方法。对于离散数据上的积分，一种有原则的估计方法是复合梯形法则。对于非均匀采样时间 $t_0  t_1  \\dots  t_N$ 和相应的幅值 $j_n = \\max(0, -i_n)$，梯形估计量为\n$$\n\\hat{Q}_{rr} = \\sum_{k=0}^{N-1} \\frac{j_k + j_{k+1}}{2}\\,\\Delta t_k, \\quad \\Delta t_k = t_{k+1} - t_k.\n$$\n这是通过将样本点之间的 $j(t)$ 近似为分段线性函数直接导出的，这种方法保留了积分与定义 $i(t)=\\frac{dQ}{dt}$ 的一致性，并避免了使用捷径公式。估计量 $\\hat{Q}_{rr}$ 是样本 $\\{j_n\\}$ 的一个线性泛函，这使得有原则的不确定度传播成为可能。\n\n由离散化（采样）引起的不确定度源于使用离散样本来近似连续函数的积分。对于足够平滑的波形，均匀网格上梯形法则的误差尺度为 $\\mathcal{O}(h^2)$，其中 $h$ 是网格间距。一种在不知道高阶导数的情况下估计离散化不确定度的第一性原理方法是比较在两个嵌套网格上计算的积分估计值：一个精细网格和一个通过抽取每隔一个样本创建的较粗糙网格，两者都使用相同的梯形估计量。用 $\\hat{Q}_h$ 表示使用精细网格的估计值，用 $\\hat{Q}_{2h}$ 表示使用抽取后网格的估计值。均匀网格上梯形法则的 Richardson 外推法启发我们使用差值来量化离散化偏差。一个保守的、等效于一倍标准差的离散化不确定度可以取为\n$$\nu_{\\text{samp}} \\approx \\frac{\\left|\\hat{Q}_h - \\hat{Q}_{2h}\\right|}{3},\n$$\n需要注意的是，对于非均匀网格，这提供了一个遵循相同原则的经验界限：更粗糙的网格抑制了高频内容，并揭示了积分对采样密度的敏感性。\n\n测量噪声不确定度是通过对 $i_n = i_{RR}(t_n) + \\epsilon_n$ 建模得出的，其中 $\\epsilon_n$ 是方差为 $\\sigma^2$ 的独立零均值噪声。由于积分估计量是样本的线性函数，它可以重新表示为\n$$\n\\hat{Q}_{rr} = \\sum_{n=0}^{N} w_n\\,j_n,\n$$\n其中 $\\{w_n\\}$ 是依赖于时间网格的合适权重。对于非均匀网格上的梯形法则，这些权重是\n$$\nw_0 = \\frac{\\Delta t_0}{2}, \\quad w_N = \\frac{\\Delta t_{N-1}}{2}, \\quad w_n = \\frac{\\Delta t_{n-1} + \\Delta t_n}{2} \\ \\text{for} \\ n=1,\\dots,N-1.\n$$\n如果测量噪声以方差为 $\\sigma^2$ 的方式加性且独立地污染样本，则积分估计量的方差为\n$$\n\\operatorname{Var}(\\hat{Q}_{rr}) = \\sigma^2 \\sum_{n=0}^{N} w_n^2,\n$$\n而一倍标准差的噪声不确定度是\n$$\nu_{\\text{noise}} = \\sqrt{\\operatorname{Var}(\\hat{Q}_{rr})}.\n$$\n噪声标准差 $\\sigma$ 必须根据测量数据 $\\{i_n\\}$ 进行估计，其方式应能将潜在信号与噪声分离，而无需预先假设波形。一种稳健的第一性原理方法是通过移动平均平滑器估计潜在的平滑幅值 $j(t)$，然后从残差中估计噪声水平。定义 $j_n = \\max(0, -i_n)$，并令 $\\tilde{j}_n$ 为通过一个与波形时间尺度相比很小的窗口计算的 $j_n$ 的局部平均版本。残差 $r_n = j_n - \\tilde{j}_n$ 捕捉了可归因于噪声的高频波动。$\\sigma$ 的一个稳健估计是\n$$\n\\hat{\\sigma} = 1.4826 \\cdot \\operatorname{median}\\left(\\left|r_n\\right|\\right),\n$$\n该方法使用针对高斯噪声的中位数绝对偏差缩放，并基于统计学原理。如果由于噪声非常低或数据极其平滑导致 $\\hat{\\sigma} = 0$，可以回退到使用 $r_n$ 的样本标准差。\n\n假设离散化误差和测量噪声是独立的不确定度来源，则组合后的一倍标准差不确定度可以通过平方和开方来报告：\n$$\nu = \\sqrt{u_{\\text{noise}}^2 + u_{\\text{samp}}^2}.\n$$\n这种组合方式与线性估计量中独立不确定度的传播一致，并避免了使用捷径公式。\n\n程序中实现的算法步骤：\n1. 对于每个测试用例，使用指定的随机种子生成采样时间 $\\{t_n\\}$ 和测量的电流样本 $\\{i_n\\}$。对于指数衰减情况，使用 $i_{RR}(t) = -I_0 \\exp(-t/\\tau)$。对于三角形情况，构造分段线性幅值 $j_{\\text{true}}(t)$ 并设置 $i_{RR}(t) = -j_{\\text{true}}(t)$。添加具有指定标准差的高斯噪声 $\\epsilon_n$。\n2. 计算 $j_n = \\max(0, -i_n)$。\n3. 通过具有非均匀时间步长 $\\Delta t_k$ 的复合梯形法则计算 $\\hat{Q}_{rr}$。\n4. 通过抽取每隔一个样本并重新计算梯形积分来估计 $u_{\\text{samp}}$；如果抽取后的网格至少有两个点，则取 $u_{\\text{samp}} \\approx \\frac{|\\hat{Q}_h - \\hat{Q}_{2h}|}{3}$；否则设置 $u_{\\text{samp}} = 0$。\n5. 从 $j_n$ 的移动平均平滑的残差中估计 $\\hat{\\sigma}$，并计算非均匀网格上梯形估计量的权重 $w_n$。计算 $u_{\\text{noise}} = \\sqrt{\\hat{\\sigma}^2 \\sum w_n^2}$。\n6. 通过 $u = \\sqrt{u_{\\text{noise}}^2 + u_{\\text{samp}}^2}$ 组合不确定度。\n7. 为每个测试用例输出以 $\\mathrm{C}$ 为单位的数对 $[Q_{rr},u]$。\n\n输出按规定生成，为不含空格的单行，其中包含每个测试用例结果的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef moving_average_reflect(x: np.ndarray, window: int) - np.ndarray:\n    \"\"\"Compute a simple moving average with reflective padding to preserve length.\"\"\"\n    if window == 1:\n        return x.copy()\n    # Ensure window is odd\n    if window % 2 == 0:\n        window += 1\n    k = window // 2\n    # Reflective padding\n    pad = np.pad(x, (k, k), mode='reflect')\n    kernel = np.ones(window, dtype=float) / float(window)\n    return np.convolve(pad, kernel, mode='valid')\n\ndef trapezoid_nonuniform(t: np.ndarray, y: np.ndarray) - float:\n    \"\"\"Composite trapezoid integration for nonuniform grid.\"\"\"\n    dt = np.diff(t)\n    return float(np.sum(dt * (y[:-1] + y[1:]) * 0.5))\n\ndef trapezoid_weights_nonuniform(t: np.ndarray) - np.ndarray:\n    \"\"\"Weights for samples in nonuniform trapezoid integral.\"\"\"\n    N = len(t) - 1\n    if N  1:\n        return np.zeros(len(t))\n    dt = np.diff(t)\n    w = np.zeros(len(t), dtype=float)\n    w[0] = dt[0] / 2.0\n    w[-1] = dt[-1] / 2.0\n    if len(t)  2:\n        w[1:-1] = (dt[:-1] + dt[1:]) / 2.0\n    return w\n\ndef estimate_noise_sigma(signal: np.ndarray) - float:\n    \"\"\"Estimate noise sigma using robust MAD from residuals after moving average smoothing.\"\"\"\n    N = len(signal)\n    # Window length guided by data size, keep it modest to avoid over-smoothing.\n    # Use an odd window, min 3, max 25.\n    base = max(3, min(25, 2 * (max(1, N // 5)) + 1))\n    smooth = moving_average_reflect(signal, base)\n    residuals = signal - smooth\n    mad = np.median(np.abs(residuals))\n    sigma_hat = 1.4826 * mad\n    if sigma_hat == 0.0:\n        # Fallback to sample std if MAD yields zero\n        if N  1:\n            sigma_hat = float(np.std(residuals, ddof=1))\n        else:\n            sigma_hat = 0.0\n    # Avoid exactly zero to keep uncertainty calculable\n    if sigma_hat == 0.0:\n        sigma_hat = 1e-15\n    return sigma_hat\n\ndef compute_Q_and_uncertainty(t: np.ndarray, i_meas: np.ndarray) - (float, float):\n    \"\"\"Compute Q_rr via trapezoidal rule and estimate combined uncertainty.\"\"\"\n    # Ensure ascending times and align measurements\n    idx = np.argsort(t)\n    t = t[idx]\n    i_meas = i_meas[idx]\n    # Magnitude of reverse current (nonnegative)\n    j = np.maximum(0.0, -i_meas)\n\n    # Trapezoidal integral on full grid\n    Q_hat = trapezoid_nonuniform(t, j)\n\n    # Discretization uncertainty via decimated grid comparison\n    if len(t) = 3:\n        t2 = t[::2]\n        j2 = j[::2]\n        if len(t2) = 2:\n            Q_coarse = trapezoid_nonuniform(t2, j2)\n            u_samp = abs(Q_hat - Q_coarse) / 3.0\n        else:\n            u_samp = 0.0\n    else:\n        u_samp = 0.0\n\n    # Noise uncertainty via linear propagation\n    w = trapezoid_weights_nonuniform(t)\n    sigma_hat = estimate_noise_sigma(j)\n    var_noise = (sigma_hat ** 2) * float(np.sum(w ** 2))\n    u_noise = float(np.sqrt(var_noise))\n\n    # Combined uncertainty (independent sources)\n    u_total = float(np.sqrt(u_samp ** 2 + u_noise ** 2))\n    return Q_hat, u_total\n\ndef generate_test_case_1():\n    # Case 1: fine uniform sampling, exponential decay\n    I0 = 10.0  # A\n    tau = 4e-7  # s\n    dt = 2e-8  # s\n    t_end = 5e-6  # s\n    N = int(round(t_end / dt))\n    t = np.linspace(0.0, t_end, N + 1)\n    i_rr = -I0 * np.exp(-t / tau)\n    rng = np.random.default_rng(12345)\n    noise = rng.normal(loc=0.0, scale=0.05, size=t.shape)  # A\n    i_meas = i_rr + noise\n    return t, i_meas\n\ndef generate_test_case_2():\n    # Case 2: coarse uniform sampling, exponential decay\n    I0 = 10.0  # A\n    tau = 4e-7  # s\n    dt = 2e-7  # s\n    t_end = 5e-6  # s\n    N = int(round(t_end / dt))\n    t = np.linspace(0.0, t_end, N + 1)\n    i_rr = -I0 * np.exp(-t / tau)\n    rng = np.random.default_rng(13579)\n    noise = rng.normal(loc=0.0, scale=0.05, size=t.shape)  # A\n    i_meas = i_rr + noise\n    return t, i_meas\n\ndef generate_test_case_3():\n    # Case 3: nonuniform sampling, triangular magnitude waveform\n    t = np.array([0.0, 1e-7, 2.5e-7, 2.6e-7, 4e-7, 8e-7, 9e-7], dtype=float)\n    # Piecewise linear magnitude j_true\n    j_true = np.zeros_like(t)\n    # Rising to 8 A at 4e-7 s\n    for idx, tt in enumerate(t):\n        if tt = 4e-7:\n            j_true[idx] = (8.0 / (4e-7)) * tt\n        elif tt = 9e-7:\n            j_true[idx] = 8.0 + (-8.0 / (5e-7)) * (tt - 4e-7)\n        else:\n            j_true[idx] = 0.0\n    i_rr = -j_true\n    rng = np.random.default_rng(24680)\n    noise = rng.normal(loc=0.0, scale=0.02, size=t.shape)  # A\n    i_meas = i_rr + noise\n    return t, i_meas\n\ndef fmt_float(x: float) - str:\n    # Format float compactly without spaces\n    return \"{:.12g}\".format(x)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        generate_test_case_1(),\n        generate_test_case_2(),\n        generate_test_case_3(),\n    ]\n\n    results = []\n    for t, i_meas in test_cases:\n        Q, u = compute_Q_and_uncertainty(t, i_meas)\n        results.append([Q, u])\n\n    # Build output string exactly as required: no spaces\n    inner = []\n    for pair in results:\n        inner.append(\"[\" + \",\".join(fmt_float(x) for x in pair) + \"]\")\n    print(\"[\" + \",\".join(inner) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}