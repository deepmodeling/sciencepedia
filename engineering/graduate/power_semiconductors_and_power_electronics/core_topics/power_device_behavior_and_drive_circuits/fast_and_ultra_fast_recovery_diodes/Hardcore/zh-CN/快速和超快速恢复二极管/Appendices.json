{
    "hands_on_practices": [
        {
            "introduction": "分析二极管反向恢复的第一步是量化其动态行为。本练习将演示如何使用数据手册中的关键参数，如反向恢复电荷 $Q_{rr}$，在一个常用的简化模型（硬恢复模型）下，计算峰值反向电流 $I_{RM}$ 和瞬时峰值功耗。这项技能对于在硬开关应用中进行初步设计、评估器件应力和选择合适的二极管至关重要。",
            "id": "3838674",
            "problem": "在硬开关桥臂中，一个快速和超快速恢复硅二极管进行换向。在二极管关断期间，外部电路施加一个恒定的电流转换率 $d i / d t$，同时一个钳位电路将二极管保持在近似恒定的反向电压 $V_{R}$。器件数据手册表征了在相同电流转换率下的反向恢复电荷 $Q_{\\mathrm{rr}}$。假设在硬恢复极限下，反向电流以斜率 $d i / d t$ 从零线性上升到峰值反向恢复电流 $I_{RM}$，然后突然降至零。忽略电容性位移电流，因此反向恢复电流主要由复合的少数载流子决定，并且在上升期间二极管电压保持在 $V_{R}$。\n\n给定 $di/dt = 250\\,\\mathrm{A}/\\mu\\mathrm{s}$，$Q_{\\mathrm{rr}} = 30\\,\\mu\\mathrm{C}$，以及 $V_{R} = 500\\,\\mathrm{V}$，利用电荷守恒和所述的线性关系来确定峰值反向恢复电流 $I_{RM}$ 以及当 $I_{RM}$ 发生时二极管在 $V_{R}$ 电压下的瞬时峰值功耗。\n\n将两个结果四舍五入至四位有效数字。$I_{RM}$ 以安培为单位表示，峰值功率以瓦特为单位表示。",
            "solution": "物理上的基本出发点是电荷守恒，它通过时间积分将电荷和电流联系起来，\n$$\nQ = \\int i(t)\\, d t.\n$$\n在所述的硬恢复假设下，反向电流以斜率 $d i / d t = s$ 从 $i(0)=0$ 线性上升到 $i(t_{r})=I_{RM}$，其中我们定义 $s \\equiv d i / d t$ 为外部电路施加的常数。因此，在上升期间，\n$$\ni(t) = s\\, t, \\quad 0 \\le t \\le t_{r},\n$$\n并在以下时刻达到峰值\n$$\nI_{RM} = s\\, t_{r} \\quad \\Rightarrow \\quad t_{r} = \\frac{I_{RM}}{s}.\n$$\n在硬恢复极限下，下降时间可以忽略不计，因此反向恢复电荷主要由线性上升曲线下的面积决定。因此，\n$$\nQ_{\\mathrm{rr}} = \\int_{0}^{t_{r}} i(t)\\, d t = \\int_{0}^{t_{r}} s\\, t\\, d t = \\frac{1}{2} s\\, t_{r}^{2}.\n$$\n使用 $t_{r} = I_{RM}/s$ 消去 $t_{r}$，得到\n$$\nQ_{\\mathrm{rr}} = \\frac{1}{2} s \\left(\\frac{I_{RM}}{s}\\right)^{2} = \\frac{1}{2} \\frac{I_{RM}^{2}}{s}.\n$$\n对 $I_{RM}$ 求解可得\n$$\nI_{RM} = \\sqrt{2\\, Q_{\\mathrm{rr}}\\, s}.\n$$\n接下来我们对 $I_{RM}$ 进行数值计算，注意将单位转换为国际单位制。给定的参数为\n$$\nQ_{\\mathrm{rr}} = 30\\,\\mu\\mathrm{C} = 30 \\times 10^{-6}\\,\\mathrm{C}, \\quad s = \\frac{d i}{d t} = 250\\,\\mathrm{A}/\\mu\\mathrm{s} = 250 \\times 10^{6}\\,\\mathrm{A/s}.\n$$\n于是，\n$$\n2\\, Q_{\\mathrm{rr}}\\, s = 2 \\times \\left(30 \\times 10^{-6}\\right) \\times \\left(250 \\times 10^{6}\\right)\n= 2 \\times 30 \\times 250 \\times 10^{-6+6}\n= 15000.\n$$\n因此，\n$$\nI_{RM} = \\sqrt{15000} \\,\\mathrm{A} \\approx 122.474\\,\\mathrm{A}.\n$$\n四舍五入至四位有效数字，\n$$\nI_{RM} \\approx 122.5\\,\\mathrm{A}.\n$$\n\n对于瞬时功耗，其基本关系是瞬时功率 $p(t) = v(t)\\, i(t)$。在上升期间二极管两端的反向电压近似恒定保持在 $V_{R}$ 的假设下，瞬时功率为\n$$\np(t) \\approx V_{R} \\, i(t),\n$$\n其峰值出现在峰值电流处：\n$$\np_{\\text{peak}} = V_{R} \\, I_{RM}.\n$$\n当 $V_{R} = 500\\,\\mathrm{V}$ 时，\n$$\np_{\\text{peak}} = 500 \\times 122.474 \\,\\mathrm{W} \\approx 61236.988\\,\\mathrm{W}.\n$$\n四舍五入至四位有效数字，\n$$\np_{\\text{peak}} \\approx 6.124 \\times 10^{4}\\,\\mathrm{W}.\n$$\n\n因此，计算得到并保留四位有效数字的量为 $I_{RM} \\approx 122.5\\,\\mathrm{A}$ 和 $p_{\\text{peak}} \\approx 6.124 \\times 10^{4}\\,\\mathrm{W}$。",
            "answer": "$$\\boxed{\\begin{pmatrix}122.5  6.124 \\times 10^{4}\\end{pmatrix}}$$"
        },
        {
            "introduction": "仅仅了解总恢复时间 $t_{rr}$ 往往不足以全面评估二极管的性能，恢复电流的波形形状同样关键。本练习引入了“软度因子” $S$ 这一更细致的度量标准，并将其与由杂散电感引起的电压过冲直接联系起来，后者是电磁干扰（EMI）的主要来源。通过这个练习，您将理解为什么两个具有相同 $t_{rr}$ 的二极管在实际应用中会表现出截然不同的EMI特性。",
            "id": "3838681",
            "problem": "考虑两个硅快速恢复二极管，二极管A和二极管B，在一个大电流开关环路中用作续流元件。当在相同的正向电流 $I_{m}$ 和换向条件下测量时，两个二极管表现出相同的反向恢复时间 $t_{rr}$。在反向恢复期间，反向恢复电流的下降阶段可以用一个两段式近似模型来描述：一个初始的准线性衰减阶段，持续时间为 $t_{s}$，电流从大约 $I_{m}$ 下降到一个小的拐点电流；随后是一个持续时间为 $t_{t}$ 的较慢的拖尾阶段，这与基区电荷的清除有关。定义软度因子 $S$ 为在用于定义 $t_{rr}$ 的测量条件下 $t_{s}$ 与 $t_{t}$ 的比值，即 $S = t_{s}/t_{t}$，并假设 $t_{rr} = t_{s} + t_{t}$。\n\n在此模型下，初始下降阶段的斜率大小 $|\\mathrm{d} i/\\mathrm{d} t|$ 主要由准线性段决定，并且可以很好地近似为 $I_{m}/t_{s}$。环路中存在一个杂散电感 $L_{\\ell}$，在下降阶段该电感上感应出的电压为 $v_{L}(t) = L_{\\ell}\\,\\mathrm{d} i/\\mathrm{d} t$。对于相同的 $L_{\\ell}$ 和 $t_{rr}$，$S$ 的差异会导致不同的 $|\\mathrm{d} i/\\mathrm{d} t|$，从而产生不同的感应电压幅值，这与高频电磁干扰（EMI）相关。\n\n给定以下测量和建模参数：$I_{m} = 25$，$t_{rr} = 35 \\times 10^{-9}$，$L_{\\ell} = 80 \\times 10^{-9}$，二极管A的 $S_{A} = 0.5$ 以及二极管B的 $S_{B} = 3.0$。采用上述定义的 $S = t_{s}/t_{t}$ 的两段式模型，计算在下降阶段开始时，二极管A的峰值感应电压 $|v_{L}|$ 与二极管B的峰值感应电压之比 $R$。请将您的最终答案 $R$ 表示为一个无量纲的单一数值。无需四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据，问题设定良好且客观。它提供了一个清晰、简化的二极管反向恢复模型以及计算所需比率的所有必要参数。\n\n目标是计算二极管A与二极管B在杂散电感上产生的峰值感应电压之比 $R$。峰值感应电压 $|v_{L}|$ 由环路杂散电感 $L_{\\ell}$ 与反向恢复下降阶段开始时的电流变化率大小 $|\\mathrm{d}i/\\mathrm{d}t|_{peak}$ 的乘积给出。\n$$|v_{L}|_{peak} = L_{\\ell} \\left|\\frac{\\mathrm{d}i}{\\mathrm{d}t}\\right|_{peak}$$\n根据问题的模型，这个峰值变化率可以很好地近似为正向电流 $I_{m}$ 与初始准线性衰减段持续时间 $t_{s}$ 的比值：\n$$\\left|\\frac{\\mathrm{d}i}{\\mathrm{d}t}\\right|_{peak} \\approx \\frac{I_{m}}{t_{s}}$$\n结合以上两式，峰值感应电压为：\n$$|v_{L}|_{peak} \\approx L_{\\ell} \\frac{I_{m}}{t_{s}}$$\n为了继续计算，我们必须用给定的参数——总反向恢复时间 $t_{rr}$ 和软度因子 $S$——来表示 $t_{s}$。给定的定义是：\n$$t_{rr} = t_{s} + t_{t}$$\n$$S = \\frac{t_{s}}{t_{t}}$$\n根据软度因子 $S$ 的定义，我们可以将拖尾电流的持续时间 $t_{t}$ 表示为 $t_{t} = \\frac{t_{s}}{S}$。将此表达式代入 $t_{rr}$ 的方程中：\n$$t_{rr} = t_{s} + \\frac{t_{s}}{S} = t_{s} \\left(1 + \\frac{1}{S}\\right) = t_{s} \\left(\\frac{S+1}{S}\\right)$$\n解出 $t_{s}$：\n$$t_{s} = t_{rr} \\left(\\frac{S}{S+1}\\right)$$\n现在我们将这个 $t_{s}$ 的表达式代入峰值电压的方程中：\n$$|v_{L}|_{peak} \\approx L_{\\ell} \\frac{I_{m}}{t_{rr} \\left(\\frac{S}{S+1}\\right)} = \\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S+1}{S}\\right)$$\n这个方程将峰值电压与软度因子 $S$ 以及对两个二极管都相同的其他参数（$L_{\\ell}$、$I_{m}$、$t_{rr}$）联系起来。我们现在可以使用它们各自的软度因子 $S_{A}$ 和 $S_{B}$ 来写出二极管A（$|v_{L,A}|_{peak}$）和二极管B（$|v_{L,B}|_{peak}$）的峰值电压表达式：\n$$|v_{L,A}|_{peak} \\approx \\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{A}+1}{S_{A}}\\right)$$\n$$|v_{L,B}|_{peak} \\approx \\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{B}+1}{S_{B}}\\right)$$\n比率 $R$ 定义为：\n$$R = \\frac{|v_{L,A}|_{peak}}{|v_{L,B}|_{peak}}$$\n代入峰值电压的表达式：\n$$R = \\frac{\\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{A}+1}{S_{A}}\\right)}{\\frac{L_{\\ell} I_{m}}{t_{rr}} \\left(\\frac{S_{B}+1}{S_{B}}\\right)}$$\n公因式 $\\frac{L_{\\ell} I_{m}}{t_{rr}}$ 被消去，留下一个仅依赖于软度因子的简化表达式 $R$：\n$$R = \\frac{\\frac{S_{A}+1}{S_{A}}}{\\frac{S_{B}+1}{S_{B}}} = \\left(\\frac{S_{A}+1}{S_{A}}\\right) \\left(\\frac{S_{B}}{S_{B}+1}\\right)$$\n问题给出了数值 $S_{A} = 0.5$ 和 $S_{B} = 3.0$。将这些值代入 $R$ 的方程中：\n$$R = \\left(\\frac{0.5+1}{0.5}\\right) \\left(\\frac{3.0}{3.0+1}\\right)$$\n$$R = \\left(\\frac{1.5}{0.5}\\right) \\left(\\frac{3.0}{4.0}\\right)$$\n$$R = (3) \\left(\\frac{3}{4}\\right)$$\n$$R = \\frac{9}{4} = 2.25$$\n二极管A与二极管B的峰值感应电压之比为 $2.25$。这表明，在总反向恢复时间相同的情况下，软度因子较小的二极管（二极管A，即“硬”恢复二极管）在杂散电感上产生的电压尖峰明显大于软度因子较大的二极管（二极管B，即“软”恢复二极管）。",
            "answer": "$$\\boxed{2.25}$$"
        },
        {
            "introduction": "理论分析最终需要通过实验测量来验证，而工程师通常面对的是从示波器等仪器中获得的离散且带有噪声的数据。本编程练习旨在搭建理论与实践之间的桥梁，指导您如何处理模拟的“测量”数据。您将学习使用数值积分方法从离散的电流采样点中计算出总反向恢复电荷 $Q_{rr}$，并对计算结果进行不确定性分析，这是一项在器件表征和电路诊断中不可或缺的实用技能。",
            "id": "3838700",
            "problem": "给定一个二极管在反向恢复期间的离散采样测量值，表示为$i_{RR}(t)$，其时间区间覆盖了整个反向恢复事件。反向恢复电荷$Q_{rr}$定义为在反向恢复过程中移出的总电荷。从电流$i(t)$与电荷$Q(t)$之间的基本关系式$i(t) = \\frac{dQ(t)}{dt}$，以及$Q_{rr}$作为恢复期间反向电流大小的时间积分的定义出发，您的任务是使用一种基于基本原理的数值积分方法，从提供的离散样本中计算$Q_{rr}$，并估计由有限采样（离散化）和测量噪声引起的不确定度。\n\n具体来说，假设测量样本的形式为$i_n = i_{RR}(t_n) + \\epsilon_n$，其中$t_n$是采样时间，$i_{RR}(t)$是潜在的反向恢复电流波形，$\\epsilon_n$是加性零均值测量噪声。您必须：\n- 计算$Q_{rr}$，即反向电流大小对时间的积分，以$\\mathrm{C}$（库仑）为单位表示。\n- 估计一个以$\\mathrm{C}$为单位的单标准差不确定度，该不确定度需同时考虑因有限采样网格导致的数值积分离散化效应和样本中存在的测量噪声。您的设计必须从第一性原理出发进行论证，以$i(t) = \\frac{dQ(t)}{dt}$为起点，并将积分估计量视为样本的线性泛函。\n\n您的程序必须为以下测试套件实现计算。对于每个案例，请严格按照描述生成测量数据，然后计算所要求的输出。所有时间单位必须是$\\mathrm{s}$（秒），电流单位是$\\mathrm{A}$（安培），电荷单位是$\\mathrm{C}$（库仑）。噪声的实现必须使用指定的随机种子生成。本问题不使用角度。\n\n测试套件：\n1. 理想情况（精细均匀采样，指数衰减）：\n   - 采样时间：$t_n = n \\cdot 2 \\times 10^{-8}\\,\\mathrm{s}$，对于$n = 0,1,\\dots,250$。\n   - 潜在波形：$i_{RR}(t) = -I_0 \\exp(-t/\\tau)$，其中$I_0 = 10\\,\\mathrm{A}$，$τ = 4 \\times 10^{-7}\\,\\mathrm{s}$。\n   - 测量噪声：$\\epsilon_n$是均值为零、标准差为$\\sigma = 0.05\\,\\mathrm{A}$的高斯噪声。\n   - 随机种子：$12345$。\n   - 测量样本：$i_n = i_{RR}(t_n) + \\epsilon_n$。\n\n2. 粗略均匀采样（相同波形，更大的离散化影响）：\n   - 采样时间：$t_n = n \\cdot 2 \\times 10^{-7}\\,\\mathrm{s}$，对于$n = 0,1,\\dots,25$。\n   - 潜在波形：$i_{RR}(t) = -I_0 \\exp(-t/\\tau)$，其中$I_0 = 10\\,\\mathrm{A}$，$τ = 4 \\times 10^{-7}\\,\\mathrm{s}$。\n   - 测量噪声：$\\epsilon_n$是均值为零、标准差为$\\sigma = 0.05\\,\\mathrm{A}$的高斯噪声。\n   - 随机种子：$13579$。\n   - 测量样本：$i_n = i_{RR}(t_n) + \\epsilon_n$。\n\n3. 边界情况（非均匀采样，三角形幅值波形，短恢复时间）：\n   - 采样时间（非均匀）：$t = [0, 1\\times 10^{-7}, 2.5\\times 10^{-7}, 2.6\\times 10^{-7}, 4\\times 10^{-7}, 8\\times 10^{-7}, 9\\times 10^{-7}]\\,\\mathrm{s}$。\n   - 潜在幅值（分段线性）：$j_{\\text{true}}(t)$从$t=0$时的$0\\,\\mathrm{A}$线性上升到$t=4\\times 10^{-7}\\,\\mathrm{s}$时的$8\\,\\mathrm{A}$，然后线性下降到$t=9\\times 10^{-7}\\,\\mathrm{s}$时的$0\\,\\mathrm{A}$。反向电流波形为$i_{RR}(t) = -j_{\\text{true}}(t)$。\n   - 测量噪声：$\\epsilon_n$是均值为零、标准差为$\\sigma = 0.02\\,\\mathrm{A}$的高斯噪声。\n   - 随机种子：$24680$。\n   - 测量样本：$i_n = i_{RR}(t_n) + \\epsilon_n$。\n\n对每个测试案例，计算：\n- 反向恢复电荷$Q_{rr}$，以$\\mathrm{C}$为单位，为一个正浮点数。\n- 一个以$\\mathrm{C}$为单位的单标准差不确定度$u$，该不确定度需同时考虑离散化和测量噪声。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例的结果是一个双元素列表$[Q_{rr},u]$，两个条目都以$\\mathrm{C}$为单位，例如，$[[q_1,u_1],[q_2,u_2],[q_3,u_3]]$。输出行中不得有空格。",
            "solution": "基本出发点是电流与电荷之间的关系，$i(t) = \\frac{dQ(t)}{dt}$，积分后得到$Q(t_2) - Q(t_1) = \\int_{t_1}^{t_2} i(t)\\,dt$。反向恢复电荷$Q_{rr}$定义为恢复事件期间反向电流大小的时间积分。如果反向电流表示为一个在恢复脉冲期间为负的有符号量$i_{RR}(t)$，那么$Q_{rr}$可以写为\n$$\nQ_{rr} = \\int_{t_s}^{t_e} \\left|i_{RR}(t)\\right|\\,dt = \\int_{t_s}^{t_e} \\max\\left(0, -i_{RR}(t)\\right)\\,dt,\n$$\n其中$[t_s,t_e]$是恢复区间。在提供的数据中，采样时间$t_n$是已知的，测量值为$i_n = i_{RR}(t_n) + \\epsilon_n$，其中$\\epsilon_n$是零均值噪声。\n\n为了从离散样本计算积分，我们采用一种基于黎曼和的复合数值积分方法。对于离散数据上的积分，一种有原则的估计方法是复合梯形法则。对于非均匀采样时间$t_0  t_1  \\dots  t_N$和相应的幅值$j_n = \\max(0, -i_n)$，梯形估计量为\n$$\n\\hat{Q}_{rr} = \\sum_{k=0}^{N-1} \\frac{j_k + j_{k+1}}{2}\\,\\Delta t_k, \\quad \\Delta t_k = t_{k+1} - t_k.\n$$\n这是通过将样本点之间的$j(t)$近似为分段线性直接导出的，这种方法保持了积分与定义$i(t)=\\frac{dQ}{dt}$的一致性，并避免了使用简化公式。估计量$\\hat{Q}_{rr}$是样本$\\{j_n\\}$的线性泛函，这使得基于原理的不确定度传播成为可能。\n\n由离散化（采样）产生的不确定度源于使用离散样本来近似连续函数的积分。对于足够平滑的波形，梯形法则在均匀网格上的误差尺度为$\\mathcal{O}(h^2)$，其中$h$是网格间距。一种在不知道高阶导数的情况下估计离散化不确定度的第一性原理方法是，比较在两个嵌套网格上计算的积分估计值：一个精细网格和一个通过抽取每隔一个样本创建的更粗糙的网格，两者都使用相同的梯形估计器。用$\\hat{Q}_h$表示使用精细网格的估计值，用$\\hat{Q}_{2h}$表示使用抽取后网格的估计值。用于均匀网格上梯形法则的Richardson外推法启发我们使用其差值来量化离散化偏差。一个保守的等效于单标准差的离散化不确定度可以取为\n$$\nu_{\\text{samp}} \\approx \\frac{\\left|\\hat{Q}_h - \\hat{Q}_{2h}\\right|}{3},\n$$\n需要注意的是，对于非均匀网格，这种方法提供了一个经验界限，它遵循相同的原则：更粗糙的网格抑制了高频内容，并揭示了积分对采样密度的敏感性。\n\n测量噪声不确定度是通过将$i_n = i_{RR}(t_n) + \\epsilon_n$建模为具有方差$\\sigma^2$的独立零均值噪声$\\epsilon_n$来推导的。由于积分估计量是样本的线性函数，它可以被重新表示为\n$$\n\\hat{Q}_{rr} = \\sum_{n=0}^{N} w_n\\,j_n,\n$$\n其中$\\{w_n\\}$是依赖于时间网格的合适权重。对于非均匀网格上的梯形法则，这些权重是\n$$\nw_0 = \\frac{\\Delta t_0}{2}, \\quad w_N = \\frac{\\Delta t_{N-1}}{2}, \\quad w_n = \\frac{\\Delta t_{n-1} + \\Delta t_n}{2} \\ \\text{for} \\ n=1,\\dots,N-1.\n$$\n如果测量噪声以方差$\\sigma^2$加性且独立地污染样本，那么积分估计量的方差是\n$$\n\\operatorname{Var}(\\hat{Q}_{rr}) = \\sigma^2 \\sum_{n=0}^{N} w_n^2,\n$$\n而单标准差噪声不确定度是\n$$\nu_{\\text{noise}} = \\sqrt{\\operatorname{Var}(\\hat{Q}_{rr})}.\n$$\n噪声标准差$\\sigma$必须根据测量数据$\\{i_n\\}$进行估计，其方式应在不预设波形的情况下将潜在信号与噪声分离。一种稳健的第一性原理方法是，通过移动平均平滑器估计潜在的平滑幅值$j(t)$，然后从残差中估计噪声水平。定义$j_n = \\max(0, -i_n)$，并让$\\tilde{j}_n$是用一个与波形时间尺度相比很小的窗口计算出的$j_n$的局部平均版本。残差$r_n = j_n - \\tilde{j}_n$捕捉了可归因于噪声的高频波动。那么，$\\sigma$的一个稳健估计是\n$$\n\\hat{\\sigma} = 1.4826 \\cdot \\operatorname{median}\\left(\\left|r_n\\right|\\right),\n$$\n该方法使用了针对高斯噪声的中位数绝对偏差（median absolute deviation）缩放，并基于统计学原理。如果由于噪声非常低或数据极其平滑导致$\\hat{\\sigma} = 0$，可以回退到使用$r_n$的样本标准差。\n\n假设离散化误差和测量噪声是独立的不确定度来源，则组合的单标准差不确定度可以通过平方和根（quadrature）报告：\n$$\nu = \\sqrt{u_{\\text{noise}}^2 + u_{\\text{samp}}^2}.\n$$\n这种组合方式与线性估计器中独立不确定度的传播相一致，并避免了使用简化公式。\n\n程序中实现的算法步骤：\n1. 对每个测试案例，使用规定的随机种子生成采样时间$\\{t_n\\}$和测量电流样本$\\{i_n\\}$。对于指数衰减案例，使用$i_{RR}(t) = -I_0 \\exp(-t/\\tau)$。对于三角形案例，构建分段线性幅值$j_{\\text{true}}(t)$并设置$i_{RR}(t) = -j_{\\text{true}}(t)$。添加具有指定标准差的高斯噪声$\\epsilon_n$。\n2. 计算$j_n = \\max(0, -i_n)$。\n3. 使用具有非均匀时间步长$\\Delta t_k$的复合梯形法则计算$\\hat{Q}_{rr}$。\n4. 通过抽取每隔一个样本并重新计算梯形积分来估计$u_{\\text{samp}}$；如果抽取后的网格至少有两个点，则取$u_{\\text{samp}} \\approx \\frac{|\\hat{Q}_h - \\hat{Q}_{2h}|}{3}$；否则设置$u_{\\text{samp}} = 0$。\n5. 通过对$j_n$进行移动平均平滑后的残差来估计$\\hat{\\sigma}$，并计算非均匀网格上梯形估计器的权重$w_n$。计算$u_{\\text{noise}} = \\sqrt{\\hat{\\sigma}^2 \\sum w_n^2}$。\n6. 通过$u = \\sqrt{u_{\\text{noise}}^2 + u_{\\text{samp}}^2}$组合不确定度。\n7. 对每个测试案例，输出以$\\mathrm{C}$为单位的对$[Q_{rr},u]$。\n\n输出以单行无空格的形式生成，包含一个按规定格式组织的、包含各测试案例结果的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef moving_average_reflect(x: np.ndarray, window: int) -> np.ndarray:\n    \"\"\"Compute a simple moving average with reflective padding to preserve length.\"\"\"\n    if window == 1:\n        return x.copy()\n    # Ensure window is odd\n    if window % 2 == 0:\n        window += 1\n    k = window // 2\n    # Reflective padding\n    pad = np.pad(x, (k, k), mode='reflect')\n    kernel = np.ones(window, dtype=float) / float(window)\n    return np.convolve(pad, kernel, mode='valid')\n\ndef trapezoid_nonuniform(t: np.ndarray, y: np.ndarray) -> float:\n    \"\"\"Composite trapezoid integration for nonuniform grid.\"\"\"\n    dt = np.diff(t)\n    return float(np.sum(dt * (y[:-1] + y[1:]) * 0.5))\n\ndef trapezoid_weights_nonuniform(t: np.ndarray) -> np.ndarray:\n    \"\"\"Weights for samples in nonuniform trapezoid integral.\"\"\"\n    N = len(t) - 1\n    if N  1:\n        return np.zeros(len(t))\n    dt = np.diff(t)\n    w = np.zeros(len(t), dtype=float)\n    w[0] = dt[0] / 2.0\n    w[-1] = dt[-1] / 2.0\n    if len(t) > 2:\n        w[1:-1] = (dt[:-1] + dt[1:]) / 2.0\n    return w\n\ndef estimate_noise_sigma(signal: np.ndarray) -> float:\n    \"\"\"Estimate noise sigma using robust MAD from residuals after moving average smoothing.\"\"\"\n    N = len(signal)\n    # Window length guided by data size, keep it modest to avoid over-smoothing.\n    # Use an odd window, min 3, max 25.\n    base = max(3, min(25, 2 * (max(1, N // 5)) + 1))\n    smooth = moving_average_reflect(signal, base)\n    residuals = signal - smooth\n    mad = np.median(np.abs(residuals))\n    sigma_hat = 1.4826 * mad\n    if sigma_hat == 0.0:\n        # Fallback to sample std if MAD yields zero\n        if N > 1:\n            sigma_hat = float(np.std(residuals, ddof=1))\n        else:\n            sigma_hat = 0.0\n    # Avoid exactly zero to keep uncertainty calculable\n    if sigma_hat == 0.0:\n        sigma_hat = 1e-15\n    return sigma_hat\n\ndef compute_Q_and_uncertainty(t: np.ndarray, i_meas: np.ndarray) -> (float, float):\n    \"\"\"Compute Q_rr via trapezoidal rule and estimate combined uncertainty.\"\"\"\n    # Ensure ascending times and align measurements\n    idx = np.argsort(t)\n    t = t[idx]\n    i_meas = i_meas[idx]\n    # Magnitude of reverse current (nonnegative)\n    j = np.maximum(0.0, -i_meas)\n\n    # Trapezoidal integral on full grid\n    Q_hat = trapezoid_nonuniform(t, j)\n\n    # Discretization uncertainty via decimated grid comparison\n    if len(t) >= 3:\n        t2 = t[::2]\n        j2 = j[::2]\n        if len(t2) >= 2:\n            Q_coarse = trapezoid_nonuniform(t2, j2)\n            u_samp = abs(Q_hat - Q_coarse) / 3.0\n        else:\n            u_samp = 0.0\n    else:\n        u_samp = 0.0\n\n    # Noise uncertainty via linear propagation\n    w = trapezoid_weights_nonuniform(t)\n    sigma_hat = estimate_noise_sigma(j)\n    var_noise = (sigma_hat ** 2) * float(np.sum(w ** 2))\n    u_noise = float(np.sqrt(var_noise))\n\n    # Combined uncertainty (independent sources)\n    u_total = float(np.sqrt(u_samp ** 2 + u_noise ** 2))\n    return Q_hat, u_total\n\ndef generate_test_case_1():\n    # Case 1: fine uniform sampling, exponential decay\n    I0 = 10.0  # A\n    tau = 4e-7  # s\n    dt = 2e-8  # s\n    t_end = 5e-6  # s\n    N = int(round(t_end / dt))\n    t = np.linspace(0.0, t_end, N + 1)\n    i_rr = -I0 * np.exp(-t / tau)\n    rng = np.random.default_rng(12345)\n    noise = rng.normal(loc=0.0, scale=0.05, size=t.shape)  # A\n    i_meas = i_rr + noise\n    return t, i_meas\n\ndef generate_test_case_2():\n    # Case 2: coarse uniform sampling, exponential decay\n    I0 = 10.0  # A\n    tau = 4e-7  # s\n    dt = 2e-7  # s\n    t_end = 5e-6  # s\n    N = int(round(t_end / dt))\n    t = np.linspace(0.0, t_end, N + 1)\n    i_rr = -I0 * np.exp(-t / tau)\n    rng = np.random.default_rng(13579)\n    noise = rng.normal(loc=0.0, scale=0.05, size=t.shape)  # A\n    i_meas = i_rr + noise\n    return t, i_meas\n\ndef generate_test_case_3():\n    # Case 3: nonuniform sampling, triangular magnitude waveform\n    t = np.array([0.0, 1e-7, 2.5e-7, 2.6e-7, 4e-7, 8e-7, 9e-7], dtype=float)\n    # Piecewise linear magnitude j_true\n    j_true = np.zeros_like(t)\n    # Rising to 8 A at 4e-7 s\n    for idx, tt in enumerate(t):\n        if tt = 4e-7:\n            j_true[idx] = (8.0 / (4e-7)) * tt\n        elif tt = 9e-7:\n            j_true[idx] = 8.0 + (-8.0 / (5e-7)) * (tt - 4e-7)\n        else:\n            j_true[idx] = 0.0\n    i_rr = -j_true\n    rng = np.random.default_rng(24680)\n    noise = rng.normal(loc=0.0, scale=0.02, size=t.shape)  # A\n    i_meas = i_rr + noise\n    return t, i_meas\n\ndef fmt_float(x: float) -> str:\n    # Format float compactly without spaces\n    return \"{:.12g}\".format(x)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        generate_test_case_1(),\n        generate_test_case_2(),\n        generate_test_case_3(),\n    ]\n\n    results = []\n    for t, i_meas in test_cases:\n        Q, u = compute_Q_and_uncertainty(t, i_meas)\n        results.append([Q, u])\n\n    # Build output string exactly as required: no spaces\n    inner = []\n    for pair in results:\n        inner.append(\"[\" + \",\".join(fmt_float(x) for x in pair) + \"]\")\n    print(\"[\" + \",\".join(inner) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}