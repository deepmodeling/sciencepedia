{
    "hands_on_practices": [
        {
            "introduction": "理论学习的最佳方式是动手实践。本节将通过一系列精心设计的练习，引导您从基本原理出发，逐步掌握空间矢量调制（SVM）的实现细节。第一个练习将带领您从零开始构建SVM算法的核心。您将学习如何根据给定的参考电压矢量确定其所在的扇区，并基于伏秒平衡原理，通过求解线性方程组来精确计算各个基本矢量在开关周期内的作用时间（dwell times），这是所有高级SVM策略的基础。",
            "id": "3882584",
            "problem": "您的任务是为空间矢量调制 (SVM) 设计一个通用算法，该算法将静止两相坐标系（$\\alpha$-$\\beta$ 平面）中指定的参考轨迹映射为一组离散的逆变器开关矢量，并计算相关的驻留时间。其应用背景为三相两电平电压源逆变器 (VSI)。目标是推导并实现一个算法，该算法从第一性原理出发，执行参考矢量映射、扇区检测和驻留时间计算，而不依赖于预先推导的简化公式。\n\n从以下基本定义和事实开始：\n\n- 设直流 (DC) 母线电压表示为 $V_{\\mathrm{dc}}$，采样周期表示为 $T_{\\mathrm{s}}$（每个开关周期的时间）。\n- 对于三相两电平 VSI，每个桥臂产生一个相到虚拟中点的电压 $v_a, v_b, v_c \\in \\{\\pm V_{\\mathrm{dc}}/2\\}$，具体取决于上桥臂还是下桥臂的开关导通。设每个桥臂的开关状态为 $s_a, s_b, s_c \\in \\{+1,-1\\}$，其中 $+1$ 对应 $+V_{\\mathrm{dc}}/2$，$-1$ 对应 $-V_{\\mathrm{dc}}/2$。\n- 将三相电压 $(v_a,v_b,v_c)$ 映射到 $\\alpha$-$\\beta$ 分量 $(v_\\alpha,v_\\beta)$ 的静止两相 (Clarke) 变换定义如下：\n  $$\n  v_\\alpha = \\frac{2}{3}\\left(v_a - \\frac{1}{2}v_b - \\frac{1}{2}v_c\\right),\\quad\n  v_\\beta = \\frac{2}{3}\\left(\\frac{\\sqrt{3}}{2}(v_b - v_c)\\right).\n  $$\n  将 $v_a = s_a\\frac{V_{\\mathrm{dc}}}{2}$、$v_b = s_b\\frac{V_{\\mathrm{dc}}}{2}$ 和 $v_c = s_c\\frac{V_{\\mathrm{dc}}}{2}$ 代入，可得到逆变器在 $\\alpha$-$\\beta$ 平面内的空间矢量。\n- 六个有效开关矢量（非零）以 $60^\\circ$ 的间隔出现，并且具有相同的幅值。它们的精确坐标由上述开关三元组的定义得出：\n  $$\n  \\begin{aligned}\n  \\mathbf{V}_1  (s_a,s_b,s_c) = (+1,-1,-1), \\\\\n  \\mathbf{V}_2  (s_a,s_b,s_c) = (+1,+1,-1), \\\\\n  \\mathbf{V}_3  (s_a,s_b,s_c) = (-1,+1,-1), \\\\\n  \\mathbf{V}_4  (s_a,s_b,s_c) = (-1,+1,+1), \\\\\n  \\mathbf{V}_5  (s_a,s_b,s_c) = (-1,-1,+1), \\\\\n  \\mathbf{V}_6  (s_a,s_b,s_c) = (+1,-1,+1). \\\\\n  \\end{aligned}\n  $$\n  每个 $\\mathbf{V}_k$ 均通过上述 Clarke 变换计算得出，其幅值为 $|\\mathbf{V}_k| = \\frac{2}{3}V_{\\mathrm{dc}}$。\n- 零开关矢量集对应于 $(s_a,s_b,s_c)=(+1,+1,+1)$ 或 $(-1,-1,-1)$，这两种状态都映射到零矢量 $\\mathbf{0}$。\n\n参考矢量规范：\n\n- 所需的参考电压矢量由其极坐标形式 $(V_{\\mathrm{ref}}, \\theta)$ 给出，其中 $V_{\\mathrm{ref}}$ 是幅值，$\\theta$ 是角度。全文使用弧度作为角度单位。该参考矢量通过以下方式映射到 $\\alpha$-$\\beta$ 平面：\n  $$\n  v_\\alpha = V_{\\mathrm{ref}}\\cos(\\theta),\\quad v_\\beta = V_{\\mathrm{ref}}\\sin(\\theta).\n  $$\n\n扇区检测：\n\n- 将扇区索引 $k\\in\\{1,2,3,4,5,6\\}$ 定义为 $\\alpha$-$\\beta$ 平面中由两个相邻有效开关矢量界定的区域，角度 $\\theta$ 位于该区域内。使用以下规则：\n  $$\n  \\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi,\\quad\n  k = 1 + \\left\\lfloor \\frac{\\theta_{\\mathrm{mod}}}{\\pi/3} \\right\\rfloor,\n  $$\n  约定如果 $V_{\\mathrm{ref}}=0$，则设 $k=0$，并且所有驻留时间都在零矢量上。\n- 对于恰好在扇区边界上的角度，即 $\\theta_{\\mathrm{mod}}$ 等于 $\\pi/3$ 的整数倍时，直接使用上述公式（这将边界分配给编号较大的扇区，但 $\\theta_{\\mathrm{mod}}=0$ 除外，它映射到 $k=1$）。\n\n驻留时间计算：\n\n- 在一个开关周期 $T_{\\mathrm{s}}$ 内，参考矢量的积分必须等于所施加的逆变器矢量的时间加权和：\n  $$\n  T_1\\,\\mathbf{V}_k + T_2\\,\\mathbf{V}_{k+1} + T_0\\,\\mathbf{0} = T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}},\n  $$\n  其中 $T_1\\ge 0$, $T_2\\ge 0$, $T_0\\ge 0$，且 $T_1+T_2+T_0 = T_{\\mathrm{s}}$。\n- 通过求解由 $\\mathbf{V}_k$ 和 $\\mathbf{V}_{k+1}$ 的 $\\alpha$-$\\beta$ 分量与 $T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}}$ 构成的 $2\\times 2$ 线性系统，可以得到 $(T_1,T_2)$。零矢量驻留时间为 $T_0=T_{\\mathrm{s}}-T_1-T_2$。\n- 将驻留时间归一化为占空比 $d_1=T_1/T_{\\mathrm{s}}$，$d_2=T_2/T_{\\mathrm{s}}$，$d_0=T_0/T_{\\mathrm{s}}$，并强制要求 $d_1,d_2,d_0\\in[0,1]$ 且 $d_1+d_2+d_0=1$。\n\n线性区域约束：\n\n- 线性调制区对应于由有效矢量张成的六边形的内部。沿扇区角平分线可达到的最大径向参考幅值等于 $V_{\\mathrm{dc}}/\\sqrt{3}$。如果 $V_{\\mathrm{ref}} > V_{\\mathrm{dc}}/\\sqrt{3}$，则通过设置 $V_{\\mathrm{ref}} \\leftarrow V_{\\mathrm{dc}}/\\sqrt{3}$ 进行饱和处理，同时保持 $\\theta$ 不变。这确保了 $d_0\\ge 0$ 并避免了本问题中的过调制。\n\n单位：\n\n- $V_{\\mathrm{dc}}$ 和 $V_{\\mathrm{ref}}$ 以伏特 (V) 表示，$T_{\\mathrm{s}}$ 以秒 (s) 表示，角度 $\\theta$ 以弧度表示。占空比 $d_1$、$d_2$、$d_0$ 是无量纲的。\n\n您的程序必须实现：\n\n1. 将 $(V_{\\mathrm{ref}},\\theta)$ 映射到 $(v_\\alpha,v_\\beta)$，并在必要时饱和到线性边界 $V_{\\mathrm{dc}}/\\sqrt{3}$。\n2. 根据上述规则进行扇区检测，对负角度使用取模运算，并在扇区边界上进行决断。\n3. 通过开关状态经由 Clarke 变换构建两个相邻的有效矢量 $\\mathbf{V}_k$ 和 $\\mathbf{V}_{k+1}$，并求解 $2\\times 2$ 线性系统以获得驻留时间。\n4. 对占空比进行归一化和裁剪，以使 $d_1,d_2,d_0\\in[0,1]$ 且 $d_1+d_2+d_0=1$。\n\n测试套件：\n\n使用以下测试用例 $(V_{\\mathrm{dc}}, T_{\\mathrm{s}}, V_{\\mathrm{ref}}, \\theta)$:\n\n- 用例 1 (通用内部点): $(600,\\ 1\\times 10^{-4},\\ 300,\\ 0.7)$。\n- 用例 2 (位于扇区边界): $(540,\\ 5\\times 10^{-5},\\ 200,\\ \\pi/3)$。\n- 用例 3 (需要饱和): $(700,\\ 2\\times 10^{-4},\\ 420,\\ 5.5)$。\n- 用例 4 (零矢量): $(800,\\ 1\\times 10^{-4},\\ 0,\\ 2.0)$。\n- 用例 5 (负半轴): $(500,\\ 1.5\\times 10^{-4},\\ 100,\\ \\pi)$。\n- 用例 6 (负角度): $(650,\\ 7\\times 10^{-5},\\ 150,\\ -0.1)$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是四元列表 $[k,d_1,d_2,d_0]$，其中 $k$ 是整数，$d_1$、$d_2$、$d_0$ 是四舍五入到10位小数的实数。输出字符串中不得有空格。例如：\n  $$\n  [[k_1,d_{1,1},d_{2,1},d_{0,1}],[k_2,d_{1,2},d_{2,2},d_{0,2}],\\dots]\n  $$",
            "solution": "我们通过结合两电平逆变器的物理原理、Clarke 变换和空间矢量六边形的几何结构来设计算法。关键步骤如下：\n\n1. 逆变器开关状态到空间矢量的基本映射。\n\n三相两电平电压源逆变器 (VSI) 的桥臂电压为 $v_a, v_b, v_c \\in \\{\\pm V_{\\mathrm{dc}}/2\\}$，由开关状态 $s_a,s_b,s_c\\in\\{+1,-1\\}$ 决定。静止坐标系 (Clarke) 变换将 $(v_a,v_b,v_c)$ 映射到 $(v_\\alpha,v_\\beta)$：\n$$\nv_\\alpha = \\frac{2}{3}\\left(v_a - \\frac{1}{2}v_b - \\frac{1}{2}v_c\\right),\\quad\nv_\\beta = \\frac{2}{3}\\left(\\frac{\\sqrt{3}}{2}(v_b - v_c)\\right).\n$$\n代入 $v_a = s_a\\frac{V_{\\mathrm{dc}}}{2}$、$v_b = s_b\\frac{V_{\\mathrm{dc}}}{2}$、$v_c = s_c\\frac{V_{\\mathrm{dc}}}{2}$，我们得到\n$$\nv_\\alpha = \\frac{V_{\\mathrm{dc}}}{3}\\left(s_a - \\frac{1}{2}s_b - \\frac{1}{2}s_c\\right),\\quad\nv_\\beta = \\frac{V_{\\mathrm{dc}}\\sqrt{3}}{6}(s_b - s_c).\n$$\n有六个有效矢量 $\\mathbf{V}_k$，对应于两个桥臂为 $+1$、一个桥臂为 $-1$ 的开关三元组，以及与之互补的、两个桥臂为 $-1$、一个桥臂为 $+1$ 的三种状态。按角度排序得到：\n$$\n\\begin{aligned}\n\\mathbf{V}_1  (s_a,s_b,s_c)=(+1,-1,-1),\\\\\n\\mathbf{V}_2  (s_a,s_b,s_c)=(+1,+1,-1),\\\\\n\\mathbf{V}_3  (s_a,s_b,s_c)=(-1,+1,-1),\\\\\n\\mathbf{V}_4  (s_a,s_b,s_c)=(-1,+1,+1),\\\\\n\\mathbf{V}_5  (s_a,s_b,s_c)=(-1,-1,+1),\\\\\n\\mathbf{V}_6  (s_a,s_b,s_c)=(+1,-1,+1).\n\\end{aligned}\n$$\n每个矢量的幅值为 $|\\mathbf{V}_k| = \\frac{2}{3}V_{\\mathrm{dc}}$，且相互间隔 $60^\\circ$。\n\n2. 参考轨迹映射。\n\n所需的参考矢量由极坐标 $(V_{\\mathrm{ref}},\\theta)$ 指定，其 $(v_\\alpha,v_\\beta)$ 分量由下式确定：\n$$\nv_\\alpha = V_{\\mathrm{ref}}\\cos(\\theta),\\quad v_\\beta = V_{\\mathrm{ref}}\\sin(\\theta).\n$$\n线性区域内的 SVM 要求参考矢量位于由六个有效矢量张成的六边形内部。在线性区域内，沿扇区角平分线可达到的最大径向幅值等于 $V_{\\mathrm{dc}}/\\sqrt{3}$，这是通过考虑扇区三角形内最长的组合在 $T_1=T_2=T_{\\mathrm{s}}/2$ 时发生而得到的，得出：\n$$\n\\left|\\frac{T_{\\mathrm{s}}}{2}\\mathbf{V}_k + \\frac{T_{\\mathrm{s}}}{2}\\mathbf{V}_{k+1}\\right| = \\frac{T_{\\mathrm{s}}}{2}\\left|\\mathbf{V}_k + \\mathbf{V}_{k+1}\\right| = \\frac{T_{\\mathrm{s}}}{2}\\cdot \\frac{4}{3}V_{\\mathrm{dc}}\\cos\\left(\\frac{\\pi}{6}\\right) = T_{\\mathrm{s}}\\cdot \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}},\n$$\n因此归一化最大值为 $V_{\\mathrm{dc}}/\\sqrt{3}$。我们因此进行饱和处理：\n$$\nV_{\\mathrm{ref}} \\leftarrow \\min\\left(V_{\\mathrm{ref}},\\frac{V_{\\mathrm{dc}}}{\\sqrt{3}}\\right),\n$$\n同时保持角度 $\\theta$ 不变。\n\n3. 扇区检测。\n\n与六边形的几何结构对齐，我们根据对 $2\\pi$ 取模后的角度定义扇区索引 $k$：\n$$\n\\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi,\\quad\nk = 1 + \\left\\lfloor \\frac{\\theta_{\\mathrm{mod}}}{\\pi/3}\\right\\rfloor.\n$$\n当 $V_{\\mathrm{ref}}=0$ 时，设 $k=0$（零矢量）。对于恰好在 $\\pi/3$ 整数倍的边界角度，该定义将其映射到编号较大的扇区，但 $\\theta_{\\mathrm{mod}}=0$ 除外，它映射到 $k=1$。\n\n4. 驻留时间推导。\n\n在每个开关周期 $T_{\\mathrm{s}}$ 内，逆变器在一个扇区内最多施加三个矢量：两个相邻的有效矢量 $\\mathbf{V}_k, \\mathbf{V}_{k+1}$ 和零矢量 $\\mathbf{0}$。在 $T_{\\mathrm{s}}$ 内的电压积分必须等于参考矢量的积分：\n$$\nT_1\\,\\mathbf{V}_k + T_2\\,\\mathbf{V}_{k+1} + T_0\\,\\mathbf{0} = T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}},\n$$\n其中 $T_1,T_2,T_0\\ge 0$ 且 $T_1+T_2+T_0=T_{\\mathrm{s}}$。在 $\\alpha$-$\\beta$ 平面内按分量写出，得到一个关于 $(T_1,T_2)$ 的 $2\\times 2$ 线性系统：\n$$\n\\begin{bmatrix}\nV_{k,\\alpha}  V_{k+1,\\alpha} \\\\\nV_{k,\\beta}  V_{k+1,\\beta}\n\\end{bmatrix}\n\\begin{bmatrix}\nT_1\\\\\nT_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nT_{\\mathrm{s}}\\,v_\\alpha\\\\\nT_{\\mathrm{s}}\\,v_\\beta\n\\end{bmatrix}.\n$$\n求解 $(T_1,T_2)$ 得到有效矢量驻留时间，零矢量驻留时间则为 $T_0=T_{\\mathrm{s}}-T_1-T_2$。归一化为占空比：\n$$\nd_1 = \\frac{T_1}{T_{\\mathrm{s}}},\\quad d_2 = \\frac{T_2}{T_{\\mathrm{s}}},\\quad d_0 = \\frac{T_0}{T_{\\mathrm{s}}}.\n$$\n我们通过将（由于数值舍入产生的）负值裁剪为0并相应调整 $d_0$ 来强制 $d_1,d_2,d_0\\in[0,1]$ 且 $d_1+d_2+d_0=1$。饱和步骤确保在线性区域内 $d_1+d_2\\le 1$。\n\n5. 每个测试用例的算法总结：\n\n- 计算 $V_{\\mathrm{lim}} = V_{\\mathrm{dc}}/\\sqrt{3}$ 并设置 $V_{\\mathrm{ref}} \\leftarrow \\min(V_{\\mathrm{ref}},V_{\\mathrm{lim}})$。\n- 如果 $V_{\\mathrm{ref}}=0$，输出 $k=0$ 和 $(d_1,d_2,d_0)=(0,0,1)$。\n- 否则，计算 $\\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi$ 和扇区 $k=1+\\left\\lfloor\\theta_{\\mathrm{mod}}/(\\pi/3)\\right\\rfloor$。\n- 计算 $(v_\\alpha,v_\\beta)=(V_{\\mathrm{ref}}\\cos\\theta_{\\mathrm{mod}},\\,V_{\\mathrm{ref}}\\sin\\theta_{\\mathrm{mod}})$。\n- 使用上面给出的开关三元组和 Clarke 变换表达式构建有效矢量 $\\mathbf{V}_k$ 和 $\\mathbf{V}_{k+1}$。\n- 求解 $2\\times 2$ 系统得到 $(T_1,T_2)$，归一化得到 $(d_1,d_2)$，设置 $d_0=1-d_1-d_2$，裁剪到 $[0,1]$ 区间，并确保 $d_1+d_2+d_0=1$（考虑浮点数舍入误差）。\n- 将 $d_1,d_2,d_0$ 四舍五入到10位小数用于输出。\n\n6. 输出规范：\n\n为每个测试用例返回列表 $[k,d_1,d_2,d_0]$，并将所有结果聚合成单行，格式为用方括号括起来的逗号分隔列表，不含空格。占空比四舍五入到10位小数。\n\n该算法基于逆变器的物理模型、Clarke 变换以及将参考矢量直接分解到六边形相邻基矢量上的几何方法，从而避免了对简化的三角函数表达式的依赖，并通过线性代数确保了其正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef clarke_transform_vector(Vdc, s_a, s_b, s_c):\n    \"\"\"\n    Compute the alpha-beta components of the inverter space vector\n    for switching states s_a, s_b, s_c in {+1, -1} given DC bus voltage Vdc.\n    \"\"\"\n    v_a = s_a * Vdc / 2.0\n    v_b = s_b * Vdc / 2.0\n    v_c = s_c * Vdc / 2.0\n    v_alpha = (2.0/3.0) * (v_a - 0.5*v_b - 0.5*v_c)\n    v_beta  = (2.0/3.0) * ((np.sqrt(3)/2.0) * (v_b - v_c))\n    return np.array([v_alpha, v_beta], dtype=float)\n\ndef active_vectors(Vdc):\n    \"\"\"\n    Return the six active vectors (V1..V6) in alpha-beta coordinates for the given Vdc.\n    Ordered by angle: 0, 60deg, 120deg, 180deg, 240deg, 300deg.\n    Switching triplets as per problem statement.\n    \"\"\"\n    states = [\n        (+1, -1, -1),  # V1\n        (+1, +1, -1),  # V2\n        (-1, +1, -1),  # V3\n        (-1, +1, +1),  # V4\n        (-1, -1, +1),  # V5\n        (+1, -1, +1),  # V6\n    ]\n    return [clarke_transform_vector(Vdc, *st) for st in states]\n\ndef detect_sector(theta, vref_mag):\n    \"\"\"\n    Detect sector index k in {1..6} from angle theta (radians).\n    If vref_mag == 0, return k=0.\n    Boundary angles assigned to higher-numbered sector except 0->1 implicitly by floor.\n    \"\"\"\n    if vref_mag == 0.0:\n        return 0\n    two_pi = 2.0*np.pi\n    theta_mod = theta % two_pi\n    sector = int(np.floor(theta_mod / (np.pi/3.0))) + 1\n    # sector in 1..6\n    return sector\n\ndef compute_duty_ratios(Vdc, Ts, Vref, theta):\n    \"\"\"\n    Compute [sector, d1, d2, d0] for given parameters, with saturation and normalization.\n    \"\"\"\n    # Saturation to linear SVM boundary\n    Vlim = Vdc / np.sqrt(3.0)\n    Vref_sat = min(Vref, Vlim)\n\n    # Handle null vector case\n    if Vref_sat == 0.0:\n        return [0, 0.0, 0.0, 1.0]\n\n    # Angle modulo 2*pi\n    theta_mod = theta % (2.0*np.pi)\n    k = detect_sector(theta_mod, Vref_sat)\n\n    # Reference components\n    v_alpha = Vref_sat * np.cos(theta_mod)\n    v_beta = Vref_sat * np.sin(theta_mod)\n    v_ref = np.array([v_alpha, v_beta], dtype=float)\n\n    # Get adjacent active vectors for sector k\n    vecs = active_vectors(Vdc)\n    V_k = vecs[k-1]\n    V_k1 = vecs[(k % 6)]  # wrap around for k+1\n    # Construct 2x2 matrix A and RHS b = Ts*v_ref\n    A = np.column_stack((V_k, V_k1))  # shape (2,2)\n    b = Ts * v_ref\n    # Solve for T1, T2\n    try:\n        T = np.linalg.solve(A, b)\n        T1, T2 = float(T[0]), float(T[1])\n    except np.linalg.LinAlgError:\n        # Fallback in degenerate case (should not occur for valid active vectors)\n        T1, T2 = 0.0, 0.0\n\n    # Normalize to duty ratios\n    d1 = T1 / Ts\n    d2 = T2 / Ts\n    # Clip tiny negative due to numerical errors\n    eps = 1e-12\n    if d1  0.0 and d1 > -eps:\n        d1 = 0.0\n    if d2  0.0 and d2 > -eps:\n        d2 = 0.0\n    # Ensure non-negativity\n    d1 = max(0.0, d1)\n    d2 = max(0.0, d2)\n    # Compute d0 and enforce sum to 1 within numerical tolerance\n    d0 = 1.0 - d1 - d2\n    if d0  0.0 and d0 > -eps:\n        d0 = 0.0\n    # If due to numerical issues sum exceeds 1 slightly, scale d1,d2\n    sum_d = d1 + d2 + d0\n    if abs(sum_d - 1.0) > 5e-12:\n        # Normalize the trio to sum to 1 while preserving non-negativity\n        total = d1 + d2\n        if total > 1.0:\n            # Saturate zero dwell\n            d1 = d1 / total\n            d2 = d2 / total\n            d0 = 0.0\n        else:\n            d0 = 1.0 - total\n    # Round to 10 decimal places for output\n    d1 = round(d1, 10)\n    d2 = round(d2, 10)\n    d0 = round(d0, 10)\n    return [k, d1, d2, d0]\n\ndef format_result_list(results):\n    \"\"\"\n    Format the list of per-case results [[k,d1,d2,d0], ...] with no spaces\n    and floating numbers already rounded to 10 decimal places.\n    \"\"\"\n    parts = []\n    for res in results:\n        k, d1, d2, d0 = res\n        # Ensure integer for k\n        k_str = str(int(k))\n        # Floats: format with 10 decimal places\n        d1_str = f\"{d1:.10f}\"\n        d2_str = f\"{d2:.10f}\"\n        d0_str = f\"{d0:.10f}\"\n        parts.append(f\"[{k_str},{d1_str},{d2_str},{d0_str}]\")\n    return f\"[{','.join(parts)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (Vdc [V], Ts [s], Vref [V], theta [rad])\n    test_cases = [\n        (600.0, 1e-4, 300.0, 0.7),               # Case 1\n        (540.0, 5e-5, 200.0, np.pi/3.0),         # Case 2\n        (700.0, 2e-4, 420.0, 5.5),               # Case 3\n        (800.0, 1e-4, 0.0, 2.0),                 # Case 4\n        (500.0, 1.5e-4, 100.0, np.pi),           # Case 5\n        (650.0, 7e-5, 150.0, -0.1),              # Case 6\n    ]\n\n    results = []\n    for Vdc, Ts, Vref, theta in test_cases:\n        res = compute_duty_ratios(Vdc, Ts, Vref, theta)\n        results.append(res)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_result_list(results))\n\nsolve()\n```"
        },
        {
            "introduction": "计算出各矢量的作用时间后，下一步是决定在一个开关周期内如何排列这些矢量，即开关序列。不同的开关序列会产生不同的开关损耗和共模电压特性，而这些对于电机驱动系统的性能至关重要。本练习将引导您设计一个开关序列，以最小化开关次数（从而降低开关损耗），并量化由此产生的共模电压均方根值。通过这个练习，您将把抽象的调制算法与逆变器的物理性能指标（如效率和电磁干扰）联系起来。",
            "id": "3837777",
            "problem": "给定一个两电平三相电压源逆变器 (VSI)，该逆变器采用空间矢量调制 (SVM) 技术驱动一台电机。逆变器的桥臂被建模为连接到电压为 $V_{\\mathrm{dc}}$ 的直流 (DC) 母线上的理想开关。每个桥臂 $x \\in \\{a,b,c\\}$ 都有一个二进制开关状态 $S_x \\in \\{0,1\\}$，其中 $S_x=1$ 表示上管导通，$S_x=0$ 表示下管导通。相对于直流母线中点，桥臂极点电压为 $v_{xN} = (2 S_x - 1)\\, V_{\\mathrm{dc}}/2$。相对于电机星形接线点的相端电压 $v_a$、$v_b$ 和 $v_c$ 满足 $v_x = v_{xN} - v_{\\mathrm{cm}}$，其中共模电压 $v_{\\mathrm{cm}}$ 定义为 $v_{\\mathrm{cm}} = (v_{aN} + v_{bN} + v_{cN})/3$。\n\n您的任务是，在一个开关周期内，根据期望的定子电压空间矢量轨迹，计算一个能够最小化总开关转换次数的开关序列，并量化由此产生的共模电压。该轨迹由空间矢量幅值 $V_{\\mathrm{ref}}$ 和电角度 $\\theta$（以弧度为单位）指定；直流母线电压 $V_{\\mathrm{dc}}$ 和开关周期 $T_s$ 也已给出。初始条件是逆变器前一周期的结束状态 $s_{\\mathrm{prev}}$，该状态被编码为一个整数 $s \\in \\{0,1,2,\\dots,7\\}$，映射关系为 $s = 4 S_a + 2 S_b + S_c$，其中 $S_a$、$S_b$ 和 $S_c$ 分别是 a、b、c 三相的桥臂状态。\n\n需使用的基本原理和约束条件：\n- Clarke变换和空间矢量表示法将三相电压简化为一个 $\\alpha\\beta$ 平面上的矢量。可行的逆变器空间矢量包括六个大小相等、角度相隔 $ \\pi/3 $ 弧度的非零有效矢量，以及位于原点的两个零矢量。\n- 在一个开关周期 $T_s$ 内，通过在两个相邻的有效矢量和（可能存在的）零矢量上驻留，来合成期望的平均参考矢量。我们将两个相邻有效矢量之间的角度范围定义为扇区。对于一个角度 $\\theta$ 位于某扇区内的期望矢量 $V_{\\mathrm{ref}}$，其相邻有效矢量的两个驻留时间 $T_1$ 和 $T_2$ 以及剩余的零矢量时间 $T_0=T_s - T_1 - T_2$ 必须通过在 $\\alpha\\beta$ 平面中求解矢量平均方程，从第一性原理推导得出。推导过程中不得使用任何捷径或预制公式；您必须基于上述的几何关系和桥臂电压模型进行推导。\n- 每个开关状态下的共模电压水平必须由 $v_{\\mathrm{cm}} = (v_{aN} + v_{bN} + v_{cN})/3$ 确定。您必须将开关周期内的共模电压均方根 (RMS) 值量化为 $V_{\\mathrm{cm,RMS}} = \\sqrt{\\left( \\sum_i t_i\\, v_{\\mathrm{cm},i}^2\\right) / T_s }$，其中 $t_i$ 和 $v_{\\mathrm{cm},i}$ 是第 $i$ 个子区间的驻留时间和共模电压。\n- 一个周期内的开关序列被限制为按顺序排列的四个子区间：从一个零矢量开始，然后驻留在第一个有效矢量上，接着是第二个有效矢量，最后以一个零矢量结束。这两个有效矢量必须是已确定扇区中的相邻矢量。零矢量可以是 $s=0$（所有下管导通）或 $s=7$（所有上管导通）。总的零矢量驻留时间 $T_0$ 必须在开始和结束时平均分配，因此每个零矢量子区间的持续时间为 $T_0/2$。在所有通过选择起始和结束零矢量以及两个有效矢量的顺序而构成的候选序列中，选择总开关转换次数最少的那一个。总转换次数是周期内所有连续状态对（包括从前一周期的结束状态 $s_{\\mathrm{prev}}$ 到起始零矢量的转换）的三个桥臂状态位之间汉明距离的总和。\n- 角度必须以弧度为单位。所有电压答案必须以伏特表示，时间以秒表示。\n\n测试套件和要求的输出：\n- 实现一个程序，对于每个测试用例 $(V_{\\mathrm{dc}}, T_s, V_{\\mathrm{ref}}, \\theta, s_{\\mathrm{prev}})$，计算：\n    1) 选定的四状态开关序列，表示为一个整数列表 $[s_1,s_2,s_3,s_4]$，使用编码 $s = 4 S_a + 2 S_b + S_c$，以及\n    2) 开关周期内的共模电压均方根值 $V_{\\mathrm{cm,RMS}}$，以伏特为单位。\n- 使用以下测试用例，每个元组为 $(V_{\\mathrm{dc}}, T_s, V_{\\mathrm{ref}}, \\theta, s_{\\mathrm{prev}})$：\n    1) $(600,\\; 1.0\\times 10^{-4},\\; 200,\\; 0.3,\\; 0)$，\n    2) $(600,\\; 1.0\\times 10^{-4},\\; 330,\\; \\pi/3 - 10^{-6},\\; 7)$，\n    3) $(600,\\; 1.0\\times 10^{-4},\\; 1,\\; 2.0,\\; 3)$，\n    4) $(600,\\; 1.0\\times 10^{-4},\\; 340,\\; 4.2,\\; 2)$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个结果都是一个二元列表 $[\\,[s_1,s_2,s_3,s_4],\\; V_{\\mathrm{cm,RMS}}\\,]$。例如：$[[[s_1,s_2,s_3,s_4],V_1],[[...],V_2],...]$。数值必须是浮点数或整数，其中 RMS 值以伏特表示。\n\n您的实现必须是完全自包含的，不得读取任何输入，也不得使用任何外部文件或网络访问。推导必须基于上述的桥臂电压模型和空间矢量几何，并且必须避免使用问题陈述中的捷径公式。",
            "solution": "所提供的问题是有效的，因为它在科学上基于电力电子和电机控制的原理，特别是空间矢量调制 (SVM)。该问题是适定的、客观的，并包含推导唯一解所需的所有必要信息。数值在电压源逆变器驱动系统的实际范围内。我将进行完整的推导和求解。\n\n求解过程包括以下几个步骤：\n1.  从给定的桥臂电压模型推导逆变器的空间电压矢量。\n2.  从第一性原理推导 SVM 算法的驻留时间。\n3.  构建优化问题，以选择一个能最小化开关转换次数的开关序列。\n4.  推导共模电压的均方根 (RMS) 值。\n5.  将此方法应用于所提供的测试用例。\n\n**1. 逆变器空间矢量**\n\n一个两电平三相逆变器有 $2^3 = 8$ 种可能的开关状态，由三元组 $(S_a, S_b, S_c)$ 定义，其中 $S_x \\in \\{0, 1\\}$。状态被编码为一个整数 $s = 4S_a + 2S_b + S_c$。相对于直流母线中点，每个桥臂极点的电压由 $v_{xN} = (S_x - 1/2)V_{\\mathrm{dc}}$ 给出。\n\n使用幅值不变Clarke变换，将三相电压转换为二维空间矢量 $\\mathbf{v} = v_\\alpha + j v_\\beta$：\n$$ v_\\alpha = \\frac{2}{3}(v_{aN} - \\frac{1}{2}v_{bN} - \\frac{1}{2}v_{cN}) $$\n$$ v_\\beta = \\frac{2}{3}\\frac{\\sqrt{3}}{2}(v_{bN} - v_{cN}) = \\frac{1}{\\sqrt{3}}(v_{bN} - v_{cN}) $$\n代入 $v_{xN}$ 的表达式：\n$$ v_\\alpha = \\frac{2}{3} V_{\\mathrm{dc}} \\left[ (S_a - \\frac{1}{2}) - \\frac{1}{2}(S_b - \\frac{1}{2}) - \\frac{1}{2}(S_c - \\frac{1}{2}) \\right] = \\frac{V_{\\mathrm{dc}}}{3} (2S_a - S_b - S_c) $$\n$$ v_\\beta = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}} \\left[ (S_b - \\frac{1}{2}) - (S_c - \\frac{1}{2}) \\right] = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}} (S_b - S_c) $$\n使用这些公式，8个状态产生8个电压矢量。状态 $s=0$ $(000)$ 和 $s=7$ $(111)$ 产生零矢量 ($\\mathbf{V}_0 = \\mathbf{V}_7 = 0$)。其他6个状态产生幅值为 $\\frac{2}{3}V_{\\mathrm{dc}}$ 的有效矢量，角度相隔 $\\pi/3$ 弧度，在 $\\alpha\\beta$ 平面上形成一个六边形。标准的有效矢量及其对应状态如下：\n- $\\mathbf{V}_1$ (状态 $s=4, 100$): 角度 $0$\n- $\\mathbf{V}_2$ (状态 $s=6, 110$): 角度 $\\pi/3$\n- $\\mathbf{V}_3$ (状态 $s=2, 010$): 角度 $2\\pi/3$\n- $\\mathbf{V}_4$ (状态 $s=3, 011$): 角度 $\\pi$\n- $\\mathbf{V}_5$ (状态 $s=1, 001$): 角度 $4\\pi/3$\n- $\\mathbf{V}_6$ (状态 $s=5, 101$): 角度 $5\\pi/3$\n\n**2. 从第一性原理推导驻留时间**\n\nSVM 通过在一个开关周期 $T_s$ 内对两个相邻的有效矢量和一个零矢量进行平均，来合成参考电压矢量 $\\mathbf{V}_{\\mathrm{ref}} = V_{\\mathrm{ref}} e^{j\\theta}$。其平均原理是：\n$$ \\mathbf{V}_{\\mathrm{ref}} = \\frac{1}{T_s}(T_1 \\mathbf{V}_k + T_2 \\mathbf{V}_{k+1} + T_0 \\mathbf{V}_{\\mathrm{zero}}) $$\n其中 $\\mathbf{V}_k$ 和 $\\mathbf{V}_{k+1}$ 是界定包含 $\\mathbf{V}_{\\mathrm{ref}}$ 的扇区的两个有效矢量，$T_1$ 和 $T_2$ 是它们各自的驻留时间。$T_0$ 是零矢量的总驻留时间。由于 $\\mathbf{V}_{\\mathrm{zero}}=0$，方程简化为 $T_s \\mathbf{V}_{\\mathrm{ref}} = T_1 \\mathbf{V}_k + T_2 \\mathbf{V}_{k+1}$。总时间受约束于 $T_s = T_1 + T_2 + T_0$。\n\n为了求解 $T_1$ 和 $T_2$，我们将矢量方程投影到一个正交基上。我们定义一个坐标系，其u轴与第一个有效矢量 $\\mathbf{V}_k$ 对齐。设扇区索引为 $k_{sec} \\in \\{0, \\dots, 5\\}$，使得 $\\mathbf{V}_{\\mathrm{ref}}$ 位于角度为 $k_{sec}\\pi/3$ 和 $(k_{sec}+1)\\pi/3$ 的矢量之间。$\\mathbf{V}_{\\mathrm{ref}}$ 在扇区内的角度是 $\\theta' = \\theta - k_{sec}\\pi/3$。\n在这个旋转坐标系中，这些矢量是：\n- $\\mathbf{V}_{\\mathrm{ref}}$: $(V_{\\mathrm{ref}} \\cos \\theta', V_{\\mathrm{ref}} \\sin \\theta')$\n- $\\mathbf{V}_k$: $(V_s, 0)$，其中 $V_s = \\frac{2}{3}V_{\\mathrm{dc}}$ 是有效矢量的幅值。\n- $\\mathbf{V}_{k+1}$: $(V_s \\cos(\\pi/3), V_s \\sin(\\pi/3)) = (V_s/2, V_s \\sqrt{3}/2)$\n\n矢量方程分解为两个标量方程：\n$$ T_s V_{\\mathrm{ref}} \\cos \\theta' = T_1 V_s + T_2 (V_s/2) $$\n$$ T_s V_{\\mathrm{ref}} \\sin \\theta' = T_2 (V_s \\sqrt{3}/2) $$\n从第二个方程，我们解出 $T_2$：\n$$ T_2 = \\frac{2 T_s V_{\\mathrm{ref}} \\sin \\theta'}{V_s \\sqrt{3}} = \\frac{2 T_s V_{\\mathrm{ref}} \\sin \\theta'}{(\\frac{2}{3}V_{\\mathrm{dc}}) \\sqrt{3}} = \\frac{\\sqrt{3} T_s V_{\\mathrm{ref}}}{V_{\\mathrm{dc}}} \\sin(\\theta') $$\n将 $T_2$ 代入第一个方程以求得 $T_1$：\n$$ T_1 = \\frac{T_s V_{\\mathrm{ref}} \\cos \\theta'}{V_s} - \\frac{T_2}{2} = \\frac{T_s V_{\\mathrm{ref}}}{V_s} \\left( \\cos \\theta' - \\frac{\\sin \\theta'}{\\sqrt{3}} \\right) = \\frac{T_s V_{\\mathrm{ref}}}{V_s} \\frac{2}{\\sqrt{3}} \\sin(\\pi/3 - \\theta') $$\n$$ T_1 = \\frac{T_s V_{\\mathrm{ref}}}{(\\frac{2}{3}V_{\\mathrm{dc}})} \\frac{2}{\\sqrt{3}} \\sin(\\pi/3 - \\theta') = \\frac{\\sqrt{3} T_s V_{\\mathrm{ref}}}{V_{\\mathrm{dc}}} \\sin(\\pi/3 - \\theta') $$\n剩余时间是零矢量时间，$T_0 = T_s - T_1 - T_2$。如果 $V_{\\mathrm{ref}}$ 超出线性调制范围（即 $T_1+T_2 > T_s$），则按比例缩放驻留时间使其在 $T_s$ 处饱和，从而得到 $T_0=0$。\n\n**3. 最优开关序列**\n\n开关序列的结构为四个分段：零矢量、第一个有效矢量、第二个有效矢量、零矢量。总的零矢量时间 $T_0$ 被平均分配，因此持续时间分别为 $(T_0/2, T_{act1}, T_{act2}, T_0/2)$。我们必须选择起始/结束零矢量 ($s_{z1}, s_{z2} \\in \\{0, 7\\}$) 和有效矢量的顺序 ($s_{act1}, s_{act2}$)，以最小化总开关转换次数。成本是从前一状态 $s_{\\mathrm{prev}}$ 开始，连续状态之间汉明距离的总和：\n$$ \\mathrm{Cost} = H(s_{\\mathrm{prev}}, s_{z1}) + H(s_{z1}, s_{act1}) + H(s_{act1}, s_{act2}) + H(s_{act2}, s_{z2}) $$\n汉明距离 $H(s_i, s_j)$ 是 $s_i$ 和 $s_j$ 的二进制表示中不同位的数量。由于相邻的有效矢量仅相差一位，因此 $H(s_{act1}, s_{act2})=1$。对于每个工作点，通过选择 $s_{z1} \\in \\{0,7\\}$、$s_{z2} \\in \\{0,7\\}$ 以及有效矢量的顺序，可以形成8个候选序列。我们评估所有8个候选序列的成本，并选择成本最低的序列。\n\n**4. RMS 共模电压**\n\n对于一个开关状态 $s=(S_a,S_b,S_c)$，其共模电压为：\n$$ v_{\\mathrm{cm}}(s) = \\frac{v_{aN} + v_{bN} + v_{cN}}{3} = \\frac{1}{3} \\sum_{x \\in \\{a,b,c\\}} (S_x - \\frac{1}{2})V_{\\mathrm{dc}} = \\frac{V_{\\mathrm{dc}}}{6} (2(S_a+S_b+S_c) - 3) $$\n设 $p(s) = S_a+S_b+S_c$ 为该状态二进制表示中1的个数。则 $v_{\\mathrm{cm}}(s) = \\frac{V_{\\mathrm{dc}}}{6} (2p(s) - 3)$。$v_{\\mathrm{cm}}^2$ 的可能值为：\n- 零矢量 ($s=0, p=0$ 或 $s=7, p=3$)：$v_{\\mathrm{cm}}(0) = -V_{\\mathrm{dc}}/2$，$v_{\\mathrm{cm}}(7) = +V_{\\mathrm{dc}}/2$。因此 $v_{\\mathrm{cm}}^2 = V_{\\mathrm{dc}}^2/4$。\n- 有效矢量 (p=1 或 p=2)：$v_{\\mathrm{cm}}(p=1)=-V_{\\mathrm{dc}}/6$，$v_{\\mathrm{cm}}(p=2)=+V_{\\mathrm{dc}}/6$。因此 $v_{\\mathrm{cm}}^2 = V_{\\mathrm{dc}}^2/36$。\n\n在持续时间为 $[T_0/2, T_{act1}, T_{act2}, T_0/2]$ 的四段周期 $[s_1, s_2, s_3, s_4]$ 内，RMS值为：\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{1}{T_s} \\left[ \\frac{T_0}{2} v_{\\mathrm{cm}}(s_1)^2 + T_{act1} v_{\\mathrm{cm}}(s_2)^2 + T_{act2} v_{\\mathrm{cm}}(s_3)^2 + \\frac{T_0}{2} v_{\\mathrm{cm}}(s_4)^2 \\right] $$\n由于两个零矢量的共模电压平方值相同，并且对于任何一对相邻的有效矢量（一个有 $p=1$，另一个有 $p=2$），其共模电压平方值也相同，因此无论选择哪个序列，表达式都可以简化：\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{1}{T_s} \\left[ T_0 \\left(\\frac{V_{\\mathrm{dc}}^2}{4}\\right) + (T_1+T_2)\\left(\\frac{V_{\\mathrm{dc}}^2}{36}\\right) \\right] $$\n使用 $T_1+T_2 = T_s-T_0$：\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{V_{\\mathrm{dc}}^2}{T_s} \\left[ \\frac{T_0}{4} + \\frac{T_s-T_0}{36} \\right] = \\frac{V_{\\mathrm{dc}}^2}{36 T_s} [9T_0 + T_s - T_0] = \\frac{V_{\\mathrm{dc}}^2}{36 T_s} [8T_0 + T_s] $$\n$$ V_{\\mathrm{cm,RMS}} = \\frac{V_{\\mathrm{dc}}}{6} \\sqrt{8 \\frac{T_0}{T_s} + 1} $$\n这表明 $V_{\\mathrm{cm,RMS}}$ 仅取决于直流环节电压和在零状态下度过的开关周期部分。\n\n**5. 算法与实现**\n\n该算法对每个测试用例按以下步骤进行：\n1.  将输入角度 $\\theta$ 归一化到 $[0, 2\\pi)$ 范围。\n2.  确定扇区索引 $k_{sec} = \\lfloor \\theta / (\\pi/3) \\rfloor$。\n3.  识别该扇区的两个相邻有效状态 $S_u$ 和 $S_v$。\n4.  计算扇区内的角度 $\\theta' = \\theta - k_{sec}\\pi/3$。\n5.  计算驻留时间 $T_1$（对于 $S_u$）和 $T_2$（对于 $S_v$）。如果 $T_1+T_2 > T_s$，则通过按比例缩放使其总和为 $T_s$ 来处理饱和情况。\n6.  计算总零矢量时间 $T_0 = T_s - T_1 - T_2$。\n7.  生成所有8个候选开关序列。对于每个序列，计算总开关成本（汉明距离之和）。\n8.  选择成本最低的序列。如果出现平局，则选择找到的第一个。\n9.  使用推导出的公式和最终的 $T_0$ 计算 $V_{\\mathrm{cm,RMS}}$。\n10. 存储最优序列和计算出的 $V_{\\mathrm{cm,RMS}}$。\n此过程在提供的 Python 代码中实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    求解给定测试用例下两电平VSI的SVM问题。\n    计算最优开关序列和RMS共模电压。\n    \"\"\"\n\n    test_cases = [\n        (600, 1.0e-4, 200, 0.3, 0),\n        (600, 1.0e-4, 330, np.pi/3 - 1e-6, 7),\n        (600, 1.0e-4, 1, 2.0, 3),\n        (600, 1.0e-4, 340, 4.2, 2)\n    ]\n    \n    # 有效电压矢量状态，按扇区索引(0-5)键控\n    # 状态对应于 k*pi/3 和 (k+1)*pi/3 角度的矢量\n    active_states_by_sector = {\n        0: (4, 6),  # Sector 1: 0 to pi/3\n        1: (6, 2),  # Sector 2: pi/3 to 2pi/3\n        2: (2, 3),  # Sector 3: 2pi/3 to pi\n        3: (3, 1),  # Sector 4: pi to 4pi/3\n        4: (1, 5),  # Sector 5: 4pi/3 to 5pi/3\n        5: (5, 4)   # Sector 6: 5pi/3 to 2pi\n    }\n    \n    def hamming_distance(n1, n2):\n        \"\"\"计算两个整数之间的汉明距离。\"\"\"\n        return bin(n1 ^ n2).count('1')\n\n    results = []\n    for V_dc, T_s, V_ref, theta, s_prev in test_cases:\n        # 步骤 1: 归一化角度并找到扇区\n        theta_norm = np.fmod(theta, 2 * np.pi)\n        if theta_norm  0:\n            theta_norm += 2 * np.pi\n        \n        # 处理theta正好是2*pi的边缘情况\n        if np.isclose(theta_norm, 2 * np.pi):\n            sector_idx = 0\n        else:\n            sector_idx = int(theta_norm / (np.pi / 3))\n\n        theta_prime = theta_norm - sector_idx * (np.pi / 3)\n\n        # 步骤 2: 计算驻留时间\n        # 常数从第一性原理推导中得出\n        a = (np.sqrt(3) * T_s * V_ref) / V_dc\n        \n        # T1是扇区第一个矢量的时间，T2是第二个矢量的\n        T1 = a * np.sin(np.pi/3 - theta_prime)\n        T2 = a * np.sin(theta_prime)\n\n        # 步骤 3: 处理过调制（饱和）\n        if T1 + T2 > T_s:\n            T_total_active = T1 + T2\n            T1 = T1 * T_s / T_total_active\n            T2 = T2 * T_s / T_total_active\n        \n        T0 = T_s - (T1 + T2)\n        # 确保T0不因浮点误差为负\n        T0 = max(0, T0)\n\n        # 步骤 4: 找到最优开关序列\n        S_u, S_v = active_states_by_sector[sector_idx]\n        zero_vectors = [0, 7]\n        best_sequence = []\n        min_cost = float('inf')\n\n        # 有8个候选序列需要检查\n        # (start_zero, active_1, active_2, end_zero)\n        candidates = []\n        for z1 in zero_vectors:\n            for z2 in zero_vectors:\n                # 两种可能的有效矢量顺序\n                candidates.append((z1, S_u, S_v, z2))\n                candidates.append((z1, S_v, S_u, z2))\n\n        for seq in candidates:\n            s1, s2, s3, s4 = seq\n            cost = (hamming_distance(s_prev, s1) +\n                    hamming_distance(s1, s2) +\n                    hamming_distance(s2, s3) +\n                    hamming_distance(s3, s4))\n            \n            if cost  min_cost:\n                min_cost = cost\n                best_sequence = list(seq)\n        \n        # 步骤 5: 计算RMS共模电压\n        # V_cm_rms = (V_dc/6) * sqrt(8 * (T0/T_s) + 1)\n        V_cm_rms = (V_dc / 6.0) * np.sqrt(8 * (T0 / T_s) + 1)\n        \n        # 格式化此测试用例的结果\n        seq_str = '[' + ','.join(map(str, best_sequence)) + ']'\n        res_str = '[' + seq_str + ',' + f'{V_cm_rms:.7f}' + ']'\n        results.append(res_str)\n\n    # 打印包含所有结果的单行输出\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从理论走向现实，最后一步是将算法部署在数字控制器（如DSP或FPGA）上。这个过程充满了实际工程挑战，因为理想的浮点数运算必须被适配到具有有限精度和物理限制的数字硬件上。本练习将模拟这一过程，要求您处理时间量的数字量化问题——将连续的作用时间转换为离散的时钟周期计数，并强制执行最小脉冲宽度限制，以确保硬件能够可靠地生成脉冲。完成此练习将为您在真实硬件上实现SVM算法打下坚实的基础。",
            "id": "3882579",
            "problem": "您的任务是在适用于数字信号处理器 (DSP) 或现场可编程门阵列 (FPGA) 上实时运行的数字逻辑环境中，实现空间矢量调制 (SVM) 的驻留时间计算核心。推导过程必须从两电平三相电压源逆变器的基本表示和Clarke变换开始，然后在一个固定的开关周期内，根据数字量化和最小脉冲约束来分配开关矢量的驻留时间。\n\n基本原理和设置：考虑一个由电压为 $V_{\\mathrm{dc}}$ 的直流母线供电的两电平三相逆变器。每个相的极电压取值为 $0$ 或 $V_{\\mathrm{dc}}$。通过Clarke变换，可以构建出在$\\alpha\\beta$平面上的合成空间矢量，其定义由相极电压 $v_a$、$v_b$、$v_c$ 给出：\n$$\n\\begin{bmatrix}\nv_\\alpha\\\\\nv_\\beta\n\\end{bmatrix}\n=\\frac{2}{3}\n\\begin{bmatrix}\n1  -\\frac{1}{2}  -\\frac{1}{2} \\\\\n0  \\frac{\\sqrt{3}}{2}  -\\frac{\\sqrt{3}}{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nv_a\\\\\nv_b\\\\\nv_c\n\\end{bmatrix}.\n$$\n逆变器有六个幅值为 $\\frac{2}{3}V_{\\mathrm{dc}}$ 的非零有效空间矢量，它们构成一个正六边形，以及两个幅值为 $0$ 的零矢量。在每个开关周期 $T_s$ 内，SVM通过对两个相邻的有效矢量和一个零矢量进行时间平均，来逼近一个参考矢量 $V_{\\mathrm{ref}}$（在$\\alpha\\beta$平面中表示，其幅值为 $|V_{\\mathrm{ref}}|$，角度为 $\\theta_{\\mathrm{ref}}$）。扇区选择将角度范围 $[0,2\\pi)$ 分为六个宽度为 $\\frac{\\pi}{3}$ 弧度的扇区。在实时实现中，当 $\\theta_{\\mathrm{ref}}$ 恰好落在扇区边界上时，必须选择索引较小的扇区以避免不连续性。\n\n目标推导和实现要求：\n- 从第一性原理出发，利用$\\alpha\\beta$平面中的矢量方程，推导出单个开关周期 $T_s$ 内有效矢量驻留时间 $T_1$ 和 $T_2$ 以及零矢量驻留时间 $T_0$ 的表达式，表达式应使用 $V_{\\mathrm{dc}}$、$|V_{\\mathrm{ref}}|$ 和 $\\theta_{\\mathrm{ref}}$ 来表示。推导必须使用将 $V_{\\mathrm{ref}}$ 分解到包含 $\\theta_{\\mathrm{ref}}$ 的扇区所对应的两个相邻有效矢量上的方法，其基底由通过Clarke变换构建的逆变器空间矢量定义。在没有推导的情况下，不得假设使用任何简化公式。\n- 如果计算出的 $T_0$ 为负（这表示相对于线性六边形区域发生了过调制），您必须通过按比例缩放 $T_1$ 和 $T_2$ 来使合成饱和，从而使 $T_0=0$ 且 $T_1+T_2=T_s$，以确保物理可实现性。\n- 实现数字量化：给定一个频率为 $f_{\\mathrm{clk}}$赫兹的时钟，整数驻留时钟周期数为 $N_i=\\mathrm{round}(T_i\\cdot f_{\\mathrm{clk}})$，其中 $i\\in\\{0,1,2\\}$，总时钟周期数为 $N_{T_s}=\\mathrm{round}(T_s\\cdot f_{\\mathrm{clk}})$。您必须通过将 $N_0$ 修正为 $N_{T_s}-N_1-N_2$ 来保证量化后 $N_0+N_1+N_2=N_{T_s}$。\n- 强制执行最小脉冲约束：每个驻留计数必须满足 $N_i\\ge N_{\\min}$，其中 $N_{\\min}$ 是一个预设的最小整数时钟周期数。如果任何 $N_i  N_{\\min}$，您必须通过一个重分配算法来修正这些计数，该算法从其他驻留时间中“借用”周期以满足最小脉冲宽度，同时保持总时钟周期数不变。该重分配应遵循以下规则：优先从最大的可用驻留时间中获取（如果可能，优先考虑 $N_0$）。可以保证 $3N_{\\min} \\le N_{T_s}$，因此总有可行的解决方案。\n- 对于每个测试用例，您的程序必须计算扇区索引 $k\\in\\{1,2,3,4,5,6\\}$，以及三个量化和约束后的驻留时钟周期数 $N_0$、$N_1$、$N_2$。\n\n测试套件和输出格式：\n- 使用以下测试用例，每个元组为 $(V_{\\mathrm{dc}}, T_s, f_{\\mathrm{clk}}, |V_{\\mathrm{ref}}|, \\theta_{\\mathrm{ref}}, N_{\\min})$：\n    - Case A: $(600, 50\\times 10^{-6}, 100\\times 10^6, 200, 0.8, 50)$\n    - Case B: $(700, 20\\times 10^{-6}, 50\\times 10^6, 0.99 \\times \\frac{2}{3} \\times 700, \\pi/3, 10)$\n    - Case C: $(400, 10\\times 10^{-6}, 25\\times 10^6, 1, 0.01, 15)$\n    - Case D: $(800, 40\\times 10^{-6}, 80\\times 10^6, 600, 3.4, 100)$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个结果必须是四元列表 `[k,N0,N1,N2]`，所有值均为整数。输出字符串中不得有空格。例如：`[[k1,N0_1,N1_1,N2_1],[k2,N0_2,N1_2,N2_2]]`。",
            "solution": "用户提供了一个基于电力电子学原理的有效且提法明确的问题。任务是推导并实现用于两电平三相逆变器的空间矢量调制 (SVM) 的核心逻辑，包括实际的数字约束。解决方案首先从基本原理推导驻留时间，然后应用指定的饱和、量化和最小脉宽约束。\n\n### 1. 基本原理和空间矢量定义\n\n一个两电平三相逆变器将其三个输出相（$a$、$b$、$c$）分别连接到电压为 $V_{\\mathrm{dc}}$ 的直流母线的正极或负极。我们假设相对于负极直流母线的相极电压（$v_a$、$v_b$、$v_c$）为 $0$ 或 $V_{\\mathrm{dc}}$。共有 $2^3 = 8$ 种可能的开关状态，由一个三元组 $(S_a, S_b, S_c)$ 表示，其中 $S_k \\in \\{0, 1\\}$。\n\n静止参考坐标系电压（$v_\\alpha$、$v_\\beta$）通过Clarke变换获得，如题目所提供：\n$$\n\\begin{bmatrix}\nv_\\alpha\\\\\nv_\\beta\n\\end{bmatrix}\n=\\frac{2}{3}\n\\begin{bmatrix}\n1  -\\frac{1}{2}  -\\frac{1}{2} \\\\\n0  \\frac{\\sqrt{3}}{2}  -\\frac{\\sqrt{3}}{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nv_a\\\\\nv_b\\\\\nv_c\n\\end{bmatrix}\n$$\n将此变换应用于八个开关状态，得到六个非零有效矢量和两个零矢量。例如，对于状态 $(1,0,0)$，其中 $v_a=V_{\\mathrm{dc}}, v_b=0, v_c=0$：\n$$\nV_1 = \\begin{bmatrix}v_\\alpha\\\\v_\\beta\\end{bmatrix} = \\frac{2}{3} \\begin{bmatrix} 1  -1/2  -1/2 \\\\ 0  \\sqrt{3}/2  -\\sqrt{3}/2 \\end{bmatrix} \\begin{bmatrix}V_{\\mathrm{dc}}\\\\0\\\\0\\end{bmatrix} = \\begin{bmatrix}\\frac{2}{3}V_{\\mathrm{dc}}\\\\0\\end{bmatrix}\n$$\n用复数表示，即为 $V_1 = \\frac{2}{3}V_{\\mathrm{dc}}e^{j0}$。类似地，可以求得其他五个有效矢量为 $V_k = \\frac{2}{3}V_{\\mathrm{dc}} e^{j(k-1)\\pi/3}$，其中 $k \\in \\{1, \\dots, 6\\}$。这些矢量在$\\alpha\\beta$平面上形成一个正六边形。两个零矢量，$V_0$（来自状态 $(0,0,0)$）和 $V_7$（来自状态 $(1,1,1)$），位于原点。\n\n### 2. 驻留时间推导\n\nSVM的核心是通过在一个开关周期 $T_s$ 内对三个静止矢量进行时间平均来合成一个期望的参考电压矢量 $V_{\\mathrm{ref}}$。所选的三个矢量是界定包含 $V_{\\mathrm{ref}}$ 的扇区的两个相邻有效矢量以及一个零矢量。\n\n伏秒平衡原理指出，参考矢量与开关周期的乘积必须等于所施加矢量与其各自驻留时间（$T_1, T_2, T_0$）乘积之和：\n$$\nV_{\\mathrm{ref}} T_s = V_k T_1 + V_{k+1} T_2 + V_0 T_0\n$$\n驻留时间之和必须等于开关周期：$T_s = T_1 + T_2 + T_0$。\n由于 $V_0$ 是零矢量，第一个方程简化为：\n$$\nV_{\\mathrm{ref}} T_s = V_k T_1 + V_{k+1} T_2\n$$\n为了求解 $T_1$ 和 $T_2$，我们将此矢量方程投影到一个方便的基上。选择一个旋转了角度 $\\phi = (k-1)\\pi/3$ 的坐标系，其中 $k$ 是扇区索引（$k \\in \\{1, \\dots, 6\\}$）。在这个旋转坐标系中，第一个有效矢量 $V'_k = V_k e^{-j\\phi}$ 位于实轴上。设 $\\theta'$ 是 $V_{\\mathrm{ref}}$ 在这个新坐标系中的角度，因此 $\\theta' = \\theta_{\\mathrm{ref}} - \\phi$。矢量方程变为：\n$$\nV'_{\\mathrm{ref}} T_s = V'_k T_1 + V'_{k+1} T_2\n$$\n其中 $V'_{\\mathrm{ref}} = |V_{\\mathrm{ref}}|e^{j\\theta'}$，$V'_k = \\frac{2}{3}V_{\\mathrm{dc}}$，以及 $V'_{k+1} = \\frac{2}{3}V_{\\mathrm{dc}}e^{j\\pi/3}$。代入这些复数值：\n$$\n|V_{\\mathrm{ref}}| T_s (\\cos\\theta' + j\\sin\\theta') = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right) T_1 + \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\left(\\cos\\frac{\\pi}{3} + j\\sin\\frac{\\pi}{3}\\right)\\right) T_2\n$$\n$$\n|V_{\\mathrm{ref}}| T_s (\\cos\\theta' + j\\sin\\theta') = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right) T_1 + \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\left(\\frac{1}{2} + j\\frac{\\sqrt{3}}{2}\\right)\\right) T_2\n$$\n令虚部和实部相等：\n$$\n\\text{(虚部)}: \\quad |V_{\\mathrm{ref}}| T_s \\sin\\theta' = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right)\\left(\\frac{\\sqrt{3}}{2}\\right)T_2 = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}}T_2 \\implies T_2 = \\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}}\\sin\\theta'\n$$\n$$\n\\text{(实部)}: \\quad |V_{\\mathrm{ref}}| T_s \\cos\\theta' = \\frac{2}{3}V_{\\mathrm{dc}}T_1 + \\frac{1}{3}V_{\\mathrm{dc}}T_2\n$$\n将 $T_2$ 代入实部方程：\n$$\n\\frac{2}{3}V_{\\mathrm{dc}}T_1 = |V_{\\mathrm{ref}}| T_s \\cos\\theta' - \\frac{1}{3}V_{\\mathrm{dc}}\\left(\\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}}\\sin\\theta'\\right) = |V_{\\mathrm{ref}}| T_s \\left(\\cos\\theta' - \\frac{\\sin\\theta'}{\\sqrt{3}}\\right)\n$$\n$$\nT_1 = \\frac{3|V_{\\mathrm{ref}}|T_s}{2V_{\\mathrm{dc}}} \\frac{2}{\\sqrt{3}}\\left(\\frac{\\sqrt{3}}{2}\\cos\\theta' - \\frac{1}{2}\\sin\\theta'\\right) = \\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}} \\sin\\left(\\frac{\\pi}{3} - \\theta'\\right)\n$$\n零矢量驻留时间则为 $T_0 = T_s - T_1 - T_2$。\n\n### 3. 实现逻辑\n\n完整的实现算法整合了推导出的公式和问题陈述中指定的约束。\n\n1.  **扇区识别**：将角度 $\\theta_{\\mathrm{ref}}$ 归一化到 $[0, 2\\pi)$。确定扇区索引 $k \\in \\{1, ..., 6\\}$。扇区 $k$ 覆盖角度区域 $[(k-1)\\pi/3, k\\pi/3)$。问题规定，如果 $\\theta_{\\mathrm{ref}}$ 落在边界上，则选择索引较小的扇区。这可以通过对归一化角度 `theta_ref/(pi/3)` 向下取整并对精确整数结果进行校正来处理。\n\n2.  **驻留时间计算**：使用扇区索引 $k$ 和扇区内角度 $\\theta' = \\theta_{\\mathrm{ref}} - (k-1)\\pi/3$，利用推导出的公式计算理想驻留时间 $T_1$ 和 $T_2$。\n\n3.  **过调制处理**：如果计算出的 $T_0 = T_s - T_1 - T_2$ 为负，则参考矢量位于可实现电压的六边形区域之外（过调制）。将有效矢量作用时间 $T_1$ 和 $T_2$ 按比例缩小以适应 $T_s$，使其总和恰好为 $T_s$。这将 $T_0$ 设置为零。新的时间为 $T'_1 = T_1 \\frac{T_s}{T_1+T_2}$ 和 $T'_2 = T_2 \\frac{T_s}{T_1+T_2}$。\n\n4.  **数字量化**：将连续时间的驻留时长转换为整数时钟周期数。$N_{T_s} = \\mathrm{round}(T_s \\cdot f_{\\mathrm{clk}})$。有效矢量的时钟周期数为 $N_1 = \\mathrm{round}(T_1 \\cdot f_{\\mathrm{clk}})$ 和 $N_2 = \\mathrm{round}(T_2 \\cdot f_{\\mathrm{clk}})$。为确保时钟周期总数守恒，零矢量的时钟周期数作为余数计算：$N_0 = N_{T_s} - N_1 - N_2$。\n\n5.  **最小脉冲约束**：为防止对硬件有问题的极短脉冲，每个时钟周期数 $N_i$ 必须至少为 $N_{\\min}$。如果任何 $N_i  N_{\\min}$，则应用重分配算法：\n    a. 计算每个脉冲的差额：$\\Delta_i = \\max(0, N_{\\min} - N_i)$。\n    b. 将总差额相加，$\\Delta_{\\mathrm{total}} = \\sum \\Delta_i$。\n    c. 每个脉冲计数临时增加其差额：$N'_i = N_i + \\Delta_i$。\n    d. 总差额 $\\Delta_{\\mathrm{total}}$ 必须从“提供者”脉冲中减去（即那些最初满足 $N_i \\ge N_{\\min}$ 的脉冲）。\n    e. 根据规则对提供者进行排序：“优先从最大的可用驻留时间中获取（如果可能，优先考虑 $N_0$）”。这通过按其原始时钟周期数 $N_i$ 降序对提供者索引进行排序来实现，其中索引 $0$ 用作平局决胜规则。\n    f. 算法遍历排序后的提供者，从每个提供者中减去所需量，直到总差额被补偿，同时确保没有提供者的计数低于 $N_{\\min}$。问题保证这总是可能的，因为 $3N_{\\min} \\le N_{T_s}$。\n\n这种结构化的方法确保了所有物理和数字约束都得到满足，从而得出了一个实用的SVM核心实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the SVM problem for the given test cases.\n    \"\"\"\n\n    def calculate_svm_ticks(V_dc, T_s, f_clk, V_ref_mag, theta_ref, N_min):\n        \"\"\"\n        Calculates SVM dwell time ticks for a given set of parameters,\n        following the derivation and constraints.\n        \"\"\"\n        # Step 1: Normalize theta_ref to [0, 2*pi)\n        theta_ref_norm = theta_ref % (2 * np.pi)\n\n        # Step 2: Determine sector\n        # The problem states: \"when theta_ref lies exactly on a sector boundary,\n        # the lower-index sector must be chosen\".\n        angle_norm_units = theta_ref_norm / (np.pi / 3)\n        \n        sector_idx = np.floor(angle_norm_units)\n\n        # Boundary condition: if angle is an integer multiple of pi/3 (and not 0),\n        # it belongs to the boundary, so we select the lower-index sector by\n        # decrementing the calculated index. A small tolerance is used for float comparison.\n        if angle_norm_units > 1e-9 and np.isclose(angle_norm_units, np.round(angle_norm_units)):\n            sector_idx = np.round(angle_norm_units) - 1\n        \n        # Handle the edge case where angle is 2*pi, which normalizes to 0, but\n        # a calculated index could be 6. The sectors are 1-6 (indices 0-5).\n        if sector_idx >= 6:\n            sector_idx = 5\n        \n        sector = int(sector_idx) + 1\n\n        # Step 3: Calculate angle within the sector\n        theta_prime = theta_ref_norm - sector_idx * (np.pi / 3)\n\n        # Step 4: Calculate ideal dwell times based on the derived formulas\n        # T1 is the dwell time for the first active vector of the sector.\n        # T2 is the dwell time for the second active vector of the sector.\n        common_factor = (np.sqrt(3) * V_ref_mag * T_s) / V_dc\n        T1 = common_factor * np.sin(np.pi/3 - theta_prime)\n        T2 = common_factor * np.sin(theta_prime)\n\n        # Step 5: Calculate T0 and check for overmodulation\n        T0 = T_s - T1 - T2\n\n        # Step 6: Handle overmodulation by saturating the dwell times\n        if T0  0:\n            T_sum_active = T1 + T2\n            if T_sum_active > 1e-12:  # Avoid division by zero\n                scale_factor = T_s / T_sum_active\n                T1 *= scale_factor\n                T2 *= scale_factor\n            else: # Should not happen in valid cases, but for robustness\n                T1 = T_s / 2.0\n                T2 = T_s / 2.0\n            T0 = 0.0\n\n        # Step 7: Perform digital quantization\n        N_Ts = int(np.round(T_s * f_clk))\n        N1 = int(np.round(T1 * f_clk))\n        N2 = int(np.round(T2 * f_clk))\n        # N0 is calculated as the remainder to conserve the total ticks\n        N0 = N_Ts - N1 - N2\n        \n        N = [N0, N1, N2]\n\n        # Step 8: Enforce the minimum pulse constraint\n        deficits = [max(0, N_min - val) for val in N]\n        total_deficit = sum(deficits)\n        \n        if total_deficit > 0:\n            # Create adjusted counts by raising all sub-minimum pulses to N_min\n            N_adj = [val + d for val, d in zip(N, deficits)]\n            \n            amount_to_reduce = total_deficit\n            \n            # Identify donor pulses (those that were originally >= N_min)\n            donor_indices = [i for i, d in enumerate(deficits) if d == 0]\n            \n            # Sort donors: largest first, with N0 as tie-breaker for the \"favor N0\" rule.\n            # This is achieved by sorting using a tuple key (-N[i], i).\n            sorted_donors = sorted(donor_indices, key=lambda i: (-N[i], i))\n            \n            for i in sorted_donors:\n                if amount_to_reduce = 0:\n                    break\n                \n                # Max amount we can take from this pulse without violating its own N_min\n                can_reduce = N_adj[i] - N_min\n                \n                # Actual reduction is the minimum of what's needed and what's available\n                reduction = min(amount_to_reduce, can_reduce)\n                \n                N_adj[i] -= reduction\n                amount_to_reduce -= reduction\n            \n            N_final = N_adj\n        else:\n            N_final = N\n            \n        return [sector, N_final[0], N_final[1], N_final[2]]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General case\n        (600, 50e-6, 100e6, 200, 0.8, 50),\n        # Case B: Boundary angle with high amplitude\n        (700, 20e-6, 50e6, 0.99 * (2/3) * 700, np.pi/3, 10),\n        # Case C: Very small amplitude requiring minimum pulse enforcement\n        (400, 10e-6, 25e6, 1, 0.01, 15),\n        # Case D: Overmodulation\n        (800, 40e-6, 80e6, 600, 3.4, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_svm_ticks(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{s},{n0},{n1},{n2}]\" for s, n0, n1, n2 in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}