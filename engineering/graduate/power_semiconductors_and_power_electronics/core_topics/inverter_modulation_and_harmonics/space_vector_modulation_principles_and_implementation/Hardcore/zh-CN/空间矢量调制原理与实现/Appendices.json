{
    "hands_on_practices": [
        {
            "introduction": "空间矢量调制（SVM）的核心在于将一个连续旋转的参考电压矢量分解为一组离散的、可由逆变器实现的固定矢量。本练习将引导你从第一性原理出发，构建一个完整的SVM算法，涵盖扇区检测、相邻有效矢量的确定，以及最重要的——占空时间的精确计算。通过完成这项练习，你将掌握将SVM的几何直觉转化为可执行代码的基础技能。",
            "id": "3882584",
            "problem": "您的任务是为空间矢量调制（SVM）设计一个通用算法，该算法将静止双轴坐标系（$\\alpha$-$\\beta$平面）中指定的参考轨迹映射到一组离散的逆变器开关矢量，并计算相关的驻留时间。背景为三相两电平电压源逆变器（VSI）。目标是从第一性原理出发，推导并实现一个能够执行参考矢量映射、扇区检测和驻留时间计算的算法，而不依赖于预先推导的简化公式。\n\n从以下基本定义和事实开始：\n\n- 设直流（DC）母线电压表示为$V_{\\mathrm{dc}}$，采样周期表示为$T_{\\mathrm{s}}$（每个开关周期的时间）。\n- 对于三相两电平VSI，每个桥臂根据上管或下管的导通情况，产生一个相到虚拟中性点电压 $v_a, v_b, v_c \\in \\{\\pm V_{\\mathrm{dc}}/2\\}$。设每个桥臂的开关状态为 $s_a, s_b, s_c \\in \\{+1,-1\\}$，其中$+1$对应$+V_{\\mathrm{dc}}/2$，$-1$对应$-V_{\\mathrm{dc}}/2$。\n- 将三相电压 $(v_a,v_b,v_c)$ 映射到$\\alpha$-$\\beta$分量 $(v_\\alpha,v_\\beta)$ 的静止双轴（Clarke）变换定义为\n  $$\n  v_\\alpha = \\frac{2}{3}\\left(v_a - \\frac{1}{2}v_b - \\frac{1}{2}v_c\\right),\\quad\n  v_\\beta = \\frac{2}{3}\\left(\\frac{\\sqrt{3}}{2}(v_b - v_c)\\right).\n  $$\n  将 $v_a = s_a\\frac{V_{\\mathrm{dc}}}{2}$，$v_b = s_b\\frac{V_{\\mathrm{dc}}}{2}$ 和 $v_c = s_c\\frac{V_{\\mathrm{dc}}}{2}$ 代入，即可得出逆变器在$\\alpha$-$\\beta$平面上的空间矢量。\n- 六个有效开关矢量（非零）的角度相隔$60^\\circ$，且具有相同的幅值。它们的精确坐标由上述开关三元组的定义得出：\n  $$\n  \\begin{aligned}\n  \\mathbf{V}_1  (s_a,s_b,s_c) = (+1,-1,-1), \\\\\n  \\mathbf{V}_2  (s_a,s_b,s_c) = (+1,+1,-1), \\\\\n  \\mathbf{V}_3  (s_a,s_b,s_c) = (-1,+1,-1), \\\\\n  \\mathbf{V}_4  (s_a,s_b,s_c) = (-1,+1,+1), \\\\\n  \\mathbf{V}_5  (s_a,s_b,s_c) = (-1,-1,+1), \\\\\n  \\mathbf{V}_6  (s_a,s_b,s_c) = (+1,-1,+1). \\\\\n  \\end{aligned}\n  $$\n  每个$\\mathbf{V}_k$都由上述Clarke变换计算得出，其幅值为 $|\\mathbf{V}_k| = \\frac{2}{3}V_{\\mathrm{dc}}$。\n- 零开关矢量集对应于$(s_a,s_b,s_c)=(+1,+1,+1)$或$(-1,-1,-1)$，两者都映射到零矢量$\\mathbf{0}$。\n\n参考矢量规范：\n\n- 期望的参考电压矢量由其极坐标形式 $(V_{\\mathrm{ref}}, \\theta)$ 给出，其中 $V_{\\mathrm{ref}}$ 是幅值，$\\theta$ 是角度。在整个过程中使用弧度作为角度单位。参考矢量通过以下方式映射到$\\alpha$-$\\beta$平面：\n  $$\n  v_\\alpha = V_{\\mathrm{ref}}\\cos(\\theta),\\quad v_\\beta = V_{\\mathrm{ref}}\\sin(\\theta).\n  $$\n\n扇区检测：\n\n- 将扇区索引 $k\\in\\{1,2,3,4,5,6\\}$ 定义为$\\alpha$-$\\beta$平面内由两个相邻有效开关矢量界定的区域，角度$\\theta$位于该区域内。使用以下规则：\n  $$\n  \\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi,\\quad\n  k = 1 + \\left\\lfloor \\frac{\\theta_{\\mathrm{mod}}}{\\pi/3} \\right\\rfloor,\n  $$\n  并约定如果 $V_{\\mathrm{ref}}=0$，则设$k=0$，所有驻留时间都在零矢量上。\n- 对于恰好在扇区边界上的角度，即$\\theta_{\\mathrm{mod}}$等于$\\pi/3$的整数倍时，直接使用上述公式（这将边界分配给编号较大的扇区，但$\\theta_{\\mathrm{mod}}=0$除外，它映射到$k=1$）。\n\n驻留时间计算：\n\n- 在一个开关周期$T_{\\mathrm{s}}$内，参考矢量的积分必须等于所施加的逆变器矢量的时间加权和：\n  $$\n  T_1\\,\\mathbf{V}_k + T_2\\,\\mathbf{V}_{k+1} + T_0\\,\\mathbf{0} = T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}},\n  $$\n  其中 $T_1\\ge 0$, $T_2\\ge 0$, $T_0\\ge 0$ 且 $T_1+T_2+T_0 = T_{\\mathrm{s}}$。\n- $(T_1,T_2)$对是通过求解由$\\mathbf{V}_k$和$\\mathbf{V}_{k+1}$的$\\alpha$-$\\beta$分量构成的针对$T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}}$的$2\\times 2$线性系统得到的。零矢量驻留时间为$T_0=T_{\\mathrm{s}}-T_1-T_2$。\n- 将驻留时间归一化为占空比 $d_1=T_1/T_{\\mathrm{s}}$，$d_2=T_2/T_{\\mathrm{s}}$，$d_0=T_0/T_{\\mathrm{s}}$，并强制$d_1,d_2,d_0\\in[0,1]$且$d_1+d_2+d_0=1$。\n\n线性区域约束：\n\n- 线性调制区对应于由有效矢量张成的六边形的内部。沿扇区角平分线可达到的最大径向参考幅值等于$V_{\\mathrm{dc}}/\\sqrt{3}$。如果$V_{\\mathrm{ref}} > V_{\\mathrm{dc}}/\\sqrt{3}$，则通过设置$V_{\\mathrm{ref}} \\leftarrow V_{\\mathrm{dc}}/\\sqrt{3}$来进行饱和处理，同时保持$\\theta$不变。这确保了$d_0\\ge 0$，并避免了本问题中的过调制。\n\n单位：\n\n- $V_{\\mathrm{dc}}$和$V_{\\mathrm{ref}}$以伏特（V）表示，$T_{\\mathrm{s}}$以秒（s）表示，角度$\\theta$以弧度表示。占空比$d_1$、$d_2$、$d_0$是无量纲的。\n\n您的程序必须实现：\n\n1. 将$(V_{\\mathrm{ref}},\\theta)$映射到$(v_\\alpha,v_\\beta)$，必要时对线性边界$V_{\\mathrm{dc}}/\\sqrt{3}$进行饱和处理。\n2. 根据上述规则进行扇区检测，对负角度使用模运算，并在扇区边界上进行决断。\n3. 通过Clarke变换从开关状态构建两个相邻的有效矢量$\\mathbf{V}_k$和$\\mathbf{V}_{k+1}$，并求解$2\\times 2$系统以获得驻留时间。\n4. 对占空比进行归一化和裁剪，使得$d_1,d_2,d_0\\in[0,1]$且$d_1+d_2+d_0=1$。\n\n测试套件：\n\n使用以下测试用例$(V_{\\mathrm{dc}}, T_{\\mathrm{s}}, V_{\\mathrm{ref}}, \\theta)$:\n\n- 用例1（一般内部）：$(600,\\ 1\\times 10^{-4},\\ 300,\\ 0.7)$。\n- 用例2（扇区边界上）：$(540,\\ 5\\times 10^{-5},\\ 200,\\ \\pi/3)$。\n- 用例3（需要饱和）：$(700,\\ 2\\times 10^{-4},\\ 420,\\ 5.5)$。\n- 用例4（零矢量）：$(800,\\ 1\\times 10^{-4},\\ 0,\\ 2.0)$。\n- 用例5（负轴）：$(500,\\ 1.5\\times 10^{-4},\\ 100,\\ \\pi)$。\n- 用例6（负角度）：$(650,\\ 7\\times 10^{-5},\\ 150,\\ -0.1)$。\n\n最终输出格式：\n\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个四元素列表$[k,d_1,d_2,d_0]$，其中$k$是整数，$d_1$、$d_2$、$d_0$是四舍五入到$10$位小数的实数。输出字符串中不得有空格。例如：\n  $$\n  [[k_1,d_{1,1},d_{2,1},d_{0,1}],[k_2,d_{1,2},d_{2,2},d_{0,2}],\\dots]\n  $$",
            "solution": "我们通过结合两电平逆变器的物理原理、Clarke变换以及空间矢量六边形的几何特性来设计该算法。关键步骤如下：\n\n1. 逆变器开关状态到空间矢量的基本映射。\n\n三相两电平电压源逆变器（VSI）的桥臂电压为 $v_a, v_b, v_c \\in \\{\\pm V_{\\mathrm{dc}}/2\\}$，由开关状态 $s_a,s_b,s_c\\in\\{+1,-1\\}$ 决定。静止坐标系（Clarke）变换将 $(v_a,v_b,v_c)$ 映射到 $(v_\\alpha,v_\\beta)$：\n$$\nv_\\alpha = \\frac{2}{3}\\left(v_a - \\frac{1}{2}v_b - \\frac{1}{2}v_c\\right),\\quad\nv_\\beta = \\frac{2}{3}\\left(\\frac{\\sqrt{3}}{2}(v_b - v_c)\\right).\n$$\n代入 $v_a = s_a\\frac{V_{\\mathrm{dc}}}{2}$，$v_b = s_b\\frac{V_{\\mathrm{dc}}}{2}$，$v_c = s_c\\frac{V_{\\mathrm{dc}}}{2}$，我们得到\n$$\nv_\\alpha = \\frac{V_{\\mathrm{dc}}}{3}\\left(s_a - \\frac{1}{2}s_b - \\frac{1}{2}s_c\\right),\\quad\nv_\\beta = \\frac{V_{\\mathrm{dc}}\\sqrt{3}}{6}(s_b - s_c).\n$$\n存在六个有效矢量 $\\mathbf{V}_k$，对应于两个桥臂为$+1$一个桥臂为$-1$的开关三元组，以及其互补的三个，即两个桥臂为$-1$一个为$+1$。按角度排列它们可得：\n$$\n\\begin{aligned}\n\\mathbf{V}_1  (s_a,s_b,s_c)=(+1,-1,-1),\\\\\n\\mathbf{V}_2  (s_a,s_b,s_c)=(+1,+1,-1),\\\\\n\\mathbf{V}_3  (s_a,s_b,s_c)=(-1,+1,-1),\\\\\n\\mathbf{V}_4  (s_a,s_b,s_c)=(-1,+1,+1),\\\\\n\\mathbf{V}_5  (s_a,s_b,s_c)=(-1,-1,+1),\\\\\n\\mathbf{V}_6  (s_a,s_b,s_c)=(+1,-1,+1).\n\\end{aligned}\n$$\n每个矢量的幅值为 $|\\mathbf{V}_k| = \\frac{2}{3}V_{\\mathrm{dc}}$，且彼此相隔$60^\\circ$。\n\n2. 参考轨迹映射。\n\n期望的参考矢量由极坐标 $(V_{\\mathrm{ref}},\\theta)$ 指定，其 $(v_\\alpha,v_\\beta)$ 分量由下式确定\n$$\nv_\\alpha = V_{\\mathrm{ref}}\\cos(\\theta),\\quad v_\\beta = V_{\\mathrm{ref}}\\sin(\\theta).\n$$\n线性区域内的SVM要求参考矢量位于由六个有效矢量张成的六边形内部。在线性区域内沿扇区角平分线可达到的最大径向幅值等于$V_{\\mathrm{dc}}/\\sqrt{3}$，这是通过考虑扇区三角形内最长的组合在$T_1=T_2=T_{\\mathrm{s}}/2$时发生而得到的，即\n$$\n\\left|\\frac{T_{\\mathrm{s}}}{2}\\mathbf{V}_k + \\frac{T_{\\mathrm{s}}}{2}\\mathbf{V}_{k+1}\\right| = \\frac{T_{\\mathrm{s}}}{2}\\left|\\mathbf{V}_k + \\mathbf{V}_{k+1}\\right| = \\frac{T_{\\mathrm{s}}}{2}\\cdot \\frac{4}{3}V_{\\mathrm{dc}}\\cos\\left(\\frac{\\pi}{6}\\right) = T_{\\mathrm{s}}\\cdot \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}},\n$$\n所以归一化的最大值为$V_{\\mathrm{dc}}/\\sqrt{3}$。因此我们进行饱和处理：\n$$\nV_{\\mathrm{ref}} \\leftarrow \\min\\left(V_{\\mathrm{ref}},\\frac{V_{\\mathrm{dc}}}{\\sqrt{3}}\\right),\n$$\n同时保持角度$\\theta$不变。\n\n3. 扇区检测。\n\n与六边形几何结构对齐，我们根据角度模$2\\pi$来定义扇区索引$k$：\n$$\n\\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi,\\quad\nk = 1 + \\left\\lfloor \\frac{\\theta_{\\mathrm{mod}}}{\\pi/3}\\right\\rfloor.\n$$\n当$V_{\\mathrm{ref}}=0$时，设置$k=0$（零矢量）。对于处于$\\pi/3$整数倍的边界角度，该定义将它们映射到编号较大的扇区，但$\\theta_{\\mathrm{mod}}=0$除外，它被映射到$k=1$。\n\n4. 驻留时间推导。\n\n在每个开关周期$T_{\\mathrm{s}}$内，逆变器在一个扇区内最多施加三个矢量：两个相邻的有效矢量$\\mathbf{V}_k, \\mathbf{V}_{k+1}$和零矢量$\\mathbf{0}$。在$T_{\\mathrm{s}}$内的积分电压必须等于参考矢量的积分：\n$$\nT_1\\,\\mathbf{V}_k + T_2\\,\\mathbf{V}_{k+1} + T_0\\,\\mathbf{0} = T_{\\mathrm{s}}\\,\\mathbf{v}_{\\mathrm{ref}},\n$$\n其中 $T_1,T_2,T_0\\ge 0$ 且 $T_1+T_2+T_0=T_{\\mathrm{s}}$。在$\\alpha$-$\\beta$平面上以分量形式书写，可得到一个关于 $(T_1,T_2)$ 的$2\\times 2$线性系统：\n$$\n\\begin{bmatrix}\nV_{k,\\alpha}  V_{k+1,\\alpha} \\\\\nV_{k,\\beta}  V_{k+1,\\beta}\n\\end{bmatrix}\n\\begin{bmatrix}\nT_1\\\\\nT_2\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nT_{\\mathrm{s}}\\,v_\\alpha\\\\\nT_{\\mathrm{s}}\\,v_\\beta\n\\end{bmatrix}.\n$$\n解出$(T_1,T_2)$得到有效矢量的驻留时间，零矢量驻留时间则为$T_0=T_{\\mathrm{s}}-T_1-T_2$。归一化为占空比：\n$$\nd_1 = \\frac{T_1}{T_{\\mathrm{s}}},\\quad d_2 = \\frac{T_2}{T_{\\mathrm{s}}},\\quad d_0 = \\frac{T_0}{T_{\\mathrm{s}}}.\n$$\n我们通过将负值（由数值舍入引起）截断为$0$并相应调整$d_0$，来强制$d_1,d_2,d_0\\in[0,1]$且$d_1+d_2+d_0=1$。饱和步骤确保了在线性区域内$d_1+d_2\\le 1$。\n\n5. 每个测试用例的算法摘要：\n\n- 计算 $V_{\\mathrm{lim}} = V_{\\mathrm{dc}}/\\sqrt{3}$ 并设置 $V_{\\mathrm{ref}} \\leftarrow \\min(V_{\\mathrm{ref}},V_{\\mathrm{lim}})$。\n- 如果$V_{\\mathrm{ref}}=0$，输出$k=0$和$(d_1,d_2,d_0)=(0,0,1)$。\n- 否则计算 $\\theta_{\\mathrm{mod}} = \\theta \\bmod 2\\pi$ 和扇区 $k=1+\\left\\lfloor\\theta_{\\mathrm{mod}}/(\\pi/3)\\right\\rfloor$。\n- 计算 $(v_\\alpha,v_\\beta)=(V_{\\mathrm{ref}}\\cos\\theta_{\\mathrm{mod}},\\,V_{\\mathrm{ref}}\\sin\\theta_{\\mathrm{mod}})$。\n- 使用给定的开关三元组和Clarke变换表达式构建有效矢量$\\mathbf{V}_k$和$\\mathbf{V}_{k+1}$。\n- 求解$2\\times 2$系统得到$(T_1,T_2)$，归一化得到$(d_1,d_2)$，设置$d_0=1-d_1-d_2$，裁剪到$[0,1]$区间，并确保$d_1+d_2+d_0=1$（考虑浮点舍入）。\n- 将$d_1,d_2,d_0$四舍五入到$10$位小数用于输出。\n\n6. 输出规范：\n\n为每个测试用例返回列表$[k,d_1,d_2,d_0]$，并将所有结果聚合成一个用方括号括起来的、无空格的逗号分隔列表。占空比四舍五入到10位小数。\n\n该算法基于物理逆变器模型、Clarke变换以及将参考矢量直接分解到六边形相邻基矢量上，从而避免了对简化三角函数表达式的依赖，并通过线性代数确保了其正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef clarke_transform_vector(Vdc, s_a, s_b, s_c):\n    \"\"\"\n    Compute the alpha-beta components of the inverter space vector\n    for switching states s_a, s_b, s_c in {+1, -1} given DC bus voltage Vdc.\n    \"\"\"\n    v_a = s_a * Vdc / 2.0\n    v_b = s_b * Vdc / 2.0\n    v_c = s_c * Vdc / 2.0\n    v_alpha = (2.0/3.0) * (v_a - 0.5*v_b - 0.5*v_c)\n    v_beta  = (2.0/3.0) * ((np.sqrt(3)/2.0) * (v_b - v_c))\n    return np.array([v_alpha, v_beta], dtype=float)\n\ndef active_vectors(Vdc):\n    \"\"\"\n    Return the six active vectors (V1..V6) in alpha-beta coordinates for the given Vdc.\n    Ordered by angle: 0, 60deg, 120deg, 180deg, 240deg, 300deg.\n    Switching triplets as per problem statement.\n    \"\"\"\n    states = [\n        (+1, -1, -1),  # V1\n        (+1, +1, -1),  # V2\n        (-1, +1, -1),  # V3\n        (-1, +1, +1),  # V4\n        (-1, -1, +1),  # V5\n        (+1, -1, +1),  # V6\n    ]\n    return [clarke_transform_vector(Vdc, *st) for st in states]\n\ndef detect_sector(theta, vref_mag):\n    \"\"\"\n    Detect sector index k in {1..6} from angle theta (radians).\n    If vref_mag == 0, return k=0.\n    Boundary angles assigned to higher-numbered sector except 0->1 implicitly by floor.\n    \"\"\"\n    if vref_mag == 0.0:\n        return 0\n    two_pi = 2.0*np.pi\n    theta_mod = theta % two_pi\n    sector = int(np.floor(theta_mod / (np.pi/3.0))) + 1\n    # sector in 1..6\n    return sector\n\ndef compute_duty_ratios(Vdc, Ts, Vref, theta):\n    \"\"\"\n    Compute [sector, d1, d2, d0] for given parameters, with saturation and normalization.\n    \"\"\"\n    # Saturation to linear SVM boundary\n    Vlim = Vdc / np.sqrt(3.0)\n    Vref_sat = min(Vref, Vlim)\n\n    # Handle null vector case\n    if Vref_sat == 0.0:\n        return [0, 0.0, 0.0, 1.0]\n\n    # Angle modulo 2*pi\n    theta_mod = theta % (2.0*np.pi)\n    k = detect_sector(theta_mod, Vref_sat)\n\n    # Reference components\n    v_alpha = Vref_sat * np.cos(theta_mod)\n    v_beta = Vref_sat * np.sin(theta_mod)\n    v_ref = np.array([v_alpha, v_beta], dtype=float)\n\n    # Get adjacent active vectors for sector k\n    vecs = active_vectors(Vdc)\n    V_k = vecs[k-1]\n    V_k1 = vecs[(k % 6)]  # wrap around for k+1\n    # Construct 2x2 matrix A and RHS b = Ts*v_ref\n    A = np.column_stack((V_k, V_k1))  # shape (2,2)\n    b = Ts * v_ref\n    # Solve for T1, T2\n    try:\n        T = np.linalg.solve(A, b)\n        T1, T2 = float(T[0]), float(T[1])\n    except np.linalg.LinAlgError:\n        # Fallback in degenerate case (should not occur for valid active vectors)\n        T1, T2 = 0.0, 0.0\n\n    # Normalize to duty ratios\n    d1 = T1 / Ts\n    d2 = T2 / Ts\n    # Clip tiny negative due to numerical errors\n    eps = 1e-12\n    if d1  0.0 and d1 > -eps:\n        d1 = 0.0\n    if d2  0.0 and d2 > -eps:\n        d2 = 0.0\n    # Ensure non-negativity\n    d1 = max(0.0, d1)\n    d2 = max(0.0, d2)\n    # Compute d0 and enforce sum to 1 within numerical tolerance\n    d0 = 1.0 - d1 - d2\n    if d0  0.0 and d0 > -eps:\n        d0 = 0.0\n    # If due to numerical issues sum exceeds 1 slightly, scale d1,d2\n    sum_d = d1 + d2 + d0\n    if abs(sum_d - 1.0) > 5e-12:\n        # Normalize the trio to sum to 1 while preserving non-negativity\n        total = d1 + d2\n        if total > 1.0:\n            # Saturate zero dwell\n            d1 = d1 / total\n            d2 = d2 / total\n            d0 = 0.0\n        else:\n            d0 = 1.0 - total\n    # Round to 10 decimal places for output\n    d1 = round(d1, 10)\n    d2 = round(d2, 10)\n    d0 = round(d0, 10)\n    return [k, d1, d2, d0]\n\ndef format_result_list(results):\n    \"\"\"\n    Format the list of per-case results [[k,d1,d2,d0], ...] with no spaces\n    and floating numbers already rounded to 10 decimal places.\n    \"\"\"\n    parts = []\n    for res in results:\n        k, d1, d2, d0 = res\n        # Ensure integer for k\n        k_str = str(int(k))\n        # Floats: format with 10 decimal places\n        d1_str = f\"{d1:.10f}\"\n        d2_str = f\"{d2:.10f}\"\n        d0_str = f\"{d0:.10f}\"\n        parts.append(f\"[{k_str},{d1_str},{d2_str},{d0_str}]\")\n    return f\"[{','.join(parts)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is (Vdc [V], Ts [s], Vref [V], theta [rad])\n    test_cases = [\n        (600.0, 1e-4, 300.0, 0.7),               # Case 1\n        (540.0, 5e-5, 200.0, np.pi/3.0),         # Case 2\n        (700.0, 2e-4, 420.0, 5.5),               # Case 3\n        (800.0, 1e-4, 0.0, 2.0),                 # Case 4\n        (500.0, 1.5e-4, 100.0, np.pi),           # Case 5\n        (650.0, 7e-5, 150.0, -0.1),              # Case 6\n    ]\n\n    results = []\n    for Vdc, Ts, Vref, theta in test_cases:\n        res = compute_duty_ratios(Vdc, Ts, Vref, theta)\n        results.append(res)\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_result_list(results))\n\nsolve()\n```"
        },
        {
            "introduction": "计算出有效矢量和零矢量的持续时间（占空时间）只是实现SVM的第一步。下一个关键问题是：如何安排这些矢量在开关周期内的施加顺序？本练习将带你深入探讨这一问题，你将学习如何设计一个能最小化开关损耗的优化开关序列，这是提升逆变器效率的关键。此外，你还将量化不同开关序列产生的共模电压，这是评估驱动系统电磁兼容（EMC）性能的重要指标。",
            "id": "3837777",
            "problem": "给定一个驱动电机的两电平三相电压源逆变器 (VSI)，该逆变器采用空间矢量调制 (SVM) 技术。逆变器桥臂被建模为连接到电压为 $V_{\\mathrm{dc}}$ 的直流 (DC) 母线上的理想开关。每个桥臂 $x \\in \\{a,b,c\\}$ 具有一个二进制开关状态 $S_x \\in \\{0,1\\}$，其中 $S_x=1$ 表示上管导通，$S_x=0$ 表示下管导通。桥臂中点相对于直流母线中点的电压为 $v_{xN} = (2 S_x - 1)\\, V_{\\mathrm{dc}}/2$。相端电压 $v_a$、$v_b$ 和 $v_c$ 是相对于电机星形接点的电压，满足 $v_x = v_{xN} - v_{\\mathrm{cm}}$，其中共模电压 $v_{\\mathrm{cm}}$ 定义为 $v_{\\mathrm{cm}} = (v_{aN} + v_{bN} + v_{cN})/3$。\n\n您的任务是，针对一个开关周期内期望的参考定子电压空间矢量轨迹，计算一个能使开关变换总次数最小化的开关序列，并量化由此产生的共模电压。该轨迹由空间矢量幅值 $V_{\\mathrm{ref}}$ 和电角度 $\\theta$ (以弧度为单位) 指定；直流母线电压 $V_{\\mathrm{dc}}$ 和开关周期 $T_s$ 也已给出。初始条件是逆变器前一个周期的结束状态 $s_{\\mathrm{prev}}$，其编码为整数 $s \\in \\{0,1,2,\\dots,7\\}$，映射关系为 $s = 4 S_a + 2 S_b + S_c$，其中 $S_a$、$S_b$ 和 $S_c$ 分别是 a、b、c三相的桥臂状态。\n\n必须使用的基本原理和约束条件：\n- Clarke变换和空间矢量表示法将三相电压简化为一个 $\\alpha\\beta$ 平面上的矢量。可行的逆变器空间矢量包括六个大小相等、角度相隔 $ \\pi/3 $ 弧度的非零有效矢量，以及位于原点的两个零矢量。\n- 在一个开关周期 $T_s$ 内，通过在两个相邻的有效矢量以及可能的一个零矢量上驻留，来合成期望的平均参考矢量。设扇区为两个相邻有效矢量之间的角度范围。对于一个角度 $\\theta$ 位于某个扇区内的期望 $V_{\\mathrm{ref}}$，必须通过在 $\\alpha\\beta$ 平面上求解矢量平均方程，从第一性原理推导出两个相邻有效矢量的驻留时间 $T_1$ 和 $T_2$，以及剩余的零矢量时间 $T_0=T_s - T_1 - T_2$。推导中不得使用任何捷径或预先制定的公式；您必须基于上述桥臂电压模型和几何关系进行推导。\n- 每个开关状态下的共模电压水平必须由 $v_{\\mathrm{cm}} = (v_{aN} + v_{bN} + v_{cN})/3$ 确定。您必须量化开关周期内共模电压的均方根 (RMS) 值，其公式为 $V_{\\mathrm{cm,RMS}} = \\sqrt{\\left( \\sum_i t_i\\, v_{\\mathrm{cm},i}^2\\right) / T_s }$，其中 $t_i$ 和 $v_{\\mathrm{cm},i}$ 分别是第 $i$ 个子区间的驻留时间和共模电压。\n- 一个周期内的开关序列被限制为四个子区间，顺序为：从一个零矢量开始，然后驻留于第一个有效矢量，接着是第二个有效矢量，最后结束于一个零矢量。这两个有效矢量必须是所确定扇区中的相邻矢量。零矢量可以是 $s=0$（所有下管导通）或 $s=7$（所有上管导通）。总的零矢量驻留时间 $T_0$ 必须在开始和结束时平均分配，因此每个零矢量子区间的持续时间为 $T_0/2$。在所有通过选择零矢量（起始和结束）和两个有效矢量的顺序而形成的候选序列中，选择使开关变换总次数最小化的那一个。开关变换总次数是周期内所有连续状态对（包括从前一结束状态 $s_{\\mathrm{prev}}$ 到起始零矢量的变换）的三个桥臂状态位之间的汉明距离之和。\n- 角度单位必须是弧度。所有电压答案必须以伏特表示，时间以秒表示。\n\n测试套件和要求的输出：\n- 实现一个程序，对于每个测试用例 $(V_{\\mathrm{dc}}, T_s, V_{\\mathrm{ref}}, \\theta, s_{\\mathrm{prev}})$，计算：\n    $1)$ 选定的四状态开关序列，表示为一个整数列表 $[s_1,s_2,s_3,s_4]$，使用编码 $s = 4 S_a + 2 S_b + S_c$，以及\n    $2)$ 开关周期内的共模电压均方根值 $V_{\\mathrm{cm,RMS}}$，单位为伏特。\n- 使用以下测试用例，每个元组为 $(V_{\\mathrm{dc}}, T_s, V_{\\mathrm{ref}}, \\theta, s_{\\mathrm{prev}})$:\n    $1)$ $(600,\\; 1.0\\times 10^{-4},\\; 200,\\; 0.3,\\; 0)$，\n    $2)$ $(600,\\; 1.0\\times 10^{-4},\\; 330,\\; \\pi/3 - 10^{-6},\\; 7)$，\n    $3)$ $(600,\\; 1.0\\times 10^{-4},\\; 1,\\; 2.0,\\; 3)$，\n    $4)$ $(600,\\; 1.0\\times 10^{-4},\\; 340,\\; 4.2,\\; 2)$。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，每个结果是一个双元素列表 $[\\,[s_1,s_2,s_3,s_4],\\; V_{\\mathrm{cm,RMS}}\\,]$。例如：$[[[s_1,s_2,s_3,s_4],V_1],[[...],V_2],...]$。数值必须是浮点数或整数，RMS值以伏特表示。\n\n您的实现必须是完全自包含的，不得读取任何输入，也不得使用任何外部文件或网络访问。推导必须基于上述桥臂电压模型和空间矢量几何，并且必须避免在问题陈述中使用捷径公式。",
            "solution": "该问题是有效的，因为它在科学上基于电力电子学和电机控制的原理，特别是空间矢量调制 (SVM)。问题陈述清晰、客观，并包含了推导唯一解所需的所有信息。数值在电压源逆变器驱动系统的实际范围内。我将进行完整的推导和求解。\n\n求解过程包括以下几个步骤：\n1.  根据给定的桥臂电压模型推导逆变器的空间电压矢量。\n2.  从第一性原理推导 SVM 算法的驻留时间。\n3.  构建优化问题，以选择开关变换次数最少的开关序列。\n4.  推导均方根 (RMS) 共模电压。\n5.  将此方法应用于给定的测试用例。\n\n**1. 逆变器空间矢量**\n\n一个两电平三相逆变器有 $2^3 = 8$ 种可能的开关状态，由三元组 $(S_a, S_b, S_c)$ 定义，其中 $S_x \\in \\{0, 1\\}$。状态被编码为整数 $s = 4S_a + 2S_b + S_c$。每个桥臂中点相对于直流母线中点的电压由 $v_{xN} = (S_x - 1/2)V_{\\mathrm{dc}}$ 给出。\n\n三相电压通过幅值不变的 Clarke 变换转换为二维空间矢量 $\\mathbf{v} = v_\\alpha + j v_\\beta$：\n$$ v_\\alpha = \\frac{2}{3}(v_{aN} - \\frac{1}{2}v_{bN} - \\frac{1}{2}v_{cN}) $$\n$$ v_\\beta = \\frac{2}{3}\\frac{\\sqrt{3}}{2}(v_{bN} - v_{cN}) = \\frac{1}{\\sqrt{3}}(v_{bN} - v_{cN}) $$\n代入 $v_{xN}$ 的表达式：\n$$ v_\\alpha = \\frac{2}{3} V_{\\mathrm{dc}} \\left[ (S_a - \\frac{1}{2}) - \\frac{1}{2}(S_b - \\frac{1}{2}) - \\frac{1}{2}(S_c - \\frac{1}{2}) \\right] = \\frac{V_{\\mathrm{dc}}}{3} (2S_a - S_b - S_c) $$\n$$ v_\\beta = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}} \\left[ (S_b - \\frac{1}{2}) - (S_c - \\frac{1}{2}) \\right] = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}} (S_b - S_c) $$\n使用这些公式，8个状态产生8个电压矢量。状态 $s=0$ $(000)$ 和 $s=7$ $(111)$ 产生零矢量 ($\\mathbf{V}_0 = \\mathbf{V}_7 = 0$)。其他6个状态产生幅值为 $\\frac{2}{3}V_{\\mathrm{dc}}$ 的有效矢量，角度相差 $\\pi/3$ 弧度，在 $\\alpha\\beta$ 平面上形成一个六边形。标准的有效矢量及其对应的状态是：\n- $\\mathbf{V}_1$ (状态 $s=4, 100$): 角度 $0$\n- $\\mathbf{V}_2$ (状态 $s=6, 110$): 角度 $\\pi/3$\n- $\\mathbf{V}_3$ (状态 $s=2, 010$): 角度 $2\\pi/3$\n- $\\mathbf{V}_4$ (状态 $s=3, 011$): 角度 $\\pi$\n- $\\mathbf{V}_5$ (状态 $s=1, 001$): 角度 $4\\pi/3$\n- $\\mathbf{V}_6$ (状态 $s=5, 101$): 角度 $5\\pi/3$\n\n**2. 从第一性原理推导驻留时间**\n\nSVM 通过在一个开关周期 $T_s$ 内对两个相邻的有效矢量和一个零矢量进行平均，来合成一个参考电压矢量 $\\mathbf{V}_{\\mathrm{ref}} = V_{\\mathrm{ref}} e^{j\\theta}$。平均原理是：\n$$ \\mathbf{V}_{\\mathrm{ref}} = \\frac{1}{T_s}(T_1 \\mathbf{V}_k + T_2 \\mathbf{V}_{k+1} + T_0 \\mathbf{V}_{\\mathrm{zero}}) $$\n其中 $\\mathbf{V}_k$ 和 $\\mathbf{V}_{k+1}$ 是界定包含 $\\mathbf{V}_{\\mathrm{ref}}$ 的扇区的两个有效矢量， $T_1$, $T_2$ 是它们各自的驻留时间。$T_0$ 是零矢量的总驻留时间。由于 $\\mathbf{V}_{\\mathrm{zero}}=0$，方程简化为 $T_s \\mathbf{V}_{\\mathrm{ref}} = T_1 \\mathbf{V}_k + T_2 \\mathbf{V}_{k+1}$。总时间受 $T_s = T_1 + T_2 + T_0$ 约束。\n\n为了求解 $T_1$ 和 $T_2$，我们将矢量方程投影到一个正交基上。我们定义一个坐标系，其u轴与第一个有效矢量 $\\mathbf{V}_k$ 对齐。设扇区索引为 $k_{sec} \\in \\{0, \\dots, 5\\}$，使得 $\\mathbf{V}_{\\mathrm{ref}}$ 位于角度为 $k_{sec}\\pi/3$ 和 $(k_{sec}+1)\\pi/3$ 的矢量之间。$\\mathbf{V}_{\\mathrm{ref}}$ 在扇区内的角度是 $\\theta' = \\theta - k_{sec}\\pi/3$。\n在这个旋转坐标系中，矢量为：\n- $\\mathbf{V}_{\\mathrm{ref}}$: $(V_{\\mathrm{ref}} \\cos \\theta', V_{\\mathrm{ref}} \\sin \\theta')$\n- $\\mathbf{V}_k$: $(V_s, 0)$，其中 $V_s = \\frac{2}{3}V_{\\mathrm{dc}}$ 是有效矢量的幅值。\n- $\\mathbf{V}_{k+1}$: $(V_s \\cos(\\pi/3), V_s \\sin(\\pi/3)) = (V_s/2, V_s \\sqrt{3}/2)$\n\n矢量方程分解为两个标量方程：\n$$ T_s V_{\\mathrm{ref}} \\cos \\theta' = T_1 V_s + T_2 (V_s/2) $$\n$$ T_s V_{\\mathrm{ref}} \\sin \\theta' = T_2 (V_s \\sqrt{3}/2) $$\n从第二个方程，我们解出 $T_2$：\n$$ T_2 = \\frac{2 T_s V_{\\mathrm{ref}} \\sin \\theta'}{V_s \\sqrt{3}} = \\frac{2 T_s V_{\\mathrm{ref}} \\sin \\theta'}{(\\frac{2}{3}V_{\\mathrm{dc}}) \\sqrt{3}} = \\frac{\\sqrt{3} T_s V_{\\mathrm{ref}}}{V_{\\mathrm{dc}}} \\sin(\\theta') $$\n将 $T_2$ 代入第一个方程求 $T_1$：\n$$ T_1 = \\frac{T_s V_{\\mathrm{ref}} \\cos \\theta'}{V_s} - \\frac{T_2}{2} = \\frac{T_s V_{\\mathrm{ref}}}{V_s} \\left( \\cos \\theta' - \\frac{\\sin \\theta'}{\\sqrt{3}} \\right) = \\frac{T_s V_{\\mathrm{ref}}}{V_s} \\frac{2}{\\sqrt{3}} \\sin(\\pi/3 - \\theta') $$\n$$ T_1 = \\frac{T_s V_{\\mathrm{ref}}}{(\\frac{2}{3}V_{\\mathrm{dc}})} \\frac{2}{\\sqrt{3}} \\sin(\\pi/3 - \\theta') = \\frac{\\sqrt{3} T_s V_{\\mathrm{ref}}}{V_{\\mathrm{dc}}} \\sin(\\pi/3 - \\theta') $$\n剩余时间是零矢量时间，$T_0 = T_s - T_1 - T_2$。如果 $V_{\\mathrm{ref}}$ 超出线性调制范围 ($T_1+T_2 > T_s$)，驻留时间将被缩放以在 $T_s$ 处饱和，导致 $T_0=0$。\n\n**3. 最优开关序列**\n\n开关序列结构为四个段：零矢量、第一个有效矢量、第二个有效矢量、零矢量。总零矢量时间 $T_0$ 被平均分配，因此持续时间为 $(T_0/2, T_{act1}, T_{act2}, T_0/2)$。我们必须选择起始/结束零矢量 ($s_{z1}, s_{z2} \\in \\{0, 7\\}$) 和有效矢量的顺序 ($s_{act1}, s_{act2}$) 以最小化总开关变换次数。成本是连续状态之间汉明距离的总和，从前一个状态 $s_{\\mathrm{prev}}$ 开始：\n$$ \\mathrm{Cost} = H(s_{\\mathrm{prev}}, s_{z1}) + H(s_{z1}, s_{act1}) + H(s_{act1}, s_{act2}) + H(s_{act2}, s_{z2}) $$\n汉明距离 $H(s_i, s_j)$ 是 $s_i$ 和 $s_j$ 二进制表示中不同位的数量。由于相邻有效矢量仅相差一位，所以 $H(s_{act1}, s_{act2})=1$。对于每个工作点，有8个候选序列，通过选择 $s_{z1} \\in \\{0,7\\}$, $s_{z2} \\in \\{0,7\\}$ 和有效矢量的顺序形成。我们评估所有8个候选序列的成本，并选择成本最小的序列。\n\n**4. RMS 共模电压**\n\n对于一个开关状态 $s=(S_a,S_b,S_c)$，共模电压为：\n$$ v_{\\mathrm{cm}}(s) = \\frac{v_{aN} + v_{bN} + v_{cN}}{3} = \\frac{1}{3} \\sum_{x \\in \\{a,b,c\\}} (S_x - \\frac{1}{2})V_{\\mathrm{dc}} = \\frac{V_{\\mathrm{dc}}}{6} (2(S_a+S_b+S_c) - 3) $$\n令 $p(s) = S_a+S_b+S_c$ 为状态二进制表示中‘1’的个数。则 $v_{\\mathrm{cm}}(s) = \\frac{V_{\\mathrm{dc}}}{6} (2p(s) - 3)$。$v_{\\mathrm{cm}}^2$ 的可能值为：\n- 零矢量 ($s=0, p=0$ 或 $s=7, p=3$): $v_{\\mathrm{cm}}(0) = -V_{\\mathrm{dc}}/2$, $v_{\\mathrm{cm}}(7) = +V_{\\mathrm{dc}}/2$。所以 $v_{\\mathrm{cm}}^2 = V_{\\mathrm{dc}}^2/4$。\n- 有效矢量 (p=1 或 p=2): $v_{\\mathrm{cm}}(p=1)=-V_{\\mathrm{dc}}/6$, $v_{\\mathrm{cm}}(p=2)=+V_{\\mathrm{dc}}/6$。所以 $v_{\\mathrm{cm}}^2 = V_{\\mathrm{dc}}^2/36$。\n\n在四段周期 $[s_1, s_2, s_3, s_4]$（持续时间为 $[T_0/2, T_{act1}, T_{act2}, T_0/2]$）内的 RMS 值为：\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{1}{T_s} \\left[ \\frac{T_0}{2} v_{\\mathrm{cm}}(s_1)^2 + T_{act1} v_{\\mathrm{cm}}(s_2)^2 + T_{act2} v_{\\mathrm{cm}}(s_3)^2 + \\frac{T_0}{2} v_{\\mathrm{cm}}(s_4)^2 \\right] $$\n由于两个零矢量的共模电压平方值相同，并且对于任何一对相邻的有效矢量（一个p=1，另一个p=2），其共模电压平方值也相同，因此无论选择哪个序列，表达式都可以简化：\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{1}{T_s} \\left[ T_0 \\left(\\frac{V_{\\mathrm{dc}}^2}{4}\\right) + (T_1+T_2)\\left(\\frac{V_{\\mathrm{dc}}^2}{36}\\right) \\right] $$\n使用 $T_1+T_2 = T_s-T_0$:\n$$ V_{\\mathrm{cm,RMS}}^2 = \\frac{V_{\\mathrm{dc}}^2}{T_s} \\left[ \\frac{T_0}{4} + \\frac{T_s-T_0}{36} \\right] = \\frac{V_{\\mathrm{dc}}^2}{36 T_s} [9T_0 + T_s - T_0] = \\frac{V_{\\mathrm{dc}}^2}{36 T_s} [8T_0 + T_s] $$\n$$ V_{\\mathrm{cm,RMS}} = \\frac{V_{\\mathrm{dc}}}{6} \\sqrt{8 \\frac{T_0}{T_s} + 1} $$\n这表明 $V_{\\mathrm{cm,RMS}}$ 仅取决于直流链路电压和开关周期中处于零状态的时间比例。\n\n**5. 算法与实现**\n\n对于每个测试用例，算法按以下步骤进行：\n1.  将输入角度 $\\theta$ 归一化到 $[0, 2\\pi)$ 范围。\n2.  确定扇区索引 $k_{sec} = \\lfloor \\theta / (\\pi/3) \\rfloor$。\n3.  确定该扇区的两个相邻有效状态，$S_u$ 和 $S_v$。\n4.  计算扇区内的角度，$\\theta' = \\theta - k_{sec}\\pi/3$。\n5.  计算驻留时间 $T_1$ (对应 $S_u$) 和 $T_2$ (对应 $S_v$)。如果 $T_1+T_2 > T_s$ (过调制)，则按比例缩放它们，使其总和为 $T_s$。\n6.  计算总零矢量时间 $T_0 = T_s - T_1 - T_2$。\n7.  生成所有8个候选开关序列。对每个序列，计算总开关成本（汉明距离之和）。\n8.  选择成本最小的序列。如果成本相同，则选择找到的第一个。\n9.  使用推导出的公式和最终的 $T_0$ 计算 $V_{\\mathrm{cm,RMS}}$。\n10. 存储最优序列和计算出的 $V_{\\mathrm{cm,RMS}}$。\n该过程在提供的 Python 代码中实现。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SVM problem for a two-level VSI for a given set of test cases.\n    It computes the optimal switching sequence and the RMS common-mode voltage.\n    \"\"\"\n\n    test_cases = [\n        (600, 1.0e-4, 200, 0.3, 0),\n        (600, 1.0e-4, 330, np.pi/3 - 1e-6, 7),\n        (600, 1.0e-4, 1, 2.0, 3),\n        (600, 1.0e-4, 340, 4.2, 2)\n    ]\n    \n    # Active voltage vectors states keyed by sector index (0-5)\n    # The states correspond to vectors at k*pi/3 and (k+1)*pi/3\n    active_states_by_sector = {\n        0: (4, 6),  # Sector 1: 0 to pi/3\n        1: (6, 2),  # Sector 2: pi/3 to 2pi/3\n        2: (2, 3),  # Sector 3: 2pi/3 to pi\n        3: (3, 1),  # Sector 4: pi to 4pi/3\n        4: (1, 5),  # Sector 5: 4pi/3 to 5pi/3\n        5: (5, 4)   # Sector 6: 5pi/3 to 2pi\n    }\n    \n    def hamming_distance(n1, n2):\n        \"\"\"Calculates the Hamming distance between two integers.\"\"\"\n        return bin(n1 ^ n2).count('1')\n\n    results = []\n    for V_dc, T_s, V_ref, theta, s_prev in test_cases:\n        # Step 1: Normalize angle and find sector\n        theta_norm = np.fmod(theta, 2 * np.pi)\n        if theta_norm  0:\n            theta_norm += 2 * np.pi\n        \n        # Handle edge case where theta is exactly 2*pi\n        if np.isclose(theta_norm, 2 * np.pi):\n            sector_idx = 0\n        else:\n            sector_idx = int(theta_norm / (np.pi / 3))\n\n        theta_prime = theta_norm - sector_idx * (np.pi / 3)\n\n        # Step 2: Calculate dwell times\n        # The constants are derived from the first-principles derivation\n        a = (np.sqrt(3) * T_s * V_ref) / V_dc\n        \n        # T1 is for the first vector of the sector, T2 for the second\n        T1 = a * np.sin(np.pi/3 - theta_prime)\n        T2 = a * np.sin(theta_prime)\n\n        # Step 3: Handle overmodulation (saturation)\n        if T1 + T2 > T_s:\n            T_total_active = T1 + T2\n            T1 = T1 * T_s / T_total_active\n            T2 = T2 * T_s / T_total_active\n        \n        T0 = T_s - (T1 + T2)\n        # Ensure T0 is not negative due to floating point inaccuracies\n        T0 = max(0, T0)\n\n        # Step 4: Find optimal switching sequence\n        S_u, S_v = active_states_by_sector[sector_idx]\n        zero_vectors = [0, 7]\n        best_sequence = []\n        min_cost = float('inf')\n\n        # There are 8 candidate sequences to check\n        # (start_zero, active_1, active_2, end_zero)\n        candidates = []\n        for z1 in zero_vectors:\n            for z2 in zero_vectors:\n                # Two possible orderings for active vectors\n                candidates.append((z1, S_u, S_v, z2))\n                candidates.append((z1, S_v, S_u, z2))\n\n        for seq in candidates:\n            s1, s2, s3, s4 = seq\n            cost = (hamming_distance(s_prev, s1) +\n                    hamming_distance(s1, s2) +\n                    hamming_distance(s2, s3) +\n                    hamming_distance(s3, s4))\n            \n            if cost  min_cost:\n                min_cost = cost\n                best_sequence = list(seq)\n        \n        # Step 5: Calculate RMS common-mode voltage\n        # V_cm_rms = (V_dc/6) * sqrt(8 * (T0/T_s) + 1)\n        V_cm_rms = (V_dc / 6.0) * np.sqrt(8 * (T0 / T_s) + 1)\n        \n        # Format the result for this test case\n        seq_str = '[' + ','.join(map(str, best_sequence)) + ']'\n        res_str = '[' + seq_str + ', ' + f'{V_cm_rms:.7f}' + ']'\n        results.append(res_str)\n\n    # Print a single line of output with all results\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "理论上的SVM算法处理的是连续的时间和幅值，但在数字信号处理器（DSP）或现场可编程门阵列（FPGA）中，一切都必须是离散和量化的。本练习旨在模拟这一从理想到现实的转换过程，你将需要处理由固定频率时钟引起的占空时间量化、过调制饱和，以及为保护功率器件而必须遵守的最小脉冲宽度限制。通过解决这些实际工程问题，你将能更好地理解在嵌入式系统中实现高性能电机驱动所面临的挑战。",
            "id": "3882579",
            "problem": "您的任务是在适用于数字信号处理器 (DSP) 或现场可编程门阵列 (FPGA) 上实时运行的数字逻辑环境中，实现空间矢量调制 (SVM) 的驻留时间计算核心。推导必须从两电平三相电压源逆变器的基本表示和Clarke变换开始，然后继续在数字量化和最小脉冲约束下，在一个固定的开关周期内分配开关矢量的驻留时间。\n\n基本原理与设置：考虑一个由电压为 $V_{\\mathrm{dc}}$ 的直流母线供电的两电平三相逆变器。每相的极电压取值为 $0$ 或 $V_{\\mathrm{dc}}$。在 $\\alpha\\beta$ 平面中的合成空间矢量可以通过Clarke变换构建，由相极电压 $v_a$, $v_b$, $v_c$ 定义如下\n$$\n\\begin{bmatrix}\nv_\\alpha\\\\\nv_\\beta\n\\end{bmatrix}\n=\\frac{2}{3}\n\\begin{bmatrix}\n1  -\\frac{1}{2}  -\\frac{1}{2}\\\\\n0  \\frac{\\sqrt{3}}{2}  -\\frac{\\sqrt{3}}{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nv_a\\\\\nv_b\\\\\nv_c\n\\end{bmatrix}.\n$$\n逆变器有六个幅值为 $\\frac{2}{3}V_{\\mathrm{dc}}$ 的非零有效空间矢量，形成一个正六边形，以及两个幅值为 $0$ 的零矢量。在每个开关周期 $T_s$ 内，SVM通过对两个相邻的有效矢量和一个零矢量进行时间平均，来近似一个参考矢量 $V_{\\mathrm{ref}}$（在 $\\alpha\\beta$ 平面中表示，其幅值为 $|V_{\\mathrm{ref}}|$，角度为 $\\theta_{\\mathrm{ref}}$）。扇区选择将角度范围 $[0,2\\pi)$ 划分为六个宽度为 $\\frac{\\pi}{3}$ 弧度的扇区。在实时实现中，当 $\\theta_{\\mathrm{ref}}$ 正好位于扇区边界上时，必须选择索引较小的扇区以避免不连续性。\n\n目标推导与实现要求：\n- 从第一性原理出发，使用 $\\alpha\\beta$ 平面中的矢量方程，推导出在一个开关周期 $T_s$ 内的有效矢量驻留时间 $T_1$ 和 $T_2$ 以及零矢量驻留时间 $T_0$，用 $V_{\\mathrm{dc}}$、$|V_{\\mathrm{ref}}|$ 和 $\\theta_{\\mathrm{ref}}$ 表示。推导必须使用将 $V_{\\mathrm{ref}}$ 分解到跨越包含 $\\theta_{\\mathrm{ref}}$ 的扇区的两个相邻有效矢量上的方法，其基由通过Clarke变换构建的逆变器空间矢量定义。未经推导，不得假定使用任何简化公式。\n- 如果计算出的 $T_0$ 为负（这表示相对于线性六边形发生了过调制），您必须通过按比例缩放 $T_1$ 和 $T_2$ 来使合成饱和，以使 $T_0=0$ 且 $T_1+T_2=T_s$，从而确保物理可实现性。\n- 实现数字量化：给定一个频率为 $f_{\\mathrm{clk}}$ 赫兹的时钟，整数驻留时钟周期数为 $N_i=\\mathrm{round}(T_i\\cdot f_{\\mathrm{clk}})$，其中 $i\\in\\{0,1,2\\}$，总时钟周期数为 $N_{T_s}=\\mathrm{round}(T_s\\cdot f_{\\mathrm{clk}})$。您必须通过将 $N_0$ 修正为 $N_{T_s}-N_1-N_2$ 来保证量化后 $N_0+N_1+N_2=N_{T_s}$。\n- 强制执行最小脉冲约束：每个驻留计数必须满足 $N_i\\ge N_{\\min}$，其中 $N_{\\min}$ 是一个预设的最小整数时钟周期数。如果任何 $N_i  N_{\\min}$，您必须实现一种重新分配算法，该算法增加不足的脉冲计数以满足 $N_{\\min}$，并从其他驻留时间中减去相应的总时钟周期数。优先从最大的可用驻留时间（如果可能，优先从 $N_0$）减去。保证 $3N_{\\min} \\le N_{T_s}$，因此总是可以找到一个解。\n- 您的程序应为每个提供的测试用例生成一个四元素列表：`[sector, N0, N1, N2]`，其中 `sector` 是一个从 $1$ 到 $6$ 的整数，`N0`、`N1` 和 `N2` 是最终的整数时钟周期数。\n\n测试套件和要求的输出：\n- 使用以下测试用例，每个元组为 $(V_{\\mathrm{dc}}, T_s, f_{\\mathrm{clk}}, |V_{\\mathrm{ref}}|, \\theta_{\\mathrm{ref}}, N_{\\min})$:\n    - Case A (通用情况): $(600, 50\\times 10^{-6}, 100\\times 10^6, 200, 0.8, 50)$\n    - Case B (高幅值下的边界角度): $(700, 20\\times 10^{-6}, 50\\times 10^6, 0.99 \\times (2/3) \\times 700, \\pi/3, 10)$\n    - Case C (需要最小脉冲强制的极小幅值): $(400, 10\\times 10^{-6}, 25\\times 10^6, 1, 0.01, 15)$\n    - Case D (过调制): $(800, 40\\times 10^{-6}, 80\\times 10^6, 600, 3.4, 100)$\n- 您的程序应生成一个单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个结果是一个四元素列表 `[sector,N0,N1,N2]`。例如：`[[1,100,500,400],[2,50,600,350],...]`。输出字符串中不得有空格。",
            "solution": "用户提供了一个基于电力电子学原理的、有效且定义明确的问题。任务是推导并实现用于两电平三相逆变器的空间矢量调制 (SVM) 的核心逻辑，包括实际的数字约束。解决方案首先从基本原理推导驻留时间，然后应用指定的饱和、量化和最小脉宽约束。\n\n### 1. 基本原理与空间矢量定义\n\n一个两电平三相逆变器将其三个输出相（$a$、$b$、$c$）分别连接到电压为 $V_{\\mathrm{dc}}$ 的直流母线的正极或负极。我们假设相对于直流负母线的相极电压（$v_a$、$v_b$、$v_c$）为 $0$ 或 $V_{\\mathrm{dc}}$。存在 $2^3 = 8$ 种可能的开关状态，由一个三元组 $(S_a, S_b, S_c)$ 表示，其中 $S_k \\in \\{0, 1\\}$。\n\n静止坐标系下的电压（$v_\\alpha$, $v_\\beta$）通过所提供的Clarke变换获得：\n$$\n\\begin{bmatrix}\nv_\\alpha\\\\\nv_\\beta\n\\end{bmatrix}\n=\\frac{2}{3}\n\\begin{bmatrix}\n1  -\\frac{1}{2}  -\\frac{1}{2}\\\\\n0  \\frac{\\sqrt{3}}{2}  -\\frac{\\sqrt{3}}{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nv_a\\\\\nv_b\\\\\nv_c\n\\end{bmatrix}\n$$\n将此变换应用于八个开关状态，可得到六个非零的有效矢量和两个零矢量。例如，对于状态 $(1,0,0)$，其中 $v_a=V_{\\mathrm{dc}}, v_b=0, v_c=0$：\n$$\nV_1 = \\begin{bmatrix}v_\\alpha\\\\v_\\beta\\end{bmatrix} = \\frac{2}{3} \\begin{bmatrix} 1  -1/2  -1/2 \\\\ 0  \\sqrt{3}/2  -\\sqrt{3}/2 \\end{bmatrix} \\begin{bmatrix}V_{\\mathrm{dc}}\\\\0\\\\0\\end{bmatrix} = \\begin{bmatrix}\\frac{2}{3}V_{\\mathrm{dc}}\\\\0\\end{bmatrix}\n$$\n在复数表示中，这表示为 $V_1 = \\frac{2}{3}V_{\\mathrm{dc}}e^{j0}$。类似地，可以求得其他五个有效矢量为 $V_k = \\frac{2}{3}V_{\\mathrm{dc}} e^{j(k-1)\\pi/3}$，其中 $k \\in \\{1, \\dots, 6\\}$。这些矢量在 $\\alpha\\beta$ 平面中形成一个正六边形。两个零矢量，$V_0$（来自状态 $(0,0,0)$）和 $V_7$（来自状态 $(1,1,1)$），位于原点。\n\n### 2. 驻留时间推导\n\nSVM的核心是在一个开关周期 $T_s$ 内，通过对三个静止矢量进行时间平均，来合成一个期望的参考电压矢量 $V_{\\mathrm{ref}}$。所选的三个矢量是界定包含 $V_{\\mathrm{ref}}$ 的扇区的两个相邻有效矢量，以及一个零矢量。\n\n伏秒平衡原理指出，参考矢量与开关周期的乘积必须等于所施加的矢量与其各自驻留时间（$T_1, T_2, T_0$）乘积之和：\n$$\nV_{\\mathrm{ref}} T_s = V_k T_1 + V_{k+1} T_2 + V_0 T_0\n$$\n驻留时间之和必须等于开关周期：$T_s = T_1 + T_2 + T_0$。\n由于 $V_0$ 是零矢量，第一个方程简化为：\n$$\nV_{\\mathrm{ref}} T_s = V_k T_1 + V_{k+1} T_2\n$$\n为了求解 $T_1$ 和 $T_2$，我们将这个矢量方程投影到一个方便的基上。选择一个旋转了角度 $\\phi = (k-1)\\pi/3$ 的坐标系，其中 $k$ 是扇区索引（$k \\in \\{1, \\dots, 6\\}$）。在这个旋转坐标系中，第一个有效矢量 $V'_k = V_k e^{-j\\phi}$ 位于实轴上。设 $\\theta'$ 为 $V_{\\mathrm{ref}}$ 在这个新坐标系中的角度，因此 $\\theta' = \\theta_{\\mathrm{ref}} - \\phi$。矢量方程变为：\n$$\nV'_{\\mathrm{ref}} T_s = V'_k T_1 + V'_{k+1} T_2\n$$\n其中 $V'_{\\mathrm{ref}} = |V_{\\mathrm{ref}}|e^{j\\theta'}$，$V'_k = \\frac{2}{3}V_{\\mathrm{dc}}$，且 $V'_{k+1} = \\frac{2}{3}V_{\\mathrm{dc}}e^{j\\pi/3}$。代入这些复数值：\n$$\n|V_{\\mathrm{ref}}| T_s (\\cos\\theta' + j\\sin\\theta') = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right) T_1 + \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\left(\\cos\\frac{\\pi}{3} + j\\sin\\frac{\\pi}{3}\\right)\\right) T_2\n$$\n$$\n|V_{\\mathrm{ref}}| T_s (\\cos\\theta' + j\\sin\\theta') = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right) T_1 + \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\left(\\frac{1}{2} + j\\frac{\\sqrt{3}}{2}\\right)\\right) T_2\n$$\n令虚部和实部相等：\n$$\n\\text{(虚部)}: \\quad |V_{\\mathrm{ref}}| T_s \\sin\\theta' = \\left(\\frac{2}{3}V_{\\mathrm{dc}}\\right)\\left(\\frac{\\sqrt{3}}{2}\\right)T_2 = \\frac{V_{\\mathrm{dc}}}{\\sqrt{3}}T_2 \\implies T_2 = \\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}}\\sin\\theta'\n$$\n$$\n\\text{(实部)}: \\quad |V_{\\mathrm{ref}}| T_s \\cos\\theta' = \\frac{2}{3}V_{\\mathrm{dc}}T_1 + \\frac{1}{3}V_{\\mathrm{dc}}T_2\n$$\n将 $T_2$ 代入实部方程：\n$$\n\\frac{2}{3}V_{\\mathrm{dc}}T_1 = |V_{\\mathrm{ref}}| T_s \\cos\\theta' - \\frac{1}{3}V_{\\mathrm{dc}}\\left(\\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}}\\sin\\theta'\\right) = |V_{\\mathrm{ref}}| T_s \\left(\\cos\\theta' - \\frac{\\sin\\theta'}{\\sqrt{3}}\\right)\n$$\n$$\nT_1 = \\frac{3|V_{\\mathrm{ref}}|T_s}{2V_{\\mathrm{dc}}} \\frac{2}{\\sqrt{3}}\\left(\\frac{\\sqrt{3}}{2}\\cos\\theta' - \\frac{1}{2}\\sin\\theta'\\right) = \\frac{\\sqrt{3}|V_{\\mathrm{ref}}|T_s}{V_{\\mathrm{dc}}} \\sin\\left(\\frac{\\pi}{3} - \\theta'\\right)\n$$\n零矢量的驻留时间则为 $T_0 = T_s - T_1 - T_2$。\n\n### 3. 实现逻辑\n\n完整的实现算法包含了推导出的公式和问题陈述中指定的约束。\n\n1.  **扇区识别**：将角度 $\\theta_{\\mathrm{ref}}$ 归一化到 $[0, 2\\pi)$。确定扇区索引 $k \\in \\{1, ..., 6\\}$。扇区 $k$ 覆盖角度区域 $[(k-1)\\pi/3, k\\pi/3)$。问题规定，如果 $\\theta_{\\mathrm{ref}}$ 落在边界上，则选择索引较小的扇区。这通过对归一化角度 `theta_ref/(pi/3)` 向下取整并对精确整数结果进行校正来处理。\n\n2.  **驻留时间计算**：使用扇区索引 $k$ 和扇区内角度 $\\theta' = \\theta_{\\mathrm{ref}} - (k-1)\\pi/3$，通过推导出的公式计算理想驻留时间 $T_1$ 和 $T_2$。\n\n3.  **过调制处理**：如果计算出的 $T_0 = T_s - T_1 - T_2$ 为负，则参考矢量超出了可实现电压的六边形范围（过调制）。将有效时间 $T_1$ 和 $T_2$ 按比例缩小以适应 $T_s$，使其总和恰好为 $T_s$。这将 $T_0$ 设置为零。新的时间为 $T'_1 = T_1 \\frac{T_s}{T_1+T_2}$ 和 $T'_2 = T_2 \\frac{T_s}{T_1+T_2}$。\n\n4.  **数字量化**：将连续时间的驻留时长转换为整数时钟周期数。$N_{T_s} = \\mathrm{round}(T_s \\cdot f_{\\mathrm{clk}})$。有效矢量时钟周期数为 $N_1 = \\mathrm{round}(T_1 \\cdot f_{\\mathrm{clk}})$ 和 $N_2 = \\mathrm{round}(T_2 \\cdot f_{\\mathrm{clk}})$。为确保时钟周期数总和守恒，零矢量时钟周期数作为余数计算：$N_0 = N_{T_s} - N_1 - N_2$。\n\n5.  **最小脉冲约束**：为防止对硬件造成问题的极短脉冲，每个时钟周期计数 $N_i$ 必须至少为 $N_{\\min}$。如果任何 $N_i  N_{\\min}$，则应用重新分配算法：\n    a. 计算每个脉冲的不足量：$\\Delta_i = \\max(0, N_{\\min} - N_i)$。\n    b. 将总不足量相加，$\\Delta_{\\mathrm{total}} = \\sum \\Delta_i$。\n    c. 每个脉冲计数临时增加其不足量：$N'_i = N_i + \\Delta_i$。\n    d. 总不足量 $\\Delta_{\\mathrm{total}}$ 必须从“提供”脉冲（那些原本满足 $N_i \\ge N_{\\min}$ 的脉冲）中减去。\n    e. 根据规则对提供者进行排序：“优先从最大的可用驻留时间（如果可能，优先从 $N_0$）”。这是通过根据其原始时钟周期数 $N_i$ 降序排序提供者索引来实现的，索引 $0$ 用作平局决胜者。\n    f. 算法遍历排序后的提供者，从每个提供者中减去所需量，直到补偿总不足量，同时确保没有提供者的计数低于 $N_{\\min}$。问题保证这总是可能的，因为 $3N_{\\min} \\le N_{T_s}$。\n\n这种结构化方法确保满足所有物理和数字约束，从而产生一个SVM核心的实用实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the SVM problem for the given test cases.\n    \"\"\"\n\n    def calculate_svm_ticks(V_dc, T_s, f_clk, V_ref_mag, theta_ref, N_min):\n        \"\"\"\n        Calculates SVM dwell time ticks for a given set of parameters,\n        following the derivation and constraints.\n        \"\"\"\n        # Step 1: Normalize theta_ref to [0, 2*pi)\n        theta_ref_norm = theta_ref % (2 * np.pi)\n\n        # Step 2: Determine sector\n        # The problem states: \"when theta_ref lies exactly on a sector boundary,\n        # the lower-index sector must be chosen\".\n        angle_norm_units = theta_ref_norm / (np.pi / 3)\n        \n        sector_idx = np.floor(angle_norm_units)\n\n        # Boundary condition: if angle is an integer multiple of pi/3 (and not 0),\n        # it belongs to the boundary, so we select the lower-index sector by\n        # decrementing the calculated index. A small tolerance is used for float comparison.\n        if angle_norm_units > 1e-9 and np.isclose(angle_norm_units, np.round(angle_norm_units)):\n            sector_idx = np.round(angle_norm_units) - 1\n        \n        # Handle the edge case where angle is 2*pi, which normalizes to 0, but\n        # a calculated index could be 6. The sectors are 1-6 (indices 0-5).\n        if sector_idx >= 6:\n            sector_idx = 5\n        \n        sector = int(sector_idx) + 1\n\n        # Step 3: Calculate angle within the sector\n        theta_prime = theta_ref_norm - sector_idx * (np.pi / 3)\n\n        # Step 4: Calculate ideal dwell times based on the derived formulas\n        # T1 is the dwell time for the first active vector of the sector.\n        # T2 is the dwell time for the second active vector of the sector.\n        common_factor = (np.sqrt(3) * V_ref_mag * T_s) / V_dc\n        T1 = common_factor * np.sin(np.pi/3 - theta_prime)\n        T2 = common_factor * np.sin(theta_prime)\n\n        # Step 5: Calculate T0 and check for overmodulation\n        T0 = T_s - T1 - T2\n\n        # Step 6: Handle overmodulation by saturating the dwell times\n        if T0  0:\n            T_sum_active = T1 + T2\n            if T_sum_active > 1e-12:  # Avoid division by zero\n                scale_factor = T_s / T_sum_active\n                T1 *= scale_factor\n                T2 *= scale_factor\n            else: # Should not happen in valid cases, but for robustness\n                T1 = T_s / 2.0\n                T2 = T_s / 2.0\n            T0 = 0.0\n\n        # Step 7: Perform digital quantization\n        N_Ts = int(np.round(T_s * f_clk))\n        N1 = int(np.round(T1 * f_clk))\n        N2 = int(np.round(T2 * f_clk))\n        # N0 is calculated as the remainder to conserve the total ticks\n        N0 = N_Ts - N1 - N2\n        \n        N = [N0, N1, N2]\n\n        # Step 8: Enforce the minimum pulse constraint\n        deficits = [max(0, N_min - val) for val in N]\n        total_deficit = sum(deficits)\n        \n        if total_deficit > 0:\n            # Create adjusted counts by raising all sub-minimum pulses to N_min\n            N_adj = [val + d for val, d in zip(N, deficits)]\n            \n            amount_to_reduce = total_deficit\n            \n            # Identify donor pulses (those that were originally >= N_min)\n            donor_indices = [i for i, d in enumerate(deficits) if d == 0]\n            \n            # Sort donors: largest first, with N0 as tie-breaker for the \"favor N0\" rule.\n            # This is achieved by sorting using a tuple key (-N[i], i).\n            sorted_donors = sorted(donor_indices, key=lambda i: (-N[i], i))\n            \n            for i in sorted_donors:\n                if amount_to_reduce = 0:\n                    break\n                \n                # Max amount we can take from this pulse without violating its own N_min\n                can_reduce = N_adj[i] - N_min\n                \n                # Actual reduction is the minimum of what's needed and what's available\n                reduction = min(amount_to_reduce, can_reduce)\n                \n                N_adj[i] -= reduction\n                amount_to_reduce -= reduction\n            \n            N_final = N_adj\n        else:\n            N_final = N\n            \n        return [sector, N_final[0], N_final[1], N_final[2]]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General case\n        (600, 50e-6, 100e6, 200, 0.8, 50),\n        # Case B: Boundary angle with high amplitude\n        (700, 20e-6, 50e6, 0.99 * (2/3) * 700, np.pi/3, 10),\n        # Case C: Very small amplitude requiring minimum pulse enforcement\n        (400, 10e-6, 25e6, 1, 0.01, 15),\n        # Case D: Overmodulation\n        (800, 40e-6, 80e6, 600, 3.4, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_svm_ticks(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{s},{n0},{n1},{n2}]\" for s, n0, n1, n2 in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}