{
    "hands_on_practices": [
        {
            "introduction": "Evaluating the efficiency of a power converter is a fundamental engineering task. This practice moves beyond idealized component models to a more realistic scenario where semiconductor losses are described by empirical formulas derived from laboratory measurements . By calculating both switching and conduction losses for a PWM-controlled Current Source Inverter (CSI), you will develop the essential skill of estimating inverter efficiency based on practical device characteristics and operating conditions.",
            "id": "3831795",
            "problem": "A three-phase Current Source Inverter (CSI) using six Gate Turn-Off Thyristors (GTOs) is fed from a direct current (DC) link with a large series inductance such that the DC link current ripple is negligible. The inverter employs balanced, symmetric carrier-based Pulse-Width Modulation (PWM) at a switching frequency $f_{\\text{s}}$, and operates at unity power factor into a balanced load. Under these conditions, the instantaneous current through any switching device at its turn-on and turn-off instants can be taken equal to the DC link current $I_{\\text{dc}}$.\n\nFor a specific device family, laboratory measurements of the turn-on and turn-off switching energies per event as functions of the device current $I$ are modeled by the polynomial fits\n$$\nE_{\\text{on}}(I) = a_{1} I + a_{2} I^{2}, \\quad E_{\\text{off}}(I) = b_{1} I + b_{2} I^{2},\n$$\nwhere $E_{\\text{on}}$ and $E_{\\text{off}}$ are in $\\text{J}$, $I$ is in $\\text{A}$, and the coefficients are $a_{1} = 2.0 \\times 10^{-4}\\,\\text{J/A}$, $a_{2} = 4.0 \\times 10^{-6}\\,\\text{J/A}^{2}$, $b_{1} = 1.5 \\times 10^{-4}\\,\\text{J/A}$, and $b_{2} = 3.0 \\times 10^{-6}\\,\\text{J/A}^{2}$. The device on-state voltage characteristic is modeled as\n$$\nV_{\\text{on}}(I) = V_{k} + r I,\n$$\nwith $V_{k} = 1.8\\,\\text{V}$ and $r = 3.0 \\times 10^{-3}\\,\\Omega$. Assume that, due to the balanced three-phase modulation, each of the six GTOs conducts for one-third of the fundamental period on average and, in steady-state PWM, each device undergoes exactly one turn-on and one turn-off per PWM period.\n\nGiven $I_{\\text{dc}} = 300\\,\\text{A}$, $f_{\\text{s}} = 2.0 \\times 10^{3}\\,\\text{s}^{-1}$, and a target output power $P_{\\text{out}} = 2.0 \\times 10^{5}\\,\\text{W}$, compute:\n1. The switching loss power per device using the measured $E_{\\text{on}}(I)$ and $E_{\\text{off}}(I)$ evaluated at $I = I_{\\text{dc}}$, and the stated modulation assumptions.\n2. The inverter efficiency defined as the ratio of output power to input power when only semiconductor conduction and switching losses in the six GTOs are counted.\n\nExpress the final efficiency as a decimal number and round your answer to four significant figures. Do not include any unit with the final answer.",
            "solution": "The problem requires the computation of two quantities: the switching loss power per device and the total inverter efficiency.\n\nFirst, we calculate the switching loss power for a single GTO device, denoted as $P_{\\text{sw,dev}}$. The problem states that each device undergoes one turn-on event and one turn-off event per switching period, $T_{\\text{s}} = 1/f_{\\text{s}}$. The current through the device at these switching instants is given as the DC link current, $I_{\\text{dc}}$.\n\nThe turn-on and turn-off energies, $E_{\\text{on}}$ and $E_{\\text{off}}$, are functions of the device current $I$. We evaluate these at $I = I_{\\text{dc}}$.\nThe turn-on energy per event is:\n$$E_{\\text{on}}(I_{\\text{dc}}) = a_{1} I_{\\text{dc}} + a_{2} I_{\\text{dc}}^{2}$$\nAnd the turn-off energy per event is:\n$$E_{\\text{off}}(I_{\\text{dc}}) = b_{1} I_{\\text{dc}} + b_{2} I_{\\text{dc}}^{2}$$\nThe total switching energy dissipated in one device during a single switching period is the sum of the turn-on and turn-off energies:\n$$E_{\\text{sw,dev}} = E_{\\text{on}}(I_{\\text{dc}}) + E_{\\text{off}}(I_{\\text{dc}}) = (a_{1} + b_{1}) I_{\\text{dc}} + (a_{2} + b_{2}) I_{\\text{dc}}^{2}$$\nThe average switching power loss per device is this energy per cycle multiplied by the switching frequency $f_{\\text{s}}$:\n$$P_{\\text{sw,dev}} = E_{\\text{sw,dev}} \\times f_{\\text{s}} = \\left[ (a_{1} + b_{1}) I_{\\text{dc}} + (a_{2} + b_{2}) I_{\\text{dc}}^{2} \\right] f_{\\text{s}}$$\nThe given parameter values are:\n$I_{\\text{dc}} = 300\\,\\text{A}$\n$f_{\\text{s}} = 2.0 \\times 10^{3}\\,\\text{s}^{-1}$\n$a_{1} = 2.0 \\times 10^{-4}\\,\\text{J/A}$\n$a_{2} = 4.0 \\times 10^{-6}\\,\\text{J/A}^{2}$\n$b_{1} = 1.5 \\times 10^{-4}\\,\\text{J/A}$\n$b_{2} = 3.0 \\times 10^{-6}\\,\\text{J/A}^{2}$\n\nSubstituting these values into the expression for $P_{\\text{sw,dev}}$:\n$$P_{\\text{sw,dev}} = \\left[ (2.0 \\times 10^{-4} + 1.5 \\times 10^{-4}) \\times 300 + (4.0 \\times 10^{-6} + 3.0 \\times 10^{-6}) \\times (300)^{2} \\right] \\times (2.0 \\times 10^{3})$$\n$$P_{\\text{sw,dev}} = \\left[ (3.5 \\times 10^{-4}) \\times 300 + (7.0 \\times 10^{-6}) \\times 90000 \\right] \\times 2000$$\n$$P_{\\text{sw,dev}} = \\left[ 0.105 + 0.63 \\right] \\times 2000 = 0.735 \\times 2000 = 1470\\,\\text{W}$$\nThis is the first required result: the switching loss power per device is $1470\\,\\text{W}$.\n\nNext, we compute the inverter efficiency, $\\eta$. Efficiency is the ratio of output power $P_{\\text{out}}$ to input power $P_{\\text{in}}$:\n$$\\eta = \\frac{P_{\\text{out}}}{P_{\\text{in}}}$$\nThe input power is the sum of the output power and the total power losses in the inverter, $P_{\\text{loss}}$:\n$$P_{\\text{in}} = P_{\\text{out}} + P_{\\text{loss}}$$\nThe total losses are specified to be the sum of semiconductor switching and conduction losses for all six GTOs.\n$$P_{\\text{loss}} = P_{\\text{sw,total}} + P_{\\text{cond,total}}$$\nThe total switching loss for the six devices is:\n$$P_{\\text{sw,total}} = 6 \\times P_{\\text{sw,dev}} = 6 \\times 1470 = 8820\\,\\text{W}$$\nTo find the total conduction loss, $P_{\\text{cond,total}}$, we first find the on-state voltage drop across a single device when it conducts the current $I_{\\text{dc}}$. Using the given model $V_{\\text{on}}(I) = V_{k} + rI$ with $V_{k} = 1.8\\,\\text{V}$ and $r = 3.0 \\times 10^{-3}\\,\\Omega$:\n$$V_{\\text{on}}(I_{\\text{dc}}) = 1.8 + (3.0 \\times 10^{-3}) \\times 300 = 1.8 + 0.9 = 2.7\\,\\text{V}$$\nIn a three-phase CSI bridge, at any instant in time, two devices conduct the full DC link current $I_{\\text{dc}}$ (one in the upper group and one in the lower group). Therefore, the total instantaneous conduction power loss in the inverter is constant and is given by:\n$$P_{\\text{cond,total}} = 2 \\times V_{\\text{on}}(I_{\\text{dc}}) \\times I_{\\text{dc}}$$\n$$P_{\\text{cond,total}} = 2 \\times 2.7 \\times 300 = 1620\\,\\text{W}$$\nThis result is consistent with the information that each device has an average conduction duty cycle of $1/3$. The conduction loss per device would be $P_{\\text{cond,dev}} = (1/3) \\times V_{\\text{on}}(I_{\\text{dc}}) \\times I_{\\text{dc}} = (1/3) \\times 2.7 \\times 300 = 270\\,\\text{W}$, and for six devices, $P_{\\text{cond,total}} = 6 \\times 270 = 1620\\,\\text{W}$.\n\nNow, we can calculate the total power loss:\n$$P_{\\text{loss}} = P_{\\text{sw,total}} + P_{\\text{cond,total}} = 8820\\,\\text{W} + 1620\\,\\text{W} = 10440\\,\\text{W}$$\nThe output power is given as $P_{\\text{out}} = 2.0 \\times 10^{5}\\,\\text{W} = 200000\\,\\text{W}$.\nThe input power is:\n$$P_{\\text{in}} = P_{\\text{out}} + P_{\\text{loss}} = 200000\\,\\text{W} + 10440\\,\\text{W} = 210440\\,\\text{W}$$\nFinally, the inverter efficiency is:\n$$\\eta = \\frac{P_{\\text{out}}}{P_{\\text{in}}} = \\frac{200000}{210440} \\approx 0.95038965976$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\\eta \\approx 0.9504$$",
            "answer": "$$\\boxed{0.9504}$$"
        },
        {
            "introduction": "A defining characteristic of the Current Source Inverter is its interaction with load-side capacitance, which can lead to potentially damaging voltage oscillations during commutation. This exercise models this critical transient phenomenon as a second-order RLC circuit, providing a hands-on opportunity to analyze the resulting resonance . You will apply fundamental circuit theory to determine the minimum damping required to ensure a stable, non-oscillatory voltage response, a crucial step in robust CSI design.",
            "id": "3831830",
            "problem": "A three-phase Current Source Inverter (CSI) employs a large direct current link inductor to approximate a stiff current source. During commutation, the output current is abruptly transferred from one leg to another, producing a step change in the phase current that momentarily isolates the load dynamics and excites parasitic elements. Consider one phase leg during such a commutation interval. The load exhibits a lumped stray capacitance $C_L$ from the phase node to the return. The commutation dynamics can be reduced to the loop comprised of the CSI link inductance $L_s$ and the stray capacitance $C_L$, because the load conductance is negligible on the commutation timescale. To mitigate overvoltage oscillations, a damping resistor $R_d$ is inserted in series with the dominant capacitive path via a series resistor-capacitor snubber branch connected across the load terminals; this snubber is designed so that, over the commutation timescale, the effective capacitive path is dominated by the inherent $C_L$ and the series resistor $R_d$ lies in the same loop as $L_s$ and $C_L$. The commutation event can be modeled as a step change $\\Delta I$ in the inverter output current injected into this loop at $t=0^{+}$, with the switching interval short relative to the load time constants.\n\nStarting from Kirchhoff’s laws and the constitutive relations $v_L = L\\frac{di}{dt}$ and $i_C = C\\frac{dv_C}{dt}$, analyze how such a current step excites the $L_s$–$C_L$ resonance and derive the condition on $R_d$ required so that the capacitor voltage response is non-oscillatory. Then, for the following parameters, compute the minimum $R_d$ that ensures a non-oscillatory (critically damped) response:\n- CSI link inductance $L_s = 150\\,\\mu\\text{H}$,\n- Load stray capacitance $C_L = 2.0\\,\\text{nF}$,\n- Current step magnitude $\\Delta I = 40\\,\\text{A}$.\n\nRound your answer to three significant figures. Express the final result in ohms. The final answer must be a single real number. Angles are not involved in this problem.",
            "solution": "The problem describes a resonant loop formed during a commutation event in a Current Source Inverter. This loop is modeled as a series RLC circuit composed of the link inductance $L_s$, a damping resistor $R_d$, and the load's stray capacitance $C_L$. The condition for a non-oscillatory response is derived by analyzing the circuit's characteristic equation.\n\nApplying Kirchhoff's Voltage Law (KVL) to the series RLC loop yields:\n$$L_s \\frac{di}{dt} + R_d i(t) + v_C(t) = v_{source}(t)$$\nwhere $i(t)$ is the loop current and $v_C(t)$ is the capacitor voltage. To express this in terms of $v_C(t)$, the current is written as $i(t) = C_L \\frac{dv_C}{dt}$. Substituting this into the KVL equation gives the second-order linear differential equation:\n$$\\frac{d^2v_C}{dt^2} + \\frac{R_d}{L_s} \\frac{dv_C}{dt} + \\frac{1}{L_s C_L} v_C(t) = \\frac{v_{source}(t)}{L_s C_L}$$\nThe transient response is determined by the characteristic equation of the homogeneous system:\n$$s^2 + \\frac{R_d}{L_s} s + \\frac{1}{L_s C_L} = 0$$\nThis is a canonical second-order characteristic equation of the form $s^2 + 2\\zeta\\omega_n s + \\omega_n^2 = 0$. By comparison, the damping ratio $\\zeta$ is identified as:\n$$\\zeta = \\frac{R_d}{2} \\sqrt{\\frac{C_L}{L_s}}$$\nA non-oscillatory response requires the damping ratio to be greater than or equal to one ($\\zeta \\ge 1$), which establishes the condition on the damping resistor:\n$$R_d \\ge 2 \\sqrt{\\frac{L_s}{C_L}}$$\nThe minimum resistance for a non-oscillatory response corresponds to the critically damped case ($\\zeta = 1$):\n$$R_{d, \\text{min}} = 2 \\sqrt{\\frac{L_s}{C_L}}$$\nUsing the given parameter values:\n-   $L_s = 150\\,\\mu\\text{H} = 150 \\times 10^{-6}\\,\\text{H}$\n-   $C_L = 2.0\\,\\text{nF} = 2.0 \\times 10^{-9}\\,\\text{F}$\n\nThe ratio inside the square root is calculated:\n$$\\frac{L_s}{C_L} = \\frac{150 \\times 10^{-6}\\,\\text{H}}{2.0 \\times 10^{-9}\\,\\text{F}} = 75000\\,\\Omega^2$$\nThe minimum required damping resistance is then:\n$$R_{d, \\text{min}} = 2 \\times \\sqrt{75000\\,\\Omega^2} \\approx 2 \\times 273.861\\,\\Omega \\approx 547.722\\,\\Omega$$\nRounding to three significant figures, the result is $548\\,\\Omega$.",
            "answer": "$$\n\\boxed{548}\n$$"
        },
        {
            "introduction": "Effective control of a CSI involves more than just generating the correct output; it requires optimizing the switching sequence to minimize stress and losses. This computational challenge puts you in the role of a control systems designer, tasked with creating an algorithm that finds the most efficient switching pattern to follow a reference trajectory . This practice in dynamic programming bridges the gap between the physical constraints of the inverter hardware and the intelligence of its control software.",
            "id": "3831779",
            "problem": "A balanced three-phase Current Source Inverter (CSI) routes a constant direct current through a six-switch bridge to synthesize a three-phase load current. Owing to a large direct current inductance, the direct current is effectively constant over one electrical period, guaranteeing current continuity. At any instant, exactly two switches conduct to form a path for the direct current, and a commutation changes conduction in only one leg at a time. The six admissible conduction states can be abstracted as a hexagon of current space-vector directions with centers at angles $$\\phi_s = s \\cdot \\frac{\\pi}{3}, \\quad s \\in \\{0,1,2,3,4,5\\},$$ where each state $s$ corresponds to routing the direct current into one phase and out of another, producing a line current space-vector oriented at $\\phi_s$.\n\nYou are given a discrete reference current trajectory in angle form over one electrical period as a finite sequence $$\\Theta = [\\theta_0, \\theta_1, \\ldots, \\theta_{N-1}],$$ where each $\\theta_k$ is the desired current space-vector angle at sample index $k$. Angles are in radians. The device and topology constraints enforce:\n- Current continuity: at each sample, the CSI must be in one of the six conduction states $s \\in \\{0,1,2,3,4,5\\}$ so that a path for the direct current exists.\n- Single-leg commutation: transitions between conduction states proceed along the hexagon via adjacent states; any transition from state $s'$ to state $s$ requires a number of single-leg commutations equal to the shortest path length along the hexagon between $s'$ and $s$, that is $$d(s',s) = \\min\\left((s - s') \\bmod 6, (s' - s) \\bmod 6\\right).$$\n\nTracking performance is constrained by an angular tolerance $\\delta \\ge 0$: at sample $k$, the chosen conduction state $s_k$ must satisfy $$e(\\theta_k, \\phi_{s_k}) \\le \\delta,$$ where $$\\operatorname{wrap}(\\alpha) = \\left((\\alpha + \\pi) \\bmod 2\\pi\\right) - \\pi, \\quad e(\\theta, \\phi) = \\left| \\operatorname{wrap}(\\theta - \\phi) \\right|.$$ The objective is to compute a switching sequence $[s_0, s_1, \\ldots, s_{N-1}]$ that minimizes the total number of single-leg commutations over the period, $$C = \\sum_{k=1}^{N-1} d(s_{k-1}, s_k),$$ subject to the above constraints. If no sequence satisfies the angular tolerance at all samples, the instance is infeasible.\n\nYour task is to write a complete program that, for each provided test case, computes the minimal feasible commutation count $C$ over one period. If the instance is infeasible, output the integer $-1$ for that test case. Angles must be treated in radians. The final outputs must be integers. The final line of your program must contain a single line with the results for all test cases as a comma-separated list enclosed in square brackets (for example, $$[c_1,c_2,c_3]$$).\n\nUse the following test suite, which probes normal operation, boundary conditions, large jumps, exact matching requirements, and infeasibility. All angles are in radians.\n\n- Test case $1$ (general monotonic sweep):\n    - Number of samples: $N = 60$.\n    - Angular tolerance: $\\delta = \\frac{\\pi}{6} - 0.02$.\n    - Reference trajectory: $$\\theta_k = 2\\pi \\cdot \\frac{k}{N}, \\quad k \\in \\{0,1,\\ldots, N-1\\}.$$\n\n- Test case $2$ (boundary condition, constant angle with generous tolerance):\n    - Number of samples: $N = 10$.\n    - Angular tolerance: $\\delta = \\frac{\\pi}{4}$.\n    - Reference trajectory: $$\\theta_k = \\frac{\\pi}{3}, \\quad k \\in \\{0,1,\\ldots, N-1\\}.$$\n\n- Test case $3$ (edge case with large inter-sample jumps):\n    - Number of samples: $N = 6$.\n    - Angular tolerance: $\\delta = \\frac{\\pi}{12}$.\n    - Reference trajectory: $$\\Theta = \\left[0, \\pi, \\frac{\\pi}{3}, \\frac{4\\pi}{3}, \\frac{2\\pi}{3}, \\frac{5\\pi}{3}\\right].$$\n\n- Test case $4$ (exact matching only, zero tolerance):\n    - Number of samples: $N = 12$.\n    - Angular tolerance: $\\delta = 0$.\n    - Reference trajectory: $$\\Theta = \\left[0, 0, \\frac{\\pi}{3}, \\frac{\\pi}{3}, \\frac{2\\pi}{3}, \\frac{2\\pi}{3}, \\pi, \\pi, \\frac{4\\pi}{3}, \\frac{4\\pi}{3}, \\frac{5\\pi}{3}, \\frac{5\\pi}{3}\\right].$$\n\n- Test case $5$ (infeasible, zero tolerance not aligned to any state center):\n    - Number of samples: $N = 1$.\n    - Angular tolerance: $\\delta = 0$.\n    - Reference trajectory: $$\\Theta = \\left[\\frac{\\pi}{6}\\right].$$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[C_1, C_2, C_3, C_4, C_5]$, where each $C_i$ is the minimal commutation count for test case $i$ or $-1$ if infeasible.",
            "solution": "This is an optimization problem that seeks to find a sequence of inverter states $[s_0, s_1, \\ldots, s_{N-1}]$ that tracks a reference angular trajectory $\\Theta$ within a tolerance $\\delta$, while minimizing the total number of single-leg commutations. The problem can be solved optimally using dynamic programming by finding the shortest path through a state-space grid where states are defined by the sample index $k$ and the inverter conduction state $s$.\n\nLet $C(k, s)$ be the minimum cumulative commutation cost to be at sample $k$ in conduction state $s$. The goal is to find $\\min_{s} C(N-1, s)$.\n\n**1. Definitions**\n\nFirst, we formalize the given functions and constants.\n- The set of six possible state angles is $\\Phi = \\{\\phi_s \\mid s \\in \\{0,1,2,3,4,5\\}\\}$, where $\\phi_s = s \\cdot \\frac{\\pi}{3}$.\n- The function to wrap an angle to the range $[-\\pi, \\pi]$ is $\\operatorname{wrap}(\\alpha) = ((\\alpha + \\pi) \\bmod 2\\pi) - \\pi$.\n- The angular error between a reference angle $\\theta$ and a state angle $\\phi$ is $e(\\theta, \\phi) = |\\operatorname{wrap}(\\theta - \\phi)|$.\n- The commutation distance between two states $s'$ and $s$ is $d(s',s) = \\min((s - s') \\bmod 6, (s' - s) \\bmod 6)$. This represents the number of single-leg commutations required for the transition.\n\n**2. Dynamic Programming Formulation**\n\nWe construct a cost matrix, denoted `cost_dp`, of size $N \\times 6$. `cost_dp`$[k, s]$ will store the value $C(k, s)$. The matrix is initialized with infinity to represent unreachable states.\n\n**Step A: Initialization (Sample $k=0$)**\n\nFor the first sample $\\theta_0$, the cost is calculated for each possible initial state $s \\in \\{0, 1, \\ldots, 5\\}$. A state $s$ is a valid starting state if its corresponding angle $\\phi_s$ is within the tolerance $\\delta$ of the reference angle $\\theta_0$.\n- For each state $s \\in \\{0, 1, \\ldots, 5\\}$:\n  - If $e(\\theta_0, \\phi_s) \\le \\delta$, then the state is a valid starting point. The commutation cost at the initial step is $0$, so we set $C(0, s) = 0$.\n  - Otherwise, the state is invalid, and we set $C(0, s) = \\infty$.\n\nIf, after this step, all entries $C(0, s)$ for $s \\in \\{0, 1, \\ldots, 5\\}$ are $\\infty$, it means no valid initial state exists. The entire trajectory is therefore infeasible.\n\n**Step B: Iteration (Samples $k=1, \\ldots, N-1$)**\n\nWe proceed sequentially through the remaining samples. For each sample $k$ from $1$ to $N-1$, we compute the minimum cost to reach each possible state $s_{\\text{curr}} \\in \\{0, 1, \\ldots, 5\\}$.\n\n- For each sample $k \\in \\{1, \\ldots, N-1\\}$:\n  - For each current state $s_{\\text{curr}} \\in \\{0, 1, \\ldots, 5\\}$:\n    - First, we check if state $s_{\\text{curr}}$ is a valid choice for sample $k$. If $e(\\theta_k, \\phi_{s_{\\text{curr}}}) > \\delta$, this state is not allowed at this sample, so $C(k, s_{\\text{curr}})$ remains $\\infty$.\n    - If state $s_{\\text{curr}}$ is valid, we find the minimum cost to transition into it from any valid state at the previous sample, $k-1$. The cost is the sum of the minimum cost to reach a previous state $s_{\\text{prev}}$ at sample $k-1$, plus the commutation distance from $s_{\\text{prev}}$ to $s_{\\text{curr}}$.\n    $$C(k, s_{\\text{curr}}) = \\min_{s_{\\text{prev}} \\in \\{0,..,5\\}} \\left( C(k-1, s_{\\text{prev}}) + d(s_{\\text{prev}}, s_{\\text{curr}}) \\right)$$\n    This minimum is taken over all possible previous states $s_{\\text{prev}}$. If $C(k-1, s_{\\text{prev}})$ is $\\infty$, that path is not considered.\n\nIf, after iterating through all $s_{\\text{curr}}$ for a given sample $k$, every entry $C(k, s)$ is $\\infty$, it signifies that there is no feasible path to reach sample $k$. The trajectory is infeasible.\n\n**Step C: Final Result**\n\nAfter completing the iteration up to sample $k = N-1$, the last row of our cost matrix, $C(N-1, \\cdot)$, contains the minimum total commutation costs for feasible sequences ending in each state $s$. The overall minimum cost is the minimum value in this row.\n$$C_{\\text{min}} = \\min_{s \\in \\{0, \\ldots, 5\\}} C(N-1, s)$$\n\n- If $C_{\\text{min}}$ is $\\infty$, no feasible sequence exists for the entire trajectory. The result is $-1$.\n- Otherwise, $C_{\\text{min}}$ is the minimum total number of single-leg commutations. Since the commutation distances $d(s',s)$ are integers, the total cost $C_{\\text{min}}$ will also be an integer.\n\nThis dynamic programming approach guarantees finding the optimal solution because it exhaustively explores all feasible state sequences and, at each step, relies on the optimal costs computed for the previous step (invoking Bellman's principle of optimality).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute the minimal commutation counts.\n    \"\"\"\n\n    def wrap(alpha):\n        \"\"\"Wraps an angle to the interval [-pi, pi].\"\"\"\n        return ((alpha + np.pi) % (2 * np.pi)) - np.pi\n\n    def angular_error(theta, phi):\n        \"\"\"Calculates the absolute angular error e(theta, phi).\"\"\"\n        return np.abs(wrap(theta - phi))\n\n    def commutation_distance(s_prev, s_curr):\n        \"\"\"Calculates the commutation distance d(s_prev, s_curr).\"\"\"\n        return min((s_curr - s_prev) % 6, (s_prev - s_curr) % 6)\n\n    def compute_min_commutations(N, delta, theta_trajectory):\n        \"\"\"\n        Computes the minimal feasible commutation count using dynamic programming.\n        \n        Args:\n            N (int): Number of samples.\n            delta (float): Angular tolerance in radians.\n            theta_trajectory (np.ndarray): The reference angle trajectory.\n            \n        Returns:\n            int: The minimal commutation count, or -1 if infeasible.\n        \"\"\"\n        if N == 0:\n            return 0\n        \n        # State angles phi_s for s in {0, 1, ..., 5}\n        phi_s = np.array([s * np.pi / 3.0 for s in range(6)])\n        \n        # DP table: cost_dp[k][s] = min cost to be at sample k in state s\n        cost_dp = np.full((N, 6), np.inf)\n\n        # Initialization (k=0)\n        # For each state s, check if it's a valid starting state\n        for s in range(6):\n            if angular_error(theta_trajectory[0], phi_s[s]) <= delta:\n                cost_dp[0, s] = 0\n\n        # If no valid starting state exists, the instance is infeasible\n        if np.all(np.isinf(cost_dp[0])):\n            return -1\n\n        # Iteration (k=1 to N-1)\n        for k in range(1, N):\n            theta_k = theta_trajectory[k]\n            \n            # For each possible current state s_curr\n            for s_curr in range(6):\n                # Check if s_curr is a valid state for sample k\n                if angular_error(theta_k, phi_s[s_curr]) <= delta:\n                    min_prev_cost = np.inf\n                    # Find the minimum cost to transition to s_curr from any previous state\n                    for s_prev in range(6):\n                        # Only consider paths from reachable previous states\n                        if not np.isinf(cost_dp[k-1, s_prev]):\n                            path_cost = cost_dp[k-1, s_prev] + commutation_distance(s_prev, s_curr)\n                            if path_cost < min_prev_cost:\n                                min_prev_cost = path_cost\n                    cost_dp[k, s_curr] = min_prev_cost\n        \n        # Final result is the minimum cost in the last row of the DP table\n        min_total_cost = np.min(cost_dp[N-1])\n\n        # If min_total_cost is infinity, no feasible path exists\n        if np.isinf(min_total_cost):\n            return -1\n        else:\n            return int(round(min_total_cost))\n\n    # Define the test cases from the problem statement.\n    test_cases = []\n    \n    # Test case 1\n    N1 = 60\n    delta1 = np.pi/6 - 0.02\n    theta1 = np.array([2 * np.pi * k / N1 for k in range(N1)])\n    test_cases.append((N1, delta1, theta1))\n\n    # Test case 2\n    N2 = 10\n    delta2 = np.pi/4\n    theta2 = np.full(N2, np.pi/3)\n    test_cases.append((N2, delta2, theta2))\n\n    # Test case 3\n    N3 = 6\n    delta3 = np.pi/12\n    theta3 = np.array([0, np.pi, np.pi/3, 4*np.pi/3, 2*np.pi/3, 5*np.pi/3])\n    test_cases.append((N3, delta3, theta3))\n    \n    # Test case 4\n    N4 = 12\n    delta4 = 0.0\n    theta4 = np.array([\n        0, 0, np.pi/3, np.pi/3, 2*np.pi/3, 2*np.pi/3,\n        np.pi, np.pi, 4*np.pi/3, 4*np.pi/3, 5*np.pi/3, 5*np.pi/3\n    ])\n    test_cases.append((N4, delta4, theta4))\n\n    # Test case 5\n    N5 = 1\n    delta5 = 0.0\n    theta5 = np.array([np.pi/6])\n    test_cases.append((N5, delta5, theta5))\n    \n    results = []\n    for N, delta, theta_trajectory in test_cases:\n        result = compute_min_commutations(N, delta, theta_trajectory)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}