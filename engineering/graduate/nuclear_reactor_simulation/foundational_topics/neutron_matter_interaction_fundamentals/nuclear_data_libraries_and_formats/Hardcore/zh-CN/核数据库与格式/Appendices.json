{
    "hands_on_practices": [
        {
            "introduction": "核数据库本质上是海量的制表化数值，例如以 ENDF 或 ACE 格式存储。对于任何反应堆模拟专家而言，以编程方式访问这些数据是一项核心技能。本练习模拟了从一个简化的数据文件中读取数据的过程，旨在计算特定反应在任意能量点的截面值，这个任务要求你熟悉数据结构，并应用正确的插值规则来重构连续的截面函数。",
            "id": "4238995",
            "problem": "给定一个单一核素的紧凑型评价核数据库（A Compact Evaluated Nuclear Data File, ACE）的简化内存表示形式，该表示仅限于在公共能量栅格上计算微观反应截面所需的信息。目标是通过定位与弹性散射和辐射俘获相对应的材料类型（Material Type, MT）反应标识符，在目标能量处对每个反应的截面进行插值，并对相关贡献求和，以确定指定能量下的总微观截面。\n\n基本原理：微观反应截面 $\\sigma(E)$ 是中子能量为 $E$ 时某个相互作用通道单位路径长度上的相互作用概率，单位为靶（barns）。对于独立的通道，选定的一组反应的总微观截面由其各自微观截面之和给出。在分段平滑的列表化截面上，能量的线性插值是合理的；具体来说，对于在单调递增点 $\\{E_i\\}_{i=0}^{N-1}$ 上列表化的能量及其对应的值 $\\{\\sigma_i\\}_{i=0}^{N-1}$，区间 $[E_i, E_{i+1}]$ 内的插值由通过这两点的唯一线性函数得到。\n\n数据表示：每个数据集包含一个单一的能量栅格和一系列反应。每个反应由其 MT 号标识，并提供一个在相同能量栅格上列表化的截面数组。使用 MT $2$ 表示弹性散射，MT $102$ 表示辐射俘获。如果这些反应中的任何一个缺失，则将其贡献视为零。\n\n插值与外推规则：\n- 对于栅格内的 $E$，找到 $i$ 使得 $E_i \\le E \\le E_{i+1}$，并计算\n$$\nt = \\frac{E - E_i}{E_{i+1} - E_i}, \\quad \\sigma(E) = \\sigma_i + t\\left(\\sigma_{i+1} - \\sigma_i\\right).\n$$\n- 对于 $E < E_0$，使用第一个区间 $[E_0, E_1]$ 和相同的公式进行外推。\n- 对于 $E > E_{N-1}$，使用最后一个区间 $[E_{N-2}, E_{N-1}]$ 和相同的公式进行外推。\n- 在插值或外推后，通过设置 $\\sigma(E) \\leftarrow \\max(0, \\sigma(E))$ 来强制每个通道的物理非负性。\n- 总微观截面是在能量 $E$ 处的弹性和俘获截面之和。\n\n单位：\n- 能量必须以电子伏特（eV）处理和报告。\n- 截面必须以靶（b）处理和报告。\n- 程序的数值输出必须四舍五入到六位小数。\n\n实现一个程序，对于下面的每个测试用例，在反应列表中定位 MT $2$ 和 MT $102$ 的索引，按规定执行插值或外推，将弹性和俘获贡献相加，并以靶为单位输出总微观截面。如果某个反应缺失，其贡献为零。\n\n测试套件：\n- 数据集 $\\mathcal{A}$：\n  - 能量栅格 $\\mathbf{E}^{(\\mathcal{A})} = [\\,10^{-5},\\,10^{-3},\\,10^{-1},\\,1\\,]$ eV。\n  - 反应：\n    - MT $2$ （弹性）： $\\boldsymbol{\\sigma}_{2}^{(\\mathcal{A})} = [\\,20.0,\\,18.0,\\,12.0,\\,8.0\\,]$ b。\n    - MT $102$ （俘获）： $\\boldsymbol{\\sigma}_{102}^{(\\mathcal{A})} = [\\,100.0,\\,10.0,\\,1.0,\\,0.1\\,]$ b。\n  - 待评估能量：\n    - $E^{(\\mathcal{A},1)} = 10^{-3}$ eV （恰好在栅格上）。\n    - $E^{(\\mathcal{A},2)} = 5\\times 10^{-2}$ eV （在栅格点之间）。\n    - $E^{(\\mathcal{A},3)} = 10^{-6}$ eV （低于栅格，外推）。\n    - $E^{(\\mathcal{A},4)} = 2$ eV （高于栅格，外推）。\n- 数据集 $\\mathcal{B}$：\n  - 能量栅格 $\\mathbf{E}^{(\\mathcal{B})} = [\\,10^{-2},\\,10^{-1},\\,10\\,]$ eV。\n  - 反应：\n    - MT $2$ （弹性）： $\\boldsymbol{\\sigma}_{2}^{(\\mathcal{B})} = [\\,5.0,\\,5.5,\\,6.0\\,]$ b。\n    - MT $102$ （俘获）： 缺失。\n  - 待评估能量：\n    - $E^{(\\mathcal{B},1)} = 1$ eV （在栅格点之间）。\n- 数据集 $\\mathcal{C}$：\n  - 能量栅格 $\\mathbf{E}^{(\\mathcal{C})} = [\\,0.0253,\\,0.5,\\,1.0\\,]$ eV。\n  - 反应：\n    - MT $102$ （俘获）： $\\boldsymbol{\\sigma}_{102}^{(\\mathcal{C})} = [\\,600.0,\\,30.0,\\,15.0\\,]$ b。\n    - MT $2$ （弹性）： 缺失。\n  - 待评估能量：\n    - $E^{(\\mathcal{C},1)} = 0.5$ eV （恰好在栅格上）。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述测试用例的顺序列出：\n$[\\,\\sigma_{\\text{tot}}^{(\\mathcal{A},1)},\\,\\sigma_{\\text{tot}}^{(\\mathcal{A},2)},\\,\\sigma_{\\text{tot}}^{(\\mathcal{A},3)},\\,\\sigma_{\\text{tot}}^{(\\mathcal{A},4)},\\,\\sigma_{\\text{tot}}^{(\\mathcal{B},1)},\\,\\sigma_{\\text{tot}}^{(\\mathcal{C},1)}\\,]$.",
            "solution": "所提出的问题是有效的。它在科学上基于核反应堆物理学的原理，特别是关于评价核数据的使用。该问题是良构的，提供了一个自洽、无歧义的数据集和规则，用于计算微观截面。所有必需的参数、边界条件和计算步骤都已明确定义，从而允许一个唯一且可验证的解。\n\n目标是在指定的中子能量 $E$ 下，通过对弹性散射（材料类型 MT $2$）和辐射俘获（MT $102$）的贡献求和，计算总微观截面 $\\sigma_{\\text{tot}}(E)$。计算基于单个核素的列表化截面数据。指导原则是，对于独立的反应通道，总截面是分截面的线性叠加：\n$$\n\\sigma_{\\text{tot}}(E) = \\sigma_{\\text{elastic}}(E) + \\sigma_{\\text{capture}}(E)\n$$\n在此背景下，$\\sigma_{\\text{elastic}}(E)$ 对应于能量 $E$ 时 MT $2$ 的截面，而 $\\sigma_{\\text{capture}}(E)$ 对应于 MT $102$ 的截面。如果任一反应在数据集中未指定，则其对总和的贡献为零。\n\n任务的核心是从一组离散的能量点 $\\{E_i\\}_{i=0}^{N-1}$ 及其对应的截面值 $\\{\\sigma_i\\}_{i=0}^{N-1}$ 中确定分截面 $\\sigma(E)$ 的值。问题规定了插值和外推的具体程序。\n\n解决此问题的算法结构如下。首先，设计一个通用函数，用于计算单个反应在目标能量 $E$ 处的截面。该函数封装了插值、外推和非负性约束的逻辑。\n\n设能量栅格为 $\\mathbf{E} = [E_0, E_1, \\dots, E_{N-1}]$，对应的截面值为 $\\boldsymbol{\\sigma} = [\\sigma_0, \\sigma_1, \\dots, \\sigma_{N-1}]$。\n\n求 $\\sigma(E)$ 的步骤如下：\n1.  **确定包围区间：** 能量栅格是单调递增的。我们必须找到定义线性插值或外推区间的索引。\n    *   **外推（低于栅格）：** 如果 $E < E_0$，则计算使用第一个区间，即点 $(E_0, \\sigma_0)$ 和 $(E_1, \\sigma_1)$。用于计算的索引是 $i=0$ 和 $i+1=1$。\n    *   **外推（高于栅格）：** 如果 $E > E_{N-1}$，则计算使用最后一个区间，即点 $(E_{N-2}, \\sigma_{N-2})$ 和 $(E_{N-1}, \\sigma_{N-1})$。索引是 $i=N-2$ 和 $i+1=N-1$。\n    *   **插值（栅格上）：** 如果 $E_0 \\le E \\le E_{N-1}$，我们必须找到一个索引 $i$ 使得 $E_i \\le E \\le E_{i+1}$。这可以通过在能量栅格上使用二分查找算法高效实现。对于精确匹配的情况，即 $E = E_i$，截面就是 $\\sigma_i$。\n\n2.  **计算插值/外推值：** 一旦确定了包围点 $(E_i, \\sigma_i)$ 和 $(E_{i+1}, \\sigma_{i+1})$，就可以使用线性插值公式找到 $\\sigma(E)$ 的值：\n    $$\n    t = \\frac{E - E_i}{E_{i+1} - E_i}\n    $$\n    $$\n    \\sigma(E) = \\sigma_i + t(\\sigma_{i+1} - \\sigma_i)\n    $$\n    根据所选区间，这个单一公式能正确处理插值（此时 $0 \\le t \\le 1$）和外推（此时 $t < 0$ 或 $t > 1$）。\n\n3.  **强制物理约束：** 微观截面不能为负。因此，计算出的值需满足非负性条件：\n    $$\n    \\sigma(E) \\leftarrow \\max(0, \\sigma(E))\n    $$\n\n然后将这个鲁棒的单通道计算函数应用于每个测试用例。对于每个指定的评估能量，我们执行以下步骤：\n1.  初始化贡献值 $\\sigma_{\\text{elastic}}(E) = 0$ 和 $\\sigma_{\\text{capture}}(E) = 0$。\n2.  检查给定数据集中是否存在 MT $2$ 的数据。如果存在，则使用能量 $E$、数据集的能量栅格和 MT $2$ 的截面数组调用插值函数。结果赋给 $\\sigma_{\\text{elastic}}(E)$。\n3.  检查是否存在 MT $102$ 的数据。如果存在，则对 MT $102$ 执行相同的计算，并将结果赋给 $\\sigma_{\\text{capture}}(E)$。\n4.  计算总截面 $\\sigma_{\\text{tot}}(E) = \\sigma_{\\text{elastic}}(E) + \\sigma_{\\text{capture}}(E)$。\n5.  按要求将最终结果四舍五入到六位小数。\n\n系统地将此过程应用于所有指定的数据集和评估能量，以生成最终的结果列表。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating total microscopic cross sections based on\n    tabulated nuclear data for several test cases.\n    \"\"\"\n\n    datasets = {\n        'A': {\n            'E_grid': np.array([1e-5, 1e-3, 1e-1, 1.0]),\n            'reactions': {\n                2: np.array([20.0, 18.0, 12.0, 8.0]),\n                102: np.array([100.0, 10.0, 1.0, 0.1])\n            }\n        },\n        'B': {\n            'E_grid': np.array([1e-2, 1e-1, 10.0]),\n            'reactions': {\n                2: np.array([5.0, 5.5, 6.0])\n            }\n        },\n        'C': {\n            'E_grid': np.array([0.0253, 0.5, 1.0]),\n            'reactions': {\n                102: np.array([600.0, 30.0, 15.0])\n            }\n        }\n    }\n\n    test_cases = [\n        ('A', 1e-3),\n        ('A', 5e-2),\n        ('A', 1e-6),\n        ('A', 2.0),\n        ('B', 1.0),\n        ('C', 0.5)\n    ]\n\n    def interpolate_cross_section(E_target, E_grid, sigma_values):\n        \"\"\"\n        Calculates the cross section at a target energy using linear interpolation\n        or extrapolation as per the problem rules.\n\n        Args:\n            E_target (float): The energy at which to evaluate the cross section.\n            E_grid (np.ndarray): The array of energy grid points.\n            sigma_values (np.ndarray): The array of cross section values.\n\n        Returns:\n            float: The calculated cross section.\n        \"\"\"\n        n_points = len(E_grid)\n        E0, E_last = E_grid[0], E_grid[n_points - 1]\n\n        if E_target < E0:\n            # Extrapolate below grid using the first segment\n            i = 0\n        elif E_target > E_last:\n            # Extrapolate above grid using the last segment\n            i = n_points - 2\n        else:\n            # Interpolate within the grid\n            # searchsorted finds insertion point j to maintain order.\n            # If E_target is in [E_grid[j-1], E_grid[j]), interval is (j-1, j).\n            j = np.searchsorted(E_grid, E_target, side='left')\n            if j < n_points and E_grid[j] == E_target:\n                # Exact match on a grid point\n                return sigma_values[j]\n            # The interval is [E_grid[j-1], E_grid[j]]\n            i = j - 1\n\n        E_i, E_i_plus_1 = E_grid[i], E_grid[i+1]\n        sigma_i, sigma_i_plus_1 = sigma_values[i], sigma_values[i+1]\n        \n        # This can happen if the grid has only 2 points and we extrapolate\n        if E_i == E_i_plus_1:\n             return sigma_i\n\n        t = (E_target - E_i) / (E_i_plus_1 - E_i)\n        sigma_E = sigma_i + t * (sigma_i_plus_1 - sigma_i)\n\n        # Enforce non-negativity\n        return max(0.0, sigma_E)\n\n    results = []\n    for dataset_key, E_eval in test_cases:\n        dataset = datasets[dataset_key]\n        E_grid = dataset['E_grid']\n        reactions = dataset['reactions']\n\n        # Get contribution from MT 2 (elastic)\n        sigma_elastic_data = reactions.get(2)\n        if sigma_elastic_data is not None:\n            sigma_elastic = interpolate_cross_section(E_eval, E_grid, sigma_elastic_data)\n        else:\n            sigma_elastic = 0.0\n\n        # Get contribution from MT 102 (capture)\n        sigma_capture_data = reactions.get(102)\n        if sigma_capture_data is not None:\n            sigma_capture = interpolate_cross_section(E_eval, E_grid, sigma_capture_data)\n        else:\n            sigma_capture = 0.0\n        \n        sigma_total = sigma_elastic + sigma_capture\n        results.append(round(sigma_total, 6))\n\n    results_str = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了简单地检索数据，验证其物理和内部一致性也至关重要。一个基本守恒定律是，总截面 $\\sigma_{\\text{tot}}(E)$ 必须等于所有独立的分波道反应截面 $\\sigma_{j}(E)$ 之和。本练习要求你实现一个验证检查程序来量化和标记偏差，从而教会你诊断诸如不一致的插值方案等常见的数据处理问题，这是核数据处理流程中一个关键的质量保证步骤。",
            "id": "4239013",
            "problem": "给定一个简化的评价核数据库6版（ENDF-6）反应截面节的集合，代表单个靶核素，包括一个总截面节和几个分波反应截面节（弹性散射、辐射俘获、裂变和非弹性散射）。在核反应堆模拟中，当在相同的处理假设下定义一致时，总微观截面应等于其独立反应道截面之和。您的任务是以编程方式检测并量化列表给出的总截面与在统一能量栅格上内插的分波截面之和之间的差异，并对可能的差异来源进行分类，重点关注阈值未对齐和内插不匹配。\n\n基本原理和假设：\n- 某一过程的反应率由 $R = N \\, \\phi \\, \\sigma$ 给出，其中 $N$ 是原子核数密度，$\\phi$ 是中子通量，$\\sigma$ 是微观截面。对于固定的靶核和能量，单位路径长度上的总反应概率是所有独立反应道概率之和，这意味着当所有反应道 $j$ 被一致地定义和处理时，恒等式 $\\sigma_{\\text{tot}}(E) \\approx \\sum_{j} \\sigma_{j}(E)$ 成立。\n- ENDF-6 节以数对 $(E_i, \\sigma_i)$ 的形式列表给出数据，并指定了用于定义列表能量之间 $\\sigma(E)$ 的内插法则。在本问题中，我们仅限于使用广泛应用的 ENDF-6 内插法则代码：$1$ 代表线性-线性内插，$4$ 代表对数-对数内插。设 $(E_0, \\sigma_0)$ 和 $(E_1, \\sigma_1)$ 包含能量 $E$：\n    - 对于代码 $1$（线性-线性），内插截面为\n    $$\\sigma(E) = \\sigma_0 + \\left(\\sigma_1 - \\sigma_0\\right) \\frac{E - E_0}{E_1 - E_0}.$$\n    - 对于代码 $4$（对数-对数），假设 $E_0 > 0$, $E_1 > 0$, $\\sigma_0 > 0$ 且 $\\sigma_1 > 0$,\n    $$\\ln \\sigma(E) = \\ln \\sigma_0 + \\left(\\ln \\sigma_1 - \\ln \\sigma_0\\right) \\frac{\\ln E - \\ln E_0}{\\ln E_1 - \\ln E_0}, \\quad \\sigma(E) = \\exp\\left(\\ln \\sigma(E)\\right).$$\n- 当某个反应道的截面 $\\sigma_j(E) \\approx 0$ 在某一阈能以下，而总截面由于其他反应道的贡献而保持非零时，就存在阈值行为。当总截面节和分波截面节使用不同的内插法则，即使在节点上的列表值相加一致，它们之间的内插值也会不同，此时会发生内插不匹配。\n\n能量栅格的构建：\n- 令 $E_{\\text{union}}$ 为所有截面节中所有列表能量的排序并集。\n- 定义评估栅格 $G$ 为 $E_{\\text{union}}$ 与 $E_{\\text{union}}$ 中相邻元素之间的算术中点的并集，即，如果 $E_{\\text{union}} = \\{e_1 < e_2 < \\dots < e_n\\}$，则\n$$G = E_{\\text{union}} \\cup \\left\\{\\frac{e_i + e_{i+1}}{2} : i = 1, \\dots, n-1\\right\\}.$$\n\n偏差度量：\n- 对于每个 $E \\in G$，令 $\\sigma_{\\text{tot}}(E)$ 为内插的总截面，$\\sigma_{\\text{sum}}(E) = \\sum_{j} \\sigma_j(E)$ 为所有给定的分波反应节（不包括总截面节）上内插截面之和。\n- 定义在 $E$ 处的绝对相对偏差为\n$$d(E) = \\frac{\\left|\\sigma_{\\text{tot}}(E) - \\sigma_{\\text{sum}}(E)\\right|}{\\max\\left(\\epsilon, \\sigma_{\\text{tot}}(E)\\right)},$$\n其中 $\\epsilon = 10^{-12}$ 靶恩 (b) 是一个小的稳定化常数。能量单位必须是电子伏特 (eV)，截面单位必须是靶恩 (b)；偏差 $d(E)$ 是无量纲的，并且必须以小数形式（而非百分比）报告。\n- 每个测试用例的输出是一个数对，包含在 $G$ 上的最大绝对相对偏差和一个用于对可能来源进行分类的整数代码：\n    - $0$ 表示未检测到可能的问题。\n    - $1$ 表示可能为阈值未对齐（差异集中在某些分波截面近似为零而总截面非零的区域）。\n    - $2$ 表示可能为内插不匹配（差异出现在远离阈值的区域，并且各截面节的内插法则不同）。\n\n需实现的诊断分类规则：\n- 设 $\\tau = 10^{-8}$ b。计算 $E^{\\star} = \\arg\\max_{E \\in G} d(E)$。如果对于至少一个分波反应 $j$，我们有 $\\sigma_j(E^{\\star}) < \\tau$ 而 $\\sigma_{\\text{tot}}(E^{\\star}) \\ge 10 \\tau$，则分类为 $1$（阈值未对齐）。否则，如果各截面节之间的内插法则代码不同，并且在 $E^{\\star}$ 处所有截面值都 $\\ge \\tau$，则分类为 $2$（内插不匹配）。否则分类为 $0$。\n\n输入表示和约束：\n- 每个节由一个元组 $(\\text{MT}, \\text{INT}, \\text{NBT}, E, \\sigma)$ 指定，其中：\n    - $\\text{MT}$ 是 ENDF 反应标识符（$\\text{MT} = 1$ 代表总截面）。\n    - $\\text{INT}$ 是一个适用于各分段的 ENDF 内插法则代码列表。\n    - $\\text{NBT}$ 是一个基于 1 的索引列表，表示每个内插分段在列表中的结束位置（根据 ENDF-6 约定，是累积的）。在这些测试用例中，只使用单个分段，$\\text{NBT} = [N]$ 且只有一个法则代码。\n    - $E$ 是列表给出的能量（eV），严格递增且为正。\n    - $\\sigma$ 是列表给出的截面（靶恩），为非负数，当与对数内插法一起使用时为严格正数。\n- 您的程序必须只在每个节的列表能量的凸包内进行内插。如果 $E \\in G$ 超出了某个节的能量范围，则将该截面值限制在边界上最近的列表值。\n\n测试套件：\n- 情况 $1$（理想情况，一致的线性-线性内插）：所有节的 $\\text{INT} = [1]$，列表能量为 $E = [1.0\\times 10^{2}, 1.0\\times 10^{3}, 1.0\\times 10^{4}, 1.0\\times 10^{5}]$ eV。截面（单位：靶恩）：\n    - 总截面 ($\\text{MT}=1$): $\\sigma = [3.0, 3.0, 3.0, 3.0]$。\n    - 弹性散射 ($\\text{MT}=2$): $\\sigma = [2.0, 1.8, 1.5, 1.2]$。\n    - 俘获 ($\\text{MT}=102$): $\\sigma = [1.0, 0.8, 0.5, 0.3]$。\n    - 裂变 ($\\text{MT}=18$): $\\sigma = [0.0, 0.4, 1.0, 1.5]$。\n- 情况 $2$（阈值未对齐）：所有节的 $\\text{INT} = [1]$，列表能量为 $E = [5.0\\times 10^{4}, 1.0\\times 10^{5}, 5.0\\times 10^{5}]$ eV。截面（单位：靶恩）：\n    - 总截面 ($\\text{MT}=1$): $\\sigma = [2.0, 2.5, 3.0]$。\n    - 弹性散射 ($\\text{MT}=2$): $\\sigma = [1.0, 1.1, 1.2]$。\n    - 俘获 ($\\text{MT}=102$): $\\sigma = [0.8, 0.9, 1.0]$。\n    - 非弹性散射 ($\\text{MT}=51$): $\\sigma = [0.0, 0.5, 0.8]$。\n- 情况 $3$（内插不匹配）：总截面使用线性-线性，分波截面使用对数-对数；列表能量为 $E = [1.0\\times 10^{2}, 1.0\\times 10^{4}, 1.0\\times 10^{6}]$ eV。截面（单位：靶恩）：\n    - 总截面 ($\\text{MT}=1$, $\\text{INT}=[1]$): $\\sigma = [3.0, 3.0, 3.0]$。\n    - 弹性散射 ($\\text{MT}=2$, $\\text{INT}=[4]$): $\\sigma = [2.0, 2.5, 2.8]$。\n    - 俘获 ($\\text{MT}=102$, $\\text{INT}=[4]$): $\\sigma = [1.0, 0.5, 0.2]$。\n\n您的程序应生成单行输出，包含一个按测试用例排列的结果列表，其中每个用例的结果是一个双元素列表 $[\\text{dmax}, \\text{code}]$，$\\text{dmax}$ 是在 $G$ 上的最大绝对相对偏差，四舍五入到小数点后六位（无量纲小数），$\\text{code}$ 是如上定义的整数分类。最后一行必须是以下形式：\n$$[[\\text{dmax}_1,\\text{code}_1],[\\text{dmax}_2,\\text{code}_2],[\\text{dmax}_3,\\text{code}_3]]$$\n不应打印任何其他输出。在整个过程中，能量必须以 eV 处理，截面以靶恩处理。",
            "solution": "该问题要求通过验证反应概率守恒这一基本物理原理，来确认简化的核截面数据的有效性。该原理规定，总反应截面 $\\sigma_{\\text{tot}}(E)$ 必须等于其所有组成部分——分波反应截面之和 $\\sum_{j} \\sigma_{j}(E)$。差异通常源于数据处理过程中的人为影响，例如不一致的内插方案或未对齐的反应阈值。任务是实现一种算法来量化此类差异并对其可能的来源进行分类。该解决方案通过一系列严谨的计算步骤来执行。\n\n首先，必须建立一个用于比较的合适的能量栅格。由于不同的反应道（以及总截面）可能在不同的能量栅格上列表给出，我们必须构建一个统一的评估栅格，记为 $G$。这个栅格必须足够精细以捕捉列表数据点之间的变化。它由所有给定截面节中所有列表能量点的排序并集（我们称之为 $E_{\\text{union}}$）构成。为了探究列表节点之间的行为，我们还包括 $E_{\\text{union}}$ 中每对相邻节点之间的算术中点。因此，如果 $E_{\\text{union}} = \\{e_1, e_2, \\dots, e_n\\}$ 且 $e_1 < e_2 < \\dots < e_n$，则最终栅格为 $G = E_{\\text{union}} \\cup \\{ \\frac{e_i + e_{i+1}}{2} \\}_{i=1}^{n-1}$。\n\n其次，对于栅格 $G$ 中的每个能量点 $E$，我们必须计算每个反应道的截面值。这需要一个能够处理指定的标准 ENDF-6 法则的内插函数。对于给定的能量 $E$ 和一个包含数据点 $(E_i, \\sigma_i)$ 的反应节，我们首先定位包含能量的区间 $[E_0, E_1]$，使得 $E_0 \\le E \\le E_1$。如果 $E$ 超出了某个节的列表能量范围，截面值将被限制在最近边界点的值。在区间内，内插值 $\\sigma(E)$ 根据指定的法则计算。对于内插代码 $1$（线性-线性），公式为：\n$$ \\sigma(E) = \\sigma_0 + (\\sigma_1 - \\sigma_0) \\frac{E - E_0}{E_1 - E_0} $$\n对于内插代码 $4$（对数-对数），适用于正能量和正截面，内插在对数值上进行：\n$$ \\ln \\sigma(E) = \\ln \\sigma_0 + (\\ln \\sigma_1 - \\ln \\sigma_0) \\frac{\\ln E - \\ln E_0}{\\ln E_1 - \\ln E_0} $$\n最终截面则为 $\\sigma(E) = \\exp(\\ln \\sigma(E))$。\n\n第三，我们计算在每个能量点 $E \\in G$ 上的偏差。我们从反应标识符为 $\\text{MT}=1$ 的节中计算内插总截面 $\\sigma_{\\text{tot}}(E)$。同时，我们计算内插分波截面之和 $\\sigma_{\\text{sum}}(E) = \\sum_{j} \\sigma_{j}(E)$，其中 $j$ 遍历所有给定的分波反应道。然后使用以下公式量化绝对相对偏差 $d(E)$：\n$$ d(E) = \\frac{|\\sigma_{\\text{tot}}(E) - \\sigma_{\\text{sum}}(E)|}{\\max(\\epsilon, \\sigma_{\\text{tot}}(E))} $$\n此处，$\\epsilon = 10^{-12}$ 靶恩是一个小的常数，用于防止当 $\\sigma_{\\text{tot}}(E)$ 非常小或为零时出现除以零的情况。\n\n第四，我们分析计算出的偏差，以确定最大值及其可能的原因。我们找到最大偏差 $d_{\\max} = \\max_{E \\in G} d(E)$，以及它出现的能量 $E^{\\star} = \\arg\\max_{E \\in G} d(E)$。为了分类其来源，我们在 $E^{\\star}$ 处应用指定的诊断规则，使用阈值 $\\tau = 10^{-8}$ 靶恩：\n1.  **阈值未对齐（代码 1）**：如果偏差在某个分波反应可忽略不计但总反应率不可忽略的区域最大，则怀疑是此原因。如果存在至少一个分波反应 $j$ 满足 $\\sigma_j(E^{\\star}) < \\tau$，而总截面满足 $\\sigma_{\\text{tot}}(E^{\\star}) \\ge 10\\tau$，则该条件成立。\n2.  **内插不匹配（代码 2）**：如果使用了不同的内插法则，并且偏差在一个所有反应都处于活动状态的区域内显著，则这很可能是原因。如果在阈值条件不满足的情况下，所有截面节使用的内插法则代码集合中包含多个不同的代码，并且在 $E^{\\star}$ 处的所有截面值（总截面和所有分波截面）都大于或等于 $\\tau$，则分类为此项。\n3.  **无明显问题（代码 0）**：如果以上条件均不满足，则认为偏差在可接受范围内或属于未分类的性质，并被赋予代码 $0$。\n\n这个系统化的程序能够对评价核数据文件中的常见不一致性进行稳健的检测和分类，这是为核反应堆模拟准备数据时一个关键的质量保证步骤。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates and analyzes simplified ENDF-6 cross section data.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Happy path, coherent lin-lin\n        [\n            {'MT': 1, 'INT': [1], 'NBT': [4], 'E': [1.0e2, 1.0e3, 1.0e4, 1.0e5], 'sigma': [3.0, 3.0, 3.0, 3.0]},\n            {'MT': 2, 'INT': [1], 'NBT': [4], 'E': [1.0e2, 1.0e3, 1.0e4, 1.0e5], 'sigma': [2.0, 1.8, 1.5, 1.2]},\n            {'MT': 102, 'INT': [1], 'NBT': [4], 'E': [1.0e2, 1.0e3, 1.0e4, 1.0e5], 'sigma': [1.0, 0.8, 0.5, 0.3]},\n            {'MT': 18, 'INT': [1], 'NBT': [4], 'E': [1.0e2, 1.0e3, 1.0e4, 1.0e5], 'sigma': [0.0, 0.4, 1.0, 1.5]}\n        ],\n        # Case 2: Threshold misalignment\n        [\n            {'MT': 1, 'INT': [1], 'NBT': [3], 'E': [5.0e4, 1.0e5, 5.0e5], 'sigma': [2.0, 2.5, 3.0]},\n            {'MT': 2, 'INT': [1], 'NBT': [3], 'E': [5.0e4, 1.0e5, 5.0e5], 'sigma': [1.0, 1.1, 1.2]},\n            {'MT': 102, 'INT': [1], 'NBT': [3], 'E': [5.0e4, 1.0e5, 5.0e5], 'sigma': [0.8, 0.9, 1.0]},\n            {'MT': 51, 'INT': [1], 'NBT': [3], 'E': [5.0e4, 1.0e5, 5.0e5], 'sigma': [0.0, 0.5, 0.8]}\n        ],\n        # Case 3: Interpolation mismatch\n        [\n            {'MT': 1, 'INT': [1], 'NBT': [3], 'E': [1.0e2, 1.0e4, 1.0e6], 'sigma': [3.0, 3.0, 3.0]},\n            {'MT': 2, 'INT': [4], 'NBT': [3], 'E': [1.0e2, 1.0e4, 1.0e6], 'sigma': [2.0, 2.5, 2.8]},\n            {'MT': 102, 'INT': [4], 'NBT': [3], 'E': [1.0e2, 1.0e4, 1.0e6], 'sigma': [1.0, 0.5, 0.2]}\n        ]\n    ]\n\n    def interpolate_section(E_eval, section):\n        E_tab = section['E']\n        sigma_tab = section['sigma']\n        int_code = section['INT'][0]\n\n        if E_eval <= E_tab[0]:\n            return sigma_tab[0]\n        if E_eval >= E_tab[-1]:\n            return sigma_tab[-1]\n\n        # Find energy interval using binary search\n        idx = np.searchsorted(E_tab, E_eval, side='right')\n        E0, E1 = E_tab[idx-1], E_tab[idx]\n        s0, s1 = sigma_tab[idx-1], sigma_tab[idx]\n        \n        if int_code == 1: # Linear-linear\n            return s0 + (s1 - s0) * (E_eval - E0) / (E1 - E0)\n        elif int_code == 4: # Logarithmic-logarithmic\n            # Problem constraints ensure s0 > 0 and s1 > 0\n            log_E_eval, log_E0, log_E1 = np.log(E_eval), np.log(E0), np.log(E1)\n            log_s0, log_s1 = np.log(s0), np.log(s1)\n            log_s = log_s0 + (log_s1 - log_s0) * (log_E_eval - log_E0) / (log_E1 - log_E0)\n            return np.exp(log_s)\n        return 0.0\n\n    results = []\n    for case_sections in test_cases:\n        total_section = None\n        partial_sections = []\n        for sec in case_sections:\n            if sec['MT'] == 1:\n                total_section = sec\n            else:\n                partial_sections.append(sec)\n\n        # Construct energy grid G\n        all_energies = set()\n        for sec in case_sections:\n            all_energies.update(sec['E'])\n        E_union = sorted(list(all_energies))\n        \n        midpoints = []\n        if len(E_union) > 1:\n            midpoints = [(E_union[i] + E_union[i+1]) / 2.0 for i in range(len(E_union) - 1)]\n\n        grid_G = sorted(list(set(E_union + midpoints)))\n\n        discrepancies = []\n        epsilon = 1e-12\n        for E_g in grid_G:\n            sigma_tot_interp = interpolate_section(E_g, total_section)\n            sigma_sum_interp = sum(interpolate_section(E_g, p_sec) for p_sec in partial_sections)\n            \n            discrepancy = abs(sigma_tot_interp - sigma_sum_interp) / max(epsilon, sigma_tot_interp)\n            discrepancies.append((discrepancy, E_g))\n\n        # Find max discrepancy and its energy\n        d_max, E_star = max(discrepancies, key=lambda item: item[0]) if discrepancies else (0.0, 0.0)\n\n        # Classify the discrepancy\n        tau = 1e-8\n        code = 0\n        \n        sigma_tot_at_E_star = interpolate_section(E_star, total_section)\n        partials_at_E_star = [interpolate_section(E_star, p_sec) for p_sec in partial_sections]\n\n        # Check for threshold misalignment\n        is_threshold_issue = False\n        if sigma_tot_at_E_star >= 10 * tau:\n            if any(s_j < tau for s_j in partials_at_E_star):\n                is_threshold_issue = True\n        \n        if is_threshold_issue:\n            code = 1\n        else:\n            # Check for interpolation mismatch\n            all_int_codes = {sec['INT'][0] for sec in case_sections}\n            all_xs_ge_tau = (sigma_tot_at_E_star >= tau) and all(s_j >= tau for s_j in partials_at_E_star)\n            if len(all_int_codes) > 1 and all_xs_ge_tau:\n                code = 2\n\n        results.append([round(d_max, 6), code])\n\n    # Format the final output string exactly as required\n    formatted_results = ','.join(str(res).replace(\" \", \"\") for res in results)\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了适用于大规模模拟，核数据文件必须在准确性与存储效率之间取得平衡。这个高级练习将带你深入了解数据处理中的“稀化”（thinning）技术，即将一个密集的原始数据集精简为一个最小的点集，同时确保在给定的误差容限内保留其物理特性。你将设计一个贪婪算法，它反映了像 NJOY 这样的主流数据处理程序中用于生成高效、优化数据库的复杂方法。",
            "id": "4239107",
            "problem": "给定点状中子反应截面数据，其形式为能量和截面值对的数组，这些数据将以与评价核数据库（ENDF）兼容的文件格式存储。在连续能量核反应堆模拟中，使用指定的插值法则在列表能量点之间重建列表化的点状截面。为了在保持保真度的同时减少存储空间，您必须构建一个简化的能量网格。当与物理上合适的插值方法一起使用时，该网格能保证相对于原始点状数据的最大相对误差不超过指定的容差。您的任务是从第一性原理出发，设计并实现一种算法，该算法选择原始数据点的最小子集，使得在所选点之间的分段插值能够保持目标最大相对误差。\n\n使用的基本原理：\n- 中子输运方程将反应率与截面耦合，而点状列表表示在能量点 $E_i$ 上采样的函数 $\\sigma(E)$。在 ENDF 风格的列表中，诸如线性-线性（lin-lin）和对数-线性（log-lin）等插值法被广泛使用，并可被视为列表点之间的确定性重建规则。\n- 重建截面 $\\hat{\\sigma}(E)$ 与原始截面 $\\sigma(E)$ 之间的相对误差定义为 $|\\hat{\\sigma}(E) - \\sigma(E)| / \\max(\\sigma(E), \\sigma_{\\mathrm{floor}})$，其中 $\\sigma_{\\mathrm{floor}}$ 是一个正的底值，用于避免除以零，并反映出在小的数值噪声范围内，零截面在物理上是无法区分的。\n- 存储每个能量和截面为双精度浮点值的点状表的存储成本为每点 $16$ 字节（能量 $8$ 字节，截面 $8$ 字节），忽略了文件头和元数据的开销。\n\n基于这些原理，推导出一个原则性算法：从能量网格的端点开始，迭代地添加使所选插值法下的局部相对误差最大化的内部点，直到所有原始列表点的最大相对误差都受给定容差的限制。用于重建的插值法是以下具有物理合理性的规则：\n- 如果两个端点的截面都超过底值 $\\sigma_{\\mathrm{floor}}$，则在两个轴上执行对数插值：即在 $\\ln(E)$ 对 $\\ln(\\sigma)$ 上进行线性插值，具体为\n$$\n\\hat{\\sigma}(E) = \\exp\\left( \\ln(\\sigma_1) + \\left( \\ln(\\sigma_2) - \\ln(\\sigma_1) \\right) \\frac{\\ln(E) - \\ln(E_1)}{\\ln(E_2) - \\ln(E_1)} \\right),\n$$\n对于端点 $(E_1, \\sigma_1)$ 和 $(E_2, \\sigma_2)$ 以及任何满足 $E_1 \\le E \\le E_2$ 的 $E$。\n- 否则，在物理轴上执行线性插值：\n$$\n\\hat{\\sigma}(E) = \\sigma_1 + (\\sigma_2 - \\sigma_1) \\frac{E - E_1}{E_2 - E_1}.\n$$\n此规则捕捉了对随能量呈乘法变化的截面使用对数插值的常见做法，并避免了对非正值取对数。\n\n将在任何原始列表能量 $E_i$ 处的相对误差定义为\n$$\n\\varepsilon_i = \\frac{|\\hat{\\sigma}(E_i) - \\sigma(E_i)|}{\\max(\\sigma(E_i), \\sigma_{\\mathrm{floor}})}.\n$$\n\n当所有 $i$ 的最大 $\\varepsilon_i$ 小于或等于容差 $\\tau$ 时，算法必须终止。\n\n对于每个测试用例，您必须：\n1. 构建简化的网格索引并计算简化后的网格大小 $M$。\n2. 计算原始文件大小 $S_{\\mathrm{orig}} = 16 N$ 字节和简化后的文件大小 $S_{\\mathrm{red}} = 16 M$ 字节。\n3. 计算压缩率 $r = (N - M) / N$（以小数表示）。\n4. 使用最终的简化网格和指定的插值法，计算实际达到的最大相对误差 $\\varepsilon_{\\max} = \\max_i \\varepsilon_i$。\n\n提供一个单独的程序来评估以下测试套件。能量和截面数据是人工合成的，但在科学上是合理的。除非另有说明，截面单位为靶（barns），能量单位为电子伏特（eV）。文件大小必须以字节表示。压缩率必须以小数表示。不涉及角度。\n\n测试套件：\n- 案例 A（类共振的一般行为，理想情况）：$N = 401$ 个能量点 $E_i$，在 $10^{-5}$ 到 $10$ eV 之间对数均匀分布。截面\n$$\n\\sigma(E) = 0.1 + \\frac{2}{\\sqrt{E}} + 12 \\exp\\left(-\\frac{(\\ln E - \\ln 0.3)^2}{2 \\cdot 0.15^2}\\right).\n$$\n容差 $\\tau = 0.02$。底值 $\\sigma_{\\mathrm{floor}} = 10^{-8}$ 靶。\n\n- 案例 B（带零的阈值行为，边界情况）：$N = 501$ 个能量点 $E_i$，在 $10^{-6}$ 到 $3.0$ 兆电子伏特（MeV）之间线性均匀分布。设阈值为 $E_{\\mathrm{th}} = 1.0$ MeV。截面\n$$\n\\sigma(E) =\n\\begin{cases}\n0,  E < E_{\\mathrm{th}},\\\\\n3 \\sqrt{E - E_{\\mathrm{th}}} \\exp\\left(-\\frac{E - E_{\\mathrm{th}}}{1.0}\\right),  E \\ge E_{\\mathrm{th}}.\n\\end{cases}\n$$\n使用指定的底值规则解释插值和对数。容差 $\\tau = 0.05$。底值 $\\sigma_{\\mathrm{floor}} = 10^{-8}$ 靶。\n\n- 案例 C（严格容差，平滑的类 $1/v$ 行为）：$N = 1001$ 个能量点 $E_i$，在 $10^{-2}$ 到 $10$ eV 之间对数均匀分布。截面\n$$\n\\sigma(E) = \\frac{5}{E}.\n$$\n容差 $\\tau = 10^{-4}$。底值 $\\sigma_{\\mathrm{floor}} = 10^{-12}$ 靶。\n\n- 案例 D（宽松容差，形状与 A 相同）：与案例 A 相同，但容差 $\\tau = 0.2$，底值 $\\sigma_{\\mathrm{floor}} = 10^{-8}$ 靶。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个案例对应一个形式为 $[M, S_{\\mathrm{orig}}, S_{\\mathrm{red}}, r, \\varepsilon_{\\max}]$ 的列表。例如，输出格式必须如下所示\n\"[ [M_A,Sorig_A,Sred_A,r_A,err_A], [M_B,Sorig_B,Sred_B,r_B,err_B], [M_C,Sorig_C,Sred_C,r_C,err_C], [M_D,Sorig_D,Sred_D,r_D,err_D] ]\"\n除了 Python 打印数字列表时产生的空格外，程序不强制要求其他空格。所有文件大小必须以字节为单位，所有压缩率必须是小数，所有误差也必须是小数。",
            "solution": "该问题要求设计并实现一种贪婪算法，以减少点状核截面数据集 $\\sigma(E)$ 中的数据点数量，同时确保重建的截面 $\\hat{\\sigma}(E)$ 与原始数据的偏差不超过指定的最大相对误差容差 $\\tau$。这项任务在核反应堆模拟中至关重要，因为从评价核数据库（ENDF）等库中高效存储和检索核数据是关键。\n\n该算法的方法论基础是对初始粗糙能量网格进行贪婪的迭代式加密。这种方法的合理性在于其直接性和有效性，能将网格点放置在最需要的地方——即函数 $\\sigma(E)$ 最难用简单插值方法近似的区域。\n\n算法流程如下：\n1. **初始化**：简化的能量网格仅使用原始密集能量网格的第一个和最后一个点进行初始化。设原始网格有 $N$ 个点，索引为 $i = 0, 1, \\dots, N-1$。简化网格的初始索引集为 $\\{0, N-1\\}$。\n\n2. **插值方案**：采用一种具有物理动机的混合插值方案，在简化网格的任意两个相邻点 $(E_1, \\sigma_1)$ 和 $(E_2, \\sigma_2)$ 之间重建截面 $\\hat{\\sigma}(E)$。\n- 如果两个端点的截面均为正且超过数值底值 $\\sigma_{\\mathrm{floor}}$（即 $\\sigma_1 > \\sigma_{\\mathrm{floor}}$ 且 $\\sigma_2 > \\sigma_{\\mathrm{floor}}$），则采用对数-对数插值（log-log）。这对应于在对数空间中的线性插值，定义如下：\n$$\n\\hat{\\sigma}(E) = \\exp\\left( \\ln(\\sigma_1) + \\left( \\ln(\\sigma_2) - \\ln(\\sigma_1) \\right) \\frac{\\ln(E) - \\ln(E_1)}{\\ln(E_2) - \\ln(E_1)} \\right)\n$$\n该方案特别适用于表现出 $1/v$ 行为（其中 $\\sigma(E) \\propto E^{-1/2}$）或其他幂律依赖性的截面，以及共振峰的两翼，因为这些行为在对数-对数空间中是线性的。\n- 否则（如果 $\\sigma_1 \\le \\sigma_{\\mathrm{floor}}$ 或 $\\sigma_2 \\le \\sigma_{\\mathrm{floor}}$），则使用标准线性插值：\n$$\n\\hat{\\sigma}(E) = \\sigma_1 + (\\sigma_2 - \\sigma_1) \\frac{E - E_1}{E_2 - E_1}\n$$\n这是一种稳健的备用方案，尤其适用于阈值反应（其截面在某一能量以下为零），可以防止对零或非正值取对数时出现问题。\n\n3. **误差控制的迭代**：算法的核心是一个迭代循环，持续进行直到各处的重建精度都满足要求。\n    a. **误差计算**：在每次迭代中，当前的简化网格定义了一组区间。对于严格位于这些区间端点之间的每个原始数据点 $(E_i, \\sigma_i)$，计算其插值截面 $\\hat{\\sigma}(E_i)$。然后按如下方式计算相对误差 $\\varepsilon_i$：\n    $$\n    \\varepsilon_i = \\frac{|\\hat{\\sigma}(E_i) - \\sigma_i|}{\\max(\\sigma_i, \\sigma_{\\mathrm{floor}})}\n    $$\n    分母 $\\max(\\sigma_i, \\sigma_{\\mathrm{floor}})$ 通过防止除以零并正确处理截面值极小的区域，确保了数值稳定性和物理合理性。\n    b. **贪婪选择**：算法识别出具有全局最大相对误差 $\\varepsilon_{\\max} = \\max_i \\varepsilon_i$ 的原始数据点及其索引 $i_{\\mathrm{worst}}$。\n    c. **终止检查**：如果该最大误差 $\\varepsilon_{\\max}$ 小于或等于预设容差 $\\tau$，则认为当前的简化网格足够精确。迭代过程终止。\n    d. **网格加密**：如果 $\\varepsilon_{\\max} > \\tau$，则将导致此最大误差的点 $(E_{i_{\\mathrm{worst}}}, \\sigma_{i_{\\mathrm{worst}}})$ 添加到简化网格中。这会分割包含最大误差的区间，从而在下一次迭代中改善局部近似。然后循环重复。\n\n4. **最终输出指标**：终止时，算法生成了一个包含 $M$ 个网格点的最终集合。由此计算所需的指标：\n- 简化网格大小 $M$。\n- 原始文件大小 $S_{\\mathrm{orig}} = 16N$ 字节，其中每个点（能量、截面）是一个双精度浮点数（各占 $8$ 字节）。\n- 简化文件大小 $S_{\\mathrm{red}} = 16M$ 字节。\n- 压缩率 $r = (N - M) / N$。\n- 在最终网格上达到的最大相对误差 $\\varepsilon_{\\max}$。\n\n这种基于原则的贪婪方法构建了原始数据的一种经济、误差有界的表示，直接解决了核数据应用中存储保真度与成本之间的权衡问题。实现将为每个测试用例忠实地执行此逻辑，生成初始网格和截面剖面，应用迭代稀疏过程，并计算最终指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final results.\n    \"\"\"\n\n    def generate_case_data(case_id):\n        \"\"\"\n        Generates the full energy grid and cross section data for a given test case.\n        \"\"\"\n        if case_id == 'A' or case_id == 'D':\n            N = 401\n            E = np.logspace(np.log10(1e-5), np.log10(10), N)\n            sigma = 0.1 + 2 / np.sqrt(E) + 12 * np.exp(-(np.log(E) - np.log(0.3))**2 / (2 * 0.15**2))\n            tau = 0.02 if case_id == 'A' else 0.2\n            sigma_floor = 1e-8\n            return E, sigma, tau, sigma_floor\n        elif case_id == 'B':\n            N = 501\n            E = np.linspace(1e-6, 3.0, N)  # Energies in MeV\n            E_th = 1.0  # Threshold in MeV\n            sigma = np.zeros_like(E)\n            mask = E >= E_th\n            # To avoid sqrt of negative number due to float precision\n            E_shifted = E[mask] - E_th\n            E_shifted[E_shifted < 0] = 0\n            sigma[mask] = 3 * np.sqrt(E_shifted) * np.exp(-E_shifted / 1.0)\n            tau = 0.05\n            sigma_floor = 1e-8\n            return E, sigma, tau, sigma_floor\n        elif case_id == 'C':\n            N = 1001\n            E = np.logspace(np.log10(1e-2), np.log10(10), N)\n            sigma = 5 / E\n            tau = 1e-4\n            sigma_floor = 1e-12\n            return E, sigma, tau, sigma_floor\n        else:\n            raise ValueError(\"Unknown case ID\")\n\n    def run_thinning_algorithm(E_full, sigma_full, tau, sigma_floor):\n        \"\"\"\n        Implements the greedy grid thinning algorithm.\n        \"\"\"\n        N = len(E_full)\n        if N <= 2:\n            return [N, 16 * N, 16 * N, 0.0, 0.0]\n\n        reduced_indices = {0, N - 1}\n        \n        final_max_err = 0.0\n\n        while True:\n            max_err = 0.0\n            worst_point_index = -1\n            \n            sorted_indices = sorted(list(reduced_indices))\n\n            for i in range(len(sorted_indices) - 1):\n                idx1 = sorted_indices[i]\n                idx2 = sorted_indices[i+1]\n\n                if idx2 - idx1 <= 1:\n                    continue\n\n                E1, s1 = E_full[idx1], sigma_full[idx1]\n                E2, s2 = E_full[idx2], sigma_full[idx2]\n\n                energies_to_check = E_full[idx1 + 1 : idx2]\n                true_sigmas = sigma_full[idx1 + 1 : idx2]\n                \n                # Vectorized interpolation\n                if s1 > sigma_floor and s2 > sigma_floor:\n                    # Log-log interpolation\n                    if np.isclose(E1,E2):\n                        interp_sigmas = np.full_like(energies_to_check, s1)\n                    else:\n                        log_s1, log_s2 = np.log(s1), np.log(s2)\n                        log_E1, log_E2 = np.log(E1), np.log(E2)\n                        if np.isclose(log_E1, log_E2):\n                            interp_sigmas = np.full_like(energies_to_check, s1)\n                        else:\n                            term = (np.log(energies_to_check) - log_E1) / (log_E2 - log_E1)\n                            log_interp_sigmas = log_s1 + (log_s2 - log_s1) * term\n                            interp_sigmas = np.exp(log_interp_sigmas)\n                else:\n                    # Linear-linear interpolation\n                    if np.isclose(E1,E2):\n                        interp_sigmas = np.full_like(energies_to_check, s1)\n                    else:\n                        term = (energies_to_check - E1) / (E2 - E1)\n                        interp_sigmas = s1 + (s2 - s1) * term\n                \n                denominators = np.maximum(true_sigmas, sigma_floor)\n                errors = np.abs(interp_sigmas - true_sigmas) / denominators\n                \n                interval_max_err_idx = np.argmax(errors)\n                interval_max_err = errors[interval_max_err_idx]\n                \n                if interval_max_err > max_err:\n                    max_err = interval_max_err\n                    worst_point_index = idx1 + 1 + interval_max_err_idx\n\n            if max_err <= tau:\n                final_max_err = max_err\n                break\n            \n            if worst_point_index != -1:\n                reduced_indices.add(worst_point_index)\n            else:\n                # Should not happen unless all errors are 0\n                final_max_err = max_err\n                break\n\n        M = len(reduced_indices)\n        S_orig = 16 * N\n        S_red = 16 * M\n        r = (N - M) / N if N > 0 else 0.0\n        \n        # To be fully compliant, re-calculate final error on the final grid\n        # This confirms the value from the last loop iteration is correct\n        achieved_max_error = 0.0\n        sorted_final_indices = sorted(list(reduced_indices))\n        for i in range(len(sorted_final_indices) - 1):\n            idx1 = sorted_final_indices[i]\n            idx2 = sorted_final_indices[i+1]\n            if idx2 - idx1 <= 1:\n                continue\n\n            E1, s1 = E_full[idx1], sigma_full[idx1]\n            E2, s2 = E_full[idx2], sigma_full[idx2]\n\n            energies_to_check = E_full[idx1 + 1 : idx2]\n            true_sigmas = sigma_full[idx1 + 1 : idx2]\n            \n            if s1 > sigma_floor and s2 > sigma_floor:\n                if not np.isclose(E1,E2):\n                    log_s1, log_s2 = np.log(s1), np.log(s2)\n                    log_E1, log_E2 = np.log(E1), np.log(E2)\n                    if not np.isclose(log_E1, log_E2):\n                        term = (np.log(energies_to_check) - log_E1) / (log_E2 - log_E1)\n                        interp_sigmas = np.exp(log_s1 + (log_s2 - log_s1) * term)\n                    else:\n                        interp_sigmas = np.full_like(energies_to_check, s1)\n                else:\n                    interp_sigmas = np.full_like(energies_to_check, s1)\n            else:\n                if not np.isclose(E1,E2):\n                    term = (energies_to_check - E1) / (E2 - E1)\n                    interp_sigmas = s1 + (s2 - s1) * term\n                else:\n                    interp_sigmas = np.full_like(energies_to_check, s1)\n            \n            denominators = np.maximum(true_sigmas, sigma_floor)\n            errors = np.abs(interp_sigmas - true_sigmas) / denominators\n            \n            interval_max_err = np.max(errors) if errors.size > 0 else 0.0\n            if interval_max_err > achieved_max_error:\n                achieved_max_error = interval_max_err\n\n        return [M, S_orig, S_red, r, achieved_max_error]\n\n    test_case_ids = ['A', 'B', 'C', 'D']\n    results = []\n    for case_id in test_case_ids:\n        E, sigma, tau, sigma_floor = generate_case_data(case_id)\n        result = run_thinning_algorithm(E, sigma, tau, sigma_floor)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}