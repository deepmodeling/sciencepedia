{
    "hands_on_practices": [
        {
            "introduction": "This first practice serves as a foundational exercise to build proficiency with the analytical tools of transport theory. You will derive the Legendre moments for the Henyey-Greenstein scattering phase function, a cornerstone model for representing anisotropic scattering in various media. This exercise demonstrates the power of using the generating function of Legendre polynomials to connect a physical model to its mathematical expansion, yielding a remarkably elegant result .",
            "id": "4233065",
            "problem": "In nuclear reactor simulation, anisotropic scattering of neutrons is commonly represented by a phase function depending on the cosine of the scattering angle, denoted by $\\mu = \\cos\\theta$. In one spatial dimension after azimuthal averaging, the normalized scattering phase function $p(\\mu)$ satisfies $\\int_{-1}^{1} p(\\mu)\\,\\mathrm{d}\\mu = 2$. The standard Legendre polynomial expansion used in one-dimensional transport codes is\n$$\np(\\mu) = \\sum_{l=0}^{\\infty} (2l+1)\\,a_{l}\\,P_{l}(\\mu),\n$$\nwhere $P_{l}(\\mu)$ are the Legendre polynomials and $a_{l}$ are the Legendre moments defined by\n$$\na_{l} = \\frac{1}{2}\\int_{-1}^{1} p(\\mu)\\,P_{l}(\\mu)\\,\\mathrm{d}\\mu.\n$$\nConsider the Henyey–Greenstein phase function,\n$$\np(\\mu) = \\frac{1-g^{2}}{\\left(1+g^{2}-2g\\mu\\right)^{3/2}},\n$$\nwith anisotropy parameter $g$ satisfying $|g|1$. Starting from the fundamental properties of Legendre polynomials (orthogonality and generating functions), derive the Legendre moments $a_{l}$ for this $p(\\mu)$ under the given normalization. Provide your final answer as a single closed-form analytic expression for $a_{l}$ in terms of $g$ and $l$. No numerical approximation is required, and no units are needed because $a_{l}$ is dimensionless.",
            "solution": "The problem is valid. It is scientifically grounded in the established theory of neutron transport, well-posed with a unique and meaningful solution, and objectively stated. All provided information is self-contained and consistent. I will now proceed with the derivation.\n\nThe objective is to find the Legendre moments $a_{l}$ for the Henyey–Greenstein phase function $p(\\mu)$. The moments are defined by the integral:\n$$\na_{l} = \\frac{1}{2}\\int_{-1}^{1} p(\\mu)\\,P_{l}(\\mu)\\,\\mathrm{d}\\mu\n$$\nThe given Henyey–Greenstein phase function is:\n$$\np(\\mu) = \\frac{1-g^{2}}{\\left(1+g^{2}-2g\\mu\\right)^{3/2}}\n$$\nSubstituting this expression for $p(\\mu)$ into the definition of $a_{l}$, we get:\n$$\na_{l} = \\frac{1}{2}\\int_{-1}^{1} \\frac{1-g^{2}}{\\left(1+g^{2}-2g\\mu\\right)^{3/2}} P_{l}(\\mu)\\,\\mathrm{d}\\mu\n$$\nTo evaluate this integral, we will find the Legendre series expansion for the Henyey–Greenstein function itself. This can be accomplished by starting with the generating function for the Legendre polynomials, $P_l(\\mu)$. The generating function, which we denote as $G(g, \\mu)$, is given by:\n$$\nG(g, \\mu) = \\frac{1}{\\sqrt{1-2g\\mu+g^2}} = \\sum_{l=0}^{\\infty} g^{l} P_{l}(\\mu)\n$$\nThis series converges for $|g|1$. The denominator of the Henyey–Greenstein function is $(1+g^2-2g\\mu)^{3/2}$, which we recognize as the denominator of the generating function raised to the power of $3$. This suggests a relationship involving derivatives of the generating function.\n\nLet us construct a series $S(g, \\mu)$ and show that it is equal to $p(\\mu)$. Consider the series:\n$$\nS(g, \\mu) = \\sum_{l=0}^{\\infty} (2l+1) g^{l} P_{l}(\\mu)\n$$\nWe can split this sum into two parts:\n$$\nS(g, \\mu) = 2 \\sum_{l=0}^{\\infty} l g^{l} P_{l}(\\mu) + \\sum_{l=0}^{\\infty} g^{l} P_{l}(\\mu)\n$$\nThe second term is precisely the generating function, $G(g, \\mu)$. The first term can be related to the derivative of $G(g, \\mu)$ with respect to $g$:\n$$\n\\sum_{l=0}^{\\infty} l g^{l} P_{l}(\\mu) = g \\sum_{l=1}^{\\infty} l g^{l-1} P_{l}(\\mu) = g \\frac{\\partial}{\\partial g} \\left( \\sum_{l=0}^{\\infty} g^{l} P_{l}(\\mu) \\right) = g \\frac{\\partial G(g, \\mu)}{\\partial g}\n$$\nTherefore, we can express $S(g, \\mu)$ in terms of $G(g, \\mu)$ and its derivative:\n$$\nS(g, \\mu) = 2g \\frac{\\partial G(g, \\mu)}{\\partial g} + G(g, \\mu)\n$$\nNow, we compute the derivative of $G(g, \\mu)$:\n$$\n\\frac{\\partial G(g, \\mu)}{\\partial g} = \\frac{\\partial}{\\partial g} \\left( (1-2g\\mu+g^2)^{-1/2} \\right) = -\\frac{1}{2}(1-2g\\mu+g^2)^{-3/2}(-2\\mu+2g) = \\frac{\\mu-g}{(1-2g\\mu+g^2)^{3/2}}\n$$\nSubstituting this derivative back into the expression for $S(g, \\mu)$:\n$$\nS(g, \\mu) = 2g \\left( \\frac{\\mu-g}{(1-2g\\mu+g^2)^{3/2}} \\right) + \\frac{1}{(1-2g\\mu+g^2)^{1/2}}\n$$\nTo combine these terms, we place them over a common denominator:\n$$\nS(g, \\mu) = \\frac{2g(\\mu-g) + (1-2g\\mu+g^2)}{(1-2g\\mu+g^2)^{3/2}} = \\frac{2g\\mu - 2g^2 + 1 - 2g\\mu + g^2}{(1-2g\\mu+g^2)^{3/2}}\n$$\nSimplifying the numerator gives:\n$$\nS(g, \\mu) = \\frac{1-g^2}{(1-2g\\mu+g^2)^{3/2}} = \\frac{1-g^2}{(1+g^2-2g\\mu)^{3/2}}\n$$\nThis expression is identical to the Henyey–Greenstein phase function $p(\\mu)$. We have thus derived its Legendre series expansion:\n$$\np(\\mu) = \\sum_{k=0}^{\\infty} (2k+1) g^{k} P_{k}(\\mu)\n$$\nWe now substitute this series representation of $p(\\mu)$ into the integral for $a_l$. We use the index $k$ for the summation to avoid confusion with the index $l$ of the moment being calculated.\n$$\na_{l} = \\frac{1}{2}\\int_{-1}^{1} \\left( \\sum_{k=0}^{\\infty} (2k+1) g^{k} P_{k}(\\mu) \\right) P_{l}(\\mu)\\,\\mathrm{d}\\mu\n$$\nSince the series converges uniformly for $|g|1$, we can interchange the order of summation and integration:\n$$\na_{l} = \\frac{1}{2} \\sum_{k=0}^{\\infty} (2k+1) g^{k} \\int_{-1}^{1} P_{k}(\\mu) P_{l}(\\mu)\\,\\mathrm{d}\\mu\n$$\nThe integral is subject to the orthogonality property of Legendre polynomials:\n$$\n\\int_{-1}^{1} P_{k}(\\mu) P_{l}(\\mu)\\,\\mathrm{d}\\mu = \\frac{2}{2l+1} \\delta_{kl}\n$$\nwhere $\\delta_{kl}$ is the Kronecker delta, which is $1$ if $k=l$ and $0$ otherwise. Substituting this orthogonality relation into the expression for $a_l$:\n$$\na_{l} = \\frac{1}{2} \\sum_{k=0}^{\\infty} (2k+1) g^{k} \\left( \\frac{2}{2l+1} \\delta_{kl} \\right)\n$$\nThe Kronecker delta collapses the infinite sum to a single term where $k=l$:\n$$\na_{l} = \\frac{1}{2} (2l+1) g^{l} \\left( \\frac{2}{2l+1} \\right)\n$$\nThe factors of $(2l+1)$ and $1/2$ cancel out, leaving a remarkably simple result:\n$$\na_{l} = g^{l}\n$$\nThis is the closed-form analytic expression for the Legendre moments of the Henyey–Greenstein phase function under the given normalization. This result is valid for all non-negative integers $l$. We can also verify that this result is consistent with the problem's expansion formula $p(\\mu) = \\sum_{l=0}^{\\infty} (2l+1) a_l P_l(\\mu)$ by direct substitution.",
            "answer": "$$\n\\boxed{g^{l}}\n$$"
        },
        {
            "introduction": "Moving from analytical theory to practical implementation, this exercise addresses how Legendre moments are computed in real-world scenarios where cross-section data is often provided numerically. This practice guides you through the design of a Gauss-Legendre quadrature scheme, a highly efficient and accurate method used in data processing codes to prepare cross-section libraries for reactor simulations. It highlights the crucial relationship between the number of quadrature points and the degree of the polynomial that can be integrated exactly .",
            "id": "4233098",
            "problem": "You are tasked with designing and implementing a Gauss–Legendre quadrature for computing scattering Legendre moments in the context of neutron transport, and justifying the number of points required to exactly integrate polynomials up to a specified degree. Consider the one-dimensional cosine of scattering angle, denoted by $\\mu \\in [-1,1]$, and let $\\{P_l(\\mu)\\}_{l=0}^{\\infty}$ be the Legendre polynomials on $[-1,1]$, which satisfy the orthogonality relation\n$$\n\\int_{-1}^{1} P_l(\\mu) P_{m}(\\mu)\\,\\mathrm{d}\\mu = \\frac{2}{2l+1}\\,\\delta_{lm},\n$$\nwhere $\\delta_{lm}$ is the Kronecker delta.\n\nIn multigroup neutron transport, the $l$-th scattering Legendre moment of the scattering cross section $\\sigma_s(\\mu)$ is defined by\n$$\n\\sigma_l = \\frac{2l+1}{2}\\int_{-1}^{1} \\sigma_s(\\mu)\\,P_l(\\mu)\\,\\mathrm{d}\\mu.\n$$\n\nThe Gauss–Legendre quadrature on $[-1,1]$ with $N$ points provides nodes $\\{\\mu_i\\}_{i=1}^{N}$ and positive weights $\\{w_i\\}_{i=1}^{N}$ such that\n$$\n\\int_{-1}^{1} p(\\mu)\\,\\mathrm{d}\\mu = \\sum_{i=1}^{N} w_i\\,p(\\mu_i)\n$$\nfor any polynomial $p(\\mu)$ of degree at most $2N-1$.\n\nYour tasks are:\n- Construct a Gauss–Legendre quadrature with $N=L+1$ points and use it to approximate $\\sigma_l$ for $l=0,1,\\dots,L$ via\n$$\n\\sigma_l^{(Q)} = \\frac{2l+1}{2}\\sum_{i=1}^{N} w_i\\,\\sigma_s(\\mu_i)\\,P_l(\\mu_i).\n$$\n- Justify, using first principles, why $N=L+1$ points exactly integrate any polynomial of degree at most $2L$ on $[-1,1]$.\n- Validate the quadrature by comparing against analytic integrals when available, or by using a higher-order Gauss–Legendre rule that is provably exact for the integrand class.\n\nAngle units: all angles are represented through their cosine $\\mu$, which is dimensionless. No other physical units are required for this problem.\n\nYour program must implement the following test suite and produce results in the exact final output format described below.\n\nTest Suite:\n1. Let $L=3$ and define $\\sigma_s(\\mu)$ in the Legendre basis by\n   $$\n   \\sigma_s(\\mu) = a_0 P_0(\\mu) + a_1 P_1(\\mu) + a_2 P_2(\\mu) + a_3 P_3(\\mu),\n   $$\n   with coefficients $a_0=1.2$, $a_1=0.5$, $a_2=-0.3$, $a_3=0.25$. Compute and return the list $[\\sigma_0^{(Q)},\\sigma_1^{(Q)},\\sigma_2^{(Q)},\\sigma_3^{(Q)}]$ using $N=L+1$ points.\n\n2. Boundary case: Let $L=0$ and $\\sigma_s(\\mu)=c$ with $c=2.5$. Return $\\sigma_0^{(Q)}$ using $N=L+1$ points.\n\n3. Edge case stressing integrand degree: Let $L=3$ and define $\\sigma_s(\\mu)$ in the monomial basis by\n   $$\n   \\sigma_s(\\mu) = c_0 + c_1 \\mu + c_2 \\mu^2 + c_3 \\mu^3 + c_4 \\mu^4 + c_5 \\mu^5 + c_6 \\mu^6,\n   $$\n   with coefficients $c_0=0.8$, $c_1=-0.4$, $c_2=0.3$, $c_3=0.2$, $c_4=-0.1$, $c_5=0.05$, $c_6=0.02$. For $l=0,1,2,3$, compute $\\sigma_l^{(Q)}$ using $N=L+1$ points. Also compute a reference $\\sigma_l^{(\\mathrm{ref})}$ using a Gauss–Legendre quadrature with $N_{\\mathrm{ref}}$ points chosen minimally so that all products $\\sigma_s(\\mu) P_l(\\mu)$ of degree up to $3L$ are integrated exactly, i.e.,\n$$\n2N_{\\mathrm{ref}}-1 \\ge 3L.\n$$\nReturn the maximum absolute error $\\max_{0\\le l \\le L} |\\sigma_l^{(Q)} - \\sigma_l^{(\\mathrm{ref})}|$.\n\n4. Property check: Let $L=4$ and set $N=L+1=5$. For each monomial $p_n(\\mu)=\\mu^n$ with $n=0,1,\\dots,2L$, use the $N$-point Gauss–Legendre quadrature to evaluate $\\int_{-1}^{1} p_n(\\mu)\\,\\mathrm{d}\\mu$. Compare each to the exact analytic integral\n$$\n\\int_{-1}^{1} \\mu^n\\,\\mathrm{d}\\mu = \\begin{cases}\n0,\\text{if $n$ is odd},\\\\\n\\frac{2}{n+1},\\text{if $n$ is even}.\n\\end{cases}\n$$\nReturn a boolean that is $\\mathrm{True}$ if and only if all monomial integrals match the analytic values within an absolute tolerance of $10^{-12}$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The elements correspond to the four test cases above, in order:\n- Test 1: a list of $L+1$ floating-point values $[\\sigma_0^{(Q)},\\dots,\\sigma_L^{(Q)}]$,\n- Test 2: a single floating-point value $\\sigma_0^{(Q)}$,\n- Test 3: a single floating-point value equal to the maximum absolute error,\n- Test 4: a single boolean value indicating the property check result.\n\nFor example, the output must have the shape\n$$\n[\\,[\\cdots],\\,\\cdots,\\,\\cdots,\\,\\mathrm{True}\\,],\n$$\nwith no additional text printed.",
            "solution": "The problem is valid as it is scientifically grounded in numerical methods and nuclear engineering, is well-posed with specific inputs and a clear objective, and is free from any scientific or factual inaccuracies, ambiguities, or contradictions. We may therefore proceed with a solution.\n\nThe core of this problem is the application of Gauss–Legendre quadrature to compute the Legendre moments $\\sigma_l$ of a scattering cross section $\\sigma_s(\\mu)$. We will first provide the theoretical justification for the properties of this quadrature and then outline the algorithmic implementation for each test case.\n\n**Theoretical Justification: Accuracy of Gauss–Legendre Quadrature**\n\nThe problem asks for a justification, from first principles, of why an $N$-point Gauss–Legendre quadrature rule exactly integrates any polynomial of degree up to $2N-1$. We are specifically interested in the case where $N=L+1$, for which the quadrature is exact for polynomials of degree up to $2(L+1)-1 = 2L+1$. This naturally implies exactness for polynomials of degree up to $2L$, as stated in the problem description.\n\nLet the $N$-point Gauss–Legendre quadrature nodes $\\{\\mu_i\\}_{i=1}^N$ be the $N$ distinct roots of the Legendre polynomial $P_N(\\mu)$, which is a polynomial of degree $N$. Let the corresponding weights be $\\{w_i\\}_{i=1}^N$. Let $p(\\mu)$ be an arbitrary polynomial of degree at most $2N-1$.\n\nWe can perform polynomial long division of $p(\\mu)$ by $P_N(\\mu)$ to obtain a quotient $q(\\mu)$ and a remainder $r(\\mu)$:\n$$\np(\\mu) = q(\\mu)P_N(\\mu) + r(\\mu)\n$$\nSince $\\deg(p) \\le 2N-1$ and $\\deg(P_N) = N$, the degree of the quotient must be $\\deg(q) \\le (2N-1) - N = N-1$, and the degree of the remainder must be $\\deg(r) \\le N-1$.\n\nNow, let us integrate $p(\\mu)$ over the interval $[-1, 1]$:\n$$\n\\int_{-1}^{1} p(\\mu)\\,\\mathrm{d}\\mu = \\int_{-1}^{1} q(\\mu)P_N(\\mu)\\,\\mathrm{d}\\mu + \\int_{-1}^{1} r(\\mu)\\,\\mathrm{d}\\mu\n$$\nThe Legendre polynomials $\\{P_k(\\mu)\\}$ form an orthogonal basis on $[-1, 1]$. A key property stemming from this orthogonality is that $\\int_{-1}^{1} P_k(\\mu)P_m(\\mu)\\,\\mathrm{d}\\mu = 0$ for $k \\ne m$. Consequently, $P_N(\\mu)$ is orthogonal to any polynomial of degree less than $N$. Since $\\deg(q) \\le N-1$, $q(\\mu)$ can be expressed as a linear combination of Legendre polynomials $P_k(\\mu)$ for $k \\in \\{0, 1, \\dots, N-1\\}$. Due to orthogonality, the integral of the product of $q(\\mu)$ and $P_N(\\mu)$ is zero:\n$$\n\\int_{-1}^{1} q(\\mu)P_N(\\mu)\\,\\mathrm{d}\\mu = 0\n$$\nThis simplifies the integral of $p(\\mu)$ to:\n$$\n\\int_{-1}^{1} p(\\mu)\\,\\mathrm{d}\\mu = \\int_{-1}^{1} r(\\mu)\\,\\mathrm{d}\\mu\n$$\nNext, let's evaluate the quadrature sum for $p(\\mu)$:\n$$\n\\sum_{i=1}^{N} w_i\\,p(\\mu_i) = \\sum_{i=1}^{N} w_i \\left( q(\\mu_i)P_N(\\mu_i) + r(\\mu_i) \\right)\n$$\nBy definition, the quadrature nodes $\\mu_i$ are the roots of $P_N(\\mu)$, so $P_N(\\mu_i) = 0$ for all $i=1, \\dots, N$. The sum thus reduces to:\n$$\n\\sum_{i=1}^{N} w_i\\,p(\\mu_i) = \\sum_{i=1}^{N} w_i\\,r(\\mu_i)\n$$\nThe weights $w_i$ are constructed precisely so that the $N$-point quadrature rule is exact for all polynomials of degree up to $N-1$. Since $\\deg(r) \\le N-1$, the quadrature evaluates the integral of $r(\\mu)$ exactly:\n$$\n\\int_{-1}^{1} r(\\mu)\\,\\mathrm{d}\\mu = \\sum_{i=1}^{N} w_i\\,r(\\mu_i)\n$$\nBy combining these results, we establish the equality:\n$$\n\\int_{-1}^{1} p(\\mu)\\,\\mathrm{d}\\mu = \\int_{-1}^{1} r(\\mu)\\,\\mathrm{d}\\mu = \\sum_{i=1}^{N} w_i\\,r(\\mu_i) = \\sum_{i=1}^{N} w_i\\,p(\\mu_i)\n$$\nThis proves that the $N$-point Gauss–Legendre quadrature is exact for any polynomial $p(\\mu)$ of degree at most $2N-1$. For the case $N = L+1$, the rule is exact for polynomials of degree up to $2L+1$.\n\n**Algorithmic Design**\n\nThe main computational task is to evaluate the scattering moments $\\sigma_l$ using the quadrature-based approximation:\n$$\n\\sigma_l^{(Q)} = \\frac{2l+1}{2}\\sum_{i=1}^{N} w_i\\,\\sigma_s(\\mu_i)\\,P_l(\\mu_i)\n$$\nThe implementation will rely on `scipy` for standard numerical routines.\n\n1.  **Gauss-Legendre Quadrature**: For a given number of points $N$, the nodes $\\{\\mu_i\\}$ and weights $\\{w_i\\}$ will be obtained using the `scipy.special.roots_legendre(N)` function.\n2.  **Legendre Polynomials**: The values of $P_l(\\mu_i)$ will be calculated using `scipy.special.eval_legendre(l, mu_array)`.\n3.  **Cross Section**: The scattering cross section $\\sigma_s(\\mu)$ must be evaluated at each node $\\mu_i$. The functional form of $\\sigma_s(\\mu)$ is provided in each test case.\n4.  **Summation**: The sum over $i$ will be performed using `numpy`'s efficient vector operations, typically `numpy.dot(weights, integrand_values)`.\n\nWe now detail the approach for each test case.\n\n**Test Case 1**: We are given $L=3$ and $\\sigma_s(\\mu)$ as a degree-3 polynomial in the Legendre basis. We use an $N=L+1=4$ point quadrature. The integrand for the $l$-th moment is $\\sigma_s(\\mu)P_l(\\mu)$. The maximum degree of this integrand occurs for $l=3$, which is $\\deg(P_3(\\mu)P_3(\\mu)) = 3+3=6$. Our $N=4$ point quadrature is exact for polynomials up to degree $2(4)-1=7$. Since $6 \\le 7$, the quadrature will compute the moments exactly. The exact moments are known to be the coefficients $a_l$ themselves due to the orthogonality relation. The algorithm will compute $\\sigma_l^{(Q)}$ for $l=0,1,2,3$ and the result should match $[1.2, 0.5, -0.3, 0.25]$ to within machine precision.\n\n**Test Case 2**: With $L=0$, we require an $N=L+1=1$ point quadrature. Here $\\sigma_s(\\mu)=2.5$, a constant (degree-0 polynomial). The integrand for $\\sigma_0^{(Q)}$ is $\\sigma_s(\\mu)P_0(\\mu) = 2.5 \\times 1 = 2.5$, which is a degree-0 polynomial. The $N=1$ point rule is exact for polynomials up to degree $2(1)-1=1$. The single node is $\\mu_1=0$ with weight $w_1=2$. The calculation is $\\sigma_0^{(Q)} = \\frac{1}{2} w_1 \\sigma_s(\\mu_1) P_0(\\mu_1) = \\frac{1}{2}(2)(2.5)(1) = 2.5$.\n\n**Test Case 3**: We are given $L=3$ and a degree-6 polynomial $\\sigma_s(\\mu)$ in the monomial basis. We first compute $\\sigma_l^{(Q)}$ with an $N=L+1=4$ point quadrature. The maximum integrand degree is for $l=3$, which is $\\deg(\\sigma_s(\\mu)P_3(\\mu)) = 6+3=9$. The $N=4$ quadrature rule is only exact up to degree $7$, so it will produce an approximate result. To find the error, we compute a reference solution $\\sigma_l^{(\\mathrm{ref})}$ using a quadrature order high enough to be exact. The required order $N_{\\mathrm{ref}}$ must satisfy $2N_{\\mathrm{ref}}-1 \\ge 9$, leading to a minimal $N_{\\mathrm{ref}}=5$. We will compute the moments with both $N=4$ and $N=5$ points and then find the maximum absolute difference between the two sets of results.\n\n**Test Case 4**: This case serves as a direct validation of the fundamental property of Gauss–Legendre quadrature. We use $L=4$, so $N=L+1=5$. The quadrature should be exact for polynomials of degree up to $2(5)-1=9$. We test this by integrating the monomials $\\mu^n$ for $n=0, 1, \\dots, 2L=8$. The highest degree is $8$, which is less than $9$. For each $n$, we compute the integral using the quadrature sum $\\sum_{i=1}^5 w_i\\mu_i^n$ and compare it against the known analytic result, which is $2/(n+1)$ for even $n$ and $0$ for odd $n$. The test passes if all computed integrals are within a tolerance of $10^{-12}$ of their analytic values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef calculate_sigma_l(l_max, n_pts, sigma_s_func):\n    \"\"\"\n    Calculates Legendre moments sigma_l for l=0,...,l_max using an n_pts\n    Gauss-Legendre quadrature.\n\n    Args:\n        l_max (int): Maximum Legendre order to compute.\n        n_pts (int): Number of quadrature points.\n        sigma_s_func (callable): Function that takes an array of mu values and\n                                 returns the cross section sigma_s(mu).\n\n    Returns:\n        list: A list of the computed moments [sigma_0, ..., sigma_l_max].\n    \"\"\"\n    mus, weights = special.roots_legendre(n_pts)\n    sigma_s_vals = sigma_s_func(mus)\n\n    sigmas = []\n    for l in range(l_max + 1):\n        # Evaluate P_l at all quadrature nodes\n        pl_vals = special.eval_legendre(l, mus)\n        \n        # Form the integrand for the moment calculation\n        integrand_vals = sigma_s_vals * pl_vals\n        \n        # Perform the quadrature sum\n        integral = np.dot(weights, integrand_vals)\n        \n        # Apply the normalization factor\n        sigma_l = (2 * l + 1) / 2.0 * integral\n        sigmas.append(sigma_l)\n        \n    return sigmas\n\n\ndef test_case_1():\n    \"\"\"\n    Test Case 1: sigma_s is a polynomial of degree L=3 in Legendre basis.\n    The N=L+1 quadrature is exact.\n    \"\"\"\n    L = 3\n    N = L + 1\n    a_coeffs = np.array([1.2, 0.5, -0.3, 0.25])\n\n    def sigma_s_mu(mu):\n        # Using numpy's broadcasting for evaluation at multiple points\n        L_vals = np.arange(len(a_coeffs))\n        mu_reshaped = mu[:, np.newaxis]\n        pl_matrix = special.eval_legendre(L_vals, mu_reshaped)\n        return pl_matrix @ a_coeffs\n\n    sigmas = calculate_sigma_l(L, N, sigma_s_mu)\n    return sigmas\n\n\ndef test_case_2():\n    \"\"\"\n    Test Case 2: Boundary case with L=0, constant cross section.\n    \"\"\"\n    L = 0\n    N = L + 1\n    c = 2.5\n\n    def sigma_s_mu(mu):\n        return np.full_like(mu, c)\n\n    sigmas = calculate_sigma_l(L, N, sigma_s_mu)\n    return sigmas[0]\n\n\ndef test_case_3():\n    \"\"\"\n    Test Case 3: Stress test where N=L+1 is not sufficient for exactness.\n    \"\"\"\n    L = 3\n    c_coeffs = np.array([0.8, -0.4, 0.3, 0.2, -0.1, 0.05, 0.02])\n\n    def sigma_s_mu(mu):\n        # Note: np.polyval expects coefficients from highest power to lowest\n        return np.polyval(c_coeffs[::-1], mu)\n\n    # Approximate calculation with N = L+1 points\n    N_q = L + 1\n    sigmas_q = calculate_sigma_l(L, N_q, sigma_s_mu)\n\n    # Reference calculation with minimally exact number of points\n    # deg(sigma_s) = 6, max deg(P_l) = 3. Integrand deg = 9.\n    # 2*N_ref - 1 = 9 == N_ref = 5.\n    N_ref = 5\n    sigmas_ref = calculate_sigma_l(L, N_ref, sigma_s_mu)\n\n    # Calculate max absolute error\n    error = np.max(np.abs(np.array(sigmas_q) - np.array(sigmas_ref)))\n    return error\n\n\ndef test_case_4():\n    \"\"\"\n    Test Case 4: Property check of the quadrature rule itself.\n    \"\"\"\n    L = 4\n    N = L + 1  # 5 points\n    tol = 1e-12\n\n    mus, weights = special.roots_legendre(N)\n    \n    # The N=5 rule is exact for polynomials up to degree 2*5-1=9\n    # We test for monomials up to degree 2L=8\n    max_n = 2 * L\n    \n    for n in range(max_n + 1):\n        # Quadrature sum for integral of mu^n\n        integrand_vals = mus**n\n        quad_integral = np.dot(weights, integrand_vals)\n        \n        # Analytic result\n        if n % 2 != 0:\n            analytic_integral = 0.0\n        else:\n            analytic_integral = 2.0 / (n + 1)\n        \n        if abs(quad_integral - analytic_integral)  tol:\n            return False\n            \n    return True\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    results = [\n        test_case_1(),\n        test_case_2(),\n        test_case_3(),\n        test_case_4(),\n    ]\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n\n```"
        },
        {
            "introduction": "This final practice connects the mathematical framework of Legendre expansions to its direct impact on the accuracy of a neutron transport simulation. By implementing a simplified spherical harmonics ($P_N$) solver, you will investigate how the truncation order $N$ affects the computed scalar flux and current for various degrees of scattering anisotropy. This numerical experiment provides a tangible understanding of the trade-offs between computational cost and physical fidelity in reactor physics calculations .",
            "id": "4233106",
            "problem": "Consider a steady-state, monoenergetic neutron transport problem in one-dimensional slab geometry. The unknown angular flux is denoted by $\\psi(x,\\mu)$ where $x$ is the spatial coordinate (in $\\mathrm{cm}$) and $\\mu$ is the direction cosine (dimensionless). The total macroscopic cross section is $\\Sigma_t$ (in $\\mathrm{cm^{-1}}$). The scattering kernel is represented by a Legendre expansion with moments $\\Sigma_{s,\\ell}$ such that the scattering source term is consistent with the spherical harmonics method (P$_N$), where the angular flux is expanded as $\\psi(x,\\mu) \\approx \\sum_{\\ell=0}^{N} (2\\ell+1)\\,\\phi_\\ell(x)\\,P_\\ell(\\mu)$ with moments $\\phi_\\ell(x)$ (the scalar flux is $\\phi_0(x)$ and the current is $\\phi_1(x)$). The microscopic physics is parameterized by a forward-peaked kernel where the Legendre moments of the scattering cross section satisfy $\\Sigma_{s,\\ell} = \\Sigma_{s,0}\\,g^\\ell$ with $0 \\le g  1$, $\\Sigma_{s,0} = c\\,\\Sigma_t$, and $0  c  1$. This form is consistent with a Henyey–Greenstein type phase function where Legendre moments decay geometrically with $\\ell$.\n\nAssume an isotropic volumetric source with spatial dependence $Q(x) = Q_0 \\cos(k x)$ where $Q_0$ is the zeroth Legendre moment of the source (in $\\mathrm{n\\;cm^{-3}\\;s^{-1}}$), and $k$ is the wavenumber (in radians per $\\mathrm{cm}$). Using the spherical harmonics method (P$_N$) truncated at order $N$, the moment equations in slab geometry can be obtained by projecting the neutron transport equation onto Legendre polynomials, leading to a coupled system for $\\{\\phi_\\ell(x)\\}_{\\ell=0}^N$ with nearest-neighbor coupling from the streaming term and diagonal terms containing $\\Sigma_t$ and $\\Sigma_{s,\\ell}$. Under harmonic forcing $Q(x) = \\Re\\{Q_0 e^{i k x}\\}$, it is appropriate to seek harmonic responses $\\phi_\\ell(x) = \\Re\\{\\hat{\\phi}_\\ell e^{i k x}\\}$, which transforms spatial derivatives to algebraic factors $i k$.\n\nStarting from the fundamental neutron balance equation and standard orthogonality of Legendre polynomials, derive the algebraic system for the complex amplitudes $\\{\\hat{\\phi}_\\ell\\}_{\\ell=0}^{N}$ under the P$_N$ closure $\\hat{\\phi}_{-1} = 0$ and $\\hat{\\phi}_{N+1} = 0$. Then, design and implement a numerical experiment that computes the P$_1$, P$_3$, and P$_7$ solutions for the scalar flux amplitude $\\hat{\\phi}_0$ and current amplitude $\\hat{\\phi}_1$ for a set of forward-peaked kernels, and quantifies the convergence of these amplitudes with respect to $N$ by comparison to a high-order reference solution at $N = N_{\\mathrm{ref}}$.\n\nThe numerical experiment must adhere to the following requirements:\n\n- Use the coupled moment equations formed by the spherical harmonics method (P$_N$) in slab geometry with harmonic source. You must construct the $(N+1)\\times(N+1)$ linear system for the complex amplitudes $\\{\\hat{\\phi}_\\ell\\}$, with nearest-neighbor couplings proportional to $i k$ from the streaming term and diagonal entries containing $(2\\ell+1)\\left(\\Sigma_t - \\Sigma_{s,\\ell}\\right)$. Take the source moment vector with only the zeroth component nonzero, equal to $Q_0$.\n- For each $N \\in \\{1,3,7\\}$, solve for $\\hat{\\phi}_0$ and $\\hat{\\phi}_1$, and compute the relative errors of these complex amplitudes with respect to a reference P$_{N_{\\mathrm{ref}}}$ solution with $N_{\\mathrm{ref}} = 31$. The relative error for a complex amplitude $\\hat{\\phi}$ must be defined as $|\\hat{\\phi}^{(N)} - \\hat{\\phi}^{(N_{\\mathrm{ref}})}| \\big/ |\\hat{\\phi}^{(N_{\\mathrm{ref}})}|$, which is dimensionless.\n- Express all cross sections in $\\mathrm{cm^{-1}}$, the wavenumber $k$ in radians per $\\mathrm{cm}$, the source $Q_0$ in $\\mathrm{n\\;cm^{-3}\\;s^{-1}}$, and report the relative errors (dimensionless). Angles are not directly reported; the direction cosine $\\mu$ is dimensionless, and spatial harmonic wavenumber $k$ uses radians.\n- Provide a test suite of parameter sets $(\\Sigma_t, c, g, k, Q_0)$ that explores different regimes, including a general case, diffusion-like behavior, extreme forward-peaking, isotropic scattering control, and increased absorption. Specifically, use:\n    - Case A (general forward-peaked): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0.9,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case B (diffusion-like $k \\to 0$): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0.9,\\,10^{-3}\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case C (extreme forward-peaked and higher spatial frequency): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.95,\\,0.99,\\,2\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case D (isotropic scattering control): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n    - Case E (increased absorption): $(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.3,\\,0.9,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output the six floats in the order $[\\text{err}(\\hat{\\phi}_0^{\\mathrm{P1}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P1}}), \\text{err}(\\hat{\\phi}_0^{\\mathrm{P3}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P3}}), \\text{err}(\\hat{\\phi}_0^{\\mathrm{P7}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P7}})]$, and concatenate all cases into one flat list. The relative errors are dimensionless floats. The final output is therefore a single bracketed list of $30$ floats.\n\nThe objective is to quantify, from first principles, how the spherical harmonics method (P$_N$) converges for a forward-peaked scattering kernel, and how the scalar flux and current amplitudes depend on $N$ across regimes. No external input is required; all parameters are specified above and must be hard-coded in your program.",
            "solution": "The user-provided problem is assessed to be valid. It is scientifically sound, well-posed, objective, and self-contained, presenting a standard problem in nuclear reactor physics. We will now proceed with the derivation and solution.\n\nThe foundation of this problem is the steady-state, monoenergetic neutron transport equation in one-dimensional slab geometry. This equation describes the balance of neutrons at a position $x$ traveling in a direction specified by the direction cosine $\\mu = \\cos(\\theta)$:\n$$\n\\mu \\frac{\\partial \\psi(x,\\mu)}{\\partial x} + \\Sigma_t \\psi(x,\\mu) = \\int_{-1}^{1} \\Sigma_s(\\mu') \\psi(x,\\mu') \\mathrm{d}\\mu' + Q(x,\\mu)\n$$\nHere, $\\psi(x,\\mu)$ is the angular neutron flux, $\\Sigma_t$ is the total macroscopic cross section, $\\Sigma_s(\\mu')$ represents the scattering kernel, and $Q(x,\\mu)$ is the external neutron source. It is assumed the scattering process is azimuthally symmetric, hence the kernel only depends on the cosine of the scattering angle.\n\nThe problem specifies a spherical harmonics (P$_N$) method to approximate the solution. This involves expanding the angular dependence of the flux $\\psi(x,\\mu)$ and the scattering kernel $\\Sigma_s(\\mu_s)$ in terms of Legendre polynomials, $P_\\ell(\\mu)$. A common convention, which leads to the system described in the problem, is to define the flux moments $\\phi_\\ell(x)$ and then construct the system for these moments. The one-dimensional transport equation in terms of moments $\\{\\phi_\\ell(x)\\}_{\\ell=0}^N$ is given by:\n$$\n\\frac{\\ell}{2\\ell-1}\\frac{\\mathrm{d}\\phi_{\\ell-1}(x)}{\\mathrm{d}x} + \\frac{\\ell+1}{2\\ell+1}\\frac{\\mathrm{d}\\phi_{\\ell+1}(x)}{\\mathrm{d}x} + (\\Sigma_t - \\Sigma_{s,\\ell})\\phi_\\ell(x) = Q_\\ell(x)\n$$\nwhere $\\phi_\\ell(x) = \\int_{-1}^{1} \\psi(x,\\mu) P_\\ell(\\mu) \\mathrm{d}\\mu$ are the flux moments, $\\Sigma_{s,\\ell}$ are the Legendre moments of the scattering cross section, and $Q_\\ell(x)$ are the moments of the source. The problem statement implies a scaling of these equations. If we multiply the $\\ell$-th equation by $(2\\ell+1)$, we obtain:\n$$\n\\ell \\frac{\\mathrm{d}\\phi_{\\ell-1}(x)}{\\mathrm{d}x} + (\\ell+1) \\frac{\\mathrm{d}\\phi_{\\ell+1}(x)}{\\mathrm{d}x} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\phi_\\ell(x) = (2\\ell+1)Q_\\ell(x)\n$$\nThis form matches the matrix structure described in the problem statement. The P$_N$ approximation is closed by setting $\\phi_{N+1}(x) = 0$. The condition $\\phi_{-1}=0$ is naturally satisfied for the $\\ell=0$ equation. The source is specified as isotropic with spatial dependence $Q(x) = Q_0 \\cos(kx)$. Its only non-zero moment is for $\\ell=0$: $Q_0(x) = Q_0 \\cos(kx)$. All other moments $Q_\\ell(x)=0$ for $\\ell > 0$.\n\nThe problem seeks a solution under harmonic forcing. We represent the source as $Q(x) = \\Re\\{Q_0 e^{ikx}\\}$ and seek harmonic responses for the flux moments: $\\phi_\\ell(x) = \\Re\\{\\hat{\\phi}_\\ell e^{ikx}\\}$. The spatial derivative operator $\\frac{\\mathrm{d}}{\\mathrm{d}x}$ transforms into multiplication by $ik$. Substituting these forms into the scaled moment equations yields a system of algebraic equations for the complex amplitudes $\\{\\hat{\\phi}_\\ell\\}_{\\ell=0}^N$:\n$$\nik\\ell\\,\\hat{\\phi}_{\\ell-1} + ik(\\ell+1)\\,\\hat{\\phi}_{\\ell+1} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\hat{\\phi}_\\ell = (2\\ell+1)Q_0\\delta_{\\ell,0}\n$$\nFor $\\ell=0$, this gives:\n$$\nik\\,\\hat{\\phi}_{1} + (\\Sigma_t - \\Sigma_{s,0})\\hat{\\phi}_0 = Q_0\n$$\nFor $1 \\le \\ell \\le N-1$:\n$$\nik\\ell\\,\\hat{\\phi}_{\\ell-1} + ik(\\ell+1)\\,\\hat{\\phi}_{\\ell+1} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\hat{\\phi}_\\ell = 0\n$$\nFor $\\ell=N$, applying the closure condition $\\hat{\\phi}_{N+1}=0$:\n$$\nikN\\,\\hat{\\phi}_{N-1} + (2N+1)(\\Sigma_t - \\Sigma_{s,N})\\hat{\\phi}_N = 0\n$$\nThis system can be written in matrix form as $A \\hat{\\mathbf{\\phi}} = \\hat{\\mathbf{Q}}$, where $\\hat{\\mathbf{\\phi}} = [\\hat{\\phi}_0, \\hat{\\phi}_1, \\dots, \\hat{\\phi}_N]^T$ and $\\hat{\\mathbf{Q}} = [Q_0, 0, \\dots, 0]^T$. The matrix $A$ is an $(N+1) \\times (N+1)$ complex-valued, tridiagonal matrix with the following non-zero entries for $\\ell = 0, \\dots, N$:\n$$\nA_{\\ell,\\ell-1} = ik\\ell \\quad (\\text{for } \\ell > 0)\n$$\n$$\nA_{\\ell,\\ell} = (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\n$$\n$$\nA_{\\ell,\\ell+1} = ik(\\ell+1) \\quad (\\text{for } \\ell  N)\n$$\nThe problem specifies the scattering moments as $\\Sigma_{s,\\ell} = \\Sigma_{s,0} g^\\ell$, where $\\Sigma_{s,0} = c \\Sigma_t$.\n\nThe numerical experiment involves constructing and solving this linear system for different expansion orders $N \\in \\{1, 3, 7\\}$ and for several sets of physical parameters. A high-order reference solution with $N_{\\mathrm{ref}}=31$ is computed to serve as a benchmark. The convergence of the P$_N$ approximation is quantified by computing the relative error of the complex amplitudes for the scalar flux ($\\hat{\\phi}_0$) and current ($\\hat{\\phi}_1$) with respect to this reference solution. The relative error for a complex quantity $\\hat{\\phi}$ is defined as $|\\hat{\\phi}^{(N)} - \\hat{\\phi}^{(N_{\\mathrm{ref}})}| / |\\hat{\\phi}^{(N_{\\mathrm{ref}})}|$.\n\nThe algorithm is as follows:\n1. For each parameter set $(\\Sigma_t, c, g, k, Q_0)$:\n2. Compute the reference solution vector $\\hat{\\mathbf{\\phi}}^{(N_{\\mathrm{ref}})}$ by constructing and solving the system $A \\hat{\\mathbf{\\phi}} = \\hat{\\mathbf{Q}}$ for $N = N_{\\mathrm{ref}} = 31$. Extract the reference amplitudes $\\hat{\\phi}_0^{(N_{\\mathrm{ref}})}$ and $\\hat{\\phi}_1^{(N_{\\mathrm{ref}})}$.\n3. For each test order $N \\in \\{1, 3, 7\\}$:\n    a. Compute the solution vector $\\hat{\\mathbf{\\phi}}^{(N)}$ by solving the system for that $N$.\n    b. Extract the amplitudes $\\hat{\\phi}_0^{(N)}$ and $\\hat{\\phi}_1^{(N)}$.\n    c. Calculate the relative errors for $\\hat{\\phi}_0$ and $\\hat{\\phi}_1$ using the specified formula.\n4. Collect all computed relative errors into a single list in the prescribed order for final output.\n\nThis procedure is implemented in the following Python code.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_pn(N, Sigma_t, c, g, k, Q0):\n    \"\"\"\n    Constructs and solves the P_N algebraic system for complex flux moment amplitudes.\n\n    Args:\n        N (int): The order of the P_N approximation.\n        Sigma_t (float): Total macroscopic cross section (cm^-1).\n        c (float): Scattering ratio (Sigma_s0 / Sigma_t).\n        g (float): Anisotropy factor for scattering moments.\n        k (float): Wavenumber of the harmonic source (rad/cm).\n        Q0 (float): Amplitude of the zeroth moment of the source (n cm^-3 s^-1).\n\n    Returns:\n        numpy.ndarray: A complex vector of the flux moment amplitudes [phi_0, ..., phi_N].\n    \"\"\"\n    n_vars = N + 1\n    A = np.zeros((n_vars, n_vars), dtype=np.complex128)\n    b = np.zeros(n_vars, dtype=np.complex128)\n\n    # Set the source term (only the 0-th moment is non-zero)\n    b[0] = Q0\n\n    # Calculate the 0-th scattering moment\n    Sigma_s0 = c * Sigma_t\n\n    # Populate the tridiagonal matrix A\n    for l in range(n_vars):\n        # Scattering moment for order l\n        Sigma_sl = Sigma_s0 * (g**l)\n        \n        # Diagonal element\n        A[l, l] = (2 * l + 1) * (Sigma_t - Sigma_sl)\n\n        # Super-diagonal element (l - l+1 coupling)\n        if l  N:\n            A[l, l + 1] = 1j * k * (l + 1)\n\n        # Sub-diagonal element (l - l-1 coupling)\n        if l  0:\n            A[l, l - 1] = 1j * k * l\n\n    # Solve the linear system A * phi_hat = b\n    phi_hat = np.linalg.solve(A, b)\n    return phi_hat\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment as specified in the problem.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: general forward-peaked\n        (1.0, 0.9, 0.9, 0.5, 1.0),\n        # Case B: diffusion-like k - 0\n        (1.0, 0.9, 0.9, 1e-3, 1.0),\n        # Case C: extreme forward-peaked and higher spatial frequency\n        (1.0, 0.95, 0.99, 2.0, 1.0),\n        # Case D: isotropic scattering control\n        (1.0, 0.9, 0.0, 0.5, 1.0),\n        # Case E: increased absorption\n        (1.0, 0.3, 0.9, 0.5, 1.0),\n    ]\n\n    N_orders = [1, 3, 7]\n    N_ref = 31\n    \n    all_results = []\n\n    for params in test_cases:\n        Sigma_t, c, g, k, Q0 = params\n\n        # Compute the high-order reference solution\n        phi_hat_ref = solve_pn(N_ref, Sigma_t, c, g, k, Q0)\n        phi0_ref = phi_hat_ref[0]\n        phi1_ref = phi_hat_ref[1]\n\n        # Avoid division by zero if reference value is zero (highly unlikely for these params)\n        phi0_ref_mag = np.abs(phi0_ref)\n        if phi0_ref_mag == 0: phi0_ref_mag = 1.0\n\n        phi1_ref_mag = np.abs(phi1_ref)\n        if phi1_ref_mag == 0: phi1_ref_mag = 1.0\n\n        # Compute solutions for specified N orders and their errors\n        for N in N_orders:\n            phi_hat_N = solve_pn(N, *params)\n            phi0_N = phi_hat_N[0]\n            # Current (phi_1) is only available for N = 1\n            phi1_N = phi_hat_N[1] if N = 1 else 0.0 + 0.0j\n\n            # Calculate relative errors\n            err_phi0 = np.abs(phi0_N - phi0_ref) / phi0_ref_mag\n            err_phi1 = np.abs(phi1_N - phi1_ref) / phi1_ref_mag\n            \n            all_results.append(err_phi0)\n            all_results.append(err_phi1)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8e}' for x in all_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}