{
    "hands_on_practices": [
        {
            "introduction": "理想化的模型，例如用于散射的狄拉克 $\\delta$ 函数，是理解我们方法局限性的强大工具。这项练习将推导这样一个核的勒让德矩，揭示在表示高度各向异性散射时遇到的基本挑战。通过分析其勒让德矩的收敛行为，我们可以深入理解 $P_N$ 近似的收敛性质及其在实际应用中的局限性。",
            "id": "4233070",
            "problem": "考虑在无限均匀介质中的平板几何内的单能中子输运，其中宏观微分散射截面仅依赖于散射角的余弦，记为 $\\mu \\in [-1,1]$。设该截面是强前向峰化的，并由狄拉克$\\delta$分布建模，即 $\\sigma(\\mu) = \\sigma_{s} \\,\\delta(\\mu - \\mu_{0})$，其中 $\\sigma_{s} > 0$ 是一个常数，$\\mu_{0} \\in [-1,1]$ 是固定的。在中子输运中，平板几何内的各向异性散射通常通过将 $\\sigma(\\mu)$ 在区间 $[-1,1]$ 上的勒让德多项式基 $\\{P_{l}(\\mu)\\}_{l=0}^{\\infty}$ 中展开来表示，这些多项式在以下意义上是正交的：\n$$\n\\int_{-1}^{1} P_{l}(\\mu)\\,P_{m}(\\mu)\\,d\\mu = \\frac{2}{2l+1}\\,\\delta_{lm}.\n$$\n从勒让德基的完备性和上述正交关系作为基本输入出发，推导由以下表示定义的勒让德展开系数 $\\sigma_{l}$：\n$$\n\\sigma(\\mu) = \\sum_{l=0}^{\\infty} \\frac{2l+1}{2}\\,\\sigma_{l}\\,P_{l}(\\mu).\n$$\n然后，利用 $l \\to \\infty$ 时勒让德多项式的渐近性质分析 $\\sigma_{l}$ 的高阶行为，讨论$N$阶截断球谐函数近似（$P_N$）对于类$\\delta$函数核的收敛速度，并比较 $\\mu_{0} \\in (-1,1)$ 和 $\\mu_{0} = 1$ 两种情况。假设角度以弧度为单位。用包含 $\\sigma_{s}$、$\\mu_{0}$ 和 $P_{l}$ 的闭式符号表达式来表示你的最终答案。",
            "solution": "目标是推导由狄拉克$\\delta$分布建模的散射截面的勒让德展开系数 $\\sigma_{l}$，并分析所得级数的收敛性质。\n\n散射截面由 $\\sigma(\\mu) = \\sigma_{s} \\,\\delta(\\mu - \\mu_{0})$ 给出，其中 $\\sigma_{s} > 0$ 是一个常数，$\\mu_{0} \\in [-1,1]$ 是散射角的余弦。$\\sigma(\\mu)$ 在勒让德多项式 $P_{l}(\\mu)$ 基中的展开式如下：\n$$\n\\sigma(\\mu) = \\sum_{m=0}^{\\infty} \\frac{2m+1}{2}\\,\\sigma_{m}\\,P_{m}(\\mu)\n$$\n这里，求和索引记为 $m$，以区别于我们旨在确定的系数索引 $l$。勒让德多项式在区间 $[-1,1]$ 上是正交的，并满足以下关系：\n$$\n\\int_{-1}^{1} P_{l}(\\mu)\\,P_{m}(\\mu)\\,d\\mu = \\frac{2}{2l+1}\\,\\delta_{lm}\n$$\n其中 $\\delta_{lm}$ 是克罗内克$\\delta$。\n\n为了确定任意非负整数 $l$ 的系数 $\\sigma_{l}$，我们利用正交性质。我们将 $\\sigma(\\mu)$ 的级数表示式的两边同乘以 $P_{l}(\\mu)$，然后在定义域 $\\mu \\in [-1, 1]$ 上积分。\n\n此操作的左侧（LHS）变为：\n$$\n\\text{LHS} = \\int_{-1}^{1} \\sigma(\\mu) P_{l}(\\mu) \\,d\\mu\n$$\n代入 $\\sigma(\\mu)$ 的表达式：\n$$\n\\text{LHS} = \\int_{-1}^{1} \\sigma_{s} \\delta(\\mu - \\mu_{0}) P_{l}(\\mu) \\,d\\mu\n$$\n通过应用狄拉克$\\delta$函数的筛选性质，该性质表明，对于包含点 $a$ 的积分域，$\\int f(x) \\delta(x-a) \\,dx = f(a)$，我们计算该积分。由于 $\\mu_{0} \\in [-1,1]$，该条件得到满足，我们得到：\n$$\n\\text{LHS} = \\sigma_{s} P_{l}(\\mu_{0})\n$$\n此操作的右侧（RHS）为：\n$$\n\\text{RHS} = \\int_{-1}^{1} \\left( \\sum_{m=0}^{\\infty} \\frac{2m+1}{2}\\,\\sigma_{m}\\,P_{m}(\\mu) \\right) P_{l}(\\mu) \\,d\\mu\n$$\n假设级数收敛性足够好，允许交换求和与积分的顺序，我们有：\n$$\n\\text{RHS} = \\sum_{m=0}^{\\infty} \\frac{2m+1}{2}\\,\\sigma_{m} \\int_{-1}^{1} P_{m}(\\mu) P_{l}(\\mu) \\,d\\mu\n$$\n利用勒让德多项式的正交关系：\n$$\n\\text{RHS} = \\sum_{m=0}^{\\infty} \\frac{2m+1}{2}\\,\\sigma_{m} \\left( \\frac{2}{2l+1}\\,\\delta_{lm} \\right)\n$$\n克罗内克$\\delta$，$\\delta_{lm}$，的存在使得无穷级数中除了 $m=l$ 的那一项外，所有项都为零。因此，表达式简化为：\n$$\n\\text{RHS} = \\frac{2l+1}{2}\\,\\sigma_{l} \\left( \\frac{2}{2l+1} \\right) = \\sigma_{l}\n$$\n通过令LHS和RHS的结果相等，我们得到如下关系：\n$$\n\\sigma_{s} P_{l}(\\mu_{0}) = \\sigma_{l}\n$$\n解此方程得到 $\\sigma_{l}$，即为勒让德展开系数的闭式符号表达式：\n$$\n\\sigma_{l} = \\sigma_{s} P_{l}(\\mu_{0})\n$$\n该表达式即为所要求的最终答案。\n\n为了分析高阶行为，我们考察 $l \\to \\infty$ 时 $\\sigma_{l}$ 的渐近性。截断的$P_N$近似 $\\sigma_{N}(\\mu) = \\sum_{l=0}^{N} \\frac{2l+1}{2}\\,\\sigma_{l}\\,P_{l}(\\mu)$ 的收敛性取决于 $\\sigma_{l}$ 的衰减速度。\n\n情况1：$\\mu_{0} \\in (-1,1)$。\n在这种情况下，我们可以写成 $\\mu_{0} = \\cos(\\theta_{0})$，其中某个角度 $\\theta_{0} \\in (0, \\pi)$。对于大的 $l$，勒让德多项式的渐近行为由 Hilb 公式给出：\n$$\nP_{l}(\\cos\\theta_{0}) \\approx \\sqrt{\\frac{2}{\\pi l \\sin\\theta_{0}}} \\cos\\left( \\left(l + \\frac{1}{2}\\right)\\theta_{0} - \\frac{\\pi}{4} \\right) + O(l^{-3/2})\n$$\n这表明 $P_{l}(\\mu_{0})$ 以 $l^{-1/2}$ 的速率衰减。因此，系数 $\\sigma_{l} = \\sigma_{s} P_{l}(\\mu_{0})$ 也以 $O(l^{-1/2})$ 的速率衰减。这是一个极其缓慢的衰减速度，这意味着 $P_N$ 级数收敛非常慢。需要大量的项，即高阶的 $N$，才能合理地近似$\\delta$函数，这是将尖锐的、局域化的函数在全局多项式基中展开时的一种典型病态特征。\n\n情况2：$\\mu_{0} = 1$（纯前向散射）。\n对于这个极限情况，我们使用已知的恒等式 $P_{l}(1) = 1$（对所有 $l \\ge 0$）。展开系数变为：\n$$\n\\sigma_{l} = \\sigma_{s} P_{l}(1) = \\sigma_{s}\n$$\n这些系数是常数，当 $l \\to \\infty$ 时不趋于零。级数收敛的条件未被满足。因此，勒让德级数展开无法表示位于区间端点的$\\delta$函数。在实践中，$P_N$ 方法的这一严重限制通常通过使用“输运修正”来处理，即将散射的前向峰化部分从展开式中移除，并将其视为对总截面的一项修正。",
            "answer": "$$\n\\boxed{\\sigma_{s} P_{l}(\\mu_{0})}\n$$"
        },
        {
            "introduction": "在实际应用中，散射截面通常以复杂的函数或表格数据的形式给出，解析积分往往不可行。本练习介绍高斯-勒让德求积，这是一种工业标准的数值方法，用于从任意截面数据中精确计算勒让德矩。通过实现并验证此方法，您将掌握将理论转化为实用计算工具的关键技能。",
            "id": "4233098",
            "problem": "您的任务是设计并实现一个高斯-勒让德求积方法，用于在中子输运的背景下计算散射勒让德矩，并论证精确积分最高达到指定次数的多项式所需的点数。考虑一维散射角余弦，记为 $\\mu \\in [-1,1]$，并设 $\\{P_l(\\mu)\\}_{l=0}^{\\infty}$ 为区间 $[-1,1]$ 上的勒让德多项式，它们满足正交关系\n$$\n\\int_{-1}^{1} P_l(\\mu) P_{m}(\\mu)\\,d\\mu = \\frac{2}{2l+1}\\,\\delta_{lm},\n$$\n其中 $\\delta_{lm}$ 是克罗内克$\\delta$函数。\n\n在多群中子输运中，散射截面 $\\sigma_s(\\mu)$ 的第 $l$ 阶散射勒让德矩 $\\sigma_l$ 定义为\n$$\n\\sigma_l = \\frac{2l+1}{2}\\int_{-1}^{1} \\sigma_s(\\mu)\\,P_l(\\mu)\\,d\\mu.\n$$\n\n在 $[-1,1]$ 上具有 $N$ 个点的高斯-勒让德求积提供了节点 $\\{\\mu_i\\}_{i=1}^{N}$ 和正权重 $\\{w_i\\}_{i=1}^{N}$，使得\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\sum_{i=1}^{N} w_i\\,p(\\mu_i)\n$$\n对于任意次数至多为 $2N-1$ 的多项式 $p(\\mu)$ 成立。\n\n您的任务是：\n- 构造一个具有 $N=L+1$ 个点的高斯-勒让德求积，并用它通过以下公式来近似计算 $l=0,1,\\dots,L$ 时的 $\\sigma_l$：\n$$\n\\sigma_l^{(Q)} = \\frac{2l+1}{2}\\sum_{i=1}^{N} w_i\\,\\sigma_s(\\mu_i)\\,P_l(\\mu_i).\n$$\n- 从第一性原理出发，论证为何 $N=L+1$ 个点能精确积分在 $[-1,1]$ 上任意次数至多为 $2L+1$ 的多项式。\n- 通过与可用的解析积分进行比较，或通过使用一个对于该被积函数类别可证明是精确的更高阶高斯-勒让德法则来验证该求积。\n\n角度单位：所有角度都通过其无量纲的余弦值 $\\mu$ 来表示。本问题不需要其他物理单位。\n\n您的程序必须实现以下测试套件，并按下文描述的精确最终输出格式生成结果。\n\n测试套件：\n1. 设 $L=3$，并在勒让德基中定义 $\\sigma_s(\\mu)$ 为\n   $$\n   \\sigma_s(\\mu) = a_0 P_0(\\mu) + a_1 P_1(\\mu) + a_2 P_2(\\mu) + a_3 P_3(\\mu),\n   $$\n   系数为 $a_0=1.2$, $a_1=0.5$, $a_2=-0.3$, $a_3=0.25$。使用 $N=L+1$ 个点计算并返回列表 $[\\sigma_0^{(Q)},\\sigma_1^{(Q)},\\sigma_2^{(Q)},\\sigma_3^{(Q)}]$。\n\n2. 边界情况：设 $L=0$ 且 $\\sigma_s(\\mu)=c$，其中 $c=2.5$。使用 $N=L+1$ 个点返回 $\\sigma_0^{(Q)}$。\n\n3. 强调被积函数次数的边缘情况：设 $L=3$，并在单项式基中定义 $\\sigma_s(\\mu)$ 为\n   $$\n   \\sigma_s(\\mu) = c_0 + c_1 \\mu + c_2 \\mu^2 + c_3 \\mu^3 + c_4 \\mu^4 + c_5 \\mu^5 + c_6 \\mu^6,\n   $$\n   系数为 $c_0=0.8$, $c_1=-0.4$, $c_2=0.3$, $c_3=0.2$, $c_4=-0.1$, $c_5=0.05$, $c_6=0.02$。对于 $l=0,1,2,3$，使用 $N=L+1$ 个点计算 $\\sigma_l^{(Q)}$。同时，使用一个高斯-勒让德求积计算参考值 $\\sigma_l^{(\\mathrm{ref})}$，其点数 $N_{\\mathrm{ref}}$ 取能使所有次数最高为 $L+\\deg(\\sigma_s)$ 的乘积 $\\sigma_s(\\mu) P_l(\\mu)$ 都被精确积分的最小值，即\n$$\n2N_{\\mathrm{ref}}-1 \\ge L+\\deg(\\sigma_s).\n$$\n返回最大绝对误差 $\\max_{0\\le l \\le L} |\\sigma_l^{(Q)} - \\sigma_l^{(\\mathrm{ref})}|$。\n\n4. 属性检查：设 $L=4$ 并设 $N=L+1=5$。对于每个单项式 $p_n(\\mu)=\\mu^n$（其中 $n=0,1,\\dots,2L$），使用 $N$ 点高斯-勒让德求积计算 $\\int_{-1}^{1} p_n(\\mu)\\,d\\mu$。将每个结果与精确的解析积分进行比较\n$$\n\\int_{-1}^{1} \\mu^n\\,d\\mu = \\begin{cases}\n0,\\text{若 $n$ 为奇数},\\\\\n\\frac{2}{n+1},\\text{若 $n$ 为偶数}.\n\\end{cases}\n$$\n当且仅当所有单项式积分值与解析值在 $10^{-12}$ 的绝对容差内匹配时，返回布尔值 $\\mathrm{True}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的元素按顺序对应于上述四个测试用例：\n- 测试 1：一个包含 $L+1$ 个浮点数值的列表 $[\\sigma_0^{(Q)},\\dots,\\sigma_L^{(Q)}]$，\n- 测试 2：一个浮点数值 $\\sigma_0^{(Q)}$，\n- 测试 3：一个等于最大绝对误差的浮点数值，\n- 测试 4：一个表明属性检查结果的布尔值。\n\n例如，输出必须具有以下形状\n$$\n[\\,[\\cdots],\\,\\cdots,\\,\\cdots,\\,\\mathrm{True}\\,],\n$$\n并且不打印任何额外文本。",
            "solution": "该问题是有效的，因为它在数值方法和核工程领域有科学依据，是适定的（具有具体输入和明确目标），并且没有任何科学或事实上的不准确性、模糊或矛盾。因此，我们可以着手提供解答。\n\n这个问题的核心是应用高斯-勒让德求积来计算散射截面 $\\sigma_s(\\mu)$ 的勒让德矩 $\\sigma_l$。我们将首先为该求积的性质提供理论论证，然后概述每个测试用例的算法实现。\n\n**理论论证：高斯-勒让德求積的精度**\n\n问题要求从第一性原理出发，论证为何一个 $N$ 点高斯-勒让德求积法则能精确积分任何次数最高为 $2N-1$ 的多项式。我们特别关心 $N=L+1$ 的情况，此时该求积对于次数最高为 $2(L+1)-1 = 2L+1$ 的多项式是精确的。\n\n设 $N$ 点高斯-勒让德求积节点 $\\{\\mu_i\\}_{i=1}^N$ 是 $N$ 次勒让德多项式 $P_N(\\mu)$ 的 $N$ 个不同根。设对应的权重为 $\\{w_i\\}_{i=1}^N$。设 $p(\\mu)$ 是一个次数至多为 $2N-1$ 的任意多项式。\n\n我们可以用 $p(\\mu)$ 对 $P_N(\\mu)$ 做多项式长除法，得到商 $q(\\mu)$ 和余数 $r(\\mu)$：\n$$\np(\\mu) = q(\\mu)P_N(\\mu) + r(\\mu)\n$$\n由于 $\\deg(p) \\le 2N-1$ 且 $\\deg(P_N) = N$，商的次数必须为 $\\deg(q) \\le (2N-1) - N = N-1$，余数的次数必须为 $\\deg(r) \\le N-1$。\n\n现在，我们在区间 $[-1, 1]$ 上对 $p(\\mu)$ 进行积分：\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\int_{-1}^{1} q(\\mu)P_N(\\mu)\\,d\\mu + \\int_{-1}^{1} r(\\mu)\\,d\\mu\n$$\n勒让德多项式 $\\{P_k(\\mu)\\}$ 在 $[-1, 1]$ 上构成一个正交基。源于此正交性的一个关键性质是，当 $k \\ne m$ 时，$\\int_{-1}^{1} P_k(\\mu)P_m(\\mu)\\,d\\mu = 0$。因此，$P_N(\\mu)$ 与任何次数小于 $N$ 的多项式正交。由于 $\\deg(q) \\le N-1$，$q(\\mu)$ 可以表示为勒让德多项式 $P_k(\\mu)$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）的线性组合。由于正交性，$q(\\mu)$ 和 $P_N(\\mu)$ 乘积的积分为零：\n$$\n\\int_{-1}^{1} q(\\mu)P_N(\\mu)\\,d\\mu = 0\n$$\n这使得 $p(\\mu)$ 的积分简化为：\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\int_{-1}^{1} r(\\mu)\\,d\\mu\n$$\n接下来，我们计算 $p(\\mu)$ 的求积和：\n$$\n\\sum_{i=1}^{N} w_i\\,p(\\mu_i) = \\sum_{i=1}^{N} w_i \\left( q(\\mu_i)P_N(\\mu_i) + r(\\mu_i) \\right)\n$$\n根据定义，求积节点 $\\mu_i$ 是 $P_N(\\mu)$ 的根，因此对于所有 $i=1, \\dots, N$ 都有 $P_N(\\mu_i) = 0$。于是，和简化为：\n$$\n\\sum_{i=1}^{N} w_i\\,p(\\mu_i) = \\sum_{i=1}^{N} w_i\\,r(\\mu_i)\n$$\n权重 $w_i$ 的构造恰好使得 $N$ 点求积法则对所有次数最高为 $N-1$ 的多项式都是精确的。由于 $\\deg(r) \\le N-1$，该求积能精确计算 $r(\\mu)$ 的积分：\n$$\n\\int_{-1}^{1} r(\\mu)\\,d\\mu = \\sum_{i=1}^{N} w_i\\,r(\\mu_i)\n$$\n结合这些结果，我们建立了等式：\n$$\n\\int_{-1}^{1} p(\\mu)\\,d\\mu = \\int_{-1}^{1} r(\\mu)\\,d\\mu = \\sum_{i=1}^{N} w_i\\,r(\\mu_i) = \\sum_{i=1}^{N} w_i\\,p(\\mu_i)\n$$\n这证明了 $N$ 点高斯-勒让德求积对于任何次数至多为 $2N-1$ 的多项式 $p(\\mu)$ 都是精确的。对于 $N = L+1$ 的情况，该法则对次数最高为 $2L+1$ 的多项式是精确的。\n\n**算法设计**\n\n主要的计算任务是使用基于求积的近似方法来计算散射矩 $\\sigma_l$：\n$$\n\\sigma_l^{(Q)} = \\frac{2l+1}{2}\\sum_{i=1}^{N} w_i\\,\\sigma_s(\\mu_i)\\,P_l(\\mu_i)\n$$\n该实现将依赖 `scipy` 库来执行标准数值例程。\n\n1.  **高斯-勒让德求积**：对于给定的点数 $N$，节点 $\\{\\mu_i\\}$ 和权重 $\\{w_i\\}$ 将使用 `scipy.special.roots_legendre(N)` 函数获得。\n2.  **勒让德多项式**：$P_l(\\mu_i)$ 的值将使用 `scipy.special.eval_legendre(l, mu_array)` 计算。\n3.  **截面**：必须在每个节点 $\\mu_i$ 处计算散射截面 $\\sigma_s(\\mu)$ 的值。$\\sigma_s(\\mu)$ 的函数形式在每个测试用例中给出。\n4.  **求和**：对 $i$ 的求和将使用 `numpy` 的高效向量操作来执行，通常是 `numpy.dot(weights, integrand_values)`。\n\n我们现在详细说明每个测试用例的方法。\n\n**测试用例 1**：给定 $L=3$ 且 $\\sigma_s(\\mu)$ 是勒让德基中的一个3次多项式。我们使用一个 $N=L+1=4$ 点的求积。第 $l$ 阶矩的被积函数是 $\\sigma_s(\\mu)P_l(\\mu)$。该被积函数的最高次数在 $l=3$ 时出现，为 $\\deg(P_3(\\mu)P_3(\\mu)) = 3+3=6$。我们的 $N=4$ 点求积对次数最高为 $2(4)-1=7$ 的多项式是精确的。由于 $6 \\le 7$，该求积将能精确计算这些矩。由于正交关系，已知精确的矩就是系数 $a_l$ 本身。算法将计算 $l=0,1,2,3$ 时的 $\\sigma_l^{(Q)}$，结果应在机器精度范围内与 $[1.2, 0.5, -0.3, 0.25]$ 相匹配。\n\n**测试用例 2**：当 $L=0$ 时，我们需要一个 $N=L+1=1$ 点的求积。这里 $\\sigma_s(\\mu)=2.5$，是一个常数（0次多项式）。$\\sigma_0^{(Q)}$ 的被积函数是 $\\sigma_s(\\mu)P_0(\\mu) = 2.5 \\times 1 = 2.5$，这是一个0次多项式。$N=1$ 点法则对次数最高为 $2(1)-1=1$ 的多项式是精确的。单个节点是 $\\mu_1=0$，权重是 $w_1=2$。计算过程为 $\\sigma_0^{(Q)} = \\frac{1}{2} w_1 \\sigma_s(\\mu_1) P_0(\\mu_1) = \\frac{1}{2}(2)(2.5)(1) = 2.5$。\n\n**测试用例 3**：给定 $L=3$ 和一个在单项式基中的6次多项式 $\\sigma_s(\\mu)$。我们首先用一个 $N=L+1=4$ 点的求积计算 $\\sigma_l^{(Q)}$。被积函数的最高次数在 $l=3$ 时出现，为 $\\deg(\\sigma_s(\\mu)P_3(\\mu)) = 6+3=9$。$N=4$ 点求积法则仅对次数最高为 $7$ 的多项式精确，因此它将产生一个近似结果。为了找出误差，我们使用一个足够高阶以保证精确的求积来计算一个参考解 $\\sigma_l^{(\\mathrm{ref})}$。所需的阶数 $N_{\\mathrm{ref}}$ 必须满足 $2N_{\\mathrm{ref}}-1 \\ge 9$，这导致最小的 $N_{\\mathrm{ref}}=5$。我们将用 $N=4$ 和 $N=5$ 个点分别计算这些矩，然后找出两组结果之间的最大绝对差。\n\n**测试用例 4**：这个案例用作高斯-勒让德求积基本性质的直接验证。我们使用 $L=4$，因此 $N=L+1=5$。该求积应对于次数最高为 $2(5)-1=9$ 的多项式是精确的。我们通过对单项式 $\\mu^n$（其中 $n=0, 1, \\dots, 2L=8$）进行积分来测试这一点。最高次数是 $8$，小于 $9$。对于每个 $n$，我们使用求积和 $\\sum_{i=1}^5 w_i\\mu_i^n$ 来计算积分，并将其与已知的解析结果进行比较，即对于偶数 $n$ 是 $2/(n+1)$，对于奇数 $n$ 是 $0$。如果所有计算出的积分值与其解析值之差的绝对值都在 $10^{-12}$ 的容差范围内，则测试通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special\n\ndef calculate_sigma_l(l_max, n_pts, sigma_s_func):\n    \"\"\"\n    Calculates Legendre moments sigma_l for l=0,...,l_max using an n_pts\n    Gauss-Legendre quadrature.\n\n    Args:\n        l_max (int): Maximum Legendre order to compute.\n        n_pts (int): Number of quadrature points.\n        sigma_s_func (callable): Function that takes an array of mu values and\n                                 returns the cross section sigma_s(mu).\n\n    Returns:\n        list: A list of the computed moments [sigma_0, ..., sigma_l_max].\n    \"\"\"\n    mus, weights = special.roots_legendre(n_pts)\n    sigma_s_vals = sigma_s_func(mus)\n\n    sigmas = []\n    for l in range(l_max + 1):\n        # Evaluate P_l at all quadrature nodes\n        pl_vals = special.eval_legendre(l, mus)\n        \n        # Form the integrand for the moment calculation\n        integrand_vals = sigma_s_vals * pl_vals\n        \n        # Perform the quadrature sum\n        integral = np.dot(weights, integrand_vals)\n        \n        # Apply the normalization factor\n        sigma_l = (2 * l + 1) / 2.0 * integral\n        sigmas.append(sigma_l)\n        \n    return sigmas\n\n\ndef test_case_1():\n    \"\"\"\n    Test Case 1: sigma_s is a polynomial of degree L=3 in Legendre basis.\n    The N=L+1 quadrature is exact.\n    \"\"\"\n    L = 3\n    N = L + 1\n    a_coeffs = np.array([1.2, 0.5, -0.3, 0.25])\n\n    def sigma_s_mu(mu):\n        # Using numpy's broadcasting for evaluation at multiple points\n        L_vals = np.arange(len(a_coeffs))\n        mu_reshaped = mu[:, np.newaxis]\n        pl_matrix = special.eval_legendre(L_vals, mu_reshaped)\n        return pl_matrix @ a_coeffs\n\n    sigmas = calculate_sigma_l(L, N, sigma_s_mu)\n    return sigmas\n\n\ndef test_case_2():\n    \"\"\"\n    Test Case 2: Boundary case with L=0, constant cross section.\n    \"\"\"\n    L = 0\n    N = L + 1\n    c = 2.5\n\n    def sigma_s_mu(mu):\n        return np.full_like(mu, c)\n\n    sigmas = calculate_sigma_l(L, N, sigma_s_mu)\n    return sigmas[0]\n\n\ndef test_case_3():\n    \"\"\"\n    Test Case 3: Stress test where N=L+1 is not sufficient for exactness.\n    \"\"\"\n    L = 3\n    c_coeffs = np.array([0.8, -0.4, 0.3, 0.2, -0.1, 0.05, 0.02])\n\n    def sigma_s_mu(mu):\n        # Note: np.polyval expects coefficients from highest power to lowest\n        return np.polyval(c_coeffs[::-1], mu)\n\n    # Approximate calculation with N = L+1 points\n    N_q = L + 1\n    sigmas_q = calculate_sigma_l(L, N_q, sigma_s_mu)\n\n    # Reference calculation with minimally exact number of points\n    # deg(sigma_s) = 6, max deg(P_l) = 3. Integrand deg = 9.\n    # 2*N_ref - 1 = 9 == N_ref = 5.\n    N_ref = 5\n    sigmas_ref = calculate_sigma_l(L, N_ref, sigma_s_mu)\n\n    # Calculate max absolute error\n    error = np.max(np.abs(np.array(sigmas_q) - np.array(sigmas_ref)))\n    return error\n\n\ndef test_case_4():\n    \"\"\"\n    Test Case 4: Property check of the quadrature rule itself.\n    \"\"\"\n    L = 4\n    N = L + 1  # 5 points\n    tol = 1e-12\n\n    mus, weights = special.roots_legendre(N)\n    \n    # The N=5 rule is exact for polynomials up to degree 2*5-1=9\n    # We test for monomials up to degree 2L=8\n    max_n = 2 * L\n    \n    for n in range(max_n + 1):\n        # Quadrature sum for integral of mu^n\n        integrand_vals = mus**n\n        quad_integral = np.dot(weights, integrand_vals)\n        \n        # Analytic result\n        if n % 2 != 0:\n            analytic_integral = 0.0\n        else:\n            analytic_integral = 2.0 / (n + 1)\n        \n        if abs(quad_integral - analytic_integral) > tol:\n            return False\n            \n    return True\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Use np.round to ensure consistent floating point representation in string\n    # and match the reference output format for the list in test case 1\n    tc1_res = np.round(test_case_1(), 8).tolist()\n    \n    results = [\n        str(tc1_res),\n        str(np.round(test_case_2(), 8)),\n        str(np.round(test_case_3(), 15)),\n        str(test_case_4()),\n    ]\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "展开散射截面的最终目的是为了求解输运方程。这最后一个练习将理论与实践相结合，要求您实现一个 $P_N$ 求解器，以观察最终解（中子通量和流）的精度如何依赖于所用勒让德矩的数量（$N$）和散射各向异性的程度。这项综合性实践将巩固您对勒让德展开在整个中子学模拟流程中作用的理解。",
            "id": "4233106",
            "problem": "考虑一个一维平板几何中的稳态单能中子输运问题。未知的角通量密度用 $\\psi(x,\\mu)$ 表示，其中 $x$ 是空间坐标（单位为 $\\mathrm{cm}$），$\\mu$ 是方向余弦（无量纲）。总宏观截面为 $\\Sigma_t$（单位为 $\\mathrm{cm^{-1}}$）。散射核由勒让德展开式表示，其矩为 $\\Sigma_{s,\\ell}$，使得散射源项与球谐函数方法（$P_N$）一致，其中角通量密度展开为 $\\psi(x,\\mu) \\approx \\sum_{\\ell=0}^{N} (2\\ell+1)\\,\\phi_\\ell(x)\\,P_\\ell(\\mu)$，其矩为 $\\phi_\\ell(x)$（标量通量密度为 $\\phi_0(x)$，流密度为 $\\phi_1(x)$）。微观物理由一个前向峰化散射核参数化，其中散射截面的勒让德矩满足 $\\Sigma_{s,\\ell} = \\Sigma_{s,0}\\,g^\\ell$，且 $0 \\le g  1$，$\\Sigma_{s,0} = c\\,\\Sigma_t$ 及 $0  c  1$。这种形式与 Henyey–Greenstein 型相函数一致，其勒让德矩随 $\\ell$ 呈几何衰减。\n\n假设有一个各向同性的体积源，其空间依赖关系为 $Q(x) = Q_0 \\cos(k x)$，其中 $Q_0$ 是源的零阶勒让德矩（单位为 $\\mathrm{n\\;cm^{-3}\\;s^{-1}}$），$k$ 是波数（单位为 $\\mathrm{rad\\;cm^{-1}}$）。使用在 $N$ 阶截断的球谐函数方法（$P_N$），通过将中子输运方程投影到勒让德多项式上，可以得到平板几何中的矩方程，这会形成一个关于 $\\{\\phi_\\ell(x)\\}_{\\ell=0}^N$ 的耦合系统，其中流项产生最近邻耦合，对角项包含 $(2\\ell+1)\\left(\\Sigma_t - \\Sigma_{s,\\ell}\\right)$。在谐波驱动 $Q(x) = \\Re\\{Q_0 e^{i k x}\\}$ 下，适宜寻找谐波响应 $\\phi_\\ell(x) = \\Re\\{\\hat{\\phi}_\\ell e^{i k x}\\}$，这将空间导数转换为代数因子 $i k$。\n\n从基本的中子平衡方程和勒让德多项式的标准正交性出发，推导在 $P_N$ 近似（其闭合条件为 $\\hat{\\phi}_{N+1} = 0$）下，复振幅 $\\{\\hat{\\phi}_\\ell\\}_{\\ell=0}^{N}$ 的代数系统。然后，设计并实现一个数值实验，该实验为一组前向峰化散射核计算标量通量密度振幅 $\\hat{\\phi}_0$ 和流密度振幅 $\\hat{\\phi}_1$ 的 $P_1$、$P_3$ 和 $P_7$ 解，并通过与 $N = N_{\\mathrm{ref}}$ 的高阶参考解进行比较，来量化这些振幅相对于 $N$ 的收敛性。\n\n数值实验必须遵守以下要求：\n\n- 使用由平板几何和谐波源的球谐函数方法（$P_N$）形成的耦合矩方程。您必须构建关于复振幅 $\\{\\hat{\\phi}_\\ell\\}$ 的 $(N+1)\\times(N+1)$ 线性系统，其中最近邻耦合与流项中的 $i k$ 成正比，对角线元素包含 $(2\\ell+1)\\left(\\Sigma_t - \\Sigma_{s,\\ell}\\right)$。源矩向量仅有第零个分量非零，等于 $Q_0$。\n- 对于每个 $N \\in \\{1,3,7\\}$，求解 $\\hat{\\phi}_0$ 和 $\\hat{\\phi}_1$，并计算这些复振幅相对于 $N_{\\mathrm{ref}} = 31$ 的 $P_{N_{\\mathrm{ref}}}$ 参考解的相对误差。复振幅 $\\hat{\\phi}$ 的相对误差必须定义为 $|\\hat{\\phi}^{(N)} - \\hat{\\phi}^{(N_{\\mathrm{ref}})}| \\big/ |\\hat{\\phi}^{(N_{\\mathrm{ref}})}|$，该值是无量纲的。\n- 所有截面以 $\\mathrm{cm^{-1}}$ 表示，波数 $k$ 以 $\\mathrm{rad\\;cm^{-1}}$ 表示，源 $Q_0$ 以 $\\mathrm{n\\;cm^{-3}\\;s^{-1}}$ 表示，并报告相对误差（无量纲）。角度不直接报告；方向余弦 $\\mu$ 是无量纲的，空间谐波波数 $k$ 使用弧度单位。\n- 提供一套参数集 $(\\Sigma_t, c, g, k, Q_0)$ 的测试套件，用于探索不同情况，包括一般情况、类扩散行为、极端前向峰化、各向同性散射控制和增加的吸收。具体使用：\n    - 情况 A（一般前向峰化）：$(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0.9,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$。\n    - 情况 B（类扩散 $k \\to 0$）：$(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0.9,\\,10^{-3}\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$。\n    - 情况 C（极端前向峰化和更高空间频率）：$(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.95,\\,0.99,\\,2\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$。\n    - 情况 D（各向同性散射控制）：$(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.9,\\,0,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$。\n    - 情况 E（增加的吸收）：$(\\Sigma_t, c, g, k, Q_0) = (\\,1\\,\\mathrm{cm^{-1}},\\,0.3,\\,0.9,\\,0.5\\,\\mathrm{rad\\;cm^{-1}},\\,1\\,\\mathrm{n\\;cm^{-3}\\;s^{-1}}\\,)$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每种情况，按顺序输出六个浮点数 $[\\text{err}(\\hat{\\phi}_0^{\\mathrm{P1}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P1}}), \\text{err}(\\hat{\\phi}_0^{\\mathrm{P3}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P3}}), \\text{err}(\\hat{\\phi}_0^{\\mathrm{P7}}), \\text{err}(\\hat{\\phi}_1^{\\mathrm{P7}})]$，并将所有情况的结果连接成一个扁平列表。相对误差是无量纲的浮点数。因此，最终输出是一个包含 $30$ 个浮点数的单一括号列表。\n\n目标是从第一性原理出发，量化球谐函数方法（$P_N$）对于前向峰化散射核的收敛情况，以及标量通量密度和流密度振幅在不同情况下如何依赖于 $N$。不需要外部输入；所有参数均已在上方指定，并且必须硬编码在您的程序中。",
            "solution": "经评估，用户提供的问题是有效的。该问题在科学上是合理的，提法恰当，客观且自洽，是核反应堆物理学中的一个标准问题。我们现在将进行推导和求解。\n\n该问题的基础是一维平板几何中的稳态单能中子输运方程。该方程描述了在位置 $x$ 处、沿方向余弦 $\\mu = \\cos(\\theta)$ 指定的方向行进的中子的平衡：\n$$\n\\mu \\frac{\\partial \\psi(x,\\mu)}{\\partial x} + \\Sigma_t \\psi(x,\\mu) = \\int_{-1}^{1} \\Sigma_s(\\mu_s,\\mu') \\psi(x,\\mu') d\\mu' + Q(x,\\mu)\n$$\n在这里，$\\psi(x,\\mu)$ 是角中子通量密度，$\\Sigma_t$ 是总宏观截面，$\\Sigma_s(\\mu_s)$ 代表散射核，$Q(x,\\mu)$ 是外部中子源。假设散射过程是方位角对称的，因此散射核仅依赖于散射角的余弦。\n\n问题指定使用球谐函数（$P_N$）方法来近似求解。这涉及将通量密度 $\\psi(x,\\mu)$ 和散射核 $\\Sigma_s(\\mu_s)$ 的角依赖性展开为勒让德多项式 $P_\\ell(\\mu)$。一种常见的约定，也是导出问题中所述系统的方法，是定义通量矩 $\\phi_\\ell(x)$，然后为这些矩构建系统。用矩 $\\{\\phi_\\ell(x)\\}_{\\ell=0}^N$ 表示的一维输运方程由下式给出：\n$$\n\\frac{\\ell}{2\\ell-1}\\frac{{d\\phi}_{\\ell-1}(x)}{dx} + \\frac{\\ell+1}{2\\ell+1}\\frac{d\\phi_{\\ell+1}(x)}{dx} + (\\Sigma_t - \\Sigma_{s,\\ell})\\phi_\\ell(x) = Q_\\ell(x)\n$$\n其中 $\\phi_\\ell(x) = \\frac{2\\ell+1}{2} \\int_{-1}^{1} \\psi(x,\\mu) P_\\ell(\\mu) d\\mu$ 是通量矩，$\\Sigma_{s,\\ell}$ 是散射截面的勒让德矩，$Q_\\ell(x)$ 是源的矩。问题陈述暗示了对这些方程进行缩放。如果我们将第 $\\ell$ 个方程乘以 $(2\\ell+1)$，并使用不同的通量矩定义 $\\tilde{\\phi}_\\ell = (2\\ell+1)\\phi_\\ell$，我们会得到：\n$$\n\\ell \\frac{d\\tilde{\\phi}_{\\ell-1}(x)}{dx} + (\\ell+1) \\frac{d\\tilde{\\phi}_{\\ell+1}(x)}{dx} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\tilde{\\phi}_\\ell(x) = (2\\ell+1)Q_\\ell(x)\n$$\n这种形式与问题陈述中描述的矩阵结构相匹配。$P_N$ 近似通过设置 $\\tilde{\\phi}_{N+1}(x) = 0$ 来闭合。对于 $\\ell=0$ 的方程，条件 $\\tilde{\\phi}_{-1}=0$ 自然满足。源被指定为各向同性，其空间依赖关系为 $Q(x) = Q_0 \\cos(kx)$。其唯一的非零矩是 $\\ell=0$ 时的矩：$Q_0(x) = Q_0 \\cos(kx)$。所有其他矩 $Q_\\ell(x)=0$（对于 $\\ell > 0$）。\n\n问题要求在谐波驱动下求解。我们将源表示为 $Q(x) = \\Re\\{Q_0 e^{ikx}\\}$，并为通量矩寻找谐波响应：$\\tilde{\\phi}_\\ell(x) = \\Re\\{\\hat{\\phi}_\\ell e^{ikx}\\}$。空间导数算子 $\\frac{d}{dx}$ 变换为乘以 $ik$。将这些形式代入缩放后的矩方程，得到关于复振幅 $\\{\\hat{\\phi}_\\ell\\}_{\\ell=0}^N$ 的代数方程组：\n$$\nik\\ell\\,\\hat{\\phi}_{\\ell-1} + ik(\\ell+1)\\,\\hat{\\phi}_{\\ell+1} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\hat{\\phi}_\\ell = (2\\ell+1)Q_0\\delta_{\\ell,0}\n$$\n对于 $\\ell=0$：\n$$\nik\\,\\hat{\\phi}_{1} + (\\Sigma_t - \\Sigma_{s,0})\\hat{\\phi}_0 = Q_0\n$$\n对于 $1 \\le \\ell \\le N-1$：\n$$\nik\\ell\\,\\hat{\\phi}_{\\ell-1} + ik(\\ell+1)\\,\\hat{\\phi}_{\\ell+1} + (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\\hat{\\phi}_\\ell = 0\n$$\n对于 $\\ell=N$，应用闭合条件 $\\hat{\\phi}_{N+1}=0$：\n$$\nikN\\,\\hat{\\phi}_{N-1} + (2N+1)(\\Sigma_t - \\Sigma_{s,N})\\hat{\\phi}_N = 0\n$$\n该系统可以写成矩阵形式 $A \\hat{\\mathbf{\\phi}} = \\hat{\\mathbf{Q}}$，其中 $\\hat{\\mathbf{\\phi}} = [\\hat{\\phi}_0, \\hat{\\phi}_1, \\dots, \\hat{\\phi}_N]^T$ 且 $\\hat{\\mathbf{Q}} = [Q_0, 0, \\dots, 0]^T$。矩阵 $A$ 是一个 $(N+1) \\times (N+1)$ 的复值三对角矩阵，其对于 $\\ell = 0, \\dots, N$ 的非零元素如下：\n$$\nA_{\\ell,\\ell-1} = ik\\ell \\quad (\\text{对于 } \\ell > 0)\n$$\n$$\nA_{\\ell,\\ell} = (2\\ell+1)(\\Sigma_t - \\Sigma_{s,\\ell})\n$$\n$$\nA_{\\ell,\\ell+1} = ik(\\ell+1) \\quad (\\text{对于 } \\ell  N)\n$$\n问题指定散射矩为 $\\Sigma_{s,\\ell} = \\Sigma_{s,0} g^\\ell$，其中 $\\Sigma_{s,0} = c \\Sigma_t$。\n\n数值实验涉及为不同的展开阶数 $N \\in \\{1, 3, 7\\}$ 和几组物理参数构建并求解该线性系统。计算一个 $N_{\\mathrm{ref}}=31$ 的高阶参考解作为基准。$P_N$ 近似的收敛性通过计算标量通量密度（$\\hat{\\phi}_0$）和流密度（$\\hat{\\phi}_1$）的复振幅相对于此参考解的相对误差来量化。复数量 $\\hat{\\phi}$ 的相对误差定义为 $|\\hat{\\phi}^{(N)} - \\hat{\\phi}^{(N_{\\mathrm{ref}})}| / |\\hat{\\phi}^{(N_{\\mathrm{ref}})}|$。\n\n算法如下：\n1. 对于每组参数集 $(\\Sigma_t, c, g, k, Q_0)$：\n2. 通过为 $N = N_{\\mathrm{ref}} = 31$ 构建并求解系统 $A \\hat{\\mathbf{\\phi}} = \\hat{\\mathbf{Q}}$ 来计算参考解向量 $\\hat{\\mathbf{\\phi}}^{(N_{\\mathrm{ref}})}$。提取参考振幅 $\\hat{\\phi}_0^{(N_{\\mathrm{ref}})}$ 和 $\\hat{\\phi}_1^{(N_{\\mathrm{ref}})}$。\n3. 对于每个测试阶数 $N \\in \\{1, 3, 7\\}$：\n    a. 通过求解对应 $N$ 的系统来计算解向量 $\\hat{\\mathbf{\\phi}}^{(N)}$。\n    b. 提取振幅 $\\hat{\\phi}_0^{(N)}$ 和 $\\hat{\\phi}_1^{(N)}$。\n    c. 使用指定的公式计算 $\\hat{\\phi}_0$ 和 $\\hat{\\phi}_1$ 的相对误差。\n4. 将所有计算出的相对误差按规定顺序收集到单个列表中，以备最终输出。\n\n此过程在以下 Python 代码中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_pn(N, Sigma_t, c, g, k, Q0):\n    \"\"\"\n    Constructs and solves the P_N algebraic system for complex flux moment amplitudes.\n\n    Args:\n        N (int): The order of the P_N approximation.\n        Sigma_t (float): Total macroscopic cross section (cm^-1).\n        c (float): Scattering ratio (Sigma_s0 / Sigma_t).\n        g (float): Anisotropy factor for scattering moments.\n        k (float): Wavenumber of the harmonic source (rad/cm).\n        Q0 (float): Amplitude of the zeroth moment of the source (n cm^-3 s^-1).\n\n    Returns:\n        numpy.ndarray: A complex vector of the flux moment amplitudes [phi_0, ..., phi_N].\n    \"\"\"\n    n_vars = N + 1\n    A = np.zeros((n_vars, n_vars), dtype=np.complex128)\n    b = np.zeros(n_vars, dtype=np.complex128)\n\n    # Set the source term (only the 0-th moment is non-zero)\n    # The problem description implies the source term for l=0 is Q0.\n    b[0] = Q0\n\n    # Calculate the 0-th scattering moment\n    Sigma_s0 = c * Sigma_t\n    \n    # The problem defines the diagonal term of the system matrix for l=0 as\n    # (Sigma_t - Sigma_s0). We implement this directly.\n    A[0, 0] = Sigma_t - Sigma_s0\n    if N > 0:\n        A[0, 1] = 1j * k * 1\n\n    # Populate the rest of the tridiagonal matrix A\n    for l in range(1, n_vars):\n        # Scattering moment for order l\n        Sigma_sl = Sigma_s0 * (g**l)\n        \n        # Diagonal element\n        # The problem states the form is (2l+1)(Sigma_t - Sigma_s,l)\n        # But the derived equation for l=0 is different.\n        # Let's stick to the derived system which is more standard.\n        A[l, l] = (Sigma_t - Sigma_sl)\n\n        # Super-diagonal element (l -> l+1 coupling)\n        if l  N:\n            A[l, l + 1] = 1j * k * (l + 1) / (2 * l + 1)\n\n        # Sub-diagonal element (l -> l-1 coupling)\n        if l > 0:\n            A[l, l - 1] = 1j * k * l / (2 * l + 1)\n\n    # The problem states a specific form for the matrix system.\n    # Let's re-implement according to the problem text strictly.\n    # \"the diagonal terms contain (2l+1)(Sigma_t - Sigma_s,l)\"\n    # \"nearest neighbor coupling is proportional to ik\"\n    # \"Source moment vector is nonzero only for the zeroth component, equal to Q0\"\n    # This implies the system in the Solution section is the one to implement.\n    A = np.zeros((n_vars, n_vars), dtype=np.complex128)\n    b[0] = Q0 # Resetting b\n    \n    for l in range(n_vars):\n        Sigma_sl = Sigma_s0 * (g**l)\n        A[l,l] = (Sigma_t - Sigma_sl)\n        # The problem text gives a slightly ambiguous recipe. The solution's derivation\n        # is the standard P_N formulation. It seems the problem text's recipe was\n        # slightly simplified. We will follow the solution's derivation.\n        # It seems the problem text `(2l+1)(Sigma_t-Sigma_sl)` is for a different moment definition.\n        # The final equations in the solution are the ones to use.\n        # Let's trust the solution's derivation of the matrix A.\n        if l == 0:\n            A[l,l] = Sigma_t - Sigma_s0\n            if l  N:\n                A[l,l+1] = 1j * k\n        else: # l > 0\n            A[l,l] = (2*l+1)*(Sigma_t-Sigma_sl)\n            if l  N:\n                A[l,l+1] = 1j * k * (l+1)\n            if l > 0:\n                A[l,l-1] = 1j * k * l\n    \n    # With the source Q_0, the l=0 equation is ik*phi_1 + (Sigma_t-Sigma_s0)*phi_0 = Q_0.\n    # The l>0 equation is ik*l*phi_{l-1} + ik*(l+1)*phi_{l+1} + (2l+1)(Sigma_t-Sigma_sl)*phi_l = 0.\n    # This seems to be the intended system. Let's code this.\n\n    A = np.zeros((n_vars, n_vars), dtype=np.complex128)\n    b = np.zeros(n_vars, dtype=np.complex128)\n    b[0] = Q0\n    \n    # l = 0\n    Sigma_s0_val = Sigma_s0 * (g**0)\n    A[0,0] = Sigma_t - Sigma_s0_val\n    if N > 0:\n        A[0,1] = 1j * k\n    \n    # 1 = l = N-1\n    for l in range(1, N):\n        Sigma_sl_val = Sigma_s0 * (g**l)\n        A[l,l-1] = 1j * k * l\n        A[l,l] = (2*l+1) * (Sigma_t - Sigma_sl_val)\n        A[l,l+1] = 1j * k * (l+1)\n\n    # l = N\n    if N > 0:\n        Sigma_sN_val = Sigma_s0 * (g**N)\n        A[N,N-1] = 1j * k * N\n        A[N,N] = (2*N+1) * (Sigma_t - Sigma_sN_val)\n\n    # Solve the linear system A * phi_hat = b\n    phi_hat = np.linalg.solve(A, b)\n    return phi_hat\n\ndef solve_for_all_cases():\n    \"\"\"\n    Main function to run the numerical experiment as specified in the problem.\n    \"\"\"\n    test_cases = [\n        # Case A: general forward-peaked\n        (1.0, 0.9, 0.9, 0.5, 1.0),\n        # Case B: diffusion-like k -> 0\n        (1.0, 0.9, 0.9, 1e-3, 1.0),\n        # Case C: extreme forward-peaked and higher spatial frequency\n        (1.0, 0.95, 0.99, 2.0, 1.0),\n        # Case D: isotropic scattering control\n        (1.0, 0.9, 0.0, 0.5, 1.0),\n        # Case E: increased absorption\n        (1.0, 0.3, 0.9, 0.5, 1.0),\n    ]\n\n    N_orders = [1, 3, 7]\n    N_ref = 31\n    \n    all_results = []\n\n    for params in test_cases:\n        Sigma_t, c, g, k, Q0 = params\n\n        phi_hat_ref = solve_pn(N_ref, *params)\n        phi0_ref = phi_hat_ref[0]\n        phi1_ref = phi_hat_ref[1] if N_ref >= 1 else 0.0 + 0.0j\n\n        phi0_ref_mag = np.abs(phi0_ref) if np.abs(phi0_ref) > 0 else 1.0\n        phi1_ref_mag = np.abs(phi1_ref) if np.abs(phi1_ref) > 0 else 1.0\n\n        for N in N_orders:\n            phi_hat_N = solve_pn(N, *params)\n            phi0_N = phi_hat_N[0]\n            phi1_N = phi_hat_N[1] if N >= 1 else 0.0 + 0.0j\n\n            err_phi0 = np.abs(phi0_N - phi0_ref) / phi0_ref_mag\n            err_phi1 = np.abs(phi1_N - phi1_ref) / phi1_ref_mag\n            \n            all_results.append(err_phi0)\n            all_results.append(err_phi1)\n\n    print(f\"[{','.join(f'{x:.8e}' for x in all_results)}]\")\n\nsolve_for_all_cases()\n```"
        }
    ]
}