{
    "hands_on_practices": [
        {
            "introduction": "The foundation of matrix-based neutron diffusion methods lies in correctly translating physical cross-section data into discrete operators. This first exercise focuses on the scattering matrix, $S$, which governs how neutrons change energy. You will practice assembling this matrix from tabulated data and then analyze a key property—strict substochasticity—which provides a sufficient condition for the convergence of simple source iteration schemes . This connection between physical data, matrix properties, and numerical performance is a cornerstone of computational reactor physics.",
            "id": "4234944",
            "problem": "Consider a homogeneous, non-fissioning medium modeled by the steady-state multigroup diffusion balance for a flux vector $\\boldsymbol{\\phi} = (\\phi_{1}, \\phi_{2}, \\phi_{3})^{\\mathrm{T}}$ with energy groups $g \\in \\{1,2,3\\}$. The fundamental starting point is the multigroup diffusion balance for each group $g$,\n$$\n- \\nabla \\cdot \\left( D_{g} \\nabla \\phi_{g} \\right) + \\Sigma_{r,g} \\phi_{g} = \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g} \\, \\phi_{g'} ,\n$$\nwhere $D_{g}$ is the diffusion coefficient, $\\Sigma_{r,g}$ is the macroscopic removal cross section, and $\\Sigma_{s,g' \\to g}$ is the macroscopic scattering cross section from energy group $g'$ into energy group $g$. In a spatially homogenized single-degree-of-freedom setting (one unknown per energy group), the scattering source can be written as a $3 \\times 3$ matrix acting on $\\boldsymbol{\\phi}$,\n$$\n\\mathbf{S} \\boldsymbol{\\phi} = \\begin{pmatrix}\n\\Sigma_{s,1 \\to 1}  \\Sigma_{s,2 \\to 1}  \\Sigma_{s,3 \\to 1} \\\\\n\\Sigma_{s,1 \\to 2}  \\Sigma_{s,2 \\to 2}  \\Sigma_{s,3 \\to 2} \\\\\n\\Sigma_{s,1 \\to 3}  \\Sigma_{s,2 \\to 3}  \\Sigma_{s,3 \\to 3}\n\\end{pmatrix} \\begin{pmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ \\phi_{3} \\end{pmatrix},\n$$\nand the removal operator is the diagonal matrix $\\mathbf{R} = \\mathrm{diag}(\\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{r,3})$. In the context of source iteration for scattering-only systems, a sufficient condition for contraction in the induced infinity-norm is that the rows of $\\mathbf{R}^{-1}\\mathbf{S}$ sum to less than one, which corresponds to strict substochasticity of the scattering-to-removal mapping.\n\nYou are given the following tabulated macroscopic scattering cross sections $\\Sigma_{s,g' \\to g}$ (in inverse centimeters, $\\mathrm{cm}^{-1}$) and removal cross sections $\\Sigma_{r,g}$ (also in $\\mathrm{cm}^{-1}$) for $G=3$:\n- $\\Sigma_{s,1 \\to 1} = 0.20$, $\\Sigma_{s,1 \\to 2} = 0.05$, $\\Sigma_{s,1 \\to 3} = 0.00$,\n- $\\Sigma_{s,2 \\to 1} = 0.01$, $\\Sigma_{s,2 \\to 2} = 0.25$, $\\Sigma_{s,2 \\to 3} = 0.06$,\n- $\\Sigma_{s,3 \\to 1} = 0.00$, $\\Sigma_{s,3 \\to 2} = 0.02$, $\\Sigma_{s,3 \\to 3} = 0.30$,\n- $\\Sigma_{r,1} = 0.35$, $\\Sigma_{r,2} = 0.40$, $\\Sigma_{r,3} = 0.38$.\n\nTasks:\n1. Assemble the $3 \\times 3$ block structure of $\\mathbf{S}$ consistent with the multigroup mapping from $\\boldsymbol{\\phi}$ to the scattering source. Explain the interpretation of rows and columns in terms of in-scatter.\n2. Using the matrix viewpoint with $\\mathbf{R} = \\mathrm{diag}(\\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{r,3})$, identify the condition under which $\\mathbf{R}^{-1}\\mathbf{S}$ is strictly substochastic in the induced infinity-norm and express this condition in terms of the tabulated cross sections.\n3. Compute the strict substochasticity margin $\\delta$, defined as the largest non-negative number such that for every energy group $g$,\n$$\n\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g} \\leq (1 - \\delta)\\, \\Sigma_{r,g} .\n$$\nExpress your final answer for $\\delta$ as a dimensionless decimal rounded to four significant figures.",
            "solution": "The analysis of the problem proceeds in three steps as requested: assembling and interpreting the scattering matrix, deriving the condition for strict substochasticity, and computing the corresponding margin $\\delta$.\n\n**Task 1: Assemble and Interpret the Scattering Matrix $\\mathbf{S}$**\n\nThe steady-state multigroup diffusion equation for a given energy group $g$ is\n$$\n- \\nabla \\cdot \\left( D_{g} \\nabla \\phi_{g} \\right) + \\Sigma_{r,g} \\phi_{g} = \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g} \\, \\phi_{g'}\n$$\nIn a spatially homogenized context, the divergence term vanishes, and the balance becomes an algebraic system. The right-hand side, representing the source of neutrons scattering into group $g$ from all groups $g'$, can be written as a matrix-vector product. The scattering source vector is $\\mathbf{S}\\boldsymbol{\\phi}$, where the element of the source vector for group $g$ is $(\\mathbf{S}\\boldsymbol{\\phi})_g = \\sum_{g'=1}^{3} S_{g,g'} \\phi_{g'}$. Comparing this with the summation in the diffusion equation, we see that the element of the scattering matrix $\\mathbf{S}$ at row $g$ and column $g'$ must be $S_{g,g'} = \\Sigma_{s,g' \\to g}$.\n\nThe problem provides the matrix structure:\n$$\n\\mathbf{S} = \\begin{pmatrix}\n\\Sigma_{s,1 \\to 1}  \\Sigma_{s,2 \\to 1}  \\Sigma_{s,3 \\to 1} \\\\\n\\Sigma_{s,1 \\to 2}  \\Sigma_{s,2 \\to 2}  \\Sigma_{s,3 \\to 2} \\\\\n\\Sigma_{s,1 \\to 3}  \\Sigma_{s,2 \\to 3}  \\Sigma_{s,3 \\to 3}\n\\end{pmatrix}\n$$\nSubstituting the given numerical values (all in units of $\\mathrm{cm}^{-1}$):\n$$\n\\mathbf{S} = \\begin{pmatrix}\n0.20  0.01  0.00 \\\\\n0.05  0.25  0.02 \\\\\n0.00  0.06  0.30\n\\end{pmatrix}\n$$\nThe interpretation of the rows and columns of $\\mathbf{S}$ is as follows:\n- The element $S_{g,g'} = \\Sigma_{s,g' \\to g}$ represents the macroscopic cross section for a neutron scattering from a source group $g'$ to a destination group $g$.\n- The $g$-th row of $\\mathbf{S}$ contains the cross sections $\\{\\Sigma_{s,1 \\to g}, \\Sigma_{s,2 \\to g}, \\Sigma_{s,3 \\to g}\\}$. When multiplied by the flux vector $\\boldsymbol{\\phi}$, the sum $\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g} \\phi_{g'}$ gives the total rate density of neutrons scattering *into* group $g$. Therefore, each row of $\\mathbf{S}$ corresponds to the in-scatter cross sections for a particular destination group.\n- The $g'$-th column of $\\mathbf{S}$ contains the cross sections $\\{\\Sigma_{s,g' \\to 1}, \\Sigma_{s,g' \\to 2}, \\Sigma_{s,g' \\to 3}\\}$. These are the cross sections for a neutron in group $g'$ scattering *out* to any other group.\n\n**Task 2: Condition for Strict Substochasticity**\n\nThe source iteration method for the algebraic system $(\\mathbf{R} - \\mathbf{S})\\boldsymbol{\\phi} = \\boldsymbol{q}_{ext}$ (where $\\boldsymbol{q}_{ext}$ is an external source, zero in this homogeneous problem) is given by $\\mathbf{R}\\boldsymbol{\\phi}^{(k+1)} = \\mathbf{S}\\boldsymbol{\\phi}^{(k)} + \\boldsymbol{q}_{ext}$, or $\\boldsymbol{\\phi}^{(k+1)} = \\mathbf{R}^{-1}\\mathbf{S}\\boldsymbol{\\phi}^{(k)} + \\mathbf{R}^{-1}\\boldsymbol{q}_{ext}$. This iteration converges if the spectral radius of the iteration matrix $\\mathbf{M} = \\mathbf{R}^{-1}\\mathbf{S}$ is less than $1$. A sufficient condition for this is that any induced matrix norm is less than $1$.\n\nThe problem specifies the induced infinity-norm, $||\\mathbf{M}||_{\\infty}$, which is defined as the maximum absolute row sum of the matrix $\\mathbf{M}$. The condition for contraction is $||\\mathbf{M}||_{\\infty}  1$. A matrix with non-negative entries whose row sums are all less than $1$ is called strictly substochastic.\n\nThe matrices $\\mathbf{R}$ and $\\mathbf{S}$ are given. The removal matrix is $\\mathbf{R} = \\mathrm{diag}(\\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{r,3})$, so its inverse is $\\mathbf{R}^{-1} = \\mathrm{diag}(1/\\Sigma_{r,1}, 1/\\Sigma_{r,2}, 1/\\Sigma_{r,3})$.\nThe iteration matrix is:\n$$\n\\mathbf{M} = \\mathbf{R}^{-1}\\mathbf{S} = \\begin{pmatrix}\n\\frac{1}{\\Sigma_{r,1}}  0  0 \\\\\n0  \\frac{1}{\\Sigma_{r,2}}  0 \\\\\n0  0  \\frac{1}{\\Sigma_{r,3}}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Sigma_{s,1 \\to 1}  \\Sigma_{s,2 \\to 1}  \\Sigma_{s,3 \\to 1} \\\\\n\\Sigma_{s,1 \\to 2}  \\Sigma_{s,2 \\to 2}  \\Sigma_{s,3 \\to 2} \\\\\n\\Sigma_{s,1 \\to 3}  \\Sigma_{s,2 \\to 3}  \\Sigma_{s,3 \\to 3}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{\\Sigma_{s,1 \\to 1}}{\\Sigma_{r,1}}  \\frac{\\Sigma_{s,2 \\to 1}}{\\Sigma_{r,1}}  \\frac{\\Sigma_{s,3 \\to 1}}{\\Sigma_{r,1}} \\\\\n\\frac{\\Sigma_{s,1 \\to 2}}{\\Sigma_{r,2}}  \\frac{\\Sigma_{s,2 \\to 2}}{\\Sigma_{r,2}}  \\frac{\\Sigma_{s,3 \\to 2}}{\\Sigma_{r,2}} \\\\\n\\frac{\\Sigma_{s,1 \\to 3}}{\\Sigma_{r,3}}  \\frac{\\Sigma_{s,2 \\to 3}}{\\Sigma_{r,3}}  \\frac{\\Sigma_{s,3 \\to 3}}{\\Sigma_{r,3}}\n\\end{pmatrix}\n$$\nThe condition that $\\mathbf{M}$ is strictly substochastic is that for each row $g \\in \\{1, 2, 3\\}$, the sum of its elements is less than $1$. The sum of the elements in row $g$ is:\n$$\n\\sum_{g'=1}^{3} M_{g,g'} = \\sum_{g'=1}^{3} \\frac{\\Sigma_{s,g' \\to g}}{\\Sigma_{r,g}} = \\frac{1}{\\Sigma_{r,g}} \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}\n$$\nThus, the condition for strict substochasticity, expressed in terms of the tabulated cross sections, is that for each group $g$:\n$$\n\\frac{1}{\\Sigma_{r,g}} \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}  1 \\quad \\iff \\quad \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}  \\Sigma_{r,g}\n$$\nPhysically, this means that for each energy group, the total rate of in-scattering must be strictly less than the total rate of removal (absorption plus out-scattering).\n\n**Task 3: Compute the Strict Substochasticity Margin $\\delta$**\n\nThe margin $\\delta$ is defined as the largest non-negative number such that for every group $g$:\n$$\n\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g} \\leq (1 - \\delta) \\Sigma_{r,g}\n$$\nRearranging to solve for $\\delta$, assuming $\\Sigma_{r,g}  0$:\n$$\n\\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}}{\\Sigma_{r,g}} \\leq 1 - \\delta \\quad \\implies \\quad \\delta \\leq 1 - \\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}}{\\Sigma_{r,g}}\n$$\nThis inequality must hold for all $g \\in \\{1, 2, 3\\}$. To find the largest $\\delta$ that satisfies this system of inequalities, we must take the minimum value of the right-hand side over all $g$:\n$$\n\\delta = \\min_{g \\in \\{1,2,3\\}} \\left( 1 - \\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}}{\\Sigma_{r,g}} \\right)\n$$\nThis is equivalent to:\n$$\n\\delta = 1 - \\max_{g \\in \\{1,2,3\\}} \\left( \\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}}{\\Sigma_{r,g}} \\right)\n$$\nWe calculate the in-scattering cross section sum and the ratio for each group. Let $c_g = (\\sum_{g'=1}^{3} \\Sigma_{s,g' \\to g}) / \\Sigma_{r,g}$.\n\nFor group $g=1$:\n$$ \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to 1} = \\Sigma_{s,1 \\to 1} + \\Sigma_{s,2 \\to 1} + \\Sigma_{s,3 \\to 1} = 0.20 + 0.01 + 0.00 = 0.21 \\, \\mathrm{cm}^{-1} $$\n$$ c_1 = \\frac{0.21}{0.35} = 0.6 $$\n\nFor group $g=2$:\n$$ \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to 2} = \\Sigma_{s,1 \\to 2} + \\Sigma_{s,2 \\to 2} + \\Sigma_{s,3 \\to 2} = 0.05 + 0.25 + 0.02 = 0.32 \\, \\mathrm{cm}^{-1} $$\n$$ c_2 = \\frac{0.32}{0.40} = 0.8 $$\n\nFor group $g=3$:\n$$ \\sum_{g'=1}^{3} \\Sigma_{s,g' \\to 3} = \\Sigma_{s,1 \\to 3} + \\Sigma_{s,2 \\to 3} + \\Sigma_{s,3 \\to 3} = 0.00 + 0.06 + 0.30 = 0.36 \\, \\mathrm{cm}^{-1} $$\n$$ c_3 = \\frac{0.36}{0.38} = \\frac{36}{38} = \\frac{18}{19} $$\n\nThe maximum of these ratios is:\n$$ \\max\\{c_1, c_2, c_3\\} = \\max\\left\\{0.6, 0.8, \\frac{18}{19}\\right\\} = \\max\\left\\{0.6, 0.8, 0.947368...\\right\\} = \\frac{18}{19} $$\nThe strict substochasticity margin $\\delta$ is then:\n$$ \\delta = 1 - \\frac{18}{19} = \\frac{1}{19} $$\nConverting to a decimal and rounding to four significant figures:\n$$ \\delta \\approx 0.05263157... \\approx 0.05263 $$\nThis value is dimensionless, as it is the ratio of cross sections.",
            "answer": "$$\n\\boxed{0.05263}\n$$"
        },
        {
            "introduction": "Real-world reactor problems involve both energy and spatial dimensions. Building on the assembly of individual operators, this practice guides you through the construction of the complete, global system matrix for a two-dimensional, two-group diffusion problem . You will implement a finite-difference stencil to model neutron leakage and combine it with scattering operators into a larger block-matrix structure, gaining essential hands-on experience in the core logic of a diffusion code.",
            "id": "4234989",
            "problem": "You are tasked with deriving, assembling, and analyzing the global block matrix for the Neutron Multigroup Diffusion (MGD) equations in two energy groups on a two-dimensional uniform Cartesian mesh. The goal is to construct the global block matrix $A = L - S$ that results from a nearest-neighbor finite difference discretization and to provide its sparsity pattern information. You must produce a complete, runnable program that builds this matrix for a specified test suite and outputs quantitative descriptors of the sparsity pattern.\n\nBegin from the following fundamental base. The steady-state two-group diffusion model in a heterogeneous but piecewise-constant material region is given by the coupled Partial Differential Equations (PDEs)\n$$\n-\\nabla \\cdot \\left(D_1(\\mathbf{r}) \\nabla \\phi_1(\\mathbf{r})\\right) + \\Sigma_{r,1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) = \\Sigma_{s,1\\to 1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 1}(\\mathbf{r}) \\phi_2(\\mathbf{r}),\n$$\n$$\n-\\nabla \\cdot \\left(D_2(\\mathbf{r}) \\nabla \\phi_2(\\mathbf{r})\\right) + \\Sigma_{r,2}(\\mathbf{r}) \\phi_2(\\mathbf{r}) = \\Sigma_{s,1\\to 2}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 2}(\\mathbf{r}) \\phi_2(\\mathbf{r}),\n$$\nwhere $D_g(\\mathbf{r})$ is the diffusion coefficient for group $g$, $\\Sigma_{r,g}(\\mathbf{r})$ is the removal cross section, and $\\Sigma_{s,g'\\to g}(\\mathbf{r})$ is the scattering cross section from group $g'$ into group $g$. The unknowns are the scalar fluxes $\\phi_g(\\mathbf{r})$ for $g \\in \\{1,2\\}$. Assume each coefficient is spatially uniform within each cell of a uniform mesh.\n\nDiscretize the spatial operator with a standard five-point Finite Difference (FD) stencil on a rectangular grid of size $N_x \\times N_y$ with unit cell width (you may treat the grid spacing as $h=1$ without units). Enforce a Dirichlet boundary condition where any neighbor that would lie outside the domain is simply omitted from the stencil. Let $N = N_x N_y$ be the number of spatial cells. Use group-major ordering for the unknown vector: list all $N$ unknowns of group 1$, followed by all $N$ of group $2$. With this ordering, the global block matrix $A$ is a $2N \\times 2N$ matrix composed of four $N \\times N$ sub-blocks,\n$$\nA = \\begin{pmatrix}\nA_{11}  A_{12} \\\\\nA_{21}  A_{22}\n\\end{pmatrix},\n\\quad\nA_{11} = L_{11} - S_{11},\\quad\nA_{22} = L_{22} - S_{22},\\quad\nA_{12} = -S_{12},\\quad\nA_{21} = -S_{21}.\n$$\nHere $L_{gg}$ is the within-group leakage-plus-removal discrete operator produced by the five-point FD stencil (with $D_g$ on each edge and $\\Sigma_{r,g}$ on the diagonal), and $S_{g g'}$ is the scattering operator from group $g'$ into group $g$. In the discrete setting, the scattering operator is cell-local in space, so each $S_{g g'}$ is diagonal in the spatial index when expressed on the same mesh.\n\nYour program must assemble $A$ and, for each test case, report quantitative sparsity information that captures both the energy-group block structure and the spatial adjacency in the leakage operator. Specifically, for each test case, compute and output the following items as a single list:\n1. The nonzero counts of each energy-group block of $A$: $[\\mathrm{nnz}(A_{11}), \\mathrm{nnz}(A_{12}), \\mathrm{nnz}(A_{21}), \\mathrm{nnz}(A_{22})]$, using a numerical threshold of $10^{-12}$ to treat entries as zero.\n2. Two boolean indicators of whether the off-diagonal energy-group blocks are diagonal in space: $[\\mathrm{isdiag}(A_{12}), \\mathrm{isdiag}(A_{21})]$, where each is true if all nonzeros in that block lie on its spatial diagonal and false otherwise (a block with no nonzeros is considered diagonal).\n3. The sorted unique list of row nonzero counts in the leakage blocks $L_{11}$ and $L_{22}$, each computed with the same threshold $10^{-12}$: $[\\mathrm{degrees}(L_{11}), \\mathrm{degrees}(L_{22})]$. Each list reports the distinct counts of nonzeros per row that arise solely from the five-point stencil structure with Dirichlet boundaries and removal diagonal terms.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s result presented as a nested list in the same order as above.\n\nTest Suite:\nUse the following three test cases, each defined by $(N_x, N_y, D_1, D_2, \\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{s,1\\to 1}, \\Sigma_{s,2\\to 2}, \\Sigma_{s,1\\to 2}, \\Sigma_{s,2\\to 1})$, with all quantities treated as dimensionless positive reals for the purposes of assembly and analysis:\n- Case 1 (two-dimensional mesh, downscatter only): $(2, 2, 1.0, 0.8, 0.2, 0.1, 0.0, 0.0, 0.05, 0.0)$.\n- Case 2 (one-dimensional line embedded in two-dimensional indexing, both intra- and inter-group scattering): $(3, 1, 0.5, 0.5, 0.3, 0.3, 0.1, 0.2, 0.05, 0.02)$.\n- Case 3 (single-cell edge case, downscatter only): $(1, 1, 1.2, 1.2, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of three nested lists, one for each test case, in the exact order given above. For each test case, the nested list must contain, in order:\n- The list $[\\mathrm{nnz}(A_{11}), \\mathrm{nnz}(A_{12}), \\mathrm{nnz}(A_{21}), \\mathrm{nnz}(A_{22})]$,\n- The list $[\\mathrm{isdiag}(A_{12}), \\mathrm{isdiag}(A_{21})]$,\n- The list $\\mathrm{degrees}(L_{11})$,\n- The list $\\mathrm{degrees}(L_{22})$.\n\nAs an example of the formatting, if there were two test cases with results $r_1$ and $r_2$, then the single line printed would be in the form: $[r_1,r_2]$. You must not print any additional text.",
            "solution": "The user has provided a problem concerning the assembly and analysis of the global matrix for the two-group neutron diffusion equations on a 2D Cartesian mesh.\n\n### Problem Validation\n\nI will first validate the problem statement according to the specified criteria.\n\n#### Step 1: Extract Givens\n\n*   **Governing Equations**: The steady-state two-group diffusion equations are given as:\n    $$-\\nabla \\cdot \\left(D_1(\\mathbf{r}) \\nabla \\phi_1(\\mathbf{r})\\right) + \\Sigma_{r,1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) = \\Sigma_{s,1\\to 1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 1}(\\mathbf{r}) \\phi_2(\\mathbf{r})$$\n    $$-\\nabla \\cdot \\left(D_2(\\mathbf{r}) \\nabla \\phi_2(\\mathbf{r})\\right) + \\Sigma_{r,2}(\\mathbf{r}) \\phi_2(\\mathbf{r}) = \\Sigma_{s,1\\to 2}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 2}(\\mathbf{r}) \\phi_2(\\mathbf{r})$$\n*   **Physical Parameters**: $D_g$ (diffusion coefficient), $\\Sigma_{r,g}$ (removal cross section), $\\Sigma_{s,g'\\to g}$ (scattering cross section). These are assumed to be piecewise-constant and uniform for each test case.\n*   **Discretization**:\n    *   Method: Five-point Finite Difference (FD) stencil.\n    *   Grid: Uniform Cartesian mesh of size $N_x \\times N_y$ cells.\n    *   Grid Spacing: $h=1$.\n    *   Boundary Conditions: Dirichlet, implemented by omitting any neighbor that lies outside the domain.\n*   **Matrix System**:\n    *   Unknowns Ordering: Group-major, where all $N = N_x N_y$ spatial unknowns for group 1 are listed, followed by all $N$ unknowns for group 2.\n    *   Global Matrix: $A = L-S$, a $2N \\times 2N$ matrix with a $2 \\times 2$ block structure.\n    $$A = \\begin{pmatrix} A_{11}  A_{12} \\\\ A_{21}  A_{22} \\end{pmatrix}$$\n    *   Block Definitions:\n        *   $A_{11} = L_{11} - S_{11}$\n        *   $A_{22} = L_{22} - S_{22}$\n        *   $A_{12} = -S_{12}$\n        *   $A_{21} = -S_{21}$\n        *   $L_{gg}$: Leakage-plus-removal operator for group $g$.\n        *   $S_{gg'}$: Scattering operator from group $g'$ to $g$, noted to be spatially cell-local (diagonal).\n*   **Analysis Task**: For each test case, compute and output:\n    1.  Nonzero counts for each block: $[\\mathrm{nnz}(A_{11}), \\mathrm{nnz}(A_{12}), \\mathrm{nnz}(A_{21}), \\mathrm{nnz}(A_{22})]$ with a tolerance of $10^{-12}$.\n    2.  Diagonality indicators for off-diagonal blocks: $[\\mathrm{isdiag}(A_{12}), \\mathrm{isdiag}(A_{21})]$.\n    3.  Sorted unique row nonzero counts for leakage blocks: $[\\mathrm{degrees}(L_{11}), \\mathrm{degrees}(L_{22})]$.\n*   **Test Suite**: Three cases are provided with specific values for $(N_x, N_y, D_1, D_2, \\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{s,1\\to 1}, \\Sigma_{s,2\\to 2}, \\Sigma_{s,1\\to 2}, \\Sigma_{s,2\\to 1})$.\n\n#### Step 2: Validate Using Extracted Givens\n\n1.  **Scientific or Factual Unsoundness**: The problem is founded on the multigroup diffusion approximation, a standard and well-established model in nuclear reactor physics. The use of finite differences for discretization is also a fundamental numerical technique. The problem formulation is scientifically and mathematically sound.\n2.  **Non-Formalizable or Irrelevant**: The problem is concrete, well-defined, and requires the implementation of a specific numerical algorithm. It is directly relevant to the simulation of nuclear reactors.\n3.  **Incomplete or Contradictory Setup**: The problem provides all necessary information: the governing equations, discretization method, boundary conditions, matrix ordering, and all physical parameters for the test cases. The definitions of the matrix blocks are consistent with the rearrangement of the governing equations into matrix form. For example, the term $\\Sigma_{s,2\\to 1} \\phi_2$ on the right-hand side of the group 1 equation moves to the left, contributing $-\\Sigma_{s,2\\to 1}\\phi_2$. This corresponds to the matrix block $A_{12}$ acting on the $\\phi_2$ vector. The definition $A_{12} = -S_{12}$ where $S_{12}$ represents scattering from group 2 to 1 (associated with $\\Sigma_{s,2\\to 1}$) is consistent.\n4.  **Unrealistic or Infeasible**: The provided parameters are positive real numbers, which is physically reasonable. The problem simplification (e.g., $h=1$, uniform material properties) is common in academic exercises and does not render the problem physically impossible or inconsistent.\n5.  **Ill-Posed or Poorly Structured**: The task is to assemble a matrix and analyze its structure, not to solve the linear system. This is a well-defined computational task. The use of \"Dirichlet boundary condition\" to mean omitting stencil points is a slightly non-standard but clearly specified instruction for implementation. It is unambiguous in its context.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem requires understanding of PDE discretization, sparse matrix data structures, and careful implementation of indexing and assembly logic. It is a substantive and non-trivial exercise in scientific computing.\n7.  **Outside Scientific Verifiability**: The results of the matrix assembly are algorithmically determined and can be independently reproduced and verified.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is valid. It is scientifically grounded, well-posed, and complete. I will now proceed to provide the solution.\n\n### Solution\n\nThe solution involves constructing the constituent blocks of the global matrix $A$ for a two-group neutron diffusion problem and analyzing their sparsity patterns. The process can be broken down into three main stages: construction of the leakage-plus-removal operators ($L_{gg}$), construction of the scattering operators ($S_{gg'}$), and finally, assembly of the blocks of $A$ and subsequent analysis.\n\n#### 1. Discretization and The Leakage-Plus-Removal Operator ($L_{gg}$)\n\nThe operator $L_{gg}$ represents the discrete form of $-\\nabla \\cdot (D_g \\nabla \\phi_g) + \\Sigma_{r,g} \\phi_g$. We use a five-point finite difference stencil on a uniform Cartesian grid of size $N_x \\times N_y$ with spacing $h=1$. The cells are indexed by a single global index $k \\in \\{0, 1, ..., N-1\\}$, where $N = N_x N_y$. A common mapping from 2D coordinates $(i, j)$ (with $0 \\le i  N_x$, $0 \\le j  N_y$) to the global index $k$ is row-major: $k = i + j \\cdot N_x$.\n\nFor a constant diffusion coefficient $D_g$, the continuous leakage operator at a point $(x,y)$ is $-D_g \\nabla^2 \\phi_g = -D_g (\\frac{\\partial^2\\phi_g}{\\partial x^2} + \\frac{\\partial^2\\phi_g}{\\partial y^2})$. Applying central differences with $h=1$, the discrete operator acting on the flux at cell $k$ (with coordinates $(i,j)$) is:\n$$ -D_g (\\phi_{g,i+1,j} - 2\\phi_{g,i,j} + \\phi_{g,i-1,j} + \\phi_{g,i,j+1} - 2\\phi_{g,i,j} + \\phi_g{,i,j-1}) = D_g(4\\phi_{g,k} - \\phi_{g,k_{R}} - \\phi_{g,k_{L}} - \\phi_{g,k_{T}} - \\phi_{g,k_{B}})$$\nwhere $k_R, k_L, k_T, k_B$ are the global indices of the right, left, top, and bottom neighbors, respectively.\n\nThe problem specifies that for cells near the boundary, any neighbor lying outside the domain is omitted from the stencil. This means the sum of neighbor contributions only includes existing neighbors, and the coefficient of the central term $\\phi_{g,k}$ scales with the number of actual neighbors, denoted $c_k$.\n\nCombining the discrete leakage operator with the removal term $\\Sigma_{r,g}\\phi_{g,k}$, the full expression for row $k$ of the operator $L_{gg}$ is:\n$$(L_{gg} \\boldsymbol{\\phi}_g)_k = (c_k D_g + \\Sigma_{r,g}) \\phi_{g,k} - \\sum_{k' \\in \\text{neighbors}(k)} D_g \\phi_{g,k'}$$\nFrom this, we deduce the entries of the matrix $L_{gg}$:\n*   Diagonal entry: $(L_{gg})_{k,k} = c_k D_g + \\Sigma_{r,g}$\n*   Off-diagonal entry: $(L_{gg})_{k,k'} = -D_g$ if cell $k'$ is a neighbor of cell $k$.\n*   All other entries are $0$.\nThe number of neighbors $c_k$ can be $2$ (for a corner cell, if $N_x, N_y > 1$), $3$ (for an edge cell, not corner), or $4$ (for an interior cell). For 1D-like cases ($N_x=1$ or $N_y=1$), $c_k$ can be $0$, $1$, or $2$.\n\n#### 2. The Scattering Operator ($S_{gg'}$)\n\nThe scattering operators $S_{gg'}$ represent the transfer of neutrons from energy group $g'$ to group $g$. The problem states these are \"cell-local in space,\" which means the scattering process at a spatial location only depends on the fluxes at that same location. Consequently, the matrices $S_{gg'}$ are diagonal in the spatial indices. For the uniform material properties given in each test case, the scattering matrix from group $g'$ to $g$ is simply a scaled identity matrix:\n$$S_{gg'} = \\Sigma_{s,g' \\to g} \\cdot I_N$$\nwhere $I_N$ is the $N \\times N$ identity matrix. Note the convention: $S_{12}$ corresponds to scattering from group 2 into group 1, so it is built using $\\Sigma_{s,2 \\to 1}$.\n\n#### 3. Assembly and Analysis\n\nWith the $L_{gg}$ and $S_{gg'}$ matrices defined, the four blocks of the system matrix $A$ are assembled as follows:\n*   $A_{11} = L_{11} - S_{11}$\n*   $A_{22} = L_{22} - S_{22}$\n*   $A_{12} = -S_{12}$\n*   $A_{21} = -S_{21}$\n\nThese operations are performed using sparse matrix arithmetic. The final step is to analyze these four blocks according to the problem requirements:\n1.  **Nonzero Counts**: For each block $A_{gg'}$, elements with an absolute value below $10^{-12}$ are treated as zero. The number of remaining non-zero elements is then counted.\n2.  **Diagonality Check**: For the off-diagonal blocks $A_{12}$ and $A_{21}$, we check if all non-zero elements lie on the main diagonal. An all-zero matrix is considered diagonal per the problem statement.\n3.  **Leakage Block Degrees**: For each leakage block $L_{gg}$, we first filter out near-zero values. Then, for each row, we count the number of non-zero entries. The final result for each block is the sorted list of unique values found among these row counts. This reflects the different connectivity patterns of cells in the grid (e.g., corner, edge, interior).\n\nThe implementation will systematically apply this logic to each test case provided. We will use `scipy.sparse` matrices, specifically `lil_matrix` for construction due to its efficient element-wise updates, and `csr_matrix` for analysis due to its efficient row-based operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, diags, csr_matrix\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through each test case, builds the matrices,\n    performs the analysis, and prints the results in the specified format.\n    \"\"\"\n    # Test Suite:\n    # (Nx, Ny, D1, D2, Sigma_r1, Sigma_r2, Sigma_s11, Sigma_s22, Sigma_s12, Sigma_s21)\n    # The problem text labels scatter as g' - g, but the test case tuple appears\n    # consistent with indexing (e.g. s12 is scatter 1-2). We map accordingly.\n    test_cases = [\n        # Case 1: 2x2 grid, downscatter only\n        (2, 2, 1.0, 0.8, 0.2, 0.1, 0.0, 0.0, 0.05, 0.0),\n        # Case 2: 3x1 grid, full scattering\n        (3, 1, 0.5, 0.5, 0.3, 0.3, 0.1, 0.2, 0.05, 0.02),\n        # Case 3: 1x1 grid, downscatter only\n        (1, 1, 1.2, 1.2, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # str() converts lists and booleans to the required string representation.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\ndef analyze_case(case_params):\n    \"\"\"\n    Analyzes a single test case: builds matrices and computes sparsity metrics.\n    \n    Args:\n        case_params (tuple): A tuple containing all parameters for the test case.\n        \n    Returns:\n        list: A nested list containing the four required analysis results.\n    \"\"\"\n    (Nx, Ny, D1, D2, Sr1, Sr2, Ss11, Ss22, Ss12, Ss21) = case_params\n    N = Nx * Ny\n    \n    # 1. Build Leakage-plus-Removal matrices L_gg\n    L11 = build_leakage_operator(Nx, Ny, D1, Sr1)\n    L22 = build_leakage_operator(Nx, Ny, D2, Sr2)\n\n    # 2. Build Scattering matrices S_gg'\n    # S_gg' is scattering from g' to g.\n    # In notation S_12, g=1, g'=2, representing scatter from 2 - 1.\n    S11 = diags([Ss11], [0], shape=(N, N), format='csr')\n    S22 = diags([Ss22], [0], shape=(N, N), format='csr')\n    S12 = diags([Ss21], [0], shape=(N, N), format='csr') # 2 - 1\n    S21 = diags([Ss12], [0], shape=(N, N), format='csr') # 1 - 2\n\n    # 3. Assemble final block matrices A_gg'\n    A11 = L11 - S11\n    A22 = L22 - S22\n    A12 = -S12\n    A21 = -S21\n\n    # 4. Perform analysis\n    \n    # Item 1: Nonzero counts\n    nnz_A11 = count_nnz(A11)\n    nnz_A12 = count_nnz(A12)\n    nnz_A21 = count_nnz(A21)\n    nnz_A22 = count_nnz(A22)\n    nnz_counts = [nnz_A11, nnz_A12, nnz_A21, nnz_A22]\n    \n    # Item 2: Diagonality check\n    isdiag_A12 = is_diagonal(A12)\n    isdiag_A21 = is_diagonal(A21)\n    diag_indicators = [isdiag_A12, isdiag_A21]\n    \n    # Item 3: Degrees of leakage blocks\n    degrees_L11 = get_degrees(L11)\n    degrees_L22 = get_degrees(L22)\n    \n    return [nnz_counts, diag_indicators, degrees_L11, degrees_L22]\n\ndef build_leakage_operator(Nx, Ny, D, Sigma_r):\n    \"\"\"\n    Constructs the leakage-plus-removal operator L for a single energy group.\n    \n    Args:\n        Nx (int): Number of cells in the x-direction.\n        Ny (int): Number of cells in the y-direction.\n        D (float): Diffusion coefficient.\n        Sigma_r (float): Removal cross section.\n        \n    Returns:\n        scipy.sparse.csr_matrix: The assembled L matrix.\n    \"\"\"\n    N = Nx * Ny\n    if N == 0:\n        return csr_matrix((0, 0))\n    \n    # Use LIL format for efficient construction\n    mat = lil_matrix((N, N), dtype=np.float64)\n    \n    for k in range(N):\n        i = k % Nx\n        j = k // Nx\n        \n        num_neighbors = 0\n        \n        # Left neighbor\n        if i > 0:\n            k_neighbor = (i - 1) + j * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n        # Right neighbor\n        if i  Nx - 1:\n            k_neighbor = (i + 1) + j * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n        # Bottom neighbor\n        if j > 0:\n            k_neighbor = i + (j - 1) * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n        # Top neighbor\n        if j  Ny - 1:\n            k_neighbor = i + (j + 1) * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n            \n        # Diagonal entry\n        mat[k, k] = num_neighbors * D + Sigma_r\n        \n    return mat.tocsr()\n\ndef apply_threshold(mat, threshold=1e-12):\n    \"\"\"\n    Explicitly zeros out elements of a sparse matrix below a threshold.\n    This function modifies the matrix in place.\n    \"\"\"\n    if mat.nnz > 0:\n        mat.data[np.abs(mat.data)  threshold] = 0.0\n        mat.eliminate_zeros()\n\ndef count_nnz(mat, threshold=1e-12):\n    \"\"\"Counts non-zeros in a matrix after applying a tolerance.\"\"\"\n    mat_copy = mat.copy()\n    apply_threshold(mat_copy, threshold)\n    return mat_copy.nnz\n\ndef is_diagonal(mat, threshold=1e-12):\n    \"\"\"Checks if a sparse matrix is diagonal.\"\"\"\n    mat_copy = mat.copy()\n    apply_threshold(mat_copy, threshold)\n    \n    # A matrix is diagonal if all its non-zero elements have row_idx == col_idx\n    # This correctly handles the all-zero matrix case, as nonzero() returns empty tuples.\n    rows, cols = mat_copy.nonzero()\n    return np.all(rows == cols)\n\ndef get_degrees(mat, threshold=1e-12):\n    \"\"\"\n    Computes the sorted list of unique row-wise non-zero counts (degrees).\n    \"\"\"\n    mat_copy = mat.copy().tocsr()\n    apply_threshold(mat_copy, threshold)\n    \n    # For a CSR matrix, the difference of the indptr array gives nnz per row.\n    row_nnz = np.diff(mat_copy.indptr)\n    unique_degrees = np.unique(row_nnz)\n    return unique_degrees.tolist()\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The elegance of the matrix formulation extends beyond problem setup to diagnostics and analysis. The convergence rate of iterative solvers is governed by the spectral radius of the iteration matrix, a value we can compute and study. This exercise explores the profound impact of upscattering—neutrons gaining energy in collisions—on the convergence of the classical source iteration method . By calculating the spectral radius in different physical regimes, you will see why this phenomenon can make simple solvers impractical and why advanced preconditioning methods are often necessary.",
            "id": "4235000",
            "problem": "Consider the steady-state multigroup neutron diffusion balance in a single homogeneous spatial cell with three energy groups. The algebraic form of the balance for group $g \\in \\{1,2,3\\}$ is given by\n$$\n\\left(\\Sigma_{r,g} + D_g B^2\\right)\\,\\phi_g \\;=\\; \\sum_{g' \\neq g} \\Sigma_{s,\\,g \\leftarrow g'}\\,\\phi_{g'} \\;+\\; Q_g,\n$$\nwhere $D_g$ is the diffusion coefficient (in meters), $B^2$ is the geometric buckling (in inverse square meters), $\\Sigma_{r,g}$ is the removal macroscopic cross section (in inverse meters), $\\Sigma_{s,\\,g \\leftarrow g'}$ is the scattering macroscopic cross section from group $g'$ into group $g$ (in inverse meters), and $Q_g$ is an external source (in inverse meters). Define the diagonal matrix\n$$\nA \\;=\\; \\mathrm{diag}\\!\\left(\\Sigma_{r,1}+D_1 B^2,\\; \\Sigma_{r,2}+D_2 B^2,\\; \\Sigma_{r,3}+D_3 B^2\\right),\n$$\nand the off-diagonal scattering matrix $S$ with entries $S_{g,g'} = \\Sigma_{s,\\,g \\leftarrow g'}$ for $g \\neq g'$ and $S_{g,g} = 0$. The classical source iteration update can be written as\n$$\n\\boldsymbol{\\phi}^{(k+1)} \\;=\\; A^{-1} S \\,\\boldsymbol{\\phi}^{(k)} \\;+\\; A^{-1} \\boldsymbol{Q}.\n$$\nThe convergence rate of source iteration is governed by the spectral radius\n$$\n\\rho\\!\\left(A^{-1} S\\right) \\;=\\; \\max_i \\left|\\lambda_i\\!\\left(A^{-1} S\\right)\\right|,\n$$\nwhere $\\lambda_i(\\cdot)$ denotes the eigenvalues of the matrix argument.\n\nYour task is to write a complete, runnable program that computes the spectral radius $\\rho\\!\\left(A^{-1} S\\right)$ for each of the following four test cases. Each test case specifies the diffusion coefficients, geometric buckling, removal cross sections, and scattering matrix. All diffusion coefficients $D_g$ are given in meters, all cross sections ($\\Sigma_{r,g}$ and all entries of $S$) are given in inverse meters, and $B^2$ is given in inverse square meters. The spectral radius is dimensionless and must be reported as a float rounded to six decimal places.\n\nTest case 1 (no upscatter, strictly downscatter):\n- $D = [1.0,\\;0.8,\\;0.6]$ meters\n- $B^2 = 0.01$ inverse square meters\n- $\\Sigma_r = [0.4,\\;0.25,\\;0.15]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.0  0.0 \\\\\n0.14  0.0  0.0 \\\\\n0.03  0.09  0.0\n\\end{bmatrix}$ inverse meters\n\nTest case 2 (mild upscatter):\n- $D = [1.0,\\;0.8,\\;0.6]$ meters\n- $B^2 = 0.01$ inverse square meters\n- $\\Sigma_r = [0.4,\\;0.25,\\;0.15]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.01  0.005 \\\\\n0.14  0.0  0.02 \\\\\n0.03  0.09  0.0\n\\end{bmatrix}$ inverse meters\n\nTest case 3 (strong upscatter):\n- $D = [1.0,\\;0.8,\\;0.6]$ meters\n- $B^2 = 0.01$ inverse square meters\n- $\\Sigma_r = [0.4,\\;0.25,\\;0.15]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.06  0.03 \\\\\n0.16  0.0  0.07 \\\\\n0.035  0.10  0.0\n\\end{bmatrix}$ inverse meters\n\nTest case 4 (near a challenging regime with significant upscatter and reduced leakage/removal):\n- $D = [1.4,\\;1.1,\\;0.7]$ meters\n- $B^2 = 0.003$ inverse square meters\n- $\\Sigma_r = [0.22,\\;0.16,\\;0.10]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.07  0.035 \\\\\n0.10  0.0  0.05 \\\\\n0.03  0.07  0.0\n\\end{bmatrix}$ inverse meters\n\nProgram requirements:\n- For each test case, construct $A$ and $S$, form $M = A^{-1} S$, and compute $\\rho(M)$ as the maximum absolute value of the eigenvalues of $M$.\n- Express each spectral radius as a float rounded to six decimal places (dimensionless).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), where $r_i$ corresponds to the spectral radius for test case $i$ in the order listed.\n\nAdditionally, in your solution, explain from first principles why upscattering modifies the matrix structure in a way that increases $\\rho\\!\\left(A^{-1}S\\right)$ and why a preconditioning strategy that treats the upscatter implicitly can be necessary to restore rapid convergence when $\\rho\\!\\left(A^{-1}S\\right)$ approaches one. No physical angles are involved in this problem, so no angle unit specification is needed.",
            "solution": "The problem asks for the computation of the spectral radius of the source iteration matrix for the multigroup neutron diffusion equation under various scattering conditions, and for a theoretical explanation of the impact of upscattering on convergence.\n\nThe steady-state multigroup diffusion equation for a homogeneous medium can be written in matrix form. For a vector of group fluxes $\\boldsymbol{\\phi} = [\\phi_1, \\phi_2, \\dots, \\phi_G]^T$ and an external source vector $\\boldsymbol{Q} = [Q_1, Q_2, \\dots, Q_G]^T$, the balance equation is:\n$$\n(L+R)\\boldsymbol{\\phi} = S\\boldsymbol{\\phi} + \\boldsymbol{Q}\n$$\nHere, $L$ is a matrix representing neutron loss due to leakage, and $R$ is a matrix representing neutron loss due to removal (absorption and out-of-group scattering). $S$ is the in-scattering matrix. In this problem, the total loss operator is given by the diagonal matrix $A$, where its diagonal elements are $A_{gg} = \\Sigma_{r,g} + D_g B^2$. This term combines removal within group $g$, characterized by the macroscopic removal cross section $\\Sigma_{r,g}$, and leakage out of the spatial domain for group $g$, approximated by $D_g B^2$. Thus, $A \\equiv L+R$. The matrix $S$ contains the off-diagonal scattering cross sections $\\Sigma_{s, g \\leftarrow g'}$ which represent neutrons scattering from group $g'$ into group $g$. The problem can be compactly expressed as:\n$$\nA\\boldsymbol{\\phi} = S\\boldsymbol{\\phi} + \\boldsymbol{Q}\n$$\nThe classical source iteration method solves this system by treating the entire scattering source term $S\\boldsymbol{\\phi}$ explicitly. Given an estimate of the flux vector from the previous iteration, $\\boldsymbol{\\phi}^{(k)}$, the next estimate $\\boldsymbol{\\phi}^{(k+1)}$ is found by solving:\n$$\nA\\boldsymbol{\\phi}^{(k+1)} = S\\boldsymbol{\\phi}^{(k)} + \\boldsymbol{Q}\n$$\nSince $A$ is a diagonal matrix, its inverse $A^{-1}$ is trivial to compute (it is a diagonal matrix whose elements are the reciprocals of the elements of $A$). The iteration can thus be written as:\n$$\n\\boldsymbol{\\phi}^{(k+1)} = A^{-1}S\\boldsymbol{\\phi}^{(k)} + A^{-1}\\boldsymbol{Q}\n$$\nThis is a fixed-point iteration of the form $\\boldsymbol{x}^{(k+1)} = M\\boldsymbol{x}^{(k)} + \\boldsymbol{c}$, where the iteration matrix is $M = A^{-1}S$. The convergence of such an iteration is guaranteed if the spectral radius of the iteration matrix, $\\rho(M)$, is less than $1$. The asymptotic rate of convergence is determined by $\\rho(M)$; the closer $\\rho(M)$ is to $1$, the slower the convergence. The spectral radius is defined as the maximum absolute value of the eigenvalues of the matrix: $\\rho(M) = \\max_i |\\lambda_i(M)|$.\n\nLet us analyze the structure of the iteration matrix $M$ and its dependence on scattering properties. By convention, energy groups are indexed from higher energy to lower energy (group $1$ is the fastest, group $G$ is the slowest).\n- **Downscattering**: A neutron collision results in energy loss, moving it from a higher energy group $g'$ to a lower energy group $g$ (where $g  g'$). In the scattering matrix $S$, this corresponds to non-zero entries $S_{gg'}$ in the strictly lower triangular part of the matrix.\n- **Upscattering**: A neutron collision results in energy gain, moving it from a lower energy group $g'$ to a higher energy group $g$ (where $g  g'$). This is physically significant only for thermal neutrons that gain energy from colliding with hot moderator nuclei. In the scattering matrix $S$, this corresponds to non-zero entries $S_{gg'}$ in the strictly upper triangular part of the matrix.\n\n**Impact of Upscattering on the Spectral Radius $\\rho(A^{-1}S)$**\n\n1.  **Case 1: No Upscattering (Strictly Downscatter)**\n    When only downscattering is present, the scattering matrix $S$ is strictly lower triangular. Its upper triangular and diagonal entries are all zero. The matrix $A$ is diagonal with positive entries. The iteration matrix $M = A^{-1}S$ is the product of a diagonal matrix and a strictly lower triangular matrix, which results in another strictly lower triangular matrix. A fundamental property of triangular matrices is that their eigenvalues are their diagonal elements. For a strictly lower triangular matrix, all diagonal elements are zero. Therefore, all eigenvalues of $M$ are zero, and its spectral radius is $\\rho(M) = 0$. This implies that the source iteration converges in a finite number of steps (at most $G$ iterations for a $G$-group problem), as the matrix $M$ is nilpotent ($M^G = 0$). Test Case 1 exemplifies this scenario.\n\n2.  **Case 2: Upscattering Present**\n    When upscattering occurs, the matrix $S$ has non-zero entries in its upper triangle. Consequently, the iteration matrix $M = A^{-1}S$ is no longer triangular. It possesses a more general structure with non-zero entries above and below the diagonal. This structure introduces cycles in the energy group coupling. For instance, a neutron can downscatter from group $1$ to group $2$, and then upscatter from group $2$ back to group $1$. This bidirectional coupling means that the matrix $M$ is no longer nilpotent and can have non-zero eigenvalues. The magnitude of these eigenvalues, and thus the spectral radius, depends on the strength of the coupling terms (the elements of $S$) relative to the strength of the removal terms (the diagonal elements of $A$). As the magnitude of upscattering terms in $S$ increases, or as the magnitude of removal/leakage terms in $A$ decreases (e.g., in a large, low-absorption system), the eigenvalues of $M$ tend to increase in magnitude. This leads to an increase in the spectral radius $\\rho(M)$, slowing down the convergence of the source iteration. As $\\rho(M)$ approaches $1$, the number of iterations required for convergence can become prohibitively large.\n\n**Necessity of Preconditioning for Upscatter Problems**\n\nWhen strong upscattering and low removal/leakage cause $\\rho(A^{-1}S)$ to be close to $1$, the standard source iteration is impractical. An acceleration technique, or preconditioning, is necessary. The slow convergence arises because the explicit treatment of the entire scattering matrix $S$ fails to capture the strong, implicit coupling between groups introduced by upscattering.\n\nA common and effective preconditioning strategy is to treat the problematic upscattering terms implicitly. We can split the scattering matrix $S$ into its strictly lower triangular part $S_L$ (downscattering) and its strictly upper triangular part $S_U$ (upscattering): $S = S_L + S_U$.\nThe original equation $A\\boldsymbol{\\phi} = (S_L + S_U)\\boldsymbol{\\phi} + \\boldsymbol{Q}$ can be rearranged as:\n$$\n(A - S_U)\\boldsymbol{\\phi} = S_L\\boldsymbol{\\phi} + \\boldsymbol{Q}\n$$\nThis suggests an alternative iterative scheme:\n$$\n(A - S_U)\\boldsymbol{\\phi}^{(k+1)} = S_L\\boldsymbol{\\phi}^{(k)} + \\boldsymbol{Q}\n$$\nThe update step is $\\boldsymbol{\\phi}^{(k+1)} = (A - S_U)^{-1}S_L\\boldsymbol{\\phi}^{(k)} + (A - S_U)^{-1}\\boldsymbol{Q}$. The iteration matrix for this preconditioned scheme is $M' = (A - S_U)^{-1}S_L$.\nThe matrix $(A - S_U)$ is upper triangular (since $A$ is diagonal and $S_U$ is strictly upper triangular) and its diagonal elements are the positive elements of $A$. It is therefore always invertible, and the system can be efficiently solved at each iteration step using back-substitution. By moving the upscattering term to the left-hand side, we are solving for its effects implicitly within each iteration. The resulting iteration matrix $M'$ typically has a much smaller spectral radius than the original $M = A^{-1}(S_L+S_U)$, dramatically accelerating convergence. This method effectively decouples the energy groups in the forward-solving direction, breaking the cycles that slowed down the original iteration.\n\nThe numerical calculations for the four test cases will now be performed based on the formula $\\rho(A^{-1}S)$.\nFor each case:\n1. Construct the diagonal matrix $A$ with elements $A_{gg} = \\Sigma_{r,g} + D_g B^2$.\n2. Invert $A$ to get $A^{-1}$.\n3. Form the iteration matrix $M = A^{-1} S$.\n4. Compute the eigenvalues of $M$.\n5. Find the maximum absolute value of the eigenvalues to obtain the spectral radius $\\rho(M)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral radius for the source iteration matrix in multigroup\n    neutron diffusion for four test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"D\": np.array([1.0, 0.8, 0.6]),\n            \"B2\": 0.01,\n            \"Sigma_r\": np.array([0.4, 0.25, 0.15]),\n            \"S\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.14, 0.0, 0.0],\n                [0.03, 0.09, 0.0]\n            ])\n        },\n        {\n            \"D\": np.array([1.0, 0.8, 0.6]),\n            \"B2\": 0.01,\n            \"Sigma_r\": np.array([0.4, 0.25, 0.15]),\n            \"S\": np.array([\n                [0.0, 0.01, 0.005],\n                [0.14, 0.0, 0.02],\n                [0.03, 0.09, 0.0]\n            ])\n        },\n        {\n            \"D\": np.array([1.0, 0.8, 0.6]),\n            \"B2\": 0.01,\n            \"Sigma_r\": np.array([0.4, 0.25, 0.15]),\n            \"S\": np.array([\n                [0.0, 0.06, 0.03],\n                [0.16, 0.0, 0.07],\n                [0.035, 0.10, 0.0]\n            ])\n        },\n        {\n            \"D\": np.array([1.4, 1.1, 0.7]),\n            \"B2\": 0.003,\n            \"Sigma_r\": np.array([0.22, 0.16, 0.10]),\n            \"S\": np.array([\n                [0.0, 0.07, 0.035],\n                [0.10, 0.0, 0.05],\n                [0.03, 0.07, 0.0]\n            ])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        D = case[\"D\"]\n        B2 = case[\"B2\"]\n        Sigma_r = case[\"Sigma_r\"]\n        S = case[\"S\"]\n\n        # 1. Construct the diagonal matrix A.\n        # A_gg = Sigma_r,g + D_g * B^2\n        A_diag = Sigma_r + D * B2\n        \n        # A is a diagonal matrix.\n        # A = np.diag(A_diag)\n\n        # 2. Invert A. For a diagonal matrix, the inverse is a diagonal\n        # matrix with the reciprocal of the diagonal elements. This is more\n        # efficient than a general inversion.\n        A_inv_diag = 1.0 / A_diag\n        A_inv = np.diag(A_inv_diag)\n        \n        # 3. Form the iteration matrix M = A^-1 * S.\n        M = A_inv @ S\n\n        # 4. Compute the eigenvalues of M.\n        eigenvalues = np.linalg.eigvals(M)\n        \n        # 5. Find the spectral radius as the maximum absolute value of the eigenvalues.\n        spectral_radius = np.max(np.abs(eigenvalues))\n        \n        results.append(spectral_radius)\n\n    # Format results to six decimal places and print in the required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}