{
    "hands_on_practices": [
        {
            "introduction": "To begin our hands-on exploration, we first focus on the core algebraic components of the multigroup equations: the scattering and removal operators. In the absence of spatial variation, the multigroup diffusion equations reduce to a matrix-vector system where the scattering matrix $S$ couples the energy groups. This first exercise challenges you to construct this matrix from fundamental cross-section data and analyze its properties in relation to the removal matrix $R$, introducing the critical concept of substochasticity which guarantees the convergence of simple iterative solvers.",
            "id": "4234944",
            "problem": "Consider a homogeneous, non-fissioning medium modeled by the steady-state multigroup diffusion balance for a flux vector $\\boldsymbol{\\phi} = (\\phi_{1}, \\phi_{2}, \\phi_{3})^{\\mathrm{T}}$ with energy groups $g \\in \\{1,2,3\\}$. The fundamental starting point is the multigroup diffusion balance for each group $g$,\n$$\n- \\nabla \\cdot \\left( D_{g} \\nabla \\phi_{g} \\right) + \\Sigma_{r,g} \\phi_{g} = \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g} \\, \\phi_{g'} ,\n$$\nwhere $D_{g}$ is the diffusion coefficient, $\\Sigma_{r,g}$ is the macroscopic removal cross section, and $\\Sigma_{s,g'\\to g}$ is the macroscopic scattering cross section from energy group $g'$ into energy group $g$. In a spatially homogenized single-degree-of-freedom setting (one unknown per energy group), the scattering source can be written as a $3 \\times 3$ matrix acting on $\\boldsymbol{\\phi}$,\n$$\n\\mathbf{S} \\boldsymbol{\\phi} = \\begin{pmatrix}\n\\Sigma_{s,1\\to 1}  \\Sigma_{s,2\\to 1}  \\Sigma_{s,3\\to 1} \\\\\n\\Sigma_{s,1\\to 2}  \\Sigma_{s,2\\to 2}  \\Sigma_{s,3\\to 2} \\\\\n\\Sigma_{s,1\\to 3}  \\Sigma_{s,2\\to 3}  \\Sigma_{s,3\\to 3}\n\\end{pmatrix} \\begin{pmatrix} \\phi_{1} \\\\ \\phi_{2} \\\\ \\phi_{3} \\end{pmatrix},\n$$\nand the removal operator is the diagonal matrix $\\mathbf{R} = \\mathrm{diag}(\\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{r,3})$. In the context of source iteration for scattering-only systems, a sufficient condition for contraction in the induced infinity-norm is that the rows of $\\mathbf{R}^{-1}\\mathbf{S}$ sum to less than one, which corresponds to strict substochasticity of the scattering-to-removal mapping.\n\nYou are given the following tabulated macroscopic scattering cross sections $\\Sigma_{s,g'\\to g}$ (in inverse centimeters, $\\mathrm{cm}^{-1}$) and removal cross sections $\\Sigma_{r,g}$ (also in $\\mathrm{cm}^{-1}$) for $G=3$:\n- $\\Sigma_{s,1\\to 1} = 0.20$, $\\Sigma_{s,1\\to 2} = 0.05$, $\\Sigma_{s,1\\to 3} = 0.00$,\n- $\\Sigma_{s,2\\to 1} = 0.01$, $\\Sigma_{s,2\\to 2} = 0.25$, $\\Sigma_{s,2\\to 3} = 0.06$,\n- $\\Sigma_{s,3\\to 1} = 0.00$, $\\Sigma_{s,3\\to 2} = 0.02$, $\\Sigma_{s,3\\to 3} = 0.30$,\n- $\\Sigma_{r,1} = 0.35$, $\\Sigma_{r,2} = 0.40$, $\\Sigma_{r,3} = 0.38$.\n\nTasks:\n1. Assemble the $3 \\times 3$ block structure of $\\mathbf{S}$ consistent with the multigroup mapping from $\\boldsymbol{\\phi}$ to the scattering source. Explain the interpretation of rows and columns in terms of in-scatter.\n2. Using the matrix viewpoint with $\\mathbf{R} = \\mathrm{diag}(\\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{r,3})$, identify the condition under which $\\mathbf{R}^{-1}\\mathbf{S}$ is strictly substochastic in the induced infinity-norm and express this condition in terms of the tabulated cross sections.\n3. Compute the strict substochasticity margin $\\delta$, defined as the largest non-negative number such that for every energy group $g$,\n$$\n\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g} \\leq (1 - \\delta)\\, \\Sigma_{r,g} .\n$$\nExpress your final answer for $\\delta$ as a dimensionless decimal rounded to four significant figures.",
            "solution": "The analysis of the problem proceeds in three steps as requested: assembling and interpreting the scattering matrix, deriving the condition for strict substochasticity, and computing the corresponding margin $\\delta$.\n\n**Task 1: Assemble and Interpret the Scattering Matrix $\\mathbf{S}$**\n\nThe steady-state multigroup diffusion equation for a given energy group $g$ is\n$$\n- \\nabla \\cdot \\left( D_{g} \\nabla \\phi_{g} \\right) + \\Sigma_{r,g} \\phi_{g} = \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g} \\, \\phi_{g'}\n$$\nIn a spatially homogenized context, the divergence term vanishes, and the balance becomes an algebraic system. The right-hand side, representing the source of neutrons scattering into group $g$ from all groups $g'$, can be written as a matrix-vector product. The scattering source vector is $\\mathbf{S}\\boldsymbol{\\phi}$, where the element of the source vector for group $g$ is $(\\mathbf{S}\\boldsymbol{\\phi})_g = \\sum_{g'=1}^{3} S_{g,g'} \\phi_{g'}$. Comparing this with the summation in the diffusion equation, we see that the element of the scattering matrix $\\mathbf{S}$ at row $g$ and column $g'$ must be $S_{g,g'} = \\Sigma_{s,g'\\to g}$.\n\nThe problem provides the matrix structure:\n$$\n\\mathbf{S} = \\begin{pmatrix}\n\\Sigma_{s,1\\to 1}  \\Sigma_{s,2\\to 1}  \\Sigma_{s,3\\to 1} \\\\\n\\Sigma_{s,1\\to 2}  \\Sigma_{s,2\\to 2}  \\Sigma_{s,3\\to 2} \\\\\n\\Sigma_{s,1\\to 3}  \\Sigma_{s,2\\to 3}  \\Sigma_{s,3\\to 3}\n\\end{pmatrix}\n$$\nSubstituting the given numerical values (all in units of $\\mathrm{cm}^{-1}$):\n$$\n\\mathbf{S} = \\begin{pmatrix}\n0.20  0.01  0.00 \\\\\n0.05  0.25  0.02 \\\\\n0.00  0.06  0.30\n\\end{pmatrix}\n$$\nThe interpretation of the rows and columns of $\\mathbf{S}$ is as follows:\n- The element $S_{g,g'} = \\Sigma_{s,g'\\to g}$ represents the macroscopic cross section for a neutron scattering from a source group $g'$ to a destination group $g$.\n- The $g$-th row of $\\mathbf{S}$ contains the cross sections $\\{\\Sigma_{s,1\\to g}, \\Sigma_{s,2\\to g}, \\Sigma_{s,3\\to g}\\}$. When multiplied by the flux vector $\\boldsymbol{\\phi}$, the sum $\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g} \\phi_{g'}$ gives the total rate density of neutrons scattering *into* group $g$. Therefore, each row of $\\mathbf{S}$ corresponds to the in-scatter cross sections for a particular destination group.\n- The $g'$-th column of $\\mathbf{S}$ contains the cross sections $\\{\\Sigma_{s,g'\\to 1}, \\Sigma_{s,g'\\to 2}, \\Sigma_{s,g'\\to 3}\\}$. These are the cross sections for a neutron in group $g'$ scattering *out* to any other group.\n\n**Task 2: Condition for Strict Substochasticity**\n\nThe source iteration method for the algebraic system $(\\mathbf{R} - \\mathbf{S})\\boldsymbol{\\phi} = \\boldsymbol{q}_{ext}$ (where $\\boldsymbol{q}_{ext}$ is an external source, zero in this homogeneous problem) is given by $\\mathbf{R}\\boldsymbol{\\phi}^{(k+1)} = \\mathbf{S}\\boldsymbol{\\phi}^{(k)} + \\boldsymbol{q}_{ext}$, or $\\boldsymbol{\\phi}^{(k+1)} = \\mathbf{R}^{-1}\\mathbf{S}\\boldsymbol{\\phi}^{(k)} + \\mathbf{R}^{-1}\\boldsymbol{q}_{ext}$. This iteration converges if the spectral radius of the iteration matrix $\\mathbf{M} = \\mathbf{R}^{-1}\\mathbf{S}$ is less than $1$. A sufficient condition for this is that any induced matrix norm is less than $1$.\n\nThe problem specifies the induced infinity-norm, $||\\mathbf{M}||_{\\infty}$, which is defined as the maximum absolute row sum of the matrix $\\mathbf{M}$. The condition for contraction is $||\\mathbf{M}||_{\\infty}  1$. A matrix with non-negative entries whose row sums are all less than $1$ is called strictly substochastic.\n\nThe matrices $\\mathbf{R}$ and $\\mathbf{S}$ are given. The removal matrix is $\\mathbf{R} = \\mathrm{diag}(\\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{r,3})$, so its inverse is $\\mathbf{R}^{-1} = \\mathrm{diag}(1/\\Sigma_{r,1}, 1/\\Sigma_{r,2}, 1/\\Sigma_{r,3})$.\nThe iteration matrix is:\n$$\n\\mathbf{M} = \\mathbf{R}^{-1}\\mathbf{S} = \\begin{pmatrix}\n\\frac{1}{\\Sigma_{r,1}}  0  0 \\\\\n0  \\frac{1}{\\Sigma_{r,2}}  0 \\\\\n0  0  \\frac{1}{\\Sigma_{r,3}}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\Sigma_{s,1\\to 1}  \\Sigma_{s,2\\to 1}  \\Sigma_{s,3\\to 1} \\\\\n\\Sigma_{s,1\\to 2}  \\Sigma_{s,2\\to 2}  \\Sigma_{s,3\\to 2} \\\\\n\\Sigma_{s,1\\to 3}  \\Sigma_{s,2\\to 3}  \\Sigma_{s,3\\to 3}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\frac{\\Sigma_{s,1\\to 1}}{\\Sigma_{r,1}}  \\frac{\\Sigma_{s,2\\to 1}}{\\Sigma_{r,1}}  \\frac{\\Sigma_{s,3\\to 1}}{\\Sigma_{r,1}} \\\\\n\\frac{\\Sigma_{s,1\\to 2}}{\\Sigma_{r,2}}  \\frac{\\Sigma_{s,2\\to 2}}{\\Sigma_{r,2}}  \\frac{\\Sigma_{s,3\\to 2}}{\\Sigma_{r,2}} \\\\\n\\frac{\\Sigma_{s,1\\to 3}}{\\Sigma_{r,3}}  \\frac{\\Sigma_{s,2\\to 3}}{\\Sigma_{r,3}}  \\frac{\\Sigma_{s,3\\to 3}}{\\Sigma_{r,3}}\n\\end{pmatrix}\n$$\nThe condition that $\\mathbf{M}$ is strictly substochastic is that for each row $g \\in \\{1, 2, 3\\}$, the sum of its elements is less than $1$. The sum of the elements in row $g$ is:\n$$\n\\sum_{g'=1}^{3} M_{g,g'} = \\sum_{g'=1}^{3} \\frac{\\Sigma_{s,g'\\to g}}{\\Sigma_{r,g}} = \\frac{1}{\\Sigma_{r,g}} \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}\n$$\nThus, the condition for strict substochasticity, expressed in terms of the tabulated cross sections, is that for each group $g$:\n$$\n\\frac{1}{\\Sigma_{r,g}} \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}  1 \\quad \\iff \\quad \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}  \\Sigma_{r,g}\n$$\nPhysically, this means that for each energy group, the total rate of in-scattering must be strictly less than the total rate of removal (absorption plus out-scattering).\n\n**Task 3: Compute the Strict Substochasticity Margin $\\delta$**\n\nThe margin $\\delta$ is defined as the largest non-negative number such that for every group $g$:\n$$\n\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g} \\leq (1 - \\delta) \\Sigma_{r,g}\n$$\nRearranging to solve for $\\delta$, assuming $\\Sigma_{r,g}  0$:\n$$\n\\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}}{\\Sigma_{r,g}} \\leq 1 - \\delta \\quad \\implies \\quad \\delta \\leq 1 - \\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}}{\\Sigma_{r,g}}\n$$\nThis inequality must hold for all $g \\in \\{1, 2, 3\\}$. To find the largest $\\delta$ that satisfies this system of inequalities, we must take the minimum value of the right-hand side over all $g$:\n$$\n\\delta = \\min_{g \\in \\{1,2,3\\}} \\left( 1 - \\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}}{\\Sigma_{r,g}} \\right)\n$$\nThis is equivalent to:\n$$\n\\delta = 1 - \\max_{g \\in \\{1,2,3\\}} \\left( \\frac{\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}}{\\Sigma_{r,g}} \\right)\n$$\nWe calculate the in-scattering cross section sum and the ratio for each group. Let $c_g = (\\sum_{g'=1}^{3} \\Sigma_{s,g'\\to g}) / \\Sigma_{r,g}$.\n\nFor group $g=1$:\n$$ \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to 1} = \\Sigma_{s,1\\to 1} + \\Sigma_{s,2\\to 1} + \\Sigma_{s,3\\to 1} = 0.20 + 0.01 + 0.00 = 0.21 \\, \\mathrm{cm}^{-1} $$\n$$ c_1 = \\frac{0.21}{0.35} = 0.6 $$\n\nFor group $g=2$:\n$$ \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to 2} = \\Sigma_{s,1\\to 2} + \\Sigma_{s,2\\to 2} + \\Sigma_{s,3\\to 2} = 0.05 + 0.25 + 0.02 = 0.32 \\, \\mathrm{cm}^{-1} $$\n$$ c_2 = \\frac{0.32}{0.40} = 0.8 $$\n\nFor group $g=3$:\n$$ \\sum_{g'=1}^{3} \\Sigma_{s,g'\\to 3} = \\Sigma_{s,1\\to 3} + \\Sigma_{s,2\\to 3} + \\Sigma_{s,3\\to 3} = 0.00 + 0.06 + 0.30 = 0.36 \\, \\mathrm{cm}^{-1} $$\n$$ c_3 = \\frac{0.36}{0.38} = \\frac{36}{38} = \\frac{18}{19} $$\n\nThe maximum of these ratios is:\n$$ \\max\\{c_1, c_2, c_3\\} = \\max\\left\\{0.6, 0.8, \\frac{18}{19}\\right\\} = \\max\\left\\{0.6, 0.8, 0.947368...\\right\\} = \\frac{18}{19} $$\nThe strict substochasticity margin $\\delta$ is then:\n$$ \\delta = 1 - \\frac{18}{19} = \\frac{1}{19} $$\nConverting to a decimal and rounding to four significant figures:\n$$ \\delta \\approx 0.05263157... \\approx 0.05263 $$\nThis value is dimensionless, as it is the ratio of cross sections.",
            "answer": "$$\n\\boxed{0.05263}\n$$"
        },
        {
            "introduction": "Building on the algebraic operators, we now incorporate spatial dependence, which is essential for realistic reactor analysis. When the diffusion equation is discretized over a spatial mesh, the leakage operator emerges as a sparse matrix representing neutron transport between adjacent cells. This practice guides you through the assembly of the complete system matrix for a two-dimensional, two-group problem, combining the spatial leakage operator with the energy-coupling scattering operators into a single large, sparse block matrix, a process fundamental to virtually all modern reactor simulation codes.",
            "id": "4234989",
            "problem": "You are tasked with deriving, assembling, and analyzing the global block matrix for the Neutron Multigroup Diffusion (MGD) equations in two energy groups on a two-dimensional uniform Cartesian mesh. The goal is to construct the global block matrix $\\mathbf{A} = \\mathbf{L} - \\mathbf{S}$ that results from a nearest-neighbor finite difference discretization and to provide its sparsity pattern information. You must produce a complete, runnable program that builds this matrix for a specified test suite and outputs quantitative descriptors of the sparsity pattern.\n\nBegin from the following fundamental base. The steady-state two-group diffusion model in a heterogeneous but piecewise-constant material region is given by the coupled Partial Differential Equations (PDEs)\n$$\n-\\nabla \\cdot \\left(D_1(\\mathbf{r}) \\nabla \\phi_1(\\mathbf{r})\\right) + \\Sigma_{r,1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) = \\Sigma_{s,1\\to 1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 1}(\\mathbf{r}) \\phi_2(\\mathbf{r}),\n$$\n$$\n-\\nabla \\cdot \\left(D_2(\\mathbf{r}) \\nabla \\phi_2(\\mathbf{r})\\right) + \\Sigma_{r,2}(\\mathbf{r}) \\phi_2(\\mathbf{r}) = \\Sigma_{s,1\\to 2}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 2}(\\mathbf{r}) \\phi_2(\\mathbf{r}),\n$$\nwhere $D_g(\\mathbf{r})$ is the diffusion coefficient for group $g$, $\\Sigma_{r,g}(\\mathbf{r})$ is the removal cross section, and $\\Sigma_{s,g'\\to g}(\\mathbf{r})$ is the scattering cross section from group $g'$ into group $g$. The unknowns are the scalar fluxes $\\phi_g(\\mathbf{r})$ for $g \\in \\{1,2\\}$. Assume each coefficient is spatially uniform within each cell of a uniform mesh.\n\nDiscretize the spatial operator with a standard five-point Finite Difference (FD) stencil on a rectangular grid of size $N_x \\times N_y$ with unit cell width (you may treat the grid spacing as $h=1$ without units). Enforce a Dirichlet boundary condition where any neighbor that would lie outside the domain is simply omitted from the stencil. Let $N = N_x N_y$ be the number of spatial cells. Use group-major ordering for the unknown vector: list all $N$ unknowns of group $1$, followed by all $N$ of group $2$. With this ordering, the global block matrix $\\mathbf{A}$ is a $2N \\times 2N$ matrix composed of four $N \\times N$ sub-blocks,\n$$\n\\mathbf{A} = \\begin{pmatrix}\nA_{11}  A_{12} \\\\\nA_{21}  A_{22}\n\\end{pmatrix},\n\\quad\nA_{11} = L_{11} - S_{11},\\quad\nA_{22} = L_{22} - S_{22},\\quad\nA_{12} = -S_{12},\\quad\nA_{21} = -S_{21}.\n$$\nHere $L_{gg}$ is the within-group leakage-plus-removal discrete operator produced by the five-point FD stencil (with $D_g$ on each edge and $\\Sigma_{r,g}$ on the diagonal), and $S_{g g'}$ is the scattering operator from group $g'$ into group $g$. In the discrete setting, the scattering operator is cell-local in space, so each $S_{g g'}$ is diagonal in the spatial index when expressed on the same mesh.\n\nYour program must assemble $\\mathbf{A}$ and, for each test case, report quantitative sparsity information that captures both the energy-group block structure and the spatial adjacency in the leakage operator. Specifically, for each test case, compute and output the following items as a single list:\n1. The nonzero counts of each energy-group block of $\\mathbf{A}$: $[\\mathrm{nnz}(A_{11}), \\mathrm{nnz}(A_{12}), \\mathrm{nnz}(A_{21}), \\mathrm{nnz}(A_{22})]$, using a numerical threshold of $10^{-12}$ to treat entries as zero.\n2. Two boolean indicators of whether the off-diagonal energy-group blocks are diagonal in space: $[\\mathrm{isdiag}(A_{12}), \\mathrm{isdiag}(A_{21})]$, where each is true if all nonzeros in that block lie on its spatial diagonal and false otherwise (a block with no nonzeros is considered diagonal).\n3. The sorted unique list of row nonzero counts in the leakage blocks $L_{11}$ and $L_{22}$, each computed with the same threshold $10^{-12}$: $[\\mathrm{degrees}(L_{11}), \\mathrm{degrees}(L_{22})]$. Each list reports the distinct counts of nonzeros per row that arise solely from the five-point stencil structure with Dirichlet boundaries and removal diagonal terms.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case’s result presented as a nested list in the same order as above.\n\nTest Suite:\nUse the following three test cases, each defined by $(N_x, N_y, D_1, D_2, \\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{s,1\\to 1}, \\Sigma_{s,2\\to 2}, \\Sigma_{s,1\\to 2}, \\Sigma_{s,2\\to 1})$, with all quantities treated as dimensionless positive reals for the purposes of assembly and analysis:\n- Case 1 (two-dimensional mesh, downscatter only): $(2, 2, 1.0, 0.8, 0.2, 0.1, 0.0, 0.0, 0.05, 0.0)$.\n- Case 2 (one-dimensional line embedded in two-dimensional indexing, both intra- and inter-group scattering): $(3, 1, 0.5, 0.5, 0.3, 0.3, 0.1, 0.2, 0.05, 0.02)$.\n- Case 3 (single-cell edge case, downscatter only): $(1, 1, 1.2, 1.2, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0)$.\n\nFinal Output Format:\nYour program should produce a single line of output containing a list of three nested lists, one for each test case, in the exact order given above. For each test case, the nested list must contain, in order:\n- The list $[\\mathrm{nnz}(A_{11}), \\mathrm{nnz}(A_{12}), \\mathrm{nnz}(A_{21}), \\mathrm{nnz}(A_{22})]$,\n- The list $[\\mathrm{isdiag}(A_{12}), \\mathrm{isdiag}(A_{21})]$,\n- The list $\\mathrm{degrees}(L_{11})$,\n- The list $\\mathrm{degrees}(L_{22})$.\n\nAs an example of the formatting, if there were two test cases with results $r_1$ and $r_2$, then the single line printed would be in the form: $[r_1,r_2]$. You must not print any additional text.",
            "solution": "The user has provided a problem concerning the assembly and analysis of the global matrix for the two-group neutron diffusion equations on a 2D Cartesian mesh.\n\n### Problem Validation\n\nI will first validate the problem statement according to the specified criteria.\n\n#### Step 1: Extract Givens\n\n*   **Governing Equations**: The steady-state two-group diffusion equations are given as:\n    $$-\\nabla \\cdot \\left(D_1(\\mathbf{r}) \\nabla \\phi_1(\\mathbf{r})\\right) + \\Sigma_{r,1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) = \\Sigma_{s,1\\to 1}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 1}(\\mathbf{r}) \\phi_2(\\mathbf{r})$$\n    $$-\\nabla \\cdot \\left(D_2(\\mathbf{r}) \\nabla \\phi_2(\\mathbf{r})\\right) + \\Sigma_{r,2}(\\mathbf{r}) \\phi_2(\\mathbf{r}) = \\Sigma_{s,1\\to 2}(\\mathbf{r}) \\phi_1(\\mathbf{r}) + \\Sigma_{s,2\\to 2}(\\mathbf{r}) \\phi_2(\\mathbf{r})$$\n*   **Physical Parameters**: $D_g$ (diffusion coefficient), $\\Sigma_{r,g}$ (removal cross section), $\\Sigma_{s,g'\\to g}$ (scattering cross section). These are assumed to be piecewise-constant and uniform for each test case.\n*   **Discretization**:\n    *   Method: Five-point Finite Difference (FD) stencil.\n    *   Grid: Uniform Cartesian mesh of size $N_x \\times N_y$ cells.\n    *   Grid Spacing: $h=1$.\n    *   Boundary Conditions: Dirichlet, implemented by omitting any neighbor that lies outside the domain.\n*   **Matrix System**:\n    *   Unknowns Ordering: Group-major, where all $N = N_x N_y$ spatial unknowns for group 1 are listed, followed by all $N$ unknowns for group 2.\n    *   Global Matrix: $\\mathbf{A} = \\mathbf{L}-\\mathbf{S}$, a $2N \\times 2N$ matrix with a $2 \\times 2$ block structure.\n    $$\\mathbf{A} = \\begin{pmatrix} A_{11}  A_{12} \\\\ A_{21}  A_{22} \\end{pmatrix}$$\n    *   Block Definitions:\n        *   $A_{11} = L_{11} - S_{11}$\n        *   $A_{22} = L_{22} - S_{22}$\n        *   $A_{12} = -S_{12}$\n        *   $A_{21} = -S_{21}$\n        *   $L_{gg}$: Leakage-plus-removal operator for group $g$.\n        *   $S_{gg'}$: Scattering operator from group $g'$ to $g$, noted to be spatially cell-local (diagonal).\n*   **Analysis Task**: For each test case, compute and output:\n    1.  Nonzero counts for each block: $[\\mathrm{nnz}(A_{11}), \\mathrm{nnz}(A_{12}), \\mathrm{nnz}(A_{21}), \\mathrm{nnz}(A_{22})]$ with a tolerance of $10^{-12}$.\n    2.  Diagonality indicators for off-diagonal blocks: $[\\mathrm{isdiag}(A_{12}), \\mathrm{isdiag}(A_{21})]$.\n    3.  Sorted unique row nonzero counts for leakage blocks: $[\\mathrm{degrees}(L_{11}), \\mathrm{degrees}(L_{22})]$.\n*   **Test Suite**: Three cases are provided with specific values for $(N_x, N_y, D_1, D_2, \\Sigma_{r,1}, \\Sigma_{r,2}, \\Sigma_{s,1\\to 1}, \\Sigma_{s,2\\to 2}, \\Sigma_{s,1\\to 2}, \\Sigma_{s,2\\to 1})$.\n\n#### Step 2: Validate Using Extracted Givens\n\n1.  **Scientific or Factual Unsoundness**: The problem is founded on the multigroup diffusion approximation, a standard and well-established model in nuclear reactor physics. The use of finite differences for discretization is also a fundamental numerical technique. The problem formulation is scientifically and mathematically sound.\n2.  **Non-Formalizable or Irrelevant**: The problem is concrete, well-defined, and requires the implementation of a specific numerical algorithm. It is directly relevant to the simulation of nuclear reactors.\n3.  **Incomplete or Contradictory Setup**: The problem provides all necessary information: the governing equations, discretization method, boundary conditions, matrix ordering, and all physical parameters for the test cases. The definitions of the matrix blocks are consistent with the rearrangement of the governing equations into matrix form. For example, the term $\\Sigma_{s,2\\to 1} \\phi_2$ on the right-hand side of the group 1 equation moves to the left, contributing $-\\Sigma_{s,2\\to 1}\\phi_2$. This corresponds to the matrix block $A_{12}$ acting on the $\\phi_2$ vector. The definition $A_{12} = -S_{12}$ where $S_{12}$ represents scattering from group 2 to 1 (associated with $\\Sigma_{s,2\\to 1}$) is consistent.\n4.  **Unrealistic or Infeasible**: The provided parameters are positive real numbers, which is physically reasonable. The problem simplification (e.g., $h=1$, uniform material properties) is common in academic exercises and does not render the problem physically impossible or inconsistent.\n5.  **Ill-Posed or Poorly Structured**: The task is to assemble a matrix and analyze its structure, not to solve the linear system. This is a well-defined computational task. The use of \"Dirichlet boundary condition\" to mean omitting stencil points is a slightly non-standard but clearly specified instruction for implementation. It is unambiguous in its context.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem requires understanding of PDE discretization, sparse matrix data structures, and careful implementation of indexing and assembly logic. It is a substantive and non-trivial exercise in scientific computing.\n7.  **Outside Scientific Verifiability**: The results of the matrix assembly are algorithmically determined and can be independently reproduced and verified.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is valid. It is scientifically grounded, well-posed, and complete. I will now proceed to provide the solution.\n\n### Solution\n\nThe solution involves constructing the constituent blocks of the global matrix $\\mathbf{A}$ for a two-group neutron diffusion problem and analyzing their sparsity patterns. The process can be broken down into three main stages: construction of the leakage-plus-removal operators ($L_{gg}$), construction of the scattering operators ($S_{gg'}$), and finally, assembly of the blocks of $\\mathbf{A}$ and subsequent analysis.\n\n#### 1. Discretization and The Leakage-Plus-Removal Operator ($L_{gg}$)\n\nThe operator $L_{gg}$ represents the discrete form of $-\\nabla \\cdot (D_g \\nabla \\phi_g) + \\Sigma_{r,g} \\phi_g$. We use a five-point finite difference stencil on a uniform Cartesian grid of size $N_x \\times N_y$ with spacing $h=1$. The cells are indexed by a single global index $k \\in \\{0, 1, ..., N-1\\}$, where $N = N_x N_y$. A common mapping from 2D coordinates $(i, j)$ (with $0 \\le i  N_x$, $0 \\le j  N_y$) to the global index $k$ is row-major: $k = i + j \\cdot N_x$.\n\nFor a constant diffusion coefficient $D_g$, the continuous leakage operator at a point $(x,y)$ is $-D_g \\nabla^2 \\phi_g = -D_g (\\frac{\\partial^2\\phi_g}{\\partial x^2} + \\frac{\\partial^2\\phi_g}{\\partial y^2})$. Applying central differences with $h=1$, the discrete operator acting on the flux at cell $k$ (with coordinates $(i,j)$) is:\n$$ -D_g (\\phi_{g,i+1,j} - 2\\phi_{g,i,j} + \\phi_{g,i-1,j} + \\phi_{g,i,j+1} - 2\\phi_{g,i,j} + \\phi_g{,i,j-1}) = D_g(4\\phi_{g,k} - \\phi_{g,k_{R}} - \\phi_{g,k_{L}} - \\phi_{g,k_{T}} - \\phi_{g,k_{B}})$$\nwhere $k_R, k_L, k_T, k_B$ are the global indices of the right, left, top, and bottom neighbors, respectively.\n\nThe problem specifies that for cells near the boundary, any neighbor lying outside the domain is omitted from the stencil. This means the sum of neighbor contributions only includes existing neighbors, and the coefficient of the central term $\\phi_{g,k}$ scales with the number of actual neighbors, denoted $c_k$.\n\nCombining the discrete leakage operator with the removal term $\\Sigma_{r,g}\\phi_{g,k}$, the full expression for row $k$ of the operator $L_{gg}$ is:\n$$(L_{gg} \\boldsymbol{\\phi}_g)_k = (c_k D_g + \\Sigma_{r,g}) \\phi_{g,k} - \\sum_{k' \\in \\text{neighbors}(k)} D_g \\phi_{g,k'}$$\nFrom this, we deduce the entries of the matrix $L_{gg}$:\n*   Diagonal entry: $(L_{gg})_{k,k} = c_k D_g + \\Sigma_{r,g}$\n*   Off-diagonal entry: $(L_{gg})_{k,k'} = -D_g$ if cell $k'$ is a neighbor of cell $k$.\n*   All other entries are $0$.\nThe number of neighbors $c_k$ can be $2$ (for a corner cell, if $N_x, N_y  1$), $3$ (for an edge cell, not corner), or $4$ (for an interior cell). For 1D-like cases ($N_x=1$ or $N_y=1$), $c_k$ can be $0$, $1$, or $2$.\n\n#### 2. The Scattering Operator ($S_{gg'}$)\n\nThe scattering operators $S_{gg'}$ represent the transfer of neutrons from energy group $g'$ to group $g$. The problem states these are \"cell-local in space,\" which means the scattering process at a spatial location only depends on the fluxes at that same location. Consequently, the matrices $S_{gg'}$ are diagonal in the spatial indices. For the uniform material properties given in each test case, the scattering matrix from group $g'$ to $g$ is simply a scaled identity matrix:\n$$S_{gg'} = \\Sigma_{s,g' \\to g} \\cdot I_N$$\nwhere $I_N$ is the $N \\times N$ identity matrix. Note the convention: $S_{12}$ corresponds to scattering from group 2 into group 1, so it is built using $\\Sigma_{s,2 \\to 1}$.\n\n#### 3. Assembly and Analysis\n\nWith the $L_{gg}$ and $S_{gg'}$ matrices defined, the four blocks of the system matrix $\\mathbf{A}$ are assembled as follows:\n*   $A_{11} = L_{11} - S_{11}$\n*   $A_{22} = L_{22} - S_{22}$\n*   $A_{12} = -S_{12}$\n*   $A_{21} = -S_{21}$\n\nThese operations are performed using sparse matrix arithmetic. The final step is to analyze these four blocks according to the problem requirements:\n1.  **Nonzero Counts**: For each block $A_{gg'}$, elements with an absolute value below $10^{-12}$ are treated as zero. The number of remaining non-zero elements is then counted.\n2.  **Diagonality Check**: For the off-diagonal blocks $A_{12}$ and $A_{21}$, we check if all non-zero elements lie on the main diagonal. An all-zero matrix is considered diagonal per the problem statement.\n3.  **Leakage Block Degrees**: For each leakage block $L_{gg}$, we first filter out near-zero values. Then, for each row, we count the number of non-zero entries. The final result for each block is the sorted list of unique values found among these row counts. This reflects the different connectivity patterns of cells in the grid (e.g., corner, edge, interior).\n\nThe implementation will systematically apply this logic to each test case provided. We will use `scipy.sparse` matrices, specifically `lil_matrix` for construction due to its efficient element-wise updates, and `csr_matrix` for analysis due to its efficient row-based operations.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix, diags, csr_matrix\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through each test case, builds the matrices,\n    performs the analysis, and prints the results in the specified format.\n    \"\"\"\n    # Test Suite:\n    # (Nx, Ny, D1, D2, Sigma_r1, Sigma_r2, Sigma_s11, Sigma_s22, Sigma_s12, Sigma_s21)\n    # The problem text labels scatter as g' - g, but the test case tuple appears\n    # consistent with indexing (e.g. s12 is scatter 1-2). We map accordingly.\n    test_cases = [\n        # Case 1: 2x2 grid, downscatter only\n        (2, 2, 1.0, 0.8, 0.2, 0.1, 0.0, 0.0, 0.05, 0.0),\n        # Case 2: 3x1 grid, full scattering\n        (3, 1, 0.5, 0.5, 0.3, 0.3, 0.1, 0.2, 0.05, 0.02),\n        # Case 3: 1x1 grid, downscatter only\n        (1, 1, 1.2, 1.2, 0.0, 0.0, 0.0, 0.0, 0.1, 0.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(case)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # str() converts lists and booleans to the required string representation.\n    output_str = \"[\" + \",\".join(str(r).replace(\"'\", \"\") for r in results) + \"]\"\n    print(output_str)\n\ndef analyze_case(case_params):\n    \"\"\"\n    Analyzes a single test case: builds matrices and computes sparsity metrics.\n    \n    Args:\n        case_params (tuple): A tuple containing all parameters for the test case.\n        \n    Returns:\n        list: A nested list containing the four required analysis results.\n    \"\"\"\n    (Nx, Ny, D1, D2, Sr1, Sr2, Ss11, Ss22, Ss12, Ss21) = case_params\n    N = Nx * Ny\n    \n    # 1. Build Leakage-plus-Removal matrices L_gg\n    L11 = build_leakage_operator(Nx, Ny, D1, Sr1)\n    L22 = build_leakage_operator(Nx, Ny, D2, Sr2)\n\n    # 2. Build Scattering matrices S_gg'\n    # S_gg' is scattering from g' to g.\n    # In notation S_12, g=1, g'=2, representing scatter from 2 - 1.\n    S11 = diags([Ss11], [0], shape=(N, N), format='csr')\n    S22 = diags([Ss22], [0], shape=(N, N), format='csr')\n    S12 = diags([Ss21], [0], shape=(N, N), format='csr') # 2 - 1\n    S21 = diags([Ss12], [0], shape=(N, N), format='csr') # 1 - 2\n\n    # 3. Assemble final block matrices A_gg'\n    A11 = L11 - S11\n    A22 = L22 - S22\n    A12 = -S12\n    A21 = -S21\n\n    # 4. Perform analysis\n    \n    # Item 1: Nonzero counts\n    nnz_A11 = count_nnz(A11)\n    nnz_A12 = count_nnz(A12)\n    nnz_A21 = count_nnz(A21)\n    nnz_A22 = count_nnz(A22)\n    nnz_counts = [nnz_A11, nnz_A12, nnz_A21, nnz_A22]\n    \n    # Item 2: Diagonality check\n    isdiag_A12 = is_diagonal(A12)\n    isdiag_A21 = is_diagonal(A21)\n    diag_indicators = [isdiag_A12, isdiag_A21]\n    \n    # Item 3: Degrees of leakage blocks\n    degrees_L11 = get_degrees(L11)\n    degrees_L22 = get_degrees(L22)\n    \n    # Python's bool `True` stringifies to `True`, problem may expect `true`\n    # Let's handle this during final string formatting.\n    return [nnz_counts, [str(isdiag_A12).lower(), str(isdiag_A21).lower()], degrees_L11, degrees_L22]\n\ndef build_leakage_operator(Nx, Ny, D, Sigma_r):\n    \"\"\"\n    Constructs the leakage-plus-removal operator L for a single energy group.\n    \n    Args:\n        Nx (int): Number of cells in the x-direction.\n        Ny (int): Number of cells in the y-direction.\n        D (float): Diffusion coefficient.\n        Sigma_r (float): Removal cross section.\n        \n    Returns:\n        scipy.sparse.csr_matrix: The assembled L matrix.\n    \"\"\"\n    N = Nx * Ny\n    if N == 0:\n        return csr_matrix((0, 0))\n    \n    # Use LIL format for efficient construction\n    mat = lil_matrix((N, N), dtype=np.float64)\n    \n    for k in range(N):\n        i = k % Nx\n        j = k // Nx\n        \n        num_neighbors = 0\n        \n        # Left neighbor\n        if i > 0:\n            k_neighbor = (i - 1) + j * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n        # Right neighbor\n        if i  Nx - 1:\n            k_neighbor = (i + 1) + j * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n        # Bottom neighbor\n        if j > 0:\n            k_neighbor = i + (j - 1) * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n        # Top neighbor\n        if j  Ny - 1:\n            k_neighbor = i + (j + 1) * Nx\n            mat[k, k_neighbor] = -D\n            num_neighbors += 1\n            \n        # Diagonal entry\n        mat[k, k] = num_neighbors * D + Sigma_r\n        \n    return mat.tocsr()\n\ndef apply_threshold(mat, threshold=1e-12):\n    \"\"\"\n    Explicitly zeros out elements of a sparse matrix below a threshold.\n    This function modifies the matrix in place.\n    \"\"\"\n    if mat.nnz > 0:\n        mat.data[np.abs(mat.data)  threshold] = 0.0\n        mat.eliminate_zeros()\n\ndef count_nnz(mat, threshold=1e-12):\n    \"\"\"Counts non-zeros in a matrix after applying a tolerance.\"\"\"\n    mat_copy = mat.copy()\n    apply_threshold(mat_copy, threshold)\n    return mat_copy.nnz\n\ndef is_diagonal(mat, threshold=1e-12):\n    \"\"\"Checks if a sparse matrix is diagonal.\"\"\"\n    mat_copy = mat.copy()\n    apply_threshold(mat_copy, threshold)\n    \n    # A matrix is diagonal if all its non-zero elements have row_idx == col_idx\n    # This correctly handles the all-zero matrix case, as nonzero() returns empty tuples.\n    rows, cols = mat_copy.nonzero()\n    return np.all(rows == cols)\n\ndef get_degrees(mat, threshold=1e-12):\n    \"\"\"\n    Computes the sorted list of unique row-wise non-zero counts (degrees).\n    \"\"\"\n    mat_copy = mat.copy().tocsr()\n    apply_threshold(mat_copy, threshold)\n    \n    # For a CSR matrix, the difference of the indptr array gives nnz per row.\n    if mat_copy.shape[0] == 0:\n        return []\n    row_nnz = np.diff(mat_copy.indptr)\n    unique_degrees = np.unique(row_nnz)\n    return unique_degrees.tolist()\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The matrix framework is not limited to steady-state criticality calculations (the $k$-eigenvalue problem) but is also a powerful tool for analyzing reactor kinetics. By assuming an exponential time dependence for the neutron flux, $\\phi(\\mathbf{x},t) = \\Phi(\\mathbf{x}) \\exp(\\alpha t)$, the time-dependent diffusion equation transforms into a generalized eigenvalue problem for the reactor's growth rate, $\\alpha$. This final exercise demonstrates this application, requiring you to assemble the relevant operators—including the \"mass matrix\" related to neutron velocity—and solve for the dominant $\\alpha$ eigenvalue, providing direct insight into the time-dependent behavior of a supercritical system.",
            "id": "4234983",
            "problem": "You are given the time-dependent multigroup neutron diffusion equation in slab geometry without external sources and without delayed neutrons. Starting from the fundamental multigroup balance law for neutron population and Fick’s law for diffusion, the partial differential equation (PDE) for the neutron flux is\n$$\n\\frac{1}{v_g}\\frac{\\partial \\phi_g(\\mathbf{x},t)}{\\partial t}\n= \\nabla \\cdot \\left(D_g \\nabla \\phi_g(\\mathbf{x},t)\\right)\n- \\Sigma_{a,g}\\,\\phi_g(\\mathbf{x},t)\n- \\sum_{g'\\neq g}\\Sigma_{s,g\\to g'}\\,\\phi_g(\\mathbf{x},t)\n+ \\sum_{g'}\\Sigma_{s,g'\\to g}\\,\\phi_{g'}(\\mathbf{x},t)\n+ \\chi_g \\sum_{g'} \\nu \\Sigma_{f,g'}\\,\\phi_{g'}(\\mathbf{x},t),\n$$\nfor energy group index $g \\in \\{1,\\dots,G\\}$, where $v_g$ is the neutron speed in group $g$, $D_g$ is the diffusion coefficient, $\\Sigma_{a,g}$ is the absorption cross section, $\\Sigma_{s,g\\to g'}$ is the scattering cross section from group $g$ to group $g'$, $\\nu \\Sigma_{f,g}$ is the production cross section in group $g$, and $\\chi_g$ is the fission neutron spectrum fraction into group $g$. Assuming separable time dependence of the form $\\phi_g(\\mathbf{x},t) = \\Phi_g(\\mathbf{x}) e^{\\alpha t}$ with constant shape $\\Phi_g(\\mathbf{x})$, and using zero-current (Neumann) boundary conditions, derive the generalized eigenvalue problem for the growth rate $\\alpha$ in matrix form. Specifically, define the spatially discretized operators $\\mathbf{L}$, $\\mathbf{F}$, and $\\mathbf{M}$ on a one-dimensional uniform grid using the Finite Difference Method (FDM) so that the generalized eigenproblem\n$$\n\\left(\\mathbf{F} - \\mathbf{L}\\right)\\,\\boldsymbol{\\Phi} = \\alpha\\, \\mathbf{M}\\, \\boldsymbol{\\Phi}\n$$\nholds. Here $\\mathbf{L}$ represents leakage plus removal minus scattering-in, $\\mathbf{F}$ represents fission production mapped by $\\chi$, and $\\mathbf{M}$ is the diagonal operator with entries $1/v_g$. Also recall the standard effective multiplication factor $k$ formulation via the steady-state generalized eigenproblem\n$$\n\\mathbf{F}\\,\\boldsymbol{\\Phi} = k\\,\\mathbf{L}\\,\\boldsymbol{\\Phi},\n$$\nwhich follows from the steady-state balance.\n\nConstruct $\\mathbf{L}$, $\\mathbf{F}$, and $\\mathbf{M}$ for a two-group ($G=2$) homogeneous slab of length $L$ in centimeters, discretized into $N$ uniform cells of width $h=L/N$ centimeters. Use the following well-tested discretization for the diffusion term with zero-current boundary conditions:\n- For group $g$ and interior cell index $i$ with $1 \\le i \\le N-2$, the diagonal coefficient accumulates $2D_g/h^2$, and the off-diagonals at $(i-1,i)$ and $(i+1,i)$ each accumulate $-D_g/h^2$.\n- For group $g$ and boundary cells $i=0$ and $i=N-1$, the diagonal coefficients accumulate $D_g/h^2$, and each has one neighbor off-diagonal coefficient of $-D_g/h^2$ to its single adjacent cell.\nInclude removal on the diagonal via $\\Sigma_{r,g} = \\Sigma_{a,g} + \\sum_{g' \\neq g}\\Sigma_{s,g\\to g'}$, include scattering-in as off-diagonal-in-group blocks via $-\\Sigma_{s,g'\\to g}$ on the left operator $\\mathbf{L}$, and define fission production via $F_{g i, g' j} = \\delta_{i j}\\,\\chi_g \\,\\nu \\Sigma_{f,g'}$ for cells $i,j$ and groups $g,g'$. Let $\\mathbf{M}$ be diagonal with $M_{g i, g i} = 1/v_g$ for each cell $i$ of group $g$.\n\nYour program must, for each test case, perform the following:\n1. Assemble the matrices $\\mathbf{L}$, $\\mathbf{F}$, and $\\mathbf{M}$ according to the specified discretization and parameters.\n2. Compute the dominant real growth rate $\\alpha$ (in $\\mathrm{s}^{-1}$) by solving the generalized eigenproblem $\\left(\\mathbf{F} - \\mathbf{L}\\right)\\boldsymbol{\\Phi} = \\alpha \\mathbf{M} \\boldsymbol{\\Phi}$ and selecting the eigenvalue with the largest real part.\n3. Compute the dominant real multiplication factor $k$ by solving $\\mathbf{F} \\boldsymbol{\\Phi} = k \\mathbf{L} \\boldsymbol{\\Phi}$ and selecting the eigenvalue with the largest real part.\n4. Using the one-speed approximation with constant shape, compute the approximation\n$$\n\\hat{\\alpha} \\approx \\frac{k - 1}{k}\\,\\frac{\\boldsymbol{\\Phi}^\\top \\mathbf{F}\\,\\boldsymbol{\\Phi}}{\\boldsymbol{\\Phi}^\\top \\mathbf{M}\\,\\boldsymbol{\\Phi}},\n$$\nwhere $\\boldsymbol{\\Phi}$ is the right eigenvector associated with the dominant $k$.\n5. Report the triple $[\\alpha_{\\text{exact}},\\alpha_{\\text{approx}},k]$ for each test case, where $\\alpha_{\\text{exact}}$ is the computed dominant real $\\alpha$, $\\alpha_{\\text{approx}}$ is the one-speed approximation defined above, and $k$ is the dominant real multiplication factor.\n\nAll quantities must be reported in consistent physical units, with $\\alpha$ in $\\mathrm{s}^{-1}$. You must round each reported float to six decimal places.\n\nTest Suite:\nUse $G=2$ groups and a uniform grid with $N=10$ cells for all cases. Let the slab length be $L=100\\,\\mathrm{cm}$, so that $h=L/N=10\\,\\mathrm{cm}$. For each case, assume homogeneous material properties across the slab cells and isotropic scattering. The fission spectrum is $\\chi_1=1$ and $\\chi_2=0$ for all cases. Provide the following three supercritical cases:\n- Case $1$ (happy path, strongly supercritical):\n  - $D_1=1.0\\,\\mathrm{cm}$, $D_2=0.25\\,\\mathrm{cm}$,\n  - $\\Sigma_{a,1}=0.01\\,\\mathrm{cm}^{-1}$, $\\Sigma_{a,2}=0.08\\,\\mathrm{cm}^{-1}$,\n  - $\\Sigma_{s,1\\to 2}=0.05\\,\\mathrm{cm}^{-1}$, $\\Sigma_{s,2\\to 1}=0.03\\,\\mathrm{cm}^{-1}$,\n  - $\\nu \\Sigma_{f,1}=0.12\\,\\mathrm{cm}^{-1}$, $\\nu \\Sigma_{f,2}=0.04\\,\\mathrm{cm}^{-1}$,\n  - $v_1=2.2\\times 10^{5}\\,\\mathrm{cm/s}$, $v_2=3.6\\times 10^{4}\\,\\mathrm{cm/s}$.\n- Case $2$ (near-critical, mildly supercritical):\n  - $D_1=1.0\\,\\mathrm{cm}$, $D_2=0.25\\,\\mathrm{cm}$,\n  - $\\Sigma_{a,1}=0.02\\,\\mathrm{cm}^{-1}$, $\\Sigma_{a,2}=0.09\\,\\mathrm{cm}^{-1}$,\n  - $\\Sigma_{s,1\\to 2}=0.06\\,\\mathrm{cm}^{-1}$, $\\Sigma_{s,2\\to 1}=0.02\\,\\mathrm{cm}^{-1}$,\n  - $\\nu \\Sigma_{f,1}=0.09\\,\\mathrm{cm}^{-1}$, $\\nu \\Sigma_{f,2}=0.02\\,\\mathrm{cm}^{-1}$,\n  - $v_1=2.0\\times 10^{5}\\,\\mathrm{cm/s}$, $v_2=5.0\\times 10^{4}\\,\\mathrm{cm/s}$.\n- Case $3$ (decoupled one-group limit inside two-group formulation):\n  - $D_1=1.2\\,\\mathrm{cm}$, $D_2=0.2\\,\\mathrm{cm}$,\n  - $\\Sigma_{a,1}=0.05\\,\\mathrm{cm}^{-1}$, $\\Sigma_{a,2}=0.2\\,\\mathrm{cm}^{-1}$,\n  - $\\Sigma_{s,1\\to 2}=0.0\\,\\mathrm{cm}^{-1}$, $\\Sigma_{s,2\\to 1}=0.0\\,\\mathrm{cm}^{-1}$,\n  - $\\nu \\Sigma_{f,1}=0.12\\,\\mathrm{cm}^{-1}$, $\\nu \\Sigma_{f,2}=0.0\\,\\mathrm{cm}^{-1}$,\n  - $v_1=1.5\\times 10^{5}\\,\\mathrm{cm/s}$, $v_2=1.0\\times 10^{5}\\,\\mathrm{cm/s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a three-element list of floats rounded to six decimals and ordered as $[\\alpha_{\\text{exact}},\\alpha_{\\text{approx}},k]$. For example, your output should look like\n$$\n[\\,[\\alpha_1,\\hat{\\alpha}_1,k_1],[\\alpha_2,\\hat{\\alpha}_2,k_2],[\\alpha_3,\\hat{\\alpha}_3,k_3]\\,].\n$$",
            "solution": "The problem statement has been critically validated and is determined to be **valid**. It is scientifically grounded in the principles of nuclear reactor physics, specifically multigroup neutron diffusion theory and reactor kinetics. The problem is well-posed, providing all necessary physical parameters, boundary conditions, and a clear, formalizable numerical discretization scheme (Finite Difference Method). The objectives are stated objectively and unambiguously. The test cases provided are physically plausible and serve to test the implementation under different, well-defined conditions.\n\nThe solution proceeds by first deriving the discrete matrix operators from the continuous partial differential equation and then solving the resulting matrix eigenvalue problems.\n\n### Derivation and Discretization of Operators\nThe fundamental time-dependent multigroup neutron diffusion equation for group $g$ is given as:\n$$\n\\frac{1}{v_g}\\frac{\\partial \\phi_g(\\mathbf{x},t)}{\\partial t}\n= \\nabla \\cdot \\left(D_g \\nabla \\phi_g(\\mathbf{x},t)\\right)\n- \\Sigma_{a,g}\\,\\phi_g(\\mathbf{x},t)\n- \\sum_{g'\\neq g}\\Sigma_{s,g\\to g'}\\,\\phi_g(\\mathbf{x},t)\n+ \\sum_{g'}\\Sigma_{s,g'\\to g}\\,\\phi_{g'}(\\mathbf{x},t)\n+ \\chi_g \\sum_{g'} \\nu \\Sigma_{f,g'}\\,\\phi_{g'}(\\mathbf{x},t)\n$$\nWe define the removal cross section for group $g$ as $\\Sigma_{r,g} = \\Sigma_{a,g} + \\sum_{g' \\neq g} \\Sigma_{s,g \\to g'}$. Substituting this and the separable ansatz $\\phi_g(\\mathbf{x},t) = \\Phi_g(\\mathbf{x}) e^{\\alpha t}$ into the equation, we obtain an equation for the spatial shape function $\\Phi_g(\\mathbf{x})$:\n$$\n\\frac{\\alpha}{v_g} \\Phi_g(\\mathbf{x}) = \\nabla \\cdot (D_g \\nabla \\Phi_g) - \\Sigma_{r,g} \\Phi_g + \\sum_{g' \\neq g} \\Sigma_{s,g'\\to g} \\Phi_{g'} + \\chi_g \\sum_{g'} \\nu \\Sigma_{f,g'} \\Phi_{g'}\n$$\nNote that the scattering term $\\sum_{g'}\\Sigma_{s,g'\\to g}\\,\\phi_{g'}$ was separated into within-group scattering (which is implicitly part of the removal term definition) and scattering from other groups $g' \\neq g$. For consistency with the standard formulation where scattering is split into removal and source, we use the provided $\\Sigma_{r,g}$ and the scattering-in term from other groups.\n\nRearranging the equation to match the desired generalized eigenvalue problem structures:\n$$\n\\left( \\chi_g \\sum_{g'} \\nu \\Sigma_{f,g'} \\Phi_{g'} \\right) - \\left( -\\nabla \\cdot (D_g \\nabla \\Phi_g) + \\Sigma_{r,g}\\Phi_g - \\sum_{g' \\neq g} \\Sigma_{s,g'\\to g} \\Phi_{g'} \\right) = \\alpha \\left( \\frac{1}{v_g} \\Phi_g \\right)\n$$\nThis precisely matches the operator form $(\\mathbf{F}-\\mathbf{L})\\boldsymbol{\\Phi} = \\alpha \\mathbf{M}\\boldsymbol{\\Phi}$, with the operators defined as:\n- **Fission operator ($\\mathbf{F}$):** $(\\mathbf{F}\\boldsymbol{\\Phi})_g = \\chi_g \\sum_{g'} \\nu \\Sigma_{f,g'} \\Phi_{g'}$\n- **Loss operator ($\\mathbf{L}$):** $(\\mathbf{L}\\boldsymbol{\\Phi})_g = -\\nabla \\cdot (D_g \\nabla \\Phi_g) + \\Sigma_{r,g}\\Phi_g - \\sum_{g' \\neq g} \\Sigma_{s,g'\\to g} \\Phi_{g'}$\n- **Mass matrix ($\\mathbf{M}$):** $(\\mathbf{M}\\boldsymbol{\\Phi})_g = \\frac{1}{v_g} \\Phi_g$\n\nThe problem is set in a one-dimensional slab of length $L$, discretized into $N$ cells of width $h=L/N$. The flux $\\Phi_g$ in each cell $i$ is represented by a single value $\\Phi_{g,i}$. The total state vector $\\boldsymbol{\\Phi}$ is a concatenation of the flux vectors for each group: $\\boldsymbol{\\Phi} = [\\Phi_1^\\top, \\Phi_2^\\top, \\dots, \\Phi_G^\\top]^\\top$, where $\\Phi_g = [\\Phi_{g,0}, \\dots, \\Phi_{g,N-1}]^\\top$. The total size of the system is $G \\times N$. For this problem, $G=2$ and $N=10$, so the matrices will be of size $20 \\times 20$.\n\n### Matrix Construction ($G=2$)\n\nThe operators $\\mathbf{L}$, $\\mathbf{F}$, and $\\mathbf{M}$ are constructed as $G \\times G$ block matrices, where each block is an $N \\times N$ matrix.\n\n**1. Mass Matrix $\\mathbf{M}$**\n$\\mathbf{M}$ is a diagonal matrix. Its block representation is:\n$$\n\\mathbf{M} = \\begin{pmatrix} (1/v_1)I_N  0 \\\\ 0  (1/v_2)I_N \\end{pmatrix}\n$$\nwhere $I_N$ is the $N \\times N$ identity matrix.\n\n**2. Fission Matrix $\\mathbf{F}$**\nThe definition $F_{gi, g'j} = \\delta_{ij} \\chi_g \\nu \\Sigma_{f,g'}$ leads to a block structure where each block $F_{gg'}$ is a diagonal matrix. Given $\\chi_1=1$ and $\\chi_2=0$:\n$$\n\\mathbf{F} = \\begin{pmatrix} F_{11}  F_{12} \\\\ F_{21}  F_{22} \\end{pmatrix} = \\begin{pmatrix} (\\nu\\Sigma_{f,1})I_N  (\\nu\\Sigma_{f,2})I_N \\\\ 0  0 \\end{pmatrix}\n$$\n\n**3. Loss Matrix $\\mathbf{L}$**\n$\\mathbf{L}$ is composed of leakage, removal, and scattering-in parts.\n$$\n\\mathbf{L} = \\begin{pmatrix} L_{11}  L_{12} \\\\ L_{21}  L_{22} \\end{pmatrix}\n$$\n- **Diagonal blocks $L_{gg}$**: These combine leakage and removal within group $g$.\n  $L_{gg} = \\text{Leakage}_g + \\text{Removal}_g$.\n  The leakage term $-\\nabla \\cdot (D_g \\nabla \\cdot)$ is discretized using the centered finite difference scheme specified for a 1D grid with zero-current (Neumann) boundary conditions. This results in the matrix $\\frac{D_g}{h^2} \\mathbf{B}$, where $\\mathbf{B}$ is the $N \\times N$ tridiagonal matrix:\n  $$\n  \\mathbf{B} = \\begin{pmatrix} 1  -1    \\\\ -1  2  -1   \\\\  \\ddots  \\ddots  \\ddots  \\\\   -1  2  -1 \\\\    -1  1 \\end{pmatrix}\n  $$\n  The removal term adds $\\Sigma_{r,g} I_N$ to this block, where $\\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1\\to 2}$ and $\\Sigma_{r,2} = \\Sigma_{a,2} + \\Sigma_{s,2\\to 1}$.\n  So, $L_{gg} = \\frac{D_g}{h^2}\\mathbf{B} + \\Sigma_{r,g}I_N$.\n- **Off-diagonal blocks $L_{g g'}$ ($g \\neq g'$)**: These represent the negative of the scattering source from group $g'$ to group $g$.\n  $L_{12}$ is the operator for group $2$ flux affecting group $1$. The scattering-in term to group $1$ is $\\Sigma_{s,2\\to 1}\\Phi_2$. As $\\mathbf{L}$ contains the negative of this source, $L_{12} = -\\Sigma_{s,2\\to 1}I_N$.\n  Similarly, $L_{21} = -\\Sigma_{s,1\\to 2}I_N$.\n\n### Eigenvalue Problems\nWith the matrices constructed, two generalized eigenvalue problems are solved using `scipy.linalg.eig(A, B)` which finds eigenvalues $\\lambda$ for $A v = \\lambda B v$.\n\n1.  **Growth Rate $\\alpha_{\\text{exact}}$**: Solved from $(\\mathbf{F} - \\mathbf{L})\\boldsymbol{\\Phi} = \\alpha \\mathbf{M} \\boldsymbol{\\Phi}$. Here, $A = \\mathbf{F}-\\mathbf{L}$ and $B = \\mathbf{M}$. The dominant eigenvalue is the one with the largest real part.\n2.  **Multiplication Factor $k$**: Solved from the steady-state equation $\\mathbf{F}\\boldsymbol{\\Phi} = k \\mathbf{L}\\boldsymbol{\\Phi}$. Here, $A = \\mathbf{F}$ and $B = \\mathbf{L}$. The dominant eigenvalue is again the one with the largest real part. The corresponding eigenvector $\\boldsymbol{\\Phi}_k$ is used for the next step. Physically, both $\\alpha$ and $k$ for the fundamental mode are real and their corresponding flux eigenvectors are real and non-negative.\n\n### Approximation for $\\alpha$\nThe point-kinetics approximation relates $\\alpha$ and $k$:\n$$\n\\hat{\\alpha} \\approx \\frac{\\rho}{\\Lambda} = \\frac{(k-1)/k}{\\Lambda}\n$$\nwhere $\\rho=(k-1)/k$ is the reactivity and $\\Lambda$ is the prompt neutron generation time. The problem provides a formula for the ratio $\\rho/\\Lambda$ as:\n$$\n\\hat{\\alpha} \\approx \\frac{k - 1}{k}\\,\\frac{\\boldsymbol{\\Phi}^\\top \\mathbf{F}\\,\\boldsymbol{\\Phi}}{\\boldsymbol{\\Phi}^\\top \\mathbf{M}\\,\\boldsymbol{\\Phi}}\n$$\nHere, $\\boldsymbol{\\Phi}$ is the dominant eigenvector $\\boldsymbol{\\Phi}_k$ from the $k$-eigenvalue calculation. The quadratic forms $\\boldsymbol{\\Phi}^\\top \\mathbf{F} \\boldsymbol{\\Phi}$ and $\\boldsymbol{\\Phi}^\\top \\mathbf{M} \\boldsymbol{\\Phi}$ are computed using this eigenvector. The eigenvector returned by numerical solvers may be complex, so its real part is taken before use in these expressions.\n\nThe implementation will construct these matrices for each test case and compute the three required values: $\\alpha_{\\text{exact}}$, $k$, and $\\hat{\\alpha}$. All results are rounded to six decimal places as requested.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    \"\"\"\n    Assembles matrices and solves eigenvalue problems for multigroup neutron diffusion.\n    \"\"\"\n    \n    # Global parameters shared by all test cases\n    G = 2  # Number of energy groups\n    N = 10  # Number of spatial cells\n    L_slab = 100.0  # cm, slab length\n    h = L_slab / N  # cm, cell width\n    chi = np.array([1.0, 0.0]) # Fission spectrum\n\n    test_cases = [\n        # Case 1 (happy path, strongly supercritical)\n        {\n            \"D\": np.array([1.0, 0.25]),\n            \"Sigma_a\": np.array([0.01, 0.08]),\n            \"Sigma_s12\": 0.05, \"Sigma_s21\": 0.03,\n            \"nuSigma_f\": np.array([0.12, 0.04]),\n            \"v\": np.array([2.2e5, 3.6e4]),\n        },\n        # Case 2 (near-critical, mildly supercritical)\n        {\n            \"D\": np.array([1.0, 0.25]),\n            \"Sigma_a\": np.array([0.02, 0.09]),\n            \"Sigma_s12\": 0.06, \"Sigma_s21\": 0.02,\n            \"nuSigma_f\": np.array([0.09, 0.02]),\n            \"v\": np.array([2.0e5, 5.0e4]),\n        },\n        # Case 3 (decoupled one-group limit)\n        {\n            \"D\": np.array([1.2, 0.2]),\n            \"Sigma_a\": np.array([0.05, 0.2]),\n            \"Sigma_s12\": 0.0, \"Sigma_s21\": 0.0,\n            \"nuSigma_f\": np.array([0.12, 0.0]),\n            \"v\": np.array([1.5e5, 1.0e5]),\n        },\n    ]\n\n    results = []\n    \n    # --- Matrix Construction ---\n    # FDM matrix for -d/dx(D d/dx) with Neumann B.C. (zero-current)\n    leakage_template = np.diag(np.full(N, 2.0)) - np.diag(np.ones(N - 1), 1) - np.diag(np.ones(N - 1), -1)\n    leakage_template[0, 0] = 1.0\n    leakage_template[N - 1, N - 1] = 1.0\n\n    for case in test_cases:\n        D = case[\"D\"]\n        Sigma_a = case[\"Sigma_a\"]\n        Sigma_s12 = case[\"Sigma_s12\"]\n        Sigma_s21 = case[\"Sigma_s21\"]\n        nuSigma_f = case[\"nuSigma_f\"]\n        v = case[\"v\"]\n\n        # Total system size\n        size = G * N\n        \n        # Initialize block matrices\n        L_mat = np.zeros((size, size))\n        F_mat = np.zeros((size, size))\n        M_mat = np.zeros((size, size))\n\n        # Fill M matrix (diagonal 1/v)\n        M_diag = np.concatenate([np.full(N, 1.0/v[0]), np.full(N, 1.0/v[1])])\n        np.fill_diagonal(M_mat, M_diag)\n\n        # Fill F matrix (fission production)\n        # F_11 block\n        F_mat[0:N, 0:N] = np.eye(N) * chi[0] * nuSigma_f[0]\n        # F_12 block\n        F_mat[0:N, N:2*N] = np.eye(N) * chi[0] * nuSigma_f[1]\n        \n        # Fill L matrix (leakage + removal - scattering_in)\n        Sigma_r1 = Sigma_a[0] + Sigma_s12\n        Sigma_r2 = Sigma_a[1] + Sigma_s21\n\n        L_11 = (D[0] / h**2) * leakage_template + np.eye(N) * Sigma_r1\n        L_mat[0:N, 0:N] = L_11\n        \n        L_22 = (D[1] / h**2) * leakage_template + np.eye(N) * Sigma_r2\n        L_mat[N:2*N, N:2*N] = L_22\n        \n        L_12 = -np.eye(N) * Sigma_s21\n        L_mat[0:N, N:2*N] = L_12\n        \n        L_21 = -np.eye(N) * Sigma_s12\n        L_mat[N:2*N, 0:N] = L_21\n\n        # --- Eigenvalue Calculations ---\n        \n        # 1. Solve for alpha_exact: (F - L) * Phi = alpha * M * Phi\n        A_alpha = F_mat - L_mat\n        B_alpha = M_mat\n        alphas, _ = eig(A_alpha, B_alpha)\n        alpha_exact = np.real(alphas[np.argmax(np.real(alphas))])\n        \n        # 2. Solve for k: F * Phi = k * L * Phi\n        A_k = F_mat\n        B_k = L_mat\n        try:\n            ks, vecs_k = eig(A_k, B_k)\n            # Find dominant eigenvalue and corresponding eigenvector\n            dominant_idx_k = np.argmax(np.real(ks))\n            k = np.real(ks[dominant_idx_k])\n            phi_k = np.real(vecs_k[:, dominant_idx_k])\n        except np.linalg.LinAlgError:\n            k = np.nan\n            phi_k = np.ones(size)\n        \n        # 3. Calculate alpha_approx\n        if np.sum(phi_k)  0:\n            phi_k = -phi_k\n        \n        numerator = phi_k.T @ F_mat @ phi_k\n        denominator = phi_k.T @ M_mat @ phi_k\n        \n        if k == 0 or np.isnan(k) or denominator == 0:\n            alpha_approx = 0.0\n        else:\n            generation_time_inv = numerator / denominator\n            alpha_approx = ((k - 1.0) / k) * generation_time_inv\n\n        results.append([\n            round(alpha_exact, 6),\n            round(alpha_approx, 6),\n            round(k, 6)\n        ])\n\n    final_output = str(results).replace(\"'\", \"\")\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}