{
    "hands_on_practices": [
        {
            "introduction": "双非均质性问题的核心在于理解中子在不同尺度上的输运。本实践从微观尺度入手，推导微观丹可夫因子 $C_{\\mu}$。通过将弦长统计分布与指数衰减定律相结合，你将亲手建立一个描述中子在燃料颗粒间隙中无碰撞穿行概率的模型，这是理解共振自屏敝效应的基础。",
            "id": "4254734",
            "problem": "考虑用于高温气冷堆中的双非均质燃料压块的微观尺度，其中微观燃料颗粒（例如，球形核芯）嵌入在石墨慢化剂基体中。仅关注微观非均质性：假设燃料和慢化剂的二元混合物在统计上是均匀和各向同性的，单位体积内的界面比表面积为 $S$，慢化剂的体积份额为 $\\phi_{m}$。在稀疏、马尔可夫两相极限下，慢化剂相内的弦长分布被视为指数分布，其平均弦长 $\\bar{\\ell}_{m}$ 由 Miles 关系式 $\\bar{\\ell}_{m} = 4 \\phi_{m}/S$ 给出。在慢化能区内的某一固定中子能量下，将慢化剂建模为纯吸收体，其宏观吸收截面为 $\\Sigma_{m}$，并忽略中子单次穿过慢化剂过程中的散射和能量变化。\n\n一个从燃料颗粒表面射出进入慢化剂的中子，在重新进入燃料相之前，会穿过一段长度为 $s$ 的随机慢化剂弦。根据在慢化剂中穿行距离 $s$ 而不发生碰撞的存活率遵循指数衰减定律 $I(s) = I_{0}\\exp(-\\Sigma_{m} s)$，定义微观丹可夫因子 $C_{\\mu}$ 为这样一个中子在慢化剂中不发生任何相互作用而到达下一个燃料区的概率。从给定的假设和基本的输运衰减原理出发，建立一个将慢化剂弦长概率密度与指数存活率进行卷积的积分表达式，并计算出其解析闭式解。用 $\\Sigma_{m}$、$S$ 和 $\\phi_{m}$ 来表示你的最终答案。最终答案必须是单一的闭式表达式。不需要进行数值近似。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、提法恰当且客观。它描述了核反应堆物理中的一个标准问题，具体是在双非均质介质中计算丹可夫因子，使用了来自输运理论和统计几何学的成熟模型和原理。所有必要的信息和定义都已提供，足以推导出一个唯一且有意义的解。\n\n问题要求计算微观丹可夫因子 $C_{\\mu}$，它被定义为一个从燃料颗粒射出、穿过慢化剂并在不发生任何相互作用的情况下到达另一个燃料区的概率。这是一个平均概率，其平均过程是对慢化剂中所有可能的路径长度（弦长）进行的。\n\n设 $s$ 为慢化剂中随机弦的长度。问题指出，中子穿行距离 $s$ 而不发生相互作用的概率遵循指数衰减定律。这个存活概率 $P_{\\text{surv}}(s)$ 由下式给出：\n$$ P_{\\text{surv}}(s) = \\exp(-\\Sigma_{m} s) $$\n其中 $\\Sigma_{m}$ 是慢化剂的宏观吸收截面。\n\n问题还指出，慢化剂相内的弦长 $s$ 的分布遵循指数概率分布。对于平均值为 $\\bar{\\lambda}$ 的指数分布，其概率密度函数 (PDF) 为 $p(x) = \\frac{1}{\\bar{\\lambda}} \\exp(-x/\\bar{\\lambda})$。在本问题中，随机变量是弦长 $s$，其平均值给定为 $\\bar{\\ell}_{m}$。因此，弦长 $s$ 的 PDF（记为 $p(s)$）是：\n$$ p(s) = \\frac{1}{\\bar{\\ell}_{m}} \\exp\\left(-\\frac{s}{\\bar{\\ell}_{m}}\\right) $$\n其中 $s \\ge 0$。弦长在 $s$ 和 $s+ds$ 之间的概率为 $p(s)ds$。\n\n微观丹可夫因子 $C_{\\mu}$ 是总存活概率，通过将特定弦长的存活概率 $P_{\\text{surv}}(s)$ 按该弦长出现的概率 $p(s)ds$ 加权，对所有从 $0$ 到 $\\infty$ 的非负弦长进行积分得到。这构成了题目所要求的两个分布的卷积。\n因此，$C_{\\mu}$ 的积分表达式为：\n$$ C_{\\mu} = \\int_{0}^{\\infty} P_{\\text{surv}}(s) \\, p(s) \\, ds $$\n\n代入 $P_{\\text{surv}}(s)$ 和 $p(s)$ 的表达式：\n$$ C_{\\mu} = \\int_{0}^{\\infty} \\left[ \\exp(-\\Sigma_{m} s) \\right] \\left[ \\frac{1}{\\bar{\\ell}_{m}} \\exp\\left(-\\frac{s}{\\bar{\\ell}_{m}}\\right) \\right] ds $$\n\n我们可以合并指数项，并将常数 $\\frac{1}{\\bar{\\ell}_{m}}$ 从积分中提出：\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}} \\int_{0}^{\\infty} \\exp\\left(-\\Sigma_{m} s - \\frac{s}{\\bar{\\ell}_{m}}\\right) ds $$\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}} \\int_{0}^{\\infty} \\exp\\left(-s \\left(\\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}\\right)\\right) ds $$\n\n这是一个标准的指数函数定积分。设指数中的常数为 $k = \\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}$。该积分变为：\n$$ \\int_{0}^{\\infty} \\exp(-ks) \\, ds = \\left[ -\\frac{1}{k} \\exp(-ks) \\right]_{0}^{\\infty} $$\n计算极限：\n$$ \\left( \\lim_{s \\to \\infty} -\\frac{1}{k} \\exp(-ks) \\right) - \\left( -\\frac{1}{k} \\exp(-k \\cdot 0) \\right) $$\n由于 $k = \\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}$ 是正的（物理截面和长度是非负的，且对于吸收介质 $\\Sigma_m>0$），当 $s \\to \\infty$ 时，$\\exp(-ks)$ 的极限为 $0$。表达式简化为：\n$$ (0) - \\left( -\\frac{1}{k} \\exp(0) \\right) = \\frac{1}{k} $$\n\n将此结果代回到 $C_{\\mu}$ 的表达式中：\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}} \\cdot \\frac{1}{k} = \\frac{1}{\\bar{\\ell}_{m}} \\cdot \\frac{1}{\\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}} $$\n\n为简化起见，我们将分子和分母同乘以 $\\bar{\\ell}_{m}$：\n$$ C_{\\mu} = \\frac{1}{\\bar{\\ell}_{m}\\left(\\Sigma_{m} + \\frac{1}{\\bar{\\ell}_{m}}\\right)} = \\frac{1}{\\bar{\\ell}_{m}\\Sigma_{m} + 1} $$\n该表达式被称为从凸体中逃逸概率的 Wigner 有理近似，这里被推广用于随机介质。\n\n最后一步是用给定的参数 $\\Sigma_{m}$、$S$（界面比表面积）和 $\\phi_{m}$（慢化剂体积份额）来表示结果。问题给出了慢化剂中平均弦长的 Miles 关系式：\n$$ \\bar{\\ell}_{m} = \\frac{4 \\phi_{m}}{S} $$\n\n将 $\\bar{\\ell}_{m}$ 的这个表达式代入我们得到的 $C_{\\mu}$ 结果中：\n$$ C_{\\mu} = \\frac{1}{\\left(\\frac{4 \\phi_{m}}{S}\\right)\\Sigma_{m} + 1} $$\n\n这可以通过对分母进行通分，改写为更紧凑的形式：\n$$ C_{\\mu} = \\frac{1}{\\frac{4 \\phi_{m} \\Sigma_{m} + S}{S}} $$\n$$ C_{\\mu} = \\frac{S}{S + 4 \\phi_{m} \\Sigma_{m}} $$\n\n这就是在给定假设下，微观丹可夫因子 $C_{\\mu}$ 的最终解析闭式表达式。",
            "answer": "$$\\boxed{\\frac{S}{S + 4 \\phi_{m} \\Sigma_{m}}}$$"
        },
        {
            "introduction": "理解了微观物理后，下一步是量化其对反应堆宏观参数的影响。本实践通过一个简化的双能群模型，让你通过编程来分离和比较微观自屏敝与宏观丹可夫耦合对无限介质增殖因子 $k_{\\infty}$ 和反应率的贡献。这项练习有助于培养对模型简化和物理效应主次重要性进行判断的能力。",
            "id": "4254731",
            "problem": "考虑一个无限介质、双能群的中子平衡问题，该问题用于一个双重非均质燃料-慢化剂系统的均匀化表示。双重非均质性源于嵌入燃料芯块（微观尺度）的微观燃料颗粒，以及慢化剂基体中燃料块的空间排布（宏观尺度）。目标是分离并量化微观泄漏与宏观丹科夫耦合对反应率和无限介质增殖因子的贡献。您需要实现一个程序，该程序能依次切换每个修正项，并测量反应率和无限介质增殖因子的变化，以确定建模工作的优先级。\n\n基本原理：\n- 无限介质中的中子平衡可以用多群形式表示为一个广义特征值问题。设$\\phi_1$为快中子群通量，$\\phi_2$为热/共振中子群通量。定义移出算符矩阵$A$和裂变产生算符矩阵$F$如下：\n$$\nA = \\begin{bmatrix}\n\\Sigma_{r,1}  0 \\\\\n-\\Sigma_{s,1\\to 2}  \\Sigma_{a,2}^{\\text{eff}}\n\\end{bmatrix}, \\quad\nF = \\begin{bmatrix}\n\\chi_1 \\nu \\Sigma_{f,1}  \\chi_1 \\nu \\Sigma_{f,2} \\\\\n\\chi_2 \\nu \\Sigma_{f,1}  \\chi_2 \\nu \\Sigma_{f,2}\n\\end{bmatrix},\n$$\n其中$\\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1\\to 2}$，$\\Sigma_{a,2}^{\\text{eff}}$是第2群中的有效吸收截面，$\\nu$是每次裂变产生的平均中子数，$\\chi_1$和$\\chi_2$分别是向第1群和第2群的裂变谱份额。无限介质增殖因子$k_\\infty$通过求解$A^{-1} F$的主特征值得到：\n$$\nA^{-1} F \\, \\Phi = k_\\infty \\, \\Phi, \\quad \\Phi = \\begin{bmatrix}\\phi_1 \\\\ \\phi_2\\end{bmatrix}.\n$$\n- 第2群的吸收反应率为$R_{a,2} = \\Sigma_{a,2}^{\\text{eff}} \\, \\phi_2$，通量归一化选择为$\\phi_1 + \\phi_2 = 1$。\n\n微观泄漏与宏观丹科夫建模假设：\n- 微观泄漏捕捉了由于微观燃料颗粒的有限光学厚度而导致的有效共振吸收减少。对于半径为$r_g$的球形颗粒，设光学厚度为$\\tau_g = \\Sigma_{t,\\text{fuel}} \\, r_g$，其中$\\Sigma_{t,\\text{fuel}}$是第2群中燃料的总截面。使用一个线性化自屏效应修正因子：\n$$\n\\Sigma_{a,2}^{\\text{eff}} = \\frac{\\Sigma_{a,2}^{\\text{base}}}{1 + \\alpha_0 \\, \\tau_g \\, T_{\\text{micro}} + \\beta_0 \\, \\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right) \\, (1 - C) \\, T_{\\text{macro}}},\n$$\n其中$\\Sigma_{a,2}^{\\text{base}}$是第2群的基准吸收截面，$\\alpha_0$和$\\beta_0$是用于微观泄漏和宏观耦合的无量纲修正系数，$\\Sigma_{t,\\text{mod}}$是第2群中慢化剂的总截面，$s$是特征燃料块间距，$C \\in [0,1]$是宏观丹科夫因子，$T_{\\text{micro}}, T_{\\text{macro}} \\in \\{0,1\\}$是用于启用相应修正的开关。因子$\\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right)$是慢化剂平均自由程相对于燃料块间距的无量纲度量。项$(1 - C)$在燃料块相互遮蔽时减少宏观背景，这与等效理论的解释一致，即较高的$C$会减少共振所见的慢化剂背景。\n- 这个简化模型在科学上对于分离趋势是合理的：增加$r_g$会增加$\\tau_g$，从而增加微观泄漏修正的幅度；增加$C$会减少$(1 - C)$，因此减少宏观修正的幅度；减小$s$会通过增加慢化剂耦合因子来增加宏观修正的幅度。\n\n数值数据：\n- 对所有测试用例使用固定的材料和能谱参数：\n  - $\\nu = 2.43$。\n  - $\\chi_1 = 0.95$，$\\chi_2 = 0.05$。\n  - $\\Sigma_{f,1} = 0.001$ $\\text{cm}^{-1}$，$\\Sigma_{f,2} = 0.06$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{a,1} = 0.005$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{s,1\\to 2} = 0.08$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{a,2}^{\\text{base}} = 0.12$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{t,\\text{fuel}} = 0.6$ $\\text{cm}^{-1}$。\n  - $\\Sigma_{t,\\text{mod}} = 0.2$ $\\text{cm}^{-1}$。\n  - $\\alpha_0 = 0.8$，$\\beta_0 = 0.2$。\n- 为每个测试用例定义切换情景：\n  - 无修正：$T_{\\text{micro}} = 0$，$T_{\\text{macro}} = 0$。\n  - 仅微观修正：$T_{\\text{micro}} = 1$，$T_{\\text{macro}} = 0$。\n  - 仅宏观修正：$T_{\\text{micro}} = 0$，$T_{\\text{macro}} = 1$。\n  - 双重修正：$T_{\\text{micro}} = 1$，$T_{\\text{macro}} = 1$。\n\n测试套件：\n- 每个测试用例指定$(r_g, C, s)$，$r_g$和$s$的单位为厘米。\n  1. 正常路径：$r_g = 0.05$ $\\text{cm}$，$C = 0.5$，$s = 1.0$ $\\text{cm}$。\n  2. 微观效应可忽略：$r_g = 0.001$ $\\text{cm}$，$C = 0.4$，$s = 2.0$ $\\text{cm}$。\n  3. 宏观效应主导：$r_g = 0.05$ $\\text{cm}$，$C = 0.0$，$s = 0.5$ $\\text{cm}$。\n  4. 宏观效应可忽略，微观效应主导：$r_g = 0.2$ $\\text{cm}$，$C = 0.95$，$s = 5.0$ $\\text{cm}$。\n\n您的任务：\n- 对于每个测试用例，在四种切换情景（无修正、仅微观修正、仅宏观修正、双重修正）下，计算$k_\\infty$和第2群吸收反应率$R_{a,2}$。\n- 在计算$R_{a,2}$之前，将通量矢量$\\Phi$归一化，使得$\\phi_1 + \\phi_2 = 1$。\n- 每个测试用例产生以下输出：\n  - 四个$k_\\infty$的值，顺序为[无修正、仅微观修正、仅宏观修正、双重修正]。\n  - 相对于“无修正”情景，第2群吸收反应率的变化：$\\Delta R_{a,2}^{\\text{micro}} = R_{a,2}^{\\text{micro}} - R_{a,2}^{\\text{none}}$和$\\Delta R_{a,2}^{\\text{macro}} = R_{a,2}^{\\text{macro}} - R_{a,2}^{\\text{none}}$。反应率是以通量归一化单位表示的，由截面乘以归一化通量构成，因此不带物理单位。\n  - 两个指示建模优先级的整数标志，基于变化的幅度：\n    - 如果$\\left|k_\\infty^{\\text{macro}} - k_\\infty^{\\text{none}}\\right| > \\left|k_\\infty^{\\text{micro}} - k_\\infty^{\\text{none}}\\right|$，则$P_k = 0$，否则$P_k = 1$。\n    - 如果$\\left|\\Delta R_{a,2}^{\\text{macro}}\\right| > \\left|\\Delta R_{a,2}^{\\text{micro}}\\right|$，则$P_R = 0$，否则$P_R = 1$。\n\n最终输出格式：\n- 您的程序应产生单行输出，包含一个由各测试用例结果组成的列表，每个测试用例的结果是一个子列表，格式如下：\n$$\n[\\;k_\\infty^{\\text{none}},\\;k_\\infty^{\\text{micro}},\\;k_\\infty^{\\text{macro}},\\;k_\\infty^{\\text{both}},\\;\\Delta R_{a,2}^{\\text{micro}},\\;\\Delta R_{a,2}^{\\text{macro}},\\;P_k,\\;P_R\\;].\n$$\n- 整个输出应严格按照方括号内包含的逗号分隔的子列表形式打印，例如：$[[\\dots],[\\dots],[\\dots],[\\dots]]$。\n\n实现约束：\n- 最终答案必须是一个完整、可运行的程序。\n- 语言：Python，版本$3.12$。\n- 库：NumPy（版本$1.23.5$）和SciPy（版本$1.11.4$）可用，但此任务仅使用Python标准库和NumPy。\n- 不允许用户输入或外部文件。",
            "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n\n**控制方程：**\n- 双能群中子平衡由广义特征值问题$A^{-1} F \\, \\Phi = k_\\infty \\, \\Phi$表示，其中$\\Phi = \\begin{bmatrix}\\phi_1 \\\\ \\phi_2\\end{bmatrix}$。\n- 移出算符矩阵$A$为：\n$$\nA = \\begin{bmatrix}\n\\Sigma_{r,1}  0 \\\\\n-\\Sigma_{s,1\\to 2}  \\Sigma_{a,2}^{\\text{eff}}\n\\end{bmatrix}\n$$\n- 裂变产生算符矩阵$F$为：\n$$\nF = \\begin{bmatrix}\n\\chi_1 \\nu \\Sigma_{f,1}  \\chi_1 \\nu \\Sigma_{f,2} \\\\\n\\chi_2 \\nu \\Sigma_{f,1}  \\chi_2 \\nu \\Sigma_{f,2}\n\\end{bmatrix}\n$$\n- 第1群移出截面为$\\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1\\to 2}$。\n- 第2群吸收反应率为$R_{a,2} = \\Sigma_{a,2}^{\\text{eff}} \\, \\phi_2$。\n- 通量归一化条件为$\\phi_1 + \\phi_2 = 1$。\n\n**$\\Sigma_{a,2}^{\\text{eff}}$的自屏模型：**\n- 有效第2群吸收截面由下式给出：\n$$\n\\Sigma_{a,2}^{\\text{eff}} = \\frac{\\Sigma_{a,2}^{\\text{base}}}{1 + \\alpha_0 \\, \\tau_g \\, T_{\\text{micro}} + \\beta_0 \\, \\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right) \\, (1 - C) \\, T_{\\text{macro}}}\n$$\n- 燃料颗粒的光学厚度为$\\tau_g = \\Sigma_{t,\\text{fuel}} \\, r_g$。\n- 修正项开关为$T_{\\text{micro}}, T_{\\text{macro}} \\in \\{0,1\\}$。\n\n**数值数据：**\n- $\\nu = 2.43$\n- $\\chi_1 = 0.95$, $\\chi_2 = 0.05$\n- $\\Sigma_{f,1} = 0.001$ $\\text{cm}^{-1}$\n- $\\Sigma_{f,2} = 0.06$ $\\text{cm}^{-1}$\n- $\\Sigma_{a,1} = 0.005$ $\\text{cm}^{-1}$\n- $\\Sigma_{s,1\\to 2} = 0.08$ $\\text{cm}^{-1}$\n- $\\Sigma_{a,2}^{\\text{base}} = 0.12$ $\\text{cm}^{-1}$\n- $\\Sigma_{t,\\text{fuel}} = 0.6$ $\\text{cm}^{-1}$\n- $\\Sigma_{t,\\text{mod}} = 0.2$ $\\text{cm}^{-1}$\n- $\\alpha_0 = 0.8$\n- $\\beta_0 = 0.2$\n\n**切换情景：**\n- 无修正：$T_{\\text{micro}} = 0$, $T_{\\text{macro}} = 0$\n- 仅微观修正：$T_{\\text{micro}} = 1$, $T_{\\text{macro}} = 0$\n- 仅宏观修正：$T_{\\text{micro}} = 0$, $T_{\\text{macro}} = 1$\n- 双重修正：$T_{\\text{micro}} = 1$, $T_{\\text{macro}} = 1$\n\n**测试套件：**\n1. $r_g = 0.05$ cm, $C = 0.5$, $s = 1.0$ cm。\n2. $r_g = 0.001$ cm, $C = 0.4$, $s = 2.0$ cm。\n3. $r_g = 0.05$ cm, $C = 0.0$, $s = 0.5$ cm。\n4. $r_g = 0.2$ cm, $C = 0.95$, $s = 5.0$ cm。\n\n**每个测试用例的所需输出：**\n- 四个$k_\\infty$值：$[k_\\infty^{\\text{none}}, k_\\infty^{\\text{micro}}, k_\\infty^{\\text{macro}}, k_\\infty^{\\text{both}}]$。\n- 两个反应率变化：$\\Delta R_{a,2}^{\\text{micro}} = R_{a,2}^{\\text{micro}} - R_{a,2}^{\\text{none}}$ 和 $\\Delta R_{a,2}^{\\text{macro}} = R_{a,2}^{\\text{macro}} - R_{a,2}^{\\text{none}}$。\n- 两个优先级标志：\n  - 如果 $|k_\\infty^{\\text{macro}} - k_\\infty^{\\text{none}}| > |k_\\infty^{\\text{micro}} - k_\\infty^{\\text{none}}|$，则 $P_k = 0$，否则 $P_k = 1$。\n  - 如果 $|\\Delta R_{a,2}^{\\text{macro}}| > |\\Delta R_{a,2}^{\\text{micro}}|$，则 $P_R = 0$，否则 $P_R = 1$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准评估此问题。\n\n1.  **科学性**：该问题在核反应堆物理学领域有坚实的基础。双能群扩散模型是反应堆分析中一种标准（尽管简化）的方法。将无限介质增殖因子$k_\\infty$表述为$A^{-1}F$的主特征值是正确的。有效截面$\\Sigma_{a,2}^{\\text{eff}}$的模型是对共振自屏效应的一种唯象但合理的表述，与Wigner有理近似和等效理论等已建立的理论一致。对颗粒尺寸（$r_g$）、燃料块间距（$s$）和丹科夫因子（$C$）的依赖性具有物理合理性。所有数值参数都在核系统的实际范围内。该问题没有违反任何科学原理。\n2.  **适定性**：该问题在数学上是适定的。它要求解一个$2 \\times 2$矩阵的特征值问题。构建矩阵所需的所有参数和常数都已提供。计算所有所需输出的步骤已明确定义。通量归一化条件确保了反应率的唯一解。对于这样的物理系统，预期会有一个占主导地位的正实数特征值（$k_\\infty$），从而保证一个有意义的解。\n3.  **客观性**：该问题以完全客观和定量的方式陈述。没有主观断言、观点或模棱两可的术语。所有任务都基于精确的数学定义。\n4.  **完整性和一致性**：该问题是自包含的。所有必要的数据、方程和条件都已提供。所提供的信息中没有矛盾。单位在整个问题中保持一致（例如，截面单位为$\\text{cm}^{-1}$，长度单位为$\\text{cm}$）。\n5.  **非平凡或伪深刻**：该问题需要一系列涉及矩阵代数和特征值分析的非平凡计算。它正确地分离了反应堆建模中的一个关键概念权衡（微观与宏观非均质效应），并要求进行定量分析来解决它，因此具有实质性深度。\n\n### 步骤3：结论与行动\n\n此问题有效。它是一个在核反应堆模拟领域内适定、有科学依据且计算具体的题目。将提供完整解答。\n\n## 解答\n\n解答过程是通过对每个测试用例和四种指定的切换情景实施物理模型来进行的。问题的核心是计算无限介质增殖因子$k_\\infty$和相应的中子通量分布$\\Phi$，所有其他量都由此导出。\n\n**步骤1：计算有效第2群吸收截面**\n\n对于每个由一组几何参数$(r_g, C, s)$定义的测试用例，以及由一对$(T_{\\text{micro}}, T_{\\text{macro}})$定义的每种切换情景，第一步是计算有效第2群吸收截面$\\Sigma_{a,2}^{\\text{eff}}$。\n\n公式为：\n$$\n\\Sigma_{a,2}^{\\text{eff}} = \\frac{\\Sigma_{a,2}^{\\text{base}}}{1 + \\alpha_0 \\, \\tau_g \\, T_{\\text{micro}} + \\beta_0 \\, \\left(\\frac{1}{\\Sigma_{t,\\text{mod}} \\, s}\\right) \\, (1 - C) \\, T_{\\text{macro}}}\n$$\n首先，根据颗粒半径$r_g$确定颗粒光学厚度$\\tau_g$：\n$$\n\\tau_g = \\Sigma_{t,\\text{fuel}} \\, r_g\n$$\n使用给定的常数（$\\Sigma_{a,2}^{\\text{base}} = 0.12$，$\\alpha_0 = 0.8$，$\\beta_0 = 0.2$，$\\Sigma_{t,\\text{fuel}}=0.6$，$\\Sigma_{t,\\text{mod}}=0.2$），对每种参数组合计算此表达式。\n\n**步骤2：构建系统矩阵**\n\n计算出$\\Sigma_{a,2}^{\\text{eff}}$后，构建移出矩阵$A$和裂变产生矩阵$F$。矩阵$F$在所有情景和测试用例中是恒定的，而$A$取决于$\\Sigma_{a,2}^{\\text{eff}}$。\n\n第1群移出截面是恒定的：\n$$\n\\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1\\to 2} = 0.005 + 0.08 = 0.085 \\, \\text{cm}^{-1}\n$$\n于是矩阵为：\n$$\nA = \\begin{bmatrix}\n0.085  0 \\\\\n-0.08  \\Sigma_{a,2}^{\\text{eff}}\n\\end{bmatrix}, \\quad\nF = \\begin{bmatrix}\n\\chi_1 \\nu \\Sigma_{f,1}  \\chi_1 \\nu \\Sigma_{f,2} \\\\\n\\chi_2 \\nu \\Sigma_{f,1}  \\chi_2 \\nu \\Sigma_{f,2}\n\\end{bmatrix}\n$$\n代入数值计算$F$：\n$$\nF = \\begin{bmatrix}\n0.95 \\cdot 2.43 \\cdot 0.001  0.95 \\cdot 2.43 \\cdot 0.06 \\\\\n0.05 \\cdot 2.43 \\cdot 0.001  0.05 \\cdot 2.43 \\cdot 0.06\n\\end{bmatrix} = \\begin{bmatrix}\n0.0023085  0.13851 \\\\\n0.0001215  0.00729\n\\end{bmatrix}\n$$\n\n**步骤3：求解特征值问题**\n\n无限介质增殖因子$k_\\infty$是迭代矩阵$M = A^{-1}F$的主（最大）特征值。我们求解特征值问题：\n$$\nM \\Phi = \\lambda \\Phi\n$$\n其中$k_\\infty = \\max(|\\lambda|)$。对应的特征向量$\\Phi$表示相对通量分布$[\\phi_1, \\phi_2]^T$。这是一个标准的数值过程，可以由NumPy等库轻松处理。首先计算矩阵逆$A^{-1}$，然后进行矩阵乘积$M = A^{-1}F$。\n\n**步骤4：通量归一化**\n\n从特征值求解器获得的特征向量$\\Phi_{raw}$是定义在一个乘法常数内的。必须根据问题的约束条件$\\phi_1 + \\phi_2 = 1$对其进行归一化。由于物理通量必须为非负值，因此取特征向量的分量为正值。归一化按以下方式进行：\n$$\n\\Phi = \\frac{\\Phi_{raw}}{|\\phi_{1,raw}| + |\\phi_{2,raw}|} = \\begin{bmatrix}\\phi_1 \\\\ \\phi_2\\end{bmatrix}\n$$\n\n**步骤5：计算反应率**\n\n使用归一化后的热中子通量$\\phi_2$和先前为当前情景确定的有效截面$\\Sigma_{a,2}^{\\text{eff}}$来计算第2群吸收反应率$R_{a,2}$：\n$$\nR_{a,2} = \\Sigma_{a,2}^{\\text{eff}} \\, \\phi_2\n$$\n\n**步骤6：计算最终输出量**\n\n在一个测试用例中为所有四种情景（无修正、仅微观修正、仅宏观修正、双重修正）计算出$k_\\infty$和$R_{a,2}$后，即可组装最终的输出量。\n\n- 收集四个$k_\\infty$的值：$k_\\infty^{\\text{none}}, k_\\infty^{\\text{micro}}, k_\\infty^{\\text{macro}}, k_\\infty^{\\text{both}}$。\n- 计算相对于“无修正”情况的反应率变化：\n  $$\n  \\Delta R_{a,2}^{\\text{micro}} = R_{a,2}^{\\text{micro}} - R_{a,2}^{\\text{none}}\n  $$\n  $$\n  \\Delta R_{a,2}^{\\text{macro}} = R_{a,2}^{\\text{macro}} - R_{a,2}^{\\text{none}}\n  $$\n- 根据微观和宏观修正引起的改变量的大小确定优先级标志$P_k$和$P_R$：\n  - 如果$|k_\\infty^{\\text{macro}} - k_\\infty^{\\text{none}}| > |k_\\infty^{\\text{micro}} - k_\\infty^{\\text{none}}|$，则$P_k = 0$，否则$P_k = 1$。\n  - 如果$|\\Delta R_{a,2}^{\\text{macro}}| > |\\Delta R_{a,2}^{\\text{micro}}|$，则$P_R = 0$，否则$P_R = 1$。值为$0$表示宏观主导，而值为$1$表示微观主导或相等。\n\n对问题陈述中提供的四个测试用例中的每一个重复此过程，并将结果汇总成最终的列表格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the double heterogeneity problem for the given test cases.\n    \"\"\"\n\n    # Define fixed material and spectrum parameters.\n    nu = 2.43\n    chi1, chi2 = 0.95, 0.05\n    Sigma_f1, Sigma_f2 = 0.001, 0.06\n    Sigma_a1 = 0.005\n    Sigma_s12 = 0.08\n    Sigma_a2_base = 0.12\n    Sigma_t_fuel = 0.6\n    Sigma_t_mod = 0.2\n    alpha0 = 0.8\n    beta0 = 0.2\n\n    # Construct the constant fission production matrix F.\n    F = np.array([\n        [chi1 * nu * Sigma_f1, chi1 * nu * Sigma_f2],\n        [chi2 * nu * Sigma_f1, chi2 * nu * Sigma_f2]\n    ])\n\n    # Define the test cases.\n    test_cases = [\n        (0.05, 0.5, 1.0),   # 1. Happy path\n        (0.001, 0.4, 2.0),  # 2. Micro negligible\n        (0.05, 0.0, 0.5),   # 3. Macro dominant\n        (0.2, 0.95, 5.0)    # 4. Macro negligible, micro dominant\n    ]\n    \n    # Define toggling scenarios: (T_micro, T_macro)\n    scenarios = {\n        \"none\": (0, 0),\n        \"micro\": (1, 0),\n        \"macro\": (0, 1),\n        \"both\": (1, 1)\n    }\n\n    all_results = []\n\n    def calculate_physics(case_params, toggles):\n        \"\"\"\n        Calculates k_inf and R_a2 for a given case and scenario.\n        \"\"\"\n        r_g, C, s = case_params\n        T_micro, T_macro = toggles\n\n        # Step 1: Calculate effective group 2 absorption cross section.\n        tau_g = Sigma_t_fuel * r_g\n        micro_term = alpha0 * tau_g * T_micro\n        macro_term = beta0 * (1 / (Sigma_t_mod * s)) * (1 - C) * T_macro\n        Sigma_a2_eff = Sigma_a2_base / (1 + micro_term + macro_term)\n\n        # Step 2: Construct the removal matrix A.\n        Sigma_r1 = Sigma_a1 + Sigma_s12\n        A = np.array([\n            [Sigma_r1, 0],\n            [-Sigma_s12, Sigma_a2_eff]\n        ])\n\n        # Step 3: Solve the eigenvalue problem.\n        if np.linalg.det(A) == 0:\n            return np.nan, np.nan\n        \n        M = np.linalg.inv(A) @ F\n        eigenvalues, eigenvectors = np.linalg.eig(M)\n\n        dominant_idx = np.argmax(eigenvalues.real)\n        k_inf = eigenvalues[dominant_idx].real\n        flux_vector = eigenvectors[:, dominant_idx].real\n\n        # Step 4: Normalize the flux vector.\n        # Physical flux must be positive. Enforce this by taking the absolute value.\n        flux_vector = np.abs(flux_vector)\n        # Normalize such that phi1 + phi2 = 1.\n        flux_sum = np.sum(flux_vector)\n        if flux_sum > 1e-12: # Avoid division by zero\n            normalized_flux = flux_vector / flux_sum\n        else:\n            normalized_flux = np.array([0.0, 0.0])\n        phi1, phi2 = normalized_flux\n\n        # Step 5: Calculate the reaction rate.\n        R_a2 = Sigma_a2_eff * phi2\n\n        return k_inf, R_a2\n\n    for case in test_cases:\n        results = {}\n        # Calculate k_inf and R_a2 for each of the four scenarios.\n        for name, toggles in scenarios.items():\n            k_inf, R_a2 = calculate_physics(case, toggles)\n            results[name] = {\"k_inf\": k_inf, \"R_a2\": R_a2}\n        \n        # Step 6: Compute final output quantities.\n        k_none = results[\"none\"][\"k_inf\"]\n        k_micro = results[\"micro\"][\"k_inf\"]\n        k_macro = results[\"macro\"][\"k_inf\"]\n        k_both = results[\"both\"][\"k_inf\"]\n\n        R_none = results[\"none\"][\"R_a2\"]\n        R_micro = results[\"micro\"][\"R_a2\"]\n        R_macro = results[\"macro\"][\"R_a2\"]\n\n        delta_R_micro = R_micro - R_none\n        delta_R_macro = R_macro - R_none\n        \n        # Determine priority flags.\n        # Pk = 0 if macro > micro, else 1\n        # PR = 0 if macro > micro, else 1\n        delta_k_micro_abs = abs(k_micro - k_none)\n        delta_k_macro_abs = abs(k_macro - k_none)\n        P_k = 0 if delta_k_macro_abs > delta_k_micro_abs else 1\n\n        delta_R_micro_abs = abs(delta_R_micro)\n        delta_R_macro_abs = abs(delta_R_macro)\n        P_R = 0 if delta_R_macro_abs > delta_R_micro_abs else 1\n        \n        # Assemble the results for the current test case.\n        case_results = [\n            k_none, k_micro, k_macro, k_both,\n            delta_R_micro, delta_R_macro,\n            P_k, P_R\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string.\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "精确的反应堆模拟依赖于准确的多群截面。本实践聚焦于一项关键的计算技术——能谱并群，它用于从精细群输运计算结果中生成保持反应率不变的粗群截面。通过实现区域加权和块加权的并群方案，你将掌握处理双非均质系统中多尺度能谱信息的实用方法。",
            "id": "4254705",
            "problem": "考虑一个代表核反应堆模拟中双重非均质燃料系统的微单元，其中燃料核芯嵌入在基体材料中。该微单元被划分为 $R$ 个不相交的区域，每个区域由 $r \\in \\{0,1,\\dots,R-1\\}$ 索引。中子能量域被离散化为 $G$ 个细能量群（简称细群），由 $g \\in \\{0,1,\\dots,G-1\\}$ 索引。一个并群映射将这些细群划分为 $H$ 个粗能量群（简称粗群），由 $H_i$ 索引，其中 $i \\in \\{0,1,\\dots,N_H-1\\}$。粗群由不相交的集合 $H_i \\subset \\{0,1,\\dots,G-1\\}$ 定义，这些集合构成了 $\\{0,1,\\dots,G-1\\}$ 的一个划分。每个区域 $r$ 都具有按区域划分的通量、截面和散射矩阵，这些数据都处于细群水平。任务是推导、实现并验证一种能谱并群方案，该方案使用来自微单元输运计算的按区域划分的通量来生成基体加权和集总加权两种群常数，并定义确保反应率保真度的一致性检查。\n\n从多群框架中的基本中子平衡和反应率定义出发，认识到反应率是微观相互作用按中子通量加权的积分。利用这些基础来推导并群过程必须如何在从细能量群到粗能量群的映射中保持反应率不变。设计一个有原则的算法，在给定按区域划分的细群通量和截面的情况下，该算法能够构建：\n- 按区域的基体加权粗群常数，其在并群过程中保持每个区域内的反应率不变。\n- 微单元水平的集总加权粗群常数，其保持所有区域合并后的总反应率不变。\n\n您的程序必须实现所推导的方案，并验证吸收反应、通过每次裂变的有效中子数（通常表示为 $\\nu$ 乘以裂变截面）产生中子的反应，以及从源粗群到目标粗群的粗群间散射反应的反应率一致性。一致性检查必须量化细群反应率与使用并群常数计算出的相应粗群反应率之间的相对误差，并通过确保所有被检查反应的最大相对误差不超过预设容差来断言保真度。容差是一个无量纲的界限，应设置为 $10^{-10}$。\n\n物理和数值单位：\n- 截面必须以靶（barns）为单位处理。\n- 通量必须以 $\\text{cm}^{-2}\\text{s}^{-1}$ 为单位处理。\n- 体积必须以 $\\text{cm}^3$ 为单位处理。\n- 反应率必须以 $\\text{s}^{-1}$ 为单位处理。\n您的程序将在内部使用上述一致的单位；最终输出将是布尔值，因此无单位。\n\n您必须使用以下测试套件。在所有情况下，粗群划分为两个粗群，定义为 $H_0 = \\{0,1\\}$ 和 $H_1 = \\{2,3\\}$，细群数量为 $G=4$。\n\n测试用例1（正常情况，两个区域同时存在散射和裂变）：\n- 区域数量 $R=2$。\n- 体积：\n$$\\mathbf{V} = [0.3, 0.7] \\text{ cm}^3.$$\n- 按区域的通量：\n$$\\boldsymbol{\\phi}^{(0)} = [2.0, 1.5, 0.8, 0.3] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(1)} = [1.0, 1.2, 1.4, 1.6] \\text{ cm}^{-2}\\text{s}^{-1}.$$\n- 吸收截面：\n$$\\boldsymbol{\\sigma}_a^{(0)} = [0.7, 0.4, 0.2, 0.1] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(1)} = [0.2, 0.15, 0.1, 0.05] \\text{ barns}.$$\n- 每次裂变的有效中子数乘以裂变截面：\n$$\\boldsymbol{\\nu\\sigma}_f^{(0)} = [1.2, 0.8, 0.1, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(1)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}.$$\n- 散射矩阵（从源细群 $g$ 到目标细群 $h$）：\n$$\\mathbf{S}^{(0)} = \\begin{bmatrix}\n0.1  0.6  0.2  0.0\\\\\n0.0  0.05  0.3  0.1\\\\\n0.0  0.0  0.02  0.2\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(1)} = \\begin{bmatrix}\n0.05  0.1  0.0  0.0\\\\\n0.0  0.05  0.05  0.0\\\\\n0.0  0.0  0.02  0.02\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}.$$\n\n测试用例2（边界条件，第二个区域无散射）：\n- 区域数量 $R=2$。\n- 体积：\n$$\\mathbf{V} = [0.3, 0.7] \\text{ cm}^3.$$\n- 按区域的通量：\n$$\\boldsymbol{\\phi}^{(0)} = [1.5, 1.1, 0.7, 0.2] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(1)} = [0.5, 0.6, 0.8, 1.0] \\text{ cm}^{-2}\\text{s}^{-1}.$$\n- 吸收截面：\n$$\\boldsymbol{\\sigma}_a^{(0)} = [0.7, 0.4, 0.2, 0.1] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(1)} = [0.4, 0.3, 0.2, 0.1] \\text{ barns}.$$\n- 每次裂变的有效中子数乘以裂变截面：\n$$\\boldsymbol{\\nu\\sigma}_f^{(0)} = [1.1, 0.7, 0.0, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(1)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}.$$\n- 散射矩阵：\n$$\\mathbf{S}^{(0)} = \\begin{bmatrix}\n0.1  0.5  0.2  0.0\\\\\n0.0  0.05  0.25  0.1\\\\\n0.0  0.0  0.02  0.2\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(1)} = \\mathbf{0}_{4\\times4} \\text{ barns}.$$\n\n测试用例3（边缘情况，所有区域中一个粗群的通量为零）：\n- 区域数量 $R=3$。\n- 体积：\n$$\\mathbf{V} = [0.25, 0.5, 0.25] \\text{ cm}^3.$$\n- 按区域的通量：\n$$\\boldsymbol{\\phi}^{(0)} = [0.0, 0.0, 0.5, 0.9] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(1)} = [0.0, 0.0, 1.0, 1.1] \\text{ cm}^{-2}\\text{s}^{-1}, \\quad \\boldsymbol{\\phi}^{(2)} = [0.0, 0.0, 0.4, 0.8] \\text{ cm}^{-2}\\text{s}^{-1}.$$\n- 吸收截面：\n$$\\boldsymbol{\\sigma}_a^{(0)} = [0.5, 0.35, 0.15, 0.07] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(1)} = [0.25, 0.2, 0.12, 0.06] \\text{ barns}, \\quad \\boldsymbol{\\sigma}_a^{(2)} = [0.3, 0.25, 0.14, 0.07] \\text{ barns}.$$\n- 每次裂变的有效中子数乘以裂变截面：\n$$\\boldsymbol{\\nu\\sigma}_f^{(0)} = [0.8, 0.3, 0.0, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(1)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}, \\quad \\boldsymbol{\\nu\\sigma}_f^{(2)} = [0.0, 0.0, 0.0, 0.0] \\text{ barns}.$$\n- 散射矩阵：\n$$\\mathbf{S}^{(0)} = \\begin{bmatrix}\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.02  0.1\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(1)} = \\begin{bmatrix}\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.02  0.03\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}, \\quad\n\\mathbf{S}^{(2)} = \\begin{bmatrix}\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.0  0.0\\\\\n0.0  0.0  0.01  0.08\\\\\n0.0  0.0  0.0  0.01\n\\end{bmatrix} \\text{ barns}.$$\n\n您的程序必须：\n- 推导并实现能谱并群方案，使用按区域划分的通量来构建用于吸收、每次裂变的有效中子数乘以裂变截面以及群间散射的基体加权和集总加权粗群常数。\n- 在微单元水平上计算吸收、每次裂变的有效中子数乘以裂变截面以及所有 $i \\neq j$ 的情况下从源粗群 $H_i$ 到目标粗群 $H_j$ 的粗群间散射的细群反应率。\n- 使用在基体加权和集总加权方案下得到的并群常数计算相应的粗群反应率，并评估所有这些反应的最大相对误差。\n- 通过检查最大相对误差不超过 $10^{-10}$ 来验证保真度。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例对应一个布尔值，表示该用例的所有保真度检查是否都在容差范围内通过（例如，“[True,False,True]”）。",
            "solution": "当前任务是为双重非均质系统推导并实现一个能谱并群方案，这是核反应堆分析中的一个常见问题。该方案将从细群数据生成粗群核截面，同时保持反应率不变。我们将为两种类型的并群常数建立公式：基体加权（按区域）和集总加权（按微单元）。最后，我们将实现此方案并通过确认使用粗群常数计算的反应率在指定的数值容差内与基准的细群反应率相匹配来验证其保真度。\n\n设系统由 $R$ 个不同区域定义，由 $r \\in \\{0, \\dots, R-1\\}$ 索引，每个区域的体积为 $V^{(r)}$。中子能谱被离散化为 $G$ 个细群，由 $g \\in \\{0, \\dots, G-1\\}$ 索引。这些细群被划分为 $N_H$ 个不相交的粗群 $H_i$，其中 $i \\in \\{0, \\dots, N_H-1\\}$。对于每个区域 $r$，给定大小为 $G$ 的细群标量通量矢量 $\\boldsymbol{\\phi}^{(r)}$、细群吸收截面矢量 $\\boldsymbol{\\sigma}_a^{(r)}$、细群有效中子产生截面矢量 $\\boldsymbol{\\nu\\sigma}_f^{(r)}$，以及大小为 $G \\times G$ 的细群到细群的散射矩阵 $\\mathbf{S}^{(r)}$。\n\n能量群并群的基本原则是保持反应率不变。在区域 $r$ 中，对于一组细群 $G'$，类型为 $x$（例如，吸收、裂变）的反应的总反应率由下式给出：\n$$ \\mathcal{R}_{x}^{(r)}(G') = V^{(r)} \\sum_{g \\in G'} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n在区域 $r$ 中，从一组源群 $G'_{\\text{src}}$ 到一组目标群 $G'_{\\text{dst}}$ 的总散射率是：\n$$ \\mathcal{R}_{s}^{(r)}(G'_{\\text{src}} \\to G'_{\\text{dst}}) = V^{(r)} \\sum_{g \\in G'_{\\text{src}}} \\phi_g^{(r)} \\sum_{h \\in G'_{\\text{dst}}} S_{g \\to h}^{(r)} $$\n\n我们首先将粗群 $H_i$ 和区域 $r$ 中的粗群标量通量简单地定义为组成它的细群通量之和：\n$$ \\Phi_i^{(r)} = \\sum_{g \\in H_i} \\phi_g^{(r)} $$\n\n**1. 基体加权并群方案**\n\n基体加权方案为每个材料区域单独生成粗群常数，保持该区域内的反应率不变。术语“基体加权”指的是使用单一材料（例如，颗粒燃料元件中的基体）的数据进行并群。\n\n为了推导粗群标量截面 $\\Sigma_{x,i}^{(r)}$（对于反应类型 $x=$ 吸收、裂变产生），我们令区域 $r$ 和粗群 $H_i$ 内的细群反应率和粗群反应率相等。\n$$ \\text{细群反应率：} \\quad \\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n$$ \\text{粗群反应率：} \\quad \\Sigma_{x,i}^{(r)} \\Phi_i^{(r)} = \\Sigma_{x,i}^{(r)} \\left(\\sum_{g \\in H_i} \\phi_g^{(r)}\\right) $$\n令两者相等，得到通量加权的粗截面公式：\n$$ \\Sigma_{x,i}^{(r)} = \\frac{\\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)}}{\\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n在分母 $\\Phi_i^{(r)}$ 为零的情况下，分子（细群反应率）也必然为零。粗群反应率 $\\Sigma_{x,i}^{(r)} \\Phi_i^{(r)}$ 也为零。按照惯例，在这种情况下我们定义 $\\Sigma_{x,i}^{(r)} = 0$。\n\n对于从群 $H_i$ 到群 $H_j$ 的粗群散射截面 $\\Sigma_{s, i \\to j}^{(r)}$，我们保持散射率不变：\n$$ \\text{细群反应率：} \\quad \\sum_{g \\in H_i} \\phi_g^{(r)} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} $$\n$$ \\text{粗群反应率：} \\quad \\Sigma_{s, i \\to j}^{(r)} \\Phi_i^{(r)} = \\Sigma_{s, i \\to j}^{(r)} \\left(\\sum_{g \\in H_i} \\phi_g^{(r)}\\right) $$\n这给出了基体加权的粗散射截面：\n$$ \\Sigma_{s, i \\to j}^{(r)} = \\frac{\\sum_{g \\in H_i} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} \\phi_g^{(r)}}{\\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n同样，如果分母为零，则截面定义为零。\n\n**2. 集总加权并群方案**\n\n集总加权方案为整个微单元生成一套单一的粗群常数，保持所有区域求和后的总反应率（“集总”）不变。\n\n对于标量截面 $\\Sigma_{x,i}^{\\text{lump}}$，我们保持每个粗群 $H_i$ 在整个微单元上的体积积分反应率不变：\n$$ \\text{细群反应率：} \\quad \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n相应的粗群反应率使用均匀化截面 $\\Sigma_{x,i}^{\\text{lump}}$ 和该粗群的总通量-体积积分 $\\Psi_i = \\sum_{r=0}^{R-1} V^{(r)} \\Phi_i^{(r)}$。\n$$ \\text{粗群反应率：} \\quad \\Sigma_{x,i}^{\\text{lump}} \\Psi_i = \\Sigma_{x,i}^{\\text{lump}} \\left( \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\phi_g^{(r)} \\right) $$\n令两者相等，得到集总加权的粗截面：\n$$ \\Sigma_{x,i}^{\\text{lump}} = \\frac{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sigma_{x,g}^{(r)} \\phi_g^{(r)}}{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n\n类似地，对于集总加权的散射截面 $\\Sigma_{s, i \\to j}^{\\text{lump}}$，我们保持从 $H_i$ 到 $H_j$ 的总散射率不变：\n$$ \\Sigma_{s, i \\to j}^{\\text{lump}} = \\frac{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} \\phi_g^{(r)}}{\\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\phi_g^{(r)}} $$\n同样的分母为零逻辑也适用：如果源粗群的总通量-体积积分为零，则相应的集总加权截面定义为零。\n\n**3. 反应率保真度检查**\n\n并群方案的验证包括确认用并群常数计算出的总反应率与来自细群数据的真实反应率相匹配。该检查针对吸收、裂变产生和粗群间散射的总微单元反应率进行。\n\n令 $\\mathcal{R}_x^{\\text{fine}}$ 为整个微单元上反应 $x$ 的总细群反应率：\n$$ \\mathcal{R}_x^{\\text{fine}} = \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g=0}^{G-1} \\sigma_{x,g}^{(r)} \\phi_g^{(r)} $$\n使用基体加权常数，粗群反应率为：\n$$ \\mathcal{R}_x^{\\text{coarse, matrix}} = \\sum_{r=0}^{R-1} V^{(r)} \\sum_{i=0}^{N_H-1} \\Sigma_{x,i}^{(r)} \\Phi_i^{(r)} $$\n使用集总加权常数，粗群反应率为：\n$$ \\mathcal{R}_x^{\\text{coarse, lump}} = \\sum_{i=0}^{N_H-1} \\Sigma_{x,i}^{\\text{lump}} \\left( \\sum_{r=0}^{R-1} V^{(r)} \\Phi_i^{(r)} \\right) $$\n根据构造，可以证明 $\\mathcal{R}_x^{\\text{fine}} = \\mathcal{R}_x^{\\text{coarse, matrix}} = \\mathcal{R}_x^{\\text{coarse, lump}}$。\n\n对于从 $H_i$ 到 $H_j$ ($i \\neq j$) 的群间散射率，反应率如下：\n$$ \\mathcal{R}_{s, i \\to j}^{\\text{fine}} = \\sum_{r=0}^{R-1} V^{(r)} \\sum_{g \\in H_i} \\sum_{h \\in H_j} S_{g \\to h}^{(r)} \\phi_g^{(r)} $$\n$$ \\mathcal{R}_{s, i \\to j}^{\\text{coarse, matrix}} = \\sum_{r=0}^{R-1} V^{(r)} \\Sigma_{s, i \\to j}^{(r)} \\Phi_i^{(r)} $$\n$$ \\mathcal{R}_{s, i \\to j}^{\\text{coarse, lump}} = \\Sigma_{s, i \\to j}^{\\text{lump}} \\left( \\sum_{r=0}^{R-1} V^{(r)} \\Phi_i^{(r)} \\right) $$\n同样，根据定义，这些量是相等的。\n\n保真度检查涉及计算每种反应类型 $y$（吸收、裂变产生、散射 $H_i \\to H_j$）的相对误差：\n$$ \\epsilon_y = \\frac{|\\mathcal{R}_y^{\\text{fine}} - \\mathcal{R}_y^{\\text{coarse}}|}{|\\mathcal{R}_y^{\\text{fine}}|} $$\n如果 $\\mathcal{R}_y^{\\text{fine}} = 0$，则当且仅当 $\\mathcal{R}_y^{\\text{coarse}}$ 也为零时，误差取为 $0$。如果考虑浮点不精确性后，所有被检查的反应和两种并群方案的最大相对误差不大于 $10^{-10}$ 的容差，则测试用例通过。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the spectral condensation problem.\n    \"\"\"\n    \n    test_cases = [\n        # Test case 1\n        {\n            \"V\": [0.3, 0.7],\n            \"phis\": [[2.0, 1.5, 0.8, 0.3], [1.0, 1.2, 1.4, 1.6]],\n            \"sigma_as\": [[0.7, 0.4, 0.2, 0.1], [0.2, 0.15, 0.1, 0.05]],\n            \"nu_sigma_fs\": [[1.2, 0.8, 0.1, 0.0], [0.0, 0.0, 0.0, 0.0]],\n            \"Ss\": [\n                [[0.1, 0.6, 0.2, 0.0], [0.0, 0.05, 0.3, 0.1], [0.0, 0.0, 0.02, 0.2], [0.0, 0.0, 0.0, 0.01]],\n                [[0.05, 0.1, 0.0, 0.0], [0.0, 0.05, 0.05, 0.0], [0.0, 0.0, 0.02, 0.02], [0.0, 0.0, 0.0, 0.01]]\n            ],\n            \"H_map\": [[0, 1], [2, 3]],\n            \"tolerance\": 1e-10,\n        },\n        # Test case 2\n        {\n            \"V\": [0.3, 0.7],\n            \"phis\": [[1.5, 1.1, 0.7, 0.2], [0.5, 0.6, 0.8, 1.0]],\n            \"sigma_as\": [[0.7, 0.4, 0.2, 0.1], [0.4, 0.3, 0.2, 0.1]],\n            \"nu_sigma_fs\": [[1.1, 0.7, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]],\n            \"Ss\": [\n                [[0.1, 0.5, 0.2, 0.0], [0.0, 0.05, 0.25, 0.1], [0.0, 0.0, 0.02, 0.2], [0.0, 0.0, 0.0, 0.01]],\n                np.zeros((4,4))\n            ],\n            \"H_map\": [[0, 1], [2, 3]],\n            \"tolerance\": 1e-10,\n        },\n        # Test case 3\n        {\n            \"V\": [0.25, 0.5, 0.25],\n            \"phis\": [[0.0, 0.0, 0.5, 0.9], [0.0, 0.0, 1.0, 1.1], [0.0, 0.0, 0.4, 0.8]],\n            \"sigma_as\": [[0.5, 0.35, 0.15, 0.07], [0.25, 0.2, 0.12, 0.06], [0.3, 0.25, 0.14, 0.07]],\n            \"nu_sigma_fs\": [[0.8, 0.3, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0]],\n            \"Ss\": [\n                [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.02, 0.1], [0.0, 0.0, 0.0, 0.01]],\n                [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.02, 0.03], [0.0, 0.0, 0.0, 0.01]],\n                [[0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.01, 0.08], [0.0, 0.0, 0.0, 0.01]],\n           ],\n            \"H_map\": [[0, 1], [2, 3]],\n            \"tolerance\": 1e-10,\n        },\n    ]\n\n    results = [run_fidelity_check(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_fidelity_check(params):\n    \"\"\"\n    Performs spectral condensation and fidelity checks for a single test case.\n    \"\"\"\n    # Unpack parameters and convert to numpy arrays for vectorization\n    V = np.array(params['V'])\n    phis = [np.array(p) for p in params['phis']]\n    sigma_as = [np.array(s) for s in params['sigma_as']]\n    nu_sigma_fs = [np.array(n) for n in params['nu_sigma_fs']]\n    Ss = [np.array(s) for s in params['Ss']]\n    H_map = params['H_map']\n    tolerance = params['tolerance']\n    \n    R = len(V)\n    N_H = len(H_map)\n    max_rel_error = 0.0\n\n    def calculate_relative_error(fine_val, coarse_val):\n        if np.isclose(fine_val, 0.0):\n            return 0.0 if np.isclose(coarse_val, 0.0, atol=1e-15, rtol=0) else np.inf\n        return np.abs(fine_val - coarse_val) / np.abs(fine_val)\n\n    # --- Pre-calculate coarse fluxes ---\n    # Per-region coarse fluxes: Phi_r has shape (R, N_H)\n    Phi_r = np.array([[np.sum(phis[r][h_indices]) for h_indices in H_map] for r in range(R)])\n            \n    # Total coarse flux-volume integral: Psi_i has shape (N_H,)\n    Psi_i = np.sum(V[:, np.newaxis] * Phi_r, axis=0)\n\n    # === Check Scalar Reactions (Absorption and Fission Production) ===\n    scalar_rx_data = {'absorption': sigma_as, 'nu_fission': nu_sigma_fs}\n    for rx_name, sigmas_fine in scalar_rx_data.items():\n        # --- Fine Rate ---\n        RR_fine = np.sum([V[r] * np.sum(sigmas_fine[r] * phis[r]) for r in range(R)])\n\n        # --- Coarse Rates ---\n        # --- Matrix-weighted ---\n        RR_coarse_matrix = 0.0\n        for r in range(R):\n            for i, h_indices in enumerate(H_map):\n                num = np.sum(sigmas_fine[r][h_indices] * phis[r][h_indices])\n                den = Phi_r[r, i]\n                Sigma_r_i = num / den if not np.isclose(den, 0.0) else 0.0\n                RR_coarse_matrix += V[r] * Sigma_r_i * Phi_r[r, i]\n        max_rel_error = max(max_rel_error, calculate_relative_error(RR_fine, RR_coarse_matrix))\n\n        # --- Lump-weighted ---\n        RR_coarse_lump = 0.0\n        for i, h_indices in enumerate(H_map):\n            num = np.sum([V[r] * np.sum(sigmas_fine[r][h_indices] * phis[r][h_indices]) for r in range(R)])\n            den = Psi_i[i]\n            Sigma_lump_i = num / den if not np.isclose(den, 0.0) else 0.0\n            RR_coarse_lump += Sigma_lump_i * Psi_i[i]\n        max_rel_error = max(max_rel_error, calculate_relative_error(RR_fine, RR_coarse_lump))\n    \n    # === Check Inter-Group Scattering Reactions ===\n    for i, h_i_indices in enumerate(H_map):\n        for j, h_j_indices in enumerate(H_map):\n            if i == j: \n                continue\n\n            # --- Fine Rate ---\n            RR_s_ij_fine = np.sum([\n                V[r] * np.sum(Ss[r][np.ix_(h_i_indices, h_j_indices)] * phis[r][h_i_indices, np.newaxis])\n                for r in range(R)\n            ])\n\n            # --- Coarse Rates ---\n            # --- Matrix-weighted ---\n            RR_s_ij_coarse_matrix = 0.0\n            for r in range(R):\n                num = np.sum(Ss[r][np.ix_(h_i_indices, h_j_indices)] * phis[r][h_i_indices, np.newaxis])\n                den = Phi_r[r, i]\n                Sigma_s_ij_r = num / den if not np.isclose(den, 0.0) else 0.0\n                RR_s_ij_coarse_matrix += V[r] * Sigma_s_ij_r * Phi_r[r, i]\n            max_rel_error = max(max_rel_error, calculate_relative_error(RR_s_ij_fine, RR_s_ij_coarse_matrix))\n\n            # --- Lump-weighted ---\n            num_lump = np.sum([\n                V[r] * np.sum(Ss[r][np.ix_(h_i_indices, h_j_indices)] * phis[r][h_i_indices, np.newaxis])\n                for r in range(R)\n            ])\n            den_lump = Psi_i[i]\n            Sigma_s_ij_lump = num_lump / den_lump if not np.isclose(den_lump, 0.0) else 0.0\n            RR_s_ij_coarse_lump = Sigma_s_ij_lump * Psi_i[i]\n            max_rel_error = max(max_rel_error, calculate_relative_error(RR_s_ij_fine, RR_s_ij_coarse_lump))\n    \n    return max_rel_error = tolerance\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}