{
    "hands_on_practices": [
        {
            "introduction": "The point kinetics equations (PKE) form a stiff system of ordinary differential equations due to the vast difference in timescales between prompt neutron lifetime ($ \\Lambda $) and delayed precursor decay ($1/\\lambda_i$). This exercise lays the essential groundwork for reactor simulation by guiding you through the implementation of a numerically stable solver. You will derive and code the backward Euler method, a fundamental implicit technique that overcomes the stability limitations of explicit methods when applied to the PKEs, ensuring reliable solutions regardless of the chosen time step size .",
            "id": "4256381",
            "problem": "Consider the nuclear reactor point kinetics model obtained by integrating the space-dependent neutron balance and delayed neutron precursor balance equations over the reactor core. Let $n(t)$ denote the normalized neutron density (dimensionless), and let $C_i(t)$ denote the normalized concentration of delayed neutron precursors in the $i$-th group (dimensionless), for $i=1,\\dots,M$. The fundamental model, expressed as a coupled system of linear ordinary differential equations (ODEs), is\n$$\n\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^M \\lambda_i C_i(t),\n$$\n$$\n\\frac{dC_i}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t), \\quad i=1,\\dots,M,\n$$\nwhere $\\rho(t)$ is the reactivity (dimensionless), $\\beta = \\sum_{i=1}^M \\beta_i$ is the total delayed neutron fraction (dimensionless), $\\beta_i$ are group-wise delayed fractions (dimensionless), $\\lambda_i$ are precursor decay constants in $\\mathrm{s}^{-1}$, and $\\Lambda$ is the prompt neutron generation time in $\\mathrm{s}$. Assume the initial condition corresponds to a steady state at zero reactivity, namely $n(0)=n_0$ and $C_i(0)=\\frac{\\beta_i}{\\Lambda \\lambda_i} n_0$ for all $i=1,\\dots,M$.\n\nYour task is to derive, from first principles of backward Euler (BE) discretization for linear ODE systems, unconditional-stability discrete update equations for $n^{k+1}$ and $C_i^{k+1}$ at time $t^{k+1}=t^k + \\Delta t$, using $\\rho^{k+1}=\\rho(t^{k+1})$ in the implicit evaluation. Use these derived equations to implement a time-marching algorithm that advances the solution across a uniform time grid $\\{t^k\\}_{k=0}^{N}$ with step size $\\Delta t$ in seconds, where $t^0=0$ and $t^N=T$.\n\nThe program must implement the derived backward Euler update equations exactly and produce the requested outputs for the following scientifically realistic and self-consistent test suite. In all tests, use $n_0 = 1$ (dimensionless). For all cases involving delayed neutron groups, use $M=6$ groups with\n$$\n\\boldsymbol{\\lambda} = [0.0124,\\, 0.0305,\\, 0.111,\\, 0.301,\\, 1.14,\\, 3.01] \\ \\mathrm{s}^{-1},\n$$\n$$\n\\boldsymbol{\\beta} = [0.000215,\\, 0.001424,\\, 0.001274,\\, 0.002568,\\, 0.000748,\\, 0.000273],\n$$\nso that $\\beta = \\sum_{i=1}^{6} \\beta_i = 0.006502$. Time is measured in seconds, and the neutron generation time is specified per case. The reactivity profiles $\\rho(t)$ are defined per case as either a step or a ramp.\n\nTest cases to implement and evaluate:\n- Case A (general happy path, small time step): $M=6$, $\\Lambda = 10^{-4}$ $\\mathrm{s}$, step reactivity $\\rho(t) = 0.002$ for all $t \\ge 0$, final time $T = 0.1$ $\\mathrm{s}$, step size $\\Delta t = 0.001$ $\\mathrm{s}$. Output $n(T)$ (dimensionless).\n- Case B (large time step, same physics as Case A): $M=6$, $\\Lambda = 10^{-4}$ $\\mathrm{s}$, step reactivity $\\rho(t) = 0.002$, final time $T = 0.1$ $\\mathrm{s}$, step size $\\Delta t = 0.05$ $\\mathrm{s}$. Output $n(T)$ (dimensionless).\n- Case C (boundary case, no delayed neutrons): $M=0$ (so $\\beta=0$ and no $C_i$ variables), $\\Lambda = 10^{-4}$ $\\mathrm{s}$, step reactivity $\\rho(t) = 0.002$, final time $T = 0.1$ $\\mathrm{s}$, step size $\\Delta t = 0.02$ $\\mathrm{s}$. Output $n(T)$ (dimensionless).\n- Case D (negative reactivity decay): $M=6$, $\\Lambda = 10^{-4}$ $\\mathrm{s}$, step reactivity $\\rho(t) = -0.003$, final time $T = 0.2$ $\\mathrm{s}$, step size $\\Delta t = 0.02$ $\\mathrm{s}$. Output $n(T)$ (dimensionless).\n- Case E (stiff precursors, very large time step, time-dependent reactivity): $M=6$, precursor decay constants scaled by a factor of $10$ so that\n$$\n\\boldsymbol{\\lambda}^{\\star} = [0.124,\\, 0.305,\\, 1.11,\\, 3.01,\\, 11.4,\\, 30.1] \\ \\mathrm{s}^{-1},\n$$\n$\\Lambda = 10^{-4}$ $\\mathrm{s}$, ramp reactivity $\\rho(t) = 0.001 \\cdot \\frac{t}{T}$ for $t \\in [0,T]$, final time $T = 0.4$ $\\mathrm{s}$, step size $\\Delta t = 0.2$ $\\mathrm{s}$. Output $n(T)$ (dimensionless).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases A through E, that is, $[n_A(T), n_B(T), n_C(T), n_D(T), n_E(T)]$ with each entry a floating-point number (dimensionless). No other text should be printed.",
            "solution": "The problem requires the derivation and implementation of a backward Euler (BE) numerical scheme to solve the nuclear reactor point kinetics equations.\n\nThe governing system of ordinary differential equations (ODEs) is given by:\n$$\n\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^M \\lambda_i C_i(t)\n$$\n$$\n\\frac{dC_i}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t), \\quad i=1,\\dots,M\n$$\nHere, $n(t)$ is the neutron density, $C_i(t)$ are the delayed neutron precursor concentrations, $\\rho(t)$ is reactivity, $\\Lambda$ is the prompt neutron generation time, $\\beta_i$ are the delayed neutron fractions for group $i$, $\\beta = \\sum_{i=1}^M \\beta_i$ is the total delayed neutron fraction, and $\\lambda_i$ are the precursor decay constants.\n\nThe initial conditions at $t=0$ correspond to a steady state with zero reactivity ($\\rho=0$), which implies $\\frac{dn}{dt}=0$ and $\\frac{dC_i}{dt}=0$. This yields:\n$$\nn(0) = n_0\n$$\n$$\nC_i(0) = \\frac{\\beta_i}{\\Lambda \\lambda_i} n_0\n$$\n\nThe task is to derive the update equations using the backward Euler method. For a general ODE $\\frac{dy}{dt} = f(t, y)$, the BE discretization is:\n$$\n\\frac{y^{k+1} - y^k}{\\Delta t} = f(t^{k+1}, y^{k+1})\n$$\nwhere $y^k \\approx y(t^k)$, $t^{k+1} = t^k + \\Delta t$, and $\\Delta t$ is the constant time step size.\n\nApplying this to the point kinetics equations, we evaluate the right-hand side at the future time step $t^{k+1}$:\n$$\n\\frac{n^{k+1} - n^k}{\\Delta t} = \\frac{\\rho^{k+1} - \\beta}{\\Lambda} n^{k+1} + \\sum_{i=1}^M \\lambda_i C_i^{k+1} \\quad (1)\n$$\n$$\n\\frac{C_i^{k+1} - C_i^k}{\\Delta t} = \\frac{\\beta_i}{\\Lambda} n^{k+1} - \\lambda_i C_i^{k+1}, \\quad i=1,\\dots,M \\quad (2)\n$$\nwhere $\\rho^{k+1} = \\rho(t^{k+1})$. This is a coupled system of $M+1$ linear algebraic equations for the unknowns $n^{k+1}$ and $\\{C_i^{k+1}\\}_{i=1}^M$.\n\nWe must solve this system. First, from equation (2), we isolate $C_i^{k+1}$ to express it in terms of the known $C_i^k$ and the still unknown $n^{k+1}$:\n$$\nC_i^{k+1} - C_i^k = \\Delta t \\left( \\frac{\\beta_i}{\\Lambda} n^{k+1} - \\lambda_i C_i^{k+1} \\right)\n$$\n$$\nC_i^{k+1} + \\Delta t \\lambda_i C_i^{k+1} = C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}\n$$\n$$\nC_i^{k+1} (1 + \\Delta t \\lambda_i) = C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}\n$$\n$$\nC_i^{k+1} = \\frac{C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}}{1 + \\Delta t \\lambda_i} \\quad (3)\n$$\nThis equation provides the update for each precursor concentration once $n^{k+1}$ is known.\n\nNext, we substitute this expression for $C_i^{k+1}$ back into equation (1) to obtain a single equation for $n^{k+1}$:\n$$\n\\frac{n^{k+1} - n^k}{\\Delta t} = \\frac{\\rho^{k+1} - \\beta}{\\Lambda} n^{k+1} + \\sum_{i=1}^M \\lambda_i \\left( \\frac{C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}}{1 + \\Delta t \\lambda_i} \\right)\n$$\nTo solve for $n^{k+1}$, we group all terms involving $n^{k+1}$ on one side of the equation.\n$$\nn^{k+1} - n^k = \\frac{\\Delta t}{\\Lambda}(\\rho^{k+1} - \\beta) n^{k+1} + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i} + n^{k+1} \\sum_{i=1}^M \\frac{\\Delta t^2 \\lambda_i \\beta_i}{\\Lambda(1 + \\Delta t \\lambda_i)}\n$$\n$$\nn^{k+1} - \\frac{\\Delta t}{\\Lambda}(\\rho^{k+1} - \\beta) n^{k+1} - n^{k+1} \\sum_{i=1}^M \\frac{\\Delta t^2 \\lambda_i \\beta_i}{\\Lambda(1 + \\Delta t \\lambda_i)} = n^k + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i}\n$$\nFactoring out $n^{k+1}$ from the left-hand side:\n$$\nn^{k+1} \\left( 1 - \\frac{\\Delta t}{\\Lambda}(\\rho^{k+1} - \\beta) - \\frac{\\Delta t^2}{\\Lambda} \\sum_{i=1}^M \\frac{\\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i} \\right) = n^k + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i}\n$$\nThe coefficient of $n^{k+1}$ can be simplified by substituting $\\beta = \\sum_{i=1}^M \\beta_i$:\n$$\n1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\beta_i - \\frac{\\Delta t}{\\Lambda} \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i}\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\left( \\beta_i - \\frac{\\Delta t \\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i} \\right)\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\left( \\frac{\\beta_i(1 + \\Delta t \\lambda_i) - \\Delta t \\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i} \\right)\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\frac{\\beta_i}{1 + \\Delta t \\lambda_i}\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda} \\left( \\rho^{k+1} - \\sum_{i=1}^M \\frac{\\beta_i}{1 + \\Delta t \\lambda_i} \\right)\n$$\nThis gives the final update equation for $n^{k+1}$:\n$$\nn^{k+1} = \\frac{n^k + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i}}{1 - \\frac{\\Delta t}{\\Lambda} \\left( \\rho^{k+1} - \\sum_{i=1}^M \\frac{\\beta_i}{1 + \\Delta t \\lambda_i} \\right)} \\quad (4)\n$$\nThe algorithm for advancing the solution from time $t^k$ to $t^{k+1}$ is as follows:\n1.  Given $n^k$, $\\{C_i^k\\}$, and parameters $\\Lambda, \\{\\beta_i\\}, \\{\\lambda_i\\}, \\Delta t$.\n2.  Determine the reactivity at the new time step, $\\rho^{k+1} = \\rho(t^{k+1})$.\n3.  Calculate $n^{k+1}$ using equation (4). This requires computing two sums over the precursor groups.\n4.  Calculate each $C_i^{k+1}$ using equation (3) and the newly computed $n^{k+1}$.\n5.  Repeat for the desired number of time steps.\n\nThis procedure, based on the unconditionally stable backward Euler method, is implemented for each test case. For Case C where $M=0$, the sums are empty, and the equations simplify to $n^{k+1} = n^k / (1 - \\frac{\\Delta t}{\\Lambda} \\rho^{k+1})$ and there are no precursor equations, which is a direct consequence of the derived general form.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the point kinetics equations for a series of test cases\n    using the backward Euler method.\n    \"\"\"\n\n    def run_simulation(M, Lambda, beta_i, lambda_i, rho_func, T, dt, n0):\n        \"\"\"\n        Runs a single point kinetics simulation.\n        \n        Args:\n            M (int): Number of delayed neutron groups.\n            Lambda (float): Prompt neutron generation time.\n            beta_i (np.array): Group-wise delayed neutron fractions.\n            lambda_i (np.array): Precursor decay constants.\n            rho_func (callable): Function for reactivity rho(t, T).\n            T (float): Final time.\n            dt (float): Time step size.\n            n0 (float): Initial neutron density.\n        \n        Returns:\n            float: Neutron density at final time T.\n        \"\"\"\n        num_steps = int(round(T / dt))\n        \n        # Initial conditions\n        n_k = n0\n        \n        if M > 0:\n            # Check for lambda_i == 0 to avoid division by zero in steady state C_i calculation\n            if np.any(lambda_i == 0):\n                raise ValueError(\"lambda_i cannot contain zero for steady-state initialization.\")\n            C_k = (beta_i / (Lambda * lambda_i)) * n0\n        else:\n            C_k = np.array([])\n\n        one_plus_dt_lambda = 1.0 + dt * lambda_i\n        \n        for k in range(num_steps):\n            t_kp1 = (k + 1) * dt\n            rho_kp1 = rho_func(t_kp1, T)\n\n            if M > 0:\n                # Sum terms for the n_kp1 update equation\n                S1_k = np.sum((dt * lambda_i * C_k) / one_plus_dt_lambda)\n                S2 = np.sum(beta_i / one_plus_dt_lambda)\n\n                # Numerator and denominator for n_kp1\n                numerator = n_k + S1_k\n                denominator = 1.0 - (dt / Lambda) * (rho_kp1 - S2)\n                \n                n_kp1 = numerator / denominator\n                \n                # Update precursor concentrations\n                C_kp1 = (C_k + (dt * beta_i / Lambda) * n_kp1) / one_plus_dt_lambda\n            else: # Case M=0\n                denominator = 1.0 - (dt/Lambda) * rho_kp1\n                n_kp1 = n_k / denominator\n                C_kp1 = np.array([])\n            \n            # Update state for next iteration\n            n_k = n_kp1\n            C_k = C_kp1\n            \n        return n_k\n\n    # Common parameters\n    n0 = 1.0\n    lambda_base = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    beta_base = np.array([0.000215, 0.001424, 0.001274, 0.002568, 0.000748, 0.000273])\n    \n    test_cases = [\n        # Case A\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base,\n         'rho_func': lambda t, T: 0.002, 'T': 0.1, 'dt': 0.001, 'n0': n0},\n        # Case B\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base,\n         'rho_func': lambda t, T: 0.002, 'T': 0.1, 'dt': 0.05, 'n0': n0},\n        # Case C\n        {'M': 0, 'Lambda': 1e-4, 'beta_i': np.array([]), 'lambda_i': np.array([]),\n         'rho_func': lambda t, T: 0.002, 'T': 0.1, 'dt': 0.02, 'n0': n0},\n        # Case D\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base,\n         'rho_func': lambda t, T: -0.003, 'T': 0.2, 'dt': 0.02, 'n0': n0},\n        # Case E\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base * 10.0,\n         'rho_func': lambda t, T: 0.001 * t / T, 'T': 0.4, 'dt': 0.2, 'n0': n0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a robust numerical solver, we can now connect our time-dependent simulations to the foundational theories of reactor kinetics. This practice focuses on validating the numerical model against an analytical benchmark for a step reactivity insertion. You will use your implicit solver to simulate a subprompt-critical transient until it reaches a stable exponential growth, then extract the reactor period from the simulation data and compare it to the prediction from the classic inhour relation, deepening your understanding of asymptotic reactor behavior .",
            "id": "4239337",
            "problem": "You are asked to design and implement a complete, runnable program that numerically integrates the reactor point kinetics equations under a step reactivity insertion using a fully implicit method and compares the numerically inferred reactor period to the prediction from the inhour relation. The context is a subprompt-critical step insertion with six delayed neutron groups. The program must adhere to the following scientific, mathematical, and output requirements.\n\nThe fundamental base for this problem is the point kinetics model, which represents the neutron balance and the dynamics of delayed neutron precursors in a well-mixed reactor core. Under the point approximation, the neutron population is denoted by $n(t)$ and the delayed neutron precursor concentrations for six groups are $C_i(t)$ for $i=1,\\dots,6$. The reactivity is $ \\rho(t) $, the total delayed neutron fraction is $ \\beta = \\sum_{i=1}^{6} \\beta_i $, the mean neutron generation time is $ \\Lambda $, and the decay constants are $ \\lambda_i $. A subprompt-critical step insertion means $ \\rho < \\beta $. The initial condition is a steady state at $ t = 0^{-} $ with $ \\rho(0^{-}) = 0 $, normalized neutron population $ n(0^{-}) = 1 $ in arbitrary power units, and precursor concentrations $ C_i(0^{-}) $ consistent with steady state. At $ t = 0^{+} $, a step reactivity $ \\rho(t) = \\rho_{\\text{step}} $ for all $ t \\ge 0 $ is applied.\n\nYour task is to:\n- Implement a fully implicit time discretization for the coupled first-order linear ordinary differential equations of the point kinetics model with six delayed neutron groups (without providing any shortcut formulas in the problem statement).\n- Use appropriate initial conditions consistent with a pre-step steady state and the definition of delayed neutron precursors.\n- Simulate the response for a sufficiently long duration so that the asymptotic exponential behavior is reached. Estimate the asymptotic exponential growth constant $ \\alpha $ from the slope of $ \\ln n(t) $ over a late-time window, and report the reactor period $ T_{\\text{num}} = 1/\\alpha $ in seconds.\n- Compute the asymptotic exponential growth constant $ \\alpha_{\\text{inhour}} $ using the well-tested inhour relation for subprompt-critical transients and obtain $ T_{\\text{inhour}} = 1/\\alpha_{\\text{inhour}} $ in seconds.\n- Compare $ T_{\\text{num}} $ to $ T_{\\text{inhour}} $ by reporting the relative difference defined as $ (T_{\\text{num}} - T_{\\text{inhour}})/T_{\\text{inhour}} $ (a dimensionless decimal). No percentages are permitted; express the answer as a decimal fraction.\n\nPhysical and numerical units:\n- Express all time-related quantities in seconds.\n- The step reactivity is given in pcm (per cent mille), where $ 1 $ pcm $=10^{-5}$ in dimensionless reactivity units. You must convert to a dimensionless $ \\rho $ inside the program.\n\nImplicit method and initialization:\n- Use a fully implicit scheme (for example, backward Euler) to advance $ n(t) $ and $ C_i(t) $ jointly at each time step, solving the resulting linear system for $ n_{k+1} $ and $ C_{i,k+1} $ from $ n_k $ and $ C_{i,k} $.\n- Prior to the step, the reactor is at steady state with $ \\rho(0^{-}) = 0 $. Set $ n(0) = 1 $ and $ C_i(0) $ consistent with the steady-state precursor balance.\n\nTest suite and parameters:\nImplement three test cases that cover typical thermal behavior, fast reactor behavior, and a near-prompt-critical boundary case, all with six delayed groups using the same decay constants $ \\lambda_i $ but different total delayed fractions $ \\beta $ and mean generation times $ \\Lambda $. In all cases use the same base set of six-group decay constants:\n- $ \\lambda = [\\,0.0124,\\;0.0305,\\;0.111,\\;0.301,\\;1.14,\\;3.01\\,] $ in s$^{-1}$.\n\nUse the following base six-group delayed neutron fractions for a typical thermal system (sum $ \\beta \\approx 0.006502 $):\n- $ \\beta^{\\text{base}} = [\\,0.000215,\\;0.001424,\\;0.001274,\\;0.002568,\\;0.000748,\\;0.000273\\,] $.\n\nFor cases that require a different total $ \\beta $, scale $ \\beta^{\\text{base}} $ proportionally so that $ \\sum_i \\beta_i $ equals the specified total.\n\nEach case uses a step reactivity $ \\rho_{\\text{step}} = 200 $ pcm, i.e., $ \\rho = 200 \\times 10^{-5} $ dimensionless. The test suite is:\n\n- Case $A$ (thermal reference):\n  - $ \\beta_i = \\beta^{\\text{base}} $.\n  - $ \\Lambda = 1.0 \\times 10^{-5} $ s.\n  - Time step $ \\Delta t = 5.0 \\times 10^{-3} $ s.\n  - Simulation duration $ T_{\\text{end}} = 60.0 $ s.\n\n- Case $B$ (fast spectrum, reduced delayed fraction):\n  - Scale $ \\beta^{\\text{base}} $ to $ \\sum_i \\beta_i = 0.0030 $.\n  - $ \\Lambda = 5.0 \\times 10^{-7} $ s.\n  - Time step $ \\Delta t = 2.5 \\times 10^{-3} $ s.\n  - Simulation duration $ T_{\\text{end}} = 40.0 $ s.\n\n- Case $C$ (near-prompt-critical boundary, subprompt-critical):\n  - Scale $ \\beta^{\\text{base}} $ to $ \\sum_i \\beta_i = 0.0022 $.\n  - $ \\Lambda = 2.0 \\times 10^{-5} $ s.\n  - Time step $ \\Delta t = 5.0 \\times 10^{-3} $ s.\n  - Simulation duration $ T_{\\text{end}} = 80.0 $ s.\n\nRequired final output format:\n- Your program should produce a single line of output containing the relative differences for the three cases as a comma-separated list enclosed in square brackets, for example $ [r_A,r_B,r_C] $, where each entry is the decimal value of $ (T_{\\text{num}} - T_{\\text{inhour}})/T_{\\text{inhour}} $ for the corresponding case.\n- The values must be printed in the exact required format with no additional text.\n\nScientific realism and constraints:\n- Ensure $ \\rho < \\beta $ for all cases (subprompt-critical).\n- The program must be self-contained, not require any user input or external files, and be runnable in a modern environment.",
            "solution": "The problem has been validated and is determined to be scientifically grounded, well-posed, and objective. It presents a standard task in computational reactor physics, requiring the numerical solution of the point kinetics equations and comparison with an analytical benchmark. All necessary parameters and conditions are provided, and there are no internal contradictions or violations of physical principles.\n\nThe solution proceeds as follows: First, we state the governing equations of the point kinetics model. Second, we derive the initial conditions from the specified steady-state reactor. Third, we develop the fully implicit numerical integration scheme. Fourth, we formulate the inhour relation to find the analytical asymptotic period. Finally, we describe the method for extracting the numerical period from the simulation data to compute the required relative difference.\n\nThe reactor point kinetics equations for neutron population density $n(t)$ and the concentrations of $i=1, \\dots, 6$ delayed neutron precursor groups $C_i(t)$ are a system of $7$ coupled first-order ordinary differential equations:\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{6} \\lambda_i C_i(t)\n$$\n$$\n\\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t)\n$$\nHere, $\\rho(t)$ is the reactivity, $\\Lambda$ is the mean neutron generation time, $\\lambda_i$ are the decay constants of the precursors, $\\beta_i$ are the delayed neutron fractions for each group, and $\\beta = \\sum_{i=1}^{6} \\beta_i$ is the total delayed neutron fraction.\n\nThe problem specifies an initial steady state at time $t=0^{-}$ with $\\rho(0^{-}) = 0$. In steady state, all time derivatives are zero. Setting $\\frac{dn}{dt}=0$ and $\\frac{dC_i}{dt}=0$ in the equations above provides the initial conditions. With the normalization $n(0)=1$, the precursor concentrations are determined from the second equation:\n$$\n0 = \\frac{\\beta_i}{\\Lambda} n(0) - \\lambda_i C_i(0) \\implies C_i(0) = \\frac{\\beta_i n(0)}{\\lambda_i \\Lambda} = \\frac{\\beta_i}{\\lambda_i \\Lambda}\n$$\nThese values for $n(0)$ and $C_i(0)$ are used to start the simulation at $t=0$, at which point a step reactivity $\\rho(t) = \\rho_{\\text{step}}$ for $t \\ge 0$ is introduced.\n\nTo numerically integrate this system, we employ a fully implicit (Backward Euler) scheme. Time is discretized into steps of size $\\Delta t$, such that $t_k = k \\Delta t$. The time derivative of a variable $y(t)$ is approximated as $\\frac{dy}{dt} \\approx \\frac{y_{k+1} - y_k}{\\Delta t}$, where all terms on the right-hand side of the ODE are evaluated at the future time step $t_{k+1}$.\nApplying this to the point kinetics equations yields:\n$$\n\\frac{n_{k+1} - n_k}{\\Delta t} = \\frac{\\rho_{\\text{step}} - \\beta}{\\Lambda} n_{k+1} + \\sum_{i=1}^{6} \\lambda_i C_{i, k+1}\n$$\n$$\n\\frac{C_{i, k+1} - C_{i, k}}{\\Delta t} = \\frac{\\beta_i}{\\Lambda} n_{k+1} - \\lambda_i C_{i, k+1}\n$$\nThis is a system of linear algebraic equations for the unknown state $[n_{k+1}, C_{1,k+1}, \\dots, C_{6,k+1}]^T$. We can solve it efficiently by substitution. From the second equation for each precursor group $i$, we can express $C_{i, k+1}$ in terms of $n_{k+1}$ and known values from step $k$:\n$$\nC_{i, k+1}(1 + \\Delta t \\lambda_i) = C_{i, k} + \\frac{\\Delta t \\beta_i}{\\Lambda} n_{k+1} \\implies C_{i, k+1} = \\frac{C_{i, k} + \\frac{\\Delta t \\beta_i}{\\Lambda} n_{k+1}}{1 + \\Delta t \\lambda_i}\n$$\nSubstituting this expression for $C_{i, k+1}$ into the discretized neutron balance equation allows us to solve for $n_{k+1}$:\n$$\n\\frac{n_{k+1} - n_k}{\\Delta t} = \\frac{\\rho_{\\text{step}} - \\beta}{\\Lambda} n_{k+1} + \\sum_{i=1}^{6} \\lambda_i \\left( \\frac{C_{i, k} + \\frac{\\Delta t \\beta_i}{\\Lambda} n_{k+1}}{1 + \\Delta t \\lambda_i} \\right)\n$$\nRearranging to isolate $n_{k+1}$ on the left-hand side:\n$$\nn_{k+1} \\left[ \\frac{1}{\\Delta t} - \\frac{\\rho_{\\text{step}} - \\beta}{\\Lambda} - \\sum_{i=1}^{6} \\frac{\\lambda_i \\Delta t \\beta_i / \\Lambda}{1 + \\Delta t \\lambda_i} \\right] = \\frac{n_k}{\\Delta t} + \\sum_{i=1}^{6} \\frac{\\lambda_i C_{i, k}}{1 + \\Delta t \\lambda_i}\n$$\nThis equation is of the form $A \\cdot n_{k+1} = B_k$, where the coefficient $A$ is constant throughout the simulation (since all its constituent parameters are constant) and $B_k$ depends on the state at the previous time step $k$. At each step, we calculate $n_{k+1} = B_k / A$ and then use this new value to update each $C_{i, k+1}$.\n\nFor a step reactivity insertion, the neutron population eventually grows exponentially as $n(t) \\sim e^{\\alpha t}$, where $\\alpha$ is a constant. The reactor period is defined as $T = 1/\\alpha$. The analytical value of this growth constant, $\\alpha_{\\text{inhour}}$, is the positive root of the inhour equation:\n$$\n\\rho_{\\text{step}} = \\alpha \\Lambda + \\sum_{i=1}^{6} \\frac{\\alpha \\beta_i}{\\alpha + \\lambda_i}\n$$\nThis is a non-linear algebraic equation for $\\alpha$. It can be solved numerically for $\\alpha_{\\text{inhour}}$ using a standard root-finding algorithm. The corresponding analytical period is $T_{\\text{inhour}} = 1/\\alpha_{\\text{inhour}}$.\n\nThe numerical period, $T_{\\text{num}}$, is estimated from the simulation results. For large $t$, where the solution is dominated by the asymptotic exponential growth, we have $\\ln n(t) \\approx \\ln n_0 + \\alpha t$. This is a linear relationship between $\\ln n(t)$ and $t$, with slope $\\alpha$. We perform a linear regression on the set of points $(t_k, \\ln n_k)$ over a late-time window of the simulation (e.g., the final $25\\%$ of time steps) to find the slope, which serves as our numerical estimate $\\alpha_{\\text{num}}$. The numerical period is then $T_{\\text{num}} = 1/\\alpha_{\\text{num}}$.\n\nFinally, for each test case, we compute the relative difference between the numerically inferred period and the analytical prediction from the inhour relation:\n$$\n\\text{Relative Difference} = \\frac{T_{\\text{num}} - T_{\\text{inhour}}}{T_{\\text{inhour}}}\n$$\nThe implementation will execute this entire procedure for each of the three test cases specified in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print results.\n    \"\"\"\n\n    def run_simulation_case(params):\n        \"\"\"\n        Solves the point kinetics problem for a single parameter set.\n\n        Args:\n            params (dict): A dictionary containing all parameters for the case.\n\n        Returns:\n            float: The relative difference (T_num - T_inhour) / T_inhour.\n        \"\"\"\n        # 1. Unpack parameters and set up case-specific data\n        Lambda = params['Lambda']\n        betas_base = params['betas_base']\n        beta_total_target = params['beta_total']\n        lambdas = params['lambdas']\n        rho_pcm = params['rho_pcm']\n        dt = params['dt']\n        T_end = params['T_end']\n\n        rho_step = rho_pcm * 1e-5\n\n        if beta_total_target is not None:\n            scaling_factor = beta_total_target / np.sum(betas_base)\n            betas = betas_base * scaling_factor\n        else:\n            betas = betas_base\n        \n        beta = np.sum(betas)\n\n        if rho_step >= beta:\n            raise ValueError(\"Reactivity is not sub-prompt-critical.\")\n\n        # 2. Set initial conditions (steady state at rho=0, n=1)\n        n0 = 1.0\n        C0 = betas * n0 / (lambdas * Lambda)\n        \n        num_steps = int(T_end / dt)\n        time_points = np.linspace(0, T_end, num_steps + 1)\n        \n        n_hist = np.zeros(num_steps + 1)\n        C_hist = np.zeros((6, num_steps + 1))\n        \n        n_hist[0] = n0\n        C_hist[:, 0] = C0\n        \n        # 3. Perform time integration using the fully implicit (Backward Euler) method\n        # Pre-calculate the constant coefficient of n_{k+1} for efficiency.\n        # This coefficient is the 'A' in the linear system A*x = b.\n        A_coeff = (1.0 / dt\n                   - (rho_step - beta) / Lambda\n                   - (dt / Lambda) * np.sum(lambdas * betas / (1.0 + dt * lambdas)))\n\n        for k in range(num_steps):\n            n_k = n_hist[k]\n            C_k = C_hist[:, k]\n            \n            # Calculate the right-hand side 'b' of the linear system, which depends on state at k.\n            B_k = n_k / dt + np.sum(lambdas * C_k / (1.0 + dt * lambdas))\n            \n            # Solve for n_{k+1}\n            n_k_plus_1 = B_k / A_coeff\n            n_hist[k+1] = n_k_plus_1\n            \n            # Update C_{i, k+1} using the newly computed n_{k+1}\n            C_hist[:, k+1] = (C_k + (dt * betas / Lambda) * n_k_plus_1) / (1.0 + dt * lambdas)\n\n        # 4. Estimate the numerical asymptotic period T_num\n        # Use the last 25% of the simulation data for a linear fit on log(n).\n        fit_start_index = int(0.75 * num_steps)\n        t_fit = time_points[fit_start_index:]\n        n_fit = n_hist[fit_start_index:]\n        \n        # Ensure there are at least 2 positive data points for fitting\n        valid_indices = n_fit > 0\n        if np.sum(valid_indices) < 2:\n            raise ValueError(\"Insufficient positive data points for period estimation.\")\n\n        log_n_fit = np.log(n_fit[valid_indices])\n        t_fit = t_fit[valid_indices]\n        \n        # np.polyfit returns [slope, intercept]; the slope is the growth constant alpha.\n        alpha_num, _ = np.polyfit(t_fit, log_n_fit, 1)\n        T_num = 1.0 / alpha_num\n    \n        # 5. Calculate the analytical period T_inhour from the inhour relation\n        def inhour_function(alpha):\n            return alpha * Lambda + np.sum(alpha * betas / (alpha + lambdas)) - rho_step\n        \n        # For positive reactivity, the root alpha must be positive.\n        sol = root_scalar(inhour_function, bracket=[1e-9, 1000.0])\n        alpha_inhour = sol.root\n        T_inhour = 1.0 / alpha_inhour\n        \n        # 6. Calculate the final relative difference\n        relative_difference = (T_num - T_inhour) / T_inhour\n        \n        return relative_difference\n\n    # Common parameters for all test cases\n    lambdas_common = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    betas_base_common = np.array([0.000215, 0.001424, 0.001274, 0.002568, 0.000748, 0.000273])\n    rho_pcm_common = 200.0\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (thermal reference)\n        {\n            'Lambda': 1.0e-5, 'beta_total': None, 'dt': 5.0e-3, 'T_end': 60.0,\n            'betas_base': betas_base_common, 'lambdas': lambdas_common, 'rho_pcm': rho_pcm_common\n        },\n        # Case B (fast spectrum, reduced delayed fraction)\n        {\n            'Lambda': 5.0e-7, 'beta_total': 0.0030, 'dt': 2.5e-3, 'T_end': 40.0,\n            'betas_base': betas_base_common, 'lambdas': lambdas_common, 'rho_pcm': rho_pcm_common\n        },\n        # Case C (near-prompt-critical boundary)\n        {\n            'Lambda': 2.0e-5, 'beta_total': 0.0022, 'dt': 5.0e-3, 'T_end': 80.0,\n            'betas_base': betas_base_common, 'lambdas': lambdas_common, 'rho_pcm': rho_pcm_common\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        rel_diff = run_simulation_case(case)\n        results.append(rel_diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world reactor behavior is governed by the coupling of neutronics with thermal-hydraulic feedback mechanisms, which introduces significant non-linearity. This advanced practice moves beyond the linear PKE model to simulate a crucial safety scenario: an Anticipated Transient Without Scram (ATWS) where reactivity is added while control systems fail. By coupling the point kinetics equations with a thermal model for moderator temperature feedback, you will analyze the dynamic competition between the external reactivity ramp and the inherent negative feedback to determine if the reactor power ultimately stabilizes or diverges .",
            "id": "4256420",
            "problem": "An Anticipated Transient Without Scram (ATWS) scenario is considered in which control rods are stuck and an externally imposed reactivity ramp produces a slow positive increase in reactivity. The objective is to determine, using the point kinetics framework with single delayed neutron group and lumped thermal feedback via the moderator temperature, whether reactor power stabilizes or diverges over a finite time horizon, for several parameter sets. All quantities, when physical units apply, must be expressed in the International System of Units (SI).\n\nStarting from the conservation of neutrons and precursors and a lumped thermal energy balance, derive governing ordinary differential equations for the neutron population $n(t)$, a single delayed neutron precursor concentration $C(t)$, and the moderator temperature $T(t)$ in terms of:\n- reactivity $\\rho(t)$ composed of an externally imposed ramp $\\rho_{\\mathrm{ext}}(t) = r t$ and a temperature feedback term $\\rho_{\\mathrm{fb}}(t) = \\alpha_T \\left(T(t) - T_{\\mathrm{ref}}\\right)$,\n- effective delayed neutron fraction $\\beta$,\n- prompt neutron generation time (mean generation lifetime) $\\Lambda$,\n- single-group precursor decay constant $\\lambda$,\n- thermal power scaling $P(t) = P_0 \\, n(t)$ with $P_0$ in watts and $n(t)$ dimensionless (normalized to $n(0) = 1$),\n- lumped thermal capacity $C_T$ in joules per kelvin,\n- first-order heat removal to an ambient sink with time constant $\\tau$ in seconds and ambient temperature $T_\\infty$ in kelvin.\n\nAssume initial conditions $n(0) = 1$ (dimensionless), $C(0)$ consistent with a steady state at zero reactivity and constant power, and $T(0) = T_{\\mathrm{ref}}$ in kelvin. For each parameter set, integrate the derived coupled ordinary differential equations over a specified time horizon $t \\in [0, t_{\\mathrm{end}}]$ in seconds, and decide whether the power stabilizes or diverges according to the following algorithmic criteria:\n- Define the normalized power as $p(t) = n(t)$ (dimensionless).\n- A case is classified as \"stabilize\" (boolean value $true$) if both of the following hold:\n  1. $\\max_{t \\in [0,t_{\\mathrm{end}}]} p(t) \\le p_{\\mathrm{lim}}$ for a specified dimensionless bound $p_{\\mathrm{lim}}$,\n  2. The maximum relative slope over the final tenth of the simulation window is less than a specified threshold $\\epsilon_{\\mathrm{rel}}$, i.e., $\\max_{t \\in [0.9 t_{\\mathrm{end}}, t_{\\mathrm{end}}]} \\left| \\dfrac{dp/dt}{p(t) + \\delta} \\right| < \\epsilon_{\\mathrm{rel}}$, where $\\delta$ is a small positive constant used only to avoid division by zero.\n- Otherwise, classify the case as \"diverge\" (boolean value $false$).\n\nUse the following test suite of parameter sets. All quantities are in SI units unless explicitly stated otherwise; reactivity coefficients $r$ and $\\alpha_T$ are in $\\Delta k/k$ per second and $\\Delta k/k$ per kelvin, respectively.\n\nTest Case 1 (moderate ramp, strong negative feedback, expected stabilization):\n- $r = 1.0 \\times 10^{-5}$,\n- $\\alpha_T = -6.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nTest Case 2 (strong ramp, weak negative feedback, expected divergence):\n- $r = 1.0 \\times 10^{-4}$,\n- $\\alpha_T = -3.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 60.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nTest Case 3 (zero ramp, baseline negative feedback, expected stabilization):\n- $r = 0.0$,\n- $\\alpha_T = -5.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nTest Case 4 (moderate ramp, very strong negative feedback, expected stabilization):\n- $r = 5.0 \\times 10^{-5}$,\n- $\\alpha_T = -1.5 \\times 10^{-4}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (dimensionless),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\nYour program must:\n- Derive the governing equations from the stated fundamental principles and implement a numerical integrator to solve them for each test case.\n- Use $C(0)$ consistent with an initial steady state at zero reactivity and constant power.\n- Decide stabilization versus divergence using the specified criteria, with $\\delta = 10^{-12}$ in the denominator for numerical robustness.\n- Produce a single line of output containing the boolean results for the four test cases as a comma-separated list enclosed in square brackets, for example: \"[true,false,true,true]\". In Python, the canonical boolean literals \"True\" and \"False\" are acceptable and must be printed exactly as they appear.",
            "solution": "The user has provided a problem in nuclear reactor analysis, specifically focusing on an Anticipated Transient Without Scram (ATWS) scenario. The problem has been validated and found to be scientifically sound, well-posed, objective, and complete. We now proceed with the solution.\n\nThe core of the problem is to model the transient behavior of a nuclear reactor using a coupled system of ordinary differential equations (ODEs) for the neutron population, delayed neutron precursor concentration, and moderator temperature.\n\n### 1. Derivation of the Governing Ordinary Differential Equations\n\nWe are tasked with deriving the governing equations from fundamental principles for three state variables: the dimensionless neutron population $n(t)$, the dimensionless precursor concentration $C(t)$, and the moderator temperature $T(t)$.\n\n**Point Kinetics Equations (PKEs)**\nThe time evolution of the neutron population and a single effective group of delayed neutron precursors is described by the point kinetics equations.\n\nThe rate of change of the neutron population, $\\frac{dn}{dt}$, is the sum of neutrons produced from prompt fission, neutrons lost through absorption and leakage, and neutrons produced from the decay of precursors. This balance is expressed as:\n$$ \\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\lambda C(t) \\quad \\quad (1) $$\nHere, $\\rho(t)$ is the total reactivity, $\\beta$ is the effective delayed neutron fraction, $\\Lambda$ is the prompt neutron generation time, and $\\lambda$ is the single-group precursor decay constant. The term $\\frac{\\rho(t) - \\beta}{\\Lambda} n(t)$ represents the net production from prompt neutrons, and $\\lambda C(t)$ represents the production from delayed neutron precursors.\n\nThe rate of change of the precursor concentration, $\\frac{dC}{dt}$, is the balance between their production from fission and their radioactive decay:\n$$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) \\quad \\quad (2) $$\nThe term $\\frac{\\beta}{\\Lambda} n(t)$ represents the rate of precursor formation, which is proportional to the fission rate (and thus to $n(t)$), and $-\\lambda C(t)$ represents their loss through decay.\n\n**Reactivity Model**\nThe total reactivity $\\rho(t)$ is given as the sum of an externally imposed linear ramp, $\\rho_{\\mathrm{ext}}(t)$, and a temperature-dependent feedback term, $\\rho_{\\mathrm{fb}}(t)$:\n$$ \\rho(t) = \\rho_{\\mathrm{ext}}(t) + \\rho_{\\mathrm{fb}}(t) = r t + \\alpha_T (T(t) - T_{\\mathrm{ref}}) $$\nHere, $r$ is the ramp rate, $\\alpha_T$ is the moderator temperature coefficient of reactivity, and $T_{\\mathrm{ref}}$ is the reference temperature at which the feedback reactivity is zero.\n\n**Thermal-Hydraulic Model**\nA lumped-parameter energy balance for the moderator is considered. The rate of change of the internal energy of the moderator, $C_T T(t)$, is equal to the heat generated by the reactor core minus the heat removed to the ambient sink.\n$$ \\frac{d}{dt}(C_T T(t)) = P(t) - P_{\\mathrm{removed}}(t) $$\nGiven a constant thermal capacity $C_T$, this becomes:\n$$ C_T \\frac{dT}{dt} = P(t) - P_{\\mathrm{removed}}(t) $$\nThe thermal power generated, $P(t)$, is proportional to the neutron population: $P(t) = P_0 n(t)$. The heat removal is modeled as a first-order process to a sink at temperature $T_\\infty$ with a time constant $\\tau$. The rate of heat removal is given by $\\frac{C_T}{\\tau}(T(t) - T_\\infty)$, representing Newtonian cooling.\nSubstituting these expressions into the energy balance yields:\n$$ C_T \\frac{dT}{dt} = P_0 n(t) - \\frac{C_T}{\\tau} (T(t) - T_\\infty) $$\nDividing by $C_T$ gives the final ODE for temperature:\n$$ \\frac{dT}{dt} = \\frac{P_0}{C_T} n(t) - \\frac{1}{\\tau} (T(t) - T_\\infty) \\quad \\quad (3) $$\n\n**Complete System of ODEs**\nThe complete system of coupled, non-linear, first-order ordinary differential equations describing the reactor transient is:\n1.  $$ \\frac{dn}{dt} = \\frac{r t + \\alpha_T (T(t) - T_{\\mathrm{ref}}) - \\beta}{\\Lambda} n(t) + \\lambda C(t) $$\n2.  $$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) $$\n3.  $$ \\frac{dT}{dt} = \\frac{P_0}{C_T} n(t) - \\frac{1}{\\tau} (T(t) - T_\\infty) $$\n\n### 2. Initial Conditions\n\nThe transient starts at $t=0$. The initial conditions are specified as:\n*   $n(0) = 1$\n*   $T(0) = T_{\\mathrm{ref}}$\n*   $C(0)$ is consistent with a steady state at zero reactivity ($\\rho=0$) and constant power.\n\nTo find $C(0)$, we set the time derivatives in the PKEs to zero, with $n(0) = 1$ and $\\rho(0)=0$:\n$$ \\frac{dn}{dt} = 0 \\implies 0 = \\frac{0 - \\beta}{\\Lambda} n(0) + \\lambda C(0) $$\n$$ \\frac{dC}{dt} = 0 \\implies 0 = \\frac{\\beta}{\\Lambda} n(0) - \\lambda C(0) $$\nBoth equations yield the same relationship. From the second equation:\n$$ \\lambda C(0) = \\frac{\\beta}{\\Lambda} n(0) $$\nSubstituting $n(0)=1$:\n$$ C(0) = \\frac{\\beta}{\\lambda \\Lambda} $$\nThe initial state vector for the numerical integration is therefore $\\mathbf{y}(0) = [n(0), C(0), T(0)]^T = \\left[ 1, \\frac{\\beta}{\\lambda \\Lambda}, T_{\\mathrm{ref}} \\right]^T$.\n\n### 3. Numerical Integration and Stabilization Criteria\n\nThe derived system of ODEs does not have a general analytical solution and must be solved numerically. We will use a standard numerical integration routine, `scipy.integrate.solve_ivp`, to solve this initial value problem for each test case over the time interval $[0, t_{\\mathrm{end}}]$.\n\nAfter obtaining the solution for the normalized power, $p(t) = n(t)$, we apply the specified algorithmic criteria to classify the outcome as \"stabilize\" ($true$) or \"diverge\" ($false$).\n\nA case is classified as \"stabilize\" if and only if both conditions are met:\n1.  **Peak Power Limit**: The maximum normalized power over the simulation does not exceed a limit $p_{\\mathrm{lim}}$.\n    $$ \\max_{t \\in [0,t_{\\mathrm{end}}]} p(t) \\le p_{\\mathrm{lim}} $$\n2.  **Relative Slope Limit**: The system is approaching a steady state, indicated by a small maximum relative slope of the power curve in the final $10\\%$ of the simulation time.\n    $$ \\max_{t \\in [0.9 t_{\\mathrm{end}}, t_{\\mathrm{end}}]} \\left| \\dfrac{dp/dt}{p(t) + \\delta} \\right| < \\epsilon_{\\mathrm{rel}} $$\nThe derivative $\\frac{dp}{dt} = \\frac{dn}{dt}$ is evaluated directly from the first ODE using the computed values of $n(t)$, $C(t)$, and $T(t)$. The small constant $\\delta = 10^{-12}$ ensures numerical stability.\n\nIf either of these conditions is not met, the case is classified as \"diverge\". This logic will be implemented for each test case to generate the final boolean results.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the reactor kinetics problem for a series of test cases and\n    determines if the reactor power stabilizes or diverges based on given criteria.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: moderate ramp, strong negative feedback\n        {\n            'r': 1.0e-5, 'alpha_T': -6.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 2: strong ramp, weak negative feedback\n        {\n            'r': 1.0e-4, 'alpha_T': -3.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 60.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 3: zero ramp, baseline negative feedback\n        {\n            'r': 0.0, 'alpha_T': -5.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 4: moderate ramp, very strong negative feedback\n        {\n            'r': 5.0e-5, 'alpha_T': -1.5e-4, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        }\n    ]\n\n    results = []\n\n    def derivatives(t, y, p):\n        \"\"\"\n        Computes the derivatives for the coupled ODE system.\n        y = [n, C, T]\n        p = dictionary of parameters\n        \"\"\"\n        n, C, T = y\n        \n        # Calculate total reactivity\n        rho = p['r'] * t + p['alpha_T'] * (T - p['T_ref'])\n        \n        # ODEs\n        dn_dt = ((rho - p['beta']) / p['Lambda']) * n + p['lambda_'] * C\n        dC_dt = (p['beta'] / p['Lambda']) * n - p['lambda_'] * C\n        dT_dt = (p['P0'] / p['C_T']) * n - (1 / p['tau']) * (T - p['T_inf'])\n        \n        return [dn_dt, dC_dt, dT_dt]\n\n    for case_params in test_cases:\n        # Set initial conditions\n        n0 = 1.0\n        C0 = case_params['beta'] / (case_params['lambda_'] * case_params['Lambda'])\n        T0 = case_params['T_ref']\n        y0 = [n0, C0, T0]\n        \n        t_span = [0, case_params['t_end']]\n        \n        # Use a sufficient number of evaluation points to accurately check criteria\n        t_eval = np.linspace(t_span[0], t_span[1], 2001)\n\n        # Solve the ODE system\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=y0,\n            args=(case_params,),\n            method='RK45',\n            t_eval=t_eval\n        )\n        \n        # Extract normalized power p(t) = n(t)\n        p_t = sol.y[0, :]\n        \n        # --- Apply Stabilization Criteria ---\n        \n        # 1. Peak Power Criterion\n        max_p = np.max(p_t)\n        crit1_met = (max_p <= case_params['p_lim'])\n        \n        # 2. Relative Slope Criterion\n        # Find the start index for the final 10% of the simulation time\n        start_index = np.where(sol.t >= 0.9 * case_params['t_end'])[0][0]\n\n        # Get state variables for the final time interval\n        t_final = sol.t[start_index:]\n        y_final = sol.y[:, start_index:]\n        p_final = y_final[0, :]\n        \n        # Calculate the derivative dp/dt over the final interval\n        dp_dt_final = np.array([derivatives(t, y, case_params)[0] for t, y in zip(t_final, y_final.T)])\n        \n        # Calculate the relative slope\n        relative_slope = np.abs(dp_dt_final / (p_final + case_params['delta']))\n        \n        max_relative_slope = np.max(relative_slope)\n        crit2_met = (max_relative_slope < case_params['epsilon_rel'])\n\n        # Final decision\n        is_stable = crit1_met and crit2_met\n        results.append(is_stable)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}