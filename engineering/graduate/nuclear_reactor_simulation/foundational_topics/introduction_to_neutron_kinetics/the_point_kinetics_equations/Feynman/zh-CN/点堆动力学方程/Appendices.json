{
    "hands_on_practices": [
        {
            "introduction": "点堆动力学方程是一组常微分方程，直接求解通常很困难，因此需要依赖数值方法。由于方程中包含的时间尺度差异巨大，简单的显式数值方法可能会不稳定，因此掌握隐式方法至关重要。本练习将指导您从头推导并实现无条件稳定的后向欧拉法，这是解决此类问题的基本功，为您后续更复杂的模拟任务打下坚实的基础。",
            "id": "4256381",
            "problem": "考虑通过在反应堆堆芯上对空间依赖的中子平衡和缓发中子先驱体平衡方程进行积分得到的核反应堆点动力学模型。令 $n(t)$ 表示归一化中子密度（无量纲），令 $C_i(t)$ 表示第 $i$ 组的归一化缓发中子先驱体浓度（无量纲），其中 $i=1,\\dots,M$。该基本模型表示为一个耦合线性常微分方程（ODE）组，形式如下：\n$$\n\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^M \\lambda_i C_i(t),\n$$\n$$\n\\frac{dC_i}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t), \\quad i=1,\\dots,M,\n$$\n其中 $\\rho(t)$ 是反应性（无量纲），$\\beta = \\sum_{i=1}^M \\beta_i$ 是总缓发中子份额（无量纲），$\\beta_i$ 是各组的缓发中子份额（无量纲），$\\lambda_i$ 是先驱体衰变常数（单位为 $\\mathrm{s}^{-1}$），$\\Lambda$ 是瞬发中子代时间（单位为 $\\mathrm{s}$）。假设初始条件对应于零反应性下的稳态，即对所有 $i=1,\\dots,M$，有 $n(0)=n_0$ 和 $C_i(0)=\\frac{\\beta_i}{\\Lambda \\lambda_i} n_0$。\n\n您的任务是，从线性常微分方程组的后向欧拉（BE）离散化第一性原理出发，推导在时间 $t^{k+1}=t^k + \\Delta t$ 处 $n^{k+1}$ 和 $C_i^{k+1}$ 的无条件稳定离散更新方程，并在隐式评估中使用 $\\rho^{k+1}=\\rho(t^{k+1})$。使用这些推导出的方程实现一个时间推进算法，该算法在步长为 $\\Delta t$ 秒的均匀时间网格 $\\{t^k\\}_{k=0}^{N}$ 上推进求解，其中 $t^0=0$ 且 $t^N=T$。\n\n程序必须精确实现推导出的后向欧拉更新方程，并为以下科学上真实且自洽的测试套件生成所要求的输出。在所有测试中，使用 $n_0 = 1$（无量纲）。对于所有涉及缓发中子组的情况，使用 $M=6$ 组，参数如下：\n$$\n\\boldsymbol{\\lambda} = [0.0124,\\, 0.0305,\\, 0.111,\\, 0.301,\\, 1.14,\\, 3.01] \\ \\mathrm{s}^{-1},\n$$\n$$\n\\boldsymbol{\\beta} = [0.000215,\\, 0.001424,\\, 0.001274,\\, 0.002568,\\, 0.000748,\\, 0.000273],\n$$\n因此 $\\beta = \\sum_{i=1}^{6} \\beta_i = 0.006502$。时间单位为秒，瞬发中子代时间根据具体情况指定。反应性剖面 $\\rho(t)$ 根据具体情况定义为阶跃或斜坡函数。\n\n需要实现和评估的测试用例：\n- 用例 A（一般理想情况，小时间步长）：$M=6$，$\\Lambda = 10^{-4}$ $\\mathrm{s}$，阶跃反应性 $\\rho(t) = 0.002$ (对所有 $t \\ge 0$)，最终时间 $T = 0.1$ $\\mathrm{s}$，步长 $\\Delta t = 0.001$ $\\mathrm{s}$。输出 $n(T)$（无量纲）。\n- 用例 B（大时间步长，物理模型与用例 A 相同）：$M=6$，$\\Lambda = 10^{-4}$ $\\mathrm{s}$，阶跃反应性 $\\rho(t) = 0.002$，最终时间 $T = 0.1$ $\\mathrm{s}$，步长 $\\Delta t = 0.05$ $\\mathrm{s}$。输出 $n(T)$（无量纲）。\n- 用例 C（边界情况，无缓发中子）：$M=0$（因此 $\\beta=0$ 且不存在 $C_i$ 变量），$\\Lambda = 10^{-4}$ $\\mathrm{s}$，阶跃反应性 $\\rho(t) = 0.002$，最终时间 $T = 0.1$ $\\mathrm{s}$，步长 $\\Delta t = 0.02$ $\\mathrm{s}$。输出 $n(T)$（无量纲）。\n- 用例 D（负反应性衰减）：$M=6$，$\\Lambda = 10^{-4}$ $\\mathrm{s}$，阶跃反应性 $\\rho(t) = -0.003$，最终时间 $T = 0.2$ $\\mathrm{s}$，步长 $\\Delta t = 0.02$ $\\mathrm{s}$。输出 $n(T)$（无量纲）。\n- 用例 E（刚性先驱体，极大时间步长，时变反应性）：$M=6$，先驱体衰变常数乘以因子 10，因此\n$$\n\\boldsymbol{\\lambda}^{\\star} = [0.124,\\, 0.305,\\, 1.11,\\, 3.01,\\, 11.4,\\, 30.1] \\ \\mathrm{s}^{-1},\n$$\n$\\Lambda = 10^{-4}$ $\\mathrm{s}$，斜坡反应性 $\\rho(t) = 0.001 \\cdot \\frac{t}{T}$ (对 $t \\in [0,T]$)，最终时间 $T = 0.4$ $\\mathrm{s}$，步长 $\\Delta t = 0.2$ $\\mathrm{s}$。输出 $n(T)$（无量纲）。\n\n您的程序应生成单行输出，其中包含按用例 A 到 E 顺序排列的结果，形式为方括号括起来的逗号分隔列表，即 $[n_A(T), n_B(T), n_C(T), n_D(T), n_E(T)]$，每个条目都是一个浮点数（无量纲）。不应打印任何其他文本。",
            "solution": "该问题要求推导并实现一个后向欧拉（BE）数值格式，用以求解核反应堆点动力学方程。\n\n控制常微分方程（ODE）组如下所示：\n$$\n\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^M \\lambda_i C_i(t)\n$$\n$$\n\\frac{dC_i}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t), \\quad i=1,\\dots,M\n$$\n在此，$n(t)$ 是中子密度，$C_i(t)$ 是缓发中子先驱体浓度，$\\rho(t)$ 是反应性，$\\Lambda$ 是瞬发中子代时间，$\\beta_i$ 是第 $i$ 组的缓发中子份额，$\\beta = \\sum_{i=1}^M \\beta_i$ 是总缓发中子份额，$\\lambda_i$ 是先驱体衰变常数。\n\n在 $t=0$ 时的初始条件对应于零反应性（$\\rho=0$）的稳态，这意味着 $\\frac{dn}{dt}=0$ 和 $\\frac{dC_i}{dt}=0$。由此可得：\n$$\nn(0) = n_0\n$$\n$$\nC_i(0) = \\frac{\\beta_i}{\\Lambda \\lambda_i} n_0\n$$\n\n任务是使用后向欧拉法推导更新方程。对于一个通用常微分方程 $\\frac{dy}{dt} = f(t, y)$，其后向欧拉离散化形式为：\n$$\n\\frac{y^{k+1} - y^k}{\\Delta t} = f(t^{k+1}, y^{k+1})\n$$\n其中 $y^k \\approx y(t^k)$，$t^{k+1} = t^k + \\Delta t$，$\\Delta t$ 是恒定的时间步长。\n\n将此方法应用于点动力学方程，我们在未来的时间步 $t^{k+1}$ 处计算右侧项：\n$$\n\\frac{n^{k+1} - n^k}{\\Delta t} = \\frac{\\rho^{k+1} - \\beta}{\\Lambda} n^{k+1} + \\sum_{i=1}^M \\lambda_i C_i^{k+1} \\quad (1)\n$$\n$$\n\\frac{C_i^{k+1} - C_i^k}{\\Delta t} = \\frac{\\beta_i}{\\Lambda} n^{k+1} - \\lambda_i C_i^{k+1}, \\quad i=1,\\dots,M \\quad (2)\n$$\n其中 $\\rho^{k+1} = \\rho(t^{k+1})$。这是一个关于未知数 $n^{k+1}$ 和 $\\{C_i^{k+1}\\}_{i=1}^M$ 的耦合线性代数方程组，包含 $M+1$ 个方程。\n\n我们必须求解这个方程组。首先，从方程（2）中，我们分离出 $C_i^{k+1}$，用已知的 $C_i^k$ 和仍未知的 $n^{k+1}$ 来表示它：\n$$\nC_i^{k+1} - C_i^k = \\Delta t \\left( \\frac{\\beta_i}{\\Lambda} n^{k+1} - \\lambda_i C_i^{k+1} \\right)\n$$\n$$\nC_i^{k+1} + \\Delta t \\lambda_i C_i^{k+1} = C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}\n$$\n$$\nC_i^{k+1} (1 + \\Delta t \\lambda_i) = C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}\n$$\n$$\nC_i^{k+1} = \\frac{C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}}{1 + \\Delta t \\lambda_i} \\quad (3)\n$$\n一旦 $n^{k+1}$ 已知，此方程即可为每个先驱体浓度提供更新。\n\n接下来，我们将 $C_i^{k+1}$ 的这个表达式代回方程（1），以获得一个关于 $n^{k+1}$ 的单一方程：\n$$\n\\frac{n^{k+1} - n^k}{\\Delta t} = \\frac{\\rho^{k+1} - \\beta}{\\Lambda} n^{k+1} + \\sum_{i=1}^M \\lambda_i \\left( \\frac{C_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^{k+1}}{1 + \\Delta t \\lambda_i} \\right)\n$$\n为了求解 $n^{k+1}$，我们将所有包含 $n^{k+1}$ 的项移到方程的一边。\n$$\nn^{k+1} - n^k = \\frac{\\Delta t}{\\Lambda}(\\rho^{k+1} - \\beta) n^{k+1} + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i} + n^{k+1} \\sum_{i=1}^M \\frac{\\Delta t^2 \\lambda_i \\beta_i}{\\Lambda(1 + \\Delta t \\lambda_i)}\n$$\n$$\nn^{k+1} - \\frac{\\Delta t}{\\Lambda}(\\rho^{k+1} - \\beta) n^{k+1} - n^{k+1} \\sum_{i=1}^M \\frac{\\Delta t^2 \\lambda_i \\beta_i}{\\Lambda(1 + \\Delta t \\lambda_i)} = n^k + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i}\n$$\n从左侧提出公因子 $n^{k+1}$：\n$$\nn^{k+1} \\left( 1 - \\frac{\\Delta t}{\\Lambda}(\\rho^{k+1} - \\beta) - \\frac{\\Delta t^2}{\\Lambda} \\sum_{i=1}^M \\frac{\\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i} \\right) = n^k + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i}\n$$\n$n^{k+1}$ 的系数可以通过代入 $\\beta = \\sum_{i=1}^M \\beta_i$ 来简化：\n$$\n1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\beta_i - \\frac{\\Delta t}{\\Lambda} \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i}\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\left( \\beta_i - \\frac{\\Delta t \\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i} \\right)\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\left( \\frac{\\beta_i(1 + \\Delta t \\lambda_i) - \\Delta t \\lambda_i \\beta_i}{1 + \\Delta t \\lambda_i} \\right)\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda}\\rho^{k+1} + \\frac{\\Delta t}{\\Lambda}\\sum_{i=1}^M \\frac{\\beta_i}{1 + \\Delta t \\lambda_i}\n$$\n$$\n= 1 - \\frac{\\Delta t}{\\Lambda} \\left( \\rho^{k+1} - \\sum_{i=1}^M \\frac{\\beta_i}{1 + \\Delta t \\lambda_i} \\right)\n$$\n这就得到了 $n^{k+1}$ 的最终更新方程：\n$$\nn^{k+1} = \\frac{n^k + \\sum_{i=1}^M \\frac{\\Delta t \\lambda_i C_i^k}{1 + \\Delta t \\lambda_i}}{1 - \\frac{\\Delta t}{\\Lambda} \\left( \\rho^{k+1} - \\sum_{i=1}^M \\frac{\\beta_i}{1 + \\Delta t \\lambda_i} \\right)} \\quad (4)\n$$\n将解从时间 $t^k$ 推进到 $t^{k+1}$ 的算法如下：\n1.  给定 $n^k$、$\\{C_i^k\\}$ 以及参数 $\\Lambda, \\{\\beta_i\\}, \\{\\lambda_i\\}, \\Delta t$。\n2.  确定新时间步的反应性，$\\rho^{k+1} = \\rho(t^{k+1})$。\n3.  使用方程（4）计算 $n^{k+1}$。这需要计算关于先驱体组的两个求和。\n4.  使用方程（3）和新计算出的 $n^{k+1}$ 来计算每个 $C_i^{k+1}$。\n5.  重复此过程，直到达到所需的时间步数。\n\n这个基于无条件稳定的后向欧拉法的过程将为每个测试用例实现。对于 $M=0$ 的用例 C，求和为空，方程简化为 $n^{k+1} = n^k / (1 - \\frac{\\Delta t}{\\Lambda} \\rho^{k+1})$，并且不存在先驱体方程，这是从推导的一般形式直接得出的结论。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the point kinetics equations for a series of test cases\n    using the backward Euler method.\n    \"\"\"\n\n    def run_simulation(M, Lambda, beta_i, lambda_i, rho_func, T, dt, n0):\n        \"\"\"\n        Runs a single point kinetics simulation.\n        \n        Args:\n            M (int): Number of delayed neutron groups.\n            Lambda (float): Prompt neutron generation time.\n            beta_i (np.array): Group-wise delayed neutron fractions.\n            lambda_i (np.array): Precursor decay constants.\n            rho_func (callable): Function for reactivity rho(t, T).\n            T (float): Final time.\n            dt (float): Time step size.\n            n0 (float): Initial neutron density.\n        \n        Returns:\n            float: Neutron density at final time T.\n        \"\"\"\n        num_steps = int(round(T / dt))\n        \n        # Initial conditions\n        n_k = n0\n        \n        if M > 0:\n            # Check for lambda_i == 0 to avoid division by zero in steady state C_i calculation\n            if np.any(lambda_i == 0):\n                raise ValueError(\"lambda_i cannot contain zero for steady-state initialization.\")\n            C_k = (beta_i / (Lambda * lambda_i)) * n0\n        else:\n            C_k = np.array([])\n\n        one_plus_dt_lambda = 1.0 + dt * lambda_i\n        \n        for k in range(num_steps):\n            t_kp1 = (k + 1) * dt\n            rho_kp1 = rho_func(t_kp1, T)\n\n            if M > 0:\n                # Sum terms for the n_kp1 update equation\n                S1_k = np.sum((dt * lambda_i * C_k) / one_plus_dt_lambda)\n                S2 = np.sum(beta_i / one_plus_dt_lambda)\n\n                # Numerator and denominator for n_kp1\n                numerator = n_k + S1_k\n                denominator = 1.0 - (dt / Lambda) * (rho_kp1 - S2)\n                \n                n_kp1 = numerator / denominator\n                \n                # Update precursor concentrations\n                C_kp1 = (C_k + (dt * beta_i / Lambda) * n_kp1) / one_plus_dt_lambda\n            else: # Case M=0\n                denominator = 1.0 - (dt/Lambda) * rho_kp1\n                n_kp1 = n_k / denominator\n                C_kp1 = np.array([])\n            \n            # Update state for next iteration\n            n_k = n_kp1\n            C_k = C_kp1\n            \n        return n_k\n\n    # Common parameters\n    n0 = 1.0\n    lambda_base = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    beta_base = np.array([0.000215, 0.001424, 0.001274, 0.002568, 0.000748, 0.000273])\n    \n    test_cases = [\n        # Case A\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base,\n         'rho_func': lambda t, T: 0.002, 'T': 0.1, 'dt': 0.001, 'n0': n0},\n        # Case B\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base,\n         'rho_func': lambda t, T: 0.002, 'T': 0.1, 'dt': 0.05, 'n0': n0},\n        # Case C\n        {'M': 0, 'Lambda': 1e-4, 'beta_i': np.array([]), 'lambda_i': np.array([]),\n         'rho_func': lambda t, T: 0.002, 'T': 0.1, 'dt': 0.02, 'n0': n0},\n        # Case D\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base,\n         'rho_func': lambda t, T: -0.003, 'T': 0.2, 'dt': 0.02, 'n0': n0},\n        # Case E\n        {'M': 6, 'Lambda': 1e-4, 'beta_i': beta_base, 'lambda_i': lambda_base * 10.0,\n         'rho_func': lambda t, T: 0.001 * t / T, 'T': 0.4, 'dt': 0.2, 'n0': n0},\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "点堆动力学方程的一个显著特点是其“刚性”（stiffness），这源于瞬发中子寿命（约 $10^{-5}$ s）与缓发中子先驱核衰变（约 0.1-10 s）之间巨大的时间尺度差异。本练习通过直接比较经典的显式龙格-库塔法和稳健的隐式方法，直观地展示了刚性问题对数值求解稳定性的影响。通过本练习，您将深刻理解为何在反应堆动力学模拟中必须优先选择能够处理刚性问题的隐式积分器。",
            "id": "4256385",
            "problem": "在点动力学近似下，核反应堆可以由中子布居和缓发中子先驱核的耦合常微分方程组来建模。考虑一个具有阶跃反应性引入的单组缓发中子模型。从基本的中子平衡和先驱核产生-衰变关系出发，对于恒定的反应性，单组点动力学方程由以下自治线性系统给出：\n$$\n\\frac{dn}{dt} = \\frac{\\rho - \\beta}{\\Lambda}\\, n + \\lambda\\, C,\\quad\n\\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}\\, n - \\lambda\\, C,\n$$\n其中，$n(t)$ 是中子布居（或归一化功率，无量纲），$C(t)$ 是缓发中子先驱核浓度（无量纲），$\\rho$ 是（无量纲的）反应性，$\\beta$ 是（无量纲的）缓发中子份额，$\\Lambda$ 是瞬发中子代时间（单位为 $\\mathrm{s}$），$\\lambda$ 是缓发中子先驱核衰变常数（单位为 $\\mathrm{s}^{-1}$）。假设反应堆在 $t0$ 时处于 $\\rho=0$ 的稳态，因此 $n(0^-)=n_0$ 且 $C(0^-)=\\frac{\\beta}{\\Lambda \\lambda} n_0$。在 $t=0$ 时，引入一个阶跃反应性 $\\rho$，并在 $t\\ge 0$ 时保持不变。\n\n你的任务是实现一个程序，针对几个指定的测试用例，比较显式方法与隐式 Runge–Kutta 配置法在对点动力学方程的瞬发跳变区和缓发拖尾区进行积分时的数值稳定性和精度。\n\n要求如下：\n\n- 将该模型实现为线性系统\n$$\n\\frac{d}{dt}\\begin{bmatrix}n\\\\C\\end{bmatrix} = A(\\rho)\\begin{bmatrix}n\\\\C\\end{bmatrix},\\quad\nA(\\rho) = \\begin{bmatrix}\\dfrac{\\rho - \\beta}{\\Lambda}  \\lambda \\\\ \\dfrac{\\beta}{\\Lambda}  -\\lambda\\end{bmatrix},\n$$\n在 $t=0$ 时的初始条件为 $n(0)=n_0$ 和 $C(0)=\\dfrac{\\beta}{\\Lambda \\lambda} n_0$。\n\n- 使用以下方法从 $t=0$ 积分到指定的最终时间 $T$：\n  1. 一个4阶显式定步长 Runge–Kutta 方法（经典 Runge–Kutta 法），步长为 $h$。\n  2. 一个适用于刚性系统的隐式 Runge–Kutta 配置法（例如 Radau IIA），为了公平比较，使用相同的最大步长 $h$。\n\n- 通过使用矩阵指数精确求解线性系统，构建一个参考解（基准真相）：\n$$\n\\begin{bmatrix}n(t)\\\\C(t)\\end{bmatrix} = e^{A(\\rho) t} \\begin{bmatrix}n(0)\\\\C(0)\\end{bmatrix}.\n$$\n\n- 对于每种方法和每个测试用例，计算：\n  1. 中子布居 $n(t)$ 在整个轨迹 $t \\in [0,T]$ 上的最大相对误差，定义为\n     $$\\max_{t \\in [0,T]} \\frac{\\left|n_{\\text{num}}(t) - n_{\\text{exact}}(t)\\right|}{\\max\\left(10^{-14},\\, n_{\\text{exact}}(t)\\right)}.$$\n     这是一个无量纲值，应以浮点数形式报告。\n  2. 一个稳定性布尔值，指示数值计算的中子布居在 $[0,T]$ 上是否保持为有限和非负。\n\n- 所有物理量必须使用指定的单位：时间单位为 $\\mathrm{s}$，衰变常数单位为 $\\mathrm{s}^{-1}$。中子布居和先驱核浓度是无量纲的。误差是无量纲的浮点数。\n\n- 使用以下参数值的测试套件。在所有情况下，设置 $n_0 = 1$：\n  1. 次临界，适度引入（理想情况）：$\\beta = 0.0065$，$\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$，$\\lambda = 0.08\\,\\mathrm{s}^{-1}$，$\\rho = 0.003$，$T = 10\\,\\mathrm{s}$，$h = 0.001\\,\\mathrm{s}$。\n  2. 近瞬发临界边界（边界情况）：$\\beta = 0.0065$，$\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$，$\\lambda = 0.08\\,\\mathrm{s}^{-1}$，$\\rho = 0.00649$，$T = 3\\,\\mathrm{s}$，$h = 0.002\\,\\mathrm{s}$。\n  3. 超瞬发临界（增长区）：$\\beta = 0.0065$，$\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$，$\\lambda = 0.08\\,\\mathrm{s}^{-1}$，$\\rho = 0.008$，$T = 0.2\\,\\mathrm{s}$，$h = 0.0001\\,\\mathrm{s}$。\n  4. 负反应性（停堆拖尾）：$\\beta = 0.0065$，$\\Lambda = 5\\times 10^{-5}\\,\\mathrm{s}$，$\\lambda = 0.08\\,\\mathrm{s}^{-1}$，$\\rho = -0.002$，$T = 10\\,\\mathrm{s}$，$h = 0.002\\,\\mathrm{s}$。\n\n- 你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个测试用例，按顺序输出一个包含四个条目的列表：显式方法最大相对误差（浮点数）、显式方法稳定性（布尔值）、隐式方法最大相对误差（浮点数）、隐式方法稳定性（布尔值）。因此，最终输出格式必须为：\n  `[[e_1,s_1,E_1,S_1],[e_2,s_2,E_2,S_2],[e_3,s_3,E_3,S_3],[e_4,s_4,E_4,S_4]]`\n其中 $e_i$ 和 $E_i$ 是浮点数，而 $s_i$ 和 $S_i$ 是布尔值。",
            "solution": "点动力学模型始于瞬发中子产生、缓发中子产生和中子损失之间的平衡。在单组缓发中子近似且参数恒定的情况下，控制方程为\n$$\n\\frac{dn}{dt} = \\frac{\\rho - \\beta}{\\Lambda}\\, n + \\lambda\\, C,\\quad\n\\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}\\, n - \\lambda\\, C,\n$$\n其中 $n(t)$ 和 $C(t)$ 是无量纲的标度化量，$\\rho$ 是无量纲的反应性，$\\beta$ 是无量纲的缓发份额，$\\Lambda$ 是瞬发中子代时间（单位为 $\\mathrm{s}$），$\\lambda$ 是先驱核衰变常数（单位为 $\\mathrm{s}^{-1}$）。对于 $t0$ 时 $\\rho=0$ 的稳态，导数消失，得到\n$$\n0 = -\\frac{\\beta}{\\Lambda} n_0 + \\lambda C_0,\\quad 0 = \\frac{\\beta}{\\Lambda} n_0 - \\lambda C_0,\n$$\n因此 $C_0 = \\frac{\\beta}{\\Lambda \\lambda} n_0$，这提供了当反应性在 $t=0$ 时阶跃到一个常数 $\\rho$ 时的初始条件。\n\n该系统可以紧凑地写成一个线性时不变系统：\n$$\n\\frac{d}{dt} \\mathbf{x}(t) = A(\\rho)\\, \\mathbf{x}(t),\\quad \\mathbf{x}(t)=\\begin{bmatrix}n(t)\\\\C(t)\\end{bmatrix},\\quad A(\\rho) = \\begin{bmatrix}\\dfrac{\\rho - \\beta}{\\Lambda}  \\lambda \\\\ \\dfrac{\\beta}{\\Lambda}  -\\lambda\\end{bmatrix}.\n$$\n对于这样一个常系数线性系统，其精确解由矩阵指数给出：\n$$\n\\mathbf{x}(t) = e^{A(\\rho) t}\\, \\mathbf{x}(0).\n$$\n这种精确形式为误差评估提供了一个参考（基准真相）。我们也可以用 $A(\\rho)$ 的特征对来表示解。特征多项式是\n$$\n\\det\\!\\big(s I - A(\\rho)\\big) = s^2 + s\\!\\left(\\lambda - \\frac{\\rho - \\beta}{\\Lambda}\\right) - \\frac{\\lambda \\rho}{\\Lambda},\n$$\n其根（动力学模态）为\n$$\ns_{1,2} = \\frac{1}{2}\\left(\\frac{\\rho - \\beta}{\\Lambda} - \\lambda \\pm \\sqrt{\\left(\\lambda - \\frac{\\rho - \\beta}{\\Lambda}\\right)^2 + \\frac{4 \\lambda \\rho}{\\Lambda}}\\right).\n$$\n中子布居 $n(t)$ 是 $e^{s_1 t}$ 和 $e^{s_2 t}$ 的线性组合，其权重由初始条件在特征向量上的投影决定。当 $\\rho$ 为正但小于 $\\beta$（次瞬发）时，一个模态是快速的并迅速衰减（瞬发跳变），另一个是慢速的（缓发拖尾）。当 $\\rho$ 接近 $\\beta$ 时，由于 $\\Lambda$ 很小且快速时间尺度变得极短，系统的刚性增强。当 $\\rho>\\beta$ 时，存在一个正特征值，中子布居表现出由快模态主导的瞬发增长。\n\n数值积分策略必须考虑到由瞬发时间尺度（量级为 $\\Lambda$）和缓发时间尺度（量级为 $1/\\lambda$）之间的差异所引起的刚性。一个4阶显式定步长 Runge–Kutta 方法（经典 Runge–Kutta 法）通过阶段求值来演化状态：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(t_n, \\mathbf{y}_n),\\\\\n\\mathbf{k}_2 = f\\!\\left(t_n + \\frac{h}{2},\\, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1\\right),\\\\\n\\mathbf{k}_3 = f\\!\\left(t_n + \\frac{h}{2},\\, \\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2\\right),\\\\\n\\mathbf{k}_4 = f\\!\\left(t_n + h,\\, \\mathbf{y}_n + h\\,\\mathbf{k}_3\\right),\\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}\\big(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\big),\n\\end{aligned}\n$$\n其中 $f(\\cdot)$ 表示右端项 $A(\\rho)\\mathbf{y}$。对于一个刚性线性测试方程 $y' = a y$（其中 $a$ 是大的负数），显式方法有一个稳定性函数 $R(z)$，其中 $z = h a$，必须满足 $\\lvert R(z)\\rvert \\le 1$ 才能保持稳定。经典 Runge–Kutta 方法的稳定性函数在实轴上对于大的负 $z$ 值衰减得很差，因为它匹配截断级数 $1 + z + z^2/2 + z^3/6 + z^4/24$。因此，对于具有 $\\lvert a \\rvert \\gg 1/h$ 的刚性分量，显式方法会变得不稳定或产生严重误差，除非选择的 $h$ 远小于最快的时间尺度，这里即 $h \\ll \\Lambda$。\n\n诸如 Radau IIA 之类的隐式 Runge–Kutta 配置法是 $A$-稳定的，并且通常是 $L$-稳定的；它们能够稳健地控制刚性衰减模态，而不需要 $h \\ll \\Lambda$。它们的内部阶段求解涉及雅可比矩阵 $J = \\partial f/\\partial \\mathbf{y} = A(\\rho)$ 的线性系统，对于当前的线性模型，该矩阵是常数。在相同的最大步长 $h$ 下，隐式方法在瞬发跳变过程中保持稳定，并能精确地积分缓发拖尾，而显式方法在瞬发区附近可能会出现振荡、负值或发散。\n\n算法计划如下：\n- 根据参数构建 $A(\\rho)$ 并设置 $\\mathbf{x}(0) = [n_0,\\, \\beta n_0/(\\Lambda \\lambda)]^\\top$。\n- 生成一个均匀的时间网格 $t_k = k h$，$k = 0,1,\\dots,\\lfloor T/h \\rfloor$，确保覆盖 $[0,T]$。\n- 通过在每个网格点上计算 $e^{A(\\rho) t_k}\\mathbf{x}(0)$ 来计算参考解。为了提高效率，利用 $A(\\rho)$ 是常数这一特点：计算特征分解 $A(\\rho) = V D V^{-1}$，然后对于每个 $t$ 计算 $e^{A(\\rho) t} = V \\,\\mathrm{diag}(e^{s_1 t}, e^{s_2 t})\\, V^{-1}$。\n- 在整个网格上应用步长为 $h$ 的4阶显式 Runge–Kutta 方法，以获得 $\\mathbf{y}^{\\text{exp}}(t_k)$。\n- 应用一个隐式 Runge–Kutta 配置求解器（Radau IIA），约束其 $\\text{max\\_step} = h$ 并使用紧密的容差，以获得在相同 $t_k$ 处采样的 $\\mathbf{y}^{\\text{imp}}(t_k)$。\n- 为每种方法计算中子布居的最大相对误差：\n$$\n\\max_k \\frac{\\left|n_{\\text{num}}(t_k) - n_{\\text{exact}}(t_k)\\right|}{\\max\\left(10^{-14},\\, n_{\\text{exact}}(t_k)\\right)}.\n$$\n- 通过检查所有 $n_{\\text{num}}(t_k)$ 是否为有限且 $\\ge 0$ 来评估稳定性。\n\n该测试套件考察了：\n- 一个次临界情况（$\\rho = 0.003$），使用适中的 $h$ 来展示典型行为（瞬发调整后，缓发拖尾占主导）。\n- 一个近瞬发临界情况（$\\rho = 0.00649$），突显了当瞬发跳变因子 $J \\approx \\frac{\\beta}{\\beta - \\rho}$ 变大时，刚性敏感度和显式方法潜在的不稳定性。\n- 一个超瞬发临界情况（$\\rho = 0.008$），其中一个特征值变为正；中子布居迅速增长，对步长稳定性和精度构成挑战。\n- 一个负反应性情况（$\\rho = -0.002$），产生停堆瞬态，其中刚性来自于快速衰减与慢速拖尾的耦合。\n\n在最大步长相同的情况下，隐式方法的 $A$-稳定性及其对刚性模态的处理应在所有情况下产生更小的误差并保持非负性和有界性，而显式方法在瞬发区附近可能会产生更大的误差或不稳定性，尤其是在 $\\rho \\approx \\beta$ 或当 $h$ 相对于 $\\Lambda$ 不够小时。程序按照规定计算并报告比较指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import eig\n\ndef A_matrix(rho, beta, Lambda, lam):\n    \"\"\"Construct the system matrix A for given parameters.\"\"\"\n    return np.array([[ (rho - beta) / Lambda, lam ],\n                     [ beta / Lambda,          -lam ]], dtype=float)\n\ndef rk4_fixed_step(f, t_grid, y0):\n    \"\"\"Explicit RK4 with fixed steps over t_grid.\"\"\"\n    y = np.zeros((len(y0), len(t_grid)))\n    y[:, 0] = y0\n    for k in range(len(t_grid) - 1):\n        t = t_grid[k]\n        h = t_grid[k+1] - t\n        yk = y[:, k]\n        k1 = f(t, yk)\n        k2 = f(t + 0.5*h, yk + 0.5*h*k1)\n        k3 = f(t + 0.5*h, yk + 0.5*h*k2)\n        k4 = f(t + h,     yk + h*k3)\n        y[:, k+1] = yk + (h/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n    return y\n\ndef exact_solution_on_grid(A, t_grid, y0):\n    \"\"\"Compute exact solution e^{A t} y0 at grid points using eigendecomposition.\"\"\"\n    # Eigendecomposition A = V D V^{-1}\n    vals, V = eig(A)\n    Vinv = np.linalg.inv(V)\n    # y(t) = V * exp(D t) * V^{-1} * y0\n    y_exact = np.zeros((len(y0), len(t_grid)), dtype=np.complex128)\n    coeff = Vinv @ y0\n    for i, t in enumerate(t_grid):\n        exp_diag = np.exp(vals * t)\n        y_exact[:, i] = V @ (exp_diag * coeff)\n    # Return real part (solution is real by construction)\n    return np.real(y_exact)\n\ndef compute_metrics(n_num, n_exact):\n    \"\"\"Compute max relative error and stability boolean.\"\"\"\n    # Relative error defined element-wise and take max\n    denom = np.maximum(1e-14, n_exact)\n    rel_errors = np.abs(n_num - n_exact) / denom\n    max_rel_error = float(np.max(rel_errors))\n    # Stability: finite and non-negative\n    stable = bool(np.all(np.isfinite(n_num)) and np.all(n_num >= 0.0))\n    return max_rel_error, stable\n\ndef solve():\n    # Define test cases from the problem statement\n    test_cases = [\n        # (beta, Lambda, lam, rho, T, h)\n        (0.0065, 5.0e-5, 0.08, 0.00300, 10.0, 0.0010),\n        (0.0065, 5.0e-5, 0.08, 0.00649,  3.0, 0.0020),\n        (0.0065, 5.0e-5, 0.08, 0.00800,  0.2, 0.0001),\n        (0.0065, 5.0e-5, 0.08, -0.0020, 10.0, 0.0020),\n    ]\n    n0 = 1.0\n\n    results = []\n    for beta, Lambda, lam, rho, T, h in test_cases:\n        # Initial condition at t=0 (steady state at rho=0 prior to step)\n        C0 = beta / (Lambda * lam) * n0\n        y0 = np.array([n0, C0], dtype=float)\n\n        # Build A and time grid\n        A = A_matrix(rho, beta, Lambda, lam)\n        n_steps = int(np.floor(T / h))\n        t_grid = np.linspace(0.0, n_steps * h, n_steps + 1)\n\n        # Right-hand side function f(t, y) = A y\n        def f(t, y):\n            return A @ y\n\n        # Exact solution\n        y_exact = exact_solution_on_grid(A, t_grid, y0)\n        n_exact = y_exact[0, :]\n\n        # Explicit RK4 fixed-step\n        y_exp = rk4_fixed_step(f, t_grid, y0)\n        n_exp = y_exp[0, :]\n        err_exp, stable_exp = compute_metrics(n_exp, n_exact)\n\n        # Implicit Radau collocation via solve_ivp, constrained by max_step=h and sample at t_grid\n        # Use tight tolerances to emphasize method accuracy and stability properties.\n        sol_imp = solve_ivp(\n            fun=lambda t, y: f(t, y),\n            t_span=(t_grid[0], t_grid[-1]),\n            y0=y0,\n            method='Radau',\n            t_eval=t_grid,\n            max_step=h,\n            rtol=1e-10,\n            atol=1e-12\n        )\n        y_imp = sol_imp.y\n        n_imp = y_imp[0, :]\n        err_imp, stable_imp = compute_metrics(n_imp, n_exact)\n\n        results.append([err_exp, stable_exp, err_imp, stable_imp])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的反应堆中，反应性不仅受控制棒等外部因素影响，还与功率、温度等内部状态变量密切相关，形成反馈回路。本练习将挑战您从线性的点堆动力学模型迈向更符合实际的非线性耦合系统，通过引入慢化剂温度反馈来模拟“无紧急停堆的预期瞬态”（ATWS）场景。完成此项练习将使您能够分析反应堆在复杂工况下的自稳定能力，这是反应堆安全分析中的一项核心技能。",
            "id": "4256420",
            "problem": "考虑一个无紧急停堆的预期瞬态 (ATWS) 场景，其中控制棒卡住，外部引入的反应性斜坡导致反应性缓慢正向增加。目标是使用带有单组缓发中子和通过慢化剂温度的集总热反馈的点堆动力学框架，对于几组参数集，确定反应堆功率在有限的时间范围内是趋于稳定还是发散。所有涉及物理单位的量，都必须用国际单位制 (SI) 表示。\n\n从中子和先驱核的守恒以及集总热能平衡出发，推导出关于中子布居数 $n(t)$、单组缓发中子先驱核浓度 $C(t)$ 和慢化剂温度 $T(t)$ 的控制常微分方程，这些方程应使用以下各项来表示：\n- 反应性 $\\rho(t)$，由外部引入的斜坡 $\\rho_{\\mathrm{ext}}(t) = r t$ 和温度反馈项 $\\rho_{\\mathrm{fb}}(t) = \\alpha_T \\left(T(t) - T_{\\mathrm{ref}}\\right)$ 组成，\n- 有效缓发中子份额 $\\beta$，\n- 瞬发中子代时间 (平均代寿期) $\\Lambda$，\n- 单组先驱核衰变常数 $\\lambda$，\n- 热功率定标 $P(t) = P_0 \\, n(t)$，其中 $P_0$ 的单位是瓦特，$n(t)$ 是无量纲的 (归一化为 $n(0) = 1$)，\n- 集总热容 $C_T$，单位为焦耳每开尔文，\n- 向环境热阱的一阶排热，时间常数为 $\\tau$ (单位为秒)，环境温度为 $T_\\infty$ (单位为开尔文)。\n\n假设初始条件为 $n(0) = 1$ (无量纲)，$C(0)$ 与零反应性和恒定功率下的稳态一致，$T(0) = T_{\\mathrm{ref}}$ (单位为开尔文)。对每组参数集，在指定的时间范围 $t \\in [0, t_{\\mathrm{end}}]$ (单位为秒) 内对推导出的耦合常微分方程进行积分，并根据以下算法判据判断功率是稳定还是发散：\n- 将归一化功率定义为 $p(t) = n(t)$ (无量纲)。\n- 如果以下两个条件都成立，则该情况被分类为“稳定”(布尔值为 $true$)：\n  1. 对于指定的无量纲界限 $p_{\\mathrm{lim}}$，满足 $\\max_{t \\in [0,t_{\\mathrm{end}}]} p(t) \\le p_{\\mathrm{lim}}$，\n  2. 在模拟窗口的最后十分之一时间段内，最大相对斜率小于指定的阈值 $\\epsilon_{\\mathrm{rel}}$，即 $\\max_{t \\in [0.9 t_{\\mathrm{end}}, t_{\\mathrm{end}}]} \\left| \\dfrac{dp/dt}{p(t) + \\delta} \\right|  \\epsilon_{\\mathrm{rel}}$，其中 $\\delta$ 是一个仅用于避免除以零的微小正常数。\n- 否则，将该情况分类为“发散”(布尔值为 $false$)。\n\n使用以下参数集测试套件。除非另有明确说明，所有量的单位均为国际单位制 (SI)；反应性系数 $r$ 和 $\\alpha_T$ 的单位分别为每秒 $\\Delta k/k$ 和每开尔文 $\\Delta k/k$。\n\n测试用例 1 (中等斜坡，强负反馈，预期稳定):\n- $r = 1.0 \\times 10^{-5}$,\n- $\\alpha_T = -6.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (无量纲),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\n测试用例 2 (大斜坡，弱负反馈，预期发散):\n- $r = 1.0 \\times 10^{-4}$,\n- $\\alpha_T = -3.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 60.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (无量纲),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\n测试用例 3 (零斜坡，基线负反馈，预期稳定):\n- $r = 0.0$,\n- $\\alpha_T = -5.0 \\times 10^{-5}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (无量纲),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\n测试用例 4 (中等斜坡，极强负反馈，预期稳定):\n- $r = 5.0 \\times 10^{-5}$,\n- $\\alpha_T = -1.5 \\times 10^{-4}$,\n- $\\beta = 6.5 \\times 10^{-3}$,\n- $\\Lambda = 1.0 \\times 10^{-4}$ s,\n- $\\lambda = 8.0 \\times 10^{-2}$ s$^{-1}$,\n- $P_0 = 1.0 \\times 10^{8}$ W,\n- $C_T = 5.0 \\times 10^{8}$ J/K,\n- $\\tau = 50.0$ s,\n- $T_{\\mathrm{ref}} = 600.0$ K,\n- $T_\\infty = 600.0$ K,\n- $t_{\\mathrm{end}} = 200.0$ s,\n- $p_{\\mathrm{lim}} = 15.0$ (无量纲),\n- $\\epsilon_{\\mathrm{rel}} = 5.0 \\times 10^{-4}$ s$^{-1}$.\n\n您的程序必须：\n- 从所述基本原理推导出控制方程，并实现一个数值积分器来为每个测试用例求解。\n- 使用与零反应性和恒定功率的初始稳态一致的 $C(0)$。\n- 使用指定的判据判断稳定与发散，为保证数值稳健性，在分母中使用 $\\delta = 10^{-12}$。\n- 生成单行输出，其中包含四个测试用例的布尔结果，格式为方括号内的逗号分隔列表，例如：\"[true,false,true,true]\"。在 Python 中，规范的布尔字面量 \"True\" 和 \"False\" 是可接受的，并且必须按原样打印。",
            "solution": "用户提供了一个核反应堆分析问题，特别关注无紧急停堆的预期瞬态 (ATWS) 场景。该问题已经过验证，被认为是科学上合理、适定、客观和完整的。我们现在开始求解。\n\n问题的核心是使用关于中子布居数、缓发中子先驱核浓度和慢化剂温度的耦合常微分方程 (ODE) 系统来模拟核反应堆的瞬态行为。\n\n### 1. 控制常微分方程的推导\n\n我们的任务是从基本原理出发，为三个状态变量推导控制方程：无量纲中子布居数 $n(t)$、无量纲先驱核浓度 $C(t)$ 和慢化剂温度 $T(t)$。\n\n**点堆动力学方程 (PKEs)**\n中子布居数和单组有效缓发中子先驱核的时间演化由点堆动力学方程描述。\n\n中子布居数的变化率 $\\frac{dn}{dt}$ 是瞬发裂变产生的中子、因吸收和泄漏而损失的中子以及先驱核衰变产生的中子之和。该平衡表示为：\n$$ \\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\lambda C(t) \\quad \\quad (1) $$\n此处，$\\rho(t)$ 是总反应性，$\\beta$ 是有效缓发中子份额，$\\Lambda$ 是瞬发中子代时间，$\\lambda$ 是单组先驱核衰变常数。项 $\\frac{\\rho(t) - \\beta}{\\Lambda} n(t)$ 代表瞬发中子的净产生，$\\lambda C(t)$ 代表缓发中子先驱核产生的贡献。\n\n先驱核浓度的变化率 $\\frac{dC}{dt}$ 是其由裂变产生和放射性衰变之间的平衡：\n$$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) \\quad \\quad (2) $$\n项 $\\frac{\\beta}{\\Lambda} n(t)$ 代表先驱核的生成速率，该速率与裂变率成正比 (因此与 $n(t)$ 成正比)，而 $-\\lambda C(t)$ 代表它们因衰变而造成的损失。\n\n**反应性模型**\n总反应性 $\\rho(t)$ 由外部引入的线性斜坡 $\\rho_{\\mathrm{ext}}(t)$ 和依赖于温度的反馈项 $\\rho_{\\mathrm{fb}}(t)$ 之和给出：\n$$ \\rho(t) = \\rho_{\\mathrm{ext}}(t) + \\rho_{\\mathrm{fb}}(t) = r t + \\alpha_T (T(t) - T_{\\mathrm{ref}}) $$\n此处，$r$ 是斜坡速率，$\\alpha_T$ 是慢化剂温度反应性系数，$T_{\\mathrm{ref}}$ 是反馈反应性为零时的参考温度。\n\n**热工水力模型**\n考虑慢化剂的集总参数能量平衡。慢化剂内能 $C_T T(t)$ 的变化率等于反应堆堆芯产生的热量减去排向环境热阱的热量。\n$$ \\frac{d}{dt}(C_T T(t)) = P(t) - P_{\\mathrm{removed}}(t) $$\n给定一个恒定的热容 $C_T$，上式变为：\n$$ C_T \\frac{dT}{dt} = P(t) - P_{\\mathrm{removed}}(t) $$\n产生的热功率 $P(t)$ 与中子布居数成正比：$P(t) = P_0 n(t)$。排热被建模为一个向温度为 $T_\\infty$ 的热阱的一阶过程，时间常数为 $\\tau$。排热速率由 $\\frac{C_T}{\\tau}(T(t) - T_\\infty)$ 给出，这代表牛顿冷却。\n将这些表达式代入能量平衡方程，得到：\n$$ C_T \\frac{dT}{dt} = P_0 n(t) - \\frac{C_T}{\\tau} (T(t) - T_\\infty) $$\n两边同除以 $C_T$ 得到最终的温度常微分方程：\n$$ \\frac{dT}{dt} = \\frac{P_0}{C_T} n(t) - \\frac{1}{\\tau} (T(t) - T_\\infty) \\quad \\quad (3) $$\n\n**完整的常微分方程组**\n描述反应堆瞬态的耦合、非线性、一阶常微分方程的完整系统如下：\n1.  $$ \\frac{dn}{dt} = \\frac{r t + \\alpha_T (T(t) - T_{\\mathrm{ref}}) - \\beta}{\\Lambda} n(t) + \\lambda C(t) $$\n2.  $$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) $$\n3.  $$ \\frac{dT}{dt} = \\frac{P_0}{C_T} n(t) - \\frac{1}{\\tau} (T(t) - T_\\infty) $$\n\n### 2. 初始条件\n\n瞬态在 $t=0$ 时开始。初始条件指定为：\n*   $n(0) = 1$\n*   $T(0) = T_{\\mathrm{ref}}$\n*   $C(0)$ 与零反应性 ($\\rho=0$) 和恒定功率下的稳态一致。\n\n为了求得 $C(0)$，我们将点堆动力学方程 (PKEs) 中的时间导数设为零，并代入 $n(0) = 1$ 和 $\\rho(0)=0$：\n$$ \\frac{dn}{dt} = 0 \\implies 0 = \\frac{0 - \\beta}{\\Lambda} n(0) + \\lambda C(0) $$\n$$ \\frac{dC}{dt} = 0 \\implies 0 = \\frac{\\beta}{\\Lambda} n(0) - \\lambda C(0) $$\n两个方程都得出相同的关系。从第二个方程可知：\n$$ \\lambda C(0) = \\frac{\\beta}{\\Lambda} n(0) $$\n代入 $n(0)=1$：\n$$ C(0) = \\frac{\\beta}{\\lambda \\Lambda} $$\n因此，用于数值积分的初始状态向量为 $\\mathbf{y}(0) = [n(0), C(0), T(0)]^T = \\left[ 1, \\frac{\\beta}{\\lambda \\Lambda}, T_{\\mathrm{ref}} \\right]^T$。\n\n### 3. 数值积分与稳定判据\n\n推导出的常微分方程组没有通用的解析解，必须进行数值求解。我们将使用一个标准的数值积分程序 `scipy.integrate.solve_ivp`，为每个测试用例在时间区间 $[0, t_{\\mathrm{end}}]$ 上求解这个初值问题。\n\n在获得归一化功率 $p(t) = n(t)$ 的解之后，我们应用指定的算法判据将结果分类为“稳定”($true$) 或“发散”($false$)。\n\n当且仅当两个条件都满足时，一个案例被分类为“稳定”：\n1.  **峰值功率限制**：在整个模拟过程中，最大归一化功率不超过限制值 $p_{\\mathrm{lim}}$。\n    $$ \\max_{t \\in [0,t_{\\mathrm{end}}]} p(t) \\le p_{\\mathrm{lim}} $$\n2.  **相对斜率限制**：系统正在接近稳态，这表现为在模拟时间的最后 $10\\%$ 内，功率曲线的最大相对斜率很小。\n    $$ \\max_{t \\in [0.9 t_{\\mathrm{end}}, t_{\\mathrm{end}}]} \\left| \\dfrac{dp/dt}{p(t) + \\delta} \\right|  \\epsilon_{\\mathrm{rel}} $$\n导数 $\\frac{dp}{dt} = \\frac{dn}{dt}$ 是使用计算出的 $n(t)$、$C(t)$ 和 $T(t)$ 的值，直接从第一个常微分方程中求得。微小常数 $\\delta = 10^{-12}$ 确保了数值稳定性。\n\n如果这两个条件中有任何一个不满足，该案例就被分类为“发散”。这一逻辑将被应用于每个测试用例，以生成最终的布尔结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the reactor kinetics problem for a series of test cases and\n    determines if the reactor power stabilizes or diverges based on given criteria.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1: moderate ramp, strong negative feedback\n        {\n            'r': 1.0e-5, 'alpha_T': -6.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 2: strong ramp, weak negative feedback\n        {\n            'r': 1.0e-4, 'alpha_T': -3.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 60.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 3: zero ramp, baseline negative feedback\n        {\n            'r': 0.0, 'alpha_T': -5.0e-5, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        },\n        # Test Case 4: moderate ramp, very strong negative feedback\n        {\n            'r': 5.0e-5, 'alpha_T': -1.5e-4, 'beta': 6.5e-3, 'Lambda': 1.0e-4, 'lambda_': 8.0e-2,\n            'P0': 1.0e8, 'C_T': 5.0e8, 'tau': 50.0, 'T_ref': 600.0, 'T_inf': 600.0,\n            't_end': 200.0, 'p_lim': 15.0, 'epsilon_rel': 5.0e-4, 'delta': 1.0e-12\n        }\n    ]\n\n    results = []\n\n    def derivatives(t, y, p):\n        \"\"\"\n        Computes the derivatives for the coupled ODE system.\n        y = [n, C, T]\n        p = dictionary of parameters\n        \"\"\"\n        n, C, T = y\n        \n        # Calculate total reactivity\n        rho = p['r'] * t + p['alpha_T'] * (T - p['T_ref'])\n        \n        # ODEs\n        dn_dt = ((rho - p['beta']) / p['Lambda']) * n + p['lambda_'] * C\n        dC_dt = (p['beta'] / p['Lambda']) * n - p['lambda_'] * C\n        dT_dt = (p['P0'] / p['C_T']) * n - (1 / p['tau']) * (T - p['T_inf'])\n        \n        return [dn_dt, dC_dt, dT_dt]\n\n    for case_params in test_cases:\n        # Set initial conditions\n        n0 = 1.0\n        C0 = case_params['beta'] / (case_params['lambda_'] * case_params['Lambda'])\n        T0 = case_params['T_ref']\n        y0 = [n0, C0, T0]\n        \n        t_span = [0, case_params['t_end']]\n        \n        # Use a sufficient number of evaluation points to accurately check criteria\n        t_eval = np.linspace(t_span[0], t_span[1], 2001)\n\n        # Solve the ODE system\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=y0,\n            args=(case_params,),\n            method='RK45',\n            t_eval=t_eval\n        )\n        \n        # Extract normalized power p(t) = n(t)\n        p_t = sol.y[0, :]\n        \n        # --- Apply Stabilization Criteria ---\n        \n        # 1. Peak Power Criterion\n        max_p = np.max(p_t)\n        crit1_met = (max_p = case_params['p_lim'])\n        \n        # 2. Relative Slope Criterion\n        # Find the start index for the final 10% of the simulation time\n        start_index = np.where(sol.t >= 0.9 * case_params['t_end'])[0][0]\n\n        # Get state variables for the final time interval\n        t_final = sol.t[start_index:]\n        y_final = sol.y[:, start_index:]\n        p_final = y_final[0, :]\n        \n        # Calculate the derivative dp/dt over the final interval\n        dp_dt_final = np.array([derivatives(t, y, case_params)[0] for t, y in zip(t_final, y_final.T)])\n        \n        # Calculate the relative slope\n        relative_slope = np.abs(dp_dt_final / (p_final + case_params['delta']))\n        \n        max_relative_slope = np.max(relative_slope)\n        crit2_met = (max_relative_slope  case_params['epsilon_rel'])\n\n        # Final decision\n        is_stable = crit1_met and crit2_met\n        results.append(is_stable)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}