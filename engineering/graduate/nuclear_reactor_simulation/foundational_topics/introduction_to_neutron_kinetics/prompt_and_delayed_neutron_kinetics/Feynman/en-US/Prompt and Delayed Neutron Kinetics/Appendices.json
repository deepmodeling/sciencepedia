{
    "hands_on_practices": [
        {
            "introduction": "This practice lays the groundwork for understanding reactor transients by focusing on the fundamental response to a step reactivity insertion. By deriving and solving the in-hour equation for a simplified one-group model, you will calculate the stable reactor period, which governs the asymptotic exponential growth of the neutron population. This exercise solidifies the connection between reactivity, delayed neutrons, and the characteristic timescales of reactor behavior .",
            "id": "4243047",
            "problem": "A homogeneous thermal nuclear reactor is modeled by point kinetics with a single-effective delayed neutron group. Under the point kinetics approximation, the total neutron population evolves due to prompt and delayed neutron production and losses. When a small step reactivity is inserted at time $t=0$, the neutron population exhibits exponential modes whose rates are determined by the coupled balance of prompt neutrons and delayed neutron precursors.\n\nAssume the reactor is initially critical and at $t=0$ a constant positive reactivity insertion of magnitude $\\rho$ is applied. The effective total delayed neutron fraction is $\\beta$, the prompt neutron generation time is $\\Lambda$, and the effective decay constant of the single delayed neutron group is $\\lambda$. The governing ordinary differential equations (ODE) for the neutron population $n(t)$ and the delayed neutron precursor concentration $C(t)$ are the standard point kinetics equations based on neutron balance and precursor decay laws.\n\nGiven $\\beta = 0.0065$, $\\Lambda = 1 \\times 10^{-5}\\,\\mathrm{s}$, $\\lambda = 0.08\\,\\mathrm{s}^{-1}$, and $\\rho = 0.004$, derive from first principles the characteristic equation for the exponential modes and determine the asymptotic exponential growth rate $s$ of the neutron population, defined by $n(t) \\propto \\exp(s t)$ for long times. Express the final value of $s$ in $\\mathrm{s}^{-1}$ and round your answer to four significant figures.",
            "solution": "The problem is assessed to be valid. It is scientifically grounded in the well-established point kinetics model of nuclear reactor dynamics, is mathematically well-posed, and provides a complete and consistent set of data for determining a unique solution.\n\nThe reactor dynamics are described by the point kinetics equations for the neutron population, $n(t)$, and the concentration of a single effective group of delayed neutron precursors, $C(t)$. For a constant reactivity insertion $\\rho$ applied at $t=0$, the governing linear ordinary differential equations for $t0$ are:\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho - \\beta}{\\Lambda} n(t) + \\lambda C(t) \\quad (1)\n$$\n$$\n\\frac{dC(t)}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t) \\quad (2)\n$$\nHere, $\\beta$ is the effective delayed neutron fraction, $\\Lambda$ is the prompt neutron generation time, and $\\lambda$ is the effective precursor decay constant.\n\nTo find the exponential modes of the system, we assume solutions of the form $n(t) = n_0 \\exp(st)$ and $C(t) = C_0 \\exp(st)$, where $s$ is the inverse time constant, or exponential rate, and $n_0$ and $C_0$ are amplitudes. Substituting these into equations (1) and (2) yields a system of algebraic equations:\n$$\ns n_0 \\exp(st) = \\frac{\\rho - \\beta}{\\Lambda} n_0 \\exp(st) + \\lambda C_0 \\exp(st)\n$$\n$$\ns C_0 \\exp(st) = \\frac{\\beta}{\\Lambda} n_0 \\exp(st) - \\lambda C_0 \\exp(st)\n$$\nFor non-trivial solutions, we can divide by $\\exp(st)$:\n$$\ns n_0 = \\frac{\\rho - \\beta}{\\Lambda} n_0 + \\lambda C_0 \\quad (3)\n$$\n$$\ns C_0 = \\frac{\\beta}{\\Lambda} n_0 - \\lambda C_0 \\quad (4)\n$$\nFrom equation (4), we can express the amplitude $C_0$ in terms of $n_0$:\n$$\nC_0(s + \\lambda) = \\frac{\\beta}{\\Lambda} n_0\n$$\n$$\nC_0 = \\frac{\\beta}{\\Lambda(s + \\lambda)} n_0\n$$\nSubstituting this expression for $C_0$ into equation (3):\n$$\ns n_0 = \\frac{\\rho - \\beta}{\\Lambda} n_0 + \\lambda \\left( \\frac{\\beta}{\\Lambda(s + \\lambda)} n_0 \\right)\n$$\nFor a non-zero neutron population ($n_0 \\neq 0$), we divide by $n_0$ to obtain the characteristic equation for $s$:\n$$\ns = \\frac{\\rho - \\beta}{\\Lambda} + \\frac{\\lambda \\beta}{\\Lambda(s + \\lambda)}\n$$\nThis equation is commonly rearranged by solving for $\\rho$, which gives the standard form of the in-hour equation:\n$$\ns\\Lambda = \\rho - \\beta + \\frac{\\lambda\\beta}{s+\\lambda}\n$$\n$$\n\\rho = s\\Lambda + \\beta - \\frac{\\lambda\\beta}{s+\\lambda} = s\\Lambda + \\beta\\left(1 - \\frac{\\lambda}{s+\\lambda}\\right) = s\\Lambda + \\beta\\left(\\frac{s+\\lambda-\\lambda}{s+\\lambda}\\right)\n$$\n$$\n\\rho = s\\Lambda + \\frac{s\\beta}{s+\\lambda}\n$$\nThe asymptotic growth rate is the dominant (largest, most positive) root of this equation. To find the roots, we rearrange the equation into a polynomial in $s$:\n$$\n\\rho(s+\\lambda) = s\\Lambda(s+\\lambda) + s\\beta\n$$\n$$\n\\rho s + \\rho\\lambda = s^2\\Lambda + s\\lambda\\Lambda + s\\beta\n$$\n$$\n\\Lambda s^2 + (\\lambda\\Lambda + \\beta - \\rho)s - \\rho\\lambda = 0\n$$\nThis is a quadratic equation of the form $as^2+bs+c=0$ with coefficients:\n$a = \\Lambda$\n$b = \\lambda\\Lambda + \\beta - \\rho$\n$c = -\\rho\\lambda$\n\nThe roots are given by the quadratic formula. The asymptotic growth rate corresponds to the larger root (using the `+` sign in the numerator):\n$$\ns = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a} = \\frac{-(\\lambda\\Lambda + \\beta - \\rho) + \\sqrt{(\\lambda\\Lambda + \\beta - \\rho)^2 + 4\\Lambda\\rho\\lambda}}{2\\Lambda}\n$$\nWe are given the following values:\n$\\beta = 0.0065$\n$\\Lambda = 1 \\times 10^{-5}\\,\\mathrm{s}$\n$\\lambda = 0.08\\,\\mathrm{s}^{-1}$\n$\\rho = 0.004$\n\nFirst, we compute the coefficients $a$, $b$, and $c$:\n$a = \\Lambda = 1 \\times 10^{-5}$\n$b = \\lambda\\Lambda + \\beta - \\rho = (0.08)(1 \\times 10^{-5}) + 0.0065 - 0.004 = 8 \\times 10^{-7} + 0.0025 = 0.0025008$\n$c = -\\rho\\lambda = -(0.004)(0.08) = -0.00032$\n\nNext, we compute the discriminant, $D = b^2 - 4ac$:\n$b^2 = (0.0025008)^2 = 6.25400064 \\times 10^{-6}$\n$-4ac = -4(1 \\times 10^{-5})(-0.00032) = 1.28 \\times 10^{-8} = 0.0128 \\times 10^{-6}$\n$D = 6.25400064 \\times 10^{-6} + 0.0128 \\times 10^{-6} = 6.26680064 \\times 10^{-6}$\n\nNow, we calculate the square root of the discriminant:\n$\\sqrt{D} = \\sqrt{6.26680064 \\times 10^{-6}} \\approx 0.00250335787$\n\nFinally, we substitute these values into the formula for $s$:\n$$\ns = \\frac{-b + \\sqrt{D}}{2a} = \\frac{-0.0025008 + 0.00250335787}{2 \\times (1 \\times 10^{-5})}\n$$\n$$\ns = \\frac{0.00000255787}{2 \\times 10^{-5}} = \\frac{2.55787 \\times 10^{-6}}{2 \\times 10^{-5}} \\approx 0.1278935 \\, \\mathrm{s}^{-1}\n$$\nRounding the result to four significant figures as requested gives:\n$$\ns \\approx 0.1279 \\, \\mathrm{s}^{-1}\n$$\nThis positive root corresponds to the stable reactor period, which governs the long-term exponential growth of the neutron population following a supercritical reactivity insertion.",
            "answer": "$$\\boxed{0.1279}$$"
        },
        {
            "introduction": "Real-world reactor transients can occur over extremely short timescales, where full numerical solutions can be complex. This hands-on coding practice introduces the powerful prompt jump approximation (PJA), a cornerstone of rapid transient analysis. You will implement and compare the PJA against a direct numerical integration of the multi-group point kinetics equations, providing quantitative insight into the approximation's validity and its utility in modeling fast reactivity changes .",
            "id": "4243064",
            "problem": "A reactor is described by single-region point kinetics with one prompt neutron population and six delayed neutron precursor groups. Consider a finite-duration reactivity pulse with amplitude applied instantaneously at time $t=0$ and held constant for a duration of $1\\,\\mathrm{ms}$, after which the reactivity is returned instantaneously to zero. The goal is to compare predictions for the neutron density $n(t)$ at $t=10\\,\\mathrm{ms}$ computed by (i) direct integration of the point kinetics equations and (ii) a model employing the prompt jump approximation at the two discontinuities, and to quantify the discrepancy. All time quantities must be handled in seconds internally; the specified evaluation time is $t=10\\,\\mathrm{ms}=0.01\\,\\mathrm{s}$. The final neutron densities are dimensionless (relative to the initial steady state), and discrepancies should be reported as dimensionless floats.\n\nStart from the following base, which are to be used as the fundamental laws and definitions for this problem:\n\n- The point kinetics equations with delayed neutron groups:\n$$\\frac{dn(t)}{dt}=\\frac{\\rho(t)-\\beta}{\\Lambda}n(t)+\\sum_{i=1}^{6}\\lambda_i C_i(t),$$\n$$\\frac{dC_i(t)}{dt}=\\frac{\\beta_i}{\\Lambda}n(t)-\\lambda_i C_i(t),\\quad i=1,\\dots,6,$$\nwhere $n(t)$ is the neutron density, $C_i(t)$ is the concentration of the $i$-th delayed neutron precursor group, $\\rho(t)$ is the reactivity (dimensionless), $\\beta=\\sum_{i=1}^{6}\\beta_i$ is the total delayed neutron fraction (dimensionless), $\\Lambda$ is the prompt neutron generation time (in seconds), and $\\lambda_i$ are decay constants of precursor groups (in $\\mathrm{s}^{-1}$). These equations are well-tested models for reactor kinetics under the point kinetics assumption.\n\n- At initial steady state with zero reactivity, the time derivatives vanish, and the steady-state relationships are:\n$$\\rho(0^-)=0,\\quad \\frac{dn}{dt}=0,\\quad \\frac{dC_i}{dt}=0,$$\nwhich imply\n$$\\sum_{i=1}^{6}\\lambda_i C_i(0^-)=\\frac{\\beta}{\\Lambda}n(0^-),\\quad C_i(0^-)=\\frac{\\beta_i}{\\lambda_i \\Lambda}n(0^-).$$\n\nDefine the reactivity pulse as\n$$\\rho(t)=\\begin{cases}\\Delta \\rho, 0\\le t t_p,\\\\ 0, t\\ge t_p,\\end{cases}$$\nwith pulse duration $t_p=1\\times 10^{-3}\\,\\mathrm{s}$ and $\\Delta \\rho$ specified per test case. The evaluation time is fixed at $t_f=10\\times 10^{-3}\\,\\mathrm{s}$.\n\nTwo models must be implemented:\n\n1. The \"exact\" model integrates the point kinetics differential equations directly, starting from the initial steady state at $t=0$ with $n(0)=1$ and $C_i(0)=\\beta_i/(\\lambda_i \\Lambda)$, using the above piecewise-constant $\\rho(t)$.\n\n2. The \"prompt jump\" approximation model enforces the continuity of precursor concentrations $C_i(t)$ across each instantaneous reactivity discontinuity and treats the neutron density $n(t)$ as undergoing an instantaneous rescaling at each discontinuity to preserve the precursor source consistency. Between discontinuities, integrate the point kinetics equations with the appropriate constant reactivity.\n\nFor all computations, use the following physically plausible and scientifically standard parameter values for uranium-235 delayed neutron data (six groups), prompt neutron generation time, and initial conditions:\n- Prompt neutron generation time $\\Lambda=1.0\\times 10^{-4}\\,\\mathrm{s}$.\n- Delayed neutron fractions $\\beta_i$ (dimensionless) by group:\n  - $\\beta_1=2.15\\times 10^{-4}$,\n  - $\\beta_2=1.424\\times 10^{-3}$,\n  - $\\beta_3=1.274\\times 10^{-3}$,\n  - $\\beta_4=2.568\\times 10^{-3}$,\n  - $\\beta_5=7.48\\times 10^{-4}$,\n  - $\\beta_6=2.73\\times 10^{-4}$,\n  so that the total delayed neutron fraction is $\\beta=\\sum_{i=1}^{6}\\beta_i=6.502\\times 10^{-3}$.\n- Decay constants $\\lambda_i$ (in $\\mathrm{s}^{-1}$) by group:\n  - $\\lambda_1=1.24\\times 10^{-2}$,\n  - $\\lambda_2=3.05\\times 10^{-2}$,\n  - $\\lambda_3=1.11\\times 10^{-1}$,\n  - $\\lambda_4=3.01\\times 10^{-1}$,\n  - $\\lambda_5=1.14$,\n  - $\\lambda_6=3.01$.\n- Initial conditions at $t=0$ are steady-state values for $\\rho=0$: $n(0)=1$ and $C_i(0)=\\beta_i/(\\lambda_i \\Lambda)$ for each $i$.\n\nImplement both models and, for each test case, compute:\n- The neutron density $n_{\\mathrm{exact}}(t_f)$ from the exact model (dimensionless).\n- The neutron density $n_{\\mathrm{pj}}(t_f)$ from the prompt jump model (dimensionless).\n- The absolute discrepancy $d_{\\mathrm{abs}}=|n_{\\mathrm{exact}}(t_f)-n_{\\mathrm{pj}}(t_f)|$ (dimensionless).\n- The relative discrepancy $d_{\\mathrm{rel}}=d_{\\mathrm{abs}}/n_{\\mathrm{exact}}(t_f)$ (dimensionless).\n\nTest suite specifications:\n- Case 1 (general case): $\\Delta \\rho=2.0\\times 10^{-3}$.\n- Case 2 (near prompt-critical boundary but subprompt): $\\Delta \\rho=6.2\\times 10^{-3}$.\n- Case 3 (negative pulse): $\\Delta \\rho=-1.0\\times 10^{-3}$.\n- Case 4 (very small pulse edge case): $\\Delta \\rho=1.0\\times 10^{-5}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of four floats in the order $[n_{\\mathrm{exact}}(t_f),n_{\\mathrm{pj}}(t_f),d_{\\mathrm{abs}},d_{\\mathrm{rel}}]$. For example, the output format must be:\n$$\\texttt{[[n1\\_exact,n1\\_pj,d1\\_abs,d1\\_rel],[n2\\_exact,n2\\_pj,d2\\_abs,d2\\_rel],[n3\\_exact,n3\\_pj,d3\\_abs,d3\\_rel],[n4\\_exact,n4\\_pj,d4\\_abs,d4\\_rel]]}$$\nwith no additional text. All quantities are dimensionless and time units are in seconds internally, with the specified evaluation time being $0.01\\,\\mathrm{s}$.",
            "solution": "The problem requires the solution of the point kinetics equations for a reactor subjected to a finite-duration reactivity pulse and a comparison with the prompt jump approximation model. The problem is scientifically grounded, well-posed, and objective. It is based on standard models in nuclear reactor physics—the point kinetics equations—and uses physically plausible parameters for a uranium-235 fueled system. It constitutes a well-defined initial value problem with a clear objective. Thus, the problem is valid and a solution can be constructed.\n\n### 1. Mathematical Model: Point Kinetics Equations\n\nThe time evolution of the neutron density, $n(t)$, and the concentrations of the six delayed neutron precursor groups, $C_i(t)$, is governed by the system of linear ordinary differential equations (ODEs):\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t)-\\beta}{\\Lambda}n(t) + \\sum_{i=1}^{6}\\lambda_i C_i(t)\n$$\n$$\n\\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda}n(t) - \\lambda_i C_i(t), \\quad i=1,\\dots,6\n$$\nwhere $\\rho(t)$ is the reactivity, $\\Lambda$ is the prompt neutron generation time, $\\beta_i$ and $\\lambda_i$ are the delayed neutron fraction and decay constant for precursor group $i$, respectively, and $\\beta = \\sum_{i=1}^{6}\\beta_i$ is the total delayed neutron fraction.\n\nThis system of $7$ equations can be expressed in matrix form. Let the state vector be $Y(t) = [n(t), C_1(t), ..., C_6(t)]^T$. Then the system is:\n$$\n\\frac{dY(t)}{dt} = A(\\rho(t)) Y(t)\n$$\nwhere $A$ is the $7 \\times 7$ kinetics matrix, which depends on the reactivity $\\rho$:\n$$\nA(\\rho) = \\begin{pmatrix}\n\\frac{\\rho - \\beta}{\\Lambda}  \\lambda_1  \\lambda_2  \\dots  \\lambda_6 \\\\\n\\frac{\\beta_1}{\\Lambda}  -\\lambda_1  0  \\dots  0 \\\\\n\\frac{\\beta_2}{\\Lambda}  0  -\\lambda_2  \\dots  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n\\frac{\\beta_6}{\\Lambda}  0  0  \\dots  -\\lambda_6\n\\end{pmatrix}\n$$\nFor a piecewise-constant reactivity, $\\rho(t) = \\rho_k$ over an interval $[t_{k-1}, t_k)$, the matrix $A(\\rho_k)$ is constant. The solution to this linear system with constant coefficients is given by the matrix exponential:\n$$\nY(t) = e^{A(\\rho_k)(t-t_{k-1})} Y(t_{k-1})\n$$\n\n### 2. \"Exact\" Model Solution\n\nThe reactivity $\\rho(t)$ is a piecewise-constant function defined by the pulse:\n$$\n\\rho(t) = \\begin{cases}\n\\Delta \\rho,  0 \\le t  t_p \\\\\n0,  t \\ge t_p\n\\end{cases}\n$$\nwith $t_p = 1 \\times 10^{-3}\\,\\mathrm{s}$. We need to find the state at $t_f = 1 \\times 10^{-2}\\,\\mathrm{s}$.\n\nThe initial conditions at $t=0$ correspond to a critical steady state with $\\rho(0^-)=0$. The time derivatives are zero, which gives $n(0)=1$ (by normalization) and $C_i(0) = \\frac{\\beta_i}{\\lambda_i \\Lambda}n(0) = \\frac{\\beta_i}{\\lambda_i \\Lambda}$. This defines the initial state vector $Y(0)$.\n\nThe solution proceeds in two steps:\n1.  **Interval 1 ($0 \\le t  t_p$):** The reactivity is constant at $\\rho = \\Delta\\rho$. The state at the end of the pulse, $t_p$, is found by evolving the initial state $Y(0)$:\n    $$\n    Y(t_p) = e^{A(\\Delta\\rho)t_p} Y(0)\n    $$\n2.  **Interval 2 ($t_p \\le t \\le t_f$):** The reactivity returns to $\\rho = 0$. The state at the final time $t_f$ is found by evolving the state from $t_p$ over the duration $t_f - t_p$:\n    $$\n    Y(t_f) = e^{A(0)(t_f-t_p)} Y(t_p)\n    $$\nCombining these steps, the final state for the exact model is:\n$$\nY_{\\mathrm{exact}}(t_f) = e^{A(0)(t_f-t_p)} e^{A(\\Delta\\rho)t_p} Y(0)\n$$\nThe neutron density $n_{\\mathrm{exact}}(t_f)$ is the first component of the vector $Y_{\\mathrm{exact}}(t_f)$.\n\n### 3. Prompt Jump Approximation (PJA) Model\n\nThe prompt jump approximation is valid when the reactivity changes on a timescale much faster than the precursor decay constants, but not necessarily faster than the prompt neutron generation time. The model assumes that precursor concentrations $C_i(t)$ are continuous across an instantaneous reactivity change, while the neutron density $n(t)$ \"jumps\" to a new value.\n\nThe jump condition is derived by assuming that the term $\\Lambda \\frac{dn}{dt}$ is negligible away from the discontinuity, leading to the quasi-static relation $n(t) \\approx \\frac{\\Lambda}{\\beta - \\rho(t)} \\sum_{i=1}^{6}\\lambda_i C_i(t)$. Across a discontinuity at time $t_d$, since the precursor concentrations $C_i$ (and thus their sum) are continuous, the neutron density must jump to maintain this relation. This gives the jump ratio:\n$$\n\\frac{n(t_d^+)}{n(t_d^-)} = \\frac{\\beta - \\rho(t_d^-)}{\\beta - \\rho(t_d^+)}\n$$\n\nThe solution algorithm for the PJA model is as follows:\n1.  **Initial State ($t = 0^-$):** The system starts at the same steady state as the exact model, $Y(0^-) = Y(0)$.\n2.  **Jump at $t = 0$:** Reactivity changes from $\\rho(0^-) = 0$ to $\\rho(0^+) = \\Delta\\rho$.\n    -   The precursor concentrations are continuous: $C_i(0^+) = C_i(0^-)$.\n    -   The neutron density jumps: $n(0^+) = n(0^-) \\frac{\\beta - \\rho(0^-)}{\\beta - \\rho(0^+)} = n(0) \\frac{\\beta}{\\beta - \\Delta\\rho}$.\n    -   This defines a new initial state vector for the subsequent evolution, $Y_{PJ}(0^+)$.\n3.  **Evolution from $t=0^+$ to $t=t_p^-$:** The system evolves with $\\rho = \\Delta\\rho$ for duration $t_p$:\n    $$\n    Y_{PJ}(t_p^-) = e^{A(\\Delta\\rho)t_p} Y_{PJ}(0^+)\n    $$\n4.  **Jump at $t=t_p$:** Reactivity changes from $\\rho(t_p^-) = \\Delta\\rho$ to $\\rho(t_p^+) = 0$.\n    -   Precursor concentrations are continuous: $C_i(t_p^+) = C_i(t_p^-)$.\n    -   Neutron density jumps: $n(t_p^+) = n(t_p^-) \\frac{\\beta - \\rho(t_p^-)}{\\beta - \\rho(t_p^+)} = n(t_p^-) \\frac{\\beta - \\Delta\\rho}{\\beta}$.\n    -   This provides the state vector $Y_{PJ}(t_p^+)$ for the final evolution period.\n5.  **Evolution from $t=t_p^+$ to $t_f$:** The system evolves with $\\rho = 0$ for duration $t_f - t_p$:\n    $$\n    Y_{PJ}(t_f) = e^{A(0)(t_f-t_p)} Y_{PJ}(t_p^+)\n    $$\nThe neutron density $n_{\\mathrm{pj}}(t_f)$ is the first component of the vector $Y_{PJ}(t_f)$.\n\n### 4. Discrepancy Calculation\n\nThe absolute and relative discrepancies between the two models are computed at the final time $t_f$ as:\n$$\nd_{\\mathrm{abs}} = |n_{\\mathrm{exact}}(t_f) - n_{\\mathrm{pj}}(t_f)|\n$$\n$$\nd_{\\mathrm{rel}} = \\frac{d_{\\mathrm{abs}}}{n_{\\mathrm{exact}}(t_f)}\n$$\n\n### 5. Implementation\n\nThe described algorithms are implemented computationally. The kinetics matrix $A(\\rho)$ is constructed for each reactivity value. The matrix exponential $e^{At}$ is calculated using `scipy.linalg.expm`. The state vectors are propagated through each phase as described above for both the exact and PJA models. The procedure is repeated for each test case value of $\\Delta\\rho$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the point kinetics equations for a reactivity pulse and compares\n    the result with the prompt jump approximation.\n    \"\"\"\n    \n    # Define physical constants and problem parameters.\n    # Prompt neutron generation time in seconds.\n    Lambda = 1.0e-4\n    \n    # Delayed neutron fractions (dimensionless).\n    beta_i = np.array([\n        2.15e-4, 1.424e-3, 1.274e-3, 2.568e-3, 7.48e-4, 2.73e-4\n    ])\n    \n    # Decay constants in s^-1.\n    lambda_i = np.array([\n        1.24e-2, 3.05e-2, 1.11e-1, 3.01e-1, 1.14, 3.01\n    ])\n    \n    # Total delayed neutron fraction.\n    beta = np.sum(beta_i)\n    \n    # Time parameters in seconds.\n    tp = 1.0e-3  # Pulse duration\n    tf = 10.0e-3 # Final evaluation time\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        2.0e-3,     # Case 1: general\n        6.2e-3,     # Case 2: near prompt-critical\n        -1.0e-3,    # Case 3: negative pulse\n        1.0e-5      # Case 4: very small pulse\n    ]\n\n    def build_A_matrix(rho):\n        \"\"\"Builds the 7x7 point kinetics matrix A for a given reactivity rho.\"\"\"\n        A = np.zeros((7, 7))\n        # Top row for dn/dt\n        A[0, 0] = (rho - beta) / Lambda\n        A[0, 1:] = lambda_i\n        # Subsequent rows for dC_i/dt\n        A[1:, 0] = beta_i / Lambda\n        np.fill_diagonal(A[1:, 1:], -lambda_i)\n        return A\n\n    results = []\n    for delta_rho in test_cases:\n        # Initial conditions: steady state at rho=0, n=1.\n        n0 = 1.0\n        C0 = beta_i / (lambda_i * Lambda) * n0\n        Y0 = np.concatenate(([n0], C0))\n        \n        # --- Model 1: \"Exact\" Integration ---\n        # Construct matrices for the two reactivity intervals.\n        A1 = build_A_matrix(delta_rho)\n        A2 = build_A_matrix(0.0)\n        \n        # Evolve from t=0 to t=tp with rho = delta_rho.\n        Y_tp_exact = expm(A1 * tp) @ Y0\n        \n        # Evolve from t=tp to t=tf with rho = 0.\n        Y_tf_exact = expm(A2 * (tf - tp)) @ Y_tp_exact\n        n_exact = Y_tf_exact[0]\n\n        # --- Model 2: Prompt Jump Approximation ---\n        # State at t=0- is Y0.\n        \n        # Jump at t=0: rho changes from 0 to delta_rho.\n        # Precursors are continuous. Neutron density jumps.\n        n_0_plus = n0 * beta / (beta - delta_rho)\n        Y0_pj = Y0.copy()\n        Y0_pj[0] = n_0_plus\n\n        # Evolve from t=0+ to t=tp- with rho = delta_rho.\n        Y_tp_minus_pj = expm(A1 * tp) @ Y0_pj\n        n_tp_minus_pj = Y_tp_minus_pj[0]\n        \n        # Jump at t=tp: rho changes from delta_rho to 0.\n        # Precursors are continuous. Neutron density jumps.\n        n_tp_plus_pj = n_tp_minus_pj * (beta - delta_rho) / beta\n        Y_tp_plus_pj = Y_tp_minus_pj.copy()\n        Y_tp_plus_pj[0] = n_tp_plus_pj\n        \n        # Evolve from t=tp+ to t=tf with rho = 0.\n        Y_tf_pj = expm(A2 * (tf - tp)) @ Y_tp_plus_pj\n        n_pj = Y_tf_pj[0]\n\n        # --- Discrepancy Calculation ---\n        d_abs = abs(n_exact - n_pj)\n        d_rel = d_abs / n_exact if n_exact != 0 else float('inf')\n        \n        # Append the list of four floats for the current case.\n        results.append([n_exact, n_pj, d_abs, d_rel])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Neutron kinetics do not exist in a vacuum; they are intrinsically coupled with the thermal-hydraulic behavior of the reactor core. This exercise extends the point kinetics model to include temperature feedback, a critical mechanism for inherent reactor safety and stability. By simulating a coupled neutronics-thermal system and performing a linear stability analysis, you will classify the reactor's response as either overdamped or underdamped, exploring how feedback determines the qualitative nature of a transient .",
            "id": "4243049",
            "problem": "Consider the point-kinetics model for a thermal nuclear reactor with one delayed neutron group, coupled to a single lumped thermal node via a linear temperature coefficient of reactivity. The reactor undergoes a step reactivity insertion at time $t=0$ seconds. The goal is to simulate the transient response and classify whether the coupled neutron-temperature system is overdamped or underdamped. Start from the following foundational elements:\n\n- The point-kinetics ordinary differential equations (ODEs) with one delayed neutron group:\n  - Neutron population dynamics $n(t)$:\n    $$\\frac{dn}{dt} = \\left(\\frac{\\rho(t) - \\beta}{\\Lambda}\\right) n(t) + \\lambda C(t)$$\n  - Delayed neutron precursor concentration $C(t)$:\n    $$\\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t)$$\n  - Lumped thermal node temperature $T(t)$:\n    $$\\frac{dT}{dt} = \\frac{\\kappa n(t) - (T(t) - T_c)}{\\tau_T}$$\n- Reactivity feedback is represented as:\n  $$\\rho(t) = \\rho_{\\text{step}} + \\alpha_T \\left(T(t) - T_0\\right)$$\n- The effective thermal parameters are related by:\n  $$\\tau_T = \\frac{C_p}{h}, \\quad \\kappa = \\frac{k_h}{h}$$\n  where $C_p$ is the effective lumped heat capacity, $h$ is the effective heat removal coefficient to the coolant, and $k_h$ is the gain converting normalized reactor power to heat generation. Units are:\n  - $t$ in seconds,\n  - $T$ in Kelvin,\n  - $C_p$ in Joule per Kelvin,\n  - $h$ in Watt per Kelvin,\n  - $k_h$ in Watt per unit normalized power,\n  - $\\Lambda$ in seconds,\n  - $\\lambda$ in inverse seconds,\n  - $\\beta$ and $\\rho$ are dimensionless reactivity fractions,\n  - $\\alpha_T$ in reactivity per Kelvin (dimensionless per Kelvin).\n\nAssume the initial steady state at $t=0^{-}$ satisfies criticality with zero net reactivity and thermal equilibrium. Use the consistent initialization:\n- Initial neutron population $n(0^{-}) = n_0$,\n- Initial precursor concentration $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$,\n- Initial fuel temperature $T(0^{-}) = T_0$,\n- Coolant reference temperature $T_c = T_0 - \\kappa n_0$ to ensure $\\frac{dT}{dt}(0^{-}) = 0$.\n\nAt $t=0^{+}$, a step reactivity $\\rho_{\\text{step}}$ is added, and the system evolves under the coupled dynamics. For classification, linearize the system around the new equilibrium after the step, defined by $\\rho(t)=0$ and $\\frac{dn}{dt}=\\frac{dC}{dt}=\\frac{dT}{dt}=0$, and evaluate the Jacobian eigenvalues. A system is considered underdamped if the Jacobian has at least one complex-conjugate pair of eigenvalues with negative real parts, and overdamped if all eigenvalues are real with negative real parts. If any eigenvalue has a positive real part, the system is unstable; for the purposes of this problem, all provided test cases are guaranteed to be stable.\n\nYour program must simulate the ODEs and perform the eigenvalue-based classification for the following test suite. Use the specified units, and integrate for a final time of $t_{\\text{end}} = 600$ seconds to produce a numerically resolved trajectory; however, classification must be based on the Jacobian at the post-step equilibrium.\n\nTest Suite Parameters:\n\n- Case $1$ (nominal, expected overdamped):\n  - $\\beta = 0.0065$, $\\Lambda = 1.0 \\times 10^{-4}$ seconds, $\\lambda = 0.08$ inverse seconds,\n  - $\\rho_{\\text{step}} = 0.002$,\n  - $\\alpha_T = -5.0 \\times 10^{-5}$ per Kelvin,\n  - $C_p = 1.0 \\times 10^{6}$ Joule per Kelvin, $h = 2.0 \\times 10^{5}$ Watt per Kelvin, $k_h = 6.0 \\times 10^{6}$ Watt per unit power,\n  - $n_0 = 1.0$, $T_0 = 600.0$ Kelvin.\n\n- Case $2$ (weak feedback and slow thermal node, expected underdamped):\n  - $\\beta = 0.0065$, $\\Lambda = 1.0 \\times 10^{-4}$ seconds, $\\lambda = 0.08$ inverse seconds,\n  - $\\rho_{\\text{step}} = 0.002$,\n  - $\\alpha_T = -1.0 \\times 10^{-5}$ per Kelvin,\n  - $C_p = 5.0 \\times 10^{6}$ Joule per Kelvin, $h = 2.0 \\times 10^{4}$ Watt per Kelvin, $k_h = 6.0 \\times 10^{6}$ Watt per unit power,\n  - $n_0 = 1.0$, $T_0 = 600.0$ Kelvin.\n\n- Case $3$ (larger step and strong feedback, expected overdamped):\n  - $\\beta = 0.0065$, $\\Lambda = 1.0 \\times 10^{-4}$ seconds, $\\lambda = 0.08$ inverse seconds,\n  - $\\rho_{\\text{step}} = 0.004$,\n  - $\\alpha_T = -1.0 \\times 10^{-4}$ per Kelvin,\n  - $C_p = 1.0 \\times 10^{6}$ Joule per Kelvin, $h = 5.0 \\times 10^{4}$ Watt per Kelvin, $k_h = 6.0 \\times 10^{6}$ Watt per unit power,\n  - $n_0 = 1.0$, $T_0 = 600.0$ Kelvin.\n\nAlgorithmic requirements:\n- Compute $\\tau_T$ and $\\kappa$ from $C_p$, $h$, and $k_h$.\n- Initialize $T_c = T_0 - \\kappa n_0$ and $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$ so the pre-step state is steady and critical.\n- Numerically integrate the coupled ODEs from $t=0$ to $t_{\\text{end}}$ seconds to simulate the response (time in seconds, temperature in Kelvin).\n- Compute the post-step equilibrium values $(n^{\\star}, C^{\\star}, T^{\\star})$ from the steady-state conditions and form the Jacobian matrix of the right-hand side at that equilibrium.\n- Classify the damping based on the Jacobian’s eigenvalues:\n  - Output $0$ for overdamped,\n  - Output $1$ for underdamped.\n- The final program output must be a single line containing a comma-separated list of the three integer classifications for the three cases, enclosed in square brackets, for example $[0,1,0]$.\n\nYour program must not read any input and must produce its single line of output exactly in the specified format. All computations must use the above parameters and must be expressed using the prescribed physical units and mathematical definitions.",
            "solution": "The derivation begins from the fundamental point-kinetics equations and a lumped thermal energy balance, which are well-established in nuclear reactor dynamics. We consider one effective delayed neutron group to keep the model compact while capturing essential delayed neutron effects.\n\nThe neutron population $n(t)$ and delayed neutron precursor concentration $C(t)$ obey:\n$$\\frac{dn}{dt} = \\left(\\frac{\\rho(t) - \\beta}{\\Lambda}\\right) n(t) + \\lambda C(t), \\quad \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda} n(t) - \\lambda C(t),$$\nwhere $\\beta$ is the total delayed neutron fraction, $\\Lambda$ is the neutron generation time, $\\lambda$ is the effective delayed neutron decay constant, and $\\rho(t)$ is the reactor reactivity. The thermal feedback enters via the reactivity definition:\n$$\\rho(t) = \\rho_{\\text{step}} + \\alpha_T (T(t) - T_0),$$\nwith $\\rho_{\\text{step}}$ the externally imposed step at $t=0$ seconds, and $\\alpha_T$ the temperature coefficient of reactivity (typically negative for Doppler feedback). The lumped thermal node is governed by energy balance:\n$$\\frac{dT}{dt} = \\frac{\\kappa n(t) - (T(t) - T_c)}{\\tau_T},$$\nwhere $\\tau_T = C_p/h$ is the thermal time constant, $\\kappa = k_h/h$ converts normalized power to temperature rise relative to coolant, $C_p$ is the effective heat capacity, $h$ is the effective heat removal coefficient, and $k_h$ is the heat generation per unit normalized power. The coolant reference temperature $T_c$ is set such that the pre-step equilibrium is satisfied:\n$$T_c = T_0 - \\kappa n_0,$$\nmaking $\\frac{dT}{dt}(0^{-}) = 0$ when $n(0^{-})=n_0$ and $T(0^{-})=T_0$.\n\nTo ensure the reactor is initially critical and at steady state, the delayed precursor concentration must satisfy the kinetic steady-state condition with zero reactivity:\n$$\\frac{dn}{dt}(0^{-}) = 0 \\implies -\\frac{\\beta}{\\Lambda} n_0 + \\lambda C(0^{-}) = 0 \\implies C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0.$$\n\nAfter the step, the system evolves under the coupled dynamics. The new equilibrium $(n^{\\star}, C^{\\star}, T^{\\star})$ is defined by zero time derivatives and zero net reactivity:\n$$\\rho^{\\star} = \\rho_{\\text{step}} + \\alpha_T (T^{\\star} - T_0) = 0,$$\n$$\\frac{dn}{dt} = 0, \\quad \\frac{dC}{dt} = 0, \\quad \\frac{dT}{dt} = 0.$$\nFrom the thermal steady-state, we have:\n$$T^{\\star} = T_c + \\kappa n^{\\star}.$$\nImposing $\\rho^{\\star} = 0$ yields:\n$$\\rho_{\\text{step}} + \\alpha_T \\left(T_c + \\kappa n^{\\star} - T_0\\right) = 0.$$\nUsing $T_c = T_0 - \\kappa n_0$, this simplifies to:\n$$\\rho_{\\text{step}} + \\alpha_T \\kappa (n^{\\star} - n_0) = 0 \\implies n^{\\star} = n_0 - \\frac{\\rho_{\\text{step}}}{\\alpha_T \\kappa}.$$\nThe equilibrium precursor concentration follows from the kinetic steady-state condition with zero reactivity:\n$$C^{\\star} = \\frac{\\beta}{\\lambda \\Lambda} n^{\\star}.$$\nFinally, $T^{\\star}$ is obtained by thermal balance: $T^{\\star} = T_c + \\kappa n^{\\star}$.\n\nTo classify the damping behavior, we linearize the nonlinear system around $(n^{\\star}, C^{\\star}, T^{\\star})$ and examine the Jacobian (the matrix of first partial derivatives of the right-hand side). Denote the state vector $\\mathbf{x} = [n, C, T]^{\\top}$ and the right-hand side $\\mathbf{f}(\\mathbf{x})$:\n$$f_1(n,C,T) = \\left(\\frac{\\rho_{\\text{step}} + \\alpha_T (T - T_0) - \\beta}{\\Lambda}\\right) n + \\lambda C,$$\n$$f_2(n,C,T) = \\frac{\\beta}{\\Lambda} n - \\lambda C,$$\n$$f_3(n,C,T) = \\frac{\\kappa n - (T - T_c)}{\\tau_T}.$$\nThe Jacobian entries at equilibrium are:\n$$\\frac{\\partial f_1}{\\partial n}\\bigg|_{\\star} = \\frac{\\rho^{\\star} - \\beta}{\\Lambda} = -\\frac{\\beta}{\\Lambda}, \\quad \\frac{\\partial f_1}{\\partial C}\\bigg|_{\\star} = \\lambda, \\quad \\frac{\\partial f_1}{\\partial T}\\bigg|_{\\star} = \\frac{\\alpha_T}{\\Lambda} n^{\\star},$$\n$$\\frac{\\partial f_2}{\\partial n}\\bigg|_{\\star} = \\frac{\\beta}{\\Lambda}, \\quad \\frac{\\partial f_2}{\\partial C}\\bigg|_{\\star} = -\\lambda, \\quad \\frac{\\partial f_2}{\\partial T}\\bigg|_{\\star} = 0,$$\n$$\\frac{\\partial f_3}{\\partial n}\\bigg|_{\\star} = \\frac{\\kappa}{\\tau_T}, \\quad \\frac{\\partial f_3}{\\partial C}\\bigg|_{\\star} = 0, \\quad \\frac{\\partial f_3}{\\partial T}\\bigg|_{\\star} = -\\frac{1}{\\tau_T}.$$\nHence, the Jacobian matrix is:\n$$\nJ^{\\star} = \\begin{bmatrix}\n-\\beta/\\Lambda  \\lambda  (\\alpha_T/\\Lambda) n^{\\star} \\\\\n\\beta/\\Lambda  -\\lambda  0 \\\\\n\\kappa/\\tau_T  0  -1/\\tau_T\n\\end{bmatrix}.\n$$\nThe damping classification is determined by the eigenvalues $\\mu$ of $J^{\\star}$:\n- Under the definition used here, the system is underdamped if there exists a complex-conjugate pair with negative real parts (oscillatory decay).\n- It is overdamped if all eigenvalues are real and have negative real parts (non-oscillatory decay).\n- Positive real parts would imply instability, but the provided cases are chosen to be stable.\n\nAlgorithmic implementation:\n1. For each test case, compute $\\tau_T = C_p/h$ and $\\kappa = k_h/h$.\n2. Set $T_c = T_0 - \\kappa n_0$ and $C(0^{-}) = \\frac{\\beta}{\\lambda \\Lambda} n_0$.\n3. Integrate the ODEs from $t=0$ to $t_{\\text{end}}$ seconds using a stiff solver to produce a trajectory (expressed in seconds and Kelvin).\n4. Compute the equilibrium values $(n^{\\star}, C^{\\star}, T^{\\star})$ using the above relations.\n5. Form $J^{\\star}$ and compute its eigenvalues. If any eigenvalue has a nonzero imaginary part with negative real part, classify as underdamped ($1$); otherwise, classify as overdamped ($0$).\n6. Aggregate the classifications for all test cases and print them as a single line in the format $[x_1,x_2,x_3]$.\n\nThis procedure is principle-based: it begins from the established point-kinetics framework and energy balance, constructs the relevant steady state for the post-step condition, linearizes about that steady state, and uses the eigenvalues of the Jacobian to determine the qualitative damping behavior. The simulation ensures the transient is generated consistently with the governing physics, though the classification is decided by the linearized dynamics near equilibrium, which captures the local oscillatory or non-oscillatory nature of the decay.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef classify_case(params):\n    # Unpack parameters\n    beta = params[\"beta\"]\n    Lambda = params[\"Lambda\"]\n    lam = params[\"lambda\"]\n    rho_step = params[\"rho_step\"]\n    alpha_T = params[\"alpha_T\"]\n    C_p = params[\"C_p\"]\n    h = params[\"h\"]\n    k_h = params[\"k_h\"]\n    n0 = params[\"n0\"]\n    T0 = params[\"T0\"]\n\n    # Derived thermal parameters\n    tau_T = C_p / h\n    kappa = k_h / h\n\n    # Coolant reference temperature chosen to make pre-step state steady\n    T_c = T0 - kappa * n0\n\n    # Initial precursor concentration for a critical, steady pre-step state\n    C0 = (beta / (lam * Lambda)) * n0\n\n    # Define dynamics\n    def rhs(t, y):\n        n, C, T = y\n        rho = rho_step + alpha_T * (T - T0)\n        dn_dt = ((rho - beta) / Lambda) * n + lam * C\n        dC_dt = (beta / Lambda) * n - lam * C\n        dT_dt = (kappa * n - (T - T_c)) / tau_T\n        return [dn_dt, dC_dt, dT_dt]\n\n    # Simulate transient (not used for classification but required by problem statement)\n    y0 = np.array([n0, C0, T0], dtype=float)\n    t_end = 600.0\n    # Use a stiff solver due to potentially fast prompt dynamics\n    solve_ivp(rhs, (0.0, t_end), y0, method=\"BDF\", rtol=1e-8, atol=1e-10, t_eval=np.linspace(0.0, t_end, 2000))\n\n    # Post-step equilibrium computation\n    # From rho* = 0 and thermal balance T* = T_c + kappa n*\n    # Using T_c relation, solve for n*\n    n_star = n0 - rho_step / (alpha_T * kappa)\n    C_star = (beta / (lam * Lambda)) * n_star\n    T_star = T_c + kappa * n_star\n\n    # Jacobian at equilibrium\n    # df1/dn = (rho* - beta)/Lambda = -beta/Lambda (since rho* = 0)\n    j11 = -beta / Lambda\n    j12 = lam\n    j13 = (alpha_T / Lambda) * n_star\n\n    j21 = beta / Lambda\n    j22 = -lam\n    j23 = 0.0\n\n    j31 = kappa / tau_T\n    j32 = 0.0\n    j33 = -1.0 / tau_T\n\n    J = np.array([[j11, j12, j13],\n                  [j21, j22, j23],\n                  [j31, j32, j33]], dtype=float)\n\n    eigvals = np.linalg.eigvals(J)\n\n    # Classification: underdamped if any eigenvalue has significant imaginary part and negative real part\n    # overdamped if all eigenvalues are real and have negative real parts\n    imag_thresh = 1e-10\n    real_parts = np.real(eigvals)\n    imag_parts = np.imag(eigvals)\n\n    # Stability check (should be stable in provided cases)\n    if np.any(real_parts > 0.0):\n        # If unstable, we still provide a classification;\n        # treat as underdamped if oscillatory, otherwise overdamped (monotonic divergence).\n        if np.any(np.abs(imag_parts) > imag_thresh):\n            return 1\n        else:\n            return 0\n\n    # Oscillatory decay?\n    if np.any(np.abs(imag_parts) > imag_thresh):\n        return 1  # underdamped\n    else:\n        return 0  # overdamped\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: nominal, expected overdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.002,\n            \"alpha_T\": -5.0e-5,\n            \"C_p\": 1.0e6,\n            \"h\": 2.0e5,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n        # Case 2: weak feedback, slow thermal node, expected underdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.002,\n            \"alpha_T\": -1.0e-5,\n            \"C_p\": 5.0e6,\n            \"h\": 2.0e4,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n        # Case 3: larger step, strong feedback, expected overdamped\n        {\n            \"beta\": 0.0065,\n            \"Lambda\": 1.0e-4,\n            \"lambda\": 0.08,\n            \"rho_step\": 0.004,\n            \"alpha_T\": -1.0e-4,\n            \"C_p\": 1.0e6,\n            \"h\": 5.0e4,\n            \"k_h\": 6.0e6,\n            \"n0\": 1.0,\n            \"T0\": 600.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = classify_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}