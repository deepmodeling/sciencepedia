{
    "hands_on_practices": [
        {
            "introduction": "At its core, the fission source iteration method is a direct application of the power iteration algorithm from numerical linear algebra. This exercise abstracts away the complexities of neutron transport physics to focus on the iterative mechanics themselves. By repeatedly applying a generation-to-generation operator matrix $\\mathbf{H}$, you will see how the process naturally converges to the dominant eigenvalue $k$ and its corresponding eigenvector, which represents the fundamental fission source distribution. This practice  solidifies the concepts of normalization, convergence, and the importance of source positivity, a property guaranteed for physical systems by the Perron–Frobenius theorem.",
            "id": "4232373",
            "problem": "Consider the steady-state neutron balance problem in a homogeneous reactor that has been discretized into a finite-dimensional linear mapping from a non-negative fission source to its next-generation fission source. Starting from the linear Boltzmann transport equation in the multiplication formulation, the discretization yields a non-negative linear operator that maps a fission source to the next-generation fission source. Define the combined one-generation mapping as a square matrix $\\mathbf{H} \\in \\mathbb{R}^{n \\times n}$ with non-negative entries, representing the composition of neutron transport, scattering, and fission emission processes in a discrete multi-region, multi-energy state vector. The $k$-eigenvalue problem seeks the dominant eigenpair $(k, \\mathbf{s})$ with $k > 0$ and $\\mathbf{s} \\ge 0$ such that $\\mathbf{H} \\mathbf{s} = k \\mathbf{s}$, where $\\mathbf{s}$ is a non-negative fission source vector. The combined operator is assumed irreducible, ensuring the existence of a unique dominant eigenvalue and a strictly positive eigenvector by the Perron–Frobenius theorem.\n\nImplement a fission source iteration that, given $\\mathbf{H}$, an initial guess $\\mathbf{s}^{(0)}$, and a positivity enforcement policy $\\mathcal{P}$, updates the fission source and the estimated multiplication factor. The core iteration is as follows: apply the mapping to obtain a raw propagated vector, optionally enforce positivity with $\\mathcal{P}$, form an updated eigenvalue estimate based on an induced vector norm, and renormalize the fission source to a fixed norm to prevent numerical overflow or underflow. Continue until convergence in the eigenvalue estimate.\n\nYou must construct a complete program that:\n- Uses the given operator $\\mathbf{H}$ with $n = 4$ and entries\n  $\\mathbf{H} = \\begin{bmatrix}\n  0.35 & 0.20 & 0.30 & 0.10 \\\\\n  0.20 & 0.40 & 0.10 & 0.15 \\\\\n  0.25 & 0.15 & 0.45 & 0.20 \\\\\n  0.10 & 0.15 & 0.15 & 0.50\n  \\end{bmatrix}$.\n- Accepts, for each test case, an initial fission source vector $\\mathbf{s}^{(0)} \\in \\mathbb{R}^4$ and a positivity enforcement policy $\\mathcal{P}$ from the following set:\n  1. $\\mathcal{P} = \\text{none}$: no positivity enforcement; the raw propagated vector is used as-is.\n  2. $\\mathcal{P} = \\text{clip\\_zero}$: replace negative components by $0$.\n  3. $\\mathcal{P} = \\text{abs}$: replace the propagated vector by its component-wise absolute value.\n- Uses the $\\ell_1$-norm to estimate the eigenvalue at iteration $m$ by $k^{(m+1)} = \\|\\mathbf{y}^{(m)}\\|_1 / \\|\\mathbf{s}^{(m)}\\|_1$, where $\\mathbf{y}^{(m)}$ is the propagated vector before renormalization, and renormalizes $\\mathbf{s}^{(m+1)} = \\mathbf{y}^{(m)} / \\|\\mathbf{y}^{(m)}\\|_1$.\n- Detects whether any negative entries occur in the raw propagated vector $\\mathbf{y}^{(m)}$ at any iteration prior to applying $\\mathcal{P}$.\n- Stops when the relative change in $k$ satisfies $|k^{(m+1)} - k^{(m)}| / \\max(k^{(m)}, 1) < 10^{-10}$ or when a maximum number of iterations $5000$ is reached.\n- Uses a small strictly positive perturbation $\\varepsilon = 10^{-14}$ only when needed to avoid a zero vector during normalization.\n- Produces the results for each test case as a pair $[k, \\text{flag}]$, where $k$ is the converged multiplication factor rounded to $8$ decimal places, and $\\text{flag}$ is a boolean indicating whether any negative entries appeared in the raw propagated vector at any iteration (before positivity enforcement). The program must output the list of results for all test cases in a single line, as a comma-separated list enclosed in square brackets, with each pair enclosed in square brackets.\n\nYour program must implement the above iteration and run on the following test suite:\n- Test case $1$ (happy path): $\\mathbf{s}^{(0)} = [0.25, 0.25, 0.25, 0.25]$ and $\\mathcal{P} = \\text{none}$.\n- Test case $2$ (sign-deficient initial guess): $\\mathbf{s}^{(0)} = [1.0, -0.5, 0.3, -0.8]$ and $\\mathcal{P} = \\text{none}$.\n- Test case $3$ (positivity enforcement by clipping): $\\mathbf{s}^{(0)} = [1.0, -0.5, 0.3, -0.8]$ and $\\mathcal{P} = \\text{clip\\_zero}$.\n- Test case $4$ (boundary case with zero initial vector): $\\mathbf{s}^{(0)} = [0.0, 0.0, 0.0, 0.0]$ and $\\mathcal{P} = \\text{clip\\_zero}$.\n\nThere are no physical units involved in this computation. Angles are not used. Percentages are not used. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a pair $[k,\\text{flag}]$ obtained as specified (e.g., $[[1.01234567,True],[\\dots]]$).",
            "solution": "The problem presented is valid. It is a well-posed numerical problem grounded in the established principles of nuclear reactor physics and numerical linear algebra. It is self-contained, objective, and provides all necessary data and constraints for a unique solution to be algorithmically determined.\n\nThe problem asks for the implementation of the fission source iteration method, which is mathematically equivalent to the power iteration algorithm, to find the dominant eigenvalue of a given matrix $\\mathbf{H}$. This dominant eigenvalue is denoted by $k$ and represents the effective neutron multiplication factor in a simplified, discretized model of a nuclear reactor.\n\nThe governing equation is the steady-state $k$-eigenvalue problem:\n$$\n\\mathbf{H} \\mathbf{s} = k \\mathbf{s}\n$$\nHere, $\\mathbf{s}$ is the eigenvector representing the spatial and energetic distribution of the fission source, and $k$ is the corresponding eigenvalue. In reactor physics, a critical system is characterized by $k=1$. The matrix $\\mathbf{H} \\in \\mathbb{R}^{n \\times n}$ is a linear operator that maps a fission source distribution from one generation to the next. It is given as:\n$$\n\\mathbf{H} = \\begin{bmatrix}\n0.35 & 0.20 & 0.30 & 0.10 \\\\\n0.20 & 0.40 & 0.10 & 0.15 \\\\\n0.25 & 0.15 & 0.45 & 0.20 \\\\\n0.10 & 0.15 & 0.15 & 0.50\n\\end{bmatrix}\n$$\nThe problem states that $\\mathbf{H}$ is non-negative and irreducible. Indeed, all entries of the given $\\mathbf{H}$ are strictly positive, $H_{ij} > 0$, which is a stronger condition known as primitivity. The Perron-Frobenius theorem for primitive matrices guarantees that there exists a unique eigenvalue $k$ that is real, positive, and strictly greater in magnitude than all other eigenvalues. This is the dominant eigenvalue, or $k$-eigenvalue. The corresponding eigenvector $\\mathbf{s}$ can be chosen to have all strictly positive components, $\\mathbf{s} > 0$.\n\nThe fission source iteration algorithm is a numerical method to find this dominant eigenpair $(k, \\mathbf{s})$. It is an iterative process defined as follows, starting from an initial guess $\\mathbf{s}^{(0)}$ and an initial eigenvalue estimate $k^{(0)}$. For iteration $m = 0, 1, 2, \\dots$:\n\n1.  **Source Propagation**: A raw next-generation source vector, which I will denote $\\mathbf{y'}^{(m)}$, is computed by applying the operator $\\mathbf{H}$ to the current source vector $\\mathbf{s}^{(m)}$:\n    $$\n    \\mathbf{y'}^{(m)} = \\mathbf{H} \\mathbf{s}^{(m)}\n    $$\n\n2.  **Positivity Enforcement**: An optional positivity policy $\\mathcal{P}$ is applied to the raw vector $\\mathbf{y'}^{(m)}$ to produce the processed vector $\\mathbf{y}^{(m)}$. The policies are:\n    -   $\\mathcal{P} = \\text{none}$: $\\mathbf{y}^{(m)} = \\mathbf{y'}^{(m)}$.\n    -   $\\mathcal{P} = \\text{clip\\_zero}$: $y_i^{(m)} = \\max(0, y'_i^{(m)})$.\n    -   $\\mathcal{P} = \\text{abs}$: $y_i^{(m)} = |y'_i^{(m)}|$.\n\n3.  **Eigenvalue Estimation**: The eigenvalue for the next step, $k^{(m+1)}$, is estimated using the ratio of the $\\ell_1$-norms of the resulting source $\\mathbf{y}^{(m)}$ and the previous source $\\mathbf{s}^{(m)}$:\n    $$\n    k^{(m+1)} = \\frac{\\|\\mathbf{y}^{(m)}\\|_1}{\\|\\mathbf{s}^{(m)}\\|_1}\n    $$\n    where $\\|\\mathbf{v}\\|_1 = \\sum_i |v_i|$. Special handling is required if $\\|\\mathbf{s}^{(m)}\\|_1 = 0$, in which case a default value of $k^{(m+1)}=1.0$ is a reasonable choice, as this only occurs for a zero initial vector.\n\n4.  **Source Renormalization**: The source vector is renormalized to have a unit $\\ell_1$-norm for the subsequent iteration. This step is crucial for numerical stability.\n    $$\n    \\mathbf{s}^{(m+1)} = \\frac{\\mathbf{y}^{(m)}}{\\|\\mathbf{y}^{(m)}\\|_1}\n    $$\n    If $\\mathbf{y}^{(m)}$ is a zero vector, its norm is $0$, leading to a division-by-zero error. In this specific scenario, as per the problem, the vector $\\mathbf{y}^{(m)}$ must be replaced by a small perturbation vector before normalization. A vector with all components equal to $\\varepsilon = 10^{-14}$ is used.\n\nThe iteration proceeds until the relative change in the eigenvalue estimate falls below a specified tolerance of $10^{-10}$, i.e., $|k^{(m+1)} - k^{(m)}| / \\max(k^{(m)}, 1) < 10^{-10}$, or until a maximum of $5000$ iterations is reached.\n\nThroughout the process, a boolean flag must track whether any raw propagated vector $\\mathbf{y'}^{(m)}$ contains negative entries at any point. This is important because while the physical fission source must be non-negative, intermediate numerical estimates, particularly with a mixed-sign initial guess $\\mathbf{s}^{(0)}$, may contain negative values.\n\nThe implementation will follow this algorithm for each of the four specified test cases, combining the matrix operations with the logic for positivity policies, convergence checks, and edge-case handling for zero vectors. The final converged eigenvalue $k$ is to be rounded to $8$ decimal places.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the fission source iteration to find the k-eigenvalue\n    for a given matrix H and a set of test cases.\n    \"\"\"\n    H = np.array([\n        [0.35, 0.20, 0.30, 0.10],\n        [0.20, 0.40, 0.10, 0.15],\n        [0.25, 0.15, 0.45, 0.20],\n        [0.10, 0.15, 0.15, 0.50]\n    ], dtype=float)\n\n    test_cases = [\n        ([0.25, 0.25, 0.25, 0.25], 'none'),\n        ([1.0, -0.5, 0.3, -0.8], 'none'),\n        ([1.0, -0.5, 0.3, -0.8], 'clip_zero'),\n        ([0.0, 0.0, 0.0, 0.0], 'clip_zero'),\n    ]\n\n    results = []\n    max_iter = 5000\n    tol = 1.0e-10\n    eps = 1.0e-14\n\n    for s0_list, policy in test_cases:\n        s = np.array(s0_list, dtype=float)\n        k_old = 1.0\n        neg_flag = False\n        k_new = 0.0\n\n        for m in range(max_iter):\n            s_norm = np.linalg.norm(s, 1)\n\n            # Step 1: Source Propagation\n            y_raw = H @ s\n\n            # Step 2: Negative Entry Detection\n            if np.any(y_raw < 0):\n                neg_flag = True\n\n            # Step 3: Positivity Enforcement\n            if policy == 'clip_zero':\n                y = np.maximum(0, y_raw)\n            elif policy == 'abs':\n                y = np.abs(y_raw)\n            else:  # 'none'\n                y = y_raw\n\n            y_norm = np.linalg.norm(y, 1)\n\n            # Step 4: Eigenvalue Estimation\n            if s_norm > 0:\n                k_new = y_norm / s_norm\n            else:\n                # This case only happens for a zero initial vector s0.\n                # k is undefined, so we use a default value for the first step.\n                k_new = 1.0\n\n            # Step 5: Convergence Check\n            # We start checking from the second iteration (m > 0).\n            if m > 0:\n                if abs(k_new - k_old) / max(k_old, 1.0) < tol:\n                    break\n            \n            # Step 6: Source Renormalization (prepare for next iteration)\n            if y_norm == 0:\n                # Avoid division by zero by using a perturbation vector.\n                y = np.full(s.shape, eps, dtype=float)\n                y_norm = np.linalg.norm(y, 1)\n            \n            s = y / y_norm\n            k_old = k_new\n        \n        # If loop finished due to max_iter, k_new holds the last value.\n        final_k = k_new\n        results.append(f\"[{round(final_k, 8)},{neg_flag}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a solid grasp of the core iterative algorithm, we can now apply it to a tangible physical model. This practice guides you through building a simple one-dimensional reactor simulator from first principles. Starting from the neutron diffusion equation, you will use the finite difference method to construct the discrete system operators and then implement the fission source iteration algorithm to find the effective multiplication factor, $k_{\\text{eff}}$. This hands-on exercise  bridges the gap between abstract matrix operations and applied reactor physics, and it introduces the indispensable engineering practice of verification by comparing the numerical result against a known analytical benchmark.",
            "id": "4232377",
            "problem": "You are tasked with constructing a complete and runnable program that estimates the effective multiplication factor using the k-eigenvalue formulation via fission source iteration and validates the numerical result against an analytical benchmark. The focus is a one-speed, one-dimensional homogeneous slab of length $L$ with vacuum boundary conditions at both ends. Your program must assemble the discrete operators from first principles, iterate to convergence of the fundamental k-eigenvalue, and report validation metrics across a small test suite.\n\nBegin from the steady-state neutron balance in diffusion theory and its constitutive relations: the particle balance equates leakage and absorption to induced fission production scaled by the effective multiplication factor, and the neutron current is proportional to the gradient of scalar flux. In a homogeneous medium with diffusion coefficient $D$, macroscopic absorption cross section $\\Sigma_a$ in units of $\\mathrm{cm}^{-1}$, and macroscopic production cross section $\\nu\\Sigma_f$ in units of $\\mathrm{cm}^{-1}$, the governing one-speed equation in slab geometry is\n$$\n-\\frac{d}{dx}\\left(D\\frac{d\\phi(x)}{dx}\\right)+\\Sigma_a\\,\\phi(x)=\\frac{1}{k}\\,\\nu\\Sigma_f\\,\\phi(x),\n$$\nfor $x\\in(0,L)$, with vacuum boundary conditions $\\,\\phi(0)=0\\,$ and $\\,\\phi(L)=0\\,$. Here, $\\,\\phi(x)\\,$ is the neutron scalar flux in units of $\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$ and $\\,k\\,$ is dimensionless.\n\nDiscretize the spatial domain using a uniform grid with $N$ interior unknowns, grid spacing $h=L/(N+1)$, and second-order central differences for the second derivative. Construct the discrete loss operator $L$ and the discrete fission operator $F$ for the homogeneous medium. Treat the vacuum boundaries as Dirichlet conditions at $x=0$ and $x=L$ embedded in the stencil. Implement the classical fission source iteration to approximate the largest eigenvalue of the operator $L^{-1}F$ and its associated eigenfunction. The iteration conceptually proceeds by alternating two steps: solving the linear system with a normalized fission source to obtain a new flux, and then updating the global multiplication factor and renormalizing the fission source accordingly. Use the integral over the domain of the fission production rate to define the normalization and update the multiplication factor. Use a uniform quadrature consistent with the grid spacing $h$ for estimating integrals.\n\nFor validation, the analytical model for a homogeneous slab with vacuum boundaries has separable eigenfunctions and yields a closed-form benchmark for the fundamental mode (the smallest buckling). The analytical effective multiplication factor for the fundamental mode ($n=1$) is\n$$\nk_{\\text{anal}}=\\frac{\\nu\\Sigma_f}{\\Sigma_a+D\\left(\\frac{\\pi}{L}\\right)^2},\n$$\nwhich you must use to compute the relative validation error of your numerical estimate $k_{\\text{num}}$ as\n$$\n\\varepsilon=\\frac{\\left|k_{\\text{num}}-k_{\\text{anal}}\\right|}{k_{\\text{anal}}}.\n$$\n\nImplement your program to run the following test suite of parameter sets. All cross sections are in $\\mathrm{cm}^{-1}$, diffusion coefficients in $\\mathrm{cm}$, lengths in $\\mathrm{cm}$. The effective multiplication factor $k$ is dimensionless. Use the vacuum boundary conditions as stated and express all relative errors as dimensionless floats.\n\n- Test Case 1 (general supercritical case, fine grid):\n  - $D=1.0\\,\\mathrm{cm}$, $\\Sigma_a=0.1\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_f=0.25\\,\\mathrm{cm}^{-1}$, $L=100.0\\,\\mathrm{cm}$, $N=200$.\n- Test Case 2 (exactly critical by construction, moderate grid):\n  - $D=1.0\\,\\mathrm{cm}$, $\\Sigma_a=0.1\\,\\mathrm{cm}^{-1}$, $L=50.0\\,\\mathrm{cm}$, $\\nu\\Sigma_f=\\Sigma_a+D\\left(\\frac{\\pi}{L}\\right)^2$ (compute this exactly in floating-point in your code), $N=100$.\n- Test Case 3 (strongly subcritical, coarse grid):\n  - $D=1.2\\,\\mathrm{cm}$, $\\Sigma_a=0.2\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_f=0.05\\,\\mathrm{cm}^{-1}$, $L=100.0\\,\\mathrm{cm}$, $N=30$.\n\nAlgorithmic requirements:\n- Initialize the scalar flux $\\,\\phi\\,$ to a positive field and define an initial fission source that is normalized so that its integral over the domain equals $1$.\n- Iteratively solve the linear system associated with the loss operator and the current normalized fission source to obtain the next flux field.\n- Update the effective multiplication factor using the integral of the induced fission production computed from the updated flux.\n- Renormalize the fission source so that its integral equals $1$ and repeat until the change in the multiplication factor between successive iterations is less than a specified tolerance or until a specified maximum iteration count is reached. Use a convergence tolerance of $10^{-12}$ on $|k_{\\text{new}}-k_{\\text{old}}|$ and a maximum of $10000$ iterations for all test cases.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output the relative error $\\,\\varepsilon\\,$ rounded to eight decimal places. The final line must therefore be of the form\n$$\n[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3],\n$$\nwith each $\\,\\varepsilon_i\\,$ a dimensionless float rounded to eight decimal places. No additional text or whitespace beyond the comma separators and enclosing brackets is permitted in the final output line.",
            "solution": "The user requires the construction of a numerical program to solve the one-speed, one-dimensional neutron diffusion equation for its fundamental k-eigenvalue and to validate the result against an analytical benchmark. The solution is derived from first principles, beginning with the governing differential equation and proceeding to its discrete matrix form, followed by an explanation of the iterative solution algorithm.\n\nThe governing steady-state, one-speed neutron diffusion equation for a homogeneous slab of length $L$ is given by:\n$$\n-D\\frac{d^2\\phi(x)}{dx^2}+\\Sigma_a\\,\\phi(x)=\\frac{1}{k}\\,\\nu\\Sigma_f\\,\\phi(x), \\quad x \\in (0, L)\n$$\nwhere $D$ is the diffusion coefficient, $\\Sigma_a$ is the macroscopic absorption cross section, $\\nu\\Sigma_f$ is the macroscopic fission production cross section, $\\phi(x)$ is the neutron scalar flux, and $k$ is the effective neutron multiplication factor. The vacuum boundary conditions are $\\phi(0) = 0$ and $\\phi(L) = 0$.\n\nThis equation can be expressed in operator form as $\\mathcal{L}\\phi(x) = \\frac{1}{k}\\mathcal{F}\\phi(x)$, where $\\mathcal{L} = -D\\frac{d^2}{dx^2} + \\Sigma_a$ is the loss operator (leakage plus absorption) and $\\mathcal{F} = \\nu\\Sigma_f$ is the fission production operator.\n\nTo solve this equation numerically, the spatial domain $(0, L)$ is discretized into a uniform grid with $N$ interior points $x_i = i \\cdot h$ for $i = 1, 2, \\dots, N$. The grid spacing is $h = L/(N+1)$. The boundary points are at $x_0=0$ and $x_{N+1}=L$, where the flux is known to be zero. The flux at the interior points is denoted by $\\phi_i = \\phi(x_i)$.\n\nThe second derivative term is approximated using a second-order central difference stencil:\n$$\n\\frac{d^2\\phi}{dx^2}\\bigg|_{x_i} \\approx \\frac{\\phi(x_i-h) - 2\\phi(x_i) + \\phi(x_i+h)}{h^2} = \\frac{\\phi_{i-1} - 2\\phi_i + \\phi_{i+1}}{h^2}\n$$\n\nSubstituting this approximation into the governing equation for each interior grid point $i$ yields a system of $N$ linear algebraic equations:\n$$\n-D\\left(\\frac{\\phi_{i-1} - 2\\phi_i + \\phi_{i+1}}{h^2}\\right) + \\Sigma_a \\phi_i = \\frac{1}{k} \\nu\\Sigma_f \\phi_i\n$$\nThis can be rearranged as:\n$$\n-\\frac{D}{h^2}\\phi_{i-1} + \\left(\\frac{2D}{h^2} + \\Sigma_a\\right)\\phi_i - \\frac{D}{h^2}\\phi_{i+1} = \\frac{1}{k} \\nu\\Sigma_f \\phi_i\n$$\nThe boundary conditions $\\phi_0=0$ and $\\phi_{N+1}=0$ are incorporated into the equations for $i=1$ and $i=N$, respectively.\n\nThis system of equations can be written in matrix form as:\n$$\n\\mathbf{L}\\vec{\\phi} = \\frac{1}{k}\\mathbf{F}\\vec{\\phi}\n$$\nwhere $\\vec{\\phi} = [\\phi_1, \\phi_2, \\dots, \\phi_N]^T$ is the vector of unknown flux values. The matrix $\\mathbf{L}$ is the discrete loss operator, an $N \\times N$ real, symmetric, tridiagonal matrix with elements:\n$$\nL_{ij} =\n\\begin{cases}\n\\frac{2D}{h^2} + \\Sigma_a, & \\text{if } i=j \\\\\n-\\frac{D}{h^2}, & \\text{if } |i-j|=1 \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThe matrix $\\mathbf{F}$ is the discrete fission operator, an $N \\times N$ diagonal matrix with elements $F_{ij} = \\nu\\Sigma_f \\delta_{ij}$.\n\nThe problem is now a generalized eigenvalue problem. The largest eigenvalue, $k$, corresponds to the fundamental mode, which is physically the most persistent flux shape. We solve this using the fission source iteration method, which is a particular implementation of the power iteration algorithm.\n\nThe iterative procedure is as follows:\nLet the iteration index be $m$. We define a fission source vector $\\vec{S} = \\nu\\Sigma_f \\vec{\\phi}$.\nThe algorithm iterates between determining the flux distribution that results from a given source distribution and then updating the source distribution and total source strength (related to $k$).\n\n1.  **Initialization ($m=0$):**\n    - Make an initial guess for the flux eigenvector, $\\vec{\\phi}^{(0)}$. A spatially uniform positive vector (e.g., a vector of all ones) is a suitable choice, as it is guaranteed to have a non-zero projection onto the fundamental mode.\n    - Compute the initial fission source: $\\vec{S}^{(0)} = \\nu\\Sigma_f \\vec{\\phi}^{(0)}$.\n    - Compute the initial estimate of the eigenvalue, $k^{(0)}$, by integrating the fission source over the domain. Using a simple rectangular quadrature, this is $k^{(0)} = h \\sum_{i=1}^N S_i^{(0)}$.\n    - Define a normalized fission source distribution for the first iteration: $\\vec{\\psi}^{(0)} = \\vec{S}^{(0)} / k^{(0)}$. By construction, $h \\sum_{i=1}^N \\psi_i^{(0)} = 1$.\n\n2.  **Iteration ($m = 0, 1, 2, \\dots$):**\n    a. **Solve for Flux:** Solve the linear system for the next flux vector $\\vec{\\phi}^{(m+1)}$ using the normalized source from the previous iteration:\n       $$\n       \\mathbf{L}\\vec{\\phi}^{(m+1)} = \\vec{\\psi}^{(m)}\n       $$\n       This corresponds to finding the steady-state flux distribution resulting from one source neutron distributed according to $\\vec{\\psi}^{(m)}$.\n    b. **Update Source and Eigenvalue:**\n       - Compute the new, unnormalized fission source resulting from the updated flux: $\\vec{S}^{(m+1)} = \\nu\\Sigma_f \\vec{\\phi}^{(m+1)}$.\n       - Compute the new eigenvalue estimate $k^{(m+1)}$ by integrating this new source. This value represents the total number of fission neutrons produced in generation $m+1$ per source neutron in generation $m$.\n         $$\n         k^{(m+1)} = h \\sum_{i=1}^N S_i^{(m+1)}\n         $$\n    c. **Check for Convergence:** Compare the new eigenvalue estimate with the previous one. If $|k^{(m+1)} - k^{(m)}| < \\epsilon_{\\text{tol}}$, where $\\epsilon_{\\text{tol}}$ is a small tolerance, the iteration has converged.\n    d. **Normalize Source:** Prepare the normalized source for the next iteration: $\\vec{\\psi}^{(m+1)} = \\vec{S}^{(m+1)} / k^{(m+1)}$.\n    e. Continue to the next iteration if not converged.\n\nUpon convergence, the final value $k^{(m+1)}$ is our numerical estimate, $k_{\\text{num}}$. This is compared against the analytical solution for validation. For a bare homogeneous slab of width $L$, the analytical eigenvalue for the fundamental mode ($n=1$) is:\n$$\nk_{\\text{anal}}=\\frac{\\nu\\Sigma_f}{\\Sigma_a+D B_g^2} = \\frac{\\nu\\Sigma_f}{\\Sigma_a+D\\left(\\frac{\\pi}{L}\\right)^2}\n$$\nThe relative error is calculated as $\\varepsilon = |k_{\\text{num}} - k_{\\text{anal}}|/k_{\\text{anal}}$. The implementation will follow this procedure for the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the 1D neutron diffusion k-eigenvalue problem using fission source iteration\n    and validates the results against an analytical benchmark for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'D': 1.0,           # cm\n            'Sigma_a': 0.1,     # cm^-1\n            'nu_Sigma_f': 0.25, # cm^-1\n            'L': 100.0,         # cm\n            'N': 200,           # number of interior points\n            'label': 'supercritical'\n        },\n        {\n            'D': 1.0,\n            'Sigma_a': 0.1,\n            'nu_Sigma_f': None, # To be computed\n            'L': 50.0,\n            'N': 100,\n            'label': 'critical'\n        },\n        {\n            'D': 1.2,\n            'Sigma_a': 0.2,\n            'nu_Sigma_f': 0.05,\n            'L': 100.0,\n            'N': 30,\n            'label': 'subcritical'\n        }\n    ]\n\n    # Algorithmic parameters\n    CONVERGENCE_TOLERANCE = 1e-12\n    MAX_ITERATIONS = 10000\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters\n        D = case['D']\n        Sigma_a = case['Sigma_a']\n        nu_Sigma_f = case['nu_Sigma_f']\n        L = case['L']\n        N = case['N']\n\n        # Special handling for Test Case 2\n        if case['label'] == 'critical':\n            # This makes k_analytical exactly 1.0\n            nu_Sigma_f = Sigma_a + D * (np.pi / L)**2\n\n        # 1. Discretization and Matrix Assembly\n        h = L / (N + 1)\n\n        # Construct the discrete loss operator L\n        # Diagonal elements: 2D/h^2 + Sigma_a\n        diag = (2.0 * D / h**2 + Sigma_a) * np.ones(N)\n        # Off-diagonal elements: -D/h^2\n        off_diag = (-D / h**2) * np.ones(N - 1)\n        \n        L_matrix = np.diag(diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n        \n        # Pre-compute the inverse of L_matrix for efficiency in the loop\n        L_inv = np.linalg.inv(L_matrix)\n\n        # 2. Fission Source Iteration\n        \n        # Initialization\n        phi = np.ones(N)                                    # Initial flux guess\n        source = nu_Sigma_f * phi                           # Initial fission source\n        k_old = h * np.sum(source)                          # Initial k estimate\n        normalized_source = source / k_old                  # Normalized source distribution\n        \n        k_num = 0.0\n        for i in range(MAX_ITERATIONS):\n            # a. Solve for flux: L * phi_new = normalized_source\n            phi = L_inv @ normalized_source\n\n            # b. Update source and eigenvalue\n            source = nu_Sigma_f * phi\n            k_new = h * np.sum(source)\n\n            # c. Check for convergence\n            if np.abs(k_new - k_old) < CONVERGENCE_TOLERANCE:\n                k_num = k_new\n                break\n\n            # d. Normalize source for next iteration\n            normalized_source = source / k_new\n            k_old = k_new\n        else: # This else belongs to the for loop, executes if loop finishes without break\n            k_num = k_old\n\n        # 3. Validation\n        \n        # Analytical solution\n        buckling_sq = (np.pi / L)**2\n        k_anal = nu_Sigma_f / (Sigma_a + D * buckling_sq)\n\n        # Relative error\n        if k_anal == 0:\n            error = np.inf if k_num != 0 else 0.0\n        else:\n            error = np.abs(k_num - k_anal) / k_anal\n        \n        results.append(\"{:.8f}\".format(error))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Calculating the reactor's criticality state is fundamental, but understanding its sensitivity to changes in the system is equally crucial for design and safety analysis. This exercise introduces first-order perturbation theory, a powerful analytical tool for quantifying how the $k$-eigenvalue responds to small changes in material properties. You will derive and apply a formula that uses both the forward flux (which represents neutron density) and the adjoint flux (which represents neutron importance) to determine this sensitivity. This advanced practice  reveals that the impact of a perturbation depends not just on its magnitude, but critically on the flux and importance at its location, providing deep physical insight without the cost of a full re-simulation.",
            "id": "4232367",
            "problem": "Consider a generalized algebraic representation of the one-speed neutron transport $k$-eigenvalue problem obtained by a coarse-mesh spatial and energy projection of the Boltzmann equation. In Fission Source Iteration, the fixed-point form of the fundamental mode is equivalent to the generalized eigenproblem\n$$\n\\mathbf{F}\\,\\boldsymbol{\\phi} \\;=\\; k\\,\\mathbf{L}\\,\\boldsymbol{\\phi},\n$$\nwhere $\\mathbf{L}$ is the loss operator (streaming, absorption, and out-scattering), $\\mathbf{F}$ is the fission production operator, $\\boldsymbol{\\phi}$ is the forward flux/source state vector, and $k$ is the effective multiplication factor. The adjoint system is defined by\n$$\n\\mathbf{F}^{\\dagger}\\,\\boldsymbol{\\phi}^{\\dagger} \\;=\\; k\\,\\mathbf{L}^{\\dagger}\\,\\boldsymbol{\\phi}^{\\dagger},\n$$\nfor the adjoint flux/source state vector $\\boldsymbol{\\phi}^{\\dagger}$ and the adjoint operators $\\mathbf{L}^{\\dagger}$ and $\\mathbf{F}^{\\dagger}$.\n\nSuppose a two-region coarse-mesh model has\n$$\n\\mathbf{L} \\;=\\; \\begin{pmatrix}\n0.8 & -0.1 \\\\\n-0.05 & 0.6\n\\end{pmatrix},\n\\qquad\n\\mathbf{F} \\;=\\; \\begin{pmatrix}\n0.7 & 0 \\\\\n0 & 0.1\n\\end{pmatrix},\n$$\nwith all quantities expressed in consistent units such that $k$ is dimensionless. Consider a small perturbation $p$ to the first-region absorption that modifies only the $(1,1)$ entry of $\\mathbf{L}$:\n$$\n\\mathbf{L}(p) \\;=\\; \\begin{pmatrix}\n0.8 + p & -0.1 \\\\\n-0.05 & 0.6\n\\end{pmatrix},\n\\qquad\n\\mathbf{F}(p) \\;=\\; \\mathbf{F}.\n$$\n\nStarting from the fundamental definitions of the forward and adjoint generalized eigenproblems and the inner-product weighting appropriate to neutron importance (i.e., adjoint-weighted bilinear forms), derive the first-order perturbation expression for the derivative $\\frac{dk}{dp}$ at $p=0$. Then evaluate it numerically for the given $\\mathbf{L}$ and $\\mathbf{F}$ by computing the fundamental mode and its adjoint and performing the required bilinear forms. Round your final numerical answer to four significant figures. Express the final answer as a pure number (dimensionless).",
            "solution": "The problem requires the derivation and evaluation of the first-order perturbation expression for the eigenvalue $k$ of a generalized eigenproblem.\n\nFirst, we derive the general formula for the derivative $\\frac{dk}{dp}$. The perturbed forward eigenproblem is given by\n$$\n\\mathbf{F}(p)\\,\\boldsymbol{\\phi}(p) \\;=\\; k(p)\\,\\mathbf{L}(p)\\,\\boldsymbol{\\phi}(p)\n$$\nWe expand all perturbed quantities as a first-order Taylor series in the perturbation parameter $p$ around $p=0$:\n$$\n\\begin{aligned}\n\\mathbf{L}(p) &\\;=\\; \\mathbf{L}_0 + p\\,\\mathbf{L}_1 + \\mathcal{O}(p^2) \\\\\n\\mathbf{F}(p) &\\;=\\; \\mathbf{F}_0 + p\\,\\mathbf{F}_1 + \\mathcal{O}(p^2) \\\\\n\\boldsymbol{\\phi}(p) &\\;=\\; \\boldsymbol{\\phi}_0 + p\\,\\boldsymbol{\\phi}_1 + \\mathcal{O}(p^2) \\\\\nk(p) &\\;=\\; k_0 + p\\,k_1 + \\mathcal{O}(p^2)\n\\end{aligned}\n$$\nwhere $\\mathbf{L}_0 = \\mathbf{L}(0)$, $\\mathbf{F}_0 = \\mathbf{F}(0)$, $\\boldsymbol{\\phi}_0 = \\boldsymbol{\\phi}(0)$, and $k_0 = k(0)$ are the unperturbed quantities. The first-order coefficients are the derivatives evaluated at $p=0$, e.g., $k_1 = \\left.\\frac{dk}{dp}\\right|_{p=0}$.\n\nSubstituting these expansions into the eigenproblem and collecting terms of the same order in $p$:\nOrder $p^0$:\n$$\n\\mathbf{F}_0\\,\\boldsymbol{\\phi}_0 \\;=\\; k_0\\,\\mathbf{L}_0\\,\\boldsymbol{\\phi}_0\n$$\nThis is the unperturbed forward eigenproblem.\n\nOrder $p^1$:\n$$\n\\mathbf{F}_0\\,\\boldsymbol{\\phi}_1 + \\mathbf{F}_1\\,\\boldsymbol{\\phi}_0 \\;=\\; k_0\\,\\mathbf{L}_0\\,\\boldsymbol{\\phi}_1 + k_0\\,\\mathbf{L}_1\\,\\boldsymbol{\\phi}_0 + k_1\\,\\mathbf{L}_0\\,\\boldsymbol{\\phi}_0\n$$\nTo isolate $k_1$, we take the inner product of this equation with the unperturbed adjoint eigenvector $\\boldsymbol{\\phi}_0^{\\dagger}$. The inner product is defined as the adjoint-weighted bilinear form $\\langle \\mathbf{u}, \\mathbf{v} \\rangle = \\mathbf{u}^{\\dagger T} \\mathbf{v}$.\n$$\n\\boldsymbol{\\phi}_0^{\\dagger T} (\\mathbf{F}_0\\,\\boldsymbol{\\phi}_1) + \\boldsymbol{\\phi}_0^{\\dagger T} (\\mathbf{F}_1\\,\\boldsymbol{\\phi}_0) \\;=\\; k_0\\,\\boldsymbol{\\phi}_0^{\\dagger T}(\\mathbf{L}_0\\,\\boldsymbol{\\phi}_1) + k_0\\,\\boldsymbol{\\phi}_0^{\\dagger T}(\\mathbf{L}_1\\,\\boldsymbol{\\phi}_0) + k_1\\,\\boldsymbol{\\phi}_0^{\\dagger T}(\\mathbf{L}_0\\,\\boldsymbol{\\phi}_0)\n$$\nUsing the property of the adjoint operator, $\\mathbf{u}^{\\dagger T}(\\mathbf{A}\\mathbf{v}) = (\\mathbf{A}^{\\dagger}\\mathbf{u})^{\\dagger T}\\mathbf{v}$, we can rewrite the first term on each side:\n$$\n(\\mathbf{F}_0^{\\dagger}\\boldsymbol{\\phi}_0^{\\dagger})^{\\dagger T}\\,\\boldsymbol{\\phi}_1 + \\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{F}_1\\,\\boldsymbol{\\phi}_0 \\rangle \\;=\\; k_0\\,(\\mathbf{L}_0^{\\dagger}\\boldsymbol{\\phi}_0^{\\dagger})^{\\dagger T}\\,\\boldsymbol{\\phi}_1 + k_0\\,\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_1\\,\\boldsymbol{\\phi}_0 \\rangle + k_1\\,\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0\\,\\boldsymbol{\\phi}_0 \\rangle\n$$\nThe unperturbed adjoint eigenproblem is $\\mathbf{F}_0^{\\dagger}\\,\\boldsymbol{\\phi}_0^{\\dagger} = k_0\\,\\mathbf{L}_0^{\\dagger}\\,\\boldsymbol{\\phi}_0^{\\dagger}$. Substituting this into the left-hand side:\n$$\n(k_0\\,\\mathbf{L}_0^{\\dagger}\\,\\boldsymbol{\\phi}_0^{\\dagger})^{\\dagger T}\\,\\boldsymbol{\\phi}_1 + \\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{F}_1\\,\\boldsymbol{\\phi}_0 \\rangle \\;=\\; k_0\\,(\\mathbf{L}_0^{\\dagger}\\boldsymbol{\\phi}_0^{\\dagger})^{\\dagger T}\\,\\boldsymbol{\\phi}_1 + k_0\\,\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_1\\,\\boldsymbol{\\phi}_0 \\rangle + k_1\\,\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0\\,\\boldsymbol{\\phi}_0 \\rangle\n$$\nThe first term on the left cancels with the first term on the right. We are left with:\n$$\n\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{F}_1\\,\\boldsymbol{\\phi}_0 \\rangle \\;=\\; k_0\\,\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_1\\,\\boldsymbol{\\phi}_0 \\rangle + k_1\\,\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0\\,\\boldsymbol{\\phi}_0 \\rangle\n$$\nSolving for $k_1 = \\frac{dk}{dp}|_{p=0}$ yields the desired expression:\n$$\n\\frac{dk}{dp}\\bigg|_{p=0} \\;=\\; \\frac{\\langle \\boldsymbol{\\phi}_0^{\\dagger}, (\\mathbf{F}_1 - k_0\\,\\mathbf{L}_1)\\,\\boldsymbol{\\phi}_0 \\rangle}{\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0\\,\\boldsymbol{\\phi}_0 \\rangle}\n$$\nNow we apply this formula to the given problem. The unperturbed operators are:\n$$\n\\mathbf{L}_0 = \\mathbf{L} = \\begin{pmatrix} 0.8 & -0.1 \\\\ -0.05 & 0.6 \\end{pmatrix}, \\qquad \\mathbf{F}_0 = \\mathbf{F} = \\begin{pmatrix} 0.7 & 0 \\\\ 0 & 0.1 \\end{pmatrix}\n$$\nThe perturbation is applied only to $\\mathbf{L}$, so $\\mathbf{F}(p) = \\mathbf{F}$ is constant, which means $\\mathbf{F}_1 = \\frac{d\\mathbf{F}}{dp} = \\mathbf{0}$. The perturbation to $\\mathbf{L}$ is $\\mathbf{L}(p) = \\mathbf{L}_0 + p\\,\\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}$, so $\\mathbf{L}_1 = \\frac{d\\mathbf{L}}{dp} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix}$.\nThe formula for this specific case simplifies to:\n$$\n\\frac{dk}{dp}\\bigg|_{p=0} \\;=\\; \\frac{-k_0\\,\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_1\\,\\boldsymbol{\\phi}_0 \\rangle}{\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0\\,\\boldsymbol{\\phi}_0 \\rangle}\n$$\nWe need to find the unperturbed fundamental eigenvalue $k_0$ and the corresponding forward eigenvector $\\boldsymbol{\\phi}_0$ and adjoint eigenvector $\\boldsymbol{\\phi}_0^{\\dagger}$.\n\nThe unperturbed eigenvalue $k_0$ is found by solving $\\det(\\mathbf{F}_0 - k_0 \\mathbf{L}_0) = 0$.\n$$\n\\det\\left( \\begin{pmatrix} 0.7 & 0 \\\\ 0 & 0.1 \\end{pmatrix} - k_0 \\begin{pmatrix} 0.8 & -0.1 \\\\ -0.05 & 0.6 \\end{pmatrix} \\right) \\;=\\; \\det\\begin{pmatrix} 0.7 - 0.8k_0 & 0.1k_0 \\\\ 0.05k_0 & 0.1 - 0.6k_0 \\end{pmatrix} \\;=\\; 0\n$$\n$$\n(0.7 - 0.8k_0)(0.1 - 0.6k_0) - (0.1k_0)(0.05k_0) \\;=\\; 0\n$$\n$$\n0.07 - 0.5k_0 + 0.48k_0^2 - 0.005k_0^2 \\;=\\; 0\n$$\n$$\n0.475k_0^2 - 0.5k_0 + 0.07 \\;=\\; 0\n$$\nUsing the quadratic formula, $k_0 = \\frac{0.5 \\pm \\sqrt{(-0.5)^2 - 4(0.475)(0.07)}}{2(0.475)} = \\frac{0.5 \\pm \\sqrt{0.25 - 0.133}}{0.95} = \\frac{0.5 \\pm \\sqrt{0.117}}{0.95}$.\nThe fundamental mode corresponds to the largest positive eigenvalue:\n$$\nk_0 = \\frac{0.5 + \\sqrt{0.117}}{0.95} \\approx 0.886371186\n$$\nThe forward eigenvector $\\boldsymbol{\\phi}_0 = (\\phi_1, \\phi_2)^T$ is found from $(\\mathbf{F}_0 - k_0 \\mathbf{L}_0)\\boldsymbol{\\phi}_0 = \\mathbf{0}$. From the first row: $(0.7 - 0.8k_0)\\phi_1 + (0.1k_0)\\phi_2 = 0$. Normalizing with $\\phi_1=1$:\n$$\n\\phi_2 = -\\frac{0.7 - 0.8k_0}{0.1k_0} = \\frac{8k_0 - 7}{k_0} \\approx 0.10263158\n$$\nSo, $\\boldsymbol{\\phi}_0 \\approx (1, 0.10263158)^T$.\n\nThe adjoint eigenvector $\\boldsymbol{\\phi}_0^{\\dagger} = (\\phi_1^{\\dagger}, \\phi_2^{\\dagger})^T$ is found from $(\\mathbf{F}_0^{\\dagger} - k_0 \\mathbf{L}_0^{\\dagger})\\boldsymbol{\\phi}_0^{\\dagger} = \\mathbf{0}$. Since the matrices are real, $\\dagger$ is the transpose.\n$$\n\\left( \\begin{pmatrix} 0.7 & 0 \\\\ 0 & 0.1 \\end{pmatrix} - k_0 \\begin{pmatrix} 0.8 & -0.05 \\\\ -0.1 & 0.6 \\end{pmatrix} \\right) \\boldsymbol{\\phi}_0^{\\dagger} = \\begin{pmatrix} 0.7 - 0.8k_0 & 0.05k_0 \\\\ 0.1k_0 & 0.1 - 0.6k_0 \\end{pmatrix} \\boldsymbol{\\phi}_0^{\\dagger} = \\mathbf{0}\n$$\nFrom the first row, $(0.7 - 0.8k_0)\\phi_1^{\\dagger} + (0.05k_0)\\phi_2^{\\dagger} = 0$. Normalizing with $\\phi_1^{\\dagger}=1$:\n$$\n\\phi_2^{\\dagger} = -\\frac{0.7 - 0.8k_0}{0.05k_0} = \\frac{8k_0 - 7}{0.5k_0} \\approx 0.20526316\n$$\nSo, $\\boldsymbol{\\phi}_0^{\\dagger} \\approx (1, 0.20526316)^T$.\n\nNow we evaluate the inner products.\nNumerator term: $\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_1\\,\\boldsymbol{\\phi}_0 \\rangle = \\boldsymbol{\\phi}_0^{\\dagger T} \\mathbf{L}_1 \\boldsymbol{\\phi}_0$\n$$\n\\begin{pmatrix} 1 & \\phi_2^{\\dagger} \\end{pmatrix} \\begin{pmatrix} 1 & 0 \\\\ 0 & 0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} 1 & \\phi_2^{\\dagger} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 1\n$$\nDenominator term: $\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0\\,\\boldsymbol{\\phi}_0 \\rangle = \\boldsymbol{\\phi}_0^{\\dagger T} \\mathbf{L}_0 \\boldsymbol{\\phi}_0$. We can use the identity $\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0 \\boldsymbol{\\phi}_0 \\rangle = \\frac{1}{k_0}\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{F}_0 \\boldsymbol{\\phi}_0 \\rangle$.\n$$\n\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{F}_0 \\boldsymbol{\\phi}_0 \\rangle = \\begin{pmatrix} 1 & \\phi_2^{\\dagger} \\end{pmatrix} \\begin{pmatrix} 0.7 & 0 \\\\ 0 & 0.1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ \\phi_2 \\end{pmatrix} = 0.7(1)(1) + 0.1\\phi_2^{\\dagger}\\phi_2\n$$\n$$\n\\approx 0.7 + 0.1(0.20526316)(0.10263158) \\approx 0.7 + 0.002106648 = 0.702106648\n$$\nSo, the denominator is $\\frac{1}{k_0}(0.702106648) \\approx \\frac{0.702106648}{0.886371186} \\approx 0.792113158$.\n\nFinally, we compute the derivative:\n$$\n\\frac{dk}{dp}\\bigg|_{p=0} = \\frac{-k_0 \\times 1}{\\langle \\boldsymbol{\\phi}_0^{\\dagger}, \\mathbf{L}_0\\,\\boldsymbol{\\phi}_0 \\rangle} \\approx \\frac{-0.886371186}{0.792113158} \\approx -1.119000\n$$\nRounding to four significant figures, the result is $-1.119$.",
            "answer": "$$\n\\boxed{-1.119}\n$$"
        }
    ]
}