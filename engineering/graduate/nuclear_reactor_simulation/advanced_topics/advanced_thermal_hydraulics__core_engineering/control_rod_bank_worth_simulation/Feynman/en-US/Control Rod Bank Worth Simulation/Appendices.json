{
    "hands_on_practices": [
        {
            "introduction": "In reactor operations and safety analysis, it is often necessary to evaluate the reactivity impact of small control rod movements. Re-running a full, computationally expensive eigenvalue simulation for each small step is impractical. This exercise introduces the powerful and efficient method of first-order perturbation theory, which leverages pre-computed forward and adjoint flux distributions to estimate reactivity changes almost instantaneously . You will implement the core formula of adjoint-weighted perturbation theory, gaining insight into how the \"importance\" of a neutron, represented by the adjoint flux $\\phi^{\\dagger}$, determines the impact of a local perturbation on global reactor behavior.",
            "id": "4218354",
            "problem": "You are given a discretized representation of a steady-state neutron balance in a one-group, fixed-source-free reactor core model. The unperturbed eigenvalue problem is written in operator form as $A \\phi = \\frac{1}{k} F \\phi$, where $A$ is the neutron loss operator, $\\phi$ is the fundamental forward flux eigenvector, $F$ is the fission production operator, and $k$ is the effective multiplication factor. The corresponding adjoint problem is $A^{\\dagger} \\phi^{\\dagger} = \\frac{1}{k} F^{\\dagger} \\phi^{\\dagger}$, where $\\phi^{\\dagger}$ is the adjoint flux eigenvector. In a nodal discretization, the inner product of two fields $x$ and $y$ is represented by $\\langle x, y \\rangle = \\sum_{i=1}^{N} x_i y_i V_i$, where $V_i$ is the volume of node $i$ and $N$ is the number of nodes. The reactivity is defined as $\\rho = \\frac{k - 1}{k}$, which is dimensionless.\n\nA control rod bank step is modeled as a small perturbation to the absorption term in certain nodes, such that the loss operator is perturbed as $A \\to A + \\delta A$, where $\\delta A$ is diagonal with entries $\\delta \\Sigma_{a,i} \\ge 0$ (for insertion) or $\\delta \\Sigma_{a,i} \\le 0$ (for withdrawal), and all other physics and operators remain unchanged for the purposes of a first-order estimate. Assume that the fission operator $F$ does not change for these small rod steps. You have access to precomputed forward and adjoint flux distributions and the nodal effective fission production cross section, and you must construct a procedure to evaluate the incremental reactivity change $\\Delta \\rho$ using only these precomputed distributions and the perturbation $\\delta \\Sigma_{a}$, without re-solving the forward eigenvalue problem.\n\nStarting from the operator definitions above and first principles of adjoint-weighted perturbation theory, derive the expression for $\\Delta \\rho$ that is valid to first order for small $\\delta \\Sigma_{a}$, and implement it to compute $\\Delta \\rho$ for the following discrete test suite. In all cases, treat the inner products as discrete sums over nodes weighted by volumes. Use the macroscopic absorption cross section increments $\\delta \\Sigma_{a}$ in $\\mathrm{cm}^{-1}$, the effective fission production cross section $\\nu \\Sigma_f$ in $\\mathrm{cm}^{-1}$, and node volumes $V$ in $\\mathrm{cm}^3$. The forward flux $\\phi$ and adjoint flux $\\phi^{\\dagger}$ are given in consistent arbitrary units. Express the final answers for $\\Delta \\rho$ in percent mille (pcm), as floats rounded to three decimal places. Percent mille (pcm) means the dimensionless reactivity multiplied by $10^5$.\n\nFor each test case, you are given arrays for $\\phi$, $\\phi^{\\dagger}$, $\\nu \\Sigma_f$, $V$, and $\\delta \\Sigma_a$:\n\n- Test Case $1$ (single-node insertion):\n  - $N = 5$\n  - $\\phi = [1.0, 1.5, 2.0, 1.5, 1.0]$\n  - $\\phi^{\\dagger} = [1.0, 1.4, 1.8, 1.4, 1.0]$\n  - $\\nu \\Sigma_f = [0.020, 0.024, 0.028, 0.024, 0.020]$ $\\mathrm{cm}^{-1}$\n  - $V = [1000, 1000, 1000, 1000, 1000]$ $\\mathrm{cm}^3$\n  - $\\delta \\Sigma_a = [0.0, 0.0, 2\\times 10^{-5}, 0.0, 0.0]$ $\\mathrm{cm}^{-1}$\n\n- Test Case $2$ (zero perturbation):\n  - $N = 5$\n  - $\\phi = [1.0, 1.5, 2.0, 1.5, 1.0]$\n  - $\\phi^{\\dagger} = [1.0, 1.4, 1.8, 1.4, 1.0]$\n  - $\\nu \\Sigma_f = [0.020, 0.024, 0.028, 0.024, 0.020]$ $\\mathrm{cm}^{-1}$\n  - $V = [1000, 1000, 1000, 1000, 1000]$ $\\mathrm{cm}^3$\n  - $\\delta \\Sigma_a = [0.0, 0.0, 0.0, 0.0, 0.0]$ $\\mathrm{cm}^{-1}$\n\n- Test Case $3$ (multi-node insertion):\n  - $N = 5$\n  - $\\phi = [1.0, 1.5, 2.0, 1.5, 1.0]$\n  - $\\phi^{\\dagger} = [1.0, 1.4, 1.8, 1.4, 1.0]$\n  - $\\nu \\Sigma_f = [0.020, 0.024, 0.028, 0.024, 0.020]$ $\\mathrm{cm}^{-1}$\n  - $V = [1000, 1000, 1000, 1000, 1000]$ $\\mathrm{cm}^3$\n  - $\\delta \\Sigma_a = [0.0, 1\\times 10^{-5}, 1\\times 10^{-5}, 1\\times 10^{-5}, 0.0]$ $\\mathrm{cm}^{-1}$\n\n- Test Case $4$ (variable volumes, edge insertion):\n  - $N = 5$\n  - $\\phi = [0.5, 1.0, 2.5, 1.0, 0.5]$\n  - $\\phi^{\\dagger} = [0.8, 1.2, 1.6, 1.2, 0.8]$\n  - $\\nu \\Sigma_f = [0.018, 0.020, 0.030, 0.020, 0.018]$ $\\mathrm{cm}^{-1}$\n  - $V = [800, 1200, 1500, 1200, 800]$ $\\mathrm{cm}^3$\n  - $\\delta \\Sigma_a = [5\\times 10^{-5}, 0.0, 0.0, 0.0, 5\\times 10^{-5}]$ $\\mathrm{cm}^{-1}$\n\n- Test Case $5$ (single-node withdrawal):\n  - $N = 5$\n  - $\\phi = [1.0, 1.5, 2.0, 1.5, 1.0]$\n  - $\\phi^{\\dagger} = [1.0, 1.4, 1.8, 1.4, 1.0]$\n  - $\\nu \\Sigma_f = [0.020, 0.024, 0.028, 0.024, 0.020]$ $\\mathrm{cm}^{-1}$\n  - $V = [1000, 1000, 1000, 1000, 1000]$ $\\mathrm{cm}^3$\n  - $\\delta \\Sigma_a = [0.0, 0.0, -1\\times 10^{-5}, 0.0, 0.0]$ $\\mathrm{cm}^{-1}$\n\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list enclosed in square brackets, in pcm units, rounded to three decimal places, for example: $\"[x_1,x_2,x_3,x_4,x_5]\"$, where each $x_i$ is the float result for test case $i$.",
            "solution": "The user-provided problem is evaluated as **valid** following a rigorous validation process. It is scientifically grounded in established principles of nuclear reactor physics, well-posed with a complete and consistent set of data, and objective in its formulation. The task is to derive and apply the first-order perturbation theory formula for reactivity change.\n\nThe fundamental principle guiding the solution is adjoint-weighted first-order perturbation theory. This method allows for the estimation of the change in an eigenvalue of a system due to a small perturbation in its operators, without needing to solve the perturbed eigenvalue problem directly. In this context, the eigenvalue is related to the reactor's effective multiplication factor, $k$.\n\nWe begin with the unperturbed forward and adjoint eigenvalue problems for a critical reactor core, where the fundamental eigenvalue is $1$. For a general multiplication factor $k$, the equations are:\n$$\nA \\phi = \\frac{1}{k} F \\phi\n$$\n$$\nA^{\\dagger} \\phi^{\\dagger} = \\frac{1}{k} F^{\\dagger} \\phi^{\\dagger}\n$$\nHere, $A$ is the neutron loss operator (absorption and leakage), $F$ is the fission production operator, $\\phi$ is the forward neutron flux, $\\phi^{\\dagger}$ is the adjoint neutron flux (or importance function), and $k$ is the effective multiplication factor.\n\nA perturbation is introduced to the loss operator, $A \\to A' = A + \\delta A$, where $\\delta A$ represents the change in macroscopic absorption cross section due to control rod movement. The fission operator $F$ is assumed to be unchanged, $F' = F$. The perturbed system is described by:\n$$\nA' \\phi' = \\frac{1}{k'} F' \\phi'\n$$\nSubstituting the perturbed quantities gives:\n$$\n(A + \\delta A) \\phi' = \\frac{1}{k'} F \\phi'\n$$\nFor a small perturbation, the perturbed flux $\\phi'$ and multiplication factor $k'$ can be expressed as first-order expansions around their unperturbed values: $\\phi' \\approx \\phi + \\delta \\phi$ and $k' \\approx k + \\delta k$. The eigenvalue term can be expanded as $\\frac{1}{k'} = \\frac{1}{k+\\delta k} \\approx \\frac{1}{k}(1 - \\frac{\\delta k}{k}) = \\frac{1}{k} - \\frac{\\delta k}{k^2}$. Substituting these into the perturbed equation and retaining only first-order terms (i.e., neglecting products of small quantities like $\\delta A \\delta \\phi$) yields:\n$$\nA \\phi + \\delta A \\phi \\approx \\left(\\frac{1}{k} - \\frac{\\delta k}{k^2}\\right) F \\phi\n$$\nUsing the unperturbed equation $A \\phi = \\frac{1}{k} F \\phi$, we can simplify the expression:\n$$\n\\frac{1}{k} F \\phi + \\delta A \\phi \\approx \\frac{1}{k} F \\phi - \\frac{\\delta k}{k^2} F \\phi\n$$\nThis reduces to:\n$$\n\\delta A \\phi \\approx -\\frac{\\delta k}{k^2} F \\phi\n$$\nTo solve for the change in eigenvalue $\\delta k$, we take the inner product of this equation with the unperturbed adjoint flux $\\phi^{\\dagger}$. The inner product is defined as $\\langle x, y \\rangle$.\n$$\n\\langle \\phi^{\\dagger}, \\delta A \\phi \\rangle \\approx \\left\\langle \\phi^{\\dagger}, -\\frac{\\delta k}{k^2} F \\phi \\right\\rangle\n$$\nSince $\\delta k/k^2$ is a scalar, it can be moved outside the inner product:\n$$\n\\langle \\phi^{\\dagger}, \\delta A \\phi \\rangle \\approx -\\frac{\\delta k}{k^2} \\langle \\phi^{\\dagger}, F \\phi \\rangle\n$$\nSolving for $\\delta k/k^2$ gives the fractional change in the eigenvalue:\n$$\n\\frac{\\delta k}{k^2} \\approx -\\frac{\\langle \\phi^{\\dagger}, \\delta A \\phi \\rangle}{\\langle \\phi^{\\dagger}, F \\phi \\rangle}\n$$\nThe problem asks for the change in reactivity, $\\Delta \\rho$. Reactivity $\\rho$ is defined as $\\rho = \\frac{k-1}{k} = 1 - \\frac{1}{k}$. The change in reactivity, $\\Delta \\rho$, for a small perturbation is given by:\n$$\n\\Delta \\rho = \\rho' - \\rho = \\left(1 - \\frac{1}{k'}\\right) - \\left(1 - \\frac{1}{k}\\right) = \\frac{1}{k} - \\frac{1}{k'} = \\frac{k' - k}{k k'} = \\frac{\\delta k}{k k'}\n$$\nTo first order, we can approximate $k' \\approx k$, which gives the key relationship:\n$$\n\\Delta \\rho \\approx \\frac{\\delta k}{k^2}\n$$\nSubstituting this into our derived expression yields the first-order formula for the change in reactivity:\n$$\n\\Delta \\rho \\approx -\\frac{\\langle \\phi^{\\dagger}, \\delta A \\phi \\rangle}{\\langle \\phi^{\\dagger}, F \\phi \\rangle}\n$$\nThe problem provides a discretized nodal representation where operators are diagonal matrices acting on nodal vectors and the inner product is a volume-weighted sum: $\\langle x, y \\rangle = \\sum_{i=1}^{N} x_i y_i V_i$. The operator actions are $(\\delta A \\phi)_i = \\delta \\Sigma_{a,i} \\phi_i$ and $(F \\phi)_i = (\\nu \\Sigma_f)_i \\phi_i$. Applying these definitions, we obtain the computational formula:\n$$\n\\Delta \\rho \\approx - \\frac{\\sum_{i=1}^{N} \\phi^{\\dagger}_i \\delta \\Sigma_{a,i} \\phi_i V_i}{\\sum_{i=1}^{N} \\phi^{\\dagger}_i (\\nu \\Sigma_f)_i \\phi_i V_i}\n$$\nThe numerator represents the total importance-weighted absorption rate change, while the denominator represents the total importance-weighted fission neutron production rate, which serves as a normalization factor. The negative sign ensures that an increase in absorption ($\\delta \\Sigma_{a,i} > 0$) leads to a negative reactivity change.\n\nThe final result must be expressed in percent mille (pcm), where $1\\,\\mathrm{pcm} = 10^{-5}$. Therefore, the computed dimensionless reactivity change $\\Delta \\rho$ is multiplied by $10^5$. The implementation will calculate the numerator and denominator for each test case using the provided arrays, compute $\\Delta\\rho$, convert it to pcm, and round to three decimal places.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the control rod bank worth simulation problem using first-order\n    adjoint-weighted perturbation theory.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1 (single-node insertion)\n        {\n            'phi':         [1.0, 1.5, 2.0, 1.5, 1.0],\n            'phi_adj':     [1.0, 1.4, 1.8, 1.4, 1.0],\n            'nu_sigma_f':  [0.020, 0.024, 0.028, 0.024, 0.020],\n            'V':           [1000, 1000, 1000, 1000, 1000],\n            'delta_sigma_a': [0.0, 0.0, 2e-5, 0.0, 0.0]\n        },\n        # Test Case 2 (zero perturbation)\n        {\n            'phi':         [1.0, 1.5, 2.0, 1.5, 1.0],\n            'phi_adj':     [1.0, 1.4, 1.8, 1.4, 1.0],\n            'nu_sigma_f':  [0.020, 0.024, 0.028, 0.024, 0.020],\n            'V':           [1000, 1000, 1000, 1000, 1000],\n            'delta_sigma_a': [0.0, 0.0, 0.0, 0.0, 0.0]\n        },\n        # Test Case 3 (multi-node insertion)\n        {\n            'phi':         [1.0, 1.5, 2.0, 1.5, 1.0],\n            'phi_adj':     [1.0, 1.4, 1.8, 1.4, 1.0],\n            'nu_sigma_f':  [0.020, 0.024, 0.028, 0.024, 0.020],\n            'V':           [1000, 1000, 1000, 1000, 1000],\n            'delta_sigma_a': [0.0, 1e-5, 1e-5, 1e-5, 0.0]\n        },\n        # Test Case 4 (variable volumes, edge insertion)\n        {\n            'phi':         [0.5, 1.0, 2.5, 1.0, 0.5],\n            'phi_adj':     [0.8, 1.2, 1.6, 1.2, 0.8],\n            'nu_sigma_f':  [0.018, 0.020, 0.030, 0.020, 0.018],\n            'V':           [800, 1200, 1500, 1200, 800],\n            'delta_sigma_a': [5e-5, 0.0, 0.0, 0.0, 5e-5]\n        },\n        # Test Case 5 (single-node withdrawal)\n        {\n            'phi':         [1.0, 1.5, 2.0, 1.5, 1.0],\n            'phi_adj':     [1.0, 1.4, 1.8, 1.4, 1.0],\n            'nu_sigma_f':  [0.020, 0.024, 0.028, 0.024, 0.020],\n            'V':           [1000, 1000, 1000, 1000, 1000],\n            'delta_sigma_a': [0.0, 0.0, -1e-5, 0.0, 0.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Convert lists to numpy arrays for vectorized calculations\n        phi = np.array(case['phi'])\n        phi_adj = np.array(case['phi_adj'])\n        nu_sigma_f = np.array(case['nu_sigma_f'])\n        V = np.array(case['V'])\n        delta_sigma_a = np.array(case['delta_sigma_a'])\n\n        # Calculate the numerator of the perturbation formula:\n        # -phi^dagger, delta_A * phi\n        # which discretizes to -sum(phi_adj * delta_sigma_a * phi * V)\n        numerator = -np.sum(phi_adj * delta_sigma_a * phi * V)\n\n        # Calculate the denominator of the perturbation formula:\n        # phi^dagger, F * phi\n        # which discretizes to sum(phi_adj * nu_sigma_f * phi * V)\n        denominator = np.sum(phi_adj * nu_sigma_f * phi * V)\n\n        # Calculate the change in reactivity (delta_rho)\n        if denominator == 0:\n            # Avoid division by zero, though not expected for a valid reactor model\n            # where production must be positive.\n            # If numerator is also zero, delta_rho is 0. Otherwise, it's undefined.\n            delta_rho = 0.0 if numerator == 0.0 else np.nan\n        else:\n            delta_rho = numerator / denominator\n\n        # Convert dimensionless reactivity to percent mille (pcm)\n        # 1 pcm = 10^-5\n        delta_rho_pcm = delta_rho * 1e5\n\n        # Round the result to three decimal places\n        rounded_result = round(delta_rho_pcm, 3)\n        results.append(rounded_result)\n\n    # Format the final output string as a comma-separated list in brackets.\n    # The str() conversion handles cases like 0.0 correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon the calculation of incremental reactivity changes, this practice addresses a more comprehensive real-world problem: determining the total (integral) worth of a control rod bank and understanding how it evolves as the nuclear fuel is consumed over an operational cycle. You will work with differential worth curves—the reactivity change per unit of insertion—at discrete burnup points, which is typical of data generated from reactor core simulators. This exercise will require you to apply standard numerical methods, namely the trapezoidal rule for integration and linear interpolation, to transform discrete data points into a continuous understanding of rod worth throughout the reactor's life . This practice is essential for developing the skills to analyze and interpret the results of lifecycle core-follow simulations.",
            "id": "4218299",
            "problem": "You are tasked with computing the change in integral control rod bank worth over specified burnup intervals by integrating differential worth curves at discrete burnup states and interpolating between the resulting integral worths. The physical and mathematical basis is as follows. The integral worth $W(B)$ of a control rod bank at burnup $B$ is defined, from first principles, as the line integral of the differential worth $w(s,B)$ with respect to the insertion depth $s$, from zero insertion to a specified full insertion depth $S_{\\max}$, expressed as $$W(B)=\\int_{0}^{S_{\\max}} w(s,B)\\,ds.$$ The differential worth $w(s,B)$ is provided at discrete insertion depths for several discrete burnup states. You must (i) compute the integral worth at those discrete burnup states using an appropriate numerical quadrature that is consistent with linearly varying behavior between sample points, and then (ii) compute the integral worth at requested burnup values by interpolating between the discrete burnup states. Finally, (iii) compute the change in integral worth across the specified burnup interval as the difference $W(B_{\\text{end}})-W(B_{\\text{start}})$. All integral worth values must be expressed in percent mille (pcm), where percent mille (pcm) is a unit of reactivity such that $1$ pcm $=10^{-5}$ in $\\Delta k/k$.\n\nYour program must implement the following requirements:\n\n- Use the definition of integral worth as an integral over insertion depth $s$ and the principle of a consistent numerical quadrature for piecewise-linear data to aggregate discrete differential worth samples into integral worth values. Then use a mathematically justified interpolation scheme to evaluate $W(B)$ at intermediate burnup values between provided discrete burnup states. Do not assume any specific functional form beyond linear behavior between adjacent samples in $s$ and $B$.\n- Treat insertion depth $s$ in centimeters (cm), burnup $B$ in gigawatt-days per metric ton uranium (GWd/tU), and differential worth $w(s,B)$ in percent mille per centimeter (pcm/cm). The integral worth $W(B)$ must be computed in percent mille (pcm). All final change values must be floats expressed in pcm, rounded to one decimal place.\n\nImplement and evaluate the following test suite. Each test case provides:\n- a list of discrete burnup states $[B_1,B_2,\\dots]$ in $\\text{GWd}/\\text{tU}$,\n- a single common insertion grid $[s_0,s_1,\\dots,s_M]$ in $\\text{cm}$,\n- differential worth samples $w(s_j,B_i)$ in $\\text{pcm}/\\text{cm}$ for each burnup state $B_i$ and grid point $s_j$, and\n- target burnup values $B_{\\text{start}}$ and $B_{\\text{end}}$ in $\\text{GWd}/\\text{tU}$, for which the change $W(B_{\\text{end}})-W(B_{\\text{start}})$ must be reported in $\\text{pcm}$.\n\nTest Case $1$ (happy path, uniform insertion grid):\n- Burnup states: $[0,20,40]$ $\\text{GWd}/\\text{tU}$.\n- Insertion grid: $[0,10,20,30,40,50]$ $\\text{cm}$.\n- Differential worth at $B=0$: $[25,20,16,12,8,5]$ $\\text{pcm}/\\text{cm}$.\n- Differential worth at $B=20$: $[22,18,14,10,7,4]$ $\\text{pcm}/\\text{cm}$.\n- Differential worth at $B=40$: $[19,16,12,9,6,3]$ $\\text{pcm}/\\text{cm}$.\n- Evaluate change from $B_{\\text{start}}=0$ to $B_{\\text{end}}=40$ $\\text{GWd}/\\text{tU}$.\n\nTest Case $2$ (interpolation in burnup, uniform but different insertion grid):\n- Burnup states: $[0,40]$ $\\text{GWd}/\\text{tU}$.\n- Insertion grid: $[0,8,16,24,40]$ $\\text{cm}$.\n- Differential worth at $B=0$: $[24,21,17,12,7]$ $\\text{pcm}/\\text{cm}$.\n- Differential worth at $B=40$: $[18,16,13,9,5]$ $\\text{pcm}/\\text{cm}$.\n- Evaluate change from $B_{\\text{start}}=10$ to $B_{\\text{end}}=30$ $\\text{GWd}/\\text{tU}$.\n\nTest Case $3$ (edge case with non-uniform insertion grid):\n- Burnup states: $[5,15,30]$ $\\text{GWd}/\\text{tU}$.\n- Insertion grid: $[0,5,15,25,45]$ $\\text{cm}$.\n- Differential worth at $B=5$: $[30,24,18,11,6]$ $\\text{pcm}/\\text{cm}$.\n- Differential worth at $B=15$: $[28,22,16,10,5]$ $\\text{pcm}/\\text{cm}$.\n- Differential worth at $B=30$: $[25,19,14,9,4]$ $\\text{pcm}/\\text{cm}$.\n- Evaluate change from $B_{\\text{start}}=15$ to $B_{\\text{end}}=30$ $\\text{GWd}/\\text{tU}$.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the three test cases, with each value being a float in $\\text{pcm}$ rounded to one decimal place (e.g., $[x_1,x_2,x_3]$ where each $x_i$ is in $\\text{pcm}$).",
            "solution": "The problem is valid. It is scientifically grounded in the principles of nuclear reactor physics, specifically concerning control rod worth and its evolution with fuel burnup. The problem is well-posed, providing all necessary data and clearly defining the mathematical procedures for its solution. The terminology and units (percent mille, GWd/tU) are standard in the field.\n\nThe problem requires a two-step numerical procedure to determine the change in integral control rod bank worth, $\\Delta W$, over a specified burnup interval $[B_{\\text{start}}, B_{\\text{end}}]$. The steps are:\n1.  Numerical integration to find the integral worth $W(B_i)$ at discrete burnup states $B_i$.\n2.  Linear interpolation to find the integral worth $W(B)$ at the target burnup values $B_{\\text{start}}$ and $B_{\\text{end}}$.\n\n**Step 1: Calculation of Integral Worth at Discrete Burnup States**\n\nThe integral worth of a control rod bank, $W(B)$, at a given fuel burnup state $B$, is defined as the integral of the differential worth, $w(s, B)$, over the full insertion depth of the rod, from $s = 0$ to $s = S_{\\max}$.\n$$\nW(B) = \\int_{0}^{S_{\\max}} w(s, B) \\, ds\n$$\nThe problem provides sampled values of the differential worth $w(s_j, B_i)$ at a set of discrete insertion depths $\\{s_0, s_1, \\dots, s_M\\}$ for several discrete burnup states $\\{B_1, B_2, \\dots\\}$. The problem states to assume linear behavior for $w(s, B)$ between these discrete sample points in $s$. This defines $w(s,B)$ as a piecewise linear function of insertion depth $s$.\n\nThe integral of a piecewise linear function defined by points $(x_j, y_j)$ is most appropriately calculated using the trapezoidal rule. The total area is the sum of the areas of the trapezoids formed between each pair of adjacent points. For a given burnup state $B_i$, the integral worth $W(B_i)$ is calculated as:\n$$\nW(B_i) \\approx \\sum_{j=0}^{M-1} \\frac{w(s_{j+1}, B_i) + w(s_j, B_i)}{2} (s_{j+1} - s_j)\n$$\nwhere $M+1$ is the number of points in the insertion grid. This calculation is performed for each discrete burnup state $B_i$ provided in a test case, yielding a set of discrete integral worth values $\\{W(B_1), W(B_2), \\dots\\}$. The units are consistent: the differential worth in pcm/cm multiplied by the insertion depth in cm yields an integral worth in pcm.\n\n**Step 2: Interpolation of Integral Worth for Target Burnup Values**\n\nAfter Step 1, we possess a set of discrete data points $(B_i, W(B_i))$ that describes how the integral worth changes with fuel burnup. The problem states to assume linear behavior for the integral worth $W(B)$ between these discrete burnup states. Therefore, to find the integral worth $W(B)$ at any intermediate burnup $B$ that falls between two given states, $B_i \\leq B \\leq B_{i+1}$, we employ linear interpolation. The formula for linear interpolation is:\n$$\nW(B) = W(B_i) + (B - B_i) \\frac{W(B_{i+1}) - W(B_i)}{B_{i+1} - B_i}\n$$\nThis formula is used to calculate the integral worths at the specified start and end burnup values, $W(B_{\\text{start}})$ and $W(B_{\\text{end}})$. If a target burnup value coincides with one of the discrete burnup states $B_i$, no interpolation is necessary, and we directly use the value $W(B_i)$ calculated in Step 1.\n\n**Step 3: Final Calculation of Worth Change**\n\nThe final quantity to be reported is the change in integral worth over the interval, which is simply the difference between the worth at the end and start burnups:\n$$\n\\Delta W = W(B_{\\text{end}}) - W(B_{\\text{start}})\n$$\nThis value, in units of pcm, is then rounded to one decimal place as required.\n\nThe algorithmic implementation will follow these steps precisely. For each test case, we first compute the integral worth for each provided burnup state using the trapezoidal rule. Then, we use these computed integral worths to perform linear interpolation to find the worths at the target start and end burnups. Finally, we compute their difference. This procedure is implemented for each of the three test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the change in integral control rod bank worth over specified burnup intervals.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"burnup_states\": [0, 20, 40],\n            \"insertion_grid\": [0, 10, 20, 30, 40, 50],\n            \"diff_worths\": [\n                [25, 20, 16, 12, 8, 5],  # B = 0\n                [22, 18, 14, 10, 7, 4],  # B = 20\n                [19, 16, 12, 9, 6, 3],   # B = 40\n            ],\n            \"b_start\": 0,\n            \"b_end\": 40,\n        },\n        {\n            \"burnup_states\": [0, 40],\n            \"insertion_grid\": [0, 8, 16, 24, 40],\n            \"diff_worths\": [\n                [24, 21, 17, 12, 7],     # B = 0\n                [18, 16, 13, 9, 5],      # B = 40\n            ],\n            \"b_start\": 10,\n            \"b_end\": 30,\n        },\n        {\n            \"burnup_states\": [5, 15, 30],\n            \"insertion_grid\": [0, 5, 15, 25, 45],\n            \"diff_worths\": [\n                [30, 24, 18, 11, 6],     # B = 5\n                [28, 22, 16, 10, 5],     # B = 15\n                [25, 19, 14, 9, 4],      # B = 30\n            ],\n            \"b_start\": 15,\n            \"b_end\": 30,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        burnup_states = case[\"burnup_states\"]\n        insertion_grid = case[\"insertion_grid\"]\n        diff_worth_curves = case[\"diff_worths\"]\n        b_start = case[\"b_start\"]\n        b_end = case[\"b_end\"]\n\n        # Step 1: Compute integral worth W(B_i) at each discrete burnup state.\n        # The integral of a piecewise linear function is calculated using the trapezoidal rule.\n        # numpy.trapz is the direct implementation of this rule.\n        integral_worths_at_states = []\n        for diff_worth_curve in diff_worth_curves:\n            integral_worth = np.trapz(diff_worth_curve, x=insertion_grid)\n            integral_worths_at_states.append(integral_worth)\n\n        # Step 2: Linearly interpolate to find W(B_start) and W(B_end).\n        # numpy.interp performs linear interpolation. It can compute values for\n        # multiple points at once.\n        target_burnups = [b_start, b_end]\n        w_start, w_end = np.interp(\n            target_burnups, burnup_states, integral_worths_at_states\n        )\n        \n        # Step 3: Compute the change in integral worth.\n        delta_w = w_end - w_start\n        \n        # Round the result to one decimal place and add to the list.\n        results.append(round(delta_w, 1))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "After calculating a quantity like a control rod worth profile, a critical question for any simulation expert is: \"How accurate is my result?\" All numerical models introduce errors, and a primary source is the discretization of continuous space onto a finite mesh. This exercise provides a hands-on introduction to a cornerstone of Verification and Validation (VV): quantifying discretization uncertainty using Richardson extrapolation and the Grid Convergence Index (GCI) methodology . By systematically running simulations on a series of refined meshes, you can estimate the error in your solution and construct formal error bars, transforming a simple numerical output into a result with a rigorous statement of confidence.",
            "id": "4218284",
            "problem": "You will write a complete, runnable program that quantifies the mesh resolution uncertainty in the axial differential control rod bank worth distribution $W(z)$ using Richardson extrapolation and error bar estimation. The physical context is a one-dimensional slab reactor of axial height $H$ with a homogeneous material, where the stationary neutron flux fundamental mode is approximated by a separable axial shape. The control rod bank worth distribution $W(z)$ is modeled via first-order perturbation theory grounded in the neutron diffusion eigenvalue problem, assuming a uniform perturbation of absorption cross section in the inserted region so that $W(z)$ is proportional to the product of the forward and adjoint fluxes. In a homogeneous slab, the adjoint flux equals the forward flux for the fundamental mode, leading to a shape proportional to the squared mode shape. For this benchmarking problem, the underlying exact distribution is defined as\n$$\nW_{\\text{true}}(z) = A \\sin^2\\!\\left(\\frac{\\pi z}{H}\\right),\n$$\nwith all angles in radians, $z \\in [0,H]$, and $W$ expressed in pcm/cm, where $1$ pcm equals $10^{-5}$ in units of $\\Delta k/k$, and lengths are in centimeters. The program must not use $W_{\\text{true}}(z)$ to directly compute the final answer; instead, it must rely on simulated numerical solutions on successively refined meshes and use a principled extrapolation and uncertainty estimation procedure.\n\nYou are given a synthetic numerical solver model that returns mesh-discrete approximations $W_h(z_i)$ on uniform meshes with spacing $h$, where the cell centers are $z_i = \\left(i+\\frac{1}{2}\\right) h_{\\text{eff}}$ for $i = 0,1,\\dots,N-1$ and $N = H/h_{\\text{eff}}$ is an integer, with $h_{\\text{eff}} = H/N$. The numerical approximation includes an asymptotic truncation error consistent with a second-order method and a controllable higher-order contamination:\n$$\nW_h(z_i) = W_{\\text{true}}(z_i) + \\alpha h_{\\text{eff}}^{p} + \\beta h_{\\text{eff}}^{p+1} + \\gamma h_{\\text{eff}}^{p} \\sin\\!\\left(\\frac{3\\pi z_i}{H}\\right),\n$$\nwhere $p$ is the nominal order, $\\alpha$, $\\beta$, and $\\gamma$ are coefficients, and $\\sin(\\cdot)$ uses radians. This $W_h$ serves as the computed observable on a given mesh. For any Richardson-based comparison, all mesh solutions must be represented on a common set of axial locations; your program should use the finest mesh’s cell centers as the common locations and interpolate coarser solutions to these locations using linear interpolation.\n\nYour task is to:\n- Compute three mesh solutions $W_{h_1}$, $W_{h_2}$, $W_{h_3}$ for each test case, where $h_1 > h_2 > h_3$ and the refinement ratio $r$ defined by $r = h_1/h_2 = h_2/h_3$ is specified.\n- Use a three-level Richardson extrapolation framework: estimate a single, global observed order $p_{\\text{obs}}$ from the triplet using a norm-based approach across $z$, and then form a two-solution Richardson extrapolation from the finest two meshes at each $z$ to approximate the grid-converged value and the associated local discretization error magnitude.\n- From the local error magnitude, form two-sided error bars using a safety factor calibrated for a $95\\%$ coverage Grid Convergence Index (GCI). Use a standard constant safety factor equal to $1.25$ to inflate the local Richardson estimate into a conservative error bar half-width at each $z$.\n- Quantify the mesh resolution uncertainty as the maximum error bar half-width across all $z$ for each test case.\n\nExpress all final reported uncertainties in pcm/cm, rounded to six decimal places. Angles in all trigonometric functions must be treated in radians.\n\nTest suite specification:\n- Use the following three test cases. For each case, compute three meshes and apply the procedure above to return a single scalar: the maximum estimated two-sided error bar half-width across $z$ in pcm/cm.\n- Test case parameters are provided as $(H,\\ A,\\ p,\\ h_1,\\ h_2,\\ h_3,\\ r,\\ \\alpha,\\ \\beta,\\ \\gamma)$, where $H$ is in cm, $A$, $\\alpha$, $\\beta$, $\\gamma$ are in pcm/cm, $p$ is dimensionless, $h_k$ are in cm, and $r$ is dimensionless.\n\n- Test case $1$:\n  - $(H,\\ A,\\ p,\\ h_1,\\ h_2,\\ h_3,\\ r,\\ \\alpha,\\ \\beta,\\ \\gamma) = (400,\\ 10,\\ 2,\\ 25,\\ 12.5,\\ 6.25,\\ 2,\\ 0.8,\\ 0.3,\\ 0.1)$.\n- Test case $2$:\n  - $(H,\\ A,\\ p,\\ h_1,\\ h_2,\\ h_3,\\ r,\\ \\alpha,\\ \\beta,\\ \\gamma) = (288,\\ 8,\\ 2,\\ 24,\\ 16,\\ 10.\\overline{6},\\ 1.5,\\ 1.5,\\ 0.5,\\ 0.2)$, where $10.\\overline{6}$ denotes $32/3$ cm exactly.\n- Test case $3$:\n  - $(H,\\ A,\\ p,\\ h_1,\\ h_2,\\ h_3,\\ r,\\ \\alpha,\\ \\beta,\\ \\gamma) = (450,\\ 12,\\ 2,\\ 50,\\ 25,\\ 12.5,\\ 2,\\ 2.0,\\ 1.0,\\ 0.05)$.\n\nAlgorithmic requirements and constraints:\n- Begin from the asymptotic truncation error model of mesh-discrete observables in numerical solutions of the neutron diffusion eigenvalue problem and derive all necessary extrapolation steps from that base. Do not use or assume any formula not derivable from these fundamentals.\n- Use the finest mesh’s cell centers as the common axial coordinates for Richardson analysis. Interpolate coarser mesh fields linearly to these points.\n- Estimate a single global observed order $p_{\\text{obs}}$ for each test case using the ratio of norms of differences between successive mesh solutions over $z$ and the known refinement ratio $r$.\n- Use two-solution Richardson extrapolation based on $p_{\\text{obs}}$ at each axial point to compute local error bar half-widths and then inflate them by a factor $1.25$ to obtain conservative $95\\%$ coverage error bars.\n- Return, for each test case, a single float equal to the maximum error bar half-width over the axial domain in pcm/cm, rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3]$, where each $x_k$ is the maximum estimated uncertainty for test case $k$ in pcm/cm, rounded to six decimal places.",
            "solution": "The problem requires the quantification of mesh resolution uncertainty for a simulated control rod bank worth distribution, $W(z)$, using a three-level Richardson extrapolation framework. The process is grounded in the analysis of the asymptotic truncation error of numerical solutions to the neutron diffusion equation.\n\nThe fundamental premise of Richardson extrapolation is that the error in a numerical solution, $W_h$, obtained with a characteristic mesh spacing $h$, can be expressed as an asymptotic series in powers of $h$. For a method with a nominal order of accuracy $p$, the solution on a discrete grid can be written as:\n$$\nW_h(z) = W_{\\text{true}}(z) + C(z)h^p + \\mathcal{O}(h^{p+1})\n$$\nwhere $W_{\\text{true}}(z)$ is the exact, continuous solution, and $C(z)$ is a function, independent of $h$, that characterizes the leading-order error. The problem provides a synthetic model for this numerical solution which we must use:\n$$\nW_h(z_i) = W_{\\text{true}}(z_i) + \\alpha h_{\\text{eff}}^{p} + \\beta h_{\\text{eff}}^{p+1} + \\gamma h_{\\text{eff}}^{p} \\sin\\!\\left(\\frac{3\\pi z_i}{H}\\right)\n$$\nwhere $W_{\\text{true}}(z) = A \\sin^2(\\frac{\\pi z}{H})$, and the effective mesh spacing $h_{\\text{eff}}$ is determined for a given nominal spacing $h_k$ by finding an integer number of cells $N_k$ such that $h_{\\text{eff}, k} = H/N_k$. For the provided test cases, $H/h_k$ is always an integer, so we have $N_k=H/h_k$ and $h_{\\text{eff}, k}=h_k$.\n\nThe procedure involves three steps: estimating the observed order of convergence, performing Richardson extrapolation to estimate the error, and calculating a conservative uncertainty bound.\n\nFirst, we compute three solutions, $W_1$, $W_2$, and $W_3$, on meshes with spacings $h_1$, $h_2$, and $h_3$, respectively. The meshes are systematically refined with a constant ratio $r = h_1/h_2 = h_2/h_3$. Since the solutions are defined on different discrete sets of axial points $z_i$, they must be compared on a common grid. As stipulated, we select the cell centers of the finest mesh, $h_3$, as the common grid. The solutions from the coarser meshes, $W_1$ and $W_2$, are transferred to this fine grid using linear interpolation. Let us denote the interpolated solutions as $W_{1,\\text{interp}}$ and $W_{2,\\text{interp}}$, and the fine-grid solution as $W_3$.\n\nSecond, we estimate the global observed order of convergence, $p_{\\text{obs}}$. Assuming the higher-order terms are negligible, the differences between successive solutions are:\n$$\nW_{1,\\text{interp}}(z) - W_{2,\\text{interp}}(z) \\approx C(z)(h_1^p - h_2^p) = C(z)h_2^p(r^p - 1)\n$$\n$$\nW_{2,\\text{interp}}(z) - W_3(z) \\approx C(z)(h_2^p - h_3^p) = C(z)h_3^p(r^p - 1) = C(z)h_2^p(1 - (1/r)^p)\n$$\nTaking the ratio of the differences gives:\n$$\n\\frac{W_{1,\\text{interp}}(z) - W_{2,\\text{interp}}(z)}{W_{2,\\text{interp}}(z) - W_3(z)} \\approx \\frac{C(z)h_2^p(r^p - 1)}{C(z)h_3^p(r^p - 1)} = \\frac{h_2^p}{h_3^p} = r^p\n$$\nTo obtain a single, robust estimate for $p_{\\text{obs}}$ that is representative of the entire domain, we take the ratio of the norms of the solution differences:\n$$\n\\frac{\\Vert W_{1,\\text{interp}} - W_{2,\\text{interp}} \\Vert}{\\Vert W_{2,\\text{interp}} - W_3 \\Vert} \\approx r^{p_{\\text{obs}}}\n$$\nUsing the discrete $L_2$-norm, where for a vector $\\mathbf{v}$, $\\Vert \\mathbf{v} \\Vert_2 = \\sqrt{\\sum_i v_i^2}$, we solve for $p_{\\text{obs}}$:\n$$\np_{\\text{obs}} = \\frac{\\ln\\left(\\frac{\\Vert W_{1,\\text{interp}} - W_{2,\\text{interp}} \\Vert_2}{\\Vert W_{2,\\text{interp}} - W_3 \\Vert_2}\\right)}{\\ln(r)}\n$$\n\nThird, we use the two finest solutions, $W_{2,\\text{interp}}$ and $W_3$, along with the estimated order $p_{\\text{obs}}$, to perform a Richardson extrapolation at each point $z_j$ on the fine grid. We establish a system of two equations for the unknowns $W_{\\text{true}}(z_j)$ and $C(z_j)$:\n$$\nW_{2,\\text{interp}}(z_j) \\approx W_{\\text{true}}(z_j) + C(z_j) h_2^{p_{\\text{obs}}}\n$$\n$$\nW_3(z_j) \\approx W_{\\text{true}}(z_j) + C(z_j) h_3^{p_{\\text{obs}}} = W_{\\text{true}}(z_j) + C(z_j) (h_2/r)^{p_{\\text{obs}}}\n$$\nSolving this system for $W_{\\text{true}}(z_j)$ yields the Richardson-extrapolated solution, $W_{\\text{RE}}(z_j)$:\n$$\nW_{\\text{RE}}(z_j) = \\frac{r^{p_{\\text{obs}}} W_3(z_j) - W_{2,\\text{interp}}(z_j)}{r^{p_{\\text{obs}}} - 1}\n$$\nThis can be expressed as a correction to the finest-grid solution:\n$$\nW_{\\text{RE}}(z_j) = W_3(z_j) + \\frac{W_3(z_j) - W_{2,\\text{interp}}(z_j)}{r^{p_{\\text{obs}}} - 1}\n$$\nThe second term on the right-hand side is the leading-order error estimate for the solution $W_3(z_j)$. The local discretization error magnitude, $|\\delta_{\\text{RE}}(z_j)|$, is therefore:\n$$\n|\\delta_{\\text{RE}}(z_j)| = \\left| \\frac{W_3(z_j) - W_{2,\\text{interp}}(z_j)}{r^{p_{\\text{obs}}} - 1} \\right|\n$$\nTo form a conservative estimate of the uncertainty, following the Grid Convergence Index (GCI) methodology, this error estimate is multiplied by a safety factor, $F_S$. The problem specifies $F_S = 1.25$. The local error bar half-width, $E_{\\text{bar}}(z_j)$, is thus:\n$$\nE_{\\text{bar}}(z_j) = F_S \\times |\\delta_{\\text{RE}}(z_j)| = 1.25 \\times \\left| \\frac{W_3(z_j) - W_{2,\\text{interp}}(z_j)}{r^{p_{\\text{obs}}} - 1} \\right|\n$$\nFinally, the overall mesh resolution uncertainty for a given test case is quantified as the maximum value of this error bar half-width across the entire axial domain:\n$$\n\\text{Uncertainty} = \\max_{j} \\left( E_{\\text{bar}}(z_j) \\right)\n$$\nThis procedure is applied to each test case to yield the final numerical results.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes mesh resolution uncertainty for control rod bank worth using Richardson extrapolation.\n    \"\"\"\n\n    test_cases = [\n        # (H, A, p, h1, h2, h3, r, alpha, beta, gamma)\n        (400.0, 10.0, 2.0, 25.0, 12.5, 6.25, 2.0, 0.8, 0.3, 0.1),\n        (288.0, 8.0, 2.0, 24.0, 16.0, 32.0/3.0, 1.5, 1.5, 0.5, 0.2),\n        (450.0, 12.0, 2.0, 50.0, 25.0, 12.5, 2.0, 2.0, 1.0, 0.05),\n    ]\n\n    results = []\n    \n    # Safety factor for GCI\n    F_S = 1.25\n\n    def get_w_h_data(params, h):\n        \"\"\"\n        Generates the discrete rod worth data for a given mesh size h.\n        \"\"\"\n        H, A, p, _, _, _, _, alpha, beta, gamma = params\n        \n        # Determine the number of cells N, ensuring it's an integer.\n        # The problem statement ensures H/h is integer for all test cases.\n        N = int(round(H / h))\n        h_eff = H / N\n\n        # Generate cell center coordinates\n        z_coords = (np.arange(N) + 0.5) * h_eff\n\n        # Calculate W_true at these coordinates\n        w_true = A * np.sin(np.pi * z_coords / H)**2\n        \n        # Calculate the synthetic numerical solution W_h\n        error_term = (alpha * h_eff**p + \n                      beta * h_eff**(p + 1) + \n                      gamma * h_eff**p * np.sin(3 * np.pi * z_coords / H))\n        w_h = w_true + error_term\n        \n        return z_coords, w_h\n\n    for case in test_cases:\n        H, _, _, h1, h2, h3, r, _, _, _ = case\n\n        # Step 1: Generate solutions on three meshes\n        z1, w1 = get_w_h_data(case, h1)  # Coarse\n        z2, w2 = get_w_h_data(case, h2)  # Medium\n        z3, w3 = get_w_h_data(case, h3)  # Fine\n\n        # Step 2: Interpolate coarser solutions to the finest mesh coordinates (z3)\n        # numpy.interp performs linear interpolation\n        w1_interp = np.interp(z3, z1, w1)\n        w2_interp = np.interp(z3, z2, w2)\n        # w3 is already on the fine grid\n\n        # Step 3: Estimate a single global observed order p_obs\n        # Use L2 norm of the differences\n        diff_12 = w1_interp - w2_interp\n        diff_23 = w2_interp - w3\n        \n        norm_diff_12 = np.linalg.norm(diff_12)\n        norm_diff_23 = np.linalg.norm(diff_23)\n        \n        # If norm_diff_23 is zero, it implies perfect agreement, which is unlikely.\n        # But as a safe guard:\n        if norm_diff_23 == 0.0:\n            if norm_diff_12 == 0.0:\n                # All solutions are identical; error is zero.\n                p_obs = case[2] # Use nominal order, though it won't matter\n            else:\n                # Unstable case, but we must proceed. Let p_obs be large.\n                p_obs = 20.0\n        else:\n            ratio_of_norms = norm_diff_12 / norm_diff_23\n            # If ratio is = 0, something is wrong, e.g. non-convergence.\n            # The calculation is robust for positive ratios.\n            if ratio_of_norms = 0:\n                p_obs = case[2] # Fallback to nominal order\n            else:\n                p_obs = np.log(ratio_of_norms) / np.log(r)\n\n        # Step 4  5: Compute local error bar half-width for each point z\n        # Error estimate from Richardson extrapolation on the two finest grids\n        # Note: the difference is w3 - w2_interp in the numerator, not w2-w3\n        # This is based on the formula: RE = w3 + (w3 - w2) / (r^p - 1)\n        # The error term is the correction itself.\n        local_error_mag = np.abs((w3 - w2_interp) / (r**p_obs - 1.0))\n        \n        # Inflate with safety factor to get error bar half-width\n        error_bar_half_width = F_S * local_error_mag\n\n        # Step 6: Find the maximum error bar half-width across the domain\n        max_uncertainty = np.max(error_bar_half_width)\n        \n        # Round to six decimal places as required\n        results.append(round(max_uncertainty, 6))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}