{
    "hands_on_practices": [
        {
            "introduction": "要有效优化可燃毒物的使用，首先必须深入理解其背后的物理机制。本练习将引导你通过一个双能群扩散模型，量化分析可燃毒物（如钆）如何通过吸收热中子来“硬化”中子能谱 。通过求解本征值问题，你将亲身体验能谱变化对无限介质增殖因子 $k_{\\infty}$ 和有效增殖因子 $k_{\\mathrm{eff}}$ 的不同影响，从而揭示泄漏效应对毒物价值的关键作用。",
            "id": "4219351",
            "problem": "本问题使用一个两群中子扩散模型，分析由氧化钆可燃毒物引起的谱硬化对无限介质增殖因子和有效增殖因子的影响。任务是从包含扩散泄漏的两群中子平衡方程出发，推导由氧化钆增加的热中子吸收如何改变分群通量和增殖因子，然后使用依赖于泄漏的谱指数和分群反应率来量化无限介质增殖因子与有效增殖因子之间的差异。该分析需要通过实现一个完整、可运行的程序来完成。\n\n假设一个空间均匀的反应堆区域，用两个能群建模：群 $1$（快中子群）和群 $2$（热中子群）。中子主要在快中子群中由裂变产生，并可能在两个群之间发生散射。本分析的基础是采用均匀曲率的两群稳态扩散近似。在此近似下，每个群的平衡方程包括由吸收和迁出散射引起的移出项、从另一群迁入的散射项、由几何曲率建模的扩散泄漏项，以及按增殖因子缩放的裂变产生项。令 $k$ 表示增殖因子，其中 $k_{\\infty}$ 是在零泄漏情况下获得的无限介质增殖因子，$k_{\\mathrm{eff}}$ 是在非零泄漏情况下获得的有效增殖因子。\n\n设宏观吸收截面为 $\\,\\Sigma_{a1}\\,$ 和 $\\,\\Sigma_{a2}\\,$（单位：$\\mathrm{cm}^{-1}$），宏观散射截面为 $\\,\\Sigma_{s12}\\,$（从群 $1$ 到群 $2$）和 $\\,\\Sigma_{s21}\\,$（从群 $2$ 到群 $1$）（单位：$\\mathrm{cm}^{-1}$），扩散系数为 $\\,D_1\\,$ 和 $\\,D_2\\,$（单位：$\\mathrm{cm}$），几何曲率为 $\\,B^2\\,$（单位：$\\mathrm{cm}^{-2}$），宏观裂变产生截面为 $\\,\\nu\\Sigma_{f1}\\,$ 和 $\\,\\nu\\Sigma_{f2}\\,$（单位：$\\mathrm{cm}^{-1}$），裂变谱份额为 $\\,\\chi_1\\,$ 和 $\\,\\chi_2\\,$，且 $\\,\\chi_1 + \\chi_2 = 1\\,$。定义移出截面 $\\,\\Sigma_{r1} = \\Sigma_{a1} + \\Sigma_{s12}\\,$ 和 $\\,\\Sigma_{r2} = \\Sigma_{a2} + \\Sigma_{s21}\\,$。群通量 $\\,\\phi_1\\,$ 和 $\\,\\phi_2\\,$ 的平衡方程可以写成一个源于扩散理论的广义特征值问题的矩阵形式：\n$$\n\\begin{bmatrix}\n\\Sigma_{r1} + D_1 B^2  & -\\Sigma_{s21} \\\\\n-\\Sigma_{s12}  & \\Sigma_{r2} + D_2 B^2\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi_1 \\\\ \\phi_2\n\\end{bmatrix}\n=\n\\frac{1}{k}\n\\begin{bmatrix}\n\\chi_1 \\nu\\Sigma_{f1} & \\chi_1 \\nu\\Sigma_{f2} \\\\\n\\chi_2 \\nu\\Sigma_{f1} & \\chi_2 \\nu\\Sigma_{f2}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi_1 \\\\ \\phi_2\n\\end{bmatrix}.\n$$\n该表达式体现了基本定律：稳态中子平衡、由 $\\,D_g B^2\\,$ 项表示的扩散泄漏，以及带有谱份额的裂变产生。\n\n为模拟氧化钆引起的谱硬化，设可燃毒物装量由一个无量纲标量 $\\,p \\ge 0\\,$ 参数化。该毒物主要增加热中子群的吸收。对宏观吸收截面使用以下关于 $\\,p\\,$ 的线性化模型：\n$$\n\\Sigma_{a1}(p) = \\Sigma_{a1}^{(0)} + \\beta\\,p, \\qquad \\Sigma_{a2}(p) = \\Sigma_{a2}^{(0)} + \\alpha\\,p,\n$$\n其中 $\\,\\alpha\\,$ 和 $\\,\\beta\\,$ 为常数，且 $\\,\\alpha \\gg \\beta\\,$，这反映了氧化钆主要吸收热中子。所有其他参数都与 $\\,p\\,$ 无关。谱指数定义为快中子通量与热中子通量之比，\n$$\nS(B^2) = \\frac{\\phi_1(B^2)}{\\phi_2(B^2)},\n$$\n而无限介质谱指数为 $\\,S(0)\\,$。通过 $\\,S(B^2)\\,$ 随 $\\,p\\,$ 和 $\\,B^2\\,$ 的增加情况来量化谱硬化。此外，通过计算分群归一化吸收份额和裂变份额来量化反应率的再分配：\n$$\nf^{(a)}_1 = \\frac{\\Sigma_{a1}\\,\\phi_1}{\\Sigma_{a1}\\,\\phi_1 + \\Sigma_{a2}\\,\\phi_2}, \\quad\nf^{(a)}_2 = \\frac{\\Sigma_{a2}\\,\\phi_2}{\\Sigma_{a1}\\,\\phi_1 + \\Sigma_{a2}\\,\\phi_2},\n$$\n$$\nf^{(f)}_1 = \\frac{\\nu\\Sigma_{f1}\\,\\phi_1}{\\nu\\Sigma_{f1}\\,\\phi_1 + \\nu\\Sigma_{f2}\\,\\phi_2}, \\quad\nf^{(f)}_2 = \\frac{\\nu\\Sigma_{f2}\\,\\phi_2}{\\nu\\Sigma_{f1}\\,\\phi_1 + \\nu\\Sigma_{f2}\\,\\phi_2}.\n$$\n所有输出均为无量纲数。由于通量归一化会抵消绝对单位，因此无需进行物理单位转换或报告；仅报告比值和增殖因子。\n\n您必须实现一个程序，对于下面列出的每个测试用例，该程序需要构建矩阵，从零泄漏情况 $\\,B^2 = 0\\,$ 计算 $\\,k_{\\infty}\\,$，从指定的非零 $\\,B^2\\,$ 计算 $\\,k_{\\mathrm{eff}}\\,$，提取相应的主导特征向量以形成谱指数 $\\,S(0)\\,$ 和 $\\,S(B^2)\\,$，计算差异 $\\,\\Delta k = k_{\\infty} - k_{\\mathrm{eff}}\\,$，并评估泄漏情况下的归一化分群吸收和裂变份额。为每对矩阵选择主（最大实部）特征值及其相关的右特征向量。为了数值稳定性，请丢弃由浮点计算产生的任何可忽略的虚部。\n\n使用以下科学上合理的参数值，为清晰起见，在模型说明中给出了其物理单位，但输出保持无量纲：\n- 基础宏观吸收截面：$\\,\\Sigma_{a1}^{(0)} = 0.010\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{a2}^{(0)} = 0.080\\,\\mathrm{cm}^{-1}\\,$。\n- 宏观散射截面：$\\,\\Sigma_{s12} = 0.200\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{s21} = 0.005\\,\\mathrm{cm}^{-1}\\,$。\n- 扩散系数：$\\,D_1 = 1.300\\,\\mathrm{cm}\\,$, $\\,D_2 = 0.300\\,\\mathrm{cm}\\,$。\n- 宏观裂变产生截面：$\\,\\nu\\Sigma_{f1} = 0.020\\,\\mathrm{cm}^{-1}\\,$, $\\,\\nu\\Sigma_{f2} = 0.100\\,\\mathrm{cm}^{-1}\\,$。\n- 裂变谱份额：$\\,\\chi_1 = 1.000\\,$, $\\,\\chi_2 = 0.000\\,$。\n- 氧化钆吸收缩放系数：$\\,\\alpha = 0.100\\,\\mathrm{cm}^{-1}\\,$, $\\,\\beta = 0.005\\,\\mathrm{cm}^{-1}\\,$。\n\n毒物装量和泄漏情况的测试套件：\n- 情况 $1$：$\\,p = 0.000\\,$, $\\,B^2 = 0.000000\\,\\mathrm{cm}^{-2}\\,$。\n- 情况 $2$：$\\,p = 0.500\\,$, $\\,B^2 = 0.000000\\,\\mathrm{cm}^{-2}\\,$。\n- 情况 $3$：$\\,p = 0.500\\,$, $\\,B^2 = 0.000500\\,\\mathrm{cm}^{-2}\\,$。\n- 情况 $4$：$\\,p = 1.000\\,$, $\\,B^2 = 0.001000\\,\\mathrm{cm}^{-2}\\,$。\n- 情况 $5$：$\\,p = 0.000\\,$, $\\,B^2 = 0.001000\\,\\mathrm{cm}^{-2}\\,$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，每个测试用例的结果本身是按顺序排列的九个浮点数的列表\n$$\n\\big[k_{\\infty},\\,k_{\\mathrm{eff}},\\,S(0),\\,S(B^2),\\,\\Delta k,\\,f^{(a)}_1,\\,f^{(a)}_2,\\,f^{(f)}_1,\\,f^{(f)}_2\\big],\n$$\n，四舍五入到六位小数。例如，最终打印的行必须如下所示\n$$\n\\texttt{[[0.950000,0.900000,1.200000,1.300000,0.050000,0.400000,0.600000,0.150000,0.850000],[\\dots]]}.\n$$",
            "solution": "该问题已经过验证，并被认定是有效的。它在科学上植根于核反应堆物理原理，特别是两群中子扩散理论。它被恰当地表述为一个广义特征值问题，并提供了所有必要的数据和定义，以确保一个唯一且有意义的解。其语言是客观的，参数在物理上是合理的。\n\n问题的核心在于分析稳态两群中子扩散方程，该方程可以表示为一个广义特征值问题。其控制方程为：\n$$\n\\begin{bmatrix}\n\\Sigma_{r1} + D_1 B^2  & -\\Sigma_{s21} \\\\\n-\\Sigma_{s12}  & \\Sigma_{r2} + D_2 B^2\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi_1 \\\\\n\\phi_2\n\\end{bmatrix}\n=\n\\frac{1}{k}\n\\begin{bmatrix}\n\\chi_1 \\nu\\Sigma_{f1} & \\chi_1 \\nu\\Sigma_{f2} \\\\\n\\chi_2 \\nu\\Sigma_{f1} & \\chi_2 \\nu\\Sigma_{f2}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi_1 \\\\\n\\phi_2\n\\end{bmatrix}\n$$\n该方程平衡了左侧的中子移出（吸收、迁出散射和泄漏）与右侧的中子产生（裂变）。变量 $k$ 是增殖因子，$\\phi_1$ 和 $\\phi_2$ 分别是快中子和热中子通量，$B^2$ 是代表中子泄漏的几何曲率。\n\n令移出/泄漏矩阵为 $M$，裂变产生矩阵为 $F$。方程则为 $M\\mathbf{\\phi} = \\frac{1}{k} F\\mathbf{\\phi}$。为了计算方便，更常将其重排为广义特征值求解器的标准形式：\n$$\nF\\mathbf{\\phi} = k M\\mathbf{\\phi}\n$$\n其中 $\\mathbf{\\phi} = [\\phi_1, \\phi_2]^T$ 是通量特征向量，$k$ 是特征值。物理上有意义的解对应于最大、实数、正的特征值，即所谓的主导特征值，它代表有效增殖因子 $k_{\\mathrm{eff}}$。相应的特征向量具有正分量。\n\n矩阵 $F$ 和 $M$ 的构建如下。裂变矩阵 $F$ 由下式给出：\n$$\nF =\n\\begin{bmatrix}\n\\chi_1 \\nu\\Sigma_{f1} & \\chi_1 \\nu\\Sigma_{f2} \\\\\n\\chi_2 \\nu\\Sigma_{f1} & \\chi_2 \\nu\\Sigma_{f2}\n\\end{bmatrix}\n$$\n使用所提供的参数 $\\chi_1 = 1.0$，$\\chi_2 = 0.0$，$\\nu\\Sigma_{f1} = 0.020\\,\\mathrm{cm}^{-1}$ 和 $\\nu\\Sigma_{f2} = 0.100\\,\\mathrm{cm}^{-1}$，裂变矩阵 $F$ 对所有测试用例都是恒定的：\n$$\nF =\n\\begin{bmatrix}\n0.020 & 0.100 \\\\\n0 & 0\n\\end{bmatrix}\n$$\n移出/泄漏矩阵 $M$ 取决于可燃毒物装量 $p$ 和几何曲率 $B^2$：\n$$\nM(p, B^2) =\n\\begin{bmatrix}\n\\Sigma_{r1}(p) + D_1 B^2 & -\\Sigma_{s21} \\\\\n-\\Sigma_{s12} & \\Sigma_{r2}(p) + D_2 B^2\n\\end{bmatrix}\n$$\n矩阵 $M$ 的分量由问题的参数确定：\n- 吸收截面，依赖于毒物装量 $p$：\n  $$\n  \\Sigma_{a1}(p) = \\Sigma_{a1}^{(0)} + \\beta\\,p = 0.010 + 0.005\\,p\n  $$\n  $$\n  \\Sigma_{a2}(p) = \\Sigma_{a2}^{(0)} + \\alpha\\,p = 0.080 + 0.100\\,p\n  $$\n- 移出截面，包括散射：\n  $$\n  \\Sigma_{r1}(p) = \\Sigma_{a1}(p) + \\Sigma_{s12} = (0.010 + 0.005\\,p) + 0.200 = 0.210 + 0.005\\,p\n  $$\n  $$\n  \\Sigma_{r2}(p) = \\Sigma_{a2}(p) + \\Sigma_{s21} = (0.080 + 0.100\\,p) + 0.005 = 0.085 + 0.100\\,p\n  $$\n- 其他固定参数为 $D_1 = 1.300\\,\\mathrm{cm}$, $D_2 = 0.300\\,\\mathrm{cm}$, $\\Sigma_{s12} = 0.200\\,\\mathrm{cm}^{-1}$ 和 $\\Sigma_{s21} = 0.005\\,\\mathrm{cm}^{-1}$。\n\n对于由一对 $(p^*, B^{2*})$ 定义的每个测试用例，执行以下计算程序：\n\n1.  **无限介质计算**：为求得 $k_{\\infty}$ 和 $S(0)$，我们分析具有指定毒物装量 $p^*$ 但零泄漏（$B^2 = 0$）的系统。\n    -   构建矩阵 $M(p^*, 0)$。\n    -   求解广义特征值问题 $F\\mathbf{\\phi} = k M(p^*, 0)\\mathbf{\\phi}$。\n    -   最大实特征值为 $k_{\\infty}$。\n    -   相应的特征向量 $\\mathbf{\\phi}_{\\infty} = [\\phi_{1,\\infty}, \\phi_{2,\\infty}]^T$ 用于计算无限介质谱指数 $S(0) = \\phi_{1,\\infty} / \\phi_{2,\\infty}$。\n\n2.  **有效介质计算**：为求得 $k_{\\mathrm{eff}}$ 和 $S(B^2)$，我们分析具有指定毒物装量 $p^*$ 和泄漏 $B^{2*}$ 的系统。\n    -   构建矩阵 $M(p^*, B^{2*})$。\n    -   求解广义特征值问题 $F\\mathbf{\\phi} = k M(p^*, B^{2*})\\mathbf{\\phi}$。\n    -   最大实特征值为 $k_{\\mathrm{eff}}$。\n    -   相应的特征向量 $\\mathbf{\\phi}_{\\mathrm{eff}} = [\\phi_{1,\\mathrm{eff}}, \\phi_{2,\\mathrm{eff}}]^T$ 用于计算有效谱指数 $S(B^{2*}) = \\phi_{1,\\mathrm{eff}} / \\phi_{2,\\mathrm{eff}}$。\n\n3.  **增殖因子的差异**：泄漏对反应性的影响通过 $\\Delta k = k_{\\infty} - k_{\\mathrm{eff}}$ 来量化。\n\n4.  **反应率份额**：对于泄漏情况，使用有效通量特征向量 $\\mathbf{\\phi}_{\\mathrm{eff}}$（或等效地，谱指数 $S(B^{2*})$）计算能群间的反应分布。\n    -   归一化吸收份额：\n        $$\n        f^{(a)}_1 = \\frac{\\Sigma_{a1}(p^*)\\,\\phi_{1,\\mathrm{eff}}}{\\Sigma_{a1}(p^*)\\,\\phi_{1,\\mathrm{eff}} + \\Sigma_{a2}(p^*)\\,\\phi_{2,\\mathrm{eff}}} = \\frac{\\Sigma_{a1}(p^*)\\,S(B^{2*})}{\\Sigma_{a1}(p^*)\\,S(B^{2*}) + \\Sigma_{a2}(p^*)}\n        $$\n        $$\n        f^{(a)}_2 = 1 - f^{(a)}_1\n        $$\n    -   归一化裂变份额：\n        $$\n        f^{(f)}_1 = \\frac{\\nu\\Sigma_{f1}\\,\\phi_{1,\\mathrm{eff}}}{\\nu\\Sigma_{f1}\\,\\phi_{1,\\mathrm{eff}} + \\nu\\Sigma_{f2}\\,\\phi_{2,\\mathrm{eff}}} = \\frac{\\nu\\Sigma_{f1}\\,S(B^{2*})}{\\nu\\Sigma_{f1}\\,S(B^{2*}) + \\nu\\Sigma_{f2}}\n        $$\n        $$\n        f^{(f)}_2 = 1 - f^{(f)}_1\n        $$\n此程序应用于所提供的五个测试用例中的每一个。广义特征值问题的数值解是使用标准线性代数库获得的。由于物理量（特征值和特征向量）在此问题中保证为实数，因此将丢弃由浮点运算产生的任何可忽略的虚部分量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eig\n\ndef solve():\n    \"\"\"\n    Solves the two-group neutron diffusion eigenvalue problem for a set of test cases.\n    \"\"\"\n\n    # Define base parameter values from the problem statement.\n    sigma_a1_0 = 0.010\n    sigma_a2_0 = 0.080\n    sigma_s12 = 0.200\n    sigma_s21 = 0.005\n    D1 = 1.300\n    D2 = 0.300\n    nu_sigma_f1 = 0.020\n    nu_sigma_f2 = 0.100\n    chi1 = 1.0\n    chi2 = 0.0\n    alpha = 0.100\n    beta = 0.005\n\n    # Test suite of poison loading and leakage cases.\n    test_cases = [\n        # (p, B^2)\n        (0.000, 0.000000),  # Case 1\n        (0.500, 0.000000),  # Case 2\n        (0.500, 0.000500),  # Case 3\n        (1.000, 0.001000),  # Case 4\n        (0.000, 0.001000),  # Case 5\n    ]\n\n    # Construct the constant Fission matrix F\n    F = np.array([\n        [chi1 * nu_sigma_f1, chi1 * nu_sigma_f2],\n        [chi2 * nu_sigma_f1, chi2 * nu_sigma_f2]\n    ])\n\n    def solve_diffusion_eigenproblem(p, B2):\n        \"\"\"\n        Constructs matrices and solves the generalized eigenvalue problem for a given p and B^2.\n        \n        Args:\n            p (float): Dimensionless poison loading factor.\n            B2 (float): Geometric buckling (cm^-2).\n        \n        Returns:\n            tuple: A tuple containing:\n                - k (float): Dominant eigenvalue (multiplication factor).\n                - S (float): Spectral index (phi_1 / phi_2).\n                - sigma_a1 (float): Group 1 macroscopic absorption cross section.\n                - sigma_a2 (float): Group 2 macroscopic absorption cross section.\n        \"\"\"\n        # Calculate poison-dependent absorption cross sections\n        sigma_a1 = sigma_a1_0 + beta * p\n        sigma_a2 = sigma_a2_0 + alpha * p\n\n        # Calculate removal cross sections\n        sigma_r1 = sigma_a1 + sigma_s12\n        sigma_r2 = sigma_a2 + sigma_s21\n\n        # Construct the Removal/Leakage matrix M\n        M = np.array([\n            [sigma_r1 + D1 * B2, -sigma_s21],\n            [-sigma_s12,        sigma_r2 + D2 * B2]\n        ])\n\n        # Solve the generalized eigenvalue problem: F*phi = k*M*phi\n        eigenvalues, eigenvectors = eig(F, b=M)\n\n        # The physical solution is the largest real eigenvalue and its corresponding eigenvector.\n        # Numerical results might have negligible imaginary parts.\n        eigenvalues = np.real(eigenvalues)\n        eigenvectors = np.real(eigenvectors)\n\n        # Find the index of the dominant (largest) eigenvalue\n        dominant_idx = np.argmax(eigenvalues)\n        \n        k = eigenvalues[dominant_idx]\n        flux_vector = eigenvectors[:, dominant_idx]\n\n        # Ensure flux is positive (a convention)\n        if flux_vector[1]  0:\n            flux_vector = -flux_vector\n        \n        # Calculate spectral index S = phi_1 / phi_2\n        # Handle potential division by zero if phi_2 is numerically zero, though unlikely here.\n        if abs(flux_vector[1])  1e-15:\n            # Physically, thermal flux will not be zero. This is a safeguard.\n            S = np.inf\n        else:\n            S = flux_vector[0] / flux_vector[1]\n\n        return k, S, sigma_a1, sigma_a2\n\n    results = []\n    for p_case, B2_case in test_cases:\n        # 1. Calculate for infinite medium (k_inf, S_0)\n        k_inf, S_0, _, _ = solve_diffusion_eigenproblem(p=p_case, B2=0.0)\n\n        # 2. Calculate for effective medium (k_eff, S_B2)\n        k_eff, S_B2, sigma_a1_eff, sigma_a2_eff = solve_diffusion_eigenproblem(p=p_case, B2=B2_case)\n        \n        # 3. Calculate delta_k\n        delta_k = k_inf - k_eff\n        \n        # 4. Calculate reaction rate fractions for the leakage case\n        # Note: Denominators are never zero if fluxes are positive.\n        # The calculation can be done using the spectral index S_B2.\n        \n        # Absorption fractions\n        num_fa1 = sigma_a1_eff * S_B2\n        den_fa = num_fa1 + sigma_a2_eff\n        f_a1 = num_fa1 / den_fa if den_fa != 0 else 0\n        f_a2 = 1.0 - f_a1\n\n        # Fission fractions\n        num_ff1 = nu_sigma_f1 * S_B2\n        den_ff = num_ff1 + nu_sigma_f2\n        f_f1 = num_ff1 / den_ff if den_ff != 0 else 0\n        f_f2 = 1.0 - f_f1\n\n        # Assemble the 9-tuple result for the current case\n        case_result = [\n            k_inf, k_eff, S_0, S_B2, delta_k,\n            f_a1, f_a2, f_f1, f_f2\n        ]\n        results.append(case_result)\n\n    # Format the final output string\n    output_str = \"[\"\n    for i, case_res in enumerate(results):\n        formatted_res = [f\"{val:.6f}\" for val in case_res]\n        output_str += f\"[{','.join(formatted_res)}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n        \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本物理原理后，下一步是将其应用于实际的燃料设计问题。本练习模拟了在燃料组件内移动可燃毒物棒的常见优化任务，要求你评估这种重新布置对组件反应性 $k_{\\infty}$ 和功率峰化因子的影响 。通过应用“冻结通量”这一微扰理论的简化方法，你将学会如何在设计初期快速评估不同装载方案的优劣，这是优化工作流程中的一个核心技能。",
            "id": "4219374",
            "problem": "给定一个简化的、但在科学上忠实的、关于核反应堆堆芯中方形燃料组件的双能群无限栅格模型。目标是使用通过栅格计算得到的宏观常数和给定的通量分布图，量化将两根可燃毒物（BP）棒从内部位置移动到角落位置对组件无限增殖因子和燃料棒功率峰值因子产生的影响。您必须实现一个程序，为指定的测试用例集计算这些变化，并打印单行聚合输出。\n\n基本原理是无限介质中的稳态中子平衡，用双能群近似表示。假设方形组件具有一个 $N \\times N$ 的燃料棒网格，通过整数坐标 $(i,j)$ 索引，其中 $i,j \\in \\{0,1,\\dots,N-1\\}$。对于每个燃料棒 $(i,j)$ 和每个能群 $g \\in \\{1,2\\}$，标量通量表示为 $\\phi_g(i,j)$，分配给该燃料棒的材料 $m(i,j)$ 的宏观吸收和产生参数分别表示为 $\\Sigma_{a,g}(m)$ 和 $\\nu\\Sigma_{f,g}(m)$。所有宏观截面的单位均为 $\\mathrm{cm}^{-1}$。\n\n我们从第一性原理将无限增殖因子 $k_{\\infty}$ 定义为无限介质中总中子产生率与总中子吸收率之比：\n$$\nk_{\\infty} \\equiv \\frac{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j)}{\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\sum_{g=1}^{2} \\Sigma_{a,g}(m(i,j)) \\, \\phi_g(i,j)}.\n$$\n我们考虑对小的重新布置采用“冻结通量”近似：通量分布图 $\\{\\phi_g(i,j)\\}$ 取自基准构型（BP棒位于内部位置）的参考栅格计算，并在评估因棒移动引起的反应率变化时作为权重重复使用。当材料扰动不大且泄漏可忽略不计时，这对应于与微扰理论一致的一阶计算。\n\n对于燃料棒功率峰值，我们采用标准的栅格计算近似方法，即燃料棒功率与裂变源密度成正比，而裂变源密度又与 $\\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j)$ 成正比。组件的燃料棒功率峰值因子 $PF$ 定义为：\n$$\nPF \\equiv \\frac{\\max_{i,j} \\left( \\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j) \\right)}{\\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1}\\left( \\sum_{g=1}^{2} \\nu\\Sigma_{f,g}(m(i,j)) \\, \\phi_g(i,j) \\right)}.\n$$\n\n您的程序必须：\n- 构建基准材料分布图 $m_{\\mathrm{base}}(i,j)$，其中两根BP棒位于指定的内部坐标，所有其他棒均为燃料棒。\n- 构建移动后材料分布图 $m_{\\mathrm{moved}}(i,j)$，将那两根BP棒移动到指定的角落坐标，并将原来的内部位置转换为燃料棒。\n- 使用提供的参数化形式生成双能群通量分布图 $\\phi_1(i,j)$ 和 $\\phi_2(i,j)$，该形式模拟通过栅格计算得到的通量形状，并对每个能群进行归一化，使得对于 $g \\in \\{1,2\\}$，$\\sum_{i,j}\\phi_g(i,j)=1$。\n- 在冻结通量近似下，计算基准和移动后分布图的 $k_{\\infty}$，并报告 $\\Delta k_{\\infty} \\equiv k_{\\infty}^{\\mathrm{moved}} - k_{\\infty}^{\\mathrm{base}}$。\n- 计算基准和移动后分布图的 $PF$，并报告 $\\Delta PF \\equiv PF^{\\mathrm{moved}} - PF^{\\mathrm{base}}$。\n\n通量分布图生成：对于每个能群 $g$，设 $\\gamma_g$ 是一个非负的形状参数。对于燃料棒 $(i,j)$，定义其相对于组件中心的径向指数平方为：\n$$\nr^2(i,j) \\equiv \\left(i - \\frac{N-1}{2}\\right)^2 + \\left(j - \\frac{N-1}{2}\\right)^2.\n$$\n定义原始通量为：\n$$\n\\phi^{\\mathrm{raw}}_g(i,j) \\equiv \\max\\!\\left(\\varepsilon, \\, 1 - \\gamma_g \\, r^2(i,j)\\right),\n$$\n其中 $\\varepsilon = 10^{-8}$，然后进行归一化以获得 $\\phi_g(i,j) \\equiv \\phi^{\\mathrm{raw}}_g(i,j) \\big/ \\left( \\sum_{p,q} \\phi^{\\mathrm{raw}}_g(p,q)\\right)$，确保每个能群的 $\\sum_{i,j}\\phi_g(i,j)=1$。\n\n材料：燃料棒的宏观参数为 $\\Sigma_{a,1}(\\mathrm{fuel})$、$\\Sigma_{a,2}(\\mathrm{fuel})$、$\\nu\\Sigma_{f,1}(\\mathrm{fuel})$ 和 $\\nu\\Sigma_{f,2}(\\mathrm{fuel})$。可燃毒物（BP）棒的参数为 $\\Sigma_{a,1}(\\mathrm{BP})$、$\\Sigma_{a,2}(\\mathrm{BP})$，并且对于 $g \\in \\{1,2\\}$，$\\nu\\Sigma_{f,g}(\\mathrm{BP}) = 0$，以表示其为非裂变吸收体。\n\n测试用例和参数：\n- 案例1（理想情况）：\n  - $N = 5$。\n  - 内部BP棒位于 $(2,2)$ 和 $(2,3)$；移动到角落 $(0,0)$ 和 $(0,4)$。\n  - 通量形状参数：$\\gamma_1 = 0.02$，$\\gamma_2 = 0.06$。\n  - 燃料：$\\Sigma_{a,1}(\\mathrm{fuel}) = 0.02$，$\\Sigma_{a,2}(\\mathrm{fuel}) = 0.08$，$\\nu\\Sigma_{f,1}(\\mathrm{fuel}) = 0.005$，$\\nu\\Sigma_{f,2}(\\mathrm{fuel}) = 0.12$。\n  - BP：$\\Sigma_{a,1}(\\mathrm{BP}) = 0.03$，$\\Sigma_{a,2}(\\mathrm{BP}) = 0.20$，$\\nu\\Sigma_{f,1}(\\mathrm{BP}) = 0.0$，$\\nu\\Sigma_{f,2}(\\mathrm{BP}) = 0.0$。\n- 案例2（边界条件：均匀通量）：\n  - $N = 5$。\n  - 内部BP棒位于 $(2,2)$ 和 $(1,3)$；移动到角落 $(0,0)$ 和 $(4,4)$。\n  - 通量形状参数：$\\gamma_1 = 0.0$，$\\gamma_2 = 0.0$。\n  - 燃料和BP的宏观参数与案例1相同。\n- 案例3（BP中热中子吸收更强，组件更大）：\n  - $N = 7$。\n  - 内部BP棒位于 $(3,3)$ 和 $(3,4)$；移动到角落 $(0,6)$ 和 $(6,0)$。\n  - 通量形状参数：$\\gamma_1 = 0.01$，$\\gamma_2 = 0.04$。\n  - 燃料：$\\Sigma_{a,1}(\\mathrm{fuel}) = 0.025$，$\\Sigma_{a,2}(\\mathrm{fuel}) = 0.09$，$\\nu\\Sigma_{f,1}(\\mathrm{fuel}) = 0.004$，$\\nu\\Sigma_{f,2}(\\mathrm{fuel}) = 0.11$。\n  - BP：$\\Sigma_{a,1}(\\mathrm{BP}) = 0.035$，$\\Sigma_{a,2}(\\mathrm{BP}) = 0.30$，$\\nu\\Sigma_{f,1}(\\mathrm{BP}) = 0.0$，$\\nu\\Sigma_{f,2}(\\mathrm{BP}) = 0.0$。\n\n计算要求：\n- 使用提供的参数化通量模型，并归一化每个能群的通量，以满足对于 $g \\in \\{1,2\\}$，$\\sum_{i,j}\\phi_g(i,j)=1$。\n- 如上定义，计算基准和移动后构型的 $k_{\\infty}$ 和 $PF$。\n- 报告每个案例的 $\\Delta k_{\\infty}$ 和 $\\Delta PF$。这两个量都是无量纲的，并且必须以小数值表示。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\Delta k_{\\infty}^{(1)}, \\Delta PF^{(1)}, \\Delta k_{\\infty}^{(2)}, \\Delta PF^{(2)}, \\Delta k_{\\infty}^{(3)}, \\Delta PF^{(3)}]$，其中上标表示案例编号。不应打印任何其他文本。",
            "solution": "该问题要求在一个简化的双能群核燃料组件模型中，量化无限增殖因子 $k_{\\infty}$ 和燃料棒功率峰值因子 $PF$ 的变化。这些变化是由将两根可燃毒物（BP）棒从内部位置移动到角落位置引起的。该分析在“冻结通量近似”下进行，这是一种标准的微扰方法，其中假设中子通量分布不因材料微扰而改变。\n\n解决方案是为每个提供的测试案例遵循一个结构化的、分步的计算过程。\n\n### 1. 通量分布图的生成\n\n组件内的中子通量分布被建模为两个能群，一个快中子能群（$g=1$）和一个热中子能群（$g=2$）。对于一个 $N \\times N$ 的组件网格，其燃料棒坐标为 $(i,j)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$，通量形状由参数化定义。\n\n首先，计算每个燃料棒与组件几何中心的径向距离的平方。中心位于坐标 $(\\frac{N-1}{2}, \\frac{N-1}{2})$。径向指数平方为：\n$$\nr^2(i,j) = \\left(i - \\frac{N-1}{2}\\right)^2 + \\left(j - \\frac{N-1}{2}\\right)^2\n$$\n接下来，使用由形状参数 $\\gamma_g$ 控制的抛物线凹陷模型，为每个能群 $g$ 生成一个原始（未归一化）的通量分布图：\n$$\n\\phi^{\\mathrm{raw}}_g(i,j) = \\max\\!\\left(\\varepsilon, \\, 1 - \\gamma_g \\, r^2(i,j)\\right)\n$$\n其中 $\\varepsilon = 10^{-8}$ 是一个小的正常数，以确保通量严格为正。这种形状反映了自屏效应，即燃料组件中心的通量通常较低。$\\gamma_g = 0$ 的值会导致空间上均匀的通量。\n\n最后，对每个原始通量分布图进行归一化，使得一个能群中所有燃料棒的通量之和等于1。这对于它们在反应率计算中作为权重函数至关重要。归一化后的通量 $\\phi_g(i,j)$ 为：\n$$\n\\phi_g(i,j) = \\frac{\\phi^{\\mathrm{raw}}_g(i,j)}{\\sum_{p=0}^{N-1}\\sum_{q=0}^{N-1} \\phi^{\\mathrm{raw}}_g(p,q)}\n$$\n这个过程产生两个 $N \\times N$ 矩阵，$\\phi_1$ 和 $\\phi_2$，分别代表归一化的快中子和热中子通量分布。关键是，在冻结通量近似下，这些基于基准构型参数计算出的通量分布图将用于基准构型和移动后构型的计算。\n\n### 2. 材料与截面映射\n\n考虑两种材料构型：“基准”构型和“移动后”构型。在基准构型中，两根BP棒位于指定的内部位置，所有其他棒都是燃料棒。在移动后构型中，这些BP棒被重新安置到角落位置，它们原来的内部位置被燃料棒填充。\n\n对于每种构型，我们构建所有相关宏观截面的 $N \\times N$ 分布图：$\\Sigma_{a,1}(\\mathbf{r})$、$\\Sigma_{a,2}(\\mathbf{r})$、$\\nu\\Sigma_{f,1}(\\mathbf{r})$ 和 $\\nu\\Sigma_{f,2}(\\mathbf{r})$，其中 $\\mathbf{r}$ 表示燃料棒位置 $(i,j)$。截面分布图的每个元素 $(i,j)$ 都被赋予与该位置材料（燃料或BP）对应的值。例如，能群1吸收截面 $\\Sigma_{a,1}(\\mathbf{r})$ 的分布图在燃料棒位置将包含 $\\Sigma_{a,1}(\\mathrm{fuel})$，在BP棒位置将包含 $\\Sigma_{a,1}(\\mathrm{BP})$。\n\n### 3. 无限增殖因子（$k_{\\infty}$）的计算\n\n无限增殖因子 $k_{\\infty}$ 是整个组件中总中子产生率与总中子吸收率之比。使用生成的通量和截面分布图，这些率被计算为所有燃料棒和两个能群上的总和。\n\n总产生率 $P$ 为：\n$$\nP = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\nu\\Sigma_{f,1}(i,j) \\, \\phi_1(i,j) + \\nu\\Sigma_{f,2}(i,j) \\, \\phi_2(i,j) \\right)\n$$\n总吸收率 $A$ 为：\n$$\nA = \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left( \\Sigma_{a,1}(i,j) \\, \\phi_1(i,j) + \\Sigma_{a,2}(i,j) \\, \\phi_2(i,j) \\right)\n$$\n由此，我们计算 $k_{\\infty}$：\n$$\nk_{\\infty} = \\frac{P}{A}\n$$\n此计算对基准构型（$k_{\\infty}^{\\mathrm{base}}$）和移动后构型（$k_{\\infty}^{\\mathrm{moved}}$）都进行，使用各自的截面分布图，但使用相同的冻结通量分布图。\n\n### 4. 燃料棒功率峰值因子（$PF$）的计算\n\n燃料棒功率峰值因子 $PF$ 衡量负载最重的燃料棒功率相对于平均燃料棒功率的倍数。在此模型中，燃料棒功率与裂变源密度 $S(i,j)$ 成正比。\n\n首先，我们计算棒状裂变源密度分布图：\n$$\nS(i,j) = \\nu\\Sigma_{f,1}(i,j) \\, \\phi_1(i,j) + \\nu\\Sigma_{f,2}(i,j) \\, \\phi_2(i,j)\n$$\n最大燃料棒功率是此分布图中的最大值：\n$$\nS_{\\max} = \\max_{i,j} S(i,j)\n$$\n平均燃料棒功率是总产生率 $P$ 除以燃料棒数量 $N^2$：\n$$\nS_{\\mathrm{avg}} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} S(i,j) = \\frac{P}{N^2}\n$$\n燃料棒功率峰值因子是最大值与平均值之比：\n$$\nPF = \\frac{S_{\\max}}{S_{\\mathrm{avg}}}\n$$\n与 $k_{\\infty}$ 类似，我们为两种构型计算 $PF^{\\mathrm{base}}$ 和 $PF^{\\mathrm{moved}}$。\n\n### 5. 最终输出计算\n\n最终要求的输出是移动后构型与基准构型之间这些参数的差异：\n$$\n\\Delta k_{\\infty} = k_{\\infty}^{\\mathrm{moved}} - k_{\\infty}^{\\mathrm{base}}\n$$\n$$\n\\Delta PF = PF^{\\mathrm{moved}} - PF^{\\mathrm{base}}\n$$\n对指定的三个测试案例中的每一个重复整个过程，并将得到的六个值汇总成最终的输出格式。\n将强吸收性、非裂变的BP棒从高通量内部区域移动到较低通量的角落区域，预计会增加反应性（$\\Delta k_{\\infty}$ 为正），因为在中子重要性最高的区域发生的吸收减少了。这一移动也倾向于使功率分布扁平化，因为高功率的中心棒被燃料棒取代，但 $PF$ 的变化可能很复杂，取决于通量形状和所涉及的具体位置。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear fuel assembly problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"N\": 5,\n            \"bp_base_locs\": [(2, 2), (2, 3)],\n            \"bp_moved_locs\": [(0, 0), (0, 4)],\n            \"gamma1\": 0.02, \"gamma2\": 0.06,\n            \"fuel_props\": {\"Sa1\": 0.02, \"Sa2\": 0.08, \"nuSf1\": 0.005, \"nuSf2\": 0.12},\n            \"bp_props\": {\"Sa1\": 0.03, \"Sa2\": 0.20, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n        # Case 2 (boundary condition: uniform flux)\n        {\n            \"N\": 5,\n            \"bp_base_locs\": [(2, 2), (1, 3)],\n            \"bp_moved_locs\": [(0, 0), (4, 4)],\n            \"gamma1\": 0.0, \"gamma2\": 0.0,\n            \"fuel_props\": {\"Sa1\": 0.02, \"Sa2\": 0.08, \"nuSf1\": 0.005, \"nuSf2\": 0.12},\n            \"bp_props\": {\"Sa1\": 0.03, \"Sa2\": 0.20, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n        # Case 3 (stronger thermal absorption in BP, larger assembly)\n        {\n            \"N\": 7,\n            \"bp_base_locs\": [(3, 3), (3, 4)],\n            \"bp_moved_locs\": [(0, 6), (6, 0)],\n            \"gamma1\": 0.01, \"gamma2\": 0.04,\n            \"fuel_props\": {\"Sa1\": 0.025, \"Sa2\": 0.09, \"nuSf1\": 0.004, \"nuSf2\": 0.11},\n            \"bp_props\": {\"Sa1\": 0.035, \"Sa2\": 0.30, \"nuSf1\": 0.0, \"nuSf2\": 0.0},\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Step 1: Generate frozen flux maps based on baseline parameters\n        phi1_map, phi2_map = generate_flux_maps(N, case[\"gamma1\"], case[\"gamma2\"])\n\n        # Step 2: Calculate metrics for baseline configuration\n        k_inf_base, pf_base = calculate_metrics(\n            N, case[\"bp_base_locs\"], phi1_map, phi2_map, case[\"fuel_props\"], case[\"bp_props\"]\n        )\n\n        # Step 3: Calculate metrics for moved configuration\n        k_inf_moved, pf_moved = calculate_metrics(\n            N, case[\"bp_moved_locs\"], phi1_map, phi2_map, case[\"fuel_props\"], case[\"bp_props\"]\n        )\n\n        # Step 4: Compute the deltas\n        delta_k_inf = k_inf_moved - k_inf_base\n        delta_pf = pf_moved - pf_base\n\n        results.extend([delta_k_inf, delta_pf])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n\ndef generate_flux_maps(N, gamma1, gamma2):\n    \"\"\"\n    Generates normalized two-group flux maps based on a parametric model.\n    \"\"\"\n    epsilon = 1e-8\n    indices = np.arange(N)\n    i, j = np.meshgrid(indices, indices, indexing='ij')\n\n    center = (N - 1) / 2.0\n    r_squared = (i - center)**2 + (j - center)**2\n\n    phi_raw_1 = np.maximum(epsilon, 1 - gamma1 * r_squared)\n    phi_raw_2 = np.maximum(epsilon, 1 - gamma2 * r_squared)\n\n    phi1_map = phi_raw_1 / np.sum(phi_raw_1)\n    phi2_map = phi_raw_2 / np.sum(phi_raw_2)\n\n    return phi1_map, phi2_map\n\n\ndef calculate_metrics(N, bp_locs, phi1_map, phi2_map, fuel_props, bp_props):\n    \"\"\"\n    Calculates k_inf and PF for a given material configuration and flux maps.\n    \"\"\"\n    # Create material map: 0 for fuel, 1 for BP\n    material_map = np.zeros((N, N), dtype=int)\n    for r, c in bp_locs:\n        material_map[r, c] = 1\n\n    # Create full cross-section maps using advanced indexing\n    Sa1_map = np.array([fuel_props[\"Sa1\"], bp_props[\"Sa1\"]])[material_map]\n    Sa2_map = np.array([fuel_props[\"Sa2\"], bp_props[\"Sa2\"]])[material_map]\n    nuSf1_map = np.array([fuel_props[\"nuSf1\"], bp_props[\"nuSf1\"]])[material_map]\n    nuSf2_map = np.array([fuel_props[\"nuSf2\"], bp_props[\"nuSf2\"]])[material_map]\n\n    # Calculate total production and absorption rates\n    total_production = np.sum(nuSf1_map * phi1_map + nuSf2_map * phi2_map)\n    total_absorption = np.sum(Sa1_map * phi1_map + Sa2_map * phi2_map)\n\n    # Calculate k_inf\n    k_inf = total_production / total_absorption if total_absorption != 0 else 0.0\n    \n    # Calculate pin power peaking factor (PF)\n    # Pin power is proportional to fission source density\n    pin_power_map = nuSf1_map * phi1_map + nuSf2_map * phi2_map\n    \n    if total_production > 0:\n        max_pin_power = np.max(pin_power_map)\n        avg_pin_power = total_production / (N * N)\n        pf = max_pin_power / avg_pin_power\n    else: # Should not happen with fuel in the assembly\n        pf = 1.0\n\n    return k_inf, pf\n\nsolve()\n```"
        },
        {
            "introduction": "对于涉及大量变量的复杂优化问题，逐一测试参数变化的“蛮力”方法效率低下。本练习将向你介绍一种更为强大和高效的计算技术——伴随通量法，用于快速计算系统响应的灵敏度 。你将通过求解伴随扩散方程，并利用其解 $\\boldsymbol{\\phi}^{\\ast}$ 来精确预测 $k_{\\mathrm{eff}}$ 对可燃毒物浓度微小变化的一阶响应，从而掌握现代反应堆设计与优化中不可或缺的分析工具。",
            "id": "4219387",
            "problem": "您的任务是计算伴随中子通量，以评估在一维粗网格扩散模型的核反应堆堆芯中，有效增殖因数 $k_{\\mathrm{eff}}$ 对可燃毒物密度变化的的一阶灵敏度。反应堆堆芯由 $N$ 个节点的均匀网格表示，节点间距为 $h$（单位 $\\mathrm{cm}$），并采用反射边界条件。物理模型为稳态、单群中子扩散近似，使用有限差分法结合界面扩散系数进行离散化。\n\n从以下基本原理开始：\n\n- 扩散近似下的稳态单群中子平衡可以在离散网格上表示为一个广义特征值问题，\n$$\nL(\\boldsymbol{\\theta}) \\, \\boldsymbol{\\phi} = \\lambda \\, M(\\boldsymbol{\\theta}) \\, \\boldsymbol{\\phi},\n$$\n其中 $L$ 是包含中子扩散和吸收的损失算子，$M$ 是包含裂变中子产生的产生算子，$\\boldsymbol{\\phi}$ 是中子通量矢量，$\\lambda$ 是等于 $1/k_{\\mathrm{eff}}$ 的广义特征值，$\\boldsymbol{\\theta}$ 是材料参数。施加了反射边界条件。\n\n- 对应的伴随特征值问题是\n$$\nL(\\boldsymbol{\\theta})^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast} = \\lambda \\, M(\\boldsymbol{\\theta})^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast},\n$$\n其中 $\\boldsymbol{\\phi}^{\\ast}$ 是伴随通量，${}^{\\mathsf{T}}$ 表示转置。\n\n- 可燃毒物密度参数 $p$ 通过以下方式线性地进入宏观吸收截面中\n$$\n\\Sigma_{a,i}(p) = \\Sigma_{a,i}^{\\mathrm{base}} + p \\, \\Sigma_{p,i},\n$$\n其中 $\\Sigma_{a,i}^{\\mathrm{base}}$ 是节点 $i$ 的基础吸收截面，$\\Sigma_{p,i}$ 是节点 $i$ 中毒物的宏观吸收截面贡献。所有截面的单位均为 $\\mathrm{cm}^{-1}$，扩散系数 $D_i$ 的单位为 $\\mathrm{cm}$。裂变产生截面 $\\nu \\Sigma_{f,i}$ 的单位为 $\\mathrm{cm}^{-1}$。网格间距 $h$ 的单位为 $\\mathrm{cm}$。\n\n- 离散损失算子 $L$ 使用调和平均界面扩散系数 $D_{i+\\frac{1}{2}}$ 和反射边界条件构建，其矩阵元为\n$$\nL_{i,i} = \\frac{D_{i-\\frac{1}{2}} + D_{i+\\frac{1}{2}}}{h^2} + \\Sigma_{a,i}(p), \\quad\nL_{i,i-1} = -\\frac{D_{i-\\frac{1}{2}}}{h^2}, \\quad\nL_{i,i+1} = -\\frac{D_{i+\\frac{1}{2}}}{h^2},\n$$\n其中 $D_{-\\frac{1}{2}} = 0$ 和 $D_{N-\\frac{1}{2}} = 0$ 强制实现反射边界，并且对于 $i = 0, \\dots, N-2$，$D_{i+\\frac{1}{2}} = \\dfrac{2}{\\frac{1}{D_i} + \\frac{1}{D_{i+1}}}$。产生算子 $M$ 是对角矩阵，其对角元为 $M_{i,i} = \\nu \\Sigma_{f,i}$。\n\n您的程序必须：\n\n- 针对每个测试用例，在基准毒物密度 $p_0$ 下构建 $L$ 和 $M$。\n- 求解正向广义特征值问题，得到最小正实数特征值 $\\lambda$ 和相应的右特征向量 $\\boldsymbol{\\phi}$，并计算 $k_{\\mathrm{eff}} = 1/\\lambda$。\n- 求解伴随广义特征值问题，得到对应同一 $\\lambda$ 的 $\\boldsymbol{\\phi}^{\\ast}$。\n- 根据第一性原理，推导并实现 $k_{\\mathrm{eff}}$ 对 $p$ 的一阶灵敏度，该灵敏度用在 $p_0$ 处计算的伴随解、正向解以及算子导数 $\\frac{\\partial L}{\\partial p}$ 来表示。将 $p$ 视为无量纲量。不要假设 $\\boldsymbol{\\phi}$ 或 $\\boldsymbol{\\phi}^{\\ast}$ 经过任何预归一化；任何所需的内积都必须显式计算。\n- 使用一阶灵敏度预测一个小的微扰 $\\delta p$ 引起的变化量 $\\Delta k_{\\mathrm{eff}}$。\n- 通过在 $p_1 = p_0 + \\delta p$ 处直接重新计算 $k_{\\mathrm{eff}}$ 并与基准值作差来验证该预测。\n\n物理和数值单位：\n- $h$ 和 $D_i$ 使用 $\\mathrm{cm}$ 作为单位，所有截面使用 $\\mathrm{cm}^{-1}$ 作为单位。有效增殖因数 $k_{\\mathrm{eff}}$ 及其变化是无量纲的。将所有最终输出表示为十进制浮点数（无量纲）。\n\n测试套件：\n实现以下三个测试用例。对于每个用例，最终结果必须是基于伴随的一阶预测值 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}}$ 与直接计算的变化量 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}}$ 之间的绝对误差。\n\n- 用例 1（理想情况，内部毒物）：\n  - $N = 12$, $h = 15$ $\\mathrm{cm}$。\n  - 对所有 $i$，$D_i = 1.2$ $\\mathrm{cm}$。\n  - 对所有 $i$，$\\Sigma_{a,i}^{\\mathrm{base}} = 0.006$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$\\nu \\Sigma_{f,i} = 0.045$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$ \\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$，但当 $i \\in \\{5,6\\}$ 时 $\\Sigma_{p,i} = 0.020$ $\\mathrm{cm}^{-1}$。\n  - $p_0 = 0.8$, $\\delta p = 0.01$。\n\n- 用例 2（边界条件和零毒物导数边界情况）：\n  - $N = 8$, $h = 20$ $\\mathrm{cm}$。\n  - 对所有 $i$，$D_i = 1.4$ $\\mathrm{cm}$。\n  - 对所有 $i$，$\\Sigma_{a,i}^{\\mathrm{base}} = 0.006$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$\\nu \\Sigma_{f,i} = 0.050$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$ \\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$。\n  - $p_0 = 1.0$, $\\delta p = 0.05$。\n\n- 用例 3（非均匀扩散，边界处有毒物，负微扰）：\n  - $N = 10$, $h = 12$ $\\mathrm{cm}$。\n  - 对于 $i = 0, \\dots, N-1$，$D_i = 1.0 + 0.6 \\frac{i}{N-1}$ $\\mathrm{cm}$。\n  - 对所有 $i$，$\\Sigma_{a,i}^{\\mathrm{base}} = 0.005$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$\\nu \\Sigma_{f,i} = 0.040$ $\\mathrm{cm}^{-1}$。\n  - 对所有 $i$，$ \\Sigma_{p,i} = 0$ $\\mathrm{cm}^{-1}$，但当 $i \\in \\{0,9\\}$ 时 $\\Sigma_{p,i} = 0.030$ $\\mathrm{cm}^{-1}$。\n  - $p_0 = 0.5$, $\\delta p = -0.02$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个绝对误差，以逗号分隔的十进制浮点数列表形式表示，并用方括号括起来，例如 $[e_1,e_2,e_3]$，其中 $e_j = \\left|\\Delta k_{\\mathrm{eff},j}^{\\mathrm{pred}} - \\Delta k_{\\mathrm{eff},j}^{\\mathrm{dir}}\\right|$ 是用例 $j$ 的误差。输出中不得包含任何额外文本。",
            "solution": "用户提供的问题经评估有效。它基于已确立的反应堆物理原理，具有科学依据，在数学上是适定的，并且为获得唯一且有意义的解提供了所有必要的参数和定义。未发现任何矛盾、歧义或事实不健全之处。\n\n问题的核心是计算有效增殖因数 $k_{\\mathrm{eff}}$ 相对于可燃毒物密度 $p$ 变化的一阶灵敏度。这需要使用一阶微扰理论推导灵敏度系数，而该理论依赖于正向和伴随中子通量。\n\n首先，我们形式上推导灵敏度表达式。该系统由单群、稳态中子扩散方程描述，离散化为广义特征值问题：\n$$\nL(p) \\, \\boldsymbol{\\phi}(p) = \\lambda(p) \\, M \\, \\boldsymbol{\\phi}(p)\n$$\n其中 $\\boldsymbol{\\phi}$ 是每个空间节点上的中子通量矢量，$L$ 是中子损失算子（扩散和吸收），$M$ 是中子产生算子（裂变），$\\lambda = 1/k_{\\mathrm{eff}}$ 是特征值，$p$ 是毒物密度参数。值得注意的是，$M$ 不依赖于 $p$。\n\n相应的伴随特征值问题由下式给出：\n$$\nL(p)^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast}(p) = \\lambda(p) \\, M^{\\mathsf{T}} \\, \\boldsymbol{\\phi}^{\\ast}(p)\n$$\n其中 $\\boldsymbol{\\phi}^{\\ast}$ 是伴随通量矢量。在此问题中，离散算子 $L$ 和产生算子 $M$（它是对角的）都是实对称的，因此 $L^{\\mathsf{T}} = L$ 且 $M^{\\mathsf{T}} = M$。因此，正向和伴随问题是相同的，它们的特征向量 $\\boldsymbol{\\phi}$ 和 $\\boldsymbol{\\phi}^{\\ast}$ 也相同。\n\n为了求得灵敏度，我们将正向特征值方程对 $p$ 求导：\n$$\n\\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} + L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} = \\frac{\\partial \\lambda}{\\partial p} M \\boldsymbol{\\phi} + \\lambda M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p}\n$$\n然后，我们将此方程与伴随通量 $\\boldsymbol{\\phi}^{\\ast}$ 作内积，其中内积定义为 $\\langle \\mathbf{y}, \\mathbf{x} \\rangle = \\mathbf{y}^{\\mathsf{T}}\\mathbf{x}$。\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle + \\langle \\boldsymbol{\\phi}^{\\ast}, L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\n根据伴随算子的定义，$\\langle \\boldsymbol{\\phi}^{\\ast}, L \\mathbf{v} \\rangle = \\langle L^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\mathbf{v} \\rangle$。利用此性质和伴随方程 $L^{\\mathsf{T}}\\boldsymbol{\\phi}^{\\ast} = \\lambda M^{\\mathsf{T}}\\boldsymbol{\\phi}^{\\ast}$，我们可以重写左侧的第二项：\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, L \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\langle L^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\langle \\lambda M^{\\mathsf{T}} \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\n最后一步成立，因为 $M$ 是对称的（$M^{\\mathsf{T}} = M$）。将其代入后，我们发现涉及通量导数 $\\frac{\\partial \\boldsymbol{\\phi}}{\\partial p}$ 的项被消去了：\n$$\n\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle + \\lambda \\langle \\boldsymbol{\\phi}^{\\ast}, M \\frac{\\partial \\boldsymbol{\\phi}}{\\partial p} \\rangle\n$$\n$$\n\\implies \\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle = \\frac{\\partial \\lambda}{\\partial p} \\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle\n$$\n解出 $\\frac{\\partial \\lambda}{\\partial p}$ 得到特征值的灵敏度：\n$$\n\\frac{\\partial \\lambda}{\\partial p} = \\frac{\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle}{\\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle}\n$$\n问题要求的是 $k_{\\mathrm{eff}} = 1/\\lambda$ 的灵敏度。使用链式法则，$\\frac{\\partial \\lambda}{\\partial p} = -\\frac{1}{k_{\\mathrm{eff}}^2} \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p}$。代入此式并重新整理，得到所求的 $k_{\\mathrm{eff}}$ 灵敏度：\n$$\n\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} = -k_{\\mathrm{eff}}^2 \\frac{\\langle \\boldsymbol{\\phi}^{\\ast}, \\frac{\\partial L}{\\partial p} \\boldsymbol{\\phi} \\rangle}{\\langle \\boldsymbol{\\phi}^{\\ast}, M \\boldsymbol{\\phi} \\rangle}\n$$\n算子导数 $\\frac{\\partial L}{\\partial p}$ 通过对 $L$ 的元素求导得到。只有对角吸收项依赖于 $p$：$L_{i,i}(p) = \\dots + \\Sigma_{a,i}^{\\mathrm{base}} + p \\, \\Sigma_{p,i}$。因此，$\\frac{\\partial L_{i,i}}{\\partial p} = \\Sigma_{p,i}$。导数矩阵 $\\frac{\\partial L}{\\partial p}$ 是对角矩阵，其对角元为 $\\Sigma_{p,i}$。内积变为求和：\n$$\n\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} = -k_{\\mathrm{eff}}^2 \\frac{\\sum_{i=0}^{N-1} \\phi^{\\ast}_i \\Sigma_{p,i} \\phi_i}{\\sum_{i=0}^{N-1} \\phi^{\\ast}_i (\\nu \\Sigma_{f,i}) \\phi_i}\n$$\n由小微扰 $\\delta p$ 引起的 $k_{\\mathrm{eff}}$ 的预测变化量为 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} = \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} \\delta p$。\n\n数值实现过程如下：\n1.  对于基准毒物密度 $p_0$ 下的一组给定参数，构建对称损失矩阵 $L(p_0)$ 和对角产生矩阵 $M$。$L$ 的非对角元由栅元界面处扩散系数的调和平均值构建，并通过将外部边界处的扩散项设置为零来强制实现反射边界条件。\n2.  求解广义特征值问题 $L(p_0) \\boldsymbol{\\phi}_0 = \\lambda_0 M \\boldsymbol{\\phi}_0$，得到最小特征值 $\\lambda_0$ 及其对应的特征向量 $\\boldsymbol{\\phi}_0$。这是通过使用针对对称矩阵的数值特征求解器完成的。基准有效增殖因数为 $k_{\\mathrm{eff},0} = 1/\\lambda_0$。\n3.  由于 $L$ 和 $M$ 是对称的，伴随通量与正向通量相同，即 $\\boldsymbol{\\phi}^{\\ast}_0 = \\boldsymbol{\\phi}_0$。\n4.  使用推导出的公式、通量 $\\boldsymbol{\\phi}_0$、$\\boldsymbol{\\phi}^{\\ast}_0$ 和 $k_{\\mathrm{eff},0}$，计算在 $p_0$ 处的灵敏度 $\\frac{\\partial k_{\\mathrm{eff}}}{\\partial p}$。\n5.  计算预测的变化量 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} = \\frac{\\partial k_{\\mathrm{eff}}}{\\partial p} \\delta p$。\n6.  为了验证，直接计算微扰后的状态。为 $p_1 = p_0 + \\delta p$ 构建一个新的损失矩阵 $L(p_1)$。\n7.  求解新的特征值问题 $L(p_1) \\boldsymbol{\\phi}_1 = \\lambda_1 M \\boldsymbol{\\phi}_1$，找到微扰后的特征值 $\\lambda_1$ 和 $k_{\\mathrm{eff},1} = 1/\\lambda_1$。\n8.  直接计算的变化量为 $\\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}} = k_{\\mathrm{eff},1} - k_{\\mathrm{eff},0}$。\n9.  每个用例的最终结果是绝对误差 $e = |\\Delta k_{\\mathrm{eff}}^{\\mathrm{pred}} - \\Delta k_{\\mathrm{eff}}^{\\mathrm{dir}}|$。这个误差量化了一阶近似的准确性。对于小的微扰 $\\delta p$，预计该误差会很小。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p):\n    \"\"\"\n    Constructs the loss (L) and production (M) matrices for the 1D diffusion problem.\n\n    Args:\n        N (int): Number of nodes.\n        h (float): Node spacing in cm.\n        D_vec (np.ndarray): Vector of diffusion coefficients for each node in cm.\n        Sigma_a_base (np.ndarray): Vector of base absorption cross sections in cm^-1.\n        nu_Sigma_f (np.ndarray): Vector of neutron production cross sections in cm^-1.\n        Sigma_p (np.ndarray): Vector of poison absorption cross sections in cm^-1.\n        p (float): Dimensionless poison density parameter.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the L and M matrices.\n    \"\"\"\n    L = np.zeros((N, N))\n    M = np.diag(nu_Sigma_f)\n\n    # Calculate interface diffusion coefficients using harmonic mean\n    D_interface = np.zeros(N - 1)\n    for i in range(N - 1):\n        D_interface[i] = 2.0 / (1.0 / D_vec[i] + 1.0 / D_vec[i+1])\n\n    # Calculate current absorption cross sections\n    Sigma_a = Sigma_a_base + p * Sigma_p\n\n    # Populate the tridiagonal L matrix\n    # Diagonal elements\n    h2 = h * h\n    for i in range(N):\n        # Absorption term\n        L[i, i] = Sigma_a[i]\n        # Diffusion term from the right interface (i, i+1)\n        if i  N - 1:\n            L[i, i] += D_interface[i] / h2\n        # Diffusion term from the left interface (i-1, i)\n        if i > 0:\n            L[i, i] += D_interface[i-1] / h2\n\n    # Off-diagonal elements\n    for i in range(N - 1):\n        L[i, i+1] = -D_interface[i] / h2\n        L[i+1, i] = -D_interface[i] / h2\n        \n    return L, M\n\ndef solve_eigenproblem(L, M):\n    \"\"\"\n    Solves the generalized eigenvalue problem L*phi = lambda*M*phi.\n\n    Args:\n        L (np.ndarray): The loss matrix.\n        M (np.ndarray): The production matrix.\n\n    Returns:\n        tuple[float, np.ndarray]: A tuple containing the fundamental eigenvalue (lambda_0)\n                                  and the corresponding eigenvector (flux phi_0).\n    \"\"\"\n    # eigh is for symmetric/Hermitian matrices, which L and M are.\n    # It returns eigenvalues in ascending order.\n    eigenvalues, eigenvectors = eigh(L, M)\n    \n    # The fundamental mode corresponds to the smallest positive eigenvalue.\n    lambda_0 = eigenvalues[0]\n    phi_0 = eigenvectors[:, 0]\n    \n    # Normalize flux to be positive (physical convention)\n    if np.sum(phi_0)  0:\n        phi_0 *= -1.0\n        \n    return lambda_0, phi_0\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 12, \"h\": 15.0,\n            \"D_func\": lambda N: np.full(N, 1.2),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.006),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.045),\n            \"Sigma_p_func\": lambda N: np.array([0.020 if i in {5, 6} else 0.0 for i in range(N)]),\n            \"p0\": 0.8, \"delta_p\": 0.01\n        },\n        # Case 2\n        {\n            \"N\": 8, \"h\": 20.0,\n            \"D_func\": lambda N: np.full(N, 1.4),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.006),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.050),\n            \"Sigma_p_func\": lambda N: np.zeros(N),\n            \"p0\": 1.0, \"delta_p\": 0.05\n        },\n        # Case 3\n        {\n            \"N\": 10, \"h\": 12.0,\n            \"D_func\": lambda N: 1.0 + 0.6 * np.arange(N) / (N - 1),\n            \"Sigma_a_base_func\": lambda N: np.full(N, 0.005),\n            \"nu_Sigma_f_func\": lambda N: np.full(N, 0.040),\n            \"Sigma_p_func\": lambda N: np.array([0.030 if i in {0, 9} else 0.0 for i in range(N)]),\n            \"p0\": 0.5, \"delta_p\": -0.02\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        h = case[\"h\"]\n        p0 = case[\"p0\"]\n        delta_p = case[\"delta_p\"]\n        p1 = p0 + delta_p\n\n        # Generate material properties\n        D_vec = case[\"D_func\"](N)\n        Sigma_a_base = case[\"Sigma_a_base_func\"](N)\n        nu_Sigma_f = case[\"nu_Sigma_f_func\"](N)\n        Sigma_p = case[\"Sigma_p_func\"](N)\n\n        # 1. Baseline Calculation (at p0)\n        L0, M = build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p0)\n        lambda0, phi0 = solve_eigenproblem(L0, M)\n        k_eff0 = 1.0 / lambda0\n        \n        # In this problem, L and M are symmetric, so phi* = phi\n        phi_star0 = phi0\n\n        # 2. Sensitivity Calculation\n        # dL/dp is a diagonal matrix with Sigma_p on the diagonal\n        dL_dp_matrix = np.diag(Sigma_p)\n        \n        numerator = phi_star0.T @ dL_dp_matrix @ phi0\n        denominator = phi_star0.T @ M @ phi0\n        \n        # Avoid division by zero if there's no fission\n        if np.isclose(denominator, 0.0):\n            dk_eff_dp = 0.0\n        else:\n            dk_eff_dp = -k_eff0**2 * (numerator / denominator)\n\n        delta_k_eff_pred = dk_eff_dp * delta_p\n\n        # 3. Direct Calculation (at p1 = p0 + delta_p)\n        L1, _ = build_matrices(N, h, D_vec, Sigma_a_base, nu_Sigma_f, Sigma_p, p1)\n        lambda1, _ = solve_eigenproblem(L1, M)\n        k_eff1 = 1.0 / lambda1\n        \n        delta_k_eff_dir = k_eff1 - k_eff0\n\n        # 4. Compute Absolute Error\n        error = abs(delta_k_eff_pred - delta_k_eff_dir)\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.12e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}