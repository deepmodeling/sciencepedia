{
    "hands_on_practices": [
        {
            "introduction": "在有限元方法中，精确构建离散系统的矩阵是求解过程的基石。本练习将引导你确定精确计算质量矩阵所需的数值积分（即高斯求积）规则，这是处理中子吸收和瞬态问题的关键步骤。通过这个计算，你不仅能掌握保证积分精度的理论方法，还将初步接触到一种重要的近似技巧——质量集中（mass lumping），为理解其在后续实践中的应用奠定基础。",
            "id": "4217887",
            "problem": "在用于核反应堆模拟的一维针元稳态中子扩散模型中，考虑在尺寸为 $h = x_{e+1} - x_{e}$ 的单个仿射物理单元 $K = [x_{e}, x_{e+1}]$ 上的连续伽辽金有限元法 (CGFEM) 离散化。宏观吸收截面 $\\Sigma_{a}$ 在 $K$ 上是常数。设试探空间和检验空间由在参考区间 $\\hat{K} = [-1,1]$ 上定义的多项式次数为 $p$ 的拉格朗日形函数 $\\{N_{i}\\}_{i=1}^{n_{\\text{dof}}}$ 张成，并通过仿射映射 $F : \\hat{K} \\to K$ 映射到 $K$ 上，使得 $x = F(\\xi)$ 且 $dx = J\\,d\\xi$，其中雅可比行列式 $J = h/2$ 为常数。单元级吸收质量矩阵的项为\n$$\nM_{ij} = \\int_{K} \\Sigma_{a}\\,N_{i}(x)\\,N_{j}(x)\\,dx.\n$$\n从中子扩散方程的弱形式和上述仿射映射出发，确定在参考区间 $\\hat{K} = [-1,1]$ 上，为精确计算所有指标 $i$ 和 $j$ 的 $M_{ij}$ 所需的高斯-勒让德求积点的最少数目 $n$。以多项式次数 $p$ 的闭式解析表达式给出最终答案。然后，用文字将此精确积分要求与通过在 $\\hat{K}$ 上使用 $p+1$ 个节点进行节点求积来对角化 $M$ 的质量集中近似进行对比，并强调其对反应堆计算中吸收算子谱特性的影响。对比不需要数值估算。最终答案必须是单一的符号表达式；不包含单位，也无需四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据、提法恰当且客观。它提出了一个应用于中子扩散的有限元方法数值分析中的标准问题，这是核反应堆模拟的核心课题。所有必要信息都已提供，所用术语在该领域内是精确且标准的。\n\n主要任务是确定为精确计算单元级吸收质量矩阵项 $M_{ij}$ 所需的高斯-勒让德求积点的最少数目 $n$。次要任务是将其与质量集中近似进行对比。\n\n首先，我们分析质量矩阵项 $M_{ij}$ 的积分。它在物理单元 $K = [x_e, x_{e+1}]$ 上定义为：\n$$\nM_{ij} = \\int_{K} \\Sigma_{a}\\,N_{i}(x)\\,N_{j}(x)\\,dx\n$$\n这里，$\\Sigma_{a}$ 是单元 $K$ 上的常数宏观吸收截面。函数 $N_i(x)$ 和 $N_j(x)$ 是多项式次数为 $p$ 的拉格朗日基函数。\n\n为了使用标准求积法则进行积分，我们将积分从物理单元 $K$ 映射到参考单元 $\\hat{K} = [-1, 1]$。问题中指出这是通过仿射映射 $x = F(\\xi)$ 完成的，微分元变换为 $dx = J\\,d\\xi$，其中雅可比行列式 $J = \\frac{h}{2}$ 为常数，且 $h = x_{e+1} - x_e$。设 $\\hat{N}_i(\\xi)$ 和 $\\hat{N}_j(\\xi)$ 为参考单元上的基函数，使得 $N_i(x) = \\hat{N}_i(F^{-1}(x))$。积分变为：\n$$\nM_{ij} = \\int_{-1}^{1} \\Sigma_{a}\\,\\hat{N}_{i}(\\xi)\\,\\hat{N}_{j}(\\xi)\\,J\\,d\\xi\n$$\n由于 $\\Sigma_{a}$ 和雅可比行列式 $J = \\frac{h}{2}$ 是常数，我们可以将它们从积分中提取出来：\n$$\nM_{ij} = \\frac{\\Sigma_{a} h}{2} \\int_{-1}^{1} \\hat{N}_{i}(\\xi)\\,\\hat{N}_{j}(\\xi)\\,d\\xi\n$$\n必须被精确积分的被积函数是乘积 $\\hat{N}_{i}(\\xi)\\,\\hat{N}_{j}(\\xi)$。由于仿射映射保持多项式次数，参考基函数 $\\hat{N}_{i}(\\xi)$ 和 $\\hat{N}_{j}(\\xi)$ 也是变量 $\\xi$ 的 $p$ 次多项式。两个 $p$ 次多项式的乘积是一个次数最多为 $p+p = 2p$ 的多项式。设被积多项式的次数为 $D$。因此，$D = 2p$。\n\n一个具有 $n$ 个点的高斯-勒让德求积法则能够精确积分最高为 $2n-1$ 次的多项式。为确保我们的被积函数被精确积分，求积法则的精确度必须大于或等于被积多项式的次数。这给出了条件：\n$$\n2n - 1 \\ge D\n$$\n代入 $D = 2p$，我们得到：\n$$\n2n - 1 \\ge 2p\n$$\n求解 $n$，我们发现：\n$$\n2n \\ge 2p + 1\n$$\n$$\nn \\ge p + \\frac{1}{2}\n$$\n由于求积点数 $n$ 必须是整数，满足此不等式的最小整数值 $n$ 是 $p+1$。\n因此，精确计算质量矩阵项 $M_{ij}$ 需要最少 $n=p+1$ 个高斯-勒让德求积点。\n\n对于问题的第二部分，我们将此精确积分方案与质量集中进行对比。精确积分产生所谓的“一致质量矩阵”，该矩阵通常是稠密的（对于 $p \\ge 1$）、对称的和正定的。\n\n如问题所述，通过节点求积进行的质量集中使用拉格朗日基函数本身的 $p+1$ 个节点作为求积点。设参考单元上的这些节点为 $\\{\\hat{\\xi}_k\\}_{k=1}^{p+1}$。根据拉格朗日基函数的定义，$\\hat{N}_i(\\hat{\\xi}_k) = \\delta_{ik}$，其中 $\\delta_{ik}$ 是克罗内克 δ。该积分近似为一个和式：\n$$\nM_{ij} = \\frac{\\Sigma_a h}{2} \\int_{-1}^{1} \\hat{N}_i(\\xi) \\hat{N}_j(\\xi) d\\xi \\approx \\frac{\\Sigma_a h}{2} \\sum_{k=1}^{p+1} w_k \\hat{N}_i(\\hat{\\xi}_k) \\hat{N}_j(\\hat{\\xi}_k)\n$$\n其中 $w_k$ 是求积权重。代入克罗内克 δ 的性质：\n$$\nM_{ij}^{\\text{lumped}} = \\frac{\\Sigma_a h}{2} \\sum_{k=1}^{p+1} w_k \\delta_{ik} \\delta_{jk}\n$$\n这个和仅在 $i=j=k$ 时非零。因此，得到的集中质量矩阵 $M^{\\text{lumped}}$ 是对角矩阵，其对角项为 $M_{ii}^{\\text{lumped}} = \\frac{\\Sigma_a h}{2} w_i > 0$。这种对角结构极大地简化了计算，特别是在瞬态问题中所需的质量矩阵求逆。\n\n这对吸收算子的谱特性有重要影响。连续吸收算子是乘以 $\\Sigma_a$ 的运算，其谱就是 $\\Sigma_a$ 所取的值域。\n一致质量矩阵虽然提供了更高阶的精确表示，但已知其特征值会高估连续算子的谱。也就是说，（归一化的）一致质量矩阵的最大特征值可能大于域中 $\\Sigma_a$ 的最大物理值。这种谱高估会对时间积分方案的稳定性和反应堆物理计算中常见的迭代求解器（例如，用于 $k_{\\text{eff}}$ 特征值的幂迭代法）的收敛速度产生负面影响。\n相比之下，集中质量矩阵是对角的，其特征值就是其对角元。虽然积分本身是不精确的，但可以构建此过程以保留某些物理性质。例如，一些质量集中方案保证矩阵特征值保持在系数 $\\Sigma_a$ 的物理界限内。这避免了谱高估，并能带来更稳健且物理上一致的数值行为，例如保持中子通量的正性。其代价是与一致质量矩阵公式相比，形式精度有所降低，但其计算优势和改进的谱特性通常使质量集中成为实际大型反应堆模拟中一个有吸引力的选择。",
            "answer": "$$\\boxed{p+1}$$"
        },
        {
            "introduction": "理论与实践的结合是掌握数值方法的关键。在前一个练习  的理论基础上，本练习要求你通过编程来直接比较一致质量矩阵（consistent mass matrix）和集中质量矩阵（lumped mass matrix）在求解瞬态中子扩散问题时的表现。你将亲手实现这两种方法，并分析它们对计算精度、数值稳定性以及解的物理性质（如正定性）的实际影响。",
            "id": "4217929",
            "problem": "考虑一维板中具有零通量（真空）边界条件的瞬态单群中子扩散方程。控制方程为标准形式 $$\\frac{1}{v}\\frac{\\partial \\phi}{\\partial t} = D \\frac{\\partial^2 \\phi}{\\partial x^2} - \\Sigma_a \\phi,$$ 其中 $x \\in [0,L]$，$t \\ge 0$，$v$ 是中子速度，$D$ 是扩散系数，$\\Sigma_a$ 是宏观吸收截面，$\\phi(x,t)$ 是标量中子通量。两边乘以 $v$ 得到 $$\\frac{\\partial \\phi}{\\partial t} = \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi,$$ 其中 $\\alpha = vD$ 且 $\\beta = v\\Sigma_a$。施加齐次 Dirichlet 边界条件 $\\phi(0,t)=0$ 和 $\\phi(L,t)=0$，以及一个与边界兼容的初始条件 $\\phi(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$。使用连续有限元法（FEM），在 $[0,L]$ 上由 $N$ 个等长单元组成的均匀网格上采用分段线性基函数，推导半离散系统 $$\\mathbf{M}\\,\\dot{\\boldsymbol{\\Phi}}(t) + \\mathbf{K}\\,\\boldsymbol{\\Phi}(t) = \\mathbf{0},$$ 其中 $\\mathbf{M}$ 是质量矩阵，$\\mathbf{K}$ 是组合的刚度-反应矩阵。一致质量矩阵使用精确的单元积分，而集总质量矩阵是通过对一致矩阵进行行求和以创建对角近似来形成的。时间积分采用显式向前欧拉法，$$\\boldsymbol{\\Phi}^{n+1} = \\boldsymbol{\\Phi}^n - \\Delta t\\,\\mathbf{M}^{-1}\\mathbf{K}\\,\\boldsymbol{\\Phi}^n.$$\n\n从弱形式出发，通过标准 Galerkin 投影、分部积分和施加 Dirichlet 边界得到单元矩阵的定义，开发一个程序，该程序能够：\n\n- 组装在 $[0,L]$ 上的 $N$ 个线性单元的内部块一致质量矩阵 $\\mathbf{M}$ 和组合刚度-反应矩阵 $\\mathbf{K}$。\n- 通过对 $\\mathbf{M}$ 进行行求和，形成集总质量矩阵 $\\mathbf{M}_{\\mathrm{lump}}$。\n- 对于一致质量和集总质量两种情况，从问题 $\\mathbf{K}\\mathbf{u}=\\lambda\\,\\mathbf{M}\\mathbf{u}$ 中计算广义特征值 $\\lambda$，找出每种情况下的最大特征值 $\\lambda_{\\max}$，并使用不等式 $0\\le \\Delta t \\lambda \\le 2$（对所有特征值成立）来表征显式欧拉法的稳定性极限。\n- 使用 $\\mathbf{M}$ 或 $\\mathbf{M}_{\\mathrm{lump}}$，从初始条件 $\\phi(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right)$ 出发，用显式欧拉法将半离散系统演化到指定的最终时间 $T$，并通过与离散正弦向量的质量内积来测量沿解析第一模态的模态振幅。将数值振幅与时间步进器实际达到的离散时间 $t = n\\Delta t$ 处的解析连续谱振幅 $\\exp\\left(-(\\alpha(\\pi/L)^2+\\beta)\\,t\\right)$ 进行比较。在两种情况下都使用一致质量内积来测量振幅，以便精度比较使用共同的度量标准。\n\n您的程序必须执行三个测试用例，它们共同构成一个测试套件，涵盖一个一般情况、一个边界稳定性条件以及一个与正性相关的边缘情况。所有物理参数必须使用以下单位：\n- $L$ 单位为米 (m)，\n- $D$ 单位为米 (m)，\n- $v$ 单位为米/秒 (m/s)，\n- $\\Sigma_a$ 单位为逆米 ($\\mathrm{m}^{-1}$)，\n- $T$ 和 $\\Delta t$ 单位为秒 (s)。\n\n测试套件参数为：\n\n- 测试用例 1 (精度，一般情况)：\n  - $L = 1.0\\,\\mathrm{m}$，\n  - $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$，\n  - $\\Sigma_a = 1.0\\times 10^{-2}\\,\\mathrm{m}^{-1}$，\n  - $v = 1000.0\\,\\mathrm{m/s}$，\n  - $N = 40$，\n  - 最终时间 $T = 0.5\\,\\mathrm{s}$，\n  - 时间步长选择为 $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$，其中 $\\mu = 0.2$，$\\lambda_{\\max,\\mathrm{cons}}$ 是一致质量矩阵的最大广义特征值。输出在时间 $t=n\\Delta t \\le T$ 时的模态振幅绝对误差对：$[\\mathrm{err}_{\\mathrm{cons}}, \\mathrm{err}_{\\mathrm{lump}}]$，其中每个误差都是无量纲的。\n\n- 测试用例 2 (稳定性，边界条件)：\n  - $L = 1.0\\,\\mathrm{m}$，\n  - $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$，\n  - $\\Sigma_a = 1.0\\times 10^{-2}\\,\\mathrm{m}^{-1}$，\n  - $v = 1000.0\\,\\mathrm{m/s}$，\n  - $N = 40$，\n  - 选择 $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$，其中 $\\mu = 1.01$。输出布尔值对 $[\\mathrm{stable}_{\\mathrm{cons}}, \\mathrm{stable}_{\\mathrm{lump}}]$，指示显式欧拉方案在每种情况下是否稳定（如果对于相应的质量矩阵 $\\Delta t \\le 2/\\lambda_{\\max}$ 则为真，否则为假）。\n\n- 测试用例 3 (正性，边缘情况)：\n  - $L = 1.0\\,\\mathrm{m}$，\n  - $D = 1.0\\times 10^{-4}\\,\\mathrm{m}$，\n  - $\\Sigma_a = 0.0\\,\\mathrm{m}^{-1}$，\n  - $v = 1000.0\\,\\mathrm{m/s}$，\n  - $N = 6$，\n  - 最终时间 $T = 0.2\\,\\mathrm{s}$，\n  - 选择 $\\Delta t = \\mu \\cdot \\frac{2}{\\lambda_{\\max,\\mathrm{cons}}}$，其中 $\\mu = 0.9$。演化一致质量和集总质量的半离散系统，并输出布尔值对 $[\\mathrm{positive}_{\\mathrm{cons}}, \\mathrm{positive}_{\\mathrm{lump}}]$，指示所有节点值是否保持非负（如果没有任何节点值超出数值公差变为负值，则为真；无量纲）。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，列表包含三个子列表，按所述测试用例的顺序排列：例如，输出格式必须严格为 $$[[\\mathrm{err}_{\\mathrm{cons}},\\mathrm{err}_{\\mathrm{lump}}],[\\mathrm{stable}_{\\mathrm{cons}},\\mathrm{stable}_{\\mathrm{lump}}],[\\mathrm{positive}_{\\mathrm{cons}},\\mathrm{positive}_{\\mathrm{lump}}]].$$\n\n科学真实性和推导要求：\n- 从通过将控制方程乘以测试函数并在 $[0,L]$ 上积分得到的弱形式出发，对扩散项使用分部积分，并强制齐次 Dirichlet 边界条件。\n- 使用一维线性有限元的标准单元矩阵：一致单元质量矩阵和单元扩散刚度矩阵，并将反应项作为按 $\\beta$ 缩放的类质量贡献加入。\n- 通过对一致内部质量矩阵进行行求和以获得对角近似来定义集总质量矩阵。\n- 使用广义特征值问题 $\\mathbf{K}\\mathbf{u}=\\lambda\\,\\mathbf{M}\\mathbf{u}$ 来评估显式欧拉稳定性极限 $\\Delta t \\le \\frac{2}{\\lambda_{\\max}}$ 并计算瞬态模态衰减。\n- 按照指定的确切格式报告所要求的输出，数值为无量纲值或布尔值，并确保在参数定义中遵守物理单位，但输出中不要求。",
            "solution": "问题陈述经评估有效。它在科学上基于核反应堆物理和数值分析的原理，作为一个初边值问题是适定的，客观的，并为唯一解提供了所有必要的信息。\n\n### 1. 弱形式的推导\n\n给定的瞬态单群中子扩散控制方程为：\n$$\n\\frac{\\partial \\phi}{\\partial t} = \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi, \\quad x \\in [0, L]\n$$\n具有齐次 Dirichlet 边界条件 $\\phi(0,t) = 0$ 和 $\\phi(L,t) = 0$。参数定义为 $\\alpha = vD$ 和 $\\beta = v\\Sigma_a$。\n\n为推导弱形式，我们将方程乘以一个来自 Sobolev 空间 $H_0^1([0,L])$ 的测试函数 $w(x)$，该空间由平方可积、具有平方可积导数且在边界 $x=0$ 和 $x=L$ 处为零的函数组成。然后，我们在空间域 $[0,L]$ 上积分：\n$$\n\\int_0^L w(x) \\frac{\\partial \\phi}{\\partial t} dx = \\int_0^L w(x) \\left( \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} - \\beta \\phi \\right) dx\n$$\n我们对扩散项应用分部积分：\n$$\n\\int_0^L w(x) \\alpha \\frac{\\partial^2 \\phi}{\\partial x^2} dx = \\left[ w(x) \\alpha \\frac{\\partial \\phi}{\\partial x} \\right]_0^L - \\int_0^L \\alpha \\frac{\\partial w}{\\partial x} \\frac{\\partial \\phi}{\\partial x} dx\n$$\n由于测试函数 $w(x) \\in H_0^1([0,L])$，我们有 $w(0) = w(L) = 0$。因此，边界项 $\\left[ w(x) \\alpha \\frac{\\partial \\phi}{\\partial x} \\right]_0^L$ 为零。于是，弱形式问题变为：寻找 $\\phi(x,t)$，使得对于所有 $w(x) \\in H_0^1([0,L])$：\n$$\n\\int_0^L w \\frac{\\partial \\phi}{\\partial t} dx + \\int_0^L \\alpha \\frac{\\partial w}{\\partial x} \\frac{\\partial \\phi}{\\partial x} dx + \\int_0^L \\beta w \\phi dx = 0\n$$\n\n### 2. 有限元离散化\n\n我们将域 $[0,L]$ 离散为 $N$ 个长度为 $h=L/N$ 的均匀单元。我们使用分段线性基函数 $N_j(x)$ 来近似标量通量 $\\phi(x,t)$：\n$$\n\\phi(x,t) \\approx \\phi_h(x,t) = \\sum_{j=1}^{N-1} \\Phi_j(t) N_j(x)\n$$\n求和遍及 $N-1$ 个内部节点，因为节点 $0$ 和 $N$ 处的通量由边界条件固定为 $0$。函数 $N_j(x)$ 是标准的“帽”函数，其中 $N_j(x)$ 在节点 $x_j$ 处为 $1$，在所有其他节点处为 $0$。\n\n使用 Galerkin 方法，我们选择测试函数 $w(x)$ 为基函数 $N_i(x)$，$i=1, \\dots, N-1$。将 $\\phi_h(x,t)$ 的展开式代入弱形式，得到一个常微分方程组：\n$$\n\\sum_{j=1}^{N-1} \\left( \\int_0^L N_i N_j dx \\right) \\frac{d\\Phi_j}{dt} + \\sum_{j=1}^{N-1} \\left( \\int_0^L \\alpha \\frac{dN_i}{dx}\\frac{dN_j}{dx} dx \\right) \\Phi_j + \\sum_{j=1}^{N-1} \\left( \\int_0^L \\beta N_i N_j dx \\right) \\Phi_j = 0\n$$\n该系统可以写成矩阵形式：\n$$\n\\mathbf{M} \\frac{d\\boldsymbol{\\Phi}}{dt} + (\\mathbf{S} + \\beta\\mathbf{M}) \\boldsymbol{\\Phi} = \\mathbf{0}\n$$\n其中 $\\boldsymbol{\\Phi}(t) = [\\Phi_1(t), \\dots, \\Phi_{N-1}(t)]^T$ 是节点通量值的向量。矩阵由其分量定义：\n-   一致质量矩阵: $M_{ij} = \\int_0^L N_i(x) N_j(x) dx$\n-   刚度矩阵: $S_{ij} = \\int_0^L \\alpha \\frac{dN_i(x)}{dx} \\frac{dN_j(x)}{dx} dx$\n\n通过定义组合刚度-反应矩阵 $\\mathbf{K} = \\mathbf{S} + \\beta\\mathbf{M}$，我们得到指定的半离散系统：\n$$\n\\mathbf{M} \\dot{\\boldsymbol{\\Phi}}(t) + \\mathbf{K} \\boldsymbol{\\Phi}(t) = \\mathbf{0}\n$$\n\n### 3. 矩阵组装\n\n全局矩阵由单元级贡献组装而成。对于长度为 $h$ 的通用单元，局部基函数导出以下单元矩阵：\n-   单元质量矩阵: $\\mathbf{m}^e = \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix}$\n-   单元刚度矩阵: $\\mathbf{s}^e = \\frac{\\alpha}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$\n\n为 $N-1$ 个内部自由度组装这些矩阵，得到三对角全局矩阵：\n-   全局一致质量矩阵 $\\mathbf{M}$：\n    -   $M_{ii} = \\frac{4h}{6} = \\frac{2h}{3}$\n    -   $M_{i, i\\pm 1} = \\frac{h}{6}$\n-   全局刚度矩阵 $\\mathbf{S}$：\n    -   $S_{ii} = \\frac{2\\alpha}{h}$\n    -   $S_{i, i\\pm 1} = -\\frac{\\alpha}{h}$\n-   全局刚度-反应矩阵 $\\mathbf{K} = \\mathbf{S} + \\beta\\mathbf{M}$：\n    -   $K_{ii} = \\frac{2\\alpha}{h} + \\beta\\frac{2h}{3}$\n    -   $K_{i, i\\pm 1} = -\\frac{\\alpha}{h} + \\beta\\frac{h}{6}$\n\n集总质量矩阵 $\\mathbf{M}_{\\mathrm{lump}}$ 是通过将一致质量矩阵 $\\mathbf{M}$ 的行相加并将总和放在对角线上形成的。对于 $(N-1) \\times (N-1)$ 的内部矩阵 $\\mathbf{M}$，行和为 $M_{1, \\mathrm{sum}} = M_{N-1, \\mathrm{sum}} = \\frac{4h}{6} + \\frac{h}{6} = \\frac{5h}{6}$，对于 $i=2, \\dots, N-2$，$M_{i, \\mathrm{sum}} = \\frac{h}{6} + \\frac{4h}{6} + \\frac{h}{6} = h$。$\\mathbf{M}_{\\mathrm{lump}}$ 是具有这些值的对角矩阵。\n\n### 4. 时间积分与稳定性分析\n\n半离散系统使用显式向前欧拉法进行时间积分：\n$$\n\\mathbf{M} \\frac{\\boldsymbol{\\Phi}^{n+1} - \\boldsymbol{\\Phi}^n}{\\Delta t} = -\\mathbf{K} \\boldsymbol{\\Phi}^n \\implies \\boldsymbol{\\Phi}^{n+1} = \\boldsymbol{\\Phi}^n - \\Delta t \\mathbf{M}^{-1} \\mathbf{K} \\boldsymbol{\\Phi}^n\n$$\n该方案的稳定性由系统矩阵 $\\mathbf{A} = \\mathbf{M}^{-1}\\mathbf{K}$ 的特征值决定。这些特征值通过求解广义特征值问题 $\\mathbf{K}\\mathbf{u} = \\lambda \\mathbf{M}\\mathbf{u}$ 找到。由于 $\\mathbf{M}$ 和 $\\mathbf{K}$ 是对称正定的，特征值 $\\lambda_i$ 是实数且为正。向前欧拉法的稳定性条件要求对于所有特征值 $\\lambda_i$，都有 $|1 - \\Delta t \\lambda_i| \\le 1$，这可以简化为 $\\Delta t \\lambda_i \\le 2$。这必须对最大特征值成立，从而得到稳定性极限：\n$$\n\\Delta t \\le \\frac{2}{\\lambda_{\\mathrm{max}}}\n$$\n这个条件必须对一致质量 ($\\mathbf{M}$) 和集总质量 ($\\mathbf{M}_{\\mathrm{lump}}$) 系统分别评估，它们会产生不同的最大特征值。\n\n### 5. 解的分析与实现\n\n-   **初始条件**：初始节点向量 $\\boldsymbol{\\Phi}^0$ 是通过在内部节点处评估初始条件 $\\phi(x,0) = \\sin(\\frac{\\pi x}{L})$ 得到的：$\\Phi_j(0) = \\sin(\\frac{\\pi x_j}{L})$，$j=1, \\dots, N-1$。这对应于离散系统的第一本征模。\n-   **模态振幅**：第一模态的解析解为 $\\phi(x,t) = A(t)\\sin(\\frac{\\pi x}{L})$，其中振幅为 $A(t) = \\exp\\left(-\\left(\\alpha(\\frac{\\pi}{L})^2+\\beta\\right)t\\right)$。解向量 $\\boldsymbol{\\Phi}^n$ 沿第一模态形状 $\\mathbf{u}_1 = \\boldsymbol{\\Phi}^0$ 的数值振幅使用一致质量内积 $\\langle \\mathbf{v}, \\mathbf{w} \\rangle_{\\mathbf{M}} = \\mathbf{v}^T \\mathbf{M} \\mathbf{w}$ 来测量：\n    $$\n    A^n_{\\mathrm{num}} = \\frac{\\langle \\boldsymbol{\\Phi}^n, \\mathbf{u}_1 \\rangle_{\\mathbf{M}}}{\\langle \\mathbf{u}_1, \\mathbf{u}_1 \\rangle_{\\mathbf{M}}} = \\frac{(\\boldsymbol{\\Phi}^n)^T \\mathbf{M} \\mathbf{u}_1}{\\mathbf{u}_1^T \\mathbf{M} \\mathbf{u}_1}\n    $$\n    误差是最终时间步长处 $|A^n_{\\mathrm{num}} - A(t_n)|$ 的绝对差。\n-   **正性**：对于情况 3，在每个步骤中检查时间演化的解向量 $\\boldsymbol{\\Phi}^n$。如果任何节点值 $\\Phi_j^n$ 变得小于一个小的数值公差（例如 $-10^{-12}$），则认为解是非正的。众所周知，一致质量有限元法即使在方案稳定时，在某些条件下也可能违反了正性，而集总质量法通常可以解决这个问题。\n\n实现将遵循这些原则，构建矩阵，求解特征值问题以确定时间步长和稳定性，执行时间积分，最后为三个测试用例中的每一个计算所需的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-dependent neutron diffusion equation using FEM\n    and evaluates accuracy, stability, and positivity for three test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Accuracy\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 1.0e-2, 'v': 1000.0, 'N': 40, 'T': 0.5, 'mu': 0.2, 'case': 'accuracy'},\n        # Case 2: Stability\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 1.0e-2, 'v': 1000.0, 'N': 40, 'T': 0, 'mu': 1.01, 'case': 'stability'},\n        # Case 3: Positivity\n        {'L': 1.0, 'D': 1.0e-4, 'Sigma_a': 0.0, 'v': 1000.0, 'N': 6, 'T': 0.2, 'mu': 0.9, 'case': 'positivity'}\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        L = params['L']\n        D = params['D']\n        Sigma_a = params['Sigma_a']\n        v = params['v']\n        N = params['N']\n        T = params['T']\n        mu = params['mu']\n        case = params['case']\n\n        alpha = v * D\n        beta = v * Sigma_a\n        h = L / N\n        dim = N - 1\n\n        # Assemble M (consistent mass) and K (stiffness-reaction) matrices\n        M_cons = np.zeros((dim, dim))\n        S = np.zeros((dim, dim))\n\n        diag_M = 4.0 * h / 6.0\n        offdiag_M = h / 6.0\n        diag_S = 2.0 * alpha / h\n        offdiag_S = -alpha / h\n\n        np.fill_diagonal(M_cons, diag_M)\n        np.fill_diagonal(S, diag_S)\n\n        if dim > 1:\n            np.fill_diagonal(M_cons[1:], offdiag_M)\n            np.fill_diagonal(M_cons[:, 1:], offdiag_M)\n            np.fill_diagonal(S[1:], offdiag_S)\n            np.fill_diagonal(S[:, 1:], offdiag_S)\n\n        K = S + beta * M_cons\n\n        # Form lumped mass matrix\n        M_lump = np.diag(M_cons.sum(axis=1))\n\n        # Compute generalized eigenvalues and max eigenvalue for both systems\n        eigvals_cons = eigh(K, M_cons, eigvals_only=True)\n        lambda_max_cons = np.max(eigvals_cons)\n\n        eigvals_lump = eigh(K, M_lump, eigvals_only=True)\n        lambda_max_lump = np.max(eigvals_lump)\n        \n        dt = mu * 2.0 / lambda_max_cons\n        \n        # Initial condition\n        nodes = np.linspace(h, L - h, dim)\n        phi0 = np.sin(np.pi * nodes / L)\n\n        if case == 'accuracy':\n            num_steps = int(T / dt)\n            final_t = num_steps * dt\n\n            # Evolve with consistent mass\n            phi_cons = phi0.copy()\n            for _ in range(num_steps):\n                rhs = -K @ phi_cons\n                phi_update = np.linalg.solve(M_cons, rhs)\n                phi_cons += dt * phi_update\n            \n            # Evolve with lumped mass\n            phi_lump = phi0.copy()\n            M_lump_inv = np.diag(1.0 / np.diag(M_lump))\n            for _ in range(num_steps):\n                rhs = -K @ phi_lump\n                phi_update = M_lump_inv @ rhs\n                phi_lump += dt * phi_update\n\n            # Measure modal amplitude and error\n            u1_vec = phi0\n            norm_factor = u1_vec.T @ M_cons @ u1_vec\n            \n            amp_cons_num = (phi_cons.T @ M_cons @ u1_vec) / norm_factor\n            amp_lump_num = (phi_lump.T @ M_cons @ u1_vec) / norm_factor\n\n            lambda_analytic = alpha * (np.pi / L)**2 + beta\n            amp_analytic = np.exp(-lambda_analytic * final_t)\n            \n            err_cons = abs(amp_cons_num - amp_analytic)\n            err_lump = abs(amp_lump_num - amp_analytic)\n            all_results.append([err_cons, err_lump])\n\n        elif case == 'stability':\n            stable_cons = dt * lambda_max_cons = 2.0\n            stable_lump = dt * lambda_max_lump = 2.0\n            all_results.append([stable_cons, stable_lump])\n\n        elif case == 'positivity':\n            num_steps = int(T / dt)\n            \n            # Check positivity for consistent mass\n            positive_cons = True\n            phi_cons = phi0.copy()\n            for _ in range(num_steps):\n                rhs = -K @ phi_cons\n                phi_update = np.linalg.solve(M_cons, rhs)\n                phi_cons += dt * phi_update\n                if np.any(phi_cons  -1e-12):\n                    positive_cons = False\n                    break\n            \n            # Check positivity for lumped mass\n            positive_lump = True\n            phi_lump = phi0.copy()\n            M_lump_inv = np.diag(1.0 / np.diag(M_lump))\n            for _ in range(num_steps):\n                rhs = -K @ phi_lump\n                phi_update = M_lump_inv @ rhs\n                phi_lump += dt * phi_update\n                if np.any(phi_lump  -1e-12):\n                    positive_lump = False\n                    break\n            all_results.append([positive_cons, positive_lump])\n\n    # Format the final output string\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        return str(v)\n\n    sublist_strs = []\n    for sublist in all_results:\n        sublist_strs.append(f\"[{','.join(map(format_val, sublist))}]\")\n    \n    print(f\"[{','.join(sublist_strs)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "有限元方法的一大优势在于其能够灵活处理复杂的物理现象，例如各向异性扩散。本练习将带领你将有限元方法应用于包含各向异性扩散张量 $\\mathbf{D}$ 的问题中，这在模拟非均匀堆芯材料时至关重要。你将通过编程计算并量化中子流密度 $\\mathbf{J}$ 与通量负梯度 $-\\nabla \\phi$ 之间的夹角，从而直观地理解各向异性如何导致这两个矢量方向不再平行。",
            "id": "4217883",
            "problem": "考虑二维方形区域上的稳态单能中子扩散近似，其中扩散是各向异性的。设 $\\Omega = [0,1] \\times [0,1]$（单位为米）由一个与笛卡尔坐标轴对齐的协调三角剖分进行离散化。稳态扩散模型旨在求解一个标量中子通量 $\\phi: \\Omega \\rightarrow \\mathbb{R}$，该通量满足以下强形式\n$$\n-\\nabla \\cdot \\left( \\mathbf{D} \\, \\nabla \\phi \\right) + \\Sigma_a \\, \\phi = Q \\quad \\text{in } \\Omega,\n$$\n并带有真空边界条件\n$$\n\\phi = 0 \\quad \\text{on } \\partial \\Omega.\n$$\n此处 $\\mathbf{D} \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定扩散张量，$\\Sigma_a$ 是宏观吸收截面，而 $Q$ 是体积源。粒子流密度由 Fick 定律定义为\n$$\n\\mathbf{J} = -\\mathbf{D} \\, \\nabla \\phi.\n$$\n您需要使用连续有限元法 (CFEM)，在结构化三角剖分上采用一阶 Lagrange 基（分片线性，全局连续）来近似 $\\phi$。从中子平衡定律和粒子流的定义出发，推导弱形式，并概述 CFEM 系统的组装过程。假设系数 $\\mathbf{D}$、$\\Sigma_a$ 和 $Q$ 在 $\\Omega$ 上为常数。在 $\\partial \\Omega$ 上施加 Dirichlet 边界条件 $\\phi=0$。使用均匀的结构化网格，每个空间方向有 $N_x=N_y=20$ 个子区间，并将每个正方形分割成两个与网格对齐的全等三角形。\n\n为分析各向异性对流方向的影响，考虑主方向与网格对齐的扩散张量，即\n$$\n\\mathbf{D} = \\begin{bmatrix} D_x  0 \\\\ 0  D_y \\end{bmatrix},\n$$\n其中 $D_x>0$ 且 $D_y>0$。对于每个三角形单元，计算常数单元梯度 $\\nabla \\phi_e$ 和相应的单元流 $\\mathbf{J}_e = -\\mathbf{D} \\, \\nabla \\phi_e$。将单元不重合角 $\\theta_e$ 定义为 $\\mathbf{J}_e$ 和 $-\\nabla \\phi_e$ 之间的夹角\n$$\n\\theta_e = \\arccos\\left( \\frac{\\mathbf{J}_e \\cdot \\left(-\\nabla \\phi_e\\right)}{\\|\\mathbf{J}_e\\|_2 \\, \\|\\nabla \\phi_e\\|_2} \\right) \\quad \\text{(单位为弧度)}.\n$$\n如果 $\\|\\nabla \\phi_e\\|_2  10^{-12}$，则在计算平均值时排除任何单元 $e$，以避免除以零。对于每组参数，报告所有包含在内的单元的平均不重合角，以度为单位表示，并四舍五入到小数点后六位。\n\n使用以下模型参数（为演示目的而设的科学上合理的数值）：$\\Sigma_a = 0.1 \\ \\text{m}^{-1}$ 和 $Q = 1.0 \\ \\text{neutrons} \\cdot \\text{m}^{-3} \\cdot \\text{s}^{-1}$。考虑四个测试用例，它们改变各向异性比率，同时保持主方向与网格对齐：\n- 测试 $1$：$D_x=1.0$, $D_y=1.0$（各向同性基准）。\n- 测试 $2$：$D_x=5.0$, $D_y=1.0$（中等各向异性）。\n- 测试 $3$：$D_x=0.2$, $D_y=1.0$（中等各向异性反转）。\n- 测试 $4$：$D_x=10.0$, $D_y=1.0$（强各向异性）。\n\n角度单位要求：所有报告的角度必须以度为单位。您的程序的最终输出必须是单行，包含一个 Python 风格的列表，其中包含与上述测试顺序对应的四个平均不重合角，每个角都四舍五入到小数点后六位，例如，\n$[\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4]$,\n其中每个 $\\alpha_i$ 是一个浮点数。\n\n您的程序应生成单行输出，包含用方括号括起来的、以逗号分隔的结果列表（例如，$[result1,result2,result3,result4]$）。",
            "solution": "用户提供了有效的问题陈述。我将继续进行解答。\n\n### 1. 理论公式\n\n该问题要求在二维方形区域 $\\Omega = [0,1] \\times [0,1]$ 上求解稳态单能中子扩散方程。\n\n**强形式：**\n控制偏微分方程 (PDE) 是：\n$$\n-\\nabla \\cdot \\left( \\mathbf{D} \\, \\nabla \\phi \\right) + \\Sigma_a \\, \\phi = Q \\quad \\text{in } \\Omega\n$$\n带有齐次 Dirichlet (真空) 边界条件：\n$$\n\\phi = 0 \\quad \\text{on } \\partial \\Omega\n$$\n此处，$\\phi$ 是标量中子通量，$\\mathbf{D}$ 是各向异性扩散张量，$\\Sigma_a$ 是宏观吸收截面，而 $Q$ 是体积中子源。所有系数都假定在整个区域上为常数。\n\n**弱形式：**\n为推导弱形式，我们将强形式乘以一个测试函数 $v$，该函数属于 Sobolev 空间 $H_0^1(\\Omega)$，此空间包含平方可积、一阶导数平方可积且在边界 $\\partial\\Omega$ 上为零的函数。然后我们在区域 $\\Omega$ 上积分：\n$$\n\\int_\\Omega \\left( -\\nabla \\cdot (\\mathbf{D} \\nabla \\phi) \\right) v \\, d\\Omega + \\int_\\Omega (\\Sigma_a \\phi) v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\n对扩散项应用分部积分（Green 第一恒等式）可得：\n$$\n\\int_\\Omega (\\mathbf{D} \\nabla \\phi) \\cdot \\nabla v \\, d\\Omega - \\int_{\\partial\\Omega} v (\\mathbf{D} \\nabla \\phi) \\cdot \\mathbf{n} \\, dS + \\int_\\Omega \\Sigma_a \\phi v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\n由于测试函数 $v$ 在边界 $\\partial\\Omega$ 上为零，边界积分消失。这便得到了弱形式：求解 $\\phi \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$：\n$$\n\\int_\\Omega (\\mathbf{D} \\nabla \\phi) \\cdot \\nabla v \\, d\\Omega + \\int_\\Omega \\Sigma_a \\phi v \\, d\\Omega = \\int_\\Omega Q v \\, d\\Omega\n$$\n该方程的形式为 $a(\\phi, v) = L(v)$，其中 $a(\\cdot, \\cdot)$ 是代表扩散和吸收的双线性形式，而 $L(\\cdot)$ 是代表源的线性形式。\n\n### 2. 有限元离散化\n\n我们用结构化三角网格对区域 $\\Omega$ 进行离散化。解 $\\phi$ 由函数 $\\phi_h$ 近似，该函数是一阶 Lagrange 基函数 $N_i(x,y)$ 的线性组合：\n$$\n\\phi_h(x, y) = \\sum_j \\phi_j N_j(x, y)\n$$\n其中 $\\phi_j$ 是网格节点上未知的通量值，求和遍及所有通量未知的节点（即内部节点）。基函数 $N_j$ 是一个“帽子”函数，在节点 $j$ 处等于 $1$，在所有其他节点处等于 $0$。\n\n将 $\\phi_h$ 代入弱形式，并选择基函数 $N_i$ 作为测试函数（Galerkin 法），我们得到一个线性代数方程组：\n$$\n\\mathbf{K} \\boldsymbol{\\phi} = \\mathbf{f}\n$$\n其中 $\\boldsymbol{\\phi}$ 是未知节点通量值的向量。全局刚度矩阵 $\\mathbf{K}$ 和全局载荷向量 $\\mathbf{f}$ 的项由以下公式给出：\n$$\nK_{ij} = a(N_j, N_i) = \\int_\\Omega (\\mathbf{D} \\nabla N_j) \\cdot \\nabla N_i \\, d\\Omega + \\int_\\Omega \\Sigma_a N_j N_i \\, d\\Omega\n$$\n$$\nf_i = L(N_i) = \\int_\\Omega Q N_i \\, d\\Omega\n$$\n\n### 3. 系统组装\n\n通过对网格中每个单元 $e$ 的贡献求和来组装全局矩阵和向量。对于单个三角形单元 $e$，计算局部刚度矩阵 $\\mathbf{K}^e$ 和局部载荷向量 $\\mathbf{f}^e$。\n\n单元刚度矩阵 $\\mathbf{K}^e$ 有两个组成部分：\n1.  **扩散（刚度）部分**：由于 $\\mathbf{D}$ 是常数，且线性基函数的梯度在单元上是常数，该项为：\n    $$\n    (\\mathbf{K}^e_{\\text{stiff}})_{ij} = (\\nabla N_i^e)^T \\mathbf{D} (\\nabla N_j^e) A_e\n    $$\n    其中 $\\nabla N_i^e$ 是第 $i$ 个局部基函数的常数梯度，而 $A_e$ 是单元面积。对于对角张量 $\\mathbf{D} = \\text{diag}(D_x, D_y)$，这可以使用三角形的几何特性来计算。\n2.  **吸收（质量）部分**：线性基函数乘积在三角形上的积分是已知的：\n    $$\n    (\\mathbf{K}^e_{\\text{mass}})_{ij} = \\Sigma_a \\int_e N_j^e N_i^e \\, d\\Omega = \\frac{\\Sigma_a A_e}{12} (1 + \\delta_{ij})\n    $$\n\n单元载荷向量 $\\mathbf{f}^e$ 计算如下：\n$$\n(f^e)_i = Q \\int_e N_i^e \\, d\\Omega = \\frac{Q A_e}{3}\n$$\n然后，将这些局部贡献组装成全局系统，由于齐次 Dirichlet 边界条件，仅考虑内部（自由）自由度。然后求解得到的稀疏、对称、正定的线性系统，以获得节点通量值。\n\n### 4. 后处理与不重合角计算\n\n一旦求得节点通量向量 $\\boldsymbol{\\phi}$，近似解 $\\phi_h$ 即为已知。对于每个单元 $e$，通量梯度 $\\nabla \\phi_e$ 是常数，并通过该单元节点通量值加权的基函数梯度的线性组合来计算：\n$$\n\\nabla \\phi_e = \\sum_{j=1}^3 \\phi_j^e \\nabla N_j^e\n$$\n然后使用 Fick 定律计算单元中子流密度 $\\mathbf{J}_e$：\n$$\n\\mathbf{J}_e = -\\mathbf{D} \\nabla \\phi_e\n$$\n流 $\\mathbf{J}_e$ 与负梯度 $-\\nabla \\phi_e$ 之间的不重合角 $\\theta_e$ 量化了扩散各向异性的影响。它使用点积公式计算：\n$$\n\\theta_e = \\arccos\\left( \\frac{\\mathbf{J}_e \\cdot \\left(-\\nabla \\phi_e\\right)}{\\|\\mathbf{J}_e\\|_2 \\, \\|\\nabla \\phi_e\\|_2} \\right) = \\arccos\\left( \\frac{(\\nabla\\phi_e)^T \\mathbf{D} (\\nabla\\phi_e)}{\\|\\mathbf{D} \\nabla\\phi_e\\|_2 \\, \\|\\nabla\\phi_e\\|_2} \\right)\n$$\n梯度范数接近于零 $(\\|\\nabla \\phi_e\\|_2  10^{-12})$ 的单元被排除在外。对于每个测试用例，计算所有包含在内的单元的这些角度的平均值（转换为度）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef calculate_mean_angle(Dx, Dy):\n    \"\"\"\n    Solves the 2D neutron diffusion equation using CFEM and calculates the mean\n    misalignment angle between current and negative flux gradient.\n\n    Args:\n        Dx (float): Diffusion coefficient in the x-direction.\n        Dy (float): Diffusion coefficient in the y-direction.\n\n    Returns:\n        float: The mean misalignment angle in degrees.\n    \"\"\"\n    # Model and Mesh Parameters\n    Nx, Ny = 20, 20\n    Lx, Ly = 1.0, 1.0\n    Sigma_a = 0.1\n    Q = 1.0\n    D_tensor = np.array([[Dx, 0], [0, Dy]])\n\n    # 1. Mesh Generation\n    hx, hy = Lx / Nx, Ly / Ny\n    num_nodes = (Nx + 1) * (Ny + 1)\n    nodes = np.array([[i * hx, j * hy] for j in range(Ny + 1) for i in range(Nx + 1)])\n\n    elements = []\n    for j in range(Ny):\n        for i in range(Nx):\n            n1 = j * (Nx + 1) + i          # bottom-left\n            n2 = j * (Nx + 1) + (i + 1)    # bottom-right\n            n3 = (j + 1) * (Nx + 1) + i      # top-left\n            n4 = (j + 1) * (Nx + 1) + (i + 1)  # top-right\n            # Split square into two triangles along the main diagonal\n            elements.append([n1, n2, n4])\n            elements.append([n1, n4, n3])\n    elements = np.array(elements, dtype=np.int32)\n\n    # 2. Map global indices to interior degrees of freedom\n    num_dof = (Nx - 1) * (Ny - 1)\n    node_map = -np.ones(num_nodes, dtype=int)\n    dof_idx = 0\n    for j in range(1, Ny):\n        for i in range(1, Nx):\n            glob_idx = j * (Nx + 1) + i\n            node_map[glob_idx] = dof_idx\n            dof_idx += 1\n\n    # 3. Assembly of the linear system\n    K = lil_matrix((num_dof, num_dof), dtype=np.float64)\n    f = np.zeros(num_dof, dtype=np.float64)\n\n    mass_local_template = (Sigma_a / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]], dtype=np.float64)\n\n    for elem_nodes in elements:\n        v = nodes[elem_nodes]\n        p1, p2, p3 = v[0], v[1], v[2]\n        \n        area = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area  1e-15: continue\n        \n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        K_stiff_local = (1 / (4 * area)) * (Dx * np.outer(b, b) + Dy * np.outer(c, c))\n        K_mass_local = mass_local_template * area\n        K_local = K_stiff_local + K_mass_local\n        \n        f_local = (Q * area / 3.0) * np.ones(3)\n        \n        for r_local in range(3):\n            glob_r = elem_nodes[r_local]\n            dof_r = node_map[glob_r]\n            if dof_r != -1:  # If row corresponds to an interior node\n                f[dof_r] += f_local[r_local]\n                for c_local in range(3):\n                    glob_c = elem_nodes[c_local]\n                    dof_c = node_map[glob_c]\n                    if dof_c != -1:  # If col corresponds to an interior node\n                        K[dof_r, dof_c] += K_local[r_local, c_local]\n\n    # 4. Solve the linear system\n    K_csc = K.tocsc()\n    phi_interior = spsolve(K_csc, f)\n    \n    phi_full = np.zeros(num_nodes)\n    phi_full[node_map != -1] = phi_interior\n\n    # 5. Post-processing to compute misalignment angles\n    angles_rad = []\n    for elem_nodes in elements:\n        v = nodes[elem_nodes]\n        p1, p2, p3 = v[0], v[1], v[2]\n        \n        area = 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1]))\n        if area  1e-15: continue\n        \n        b = np.array([p2[1] - p3[1], p3[1] - p1[1], p1[1] - p2[1]])\n        c = np.array([p3[0] - p2[0], p1[0] - p3[0], p2[0] - p1[0]])\n        \n        elem_phi_vals = phi_full[elem_nodes]\n        \n        grad_phi_x = np.dot(elem_phi_vals, b) / (2 * area)\n        grad_phi_y = np.dot(elem_phi_vals, c) / (2 * area)\n        grad_phi = np.array([grad_phi_x, grad_phi_y])\n        \n        norm_grad = np.linalg.norm(grad_phi)\n        \n        if norm_grad  1e-12:\n            continue\n            \n        J = -D_tensor @ grad_phi\n        norm_J = np.linalg.norm(J)\n        \n        if norm_J  1e-12:\n            continue\n        \n        cos_theta = (grad_phi @ D_tensor @ grad_phi) / (norm_J * norm_grad)\n        \n        # Clip to handle potential floating point inaccuracies\n        cos_theta = np.clip(cos_theta, -1.0, 1.0)\n        \n        angle_rad = np.arccos(cos_theta)\n        angles_rad.append(angle_rad)\n        \n    mean_angle_rad = np.mean(angles_rad) if angles_rad else 0.0\n    mean_angle_deg = np.degrees(mean_angle_rad)\n    \n    return mean_angle_deg\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0),  # Test 1: Isotropic\n        (5.0, 1.0),  # Test 2: Moderate anisotropy\n        (0.2, 1.0),  # Test 3: Moderate anisotropy inverted\n        (10.0, 1.0), # Test 4: Strong anisotropy\n    ]\n\n    results = []\n    for Dx, Dy in test_cases:\n        result = calculate_mean_angle(Dx, Dy)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n\n```"
        }
    ]
}