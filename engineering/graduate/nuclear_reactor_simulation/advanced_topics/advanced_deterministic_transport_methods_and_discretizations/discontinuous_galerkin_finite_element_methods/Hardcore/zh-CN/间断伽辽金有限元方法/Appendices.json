{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导你为中子扩散方程实现对称内部罚函数伽辽金 (SIPG) 方法，这是间断伽辽金 (DG) 方法求解椭圆型问题的基石。通过从第一性原理出发，显式地推导和计算单元刚度矩阵与界面耦合矩阵，你将深入理解 DG 方法如何通过数值通量和罚项来弱化地施加连续性并保证稳定性。这项实践是掌握 DG-FEM 核心机制的关键一步 。",
            "id": "4222454",
            "problem": "考虑在有限域 $[0,L]$ 上具有真空边界条件的一维板状中子扩散方程，\n$$ -\\frac{d}{dx}\\left(D(x)\\frac{d \\phi(x)}{dx}\\right) + \\Sigma_a(x)\\,\\phi(x) = q(x), \\quad x\\in (0,L), $$\n其中 $D(x)$ 是扩散系数，$\\Sigma_a(x)$ 是宏观吸收截面，$q(x)$ 是体源。就此问题而言，假设 $D(x)$ 和 $\\Sigma_a(x)$ 是单元常数，并专注于构建与左侧算子对应的双线性形式。此问题中的最终数值输出是无量纲的，因为所有构建的矩阵项都是诸如 $D/h$ 和 $\\Sigma_a h$ 之类项的组合，其中 $D$ 的单位是厘米，$\\Sigma_a$ 的单位是厘米的倒数，$h$ 的单位是厘米，从而得到无量纲的乘积和比率。\n\n您必须在均匀网格上，针对多项式次数 $p=1$ 的间断Galerkin离散化，推导并实现对称内部罚函数Galerkin (SIPG) 方法。设域被划分为 $N$ 个均匀单元，每个单元的长度为 $h = L/N$，单元区间为 $K_e = [x_e, x_{e+1}]$。在每个单元上，使用定义为分别对应于单元左右端点的线性Lagrange多项式的局部基函数 $\\varphi_1$ 和 $\\varphi_2$。使用适用于SIPG方法的Nitsche型项来施加真空边界条件。使用定义为\n$$ \\tau = C_{\\mathrm{ip}} \\frac{D}{h}, $$\n的罚参数，其中 $C_{\\mathrm{ip}}$ 是为确保强迫性而选择的正常数。\n\n从第一性原理出发：中子平衡定律和Fick定律为扩散算子提供了理论依据。通过对每个单元进行分部积分，形成单元弱形式。然后，应用SIPG方法，通过使用跳跃和平均，经由内部面耦合单元。使用以下在内部面 $x = x_f$ 处的定义：\n- 左侧单元在其右侧面上的外法线为 $n^- = +1$，右侧单元在其左侧面上的外法线为 $n^+ = -1$。\n- 面上标量场 $w$ 的跳跃为 $[w] = w^- - w^+$，标量场 $a$ 的平均为 $\\{a\\} = \\tfrac{1}{2}(a^- + a^+)$。\n- 对于扩散通量，使用平均法向导数 $\\{D \\,\\partial w/\\partial n\\} = \\tfrac{1}{2}(D^- \\, \\partial w^-/\\partial n^- + D^+ \\, \\partial w^+/\\partial n^+)$。\n\n在 $x=0$ 或 $x=L$ 的Dirichlet边界面上，使用Nitsche项来施加真空边界条件，这些项模仿内部面的SIPG结构，用相对于域边界和边界外法线的单边迹代替平均和跳跃。\n\n您的任务：\n- 根据上述原理，推导以下各项的显式公式：\n  1. 任何单元上对于 $p=1$ 的体积分贡献的单元刚度矩阵。\n  2. 两个相邻单元之间对于 $p=1$ 的内部面耦合矩阵。\n  3. 左边界 ($x=0$) 和右边界 ($x=L$) 上对于 $p=1$ 真空条件的边界面耦合矩阵。\n- 实现一个完整的、可运行的程序，为以下参数集的测试套件计算这些矩阵。所有数值输出都是无量纲的。在每个单元内，基函数必须按 $(\\varphi_1,\\varphi_2)$ 的顺序局部排序。对于内部面矩阵，自由度按 $(\\varphi_1^-,\\varphi_2^-,\\varphi_1^+,\\varphi_2^+)$ 的顺序排序，其中上标 $-$ 和 $+$ 分别指代左侧和右侧单元。\n\n测试套件参数集：\n- 案例1（一般情况）：$L = 30.0$, $N = 3$, $D = 1.2$, $\\Sigma_a = 0.05$, $C_{\\mathrm{ip}} = 2.0$。\n- 案例2（单单元边界情况）：$L = 5.0$, $N = 1$, $D = 0.5$, $\\Sigma_a = 0.2$, $C_{\\mathrm{ip}} = 2.5$。\n- 案例3（小扩散，强吸收）：$L = 2.0$, $N = 2$, $D = 0.01$, $\\Sigma_a = 1.5$, $C_{\\mathrm{ip}} = 1.0$。\n\n程序输出规范：\n- 对于每个案例，计算：\n  - 以行主序扁平化的单元体积分刚度矩阵。\n  - 以行主序扁平化的内部面耦合矩阵；如果没有内部面（对于 $N=1$），则此项返回一个空列表。\n  - 以行主序扁平化的左边界面耦合矩阵。\n  - 以行主序扁平化的右边界面耦合矩阵。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该行必须表示一个列表，每个测试案例占一项，而每一项本身是一个列表，包含四个对应于上述扁平化矩阵的列表，顺序为：单元体积分刚度矩阵、内部面矩阵（或空列表）、左边界面、右边界面。例如，结构应为 $[[\\text{K\\_vol},\\text{F\\_int},\\text{F\\_left},\\text{F\\_right}], \\dots]$，打印在单行上。\n\n所有量都是无量纲的；不需要物理单位转换或角度单位。输出中不出现百分比；只应有浮点数。",
            "solution": "该问题要求推导并实现用于一维中子扩散方程的对称内部罚函数Galerkin (SIPG) 间断Galerkin (DG) 方法的矩阵分量。\n\n一维稳态中子扩散方程由下式给出：\n$$ -\\frac{d}{dx}\\left(D(x)\\frac{d \\phi(x)}{dx}\\right) + \\Sigma_a(x)\\,\\phi(x) = q(x), \\quad x\\in (0,L) $$\n其中 $\\phi(x)$ 是中子标量通量，$D(x)$ 是扩散系数，$\\Sigma_a(x)$ 是宏观吸收截面，$q(x)$ 是外部中子源。\n\n为了推导变分形式，我们乘以一个测试函数 $v(x)$ 并对单个网格单元 $K_e = [x_e, x_{e+1}]$ 进行积分：\n$$ \\int_{K_e} \\left( -\\frac{d}{dx}\\left(D\\frac{d \\phi}{dx}\\right) + \\Sigma_a \\phi \\right) v \\, dx = \\int_{K_e} q v \\, dx $$\n对扩散项应用分部积分可得：\n$$ \\int_{K_e} D \\frac{d\\phi}{dx} \\frac{dv}{dx} \\, dx + \\int_{K_e} \\Sigma_a \\phi v \\, dx - \\left[ D \\frac{d\\phi}{dx} v \\right]_{x_e}^{x_{e+1}} = \\int_{K_e} q v \\, dx $$\n设 $n$ 为单元边界 $\\partial K_e$ 的外法线。在右边界 $x_{e+1}$ 处，$n=1$，在左边界 $x_e$ 处，$n=-1$。边界项可以写成在单元边界上的积分：\n$$ -\\left[ D\\frac{d\\phi}{dx}v \\right]_{x_{e}}^{x_{e+1}} = -\\int_{\\partial K_e} D\\frac{d\\phi}{dx} n v \\, dS $$\n对网格中所有单元 $K_e$ 求和得到全局公式。在DG方法中，解 $\\phi$ 和测试函数 $v$ 在单元面之间是不连续的。单元间的耦合通过数值通量被弱施加。\n\n对应于左侧算子的双线性形式 $B(\\phi, v)$ 的SIPG公式是通过对单元体积分贡献求和并添加内部面和边界面项来构建的。\n$$ B(\\phi, v) = \\sum_{e=1}^{N} \\int_{K_e} \\left(D \\frac{d\\phi}{dx} \\frac{dv}{dx} + \\Sigma_a \\phi v \\right) dx + B_{\\text{faces}}(\\phi, v) $$\n面项 $B_{\\text{faces}}$ 由内部面 ($\\mathcal{F}_I$) 和边界面 ($\\mathcal{F}_B$) 的贡献组成。\n\n对于位于左单元 $K^-$ 和右单元 $K^+$ 之间的内部面 $x=x_f$，我们使用跳跃 $[w] = w^- - w^+$ 和平均 $\\{\\!\\{a\\}\\!\\} = \\frac{1}{2}(a^- + a^+)$ 算子。问题指定了法向通量的平均值 $\\{ D \\nabla w \\}_n = \\frac{1}{2}(D^- (\\nabla w^- \\cdot n^-) + D^+ (\\nabla w^+ \\cdot n^+))$。当 $n^-=+1$ 和 $n^+=-1$ 时，这变为 $\\{ D \\nabla w \\}_n = \\frac{1}{2}(D^- \\frac{dw^-}{dx} - D^+ \\frac{dw^+}{dx})$。所有内部面的SIPG贡献为：\n$$ B_{\\mathcal{F}_I}(\\phi, v) = \\sum_{f \\in \\mathcal{F}_I} \\left( - \\{\\!\\{ D \\nabla \\phi \\}\\!\\}_n [v] - \\{\\!\\{ D \\nabla v \\}\\! \\}_n [\\phi] + \\tau [\\phi][v] \\right) \\Big|_{x_f} $$\n含有 $\\tau$ 的项是罚函数项，其中 $\\tau = C_{\\mathrm{ip}} \\frac{D}{h}$ 是一个确保稳定性的参数。\n\n对于边界 $x=0$ 和 $x=L$ 处的边界面，使用Nitsche方法弱施加真空边界条件 ($\\phi=0$)。这模仿了内部面公式，用相对于域边界和边界外法线的单边迹代替了跳跃和平均。来自边界面的贡献为：\n$$ B_{\\mathcal{F}_B}(\\phi, v) = \\sum_{f \\in \\mathcal{F}_B} \\left( - (D \\nabla \\phi \\cdot n) v - (D \\nabla v \\cdot n) \\phi + \\tau \\phi v \\right) \\Big|_{x_f} $$\n其中 $n$ 是域边界 $\\partial\\Omega$ 的外法线。\n\n我们现在将这些形式特化到尺寸为 $h=L/N$ 的均匀网格和多项式次数 $p=1$ 的情况。在一个单元 $K_e = [x_e, x_{e+1}]$ 上，局部基函数是对应于端点的线性Lagrange多项式：\n$$ \\varphi_1(x) = \\frac{x_{e+1}-x}{h}, \\quad \\varphi_2(x) = \\frac{x-x_e}{h} $$\n它们的导数是常数：\n$$ \\frac{d\\varphi_1}{dx} = -\\frac{1}{h}, \\quad \\frac{d\\varphi_2}{dx} = \\frac{1}{h} $$\n在每个单元上，解和测试函数展开为 $\\phi(x) = \\sum_{j=1}^2 \\phi_j \\varphi_j(x)$ 和 $v(x) = \\sum_{i=1}^2 v_i \\varphi_i(x)$。参数 $D$ 和 $\\Sigma_a$ 在每个单元上是常数。\n\n### 1. 单元体积分刚度矩阵 ($K_{\\text{vol}}$)\n$2 \\times 2$ 单元体积分矩阵的项由下式给出：\n$$ K_{\\text{vol}, ij} = \\int_{K_e} \\left(D \\frac{d\\varphi_j}{dx} \\frac{d\\varphi_i}{dx} + \\Sigma_a \\varphi_j \\varphi_i \\right) dx $$\n该矩阵是来自扩散项的刚度矩阵和来自吸收项的质量矩阵之和。\n刚度分量为：$D \\int_{x_e}^{x_{e+1}} (\\pm \\frac{1}{h})(\\pm \\frac{1}{h}) dx = \\frac{D}{h}$。\n$$ K^D = \\frac{D}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\n质量分量为：$\\Sigma_a \\int_{x_e}^{x_{e+1}} \\varphi_j \\varphi_i dx$。\n$$ M = \\Sigma_a \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} $$\n将这些相加得到完整的单元体积分矩阵：\n$$ K_{\\text{vol}} = \\begin{pmatrix} \\frac{D}{h} + \\frac{\\Sigma_a h}{3}  -\\frac{D}{h} + \\frac{\\Sigma_a h}{6} \\\\ -\\frac{D}{h} + \\frac{\\Sigma_a h}{6}  \\frac{D}{h} + \\frac{\\Sigma_a h}{3} \\end{pmatrix} $$\n\n### 2. 内部面耦合矩阵 ($F_{\\text{int}}$)\n对于单元 $K^-$ 和 $K^+$ 之间的面 $x_f$，自由度排序为 $(\\phi_1^-, \\phi_2^-, \\phi_1^+, \\phi_2^+)$。在面 $x_f=x_{e+1}^- = x_e^+$ 处，基函数的值为：$\\varphi_1^-(x_f)=0, \\varphi_2^-(x_f)=1$ 和 $\\varphi_1^+(x_f)=1, \\varphi_2^+(x_f)=0$。对基函数对计算跳跃项和平均项。得到的 $4 \\times 4$ 矩阵是：\n$$ F_{\\text{int}} = B_{\\mathcal{F}_I}(\\phi, v) \\text{ evaluated for basis functions} $$\n设 $u = (\\phi_1^-, \\phi_2^-, \\phi_1^+, \\phi_2^+)^T$。在面上，$[\\phi] = \\phi_2^- - \\phi_1^+$。平均通量项为 $\\{\\!\\{ D \\nabla \\phi \\}\\!\\}_n = \\frac{D}{2h}(-\\phi_1^-+\\phi_2^-+\\phi_1^+-\\phi_2^+)$，假设 $D$ 在面上是常数。将这些代入SIPG面形式可得：\n$$ F_{\\text{int}} = \\frac{D}{2h} \\begin{pmatrix}\n0   1   -1   0 \\\\\n1   2C_{\\mathrm{ip}}-2   -2C_{\\mathrm{ip}}   1 \\\\\n-1   -2C_{\\mathrm{ip}}   2C_{\\mathrm{ip}}+2   -1 \\\\\n0   1   -1   0\n\\end{pmatrix} $$\n\n### 3. 边界面耦合矩阵 ($F_{\\text{left}}$，$F_{\\text{right}}$)\n这些是加到边单元的单元矩阵上的 $2 \\times 2$ 矩阵。\n- **左边界 ($x=0$)**：面位于第一个单元 $K_1=[0, h]$ 的左侧。域的外法线为 $n=-1$。在 $x=0$ 处，$\\varphi_1(0)=1, \\varphi_2(0)=0$。导数为 $d\\varphi_1/dx=-1/h, d\\varphi_2/dx=1/h$。\n在 $K_1$ 上对基函数对计算边界形式的贡献。\n$$ F_{\\text{left}} = \\begin{pmatrix}\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_1)   B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_1) \\\\\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_2)   B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_2)\n\\end{pmatrix} = \\frac{D}{h} \\begin{pmatrix} C_{\\mathrm{ip}}-2   1 \\\\ 1   0 \\end{pmatrix} $$\n- **右边界 ($x=L$)**：面位于最后一个单元 $K_N=[L-h, L]$ 的右侧。域的外法线为 $n=+1$。在 $x=L$ 处，$\\varphi_1(L)=0, \\varphi_2(L)=1$。\n在 $K_N$ 上对基函数对计算边界形式的贡献。\n$$ F_{\\text{right}} = \\begin{pmatrix}\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_1)   B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_1) \\\\\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_2)   B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_2)\n\\end{pmatrix} = \\frac{D}{h} \\begin{pmatrix} 0   1 \\\\ 1   C_{\\mathrm{ip}}-2 \\end{pmatrix} $$\n\n这些推导出的公式在以下Python程序中实现。",
            "answer": "```python\nimport numpy as np\n\ndef compute_k_vol(D, Sigma_a, h):\n    \"\"\"\n    Computes the 2x2 elemental volume stiffness matrix for p=1.\n    \"\"\"\n    k_vol = np.zeros((2, 2))\n    \n    # Diffusion part: (D/h) * [[1, -1], [-1, 1]]\n    k_vol[0, 0] += D / h\n    k_vol[0, 1] -= D / h\n    k_vol[1, 0] -= D / h\n    k_vol[1, 1] += D / h\n    \n    # Absorption part: (Sigma_a * h / 6) * [[2, 1], [1, 2]]\n    k_vol[0, 0] += Sigma_a * h / 3.0\n    k_vol[0, 1] += Sigma_a * h / 6.0\n    k_vol[1, 0] += Sigma_a * h / 6.0\n    k_vol[1, 1] += Sigma_a * h / 3.0\n    \n    return k_vol\n\ndef compute_f_int(D, h, C_ip):\n    \"\"\"\n    Computes the 4x4 interior face coupling matrix.\n    DOF ordering: (phi_1_left, phi_2_left, phi_1_right, phi_2_right)\n    \"\"\"\n    f_int = np.zeros((4, 4))\n    \n    # Prefactor\n    factor = D / (2.0 * h)\n    \n    # Consistency terms (symmetric part)\n    f_int[0, 1] = 1.0; f_int[1, 0] = 1.0\n    f_int[0, 2] = -1.0; f_int[2, 0] = -1.0\n    f_int[1, 3] = 1.0; f_int[3, 1] = 1.0\n    f_int[2, 3] = -1.0; f_int[3, 2] = -1.0\n    \n    # Consistency terms (diagonal part) and Penalty terms\n    f_int[1, 1] = 2.0 * C_ip - 2.0\n    f_int[2, 2] = 2.0 * C_ip + 2.0\n    \n    # Penalty cross terms\n    f_int[1, 2] = -2.0 * C_ip\n    f_int[2, 1] = -2.0 * C_ip\n    \n    return factor * f_int\n\ndef compute_f_left(D, h, C_ip):\n    \"\"\"\n    Computes the 2x2 left boundary face matrix.\n    \"\"\"\n    f_left = np.zeros((2, 2))\n    factor = D / h\n    \n    f_left[0, 0] = C_ip - 2.0\n    f_left[0, 1] = 1.0\n    f_left[1, 0] = 1.0\n    f_left[1, 1] = 0.0\n    \n    return factor * f_left\n\ndef compute_f_right(D, h, C_ip):\n    \"\"\"\n    Computes the 2x2 right boundary face matrix.\n    \"\"\"\n    f_right = np.zeros((2, 2))\n    factor = D / h\n    \n    f_right[0, 0] = 0.0\n    f_right[0, 1] = 1.0\n    f_right[1, 0] = 1.0\n    f_right[1, 1] = C_ip - 2.0\n    \n    return factor * f_right\n\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and generate output.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=30.0, N=3, D=1.2, Sigma_a=0.05, C_ip=2.0\n        (30.0, 3, 1.2, 0.05, 2.0),\n        # Case 2: L=5.0, N=1, D=0.5, Sigma_a=0.2, C_ip=2.5\n        (5.0, 1, 0.5, 0.2, 2.5),\n        # Case 3: L=2.0, N=2, D=0.01, Sigma_a=1.5, C_ip=1.0\n        (2.0, 2, 0.01, 1.5, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, D, Sigma_a, C_ip = case\n        h = L / N\n\n        # Calculate all required matrices\n        k_vol = compute_k_vol(D, Sigma_a, h)\n        \n        f_int_list = []\n        if N > 1:\n            f_int = compute_f_int(D, h, C_ip)\n            f_int_list = f_int.flatten().tolist()\n\n        f_left = compute_f_left(D, h, C_ip)\n        f_right = compute_f_right(D, h, C_ip)\n\n        # Store results for this case\n        case_result = [\n            k_vol.flatten().tolist(),\n            f_int_list,\n            f_left.flatten().tolist(),\n            f_right.flatten().tolist()\n        ]\n        results.append(case_result)\n\n    # Convert the final list of results to a string without extra spaces.\n    # Standard str() adds spaces, so we build the string manually.\n    def list_to_str(lst):\n        if not isinstance(lst, list):\n            return str(lst)\n        return '[' + ','.join(map(list_to_str, lst)) + ']'\n    \n    # Format each case's result list into a string\n    results_str_list = [list_to_str(res) for res in results]\n    \n    # Join the case strings and print in the final format\n    final_output = '[' + ','.join(results_str_list) + ']'\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "现在我们将注意力从扩散方程转向双曲型的中子输运方程。本练习的核心是为离散纵标 ($S_N$) 方法实现反射边界条件，这在反应堆物理中是处理对称性的常见要求。你将为一个分片常数 DG 离散格式实现输运扫描算法，并使用不动点迭代来处理由反射边界引入的方向耦合 。",
            "id": "4222410",
            "problem": "考虑平板几何中的一维单能稳态中性粒子通量线性输运方程，这是核反应堆模拟中的一个标准子问题。该平板长度为 $L$，被划分为 $K$ 个宽度为 $\\Delta x = L/K$ 的均匀网格。第 $m$ 个离散方向的角通量，记为 $\\psi_m(x)$，满足输运方程\n$$\n\\mu_m \\frac{d \\psi_m(x)}{dx} + \\sigma_t \\psi_m(x) = q,\n$$\n其中 $\\mu_m \\in (-1,1)$ 是第 $m$ 个离散纵标的方向余弦，$\\sigma_t > 0$ 是单位为 $\\mathrm{cm}^{-1}$ 的宏观总截面，而 $q$ 是一个单位为 $\\mathrm{n}\\, \\mathrm{cm}^{-3}\\, \\mathrm{s}^{-1}\\, \\mathrm{sr}^{-1}$ 的常数各向同性体源。角向离散化采用离散纵标法 (S$_N$)，其中 $N$ 为偶数，且在 $[-1,1]$ 上的求积组 $\\{(\\mu_m,w_m)\\}_{m=1}^N$ 是对称的并满足 $\\sum_{m=1}^N w_m = 2$。\n\n空间离散化采用分片常数基函数（多项式次数 $p=0$）的间断伽辽金 (DG) 有限元法。在每个网格 $i \\in \\{0,1,\\dots,K-1\\}$ 上，网格平均未知量为 $\\psi_{m,i} \\approx \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} \\psi_m(x)\\, dx$，界面通量通过迎风数值通量来近似。标量通量近似为\n$$\n\\phi_i = \\sum_{m=1}^N w_m \\psi_{m,i},\n$$\n而全域平均标量通量为\n$$\n\\bar{\\phi} = \\frac{1}{L} \\int_0^L \\phi(x)\\, dx \\approx \\frac{1}{K}\\sum_{i=0}^{K-1} \\phi_i,\n$$\n其单位为 $\\mathrm{n}\\, \\mathrm{cm}^{-2}\\, \\mathrm{s}^{-1}$。\n\n反射边界条件必须通过方向索引映射来实现。在左边界 $x=0$，对于任何 $\\mu_m > 0$（进入区域），入流通量边界值满足\n$$\n\\psi_m(0) = \\psi_{m'}(0) \\quad \\text{其中} \\quad \\mu_{m'} = -\\mu_m.\n$$\n在右边界 $x=L$，对于任何 $\\mu_m  0$（进入区域），入流通量边界值满足\n$$\n\\psi_m(L) = \\psi_{m'}(L) \\quad \\text{其中} \\quad \\mu_{m'} = -\\mu_m.\n$$\n对于真空边界条件，入流通量边界值为零。方向索引映射必须将每个 $\\mu_m$ 与其反射对应方向 $-\\mu_m$ 配对。\n\n从强形式输运方程出发，采用迎风数值通量的 DG 弱形式产生了一个网格平衡关系，该关系将 $\\psi_{m,i}$ 与其迎风邻居和入流通量边界值联系起来。这导致了按方向的扫描。反射边界通过入流项将方向对 $\\mu$ 和 $-\\mu$ 耦合起来。因此，需要实现一个对方向进行迭代的不动点扫描来解决反射边界条件：初始化入流通量边界值，对所有方向执行扫描，通过反射映射更新入流值，并迭代直到入流通量边界值收敛到指定容差内的不动点。\n\n角度单位未使用，因为方向由无量纲的方向余弦 $\\mu_m$ 表示。所有物理量必须以一致的厘米单位制处理。数值求积应使用 $[-1,1]$ 上的 $N$ 点 Gauss–Legendre 求积来定义 $\\{(\\mu_m,w_m)\\}$。\n\n实现一个完整、可运行的程序，该程序：\n- 通过 $[-1,1]$ 上的 $N$ 点 Gauss–Legendre 节点和权重构建 S$_N$ 求积组。\n- 构建采用迎风数值通量的 DG 分片常数（次数 $p=0$）空间离散化。\n- 通过在边界处映射方向索引并使用不动点迭代相应地调整数值通量中的入流项来强制施加反射边界条件。\n- 为每个测试用例计算全域平均标量通量 $\\bar{\\phi}$。\n\n使用以下参数集 $(L, K, \\sigma_t, q, N, \\text{left\\_BC}, \\text{right\\_BC})$ 的测试套件：\n1. $(4.0, 4, 1.0, 1.0, 4, \\text{真空}, \\text{真空})$。\n2. $(4.0, 4, 1.0, 1.0, 4, \\text{反射}, \\text{真空})$。\n3. $(4.0, 4, 1.0, 1.0, 4, \\text{反射}, \\text{反射})$。\n4. $(4.0, 4, 10.0, 1.0, 4, \\text{反射}, \\text{真空})$。\n5. $(4.0, 4, 0.01, 0.0, 4, \\text{反射}, \\text{反射})$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4,result5]”），其中每个结果是全域平均标量通量 $\\bar{\\phi}$，单位为 $\\mathrm{n}\\, \\mathrm{cm}^{-2}\\, \\mathrm{s}^{-1}$，并四舍五入到六位小数。",
            "solution": "一维单能稳态线性输运方程由下式给出：\n$$\n\\mu_m \\frac{d \\psi_m(x)}{dx} + \\sigma_t \\psi_m(x) = q\n$$\n其中：\n- $\\psi_m(x)$ 是第 $m$ 个离散方向的角通量。\n- $\\mu_m \\in (-1, 1)$ 是方向余弦。\n- $\\sigma_t > 0$ 是宏观总截面。\n- $q$ 是一个常数各向同性源项。\n\n角向域使用一个 $N$ 点 Gauss-Legendre 求积组 $\\{(\\mu_m, w_m)\\}_{m=1}^N$ 进行离散化。空间域 $x \\in [0, L]$ 被划分为 $K$ 个宽度为 $\\Delta x = L/K$ 的均匀网格 $I_i = [x_{i-1/2}, x_{i+1/2}]$。\n\n我们应用具有分片常数基函数 ($p=0$) 的 DG 方法。对于每个网格 $I_i$，解由其网格平均值 $\\psi_{m,i}$ 近似。我们将输运方程乘以一个在网格 $I_i$ 上为 $v(x) = 1$（在其他地方为 $0$）的测试函数，并在该网格上积分：\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\mu_m \\frac{d \\psi_m}{dx} + \\sigma_t \\psi_m - q \\right) dx = 0\n$$\n对平流项应用分部积分法得到离散平衡方程：\n$$\n\\frac{\\mu_m}{\\Delta x} (\\hat{\\psi}_{m,i+1/2} - \\hat{\\psi}_{m,i-1/2}) + \\sigma_t \\psi_{m,i} = q\n$$\n其中 $\\hat{\\psi}$ 是迎风数值通量。\n\n可以重新排列离散方程，以根据来自迎风网格的值求解 $\\psi_{m,i}$。\n\n对于正向扫描 ($\\mu_m > 0$)，扫描从左到右进行 ($i=0, \\dots, K-1$)。\n$$\n\\psi_{m,i} = \\frac{q \\Delta x + \\mu_m \\psi_{m,\\text{in}}}{\\sigma_t \\Delta x + \\mu_m}\n$$\n对于反向扫描 ($\\mu_m  0$)，扫描从右到左进行 ($i=K-1, \\dots, 0$)。\n$$\n\\psi_{m,i} = \\frac{q \\Delta x - \\mu_m \\psi_{m,\\text{in}}}{\\sigma_t \\Delta x - \\mu_m}\n$$\n在这些方程中，$\\psi_{m,\\text{in}}$ 是进入当前单元的角通量。\n\n反射边界条件通过将出射角通量映射到对应的入射角通量上来处理，这在方向之间引入了耦合。这种耦合通过不动点迭代来求解：\n1. 对入射边界通量进行初始猜测（例如，对于真空边界为零，对于反射边界也为零）。\n2. 对所有方向进行扫描，计算出整个区域内的角通量。\n3. 使用扫描得到的出射边界通量，通过反射关系更新入射边界通量。\n4. 重复步骤 2-3，直到入射边界通量收敛。\n5. 计算并返回最终的平均标量通量。\n该算法在提供的 Python 代码中实现。",
            "answer": "```python\nimport numpy as np\n\ndef get_quadrature(N):\n    \"\"\"\n    Computes N-point Gauss-Legendre quadrature nodes and weights on [-1, 1].\n\n    Args:\n        N (int): The number of quadrature points (order of S_N).\n\n    Returns:\n        tuple: A tuple containing:\n            - mu (np.ndarray): The direction cosines (nodes), sorted.\n            - w (np.ndarray): The corresponding weights.\n    \"\"\"\n    mu, w = np.polynomial.legendre.leggauss(N)\n    return mu, w\n\ndef build_reflection_map(N):\n    \"\"\"\n    Builds a mapping from a direction index to its reflected-direction index.\n    Assumes a symmetric quadrature set sorted in ascending order.\n\n    Args:\n        N (int): The number of quadrature points.\n\n    Returns:\n        dict: A dictionary mapping index m to its reflection N-1-m.\n    \"\"\"\n    return {m: N - 1 - m for m in range(N)}\n\ndef solve_transport(L, K, sigma_t, q, N, left_bc, right_bc, tol=1e-12, max_iter=1000):\n    \"\"\"\n    Solves the 1D steady-state transport equation using DG-P0.\n\n    Args:\n        L (float): Length of the slab.\n        K (int): Number of spatial cells.\n        sigma_t (float): Macroscopic total cross section.\n        q (float): Isotropic volumetric source.\n        N (int): S_N quadrature order.\n        left_bc (str): Left boundary condition ('vacuum' or 'reflective').\n        right_bc (str): Right boundary condition ('vacuum' or 'reflective').\n        tol (float): Convergence tolerance for fixed-point iteration.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        float: The domain-averaged scalar flux.\n    \"\"\"\n    delta_x = L / K\n    mu, w = get_quadrature(N)\n    reflection_map = build_reflection_map(N)\n\n    # Angular flux psi[m, i] for direction m in cell i\n    psi = np.zeros((N, K))\n\n    # Boundary angular fluxes (inflow only)\n    psi_L_in = np.zeros(N)  # For mu > 0\n    psi_R_in = np.zeros(N)  # For mu  0\n\n    # Fixed-point iteration for reflective boundary conditions\n    for it in range(max_iter):\n        psi_L_in_old = np.copy(psi_L_in)\n        psi_R_in_old = np.copy(psi_R_in)\n        \n        # Sweep over all discrete ordinates\n        for m in range(N):\n            if mu[m] > 0:  # Forward sweep: Left -> Right\n                psi_in = psi_L_in[m]\n                denominator = sigma_t * delta_x + mu[m]\n                for i in range(K):\n                    numerator = q * delta_x + mu[m] * psi_in\n                    psi[m, i] = numerator / denominator\n                    psi_in = psi[m, i]  # Outgoing flux of cell i is incoming for i+1\n            \n            else:  # Backward sweep: Right -> Left (mu[m]  0)\n                psi_in = psi_R_in[m]\n                denominator = sigma_t * delta_x - mu[m]\n                for i in range(K - 1, -1, -1):\n                    numerator = q * delta_x - mu[m] * psi_in\n                    psi[m, i] = numerator / denominator\n                    psi_in = psi[m, i]  # Outgoing flux of cell i is incoming for i-1\n    \n        # Update boundary conditions based on the new sweep results\n        # Left Boundary\n        if left_bc == 'reflective':\n            for m in range(N):\n                if mu[m] > 0:\n                    m_refl = reflection_map[m]\n                    psi_L_in[m] = psi[m_refl, 0]\n        else:  # vacuum\n            # This only needs to be set once, but is harmless in the loop\n            psi_L_in.fill(0.0)\n\n        # Right Boundary\n        if right_bc == 'reflective':\n            for m in range(N):\n                if mu[m]  0:\n                    m_refl = reflection_map[m]\n                    psi_R_in[m] = psi[m_refl, K - 1]\n        else:  # vacuum\n            psi_R_in.fill(0.0)\n\n        # Check for convergence of boundary fluxes.\n        # Only needed if there is at least one reflective boundary.\n        if left_bc == 'vacuum' and right_bc == 'vacuum':\n            break  # No iteration required\n\n        err_L = np.linalg.norm(psi_L_in - psi_L_in_old, np.inf) if left_bc == 'reflective' else 0.0\n        err_R = np.linalg.norm(psi_R_in - psi_R_in_old, np.inf) if right_bc == 'reflective' else 0.0\n        \n        if max(err_L, err_R)  tol:\n            break\n            \n    # Calculate cell-wise scalar flux: phi_i = sum_m(w_m * psi_m,i)\n    phi = np.dot(w, psi)\n\n    # Calculate domain-averaged scalar flux: phi_bar = mean(phi_i)\n    phi_bar = np.mean(phi)\n\n    return phi_bar\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (4.0, 4, 1.0, 1.0, 4, 'vacuum', 'vacuum'),\n        (4.0, 4, 1.0, 1.0, 4, 'reflective', 'vacuum'),\n        (4.0, 4, 1.0, 1.0, 4, 'reflective', 'reflective'),\n        (4.0, 4, 10.0, 1.0, 4, 'reflective', 'vacuum'),\n        (4.0, 4, 0.01, 0.0, 4, 'reflective', 'reflective')\n    ]\n\n    results = []\n    for case in test_cases:\n        L, K, sigma_t, q, N, left_bc, right_bc = case\n        phi_bar = solve_transport(L, K, sigma_t, q, N, left_bc, right_bc)\n        results.append(f\"{phi_bar:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "间断伽辽金 (DG) 方法的一个关键理论优势是其具备单元局域守恒性，而传统的连续伽辽金 (CG) 方法则不具备此特性。本练习要求你利用给定的 DG 和 CG 数值解，对一个多群扩散问题进行后处理分析。通过计算每个单元内的泄漏、移除、慢化和裂变等反应率的平衡，你将能够定量地验证这两种方法的守恒特性差异 。",
            "id": "4222477",
            "problem": "给定一个用于核反应堆模拟的一维、稳态、双能群中子扩散模型。该模型在分区定义域上使用多群扩散近似，并采用连续 Galerkin 有限元法 (CG) 和非连续 Galerkin 有限元法 (DG) 来表示中子通量场。您的任务是在指定的狄利克雷真空边界条件下，通过计算每个能群的泄漏、移出、群内散射和裂变源的单元平衡，来评估局部守恒特性。\n\n基本原理：\n- 稳态、双能群中子扩散方程（针对以群为索引的中子通量 $\\,\\phi_g(x)\\,$，其中 $\\,g \\in \\{1,2\\}\\,$）由下式给出\n$$\n-\\nabla \\cdot \\left( D_g(x) \\nabla \\phi_g(x) \\right) + \\Sigma_{r,g}(x)\\,\\phi_g(x) = \\sum_{\\substack{g' = 1 \\\\ g' \\neq g}}^{2} \\Sigma_{s,g' \\to g}(x)\\,\\phi_{g'}(x) \\;+\\; \\frac{1}{k_{\\mathrm{eff}}}\\,\\chi_g \\sum_{g'=1}^{2} \\nu \\Sigma_{f,g'}(x)\\,\\phi_{g'}(x),\n$$\n其中 $\\,D_g(x)\\,$ 是扩散系数，$\\,\\Sigma_{r,g}(x)\\,$ 是移出截面，$\\,\\Sigma_{s,g' \\to g}(x)\\,$ 是从群 $\\,g'\\,$ 到群 $\\,g\\,$ 的散射截面，$\\,\\nu\\Sigma_{f,g'}(x)\\,$ 是由群 $\\,g'\\,$ 中的裂变产生中子的截面，$\\,\\chi_g\\,$ 是到群 $\\,g\\,$ 的裂变谱份额，$\\,k_{\\mathrm{eff}}\\,$ 是有效增殖因子。\n- 移出的定义为 $\\,\\Sigma_{r,g}(x) = \\Sigma_{a,g}(x) + \\sum_{\\substack{g' = 1 \\\\ g' \\neq g}}^{2} \\Sigma_{s,g \\to g'}(x)\\,$。\n- 定义域是一维的，位置坐标为 $\\,x \\in [0,L]\\,$，横截面积为单位面积，因此所有积分量均为单位面积量。\n- 施加狄利克雷真空边界条件：对于 $\\,g \\in \\{1,2\\}\\,$，有 $\\,\\phi_g(0) = 0\\,$ 和 $\\,\\phi_g(L) = 0\\,$。\n\n单元平衡公式：\n- 对于长度为 $\\,h_K\\,$、在其表面具有向外单位法线 $\\,n\\,$ 的单元 $\\,K\\,$，群 $\\,g\\,$ 的精确连续平衡为\n$$\nB_{K,g} \\;=\\; L_{K,g} \\;+\\; R_{K,g} \\;-\\; S_{K,g}^{\\text{in}} \\;-\\; F_{K,g} \\;=\\; 0,\n$$\n各项定义如下\n$$\nL_{K,g} = -\\int_{\\partial K} J_g \\cdot n \\, ds, \\quad J_g = -D_g \\nabla \\phi_g,\n$$\n$$\nR_{K,g} = \\int_{K} \\Sigma_{r,g}\\,\\phi_g \\, dx,\n$$\n$$\nS_{K,g}^{\\text{in}} = \\int_{K} \\sum_{\\substack{g' = 1 \\\\ g' \\neq g}}^{2} \\Sigma_{s,g' \\to g}\\,\\phi_{g'} \\, dx,\n$$\n$$\nF_{K,g} = \\int_{K} \\frac{1}{k_{\\mathrm{eff}}}\\,\\chi_g \\sum_{g' = 1}^{2} \\nu \\Sigma_{f,g'}\\,\\phi_{g'} \\, dx.\n$$\n- 在连续 Galerkin 有限元法中，每个单元上的通量 $\\,\\phi_g(x)\\,$ 是分段线性的，且在节点处强制执行狄利克雷边界条件。单元泄漏可以通过在单元表面计算物理中子流密度 $\\,J_g = -D_g \\frac{d\\phi_g}{dx}\\,$ 来评估。对于分段线性的 $\\,\\phi_g\\,$，$\\,\\frac{d\\phi_g}{dx}\\,$ 在每个单元上是常数，因此\n$$\nL_{K,g}^{\\mathrm{CG}} = J_g(x_{\\text{left}}) - J_g(x_{\\text{right}}),\n$$\n对于单元上为常数的 $\\,J_g\\,$，该值为零。\n- 在非连续 Galerkin 有限元法中，采用对称内部罚函数法，并且每个单元上的通量 $\\,\\phi_g\\,$ 是分段常数，罚参数为 $\\,\\eta > 0\\,$。相邻单元 $\\,K\\,$ 和 $\\,K'\\,$ 之间一个面上的数值泄漏模型为\n$$\nF_{g}^{\\mathrm{DG}}(K \\leftrightarrow K') = \\frac{\\eta}{h_f}\\left(\\phi_{g,K} - \\phi_{g,K'}\\right),\n$$\n其中 $\\,h_f\\,$ 是局部面的长度（在一维中取 $\\,1\\,$），$\\,\\phi_{g,K}, \\phi_{g,K'}\\,$ 分别是 $\\,K\\,$ 和 $\\,K'\\,$ 上的分段常数通量。在狄利克雷边界处，我们设定 $\\,\\phi_{g,\\text{outside}} = 0\\,$，因此面通量变为 $\\,\\frac{\\eta}{h_f}\\phi_{g,K}\\,$。单元泄漏是其两个面上的总和，\n$$\nL_{K,g}^{\\mathrm{DG}} = \\sum_{f \\subset \\partial K} \\frac{\\eta}{h_f}\\left(\\phi_{g,K} - \\phi_{g,K_f}\\right),\n$$\n其中 $\\,K_f\\,$ 是穿过面 $\\,f\\,$ 的相邻单元，或者是 $\\,\\phi_{g,K_f} = 0\\,$ 的真空外部。\n- 反应、群内散射和裂变源的积分在每个单元上进行精确计算，假设截面为分段常数，且 $\\,\\phi_g\\,$ 要么是分段常数 (DG)，要么是使用其平均值的分段线性函数 (CG)。对于 CG，单元上的平均值是单元端点处节点值的算术平均值。\n\n单位：\n- 所有积分平衡 $\\,B_{K,g}\\,$、泄漏 $\\,L_{K,g}\\,$ 和源项 $\\,R_{K,g}, S_{K,g}^{\\text{in}}, F_{K,g}\\,$ 均以中子数/平方厘米/秒 $\\,(\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1})\\,$ 表示。\n- 角度不出现；不要报告任何百分比。\n\n程序要求：\n- 实现一个独立的 Python 程序，对于每个测试用例，构建指定的网格和材料参数，使用上述公式评估 $\\,B_{K,g}^{\\mathrm{DG}}\\,$ 和 $\\,B_{K,g}^{\\mathrm{CG}}\\,$，并为每个测试用例返回两个浮点值：DG 方法在所有单元和两个能群上的最大绝对单元不平衡量，以及 CG 方法的最大绝对单元不平衡量。这些值必须以十进制数形式报告，单位为 $\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,...]”）。\n\n测试套件：\n- 使用以下三个测试用例，每个用例都有两个能群 $\\,G=2\\,$，定义域长度 $\\,L=8\\,\\mathrm{cm}\\,$，以及四个长度为 $\\,h_K = [2,2,2,2]\\,\\mathrm{cm}\\,$ 的单元：\n    1. 具有中等散射和裂变的正常情况：\n        - 扩散系数 $\\,D_1 = 1.2\\,\\mathrm{cm}\\,$, $\\,D_2 = 0.3\\,\\mathrm{cm}\\,$ (单元常数)。\n        - 吸收截面 $\\,\\Sigma_{a,1} = 0.02\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{a,2} = 0.08\\,\\mathrm{cm}^{-1}\\,$ (单元常数)。\n        - 散射截面：$\\,\\Sigma_{s,1 \\to 2} = 0.05\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{s,2 \\to 1} = 0.002\\,\\mathrm{cm}^{-1}\\,$；无群内散射，无其他非对角元素。\n        - 裂变：$\\,\\nu\\Sigma_{f,1} = 0.0\\,\\mathrm{cm}^{-1}\\,$, $\\,\\nu\\Sigma_{f,2} = 0.15\\,\\mathrm{cm}^{-1}\\,$；裂变谱 $\\,\\chi_1 = 0.6\\,$, $\\,\\chi_2 = 0.4\\,$；$\\,k_{\\mathrm{eff}} = 1.0\\,$。\n        - CG 节点通量 $\\,\\phi_1 = [0.0, 1.0, 0.8, 0.5, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_2 = [0.0, 1.2, 1.0, 0.7, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$，位于节点 $\\,x = [0,2,4,6,8]\\,\\mathrm{cm}\\,$。\n        - DG 单元通量 $\\,\\phi_{1,K} = [0.9, 0.85, 0.6, 0.3]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_{2,K} = [1.1, 0.95, 0.75, 0.35]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$；罚参数 $\\,\\eta = 1.0\\,$。\n    2. 边界主导的纯吸收情况（无散射，无裂变）：\n        - $\\,D_1 = 1.0\\,\\mathrm{cm}\\,$, $\\,D_2 = 0.25\\,\\mathrm{cm}\\,$。\n        - $\\,\\Sigma_{a,1} = 0.05\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{a,2} = 0.20\\,\\mathrm{cm}^{-1}\\,$。\n        - 对于所有 $\\,g \\neq g'\\,$，$\\,\\Sigma_{s,g \\to g'} = 0\\,\\mathrm{cm}^{-1}\\,$。\n        - 对于所有 $\\,g\\,$，$\\,\\nu\\Sigma_{f,g} = 0\\,\\mathrm{cm}^{-1}\\,$；$\\,\\chi_g\\,$ 任意；$\\,k_{\\mathrm{eff}} = 1.0\\,$。\n        - CG 节点通量 $\\,\\phi_1 = [0.0, 0.6, 0.3, 0.1, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_2 = [0.0, 0.9, 0.4, 0.2, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$。\n        - DG 单元通量 $\\,\\phi_{1,K} = [0.5, 0.35, 0.2, 0.05]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_{2,K} = [0.8, 0.45, 0.25, 0.1]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$；$\\,\\eta = 1.0\\,$。\n    3. 强散射和次临界裂变情况：\n        - $\\,D_1 = 1.5\\,\\mathrm{cm}\\,$, $\\,D_2 = 0.4\\,\\mathrm{cm}\\,$。\n        - $\\,\\Sigma_{a,1} = 0.01\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{a,2} = 0.05\\,\\mathrm{cm}^{-1}\\,$。\n        - $\\,\\Sigma_{s,1 \\to 2} = 0.20\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{s,2 \\to 1} = 0.10\\,\\mathrm{cm}^{-1}\\,$。\n        - $\\,\\nu\\Sigma_{f,1} = 0.00\\,\\mathrm{cm}^{-1}\\,$, $\\,\\nu\\Sigma_{f,2} = 0.05\\,\\mathrm{cm}^{-1}\\,$；$\\,\\chi_1 = 0.7\\,$, $\\,\\chi_2 = 0.3\\,$；$\\,k_{\\mathrm{eff}} = 0.95\\,$。\n        - CG 节点通量 $\\,\\phi_1 = [0.0, 0.7, 0.9, 0.6, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_2 = [0.0, 1.0, 1.1, 0.8, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$。\n        - DG 单元通量 $\\,\\phi_{1,K} = [0.6, 0.85, 0.7, 0.4]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_{2,K} = [0.9, 1.05, 0.9, 0.5]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$；$\\,\\eta = 1.0\\,$。\n\n输出规格：\n- 对于三个测试用例中的每一个，计算最大绝对不平衡值 $\\,\\max_{K,g} \\left| B_{K,g}^{\\mathrm{DG}} \\right|\\,$ 和 $\\,\\max_{K,g} \\left| B_{K,g}^{\\mathrm{CG}} \\right|\\,$，并按以下顺序返回包含六个浮点值的单行：\n$$\n\\left[ \\max |B|_{\\mathrm{DG}}^{(1)}, \\; \\max |B|_{\\mathrm{CG}}^{(1)}, \\; \\max |B|_{\\mathrm{DG}}^{(2)}, \\; \\max |B|_{\\mathrm{CG}}^{(2)}, \\; \\max |B|_{\\mathrm{DG}}^{(3)}, \\; \\max |B|_{\\mathrm{CG}}^{(3)} \\right],\n$$\n其中上标表示测试用例索引。确保程序严格按照此单行格式打印。所有值都以 $\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$ 为单位，并应计算为十进制数。",
            "solution": "该任务是使用连续 Galerkin (CG) 和非连续 Galerkin (DG) 有限元法提供的通量解，计算双能群、一维中子扩散问题的单元粒子平衡。目标是为每种方法和三个不同的测试用例，找出最大绝对不平衡量 $\\max_{K,g} |B_{K,g}|$。\n\n单元 $K$ 和能群 $g$ 的基本粒子平衡方程由下式给出：\n$$\nB_{K,g} = L_{K,g} + R_{K,g} - S_{K,g}^{\\text{in}} - F_{K,g}\n$$\n在这里，$L_{K,g}$ 是流出单元的净泄漏率，$R_{K,g}$ 是单元内的总移出率，$S_{K,g}^{\\text{in}}$ 是来自其他能群的群内散射率，$F_{K,g}$ 是裂变产生率。\n\nCG 和 DG 方法的计算因中子通量 $\\phi_g(x)$ 的表示方式和泄漏项的定义而异。\n\n### 非连续 Galerkin (DG) 方法计算\n\n对于 DG 方法，假定中子通量 $\\phi_{g,K}$ 在每个单元 $K$ 上是分段常数。各项的积分为：\n- **移出项 ($R_{K,g}$)**：$R_{K,g} = \\Sigma_{r,g} \\cdot \\phi_{g,K} \\cdot h_K$\n- **群内散射项 ($S_{K,g}^{\\text{in}}$)**：$S_{K,1}^{\\text{in}} = \\Sigma_{s,2 \\to 1} \\cdot \\phi_{2,K} \\cdot h_K$ 和 $S_{K,2}^{\\text{in}} = \\Sigma_{s,1 \\to 2} \\cdot \\phi_{1,K} \\cdot h_K$\n- **裂变项 ($F_{K,g}$)**：$F_{K,g} = \\frac{\\chi_g}{k_{\\mathrm{eff}}} \\left( \\nu\\Sigma_{f,1}\\phi_{1,K} + \\nu\\Sigma_{f,2}\\phi_{2,K} \\right) h_K$\n- **泄漏项 ($L_{K,g}^{\\mathrm{DG}}$)**：单元 $K$ 的 DG 泄漏是其各表面上数值通量的总和。对于一个内部单元 $K_k$ 及其相邻单元 $K_{k-1}$ 和 $K_{k+1}$：$L_{K_k,g}^{\\mathrm{DG}} = \\eta \\left( \\phi_{g,K_k} - \\phi_{g,K_{k-1}} \\right) + \\eta \\left( \\phi_{g,K_k} - \\phi_{g,K_{k+1}} \\right)$。边界单元特殊处理，其外部通量为零。\n\n### 连续 Galerkin (CG) 方法计算\n\n对于 CG 方法，中子通量 $\\phi_g(x)$ 是分段线性的。反应率的积分使用单元上的平均通量来计算，即 $\\phi_{g,\\text{avg},K_k} = (\\phi_{g,k} + \\phi_{g,k+1})/2$。根据问题陈述，泄漏项被定义为零：$L_{K,g}^{\\mathrm{CG}} = 0$。\n\n该算法在以下 Python 代码中实现，用于计算并比较两种方法的不平衡量。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute element-wise balance for CG and DG methods\n    for three test cases of a 1D, 2-group neutron diffusion problem.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Normal case\n        {\n            \"h_K\": [2.0, 2.0, 2.0, 2.0],\n            \"D\": [1.2, 0.3],\n            \"Sigma_a\": [0.02, 0.08],\n            \"Sigma_s_12\": 0.05,\n            \"Sigma_s_21\": 0.002,\n            \"nuSigma_f\": [0.0, 0.15],\n            \"chi\": [0.6, 0.4],\n            \"k_eff\": 1.0,\n            \"eta\": 1.0,\n            \"cg_phi_nodes\": np.array([\n                [0.0, 1.0, 0.8, 0.5, 0.0],  # group 1\n                [0.0, 1.2, 1.0, 0.7, 0.0]   # group 2\n            ]),\n            \"dg_phi_elem\": np.array([\n                [0.9, 0.85, 0.6, 0.3],     # group 1\n                [1.1, 0.95, 0.75, 0.35]    # group 2\n            ])\n        },\n        # Case 2: Pure absorption\n        {\n            \"h_K\": [2.0, 2.0, 2.0, 2.0],\n            \"D\": [1.0, 0.25],\n            \"Sigma_a\": [0.05, 0.20],\n            \"Sigma_s_12\": 0.0,\n            \"Sigma_s_21\": 0.0,\n            \"nuSigma_f\": [0.0, 0.0],\n            \"chi\": [1.0, 0.0], # Arbitrary, as nuSigma_f is zero\n            \"k_eff\": 1.0,\n            \"eta\": 1.0,\n            \"cg_phi_nodes\": np.array([\n                [0.0, 0.6, 0.3, 0.1, 0.0],\n                [0.0, 0.9, 0.4, 0.2, 0.0]\n            ]),\n            \"dg_phi_elem\": np.array([\n                [0.5, 0.35, 0.2, 0.05],\n                [0.8, 0.45, 0.25, 0.1]\n            ])\n        },\n        # Case 3: Strong scattering, subcritical fission\n        {\n            \"h_K\": [2.0, 2.0, 2.0, 2.0],\n            \"D\": [1.5, 0.4],\n            \"Sigma_a\": [0.01, 0.05],\n            \"Sigma_s_12\": 0.20,\n            \"Sigma_s_21\": 0.10,\n            \"nuSigma_f\": [0.0, 0.05],\n            \"chi\": [0.7, 0.3],\n            \"k_eff\": 0.95,\n            \"eta\": 1.0,\n            \"cg_phi_nodes\": np.array([\n                [0.0, 0.7, 0.9, 0.6, 0.0],\n                [0.0, 1.0, 1.1, 0.8, 0.0]\n            ]),\n            \"dg_phi_elem\": np.array([\n                [0.6, 0.85, 0.7, 0.4],\n                [0.9, 1.05, 0.9, 0.5]\n            ])\n        }\n    ]\n\n    final_results = []\n    num_elements = 4\n    num_groups = 2\n\n    for case in test_cases:\n        # Unpack case data\n        h_K_arr = case[\"h_K\"]\n        Sigma_a = case[\"Sigma_a\"]\n        Sigma_s_12 = case[\"Sigma_s_12\"]\n        Sigma_s_21 = case[\"Sigma_s_21\"]\n        nuSigma_f = case[\"nuSigma_f\"]\n        chi = case[\"chi\"]\n        k_eff = case[\"k_eff\"]\n        eta = case[\"eta\"]\n        cg_phi_nodes = case[\"cg_phi_nodes\"]\n        dg_phi_elem = case[\"dg_phi_elem\"]\n        \n        # Derived cross sections\n        Sigma_r = [Sigma_a[0] + Sigma_s_12, Sigma_a[1] + Sigma_s_21]\n\n        # --- DG Calculation ---\n        dg_imbalances = []\n        for k in range(num_elements):\n            h_K = h_K_arr[k]\n            for g_idx in range(num_groups):\n                phi_g_K = dg_phi_elem[g_idx, k]\n                \n                # Removal\n                R_K_g = Sigma_r[g_idx] * phi_g_K * h_K\n\n                # In-scattering\n                if g_idx == 0: # Group 1\n                    phi_gprime_K = dg_phi_elem[1, k]\n                    S_in_K_g = Sigma_s_21 * phi_gprime_K * h_K\n                else: # Group 2\n                    phi_gprime_K = dg_phi_elem[0, k]\n                    S_in_K_g = Sigma_s_12 * phi_gprime_K * h_K\n\n                # Fission\n                fission_prod = (nuSigma_f[0] * dg_phi_elem[0, k] + \n                                nuSigma_f[1] * dg_phi_elem[1, k])\n                F_K_g = (chi[g_idx] / k_eff) * fission_prod * h_K\n\n                # Leakage\n                phi_left_neighbor = dg_phi_elem[g_idx, k - 1] if k > 0 else 0.0\n                phi_right_neighbor = dg_phi_elem[g_idx, k + 1] if k  num_elements - 1 else 0.0\n                L_K_g = eta * (phi_g_K - phi_left_neighbor) + eta * (phi_g_K - phi_right_neighbor)\n\n                # Balance\n                B_K_g = L_K_g + R_K_g - S_in_K_g - F_K_g\n                dg_imbalances.append(abs(B_K_g))\n        \n        final_results.append(max(dg_imbalances) if dg_imbalances else 0.0)\n        \n        # --- CG Calculation ---\n        cg_imbalances = []\n        for k in range(num_elements):\n            h_K = h_K_arr[k]\n            for g_idx in range(num_groups):\n                phi_avg = (cg_phi_nodes[g_idx, k] + cg_phi_nodes[g_idx, k+1]) / 2.0\n\n                # Leakage\n                L_K_g = 0.0\n\n                # Removal\n                R_K_g = Sigma_r[g_idx] * phi_avg * h_K\n\n                # In-scattering\n                if g_idx == 0: # Group 1\n                    phi_gprime_avg = (cg_phi_nodes[1, k] + cg_phi_nodes[1, k+1]) / 2.0\n                    S_in_K_g = Sigma_s_21 * phi_gprime_avg * h_K\n                else: # Group 2\n                    phi_gprime_avg = (cg_phi_nodes[0, k] + cg_phi_nodes[0, k+1]) / 2.0\n                    S_in_K_g = Sigma_s_12 * phi_gprime_avg * h_K\n                \n                # Fission\n                phi1_avg = (cg_phi_nodes[0, k] + cg_phi_nodes[0, k+1]) / 2.0\n                phi2_avg = (cg_phi_nodes[1, k] + cg_phi_nodes[1, k+1]) / 2.0\n                fission_prod = nuSigma_f[0] * phi1_avg + nuSigma_f[1] * phi2_avg\n                F_K_g = (chi[g_idx] / k_eff) * fission_prod * h_K\n\n                # Balance\n                B_K_g = L_K_g + R_K_g - S_in_K_g - F_K_g\n                cg_imbalances.append(abs(B_K_g))\n\n        final_results.append(max(cg_imbalances) if cg_imbalances else 0.0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}