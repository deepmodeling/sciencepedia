{
    "hands_on_practices": [
        {
            "introduction": "Applying the Discontinuous Galerkin (DG) method to diffusion equations is a foundational skill, but it requires a different approach than for first-order problems, involving penalties to ensure stability and convergence. This practice guides you through the from-scratch derivation and implementation of the Symmetric Interior Penalty Galerkin (SIPG) method, one of the most common DG variants for diffusion problems. By constructing the elemental and face-coupling matrices yourself , you will gain a concrete understanding of how DG handles second-order elliptic operators.",
            "id": "4222454",
            "problem": "Consider the one-dimensional slab neutron diffusion equation on a finite domain $[0,L]$ with vacuum boundary conditions,\n$$ -\\frac{d}{dx}\\left(D(x)\\frac{d \\phi(x)}{dx}\\right) + \\Sigma_a(x)\\,\\phi(x) = q(x), \\quad x\\in (0,L), $$\nwhere $D(x)$ is the diffusion coefficient, $\\Sigma_a(x)$ is the macroscopic absorption cross section, and $q(x)$ is a volumetric source. For the purposes of this problem, assume $D(x)$ and $\\Sigma_a(x)$ are elementwise constants, and focus exclusively on constructing the bilinear form corresponding to the left-hand side operator. The final numerical outputs in this problem are dimensionless because all constructed matrix entries are combinations of terms like $D/h$ and $\\Sigma_a h$, with $D$ measured in centimeters and $\\Sigma_a$ in inverse centimeters, and $h$ in centimeters, yielding dimensionless products and ratios.\n\nYou must derive and implement the Symmetric Interior Penalty Galerkin (SIPG) method for a discontinuous Galerkin discretization using polynomial degree $p=1$ on a uniform mesh. Let the domain be partitioned into $N$ uniform elements, each of length $h = L/N$, with element intervals $K_e = [x_e, x_{e+1}]$. On each element, use the local basis functions $\\varphi_1$ and $\\varphi_2$ defined as linear Lagrange polynomials corresponding to the left and right endpoints of the element, respectively. Enforce the vacuum boundary condition using the Nitsche-type terms appropriate for the SIPG method. Use the penalty parameter defined as\n$$ \\tau = C_{\\mathrm{ip}} \\frac{D}{h}, $$\nwhere $C_{\\mathrm{ip}}$ is a positive constant chosen to ensure coercivity.\n\nStart from first principles: the neutron balance law and Fick's law justify the diffusion operator. Form the elemental weak form by integrating by parts elementwise. Then, apply the SIPG approach to couple elements through interior faces by using jumps and averages. Use the following definitions on an interior face located at $x = x_f$:\n- The outward normal for the left element at its right face is $n^- = +1$, and for the right element at its left face is $n^+ = -1$.\n- The jump of a scalar field $w$ at the face is $[w] = w^- - w^+$, and the average of a scalar field $a$ is $\\{a\\} = \\tfrac{1}{2}(a^- + a^+)$.\n- For the diffusive flux, use the averaged normal derivative $\\{D \\,\\partial w/\\partial n\\} = \\tfrac{1}{2}(D^- \\, \\partial w^-/\\partial n^- + D^+ \\, \\partial w^+/\\partial n^+)$.\n\nOn a Dirichlet boundary face at $x=0$ or $x=L$, impose the vacuum boundary condition using Nitsche terms that mirror the interior-face SIPG structure, replacing averages and jumps with one-sided traces relative to the domain boundary and the outward normal of the boundary.\n\nYour tasks:\n- Derive, from the above principles, explicit formulas for:\n  1. The elemental stiffness matrix for the volume contribution on any element for $p=1$.\n  2. The interior-face coupling matrix between two adjacent elements for $p=1$.\n  3. The boundary-face coupling matrix on the left boundary ($x=0$) and on the right boundary ($x=L$) for $p=1$ vacuum conditions.\n- Implement a complete, runnable program that computes these matrices for the following test suite of parameter sets. All numeric outputs are dimensionless. Basis functions must be ordered locally as $(\\varphi_1,\\varphi_2)$ within each element. For an interior face matrix, order the degrees of freedom as $(\\varphi_1^-,\\varphi_2^-,\\varphi_1^+,\\varphi_2^+)$, where the superscripts $-$ and $+$ refer to the left and right elements, respectively.\n\nTest suite parameter sets:\n- Case $1$ (general case): $L = 30.0$, $N = 3$, $D = 1.2$, $\\Sigma_a = 0.05$, $C_{\\mathrm{ip}} = 2.0$.\n- Case $2$ (single-element boundary case): $L = 5.0$, $N = 1$, $D = 0.5$, $\\Sigma_a = 0.2$, $C_{\\mathrm{ip}} = 2.5$.\n- Case $3$ (small diffusion, strong absorption): $L = 2.0$, $N = 2$, $D = 0.01$, $\\Sigma_a = 1.5$, $C_{\\mathrm{ip}} = 1.0$.\n\nProgram output specification:\n- For each case, compute:\n  - The elemental volume stiffness matrix flattened in row-major order.\n  - The interior face coupling matrix flattened in row-major order; if there is no interior face (for $N=1$), return an empty list for this item.\n  - The left boundary-face coupling matrix flattened in row-major order.\n  - The right boundary-face coupling matrix flattened in row-major order.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The line must represent a list with one entry per test case, and each entry is itself a list containing four lists corresponding to the flattened matrices described above, in the order: elemental volume stiffness, interior face matrix (or empty list), left boundary face, right boundary face. For example, the structure should be $[[\\text{K\\_vol},\\text{F\\_int},\\text{F\\_left},\\text{F\\_right}], \\dots]$ printed on one single line.\n\nAll quantities are dimensionless; no physical unit conversion or angle units are required. No percentages appear in the output; only floats are expected.",
            "solution": "The problem requires the derivation and implementation of the matrix components for a Symmetric Interior Penalty Galerkin (SIPG) discontinuous Galerkin (DG) method for the one-dimensional neutron diffusion equation.\n\nThe one-dimensional steady-state neutron diffusion equation is given by:\n$$ -\\frac{d}{dx}\\left(D(x)\\frac{d \\phi(x)}{dx}\\right) + \\Sigma_a(x)\\,\\phi(x) = q(x), \\quad x\\in (0,L) $$\nwhere $\\phi(x)$ is the neutron scalar flux, $D(x)$ is the diffusion coefficient, $\\Sigma_a(x)$ is the macroscopic absorption cross section, and $q(x)$ is an external neutron source.\n\nTo derive the variational formulation, we multiply by a test function $v(x)$ and integrate over a single mesh element $K_e = [x_e, x_{e+1}]$:\n$$ \\int_{K_e} \\left( -\\frac{d}{dx}\\left(D\\frac{d \\phi}{dx}\\right) + \\Sigma_a \\phi \\right) v \\, dx = \\int_{K_e} q v \\, dx $$\nApplying integration by parts to the diffusion term yields:\n$$ \\int_{K_e} D \\frac{d\\phi}{dx} \\frac{dv}{dx} \\, dx + \\int_{K_e} \\Sigma_a \\phi v \\, dx - \\left[ D \\frac{d\\phi}{dx} v \\right]_{x_e}^{x_{e+1}} = \\int_{K_e} q v \\, dx $$\nLet $n$ be the outward normal to the element boundary $\\partial K_e$. At the right boundary $x_{e+1}$, $n=1$, and at the left boundary $x_e$, $n=-1$. The boundary term can be written as an integral over the element boundary:\n$$ -\\left[ D\\frac{d\\phi}{dx}v \\right]_{x_{e}}^{x_{e+1}} = -\\int_{\\partial K_e} D\\frac{d\\phi}{dx} n v \\, dS $$\nSumming over all elements $K_e$ in the mesh gives the global formulation. In the DG method, the solution $\\phi$ and test function $v$ are discontinuous across element faces. The inter-element coupling is enforced weakly through numerical fluxes.\n\nThe SIPG formulation for the bilinear form $B(\\phi, v)$, corresponding to the left-hand side operator, is constructed by summing element-wise volume contributions and adding terms for interior and boundary faces.\n$$ B(\\phi, v) = \\sum_{e=1}^{N} \\int_{K_e} \\left(D \\frac{d\\phi}{dx} \\frac{dv}{dx} + \\Sigma_a \\phi v \\right) dx + B_{\\text{faces}}(\\phi, v) $$\nThe face term $B_{\\text{faces}}$ is composed of contributions from interior faces ($\\mathcal{F}_I$) and boundary faces ($\\mathcal{F}_B$).\n\nFor an interior face at $x=x_f$ between a left element $K^-$ and a right element $K^+$, we use the jump $[w] = w^- - w^+$ and average $\\{\\!\\{a\\}\\!\\} = \\frac{1}{2}(a^- + a^+)$ operators. The SIPG contribution from all interior faces is:\n$$ B_{\\mathcal{F}_I}(\\phi, v) = \\sum_{f \\in \\mathcal{F}_I} \\left( - \\{\\!\\{ D \\nabla \\phi \\}\\!\\}_n [v] - \\{\\!\\{ D \\nabla v \\}\\! \\}_n [\\phi] + \\tau [\\phi][v] \\right) \\Big|_{x_f} $$\nThe term with $\\tau$ is the penalty term, where $\\tau = C_{\\mathrm{ip}} \\frac{D}{h}$ is a parameter ensuring stability.\n\nFor boundary faces at $x=0$ and $x=L$, a vacuum boundary condition ($\\phi=0$) is imposed weakly using Nitsche's method. This mirrors the interior face formulation by replacing jumps and averages with single-sided traces. The contribution from boundary faces is:\n$$ B_{\\mathcal{F}_B}(\\phi, v) = \\sum_{f \\in \\mathcal{F}_B} \\left( - (D \\nabla \\phi \\cdot n) v - (D \\nabla v \\cdot n) \\phi + \\tau \\phi v \\right) \\Big|_{x_f} $$\nwhere $n$ is the outward normal to the domain boundary $\\partial\\Omega$.\n\nWe now specialize these forms for a uniform mesh of size $h=L/N$ and polynomial degree $p=1$. On an element $K_e = [x_e, x_{e+1}]$, the local basis functions are the linear Lagrange polynomials corresponding to the endpoints:\n$$ \\varphi_1(x) = \\frac{x_{e+1}-x}{h}, \\quad \\varphi_2(x) = \\frac{x-x_e}{h} $$\nTheir derivatives are constant:\n$$ \\frac{d\\varphi_1}{dx} = -\\frac{1}{h}, \\quad \\frac{d\\varphi_2}{dx} = \\frac{1}{h} $$\nOn each element, the solution and test function are expanded as $\\phi(x) = \\sum_{j=1}^2 \\phi_j \\varphi_j(x)$ and $v(x) = \\sum_{i=1}^2 v_i \\varphi_i(x)$. The parameters $D$ and $\\Sigma_a$ are constant on each element.\n\n### 1. Elemental Volume Stiffness Matrix ($K_{\\text{vol}}$)\nThe entries of the $2 \\times 2$ elemental volume matrix are given by:\n$$ K_{\\text{vol}, ij} = \\int_{K_e} \\left(D \\frac{d\\varphi_j}{dx} \\frac{d\\varphi_i}{dx} + \\Sigma_a \\varphi_j \\varphi_i \\right) dx $$\nThis matrix is the sum of a stiffness matrix from the diffusion term and a mass matrix from the absorption term.\nThe stiffness components are: $D \\int_{x_e}^{x_{e+1}} (\\pm \\frac{1}{h})(\\pm \\frac{1}{h}) dx = \\frac{D}{h}$.\n$$ K^D = \\frac{D}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} $$\nThe mass components are: $\\Sigma_a \\int_{x_e}^{x_{e+1}} \\varphi_j \\varphi_i dx$.\n$$ M = \\Sigma_a \\frac{h}{6} \\begin{pmatrix} 2  1 \\\\ 1  2 \\end{pmatrix} $$\nSumming these gives the full elemental volume matrix:\n$$ K_{\\text{vol}} = \\begin{pmatrix} \\frac{D}{h} + \\frac{\\Sigma_a h}{3}  -\\frac{D}{h} + \\frac{\\Sigma_a h}{6} \\\\ -\\frac{D}{h} + \\frac{\\Sigma_a h}{6}  \\frac{D}{h} + \\frac{\\Sigma_a h}{3} \\end{pmatrix} $$\n\n### 2. Interior-Face Coupling Matrix ($F_{\\text{int}}$)\nFor a face at $x_f$ between element $K^-$ and $K^+$, the degrees of freedom are ordered $(\\phi_1^-, \\phi_2^-, \\phi_1^+, \\phi_2^+)$. At the face $x_f=x_{e+1}^- = x_e^+$, the only non-zero basis function values are $\\varphi_2^-(x_f)=1$ and $\\varphi_1^+(x_f)=1$. The jumps and averages in the SIPG formulation are evaluated for pairs of basis functions $(\\phi_i, \\phi_j)$. Assembling the contributions for all 16 pairs of basis functions yields the $4 \\times 4$ interior face matrix. The final matrix is:\n$$ F_{\\text{int}} = \\frac{D}{2h} \\begin{pmatrix}\n0  1  -1  0 \\\\\n1  2C_{\\mathrm{ip}}-2  -2C_{\\mathrm{ip}}  1 \\\\\n-1  -2C_{\\mathrm{ip}}  2C_{\\mathrm{ip}}+2  -1 \\\\\n0  1  -1  0\n\\end{pmatrix} $$\n\n### 3. Boundary-Face Coupling Matrices ($F_{\\text{left}}$, $F_{\\text{right}}$)\nThese are $2 \\times 2$ matrices added to the elemental matrix of the boundary element.\n- **Left boundary ($x=0$)**: The face is on the left side of the first element $K_1=[0, h]$. The outward domain normal is $n=-1$. At $x=0$, $\\varphi_1(0)=1, \\varphi_2(0)=0$. The derivatives are $d\\varphi_1/dx=-1/h, d\\varphi_2/dx=1/h$.\nThe boundary form contribution is evaluated for pairs of basis functions on $K_1$.\n$$ F_{\\text{left}} = \\begin{pmatrix}\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_1)  B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_1) \\\\\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_2)  B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_2)\n\\end{pmatrix} = \\frac{D}{h} \\begin{pmatrix} C_{\\mathrm{ip}}-2  1 \\\\ 1  0 \\end{pmatrix} $$\n- **Right boundary ($x=L$)**: The face is on the right side of the last element $K_N=[L-h, L]$. The outward domain normal is $n=+1$. At $x=L$, $\\varphi_1(L)=0, \\varphi_2(L)=1$.\nThe boundary form contribution is evaluated for pairs of basis functions on $K_N$.\n$$ F_{\\text{right}} = \\begin{pmatrix}\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_1)  B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_1) \\\\\nB_{\\mathcal{F}_B}(\\varphi_1,\\varphi_2)  B_{\\mathcal{F}_B}(\\varphi_2,\\varphi_2)\n\\end{pmatrix} = \\frac{D}{h} \\begin{pmatrix} 0  1 \\\\ 1  C_{\\mathrm{ip}}-2 \\end{pmatrix} $$\n\nThese derived formulas are implemented in the following Python program.",
            "answer": "```python\nimport numpy as np\n\ndef compute_k_vol(D, Sigma_a, h):\n    \"\"\"\n    Computes the 2x2 elemental volume stiffness matrix for p=1.\n    \"\"\"\n    k_vol = np.zeros((2, 2))\n    \n    # Diffusion part: (D/h) * [[1, -1], [-1, 1]]\n    k_vol[0, 0] += D / h\n    k_vol[0, 1] -= D / h\n    k_vol[1, 0] -= D / h\n    k_vol[1, 1] += D / h\n    \n    # Absorption part: (Sigma_a * h / 6) * [[2, 1], [1, 2]]\n    k_vol[0, 0] += Sigma_a * h / 3.0\n    k_vol[0, 1] += Sigma_a * h / 6.0\n    k_vol[1, 0] += Sigma_a * h / 6.0\n    k_vol[1, 1] += Sigma_a * h / 3.0\n    \n    return k_vol\n\ndef compute_f_int(D, h, C_ip):\n    \"\"\"\n    Computes the 4x4 interior face coupling matrix.\n    DOF ordering: (phi_1_left, phi_2_left, phi_1_right, phi_2_right)\n    \"\"\"\n    f_int = np.zeros((4, 4))\n    \n    # Prefactor\n    factor = D / (2.0 * h)\n    \n    # Consistency terms (symmetric part)\n    f_int[0, 1] = 1.0; f_int[1, 0] = 1.0\n    f_int[0, 2] = -1.0; f_int[2, 0] = -1.0\n    f_int[1, 3] = 1.0; f_int[3, 1] = 1.0\n    f_int[2, 3] = -1.0; f_int[3, 2] = -1.0\n    \n    # Consistency terms (diagonal part) and Penalty terms\n    f_int[1, 1] = 2.0 * C_ip - 2.0\n    f_int[2, 2] = 2.0 * C_ip + 2.0\n    \n    # Penalty cross terms\n    f_int[1, 2] = -2.0 * C_ip\n    f_int[2, 1] = -2.0 * C_ip\n    \n    return factor * f_int\n\ndef compute_f_left(D, h, C_ip):\n    \"\"\"\n    Computes the 2x2 left boundary face matrix.\n    \"\"\"\n    f_left = np.zeros((2, 2))\n    factor = D / h\n    \n    f_left[0, 0] = C_ip - 2.0\n    f_left[0, 1] = 1.0\n    f_left[1, 0] = 1.0\n    f_left[1, 1] = 0.0\n    \n    return factor * f_left\n\ndef compute_f_right(D, h, C_ip):\n    \"\"\"\n    Computes the 2x2 right boundary face matrix.\n    \"\"\"\n    f_right = np.zeros((2, 2))\n    factor = D / h\n    \n    f_right[0, 0] = 0.0\n    f_right[0, 1] = 1.0\n    f_right[1, 0] = 1.0\n    f_right[1, 1] = C_ip - 2.0\n    \n    return factor * f_right\n\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and generate output.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=30.0, N=3, D=1.2, Sigma_a=0.05, C_ip=2.0\n        (30.0, 3, 1.2, 0.05, 2.0),\n        # Case 2: L=5.0, N=1, D=0.5, Sigma_a=0.2, C_ip=2.5\n        (5.0, 1, 0.5, 0.2, 2.5),\n        # Case 3: L=2.0, N=2, D=0.01, Sigma_a=1.5, C_ip=1.0\n        (2.0, 2, 0.01, 1.5, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, D, Sigma_a, C_ip = case\n        h = L / N\n\n        # Calculate all required matrices\n        k_vol = compute_k_vol(D, Sigma_a, h)\n        \n        f_int_list = []\n        if N > 1:\n            f_int = compute_f_int(D, h, C_ip)\n            f_int_list = f_int.flatten().tolist()\n\n        f_left = compute_f_left(D, h, C_ip)\n        f_right = compute_f_right(D, h, C_ip)\n\n        # Store results for this case\n        case_result = [\n            k_vol.flatten().tolist(),\n            f_int_list,\n            f_left.flatten().tolist(),\n            f_right.flatten().tolist()\n        ]\n        results.append(case_result)\n\n    # Convert the final list of results to a string without extra spaces.\n    # Standard str() adds spaces, so we build the string manually.\n    def list_to_str(lst):\n        if not isinstance(lst, list):\n            return str(lst)\n        return '[' + ','.join(map(list_to_str, lst)) + ']'\n    \n    # Format each case's result list into a string\n    results_str_list = [list_to_str(res) for res in results]\n    \n    # Join the case strings and print in the final format\n    final_output = '[' + ','.join(results_str_list) + ']'\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "While the previous exercise focused on diffusion, DG methods are also powerfully applied to the first-order neutron transport equation. A key challenge in practical simulations is implementing physically realistic boundary conditions, such as reflection, which models symmetry in a reactor core. This exercise  tasks you with implementing a transport sweep algorithm for the discrete ordinates ($S_N$) equations and handling reflective boundaries, which couple different angular directions and necessitate an iterative solution scheme.",
            "id": "4222410",
            "problem": "Consider the one-dimensional, monoenergetic steady-state linear transport equation for neutral particle flux in a slab geometry, which is a standard subproblem in nuclear reactor simulation. The slab has length $L$ partitioned into $K$ uniform cells of width $\\Delta x = L/K$. The angular flux for the $m$-th discrete direction, denoted by $\\psi_m(x)$, satisfies the transport equation\n$$\n\\mu_m \\frac{d \\psi_m(x)}{dx} + \\sigma_t \\psi_m(x) = q,\n$$\nwhere $\\mu_m \\in (-1,1)$ is the direction cosine for the $m$-th discrete ordinate, $\\sigma_t > 0$ is the macroscopic total cross section in $\\mathrm{cm}^{-1}$, and $q$ is a constant isotropic volumetric source in $\\mathrm{n}\\, \\mathrm{cm}^{-3}\\, \\mathrm{s}^{-1}\\, \\mathrm{sr}^{-1}$. The angular discretization is performed using the discrete ordinates method (S$_N$), where $N$ is even and the quadrature set $\\{(\\mu_m,w_m)\\}_{m=1}^N$ on $[-1,1]$ is symmetric and satisfies $\\sum_{m=1}^N w_m = 2$.\n\nThe spatial discretization uses the discontinuous Galerkin (DG) finite element method with piecewise-constant basis functions (polynomial degree $p=0$). On each cell $i \\in \\{0,1,\\dots,K-1\\}$, the cell-averaged unknown is $\\psi_{m,i} \\approx \\frac{1}{\\Delta x}\\int_{x_{i-1/2}}^{x_{i+1/2}} \\psi_m(x)\\, dx$, and interface fluxes are approximated by an upwind numerical flux. The scalar flux is approximated by\n$$\n\\phi_i = \\sum_{m=1}^N w_m \\psi_{m,i},\n$$\nand the domain-averaged scalar flux is\n$$\n\\bar{\\phi} = \\frac{1}{L} \\int_0^L \\phi(x)\\, dx \\approx \\frac{1}{K}\\sum_{i=0}^{K-1} \\phi_i,\n$$\nwith units $\\mathrm{n}\\, \\mathrm{cm}^{-2}\\, \\mathrm{s}^{-1}$.\n\nReflective boundary conditions must be implemented using directional index mapping. At the left boundary $x=0$, for any $\\mu_m  0$ (incoming to the domain), the inflow boundary value satisfies\n$$\n\\psi_m(0) = \\psi_{m'}(0) \\quad \\text{where} \\quad \\mu_{m'} = -\\mu_m.\n$$\nAt the right boundary $x=L$, for any $\\mu_m  0$ (incoming to the domain), the inflow boundary value satisfies\n$$\n\\psi_m(L) = \\psi_{m'}(L) \\quad \\text{where} \\quad \\mu_{m'} = -\\mu_m.\n$$\nFor vacuum boundary conditions, the inflow boundary value is zero. The direction index mapping must pair each $\\mu_m$ with its reflected counterpart $-\\mu_m$.\n\nStarting from the strong form transport equation, the DG weak form with upwind numerical flux yields a cell-wise balance that relates $\\psi_{m,i}$ to its upwind neighbor and the inflow boundary value. This results in a direction-wise sweep. Reflective boundaries couple direction pairs $\\mu$ and $-\\mu$ through the inflow terms. Therefore, implement an iterative fixed-point sweep over directions to resolve reflective boundary conditions: initialize inflow boundary values, perform sweeps for all directions, update inflow values via reflection mappings, and iterate until the inflow boundary values converge to a fixed point within a specified tolerance.\n\nAngle units are not used because the directions are represented by dimensionless direction cosines $\\mu_m$. All physical quantities must be handled in consistent centimeter-based units. The numerical quadrature should use $N$-point Gauss–Legendre quadrature on $[-1,1]$ to define $\\{(\\mu_m,w_m)\\}$.\n\nImplement a complete, runnable program that:\n- Constructs the S$_N$ quadrature via $N$-point Gauss–Legendre nodes and weights on $[-1,1]$.\n- Builds the DG piecewise-constant (degree $p=0$) spatial discretization with upwind numerical flux.\n- Enforces reflective boundary conditions by mapping direction indices at boundaries and adjusting inflow terms in the numerical flux accordingly using a fixed-point iteration.\n- Computes the domain-averaged scalar flux $\\bar{\\phi}$ for each test case.\n\nUse the following test suite of parameter sets $(L, K, \\sigma_t, q, N, \\text{left\\_BC}, \\text{right\\_BC})$:\n1. $(4.0, 4, 1.0, 1.0, 4, \\text{vacuum}, \\text{vacuum})$.\n2. $(4.0, 4, 1.0, 1.0, 4, \\text{reflective}, \\text{vacuum})$.\n3. $(4.0, 4, 1.0, 1.0, 4, \\text{reflective}, \\text{reflective})$.\n4. $(4.0, 4, 10.0, 1.0, 4, \\text{reflective}, \\text{vacuum})$.\n5. $(4.0, 4, 0.01, 0.0, 4, \\text{reflective}, \\text{reflective})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is the domain-averaged scalar flux $\\bar{\\phi}$ in $\\mathrm{n}\\, \\mathrm{cm}^{-2}\\, \\mathrm{s}^{-1}$, rounded to six decimal places.",
            "solution": "The solution proceeds by first deriving the discretized form of the transport equation using a DG spatial discretization with piecewise constant basis functions ($p=0$) and then implementing a numerical solver in Python. The solver will handle vacuum and reflective boundary conditions through an iterative fixed-point scheme.\n\n### 1. Problem Formulation\n\nThe steady-state, one-dimensional, monoenergetic linear transport equation is given by:\n$$\n\\mu_m \\frac{d \\psi_m(x)}{dx} + \\sigma_t \\psi_m(x) = q\n$$\nwhere:\n- $\\psi_m(x)$ is the angular flux for the $m$-th discrete direction.\n- $\\mu_m \\in (-1, 1)$ is the direction cosine.\n- $\\sigma_t > 0$ is the macroscopic total cross section.\n- $q$ is a constant isotropic source term.\n\nThe angular domain is discretized using an $N$-point Gauss-Legendre quadrature set $\\{(\\mu_m, w_m)\\}_{m=1}^N$. The spatial domain $x \\in [0, L]$ is partitioned into $K$ cells $I_i = [x_{i-1/2}, x_{i+1/2}]$ of uniform width $\\Delta x = L/K$.\n\n### 2. Discontinuous Galerkin (DG) Discretization\n\nWe apply the DG method with piecewise constant basis functions ($p=0$). For each cell $I_i$, the solution is approximated by its cell average, $\\psi_{m,i}$. We multiply the transport equation by a test function $v(x) = 1$ over cell $I_i$ (and $0$ elsewhere) and integrate over the cell:\n$$\n\\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\mu_m \\frac{d \\psi_m}{dx} + \\sigma_t \\psi_m - q \\right) dx = 0\n$$\nApplying integration by parts to the advection term yields:\n$$\n\\left[ \\mu_m \\psi_m(x) \\right]_{x_{i-1/2}}^{x_{i+1/2}} + \\int_{x_{i-1/2}}^{x_{i+1/2}} (\\sigma_t \\psi_m - q) dx = 0\n$$\n$$\n\\mu_m (\\psi_m(x_{i+1/2}) - \\psi_m(x_{i-1/2})) + \\sigma_t \\psi_{m,i} \\Delta x - q \\Delta x = 0\n$$\nThe discontinuous flux values at the cell interfaces, $\\psi_m(x_{i\\pm1/2})$, are replaced by a single-valued numerical flux, denoted $\\hat{\\psi}_m$. The problem specifies an upwind numerical flux, which is determined by the sign of $\\mu_m$:\n- At interface $x_{i+1/2}$: $\\hat{\\psi}_{m, i+1/2} = \\begin{cases} \\psi_{m,i}  \\text{if } \\mu_m  0 \\\\ \\psi_{m,i+1}  \\text{if } \\mu_m  0 \\end{cases}$\n- At interface $x_{i-1/2}$: $\\hat{\\psi}_{m, i-1/2} = \\begin{cases} \\psi_{m,i-1}  \\text{if } \\mu_m  0 \\\\ \\psi_{m,i}  \\text{if } \\mu_m  0 \\end{cases}$\n\nSubstituting the numerical flux and dividing by $\\Delta x$ gives the discrete balance equation for cell $i$:\n$$\n\\frac{\\mu_m}{\\Delta x} (\\hat{\\psi}_{m,i+1/2} - \\hat{\\psi}_{m,i-1/2}) + \\sigma_t \\psi_{m,i} = q\n$$\n\n### 3. Transport Sweep Algorithm\n\nThe discrete equation can be rearranged to solve for $\\psi_{m,i}$ based on the value from the upwind cell. This leads to a sweep across the domain for each direction $\\mu_m$.\n\n**Case 1: Forward Sweep ($\\mu_m  0$)**\nThe sweep proceeds from left to right ($i=0, \\dots, K-1$). The upwind fluxes are $\\hat{\\psi}_{m,i+1/2} = \\psi_{m,i}$ and $\\hat{\\psi}_{m,i-1/2} = \\psi_{m,\\text{in}}$, where $\\psi_{m,\\text{in}}$ is the influx to cell $i$ (i.e., $\\psi_{m,i-1}$ for $i0$ and the left boundary flux for $i=0$).\n$$\n\\frac{\\mu_m}{\\Delta x} (\\psi_{m,i} - \\psi_{m,\\text{in}}) + \\sigma_t \\psi_{m,i} = q\n$$\nSolving for $\\psi_{m,i}$:\n$$\n\\psi_{m,i} = \\frac{q \\Delta x + \\mu_m \\psi_{m,\\text{in}}}{\\sigma_t \\Delta x + \\mu_m}\n$$\n\n**Case 2: Backward Sweep ($\\mu_m  0$)**\nThe sweep proceeds from right to left ($i=K-1, \\dots, 0$). The upwind fluxes are $\\hat{\\psi}_{m,i+1/2} = \\psi_{m,\\text{in}}$ and $\\hat{\\psi}_{m,i-1/2} = \\psi_{m,i}$. $\\psi_{m,\\text{in}}$ is the influx to cell $i$ (i.e., $\\psi_{m,i+1}$ for $iK-1$ and the right boundary flux for $i=K-1$).\n$$\n\\frac{\\mu_m}{\\Delta x} (\\psi_{m,\\text{in}} - \\psi_{m,i}) + \\sigma_t \\psi_{m,i} = q\n$$\nSolving for $\\psi_{m,i}$:\n$$\n\\psi_{m,i} = \\frac{q \\Delta x - \\mu_m \\psi_{m,\\text{in}}}{\\sigma_t \\Delta x - \\mu_m}\n$$\n\n### 4. Boundary Conditions and Fixed-Point Iteration\n\n- **Vacuum Boundaries**: The inflow flux is zero. For $\\mu_m  0$, the left boundary flux is $0$. For $\\mu_m  0$, the right boundary flux is $0$.\n\n- **Reflective Boundaries**: The inflow flux at a boundary for a direction $\\mu_m$ is equal to the outgoing flux for the reflected direction $\\mu_{m'} = -\\mu_m$.\n    - Left boundary ($x=0$): For $\\mu_m  0$, the inflow is $\\psi_m^{\\text{L}} = \\psi_{m',0}$, where $\\mu_{m'} = -\\mu_m$.\n    - Right boundary ($x=L$): For $\\mu_m  0$, the inflow is $\\psi_m^{\\text{R}} = \\psi_{m',K-1}$, where $\\mu_{m'} = -\\mu_m$.\n\nThe inter-directional coupling introduced by reflective boundaries necessitates an iterative solution. A fixed-point iteration is employed:\n1.  Initialize all boundary inflow fluxes (e.g., to $0$).\n2.  Begin iteration:\n    a. Store the current boundary inflow values.\n    b. For each direction $m=1, \\dots, N$, perform a transport sweep using the current boundary inflow values to compute all cell-averaged angular fluxes $\\psi_{m,i}$.\n    c. After all sweeps are complete, update the boundary inflow values based on the reflective boundary conditions using the newly computed cell-averaged fluxes. For vacuum boundaries, the inflow remains $0$.\n    d. Check for convergence by comparing the new boundary inflow values with the stored old values. If the change (e.g., in the infinity norm) is below a tolerance, the iteration has converged. Otherwise, repeat from step (2a).\n\n### 5. Final Calculation\n\nOnce the angular fluxes $\\psi_{m,i}$ have converged, the cell-wise scalar flux is computed by integrating over all angles:\n$$\n\\phi_i = \\sum_{m=1}^N w_m \\psi_{m,i}\n$$\nThe domain-averaged scalar flux is the arithmetic mean of the cell-wise scalar fluxes:\n$$\n\\bar{\\phi} = \\frac{1}{K} \\sum_{i=0}^{K-1} \\phi_i\n$$\nThis quantity is calculated for each test case provided. The Gauss-Legendre quadrature points $\\mu_m$ and weights $w_m$ are symmetric, which simplifies the mapping between a direction and its reflection. If the quadrature points are sorted, then for direction index $m$, the reflected direction index is $m' = N - 1 - m$.",
            "answer": "```python\nimport numpy as np\n\ndef get_quadrature(N):\n    \"\"\"\n    Computes N-point Gauss-Legendre quadrature nodes and weights on [-1, 1].\n\n    Args:\n        N (int): The number of quadrature points (order of S_N).\n\n    Returns:\n        tuple: A tuple containing:\n            - mu (np.ndarray): The direction cosines (nodes), sorted.\n            - w (np.ndarray): The corresponding weights.\n    \"\"\"\n    mu, w = np.polynomial.legendre.leggauss(N)\n    return mu, w\n\ndef build_reflection_map(N):\n    \"\"\"\n    Builds a mapping from a direction index to its reflected-direction index.\n    Assumes a symmetric quadrature set sorted in ascending order.\n\n    Args:\n        N (int): The number of quadrature points.\n\n    Returns:\n        dict: A dictionary mapping index m to its reflection N-1-m.\n    \"\"\"\n    return {m: N - 1 - m for m in range(N)}\n\ndef solve_transport(L, K, sigma_t, q, N, left_bc, right_bc, tol=1e-12, max_iter=1000):\n    \"\"\"\n    Solves the 1D steady-state transport equation using DG-P0.\n\n    Args:\n        L (float): Length of the slab.\n        K (int): Number of spatial cells.\n        sigma_t (float): Macroscopic total cross section.\n        q (float): Isotropic volumetric source.\n        N (int): S_N quadrature order.\n        left_bc (str): Left boundary condition ('vacuum' or 'reflective').\n        right_bc (str): Right boundary condition ('vacuum' or 'reflective').\n        tol (float): Convergence tolerance for fixed-point iteration.\n        max_iter (int): Maximum number of iterations.\n\n    Returns:\n        float: The domain-averaged scalar flux.\n    \"\"\"\n    delta_x = L / K\n    mu, w = get_quadrature(N)\n    reflection_map = build_reflection_map(N)\n\n    # Angular flux psi[m, i] for direction m in cell i\n    psi = np.zeros((N, K))\n\n    # Boundary angular fluxes (inflow only)\n    psi_L_in = np.zeros(N)  # For mu > 0\n    psi_R_in = np.zeros(N)  # For mu  0\n\n    # Fixed-point iteration for reflective boundary conditions\n    for it in range(max_iter):\n        psi_L_in_old = np.copy(psi_L_in)\n        psi_R_in_old = np.copy(psi_R_in)\n        \n        # Sweep over all discrete ordinates\n        for m in range(N):\n            if mu[m] > 0:  # Forward sweep: Left -> Right\n                psi_in = psi_L_in[m]\n                denominator = sigma_t * delta_x + mu[m]\n                for i in range(K):\n                    numerator = q * delta_x + mu[m] * psi_in\n                    psi[m, i] = numerator / denominator\n                    psi_in = psi[m, i]  # Outgoing flux of cell i is incoming for i+1\n            \n            else:  # Backward sweep: Right -> Left (mu[m]  0)\n                psi_in = psi_R_in[m]\n                denominator = sigma_t * delta_x - mu[m]\n                for i in range(K - 1, -1, -1):\n                    numerator = q * delta_x - mu[m] * psi_in\n                    psi[m, i] = numerator / denominator\n                    psi_in = psi[m, i]  # Outgoing flux of cell i is incoming for i-1\n    \n        # Update boundary conditions based on the new sweep results\n        # Left Boundary\n        if left_bc == 'reflective':\n            for m in range(N):\n                if mu[m] > 0:\n                    m_refl = reflection_map[m]\n                    psi_L_in[m] = psi[m_refl, 0]\n        else:  # vacuum\n            # This only needs to be set once, but is harmless in the loop\n            psi_L_in.fill(0.0)\n\n        # Right Boundary\n        if right_bc == 'reflective':\n            for m in range(N):\n                if mu[m]  0:\n                    m_refl = reflection_map[m]\n                    psi_R_in[m] = psi[m_refl, K - 1]\n        else:  # vacuum\n            psi_R_in.fill(0.0)\n\n        # Check for convergence of boundary fluxes.\n        # Only needed if there is at least one reflective boundary.\n        if left_bc == 'vacuum' and right_bc == 'vacuum':\n            break  # No iteration required\n\n        err_L = np.linalg.norm(psi_L_in - psi_L_in_old, np.inf) if left_bc == 'reflective' else 0.0\n        err_R = np.linalg.norm(psi_R_in - psi_R_in_old, np.inf) if right_bc == 'reflective' else 0.0\n        \n        if max(err_L, err_R)  tol:\n            break\n            \n    # Calculate cell-wise scalar flux: phi_i = sum_m(w_m * psi_m,i)\n    phi = np.dot(w, psi)\n\n    # Calculate domain-averaged scalar flux: phi_bar = mean(phi_i)\n    phi_bar = np.mean(phi)\n\n    return phi_bar\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (4.0, 4, 1.0, 1.0, 4, 'vacuum', 'vacuum'),\n        (4.0, 4, 1.0, 1.0, 4, 'reflective', 'vacuum'),\n        (4.0, 4, 1.0, 1.0, 4, 'reflective', 'reflective'),\n        (4.0, 4, 10.0, 1.0, 4, 'reflective', 'vacuum'),\n        (4.0, 4, 0.01, 0.0, 4, 'reflective', 'reflective')\n    ]\n\n    results = []\n    for case in test_cases:\n        L, K, sigma_t, q, N, left_bc, right_bc = case\n        phi_bar = solve_transport(L, K, sigma_t, q, N, left_bc, right_bc)\n        results.append(f\"{phi_bar:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "One of the most celebrated properties of DG methods is their ability to enforce local (element-wise) conservation of particles, a feature not generally shared by standard Continuous Galerkin (CG) methods. In this practice, you will perform a post-processing analysis using provided flux solutions from both DG and CG methods . By calculating the element-wise balance of all physical processes—leakage, absorption, scattering, and fission—you will quantitatively demonstrate the conservation properties inherent to the DG formulation.",
            "id": "4222477",
            "problem": "You are given a one-dimensional, steady-state, two-energy-group neutron diffusion model for nuclear reactor simulation. The model uses the multi-group diffusion approximation on a partitioned domain with both a continuous Galerkin finite element method (CG) and a discontinuous Galerkin finite element method (DG) representation of the neutron flux fields. Your task is to evaluate local conservation properties by computing element-wise balances of leakage, removal, in-scattering, and fission sources for each energy group, under specified Dirichlet vacuum boundary conditions.\n\nFundamental base:\n- The steady-state, two-group neutron diffusion equations for group-indexed neutron fluxes $\\,\\phi_g(x)\\,$, with $\\,g \\in \\{1,2\\}\\,$, are given by\n$$\n-\\nabla \\cdot \\left( D_g(x) \\nabla \\phi_g(x) \\right) + \\Sigma_{r,g}(x)\\,\\phi_g(x) = \\sum_{\\substack{g' = 1 \\\\ g' \\neq g}}^{2} \\Sigma_{s,g' \\to g}(x)\\,\\phi_{g'}(x) \\;+\\; \\frac{1}{k_{\\mathrm{eff}}}\\,\\chi_g \\sum_{g'=1}^{2} \\nu \\Sigma_{f,g'}(x)\\,\\phi_{g'}(x),\n$$\nwhere $\\,D_g(x)\\,$ is the diffusion coefficient, $\\,\\Sigma_{r,g}(x)\\,$ is the removal cross section, $\\,\\Sigma_{s,g' \\to g}(x)\\,$ is the scattering cross section from group $\\,g'\\,$ to group $\\,g\\,$, $\\,\\nu\\Sigma_{f,g'}(x)\\,$ is the neutron production cross section from fission in group $\\,g'\\,$, $\\,\\chi_g\\,$ is the fission spectrum fraction to group $\\,g\\,$, and $\\,k_{\\mathrm{eff}}\\,$ is the effective multiplication factor.\n- Removal is defined as $\\,\\Sigma_{r,g}(x) = \\Sigma_{a,g}(x) + \\sum_{\\substack{g' = 1 \\\\ g' \\neq g}}^{2} \\Sigma_{s,g \\to g'}(x)\\,$.\n- The domain is one-dimensional with position coordinate $\\,x \\in [0,L]\\,$ and a unit cross-sectional area, so all integrated quantities are per unit area.\n- Dirichlet vacuum boundary conditions are imposed: $\\,\\phi_g(0) = 0\\,$ and $\\,\\phi_g(L) = 0\\,$ for $\\,g \\in \\{1,2\\}\\,$.\n\nElement-wise balance formulation:\n- For an element $\\,K\\,$ with length $\\,h_K\\,$ and outward unit normals $\\,n\\,$ at its faces, the exact continuous balance for group $\\,g\\,$ is\n$$\nB_{K,g} \\;=\\; L_{K,g} \\;+\\; R_{K,g} \\;-\\; S_{K,g}^{\\text{in}} \\;-\\; F_{K,g} \\;=\\; 0,\n$$\nwith terms defined as\n$$\nL_{K,g} = -\\int_{\\partial K} J_g \\cdot n \\, ds, \\quad J_g = -D_g \\nabla \\phi_g,\n$$\n$$\nR_{K,g} = \\int_{K} \\Sigma_{r,g}\\,\\phi_g \\, dx,\n$$\n$$\nS_{K,g}^{\\text{in}} = \\int_{K} \\sum_{\\substack{g' = 1 \\\\ g' \\neq g}}^{2} \\Sigma_{s,g' \\to g}\\,\\phi_{g'} \\, dx,\n$$\n$$\nF_{K,g} = \\int_{K} \\frac{1}{k_{\\mathrm{eff}}}\\,\\chi_g \\sum_{g' = 1}^{2} \\nu \\Sigma_{f,g'}\\,\\phi_{g'} \\, dx.\n$$\n- Under the continuous Galerkin finite element method with piecewise linear flux $\\,\\phi_g(x)\\,$ on each element and Dirichlet boundary conditions enforced at nodes, the element leakage can be evaluated by using the physical current $\\,J_g = -D_g \\frac{d\\phi_g}{dx}\\,$ evaluated at the element faces. For a piecewise linear $\\,\\phi_g\\,$, $\\,\\frac{d\\phi_g}{dx}\\,$ is constant on each element, so\n$$\nL_{K,g}^{\\mathrm{CG}} = J_g(x_{\\text{left}}) - J_g(x_{\\text{right}}),\n$$\nwhich is zero for constant $\\,J_g\\,$ on the element.\n- Under the discontinuous Galerkin finite element method with a symmetric interior penalty approach and piecewise constant flux $\\,\\phi_g\\,$ on each element, with penalty parameter $\\,\\eta > 0\\,$, the numerical leakage across a face between neighboring elements $\\,K\\,$ and $\\,K'\\,$ is modeled as\n$$\nF_{g}^{\\mathrm{DG}}(K \\leftrightarrow K') = \\frac{\\eta}{h_f}\\left(\\phi_{g,K} - \\phi_{g,K'}\\right),\n$$\nwhere $\\,h_f\\,$ is the local face length (taken as $\\,1\\,$ in one dimension) and $\\,\\phi_{g,K}, \\phi_{g,K'}\\,$ are the piecewise constant fluxes on $\\,K\\,$ and $\\,K'\\,$, respectively. At a Dirichlet boundary, we model $\\,\\phi_{g,\\text{outside}} = 0\\,$, so the face flux becomes $\\,\\frac{\\eta}{h_f}\\phi_{g,K}\\,$. The element leakage is the sum over its two faces,\n$$\nL_{K,g}^{\\mathrm{DG}} = \\sum_{f \\subset \\partial K} \\frac{\\eta}{h_f}\\left(\\phi_{g,K} - \\phi_{g,K_f}\\right),\n$$\nwith $\\,K_f\\,$ the neighbor across face $\\,f\\,$ or the vacuum exterior with $\\,\\phi_{g,K_f} = 0\\,$.\n- The reaction, in-scattering, and fission source integrals are computed exactly on each element by assuming piecewise constant cross sections and either piecewise constant $\\,\\phi_g\\,$ (DG) or piecewise linear $\\,\\phi_g\\,$ whose average value is used (CG). For CG, the average value on an element is the arithmetic mean of the nodal values at the element endpoints.\n\nUnits:\n- Express all integrated balances $\\,B_{K,g}\\,$, leakages $\\,L_{K,g}\\,$, and sources $\\,R_{K,g}, S_{K,g}^{\\text{in}}, F_{K,g}\\,$ in neutrons per square centimeter per second $\\,(\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1})\\,$.\n- Angles do not appear; do not report any percentages.\n\nProgram requirements:\n- Implement a self-contained Python program that, for each test case, constructs the specified mesh and material parameters, evaluates $\\,B_{K,g}^{\\mathrm{DG}}\\,$ and $\\,B_{K,g}^{\\mathrm{CG}}\\,$ using the formulas above, and returns for each test case two floating-point values: the maximum absolute element-wise imbalance magnitude over all elements and both energy groups for DG, and the maximum absolute element-wise imbalance magnitude for CG. The values must be reported in $\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$ as decimal numbers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,...]\").\n\nTest suite:\n- Use the following three test cases, each with two energy groups $\\,G=2\\,$, domain length $\\,L=8\\,\\mathrm{cm}\\,$, and four elements of lengths $\\,h_K = [2,2,2,2]\\,\\mathrm{cm}\\,$:\n    1. Happy path case with moderate scattering and fission:\n        - Diffusion coefficients $\\,D_1 = 1.2\\,\\mathrm{cm}\\,$, $\\,D_2 = 0.3\\,\\mathrm{cm}\\,$ (element-wise constant).\n        - Absorption cross sections $\\,\\Sigma_{a,1} = 0.02\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{a,2} = 0.08\\,\\mathrm{cm}^{-1}\\,$ (element-wise constant).\n        - Scattering cross sections: $\\,\\Sigma_{s,1 \\to 2} = 0.05\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{s,2 \\to 1} = 0.002\\,\\mathrm{cm}^{-1}\\,$; no within-group scattering and no other off-diagonal elements.\n        - Fission: $\\,\\nu\\Sigma_{f,1} = 0.0\\,\\mathrm{cm}^{-1}\\,$, $\\,\\nu\\Sigma_{f,2} = 0.15\\,\\mathrm{cm}^{-1}\\,$; fission spectrum $\\,\\chi_1 = 0.6\\,$, $\\,\\chi_2 = 0.4\\,$; $\\,k_{\\mathrm{eff}} = 1.0\\,$.\n        - CG nodal fluxes $\\,\\phi_1 = [0.0, 1.0, 0.8, 0.5, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_2 = [0.0, 1.2, 1.0, 0.7, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$ at nodes $\\,x = [0,2,4,6,8]\\,\\mathrm{cm}\\,$.\n        - DG element fluxes $\\,\\phi_{1,K} = [0.9, 0.85, 0.6, 0.3]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_{2,K} = [1.1, 0.95, 0.75, 0.35]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$; penalty parameter $\\,\\eta = 1.0\\,$.\n    2. Boundary-dominated pure absorption case (no scattering, no fission):\n        - $\\,D_1 = 1.0\\,\\mathrm{cm}\\,$, $\\,D_2 = 0.25\\,\\mathrm{cm}\\,$.\n        - $\\,\\Sigma_{a,1} = 0.05\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{a,2} = 0.20\\,\\mathrm{cm}^{-1}\\,$.\n        - $\\,\\Sigma_{s,g \\to g'} = 0\\,\\mathrm{cm}^{-1}\\,$ for all $\\,g \\neq g'\\,$.\n        - $\\,\\nu\\Sigma_{f,g} = 0\\,\\mathrm{cm}^{-1}\\,$ for all $\\,g\\,$; $\\,\\chi_g\\,$ arbitrary; $\\,k_{\\mathrm{eff}} = 1.0\\,$.\n        - CG nodal fluxes $\\,\\phi_1 = [0.0, 0.6, 0.3, 0.1, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_2 = [0.0, 0.9, 0.4, 0.2, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$.\n        - DG element fluxes $\\,\\phi_{1,K} = [0.5, 0.35, 0.2, 0.05]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_{2,K} = [0.8, 0.45, 0.25, 0.1]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$; $\\,\\eta = 1.0\\,$.\n    3. Strong scattering and subcritical fission case:\n        - $\\,D_1 = 1.5\\,\\mathrm{cm}\\,$, $\\,D_2 = 0.4\\,\\mathrm{cm}\\,$.\n        - $\\,\\Sigma_{a,1} = 0.01\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{a,2} = 0.05\\,\\mathrm{cm}^{-1}\\,$.\n        - $\\,\\Sigma_{s,1 \\to 2} = 0.20\\,\\mathrm{cm}^{-1}\\,$, $\\,\\Sigma_{s,2 \\to 1} = 0.10\\,\\mathrm{cm}^{-1}\\,$.\n        - $\\,\\nu\\Sigma_{f,1} = 0.00\\,\\mathrm{cm}^{-1}\\,$, $\\,\\nu\\Sigma_{f,2} = 0.05\\,\\mathrm{cm}^{-1}\\,$; $\\,\\chi_1 = 0.7\\,$, $\\,\\chi_2 = 0.3\\,$; $\\,k_{\\mathrm{eff}} = 0.95\\,$.\n        - CG nodal fluxes $\\,\\phi_1 = [0.0, 0.7, 0.9, 0.6, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_2 = [0.0, 1.0, 1.1, 0.8, 0.0]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$.\n        - DG element fluxes $\\,\\phi_{1,K} = [0.6, 0.85, 0.7, 0.4]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$, $\\,\\phi_{2,K} = [0.9, 1.05, 0.9, 0.5]\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$; $\\,\\eta = 1.0\\,$.\n\nOutput specification:\n- For each of the three test cases, compute the maximum absolute imbalance value $\\,\\max_{K,g} \\left| B_{K,g}^{\\mathrm{DG}} \\right|\\,$ and $\\,\\max_{K,g} \\left| B_{K,g}^{\\mathrm{CG}} \\right|\\,$ and return a single line with six floating-point values in the order\n$$\n\\left[ \\max |B|_{\\mathrm{DG}}^{(1)}, \\; \\max |B|_{\\mathrm{CG}}^{(1)}, \\; \\max |B|_{\\mathrm{DG}}^{(2)}, \\; \\max |B|_{\\mathrm{CG}}^{(2)}, \\; \\max |B|_{\\mathrm{DG}}^{(3)}, \\; \\max |B|_{\\mathrm{CG}}^{(3)} \\right],\n$$\nwhere the superscript denotes the test case index. Ensure the program prints exactly this single-line format. All values are in $\\,\\mathrm{n}\\,\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}\\,$ and should be computed as decimals.",
            "solution": "The task is to compute the element-wise particle balance for a two-group, one-dimensional neutron diffusion problem using provided flux solutions from a Continuous Galerkin (CG) and a Discontinuous Galerkin (DG) finite element method. The goal is to find the maximum absolute imbalance, $\\max_{K,g} |B_{K,g}|$, for each method and for three distinct test cases.\n\nThe fundamental particle balance equation for an element $K$ and energy group $g$ is given by:\n$$\nB_{K,g} = L_{K,g} + R_{K,g} - S_{K,g}^{\\text{in}} - F_{K,g}\n$$\nHere, $L_{K,g}$ is the net leakage rate out of the element, $R_{K,g}$ is the total removal rate within the element, $S_{K,g}^{\\text{in}}$ is the in-scattering rate from other energy groups, and $F_{K,g}$ is the fission production rate. For a true solution to the diffusion equation, this balance $B_{K,g}$ would be exactly zero for every element $K$. Since the provided fluxes are numerical approximations, a non-zero imbalance is expected, which quantifies the local non-conservation of the numerical scheme.\n\nThe calculations for the CG and DG methods differ based on the representation of the neutron flux $\\phi_g(x)$ and the definition of the leakage term. The cross sections are assumed to be piecewise constant over each element. The domain consists of $4$ elements, each of length $h_K = 2\\,\\mathrm{cm}$. There are two energy groups, $g \\in \\{1, 2\\}$.\n\n### Discontinuous Galerkin (DG) Method Calculation\n\nFor the DG method, the neutron flux $\\phi_{g,K}$ is assumed to be piecewise constant on each element $K$. Let the elements be indexed $k \\in \\{0, 1, 2, 3\\}$. The DG method is constructed such that the numerical leakage term exactly balances the integrated reaction terms when the test function is chosen as 1 on element K and 0 elsewhere. This means the imbalance $B_{K,g}^{\\mathrm{DG}}$ should be zero (within floating-point precision).\n\n1.  **Removal Term ($R_{K,g}$)**: The removal cross section for group $g$ is $\\Sigma_{r,g} = \\Sigma_{a,g} + \\sum_{g' \\neq g} \\Sigma_{s,g \\to g'}$. For the two-group case, this gives:\n    $$\n    \\Sigma_{r,1} = \\Sigma_{a,1} + \\Sigma_{s,1 \\to 2}\n    $$\n    $$\n    \\Sigma_{r,2} = \\Sigma_{a,2} + \\Sigma_{s,2 \\to 1}\n    $$\n    Since $\\phi_{g,K}$ and $\\Sigma_{r,g}$ are constant over element $K$, the removal integral is:\n    $$\n    R_{K,g} = \\int_{K} \\Sigma_{r,g}\\,\\phi_g \\, dx = \\Sigma_{r,g} \\cdot \\phi_{g,K} \\cdot h_K\n    $$\n\n2.  **In-scattering Term ($S_{K,g}^{\\text{in}}$)**: This term represents neutrons scattering into group $g$ from the other group $g'$.\n    $$\n    S_{K,1}^{\\text{in}} = \\int_{K} \\Sigma_{s,2 \\to 1}\\,\\phi_{2} \\, dx = \\Sigma_{s,2 \\to 1} \\cdot \\phi_{2,K} \\cdot h_K\n    $$\n    $$\n    S_{K,2}^{\\text{in}} = \\int_{K} \\Sigma_{s,1 \\to 2}\\,\\phi_{1} \\, dx = \\Sigma_{s,1 \\to 2} \\cdot \\phi_{1,K} \\cdot h_K\n    $$\n\n3.  **Fission Term ($F_{K,g}$)**: This term is the source of neutrons in group $g$ from fissions occurring in all groups.\n    $$\n    F_{K,g} = \\int_{K} \\frac{1}{k_{\\mathrm{eff}}}\\,\\chi_g \\sum_{g'=1}^{2} \\nu \\Sigma_{f,g'}\\,\\phi_{g'} \\, dx = \\frac{\\chi_g}{k_{\\mathrm{eff}}} \\left( \\nu\\Sigma_{f,1}\\phi_{1,K} + \\nu\\Sigma_{f,2}\\phi_{2,K} \\right) h_K\n    $$\n\n4.  **Leakage Term ($L_{K,g}^{\\mathrm{DG}}$)**: The DG leakage for element $K$ is the sum of numerical fluxes over its faces, as defined in the problem. The face flux between element $K$ and a neighbor $K_f$ is $\\eta(\\phi_{g,K} - \\phi_{g,K_f})$, with $h_f=1$.\n    For an interior element $K_k$ with neighbors $K_{k-1}$ and $K_{k+1}$:\n    $$\n    L_{K_k,g}^{\\mathrm{DG}} = \\eta \\left( \\phi_{g,K_k} - \\phi_{g,K_{k-1}} \\right) + \\eta \\left( \\phi_{g,K_k} - \\phi_{g,K_{k+1}} \\right)\n    $$\n    For the first element $K_0$, the left neighbor is the vacuum with $\\phi_g=0$:\n    $$\n    L_{K_0,g}^{\\mathrm{DG}} = \\eta \\left( \\phi_{g,K_0} - 0 \\right) + \\eta \\left( \\phi_{g,K_0} - \\phi_{g,K_1} \\right)\n    $$\n    For the last element $K_3$, the right neighbor is the vacuum with $\\phi_g=0$:\n    $$\n    L_{K_3,g}^{\\mathrm{DG}} = \\eta \\left( \\phi_{g,K_3} - \\phi_{g,K_2} \\right) + \\eta \\left( \\phi_{g,K_3} - 0 \\right)\n    $$\n\n### Continuous Galerkin (CG) Method Calculation\n\nFor the CG method, the neutron flux $\\phi_g(x)$ is piecewise linear and continuous at element nodes. For an element $K_k$ between nodes $k$ and $k+1$, the flux is defined by its nodal values $\\phi_{g,k}$ and $\\phi_{g,k+1}$.\n\n1.  **Leakage Term ($L_{K,g}^{\\mathrm{CG}}$)**: For this problem's pedagogical purpose, the local leakage term for the CG balance check is defined to be zero, as stated in the problem description:\n    $$\n    L_{K,g}^{\\mathrm{CG}} = 0\n    $$\n    This choice highlights that, unlike in DG, the integrated reaction terms in a CG element do not balance on their own. The physical leakage, which is non-zero, is required to achieve balance in the global weak form, but not in this local check.\n\n2.  **Reaction Terms ($R_{K,g}$, $S_{K,g}^{\\text{in}}$, $F_{K,g}$)**: The integrals are evaluated using the average value of the linear flux profile over the element. The average flux on element $K_k$ is:\n    $$\n    \\phi_{g,\\text{avg},K_k} = \\frac{\\phi_{g,k} + \\phi_{g,k+1}}{2}\n    $$\n    The terms are then calculated in the same way as for DG, but substituting $\\phi_{g,K}$ with $\\phi_{g,\\text{avg},K_k}$:\n    $$\n    R_{K_k,g} = \\Sigma_{r,g} \\cdot \\phi_{g,\\text{avg},K_k} \\cdot h_K\n    $$\n    $$\n    S_{K_k,1}^{\\text{in}} = \\Sigma_{s,2 \\to 1} \\cdot \\phi_{2,\\text{avg},K_k} \\cdot h_K\n    $$\n    $$\n    S_{K_k,2}^{\\text{in}} = \\Sigma_{s,1 \\to 2} \\cdot \\phi_{1,\\text{avg},K_k} \\cdot h_K\n    $$\n    $$\n    F_{K_k,g} = \\frac{\\chi_g}{k_{\\mathrm{eff}}} \\left( \\nu\\Sigma_{f,1}\\phi_{1,\\text{avg},K_k} + \\nu\\Sigma_{f,2}\\phi_{2,\\text{avg},K_k} \\right) h_K\n    $$\n\nThe Python implementation will follow this logic for each test case to compute and report the maximum imbalances.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute element-wise balance for CG and DG methods\n    for three test cases of a 1D, 2-group neutron diffusion problem.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Happy path\n        {\n            \"h_K\": [2.0, 2.0, 2.0, 2.0],\n            \"D\": [1.2, 0.3],\n            \"Sigma_a\": [0.02, 0.08],\n            \"Sigma_s_12\": 0.05,\n            \"Sigma_s_21\": 0.002,\n            \"nuSigma_f\": [0.0, 0.15],\n            \"chi\": [0.6, 0.4],\n            \"k_eff\": 1.0,\n            \"eta\": 1.0,\n            \"cg_phi_nodes\": np.array([\n                [0.0, 1.0, 0.8, 0.5, 0.0],  # group 1\n                [0.0, 1.2, 1.0, 0.7, 0.0]   # group 2\n            ]),\n            \"dg_phi_elem\": np.array([\n                [0.9, 0.85, 0.6, 0.3],     # group 1\n                [1.1, 0.95, 0.75, 0.35]    # group 2\n            ])\n        },\n        # Case 2: Pure absorption\n        {\n            \"h_K\": [2.0, 2.0, 2.0, 2.0],\n            \"D\": [1.0, 0.25],\n            \"Sigma_a\": [0.05, 0.20],\n            \"Sigma_s_12\": 0.0,\n            \"Sigma_s_21\": 0.0,\n            \"nuSigma_f\": [0.0, 0.0],\n            \"chi\": [1.0, 0.0], # Arbitrary, as nuSigma_f is zero\n            \"k_eff\": 1.0,\n            \"eta\": 1.0,\n            \"cg_phi_nodes\": np.array([\n                [0.0, 0.6, 0.3, 0.1, 0.0],\n                [0.0, 0.9, 0.4, 0.2, 0.0]\n            ]),\n            \"dg_phi_elem\": np.array([\n                [0.5, 0.35, 0.2, 0.05],\n                [0.8, 0.45, 0.25, 0.1]\n            ])\n        },\n        # Case 3: Strong scattering, subcritical fission\n        {\n            \"h_K\": [2.0, 2.0, 2.0, 2.0],\n            \"D\": [1.5, 0.4],\n            \"Sigma_a\": [0.01, 0.05],\n            \"Sigma_s_12\": 0.20,\n            \"Sigma_s_21\": 0.10,\n            \"nuSigma_f\": [0.0, 0.05],\n            \"chi\": [0.7, 0.3],\n            \"k_eff\": 0.95,\n            \"eta\": 1.0,\n            \"cg_phi_nodes\": np.array([\n                [0.0, 0.7, 0.9, 0.6, 0.0],\n                [0.0, 1.0, 1.1, 0.8, 0.0]\n            ]),\n            \"dg_phi_elem\": np.array([\n                [0.6, 0.85, 0.7, 0.4],\n                [0.9, 1.05, 0.9, 0.5]\n            ])\n        }\n    ]\n\n    final_results = []\n    num_elements = 4\n    num_groups = 2\n\n    for case in test_cases:\n        # Unpack case data\n        h_K_arr = case[\"h_K\"]\n        Sigma_a = case[\"Sigma_a\"]\n        Sigma_s_12 = case[\"Sigma_s_12\"]\n        Sigma_s_21 = case[\"Sigma_s_21\"]\n        nuSigma_f = case[\"nuSigma_f\"]\n        chi = case[\"chi\"]\n        k_eff = case[\"k_eff\"]\n        eta = case[\"eta\"]\n        cg_phi_nodes = case[\"cg_phi_nodes\"]\n        dg_phi_elem = case[\"dg_phi_elem\"]\n        \n        # Derived cross sections\n        Sigma_r = [Sigma_a[0] + Sigma_s_12, Sigma_a[1] + Sigma_s_21]\n\n        # --- DG Calculation ---\n        dg_imbalances = []\n        for k in range(num_elements):\n            h_K = h_K_arr[k]\n            for g_idx in range(num_groups):\n                phi_g_K = dg_phi_elem[g_idx, k]\n                \n                # Removal\n                R_K_g = Sigma_r[g_idx] * phi_g_K * h_K\n\n                # In-scattering\n                if g_idx == 0: # Group 1\n                    phi_gprime_K = dg_phi_elem[1, k]\n                    S_in_K_g = Sigma_s_21 * phi_gprime_K * h_K\n                else: # Group 2\n                    phi_gprime_K = dg_phi_elem[0, k]\n                    S_in_K_g = Sigma_s_12 * phi_gprime_K * h_K\n\n                # Fission\n                fission_prod = (nuSigma_f[0] * dg_phi_elem[0, k] + \n                                nuSigma_f[1] * dg_phi_elem[1, k])\n                F_K_g = (chi[g_idx] / k_eff) * fission_prod * h_K\n\n                # Leakage\n                phi_left_neighbor = dg_phi_elem[g_idx, k - 1] if k > 0 else 0.0\n                phi_right_neighbor = dg_phi_elem[g_idx, k + 1] if k  num_elements - 1 else 0.0\n                L_K_g = eta * (phi_g_K - phi_left_neighbor) + eta * (phi_g_K - phi_right_neighbor)\n\n                # Balance\n                B_K_g = L_K_g + R_K_g - S_in_K_g - F_K_g\n                dg_imbalances.append(abs(B_K_g))\n        \n        final_results.append(max(dg_imbalances))\n        \n        # --- CG Calculation ---\n        cg_imbalances = []\n        for k in range(num_elements):\n            h_K = h_K_arr[k]\n            for g_idx in range(num_groups):\n                phi_avg = (cg_phi_nodes[g_idx, k] + cg_phi_nodes[g_idx, k+1]) / 2.0\n\n                # Leakage\n                L_K_g = 0.0\n\n                # Removal\n                R_K_g = Sigma_r[g_idx] * phi_avg * h_K\n\n                # In-scattering\n                if g_idx == 0: # Group 1\n                    phi_gprime_avg = (cg_phi_nodes[1, k] + cg_phi_nodes[1, k+1]) / 2.0\n                    S_in_K_g = Sigma_s_21 * phi_gprime_avg * h_K\n                else: # Group 2\n                    phi_gprime_avg = (cg_phi_nodes[0, k] + cg_phi_nodes[0, k+1]) / 2.0\n                    S_in_K_g = Sigma_s_12 * phi_gprime_avg * h_K\n                \n                # Fission\n                phi1_avg = (cg_phi_nodes[0, k] + cg_phi_nodes[0, k+1]) / 2.0\n                phi2_avg = (cg_phi_nodes[1, k] + cg_phi_nodes[1, k+1]) / 2.0\n                fission_prod = nuSigma_f[0] * phi1_avg + nuSigma_f[1] * phi2_avg\n                F_K_g = (chi[g_idx] / k_eff) * fission_prod * h_K\n\n                # Balance\n                B_K_g = L_K_g + R_K_g - S_in_K_g - F_K_g\n                cg_imbalances.append(abs(B_K_g))\n\n        final_results.append(max(cg_imbalances))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}