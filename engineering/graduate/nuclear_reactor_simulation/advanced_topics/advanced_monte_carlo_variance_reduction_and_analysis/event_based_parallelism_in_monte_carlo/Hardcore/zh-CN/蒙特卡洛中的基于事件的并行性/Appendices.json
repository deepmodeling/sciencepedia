{
    "hands_on_practices": [
        {
            "introduction": "在基于事件的并行计算中，尤其是在如图形处理单元（GPU）这样的硬件上，性能不仅取决于单次计算的速度，还取决于我们管理工作负载的效率。本练习旨在解决一个根本性挑战：每次启动计算内核时产生的固定开销 $\\tau_k$。通过一次性处理一大批 $N$ 个事件，我们可以摊销这一成本，本实践将指导您推导并计算达到目标效率 $\\eta$ 所需的最小批处理大小，这是设计高吞吐量蒙特卡罗模拟的关键第一步 。",
            "id": "4224488",
            "problem": "在一个用于图形处理单元（GPU）上进行核反应堆模拟的、基于事件的蒙特卡洛中子输运内核中，每次内核启动会处理一批共 $N$ 个事件。每次启动会产生固定的内核启动开销时间 $\\tau_k$，批次中的每个事件需要恒定的计算时间 $c$。将一个批次的效率 $\\eta(N)$ 定义为该批次的有效计算时间与总壁钟时间之比。仅使用以下基本定义：(i) 开销增加一个与 $N$ 无关的恒定时间 $\\tau_k$，(ii) 总计算时间以 $N c$ 线性累积，以及 (iii) 效率是有效计算时间与总时间之比，推导出保证达到目标效率 $\\eta$（其中 $0  \\eta  1$）的最小整数批次大小 $N_{\\min}$。\n\n然后，针对一个特定的反应堆物理吞吐量目标，取 $\\tau_k = 8.0\\,\\mu\\mathrm{s}$，$c = 25\\,\\mathrm{ns}$，且 $\\eta = 0.9$。计算满足目标效率的最小整数批次大小 $N_{\\min}$，并通过使用这些定义所蕴含的简单计时模型，计算 $N_{\\min}$ 处的效率来验证您的结果。最终答案以无单位的整数形式表示。",
            "solution": "首先根据所提供的准则对问题进行验证。\n\n**步骤1：提取已知条件**\n- 批次大小：$N$ 个事件\n- 固定内核启动开销时间：$\\tau_k$\n- 每个事件的恒定计算时间：$c$\n- 批次的效率：$\\eta(N)$，定义为有效计算时间与批次总壁钟时间之比。\n- 基本定义 (i)：开销增加一个与 $N$ 无关的恒定时间 $\\tau_k$。\n- 基本定义 (ii)：总计算时间以 $N c$ 线性累积。\n- 基本定义 (iii)：效率是有效计算时间与总时间之比。\n- 目标效率：$\\eta$，其中 $0  \\eta  1$。\n- 目标1：推导保证效率至少为 $\\eta$ 的最小整数批次大小 $N_{\\min}$。\n- 目标2：使用具体数值 $\\tau_k = 8.0\\,\\mu\\mathrm{s}$，$c = 25\\,\\mathrm{ns}$ 和 $\\eta = 0.9$ 计算 $N_{\\min}$。\n- 目标3：通过计算 $N_{\\min}$ 处的效率来验证结果。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法恰当且客观。它描述了一个用于高性能计算的标准简化性能模型，尤其适用于像GPU这样面向吞吐量的架构。启动开销和单位元素处理时间的概念是性能分析的基础。给定的定义对于构建数学模型是充分且一致的。问题要求解一个不等式的最小整数解，这是一个明确定义的数学任务。为 $\\tau_k$，$c$ 和 $\\eta$ 提供的数值对于现代硬件和模拟环境是物理上现实的。该问题不是提法不当、模棱两可或微不足道的。它代表了性能优化中的一个基本问题。\n\n**结论：** 该问题有效。\n\n**步骤3：求解推导**\n\n根据所给定义，我们首先将效率 $\\eta(N)$ 的表达式形式化。对于一个包含 $N$ 个事件的批次，其“有效计算时间”是花费在计算上的总时间，即事件数量与每个事件所需时间的乘积。\n设 $T_{\\text{compute}}$ 为总有效计算时间。根据定义 (ii)：\n$$T_{\\text{compute}}(N) = N c$$\n\n“批次的总壁钟时间”，我们称之为 $T_{\\text{total}}(N)$，是有效计算时间与固定内核启动开销之和。根据定义 (i) 和 (ii)：\n$$T_{\\text{total}}(N) = T_{\\text{compute}}(N) + \\tau_k = N c + \\tau_k$$\n\n效率 $\\eta(N)$ 是批次大小 $N$ 的函数。根据定义 (iii)，它是有效计算时间与总壁钟时间之比：\n$$\\eta(N) = \\frac{T_{\\text{compute}}(N)}{T_{\\text{total}}(N)} = \\frac{N c}{N c + \\tau_k}$$\n\n问题要求找到保证达到目标效率 $\\eta$ 的最小整数批次大小 $N_{\\min}$。这可以转化为不等式：\n$$\\eta(N) \\ge \\eta$$\n代入 $\\eta(N)$ 的表达式，我们得到：\n$$\\frac{N c}{N c + \\tau_k} \\ge \\eta$$\n由于 $N$ 是批次大小，所以 $N \\ge 1$。常数 $c$ 和 $\\tau_k$ 是时间，因此它们是正数。所以，分母 $N c + \\tau_k$ 严格为正。我们可以用此项乘以不等式两边，而无需改变不等号的方向：\n$$N c \\ge \\eta (N c + \\tau_k)$$\n$$N c \\ge \\eta N c + \\eta \\tau_k$$\n为了解出 $N$，我们将所有包含 $N$ 的项移到一边：\n$$N c - \\eta N c \\ge \\eta \\tau_k$$\n$$N(c - \\eta c) \\ge \\eta \\tau_k$$\n$$N c (1 - \\eta) \\ge \\eta \\tau_k$$\n问题陈述 $0  \\eta  1$，这意味着 $1 - \\eta$ 是一个正量。因此，我们可以用 $c(1 - \\eta)$ 除以不等式两边，而无需改变其方向：\n$$N \\ge \\frac{\\eta \\tau_k}{c (1 - \\eta)}$$\n这个不等式指定了批次大小 $N$ 必须满足的条件。问题要求的是*最小整数*批次大小 $N_{\\min}$。这是满足该条件的 $N$ 的最小整数值。这个整数可以通过对右侧表达式取上取整（ceiling）得到：\n$$N_{\\min} = \\left\\lceil \\frac{\\eta \\tau_k}{c(1-\\eta)} \\right\\rceil$$\n\n符号推导到此完成。现在，我们使用所给数据计算 $N_{\\min}$ 的数值：$\\tau_k = 8.0\\,\\mu\\mathrm{s}$，$c = 25\\,\\mathrm{ns}$，以及 $\\eta = 0.9$。\n首先，我们确保单位一致。我们将两个时间值都转换为秒：\n$\\tau_k = 8.0 \\times 10^{-6}\\,\\mathrm{s}$\n$c = 25 \\times 10^{-9}\\,\\mathrm{s}$\n\n我们可以计算无量纲比值 $\\frac{\\tau_k}{c}$：\n$$\\frac{\\tau_k}{c} = \\frac{8.0 \\times 10^{-6}}{25 \\times 10^{-9}} = \\frac{8.0}{25} \\times 10^3 = 0.32 \\times 10^3 = 320$$\n现在，将 $\\eta$ 的值和比值 $\\frac{\\tau_k}{c}$ 代入关于 $N$ 的不等式中：\n$$N \\ge \\frac{0.9}{1 - 0.9} \\left( \\frac{\\tau_k}{c} \\right)$$\n$$N \\ge \\frac{0.9}{0.1} \\times 320$$\n$$N \\ge 9 \\times 320$$\n$$N \\ge 2880$$\n由于下界是一个整数，满足该不等式的最小整数 $N$ 是 $N_{\\min} = 2880$。\n$$N_{\\min} = 2880$$\n\n最后，我们通过计算批次大小为 $N_{\\min} = 2880$ 时达到的效率来验证这个结果。\n$$\\eta(N_{\\min}) = \\eta(2880) = \\frac{2880 \\cdot c}{2880 \\cdot c + \\tau_k}$$\n为了简化，我们可以将分子和分母同时除以 $c$：\n$$\\eta(2880) = \\frac{2880}{2880 + \\frac{\\tau_k}{c}}$$\n使用我们之前计算的比值 $\\frac{\\tau_k}{c} = 320$：\n$$\\eta(2880) = \\frac{2880}{2880 + 320} = \\frac{2880}{3200}$$\n简化分数：\n$$\\eta(2880) = \\frac{288}{320} = \\frac{144}{160} = \\frac{72}{80} = \\frac{36}{40} = \\frac{9}{10} = 0.9$$\n$N_{\\min} = 2880$ 时的效率恰好是 $0.9$，与目标效率 $\\eta$ 相匹配。这验证了我们对 $N_{\\min}$ 的计算。",
            "answer": "$$\\boxed{2880}$$"
        },
        {
            "introduction": "虽然大批量处理有助于摊销启动开销，但在单指令多线程（SIMT）架构（如 GPU）上，另一个显著的性能瓶颈是线程束发散（warp divergence）。当一个线程束内的线程执行不同的指令时，就会发生这种情况，从而迫使多个代码路径串行执行。这项动手实践将挑战您设计并分析一种强大的优化策略——事件分桶（event bucketization），通过根据粒子后续的计算路径对其进行排序来缓解此问题，从而确保线程束保持一致性，并使硬件得到充分利用 。",
            "id": "4224563",
            "problem": "考虑一个核反应堆堆芯中子输运的基于事件的蒙特卡罗（MC）模拟，其中散射事件在采用单指令多线程（SIMT）执行模式的图形处理器（GPU）上进行处理。中子的角散射由一个关于散射角余弦（记为 $\\mu \\in [-1,1]$）的归一化各向异性核描述，其勒让德展开式最高为二阶：\n$$\np(\\mu) = \\frac{1}{2}\\left(1 + a_1 \\mu + \\frac{a_2}{2}\\left(3\\mu^2 - 1\\right)\\right),\n$$\n其中 $a_1$ 和 $a_2$ 是各向异性系数。选择的归一化常数使得 $\\int_{-1}^{1} p(\\mu)\\,d\\mu = 1$。该散射核在散射例程中导致了依赖于角度的代码路径：前向散射、中央散射和背向散射。这些路径由单个参数 $\\mu_t \\in (0,1)$ 定义的角度阈值触发，具体如下：\n- 如果 $\\mu \\in [\\mu_t, 1]$，则采用前向路径，\n- 如果 $\\mu \\in (-\\mu_t, \\mu_t)$，则采用中央路径，\n- 如果 $\\mu \\in [-1, -\\mu_t]$，则采用背向散射路径。\n\n假设每条路径有固定的路径执行成本，以无量纲时间单位建模，前向、中央和背向散射的成本分别由 $c_f$、$c_m$ 和 $c_b$ 给出。GPU 的 warp 大小为 $W$ 个线程。在 SIMT 执行中，当一个 warp 内的线程采用不同分支时，会发生 warp 级分歧；该 warp 会串行执行其内部存在的所有分支，为 warp 中存在的每个不同分支支付一次成本，而与采用该分支的线程数量无关。\n\n你需要设计一种分桶（重映射）策略，根据粒子依赖于角度的路径键（前向、中央、背向散射）将其分配到连续的桶中，以最小化 warp 内分歧。重映射需要根据整数桶键（三个桶）对粒子进行排序，其估计开销通过一个类似于计数排序的成本模型来建模：\n$$\nT_{\\text{sort}} = \\gamma N + \\delta B,\n$$\n其中 $N$ 是粒子数，$B$ 是桶的数量（此处 $B=3$），$\\gamma, \\delta$ 是正常数。排序后，每个桶都由大小为 $W$ 的完整 warp 进行处理；位于桶末尾的部分填充的 warp 仍然会产生该桶的完整路径成本。\n\n仅从上述给定的基本框架出发，包括玻尔兹曼输运框架（散射核和归一化）、SIMT 分歧行为以及整数键排序成本模型，推导以下内容：\n- 通过在相应的角度区间上对给定的 $p(\\mu)$ 进行积分，得到粒子落入背向散射、中央和前向桶的概率 $p_b$、$p_m$ 和 $p_f$。\n- 在没有任何重映射的情况下，处理 $N$ 个粒子（分组为大小为 $W$ 的 warp）的预期总执行时间（以无量纲时间单位表示），其中每个 warp 的时间是其内部存在的不同路径的成本之和。\n- 采用三桶分桶策略的总执行时间，包括排序开销和分桶执行时间，其中每个桶的 warp 数量是预期桶内粒子数除以 $W$ 的向上取整。\n\n你的程序必须为下面指定的每个测试用例计算两个输出：无重映射的总时间和采用三角度桶分桶的总时间。所有最终结果都表示为无量纲浮点数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，其顺序为：对于每个测试用例，首先输出无重映射的总时间，然后输出分桶后的总时间；因此，最终列表的长度是测试用例数量的两倍。\n\n测试套件：\n- 案例 A（理想情况）：$N=65536$, $W=32$, $a_1=0.2$, $a_2=0.1$, $\\mu_t=0.6$, $c_f=6.0$, $c_m=4.0$, $c_b=7.0$, $\\gamma=0.25$, $\\delta=400.0$。\n- 案例 B（前向峰值各向异性）：$N=65536$, $W=32$, $a_1=0.6$, $a_2=0.2$, $\\mu_t=0.8$, $c_f=8.0$, $c_m=5.0$, $c_b=9.0$, $\\gamma=0.2$, $\\delta=400.0$。\n- 案例 C（边界情况，由于 $W=1$ 无分歧）：$N=1000$, $W=1$, $a_1=0.0$, $a_2=0.0$, $\\mu_t=0.5$, $c_f=6.0$, $c_m=6.0$, $c_b=6.0$, $\\gamma=0.3$, $\\delta=200.0$。\n- 案例 D（更大的 warp 大小）：$N=262144$, $W=64$, $a_1=0.3$, $a_2=-0.1$, $\\mu_t=0.7$, $c_f=7.0$, $c_m=4.0$, $c_b=8.0$, $\\gamma=0.25$, $\\delta=600.0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），列表中的条目是浮点数，按 A、B、C、D 的顺序对应每个测试用例的：（无重映射总时间）、（分桶后总时间）。所有计算必须根据给定的定义进行解析计算，不进行任何随机抽样。所有输出必须如指定的那样为无量纲。",
            "solution": "用户提供的问题是有效的，因为它在科学上基于核反应堆物理和并行计算原理，在数学上是适定的，并且使用客观、精确的语言进行表述。所有必要的参数都已提供，并且所需的推导可以通过解析方法实现。\n\n本解决方案展示了在 GPU 上进行蒙特卡罗中子散射模拟的总执行时间的解析推导，包括使用和不使用粒子分桶策略两种情况。\n\n### 1. 路径概率的推导\n\n中子散射到特定角度范围内的概率，是通过将归一化的各向异性散射核 $p(\\mu)$ 在散射角余弦 $\\mu$ 的相应区间上积分来确定的。\n\n散射核以最高二阶的勒让德展开式形式给出：\n$$\np(\\mu) = \\frac{1}{2}\\left(1 + a_1 \\mu + \\frac{a_2}{2}\\left(3\\mu^2 - 1\\right)\\right)\n$$\n该概率密度函数被归一化，使得 $\\int_{-1}^{1} p(\\mu)\\,d\\mu = 1$。三个角度路径由参数 $\\mu_t \\in (0,1)$ 定义：\n- 前向路径 (f): $\\mu \\in [\\mu_t, 1]$\n- 中央路径 (m): $\\mu \\in (-\\mu_t, \\mu_t)$\n- 背向散射路径 (b): $\\mu \\in [-1, -\\mu_t]$\n\n为了求出每条路径的概率，我们计算 $p(\\mu)$ 在每个区间上的定积分。首先，我们求出 $p(\\mu)$ 的不定积分，记为 $P(\\mu)$：\n$$\nP(\\mu) = \\int p(\\mu)\\,d\\mu = \\frac{1}{2} \\int \\left( \\left(1-\\frac{a_2}{2}\\right) + a_1 \\mu + \\frac{3a_2}{2}\\mu^2 \\right) d\\mu\n$$\n$$\nP(\\mu) = \\frac{1}{2} \\left( \\left(1-\\frac{a_2}{2}\\right)\\mu + \\frac{a_1}{2}\\mu^2 + \\frac{a_2}{2}\\mu^3 \\right) + C\n$$\n\n概率 $p_f$、$p_m$ 和 $p_b$ 分别是：\n\n**中央路径概率 ($p_m$):**\n$$\np_m = \\int_{-\\mu_t}^{\\mu_t} p(\\mu)\\,d\\mu = P(\\mu_t) - P(-\\mu_t)\n$$\n$$\np_m = \\frac{1}{2} \\left[ \\left( \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 + \\frac{a_2}{2}\\mu_t^3 \\right) - \\left( -\\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right) \\right]\n$$\n$$\np_m = \\frac{1}{2} \\left[ 2\\left(1-\\frac{a_2}{2}\\right)\\mu_t + 2\\frac{a_2}{2}\\mu_t^3 \\right] = \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_2}{2}\\mu_t^3 = \\mu_t + \\frac{a_2}{2}\\left(\\mu_t^3 - \\mu_t\\right)\n$$\n\n**前向路径概率 ($p_f$):**\n$$\np_f = \\int_{\\mu_t}^{1} p(\\mu)\\,d\\mu = P(1) - P(\\mu_t)\n$$\n$$\nP(1) = \\frac{1}{2} \\left( \\left(1-\\frac{a_2}{2}\\right) + \\frac{a_1}{2} + \\frac{a_2}{2} \\right) = \\frac{1}{2}\\left(1 + \\frac{a_1}{2}\\right)\n$$\n$$\np_f = \\frac{1}{2}\\left(1 + \\frac{a_1}{2}\\right) - \\frac{1}{2} \\left( \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 + \\frac{a_2}{2}\\mu_t^3 \\right)\n$$\n$$\np_f = \\frac{1}{2} \\left[ 1 + \\frac{a_1}{2} - \\left(1-\\frac{a_2}{2}\\right)\\mu_t - \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right]\n$$\n\n**背向散射路径概率 ($p_b$):**\n$$\np_b = \\int_{-1}^{-\\mu_t} p(\\mu)\\,d\\mu = P(-\\mu_t) - P(-1)\n$$\n$$\nP(-1) = \\frac{1}{2} \\left( -\\left(1-\\frac{a_2}{2}\\right) + \\frac{a_1}{2} - \\frac{a_2}{2} \\right) = \\frac{1}{2}\\left(-1 + \\frac{a_1}{2}\\right)\n$$\n$$\np_b = \\frac{1}{2} \\left( -\\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right) - \\frac{1}{2}\\left(-1 + \\frac{a_1}{2}\\right)\n$$\n$$\np_b = \\frac{1}{2} \\left[ 1 - \\frac{a_1}{2} - \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right]\n$$\n这三个概率之和为 1。\n\n### 2. 无重映射的执行时间 ($T_{\\text{no-remap}}$)\n\n在没有重映射的情况下，对应于 $N$ 个粒子的线程被分组为大小为 $W$ 的 warp。在 SIMT 架构上，如果一个 warp 内的线程发生分歧（采用不同的代码路径），该 warp 会串行执行每个不同的路径。一个 warp 的成本是其线程所采用的所有唯一路径的成本之和。\n\n让我们求解大小为 $w$ 的单个 warp 的预期执行时间。某个特定路径（例如前向路径 $f$）出现在 warp 中的概率是 1 减去 warp 中*没有*线程采用该路径的概率。单个线程*不*采用路径 $f$ 的概率是 $1 - p_f$。对于 $w$ 个独立线程，此概率为 $(1 - p_f)^w$。\n- 路径 $f$ 存在的概率：$P(\\text{f present}) = 1 - (1 - p_f)^w$\n- 路径 $m$ 存在的概率：$P(\\text{m present}) = 1 - (1 - p_m)^w$\n- 路径 $b$ 存在的概率：$P(\\text{b present}) = 1 - (1 - p_b)^w$\n\n大小为 $w$ 的 warp 的预期时间 $E[T_{\\text{warp}}(w)]$ 是每个路径的成本乘以其出现概率的总和：\n$$\nE[T_{\\text{warp}}(w)] = c_f \\left(1 - (1-p_f)^w\\right) + c_m \\left(1 - (1-p_m)^w\\right) + c_b \\left(1 - (1-p_b)^w\\right)\n$$\n对于总共 $N$ 个粒子，有 $N_{full} = \\lfloor N/W \\rfloor$ 个大小为 $W$ 的完整 warp，如果 $N$ 不是 $W$ 的倍数，则还有一个大小为 $W_{\\text{last}} = N \\pmod W$ 的部分 warp。\n\n预期的总时间是所有 warp 的预期时间之和：\n$$\nT_{\\text{no-remap}} = \\lfloor N/W \\rfloor \\cdot E[T_{\\text{warp}}(W)] + E[T_{\\text{warp}}(N \\pmod W)]\n$$\n其中第二项仅在 $N \\pmod W > 0$ 时添加。\n\n### 3. 使用分桶的执行时间 ($T_{\\text{remap}}$)\n\n分桶策略包括两个阶段：排序和执行。总时间是每个阶段的时间之和。\n$$\nT_{\\text{remap}} = T_{\\text{sort}} + T_{\\text{exec,bucketed}}\n$$\n\n**排序成本 ($T_{\\text{sort}}$):**\n问题为排序开销提供了一个模型：\n$$\nT_{\\text{sort}} = \\gamma N + \\delta B\n$$\n对于 $B=3$ 个桶（前向、中央、背向散射），成本为：\n$$\nT_{\\text{sort}} = \\gamma N + 3\\delta\n$$\n\n**分桶执行成本 ($T_{\\text{exec,bucketed}}$):**\n排序后，粒子按其目标路径分组。处理特定桶的 warp 中的所有线程都将执行相同的代码路径，从而消除 warp 内分歧。\n每个桶中的预期粒子数分别为 $N_f = N p_f$、$N_m = N p_m$ 和 $N_b = N p_b$。\n问题规定，每个桶的 warp 数量计算为预期桶内粒子数除以 warp 大小 $W$ 的向上取整：\n- 前向桶的 warp 数：$N_{\\text{warps},f} = \\lceil N p_f / W \\rceil$\n- 中央桶的 warp 数：$N_{\\text{warps},m} = \\lceil N p_m / W \\rceil$\n- 背向散射桶的 warp 数：$N_{\\text{warps},b} = \\lceil N p_b / W \\rceil$\n\n前向桶中的每个 warp 成本为 $c_f$，中央桶为 $c_m$，背向散射桶为 $c_b$。总的分桶执行时间是：\n$$\nT_{\\text{exec,bucketed}} = N_{\\text{warps},f} \\cdot c_f + N_{\\text{warps},m} \\cdot c_m + N_{\\text{warps},b} \\cdot c_b\n$$\n$$\nT_{\\text{exec,bucketed}} = \\lceil Np_f/W \\rceil c_f + \\lceil Np_m/W \\rceil c_m + \\lceil Np_b/W \\rceil c_b\n$$\n使用重映射的总时间是这两个部分之和。\n\n### 公式总结\n计算过程首先是为给定的测试用例计算 $p_f, p_m, p_b$。然后，使用这些概率和推导出的公式来计算 $T_{\\text{no-remap}}$ 和 $T_{\\text{remap}}$。\n- $T_{\\text{no-remap}} = \\lfloor N/W \\rfloor \\left( \\sum_{k \\in \\{f,m,b\\}} c_k(1-(1-p_k)^W) \\right) + \\mathbf{1}_{N \\pmod W \\neq 0} \\left( \\sum_{k \\in \\{f,m,b\\}} c_k(1-(1-p_k)^{N \\pmod W}) \\right)$\n- $T_{\\text{remap}} = (\\gamma N + 3\\delta) + c_f \\lceil Np_f/W \\rceil + c_m \\lceil Np_m/W \\rceil + c_b \\lceil Np_b/W \\rceil$\n\n将实施这些公式来解决给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the total execution time for a Monte Carlo simulation \n    both without and with a particle bucketization strategy.\n    \"\"\"\n    \n    # Test cases are defined as tuples of parameters:\n    # (N, W, a1, a2, mu_t, c_f, c_m, c_b, gamma, delta)\n    test_cases = [\n        # Case A (happy path)\n        (65536, 32, 0.2, 0.1, 0.6, 6.0, 4.0, 7.0, 0.25, 400.0),\n        # Case B (forward-peaked anisotropy)\n        (65536, 32, 0.6, 0.2, 0.8, 8.0, 5.0, 9.0, 0.2, 400.0),\n        # Case C (boundary, no divergence due to W=1)\n        (1000, 1, 0.0, 0.0, 0.5, 6.0, 6.0, 6.0, 0.3, 200.0),\n        # Case D (larger warp size)\n        (262144, 64, 0.3, -0.1, 0.7, 7.0, 4.0, 8.0, 0.25, 600.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        time_no_remap, time_remap = calculate_times_for_case(*case)\n        results.append(time_no_remap)\n        results.append(time_remap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_times_for_case(N, W, a1, a2, mu_t, c_f, c_m, c_b, gamma, delta):\n    \"\"\"\n    Calculates execution times for a single test case.\n    \n    Args:\n        N (int): Number of particles.\n        W (int): Warp size.\n        a1, a2 (float): Anisotropy coefficients.\n        mu_t (float): Angle threshold.\n        c_f, c_m, c_b (float): Path execution costs.\n        gamma, delta (float): Sorting cost coefficients.\n\n    Returns:\n        tuple: (total time without remapping, total time with bucketization).\n    \"\"\"\n\n    # 1. Calculate Path Probabilities (p_f, p_m, p_b)\n    # p_m = mu_t + a2/2 * (mu_t^3 - mu_t)\n    p_m = mu_t + 0.5 * a2 * (mu_t**3 - mu_t)\n    \n    # p_f = 0.5 * [1 + a1/2 - (1-a2/2)*mu_t - a1/2*mu_t^2 - a2/2*mu_t^3]\n    p_f = 0.5 * (1 + 0.5 * a1 - (1 - 0.5 * a2) * mu_t - 0.5 * a1 * mu_t**2 - 0.5 * a2 * mu_t**3)\n\n    # p_b can be derived from p_f and p_m, or calculated directly.\n    # To maintain precision, we use the direct formula, but 1 - p_f - p_m is also valid.\n    # p_b = 0.5 * [1 - a1/2 - (1-a2/2)*mu_t + a1/2*mu_t^2 - a2/2*mu_t^3]\n    p_b = 1.0 - p_f - p_m\n\n    # 2. Calculate Execution Time Without Remapping (T_no_remap)\n    \n    # Function to calculate expected time for a warp of a given size `w`\n    def get_expected_warp_time(w, p_f, p_m, p_b, c_f, c_m, c_b):\n        if w == 0:\n            return 0.0\n        time = 0.0\n        # Contribution from forward path\n        prob_f_present = 1.0 - (1.0 - p_f)**w\n        time += c_f * prob_f_present\n        # Contribution from central path\n        prob_m_present = 1.0 - (1.0 - p_m)**w\n        time += c_m * prob_m_present\n        # Contribution from backscattering path\n        prob_b_present = 1.0 - (1.0 - p_b)**w\n        time += c_b * prob_b_present\n        return time\n\n    num_full_warps = N // W\n    last_warp_size = N % W\n\n    expected_time_full_warp = get_expected_warp_time(W, p_f, p_m, p_b, c_f, c_m, c_b)\n    total_time_no_remap = num_full_warps * expected_time_full_warp\n    \n    if last_warp_size > 0:\n        expected_time_last_warp = get_expected_warp_time(last_warp_size, p_f, p_m, p_b, c_f, c_m, c_b)\n        total_time_no_remap += expected_time_last_warp\n\n    # 3. Calculate Execution Time With Bucketization (T_remap)\n    # T_remap = T_sort + T_exec_bucketed\n    \n    # Sorting cost\n    B = 3  # Number of buckets\n    T_sort = gamma * N + delta * B\n\n    # Bucketed execution cost\n    # Expected number of particles per bucket\n    N_f = N * p_f\n    N_m = N * p_m\n    N_b = N * p_b\n\n    # Number of warps per bucket\n    num_warps_f = np.ceil(N_f / W)\n    num_warps_m = np.ceil(N_m / W)\n    num_warps_b = np.ceil(N_b / W)\n\n    T_exec_bucketed = num_warps_f * c_f + num_warps_m * c_m + num_warps_b * c_b\n    \n    total_time_remap = T_sort + T_exec_bucketed\n\n    return total_time_no_remap, total_time_remap\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "通过并行化最大限度地提高性能，绝不能以牺牲正确性为代价。复杂的并行算法可能会引入一些微妙的错误，例如对随机数生成器（RNG）等共享资源的竞态条件，这些错误是出了名的难以检测。本练习探讨了这种缺陷的隐蔽性：虽然它可能不会使最终的估计值产生偏差，但它会引入虚假的关联，从而使结果的统计不确定性失效。您将分析这种效应，并设计一个基于统计学原理的测试来检测这种隐藏的关联，这是验证任何并行蒙特卡罗代码完整性的关键技能 。",
            "id": "4224517",
            "problem": "在用于核反应堆模拟的基于事件的蒙特卡洛辐射输运中，碰撞、飞行和计数事件作为离散项在由 $K$ 个线程处理的全局事件池中执行。每个线程 $k \\in \\{1,\\dots,K\\}$ 在批次 $t \\in \\{1,\\dots,T\\}$ 期间累积一个批次级计数 $Y_{t,k}$，其中批次将固定数量的工作分组以减少序列相关性。考虑一个线性径迹长度反应率估计器，其中每个事件贡献是一个随机变量 $X_{t,k,i}$，它们同分布，具有有限均值 $E[X_{t,k,i}] = \\mu$ 和方差 $\\operatorname{Var}(X_{t,k,i}) = \\sigma^2$。线程级批次计数为 $Y_{t,k} = \\sum_{i=1}^{N_{t,k}} X_{t,k,i}$，总批次估计器为 $\\hat{\\theta}_t = \\frac{1}{\\sum_{k=1}^{K} N_{t,k}} \\sum_{k=1}^{K} Y_{t,k}$。运行级估计器为 $\\bar{\\theta} = \\frac{1}{T} \\sum_{t=1}^{T} \\hat{\\theta}_t$。\n\n假设所有事件贡献如上所述同分布，并且在正确的随机数生成器（RNG）处理下，基于事件的调度将使得跨线程的计数是独立的。现在假设一个竞争条件导致随机数生成器（RNG）状态在每次抽样时以概率 $\\rho \\in (0,1)$ 在某些线程对之间被无意中共享，从而导致在同一批次内的不同线程间出现重复的随机变量。通过假设在批次 $t$ 内，线程 $k$ 使用的 $X_{t,k,i}$ 中有比例为 $\\rho$ 的部分是同一批次中另一线程 $\\ell \\neq k$ 使用的相应抽样的精确副本，而其余 $1-\\rho$ 的抽样是独立的，来对此进行建模。\n\n分析这种RNG状态共享对运行级估计器 $\\bar{\\theta}$ 的偏差的影响，并基于各线程批次计数 $\\{Y_{t,k}\\}_{t=1}^{T}$ 之间的互相关性，提出一种有统计学原理的检测检验。你可以假设以下经过充分检验的事实：如果输入的随机变量分布正确，线性蒙特卡洛估计器是无偏的；并且在零相关的原假设下，样本皮尔逊相关的Fisher变换是渐近正态的。\n\n哪个选项最好地描述了偏差并提出了一个有效的检测检验？\n\nA. RNG状态共享在 $E[\\bar{\\theta}]$ 中产生一个正偏差，其大小与 $\\rho \\mu$ 成比例，因为重复的抽样会过高地加权高贡献事件；通过计算线程间滞后为0的样本皮尔逊相关，并在任何相关性超过固定阈值 $r  0$ 时宣布存在偏差，且不进行多重比较校正，来进行检测。\n\nB. 对于线性估计器，RNG状态共享不会使 $E[\\bar{\\theta}]$ 产生偏差，因为重复的抽样仍然是同分布的，但它通过正的跨线程协方差增大了 $\\operatorname{Var}(\\bar{\\theta})$；通过估计 $\\{Y_{t,k}\\}$ 和 $\\{Y_{t,\\ell}\\}$ 在 $t=1,\\dots,T$ 上的成对滞后为0的皮尔逊相关 $r_{k\\ell}$，应用Fisher变换 $z_{k\\ell} = \\tfrac{1}{2}\\ln\\frac{1+r_{k\\ell}}{1-r_{k\\ell}}$，并在 $M = \\frac{K(K-1)}{2}$ 个线程对上使用Bonferroni校正，将 $|z_{k\\ell}|$ 与 $z_{1-\\alpha/(2M)} \\sqrt{\\frac{1}{T-3}}$ 进行检验，来进行检测。\n\nC. RNG状态共享在 $E[\\bar{\\theta}]$ 中产生一个负偏差，因为吸收事件被过采样，并且检测应完全依赖于 $\\{Y_{t,k}\\}$ 在非零滞后下的单线程自相关，因为在竞争条件下跨线程相关性会消失。\n\nD. 偏差仅在计数是非线性泛函（例如两个随机和的比率）时出现；检测必须基于比较线程间的估计方差而不是相关性，因为皮尔逊互相关对基于事件的调度中的RNG状态共享不敏感。\n\n选择正确的选项。",
            "solution": "用户要求对一个关于核反应堆模拟中基于事件的蒙特卡洛方法的问题进行批判性分析，特别是随机数生成器（RNG）竞争条件的影响。任务是验证问题陈述的有效性，如果有效，则推导其对指定估计器偏差的影响，并提出一个有效的统计检测检验。最后，我必须评估给出的选项。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **领域**：用于核反应堆模拟的基于事件的蒙特卡洛辐射输运。\n- **并行性**：$K$ 个线程处理来自全局事件池的事件。\n- **索引**：线程索引 $k \\in \\{1,\\dots,K\\}$，批次索引 $t \\in \\{1,\\dots,T\\}$。\n- **估计器组件**：\n    - $X_{t,k,i}$：一个事件贡献，一个随机变量。\n    - $E[X_{t,k,i}] = \\mu$，$\\operatorname{Var}(X_{t,k,i}) = \\sigma^2$（对于所有 $t,k,i$ 都是有限的、同分布的）。\n    - $Y_{t,k} = \\sum_{i=1}^{N_{t,k}} X_{t,k,i}$：线程的批次级计数，其中 $N_{t,k}$ 是批次 $t$ 中线程 $k$ 的事件数。\n- **估计器**：\n    - $\\hat{\\theta}_t = \\frac{1}{\\sum_{k=1}^{K} N_{t,k}} \\sum_{k=1}^{K} Y_{t,k}$：总批次估计器（一个线性径迹长度反应率估计器）。\n    - $\\bar{\\theta} = \\frac{1}{T} \\sum_{t=1}^{T} \\hat{\\theta}_t$：运行级估计器。\n- **缺陷**：RNG状态上的竞争条件。\n- **缺陷模型**：\n    - 对于批次 $t$ 中的每个线程 $k$，其事件贡献 $X_{t,k,i}$ 的一个比例 $\\rho \\in (0,1)$ 是同一批次中另一个线程 $\\ell \\neq k$ 贡献的精确副本。\n    - 剩余比例 $1-\\rho$ 的抽样是独立的。\n- **假设与已知事实**：\n    1.  在没有缺陷的情况下，跨线程的计数是独立的。\n    2.  如果输入的随机变量分布正确，线性蒙特卡洛估计器是无偏的。\n    3.  在零相关的原假设下，样本皮尔逊相关的Fisher变换是渐近正态的。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学基础**：该问题在计算科学领域，特别是在粒子输运的并行蒙特卡洛方法领域，有很好的基础。基于事件的并行、线程级对共享资源（如RNG）的竞争条件、用于方差缩减和统计分析的批处理，以及估计器的形式都是标准且现实的概念。\n- **良构性**：问题是良构的。它为所有变量和估计器提供了清晰的定义，并为缺陷提供了一个可量化的模型（比例为 $\\rho$ 的重复）。它要求对偏差进行具体分析并提出检测方法，为此提供了足够的信息。\n- **客观性**：语言是技术性的、精确的和客观的。没有主观或含糊的陈述。\n\n**步骤3：结论与行动**\n问题陈述在科学上是合理的、良构的、客观的。它是**有效的**。我将继续进行解答推导。\n\n### 解答推导\n\n问题需要分析两个方面：（1）运行级估计器 $\\bar{\\theta}$ 的偏差，以及（2）一种用于检测所述缺陷的有效统计检验。\n\n**1. 偏差分析**\n\n运行级估计器为 $\\bar{\\theta} = \\frac{1}{T} \\sum_{t=1}^{T} \\hat{\\theta}_t$。根据期望的线性性质，其期望值为 $E[\\bar{\\theta}] = \\frac{1}{T} \\sum_{t=1}^{T} E[\\hat{\\theta}_t]$。由于各批次在统计上是独立的且设置相同，所以对于所有 $t$，$E[\\hat{\\theta}_t]$ 是一个常数。因此，$E[\\bar{\\theta}] = E[\\hat{\\theta}_1]$。我们分析单个批次估计器的期望，为清晰起见省略索引 $t$：\n$$\n\\hat{\\theta} = \\frac{\\sum_{k=1}^{K} Y_{k}}{\\sum_{k=1}^{K} N_{k}} = \\frac{\\sum_{k=1}^{K} \\sum_{i=1}^{N_{k}} X_{k,i}}{\\sum_{k=1}^{K} N_{k}}\n$$\n这是一个对 $X$ 变量均值的估计器。分母 $N_{\\text{total}} = \\sum_{k=1}^{K} N_{k}$ 是一个随机变量。这种比率估计器的期望通常是不平凡的。然而，我们可以通过以每个线程的事件数 $\\{N_k\\}_{k=1}^K$ 为条件来分析期望。\n令 $\\mathcal{N} = \\{N_1, \\dots, N_K\\}$ 为事件计数的集合。全期望定律表明 $E[\\hat{\\theta}] = E[E[\\hat{\\theta} | \\mathcal{N}]]$.\n首先，我们计算条件期望：\n$$\nE[\\hat{\\theta} | \\mathcal{N}] = E\\left[ \\frac{\\sum_{k,i} X_{k,i}}{\\sum_k N_k} \\bigg| \\mathcal{N} \\right] = \\frac{1}{\\sum_k N_k} E\\left[ \\sum_{k,i} X_{k,i} \\bigg| \\mathcal{N} \\right]\n$$\n根据期望的线性性质：\n$$\nE[\\hat{\\theta} | \\mathcal{N}] = \\frac{1}{\\sum_k N_k} \\sum_{k,i} E[X_{k,i}]\n$$\n偏差问题的核心在于RNG缺陷是否改变了 $E[X_{k,i}]$。问题陈述说，该缺陷导致一些 $X_{k,i}$ 成为其他 $X_{\\ell,j}$ 的副本。虽然这引入了相关性（$X_{k,i} = X_{\\ell,j}$），但它并没有改变任何单个 $X_{k,i}$ 从中抽样的边缘概率分布。每个 $X_{k,i}$ 仍然是一个期望为 $\\mu$ 的随机变量的实现。问题陈述说这些贡献是“同分布的”。缺陷使它们不再是*独立的*，但它们仍然是同分布的。\n因此，对于所有的 $k,i$，$E[X_{k,i}] = \\mu$。\n将此代入条件期望中：\n$$\nE[\\hat{\\theta} | \\mathcal{N}] = \\frac{1}{\\sum_k N_k} \\sum_{k=1}^K \\sum_{i=1}^{N_k} \\mu = \\frac{1}{\\sum_k N_k} \\left( \\sum_k N_k \\right) \\mu = \\mu\n$$\n由于无论 $N_k$ 的值如何，条件期望都是 $\\mu$，所以总期望也是 $\\mu$：\n$$\nE[\\bar{\\theta}] = E[\\hat{\\theta}] = E[E[\\hat{\\theta} | \\mathcal{N}]] = E[\\mu] = \\mu\n$$\n关于偏差的结论：估计器 $\\bar{\\theta}$ 对于真实均值 $\\mu$ 仍然是无偏的。RNG缺陷不会给这个线性估计器引入偏差。然而，重复的随机数确实会在不同线程的计数之间引起正协方差，例如，对于 $k \\ne \\ell$，$\\operatorname{Cov}(Y_{t,k}, Y_{t,\\ell})  0$。这将增大估计器 $\\bar{\\theta}$ 的方差，如果这种相关性不被考虑在内，将导致对统计误差的低估。\n\n**2. 统计检测检验**\n\n该缺陷的特征是来自不同线程的批次计数序列之间存在正相关。也就是说，线程 $k$ 的序列 $\\{Y_{t,k}\\}_{t=1}^T$ 应与线程 $\\ell$ 的序列 $\\{Y_{t,\\ell}\\}_{t=1}^T$ 相关。一个有效的检测检验必须检查这种相关性。\n\n- **假设**：对于任何线程对 $(k, \\ell)$ 且 $k \\neq \\ell$，我们检验原假设 $H_0: p_{k\\ell} = 0$（无相关）对备择假设 $H_1: p_{k\\ell} \\neq 0$（或更具体地，$p_{k\\ell}  0$），其中 $p_{k\\ell}$ 是 $Y_{t,k}$ 和 $Y_{t,\\ell}$ 总体之间的真实皮尔逊相关系数。\n- **检验统计量**：我们有 $T$ 个配对观测值 $(Y_{1,k}, Y_{1,\\ell}), \\dots, (Y_{T,k}, Y_{T,\\ell})$。我们计算样本皮尔逊相关系数 $r_{k\\ell}$。\n- **变换**：为了检验假设，我们使用Fisher $z$-变换，它能稳定方差并使分布近似正态。该变换为 $z_{k\\ell} = \\frac{1}{2} \\ln\\left(\\frac{1+r_{k\\ell}}{1-r_{k\\ell}}\\right) = \\operatorname{artanh}(r_{k\\ell})$。\n- **$H_0$下的分布**：在原假设（$p_{k\\ell}=0$）下，$z_{k\\ell}$ 近似服从均值为 $0$，标准差为 $\\sigma_z = \\frac{1}{\\sqrt{T-3}}$ 的正态分布。\n- **多重比较**：我们必须对所有唯一的线程对执行此检验。共有 $M = \\binom{K}{2} = \\frac{K(K-1)}{2}$ 对。为了在显著性水平 $\\alpha$ 下控制族系误差率，需要进行多重比较校正。Bonferroni校正是标准方法（尽管保守），它将 $M$ 个独立检验中每个检验的显著性水平设为 $\\alpha/M$。\n- **假设检验程序**：对于每对 $(k, \\ell)$ 的双边检验，如果检验统计量超过临界值，我们拒绝 $H_0$。标准化的检验统计量是 $Z_{k\\ell} = \\frac{z_{k\\ell}}{\\sigma_z} = z_{k\\ell}\\sqrt{T-3}$，在 $H_0$ 下服从标准正态分布 $N(0,1)$。对于显著性水平为 $\\alpha/M$ 的双边检验，临界值为 $z_{1-\\alpha/(2M)}$。因此，如果 $|Z_{k\\ell}|  z_{1-\\alpha/(2M)}$，我们拒绝 $H_0$，这等价于 $|z_{k\\ell}\\sqrt{T-3}|  z_{1-\\alpha/(2M)}$，或 $|z_{k\\ell}|  \\frac{z_{1-\\alpha/(2M)}}{\\sqrt{T-3}}$。这与将 $|z_{k\\ell}|$ 与临界值 $z_{1-\\alpha/(2M)} \\times \\sigma_z = z_{1-\\alpha/(2M)} \\frac{1}{\\sqrt{T-3}}$ 进行比较是相同的。\n\n这个程序构成了一个有统计学原理的检测检验。\n\n### 逐项分析\n\n**A. RNG状态共享在 $E[\\bar{\\theta}]$ 中产生一个正偏差，其大小与 $\\rho \\mu$ 成比例，因为重复的抽样会过高地加权高贡献事件；通过计算线程间滞后为0的样本皮尔逊相关，并在任何相关性超过固定阈值 $r  0$ 时宣布存在偏差，且不进行多重比较校正，来进行检测。**\n- 关于偏差的说法是**不正确的**。如推导所示，线性估计器仍然是无偏的。\n- 提出的检测检验在统计上是薄弱的。使用固定的、任意的相关性阈值是不严谨的，并且不进行多重比较校正将导致在 $K$ 很大时出现不可接受的高假阳性率。\n- 结论：**不正确**。\n\n**B. 对于线性估计器，RNG状态共享不会使 $E[\\bar{\\theta}]$ 产生偏差，因为重复的抽样仍然是同分布的，但它通过正的跨线程协方差增大了 $\\operatorname{Var}(\\bar{\\theta})$；通过估计 $\\{Y_{t,k}\\}$ 和 $\\{Y_{t,\\ell}\\}$ 在 $t=1,\\dots,T$ 上的成对滞后为0的皮尔逊相关 $r_{k\\ell}$，应用Fisher变换 $z_{k\\ell} = \\tfrac{1}{2}\\ln\\frac{1+r_{k\\ell}}{1-r_{k\\ell}}$，并在 $M = \\frac{K(K-1)}{2}$ 个线程对上使用Bonferroni校正，将 $|z_{k\\ell}|$ 与 $z_{1-\\alpha/(2M)} \\sqrt{\\frac{1}{T-3}}$ 进行检验，来进行检测。**\n- 对偏差（“不会...产生偏差”）和方差（“通过正的跨线程协方差增大了...”）的分析是**正确的**。其理由（“重复的抽样仍然是同分布的”）也是正确的。\n- 提出的检测检验在统计上是健全和完整的。它正确地将互相关识别为信号。它使用了适当的Fisher变换和正确的标准误差公式（$\\sigma_z = 1/\\sqrt{T-3}$），并正确地应用了Bonferroni校正进行多重比较。将 $|z_{k\\ell}|$ 与临界值 $z_{1-\\alpha/(2M)} / \\sqrt{T-3}$（在选项中写作 $z_{1-\\alpha/(2M)} \\sqrt{\\frac{1}{T-3}}$）进行比较是正确的程序。\n- 结论：**正确**。\n\n**C. RNG状态共享在 $E[\\bar{\\theta}]$ 中产生一个负偏差，因为吸收事件被过采样，并且检测应完全依赖于 $\\{Y_{t,k}\\}$ 在非零滞后下的单线程自相关，因为在竞争条件下跨线程相关性会消失。**\n- 关于负偏差的说法是**不正确的**。\n- 关于检测应依赖单线程自相关的说法是误导的；主要的信号是跨线程相关性。\n- “在竞争条件下跨线程相关性会消失”的说法与该特定缺陷的实际情况恰恰相反。\n- 结论：**不正确**。\n\n**D. 偏差仅在计数是非线性泛函（例如两个随机和的比率）时出现；检测必须基于比较线程间的估计方差而不是相关性，因为皮尔逊互相关对基于事件的调度中的RNG状态共享不敏感。**\n- 关于非线性估计器中偏差的第一句话是合理的，并且通常是正确的，与我们在线性情况下没有偏差的发现一致。然而，这不是重点。\n- 检测方案存在根本性缺陷。“皮尔逊互相关对RNG状态共享不敏感”的说法是**不正确的**。它恰恰是最直接和最敏感的指标。比较线程间的方差是一种远不那么直接或强大的检验。\n- 结论：**不正确**。",
            "answer": "$$\\boxed{B}$$"
        }
    ]
}