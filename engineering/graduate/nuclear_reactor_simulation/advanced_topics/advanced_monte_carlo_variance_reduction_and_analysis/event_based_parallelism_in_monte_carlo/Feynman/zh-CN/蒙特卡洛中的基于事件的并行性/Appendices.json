{
    "hands_on_practices": [
        {
            "introduction": "将蒙特卡洛模拟迁移到如图形处理单元（GPU）之类的并行架构上，可以释放巨大的计算能力，但同时也带来了新的性能考量。一个根本性的挑战是与启动计算内核相关的开销。本练习将引导您运用一个基础性能模型，确定为有效摊销此固定开销所需的最小批处理大小，从而确保GPU资源被用于有效计算而非管理任务。掌握这种优化是发挥事件驱动并行方法潜力的第一步。",
            "id": "4224488",
            "problem": "在用于图形处理器（GPU）上进行核反应堆模拟的基于事件的蒙特卡洛中子输运核函数中，每次核函数启动会处理一批 $N$ 个事件。每次启动会产生一个固定的核函数启动开销时间 $\\tau_k$，批处理中的每个事件需要一个恒定的计算时间 $c$。将一批事件的效率 $\\eta(N)$ 定义为该批事件的有效计算时间与总壁钟时间之比。请仅使用以下基本定义：(i) 开销增加一个与 $N$ 无关的恒定时间 $\\tau_k$；(ii) 总计算时间随事件数线性累积为 $N c$；(iii) 效率是有效计算时间与总时间之比。推导出保证达到目标效率 $\\eta$（其中 $0  \\eta  1$）的最小整数批处理大小 $N_{\\min}$。\n\n然后，针对一个特定的反应堆物理吞吐量目标，取 $\\tau_k = 8.0\\,\\mu\\mathrm{s}$，$c = 25\\,\\mathrm{ns}$ 和 $\\eta = 0.9$。计算满足目标效率的最小整数批处理大小 $N_{\\min}$，并通过使用这些定义所隐含的简单计时模型来评估 $N_{\\min}$ 处的效率，以验证您的结果。将最终答案表示为一个无单位的整数。",
            "solution": "首先根据提供的标准对问题进行验证。\n\n**步骤1：提取已知条件**\n- 批处理大小：$N$ 个事件\n- 固定的核函数启动开销时间：$\\tau_k$\n- 每个事件的恒定计算时间：$c$\n- 一批事件的效率：$\\eta(N)$，定义为有效计算时间与该批处理总壁钟时间之比。\n- 基本定义 (i)：开销增加一个与 $N$ 无关的恒定时间 $\\tau_k$。\n- 基本定义 (ii)：总计算时间随事件数线性累积为 $N c$。\n- 基本定义 (iii)：效率是有效计算时间与总时间之比。\n- 目标效率：$\\eta$，其中 $0  \\eta  1$。\n- 目标1：推导出保证效率至少为 $\\eta$ 的最小整数批处理大小 $N_{\\min}$。\n- 目标2：使用具体值 $\\tau_k = 8.0\\,\\mu\\mathrm{s}$，$c = 25\\,\\mathrm{ns}$ 和 $\\eta = 0.9$ 计算 $N_{\\min}$。\n- 目标3：通过计算 $N_{\\min}$ 处的效率来验证结果。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法恰当且客观。它描述了一个用于高性能计算（尤其适用于像GPU这样的吞吐量导向架构）的标准简化性能模型。启动开销和每元素处理时间的概念是性能分析的基础。给出的定义对于构建数学模型是充分且一致的。该问题要求解一个不等式的最小整数解，这是一个明确定义的数学任务。为 $\\tau_k$、$c$ 和 $\\eta$ 提供的值在现代硬件和模拟环境中是物理上现实的。该问题不是病态的、模糊的或微不足道的。它代表了性能优化中的一个基本问题。\n\n**结论：** 该问题有效。\n\n**步骤3：求解推导**\n\n根据所提供的定义，我们首先将效率 $\\eta(N)$ 的表达式形式化。一批 $N$ 个事件的“有效计算时间”是用于计算的总时间，即事件数量与每个事件所需时间的乘积。\n设 $T_{\\text{compute}}$ 为总有效计算时间。根据定义(ii)：\n$$T_{\\text{compute}}(N) = N c$$\n\n该批处理的“总壁钟时间”，我们称之为 $T_{\\text{total}}(N)$，是有效计算时间与固定的核函数启动开销之和。根据定义(i)和(ii)：\n$$T_{\\text{total}}(N) = T_{\\text{compute}}(N) + \\tau_k = N c + \\tau_k$$\n\n效率 $\\eta(N)$ 是批处理大小 $N$ 的函数。根据定义(iii)，它是有效计算时间与总壁钟时间之比：\n$$\\eta(N) = \\frac{T_{\\text{compute}}(N)}{T_{\\text{total}}(N)} = \\frac{N c}{N c + \\tau_k}$$\n\n问题要求找到保证达到目标效率 $\\eta$ 的最小整数批处理大小 $N_{\\min}$。这可以转化为不等式：\n$$\\eta(N) \\ge \\eta$$\n代入 $\\eta(N)$ 的表达式，我们得到：\n$$\\frac{N c}{N c + \\tau_k} \\ge \\eta$$\n由于 $N$ 是批处理大小，所以 $N \\ge 1$。常数 $c$ 和 $\\tau_k$ 是时间，因此它们是正数。所以，分母 $N c + \\tau_k$ 严格为正。我们可以在不等式两边同乘以这个项，而不会改变不等号的方向：\n$$N c \\ge \\eta (N c + \\tau_k)$$\n$$N c \\ge \\eta N c + \\eta \\tau_k$$\n为了解出 $N$，我们将所有含 $N$ 的项移到一边：\n$$N c - \\eta N c \\ge \\eta \\tau_k$$\n$$N(c - \\eta c) \\ge \\eta \\tau_k$$\n$$N c (1 - \\eta) \\ge \\eta \\tau_k$$\n问题说明 $0  \\eta  1$，这意味着 $1 - \\eta$ 是一个正数。因此，我们可以将不等式两边同除以 $c(1 - \\eta)$ 而不改变其方向：\n$$N \\ge \\frac{\\eta \\tau_k}{c (1 - \\eta)}$$\n这个不等式规定了批处理大小 $N$ 必须满足的条件。问题要求的是*最小整数*批处理大小 $N_{\\min}$。这是满足该条件的最小整数 $N$ 值。这个整数可以通过对右侧表达式取上取整（ceiling）得到：\n$$N_{\\min} = \\left\\lceil \\frac{\\eta \\tau_k}{c(1-\\eta)} \\right\\rceil$$\n\n这样就完成了符号推导。现在，我们使用所提供的数据计算 $N_{\\min}$ 的数值：$\\tau_k = 8.0\\,\\mu\\mathrm{s}$，$c = 25\\,\\mathrm{ns}$ 和 $\\eta = 0.9$。\n首先，我们确保单位一致。我们将两个时间值都转换为秒：\n$\\tau_k = 8.0 \\times 10^{-6}\\,\\mathrm{s}$\n$c = 25 \\times 10^{-9}\\,\\mathrm{s}$\n\n我们可以计算无量纲比率 $\\frac{\\tau_k}{c}$：\n$$\\frac{\\tau_k}{c} = \\frac{8.0 \\times 10^{-6}}{25 \\times 10^{-9}} = \\frac{8.0}{25} \\times 10^3 = 0.32 \\times 10^3 = 320$$\n现在，将 $\\eta$ 的值和比率 $\\frac{\\tau_k}{c}$ 代入关于 $N$ 的不等式中：\n$$N \\ge \\frac{0.9}{1 - 0.9} \\left( \\frac{\\tau_k}{c} \\right)$$\n$$N \\ge \\frac{0.9}{0.1} \\times 320$$\n$$N \\ge 9 \\times 320$$\n$$N \\ge 2880$$\n由于下界是一个整数，满足不等式的最小整数 $N$ 是 $N_{\\min} = 2880$。\n$$N_{\\min} = 2880$$\n\n最后，我们通过计算批处理大小为 $N_{\\min} = 2880$ 时所达到的效率来验证此结果。\n$$\\eta(N_{\\min}) = \\eta(2880) = \\frac{2880 \\cdot c}{2880 \\cdot c + \\tau_k}$$\n为简化计算，我们可以将分子和分母同除以 $c$：\n$$\\eta(2880) = \\frac{2880}{2880 + \\frac{\\tau_k}{c}}$$\n使用我们之前计算出的比率 $\\frac{\\tau_k}{c} = 320$：\n$$\\eta(2880) = \\frac{2880}{2880 + 320} = \\frac{2880}{3200}$$\n简化分数：\n$$\\eta(2880) = \\frac{288}{320} = \\frac{144}{160} = \\frac{72}{80} = \\frac{36}{40} = \\frac{9}{10} = 0.9$$\n$N_{\\min} = 2880$ 时的效率恰好是 $0.9$，与目标效率 $\\eta$ 相符。这验证了我们对 $N_{\\min}$ 的计算。",
            "answer": "$$\\boxed{2880}$$"
        },
        {
            "introduction": "除了管理内核启动开销外，在GPU上实现基于事件的蒙特卡洛方法的峰值性能，还需要解决架构特定的挑战，例如“线程束发散”（warp divergence）。当一个线程束内的线程因条件分支（这在粒子散射物理中很常见）而执行不同指令时，性能会受到影响。本实践深入探讨了这个问题，要求您设计并分析一种“分桶”策略，通过按计算路径对粒子进行排序来消除发散，这是一种优化复杂物理内核的强大技术。",
            "id": "4224563",
            "problem": "考虑在核反应堆堆芯中进行中子输运的基于事件的蒙特卡洛 (MC) 模拟，其中散射事件在图形处理单元 (GPU) 上通过单指令多线程 (SIMT) 执行模型进行处理。中子的角散射由关于散射角余弦 $\\mu \\in [-1,1]$ 的归一化各向异性核函数描述，其 Legendre 展开至二阶为：\n$$\np(\\mu) = \\frac{1}{2}\\left(1 + a_1 \\mu + \\frac{a_2}{2}\\left(3\\mu^2 - 1\\right)\\right),\n$$\n其中 $a_1$ 和 $a_2$ 是各向异性系数。选择归一化常数以满足 $\\int_{-1}^{1} p(\\mu)\\,d\\mu = 1$。该散射核函数导致散射例程中出现与角度相关的代码路径：前向散射、中心散射和后向散射。这些路径由单个参数 $\\mu_t \\in (0,1)$ 定义的角度阈值触发，具体如下：\n- 如果 $\\mu \\in [\\mu_t, 1]$，则采用前向路径，\n- 如果 $\\mu \\in (-\\mu_t, \\mu_t)$，则采用中心路径，\n- 如果 $\\mu \\in [-1, -\\mu_t]$，则采用后向散射路径。\n\n假设每条路径具有固定的路径执行成本，以无单位时间单位建模，前向、中心和后向散射的成本分别为 $c_f$、$c_m$ 和 $c_b$。GPU 的线程束大小为 $W$ 个线程。在 SIMT 执行中，当一个线程束内的线程采用不同分支时，会发生线程束级别的分歧；该线程束会串行执行其内部存在的所有分支，对每个存在于线程束内的不同分支支付一次其成本，而与采用该分支的线程数量无关。\n\n您需要设计一种“分桶”（重新映射）策略，该策略根据与角度相关的路径键（前向、中心、后向散射）将粒子分配到连续的桶中，以最小化线程束内分歧。该重新映射需要按整数桶键（三个桶）对粒子进行排序，其开销估计由类似计数排序的成本模型给出\n$$\nT_{\\text{sort}} = \\gamma N + \\delta B,\n$$\n其中 $N$ 是粒子数，$B$ 是桶的数量（此处 $B=3$），$\\gamma$ 和 $\\delta$ 是正常数。排序后，每个桶由大小为 $W$ 的完整线程束进行处理；位于桶末尾的部分填充的线程束仍然会产生该桶的完整路径成本。\n\n仅从上述给定的基本框架出发，包括 Boltzmann 输运框架（散射核函数和归一化）、SIMT 分歧行为以及整数键排序成本模型，推导以下内容：\n- 通过在相应的角度区间上对给定的 $p(\\mu)$ 进行积分，得出分别落入后向散射、中心和前向桶的概率 $p_b$、$p_m$ 和 $p_f$。\n- 在没有任何重新映射的情况下，处理 $N$ 个粒子（以大小为 $W$ 的线程束进行处理）的预期总执行时间（以无单位时间单位表示），其中每个线程束的时间是其内部存在的不同路径的成本之和。\n- 采用分桶（分为三个桶）策略的总执行时间，包括排序开销和分桶后的执行时间，其中每个桶的线程束数量是预期桶内粒子数除以 $W$ 的向上取整。\n\n您的程序必须为下面指定的每个测试用例计算两个输出：没有重新映射的总时间，以及分桶为三个角度桶的总时间。所有最终结果均表示为无单位的浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容按以下顺序排列：对于每个测试用例，首先输出无重新映射的总时间，然后是分桶后的总时间；因此，最终列表的长度是测试用例数量的两倍。\n\n测试套件：\n- 案例 A（正常路径）：$N=65536$, $W=32$, $a_1=0.2$, $a_2=0.1$, $\\mu_t=0.6$, $c_f=6.0$, $c_m=4.0$, $c_b=7.0$, $\\gamma=0.25$, $\\delta=400.0$。\n- 案例 B（前向峰值各向异性）：$N=65536$, $W=32$, $a_1=0.6$, $a_2=0.2$, $\\mu_t=0.8$, $c_f=8.0$, $c_m=5.0$, $c_b=9.0$, $\\gamma=0.2$, $\\delta=400.0$。\n- 案例 C（边界情况，由于 $W=1$ 无分歧）：$N=1000$, $W=1$, $a_1=0.0$, $a_2=0.0$, $\\mu_t=0.5$, $c_f=6.0$, $c_m=6.0$, $c_b=6.0$, $\\gamma=0.3$, $\\delta=200.0$。\n- 案例 D（更大的线程束大小）：$N=262144$, $W=64$, $a_1=0.3$, $a_2=-0.1$, $\\mu_t=0.7$, $c_f=7.0$, $c_m=4.0$, $c_b=8.0$, $\\gamma=0.25$, $\\delta=600.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），列表项为浮点数，按 A、B、C、D 的顺序对应于每个测试用例的：（无重新映射总时间）、（分桶后总时间）。所有计算必须根据给定的定义进行解析计算，不得进行任何随机抽样。所有输出必须如指定的那样是无单位的。",
            "solution": "用户提供的问题是有效的，因为它在科学上基于核反应堆物理和并行计算原理，在数学上是适定的，并且使用客观、精确的语言进行表述。所有必要的参数都已提供，并且所需的推导可以通过解析方法实现。\n\n本解答提出了在 GPU 上进行蒙特卡洛中子散射模拟的总执行时间的解析推导，涵盖了使用和不使用粒子分桶策略两种情况。\n\n### 1. 路径概率的推导\n\n中子散射到特定角度范围内的概率，是通过将归一化的各向异性散射核函数 $p(\\mu)$ 在散射角余弦 $\\mu$ 的相应区间上积分来确定的。\n\n散射核函数以二阶 Legendre 展开形式给出：\n$$\np(\\mu) = \\frac{1}{2}\\left(1 + a_1 \\mu + \\frac{a_2}{2}\\left(3\\mu^2 - 1\\right)\\right)\n$$\n该概率密度函数被归一化以满足 $\\int_{-1}^{1} p(\\mu)\\,d\\mu = 1$。三个角度路径由参数 $\\mu_t \\in (0,1)$ 定义：\n- 前向路径 (f): $\\mu \\in [\\mu_t, 1]$\n- 中心路径 (m): $\\mu \\in (-\\mu_t, \\mu_t)$\n- 后向散射路径 (b): $\\mu \\in [-1, -\\mu_t]$\n\n为了求出每条路径的概率，我们计算 $p(\\mu)$ 在每个区间上的定积分。首先，我们求出 $p(\\mu)$ 的不定积分，记为 $P(\\mu)$：\n$$\nP(\\mu) = \\int p(\\mu)\\,d\\mu = \\frac{1}{2} \\int \\left( \\left(1-\\frac{a_2}{2}\\right) + a_1 \\mu + \\frac{3a_2}{2}\\mu^2 \\right) d\\mu\n$$\n$$\nP(\\mu) = \\frac{1}{2} \\left( \\left(1-\\frac{a_2}{2}\\right)\\mu + \\frac{a_1}{2}\\mu^2 + \\frac{a_2}{2}\\mu^3 \\right) + C\n$$\n\n概率 $p_f$、$p_m$ 和 $p_b$ 分别为：\n\n**中心路径概率 ($p_m$)：**\n$$\np_m = \\int_{-\\mu_t}^{\\mu_t} p(\\mu)\\,d\\mu = P(\\mu_t) - P(-\\mu_t)\n$$\n$$\np_m = \\frac{1}{2} \\left[ \\left( \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 + \\frac{a_2}{2}\\mu_t^3 \\right) - \\left( -\\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right) \\right]\n$$\n$$\np_m = \\frac{1}{2} \\left[ 2\\left(1-\\frac{a_2}{2}\\right)\\mu_t + 2\\frac{a_2}{2}\\mu_t^3 \\right] = \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_2}{2}\\mu_t^3 = \\mu_t + \\frac{a_2}{2}\\left(\\mu_t^3 - \\mu_t\\right)\n$$\n\n**前向路径概率 ($p_f$)：**\n$$\np_f = \\int_{\\mu_t}^{1} p(\\mu)\\,d\\mu = P(1) - P(\\mu_t)\n$$\n$$\nP(1) = \\frac{1}{2} \\left( \\left(1-\\frac{a_2}{2}\\right) + \\frac{a_1}{2} + \\frac{a_2}{2} \\right) = \\frac{1}{2}\\left(1 + \\frac{a_1}{2}\\right)\n$$\n$$\np_f = \\frac{1}{2}\\left(1 + \\frac{a_1}{2}\\right) - \\frac{1}{2} \\left( \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 + \\frac{a_2}{2}\\mu_t^3 \\right)\n$$\n$$\np_f = \\frac{1}{2} \\left[ 1 + \\frac{a_1}{2} - \\left(1-\\frac{a_2}{2}\\right)\\mu_t - \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right]\n$$\n\n**后向散射路径概率 ($p_b$)：**\n$$\np_b = \\int_{-1}^{-\\mu_t} p(\\mu)\\,d\\mu = P(-\\mu_t) - P(-1)\n$$\n$$\nP(-1) = \\frac{1}{2} \\left( -\\left(1-\\frac{a_2}{2}\\right) + \\frac{a_1}{2} - \\frac{a_2}{2} \\right) = \\frac{1}{2}\\left(-1 + \\frac{a_1}{2}\\right)\n$$\n$$\np_b = \\frac{1}{2} \\left( -\\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right) - \\frac{1}{2}\\left(-1 + \\frac{a_1}{2}\\right)\n$$\n$$\np_b = \\frac{1}{2} \\left[ 1 - \\frac{a_1}{2} - \\left(1-\\frac{a_2}{2}\\right)\\mu_t + \\frac{a_1}{2}\\mu_t^2 - \\frac{a_2}{2}\\mu_t^3 \\right]\n$$\n这三个概率之和为 $1$。\n\n### 2. 无重新映射的执行时间 ($T_{\\text{no-remap}}$)\n\n在没有重新映射的情况下，对应于 $N$ 个粒子的线程被分组成大小为 $W$ 的线程束。在 SIMT 架构上，如果一个线程束内的线程发生分歧（即采用不同的代码路径），该线程束将串行执行每个不同的路径。一个线程束的成本是其线程所采用的所有唯一路径的成本之和。\n\n我们来求大小为 $w$ 的单个线程束的预期执行时间。某个特定路径（例如前向路径 $f$）存在于线程束中的概率是 $1$ 减去线程束中*没有*线程采用该路径的概率。单个线程*不*采用路径 $f$ 的概率是 $1 - p_f$。对于 $w$ 个独立线程，这个概率是 $(1 - p_f)^w$。\n- 路径 $f$ 存在的概率：$P(\\text{f present}) = 1 - (1 - p_f)^w$\n- 路径 $m$ 存在的概率：$P(\\text{m present}) = 1 - (1 - p_m)^w$\n- 路径 $b$ 存在的概率：$P(\\text{b present}) = 1 - (1 - p_b)^w$\n\n大小为 $w$ 的线程束的预期时间 $E[T_{\\text{warp}}(w)]$ 是每个路径的成本乘以其出现概率的总和：\n$$\nE[T_{\\text{warp}}(w)] = c_f \\left(1 - (1-p_f)^w\\right) + c_m \\left(1 - (1-p_m)^w\\right) + c_b \\left(1 - (1-p_b)^w\\right)\n$$\n对于总共 $N$ 个粒子，有 $N_{full} = \\lfloor N/W \\rfloor$ 个大小为 $W$ 的完整线程束，以及（如果 $N$ 不是 $W$ 的倍数）一个大小为 $W_{\\text{last}} = N \\pmod W$ 的部分填充线程束。\n\n总预期时间是所有线程束预期时间之和：\n$$\nT_{\\text{no-remap}} = \\lfloor N/W \\rfloor \\cdot E[T_{\\text{warp}}(W)] + E[T_{\\text{warp}}(N \\pmod W)]\n$$\n其中，仅当 $N \\pmod W > 0$ 时才添加第二项。\n\n### 3. 采用分桶策略的执行时间 ($T_{\\text{remap}}$)\n\n分桶策略包括两个阶段：排序和执行。总时间是每个阶段的时间之和。\n$$\nT_{\\text{remap}} = T_{\\text{sort}} + T_{\\text{exec,bucketed}}\n$$\n\n**排序成本 ($T_{\\text{sort}}$)：**\n问题提供了一个排序开销的模型：\n$$\nT_{\\text{sort}} = \\gamma N + \\delta B\n$$\n对于 $B=3$ 个桶（前向、中心、后向散射），成本为：\n$$\nT_{\\text{sort}} = \\gamma N + 3\\delta\n$$\n\n**分桶后执行成本 ($T_{\\text{exec,bucketed}}$)：**\n排序后，粒子按其目标路径分组。处理特定桶的线程束中的所有线程都将执行相同的代码路径，从而消除了线程束内分歧。\n每个桶中的预期粒子数为 $N_f = N p_f$、$N_m = N p_m$ 和 $N_b = N p_b$。\n问题规定，每个桶的线程束数量计算为预期桶内粒子数除以线程束大小 $W$ 的向上取整：\n- 前向桶的线程束：$N_{\\text{warps},f} = \\lceil N p_f / W \\rceil$\n- 中心桶的线程束：$N_{\\text{warps},m} = \\lceil N p_m / W \\rceil$\n- 后向散射桶的线程束：$N_{\\text{warps},b} = \\lceil N p_b / W \\rceil$\n\n前向桶中的每个线程束成本为 $c_f$，中心桶为 $c_m$，后向散射桶为 $c_b$。分桶后的总执行时间为：\n$$\nT_{\\text{exec,bucketed}} = N_{\\text{warps},f} \\cdot c_f + N_{\\text{warps},m} \\cdot c_m + N_{\\text{warps},b} \\cdot c_b\n$$\n$$\nT_{\\text{exec,bucketed}} = \\lceil Np_f/W \\rceil c_f + \\lceil Np_m/W \\rceil c_m + \\lceil Np_b/W \\rceil c_b\n$$\n采用重新映射的总时间是这两个部分的总和。\n\n### 公式摘要\n计算过程首先是为给定的测试用例计算 $p_f, p_m, p_b$。然后，使用这些概率和推导出的公式来计算 $T_{\\text{no-remap}}$ 和 $T_{\\text{remap}}$。\n- $T_{\\text{no-remap}} = \\lfloor N/W \\rfloor \\left( \\sum_{k \\in \\{f,m,b\\}} c_k(1-(1-p_k)^W) \\right) + \\mathbf{1}_{N \\pmod W \\neq 0} \\left( \\sum_{k \\in \\{f,m,b\\}} c_k(1-(1-p_k)^{N \\pmod W}) \\right)$\n- $T_{\\text{remap}} = (\\gamma N + 3\\delta) + c_f \\lceil Np_f/W \\rceil + c_m \\lceil Np_m/W \\rceil + c_b \\lceil Np_b/W \\rceil$\n\n将实施这些公式来求解给定的测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the total execution time for a Monte Carlo simulation \n    both without and with a particle bucketization strategy.\n    \"\"\"\n    \n    # Test cases are defined as tuples of parameters:\n    # (N, W, a1, a2, mu_t, c_f, c_m, c_b, gamma, delta)\n    test_cases = [\n        # Case A (happy path)\n        (65536, 32, 0.2, 0.1, 0.6, 6.0, 4.0, 7.0, 0.25, 400.0),\n        # Case B (forward-peaked anisotropy)\n        (65536, 32, 0.6, 0.2, 0.8, 8.0, 5.0, 9.0, 0.2, 400.0),\n        # Case C (boundary, no divergence due to W=1)\n        (1000, 1, 0.0, 0.0, 0.5, 6.0, 6.0, 6.0, 0.3, 200.0),\n        # Case D (larger warp size)\n        (262144, 64, 0.3, -0.1, 0.7, 7.0, 4.0, 8.0, 0.25, 600.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        time_no_remap, time_remap = calculate_times_for_case(*case)\n        results.append(time_no_remap)\n        results.append(time_remap)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_times_for_case(N, W, a1, a2, mu_t, c_f, c_m, c_b, gamma, delta):\n    \"\"\"\n    Calculates execution times for a single test case.\n    \n    Args:\n        N (int): Number of particles.\n        W (int): Warp size.\n        a1, a2 (float): Anisotropy coefficients.\n        mu_t (float): Angle threshold.\n        c_f, c_m, c_b (float): Path execution costs.\n        gamma, delta (float): Sorting cost coefficients.\n\n    Returns:\n        tuple: (total time without remapping, total time with bucketization).\n    \"\"\"\n\n    # 1. Calculate Path Probabilities (p_f, p_m, p_b)\n    # p_m = mu_t + a2/2 * (mu_t^3 - mu_t)\n    p_m = mu_t + 0.5 * a2 * (mu_t**3 - mu_t)\n    \n    # p_f = 0.5 * [1 + a1/2 - (1-a2/2)*mu_t - a1/2*mu_t^2 - a2/2*mu_t^3]\n    p_f = 0.5 * (1 + 0.5 * a1 - (1 - 0.5 * a2) * mu_t - 0.5 * a1 * mu_t**2 - 0.5 * a2 * mu_t**3)\n\n    # p_b can be derived from p_f and p_m, or calculated directly.\n    # To maintain precision, we use the direct formula, but 1 - p_f - p_m is also valid.\n    # p_b = 0.5 * [1 - a1/2 - (1-a2/2)*mu_t + a1/2*mu_t^2 - a2/2*mu_t^3]\n    p_b = 1.0 - p_f - p_m\n\n    # 2. Calculate Execution Time Without Remapping (T_no_remap)\n    \n    # Function to calculate expected time for a warp of a given size `w`\n    def get_expected_warp_time(w, p_f, p_m, p_b, c_f, c_m, c_b):\n        if w == 0:\n            return 0.0\n        time = 0.0\n        # Contribution from forward path\n        prob_f_present = 1.0 - (1.0 - p_f)**w\n        time += c_f * prob_f_present\n        # Contribution from central path\n        prob_m_present = 1.0 - (1.0 - p_m)**w\n        time += c_m * prob_m_present\n        # Contribution from backscattering path\n        prob_b_present = 1.0 - (1.0 - p_b)**w\n        time += c_b * prob_b_present\n        return time\n\n    num_full_warps = N // W\n    last_warp_size = N % W\n\n    expected_time_full_warp = get_expected_warp_time(W, p_f, p_m, p_b, c_f, c_m, c_b)\n    total_time_no_remap = num_full_warps * expected_time_full_warp\n    \n    if last_warp_size > 0:\n        expected_time_last_warp = get_expected_warp_time(last_warp_size, p_f, p_m, p_b, c_f, c_m, c_b)\n        total_time_no_remap += expected_time_last_warp\n\n    # 3. Calculate Execution Time With Bucketization (T_remap)\n    # T_remap = T_sort + T_exec_bucketed\n    \n    # Sorting cost\n    B = 3  # Number of buckets\n    T_sort = gamma * N + delta * B\n\n    # Bucketed execution cost\n    # Expected number of particles per bucket\n    N_f = N * p_f\n    N_m = N * p_m\n    N_b = N * p_b\n\n    # Number of warps per bucket\n    num_warps_f = np.ceil(N_f / W)\n    num_warps_m = np.ceil(N_m / W)\n    num_warps_b = np.ceil(N_b / W)\n\n    T_exec_bucketed = num_warps_f * c_f + num_warps_m * c_m + num_warps_b * c_b\n    \n    total_time_remap = T_sort + T_exec_bucketed\n\n    return total_time_no_remap, total_time_remap\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在实现了事件驱动并行和粒子重排等复杂优化之后，一个关键的最后步骤是验证新的高性能代码产生的结果与可信的传统实现版本在统计上是等效的。仅仅未能发现差异并不构成等效性的证明。本练习介绍了被称为“双单侧检验”（TOST）的严谨统计方法，用于在一个预定义的、具有物理意义的容差范围内，正式证明两个代码在统计上是等效的，这是代码验证与确认（VV）中的一项核心技能。",
            "id": "4224482",
            "problem": "一个核反应堆堆芯模拟通过蒙特卡洛（MC）粒子输运来估计单元中子通量。考虑了两种实现：一种是传统的基于历史的程序，另一种是同时处理许多粒子输运事件的基于事件的并行程序。两种实现都在给定单元中产生一个无偏的径迹长度通量计数，该计数是每个历史贡献的样本均值。设每个历史的贡献为一个随机变量 $X$，其均值为 $\\mu$ 且方差为 $\\sigma^{2}$，两者均为有限值。来自 $N$ 个历史的单元通量估计量为 $\\hat{T} = \\frac{1}{N}\\sum_{i=1}^{N} X_{i}$。\n\n运行被组织成不重叠的批次以减轻序列相关性，从基于历史的程序中得到批次均值 $\\{\\bar{T}_{H,k}\\}_{k=1}^{n_{H}}$，从基于事件的程序中得到批次均值 $\\{\\bar{T}_{E,\\ell}\\}_{\\ell=1}^{n_{E}}$。假设每个程序内的批次均值近似独立同分布且具有有限方差，并且两个程序使用独立的随机数流。将基于历史的程序的真实期望批次均值计数记为 $\\mu_{H}$，将基于事件的程序的真实期望批次均值计数记为 $\\mu_{E}$。\n\n使用大数定律和中心极限定理（CLT），可以将批次均值的平均值 $\\bar{X}_{H} = \\frac{1}{n_{H}}\\sum_{k=1}^{n_{H}} \\bar{T}_{H,k}$ 和 $\\bar{X}_{E} = \\frac{1}{n_{E}}\\sum_{\\ell=1}^{n_{E}} \\bar{T}_{E,\\ell}$ 的抽样分布近似为均值为 $\\mu_{H}$ 和 $\\mu_{E}$ 且方差随 $n_{H}$ 和 $n_{E}$ 减小的正态分布。\n\n假设指定了一个特定应用的等价界限 $\\delta  0$，表示相对于建模目标而言，物理上可忽略的最大通量差异。在显著性水平 $\\alpha$ 下，选择正确定义两种实现的统计等价性，并为在上述假设下比较计数提出有效假设检验的选项。\n\nA. 将统计等价性定义为 $|\\mu_{H} - \\mu_{E}|  \\delta$。使用带有 Welch 标准误的两个单侧 t 检验（Two One-Sided Tests, TOST）进行检验。具体来说，令 $s_{H}^{2}$ 和 $s_{E}^{2}$ 分别为 $\\{\\bar{T}_{H,k}\\}$ 和 $\\{\\bar{T}_{E,\\ell}\\}$ 的样本方差，并定义标准误 $S = \\sqrt{\\frac{s_{H}^{2}}{n_{H}} + \\frac{s_{E}^{2}}{n_{E}}}$。执行两个检验：$H_{0,L}: \\mu_{H} - \\mu_{E} \\le -\\delta$ 对 $H_{1,L}: \\mu_{H} - \\mu_{E} > -\\delta$，使用 $t_{L} = \\frac{(\\bar{X}_{H} - \\bar{X}_{E}) + \\delta}{S}$；以及 $H_{0,U}: \\mu_{H} - \\mu_{E} \\ge \\delta$ 对 $H_{1,U}: \\mu_{H} - \\mu_{E}  \\delta$，使用 $t_{U} = \\frac{(\\bar{X}_{H} - \\bar{X}_{E}) - \\delta}{S}$。使用 Welch–Satterthwaite 自由度作为临界值，如果两个单侧检验都在水平 $\\alpha$ 下被拒绝，则声明等价。\n\nB. 将统计等价性定义为每个事件贡献的完整分布相等，并使用 Kolmogorov–Smirnov (KS) 检验对来自两个程序的事件贡献的合并集合进行检验，采用相同的随机数流（共同随机数）以提高灵敏度。在水平 $\\alpha$ 下，未能拒绝分布相等意味着等价。\n\nC. 将统计等价性定义为期望计数相等，即 $\\mu_{H} = \\mu_{E}$。使用双侧、合并方差的学生 t 检验来检验 $H_{0}: \\mu_{H} - \\mu_{E} = 0$ 对 $H_{1}: \\mu_{H} - \\mu_{E} \\ne 0$，显著性水平为 $\\alpha$，如果原假设未被拒绝，则判定为等价。\n\nD. 将统计等价性定义为 $|\\mu_{H} - \\mu_{E}| \\le \\delta$，并通过为 $\\mu_{H}$ 和 $\\mu_{E}$ 构建两个独立的 $(1-\\alpha)$ 双侧置信区间进行检验；如果区间重叠且其中点之差小于 $\\delta$，则声明等价。",
            "solution": "用户提供了一个关于核反应堆分析中两种蒙特卡洛模拟程序统计比较的问题。任务是验证问题陈述的有效性，然后确定建立两种程序之间统计等价性的正确方法。\n\n### 第一步：提取已知条件\n\n- **问题领域：** 用于核反应堆堆芯模拟的蒙特卡洛（MC）粒子输运，以估计单元中子通量。\n- **实现：** 1) 传统的基于历史的程序和 2) 基于事件的并行程序。\n- **估计量：** 两种程序都使用无偏的径迹长度通量计数，该计数由每个历史贡献的样本均值给出。\n- **随机变量：** $X$ 是每个历史的贡献，具有有限均值 $\\mu$ 和有限方差 $\\sigma^2$。\n- **$N$个历史的计数估计量：** $\\hat{T} = \\frac{1}{N}\\sum_{i=1}^{N} X_{i}$。\n- **批处理：** 运行被划分为不重叠的批次。\n- **批次均值数据：**\n    - 基于历史的程序： $\\{\\bar{T}_{H,k}\\}_{k=1}^{n_{H}}$。\n    - 基于事件的程序： $\\{\\bar{T}_{E,\\ell}\\}_{\\ell=1}^{n_{E}}$。\n- **假设：**\n    1. 每个程序内的批次均值近似独立同分布（i.i.d.）且具有有限方差。\n    2. 两个程序使用独立的随机数流。\n- **关注的参数（真实均值）：**\n    - $\\mu_{H}$：基于历史的程序的真实期望批次均值计数。\n    - $\\mu_{E}$：基于事件的程序的真实期望批次均值计数。\n- **总样本均值：**\n    - $\\bar{X}_{H} = \\frac{1}{n_{H}}\\sum_{k=1}^{n_{H}} \\bar{T}_{H,k}$。\n    - $\\bar{X}_{E} = \\frac{1}{n_{E}}\\sum_{\\ell=1}^{n_{E}} \\bar{T}_{E,\\ell}$。\n- **分布模型：** 基于中心极限定理（CLT），$\\bar{X}_{H}$ 和 $\\bar{X}_{E}$ 的抽样分布被近似为正态分布。\n    - $\\bar{X}_{H} \\approx \\mathcal{N}(\\mu_{H}, \\text{Var}(\\bar{T}_{H,k})/n_H)$。\n    - $\\bar{X}_{E} \\approx \\mathcal{N}(\\mu_{E}, \\text{Var}(\\bar{T}_{E,\\ell})/n_E)$。\n- **等价性规范：**\n    - 等价界限 $\\delta > 0$，代表物理上可忽略的最大通量差异。\n    - 显著性水平 $\\alpha$。\n- **目标：** 选择在这些假设下正确定义统计等价性并提出有效假设检验的选项。\n\n### 第二步：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行审查。\n\n- **科学依据：** 该问题牢固地植根于计算物理程序的验证与确认（VV）领域。\n- **适定性：** 该问题是适定的。它提出了一个具有明确假设的清晰场景，并要求从一组选项中识别出正确的统计方法。在统计假设检验的框架内，预计存在一个唯一的正确答案。\n- **客观性：** 语言正式、精确，没有主观或含糊的术语。\n- **不完整性/矛盾：** 该问题提供了一套一致且充分的假设来构建一个假设检验。“近似独立”批次均值的假设是在此背景下应用中心极限定理的一个标准且必要的简化。独立的随机数流这一假设是选择正确统计检验（非配对检验）的关键信息。\n- **不切实际/不可行：** 该场景非常现实。比较模拟程序的不同实现以确定其等价性是软件VV中的一个标准任务。\n- **其他缺陷：** 该问题不是不适定的、琐碎的或不可验证的。它探讨了应用统计学中一个细微但重要的概念：检验差异与检验等价性之间的区别。\n\n### 第三步：结论与行动\n\n问题陈述是**有效的**。这是一个在应用统计学领域中表述良好的问题，与计算核工程领域相关。后续步骤将推导正确的方法并评估给定的选项。\n\n### 解答推导\n\n核心任务是建立两种程序之间的“统计等价性”，这意味着它们的期望输出 $\\mu_H$ 和 $\\mu_E$ 足够接近，以至于在实际应用中可以被认为是可互换的。“接近程度”由等价界限 $\\delta$ 来量化。\n\n等价性的陈述是，真实均值之间的绝对差小于界限 $\\delta$：\n$$ |\\mu_H - \\mu_E|  \\delta $$\n这可以写成两个不等式的合取：\n$$ -\\delta  \\mu_H - \\mu_E  \\delta $$\n在假设检验中，无法证明原假设。要证明一个主张，该主张必须是备择假设。因此，为了证明等价性，原假设必须陈述相反的情况：即程序是*不等价*的。$|\\mu_H - \\mu_E|  \\delta$ 的否定是 $|\\mu_H - \\mu_E| \\ge \\delta$。这可以分为两个不相交的区域：\n$$ (\\mu_H - \\mu_E \\ge \\delta) \\quad \\text{或} \\quad (\\mu_H - \\mu_E \\le -\\delta) $$\n这种结构导致了**两个单侧检验（TOST）**程序。我们为每个“不等价”区域制定一个原假设，并且必须同时拒绝这两个原假设才能得出等价的结论。\n\n**检验1（下界）：**\n- 原假设 $H_{0,L}: \\mu_H - \\mu_E \\le -\\delta$。\n- 备择假设 $H_{1,L}: \\mu_H - \\mu_E > -\\delta$。\n\n**检验2（上界）：**\n- 原假设 $H_{0,U}: \\mu_H - \\mu_E \\ge \\delta$。\n- 备择假设 $H_{1,U}: \\mu_H - \\mu_E  \\delta$。\n\n如果我们能在显著性水平 $\\alpha$ 下同时拒绝 $H_{0,L}$ 和 $H_{0,U}$，我们就为 $-\\delta  \\mu_H - \\mu_E  \\delta$ 这一主张提供了统计证据。\n\n为了执行这些检验，我们需要一个关于均值差 $\\mu_H - \\mu_E$ 的检验统计量。我们有两个独立的批次均值样本，样本大小分别为 $n_H$ 和 $n_E$，样本均值为 $\\bar{X}_H$ 和 $\\bar{X}_E$，批次均值的样本方差为 $s_H^2$ 和 $s_E^2$。由于批次均值的总体方差未知且不假定相等，因此适合的检验是 Welch's t-test。\n\n样本均值差的标准误是：\n$$ S = \\sqrt{\\frac{s_H^2}{n_H} + \\frac{s_E^2}{n_E}} $$\nt 统计量是在每个原假设的边界上构建的：\n- 对于 $H_{0,L}$，边界是 $\\mu_H - \\mu_E = -\\delta$。检验统计量是：\n$$ t_L = \\frac{(\\bar{X}_H - \\bar{X}_E) - (-\\delta)}{S} = \\frac{(\\bar{X}_H - \\bar{X}_E) + \\delta}{S} $$\n如果 $t_L > t_{\\alpha, \\nu}$，我们拒绝 $H_{0,L}$，其中 $\\nu$ 是自由度。\n\n- 对于 $H_{0,U}$，边界是 $\\mu_H - \\mu_E = \\delta$。检验统计量是：\n$$ t_U = \\frac{(\\bar{X}_H - \\bar{X}_E) - \\delta}{S} $$\n如果 $t_U  -t_{\\alpha, \\nu}$，我们拒绝 $H_{0,U}$。\n\n自由度 $\\nu$ 使用 Welch-Satterthwaite 方程来近似，这对于此检验是合适的。\n\n### 逐项分析\n\n**A. 将统计等价性定义为 $|\\mu_{H} - \\mu_{E}|  \\delta$。使用带有 Welch 标准误的两个单侧 t 检验（Two One-Sided Tests, TOST）进行检验。具体来说，令 $s_{H}^{2}$ 和 $s_{E}^{2}$ 分别为 $\\{\\bar{T}_{H,k}\\}$ 和 $\\{\\bar{T}_{E,\\ell}\\}$ 的样本方差，并定义标准误 $S = \\sqrt{\\frac{s_{H}^{2}}{n_{H}} + \\frac{s_{E}^{2}}{n_{E}}}$。执行两个检验：$H_{0,L}: \\mu_{H} - \\mu_{E} \\le -\\delta$ 对 $H_{1,L}: \\mu_{H} - \\mu_{E} > -\\delta$，使用 $t_{L} = \\frac{(\\bar{X}_{H} - \\bar{X}_{E}) + \\delta}{S}$；以及 $H_{0,U}: \\mu_{H} - \\mu_{E} \\ge \\delta$ 对 $H_{1,U}: \\mu_{H} - \\mu_{E}  \\delta$，使用 $t_{U} = \\frac{(\\bar{X}_{H} - \\bar{X}_{E}) - \\delta}{S}$。使用 Welch–Satterthwaite 自由度作为临界值，如果两个单侧检验都在水平 $\\alpha$ 下被拒绝，则声明等价。**\n\n这个选项完全符合推导出的正确程序。它正确地定义了等价性，正确地将 TOST 程序确定为合适的框架，正确地指定了原假设，正确地基于 Welch 标准误为方差不等的独立样本构建了检验统计量，并正确地陈述了决策规则。提及 Welch–Satterthwaite 自由度证实了使用了正确的基础检验。\n**结论：正确。**\n\n**B. 将统计等价性定义为每个事件贡献的完整分布相等，并使用 Kolmogorov–Smirnov (KS) 检验对来自两个程序的事件贡献的合并集合进行检验，采用相同的随机数流（共同随机数）以提高灵敏度。在水平 $\\alpha$ 下，未能拒绝分布相等意味着等价。**\n\n这个选项包含几个关键缺陷。\n1. 等价性的定义是“完整分布相等”，这比问题所要求的条件（在界限 $\\delta$ 内的平均通量等价）要严格得多。\n2. 它建议使用“共同随机数”，这直接与问题给出的条件“两个程序使用独立的随机数流”相矛盾。\n3. 其决策规则，“未能拒绝...意味着等价”，是假设检验中一个被称为“接受原假设”的基本逻辑谬误。缺乏差异的证据并不构成相等的证据。\n**结论：不正确。**\n\n**C. 将统计等价性定义为期望计数相等，即 $\\mu_{H} = \\mu_{E}$。使用双侧、合并方差的学生 t 检验来检验 $H_{0}: \\mu_{H} - \\mu_{E} = 0$ 对 $H_{1}: \\mu_{H} - \\mu_{E} \\ne 0$，显著性水平为 $\\alpha$，如果原假设未被拒绝，则判定为等价。**\n\n这个选项也因多个原因而存在缺陷。\n1. 它将等价性定义为点相等（$\\mu_{H} = \\mu_{E}$），忽略了指定的等价界限 $\\delta > 0$，该界限旨在用于实际等价而非精确相等。\n2. 它提出了一个传统的差异检验，其中原假设是没有差异。\n3. 与选项 B 类似，其结论“如果原假设未被拒绝则判定为等价”是接受原假设的逻辑谬误。\n4. 它建议使用“合并方差”t 检验，这做出了一个限制性且不合理的假设，即来自两个不同程序的批次均值的方差相等。Welch's t-test 更通用且更合适。\n**结论：不正确。**\n\n**D. 将统计等价性定义为 $|\\mu_{H} - \\mu_{E}| \\le \\delta$，并通过为 $\\mu_{H}$ 和 $\\mu_{E}$ 构建两个独立的 $(1-\\alpha)$ 双侧置信区间进行检验；如果区间重叠且其中点之差小于 $\\delta$，则声明等价。**\n\n这个选项提出了一个在统计上已知有缺陷的启发式方法。\n1. 使用置信区间比较两个均值的正确方法是为均值*之差* $\\mu_H - \\mu_E$ 构建单个置信区间。检查两个独立区间的重叠不具备正确的统计特性；具体来说，第一类错误率没有控制在 $\\alpha$ 水平。\n2. 所提议的决策规则是临时的。关于“中点之差”（即样本均值 $\\bar{X}_H - \\bar{X}_E$）的条件忽略了抽样变异性，而这种变异性是由标准误捕获的。一个正式的检验必须包含这种变异性。TOST 程序等价于检查均值差 $\\mu_H - \\mu_E$ 的 $(1-2\\alpha)$ 置信区间是否完全包含在等价区间 $(-\\delta, \\delta)$ 内，这才是正确的基于区间的方法。选项 D 的程序与此不等价。\n**结论：不正确。**\n\n唯一正确阐述了统计等价性问题并提出了有效、标准且稳健的统计检验的选项是 A。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}