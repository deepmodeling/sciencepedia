{
    "hands_on_practices": [
        {
            "introduction": "在耦合不同尺度求解器时，空间均匀化是一种必要的简化方法。本练习将引导您从第一性原理出发，推导体积加权的宏观截面，这是将复杂、非均匀的燃料棒晶胞表示为单一均匀材料以进行粗略计算的一项基本技术。通过这项实践，您将能深刻理解此方法背后的核心假设，例如中子通量扁平化假设，并认识其局限性 。",
            "id": "4219939",
            "problem": "一个来自压水堆栅格的单栅元将在中子学求解器和燃料性能程序（FPC）之间传递，以耦合更新材料状态和截面。考虑一个单群、稳态、无泄漏、轴对称的栅元，由四个同心区域组成：燃料、间隙、包壳和慢化剂，并在轴向无限延伸。FPC 提供了更新的热力学状态，中子学数据库已将其映射为区域平均的宏观吸收截面。您需要为此栅元定义空间均匀化，从第一性原理出发推导按体积加权的均匀化宏观吸收截面，然后利用所提供的数据计算其值。\n\n使用以下每单位高度的几何规格：燃料半径 $r_{f} = 0.41\\,\\mathrm{cm}$，包壳内径 $r_{ci} = 0.415\\,\\mathrm{cm}$，包壳外径 $r_{co} = 0.475\\,\\mathrm{cm}$，栅元边界半径 $R = 0.63\\,\\mathrm{cm}$。假设每个区域都是具有所述半径的正圆环（燃料为实心圆盘）。\n\n中子学数据库在接收此时间步下由 FPC 预测的温度和密度后，提供了以下区域平均的单群宏观吸收截面：燃料 $\\Sigma_{a}^{(f)} = 0.13\\,\\mathrm{cm^{-1}}$，间隙 $\\Sigma_{a}^{(g)} = 1.0 \\times 10^{-4}\\,\\mathrm{cm^{-1}}$，包壳 $\\Sigma_{a}^{(c)} = 0.007\\,\\mathrm{cm^{-1}}$，慢化剂 $\\Sigma_{a}^{(m)} = 0.020\\,\\mathrm{cm^{-1}}$。\n\n任务：\n1) 根据保持整个栅元某个积分量不变的原则，为此非均匀栅元定义空间均匀化。\n2) 仅从宏观吸收截面的定义和吸收反应率的体积分定义出发，并假设在整个非均匀区中标量通量是均匀的，推导出整个栅元的均匀化宏观吸收截面的表达式。\n3) 使用您推导的表达式，根据给定数据计算栅元的均匀化宏观吸收截面。最终结果以 $\\mathrm{cm^{-1}}$ 为单位，并四舍五入至四位有效数字。\n4) 简要说明在中子学-燃料性能耦合模拟中，当存在强烈的栅元内部通量和温度梯度时，您所推导的按体积加权的均匀化方法的主要局限性。\n\n最终答案只需报告第 3 部分的数值。所有其他部分应在您的解题思路中予以说明。",
            "solution": "该问题被认为是有效的，因为它基于核反应堆物理原理，提法得当，并包含获得唯一解所需的所有信息。这是反应堆分析中的一个标准（尽管简化了的）问题。\n\n解答的结构是为了回应问题陈述中提出的四个任务。\n\n任务 1) 定义空间均匀化。\n在反应堆物理学中，空间均匀化是将材料的非均匀排布（例如栅元中的燃料、间隙、包壳和慢化剂）替换为等效均匀介质的过程。“等效性”的概念是核心，其定义是保持某个特定的积分量不变。对于中子输运和扩散问题，这个量是栅元体积内特定类型（例如，吸收、裂变、散射）的总反应率。因此，虚拟均匀材料的均匀化截面的定义是：使用这些截面和均匀化介质中的通量计算出的总反应率，与在实际非均匀介质中的总反应率相同。\n\n任务 2) 推导按体积加权的均匀化宏观吸收截面。\n推导从反应率的基本定义开始。在位置 $\\vec{r}$ 处的吸收反应率密度由宏观吸收截面 $\\Sigma_a(\\vec{r})$ 和标量中子通量 $\\phi(\\vec{r})$ 的乘积给出。体积 $V$ 内的总吸收率 $A$ 是该密度在体积上的积分：\n$$ A = \\int_V \\Sigma_a(\\vec{r}) \\phi(\\vec{r}) dV $$\n对于非均匀栅元，总体积 $V_{cell}$ 是其组成区域体积的总和：燃料 ($f$)、间隙 ($g$)、包壳 ($c$) 和慢化剂 ($m$)。非均匀栅元中的总吸收率 $A_{het}$ 是每个区域中吸收率的总和。假设在每个区域 $i$（体积为 $V_i$，截面为 $\\Sigma_a^{(i)}$）内宏观截面是恒定的，则总吸收率为：\n$$ A_{het} = \\sum_{i \\in \\{f,g,c,m\\}} \\int_{V_i} \\Sigma_a^{(i)} \\phi(\\vec{r}) dV = \\sum_{i} \\Sigma_a^{(i)} \\int_{V_i} \\phi(\\vec{r}) dV $$\n对于等效的均匀栅元，其特征是单一的均匀化吸收截面 $\\bar{\\Sigma}_a$，在相同体积 $V_{cell}$ 上的总吸收率 $A_{hom}$ 为：\n$$ A_{hom} = \\int_{V_{cell}} \\bar{\\Sigma}_a \\phi_{hom}(\\vec{r}) dV = \\bar{\\Sigma}_a \\int_{V_{cell}} \\phi_{hom}(\\vec{r}) dV $$\n其中 $\\phi_{hom}(\\vec{r})$ 是均匀介质中的通量。\n\n均匀化原理要求 $A_{het} = A_{hom}$：\n$$ \\bar{\\Sigma}_a \\int_{V_{cell}} \\phi_{hom}(\\vec{r}) dV = \\sum_{i} \\Sigma_a^{(i)} \\int_{V_i} \\phi(\\vec{r}) dV $$\n问题明确指出，假设在整个非均匀区中标量通量是均匀的，即 $\\phi_0$。这意味着在非均匀栅元中，对于所有 $\\vec{r}$ 都有 $\\phi(\\vec{r}) = \\phi_0$，因此在等效均匀栅元中也有 $\\phi_{hom}(\\vec{r}) = \\phi_0$。将此假设代入方程可得：\n$$ \\bar{\\Sigma}_a \\int_{V_{cell}} \\phi_0 dV = \\sum_{i} \\Sigma_a^{(i)} \\int_{V_i} \\phi_0 dV $$\n由于 $\\phi_0$ 是一个非零常数，它可以从积分中提出并在等式两边消去：\n$$ \\bar{\\Sigma}_a \\int_{V_{cell}} dV = \\sum_{i} \\Sigma_a^{(i)} \\int_{V_i} dV $$\n积分仅代表相应区域的体积：\n$$ \\bar{\\Sigma}_a V_{cell} = \\sum_{i} \\Sigma_a^{(i)} V_i $$\n求解均匀化吸收截面 $\\bar{\\Sigma}_a$，我们得到按体积加权的平均值：\n$$ \\bar{\\Sigma}_a = \\frac{\\sum_{i} \\Sigma_a^{(i)} V_i}{V_{cell}} = \\frac{\\sum_{i} \\Sigma_a^{(i)} V_i}{\\sum_{i} V_i} $$\n这是在空间均匀中子通量假设下推导出的按体积加权的均匀化宏观吸收截面的表达式。\n\n任务 3) 计算均匀化宏观吸收截面。\n栅元被假设为无限长，因此我们可以使用每单位高度的面积来计算，这些面积与体积成正比。设 $A_i$ 为区域 $i$ 的横截面积。\n面积为：\n- 燃料：$A_f = \\pi r_f^2$\n- 间隙：$A_g = \\pi (r_{ci}^2 - r_f^2)$\n- 包壳：$A_c = \\pi (r_{co}^2 - r_{ci}^2)$\n- 慢化剂：$A_m = \\pi (R^2 - r_{co}^2)$\n- 总栅元：$A_{cell} = \\pi R^2$\n\n$\\bar{\\Sigma}_a$ 的公式可以用面积来表示：\n$$ \\bar{\\Sigma}_a = \\frac{\\Sigma_a^{(f)} A_f + \\Sigma_a^{(g)} A_g + \\Sigma_a^{(c)} A_c + \\Sigma_a^{(m)} A_m}{A_{cell}} $$\n因子 $\\pi$ 从分子和分母中消去：\n$$ \\bar{\\Sigma}_a = \\frac{\\Sigma_a^{(f)} r_f^2 + \\Sigma_a^{(g)} (r_{ci}^2 - r_f^2) + \\Sigma_a^{(c)} (r_{co}^2 - r_{ci}^2) + \\Sigma_a^{(m)} (R^2 - r_{co}^2)}{R^2} $$\n给定的半径是：$r_f = 0.41\\,\\mathrm{cm}$，$r_{ci} = 0.415\\,\\mathrm{cm}$，$r_{co} = 0.475\\,\\mathrm{cm}$，以及 $R = 0.63\\,\\mathrm{cm}$。它们的平方是：\n- $r_f^2 = (0.41)^2 = 0.1681\\,\\mathrm{cm}^2$\n- $r_{ci}^2 = (0.415)^2 = 0.172225\\,\\mathrm{cm}^2$\n- $r_{co}^2 = (0.475)^2 = 0.225625\\,\\mathrm{cm}^2$\n- $R^2 = (0.63)^2 = 0.3969\\,\\mathrm{cm}^2$\n\n面积项（除以 $\\pi$）为：\n- $A_f/\\pi = 0.1681\\,\\mathrm{cm}^2$\n- $A_g/\\pi = 0.172225 - 0.1681 = 0.004125\\,\\mathrm{cm}^2$\n- $A_c/\\pi = 0.225625 - 0.172225 = 0.0534\\,\\mathrm{cm}^2$\n- $A_m/\\pi = 0.3969 - 0.225625 = 0.171275\\,\\mathrm{cm}^2$\n\n给定的宏观吸收截面是：$\\Sigma_{a}^{(f)} = 0.13\\,\\mathrm{cm^{-1}}$，$\\Sigma_{a}^{(g)} = 1.0 \\times 10^{-4}\\,\\mathrm{cm^{-1}}$，$\\Sigma_{a}^{(c)} = 0.007\\,\\mathrm{cm^{-1}}$，以及 $\\Sigma_{a}^{(m)} = 0.020\\,\\mathrm{cm^{-1}}$。\n\n现在，我们计算 $\\bar{\\Sigma}_a$ 表达式的分子：\nNumerator $= (\\Sigma_a^{(f)} r_f^2 + \\dots) = (0.13)(0.1681) + (1.0 \\times 10^{-4})(0.004125) + (0.007)(0.0534) + (0.020)(0.171275)$\nNumerator $= 0.021853 + 0.0000004125 + 0.0003738 + 0.0034255 = 0.0256527125\\,\\mathrm{cm^{-1} \\cdot cm^2}$\n\n除以分母 $R^2 = 0.3969\\,\\mathrm{cm}^2$：\n$$ \\bar{\\Sigma}_a = \\frac{0.0256527125}{0.3969} \\approx 0.064632685\\,\\mathrm{cm^{-1}} $$\n将结果四舍五入到四位有效数字，我们得到：\n$$ \\bar{\\Sigma}_a \\approx 0.06463\\,\\mathrm{cm^{-1}} $$\n\n任务 4) 陈述按体积加权的均匀化方法的主要局限性。\n按体积加权的均匀化方法的推导关键地依赖于空间均匀中子通量的假设。这个假设在反应堆栅元中物理上是不准确的，并构成了该方法的主要局限性。\n1. **通量自屏效应**：燃料的吸收截面（$\\Sigma_a^{(f)} = 0.13\\,\\mathrm{cm^{-1}}$）远高于周围慢化剂的吸收截面（$\\Sigma_a^{(m)} = 0.020\\,\\mathrm{cm^{-1}}$）。这种巨大的差异导致燃料区内的中子通量产生强烈凹陷，这种效应被称为自屏效应。实际通量在慢化剂中最高，在燃料中心最低。按体积加权的方法假设通量是平坦的，从而不成比例地加权了高截面燃料区的贡献，导致对真实有效吸收率的高估，因此得到的均匀化截面值也就不正确地偏高。\n2. **忽略温度梯度**：在中子学-燃料性能耦合模拟的背景下，燃料表现出非常大的径向温度梯度，在中心线处达到峰值。宏观截面，特别是通过共振效应（多普勒展宽），是高度依赖于温度的。对整个燃料区使用单一的、区域平均的截面（如“中子学数据库”所提供的），是一个粗略的简化，忽略了由 FPC 计算出的详细温度分布。这个平均过程本身在进行均匀化步骤之前就已经引入了重大误差。\n\n一个物理上正确的均匀化方法必须使用实际的、随空间变化的通量分布 $\\phi(\\vec{r})$ 来保持反应率不变。这导致了通量加权，其中均匀化截面为 $\\bar{\\Sigma}_a = (\\sum_i \\Sigma_a^{(i)} \\bar{\\phi}_i V_i) / (\\sum_j \\bar{\\phi}_j V_j)$，其中 $\\bar{\\phi}_i$ 是区域 $i$ 中的平均通量。平坦通量假设只是一个一阶近似，对于精确的反应堆分析通常是不够的。",
            "answer": "$$\\boxed{0.06463}$$"
        },
        {
            "introduction": "中子学和燃料性能程序通常使用不同的计算网格，这为数据交换带来了挑战。本练习旨在解决一个关键的工程问题：如何在保证总能量严格守恒的前提下，将功率密度等数据从一个网格传递到另一个网格。您将通过推导并实现一个基于几何相交的守恒投影算法，来掌握这一核心耦合技术 。",
            "id": "4219857",
            "problem": "考虑在一个二维矩形域中，一个中子学求解器与一个燃料性能求解器之间的耦合。该域在平面外方向上的单位厚度为$1\\,\\text{m}$，因此平面中的面积在数值上等于以立方米为单位的体积。中子学求解器提供一个分段常数的体功率密度场 $p$（单位为 $\\text{W}/\\text{m}^3$），该场定义在一组划分了该域的轴对齐矩形单元网格上。燃料性能求解器使用另一组同样覆盖该域的轴对齐矩形有限元网格（不一定与中子学网格对齐）。目标是构建一个守恒投影算子，将单元上的常数 $p$ 映射为燃料性能单元上的单元平均功率密度 $p_f$，从而确保总功率 $\\int p\\,dV$ 在网格间完全守恒。\n\n仅从能量守恒、测度的可加性以及体积分的定义出发，推导一个数学上守恒的投影，将中子学网格单元上的分段常数功率密度映射到燃料网格上的单元平均值，并确保投影后的单元积分功率之和等于原始的总积分功率。然后，通过计算平面中矩形之间的几何相交面积，为轴对齐的矩形网格实现此投影。\n\n假设：\n- 中子学网格由不相交的轴对齐矩形 $C_i$ 组成，每个 $C_i$ 内具有恒定的 $p_i$（单位为 $\\text{W}/\\text{m}^3$）。\n- 燃料性能网格由轴对齐的矩形 $E_j$ 组成。\n- 域的厚度为 $1\\,\\text{m}$，因此矩形面积等于以 $\\text{m}^3$ 为单位的体积。\n- 不涉及角度；不需要角度单位。\n\n对于每个燃料单元 $E_j$，计算单元平均功率密度 $p_{f,j}$（单位为 $\\text{W}/\\text{m}^3$）和单元积分功率 $P_j$（单位为 $\\text{W}$）。该投影必须是守恒的，即燃料网格上的总积分功率 $\\sum_j P_j$ 等于中子学网格上的总积分功率 $\\sum_i p_i\\,|C_i|$，其中 $|\\,\\cdot\\,|$ 表示面积。\n\n您的程序必须为以下测试套件实现此投影，每个测试套件由一组带功率密度的中子学单元和一组燃料单元定义。矩形以四元组 $(x_{\\min}, x_{\\max}, y_{\\min}, y_{\\max})$（单位为米）的形式给出，功率密度以 $\\text{W}/\\text{m}^3$ 为单位给出。\n\n测试用例1（一般部分重叠）：\n- 中子学单元：\n  - $C_1 = (0,1,0,1)$，功率 $p_1 = 1.0\\times 10^8\\,\\text{W}/\\text{m}^3$\n  - $C_2 = (1,2,0,1)$，功率 $p_2 = 0.5\\times 10^8\\,\\text{W}/\\text{m}^3$\n- 燃料单元：\n  - $E_1 = (0,1.2,0,1)$\n  - $E_2 = (1.2,2,0,1)$\n\n测试用例2（完美对齐）：\n- 中子学单元：\n  - $C_1 = (0,1,0,1)$，功率 $p_1 = 0.8\\times 10^8\\,\\text{W}/\\text{m}^3$\n  - $C_2 = (1,2,0,1)$，功率 $p_2 = 0.8\\times 10^8\\,\\text{W}/\\text{m}^3$\n- 燃料单元：\n  - $E_1 = (0,1,0,1)$\n  - $E_2 = (1,2,0,1)$\n\n测试用例3（精细燃料网格穿过粗糙中子学网格）：\n- 中子学单元：\n  - $C_1 = (0,1,0,1)$，功率 $p_1 = 1.0\\times 10^8\\,\\text{W}/\\text{m}^3$\n  - $C_2 = (1,2,0,1)$，功率 $p_2 = 2.0\\times 10^8\\,\\text{W}/\\text{m}^3$\n  - $C_3 = (0,1,1,2)$，功率 $p_3 = 0.5\\times 10^8\\,\\text{W}/\\text{m}^3$\n  - $C_4 = (1,2,1,2)$，功率 $p_4 = 1.5\\times 10^8\\,\\text{W}/\\text{m}^3$\n- 燃料单元：\n  - $E_1 = (0,0.5,0,2)$\n  - $E_2 = (0.5,1.0,0,2)$\n  - $E_3 = (1.0,1.5,0,2)$\n  - $E_4 = (1.5,2.0,0,2)$\n\n测试用例4（微小条带和零功率区域）：\n- 中子学单元：\n  - $C_1 = (0,1,0,1)$，功率 $p_1 = 1.0\\times 10^9\\,\\text{W}/\\text{m}^3$\n  - $C_2 = (1,2,0,1)$，功率 $p_2 = 0.0\\,\\text{W}/\\text{m}^3$\n- 燃料单元：\n  - $E_1 = (0.99,1.01,0,1)$\n  - $E_2 = (0.0,0.99,0,1)$\n  - $E_3 = (1.01,2.0,0,1)$\n\n您的程序必须：\n- 推导并实现一个守恒投影，仅使用几何相交和给定的 $p_i$ 值来计算 $p_{f,j}$ 和 $P_j$。\n- 对于每个测试用例，使用推导出的投影计算中子学网格和燃料网格上的总积分功率，然后计算定义为这两个总功率之间绝对差的守恒误差（单位为 $\\text{W}$）。\n\n答案规格：\n- 对于每个测试用例，所需答案是一个 $float$ 类型的数值，等于以 $\\text{W}$ 为单位表示的守恒误差。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列结果：例如，对于四个测试用例，输出格式为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_k$ 是测试用例 $k$ 的守恒误差（单位为 $\\text{W}$）。\n- 每个守恒误差均以 $\\text{W}$ 表示；为便于显示，数值可四舍五入到 $10^{-12}\\,\\text{W}$ 的绝对容差。",
            "solution": "该问题要求推导并实现一个守恒投影算子，用于将分段常数功率密度场从中子学网格映射到燃料性能网格。推导必须基于第一性原理，即能量守恒和积分的性质。\n\n设域由 $\\Omega$ 表示。中子学网格由一组不相交的轴对齐矩形单元 $\\{C_i\\}$ 组成，这些单元构成 $\\Omega$ 的一个划分，即 $\\bigcup_i C_i = \\Omega$ 且当 $i \\neq k$ 时 $C_i \\cap C_k = \\emptyset$。功率密度场 $p(\\mathbf{x})$ 被定义为分段常数，对于任何位置向量 $\\mathbf{x} \\in C_i$，有 $p(\\mathbf{x}) = p_i$，其中 $p_i$ 是一个以 $\\text{W}/\\text{m}^3$ 为单位的常数值。\n\n在整个域中生成的总功率 $P_{\\text{total,N}}$ 由功率密度场在 $\\Omega$ 上的体积分给出。由于单位厚度为 $1\\,\\text{m}$，体积分在数值上等同于面积分。设 $|S|$ 表示区域 $S$ 的面积。中子学网格上的总功率为：\n$$ P_{\\text{total,N}} = \\int_{\\Omega} p(\\mathbf{x}) \\,dV $$\n根据测度的可加性，由于单元 $C_i$ 划分了该域，此积分可表示为在每个单元上的积分之和：\n$$ P_{\\text{total,N}} = \\sum_i \\int_{C_i} p(\\mathbf{x}) \\,dV $$\n由于在每个单元 $C_i$ 内，$p(\\mathbf{x})$ 是常数（$p_i$），我们可以写出：\n$$ P_{\\text{total,N}} = \\sum_i p_i \\int_{C_i} \\,dV = \\sum_i p_i |C_i| $$\n此处， $|C_i|$ 代表单元 $C_i$ 的体积，数值上等于其面积。\n\n燃料性能网格也由一组划分同一域 $\\Omega$ 的轴对齐矩形单元 $\\{E_j\\}$ 组成。我们的目标是为每个燃料单元 $E_j$ 定义一个积分功率 $P_j$ 和一个单元平均功率密度 $p_{f,j}$。\n\n能量守恒的基本原理规定，在燃料单元 $E_j$ 体积内产生的功率是原始功率密度场 $p(\\mathbf{x})$ 在该单元域上的积分。因此，单元 $E_j$ 中的积分功率 $P_j$ 是：\n$$ P_j = \\int_{E_j} p(\\mathbf{x}) \\,dV $$\n为计算此积分，我们可以再次使用可加性。积分域 $E_j$ 可由其与中子学单元 $\\{C_i\\}$ 的交集来划分。设 $I_{ij} = C_i \\cap E_j$ 为中子学单元 $C_i$ 和燃料单元 $E_j$ 的相交区域。这些不相交的交集的并集覆盖了燃料单元，即 $\\bigcup_i I_{ij} = E_j$。$P_j$ 的积分可以重写为：\n$$ P_j = \\sum_i \\int_{I_{ij}} p(\\mathbf{x}) \\,dV $$\n在每个相交区域 $I_{ij}$（它是 $C_i$ 的子集）内，功率密度是恒定的，等于 $p_i$。因此，积分简化为：\n$$ P_j = \\sum_i p_i \\int_{I_{ij}} \\,dV = \\sum_i p_i |C_i \\cap E_j| $$\n此公式给出了每个燃料单元 $E_j$ 内的总功率。它是中子学功率密度的加权和，其中权重是中子学单元与给定燃料单元之间的相交面积。\n\n燃料单元 $E_j$ 的单元平均功率密度 $p_{f,j}$ 定义为该单元中的总功率除以其体积：\n$$ p_{f,j} = \\frac{P_j}{|E_j|} = \\frac{1}{|E_j|} \\sum_i p_i |C_i \\cap E_j| $$\n这就构成了推导出的守恒投影算子。\n\n为验证此投影确实是守恒的，我们必须证明在燃料网格上求和的总功率 $P_{\\text{total,F}} = \\sum_j P_j$ 等于在中子学网格上的总功率 $P_{\\text{total,N}}$。\n$$ P_{\\text{total,F}} = \\sum_j P_j = \\sum_j \\left( \\sum_i p_i |C_i \\cap E_j| \\right) $$\n通过交换求和顺序（对于有限和是允许的），我们得到：\n$$ P_{\\text{total,F}} = \\sum_i p_i \\left( \\sum_j |C_i \\cap E_j| \\right) $$\n由于燃料单元 $\\{E_j\\}$ 也构成了域 $\\Omega$ 的一个划分，它们与任何给定中子学单元 $C_i$ 的相交面积之和必须等于该单元的总面积：$\\sum_j |C_i \\cap E_j| = |C_i|$。将此代入方程，得到：\n$$ P_{\\text{total,F}} = \\sum_i p_i |C_i| = P_{\\text{total,N}} $$\n这证实了所推导的投影在数学上是精确的，并保证了总功率的守恒，其限制仅在于实现中的浮点算术精度。\n\n此投影的实现需要一种方法来计算两个轴对齐矩形的相交面积。设矩形 $R_1$ 由 $(x_{1,\\min}, x_{1,\\max}, y_{1,\\min}, y_{1,\\max})$ 定义，矩形 $R_2$ 由 $(x_{2,\\min}, x_{2,\\max}, y_{2,\\min}, y_{2,\\max})$ 定义。如果它们的交集存在，它也是一个轴对齐的矩形 $R_{\\text{int}}$，其边界由以下公式给出：\n$x_{\\text{int},\\min} = \\max(x_{1,\\min}, x_{2,\\min})$\n$x_{\\text{int},\\max} = \\min(x_{1,\\max}, x_{2,\\max})$\n$y_{\\text{int},\\min} = \\max(y_{1,\\min}, y_{2,\\min})$\n$y_{\\text{int},\\max} = \\min(y_{1,\\max}, y_{2,\\max})$\n交集的宽度是 $w_{\\text{int}} = x_{\\text{int},\\max} - x_{\\text{int},\\min}$，高度是 $h_{\\text{int}} = y_{\\text{int},\\max} - y_{\\text{int},\\min}$。只有当 $w_{\\text{int}} > 0$ 和 $h_{\\text{int}} > 0$ 都成立时，相交面积才非零。因此，面积为：\n$$ |R_1 \\cap R_2| = \\max(0, w_{\\text{int}}) \\times \\max(0, h_{\\text{int}}) $$\n每个测试用例的总体算法如下：\n1.  通过对所有中子学单元求和 $p_i |C_i|$，计算中子学网格上的总功率 $P_{\\text{total,N}}$。\n2.  将燃料网格上的总功率 $P_{\\text{total,F}}$ 初始化为 $0$。\n3.  对于每个燃料单元 $E_j$：\n    a. 通过对所有中子学单元的贡献求和来计算积分功率 $P_j$：$P_j = \\sum_i p_i |C_i \\cap E_j|$。相交面积 $|C_i \\cap E_j|$ 使用上面的几何公式计算。\n    b. 将计算出的 $P_j$ 加到 $P_{\\text{total,F}}$ 上。\n4.  守恒误差是绝对差 $|P_{\\text{total,F}} - P_{\\text{total,N}}|$。\n使用标准浮点算术实现的此过程将得出所需的守恒误差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a conservative projection for power density\n    between two misaligned rectangular meshes, and calculates the\n    conservation error for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (general partial overlaps)\n        {\n            \"neutronics_cells\": [\n                (1.0e8, (0, 1, 0, 1)),  # p1, C1\n                (0.5e8, (1, 2, 0, 1)),  # p2, C2\n            ],\n            \"fuel_elements\": [\n                (0, 1.2, 0, 1),        # E1\n                (1.2, 2, 0, 1),        # E2\n            ]\n        },\n        # Test Case 2 (perfect alignment)\n        {\n            \"neutronics_cells\": [\n                (0.8e8, (0, 1, 0, 1)),  # p1, C1\n                (0.8e8, (1, 2, 0, 1)),  # p2, C2\n            ],\n            \"fuel_elements\": [\n                (0, 1, 0, 1),          # E1\n                (1, 2, 0, 1),          # E2\n            ]\n        },\n        # Test Case 3 (fine fuel mesh crossing a coarse neutronics mesh)\n        {\n            \"neutronics_cells\": [\n                (1.0e8, (0, 1, 0, 1)),  # p1, C1\n                (2.0e8, (1, 2, 0, 1)),  # p2, C2\n                (0.5e8, (0, 1, 1, 2)),  # p3, C3\n                (1.5e8, (1, 2, 1, 2)),  # p4, C4\n            ],\n            \"fuel_elements\": [\n                (0, 0.5, 0, 2),        # E1\n                (0.5, 1.0, 0, 2),      # E2\n                (1.0, 1.5, 0, 2),      # E3\n                (1.5, 2.0, 0, 2),      # E4\n            ]\n        },\n        # Test Case 4 (tiny sliver and zero-power region)\n        {\n            \"neutronics_cells\": [\n                (1.0e9, (0, 1, 0, 1)),  # p1, C1\n                (0.0,   (1, 2, 0, 1)),  # p2, C2\n            ],\n            \"fuel_elements\": [\n                (0.99, 1.01, 0, 1),    # E1\n                (0.0, 0.99, 0, 1),     # E2\n                (1.01, 2.0, 0, 1),     # E3\n            ]\n        }\n    ]\n\n    def intersect_area(rect1, rect2):\n        \"\"\"\n        Calculates the intersection area of two axis-aligned rectangles.\n        A rectangle is a tuple (xmin, xmax, ymin, ymax).\n        \"\"\"\n        x_min1, x_max1, y_min1, y_max1 = rect1\n        x_min2, x_max2, y_min2, y_max2 = rect2\n\n        x_overlap = max(0.0, min(x_max1, x_max2) - max(x_min1, x_min2))\n        y_overlap = max(0.0, min(y_max1, y_max2) - max(y_min1, y_min2))\n        \n        return x_overlap * y_overlap\n\n    results = []\n    for case in test_cases:\n        neutronics_cells = case[\"neutronics_cells\"]\n        fuel_elements = case[\"fuel_elements\"]\n\n        # 1. Calculate total power on the neutronics mesh\n        total_power_neutronics = 0.0\n        for p_i, C_i in neutronics_cells:\n            # Area is numerically equal to volume due to unit thickness\n            area_C_i = (C_i[1] - C_i[0]) * (C_i[3] - C_i[2])\n            total_power_neutronics += p_i * area_C_i\n\n        # 2. Calculate total power on the fuel mesh via projection\n        total_power_fuel = 0.0\n        for E_j in fuel_elements:\n            # Calculate integrated power P_j for fuel element E_j\n            power_P_j = 0.0\n            for p_i, C_i in neutronics_cells:\n                area_ij = intersect_area(C_i, E_j)\n                power_P_j += p_i * area_ij\n            \n            total_power_fuel += power_P_j\n\n        # 3. Compute the conservation error\n        conservation_error = abs(total_power_fuel - total_power_neutronics)\n        results.append(conservation_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了如何均匀化和映射数据之后，理解这些简化所带来的影响至关重要。本练习通过对比高保真度的棒内解析耦合与简化的组件均匀化方法，让您量化由此产生的峰值燃料温度预测误差——这是一个关键的安全参数。这项练习突出了在耦合模拟中，计算效率与准确性之间的重要权衡 。",
            "id": "4219856",
            "problem": "您的任务是为一个圆柱形燃料棒构建一个简化但科学严谨的中子学与燃料性能之间的耦合，并比较两种映射策略：棒内核功率映射与组件均匀化耦合。\n\n从第一性原理出发，推导并实现预测稳态条件下峰值中心线温度所需的温度模型，然后量化在使用组件均匀化耦合替代棒内核功率映射时，峰值温度预测产生的误差。\n\n使用以下基本原理：\n\n- 傅里叶热传导定律：$q_r = -k \\, \\frac{dT}{dr}$。\n- 在半径为 $R$ 的圆柱体中，均匀体积热生成下的稳态能量守恒：$$\\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{dT}{dr}\\right) + \\frac{q''' }{k} = 0.$$\n- 与线热率相关的均匀体积热生成：$$q''' = \\frac{q'}{\\pi R^2}, \\quad \\text{with} \\quad q' = \\frac{P}{L},$$ 其中 $P$ 是棒功率，$L$ 是燃料的活性区长度。\n\n在稳态条件下，并假设燃料芯块（$r_f$）、气隙（$r_g$）和包壳（从 $r_{c,\\text{in}}$ 到 $r_{c,\\text{out}}$）是同心圆柱体，且外部与温度为 $T_{\\infty}$、传热系数为 $h$ 的冷却剂进行对流换热，中心线温度 $T(0)$ 可通过一个热阻网络表示：\n- 因体积生热导致的燃料内部温升：$$\\Delta T_{\\text{fuel}} = \\frac{q'}{4 \\pi k_f}.$$\n- 气隙导热线热阻：$$R_{\\text{gap}} = \\frac{\\ln\\left(\\frac{r_g}{r_f}\\right)}{2 \\pi k_g}.$$\n- 包壳导热线热阻：$$R_{\\text{clad}} = \\frac{\\ln\\left(\\frac{r_{c,\\text{out}}}{r_{c,\\text{in}}}\\right)}{2 \\pi k_c}.$$\n- 外部对流线热阻：$$R_{\\text{conv}} = \\frac{1}{2 \\pi r_{c,\\text{out}} h}.$$\n\n对于给定的线热率为 $q'$ 的燃料棒，其中心线温度为：\n$$T(0) = T_{\\infty} + q' \\left( R_{\\text{conv}} + R_{\\text{clad}} + R_{\\text{gap}} \\right) + \\frac{q'}{4 \\pi k_f}.$$\n\n定义两种耦合策略：\n1. 棒内核功率映射：使用每根燃料棒的实际功率 $P_i$ 计算其线热率 $q'_i = \\frac{P_i}{L}$ 及其中心线温度 $T_i(0)$，然后确定峰值温度 $T_{\\text{peak,true}} = \\max_i T_i(0)$。\n2. 组件均匀化耦合：对于 $N$ 根燃料棒，计算组件平均功率 $\\bar{P} = \\frac{1}{N}\\sum_{i=1}^{N} P_i$，将 $\\bar{P}$ 赋给每根燃料棒，计算相应的均匀中心线温度 $T_{\\text{avg}}(0)$，并取 $T_{\\text{peak,homo}} = T_{\\text{avg}}(0)$。\n\n对于下面的每个测试用例，按如下方式量化峰值温度预测的绝对误差：\n$$E = \\left| T_{\\text{peak,homo}} - T_{\\text{peak,true}} \\right|.$$\n\n所有计算必须使用指定的物理常数和单位。最终误差值以开尔文（$\\text{K}$）为单位表示，并四舍五入到三位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[E_1,E_2,E_3,E_4]$）。\n\n所有用例使用以下通用几何和材料属性：\n- 燃料半径：$r_f = 4.10 \\times 10^{-3} \\ \\text{m}$。\n- 气隙外半径：$r_g = 4.185 \\times 10^{-3} \\ \\text{m}$。\n- 包壳内半径：$r_{c,\\text{in}} = 4.185 \\times 10^{-3} \\ \\text{m}$。\n- 包壳外半径：$r_{c,\\text{out}} = 4.785 \\times 10^{-3} \\ \\text{m}$。\n- 燃料热导率：$k_f = 3.0 \\ \\text{W} \\, \\text{m}^{-1} \\, \\text{K}^{-1}$。\n- 气隙（氦气）热导率：$k_g = 0.3 \\ \\text{W} \\, \\text{m}^{-1} \\, \\text{K}^{-1}$。\n- 包壳（锆合金）热导率：$k_c = 16.0 \\ \\text{W} \\, \\text{m}^{-1} \\, \\text{K}^{-1}$。\n- 活性燃料长度：$L = 3.7 \\ \\text{m}$。\n- 冷却剂温度：$T_{\\infty} = 580.0 \\ \\text{K}$。\n\n测试套件：\n- 用例 $1$（正常路径）：$3 \\times 3$ 棒功率（单位：瓦），\n$$\\begin{bmatrix}\n12000  10000  9000 \\\\\n8000  15000  8000 \\\\\n7000  10000  9000\n\\end{bmatrix}, \\quad h = 1.20 \\times 10^{4} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n- 用例 $2$（均匀边界用例）：$3 \\times 3$ 棒功率（单位：瓦），\n$$\\begin{bmatrix}\n10000  10000  10000 \\\\\n10000  10000  10000 \\\\\n10000  10000  10000\n\\end{bmatrix}, \\quad h = 1.20 \\times 10^{4} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n- 用例 $3$（极端峰值边界用例）：$3 \\times 3$ 棒功率（单位：瓦），\n$$\\begin{bmatrix}\n5000  5000  5000 \\\\\n5000  25000  5000 \\\\\n5000  5000  5000\n\\end{bmatrix}, \\quad h = 1.20 \\times 10^{4} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n- 用例 $4$（低冷却边界用例）：棒功率与用例 $1$ 相同，但\n$$h = 5.00 \\times 10^{3} \\ \\text{W} \\, \\text{m}^{-2} \\, \\text{K}^{-1}.$$\n\n要求的最终输出格式：\n- 您的程序必须计算测试套件中每个用例的 $E$，并打印一行包含 $[E_1,E_2,E_3,E_4]$ 格式的列表，其中每个 $E_i$ 四舍五入到三位小数，并以开尔文（$\\text{K}$）为单位表示。",
            "solution": "中子学与燃料性能程序之间的耦合问题是高保真核反应堆模拟的核心。该任务要求通过量化一种计算成本较低但精度也较低的均匀化方法所引入的误差，来对兩種常見的耦合策略進行批判性評估。该分析建立在传热学的第一性原理之上。\n\n物理模型是一个处于稳态条件下的圆柱形燃料棒。燃料芯块内部（从半径 $r=0$ 到 $r=r_f$）温度分布 $T(r)$ 的控制方程是带有均匀体积热源 $q'''$ 的热传导方程：\n$$\n\\frac{1}{r}\\frac{d}{dr}\\left(r k_f \\frac{dT}{dr}\\right) + q''' = 0\n$$\n假设燃料热导率 $k_f$ 为常数，该方程可写为：\n$$\n\\frac{1}{r}\\frac{d}{dr}\\left(r \\frac{dT}{dr}\\right) + \\frac{q'''}{k_f} = 0\n$$\n体积热生成率 $q'''$ 与燃料棒的线热率 $q'$（单位长度的功率，$P/L$）通过 $q''' = \\frac{q'}{\\pi r_f^2}$ 相关联。在中心线对称（$\\frac{dT}{dr}|_{r=0} = 0$）和燃料表面温度已知 $T(r_f)$ 的边界条件下，对热方程进行两次积分，可得到整个燃料芯块的温降：\n$$\n\\Delta T_{\\text{fuel}} = T(0) - T(r_f) = \\frac{q''' r_f^2}{4k_f} = \\frac{(q'/\\pi r_f^2) r_f^2}{4k_f} = \\frac{q'}{4 \\pi k_f}\n$$\n该项表示产热介质内部的温升。\n\n系统的其余部分由被动层组成，热量通过这些层传导和对流散失。这些层使用热阻网络进行建模。单位长度的总热流率 $q'$ 在气隙、包壳和对流边界层中保持恒定。这些层上的温降为：\n1.  **气隙**：建模为通过从 $r_f$到 $r_g$ 的圆柱壳体的热传导。温降为 $\\Delta T_{\\text{gap}} = q' R_{\\text{gap}}$，其中线热阻为 $R_{\\text{gap}} = \\frac{\\ln(r_g/r_f)}{2 \\pi k_g}$。\n2.  **包壳**：建模为通过从 $r_{c,\\text{in}}$ 到 $r_{c,\\text{out}}$ 的圆柱壳体的热传导。温降为 $\\Delta T_{\\text{clad}} = q' R_{\\text{clad}}$，其热阻为 $R_{\\text{clad}} = \\frac{\\ln(r_{c,\\text{out}}/r_{c,\\text{in}})}{2 \\pi k_c}$。\n3.  **冷却剂对流**：根据牛顿冷却定律在包壳外表面建模。温降为 $\\Delta T_{\\text{conv}} = q' R_{\\text{conv}}$，其热阻为 $R_{\\text{conv}} = \\frac{1}{2 \\pi r_{c,\\text{out}} h}$。\n\n中心线温度 $T(0)$ 是冷却剂主流温度 $T_{\\infty}$ 与所有顺序温降的总和：\n$$\nT(0) = T_{\\infty} + \\Delta T_{\\text{conv}} + \\Delta T_{\\text{clad}} + \\Delta T_{\\text{gap}} + \\Delta T_{\\text{fuel}}\n$$\n代入每一项的表达式，得到所提供的公式：\n$$\nT(0) = T_{\\infty} + q' \\left( R_{\\text{conv}} + R_{\\text{clad}} + R_{\\text{gap}} \\right) + \\frac{q'}{4 \\pi k_f}\n$$\n该方程可以简化为 $T(0)$ 和 $q'$ 之间的线性关系：\n$$\nT(0) = T_{\\infty} + q' \\left( \\frac{1}{2 \\pi r_{c,\\text{out}} h} + \\frac{\\ln(r_{c,\\text{out}}/r_{c,\\text{in}})}{2 \\pi k_c} + \\frac{\\ln(r_g/r_f)}{2 \\pi k_g} + \\frac{1}{4 \\pi k_f} \\right)\n$$\n令括号中的项为总热系数 $A(h)$。那么，$T(0) = T_{\\infty} + A(h) \\cdot q'$。由于温度是线热率 $q'$ 的线性函数，峰值温度将始终对应于具有最大线热率 $q'_{\\text{max}}$ 的燃料棒。\n\n两种耦合策略的评估如下：\n1.  **棒内核功率映射**：在该模型的假设范围内，这是一种物理上正确的方法。每根燃料棒 $i$ 的功率 $P_i$ 用于计算其特定的线热率 $q'_i = P_i/L$。计算所有燃料棒的温度 $T_i(0)$，真正的峰值温度是它们中的最大值：$T_{\\text{peak,true}} = \\max_i(T_i(0))$。这对应于具有最大功率 $P_{\\text{max}}$，因此也具有最大线热率 $q'_{\\text{max}}$ 的燃料棒。\n    $$ T_{\\text{peak,true}} = T_{\\infty} + A(h) \\cdot q'_{\\text{max}} = T_{\\infty} + A(h) \\cdot \\frac{P_{\\text{max}}}{L} $$\n2.  **组件均匀化耦合**：这是一种忽略了详细棒功率分布的近似方法。计算组件平均功率 $\\bar{P} = \\frac{1}{N}\\sum_{i=1}^{N} P_i$，并将其分配给每根燃料棒。这导致了单一、均匀的线热率 $\\bar{q}' = \\bar{P}/L$ 和单一的温度值 $T_{\\text{avg}}(0)$，该值被视为峰值温度：$T_{\\text{peak,homo}} = T_{\\text{avg}}(0)$。\n    $$ T_{\\text{peak,homo}} = T_{\\infty} + A(h) \\cdot \\bar{q}' = T_{\\infty} + A(h) \\cdot \\frac{\\bar{P}}{L} $$\n\n误差 $E = \\left| T_{\\text{peak,homo}} - T_{\\text{peak,true}} \\right|$ 量化了这种差异。代入上述表达式：\n$$\nE = \\left| \\left(T_{\\infty} + A(h) \\cdot \\frac{\\bar{P}}{L}\\right) - \\left(T_{\\infty} + A(h) \\cdot \\frac{P_{\\text{max}}}{L}\\right) \\right| = \\frac{A(h)}{L} | \\bar{P} - P_{\\text{max}} |\n$$\n由于 $\\bar{P} \\le P_{\\text{max}}$，误差简化为 $E = \\frac{A(h)}{L} (P_{\\text{max}} - \\bar{P})$。这表明，当功率存在变化时，均匀化方案总是低估峰值温度，这对于安全分析而言是一个非保守的结果。该误差的大小与峰值棒功率和平均棒功率之间的差异成正比。\n\n计算过程是首先为每个测试用例计算系数 $A(h)$ 的分量。然后，对于每个用例的功率分布，确定 $P_{\\text{max}}$ 和 $\\bar{P}$，最后使用推导出的公式计算误差 $E$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the error in peak fuel centerline temperature prediction\n    when using assembly-homogenized coupling versus pin-resolved mapping.\n    \"\"\"\n\n    # Common physical constants and geometry\n    r_f = 4.10e-3  # Fuel radius, m\n    r_g = 4.185e-3 # Gap outer radius, m\n    r_c_in = 4.185e-3 # Cladding inner radius, m\n    r_c_out = 4.785e-3 # Cladding outer radius, m\n    k_f = 3.0     # Fuel thermal conductivity, W/m-K\n    k_g = 0.3     # Gap thermal conductivity, W/m-K\n    k_c = 16.0    # Cladding thermal conductivity, W/m-K\n    L = 3.7       # Active fuel length, m\n    T_inf = 580.0   # Coolant temperature, K\n\n    # Test cases: (pin_powers in W, h in W/m^2-K)\n    test_cases = [\n        (np.array([\n            [12000, 10000, 9000],\n            [8000, 15000, 8000],\n            [7000, 10000, 9000]\n        ]), 1.20e4),\n        (np.array([\n            [10000, 10000, 10000],\n            [10000, 10000, 10000],\n            [10000, 10000, 10000]\n        ]), 1.20e4),\n        (np.array([\n            [5000, 5000, 5000],\n            [5000, 25000, 5000],\n            [5000, 5000, 5000]\n        ]), 1.20e4),\n        (np.array([\n            [12000, 10000, 9000],\n            [8000, 15000, 8000],\n            [7000, 10000, 9000]\n        ]), 5.00e3)\n    ]\n\n    results = []\n\n    # Pre-calculate constant thermal resistance terms\n    R_gap = np.log(r_g / r_f) / (2 * np.pi * k_g)\n    R_clad = np.log(r_c_out / r_c_in) / (2 * np.pi * k_c)\n    fuel_term = 1 / (4 * np.pi * k_f)\n    \n    def calculate_centerline_temp(q_prime, h):\n        \"\"\"\n        Calculates centerline temperature for a given linear heat rate and h.\n        \n        Args:\n            q_prime (float): Linear heat rate (W/m).\n            h (float): Convective heat transfer coefficient (W/m^2-K).\n\n        Returns:\n            float: Centerline temperature (K).\n        \"\"\"\n        R_conv = 1 / (2 * np.pi * r_c_out * h)\n        temp_rise = q_prime * (R_conv + R_clad + R_gap + fuel_term)\n        return T_inf + temp_rise\n\n    for pin_powers, h in test_cases:\n        # 1. Pin-resolved mapping (true peak temperature)\n        P_max = pin_powers.max()\n        q_prime_max = P_max / L\n        T_peak_true = calculate_centerline_temp(q_prime_max, h)\n\n        # 2. Assembly-homogenized coupling\n        P_avg = pin_powers.mean()\n        q_prime_avg = P_avg / L\n        T_peak_homo = calculate_centerline_temp(q_prime_avg, h)\n\n        # 3. Quantify the error\n        error = abs(T_peak_homo - T_peak_true)\n        results.append(error)\n\n    # Format results for final output\n    formatted_results = [f'{res:.3f}' for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}