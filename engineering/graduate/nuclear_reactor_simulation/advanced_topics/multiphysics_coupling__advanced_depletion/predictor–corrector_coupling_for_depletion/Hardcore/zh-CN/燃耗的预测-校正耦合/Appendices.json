{
    "hands_on_practices": [
        {
            "introduction": "在将任何数值方法应用于复杂问题之前，通过一个具有已知解析解的简单问题来验证其实现是至关重要的一步。本实践练习将指导你如何进行收敛率研究，以验证我们实现的预测-校正积分器是否达到了其理论上的二阶精度。这个过程不仅能确认代码的正确性，还能加深对数值误差如何随步长变化的理解。",
            "id": "4241745",
            "problem": "考虑一个在恒定中子通量下的核反应堆模拟中的线性三核素损耗链。该链定义为核素 $1$ 衰变到核素 $2$，核素 $2$ 衰变到核素 $3$，核素 $3$ 衰变并移出该链。每种核素还会发生中子吸收，这会将其从链中移除，但不会产生链中的其他核素。其控制常微分方程 (ODEs) 为\n$$\n\\frac{d \\mathbf{n}(t)}{dt} = \\mathbf{A} \\, \\mathbf{n}(t),\n$$\n其中 $\\mathbf{n}(t) = [n_1(t), n_2(t), n_3(t)]^\\top$ 是数密度（无量纲的数分数），系数矩阵 $\\mathbf{A}$ 为\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n-(\\lambda_1 + \\sigma_1 \\, \\phi) & 0 & 0 \\\\\n\\lambda_1 & -(\\lambda_2 + \\sigma_2 \\, \\phi) & 0 \\\\\n0 & \\lambda_2 & -(\\lambda_3 + \\sigma_3 \\, \\phi)\n\\end{bmatrix}.\n$$\n此处，$\\lambda_i$ 是衰变常数，单位为 $\\mathrm{s}^{-1}$；$\\sigma_i$ 是吸收截面，单位为 $\\mathrm{cm}^2$；$\\phi$ 是标量中子通量，单位为 $\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。有效移除常数是 $\\alpha_i = \\lambda_i + \\sigma_i \\, \\phi$，单位为 $\\mathrm{s}^{-1}$。该链是线性时不变的，对于不同的 $\\alpha_i$，其已知的解析解可由 Bateman 方程推导得出。\n\n你的任务是：\n- 为该常微分方程实现一个预估-校正积分器（显式梯形法则，也称为二阶 Heun 方法）。该积分器带有耦合，使用步初系数来预估步末数密度，然后使用步末系数进行校正。在这种线性常系数设定下，该方法简化为求解 $\\mathbf{n}' = \\mathbf{A}\\mathbf{n}$ 的经典显式梯形法。\n- 使用 Bateman 公式为具有不同 $\\alpha_i$ 的线性链实现解析解（假设没有简并情况）。\n- 定义一个验证测试，通过计算在最终时间 $T$ 处、使用连续细化的步长所产生的数值误差，来测量预估-校正方法的观测收敛率，并通过关系式 $E(h) \\approx C h^p$ 估计阶数 $p$，因此有\n$$\np \\approx \\frac{\\log(E(h_1)) - \\log(E(h_2))}{\\log(h_1) - \\log(h_2)},\n$$\n其中 $h_2 = h_1 / 2$。使用在时间 $T$ 的最终数密度误差向量的欧几里得范数作为 $E(h)$。\n\n所有物理量必须使用以下单位：\n- 时间单位为 $\\mathrm{s}$。\n- 衰变常数单位为 $\\mathrm{s}^{-1}$。\n- 吸收截面单位为 $\\mathrm{cm}^2$。\n- 通量单位为 $\\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n- 数密度为无量纲的数分数。\n\n实现一个程序，对于每个测试用例，该程序使用预估-校正方法和三个步数 $N_1$、$N_2$ 和 $N_3$（其中 $N_2 = 2N_1$ 且 $N_3 = 2N_2$）计算在 $T$ 时的数值解；计算相应的误差 $E(h_1)$、$E(h_2)$、$E(h_3)$；并通过对以下两组成对的估计值取平均来返回测得的收敛率：\n$$\np_{12} = \\frac{\\log(E(h_1)) - \\log(E(h_2))}{\\log(h_1) - \\log(h_2)}, \\quad\np_{23} = \\frac{\\log(E(h_2)) - \\log(E(h_3))}{\\log(h_2) - \\log(h_3)}, \\quad\np = \\frac{p_{12} + p_{23}}{2}.\n$$\n\n使用以下测试套件：\n\n- 测试用例 1 (纯衰变链，中等速率)：\n  - $\\lambda_1 = 0.1 \\ \\mathrm{s}^{-1}$，$\\lambda_2 = 0.05 \\ \\mathrm{s}^{-1}$，$\\lambda_3 = 0.0 \\ \\mathrm{s}^{-1}$。\n  - $\\sigma_1 = 0.0 \\ \\mathrm{cm}^2$，$\\sigma_2 = 0.0 \\ \\mathrm{cm}^2$，$\\sigma_3 = 0.0 \\ \\mathrm{cm}^2$。\n  - $\\phi = 0.0 \\ \\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 初始条件 $\\mathbf{n}(0) = [1.0, 0.0, 0.0]^\\top$。\n  - 最终时间 $T = 5.0 \\ \\mathrm{s}$。\n  - 步数 $(N_1, N_2, N_3) = (50, 100, 200)$。\n\n- 测试用例 2 (衰变加吸收，不同的初始组分)：\n  - $\\lambda_1 = 0.05 \\ \\mathrm{s}^{-1}$，$\\lambda_2 = 0.02 \\ \\mathrm{s}^{-1}$，$\\lambda_3 = 0.01 \\ \\mathrm{s}^{-1}$。\n  - $\\sigma_1 = 3 \\times 10^{-24} \\ \\mathrm{cm}^2$，$\\sigma_2 = 4 \\times 10^{-24} \\ \\mathrm{cm}^2$，$\\sigma_3 = 2 \\times 10^{-24} \\ \\mathrm{cm}^2$。\n  - $\\phi = 1 \\times 10^{14} \\ \\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 初始条件 $\\mathbf{n}(0) = [0.6, 0.4, 0.0]^\\top$。\n  - 最终时间 $T = 10.0 \\ \\mathrm{s}$。\n  - 步数 $(N_1, N_2, N_3) = (50, 100, 200)$。\n\n- 测试用例 3 (刚性衰变链)：\n  - $\\lambda_1 = 20.0 \\ \\mathrm{s}^{-1}$，$\\lambda_2 = 10.0 \\ \\mathrm{s}^{-1}$，$\\lambda_3 = 5.0 \\ \\mathrm{s}^{-1}$。\n  - $\\sigma_1 = 0.0 \\ \\mathrm{cm}^2$，$\\sigma_2 = 0.0 \\ \\mathrm{cm}^2$，$\\sigma_3 = 0.0 \\ \\mathrm{cm}^2$。\n  - $\\phi = 0.0 \\ \\mathrm{cm}^{-2}\\,\\mathrm{s}^{-1}$。\n  - 初始条件 $\\mathbf{n}(0) = [1.0, 0.0, 0.0]^\\top$。\n  - 最终时间 $T = 0.5 \\ \\mathrm{s}$。\n  - 步数 $(N_1, N_2, N_3) = (50, 100, 200)$。\n\n你的程序应产生单行输出，其中包含三个测试用例测得的收敛率，格式为方括号括起来的、逗号分隔的浮点数列表（例如，\"[p1,p2,p3]\"）。不应产生其他任何输出。最终的收敛率表示为无量纲的浮点数（无单位）。",
            "solution": "该问题要求验证应用于模拟核素损耗的线性常微分方程组 (ODEs) 的预估-校正数值方法的收敛率。这涉及到实现该数值方法，推导并实现解析解，然后利用它们来计算经验收敛阶。\n\n### 1. 控制方程和系统矩阵\n核素数密度 $\\mathbf{n}(t) = [n_1(t), n_2(t), n_3(t)]^\\top$ 的时间演化由以下线性常系数常微分方程组描述：\n$$\n\\frac{d \\mathbf{n}(t)}{dt} = \\mathbf{A} \\, \\mathbf{n}(t)\n$$\n系统矩阵 $\\mathbf{A}$ 是根据衰变常数 $\\lambda_i$、吸收截面 $\\sigma_i$ 和中子通量 $\\phi$ 定义的。它是一个下三角矩阵，形式如下：\n$$\n\\mathbf{A} =\n\\begin{bmatrix}\n-(\\lambda_1 + \\sigma_1 \\, \\phi) & 0 & 0 \\\\\n\\lambda_1 & -(\\lambda_2 + \\sigma_2 \\, \\phi) & 0 \\\\\n0 & \\lambda_2 & -(\\lambda_3 + \\sigma_3 \\, \\phi)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-\\alpha_1 & 0 & 0 \\\\\n\\lambda_1 & -\\alpha_2 & 0 \\\\\n0 & \\lambda_2 & -\\alpha_3\n\\end{bmatrix}\n$$\n其中 $\\alpha_i = \\lambda_i + \\sigma_i \\, \\phi$ 是核素 $i$ 的总移除常数。\n\n### 2. 通过 Bateman 方程求解解析解\n对于具有不同移除常数 $\\alpha_i$ 的线性链，可以使用 Bateman 方程找到其解析解。在时间 $t$ 时，对于一个初始状态 $\\mathbf{n}(0)$ 的解，可以通过对每个初始核素浓度的贡献求和来找到。对于给定的三核素系统，解为：\n\n$n_1(t) = n_1(0) e^{-\\alpha_1 t}$\n\n$n_2(t) = n_1(0) \\frac{\\lambda_1}{\\alpha_2 - \\alpha_1} (e^{-\\alpha_1 t} - e^{-\\alpha_2 t}) + n_2(0) e^{-\\alpha_2 t}$\n\n$n_3(t) = n_1(0) \\lambda_1 \\lambda_2 \\left( \\frac{e^{-\\alpha_1 t}}{(\\alpha_2 - \\alpha_1)(\\alpha_3 - \\alpha_1)} + \\frac{e^{-\\alpha_2 t}}{(\\alpha_1 - \\alpha_2)(\\alpha_3 - \\alpha_2)} + \\frac{e^{-\\alpha_3 t}}{(\\alpha_1 - \\alpha_3)(\\alpha_2 - \\alpha_3)} \\right) + n_2(0) \\frac{\\lambda_2}{\\alpha_3 - \\alpha_2} (e^{-\\alpha_2 t} - e^{-\\alpha_3 t}) + n_3(0) e^{-\\alpha_3 t}$\n\n这些方程在问题假设所有 $\\alpha_i$ 都互不相同的条件下是有效的。\n\n### 3. 数值方法：显式梯形法则 (Heun 方法)\n问题指定了一个预估-校正格式。对于一个一般的常微分方程组 $\\mathbf{y}'=\\mathbf{f}(t, \\mathbf{y})$，从 $t_k$ 到 $t_{k+1}=t_k+h$ 的一个步长包含以下步骤：\n1.  **预估步**：一个显式欧拉步，用于找到区间末端的一个初步值 $\\mathbf{y}^*_{k+1}$。\n    $$\n    \\mathbf{y}^*_{k+1} = \\mathbf{y}_k + h \\mathbf{f}(t_k, \\mathbf{y}_k)\n    $$\n2.  **校正步**：一个隐式梯形步，使用预估值来计算区间末端的函数值，从而提高精度。\n    $$\n    \\mathbf{y}_{k+1} = \\mathbf{y}_k + \\frac{h}{2} \\left[ \\mathbf{f}(t_k, \\mathbf{y}_k) + \\mathbf{f}(t_{k+1}, \\mathbf{y}^*_{k+1}) \\right]\n    $$\n对于我们特定的线性系统 $\\mathbf{f}(t, \\mathbf{n}) = \\mathbf{A}\\mathbf{n}$，该方法简化如下：\n1.  **预估**： $\\mathbf{n}^*_{k+1} = \\mathbf{n}_k + h (\\mathbf{A} \\mathbf{n}_k)$\n2.  **校正**： $\\mathbf{n}_{k+1} = \\mathbf{n}_k + \\frac{h}{2} (\\mathbf{A} \\mathbf{n}_k + \\mathbf{A} \\mathbf{n}^*_{k+1})$\n\n问题中“使用步初系数”进行预估和“使用步末系数”进行校正的措辞暗示了矩阵 $\\mathbf{A}$ 可能依赖于 $\\mathbf{n}$ 的情景。在本问题中，$\\mathbf{A}$ 是常数，因此“步末系数”是使用预估的密度计算的，但结果仍然是相同的常数矩阵 $\\mathbf{A}$。因此，该实现对应于用于线性系统的标准二阶 Heun 方法。\n\n### 4. 收敛率验证\nHeun 方法的理论收敛阶为 $p=2$。为了对此进行经验性验证，我们计算了一系列递减步长下数值解的误差。在最终时间 $T$，对于步长 $h$，误差 $E(h)$ 定义为数值解与解析解之差的欧几里得范数：\n$$\nE(h) = \\|\\mathbf{n}_{\\text{numerical}}(T) - \\mathbf{n}_{\\text{analytic}}(T)\\|_2\n$$\n假设误差遵循关系式 $E(h) \\approx C h^p$，其中 $C$ 是一个常数，我们可以使用两个不同步长 $h_1$ 和 $h_2$ 的结果来估计 $p$：\n$$\np \\approx \\frac{\\log(E(h_1)) - \\log(E(h_2))}{\\log(h_1) - \\log(h_2)}\n$$\n给定步数 $N_1$、$N_2=2N_1$ 和 $N_3=2N_2$，对应的步长为 $h_1=T/N_1$、$h_2=T/N_2=h_1/2$ 和 $h_3=T/N_3=h_2/2$。分母简化为：$\\log(h_1) - \\log(h_2) = \\log(h_1/h_2) = \\log(2)$。我们计算 $p$ 的两个估计值：\n$$\np_{12} = \\frac{\\log(E(h_1)/E(h_2))}{\\log(2)}, \\quad p_{23} = \\frac{\\log(E(h_2)/E(h_3))}{\\log(2)}\n$$\n最终报告的收敛率是这两个估计值的平均值：$p = (p_{12} + p_{23}) / 2$。$p \\approx 2.0$ 的经验值将证实该方法预期的二阶精度。\n\n### 5. 实现策略\n一个 Python 程序的结构旨在解决该问题：\n1.  一个函数 `bateman_solution` 实现了 $n_1(t)$、$n_2(t)$ 和 $n_3(t)$ 的解析公式。它接受物理参数、初始条件和时间 $t$ 作为输入。\n2.  一个函数 `heun_solver` 实现了预估-校正格式。它迭代给定的步数，在每一步更新密度向量。\n3.  主函数 `solve` 协调每个测试用例的处理过程。它会：\n    a.  设置参数（$\\lambda_i, \\sigma_i, \\phi, \\mathbf{n}(0), T, N_k$）。\n    b.  构建矩阵 $\\mathbf{A}$。\n    c.  计算在时间 $T$ 时的精确解。\n    d.  遍历指定的步数（$N_1, N_2, N_3$），为每个步数调用 `heun_solver`，并计算误差范数 $E(h_k)$。\n    e.  使用收集到的误差计算平均收敛率 $p$。\n    f.  收集所有测试用例的收敛率，并以指定格式打印它们。\n所有的向量和矩阵运算都使用 `numpy` 库执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bateman_solution(lambdas, alphas, n0, t):\n    \"\"\"\n    Computes the analytic solution for the 3-nuclide chain using Bateman's equations.\n    Assumes distinct alpha values.\n    \n    Args:\n        lambdas (list or np.ndarray): decay constants [lambda_1, lambda_2, lambda_3].\n        alphas (list or np.ndarray): effective removal constants [alpha_1, alpha_2, alpha_3].\n        n0 (np.ndarray): initial number densities [n1(0), n2(0), n3(0)].\n        t (float): time at which to evaluate the solution.\n\n    Returns:\n        np.ndarray: number density vector [n1(t), n2(t), n3(t)].\n    \"\"\"\n    l1, l2, _ = lambdas\n    a1, a2, a3 = alphas\n    n1_0, n2_0, n3_0 = n0\n\n    # These assertions confirm the problem constraint of distinct alphas\n    assert a1 != a2, \"alpha_1 and alpha_2 cannot be equal.\"\n    assert a1 != a3, \"alpha_1 and alpha_3 cannot be equal.\"\n    assert a2 != a3, \"alpha_2 and alpha_3 cannot be equal.\"\n\n    # Exponential terms\n    exp_a1t = np.exp(-a1 * t)\n    exp_a2t = np.exp(-a2 * t)\n    exp_a3t = np.exp(-a3 * t)\n\n    # --- n1(t) ---\n    n1_t = n1_0 * exp_a1t\n\n    # --- n2(t) ---\n    n2_t_from_n1_0 = n1_0 * l1 / (a2 - a1) * (exp_a1t - exp_a2t)\n    n2_t_from_n2_0 = n2_0 * exp_a2t\n    n2_t = n2_t_from_n1_0 + n2_t_from_n2_0\n\n    # --- n3(t) ---\n    # Contribution from n1(0)\n    c1 = 1.0 / ((a2 - a1) * (a3 - a1))\n    c2 = 1.0 / ((a1 - a2) * (a3 - a2))\n    c3 = 1.0 / ((a1 - a3) * (a2 - a3))\n    n3_t_from_n1_0 = n1_0 * l1 * l2 * (c1 * exp_a1t + c2 * exp_a2t + c3 * exp_a3t)\n    \n    # Contribution from n2(0)\n    if l2 > 0:\n        n3_t_from_n2_0 = n2_0 * l2 / (a3 - a2) * (exp_a2t - exp_a3t)\n    else:\n        n3_t_from_n2_0 = 0.0\n\n    # Contribution from n3(0)\n    n3_t_from_n3_0 = n3_0 * exp_a3t\n    \n    n3_t = n3_t_from_n1_0 + n3_t_from_n2_0 + n3_t_from_n3_0\n\n    return np.array([n1_t, n2_t, n3_t])\n\ndef heun_solver(A, n0, h, num_steps):\n    \"\"\"\n    Solves dn/dt = An using the explicit trapezoidal (Heun's) method.\n    \n    Args:\n        A (np.ndarray): The coefficient matrix.\n        n0 (np.ndarray): The initial number density vector.\n        h (float): The time step size.\n        num_steps (int): The number of time steps to take.\n\n    Returns:\n        np.ndarray: The numerical solution vector at the final time.\n    \"\"\"\n    n = np.copy(n0)\n    for _ in range(num_steps):\n        # Predictor step\n        k1 = A @ n\n        n_pred = n + h * k1\n        \n        # Corrector step\n        k2 = A @ n_pred\n        n = n + (h / 2.0) * (k1 + k2)\n    return n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute convergence rates.\n    \"\"\"\n    test_cases = [\n        {\n            \"lambdas\": np.array([0.1, 0.05, 0.0]),\n            \"sigmas\": np.array([0.0, 0.0, 0.0]),\n            \"phi\": 0.0,\n            \"n0\": np.array([1.0, 0.0, 0.0]),\n            \"T\": 5.0,\n            \"Ns\": (50, 100, 200),\n        },\n        {\n            \"lambdas\": np.array([0.05, 0.02, 0.01]),\n            \"sigmas\": np.array([3e-24, 4e-24, 2e-24]),\n            \"phi\": 1e14,\n            \"n0\": np.array([0.6, 0.4, 0.0]),\n            \"T\": 10.0,\n            \"Ns\": (50, 100, 200),\n        },\n        {\n            \"lambdas\": np.array([20.0, 10.0, 5.0]),\n            \"sigmas\": np.array([0.0, 0.0, 0.0]),\n            \"phi\": 0.0,\n            \"n0\": np.array([1.0, 0.0, 0.0]),\n            \"T\": 0.5,\n            \"Ns\": (50, 100, 200),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambdas = case[\"lambdas\"]\n        sigmas = case[\"sigmas\"]\n        phi = case[\"phi\"]\n        n0 = case[\"n0\"]\n        T = case[\"T\"]\n        Ns = case[\"Ns\"]\n\n        # Calculate effective removal constants and build the matrix A\n        alphas = lambdas + sigmas * phi\n        A = np.array([\n            [-alphas[0], 0, 0],\n            [lambdas[0], -alphas[1], 0],\n            [0, lambdas[1], -alphas[2]],\n        ])\n\n        # Get the exact solution at the final time T\n        n_exact = bateman_solution(lambdas, alphas, n0, T)\n        \n        errors = []\n        step_sizes = []\n\n        for N in Ns:\n            h = T / N\n            step_sizes.append(h)\n            \n            # Get the numerical solution\n            n_numerical = heun_solver(A, n0, h, N)\n            \n            # Calculate the Euclidean norm of the error\n            error = np.linalg.norm(n_numerical - n_exact)\n            errors.append(error)\n\n        # Calculate pairwise convergence rates\n        # p = log(E1/E2) / log(h1/h2) where h1/h2 = 2\n        p12 = np.log(errors[0] / errors[1]) / np.log(step_sizes[0] / step_sizes[1])\n        p23 = np.log(errors[1] / errors[2]) / np.log(step_sizes[1] / step_sizes[2])\n\n        # Average the two estimates\n        p_avg = (p12 + p23) / 2.0\n        results.append(p_avg)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在真实的反应堆模拟中，由于各种反馈效应的存在，问题通常是非线性的。本实践将超越简单的代码验证，在一个包含中子通量反馈的基准问题上，将预测-校正方法与其他常用技术（如简单的一阶方法和先进的自适应求解器）进行比较。我们的目标是分析在准确性和计算成本之间的实际权衡，这是工程师和科学家在选择数值方法时必须面对的核心问题。",
            "id": "4241782",
            "problem": "请考虑一个简化的、科学上一致的耗散基准问题，该问题代表了核反应堆模拟。该系统由三种核素的数密度组成，记为向量 $N(t) = [N_F(t), N_M(t), N_X(t)]^\\top$，单位为原子数/立方厘米。其控制方程为 Bateman 型耦合系统\n$$\n\\frac{dN}{dt} = Q\\big(N(t)\\big)\\,N(t),\n$$\n其中 $Q(N)$ 是一个 $3\\times 3$ 的反应率矩阵，其元素由中子诱发反应和放射性衰变决定。中子通量通过带有成分反馈的模型表示为\n$$\n\\phi(N) = \\frac{\\phi_0}{1 + \\kappa\\,N_X},\n$$\n其中 $\\phi_0$ 的单位是中子数/平方厘米·秒，$\\kappa$ 的单位是立方厘米/原子。所包含的物理过程有：\n- 易裂变核素 $F$ 的吸收和裂变，其微观截面分别为 $\\sigma_{F,a}$ 和 $\\sigma_{F,f}$，单位为平方厘米。\n- 介质核素 $M$ 的吸收，截面为 $\\sigma_{M,a}$；以及毒物核素 $X$ 的吸收，截面为 $\\sigma_{X,a}$。\n- 放射性衰变，衰变常数分别为 $\\lambda_F$、$\\lambda_M$ 和 $\\lambda_X$，单位为 1/秒。\n- 一部分比例为 $b_{M\\rightarrow F}$ 的 $M$ 衰变为 $F$，毒物 $X$ 由 $F$ 的裂变产生，独立产额为 $y_X$（无量纲）。\n\n在这些假设下，$Q(N)$ 的元素定义如下\n$$\n\\begin{aligned}\n\\frac{dN_F}{dt} = -\\big(\\sigma_{F,a}+\\sigma_{F,f}\\big)\\,\\phi(N)\\,N_F - \\lambda_F\\,N_F + b_{M\\rightarrow F}\\,\\lambda_M\\,N_M,\\\\\n\\frac{dN_M}{dt} = +\\sigma_{F,a}\\,\\phi(N)\\,N_F - \\sigma_{M,a}\\,\\phi(N)\\,N_M - \\lambda_M\\,N_M,\\\\\n\\frac{dN_X}{dt} = +y_X\\,\\sigma_{F,f}\\,\\phi(N)\\,N_F - \\sigma_{X,a}\\,\\phi(N)\\,N_X - \\lambda_X\\,N_X.\n\\end{aligned}\n$$\n这通过 $dN/dt = Q(N)\\,N$ 定义了 $Q(N)$。\n\n您的任务是，在给定的时间范围 $T$ 和初始条件 $N(0)=N_0$ 下，实现并比较三种时间积分策略，并量化其精度和计算成本：\n1. 冻结反应率矩阵指数法 (ME)：在一个宏观时间步长 $\\Delta t$ 内，将 $Q$ 在时间步开始时冻结为 $Q_k = Q(N_k)$，并计算 $N_{k+1} = \\exp\\!\\big(\\Delta t\\,Q_k\\big)\\,N_k$。\n2. 预测-校正耗散法 (PC)：在一个宏观时间步长 $\\Delta t$ 内，计算预测值 $N^{\\mathrm{pred}} = \\exp\\!\\big(\\Delta t\\,Q(N_k)\\big)\\,N_k$，然后构建 $Q_{\\mathrm{avg}} = \\tfrac{1}{2}\\big(Q(N_k)+Q(N^{\\mathrm{pred}})\\big)$，并计算校正后的状态 $N_{k+1} = \\exp\\!\\big(\\Delta t\\,Q_{\\mathrm{avg}}\\big)\\,N_k$。\n3. 反向微分公式 (BDF)：使用一个隐式变步长求解器来求解 $dN/dt = Q(N)\\,N$。\n\n将精度度量定义为最终时刻的相对 2-范数误差，\n$$\n\\varepsilon = \\frac{\\left\\|N_{\\mathrm{method}}(T)-N_{\\mathrm{ref}}(T)\\right\\|_2}{\\left\\|N_{\\mathrm{ref}}(T)\\right\\|_2},\n$$\n其中参考解 $N_{\\mathrm{ref}}(T)$ 为：\n- 在线性情况（恒定通量）下，为精确解 $N_{\\mathrm{ref}}(T)=\\exp\\!\\big(T\\,Q_{\\mathrm{const}}\\big)\\,N_0$，其中 $Q_{\\mathrm{const}}=Q(N_0)$ 且 $\\kappa=0$，这使得 $Q$ 不随时间变化。\n- 在非线性反馈情况（$\\kappa>0$）下，为一个具有严格容差的高精度反向微分公式 (BDF) 解。\n\n将计算成本代理指标定义如下：\n- 对于 ME：反应率矩阵求值次数 $n_Q$ 和矩阵指数求值次数 $n_{\\exp}$。\n- 对于 PC：反应率矩阵求值次数 $n_Q$ 和矩阵指数求值次数 $n_{\\exp}$。\n- 对于 BDF：求解器报告的右端项求值次数 $n_{\\mathrm{fev}}$ 和雅可比矩阵求值次数 $n_{\\mathrm{jev}}$。\n\n所有物理单位必须一致：数密度单位为原子数/立方厘米，通量单位为中子数/平方厘米·秒，截面单位为平方厘米，时间单位为秒。所有数值输出均表示为浮点数，使用上述定义的精度度量（无量纲），计算成本代理指标则为整数计数。\n\n实现您的程序以运行以下测试套件，每个测试由 $(N_0,\\phi_0,\\kappa,T,\\Delta t)$ 以及固定的微观和衰变参数指定：\n\n所有测试的固定参数：\n- $\\sigma_{F,a} = 6\\times 10^{-24}$, $\\sigma_{F,f} = 5.85\\times 10^{-22}$, $\\sigma_{M,a} = 2\\times 10^{-24}$, $\\sigma_{X,a} = 2\\times 10^{-18}$。\n- $\\lambda_F = 0$, $\\lambda_M = 1\\times 10^{-6}$, $\\lambda_X = 2.1\\times 10^{-5}$。\n- $b_{M\\rightarrow F} = 0.5$, $y_X = 3\\times 10^{-3}$。\n\n测试案例：\n- 案例 A（线性，恒定通量基准）：$N_0 = [5\\times 10^{20},\\,2\\times 10^{20},\\,1\\times 10^{16}]^\\top$，$\\phi_0 = 1\\times 10^{14}$，$\\kappa=0$，$T=3.6\\times 10^{3}$，$\\Delta t = 6.0\\times 10^{2}$。\n- 案例 B（非线性，弱反馈）：$N_0 = [5\\times 10^{20},\\,2\\times 10^{20},\\,1\\times 10^{16}]^\\top$，$\\phi_0 = 1\\times 10^{14}$，$\\kappa=1\\times 10^{-21}$，$T=3.6\\times 10^{3}$，$\\Delta t = 6.0\\times 10^{2}$。\n- 案例 C（非线性，具有强毒化效应的刚性问题）：$N_0 = [5\\times 10^{20},\\,2\\times 10^{20},\\,1\\times 10^{16}]^\\top$，$\\phi_0 = 3\\times 10^{14}$，$\\kappa=5\\times 10^{-21}$，$T=3.6\\times 10^{3}$，$\\Delta t = 6.0\\times 10^{1}$。\n\n对于每个案例，计算：\n- ME 方法的最终时刻相对误差 $\\varepsilon_{\\mathrm{ME}}$、$n_Q$ 和 $n_{\\exp}$。\n- PC 方法的最终时刻相对误差 $\\varepsilon_{\\mathrm{PC}}$、$n_Q$ 和 $n_{\\exp}$。\n- BDF 方法的最终时刻相对误差 $\\varepsilon_{\\mathrm{BDF}}$、$n_{\\mathrm{fev}}$ 和 $n_{\\mathrm{jev}}$（使用中等容差）。\n\n在非线性案例中，BDF 参考解使用严格容差，相对容差为 $10^{-10}$，每个分量的绝对容差为 $10^{-12}$；用于比较的 BDF 方法使用中等容差，相对容差为 $10^{-8}$，每个分量的绝对容差为 $10^{-10}$。线性案例的参考解应使用所述的精确矩阵指数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，其中每个元素对应一个测试案例，并且本身也是一个列表\n$$\n\\big[\\varepsilon_{\\mathrm{ME}},\\,n_{Q,\\mathrm{ME}},\\,n_{\\exp,\\mathrm{ME}},\\,\\varepsilon_{\\mathrm{PC}},\\,n_{Q,\\mathrm{PC}},\\,n_{\\exp,\\mathrm{PC}},\\,\\varepsilon_{\\mathrm{BDF}},\\,n_{\\mathrm{fev,BDF}},\\,n_{\\mathrm{jev,BDF}}\\big].\n$$\n打印出的列表格式应不含空格（例如，$[[\\dots],[\\dots],[\\dots]]$）。",
            "solution": "所提出的问题是针对一个模拟简化核反应堆中核素耗散的耦合非线性常微分方程 (ODE) 系统，实现并比较三种数值时间积分方案。该问题在科学上是一致的、适定的，并为严格的计算分析提供了所有必要的数据和规范。评估标准在精度和计算成本代理指标方面有明确的定义。因此，该问题是有效的，下面给出完整的解决方案。\n\n系统动力学由以下向量方程描述：\n$$\n\\frac{d}{dt} N(t) = Q\\big(N(t)\\big) N(t)\n$$\n其中 $N(t) = [N_F(t), N_M(t), N_X(t)]^\\top$ 是易裂变核素 ($F$)、介质核素 ($M$) 和毒物核素 ($X$) 的数密度向量。演化过程由依赖于状态的反应率矩阵 $Q(N)$ 控制，其元素是物理常数和中子通量 $\\phi(N)$ 的函数，该通量表现出对毒物浓度 $N_X$ 的反馈：\n$$\n\\phi(N) = \\frac{\\phi_0}{1 + \\kappa N_X}\n$$\n单个 ODE 方程如下：\n$$\n\\begin{aligned}\n\\frac{dN_F}{dt} = -\\big(\\sigma_{F,a}+\\sigma_{F,f}\\big)\\,\\phi(N)\\,N_F - \\lambda_F\\,N_F + b_{M\\rightarrow F}\\,\\lambda_M\\,N_M \\\\\n\\frac{dN_M}{dt} = +\\sigma_{F,a}\\,\\phi(N)\\,N_F - \\sigma_{M,a}\\,\\phi(N)\\,N_M - \\lambda_M\\,N_M \\\\\n\\frac{dN_X}{dt} = +y_X\\,\\sigma_{F,f}\\,\\phi(N)\\,N_F - \\sigma_{X,a}\\,\\phi(N)\\,N_X - \\lambda_X\\,N_X\n\\end{aligned}\n$$\n根据此系统，可以构建 $3 \\times 3$ 的反应率矩阵 $Q(N)$ 如下：\n$$\nQ(N) =\n\\begin{pmatrix}\n-\\left(\\sigma_{F,a}+\\sigma_{F,f}\\right)\\phi(N) - \\lambda_F & b_{M\\rightarrow F}\\lambda_M & 0 \\\\\n\\sigma_{F,a}\\phi(N) & -\\sigma_{M,a}\\phi(N) - \\lambda_M & 0 \\\\\ny_X\\sigma_{F,f}\\phi(N) & 0 & -\\sigma_{X,a}\\phi(N) - \\lambda_X\n\\end{pmatrix}\n$$\n任务是使用三种不同的方法求解这个从 $t=0$ 到 $t=T$ 的初值问题（给定 $N(0)=N_0$），并比较它们的性能。\n\n1.  **冻结反应率矩阵指数法 (ME)**：这是一种一阶显式方法。对于每个从 $t_k$ 到 $t_{k+1}$、时长为 $\\Delta t$ 的时间步，假设反应率矩阵 $Q$ 是恒定的，并在时间步开始时求值，即 $Q_k = Q(N_k)$。然后使用矩阵指数推进求解：\n    $$\n    N_{k+1} = \\exp\\left(\\Delta t \\, Q_k\\right) N_k\n    $$\n    一步的计算成本是一次 $Q(N)$ 求值和一次矩阵指数计算。\n\n2.  **预测-校正耗散法 (PC)**：这是一种二阶显式方法，旨在提高 ME 方法的精度。每个时间步包括两个阶段：\n    -   **预测阶段**：使用 ME 方法计算一个中间状态 $N^{\\mathrm{pred}}$：\n        $$\n        N^{\\mathrm{pred}} = \\exp\\left(\\Delta t \\, Q(N_k)\\right) N_k\n        $$\n    -   **校正阶段**：通过对时间步开始和预测结束时的反应率取平均，形成一个新的、更准确的反应率矩阵 $Q_{\\mathrm{avg}}$：\n        $$\n        Q_{\\mathrm{avg}} = \\frac{1}{2}\\left(Q(N_k) + Q(N^{\\mathrm{pred}})\\right)\n        $$\n        然后使用这个平均矩阵，再次从 $N_k$ 开始，计算该时间步的最终状态：\n        $$\n        N_{k+1} = \\exp\\left(\\Delta t \\, Q_{\\mathrm{avg}}\\right) N_k\n        $$\n    一步的成本是两次 $Q(N)$ 求值和两次矩阵指数计算。\n\n3.  **反向微分公式 (BDF)**：这是一类隐式、变步长、多步方法，非常适合求解刚性 ODE。我们将使用一个高质量的库实现（`scipy.integrate.solve_ivp`，`method='BDF'`）。求解器会自动调整其内部步长以满足指定的误差容差，这使得它与固定步长的 ME 和 PC 方法有本质区别。其成本由求解器报告的右端函数求值次数 ($n_{\\mathrm{fev}}$) 和雅可比矩阵求值次数 ($n_{\\mathrm{jev}}$) 来衡量。\n\n比较基于最终时间 $T$ 的相对 $L_2$-范数误差度量：\n$$\n\\varepsilon = \\frac{\\left\\|N_{\\mathrm{method}}(T)-N_{\\mathrm{ref}}(T)\\right\\|_2}{\\left\\|N_{\\mathrm{ref}}(T)\\right\\|_2}\n$$\n为每个案例生成一个高保真度的参考解 $N_{\\mathrm{ref}}(T)$。在线性情况（$\\kappa=0$）下，$Q$ 是恒定的，精确解为 $N(T) = \\exp(T Q) N_0$。在非线性情况（$\\kappa>0$）下，使用一个具有非常严格容差（`rtol=1e-10`, `atol=1e-12`）的 BDF 解作为参考。\n\n实现过程将首先定义一个函数，根据问题参数构造 $Q(N)$。然后，单独的函数将实现 ME、PC 和 BDF 求解方案。主程序将遍历指定的测试案例，计算参考解，运行这三种方法中的每一种，并计算它们各自的精度和成本指标。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Implements and compares three time-integration strategies for a simplified\n    nuclear reactor nuclide depletion problem.\n    \"\"\"\n    \n    # Fixed physical parameters for all test cases\n    params = {\n        'sigma_F_a': 6e-24,\n        'sigma_F_f': 5.85e-22,\n        'sigma_M_a': 2e-24,\n        'sigma_X_a': 2e-18,\n        'lambda_F': 0.0,\n        'lambda_M': 1e-6,\n        'lambda_X': 2.1e-5,\n        'b_M_to_F': 0.5,\n        'y_X': 3e-3\n    }\n\n    # Test case definitions: (N0, phi0, kappa, T, dt)\n    test_cases = [\n        # Case A: linear, constant flux baseline\n        {'N0': np.array([5e20, 2e20, 1e16]), 'phi0': 1e14, 'kappa': 0.0,\n         'T': 3.6e3, 'dt': 6.0e2},\n        # Case B: nonlinear, mild feedback\n        {'N0': np.array([5e20, 2e20, 1e16]), 'phi0': 1e14, 'kappa': 1e-21,\n         'T': 3.6e3, 'dt': 6.0e2},\n        # Case C: nonlinear, stiff with strong poisoning\n        {'N0': np.array([5e20, 2e20, 1e16]), 'phi0': 3e14, 'kappa': 5e-21,\n         'T': 3.6e3, 'dt': 6.0e1},\n    ]\n\n    # Helper function to get the rate matrix Q(N)\n    def get_Q(N, phi0, kappa, p):\n        N_X = N[2]\n        flux = phi0 / (1.0 + kappa * N_X)\n        \n        Q = np.zeros((3, 3))\n        \n        # dN_F/dt terms\n        Q[0, 0] = -(p['sigma_F_a'] + p['sigma_F_f']) * flux - p['lambda_F']\n        Q[0, 1] = p['b_M_to_F'] * p['lambda_M']\n        \n        # dN_M/dt terms\n        Q[1, 0] = p['sigma_F_a'] * flux\n        Q[1, 1] = -p['sigma_M_a'] * flux - p['lambda_M']\n        \n        # dN_X/dt terms\n        Q[2, 0] = p['y_X'] * p['sigma_F_f'] * flux\n        Q[2, 2] = -p['sigma_X_a'] * flux - p['lambda_X']\n        \n        return Q\n\n    # Right-hand side function for ODE solver\n    def rhs(t, N, phi0, kappa, p):\n        Q = get_Q(N, phi0, kappa, p)\n        return Q @ N\n\n    # Error calculation function\n    def calculate_relative_error(N_method, N_ref):\n        return np.linalg.norm(N_method - N_ref) / np.linalg.norm(N_ref)\n\n    all_results = []\n    for case in test_cases:\n        N0, phi0, kappa, T, dt = case['N0'], case['phi0'], case['kappa'], case['T'], case['dt']\n\n        # --- Generate Reference Solution ---\n        if kappa == 0:  # Linear case\n            Q_const = get_Q(N0, phi0, kappa, params)\n            N_ref = expm(T * Q_const) @ N0\n        else:  # Nonlinear case\n            sol_ref = solve_ivp(\n                lambda t, y: rhs(t, y, phi0, kappa, params),\n                (0, T), N0, method='BDF', rtol=1e-10, atol=1e-12\n            )\n            N_ref = sol_ref.y[:, -1]\n\n        # --- 1. Matrix Exponential (ME) Method ---\n        N_me = N0.copy()\n        num_steps = int(round(T / dt))\n        n_Q_me, n_exp_me = 0, 0\n        for _ in range(num_steps):\n            Q_k = get_Q(N_me, phi0, kappa, params)\n            n_Q_me += 1\n            N_me = expm(dt * Q_k) @ N_me\n            n_exp_me += 1\n        eps_me = calculate_relative_error(N_me, N_ref)\n\n        # --- 2. Predictor-Corrector (PC) Method ---\n        N_pc = N0.copy()\n        n_Q_pc, n_exp_pc = 0, 0\n        for _ in range(num_steps):\n            Q_k = get_Q(N_pc, phi0, kappa, params)\n            n_Q_pc += 1\n            \n            N_pred = expm(dt * Q_k) @ N_pc\n            n_exp_pc += 1\n            \n            Q_pred = get_Q(N_pred, phi0, kappa, params)\n            n_Q_pc += 1\n            \n            Q_avg = 0.5 * (Q_k + Q_pred)\n            N_pc = expm(dt * Q_avg) @ N_pc\n            n_exp_pc += 1\n        eps_pc = calculate_relative_error(N_pc, N_ref)\n\n        # --- 3. BDF Method ---\n        sol_bdf = solve_ivp(\n            lambda t, y: rhs(t, y, phi0, kappa, params),\n            (0, T), N0, method='BDF', rtol=1e-8, atol=1e-10\n        )\n        N_bdf = sol_bdf.y[:, -1]\n        eps_bdf = calculate_relative_error(N_bdf, N_ref)\n        n_fev_bdf = sol_bdf.nfev\n        n_jev_bdf = sol_bdf.njev\n\n        case_results = [\n            eps_me, n_Q_me, n_exp_me,\n            eps_pc, n_Q_pc, n_exp_pc,\n            eps_bdf, n_fev_bdf, n_jev_bdf,\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    outer_list_str = []\n    for case_res in all_results:\n        inner_list_str = f\"[{','.join(f'{val:.6e}' if isinstance(val, float) else str(val) for val in case_res)}]\"\n        outer_list_str.append(inner_list_str)\n    \n    print(f\"[{','.join(outer_list_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在紧耦合模拟中，校正步骤本身可能需要一个迭代过程，以找到核素场和中子通量之间的自洽解。本练习深入探讨了如何使用松弛参数来加速这些内部迭代的收敛。我们将推导能够最小化误差放大的最优松弛参数，这是提高高级预测-校正方案效率的一项关键技术。",
            "id": "4241763",
            "problem": "在耦合中子输运与核素燃耗模拟中，同位素数密度 $\\mathbf{n}(t)$ 根据形式为 $\\frac{d\\mathbf{n}}{dt} = \\mathbf{F}(\\mathbf{n}, \\phi(\\mathbf{n}))$ 的常微分方程组 (ODEs) 演化，其中中子通量 $\\phi$ 通过宏观截面依赖于 $\\mathbf{n}$。在每个燃耗时间步应用预测-校正耦合，以确保通量场和核素场之间的一致性。考虑松弛校正更新\n$$\n\\mathbf{n}^{k+1} = \\mathbf{n}^{k} + \\omega\\left(\\mathcal{C}(\\mathbf{n}^{k}) - \\mathbf{n}^{k}\\right),\n$$\n其中 $\\mathcal{C}$ 是校正映射（例如，通过使用更新后的通量进行一次隐式燃耗求解得到），而 $\\omega$ 是一个标量松弛参数。\n\n假设在物理上一致的不动点 $\\mathbf{n}^{\\ast}$ 附近，校正映射是 Fréchet 可微的，并且其雅可比矩阵 $T = D\\mathcal{C}(\\mathbf{n}^{\\ast})$ 具有包含在区间 $[t_{\\min}, t_{\\max}]$ 内的实数谱，其中 $t_{\\min} = 0.68$ 且 $t_{\\max} = 0.91$。这与所选时间步长上的反应速率限制燃耗以及通量对变化的宏观截面的敏感性相一致。\n\n您需要提出一个 $\\omega$ 的值，该值能够最小化所有本征模式下的最坏情况渐近误差放大，即最小化松弛校正更新的线性化误差传播算子的谱半径。请提供根据这些界限计算出的最优 $\\omega$ 的单个数值。将您的最终答案表示为一个纯数（无量纲），并将其四舍五入到四位有效数字。",
            "solution": "用户希望找到用于核反应堆模拟中松弛校正更新方案的最优松弛参数 $\\omega$。目标是最小化最坏情况下的渐近误差放大，这等效于最小化线性化误差传播算子的谱半径。\n\n松弛校正更新由下式给出：\n$$\n\\mathbf{n}^{k+1} = \\mathbf{n}^{k} + \\omega\\left(\\mathcal{C}(\\mathbf{n}^{k}) - \\mathbf{n}^{k}\\right)\n$$\n该方程可以重排为不动点迭代的形式：\n$$\n\\mathbf{n}^{k+1} = (1-\\omega)\\mathbf{n}^{k} + \\omega\\mathcal{C}(\\mathbf{n}^{k})\n$$\n令 $\\mathbf{n}^{\\ast}$ 表示物理上一致的不动点，它满足条件 $\\mathcal{C}(\\mathbf{n}^{\\ast}) = \\mathbf{n}^{\\ast}$。第 $k$ 次迭代的误差定义为与此不动点的偏差：$\\mathbf{e}^{k} = \\mathbf{n}^{k} - \\mathbf{n}^{\\ast}$。\n\n为分析迭代的收敛性，我们在不动点 $\\mathbf{n}^{\\ast}$ 附近对更新方程进行线性化。我们将 $\\mathbf{n}^{k} = \\mathbf{n}^{\\ast} + \\mathbf{e}^{k}$ 代入迭代公式中：\n$$\n\\mathbf{n}^{\\ast} + \\mathbf{e}^{k+1} = (1-\\omega)(\\mathbf{n}^{\\ast} + \\mathbf{e}^{k}) + \\omega\\mathcal{C}(\\mathbf{n}^{\\ast} + \\mathbf{e}^{k})\n$$\n问题陈述，校正映射 $\\mathcal{C}$ 是 Fréchet 可微的。因此，我们可以对 $\\mathcal{C}(\\mathbf{n}^{\\ast} + \\mathbf{e}^{k})$ 在 $\\mathbf{n}^{\\ast}$ 处使用一阶泰勒级数展开：\n$$\n\\mathcal{C}(\\mathbf{n}^{\\ast} + \\mathbf{e}^{k}) \\approx \\mathcal{C}(\\mathbf{n}^{\\ast}) + D\\mathcal{C}(\\mathbf{n}^{\\ast})\\mathbf{e}^{k}\n$$\n此处，$D\\mathcal{C}(\\mathbf{n}^{\\ast})$ 是映射 $\\mathcal{C}$ 在不动点 $\\mathbf{n}^{\\ast}$ 处求值的雅可比矩阵，记为 $T$。使用 $\\mathcal{C}(\\mathbf{n}^{\\ast})=\\mathbf{n}^{\\ast}$，展开式变为：\n$$\n\\mathcal{C}(\\mathbf{n}^{\\ast} + \\mathbf{e}^{k}) \\approx \\mathbf{n}^{\\ast} + T\\mathbf{e}^{k}\n$$\n将此近似代入误差演化方程中：\n$$\n\\mathbf{n}^{\\ast} + \\mathbf{e}^{k+1} \\approx (1-\\omega)(\\mathbf{n}^{\\ast} + \\mathbf{e}^{k}) + \\omega(\\mathbf{n}^{\\ast} + T\\mathbf{e}^{k})\n$$\n展开并简化各项：\n$$\n\\mathbf{n}^{\\ast} + \\mathbf{e}^{k+1} \\approx (1-\\omega)\\mathbf{n}^{\\ast} + (1-\\omega)\\mathbf{e}^{k} + \\omega\\mathbf{n}^{\\ast} + \\omega T\\mathbf{e}^{k}\n$$\n$$\n\\mathbf{n}^{\\ast} + \\mathbf{e}^{k+1} \\approx \\mathbf{n}^{\\ast} + ((1-\\omega)I + \\omega T)\\mathbf{e}^{k}\n$$\n其中 $I$ 是单位算子。这导出了线性化误差传播方程：\n$$\n\\mathbf{e}^{k+1} \\approx G_{\\omega}\\mathbf{e}^{k} \\quad \\text{其中} \\quad G_{\\omega} = (1-\\omega)I + \\omega T\n$$\n算子 $G_{\\omega}$ 是误差传播算子，或称迭代算子。渐近收敛速率由其谱半径 $\\rho(G_{\\omega})$ 决定。为了找到最优松弛参数 $\\omega$，我们必须找到使 $\\rho(G_{\\omega})$ 最小化的 $\\omega$ 值。\n\n$G_{\\omega}$ 的本征值（记为 $\\lambda$）通过标量函数 $\\lambda(t) = (1-\\omega) + \\omega t = 1 - \\omega(1-t)$ 与 $T$ 的本征值（记为 $t$）相关联。谱半径是这些本征值绝对值的最大值：\n$$\n\\rho(G_{\\omega}) = \\max_{t \\in \\sigma(T)} |\\lambda(t)| = \\max_{t \\in \\sigma(T)} |1 - \\omega(1-t)|\n$$\n其中 $\\sigma(T)$ 是 $T$ 的谱。\n\n问题陈述，谱 $\\sigma(T)$ 是实数且包含在区间 $[t_{\\min}, t_{\\max}]$ 内，其中 $t_{\\min} = 0.68$ 且 $t_{\\max} = 0.91$。由于 $\\lambda(t)$ 是 $t$ 的线性函数，其绝对值在区间 $[t_{\\min}, t_{\\max}]$ 上的最大值必在端点之一处取得。因此，我们要最小化：\n$$\ng(\\omega) = \\max \\left( |1 - \\omega(1-t_{\\min})|, |1 - \\omega(1-t_{\\max})| \\right)\n$$\n这是一个经典的极小化极大问题。当两个参数的绝对值相等时，$g(\\omega)$ 达到其最小值：\n$$\n|1 - \\omega(1-t_{\\min})| = |1 - \\omega(1-t_{\\max})|\n$$\n该条件导出了 $\\omega$ 的最优值。当两个量符号相反时，出现最优解，这平衡了整个谱范围内的误差放大：\n$$\n1 - \\omega(1-t_{\\min}) = - \\left[1 - \\omega(1-t_{\\max})\\right]\n$$\n求解 $\\omega$：\n$$\n1 - \\omega + \\omega t_{\\min} = -1 + \\omega - \\omega t_{\\max}\n$$\n$$\n2 = 2\\omega - \\omega t_{\\min} - \\omega t_{\\max}\n$$\n$$\n2 = \\omega(2 - (t_{\\min} + t_{\\max}))\n$$\n这给出了最优松弛参数 $\\omega_{\\text{opt}}$：\n$$\n\\omega_{\\text{opt}} = \\frac{2}{2 - (t_{\\min} + t_{\\max})}\n$$\n给定数值 $t_{\\min} = 0.68$ 和 $t_{\\max} = 0.91$。将这些值代入公式中：\n$$\n\\omega_{\\text{opt}} = \\frac{2}{2 - (0.68 + 0.91)} = \\frac{2}{2 - 1.59} = \\frac{2}{0.41}\n$$\n计算数值：\n$$\n\\omega_{\\text{opt}} \\approx 4.87804878...\n$$\n按要求将结果四舍五入到四位有效数字，我们得到 $4.878$。",
            "answer": "$$\n\\boxed{4.878}\n$$"
        }
    ]
}