{
    "hands_on_practices": [
        {
            "introduction": "The point kinetics equations that govern the amplitude $A(t)$ in the PCQS method rely on parameters like the effective delayed neutron fraction $\\beta_{\\text{eff}}$ and the prompt neutron generation time $\\Lambda$. These are not fundamental constants but are instead weighted averages that depend on the neutron flux shape $\\psi(\\mathbf{r},t)$. This exercise provides practice in deriving and computing these crucial parameters directly from a given flux shape, grounding the abstract PCQS method in fundamental reactor physics principles .",
            "id": "4242130",
            "problem": "You are given a one-dimensional, slab-geometry multigroup setting relevant to the Predictor–Corrector Quasi-Static (PCQS) method in nuclear reactor simulation, where the neutron flux is factorized into an amplitude and a shape. You are to start from the fundamental multigroup balance concepts (neutron density, fission source rate) and derive working numerical estimators for the effective delayed neutron fraction and the prompt neutron generation time using only the provided shape functions and cross sections. Implement the derived estimators as midpoint-rule quadratures on uniform meshes, and evaluate the sensitivity of the estimators to the discretization of the shape.\n\nUse the following fundamental base:\n\n- The neutron density in energy group $g$ is related to the neutron flux by $n_g(\\mathbf{r},t) = \\phi_g(\\mathbf{r},t)/v_g$, where $v_g$ is the neutron speed in the energy group $g$.\n- The total fission production rate is $F(t) = \\sum_{g} \\int \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$, where $\\nu_g$ is the average number of neutrons per fission induced by a neutron in group $g$, and $\\Sigma_{f,g}$ is the macroscopic fission cross section in group $g$.\n- The delayed neutron fraction at the point of production is characterized by groupwise delayed fractions $\\beta_g$, assumed constant over space for this problem. The delayed fission production rate is $F_d(t) = \\sum_{g} \\int \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$.\n- In the quasi-static factorization, the flux is represented as $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r},t)$, where $A(t)$ is an amplitude and $\\psi_g$ is a shape that captures the spatial and energy dependence.\n\nTasks:\n\n$1.$ Using the above base only, derive expressions for the effective delayed neutron fraction $\\beta_{\\text{eff}}(t)$ and for the prompt neutron generation time $\\Lambda(t)$ in terms of spatial integrals over the shape $\\psi_g(\\mathbf{r},t)$, the group speeds $v_g$, the macroscopic fission cross sections $\\Sigma_{f,g}(\\mathbf{r})$, and the groupwise delayed fractions $\\beta_g$, without invoking any adjoint weighting or transport-eigenvalue shortcuts. Clearly state any quasi-static assumptions you rely on to eliminate dependence on the amplitude $A(t)$.\n\n$2.$ In one-dimensional slab geometry of length $L$, replace volume integrals with line integrals over $x \\in [0,L]$ and evaluate them numerically using the midpoint rule over a uniform grid of $N$ cells with cell width $\\Delta x = L/N$ and midpoints $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ for $i \\in \\{0,1,\\dots,N-1\\}$.\n\n$3.$ Implement a program that, for each test case specified below, computes:\n- The effective delayed neutron fraction $\\beta_{\\text{eff}}$ (dimensionless).\n- The prompt neutron generation time $\\Lambda$ in seconds.\n- The relative discretization sensitivity for each quantity, defined as $E_{\\beta} = \\left|\\beta_{\\text{eff}}^{(N)} - \\beta_{\\text{eff}}^{(\\text{ref})}\\right| / \\left|\\beta_{\\text{eff}}^{(\\text{ref})}\\right|$ and $E_{\\Lambda} = \\left|\\Lambda^{(N)} - \\Lambda^{(\\text{ref})}\\right| / \\left|\\Lambda^{(\\text{ref})}\\right|$, where the reference is computed on a very fine grid with $N_{\\text{ref}}$ cells.\n\nAssumptions and units:\n\n- Consider two energy groups, indexed by $g \\in \\{1,2\\}$.\n- Use one-dimensional slab geometry with $x \\in [0,L]$, $L$ in centimeters, macroscopic cross sections in $\\text{cm}^{-1}$, speeds in $\\text{cm}/\\text{s}$, and compute $\\Lambda$ in seconds. The effective delayed neutron fraction $\\beta_{\\text{eff}}$ is dimensionless.\n- The shape functions are provided directly as functions of $x$ and energy group $g$; there is no need to solve any transport or diffusion equation.\n- The neutron yields $\\nu_g$ and delayed fractions $\\beta_g$ are constants.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each test case should itself be a list of four floats in the order $[\\beta_{\\text{eff}}, \\Lambda, E_{\\beta}, E_{\\Lambda}]$, with each float rounded to eight decimal places. Thus, the overall output should look like $[[b_1,\\lambda_1,e_{b,1},e_{\\lambda,1}],[b_2,\\lambda_2,e_{b,2},e_{\\lambda,2}],\\dots]$.\n\nTest suite:\n\nFor all cases, use a fine reference discretization with $N_{\\text{ref}} = 50000$.\n\nCase A (smooth shape, uniform material):\n\n- Domain length $L = 100.0$.\n- Group speeds: $v_1 = 2.2\\times 10^{5}$, $v_2 = 1.0\\times 10^{7}$.\n- Neutron yields: $\\nu_1 = 2.43$, $\\nu_2 = 2.43$.\n- Macroscopic fission cross sections: $\\Sigma_{f,1}(x) = 5.0\\times 10^{-3}$, $\\Sigma_{f,2}(x) = 1.0\\times 10^{-3}$.\n- Delayed fractions: $\\beta_1 = 4.0\\times 10^{-3}$, $\\beta_2 = 2.5\\times 10^{-3}$.\n- Shapes: $\\psi_1(x) = \\sin\\left(\\pi x/L\\right)$, $\\psi_2(x) = 0.6\\,\\sin\\left(\\pi x/L\\right)$.\n- Coarse discretization for evaluation: $N = 20$.\n\nCase B (material discontinuity, smooth shape):\n\n- Domain length $L = 100.0$.\n- Group speeds: $v_1 = 2.2\\times 10^{5}$, $v_2 = 1.0\\times 10^{7}$.\n- Neutron yields: $\\nu_1 = 2.43$, $\\nu_2 = 2.43$.\n- Macroscopic fission cross sections:\n  - $\\Sigma_{f,1}(x) = 3.0\\times 10^{-3}$ for $x < L/2$, and $\\Sigma_{f,1}(x) = 7.0\\times 10^{-3}$ for $x \\ge L/2$.\n  - $\\Sigma_{f,2}(x) = 8.0\\times 10^{-4}$ for $x < L/2$, and $\\Sigma_{f,2}(x) = 1.2\\times 10^{-3}$ for $x \\ge L/2$.\n- Delayed fractions: $\\beta_1 = 4.0\\times 10^{-3}$, $\\beta_2 = 2.5\\times 10^{-3}$.\n- Shapes: $\\psi_1(x) = \\sin\\left(\\pi x/L\\right)$, $\\psi_2(x) = 0.6\\,\\sin\\left(\\pi x/L\\right)$.\n- Coarse discretization for evaluation: $N = 40$.\n\nCase C (steeper shape, uniform material):\n\n- Domain length $L = 100.0$.\n- Group speeds: $v_1 = 2.2\\times 10^{5}$, $v_2 = 1.0\\times 10^{7}$.\n- Neutron yields: $\\nu_1 = 2.43$, $\\nu_2 = 2.43$.\n- Macroscopic fission cross sections: $\\Sigma_{f,1}(x) = 4.0\\times 10^{-3}$, $\\Sigma_{f,2}(x) = 1.5\\times 10^{-3}$.\n- Delayed fractions: $\\beta_1 = 4.0\\times 10^{-3}$, $\\beta_2 = 2.5\\times 10^{-3}$.\n- Shapes: $\\psi_1(x) = \\sin\\left(\\pi x/L\\right) + 0.2\\,\\sin\\left(3\\pi x/L\\right)$, $\\psi_2(x) = 0.5\\,\\sin\\left(\\pi x/L\\right) + 0.1\\,\\sin\\left(3\\pi x/L\\right)$.\n- Coarse discretization for evaluation: $N = 30$.\n\nImplementation details and output:\n\n- Use the midpoint-rule quadrature over the specified $N$ for the coarse estimate and $N_{\\text{ref}}$ for the reference estimate in each case.\n- Treat the shapes $\\psi_g(x)$ as dimensionless functions. You do not need any amplitude normalization, but your derivation must justify why the amplitude cancels in the required ratios.\n- Your program should produce exactly one line: a single bracketed list with three inner lists, one for each case, each containing four floats $[\\beta_{\\text{eff}}, \\Lambda, E_{\\beta}, E_{\\Lambda}]$, rounded to eight decimal places, and with no additional text.",
            "solution": "The problem is valid as it is scientifically grounded in established principles of nuclear reactor physics, is well-posed, objective, and contains all necessary information for a unique solution. The tasks require the derivation and numerical implementation of reactor kinetics parameters, which is a standard and verifiable procedure.\n\n### Part 1: Derivation of Estimators\n\nThe goal is to derive expressions for the effective delayed neutron fraction, $\\beta_{\\text{eff}}$, and the prompt neutron generation time, $\\Lambda$, using the provided fundamental definitions and the quasi-static flux factorization. The derivation must not use adjoint weighting.\n\n**1.1. Effective Delayed Neutron Fraction ($\\beta_{\\text{eff}}$)**\n\nThe effective delayed neutron fraction, $\\beta_{\\text{eff}}$, is defined as the ratio of the total delayed fission neutron production rate to the total (prompt plus delayed) fission neutron production rate.\n\nThe total fission production rate, $F(t)$, is given by:\n$$F(t) = \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$$\nwhere $\\nu_g$ is the number of neutrons produced per fission induced by a neutron in energy group $g$, $\\Sigma_{f,g}(\\mathbf{r})$ is the macroscopic fission cross section, and $\\phi_g(\\mathbf{r},t)$ is the neutron flux. The integral is over the reactor volume $V$.\n\nThe delayed fission production rate, $F_d(t)$, is given by:\n$$F_d(t) = \\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$$\nwhere $\\beta_g$ is the fraction of fission neutrons that are delayed for fissions induced by neutrons in group $g$.\n\nBy definition, $\\beta_{\\text{eff}}(t)$ is the ratio of these two rates:\n$$\\beta_{\\text{eff}}(t) = \\frac{F_d(t)}{F(t)} = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}$$\n\nWe introduce the quasi-static flux factorization, $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r},t)$, where $A(t)$ is a time-dependent amplitude and $\\psi_g(\\mathbf{r},t)$ is a time-dependent shape function. A key assumption of the quasi-static method is that the shape function $\\psi_g$ varies slowly with time, allowing us to treat it as constant for the calculation of integral parameters at a specific time instant. The problem provides time-independent shapes, $\\psi_g(\\mathbf{r})$, which is consistent with this assumption.\n\nSubstituting the factorization into the expression for $\\beta_{\\text{eff}}$:\n$$\\beta_{\\text{eff}}(t) = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) A(t)\\,\\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) A(t)\\,\\psi_g(\\mathbf{r}) \\, dV}$$\nSince the amplitude $A(t)$ is independent of space ($\\mathbf{r}$) and energy group ($g$), it can be factored out of the integrals and sums in both the numerator and the denominator:\n$$\\beta_{\\text{eff}}(t) = \\frac{A(t) \\left( \\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}{A(t) \\left( \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}$$\nThe amplitude $A(t)$ cancels, provided $A(t) \\ne 0$ and the total fission rate is non-zero. This cancellation justifies why the result is independent of the flux amplitude and any arbitrary normalization of the shape function $\\psi_g$. The resulting expression depends only on the shape and the material properties:\n$$\\beta_{\\text{eff}} = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}$$\n\n**1.2. Prompt Neutron Generation Time ($\\Lambda$)**\n\nThe prompt neutron generation time, $\\Lambda$, is defined as the ratio of the total neutron population in the reactor to the total fission neutron production rate.\n\nThe total neutron population, $N_{\\text{total}}(t)$, is the volume integral of the total neutron density. The neutron density in group $g$ is $n_g(\\mathbf{r},t) = \\phi_g(\\mathbf{r},t)/v_g$, where $v_g$ is the average neutron speed for group $g$.\n$$N_{\\text{total}}(t) = \\sum_{g} \\int_V n_g(\\mathbf{r},t) \\, dV = \\sum_{g} \\int_V \\frac{\\phi_g(\\mathbf{r},t)}{v_g} \\, dV$$\nThe total fission production rate, $F(t)$, is the same as defined previously.\n\nBy definition, $\\Lambda(t)$ is:\n$$\\Lambda(t) = \\frac{N_{\\text{total}}(t)}{F(t)} = \\frac{\\sum_{g} \\int_V \\frac{\\phi_g(\\mathbf{r},t)}{v_g} \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}$$\nSubstituting the factorization $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r})$ and again factoring out the amplitude $A(t)$:\n$$\\Lambda(t) = \\frac{A(t) \\left( \\sum_{g} \\frac{1}{v_g} \\int_V \\psi_g(\\mathbf{r}) \\, dV \\right)}{A(t) \\left( \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}$$\nThe amplitude $A(t)$ cancels, yielding the final expression for the prompt neutron generation time:\n$$\\Lambda = \\frac{\\sum_{g} \\frac{1}{v_g} \\int_V \\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}$$\n\n### Part 2: Numerical Implementation in 1D Slab Geometry\n\nFor a one-dimensional slab of length $L$, the volume differential $dV$ is replaced by the line differential $dx$, assuming a unit cross-sectional area. The integrals are evaluated over the domain $x \\in [0, L]$.\n\nThe expressions become:\n$$\\beta_{\\text{eff}} = \\frac{\\sum_{g} \\int_0^L \\beta_g \\, \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}{\\sum_{g} \\int_0^L \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}$$\n$$\\Lambda = \\frac{\\sum_{g} \\frac{1}{v_g} \\int_0^L \\psi_g(x) \\, dx}{\\sum_{g} \\int_0^L \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}$$\n\nWe approximate the integrals using the midpoint rule quadrature on a uniform grid of $N$ cells. The cell width is $\\Delta x = L/N$, and the cell midpoints are $x_i = (i + 1/2)\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$. An integral $\\int_0^L f(x) \\, dx$ is approximated as:\n$$\\int_0^L f(x) \\, dx \\approx \\sum_{i=0}^{N-1} f(x_i) \\Delta x$$\n\nLet us define the following sums over the grid points:\n$$S_{f,g} = \\sum_{i=0}^{N-1} \\Sigma_{f,g}(x_i) \\psi_g(x_i)$$\n$$S_{\\psi,g} = \\sum_{i=0}^{N-1} \\psi_g(x_i)$$\n\nThe integrals are then approximated as:\n$$\\int_0^L \\Sigma_{f,g}(x) \\psi_g(x) \\, dx \\approx S_{f,g} \\Delta x$$\n$$\\int_0^L \\psi_g(x) \\, dx \\approx S_{\\psi,g} \\Delta x$$\n\nSubstituting these approximations into the expressions for $\\beta_{\\text{eff}}$ and $\\Lambda$:\n$$\\beta_{\\text{eff}}^{(N)} = \\frac{\\sum_{g} \\beta_g \\, \\nu_g (S_{f,g} \\Delta x)}{\\sum_{g} \\nu_g (S_{f,g} \\Delta x)} = \\frac{\\Delta x \\sum_{g} \\beta_g \\nu_g S_{f,g}}{\\Delta x \\sum_{g} \\nu_g S_{f,g}} = \\frac{\\sum_{g} \\beta_g \\nu_g S_{f,g}}{\\sum_{g} \\nu_g S_{f,g}}$$\n$$\\Lambda^{(N)} = \\frac{\\sum_{g} \\frac{1}{v_g} (S_{\\psi,g} \\Delta x)}{\\sum_{g} \\nu_g (S_{f,g} \\Delta x)} = \\frac{\\Delta x \\sum_{g} \\frac{1}{v_g} S_{\\psi,g}}{\\Delta x \\sum_{g} \\nu_g S_{f,g}} = \\frac{\\sum_{g} \\frac{1}{v_g} S_{\\psi,g}}{\\sum_{g} \\nu_g S_{f,g}}$$\nThe common factor $\\Delta x = L/N$ cancels in both expressions. The numerical estimators are thus computed by evaluating the integrands at the cell midpoints and summing them up, without needing to multiply by the cell width.\n\n### Part 3: Discretization Sensitivity\n\nThe relative discretization sensitivity for a quantity $Q$ (either $\\beta_{\\text{eff}}$ or $\\Lambda$) is calculated as:\n$$E_Q = \\frac{\\left|Q^{(N)} - Q^{(\\text{ref})}\\right|}{\\left|Q^{(\\text{ref})}\\right|}$$\nwhere $Q^{(N)}$ is the value computed on the coarse grid with $N$ cells, and $Q^{(\\text{ref})}$ is the reference value computed on a very fine grid with $N_{\\text{ref}}$ cells, which serves as an approximation to the true continuous value.\n\nThe program will implement these formulas for each test case, calculate the quantities for both the coarse ($N$) and reference ($N_{\\text{ref}}$) discretizations, and then compute the sensitivities before printing the formatted output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_kinetics(L, v, nu, beta, sigma_f_funcs, psi_funcs, N):\n    \"\"\"\n    Computes effective delayed neutron fraction and prompt neutron generation time.\n\n    Args:\n        L (float): Domain length in cm.\n        v (tuple): Group speeds (v1, v2) in cm/s.\n        nu (tuple): Neutrons per fission (nu1, nu2).\n        beta (tuple): Delayed neutron fractions (beta1, beta2).\n        sigma_f_funcs (tuple): Functions for macroscopic fission cross sections.\n        psi_funcs (tuple): Functions for shape functions.\n        N (int): Number of discretization cells.\n\n    Returns:\n        tuple: (beta_eff, Lambda)\n    \"\"\"\n    v1, v2 = v\n    nu1, nu2 = nu\n    beta1, beta2 = beta\n    sigma_f1_func, sigma_f2_func = sigma_f_funcs\n    psi1_func, psi2_func = psi_funcs\n\n    # Create grid of cell midpoints\n    dx = L / N\n    x_midpoints = (np.arange(N) + 0.5) * dx\n\n    # Evaluate shapes and cross sections at midpoints\n    psi1_vals = psi1_func(x_midpoints)\n    psi2_vals = psi2_func(x_midpoints)\n    sigma_f1_vals = sigma_f1_func(x_midpoints)\n    sigma_f2_vals = sigma_f2_func(x_midpoints)\n\n    # Calculate sums S_f,g and S_psi,g\n    S_f1 = np.sum(sigma_f1_vals * psi1_vals)\n    S_f2 = np.sum(sigma_f2_vals * psi2_vals)\n    S_psi1 = np.sum(psi1_vals)\n    S_psi2 = np.sum(psi2_vals)\n\n    # Calculate numerators and the common denominator for beta_eff and Lambda\n    # Denominator: total fission source rate integral (without amplitude)\n    I_den = nu1 * S_f1 + nu2 * S_f2\n    \n    # Numerator for beta_eff: delayed fission source rate integral\n    I_beta_num = beta1 * nu1 * S_f1 + beta2 * nu2 * S_f2\n    \n    # Numerator for Lambda: total neutron population integral (flux/v)\n    I_Lambda_num = (1.0 / v1) * S_psi1 + (1.0 / v2) * S_psi2\n    \n    if I_den == 0:\n        return (np.nan, np.nan)\n\n    # Compute beta_eff and Lambda\n    beta_eff = I_beta_num / I_den\n    Lambda = I_Lambda_num / I_den\n\n    return beta_eff, Lambda\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    N_ref = 50000\n\n    test_cases = [\n        # Case A: Smooth shape, uniform material\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: 5.0e-3,\n                lambda x: 1.0e-3\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0),\n                lambda x: 0.6 * np.sin(np.pi * x / 100.0)\n            ),\n            \"N\": 20\n        },\n        # Case B: Material discontinuity, smooth shape\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: np.where(x < 50.0, 3.0e-3, 7.0e-3),\n                lambda x: np.where(x < 50.0, 8.0e-4, 1.2e-3)\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0),\n                lambda x: 0.6 * np.sin(np.pi * x / 100.0)\n            ),\n            \"N\": 40\n        },\n        # Case C: Steeper shape, uniform material\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: 4.0e-3,\n                lambda x: 1.5e-3\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0) + 0.2 * np.sin(3 * np.pi * x / 100.0),\n                lambda x: 0.5 * np.sin(np.pi * x / 100.0) + 0.1 * np.sin(3 * np.pi * x / 100.0)\n            ),\n            \"N\": 30\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Reference calculation with a very fine grid\n        beta_ref, Lambda_ref = compute_kinetics(\n            case[\"L\"], case[\"v\"], case[\"nu\"], case[\"beta\"],\n            case[\"sigma_f_funcs\"], case[\"psi_funcs\"], N_ref\n        )\n\n        # Coarse calculation with the specified grid size N\n        beta_n, Lambda_n = compute_kinetics(\n            case[\"L\"], case[\"v\"], case[\"nu\"], case[\"beta\"],\n            case[\"sigma_f_funcs\"], case[\"psi_funcs\"], case[\"N\"]\n        )\n\n        # Calculate relative discretization sensitivities\n        E_beta = np.abs(beta_n - beta_ref) / np.abs(beta_ref)\n        E_Lambda = np.abs(Lambda_n - Lambda_ref) / np.abs(Lambda_ref)\n\n        case_results = [\n            round(beta_n, 8),\n            round(Lambda_n, 8),\n            round(E_beta, 8),\n            round(E_Lambda, 8)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists\n    results_str_list = []\n    for res_list in all_results:\n        results_str_list.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "The predictor-corrector cycle involves updating not just the flux amplitude but also the delayed neutron precursor concentrations, which act as the memory of the system's fission history. This practice problem focuses on the precursor balance equation, demonstrating how a shape change between the predictor and corrector steps directly impacts the fission source term that produces new precursors. It offers a detailed look at the inner mechanics of a single time step in the PCQS algorithm .",
            "id": "4242155",
            "problem": "Consider a homogeneous thermal reactor represented by two spatially uniform regions, region $A$ and region $B$, each of equal volume $V_A = V_B = 1$ (arbitrary volume units). The fission production coefficients are spatially dependent and given by $\\nu \\Sigma_{f,A} = 2$ and $\\nu \\Sigma_{f,B} = 1$ (arbitrary consistent units). Assume the Predictor–Corrector Quasi-Static (PCQS) method: the neutron flux is factorized as $\\phi(\\mathbf{r}, t) = P(t) S(\\mathbf{r}, t)$, where $P(t)$ is the global amplitude and $S(\\mathbf{r}, t)$ is the shape function. The shape function is normalized such that $\\int_{V} S(\\mathbf{r}, t) \\, dV = 1$.\n\nThe total delayed neutron precursor concentration for a single family $i$, denoted $N_i(t) = \\int_{V} C_i(\\mathbf{r}, t) \\, dV$, obeys the space-integrated precursor balance derived from the delayed neutron source and decay:\n$$\n\\frac{d N_i(t)}{d t} = \\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV - \\lambda_i N_i(t),\n$$\nwhere $\\beta_i$ is the (dimensionless) delayed neutron fraction for family $i$ and $\\lambda_i$ is its decay constant.\n\nOver a single coarse PCQS step of duration $\\Delta T = 0.5 \\mathrm{s}$, the global amplitude increases from $P(t) = P_0 = 1.0$ to $P(t + \\Delta T) = P_1 = 1.2$. The shape is updated from a predictor shape at the beginning of the step,\n$$\nS(\\mathbf{r}, t): \\quad s_A^{p,0} = 0.55, \\quad s_B^{p,0} = 0.45,\n$$\nto a corrector shape at the end of the step,\n$$\nS(\\mathbf{r}, t+\\Delta T): \\quad s_A^{c,1} = 0.60, \\quad s_B^{c,1} = 0.40,\n$$\nwith the shape normalization $\\int_{V} S(\\mathbf{r}, t) \\, dV = s_A + s_B = 1$ at each time.\n\nLet the initial precursor concentration be $N_i(t) = N_0 = 2.000 \\times 10^{-2}$ (normalized concentration units), the delayed neutron fraction be $\\beta_i = 1.00 \\times 10^{-3}$, and the decay constant be $\\lambda_i = 8.0 \\times 10^{-2} \\mathrm{s}^{-1}$.\n\nUsing the PCQS predictor–corrector update, approximate the source term $\\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV$ as varying linearly over the coarse step between its predictor value at $t$ and its corrector value at $t+\\Delta T$, and use the exact integrating factor solution of the precursor ordinary differential equation to compute $N_i(t+\\Delta T)$. Explicitly evaluate the shape-weighted fission production integral at the beginning and end of the step using the given $s_A$ and $s_B$.\n\nRound your final answer for $N_i(t+\\Delta T)$ to five significant figures. Express the final concentration in the same normalized concentration units as $N_i(t)$.",
            "solution": "The problem is validated as scientifically grounded, well-posed, and objective. It is a standard problem in nuclear reactor kinetics using the Predictor-Corrector Quasi-Static (PCQS) method. All provided data are consistent and sufficient for a unique solution.\n\nThe problem requires the calculation of the total delayed neutron precursor concentration $N_i(t+\\Delta T)$ for a single family $i$ at the end of a time step of duration $\\Delta T$. The evolution of $N_i(t)$ is governed by the ordinary differential equation (ODE):\n$$\n\\frac{d N_i(t)}{d t} = Q_i(t) - \\lambda_i N_i(t)\n$$\nwhere $Q_i(t)$ is the source term, given by:\n$$\nQ_i(t) = \\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV\n$$\nThe problem is defined on the time interval $[t_0, t_0+\\Delta T]$. For simplicity, we set $t_0=0$, so the interval is $[0, \\Delta T]$.\n\nFirst, we must evaluate the source term $Q_i(t)$ at the beginning ($t=0$) and end ($t=\\Delta T$) of the time step. The integral represents the shape-weighted fission production rate, which we denote as $F(t) = \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV$. Since the reactor consists of two homogeneous regions, $A$ and $B$, this integral becomes:\n$$\nF(t) = \\int_{V_A} \\nu \\Sigma_{f,A} S(\\mathbf{r}, t) \\, dV + \\int_{V_B} \\nu \\Sigma_{f,B} S(\\mathbf{r}, t) \\, dV\n$$\nThe problem states that the shape function $S(\\mathbf{r},t)$ is spatially uniform within each region, having values $s_A(t)$ and $s_B(t)$ respectively. Given $V_A = V_B = 1$ (arbitrary volume unit), the integral simplifies to:\n$$\nF(t) = (\\nu \\Sigma_{f,A}) s_A(t) V_A + (\\nu \\Sigma_{f,B}) s_B(t) V_B = (\\nu \\Sigma_{f,A}) s_A(t) + (\\nu \\Sigma_{f,B}) s_B(t)\n$$\n\nAt the beginning of the step ($t=0$), we use the predictor shape and initial amplitude:\n- $\\nu \\Sigma_{f,A} = 2$, $\\nu \\Sigma_{f,B} = 1$\n- $s_A(0) = s_A^{p,0} = 0.55$, $s_B(0) = s_B^{p,0} = 0.45$\n- $P(0) = P_0 = 1.0$\n- $\\beta_i = 1.00 \\times 10^{-3} = 0.001$\n\nThe shape-weighted fission production at $t=0$ is:\n$$\nF_0 = F(0) = (2)(0.55) + (1)(0.45) = 1.10 + 0.45 = 1.55\n$$\nThe source term at $t=0$ is:\n$$\nQ_{i,0} = \\beta_i P_0 F_0 = (0.001)(1.0)(1.55) = 0.00155\n$$\n\nAt the end of the step ($t=\\Delta T$), we use the corrector shape and final amplitude:\n- $s_A(\\Delta T) = s_A^{c,1} = 0.60$, $s_B(\\Delta T) = s_B^{c,1} = 0.40$\n- $P(\\Delta T) = P_1 = 1.2$\n\nThe shape-weighted fission production at $t=\\Delta T$ is:\n$$\nF_1 = F(\\Delta T) = (2)(0.60) + (1)(0.40) = 1.20 + 0.40 = 1.60\n$$\nThe source term at $t=\\Delta T$ is:\n$$\nQ_{i,1} = \\beta_i P_1 F_1 = (0.001)(1.2)(1.60) = 0.00192\n$$\n\nThe problem specifies approximating the source term $Q_i(t')$ as varying linearly over the time step $t' \\in [0, \\Delta T]$:\n$$\nQ_i(t') = Q_{i,0} + \\frac{Q_{i,1} - Q_{i,0}}{\\Delta T} t'\n$$\nThe ODE is $\\frac{d N_i}{dt'} + \\lambda_i N_i = Q_i(t')$. Using an integrating factor $\\exp(\\lambda_i t')$, the exact solution for $N_i(\\Delta T)$ is:\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + \\exp(-\\lambda_i \\Delta T) \\int_{0}^{\\Delta T} Q_i(t') \\exp(\\lambda_i t') dt'\n$$\nThe integral part represents the contribution from the source term. Let's evaluate this integral with the linear approximation for $Q_i(t')$. A convenient change of variables for the integral is $u = \\Delta T - t'$, which leads to the solution form:\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + \\int_{0}^{\\Delta T} Q_i(\\Delta T - u) \\exp(-\\lambda_i u) du\n$$\nThe linear source term in terms of $u$ is $Q_i(\\Delta T - u) = Q_{i,1} - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T}u$.\nThe source contribution is:\n$$\n\\int_0^{\\Delta T} \\left( Q_{i,1} - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T} u \\right) \\exp(-\\lambda_i u) du = Q_{i,1} \\int_0^{\\Delta T} \\exp(-\\lambda_i u) du - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T} \\int_0^{\\Delta T} u \\exp(-\\lambda_i u) du\n$$\nEvaluating the two integrals gives:\n$$\n\\int_0^{\\Delta T} \\exp(-\\lambda_i u) du = \\frac{1 - \\exp(-\\lambda_i \\Delta T)}{\\lambda_i}\n$$\n$$\n\\int_0^{\\Delta T} u \\exp(-\\lambda_i u) du = \\frac{1}{\\lambda_i^2} - \\frac{\\Delta T \\exp(-\\lambda_i \\Delta T)}{\\lambda_i} - \\frac{\\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2}\n$$\nCombining these results and grouping terms by $Q_{i,0}$ and $Q_{i,1}$, we obtain the analytical solution:\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + Q_{i,0} \\left( \\frac{1 - \\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2 \\Delta T} - \\frac{\\exp(-\\lambda_i \\Delta T)}{\\lambda_i} \\right) + Q_{i,1} \\left( \\frac{\\lambda_i \\Delta T - 1 + \\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2 \\Delta T} \\right)\n$$\nNow we substitute the numerical values:\n- Initial concentration: $N_i(0) = N_0 = 2.000 \\times 10^{-2} = 0.02$\n- Decay constant: $\\lambda_i = 8.0 \\times 10^{-2} \\ \\mathrm{s}^{-1} = 0.08 \\ \\mathrm{s}^{-1}$\n- Time step: $\\Delta T = 0.5 \\ \\mathrm{s}$\n- $Q_{i,0} = 0.00155$\n- $Q_{i,1} = 0.00192$\n\nWe compute the terms in the solution:\n- $\\lambda_i \\Delta T = (0.08)(0.5) = 0.04$\n- $\\exp(-\\lambda_i \\Delta T) = \\exp(-0.04) \\approx 0.960789439$\n- $\\lambda_i^2 \\Delta T = (0.08)^2 (0.5) = (0.0064)(0.5) = 0.0032$\n\nThe coefficient for $Q_{i,0}$ is:\n$$\n\\frac{1 - \\exp(-0.04)}{(0.0032)} - \\frac{\\exp(-0.04)}{0.08} = \\frac{1 - 0.960789439}{0.0032} - \\frac{0.960789439}{0.08} \\approx 12.253300 - 12.009868 = 0.243432\n$$\nThe coefficient for $Q_{i,1}$ is:\n$$\n\\frac{0.04 - 1 + \\exp(-0.04)}{0.0032} = \\frac{0.04 - 1 + 0.960789439}{0.0032} = \\frac{0.000789439}{0.0032} \\approx 0.2466998\n$$\nNow, we calculate $N_i(\\Delta T)$:\n$$\nN_i(\\Delta T) = (0.02) \\exp(-0.04) + (0.00155)(0.243432) + (0.00192)(0.2466998)\n$$\n$$\nN_i(\\Delta T) \\approx (0.02)(0.960789439) + 0.0003773196 + 0.0004736636\n$$\n$$\nN_i(\\Delta T) \\approx 0.0192157888 + 0.0003773196 + 0.0004736636\n$$\n$$\nN_i(\\Delta T) \\approx 0.020066772\n$$\nRounding to five significant figures as requested:\n$$\nN_i(t+\\Delta T) \\approx 0.020067\n$$",
            "answer": "$$\\boxed{0.020067}$$"
        },
        {
            "introduction": "The primary advantage of the quasi-static method over simpler point kinetics is its ability to account for changes in the spatial flux distribution during a transient. This exercise synthesizes the core concepts by having you build and compare two models: a PCQS model where shape changes affect reactivity and a pure point kinetics model with a fixed shape. By simulating a full transient, you will directly observe and quantify the impact of spatial flux redistribution, revealing why more sophisticated methods like PCQS are essential for accurate reactor simulation .",
            "id": "4242119",
            "problem": "Consider a one-dimensional, homogeneous, thermal nuclear reactor represented as a slab of length $L$, with vacuum boundary conditions at $x=0$ and $x=L$. The reactor is modeled using the one-speed neutron balance with a single delayed neutron group, and the neutron population is expressed through an amplitude–shape factorization, where the neutron flux is written as $\\phi(x,t) = A(t) S(x,t)$, with $S(x,t)$ normalized such that $\\int_0^L S(x,t)\\,dx = 1$ at all times. The reactor is homogeneous, meaning material properties do not vary spatially, but external reactivity insertions are permitted to be spatially nonuniform and time-dependent. The physical time unit must be seconds, and spatial distances must be centimeters.\n\nThe fundamental base for the dynamics shall be:\n- The point kinetics model for reactor amplitude with one delayed neutron group, expressed in terms of the amplitude $A(t)$ and the delayed neutron precursor amplitude $C(t)$:\n  - $A(t)$ evolves due to net effective reactivity and delayed neutron source.\n  - $C(t)$ evolves due to production from $A(t)$ and decay with constant $\\lambda_d$.\n- Shape evolution under nonuniform reactivity drives deviations from the fundamental spatial mode, with deviations captured by a first harmonic coefficient $b_1(t)$ in a modal expansion.\n\nYou will implement two models:\n- A predictor–corrector quasi-static method (PCQS), where the amplitude $A(t)$ is advanced using point kinetics with a time-dependent effective reactivity that includes shape corrections, and the shape deviation coefficient $b_1(t)$ is advanced via a driven, damped ordinary differential equation representing first-order response of the first harmonic shape under nonuniform reactivity.\n- A pure point kinetics model (PK), where the amplitude $A_{\\mathrm{PK}}(t)$ is advanced with the same point kinetics equations, but the flux shape is assumed fixed and equal to the fundamental mode at all times, and shape correction terms are neglected.\n\nDefinitions and core constructs to use:\n- Let the fundamental mode be $S_0(x) = \\sin\\left(\\frac{\\pi x}{L}\\right)$ and the first harmonic be $S_1(x) = \\sin\\left(\\frac{2\\pi x}{L}\\right)$, both satisfying vacuum boundary conditions.\n- Let the shape be approximated as $S(x,t) = \\tilde{S}(x,t)/\\int_0^L \\tilde{S}(x,t)\\,dx$ with $\\tilde{S}(x,t) = S_0(x) + b_1(t) S_1(x)$, enforcing $\\int_0^L S(x,t)\\,dx = 1$.\n- External reactivity is represented by a spatially and temporally varying reactivity density $r_{\\mathrm{ext}}(x,t)$ (dimensionless), producing an average effective reactivity through shape-weighted integration:\n  - For PCQS: $\\rho_{\\mathrm{avg}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S(x,t)\\,dx$.\n  - For PK: $\\rho_{\\mathrm{avg,PK}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_0(x)\\,dx$.\n- The PCQS model uses a shape correction to reactivity that penalizes leakage increase due to shape distortion, approximated as a quadratic function of the first harmonic amplitude:\n  - $\\rho_{\\mathrm{shape}}(t) = -\\eta\\, b_1(t)^2$, with $\\eta > 0$ a constant sensitivity parameter.\n- The total effective reactivity used in the PCQS amplitude is then $\\rho_{\\mathrm{eff}}(t) = \\rho_{\\mathrm{avg}}(t) + \\rho_{\\mathrm{shape}}(t)$.\n- The PCQS amplitude–precursor system is:\n  - $\\dfrac{dA}{dt} = \\left(\\dfrac{\\rho_{\\mathrm{eff}}(t) - \\beta}{\\Lambda}\\right) A(t) + \\lambda_d\\, C(t)$,\n  - $\\dfrac{dC}{dt} = \\left(\\dfrac{\\beta}{\\Lambda}\\right) A(t) - \\lambda_d\\, C(t)$,\n  where $\\beta$ is the total delayed neutron fraction and $\\Lambda$ is the prompt neutron generation time.\n- The PK amplitude–precursor system is identical, but uses $\\rho_{\\mathrm{avg,PK}}(t)$ in place of $\\rho_{\\mathrm{eff}}(t)$ and assumes $b_1(t)\\equiv 0$.\n- The first harmonic coefficient $b_1(t)$ in PCQS obeys a driven, damped dynamics that captures excitation by nonuniform reactivity and relaxation due to modal decay:\n  - $\\dfrac{db_1}{dt} = -\\gamma\\, b_1(t) + \\chi\\, \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_1(x)\\,dx$,\n  where $\\gamma > 0$ is the relaxation rate of the first harmonic and $\\chi > 0$ is the coupling gain from nonuniform reactivity to the first harmonic.\n\nNumerical integration method requirements:\n- Use a predictor–corrector (trapezoidal) time stepping for the PCQS system of $A(t)$, $C(t)$, and $b_1(t)$.\n- Use a matching time stepping scheme for the PK system of $A_{\\mathrm{PK}}(t)$ and $C_{\\mathrm{PK}}(t)$.\n- Use a uniform spatial grid to evaluate the spatial integrals via numerical quadrature (e.g., the trapezoidal rule).\n- Initialize at $t=0$ with $A(0)=1$, $b_1(0)=0$, and $C(0) = \\dfrac{\\beta}{\\Lambda\\, \\lambda_d} A(0)$ to be consistent with zero net reactivity steady state.\n\nPhysical parameters to use:\n- $L = 100\\,\\mathrm{cm}$,\n- $\\beta = 0.0065$,\n- $\\Lambda = 1.0\\times 10^{-4}\\,\\mathrm{s}$,\n- $\\lambda_d = 0.08\\,\\mathrm{s}^{-1}$,\n- $\\gamma = 20.0\\,\\mathrm{s}^{-1}$,\n- $\\chi = 1.0$,\n- $\\eta = 0.2$.\n\nTest suite specification:\n- Spatial grid: use $N_x = 200$ points uniformly spaced on $[0,L]$.\n- Time stepping: use $\\Delta t = 0.001\\,\\mathrm{s}$.\n- Three transient cases provide coverage of different excitation regimes:\n  1. Case $1$ (happy path, nonuniform ramp): $r_{\\mathrm{ext}}(x,t) = r_{\\max} \\, \\mathrm{ramp}(t) \\, \\dfrac{\\exp(-x/\\ell)}{\\max_{x\\in[0,L]} \\exp(-x/\\ell)}$, with $r_{\\max} = 0.003$, $\\ell = L/5$, and $\\mathrm{ramp}(t) = \\min(t/T_r,1)$ with $T_r = 1.0\\,\\mathrm{s}$. Simulate to final time $T=3.0\\,\\mathrm{s}$.\n  2. Case $2$ (boundary condition check, uniform step): $r_{\\mathrm{ext}}(x,t) = r_0$, with $r_0 = 0.003$ constant in space and time for $0\\le t\\le 3.0\\,\\mathrm{s}$, and $T=3.0\\,\\mathrm{s}$.\n  3. Case $3$ (edge case, short pulse near boundary): $r_{\\mathrm{ext}}(x,t) = r_p\\, \\mathbf{1}_{[0,T_p]}(t)\\, \\dfrac{\\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}{\\max_{x\\in[0,L]} \\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}$, with $r_p = 0.01$, $T_p = 0.2\\,\\mathrm{s}$, $\\sigma = L/20$, and $T=1.0\\,\\mathrm{s}$.\n\nFor each case, compute:\n- The maximum absolute difference in amplitude trajectories over the simulation time window, $\\max_{t\\in[0,T]} |A(t) - A_{\\mathrm{PK}}(t)|$, reported as a dimensionless float.\n- The time integral of the absolute shape correction reactivity, $\\int_0^T |\\rho_{\\mathrm{shape}}(t)|\\,dt$, reported in $\\mathrm{s}$ with reactivity being dimensionless.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, each sublist corresponding to one case and ordered as $[\\text{max\\_abs\\_diff}, \\text{shape\\_corr\\_integral}]$. For example, the output format must be exactly like $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$, where all $a_i$ and $b_i$ are floats.",
            "solution": "The user has requested the implementation and comparison of two reactor dynamics models: a predictor-corrector quasi-static (PCQS) model and a pure point kinetics (PK) model. The problem is to be solved for three distinct transient scenarios.\n\n### Step 1: Extract Givens\n\n**Reactor Model:**\n- One-dimensional, homogeneous slab reactor of length $L$.\n- Vacuum boundary conditions at $x=0$ and $x=L$.\n- One-speed neutron balance with one delayed neutron group.\n- Flux factorization: $\\phi(x,t) = A(t) S(x,t)$.\n- Shape normalization: $\\int_0^L S(x,t)\\,dx = 1$ for all $t$.\n\n**Mathematical Formulation:**\n- **Shape Expansion:**\n    - Fundamental mode: $S_0(x) = \\sin\\left(\\frac{\\pi x}{L}\\right)$.\n    - First harmonic: $S_1(x) = \\sin\\left(\\frac{2\\pi x}{L}\\right)$.\n    - Shape approximation: $S(x,t) = \\tilde{S}(x,t)/\\int_0^L \\tilde{S}(x,t)\\,dx$, with $\\tilde{S}(x,t) = S_0(x) + b_1(t) S_1(x)$.\n- **Reactivity:**\n    - External reactivity density: $r_{\\mathrm{ext}}(x,t)$.\n    - PCQS average reactivity: $\\rho_{\\mathrm{avg}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S(x,t)\\,dx$.\n    - PK average reactivity: $\\rho_{\\mathrm{avg,PK}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_0(x)\\,dx$.\n    - PCQS shape reactivity correction: $\\rho_{\\mathrm{shape}}(t) = -\\eta\\, b_1(t)^2$.\n    - PCQS total effective reactivity: $\\rho_{\\mathrm{eff}}(t) = \\rho_{\\mathrm{avg}}(t) + \\rho_{\\mathrm{shape}}(t)$.\n- **PCQS Dynamics:**\n    - $\\dfrac{dA}{dt} = \\left(\\dfrac{\\rho_{\\mathrm{eff}}(t) - \\beta}{\\Lambda}\\right) A(t) + \\lambda_d\\, C(t)$\n    - $\\dfrac{dC}{dt} = \\left(\\dfrac{\\beta}{\\Lambda}\\right) A(t) - \\lambda_d\\, C(t)$\n    - $\\dfrac{db_1}{dt} = -\\gamma\\, b_1(t) + \\chi\\, \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_1(x)\\,dx$\n- **PK Dynamics:**\n    - Uses same amplitude-precursor equations as PCQS, but with $\\rho_{\\mathrm{avg,PK}}(t)$ instead of $\\rho_{\\mathrm{eff}}(t)$.\n    - $b_1(t) \\equiv 0$ is assumed.\n- **Initial Conditions ($t=0$):**\n    - $A(0) = 1$\n    - $b_1(0) = 0$\n    - $C(0) = \\dfrac{\\beta}{\\Lambda\\, \\lambda_d} A(0)$\n\n**Physical and Numerical Parameters:**\n- $L = 100\\,\\mathrm{cm}$\n- $\\beta = 0.0065$\n- $\\Lambda = 1.0\\times 10^{-4}\\,\\mathrm{s}$\n- $\\lambda_d = 0.08\\,\\mathrm{s}^{-1}$\n- $\\gamma = 20.0\\,\\mathrm{s}^{-1}$\n- $\\chi = 1.0$\n- $\\eta = 0.2$\n- Spatial grid points: $N_x = 200$\n- Time step: $\\Delta t = 0.001\\,\\mathrm{s}$\n\n**Test Cases for $r_{\\mathrm{ext}}(x,t)$:**\n1.  **Case 1 (Nonuniform Ramp):** $r_{\\mathrm{ext}}(x,t) = r_{\\max} \\, \\mathrm{ramp}(t) \\, \\dfrac{\\exp(-x/\\ell)}{\\max_{x\\in[0,L]} \\exp(-x/\\ell)}$\n    - $r_{\\max} = 0.003$\n    - $\\ell = L/5 = 20\\,\\mathrm{cm}$\n    - $\\mathrm{ramp}(t) = \\min(t/T_r,1)$ with $T_r = 1.0\\,\\mathrm{s}$\n    - Final time: $T = 3.0\\,\\mathrm{s}$\n2.  **Case 2 (Uniform Step):** $r_{\\mathrm{ext}}(x,t) = r_0 = 0.003$\n    - Final time: $T = 3.0\\,\\mathrm{s}$\n3.  **Case 3 (Boundary Pulse):** $r_{\\mathrm{ext}}(x,t) = r_p\\, \\mathbf{1}_{[0,T_p]}(t)\\, \\dfrac{\\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}{\\max_{x\\in[0,L]} \\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}$\n    - $r_p = 0.01$\n    - $T_p = 0.2\\,\\mathrm{s}$\n    - $\\sigma = L/20 = 5\\,\\mathrm{cm}$\n    - Final time: $T = 1.0\\,\\mathrm{s}$\n\n**Required Outputs:**\nFor each case, compute and report:\n1.  $\\max_{t\\in[0,T]} |A(t) - A_{\\mathrm{PK}}(t)|$\n2.  $\\int_0^T |\\rho_{\\mathrm{shape}}(t)|\\,dt$\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded:** The problem uses a standard and well-established simplified model for reactor dynamics, known as the quasi-static method, based on the factorization of neutron flux. The point kinetics equations are fundamental to reactor physics. All equations represent physically plausible phenomena (reactivity feedback, modal excitation, precursor decay). The problem is scientifically sound.\n- **Well-Posed:** All necessary physical parameters, initial conditions, boundary conditions, and forcing functions are explicitly provided. The system of ordinary differential equations (ODEs) is well-defined. The numerical method (predictor-corrector) is specified. A unique, stable solution is expected for the given parameters and time scales. An ambiguity in the definition of $\\rho_{\\mathrm{avg,PK}}(t)$ exists: it specifies weighting with $S_0(x)$, which is not normalized, while the general principle of flux-weighting implies a normalized weighting function. A consistent interpretation, assuming the use of a normalized fundamental shape for the PK model, resolves this and is scientifically justifiable. This interpretation is that the fixed shape for PK is the normalized fundamental mode, consistent with the normalization constraint $\\int_0^L S(x,t)\\, dx = 1$.\n- **Objective:** The problem is stated using precise mathematical and physical terminology, free from subjective language. The tasks are quantitative and verifiable.\n\nThe problem is free of the invalidity flaws listed. The minor ambiguity regarding normalization is resolvable through a standard and logical interpretation consistent with the problem's overall framework.\n\n### Step 3: Verdict and Action\n\nThe problem is deemed **valid**. A solution will be provided.\n\n### Principle-Based Design of Solution\n\nThe solution requires numerically integrating two systems of coupled ODEs over time: one for the PCQS model and one for the PK model. The specified predictor-corrector (trapezoidal) method will be employed for time integration, and the trapezoidal rule for spatial quadrature.\n\n**1. System Formulation**\nThe state vectors for the two models are:\n- PCQS: $\\mathbf{y}(t) = [A(t), C(t), b_1(t)]^T$\n- PK: $\\mathbf{y}_{\\mathrm{PK}}(t) = [A_{\\mathrm{PK}}(t), C_{\\mathrm{PK}}(t)]^T$\n\nThe ODE systems can be written in the standard form $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}, t)$.\n\n**2. Spatial Discretization and Normalization**\nA uniform spatial grid $x_i = i \\cdot \\Delta x$ for $i=0, 1, \\dots, N_x-1$ is used, where $\\Delta x = L/(N_x-1)$. Spatial integrals of the form $\\int_0^L g(x) dx$ are computed using the numerical trapezoidal rule.\n\nThe basis functions are $S_0(x) = \\sin(\\pi x/L)$ and $S_1(x) = \\sin(2\\pi x/L)$. A key analytical simplification arises from their orthogonality properties over the interval $[0,L]$.\n- The normalization integral for the shape is $I_S = \\int_0^L \\tilde{S}(x,t) dx = \\int_0^L (S_0(x) + b_1(t)S_1(x)) dx$.\n- Since $\\int_0^L S_1(x) dx = \\int_0^L \\sin(2\\pi x/L) dx = 0$, this integral simplifies to $I_S = \\int_0^L S_0(x) dx = \\int_0^L \\sin(\\pi x/L) dx = [-\\frac{L}{\\pi}\\cos(\\frac{\\pi x}{L})]^L_0 = \\frac{2L}{\\pi}$.\n- The normalized shape for the PCQS model is $S(x,t) = \\frac{\\tilde{S}(x,t)}{I_S} = \\frac{\\pi}{2L}(S_0(x) + b_1(t)S_1(x))$.\n- The fixed, normalized shape for the PK model is $S_{0,\\mathrm{norm}}(x) = \\frac{S_0(x)}{I_S} = \\frac{\\pi}{2L}S_0(x)$. This resolves the ambiguity in the problem statement for $\\rho_{\\mathrm{avg,PK}}$ by ensuring consistent normalization.\n\n**3. Temporal Integration: Predictor-Corrector Method**\nFor a generic ODE $\\frac{dy}{dt} = f(y, t)$, the update from time $t_n$ to $t_{n+1}=t_n+\\Delta t$ is a two-step process:\n- **Predictor Step (Forward Euler):** An explicit estimate $y^*_{n+1}$ is computed.\n  $y^*_{n+1} = y_n + \\Delta t \\cdot f(y_n, t_n)$\n- **Corrector Step (Trapezoidal Rule):** The final value $y_{n+1}$ is computed using the average of the slopes at the beginning and end of the interval, where the end-interval slope is evaluated using the predicted value.\n  $y_{n+1} = y_n + \\frac{\\Delta t}{2} [f(y_n, t_n) + f(y^*_{n+1}, t_{n+1})]$\n\nThis scheme will be applied to the state vectors $\\mathbf{y}$ and $\\mathbf{y}_{\\mathrm{PK}}$.\n\n**4. Algorithm for a Single Time Step**\nLet the state at time $t_n$ be $(A_n, C_n, b_{1,n})$ for PCQS and $(A_{\\mathrm{PK},n}, C_{\\mathrm{PK},n})$ for PK.\n\n- **Part A: Compute Derivatives at $t_n$**\n  1. Evaluate external reactivity $r_{\\mathrm{ext}}(x, t_n)$ on the spatial grid.\n  2. For PCQS:\n     - Compute the current normalized shape $S_n(x)$ using $b_{1,n}$.\n     - Compute reactivities $\\rho_{\\mathrm{avg},n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n)S_n(x)dx$ and $\\rho_{\\mathrm{shape},n} = -\\eta b_{1,n}^2$.\n     - Compute total reactivity $\\rho_{\\mathrm{eff},n} = \\rho_{\\mathrm{avg},n} + \\rho_{\\mathrm{shape},n}$.\n     - Compute the first harmonic forcing term $G_{1,n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n)S_1(x)dx$.\n     - Calculate the derivatives $\\frac{dA}{dt}|_n$, $\\frac{dC}{dt}|_n$, $\\frac{db_1}{dt}|_n$.\n  3. For PK:\n     - Compute reactivity $\\rho_{\\mathrm{avg,PK},n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n) S_{0,\\mathrm{norm}}(x)dx$.\n     - Calculate the derivatives $\\frac{dA_{\\mathrm{PK}}}{dt}|_n$, $\\frac{dC_{\\mathrm{PK}}}{dt}|_n$.\n\n- **Part B: Predictor Step**\n  1. Compute predicted states at $t_{n+1}$: $(A^*_{n+1}, C^*_{n+1}, b^*_{1,n+1})$ and $(A^*_{\\mathrm{PK},n+1}, C^*_{\\mathrm{PK},n+1})$ using the derivatives from Part A and a forward Euler step.\n\n- **Part C: Compute Derivatives at $t_{n+1}$ using Predicted State**\n  1. Evaluate external reactivity $r_{\\mathrm{ext}}(x, t_{n+1})$ on the spatial grid.\n  2. For PCQS:\n     - Use $b^*_{1,n+1}$ to define the predicted shape $S^*_{n+1}(x)$.\n     - Compute predicted reactivities $\\rho^*_{\\mathrm{avg},n+1}$, $\\rho^*_{\\mathrm{shape},n+1}$, $\\rho^*_{\\mathrm{eff},n+1}$ and forcing term $G^*_{1,n+1}$ using $r_{\\mathrm{ext}}(x, t_{n+1})$ and the predicted state.\n     - Calculate predicted derivatives using the predicted state and reactivities: $(\\frac{d\\mathbf{y}}{dt})^*_{n+1}$.\n  3. For PK:\n     - Compute predicted reactivity $\\rho^*_{\\mathrm{avg,PK},n+1}$ using $r_{\\mathrm{ext}}(x,t_{n+1})$.\n     - Calculate predicted derivatives $(\\frac{d\\mathbf{y}_{\\mathrm{PK}}}{dt})^*_{n+1}$ using the predicted state and reactivity.\n\n- **Part D: Corrector Step**\n  1. Compute the final state at $t_{n+1}$ for both models using the trapezoidal rule, averaging the derivatives from Part A and Part C.\n\nThis process is repeated for all time steps from $t=0$ to the final time $T$. During the simulation, the values of $A(t)$, $A_{\\mathrm{PK}}(t)$, and $\\rho_{\\mathrm{shape}}(t)$ are stored at each time step to compute the required output metrics after the simulation is complete.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reactor dynamics problem for three cases using PCQS and PK models.\n    \"\"\"\n    \n    # Physical and numerical parameters\n    L = 100.0  # cm\n    beta = 0.0065\n    Lambda = 1.0e-4  # s\n    lambda_d = 0.08  # s^-1\n    gamma = 20.0  # s^-1\n    chi = 1.0\n    eta = 0.2\n    \n    Nx = 200\n    dt = 0.001  # s\n\n    # Spatial grid and basis functions\n    x_grid = np.linspace(0, L, Nx)\n    S0 = np.sin(np.pi * x_grid / L)\n    S1 = np.sin(2 * np.pi * x_grid / L)\n    \n    # Normalization integral (analytically 2*L/pi)\n    norm_S0 = np.trapz(S0, x_grid) \n    S0_norm = S0 / norm_S0\n    \n    # Test cases defined as dictionaries\n    test_cases = [\n        {\n            \"T_final\": 3.0,\n            \"r_ext_func\": lambda x, t: 0.003 * min(t / 1.0, 1.0) * np.exp(-x / 20.0),\n        },\n        {\n            \"T_final\": 3.0,\n            \"r_ext_func\": lambda x, t: 0.003 * np.ones_like(x),\n        },\n        {\n            \"T_final\": 1.0,\n            \"r_ext_func\": lambda x, t: 0.01 * (1.0 if t <= 0.2 else 0.0) * np.exp(-x**2 / (2 * 5.0**2)),\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        T_final = case[\"T_final\"]\n        r_ext_func = case[\"r_ext_func\"]\n        \n        # Time steps\n        t_steps = np.arange(0, T_final + dt, dt)\n        num_steps = len(t_steps)\n\n        # Initial conditions\n        A0 = 1.0\n        C0 = (beta / (Lambda * lambda_d)) * A0\n        b1_0 = 0.0\n\n        # PCQS history arrays\n        A_hist = np.zeros(num_steps)\n        C_hist = np.zeros(num_steps)\n        b1_hist = np.zeros(num_steps)\n        rho_shape_hist = np.zeros(num_steps)\n        \n        # PK history arrays\n        A_pk_hist = np.zeros(num_steps)\n        C_pk_hist = np.zeros(num_steps)\n        \n        # Set initial values\n        A_hist[0], C_hist[0], b1_hist[0] = A0, C0, b1_0\n        A_pk_hist[0], C_pk_hist[0] = A0, C0\n        rho_shape_hist[0] = -eta * b1_0**2\n\n        # Main time loop\n        for i in range(num_steps - 1):\n            t_n = t_steps[i]\n            t_n1 = t_steps[i+1]\n            \n            # --- Current step (n) derivatives ---\n            A_n, C_n, b1_n = A_hist[i], C_hist[i], b1_hist[i]\n            A_pk_n, C_pk_n = A_pk_hist[i], C_pk_hist[i]\n\n            r_ext_n = r_ext_func(x_grid, t_n)\n\n            # PCQS derivatives at n\n            S_n = (S0 + b1_n * S1) / norm_S0\n            rho_avg_n = np.trapz(r_ext_n * S_n, x_grid)\n            rho_shape_n = -eta * b1_n**2\n            rho_eff_n = rho_avg_n + rho_shape_n\n            G1_n = np.trapz(r_ext_n * S1, x_grid)\n\n            f_A_n = ((rho_eff_n - beta) / Lambda) * A_n + lambda_d * C_n\n            f_C_n = (beta / Lambda) * A_n - lambda_d * C_n\n            f_b1_n = -gamma * b1_n + chi * G1_n\n\n            # PK derivatives at n\n            rho_avg_pk_n = np.trapz(r_ext_n * S0_norm, x_grid)\n            f_A_pk_n = ((rho_avg_pk_n - beta) / Lambda) * A_pk_n + lambda_d * C_pk_n\n            f_C_pk_n = (beta / Lambda) * A_pk_n - lambda_d * C_pk_n\n\n            # --- Predictor step ---\n            A_star = A_n + dt * f_A_n\n            C_star = C_n + dt * f_C_n\n            b1_star = b1_n + dt * f_b1_n\n            \n            A_pk_star = A_pk_n + dt * f_A_pk_n\n            C_pk_star = C_pk_n + dt * f_C_pk_n\n\n            # --- Predicted step (n+1) derivatives ---\n            r_ext_n1 = r_ext_func(x_grid, t_n1)\n\n            # PCQS derivatives at n+1\n            S_star = (S0 + b1_star * S1) / norm_S0\n            rho_avg_star = np.trapz(r_ext_n1 * S_star, x_grid)\n            rho_shape_star = -eta * b1_star**2\n            rho_eff_star = rho_avg_star + rho_shape_star\n            G1_star = np.trapz(r_ext_n1 * S1, x_grid)\n\n            f_A_star = ((rho_eff_star - beta) / Lambda) * A_star + lambda_d * C_star\n            f_C_star = (beta / Lambda) * A_star - lambda_d * C_star\n            f_b1_star = -gamma * b1_star + chi * G1_star\n            \n            # PK derivatives at n+1\n            rho_avg_pk_star = np.trapz(r_ext_n1 * S0_norm, x_grid)\n            f_A_pk_star = ((rho_avg_pk_star - beta) / Lambda) * A_pk_star + lambda_d * C_pk_star\n            f_C_pk_star = (beta / Lambda) * A_pk_star - lambda_d * C_pk_star\n            \n            # --- Corrector step ---\n            A_hist[i+1] = A_n + 0.5 * dt * (f_A_n + f_A_star)\n            C_hist[i+1] = C_n + 0.5 * dt * (f_C_n + f_C_star)\n            b1_hist[i+1] = b1_n + 0.5 * dt * (f_b1_n + f_b1_star)\n            \n            A_pk_hist[i+1] = A_pk_n + 0.5 * dt * (f_A_pk_n + f_A_pk_star)\n            C_pk_hist[i+1] = C_pk_n + 0.5 * dt * (f_C_pk_n + f_C_pk_star)\n\n            # Store shape reactivity for output calculation\n            rho_shape_hist[i+1] = -eta * b1_hist[i+1]**2\n        \n        # Calculate final metrics for the case\n        max_abs_diff = np.max(np.abs(A_hist - A_pk_hist))\n        shape_corr_integral = np.trapz(np.abs(rho_shape_hist), t_steps)\n        \n        all_results.append([max_abs_diff, shape_corr_integral])\n\n    # Format output\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}