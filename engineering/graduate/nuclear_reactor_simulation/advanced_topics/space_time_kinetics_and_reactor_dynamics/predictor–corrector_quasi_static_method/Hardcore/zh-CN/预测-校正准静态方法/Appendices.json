{
    "hands_on_practices": [
        {
            "introduction": "反应堆动力学分析的核心是将复杂的三维中子输运问题简化为点动力学模型。该实践将指导你从通量分布和材料截面这些基本量出发，推导并数值计算有效缓发中子份额 $\\beta_{\\text{eff}}$ 和瞬发中子代时间 $\\Lambda$ 这两个关键动力学参数。通过这个过程 ，你将深刻理解宏观动力学参数是如何蕴含于微观的空间与能量细节之中的。",
            "id": "4242130",
            "problem": "在与核反应堆模拟中的预测-校正准静态（PCQS）方法相关的一维板几何多群设置中，中子通量被分解为一个幅度和一个形状函数。您需要从基本的多群平衡概念（中子密度、裂变源率）出发，仅使用所提供的形状函数和截面，推导出有效缓发中子份额和瞬发中子代长时间的有效数值估算子。将推导出的估算子实现为均匀网格上的中点法则求积，并评估估算子对形状离散化的敏感性。\n\n使用以下基本基础：\n\n- 能量群 $g$ 中的中子密度通过 $n_g(\\mathbf{r},t) = \\phi_g(\\mathbf{r},t)/v_g$ 与中子通量相关，其中 $v_g$ 是能量群 $g$ 中的中子速度。\n- 总裂变产生率是 $F(t) = \\sum_{g} \\int \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$，其中 $\\nu_g$ 是由能量群 $g$ 中的一个中子引起的每次裂变产生的平均中子数，$\\Sigma_{f,g}$ 是能量群 $g$ 中的宏观裂变截面。\n- 在产生点，缓发中子份额由群缓发份额 $\\beta_g$ 表征，在本问题中假设其在空间上是常数。缓发裂变产生率为 $F_d(t) = \\sum_{g} \\int \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$。\n- 在准静态分解中，通量表示为 $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r},t)$，其中 $A(t)$ 是一个幅度，$\\psi_g$ 是一个捕捉空间和能量依赖性的形状函数。\n\n任务：\n\n$1.$ 仅使用上述基础，推导有效缓发中子份额 $\\beta_{\\text{eff}}(t)$ 和瞬发中子代长时间 $\\Lambda(t)$ 的表达式，这些表达式应以形状函数 $\\psi_g(\\mathbf{r},t)$、群速度 $v_g$、宏观裂变截面 $\\Sigma_{f,g}(\\mathbf{r})$ 和群缓发份额 $\\beta_g$ 的空间积分形式表示，不使用任何伴随权重或输运-特征值捷径。清楚说明您所依赖的任何准静态假设，以消除对幅度 $A(t)$ 的依赖。\n\n$2.$ 在长度为 $L$ 的一维板几何中，将体积积分替换为在 $x \\in [0,L]$ 上的线积分，并使用中点法则在包含 $N$ 个单元的均匀网格上对它们进行数值评估，单元宽度为 $\\Delta x = L/N$，中点为 $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。\n\n$3.$ 实现一个程序，对于下面指定的每个测试用例，计算：\n- 有效缓发中子份额 $\\beta_{\\text{eff}}$（无量纲）。\n- 瞬发中子代长时间 $\\Lambda$（单位：秒）。\n- 每个量的相对离散化敏感度，定义为 $E_{\\beta} = \\left|\\beta_{\\text{eff}}^{(N)} - \\beta_{\\text{eff}}^{(\\text{ref})}\\right| / \\left|\\beta_{\\text{eff}}^{(\\text{ref})}\\right|$ 和 $E_{\\Lambda} = \\left|\\Lambda^{(N)} - \\Lambda^{(\\text{ref})}\\right| / \\left|\\Lambda^{(\\text{ref})}\\right|$，其中参考值是在一个具有 $N_{\\text{ref}}$ 个单元的非常精细的网格上计算的。\n\n假设和单位：\n\n- 考虑两个能量群，索引为 $g \\in \\{1,2\\}$。\n- 使用一维板几何，其中 $x \\in [0,L]$，$L$ 的单位为厘米，宏观截面单位为 $\\text{cm}^{-1}$，速度单位为 $\\text{cm}/\\text{s}$，并计算 $\\Lambda$（单位：秒）。有效缓发中子份额 $\\beta_{\\text{eff}}$ 是无量纲的。\n- 形状函数直接作为 $x$ 和能量群 $g$ 的函数提供；无需解任何输运或扩散方程。\n- 中子产额 $\\nu_g$ 和缓发份额 $\\beta_g$ 是常数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身应是一个包含四个浮点数的列表，顺序为 $[\\beta_{\\text{eff}}, \\Lambda, E_{\\beta}, E_{\\Lambda}]$，每个浮点数四舍五入到八位小数。因此，总体输出应类似于 $[[b_1,\\lambda_1,e_{b,1},e_{\\lambda,1}],[b_2,\\lambda_2,e_{b,2},e_{\\lambda,2}],\\dots]$。\n\n测试套件：\n\n对于所有情况，使用具有 $N_{\\text{ref}} = 50000$ 的精细参考离散化。\n\n情况A（平滑形状，均匀材料）：\n\n- 域长度 $L = 100.0$。\n- 群速度: $v_1 = 2.2\\times 10^{5}$，$v_2 = 1.0\\times 10^{7}$。\n- 中子产额: $\\nu_1 = 2.43$，$\\nu_2 = 2.43$。\n- 宏观裂变截面: $\\Sigma_{f,1}(x) = 5.0\\times 10^{-3}$，$\\Sigma_{f,2}(x) = 1.0\\times 10^{-3}$。\n- 缓发份额: $\\beta_1 = 4.0\\times 10^{-3}$，$\\beta_2 = 2.5\\times 10^{-3}$。\n- 形状函数: $\\psi_1(x) = \\sin\\left(\\pi x/L\\right)$，$\\psi_2(x) = 0.6\\,\\sin\\left(\\pi x/L\\right)$。\n- 用于评估的粗略离散化：$N = 20$。\n\n情况B（材料不连续，平滑形状）：\n\n- 域长度 $L = 100.0$。\n- 群速度: $v_1 = 2.2\\times 10^{5}$，$v_2 = 1.0\\times 10^{7}$。\n- 中子产额: $\\nu_1 = 2.43$，$\\nu_2 = 2.43$。\n- 宏观裂变截面:\n  - 当 $x  L/2$ 时，$\\Sigma_{f,1}(x) = 3.0\\times 10^{-3}$；当 $x \\ge L/2$ 时，$\\Sigma_{f,1}(x) = 7.0\\times 10^{-3}$。\n  - 当 $x  L/2$ 时，$\\Sigma_{f,2}(x) = 8.0\\times 10^{-4}$；当 $x \\ge L/2$ 时，$\\Sigma_{f,2}(x) = 1.2\\times 10^{-3}$。\n- 缓发份额: $\\beta_1 = 4.0\\times 10^{-3}$，$\\beta_2 = 2.5\\times 10^{-3}$。\n- 形状函数: $\\psi_1(x) = \\sin\\left(\\pi x/L\\right)$，$\\psi_2(x) = 0.6\\,\\sin\\left(\\pi x/L\\right)$。\n- 用于评估的粗略离散化：$N = 40$。\n\n情况C（更陡峭的形状，均匀材料）：\n\n- 域长度 $L = 100.0$。\n- 群速度: $v_1 = 2.2\\times 10^{5}$，$v_2 = 1.0\\times 10^{7}$。\n- 中子产额: $\\nu_1 = 2.43$，$\\nu_2 = 2.43$。\n- 宏观裂变截面: $\\Sigma_{f,1}(x) = 4.0\\times 10^{-3}$，$\\Sigma_{f,2}(x) = 1.5\\times 10^{-3}$。\n- 缓发份额: $\\beta_1 = 4.0\\times 10^{-3}$，$\\beta_2 = 2.5\\times 10^{-3}$。\n- 形状函数: $\\psi_1(x) = \\sin\\left(\\pi x/L\\right) + 0.2\\,\\sin\\left(3\\pi x/L\\right)$，$\\psi_2(x) = 0.5\\,\\sin\\left(\\pi x/L\\right) + 0.1\\,\\sin\\left(3\\pi x/L\\right)$。\n- 用于评估的粗略离散化：$N = 30$。\n\n实现细节和输出：\n\n- 在每种情况下，对粗略估计使用指定的 $N$ 进行中点法则求积，对参考估计使用 $N_{\\text{ref}}$ 进行中点法则求积。\n- 将形状函数 $\\psi_g(x)$ 视为无量纲函数。您不需要任何幅度归一化，但您的推导必须证明为什么在所需的比率中幅度会抵消。\n- 您的程序应精确生成一行：一个包含三个内部列表的方括号列表，每个内部列表对应一种情况，包含四个浮点数 $[\\beta_{\\text{eff}}, \\Lambda, E_{\\beta}, E_{\\Lambda}]$，四舍五入到八位小数，且无任何附加文本。",
            "solution": "该问题是有效的，因为它科学地基于核反应堆物理的既定原理，问题表述清晰、客观，并包含获得唯一解所需的所有信息。任务要求推导和数值实现反应堆动力学参数，这是一个标准且可验证的过程。\n\n### 第1部分：估算子的推导\n\n目标是使用提供的基本定义和准静态通量分解，推导有效缓发中子份额 $\\beta_{\\text{eff}}$ 和瞬发中子代长时间 $\\Lambda$ 的表达式。推导过程不得使用伴随权重。\n\n**1.1. 有效缓发中子份额 ($\\beta_{\\text{eff}}$)**\n\n有效缓发中子份额 $\\beta_{\\text{eff}}$ 定义为总缓发裂变中子产生率与总（瞬发加缓发）裂变中子产生率之比。\n\n总裂变产生率 $F(t)$ 由下式给出：\n$$F(t) = \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$$\n其中 $\\nu_g$ 是能量群 $g$ 中的一个中子每次裂变产生的中子数，$\\Sigma_{f,g}(\\mathbf{r})$ 是宏观裂变截面，$\\phi_g(\\mathbf{r},t)$ 是中子通量。积分遍及反应堆体积 $V$。\n\n缓发裂变产生率 $F_d(t)$ 由下式给出：\n$$F_d(t) = \\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV$$\n其中 $\\beta_g$ 是由群 $g$ 中的中子引起的裂变中，缓发中子所占的份额。\n\n根据定义，$\\beta_{\\text{eff}}(t)$ 是这两个率的比值：\n$$\\beta_{\\text{eff}}(t) = \\frac{F_d(t)}{F(t)} = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}$$\n\n我们引入准静态通量分解 $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r},t)$，其中 $A(t)$ 是一个随时间变化的幅度，$\\psi_g(\\mathbf{r},t)$ 是一个随时间变化的形状函数。准静态方法的一个关键假设是形状函数 $\\psi_g$ 随时间变化缓慢，这使我们可以在特定时间瞬间计算积分参数时将其视为常数。本问题提供了不随时间变化的形状函数 $\\psi_g(\\mathbf{r})$，这与该假设是一致的。\n\n将分解式代入 $\\beta_{\\text{eff}}$ 的表达式中：\n$$\\beta_{\\text{eff}}(t) = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) A(t)\\,\\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) A(t)\\,\\psi_g(\\mathbf{r}) \\, dV}$$\n由于幅度 $A(t)$ 与空间（$\\mathbf{r}$）和能量群（$g$）无关，因此可以将其从分子和分母的积分和求和中提出来：\n$$\\beta_{\\text{eff}}(t) = \\frac{A(t) \\left( \\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}{A(t) \\left( \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}$$\n只要 $A(t) \\ne 0$ 且总裂变率不为零，幅度 $A(t)$ 就会被抵消。这种抵消解释了为什么结果与通量幅度和形状函数 $\\psi_g$ 的任何任意归一化无关。最终的表达式仅取决于形状和材料属性：\n$$\\beta_{\\text{eff}} = \\frac{\\sum_{g} \\int_V \\beta_g \\, \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}$$\n\n**1.2. 瞬发中子代长时间 ($\\Lambda$)**\n\n瞬发中子代长时间 $\\Lambda$ 定义为反应堆中总中子数与总裂变中子产生率之比。\n\n总中子数 $N_{\\text{total}}(t)$ 是总中子密度的体积积分。能量群 $g$ 中的中子密度为 $n_g(\\mathbf{r},t) = \\phi_g(\\mathbf{r},t)/v_g$，其中 $v_g$ 是能量群 $g$ 的平均中子速度。\n$$N_{\\text{total}}(t) = \\sum_{g} \\int_V n_g(\\mathbf{r},t) \\, dV = \\sum_{g} \\int_V \\frac{\\phi_g(\\mathbf{r},t)}{v_g} \\, dV$$\n总裂变产生率 $F(t)$ 与前面定义的相同。\n\n根据定义，$\\Lambda(t)$ 为：\n$$\\Lambda(t) = \\frac{N_{\\text{total}}(t)}{F(t)} = \\frac{\\sum_{g} \\int_V \\frac{\\phi_g(\\mathbf{r},t)}{v_g} \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\phi_g(\\mathbf{r},t) \\, dV}$$\n代入分解式 $\\phi_g(\\mathbf{r},t) = A(t)\\,\\psi_g(\\mathbf{r})$ 并再次提出幅度 $A(t)$：\n$$\\Lambda(t) = \\frac{A(t) \\left( \\sum_{g} \\frac{1}{v_g} \\int_V \\psi_g(\\mathbf{r}) \\, dV \\right)}{A(t) \\left( \\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV \\right)}$$\n幅度 $A(t)$ 被抵消，得到瞬发中子代长时间的最终表达式：\n$$\\Lambda = \\frac{\\sum_{g} \\frac{1}{v_g} \\int_V \\psi_g(\\mathbf{r}) \\, dV}{\\sum_{g} \\int_V \\nu_g \\Sigma_{f,g}(\\mathbf{r}) \\psi_g(\\mathbf{r}) \\, dV}$$\n\n### 第2部分：一维板几何中的数值实现\n\n对于长度为 $L$ 的一维板，假设横截面积为单位面积，体积微分 $dV$ 被线微分 $dx$ 替代。积分在域 $x \\in [0, L]$ 上进行评估。\n\n表达式变为：\n$$\\beta_{\\text{eff}} = \\frac{\\sum_{g} \\int_0^L \\beta_g \\, \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}{\\sum_{g} \\int_0^L \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}$$\n$$\\Lambda = \\frac{\\sum_{g} \\frac{1}{v_g} \\int_0^L \\psi_g(x) \\, dx}{\\sum_{g} \\int_0^L \\nu_g \\Sigma_{f,g}(x) \\psi_g(x) \\, dx}$$\n\n我们使用中点法则求积法，在包含 $N$ 个单元的均匀网格上近似这些积分。单元宽度为 $\\Delta x = L/N$，单元中点为 $x_i = (i + 1/2)\\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。一个积分 $\\int_0^L f(x) \\, dx$ 可近似为：\n$$\\int_0^L f(x) \\, dx \\approx \\sum_{i=0}^{N-1} f(x_i) \\Delta x$$\n\n让我们定义以下在网格点上的求和：\n$$S_{f,g} = \\sum_{i=0}^{N-1} \\Sigma_{f,g}(x_i) \\psi_g(x_i)$$\n$$S_{\\psi,g} = \\sum_{i=0}^{N-1} \\psi_g(x_i)$$\n\n积分随后被近似为：\n$$\\int_0^L \\Sigma_{f,g}(x) \\psi_g(x) \\, dx \\approx S_{f,g} \\Delta x$$\n$$\\int_0^L \\psi_g(x) \\, dx \\approx S_{\\psi,g} \\Delta x$$\n\n将这些近似值代入 $\\beta_{\\text{eff}}$ 和 $\\Lambda$ 的表达式中：\n$$\\beta_{\\text{eff}}^{(N)} = \\frac{\\sum_{g} \\beta_g \\, \\nu_g (S_{f,g} \\Delta x)}{\\sum_{g} \\nu_g (S_{f,g} \\Delta x)} = \\frac{\\Delta x \\sum_{g} \\beta_g \\nu_g S_{f,g}}{\\Delta x \\sum_{g} \\nu_g S_{f,g}} = \\frac{\\sum_{g} \\beta_g \\nu_g S_{f,g}}{\\sum_{g} \\nu_g S_{f,g}}$$\n$$\\Lambda^{(N)} = \\frac{\\sum_{g} \\frac{1}{v_g} (S_{\\psi,g} \\Delta x)}{\\sum_{g} \\nu_g (S_{f,g} \\Delta x)} = \\frac{\\Delta x \\sum_{g} \\frac{1}{v_g} S_{\\psi,g}}{\\Delta x \\sum_{g} \\nu_g S_{f,g}} = \\frac{\\sum_{g} \\frac{1}{v_g} S_{\\psi,g}}{\\sum_{g} \\nu_g S_{f,g}}$$\n公因子 $\\Delta x = L/N$ 在两个表达式中都被抵消。因此，数值估算子是通过在单元中点处评估被积函数并将其求和来计算的，无需乘以单元宽度。\n\n### 第3部分：离散化敏感度\n\n一个量 $Q$（$\\beta_{\\text{eff}}$ 或 $\\Lambda$）的相对离散化敏感度计算如下：\n$$E_Q = \\frac{\\left|Q^{(N)} - Q^{(\\text{ref})}\\right|}{\\left|Q^{(\\text{ref})}\\right|}$$\n其中 $Q^{(N)}$ 是在具有 $N$ 个单元的粗网格上计算的值，而 $Q^{(\\text{ref})}$ 是在具有 $N_{\\text{ref}}$ 个单元的非常精细的网格上计算的参考值，它作为真实连续值的近似。\n\n程序将为每个测试用例实现这些公式，计算粗略（$N$）和参考（$N_{\\text{ref}}$）离散化下的各量值，然后在打印格式化输出之前计算敏感度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_kinetics(L, v, nu, beta, sigma_f_funcs, psi_funcs, N):\n    \"\"\"\n    Computes effective delayed neutron fraction and prompt neutron generation time.\n\n    Args:\n        L (float): Domain length in cm.\n        v (tuple): Group speeds (v1, v2) in cm/s.\n        nu (tuple): Neutrons per fission (nu1, nu2).\n        beta (tuple): Delayed neutron fractions (beta1, beta2).\n        sigma_f_funcs (tuple): Functions for macroscopic fission cross sections.\n        psi_funcs (tuple): Functions for shape functions.\n        N (int): Number of discretization cells.\n\n    Returns:\n        tuple: (beta_eff, Lambda)\n    \"\"\"\n    v1, v2 = v\n    nu1, nu2 = nu\n    beta1, beta2 = beta\n    sigma_f1_func, sigma_f2_func = sigma_f_funcs\n    psi1_func, psi2_func = psi_funcs\n\n    # Create grid of cell midpoints\n    dx = L / N\n    x_midpoints = (np.arange(N) + 0.5) * dx\n\n    # Evaluate shapes and cross sections at midpoints\n    psi1_vals = psi1_func(x_midpoints)\n    psi2_vals = psi2_func(x_midpoints)\n    sigma_f1_vals = sigma_f1_func(x_midpoints)\n    sigma_f2_vals = sigma_f2_func(x_midpoints)\n\n    # Calculate sums S_f,g and S_psi,g\n    S_f1 = np.sum(sigma_f1_vals * psi1_vals)\n    S_f2 = np.sum(sigma_f2_vals * psi2_vals)\n    S_psi1 = np.sum(psi1_vals)\n    S_psi2 = np.sum(psi2_vals)\n\n    # Calculate numerators and the common denominator for beta_eff and Lambda\n    # Denominator: total fission source rate integral (without amplitude)\n    I_den = nu1 * S_f1 + nu2 * S_f2\n    \n    # Numerator for beta_eff: delayed fission source rate integral\n    I_beta_num = beta1 * nu1 * S_f1 + beta2 * nu2 * S_f2\n    \n    # Numerator for Lambda: total neutron population integral (flux/v)\n    I_Lambda_num = (1.0 / v1) * S_psi1 + (1.0 / v2) * S_psi2\n    \n    if I_den == 0:\n        return (np.nan, np.nan)\n\n    # Compute beta_eff and Lambda\n    beta_eff = I_beta_num / I_den\n    Lambda = I_Lambda_num / I_den\n\n    return beta_eff, Lambda\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    N_ref = 50000\n\n    test_cases = [\n        # Case A: Smooth shape, uniform material\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: 5.0e-3,\n                lambda x: 1.0e-3\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0),\n                lambda x: 0.6 * np.sin(np.pi * x / 100.0)\n            ),\n            \"N\": 20\n        },\n        # Case B: Material discontinuity, smooth shape\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: np.where(x  50.0, 3.0e-3, 7.0e-3),\n                lambda x: np.where(x  50.0, 8.0e-4, 1.2e-3)\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0),\n                lambda x: 0.6 * np.sin(np.pi * x / 100.0)\n            ),\n            \"N\": 40\n        },\n        # Case C: Steeper shape, uniform material\n        {\n            \"L\": 100.0,\n            \"v\": (2.2e5, 1.0e7),\n            \"nu\": (2.43, 2.43),\n            \"beta\": (4.0e-3, 2.5e-3),\n            \"sigma_f_funcs\": (\n                lambda x: 4.0e-3,\n                lambda x: 1.5e-3\n            ),\n            \"psi_funcs\": (\n                lambda x: np.sin(np.pi * x / 100.0) + 0.2 * np.sin(3 * np.pi * x / 100.0),\n                lambda x: 0.5 * np.sin(np.pi * x / 100.0) + 0.1 * np.sin(3 * np.pi * x / 100.0)\n            ),\n            \"N\": 30\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Reference calculation with a very fine grid\n        beta_ref, Lambda_ref = compute_kinetics(\n            case[\"L\"], case[\"v\"], case[\"nu\"], case[\"beta\"],\n            case[\"sigma_f_funcs\"], case[\"psi_funcs\"], N_ref\n        )\n\n        # Coarse calculation with the specified grid size N\n        beta_n, Lambda_n = compute_kinetics(\n            case[\"L\"], case[\"v\"], case[\"nu\"], case[\"beta\"],\n            case[\"sigma_f_funcs\"], case[\"psi_funcs\"], case[\"N\"]\n        )\n\n        # Calculate relative discretization sensitivities\n        E_beta = np.abs(beta_n - beta_ref) / np.abs(beta_ref)\n        E_Lambda = np.abs(Lambda_n - Lambda_ref) / np.abs(Lambda_ref)\n\n        case_results = [\n            round(beta_n, 8),\n            round(Lambda_n, 8),\n            round(E_beta, 8),\n            round(E_Lambda, 8)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists\n    results_str_list = []\n    for res_list in all_results:\n        results_str_list.append(f\"[{','.join(map(str, res_list))}]\")\n    \n    final_output = f\"[{','.join(results_str_list)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "PCQS 方法的精髓在于其预测-校正迭代框架。为了精确掌握其工作机理，本练习将带你深入单个时间步长内部，聚焦于缓发中子先驱核浓度的更新过程。你将通过具体计算，体验预测步和校正步的通量形状信息如何共同作用于缓发中子源项，从而深化对该方法数值稳定性和准确性来源的理解 。",
            "id": "4242119",
            "problem": "考虑一个一维、均匀的热核反应堆，表示为长度为 $L$ 的平板，在 $x=0$ 和 $x=L$ 处具有真空边界条件。该反应堆使用单群延迟中子、单能中子平衡进行建模，中子布居通过幅度-形状因子分解法表示，其中中子通量写作 $\\phi(x,t) = A(t) S(x,t)$，其中 $S(x,t)$ 被归一化，使得在所有时刻 $\\int_0^L S(x,t)\\,dx = 1$。反应堆是均匀的，意味着材料属性不随空间变化，但允许外部反应性引入在空间上不均匀且随时间变化。物理时间单位必须是秒，空间距离单位必须是厘米。\n\n动力学的基础应为：\n- 带有单群延迟中子的反应堆幅度点动力学模型，用幅度 $A(t)$ 和延迟中子先驱核幅度 $C(t)$ 表示：\n  - $A(t)$ 因净有效反应性和延迟中子源而演化。\n  - $C(t)$ 因 $A(t)$ 的产生和以常数 $\\lambda_d$ 的衰变而演化。\n- 在非均匀反应性作用下，形状的演化导致偏离基波空间模式，该偏离由模态展开中的一阶谐波系数 $b_1(t)$ 捕捉。\n\n您将实现两个模型：\n- 一种预测-校正准静态方法 (PCQS)，其中幅度 $A(t)$ 使用点动力学进行推进，其时变有效反应性包含形状修正项，而形状偏差系数 $b_1(t)$ 通过一个受驱、阻尼的常微分方程进行推进，该方程表示一阶谐波形状在非均匀反应性下的一阶响应。\n- 一个纯点动力学模型 (PK)，其中幅度 $A_{\\mathrm{PK}}(t)$ 使用相同的点动力学方程进行推进，但通量形状被假定在所有时刻固定且等于基波模式，形状修正项被忽略。\n\n使用的定义和核心构造：\n- 设基波模式为 $S_0(x) = \\sin\\left(\\frac{\\pi x}{L}\\right)$，一阶谐波为 $S_1(x) = \\sin\\left(\\frac{2\\pi x}{L}\\right)$，两者均满足真空边界条件。\n- 设形状近似为 $S(x,t) = \\tilde{S}(x,t)/\\int_0^L \\tilde{S}(x,t)\\,dx$，其中 $\\tilde{S}(x,t) = S_0(x) + b_1(t) S_1(x)$，强制要求 $\\int_0^L S(x,t)\\,dx = 1$。\n- 外部反应性由一个随空间和时间变化的反应性密度 $r_{\\mathrm{ext}}(x,t)$（无量纲）表示，通过形状加权积分产生平均有效反应性：\n  - 对于 PCQS: $\\rho_{\\mathrm{avg}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S(x,t)\\,dx$。\n  - 对于 PK: $\\rho_{\\mathrm{avg,PK}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_0(x)\\,dx$。\n- PCQS 模型使用一个对反应性的形状修正项，该修正项惩罚因形状畸变引起的泄漏增加，近似为一阶谐波幅值的二次函数：\n  - $\\rho_{\\mathrm{shape}}(t) = -\\eta\\, b_1(t)^2$，其中 $\\eta0$ 是一个常数灵敏度参数。\n- 那么，PCQS 幅值中使用的总有效反应性为 $\\rho_{\\mathrm{eff}}(t) = \\rho_{\\mathrm{avg}}(t) + \\rho_{\\mathrm{shape}}(t)$。\n- PCQS 幅值-先驱核系统是：\n  - $\\dfrac{dA}{dt} = \\left(\\dfrac{\\rho_{\\mathrm{eff}}(t) - \\beta}{\\Lambda}\\right) A(t) + \\lambda_d\\, C(t)$,\n  - $\\dfrac{dC}{dt} = \\left(\\dfrac{\\beta}{\\Lambda}\\right) A(t) - \\lambda_d\\, C(t)$,\n  其中 $\\beta$ 是总延迟中子份额，$\\Lambda$ 是瞬发中子代时间。\n- PK 幅值-先驱核系统是相同的，但使用 $\\rho_{\\mathrm{avg,PK}}(t)$ 代替 $\\rho_{\\mathrm{eff}}(t)$，并假设 $b_1(t)\\equiv 0$。\n- 在 PCQS 中，一阶谐波系数 $b_1(t)$ 遵循一个受驱、阻尼的动力学过程，该过程捕捉了非均匀反应性引起的激励和由于模态衰减引起的弛豫：\n  - $\\dfrac{db_1}{dt} = -\\gamma\\, b_1(t) + \\chi\\, \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_1(x)\\,dx$,\n  其中 $\\gamma0$ 是一阶谐波的弛豫率，$\\chi0$ 是从非均匀反应性到一阶谐波的耦合增益。\n\n数值积分方法要求：\n- 对 $A(t)$、$C(t)$ 和 $b_1(t)$ 的 PCQS 系统使用预测-校正（梯形）时间步进法。\n- 对 $A_{\\mathrm{PK}}(t)$ 和 $C_{\\mathrm{PK}}(t)$ 的 PK 系统使用匹配的时间步进方案。\n- 使用均匀空间网格，通过数值积分（例如，梯形法则）来计算空间积分。\n- 在 $t=0$ 时初始化，$A(0)=1$，$b_1(0)=0$，并且 $C(0) = \\dfrac{\\beta}{\\Lambda\\, \\lambda_d} A(0)$，以与净反应性为零的稳态保持一致。\n\n使用的物理参数：\n- $L = 100\\,\\mathrm{cm}$,\n- $\\beta = 0.0065$,\n- $\\Lambda = 1.0\\times 10^{-4}\\,\\mathrm{s}$,\n- $\\lambda_d = 0.08\\,\\mathrm{s}^{-1}$,\n- $\\gamma = 20.0\\,\\mathrm{s}^{-1}$,\n- $\\chi = 1.0$,\n- $\\eta = 0.2$.\n\n测试套件规范：\n- 空间网格：在 $[0,L]$ 上使用 $N_x = 200$ 个均匀分布的点。\n- 时间步进：使用 $\\Delta t = 0.001\\,\\mathrm{s}$。\n- 三个瞬态案例覆盖了不同的激励机制：\n  1. 案例 1（正常路径，非均匀斜坡）：$r_{\\mathrm{ext}}(x,t) = r_{\\max} \\, \\mathrm{ramp}(t) \\, \\dfrac{\\exp(-x/\\ell)}{\\max_{x\\in[0,L]} \\exp(-x/\\ell)}$，其中 $r_{\\max} = 0.003$，$\\ell = L/5$，并且 $\\mathrm{ramp}(t) = \\min(t/T_r,1)$，其中 $T_r = 1.0\\,\\mathrm{s}$。模拟到最终时间 $T=3.0\\,\\mathrm{s}$。\n  2. 案例 2（边界条件检查，均匀阶跃）：$r_{\\mathrm{ext}}(x,t) = r_0$，其中 $r_0 = 0.003$ 在空间和时间上对于 $0\\le t\\le 3.0\\,\\mathrm{s}$ 是常数，且 $T=3.0\\,\\mathrm{s}$。\n  3. 案例 3（边界情况，边界附近的短脉冲）：$r_{\\mathrm{ext}}(x,t) = r_p\\, \\mathbf{1}_{[0,T_p]}(t)\\, \\dfrac{\\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}{\\max_{x\\in[0,L]} \\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}$，其中 $r_p = 0.01$，$T_p = 0.2\\,\\mathrm{s}$，$\\sigma = L/20$，且 $T=1.0\\,\\mathrm{s}$。\n\n对于每个案例，计算：\n- 在模拟时间窗口内幅值轨迹的最大绝对差，$\\max_{t\\in[0,T]} |A(t) - A_{\\mathrm{PK}}(t)|$，以无量纲浮点数形式报告。\n- 形状修正反应性绝对值的时间积分，$\\int_0^T |\\rho_{\\mathrm{shape}}(t)|\\,dt$，以 $\\mathrm{s}$ 为单位报告，其中反应性是无量纲的。\n\n最终输出规范：\n- 您的程序应生成单行输出，包含结果，格式为逗号分隔的列表的列表，每个子列表对应一个案例，并按 $[\\text{max\\_abs\\_diff}, \\text{shape\\_corr\\_integral}]$ 的顺序排列。例如，输出格式必须与 $[[a_1,b_1],[a_2,b_2],[a_3,b_3]]$ 完全一样，其中所有的 $a_i$ 和 $b_i$ 都是浮点数。",
            "solution": "用户要求实现并比较两种反应堆动力学模型：一种是预测-校正准静态 (PCQS) 模型，另一种是纯点动力学 (PK) 模型。该问题需要在三种不同的瞬态场景下求解。\n\n### 步骤1：提取已知条件\n\n**反应堆模型：**\n- 长度为 $L$ 的一维均匀平板反应堆。\n- $x=0$ 和 $x=L$ 处的真空边界条件。\n- 单能中子平衡，带单群延迟中子。\n- 通量因子分解：$\\phi(x,t) = A(t) S(x,t)$。\n- 形状归一化：对所有 $t$，$\\int_0^L S(x,t)\\,dx = 1$。\n\n**数学公式：**\n- **形状展开：**\n    - 基波模式：$S_0(x) = \\sin\\left(\\frac{\\pi x}{L}\\right)$。\n    - 一阶谐波：$S_1(x) = \\sin\\left(\\frac{2\\pi x}{L}\\right)$。\n    - 形状近似：$S(x,t) = \\tilde{S}(x,t)/\\int_0^L \\tilde{S}(x,t)\\,dx$，其中 $\\tilde{S}(x,t) = S_0(x) + b_1(t) S_1(x)$。\n- **反应性：**\n    - 外部反应性密度：$r_{\\mathrm{ext}}(x,t)$。\n    - PCQS 平均反应性：$\\rho_{\\mathrm{avg}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S(x,t)\\,dx$。\n    - PK 平均反应性：$\\rho_{\\mathrm{avg,PK}}(t) = \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_0(x)\\,dx$。\n    - PCQS 形状反应性修正：$\\rho_{\\mathrm{shape}}(t) = -\\eta\\, b_1(t)^2$。\n    - PCQS 总有效反应性：$\\rho_{\\mathrm{eff}}(t) = \\rho_{\\mathrm{avg}}(t) + \\rho_{\\mathrm{shape}}(t)$。\n- **PCQS 动力学：**\n    - $\\dfrac{dA}{dt} = \\left(\\dfrac{\\rho_{\\mathrm{eff}}(t) - \\beta}{\\Lambda}\\right) A(t) + \\lambda_d\\, C(t)$\n    - $\\dfrac{dC}{dt} = \\left(\\dfrac{\\beta}{\\Lambda}\\right) A(t) - \\lambda_d\\, C(t)$\n    - $\\dfrac{db_1}{dt} = -\\gamma\\, b_1(t) + \\chi\\, \\int_0^L r_{\\mathrm{ext}}(x,t)\\, S_1(x)\\,dx$\n- **PK 动力学：**\n    - 使用与 PCQS 相同的幅值-先驱核方程，但用 $\\rho_{\\mathrm{avg,PK}}(t)$ 代替 $\\rho_{\\mathrm{eff}}(t)$。\n    - 假设 $b_1(t) \\equiv 0$。\n- **初始条件 ($t=0$)：**\n    - $A(0) = 1$\n    - $b_1(0) = 0$\n    - $C(0) = \\dfrac{\\beta}{\\Lambda\\, \\lambda_d} A(0)$\n\n**物理和数值参数：**\n- $L = 100\\,\\mathrm{cm}$\n- $\\beta = 0.0065$\n- $\\Lambda = 1.0\\times 10^{-4}\\,\\mathrm{s}$\n- $\\lambda_d = 0.08\\,\\mathrm{s}^{-1}$\n- $\\gamma = 20.0\\,\\mathrm{s}^{-1}$\n- $\\chi = 1.0$\n- $\\eta = 0.2$\n- 空间网格点数：$N_x = 200$\n- 时间步长：$\\Delta t = 0.001\\,\\mathrm{s}$\n\n**$r_{\\mathrm{ext}}(x,t)$ 的测试案例：**\n1.  **案例 1 (非均匀斜坡)：** $r_{\\mathrm{ext}}(x,t) = r_{\\max} \\, \\mathrm{ramp}(t) \\, \\dfrac{\\exp(-x/\\ell)}{\\max_{x\\in[0,L]} \\exp(-x/\\ell)}$\n    - $r_{\\max} = 0.003$\n    - $\\ell = L/5 = 20\\,\\mathrm{cm}$\n    - $\\mathrm{ramp}(t) = \\min(t/T_r,1)$ 其中 $T_r = 1.0\\,\\mathrm{s}$\n    - 最终时间：$T = 3.0\\,\\mathrm{s}$\n2.  **案例 2 (均匀阶跃)：** $r_{\\mathrm{ext}}(x,t) = r_0 = 0.003$\n    - 最终时间：$T = 3.0\\,\\mathrm{s}$\n3.  **案例 3 (边界脉冲)：** $r_{\\mathrm{ext}}(x,t) = r_p\\, \\mathbf{1}_{[0,T_p]}(t)\\, \\dfrac{\\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}{\\max_{x\\in[0,L]} \\exp\\left(-\\dfrac{x^2}{2\\sigma^2}\\right)}$\n    - $r_p = 0.01$\n    - $T_p = 0.2\\,\\mathrm{s}$\n    - $\\sigma = L/20 = 5\\,\\mathrm{cm}$\n    - 最终时间：$T = 1.0\\,\\mathrm{s}$\n\n**要求输出：**\n对于每个案例，计算并报告：\n1.  $\\max_{t\\in[0,T]} |A(t) - A_{\\mathrm{PK}}(t)|$\n2.  $\\int_0^T |\\rho_{\\mathrm{shape}}(t)|\\,dt$\n\n### 步骤2：使用提取的已知条件进行验证\n\n- **科学依据：**该问题使用了一个标准的、成熟的反应堆动力学简化模型，即基于中子通量因子分解的准静态方法。点动力学方程是反应堆物理的基础。所有方程都代表了物理上合理的现象（反应性反馈、模态激励、先驱核衰变）。该问题在科学上是合理的。\n- **适定性：**所有必需的物理参数、初始条件、边界条件和强迫函数都已明确提供。常微分方程组 (ODEs) 定义良好。数值方法（预测-校正）也已指定。对于给定的参数和时间尺度，预期会有一个唯一的、稳定的解。在 $\\rho_{\\mathrm{avg,PK}}(t)$ 的定义中存在一个模糊之处：它指定使用未归一化的 $S_0(x)$ 进行加权，而通量加权的一般原则意味着应使用归一化的加权函数。一个一致的解释，即假设 PK 模型使用归一化的基波形状，可以解决这个问题并且在科学上是合理的。这种解释是 PK 的固定形状是归一化后的基波模式，与归一化约束 $\\int_0^L S(x,t)\\, dx = 1$ 一致。\n- **客观性：**该问题使用精确的数学和物理术语陈述，没有主观语言。任务是定量的和可验证的。\n\n该问题没有列出的无效性缺陷。关于归一化的微小模糊之处可以通过一个标准的、逻辑的、与问题整体框架一致的解释来解决。\n\n### 步骤3：结论与行动\n\n该问题被判定为**有效**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该解决方案需要对两个耦合的常微分方程组随时间进行数值积分：一个用于 PCQS 模型，另一个用于 PK 模型。将采用指定的预测-校正（梯形）方法进行时间积分，并采用梯形法则进行空间积分。\n\n**1. 系统公式化**\n两个模型的状态向量为：\n- PCQS: $\\mathbf{y}(t) = [A(t), C(t), b_1(t)]^T$\n- PK: $\\mathbf{y}_{\\mathrm{PK}}(t) = [A_{\\mathrm{PK}}(t), C_{\\mathrm{PK}}(t)]^T$\n\n该常微分方程组可以写成标准形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y}, t)$。\n\n**2. 空间离散化与归一化**\n使用一个均匀的空间网格 $x_i = i \\cdot \\Delta x$（其中 $i=0, 1, \\dots, N_x-1$），$\\Delta x = L/(N_x-1)$。形式为 $\\int_0^L g(x) dx$ 的空间积分使用数值梯形法则计算。\n\n基函数为 $S_0(x) = \\sin(\\pi x/L)$ 和 $S_1(x) = \\sin(2\\pi x/L)$。一个关键的解析简化来自于它们在区间 $[0,L]$ 上的正交性。\n- 形状的归一化积分为 $I_S = \\int_0^L \\tilde{S}(x,t) dx = \\int_0^L (S_0(x) + b_1(t)S_1(x)) dx$。\n- 由于 $\\int_0^L S_1(x) dx = \\int_0^L \\sin(2\\pi x/L) dx = 0$，该积分简化为 $I_S = \\int_0^L S_0(x) dx = \\int_0^L \\sin(\\pi x/L) dx = [-\\frac{L}{\\pi}\\cos(\\frac{\\pi x}{L})]^L_0 = \\frac{2L}{\\pi}$。\n- PCQS 模型的归一化形状为 $S(x,t) = \\frac{\\tilde{S}(x,t)}{I_S} = \\frac{\\pi}{2L}(S_0(x) + b_1(t)S_1(x))$。\n- PK 模型的固定、归一化形状为 $S_{0,\\mathrm{norm}}(x) = \\frac{S_0(x)}{I_S} = \\frac{\\pi}{2L}S_0(x)$。这通过确保一致的归一化解决了问题陈述中关于 $\\rho_{\\mathrm{avg,PK}}$ 的模糊性。\n\n**3. 时间积分：预测-校正方法**\n对于一个通用常微分方程 $\\frac{dy}{dt} = f(y, t)$，从时间 $t_n$ 到 $t_{n+1}=t_n+\\Delta t$ 的更新是一个两步过程：\n- **预测步骤（前向欧拉法）：**计算一个显式估计值 $y^*_{n+1}$。\n  $y^*_{n+1} = y_n + \\Delta t \\cdot f(y_n, t_n)$\n- **校正步骤（梯形法则）：**最终值 $y_{n+1}$ 使用区间起点和终点斜率的平均值计算，其中终点斜率使用预测值进行评估。\n  $y_{n+1} = y_n + \\frac{\\Delta t}{2} [f(y_n, t_n) + f(y^*_{n+1}, t_{n+1})]$\n\n此方案将应用于状态向量 $\\mathbf{y}$ 和 $\\mathbf{y}_{\\mathrm{PK}}$。\n\n**4. 单个时间步的算法**\n设在时间 $t_n$ 时，PCQS 的状态为 $(A_n, C_n, b_{1,n})$，PK 的状态为 $(A_{\\mathrm{PK},n}, C_{\\mathrm{PK},n})$。\n\n- **A 部分：计算在 $t_n$ 处的导数**\n  1. 在空间网格上计算外部反应性 $r_{\\mathrm{ext}}(x, t_n)$。\n  2. 对于 PCQS：\n     - 使用 $b_{1,n}$ 计算当前归一化形状 $S_n(x)$。\n     - 计算反应性 $\\rho_{\\mathrm{avg},n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n)S_n(x)dx$ 和 $\\rho_{\\mathrm{shape},n} = -\\eta b_{1,n}^2$。\n     - 计算总反应性 $\\rho_{\\mathrm{eff},n} = \\rho_{\\mathrm{avg},n} + \\rho_{\\mathrm{shape},n}$。\n     - 计算一阶谐波强迫项 $G_{1,n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n)S_1(x)dx$。\n     - 计算导数 $\\frac{dA}{dt}|_n$、$\\frac{dC}{dt}|_n$、$\\frac{db_1}{dt}|_n$。\n  3. 对于 PK：\n     - 计算反应性 $\\rho_{\\mathrm{avg,PK},n} = \\int_0^L r_{\\mathrm{ext}}(x, t_n) S_{0,\\mathrm{norm}}(x)dx$。\n     - 计算导数 $\\frac{dA_{\\mathrm{PK}}}{dt}|_n$、$\\frac{dC_{\\mathrm{PK}}}{dt}|_n$。\n\n- **B 部分：预测步骤**\n  1. 使用 A 部分的导数和前向欧拉步，计算在 $t_{n+1}$ 的预测状态：$(A^*_{n+1}, C^*_{n+1}, b^*_{1,n+1})$ 和 $(A^*_{\\mathrm{PK},n+1}, C^*_{\\mathrm{PK},n+1})$。\n\n- **C 部分：使用预测状态计算在 $t_{n+1}$ 处的导数**\n  1. 在空间网格上计算外部反应性 $r_{\\mathrm{ext}}(x, t_{n+1})$。\n  2. 对于 PCQS：\n     - 使用 $b^*_{1,n+1}$ 定义预测形状 $S^*_{n+1}(x)$。\n     - 使用 $r_{\\mathrm{ext}}(x, t_{n+1})$ 和预测状态计算预测反应性 $\\rho^*_{\\mathrm{avg},n+1}$、$\\rho^*_{\\mathrm{shape},n+1}$、$\\rho^*_{\\mathrm{eff},n+1}$ 和强迫项 $G^*_{1,n+1}$。\n     - 使用预测状态和反应性计算预测导数：$(\\frac{d\\mathbf{y}}{dt})^*_{n+1}$。\n  3. 对于 PK：\n     - 使用 $r_{\\mathrm{ext}}(x,t_{n+1})$ 计算预测反应性 $\\rho^*_{\\mathrm{avg,PK},n+1}$。\n     - 使用预测状态和反应性计算预测导数 $(\\frac{d\\mathbf{y}_{\\mathrm{PK}}}{dt})^*_{n+1}$。\n\n- **D 部分：校正步骤**\n  1. 对两个模型，使用梯形法则，通过平均 A 部分和 C 部分的导数，计算在 $t_{n+1}$ 的最终状态。\n\n对从 $t=0$ 到最终时间 $T$ 的所有时间步重复此过程。在仿真期间，每个时间步的 $A(t)$、$A_{\\mathrm{PK}}(t)$ 和 $\\rho_{\\mathrm{shape}}(t)$ 的值都被存储下来，以便在仿真完成后计算所需的输出指标。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reactor dynamics problem for three cases using PCQS and PK models.\n    \"\"\"\n    \n    # Physical and numerical parameters\n    L = 100.0  # cm\n    beta = 0.0065\n    Lambda = 1.0e-4  # s\n    lambda_d = 0.08  # s^-1\n    gamma = 20.0  # s^-1\n    chi = 1.0\n    eta = 0.2\n    \n    Nx = 200\n    dt = 0.001  # s\n\n    # Spatial grid and basis functions\n    x_grid = np.linspace(0, L, Nx)\n    S0 = np.sin(np.pi * x_grid / L)\n    S1 = np.sin(2 * np.pi * x_grid / L)\n    \n    # Normalization integral (analytically 2*L/pi)\n    norm_S0 = np.trapz(S0, x_grid) \n    S0_norm = S0 / norm_S0\n    \n    # Test cases defined as dictionaries\n    test_cases = [\n        {\n            \"T_final\": 3.0,\n            \"r_ext_func\": lambda x, t: 0.003 * min(t / 1.0, 1.0) * np.exp(-x / 20.0),\n        },\n        {\n            \"T_final\": 3.0,\n            \"r_ext_func\": lambda x, t: 0.003 * np.ones_like(x),\n        },\n        {\n            \"T_final\": 1.0,\n            \"r_ext_func\": lambda x, t: 0.01 * (1.0 if t = 0.2 else 0.0) * np.exp(-x**2 / (2 * 5.0**2)),\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        T_final = case[\"T_final\"]\n        r_ext_func = case[\"r_ext_func\"]\n        \n        # Time steps\n        t_steps = np.arange(0, T_final + dt, dt)\n        num_steps = len(t_steps)\n\n        # Initial conditions\n        A0 = 1.0\n        C0 = (beta / (Lambda * lambda_d)) * A0\n        b1_0 = 0.0\n\n        # PCQS history arrays\n        A_hist = np.zeros(num_steps)\n        C_hist = np.zeros(num_steps)\n        b1_hist = np.zeros(num_steps)\n        rho_shape_hist = np.zeros(num_steps)\n        \n        # PK history arrays\n        A_pk_hist = np.zeros(num_steps)\n        C_pk_hist = np.zeros(num_steps)\n        \n        # Set initial values\n        A_hist[0], C_hist[0], b1_hist[0] = A0, C0, b1_0\n        A_pk_hist[0], C_pk_hist[0] = A0, C0\n        rho_shape_hist[0] = -eta * b1_0**2\n\n        # Main time loop\n        for i in range(num_steps - 1):\n            t_n = t_steps[i]\n            t_n1 = t_steps[i+1]\n            \n            # --- Current step (n) derivatives ---\n            A_n, C_n, b1_n = A_hist[i], C_hist[i], b1_hist[i]\n            A_pk_n, C_pk_n = A_pk_hist[i], C_pk_hist[i]\n\n            r_ext_n = r_ext_func(x_grid, t_n)\n\n            # PCQS derivatives at n\n            S_n = (S0 + b1_n * S1) / norm_S0\n            rho_avg_n = np.trapz(r_ext_n * S_n, x_grid)\n            rho_shape_n = -eta * b1_n**2\n            rho_eff_n = rho_avg_n + rho_shape_n\n            G1_n = np.trapz(r_ext_n * S1, x_grid)\n\n            f_A_n = ((rho_eff_n - beta) / Lambda) * A_n + lambda_d * C_n\n            f_C_n = (beta / Lambda) * A_n - lambda_d * C_n\n            f_b1_n = -gamma * b1_n + chi * G1_n\n\n            # PK derivatives at n\n            rho_avg_pk_n = np.trapz(r_ext_n * S0_norm, x_grid)\n            f_A_pk_n = ((rho_avg_pk_n - beta) / Lambda) * A_pk_n + lambda_d * C_pk_n\n            f_C_pk_n = (beta / Lambda) * A_pk_n - lambda_d * C_pk_n\n\n            # --- Predictor step ---\n            A_star = A_n + dt * f_A_n\n            C_star = C_n + dt * f_C_n\n            b1_star = b1_n + dt * f_b1_n\n            \n            A_pk_star = A_pk_n + dt * f_A_pk_n\n            C_pk_star = C_pk_n + dt * f_C_pk_n\n\n            # --- Predicted step (n+1) derivatives ---\n            r_ext_n1 = r_ext_func(x_grid, t_n1)\n\n            # PCQS derivatives at n+1\n            S_star = (S0 + b1_star * S1) / norm_S0\n            rho_avg_star = np.trapz(r_ext_n1 * S_star, x_grid)\n            rho_shape_star = -eta * b1_star**2\n            rho_eff_star = rho_avg_star + rho_shape_star\n            G1_star = np.trapz(r_ext_n1 * S1, x_grid)\n\n            f_A_star = ((rho_eff_star - beta) / Lambda) * A_star + lambda_d * C_star\n            f_C_star = (beta / Lambda) * A_star - lambda_d * C_star\n            f_b1_star = -gamma * b1_star + chi * G1_star\n            \n            # PK derivatives at n+1\n            rho_avg_pk_star = np.trapz(r_ext_n1 * S0_norm, x_grid)\n            f_A_pk_star = ((rho_avg_pk_star - beta) / Lambda) * A_pk_star + lambda_d * C_pk_star\n            f_C_pk_star = (beta / Lambda) * A_pk_star - lambda_d * C_pk_star\n            \n            # --- Corrector step ---\n            A_hist[i+1] = A_n + 0.5 * dt * (f_A_n + f_A_star)\n            C_hist[i+1] = C_n + 0.5 * dt * (f_C_n + f_C_star)\n            b1_hist[i+1] = b1_n + 0.5 * dt * (f_b1_n + f_b1_star)\n            \n            A_pk_hist[i+1] = A_pk_n + 0.5 * dt * (f_A_pk_n + f_A_pk_star)\n            C_pk_hist[i+1] = C_pk_n + 0.5 * dt * (f_C_pk_n + f_C_pk_star)\n\n            # Store shape reactivity for output calculation\n            rho_shape_hist[i+1] = -eta * b1_hist[i+1]**2\n        \n        # Calculate final metrics for the case\n        max_abs_diff = np.max(np.abs(A_hist - A_pk_hist))\n        shape_corr_integral = np.trapz(np.abs(rho_shape_hist), t_steps)\n        \n        all_results.append([max_abs_diff, shape_corr_integral])\n\n    # Format output\n    result_str = \",\".join([f\"[{res[0]},{res[1]}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "PCQS 方法的精髓在于其预测-校正迭代框架。为了精确掌握其工作机理，本练习将带你深入单个时间步长内部，聚焦于缓发中子先驱核浓度的更新过程。你将通过具体计算，体验预测步和校正步的通量形状信息如何共同作用于缓发中子源项，从而深化对该方法数值稳定性和准确性来源的理解 。",
            "id": "4242155",
            "problem": "考虑一个均匀热中子反应堆，它由两个空间上均匀的区域（A区和B区）表示，每个区域的体积相等，$V_A = V_B = 1$（任意体积单位）。裂变产生系数是空间相关的，由 $\\nu \\Sigma_{f,A} = 2$ 和 $\\nu \\Sigma_{f,B} = 1$ 给出（任意一致单位）。假设使用预测-校正准静态（PCQS）方法：中子通量被分解为 $\\phi(\\mathbf{r}, t) = P(t) S(\\mathbf{r}, t)$，其中 $P(t)$ 是全局幅度，$S(\\mathbf{r}, t)$ 是形状函数。形状函数被归一化，使得 $\\int_{V} S(\\mathbf{r}, t) \\, dV = 1$。\n\n对于单族 $i$，总缓发中子先驱核浓度（记为 $N_i(t) = \\int_{V} C_i(\\mathbf{r}, t) \\, dV$）遵循由缓发中子源和衰变推导出的空间积分先驱核平衡方程：\n$$\n\\frac{d N_i(t)}{d t} = \\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV - \\lambda_i N_i(t),\n$$\n其中 $\\beta_i$ 是第 $i$ 族的（无量纲）缓发中子份额，$\\lambda_i$ 是其衰变常数。\n\n在一个时长为 $\\Delta T = 0.5 \\ \\mathrm{s}$ 的 PCQS 粗时间步长内，全局幅度从 $P(t) = P_0 = 1.0$ 增加到 $P(t + \\Delta T) = P_1 = 1.2$。形状从时间步开始时的预测形状，\n$$\nS(\\mathbf{r}, t): \\quad s_A^{p,0} = 0.55, \\quad s_B^{p,0} = 0.45,\n$$\n更新到时间步结束时的校正形状，\n$$\nS(\\mathbf{r}, t+\\Delta T): \\quad s_A^{c,1} = 0.60, \\quad s_B^{c,1} = 0.40,\n$$\n形状归一化在每个时刻都满足 $\\int_{V} S(\\mathbf{r}, t) \\, dV = s_A + s_B = 1$。\n\n设初始先驱核浓度为 $N_i(t) = N_0 = 2.000 \\times 10^{-2}$（归一化浓度单位），缓发中子份额为 $\\beta_i = 1.00 \\times 10^{-3}$，衰变常数为 $\\lambda_i = 8.0 \\times 10^{-2} \\ \\mathrm{s}^{-1}$。\n\n使用 PCQS 预测-校正更新，将在粗时间步长内，源项 $\\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV$ 近似为其在 $t$ 时刻的预测值和 $t+\\Delta T$ 时刻的校正值之间的线性变化，并使用先驱核常微分方程的积分因子精确解来计算 $N_i(t+\\Delta T)$。使用给定的 $s_A$ 和 $s_B$，明确计算在时间步开始和结束时的形状加权裂变产生积分。\n\n将 $N_i(t+\\Delta T)$ 的最终答案四舍五入至五位有效数字。以与 $N_i(t)$ 相同的归一化浓度单位表示最终浓度。",
            "solution": "该问题被验证为具有科学依据、提法得当且客观。这是一个使用预测-校正准静态（PCQS）方法的核反应堆动力学标准问题。所有提供的数据都是一致的，并且足以得到唯一解。\n\n该问题要求计算在时长为 $\\Delta T$ 的时间步结束时，单族 $i$ 的总缓发中子先驱核浓度 $N_i(t+\\Delta T)$。$N_i(t)$ 的演化由以下常微分方程（ODE）决定：\n$$\n\\frac{d N_i(t)}{d t} = Q_i(t) - \\lambda_i N_i(t)\n$$\n其中 $Q_i(t)$ 是源项，由下式给出：\n$$\nQ_i(t) = \\beta_i P(t) \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV\n$$\n该问题定义在时间区间 $[t_0, t_0+\\Delta T]$ 上。为简单起见，我们设 $t_0=0$，因此区间为 $[0, \\Delta T]$。\n\n首先，我们必须计算在时间步开始时（$t=0$）和结束时（$t=\\Delta T$）的源项 $Q_i(t)$。该积分表示形状加权的裂变产生率，我们将其记为 $F(t) = \\int_V \\nu \\Sigma_f(\\mathbf{r}) S(\\mathbf{r}, t) \\, dV$。由于反应堆由两个均匀区域 A 和 B 组成，该积分变为：\n$$\nF(t) = \\int_{V_A} \\nu \\Sigma_{f,A} S(\\mathbf{r}, t) \\, dV + \\int_{V_B} \\nu \\Sigma_{f,B} S(\\mathbf{r}, t) \\, dV\n$$\n问题陈述，形状函数 $S(\\mathbf{r},t)$ 在每个区域内空间均匀，其值分别为 $s_A(t)$ 和 $s_B(t)$。给定 $V_A = V_B = 1$（任意体积单位），该积分简化为：\n$$\nF(t) = (\\nu \\Sigma_{f,A}) s_A(t) V_A + (\\nu \\Sigma_{f,B}) s_B(t) V_B = (\\nu \\Sigma_{f,A}) s_A(t) + (\\nu \\Sigma_{f,B}) s_B(t)\n$$\n\n在时间步开始时（$t=0$），我们使用预测形状和初始幅度：\n- $\\nu \\Sigma_{f,A} = 2$, $\\nu \\Sigma_{f,B} = 1$\n- $s_A(0) = s_A^{p,0} = 0.55$, $s_B(0) = s_B^{p,0} = 0.45$\n- $P(0) = P_0 = 1.0$\n- $\\beta_i = 1.00 \\times 10^{-3} = 0.001$\n\n在 $t=0$ 时的形状加权裂变产生率为：\n$$\nF_0 = F(0) = (2)(0.55) + (1)(0.45) = 1.10 + 0.45 = 1.55\n$$\n在 $t=0$ 时的源项为：\n$$\nQ_{i,0} = \\beta_i P_0 F_0 = (0.001)(1.0)(1.55) = 0.00155\n$$\n\n在时间步结束时（$t=\\Delta T$），我们使用校正形状和最终幅度：\n- $s_A(\\Delta T) = s_A^{c,1} = 0.60$, $s_B(\\Delta T) = s_B^{c,1} = 0.40$\n- $P(\\Delta T) = P_1 = 1.2$\n\n在 $t=\\Delta T$ 时的形状加权裂变产生率为：\n$$\nF_1 = F(\\Delta T) = (2)(0.60) + (1)(0.40) = 1.20 + 0.40 = 1.60\n$$\n在 $t=\\Delta T$ 时的源项为：\n$$\nQ_{i,1} = \\beta_i P_1 F_1 = (0.001)(1.2)(1.60) = 0.00192\n$$\n\n问题指定将源项 $Q_i(t')$ 在时间步 $t' \\in [0, \\Delta T]$ 内近似为线性变化：\n$$\nQ_i(t') = Q_{i,0} + \\frac{Q_{i,1} - Q_{i,0}}{\\Delta T} t'\n$$\nODE 为 $\\frac{d N_i}{dt'} + \\lambda_i N_i = Q_i(t')$。使用积分因子 $\\exp(\\lambda_i t')$， $N_i(\\Delta T)$ 的精确解为：\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + \\exp(-\\lambda_i \\Delta T) \\int_{0}^{\\Delta T} Q_i(t') \\exp(\\lambda_i t') dt'\n$$\n积分部分代表了源项的贡献。我们使用 $Q_i(t')$ 的线性近似来计算这个积分。一个方便的积分变量替换是 $u = \\Delta T - t'$，这会得到如下解的形式：\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + \\int_{0}^{\\Delta T} Q_i(\\Delta T - u) \\exp(-\\lambda_i u) du\n$$\n用 $u$ 表示的线性源项是 $Q_i(\\Delta T - u) = Q_{i,1} - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T}u$。\n源项贡献为：\n$$\n\\int_0^{\\Delta T} \\left( Q_{i,1} - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T} u \\right) \\exp(-\\lambda_i u) du = Q_{i,1} \\int_0^{\\Delta T} \\exp(-\\lambda_i u) du - \\frac{Q_{i,1}-Q_{i,0}}{\\Delta T} \\int_0^{\\Delta T} u \\exp(-\\lambda_i u) du\n$$\n计算这两个积分得到：\n$$\n\\int_0^{\\Delta T} \\exp(-\\lambda_i u) du = \\frac{1 - \\exp(-\\lambda_i \\Delta T)}{\\lambda_i}\n$$\n$$\n\\int_0^{\\Delta T} u \\exp(-\\lambda_i u) du = \\frac{1}{\\lambda_i^2} - \\frac{\\Delta T \\exp(-\\lambda_i \\Delta T)}{\\lambda_i} - \\frac{\\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2}\n$$\n结合这些结果，并按 $Q_{i,0}$ 和 $Q_{i,1}$ 对各项进行分组，我们得到解析解：\n$$\nN_i(\\Delta T) = N_i(0) \\exp(-\\lambda_i \\Delta T) + Q_{i,0} \\left( \\frac{1 - \\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2 \\Delta T} - \\frac{\\exp(-\\lambda_i \\Delta T)}{\\lambda_i} \\right) + Q_{i,1} \\left( \\frac{\\lambda_i \\Delta T - 1 + \\exp(-\\lambda_i \\Delta T)}{\\lambda_i^2 \\Delta T} \\right)\n$$\n现在我们代入数值：\n- 初始浓度：$N_i(0) = N_0 = 2.000 \\times 10^{-2} = 0.02$\n- 衰变常数：$\\lambda_i = 8.0 \\times 10^{-2} \\ \\mathrm{s}^{-1} = 0.08 \\ \\mathrm{s}^{-1}$\n- 时间步长：$\\Delta T = 0.5 \\ \\mathrm{s}$\n- $Q_{i,0} = 0.00155$\n- $Q_{i,1} = 0.00192$\n\n我们计算解中的各项：\n- $\\lambda_i \\Delta T = (0.08)(0.5) = 0.04$\n- $\\exp(-\\lambda_i \\Delta T) = \\exp(-0.04) \\approx 0.960789439$\n- $\\lambda_i^2 \\Delta T = (0.08)^2 (0.5) = (0.0064)(0.5) = 0.0032$\n\n$Q_{i,0}$ 的系数是：\n$$\n\\frac{1 - \\exp(-0.04)}{(0.0032)} - \\frac{\\exp(-0.04)}{0.08} = \\frac{1 - 0.960789439}{0.0032} - \\frac{0.960789439}{0.08} \\approx 12.253300 - 12.009868 = 0.243432\n$$\n$Q_{i,1}$ 的系数是：\n$$\n\\frac{0.04 - 1 + \\exp(-0.04)}{0.0032} = \\frac{0.04 - 1 + 0.960789439}{0.0032} = \\frac{0.000789439}{0.0032} \\approx 0.2466998\n$$\n现在，我们计算 $N_i(\\Delta T)$：\n$$\nN_i(\\Delta T) = (0.02) \\exp(-0.04) + (0.00155)(0.243432) + (0.00192)(0.2466998)\n$$\n$$\nN_i(\\Delta T) \\approx (0.02)(0.960789439) + 0.0003773196 + 0.0004736636\n$$\n$$\nN_i(\\Delta T) \\approx 0.0192157888 + 0.0003773196 + 0.0004736636\n$$\n$$\nN_i(\\Delta T) \\approx 0.020066772\n$$\n按要求四舍五入到五位有效数字：\n$$\nN_i(t+\\Delta T) \\approx 0.020067\n$$",
            "answer": "$$\\boxed{0.020067}$$"
        }
    ]
}