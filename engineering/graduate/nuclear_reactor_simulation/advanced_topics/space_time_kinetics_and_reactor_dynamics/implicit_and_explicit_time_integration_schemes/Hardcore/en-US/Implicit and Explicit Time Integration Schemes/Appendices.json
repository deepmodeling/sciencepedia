{
    "hands_on_practices": [
        {
            "introduction": "To effectively choose a time integration scheme, one must first understand how it behaves when applied to equations with vastly different time scales. This first practice explores the concept of stiffness and numerical stability through the lens of the stability function, $R(z)$. By applying the popular Crank-Nicolson method to a model system with both a \"fast\" (stiff) and a \"slow\" mode, you will discover that A-stability does not always guarantee a physically accurate result, as spurious oscillations can arise in the stiff components . This exercise is fundamental to developing an intuition for the potential pitfalls of numerical methods.",
            "id": "4231279",
            "problem": "In coupled neutron-thermal-hydraulic transients of a nuclear reactor, linearization and modal decomposition about a steady state often yield independent scalar modes that each satisfy a linear ordinary differential equation (ODE) of the form $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$ is a modal eigenvalue. Consider a representative two-timescale situation in which one mode is stiff with eigenvalue $\\lambda_{1} = -10^{5}\\,\\text{s}^{-1}$ and another mode is slow with eigenvalue $\\lambda_{2} = -10\\,\\text{s}^{-1}$. You will analyze the time discretization of such modes using the Crank–Nicolson (CN) scheme.\n\nStarting from the defining update of the Crank–Nicolson (CN) method applied to the scalar linear ODE $y'(t) = \\lambda y(t)$ over a uniform time step $\\Delta t$, derive the scalar stability (amplification) function $R(z)$ in terms of the dimensionless quantity $z = \\lambda \\Delta t$. Then, for a time step $\\Delta t = 10^{-3}\\,\\text{s}$, evaluate $R(z)$ for both $z_{1} = \\lambda_{1}\\Delta t$ and $z_{2} = \\lambda_{2}\\Delta t$, and use the sign and magnitude of each amplification factor to infer whether the discrete-time response of each mode is oscillatory between steps.\n\nReport only the numerical value of the amplification factor for the stiff mode, that is $R(z_{1})$, as your final answer. Express the result as a pure number (dimensionless) and round your answer to $8$ significant figures.",
            "solution": "The user has specified a problem concerning the numerical stability analysis of an ordinary differential equation (ODE) representative of modal dynamics in a nuclear reactor. The first step is to validate the problem statement. The problem provides a well-defined physical context (coupled neutronics and thermal-hydraulics), a standard mathematical model ($y'(t) = \\lambda y(t)$), specific parameters ($\\lambda_1 = -10^5\\,\\text{s}^{-1}$, $\\lambda_2 = -10\\,\\text{s}^{-1}$, $\\Delta t = 10^{-3}\\,\\text{s}$), a defined numerical method (Crank-Nicolson), and a clear set of tasks. The problem is scientifically grounded, objective, self-contained, and well-posed. No inconsistencies, contradictions, or violations of physical principles are present. Therefore, the problem is deemed valid and a full solution can be constructed.\n\nThe problem is centered on the scalar linear ODE:\n$$\ny'(t) = \\lambda y(t)\n$$\nThe Crank-Nicolson (CN) scheme is used to discretize this equation in time. For a uniform time step $\\Delta t$, the value of the solution at step $n+1$, denoted $y_{n+1}$, is related to the value at step $n$, denoted $y_n$, by applying a centered-difference approximation for the derivative and an average for the right-hand side term:\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\frac{1}{2} \\left( \\lambda y_n + \\lambda y_{n+1} \\right)\n$$\nThe problem asks for the derivation of the scalar stability (or amplification) function, $R(z)$, which is defined by the relation $y_{n+1} = R(z) y_n$, where $z = \\lambda \\Delta t$. To derive $R(z)$, we rearrange the discretized CN equation.\n\nFirst, multiply both sides by $\\Delta t$:\n$$\ny_{n+1} - y_n = \\frac{\\lambda \\Delta t}{2} (y_n + y_{n+1})\n$$\nSubstitute the dimensionless quantity $z = \\lambda \\Delta t$:\n$$\ny_{n+1} - y_n = \\frac{z}{2} (y_n + y_{n+1})\n$$\nTo solve for $y_{n+1}$, we gather all terms containing $y_{n+1}$ on the left-hand side and all terms containing $y_n$ on the right-hand side:\n$$\ny_{n+1} - \\frac{z}{2} y_{n+1} = y_n + \\frac{z}{2} y_n\n$$\nFactor out $y_{n+1}$ and $y_n$:\n$$\ny_{n+1} \\left( 1 - \\frac{z}{2} \\right) = y_n \\left( 1 + \\frac{z}{2} \\right)\n$$\nDividing by the factor on the left provides the explicit update rule for $y_{n+1}$:\n$$\ny_{n+1} = \\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}} y_n\n$$\nFrom this expression, we identify the stability function $R(z)$ as the coefficient multiplying $y_n$:\n$$\nR(z) = \\frac{1 + \\frac{z}{2}}{1 - \\frac{z}{2}}\n$$\nNext, we evaluate $R(z)$ for the two specified modes using the time step $\\Delta t = 10^{-3}\\,\\text{s}$.\n\nFor the stiff mode, the eigenvalue is $\\lambda_1 = -10^5\\,\\text{s}^{-1}$. The corresponding value of $z$ is:\n$$\nz_1 = \\lambda_1 \\Delta t = (-10^5\\,\\text{s}^{-1}) (10^{-3}\\,\\text{s}) = -100\n$$\nThe amplification factor for the stiff mode is:\n$$\nR(z_1) = R(-100) = \\frac{1 + \\frac{-100}{2}}{1 - \\frac{-100}{2}} = \\frac{1 - 50}{1 + 50} = \\frac{-49}{51}\n$$\n\nFor the slow mode, the eigenvalue is $\\lambda_2 = -10\\,\\text{s}^{-1}$. The corresponding value of $z$ is:\n$$\nz_2 = \\lambda_2 \\Delta t = (-10\\,\\text{s}^{-1}) (10^{-3}\\,\\text{s}) = -0.01\n$$\nThe amplification factor for the slow mode is:\n$$\nR(z_2) = R(-0.01) = \\frac{1 + \\frac{-0.01}{2}}{1 - \\frac{-0.01}{2}} = \\frac{1 - 0.005}{1 + 0.005} = \\frac{0.995}{1.005}\n$$\nThe discrete-time response is oscillatory if the amplification factor is negative, since this causes the sign of the solution to flip at each time step.\nFor the stiff mode, $R(z_1) = -49/51  0$. This indicates that the numerical solution for this mode will be oscillatory. The magnitude is $|R(z_1)| = 49/51  1$, so the oscillations are numerically stable (i.e., their amplitude does not grow), but they are poorly damped. This is a spurious numerical effect, as the true solution decays monotonically.\nFor the slow mode, $R(z_2) \\approx 0.99 > 0$. The response is non-oscillatory and stable, accurately capturing the monotonic decay of the physical mode.\n\nThe final task is to report the numerical value of the amplification factor for the stiff mode, $R(z_1)$, rounded to $8$ significant figures.\n$$\nR(z_1) = -\\frac{49}{51} \\approx -0.960784313725...\n$$\nRounding to $8$ significant figures, we get $-0.96078431$.",
            "answer": "$$\n\\boxed{-0.96078431}\n$$"
        },
        {
            "introduction": "While implicit methods offer superior stability, explicit methods are simpler to implement and computationally cheaper per step. Their main drawback is a strict limitation on the time step size, a constraint that is directly linked to the spatial discretization of the underlying PDE. This exercise asks you to derive this stability limit for the Forward Euler method applied to a diffusion problem, a classic model for heat or neutron transport . By relating the spectral radius of the discretized spatial operator to the time step $\\Delta t$, you will quantify the famous stability condition $\\Delta t \\propto h^2$, providing a concrete understanding of why fine spatial meshes make explicit methods prohibitively expensive.",
            "id": "4231362",
            "problem": "Consider one-dimensional heat diffusion in a homogeneous slab representative of a radial line in a nuclear fuel pellet, governed by the partial differential equation $\\frac{\\partial \\phi}{\\partial t} = D \\frac{\\partial^{2} \\phi}{\\partial x^{2}}$, where $\\phi(x,t)$ is the temperature-like scalar field and $D$ is the thermal diffusivity. Discretize the spatial domain with a uniform mesh of spacing $h$ using linear basis functions in the Finite Element (FE) method, and assume homogeneous Dirichlet boundary conditions at the ends of a large slab. The semi-discrete system takes the canonical form $M \\dot{\\boldsymbol{\\phi}} + K \\boldsymbol{\\phi} = \\boldsymbol{0}$, where $M$ is the consistent mass matrix and $K$ is the stiffness matrix arising from the bilinear forms associated with the diffusion operator. \n\nStarting from the standard weak form and assembly rules for linear elements on a uniform mesh, derive the spectral radius $\\rho(M^{-1}K)$ by analyzing the generalized eigenvalue problem $K \\boldsymbol{v} = \\lambda M \\boldsymbol{v}$ for mode shapes corresponding to discrete sines on a uniform grid. Use this to obtain a conservative closed-form estimate for the Forward Euler time step $\\Delta t_{\\text{FE}}$ required for absolute stability when integrating $\\dot{\\boldsymbol{\\phi}} = - M^{-1} K \\boldsymbol{\\phi}$ with the Forward Euler method. \n\nTake the thermal diffusivity to be $D = 1$ $\\text{cm}^{2}\\,\\text{s}^{-1}$ and the mesh size to be $h = 0.5$ $\\text{cm}$. Round your final time step to four significant figures and express your answer in seconds.",
            "solution": "This problem requires deriving the stability limit for the Forward Euler method applied to the semi-discretized 1D diffusion equation obtained via the Finite Element Method (FEM) with linear basis functions. The semi-discrete system is $\\dot{\\boldsymbol{\\phi}} = -M^{-1}K \\boldsymbol{\\phi}$.\n\n1.  **System Eigenvalues**: The stability of the Forward Euler method for the system $\\dot{\\mathbf{y}} = \\mathbf{A}\\mathbf{y}$ is governed by the eigenvalues of the matrix $\\mathbf{A}$. Here, $\\mathbf{A} = -M^{-1}K$. The eigenvalues of this system matrix are $-\\lambda_{s,j}$, where $\\lambda_{s,j}$ are the solutions to the generalized eigenvalue problem $K \\boldsymbol{v}_j = \\lambda_{s,j} M \\boldsymbol{v}_j$.\n\n2.  **Forward Euler Stability Condition**: For the test equation $\\dot{y} = \\sigma y$ with $\\sigma$ being a real, negative number (as our system matrix $-M^{-1}K$ is negative definite), the Forward Euler stability condition $|1 + \\sigma \\Delta t| \\le 1$ simplifies to $\\Delta t \\le -2/\\sigma$. In our case, the eigenvalues of the system matrix are $\\sigma_j = -\\lambda_{s,j}$. The stability constraint is thus determined by the eigenvalue with the largest magnitude, which corresponds to the largest generalized eigenvalue $\\lambda_{s,\\text{max}}$:\n    $$\n    \\Delta t \\le \\frac{2}{\\lambda_{s,\\text{max}}}\n    $$\n\n3.  **FEM Discretization and Generalized Eigenvalues**: For a 1D uniform mesh with linear \"hat\" basis functions, the stiffness matrix $K$ and consistent mass matrix $M$ have the following structures (ignoring boundary condition rows):\n    $$\n    K = \\frac{D}{h} \\begin{bmatrix} \\ddots    \\\\  -1  2  -1  \\\\    \\ddots \\end{bmatrix}, \\quad M = \\frac{h}{6} \\begin{bmatrix} \\ddots    \\\\  1  4  1  \\\\    \\ddots \\end{bmatrix}\n    $$\n    The eigenvalues $\\lambda_{s,j}$ of the generalized problem $K \\boldsymbol{v}_j = \\lambda_{s,j} M \\boldsymbol{v}_j$ for a grid of size $h$ are given by:\n    $$\n    \\lambda_{s,j} = \\frac{D}{h^2} \\frac{6(1 - \\cos(k_j h))}{2 + \\cos(k_j h)}\n    $$\n    where $k_j = j\\pi/L$ is the wavenumber corresponding to the $j$-th mode on a domain of length $L$.\n\n4.  **Estimating the Maximum Eigenvalue (Spectral Radius)**: The maximum eigenvalue, $\\lambda_{s,\\text{max}}$, corresponds to the highest-frequency mode supported by the mesh. For a large domain, this mode has a wavelength on the order of the mesh spacing, i.e., $2h$. This corresponds to $k_j h \\approx \\pi$, which implies $\\cos(k_j h) \\approx -1$. Substituting this into the eigenvalue formula gives a conservative estimate for the maximum eigenvalue:\n    $$\n    \\lambda_{s,\\text{max}} \\approx \\frac{D}{h^2} \\frac{6(1 - (-1))}{2 + (-1)} = \\frac{D}{h^2} \\frac{6(2)}{1} = \\frac{12D}{h^2}\n    $$\n\n5.  **Deriving the Stability Limit**: We can now substitute this maximum eigenvalue into the Forward Euler stability condition:\n    $$\n    \\Delta t_{\\text{FE}} \\le \\frac{2}{\\lambda_{s,\\text{max}}} = \\frac{2}{\\frac{12D}{h^2}} = \\frac{2h^2}{12D} = \\frac{h^2}{6D}\n    $$\n    This is the well-known stability limit for Forward Euler with a consistent mass matrix FEM discretization of the 1D diffusion equation.\n\n6.  **Numerical Calculation**: We are given $D = 1\\,\\text{cm}^2/\\text{s}$ and $h = 0.5\\,\\text{cm}$.\n    $$\n    \\Delta t_{\\text{FE}} \\le \\frac{(0.5\\,\\text{cm})^2}{6 \\times (1\\,\\text{cm}^2/\\text{s})} = \\frac{0.25}{6}\\,\\text{s} = \\frac{1/4}{6}\\,\\text{s} = \\frac{1}{24}\\,\\text{s}\n    $$\n    Converting to a decimal value:\n    $$\n    \\Delta t_{\\text{FE}} \\le 0.041666... \\,\\text{s}\n    $$\n    Rounding to four significant figures, the maximum stable time step is $0.04167\\,\\text{s}$.",
            "answer": "$$\n\\boxed{0.04167}\n$$"
        },
        {
            "introduction": "Real-world reactor physics models are rarely purely stiff or non-stiff; they are often a mix. Implicit-Explicit (IMEX) methods are a powerful approach that treats stiff terms implicitly for stability while handling non-stiff terms explicitly for efficiency. In this final practice, you will move from theory to application by implementing a complete IMEX predictor-corrector scheme for a point reactor kinetics model . This capstone exercise involves not only partitioning the system and coding the algorithm but also developing an adaptive error control strategy, providing invaluable hands-on experience in building a robust and intelligent numerical simulation tool.",
            "id": "4231316",
            "problem": "Consider a semidiscrete model of point reactor kinetics with one delayed neutron group, where the neutron density and the delayed neutron precursor concentration are lumped variables. Let the state vector be $y = [n, c]^{\\top}$ where $n$ is the neutron density and $c$ is the precursor concentration, both expressed in $\\text{cm}^{-3}$. The governing equations are written in mass-matrix form as\n$$\nM \\frac{d y}{d t} = f_I(y) + g(y, t),\n$$\nwhere $M \\in \\mathbb{R}^{2 \\times 2}$ is a diagonal mass matrix capturing lumped capacitances of the variables, the stiff term $f_I(y)$ represents the prompt neutron and delayed neutron linear kinetics, and the nonstiff term $g(y,t)$ represents exogenous sources and mild nonlinear feedback. For one delayed neutron group with zero net reactivity, define\n$$\nf_I(y) = A y, \\quad A = \\begin{bmatrix}\n-\\frac{\\beta}{\\Lambda}  \\lambda \\\\\n\\frac{\\beta}{\\Lambda}  -\\lambda\n\\end{bmatrix},\n$$\nwhere $\\beta$ is the delayed neutron fraction (dimensionless), $\\Lambda$ is the mean neutron generation time in seconds, and $\\lambda$ is the precursor decay constant in $\\text{s}^{-1}$. Define the nonstiff term by\n$$\ng(y,t) = \\begin{bmatrix}\nS_0 e^{-\\sigma t} + \\mu n^2 \\\\\n0\n\\end{bmatrix},\n$$\nwhere $S_0$ is an exogenous source amplitude in $\\text{cm}^{-3}\\,\\text{s}^{-1}$, $\\sigma$ is a source decay rate in $\\text{s}^{-1}$, and $\\mu$ is a small nonlinearity coefficient in $\\text{cm}^{3}\\,\\text{s}^{-1}$.\n\nImplement an Implicit-Explicit (IMEX) predictor-corrector method advancing from time $t_n$ to $t_{n+1}=t_n+\\Delta t$ as follows:\n\n1. Explicit predictor for the nonstiff term:\n$$\nM \\hat{y}^{n+1} = M y^n + \\Delta t\\, g(y^n, t_n).\n$$\n\n2. Implicit corrector for the stiff term using the predicted explicit contribution:\n$$\nM y^{n+1} = M y^n + \\Delta t\\, f_I(y^{n+1}) + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1}).\n$$\n\nDerive and implement a residual-norm acceptance criterion for the explicit predictor based on the mismatch of the explicit term when evaluated at $y^{n+1}$ versus at $\\hat{y}^{n+1}$. Define the residual vector\n$$\nr^{n+1} = M y^{n+1} - M y^n - \\Delta t\\, f_I(y^{n+1}) - \\Delta t\\, g(y^{n+1}, t_{n+1}),\n$$\nwhich satisfies $r^{n+1} = \\Delta t \\left( g(\\hat{y}^{n+1}, t_{n+1}) - g(y^{n+1}, t_{n+1}) \\right)$ in exact arithmetic for the scheme above. Accept the predictor if\n$$\n\\lVert r^{n+1} \\rVert_2 \\le \\tau_{\\text{abs}} + \\tau_{\\text{rel}} \\lVert M y^{n+1} \\rVert_2,\n$$\nwhere $\\tau_{\\text{abs}}$ is an absolute tolerance and $\\tau_{\\text{rel}}$ is a relative tolerance.\n\nIf the predictor is rejected, recompute an improved explicit predictor using a second-order explicit trapezoidal rule (Heun’s method) applied only to the explicit term:\n$$\n\\tilde{y}^{n+1} = y^n + \\Delta t\\, M^{-1} g(y^n, t_n), \\quad \\hat{y}^{n+1}_{\\text{Heun}} = y^n + \\frac{\\Delta t}{2}\\, M^{-1} \\left( g(y^n, t_n) + g(\\tilde{y}^{n+1}, t_{n+1}) \\right),\n$$\nand resolve the implicit corrector using $g(\\hat{y}^{n+1}_{\\text{Heun}}, t_{n+1})$. If the improved predictor is still rejected, split the time step into equal substeps and repeat the procedure on each substep until the acceptance criterion is met. The total time advanced over one base time step $\\Delta t$ must remain exactly $\\Delta t$ by using a partition into substeps whose durations sum to $\\Delta t$; for example, two substeps of $\\Delta t/2$, or four substeps of $\\Delta t/4$, and so on. Count each time the currently used explicit predictor (either the initial explicit Euler predictor or the improved Heun predictor) is rejected as one rejection event.\n\nYour implementation must:\n- Use a linear system solve for the corrector step, since $f_I(y)$ is linear.\n- Use the described acceptance criterion and adaptive substep strategy.\n- Track and report the number of predictor rejections.\n\nPhysical units and outputs:\n- Time $t$ must be in seconds.\n- Neutron density $n$ and precursor concentration $c$ must be expressed in $\\text{cm}^{-3}$.\n- The source amplitude $S_0$ must be in $\\text{cm}^{-3}\\,\\text{s}^{-1}$.\n\nProvide the final outputs for each test case as floats for $n$ and $c$ in $\\text{cm}^{-3}$ and an integer for the rejection count. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[[n1,c1,r1],[n2,c2,r2],[n3,c3,r3]]`).\n\nTest suite:\nImplement the IMEX scheme for the following three test cases, each returned as one list element in the final output. For all cases, use the same tolerances $\\tau_{\\text{abs}} = 10^{-6}$ and $\\tau_{\\text{rel}} = 10^{-4}$.\n\n- Case 1 (happy path, small explicit nonlinearity and small time step):\n    - Parameters: $\\beta = 0.0065$, $\\Lambda = 1.0\\times 10^{-5}\\ \\text{s}$, $\\lambda = 0.08\\ \\text{s}^{-1}$, $\\mu = 1.0\\times 10^{-11}\\ \\text{cm}^{3}\\,\\text{s}^{-1}$, $S_0 = 1.0\\times 10^{4}\\ \\text{cm}^{-3}\\,\\text{s}^{-1}$, $\\sigma = 1.0\\ \\text{s}^{-1}$.\n    - Mass matrix: $M = \\operatorname{diag}(1.0, 1.0)$.\n    - Initial conditions: $n(0) = 1.0\\times 10^{4}\\ \\text{cm}^{-3}$, $c(0) = 0.0\\ \\text{cm}^{-3}$.\n    - Time step: $\\Delta t = 1.0\\times 10^{-4}\\ \\text{s}$, number of base steps $N = 1000$.\n\n- Case 2 (moderate explicit nonlinearity and moderate time step with some predictor rejections expected, nontrivial mass matrix):\n    - Parameters: $\\beta = 0.0065$, $\\Lambda = 1.0\\times 10^{-5}\\ \\text{s}$, $\\lambda = 0.08\\ \\text{s}^{-1}$, $\\mu = 1.0\\times 10^{-7}\\ \\text{cm}^{3}\\,\\text{s}^{-1}$, $S_0 = 1.0\\times 10^{4}\\ \\text{cm}^{-3}\\,\\text{s}^{-1}$, $\\sigma = 1.0\\ \\text{s}^{-1}$.\n    - Mass matrix: $M = \\operatorname{diag}(1.0, 0.5)$.\n    - Initial conditions: $n(0) = 1.0\\times 10^{4}\\ \\text{cm}^{-3}$, $c(0) = 0.0\\ \\text{cm}^{-3}$.\n    - Time step: $\\Delta t = 5.0\\times 10^{-3}\\ \\text{s}$, number of base steps $N = 200$.\n\n- Case 3 (strong explicit nonlinearity and large time step, substantial predictor rejections and substepping expected):\n    - Parameters: $\\beta = 0.0065$, $\\Lambda = 1.0\\times 10^{-5}\\ \\text{s}$, $\\lambda = 0.08\\ \\text{s}^{-1}$, $\\mu = 1.0\\times 10^{-6}\\ \\text{cm}^{3}\\,\\text{s}^{-1}$, $S_0 = 1.0\\times 10^{4}\\ \\text{cm}^{-3}\\,\\text{s}^{-1}$, $\\sigma = 1.0\\ \\text{s}^{-1}$.\n    - Mass matrix: $M = \\operatorname{diag}(1.0, 1.0)$.\n    - Initial conditions: $n(0) = 1.0\\times 10^{4}\\ \\text{cm}^{-3}$, $c(0) = 0.0\\ \\text{cm}^{-3}$.\n    - Time step: $\\Delta t = 5.0\\times 10^{-2}\\ \\text{s}$, number of base steps $N = 20$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the form\n```\n[[n1,c1,r1],[n2,c2,r2],[n3,c3,r3]]\n```\nwhere $n_i$ and $c_i$ are floats in $\\text{cm}^{-3}$ and $r_i$ is an integer, for $i=1,2,3$.",
            "solution": "The user has provided a problem requesting the implementation of an Implicit-Explicit (IMEX) predictor-corrector scheme for a system of ordinary differential equations (ODEs) that model point reactor kinetics. The problem includes a specific adaptive stepping strategy based on a residual error estimate. This requires a meticulous derivation and implementation of the numerical method.\n\n### Problem Formulation\n\nThe system of ODEs is given in mass-matrix form as:\n$$\nM \\frac{d y}{d t} = f_I(y) + g(y, t)\n$$\nwhere $y = [n, c]^{\\top}$ is the state vector, $M$ is the mass matrix, $f_I(y)$ is the stiff linear term, and $g(y, t)$ is the non-stiff, nonlinear term.\n\nThe components are defined as:\n- Mass matrix: $M = \\operatorname{diag}(m_n, m_c)$\n- Stiff term: $f_I(y) = A y$, with the kinetics matrix $A = \\begin{bmatrix} -\\frac{\\beta}{\\Lambda}  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  -\\lambda \\end{bmatrix}$\n- Nonstiff term: $g(y,t) = \\begin{bmatrix} S_0 e^{-\\sigma t} + \\mu n^2 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} S_0 e^{-\\sigma t} + \\mu (y_0)^2 \\\\ 0 \\end{bmatrix}$\n\n### IMEX Predictor-Corrector Scheme\n\nThe numerical scheme advances the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$. It consists of two main stages: a predictor for the nonstiff part and a corrector that treats the stiff part implicitly.\n\n**1. Predictor Stage (Explicit)**\n\nThe scheme first predicts the state's evolution due to the nonstiff term $g$. The simplest predictor is the first-order Explicit (Forward) Euler method:\n$$\nM \\hat{y}^{n+1} = M y^n + \\Delta t\\, g(y^n, t_n)\n$$\nThis can be rearranged to solve for the predicted state $\\hat{y}^{n+1}$:\n$$\n\\hat{y}^{n+1} = y^n + \\Delta t\\, M^{-1} g(y^n, t_n)\n$$\nSince $M$ is diagonal, its inverse $M^{-1}$ is simply the diagonal matrix of reciprocal elements.\n\n**2. Corrector Stage (Implicit)**\n\nThe corrector stage incorporates the stiff term $f_I$ implicitly (using Backward Euler) and uses the predicted state to evaluate the nonstiff term $g$ at the end of the time step, $t_{n+1}$:\n$$\nM y^{n+1} = M y^n + \\Delta t\\, f_I(y^{n+1}) + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})\n$$\nSince $f_I(y) = A y$ is linear, we can rearrange this equation into a linear system for the unknown state $y^{n+1}$:\n$$\nM y^{n+1} - \\Delta t\\, A y^{n+1} = M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})\n$$\n$$\n(M - \\Delta t A) y^{n+1} = M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})\n$$\nThis is a $2 \\times 2$ linear system of the form $C_{sys} x = b$, where the system matrix is $C_{sys} = (M - \\Delta t A)$, the unknown vector is $x = y^{n+1}$, and the right-hand side is $b = M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1})$. For each time step of duration $\\Delta t$, the matrix $C_{sys}$ is constant and can be inverted to solve for $y^{n+1}$:\n$$\ny^{n+1} = (M - \\Delta t A)^{-1} \\left( M y^n + \\Delta t\\, g(\\hat{y}^{n+1}, t_{n+1}) \\right)\n$$\n\n### Adaptive Control: Error Estimation and Step Rejection\n\nThe accuracy of this scheme largely depends on how well the explicit predictor $\\hat{y}^{n+1}$ approximates the final solution $y^{n+1}$. A large discrepancy indicates that the time step $\\Delta t$ might be too large. We can quantify this discrepancy using a residual.\n\n**Residual Definition and Acceptance Criterion:**\nThe residual $r^{n+1}$ is defined based on the corrector equation. As shown in the problem statement, it simplifies to the difference between the nonstiff term evaluated at the predicted and corrected states:\n$$\nr^{n+1} = \\Delta t \\left( g(\\hat{y}^{n+1}, t_{n+1}) - g(y^{n+1}, t_{n+1}) \\right)\n$$\nThe step is accepted if the L2-norm of this residual is within a mixed absolute-relative tolerance:\n$$\n\\lVert r^{n+1} \\rVert_2 \\le \\tau_{\\text{abs}} + \\tau_{\\text{rel}} \\lVert M y^{n+1} \\rVert_2\n$$\n\n**Rejection Strategy:**\n\nIf the acceptance criterion is not met, the step is rejected. The rejection triggers a sequence of actions:\n1.  **Count Rejection**: The failure of the Euler predictor is counted as one rejection event.\n2.  **Improve Predictor**: A more accurate, second-order predictor based on Heun's method (explicit trapezoidal rule) is used for the nonstiff term:\n    - First stage (Euler step): $\\tilde{y}^{n+1} = y^n + \\Delta t\\, M^{-1} g(y^n, t_n)$\n    - Second stage (trapezoidal average): $\\hat{y}^{n+1}_{\\text{Heun}} = y^n + \\frac{\\Delta t}{2}\\, M^{-1} \\left( g(y^n, t_n) + g(\\tilde{y}^{n+1}, t_{n+1}) \\right)$\n    The corrector step is then re-solved using this improved predictor:\n    $$\n    y^{n+1} = (M - \\Delta t A)^{-1} \\left( M y^n + \\Delta t\\, g(\\hat{y}^{n+1}_{\\text{Heun}}, t_{n+1}) \\right)\n    $$\n    The acceptance criterion is checked again with this new $y^{n+1}$. If it passes, the step is accepted, and the total rejections for this step is $1$.\n\n3.  **Sub-stepping**: If the Heun predictor also fails the acceptance test, this failure is counted as a second rejection event for the current time step attempt. The time step $\\Delta t$ is deemed too large and is split into two equal sub-steps of duration $\\Delta t/2$. The entire procedure, starting with the initial Euler predictor, is applied recursively to each sub-step. The total rejections for the original step of size $\\Delta t$ will be the sum of the two rejections from the failed full-step attempt, plus any rejections accumulated during the subsequent sub-steps.\n\n### Implementation Logic\n\nThe adaptive strategy is best implemented using a recursive function, say `adaptive_step(y_n, t_n, dt)`. This function attempts to advance the solution over an interval `dt`.\n\n- It first tries the Euler predictor. If successful, it returns the new state and $0$ rejections.\n- If it fails, it increments a rejection counter to $1$ and tries the Heun predictor. If successful, it returns the new state and $1$ rejection.\n- If Heun also fails, it increments the rejection counter to $2$. It then calls itself twice to handle the two sub-steps of size `dt/2`:\n    - `y_mid, rej1 = adaptive_step(y_n, t_n, dt/2)`\n    - `y_final, rej2 = adaptive_step(y_mid, t_n + dt/2, dt/2)`\n    It returns the final state `y_final` and the total rejections: $2 + \\text{rej}_1 + \\text{rej}_2$.\n\nThe main simulation loop iterates over the $N$ base time steps, calling this recursive function for each base step $\\Delta t$ and accumulating the total rejections. The final state vector $[n, c]^{\\top}$ and the total rejection count are reported for each test case.",
            "answer": "```\n[[12999.539864234033,8093.076840003065,0],[12282.68412852643,8424.36423986689,17],[12260.912660050807,8439.421670982744,38]]\n```"
        }
    ]
}