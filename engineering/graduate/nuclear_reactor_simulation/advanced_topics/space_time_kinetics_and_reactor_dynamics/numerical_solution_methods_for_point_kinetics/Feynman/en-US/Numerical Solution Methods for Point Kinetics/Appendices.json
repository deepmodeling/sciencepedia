{
    "hands_on_practices": [
        {
            "introduction": "Before we can numerically integrate the point kinetics equations over time, it's crucial to understand the system's instantaneous behavior. This practice  examines the initial response of a reactor to a sudden reactivity change, revealing the origin of the numerical stiffness that specialized methods must handle. By calculating the initial rate of change of the neutron population, you will gain a physical intuition for the prompt jump phenomenon.",
            "id": "4239358",
            "problem": "A homogeneous thermal reactor is modeled by the point kinetics equations with $G=6$ delayed neutron groups. The total delayed neutron fraction is $\\beta = 0.0065$, the prompt neutron generation time is $\\Lambda = 1.0 \\times 10^{-5}\\ \\mathrm{s}$, and the delayed neutron data for the six groups are given by the fractional yields $\\{\\beta_i\\}_{i=1}^{6}$ and decay constants $\\{\\lambda_i\\}_{i=1}^{6}$:\n- $\\beta_1 = 2.15 \\times 10^{-4}$, $\\lambda_1 = 1.24 \\times 10^{-2}\\ \\mathrm{s}^{-1}$\n- $\\beta_2 = 1.424 \\times 10^{-3}$, $\\lambda_2 = 3.05 \\times 10^{-2}\\ \\mathrm{s}^{-1}$\n- $\\beta_3 = 1.274 \\times 10^{-3}$, $\\lambda_3 = 1.11 \\times 10^{-1}\\ \\mathrm{s}^{-1}$\n- $\\beta_4 = 2.568 \\times 10^{-3}$, $\\lambda_4 = 3.01 \\times 10^{-1}\\ \\mathrm{s}^{-1}$\n- $\\beta_5 = 7.48 \\times 10^{-4}$, $\\lambda_5 = 1.14\\ \\mathrm{s}^{-1}$\n- $\\beta_6 = 2.73 \\times 10^{-4}$, $\\lambda_6 = 3.01\\ \\mathrm{s}^{-1}$\n\nAssume no external neutron source. The reactor is initially at steady critical conditions for $t0$, with reactivity $\\rho^{-}=0$, normalized neutron density $n(0^{-}) = 1$, and each precursor group concentration $C_i(0^{-})$ equal to its steady-state value consistent with $\\rho^{-}=0$. At $t=0$, an instantaneous positive step reactivity insertion of $\\rho = 2000\\ \\mathrm{pcm}$ is made, where $\\mathrm{pcm}$ denotes per cent mille so that $1\\ \\mathrm{pcm} = 10^{-5}$.\n\nStarting from the neutron balance with delayed neutron precursors and the definitions of steady critical conditions before the step, derive the exact expression for the initial time derivative of the neutron density, $\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$, and evaluate it numerically with the given data. Express your final numerical value in $\\mathrm{s}^{-1}$, and round to four significant figures.\n\nAlso, briefly explain in words the physical meaning of the sign of $\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$ within the point kinetics framework (this explanatory part will not be graded for numerical accuracy).",
            "solution": "The problem is first validated against the specified criteria.\n- **Scientific Groundedness**: The problem is based on the standard point kinetics equations, a cornerstone of nuclear reactor dynamics. All provided parameters, such as the prompt neutron generation time ($\\Lambda$), total delayed neutron fraction ($\\beta$), and the individual group fractions ($\\beta_i$) and decay constants ($\\lambda_i$), are physically realistic for a thermal reactor. The sum of the provided $\\beta_i$ values is $2.15 \\times 10^{-4} + 1.424 \\times 10^{-3} + 1.274 \\times 10^{-3} + 2.568 \\times 10^{-3} + 7.48 \\times 10^{-4} + 2.73 \\times 10^{-4} = 6.502 \\times 10^{-3}$, which is consistent with the given total $\\beta = 0.0065$. The scenario of a step reactivity insertion is a standard problem in reactor transient analysis. The problem is scientifically sound.\n- **Well-Posedness**: The problem is well-posed. It provides a complete set of initial conditions, system parameters, and a clearly defined change at $t=0$. The objective is to find the initial rate of change of the neutron density, for which a unique solution exists.\n- **Objectivity**: The problem is stated in precise, objective, and quantitative terms, free from any subjective or ambiguous language.\n\nThe verdict is that the problem is valid. We proceed to the solution.\n\nThe point kinetics equations for neutron density $n(t)$ and precursor concentrations $C_i(t)$ for $i=1, \\dots, G$ groups, with no external source, are:\n$$ \\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{G} \\lambda_i C_i(t) \\quad \\quad (1) $$\n$$ \\frac{dC_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i C_i(t) \\quad \\quad (2) $$\nwhere $\\rho(t)$ is the reactivity, $\\Lambda$ is the prompt neutron generation time, $\\beta = \\sum_{i=1}^{G} \\beta_i$ is the total delayed neutron fraction, $\\beta_i$ are the group fractions, and $\\lambda_i$ are the group decay constants.\n\nFirst, we establish the initial conditions for $t  0$. The reactor is in a steady critical state.\n- Steady state implies that all time derivatives are zero: $\\frac{dn}{dt} = 0$ and $\\frac{dC_i}{dt} = 0$.\n- Critical condition implies that the reactivity is zero: $\\rho(t0) = \\rho^{-} = 0$.\n- The neutron density is given as normalized to unity: $n(0^{-}) = 1$.\n\nFrom equation (2) at steady state:\n$$ 0 = \\frac{\\beta_i}{\\Lambda} n(0^{-}) - \\lambda_i C_i(0^{-}) $$\nSolving for the initial precursor concentrations, $C_i(0^{-})$:\n$$ C_i(0^{-}) = \\frac{\\beta_i}{\\lambda_i \\Lambda} n(0^{-}) $$\nSince $n(0^{-}) = 1$, we have:\n$$ C_i(0^{-}) = \\frac{\\beta_i}{\\lambda_i \\Lambda} $$\nThese initial conditions satisfy equation (1) at steady state, as $\\frac{\\rho^{-} - \\beta}{\\Lambda}n(0^{-}) + \\sum_{i=1}^{G} \\lambda_i C_i(0^{-}) = \\frac{0 - \\beta}{\\Lambda}(1) + \\sum_{i=1}^{G} \\lambda_i \\left(\\frac{\\beta_i}{\\lambda_i \\Lambda}\\right) = -\\frac{\\beta}{\\Lambda} + \\frac{1}{\\Lambda}\\sum_{i=1}^{G} \\beta_i = -\\frac{\\beta}{\\Lambda} + \\frac{\\beta}{\\Lambda} = 0$.\n\nAt $t=0$, there is an instantaneous step insertion of reactivity. The reactivity for $t \\ge 0$ is $\\rho(t \\ge 0) = \\rho^{+} = 2000\\ \\mathrm{pcm} = 2000 \\times 10^{-5} = 0.02$.\n\nPhysical state variables such as neutron density and precursor concentrations cannot change discontinuously. Therefore, their values immediately after the step change, at $t=0^{+}$, must be the same as their values immediately before, at $t=0^{-}$.\n$$ n(0^{+}) = n(0^{-}) = 1 $$\n$$ C_i(0^{+}) = C_i(0^{-}) = \\frac{\\beta_i}{\\lambda_i \\Lambda} $$\n\nWe want to find the time derivative of the neutron density at $t=0^{+}$, which is $\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$. We evaluate equation (1) at $t=0^{+}$ using the conditions at $t=0^{+}$:\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho(0^{+}) - \\beta}{\\Lambda} n(0^{+}) + \\sum_{i=1}^{G} \\lambda_i C_i(0^{+}) $$\nSubstituting the values for $\\rho(0^{+})$, $n(0^{+})$, and $C_i(0^{+})$:\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+} - \\beta}{\\Lambda} (1) + \\sum_{i=1}^{G} \\lambda_i \\left( \\frac{\\beta_i}{\\lambda_i \\Lambda} \\right) $$\nThe $\\lambda_i$ terms in the sum cancel out:\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+} - \\beta}{\\Lambda} + \\frac{1}{\\Lambda} \\sum_{i=1}^{G} \\beta_i $$\nBy definition, $\\beta = \\sum_{i=1}^{G} \\beta_i$. Substituting this into the equation:\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+} - \\beta}{\\Lambda} + \\frac{\\beta}{\\Lambda} = \\frac{\\rho^{+} - \\beta + \\beta}{\\Lambda} $$\nThis simplifies to the exact expression for the initial time derivative of the neutron density:\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{\\rho^{+}}{\\Lambda} $$\n\nNow, we evaluate this expression numerically using the given data:\n- Reactivity insertion: $\\rho^{+} = 0.02$.\n- Prompt neutron generation time: $\\Lambda = 1.0 \\times 10^{-5}\\ \\mathrm{s}$.\n\n$$ \\left.\\frac{dn}{dt}\\right|_{t=0^{+}} = \\frac{0.02}{1.0 \\times 10^{-5}\\ \\mathrm{s}} = 2000\\ \\mathrm{s}^{-1} $$\nRounding to four significant figures, the value is $2.000 \\times 10^3\\ \\mathrm{s}^{-1}$.\n\nThe physical meaning of the sign of $\\left.\\frac{dn}{dt}\\right|_{t=0^{+}}$:\nThe sign of the derivative is positive. This indicates that the neutron density, and consequently the reactor power, is increasing immediately following the reactivity insertion. A positive reactivity insertion ($\\rho^{+} > 0$) makes the reactor supercritical, meaning the rate of neutron production from fissions exceeds the rate of neutron loss from absorption and leakage. This imbalance leads to a growth in the neutron population. The magnitude of the derivative, which is governed by the ratio of the inserted reactivity to the prompt neutron generation time, signifies a very rapid initial power increase, characteristic of a prompt supercritical transient, since $\\rho^{+} = 0.02$ is greater than $\\beta = 0.0065$. Essentially, the positive sign confirms that the chain reaction is divergent.",
            "answer": "$$ \\boxed{2.000 \\times 10^{3}} $$"
        },
        {
            "introduction": "Having understood the challenge of stiffness from the prompt jump, the next logical step is to build a numerical solver that can handle it efficiently. This exercise  guides you through deriving and implementing a semi-implicit method, a common and robust approach for the point kinetics equations. By treating the fast prompt neutron dynamics implicitly and the slower delayed neutron effects explicitly, this method achieves stability even with relatively large time steps.",
            "id": "4239418",
            "problem": "Consider the Point Kinetics Equations (PKE) for a homogeneous nuclear reactor model with $M$ groups of delayed neutron precursors. The neutron density $n(t)$ and the precursor concentrations $c_i(t)$, for $i \\in \\{1,\\dots,M\\}$, evolve according to the system\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i c_i(t),\n$$\n$$\n\\frac{dc_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i c_i(t),\n$$\nwhere all quantities are functions of time $t$ with units explicitly specified as follows: $t$ in seconds, $\\Lambda$ in seconds, each $\\lambda_i$ in reciprocal seconds, and $n(t)$ and $c_i(t)$ dimensionless. The total delayed neutron fraction is $\\beta = \\sum_{i=1}^{M} \\beta_i$. The reactivity $\\rho(t)$ is dimensionless and is a prescribed function of time.\n\nStarting from these governing equations, derive from first principles a one-step time integration scheme over a time step of size $\\Delta t$ that treats the prompt neutron production term $\\left( \\left(\\rho(t) - \\beta\\right)/\\Lambda \\right) n(t)$ implicitly and treats all delayed neutron terms $\\lambda_i c_i(t)$ and $\\left( \\beta_i/\\Lambda \\right) n(t)$ explicitly. Your derivation must begin with the differential equations above and employ only definitions of the backward Euler method for implicit terms and forward Euler method for explicit terms, without invoking any shortcut formulas not derived directly from these definitions. You must justify the semi-implicit choice by quantifying the separation of timescales between the prompt neutron generation time and the delayed neutron precursor decay times.\n\nImplement the derived semi-implicit scheme in a program and apply it to the following test suite. In every case, use $M = 6$ delayed neutron groups with the following scientifically typical parameters:\n- Delayed neutron decay constants (in $\\text{s}^{-1}$): $\\lambda_1 = 0.0124$, $\\lambda_2 = 0.0305$, $\\lambda_3 = 0.111$, $\\lambda_4 = 0.301$, $\\lambda_5 = 1.14$, $\\lambda_6 = 3.01$.\n- Delayed neutron fractions (dimensionless): $\\beta_1 = 0.000246$, $\\beta_2 = 0.001238$, $\\beta_3 = 0.001274$, $\\beta_4 = 0.002568$, $\\beta_5 = 0.000748$, $\\beta_6 = 0.000273$.\nLet the initial condition represent a reactor at steady criticality just before any reactivity change: $n(0) = 1.0$ and $c_i(0) = \\left(\\beta_i/(\\lambda_i \\Lambda)\\right) n(0)$. Set the external source to zero for all cases.\n\nDefine the following four parameter sets to test different regimes and edge cases. For each case, compute the final normalized neutron density $n(T)$ at the final time $T$.\n\n- Case A (delayed-supercritical step, typical thermal reactor):\n  - Neutron generation time: $\\Lambda = 0.0001$ $\\text{s}$.\n  - Reactivity: $\\rho(t) = 0.002$ for all $t \\ge 0$.\n  - Total simulation time: $T = 5.0$ $\\text{s}$.\n  - Time step: $\\Delta t = 0.001$ $\\text{s}$.\n\n- Case B (prompt-supercritical step, fast transient, fine time step):\n  - Neutron generation time: $\\Lambda = 0.00001$ $\\text{s}$.\n  - Reactivity: $\\rho(t) = 0.007$ for all $t \\ge 0$.\n  - Total simulation time: $T = 0.02$ $\\text{s}$.\n  - Time step: $\\Delta t = 0.000002$ $\\text{s}$.\n\n- Case C (prompt-supercritical step, coarse time step near the prompt period scale):\n  - Neutron generation time: $\\Lambda = 0.00001$ $\\text{s}$.\n  - Reactivity: $\\rho(t) = 0.007$ for all $t \\ge 0$.\n  - Total simulation time: $T = 0.02$ $\\text{s}$.\n  - Time step: $\\Delta t = 0.01$ $\\text{s}$.\n\n- Case D (linearly ramped delayed-supercritical reactivity):\n  - Neutron generation time: $\\Lambda = 0.0001$ $\\text{s}$.\n  - Reactivity: $\\rho(t)$ increases linearly from $0$ at $t = 0$ to $0.005$ at $t = 2.0$ $\\text{s}$, i.e., $\\rho(t) = (0.005/2.0)\\, t$ for $0 \\le t \\le 2.0$.\n  - Total simulation time: $T = 2.0$ $\\text{s}$.\n  - Time step: $\\Delta t = 0.0005$ $\\text{s}$.\n\nYour program must compute $n(T)$ for each case and produce a single line of output containing the four results as a comma-separated list enclosed in square brackets. Each reported number is dimensionless and must be a floating-point value. For example, the output format should be like $[x_1,x_2,x_3,x_4]$, where each $x_j$ corresponds to the computed $n(T)$ for the specified case and is expressed as a float without units. The final outputs must be expressed as floats and not as percentages or annotated strings.",
            "solution": "The problem statement is first validated against the required criteria.\n\n### Step 1: Extract Givens\n\nThe verbatim givens from the problem statement are as follows:\n\n**Governing Equations:**\nThe Point Kinetics Equations (PKE) for $M$ groups of delayed neutron precursors, with neutron density $n(t)$ and precursor concentrations $c_i(t)$ for $i \\in \\{1, \\dots, M\\}$:\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i c_i(t)\n$$\n$$\n\\frac{dc_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i c_i(t)\n$$\n-   Total delayed neutron fraction: $\\beta = \\sum_{i=1}^{M} \\beta_i$.\n-   Units: $t$ in seconds ($\\text{s}$), $\\Lambda$ in $\\text{s}$, $\\lambda_i$ in $\\text{s}^{-1}$. $n(t)$, $c_i(t)$, $\\rho(t)$, $\\beta_i$, $\\beta$ are dimensionless.\n-   The external source term is zero.\n\n**Standard Parameters ($M=6$):**\n-   Delayed neutron decay constants ($\\text{s}^{-1}$): $\\lambda = [0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01]$.\n-   Delayed neutron fractions: $\\beta_i = [0.000246, 0.001238, 0.001274, 0.002568, 0.000748, 0.000273]$.\n\n**Initial Conditions:**\n-   $n(0) = 1.0$.\n-   $c_i(0) = \\left(\\beta_i/(\\lambda_i \\Lambda)\\right) n(0)$. This represents a reactor at steady criticality ($\\rho(0) = 0$).\n\n**Task Requirements:**\n-   Derive a one-step time integration scheme where the prompt neutron term $\\left( \\left(\\rho(t) - \\beta\\right)/\\Lambda \\right) n(t)$ is treated implicitly (backward Euler) and all delayed neutron terms ($\\lambda_i c_i(t)$ and $\\left( \\beta_i/\\Lambda \\right) n(t)$) are treated explicitly (forward Euler).\n-   Justify the semi-implicit choice.\n-   Implement the scheme and compute the final normalized neutron density $n(T)$ for four test cases.\n\n**Test Cases:**\n-   **Case A**: $\\Lambda = 0.0001\n\\text{ s}$, $\\rho(t) = 0.002$, $T = 5.0\n\\text{ s}$, $\\Delta t = 0.001\n\\text{ s}$.\n-   **Case B**: $\\Lambda = 0.00001\n\\text{ s}$, $\\rho(t) = 0.007$, $T = 0.02\n\\text{ s}$, $\\Delta t = 0.000002\n\\text{ s}$.\n-   **Case C**: $\\Lambda = 0.00001\n\\text{ s}$, $\\rho(t) = 0.007$, $T = 0.02\n\\text{ s}$, $\\Delta t = 0.01\n\\text{ s}$.\n-   **Case D**: $\\Lambda = 0.0001\n\\text{ s}$, $\\rho(t) = (0.005/2.0)\\, t$ for $0 \\le t \\le 2.0\n\\text{ s}$, $T = 2.0\n\\text{ s}$, $\\Delta t = 0.0005\n\\text{ s}$.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded**: The problem is built upon the Point Kinetics Equations, a cornerstone of reactor dynamics analysis. The provided parameters for delayed neutron groups are standard, empirically-derived values for reactors using uranium fuel. The initial conditions describe a physically meaningful critical steady state, and the test cases represent standard transient scenarios (step and ramp reactivity insertions). The problem is fundamentally sound.\n-   **Well-Posed**: The problem supplies a set of coupled, non-linear, first-order ordinary differential equations with well-defined initial conditions and a specified forcing function $\\rho(t)$. This constitutes a well-posed initial value problem in mathematics. The instructions to derive and apply a specific numerical method are unambiguous and lead to a unique computational result for each case. The problem is self-contained and complete.\n-   **Objective**: The problem is stated using precise, objective mathematical and scientific language. It is free from subjective claims, speculation, or ambiguity.\n\n### Step 3: Verdict and Action\n\nThe problem is determined to be **valid**. It is a standard and well-formulated problem in computational nuclear engineering. The solution process may proceed.\n\n### Derivation and Solution\n\nThe core task is to derive and implement a semi-implicit numerical scheme for the Point Kinetics Equations (PKE).\n\n**Justification for the Semi-Implicit Method**\n\nThe PKE system is known to be numerically \"stiff.\" Stiffness arises from the presence of vastly different timescales governing the system's dynamics. In the PKE, the two primary timescales are the prompt neutron generation time, $\\Lambda$, and the decay half-lives of the delayed neutron precursors, which are related to $1/\\lambda_i$.\nFor a typical thermal reactor (Case A), $\\Lambda \\approx 10^{-4} \\, \\text{s}$. For a fast reactor (Cases B, C), $\\Lambda \\approx 10^{-5} \\, \\text{s}$.\nThe precursor decay constants $\\lambda_i$ range from approximately $0.0124 \\, \\text{s}^{-1}$ to $3.01 \\, \\text{s}^{-1}$. The corresponding characteristic decay times, $1/\\lambda_i$, span from approximately $0.33 \\, \\text{s}$ to $80 \\, \\text{s}$.\nThe ratio of the slowest precursor timescale to the prompt neutron timescale can be enormous ($80 \\, \\text{s} / 10^{-5} \\, \\text{s} \\approx 8 \\times 10^6$). When using a fully explicit integration method (like forward Euler), the stability of the numerical scheme is dictated by the fastest timescale in the system. The stability criterion for an explicit method would require the time step $\\Delta t$ to be on the order of $\\Lambda/|\\rho-\\beta|$, which becomes prohibitively small, especially during prompt-supercritical transients ($\\rho > \\beta$).\nThe semi-implicit approach resolves this issue. By treating the fast-varying prompt term $\\left(\\frac{\\rho - \\beta}{\\Lambda}\\right)n$ implicitly (using the unconditionally stable backward Euler method), we remove the stability constraint associated with $\\Lambda$. The slow-varying delayed neutron terms can be treated explicitly (using the forward Euler method) without compromising stability, as their timescales are much longer. This approach provides excellent stability while remaining computationally efficient, as it avoids solving a fully coupled system at each time step.\n\n**Derivation of the Numerical Scheme**\n\nWe discretize time with a uniform step size $\\Delta t$, such that $t_k = k \\Delta t$. We denote the numerical approximation of a variable $y(t)$ at time $t_k$ as $y^k$. The time derivative is approximated by a first-order finite difference: $\\frac{dy}{dt} \\approx \\frac{y^{k+1} - y^k}{\\Delta t}$.\n\n1.  **Neutron Density Equation:**\n    The governing equation is:\n    $$\n    \\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i c_i(t)\n    $$\n    We apply the specified scheme: the prompt term (first term on the right-hand side) is evaluated at the new time step $t_{k+1}$ (implicit), and the delayed source term is evaluated at the current time step $t_k$ (explicit).\n    $$\n    \\frac{n^{k+1} - n^k}{\\Delta t} = \\frac{\\rho(t_{k+1}) - \\beta}{\\Lambda} n^{k+1} + \\sum_{i=1}^{M} \\lambda_i c_i^k\n    $$\n    To find the update rule for $n^{k+1}$, we rearrange the equation to solve for $n^{k+1}$:\n    $$\n    n^{k+1} - n^k = \\Delta t \\left( \\frac{\\rho^{k+1} - \\beta}{\\Lambda} \\right) n^{k+1} + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k\n    $$\n    where $\\rho^{k+1} = \\rho(t_{k+1})$.\n    $$\n    n^{k+1} \\left( 1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda} \\right) = n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k\n    $$\n    This yields the explicit update formula for the neutron density:\n    $$\n    n^{k+1} = \\frac{n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k}{1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda}}\n    $$\n\n2.  **Precursor Concentration Equations:**\n    The governing equations are:\n    $$\n    \\frac{dc_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i c_i(t), \\quad i=1, \\dots, M\n    $$\n    The problem states that all delayed neutron terms are to be treated explicitly. This means the entire right-hand side is evaluated at the current time step $t_k$ (forward Euler).\n    $$\n    \\frac{c_i^{k+1} - c_i^k}{\\Delta t} = \\frac{\\beta_i}{\\Lambda} n^k - \\lambda_i c_i^k\n    $$\n    Solving for $c_i^{k+1}$ gives the update rule for the precursor concentrations:\n    $$\n    c_i^{k+1} = c_i^k + \\Delta t \\left( \\frac{\\beta_i}{\\Lambda} n^k - \\lambda_i c_i^k \\right)\n    $$\n    This can be rewritten as:\n    $$\n    c_i^{k+1} = (1 - \\Delta t \\lambda_i) c_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^k\n    $$\n\n**Summary of the Algorithm**\n\nThe time evolution is computed iteratively. Given the state of the system $(n^k, c_1^k, \\dots, c_M^k)$ at time $t_k$, the state at $t_{k+1} = t_k + \\Delta t$ is found as follows:\n\n1.  Determine the reactivity at the next time step, $\\rho^{k+1} = \\rho(t_{k+1})$.\n2.  Calculate the next neutron density $n^{k+1}$ using the state at time $t_k$:\n    $$ n^{k+1} = \\frac{n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k}{1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda}} $$\n3.  Calculate the next precursor concentrations $c_i^{k+1}$ using the state at time $t_k$:\n    $$ c_i^{k+1} = (1 - \\Delta t \\lambda_i) c_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^k $$\n4.  Update the state variables: set $n^k \\leftarrow n^{k+1}$ and $c_i^k \\leftarrow c_i^{k+1}$.\n5.  Repeat for the required number of time steps, $N = T / \\Delta t$.\n\nThe initial conditions at $t=0$ are $n^0 = 1.0$ and $c_i^0 = (\\beta_i / (\\lambda_i \\Lambda)) n^0$. Note that $c_i^0$ depends on $\\Lambda$ and must be calculated for each case.\nThe total delayed neutron fraction is calculated as $\\beta = \\sum_{i=1}^M \\beta_i = 0.006347$.\nThe implementation will follow this algorithm for each of the four specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Point Kinetics Equations for four test cases using a\n    semi-implicit numerical scheme and prints the results.\n    \"\"\"\n\n    # Define standard delayed neutron group parameters for M=6\n    # Decay constants (lambda_i) in s^-1\n    lambdas = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    # Delayed neutron fractions (beta_i)\n    betas = np.array([0.000246, 0.001238, 0.001274, 0.002568, 0.000748, 0.000273])\n    # Total delayed neutron fraction\n    beta_total = np.sum(betas)\n\n    def run_simulation(Lambda, rho_func, T, dt):\n        \"\"\"\n        Runs a single PKE simulation for a given set of parameters.\n\n        Args:\n            Lambda (float): Neutron generation time in seconds.\n            rho_func (callable): Function of time t that returns reactivity rho.\n            T (float): Total simulation time in seconds.\n            dt (float): Time step size in seconds.\n\n        Returns:\n            float: The final neutron density n(T).\n        \"\"\"\n        # Initial conditions for a critical reactor (rho=0 at t=0)\n        n = 1.0\n        # This must be calculated with the case-specific Lambda\n        c = (betas / (lambdas * Lambda)) * n\n\n        # Time stepping\n        num_steps = int(round(T / dt))\n        t = 0.0\n\n        for k in range(num_steps):\n            # State at the beginning of the step (k)\n            n_k = n\n            c_k = c\n            \n            # Time at the end of the step (k+1)\n            t_next = t + dt\n            rho_next = rho_func(t_next)\n\n            # --- Calculate the state at t_next ---\n            \n            # 1. Update neutron density (n) using the semi-implicit formula\n            # Delayed source term is explicit (evaluated at k)\n            delayed_source = np.sum(lambdas * c_k)\n            \n            numerator = n_k + dt * delayed_source\n            denominator = 1.0 - (dt / Lambda) * (rho_next - beta_total)\n            \n            n_next = numerator / denominator\n\n            # 2. Update precursor concentrations (c) using the explicit formula\n            # All terms are evaluated at k\n            c_next = (1.0 - dt * lambdas) * c_k + (dt * betas / Lambda) * n_k\n\n            # --- Update state for the next iteration ---\n            n = n_next\n            c = c_next\n            t = t_next\n\n        return n\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"Lambda\": 0.0001,\n            \"rho_func\": lambda t: 0.002,\n            \"T\": 5.0,\n            \"dt\": 0.001\n        },\n        {\n            \"name\": \"Case B\",\n            \"Lambda\": 0.00001,\n            \"rho_func\": lambda t: 0.007,\n            \"T\": 0.02,\n            \"dt\": 0.000002\n        },\n        {\n            \"name\": \"Case C\",\n            \"Lambda\": 0.00001,\n            \"rho_func\": lambda t: 0.007,\n            \"T\": 0.02,\n            \"dt\": 0.01\n        },\n        {\n            \"name\": \"Case D\",\n            \"Lambda\": 0.0001,\n            \"rho_func\": lambda t: (0.005 / 2.0) * t if t = 2.0 else 0.005,\n            \"T\": 2.0,\n            \"dt\": 0.0005\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        final_n = run_simulation(\n            Lambda=case[\"Lambda\"],\n            rho_func=case[\"rho_func\"],\n            T=case[\"T\"],\n            dt=case[\"dt\"]\n        )\n        results.append(final_n)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A stable numerical solution is necessary, but not sufficient; it must also accurately represent the underlying physics. This final practice  delves into the critical analysis of numerical errors, exploring how discretization introduces artifacts like artificial damping and phase lag. By quantifying these deviations from the true analytical response, you will learn to avoid misinterpreting simulation results, a vital skill for reliable reactor safety and control system analysis.",
            "id": "4239394",
            "problem": "Consider the one-group nuclear reactor point kinetics under small reactivity perturbations around critical steady state. Begin from the neutron balance and delayed precursor balance to obtain a minimal linear model suitable for frequency-domain analysis. The fundamental base is the standard one-group point kinetics, which in continuous time is expressed as two coupled ordinary differential equations relating neutron population and delayed neutron precursor concentration. Assume a normalized baseline neutron population equal to unity and small sinusoidal reactivity forcing.\n\nStarting point and modeling assumptions:\n- Let the normalized neutron population be $n(t)$ and the delayed neutron precursor concentration be $C(t)$, with $n(t)$ dimensionless and $C(t)$ in a consistent normalization such that the coupling terms are dimensionally sound.\n- Let the effective delayed neutron fraction be $\\beta$ (dimensionless), the prompt neutron generation time be $\\Lambda$ (in seconds), and the effective single-group decay constant be $\\lambda$ (in inverse seconds).\n- Let the reactivity perturbation be the scalar input $u(t) = \\delta \\rho(t)$ (dimensionless), assumed small and sinusoidal at angular frequency $\\omega$ (in radians per second).\n- Linearize exactly around the critical steady state with $n_0 = 1$ (dimensionless) and $\\rho_0 = 0$ (dimensionless).\n\nTasks:\n1. Starting from the one-group point kinetics equations\n   $$\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda}\\,n(t) + \\lambda\\,C(t), \\qquad \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}\\,n(t) - \\lambda\\,C(t),$$\n   derive a Linear Time-Invariant (LTI) perturbation model for the state vector $x(t) = \\begin{bmatrix}\\delta n(t) \\\\ \\delta C(t)\\end{bmatrix}$ and the input $u(t) = \\delta \\rho(t)$, in the form\n   $$\\frac{dx}{dt} = A\\,x(t) + B\\,u(t), \\qquad y(t) = H\\,x(t),$$\n   where $y(t) = \\delta n(t)$ is the output of interest. Identify $A$, $B$, and $H$ explicitly in terms of $\\beta$, $\\Lambda$, and $\\lambda$ under the normalization $n_0 = 1$.\n\n2. Define the continuous-time frequency response (transfer function) from $u(t)$ to $y(t)$ as\n   $$G(s) = H\\,(sI - A)^{-1}B,$$\n   and the steady-state sinusoidal response at angular frequency $\\omega$ (in radians per second) as $G(i\\omega)$.\n\n3. For three time-stepping schemes applied to the LTI state-space model, derive the corresponding discrete-time state update and discrete-time transfer function evaluated on the unit circle. The schemes are:\n   - Forward (explicit) Euler: derive $M_{\\mathrm{FE}}$ and $N_{\\mathrm{FE}}$ such that\n     $$x_{k+1} = M_{\\mathrm{FE}}\\,x_k + N_{\\mathrm{FE}}\\,u_k.$$\n   - Backward (implicit) Euler: derive $M_{\\mathrm{BE}}$ and input mapping consistent with evaluation at the end of the step,\n     $$x_{k+1} = M_{\\mathrm{BE}}\\,x_k + \\tilde{N}_{\\mathrm{BE}}\\,u_{k+1}.$$\n   - Trapezoidal (Crank-Nicolson (CN)) method: derive $M_{\\mathrm{CN}}$ and input maps for both the beginning and end of the step,\n     $$x_{k+1} = M_{\\mathrm{CN}}\\,x_k + N_{\\mathrm{CN},0}\\,u_k + N_{\\mathrm{CN},1}\\,u_{k+1}.$$\n   For each scheme, define the discrete-time transfer function $G_d(z)$ evaluated at $z=e^{i\\Omega}$, where $\\Omega = \\omega h$ (dimensionless) and $h$ is the time step (in seconds), using the appropriate $z$ factors induced by $u_{k+1}$ in the backward Euler and Crank-Nicolson input terms.\n\n4. Quantify numerical artifacts relative to the continuous-time response. Define:\n   - The numerical gain ratio as $\\gamma = \\frac{|G_d(e^{i\\Omega})|}{|G(i\\omega)|}$ (dimensionless).\n   - The additional numerical phase error as $\\phi_{\\mathrm{err}} = \\operatorname{Arg}\\big(G_d(e^{i\\Omega})\\big) - \\operatorname{Arg}\\big(G(i\\omega)\\big)$ (in radians), wrapped into the principal interval $\\left[-\\pi,\\pi\\right]$.\n\n5. Use the following physically plausible parameter values:\n   - Effective delayed neutron fraction $\\beta = 0.0065$ (dimensionless).\n   - Prompt neutron generation time $\\Lambda = 1.0\\times 10^{-4}$ (in seconds).\n   - Effective single-group decay constant $\\lambda = 0.08$ (in inverse seconds).\n   - Baseline normalized power $n_0 = 1$ (dimensionless).\n\n6. Evaluate the numerical artifacts for the specified test suite of method, time step, and forcing frequency combinations. Each test case is a triple $(\\text{method}, h, \\omega)$:\n   - Test case $1$: Forward Euler, $h = 0.001$ (in seconds), $\\omega = 2\\pi \\cdot 1$ (in radians per second).\n   - Test case $2$: Forward Euler, $h = 0.02$ (in seconds), $\\omega = 2\\pi \\cdot 1$ (in radians per second).\n   - Test case $3$: Backward Euler, $h = 0.02$ (in seconds), $\\omega = 2\\pi \\cdot 10$ (in radians per second).\n   - Test case $4$: Crank-Nicolson, $h = 0.02$ (in seconds), $\\omega = 2\\pi \\cdot 10$ (in radians per second).\n   - Test case $5$: Forward Euler, $h = 0.005$ (in seconds), $\\omega = 600.0$ (in radians per second).\n\n7. Scientific interpretation requirement: After quantifying $\\gamma$ and $\\phi_{\\mathrm{err}}$, relate how numerical damping (i.e., $\\gamma  1$) or amplification (i.e., $\\gamma > 1$), and numerical phase lag (i.e., $\\phi_{\\mathrm{err}}  0$) could be misread in reactor control studies. For example, discuss how excessive numerical damping could be misinterpreted as stronger inherent negative reactivity feedback, or how phase lag could be misinterpreted as sensor delay or actuator latency affecting stability margins. This interpretive mapping should follow from the computed artifacts without introducing nonphysical assumptions.\n\nRequired output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each test case result must be a two-element list in the order $[\\gamma, \\phi_{\\mathrm{err}}]$, with both values as floats rounded to six decimal places.\n- The overall output must therefore be a nested list like\n  $$\\big[[\\gamma_1,\\phi_{\\mathrm{err},1}],[\\gamma_2,\\phi_{\\mathrm{err},2}],\\dots\\big],$$\n  printed exactly as a single line in the form\n  $$\\texttt{[[g1,p1],[g2,p2],...]}.$$\n\nAngle unit specification:\n- Express $\\phi_{\\mathrm{err}}$ in radians (no degrees).",
            "solution": "**Task 1: Derivation of the Linear Time-Invariant (LTI) Model**\n\nThe starting point is the one-group point kinetics equations:\n$$ \\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda}n(t) + \\lambda C(t) $$\n$$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}n(t) - \\lambda C(t) $$\nWe linearize these equations around a critical steady state $(\\rho_0, n_0, C_0)$, where $\\rho_0=0$ and the normalized neutron population is $n_0=1$. At steady state, the time derivatives are zero:\n$$ 0 = \\frac{0 - \\beta}{\\Lambda}n_0 + \\lambda C_0 \\implies \\lambda C_0 = \\frac{\\beta}{\\Lambda}n_0 $$\n$$ 0 = \\frac{\\beta}{\\Lambda}n_0 - \\lambda C_0 $$\nWith $n_0=1$, the steady-state precursor concentration is $C_0 = \\frac{\\beta}{\\lambda \\Lambda}$.\n\nLet the variables be represented by their steady-state values plus small perturbations:\n$n(t) = n_0 + \\delta n(t) = 1 + \\delta n(t)$\n$C(t) = C_0 + \\delta C(t)$\n$\\rho(t) = \\rho_0 + \\delta \\rho(t) = \\delta \\rho(t)$\n\nSubstituting these into the original equations and keeping only first-order terms in the perturbations ($\\delta n, \\delta C, \\delta \\rho$):\nFor the neutron population equation:\n$$ \\frac{d(1 + \\delta n)}{dt} = \\frac{\\delta\\rho(t) - \\beta}{\\Lambda}(1 + \\delta n(t)) + \\lambda(C_0 + \\delta C(t)) $$\n$$ \\frac{d\\delta n}{dt} \\approx \\left(\\frac{\\delta\\rho(t)}{\\Lambda} - \\frac{\\beta}{\\Lambda}\\right)(1) + \\left(\\frac{-\\beta}{\\Lambda}\\right)\\delta n(t) + \\lambda C_0 + \\lambda \\delta C(t) $$\n$$ \\frac{d\\delta n}{dt} = \\frac{\\delta\\rho}{\\Lambda}n_0 - \\frac{\\beta}{\\Lambda}n_0 - \\frac{\\beta}{\\Lambda}\\delta n + \\lambda C_0 + \\lambda \\delta C $$\nThe terms $-\\frac{\\beta}{\\Lambda}n_0 + \\lambda C_0$ sum to zero based on the steady-state condition. Recalling $n_0=1$:\n$$ \\frac{d\\delta n}{dt} = -\\frac{\\beta}{\\Lambda}\\delta n(t) + \\lambda \\delta C(t) + \\frac{1}{\\Lambda}\\delta \\rho(t) $$\nFor the precursor concentration equation:\n$$ \\frac{d(C_0 + \\delta C)}{dt} = \\frac{\\beta}{\\Lambda}(1 + \\delta n(t)) - \\lambda(C_0 + \\delta C(t)) $$\n$$ \\frac{d\\delta C}{dt} = \\frac{\\beta}{\\Lambda}n_0 + \\frac{\\beta}{\\Lambda}\\delta n(t) - \\lambda C_0 - \\lambda \\delta C(t)$$\nAgain, the steady-state terms $\\frac{\\beta}{\\Lambda}n_0 - \\lambda C_0$ cancel out.\n$$ \\frac{d\\delta C}{dt} = \\frac{\\beta}{\\Lambda}\\delta n(t) - \\lambda \\delta C(t) $$\nWe can now write this in the state-space form $\\frac{dx}{dt} = Ax(t) + Bu(t)$ with $x(t) = \\begin{bmatrix}\\delta n(t) \\\\ \\delta C(t)\\end{bmatrix}$ and $u(t) = \\delta \\rho(t)$.\n\nThe state matrix $A$, input matrix $B$, and output matrix $H$ (for output $y(t) = \\delta n(t)$) are:\n$$ A = \\begin{bmatrix} -\\frac{\\beta}{\\Lambda}  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  -\\lambda \\end{bmatrix}, \\quad B = \\begin{bmatrix} \\frac{1}{\\Lambda} \\\\ 0 \\end{bmatrix}, \\quad H = \\begin{bmatrix} 1  0 \\end{bmatrix} $$\n\n**Task 2: Continuous-Time Frequency Response**\n\nThe transfer function $G(s)$ from the input $u(t)=\\delta\\rho(t)$ to the output $y(t)=\\delta n(t)$ is given by $G(s) = H(sI - A)^{-1}B$.\nFirst, we find $(sI - A)^{-1}$:\n$$ sI - A = \\begin{bmatrix} s + \\frac{\\beta}{\\Lambda}  -\\lambda \\\\ -\\frac{\\beta}{\\Lambda}  s + \\lambda \\end{bmatrix} $$\n$$ \\det(sI - A) = \\left(s + \\frac{\\beta}{\\Lambda}\\right)(s + \\lambda) - \\lambda\\frac{\\beta}{\\Lambda} = s^2 + s\\lambda + s\\frac{\\beta}{\\Lambda} = s\\left(s + \\lambda + \\frac{\\beta}{\\Lambda}\\right) $$\n$$ (sI - A)^{-1} = \\frac{1}{\\det(sI-A)} \\begin{bmatrix} s + \\lambda  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  s + \\frac{\\beta}{\\Lambda} \\end{bmatrix} $$\nNow, we compute $G(s)$:\n$$ G(s) = \\begin{bmatrix} 1  0 \\end{bmatrix} \\frac{1}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} \\begin{bmatrix} s + \\lambda  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  s + \\frac{\\beta}{\\Lambda} \\end{bmatrix} \\begin{bmatrix} \\frac{1}{\\Lambda} \\\\ 0 \\end{bmatrix} $$\n$$ G(s) = \\frac{1}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} \\begin{bmatrix} 1  0 \\end{bmatrix} \\begin{bmatrix} \\frac{s+\\lambda}{\\Lambda} \\\\ \\frac{\\beta}{\\Lambda^2} \\end{bmatrix} = \\frac{\\frac{s+\\lambda}{\\Lambda}}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} $$\nThis is the standard zero-power reactor transfer function. The steady-state sinusoidal response at frequency $\\omega$ is obtained by evaluating $G(s)$ at $s = i\\omega$, where $i=\\sqrt{-1}$.\n\n**Task 3: Discrete-Time Models and Transfer Functions**\n\nWe discretize the LTI system $\\frac{dx}{dt} = Ax + Bu$ with a time step $h$.\n\n*Forward Euler (FE):* The update is $x_{k+1} = x_k + h(Ax_k + Bu_k)$.\n$$ x_{k+1} = (I + hA)x_k + (hB)u_k $$\nThis gives $M_{\\mathrm{FE}} = I + hA$ and $N_{\\mathrm{FE}} = hB$.\nThe discrete transfer function, from the z-transform $z x(z) = M_{\\mathrm{FE}}x(z) + N_{\\mathrm{FE}}u(z)$, is:\n$$ G_{d, \\mathrm{FE}}(z) = H(zI - M_{\\mathrm{FE}})^{-1}N_{\\mathrm{FE}} $$\n\n*Backward Euler (BE):* The update is $x_{k+1} = x_k + h(Ax_{k+1} + Bu_{k+1})$.\n$$ (I - hA)x_{k+1} = x_k + hBu_{k+1} \\implies x_{k+1} = (I - hA)^{-1}x_k + h(I - hA)^{-1}Bu_{k+1} $$\nThis gives $M_{\\mathrm{BE}} = (I-hA)^{-1}$ and $\\tilde{N}_{\\mathrm{BE}} = h(I - hA)^{-1}B$.\nThe z-transform is $z x(z) = M_{\\mathrm{BE}}x(z) + z\\tilde{N}_{\\mathrm{BE}}u(z)$ due to the $u_{k+1}$ term. The transfer function is:\n$$ G_{d, \\mathrm{BE}}(z) = H(zI - M_{\\mathrm{BE}})^{-1}z\\tilde{N}_{\\mathrm{BE}} $$\n\n*Crank-Nicolson (CN):* The update averages the derivative evaluation: $x_{k+1} = x_k + \\frac{h}{2}[(Ax_k+Bu_k) + (Ax_{k+1}+Bu_{k+1})]$.\n$$ \\left(I - \\frac{h}{2}A\\right)x_{k+1} = \\left(I + \\frac{h}{2}A\\right)x_k + \\frac{h}{2}B u_k + \\frac{h}{2}B u_{k+1} $$\n$$ x_{k+1} = \\left(I - \\frac{h}{2}A\\right)^{-1}\\left(I + \\frac{h}{2}A\\right)x_k + \\left(I - \\frac{h}{2}A\\right)^{-1}\\frac{h}{2}B u_k + \\left(I - \\frac{h}{2}A\\right)^{-1}\\frac{h}{2}B u_{k+1} $$\nThis gives $M_{\\mathrm{CN}} = (I - \\frac{h}{2}A)^{-1}(I + \\frac{h}{2}A)$, $N_{\\mathrm{CN},0} = (I - \\frac{h}{2}A)^{-1}\\frac{h}{2}B$, and $N_{\\mathrm{CN},1} = (I - \\frac{h}{2}A)^{-1}\\frac{h}{2}B$. \nThe z-transform is $z x(z) = M_{\\mathrm{CN}}x(z) + (N_{\\mathrm{CN},0} + zN_{\\mathrm{CN},1})u(z)$. The transfer function is:\n$$ G_{d, \\mathrm{CN}}(z) = H(zI - M_{\\mathrm{CN}})^{-1}(N_{\\mathrm{CN},0} + zN_{\\mathrm{CN},1}) $$\nFor all schemes, the frequency response is found by setting $z = e^{i\\Omega}$, where $\\Omega = \\omega h$.\n\n**Task 4-6: Numerical Artifacts, Parameters, and Evaluation**\n\nThe numerical gain ratio $\\gamma$ and phase error $\\phi_{\\mathrm{err}}$ are computed for the specified parameters and test cases. The parameters are $\\beta = 0.0065$, $\\Lambda = 1.0 \\times 10^{-4}\\,\\mathrm{s}$, and $\\lambda = 0.08\\,\\mathrm{s}^{-1}$. These values are substituted into the matrices $A$, $B$, and $H$. The calculations for each test case involve complex matrix algebra, which is performed by the accompanying Python code. The phase error is wrapped to the interval $[-\\pi, \\pi]$.\n\n**Task 7: Scientific Interpretation**\n\nThe numerical artifacts $\\gamma$ and $\\phi_{\\mathrm{err}}$ quantify the deviation of the numerical solution from the true analytical solution in the frequency domain. Misinterpreting these artifacts as physical phenomena can lead to erroneous conclusions in reactor safety and control analysis.\n\nA numerical gain ratio $\\gamma  1$ signifies *numerical damping*. The simulation predicts a response amplitude smaller than the actual physical response. In a reactor control context, this could be mistaken for stronger inherent negative feedback (like the Doppler effect), making the reactor appear more stable and self-regulating than it truly is. This might lead to an unsafe underestimation of power peaks during operational transients.\n\nConversely, $\\gamma > 1$ represents *numerical amplification*. This could lead to a false prediction of instability or a gross overestimation of transient severity. An analyst might conclude the system is less stable than it is, potentially imposing unnecessarily restrictive operational limits.\n\nA numerical phase error $\\phi_{\\mathrm{err}} \\neq 0$ indicates that the simulation introduces a time shift error. A negative error, $\\phi_{\\mathrm{err}}  0$, is a *numerical phase lag*. The simulated neutron population response will lag behind the true physical response to a reactivity change. This is particularly pernicious because it mimics real-world delays, such as sensor lag or actuator latency. Since phase lag erodes the phase margin, a key metric for feedback stability, a significant numerical phase lag could lead to an incorrect assessment of the system's stability, possibly masking a potential instability or misdiagnosing its cause. A positive error, $\\phi_{\\mathrm{err}} > 0$ (phase lead), is less common for simple methods but would artificially increase the phase margin, painting an overly optimistic picture of system stability.\n\nIn summary, these numerical artifacts are not just mathematical curiosities; they can directly impact the fidelity of safety analyses and the design of control systems for nuclear reactors.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear reactor kinetics numerical analysis problem.\n\n    This function performs the following steps:\n    1. Defines the physical parameters for the point kinetics model.\n    2. Defines the LTI state-space matrices (A, B, H).\n    3. Defines a list of test cases, each specifying a numerical method,\n       time step (h), and forcing frequency (omega).\n    4. For each test case:\n       a. Calculates the exact continuous-time frequency response G(i*omega).\n       b. Calculates the discrete-time frequency response G_d(exp(i*omega*h))\n          for the specified numerical method.\n       c. Computes the numerical gain ratio (gamma) and phase error (phi_err).\n    5. Formats and prints the results as required.\n    \"\"\"\n    \n    # 5. Use the following physically plausible parameter values:\n    beta = 0.0065  # Effective delayed neutron fraction\n    Lambda = 1.0e-4  # Prompt neutron generation time [s]\n    lmbda = 0.08  # Effective single-group decay constant [1/s]\n\n    # 1. Derive a Linear Time-Invariant (LTI) perturbation model\n    # A matrix\n    A = np.array([\n        [-beta / Lambda, lmbda],\n        [beta / Lambda, -lmbda]\n    ], dtype=float)\n\n    # B matrix\n    B = np.array([\n        [1.0 / Lambda],\n        [0.0]\n    ], dtype=float)\n\n    # H matrix\n    H = np.array([[1.0, 0.0]], dtype=float)\n    \n    # 6. Evaluate the numerical artifacts for the specified test suite\n    test_cases = [\n        # (method, h, omega)\n        (\"FE\", 0.001, 2.0 * np.pi * 1.0),\n        (\"FE\", 0.02, 2.0 * np.pi * 1.0),\n        (\"BE\", 0.02, 2.0 * np.pi * 10.0),\n        (\"CN\", 0.02, 2.0 * np.pi * 10.0),\n        (\"FE\", 0.005, 600.0)\n    ]\n\n    results = []\n    I = np.identity(2, dtype=float)\n\n    for method, h, omega in test_cases:\n        s = 1j * omega\n        \n        # 2. Define the continuous-time frequency response G(i*omega)\n        # G(s) = H * (sI - A)^-1 * B\n        G_continuous = H @ np.linalg.inv(s * I - A) @ B\n        G_cont_val = G_continuous[0, 0]\n\n        # 3. For three time-stepping schemes, derive discrete-time transfer function\n        Omega = omega * h\n        z = np.exp(1j * Omega)\n        \n        G_d_val = 0.0 + 0.0j\n\n        if method == \"FE\":\n            # Forward Euler\n            # x_{k+1} = (I + hA)x_k + (hB)u_k\n            # M_FE = I + hA, N_FE = hB\n            # G_d(z) = H * (zI - M_FE)^-1 * N_FE\n            M_fe = I + h * A\n            N_fe = h * B\n            G_discrete = H @ np.linalg.inv(z * I - M_fe) @ N_fe\n            G_d_val = G_discrete[0, 0]\n            \n        elif method == \"BE\":\n            # Backward Euler\n            # x_{k+1} = (I - hA)^-1 * x_k + h*(I-hA)^-1*B * u_{k+1}\n            # M_BE = (I-hA)^-1, N_tilde_BE = h*(I-hA)^-1*B\n            # G_d(z) = H * (zI - M_BE)^-1 * z*N_tilde_BE\n            inv_term_be = np.linalg.inv(I - h * A)\n            M_be = inv_term_be\n            N_tilde_be = h * inv_term_be @ B\n            G_discrete = H @ np.linalg.inv(z * I - M_be) @ (z * N_tilde_be)\n            G_d_val = G_discrete[0, 0]\n\n        elif method == \"CN\":\n            # Crank-Nicolson\n            # x_k+1 = M_CN*x_k + N_CN0*u_k + N_CN1*u_{k+1}\n            # M_CN = (I-h/2 A)^-1 * (I+h/2 A)\n            # N_CN0 = N_CN1 = (I-h/2 A)^-1 * h/2 * B\n            # G_d(z) = H * (zI - M_CN)^-1 * (N_CN0 + z*N_CN1)\n            inv_term_cn = np.linalg.inv(I - 0.5 * h * A)\n            M_cn = inv_term_cn @ (I + 0.5 * h * A)\n            N_cn0 = inv_term_cn @ (0.5 * h * B)\n            N_cn1 = N_cn0 # N_CN0 and N_CN1 are identical\n            G_discrete = H @ np.linalg.inv(z * I - M_cn) @ (N_cn0 + z * N_cn1)\n            G_d_val = G_discrete[0, 0]\n            \n        # 4. Quantify numerical artifacts\n        # Numerical gain ratio\n        gamma = np.abs(G_d_val) / np.abs(G_cont_val)\n        \n        # Additional numerical phase error\n        phi_d = np.angle(G_d_val)\n        phi_cont = np.angle(G_cont_val)\n        phi_err = phi_d - phi_cont\n        \n        # Wrap phase error to the principal interval [-pi, pi]\n        phi_err_wrapped = (phi_err + np.pi) % (2 * np.pi) - np.pi\n        \n        results.append([round(gamma, 6), round(phi_err_wrapped, 6)])\n\n    # Required output format: [[g1,p1],[g2,p2],...]\n    result_str = \",\".join([f\"[{g},{p}]\" for g, p in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}