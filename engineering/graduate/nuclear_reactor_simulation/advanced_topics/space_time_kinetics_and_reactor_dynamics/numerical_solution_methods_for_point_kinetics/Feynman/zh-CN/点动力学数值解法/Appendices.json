{
    "hands_on_practices": [
        {
            "introduction": "点动力学方程组（PKE）具有数值“刚性”的特点，这意味着简单的显式积分方法需要极小的时间步长才能保持稳定。本练习 () 将指导您推导并实现一种半隐式方案，该方案通过隐式处理快变的瞬发项和显式处理慢变的缓发项来有效解决刚性问题。这构成了从头开始构建一个稳定可靠的点动力学求解器的基础。",
            "id": "4239418",
            "problem": "考虑一个具有 $M$ 族缓发中子先驱核的均匀核反应堆模型的点动力学方程(PKE)。中子密度 $n(t)$ 和先驱核浓度 $c_i(t)$（其中 $i \\in \\{1,\\dots,M\\}$）根据以下方程组演化：\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i c_i(t),\n$$\n$$\n\\frac{dc_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i c_i(t),\n$$\n其中所有量均为时间 $t$ 的函数，单位明确指定如下：$t$ 的单位为秒，$\\Lambda$ 的单位为秒，每个 $\\lambda_i$ 的单位为秒的倒数，$n(t)$ 和 $c_i(t)$ 为无量纲量。总的缓发中子份额为 $\\beta = \\sum_{i=1}^{M} \\beta_i$。反应性 $\\rho(t)$ 是无量纲的，并且是给定的时间函数。\n\n从这些控制方程出发，基于第一性原理，推导一个时间步长为 $\\Delta t$ 的单步时间积分格式。该格式隐式处理瞬发中子产生项 $\\left( \\left(\\rho(t) - \\beta\\right)/\\Lambda \\right) n(t)$，并显式处理所有缓发中子项 $\\lambda_i c_i(t)$ 和 $\\left( \\beta_i/\\Lambda \\right) n(t)$。您的推导必须从上述微分方程开始，并且仅使用后向欧拉法对隐式项的定义和前向欧拉法对显式项的定义，不得引用任何未从这些定义直接推导出的简化公式。您必须通过量化瞬发中子代时间与缓发中子先驱核衰变时间之间的时间尺度分离来证明选择半隐式方法的合理性。\n\n在一个程序中实现所推导的半隐式格式，并将其应用于以下测试套件。在所有情况下，使用 $M = 6$ 族缓发中子，并采用以下典型的科学参数：\n- 缓发中子衰变常数 (单位 $\\text{s}^{-1}$)：$\\lambda_1 = 0.0124$, $\\lambda_2 = 0.0305$, $\\lambda_3 = 0.111$, $\\lambda_4 = 0.301$, $\\lambda_5 = 1.14$, $\\lambda_6 = 3.01$。\n- 缓发中子份额 (无量纲)：$\\beta_1 = 0.000246$, $\\beta_2 = 0.001238$, $\\beta_3 = 0.001274$, $\\beta_4 = 0.002568$, $\\beta_5 = 0.000748$, $\\beta_6 = 0.000273$。\n设初始条件代表反应堆在任何反应性变化前处于稳定临界状态：$n(0) = 1.0$ 和 $c_i(0) = \\left(\\beta_i/(\\lambda_i \\Lambda)\\right) n(0)$。所有情况下，将外部源设置为零。\n\n定义以下四个参数集以测试不同的工况和边界情况。对于每种情况，计算最终时间 $T$ 时的最终归一化中子密度 $n(T)$。\n\n- 情况 A (缓发超临界阶跃，典型热中子反应堆)：\n  - 中子代时间：$\\Lambda = 0.0001$ $\\text{s}$。\n  - 反应性：对于所有 $t \\ge 0$，$\\rho(t) = 0.002$。\n  - 总模拟时间：$T = 5.0$ $\\text{s}$。\n  - 时间步长：$\\Delta t = 0.001$ $\\text{s}$。\n\n- 情况 B (瞬发超临界阶跃，快速瞬态，精细时间步长)：\n  - 中子代时间：$\\Lambda = 0.00001$ $\\text{s}$。\n  - 反应性：对于所有 $t \\ge 0$，$\\rho(t) = 0.007$。\n  - 总模拟时间：$T = 0.02$ $\\text{s}$。\n  - 时间步长：$\\Delta t = 0.000002$ $\\text{s}$。\n\n- 情况 C (瞬发超临界阶跃，粗略时间步长，接近瞬发周期尺度)：\n  - 中子代时间：$\\Lambda = 0.00001$ $\\text{s}$。\n  - 反应性：对于所有 $t \\ge 0$，$\\rho(t) = 0.007$。\n  - 总模拟时间：$T = 0.02$ $\\text{s}$。\n  - 时间步长：$\\Delta t = 0.01$ $\\text{s}$。\n\n- 情况 D (线性斜坡引入的缓发超临界反应性)：\n  - 中子代时间：$\\Lambda = 0.0001$ $\\text{s}$。\n  - 反应性：对于 $0 \\le t \\le 2.0$ $\\text{s}$，$\\rho(t)$ 从 $t = 0$ 时的 $0$ 线性增加到 $t = 2.0$ $\\text{s}$ 时的 $0.005$，即 $\\rho(t) = (0.005/2.0)\\, t$。\n  - 总模拟时间：$T = 2.0$ $\\text{s}$。\n  - 时间步长：$\\Delta t = 0.0005$ $\\text{s}$。\n\n您的程序必须计算每种情况下的 $n(T)$，并生成单行输出，其中包含四个结果，形式为方括号括起来的逗号分隔列表。报告的每个数字都是无量纲的，并且必须是浮点值。例如，输出格式应类似于 $[x_1,x_2,x_3,x_4]$，其中每个 $x_j$ 对应于指定情况下计算出的 $n(T)$，并表示为不带单位的浮点数。最终输出必须表示为浮点数，而不是百分比或带注释的字符串。",
            "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n\n问题陈述中逐字给出的已知条件如下：\n\n**控制方程：**\n具有 $M$ 族缓发中子先驱核的点动力学方程(PKE)，其中子密度为 $n(t)$，先驱核浓度为 $c_i(t)$ ($i \\in \\{1, \\dots, M\\}$)：\n$$\n\\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i c_i(t)\n$$\n$$\n\\frac{dc_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i c_i(t)\n$$\n-   总缓发中子份额：$\\beta = \\sum_{i=1}^{M} \\beta_i$。\n-   单位：$t$ 的单位为秒($\\text{s}$)，$\\Lambda$ 的单位为 $\\text{s}$，$\\lambda_i$ 的单位为 $\\text{s}^{-1}$。$n(t)$、$c_i(t)$、$\\rho(t)$、$\\beta_i$、$\\beta$ 均为无量纲。\n-   外部源项为零。\n\n**标准参数($M=6$)：**\n-   缓发中子衰变常数 ($\\text{s}^{-1}$)：$\\lambda = [0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01]$。\n-   缓发中子份额：$\\beta_i = [0.000246, 0.001238, 0.001274, 0.002568, 0.000748, 0.000273]$。\n\n**初始条件：**\n-   $n(0) = 1.0$。\n-   $c_i(0) = \\left(\\beta_i/(\\lambda_i \\Lambda)\\right) n(0)$。这代表反应堆处于稳定临界状态($\\rho(0) = 0$)。\n\n**任务要求：**\n-   推导一个单步时间积分格式，其中瞬发中子项 $\\left( \\left(\\rho(t) - \\beta\\right)/\\Lambda \\right) n(t)$ 被隐式处理（后向欧拉法），所有缓发中子项（$\\lambda_i c_i(t)$ 和 $\\left( \\beta_i/\\Lambda \\right) n(t)$）被显式处理（前向欧拉法）。\n-   证明半隐式选择的合理性。\n-   实现该格式并计算四个测试用例的最终归一化中子密度 $n(T)$。\n\n**测试用例：**\n-   **情况 A**：$\\Lambda = 0.0001\n\\text{ s}$，$\\rho(t) = 0.002$，$T = 5.0\n\\text{ s}$，$\\Delta t = 0.001\n\\text{ s}$。\n-   **情况 B**：$\\Lambda = 0.00001\n\\text{ s}$，$\\rho(t) = 0.007$，$T = 0.02\n\\text{ s}$，$\\Delta t = 0.000002\n\\text{ s}$。\n-   **情况 C**：$\\Lambda = 0.00001\n\\text{ s}$，$\\rho(t) = 0.007$，$T = 0.02\n\\text{ s}$，$\\Delta t = 0.01\n\\text{ s}$。\n-   **情况 D**：$\\Lambda = 0.0001\n\\text{ s}$，对于 $0 \\le t \\le 2.0\n\\text{ s}$，$\\rho(t) = (0.005/2.0)\\, t$，$T = 2.0\n\\text{ s}$，$\\Delta t = 0.0005\n\\text{ s}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n-   **科学依据充分**：该问题建立在点动力学方程之上，这是反应堆动力学分析的基石。所提供的缓发中子组参数是使用铀燃料的反应堆的标准经验导出值。初始条件描述了一个物理上有意义的临界稳态，测试用例代表了标准的瞬态情景（阶跃和斜坡反应性引入）。该问题在根本上是合理的。\n-   **适定性**：问题提供了一组耦合的、非线性的、一阶常微分方程，具有明确的初始条件和指定的强迫函数 $\\rho(t)$。这在数学上构成了一个适定的初值问题。推导和应用特定数值方法的指令是明确的，并且对每种情况都能得到唯一的计算结果。问题是自洽和完整的。\n-   **客观性**：问题陈述使用了精确、客观的数学和科学语言。它没有主观断言、推测或含糊之处。\n\n### 第 3 步：结论与行动\n\n该问题被确定为**有效**。这是计算核工程领域一个标准且表述良好的问题。可以继续进行求解过程。\n\n### 推导与求解\n\n核心任务是推导和实现点动力学方程(PKE)的半隐式数值格式。\n\n**半隐式方法的合理性**\n\nPKE系统是众所周知的数值“刚性”问题。刚性源于控制系统动态的多个时间尺度存在巨大差异。在PKE中，两个主要的时间尺度是瞬发中子代时间 $\\Lambda$ 和缓发中子先驱核的衰变半衰期（与 $1/\\lambda_i$ 相关）。\n对于典型的热中子反应堆（情况A），$\\Lambda \\approx 10^{-4} \\, \\text{s}$。对于快中子反应堆（情况B、C），$\\Lambda \\approx 10^{-5} \\, \\text{s}$。\n先驱核衰变常数 $\\lambda_i$ 的范围大约从 $0.0124 \\, \\text{s}^{-1}$ 到 $3.01 \\, \\text{s}^{-1}$。相应的特征衰变时间 $1/\\lambda_i$ 的范围大约从 $0.33 \\, \\text{s}$ 到 $80 \\, \\text{s}$。\n最慢的先驱核时间尺度与瞬发中子时间尺度的比值可能非常巨大（$80 \\, \\text{s} / 10^{-5} \\, \\text{s} \\approx 8 \\times 10^6$）。当使用完全显式积分方法（如前向欧拉法）时，数值格式的稳定性取决于系统中最快的时间尺度。显式方法的稳定性判据要求时间步长 $\\Delta t$ 约为 $\\Lambda/|\\rho-\\beta|$ 的量级，这会变得非常小以至于不切实际，尤其是在瞬发超临界瞬态（$\\rho > \\beta$）期间。\n半隐式方法解决了这个问题。通过隐式处理快速变化的瞬发项 $\\left(\\frac{\\rho - \\beta}{\\Lambda}\\right)n$（使用无条件稳定的后向欧拉法），我们消除了与 $\\Lambda$ 相关的稳定性约束。慢速变化的缓发中子项可以显式处理（使用前向欧拉法）而不会影响稳定性，因为它们的时间尺度要长得多。这种方法在保持计算效率的同时提供了出色的稳定性，因为它避免了在每个时间步求解一个完全耦合的系统。\n\n**数值格式的推导**\n\n我们用均匀的步长 $\\Delta t$ 对时间进行离散化，使得 $t_k = k \\Delta t$。我们将变量 $y(t)$ 在时间 $t_k$ 的数值近似表示为 $y^k$。时间导数用一阶有限差分近似：$\\frac{dy}{dt} \\approx \\frac{y^{k+1} - y^k}{\\Delta t}$。\n\n1.  **中子密度方程：**\n    控制方程为：\n    $$\n    \\frac{dn(t)}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda} n(t) + \\sum_{i=1}^{M} \\lambda_i c_i(t)\n    $$\n    我们应用指定的格式：瞬发项（右侧第一项）在新的时间步 $t_{k+1}$ 进行计算（隐式），缓发源项在当前时间步 $t_k$ 进行计算（显式）。\n    $$\n    \\frac{n^{k+1} - n^k}{\\Delta t} = \\frac{\\rho(t_{k+1}) - \\beta}{\\Lambda} n^{k+1} + \\sum_{i=1}^{M} \\lambda_i c_i^k\n    $$\n    为了找到 $n^{k+1}$ 的更新规则，我们重新整理方程以求解 $n^{k+1}$：\n    $$\n    n^{k+1} - n^k = \\Delta t \\left( \\frac{\\rho^{k+1} - \\beta}{\\Lambda} \\right) n^{k+1} + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k\n    $$\n    其中 $\\rho^{k+1} = \\rho(t_{k+1})$。\n    $$\n    n^{k+1} \\left( 1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda} \\right) = n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k\n    $$\n    这得到中子密度的显式更新公式：\n    $$\n    n^{k+1} = \\frac{n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k}{1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda}}\n    $$\n\n2.  **先驱核浓度方程：**\n    控制方程为：\n    $$\n    \\frac{dc_i(t)}{dt} = \\frac{\\beta_i}{\\Lambda} n(t) - \\lambda_i c_i(t), \\quad i=1, \\dots, M\n    $$\n    问题陈述要求所有缓发中子项都应显式处理。这意味着整个右侧都在当前时间步 $t_k$ 进行计算（前向欧拉法）。\n    $$\n    \\frac{c_i^{k+1} - c_i^k}{\\Delta t} = \\frac{\\beta_i}{\\Lambda} n^k - \\lambda_i c_i^k\n    $$\n    求解 $c_i^{k+1}$ 得到先驱核浓度的更新规则：\n    $$\n    c_i^{k+1} = c_i^k + \\Delta t \\left( \\frac{\\beta_i}{\\Lambda} n^k - \\lambda_i c_i^k \\right)\n    $$\n    这可以改写为：\n    $$\n    c_i^{k+1} = (1 - \\Delta t \\lambda_i) c_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^k\n    $$\n\n**算法总结**\n\n时间演化通过迭代计算。给定系统在时间 $t_k$ 的状态 $(n^k, c_1^k, \\dots, c_M^k)$，在 $t_{k+1} = t_k + \\Delta t$ 的状态按以下步骤求得：\n\n1.  确定下一个时间步的反应性 $\\rho^{k+1} = \\rho(t_{k+1})$。\n2.  使用时间 $t_k$ 的状态计算下一个中子密度 $n^{k+1}$：\n    $$ n^{k+1} = \\frac{n^k + \\Delta t \\sum_{i=1}^{M} \\lambda_i c_i^k}{1 - \\frac{\\Delta t (\\rho^{k+1} - \\beta)}{\\Lambda}} $$\n3.  使用时间 $t_k$ 的状态计算下一个先驱核浓度 $c_i^{k+1}$：\n    $$ c_i^{k+1} = (1 - \\Delta t \\lambda_i) c_i^k + \\frac{\\Delta t \\beta_i}{\\Lambda} n^k $$\n4.  更新状态变量：令 $n^k \\leftarrow n^{k+1}$ 和 $c_i^k \\leftarrow c_i^{k+1}$。\n5.  重复所需的时间步数 $N = T / \\Delta t$。\n\n在 $t=0$ 时的初始条件是 $n^0 = 1.0$ 和 $c_i^0 = (\\beta_i / (\\lambda_i \\Lambda)) n^0$。注意 $c_i^0$ 依赖于 $\\Lambda$，必须为每种情况单独计算。\n总的缓发中子份额计算为 $\\beta = \\sum_{i=1}^M \\beta_i = 0.006347$。\n实现将遵循此算法对四个指定的测试用例进行计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Point Kinetics Equations for four test cases using a\n    semi-implicit numerical scheme and prints the results.\n    \"\"\"\n\n    # Define standard delayed neutron group parameters for M=6\n    # Decay constants (lambda_i) in s^-1\n    lambdas = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    # Delayed neutron fractions (beta_i)\n    betas = np.array([0.000246, 0.001238, 0.001274, 0.002568, 0.000748, 0.000273])\n    # Total delayed neutron fraction\n    beta_total = np.sum(betas)\n\n    def run_simulation(Lambda, rho_func, T, dt):\n        \"\"\"\n        Runs a single PKE simulation for a given set of parameters.\n\n        Args:\n            Lambda (float): Neutron generation time in seconds.\n            rho_func (callable): Function of time t that returns reactivity rho.\n            T (float): Total simulation time in seconds.\n            dt (float): Time step size in seconds.\n\n        Returns:\n            float: The final neutron density n(T).\n        \"\"\"\n        # Initial conditions for a critical reactor (rho=0 at t=0)\n        n = 1.0\n        # This must be calculated with the case-specific Lambda\n        c = (betas / (lambdas * Lambda)) * n\n\n        # Time stepping\n        num_steps = int(round(T / dt))\n        t = 0.0\n\n        for k in range(num_steps):\n            # State at the beginning of the step (k)\n            n_k = n\n            c_k = c\n            \n            # Time at the end of the step (k+1)\n            t_next = t + dt\n            rho_next = rho_func(t_next)\n\n            # --- Calculate the state at t_next ---\n            \n            # 1. Update neutron density (n) using the semi-implicit formula\n            # Delayed source term is explicit (evaluated at k)\n            delayed_source = np.sum(lambdas * c_k)\n            \n            numerator = n_k + dt * delayed_source\n            denominator = 1.0 - (dt / Lambda) * (rho_next - beta_total)\n            \n            n_next = numerator / denominator\n\n            # 2. Update precursor concentrations (c) using the explicit formula\n            # All terms are evaluated at k\n            c_next = (1.0 - dt * lambdas) * c_k + (dt * betas / Lambda) * n_k\n\n            # --- Update state for the next iteration ---\n            n = n_next\n            c = c_next\n            t = t_next\n\n        return n\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"Lambda\": 0.0001,\n            \"rho_func\": lambda t: 0.002,\n            \"T\": 5.0,\n            \"dt\": 0.001\n        },\n        {\n            \"name\": \"Case B\",\n            \"Lambda\": 0.00001,\n            \"rho_func\": lambda t: 0.007,\n            \"T\": 0.02,\n            \"dt\": 0.000002\n        },\n        {\n            \"name\": \"Case C\",\n            \"Lambda\": 0.00001,\n            \"rho_func\": lambda t: 0.007,\n            \"T\": 0.02,\n            \"dt\": 0.01\n        },\n        {\n            \"name\": \"Case D\",\n            \"Lambda\": 0.0001,\n            \"rho_func\": lambda t: (0.005 / 2.0) * t if t = 2.0 else 0.005,\n            \"T\": 2.0,\n            \"dt\": 0.0005\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        final_n = run_simulation(\n            Lambda=case[\"Lambda\"],\n            rho_func=case[\"rho_func\"],\n            T=case[\"T\"],\n            dt=case[\"dt\"]\n        )\n        results.append(final_n)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建一个能运行的求解器只是第一步；理解其局限性同样至关重要。本练习 () 将带您从时域仿真转向频域分析，以量化数值方法如何扭曲系统的真实动态响应。我们将探讨数值阻尼和相位误差等伪影，如果不加识别，这些伪影在反应堆控制和安全研究中可能会被误解为真实的物理效应。",
            "id": "4239394",
            "problem": "考虑在临界稳态附近，受到小反应性微扰下的单群核反应堆点动力学模型。从​​中子平衡和缓发先驱核平衡方程出发，获得一个适用于频域分析的最小线性模型。其基本理论基础是标准的单群点动力学模型，在连续时间下，该模型由两个耦合的常微分方程表示，关联了中子布居和缓发中子先驱核浓度。假设归一化的基线中子布居等于1，且反应性为小的正弦强迫项。\n\n起点和建模假设：\n- 设归一化中子布居为 $n(t)$，缓发中子先驱核浓度为 $C(t)$，其中 $n(t)$ 为无量纲量，$C(t)$ 采用一致的归一化方式，以确保耦合项在量纲上是合理的。\n- 设有效缓发中子份额为 $\\beta$ (无量纲)，瞬发中子代时间为 $\\Lambda$ (单位：秒)，有效单群衰变常数为 $\\lambda$ (单位：秒的倒数)。\n- 设反应性微扰为标量输入 $u(t) = \\delta \\rho(t)$ (无量纲)，假定其值很小，且为角频率 $\\omega$ (单位：弧度/秒) 的正弦波。\n- 围绕临界稳态 $n_0 = 1$ (无量纲) 和 $\\rho_0 = 0$ (无量纲) 进行精确线性化。\n\n任务：\n1.  从单群点动力学方程出发\n    $$\\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda}\\,n(t) + \\lambda\\,C(t), \\qquad \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}\\,n(t) - \\lambda\\,C(t),$$\n    推导一个针对状态向量 $x(t) = \\begin{bmatrix}\\delta n(t) \\\\ \\delta C(t)\\end{bmatrix}$ 和输入 $u(t) = \\delta \\rho(t)$ 的线性时不变 (LTI) 微扰模型，其形式为\n    $$\\frac{dx}{dt} = A\\,x(t) + B\\,u(t), \\qquad y(t) = H\\,x(t),$$\n    其中 $y(t) = \\delta n(t)$ 是我们关心的输出。在归一化条件 $n_0 = 1$ 下，明确地用 $\\beta$、$\\Lambda$ 和 $\\lambda$ 表示 $A$、$B$ 和 $H$。\n\n2.  将从 $u(t)$ 到 $y(t)$ 的连续时间频率响应 (传递函数) 定义为\n    $$G(s) = H\\,(sI - A)^{-1}B,$$\n    并将角频率为 $\\omega$ (单位：弧度/秒) 的稳态正弦响应定义为 $G(i\\omega)$。\n\n3.  对于应用于该 LTI 状态空间模型的三个时间步进格式，推导其对应的离散时间状态更新和在单位圆上求值的离散时间传递函数。这些格式是：\n    - 前向 (显式) 欧拉法：推导 $M_{\\mathrm{FE}}$ 和 $N_{\\mathrm{FE}}$，使得\n      $$x_{k+1} = M_{\\mathrm{FE}}\\,x_k + N_{\\mathrm{FE}}\\,u_k.$$\n    - 后向 (隐式) 欧拉法：推导 $M_{\\mathrm{BE}}$ 和与步末求值一致的输入映射，\n      $$x_{k+1} = M_{\\mathrm{BE}}\\,x_k + \\tilde{N}_{\\mathrm{BE}}\\,u_{k+1}.$$\n    - 梯形法 (Crank-Nicolson (CN) 法)：推导 $M_{\\mathrm{CN}}$ 以及用于步初和步末的输入映射，\n      $$x_{k+1} = M_{\\mathrm{CN}}\\,x_k + N_{\\mathrm{CN},0}\\,u_k + N_{\\mathrm{CN},1}\\,u_{k+1}.$$\n    对于每种格式，利用后向欧拉法和 Crank-Nicolson 法输入项中的 $u_{k+1}$ 所引入的相应 $z$ 因子，定义在 $z=e^{i\\Omega}$ 处求值的离散时间传递函数 $G_d(z)$，其中 $\\Omega = \\omega h$ (无量纲)，$h$ 是时间步长 (单位：秒)。\n\n4.  量化相对于连续时间响应的数值效应。定义：\n    - 数值增益比 $\\gamma = \\frac{|G_d(e^{i\\Omega})|}{|G(i\\omega)|}$ (无量纲)。\n    - 附加数值相位误差 $\\phi_{\\mathrm{err}} = \\operatorname{Arg}\\big(G_d(e^{i\\Omega})\\big) - \\operatorname{Arg}\\big(G(i\\omega)\\big)$ (单位：弧度)，并将其归一化到主值区间 $\\left[-\\pi,\\pi\\right]$。\n\n5.  使用以下物理上合理的参数值：\n    - 有效缓发中子份额 $\\beta = 0.0065$ (无量纲)。\n    - 瞬发中子代时间 $\\Lambda = 1.0\\times 10^{-4}$ (单位：秒)。\n    - 有效单群衰变常数 $\\lambda = 0.08$ (单位：秒的倒数)。\n    - 基线归一化功率 $n_0 = 1$ (无量纲)。\n\n6.  评估指定测试套件（方法、时间步长和强迫频率的组合）的数值效应。每个测试用例是一个三元组 $(\\text{方法}, h, \\omega)$:\n    - 测试用例 1：前向欧拉法, $h = 0.001$ (秒), $\\omega = 2\\pi \\cdot 1$ (弧度/秒)。\n    - 测试用例 2：前向欧拉法, $h = 0.02$ (秒), $\\omega = 2\\pi \\cdot 1$ (弧度/秒)。\n    - 测试用例 3：后向欧拉法, $h = 0.02$ (秒), $\\omega = 2\\pi \\cdot 10$ (弧度/秒)。\n    - 测试用例 4：Crank-Nicolson 法, $h = 0.02$ (秒), $\\omega = 2\\pi \\cdot 10$ (弧度/秒)。\n    - 测试用例 5：前向欧拉法, $h = 0.005$ (秒), $\\omega = 600.0$ (弧度/秒)。\n\n7.  科学解释要求：在量化 $\\gamma$ 和 $\\phi_{\\mathrm{err}}$ 之后，阐述数值阻尼 (即 $\\gamma  1$) 或数值放大 (即 $\\gamma > 1$)，以及数值相位滞后 (即 $\\phi_{\\mathrm{err}}  0$) 在反应堆控制研究中可能如何被误读。例如，讨论过度数值阻尼如何可能被误解为更强的固有负反应性反馈，或相位滞后如何可能被误解为影响稳定性裕度的传感器延迟或执行器延迟。这种解释性映射应源自计算出的数值效应，而不引入非物理假设。\n\n所需输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。\n- 每个测试用例的结果必须是一个双元素列表，顺序为 $[\\gamma, \\phi_{\\mathrm{err}}]$，两个值都应为浮点数，并四舍五入到六位小数。\n- 因此，总输出必须是一个嵌套列表，形式如\n  $$\\big[[\\gamma_1,\\phi_{\\mathrm{err},1}],[\\gamma_2,\\phi_{\\mathrm{err},2}],\\dots\\big],$$\n  并严格以单行形式打印\n  $$\\texttt{[[g1,p1],[g2,p2],...]}.$$\n\n角度单位规范：\n- 以弧度表示 $\\phi_{\\mathrm{err}}$ (非度数)。",
            "solution": "用户提供了一个定义明确的核反应堆动力学问题，重点在于线性化点动力学方程的频域分析，以及常用时间步进格式所引入的数值效应。该问题在科学上是合理的，内容自洽，并且在算法上是可行的。\n\n解题过程系统地遵循了问题陈述中概述的任务。\n\n\\textbf{任务1：线性时不变 (LTI) 模型的推导}\n\n起点是单群点动力学方程：\n$$ \\frac{dn}{dt} = \\frac{\\rho(t) - \\beta}{\\Lambda}n(t) + \\lambda C(t) $$\n$$ \\frac{dC}{dt} = \\frac{\\beta}{\\Lambda}n(t) - \\lambda C(t) $$\n我们在临界稳态 $(\\rho_0, n_0, C_0)$ 附近对这些方程进行线性化，其中 $\\rho_0=0$，归一化中子布居为 $n_0=1$。在稳态下，时间导数为零：\n$$ 0 = \\frac{0 - \\beta}{\\Lambda}n_0 + \\lambda C_0 \\implies \\lambda C_0 = \\frac{\\beta}{\\Lambda}n_0 $$\n$$ 0 = \\frac{\\beta}{\\Lambda}n_0 - \\lambda C_0 $$\n当 $n_0=1$ 时，稳态先驱核浓度为 $C_0 = \\frac{\\beta}{\\lambda \\Lambda}$。\n\n令变量表示为其稳态值加上小的微扰：\n$n(t) = n_0 + \\delta n(t) = 1 + \\delta n(t)$\n$C(t) = C_0 + \\delta C(t)$\n$\\rho(t) = \\rho_0 + \\delta \\rho(t) = \\delta \\rho(t)$\n\n将这些代入原始方程，并只保留微扰项 ($\\delta n, \\delta C, \\delta \\rho$) 的一阶项：\n对于中子布居方程：\n$$ \\frac{d(1 + \\delta n)}{dt} = \\frac{\\delta\\rho(t) - \\beta}{\\Lambda}(1 + \\delta n(t)) + \\lambda(C_0 + \\delta C(t)) $$\n$$ \\frac{d\\delta n}{dt} \\approx \\left(\\frac{\\delta\\rho(t)}{\\Lambda} - \\frac{\\beta}{\\Lambda}\\right)(1) + \\left(\\frac{-\\beta}{\\Lambda}\\right)\\delta n(t) + \\lambda C_0 + \\lambda \\delta C(t) $$\n$$ \\frac{d\\delta n}{dt} = \\frac{\\delta\\rho}{\\Lambda}n_0 - \\frac{\\beta}{\\Lambda}n_0 - \\frac{\\beta}{\\Lambda}\\delta n + \\lambda C_0 + \\lambda \\delta C $$\n根据稳态条件，$-\\frac{\\beta}{\\Lambda}n_0 + \\lambda C_0$ 这些项相加为零。回顾 $n_0=1$：\n$$ \\frac{d\\delta n}{dt} = -\\frac{\\beta}{\\Lambda}\\delta n(t) + \\lambda \\delta C(t) + \\frac{1}{\\Lambda}\\delta \\rho(t) $$\n对于先驱核浓度方程：\n$$ \\frac{d(C_0 + \\delta C)}{dt} = \\frac{\\beta}{\\Lambda}(1 + \\delta n(t)) - \\lambda(C_0 + \\delta C(t)) $$\n$$ \\frac{d\\delta C}{dt} = \\frac{\\beta}{\\Lambda}n_0 + \\frac{\\beta}{\\Lambda}\\delta n(t) - \\lambda C_0 - \\lambda \\delta C(t)$$\n同样，稳态项 $\\frac{\\beta}{\\Lambda}n_0 - \\lambda C_0$ 相互抵消。\n$$ \\frac{d\\delta C}{dt} = \\frac{\\beta}{\\Lambda}\\delta n(t) - \\lambda \\delta C(t) $$\n现在我们可以将其写成状态空间形式 $\\frac{dx}{dt} = Ax(t) + Bu(t)$，其中 $x(t) = \\begin{bmatrix}\\delta n(t) \\\\ \\delta C(t)\\end{bmatrix}$ 且 $u(t) = \\delta \\rho(t)$。\n\n状态矩阵 $A$、输入矩阵 $B$ 和输出矩阵 $H$（对于输出 $y(t) = \\delta n(t)$）为：\n$$ A = \\begin{bmatrix} -\\frac{\\beta}{\\Lambda}  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  -\\lambda \\end{bmatrix}, \\quad B = \\begin{bmatrix} \\frac{1}{\\Lambda} \\\\ 0 \\end{bmatrix}, \\quad H = \\begin{bmatrix} 1  0 \\end{bmatrix} $$\n\n\\textbf{任务2：连续时间频率响应}\n\n从输入 $u(t)=\\delta\\rho(t)$ 到输出 $y(t)=\\delta n(t)$ 的传递函数 $G(s)$ 由 $G(s) = H(sI - A)^{-1}B$ 给出。\n首先，我们求 $(sI - A)^{-1}$：\n$$ sI - A = \\begin{bmatrix} s + \\frac{\\beta}{\\Lambda}  -\\lambda \\\\ -\\frac{\\beta}{\\Lambda}  s + \\lambda \\end{bmatrix} $$\n$$ \\det(sI - A) = \\left(s + \\frac{\\beta}{\\Lambda}\\right)(s + \\lambda) - \\lambda\\frac{\\beta}{\\Lambda} = s^2 + s\\lambda + s\\frac{\\beta}{\\Lambda} = s\\left(s + \\lambda + \\frac{\\beta}{\\Lambda}\\right) $$\n$$ (sI - A)^{-1} = \\frac{1}{\\det(sI-A)} \\begin{bmatrix} s + \\lambda  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  s + \\frac{\\beta}{\\Lambda} \\end{bmatrix} $$\n现在，我们计算 $G(s)$：\n$$ G(s) = \\begin{bmatrix} 1  0 \\end{bmatrix} \\frac{1}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} \\begin{bmatrix} s + \\lambda  \\lambda \\\\ \\frac{\\beta}{\\Lambda}  s + \\frac{\\beta}{\\Lambda} \\end{bmatrix} \\begin{bmatrix} \\frac{1}{\\Lambda} \\\\ 0 \\end{bmatrix} $$\n$$ G(s) = \\frac{1}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} \\begin{bmatrix} s+\\lambda  \\lambda \\end{bmatrix} \\begin{bmatrix} \\frac{1}{\\Lambda} \\\\ 0 \\end{bmatrix} = \\frac{\\frac{s+\\lambda}{\\Lambda}}{s(s + \\lambda + \\frac{\\beta}{\\Lambda})} $$\n这是标准的零功率反应堆传递函数。在频率 $\\omega$ 下的稳态正弦响应通过将 $s = i\\omega$（其中 $i=\\sqrt{-1}$）代入 $G(s)$ 来获得。\n\n\\textbf{任务3：离散时间模型和传递函数}\n\n我们用时间步长 $h$ 对 LTI 系统 $\\frac{dx}{dt} = Ax + Bu$ 进行离散化。\n\n\\textit{前向欧拉法 (FE):} 更新公式为 $x_{k+1} = x_k + h(Ax_k + Bu_k)$。\n$$ x_{k+1} = (I + hA)x_k + (hB)u_k $$\n这得到 $M_{\\mathrm{FE}} = I + hA$ 和 $N_{\\mathrm{FE}} = hB$。\n离散传递函数，由 z 变换 $z x(z) = M_{\\mathrm{FE}}x(z) + N_{\\mathrm{FE}}u(z)$ 得到：\n$$ G_{d, \\mathrm{FE}}(z) = H(zI - M_{\\mathrm{FE}})^{-1}N_{\\mathrm{FE}} $$\n\n\\textit{后向欧拉法 (BE):} 更新公式为 $x_{k+1} = x_k + h(Ax_{k+1} + Bu_{k+1})$。\n$$ (I - hA)x_{k+1} = x_k + hBu_{k+1} \\implies x_{k+1} = (I - hA)^{-1}x_k + h(I - hA)^{-1}Bu_{k+1} $$\n这得到 $M_{\\mathrm{BE}} = (I-hA)^{-1}$ 和 $\\tilde{N}_{\\mathrm{BE}} = h(I - hA)^{-1}B$。\n由于 $u_{k+1}$ 项的存在，z 变换为 $z x(z) = M_{\\mathrm{BE}}x(z) + z\\tilde{N}_{\\mathrm{BE}}u(z)$。传递函数为：\n$$ G_{d, \\mathrm{BE}}(z) = H(zI - M_{\\mathrm{BE}})^{-1}z\\tilde{N}_{\\mathrm{BE}} $$\n\n\\textit{Crank-Nicolson 法 (CN):} 更新公式对导数求值取平均：$x_{k+1} = x_k + \\frac{h}{2}[(Ax_k+Bu_k) + (Ax_{k+1}+Bu_{k+1})]$。\n$$ \\left(I - \\frac{h}{2}A\\right)x_{k+1} = \\left(I + \\frac{h}{2}A\\right)x_k + \\frac{h}{2}B u_k + \\frac{h}{2}B u_{k+1} $$\n$$ x_{k+1} = \\left(I - \\frac{h}{2}A\\right)^{-1}\\left(I + \\frac{h}{2}A\\right)x_k + \\left(I - \\frac{h}{2}A\\right)^{-1}\\frac{h}{2}B u_k + \\left(I - \\frac{h}{2}A\\right)^{-1}\\frac{h}{2}B u_{k+1} $$\n这得到 $M_{\\mathrm{CN}} = (I - \\frac{h}{2}A)^{-1}(I + \\frac{h}{2}A)$，$N_{\\mathrm{CN},0} = (I - \\frac{h}{2}A)^{-1}\\frac{h}{2}B$ 和 $N_{\\mathrm{CN},1} = (I - \\frac{h}{2}A)^{-1}\\frac{h}{2}B$。\nz 变换为 $z x(z) = M_{\\mathrm{CN}}x(z) + (N_{\\mathrm{CN},0} + zN_{\\mathrm{CN},1})u(z)$。传递函数为：\n$$ G_{d, \\mathrm{CN}}(z) = H(zI - M_{\\mathrm{CN}})^{-1}(N_{\\mathrm{CN},0} + zN_{\\mathrm{CN},1}) $$\n对于所有格式，频率响应通过设置 $z = e^{i\\Omega}$ 来找到，其中 $\\Omega = \\omega h$。\n\n\\textbf{任务4-6：数值效应、参数和评估}\n\n数值增益比 $\\gamma$ 和相位误差 $\\phi_{\\mathrm{err}}$ 是根据指定的参数和测试用例计算的。参数为 $\\beta = 0.0065$，$\\Lambda = 1.0 \\times 10^{-4}\\,\\mathrm{s}$，以及 $\\lambda = 0.08\\,\\mathrm{s}^{-1}$。这些值被代入矩阵 $A$、$B$ 和 $H$。每个测试用例的计算涉及复数矩阵代数，这由附带的 Python 代码执行。相位误差被归一化到区间 $[-\\pi, \\pi]$。\n\n\\textbf{任务7：科学解释}\n\n数值效应 $\\gamma$ 和 $\\phi_{\\mathrm{err}}$ 量化了数值解在频域中与真实解析解的偏差。将这些效应误解为物理现象可能导致在反应堆安全和控制分析中得出错误的结论。\n\n数值增益比 $\\gamma  1$ 表示\\textit{数值阻尼}。模拟预测的响应幅度小于实际物理响应。在反应堆控制背景下，这可能被误认为是更强的固有负反馈（如多普勒效应），使得反应堆看起来比实际更稳定、自调节能力更强。这可能导致在运行瞬态期间对功率峰值的不安全低估。\n\n相反，$\\gamma > 1$ 代表\\textit{数值放大}。这可能导致对不稳定的错误预测或对瞬态严重性的严重高估。分析师可能会得出系统不如实际稳定的结论，从而可能施加不必要的严格操作限制。\n\n数值相位误差 $\\phi_{\\mathrm{err}} \\neq 0$ 表明模拟引入了时间偏移误差。负误差 $\\phi_{\\mathrm{err}}  0$ 是\\textit{数值相位滞后}。模拟的中子布居响应将滞后于对反应性变化的真实物理响应。这一点尤其有害，因为它模仿了现实世界中的延迟，如传感器延迟或执行器延迟。由于相位滞后会侵蚀相位裕度（反馈稳定性的一个关键指标），显著的数值相位滞后可能导致对系统稳定性的不正确评估，可能掩盖潜在的不稳定性或误诊其原因。正误差 $\\phi_{\\mathrm{err}} > 0$（相位超前）对于简单方法不太常见，但会人为地增加相位裕度，描绘出对系统稳定性过于乐观的画面。\n\n总之，这些数值效应不仅仅是数学上的奇特现象；它们可以直接影响核反应堆安全分析的可信度和控制系统的设计。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the nuclear reactor kinetics numerical analysis problem.\n\n    This function performs the following steps:\n    1. Defines the physical parameters for the point kinetics model.\n    2. Defines the LTI state-space matrices (A, B, H).\n    3. Defines a list of test cases, each specifying a numerical method,\n       time step (h), and forcing frequency (omega).\n    4. For each test case:\n       a. Calculates the exact continuous-time frequency response G(i*omega).\n       b. Calculates the discrete-time frequency response G_d(exp(i*omega*h))\n          for the specified numerical method.\n       c. Computes the numerical gain ratio (gamma) and phase error (phi_err).\n    5. Formats and prints the results as required.\n    \"\"\"\n    \n    # 5. Use the following physically plausible parameter values:\n    beta = 0.0065  # Effective delayed neutron fraction\n    Lambda = 1.0e-4  # Prompt neutron generation time [s]\n    lmbda = 0.08  # Effective single-group decay constant [1/s]\n\n    # 1. Derive a Linear Time-Invariant (LTI) perturbation model\n    # A matrix\n    A = np.array([\n        [-beta / Lambda, lmbda],\n        [beta / Lambda, -lmbda]\n    ], dtype=float)\n\n    # B matrix\n    B = np.array([\n        [1.0 / Lambda],\n        [0.0]\n    ], dtype=float)\n\n    # H matrix\n    H = np.array([[1.0, 0.0]], dtype=float)\n    \n    # 6. Evaluate the numerical artifacts for the specified test suite\n    test_cases = [\n        # (method, h, omega)\n        (\"FE\", 0.001, 2.0 * np.pi * 1.0),\n        (\"FE\", 0.02, 2.0 * np.pi * 1.0),\n        (\"BE\", 0.02, 2.0 * np.pi * 10.0),\n        (\"CN\", 0.02, 2.0 * np.pi * 10.0),\n        (\"FE\", 0.005, 600.0)\n    ]\n\n    results = []\n    I = np.identity(2, dtype=float)\n\n    for method, h, omega in test_cases:\n        s = 1j * omega\n        \n        # 2. Define the continuous-time frequency response G(i*omega)\n        # G(s) = H * (sI - A)^-1 * B\n        G_continuous = H @ np.linalg.inv(s * I - A) @ B\n        G_cont_val = G_continuous[0, 0]\n\n        # 3. For three time-stepping schemes, derive discrete-time transfer function\n        Omega = omega * h\n        z = np.exp(1j * Omega)\n        \n        G_d_val = 0.0 + 0.0j\n\n        if method == \"FE\":\n            # Forward Euler\n            # x_{k+1} = (I + hA)x_k + (hB)u_k\n            # M_FE = I + hA, N_FE = hB\n            # G_d(z) = H * (zI - M_FE)^-1 * N_FE\n            M_fe = I + h * A\n            N_fe = h * B\n            G_discrete = H @ np.linalg.inv(z * I - M_fe) @ N_fe\n            G_d_val = G_discrete[0, 0]\n            \n        elif method == \"BE\":\n            # Backward Euler\n            # x_{k+1} = (I - hA)^-1 * x_k + h*(I-hA)^-1*B * u_{k+1}\n            # M_BE = (I-hA)^-1, N_tilde_BE = h*(I-hA)^-1*B\n            # G_d(z) = H * (zI - M_BE)^-1 * z*N_tilde_BE\n            inv_term_be = np.linalg.inv(I - h * A)\n            M_be = inv_term_be\n            N_tilde_be = h * inv_term_be @ B\n            G_discrete = H @ np.linalg.inv(z * I - M_be) @ (z * N_tilde_be)\n            G_d_val = G_discrete[0, 0]\n\n        elif method == \"CN\":\n            # Crank-Nicolson\n            # x_k+1 = M_CN*x_k + N_CN0*u_k + N_CN1*u_{k+1}\n            # M_CN = (I-h/2 A)^-1 * (I+h/2 A)\n            # N_CN0 = N_CN1 = (I-h/2 A)^-1 * h/2 * B\n            # G_d(z) = H * (zI - M_CN)^-1 * (N_CN0 + z*N_CN1)\n            inv_term_cn = np.linalg.inv(I - 0.5 * h * A)\n            M_cn = inv_term_cn @ (I + 0.5 * h * A)\n            N_cn0 = inv_term_cn @ (0.5 * h * B)\n            N_cn1 = N_cn0 # N_CN0 and N_CN1 are identical\n            G_discrete = H @ np.linalg.inv(z * I - M_cn) @ (N_cn0 + z * N_cn1)\n            G_d_val = G_discrete[0, 0]\n            \n        # 4. Quantify numerical artifacts\n        # Numerical gain ratio\n        gamma = np.abs(G_d_val) / np.abs(G_cont_val)\n        \n        # Additional numerical phase error\n        phi_d = np.angle(G_d_val)\n        phi_cont = np.angle(G_cont_val)\n        phi_err = phi_d - phi_cont\n        \n        # Wrap phase error to the principal interval [-pi, pi]\n        phi_err_wrapped = (phi_err + np.pi) % (2 * np.pi) - np.pi\n        \n        results.append([round(gamma, 6), round(phi_err_wrapped, 6)])\n\n    # Required output format: [[g1,p1],[g2,p2],...]\n    result_str = \",\".join([f\"[{g},{p}]\" for g, p in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "真实的反应堆瞬态过程涉及跨越多个数量级的动态变化，这使得固定时间步长显得效率低下。本练习 () 将通过开发一个能够自动调整时间步长以满足目标精度的智能求解器来应对这一挑战。通过实现基于Richardson外推法的误差估计器，您将学会如何为复杂的瞬态分析创建高效且可靠的仿真工具。",
            "id": "4239335",
            "problem": "考虑一个具有 $G$ 个缓发中子群、无外部源且中子密度归一化的核反应堆的点动力学方程：\n$$\n\\frac{dn}{dt}=\\frac{\\rho(t)-\\beta}{\\Lambda}\\,n(t)+\\sum_{i=1}^{G}\\lambda_i\\,C_i(t),\\qquad\n\\frac{dC_i}{dt}=\\frac{\\beta_i}{\\Lambda}\\,n(t)-\\lambda_i\\,C_i(t),\\quad i=1,\\dots,G.\n$$\n此处，$n(t)$ 是无量纲中子密度，$C_i(t)$ 是无量纲先驱核浓度，$\\rho(t)$ 是无量纲反应性，$\\beta=\\sum_{i=1}^{G}\\beta_i$ 是总缓发中子份额，$\\Lambda$ 是以秒为单位的瞬发中子代时间，$\\lambda_i$ 是以秒的倒数为单位的衰变常数。假设 $t=0$ 时的初始状态是一个稳态临界平衡，其中 $n(0)=1$，$C_i(0)=\\frac{\\beta_i}{\\Lambda\\,\\lambda_i}\\,n(0)$，对应于 $\\rho(0)=0$。\n\n您的任务是设计并实现一个基于 Richardson 外推法的时间步长自适应程序，在使用后向欧拉（隐式欧拉）法时控制 $n(t)$ 的局部截断误差。从点动力学方程和后向欧拉离散化的定义出发。在从 $t_k$ 到 $t_{k+1}=t_k+\\Delta t$ 的每个尝试步中，构造以下两者：\n- 一个大小为 $\\Delta t$ 的单次隐式步，产生 $(n^{\\Delta t}_{k+1},C^{\\Delta t}_{i,k+1})$，\n- 以及一对大小为 $\\Delta t/2$ 的隐式半步，产生 $(n^{\\Delta t/2}_{k+1},C^{\\Delta t/2}_{i,k+1})$。\n\n使用差值 $|n^{\\Delta t/2}_{k+1}-n^{\\Delta t}_{k+1}|$ 和方法阶数来构建 $t_{k+1}$ 时刻 $n$ 的局部误差的 Richardson 外推估计，并根据 $n$ 的目标绝对精度 $\\tau$ 接受或拒绝该步。如果该步被接受，则使用两个半步的解 $(n^{\\Delta t/2}_{k+1},C^{\\Delta t/2}_{i,k+1})$ 来推进解。使用安全因子 $s\\_f$ 和与后向欧拉法局部误差阶数一致的幂律控制器来调整下一步的 $\\Delta t$。对时间步长增长因子施加下界和上界以确保鲁棒性。对于时变反应性，将 $\\rho(t)$ 在每个隐式子步上近似为分段常数，其值在子步的结束时间处计算。\n\n对于热谱下的低浓铀，使用以下针对 $G=6$ 个缓发中子群的物理上合理的数据：\n- 缓发份额 $\\beta\\_i$：$[0.000215,\\,0.001424,\\,0.001274,\\,0.002568,\\,0.000748,\\,0.000273]$，因此 $\\beta=\\sum\\_i \\beta\\_i\\approx 0.006502$。\n- 衰变常数 $\\lambda\\_i$ (单位 $\\mathrm{s}^{-1}$): $[0.0124,\\,0.0305,\\,0.111,\\,0.301,\\,1.14,\\,3.01]$。\n- 瞬发中子代时间 $\\Lambda=5\\times 10^{-5}\\,\\mathrm{s}$。\n\n对所有测试用例使用以下自适应参数：\n- 安全因子 $s\\_f=0.9$。\n- 增长因子界限 $g\\_{\\min}=0.3$ 和 $g\\_{\\max}=2.0$。\n- 最小时间步长 $\\Delta t\\_{\\min}=10^{-12}\\,\\mathrm{s}$。\n- 当估计误差为零时，使用最大增长率 $g\\_{\\max}$。\n\n按指示为每个用例定义反应性函数 $\\rho(t)$，约定“阶跃”反应性指对于所有 $t\\ge 0$，$\\rho(t)=\\rho\\_0$；从 $0$ 到 $\\rho\\_{\\mathrm{final}}$ 在 $t\\_{\\mathrm{ramp}}$ 秒内的“斜坡”反应性指 $\\rho(t)=\\min\\!\\left(\\rho\\_{\\mathrm{final}},\\,\\rho\\_{\\mathrm{final}}\\,t/t\\_{\\mathrm{ramp}}\\right)$。\n\n通过求解在 $t_{k+1}$ 时刻和未知量 $(n\\_{k+1},C\\_{i,k+1})$ 处计算所有右端项得到的线性系统，来实现 $t_{k+1}$ 时刻的隐式欧拉步。使用双精度算术。\n\n测试套件：\n计算以下五个参数集中每一个的最终中子密度 $n(t\\_{\\mathrm{end}})$。所有时间单位为秒，反应性为无量纲。精度目标 $\\tau$ 是对 $n$ 的绝对容差。\n\n- 用例 A (次瞬发阶跃): $\\rho(t)\\equiv 0.003$, $t\\_{\\mathrm{end}}=0.5$, $\\tau=1\\times 10^{-7}$, 初始 $\\Delta t\\_0=1\\times 10^{-4}$。\n- 用例 B (瞬发超临界阶跃): $\\rho(t)\\equiv 0.010$, $t\\_{\\mathrm{end}}=0.05$, $\\tau=1\\times 10^{-6}$, 初始 $\\Delta t\\_0=1\\times 10^{-6}$。\n- 用例 C (到次瞬发的斜坡): $\\rho(t)=\\min\\!\\left(0.005,\\,0.005\\,t/0.2\\right)$, $t\\_{\\mathrm{end}}=0.3$, $\\tau=5\\times 10^{-7}$, 初始 $\\Delta t\\_0=5\\times 10^{-5}$。\n- 用例 D (严格容差): $\\rho(t)\\equiv 0.003$, $t\\_{\\mathrm{end}}=0.1$, $\\tau=1\\times 10^{-9}$, 初始 $\\Delta t\\_0=1\\times 10^{-5}$。\n- 用例 E (负阶跃): $\\rho(t)\\equiv -0.002$, $t\\_{\\mathrm{end}}=0.5$, $\\tau=1\\times 10^{-4}$, 初始 $\\Delta t\\_0=1\\times 10^{-4}$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个条目是对应 A, B, C, D, E 用例的最终 $n(t\\_{\\mathrm{end}})$，并格式化为具有恰好 $10$ 位有效数字的科学记数法（例如，$1.2345678900\\mathrm{e}{-03}$）。因此，要求的输出格式为：\"[nA,nB,nC,nD,nE]\"，其中每个 $n\\bullet$ 都按指定格式进行格式化。",
            "solution": "该问题要求为核反应堆的点动力学方程实现一个自适应时间步长的数值求解器。指定的方法是后向（隐式）欧拉格式，步长控制通过基于 Richardson 外推的误差估计来管理。该问题是适定的且在科学上是合理的，基于反应堆物理和数值分析的基本原理。在进行实现之前，我们将首先形式化其数学和算法基础。\n\n对于归一化中子密度 $n(t)$ 和 $G$ 组缓发中子先驱核浓度 $C_i(t)$ 的点动力学方程，以 $G+1$ 个耦合常微分方程（ODE）组的形式给出：\n$$\n\\frac{dn}{dt}=\\frac{\\rho(t)-\\beta}{\\Lambda}\\,n(t)+\\sum_{i=1}^{G}\\lambda_i\\,C_i(t)\n$$\n$$\n\\frac{dC_i}{dt}=\\frac{\\beta_i}{\\Lambda}\\,n(t)-\\lambda_i\\,C_i(t),\\quad i=1,\\dots,G\n$$\n这些方程可以通过定义状态向量 $\\mathbf{y}(t) = [n(t), C_1(t), \\dots, C_G(t)]^T$ 来表示为矩阵形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{A}(t)\\mathbf{y}(t)$。系统矩阵 $\\mathbf{A}(t)$ 则为：\n$$\n\\mathbf{A}(t) = \\begin{pmatrix}\n\\frac{\\rho(t)-\\beta}{\\Lambda}  \\lambda_1  \\lambda_2  \\dots  \\lambda_G \\\\\n\\frac{\\beta_1}{\\Lambda}  -\\lambda_1  0  \\dots  0 \\\\\n\\frac{\\beta_2}{\\Lambda}  0  -\\lambda_2  \\dots  0 \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n\\frac{\\beta_G}{\\Lambda}  0  0  \\dots  -\\lambda_G\n\\end{pmatrix}\n$$\n问题指定了使用后向欧拉法进行时间积分。对于从时间 $t_k$ 到 $t_{k+1} = t_k + h$ 的一个步长，该方法定义为：\n$$\n\\mathbf{y}_{k+1} = \\mathbf{y}_k + h \\left. \\frac{d\\mathbf{y}}{dt} \\right|_{t_{k+1}} = \\mathbf{y}_k + h\\mathbf{A}(t_{k+1})\\mathbf{y}_{k+1}\n$$\n整理各项可得到关于未知状态 $\\mathbf{y}_{k+1}$ 的线性系统：\n$$\n(\\mathbf{I} - h\\mathbf{A}(t_{k+1}))\\mathbf{y}_{k+1} = \\mathbf{y}_k\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。虽然这个 $(G+1) \\times (G+1)$ 的系统可以使用通用线性代数程序求解，但其特定结构允许一种更高效的直接解析解。令 $\\mathbf{y}_{k+1} = [n_{k+1}, C_{1, k+1}, \\dots, C_{G, k+1}]^T$ 和 $\\mathbf{y}_k = [n_k, C_{1, k}, \\dots, C_{G, k}]^T$。从第 $i$ 个先驱核方程：\n$$\nC_{i,k+1} = C_{i,k} + h\\left(\\frac{\\beta_i}{\\Lambda}n_{k+1} - \\lambda_i C_{i,k+1}\\right) \\implies (1+h\\lambda_i)C_{i,k+1} = C_{i,k} + \\frac{h\\beta_i}{\\Lambda}n_{k+1}\n$$\n这使我们能够用尚属未知的 $n_{k+1}$ 来表示每个 $C_{i,k+1}$：\n$$\nC_{i,k+1} = \\frac{C_{i,k} + \\frac{h\\beta_i}{\\Lambda}n_{k+1}}{1+h\\lambda_i}\n$$\n将此代入离散化的中子密度方程：\n$$\nn_{k+1} = n_k + h \\left( \\frac{\\rho_{k+1}-\\beta}{\\Lambda}n_{k+1} + \\sum_{i=1}^G \\lambda_i C_{i, k+1} \\right)\n$$\n其中 $\\rho_{k+1} = \\rho(t_{k+1})$。代入 $C_{i,k+1}$ 的表达式得到：\n$$\nn_{k+1} = n_k + h \\frac{\\rho_{k+1}-\\beta}{\\Lambda}n_{k+1} + h \\sum_{i=1}^G \\lambda_i \\left( \\frac{C_{i,k} + \\frac{h\\beta_i}{\\Lambda}n_{k+1}}{1+h\\lambda_i} \\right)\n$$\n将所有包含 $n_{k+1}$ 的项收集到左侧并求解 $n_{k+1}$，得到：\n$$\nn_{k+1} = \\frac{n_k + h \\sum_{i=1}^{G} \\frac{\\lambda_i C_{i,k}} {1+h\\lambda_i}}{1 - \\frac{h(\\rho_{k+1}-\\beta)}{\\Lambda} - \\frac{h^2}{\\Lambda} \\sum_{i=1}^{G} \\frac{\\beta_i \\lambda_i}{1+h\\lambda_i}}\n$$\n在确定了 $n_{k+1}$ 后，通过回代即可找到先驱核浓度 $C_{i,k+1}$。此过程构成一个完整的隐式欧拉步。\n\n为控制局部截断误差，我们采用基于 Richardson 外推的自适应格式。在从 $t_k$ 到 $t_{k+1}$ 每个大小为 $\\Delta t$ 的尝试步中，我们计算状态的两种近似：\n1.  $\\mathbf{y}^{\\Delta t}_{k+1}$：大小为 $\\Delta t$ 的单步结果。\n2.  $\\mathbf{y}^{\\Delta t/2}_{k+1}$：大小为 $\\Delta t/2$ 的两个连续半步的结果。\n\n后向欧拉法的全局误差为 $p=1$ 阶，意味着其局部截断误差与 $(\\Delta t)^{p+1} = (\\Delta t)^2$ 成正比。更精确的两个半步解的误差 $E_{\\Delta t/2}$，可以通过两种近似的中子密度之差来估计：\n$$\nE_{\\text{est}} \\approx |n^{\\Delta t/2}_{k+1} - n^{\\Delta t}_{k+1}|\n$$\n将此估计值与用户定义的绝对容差 $\\tau$ 进行比较。\n- 如果 $E_{\\text{est}} \\le \\tau$，则接受该步。使用更精确的解 $\\mathbf{y}^{\\Delta t/2}_{k+1}$ 将状态推进到 $t_{k+1}$。\n- 如果 $E_{\\text{est}} > \\tau$，则拒绝该步，并计算一个新的、更小的步长以从 $t_k$ 重试该步。\n\n新的时间步长 $\\Delta t_{\\text{new}}$ 由从误差阶数推导出的幂律控制器确定。我们希望新步长的误差约等于容差 $\\tau$。由于 $E_{\\text{est}} \\propto (\\Delta t_{\\text{current}})^2$，我们可以写出：\n$$\n\\frac{\\tau}{E_{\\text{est}}} \\approx \\left( \\frac{\\Delta t_{\\text{new}}}{\\Delta t_{\\text{current}}} \\right)^2 \\implies \\Delta t_{\\text{new}} \\approx \\Delta t_{\\text{current}} \\left(\\frac{\\tau}{E_{\\text{est}}}\\right)^{1/2}\n$$\n为确保稳定性和效率，引入了一个安全因子 $s_f$，并且增长/收缩因子被 $g_{\\min}$ 和 $g_{\\max}$ 界定：\n$$\ng = s_f \\left(\\frac{\\tau}{E_{\\text{est}}}\\right)^{1/2}\n$$\n$$\n\\Delta t_{\\text{new}} = \\Delta t_{\\text{current}} \\cdot \\max(g_{\\min}, \\min(g_{\\max}, g))\n$$\n无论当前步是被接受还是被拒绝，都使用此公式来设置下一个时间步长。同时还强制执行一个最小允许步长 $\\Delta t_{\\min}$。\n\n整体算法流程如下：\n1.  初始化所有物理常数（$\\Lambda, \\beta_i, \\lambda_i, \\beta = \\sum \\beta_i$）和自适应控制参数（$s_f, g_{\\min}, g_{\\max}, \\Delta t_{\\min}$）。\n2.  对每个测试用例，在 $t_0=0$ 初始化状态向量 $\\mathbf{y}_0 = [1, \\frac{\\beta_1}{\\Lambda\\lambda_1}, \\dots, \\frac{\\beta_G}{\\Lambda\\lambda_G}]^T$。设置初始时间步长 $\\Delta t = \\Delta t_0$。\n3.  开始主循环，直到 $t$ 达到 $t_{\\text{end}}$。\n4.  在循环内部，执行单步和双半步计算以找到 $n^{\\Delta t}_{k+1}$ 和 $n^{\\Delta t/2}_{k+1}$。对于时变反应性，在每个子步的结束时间处计算 $\\rho(t)$。\n5.  计算误差估计 $E_{\\text{est}}$ 和建议的下一个时间步长 $\\Delta t_{\\text{new}}$。\n6.  如果步被接受（$E_{\\text{est}} \\le \\tau$），则更新时间 $t \\leftarrow t+\\Delta t$，更新状态向量 $\\mathbf{y} \\leftarrow \\mathbf{y}^{\\Delta t/2}_{k+1}$，并将下一个时间步长设置为 $\\Delta t_{\\text{new}}$。\n7.  如果步被拒绝（$E_{\\text{est}} > \\tau$），不更新时间或状态，但为下一次尝试减小时间步长至 $\\Delta t_{\\text{new}}$。\n8.  重复此过程，直到模拟时间达到 $t_{\\text{end}}$。$n(t)$ 的最终值即为所求结果。\n这为解决给定问题提供了一个完整、鲁棒且高效的程序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the point kinetics equations for the given test cases\n    using an adaptive backward Euler method.\n    \"\"\"\n    # Physical constants for G=6 delayed groups\n    BETA_I = np.array([0.000215, 0.001424, 0.001274, 0.002568, 0.000748, 0.000273])\n    LAMBDA_I = np.array([0.0124, 0.0305, 0.111, 0.301, 1.14, 3.01])\n    G = 6\n    BETA = np.sum(BETA_I)\n    LAMBDA = 5e-5  # Prompt neutron generation time in seconds\n\n    # Adaptation parameters\n    S_F = 0.9\n    G_MIN = 0.3\n    G_MAX = 2.0\n    DT_MIN = 1e-12\n\n    # Test cases\n    test_cases = [\n        {'name': 'A', 'rho_func': lambda t: 0.003, 't_end': 0.5, 'tau': 1e-7, 'dt0': 1e-4},\n        {'name': 'B', 'rho_func': lambda t: 0.010, 't_end': 0.05, 'tau': 1e-6, 'dt0': 1e-6},\n        {'name': 'C', 'rho_func': lambda t: min(0.005, 0.005 * t / 0.2), 't_end': 0.3, 'tau': 5e-7, 'dt0': 5e-5},\n        {'name': 'D', 'rho_func': lambda t: 0.003, 't_end': 0.1, 'tau': 1e-9, 'dt0': 1e-5},\n        {'name': 'E', 'rho_func': lambda t: -0.002, 't_end': 0.5, 'tau': 1e-4, 'dt0': 1e-4},\n    ]\n\n    def analytic_implicit_step(y_k, h, t_end_step, rho_func):\n        \"\"\"\n        Performs one implicit Euler step using the analytic solution for the linear system.\n        \n        Args:\n            y_k (np.ndarray): State vector [n, C1, ..., CG] at the beginning of the step.\n            h (float): Time step size.\n            t_end_step (float): Time at the end of the step.\n            rho_func (callable): Function for reactivity rho(t).\n\n        Returns:\n            np.ndarray: State vector y_k+1 at the end of the step.\n        \"\"\"\n        n_k = y_k[0]\n        C_k = y_k[1:]\n        \n        rho_kp1 = rho_func(t_end_step)\n        \n        # Denominators for C_i and n expressions\n        den_C_i = 1.0 + h * LAMBDA_I\n        \n        # Numerator for n_kp1\n        num_n = n_k + h * np.sum(LAMBDA_I * C_k / den_C_i)\n        \n        # Denominator for n_kp1\n        den_n = 1.0 - (h * (rho_kp1 - BETA) / LAMBDA) - (h**2 / LAMBDA) * np.sum(BETA_I * LAMBDA_I / den_C_i)\n        \n        n_kp1 = num_n / den_n\n        \n        # Back-substitute to find C_i_kp1\n        C_kp1 = (C_k + (h * BETA_I / LAMBDA) * n_kp1) / den_C_i\n        \n        return np.concatenate(([n_kp1], C_kp1))\n\n    results = []\n    for case in test_cases:\n        # Initial conditions\n        t = 0.0\n        n0 = 1.0\n        C0 = BETA_I * n0 / (LAMBDA * LAMBDA_I)\n        y = np.concatenate(([n0], C0))\n        \n        dt = case['dt0']\n        tau = case['tau']\n        t_end = case['t_end']\n        rho_func = case['rho_func']\n        \n        while t  t_end:\n            # Ensure the step does not overshoot t_end\n            if t + dt > t_end:\n                dt = t_end - t\n\n            # Perform two calculations for Richardson extrapolation\n            # 1. Single large step of size dt\n            y_dt = analytic_implicit_step(y, dt, t + dt, rho_func)\n            n_dt = y_dt[0]\n            \n            # 2. Two half-steps of size dt/2\n            y_half1 = analytic_implicit_step(y, dt / 2.0, t + dt / 2.0, rho_func)\n            y_dt_2 = analytic_implicit_step(y_half1, dt / 2.0, t + dt, rho_func)\n            n_dt_2 = y_dt_2[0]\n            \n            # Estimate local error\n            # For BE (p=1), error of more accurate solution is approx |n_dt_2 - n_dt|\n            error_est = abs(n_dt_2 - n_dt)\n            \n            # Step size adaptation logic\n            if error_est = tau:\n                # Accept step\n                t += dt\n                y = y_dt_2  # Advance with more accurate solution\n                \n                # Calculate next time step\n                if error_est == 0.0:\n                    g = G_MAX\n                else:\n                    g = S_F * (tau / error_est)**0.5\n                \n                dt = dt * max(G_MIN, min(G_MAX, g))\n                dt = max(dt, DT_MIN)\n\n            else:\n                # Reject step, recalculate dt for retry\n                g = S_F * (tau / error_est)**0.5\n                dt = dt * max(G_MIN, min(G_MAX, g))\n                dt = max(dt, DT_MIN)\n\n        results.append(y[0])\n\n    # Format output as specified\n    formatted_results = [f\"{res:.10e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}