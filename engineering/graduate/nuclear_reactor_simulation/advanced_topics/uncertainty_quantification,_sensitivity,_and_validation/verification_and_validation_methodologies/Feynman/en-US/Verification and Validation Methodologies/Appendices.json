{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in any simulation is to ensure that the numerical errors inherent in the discretization process are understood and controlled, a core task of solution verification. The Grid Convergence Index (GCI) offers a standardized, quantitative method for estimating the discretization error in a simulation result. Based on Richardson extrapolation, it provides an error band on the fine-grid solution, allowing us to assess how close our computed value is to the asymptotic numerical result. This exercise will give you hands-on experience in applying the GCI methodology to simulation data, a fundamental skill for establishing the credibility of computational models .",
            "id": "4003027",
            "problem": "A one-dimensional, steady-state conduction problem is solved in a homogeneous slab of length $L$ with Dirichlet boundary conditions $T(0)=T_{0}$ and $T(L)=T_{L}$ and constant thermal conductivity $k$. A finite-volume discretization with second-order central differencing is used to compute the wall heat flux magnitude at $x=0$, denoted by $\\phi$. Three uniform meshes are employed with $N_{3}=32$, $N_{2}=64$, and $N_{1}=128$ control volumes, so that the uniform refinement ratios satisfy $r_{32}=h_{3}/h_{2}=2$ and $r_{21}=h_{2}/h_{1}=2$, where $h_{j}=L/N_{j}$. The computed quantities of interest on these meshes are\n$\\phi_{3}=1.0160\\times 10^{4}$, $\\phi_{2}=1.0040\\times 10^{4}$, and $\\phi_{1}=1.0010\\times 10^{4}$.\nA separate three-grid analysis has established an apparent order of accuracy $p_{\\mathrm{obs}}=1.98$ for this quantity. Using the classical definition of the Grid Convergence Index (GCI) for the fine grid based on the discretization error model and Richardson extrapolation, and adopting the recommended safety factor $F_{s}=1.25$ for three-grid verification in the asymptotic range, compute the fine-grid Grid Convergence Index $\\mathrm{GCI}_{21}$ for $\\phi$ using the $(1,2)$ grid pair and $p_{\\mathrm{obs}}$. Round your final answer to four significant figures and express it as a dimensionless decimal fraction. In your solution, justify the GCI formula from the discretization error model and interpret the role of the safety factor $F_{s}$ in the GCI expression (conceptual interpretation only; the final answer must be the computed numerical value).",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective.\n\n**Step 1: Extract Givens**\n- **Problem Type**: One-dimensional, steady-state heat conduction in a homogeneous slab.\n- **Boundary Conditions**: Dirichlet conditions, $T(0)=T_{0}$ and $T(L)=T_{L}$.\n- **Material Property**: Constant thermal conductivity $k$.\n- **Numerical Method**: Finite-volume discretization with second-order central differencing.\n- **Quantity of Interest**: Wall heat flux magnitude at $x=0$, denoted by $\\phi$.\n- **Grids**: Three uniform meshes with $N_{3}=32$, $N_{2}=64$, and $N_{1}=128$ control volumes.\n- **Grid Sizes**: $h_{j} = L/N_{j}$.\n- **Refinement Ratios**: $r_{32} = h_{3}/h_{2} = 2$ and $r_{21} = h_{2}/h_{1} = 2$.\n- **Computed Solutions**: $\\phi_{3}=1.0160\\times 10^{4}$, $\\phi_{2}=1.0040\\times 10^{4}$, and $\\phi_{1}=1.0010\\times 10^{4}$.\n- **Observed Order of Accuracy**: $p_{\\mathrm{obs}}=1.98$.\n- **Safety Factor**: $F_{s}=1.25$.\n- **Task**: Compute the fine-grid Grid Convergence Index, $\\mathrm{GCI}_{21}$, using the grid pair $(1,2)$ and $p_{\\mathrm{obs}}$. The final answer must be rounded to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is grounded in the established field of computational heat transfer and fluid dynamics. The Grid Convergence Index (GCI) is a standard and widely accepted method for quantifying discretization error, as outlined in the editorial policies of major engineering journals (e.g., ASME Journal of Fluids Engineering). The procedure is based on Richardson extrapolation, a robust mathematical technique.\n- **Well-Posed**: The problem provides all necessary data—three grid solutions, the refinement ratio, the observed order of accuracy, and the safety factor—to compute a unique value for the GCI.\n- **Objective**: The problem is stated using precise, standard terminology from numerical analysis and heat transfer. There are no subjective or ambiguous statements.\n\n**Step 3: Verdict and Action**\nThe problem is valid as it is scientifically sound, self-contained, and well-posed. A complete solution will be provided.\n\n**Solution Derivation**\n\nThe foundation of the Grid Convergence Index (GCI) is the modeling of discretization error. For a numerical scheme with an order of accuracy $p$, the solution $\\phi_h$ on a grid with characteristic size $h$ can be expressed via a Taylor series expansion of the error:\n$$\n\\phi_h = \\phi_{\\mathrm{exact}} + c h^p + O(h^{p+1})\n$$\nwhere $\\phi_{\\mathrm{exact}}$ is the exact (unknown) solution to the continuum equations, and $c$ is a constant that depends on higher-order derivatives of the solution.\n\nAssuming the grid is fine enough to be in the \"asymptotic range,\" the higher-order terms $O(h^{p+1})$ are negligible, and the error is dominated by the leading term:\n$$\n\\phi_h \\approx \\phi_{\\mathrm{exact}} + c h^p\n$$\n\nWe apply this model to two grids: a fine grid (grid $1$) with size $h_1$ and a coarser grid (grid $2$) with size $h_2$. The grid refinement ratio is $r_{21} = h_2/h_1$. The solutions on these grids are:\n$$\n\\phi_1 \\approx \\phi_{\\mathrm{exact}} + c h_1^p\n$$\n$$\n\\phi_2 \\approx \\phi_{\\mathrm{exact}} + c h_2^p = \\phi_{\\mathrm{exact}} + c (r_{21} h_1)^p\n$$\nThis forms a system of two algebraic equations for the unknowns $\\phi_{\\mathrm{exact}}$ and $c$. We can eliminate $c$ to solve for a more accurate estimate of $\\phi_{\\mathrm{exact}}$, known as the Richardson extrapolated solution, $\\phi_{\\mathrm{extrap}}^{21}$:\n$$\n\\phi_{\\mathrm{extrap}}^{21} = \\frac{r_{21}^p \\phi_1 - \\phi_2}{r_{21}^p - 1} = \\phi_1 + \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1}\n$$\nThe estimated error in the fine-grid solution, $E_a^{21}$, is the difference between the fine-grid solution and this extrapolated value:\n$$\nE_a^{21} = \\phi_{\\mathrm{extrap}}^{21} - \\phi_1 = \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1}\n$$\nThe GCI is defined as a measure of the uncertainty in the fine-grid solution. It is based on the magnitude of the estimated error, scaled by a factor of safety $F_s$, and is typically expressed as a relative quantity with respect to the fine-grid solution itself.\n$$\n\\mathrm{GCI}_{21} = F_s \\frac{|E_a^{21}|}{|\\phi_1|} = F_s \\frac{1}{|\\phi_1|} \\left| \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1} \\right|\n$$\nSince $r_{21} = 2 > 1$ and $p_{\\mathrm{obs}} = 1.98 > 0$, the term $r_{21}^p - 1$ is positive. The formula can be written as:\n$$\n\\mathrm{GCI}_{21} = \\frac{F_s}{r_{21}^p - 1} \\left| \\frac{\\phi_1 - \\phi_2}{\\phi_1} \\right|\n$$\n\nThe factor of safety, $F_s$, serves to create a conservative error band. Its value reflects the confidence in the assumptions underlying the extrapolation. The Richardson extrapolation assumes the numerical solution is in the asymptotic range, which may not be perfectly true. $F_s > 1$ (e.g., $F_s=1.25$ for three-grid studies with a well-behaved order of convergence) inflates the estimated error to create an uncertainty interval, $\\phi_1 \\pm (\\mathrm{GCI}_{21} \\cdot \\phi_1)$, that is likely (e.g., with $95\\%$ confidence) to contain the exact solution $\\phi_{\\mathrm{exact}}$.\n\n**Calculation**\n\nWe now substitute the given values into the derived formula for $\\mathrm{GCI}_{21}$.\nThe givens are:\n- Fine-grid solution: $\\phi_1 = 1.0010 \\times 10^4$\n- Coarse-grid solution: $\\phi_2 = 1.0040 \\times 10^4$\n- Refinement ratio: $r_{21} = 2$\n- Observed order of accuracy: $p = p_{\\mathrm{obs}} = 1.98$\n- Factor of safety: $F_s = 1.25$\n\nFirst, we compute the relative difference between the two solutions:\n$$\n\\left| \\frac{\\phi_1 - \\phi_2}{\\phi_1} \\right| = \\left| \\frac{1.0010 \\times 10^4 - 1.0040 \\times 10^4}{1.0010 \\times 10^4} \\right| = \\left| \\frac{-0.0030 \\times 10^4}{1.0010 \\times 10^4} \\right| = \\frac{0.0030}{1.0010} = \\frac{3}{1001}\n$$\nNext, we compute the denominator term involving the order of accuracy:\n$$\nr_{21}^p - 1 = 2^{1.98} - 1\n$$\nNow, substitute these into the GCI formula:\n$$\n\\mathrm{GCI}_{21} = \\frac{1.25}{2^{1.98} - 1} \\times \\frac{3}{1001}\n$$\nWe compute the numerical value:\n$$\n2^{1.98} \\approx 3.944835\n$$\n$$\nr_{21}^p - 1 \\approx 2.944835\n$$\n$$\n\\frac{3}{1001} \\approx 0.002997003\n$$\n$$\n\\mathrm{GCI}_{21} \\approx \\frac{1.25}{2.944835} \\times 0.002997003 \\approx (0.424469) \\times (0.002997003) \\approx 0.00127214\n$$\nThe problem requires rounding the final answer to four significant figures. The first four significant figures are $1$, $2$, $7$, and $2$. The fifth digit is $1$, so we round down.\n$$\n\\mathrm{GCI}_{21} \\approx 0.001272\n$$\nThis value represents an estimated uncertainty of approximately $0.1272\\%$ in the fine-grid solution $\\phi_1$.",
            "answer": "$$\n\\boxed{0.001272}\n$$"
        },
        {
            "introduction": "For complex, non-linear, or coupled systems like those in reactor physics, exact analytical solutions for verification are often unavailable. The Method of Manufactured Solutions (MMS) provides a rigorous and powerful framework for code verification in their absence. MMS works \"in reverse\" by defining a desired (manufactured) solution and substituting it into the governing equations to derive the necessary source terms that make it an exact solution of a slightly modified problem. By working through the derivation of source terms for a coupled neutronics and thermal feedback model, you will learn how to apply this technique to verify the correct implementation of complex physics and their interactions in a simulation code .",
            "id": "4260225",
            "problem": "A nuclear reactor simulator is to be verified using the Method of Manufactured Solutions (MMS). Consider a single-energy-group, time-dependent neutron diffusion model with Doppler temperature feedback coupled to a thermal energy balance. The governing equations are the neutron balance and the thermal energy equation, which follow from neutron conservation with Fick’s law and energy conservation, respectively,\n$$\n\\frac{1}{v}\\,\\frac{\\partial \\phi(\\mathbf{x},t)}{\\partial t} - \\nabla \\cdot \\left( D \\,\\nabla \\phi(\\mathbf{x},t) \\right) + \\Sigma_{a}(T(\\mathbf{x},t))\\,\\phi(\\mathbf{x},t) = \\nu\\,\\Sigma_{f}(T(\\mathbf{x},t))\\,\\phi(\\mathbf{x},t) + S_{n}(\\mathbf{x},t),\n$$\n$$\n\\rho\\,c_{p}\\,\\frac{\\partial T(\\mathbf{x},t)}{\\partial t} - \\nabla \\cdot \\left( k \\,\\nabla T(\\mathbf{x},t) \\right) = \\epsilon_{f}\\,\\Sigma_{f}(T(\\mathbf{x},t))\\,\\phi(\\mathbf{x},t) - h\\,\\big(T(\\mathbf{x},t)-T_{\\mathrm{cool}}\\big) + S_{T}(\\mathbf{x},t).\n$$\nHere, $v$ is the neutron speed, $D$ is the diffusion coefficient, $\\Sigma_{a}$ is the macroscopic absorption cross section, $\\nu\\,\\Sigma_{f}$ is the neutron production term from fission, $\\rho$ is the density, $c_{p}$ is the specific heat capacity at constant pressure, $k$ is the thermal conductivity, $\\epsilon_{f}$ is the volumetric fission energy release coefficient, $h$ is a linear heat transfer coefficient, $T_{\\mathrm{cool}}$ is a prescribed coolant temperature, and $S_{n}$ and $S_{T}$ are manufactured volumetric source terms. To embed Doppler feedback in a scientifically plausible way, assume temperature dependencies\n$$\n\\Sigma_{a}(T) = \\Sigma_{a0}\\,\\sqrt{\\frac{T}{T_{0}}}, \n\\qquad \n\\Sigma_{f}(T) = \\Sigma_{f0}\\,\\exp\\!\\big(-\\alpha_{D}\\,\\big(T-T_{0}\\big)\\big),\n$$\nwith $\\Sigma_{a0}$, $\\Sigma_{f0}$, $T_{0}$, and $\\alpha_{D}$ being positive constants.\n\nPrescribe the manufactured neutron flux and temperature fields over a cubic domain of side length $L$ as\n$$\n\\phi(\\mathbf{x},t) = \\phi_{0}\\left[1 + a\\,\\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{L}\\right)\\sin\\!\\left(\\frac{\\pi z}{L}\\right)\\right]\\exp(\\lambda t),\n$$\n$$\nT(\\mathbf{x},t) = T_{0} + \\Theta_{0}\\,\\cos\\!\\left(\\frac{\\pi x}{L}\\right)\\cos\\!\\left(\\frac{\\pi y}{L}\\right)\\cos\\!\\left(\\frac{\\pi z}{L}\\right)\\exp(\\mu t),\n$$\nwhere $\\phi_{0}$, $a$, $\\lambda$, $\\Theta_{0}$, $\\mu$, and $L$ are given constants and $\\mathbf{x}=(x,y,z)$. Assume spatially uniform $D$, $v$, $\\rho$, $c_{p}$, $k$, $h$, $\\epsilon_{f}$, $\\Sigma_{a0}$, $\\Sigma_{f0}$, $T_{0}$, $\\alpha_{D}$, and $T_{\\mathrm{cool}}$.\n\nStarting from the governing equations and the above manufactured fields, derive both manufactured source terms $S_{n}(\\mathbf{x},t)$ and $S_{T}(\\mathbf{x},t)$ and explicitly identify how Doppler feedback couples $T(\\mathbf{x},t)$ into the neutron equation through $\\Sigma_{a}(T)$ and $\\Sigma_{f}(T)$. Then, provide the closed-form analytic expression for the manufactured neutron source term $S_{n}(\\mathbf{x},t)$ obtained by substituting the prescribed $\\phi(\\mathbf{x},t)$ and $T(\\mathbf{x},t)$ and collecting terms.\n\nExpress the final answer for $S_{n}(\\mathbf{x},t)$ in neutrons per centimeter cubed per second. No rounding is required; give the exact analytic expression in terms of the given symbols.",
            "solution": "The problem statement will first be validated for scientific soundness, self-consistency, and clarity before a solution is attempted.\n\n### Step 1: Extract Givens\nThe governing equations for the coupled neutronics/thermal-hydraulics system are:\nNeutron balance:\n$$\n\\frac{1}{v}\\,\\frac{\\partial \\phi(\\mathbf{x},t)}{\\partial t} - \\nabla \\cdot \\left( D \\,\\nabla \\phi(\\mathbf{x},t) \\right) + \\Sigma_{a}(T(\\mathbf{x},t))\\,\\phi(\\mathbf{x},t) = \\nu\\,\\Sigma_{f}(T(\\mathbf{x},t))\\,\\phi(\\mathbf{x},t) + S_{n}(\\mathbf{x},t)\n$$\nThermal energy balance:\n$$\n\\rho\\,c_{p}\\,\\frac{\\partial T(\\mathbf{x},t)}{\\partial t} - \\nabla \\cdot \\left( k \\,\\nabla T(\\mathbf{x},t) \\right) = \\epsilon_{f}\\,\\Sigma_{f}(T(\\mathbf{x},t))\\,\\phi(\\mathbf{x},t) - h\\,\\big(T(\\mathbf{x},t)-T_{\\mathrm{cool}}\\big) + S_{T}(\\mathbf{x},t)\n$$\nThe temperature dependencies of the macroscopic cross sections are given as:\n$$\n\\Sigma_{a}(T) = \\Sigma_{a0}\\,\\sqrt{\\frac{T}{T_{0}}}, \\qquad \\Sigma_{f}(T) = \\Sigma_{f0}\\,\\exp\\!\\big(-\\alpha_{D}\\,\\big(T-T_{0}\\big)\\big)\n$$\nThe manufactured solutions for the neutron flux $\\phi$ and temperature $T$ are prescribed as:\n$$\n\\phi(\\mathbf{x},t) = \\phi_{0}\\left[1 + a\\,\\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{L}\\right)\\sin\\!\\left(\\frac{\\pi z}{L}\\right)\\right]\\exp(\\lambda t)\n$$\n$$\nT(\\mathbf{x},t) = T_{0} + \\Theta_{0}\\,\\cos\\!\\left(\\frac{\\pi x}{L}\\right)\\cos\\!\\left(\\frac{\\pi y}{L}\\right)\\cos\\!\\left(\\frac{\\pi z}{L}\\right)\\exp(\\mu t)\n$$\nThe following parameters are given as spatially uniform constants: $v$, $D$, $\\rho$, $c_{p}$, $k$, $h$, $\\epsilon_{f}$, $\\Sigma_{a0}$, $\\Sigma_{f0}$, $T_{0}$, $\\alpha_{D}$, and $T_{\\mathrm{cool}}$. The parameters $\\phi_0$, $a$, $\\lambda$, $\\Theta_0$, $\\mu$, and $L$ are also given constants. The domain is a cube of side length $L$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation against established criteria.\n- **Scientifically Grounded**: The problem uses a standard, albeit simplified, model for reactor physics: the time-dependent, one-group neutron diffusion equation coupled with a heat conduction/convection equation. The temperature dependencies for the cross-sections, $\\Sigma_a(T)$ and $\\Sigma_f(T)$, are plausible representations of physical phenomena such as Doppler broadening. The Method of Manufactured Solutions (MMS) is a rigorous and standard technique for code verification. Therefore, the problem is scientifically sound.\n- **Well-Posed**: The task is to derive expressions for source terms $S_n$ and $S_T$ that make the prescribed functions $\\phi(\\mathbf{x},t)$ and $T(\\mathbf{x},t)$ exact solutions to the governing equations. This is an algebraic and calculus-based substitution exercise, not a problem of solving the partial differential equations themselves. A unique solution for the source terms exists and is determined by the prescribed fields and their derivatives.\n- **Objective**: The problem is formulated with precise mathematical expressions and definitions. There are no subjective or opinion-based statements.\n- **Completeness and Consistency**: All necessary equations, manufactured fields, and constants are provided. There are no missing data or contradictions. The assumption of uniform coefficients is a standard simplification for such problems.\n- **Feasibility and Plausibility**: The manufactured solutions are smooth, continuous, and differentiable, which is required for the application of the differential operators. The setup is physically and mathematically consistent.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. It is a well-posed, scientifically grounded problem in the field of nuclear engineering code verification. A solution will now be derived.\n\n### Derivation\n\nThe Method of Manufactured Solutions (MMS) requires us to substitute the chosen manufactured solutions for $\\phi(\\mathbf{x},t)$ and $T(\\mathbf{x},t)$ into the governing partial differential equations. The equations will not balance. The residual terms are then collected and defined as the manufactured source terms, $S_n(\\mathbf{x},t)$ and $S_T(\\mathbf{x},t)$. By implementing these source terms in a numerical simulator, one can verify if the code converges to the known, exact manufactured solution.\n\nFirst, we rearrange the governing equations to solve for the source terms:\n$$\nS_{n}(\\mathbf{x},t) = \\frac{1}{v}\\,\\frac{\\partial \\phi}{\\partial t} - \\nabla \\cdot \\left( D \\,\\nabla \\phi \\right) + \\left[ \\Sigma_{a}(T) - \\nu\\,\\Sigma_{f}(T) \\right] \\phi\n$$\n$$\nS_{T}(\\mathbf{x},t) = \\rho\\,c_{p}\\,\\frac{\\partial T}{\\partial t} - \\nabla \\cdot \\left( k \\,\\nabla T \\right) - \\epsilon_{f}\\,\\Sigma_{f}(T)\\,\\phi + h\\,\\left(T-T_{\\mathrm{cool}}\\right)\n$$\nThe coupling from the temperature field $T(\\mathbf{x},t)$ to the neutron field $\\phi(\\mathbf{x},t)$ occurs through the temperature-dependent cross sections $\\Sigma_a(T)$ and $\\Sigma_f(T)$. The functions $\\Sigma_a(T(\\mathbf{x},t))$ and $\\Sigma_f(T(\\mathbf{x},t))$ act as spatially and temporally varying coefficients in the neutron balance equation, directly linking the thermal state of the reactor to its neutronic behavior. This is the explicit representation of Doppler and other temperature feedback mechanisms in this model.\n\nTo derive $S_n(\\mathbf{x},t)$, we compute each term in its defining equation using the given manufactured solutions.\n\n**1. Time Derivative of Flux:**\n$$\n\\frac{\\partial \\phi}{\\partial t} = \\frac{\\partial}{\\partial t} \\left\\{ \\phi_{0}\\left[1 + a\\,\\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{L}\\right)\\sin\\!\\left(\\frac{\\pi z}{L}\\right)\\right]\\exp(\\lambda t) \\right\\} = \\lambda\\,\\phi(\\mathbf{x},t)\n$$\nThe first term of $S_n$ is $\\frac{1}{v}\\frac{\\partial \\phi}{\\partial t} = \\frac{\\lambda}{v}\\,\\phi(\\mathbf{x},t)$.\n\n**2. Diffusion Term:**\nSince the diffusion coefficient $D$ is uniform, $\\nabla \\cdot (D \\nabla \\phi) = D \\nabla^2 \\phi$.\nWe compute the Laplacian of $\\phi$:\n$$\n\\nabla^2 \\phi = \\nabla^2 \\left\\{ \\phi_{0}\\left[1 + a\\,\\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{L}\\right)\\sin\\!\\left(\\frac{\\pi z}{L}\\right)\\right]\\exp(\\lambda t) \\right\\}\n$$\nThe Laplacian operates only on the spatial part. Let $\\phi_s(\\mathbf{x}) = \\sin(\\frac{\\pi x}{L})\\sin(\\frac{\\pi y}{L})\\sin(\\frac{\\pi z}{L})$.\n$$\n\\nabla^2\\phi_s = \\left(\\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}\\right) \\phi_s = \\left[-\\left(\\frac{\\pi}{L}\\right)^2 - \\left(\\frac{\\pi}{L}\\right)^2 - \\left(\\frac{\\pi}{L}\\right)^2\\right]\\phi_s = -3\\left(\\frac{\\pi}{L}\\right)^2\\phi_s\n$$\nThus,\n$$\n\\nabla^2\\phi = \\phi_0 a \\left[-3\\left(\\frac{\\pi}{L}\\right)^2 \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{L}\\right)\\sin\\!\\left(\\frac{\\pi z}{L}\\right)\\right]\\exp(\\lambda t)\n$$\nThe diffusion term in the $S_n$ equation is:\n$$\n-\\nabla \\cdot (D \\nabla \\phi) = -D \\nabla^2 \\phi = 3D\\left(\\frac{\\pi}{L}\\right)^2 a \\phi_0 \\sin\\!\\left(\\frac{\\pi x}{L}\\right)\\sin\\!\\left(\\frac{\\pi y}{L}\\right)\\sin\\!\\left(\\frac{\\pi z}{L}\\right)\\exp(\\lambda t)\n$$\n\n**3. Reaction Term:**\nThe reaction term is $[\\Sigma_{a}(T) - \\nu\\,\\Sigma_{f}(T)]\\phi$. We substitute the expressions for $T(\\mathbf{x},t)$, $\\Sigma_a(T)$, $\\Sigma_f(T)$, and $\\phi(\\mathbf{x},t)$.\nLet $T_c(\\mathbf{x}) = \\cos(\\frac{\\pi x}{L})\\cos(\\frac{\\pi y}{L})\\cos(\\frac{\\pi z}{L})$.\nThen $T(\\mathbf{x},t) = T_0 + \\Theta_0 T_c(\\mathbf{x}) \\exp(\\mu t)$.\n$$\n\\Sigma_a(T) = \\Sigma_{a0}\\sqrt{\\frac{T_0 + \\Theta_0 T_c(\\mathbf{x}) \\exp(\\mu t)}{T_0}} = \\Sigma_{a0}\\sqrt{1 + \\frac{\\Theta_0}{T_0} T_c(\\mathbf{x}) \\exp(\\mu t)}\n$$\n$$\n\\nu\\Sigma_f(T) = \\nu\\Sigma_{f0}\\exp\\left(-\\alpha_D \\left[ (T_0 + \\Theta_0 T_c(\\mathbf{x}) \\exp(\\mu t)) - T_0 \\right]\\right) = \\nu\\Sigma_{f0}\\exp\\left(-\\alpha_D \\Theta_0 T_c(\\mathbf{x}) \\exp(\\mu t)\\right)\n$$\nThe full reaction term is the product of $(\\Sigma_a(T) - \\nu\\Sigma_f(T))$ and $\\phi(\\mathbf{x},t)$.\n\n**4. Assembling the Neutron Source Term $S_n(\\mathbf{x},t)$:**\nWe sum the derived terms:\n$$\nS_n(\\mathbf{x},t) = \\frac{\\lambda}{v}\\phi(\\mathbf{x},t) - D\\nabla^2\\phi(\\mathbf{x},t) + \\left[\\Sigma_a(T(\\mathbf{x},t)) - \\nu\\Sigma_f(T(\\mathbf{x},t))\\right]\\phi(\\mathbf{x},t)\n$$\nSubstituting the expressions:\n$$\nS_n(\\mathbf{x},t) = \\frac{\\lambda}{v} \\phi_0\\left[1 + a\\,\\phi_s(\\mathbf{x})\\right]\\exp(\\lambda t) + 3D\\left(\\frac{\\pi}{L}\\right)^2 a \\phi_0 \\phi_s(\\mathbf{x})\\exp(\\lambda t) + \\left[\\Sigma_a(T(\\mathbf{x},t)) - \\nu\\Sigma_f(T(\\mathbf{x},t))\\right] \\phi_0\\left[1 + a\\,\\phi_s(\\mathbf{x})\\right]\\exp(\\lambda t)\n$$\nWe can collect terms. The expression is more organized by factoring out the flux $\\phi(\\mathbf{x},t)$:\n$$\nS_n(\\mathbf{x},t) = \\left(\\frac{\\lambda}{v} + \\Sigma_a(T(\\mathbf{x},t)) - \\nu\\Sigma_f(T(\\mathbf{x},t))\\right) \\phi(\\mathbf{x},t) - D\\nabla^2\\phi(\\mathbf{x},t)\n$$\nThis gives the final analytic expression for $S_n(\\mathbf{x},t)$ by substituting the full forms for $\\phi$, $T$, and $\\nabla^2\\phi$:\n$$\nS_n(\\mathbf{x},t) = \\left( \\frac{\\lambda}{v} + \\Sigma_{a0}\\sqrt{1 + \\frac{\\Theta_0}{T_0}T_c(\\mathbf{x})\\exp(\\mu t)} - \\nu\\Sigma_{f0}\\exp(-\\alpha_D \\Theta_0 T_c(\\mathbf{x})\\exp(\\mu t)) \\right) \\phi_0(1+a\\phi_s(\\mathbf{x}))\\exp(\\lambda t) + 3D\\left(\\frac{\\pi}{L}\\right)^2 a \\phi_0 \\phi_s(\\mathbf{x})\\exp(\\lambda t)\n$$\nFactoring out $\\phi_0 \\exp(\\lambda t)$ yields the final form presented in the answer box.\n\nFor completeness, the derivation of $S_T(\\mathbf{x},t)$ follows the same procedure.\n1. $\\frac{\\partial T}{\\partial t} = \\mu \\Theta_0 T_c(\\mathbf{x}) \\exp(\\mu t)$.\n2. $\\nabla^2 T = -3(\\frac{\\pi}{L})^2 \\Theta_0 T_c(\\mathbf{x}) \\exp(\\mu t)$.\n3.Assemble $S_T$:\n$$\nS_T(\\mathbf{x},t) = \\rho c_p \\mu \\Theta_0 T_c(\\mathbf{x})\\exp(\\mu t) + 3k\\left(\\frac{\\pi}{L}\\right)^2 \\Theta_0 T_c(\\mathbf{x})\\exp(\\mu t) - \\epsilon_f \\Sigma_f(T(\\mathbf{x},t))\\phi(\\mathbf{x},t) + h(T_0 + \\Theta_0 T_c(\\mathbf{x})\\exp(\\mu t) - T_{\\mathrm{cool}})\n$$\nGrouping terms gives:\n$$\nS_T(\\mathbf{x},t) = \\Theta_0 \\left[\\rho c_p \\mu + 3k\\left(\\frac{\\pi}{L}\\right)^2 + h\\right]T_c(\\mathbf{x})\\exp(\\mu t) + h(T_0 - T_{\\mathrm{cool}}) - \\epsilon_f \\Sigma_f(T(\\mathbf{x},t))\\phi(\\mathbf{x},t)\n$$\nThis completes the derivation of both source terms as requested. The final answer requires only the expression for $S_n(\\mathbf{x},t)$.",
            "answer": "$$\n\\boxed{\\phi_{0}\\exp(\\lambda t)\\left\\{ \\left[1 + a\\sin\\left(\\frac{\\pi x}{L}\\right)\\sin\\left(\\frac{\\pi y}{L}\\right)\\sin\\left(\\frac{\\pi z}{L}\\right)\\right]\\left(\\frac{\\lambda}{v} + \\Sigma_{a0}\\sqrt{1 + \\frac{\\Theta_{0}}{T_{0}}\\cos\\left(\\frac{\\pi x}{L}\\right)\\cos\\left(\\frac{\\pi y}{L}\\right)\\cos\\left(\\frac{\\pi z}{L}\\right)\\exp(\\mu t)} - \\nu\\Sigma_{f0}\\exp\\left(-\\alpha_{D}\\Theta_{0}\\cos\\left(\\frac{\\pi x}{L}\\right)\\cos\\left(\\frac{\\pi y}{L}\\right)\\cos\\left(\\frac{\\pi z}{L}\\right)\\exp(\\mu t)\\right)\\right) + 3D\\left(\\frac{\\pi}{L}\\right)^{2}a\\sin\\left(\\frac{\\pi x}{L}\\right)\\sin\\left(\\frac{\\pi y}{L}\\right)\\sin\\left(\\frac{\\pi z}{L}\\right) \\right\\}}\n$$"
        },
        {
            "introduction": "Beyond verification (ensuring the code solves the equations correctly), we must address uncertainty in the model's inputs, such as material properties and boundary conditions. Uncertainty Quantification (UQ) and reliability analysis are essential for assessing confidence in simulation predictions, particularly in safety-critical applications. The First-Order Reliability Method (FORM) is an efficient probabilistic technique for estimating the failure probability of a system by identifying the most probable failure point in the space of uncertain parameters. This practice involves implementing the iterative Hasofer-Lind-Rackwitz-Fiessler (HL-RF) algorithm to find a system's reliability index $\\beta$, providing you with a practical understanding of how to move from deterministic simulation to probabilistic risk assessment .",
            "id": "4260213",
            "problem": "You are tasked with implementing the First-Order Reliability Method (FORM) to compute the reliability index $\\beta$ and the corresponding failure probability for a limit state related to fuel centerline temperature in a nuclear fuel rod under steady-state conditions. The context is Verification and Validation (V&V) methodologies in nuclear reactor simulation, and your implementation must be general, starting from fundamental laws and standard probabilistic definitions, without relying on shortcut formulas. The limit state is defined as exceeding a specified material temperature limit. The physics model is grounded in steady-state heat conduction with uniform volumetric heat generation in a solid cylinder with convective cooling at the surface.\n\nUse the following physically justified model for the fuel centerline temperature. For a solid cylindrical fuel rod of radius $R$ with uniform volumetric heat generation $\\dot{q}^{\\prime\\prime\\prime}$, thermal conductivity $k$, and convective cooling characterized by heat transfer coefficient $h$ to a coolant at temperature $T_{\\mathrm{c}}$, the centerline temperature is\n$$\nT_{\\mathrm{center}} = T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right).\n$$\nThis follows from the steady-state heat equation in cylindrical coordinates with uniform generation and boundary condition $-k \\left.\\frac{\\partial T}{\\partial r}\\right|_{r=R} = h (T(R) - T_{\\mathrm{c}})$, equating the surface heat flux to the convective heat transfer. The safety limit is a fixed fuel temperature limit $T_{\\mathrm{limit}}$, and the limit-state function is\n$$\ng(\\mathbf{X}) = T_{\\mathrm{limit}} - T_{\\mathrm{center}}(\\mathbf{X}),\n$$\nwhere $\\mathbf{X} = [T_{\\mathrm{c}}, \\dot{q}^{\\prime\\prime\\prime}, h, k, R]$. Failure occurs when $g(\\mathbf{X}) \\le 0$.\n\nYou must compute the reliability index $\\beta$ using the First-Order Reliability Method (FORM). Define the standard normal space variables $\\mathbf{u} = [u_1, u_2, u_3, u_4, u_5]$ that are independent and standard normal. Use the isoprobabilistic transformation for independent input variables:\n- For a normal variable $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$, use $x(u) = \\mu + \\sigma u$ and Jacobian component $\\frac{\\partial x}{\\partial u} = \\sigma$.\n- For a lognormal variable $X \\sim \\mathrm{Lognormal}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$ with underlying normal $Y=\\ln X \\sim \\mathcal{N}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$, parameterize $\\mu_{\\ln}$ and $\\sigma_{\\ln}$ by the physical mean $m$ and coefficient of variation $c_v$ via $\\sigma_{\\ln} = \\sqrt{\\ln(1 + c_v^2)}$ and $\\mu_{\\ln} = \\ln(m) - \\frac{1}{2}\\sigma_{\\ln}^2$, then use $x(u) = \\exp(\\mu_{\\ln} + \\sigma_{\\ln} u)$ and Jacobian component $\\frac{\\partial x}{\\partial u} = \\sigma_{\\ln} x$.\n\nCompute the gradient of the limit-state function in physical space $\\nabla_{\\mathbf{X}} g(\\mathbf{X})$ from first principles, using the fuel temperature model above. Map this gradient to the standard normal space via the Jacobian of the transformation to obtain $\\nabla_{\\mathbf{u}} g(\\mathbf{u})$. Implement the Hasofer-Lind-Rackwitz-Fiessler (HL-RF) iterative algorithm with linearization of the limit-state function to update $\\mathbf{u}$:\n$$\n\\mathbf{u}_{k+1} = -\\lambda_k \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k), \\quad \\text{where} \\quad \\lambda_k = \\frac{g(\\mathbf{u}_k) - \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)^{\\top} \\mathbf{u}_k}{\\left\\|\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\\right\\|^2}.\n$$\nInitialize with $\\mathbf{u}_0 = [0,0,0,0,0]$. Iterate until convergence is reached, for example when $\\left\\|\\mathbf{u}_{k+1} - \\mathbf{u}_k\\right\\| < \\varepsilon$, with a small tolerance $\\varepsilon$ such as $\\varepsilon = 10^{-8}$, or a maximum number of iterations is reached. At convergence, compute the reliability index as\n$$\n\\beta = \\left\\|\\mathbf{u}^*\\right\\|,\n$$\nwhere $\\mathbf{u}^*$ is the converged design point in standard normal space. Convert the reliability index to failure probability using the standard normal cumulative distribution function $\\Phi(\\cdot)$ as\n$$\np_{\\mathrm{f}} = \\Phi(-\\beta),\n$$\nand report $p_{\\mathrm{f}}$ as a decimal.\n\nAll physical and numerical units must be respected:\n- $T_{\\mathrm{limit}}$ and $T_{\\mathrm{c}}$ in $\\mathrm{K}$ (Kelvin).\n- $\\dot{q}^{\\prime\\prime\\prime}$ in $\\mathrm{W}/\\mathrm{m}^3$.\n- $h$ in $\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$.\n- $k$ in $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$.\n- $R$ in $\\mathrm{m}$ (meters).\nThe outputs $\\beta$ and $p_{\\mathrm{f}}$ are dimensionless; express $p_{\\mathrm{f}}$ as a decimal.\n\nImplement your solution in a general, reusable manner that follows the principles above and works for the following test suite, which exercises a typical safe case, a near-boundary case, and a high-risk case. All variables are independent.\n\nUse $T_{\\mathrm{limit}} = 1800\\,\\mathrm{K}$ in all cases.\n\nTest Case $1$ (typical safe operating conditions):\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\mu = 580\\,\\mathrm{K}, \\sigma = 15\\,\\mathrm{K})$.\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$ with mean $m = 1.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$ and coefficient of variation $c_v = 0.10$.\n- $h \\sim \\mathrm{Lognormal}$ with mean $m = 20000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$ and $c_v = 0.15$.\n- $k \\sim \\mathrm{Lognormal}$ with mean $m = 2.5\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$ and $c_v = 0.20$.\n- $R \\sim \\mathrm{Lognormal}$ with mean $m = 0.004\\,\\mathrm{m}$ and $c_v = 0.01$.\n\nTest Case $2$ (near boundary):\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\mu = 650\\,\\mathrm{K}, \\sigma = 20\\,\\mathrm{K})$.\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$ with mean $m = 3.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$ and $c_v = 0.10$.\n- $h \\sim \\mathrm{Lognormal}$ with mean $m = 5000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$ and $c_v = 0.20$.\n- $k \\sim \\mathrm{Lognormal}$ with mean $m = 1.5\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$ and $c_v = 0.25$.\n- $R \\sim \\mathrm{Lognormal}$ with mean $m = 0.0045\\,\\mathrm{m}$ and $c_v = 0.02$.\n\nTest Case $3$ (high risk):\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\mu = 700\\,\\mathrm{K}, \\sigma = 30\\,\\mathrm{K})$.\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$ with mean $m = 4.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$ and $c_v = 0.15$.\n- $h \\sim \\mathrm{Lognormal}$ with mean $m = 3000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$ and $c_v = 0.25$.\n- $k \\sim \\mathrm{Lognormal}$ with mean $m = 1.0\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$ and $c_v = 0.30$.\n- $R \\sim \\mathrm{Lognormal}$ with mean $m = 0.0050\\,\\mathrm{m}$ and $c_v = 0.03$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\beta_1, p_{\\mathrm{f},1}, \\beta_2, p_{\\mathrm{f},2}, \\beta_3, p_{\\mathrm{f},3}]$, where the subscript denotes the test case index. Each entry must be a floating-point number.",
            "solution": "The problem is assessed to be valid. It is a well-posed, scientifically grounded problem in reliability analysis applied to nuclear engineering thermal-hydraulics. The physical model, mathematical formulation, and numerical algorithm are all standard and clearly defined. All necessary data are provided.\n\nThe objective is to compute the reliability index $\\beta$ and the probability of failure $p_{\\mathrm{f}}$ for a nuclear fuel rod's centerline temperature exceeding a safety limit. This is achieved by implementing the First-Order Reliability Method (FORM) with the Hasofer-Lind-Rackwitz-Fiessler (HL-RF) iterative algorithm.\n\nThe core of the problem involves transforming the random physical variables into a standard normal space and finding the point on the failure surface closest to the origin in this space. The distance to this point is the reliability index $\\beta$.\n\n**1. Limit State Function and Physical Variables**\n\nThe vector of independent random variables in the physical space is $\\mathbf{X} = [x_1, x_2, x_3, x_4, x_5]^{\\top} = [T_{\\mathrm{c}}, \\dot{q}^{\\prime\\prime\\prime}, h, k, R]^{\\top}$. The fuel centerline temperature is given by:\n$$\nT_{\\mathrm{center}}(\\mathbf{X}) = T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right)\n$$\nThe safety limit is a constant temperature $T_{\\mathrm{limit}}$. The limit-state function $g(\\mathbf{X})$ defines the boundary between safe and failure states. Failure is defined as the condition where the centerline temperature exceeds the limit, which corresponds to $g(\\mathbf{X}) \\le 0$.\n$$\ng(\\mathbf{X}) = T_{\\mathrm{limit}} - T_{\\mathrm{center}}(\\mathbf{X}) = T_{\\mathrm{limit}} - \\left[ T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right) \\right]\n$$\n\n**2. Gradient in Physical Space**\n\nThe HL-RF algorithm requires the gradient of the limit-state function. We first compute this gradient with respect to the physical variables, $\\nabla_{\\mathbf{X}} g(\\mathbf{X})$. The partial derivatives are:\n- $\\frac{\\partial g}{\\partial T_{\\mathrm{c}}} = -1$\n- $\\frac{\\partial g}{\\partial \\dot{q}^{\\prime\\prime\\prime}} = -\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right)$\n- $\\frac{\\partial g}{\\partial h} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial h}\\left(\\frac{R}{2h}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(-\\frac{R}{2h^2}\\right) = \\frac{\\dot{q}^{\\prime\\prime\\prime} R}{2h^2}$\n- $\\frac{\\partial g}{\\partial k} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial k}\\left(\\frac{R^2}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(-\\frac{R^2}{4k^2}\\right) = \\frac{\\dot{q}^{\\prime\\prime\\prime} R^2}{4k^2}$\n- $\\frac{\\partial g}{\\partial R} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial R}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{1}{2h} + \\frac{2R}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{1}{2h} + \\frac{R}{2k}\\right)$\n\n**3. Isoprobabilistic Transformation and Jacobian**\n\nThe physical variables $\\mathbf{X}$ are transformed into a vector of independent standard normal variables $\\mathbf{u} = [u_1, u_2, u_3, u_4, u_5]^{\\top}$. The transformation $x_i(u_i)$ and its derivative $\\frac{\\partial x_i}{\\partial u_i}$ depend on the probability distribution of $x_i$.\n\n- For a normally distributed variable $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$:\n  $$x(u) = \\mu + \\sigma u$$\n  $$\\frac{\\partial x}{\\partial u} = \\sigma$$\n\n- For a lognormally distributed variable $X \\sim \\mathrm{Lognormal}$ with mean $m$ and coefficient of variation $c_v$:\n  The parameters of the underlying normal distribution $Y = \\ln X \\sim \\mathcal{N}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$ are first calculated:\n  $$\\sigma_{\\ln}^2 = \\ln(1 + c_v^2)$$\n  $$\\mu_{\\ln} = \\ln(m) - \\frac{1}{2}\\sigma_{\\ln}^2$$\n  The transformation and its derivative are:\n  $$x(u) = \\exp(\\mu_{\\ln} + \\sigma_{\\ln} u)$$\n  $$\\frac{\\partial x}{\\partial u} = \\frac{d}{du} \\left( e^{\\mu_{\\ln} + \\sigma_{\\ln} u} \\right) = e^{\\mu_{\\ln} + \\sigma_{\\ln} u} \\cdot \\sigma_{\\ln} = \\sigma_{\\ln} x(u)$$\n\n**4. Gradient in Standard Normal Space**\n\nThe gradient in the standard normal space, $\\nabla_{\\mathbf{u}} g(\\mathbf{u})$, is found using the chain rule. Since the transformations are independent, the Jacobian matrix $\\mathbf{J}_{\\mathbf{X},\\mathbf{u}}$ is diagonal with entries $J_{ii} = \\frac{\\partial x_i}{\\partial u_i}$.\n$$\n\\nabla_{\\mathbf{u}} g(\\mathbf{u}) = \\mathbf{J}_{\\mathbf{X},\\mathbf{u}}^{\\top} \\nabla_{\\mathbf{X}} g(\\mathbf{X}(\\mathbf{u}))\n$$\nThe components of the gradient are therefore:\n$$\n\\frac{\\partial g}{\\partial u_i} = \\frac{\\partial g}{\\partial x_i} \\frac{\\partial x_i}{\\partial u_i}\n$$\nThese must be evaluated at the current iteration's point $\\mathbf{u}_k$ by first computing the corresponding physical values $\\mathbf{X}(\\mathbf{u}_k)$.\n\n**5. HL-RF Algorithm**\n\nThe HL-RF algorithm is a fixed-point iteration scheme to find the design point $\\mathbf{u}^*$, which is the point on the failure surface $g(\\mathbf{u}) = 0$ with the minimum distance to the origin.\n\n1. Initialize the iteration with $\\mathbf{u}_0 = \\mathbf{0}$.\n2. For iteration $k=0, 1, 2, \\dots$:\n   a. Compute the physical variables $\\mathbf{X}_k = \\mathbf{X}(\\mathbf{u}_k)$.\n   b. Evaluate the limit-state function $g(\\mathbf{u}_k) = g(\\mathbf{X}_k)$.\n   c. Evaluate the gradient in physical space $\\nabla_{\\mathbf{X}} g(\\mathbf{X}_k)$.\n   d. Compute the Jacobian components $\\frac{\\partial x_i}{\\partial u_i}$ at $\\mathbf{u}_k$.\n   e. Compute the gradient in standard normal space $\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)$.\n   f. Calculate the update parameter $\\lambda_k$:\n      $$\n      \\lambda_k = \\frac{g(\\mathbf{u}_k) - \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)^{\\top} \\mathbf{u}_k}{\\left\\|\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\\right\\|^2}\n      $$\n   g. Update the standard normal vector $\\mathbf{u}_{k+1}$:\n      $$\n      \\mathbf{u}_{k+1} = -\\lambda_k \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\n      $$\n3. Check for convergence. The iteration stops when $\\left\\|\\mathbf{u}_{k+1} - \\mathbf{u}_k\\right\\| < \\varepsilon$, where $\\varepsilon$ is a small tolerance (e.g., $10^{-8}$). The converged point is the design point $\\mathbf{u}^*$.\n\n**6. Reliability Index and Failure Probability**\n\nOnce the algorithm converges to the design point $\\mathbf{u}^*$, the reliability index $\\beta$ is the Euclidean norm (distance from the origin) of this point:\n$$\n\\beta = \\left\\|\\mathbf{u}^*\\right\\| = \\sqrt{\\sum_{i=1}^n (u_i^*)^2}\n$$\nThe first-order approximation of the probability of failure $p_{\\mathrm{f}}$ is then computed using the standard normal cumulative distribution function, $\\Phi(\\cdot)$:\n$$\np_{\\mathrm{f}} = \\Phi(-\\beta)\n$$\nThis procedure is implemented for each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n#\n# === Probabilistic Variable Definitions ===\n#\nclass NormalVariable:\n    \"\"\"Represents a normally distributed random variable.\"\"\"\n    def __init__(self, mean, std_dev):\n        self.mean = float(mean)\n        self.std_dev = float(std_dev)\n\n    def transform(self, u):\n        \"\"\"Maps a standard normal variable u to the physical variable x.\"\"\"\n        return self.mean + self.std_dev * u\n\n    def jacobian_component(self, u, x):\n        \"\"\"Computes the component of the Jacobian d(x)/d(u).\"\"\"\n        return self.std_dev\n\nclass LognormalVariable:\n    \"\"\"Represents a lognormally distributed random variable.\"\"\"\n    def __init__(self, mean, cv):\n        self.m = float(mean)\n        self.cv = float(cv)\n        \n        # Pre-compute parameters of the underlying normal distribution\n        sigma_ln_sq = np.log(1.0 + self.cv**2)\n        self.sigma_ln = np.sqrt(sigma_ln_sq)\n        self.mu_ln = np.log(self.m) - 0.5 * sigma_ln_sq\n\n    def transform(self, u):\n        \"\"\"Maps a standard normal variable u to the physical variable x.\"\"\"\n        return np.exp(self.mu_ln + self.sigma_ln * u)\n\n    def jacobian_component(self, u, x):\n        \"\"\"Computes the component of the Jacobian d(x)/d(u).\"\"\"\n        return self.sigma_ln * x\n\n#\n# === First-Order Reliability Method (FORM) Solver ===\n#\ndef solve_form(variables, T_limit, epsilon=1e-8, max_iter=100):\n    \"\"\"\n    Computes the reliability index and failure probability using FORM-HLRF.\n    \"\"\"\n    num_vars = len(variables)\n    u = np.zeros(num_vars)\n\n    for i in range(max_iter):\n        u_old = u.copy()\n        \n        # 1. Transform from standard normal space (u) to physical space (x)\n        x = np.array([var.transform(u_i) for var, u_i in zip(variables, u)])\n        Tc, q_dot, h, k, R = x\n        \n        # 2. Evaluate the limit-state function g(u)\n        T_center = Tc + q_dot * (R / (2.0 * h) + R**2 / (4.0 * k))\n        g_val = T_limit - T_center\n        \n        # 3. Evaluate the gradient of g in physical space, grad_x(g)\n        grad_g_x = np.array([\n            -1.0,\n            -(R / (2.0 * h) + R**2 / (4.0 * k)),\n            (q_dot * R) / (2.0 * h**2),\n            (q_dot * R**2) / (4.0 * k**2),\n            -q_dot * (1.0 / (2.0 * h) + R / (2.0 * k))\n        ])\n\n        # 4. Compute the gradient of g in standard normal space, grad_u(g)\n        jac_components = np.array([var.jacobian_component(u_i, x_i) \n                                   for var, u_i, x_i in zip(variables, u, x)])\n        grad_g_u = grad_g_x * jac_components\n        \n        # 5. Apply the HL-RF update rule\n        norm_grad_g_u = np.linalg.norm(grad_g_u)\n        if norm_grad_g_u < 1e-12: # Avoid division by zero\n            # If gradient is near zero and g is also near zero, we might have converged.\n            if abs(g_val) < epsilon:\n                break\n            else:\n                # This case is unlikely for this problem but is good practice to handle.\n                # A zero gradient far from the failure surface indicates a problem.\n                raise RuntimeError(\"HL-RF failed: zero gradient encountered.\")\n\n        lambda_k = (g_val - np.dot(grad_g_u, u)) / (norm_grad_g_u**2)\n        u = -lambda_k * grad_g_u\n        \n        # 6. Check for convergence\n        if np.linalg.norm(u - u_old) < epsilon:\n            break\n    \n    # 7. Compute reliability index (beta) and probability of failure (p_f)\n    beta = np.linalg.norm(u)\n    p_f = norm.cdf(-beta)\n    \n    return beta, p_f\n\n#\n# === Main Execution Block ===\n#\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (typical safe operating conditions)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=580.0, std_dev=15.0),\n                LognormalVariable(mean=1.0e8, cv=0.10),\n                LognormalVariable(mean=20000.0, cv=0.15),\n                LognormalVariable(mean=2.5, cv=0.20),\n                LognormalVariable(mean=0.004, cv=0.01)\n            ]\n        },\n        # Test Case 2 (near boundary)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=650.0, std_dev=20.0),\n                LognormalVariable(mean=3.0e8, cv=0.10),\n                LognormalVariable(mean=5000.0, cv=0.20),\n                LognormalVariable(mean=1.5, cv=0.25),\n                LognormalVariable(mean=0.0045, cv=0.02)\n            ]\n        },\n        # Test Case 3 (high risk)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=700.0, std_dev=30.0),\n                LognormalVariable(mean=4.0e8, cv=0.15),\n                LognormalVariable(mean=3000.0, cv=0.25),\n                LognormalVariable(mean=1.0, cv=0.30),\n                LognormalVariable(mean=0.0050, cv=0.03)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, p_f = solve_form(case['variables'], case['T_limit'])\n        results.extend([beta, p_f])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}