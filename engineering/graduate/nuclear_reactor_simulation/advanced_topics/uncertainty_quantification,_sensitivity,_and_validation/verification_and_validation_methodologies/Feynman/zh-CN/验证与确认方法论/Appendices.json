{
    "hands_on_practices": [
        {
            "introduction": "在验证计算代码时，首要任务是量化离散化误差，即数值解与精确解之间的差异。网格收敛指数（Grid Convergence Index, GCI）是一种基于理查德森外推法的标准化方法，用于估算离散化误差并为精细网格解提供一个不确定性区间。这项实践将指导你计算GCI，让你掌握评估数值模拟收敛性和准确性的基本技能。",
            "id": "4003027",
            "problem": "一个一维稳态热传导问题在一个长度为 $L$ 的均匀板中求解，边界条件为狄利克雷（Dirichlet）边界条件 $T(0)=T_{0}$ 和 $T(L)=T_{L}$，热导率为常数 $k$。采用具有二阶中心差分的有限体积法离散化来计算 $x=0$ 处的壁面热流密度大小，记为 $\\phi$。使用了三套均匀网格，控制体数量分别为 $N_{3}=32$、$N_{2}=64$ 和 $N_{1}=128$，因此均匀加密比满足 $r_{32}=h_{3}/h_{2}=2$ 和 $r_{21}=h_{2}/h_{1}=2$，其中 $h_{j}=L/N_{j}$。在这些网格上计算得到的目标量为\n$\\phi_{3}=1.0160\\times 10^{4}$、$\\phi_{2}=1.0040\\times 10^{4}$ 和 $\\phi_{1}=1.0010\\times 10^{4}$。\n一项独立的三网格分析已确定该量的表观精度阶为 $p_{\\mathrm{obs}}=1.98$。使用基于离散误差模型和 Richardson 外推法的网格收敛指数（GCI）的经典定义，并采用在渐近范围内进行三网格验证时推荐的安全系数 $F_{s}=1.25$，利用 $(1,2)$ 网格对和 $p_{\\mathrm{obs}}$ 计算 $\\phi$ 的细网格收敛指数 $\\mathrm{GCI}_{21}$。将最终答案四舍五入至四位有效数字，并表示为无量纲的小数。在你的解答中，从离散误差模型的角度论证 GCI 公式，并解释安全系数 $F_{s}$ 在 GCI 表达式中的作用（仅需概念性解释；最终答案必须是计算出的数值）。",
            "solution": "首先验证问题，以确保其具有科学依据、是适定的且客观的。\n\n**步骤1：提取已知条件**\n- **问题类型**：一维稳态热传导，均匀板。\n- **边界条件**：狄利克雷（Dirichlet）条件，$T(0)=T_{0}$ 和 $T(L)=T_{L}$。\n- **材料属性**：恒定热导率 $k$。\n- **数值方法**：具有二阶中心差分的有限体积法离散化。\n- **目标量**：$x=0$ 处的壁面热流密度大小，记为 $\\phi$。\n- **网格**：三套均匀网格，控制体数量分别为 $N_{3}=32$、$N_{2}=64$ 和 $N_{1}=128$。\n- **网格尺寸**：$h_{j} = L/N_{j}$。\n- **加密比**：$r_{32} = h_{3}/h_{2} = 2$ 和 $r_{21} = h_{2}/h_{1} = 2$。\n- **计算解**：$\\phi_{3}=1.0160\\times 10^{4}$、$\\phi_{2}=1.0040\\times 10^{4}$ 和 $\\phi_{1}=1.0010\\times 10^{4}$。\n- **观测精度阶**：$p_{\\mathrm{obs}}=1.98$。\n- **安全系数**：$F_{s}=1.25$。\n- **任务**：使用 $(1,2)$ 网格对和 $p_{\\mathrm{obs}}$ 计算细网格收敛指数 $\\mathrm{GCI}_{21}$。最终答案必须四舍五入至四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于计算传热学和流体动力学这一成熟领域。网格收敛指数（GCI）是量化离散误差的标准且被广泛接受的方法，正如主要工程期刊（例如ASME Journal of Fluids Engineering）的编辑政策中所述。该程序基于 Richardson 外推法，这是一种稳健的数学技术。\n- **适定性**：该问题提供了计算 GCI 唯一值所需的所有数据——三套网格解、加密比、观测精度阶和安全系数。\n- **客观性**：该问题使用数值分析和传热学中的精确、标准术语进行陈述。没有主观或含糊的陈述。\n\n**步骤3：结论与行动**\n该问题是有效的，因为它科学上合理、自洽且适定。将提供完整的解答。\n\n**解答推导**\n\n网格收敛指数（GCI）的基础是离散误差的建模。对于一个精度阶为 $p$ 的数值格式，在特征尺寸为 $h$ 的网格上得到的解 $\\phi_h$ 可以通过误差的泰勒级数展开表示为：\n$$\n\\phi_h = \\phi_{\\mathrm{exact}} + c h^p + O(h^{p+1})\n$$\n其中 $\\phi_{\\mathrm{exact}}$ 是连续介质方程的精确（未知）解，$c$ 是一个取决于解的高阶导数的常数。\n\n假设网格足够细以至于处于“渐近范围”，则高阶项 $O(h^{p+1})$ 可以忽略不计，误差由主导项决定：\n$$\n\\phi_h \\approx \\phi_{\\mathrm{exact}} + c h^p\n$$\n\n我们将此模型应用于两套网格：尺寸为 $h_1$ 的细网格（网格1）和尺寸为 $h_2$ 的粗网格（网格2）。网格加密比为 $r_{21} = h_2/h_1$。在这些网格上的解为：\n$$\n\\phi_1 \\approx \\phi_{\\mathrm{exact}} + c h_1^p\n$$\n$$\n\\phi_2 \\approx \\phi_{\\mathrm{exact}} + c h_2^p = \\phi_{\\mathrm{exact}} + c (r_{21} h_1)^p\n$$\n这构成了一个关于未知数 $\\phi_{\\mathrm{exact}}$ 和 $c$ 的两个代数方程组。我们可以消去 $c$ 来求解 $\\phi_{\\mathrm{exact}}$ 的一个更精确的估计值，该值被称为 Richardson 外推解 $\\phi_{\\mathrm{extrap}}^{21}$：\n$$\n\\phi_{\\mathrm{extrap}}^{21} = \\frac{r_{21}^p \\phi_1 - \\phi_2}{r_{21}^p - 1} = \\phi_1 + \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1}\n$$\n细网格解的估计误差 $E_a^{21}$ 是细网格解与此外推值之差：\n$$\nE_a^{21} = \\phi_{\\mathrm{extrap}}^{21} - \\phi_1 = \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1}\n$$\nGCI被定义为衡量细网格解不确定性的一种度量。它基于估计误差的大小，并按安全系数 $F_s$ 进行缩放，通常表示为相对于细网格解本身的相对量。\n$$\n\\mathrm{GCI}_{21} = F_s \\frac{|E_a^{21}|}{|\\phi_1|} = F_s \\frac{1}{|\\phi_1|} \\left| \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1} \\right|\n$$\n由于 $r_{21} = 2 > 1$ 且 $p_{\\mathrm{obs}} = 1.98 > 0$，因此项 $r_{21}^p - 1$ 是正的。该公式可以写为：\n$$\n\\mathrm{GCI}_{21} = \\frac{F_s}{r_{21}^p - 1} \\left| \\frac{\\phi_1 - \\phi_2}{\\phi_1} \\right|\n$$\n\n安全系数 $F_s$ 用于创建一个保守的误差带。其值反映了对外推法所基于的假设的置信度。Richardson 外推法假设数值解处于渐近范围内，但这可能不完全成立。$F_s > 1$（例如，对于收敛阶表现良好的三网格研究，$F_s=1.25$）会扩大估计误差，从而创建一个不确定性区间 $\\phi_1 \\pm (\\mathrm{GCI}_{21} \\cdot \\phi_1)$，该区间很可能（例如，具有 $95\\%$ 的置信度）包含精确解 $\\phi_{\\mathrm{exact}}$。\n\n**计算**\n\n现在我们将给定的值代入推导出的 $\\mathrm{GCI}_{21}$ 公式中。\n已知条件如下：\n- 细网格解：$\\phi_1 = 1.0010 \\times 10^4$\n- 粗网格解：$\\phi_2 = 1.0040 \\times 10^4$\n- 加密比：$r_{21} = 2$\n- 观测精度阶：$p = p_{\\mathrm{obs}} = 1.98$\n- 安全系数：$F_s = 1.25$\n\n首先，我们计算两个解之间的相对差异：\n$$\n\\left| \\frac{\\phi_1 - \\phi_2}{\\phi_1} \\right| = \\left| \\frac{1.0010 \\times 10^4 - 1.0040 \\times 10^4}{1.0010 \\times 10^4} \\right| = \\left| \\frac{-0.0030 \\times 10^4}{1.0010 \\times 10^4} \\right| = \\frac{0.0030}{1.0010} = \\frac{3}{1001}\n$$\n接下来，我们计算分母中包含精度阶的项：\n$$\nr_{21}^p - 1 = 2^{1.98} - 1\n$$\n现在，将这些代入 GCI 公式：\n$$\n\\mathrm{GCI}_{21} = \\frac{1.25}{2^{1.98} - 1} \\times \\frac{3}{1001}\n$$\n我们计算其数值：\n$$\n2^{1.98} \\approx 3.944835\n$$\n$$\nr_{21}^p - 1 \\approx 2.944835\n$$\n$$\n\\frac{3}{1001} \\approx 0.002997003\n$$\n$$\n\\mathrm{GCI}_{21} \\approx \\frac{1.25}{2.944835} \\times 0.002997003 \\approx (0.424469) \\times (0.002997003) \\approx 0.00127214\n$$\n题目要求将最终答案四舍五入至四位有效数字。前四位有效数字是 $1$、$2$、$7$ 和 $2$。第五位数字是 $1$，所以我们向下舍入。\n$$\n\\mathrm{GCI}_{21} \\approx 0.001272\n$$\n该值表示细网格解 $\\phi_1$ 中约 $0.1272\\%$ 的估计不确定性。",
            "answer": "$$\n\\boxed{0.001272}\n$$"
        },
        {
            "introduction": "确认代码能够正确求解其所基于的偏微分方程是验证过程的核心。制造解方法（Method of Manufactured Solutions, MMS）是一种精确而强大的技术，用于系统性地验证代码的实现是否正确。通过本练习，你将学习如何为一个给定的偏微分方程设计一个制造解，推导出相应的源项和边界条件，这是验证复杂模拟软件正确性的关键步骤。",
            "id": "4003053",
            "problem": "一个计算传热学代码将使用制造解方法（Method of Manufactured Solutions, MMS）进行验证。考虑在单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 上，对于时间 $t>0$，在具有恒定热扩散率 $\\alpha>0$ 的均匀、各向同性介质中的二维瞬态热传导。关于标量场 $u(x,y,t)$ 的控制方程为\n$$\n\\frac{\\partial u}{\\partial t}=\\alpha\\left(\\frac{\\partial^{2}u}{\\partial x^{2}}+\\frac{\\partial^{2}u}{\\partial y^{2}}\\right)+S(x,y,t),\n$$\n其中 $S(x,y,t)$ 是一个体积源项。\n\n使用制造解方法（MMS），令制造解为\n$$\nu(x,y,t)=\\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^{2}\\alpha t).\n$$\n\n以能量守恒和傅里叶定律为基础，推导相应的制造源项 $S(x,y,t)$，该源项使得 $u(x,y,t)$ 成为控制方程的精确解。然后，指定与制造解严格一致且适用于在 $\\partial\\Omega$ 所有边界上使用狄利克雷（Dirichlet）数据进行代码验证的边界条件和初始条件。\n\n答案规格：\n- 以一个行向量的形式提供最终答案，该向量包含三个条目，顺序如下：$S(x,y,t)$ 的解析表达式、初始条件 $u(x,y,0)$ 以及施加在 $\\partial\\Omega$ 上的狄利克雷边值 $g(x,y,t)$。\n- 答案仅用 $x$、$y$、$t$、$\\alpha$ 和 $\\pi$ 表示。\n- 无需进行数值计算或四舍五入，最终答案中也无需报告物理单位。",
            "solution": "用户希望我解决以下问题：\n一个计算传热学代码将使用制造解方法（Method of Manufactured Solutions, MMS）进行验证。考虑在单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 上，对于时间 $t>0$，在具有恒定热扩散率 $\\alpha>0$ 的均匀、各向同性介质中的二维瞬态热传导。关于标量场 $u(x,y,t)$ 的控制方程为\n$$\n\\frac{\\partial u}{\\partial t}=\\alpha\\left(\\frac{\\partial^{2}u}{\\partial x^{2}}+\\frac{\\partial^{2}u}{\\partial y^{2}}\\right)+S(x,y,t),\n$$\n其中 $S(x,y,t)$ 是一个体积源项。\n\n使用制造解方法（MMS），令制造解为\n$$\nu(x,y,t)=\\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^{2}\\alpha t).\n$$\n\n以能量守恒和傅里叶定律为基础，推导相应的制造源项 $S(x,y,t)$，该源项使得 $u(x,y,t)$ 成为控制方程的精确解。然后，指定与制造解严格一致且适用于在 $\\partial\\Omega$ 所有边界上使用狄利克雷（Dirichlet）数据进行代码验证的边界条件和初始条件。\n\n答案规格：\n- 以一个行向量的形式提供最终答案，该向量包含三个条目，顺序如下：$S(x,y,t)$ 的解析表达式、初始条件 $u(x,y,0)$ 以及施加在 $\\partial\\Omega$ 上的狄利克雷边值 $g(x,y,t)$。\n- 答案仅用 $x$、$y$、$t$、$\\alpha$ 和 $\\pi$ 表示。\n- 无需进行数值计算或四舍五入，最终答案中也无需报告物理单位。\n\n### 步骤1：提取已知信息\n- **控制方程**：$\\frac{\\partial u}{\\partial t}=\\alpha\\left(\\frac{\\partial^{2}u}{\\partial x^{2}}+\\frac{\\partial^{2}u}{\\partial y^{2}}\\right)+S(x,y,t)$\n- **制造解**：$u(x,y,t)=\\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^{2}\\alpha t)$\n- **域**：$\\Omega=(0,1)\\times(0,1)$，对于 $t>0$\n- **参数**：热扩散率 $\\alpha>0$（恒定）\n- **介质**：均匀、各向同性\n- **任务**：\n  1. 推导源项 $S(x,y,t)$。\n  2. 指定初始条件 $u(x,y,0)$。\n  3. 指定 $\\partial\\Omega$ 上的狄利克雷边界条件 $g(x,y,t)$。\n- **答案格式**：一个包含 $[S(x,y,t), u(x,y,0), g(x,y,t)]$ 的行向量。\n\n### 步骤2：使用提取的已知信息进行验证\n- **科学依据**：该问题基于热传导方程，这是一条基本的物理定律。制造解方法（MMS）是计算科学与工程中用于软件验证的一种标准而严谨的技术。该设定具有科学合理性。\n- **适定性**：问题陈述清晰。它要求推导一个源项以及相应的边界/初始条件，以强制一个选定的函数成为偏微分方程的精确解。这是一个直接、明确的数学过程，会导出一个唯一的解。该问题是适定的。\n- **客观性**：该问题使用精确的数学表达式和术语定义，没有任何主观或模棱两可的语言。\n- **结论**：该问题是自洽的、有科学依据的且适定的。它没有违反任何无效标准。\n\n### 步骤3：判断与行动\n该问题有效。将提供一个完整的解答。\n\n制造解方法（MMS）要求将选定的制造解代入控制偏微分方程（PDE），以确定使该方程成立所必需的源项 $S(x,y,t)$。我们首先重新整理控制方程来求解 $S(x,y,t)$：\n$$\nS(x,y,t) = \\frac{\\partial u}{\\partial t} - \\alpha \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n$$\n给定的制造解为 $u(x,y,t) = \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)$。我们现在必须计算 $u(x,y,t)$ 所需的偏导数。\n\n首先，是关于时间 $t$ 的偏导数：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial t} \\left[ \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right]\n$$\n$$\n\\frac{\\partial u}{\\partial t} = \\sin(\\pi x)\\sin(\\pi y) \\cdot \\left( -2\\pi^2\\alpha \\right) \\exp(-2\\pi^2\\alpha t)\n$$\n$$\n\\frac{\\partial u}{\\partial t} = -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t)\n$$\n\n接下来，是关于空间坐标 $x$ 和 $y$ 的二阶偏导数。对于 $x$：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = \\pi \\cos(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left[ \\pi \\cos(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n\n同理，对于 $y$：\n$$\n\\frac{\\partial u}{\\partial y} = \\frac{\\partial}{\\partial y} \\left[ \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = \\pi \\sin(\\pi x)\\cos(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2} = \\frac{\\partial}{\\partial y} \\left[ \\pi \\sin(\\pi x)\\cos(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n\n现在，我们将这些导数代入 $S(x,y,t)$ 的表达式中：\n$$\nS(x,y,t) = \\left( -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t) \\right) - \\alpha \\left[ \\left( -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right) + \\left( -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right) \\right]\n$$\n$$\nS(x,y,t) = -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t) - \\alpha \\left[ -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right]\n$$\n$$\nS(x,y,t) = -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t) + 2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n$$\nS(x,y,t) = 0\n$$\n源项为零。这表明制造解是齐次热传导方程的一个解。\n\n接下来，我们通过计算制造解在 $t=0$ 时的值来指定初始条件 $u(x,y,0)$：\n$$\nu(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha \\cdot 0) = \\sin(\\pi x)\\sin(\\pi y)\\exp(0)\n$$\n$$\nu(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)\n$$\n\n最后，我们通过计算制造解在单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 边界 $\\partial\\Omega$ 上的值来指定狄利克雷边界条件 $g(x,y,t)$。边界由四条线段组成：$x=0$、$x=1$、$y=0$ 和 $y=1$。\n- 在 $x=0$ ($0 \\le y \\le 1$) 上：$g(0,y,t) = \\sin(0)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) = 0$。\n- 在 $x=1$ ($0 \\le y \\le 1$) 上：$g(1,y,t) = \\sin(\\pi)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) = 0$。\n- 在 $y=0$ ($0 \\le x \\le 1$) 上：$g(x,0,t) = \\sin(\\pi x)\\sin(0)\\exp(-2\\pi^2\\alpha t) = 0$。\n- 在 $y=1$ ($0 \\le x \\le 1$) 上：$g(x,1,t) = \\sin(\\pi x)\\sin(\\pi)\\exp(-2\\pi^2\\alpha t) = 0$。\n\n由于对于所有时间 $t>0$，制造解在边界的所有部分上都为零，因此一致的狄利克雷边界条件是一个常数零。\n$$\ng(x,y,t) = 0 \\quad \\text{对于 } (x,y) \\in \\partial\\Omega, t > 0\n$$\n\n所需的三个分量是：\n1. 源项：$S(x,y,t) = 0$。\n2. 初始条件：$u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$。\n3. 狄利克雷边界条件：$g(x,y,t) = 0$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\sin(\\pi x)\\sin(\\pi y) & 0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在代码验证（Verification）之后，我们必须进入验证（Validation）和不确定性量化（Uncertainty Quantification, UQ）的领域，评估模型输入参数的不确定性如何影响输出结果的可靠性。一阶可靠性方法（First-Order Reliability Method, FORM）是一种高效的概率分析技术，用于计算系统在不确定性输入下超出安全极限的概率。这项实践将引导你应用FORM来评估核燃料棒的温度安全性，将数值模拟与工程可靠性评估联系起来。",
            "id": "4260213",
            "problem": "您的任务是实施一阶可靠性方法（FORM），以计算在稳态条件下，核燃料棒中与燃料中心线温度相关的极限状态的可靠性指标 $\\beta$ 及相应的失效概率。背景是核反应堆模拟中的验证与确认（V&V）方法学，您的实现必须具有通用性，从基本定律和标准概率定义出发，而不依赖于简化公式。极限状态定义为超过指定的材料温度极限。物理模型基于稳态热传导，考虑一个具有均匀体积热生成率并在表面进行对流冷却的实心圆柱体。\n\n使用以下具有物理依据的模型计算燃料中心线温度。对于一个半径为 $R$、具有均匀体积热生成率 $\\dot{q}^{\\prime\\prime\\prime}$、热导率为 $k$、并由传热系数 $h$ 表征与温度为 $T_{\\mathrm{c}}$ 的冷却剂进行对流冷却的实心圆柱形燃料棒，其中心线温度为\n$$\nT_{\\mathrm{center}} = T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right).\n$$\n该公式由柱坐标系下的稳态热方程推导而来，其中包含均匀热生成项和边界条件 $-k \\left.\\frac{\\partial T}{\\partial r}\\right|_{r=R} = h (T(R) - T_{\\mathrm{c}})$，该边界条件将表面热通量与对流传热相等同。安全极限是一个固定的燃料温度极限 $T_{\\mathrm{limit}}$，极限状态函数为\n$$\ng(\\mathbf{X}) = T_{\\mathrm{limit}} - T_{\\mathrm{center}}(\\mathbf{X}),\n$$\n其中 $\\mathbf{X} = [T_{\\mathrm{c}}, \\dot{q}^{\\prime\\prime\\prime}, h, k, R]$。当 $g(\\mathbf{X}) \\le 0$ 时，发生失效。\n\n您必须使用一阶可靠性方法（FORM）计算可靠性指标 $\\beta$。定义标准正态空间变量 $\\mathbf{u} = [u_1, u_2, u_3, u_4, u_5]$，它们是相互独立且服从标准正态分布的。对独立输入变量使用等概率变换：\n- 对于一个正态变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，使用 $x(u) = \\mu + \\sigma u$ 以及雅可比分量 $\\frac{\\partial x}{\\partial u} = \\sigma$。\n- 对于一个对数正態变量 $X \\sim \\mathrm{Lognormal}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$，其底层正态分布为 $Y=\\ln X \\sim \\mathcal{N}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$，通过物理均值 $m$ 和变异系数 $c_v$ 进行参数化，即 $\\sigma_{\\ln} = \\sqrt{\\ln(1 + c_v^2)}$ 和 $\\mu_{\\ln} = \\ln(m) - \\frac{1}{2}\\sigma_{\\ln}^2$，然后使用 $x(u) = \\exp(\\mu_{\\ln} + \\sigma_{\\ln} u)$ 以及雅可比分量 $\\frac{\\partial x}{\\partial u} = \\sigma_{\\ln} x$。\n\n使用上述燃料温度模型，从第一性原理出发，计算极限状态函数在物理空间中的梯度 $\\nabla_{\\mathbf{X}} g(\\mathbf{X})$。通过变换的雅可比矩阵将此梯度映射到标准正态空间，以获得 $\\nabla_{\\mathbf{u}} g(\\mathbf{u})$。实施 Hasofer-Lind-Rackwitz-Fiessler (HL-RF) 迭代算法，通过对极限状态函数进行线性化来更新 $\\mathbf{u}$：\n$$\n\\mathbf{u}_{k+1} = -\\lambda_k \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k), \\quad \\text{其中} \\quad \\lambda_k = \\frac{g(\\mathbf{u}_k) - \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)^{\\top} \\mathbf{u}_k}{\\left\\|\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\\right\\|^2}.\n$$\n使用 $\\mathbf{u}_0 = [0,0,0,0,0]$进行初始化。迭代直至达到收敛，例如当 $\\left\\|\\mathbf{u}_{k+1} - \\mathbf{u}_k\\right\\|  \\varepsilon$（其中 $\\varepsilon$ 是一个很小的容差，如 $\\varepsilon = 10^{-8}$）时，或达到最大迭代次数。收敛时，按如下方式计算可靠性指标\n$$\n\\beta = \\left\\|\\mathbf{u}^*\\right\\|,\n$$\n其中 $\\mathbf{u}^*$ 是在标准正态空间中收敛的设计点。使用标准正态累积分布函数 $\\Phi(\\cdot)$ 将可靠性指标转换为失效概率\n$$\np_{\\mathrm{f}} = \\Phi(-\\beta),\n$$\n并以小数形式报告 $p_{\\mathrm{f}}$。\n\n必须遵守所有物理和数值单位：\n- $T_{\\mathrm{limit}}$ 和 $T_{\\mathrm{c}}$ 的单位为 $\\mathrm{K}$ (开尔文)。\n- $\\dot{q}^{\\prime\\prime\\prime}$ 的单位为 $\\mathrm{W}/\\mathrm{m}^3$。\n- $h$ 的单位为 $\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$。\n- $k$ 的单位为 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$。\n- $R$ 的单位为 $\\mathrm{m}$ (米)。\n输出 $\\beta$ 和 $p_{\\mathrm{f}}$ 是无量纲的；请将 $p_{\\mathrm{f}}$ 表示为小数。\n\n以通用、可重用的方式实现您的解决方案，该方案需遵循上述原则，并能适用于以下测试套件。该套件包含一个典型的安全工况、一个近边界工况和一个高风险工况。所有变量都是相互独立的。\n\n在所有案例中均使用 $T_{\\mathrm{limit}} = 1800\\,\\mathrm{K}$。\n\n测试案例1（典型安全运行工况）：\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\mu = 580\\,\\mathrm{K}, \\sigma = 15\\,\\mathrm{K})$。\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$，均值 $m = 1.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$，变异系数 $c_v = 0.10$。\n- $h \\sim \\mathrm{Lognormal}$，均值 $m = 20000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$，$c_v = 0.15$。\n- $k \\sim \\mathrm{Lognormal}$，均值 $m = 2.5\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$c_v = 0.20$。\n- $R \\sim \\mathrm{Lognormal}$，均值 $m = 0.004\\,\\mathrm{m}$，$c_v = 0.01$。\n\n测试案例2（近边界工况）：\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\mu = 650\\,\\mathrm{K}, \\sigma = 20\\,\\mathrm{K})$。\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$，均值 $m = 3.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$，变异系数 $c_v = 0.10$。\n- $h \\sim \\mathrm{Lognormal}$，均值 $m = 5000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$，$c_v = 0.20$。\n- $k \\sim \\mathrm{Lognormal}$，均值 $m = 1.5\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$c_v = 0.25$。\n- $R \\sim \\mathrm{Lognormal}$，均值 $m = 0.0045\\,\\mathrm{m}$，$c_v = 0.02$。\n\n测试案例3（高风险工况）：\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\mu = 700\\,\\mathrm{K}, \\sigma = 30\\,\\mathrm{K})$。\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$，均值 $m = 4.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$，变异系数 $c_v = 0.15$。\n- $h \\sim \\mathrm{Lognormal}$，均值 $m = 3000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$，$c_v = 0.25$。\n- $k \\sim \\mathrm{Lognormal}$，均值 $m = 1.0\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$c_v = 0.30$。\n- $R \\sim \\mathrm{Lognormal}$，均值 $m = 0.0050\\,\\mathrm{m}$，$c_v = 0.03$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，顺序为 $[\\beta_1, p_{\\mathrm{f},1}, \\beta_2, p_{\\mathrm{f},2}, \\beta_3, p_{\\mathrm{f},3}]$，其中下标表示测试案例索引。每个条目必须是浮点数。",
            "solution": "此问题经评估为有效。这是一个适定的、具有科学依据的问题，涉及可靠性分析在核工程热工水力学中的应用。其物理模型、数学公式和数值算法都是标准的且定义清晰。所有必要的数据均已提供。\n\n目标是计算核燃料棒中心线温度超过安全极限的可靠性指标 $\\beta$ 和失效概率 $p_{\\mathrm{f}}$。这通过实施一阶可靠性方法（FORM）以及 Hasofer-Lind-Rackwitz-Fiessler (HL-RF) 迭代算法来实现。\n\n问题的核心在于将随机物理变量转换到标准正态空间，并在此空间中找到失效面上距离原点最近的点。该点到原点的距离即为可靠性指标 $\\beta$。\n\n**1. 极限状态函数与物理变量**\n\n物理空间中独立随机变量的向量为 $\\mathbf{X} = [x_1, x_2, x_3, x_4, x_5]^{\\top} = [T_{\\mathrm{c}}, \\dot{q}^{\\prime\\prime\\prime}, h, k, R]^{\\top}$。燃料中心线温度由下式给出：\n$$\nT_{\\mathrm{center}}(\\mathbf{X}) = T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right)\n$$\n安全极限是一个恒定温度 $T_{\\mathrm{limit}}$。极限状态函数 $g(\\mathbf{X})$ 定义了安全状态与失效状态之间的边界。失效被定义为中心线温度超过极限的条件，对应于 $g(\\mathbf{X}) \\le 0$。\n$$\ng(\\mathbf{X}) = T_{\\mathrm{limit}} - T_{\\mathrm{center}}(\\mathbf{X}) = T_{\\mathrm{limit}} - \\left[ T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right) \\right]\n$$\n\n**2. 物理空间中的梯度**\n\nHL-RF 算法需要极限状态函数的梯度。我们首先计算此函数相对于物理变量的梯度 $\\nabla_{\\mathbf{X}} g(\\mathbf{X})$。其偏导数如下：\n- $\\frac{\\partial g}{\\partial T_{\\mathrm{c}}} = -1$\n- $\\frac{\\partial g}{\\partial \\dot{q}^{\\prime\\prime\\prime}} = -\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right)$\n- $\\frac{\\partial g}{\\partial h} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial h}\\left(\\frac{R}{2h}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(-\\frac{R}{2h^2}\\right) = \\frac{\\dot{q}^{\\prime\\prime\\prime} R}{2h^2}$\n- $\\frac{\\partial g}{\\partial k} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial k}\\left(\\frac{R^2}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(-\\frac{R^2}{4k^2}\\right) = \\frac{\\dot{q}^{\\prime\\prime\\prime} R^2}{4k^2}$\n- $\\frac{\\partial g}{\\partial R} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial R}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{1}{2h} + \\frac{2R}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{1}{2h} + \\frac{R}{2k}\\right)$\n\n**3. 等概率变换与雅可比**\n\n物理变量 $\\mathbf{X}$ 被转换为一个由独立标准正态变量组成的向量 $\\mathbf{u} = [u_1, u_2, u_3, u_4, u_5]^{\\top}$。变换 $x_i(u_i)$ 及其导数 $\\frac{\\partial x_i}{\\partial u_i}$ 取决于 $x_i$ 的概率分布。\n\n- 对于一个正态分布的变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$:\n  $$x(u) = \\mu + \\sigma u$$\n  $$\\frac{\\partial x}{\\partial u} = \\sigma$$\n\n- 对于一个对数正态分布的变量 $X \\sim \\mathrm{Lognormal}$，其均值为 $m$，变异系数为 $c_v$:\n  其底层正态分布 $Y = \\ln X \\sim \\mathcal{N}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$ 的参数首先被计算出来：\n  $$\\sigma_{\\ln}^2 = \\ln(1 + c_v^2)$$\n  $$\\mu_{\\ln} = \\ln(m) - \\frac{1}{2}\\sigma_{\\ln}^2$$\n  变换及其导数为：\n  $$x(u) = \\exp(\\mu_{\\ln} + \\sigma_{\\ln} u)$$\n  $$\\frac{\\partial x}{\\partial u} = \\frac{d}{du} \\left( e^{\\mu_{\\ln} + \\sigma_{\\ln} u} \\right) = e^{\\mu_{\\ln} + \\sigma_{\\ln} u} \\cdot \\sigma_{\\ln} = \\sigma_{\\ln} x(u)$$\n\n**4. 标准正态空间中的梯度**\n\n标准正态空间中的梯度 $\\nabla_{\\mathbf{u}} g(\\mathbf{u})$ 可通过链式法则求得。由于变换是独立的，雅可比矩阵 $\\mathbf{J}_{\\mathbf{X},\\mathbf{u}}$ 是一个对角矩阵，其对角线元素为 $J_{ii} = \\frac{\\partial x_i}{\\partial u_i}$。\n$$\n\\nabla_{\\mathbf{u}} g(\\mathbf{u}) = \\mathbf{J}_{\\mathbf{X},\\mathbf{u}}^{\\top} \\nabla_{\\mathbf{X}} g(\\mathbf{X}(\\mathbf{u}))\n$$\n因此，梯度的分量为：\n$$\n\\frac{\\partial g}{\\partial u_i} = \\frac{\\partial g}{\\partial x_i} \\frac{\\partial x_i}{\\partial u_i}\n$$\n这些分量必须在当前迭代点 $\\mathbf{u}_k$ 进行计算，方法是首先计算出对应的物理值 $\\mathbf{X}(\\mathbf{u}_k)$。\n\n**5. HL-RF 算法**\n\nHL-RF 算法是一种不动点迭代方案，用于寻找设计点 $\\mathbf{u}^*$，该点是失效面 $g(\\mathbf{u}) = 0$ 上距离原点最近的点。\n\n1.  使用 $\\mathbf{u}_0 = \\mathbf{0}$ 初始化迭代。\n2.  对于迭代 $k=0, 1, 2, \\dots$:\n    a. 计算物理变量 $\\mathbf{X}_k = \\mathbf{X}(\\mathbf{u}_k)$。\n    b. 评估极限状态函数 $g(\\mathbf{u}_k) = g(\\mathbf{X}_k)$。\n    c. 评估物理空间中的梯度 $\\nabla_{\\mathbf{X}} g(\\mathbf{X}_k)$。\n    d. 计算在 $\\mathbf{u}_k$ 处的雅可比分量 $\\frac{\\partial x_i}{\\partial u_i}$。\n    e. 计算标准正态空间中的梯度 $\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)$。\n    f. 计算更新参数 $\\lambda_k$：\n       $$\n       \\lambda_k = \\frac{g(\\mathbf{u}_k) - \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)^{\\top} \\mathbf{u}_k}{\\left\\|\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\\right\\|^2}\n       $$\n    g. 更新标准正态向量 $\\mathbf{u}_{k+1}$：\n       $$\n       \\mathbf{u}_{k+1} = -\\lambda_k \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\n       $$\n3.  检查收敛性。当 $\\left\\|\\mathbf{u}_{k+1} - \\mathbf{u}_k\\right\\|  \\varepsilon$ 时，迭代停止，其中 $\\varepsilon$ 是一个很小的容差（例如 $10^{-8}$）。收敛点即为设计点 $\\mathbf{u}^*$。\n\n**6. 可靠性指标与失效概率**\n\n一旦算法收敛到设计点 $\\mathbf{u}^*$，可靠性指标 $\\beta$ 即为该点的欧几里得范数（到原点的距离）：\n$$\n\\beta = \\left\\|\\mathbf{u}^*\\right\\| = \\sqrt{\\sum_{i=1}^n (u_i^*)^2}\n$$\n然后，使用标准正态累积分布函数 $\\Phi(\\cdot)$ 计算失效概率 $p_{\\mathrm{f}}$ 的一阶近似值：\n$$\np_{\\mathrm{f}} = \\Phi(-\\beta)\n$$\n对所提供的三个测试案例中的每一个都实施此程序。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n#\n# === Probabilistic Variable Definitions ===\n#\nclass NormalVariable:\n    \"\"\"Represents a normally distributed random variable.\"\"\"\n    def __init__(self, mean, std_dev):\n        self.mean = float(mean)\n        self.std_dev = float(std_dev)\n\n    def transform(self, u):\n        \"\"\"Maps a standard normal variable u to the physical variable x.\"\"\"\n        return self.mean + self.std_dev * u\n\n    def jacobian_component(self, u, x):\n        \"\"\"Computes the component of the Jacobian d(x)/d(u).\"\"\"\n        return self.std_dev\n\nclass LognormalVariable:\n    \"\"\"Represents a lognormally distributed random variable.\"\"\"\n    def __init__(self, mean, cv):\n        self.m = float(mean)\n        self.cv = float(cv)\n        \n        # Pre-compute parameters of the underlying normal distribution\n        sigma_ln_sq = np.log(1.0 + self.cv**2)\n        self.sigma_ln = np.sqrt(sigma_ln_sq)\n        self.mu_ln = np.log(self.m) - 0.5 * sigma_ln_sq\n\n    def transform(self, u):\n        \"\"\"Maps a standard normal variable u to the physical variable x.\"\"\"\n        return np.exp(self.mu_ln + self.sigma_ln * u)\n\n    def jacobian_component(self, u, x):\n        \"\"\"Computes the component of the Jacobian d(x)/d(u).\"\"\"\n        return self.sigma_ln * x\n\n#\n# === First-Order Reliability Method (FORM) Solver ===\n#\ndef solve_form(variables, T_limit, epsilon=1e-8, max_iter=100):\n    \"\"\"\n    Computes the reliability index and failure probability using FORM-HLRF.\n    \"\"\"\n    num_vars = len(variables)\n    u = np.zeros(num_vars)\n\n    for i in range(max_iter):\n        u_old = u.copy()\n        \n        # 1. Transform from standard normal space (u) to physical space (x)\n        x = np.array([var.transform(u_i) for var, u_i in zip(variables, u)])\n        Tc, q_dot, h, k, R = x\n        \n        # 2. Evaluate the limit-state function g(u)\n        T_center = Tc + q_dot * (R / (2.0 * h) + R**2 / (4.0 * k))\n        g_val = T_limit - T_center\n        \n        # 3. Evaluate the gradient of g in physical space, grad_x(g)\n        grad_g_x = np.array([\n            -1.0,\n            -(R / (2.0 * h) + R**2 / (4.0 * k)),\n            (q_dot * R) / (2.0 * h**2),\n            (q_dot * R**2) / (4.0 * k**2),\n            -q_dot * (1.0 / (2.0 * h) + R / (2.0 * k))\n        ])\n\n        # 4. Compute the gradient of g in standard normal space, grad_u(g)\n        jac_components = np.array([var.jacobian_component(u_i, x_i) \n                                   for var, u_i, x_i in zip(variables, u, x)])\n        grad_g_u = grad_g_x * jac_components\n        \n        # 5. Apply the HL-RF update rule\n        norm_grad_g_u = np.linalg.norm(grad_g_u)\n        if norm_grad_g_u  1e-12: # Avoid division by zero\n            # If gradient is near zero and g is also near zero, we might have converged.\n            if abs(g_val)  epsilon:\n                break\n            else:\n                # This case is unlikely for this problem but is good practice to handle.\n                # A zero gradient far from the failure surface indicates a problem.\n                raise RuntimeError(\"HL-RF failed: zero gradient encountered.\")\n\n        lambda_k = (g_val - np.dot(grad_g_u, u)) / (norm_grad_g_u**2)\n        u = -lambda_k * grad_g_u\n        \n        # 6. Check for convergence\n        if np.linalg.norm(u - u_old)  epsilon:\n            break\n    \n    # 7. Compute reliability index (beta) and probability of failure (p_f)\n    beta = np.linalg.norm(u)\n    p_f = norm.cdf(-beta)\n    \n    return beta, p_f\n\n#\n# === Main Execution Block ===\n#\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (typical safe operating conditions)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=580.0, std_dev=15.0),\n                LognormalVariable(mean=1.0e8, cv=0.10),\n                LognormalVariable(mean=20000.0, cv=0.15),\n                LognormalVariable(mean=2.5, cv=0.20),\n                LognormalVariable(mean=0.004, cv=0.01)\n            ]\n        },\n        # Test Case 2 (near boundary)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=650.0, std_dev=20.0),\n                LognormalVariable(mean=3.0e8, cv=0.10),\n                LognormalVariable(mean=5000.0, cv=0.20),\n                LognormalVariable(mean=1.5, cv=0.25),\n                LognormalVariable(mean=0.0045, cv=0.02)\n            ]\n        },\n        # Test Case 3 (high risk)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=700.0, std_dev=30.0),\n                LognormalVariable(mean=4.0e8, cv=0.15),\n                LognormalVariable(mean=3000.0, cv=0.25),\n                LognormalVariable(mean=1.0, cv=0.30),\n                LognormalVariable(mean=0.0050, cv=0.03)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, p_f = solve_form(case['variables'], case['T_limit'])\n        results.extend([beta, p_f])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}