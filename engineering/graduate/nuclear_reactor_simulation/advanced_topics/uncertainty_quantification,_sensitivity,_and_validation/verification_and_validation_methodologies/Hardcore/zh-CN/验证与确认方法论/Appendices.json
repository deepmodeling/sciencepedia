{
    "hands_on_practices": [
        {
            "introduction": "在计算流体动力学和传热学中，验证数值解是否收敛于精确解是至关重要的一步。本练习将引导您应用网格收敛指数（GCI）方法，这是一种基于理查德森外推法的标准化技术，用于量化离散化误差。通过对一个典型的一维稳态导热问题进行分析，您将亲手计算GCI值，并深入理解其公式中安全系数$F_s$为结果提供置信区间的关键作用。",
            "id": "4003027",
            "problem": "在一个长度为 $L$、导热系数 $k$ 为常数的均匀平板中，求解一个一维稳态热传导问题，其边界条件为 Dirichlet 边界条件 $T(0)=T_{0}$ 和 $T(L)=T_{L}$。采用二阶中心差分的有限体积法离散来计算 $x=0$ 处的壁面热流密度大小，记为 $\\phi$。使用了三个均匀网格，其控制体积数量分别为 $N_{3}=32$、$N_{2}=64$ 和 $N_{1}=128$，因此均匀加密比满足 $r_{32}=h_{3}/h_{2}=2$ 和 $r_{21}=h_{2}/h_{1}=2$，其中 $h_{j}=L/N_{j}$。在这些网格上计算得到的目标量为\n$\\phi_{3}=1.0160\\times 10^{4}$、$\\phi_{2}=1.0040\\times 10^{4}$ 和 $\\phi_{1}=1.0010\\times 10^{4}$。\n一项独立的三套网格分析确定了该物理量的表观精度阶为 $p_{\\mathrm{obs}}=1.98$。基于离散误差模型和 Richardson 外推法，使用细网格的网格收敛指数（GCI）的经典定义，并采用在渐近范围内进行三套网格验证时推荐的安全系数 $F_{s}=1.25$，利用 $(1,2)$ 网格对和 $p_{\\mathrm{obs}}$ 计算 $\\phi$ 的细网格网格收敛指数 $\\mathrm{GCI}_{21}$。将最终答案四舍五入至四位有效数字，并表示为无量纲小数。在你的解答中，需从离散误差模型出发推导 GCI 公式，并解释安全系数 $F_{s}$ 在 GCI 表达式中的作用（仅作概念性解释；最终答案必须是计算出的数值）。",
            "solution": "**解题推导**\n\n网格收敛指数（GCI）的基础是离散误差的建模。对于一个精度阶为 $p$ 的数值格式，在特征尺寸为 $h$ 的网格上得到的解 $\\phi_h$ 可以通过误差的泰勒级数展开表示为：\n$$\n\\phi_h = \\phi_{\\mathrm{exact}} + c h^p + O(h^{p+1})\n$$\n其中 $\\phi_{\\mathrm{exact}}$ 是连续介质方程的精确（未知）解，$c$ 是一个依赖于解的高阶导数的常数。\n\n假设网格足够密，处于“渐近范围”内，则高阶项 $O(h^{p+1})$ 可以忽略不计，误差由主导项决定：\n$$\n\\phi_h \\approx \\phi_{\\mathrm{exact}} + c h^p\n$$\n\n我们将此模型应用于两套网格：尺寸为 $h_1$ 的细网格（网格1）和尺寸为 $h_2$ 的粗网格（网格2）。网格加密比为 $r_{21} = h_2/h_1$。在这些网格上的解为：\n$$\n\\phi_1 \\approx \\phi_{\\mathrm{exact}} + c h_1^p\n$$\n$$\n\\phi_2 \\approx \\phi_{\\mathrm{exact}} + c h_2^p = \\phi_{\\mathrm{exact}} + c (r_{21} h_1)^p\n$$\n这构成了关于未知数 $\\phi_{\\mathrm{exact}}$ 和 $c$ 的一个二元代数方程组。我们可以消去 $c$ 来求解 $\\phi_{\\mathrm{exact}}$ 的一个更精确的估计值，该值被称为 Richardson 外推解 $\\phi_{\\mathrm{extrap}}^{21}$：\n$$\n\\phi_{\\mathrm{extrap}}^{21} = \\frac{r_{21}^p \\phi_1 - \\phi_2}{r_{21}^p - 1} = \\phi_1 + \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1}\n$$\n细网格解的估计误差 $E_a^{21}$ 是细网格解与此外推值之差：\n$$\nE_a^{21} = \\phi_{\\mathrm{extrap}}^{21} - \\phi_1 = \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1}\n$$\nGCI 被定义为细网格解不确定度的一种度量。它基于估计误差的大小，并按安全系数 $F_s$ 进行缩放，通常表示为相对于细网格解本身的相对量。\n$$\n\\mathrm{GCI}_{21} = F_s \\frac{|E_a^{21}|}{|\\phi_1|} = F_s \\frac{1}{|\\phi_1|} \\left| \\frac{\\phi_1 - \\phi_2}{r_{21}^p - 1} \\right|\n$$\n由于 $r_{21} = 2 > 1$ 且 $p_{\\mathrm{obs}} = 1.98 > 0$，项 $r_{21}^p - 1$ 为正。该公式可以写为：\n$$\n\\mathrm{GCI}_{21} = \\frac{F_s}{r_{21}^p - 1} \\left| \\frac{\\phi_1 - \\phi_2}{\\phi_1} \\right|\n$$\n\n安全系数 $F_s$ 用于创建一个保守的误差带。其值反映了对外推法所基于的假设的置信度。Richardson 外推法假设数值解处于渐近范围内，但这可能不完全成立。$F_s > 1$（例如，对于具有良态收敛阶的三套网格研究，$F_s=1.25$）会放大估计误差，从而创建一个不确定度区间 $\\phi_1 \\pm (\\mathrm{GCI}_{21} \\cdot \\phi_1)$，该区间很可能（例如，以 95% 的置信度）包含精确解 $\\phi_{\\mathrm{exact}}$。\n\n**计算**\n\n我们现在将给定值代入推导出的 $\\mathrm{GCI}_{21}$ 公式中。\n已知条件如下：\n- 细网格解：$\\phi_1 = 1.0010 \\times 10^4$\n- 粗网格解：$\\phi_2 = 1.0040 \\times 10^4$\n- 加密比：$r_{21} = 2$\n- 观测到的精度阶：$p = p_{\\mathrm{obs}} = 1.98$\n- 安全系数：$F_s = 1.25$\n\n首先，我们计算两个解之间的相对差异：\n$$\n\\left| \\frac{\\phi_1 - \\phi_2}{\\phi_1} \\right| = \\left| \\frac{1.0010 \\times 10^4 - 1.0040 \\times 10^4}{1.0010 \\times 10^4} \\right| = \\left| \\frac{-0.0030 \\times 10^4}{1.0010 \\times 10^4} \\right| = \\frac{0.0030}{1.0010} = \\frac{3}{1001}\n$$\n接下来，我们计算包含精度阶的分母项：\n$$\nr_{21}^p - 1 = 2^{1.98} - 1\n$$\n现在，将这些代入 GCI 公式：\n$$\n\\mathrm{GCI}_{21} = \\frac{1.25}{2^{1.98} - 1} \\times \\frac{3}{1001}\n$$\n我们计算其数值：\n$$\n2^{1.98} \\approx 3.944835\n$$\n$$\nr_{21}^p - 1 \\approx 2.944835\n$$\n$$\n\\frac{3}{1001} \\approx 0.002997003\n$$\n$$\n\\mathrm{GCI}_{21} \\approx \\frac{1.25}{2.944835} \\times 0.002997003 \\approx (0.424469) \\times (0.002997003) \\approx 0.00127214\n$$\n题目要求将最终答案四舍五入至四位有效数字。前四位有效数字是 $1$、$2$、$7$ 和 $2$。第五位数字是 $1$，因此我们向下舍入。\n$$\n\\mathrm{GCI}_{21} \\approx 0.001272\n$$\n这个值表示细网格解 $\\phi_1$ 的估计不确定度约为 $0.1272\\%$。",
            "answer": "$$\n\\boxed{0.001272}\n$$"
        },
        {
            "introduction": "验证一个复杂的仿真代码是否正确无误地求解了其预设的控制方程，是软件开发中的一个核心挑战。制造解方法（MMS）为此提供了一个强大而严谨的框架。在此实践中，您将通过一个二维瞬态热传导问题，体验MMS的核心思想：首先“制造”一个解析解，然后反向推导出必须施加到控制方程中的源项以及相应的边界和初始条件，从而为代码的精确性验证创建一个无懈可击的基准。",
            "id": "4003053",
            "problem": "一个计算传热学代码将使用人造解方法 (MMS) 进行验证。考虑在单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 上，对于时间 $t>0$，在具有恒定热扩散系数 $\\alpha>0$ 的均匀、各向同性介质中的二维瞬态热传导。以标量场 $u(x,y,t)$ 表示的控制方程为\n$$\n\\frac{\\partial u}{\\partial t}=\\alpha\\left(\\frac{\\partial^{2}u}{\\partial x^{2}}+\\frac{\\partial^{2}u}{\\partial y^{2}}\\right)+S(x,y,t),\n$$\n其中 $S(x,y,t)$ 是一个体积源项。\n\n使用人造解方法 (MMS)，让人造解为\n$$\nu(x,y,t)=\\sin(\\pi x)\\sin(\\pi y)\\exp\\!\\big(-2\\pi^{2}\\alpha t\\big).\n$$\n\n以能量守恒和傅里叶定律为基本基础，推导相应的制造源项 $S(x,y,t)$，使 $u(x,y,t)$ 成为控制方程的精确解。然后，指定与人造解严格一致且适用于在 $\\partial\\Omega$ 的所有边界上使用狄利克雷数据进行代码验证的边界和初始条件。\n\n答案规格：\n- 以行向量的形式提供您的最终答案，包含三个条目，顺序如下：$S(x,y,t)$ 的解析表达式、初始条件 $u(x,y,0)$ 以及施加在 $\\partial\\Omega$ 上的狄利克雷边界值 $g(x,y,t)$。\n- 答案仅用 $x$、$y$、$t$、$\\alpha$ 和 $\\pi$ 表示。\n- 无需进行数值计算或四舍五入，最终答案中也无需报告物理单位。",
            "solution": "人造解方法 (MMS) 要求将选定的人造解代入控制偏微分方程 (PDE)，以确定使该方程成立所必需的源项 $S(x,y,t)$。我们首先重新整理控制方程来求解 $S(x,y,t)$：\n$$\nS(x,y,t) = \\frac{\\partial u}{\\partial t} - \\alpha \\left( \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} \\right)\n$$\n人造解给定为 $u(x,y,t) = \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)$。我们现在必须计算 $u(x,y,t)$ 所需的偏导数。\n\n首先，是关于时间 $t$ 的偏导数：\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial t} \\left[ \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right]\n$$\n$$\n\\frac{\\partial u}{\\partial t} = \\sin(\\pi x)\\sin(\\pi y) \\cdot \\left( -2\\pi^2\\alpha \\right) \\exp(-2\\pi^2\\alpha t)\n$$\n$$\n\\frac{\\partial u}{\\partial t} = -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t)\n$$\n\n接下来，是关于空间坐标 $x$ 和 $y$ 的二阶偏导数。对于 $x$：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left[ \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = \\pi \\cos(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left[ \\pi \\cos(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n\n同理，对于 $y$：\n$$\n\\frac{\\partial u}{\\partial y} = \\frac{\\partial}{\\partial y} \\left[ \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = \\pi \\sin(\\pi x)\\cos(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2} = \\frac{\\partial}{\\partial y} \\left[ \\pi \\sin(\\pi x)\\cos(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right] = -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n\n现在，我们将这些导数代入 $S(x,y,t)$ 的表达式中：\n$$\nS(x,y,t) = \\left( -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t) \\right) - \\alpha \\left[ \\left( -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right) + \\left( -\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right) \\right]\n$$\n$$\nS(x,y,t) = -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t) - \\alpha \\left[ -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) \\right]\n$$\n$$\nS(x,y,t) = -2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y) \\exp(-2\\pi^2\\alpha t) + 2\\pi^2\\alpha \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t)\n$$\n$$\nS(x,y,t) = 0\n$$\n源项为零。这表明人造解是齐次热方程的一个解。\n\n接下来，我们通过在 $t=0$ 时计算人造解来指定初始条件 $u(x,y,0)$：\n$$\nu(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha \\cdot 0) = \\sin(\\pi x)\\sin(\\pi y)\\exp(0)\n$$\n$$\nu(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)\n$$\n\n最后，我们通过在单位正方形域 $\\Omega=(0,1)\\times(0,1)$ 的边界 $\\partial\\Omega$ 上计算人造解来指定狄利克雷边界条件 $g(x,y,t)$。该边界由四个部分组成：$x=0$、$x=1$、$y=0$ 和 $y=1$。\n- 在 $x=0$ ($0 \\le y \\le 1$) 上：$g(0,y,t) = \\sin(0)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) = 0$。\n- 在 $x=1$ ($0 \\le y \\le 1$) 上：$g(1,y,t) = \\sin(\\pi)\\sin(\\pi y)\\exp(-2\\pi^2\\alpha t) = 0$。\n- 在 $y=0$ ($0 \\le x \\le 1$) 上：$g(x,0,t) = \\sin(\\pi x)\\sin(0)\\exp(-2\\pi^2\\alpha t) = 0$。\n- 在 $y=1$ ($0 \\le x \\le 1$) 上：$g(x,1,t) = \\sin(\\pi x)\\sin(\\pi)\\exp(-2\\pi^2\\alpha t) = 0$。\n\n由于在所有时间 $t>0$ 内，人造解在边界的所有部分都为零，因此一致的狄利克雷边界条件是一个常数零。\n$$\ng(x,y,t) = 0 \\quad \\text{对于 } (x,y) \\in \\partial\\Omega, t > 0\n$$\n\n所需的三个分量是：\n1. 源项：$S(x,y,t) = 0$。\n2. 初始条件：$u(x,y,0) = \\sin(\\pi x)\\sin(\\pi y)$。\n3. 狄利克雷边界条件：$g(x,y,t) = 0$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0 & \\sin(\\pi x)\\sin(\\pi y) & 0 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "超越了代码验证的范畴，我们必须面对现实世界中模型输入参数固有的不确定性，并量化其对系统安全的影响。一阶可靠性方法（FORM）是评估结构或系统失效概率的经典工程技术。本练习将指导您从基本物理模型出发，为一个核燃料棒的温度超限问题实现Hasofer-Lind-Rackwitz-Fiessler（HL-RF）迭代算法，从而计算可靠性指标 $\\beta$ 和相应的失效概率，深刻理解不确定性量化在安全关键系统评估中的应用。",
            "id": "4260213",
            "problem": "您的任务是实现一阶可靠性方法（FORM），以计算与稳态条件下核燃料棒中心线温度相关的极限状态的可靠性指标 $\\beta$ 及相应的失效概率。上下文是核反应堆模拟中的验证与确认（V&V）方法论，您的实现必须具有通用性，从基本定律和标准概率定义出发，不依赖于简化公式。极限状态定义为超过指定的材料温度极限。物理模型基于稳态热传导，在一个表面有对流冷却的实心圆柱体中，具有均匀的体积热生成。\n\n使用以下具有物理依据的模型来计算燃料中心线温度。对于一个半径为 $R$、具有均匀体积热生成率 $\\dot{q}^{\\prime\\prime\\prime}$、热导率为 $k$、并向温度为 $T_{\\mathrm{c}}$ 的冷却剂进行对流冷却（其特征为传热系数 $h$）的实心圆柱形燃料棒，其中心线温度为\n$$\nT_{\\mathrm{center}} = T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right).\n$$\n这源于在均匀生成和边界条件 $-k \\left.\\frac{\\partial T}{\\partial r}\\right|_{r=R} = h (T(R) - T_{\\mathrm{c}})$ 下的柱坐标系稳态热方程，该边界条件将表面热通量与对流传热相等同。安全极限是固定的燃料温度极限 $T_{\\mathrm{limit}}$，极限状态函数为\n$$\ng(\\mathbf{X}) = T_{\\mathrm{limit}} - T_{\\mathrm{center}}(\\mathbf{X}),\n$$\n其中 $\\mathbf{X} = [T_{\\mathrm{c}}, \\dot{q}^{\\prime\\prime\\prime}, h, k, R]$。当 $g(\\mathbf{X}) \\le 0$ 时，发生失效。\n\n您必须使用一阶可靠性方法（FORM）计算可靠性指标 $\\beta$。定义标准正态空间变量 $\\mathbf{u} = [u_1, u_2, u_3, u_4, u_5]$，这些变量是独立且服从标准正态分布的。对独立输入变量使用等概率变换：\n- 对于正态变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$，使用 $x(u) = \\mu + \\sigma u$ 和雅可比分量 $\\frac{\\partial x}{\\partial u} = \\sigma$。\n- 对于对数正态变量 $X \\sim \\mathrm{Lognormal}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$，其底层正态分布为 $Y=\\ln X \\sim \\mathcal{N}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$，通过物理平均值 $m$ 和变异系数 $c_v$ 来参数化 $\\mu_{\\ln}$ 和 $\\sigma_{\\ln}$：$\\sigma_{\\ln} = \\sqrt{\\ln(1 + c_v^2)}$ 和 $\\mu_{\\ln} = \\ln(m) - \\frac{1}{2}\\sigma_{\\ln}^2$，然后使用 $x(u) = \\exp(\\mu_{\\ln} + \\sigma_{\\ln} u)$ 和雅可比分量 $\\frac{\\partial x}{\\partial u} = \\sigma_{\\ln} x$。\n\n从第一性原理出发，使用上述燃料温度模型计算极限状态函数在物理空间中的梯度 $\\nabla_{\\mathbf{X}} g(\\mathbf{X})$。通过变换的雅可比矩阵将此梯度映射到标准正态空间，以获得 $\\nabla_{\\mathbf{u}} g(\\mathbf{u})$。实现 Hasofer-Lind-Rackwitz-Fiessler (HL-RF) 迭代算法，通过线性化极限状态函数来更新 $\\mathbf{u}$：\n$$\n\\mathbf{u}_{k+1} = -\\lambda_k \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k), \\quad \\text{其中} \\quad \\lambda_k = \\frac{g(\\mathbf{u}_k) - \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)^{\\top} \\mathbf{u}_k}{\\left\\|\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\\right\\|^2}。\n$$\n使用 $\\mathbf{u}_0 = [0,0,0,0,0]$ 进行初始化。迭代直至达到收敛，例如当 $\\left\\|\\mathbf{u}_{k+1} - \\mathbf{u}_k\\right\\|  \\varepsilon$（其中 $\\varepsilon$ 是一个小的容差，如 $\\varepsilon = 10^{-8}$）或达到最大迭代次数时。收敛后，将可靠性指标计算为\n$$\n\\beta = \\left\\|\\mathbf{u}^*\\right\\|,\n$$\n其中 $\\mathbf{u}^*$ 是标准正态空间中的收敛设计点。使用标准正态累积分布函数 $\\Phi(\\cdot)$ 将可靠性指标转换为失效概率\n$$\np_{\\mathrm{f}} = \\Phi(-\\beta),\n$$\n并以小数形式报告 $p_{\\mathrm{f}}$。\n\n所有物理和数值单位都必须遵守：\n- $T_{\\mathrm{limit}}$ 和 $T_{\\mathrm{c}}$ 单位为 $\\mathrm{K}$ (开尔文)。\n- $\\dot{q}^{\\prime\\prime\\prime}$ 单位为 $\\mathrm{W}/\\mathrm{m}^3$。\n- $h$ 单位为 $\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$。\n- $k$ 单位为 $\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$。\n- $R$ 单位为 $\\mathrm{m}$ (米)。\n输出 $\\beta$ 和 $p_{\\mathrm{f}}$ 是无量纲的；请以小数形式表示 $p_{\\mathrm{f}}$。\n\n以通用、可重用的方式实现您的解决方案，使其遵循上述原则，并能适用于以下测试套件，该套件涵盖一个典型的安全案例、一个近边界案例和一个高风险案例。所有变量都是独立的。\n\n在所有情况下均使用 $T_{\\mathrm{limit}} = 1800\\,\\mathrm{K}$。\n\n测试案例 1（典型安全运行条件）：\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\text{均值} = 580\\,\\mathrm{K}, \\sigma = 15\\,\\mathrm{K})$。\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$，均值 $m = 1.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$，变异系数 $c_v = 0.10$。\n- $h \\sim \\mathrm{Lognormal}$，均值 $m = 20000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$，$c_v = 0.15$。\n- $k \\sim \\mathrm{Lognormal}$，均值 $m = 2.5\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$c_v = 0.20$。\n- $R \\sim \\mathrm{Lognormal}$，均值 $m = 0.004\\,\\mathrm{m}$，$c_v = 0.01$。\n\n测试案例 2（近边界）：\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\text{均值} = 650\\,\\mathrm{K}, \\sigma = 20\\,\\mathrm{K})$。\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$，均值 $m = 3.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$，$c_v = 0.10$。\n- $h \\sim \\mathrm{Lognormal}$，均值 $m = 5000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$，$c_v = 0.20$。\n- $k \\sim \\mathrm{Lognormal}$，均值 $m = 1.5\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$c_v = 0.25$。\n- $R \\sim \\mathrm{Lognormal}$，均值 $m = 0.0045\\,\\mathrm{m}$，$c_v = 0.02$。\n\n测试案例 3（高风险）：\n- $T_{\\mathrm{c}} \\sim \\mathcal{N}(\\text{均值} = 700\\,\\mathrm{K}, \\sigma = 30\\,\\mathrm{K})$。\n- $\\dot{q}^{\\prime\\prime\\prime} \\sim \\mathrm{Lognormal}$，均值 $m = 4.0\\times 10^8\\,\\mathrm{W}/\\mathrm{m}^3$，$c_v = 0.15$。\n- $h \\sim \\mathrm{Lognormal}$，均值 $m = 3000\\,\\mathrm{W}/(\\mathrm{m}^2\\cdot\\mathrm{K})$，$c_v = 0.25$。\n- $k \\sim \\mathrm{Lognormal}$，均值 $m = 1.0\\,\\mathrm{W}/(\\mathrm{m}\\cdot\\mathrm{K})$，$c_v = 0.30$。\n- $R \\sim \\mathrm{Lognormal}$，均值 $m = 0.0050\\,\\mathrm{m}$，$c_v = 0.03$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\beta_1, p_{\\mathrm{f},1}, \\beta_2, p_{\\mathrm{f},2}, \\beta_3, p_{\\mathrm{f},3}]$，其中下标表示测试案例的索引。每个条目必须是浮点数。",
            "solution": "目标是计算核燃料棒中心线温度超过安全极限时的可靠性指标 $\\beta$ 和失效概率 $p_{\\mathrm{f}}$。这通过实现一阶可靠性方法（FORM）及 Hasofer-Lind-Rackwitz-Fiessler（HL-RF）迭代算法来完成。\n\n问题的核心在于将随机物理变量转换到标准正态空间，并在此空间中找到失效面上距离原点最近的点。该点到原点的距离即为可靠性指标 $\\beta$。\n\n**1. 极限状态函数和物理变量**\n\n物理空间中的独立随机变量向量为 $\\mathbf{X} = [x_1, x_2, x_3, x_4, x_5]^{\\top} = [T_{\\mathrm{c}}, \\dot{q}^{\\prime\\prime\\prime}, h, k, R]^{\\top}$。燃料中心线温度由下式给出：\n$$\nT_{\\mathrm{center}}(\\mathbf{X}) = T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right)\n$$\n安全极限是恒定温度 $T_{\\mathrm{limit}}$。极限状态函数 $g(\\mathbf{X})$ 定义了安全状态和失效状态之间的边界。失效定义为中心线温度超过极限的条件，对应于 $g(\\mathbf{X}) \\le 0$。\n$$\ng(\\mathbf{X}) = T_{\\mathrm{limit}} - T_{\\mathrm{center}}(\\mathbf{X}) = T_{\\mathrm{limit}} - \\left[ T_{\\mathrm{c}} + \\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right) \\right]\n$$\n\n**2. 物理空间中的梯度**\n\nHL-RF 算法需要极限状态函数的梯度。我们首先计算此梯度关于物理变量的导数 $\\nabla_{\\mathbf{X}} g(\\mathbf{X})$。偏导数如下：\n- $\\frac{\\partial g}{\\partial T_{\\mathrm{c}}} = -1$\n- $\\frac{\\partial g}{\\partial \\dot{q}^{\\prime\\prime\\prime}} = -\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right)$\n- $\\frac{\\partial g}{\\partial h} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial h}\\left(\\frac{R}{2h}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(-\\frac{R}{2h^2}\\right) = \\frac{\\dot{q}^{\\prime\\prime\\prime} R}{2h^2}$\n- $\\frac{\\partial g}{\\partial k} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial k}\\left(\\frac{R^2}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(-\\frac{R^2}{4k^2}\\right) = \\frac{\\dot{q}^{\\prime\\prime\\prime} R^2}{4k^2}$\n- $\\frac{\\partial g}{\\partial R} = -\\dot{q}^{\\prime\\prime\\prime} \\frac{\\partial}{\\partial R}\\left(\\frac{R}{2h} + \\frac{R^2}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{1}{2h} + \\frac{2R}{4k}\\right) = -\\dot{q}^{\\prime\\prime\\prime}\\left(\\frac{1}{2h} + \\frac{R}{2k}\\right)$\n\n**3. 等概率变换和雅可比矩阵**\n\n物理变量 $\\mathbf{X}$ 被转换为一个独立标准正态变量的向量 $\\mathbf{u} = [u_1, u_2, u_3, u_4, u_5]^{\\top}$。变换 $x_i(u_i)$ 及其导数 $\\frac{\\partial x_i}{\\partial u_i}$ 取决于 $x_i$ 的概率分布。\n\n- 对于正态分布变量 $X \\sim \\mathcal{N}(\\mu, \\sigma^2)$:\n  $$x(u) = \\mu + \\sigma u$$\n  $$\\frac{\\partial x}{\\partial u} = \\sigma$$\n\n- 对于对数正态分布变量 $X \\sim \\mathrm{Lognormal}$，其均值为 $m$，变异系数为 $c_v$：\n  首先计算其底层正态分布 $Y = \\ln X \\sim \\mathcal{N}(\\mu_{\\ln}, \\sigma_{\\ln}^2)$ 的参数：\n  $$\\sigma_{\\ln}^2 = \\ln(1 + c_v^2)$$\n  $$\\mu_{\\ln} = \\ln(m) - \\frac{1}{2}\\sigma_{\\ln}^2$$\n  变换及其导数如下：\n  $$x(u) = \\exp(\\mu_{\\ln} + \\sigma_{\\ln} u)$$\n  $$\\frac{\\partial x}{\\partial u} = \\frac{d}{du} \\left( e^{\\mu_{\\ln} + \\sigma_{\\ln} u} \\right) = e^{\\mu_{\\ln} + \\sigma_{\\ln} u} \\cdot \\sigma_{\\ln} = \\sigma_{\\ln} x(u)$$\n\n**4. 标准正态空间中的梯度**\n\n标准正态空间中的梯度 $\\nabla_{\\mathbf{u}} g(\\mathbf{u})$ 通过链式法则求得。由于变换是独立的，雅可比矩阵 $\\mathbf{J}_{\\mathbf{X},\\mathbf{u}}$ 是对角矩阵，其对角线元素为 $J_{ii} = \\frac{\\partial x_i}{\\partial u_i}$。\n$$\n\\nabla_{\\mathbf{u}} g(\\mathbf{u}) = \\mathbf{J}_{\\mathbf{X},\\mathbf{u}}^{\\top} \\nabla_{\\mathbf{X}} g(\\mathbf{X}(\\mathbf{u}))\n$$\n因此，梯度的分量为：\n$$\n\\frac{\\partial g}{\\partial u_i} = \\frac{\\partial g}{\\partial x_i} \\frac{\\partial x_i}{\\partial u_i}\n$$\n这些值必须在当前迭代点 $\\mathbf{u}_k$ 处进行评估，方法是首先计算相应的物理值 $\\mathbf{X}(\\mathbf{u}_k)$。\n\n**5. HL-RF 算法**\n\nHL-RF 算法是一种不动点迭代方案，用于寻找设计点 $\\mathbf{u}^*$。该点是失效面 $g(\\mathbf{u}) = 0$ 上距离原点最近的点。\n\n1. 用 $\\mathbf{u}_0 = \\mathbf{0}$ 初始化迭代。\n2. 对于迭代 $k=0, 1, 2, \\dots$：\n   a. 计算物理变量 $\\mathbf{X}_k = \\mathbf{X}(\\mathbf{u}_k)$。\n   b. 评估极限状态函数 $g(\\mathbf{u}_k) = g(\\mathbf{X}_k)$。\n   c. 评估物理空间中的梯度 $\\nabla_{\\mathbf{X}} g(\\mathbf{X}_k)$。\n   d. 计算在 $\\mathbf{u}_k$ 处的雅可比分量 $\\frac{\\partial x_i}{\\partial u_i}$。\n   e. 计算标准正态空间中的梯度 $\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)$。\n   f. 计算更新参数 $\\lambda_k$：\n      $$\n      \\lambda_k = \\frac{g(\\mathbf{u}_k) - \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)^{\\top} \\mathbf{u}_k}{\\left\\|\\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\\right\\|^2}\n      $$\n   g. 更新标准正态向量 $\\mathbf{u}_{k+1}$：\n      $$\n      \\mathbf{u}_{k+1} = -\\lambda_k \\nabla_{\\mathbf{u}} g(\\mathbf{u}_k)\n      $$\n3. 检查收敛性。当 $\\left\\|\\mathbf{u}_{k+1} - \\mathbf{u}_k\\right\\|  \\varepsilon$ 时，迭代停止，其中 $\\varepsilon$ 是一个小的容差（例如 $10^{-8}$）。收敛点即为设计点 $\\mathbf{u}^*$。\n\n**6. 可靠性指标和失效概率**\n\n一旦算法收敛到设计点 $\\mathbf{u}^*$，可靠性指标 $\\beta$ 即为该点的欧几里得范数（到原点的距离）：\n$$\n\\beta = \\left\\|\\mathbf{u}^*\\right\\| = \\sqrt{\\sum_{i=1}^n (u_i^*)^2}\n$$\n然后使用标准正态累积分布函数 $\\Phi(\\cdot)$ 计算失效概率 $p_{\\mathrm{f}}$ 的一阶近似值：\n$$\np_{\\mathrm{f}} = \\Phi(-\\beta)\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n#\n# === Probabilistic Variable Definitions ===\n#\nclass NormalVariable:\n    \"\"\"Represents a normally distributed random variable.\"\"\"\n    def __init__(self, mean, std_dev):\n        self.mean = float(mean)\n        self.std_dev = float(std_dev)\n\n    def transform(self, u):\n        \"\"\"Maps a standard normal variable u to the physical variable x.\"\"\"\n        return self.mean + self.std_dev * u\n\n    def jacobian_component(self, u, x):\n        \"\"\"Computes the component of the Jacobian d(x)/d(u).\"\"\"\n        return self.std_dev\n\nclass LognormalVariable:\n    \"\"\"Represents a lognormally distributed random variable.\"\"\"\n    def __init__(self, mean, cv):\n        self.m = float(mean)\n        self.cv = float(cv)\n        \n        # Pre-compute parameters of the underlying normal distribution\n        sigma_ln_sq = np.log(1.0 + self.cv**2)\n        self.sigma_ln = np.sqrt(sigma_ln_sq)\n        self.mu_ln = np.log(self.m) - 0.5 * sigma_ln_sq\n\n    def transform(self, u):\n        \"\"\"Maps a standard normal variable u to the physical variable x.\"\"\"\n        return np.exp(self.mu_ln + self.sigma_ln * u)\n\n    def jacobian_component(self, u, x):\n        \"\"\"Computes the component of the Jacobian d(x)/d(u).\"\"\"\n        return self.sigma_ln * x\n\n#\n# === First-Order Reliability Method (FORM) Solver ===\n#\ndef solve_form(variables, T_limit, epsilon=1e-8, max_iter=100):\n    \"\"\"\n    Computes the reliability index and failure probability using FORM-HLRF.\n    \"\"\"\n    num_vars = len(variables)\n    u = np.zeros(num_vars)\n\n    for i in range(max_iter):\n        u_old = u.copy()\n        \n        # 1. Transform from standard normal space (u) to physical space (x)\n        x = np.array([var.transform(u_i) for var, u_i in zip(variables, u)])\n        Tc, q_dot, h, k, R = x\n        \n        # 2. Evaluate the limit-state function g(u)\n        T_center = Tc + q_dot * (R / (2.0 * h) + R**2 / (4.0 * k))\n        g_val = T_limit - T_center\n        \n        # 3. Evaluate the gradient of g in physical space, grad_x(g)\n        grad_g_x = np.array([\n            -1.0,\n            -(R / (2.0 * h) + R**2 / (4.0 * k)),\n            (q_dot * R) / (2.0 * h**2),\n            (q_dot * R**2) / (4.0 * k**2),\n            -q_dot * (1.0 / (2.0 * h) + R / (2.0 * k))\n        ])\n\n        # 4. Compute the gradient of g in standard normal space, grad_u(g)\n        jac_components = np.array([var.jacobian_component(u_i, x_i) \n                                   for var, u_i, x_i in zip(variables, u, x)])\n        grad_g_u = grad_g_x * jac_components\n        \n        # 5. Apply the HL-RF update rule\n        norm_grad_g_u = np.linalg.norm(grad_g_u)\n        if norm_grad_g_u  1e-12: # Avoid division by zero\n            # If gradient is near zero and g is also near zero, we might have converged.\n            if abs(g_val)  epsilon:\n                break\n            else:\n                # This case is unlikely for this problem but is good practice to handle.\n                # A zero gradient far from the failure surface indicates a problem.\n                raise RuntimeError(\"HL-RF failed: zero gradient encountered.\")\n\n        lambda_k = (g_val - np.dot(grad_g_u, u)) / (norm_grad_g_u**2)\n        u = -lambda_k * grad_g_u\n        \n        # 6. Check for convergence\n        if np.linalg.norm(u - u_old)  epsilon:\n            break\n    \n    # 7. Compute reliability index (beta) and probability of failure (p_f)\n    beta = np.linalg.norm(u)\n    p_f = norm.cdf(-beta)\n    \n    return beta, p_f\n\n#\n# === Main Execution Block ===\n#\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (typical safe operating conditions)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=580.0, std_dev=15.0),\n                LognormalVariable(mean=1.0e8, cv=0.10),\n                LognormalVariable(mean=20000.0, cv=0.15),\n                LognormalVariable(mean=2.5, cv=0.20),\n                LognormalVariable(mean=0.004, cv=0.01)\n            ]\n        },\n        # Test Case 2 (near boundary)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=650.0, std_dev=20.0),\n                LognormalVariable(mean=3.0e8, cv=0.10),\n                LognormalVariable(mean=5000.0, cv=0.20),\n                LognormalVariable(mean=1.5, cv=0.25),\n                LognormalVariable(mean=0.0045, cv=0.02)\n            ]\n        },\n        # Test Case 3 (high risk)\n        {\n            'T_limit': 1800.0,\n            'variables': [\n                NormalVariable(mean=700.0, std_dev=30.0),\n                LognormalVariable(mean=4.0e8, cv=0.15),\n                LognormalVariable(mean=3000.0, cv=0.25),\n                LognormalVariable(mean=1.0, cv=0.30),\n                LognormalVariable(mean=0.0050, cv=0.03)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        beta, p_f = solve_form(case['variables'], case['T_limit'])\n        results.extend([beta, p_f])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}