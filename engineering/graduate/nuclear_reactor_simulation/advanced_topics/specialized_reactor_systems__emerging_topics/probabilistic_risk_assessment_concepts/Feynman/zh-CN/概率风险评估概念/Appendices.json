{
    "hands_on_practices": [
        {
            "introduction": "概率风险评估（PRA）的核心在于将复杂的系统失效分解为更基本的事件组合。本练习将引导您完成一个基础但至关重要的任务：量化故障树。通过一个关于反应堆停堆后余热排出功能的假设场景，您将使用最小割集来计算顶事件（即系统功能失效）的精确概率，并将其与“稀有事件近似”的结果进行比较。这个实践旨在巩固您对概率论基本公理（特别是容斥原理）的理解，并揭示在工程实践中进行近似计算的价值与权衡。",
            "id": "4242381",
            "problem": "一个反应堆刚刚停堆，衰变热排出系统需要在 $24$ 小时的任务时间内运行以排出余热。在核反应堆模拟的概率风险评估（Probabilistic Risk Assessment, PRA）背景下，考虑顶事件被定义为在任务时间内衰变热排出功能的失效。该顶事件的故障树具有以下最小割集（每个割集都是独立基本部件故障的合取）：\n- $M_{1} = \\{A, B\\}$，\n- $M_{2} = \\{B, C\\}$，\n- $M_{3} = \\{C, D\\}$，\n- $M_{4} = \\{A, D\\}$。\n\n假设基本事件是统计独立的，其任务时间内的失效概率如下：\n- $P(A) = 1.5 \\times 10^{-3}$，\n- $P(B) = 8.0 \\times 10^{-4}$，\n- $P(C) = 1.2 \\times 10^{-3}$，\n- $P(D) = 9.0 \\times 10^{-4}$。\n\n仅使用基本概率公理和从第一性原理推导出的容斥原理，计算作为最小割集失效事件并集的顶事件的确切概率。同时，通过对最小割集概率求和来计算顶事件概率的稀有事件近似值，并对它们进行定性比较。将最终（确切的）顶事件概率表示为小数，四舍五入到六位有效数字。不要使用百分号。",
            "solution": "用户希望我解决这个问题。\n\n**第一步：提取已知条件**\n\n- **任务时间**：$24$ 小时\n- **顶事件**：衰变热排出功能失效。\n- **最小割集（MCS）**：\n  - $M_{1} = \\{A, B\\}$\n  - $M_{2} = \\{B, C\\}$\n  - $M_{3} = \\{C, D\\}$\n  - $M_{4} = \\{A, D\\}$\n- **基本事件独立性**：基本事件是统计独立的。\n- **基本事件失效概率**：\n  - $P(A) = 1.5 \\times 10^{-3}$\n  - $P(B) = 8.0 \\times 10^{-4}$\n  - $P(C) = 1.2 \\times 10^{-3}$\n  - $P(D) = 9.0 \\times 10^{-4}$\n- **任务**：\n  1. 使用容斥原理计算顶事件的确切概率。\n  2. 计算稀有事件近似值。\n  3. 定性比较确切概率和近似概率。\n  4. 将最终确切概率表示为小数，并四舍五入到六位有效数字。\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题基于概率风险评估（PRA）和故障树分析（FTA）的原理，这些是核工程和可靠性理论中标准的、完善的方法论。该场景在反应堆安全分析中是一个可信且重要的场景。给出的数值具有现实的量级。此标准已满足。\n- **适定性**：该问题提供了计算唯一解所需的所有数据（最小割集、基本事件概率、独立性）。目标陈述清晰。此标准已满足。\n- **客观性**：该问题以精确、定量且无偏见的技术语言陈述。此标准已满足。\n\n该问题没有说明中列出的任何缺陷（例如，科学上不健全、数据缺失、模棱两可等）。其逻辑结构合理，并提出了一个可靠性工程中标准的、尽管详细的计算。\n\n**第三步：结论与行动**\n\n该问题是**有效的**。将提供完整解答。\n\n顶事件，我们用 $T$ 表示，是衰变热排出功能的失效。该事件发生当且仅当至少一个最小割集（MCS）发生。设 $E_i$ 为对应于最小割集 $M_i$ 中所有基本部件失效的事件。顶事件是这些事件的并集：\n$$\nT = E_1 \\cup E_2 \\cup E_3 \\cup E_4\n$$\n事件 $E_i$ 被定义为其各自基本事件的合取（交集）：\n- $E_1 = A \\cap B$\n- $E_2 = B \\cap C$\n- $E_3 = C \\cap D$\n- $E_4 = A \\cap D$\n\n顶事件的概率 $P(T)$ 为 $P(E_1 \\cup E_2 \\cup E_3 \\cup E_4)$。我们必须使用容斥原理来求确切值。对于四个事件，公式为：\n$$\nP(T) = \\sum_{i=1}^{4} P(E_i) - \\sum_{1 \\le i  j \\le 4} P(E_i \\cap E_j) + \\sum_{1 \\le i  j  k \\le 4} P(E_i \\cap E_j \\cap E_k) - P(E_1 \\cap E_2 \\cap E_3 \\cap E_4)\n$$\n\n首先，我们计算单个 MCS 事件的概率 $P(E_i)$。由于基本事件 A、B、C、D 是统计独立的，它们交集的概率是它们各自概率的乘积。\n$$\nP(E_1) = P(A \\cap B) = P(A)P(B) = (1.5 \\times 10^{-3})(8.0 \\times 10^{-4}) = 1.2 \\times 10^{-6}\n$$\n$$\nP(E_2) = P(B \\cap C) = P(B)P(C) = (8.0 \\times 10^{-4})(1.2 \\times 10^{-3}) = 9.6 \\times 10^{-7} = 0.96 \\times 10^{-6}\n$$\n$$\nP(E_3) = P(C \\cap D) = P(C)P(D) = (1.2 \\times 10^{-3})(9.0 \\times 10^{-4}) = 1.08 \\times 10^{-6}\n$$\n$$\nP(E_4) = P(A \\cap D) = P(A)P(D) = (1.5 \\times 10^{-3})(9.0 \\times 10^{-4}) = 1.35 \\times 10^{-6}\n$$\n\n容斥级数的第一项是这些概率之和，这也被称为稀有事件近似，记为 $P(T)_{approx}$。\n$$\nP(T)_{approx} = \\sum_{i=1}^{4} P(E_i) = (1.2 + 0.96 + 1.08 + 1.35) \\times 10^{-6} = 4.59 \\times 10^{-6}\n$$\n\n接下来，我们计算成对交集的概率 $P(E_i \\cap E_j)$。\n$$\nP(E_1 \\cap E_2) = P((A \\cap B) \\cap (B \\cap C)) = P(A \\cap B \\cap C) = P(A)P(B)P(C) = (1.2 \\times 10^{-6})(1.2 \\times 10^{-3}) = 1.44 \\times 10^{-9}\n$$\n$$\nP(E_1 \\cap E_3) = P((A \\cap B) \\cap (C \\cap D)) = P(A \\cap B \\cap C \\cap D) = P(A)P(B)P(C)P(D) = (1.44 \\times 10^{-9})(9.0 \\times 10^{-4}) = 1.296 \\times 10^{-12}\n$$\n$$\nP(E_1 \\cap E_4) = P((A \\cap B) \\cap (A \\cap D)) = P(A \\cap B \\cap D) = P(A)P(B)P(D) = (1.2 \\times 10^{-6})(9.0 \\times 10^{-4}) = 1.08 \\times 10^{-9}\n$$\n$$\nP(E_2 \\cap E_3) = P((B \\cap C) \\cap (C \\cap D)) = P(B \\cap C \\cap D) = P(B)P(C)P(D) = (0.96 \\times 10^{-6})(9.0 \\times 10^{-4}) = 8.64 \\times 10^{-10} = 0.864 \\times 10^{-9}\n$$\n$$\nP(E_2 \\cap E_4) = P((B \\cap C) \\cap (A \\cap D)) = P(A \\cap B \\cap C \\cap D) = 1.296 \\times 10^{-12}\n$$\n$$\nP(E_3 \\cap E_4) = P((C \\cap D) \\cap (A \\cap D)) = P(A \\cap C \\cap D) = P(A)P(C)P(D) = (1.5 \\times 10^{-3})(1.2 \\times 10^{-3})(9.0 \\times 10^{-4}) = 1.62 \\times 10^{-9}\n$$\n这些成对交集概率的总和是：\n$$\n\\sum_{1 \\le i  j \\le 4} P(E_i \\cap E_j) = (1.44 + 1.08 + 0.864 + 1.62) \\times 10^{-9} + 2 \\times (1.296 \\times 10^{-12})\n$$\n$$\n= 5.004 \\times 10^{-9} + 2.592 \\times 10^{-12} = 5.004 \\times 10^{-9} + 0.002592 \\times 10^{-9} = 5.006592 \\times 10^{-9}\n$$\n\n接下来，我们计算三路交集的概率 $P(E_i \\cap E_j \\cap E_k)$。\n$$\nP(E_1 \\cap E_2 \\cap E_3) = P((A \\cap B) \\cap (B \\cap C) \\cap (C \\cap D)) = P(A \\cap B \\cap C \\cap D) = 1.296 \\times 10^{-12}\n$$\n$$\nP(E_1 \\cap E_2 \\cap E_4) = P((A \\cap B) \\cap (B \\cap C) \\cap (A \\cap D)) = P(A \\cap B \\cap C \\cap D) = 1.296 \\times 10^{-12}\n$$\n$$\nP(E_1 \\cap E_3 \\cap E_4) = P((A \\cap B) \\cap (C \\cap D) \\cap (A \\cap D)) = P(A \\cap B \\cap C \\cap D) = 1.296 \\times 10^{-12}\n$$\n$$\nP(E_2 \\cap E_3 \\cap E_4) = P((B \\cap C) \\cap (C \\cap D) \\cap (A \\cap D)) = P(A \\cap B \\cap C \\cap D) = 1.296 \\times 10^{-12}\n$$\n这些三路交集概率的总和是：\n$$\n\\sum_{1 \\le i  j  k \\le 4} P(E_i \\cap E_j \\cap E_k) = 4 \\times P(A \\cap B \\cap C \\cap D) = 4 \\times (1.296 \\times 10^{-12}) = 5.184 \\times 10^{-12}\n$$\n\n最后，四路交集的概率是：\n$$\nP(E_1 \\cap E_2 \\cap E_3 \\cap E_4) = P(A \\cap B \\cap C \\cap D) = 1.296 \\times 10^{-12}\n$$\n\n现在，我们将所有这些项代入容斥公式，以求得确切概率 $P(T)$。\n$$\nP(T) = (4.59 \\times 10^{-6}) - (5.006592 \\times 10^{-9}) + (5.184 \\times 10^{-12}) - (1.296 \\times 10^{-12})\n$$\n$$\nP(T) = 4.59 \\times 10^{-6} - 0.005006592 \\times 10^{-6} + 0.000005184 \\times 10^{-6} - 0.000001296 \\times 10^{-6}\n$$\n$$\nP(T) = (4.59 - 0.005006592 + 0.000003888) \\times 10^{-6}\n$$\n$$\nP(T) = (4.584993408 + 0.000003888) \\times 10^{-6}\n$$\n$$\nP(T) = 4.584997296 \\times 10^{-6}\n$$\n\n对于定性比较，稀有事件近似值为 $P(T)_{approx} = 4.59 \\times 10^{-6}$，而确切概率为 $P(T)_{exact} = 4.584997296 \\times 10^{-6}$。近似值是一个高估值，这是预料之中的。总和 $\\sum P(E_i)$ 重复计算了事件 $E_i$ 交集的概率。容斥原理通过减去成对交集的概率、加回三元交集的概率等方式对此进行修正。对于稀有事件，交集的概率远小于单个事件的概率，因此第一项占主导地位，在第一项之后截断级数（即稀有事件近似）可以提供一个很好的估计。这个估计是保守的，因为它高估了失效概率。相对误差非常小，约为 $0.1\\%$：\n$$\n\\frac{P(T)_{approx} - P(T)_{exact}}{P(T)_{exact}} \\approx \\frac{4.59 \\times 10^{-6} - 4.585 \\times 10^{-6}}{4.585 \\times 10^{-6}} = \\frac{0.005}{4.585} \\approx 0.00109\n$$\n\n最后，我们将确切的顶事件概率表示为小数，并四舍五入到六位有效数字。\n$$\nP(T) = 4.584997296 \\times 10^{-6}\n$$\n四舍五入到六位有效数字得到 $4.58500 \\times 10^{-6}$。作为小数，即为 $0.00000458500$。",
            "answer": "$$\n\\boxed{0.00000458500}\n$$"
        },
        {
            "introduction": "除了硬件故障，人为因素在核反应堆安全中也扮演着决定性角色。本练习将您的注意力从硬件可靠性转移到人为可靠性分析（HRA）这一关键领域。您将通过一个涉及应急响应程序的多步骤操作员行为的假设案例，学习如何量化“综合人为失误概率”（HEP）。此问题的核心是处理步骤之间的依赖性——一个步骤的失误可能会影响后续步骤的成功率。通过应用条件概率，您将构建一个依赖模型，并计算整个程序失败的总概率，从而深入理解在PRA中对复杂人为干预进行建模的挑战与方法。",
            "id": "4242403",
            "problem": "压水反应堆的应急响应程序包含一个顺序的三步操作员行动，用于在汽轮机跳闸并丧失厂外电源后维持堆芯冷却。在核反应堆模拟的概率风险评估 (PRA) 中，分析师必须量化复合程序失效的人为失误概率 (HEP)，同时要认识到由于认知遗留、时间压力和演变的电厂信号，步骤之间存在依赖性。为建立依赖模型的基础，假设一个贝叶斯网络 (BN)，其中包含二元错误节点 $E_1$、$E_2$ 和 $E_3$，$E_i$ 表示步骤 $i$ 中的错误，有向边 $E_1 \\rightarrow E_2$、$E_1 \\rightarrow E_3$ 和 $E_2 \\rightarrow E_3$ 捕捉了顺序依赖性。\n\n步骤定义：\n- 步骤 $1$：诊断电厂状态并选择正确的应急冷却策略。\n- 步骤 $2$：对齐硼注入路径并验证阀门位置。\n- 步骤 $3$：启动注入泵并确认流量指示稳定。\n\n假设BN具有以下边际和条件概率，反映了性能形成和认知依赖性：\n- $P(E_1)=0.08$。\n- $P(E_2 \\mid E_1)=0.25$, $P(E_2 \\mid \\overline{E_1})=0.03$。\n- $P(E_3 \\mid \\overline{E_1},\\overline{E_2})=0.02$, $P(E_3 \\mid E_1,\\overline{E_2})=0.10$, $P(E_3 \\mid \\overline{E_1},E_2)=0.12$, $P(E_3 \\mid E_1,E_2)=0.20$。\n\n对于此情景，将复合程序失效事件 $F$ 定义为“至少发生一个步骤错误”，即 $F=\\{E_1 \\cup E_2 \\cup E_3\\}$，将程序成功事件 $S$ 定义为“没有错误发生”，即 $S=\\{\\overline{E_1} \\cap \\overline{E_2} \\cap \\overline{E_3}\\}$。\n\n仅从概率公理和条件概率的定义出发，推导出一个关于 $P(F)$ 的数学有效表达式，该表达式用 $P(\\overline{E_1})$、$P(\\overline{E_2} \\mid \\overline{E_1})$ 和 $P(\\overline{E_3} \\mid \\overline{E_1},\\overline{E_2})$ 表示，然后使用给定的BN参数对其进行评估。将最终的复合HEP $P(F)$ 表示为十进制数（无单位）。将您的答案四舍五入到四位有效数字。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于概率风险评估和概率论，是自洽、适定和客观的。为得到唯一解所需的所有必要数据和定义均已提供。\n\n目标是确定一个三步顺序程序的复合人为失误概率 (HEP)，记为 $P(F)$。失效事件 $F$ 定义为三个步骤中至少发生一个错误，形式上表示为单个错误事件 $E_1$、$E_2$ 和 $E_3$ 的并集：\n$$F = E_1 \\cup E_2 \\cup E_3$$\n计算事件并集的概率，一个更直接的方法通常是计算其补集的概率。失效事件 $F$ 的补集是成功事件 $S$，对应于三个步骤中均未发生错误。根据 De Morgan 定律，F的补集，记为 $\\overline{F}$，是：\n$$\\overline{F} = \\overline{E_1 \\cup E_2 \\cup E_3} = \\overline{E_1} \\cap \\overline{E_2} \\cap \\overline{E_3} = S$$\n根据概率公理，一个事件及其补集的概率之和为 $1$。因此：\n$$P(F) + P(\\overline{F}) = 1$$\n$$P(F) = 1 - P(\\overline{F}) = 1 - P(S)$$\n任务现在简化为求成功事件的概率，$P(S) = P(\\overline{E_1} \\cap \\overline{E_2} \\cap \\overline{E_3})$。\n\n为了推导 $P(S)$ 的表达式，我们使用概率的链式法则，这是条件概率定义 $P(A \\cap B) = P(A \\mid B)P(B)$ 的一个推论。对于三个事件，链式法则表述为：\n$$P(\\overline{E_1} \\cap \\overline{E_2} \\cap \\overline{E_3}) = P(\\overline{E_3} \\mid \\overline{E_1} \\cap \\overline{E_2}) P(\\overline{E_2} \\cap \\overline{E_1})$$\n再次对 $P(\\overline{E_2} \\cap \\overline{E_1})$ 项应用条件概率的定义：\n$$P(\\overline{E_2} \\cap \\overline{E_1}) = P(\\overline{E_2} \\mid \\overline{E_1}) P(\\overline{E_1})$$\n将其代回，得到 $P(S)$ 的完整表达式：\n$$P(S) = P(\\overline{E_1}) P(\\overline{E_2} \\mid \\overline{E_1}) P(\\overline{E_3} \\mid \\overline{E_1}, \\overline{E_2})$$\n这是问题所规定的结构，它自然地源于指定的贝叶斯网络的因果依赖关系（$E_1 \\rightarrow E_2$、$E_1 \\rightarrow E_3$、$E_2 \\rightarrow E_3$）。\n\n因此，复合失效概率 $P(F)$ 为：\n$$P(F) = 1 - \\left( P(\\overline{E_1}) P(\\overline{E_2} \\mid \\overline{E_1}) P(\\overline{E_3} \\mid \\overline{E_1}, \\overline{E_2}) \\right)$$\n我们现在使用所提供的数据来评估每一项。事件补集 $\\overline{A}$ 的概率为 $P(\\overline{A}) = 1 - P(A)$。\n\n1.  计算 $P(\\overline{E_1})$:\n    已知 $P(E_1) = 0.08$。\n    $$P(\\overline{E_1}) = 1 - P(E_1) = 1 - 0.08 = 0.92$$\n\n2.  计算 $P(\\overline{E_2} \\mid \\overline{E_1})$:\n    已知 $P(E_2 \\mid \\overline{E_1}) = 0.03$。\n    $$P(\\overline{E_2} \\mid \\overline{E_1}) = 1 - P(E_2 \\mid \\overline{E_1}) = 1 - 0.03 = 0.97$$\n\n3.  计算 $P(\\overline{E_3} \\mid \\overline{E_1}, \\overline{E_2})$:\n    已知 $P(E_3 \\mid \\overline{E_1}, \\overline{E_2}) = 0.02$。\n    $$P(\\overline{E_3} \\mid \\overline{E_1}, \\overline{E_2}) = 1 - P(E_3 \\mid \\overline{E_1}, \\overline{E_2}) = 1 - 0.02 = 0.98$$\n\n现在，将这些概率代入 $P(S)$ 的表达式中：\n$$P(S) = (0.92) \\times (0.97) \\times (0.98)$$\n$$P(S) = 0.8924 \\times 0.98$$\n$$P(S) = 0.874552$$\n\n最后，计算复合HEP，$P(F)$：\n$$P(F) = 1 - P(S) = 1 - 0.874552 = 0.125448$$\n问题要求答案四舍五入到四位有效数字。\n$$P(F) \\approx 0.1254$$\n该值表示在三步应急程序中，考虑到指定的认知和顺序依赖性，至少发生一次人为失误的总概率。",
            "answer": "$$\\boxed{0.1254}$$"
        },
        {
            "introduction": "在真实的PRA模型中，我们输入的基本事件概率和初始事件频率并非确切的常数，而是带有不确定性的估计值。一个完整的风险评估必须量化这种不确定性如何传播到最终的风险指标（如堆芯损坏频率，CDF）中。这个综合性练习将指导您实施蒙特卡洛模拟——这是PRA中进行不确定性分析的黄金标准。您将为一个简化的反应堆模型编写程序，通过从指定的概率分布中抽样参数，来计算CDF的分布，而不仅仅是一个单一的点估计值。这项实践将前面练习中的概念（如故障树逻辑）整合到一个更大的事件树框架中，最终让您能够计算出风险指标的均值和置信区间，深刻体验现代PRA如何为风险知情决策提供有力的量化支持。",
            "id": "4242362",
            "problem": "您的任务是实现一个程序，该程序使用蒙特卡罗抽样，通过事件树及相关的故障树传播参数不确定性，以生成堆芯损伤频率（CDF）的分布及其可信区间。该问题设定在核反应堆概率风险评估（PRA）的背景下。您的实现必须具有通用性、科学性，并严格遵守指定的输出格式。\n\n从以下基本和核心定义开始：\n- 事件树表示导致潜在序列的互斥始发事件。堆芯损伤频率（CDF）定义为始发事件频率乘以相关序列上的条件堆芯损伤概率的总和。形式上，如果有 $M$ 个始发事件，则\n$$\n\\text{CDF} = \\sum_{i=1}^{M} f_i \\, P_i,\n$$\n其中 $f_i$ 是始发事件频率（单位：每反应堆年），$P_i$ 是事件 $i$ 的条件堆芯损伤概率。\n- 在基本组件失效事件独立的假设下，故障树通过与门（AND）和或门（OR）等逻辑门来描述系统失效的组合方式。如果 $A$ 和 $B$ 是独立失效，那么对于一个与门，\n$$\nP(A \\land B) = P(A) \\, P(B),\n$$\n对于一个或门，\n$$\nP(A \\lor B) = P(A) + P(B) - P(A) P(B).\n$$\n- 组件的按需失效概率被建模为服从贝塔分布的随机变量，以反映不确定性。如果 $p$ 是失效概率，那么 $p \\sim \\text{Beta}(\\alpha,\\beta)$，其均值为 $\\mathbb{E}[p] = \\frac{\\alpha}{\\alpha + \\beta}$。\n- 与时间相关的运行失效被建模为失效率为 $\\lambda$（单位：每小时失效次数）的泊松过程。在任务时间 $t$ 小时内至少发生一次失效的概率是\n$$\nq = 1 - e^{-\\lambda t}.\n$$\n- 始发事件频率 $f_i$（单位：每反应堆年）被建模为独立的对数正态随机变量，$f_i \\sim \\text{Lognormal}(\\mu_i, \\sigma_i)$，其中 $\\mu_i$ 和 $\\sigma_i$ 分别是自然对数的均值和标准差（因此 $\\log f_i \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$）。\n\n需要建模的事件树和故障树结构如下：\n- 始发事件：失水事故（LOCA）、全厂断电（SBO）和无紧急停堆的预期瞬态（ATWS）。设索引集为 $i \\in \\{\\text{LOCA}, \\text{SBO}, \\text{ATWS}\\}$。\n- 故障树顶事件逻辑定义如下：\n    - 对于 LOCA，如果高压安注（HPI）和低压安注（LPI）均按需失效，则发生堆芯损伤，由一个与门建模：\n      $$\n      P_{\\text{LOCA}} = p_{\\text{HPI}} \\cdot p_{\\text{LPI}}.\n      $$\n    - 对于 ATWS，如果辅助给水（AFW）按需失效且低压安注（LPI）按需失效，则发生堆芯损伤，同样是一个与门：\n      $$\n      P_{\\text{ATWS}} = p_{\\text{AFW}} \\cdot p_{\\text{LPI}}.\n      $$\n    - 对于 SBO，如果在指定的任务时间内，$n$ 台应急柴油发电机（EDG）中成功运行的少于 $k$ 台，则发生堆芯损伤。设 $q$ 表示单台发电机在任务时间内的运行失效概率，假设各发电机相同且独立。那么，运行的发电机少于 $k$ 台的概率是二项累积概率：\n      $$\n      P_{\\text{SBO}} = \\sum_{s=0}^{k-1} \\binom{n}{s} (1-q)^s \\, q^{n-s}.\n      $$\n\n不确定性传播与蒙特卡罗方法：\n- 对于每次蒙特卡罗实现：\n    - 对组件按需失效概率进行抽样：$p_{\\text{HPI}} \\sim \\text{Beta}(\\alpha_{\\text{HPI}}, \\beta_{\\text{HPI}})$、$p_{\\text{LPI}} \\sim \\text{Beta}(\\alpha_{\\text{LPI}}, \\beta_{\\text{LPI}})$、$p_{\\text{AFW}} \\sim \\text{Beta}(\\alpha_{\\text{AFW}}, \\beta_{\\text{AFW}})$。这些概率在该次实现的所有始发事件中是共享的。\n    - 从参数为 $(\\mu_{\\lambda}, \\sigma_{\\lambda})$（自然对数的参数）的对数正态分布中抽样应急柴油发电机的运行失效率 $\\lambda_{\\text{EDG}}$，并计算 $q = 1 - e^{-\\lambda_{\\text{EDG}} t}$，其中 $t$ 是任务时间（小时）。这些 EDG 参数在该次实现的所有事件中也是共用的。\n    - 从它们指定的对数正态分布中独立抽样始发事件频率 $f_{\\text{LOCA}}$、$f_{\\text{SBO}}$ 和 $f_{\\text{ATWS}}$。\n    - 使用上述逻辑门公式计算 $P_{\\text{LOCA}}$、$P_{\\text{SBO}}$ 和 $P_{\\text{ATWS}}$，然后计算\n      $$\n      \\text{CDF} = f_{\\text{LOCA}} P_{\\text{LOCA}} + f_{\\text{SBO}} P_{\\text{SBO}} + f_{\\text{ATWS}} P_{\\text{ATWS}}.\n      $$\n- 重复 $N$ 次实现以获得 CDF 的分布。报告经验均值和置信水平为 $c$ 的双侧可信区间（例如，$c = 0.95$）。双侧可信区间的端点是抽样得到的 CDF 分布的 $(\\frac{1-c}{2})$ 和 $(1-\\frac{1-c}{2})$ 经验分位数。\n\n物理和数值单位：\n- 所有 CDF 和区间值均以 $1/\\text{年}$（每反应堆年）为单位报告。将数值输出表示为无量纲的浮点数，其隐含单位为 $1/\\text{年}$。\n\n角度单位不适用。不应使用百分比；所有概率均以小数表示。\n\n测试套件：\n实现您的程序以运行以下四个测试用例，并为每个用例按指定格式返回结果。程序必须使用固定的随机种子以保证可复现性。\n\n- 测试用例 1（中等不确定性，基准架构）：\n    - 蒙特卡罗样本数：$N = 20000$。\n    - 可信水平：$c = 0.95$。\n    - 任务时间：$t = 8$ 小时。\n    - EDG：$n = 2$，$k = 1$。\n    - Beta 参数（按需失效）：\n        - HPI: $(\\alpha_{\\text{HPI}}, \\beta_{\\text{HPI}}) = (10, 190)$。\n        - LPI: $(\\alpha_{\\text{LPI}}, \\beta_{\\text{LPI}}) = (8, 192)$。\n        - AFW: $(\\alpha_{\\text{AFW}}, \\beta_{\\text{AFW}}) = (12, 288)$。\n    - EDG 运行失效率（每小时）的对数正态参数：$(\\mu_{\\lambda}, \\sigma_{\\lambda}) = (\\log(0.01), 0.5)$。\n    - 始发事件频率（每年）的对数正态参数：\n        - LOCA: $(\\mu, \\sigma) = (\\log(10^{-3}), 0.5)$。\n        - SBO: $(\\mu, \\sigma) = (\\log(5 \\cdot 10^{-4}), 0.6)$。\n        - ATWS: $(\\mu, \\sigma) = (\\log(10^{-4}), 0.7)$。\n\n- 测试用例 2（低不确定性，较短任务时间）：\n    - 蒙特卡罗样本数：$N = 10000$。\n    - 可信水平：$c = 0.90$。\n    - 任务时间：$t = 4$ 小时。\n    - EDG：$n = 2$，$k = 1$。\n    - Beta 参数（按需失效）：\n        - HPI: $(\\alpha_{\\text{HPI}}, \\beta_{\\text{HPI}}) = (100, 1900)$。\n        - LPI: $(\\alpha_{\\text{LPI}}, \\beta_{\\text{LPI}}) = (120, 2880)$。\n        - AFW: $(\\alpha_{\\text{AFW}}, \\beta_{\\text{AFW}}) = (150, 3675)$。\n    - EDG 运行失效率（每小时）的对数正态参数：$(\\mu_{\\lambda}, \\sigma_{\\lambda}) = (\\log(0.01), 0.2)$。\n    - 始发事件频率（每年）的对数正态参数：\n        - LOCA: $(\\mu, \\sigma) = (\\log(8 \\cdot 10^{-4}), 0.3)$。\n        - SBO: $(\\mu, \\sigma) = (\\log(3 \\cdot 10^{-4}), 0.4)$。\n        - ATWS: $(\\mu, \\sigma) = (\\log(2 \\cdot 10^{-4}), 0.35)$。\n\n- 测试用例 3（重尾不确定性，长任务时间）：\n    - 蒙特卡罗样本数：$N = 15000$。\n    - 可信水平：$c = 0.95$。\n    - 任务时间：$t = 24$ 小时。\n    - EDG：$n = 2$，$k = 1$。\n    - Beta 参数（按需失效）：\n        - HPI: $(\\alpha_{\\text{HPI}}, \\beta_{\\text{HPI}}) = (2, 38)$。\n        - LPI: $(\\alpha_{\\text{LPI}}, \\beta_{\\text{LPI}}) = (2, 48)$。\n        - AFW: $(\\alpha_{\\text{AFW}}, \\beta_{\\text{AFW}}) = (3, 72)$。\n    - EDG 运行失效率（每小时）的对数正态参数：$(\\mu_{\\lambda}, \\sigma_{\\lambda}) = (\\log(0.02), 0.8)$。\n    - 始发事件频率（每年）的对数正态参数：\n        - LOCA: $(\\mu, \\sigma) = (\\log(5 \\cdot 10^{-4}), 1.0)$。\n        - SBO: $(\\mu, \\sigma) = (\\log(8 \\cdot 10^{-4}), 1.1)$。\n        - ATWS: $(\\mu, \\sigma) = (\\log(1.5 \\cdot 10^{-4}), 1.2)$。\n\n- 测试用例 4（冗余架构变化，需要多台发电机）：\n    - 蒙特卡罗样本数：$N = 12000$。\n    - 可信水平：$c = 0.95$。\n    - 任务时间：$t = 12$ 小时。\n    - EDG：$n = 3$，$k = 2$。\n    - Beta 参数（按需失效）：\n        - HPI: $(\\alpha_{\\text{HPI}}, \\beta_{\\text{HPI}}) = (20, 380)$。\n        - LPI: $(\\alpha_{\\text{LPI}}, \\beta_{\\text{LPI}}) = (16, 384)$。\n        - AFW: $(\\alpha_{\\text{AFW}}, \\beta_{\\text{AFW}}) = (25, 600)$。\n    - EDG 运行失效率（每小时）的对数正态参数：$(\\mu_{\\lambda}, \\sigma_{\\lambda}) = (\\log(0.005), 0.7)$。\n    - 始发事件频率（每年）的对数正态参数：\n        - LOCA: $(\\mu, \\sigma) = (\\log(7 \\cdot 10^{-4}), 0.6)$。\n        - SBO: $(\\mu, \\sigma) = (\\log(4 \\cdot 10^{-4}), 0.6)$。\n        - ATWS: $(\\mu, \\sigma) = (\\log(10^{-4}), 0.7)$。\n\n程序要求：\n- 使用固定的随机种子以保证可复现性。\n- 对每个测试用例，执行蒙特卡罗抽样以获得 CDF 分布，并计算经验均值、下可信限和上可信限（置信水平为 $c$）。可信限必须是抽样 CDF 的 $\\left(\\frac{1-c}{2}\\right)$ 和 $\\left(1 - \\frac{1-c}{2}\\right)$ 分位数。\n- 您的程序应生成一行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素本身是一个包含三个浮点数 $[\\text{mean},\\text{lower},\\text{upper}]$ 的列表，按顺序对应每个测试用例。例如，输出格式必须为\n$$\n\\big[ [m_1,\\ell_1,u_1],[m_2,\\ell_2,u_2],[m_3,\\ell_3,u_3],[m_4,\\ell_4,u_4] \\big],\n$$\n其中所有值都以 $1/\\text{年}$ 为单位，并表示为十进制数（不打印单位）。",
            "solution": "问题陈述已根据指定标准进行了仔细审查和验证。\n\n### 步骤 1：提取给定信息\n\n- **堆芯损伤频率 (CDF) 定义**：对于 $M$ 个始发事件，$\\text{CDF} = \\sum_{i=1}^{M} f_i \\, P_i$。\n- **始发事件**：$i \\in \\{\\text{LOCA}, \\text{SBO}, \\text{ATWS}\\}$，因此 $M=3$。\n- **故障树逻辑**：\n    - 与门：对于独立事件，$P(A \\land B) = P(A) \\, P(B)$。\n    - 或门：对于独立事件，$P(A \\lor B) = P(A) + P(B) - P(A) P(B)$。\n- **条件堆芯损伤概率 ($P_i$)**：\n    - $P_{\\text{LOCA}} = p_{\\text{HPI}} \\cdot p_{\\text{LPI}}$\n    - $P_{\\text{ATWS}} = p_{\\text{AFW}} \\cdot p_{\\text{LPI}}$\n    - $P_{\\text{SBO}} = \\sum_{s=0}^{k-1} \\binom{n}{s} (1-q)^s \\, q^{n-s}$\n- **基本事件的概率模型**：\n    - 按需失效概率：$p \\sim \\text{Beta}(\\alpha, \\beta)$。\n    - 随时间相关的运行失效概率：$q = 1 - e^{-\\lambda t}$，其中 $\\lambda$ 是失效率（每小时），$t$ 是任务时间（小时）。\n- **参数的不确定性模型**：\n    - 按需失效概率 $p_{\\text{HPI}}$、$p_{\\text{LPI}}$、$p_{\\text{AFW}}$ 在每次蒙特卡罗实现中从其各自的贝塔分布中抽样一次。\n    - EDG 运行失效率 $\\lambda_{\\text{EDG}}$ 从对数正态分布中抽样：$\\log(\\lambda_{\\text{EDG}}) \\sim \\mathcal{N}(\\mu_{\\lambda}, \\sigma_{\\lambda}^2)$。\n    - 始发事件频率 $f_i$ 从对数正态分布中抽样：$\\log(f_i) \\sim \\mathcal{N}(\\mu_i, \\sigma_i^2)$。所有频率单位均为 $1/\\text{年}$。\n- **蒙特卡罗程序**：\n    - 对于 $N$ 次实现的每一次，对所有基本参数（$p$ 值、$\\lambda$、$f$ 值）进行抽样，计算 $q$，然后计算 $P_i$，最后计算总 CDF。\n    - 计算 $N$ 个 CDF 样本的经验均值以及 $(\\frac{1-c}{2})$ 和 $(1-\\frac{1-c}{2})$ 经验分位数，以构成置信水平为 $c$ 的可信区间。\n- **测试用例**：提供了四个不同的测试用例，每个用例都指定了 $N、c、t、n、k$ 以及所有贝塔分布和对数正态分布的参数。\n- **程序要求**：使用固定的随机种子。将所有四个测试用例的结果输出为列表的列表：$\\big[ [m_1,\\ell_1,u_1],[m_2,\\ell_2,u_2],[m_3,\\ell_3,u_3],[m_4,\\ell_4,u_4] \\big]$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n对问题进行有效性审查：\n- **科学基础**：该问题是概率风险评估（PRA）原理的一个典型应用，这是核安全工程的基石。事件树、故障树、蒙特卡罗方法以及特定概率分布（用于概率的贝塔分布、用于频率和速率的对数正态分布）的使用是该领域的标准和正确实践。\n- **良构性**：问题是完全指定的。它提供了一套完整的模型、参数和计算指令。目标——计算 CDF 的均值和可信区间——是明确定义的。固定随机种子的要求确保了计算结果是确定性和可复现的。\n- **客观性**：问题以精确、定量和无偏见的语言陈述。所有定义和参数都是形式化和明确的。\n- **一致性和完整性**：设置在内部是一致和完整的。为四个测试用例中的每一个都提供了所有必要的数据。变量之间的关系（例如 $\\lambda_{\\text{EDG}}$ 和 $q$）被明确定义。LPI 系统失效概率（$p_{\\text{LPI}}$）在两个事件序列中的共享性是一个现实特征，并已正确地纳入模型中。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。它是在核反应堆模拟和风险评估领域中一个结构良好、科学合理且计算上可处理的问题。将开发一个解决方案。\n\n### 解决方案\n\n目标是实现一个蒙特卡罗模拟，通过一个简化的 PRA 模型来传播不确定性，并计算堆芯损伤频率（CDF）的分布。从这个分布中，我们将为几个指定的测试用例确定 CDF 的均值及其可信区间。\n\n**理论框架**\n\n总堆芯损伤频率是导致堆芯损伤的所有事故序列的频率之和。在这个模型中，我们有三个互斥的始发事件（IEs）：失水事故（LOCA）、全厂断电（SBO）和无紧急停堆的预期瞬态（ATWS）。因此，CDF 为：\n$$\n\\text{CDF} = f_{\\text{LOCA}} P_{\\text{LOCA}} + f_{\\text{SBO}} P_{\\text{SBO}} + f_{\\text{ATWS}} P_{\\text{ATWS}}\n$$\n其中 $f_i$ 是始发事件 $i$ 的频率，$P_i$ 是在事件 $i$ 发生的情况下，堆芯损伤的条件概率。\n\n模型参数的不确定性通过将它们视为随机变量来传播。对于每次蒙特卡罗实现，我们从其指定的概率分布中为每个参数抽取一个样本。\n\n**1. 参数抽样：**\n- **始发事件频率 ($f_i$)**：频率由对数正态分布建模。我们从 $\\text{Lognormal}(\\mu_i, \\sigma_i)$ 中抽样 $f_i$，其中 $\\mu_i$ 和 $\\sigma_i$ 是 $\\log(f_i)$ 的均值和标准差。\n- **按需失效概率 ($p$)**：系统按需失效的概率（$p_{\\text{HPI}}$、$p_{\\text{LPI}}$、$p_{\\text{AFW}}$）由贝塔分布建模。我们从各自的 $\\text{Beta}(\\alpha, \\beta)$ 分布中抽样。请注意，在同一次实现中，为 LOCA 和 ATWS 序列使用的是单个抽样的 $p_{\\text{LPI}}$ 值，这正确地模拟了它作为一个共享依赖项。\n- **随时间相关的失效率 ($\\lambda_{\\text{EDG}}$)**：应急柴油发电机（EDG）的失效率从对数正态分布中抽样，$\\lambda_{\\text{EDG}} \\sim \\text{Lognormal}(\\mu_{\\lambda}, \\sigma_{\\lambda})$。由此，计算出 EDG 在任务时间 $t$ 内未能运行的概率为 $q = 1 - e^{-\\lambda_{\\text{EDG}} t}$。\n\n**2. 条件概率计算 ($P_i$)：**\n- **$P_{\\text{LOCA}}$**：LOCA 后的堆芯损伤需要高压安注（HPI）和低压安注（LPI）系统同时失效。假设独立性，这是一个与门：\n$$\nP_{\\text{LOCA}} = p_{\\text{HPI}} \\cdot p_{\\text{LPI}}\n$$\n- **$P_{\\text{ATWS}}$**：ATWS 后的堆芯损伤需要辅助给水（AFW）和 LPI 系统同时失效。这也是一个与门：\n$$\nP_{\\text{ATWS}} = p_{\\text{AFW}} \\cdot p_{\\text{LPI}}\n$$\n- **$P_{\\text{SBO}}$**：SBO 后的堆芯损伤发生在应急电源系统失效时。该系统由 $n$ 台 EDG 组成，至少需要 $k$ 台成功运行。如果成功运行的 EDG 少于 $k$ 台，则发生失效。设 $S$ 为成功运行的 EDG 数量。单台 EDG 成功运行的概率是 $(1-q)$。假设独立失效，$S$ 服从二项分布，$S \\sim \\text{Binomial}(n, 1-q)$。系统失效的概率是 $P(S  k) = P(S \\le k-1)$，即二项分布的累积分布函数（CDF）：\n$$\nP_{\\text{SBO}} = \\sum_{s=0}^{k-1} \\binom{n}{s} (1-q)^s q^{n-s}\n$$\n\n**蒙特卡罗模拟算法**\n\n对每个测试用例，模拟按以下步骤进行：\n1.  **初始化**：为保证可复现性，设置一个固定的随机数生成器种子。初始化一个空列表，用于存储每次实现计算出的 CDF 值。\n2.  **向量化抽样**：对于总共 $N$ 次蒙特卡罗样本，同时为每个不确定参数生成 $N$ 个随机变量。这在计算上是高效的。\n    -   从它们的贝塔分布中为 $p_{\\text{HPI}}, p_{\\text{LPI}}, p_{\\text{AFW}}$ 生成一个包含 $N$ 个样本的数组。\n    -   从其对数正态分布中为 $\\lambda_{\\text{EDG}}$ 生成一个包含 $N$ 个样本的数组。\n    -   从它们的对数正态分布中为 $f_{\\text{LOCA}}, f_{\\text{SBO}}, f_{\\text{ATWS}}$ 生成包含 $N$ 个样本的数组。\n3.  **向量化计算**：对这些数组执行算术运算，以一次性计算所有 $N$ 次实现的 CDF。\n    -   计算 $q$ 值的数组：$q_{\\text{samples}} = 1 - \\exp(-\\lambda_{\\text{EDG\\_samples}} \\cdot t)$。\n    -   使用二项累积分布函数为 $q_{\\text{samples}}$ 中的每个元素计算 $P_{\\text{SBO}}$ 值的数组。\n    -   计算 $P_{\\text{LOCA}}$ 和 $P_{\\text{ATWS}}$ 的数组。\n    -   将这些组合起来，得到最终包含 $N$ 个 CDF 样本的数组：$\\text{CDF}_{\\text{samples}} = (f_{\\text{LOCA}} \\cdot P_{\\text{LOCA}} + f_{\\text{SBO}} \\cdot P_{\\text{SBO}} + f_{\\text{ATWS}} \\cdot P_{\\text{ATWS}})_{\\text{samples}}$。\n4.  **统计分析**：\n    -   计算 $\\text{CDF}_{\\text{samples}}$ 数组的经验均值。\n    -   计算可信区间。对于可信水平 $c$，下限和上限分别是对应于概率 $p_L = (1-c)/2$ 和 $p_U = 1 - (1-c)/2$ 的经验分位数。\n5.  **输出格式化**：存储该测试用例的结果三元组 [均值, 下限, 上限]。对所有四个用例重复此过程，并按指定格式化最终输出。\n\n这种向量化方法利用了像 `NumPy` 和 `SciPy` 这样的数值库来实现高性能，这对于高效运行数万次模拟至关重要。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binom\n\ndef solve():\n    \"\"\"\n    Main function to run the Monte Carlo simulation for all specified test cases\n    and print the results in the required format.\n    \"\"\"\n    # A fixed random seed is used for reproducibility of the Monte Carlo simulation.\n    RANDOM_SEED = 42\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1: moderate uncertainties, baseline architecture\n        {\n            \"N\": 20000, \"c\": 0.95, \"t\": 8.0, \"edg_n\": 2, \"edg_k\": 1,\n            \"beta_hpi\": (10, 190), \"beta_lpi\": (8, 192), \"beta_afw\": (12, 288),\n            \"lognorm_edg_rate\": (np.log(0.01), 0.5),\n            \"lognorm_loca_freq\": (np.log(1e-3), 0.5),\n            \"lognorm_sbo_freq\": (np.log(5e-4), 0.6),\n            \"lognorm_atws_freq\": (np.log(1e-4), 0.7),\n        },\n        # Test Case 2: low uncertainty, shorter mission time\n        {\n            \"N\": 10000, \"c\": 0.90, \"t\": 4.0, \"edg_n\": 2, \"edg_k\": 1,\n            \"beta_hpi\": (100, 1900), \"beta_lpi\": (120, 2880), \"beta_afw\": (150, 3675),\n            \"lognorm_edg_rate\": (np.log(0.01), 0.2),\n            \"lognorm_loca_freq\": (np.log(8e-4), 0.3),\n            \"lognorm_sbo_freq\": (np.log(3e-4), 0.4),\n            \"lognorm_atws_freq\": (np.log(2e-4), 0.35),\n        },\n        # Test Case 3: heavy-tailed uncertainties, long mission time\n        {\n            \"N\": 15000, \"c\": 0.95, \"t\": 24.0, \"edg_n\": 2, \"edg_k\": 1,\n            \"beta_hpi\": (2, 38), \"beta_lpi\": (2, 48), \"beta_afw\": (3, 72),\n            \"lognorm_edg_rate\": (np.log(0.02), 0.8),\n            \"lognorm_loca_freq\": (np.log(5e-4), 1.0),\n            \"lognorm_sbo_freq\": (np.log(8e-4), 1.1),\n            \"lognorm_atws_freq\": (np.log(1.5e-4), 1.2),\n        },\n        # Test Case 4: redundancy architecture variation, multiple generators required\n        {\n            \"N\": 12000, \"c\": 0.95, \"t\": 12.0, \"edg_n\": 3, \"edg_k\": 2,\n            \"beta_hpi\": (20, 380), \"beta_lpi\": (16, 384), \"beta_afw\": (25, 600),\n            \"lognorm_edg_rate\": (np.log(0.005), 0.7),\n            \"lognorm_loca_freq\": (np.log(7e-4), 0.6),\n            \"lognorm_sbo_freq\": (np.log(4e-4), 0.6),\n            \"lognorm_atws_freq\": (np.log(1e-4), 0.7),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        \n        # Step 1: Sample all uncertain parameters (vectorized)\n        \n        # Sample on-demand failure probabilities from Beta distributions\n        p_hpi = rng.beta(case[\"beta_hpi\"][0], case[\"beta_hpi\"][1], size=N)\n        p_lpi = rng.beta(case[\"beta_lpi\"][0], case[\"beta_lpi\"][1], size=N)\n        p_afw = rng.beta(case[\"beta_afw\"][0], case[\"beta_afw\"][1], size=N)\n\n        # Sample EDG run failure rate and compute run failure probability q\n        lambda_edg = rng.lognormal(case[\"lognorm_edg_rate\"][0], case[\"lognorm_edg_rate\"][1], size=N)\n        mission_time = case[\"t\"]\n        q_edg = 1 - np.exp(-lambda_edg * mission_time)\n\n        # Sample initiating event frequencies from Lognormal distributions\n        f_loca = rng.lognormal(case[\"lognorm_loca_freq\"][0], case[\"lognorm_loca_freq\"][1], size=N)\n        f_sbo = rng.lognormal(case[\"lognorm_sbo_freq\"][0], case[\"lognorm_sbo_freq\"][1], size=N)\n        f_atws = rng.lognormal(case[\"lognorm_atws_freq\"][0], case[\"lognorm_atws_freq\"][1], size=N)\n        \n        # Step 2: Calculate conditional core damage probabilities (P_i)\n        \n        # P_LOCA = p_HPI * p_LPI (AND gate)\n        P_loca = p_hpi * p_lpi\n        \n        # P_ATWS = p_AFW * p_LPI (AND gate)\n        P_atws = p_afw * p_lpi\n\n        # P_SBO: Binomial probability of fewer than k successes out of n trials.\n        # Success = EDG runs, probability of success = 1 - q_edg\n        n, k = case[\"edg_n\"], case[\"edg_k\"]\n        P_sbo = binom.cdf(k - 1, n, 1 - q_edg)\n\n        # Step 3: Calculate the total CDF for each realization\n        cdf_samples = (f_loca * P_loca) + (f_sbo * P_sbo) + (f_atws * P_atws)\n        \n        # Step 4: Compute summary statistics (mean and credible interval)\n        mean_cdf = np.mean(cdf_samples)\n        \n        c = case[\"c\"]\n        lower_quantile = (1 - c) / 2\n        upper_quantile = 1 - lower_quantile\n        \n        lower_bound = np.quantile(cdf_samples, lower_quantile)\n        upper_bound = np.quantile(cdf_samples, upper_quantile)\n        \n        results.append([mean_cdf, lower_bound, upper_bound])\n\n    # Final print statement in the exact required format.\n    # str() on a list produces '[a, b, c]', which includes spaces.\n    # This is joined by commas, producing '[a, b, c],[d, e, f]'.\n    # This is then wrapped in brackets: '[[a, b, c],[d, e, f]]'.\n    # This matches the desired structure.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}