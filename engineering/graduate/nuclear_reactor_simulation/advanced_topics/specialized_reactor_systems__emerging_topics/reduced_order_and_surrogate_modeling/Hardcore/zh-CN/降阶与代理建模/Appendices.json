{
    "hands_on_practices": [
        {
            "introduction": "构建基于投影的降阶模型的第一步是创建一个高效的基。本征正交分解（POD）提供了一种在最小二乘意义上最优的基，而本次实践的核心任务是根据基向量所含的“能量”来截断这个基 ()。这可以帮助我们理解在模型降维过程中，模型精度与计算效率之间的基本权衡。",
            "id": "4245495",
            "problem": "核反应堆堆芯状态估计器会生成一个空间快照矩阵，该矩阵表示在不同运行工況下，离散空间位置上的状态，例如温度或中子通量。设快照矩阵表示为 $X \\in \\mathbb{R}^{n \\times m}$，其中每一列是在 $n$ 个空间自由度上的一个快照，共有 $m$ 个快照。在降阶建模中，可以使用标准欧几里得内积从均值中心化的快照矩阵中计算出本征正交分解 (POD) 模态。均值中心化、奇异值分解和能量捕获的定义如下。\n\n给定 $X$，定义快照均值为 $\\mu = \\frac{1}{m} X \\mathbf{1}_m \\in \\mathbb{R}^{n}$，其中 $\\mathbf{1}_m$ 是一个 $m$ 维全1向量。构建均值中心化矩阵 $X_c = X - \\mu \\mathbf{1}_m^{\\top}$。在欧几里得内积下计算 $X_c$ 的奇异值分解 (SVD)，即 $X_c = U \\Sigma V^{\\top}$，其中奇异值位于 $\\Sigma$ 的对角线上，表示为 $\\{\\sigma_i\\}_{i=1}^{p}$，其中 $p = \\min(n,m)$ 且按非递增顺序排列。定义总快照能量为 Frobenius 范数的平方 $E_{\\text{tot}} = \\lVert X_c \\rVert_F^2$，并定义前 $r$ 个 POD 模态捕获的能量为 $E_r = \\lVert U_r U_r^{\\top} X_c \\rVert_F^2$，其中 $U_r$ 包含 $U$ 的前 $r$ 列。能量捕获比是无量纲量 $E_r / E_{\\text{tot}}$。\n\n从这些定义出发，推导 $E_r / E_{\\text{tot}}$ 与奇异值 $\\{\\sigma_i\\}$ 之间的关系，并设计一个算法来确定满足能量捕获比 $E_r / E_{\\text{tot}} \\geq 0.99$ 的最小正整数 $r$。如果 $E_{\\text{tot}} = 0$，则定义答案为 $r = 0$。本问题中的所有比率都是无量纲的。\n\n您的任务是实现一个程序，为每个提供的测试用例计算上述定义的最小 $r$ 值。程序不得要求任何用户输入，并且必须按顺序处理以下快照矩阵测试套件：\n\n- 测试用例 1（理想情况，秩一占优，已均值中心化）：\n  $$\n  X_1 = \\begin{bmatrix}\n  -2  -1  0  1  2 \\\\\n  -4  -2  0  2  4 \\\\\n  -6  -3  0  3  6\n  \\end{bmatrix}\n  $$\n- 测试用例 2（两个非零模态，已均值中心化）：\n  $$\n  X_2 = \\begin{bmatrix}\n  -3  -2  -1  1  2  3 \\\\\n  1  -1  1  -1  1  -1 \\\\\n  0  0  0  0  0  0 \\\\\n  0  0  0  0  0  0\n  \\end{bmatrix}\n  $$\n- 测试用例 3（两个等能量模态，已均值中心化）：\n  $$\n  X_3 = \\begin{bmatrix}\n  1  -1  1  -1 \\\\\n  1  1  -1  -1\n  \\end{bmatrix}\n  $$\n- 测试用例 4（边界情况，中心化后能量为零）：\n  $$\n  X_4 = \\begin{bmatrix}\n  5 \\\\\n  -2 \\\\\n  7\n  \\end{bmatrix}\n  $$\n  注意：对于 $X_4$，由于 $m = 1$，均值中心化后得到 $X_c = 0$，因此 $E_{\\text{tot}} = 0$，定义的答案为 $r = 0$。\n\n您的程序应按给定顺序，使用均值中心化快照的 SVD 为每个测试用例计算最小的 $r$。如果 $E_{\\text{tot}} = 0$，则该测试用例返回 $r=0$。否则，找到最小的 $r \\in \\{1,2,\\dots,p\\}$，使得捕获的能量比率至少为 $0.99$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[1,2,3,4]”）。结果必须是分别对应于 $X_1$、$X_2$、$X_3$ 和 $X_4$ 的 $r$ 值的整数。所有能量比率都是无量纲的；输出中不需要任何物理单位。",
            "solution": "该问题被评估为有效。它在科学上基于线性代数和降阶建模的原理，特别是本征正交分解 (POD)。该问题是适定的，具有明确的目标和足够的数据来为每个测试用例找到唯一的解。所有术语都经过了正式定义，前提条件在事实上是正确的且内部一致。\n\n问题的核心是推导出一个用奇异值表示能量捕獲比的表达式，然后利用此关系找到捕获至少 $99\\%$ 总能量所需的最小模态数 $r$。\n\n首先，我们建立总能量 $E_{\\text{tot}}$ 与奇异值 $\\{\\sigma_i\\}$ 之间的关系。总能量是均值中心化快照矩阵 $X_c \\in \\mathbb{R}^{n \\times m}$ 的 Frobenius 范数的平方。\n$$\nE_{\\text{tot}} = \\lVert X_c \\rVert_F^2\n$$\n矩阵的 Frobenius 范数的平方等于 $X_c^{\\top} X_c$ 的迹。使用 $X_c = U \\Sigma V^{\\top}$ 的奇异值分解 (SVD)，其中 $U$ 和 $V$ 是正交矩阵 ($U^{\\top} U = I$, $V^{\\top} V = I$)，我们可以写出：\n$$\nX_c^{\\top} X_c = (U \\Sigma V^{\\top})^{\\top} (U \\Sigma V^{\\top}) = V \\Sigma^{\\top} U^{\\top} U \\Sigma V^{\\top} = V (\\Sigma^{\\top} \\Sigma) V^{\\top}\n$$\n利用迹的循环性质 $\\text{Tr}(ABC) = \\text{Tr}(CAB)$：\n$$\nE_{\\text{tot}} = \\text{Tr}(X_c^{\\top} X_c) = \\text{Tr}(V (\\Sigma^{\\top} \\Sigma) V^{\\top}) = \\text{Tr}(V^{\\top} V (\\Sigma^{\\top} \\Sigma)) = \\text{Tr}(\\Sigma^{\\top} \\Sigma)\n$$\n矩阵 $\\Sigma \\in \\mathbb{R}^{n \\times m}$ 的主对角线上有奇异值 $\\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq \\sigma_p \\geq 0$，其中 $p = \\min(n, m)$。矩阵 $\\Sigma^{\\top} \\Sigma$ 是一个 $m \\times m$ 的对角矩阵，其对角线元素为 $\\{\\sigma_1^2, \\sigma_2^2, \\dots, \\sigma_p^2\\}$，如果 $m > p$，则其余对角线元素为零。迹是这些对角线元素之和。\n$$\nE_{\\text{tot}} = \\sum_{i=1}^{p} \\sigma_i^2\n$$\n接下来，我们推导前 $r$ 个模态捕获的能量 $E_r$ 的表达式。其定义为 $E_r = \\lVert U_r U_r^{\\top} X_c \\rVert_F^2$，其中 $U_r$ 由 $U$ 的前 $r$ 列组成。矩阵 $P_r = U_r U_r^{\\top}$是到由这前 $r$ 个 POD 模态张成的子空间上的正交投影算子。\n$$\nE_r = \\lVert P_r X_c \\rVert_F^2 = \\text{Tr}((P_r X_c)^{\\top} (P_r X_c)) = \\text{Tr}(X_c^{\\top} P_r^{\\top} P_r X_c)\n$$\n由于 $P_r$ 是一个投影算子，它是幂等的 ($P_r^2 = P_r$) 和自伴的 ($P_r^{\\top} = P_r$)。因此，$P_r^{\\top} P_r = P_r$。\n$$\nE_r = \\text{Tr}(X_c^{\\top} P_r X_c)\n$$\n应用迹的循环性质并代入 $X_c = U \\Sigma V^{\\top}$：\n$$\nE_r = \\text{Tr}(P_r X_c X_c^{\\top}) = \\text{Tr}(U_r U_r^{\\top} (U \\Sigma V^{\\top})(U \\Sigma V^{\\top})^{\\top}) = \\text{Tr}(U_r U_r^{\\top} U \\Sigma \\Sigma^{\\top} U^{\\top})\n$$\n再次应用循环性质：\n$$\nE_r = \\text{Tr}(U^{\\top} U_r U_r^{\\top} U (\\Sigma \\Sigma^{\\top}))\n$$\n矩阵乘积 $U^{\\top} U_r U_r^{\\top} U$ 得到一个 $n \\times n$ 的对角矩阵，其前 $r$ 个对角线位置为 $1$，其余位置为 $0$。这是因为 $U^{\\top} U_r$ 是一个 $n \\times r$ 矩阵，其顶部的 $r \\times r$ 块是单位矩阵 $I_r$，其下部的 $(n-r) \\times r$ 块是零矩阵。与它的转置相乘便得到所述的对角结构。该矩阵与对角矩阵 $\\Sigma \\Sigma^{\\top}$ (其对角线元素为 $\\sigma_i^2$) 的乘积的迹，分离出了前 $r$ 个奇异值的平方。\n$$\nE_r = \\sum_{i=1}^{r} \\sigma_i^2\n$$\n最后，能量捕获比由下式给出：\n$$\n\\frac{E_r}{E_{\\text{tot}}} = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{p} \\sigma_i^2}\n$$\n寻找满足此比率至少为 $0.99$ 的最小正整数 $r$ 的算法如下：\n1. 对于给定的快照矩阵 $X$，计算均值快照向量 $\\mu$ 和均值中心化矩阵 $X_c$。\n2. 计算总能量 $E_{\\text{tot}} = \\lVert X_c \\rVert_F^2$。如果 $E_{\\text{tot}}$ 为零（或数值上与零无法区分），则根据问题陈述，$r=0$。\n3. 如果 $E_{\\text{tot}} > 0$，使用 SVD 计算 $X_c$ 的奇异值 $\\{\\sigma_i\\}$。\n4. 总能量可以确认为 $E_{\\text{tot}} = \\sum_{i=1}^p \\sigma_i^2$。\n5. 从 $k=1$ 迭代到 $p$，计算平方奇异值的累积和 $S_k = \\sum_{i=1}^k \\sigma_i^2$。\n6. 在每一步中，检查比率 $S_k / E_{\\text{tot}} \\geq 0.99$ 是否成立。使此不等式成立的第一个 $k$ 值即为所求的最小秩 $r$。\n\n对每个提供的测试用例都实现了此算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_r(X: np.ndarray) -> int:\n    \"\"\"\n    Computes the smallest number of POD modes 'r' to capture at least 99% of the energy.\n\n    Args:\n        X: The snapshot matrix of size (n, m).\n\n    Returns:\n        The smallest integer r.\n    \"\"\"\n    # Defensive check to ensure X is a 2D array\n    X = np.atleast_2d(X)\n    \n    # Get dimensions n (spatial DOFs) and m (number of snapshots)\n    n, m = X.shape\n    \n    # Step 1: Compute the mean snapshot and the mean-centered matrix X_c\n    if m == 1:\n        # If there is only one snapshot, the mean is the snapshot itself\n        mu = X\n        X_c = X - mu  # This results in a zero matrix\n    else:\n        mu = X.mean(axis=1, keepdims=True)\n        X_c = X - mu\n        \n    # Step 2: Check for the zero energy case\n    # The total energy is the squared Frobenius norm of X_c.\n    # We can check if X_c is all zeros, which is more robust than floating point comparison of energy.\n    if not np.any(X_c):\n        return 0\n        \n    # Step 3: Compute the singular values of X_c\n    # We only need the singular values, so we can set compute_uv=False for efficiency\n    s = np.linalg.svd(X_c, compute_uv=False)\n    \n    # Step 4: Calculate the total energy from the squared singular values\n    s_squared = s**2\n    total_energy = np.sum(s_squared)\n    \n    # This check handles cases where energy is numerically very close to zero\n    if total_energy  1e-15:\n        return 0\n\n    # Step 5: Find the smallest r satisfying the energy capture condition\n    # Calculate the cumulative sum of energy captured by the modes\n    cumulative_energy = np.cumsum(s_squared)\n    \n    # Calculate the ratio of captured energy to total energy\n    energy_ratios = cumulative_energy / total_energy\n    \n    # Find the first index where the ratio is = 0.99\n    # np.where returns a tuple of arrays; we need the first element of the first array.\n    # The result is a 0-based index, so we add 1 to get the number of modes r.\n    r = np.where(energy_ratios = 0.99)[0][0] + 1\n    \n    return int(r)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        np.array([\n            [-2.0, -1.0, 0.0, 1.0, 2.0],\n            [-4.0, -2.0, 0.0, 2.0, 4.0],\n            [-6.0, -3.0, 0.0, 3.0, 6.0]\n        ]),\n        # Test case 2\n        np.array([\n            [-3.0, -2.0, -1.0, 1.0, 2.0, 3.0],\n            [1.0, -1.0, 1.0, -1.0, 1.0, -1.0],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        ]),\n        # Test case 3\n        np.array([\n            [1.0, -1.0, 1.0, -1.0],\n            [1.0, 1.0, -1.0, -1.0]\n        ]),\n        # Test case 4 (must be a column vector, shape (3,1))\n        np.array([\n            [5.0],\n            [-2.0],\n            [7.0]\n        ])\n    ]\n\n    results = []\n    for case in test_cases:\n        r = compute_r(case)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在选择了一个最优基之后，下一步自然是利用这个基来构建一个可预测的降阶模型。本次实践将演示伽辽金投影法，将控制物理过程的中子扩散方程投影到我们通过POD获得的基上 ()。通过这种方法，复杂的偏微分方程可以转化为一个小型、易于求解的代数方程组，这正是基于投影的降阶模型的核心所在。",
            "id": "4245475",
            "problem": "考虑在矩形组件域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上的稳态二维中子扩散模型，其具有均匀诺伊曼边界条件 (homogeneous Neumann boundary conditions)。该无量纲化模型基于稳态中子平衡和菲克定律 (Fick's law)，得到扩散方程 $-\\nabla \\cdot (D(x,y) \\nabla \\phi(x,y)) + \\Sigma_a(x,y)\\,\\phi(x,y) = q(x,y)$，其中 $D(x,y)$ 是扩散系数，$\\Sigma_a(x,y)$ 是吸收截面，而 $q(x,y)$ 是一个源项。在降阶建模中，将算子通过伽辽金投影 (Galerkin projection) 到由一组基函数 $\\{\\varphi_i\\}_{i=1}^r$ 张成的子空间上，会得到一个降阶算子，其矩阵元由双线性形式 $a(\\varphi_i,\\varphi_j) = \\int_{\\Omega} D\\,\\nabla \\varphi_i \\cdot \\nabla \\varphi_j\\,\\mathrm{d}x\\,\\mathrm{d}y + \\int_{\\Omega} \\Sigma_a\\, \\varphi_i\\,\\varphi_j\\,\\mathrm{d}x\\,\\mathrm{d}y$ 给出。基函数 $\\{\\varphi_i\\}_{i=1}^r$ 是通过使用一组快照场 $\\{u^{(k)}(x,y)\\}_{k=1}^m$ 进行本征正交分解 (Proper Orthogonal Decomposition, POD) 获得的。对于具有 $N_x \\times N_y$ 个单元中心、单元间距 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$ 以及单元面积 $h_x h_y$ 的均匀网格离散化，设离散内积为 $(u,v)_W = \\sum_{i=1}^{N_y} \\sum_{j=1}^{N_x} u_{i,j} v_{i,j}\\, h_x h_y$。使用加权奇异值分解 (weighted singular value decomposition) 形成一个关于 $(\\cdot,\\cdot)_W$ 正交的 POD 基，即 $\\Phi = W^{-1/2} U_r$，其中 $U_r$ 是 $Y = W^{1/2} X$ 的前 $r$ 个左奇异向量，$X$ 是快照矩阵（每列是一个扁平化的快照场），$W^{1/2}$ 表示每个网格单元乘以 $\\sqrt{h_x h_y}$。使用单元中心值，通过离散求积 $\\sum_{i=1}^{N_y} \\sum_{j=1}^{N_x} (\\cdot)\\, h_x h_y$ 来近似定义 $a(\\varphi_i,\\varphi_j)$ 的积分。通过有限差分近似每个基场 $\\varphi_\\ell$ 的空间梯度：对于内部索引，使用中心差分公式 $\\partial_x \\varphi_\\ell|_{i,j} \\approx (\\varphi_{\\ell,i,j+1} - \\varphi_{\\ell,i,j-1})/(2 h_x)$ 和 $\\partial_y \\varphi_\\ell|_{i,j} \\approx (\\varphi_{\\ell,i+1,j} - \\varphi_{\\ell,i-1,j})/(2 h_y)$；在边界上，使用单边差分 $\\partial_x \\varphi_\\ell|_{i,0} \\approx (\\varphi_{\\ell,i,1} - \\varphi_{\\ell,i,0})/h_x$，$\\partial_x \\varphi_\\ell|_{i,N_x-1} \\approx (\\varphi_{\\ell,i,N_x-1} - \\varphi_{\\ell,i,N_x-2})/h_x$，对于 $i=0$ 和 $i=N_y-1$ 处的 $\\partial_y$ 也类似处理。根据这些定义，针对给定的 POD 基阶数 $r$，计算降阶算子矩阵元 $A_{p,q} = a(\\varphi_p,\\varphi_q)$。\n\n所有量均为无量纲；报告数值结果时不带物理单位。不出现角度。不出现百分比。\n\n您的程序必须构建和评估三个测试用例，每个用例定义 $(L_x,L_y)$、$(N_x,N_y)$、非均匀的 $D(x,y)$ 和 $\\Sigma_a(x,y)$、快照集以及 POD 阶数 $r$。对于每个测试用例，将降阶算子矩阵元按行主序（row-major order）扁平化为一个浮点数列表返回。将所有测试用例的结果汇总到单行输出中，其格式在本问题陈述的末尾描述。\n\n测试套件：\n\n- 测试用例 1 (典型的非均匀内部包含物)：\n  - 几何：$L_x = 1$, $L_y = 1$, $N_x = 16$, $N_y = 16$，单元中心网格。\n  - 扩散：当 $|x - 0.5| \\le 0.1$ 且 $|y - 0.5| \\le 0.1$ 时，$D(x,y) = 3$，否则 $D(x,y) = 1$。\n  - 吸收：当 $x \\ge 0.5$ 且 $y \\ge 0.5$ 时，$\\Sigma_a(x,y) = 0.4$，否则 $\\Sigma_a(x,y) = 0.1$。\n  - 快照 ($m = 5$)，在单元中心 $(x_j,y_i)$ 的网格上求值，其中 $x_j = (j+0.5) h_x$，$y_i = (i+0.5) h_y$。定义 $x' = x/L_x$, $y' = y/L_y$ 并令\n    - $u^{(1)}(x,y) = \\cos(\\pi x') \\cos(\\pi y')$,\n    - $u^{(2)}(x,y) = \\cos(2\\pi x') \\cos(\\pi y')$,\n    - $u^{(3)}(x,y) = \\sin(\\pi x') \\sin(2\\pi y')$,\n    - $u^{(4)}(x,y) = \\exp(-50[(x-0.5)^2 + (y-0.7)^2])$,\n    - $u^{(5)}(x,y) = \\exp(-40[(x-0.25)^2 + (y-0.25)^2])$.\n  - POD 阶数：$r = 3$。\n\n- 测试用例 2 (近均匀介质，边界情况 $r=1$)：\n  - 几何：$L_x = 1$, $L_y = 0.5$, $N_x = 8$, $N_y = 8$。\n  - 扩散：$D(x,y) = 1$。\n  - 吸收：$\\Sigma_a(x,y) = 0.2$。\n  - 快照 ($m = 3$)，其中 $x' = x/L_x$, $y' = y/L_y$：\n    - $u^{(1)}(x,y) = 1$,\n    - $u^{(2)}(x,y) = \\cos(\\pi x')$,\n    - $u^{(3)}(x,y) = \\cos(\\pi y')$.\n  - POD 阶数：$r = 1$。\n\n- 测试用例 3 (强非均匀包含物和条带，更高的 $r$)：\n  - 几何：$L_x = 1.2$, $L_y = 0.8$, $N_x = 20$, $N_y = 12$。\n  - 扩散：$D(x,y) = 0.8 + 2.5 \\exp\\left(-\\left[\\frac{(x - 0.7 L_x)^2}{(0.15 L_x)^2} + \\frac{(y - 0.4 L_y)^2}{(0.12 L_y)^2}\\right]\\right) + 0.6\\,\\mathbf{1}_{|x - 0.3 L_x| \\le 0.08 L_x}$，其中 $\\mathbf{1}$ 是指示函数，当条件成立时等于 $1$，否则等于 $0$。\n  - 吸收：$\\Sigma_a(x,y) = 0.15 + 0.35 \\exp\\left(-\\left[\\frac{(x - 0.3 L_x)^2}{(0.18 L_x)^2} + \\frac{(y - 0.6 L_y)^2}{(0.15 L_y)^2}\\right]\\right) + 0.1\\,\\mathbf{1}_{|x - 0.6 L_x| \\le 0.1 L_x}$。\n  - 快照 ($m = 6$)，其中 $x' = x/L_x$, $y' = y/L_y$：\n    - $u^{(1)}(x,y) = \\cos(\\pi x') \\cos(\\pi y')$,\n    - $u^{(2)}(x,y) = \\cos(2\\pi x') \\cos(2\\pi y')$,\n    - $u^{(3)}(x,y) = \\sin(2\\pi x') \\cos(\\pi y')$,\n    - $u^{(4)}(x,y) = \\exp(-30[(x-0.5 L_x)^2 + (y-0.25 L_y)^2])$,\n    - $u^{(5)}(x,y) = \\exp(-25[(x-0.9 L_x)^2 + (y-0.6 L_y)^2])$,\n    - $u^{(6)}(x,y) = \\sin(\\pi x') \\sin(2\\pi y')$.\n  - POD 阶数：$r = 4$。\n\n实现要求：\n- 为每个测试用例构建网格，并在单元中心 $(x_j,y_i)$ 处计算 $D(x,y)$、$\\Sigma_a(x,y)$ 和快照场。\n- 通过按行主序扁平化每个快照场来构建快照矩阵 $X \\in \\mathbb{R}^{(N_x N_y) \\times m}$。\n- 使用每个单元权重为 $(h_x h_y)$ 的 $L^2$ 内积进行加权奇异值分解：通过将每行乘以 $\\sqrt{h_x h_y}$ 来计算 $Y = W^{1/2} X$，然后计算 $Y$ 的前 $r$ 个左奇异向量 $U_r$，并设置 POD 基矩阵 $\\Phi = W^{-1/2} U_r$，其中 $W^{-1/2}$ 将每行除以 $\\sqrt{h_x h_y}$。将 $\\Phi$ 的每一列重塑回 $N_y \\times N_x$ 的网格，以获得基场 $\\varphi_\\ell(x,y)$。\n- 通过指定的有限差分近似 $\\nabla \\varphi_\\ell$，并使用离散求积 $\\sum_{i,j} h_x h_y \\left( D\\, \\nabla \\varphi_p \\cdot \\nabla \\varphi_q + \\Sigma_a\\, \\varphi_p \\varphi_q \\right)$ 形成降阶算子矩阵元 $A_{p,q}$。\n- 对于每个测试用例，将扁平化的降阶算子矩阵元按行主序输出为浮点数列表。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应测试用例的按行主序扁平化的降阶算子矩阵元列表。例如，格式必须完全像 $[\\text{list\\_for\\_case\\_1},\\text{list\\_for\\_case\\_2},\\text{list\\_for\\_case\\_3}]$，不得有任何额外文本。每个内部列表必须包含 $r \\times r$ 个浮点数。",
            "solution": "该问题是有效的，因为它在核反应堆物理模拟的降阶建模领域提出了一个适定的、有科学依据的计算任务。所有必要的数据和程序步骤均已提供。\n\n目标是计算降阶系统算子 $A_{p,q}$ 的矩阵元，该算子是通过将稳态中子扩散算子进行伽辽金投影 (Galerkin projection) 到一个低维子空间上得到的。该子空间由一组通过本征正交分解 (Proper Orthogonal Decomposition, POD) 导出的基函数 $\\{\\varphi_i\\}_{i=1}^r$ 张成。该分析针对三个不同的测试用例进行。\n\n在域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上，中子通量 $\\phi(x,y)$ 的控制方程是二维稳态中子扩散方程：\n$$-\\nabla \\cdot (D(x,y) \\nabla \\phi(x,y)) + \\Sigma_a(x,y)\\,\\phi(x,y) = q(x,y)$$\n其中 $D$ 是扩散系数，$\\Sigma_a$ 是宏观吸收截面，$q$ 是中子源项。在均匀诺伊曼边界条件下，相关的弱形式涉及对称双线性形式 $a(u,v)$:\n$$a(u,v) = \\int_{\\Omega} D(x,y)\\,\\nabla u \\cdot \\nabla v\\,\\mathrm{d}x\\,\\mathrm{d}y + \\int_{\\Omega} \\Sigma_a(x,y)\\, u\\,v\\,\\mathrm{d}x\\,\\mathrm{d}y$$\n在伽辽金方法 (Galerkin method) 中，解被近似为基函数的线性组合，$\\phi(x,y) \\approx \\sum_{i=1}^r c_i \\varphi_i(x,y)$。将弱形式投影到基 $\\{\\varphi_j\\}_{j=1}^r$ 上，得到一个降阶线性系统 $A c = f$，其中降阶算子 $A$ 的矩阵元由 $A_{p,q} = a(\\varphi_p,\\varphi_q)$ 给出。\n\n确定每个测试用例的矩阵 $A$ 的计算过程如下：\n\n1.  **离散化**：将连续域 $\\Omega$ 离散化为 $N_y \\times N_x$ 个单元的均匀网格。单元中心位于 $(x_j, y_i)$，其中对于 $j \\in \\{0, \\dots, N_x-1\\}$，$x_j = (j+0.5)h_x$；对于 $i \\in \\{0, \\dots, N_y-1\\}$，$y_i = (i+0.5)h_y$。单元尺寸为 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$。材料属性 $D(x,y)$ 和 $\\Sigma_a(x,y)$ 在这些单元中心进行求值。\n\n2.  **快照收集**：在离散网格上对一组 $m$ 个快照场 $\\{u^{(k)}(x,y)\\}_{k=1}^m$ 进行求值，这些快照场代表系统的特征状态。每个快照被扁平化为一个长度为 $N = N_x N_y$ 的向量。这些向量被组装成快照矩阵 $X \\in \\mathbb{R}^{N \\times m}$ 的列。\n\n3.  **POD 基构建**：使用加权奇异值分解 (Singular Value Decomposition, SVD) 构建一个关于离散 $L^2$ 内积 $(u,v)_W = \\sum_{k=1}^N u_k v_k (h_x h_y)$ 正交的基。\n    -   离散内积可以写成矩阵形式 $(u,v)_W = u^T W v$，其中 $W$ 是一个对角矩阵，其对角线上的元素是单元面积 $dA = h_x h_y$。由于网格是均匀的，所以 $W = (h_x h_y) I$。\n    -   形成加权快照矩阵 $Y = W^{1/2} X = \\sqrt{h_x h_y} X$。\n    -   计算 $Y$ 的 SVD：$Y = U S V^T$。$U$ 的列是左奇异向量。\n    -   选取 $U$ 的前 $r$ 列形成 $U_r \\in \\mathbb{R}^{N \\times r}$。\n    -   POD 基向量（作为矩阵 $\\Phi$ 的列）通过对 $U_r$ 去加权得到：$\\Phi = W^{-1/2} U_r = (1/\\sqrt{h_x h_y}) U_r$。$\\Phi$ 的列，记为 $\\vec{\\varphi}_p$，是基函数 $\\varphi_p$ 的扁平化表示。根据构造，这些基向量关于 $(\\cdot, \\cdot)_W$ 内积是正交的：$(\\vec{\\varphi}_p, \\vec{\\varphi}_q)_W = \\delta_{pq}$。\n\n4.  **梯度计算**：为了计算双线性形式，需要基函数 $\\nabla \\varphi_p$ 的梯度。每个基向量 $\\vec{\\varphi}_p$ 被重塑为 $N_y \\times N_x$ 的网格。然后使用指定的有限差分公式在每个网格单元 $(i,j)$ 处近似偏导数 $\\partial_x \\varphi_p$ 和 $\\partial_y \\varphi_p$：\n    -   **内部点**：二阶中心差分。\n        $$ \\frac{\\partial \\varphi_p}{\\partial x}\\bigg|_{i,j} \\approx \\frac{\\varphi_{p,i,j+1} - \\varphi_{p,i,j-1}}{2 h_x}, \\quad \\frac{\\partial \\varphi_p}{\\partial y}\\bigg|_{i,j} \\approx \\frac{\\varphi_{p,i+1,j} - \\varphi_{p,i-1,j}}{2 h_y} $$\n    -   **边界点**：一阶单边差分。例如，在边界 $j=0$ 处：\n        $$ \\frac{\\partial \\varphi_p}{\\partial x}\\bigg|_{i,0} \\approx \\frac{\\varphi_{p,i,1} - \\varphi_{p,i,0}}{h_x} $$\n        类似公式适用于其他边界（$j=N_x-1$, $i=0$, $i=N_y-1$）。\n\n5.  **降阶算子组装**：通过在网格单元上使用数值求积来近似双线性形式 $a(\\varphi_p, \\varphi_q)$ 中的积分，从而计算 $r \\times r$ 降阶算子的矩阵元 $A_{p,q}$：\n    $$ A_{p,q} = \\sum_{i=0}^{N_y-1} \\sum_{j=0}^{N_x-1} \\left[ D_{i,j} \\left( \\frac{\\partial \\varphi_p}{\\partial x}\\frac{\\partial \\varphi_q}{\\partial x} + \\frac{\\partial \\varphi_p}{\\partial y}\\frac{\\partial \\varphi_q}{\\partial y} \\right)_{i,j} + (\\Sigma_a)_{i,j} (\\varphi_p)_{i,j} (\\varphi_q)_{i,j} \\right] (h_x h_y) $$\n    对所有 $p,q \\in \\{0, \\dots, r-1\\}$ 的对 $(p,q)$ 执行此计算。然后将得到的矩阵 $A$ 按行主序扁平化为一个列表。对所提供的三个测试用例中的每一个都重复此整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for all test cases.\n    \"\"\"\n\n    # Test Case 1: Heterogeneous interior inclusion\n    case1_params = {\n        'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16, 'r': 3,\n        'D_func': lambda x, y, Lx, Ly: 3.0 if np.abs(x - 0.5) = 0.1 and np.abs(y - 0.5) = 0.1 else 1.0,\n        'Sigma_a_func': lambda x, y, Lx, Ly: 0.4 if x = 0.5 and y = 0.5 else 0.1,\n        'snapshots': [\n            lambda x, y, Lx, Ly: np.cos(np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.cos(2 * np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.sin(np.pi * x/Lx) * np.sin(2 * np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.exp(-50 * ((x - 0.5)**2 + (y - 0.7)**2)),\n            lambda x, y, Lx, Ly: np.exp(-40 * ((x - 0.25)**2 + (y - 0.25)**2))\n        ]\n    }\n\n    # Test Case 2: Near-homogeneous medium\n    case2_params = {\n        'Lx': 1.0, 'Ly': 0.5, 'Nx': 8, 'Ny': 8, 'r': 1,\n        'D_func': lambda x, y, Lx, Ly: 1.0,\n        'Sigma_a_func': lambda x, y, Lx, Ly: 0.2,\n        'snapshots': [\n            lambda x, y, Lx, Ly: 1.0,\n            lambda x, y, Lx, Ly: np.cos(np.pi * x/Lx),\n            lambda x, y, Lx, Ly: np.cos(np.pi * y/Ly)\n        ]\n    }\n\n    # Test Case 3: Strongly heterogeneous inclusion and stripe\n    case3_params = {\n        'Lx': 1.2, 'Ly': 0.8, 'Nx': 20, 'Ny': 12, 'r': 4,\n        'D_func': lambda x, y, Lx, Ly: 0.8 + 2.5 * np.exp(-(((x-0.7*Lx)/(0.15*Lx))**2 + ((y-0.4*Ly)/(0.12*Ly))**2)) \\\n                                        + 0.6 * (np.abs(x - 0.3*Lx) = 0.08*Lx),\n        'Sigma_a_func': lambda x, y, Lx, Ly: 0.15 + 0.35 * np.exp(-(((x-0.3*Lx)/(0.18*Lx))**2 + ((y-0.6*Ly)/(0.15*Ly))**2)) \\\n                                          + 0.1 * (np.abs(x - 0.6*Lx) = 0.1*Lx),\n        'snapshots': [\n            lambda x, y, Lx, Ly: np.cos(np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.cos(2*np.pi * x/Lx) * np.cos(2*np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.sin(2*np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.exp(-30 * ((x-0.5*Lx)**2 + (y-0.25*Ly)**2)),\n            lambda x, y, Lx, Ly: np.exp(-25 * ((x-0.9*Lx)**2 + (y-0.6*Ly)**2)),\n            lambda x, y, Lx, Ly: np.sin(np.pi * x/Lx) * np.sin(2*np.pi * y/Ly)\n        ]\n    }\n\n    test_cases = [case1_params, case2_params, case3_params]\n    results = [process_case(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_gradient(phi, hx, hy):\n    \"\"\"\n    Computes the gradient of a field on the grid using specified finite differences.\n    \"\"\"\n    Ny, Nx = phi.shape\n    grad_x = np.zeros_like(phi)\n    grad_y = np.zeros_like(phi)\n\n    # x-gradient\n    grad_x[:, 1:-1] = (phi[:, 2:] - phi[:, :-2]) / (2 * hx)\n    grad_x[:, 0] = (phi[:, 1] - phi[:, 0]) / hx\n    grad_x[:, -1] = (phi[:, -1] - phi[:, -2]) / hx\n\n    # y-gradient\n    grad_y[1:-1, :] = (phi[2:, :] - phi[:-2, :]) / (2 * hy)\n    grad_y[0, :] = (phi[1, :] - phi[0, :]) / hy\n    grad_y[-1, :] = (phi[-1, :] - phi[-2, :]) / hy\n    \n    return grad_x, grad_y\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case to compute the reduced operator.\n    \"\"\"\n    Lx, Ly = params['Lx'], params['Ly']\n    Nx, Ny = params['Nx'], params['Ny']\n    r = params['r']\n    \n    hx, hy = Lx / Nx, Ly / Ny\n    dA = hx * hy\n    w_sqrt = np.sqrt(dA)\n\n    # 1. Grid and Parameters Setup\n    x = (np.arange(Nx) + 0.5) * hx\n    y = (np.arange(Ny) + 0.5) * hy\n    xx, yy = np.meshgrid(x, y)\n\n    D_grid = np.vectorize(params['D_func'])(xx, yy, Lx, Ly)\n    Sigma_a_grid = np.vectorize(params['Sigma_a_func'])(xx, yy, Lx, Ly)\n\n    # 2. Snapshot Generation\n    m = len(params['snapshots'])\n    snapshot_matrix_X = np.zeros((Nx * Ny, m))\n    for k, u_func in enumerate(params['snapshots']):\n        snapshot_grid = np.vectorize(u_func)(xx, yy, Lx, Ly)\n        snapshot_matrix_X[:, k] = snapshot_grid.flatten()\n\n    # 3. POD Basis Construction\n    Y = w_sqrt * snapshot_matrix_X\n    U, s, vh = svd(Y, full_matrices=False)\n    \n    Ur = U[:, :r]\n    Phi_matrix = (1.0 / w_sqrt) * Ur\n\n    # 4. Reduced Operator Assembly\n    A = np.zeros((r, r))\n    phi_basis_grids = [Phi_matrix[:, p].reshape(Ny, Nx) for p in range(r)]\n    phi_grads = [get_gradient(phi_p, hx, hy) for phi_p in phi_basis_grids]\n\n    for p in range(r):\n        for q in range(r):\n            phi_p_grid = phi_basis_grids[p]\n            phi_q_grid = phi_basis_grids[q]\n\n            grad_x_p, grad_y_p = phi_grads[p]\n            grad_x_q, grad_y_q = phi_grads[q]\n\n            # Stiffness term integrand: D * (grad(p) . grad(q))\n            stiffness_integrand = D_grid * (grad_x_p * grad_x_q + grad_y_p * grad_y_q)\n            \n            # Mass term integrand: Sigma_a * p * q\n            mass_integrand = Sigma_a_grid * phi_p_grid * phi_q_grid\n\n            # Numerical quadrature\n            A[p, q] = np.sum(stiffness_integrand + mass_integrand) * dA\n            \n    return A.flatten().tolist()\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "除了基于投影的降阶模型，另一大类强大的代理模型是非侵入式或数据驱动模型。本次实践将探索这类模型中的高斯过程（GP）方法，它将高保真模型视为一个“黑箱”进行建模 ()。本练习不仅将构建一个高斯过程模型，还将引入交叉验证这一关键实践，以评估模型对未见数据的泛化能力，这是确保代理模型可靠性的重要步骤。",
            "id": "4245522",
            "problem": "您的任务是构建和评估一个高斯过程（GP）代理模型，用于模拟核反应堆堆芯中控制棒的反应性价值随插入深度和燃料温度的变化。目标是使用留一法（LOO）交叉验证来评估其泛化能力。所有数学对象，包括数字，都必须用 LaTeX 书写。感兴趣的反应堆物理量是控制棒价值，以“per cent mille”（pcm）为单位表示，定义为控制棒移动引起的反应性变化，其中 $1\\ \\text{pcm} = 10^{-5}$ 反应性单位。\n\n起点和假设：\n- 代理模型是一个高斯过程（GP），使用带自动相关性确定（ARD）的平方指数核。输入是一个二维向量 $\\mathbf{x} = [u, T]$，其中 $u$ 是控制棒插入份额（无量纲，介于 $0$ 和 $1$ 之间），$T$ 是以开尔文为单位的燃料温度。\n- 观测值遵循 $y_i = f(\\mathbf{x}_i) + \\epsilon_i$，其中 $\\epsilon_i$ 是方差为 $\\sigma_n^2$ 的独立高斯测量噪声，$f(\\cdot)$ 是由 GP 先验建模的潜函数。\n- 核函数为 $k(\\mathbf{x}, \\mathbf{x}') = \\sigma_f^2 \\exp\\left(-\\dfrac{1}{2}\\left(\\dfrac{(u-u')^2}{\\ell_u^2} + \\dfrac{(T-T')^2}{\\ell_T^2}\\right)\\right)$，其中 $\\sigma_f$ 是信号振幅（单位为 pcm），$\\ell_u$ 和 $\\ell_T$ 分别是 $u$（无量纲）和 $T$（开尔文）的特征长度尺度。\n\n训练数据构建：\n- 使用输入网格，插入份额 $u \\in \\{0.0, 0.5, 1.0\\}$，温度 $T \\in \\{560,\\ 590,\\ 620\\}\\ \\text{K}$，按 $u$ 升序、然后在每个 $u$ 内部按 $T$ 升序进行字典序排序。这将产生 $9$ 个输入 $\\{\\mathbf{x}_i\\}_{i=0}^{8}$。\n- 基于物理知识的潜函数 $w_{\\text{true}}(u, T)$ 为\n$$\nw_{\\text{true}}(u, T) = W_{\\max} \\left(1 - e^{-c u}\\right) \\left(1 - a\\,(T - T_{\\text{ref}})\\right) + b\\,u\\,(T - T_{\\text{ref}}),\n$$\n其中常数为 $W_{\\max} = 7000\\ \\text{pcm}$，$c = 3.5$，$a = 5 \\times 10^{-4}\\ \\text{K}^{-1}$，$T_{\\text{ref}} = 590\\ \\text{K}$，$b = -6\\ \\text{pcm/K}$。该函数形式编码了以下物理现象：更深的插入会非线性地增加棒价值，而升高的温度由于多普勒展宽效应会降低棒价值，同时存在一个弱的交叉效应。\n- 添加确定性伪噪声以形成观测到的训练目标：\n$$\ny_i = w_{\\text{true}}(u_i, T_i) + \\eta_i,\\quad \\text{其中}\\quad \\eta_i = A_{\\text{noise}} \\sin(0.7\\, i)\\ \\text{pcm},\n$$\n对于遵循上述排序的索引 $i \\in \\{0,1,\\dots,8\\}$。参数 $A_{\\text{noise}}$ 控制噪声振幅。\n\n建模与评估任务：\n- 对于每个指定的测试用例，构建协方差矩阵 $\\mathbf{K}$，其元素为 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j) + \\sigma_n^2 \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克 δ。利用 GP 后验和多变量高斯分布的性质，计算每个训练输入点上的留一法（LOO）预测均值，而无需重新拟合 $9$ 个独立的模型，然后通过将这些预测值与观测值 $y_i$ 进行比较来计算 LOO 误差。\n- 对于每个测试用例，评估 LOO 预测的均方根误差（RMSE），\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(\\widehat{y}_i^{\\text{LOO}} - y_i\\right)^2},\n$$\n其中 $N = 9$。以 pcm 为单位表示 RMSE。\n\n测试套件：\n- 使用以下三个测试用例，每个用例指定为一个元组 $(\\sigma_f, \\ell_u, \\ell_T, \\sigma_n, A_{\\text{noise}})$ 并注明单位：\n    1. 用例 A（一般中等噪声场景）：$(3000,\\ 0.35,\\ 25.0,\\ 50.0,\\ 20.0)$，其中 $\\sigma_f$ 单位为 pcm，$\\ell_u$ 无量纲，$\\ell_T$ 单位为开尔文，$\\sigma_n$ 单位为 pcm，$A_{\\text{noise}}$ 单位为 pcm。\n    2. 用例 B（边界条件，无噪声观测）：$(3000,\\ 0.35,\\ 25.0,\\ 10^{-6},\\ 0.0)$，用于模拟可忽略的测量噪声，同时保持数值稳定性。\n    3. 用例 C（边缘情况，长度尺度不匹配）：$(1500,\\ 0.05,\\ 200.0,\\ 50.0,\\ 20.0)$，代表对 $u$ 的过高敏感性和对 $T$ 的过度平滑。\n\n要求输出：\n- 您的程序应生成一行输出，其中包含三个测试用例的 LOO RMSE，格式为逗号分隔的列表，并用方括号括起，顺序为用例 A、用例 B、用例 C，例如 $[\\text{rmse}_A,\\text{rmse}_B,\\text{rmse}_C]$。\n- 数值必须表示为以 pcm 为单位的浮点数 RMSE。\n\n角度单位不适用。所有物理单位均已指定。不应读取任何外部数据；所有计算必须在程序内部完成。",
            "solution": "该问题要求为一个核反应堆物理量构建和评估一个高斯过程（GP）代理模型。评估将使用留一法（LOO）交叉验证进行。最终输出是针对三组不同模型超参数的 LOO 预测的均方根误差（RMSE）。解决方案的步骤是：首先生成训练数据，然后构建 GP 模型的各个组件，最后应用 LOO-CV 的解析公式来计算 RMSE。\n\n首先，我们建立训练数据集。输入域是二维的，由控制棒插入份额 $u$ 和燃料温度 $T$ 组成。输入向量表示为 $\\mathbf{x} = [u, T]$。问题指定了一个由 $N=9$ 个训练点组成的网格，该网格由 $u \\in \\{0.0, 0.5, 1.0\\}$ 和 $T \\in \\{560, 590, 620\\}\\ \\text{K}$ 的笛卡尔积形成。点 $\\{\\mathbf{x}_i\\}_{i=0}^{8}$ 按字典序排序，其中 $u$ 为主键（升序），$T$ 为次键（升序）。这产生以下训练输入序列：\n$\\mathbf{x}_0 = [0.0, 560]$, $\\mathbf{x}_1 = [0.0, 590]$, $\\mathbf{x}_2 = [0.0, 620]$,\n$\\mathbf{x}_3 = [0.5, 560]$, $\\mathbf{x}_4 = [0.5, 590]$, $\\mathbf{x}_5 = [0.5, 620]$,\n$\\mathbf{x}_6 = [1.0, 560]$, $\\mathbf{x}_7 = [1.0, 590]$, $\\mathbf{x}_8 = [1.0, 620]$。\n\n相应的训练输出（目标）$y_i$ 是由一个基于物理知识的潜函数 $w_{\\text{true}}(u, T)$ 加上确定性伪噪声生成的。潜函数由以下公式给出：\n$$\nw_{\\text{true}}(u, T) = W_{\\max} \\left(1 - e^{-c u}\\right) \\left(1 - a\\,(T - T_{\\text{ref}})\\right) + b\\,u\\,(T - T_{\\text{ref}})\n$$\n其中常数为 $W_{\\max} = 7000\\ \\text{pcm}$，$c = 3.5$，$a = 5 \\times 10^{-4}\\ \\text{K}^{-1}$，$T_{\\text{ref}} = 590\\ \\text{K}$，$b = -6\\ \\text{pcm/K}$。\n然后，观测目标 $y_i$ 按如下方式构建：\n$$\ny_i = w_{\\text{true}}(u_i, T_i) + \\eta_i\n$$\n其中伪噪声项 $\\eta_i$ 定义为 $\\eta_i = A_{\\text{noise}} \\sin(0.7\\, i)$ 对于 $i \\in \\{0, 1, \\dots, 8\\}$。振幅 $A_{\\text{noise}}$ 是每个测试用例中指定的参数之一。\n\n代理模型是一个高斯过程。GP 定义了函数上的一个先验，$f(\\mathbf{x}) \\sim \\mathcal{GP}(m(\\mathbf{x}), k(\\mathbf{x}, \\mathbf{x}'))$。我们假设均值函数为零，$m(\\mathbf{x})=0$。协方差函数（或称核函数）是带自动相关性确定（ARD）的平方指数函数：\n$$\nk(\\mathbf{x}, \\mathbf{x}') = \\sigma_f^2 \\exp\\left(-\\frac{1}{2}\\left(\\frac{(u-u')^2}{\\ell_u^2} + \\frac{(T-T')^2}{\\ell_T^2}\\right)\\right)\n$$\n超参数 $(\\sigma_f, \\ell_u, \\ell_T)$ 分别是信号振幅和每个输入维度的特征长度尺度。假设观测值受到独立高斯噪声的干扰，$y_i = f(\\mathbf{x}_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_n^2)$。\n\n给定一组训练数据 $\\mathcal{D} = \\{\\mathbf{X}, \\mathbf{y}\\}$，其中 $\\mathbf{X}$ 是输入的 $N \\times 2$ 矩阵，$\\mathbf{y}$ 是输出的 $N \\times 1$ 向量，GP 模型即被定义。训练输入的协方差矩阵表示为 $\\mathbf{K}$，其元素为 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$。带噪声观测值的协方差矩阵为 $\\mathbf{K}_y = \\mathbf{K} + \\sigma_n^2 \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $N \\times N$ 的单位矩阵。\n\n任务的核心是计算 LOO-CV 误差。对于每个点 $i$，我们需要使用在除 $(\\mathbf{x}_i, y_i)$ 之外的所有数据上训练的 GP 来计算预测值 $\\widehat{y}_i^{\\text{LOO}}$。通过重新训练模型 $N$ 次来执行此操作在计算上是低效的。幸运的是，对于 GP，存在一个解析的快捷方式。LOO 预测均值 $\\mu_{-i}(\\mathbf{x}_i) = \\widehat{y}_i^{\\text{LOO}}$ 和方差可以用从完整模型导出的量来表示。\n\n令 $\\mathbf{C} = \\mathbf{K}_y^{-1} = (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1}$ 为完整数据协方差矩阵的逆。令 $\\mathbf{\\alpha} = \\mathbf{C}\\mathbf{y}$。第 $i$ 个点的 LOO 预测均值由以下公式给出：\n$$\n\\widehat{y}_i^{\\text{LOO}} = \\mu_{-i}(\\mathbf{x}_i) = y_i - \\frac{\\alpha_i}{C_{ii}}\n$$\n其中 $\\alpha_i$ 是向量 $\\mathbf{\\alpha}$ 的第 $i$ 个元素，$C_{ii}$ 是矩阵 $\\mathbf{C}$ 的第 $i$ 个对角元素。\n\n性能指标是 LOO 预测的 RMSE，定义为：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(\\widehat{y}_i^{\\text{LOO}} - y_i\\right)^2}\n$$\n求和内部的差值项是点 $i$ 的 LOO 预测误差。使用 $\\widehat{y}_i^{\\text{LOO}}$ 的公式，这个误差是：\n$$\n\\widehat{y}_i^{\\text{LOO}} - y_i = \\left(y_i - \\frac{\\alpha_i}{C_{ii}}\\right) - y_i = -\\frac{\\alpha_i}{C_{ii}}\n$$\n将此代入 RMSE 公式，我们得到：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(-\\frac{\\alpha_i}{C_{ii}}\\right)^2} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(\\frac{\\alpha_i}{C_{ii}}\\right)^2}\n$$\n\n每个测试用例的总体算法如下：\n1.  从测试用例中设置超参数 $(\\sigma_f, \\ell_u, \\ell_T, \\sigma_n, A_{\\text{noise}})$。\n2.  生成 $N=9$ 个训练输入向量 $\\mathbf{X}$ 和对应的目标值 $\\mathbf{y}$。\n3.  使用 ARD SE 核计算 $9 \\times 9$ 的核矩阵 $\\mathbf{K}$。\n4.  构建带噪声的协方差矩阵 $\\mathbf{K}_y = \\mathbf{K} + \\sigma_n^2 \\mathbf{I}$。\n5.  计算逆矩阵 $\\mathbf{C} = \\mathbf{K}_y^{-1}$。\n6.  计算向量 $\\mathbf{\\alpha} = \\mathbf{C}\\mathbf{y}$。\n7.  对于从 $0$ 到 $8$ 的每个 $i$，计算 LOO 残差 $r_i = \\alpha_i/C_{ii}$。\n8.  计算 RMSE 为 $\\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} r_i^2}$。\n\n对所有三个测试用例重复此过程，并报告所得的 RMSE 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and evaluates a Gaussian Process surrogate model for nuclear reactor\n    control rod worth using Leave-One-Out (LOO) cross-validation.\n    \"\"\"\n    \n    # Define physical constants for the true function\n    W_max = 7000.0  # pcm\n    c = 3.5         # unitless\n    a = 5.0e-4      # K^-1\n    T_ref = 590.0   # K\n    b = -6.0        # pcm/K\n\n    def w_true(u, T):\n        \"\"\"Calculates the physically informed latent function value.\"\"\"\n        term1 = W_max * (1.0 - np.exp(-c * u)) * (1.0 - a * (T - T_ref))\n        term2 = b * u * (T - T_ref)\n        return term1 + term2\n\n    # Generate the training input grid as specified\n    u_vals = np.array([0.0, 0.5, 1.0])\n    T_vals = np.array([560.0, 590.0, 620.0])\n    \n    X_list = []\n    for u_val in u_vals:\n        for T_val in T_vals:\n            X_list.append([u_val, T_val])\n    X = np.array(X_list)\n    N = X.shape[0]\n\n    def ard_se_kernel(X_data, sigma_f, l_u, l_T):\n        \"\"\"Computes the ARD SE kernel matrix using numpy broadcasting.\"\"\"\n        length_scales = np.array([l_u, l_T])\n        scaled_X = X_data / length_scales\n        \n        # Compute squared Euclidean distance matrix on scaled data\n        # (N, 1, D) - (1, N, D) - (N, N, D), then sum over D\n        diffs = scaled_X[:, np.newaxis, :] - scaled_X[np.newaxis, :, :]\n        sq_dists = np.sum(diffs**2, axis=-1)\n        \n        return sigma_f**2 * np.exp(-0.5 * sq_dists)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (sigma_f, l_u, l_T, sigma_n, A_noise)\n        (3000.0, 0.35, 25.0, 50.0, 20.0),   # Case A\n        (3000.0, 0.35, 25.0, 1e-6, 0.0),    # Case B\n        (1500.0, 0.05, 200.0, 50.0, 20.0),  # Case C\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        sigma_f, l_u, l_T, sigma_n, A_noise = case\n\n        # Generate training targets Y based on the current case's noise amplitude\n        Y_true = np.array([w_true(u, T) for u, T in X])\n        noise_term = np.array([A_noise * np.sin(0.7 * i) for i in range(N)])\n        Y = Y_true + noise_term\n        \n        # Construct the GP covariance matrices\n        K = ard_se_kernel(X, sigma_f, l_u, l_T)\n        K_y = K + (sigma_n**2) * np.eye(N)\n\n        # Compute quantities for the analytical LOO-CV formula\n        # C = inv(K_y)\n        # alpha = C @ Y\n        # Using a direct call to inv is acceptable for a small 9x9 matrix.\n        C = np.linalg.inv(K_y)\n        alpha = C.dot(Y)\n\n        # The i-th LOO residual (y_i - y_hat_loo_i) is alpha_i / C_ii.\n        # The error term in the RMSE formula (y_hat_loo_i - y_i) is -alpha_i / C_ii.\n        # Squaring this gives (alpha_i / C_ii)^2.\n        loo_residuals = alpha / np.diag(C)\n        \n        # Compute the Root Mean Square Error of LOO predictions\n        rmse = np.sqrt(np.mean(loo_residuals**2))\n        \n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}