{
    "hands_on_practices": [
        {
            "introduction": "在构建许多降阶模型时，第一步是分析高保真模拟数据，以提取最重要的潜在模式。本实践聚焦于本征正交分解（Proper Orthogonal Decomposition, POD），这是一种与主成分分析（Principal Component Analysis, PCA）类似的技术，用于量化地确定最优的低维基。你将通过实现一个算法，来选择所需的最少模态数量，以捕获预设水平的系统“能量”或方差。",
            "id": "4245495",
            "problem": "核反应堆堆芯状态估计器会生成一个空间快照矩阵，该矩阵表示在不同运行工况下，离散空间位置上的状态，如温度或中子通量。设快照矩阵为 $X \\in \\mathbb{R}^{n \\times m}$，其中每一列是在 $n$ 个空间自由度上的一个快照，共有 $m$ 个快照。在降阶建模中，可以使用标准的欧几里得内积，从均值中心化的快照矩阵中计算出固有正交分解 (POD) 模态。均值中心化、奇异值分解和能量捕获的定义如下。\n\n给定 $X$，定义快照均值为 $\\mu = \\frac{1}{m} X \\mathbf{1}_m \\in \\mathbb{R}^{n}$，其中 $\\mathbf{1}_m$ 是 $m$ 维全一向量。构造均值中心化矩阵 $X_c = X - \\mu \\mathbf{1}_m^{\\top}$。在欧几里得内积下，计算 $X_c$ 的奇异值分解 (SVD)，即 $X_c = U \\Sigma V^{\\top}$，其中奇异值位于 $\\Sigma$ 的对角线上，记为 $\\{\\sigma_i\\}_{i=1}^{p}$，其中 $p = \\min(n,m)$ 且按非增顺序排列。定义总快照能量为弗罗贝尼乌斯范数的平方 $E_{\\text{tot}} = \\lVert X_c \\rVert_F^2$，并定义前 $r$ 个 POD 模态捕获的能量为 $E_r = \\lVert U_r U_r^{\\top} X_c \\rVert_F^2$，其中 $U_r$ 包含 $U$ 的前 $r$ 列。能量捕获比是无量纲量 $E_r / E_{\\text{tot}}$。\n\n从这些定义出发，推导 $E_r / E_{\\text{tot}}$ 与奇异值 $\\{\\sigma_i\\}$ 之间的关系，并设计一个算法来确定最小的正整数 $r$，使得捕获的能量比满足 $E_r / E_{\\text{tot}} \\geq 0.99$。如果 $E_{\\text{tot}} = 0$，则定义答案为 $r = 0$。本问题中所有比率均为无量纲。\n\n您的任务是实现一个程序，对每个给定的测试用例，计算如上定义的最小 $r$ 值。程序不得要求任何用户输入，并且必须按顺序处理以下快照矩阵测试套件：\n\n- 测试用例 1（理想情况，秩一主导，已均值中心化）：\n  $$\n  X_1 = \\begin{bmatrix}\n  -2  -1  0  1  2 \\\\\n  -4  -2  0  2  4 \\\\\n  -6  -3  0  3  6\n  \\end{bmatrix}\n  $$\n- 测试用例 2（两个非零模态，已均值中心化）：\n  $$\n  X_2 = \\begin{bmatrix}\n  -3  -2  -1  1  2  3 \\\\\n  1  -1  1  -1  1  -1 \\\\\n  0  0  0  0  0  0 \\\\\n  0  0  0  0  0  0\n  \\end{bmatrix}\n  $$\n- 测试用例 3（两个等能量模态，已均值中心化）：\n  $$\n  X_3 = \\begin{bmatrix}\n  1  -1  1  -1 \\\\\n  1  1  -1  -1\n  \\end{bmatrix}\n  $$\n- 测试用例 4（边界情况，中心化后能量为零）：\n  $$\n  X_4 = \\begin{bmatrix}\n  5 \\\\\n  -2 \\\\\n  7\n  \\end{bmatrix}\n  $$\n  注意：对于 $X_4$，由于 $m = 1$，均值中心化后得到 $X_c = 0$，因此 $E_{\\text{tot}} = 0$，定义的答案是 $r = 0$。\n\n您的程序应按给定顺序为每个测试用例计算最小的 $r$ 值，使用均值中心化快照的 SVD。如果 $E_{\\text{tot}} = 0$，则该测试用例返回 $r = 0$。否则，找到最小的 $r \\in \\{1,2,\\dots,p\\}$，使得捕获的能量比至少为 $0.99$。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个方括号内的逗号分隔列表的结果（例如，“[1,2,3,4]”）。结果必须是整数，分别对应 $X_1$、$X_2$、$X_3$ 和 $X_4$ 的 $r$ 值。所有能量比都是无量纲的；输出中不需要任何物理单位。",
            "solution": "该问题经评估有效。它基于线性代数和降阶建模（特别是固有正交分解 (POD)）的原理，具有科学依据。该问题是适定的，目标明确，数据充分，可以为每个测试用例找到唯一解。所有术语都经过形式化定义，前提条件事实正确且内部一致。\n\n问题的核心是推导能量捕获比与奇异值的表达式，然后利用这种关系找到捕获至少 $99\\%$ 总能量所需的最小模态数 $r$。\n\n首先，我们建立总能量 $E_{\\text{tot}}$ 与奇异值 $\\{\\sigma_i\\}$ 之间的关系。总能量是均值中心化快照矩阵 $X_c \\in \\mathbb{R}^{n \\times m}$ 的弗罗贝尼乌斯范数的平方。\n$$\nE_{\\text{tot}} = \\lVert X_c \\rVert_F^2\n$$\n矩阵的弗罗贝尼乌斯范数的平方等于 $X_c^{\\top} X_c$ 的迹。使用 $X_c$ 的奇异值分解 (SVD) $X_c = U \\Sigma V^{\\top}$，其中 $U$ 和 $V$ 是正交矩阵（$U^{\\top} U = I$，$V^{\\top} V = I$），我们可以写出：\n$$\nX_c^{\\top} X_c = (U \\Sigma V^{\\top})^{\\top} (U \\Sigma V^{\\top}) = V \\Sigma^{\\top} U^{\\top} U \\Sigma V^{\\top} = V (\\Sigma^{\\top} \\Sigma) V^{\\top}\n$$\n利用迹的循环性质 $\\text{Tr}(ABC) = \\text{Tr}(CAB)$：\n$$\nE_{\\text{tot}} = \\text{Tr}(X_c^{\\top} X_c) = \\text{Tr}(V (\\Sigma^{\\top} \\Sigma) V^{\\top}) = \\text{Tr}(V^{\\top} V (\\Sigma^{\\top} \\Sigma)) = \\text{Tr}(\\Sigma^{\\top} \\Sigma)\n$$\n矩阵 $\\Sigma \\in \\mathbb{R}^{n \\times m}$ 的主对角线上有奇异值 $\\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq \\sigma_p \\geq 0$，其中 $p = \\min(n, m)$。矩阵 $\\Sigma^{\\top} \\Sigma$ 是一个 $m \\times m$ 的对角矩阵，其对角元为 $\\{\\sigma_1^2, \\sigma_2^2, \\dots, \\sigma_p^2\\}$，如果 $m > p$，其余对角元为零。迹是这些对角元之和。\n$$\nE_{\\text{tot}} = \\sum_{i=1}^{p} \\sigma_i^2\n$$\n接下来，我们推导前 $r$ 个模态捕获的能量 $E_r$ 的表达式。它被定义为 $E_r = \\lVert U_r U_r^{\\top} X_c \\rVert_F^2$，其中 $U_r$ 由 $U$ 的前 $r$ 列组成。矩阵 $P_r = U_r U_r^{\\top}$ 是到由这前 $r$ 个 POD 模态张成的子空间上的正交投影算子。\n$$\nE_r = \\lVert P_r X_c \\rVert_F^2 = \\text{Tr}((P_r X_c)^{\\top} (P_r X_c)) = \\text{Tr}(X_c^{\\top} P_r^{\\top} P_r X_c)\n$$\n由于 $P_r$ 是一个投影算子，它是幂等的（$P_r^2 = P_r$）和自伴的（$P_r^{\\top} = P_r$）。因此，$P_r^{\\top} P_r = P_r$。\n$$\nE_r = \\text{Tr}(X_c^{\\top} P_r X_c)\n$$\n应用迹的循环性质并代入 $X_c = U \\Sigma V^{\\top}$：\n$$\nE_r = \\text{Tr}(P_r X_c X_c^{\\top}) = \\text{Tr}(U_r U_r^{\\top} (U \\Sigma V^{\\top})(U \\Sigma V^{\\top})^{\\top}) = \\text{Tr}(U_r U_r^{\\top} U \\Sigma \\Sigma^{\\top} U^{\\top})\n$$\n再次应用循环性质：\n$$\nE_r = \\text{Tr}(U^{\\top} U_r U_r^{\\top} U (\\Sigma \\Sigma^{\\top}))\n$$\n矩阵乘积 $U^{\\top} U_r U_r^{\\top} U$ 产生一个 $n \\times n$ 的对角矩阵，其前 $r$ 个对角元为 $1$，其余为 $0$。这是因为 $U^{\\top} U_r$ 是一个 $n \\times r$ 矩阵，其顶部的 $r \\times r$ 块是单位矩阵 $I_r$，其下方的 $(n-r) \\times r$ 块是零。它与其转置的乘积产生所述的对角结构。该矩阵与对角矩阵 $\\Sigma \\Sigma^{\\top}$（其对角元为 $\\sigma_i^2$）的乘积的迹分离出前 $r$ 个奇异值的平方。\n$$\nE_r = \\sum_{i=1}^{r} \\sigma_i^2\n$$\n最后，能量捕获比由下式给出：\n$$\n\\frac{E_r}{E_{\\text{tot}}} = \\frac{\\sum_{i=1}^{r} \\sigma_i^2}{\\sum_{i=1}^{p} \\sigma_i^2}\n$$\n寻找满足该比率至少为 $0.99$ 的最小正整数 $r$ 的算法如下：\n1. 对于给定的快照矩阵 $X$，计算均值快照向量 $\\mu$ 和均值中心化矩阵 $X_c$。\n2. 计算总能量 $E_{\\text{tot}} = \\lVert X_c \\rVert_F^2$。如果 $E_{\\text{tot}}$ 为零（或数值上与零无法区分），问题规定 $r=0$。\n3. 如果 $E_{\\text{tot}} > 0$，使用 SVD 计算 $X_c$ 的奇异值 $\\{\\sigma_i\\}$。\n4. 总能量可以确认为 $E_{\\text{tot}} = \\sum_{i=1}^p \\sigma_i^2$。\n5. 从 $k=1$ 到 $p$ 迭代，计算奇异值平方的累积和 $S_k = \\sum_{i=1}^k \\sigma_i^2$。\n6. 在每一步中，检查比率 $S_k / E_{\\text{tot}} \\geq 0.99$ 是否成立。第一个使此不等式成立的 $k$ 值就是所求的最小秩 $r$。\n\n对每个给定的测试用例实施此算法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_r(X: np.ndarray) -> int:\n    \"\"\"\n    Computes the smallest number of POD modes 'r' to capture at least 99% of the energy.\n\n    Args:\n        X: The snapshot matrix of size (n, m).\n\n    Returns:\n        The smallest integer r.\n    \"\"\"\n    # Defensive check to ensure X is a 2D array\n    X = np.atleast_2d(X)\n    \n    # Get dimensions n (spatial DOFs) and m (number of snapshots)\n    n, m = X.shape\n    \n    # Step 1: Compute the mean snapshot and the mean-centered matrix X_c\n    if m == 1:\n        # If there is only one snapshot, the mean is the snapshot itself\n        mu = X\n        X_c = X - mu  # This results in a zero matrix\n    else:\n        mu = X.mean(axis=1, keepdims=True)\n        X_c = X - mu\n        \n    # Step 2: Check for the zero energy case\n    # The total energy is the squared Frobenius norm of X_c.\n    # We can check if X_c is all zeros, which is more robust than floating point comparison of energy.\n    if not np.any(X_c):\n        return 0\n        \n    # Step 3: Compute the singular values of X_c\n    # We only need the singular values, so we can set compute_uv=False for efficiency\n    s = np.linalg.svd(X_c, compute_uv=False)\n    \n    # Step 4: Calculate the total energy from the squared singular values\n    s_squared = s**2\n    total_energy = np.sum(s_squared)\n    \n    # This check handles cases where energy is numerically very close to zero\n    if total_energy  1e-15:\n        return 0\n\n    # Step 5: Find the smallest r satisfying the energy capture condition\n    # Calculate the cumulative sum of energy captured by the modes\n    cumulative_energy = np.cumsum(s_squared)\n    \n    # Calculate the ratio of captured energy to total energy\n    energy_ratios = cumulative_energy / total_energy\n    \n    # Find the first index where the ratio is = 0.99\n    # np.where returns a tuple of arrays; we need the first element of the first array.\n    # The result is a 0-based index, so we add 1 to get the number of modes r.\n    r = np.where(energy_ratios = 0.99)[0][0] + 1\n    \n    return int(r)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        np.array([\n            [-2.0, -1.0, 0.0, 1.0, 2.0],\n            [-4.0, -2.0, 0.0, 2.0, 4.0],\n            [-6.0, -3.0, 0.0, 3.0, 6.0]\n        ]),\n        # Test case 2\n        np.array([\n            [-3.0, -2.0, -1.0, 1.0, 2.0, 3.0],\n            [1.0, -1.0, 1.0, -1.0, 1.0, -1.0],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n        ]),\n        # Test case 3\n        np.array([\n            [1.0, -1.0, 1.0, -1.0],\n            [1.0, 1.0, -1.0, -1.0]\n        ]),\n        # Test case 4 (must be a column vector, shape (3,1))\n        np.array([\n            [5.0],\n            [-2.0],\n            [7.0]\n        ])\n    ]\n\n    results = []\n    for case in test_cases:\n        r = compute_r(case)\n        results.append(r)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本实践以前述的POD概念为基础，将引导你完成构建一个基于投影的物理系统降阶模型的全过程。你将利用上一实践中学习生成的POD基函数，将一个二维中子扩散方程投影到一个低维系统上。这个练习将抽象的数据分析与具体的、可预测的物理模型联系起来，是降阶建模的核心实践。",
            "id": "4245475",
            "problem": "考虑在矩形组件区域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上具有均匀诺伊曼边界条件的稳态二维中子扩散模型。该无量纲化模型基于稳态中子平衡和菲克定律 (Fick's law)，得到扩散方程 $-\\nabla \\cdot (D(x,y) \\nabla \\phi(x,y)) + \\Sigma_a(x,y)\\,\\phi(x,y) = q(x,y)$，其中 $D(x,y)$ 是扩散系数，$\\Sigma_a(x,y)$ 是吸收截面，$q(x,y)$ 是源项。在降阶建模中，将伽辽金投影到一个由一组基函数 $\\{\\varphi_i\\}_{i=1}^r$ 张成的子空间上，会得到一个降阶算子，其各项由双线性形式 $a(\\varphi_i,\\varphi_j) = \\int_{\\Omega} D\\,\\nabla \\varphi_i \\cdot \\nabla \\varphi_j\\,\\mathrm{d}x\\,\\mathrm{d}y + \\int_{\\Omega} \\Sigma_a\\, \\varphi_i\\,\\varphi_j\\,\\mathrm{d}x\\,\\mathrm{d}y$ 给出。基 $\\{\\varphi_i\\}_{i=1}^r$ 是通过使用一组快照场 $\\{u^{(k)}(x,y)\\}_{k=1}^m$ 进行本征正交分解 (POD) 获得的。对于具有 $N_x \\times N_y$ 个网格中心、网格间距 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$ 以及网格面积 $h_x h_y$ 的均匀网格离散化，设离散内积为 $(u,v)_W = \\sum_{i=1}^{N_y} \\sum_{j=1}^{N_x} u_{i,j} v_{i,j}\\, h_x h_y$。使用加权奇异值分解来形成一个关于 $(\\cdot,\\cdot)_W$ 标准正交的 POD 基，即 $\\Phi = W^{-1/2} U_r$，其中 $U_r$ 是 $Y = W^{1/2} X$ 的前 $r$ 个左奇异向量，$X$ 是快照矩阵（每列是一个展平的快照场），$W^{1/2}$ 表示每个网格单元乘以 $\\sqrt{h_x h_y}$。通过使用网格中心值的离散求积 $\\sum_{i=1}^{N_y} \\sum_{j=1}^{N_x} (\\cdot)\\, h_x h_y$ 来近似定义 $a(\\varphi_i,\\varphi_j)$ 的积分。通过有限差分近似每个基场 $\\varphi_\\ell$ 的空间梯度：对于内部索引，使用中心差分公式 $\\partial_x \\varphi_\\ell|_{i,j} \\approx (\\varphi_{\\ell,i,j+1} - \\varphi_{\\ell,i,j-1})/(2 h_x)$ 和 $\\partial_y \\varphi_\\ell|_{i,j} \\approx (\\varphi_{\\ell,i+1,j} - \\varphi_{\\ell,i-1,j})/(2 h_y)$；在边界上，使用单边差分 $\\partial_x \\varphi_\\ell|_{i,0} \\approx (\\varphi_{\\ell,i,1} - \\varphi_{\\ell,i,0})/h_x$，$\\partial_x \\varphi_\\ell|_{i,N_x-1} \\approx (\\varphi_{\\ell,i,N_x-1} - \\varphi_{\\ell,i,N_x-2})/h_x$，以及在 $i=0$ 和 $i=N_y-1$ 处对 $\\partial_y$ 的类似公式。根据这些定义，为给定的 POD 基阶数 $r$ 计算降阶算子项 $A_{p,q} = a(\\varphi_p,\\varphi_q)$。\n\n所有量均为无量纲；报告数值结果时不带物理单位。不出现角度。不出现百分比。\n\n您的程序必须构建并评估三个测试用例，每个用例定义 $(L_x,L_y)$、$(N_x,N_y)$、非均匀的 $D(x,y)$ 和 $\\Sigma_a(x,y)$、快照集以及 POD 阶数 $r$。对于每个测试用例，返回按行主序展平的降阶算子矩阵项，形式为浮点数列表。将所有测试用例的结果汇总到单行输出中，格式如此问题陈述末尾所述。\n\n测试套件：\n\n- 测试用例 $1$（典型的非均匀内部包含物）：\n  - 几何：$L_x = 1$, $L_y = 1$, $N_x = 16$, $N_y = 16$，网格中心。\n  - 扩散：若 $|x - 0.5| \\le 0.1$ 且 $|y - 0.5| \\le 0.1$，则 $D(x,y) = 3$，否则 $D(x,y) = 1$。\n  - 吸收：若 $x \\ge 0.5$ 且 $y \\ge 0.5$，则 $\\Sigma_a(x,y) = 0.4$，否则 $\\Sigma_a(x,y) = 0.1$。\n  - 快照（$m = 5$），在网格中心 $(x_j,y_i)$ 处求值，其中 $x_j = (j+0.5) h_x$，$y_i = (i+0.5) h_y$。定义 $x' = x/L_x$，$y' = y/L_y$，并设\n    - $u^{(1)}(x,y) = \\cos(\\pi x') \\cos(\\pi y')$,\n    - $u^{(2)}(x,y) = \\cos(2\\pi x') \\cos(\\pi y')$,\n    - $u^{(3)}(x,y) = \\sin(\\pi x') \\sin(2\\pi y')$,\n    - $u^{(4)}(x,y) = \\exp(-50[(x-0.5)^2 + (y-0.7)^2])$,\n    - $u^{(5)}(x,y) = \\exp(-40[(x-0.25)^2 + (y-0.25)^2])$。\n  - POD 阶数：$r = 3$。\n\n- 测试用例 $2$（近均匀介质，边缘情况 $r=1$）：\n  - 几何：$L_x = 1$, $L_y = 0.5$, $N_x = 8$, $N_y = 8$。\n  - 扩散：$D(x,y) = 1$。\n  - 吸收：$\\Sigma_a(x,y) = 0.2$。\n  - 快照（$m = 3$），其中 $x' = x/L_x$，$y' = y/L_y$：\n    - $u^{(1)}(x,y) = 1$,\n    - $u^{(2)}(x,y) = \\cos(\\pi x')$,\n    - $u^{(3)}(x,y) = \\cos(\\pi y')$.\n  - POD 阶数：$r = 1$。\n\n- 测试用例 $3$（强非均匀包含物和条带，更高的 $r$）：\n  - 几何：$L_x = 1.2$, $L_y = 0.8$, $N_x = 20$, $N_y = 12$。\n  - 扩散：$D(x,y) = 0.8 + 2.5 \\exp\\left(-\\left[\\frac{(x - 0.7 L_x)^2}{(0.15 L_x)^2} + \\frac{(y - 0.4 L_y)^2}{(0.12 L_y)^2}\\right]\\right) + 0.6\\,\\mathbf{1}_{|x - 0.3 L_x| \\le 0.08 L_x}$，其中 $\\mathbf{1}$ 是指示函数，若条件成立则为 $1$，否则为 $0$。\n  - 吸收：$\\Sigma_a(x,y) = 0.15 + 0.35 \\exp\\left(-\\left[\\frac{(x - 0.3 L_x)^2}{(0.18 L_x)^2} + \\frac{(y - 0.6 L_y)^2}{(0.15 L_y)^2}\\right]\\right) + 0.1\\,\\mathbf{1}_{|x - 0.6 L_x| \\le 0.1 L_x}$。\n  - 快照（$m = 6$），其中 $x' = x/L_x$，$y' = y/L_y$：\n    - $u^{(1)}(x,y) = \\cos(\\pi x') \\cos(\\pi y')$,\n    - $u^{(2)}(x,y) = \\cos(2\\pi x') \\cos(2\\pi y')$,\n    - $u^{(3)}(x,y) = \\sin(2\\pi x') \\cos(\\pi y')$,\n    - $u^{(4)}(x,y) = \\exp(-30[(x-0.5 L_x)^2 + (y-0.25 L_y)^2])$,\n    - $u^{(5)}(x,y) = \\exp(-25[(x-0.9 L_x)^2 + (y-0.6 L_y)^2])$,\n    - $u^{(6)}(x,y) = \\sin(\\pi x') \\sin(2\\pi y')$.\n  - POD 阶数：$r = 4$。\n\n实现要求：\n- 对于每个测试用例，构建网格并在网格中心 $(x_j,y_i)$ 处评估 $D(x,y)$、$\\Sigma_a(x,y)$ 和快照场。\n- 通过按行主序展平每个快照场来构建快照矩阵 $X \\in \\mathbb{R}^{(N_x N_y) \\times m}$。\n- 使用加权奇异值分解，其中每个单元的 $L^2$ 内积权重为 $h_x h_y$：通过将每行乘以 $\\sqrt{h_x h_y}$ 来计算 $Y = W^{1/2} X$，然后计算 $Y$ 的前 $r$ 个左奇异向量 $U_r$，并设置 POD 基矩阵 $\\Phi = W^{-1/2} U_r$，其中 $W^{-1/2}$ 将每行除以 $\\sqrt{h_x h_y}$。将 $\\Phi$ 的每列重塑回 $N_y \\times N_x$ 网格，以获得基场 $\\varphi_\\ell(x,y)$。\n- 通过指定的有限差分近似 $\\nabla \\varphi_\\ell$，并使用离散求积 $\\sum_{i,j} h_x h_y \\left( D\\, \\nabla \\varphi_p \\cdot \\nabla \\varphi_q + \\Sigma_a\\, \\varphi_p \\varphi_q \\right)$ 形成降阶算子项 $A_{p,q}$。\n- 对于每个测试用例，以浮点数列表的形式输出按行主序展平的降阶算子矩阵项。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的降阶算子项的行主序展平列表。例如，格式必须完全像 $[\\text{list\\_for\\_case\\_1},\\text{list\\_for\\_case\\_2},\\text{list\\_for\\_case\\_3}]$，不得有任何额外文本。每个内部列表必须包含 $r \\times r$ 个浮点数。",
            "solution": "该问题是有效的，因为它提出了一个在核反应堆物理模拟降阶建模领域中适定的、具有科学依据的计算任务。所有必要的数据和程序步骤均已提供。\n\n目标是计算通过将稳态中子扩散算子伽辽金投影到一个低维子空间上所获得的降阶系统算子 $A_{p,q}$ 的各项。该子空间由一组通过本征正交分解 (POD) 导出的基函数 $\\{\\varphi_i\\}_{i=1}^r$ 张成。分析针对三个不同的测试用例进行。\n\n在区域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上，中子通量 $\\phi(x,y)$ 的控制方程是二维稳态中子扩散方程：\n$$-\\nabla \\cdot (D(x,y) \\nabla \\phi(x,y)) + \\Sigma_a(x,y)\\,\\phi(x,y) = q(x,y)$$\n其中 $D$ 是扩散系数，$\\Sigma_a$ 是宏观吸收截面，$q$ 是中子源项。对于均匀诺伊曼边界条件，相关的弱形式涉及对称双线性形式 $a(u,v)$：\n$$a(u,v) = \\int_{\\Omega} D(x,y)\\,\\nabla u \\cdot \\nabla v\\,\\mathrm{d}x\\,\\mathrm{d}y + \\int_{\\Omega} \\Sigma_a(x,y)\\, u\\,v\\,\\mathrm{d}x\\,\\mathrm{d}y$$\n在伽辽金方法中，解被近似为基函数的线性组合，即 $\\phi(x,y) \\approx \\sum_{i=1}^r c_i \\varphi_i(x,y)$。将弱形式投影到基 $\\{\\varphi_j\\}_{j=1}^r$ 上，得到一个降阶线性系统 $A c = f$，其中降阶算子 $A$ 的各项由 $A_{p,q} = a(\\varphi_p,\\varphi_q)$ 给出。\n\n为每个测试用例确定矩阵 $A$ 的计算过程如下：\n\n1.  **离散化**：连续区域 $\\Omega$ 被离散化为 $N_y \\times N_x$ 个单元的均匀网格。网格中心位于 $(x_j, y_i)$，其中 $x_j = (j+0.5)h_x$（对于 $j \\in \\{0, \\dots, N_x-1\\}$）和 $y_i = (i+0.5)h_y$（对于 $i \\in \\{0, \\dots, N_y-1\\}$），单元尺寸为 $h_x = L_x/N_x$ 和 $h_y = L_y/N_y$。材料属性 $D(x,y)$ 和 $\\Sigma_a(x,y)$ 在这些网格中心处进行评估。\n\n2.  **快照采集**：在离散网格上评估一组 $m$ 个快照场 $\\{u^{(k)}(x,y)\\}_{k=1}^m$，这些快照场代表了系统的特征状态。每个快照被展平为一个长度为 $N = N_x N_y$ 的向量。这些向量被组装成快照矩阵 $X \\in \\mathbb{R}^{N \\times m}$ 的列。\n\n3.  **POD 基的构建**：使用加权奇异值分解 (SVD) 构建一个关于离散 $L^2$ 内积 $(u,v)_W = \\sum_{k=1}^N u_k v_k (h_x h_y)$ 标准正交的基。\n    -   离散内积可以写成矩阵形式 $(u,v)_W = u^T W v$，其中 $W$ 是一个对角矩阵，其对角线上的元素为单元面积 $dA = h_x h_y$。由于网格是均匀的，所以 $W = (h_x h_y) I$。\n    -   形成一个加权快照矩阵 $Y = W^{1/2} X = \\sqrt{h_x h_y} X$。\n    -   计算 $Y$ 的 SVD：$Y = U S V^T$。$U$ 的列是左奇异向量。\n    -   选择 $U$ 的前 $r$ 列构成 $U_r \\in \\mathbb{R}^{N \\times r}$。\n    -   通过对 $U_r$ 去加权来获得 POD 基向量（作为矩阵 $\\Phi$ 的列）：$\\Phi = W^{-1/2} U_r = (1/\\sqrt{h_x h_y}) U_r$。$\\Phi$ 的列，记作 $\\vec{\\varphi}_p$，是基函数 $\\varphi_p$ 的展平表示。根据构造，这些基向量关于 $(\\cdot, \\cdot)_W$ 内积是标准正交的：$(\\vec{\\varphi}_p, \\vec{\\varphi}_q)_W = \\delta_{pq}$。\n\n4.  **梯度计算**：为了评估双线性形式，需要基函数的梯度 $\\nabla \\varphi_p$。每个基向量 $\\vec{\\varphi}_p$ 被重塑为一个 $N_y \\times N_x$ 的网格。然后使用指定的有限差分公式在每个网格单元 $(i,j)$ 处近似偏导数 $\\partial_x \\varphi_p$ 和 $\\partial_y \\varphi_p$：\n    -   **内部点**：二阶中心差分。\n        $$ \\frac{\\partial \\varphi_p}{\\partial x}\\bigg|_{i,j} \\approx \\frac{\\varphi_{p,i,j+1} - \\varphi_{p,i,j-1}}{2 h_x}, \\quad \\frac{\\partial \\varphi_p}{\\partial y}\\bigg|_{i,j} \\approx \\frac{\\varphi_{p,i+1,j} - \\varphi_{p,i-1,j}}{2 h_y} $$\n    -   **边界点**：一阶单边差分。例如，在边界 $j=0$ 处：\n        $$ \\frac{\\partial \\varphi_p}{\\partial x}\\bigg|_{i,0} \\approx \\frac{\\varphi_{p,i,1} - \\varphi_{p,i,0}}{h_x} $$\n        类似的公式适用于其他边界（$j=N_x-1$, $i=0$, $i=N_y-1$）。\n\n5.  **降阶算子组装**：通过使用网格单元上的数值求积来近似双线性形式 $a(\\varphi_p, \\varphi_q)$ 中的积分，从而计算 $r \\times r$ 降阶算子 $A$ 的各项 $A_{p,q}$：\n    $$ A_{p,q} = \\sum_{i=0}^{N_y-1} \\sum_{j=0}^{N_x-1} \\left[ D_{i,j} \\left( \\frac{\\partial \\varphi_p}{\\partial x}\\frac{\\partial \\varphi_q}{\\partial x} + \\frac{\\partial \\varphi_p}{\\partial y}\\frac{\\partial \\varphi_q}{\\partial y} \\right)_{i,j} + (\\Sigma_a)_{i,j} (\\varphi_p)_{i,j} (\\varphi_q)_{i,j} \\right] (h_x h_y) $$\n    对所有 $(p,q)$（其中 $p,q \\in \\{0, \\dots, r-1\\}$）对执行此计算。然后将得到的矩阵 $A$ 按行主序展平为一个列表。对所提供的三个测试用例中的每一个都重复此整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import svd\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution for all test cases.\n    \"\"\"\n\n    # Test Case 1: Heterogeneous interior inclusion\n    case1_params = {\n        'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16, 'r': 3,\n        'D_func': lambda x, y, Lx, Ly: 3.0 if np.abs(x - 0.5) = 0.1 and np.abs(y - 0.5) = 0.1 else 1.0,\n        'Sigma_a_func': lambda x, y, Lx, Ly: 0.4 if x = 0.5 and y = 0.5 else 0.1,\n        'snapshots': [\n            lambda x, y, Lx, Ly: np.cos(np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.cos(2 * np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.sin(np.pi * x/Lx) * np.sin(2 * np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.exp(-50 * ((x - 0.5)**2 + (y - 0.7)**2)),\n            lambda x, y, Lx, Ly: np.exp(-40 * ((x - 0.25)**2 + (y - 0.25)**2))\n        ]\n    }\n\n    # Test Case 2: Near-homogeneous medium\n    case2_params = {\n        'Lx': 1.0, 'Ly': 0.5, 'Nx': 8, 'Ny': 8, 'r': 1,\n        'D_func': lambda x, y, Lx, Ly: 1.0,\n        'Sigma_a_func': lambda x, y, Lx, Ly: 0.2,\n        'snapshots': [\n            lambda x, y, Lx, Ly: 1.0,\n            lambda x, y, Lx, Ly: np.cos(np.pi * x/Lx),\n            lambda x, y, Lx, Ly: np.cos(np.pi * y/Ly)\n        ]\n    }\n\n    # Test Case 3: Strongly heterogeneous inclusion and stripe\n    case3_params = {\n        'Lx': 1.2, 'Ly': 0.8, 'Nx': 20, 'Ny': 12, 'r': 4,\n        'D_func': lambda x, y, Lx, Ly: 0.8 + 2.5 * np.exp(-(((x-0.7*Lx)/(0.15*Lx))**2 + ((y-0.4*Ly)/(0.12*Ly))**2)) \\\n                                        + 0.6 * (np.abs(x - 0.3*Lx) = 0.08*Lx),\n        'Sigma_a_func': lambda x, y, Lx, Ly: 0.15 + 0.35 * np.exp(-(((x-0.3*Lx)/(0.18*Lx))**2 + ((y-0.6*Ly)/(0.15*Ly))**2)) \\\n                                          + 0.1 * (np.abs(x - 0.6*Lx) = 0.1*Lx),\n        'snapshots': [\n            lambda x, y, Lx, Ly: np.cos(np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.cos(2*np.pi * x/Lx) * np.cos(2*np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.sin(2*np.pi * x/Lx) * np.cos(np.pi * y/Ly),\n            lambda x, y, Lx, Ly: np.exp(-30 * ((x-0.5*Lx)**2 + (y-0.25*Ly)**2)),\n            lambda x, y, Lx, Ly: np.exp(-25 * ((x-0.9*Lx)**2 + (y-0.6*Ly)**2)),\n            lambda x, y, Lx, Ly: np.sin(np.pi * x/Lx) * np.sin(2*np.pi * y/Ly)\n        ]\n    }\n\n    test_cases = [case1_params, case2_params, case3_params]\n    results = [process_case(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_gradient(phi, hx, hy):\n    \"\"\"\n    Computes the gradient of a field on the grid using specified finite differences.\n    \"\"\"\n    Ny, Nx = phi.shape\n    grad_x = np.zeros_like(phi)\n    grad_y = np.zeros_like(phi)\n\n    # x-gradient\n    grad_x[:, 1:-1] = (phi[:, 2:] - phi[:, :-2]) / (2 * hx)\n    grad_x[:, 0] = (phi[:, 1] - phi[:, 0]) / hx\n    grad_x[:, -1] = (phi[:, -1] - phi[:, -2]) / hx\n\n    # y-gradient\n    grad_y[1:-1, :] = (phi[2:, :] - phi[:-2, :]) / (2 * hy)\n    grad_y[0, :] = (phi[1, :] - phi[0, :]) / hy\n    grad_y[-1, :] = (phi[-1, :] - phi[-2, :]) / hy\n    \n    return grad_x, grad_y\n\ndef process_case(params):\n    \"\"\"\n    Processes a single test case to compute the reduced operator.\n    \"\"\"\n    Lx, Ly = params['Lx'], params['Ly']\n    Nx, Ny = params['Nx'], params['Ny']\n    r = params['r']\n    \n    hx, hy = Lx / Nx, Ly / Ny\n    dA = hx * hy\n    w_sqrt = np.sqrt(dA)\n\n    # 1. Grid and Parameters Setup\n    x = (np.arange(Nx) + 0.5) * hx\n    y = (np.arange(Ny) + 0.5) * hy\n    xx, yy = np.meshgrid(x, y)\n\n    D_grid = np.vectorize(params['D_func'])(xx, yy, Lx, Ly)\n    Sigma_a_grid = np.vectorize(params['Sigma_a_func'])(xx, yy, Lx, Ly)\n\n    # 2. Snapshot Generation\n    m = len(params['snapshots'])\n    snapshot_matrix_X = np.zeros((Nx * Ny, m))\n    for k, u_func in enumerate(params['snapshots']):\n        snapshot_grid = np.vectorize(u_func)(xx, yy, Lx, Ly)\n        snapshot_matrix_X[:, k] = snapshot_grid.flatten()\n\n    # 3. POD Basis Construction\n    Y = w_sqrt * snapshot_matrix_X\n    U, s, vh = svd(Y, full_matrices=False)\n    \n    Ur = U[:, :r]\n    Phi_matrix = (1.0 / w_sqrt) * Ur\n\n    # 4. Reduced Operator Assembly\n    A = np.zeros((r, r))\n    phi_basis_grids = [Phi_matrix[:, p].reshape(Ny, Nx) for p in range(r)]\n    phi_grads = [get_gradient(phi_p, hx, hy) for phi_p in phi_basis_grids]\n\n    for p in range(r):\n        for q in range(r):\n            phi_p_grid = phi_basis_grids[p]\n            phi_q_grid = phi_basis_grids[q]\n\n            grad_x_p, grad_y_p = phi_grads[p]\n            grad_x_q, grad_y_q = phi_grads[q]\n\n            # Stiffness term integrand: D * (grad(p) . grad(q))\n            stiffness_integrand = D_grid * (grad_x_p * grad_x_q + grad_y_p * grad_y_q)\n            \n            # Mass term integrand: Sigma_a * p * q\n            mass_integrand = Sigma_a_grid * phi_p_grid * phi_q_grid\n\n            # Numerical quadrature\n            A[p, q] = np.sum(stiffness_integrand + mass_integrand) * dA\n            \n    return A.flatten().tolist()\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "本实践介绍了一种替代的、非侵入式的代理建模方法——高斯过程（Gaussian Processes, GPs）。与投影方法不同，GP模型直接从数据中学习输入-输出关系，而无需修改控制方程。你将为一个反应堆控制棒价值构建一个GP代理模型，并使用高效的留一法交叉验证技术，来评估其泛化性能，这是模型验证的关键一步。",
            "id": "4245522",
            "problem": "您的任务是构建并评估一个高斯过程（GP）代理模型，用于描述核反应堆堆芯中控制棒的反应性价值随插入深度和燃料温度变化的函数。目标是使用留一法（LOO）交叉验证来评估其泛化能力。所有数学对象，包括数字，都必须使用 LaTeX 书写。我们感兴趣的反应堆物理量是控制棒价值，以 pcm（per cent mille）为单位表示，其定义为控制棒移动引起的反应性变化，其中 $1\\ \\text{pcm} = 10^{-5}$ 反应性单位。\n\n起始点与假设：\n- 代理模型是一个高斯过程（GP），具有带自动相关性确定（ARD）的平方指数核。输入是一个二维向量 $\\mathbf{x} = [u, T]$，其中 $u$ 是控制棒插入份额（无量纲，介于 $0$ 和 $1$ 之间），$T$ 是以开尔文为单位的燃料温度。\n- 观测值遵循 $y_i = f(\\mathbf{x}_i) + \\epsilon_i$，其中 $\\epsilon_i$ 是独立的、方差为 $\\sigma_n^2$ 的高斯测量噪声，$f(\\cdot)$ 是由一个 GP 先验建模的潜函数。\n- 核函数为 $k(\\mathbf{x}, \\mathbf{x}') = \\sigma_f^2 \\exp\\left(-\\dfrac{1}{2}\\left(\\dfrac{(u-u')^2}{\\ell_u^2} + \\dfrac{(T-T')^2}{\\ell_T^2}\\right)\\right)$，其中 $\\sigma_f$ 是信号振幅（单位为 pcm），$\\ell_u$ 和 $\\ell_T$ 分别是 $u$（无量纲）和 $T$（开尔文）的特征长度尺度。\n\n训练数据构建：\n- 使用插入份额 $u \\in \\{0.0, 0.5, 1.0\\}$ 和温度 $T \\in \\{560,\\ 590,\\ 620\\}\\ \\text{K}$ 构成的输入网格，按 $u$ 升序、在每个 $u$ 内按 $T$ 升序的字典序进行排序。这将产生 $9$ 个输入 $\\{\\mathbf{x}_i\\}_{i=0}^{8}$。\n- 符合物理规律的潜函数 $w_{\\text{true}}(u, T)$ 为\n$$\nw_{\\text{true}}(u, T) = W_{\\max} \\left(1 - e^{-c u}\\right) \\left(1 - a\\,(T - T_{\\text{ref}})\\right) + b\\,u\\,(T - T_{\\text{ref}}),\n$$\n其中常数为 $W_{\\max} = 7000\\ \\text{pcm}$，$c = 3.5$，$a = 5 \\times 10^{-4}\\ \\text{K}^{-1}$，$T_{\\text{ref}} = 590\\ \\text{K}$，以及 $b = -6\\ \\text{pcm/K}$。这种函数形式体现了更深的插入会非线性地增加价值，而温度升高会因多普勒展宽而降低价值，同时存在一个弱的交叉效应。\n- 添加确定性伪噪声以构成观测到的训练目标：\n$$\ny_i = w_{\\text{true}}(u_i, T_i) + \\eta_i,\\quad \\text{其中}\\quad \\eta_i = A_{\\text{noise}} \\sin(0.7\\, i)\\ \\text{pcm},\n$$\n其中索引 $i \\in \\{0,1,\\dots,8\\}$ 遵循上述排序。参数 $A_{\\text{noise}}$ 控制噪声的振幅。\n\n建模与评估任务：\n- 对于每个指定的测试用例，构建协方差矩阵 $\\mathbf{K}$，其元素为 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j) + \\sigma_n^2 \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克δ函数。利用 GP 后验和多元高斯分布的性质，在不重新拟合 $9$ 个独立模型的情况下，计算每个训练输入点的留一法（LOO）预测均值，然后通过将这些预测值与观测值 $y_i$ 进行比较来计算 LOO 误差。\n- 对每个测试用例，评估 LOO 预测的均方根误差（RMSE），\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(\\widehat{y}_i^{\\text{LOO}} - y_i\\right)^2},\n$$\n其中 $N = 9$。以 pcm 为单位表示 RMSE。\n\n测试套件：\n- 使用以下三个测试用例，每个用例指定为一个带有单位的元组 $(\\sigma_f, \\ell_u, \\ell_T, \\sigma_n, A_{\\text{noise}})$：\n    1. 用例 A（一般中等噪声情景）：$(3000,\\ 0.35,\\ 25.0,\\ 50.0,\\ 20.0)$，其中 $\\sigma_f$ 单位为 pcm，$\\ell_u$ 无量纲，$\\ell_T$ 单位为开尔文，$\\sigma_n$ 单位为 pcm，$A_{\\text{noise}}$ 单位为 pcm。\n    2. 用例 B（边界条件，无噪声观测）：$(3000,\\ 0.35,\\ 25.0,\\ 10^{-6},\\ 0.0)$，用于模拟可忽略的测量噪声同时保持数值稳定性。\n    3. 用例 C（长度尺度不匹配的边缘用例）：$(1500,\\ 0.05,\\ 200.0,\\ 50.0,\\ 20.0)$，表示对 $u$ 的过高敏感度和对 $T$ 的过度平滑性。\n\n所需输出：\n- 您的程序应生成单行输出，其中包含三个测试用例的 LOO RMSE 值，以逗号分隔列表的形式置于方括号内，顺序为用例 A、用例 B、用例 C，例如 $[\\text{rmse}_A,\\text{rmse}_B,\\text{rmse}_C]$。\n- 数值必须是以 pcm 为单位的浮点数表示的 RMSE。\n\n角度单位不适用。所有物理单位均已指定。不应读取任何外部数据；所有计算必须在程序内执行。",
            "solution": "该问题要求为一种核反应堆物理量构建并评估一个高斯过程（GP）代理模型。评估将使用留一法（LOO）交叉验证进行。最终输出是针对三组不同模型超参数的 LOO 预测的均方根误差（RMSE）。解决方案的步骤是：首先生成训练数据，然后构建 GP 模型的各个组件，最后应用 LOO-CV 的解析公式来计算 RMSE。\n\n首先，我们建立训练数据集。输入域是二维的，由控制棒插入份额 $u$ 和燃料温度 $T$ 组成。输入向量表示为 $\\mathbf{x} = [u, T]$。问题指定了一个由 $N=9$ 个训练点组成的网格，该网格由 $u \\in \\{0.0, 0.5, 1.0\\}$ 和 $T \\in \\{560, 590, 620\\}\\ \\text{K}$ 的笛卡尔积形成。点集 $\\{\\mathbf{x}_i\\}_{i=0}^{8}$ 按字典序排列，以 $u$ 为主键（升序），$T$ 为次键（升序）。这产生了以下训练输入序列：\n$\\mathbf{x}_0 = [0.0, 560]$, $\\mathbf{x}_1 = [0.0, 590]$, $\\mathbf{x}_2 = [0.0, 620]$,\n$\\mathbf{x}_3 = [0.5, 560]$, $\\mathbf{x}_4 = [0.5, 590]$, $\\mathbf{x}_5 = [0.5, 620]$,\n$\\mathbf{x}_6 = [1.0, 560]$, $\\mathbf{x}_7 = [1.0, 590]$, $\\mathbf{x}_8 = [1.0, 620]$。\n\n相应的训练输出（目标值）$y_i$ 是由一个符合物理规律的潜函数 $w_{\\text{true}}(u, T)$ 加上确定性伪噪声生成的。潜函数由下式给出：\n$$\nw_{\\text{true}}(u, T) = W_{\\max} \\left(1 - e^{-c u}\\right) \\left(1 - a\\,(T - T_{\\text{ref}})\\right) + b\\,u\\,(T - T_{\\text{ref}})\n$$\n其中常数为 $W_{\\max} = 7000\\ \\text{pcm}$，$c = 3.5$，$a = 5 \\times 10^{-4}\\ \\text{K}^{-1}$，$T_{\\text{ref}} = 590\\ \\text{K}$，以及 $b = -6\\ \\text{pcm/K}$。\n观测目标 $y_i$ 则构造为：\n$$\ny_i = w_{\\text{true}}(u_i, T_i) + \\eta_i\n$$\n其中伪噪声项 $\\eta_i$ 定义为 $\\eta_i = A_{\\text{noise}} \\sin(0.7\\, i)$，适用于 $i \\in \\{0, 1, \\dots, 8\\}$。振幅 $A_{\\text{noise}}$ 是每个测试用例中指定的参数之一。\n\n代理模型是一个高斯过程。一个 GP 定义了函数上的一个先验分布，$f(\\mathbf{x}) \\sim \\mathcal{GP}(m(\\mathbf{x}), k(\\mathbf{x}, \\mathbf{x}'))$。我们假设均值函数为零，$m(\\mathbf{x})=0$。协方差函数（或核函数）是带自动相关性确定（ARD）的平方指数核：\n$$\nk(\\mathbf{x}, \\mathbf{x}') = \\sigma_f^2 \\exp\\left(-\\frac{1}{2}\\left(\\frac{(u-u')^2}{\\ell_u^2} + \\frac{(T-T')^2}{\\ell_T^2}\\right)\\right)\n$$\n超参数 $(\\sigma_f, \\ell_u, \\ell_T)$ 分别是信号振幅和每个输入维度的特征长度尺度。观测值被假设为受到独立高斯噪声的干扰，$y_i = f(\\mathbf{x}_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_n^2)$。\n\n给定一组训练数据 $\\mathcal{D} = \\{\\mathbf{X}, \\mathbf{y}\\}$，其中 $\\mathbf{X}$ 是输入的 $N \\times 2$ 矩阵，$\\mathbf{y}$ 是输出的 $N \\times 1$ 向量，GP 模型就此定义。训练输入的协方差矩阵记为 $\\mathbf{K}$，其元素为 $K_{ij} = k(\\mathbf{x}_i, \\mathbf{x}_j)$。带噪声观测值的协方差矩阵为 $\\mathbf{K}_y = \\mathbf{K} + \\sigma_n^2 \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $N \\times N$ 的单位矩阵。\n\n任务的核心是计算 LOO-CV 误差。对于每个点 $i$，我们需要使用在除 $(\\mathbf{x}_i, y_i)$ 之外的所有数据上训练的 GP 来计算预测值 $\\widehat{y}_i^{\\text{LOO}}$。通过重新训练模型 $N$ 次来执行此操作在计算上是低效的。幸运的是，对于 GP，存在一种解析的快捷方法。LOO 预测均值 $\\mu_{-i}(\\mathbf{x}_i) = \\widehat{y}_i^{\\text{LOO}}$ 和方差可以用从完整模型推导出的量来表示。\n\n令 $\\mathbf{C} = \\mathbf{K}_y^{-1} = (\\mathbf{K} + \\sigma_n^2 \\mathbf{I})^{-1}$ 为完整数据协方差矩阵的逆。令 $\\mathbf{\\alpha} = \\mathbf{C}\\mathbf{y}$。第 $i$ 个点的 LOO 预测均值由下式给出：\n$$\n\\widehat{y}_i^{\\text{LOO}} = \\mu_{-i}(\\mathbf{x}_i) = y_i - \\frac{\\alpha_i}{C_{ii}}\n$$\n其中 $\\alpha_i$ 是向量 $\\mathbf{\\alpha}$ 的第 $i$ 个元素，$C_{ii}$ 是矩阵 $\\mathbf{C}$ 的第 $i$ 个对角线元素。\n\n性能指标是 LOO 预测的 RMSE，定义为：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(\\widehat{y}_i^{\\text{LOO}} - y_i\\right)^2}\n$$\n求和内部的差值项是点 $i$ 的 LOO 预测误差。使用 $\\widehat{y}_i^{\\text{LOO}}$ 的公式，这个误差是：\n$$\n\\widehat{y}_i^{\\text{LOO}} - y_i = \\left(y_i - \\frac{\\alpha_i}{C_{ii}}\\right) - y_i = -\\frac{\\alpha_i}{C_{ii}}\n$$\n将此代入 RMSE 公式，我们得到：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(-\\frac{\\alpha_i}{C_{ii}}\\right)^2} = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\left(\\frac{\\alpha_i}{C_{ii}}\\right)^2}\n$$\n\n每个测试用例的总体算法如下：\n1.  根据测试用例设置超参数 $(\\sigma_f, \\ell_u, \\ell_T, \\sigma_n, A_{\\text{noise}})$。\n2.  生成 $N=9$ 个训练输入向量 $\\mathbf{X}$ 和对应的目标值 $\\mathbf{y}$。\n3.  使用 ARD SE 核计算 $9 \\times 9$ 的核矩阵 $\\mathbf{K}$。\n4.  构成带噪声的协方差矩阵 $\\mathbf{K}_y = \\mathbf{K} + \\sigma_n^2 \\mathbf{I}$。\n5.  计算逆矩阵 $\\mathbf{C} = \\mathbf{K}_y^{-1}$。\n6.  计算向量 $\\mathbf{\\alpha} = \\mathbf{C}\\mathbf{y}$。\n7.  对于从 $0$ 到 $8$ 的每个 $i$，计算 LOO 残差 $r_i = \\alpha_i/C_{ii}$。\n8.  计算 RMSE 为 $\\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} r_i^2}$。\n\n对所有三个测试用例重复此过程，并报告所得的 RMSE 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and evaluates a Gaussian Process surrogate model for nuclear reactor\n    control rod worth using Leave-One-Out (LOO) cross-validation.\n    \"\"\"\n    \n    # Define physical constants for the true function\n    W_max = 7000.0  # pcm\n    c = 3.5         # unitless\n    a = 5.0e-4      # K^-1\n    T_ref = 590.0   # K\n    b = -6.0        # pcm/K\n\n    def w_true(u, T):\n        \"\"\"Calculates the physically informed latent function value.\"\"\"\n        term1 = W_max * (1.0 - np.exp(-c * u)) * (1.0 - a * (T - T_ref))\n        term2 = b * u * (T - T_ref)\n        return term1 + term2\n\n    # Generate the training input grid as specified\n    u_vals = np.array([0.0, 0.5, 1.0])\n    T_vals = np.array([560.0, 590.0, 620.0])\n    \n    X_list = []\n    for u_val in u_vals:\n        for T_val in T_vals:\n            X_list.append([u_val, T_val])\n    X = np.array(X_list)\n    N = X.shape[0]\n\n    def ard_se_kernel(X_data, sigma_f, l_u, l_T):\n        \"\"\"Computes the ARD SE kernel matrix using numpy broadcasting.\"\"\"\n        length_scales = np.array([l_u, l_T])\n        scaled_X = X_data / length_scales\n        \n        # Compute squared Euclidean distance matrix on scaled data\n        # (N, 1, D) - (1, N, D) - (N, N, D), then sum over D\n        diffs = scaled_X[:, np.newaxis, :] - scaled_X[np.newaxis, :, :]\n        sq_dists = np.sum(diffs**2, axis=-1)\n        \n        return sigma_f**2 * np.exp(-0.5 * sq_dists)\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # (sigma_f, l_u, l_T, sigma_n, A_noise)\n        (3000.0, 0.35, 25.0, 50.0, 20.0),   # Case A\n        (3000.0, 0.35, 25.0, 1e-6, 0.0),    # Case B\n        (1500.0, 0.05, 200.0, 50.0, 20.0),  # Case C\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        sigma_f, l_u, l_T, sigma_n, A_noise = case\n\n        # Generate training targets Y based on the current case's noise amplitude\n        Y_true = np.array([w_true(u, T) for u, T in X])\n        noise_term = np.array([A_noise * np.sin(0.7 * i) for i in range(N)])\n        Y = Y_true + noise_term\n        \n        # Construct the GP covariance matrices\n        K = ard_se_kernel(X, sigma_f, l_u, l_T)\n        K_y = K + (sigma_n**2) * np.eye(N)\n\n        # Compute quantities for the analytical LOO-CV formula\n        # C = inv(K_y)\n        # alpha = C @ Y\n        # Using a direct call to inv is acceptable for a small 9x9 matrix.\n        C = np.linalg.inv(K_y)\n        alpha = C.dot(Y)\n\n        # The i-th LOO residual (y_i - y_hat_loo_i) is alpha_i / C_ii.\n        # The error term in the RMSE formula (y_hat_loo_i - y_i) is -alpha_i / C_ii.\n        # Squaring this gives (alpha_i / C_ii)^2.\n        loo_residuals = alpha / np.diag(C)\n        \n        # Compute the Root Mean Square Error of LOO predictions\n        rmse = np.sqrt(np.mean(loo_residuals**2))\n        \n        results.append(rmse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}