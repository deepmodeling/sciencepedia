{
    "hands_on_practices": [
        {
            "introduction": "要精通切比雪夫有理逼近方法(CRAM)，不仅需要理解其理论，还需要掌握构建和分析这些逼近式的实践技能。我们将从一个基本练习开始：从头构建一个简单的 $[1/1]$ 阶有理逼近式。这个练习旨在揭示这些逼近函数是如何通过在关键点（如 $\\lambda=0$）匹配目标函数及其导数来构造的，从而优先保证对特定物理情景（例如长寿命核素的行为）的模拟精度。",
            "id": "4216709",
            "problem": "在用于核燃料耗损的中子诱发嬗变和放射性衰变模拟中，核素数密度矢量 $\\mathbf{N}(t)$ 满足 Bateman 嬗变方程 $\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}(t)\\,\\mathbf{N}(t)$，其中 $\\mathbf{A}(t)$ 是随时间变化的嬗变-衰变矩阵，其特征值的实部为非正数。在时长为 $t0$ 且在此期间 $\\mathbf{A}$ 保持不变的时间步长内，形式解为 $\\mathbf{N}(t+\\Delta t) = \\exp(t\\,\\mathbf{A})\\,\\mathbf{N}(t)$。在实践中，切比雪夫有理近似方法 (CRAM) 用 $\\mathbf{A}$ 的有理函数替换 $\\exp(t\\,\\mathbf{A})$，以在 $\\mathbf{A}$ 的整个谱上实现高精度和稳定性。\n\n长寿命核素对应于小的衰变常数，这映射到负实轴上 $\\lambda=0$ 附近的 $\\mathbf{A}$ 的特征值 $\\lambda$。为了优先保证此类模式的准确性，考虑标量目标函数 $f(\\lambda) = \\exp(-t\\,\\lambda)$（对于 $\\lambda \\ge 0$），它表示 $\\exp(t\\,\\mathbf{A})$ 通过映射 $\\lambda \\mapsto -\\lambda$ 作用于实数非负 $\\lambda$ 的行为。\n\n构造一个对 $f(\\lambda)$ 的 [1/1] 次加权有理近似式 $R(\\lambda)$，通过施加以下设计约束来优先保证在 $\\lambda=0$ 附近的准确性：\n- 在 $\\lambda=0$ 处保持值精确：$R(0) = f(0)$。\n- 在 $\\lambda=0$ 处保持斜率精确：$R'(0) = f'(0)$。\n- 在一个小的正横坐标 $\\sigma0$ 处进行加权近零插值：$R(\\sigma) = f(\\sigma)$，其中 $\\sigma$ 由从业者选择，以反映对 $\\lambda=0$ 附近的期望强调。\n\n假设一般形式为 $R(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda}$，其中 $a$ 和 $b$ 是实系数。推导 $R(\\lambda)$ 关于 $t$ 和 $\\sigma$ 的显式解析表达式。以单一闭式表达式提供最终答案。无需进行数值计算，也不应进行舍入。最终答案不得包含单位。",
            "solution": "该问题要求为函数 $f(\\lambda) = \\exp(-t\\,\\lambda)$ 构造一个特定的 [1/1] 次加权有理近似式 $R(\\lambda)$。该近似式必须在 $\\lambda=0$ 和一个小的正横坐标 $\\sigma  0$ 处满足一组插值和导数匹配条件。\n\n首先，我们对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- **目标函数**：$f(\\lambda) = \\exp(-t\\,\\lambda)$，对于 $\\lambda \\ge 0$。\n- **有理近似式形式**：$R(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda}$，其中 $a$ 和 $b$ 是实系数。\n- **约束条件**：\n    1.  $R(0) = f(0)$ (在 $\\lambda=0$ 处的值精确)\n    2.  $R'(0) = f'(0)$ (在 $\\lambda=0$ 处的斜率精确)\n    3.  $R(\\sigma) = f(\\sigma)$ 对于 $\\sigma  0$ (在 $\\lambda=\\sigma$ 处插值)\n- **目标**：推导 $R(\\lambda)$ 关于 $t$ 和 $\\sigma$ 的显式解析表达式。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题具有科学依据，位于求解核工程中出现的常微分方程组的数值方法这一成熟领域。使用有理近似来逼近矩阵指数是一种标准且强大的技术（例如，Padé 近似、CRAM）。该问题是适定的：它为具有两个未知参数 $a$ 和 $b$ 的近似式提供了特定形式，并施加了三个约束。正如我们将看到的，其中一个约束被所选的 $R(\\lambda)$ 形式自动满足，剩下两个独立的约束来确定这两个未知数。该问题是客观的、数学上精确的，并且不包含矛盾或歧义。\n\n### 结论与行动\n问题是有效的。我们继续进行推导。\n\n### 有理近似式的推导\n\n目标函数为 $f(\\lambda) = \\exp(-t\\,\\lambda)$。其关于 $\\lambda$ 的一阶导数为 $f'(\\lambda) = -t\\,\\exp(-t\\,\\lambda)$。\n\n所提出的有理近似式为 $R(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda}$。使用商法则求得其一阶导数为：\n$$\nR'(\\lambda) = \\frac{d}{d\\lambda} \\left( \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda} \\right) = \\frac{a(1 + b\\,\\lambda) - (1 + a\\,\\lambda)b}{(1 + b\\,\\lambda)^2} = \\frac{a + ab\\,\\lambda - b - ab\\,\\lambda}{(1 + b\\,\\lambda)^2} = \\frac{a - b}{(1 + b\\,\\lambda)^2}\n$$\n\n我们现在应用给定的三个约束来确定系数 $a$ 和 $b$。\n\n**约束 1: $R(0) = f(0)$**\n我们在 $\\lambda=0$ 处计算两个函数的值：\n$$\nf(0) = \\exp(-t \\cdot 0) = \\exp(0) = 1\n$$\n$$\nR(0) = \\frac{1 + a \\cdot 0}{1 + b \\cdot 0} = \\frac{1}{1} = 1\n$$\n因此，由于 $R(\\lambda)$ 的预定形式，对于 $a$ 和 $b$ 的任何选择，条件 $R(0) = f(0)$ 都得到满足。这个约束虽然对理解背景很重要，但被自动满足，并且没有为 $a$ 或 $b$ 提供方程。\n\n**约束 2: $R'(0) = f'(0)$**\n我们在 $\\lambda=0$ 处计算导数的值：\n$$\nf'(0) = -t\\,\\exp(-t \\cdot 0) = -t\n$$\n$$\nR'(0) = \\frac{a - b}{(1 + b \\cdot 0)^2} = a - b\n$$\n令两者相等，得到我们第一个关联 $a$ 和 $b$ 的方程：\n$$\na - b = -t \\implies a = b - t\n$$\n\n**约束 3: $R(\\sigma) = f(\\sigma)$**\n我们在 $\\lambda=\\sigma$ 处计算函数的值：\n$$\nf(\\sigma) = \\exp(-t\\,\\sigma)\n$$\n$$\nR(\\sigma) = \\frac{1 + a\\,\\sigma}{1 + b\\,\\sigma}\n$$\n令两者相等，得到我们的第二个方程：\n$$\n\\frac{1 + a\\,\\sigma}{1 + b\\,\\sigma} = \\exp(-t\\,\\sigma)\n$$\n\n现在，我们求解这个由两个方程组成的方程组，以求出两个未知数 $a$ 和 $b$。我们将第二个约束中得到的 $a$ 的表达式代入第三个约束的方程中：\n$$\n\\frac{1 + (b - t)\\sigma}{1 + b\\,\\sigma} = \\exp(-t\\,\\sigma)\n$$\n我们继续求解 $b$：\n$$\n1 + b\\,\\sigma - t\\,\\sigma = (1 + b\\,\\sigma)\\exp(-t\\,\\sigma)\n$$\n$$\n1 + b\\,\\sigma - t\\,\\sigma = \\exp(-t\\,\\sigma) + b\\,\\sigma\\,\\exp(-t\\,\\sigma)\n$$\n合并含有 $b$ 的项：\n$$\nb\\,\\sigma - b\\,\\sigma\\,\\exp(-t\\,\\sigma) = t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)\n$$\n$$\nb\\,\\sigma(1 - \\exp(-t\\,\\sigma)) = t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)\n$$\n解出 $b$：\n$$\nb = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n现在我们使用 $a = b - t$ 来求 $a$：\n$$\na = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))} - t\n$$\n$$\na = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma) - t\\,\\sigma(1 - \\exp(-t\\,\\sigma))}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n$$\na = \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma) - t\\,\\sigma + t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n$$\na = \\frac{-1 + \\exp(-t\\,\\sigma) + t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))} = \\frac{\\exp(-t\\,\\sigma)(1+t\\,\\sigma) - 1}{\\sigma(1 - \\exp(-t\\,\\sigma))}\n$$\n在确定了系数 $a$ 和 $b$ 之后，我们将它们代回到 $R(\\lambda)$ 的表达式中：\n$$\nR(\\lambda) = \\frac{1 + a\\,\\lambda}{1 + b\\,\\lambda} = \\frac{1 + \\lambda \\left( \\frac{\\exp(-t\\,\\sigma)(1+t\\,\\sigma) - 1}{\\sigma(1 - \\exp(-t\\,\\sigma))} \\right)}{1 + \\lambda \\left( \\frac{t\\,\\sigma - 1 + \\exp(-t\\,\\sigma)}{\\sigma(1 - \\exp(-t\\,\\sigma))} \\right)}\n$$\n为了简化这个繁分数，我们将分子和分母同乘以 $\\sigma(1 - \\exp(-t\\,\\sigma))$：\n$$\nR(\\lambda) = \\frac{\\sigma(1 - \\exp(-t\\,\\sigma)) + \\lambda(\\exp(-t\\,\\sigma)(1+t\\,\\sigma) - 1)}{\\sigma(1 - \\exp(-t\\,\\sigma)) + \\lambda(t\\,\\sigma - 1 + \\exp(-t\\,\\sigma))}\n$$\n这个表达式可以被重排成一个更具揭示性的结构。\n分子：\n$$\n(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma)\n$$\n分母：\n$$\n(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\n$$\n将这些组合起来，得到有理近似式 $R(\\lambda)$ 的最终简化表达式：\n$$\nR(\\lambda) = \\frac{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma}\n$$\n这就是所求的近似式关于 $\\lambda$、$t$ 和 $\\sigma$ 的闭式表达式。",
            "answer": "$$\n\\boxed{\\frac{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma\\,\\exp(-t\\,\\sigma)}{(\\sigma-\\lambda)(1-\\exp(-t\\,\\sigma)) + \\lambda\\,t\\,\\sigma}}\n$$"
        },
        {
            "introduction": "在了解了如何构建逼近式之后，下一步自然是分析其性能。CRAM的一个关键优势是其误差会随着阶数 $k$ 的增加而可预测地快速收敛。本练习将通过一个实际计算，来探索CRAM误差的几何收敛特性，并演示如何利用这一强大性质来估算达到目标精度所需的逼近阶数，这是科学计算中的一项常见任务。",
            "id": "4216696",
            "problem": "在核反应堆燃耗计算中，一个均匀燃耗步被建模为一个常系数线性常微分方程组，$$\\frac{d\\boldsymbol{n}}{dt} = -\\boldsymbol{A}\\,\\boldsymbol{n},$$ 其中 $\\boldsymbol{n}$ 是核素存量向量，$\\boldsymbol{A}$ 是嬗变矩阵，其非对角元为非负，对角元为非正，且由反应率决定。对于一个长度为 $\\Delta t$ 的时间步长，其精确解为 $$\\boldsymbol{n}(\\Delta t) = \\exp(-\\boldsymbol{A}\\,\\Delta t)\\,\\boldsymbol{n}(0)。$$ 切比雪夫有理逼近法 (CRAM) 通过在负实轴上计算标量指数的有理逼近来替换矩阵指数，得到 $$\\boldsymbol{n}(\\Delta t) \\approx r_{k,k}(-\\boldsymbol{A}\\,\\Delta t)\\,\\boldsymbol{n}(0),$$ 其中 $r_{k,k}$ 是一个 $(k,k)$ 型有理函数，其选择是为了最小化在 $(-\\infty,0]$ 上的均匀标量误差。对于谱位于经 $\\Delta t$ 缩放的闭右半平面内的矩阵 $\\boldsymbol{A}$，算子误差可由标量极小化极大误差 $$E_k := \\sup_{x \\leq 0} \\left| \\exp(x) - r_{k,k}(x) \\right|$$ 来界定。实践和理论上，对于较大的 $k$，$E_k$ 随 $k$ 呈几何衰减，即 $$E_k \\sim \\alpha\\,\\beta^{k} \\quad \\text{as } k \\to \\infty,$$ 其中常数 $\\alpha0$ 和 $0  \\beta  1$ 由 $(-\\infty,0]$ 上的极值有理逼近问题确定。广泛接受的关于 $\\exp(x)$ 在 $(-\\infty,0]$ 上的最佳一致 $(k,k)$ 型有理逼近的列表给出 $$E_{8} = 1.20 \\times 10^{-7}, \\qquad E_{16} = 2.20 \\times 10^{-16}。$$\n\n假设 $E_k$ 具有几何渐近形式，并根据上述列表值校准常数 $\\alpha$ 和 $\\beta$，估计确保 $$E_k \\leq \\epsilon,$$ 所需的最小整数阶数 $k$，其中给定的容差为 $$\\epsilon = 1.0 \\times 10^{-15}。$$ 最终答案以整数 $k$ 的形式给出。除了选择满足不等式的最小整数外，不需要其他舍入指令。",
            "solution": "问题要求切比雪夫有理逼近法 (CRAM) 的最小整数阶数 $k$，使得逼近误差 $E_k$ 低于指定的容差 $\\epsilon$。\n\n问题指出，对于大的 $k$，误差 $E_k$ 遵循几何渐近形式：\n$$E_k \\sim \\alpha \\beta^{k} \\quad \\text{as } k \\to \\infty$$\n其中 $\\alpha  0$ 和 $0  \\beta  1$ 是常数。我们从列表误差值中得到两个数据点：\n$E_{8} = 1.20 \\times 10^{-7}$\n$E_{16} = 2.20 \\times 10^{-16}$\n\n我们假设对于给定的阶数 $k=8$ 和 $k=16$，这个渐近关系精确成立。这使我们能够建立一个包含两个未知数 $\\alpha$ 和 $\\beta$ 的二元方程组：\n$$\n\\begin{cases}\nE_{8} = \\alpha \\beta^{8} \\\\\nE_{16} = \\alpha \\beta^{16}\n\\end{cases}\n$$\n目标是找到满足不等式 $E_k \\leq \\epsilon$ 的最小整数 $k$，其中给定的容差为 $\\epsilon = 1.0 \\times 10^{-15}$。\n\n首先，我们使用给定数据求解参数 $\\alpha$ 和 $\\beta$。一个更直接的方法是建立一个关系，绕过对 $\\alpha$ 和 $\\beta$ 的显式计算。我们定义 $k_1 = 8$ 和 $k_2 = 16$。方程组为：\n$$E_{k_1} = \\alpha \\beta^{k_1}$$\n$$E_{k_2} = \\alpha \\beta^{k_2}$$\n用第二个方程除以第一个方程可以消去 $\\alpha$：\n$$\\frac{E_{k_2}}{E_{k_1}} = \\frac{\\alpha \\beta^{k_2}}{\\alpha \\beta^{k_1}} = \\beta^{k_2 - k_1}$$\n这就得到了 $\\beta$ 的表达式。由于 $E_{k_2}  E_{k_1}$ 且 $k_2 > k_1$，我们有 $0  \\beta  1$，这与预期相符。\n\n我们寻求最小的整数 $k$，使得 $E_k \\leq \\epsilon$。使用模型 $E_k = \\alpha \\beta^k$：\n$$\\alpha \\beta^k \\leq \\epsilon$$\n我们可以从第一个方程中将 $\\alpha$ 表示为 $\\alpha = E_{k_1} / \\beta^{k_1}$。将其代入不等式中得到：\n$$\\frac{E_{k_1}}{\\beta^{k_1}} \\beta^k \\leq \\epsilon$$\n$$\\beta^{k-k_1} \\leq \\frac{\\epsilon}{E_{k_1}}$$\n为了求解 $k$，我们对两边取自然对数。由于 $0  \\beta  1$，我们有 $\\ln(\\beta)  0$。\n$$(k-k_1) \\ln(\\beta) \\leq \\ln\\left(\\frac{\\epsilon}{E_{k_1}}\\right)$$\n两边同除以 $\\ln(\\beta)$ 需要反转不等号：\n$$k-k_1 \\geq \\frac{\\ln\\left(\\frac{\\epsilon}{E_{k_1}}\\right)}{\\ln(\\beta)}$$\n从 $\\beta^{k_2 - k_1} = E_{k_2}/E_{k_1}$，我们得到 $\\ln(\\beta) = \\frac{1}{k_2 - k_1}\\ln\\left(\\frac{E_{k_2}}{E_{k_1}}\\right)$。将此代入关于 $k$ 的不等式中：\n$$k-k_1 \\geq \\frac{\\ln\\left(\\frac{\\epsilon}{E_{k_1}}\\right)}{\\frac{1}{k_2 - k_1}\\ln\\left(\\frac{E_{k_2}}{E_{k_1}}\\right)}$$\n$$k \\geq k_1 + (k_2 - k_1) \\frac{\\ln\\left(\\frac{\\epsilon}{E_{k_1}}\\right)}{\\ln\\left(\\frac{E_{k_2}}{E_{k_1}}\\right)}$$\n现在，我们代入给定的数值：\n$k_1 = 8$\n$k_2 = 16$\n$E_{k_1} = 1.20 \\times 10^{-7}$\n$E_{k_2} = 2.20 \\times 10^{-16}$\n$\\epsilon = 1.0 \\times 10^{-15}$\n\n我们计算公式所需的比率：\n$$\\frac{\\epsilon}{E_{k_1}} = \\frac{1.0 \\times 10^{-15}}{1.20 \\times 10^{-7}} = \\frac{1}{1.20} \\times 10^{-8} = \\frac{5}{6} \\times 10^{-8}$$\n$$\\frac{E_{k_2}}{E_{k_1}} = \\frac{2.20 \\times 10^{-16}}{1.20 \\times 10^{-7}} = \\frac{2.2}{1.2} \\times 10^{-9} = \\frac{11}{6} \\times 10^{-9}$$\n将这些代入关于 $k$ 的不等式中：\n$$k \\geq 8 + (16 - 8) \\frac{\\ln\\left(\\frac{5}{6} \\times 10^{-8}\\right)}{\\ln\\left(\\frac{11}{6} \\times 10^{-9}\\right)}$$\n$$k \\geq 8 + 8 \\frac{\\ln\\left(\\frac{5}{6}\\right) + \\ln(10^{-8})}{\\ln\\left(\\frac{11}{6}\\right) + \\ln(10^{-9})}$$\n$$k \\geq 8 + 8 \\frac{\\ln(5) - \\ln(6) - 8\\ln(10)}{\\ln(11) - \\ln(6) - 9\\ln(10)}$$\n使用对数的数值：\n$\\ln(5) \\approx 1.609438$\n$\\ln(6) \\approx 1.791759$\n$\\ln(10) \\approx 2.302585$\n$\\ln(11) \\approx 2.397895$\n\n分数的分子变为：\n$\\ln\\left(\\frac{\\epsilon}{E_{k_1}}\\right) \\approx (1.609438 - 1.791759) - 8(2.302585) = -0.182321 - 18.42068 = -18.603001$\n\n分数的分母变为：\n$\\ln\\left(\\frac{E_{k_2}}{E_{k_1}}\\right) \\approx (2.397895 - 1.791759) - 9(2.302585) = 0.606136 - 20.723265 = -20.117129$\n\n将这些值代回关于 $k$ 的不等式中：\n$$k \\geq 8 + 8 \\left(\\frac{-18.603001}{-20.117129}\\right)$$\n$$k \\geq 8 + 8 (0.924733 \\dots)$$\n$$k \\geq 8 + 7.39786 \\dots$$\n$$k \\geq 15.39786 \\dots$$\n由于 $k$ 必须是整数，满足此条件的最小整数 $k$ 值是大于或等于 $15.39786\\dots$ 的最小整数，即 $16$。\n\n为了验证，我们可以注意到 $E_{16} = 2.20 \\times 10^{-16}$，确实小于 $\\epsilon = 1.0 \\times 10^{-15}$。计算 $E_{15} = E_{16} / \\beta$ 会显示 $E_{15} > \\epsilon$，这证实了 $k=15$ 是不够的。\n$\\beta = (E_{16}/E_{8})^{1/8} \\approx \\left(\\frac{2.20 \\times 10^{-16}}{1.20 \\times 10^{-7}}\\right)^{1/8} \\approx (1.8333 \\times 10^{-9})^{1/8} \\approx 0.08089$。\n$E_{15} = E_{16} / \\beta \\approx (2.20 \\times 10^{-16}) / 0.08089 \\approx 2.72 \\times 10^{-15} > \\epsilon$。这证实了我们的结果。",
            "answer": "$$\\boxed{16}$$"
        },
        {
            "introduction": "最后，我们进入一个更高级的实践场景，旨在解决实际应用中的效率问题。在真实的反应堆模拟中，问题的刚性（与矩阵谱展宽相关）可能随时间步而变化，始终使用高阶CRAM虽安全但计算成本高。这个练习将指导你设计一种自适应算法，该算法利用计算成本低廉的谱估计方法（如Gershgorin圆盘定理）来动态评估问题难度，并据此选择既能保证精度又计算效率最高的CRAM阶数。",
            "id": "4216710",
            "problem": "要求您设计并实现一个自适应选择方案，该方案针对一个由实方阵表示的给定线性算子，决定使用16阶Chebyshev有理逼近法 (CRAM-16) 还是32阶Chebyshev有理逼近法 (CRAM-32) 来近似应用于核反应堆模拟背景下状态向量的矩阵指数。该选择必须基于一个有理论依据且计算成本低廉的误差代理，该代理无需显式计算CRAM-16或CRAM-32。\n\n其物理和数学背景如下。在许多反应堆物理模型中，状态向量 $y(t)$（例如，核素密度或多群中子通量）的时间演化由一个刚性线性常微分方程组控制\n$$\n\\frac{d}{dt} y(t) \\;=\\; -A\\,y(t),\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个矩阵，其元素带有以 $\\mathrm{s}^{-1}$ 为单位的物理速率，而 $t$ 是以秒为单位的时间。在时间 $t$ 的精确解是\n$$\ny(t) \\;=\\; \\exp\\big(-\\,A\\,t\\big)\\,y(0).\n$$\nChebyshev有理逼近法 (CRAM) 通过一个有理函数在正实轴上逼近标量函数 $f(z) = \\exp(-z)$，然后通过泛函演算将此逼近提升至矩阵，从而高效且稳定地逼近 $\\exp(-A t)$，尤其适用于刚性矩阵 $A$。高阶CRAM（如CRAM-32）通常在正实轴上产生比低阶CRAM（如CRAM-16）更小的一致逼近误差，但计算成本更高。此处的目的，是在进行任何CRAM计算之前，使用一个从 $tA$ 的谱导出的廉价代理，在CRAM-16和CRAM-32之间做出选择。\n\n您的任务是实现以下内容：\n\n1. 定义一个误差代理，它能给出缩放后算子 $tA$ 在正实轴上的谱分布范围的上界。您可以使用以下任一经过充分测试且计算成本低廉的界：\n   - 基于Gershgorin圆盘的界：\n     $$\n     \\mu_G \\;=\\; t \\cdot \\max_{1 \\le i \\le n} \\sum_{j=1}^{n} \\big|a_{ij}\\big|,\n     $$\n     其中 $a_{ij}$ 是 $A$ 的第 $(i,j)$ 个元素。\n   - 使用算子范数的矩阵范数界：\n     $$\n     \\mu_1 \\;=\\; t \\cdot \\lVert A \\rVert_{1}, \\quad \\mu_{\\infty} \\;=\\; t \\cdot \\lVert A \\rVert_{\\infty},\n     $$\n     其中 $\\lVert \\cdot \\rVert_{1}$ 是最大绝对列和，$\\lVert \\cdot \\rVert_{\\infty}$ 是最大绝对行和。\n   - 通过几步幂迭代进行可选的优化，以在2-范数意义下估计 $tA$ 的谱半径：\n     $$\n     \\mu_{2,\\mathrm{est}} \\;\\approx\\; \\frac{\\lVert (tA) v \\rVert_{2}}{\\lVert v \\rVert_{2}},\n     $$\n     其中非零向量 $v$ 通过与 $tA$ 的重复相乘进行更新，$\\lVert \\cdot \\rVert_{2}$ 是欧几里得范数。\n\n2. 使用这些代理，根据以下原则定义阈值 $\\tau_{\\mathrm{low}}$ 和 $\\tau_{\\mathrm{high}}$：当 $tA$ 的谱在正实轴上紧密聚集在原点附近时（代理值较小），CRAM-16是足够的；当谱在正实轴上延伸得更远时（代理值较大），CRAM-32是更优选的。对于介于两个阈值之间的模棱两可的代理值，使用可选的幂迭代优化来做出最终决定。\n\n3. 实现一个函数，该函数给定一个元素单位为 $\\mathrm{s}^{-1}$ 的实矩阵 $A$ 和一个以秒为单位的时间步长 $t$，根据上述自适应规则返回整数 $16$ 或 $32$。\n\n您的程序必须能直接运行，并为以下测试套件生成结果。对于每个测试用例，都给定一个矩阵 $A$ 和一个时间 $t$：\n- 测试用例 1 (理想情况，弱耦合慢速率): \n  $$\n  A_1 \\;=\\; \\begin{bmatrix}\n  0.10  -0.02  0.00 \\\\\n  0.02  0.07  -0.01 \\\\\n  0.00  0.01  0.03\n  \\end{bmatrix}, \\quad t_1 \\;=\\; 0.10 \\text{ s}.\n  $$\n- 测试用例 2 (刚性系统，快速移除率):\n  $$\n  A_2 \\;=\\; \\begin{bmatrix}\n  10^{5}  -10^{3}  0  0 \\\\\n  10^{3}  10^{5}  -10^{3}  0 \\\\\n  0  10^{3}  10^{5}  -10^{3} \\\\\n  0  0  10^{3}  10^{5}\n  \\end{bmatrix}, \\quad t_2 \\;=\\; 10^{-3} \\text{ s}.\n  $$\n- 测试用例 3 (近单位步长，极小时间):\n  $$\n  A_3 \\;=\\; \\begin{bmatrix}\n  0.50  -0.20  0.10  0.00  0.00 \\\\\n  0.10  0.40  -0.15  0.05  0.00 \\\\\n  0.00  0.10  0.60  -0.25  0.05 \\\\\n  0.00  0.00  0.10  0.30  -0.10 \\\\\n  0.00  0.00  0.00  0.05  0.20\n  \\end{bmatrix}, \\quad t_3 \\;=\\; 10^{-8} \\text{ s}.\n  $$\n- 测试用例 4 (非正规耦合，中到大等效尺度):\n  $$\n  A_4 \\;=\\; \\begin{bmatrix}\n  10  -50  0 \\\\\n  0  10  -50 \\\\\n  0  0  10\n  \\end{bmatrix}, \\quad t_4 \\;=\\; 0.60 \\text{ s}.\n  $$\n- 测试用例 5 (临界耦合与时间):\n  $$\n  A_5 \\;=\\; \\begin{bmatrix}\n  5  -1  0  0  0 \\\\\n  1  5  -1  0  0 \\\\\n  0  1  5  -1  0 \\\\\n  0  0  1  5  -1 \\\\\n  0  0  0  1  5\n  \\end{bmatrix}, \\quad t_5 \\;=\\; 1.50 \\text{ s}.\n  $$\n\n所有矩阵元素 $a_{ij}$ 的单位均为 $\\mathrm{s}^{-1}$，所有时间 $t$ 的单位均为 $\\mathrm{s}$。如果出现任何角度量，您必须使用弧度，但在这些测试用例中没有出现角度。\n\n您的程序应生成单行输出，其中包含五个测试用例所选阶数的逗号分隔列表，并用方括号括起来，例如，\n$$\n[\\dots]\n$$\n其中每个条目是相应测试用例的整数 $16$ 或 $32$。输出必须严格遵守此格式，不得包含任何额外文本。",
            "solution": "该解决方案基于连接底层物理、矩阵指数、有理逼近理论和廉价谱界定技术的基本原理构建。\n\n1. 从刚性线性初值问题开始\n$$\n\\frac{d}{dt} y(t) \\;=\\; -A\\,y(t),\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个实矩阵，其元素单位为 $\\mathrm{s}^{-1}$。精确解为\n$$\ny(t) \\;=\\; \\exp\\big(-A\\,t\\big)\\,y(0).\n$$\n当 $A$ 是刚性的（具有大特征值或强非正规耦合），如果不小心处理，直接计算矩阵指数可能会成本高昂或不稳定。\n\n2. Chebyshev有理逼近法 (CRAM) 构建一个有理函数 $R_n(z)$，它在正实轴上一致逼近 $f(z) = \\exp(-z)$。$n$ 阶CRAM（例如 $n=16$ 或 $n=32$）使用 $R_n(z)$ 的部分分式分解，其中包含共轭复数极点-留数对，通过求解形如下式的移位线性系统来高效地计算 $R_n(tA)$：\n$$\n\\left( tA - \\theta_k I \\right) w_k \\;=\\; y(0).\n$$\n更高的 $n$ 通常会产生更小的一致逼近误差\n$$\n\\varepsilon_n \\;=\\; \\sup_{x \\in [0,\\infty)} \\big| \\exp(-x) - R_n(x) \\big|,\n$$\n其中 $\\varepsilon_{32} \\ll \\varepsilon_{16}$，但代价是需要更多的线性求解。\n\n3. 为了在进行任何CRAM计算之前自适应地选择阶数，我们使用谱代理来界定谱 $\\sigma(tA)$ 在正实轴上的分布范围。矩阵泛函演算意味着 $R_n(tA)$ 的误差满足\n$$\n\\big\\| \\exp(-tA) - R_n(tA) \\big\\| \\;\\le\\; \\sup_{\\lambda \\in \\sigma(tA)} \\big| \\exp(-\\lambda) - R_n(\\lambda) \\big| \\;\\le\\; \\sup_{x \\in [0, \\mu]} \\big| \\exp(-x) - R_n(x) \\big|,\n$$\n其中 $\\mu$ 是 $\\sigma(tA)$ 在正实轴上实部位置的任意上界。因此，如果 $\\mu$ 很小，低阶CRAM可以达到期望的误差水平；如果 $\\mu$ 很大，则高阶CRAM更可取。\n\n4. 我们通过计算廉价、保守的界来获得 $\\mu$：\n   - Gershgorin圆定理表明，$A$的每个特征值 $\\lambda$ 都位于至少一个以 $a_{ii}$ 为中心、半径为 $R_i = \\sum_{j \\ne i} |a_{ij}|$ 的圆盘内。在正实轴上，对于非负尺度的一个简单界是\n     $$\n     \\mu_G \\;=\\; t \\cdot \\max_{i} \\sum_{j} |a_{ij}|,\n     $$\n     它等于 $t$ 乘以最大绝对行和。这同时捕捉了对角元素和耦合强度。\n   - 算子范数给出\n     $$\n     \\mu_1 \\;=\\; t \\lVert A \\rVert_1, \\quad \\mu_{\\infty} \\;=\\; t \\lVert A \\rVert_{\\infty},\n     $$\n     两者计算成本都很低。为方便和保守起见，可以使用 $\\mu \\;=\\; \\max\\{\\mu_G, \\mu_1, \\mu_{\\infty}\\}$ 或简单地使用 $\\mu_G$（因为 $\\mu_G = t\\lVert A \\rVert_{\\infty}$）。\n   - 在 $\\mu$ 既不大也不小的模糊区域，几轮幂迭代可以在2-范数意义下优化估计：\n     $$\n     v_{k+1} \\;=\\; \\frac{tA\\,v_k}{\\lVert tA\\,v_k \\rVert_2}, \\quad \\mu_{2,\\mathrm{est}} \\;\\approx\\; \\frac{\\lVert tA\\,v_k \\rVert_2}{\\lVert v_k \\rVert_2}.\n     $$\n     这估计了2-范数下的算子范数，对于非正规矩阵具有信息价值。\n\n5. 决策逻辑。选择阈值 $\\tau_{\\mathrm{low}}$ 和 $\\tau_{\\mathrm{high}}$ 以反映CRAM-16和CRAM-32的典型一致误差断点。精确值取决于已发布的极小化极大误差曲线；这里我们设定保守值以捕捉其意图：如果 $\\mu \\le \\tau_{\\mathrm{low}}$，选择CRAM-16；如果 $\\mu \\ge \\tau_{\\mathrm{high}}$，选择CRAM-32；如果 $\\tau_{\\mathrm{low}}  \\mu  \\tau_{\\mathrm{high}}$，则使用优化后的估计 $\\mu_{2,\\mathrm{est}}$ 并将其与一个中间阈值进行比较来决定。与实际构建CRAM-32相比，此方案的计算量微不足道，并且在各种刚性和非正规性条件下都具有鲁棒性。\n\n6. 测试套件覆盖范围：\n   - 测试用例1是一个弱耦合、慢速率系统，且 $t$ 很小，因此 $\\mu$ 非常小，CRAM-16是足够的。\n   - 测试用例2具有非常大的移除率和较小的 $t$，但 $t\\lVert A \\rVert_{\\infty}$ 足够大，为了精度应选择CRAM-32。\n   - 测试用例3使用极小的时间，使步长接近单位阵，倾向于选择CRAM-16。\n   - 测试用例4是非正规矩阵，具有强非对角耦合和中等大小的时间，产生较大的 $\\mu$，倾向于选择CRAM-32。\n   - 测试用例5位于下阈值附近，通过保守界被选择为倾向于CRAM-16。\n\n7. 实现细节。计算 $\\mu_G = t \\max_i \\sum_j |a_{ij}|$ 并与 $\\tau_{\\mathrm{low}}$ 和 $\\tau_{\\mathrm{high}}$ 进行比较。如果需要，运行几次（例如20次）幂迭代来估计 $\\mu_{2,\\mathrm{est}}$ 并与一个中间点阈值进行比较。每个测试用例的最终输出是整数16或32。除了单位为 $\\mathrm{s}^{-1}$ 的矩阵元素和单位为 $\\mathrm{s}$ 的时间外，不打印任何物理量；因此，输出是无量纲的整数。\n\n这种基于原理的选择利用了紧密相连的基础：$\\exp(-tA)$ 在刚性线性反应堆模型中的作用，CRAM在正实轴上的一致有理逼近误差，以及经典的谱界（Gershgorin和算子范数），从而以可忽略的计算开销来决定合适的逼近阶数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gershgorin_row_sum_bound(A: np.ndarray) - float:\n    \"\"\"\n    Compute the maximum absolute row sum of A, which equals the infinity norm ||A||_inf.\n    This serves as a Gershgorin-based bound on the spectral spread relevant to the positive real axis.\n    \"\"\"\n    return np.max(np.sum(np.abs(A), axis=1))\n\ndef power_iteration_norm_estimate(M: np.ndarray, iterations: int = 20, seed: int = 0) - float:\n    \"\"\"\n    Estimate the operator 2-norm of matrix M using power iteration on M^T M implicitly\n    by repeatedly applying M to a vector and measuring amplification.\n    For non-normal matrices this is an estimate; it is inexpensive and often informative.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    v = rng.standard_normal(M.shape[1])\n    v_norm = np.linalg.norm(v)\n    if v_norm == 0.0:\n        v = np.ones(M.shape[1])\n        v_norm = np.linalg.norm(v)\n    v = v / v_norm\n    for _ in range(iterations):\n        w = M @ v\n        w_norm = np.linalg.norm(w)\n        if w_norm == 0.0:\n            # M annihilates v; return zero estimate\n            return 0.0\n        v = w / w_norm\n    # Final amplification factor of the last step as a proxy\n    return np.linalg.norm(M @ v) / np.linalg.norm(v)\n\ndef choose_cram_order(A: np.ndarray, t: float,\n                      tau_low: float = 12.0,\n                      tau_high: float = 30.0,\n                      mid_factor: float = 20.0) - int:\n    \"\"\"\n    Adaptive selection between CRAM-16 and CRAM-32 using cheap spectral proxies.\n\n    Parameters:\n        A: Real square matrix with entries in s^{-1}.\n        t: Time step in seconds.\n        tau_low: Lower threshold for proxy deciding CRAM-16.\n        tau_high: Upper threshold for proxy deciding CRAM-32.\n        mid_factor: Midpoint threshold used with power iteration when proxy is ambiguous.\n\n    Returns:\n        16 or 32 indicating selected CRAM order.\n    \"\"\"\n    # Cheap Gershgorin (infinity norm) bound scaled by t\n    mu_g = t * gershgorin_row_sum_bound(A)\n\n    if mu_g = tau_low:\n        return 16\n    if mu_g = tau_high:\n        return 32\n\n    # Ambiguous region: refine using a few steps of power iteration on t*A\n    M = t * A\n    mu2_est = power_iteration_norm_estimate(M, iterations=20, seed=42)\n\n    # Decide using mid_factor as a middle threshold\n    if mu2_est = mid_factor:\n        return 16\n    else:\n        return 32\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case is (A, t)\n        (\n            np.array([\n                [0.10, -0.02, 0.00],\n                [0.02,  0.07, -0.01],\n                [0.00,  0.01,  0.03]\n            ], dtype=float),\n            0.10\n        ),\n        (\n            np.array([\n                [1e5, -1e3, 0.0, 0.0],\n                [1e3,  1e5, -1e3, 0.0],\n                [0.0,  1e3,  1e5, -1e3],\n                [0.0,  0.0,  1e3,  1e5]\n            ], dtype=float),\n            1e-3\n        ),\n        (\n            np.array([\n                [0.50, -0.20,  0.10,  0.00,  0.00],\n                [0.10,  0.40, -0.15,  0.05,  0.00],\n                [0.00,  0.10,  0.60, -0.25,  0.05],\n                [0.00,  0.00,  0.10,  0.30, -0.10],\n                [0.00,  0.00,  0.00,  0.05,  0.20]\n            ], dtype=float),\n            1e-8\n        ),\n        (\n            np.array([\n                [10.0, -50.0,   0.0],\n                [ 0.0,  10.0, -50.0],\n                [ 0.0,   0.0,  10.0]\n            ], dtype=float),\n            0.60\n        ),\n        (\n            np.array([\n                [5.0, -1.0,  0.0,  0.0,  0.0],\n                [1.0,  5.0, -1.0,  0.0,  0.0],\n                [0.0,  1.0,  5.0, -1.0,  0.0],\n                [0.0,  0.0,  1.0,  5.0, -1.0],\n                [0.0,  0.0,  0.0,  1.0,  5.0]\n            ], dtype=float),\n            1.50\n        )\n    ]\n\n    results = []\n    for A, t in test_cases:\n        order = choose_cram_order(A, t,\n                                  tau_low=12.0,\n                                  tau_high=30.0,\n                                  mid_factor=20.0)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}