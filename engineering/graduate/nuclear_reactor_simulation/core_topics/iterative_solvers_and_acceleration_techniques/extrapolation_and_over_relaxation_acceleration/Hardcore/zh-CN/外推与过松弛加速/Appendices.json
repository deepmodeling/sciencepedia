{
    "hands_on_practices": [
        {
            "introduction": "像理查森外推（Richardson extrapolation）这样的外推技术，其建立基础是假设离散误差遵循一个可预测的模式，通常与网格尺寸的幂次方 $h^p$ 成比例。本练习 () 提供了一种直接的实践方法，通过一系列加密网格上的数值结果来计算观测到的收敛阶 $p$，从而验证这一基本假设。掌握这种分析方法，对于在科学计算中自信地应用和评估外推方法至关重要。",
            "id": "4224934",
            "problem": "在一个针对轻水反应堆堆芯的二维均匀化中子扩散特征值问题中，使用在均匀、几何相似的笛卡尔网格序列上的单元中心有限体积离散化方法来计算有效增殖因子 $k_{\\text{eff}}$。设网格间距为 $h_{1}$、$h_{2}$ 和 $h_{3}$，具有恒定的各向同性加密比 $r$，因此 $h_{2} = h_{1}/r$ 且 $h_{3} = h_{2}/r$。假设该序列处于渐近区，其中 $k_{\\text{eff}}$ 的主阶离散误差形式为 $C h^{p}$，这里 $C$ 是一个非零常数，$p$ 是该离散化方法对 $k_{\\text{eff}}$ 的观测（实验）精度阶。输运物理和材料性质是固定的；序列中只有空间网格发生变化，并且特征值求解被驱动到足够严格的残差容差，使得迭代（求解器）误差与离散误差相比可以忽略不计。\n\n给定以下数据：\n- 各向同性加密比 $r = 2$。\n- 网格尺寸 $h_{1} = 10$ 厘米，$h_{2} = 5$ 厘米，$h_{3} = 2.5$ 厘米。\n- 计算出的有效增殖因子：$k_{\\text{eff}}(h_{1}) = 1.010000$，$k_{\\text{eff}}(h_{2}) = 1.002500$，$k_{\\text{eff}}(h_{3}) = 1.000625$。\n\n从适用于椭圆特征值问题的一致渐近误差模型出发，并且不预先假设 $p$ 的任何特定值，根据三个网格层级和恒定的加密比 $r$ 推导观测阶 $p$ 的表达式，然后根据给定数据计算 $p$。\n\n最后，简要分析——不进行任何进一步的数值计算——如果使用各向异性网格序列（其中 $h_{x}$ 在层级间减半而 $h_{y}$ 保持不变）来代替各向同性加密，考虑到中子通量具有与 $y$ 方向对齐的强边界层，这对 $k_{\\text{eff}}$ 的 Richardson 外推的可靠性有何影响。\n\n仅报告计算出的 $p$ 值作为最终答案，四舍五入到三位有效数字。$p$ 不需要单位。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 问题类型：二维均匀化中子扩散特征值问题。\n- 数值方法：在均匀、几何相似的笛卡尔网格上的单元中心有限体积离散化。\n- 网格间距：$h_{1}$、$h_{2}$、$h_{3}$。\n- 加密比：$r$，满足 $h_{2} = h_{1}/r$ 和 $h_{3} = h_{2}/r$。\n- 渐近误差模型：$k_{\\text{eff}}$ 的主阶离散误差为 $C h^{p}$，其中 $C$ 为非零常数，$p$ 为观测到的精度阶。\n- 求解器误差：与离散误差相比可以忽略不计。\n- 数据：\n  - 各向同性加密比 $r = 2$。\n  - 网格尺寸：$h_{1} = 10$ 厘米，$h_{2} = 5$ 厘米，$h_{3} = 2.5$ 厘米。\n  - 计算出的特征值：$k_{\\text{eff}}(h_{1}) = 1.010000$，$k_{\\text{eff}}(h_{2}) = 1.002500$，$k_{\\text{eff}}(h_{3}) = 1.000625$。\n- 任务：\n  1. 根据三个网格层级和恒定加密比 $r$ 推导观测阶 $p$ 的表达式。\n  2. 根据给定数据计算 $p$。\n  3. 简要分析在各向异性加密下 Richardson 外推对 $k_{\\text{eff}}$ 的可靠性。\n- 最终答案要求：仅报告计算出的 $p$ 值，四舍五入到三位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在计算核工程和数值分析领域具有坚实的科学基础。中子扩散方程、其特征值形式、有限体积法以及通过网格加密研究进行的离散误差分析都是标准的、基础的概念。渐近误差模型是数值分析的基石。\n- **良态的**：该问题是良态的。它为数值解提供了三个数据点，这是从三参数误差模型（$k_{\\text{exact}}$、$C$、$p$）中确定观测精度阶 $p$ 所需的最小数量。可以确定 $p$ 的唯一解。\n- **客观的**：问题陈述以精确、客观和技术性的语言编写，没有任何主观性或偏见。\n- **完整且一致**：所有必要的数据（$h_i$、$k_{\\text{eff}}(h_i)$、$r$）都已提供并且内部一致（例如，对于给定值，$h_{2} = h_{1}/r$ 成立）。该问题是自洽的。\n- **现实且可行**：该设置是反应堆物理模拟中收敛性研究的真实表示。$k_{\\text{eff}}$ 的值对于近临界系统是合理的。\n- **其他缺陷**：该问题不是病态的、微不足道的，或基于任何其他列出的缺陷。\n\n### 步骤 3：结论与行动\n该问题有效。将提供解答。\n\n### 解答推导\n\n分析过程首先推导观测精度阶的公式，计算其值，然后讨论各向异性加密的影响。\n\n设 $k_{\\text{exact}}$ 是有效增殖因子的精确连续值。问题陈述指出，对于足够小的网格间距 $h$，数值计算的特征值 $k(h)$ 可以通过渐近误差展开与精确值相关联。该展开的主阶项为：\n$$k(h) \\approx k_{\\text{exact}} + C h^{p}$$\n其中 $C$ 是一个与 $h$ 无关的常数，$p$ 是数值方法的精度阶。\n\n我们将此模型应用于给定的三个网格层级，其间距分别为 $h_{1}$、$h_{2}$ 和 $h_{3}$：\n1. $k(h_{1}) = k_{\\text{exact}} + C h_{1}^{p}$\n2. $k(h_{2}) = k_{\\text{exact}} + C h_{2}^{p}$\n3. $k(h_{3}) = k_{\\text{exact}} + C h_{3}^{p}$\n\n为了找到 $p$ 的表达式，我们必须消去未知常数 $k_{\\text{exact}}$ 和 $C$。首先，我们通过对连续方程作差来消去 $k_{\\text{exact}}$：\n$$k(h_{1}) - k(h_{2}) = (k_{\\text{exact}} + C h_{1}^{p}) - (k_{\\text{exact}} + C h_{2}^{p}) = C (h_{1}^{p} - h_{2}^{p})$$\n$$k(h_{2}) - k(h_{3}) = (k_{\\text{exact}} + C h_{2}^{p}) - (k_{\\text{exact}} + C h_{3}^{p}) = C (h_{2}^{p} - h_{3}^{p})$$\n\n接下来，我们通过对这两个差分方程求比来消去常数 $C$：\n$$\\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} = \\frac{C (h_{1}^{p} - h_{2}^{p})}{C (h_{2}^{p} - h_{3}^{p})} = \\frac{h_{1}^{p} - h_{2}^{p}}{h_{2}^{p} - h_{3}^{p}}$$\n\n网格间距通过一个恒定的各向同性加密比 $r$ 相关联，使得 $h_{2} = h_{1}/r$ 且 $h_{3} = h_{2}/r = h_{1}/r^{2}$。将这些关系代入方程的右侧，得到：\n$$\\frac{h_{1}^{p} - (h_{1}/r)^{p}}{(h_{1}/r)^{p} - (h_{1}/r^{2})^{p}} = \\frac{h_{1}^{p}(1 - 1/r^{p})}{h_{1}^{p}(1/r^{p} - 1/r^{2p})} = \\frac{1 - r^{-p}}{r^{-p} - r^{-2p}}$$\n为了简化这个分数，我们可以将分子和分母同乘以 $r^{2p}$：\n$$\\frac{r^{2p}(1 - r^{-p})}{r^{2p}(r^{-p} - r^{-2p})} = \\frac{r^{2p} - r^{p}}{r^{p} - 1}$$\n从分子中提出因子 $r^{p}$，得到：\n$$\\frac{r^{p}(r^{p} - 1)}{r^{p} - 1} = r^{p}$$\n\n因此，我们得到了将解的差值之比与精度阶 $p$ 联系起来的表达式：\n$$\\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} = r^{p}$$\n为了求解 $p$，我们对两边取自然对数：\n$$\\ln\\left( \\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} \\right) = \\ln(r^{p}) = p \\ln(r)$$\n这给出了观测精度阶的最终表达式：\n$$p = \\frac{\\ln\\left( \\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} \\right)}{\\ln(r)}$$\n\n现在，我们使用所提供的数据来计算 $p$：\n- 加密比：$r = 2$。\n- 特征值：$k(h_{1}) = 1.010000$，$k(h_{2}) = 1.002500$，$k(h_{3}) = 1.000625$。\n\n首先，计算特征值的差值：\n$$k(h_{1}) - k(h_{2}) = 1.010000 - 1.002500 = 0.007500$$\n$$k(h_{2}) - k(h_{3}) = 1.002500 - 1.000625 = 0.001875$$\n接下来，计算这些差值的比率：\n$$\\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} = \\frac{0.007500}{0.001875} = 4$$\n最后，将此结果和 $r$ 的值代入 $p$ 的公式中：\n$$p = \\frac{\\ln(4)}{\\ln(2)} = \\frac{\\ln(2^{2})}{\\ln(2)} = \\frac{2 \\ln(2)}{\\ln(2)} = 2$$\n观测到的精度阶恰好为 $2$。对于扩散方程，在笛卡尔网格上使用单元中心有限体积法预期为二阶精度，因此该结果与理论一致。四舍五入到三位有效数字得到 $2.00$。\n\n### 各向异性加密分析\nRichardson 外推是一种通过组合不同网格层级的结果来提高数值解精度的方法。它从根本上依赖于存在一个形式为 $A(h) = A_{\\text{exact}} + C h^{p} + O(h^{p+q})$ 的良态渐近误差级数，其中 $h$ 是代表趋于零的网格间距的单个参数。\n\n在各向异性加密的情况下，即网格间距 $h_{x}$ 被加密而 $h_{y}$ 保持不变，这个基本假设被违反了。离散误差不再是单个参数 $h$ 的函数，而是 $h_{x}$ 和 $h_{y}$ 两者的函数。主阶误差模型将采用以下形式：\n$$E(h_{x}, h_{y}) \\approx C_{x} h_{x}^{p_x} + C_{y} h_{y}^{p_y}$$\n因此，计算出的特征值为 $k(h_{x}, h_{y}) \\approx k_{\\text{exact}} + C_{x} h_{x}^{p_x} + C_{y} h_{y}^{p_y}$。\n\n如果通过将 $h_{x}$ 减半同时保持 $h_{y}$ 不变来生成网格序列，计算出的特征值的行为将如下：\n$$k(h_{x}) \\approx (k_{\\text{exact}} + C_{y} h_{y}^{p_y}) + C_{x} h_{x}^{p_x}$$\n当 $h_{x} \\rightarrow 0$ 时，解序列 $k(h_x)$ 不会收敛到真实的连续特征值 $k_{\\text{exact}}$。相反，它会收敛到一个有偏差的值 $k_{\\text{exact}} + C_{y} h_{y}^{p_y}$，其中偏差 $E_{\\text{bias}} = C_{y} h_{y}^{p_y}$ 是来自未加密的 $y$ 方向的非消失误差分量。\n\n中子通量具有与 $y$ 方向对齐的强边界层这一事实意味着在 $x$ 方向上存在大梯度，这使得在 $x$ 方向上的加密至关重要。然而，这并不意味着 $y$ 方向上的梯度为零。即使 $y$ 方向的梯度较小，固定的、可能显著的误差贡献 $E_{\\text{bias}}$ 仍将存在。\n\n当应用于此序列时，Richardson 外推只会抵消依赖于 $h_{x}$ 的主误差项，但它会外推到一个不正确的、有偏差的极限。因此，Richardson 外推的可靠性受到严重损害。它会产生一个相对于 $x$ 方向离散化更准确的结果，但由于受到来自 $y$ 方向离散化的固定误差的污染，它将无法收敛到真实的物理解决方案。该过程将存在根本性的缺陷。\n\n要求的最终答案仅为 $p$ 的数值。精确值为 $p=2$。四舍五入到三位有效数字，即为 $2.00$。",
            "answer": "$$\\boxed{2.00}$$"
        },
        {
            "introduction": "在处理像中子通量这样的矢量时，一个常见的直觉是将其分量视作独立的标量序列，并逐一进行加速。本练习 () 使用艾特肯（Aitken） $\\Delta^2$ 方法，深入剖析了这种直观方法的潜在缺陷。通过分析一个简单的二维系统，您将揭示多模式误差的存在如何违反该方法几何收敛的核心假设，从而导致结果不可靠甚至适得其反。",
            "id": "4224951",
            "problem": "考虑一个一维均匀板式反应堆，其通过多群中子扩散方程建模，并离散为两个空间自由度，得到第 $n$ 次迭代时的向量中子通量 $\\boldsymbol{\\phi}^{(n)} \\in \\mathbb{R}^2$。标准的源迭代方法寻求一个线性映射的不动点，其抽象形式写作 $\\boldsymbol{\\phi}^{(n+1)} = \\mathbf{M}\\,\\boldsymbol{\\phi}^{(n)} + \\boldsymbol{s}$，其中 $\\mathbf{M}$ 是由散射和扩散引起的迭代算子，$\\boldsymbol{s}$ 是一个固定源。对于这类线性不动点迭代，相对于不动点 $\\boldsymbol{\\phi}^\\star$ 的误差 $\\boldsymbol{e}^{(n)} = \\boldsymbol{\\phi}^{(n)} - \\boldsymbol{\\phi}^\\star$ 按照 $\\boldsymbol{e}^{(n+1)} = \\mathbf{M}\\,\\boldsymbol{e}^{(n)}$ 传播，且对于可对角化的 $\\mathbf{M}$，误差可以进行模态分解 $\\boldsymbol{e}^{(n)} = \\sum_{j} c_j \\lambda_j^n \\boldsymbol{v}_j$，其中 $\\lambda_j$ 和 $\\boldsymbol{v}_j$ 是 $\\mathbf{M}$ 的特征值和特征向量。\n\n假设通过源迭代产生的中子通量的连续三次迭代结果为\n$$\n\\boldsymbol{\\phi}^{(0)} = \\begin{bmatrix} 4.0 \\\\ -2.0 \\end{bmatrix},\\quad\n\\boldsymbol{\\phi}^{(1)} = \\begin{bmatrix} 1.85 \\\\ 0.05 \\end{bmatrix},\\quad\n\\boldsymbol{\\phi}^{(2)} = \\begin{bmatrix} 1.1725 \\\\ 0.6325 \\end{bmatrix}.\n$$\n一位工程师建议通过对这三次迭代结果逐分量应用 Aitken $\\Delta^2$ 外推法来加速收敛——即，将 $\\boldsymbol{\\phi}^{(n)}$ 的每个元素视为一个独立的标量序列，并分别为每个分量形成加速估计值——然后从这个加速后的向量估计值继续进行迭代。\n\n基于基本误差传播模型 $\\boldsymbol{e}^{(n+1)} = \\mathbf{M}\\,\\boldsymbol{e}^{(n)}$ 和线性迭代的模态分解，回答以下问题：\n\n1. 使用以上数据，计算逐分量的 Aitken $\\Delta^2$ 加速估计值 $\\boldsymbol{\\phi}^{(\\mathrm{A})}$。\n2. 选择与关于中子通量分布中的误差模态以及逐分量 Aitken 外推法行为的第一性原理推断最相符的陈述。\n\n选项：\n\nA. 使用所提供的数据，逐分量的 Aitken $\\Delta^2$ 加速估计值约为 $\\boldsymbol{\\phi}^{(\\mathrm{A})} \\approx \\begin{bmatrix} 0.858 \\\\ 0.865 \\end{bmatrix}$；这可能会使第二个分量的结果恶化，因为每个分量通常是误差模态的叠加，所以作为 Aitken 方法基础的标量几何收敛假设在逐分量应用时可能不成立。\n\nB. 对于任何谱半径小于1的线性源迭代，逐分量的 Aitken $\\Delta^2$ 方法在两步之后总能减小误差的欧几里得范数。\n\nC. 只要主导误差模态具有严格最大的特征值，无论该模态如何投影到各个分量上，逐分量的 Aitken $\\Delta^2$ 方法总能在两步内产生精确的不动点解。\n\nD. 在反应堆模拟中，一个更稳妥的替代方法是（通过投影）从连续的差分中提取主导的空间误差模态，并对该模态的振幅应用标量 Aitken 方法；这种方法针对收敛最慢的模态，并避免了混合分量加速的陷阱。\n\n选择所有适用项。",
            "solution": "用户希望我解决一个关于核反应堆模拟中数值加速方法的问题。\n\n### 问题验证\n\n我将首先根据指定标准验证问题陈述。\n\n**步骤1：提取已知条件**\n- 背景是一个通过多群中子扩散方程建模的一维均匀板式反应堆。\n- 离散化后的系统产生一个在第 $n$ 次迭代时的向量中子通量 $\\boldsymbol{\\phi}^{(n)} \\in \\mathbb{R}^2$。\n- 迭代格式是线性不动点迭代（源迭代）：$\\boldsymbol{\\phi}^{(n+1)} = \\mathbf{M}\\,\\boldsymbol{\\phi}^{(n)} + \\boldsymbol{s}$。\n- 误差传播由 $\\boldsymbol{e}^{(n+1)} = \\mathbf{M}\\,\\boldsymbol{e}^{(n)}$ 给出，其中 $\\boldsymbol{e}^{(n)} = \\boldsymbol{\\phi}^{(n)} - \\boldsymbol{\\phi}^\\star$。\n- 对于可对角化的 $\\mathbf{M}$，误差有一个模态分解 $\\boldsymbol{e}^{(n)} = \\sum_{j} c_j \\lambda_j^n \\boldsymbol{v}_j$。\n- 提供了连续三次的迭代结果：\n$$\n\\boldsymbol{\\phi}^{(0)} = \\begin{bmatrix} 4.0 \\\\ -2.0 \\end{bmatrix},\\quad\n\\boldsymbol{\\phi}^{(1)} = \\begin{bmatrix} 1.85 \\\\ 0.05 \\end{bmatrix},\\quad\n\\boldsymbol{\\phi}^{(2)} = \\begin{bmatrix} 1.1725 \\\\ 0.6325 \\end{bmatrix}.\n$$\n- 任务是计算逐分量的 Aitken $\\Delta^2$ 加速估计值 $\\boldsymbol{\\phi}^{(\\mathrm{A})}$ 并评估关于该过程的几个陈述。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据充分**：该问题在核反应堆物理数值方法领域有充分的依据。源迭代法、误差的模态分析和 Aitken 的 $\\Delta^2$ 外推法都是标准且成熟的概念。\n- **适定性**：该问题是适定的。提供的数据足以执行所需的计算。所提问题是精确的，并且可以使用提供的数据和数值线性代数的第一性原理来回答。\n- **客观性**：问题陈述是客观的，并使用了精确的技术语言。\n- **完整性与一致性**：问题是自洽的，没有矛盾。\n- **真实性**：该设置是反应堆分析中一个数值问题的简化但标准的表示。数值是人为设计的但看起来合理。\n\n**步骤3：结论与行动**\n问题是**有效的**。我将继续进行推导和分析。\n\n### 解题推导\n\n问题需要完成两个主要任务：首先，计算逐分量的 Aitken $\\Delta^2$ 加速估计值；其次，在底层误差模态传播的背景下分析该方法的行为。\n\n**1. 逐分量 Aitken $\\Delta^2$ 估计值的计算**\n\nAitken 的 $\\Delta^2$ 外推法利用一个标量序列 $\\{x_n\\}_{n=0}^\\infty$ 的连续三项 $x_0$、$x_1$ 和 $x_2$ 来估计其极限 $x^\\star$。公式为：\n$$ x^{(\\mathrm{A})} = x_0 - \\frac{(\\Delta x_0)^2}{\\Delta^2 x_0} = x_0 - \\frac{(x_1 - x_0)^2}{x_2 - 2x_1 + x_0} $$\n我们将此公式独立地应用于向量序列 $\\boldsymbol{\\phi}^{(n)}$ 的每个分量。\n\n**第一个分量 ($\\phi_1$):**\n序列为 $\\phi_1^{(0)} = 4.0$，$\\phi_1^{(1)} = 1.85$，$\\phi_1^{(2)} = 1.1725$。\n\n首先，我们计算前向差分：\n- $\\Delta \\phi_1^{(0)} = \\phi_1^{(1)} - \\phi_1^{(0)} = 1.85 - 4.0 = -2.15$\n- $\\Delta \\phi_1^{(1)} = \\phi_1^{(2)} - \\phi_1^{(1)} = 1.1725 - 1.85 = -0.6775$\n\n接下来，我们计算二阶前向差分：\n- $\\Delta^2 \\phi_1^{(0)} = \\Delta \\phi_1^{(1)} - \\Delta \\phi_1^{(0)} = -0.6775 - (-2.15) = 1.4725$\n\n现在，我们应用 Aitken 公式：\n$$ \\phi_1^{(\\mathrm{A})} = \\phi_1^{(0)} - \\frac{(\\Delta \\phi_1^{(0)})^2}{\\Delta^2 \\phi_1^{(0)}} = 4.0 - \\frac{(-2.15)^2}{1.4725} = 4.0 - \\frac{4.6225}{1.4725} \\approx 4.0 - 3.139219 = 0.860781 $$\n\n**第二个分量 ($\\phi_2$):**\n序列为 $\\phi_2^{(0)} = -2.0$，$\\phi_2^{(1)} = 0.05$，$\\phi_2^{(2)} = 0.6325$。\n\n首先，我们计算前向差分：\n- $\\Delta \\phi_2^{(0)} = \\phi_2^{(1)} - \\phi_2^{(0)} = 0.05 - (-2.0) = 2.05$\n- $\\Delta \\phi_2^{(1)} = \\phi_2^{(2)} - \\phi_2^{(1)} = 0.6325 - 0.05 = 0.5825$\n\n接下来，我们计算二阶前向差分：\n- $\\Delta^2 \\phi_2^{(0)} = \\Delta \\phi_2^{(1)} - \\Delta \\phi_2^{(0)} = 0.5825 - 2.05 = -1.4675$\n\n现在，我们应用 Aitken 公式：\n$$ \\phi_2^{(\\mathrm{A})} = \\phi_2^{(0)} - \\frac{(\\Delta \\phi_2^{(0)})^2}{\\Delta^2 \\phi_2^{(0)}} = -2.0 - \\frac{(2.05)^2}{-1.4675} = -2.0 + \\frac{4.2025}{1.4675} \\approx -2.0 + 2.863714 = 0.863714 $$\n\n因此，逐分量的 Aitken 加速估计值为 $\\boldsymbol{\\phi}^{(\\mathrm{A})} \\approx \\begin{bmatrix} 0.8608 \\\\ 0.8637 \\end{bmatrix}$。\n\n**2. 原理与选项分析**\n\nAitken 的 $\\Delta^2$ 方法的推导假设是序列的误差 $e_n = x_n - x^\\star$ 呈几何级数行为，即对于一个常数收敛比 $\\lambda$，有 $e_{n+1} = \\lambda e_n$。在向量迭代 $\\boldsymbol{e}^{(n+1)} = \\mathbf{M} \\boldsymbol{e}^{(n)}$ 的背景下，误差是多个模态的叠加：$\\boldsymbol{e}^{(n)} = \\sum_{j} c_j \\lambda_j^n \\boldsymbol{v}_j$。\n\n要使逐分量的误差 $e_i^{(n)}$ 呈几何级数，总向量误差 $\\boldsymbol{e}^{(n)}$ 必须由单个模态主导，即 $\\boldsymbol{e}^{(n)} \\approx c_1 \\lambda_1^n \\boldsymbol{v}_1$。如果存在一个严格的主导特征值 $|\\lambda_1| > |\\lambda_2| \\ge \\dots$，这种情况会在 $n \\to \\infty$ 时渐近发生。如果有多个模态都很显著（例如，在迭代初期或特征值大小相近时），比率 $e_i^{(n+1)}/e_i^{(n)}$ 不是常数，Aitken 方法的假设就被违反了。\n\n我们来检查给定的迭代是否由单个模态主导。如果是的话，差分向量 $\\boldsymbol{d}^{(n)} = \\boldsymbol{\\phi}^{(n+1)} - \\boldsymbol{\\phi}^{(n)}$ 将满足 $\\boldsymbol{d}^{(n+1)} \\approx \\lambda_1 \\boldsymbol{d}^{(n)}$。我们来计算差分向量：\n$$ \\boldsymbol{d}^{(0)} = \\boldsymbol{\\phi}^{(1)} - \\boldsymbol{\\phi}^{(0)} = \\begin{bmatrix} 1.85 - 4.0 \\\\ 0.05 - (-2.0) \\end{bmatrix} = \\begin{bmatrix} -2.15 \\\\ 2.05 \\end{bmatrix} $$\n$$ \\boldsymbol{d}^{(1)} = \\boldsymbol{\\phi}^{(2)} - \\boldsymbol{\\phi}^{(1)} = \\begin{bmatrix} 1.1725 - 1.85 \\\\ 0.6325 - 0.05 \\end{bmatrix} = \\begin{bmatrix} -0.6775 \\\\ 0.5825 \\end{bmatrix} $$\n我们来逐分量计算比率 $\\boldsymbol{d}^{(1)} / \\boldsymbol{d}^{(0)}$：\n- 分量1的比率：$\\frac{-0.6775}{-2.15} \\approx 0.3151$\n- 分量2的比率：$\\frac{0.5825}{2.05} \\approx 0.2841$\n两个比率不相等。这明确证明了误差不是由单个模态主导的；至少有两个具有不同特征值的误差模态是显著的。因此，应用逐分量的 Aitken 方法并不能保证有效。\n\n现在我们评估每个选项：\n\n**选项A**：使用所提供的数据，逐分量的 Aitken $\\Delta^2$ 加速估计值约为 $\\boldsymbol{\\phi}^{(\\mathrm{A})} \\approx \\begin{bmatrix} 0.858 \\\\ 0.865 \\end{bmatrix}$；这可能会使第二个分量的结果恶化，因为每个分量通常是误差模态的叠加，所以作为 Aitken 方法基础的标量几何收敛假设在逐分量应用时可能不成立。\n- 计算出的估计值 $\\boldsymbol{\\phi}^{(\\mathrm{A})} \\approx \\begin{bmatrix} 0.8608 \\\\ 0.8637 \\end{bmatrix}$ 与选项中给出的值非常接近。微小的差异（$0.4\\%$）可能是由于问题表述中的四舍五入造成的。计算结果是一致的。\n- 其推理完全正确。如上所示，误差是至少两个模态的叠加。这违反了每个分量标量序列的几何收敛假设。当此假设被违反时，Aitken 方法不保证能加速收敛，甚至可能产生更差的估计（即增加误差）。\n- **结论**：**正确**。\n\n**选项B**：对于任何谱半径小于1的线性源迭代，逐分量的 Aitken $\\Delta^2$ 方法在两步之后总能减小误差的欧几里得范数。\n- 这个陈述是错误的。“总是”这个限定词太强了。如选项A中所解释，当几何收敛的基本假设不满足时，该方法可能会失败并增加误差。谱半径 $\\rho(\\mathbf{M})  1$ 保证了基础迭代会收敛，但这并不保证任何特定的加速尝试都会成功，尤其是在多个模态同时存在的迭代初期。我们可以构建简单的标量反例，其中 Aitken 方法会增加误差的大小，然后可以将其嵌入到向量问题中。\n- **结论**：**不正确**。\n\n**选项C**：只要主导误差模态具有严格最大的特征值，无论该模态如何投影到各个分量上，逐分量的 Aitken $\\Delta^2$ 方法总能在两步内产生精确的不动点解。\n- 这个陈述是错误的。Aitken 方法只有在序列是*完全*几何级数时才能得出精确解。存在严格主导特征值仅能保证序列*渐近地*趋于几何级数。次主导模态仍然存在，意味着误差是 $\\boldsymbol{e}^{(n)} = c_1 \\lambda_1^n \\boldsymbol{v}_1 + \\text{次主导项}$。除非初始误差 $\\boldsymbol{e}^{(0)}$ 恰好是一个纯特征向量 $\\boldsymbol{v}_1$（使得所有其他的 $c_j=0$），否则该方法不会产生精确解。\n- **结论**：**不正确**。\n\n**选项D**：在反应堆模拟中，一个更稳妥的替代方法是（通过投影）从连续的差分中提取主导的空间误差模态，并对该模态的振幅应用标量 Aitken 方法；这种方法针对收敛最慢的模态，并避免了混合分量加速的陷阱。\n- 这个陈述描述了一种模态加速方法，这是一种更复杂、更稳健的方法。主导误差模态（与模最大的特征值 $\\lambda_1$ 相关）决定了整体（最慢）的收敛速度。通过估计该模态的形状（例如，从 $\\boldsymbol{\\phi}^{(n+1)} - \\boldsymbol{\\phi}^{(n)}$），并将误差投影到这个形状上，就可以追踪这个单一模态的标量振幅。得到的这个振幅标量序列比原始的 $\\boldsymbol{\\phi}^{(n)}$ 分量值（它是所有模态的混合）更有可能表现出几何收敛性。因此，对这个振幅序列应用 Aitken 方法更加可靠和“稳妥”，因为它避免了因违反几何假设而产生的“混合分量加速的陷阱”。这种方法在概念上与诸如粗网格重新平衡（Coarse Mesh Rebalance, CMR）和综合加速等强大技术相关。\n- **结论**：**正确**。",
            "answer": "$$\\boxed{AD}$$"
        },
        {
            "introduction": "理论和简单的例子固然有价值，但一个加速方法的真正考验是其在复杂、大规模模拟中的表现。这个综合性练习 () 要求您实现一个完整的三维反应堆瞬态模拟，并量化外推方法带来的计算收益。通过比较迭代求解器中零阶、线性和二次外推初值策略的性能，您将对算法复杂性与计算效率之间的关键权衡获得切实的理解。",
            "id": "4224950",
            "problem": "考虑一个由控制棒抽出驱动的简化的三维全堆芯核反应堆瞬态过程，该过程由速度标度单群中子扩散方程建模。从输运到扩散的简化和速度标度出发，我们假设中子通量 $ \\phi(\\mathbf{x},t) $ 的控制方程为\n$$ \\frac{\\partial \\phi}{\\partial t} = \\alpha \\nabla^2 \\phi - \\beta(\\mathbf{x},t) \\phi + s(\\mathbf{x}), $$\n其中 $ \\alpha $ 是有效扩散系数（单位为 $\\text{cm}^2/\\text{s}$），$ \\beta(\\mathbf{x},t) $ 是有效吸收率（单位为 $ \\text{s}^{-1} $），由于控制棒运动而随时间变化，$ s(\\mathbf{x}) $ 是一个固定的外部源（其单位与方程一致，使得所有项的和以 $ \\text{s}^{-1} $ 为单位）。该方程定义在一个长方体区域 $ \\Omega = [0,L_x] \\times [0,L_y] \\times [0,L_z] $ 上，具有齐次狄利克雷（零通量）边界条件和内部点的均匀笛卡尔网格。初始条件为 $ \\phi(\\mathbf{x},0) = 0 $。\n\n控制棒抽出由一个局部区域 $ R \\subset \\Omega $（一个贯穿轴向的中心方柱体）表示，在该区域内 $ \\beta(\\mathbf{x},t) $ 在瞬态持续时间 $ T $ 内随时间线性减小，而在 $ R $ 外部则保持不变。具体来说，\n$$ \\beta(\\mathbf{x},t) = \\beta_0 + \\Delta \\beta \\left( 1 - \\frac{t}{T} \\right) \\chi_R(\\mathbf{x}), \\quad 0 \\le t \\le T, $$\n其中 $ \\beta_0 $ 是基础吸收率，$ \\Delta \\beta > 0 $ 是由于插入的控制棒引起的初始过剩吸收，$ \\chi_R $ 是控制棒区域的特征函数（如果 $ \\mathbf{x} \\in R $ 则 $ \\chi_R(\\mathbf{x}) = 1 $，否则为 $ 0 $）。这通过随时间减少 $ R $ 区域内的吸收来实现控制棒的抽出。\n\n在步长为 $ \\Delta t $ 的均匀时间网格上使用后向欧拉法对时间进行离散，并在内部网格点上使用标准二阶中心有限差分格式对空间拉普拉斯算子进行离散，在外部施加零通量边界值。这导致在每个时间步长上，得到一个如下形式的线性系统\n$$ \\left( I - \\Delta t \\, \\alpha \\, L + \\Delta t \\, \\mathrm{diag}(\\beta^{n+1}) \\right) \\, \\phi^{n+1} = \\phi^{n} + \\Delta t \\, s, $$\n其中 $ L $ 是离散拉普拉斯算子，$ \\beta^{n+1} $ 是空间场 $ \\beta(\\cdot,t^{n+1}) $。使用松弛参数为 $ \\omega $ 的逐次超松弛（SOR）方法求解每个线性系统。\n\n为了在每个时间步加速收敛，使用从先前时间步外推得到的初始猜测值 $ \\phi^{n+1,(0)} $ 进行SOR迭代：\n- 线性外推：对于 $ n \\ge 1 $，有 $ \\phi^{n+1,(0)} = \\phi^n + (\\phi^n - \\phi^{n-1}) $，且 $ \\phi^{1,(0)} = \\phi^0 $。\n- 二次外推：对于 $ n \\ge 2 $，有 $ \\phi^{n+1,(0)} = \\phi^n + (\\phi^n - \\phi^{n-1}) + \\tfrac{1}{2} (\\phi^n - 2 \\phi^{n-1} + \\phi^{n-2}) $，对于 $ n = 1 $ 回退到线性外推，对于 $ n = 0 $ 回退到 $ \\phi^0 $。\n\n定量目标是比较线性外推与二次外推在控制棒抽出瞬态过程中的表现，并衡量计算成本与精度之间的权衡。使用以下科学上合理且自洽的参数：\n- 区域长度：$ L_x = L_y = L_z = 100 \\, \\text{cm} $。\n- 内部网格点：$ N_x = 10 $，$ N_y = 10 $，$ N_z = 6 $。使用均匀间距 $ h_x = \\frac{L_x}{N_x+1} $，$ h_y = \\frac{L_y}{N_y+1} $，$ h_z = \\frac{L_z}{N_z+1} $。\n- 有效扩散系数：$ \\alpha = 0.5 \\, \\text{cm}^2/\\text{s} $。\n- 基础吸收率：$ \\beta_0 = 0.08 \\, \\text{s}^{-1} $。\n- 控制棒区域的初始过剩吸收：$ \\Delta \\beta = 0.04 \\, \\text{s}^{-1} $。\n- 瞬态持续时间：$ T = 0.2 \\, \\text{s} $。\n- 外部源：$ s(\\mathbf{x}) \\equiv s_0 = 0.02 $（单位经选择以与方程保持一致）。该源在空间上是均匀的。\n- 控制棒区域 $ R $：$x$-$y$ 平面内一个中心的 $ 3 \\times 3 $ 内部网格单元正方形，贯穿所有 $z$ 平面。\n\n实现SOR方法，其停止准则为每次迭代的最大绝对变化量小于容差 $ \\varepsilon = 10^{-5} $，或者达到每个时间步长 $ N_{\\max} = 100 $ 次SOR迭代的硬性上限。统计并报告在所有时间步长上累积的总SOR迭代次数，作为计算成本的代理指标。为了评估精度，计算最终时刻通量场相对于一个更高精度参考解的相对离散 $ L^2 $ 误差：\n$$ \\mathrm{err} = \\frac{\\left\\| \\phi_{\\text{case}}^{\\text{final}} - \\phi_{\\text{ref}}^{\\text{final}} \\right\\|_2}{\\left\\| \\phi_{\\text{ref}}^{\\text{final}} \\right\\|_2}, $$\n其中 $ L^2 $ 范数使用内部网格点上的未加权欧几里得范数。\n\n使用时间步长 $ \\Delta t_{\\text{ref}} = 0.005 \\, \\text{s} $（即 $ N_{\\text{ref}} = 40 $ 步达到 $ T $），并采用二次外推和 $ \\omega = 1.9 $ 来构建参考解。\n\n您的程序必须运行以下参数组合的测试套件（每个都达到 $ T = 0.2 \\, \\text{s} $），为每个组合计算 $ \\mathrm{err} $ 和总SOR迭代次数，并按指定格式生成输出：\n1. 情况 1：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，线性外推，$ \\omega = 1.7 $。\n2. 情况 2：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，二次外推，$ \\omega = 1.7 $。\n3. 情况 3：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，无外推（初始猜测 $ \\phi^{n+1,(0)} = \\phi^n $），$ \\omega = 1.7 $。\n4. 情况 4：$ \\Delta t = 0.02 \\, \\text{s} $，$ N = 10 $，二次外推，$ \\omega = 1.7 $。\n5. 情况 5：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，二次外推，$ \\omega = 1.3 $。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，顺序为 $ [\\mathrm{err}_1, I_1, \\mathrm{err}_2, I_2, \\mathrm{err}_3, I_3, \\mathrm{err}_4, I_4, \\mathrm{err}_5, I_5] $，其中 $ \\mathrm{err}_k $ 是情况 $ k $ 的相对误差（以小数形式表示），$ I_k $ 是情况 $ k $ 的总整数SOR迭代次数。时间以秒为单位报告，角度（若有）以弧度为单位报告；此处不使用角度。所有浮点输出必须是小数形式，不带百分号，如所规定。",
            "solution": "所提供的问题是计算物理领域中一个有效且适定的练习，特别是在核反应堆瞬态的数值模拟方面。它要求实现并比较用于求解含时偏微分方程的不同数值方案。所有参数均已提供，物理模型是标准的简化模型（单群扩散），数值方法（后向欧拉法、有限差分法、SOR法）也适合该任务。目标清晰且可量化衡量。\n\n我们首先将数值方案形式化。控制方程是速度标度单群中子扩散方程：\n$$ \\frac{\\partial \\phi}{\\partial t} = \\alpha \\nabla^2 \\phi - \\beta(\\mathbf{x},t) \\phi + s(\\mathbf{x}) $$\n该方程定义在区域 $ \\Omega = [0,L_x] \\times [0,L_y] \\times [0,L_z] $ 上，具有零通量边界条件 $ \\phi(\\mathbf{x},t)|_{\\partial\\Omega} = 0 $ 和零通量初始条件 $ \\phi(\\mathbf{x},0) = 0 $。\n\n时间导数在均匀时间网格 $ t^n = n \\Delta t $ 上使用一阶精度的后向欧拉法进行离散：\n$$ \\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = \\alpha \\nabla^2 \\phi^{n+1} - \\beta^{n+1} \\phi^{n+1} + s $$\n其中上标表示时间步索引，例如 $ \\phi^n \\equiv \\phi(\\mathbf{x}, t^n) $。重新排列各项，将未知量 $ \\phi^{n+1} $ 放在左侧，得到：\n$$ (1 + \\Delta t \\beta^{n+1}) \\phi^{n+1} - \\Delta t \\alpha \\nabla^2 \\phi^{n+1} = \\phi^n + \\Delta t s $$\n这是一个关于 $ \\phi^{n+1} $ 的椭圆型偏微分方程，必须在每个时间步求解。\n\n空间域在均匀笛卡尔网格上离散，各轴分别有 $ N_x, N_y, N_z $ 个内部点。网格间距为 $ h_x = L_x/(N_x+1) $，$ h_y = L_y/(N_y+1) $ 和 $ h_z = L_z/(N_z+1) $。拉普拉斯算子 $ \\nabla^2 $ 使用标准二阶中心有限差分格式进行近似。在内部网格点 $ (i,j,k) $ 处，其形式为：\n$$ \\nabla^2 \\phi \\approx \\frac{\\phi_{i-1,j,k} - 2\\phi_{i,j,k} + \\phi_{i+1,j,k}}{h_x^2} + \\frac{\\phi_{i,j-1,k} - 2\\phi_{i,j,k} + \\phi_{i,j+1,k}}{h_y^2} + \\frac{\\phi_{i,j,k-1} - 2\\phi_{i,j,k} + \\phi_{i,j,k+1}}{h_z^2} $$\n将此代入时间离散化的方程，我们得到一个关于所有内部网格点上 $ \\phi^{n+1} $ 值的大型稀疏线性方程组。对于一个特定的点 $ (i,j,k) $，方程为：\n$$ \\left(1 + \\Delta t \\beta_{i,j,k}^{n+1} + 2\\alpha\\Delta t \\left(\\frac{1}{h_x^2} + \\frac{1}{h_y^2} + \\frac{1}{h_z^2}\\right)\\right)\\phi_{i,j,k}^{n+1} - \\frac{\\alpha\\Delta t}{h_x^2}(\\phi_{i-1,j,k}^{n+1} + \\phi_{i+1,j,k}^{n+1}) - \\dots = \\phi_{i,j,k}^n + \\Delta t s_{i,j,k} $$\n该系统可以写成矩阵形式 $ \\mathbf{A}\\boldsymbol{\\phi}^{n+1} = \\mathbf{b} $，其中 $ \\boldsymbol{\\phi}^{n+1} $ 是未知通量值的向量，$ \\mathbf{A} $ 是一个大型、稀疏且结构化的矩阵，$ \\mathbf{b} $ 是由前一时间步的已知量组成的右端向量。矩阵 $ \\mathbf{A} $ 是对称正定的，这保证了当松弛参数 $ \\omega \\in (0,2) $ 时，逐次超松弛（SOR）方法的收敛性。\n\nSOR方法是一种迭代求解器。对于每个点 $ (i,j,k) $，我们根据其邻近点的当前值计算一个更新值。SOR的更新规则是：\n$$ \\phi_{i,j,k}^{(m+1)} = (1-\\omega)\\phi_{i,j,k}^{(m)} + \\omega \\phi_{i,j,k}^{\\text{GS}} $$\n其中 $ (m) $ 是SOR迭代索引，$ \\omega $ 是松弛参数，$ \\phi_{i,j,k}^{\\text{GS}} $ 是Gauss-Seidel更新：\n$$ \\phi_{i,j,k}^{\\text{GS}} = \\frac{1}{D_{i,j,k}} \\left( \\phi_{i,j,k}^n + \\Delta t s_{i,j,k} + \\frac{\\alpha\\Delta t}{h_x^2}(\\phi_{i-1,j,k}^{(m+1)} + \\phi_{i+1,j,k}^{(m)}) + \\frac{\\alpha\\Delta t}{h_y^2}(\\phi_{i,j-1,k}^{(m+1)} + \\phi_{i,j+1,k}^{(m)}) + \\frac{\\alpha\\Delta t}{h_z^2}(\\phi_{i,j,k-1}^{(m+1)} + \\phi_{i,j,k+1}^{(m)}) \\right) $$\n此处，$ D_{i,j,k} $ 是矩阵 $ \\mathbf{A} $ 在点 $ (i,j,k) $ 处的对角元素：\n$$ D_{i,j,k} = 1 + \\Delta t \\beta_{i,j,k}^{n+1} + 2\\alpha\\Delta t \\left(\\frac{1}{h_x^2} + \\frac{1}{h_y^2} + \\frac{1}{h_z^2}\\right) $$\nGauss-Seidel更新使用可用的最新值；当以字典序遍历网格时，这意味着对索引较小的邻居使用迭代 $ (m+1) $ 的值，对索引较大的邻居使用迭代 $ (m) $ 的值。这通过原地更新通量数组来实现。\n\nSOR求解器的效率在很大程度上取决于初始猜测值 $ \\boldsymbol{\\phi}^{n+1,(0)} $。一个更接近最终解的猜测值可以减少收敛所需的迭代次数。我们比较三种初始猜测策略：\n1.  无外推（或零阶）：$ \\boldsymbol{\\phi}^{n+1,(0)} = \\boldsymbol{\\phi}^n $。这假设解与前一时间步相比变化不大。\n2.  线性外推（一阶）：$ \\boldsymbol{\\phi}^{n+1,(0)} = \\boldsymbol{\\phi}^n + (\\boldsymbol{\\phi}^n - \\boldsymbol{\\phi}^{n-1}) $。这利用最近两个时间步的趋势将解向前外推。它等价于时间上的一阶泰勒展开。\n3.  二次外推（二阶）：$ \\boldsymbol{\\phi}^{n+1,(0)} = \\boldsymbol{\\phi}^n + (\\boldsymbol{\\phi}^n - \\boldsymbol{\\phi}^{n-1}) + \\frac{1}{2}(\\boldsymbol{\\phi}^n - 2\\boldsymbol{\\phi}^{n-1} + \\boldsymbol{\\phi}^{n-2}) $。这利用最近三个时间步的信息进行更精确的、基于二阶泰勒的预测。\n\n实现将包含一个主时间步进循环。在每个时间步 $ n $，代码将首先计算含时吸收场 $ \\beta^{n+1} $，然后根据所选的外推方案和可用的历史数据准备SOR求解器的初始猜测值，最后执行SOR迭代直到达到收敛或达到最大迭代次数。所有时间步的总SOR迭代次数用作计算成本的度量。将最终通量场与高分辨率参考解进行比较以评估精度。参考解是使用更小的时间步长 $ \\Delta t_{\\text{ref}} $、二次外推和近最优松弛参数 $ \\omega $ 计算的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted or needed.\n\ndef solve():\n    \"\"\"\n    Main function to run the reactor transient simulation for all test cases.\n    \"\"\"\n    # Scientific and numerical parameters from the problem statement\n    Lx, Ly, Lz = 100.0, 100.0, 100.0\n    Nx, Ny, Nz = 10, 10, 6\n    alpha = 0.5\n    beta_0 = 0.08\n    delta_beta = 0.04\n    T_transient = 0.2\n    s0 = 0.02\n    sor_tol = 1e-5\n    sor_max_iter = 100\n\n    # Grid spacing\n    hx = Lx / (Nx + 1)\n    hy = Ly / (Ny + 1)\n    hz = Lz / (Nz + 1)\n    \n    # Rod region definition: central 3x3 square of interior grid cells\n    rod_size_x, rod_size_y = 3, 3\n    rod_start_x = (Nx - rod_size_x) // 2\n    rod_end_x = rod_start_x + rod_size_x\n    rod_start_y = (Ny - rod_size_y) // 2\n    rod_end_y = rod_start_y + rod_size_y\n\n    def run_transient(dt, omega, extrap_mode):\n        \"\"\"\n        Simulates the reactor transient for a given set of parameters.\n        \n        Args:\n            dt (float): Time step size.\n            omega (float): SOR relaxation parameter.\n            extrap_mode (str): Extrapolation mode ('none', 'linear', 'quadratic').\n\n        Returns:\n            tuple: A tuple containing the final flux field (3D numpy array)\n                   and the total number of SOR iterations (int).\n        \"\"\"\n        num_steps = int(round(T_transient / dt))\n        total_sor_iterations = 0\n\n        # Flux history: [phi_{n-2}, phi_{n-1}, phi_n]\n        phi_history = [np.zeros((Nx, Ny, Nz)) for _ in range(3)]\n        \n        # Precompute some constants for SOR\n        cx = alpha * dt / (hx * hx)\n        cy = alpha * dt / (hy * hy)\n        cz = alpha * dt / (hz * hz)\n        diag_base = 2.0 * alpha * dt * (1/(hx*hx) + 1/(hy*hy) + 1/(hz*hz))\n\n        for n in range(num_steps):\n            t_np1 = (n + 1) * dt\n            phi_n, phi_nm1, phi_nm2 = phi_history[2], phi_history[1], phi_history[0]\n\n            # Calculate beta field at time t_np1\n            beta = np.full((Nx, Ny, Nz), beta_0)\n            rod_absorption_reduction = delta_beta * (1.0 - t_np1 / T_transient)\n            beta[rod_start_x:rod_end_x, rod_start_y:rod_end_y, :] += rod_absorption_reduction\n\n            # RHS of the linear system\n            rhs = phi_n + dt * s0\n            \n            # Diagonal terms of the matrix\n            diag_term = 1.0 + dt * beta + diag_base\n\n            # Initial guess for SOR\n            if extrap_mode == 'none':\n                phi_guess = phi_n.copy()\n            elif extrap_mode == 'linear':\n                if n == 0:\n                    phi_guess = phi_n.copy() # Fallback for first step\n                else:\n                    phi_guess = phi_n + (phi_n - phi_nm1)\n            elif extrap_mode == 'quadratic':\n                if n == 0:\n                    phi_guess = phi_n.copy() # Fallback for first step\n                elif n == 1:\n                    phi_guess = phi_n + (phi_n - phi_nm1) # Linear fallback for second step\n                else:\n                    phi_guess = phi_n + (phi_n - phi_nm1) + 0.5 * (phi_n - 2*phi_nm1 + phi_nm2)\n            \n            phi_k = phi_guess\n            \n            # SOR solver\n            for k_iter in range(sor_max_iter):\n                phi_k_old = phi_k.copy()\n                max_change = 0.0\n\n                for i in range(Nx):\n                    for j in range(Ny):\n                        for k in range(Nz):\n                            val_old = phi_k[i, j, k]\n\n                            # Neighbor values (updated in-place for GS)\n                            # Homogeneous Dirichlet BC are handled by setting neighbors to 0 at boundaries\n                            neigh_im1 = phi_k[i-1, j, k] if i > 0 else 0.0\n                            neigh_ip1 = phi_k[i+1, j, k] if i  Nx - 1 else 0.0\n                            neigh_jm1 = phi_k[i, j-1, k] if j > 0 else 0.0\n                            neigh_jp1 = phi_k[i, j+1, k] if j  Ny - 1 else 0.0\n                            neigh_km1 = phi_k[i, j, k-1] if k > 0 else 0.0\n                            neigh_kp1 = phi_k[i, j, k+1] if k  Nz - 1 else 0.0\n                            \n                            off_diag_sum = (cx * (neigh_im1 + neigh_ip1) + \n                                            cy * (neigh_jm1 + neigh_jp1) + \n                                            cz * (neigh_km1 + neigh_kp1))\n                            \n                            gs_val = (rhs[i, j, k] + off_diag_sum) / diag_term[i, j, k]\n                            \n                            new_val = (1.0 - omega) * val_old + omega * gs_val\n                            phi_k[i, j, k] = new_val\n                            \n                            max_change = max(max_change, abs(new_val - val_old))\n                \n                if max_change  sor_tol:\n                    break\n            \n            # Update history and iteration count\n            phi_new = phi_k\n            total_sor_iterations += (k_iter + 1)\n            phi_history = [phi_history[1], phi_history[2], phi_new]\n\n        return phi_history[2], total_sor_iterations\n\n    # --- Main Execution ---\n\n    # 1. Generate reference solution\n    ref_params = {'dt': 0.005, 'omega': 1.9, 'extrap_mode': 'quadratic'}\n    phi_ref_final, _ = run_transient(**ref_params)\n    norm_phi_ref = np.linalg.norm(phi_ref_final)\n    \n    # 2. Run test cases\n    test_cases = [\n        # Case 1: dt=0.01, linear, omega=1.7\n        {'dt': 0.01, 'omega': 1.7, 'extrap_mode': 'linear'},\n        # Case 2: dt=0.01, quadratic, omega=1.7\n        {'dt': 0.01, 'omega': 1.7, 'extrap_mode': 'quadratic'},\n        # Case 3: dt=0.01, no extrap, omega=1.7\n        {'dt': 0.01, 'omega': 1.7, 'extrap_mode': 'none'},\n        # Case 4: dt=0.02, quadratic, omega=1.7\n        {'dt': 0.02, 'omega': 1.7, 'extrap_mode': 'quadratic'},\n        # Case 5: dt=0.01, quadratic, omega=1.3\n        {'dt': 0.01, 'omega': 1.3, 'extrap_mode': 'quadratic'},\n    ]\n\n    results = []\n    for case in test_cases:\n        phi_case_final, total_iters = run_transient(**case)\n        \n        # Calculate relative L2 error\n        # Need to handle potential size mismatch if grid was different (not the case here)\n        error = np.linalg.norm(phi_case_final - phi_ref_final) / norm_phi_ref\n        \n        results.extend([error, total_iters])\n\n    # Final print statement in the exact required format\n    # The problem specifies decimal for error and integer for iterations.\n    # We will format the list accordingly to ensure this.\n    formatted_results = [f\"{val:.6f}\" if isinstance(val, float) else str(val) for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}