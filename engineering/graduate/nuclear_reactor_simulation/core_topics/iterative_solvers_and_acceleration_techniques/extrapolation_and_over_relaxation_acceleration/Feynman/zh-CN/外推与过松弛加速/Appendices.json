{
    "hands_on_practices": [
        {
            "introduction": "在计算科学中，验证模拟代码的误差是否以理论预测的速率收敛，是代码验证与确认（V&V）中的一个关键步骤，即“观测收敛阶”，从而验证方法的正确实现。这个过程也是理查森外推法（Richardson extrapolation）提高解的精度的理论基础。",
            "id": "4224934",
            "problem": "在一个针对轻水反应堆堆芯的二维均匀化中子扩散特征值问题中，有效增殖因子 $k_{\\text{eff}}$ 是通过在一系列均匀、几何相似的笛卡尔网格上使用单元中心有限体积离散化方法计算的。设网格间距为 $h_{1}$、$h_{2}$ 和 $h_{3}$，具有恒定的各向同性加密比 $r$，因此 $h_{2} = h_{1}/r$ 且 $h_{3} = h_{2}/r$。假设该序列处于渐近区域，其中 $k_{\\text{eff}}$ 的主阶离散误差形式为 $C h^{p}$，这里 $C$ 是一个非零常数，$p$ 是 $k_{\\text{eff}}$ 离散化的观测（实验）精度阶。输运物理和材料属性是固定的；在该序列中只有空间网格发生变化，并且特征值求解的残差容差足够小，以至于迭代（求解器）误差与离散误差相比可以忽略不计。\n\n给定以下数据：\n- 各向同性加密比 $r = 2$。\n- 网格尺寸 $h_{1} = 10$ 厘米，$h_{2} = 5$ 厘米，及 $h_{3} = 2.5$ 厘米。\n- 计算得到的有效增殖因子：$k_{\\text{eff}}(h_{1}) = 1.010000$，$k_{\\text{eff}}(h_{2}) = 1.002500$，$k_{\\text{eff}}(h_{3}) = 1.000625$。\n\n从一个适用于椭圆特征值问题的一致性渐近误差模型出发，并且不预先假设 $p$ 的任何特定值，推导出一个基于三个网格层级和恒定加密比 $r$ 的观测阶 $p$ 的表达式，然后根据给定数据计算 $p$。\n\n最后，简要分析——不进行任何进一步的数值计算——如果使用各向异性网格序列（其中 $h_{x}$ 在各层级间减半而 $h_{y}$ 保持不变）代替各向同性加密，考虑到中子通量存在与 $y$ 方向对齐的强边界层，这对 $k_{\\text{eff}}$ 的 Richardson 外推法的可靠性有何影响。\n\n仅报告计算出的 $p$ 值作为最终答案，四舍五入至三位有效数字。$p$ 无需单位。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- 问题类型：二维均匀化中子扩散特征值问题。\n- 数值方法：在均匀、几何相似的笛卡尔网格上进行单元中心有限体积离散化。\n- 网格间距：$h_{1}$、$h_{2}$、$h_{3}$。\n- 加密比：$r$，其中 $h_{2} = h_{1}/r$ 且 $h_{3} = h_{2}/r$。\n- 渐近误差模型：$k_{\\text{eff}}$ 的主阶离散误差为 $C h^{p}$，其中 $C$ 为非零常数，$p$ 为观测到的精度阶。\n- 求解器误差：与离散误差相比可忽略不计。\n- 数据：\n  - 各向同性加密比 $r = 2$。\n  - 网格尺寸：$h_{1} = 10$ 厘米，$h_{2} = 5$ 厘米，$h_{3} = 2.5$ 厘米。\n  - 计算出的特征值：$k_{\\text{eff}}(h_{1}) = 1.010000$，$k_{\\text{eff}}(h_{2}) = 1.002500$，$k_{\\text{eff}}(h_{3}) = 1.000625$。\n- 任务：\n  1. 基于三个网格层级和恒定加密比 $r$ 推导观测阶 $p$ 的表达式。\n  2. 根据给定数据计算 $p$。\n  3. 简要分析在各向异性加密下，$k_{\\text{eff}}$ 的 Richardson 外推法的可靠性。\n- 最终答案要求：仅报告计算出的 $p$ 值，四舍五入至三位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题在计算核工程和数值分析领域有坚实的理论基础。中子扩散方程、其特征值形式、有限体积法，以及通过网格加密研究进行的离散误差分析都是标准的、基础的概念。渐近误差模型是数值分析的基石。\n- **适定性**：该问题是适定的。它为数值解提供了三个数据点，这是从三参数误差模型（$k_{\\text{exact}}$, $C$, $p$）确定观测精度阶 $p$ 所需的最小数量。可以确定 $p$ 的唯一解。\n- **客观性**：问题陈述以精确、客观和技术性的语言编写，没有任何主观性或偏见。\n- **完整性和一致性**：所有必要数据（$h_i$, $k_{\\text{eff}}(h_i)$, $r$）均已提供且内部一致（例如，给定值满足 $h_{2} = h_{1}/r$）。问题是自洽的。\n- **现实性和可行性**：该设置是对反应堆物理模拟中收敛性研究的真实表示。$k_{\\text{eff}}$ 的值对于近临界系统是合理的。\n- **其他缺陷**：该问题不是不适定的、琐碎的，或基于任何其他列出的缺陷。\n\n### 步骤 3：结论与行动\n问题有效。将提供解答。\n\n### 解答推导\n\n分析过程首先推导观测精度阶的公式，计算其值，然后讨论各向异性加密的影响。\n\n设 $k_{\\text{exact}}$ 为有效增殖因子的精确连续介质值。问题陈述指出，对于足够小的网格间距 $h$，数值计算的特征值 $k(h)$ 可以通过渐近误差展开与精确值联系起来。该展开的主阶项为：\n$$k(h) \\approx k_{\\text{exact}} + C h^{p}$$\n其中 $C$ 是一个与 $h$ 无关的常数，$p$ 是数值方法的精度阶。\n\n我们将此模型应用于给定的三个网格层级，其间距分别为 $h_{1}$、$h_{2}$ 和 $h_{3}$：\n1. $k(h_{1}) = k_{\\text{exact}} + C h_{1}^{p}$\n2. $k(h_{2}) = k_{\\text{exact}} + C h_{2}^{p}$\n3. $k(h_{3}) = k_{\\text{exact}} + C h_{3}^{p}$\n\n为了找到 $p$ 的表达式，我们必须消去未知常数 $k_{\\text{exact}}$ 和 $C$。首先，我们通过对连续方程作差来消去 $k_{\\text{exact}}$：\n$$k(h_{1}) - k(h_{2}) = (k_{\\text{exact}} + C h_{1}^{p}) - (k_{\\text{exact}} + C h_{2}^{p}) = C (h_{1}^{p} - h_{2}^{p})$$\n$$k(h_{2}) - k(h_{3}) = (k_{\\text{exact}} + C h_{2}^{p}) - (k_{\\text{exact}} + C h_{3}^{p}) = C (h_{2}^{p} - h_{3}^{p})$$\n\n接下来，我们通过将这两个差分方程相除来消去常数 $C$：\n$$\\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} = \\frac{C (h_{1}^{p} - h_{2}^{p})}{C (h_{2}^{p} - h_{3}^{p})} = \\frac{h_{1}^{p} - h_{2}^{p}}{h_{2}^{p} - h_{3}^{p}}$$\n\n网格间距由一个恒定的各向同性加密比 $r$ 相关联，使得 $h_{2} = h_{1}/r$ 且 $h_{3} = h_{2}/r = h_{1}/r^{2}$。将这些关系代入方程的右侧，得到：\n$$\\frac{h_{1}^{p} - (h_{1}/r)^{p}}{(h_{1}/r)^{p} - (h_{1}/r^{2})^{p}} = \\frac{h_{1}^{p}(1 - 1/r^{p})}{h_{1}^{p}(1/r^{p} - 1/r^{2p})} = \\frac{1 - r^{-p}}{r^{-p} - r^{-2p}}$$\n为了简化这个分数，我们可以将分子和分母同乘以 $r^{2p}$：\n$$\\frac{r^{2p}(1 - r^{-p})}{r^{2p}(r^{-p} - r^{-2p})} = \\frac{r^{2p} - r^{p}}{r^{p} - 1}$$\n从分子中提出因子 $r^{p}$ 得到：\n$$\\frac{r^{p}(r^{p} - 1)}{r^{p} - 1} = r^{p}$$\n\n因此，我们得到了将解的差值之比与精度阶 $p$ 联系起来的表达式：\n$$\\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} = r^{p}$$\n为了求解 $p$，我们对两边取自然对数：\n$$\\ln\\left( \\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} \\right) = \\ln(r^{p}) = p \\ln(r)$$\n这给出了观测精度阶的最终表达式：\n$$p = \\frac{\\ln\\left( \\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} \\right)}{\\ln(r)}$$\n\n现在，我们使用所提供的数据来计算 $p$：\n- 加密比：$r = 2$。\n- 特征值：$k(h_{1}) = 1.010000$，$k(h_{2}) = 1.002500$，$k(h_{3}) = 1.000625$。\n\n首先，计算特征值的差：\n$$k(h_{1}) - k(h_{2}) = 1.010000 - 1.002500 = 0.007500$$\n$$k(h_{2}) - k(h_{3}) = 1.002500 - 1.000625 = 0.001875$$\n接下来，计算这些差值的比率：\n$$\\frac{k(h_{1}) - k(h_{2})}{k(h_{2}) - k(h_{3})} = \\frac{0.007500}{0.001875} = 4$$\n最后，将此结果和 $r$ 的值代入 $p$ 的公式：\n$$p = \\frac{\\ln(4)}{\\ln(2)} = \\frac{\\ln(2^{2})}{\\ln(2)} = \\frac{2 \\ln(2)}{\\ln(2)} = 2$$\n观测到的精度阶恰好为 $2$。对于扩散方程，在笛卡尔网格上使用单元中心有限体积法预期为二阶精度，因此该结果与理论相符。四舍五入到三位有效数字得到 $2.00$。\n\n### 各向异性加密分析\nRichardson 外推法是一种通过组合不同网格层级的结果来提高数值解精度的方法。它根本上依赖于一个表现良好的渐近误差级数的存在，其形式为 $A(h) = A_{\\text{exact}} + C h^{p} + O(h^{p+q})$，其中 $h$ 是一个代表趋于零的网格间距的单一参数。\n\n在各向异性加密的情况下，即网格间距 $h_{x}$ 被加密而 $h_{y}$ 保持不变，这个基本假设被违反了。离散误差不再是单一参数 $h$ 的函数，而是 $h_{x}$ 和 $h_{y}$ 两者的函数。主阶误差模型将采用以下形式：\n$$E(h_{x}, h_{y}) \\approx C_{x} h_{x}^{p_x} + C_{y} h_{y}^{p_y}$$\n因此，计算出的特征值为 $k(h_{x}, h_{y}) \\approx k_{\\text{exact}} + C_{x} h_{x}^{p_x} + C_{y} h_{y}^{p_y}$。\n\n如果通过将 $h_{x}$ 减半而保持 $h_{y}$ 不变来生成一系列网格，计算出的特征值将表现为：\n$$k(h_{x}) \\approx (k_{\\text{exact}} + C_{y} h_{y}^{p_y}) + C_{x} h_{x}^{p_x}$$\n当 $h_{x} \\rightarrow 0$ 时，解序列 $k(h_x)$ 不会收敛到真实的连续介质特征值 $k_{\\text{exact}}$。相反，它会收敛到一个有偏差的值 $k_{\\text{exact}} + C_{y} h_{y}^{p_y}$，其中偏差 $E_{\\text{bias}} = C_{y} h_{y}^{p_y}$ 是来自未加密的 $y$ 方向的非消失误差分量。\n\n中子通量存在与 $y$ 方向对齐的强边界层这一事实，意味着在 $x$ 方向存在大梯度，这使得在 $x$ 方向的加密至关重要。然而，这并不意味着 $y$ 方向的梯度为零。即使 $y$ 方向的梯度较小，固定的、可能很显著的误差贡献 $E_{\\text{bias}}$ 仍将存在。\n\n当 Richardson 外推法应用于此序列时，它只会抵消依赖于 $h_{x}$ 的主误差项，但会向不正确的、有偏差的极限进行外推。因此，Richardson 外推法的可靠性受到严重损害。它会产生一个相对于 $x$ 方向离散化更精确的结果，但由于受到来自 $y$ 方向离散化的固定误差的污染，它将无法收敛到真实的物理解。该过程在根本上是有缺陷的。\n\n要求的最终答案仅为 $p$ 的数值。\n精确值为 $p=2$。四舍五入至三位有效数字为 $2.00$。",
            "answer": "$$\\boxed{2.00}$$"
        },
        {
            "introduction": "从理论转向直接应用，我们来探讨如何在实际问题中利用外推法来提升计算效率。在瞬态模拟中，每个时间步都需要求解一个大型线性方程组，计算成本高昂；然而，相邻时间步的解通常很相似。本练习是一个编码挑战，要求您在反应堆瞬态模拟中实现并量化不同外推策略的效果，通过比较求解器迭代次数来评估其对计算总量的影响。",
            "id": "4224950",
            "problem": "考虑一个简化的三维全堆芯核反应堆瞬态过程，该过程由控制棒抽出驱动，并由速度标度的单群中子扩散方程建模。从输运到扩散的简化和速度标度出发，我们假设中子通量 $ \\phi(\\mathbf{x},t) $ 的控制方程为\n$$ \\frac{\\partial \\phi}{\\partial t} = \\alpha \\nabla^2 \\phi - \\beta(\\mathbf{x},t) \\phi + s(\\mathbf{x}), $$\n其中 $ \\alpha $ 是有效扩散系数（单位为 $\\text{cm}^2/\\text{s}$），$ \\beta(\\mathbf{x},t) $ 是有效吸收率（单位为 $ \\text{s}^{-1} $），由于控制棒运动而随时间变化，$ s(\\mathbf{x}) $ 是一个固定的外部源（其单位与方程一致，使得所有项相加以 $ \\text{s}^{-1} $ 为单位）。该方程建立在长方体域 $ \\Omega = [0,L_x] \\times [0,L_y] \\times [0,L_z] $ 上，具有均匀狄利克雷（零通量）边界条件和内部点的均匀笛卡尔网格。初始条件为 $ \\phi(\\mathbf{x},0) = 0 $。\n\n控制棒抽出由一个局部区域 $ R \\subset \\Omega $（一个跨越轴向的中心方柱体）表示，在该区域中，$ \\beta(\\mathbf{x},t) $ 在瞬态持续时间 $ T $ 内随时间线性减小，而在 $ R $ 外部则保持不变。具体来说，\n$$ \\beta(\\mathbf{x},t) = \\beta_0 + \\Delta \\beta \\left( 1 - \\frac{t}{T} \\right) \\chi_R(\\mathbf{x}), \\quad 0 \\le t \\le T, $$\n其中 $ \\beta_0 $ 是基础吸收率，$ \\Delta \\beta > 0 $ 是由于插入的控制棒引起的初始过剩吸收，而 $ \\chi_R $ 是控制棒区域的特征函数（如果 $ \\mathbf{x} \\in R $，则 $ \\chi_R(\\mathbf{x}) = 1 $，否则为 $ 0 $）。这通过随时间降低 $ R $ 区域内的吸收来实现控制棒的抽出。\n\n使用后向欧拉法在时间步长为 $ \\Delta t $ 的均匀时间网格上对时间进行离散，并通过内部网格点上的标准二阶中心有限差分格式对空间拉普拉斯算子进行离散，在外部施加零通量边界值。这导致在每个时间步都产生一个形式如下的线性系统：\n$$ \\left( I - \\Delta t \\, \\alpha \\, L + \\Delta t \\, \\mathrm{diag}(\\beta^{n+1}) \\right) \\, \\phi^{n+1} = \\phi^{n} + \\Delta t \\, s, $$\n其中 $ L $ 是离散拉普拉斯算子，$ \\beta^{n+1} $ 是空间场 $ \\beta(\\cdot,t^{n+1}) $。用逐次超松弛（SOR）方法求解每个线性系统，松弛参数为 $ \\omega $。\n\n为加速每个时间步的收敛，使用通过先前时间步外推得到的初始猜测值 $ \\phi^{n+1,(0)} $ 进行SOR迭代：\n- 线性外推：对于 $ n \\ge 1 $，为 $ \\phi^{n+1,(0)} = \\phi^n + (\\phi^n - \\phi^{n-1}) $，对于 $ n=0 $，为 $ \\phi^{1,(0)} = \\phi^0 $。\n- 二次外推：对于 $ n \\ge 2 $，为 $ \\phi^{n+1,(0)} = \\phi^n + (\\phi^n - \\phi^{n-1}) + \\tfrac{1}{2} (\\phi^n - 2 \\phi^{n-1} + \\phi^{n-2}) $，对于 $ n = 1 $ 回退到线性外推，对于 $ n = 0 $ 回退到 $ \\phi^0 $。\n\n定量目标是比较线性外推与二次外推在控制棒抽出瞬态过程中的表现，并衡量计算成本与准确性之间的权衡。使用以下科学上合理且自洽的参数：\n- 域长度：$ L_x = L_y = L_z = 100 \\, \\text{cm} $。\n- 内部网格点数：$ N_x = 10 $，$ N_y = 10 $，$ N_z = 6 $。使用均匀间距 $ h_x = \\frac{L_x}{N_x+1} $，$ h_y = \\frac{L_y}{N_y+1} $，$ h_z = \\frac{L_z}{N_z+1} $。\n- 有效扩散系数：$ \\alpha = 0.5 \\, \\text{cm}^2/\\text{s} $。\n- 基础吸收率：$ \\beta_0 = 0.08 \\, \\text{s}^{-1} $。\n- 控制棒区域的初始过剩吸收：$ \\Delta \\beta = 0.04 \\, \\text{s}^{-1} $。\n- 瞬态持续时间：$ T = 0.2 \\, \\text{s} $。\n- 外部源：$ s(\\mathbf{x}) \\equiv s_0 = 0.02 $（单位经选择与方程一致）。此源在空间上是均匀的。\n- 控制棒区域 $ R $：在 $ x$-$y $ 平面内一个中心的 $ 3 \\times 3 $ 内部网格单元正方形，跨越所有 $ z $ 平面。\n\n实现SOR，其停止准则为每次迭代的最大绝对变化小于容差 $ \\varepsilon = 10^{-5} $，或每个时间步最多 $ N_{\\max} = 100 $ 次SOR迭代。统计并报告在所有时间步上累积的总SOR迭代次数，作为计算成本的代表。为评估准确性，计算最终时刻通量场相对于一个更高精度参考解的相对离散 $ L^2 $ 误差：\n$$ \\mathrm{err} = \\frac{\\left\\| \\phi_{\\text{case}}^{\\text{final}} - \\phi_{\\text{ref}}^{\\text{final}} \\right\\|_2}{\\left\\| \\phi_{\\text{ref}}^{\\text{final}} \\right\\|_2}, $$\n其中 $ L^2 $ 范数使用内部网格点上的未加权欧几里得范数。\n\n使用时间步长 $ \\Delta t_{\\text{ref}} = 0.005 \\, \\text{s} $（共 $ N_{\\text{ref}} = 40 $ 步达到 $ T $）、二次外推和 $ \\omega = 1.9 $ 来构建参考解。\n\n您的程序必须运行以下参数组合的测试套件（每个都达到 $ T = 0.2 \\, \\text{s} $），为每个组合计算 $ \\mathrm{err} $ 和总SOR迭代次数，并按指定格式生成输出：\n1. 案例 $ 1 $：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，线性外推，$ \\omega = 1.7 $。\n2. 案例 $ 2 $：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，二次外推，$ \\omega = 1.7 $。\n3. 案例 $ 3 $：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，无外推（初始猜测值 $ \\phi^{n+1,(0)} = \\phi^n $），$ \\omega = 1.7 $。\n4. 案例 $ 4 $：$ \\Delta t = 0.02 \\, \\text{s} $，$ N = 10 $，二次外推，$ \\omega = 1.7 $。\n5. 案例 $ 5 $：$ \\Delta t = 0.01 \\, \\text{s} $，$ N = 20 $，二次外推，$ \\omega = 1.3 $。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $ [\\mathrm{err}_1, I_1, \\mathrm{err}_2, I_2, \\mathrm{err}_3, I_3, \\mathrm{err}_4, I_4, \\mathrm{err}_5, I_5] $，其中 $ \\mathrm{err}_k $ 是案例 $ k $ 的相对误差（以小数表示），$ I_k $ 是案例 $ k $ 的总整数SOR迭代次数。以秒为单位报告时间，以弧度为单位报告角度（如果有）；此处不使用角度。所有浮点输出必须是不带百分号的小数，如指定。",
            "solution": "所提供的问题是计算物理学中一个有效且适定的练习，特别是在核反应堆瞬态的数值模拟方面。它要求实现和比较用于求解时变偏微分方程的不同数值方案。所有参数都已提供，物理模型是标准简化模型（单群扩散），数值方法（后向欧拉法、有限差分、逐次超松弛法(SOR)）也适合该任务。目标明确且可量化测量。\n\n我们首先将数值方案形式化。控制方程是速度标度的单群中子扩散方程：\n$$ \\frac{\\partial \\phi}{\\partial t} = \\alpha \\nabla^2 \\phi - \\beta(\\mathbf{x},t) \\phi + s(\\mathbf{x}) $$\n该方程定义在域 $ \\Omega = [0,L_x] \\times [0,L_y] \\times [0,L_z] $上，具有零通量边界条件 $ \\phi(\\mathbf{x},t)|_{\\partial\\Omega} = 0 $ 和零通量初始条件 $ \\phi(\\mathbf{x},0) = 0 $。\n\n时间导数使用一阶精度的后向欧拉法在均匀时间网格 $ t^n = n \\Delta t $ 上进行离散：\n$$ \\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = \\alpha \\nabla^2 \\phi^{n+1} - \\beta^{n+1} \\phi^{n+1} + s $$\n其中上标表示时间步索引，例如 $ \\phi^n \\equiv \\phi(\\mathbf{x}, t^n) $。重新整理各项，将未知数 $ \\phi^{n+1} $ 组合到左侧，得到：\n$$ (1 + \\Delta t \\beta^{n+1}) \\phi^{n+1} - \\Delta t \\alpha \\nabla^2 \\phi^{n+1} = \\phi^n + \\Delta t s $$\n这是关于 $ \\phi^{n+1} $ 的一个椭圆型偏微分方程，必须在每个时间步求解。\n\n空间域在均匀笛卡尔网格上离散，沿每个轴分别有 $ N_x, N_y, N_z $ 个内部点。网格间距为 $ h_x = L_x/(N_x+1) $，$ h_y = L_y/(N_y+1) $ 和 $ h_z = L_z/(N_z+1) $。拉普拉斯算子 $ \\nabla^2 $ 使用标准的二阶中心有限差分格式进行近似。在一个内部网格点 $ (i,j,k) $ 处，其形式为：\n$$ \\nabla^2 \\phi \\approx \\frac{\\phi_{i-1,j,k} - 2\\phi_{i,j,k} + \\phi_{i+1,j,k}}{h_x^2} + \\frac{\\phi_{i,j-1,k} - 2\\phi_{i,j,k} + \\phi_{i,j+1,k}}{h_y^2} + \\frac{\\phi_{i,j,k-1} - 2\\phi_{i,j,k} + \\phi_{i,j,k+1}}{h_z^2} $$\n将此代入时间离散方程，我们得到一个关于所有内部网格点上 $ \\phi^{n+1} $ 值的大型稀疏线性方程组。对于一个特定的点 $ (i,j,k) $，方程为：\n$$ \\left(1 + \\Delta t \\beta_{i,j,k}^{n+1} + 2\\alpha\\Delta t \\left(\\frac{1}{h_x^2} + \\frac{1}{h_y^2} + \\frac{1}{h_z^2}\\right)\\right)\\phi_{i,j,k}^{n+1} - \\frac{\\alpha\\Delta t}{h_x^2}(\\phi_{i-1,j,k}^{n+1} + \\phi_{i+1,j,k}^{n+1}) - \\dots = \\phi_{i,j,k}^n + \\Delta t s_{i,j,k} $$\n该系统可以写成矩阵形式 $ \\mathbf{A}\\boldsymbol{\\phi}^{n+1} = \\mathbf{b} $，其中 $ \\boldsymbol{\\phi}^{n+1} $ 是未知通量值的向量，$\\mathbf{A}$ 是一个大型、稀疏且结构化的矩阵，$\\mathbf{b}$ 是由前一时间步的已知量组成的右侧向量。矩阵 $ \\mathbf{A} $ 是对称正定的，这保证了当松弛参数 $ \\omega \\in (0,2) $ 时，逐次超松弛（SOR）方法的收敛性。\n\nSOR方法是一种迭代求解器。对于每个点 $ (i,j,k) $，我们根据其邻居的当前值计算更新值。SOR更新规则是：\n$$ \\phi_{i,j,k}^{(m+1)} = (1-\\omega)\\phi_{i,j,k}^{(m)} + \\omega \\phi_{i,j,k}^{\\text{GS}} $$\n其中 $ (m) $ 是SOR迭代指数，$\\omega$ 是松弛参数，$ \\phi_{i,j,k}^{\\text{GS}} $ 是高斯-赛德尔（Gauss-Seidel）更新：\n$$ \\phi_{i,j,k}^{\\text{GS}} = \\frac{1}{D_{i,j,k}} \\left( \\phi_{i,j,k}^n + \\Delta t s_{i,j,k} + \\frac{\\alpha\\Delta t}{h_x^2}(\\phi_{i-1,j,k}^{(m+1)} + \\phi_{i+1,j,k}^{(m)}) + \\frac{\\alpha\\Delta t}{h_y^2}(\\phi_{i,j-1,k}^{(m+1)} + \\phi_{i,j+1,k}^{(m)}) + \\frac{\\alpha\\Delta t}{h_z^2}(\\phi_{i,j,k-1}^{(m+1)} + \\phi_{i,j,k+1}^{(m)}) \\right) $$\n这里，$ D_{i,j,k} $ 是矩阵 $ \\mathbf{A} $ 在点 $ (i,j,k) $ 处的对角元素：\n$$ D_{i,j,k} = 1 + \\Delta t \\beta_{i,j,k}^{n+1} + 2\\alpha\\Delta t \\left(\\frac{1}{h_x^2} + \\frac{1}{h_y^2} + \\frac{1}{h_z^2}\\right) $$\n高斯-赛德尔更新使用最新的可用值；当按字典序遍历网格时，这意味着对索引较小的邻居使用来自迭代 $ (m+1) $ 的值，对索引较大的邻居使用来自迭代 $ (m) $ 的值。这通过就地更新通量数组来实现。\n\nSOR求解器的效率在很大程度上取决于初始猜测值 $ \\boldsymbol{\\phi}^{n+1,(0)} $。一个更接近最终解的猜测值可以减少收敛所需的迭代次数。我们比较三种初始猜测策略：\n1.  无外推（或零阶）：$ \\boldsymbol{\\phi}^{n+1,(0)} = \\boldsymbol{\\phi}^n $。这假设解与前一时间步相比变化不大。\n2.  线性外推（一阶）：$ \\boldsymbol{\\phi}^{n+1,(0)} = \\boldsymbol{\\phi}^n + (\\boldsymbol{\\phi}^n - \\boldsymbol{\\phi}^{n-1}) $。这使用最后两个时间步的趋势将解向前外推。它等效于时间上的一阶泰勒展开。\n3.  二次外推（二阶）：$ \\boldsymbol{\\phi}^{n+1,(0)} = \\boldsymbol{\\phi}^n + (\\boldsymbol{\\phi}^n - \\boldsymbol{\\phi}^{n-1}) + \\frac{1}{2}(\\boldsymbol{\\phi}^n - 2\\boldsymbol{\\phi}^{n-1} + \\boldsymbol{\\phi}^{n-2}) $。这使用最后三个时间步的信息进行更准确的、基于二阶泰勒展开的预测。\n\n实现将包含一个主时间步进循环。在每个时间步 $ n $，代码将首先计算随时间变化的吸收场 $ \\beta^{n+1} $，然后根据所选的外推方案和可用历史数据为SOR求解器准备初始猜测值，最后执行SOR迭代直到达到收敛或达到最大迭代次数。所有时间步的总SOR迭代次数用作计算成本的度量。将最终通量场与高分辨率参考解进行比较以评估准确性。参考解是使用更小的时间步长 $ \\Delta t_{\\text{ref}} $、二次外推和接近最优的松弛参数 $ \\omega $ 来计算的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted or needed.\n\ndef solve():\n    \"\"\"\n    Main function to run the reactor transient simulation for all test cases.\n    \"\"\"\n    # Scientific and numerical parameters from the problem statement\n    Lx, Ly, Lz = 100.0, 100.0, 100.0\n    Nx, Ny, Nz = 10, 10, 6\n    alpha = 0.5\n    beta_0 = 0.08\n    delta_beta = 0.04\n    T_transient = 0.2\n    s0 = 0.02\n    sor_tol = 1e-5\n    sor_max_iter = 100\n\n    # Grid spacing\n    hx = Lx / (Nx + 1)\n    hy = Ly / (Ny + 1)\n    hz = Lz / (Nz + 1)\n    \n    # Rod region definition: central 3x3 square of interior grid cells\n    rod_size_x, rod_size_y = 3, 3\n    rod_start_x = (Nx - rod_size_x) // 2\n    rod_end_x = rod_start_x + rod_size_x\n    rod_start_y = (Ny - rod_size_y) // 2\n    rod_end_y = rod_start_y + rod_size_y\n\n    def run_transient(dt, omega, extrap_mode):\n        \"\"\"\n        Simulates the reactor transient for a given set of parameters.\n        \n        Args:\n            dt (float): Time step size.\n            omega (float): SOR relaxation parameter.\n            extrap_mode (str): Extrapolation mode ('none', 'linear', 'quadratic').\n\n        Returns:\n            tuple: A tuple containing the final flux field (3D numpy array)\n                   and the total number of SOR iterations (int).\n        \"\"\"\n        num_steps = int(round(T_transient / dt))\n        total_sor_iterations = 0\n\n        # Flux history: [phi_{n-2}, phi_{n-1}, phi_n]\n        phi_history = [np.zeros((Nx, Ny, Nz)) for _ in range(3)]\n        \n        # Precompute some constants for SOR\n        cx = alpha * dt / (hx * hx)\n        cy = alpha * dt / (hy * hy)\n        cz = alpha * dt / (hz * hz)\n        diag_base = 2.0 * alpha * dt * (1/(hx*hx) + 1/(hy*hy) + 1/(hz*hz))\n\n        for n in range(num_steps):\n            t_np1 = (n + 1) * dt\n            phi_n, phi_nm1, phi_nm2 = phi_history[2], phi_history[1], phi_history[0]\n\n            # Calculate beta field at time t_np1\n            beta = np.full((Nx, Ny, Nz), beta_0)\n            rod_absorption_reduction = delta_beta * (1.0 - t_np1 / T_transient)\n            beta[rod_start_x:rod_end_x, rod_start_y:rod_end_y, :] += rod_absorption_reduction\n\n            # RHS of the linear system\n            rhs = phi_n + dt * s0\n            \n            # Diagonal terms of the matrix\n            diag_term = 1.0 + dt * beta + diag_base\n\n            # Initial guess for SOR\n            if extrap_mode == 'none':\n                phi_guess = phi_n.copy()\n            elif extrap_mode == 'linear':\n                if n == 0:\n                    phi_guess = phi_n.copy() # Fallback for first step\n                else:\n                    phi_guess = phi_n + (phi_n - phi_nm1)\n            elif extrap_mode == 'quadratic':\n                if n == 0:\n                    phi_guess = phi_n.copy() # Fallback for first step\n                elif n == 1:\n                    phi_guess = phi_n + (phi_n - phi_nm1) # Linear fallback for second step\n                else:\n                    phi_guess = phi_n + (phi_n - phi_nm1) + 0.5 * (phi_n - 2*phi_nm1 + phi_nm2)\n            \n            phi_k = phi_guess\n            \n            # SOR solver\n            for k_iter in range(sor_max_iter):\n                phi_k_old = phi_k.copy()\n                max_change = 0.0\n\n                for i in range(Nx):\n                    for j in range(Ny):\n                        for k in range(Nz):\n                            val_old = phi_k[i, j, k]\n\n                            # Neighbor values (updated in-place for GS)\n                            # Homogeneous Dirichlet BC are handled by setting neighbors to 0 at boundaries\n                            neigh_im1 = phi_k[i-1, j, k] if i > 0 else 0.0\n                            neigh_ip1 = phi_k[i+1, j, k] if i < Nx - 1 else 0.0\n                            neigh_jm1 = phi_k[i, j-1, k] if j > 0 else 0.0\n                            neigh_jp1 = phi_k[i, j+1, k] if j < Ny - 1 else 0.0\n                            neigh_km1 = phi_k[i, j, k-1] if k > 0 else 0.0\n                            neigh_kp1 = phi_k[i, j, k+1] if k < Nz - 1 else 0.0\n                            \n                            off_diag_sum = (cx * (neigh_im1 + neigh_ip1) + \n                                            cy * (neigh_jm1 + neigh_jp1) + \n                                            cz * (neigh_km1 + neigh_kp1))\n                            \n                            gs_val = (rhs[i, j, k] + off_diag_sum) / diag_term[i, j, k]\n                            \n                            new_val = (1.0 - omega) * val_old + omega * gs_val\n                            phi_k[i, j, k] = new_val\n                            \n                            max_change = max(max_change, abs(new_val - val_old))\n                \n                if max_change < sor_tol:\n                    break\n            \n            # Update history and iteration count\n            phi_new = phi_k\n            total_sor_iterations += (k_iter + 1)\n            phi_history = [phi_history[1], phi_history[2], phi_new]\n\n        return phi_history[2], total_sor_iterations\n\n    # --- Main Execution ---\n\n    # 1. Generate reference solution\n    ref_params = {'dt': 0.005, 'omega': 1.9, 'extrap_mode': 'quadratic'}\n    phi_ref_final, _ = run_transient(**ref_params)\n    norm_phi_ref = np.linalg.norm(phi_ref_final)\n    \n    # 2. Run test cases\n    test_cases = [\n        # Case 1: dt=0.01, linear, omega=1.7\n        {'dt': 0.01, 'omega': 1.7, 'extrap_mode': 'linear'},\n        # Case 2: dt=0.01, quadratic, omega=1.7\n        {'dt': 0.01, 'omega': 1.7, 'extrap_mode': 'quadratic'},\n        # Case 3: dt=0.01, no extrap, omega=1.7\n        {'dt': 0.01, 'omega': 1.7, 'extrap_mode': 'none'},\n        # Case 4: dt=0.02, quadratic, omega=1.7\n        {'dt': 0.02, 'omega': 1.7, 'extrap_mode': 'quadratic'},\n        # Case 5: dt=0.01, quadratic, omega=1.3\n        {'dt': 0.01, 'omega': 1.3, 'extrap_mode': 'quadratic'},\n    ]\n\n    results = []\n    for case in test_cases:\n        phi_case_final, total_iters = run_transient(**case)\n        \n        # Calculate relative L2 error\n        # Need to handle potential size mismatch if grid was different (not the case here)\n        error = np.linalg.norm(phi_case_final - phi_ref_final) / norm_phi_ref\n        \n        results.extend([error, total_iters])\n\n    # Final print statement in the exact required format\n    # The problem specifies decimal for error and integer for iterations.\n    # We will format the list accordingly to ensure this.\n    formatted_results = [f\"{val:.6f}\" if isinstance(val, float) else str(val) for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了简单的多项式外推，还存在更强大的迭代加速技术，它们通常能更有效地处理复杂的非线性问题。本练习要求对安德森加速（Anderson acceleration）——一种现代的定点迭代加速方法——进行分析性研究。您将推导其计算开销，并分析其在加速能力、计算成本和内存占用之间的权衡，这些是设计高效大规模模拟时必须考虑的关键因素。",
            "id": "4224953",
            "problem": "考虑在三维反应堆堆芯中使用离散纵标法（也称为 $S_{N}$ 法）和源迭代进行稳态中子输运计算。设未知向量的大小为 $N$，一次输运扫描（将输运算子应用一次，以在所有角度和能量组上推进通量未知数）的成本为 $S = \\alpha N$ 次浮点运算（flops），其中 $\\alpha > 0$ 是一个与问题相关的常数，它包含了角度求积、网格遍历和群内散射的成本。为了加速不动点迭代，在累积了长度为 $m$ 的历史记录后，每次迭代都应用深度为 $m$ 的 Anderson 加速（I型）。\n\n假设在长度为 $N$ 的向量上，深度为 $m$ 的一个 Anderson 加速步骤的实现模型如下：\n- 一个维度为 $N \\times m$ 的高瘦最小二乘问题通过对 $N \\times m$ 的残差差分矩阵进行基于 Householder 的经济型 $QR$ 分解来求解，然后将 $Q^{T}$ 应用于一个残差向量，并使用 $m \\times m$ 的上三角因子 $R$ 进行回代。\n- 从存储的残差形成 $N \\times m$ 的残差差分矩阵的成本为 $N m$ flops。\n- 一个 $N \\times m$ 矩阵的 Householder $QR$ 分解成本为 $2 N m^{2} - \\tfrac{2}{3} m^{3}$ flops。\n- 将 $Q^{T}$ 应用于一个长度为 $N$ 的右端项的成本为 $2 N m$ flops。\n- 在 $m \\times m$ 的上三角系统中进行回代的成本为 $m^{2}$ flops。\n- 将加速后的更新形成为最多 $m+1$ 个已存储的长度为 $N$ 的向量的线性组合的成本为 $2 N m$ flops。\n\n在存储方面，假设 Anderson 加速维护两个长度为 $m$ 的历史记录：迭代差分和残差差分，每个都是一个 $N \\times m$ 的稠密矩阵，以及两个长度为 $N$ 的工作向量。如果基准输运扫描需要存储两个长度为 $N$ 的向量，并且超出基准可用于加速的总额外存储空间被限制为 $\\Lambda N$ 个双精度数（也就是说，最多可以存储 $\\Lambda$ 个额外的长度为 $N$ 的向量），那么 Anderson 深度的内存可行性约束是 $2 m + 2 \\le \\Lambda$。\n\n任务：\n1. 通过将上面列出的成本相加，推导出每次迭代的 Anderson 加速开销 $C_{\\mathrm{AA}}(m,N)$。然后形成无量纲的开销与扫描比\n$$\nR(m;N,\\alpha) \\equiv \\frac{C_{\\mathrm{AA}}(m,N)}{S} = \\frac{C_{\\mathrm{AA}}(m,N)}{\\alpha N}.\n$$\n2. 在与大规模反应堆模拟相关的渐近状态 $N \\gg m$下，保留 $m$ 和 $N$ 的主要项，以获得一个在主阶上与 $N$ 无关的近似 $R_{\\mathrm{asym}}(m;\\alpha)$。使用此近似，确定收支平衡深度 $m_{\\star}$，使得 $R_{\\mathrm{asym}}(m_{\\star};\\alpha) = 1$，并将 $m_{\\star}$ 表示为 $\\alpha$ 的闭式解。\n3. 使用存储模型和约束 $2 m + 2 \\le \\Lambda$，确定内存限制下的最大可行深度 $m_{\\mathrm{mem}}$ 的闭式解。\n4. 报告同时满足计算可行性和内存可行性的收支平衡深度，作为一个单一的闭式解析表达式\n$$\nm_{\\mathrm{be}} \\equiv \\min\\!\\big(m_{\\star},\\, m_{\\mathrm{mem}}\\big).\n$$\n\n您的最终答案必须是关于 $\\alpha$ 和 $\\Lambda$ 的 $m_{\\mathrm{be}}$ 的单一闭式解析表达式。",
            "solution": "该问题已经过验证，被认为是科学上可靠、适定且客观的。所提供的信息是自洽的，足以推导出所要求的解析表达式。\n\n解答过程通过按顺序处理四个任务来进行。\n\n任务1：推导每次迭代的 Anderson 加速开销 $C_{\\mathrm{AA}}(m,N)$ 和无量纲的开销与扫描比 $R(m;N,\\alpha)$。\n\n一个 Anderson 加速步骤的总成本 $C_{\\mathrm{AA}}(m,N)$ 是问题陈述中提供的每个子任务的浮点运算次数之和。设 $N$ 是向量大小，$m$ 是加速深度。\n成本的组成部分是：\n1. 形成 $N \\times m$ 的残差差分矩阵：$N m$ flops。\n2. $N \\times m$ 矩阵的 Householder QR 分解：$2 N m^{2} - \\frac{2}{3} m^{3}$ flops。\n3. 将 $Q^{T}$ 应用于残差向量：$2 N m$ flops。\n4. 使用 $m \\times m$ 矩阵 $R$ 进行回代：$m^{2}$ flops。\n5. 形成更新后的解向量：$2 N m$ flops。\n\n将这些贡献相加，得到总开销 $C_{\\mathrm{AA}}(m,N)$：\n$$\nC_{\\mathrm{AA}}(m,N) = (N m) + \\left(2 N m^{2} - \\frac{2}{3} m^{3}\\right) + (2 N m) + (m^{2}) + (2 N m)\n$$\n我们将与 $N$ 成正比的项和不成正比的项分组：\n$$\nC_{\\mathrm{AA}}(m,N) = N(m + 2m^2 + 2m + 2m) + \\left(m^2 - \\frac{2}{3} m^3\\right)\n$$\n$$\nC_{\\mathrm{AA}}(m,N) = N(2m^2 + 5m) + m^2 - \\frac{2}{3} m^3\n$$\n单次输运扫描的成本由 $S = \\alpha N$ flops 给出。无量纲的开销与扫描比 $R(m;N,\\alpha)$ 定义为 $\\frac{C_{\\mathrm{AA}}(m,N)}{S}$。\n$$\nR(m;N,\\alpha) = \\frac{N(2m^2 + 5m) + m^2 - \\frac{2}{3} m^3}{\\alpha N} = \\frac{2m^2 + 5m}{\\alpha} + \\frac{m^2 - \\frac{2}{3} m^3}{\\alpha N}\n$$\n\n任务2：确定渐近比率 $R_{\\mathrm{asym}}(m;\\alpha)$ 和收支平衡深度 $m_{\\star}$。\n\n在问题规模 $N$ 远大于加速深度 $m$ (即 $N \\gg m$) 的渐近状态下，阶数为 $\\frac{m^k}{N}$ (其中 $k>0$) 的项变得可以忽略不计。因此，我们可以通过只保留主阶项来近似比率 $R$。\n$$\nR_{\\mathrm{asym}}(m;\\alpha) = \\lim_{N\\to\\infty} R(m;N,\\alpha) = \\frac{2m^2 + 5m}{\\alpha}\n$$\n正如所要求，这个渐近比率与 $N$ 无关。\n\n收支平衡深度 $m_{\\star}$ 被定义为加速的计算开销等于一次输运扫描成本时的深度。这对应于条件 $R_{\\mathrm{asym}}(m_{\\star};\\alpha) = 1$。\n$$\n\\frac{2m_{\\star}^2 + 5m_{\\star}}{\\alpha} = 1\n$$\n$$\n2m_{\\star}^2 + 5m_{\\star} - \\alpha = 0\n$$\n这是一个关于 $m_{\\star}$ 的二次方程。我们使用二次公式 $m_{\\star} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来求解，其中 $a=2$，$b=5$，$c=-\\alpha$。\n$$\nm_{\\star} = \\frac{-5 \\pm \\sqrt{5^2 - 4(2)(-\\alpha)}}{2(2)} = \\frac{-5 \\pm \\sqrt{25 + 8\\alpha}}{4}\n$$\n由于深度 $m$ 必须是正数，并且给定 $\\alpha > 0$，平方根下的项 $\\sqrt{25 + 8\\alpha}$ 大于 $\\sqrt{25} = 5$。因此，我们必须选择正根以确保 $m_{\\star} > 0$。\n$$\nm_{\\star} = \\frac{-5 + \\sqrt{25 + 8\\alpha}}{4}\n$$\n\n任务3：确定内存限制下的最大可行深度 $m_{\\mathrm{mem}}$。\n\n存储模型指出，Anderson 加速需要存储两个 $N \\times m$ 矩阵和两个长度为 $N$ 的工作向量。这总计需要 $2m+2$ 个长度为 $N$ 的向量。超出基准的可用额外存储是 $\\Lambda N$ 个双精度数，可以容纳 $\\Lambda$ 个长度为 $N$ 的向量。因此，内存可行性约束是：\n$$\n2m + 2 \\le \\Lambda\n$$\n为了便于分析，我们将其视为连续变量的最大可行深度，可以通过求解等式找到：\n$$\n2m_{\\mathrm{mem}} + 2 = \\Lambda\n$$\n求解 $m_{\\mathrm{mem}}$ 得：\n$$\n2m_{\\mathrm{mem}} = \\Lambda - 2\n$$\n$$\nm_{\\mathrm{mem}} = \\frac{\\Lambda - 2}{2}\n$$\n\n任务4：报告同时满足计算可行性和内存可行性的收支平衡深度 $m_{\\mathrm{be}}$。\n\n总体收支平衡深度 $m_{\\mathrm{be}}$ 必须同时满足计算收支平衡条件和内存约束。这意味着深度既不能超过计算最优值 $m_{\\star}$（超过该值开销过高），也不能超过内存限制值 $m_{\\mathrm{mem}}$（超过该值存储空间不足）。因此，有效的收支平衡深度是这两个值的最小值。\n$$\nm_{\\mathrm{be}} \\equiv \\min\\!\\big(m_{\\star},\\, m_{\\mathrm{mem}}\\big)\n$$\n将推导出的 $m_{\\star}$ 和 $m_{\\mathrm{mem}}$ 的表达式代入，得到关于 $\\alpha$ 和 $\\Lambda$ 的 $m_{\\mathrm{be}}$ 的最终闭式解析表达式。\n$$\nm_{\\mathrm{be}} = \\min\\left( \\frac{\\sqrt{25 + 8\\alpha} - 5}{4}, \\frac{\\Lambda - 2}{2} \\right)\n$$",
            "answer": "$$\n\\boxed{\\min\\left( \\frac{\\sqrt{25 + 8\\alpha} - 5}{4}, \\frac{\\Lambda - 2}{2} \\right)}\n$$"
        }
    ]
}