{
    "hands_on_practices": [
        {
            "introduction": "Understanding the performance of an iterative solver begins with estimating its convergence rate. This first practice connects the abstract concept of an iteration operator's spectral radius, $\\rho$, to the concrete number of steps needed to achieve a desired accuracy. By deriving this relationship  and applying it to a system with high scattering, you will gain a quantitative appreciation for why some transport problems converge much more slowly than others.",
            "id": "4218825",
            "problem": "In one-speed, steady-state neutron transport for a homogeneous slab with isotropic scattering, consider the standard fixed-point Source Iteration (SI) applied to the Discrete Ordinates method (SN). Let the linear iteration be written in terms of the error update $e^{(k+1)} = \\mathcal{M} e^{(k)}$, where $\\mathcal{M}$ is the iteration operator and $e^{(k)}$ is the error at iteration $k$ with respect to the fixed point. Assume a matrix norm consistent with the spectral properties of $\\mathcal{M}$ and define the spectral radius $\\rho(\\mathcal{M}) = q$, with $0  q  1$, so that the norm of the error (and residual in a consistent norm) contracts by at most a factor $q$ per iteration. A convergence criterion is imposed on the residual norm $\\|r^{(n)}\\|$ requiring $\\|r^{(n)}\\| \\le \\theta \\|r^{(0)}\\|$ for some target reduction factor $0  \\theta  1$.\n\nStarting only from the definition of spectral radius and the submultiplicative property of consistent matrix norms, derive an expression for the minimal integer number of iterations $n$ required to achieve $\\|r^{(n)}\\| \\le \\theta \\|r^{(0)}\\|$ in terms of $\\theta$ and $q$. Then, interpret this result for a highly scattering medium by taking the scattering ratio $c = 0.95$ and using the standard SI observation $q \\approx c$. Evaluate the minimal $n$ that guarantees a residual reduction factor of $\\theta = 1.0 \\times 10^{-8}$.\n\nExpress the final answer as a single integer with no units. No rounding instruction is needed beyond the integer requirement; report the minimal integer $n$ that satisfies the criterion.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and all necessary information is provided. The problem describes the standard Source Iteration (SI) method for solving the neutron transport equation, utilizing established concepts such as the iteration operator, spectral radius, and convergence criteria. The provided parameters are physically realistic, and the question is mathematically unambiguous. The problem is deemed valid.\n\nThe core of the problem is to determine the minimum number of iterations, $n$, required to satisfy a given convergence criterion. The iterative process for the error is given by $e^{(k+1)} = \\mathcal{M} e^{(k)}$, where $\\mathcal{M}$ is the iteration operator. The spectral radius of this operator is $\\rho(\\mathcal{M}) = q$. The problem states that for a consistent norm, the residual norm contracts by at most a factor of $q$ per iteration. We can express this relationship as an inequality:\n$$\n\\|r^{(k+1)}\\| \\le q \\|r^{(k)}\\|\n$$\nwhere $r^{(k)}$ is the residual at iteration $k$. We can apply this inequality recursively starting from the initial residual $r^{(0)}$:\nFor iteration $k=1$:\n$$\n\\|r^{(1)}\\| \\le q \\|r^{(0)}\\|\n$$\nFor iteration $k=2$:\n$$\n\\|r^{(2)}\\| \\le q \\|r^{(1)}\\| \\le q (q \\|r^{(0)}\\|) = q^2 \\|r^{(0)}\\|\n$$\nBy induction, for an arbitrary number of iterations $n$, the residual norm is bounded by:\n$$\n\\|r^{(n)}\\| \\le q^n \\|r^{(0)}\\|\n$$\nThis inequality provides a worst-case bound on the residual norm after $n$ iterations.\n\nThe specified convergence criterion is $\\|r^{(n)}\\| \\le \\theta \\|r^{(0)}\\|$ for a given reduction factor $\\theta$, where $0  \\theta  1$. To guarantee that this criterion is met, we require that the upper bound of our derived inequality be less than or equal to the target value:\n$$\nq^n \\|r^{(0)}\\| \\le \\theta \\|r^{(0)}\\|\n$$\nAssuming the initial residual is non-zero, i.e., $\\|r^{(0)}\\|  0$, we can divide both sides by $\\|r^{(0)}\\|$ without changing the inequality:\n$$\nq^n \\le \\theta\n$$\nTo solve for $n$, we take the natural logarithm of both sides. Since both $q$ and $\\theta$ are positive numbers between $0$ and $1$, their logarithms are negative.\n$$\n\\ln(q^n) \\le \\ln(\\theta)\n$$\nUsing the property of logarithms, $\\ln(a^b) = b \\ln(a)$, we have:\n$$\nn \\ln(q) \\le \\ln(\\theta)\n$$\nTo isolate $n$, we must divide by $\\ln(q)$. As $0  q  1$, $\\ln(q)$ is a negative number. Dividing an inequality by a negative number reverses the direction of the inequality sign:\n$$\nn \\ge \\frac{\\ln(\\theta)}{\\ln(q)}\n$$\nThis is the derived expression for the number of iterations $n$. The problem asks for the *minimal integer* number of iterations required. This corresponds to the smallest integer that is greater than or equal to the value on the right-hand side, which is the definition of the ceiling function.\n$$\nn = \\left\\lceil \\frac{\\ln(\\theta)}{\\ln(q)} \\right\\rceil\n$$\nFor the interpretation part, we consider a highly scattering medium where the scattering ratio $c$ is close to $1$. The problem uses the standard observation that for Source Iterations in an optically thick medium, the spectral radius $q$ is approximately equal to the scattering ratio, $q \\approx c$. As $c \\to 1$, $q$ also approaches $1$. Consequently, $\\ln(q)$ approaches $0$ from the negative side. The term $\\ln(\\theta)$ is a fixed negative number for a given tolerance. Therefore, the ratio $\\frac{\\ln(\\theta)}{\\ln(q)}$ becomes a large positive number. This indicates that a very large number of iterations $n$ is required for convergence, which is the mathematical manifestation of the slow convergence of the Source Iteration method in highly scattering, low-absorption physical systems.\n\nFinally, we evaluate the minimal integer $n$ for the given values:\nScattering ratio $c = 0.95$, which implies $q \\approx 0.95$.\nTarget residual reduction factor $\\theta = 1.0 \\times 10^{-8}$.\n\nWe substitute these values into our derived expression:\n$$\nn \\ge \\frac{\\ln(1.0 \\times 10^{-8})}{\\ln(0.95)}\n$$\nCalculating the values of the logarithms:\n$$\n\\ln(1.0 \\times 10^{-8}) \\approx -18.420680744\n$$\n$$\n\\ln(0.95) \\approx -0.05129329438\n$$\nNow, we perform the division:\n$$\nn \\ge \\frac{-18.420680744}{-0.05129329438} \\approx 359.13548...\n$$\nSince $n$ must be an integer, we take the ceiling of this result to find the minimal number of iterations that guarantees the criterion is met:\n$$\nn = \\lceil 359.13548... \\rceil = 360\n$$\nTherefore, a minimum of 360 iterations are required.",
            "answer": "$$\\boxed{360}$$"
        },
        {
            "introduction": "Driving an iterative solver's residual to a small number is the mechanism of convergence, but what does that small residual truly guarantee about the accuracy of the physics? This practice guides you through a numerical experiment to explore the crucial relationship between the balance residual and the error in a physical quantity of interest, the absorption rate. By completing this exercise , you will learn to critically assess whether a chosen convergence tolerance is sufficient to ensure the physical fidelity of your simulation's results.",
            "id": "4218841",
            "problem": "You are given a benchmark based on steady-state, monoenergetic neutron transport in a one-dimensional slab with isotropic scattering. The discrete cell-wise neutron balance is expressed as production equals losses. Under a linearized diamond-difference-like discretization, the balance over each cell can be represented by a linear system for the cell-averaged scalar flux vector $ \\phi \\in \\mathbb{R}^N $,\n$$\nA \\phi = q,\n$$\nwhere $ A \\in \\mathbb{R}^{N \\times N} $ is the transport-loss operator, and $ q \\in \\mathbb{R}^N $ is the external source vector. The matrix $ A $ combines absorption, scattering removal, and a symmetric tridiagonal leakage operator. Specifically, let $N$ be the number of spatial cells, with uniform cell width $ h $ in centimeters, absorption cross section $ \\Sigma_a $ in inverse centimeters, scattering cross section $ \\Sigma_s $ in inverse centimeters, and diffusion-like leakage coefficient $ D $ in centimeters. Define the leakage matrix $ L \\in \\mathbb{R}^{N \\times N} $ by\n$$\nL_{i,i} = \\begin{cases}\n\\frac{D}{h^2},  i = 0 \\ \\text{or} \\ i = N - 1, \\\\\n\\frac{2D}{h^2},  \\text{otherwise},\n\\end{cases}\n\\quad\nL_{i,i+1} = L_{i+1,i} = -\\frac{D}{h^2} \\ \\text{for} \\ 0 \\le i \\le N-2,\n\\quad\nL_{i,j} = 0 \\ \\text{otherwise},\n$$\nand define\n$$\nA = L + \\operatorname{diag}(\\Sigma_a \\mathbf{1}) - \\operatorname{diag}(\\Sigma_s \\mathbf{1}),\n$$\nwhere $ \\mathbf{1} \\in \\mathbb{R}^N $ is the vector of ones. The exact scalar flux $ \\phi^\\star $ is the solution of $ A \\phi^\\star = q $. The cell-wise balance residual vector for an approximate flux $ \\phi $ is defined by\n$$\nr(\\phi) = q - A \\phi,\n$$\nwhich measures the net imbalance between sources and losses in each cell.\n\nConsider the absorption reaction rate vector $ R(\\phi) = \\Sigma_a \\phi $, and define the relative absorption reaction-rate error as the dimensionless quantity\n$$\n\\varepsilon_R(\\phi) = \\frac{\\| R(\\phi) - R(\\phi^\\star) \\|_2}{\\| R(\\phi^\\star) \\|_2}.\n$$\nYou will use approximate fluxes of the form $ \\phi_\\alpha = \\alpha \\, \\phi^\\star $ for given $ \\alpha \\in \\mathbb{R} $, which can represent an intermediate iterate from an iterative transport solver when the scalar flux scale is underestimated or overestimated.\n\nYour task is to compute, for each test case, the cell-balance residual norm $ \\| r(\\phi_\\alpha) \\|_2 $, compare it against a residual tolerance $ \\tau $, and then evaluate whether meeting the residual tolerance implies that the absorption reaction-rate error is below a desired fraction. For a given $ \\alpha $, define the tolerance\n$$\n\\tau = c \\, \\| q \\|_2,\n$$\nwith $ c  0 $, and a desired error fraction $ \\delta  0 $ (expressed as a decimal, not a percentage sign).\n\nFor this benchmark, use the following physically plausible and self-consistent parameters:\n- Number of cells $ N = 10 $,\n- Cell width $ h = 1 $ centimeter,\n- Absorption cross section $ \\Sigma_a = 0.10 $ inverse centimeters,\n- Scattering cross section $ \\Sigma_s = 0.08 $ inverse centimeters,\n- Leakage coefficient $ D = 0.50 $ centimeters,\n- External source vector $ q $ is uniform with $ q_i = 1.0 $ for $ i = 0, 1, \\dots, N-1 $.\n\nFor each test case $ (\\alpha, c, \\delta) $, construct $ \\phi_\\alpha = \\alpha \\phi^\\star $, compute the residual $ r(\\phi_\\alpha) $ and its two-norm $ \\| r(\\phi_\\alpha) \\|_2 $, and the relative absorption reaction-rate error $ \\varepsilon_R(\\phi_\\alpha) $. Then determine the boolean value of the implication\n$$\n\\| r(\\phi_\\alpha) \\|_2 \\le \\tau \\ \\Rightarrow \\ \\varepsilon_R(\\phi_\\alpha) \\le \\delta.\n$$\nReturn True if the implication holds and False otherwise. Note that if $ \\| r(\\phi_\\alpha) \\|_2  \\tau $, the implication is vacuously true.\n\nTest Suite:\nUse the following four test cases that exercise different facets of the implication logic, including a general case, a boundary case, a case where the tolerance is not sufficiently strict, and a vacuous true case:\n1. $ (\\alpha, c, \\delta) = (0.99, 0.012, 0.015) $,\n2. $ (\\alpha, c, \\delta) = (0.97, 0.030, 0.030) $,\n3. $ (\\alpha, c, \\delta) = (0.95, 0.051, 0.040) $,\n4. $ (\\alpha, c, \\delta) = (0.80, 0.150, 0.020) $.\n\nFinal Output Format:\nYour program should produce a single line of output containing the resulting boolean values for the four test cases as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True,True]\").",
            "solution": "We begin from the steady-state, monoenergetic neutron transport equation integrated over directions and volumes to yield a discrete balance per cell, which states that production equals losses. In a linear discretization suitable for iterative transport solvers, the unknown scalar flux vector $ \\phi $ satisfies the linear system\n$$\nA \\phi = q,\n$$\nwhere $ A $ combines streaming/leakage, absorption, and scattering removal. The leakage matrix $ L $ constructed with the stated $ D $ and $ h $ induces coupling between neighboring cells and contributes to losses; the diagonal terms $ \\Sigma_a $ and $ \\Sigma_s $ represent material interactions. The exact solution $ \\phi^\\star $ satisfies $ A \\phi^\\star = q $. For any approximate $ \\phi $, the residual vector\n$$\nr(\\phi) = q - A \\phi\n$$\nis the cell-wise balance residual: it measures the difference between production ($ q + \\Sigma_s \\phi $ implicitly included when the scattering term is moved to the left-hand side of $ A $) and losses ($ \\Sigma_a \\phi + L \\phi $), rendered here compactly by the linear system residual.\n\nReaction rates are linear functionals of the scalar flux. The absorption reaction rate vector is\n$$\nR(\\phi) = \\Sigma_a \\phi,\n$$\nand the relative absorption reaction-rate error is\n$$\n\\varepsilon_R(\\phi) = \\frac{\\| R(\\phi) - R(\\phi^\\star) \\|_2}{\\| R(\\phi^\\star) \\|_2}.\n$$\nTo analyze how residual tolerances control reaction-rate errors, consider the error $ e = \\phi - \\phi^\\star $. Substituting into the residual definition,\n$$\nr(\\phi) = q - A \\phi = A \\phi^\\star - A \\phi = -A (\\phi - \\phi^\\star) = -A e.\n$$\nThus,\n$$\ne = -A^{-1} r(\\phi).\n$$\nApplying the absorption reaction rate operator gives\n$$\nR(\\phi) - R(\\phi^\\star) = \\Sigma_a (\\phi - \\phi^\\star) = -\\Sigma_a A^{-1} r(\\phi).\n$$\nTaking two-norms and using submultiplicativity yields the bound\n$$\n\\| R(\\phi) - R(\\phi^\\star) \\|_2 \\le \\| \\Sigma_a A^{-1} \\|_2 \\, \\| r(\\phi) \\|_2.\n$$\nDividing by $ \\| R(\\phi^\\star) \\|_2 $ gives\n$$\n\\varepsilon_R(\\phi) \\le \\frac{\\| \\Sigma_a A^{-1} \\|_2}{\\| R(\\phi^\\star) \\|_2} \\, \\| r(\\phi) \\|_2.\n$$\nTherefore, a sufficient condition to guarantee that $ \\varepsilon_R(\\phi) \\le \\delta $ is\n$$\n\\| r(\\phi) \\|_2 \\le \\tau_\\text{suff} \\equiv \\delta \\, \\frac{\\| R(\\phi^\\star) \\|_2}{\\| \\Sigma_a A^{-1} \\|_2}.\n$$\nThis shows from first principles how a residual tolerance controls reaction-rate errors via operator norms.\n\nFor the specific test construction $ \\phi_\\alpha = \\alpha \\phi^\\star $ with scalar $ \\alpha $, substitute into the residual:\n$$\nr(\\phi_\\alpha) = q - A (\\alpha \\phi^\\star) = q - \\alpha A \\phi^\\star = q - \\alpha q = (1 - \\alpha) q.\n$$\nHence,\n$$\n\\| r(\\phi_\\alpha) \\|_2 = |1 - \\alpha| \\, \\| q \\|_2.\n$$\nThe reaction-rate error becomes\n$$\nR(\\phi_\\alpha) - R(\\phi^\\star) = \\Sigma_a (\\alpha \\phi^\\star - \\phi^\\star) = (\\alpha - 1) \\Sigma_a \\phi^\\star,\n$$\nso\n$$\n\\varepsilon_R(\\phi_\\alpha) = \\frac{\\| (\\alpha - 1) \\Sigma_a \\phi^\\star \\|_2}{\\| \\Sigma_a \\phi^\\star \\|_2} = | \\alpha - 1 |.\n$$\nThis exact relationship shows that, in this construction, meeting the residual tolerance $ \\| r(\\phi_\\alpha) \\|_2 \\le \\tau $ implies $ \\varepsilon_R(\\phi_\\alpha) \\le \\delta $ if and only if\n$$\n|1 - \\alpha| \\, \\| q \\|_2 \\le \\tau \\quad \\text{and} \\quad |1 - \\alpha| \\le \\delta.\n$$\nIf one sets $ \\tau = c \\, \\| q \\|_2 $, then $ \\| r(\\phi_\\alpha) \\|_2 \\le \\tau $ whenever $ |1 - \\alpha| \\le c $. Consequently, for this family of approximate fluxes, choosing $ c \\ge |1 - \\alpha| $ ensures the residual criterion is met, and choosing $ \\delta \\ge |1 - \\alpha| $ ensures the reaction-rate error criterion is met. The implication $ \\| r(\\phi_\\alpha) \\|_2 \\le \\tau \\Rightarrow \\varepsilon_R(\\phi_\\alpha) \\le \\delta $ holds when both are satisfied simultaneously. If $ \\| r(\\phi_\\alpha) \\|_2  \\tau $, the implication is vacuously true regardless of $ \\delta $.\n\nAlgorithmic design:\n1. Construct $ L $ from $ D $ and $ h $ as specified, then assemble $ A = L + \\operatorname{diag}(\\Sigma_a \\mathbf{1}) - \\operatorname{diag}(\\Sigma_s \\mathbf{1}) $.\n2. Form $ q $ as a uniform vector of ones, solve $ A \\phi^\\star = q $ for $ \\phi^\\star $ using a robust linear solver.\n3. For each test case $ (\\alpha, c, \\delta) $, compute $ \\phi_\\alpha = \\alpha \\phi^\\star $, the residual $ r(\\phi_\\alpha) = q - A \\phi_\\alpha $, and its two-norm $ \\| r(\\phi_\\alpha) \\|_2 $. Compute $ \\tau = c \\, \\| q \\|_2 $.\n4. Compute $ \\varepsilon_R(\\phi_\\alpha) = \\| \\Sigma_a (\\phi_\\alpha - \\phi^\\star) \\|_2 / \\| \\Sigma_a \\phi^\\star \\|_2 $.\n5. Evaluate the implication: return True if $ \\| r(\\phi_\\alpha) \\|_2 \\le \\tau $ implies $ \\varepsilon_R(\\phi_\\alpha) \\le \\delta $, otherwise False. If $ \\| r(\\phi_\\alpha) \\|_2  \\tau $, return True since the implication is vacuously true.\n6. Aggregate the boolean results for all test cases into a single list in the specified output format.\n\nCoverage of the test suite:\n- A general case where the tolerance and desired fraction exceed the actual residual-derived scale, yielding True.\n- A boundary case where both criteria are met exactly, yielding True.\n- A case where the residual tolerance is met but the desired fraction is too strict, yielding False.\n- A vacuous case where the residual tolerance is not met, yielding True.\n\nThis principled approach aligns with convergence criteria in iterative transport solvers: residual norms provide a practical stopping condition, and bounding reaction-rate errors via operator-based estimates provides a theoretical guarantee. The specific scaled-flux tests provide exact relations that demonstrate the implication behavior concretely.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_leakage_matrix(N, D, h):\n    \"\"\"\n    Build the symmetric tridiagonal leakage matrix L of size N x N:\n    L_{i,i} = D/h^2 for boundaries, 2D/h^2 for interior,\n    L_{i,i+1} = L_{i+1,i} = -D/h^2.\n    \"\"\"\n    L = np.zeros((N, N), dtype=float)\n    coef = D / (h**2)\n    for i in range(N):\n        if i == 0 or i == N - 1:\n            L[i, i] = coef\n        else:\n            L[i, i] = 2.0 * coef\n        if i  N - 1:\n            L[i, i + 1] = -coef\n            L[i + 1, i] = -coef\n    return L\n\ndef solve_benchmark_and_check():\n    # Benchmark parameters\n    N = 10       # number of cells\n    h = 1.0      # cm\n    Sigma_a = 0.10  # 1/cm\n    Sigma_s = 0.08  # 1/cm\n    D = 0.50        # cm\n\n    # Build A = L + diag(Sigma_a) - diag(Sigma_s)\n    L = build_leakage_matrix(N, D, h)\n    A = L + np.diag(np.full(N, Sigma_a)) - np.diag(np.full(N, Sigma_s))\n\n    # External source vector q (uniform ones)\n    q = np.ones(N, dtype=float)\n\n    # Solve for exact flux phi_star\n    phi_star = np.linalg.solve(A, q)\n\n    # Precompute norms used in tolerances and errors\n    q_norm = np.linalg.norm(q, 2)\n    R_star = Sigma_a * phi_star\n    R_star_norm = np.linalg.norm(R_star, 2)\n\n    # Test cases: (alpha, c, delta)\n    test_cases = [\n        (0.99, 0.012, 0.015),  # Happy path: residual within tau and error within delta\n        (0.97, 0.030, 0.030),  # Boundary: equality case\n        (0.95, 0.051, 0.040),  # Residual within tau but error above desired fraction\n        (0.80, 0.150, 0.020),  # Vacuous true: residual exceeds tau\n    ]\n\n    results = []\n    for alpha, c, delta in test_cases:\n        # Construct approximate flux\n        phi_alpha = alpha * phi_star\n\n        # Compute residual and its norm\n        r = q - A @ phi_alpha\n        r_norm = np.linalg.norm(r, 2)\n\n        # Residual tolerance\n        tau = c * q_norm\n\n        # Compute relative absorption reaction-rate error\n        R_err = Sigma_a * (phi_alpha - phi_star)\n        R_err_norm = np.linalg.norm(R_err, 2)\n        epsilon_R = R_err_norm / R_star_norm if R_star_norm != 0.0 else 0.0\n\n        # Implication: if residual = tau then epsilon_R = delta\n        if r_norm = tau:\n            results.append(epsilon_R = delta)\n        else:\n            # Implication is vacuously true when premise is false\n            results.append(True)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve():\n    solve_benchmark_and_check()\n\nsolve()\n```"
        },
        {
            "introduction": "Realistic transport solvers often involve nested iterations, where an 'outer' loop manages a physics process like fission source updates, and an 'inner' loop solves a transport sweep. This final practice addresses the critical question of how to balance the computational work between these nested loops for maximum efficiency. You will implement an adaptive strategy  that tightens the inner solver's tolerance as the outer iteration converges, demonstrating a powerful technique for reducing total runtime without sacrificing final accuracy.",
            "id": "4218844",
            "problem": "Consider a steady-state, one-group iterative transport solver for the Neutron Transport Equation (NTE) written abstractly as a fixed-point problem with iteration map $G$ acting on an unknown state vector $x$, where the exact fixed point $x^\\star$ satisfies $x^\\star = G(x^\\star)$. Assume the outer iteration is a contraction in a compatible norm $\\|\\cdot\\|$ with modulus $0  \\rho  1$ so that for all iterates $x_m$ one has $\\|G(x_m) - G(x^\\star)\\| \\le \\rho \\|x_m - x^\\star\\|$. In practice, the inner transport sweep or linear solve used to apply $G$ is performed inexactly, producing an additive inner error $e_m$ at outer step $m$, yielding the inexact fixed-point update $x_{m+1} = G(x_m) + e_m$.\n\nStarting from the Banach fixed-point principles for contractions and the definition of the residual $r_m = \\|x_m - G(x_m)\\|$, formulate an adaptive strategy for the inner tolerance $\\epsilon_m$ that uses the outer residual as a proxy to tighten tolerances as the outer iteration progresses. Your strategy must be expressed as $\\epsilon_m = \\min\\{\\epsilon_{\\text{cap}}, \\kappa \\, r_m^p\\}$ with parameters $0  \\kappa$ and $p \\ge 1$, and a cap $\\epsilon_{\\text{cap}}  0$. Then, derive how the inexactness propagates in the outer error recursion and use it to quantify the trade-off between total inner work and final outer accuracy.\n\nAssume the following modeling assumptions, consistent with widely used iterative solver behavior:\n- The outer error satisfies the inexact recursion bound $\\|x_{m+1} - x^\\star\\| \\le \\rho \\|x_m - x^\\star\\| + \\epsilon_m$.\n- The outer residual and error are related by bounds $\\left(1 - \\rho\\right)\\|x_m - x^\\star\\| \\le r_m \\le \\left(1 + \\rho\\right)\\|x_m - x^\\star\\|$. For a conservative algorithmic design, you may use $r_m \\approx \\left(1 - \\rho\\right)\\|x_m - x^\\star\\|$ as a proxy.\n- The inner work at step $m$ (e.g., number of inner iterations or normalized computational effort) follows a logarithmic model $w_m = a_0 + a_1 \\max\\left\\{0, \\log\\left(\\frac{\\epsilon_{\\text{ref}}}{\\epsilon_m}\\right)\\right\\}$ for some $\\epsilon_{\\text{ref}}  0$ and coefficients $a_0  0$, $a_1  0$, reflecting geometric inner convergence to tolerance. The total work is $W = \\sum_{m=0}^{M-1} w_m$.\n\nYour program must implement the adaptive tolerance strategy and report, for each test case, the total inner work $W$ and the final outer error $E_M = \\|x_M - x^\\star\\|$ after $M$ outer steps, using the conservative recursion $E_{m+1} = \\rho E_m + \\epsilon_m$ with $E_0$ given. For comparison, include test cases that use a fixed inner tolerance schedule where $\\epsilon_m \\equiv \\epsilon_{\\text{cap}}$ for all $m$.\n\nUse the following test suite of parameter sets, each specified as a tuple containing: schedule type, contraction modulus $\\rho$, initial outer error $E_0$, number of outer iterations $M$, tolerance parameters $\\kappa$, $p$, cap $\\epsilon_{\\text{cap}}$, and inner work parameters $a_0$, $a_1$, $\\epsilon_{\\text{ref}}$:\n- Test Case $1$: adaptive schedule, $\\rho = 0.85$, $E_0 = 1.0$, $M = 30$, $\\kappa = 0.50$, $p = 1$, $\\epsilon_{\\text{cap}} = 10^{-4}$, $a_0 = 1.0$, $a_1 = 12.0$, $\\epsilon_{\\text{ref}} = 1.0$.\n- Test Case $2$: adaptive schedule, $\\rho = 0.95$, $E_0 = 1.0$, $M = 60$, $\\kappa = 0.03$, $p = 1$, $\\epsilon_{\\text{cap}} = 10^{-5}$, $a_0 = 1.0$, $a_1 = 12.0$, $\\epsilon_{\\text{ref}} = 1.0$.\n- Test Case $3$: fixed schedule, $\\rho = 0.95$, $E_0 = 1.0$, $M = 60$, $\\kappa$ ignored, $p$ ignored, $\\epsilon_{\\text{cap}} = 10^{-5}$, $a_0 = 1.0$, $a_1 = 12.0$, $\\epsilon_{\\text{ref}} = 1.0$.\n- Test Case $4$: adaptive schedule, $\\rho = 0.30$, $E_0 = 1.0$, $M = 20$, $\\kappa = 0.50$, $p = 1$, $\\epsilon_{\\text{cap}} = 10^{-4}$, $a_0 = 1.0$, $a_1 = 12.0$, $\\epsilon_{\\text{ref}} = 1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list with two floating-point numbers $[W, E_M]$, so the final output must be of the form $[[W_1,E_{M,1}],[W_2,E_{M,2}],[W_3,E_{M,3}],[W_4,E_{M,4}]]$.",
            "solution": "The problem requires the formulation and analysis of an adaptive inner tolerance strategy for an inexact iterative solver for the Neutron Transport Equation. The solver is abstractly represented as a fixed-point problem $x^\\star = G(x^\\star)$, where $G$ is a contraction mapping. The practical iteration is inexact, given by $x_{m+1} = G(x_m) + e_m$, where $e_m$ is the error from the inner solve at outer iteration $m$, bounded in norm by the inner tolerance such that $\\|e_m\\| \\le \\epsilon_m$.\n\nFirst, we establish the recurrence relation for the outer error, defined as $E_m = \\|x_m - x^\\star\\|$. The exact fixed point satisfies $x^\\star = G(x^\\star)$. Subtracting this from the inexact update equation gives:\n$$ x_{m+1} - x^\\star = (G(x_m) - G(x^\\star)) + e_m $$\nTaking the norm of both sides and applying the triangle inequality yields:\n$$ \\|x_{m+1} - x^\\star\\| \\le \\|G(x_m) - G(x^\\star)\\| + \\|e_m\\| $$\nUsing the given contraction property, $\\|G(x_m) - G(x^\\star)\\| \\le \\rho \\|x_m - x^\\star\\|$ with modulus $0  \\rho  1$, and the bound on the inner error, $\\|e_m\\| \\le \\epsilon_m$, we arrive at the outer error recursion bound:\n$$ E_{m+1} \\le \\rho E_m + \\epsilon_m $$\nFor a conservative analysis and for the purpose of the simulation requested in the problem, we will use this relationship as an equality: $E_{m+1} = \\rho E_m + \\epsilon_m$.\n\nThe proposed adaptive strategy for the inner tolerance, $\\epsilon_m = \\min\\{\\epsilon_{\\text{cap}}, \\kappa \\, r_m^p\\}$, depends on the outer residual, $r_m = \\|x_m - G(x_m)\\|$. The residual is an observable quantity at each step, unlike the true error $E_m$, and serves as a computable proxy for it. The relationship between the residual and the error is given by the well-known bounds:\n$$ (1 - \\rho)\\|x_m - x^\\star\\| \\le \\|x_m - G(x_m)\\| \\le (1 + \\rho)\\|x_m - x^\\star\\| $$\nTo derive these, we use the definition of $r_m$ and the triangle inequality:\n$$ r_m = \\|x_m - G(x_m)\\| = \\|(x_m - x^\\star) - (G(x_m) - G(x^\\star))\\| $$\nThe upper bound follows:\n$$ r_m \\le \\|x_m - x^\\star\\| + \\|G(x_m) - G(x^\\star)\\| \\le E_m + \\rho E_m = (1 + \\rho) E_m $$\nThe lower bound follows from the reverse triangle inequality:\n$$ r_m \\ge \\left| \\|x_m - x^\\star\\| - \\|G(x_m) - G(x^\\star)\\| \\right| \\ge E_m - \\rho E_m = (1 - \\rho) E_m $$\nThe rationale for the adaptive strategy is to couple the inner solver's precision to the outer iteration's progress. When the outer error $E_m$ (and thus the residual $r_m$) is large, a coarse inner tolerance $\\epsilon_m$ is sufficient, saving computational work. As the outer iteration converges ($E_m \\to 0$, $r_m \\to 0$), the inner tolerance must be tightened to resolve the solution accurately and prevent stagnation of the outer iteration due to inner solver noise. The parameter $\\kappa  0$ scales the tolerance relative to the residual, $p \\ge 1$ controls the rate of tightening, and $\\epsilon_{\\text{cap}}$ provides an upper bound on the tolerance value, ensuring a minimum level of inner accuracy is always maintained.\n\nFor the implementation, we use the provided conservative proxy $r_m \\approx (1 - \\rho)E_m$. Substituting this into the adaptive strategy gives the formula for the inner tolerance at step $m$ in terms of the error $E_m$:\n$$ \\epsilon_m = \\min\\{\\epsilon_{\\text{cap}}, \\kappa ((1-\\rho)E_m)^p\\} $$\n\nThe computational effort is modeled by the total inner work, $W = \\sum_{m=0}^{M-1} w_m$, where the work at each step, $w_m$, depends logarithmically on the inverse of the tolerance:\n$$ w_m = a_0 + a_1 \\max\\left\\{0, \\log\\left(\\frac{\\epsilon_{\\text{ref}}}{\\epsilon_m}\\right)\\right\\} $$\nThis model reflects the typical geometric convergence of an iterative inner solver, where achieving an additional digit of accuracy requires a fixed amount of extra work. The parameters $a_0  0$ and $a_1  0$ represent the fixed startup cost and the per-e-folding cost of the inner solver, respectively.\n\nThe simulation will proceed for a total of $M$ steps, starting with an initial error $E_0$. At each step $m = 0, 1, \\dots, M-1$, we will:\n1.  Calculate the inner tolerance $\\epsilon_m$ based on the current error $E_m$ and the specified schedule (adaptive or fixed). For a fixed schedule, $\\epsilon_m \\equiv \\epsilon_{\\text{cap}}$.\n2.  Calculate the work for the current step, $w_m$, using the work model.\n3.  Accumulate the total work, $W$.\n4.  Update the outer error for the next step using the recursion $E_{m+1} = \\rho E_m + \\epsilon_m$.\n\nThe final reported values will be the total work $W$ and the final error $E_M$ after $M$ steps.\n\nA point of interest arises from the specific parameters chosen for the test cases. For Test Case $2$ (adaptive) and Test Case $3$ (fixed), the adaptive strategy of Case $2$ degenerates into a fixed tolerance strategy identical to Case $3$. This is because the condition for the adaptive component to become active, $\\kappa((1-\\rho)E_m)^p  \\epsilon_{\\text{cap}}$, which with the supplied parameters is $0.03 \\times (0.05 \\times E_m)  10^{-5}$, or $E_m  10^{-5} / 0.0015 \\approx 0.0067$, is not met within the specified $M=60$ iterations. Consequently, for all steps $m  60$, the tolerance is determined by the cap, $\\epsilon_m = \\min\\{\\epsilon_{\\text{cap}}, \\dots\\} = \\epsilon_{\\text{cap}}$. This results in identical behavior and outputs for both cases. In contrast, Test Case $4$, with its rapidly converging outer iteration ($\\rho=0.3$), will properly demonstrate the transition from the capped tolerance to the dynamically reducing tolerance.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates an adaptive inner tolerance strategy for an\n    inexact iterative solver based on provided theoretical models.\n\n    The program calculates the total computational work and final error for\n    several test cases of an iterative scheme, comparing adaptive and fixed\n    tolerance schedules.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains:\n    # (schedule type, rho, E0, M, kappa, p, eps_cap, a0, a1, eps_ref)\n    test_cases = [\n        ('adaptive', 0.85, 1.0, 30, 0.50, 1, 1e-4, 1.0, 12.0, 1.0),\n        ('adaptive', 0.95, 1.0, 60, 0.03, 1, 1e-5, 1.0, 12.0, 1.0),\n        ('fixed', 0.95, 1.0, 60, None, None, 1e-5, 1.0, 12.0, 1.0),\n        ('adaptive', 0.30, 1.0, 20, 0.50, 1, 1e-4, 1.0, 12.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        schedule_type, rho, E0, M, kappa, p, eps_cap, a0, a1, eps_ref = case\n\n        current_error = E0\n        total_work = 0.0\n\n        for _ in range(M):\n            # Step 1: Calculate inner tolerance eps_m based on the schedule\n            if schedule_type == 'adaptive':\n                # Use the conservative proxy for the residual: r_m approx (1 - rho) * E_m\n                residual_proxy = (1.0 - rho) * current_error\n                # Calculate the dynamically adjusted tolerance based on the residual\n                adaptive_tol = kappa * (residual_proxy ** p)\n                # The tolerance is the minimum of the cap and the adaptive value\n                inner_tolerance = min(eps_cap, adaptive_tol)\n            else:  # 'fixed' schedule\n                inner_tolerance = eps_cap\n\n            # Step 2: Calculate work for the current step w_m\n            # The work model is w_m = a0 + a1 * max(0, log(eps_ref / eps_m))\n            # Ensure argument to log is positive\n            if inner_tolerance > 0:\n                log_arg = eps_ref / inner_tolerance\n                log_term = np.log(log_arg)\n            else:\n                # This case should not be reached with the given problem constraints\n                log_term = np.inf\n            \n            step_work = a0 + a1 * max(0, log_term)\n\n            # Step 3: Accumulate total work\n            total_work += step_work\n\n            # Step 4: Update outer error for the next step using E_{m+1} = rho * E_m + eps_m\n            current_error = rho * current_error + inner_tolerance\n            \n        final_error = current_error\n        results.append([total_work, final_error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}