{
    "hands_on_practices": [
        {
            "introduction": "The effectiveness of a multigrid solver hinges on the quality of its coarse-grid operators. For the heterogeneous materials found in nuclear reactor cores, a naive rediscretization of the governing equations on a coarse grid can fail to capture essential fine-scale physics, leading to poor convergence. This exercise () challenges you to derive and compare a naive coarse operator with the mathematically robust Galerkin operator. By working through a classic checkerboard problem, you will uncover the fundamental reason why the Galerkin construction is essential for creating powerful algebraic multigrid (AMG) methods that can handle sharp discontinuities in material properties.",
            "id": "4236904",
            "problem": "Consider the one-group steady neutron diffusion equation in Cartesian geometry, written for the scalar neutron flux $\\phi(x,y)$ as $-\\nabla \\cdot (D(x,y)\\nabla \\phi) = 0$, where $D(x,y)$ is the diffusion coefficient. Assume a conservative cell-centered finite-volume discretization on a uniform $2 \\times 2$ fine grid of square cells of side length $h$, with cell centers at the usual midpoints and face-centered diffusive fluxes computed by Fick's law and continuity of normal current. The diffusion coefficient $D(x,y)$ is heterogeneous in a checkerboard pattern: the top-left fine cell has $D = D_{A}$, the top-right has $D = D_{B}$, the bottom-left has $D = D_{B}$, and the bottom-right has $D = D_{A}$, with $D_{A} > 0$ and $D_{B} > 0$.\n\nForm a two-cell coarse grid by aggregating the two left fine cells into a single coarse cell $L$ and the two right fine cells into a single coarse cell $R$. Define the multigrid coarse operator by the Galerkin projection with restriction $R = P^{\\top}$, where the prolongation $P$ is piecewise constant on aggregates: a coarse degree of freedom injects a constant value to all its constituent fine cells, and zero elsewhere. For comparison, define a rediscretized coarse operator by discretizing the same diffusion equation on the two-cell coarse grid, using the same finite-volume scheme, with coarse-cell diffusion coefficients given by the volume average within each aggregate, i.e., $D_{L}^{c} = (D_{A} + D_{B})/2$ and $D_{R}^{c} = (D_{A} + D_{B})/2$.\n\nLet the coarse-grid off-diagonal entry between $L$ and $R$ be denoted by $A_{H}^{\\text{Gal}}(L,R)$ for the Galerkin operator and $A_{H}^{\\text{Red}}(L,R)$ for the rediscretized operator. Using only the fundamental definitions above (Fick’s law for diffusive flux, continuity of normal current across faces, and conservative finite-volume balance), derive each off-diagonal entry from first principles. Then compute the ratio of magnitudes\n$$\\mathcal{R} = \\frac{|A_{H}^{\\text{Red}}(L,R)|}{|A_{H}^{\\text{Gal}}(L,R)|}$$\nas a closed-form analytic expression in terms of $D_{A}$ and $D_{B}$.\n\nFinally, briefly explain, based on your derivation, which construction better captures the fine-scale physics across the coarse interface for the given checkerboard heterogeneity. Express the final ratio $\\mathcal{R}$ as your answer. No rounding is required, and no units should be included in the final expression.",
            "solution": "The problem requires the derivation of off-diagonal entries for two types of multigrid coarse-grid operators—Galerkin and rediscretized—and the calculation of the ratio of their magnitudes. The analysis is based on a cell-centered finite-volume discretization of the steady-state neutron diffusion equation, $-\\nabla \\cdot (D(x,y)\\,\\nabla \\phi) = 0$, on a specific $2 \\times 2$ heterogeneous grid.\n\nFirst, we establish the fine-grid discretization. The domain is a $2 \\times 2$ grid of square cells, each with side length $h$. Let the cells be numbered as follows:\n- Cell $1$: top-left, with diffusion coefficient $D_1 = D_A$.\n- Cell $2$: top-right, with diffusion coefficient $D_2 = D_B$.\n- Cell $3$: bottom-left, with diffusion coefficient $D_3 = D_B$.\n- Cell $4$: bottom-right, with diffusion coefficient $D_4 = D_A$.\n\nThe cell-centered finite-volume method yields a system of linear equations $A_h \\phi_h = f_h$, where $\\phi_h = [\\phi_1, \\phi_2, \\phi_3, \\phi_4]^{\\top}$ is the vector of cell-averaged fluxes. The equation for a cell $i$ is derived from the conservative balance law, which states that the sum of currents leaving the cell through its faces is zero (for a source-free problem).\nThe current across the face between cell $i$ and cell $j$ is given by Fick's law. For a face of length $h$ and cell center distance $h$, the integrated current (or flux) is $F_{ij} = C_{ij}(\\phi_i - \\phi_j)$, where $C_{ij}$ is the conductance. The matrix entry $A_{ij}$ for $i \\neq j$ is given by $A_{ij} = -C_{ij}$. The conductance is defined as $C_{ij} = \\frac{D_{ij} \\cdot (\\text{face area})}{(\\text{cell distance})}$, where $D_{ij}$ is the diffusion coefficient at the interface.\nFor a 2D problem on a square grid of side $h$, the face area is $h$ (per unit depth) and the distance between cell centers is $h$. Thus, $C_{ij} = D_{ij}$. The problem specifies continuity of normal current, which implies that the interface diffusion coefficient $D_{ij}$ should be the harmonic mean of the diffusion coefficients of the adjacent cells: $D_{ij} = \\frac{2 D_i D_j}{D_i + D_j}$.\n\nLet's compute the conductances between adjacent fine cells:\n- Interface $1$-$2$: $C_{12} = \\frac{2 D_1 D_2}{D_1 + D_2} = \\frac{2 D_A D_B}{D_A + D_B}$.\n- Interface $1$-$3$: $C_{13} = \\frac{2 D_1 D_3}{D_1 + D_3} = \\frac{2 D_A D_B}{D_A + D_B}$.\n- Interface $2$-$4$: $C_{24} = \\frac{2 D_2 D_4}{D_2 + D_4} = \\frac{2 D_B D_A}{D_B + D_A}$.\n- Interface $3$-$4$: $C_{34} = \\frac{2 D_3 D_4}{D_3 + D_4} = \\frac{2 D_B D_A}{D_B + D_A}$.\nAll four conductances are identical. Let us denote this value by $K = \\frac{2 D_A D_B}{D_A + D_B}$. The off-diagonal entries of the fine-grid matrix $A_h$ are $A_{ij} = -K$ if cells $i$ and $j$ are adjacent, and $0$ otherwise. The diagonal entries are $A_{ii} = -\\sum_{j \\neq i} A_{ij}$. This gives the fine-grid operator matrix:\n$$\nA_h = \\begin{pmatrix}\nC_{12}+C_{13}  -C_{12}  -C_{13}  0 \\\\\n-C_{21}  C_{21}+C_{24}  0  -C_{24} \\\\\n-C_{31}  0  C_{31}+C_{34}  -C_{34} \\\\\n0  -C_{42}  -C_{43}  C_{42}+C_{43}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2K  -K  -K  0 \\\\\n-K  2K  0  -K \\\\\n-K  0  2K  -K \\\\\n0  -K  -K  2K\n\\end{pmatrix}\n$$\n\nNext, we construct the Galerkin coarse-grid operator, $A_{H}^{\\text{Gal}} = R A_h P$. The coarse grid consists of two cells: $L$ (aggregating fine cells $1$ and $3$) and $R$ (aggregating fine cells $2$ and $4$). The prolongation operator $P$ maps the coarse-flux vector $\\phi_H = [\\phi_L, \\phi_R]^{\\top}$ to the fine-flux vector $\\phi_h$ via piecewise constant injection: $\\phi_1 = \\phi_L$, $\\phi_3 = \\phi_L$, $\\phi_2 = \\phi_R$, $\\phi_4 = \\phi_R$. In matrix form:\n$$\nP = \\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n1  0 \\\\\n0  1\n\\end{pmatrix}\n$$\nThe restriction operator $R$ is the transpose of $P$:\n$$\nR = P^{\\top} = \\begin{pmatrix}\n1  0  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n$$\nNow we compute $A_{H}^{\\text{Gal}} = R A_h P$:\n$$\nA_h P = \\begin{pmatrix}\n2K  -K  -K  0 \\\\\n-K  2K  0  -K \\\\\n-K  0  2K  -K \\\\\n0  -K  -K  2K\n\\end{pmatrix}\n\\begin{pmatrix}\n1  0 \\\\\n0  1 \\\\\n1  0 \\\\\n0  1\n\\end{pmatrix} = \\begin{pmatrix}\n(2K-K)  -K \\\\\n-K  (2K-K) \\\\\n(-K+2K)  -K \\\\\n-K  (-K+2K)\n\\end{pmatrix} = \\begin{pmatrix}\nK  -K \\\\\n-K  K \\\\\nK  -K \\\\\n-K  K\n\\end{pmatrix}\n$$\n$$\nA_{H}^{\\text{Gal}} = R (A_h P) = \\begin{pmatrix}\n1  0  1  0 \\\\\n0  1  0  1\n\\end{pmatrix}\n\\begin{pmatrix}\nK  -K \\\\\n-K  K \\\\\nK  -K \\\\\n-K  K\n\\end{pmatrix} = \\begin{pmatrix}\n(K+K)  (-K-K) \\\\\n(-K-K)  (K+K)\n\\end{pmatrix} = \\begin{pmatrix}\n2K  -2K \\\\\n-2K  2K\n\\end{pmatrix}\n$$\nThe off-diagonal entry for the Galerkin operator is $A_{H}^{\\text{Gal}}(L,R) = -2K$. Substituting the expression for $K$:\n$$A_{H}^{\\text{Gal}}(L,R) = -2 \\left( \\frac{2 D_A D_B}{D_A + D_B} \\right) = -\\frac{4 D_A D_B}{D_A + D_B}$$\n\nNext, we derive the rediscretized coarse operator, $A_{H}^{\\text{Red}}$. This involves discretizing the diffusion equation on the coarse grid itself. Each coarse cell has dimensions $h \\times 2h$. The diffusion coefficients for the coarse cells are volume averages of the constituent fine cells. Since each fine cell has area $h^2$:\n- $D_{L}^{c} = \\frac{D_A \\cdot h^2 + D_B \\cdot h^2}{h^2 + h^2} = \\frac{D_A + D_B}{2}$.\n- $D_{R}^{c} = \\frac{D_B \\cdot h^2 + D_A \\cdot h^2}{h^2 + h^2} = \\frac{D_A + D_B}{2}$.\nWe apply the same finite-volume scheme to this two-cell coarse grid. The off-diagonal entry $A_{H}^{\\text{Red}}(L,R)$ is the negative of the conductance $C_{LR}$ between coarse cells $L$ and $R$.\n$$C_{LR} = \\frac{D_{\\text{int}} \\cdot (\\text{face area})}{(\\text{cell distance})}$$\nThe interface between cells $L$ and $R$ has area (length) $2h$. The distance between the coarse cell centers is $h$. The interface diffusion coefficient $D_{\\text{int}}$ is the harmonic mean of $D_L^c$ and $D_R^c$:\n$$D_{\\text{int}} = \\frac{2 D_L^c D_R^c}{D_L^c + D_R^c} = \\frac{2 \\left(\\frac{D_A+D_B}{2}\\right) \\left(\\frac{D_A+D_B}{2}\\right)}{\\left(\\frac{D_A+D_B}{2}\\right) + \\left(\\frac{D_A+D_B}{2}\\right)} = \\frac{D_A+D_B}{2}$$\nThe coarse-grid conductance is therefore:\n$$C_{LR} = \\frac{\\left(\\frac{D_A+D_B}{2}\\right) \\cdot (2h)}{h} = D_A + D_B$$\nThe off-diagonal entry for the rediscretized operator is $A_{H}^{\\text{Red}}(L,R) = -C_{LR} = -(D_A + D_B)$.\n\nFinally, we compute the ratio $\\mathcal{R}$:\n$$\\mathcal{R} = \\frac{|A_{H}^{\\text{Red}}(L,R)|}{|A_{H}^{\\text{Gal}}(L,R)|} = \\frac{|-(D_A + D_B)|}{\\left|-\\frac{4 D_A D_B}{D_A + D_B}\\right|} = \\frac{D_A + D_B}{\\frac{4 D_A D_B}{D_A + D_B}}$$\n$$\\mathcal{R} = \\frac{(D_A + D_B)^2}{4 D_A D_B}$$\n\nBased on this derivation, we can assess which construction is superior. The Galerkin operator's off-diagonal term, $A_{H}^{\\text{Gal}}(L,R) = -2K$, represents the negative sum of all fine-scale conductances connecting the aggregates $L$ and $R$. The total conductance across the coarse interface is the sum of the conductances of the two fine-scale interfaces ($1$-$2$ and $3$-$4$) that compose it. This corresponds physically to two parallel paths for diffusion, and summing their individual conductances ($K+K=2K$) correctly yields the total conductance. Thus, the Galerkin operator accurately preserves the total fine-scale flux across the coarse-cell boundary.\nThe rediscretized operator, in contrast, first computes an arithmetic average of the diffusion coefficients within each coarse cell, $D_L^c=D_R^c=(D_A+D_B)/2$. This homogenization step smooths over the critical checkerboard heterogeneity, creating an effective medium. The subsequent discretization on this homogenized medium yields a conductance of $D_A+D_B$. This value does not correspond to the physical reality of diffusion across the alternating high and low-conductivity paths. The ratio $\\mathcal{R}$ is a measure of the discrepancy. By the inequality of arithmetic and geometric means, $(D_A+D_B)^2 \\ge 4 D_A D_B$, so $\\mathcal{R} \\ge 1$. This shows that the rediscretized coarse operator overestimates the coupling (conductance) between the coarse cells whenever $D_A \\neq D_B$. For problems with high contrast ($D_A \\gg D_B$ or $D_B \\gg D_A$), this overestimation can be severe, leading to poor convergence of the multigrid solver. The Galerkin construction, by correctly summing the physical pathways, better captures the fine-scale physics and is the preferred method for such problems.",
            "answer": "$$\\boxed{\\frac{(D_A + D_B)^2}{4 D_A D_B}}$$"
        },
        {
            "introduction": "Once you have a strategy for defining your operators, the next question is how to implement them efficiently. In the world of high-performance computing, memory access is often the primary bottleneck, not floating-point operations. This practice () guides you through a quantitative comparison of two dominant implementation strategies: the matrix-based approach typical of Algebraic Multigrid (AMG), which stores the operator explicitly, and a matrix-free approach that re-computes the operator's action on-the-fly. By writing a short program to analyze the memory traffic for each method, you will gain a crucial, hardware-aware perspective on algorithm performance in large-scale simulations.",
            "id": "4236921",
            "problem": "Consider the three-dimensional neutron diffusion equation, a well-tested model for steady-state neutron transport in reactor physics, given by $$-\\nabla \\cdot \\left(D(\\mathbf{x}) \\nabla \\phi(\\mathbf{x})\\right) + \\Sigma_a(\\mathbf{x}) \\phi(\\mathbf{x}) = S(\\mathbf{x}),$$ where $D(\\mathbf{x})$ is the diffusion coefficient, $\\Sigma_a(\\mathbf{x})$ is the absorption cross section, $\\phi(\\mathbf{x})$ is the scalar flux, and $S(\\mathbf{x})$ is the source term. On a uniform rectilinear mesh with $N_x$ cells in the $x$ direction, $N_y$ cells in the $y$ direction, and $N_z$ cells in the $z$ direction, the discrete operator for isotropic diffusion with standard second-order finite differences has at most a seven-point stencil per interior cell.\n\nTwo multigrid strategies are considered for accelerating the solution of such discrete systems in nuclear reactor simulation:\n\n- Algebraic Multigrid (AMG), which stores the fine-grid operator explicitly in Compressed Sparse Row (CSR) format. CSR consists of three arrays: a row pointer of length $N+1$, column indices of length equal to the number of nonzeros, and floating-point values of the same length, where $N = N_x N_y N_z$ is the number of unknowns.\n\n- Matrix-free geometric multigrid, which does not store the explicit matrix. Instead, it stores field coefficients required for operator application (e.g., $D$ and $\\Sigma_a$) and computes the operator action on the fly by evaluating fluxes across cell faces using the stencil and local coefficients.\n\nAssume the following memory model and data representation, consistent with high-performance computing practice for large reactor meshes:\n\n- All floating-point values are stored in double precision, using $b_v = 8$ bytes per value.\n- All indices (row pointers and column indices) are stored in 64-bit integers, using $b_i = 8$ bytes per index.\n- For the CSR-based operator application (single sparse matrix-vector multiplication with $y = A x$), the memory traffic includes reading the row pointer array, reading the column indices and values for all nonzeros, reading the vector $x$, and writing the vector $y$.\n- For the matrix-free operator application using a seven-point stencil, the memory traffic includes reading the coefficient fields $D$ and $\\Sigma_a$ on cells, reading the vector $x$, and writing the vector $y$. Face coefficients are computed on the fly from neighboring cell-centered coefficients, and no explicit matrix or index arrays are read.\n\nStarting from these definitions and the structure of the seven-point stencil on a uniform three-dimensional grid, do the following:\n\n1. Derive an exact expression for the total number of nonzeros in the CSR representation of the seven-point discrete diffusion operator on an $N_x \\times N_y \\times N_z$ grid. Express this count using $N_x$, $N_y$, and $N_z$ only. Your derivation must be purely combinatorial, counting neighbor pairs along each coordinate direction.\n\n2. Using your result from part 1 and the memory model stated above, derive symbolic formulas for the total bytes read and written during a single operator application for:\n   - The CSR-based Algebraic Multigrid (AMG) sparse matrix-vector multiplication.\n   - The matrix-free operator application with cell-centered $D$ and $\\Sigma_a$.\n\n   Use only $N$, $N_x$, $N_y$, $N_z$, $b_v$, $b_i$, and the nonzero count in your expressions. Assume ideal reuse of the input vector and coefficient fields such that each is read exactly once per operator application.\n\n3. Given a memory bandwidth $B$ in bytes per second, derive expressions for the predicted time to complete one operator application in seconds for both AMG and matrix-free methods using a simple roofline-style bandwidth-bound model. The predicted time is the total memory traffic divided by $B$.\n\n4. Implement a program that evaluates, for each test case in the suite below, the following outputs:\n   - The total bytes for AMG operator application.\n   - The total bytes for matrix-free operator application.\n   - The ratio of AMG to matrix-free bytes (dimensionless speedup factor indicating memory traffic reduction).\n   - The predicted AMG time in seconds.\n   - The predicted matrix-free time in seconds.\n\nAll outputs involving time must be expressed in seconds. The program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is itself a list in the order described above. For floating-point results, print them in standard decimal notation.\n\nUse the following test suite to ensure coverage of a typical reactor core mesh, boundary-dominated small meshes, and degenerate slab geometries:\n\n- Test case 1 (general core-scale): $N_x = 128$, $N_y = 128$, $N_z = 64$, $B = 160 \\times 10^9$ bytes per second.\n- Test case 2 (boundary-dominated small mesh): $N_x = 4$, $N_y = 4$, $N_z = 4$, $B = 50 \\times 10^9$ bytes per second.\n- Test case 3 (slab geometry): $N_x = 256$, $N_y = 256$, $N_z = 1$, $B = 800 \\times 10^9$ bytes per second.\n- Test case 4 (tall core): $N_x = 96$, $N_y = 96$, $N_z = 192$, $B = 200 \\times 10^9$ bytes per second.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[[bytes_AMG_case1,bytes_MF_case1,speedup_case1,time_AMG_case1,time_MF_case1],...]\").",
            "solution": "The problem is assessed to be valid as it is scientifically grounded in established principles of numerical analysis and reactor physics, is well-posed, objective, and internally consistent.\n\nHerein, a step-by-step derivation and solution are provided.\n\n**Part 1: Derivation of the Number of Nonzeros (nnz)**\n\nThe total number of non-zero elements, denoted as $nnz$, in the sparse matrix corresponds to the total number of connections in the discretized grid, including self-connections (diagonal entries). The matrix arises from a seven-point finite difference stencil on a three-dimensional uniform grid of size $N_x \\times N_y \\times N_z$.\n\nThe total number of cells, or degrees of freedom, is $N = N_x N_y N_z$. Each cell $i$ has a non-zero diagonal entry $A_{ii}$ in the matrix, which accounts for the cell's own flux value. This contributes a total of $N$ non-zero diagonal entries.\n\nThe off-diagonal non-zero entries, $A_{ij}$ for $i \\neq j$, exist if and only if cells $i$ and $j$ are immediate neighbors. For an isotropic diffusion operator discretized with a standard second-order scheme, the matrix is symmetric, meaning a connection from cell $i$ to $j$ implies a connection from $j$ to $i$. Therefore, we can count the number of adjacent cell pairs and multiply by $2$ to find the total number of off-diagonal non-zeros.\n\nWe count the number of internal faces (shared boundaries between adjacent cells) along each coordinate axis:\n-   Number of internal faces oriented along the x-axis: In each of the $N_y N_z$ \"rows\" of cells extending in the x-direction, there are $N_x-1$ internal faces. This gives a total of $(N_x - 1) N_y N_z$ faces.\n-   Number of internal faces oriented along the y-axis: Similarly, there are $N_x (N_y - 1) N_z$ faces.\n-   Number of internal faces oriented along the z-axis: There are $N_x N_y (N_z - 1)$ faces.\n\nThe total number of adjacent cell pairs is the sum of these counts:\n$$\n\\text{Total Pairs} = (N_x - 1)N_y N_z + N_x(N_y - 1)N_z + N_x N_y(N_z - 1)\n$$\nExpanding and using $N = N_x N_y N_z$:\n$$\n\\text{Total Pairs} = (N - N_y N_z) + (N - N_x N_z) + (N - N_x N_y)\n$$\n$$\n\\text{Total Pairs} = 3N - (N_x N_y + N_x N_z + N_y N_z)\n$$\nEach pair contributes two off-diagonal entries to the matrix. Thus, the total number of off-diagonal non-zeros is $2 \\times (\\text{Total Pairs})$.\n$$\n\\text{Off-diagonals} = 2 \\left( 3N - (N_x N_y + N_x N_z + N_y N_z) \\right) = 6N - 2(N_x N_y + N_x N_z + N_y N_z)\n$$\nThe total number of non-zeros, $nnz$, is the sum of the diagonal entries and the off-diagonal entries:\n$$\nnnz = N + \\text{Off-diagonals} = N + 6N - 2(N_x N_y + N_x N_z + N_y N_z)\n$$\n$$\nnnz = 7N - 2(N_x N_y + N_x N_z + N_y N_z)\n$$\nSubstituting $N = N_x N_y N_z$, the final expression is:\n$$\nnnz = 7 N_x N_y N_z - 2(N_x N_y + N_x N_z + N_y N_z)\n$$\n\n**Part 2: Symbolic Formulas for Memory Traffic**\n\nWe are given that floating-point values are stored in $b_v = 8$ bytes and indices in $b_i = 8$ bytes. The total number of unknowns is $N = N_x N_y N_z$.\n\n**Algebraic Multigrid (AMG) Memory Traffic ($M_{AMG}$)**\n\nThe memory traffic for a single sparse matrix-vector multiplication ($y=Ax$) using the Compressed Sparse Row (CSR) format is the sum of bytes read and written.\n1.  Read row pointer array: length $N+1$, $b_i$ bytes per element. Total: $(N+1) b_i$.\n2.  Read column indices array: length $nnz$, $b_i$ bytes per element. Total: $nnz \\cdot b_i$.\n3.  Read values array: length $nnz$, $b_v$ bytes per element. Total: $nnz \\cdot b_v$.\n4.  Read input vector $x$: length $N$, $b_v$ bytes per element. Total: $N \\cdot b_v$.\n5.  Write output vector $y$: length $N$, $b_v$ bytes per element. Total: $N \\cdot b_v$.\n\nThe total memory traffic, $M_{AMG}$, is the sum of these components:\n$$\nM_{AMG} = (N+1) b_i + nnz \\cdot b_i + nnz \\cdot b_v + N \\cdot b_v + N \\cdot b_v\n$$\n$$\nM_{AMG} = (N+1) b_i + nnz (b_i + b_v) + 2N b_v\n$$\n\n**Matrix-Free Memory Traffic ($M_{MF}$)**\n\nFor the matrix-free method, the operator is applied without reading a stored matrix.\n1.  Read coefficient field $D$: length $N$, $b_v$ bytes per element. Total: $N \\cdot b_v$.\n2.  Read coefficient field $\\Sigma_a$: length $N$, $b_v$ bytes per element. Total: $N \\cdot b_v$.\n3.  Read input vector $x$: length $N$, $b_v$ bytes per element. Total: $N \\cdot b_v$.\n4.  Write output vector $y$: length $N$, $b_v$ bytes per element. Total: $N \\cdot b_v$.\n\nThe total memory traffic, $M_{MF}$, is the sum of these components:\n$$\nM_{MF} = N b_v + N b_v + N b_v + N b_v = 4N b_v\n$$\nSubstituting $N = N_x N_y N_z$:\n$$\nM_{MF} = 4 (N_x N_y N_z) b_v\n$$\n\n**Part 3: Predicted Time for Operator Application**\n\nUsing a simple bandwidth-bound model, the time $T$ to complete an operation is the total memory traffic divided by the memory bandwidth $B$.\n\n**Predicted AMG Time ($T_{AMG}$)**\n$$\nT_{AMG} = \\frac{M_{AMG}}{B} = \\frac{(N+1) b_i + nnz (b_i + b_v) + 2N b_v}{B}\n$$\n\n**Predicted Matrix-Free Time ($T_{MF}$)**\n$$\nT_{MF} = \\frac{M_{MF}}{B} = \\frac{4N b_v}{B}\n$$\n\n**Part 4: Implementation and Calculations**\n\nThe provided formulas are implemented to evaluate the required metrics for the specified test cases. The values $b_v = 8$ and $b_i = 8$ are used. The resulting program computes byte counts, the ratio $M_{AMG}/M_{MF}$, and predicted times $T_{AMG}$ and $T_{MF}$. Floating-point results are formatted in standard decimal notation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Nx, Ny, Nz, Bandwidth in bytes/s)\n        (128, 128, 64, 160e9),\n        (4, 4, 4, 50e9),\n        (256, 256, 1, 800e9),\n        (96, 96, 192, 200e9),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = calculate_metrics(*case)\n        all_results.append(result)\n\n    # Helper to format a float into standard decimal notation, avoiding 'e' notation,\n    # and removing unnecessary trailing zeros.\n    def format_float(f):\n        # Format with sufficient precision to avoid scientific notation for small numbers.\n        s = f'{f:.16f}'\n        # Strip trailing zeros, and then the decimal point if it's the last character.\n        return s.rstrip('0').rstrip('.') if '.' in s else s\n\n    # Format the final output string according to the problem specification.\n    case_strings = []\n    for res_list in all_results:\n        # res_list contains [int, int, float, float, float]\n        formatted_list = [\n            str(res_list[0]),                             # bytes_amg (int)\n            str(res_list[1]),                             # bytes_mf (int)\n            format_float(res_list[2]),                    # ratio (float)\n            format_float(res_list[3]),                    # time_amg (float)\n            format_float(res_list[4]),                    # time_mf (float)\n        ]\n        case_strings.append(f\"[{','.join(formatted_list)}]\")\n\n    final_output = f\"[{','.join(case_strings)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\ndef calculate_metrics(Nx, Ny, Nz, B):\n    \"\"\"\n    Calculates performance metrics for a single test case.\n\n    Args:\n        Nx (int): Number of cells in the x-direction.\n        Ny (int): Number of cells in the y-direction.\n        Nz (int): Number of cells in the z-direction.\n        B (float): Memory bandwidth in bytes per second.\n\n    Returns:\n        list: A list containing [bytes_amg, bytes_mf, ratio, time_amg, time_mf].\n    \"\"\"\n    # Memory model constants\n    b_v = 8  # bytes per double-precision floating-point value\n    b_i = 8  # bytes per 64-bit integer index\n\n    # Total number of cells (unknowns)\n    N = Nx * Ny * Nz\n\n    # Part 1: Calculate the total number of non-zeros (nnz)\n    # nnz = 7*N - 2*(Nx*Ny + Nx*Nz + Ny*Nz)\n    nnz = 7 * N - 2 * (Nx * Ny + Nx * Nz + Ny * Nz)\n\n    # Part 2: Calculate total memory traffic in bytes for both methods\n    # M_AMG = (N+1)*b_i + nnz*(b_i + b_v) + 2*N*b_v\n    bytes_amg = (N + 1) * b_i + nnz * (b_i + b_v) + 2 * N * b_v\n\n    # M_MF = 4*N*b_v\n    bytes_mf = 4 * N * b_v\n\n    # Calculate the ratio of AMG to matrix-free bytes\n    # Ensure floating point division\n    ratio = float(bytes_amg) / float(bytes_mf)\n\n    # Part 3: Calculate predicted time in seconds\n    # T = M / B\n    time_amg = float(bytes_amg) / float(B)\n    time_mf = float(bytes_mf) / float(B)\n\n    return [bytes_amg, bytes_mf, ratio, time_amg, time_mf]\n\n\n# Run the solution\nsolve()\n```"
        },
        {
            "introduction": "A well-designed multigrid solver must be properly tuned to deliver optimal performance. The classic V-cycle involves a careful balance between the work done in smoothing high-frequency errors on the fine grid and the work done solving for low-frequency errors on the coarse grid. This exercise () presents a practical performance model that allows you to optimize this balance. By exploring how the number of smoothing steps and coarse-grid iterations affects both the cost per cycle and the overall convergence rate, you will learn how to tune a multigrid solver to minimize the total time-to-solution for a given problem.",
            "id": "4236968",
            "problem": "Consider the steady-state multigroup neutron diffusion equation discretized on a three-dimensional reactor core mesh. To accelerate a stationary source iteration, a two-grid Multigrid (MG) cycle is used, consisting of fine-grid smoothing, restriction to a coarse grid, an inexact coarse-grid solve, and prolongation back to the fine grid, followed by fine-grid post-smoothing. The goal is to choose the cycle parameters to minimize total time-to-solution for a prescribed residual reduction.\n\nAdopt the following work unit model for the two-grid MG cycle. Each fine-grid smoothing sweep (Jacobi-like) costs $c_s$ work units, a single fine-to-coarse transfer (restriction) costs $c_r$ work units, a single coarse-to-fine transfer (prolongation) costs $c_p$ work units, and each coarse-grid inner iteration costs $c_c$ work units. Let the number of pre-smoothing sweeps be $m$ and the number of post-smoothing sweeps be $m$ (i.e., $2m$ total fine-grid smooths), and let the number of coarse-grid inner iterations be $\\gamma$. The per-cycle cost is modeled as\n$$\nW(m,\\gamma) \\;=\\; 2 m\\, c_s \\;+\\; c_r \\;+\\; c_p \\;+\\; \\gamma \\, c_c.\n$$\n\nAssume the error after one cycle is decomposable into a high-frequency component damped primarily by smoothing and a low-frequency component damped primarily by the coarse-grid correction. If the initial error energy splits as a fraction $\\alpha$ in high-frequency modes and $1-\\alpha$ in low-frequency modes, and if a single fine-grid smoothing sweep reduces high-frequency modes by a factor $\\sigma$ while a single coarse-grid inner iteration reduces low-frequency modes by a factor $\\tau$, then the per-cycle error contraction factor is modeled by\n$$\nq(m,\\gamma) \\;=\\; \\sqrt{ \\alpha \\, \\sigma^{2m} \\;+\\; (1-\\alpha) \\, \\tau^{2\\gamma} }.\n$$\n\nThe number of cycles required to achieve a residual reduction factor $r_{\\mathrm{target}}$ is the smallest integer\n$$\nk(m,\\gamma) \\;=\\; \\left\\lceil \\frac{\\ln\\!\\big(r_{\\mathrm{target}}\\big)}{\\ln\\!\\big(q(m,\\gamma)\\big)} \\right\\rceil,\n$$\nand the total time-to-solution is then\n$$\nT(m,\\gamma) \\;=\\; W(m,\\gamma)\\, k(m,\\gamma).\n$$\n\nFor a representative pressurized water reactor (PWR) core problem, measured constants are: $c_s = 4.0$ ms, $c_r = 1.2$ ms, $c_p = 1.5$ ms, $c_c = 7.0$ ms, $\\alpha = 0.6$, $\\sigma = 0.5$, $\\tau = 0.3$, and $r_{\\mathrm{target}} = 10^{-8}$. Restrict attention to $m \\in \\{\\,1,\\,2,\\,3\\,\\}$ and $\\gamma \\in \\{\\,1,\\,2,\\,3\\,\\}$.\n\nUsing the work unit model and contraction model above, determine the minimal possible total time-to-solution $T_{\\min}$ over the specified discrete choices of $m$ and $\\gamma$. Express your final answer in seconds and round your answer to four significant figures.",
            "solution": "The problem will first be validated against the specified criteria.\n\n### Step 1: Extract Givens\nThe problem provides the following data, definitions, and relationships:\n-   **Model for per-cycle work cost:**\n    $$\n    W(m,\\gamma) \\;=\\; 2 m\\, c_s \\;+\\; c_r \\;+\\; c_p \\;+\\; \\gamma \\, c_c\n    $$\n-   **Model for per-cycle error contraction factor:**\n    $$\n    q(m,\\gamma) \\;=\\; \\sqrt{ \\alpha \\, \\sigma^{2m} \\;+\\; (1-\\alpha) \\, \\tau^{2\\gamma} }\n    $$\n-   **Model for the number of cycles:**\n    $$\n    k(m,\\gamma) \\;=\\; \\left\\lceil \\frac{\\ln\\!\\big(r_{\\mathrm{target}}\\big)}{\\ln\\!\\big(q(m,\\gamma)\\big)} \\right\\rceil\n    $$\n-   **Model for total time-to-solution:**\n    $$\n    T(m,\\gamma) \\;=\\; W(m,\\gamma)\\, k(m,\\gamma)\n    $$\n-   **Variables to be optimized:**\n    -   Number of pre/post-smoothing sweeps: $m$\n    -   Number of coarse-grid inner iterations: $\\gamma$\n-   **Domain for variables:**\n    -   $m \\in \\{\\,1,\\,2,\\,3\\,\\}$\n    -   $\\gamma \\in \\{\\,1,\\,2,\\,3\\,\\}$\n-   **Numerical Constants:**\n    -   Fine-grid smoothing cost: $c_s = 4.0$ ms\n    -   Restriction cost: $c_r = 1.2$ ms\n    -   Prolongation cost: $c_p = 1.5$ ms\n    -   Coarse-grid iteration cost: $c_c = 7.0$ ms\n    -   High-frequency error fraction: $\\alpha = 0.6$\n    -   Smoothing factor: $\\sigma = 0.5$\n    -   Coarse-grid solve factor: $\\tau = 0.3$\n    -   Target residual reduction: $r_{\\mathrm{target}} = 10^{-8}$\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is critically examined:\n-   **Scientifically Grounded:** The problem describes a simplified performance model for a multigrid iterative solver. Such models, which balance computational work per iteration against the rate of convergence, are a standard and valid tool in numerical analysis for optimizing algorithm parameters. The underlying concepts (smoothing, coarse-grid correction, error modes) are fundamental to multigrid theory. The problem is scientifically sound.\n-   **Well-Posed:** The problem is a well-posed discrete optimization task. The objective function $T(m, \\gamma)$ is clearly defined, and the domain of the independent variables $(m, \\gamma)$ is a finite, discrete set. This guarantees that a minimum value exists and is attainable within the specified set.\n-   **Objective:** The problem is stated using precise mathematical definitions and objective numerical data. There are no subjective or ambiguous terms.\n-   **Completeness and Consistency:** All necessary parameters and formulas are provided, and there are no internal contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. A rigorous solution will be developed.\n\nThe objective is to find the minimal possible total time-to-solution, $T_{\\min}$, by evaluating the function $T(m,\\gamma)$ for all pairs $(m, \\gamma)$ in the discrete domain $m \\in \\{1, 2, 3\\}$ and $\\gamma \\in \\{1, 2, 3\\}$.\n\nThe given parameters are:\n$c_s = 4.0$, $c_r = 1.2$, $c_p = 1.5$, $c_c = 7.0$ (all in ms).\n$\\alpha = 0.6$, $\\sigma = 0.5$, $\\tau = 0.3$, and $r_{\\mathrm{target}} = 10^{-8}$.\n\nFirst, we compute the constant terms. The combined cost of restriction and prolongation per cycle is $c_r + c_p = 1.2 + 1.5 = 2.7$ ms. The numerator in the expression for $k(m,\\gamma)$ is $\\ln(r_{\\mathrm{target}}) = \\ln(10^{-8}) = -8 \\ln(10) \\approx -18.42068$.\n\nWe now systematically evaluate $T(m,\\gamma)$ for each of the $3 \\times 3 = 9$ pairs of $(m, \\gamma)$. All time calculations are initially in milliseconds (ms).\n\n**Case 1: $m=1$**\n-   For $(m, \\gamma) = (1, 1)$:\n    $W(1,1) = 2(1)(4.0) + 2.7 + 1(7.0) = 8.0 + 2.7 + 7.0 = 17.7$ ms.\n    $q(1,1) = \\sqrt{0.6(0.5)^{2(1)} + (1-0.6)(0.3)^{2(1)}} = \\sqrt{0.6(0.25) + 0.4(0.09)} = \\sqrt{0.186} \\approx 0.43128$.\n    $k(1,1) = \\left\\lceil \\frac{-18.42068}{\\ln(0.43128)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-0.84095} \\right\\rceil = \\lceil 21.905 \\rceil = 22$.\n    $T(1,1) = 17.7 \\times 22 = 389.4$ ms.\n\n-   For $(m, \\gamma) = (1, 2)$:\n    $W(1,2) = 2(1)(4.0) + 2.7 + 2(7.0) = 8.0 + 2.7 + 14.0 = 24.7$ ms.\n    $q(1,2) = \\sqrt{0.6(0.5)^2 + 0.4(0.3)^4} = \\sqrt{0.15 + 0.4(0.0081)} = \\sqrt{0.15324} \\approx 0.39146$.\n    $k(1,2) = \\left\\lceil \\frac{-18.42068}{\\ln(0.39146)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-0.93796} \\right\\rceil = \\lceil 19.639 \\rceil = 20$.\n    $T(1,2) = 24.7 \\times 20 = 494.0$ ms.\n\n-   For $(m, \\gamma) = (1, 3)$:\n    $W(1,3) = 2(1)(4.0) + 2.7 + 3(7.0) = 8.0 + 2.7 + 21.0 = 31.7$ ms.\n    $q(1,3) = \\sqrt{0.6(0.5)^2 + 0.4(0.3)^6} = \\sqrt{0.15 + 0.4(0.000729)} = \\sqrt{0.1502916} \\approx 0.38767$.\n    $k(1,3) = \\left\\lceil \\frac{-18.42068}{\\ln(0.38767)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-0.94759} \\right\\rceil = \\lceil 19.439 \\rceil = 20$.\n    $T(1,3) = 31.7 \\times 20 = 634.0$ ms.\n\n**Case 2: $m=2$**\n-   For $(m, \\gamma) = (2, 1)$:\n    $W(2,1) = 2(2)(4.0) + 2.7 + 1(7.0) = 16.0 + 2.7 + 7.0 = 25.7$ ms.\n    $q(2,1) = \\sqrt{0.6(0.5)^{2(2)} + 0.4(0.3)^{2(1)}} = \\sqrt{0.6(0.0625) + 0.4(0.09)} = \\sqrt{0.0735} \\approx 0.27111$.\n    $k(2,1) = \\left\\lceil \\frac{-18.42068}{\\ln(0.27111)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-1.30521} \\right\\rceil = \\lceil 14.113 \\rceil = 15$.\n    $T(2,1) = 25.7 \\times 15 = 385.5$ ms.\n\n-   For $(m, \\gamma) = (2, 2)$:\n    $W(2,2) = 2(2)(4.0) + 2.7 + 2(7.0) = 16.0 + 2.7 + 14.0 = 32.7$ ms.\n    $q(2,2) = \\sqrt{0.6(0.5)^4 + 0.4(0.3)^4} = \\sqrt{0.0375 + 0.00324} = \\sqrt{0.04074} \\approx 0.20184$.\n    $k(2,2) = \\left\\lceil \\frac{-18.42068}{\\ln(0.20184)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-1.60023} \\right\\rceil = \\lceil 11.511 \\rceil = 12$.\n    $T(2,2) = 32.7 \\times 12 = 392.4$ ms.\n\n-   For $(m, \\gamma) = (2, 3)$:\n    $W(2,3) = 2(2)(4.0) + 2.7 + 3(7.0) = 16.0 + 2.7 + 21.0 = 39.7$ ms.\n    $q(2,3) = \\sqrt{0.6(0.5)^4 + 0.4(0.3)^6} = \\sqrt{0.0375 + 0.0002916} = \\sqrt{0.0377916} \\approx 0.19440$.\n    $k(2,3) = \\left\\lceil \\frac-{-1.63783} \\right\\rceil = \\lceil 11.247 \\rceil = 12$.\n    $T(2,3) = 39.7 \\times 12 = 476.4$ ms.\n\n**Case 3: $m=3$**\n-   For $(m, \\gamma) = (3, 1)$:\n    $W(3,1) = 2(3)(4.0) + 2.7 + 1(7.0) = 24.0 + 2.7 + 7.0 = 33.7$ ms.\n    $q(3,1) = \\sqrt{0.6(0.5)^{2(3)} + 0.4(0.3)^{2(1)}} = \\sqrt{0.6(0.015625) + 0.4(0.09)} = \\sqrt{0.045375} \\approx 0.21299$.\n    $k(3,1) = \\left\\lceil \\frac{-18.42068}{\\ln(0.21299)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-1.54649} \\right\\rceil = \\lceil 11.911 \\rceil = 12$.\n    $T(3,1) = 33.7 \\times 12 = 404.4$ ms.\n\n-   For $(m, \\gamma) = (3, 2)$:\n    $W(3,2) = 2(3)(4.0) + 2.7 + 2(7.0) = 24.0 + 2.7 + 14.0 = 40.7$ ms.\n    $q(3,2) = \\sqrt{0.6(0.5)^6 + 0.4(0.3)^4} = \\sqrt{0.009375 + 0.00324} = \\sqrt{0.012615} \\approx 0.11232$.\n    $k(3,2) = \\left\\lceil \\frac{-18.42068}{\\ln(0.11232)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-2.18651} \\right\\rceil = \\lceil 8.425 \\rceil = 9$.\n    $T(3,2) = 40.7 \\times 9 = 366.3$ ms.\n\n-   For $(m, \\gamma) = (3, 3)$:\n    $W(3,3) = 2(3)(4.0) + 2.7 + 3(7.0) = 24.0 + 2.7 + 21.0 = 47.7$ ms.\n    $q(3,3) = \\sqrt{0.6(0.5)^6 + 0.4(0.3)^6} = \\sqrt{0.009375 + 0.0002916} = \\sqrt{0.0096666} \\approx 0.09832$.\n    $k(3,3) = \\left\\lceil \\frac{-18.42068}{\\ln(0.09832)} \\right\\rceil = \\left\\lceil \\frac{-18.42068}{-2.32000} \\right\\rceil = \\lceil 7.940 \\rceil = 8$.\n    $T(3,3) = 47.7 \\times 8 = 381.6$ ms.\n\n**Conclusion**\nBy comparing all nine computed values of $T(m,\\gamma)$:\n$T(1,1)=389.4$ ms, $T(1,2)=494.0$ ms, $T(1,3)=634.0$ ms\n$T(2,1)=385.5$ ms, $T(2,2)=392.4$ ms, $T(2,3)=476.4$ ms\n$T(3,1)=404.4$ ms, $T(3,2)=366.3$ ms, $T(3,3)=381.6$ ms\n\nThe minimum value is $T_{\\min} = 366.3$ ms, corresponding to the parameters $(m, \\gamma) = (3, 2)$. The problem asks for this result in seconds, rounded to four significant figures.\n$$\nT_{\\min} = 366.3 \\text{ ms} = 0.3663 \\text{ s}\n$$\nThis value is already expressed to four significant figures.",
            "answer": "$$\n\\boxed{0.3663}\n$$"
        }
    ]
}