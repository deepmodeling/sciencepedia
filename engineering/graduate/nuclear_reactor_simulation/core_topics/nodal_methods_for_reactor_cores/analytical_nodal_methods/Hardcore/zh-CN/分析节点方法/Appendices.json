{
    "hands_on_practices": [
        {
            "introduction": "任何节点方法的核心都是在中子学粗网格单元（即“节点”）上的中子守恒原理。本练习从稳态中子扩散方程出发，推导了将节点净泄漏与其体积积分源和吸收率联系起来的节点平衡关系。通过从体积率（源减吸收）和表面分流（出射减入射）两个角度独立计算净泄漏并验证其相等性，您将加深对节点方法物理基础的理解。",
            "id": "4214335",
            "problem": "考虑在单群、稳态中子扩散模型中，用于解析节点法 (ANM) 的一个一维矩形节点。该节点的宽度为 $h = 20$ cm，横截面积恒为 $A = 100$ cm$^{2}$，因此其体积为 $V = A h$。在节点内部，节点内体积中子源密度近似为空间均匀的，其节点平均值为 $\\bar{S} = 1.35 \\times 10^{6}$ n cm$^{-3}$ s$^{-1}$。宏观吸收截面是空间均匀的，为 $\\Sigma_{a} = 0.08$ cm$^{-1}$，节点平均标通量为 $\\bar{\\phi} = 1.50 \\times 10^{7}$ n cm$^{-2}$ s$^{-1}$。节点的左右两个面具有面积分分流，其定义为穿过这些面的中子总率，并相对于节点分为流出和流入两个分量。在左侧面，流出和流入的面积分分流分别为 $I_{L}^{\\text{out}} = 8.20 \\times 10^{8}$ s$^{-1}$ 和 $I_{L}^{\\text{in}} = 7.10 \\times 10^{8}$ s$^{-1}$。在右侧面，它们分别为 $I_{R}^{\\text{out}} = 9.00 \\times 10^{8}$ s$^{-1}$ 和 $I_{R}^{\\text{in}} = 7.10 \\times 10^{8}$ s$^{-1}$。\n\n仅从稳态单群中子扩散方程和中子守恒出发，推导将节点净泄漏与其体积分源和吸收联系起来的节点平衡关系。然后，使用所提供的数据：\n- 应用从控制方程推导出的节点平衡关系，计算节点的净泄漏，以及\n- 独立地将净泄漏计算为所有面上流出与流入的面积分分流之差的和，\n\n并验证这两个结果相等，从而证明节点内的全局守恒。\n\n报告节点的净泄漏值，单位为中子/秒。将您的答案四舍五入到三位有效数字，并以中子/秒为单位表示最终值。",
            "solution": "该问题经核实具有科学依据、问题明确且客观。它基于中子扩散理论的基本原理和反应堆物理模拟中使用的成熟的解析节点法 (ANM)。所提供的数据充分且一致，足以得出一个唯一的解。因此，我们可以继续进行推导和计算。\n\n这个问题的基础是稳态单群中子扩散方程，它表示空间中任意点 $\\vec{r}$ 处的中子局部平衡。该方程由下式给出：\n$$\n-\\nabla \\cdot \\vec{J}(\\vec{r}) + S(\\vec{r}) - \\Sigma_{a}(\\vec{r})\\phi(\\vec{r}) = 0\n$$\n其中 $\\vec{J}(\\vec{r})$ 是中子流密度矢量，$S(\\vec{r})$ 是体积中子源密度，$\\Sigma_{a}(\\vec{r})$ 是宏观吸收截面，$\\phi(\\vec{r})$ 是标量中子通量。\n\n为了推导有限体积元（即节点）的节点平衡方程，我们将此微分方程在节点体积 $V$ 上积分：\n$$\n\\int_V \\left( -\\nabla \\cdot \\vec{J}(\\vec{r}) + S(\\vec{r}) - \\Sigma_{a}(\\vec{r})\\phi(\\vec{r}) \\right) dV = 0\n$$\n根据积分的线性性质，我们可以分离各项：\n$$\n-\\int_V \\nabla \\cdot \\vec{J}(\\vec{r}) \\, dV + \\int_V S(\\vec{r}) \\, dV - \\int_V \\Sigma_{a}(\\vec{r})\\phi(\\vec{r}) \\, dV = 0\n$$\n对第一项应用散度定理，我们将流密度散度的体积分转换为流密度在节点边界 $\\partial V$ 上的面积分：\n$$\n\\int_V \\nabla \\cdot \\vec{J}(\\vec{r}) \\, dV = \\oint_{\\partial V} \\vec{J}(\\vec{r}) \\cdot d\\vec{A}\n$$\n项 $\\oint_{\\partial V} \\vec{J}(\\vec{r}) \\cdot d\\vec{A}$ 表示从中子节点边界表面流出的中子总净率。根据定义，这就是节点的净泄漏率，我们记为 $L_{\\text{net}}$。\n\n积分平衡方程中的另外两项分别表示节点内的总源率和总吸收率：\n- 总源率：$S_{\\text{node}} = \\int_V S(\\vec{r}) \\, dV$\n- 总吸收率：$A_{\\text{node}} = \\int_V \\Sigma_{a}(\\vec{r})\\phi(\\vec{r}) \\, dV$\n\n将这些定义代回积分方程，得到节点平衡方程：\n$$\nL_{\\text{net}} = S_{\\text{node}} - A_{\\text{node}}\n$$\n该方程陈述了一个基本的守恒原理：对于一个处于稳态的系统，粒子从一个体积中泄漏的净率必须等于该体积内的产生率减去损失率。\n\n问题要求我们用两种方法计算 $L_{\\text{net}}$ 并验证它们相等。\n\n**方法1：根据体积分源率和吸收率计算。**\n问题提供了节点平均值，并假设宏观吸收截面 $\\Sigma_{a}$ 在空间上是均匀的。\n节点体积为 $V = A h$。\n已知：$A = 100 \\text{ cm}^2$ 和 $h = 20 \\text{ cm}$。\n$$\nV = (100 \\text{ cm}^2) \\times (20 \\text{ cm}) = 2000 \\text{ cm}^3\n$$\n节点内的总源率 $S_{\\text{node}}$ 是节点平均源密度 $\\bar{S}$ 与节点体积 $V$ 的乘积。\n已知：$\\bar{S} = 1.35 \\times 10^{6} \\text{ n cm}^{-3} \\text{ s}^{-1}$。\n$$\nS_{\\text{node}} = \\bar{S} V = (1.35 \\times 10^{6}) \\times (2000) = 2.7 \\times 10^{9} \\text{ n s}^{-1}\n$$\n节点内的总吸收率 $A_{\\text{node}}$ 是常数吸收截面 $\\Sigma_{a}$、节点平均标通量 $\\bar{\\phi}$ 和节点体积 $V$ 的乘积。\n已知：$\\Sigma_{a} = 0.08 \\text{ cm}^{-1}$ 和 $\\bar{\\phi} = 1.50 \\times 10^{7} \\text{ n cm}^{-2} \\text{ s}^{-1}$。\n$$\nA_{\\text{node}} = \\Sigma_{a} \\bar{\\phi} V = (0.08) \\times (1.50 \\times 10^{7}) \\times (2000) = 2.4 \\times 10^{9} \\text{ n s}^{-1}\n$$\n使用节点平衡方程，净泄漏为：\n$$\nL_{\\text{net}} = S_{\\text{node}} - A_{\\text{node}} = 2.7 \\times 10^{9} \\text{ n s}^{-1} - 2.4 \\times 10^{9} \\text{ n s}^{-1} = 0.3 \\times 10^{9} \\text{ n s}^{-1} = 3.0 \\times 10^{8} \\text{ n s}^{-1}\n$$\n\n**方法2：根据面积分分流计算。**\n净泄漏 $L_{\\text{net}}$ 也是离开节点的中子总率减去进入节点的中子总率。这些率以面积分分流的形式给出。\n总流出量是所有面（左侧和右侧）上流出分流的总和：\n$$\nI_{\\text{total}}^{\\text{out}} = I_{L}^{\\text{out}} + I_{R}^{\\text{out}}\n$$\n已知：$I_{L}^{\\text{out}} = 8.20 \\times 10^{8} \\text{ s}^{-1}$ 和 $I_{R}^{\\text{out}} = 9.00 \\times 10^{8} \\text{ s}^{-1}$。\n$$\nI_{\\text{total}}^{\\text{out}} = (8.20 \\times 10^{8} + 9.00 \\times 10^{8}) \\text{ s}^{-1} = 17.20 \\times 10^{8} \\text{ s}^{-1} = 1.72 \\times 10^{9} \\text{ s}^{-1}\n$$\n总流入量是所有面上流入分流的总和：\n$$\nI_{\\text{total}}^{\\text{in}} = I_{L}^{\\text{in}} + I_{R}^{\\text{in}}\n$$\n已知：$I_{L}^{\\text{in}} = 7.10 \\times 10^{8} \\text{ s}^{-1}$ 和 $I_{R}^{\\text{in}} = 7.10 \\times 10^{8} \\text{ s}^{-1}$。\n$$\nI_{\\text{total}}^{\\text{in}} = (7.10 \\times 10^{8} + 7.10 \\times 10^{8}) \\text{ s}^{-1} = 14.20 \\times 10^{8} \\text{ s}^{-1} = 1.42 \\times 10^{9} \\text{ s}^{-1}\n$$\n净泄漏是总流出量减去总流入量：\n$$\nL_{\\text{net}} = I_{\\text{total}}^{\\text{out}} - I_{\\text{total}}^{\\text{in}} = 1.72 \\times 10^{9} \\text{ s}^{-1} - 1.42 \\times 10^{9} \\text{ s}^{-1} = 0.30 \\times 10^{9} \\text{ s}^{-1} = 3.0 \\times 10^{8} \\text{ s}^{-1}\n$$\n\n**验证：**\n从体积平衡（方法1）计算出的净泄漏为 $3.0 \\times 10^{8} \\text{ n s}^{-1}$。\n从表面分流（方法2）计算出的净泄漏为 $3.0 \\times 10^{8} \\text{ s}^{-1}$。\n两个结果完全相同，这证实了所提供的数据与稳态下中子守恒的物理定律是一致的。\n\n问题要求报告净泄漏的单一值，并四舍五入到三位有效数字。\n计算值为 $3.0 \\times 10^{8}$。保留三位有效数字，即为 $3.00 \\times 10^{8}$。",
            "answer": "$$\\boxed{3.00 \\times 10^8}$$"
        },
        {
            "introduction": "解析节点法的一个关键特征是，它利用一个简化的一维扩散方程的解析解来近似每个节点内的中子通量分布。本练习探讨了如何将其他两个维度上的泄漏（横向泄漏）作为一个与空间相关的源项来处理，这个源项通常用勒让德多项式展开。通过求解包含和不包含非均匀横向泄漏项的一维方程，您将深入了解解析节点法如何精确地捕捉对计算精度至关重要的通量剖面非均匀性。",
            "id": "4214385",
            "problem": "考虑一个使用解析节点法（ANM）处理的核反应堆堆芯中的单个均匀化矩形节点。该节点在 $x$ 方向上从 $x=-a$ 延伸到 $x=+a$，其中 $a=\\frac{h}{2}$，节点总宽度为 $h=40\\,\\mathrm{cm}$，因此 $a=20\\,\\mathrm{cm}$。假设沿 $x$ 方向的一维单群稳态中子扩散模型，具有空间上恒定的各向同性产生源 $S_0$ 和一个近似的横向泄漏源 $T(x)$，该泄漏源捕捉了与 $y$ 和 $z$ 方向的耦合。控制方程为\n$$\n-D\\,\\frac{d^2\\phi(x)}{dx^2}+\\Sigma_a\\,\\phi(x)=S_0+T(x)\\quad\\text{for}\\quad x\\in[-a,a],\n$$\n在节点表面具有反射（净流为零）边界条件，\n$$\n\\frac{d\\phi}{dx}\\bigg|_{x=-a}=\\frac{d\\phi}{dx}\\bigg|_{x=+a}=0.\n$$\n其中 $D$ 是扩散系数，$\\Sigma_a$ 是宏观吸收截面，$\\phi(x)$ 是标量中子通量。\n\n使用以下物理上一致的数据：$D=1.2\\,\\mathrm{cm}$，$\\Sigma_a=0.08\\,\\mathrm{cm}^{-1}$，以及 $S_0=0.04\\,\\mathrm{n}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1}$。横向泄漏源由在标度化坐标 $\\xi=\\frac{x}{a}$（在 $[-1,1]$ 上）中的二阶 Legendre 展开表示，\n$$\nT(\\xi)=t_0\\left[s_0\\,P_0(\\xi)+s_2\\,P_2(\\xi)\\right],\n$$\n其中 $P_0(\\xi)=1$ 且 $P_2(\\xi)=\\frac{1}{2}\\left(3\\xi^2-1\\right)$。平均横向泄漏幅度为 $t_0=0.02\\,\\mathrm{n}\\,\\mathrm{cm}^{-3}\\,\\mathrm{s}^{-1}$。泄漏分配参数由 $s_0=1$ 和 $s_2=-0.6$ 给出，这产生了一个非均匀的横向泄漏形状。“无分配”假设对应于 $s_2=0$，即一个等于其节点平均值的恒定横向泄漏。\n\n从单群扩散方程和给定的边界条件出发，推导节点中心通量 $\\phi(0)$，分别针对 (i) 给定的泄漏分配 $s_2=-0.6$ 和 (ii) 无分配情况 $s_2=0$。将比较定义为无量纲比率\n$$\nR=\\frac{\\phi(0)\\big|_{s_2=-0.6}}{\\phi(0)\\big|_{s_2=0}}.\n$$\n使用所提供的数据计算 $R$。将最终比率表示为一个无量纲数，并将您的答案四舍五入到四位有效数字。",
            "solution": "本问题要求求解一个一维单群中子扩散方程，其源项包含一个由二阶勒让德多项式表示的非均匀横向泄漏项。我们的目标是推导并比较包含此非均匀项与不包含此项（即泄漏均匀分布）两种情况下，节点中心的通量值。\n\n**1. 建立控制方程**\n控制方程为：\n$$-D\\,\\frac{d^2\\phi(x)}{dx^2}+\\Sigma_a\\,\\phi(x)=S(x)$$\n总源项 $S(x)$ 是固定源 $S_0$ 与横向泄漏 $T(x)$ 之和。将 $T(x)$ 用 $x$ 表示：\n$$T(x) = t_0\\left[s_0\\,P_0\\left(\\frac{x}{a}\\right)+s_2\\,P_2\\left(\\frac{x}{a}\\right)\\right] = t_0\\left[s_0 + s_2\\,\\frac{1}{2}\\left(3\\left(\\frac{x}{a}\\right)^2-1\\right)\\right]$$\n因此，总源项可以写成一个关于 $x$ 的二次多项式：\n$$S(x) = \\left(S_0 + t_0s_0 - \\frac{t_0s_2}{2}\\right) + \\left(\\frac{3t_0s_2}{2a^2}\\right)x^2 = S_{\\text{const}} + S_{\\text{quad}}x^2$$\n\n**2. 求解微分方程**\n方程可重写为：\n$$\\frac{d^2\\phi(x)}{dx^2} - B_m^2 \\phi(x) = -\\frac{S(x)}{D}, \\quad \\text{其中} \\quad B_m^2 = \\frac{\\Sigma_a}{D}$$\n通解 $\\phi(x)$ 是齐次解 $\\phi_h(x)$ 与特解 $\\phi_p(x)$ 之和。由于问题具有对称性（对称域、对称源项、反射边界条件），齐次解为偶函数形式：\n$$\\phi_h(x) = C_1 \\cosh(B_m x)$$\n对于二次源项，我们使用待定系数法寻找一个二次多项式形式的特解 $\\phi_p(x) = A x^2 + C$。代入方程可求得：\n$$\\phi_p(x) = \\frac{S_{\\text{quad}}}{\\Sigma_a} x^2 + \\left( \\frac{S_{\\text{const}}}{\\Sigma_a} + \\frac{2 D S_{\\text{quad}}}{\\Sigma_a^2} \\right)$$\n因此，通解为：\n$$\\phi(x) = C_1 \\cosh(B_m x) + \\frac{S_{\\text{quad}}}{\\Sigma_a} x^2 + \\frac{S_{\\text{const}}}{\\Sigma_a} + \\frac{2 D S_{\\text{quad}}}{\\Sigma_a^2}$$\n\n**3. 应用边界条件并计算中心通量**\n应用反射边界条件 $\\frac{d\\phi}{dx}\\big|_{x=a}=0$ 来确定常数 $C_1$：\n$$\\phi'(x) = C_1 B_m \\sinh(B_m x) + \\frac{2S_{\\text{quad}}}{\\Sigma_a}x$$\n$$C_1 B_m \\sinh(B_m a) + \\frac{2S_{\\text{quad}}a}{\\Sigma_a} = 0 \\implies C_1 = -\\frac{2 a S_{\\text{quad}}}{\\Sigma_a B_m \\sinh(B_m a)}$$\n在节点中心 $x=0$ 处，$\\cosh(0)=1$，$x^2=0$，因此通量为：\n$$\\phi(0) = C_1 + \\frac{S_{\\text{const}}}{\\Sigma_a} + \\frac{2 D S_{\\text{quad}}}{\\Sigma_a^2}$$\n代入 $C_1$、 $S_{\\text{const}}$ 和 $S_{\\text{quad}}$ 的表达式，并整理可得：\n$$\\phi(0) = \\frac{S_0 + t_0 s_0}{\\Sigma_a} + \\frac{t_0 s_2}{\\Sigma_a} \\left( -\\frac{1}{2} + \\frac{3}{a^2 B_m^2} \\left( 1 - \\frac{a B_m}{\\sinh(a B_m)} \\right) \\right)$$\n\n**4. 计算比率 R**\n(ii) **无分配情况 ($s_2=0$):** 当 $s_2=0$ 时，$S_{\\text{quad}}=0$，上述表达式中第二项为零。解简化为常数通量：\n$$\\phi(0)\\big|_{s_2=0} = \\frac{S_0 + t_0 s_0}{\\Sigma_a}$$\n(i) **有分配情况 ($s_2=-0.6$):** 使用上面推导的完整表达式。\n\n比率 $R$ 定义为两种情况下中心通量之比：\n$$R = \\frac{\\phi(0)\\big|_{s_2=-0.6}}{\\phi(0)\\big|_{s_2=0}} = 1 + \\frac{t_0 s_2}{S_0 + t_0 s_0} \\left( -\\frac{1}{2} + \\frac{3}{a^2 B_m^2} \\left( 1 - \\frac{a B_m}{\\sinh(a B_m)} \\right) \\right)$$\n代入数值：$a=20\\,\\mathrm{cm}$, $D=1.2\\,\\mathrm{cm}$, $\\Sigma_a=0.08\\,\\mathrm{cm}^{-1}$, $S_0=0.04$, $t_0=0.02$, $s_0=1$, $s_2=-0.6$。\n可得：\n$B_m^2 = \\Sigma_a/D = 1/15\\,\\mathrm{cm}^{-2}$。\n$a^2 B_m^2 = 400/15 = 80/3$。\n$a B_m = 20/\\sqrt{15} \\approx 5.1640$。\n$\\frac{t_0 s_2}{S_0 + t_0 s_0} = \\frac{0.02 \\times (-0.6)}{0.04 + 0.02} = \\frac{-0.012}{0.06} = -0.2$。\n计算括号内的项：\n$$-\\frac{1}{2} + \\frac{3}{80/3} \\left( 1 - \\frac{20/\\sqrt{15}}{\\sinh(20/\\sqrt{15})} \\right) \\approx -0.5 + 0.1125 \\times (1 - 0.05907) \\approx -0.39415$$\n最后，计算 R：\n$$R \\approx 1 + (-0.2) \\times (-0.39415) = 1 + 0.07883 = 1.07883$$\n四舍五入到四位有效数字，结果为 $1.079$。",
            "answer": "$$\n\\boxed{1.079}\n$$"
        },
        {
            "introduction": "在建立了反应堆堆芯中所有节点之间的耦合关系后，整个问题就归结为一个大规模的矩阵特征值问题。本练习要求您实现幂迭代法，这是一种用于求解主特征值（有效增殖因数 $k_{\\text{eff}}$）及其对应特征向量（中子通量分布）的基础算法。这项动手编程练习将使您熟悉大多数反应堆物理程序的核心数值引擎，从而将节点理论与实际计算联系起来。",
            "id": "4214374",
            "problem": "考虑一个粗网格节块公式中的稳态多群中子扩散平衡，在对每个节块进行积分并通过解析节块封闭关系消除界面未知数后，该问题可简化为以下形式的广义代数特征值问题\n$$\n\\mathbf{A}\\,\\boldsymbol{\\phi} \\;=\\; \\frac{1}{k}\\,\\mathbf{F}\\,\\boldsymbol{\\phi},\n$$\n其中 $\\mathbf{A}$ 是一个节块损失耦合算子，$\\mathbf{F}$ 是一个节块裂变产生算子。假设 $\\mathbf{A}$ 是一个 M-矩阵（对角元为正，非对角元为非正，且严格对角占优），$\\mathbf{F}$ 的元素均为非负。通过在左侧乘以 $\\mathbf{A}^{-1}$，该问题等价于标准特征值问题\n$$\n\\mathbf{T}\\,\\boldsymbol{\\phi} \\;=\\; k\\,\\boldsymbol{\\phi}, \\quad \\text{with} \\quad \\mathbf{T} \\equiv \\mathbf{A}^{-1}\\mathbf{F}.\n$$\n您需要实现幂迭代法来近似求解 $\\mathbf{T}$ 的主特征对 $(k,\\boldsymbol{\\phi})$，它对应于有效增殖因子 $k_\\text{eff}$ 和基波模节块通量形状。请遵循以下原则：\n- 从一个分量严格为正且欧几里得范数为单位的初始猜测 $\\boldsymbol{\\phi}^{(0)}$ 开始，并进行迭代\n$$\n\\boldsymbol{w}^{(m)} \\;=\\; \\mathbf{A}^{-1}\\mathbf{F}\\,\\boldsymbol{\\phi}^{(m)}, \\qquad\nk^{(m+1)} \\;=\\; \\frac{\\left(\\boldsymbol{\\phi}^{(m)}\\right)^{\\!\\top}\\boldsymbol{w}^{(m)}}{\\left(\\boldsymbol{\\phi}^{(m)}\\right)^{\\!\\top}\\boldsymbol{\\phi}^{(m)}}, \\qquad\n\\boldsymbol{\\phi}^{(m+1)} \\;=\\; \\frac{\\boldsymbol{w}^{(m)}}{\\left\\|\\boldsymbol{w}^{(m)}\\right\\|_2}.\n$$\n- 在每次迭代中，计算广义残差\n$$\n\\boldsymbol{r}^{(m+1)} \\;=\\; \\mathbf{F}\\,\\boldsymbol{\\phi}^{(m+1)} \\;-\\; k^{(m+1)}\\,\\mathbf{A}\\,\\boldsymbol{\\phi}^{(m+1)},\n$$\n及其相对欧几里得范数\n$$\n\\rho^{(m+1)} \\;=\\; \\frac{\\left\\|\\boldsymbol{r}^{(m+1)}\\right\\|_2}{\\left\\|\\mathbf{A}\\,\\boldsymbol{\\phi}^{(m+1)}\\right\\|_2}.\n$$\n- 当对于给定的容差 $\\varepsilon$ 满足 $\\rho^{(m+1)} \\le \\varepsilon$ 时，或者达到预设的最大迭代次数时，终止迭代。\n\n请实现一个程序，对于下述每个测试用例，返回一个三元组，包含终止时的近似主特征值 $k_\\text{eff}$、最终的残差范数 $\\rho$ 以及一个整数收敛标志（如果 $\\rho \\le \\varepsilon$ 则为 $1$，否则为 $0$）。初始向量必须是归一化为单位欧几里得范数的全一向量。所有算术运算必须以标准双精度进行。此问题中无物理单位要求；所有量均为无量纲。\n\n测试套件：\n- 用例 1（一般的良态节块系统）：\n  - $\\mathbf{A}_1 = \\begin{bmatrix} 2.5  -0.5  0.0 \\\\ -0.4  2.8  -0.6 \\\\ 0.0  -0.3  2.2 \\end{bmatrix}$, \n    $\\mathbf{F}_1 = \\begin{bmatrix} 0.7  0.1  0.0 \\\\ 0.2  0.6  0.1 \\\\ 0.0  0.2  0.5 \\end{bmatrix}$, \n    $\\varepsilon_1 = 10^{-8}$, \n    $m_{\\max,1} = 1000$。\n- 用例 2（主谱接近简并以挑战收敛速率）：\n  - $\\mathbf{A}_2 = \\begin{bmatrix} 3.0  -0.9  -0.2 \\\\ -0.9  3.1  -0.9 \\\\ -0.2  -0.9  3.0 \\end{bmatrix}$, \n    $\\mathbf{F}_2 = \\begin{bmatrix} 1.2  0.2  0.0 \\\\ 0.2  1.15  0.2 \\\\ 0.0  0.2  1.1 \\end{bmatrix}$, \n    $\\varepsilon_2 = 10^{-9}$, \n    $m_{\\max,2} = 2000$。\n- 用例 3（容差过严且迭代次数不足以强制非收敛）：\n  - $\\mathbf{A}_3 = \\begin{bmatrix} 2.0  -0.5  -0.4 \\\\ -0.5  2.1  -0.5 \\\\ -0.4  -0.5  2.2 \\end{bmatrix}$, \n    $\\mathbf{F}_3 = \\begin{bmatrix} 0.9  0.1  0.05 \\\\ 0.1  0.85  0.1 \\\\ 0.05  0.1  0.8 \\end{bmatrix}$, \n    $\\varepsilon_3 = 10^{-12}$, \n    $m_{\\max,3} = 5$。\n\n对于每个用例，输出三元组 $\\left[k_\\text{eff}, \\rho, c\\right]$，其中 $k_\\text{eff}$ 和 $\\rho$ 四舍五入到 $8$ 位小数，$c \\in \\{0,1\\}$ 是收敛标志。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个由三个用例结果组成的逗号分隔列表，该列表用方括号括起来，每个用例结果本身也格式化为用方括号括起来的逗号分隔三元组，且不含内嵌空格。例如，输出应具有以下形式：\n$[\\,[k_1,\\rho_1,c_1],[k_2,\\rho_2,c_2],[k_3,\\rho_3,c_3]\\,]$ \n其中每个 $k_i$ 和 $\\rho_i$ 都精确打印到小数点后 $8$ 位，每个 $c_i$ 是整数 $0$ 或 $1$。",
            "solution": "该问题要求实现幂迭代法，用于求解形如 $\\mathbf{A}\\,\\boldsymbol{\\phi} = (1/k)\\,\\mathbf{F}\\,\\boldsymbol{\\phi}$ 的广义特征值问题的主特征对 $(k, \\boldsymbol{\\phi})$。这在反应堆物理中对应于计算有效增殖因子 $k_\\text{eff}$ 和基波中子通量分布。\n\n**算法概述**\n幂迭代法是一种迭代算法，通过反复将矩阵乘以一个向量来找到其主特征向量。对于给定的问题，迭代矩阵是 $\\mathbf{T} = \\mathbf{A}^{-1}\\mathbf{F}$。算法遵循以下步骤：\n1.  **初始化**：从一个初始的归一化通量向量 $\\boldsymbol{\\phi}^{(0)}$ 开始（例如，归一化的全一向量）。\n2.  **迭代更新**：在每次迭代 $m$ 中：\n    a.  **计算裂变源**：首先计算当前通量分布产生的裂变中子源，$\\boldsymbol{y} = \\mathbf{F}\\boldsymbol{\\phi}^{(m)}$。\n    b.  **求解通量**：通过求解线性方程组 $\\mathbf{A}\\boldsymbol{w}^{(m)} = \\boldsymbol{y}$ 来更新通量分布。这一步等效于计算 $\\boldsymbol{w}^{(m)} = \\mathbf{A}^{-1}\\boldsymbol{y}$，但避免了显式计算矩阵的逆，从而在数值上更稳健。\n    c.  **更新特征值**：使用瑞利商估计新的特征值 $k^{(m+1)} = (\\boldsymbol{\\phi}^{(m)})^\\top \\boldsymbol{w}^{(m)} / ((\\boldsymbol{\\phi}^{(m)})^\\top \\boldsymbol{\\phi}^{(m)})$。\n    d.  **归一化特征向量**：将新计算出的向量 $\\boldsymbol{w}^{(m)}$ 归一化，得到下一次迭代的特征向量估计 $\\boldsymbol{\\phi}^{(m+1)} = \\boldsymbol{w}^{(m)} / \\|\\boldsymbol{w}^{(m)}\\|_2$。\n3.  **收敛判据**：在每次迭代后，计算广义残差 $\\boldsymbol{r}^{(m+1)}$ 及其相对范数 $\\rho^{(m+1)}$。如果 $\\rho^{(m+1)}$ 小于给定的容差 $\\varepsilon$，则认为算法收敛。\n4.  **终止条件**：当算法收敛或达到预设的最大迭代次数 $m_{\\max}$ 时，迭代终止。\n\n**实现**\n提供的 Python 代码 `power_iteration` 函数精确地实现了上述算法。它使用 `NumPy` 库进行所有必需的线性代数运算，如矩阵向量乘法、求解线性系统 (`numpy.linalg.solve`) 和计算向量范数。一个主函数 `solve` 负责运行所有三个测试用例，收集结果，并按照要求的格式输出最终的三元组 $[k_\\text{eff}, \\rho, c]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef power_iteration(A: np.ndarray, F: np.ndarray, eps: float, max_iter: int) -> tuple[float, float, int]:\n    \"\"\"\n    Solves the generalized eigenvalue problem A*phi = (1/k)*F*phi using power iteration.\n\n    Args:\n        A: The nodal loss-coupling operator matrix.\n        F: The nodal fission production operator matrix.\n        eps: The convergence tolerance for the relative residual norm.\n        max_iter: The maximum number of iterations.\n\n    Returns:\n        A tuple containing the approximate dominant eigenvalue (k_eff),\n        the final relative residual norm (rho), and a convergence flag (1 if converged, 0 otherwise).\n    \"\"\"\n    n = A.shape[0]\n    \n    # Initialize the eigenvector guess phi^(0) as the all-ones vector,\n    # normalized to have a unit Euclidean norm.\n    phi = np.ones(n, dtype=np.float64)\n    phi = phi / np.linalg.norm(phi)\n    \n    k_eff = 0.0\n    rho = np.inf  # Initialize with a large value\n    converged = 0\n\n    for m in range(max_iter):\n        # Current eigenvector estimate is phi, which corresponds to phi^(m).\n        \n        # 1. Calculate w^(m) = A^-1 * F * phi^(m)\n        # This is done by first computing y = F * phi and then solving A * w = y.\n        # This avoids explicit matrix inversion, which is numerically preferable.\n        y = F @ phi\n        w = np.linalg.solve(A, y)\n        \n        # 2. Calculate k^(m+1) using the Rayleigh quotient formulation.\n        # Since phi is normalized, phi.T @ phi is 1.0.\n        k_eff = (phi.T @ w) / (phi.T @ phi)\n        \n        # 3. Calculate the next eigenvector estimate phi^(m+1) by normalization.\n        norm_w = np.linalg.norm(w)\n        if norm_w < np.finfo(np.float64).eps:\n            # Pathological case where the fission source vanishes. Stop iteration.\n            break \n            \n        phi_next = w / norm_w\n        \n        # 4. Calculate the generalized residual r^(m+1) and its relative norm rho^(m+1).\n        A_phi_next = A @ phi_next\n        r = F @ phi_next - k_eff * A_phi_next\n        \n        norm_r = np.linalg.norm(r)\n        norm_A_phi_next = np.linalg.norm(A_phi_next)\n        \n        if norm_A_phi_next < np.finfo(np.float64).eps:\n            # Pathological case where A*phi is near zero. Stop iteration.\n            break\n\n        rho = norm_r / norm_A_phi_next\n        \n        # Update phi for the next iteration.\n        phi = phi_next\n        \n        # 5. Check for convergence.\n        if rho <= eps:\n            converged = 1\n            break\n            \n    # Return the results from the last completed iteration.\n    return k_eff, rho, converged\n\n\ndef solve():\n    \"\"\"\n    Runs the power iteration for all test cases and prints the formatted results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[2.5, -0.5, 0.0], [-0.4, 2.8, -0.6], [0.0, -0.3, 2.2]], dtype=np.float64),\n            \"F\": np.array([[0.7, 0.1, 0.0], [0.2, 0.6, 0.1], [0.0, 0.2, 0.5]], dtype=np.float64),\n            \"eps\": 1e-8,\n            \"max_iter\": 1000\n        },\n        {\n            \"A\": np.array([[3.0, -0.9, -0.2], [-0.9, 3.1, -0.9], [-0.2, -0.9, 3.0]], dtype=np.float64),\n            \"F\": np.array([[1.2, 0.2, 0.0], [0.2, 1.15, 0.2], [0.0, 0.2, 1.1]], dtype=np.float64),\n            \"eps\": 1e-9,\n            \"max_iter\": 2000\n        },\n        {\n            \"A\": np.array([[2.0, -0.5, -0.4], [-0.5, 2.1, -0.5], [-0.4, -0.5, 2.2]], dtype=np.float64),\n            \"F\": np.array([[0.9, 0.1, 0.05], [0.1, 0.85, 0.1], [0.05, 0.1, 0.8]], dtype=np.float64),\n            \"eps\": 1e-12,\n            \"max_iter\": 5\n        }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        k_eff, rho, converged = power_iteration(\n            case[\"A\"], case[\"F\"], case[\"eps\"], case[\"max_iter\"]\n        )\n        \n        # Format the results into the string \"[k_eff,rho,c]\" with 8 decimal places for floats.\n        result_str = f\"[{k_eff:.8f},{rho:.8f},{converged}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format: [[...],[...],[...]]\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```"
        }
    ]
}