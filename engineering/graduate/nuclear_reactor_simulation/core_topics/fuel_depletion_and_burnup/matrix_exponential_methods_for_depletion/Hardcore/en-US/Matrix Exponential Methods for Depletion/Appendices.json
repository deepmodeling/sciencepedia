{
    "hands_on_practices": [
        {
            "introduction": "To build a solid foundation, we begin by connecting the abstract matrix exponential formalism to a concrete, analytically solvable problem. This exercise  asks you to derive the solution for a simple two-nuclide decay chain using two different methods: direct integration of the scalar ODEs and application of the matrix exponential. By demonstrating that both paths lead to the identical result, you will gain a deeper intuition for the matrix exponential as the true solution operator for linear time-invariant systems.",
            "id": "4234748",
            "problem": "In a homogeneous, zero-flux cell, consider a two-nuclide chain where nuclide $1$ decays to nuclide $2$ with decay constant $\\lambda_{1} > 0$, and nuclide $2$ decays to a stable sink with decay constant $\\lambda_{2} > 0$. There are no other reactions or sources. Let the inventory vector be $n(t) = \\begin{pmatrix} n_{1}(t) \\\\ n_{2}(t) \\end{pmatrix}$, with initial condition $n(0) = \\begin{pmatrix} n_{1,0} \\\\ n_{2,0} \\end{pmatrix}$. The depletion equations are linear and time-invariant and can be written as $\\frac{d}{dt} n(t) = A n(t)$, where $A$ is a constant matrix. Assume $\\lambda_{1} \\neq \\lambda_{2}$.\n\nUsing only the fundamental radioactive decay law and the definition of the matrix exponential as the solution operator for linear time-invariant systems, perform the following:\n\n- Identify the system matrix $A$ implied by the physical description.\n- Derive a closed-form expression for $n_{2}(\\Delta t)$ in terms of $n_{1,0}$, $n_{2,0}$, $\\lambda_{1}$, $\\lambda_{2}$, and $\\Delta t$, starting from the scalar ordinary differential equations (ODEs).\n- Independently, starting from the definition of the state transition matrix $\\Phi(t) = \\exp(A t)$ as the unique solution of $\\frac{d}{dt}\\Phi(t) = A \\Phi(t)$ with $\\Phi(0) = I$, determine the $(2,1)$ entry of $\\exp(A \\Delta t)$.\n- Verify that applying $\\exp(A \\Delta t)$ to $n(0)$ reproduces the closed-form $n_{2}(\\Delta t)$ for arbitrary $n_{1,0}$ and $n_{2,0}$.\n\nProvide as your final answer the symbolic expression for the $(2,1)$ entry of $\\exp(A \\Delta t)$. No numerical evaluation is required, and no units are to be reported. The answer should be a single closed-form analytic expression.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and free of contradictions or ambiguities. It represents a standard problem in nuclear engineering and mathematical physics. We may therefore proceed with a full solution.\n\nThe problem asks for a multi-step derivation and verification concerning a two-nuclide radioactive decay chain. Let $n_1(t)$ and $n_2(t)$ be the concentrations of nuclide $1$ and nuclide $2$ at time $t$, respectively.\n\n**1. Identification of the System Matrix $A$**\n\nThe physical process is a decay chain $1 \\rightarrow 2 \\rightarrow \\text{stable}$.\nThe rate of change of the concentration of nuclide $1$, $n_1(t)$, is governed solely by its own radioactive decay. The rate of decay is proportional to its concentration, with the decay constant being $\\lambda_1$.\n$$ \\frac{d n_1(t)}{dt} = -\\lambda_1 n_1(t) $$\nThe rate of change of the concentration of nuclide $2$, $n_2(t)$, has two contributions: a source term from the decay of nuclide $1$ and a loss term from its own decay. The production rate from nuclide $1$ is $\\lambda_1 n_1(t)$, and the loss rate is $\\lambda_2 n_2(t)$.\n$$ \\frac{d n_2(t)}{dt} = \\lambda_1 n_1(t) - \\lambda_2 n_2(t) $$\nThese two coupled first-order linear ordinary differential equations can be expressed in matrix form as $\\frac{d}{dt} n(t) = A n(t)$:\n$$ \\frac{d}{dt} \\begin{pmatrix} n_1(t) \\\\ n_2(t) \\end{pmatrix} = \\begin{pmatrix} -\\lambda_1 & 0 \\\\ \\lambda_1 & -\\lambda_2 \\end{pmatrix} \\begin{pmatrix} n_1(t) \\\\ n_2(t) \\end{pmatrix} $$\nBy inspection, the system matrix $A$ is:\n$$ A = \\begin{pmatrix} -\\lambda_1 & 0 \\\\ \\lambda_1 & -\\lambda_2 \\end{pmatrix} $$\n\n**2. Derivation of $n_2(\\Delta t)$ from Scalar ODEs**\n\nFirst, we solve the ODE for $n_1(t)$ with the initial condition $n_1(0) = n_{1,0}$:\n$$ \\frac{dn_1}{dt} = -\\lambda_1 n_1(t) \\implies n_1(t) = n_{1,0} \\exp(-\\lambda_1 t) $$\nNext, we substitute this solution into the ODE for $n_2(t)$:\n$$ \\frac{dn_2}{dt} = \\lambda_1 n_{1,0} \\exp(-\\lambda_1 t) - \\lambda_2 n_2(t) $$\nThis can be rewritten as a standard first-order linear ODE:\n$$ \\frac{dn_2}{dt} + \\lambda_2 n_2(t) = \\lambda_1 n_{1,0} \\exp(-\\lambda_1 t) $$\nWe solve this using an integrating factor, $\\mu(t) = \\exp\\left(\\int \\lambda_2 dt\\right) = \\exp(\\lambda_2 t)$. Multiplying the equation by $\\mu(t)$:\n$$ \\exp(\\lambda_2 t) \\frac{dn_2}{dt} + \\lambda_2 \\exp(\\lambda_2 t) n_2(t) = \\lambda_1 n_{1,0} \\exp((\\lambda_2 - \\lambda_1)t) $$\nThe left side is the derivative of the product $n_2(t)\\mu(t)$:\n$$ \\frac{d}{dt} \\left( n_2(t) \\exp(\\lambda_2 t) \\right) = \\lambda_1 n_{1,0} \\exp((\\lambda_2 - \\lambda_1)t) $$\nIntegrating both sides from $0$ to $t$:\n$$ \\int_0^t \\frac{d}{d\\tau} \\left( n_2(\\tau) \\exp(\\lambda_2 \\tau) \\right) d\\tau = \\int_0^t \\lambda_1 n_{1,0} \\exp((\\lambda_2 - \\lambda_1)\\tau) d\\tau $$\n$$ \\left[ n_2(\\tau) \\exp(\\lambda_2 \\tau) \\right]_0^t = \\lambda_1 n_{1,0} \\left[ \\frac{\\exp((\\lambda_2 - \\lambda_1)\\tau)}{\\lambda_2 - \\lambda_1} \\right]_0^t $$\nThis step is valid because the problem states $\\lambda_1 \\neq \\lambda_2$.\n$$ n_2(t) \\exp(\\lambda_2 t) - n_2(0) \\exp(0) = \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp((\\lambda_2 - \\lambda_1)t) - 1 \\right) $$\nUsing the initial condition $n_2(0) = n_{2,0}$:\n$$ n_2(t) \\exp(\\lambda_2 t) = n_{2,0} + \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp(\\lambda_2 t)\\exp(-\\lambda_1 t) - 1 \\right) $$\nMultiplying by $\\exp(-\\lambda_2 t)$ to isolate $n_2(t)$:\n$$ n_2(t) = n_{2,0} \\exp(-\\lambda_2 t) + \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp(-\\lambda_1 t) - \\exp(-\\lambda_2 t) \\right) $$\nFinally, evaluating at time $t = \\Delta t$:\n$$ n_2(\\Delta t) = n_{2,0} \\exp(-\\lambda_2 \\Delta t) + \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp(-\\lambda_1 \\Delta t) - \\exp(-\\lambda_2 \\Delta t) \\right) $$\n\n**3. Determination of the $(2,1)$ Entry of $\\exp(A \\Delta t)$**\n\nLet $\\Phi(t) = \\exp(A t)$ be the state transition matrix. It is the unique solution to the matrix differential equation $\\frac{d}{dt}\\Phi(t) = A \\Phi(t)$ with the initial condition $\\Phi(0) = I$, the identity matrix. Let $\\Phi(t) = \\begin{pmatrix} \\Phi_{11}(t) & \\Phi_{12}(t) \\\\ \\Phi_{21}(t) & \\Phi_{22}(t) \\end{pmatrix}$.\nThe matrix equation expands to a system of ODEs for the entries of $\\Phi(t)$:\n$$ \\frac{d}{dt} \\begin{pmatrix} \\Phi_{11} & \\Phi_{12} \\\\ \\Phi_{21} & \\Phi_{22} \\end{pmatrix} = \\begin{pmatrix} -\\lambda_1 & 0 \\\\ \\lambda_1 & -\\lambda_2 \\end{pmatrix} \\begin{pmatrix} \\Phi_{11} & \\Phi_{12} \\\\ \\Phi_{21} & \\Phi_{22} \\end{pmatrix} = \\begin{pmatrix} -\\lambda_1 \\Phi_{11} & -\\lambda_1 \\Phi_{12} \\\\ \\lambda_1 \\Phi_{11} - \\lambda_2 \\Phi_{21} & \\lambda_1 \\Phi_{12} - \\lambda_2 \\Phi_{22} \\end{pmatrix} $$\nThe initial conditions are $\\Phi_{11}(0) = 1$, $\\Phi_{12}(0) = 0$, $\\Phi_{21}(0) = 0$, and $\\Phi_{22}(0) = 1$.\nTo find the $(2,1)$ entry, $\\Phi_{21}(t)$, we must solve the ODE:\n$$ \\frac{d\\Phi_{21}}{dt} = \\lambda_1 \\Phi_{11}(t) - \\lambda_2 \\Phi_{21}(t) $$\nThis requires first finding $\\Phi_{11}(t)$. From the matrix system, its ODE is $\\frac{d\\Phi_{11}}{dt} = -\\lambda_1 \\Phi_{11}$, with initial condition $\\Phi_{11}(0)=1$. The solution is $\\Phi_{11}(t) = \\exp(-\\lambda_1 t)$.\nSubstituting this into the equation for $\\Phi_{21}(t)$:\n$$ \\frac{d\\Phi_{21}}{dt} + \\lambda_2 \\Phi_{21}(t) = \\lambda_1 \\exp(-\\lambda_1 t) $$\nThis is a first-order linear ODE with initial condition $\\Phi_{21}(0) = 0$. This equation is of the same form as the one for $n_2(t)$, but with $n_{1,0}$ replaced by $1$ and $n_{2,0}$ replaced by $0$. Using the same integrating factor method or by direct substitution into the general solution form derived previously:\n$$ \\Phi_{21}(t) = 0 \\cdot \\exp(-\\lambda_2 t) + \\frac{\\lambda_1 \\cdot 1}{\\lambda_2 - \\lambda_1} \\left( \\exp(-\\lambda_1 t) - \\exp(-\\lambda_2 t) \\right) $$\n$$ \\Phi_{21}(t) = \\frac{\\lambda_1}{\\lambda_2 - \\lambda_1} \\left(\\exp(-\\lambda_1 t) - \\exp(-\\lambda_2 t)\\right) $$\nThe $(2,1)$ entry of $\\exp(A \\Delta t)$ is therefore:\n$$ (\\exp(A \\Delta t))_{2,1} = \\Phi_{21}(\\Delta t) = \\frac{\\lambda_1}{\\lambda_2 - \\lambda_1} \\left(\\exp(-\\lambda_1 \\Delta t) - \\exp(-\\lambda_2 \\Delta t)\\right) $$\n\n**4. Verification**\n\nThe solution to the system is given by $n(\\Delta t) = \\exp(A \\Delta t) n(0)$. We focus on the second component of this vector equation:\n$$ n_2(\\Delta t) = (\\exp(A \\Delta t))_{2,1} n_{1,0} + (\\exp(A \\Delta t))_{2,2} n_{2,0} $$\nWe have already found $(\\exp(A \\Delta t))_{2,1}$. We now find $(\\exp(A \\Delta t))_{2,2} = \\Phi_{22}(\\Delta t)$. The ODE is $\\frac{d\\Phi_{22}}{dt} = \\lambda_1 \\Phi_{12} - \\lambda_2 \\Phi_{22}$ with $\\Phi_{22}(0)=1$. First, we need $\\Phi_{12}(t)$. Its ODE is $\\frac{d\\Phi_{12}}{dt} = -\\lambda_1 \\Phi_{12}$ with $\\Phi_{12}(0)=0$. The only solution is $\\Phi_{12}(t)=0$.\nThe ODE for $\\Phi_{22}$ simplifies to $\\frac{d\\Phi_{22}}{dt} = -\\lambda_2 \\Phi_{22}$, with $\\Phi_{22}(0)=1$. The solution is $\\Phi_{22}(t)=\\exp(-\\lambda_2 t)$.\nSubstituting the expressions for $\\Phi_{21}(\\Delta t)$ and $\\Phi_{22}(\\Delta t)$ into the equation for $n_2(\\Delta t)$:\n$$ n_2(\\Delta t) = \\left( \\frac{\\lambda_1}{\\lambda_2 - \\lambda_1} \\left(\\exp(-\\lambda_1 \\Delta t) - \\exp(-\\lambda_2 \\Delta t)\\right) \\right) n_{1,0} + \\left( \\exp(-\\lambda_2 \\Delta t) \\right) n_{2,0} $$\nThis expression is identical to the one derived in part 2 by solving the scalar ODEs. The results are consistent, thus verifying the calculation. The $(2,1)$ entry of the matrix exponential correctly represents the contribution of the initial concentration of nuclide $1$ to the final concentration of nuclide $2$.",
            "answer": "$$\\boxed{\\frac{\\lambda_{1}}{\\lambda_{2} - \\lambda_{1}} (\\exp(-\\lambda_{1} \\Delta t) - \\exp(-\\lambda_{2} \\Delta t))}$$"
        },
        {
            "introduction": "Real-world depletion calculations must account for constant sources, such as fission yields, which render the system of equations inhomogeneous. This hands-on exercise  demonstrates how to solve such systems elegantly by transforming them into a larger, homogeneous form using the augmented matrix method. Furthermore, it addresses the critical requirement of physical realism by having you implement a positivity check and diagnose the root cause of any unphysical negative densities, a crucial skill for validating simulation results.",
            "id": "4234763",
            "problem": "Consider a depletion step in a nuclear reactor simulation, modeled as a linear, piecewise-constant system over a single time interval. Let the nuclide number density vector be denoted by $N(t) \\in \\mathbb{R}^n$, with $n$ nuclides, and assume a constant neutron flux $\\phi$ over the interval. The governing law is the linear inhomogeneous system\n$$\n\\frac{d}{dt} N(t) = A N(t) + q,\n$$\nwhere $A \\in \\mathbb{R}^{n \\times n}$ is the depletion/transmutation matrix assembled from decay constants and neutron-induced reaction rates, and $q \\in \\mathbb{R}^n$ is a constant source term (for example, from fission yields treated as constant within the step). All quantities are assumed constant within the time interval of length $h$, so the exact solution at time $t+h$ is well-defined. The number densities are expressed in atoms per barn-centimeter ($\\text{atoms}/\\text{b}\\text{-}\\text{cm}$), the flux $\\phi$ in neutrons per square centimeter per second ($\\text{n}/\\text{cm}^2/\\text{s}$), cross sections in barns, and time in seconds.\n\nFundamental base:\n- Linear first-order ordinary differential equations and the exact solution via the matrix exponential for systems with constant coefficients.\n- Nuclide balance: for each nuclide $i$, the diagonal entry $A_{ii}$ is the negative sum of its removal rates, and the off-diagonal entries $A_{ji}$ for $j \\neq i$ are nonnegative transfer rates from $i$ to $j$ (when physically consistent).\n- For a decay with decay constant $\\lambda_i$ producing daughter $j$ with branching fraction $\\beta_{i \\to j}$, the production rate contributes $A_{j i} = \\beta_{i \\to j} \\lambda_i$ and removal contributes $A_{i i} = -\\lambda_i$. For neutron absorption of nuclide $i$ with microscopic cross section $\\sigma_i$ at flux $\\phi$, the removal rate is $\\lambda^{(n)}_i = \\phi \\sigma_i \\times 10^{-24}$ in $\\text{s}^{-1}$, and any tracked transmutation yield $y_{i \\to j}$ adds $A_{j i} = y_{i \\to j} \\lambda^{(n)}_i$. A constant source $q_j$ may be included to represent, for example, fission yields treated as constant within the step.\n\nTask:\n1. Using the matrix exponential method, compute $N(t+h)$ exactly for each given scenario by augmenting the system to remove the inhomogeneous term. Introduce an augmented state $X(t) = \\begin{bmatrix} N(t) \\\\ 1 \\end{bmatrix}$ of dimension $n+1$ so that\n$$\n\\frac{d}{dt} X(t) = \\begin{bmatrix} A & q \\\\ 0\\cdot\\mathbf{1}^\\top & 0 \\end{bmatrix} X(t),\n$$\nwhere $0\\cdot\\mathbf{1}^\\top$ denotes the zero row vector of length $n$. Then\n$$\nX(t+h) = \\exp\\!\\left(\\begin{bmatrix} A & q \\\\ 0 & 0 \\end{bmatrix} h\\right) X(t), \\quad \\text{and} \\quad N(t+h) = \\left[ X(t+h) \\right]_{1:n}.\n$$\n2. Perform a strict positivity check on the computed densities $N(t+h)$: determine whether each component is strictly greater than $0$, with no tolerance.\n3. If any component is not strictly greater than $0$, document the violation by reporting the minimum component value and diagnose a likely numerical cause using the following indicators:\n   - Check whether $A$ is a Metzler matrix, i.e., $A_{j i} \\ge 0$ for $j \\ne i$. A failure indicates an inconsistent model structure that does not generate a positive semigroup.\n   - Estimate stiffness via the ratio\n     $$\n     S = \\frac{\\max_i |\\Re(\\lambda_i(A))|}{\\min_{i: |\\Re(\\lambda_i(A))| > 0} |\\Re(\\lambda_i(A))|},\n     $$\n     where $\\lambda_i(A)$ are the eigenvalues of $A$. Extremely large $S$ combined with large $h$ suggests potential round-off amplification in computing the matrix exponential.\n   - Report whether the negativity magnitude is on the order of machine precision versus materially negative.\n4. Output, for each test scenario, a triple $[b, m, d]$, where $b$ is a boolean indicating whether all components of $N(t+h)$ are strictly positive, $m$ is the minimum component of $N(t+h)$ (a float), and $d$ is an integer diagnostic code defined as:\n   - $0$ if no violation occurred (all strictly positive).\n   - $1$ if the matrix is not Metzler (negative off-diagonal entries detected).\n   - $2$ if a violation occurred but the minimum value is close to machine precision in magnitude (interpreted as round-off under extreme stiffness).\n   - $3$ if a violation occurred with a Metzler matrix and the magnitude is materially negative (interpreted as error amplification due to step size and ill-conditioning).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each scenarioâ€™s triple itself enclosed in square brackets and comma-separated, for example: $[ [b_1,m_1,d_1],[b_2,m_2,d_2],\\ldots ]$.\n\nTest suite:\nUse the following four scenarios. All densities should be reported in $\\text{atoms}/\\text{b}\\text{-}\\text{cm}$ and all times in $\\text{s}$. For all scenarios, the nuclide ordering is $[\\text{U-235}, \\text{U-236}, \\text{I-135}, \\text{Xe-135}]$.\n\n- Scenario $1$ (baseline thermal flux, moderate step):\n  - Initial densities: $N(0) = [3.000 \\times 10^{-4}, 0.000, 0.000, 0.000]$.\n  - Flux: $\\phi = 3.000 \\times 10^{14}$.\n  - Cross sections (barns): $\\sigma_f(\\text{U-235}) = 580.0$, $\\sigma_c(\\text{U-235}) = 100.0$, $\\sigma_a(\\text{Xe-135}) = 2.000 \\times 10^{6}$, $\\sigma_a(\\text{I-135}) = 6.0$.\n  - Decay constants: $\\lambda(\\text{I-135}) = \\ln(2)/23652.0$, $\\lambda(\\text{Xe-135}) = \\ln(2)/32904.0$.\n  - Fission yield: $Y(\\text{I-135} \\leftarrow \\text{U-235 fision}) = 0.062$.\n  - Step: $h = 21600.0$.\n\n- Scenario $2$ (extreme stiffness, long step):\n  - Initial densities: $N(0) = [3.000 \\times 10^{-4}, 0.000, 0.000, 0.000]$.\n  - Flux: $\\phi = 1.000 \\times 10^{15}$.\n  - Cross sections (barns): same as Scenario $1$.\n  - Decay constants: same as Scenario $1$.\n  - Fission yield: same as Scenario $1$.\n  - Step: $h = 3.600 \\times 10^{6}$.\n\n- Scenario $3$ (decay-only, zero flux boundary case):\n  - Initial densities: $N(0) = [1.000 \\times 10^{-6}, 0.000, 2.000 \\times 10^{-6}, 0.000]$.\n  - Flux: $\\phi = 0.0$.\n  - Cross sections (barns): same as Scenario $1$.\n  - Decay constants: same as Scenario $1$.\n  - Fission yield: $Y(\\text{I-135} \\leftarrow \\text{U-235 fision}) = 0.062$ (unused due to zero flux).\n  - Step: $h = 86400.0$.\n\n- Scenario $4$ (diagnostic edge case with inconsistent off-diagonal):\n  - Initial densities: $N(0) = [3.000 \\times 10^{-4}, 0.000, 0.000, 0.000]$.\n  - Flux: $\\phi = 3.000 \\times 10^{14}$.\n  - Cross sections (barns): same as Scenario $1$.\n  - Decay constants: same as Scenario $1$.\n  - Fission yield: same as Scenario $1$.\n  - Step: $h = 3600.0$.\n  - Modification: invert the sign of the $\\text{U-235} \\to \\text{U-236}$ capture transfer so that $A_{2,1} = -\\lambda^{(n)}_{\\mathrm{capture, U-235}}$, creating a negative off-diagonal (this is intentionally inconsistent and is used solely to test the diagnostic).\n\nAssembly details for all scenarios:\n- Compute $\\lambda^{(n)}_{\\mathrm{fission, U-235}} = \\phi \\sigma_{f}^{\\mathrm{U-235}} \\times 10^{-24}$ and $\\lambda^{(n)}_{\\mathrm{capture, U-235}} = \\phi \\sigma_{c}^{\\mathrm{U-235}} \\times 10^{-24}$.\n- Removal on U-235: $A_{1,1} = -(\\lambda^{(n)}_{\\mathrm{fission, U-235}} + \\lambda^{(n)}_{\\mathrm{capture, U-235}})$.\n- Capture transfer to U-236: $A_{2,1} = +\\lambda^{(n)}_{\\mathrm{capture, U-235}}$ except in Scenario 4 where $A_{2,1}$ is negated.\n- Fission yield source to I-135: $q_3 = Y \\cdot \\lambda^{(n)}_{\\mathrm{fission, U-235}} \\cdot N_1(0)$.\n- I-135 decay to Xe-135: $A_{4,3} = \\lambda(\\text{I-135})$ and $A_{3,3} = -\\lambda(\\text{I-135})$.\n- Xe-135 removal: $A_{4,4} = -(\\lambda(\\text{Xe-135}) + \\phi \\sigma_{a}^{\\mathrm{Xe-135}} \\times 10^{-24})$.\n- I-135 absorption is neglected in production and included only in removal if desired; for this test, set $A_{3,3}$ as above without neutron absorption contribution to simplify the chain.\n\nYour program must:\n- Implement the augmented matrix exponential method exactly for computing $N(t+h)$.\n- For each scenario, compute the boolean strict positivity result, the minimum component value of $N(t+h)$ in $\\text{atoms}/\\text{b}\\text{-}\\text{cm}$, and the diagnostic code according to the rules above.\n- Produce a single line of output with the list of four scenario results in the format described earlier, with numerical values printed in standard decimal notation.",
            "solution": "The governing depletion equations over a single step with constant coefficients are linear and piecewise-constant. Starting from the fundamental law of linear systems,\n$$\n\\frac{d}{dt} N(t) = A N(t) + q,\n$$\nwith $A \\in \\mathbb{R}^{n \\times n}$ constant and $q \\in \\mathbb{R}^n$ constant on the interval, the exact solution follows from the theory of linear ordinary differential equations. In particular, the homogeneous solution is governed by the matrix exponential,\n$$\nN_{\\text{hom}}(t+h) = \\exp(A h) \\, N(t),\n$$\nand the complete solution incorporates the forcing via the variation-of-constants formula,\n$$\nN(t+h) = \\exp(A h)\\, N(t) + \\int_0^h \\exp(A \\tau) \\, q \\, d\\tau.\n$$\nWhen $A$ is invertible, the integral can be written as $A^{-1}(\\exp(A h) - I)q$, but this is not robust when $A$ is singular or near-singular. A principled and numerically stable approach is to convert the inhomogeneous system into a homogeneous system of dimension $n+1$ by augmenting the state with a constant component. Define the augmented state\n$$\nX(t) = \\begin{bmatrix} N(t) \\\\ 1 \\end{bmatrix},\n$$\nand the augmented system matrix\n$$\n\\mathcal{A} = \\begin{bmatrix} A & q \\\\ 0\\cdot\\mathbf{1}^\\top & 0 \\end{bmatrix}.\n$$\nThen\n$$\n\\frac{d}{dt} X(t) = \\mathcal{A} X(t),\n$$\nwhose exact solution is\n$$\nX(t+h) = \\exp(\\mathcal{A} h)\\, X(t).\n$$\nThe first $n$ components of $X(t+h)$ give $N(t+h)$ exactly. This transformation is based on well-tested facts of linear system theory and avoids any need to explicitly invert $A$ or evaluate integrals, while staying within the matrix exponential method.\n\nAssembly of $A$ and $q$ uses the physics of nuclide balance. For nuclide $i$, removal rates contribute to $A_{ii}$ as negative terms, and transfers to daughter nuclides contribute to off-diagonal entries. The neutron-induced reaction rate per nuclide is given by the product of flux and cross section in consistent units: with cross sections in barns and flux in $\\text{n}/\\text{cm}^2/\\text{s}$, the per-atom removal rate is $\\lambda^{(n)} = \\phi \\sigma \\times 10^{-24}$ in $\\text{s}^{-1}$. For decay processes, the removal contribution is $-\\lambda$, and the transfer to a daughter with branching fraction $\\beta$ is $\\beta \\lambda$ in the corresponding off-diagonal.\n\nPositivity considerations follow from the structure of $A$. If $A$ is a Metzler matrix (all off-diagonals are nonnegative) and the system is conservative in the sense that production terms are nonnegative, then the matrix exponential $\\exp(A t)$ generates a positive semigroup and preserves nonnegativity of the state for nonnegative initial conditions and nonnegative inputs. In such cases, the exact solution is strictly positive for strictly positive initial conditions (modulo the possibility of zero source contributions). However, numerical computation of $\\exp(\\mathcal{A} h)$ can introduce tiny negative components due to floating-point round-off or error amplification under stiffness.\n\nTo diagnose violations, we check:\n- Metzler property of $A$: verify $A_{j i} \\ge 0$ for $j \\ne i$. If this fails, then the model structure itself breaks positivity and any observed negativity is not due to the numerical evaluation but to inconsistent coupling.\n- Stiffness ratio,\n$$\nS = \\frac{\\max_i |\\Re(\\lambda_i(A))|}{\\min_{i: |\\Re(\\lambda_i(A))| > 0} |\\Re(\\lambda_i(A))|},\n$$\nwhere $\\lambda_i(A)$ are the eigenvalues. Large $S$ signals widely separated timescales. Combined with large $h$, scaling and squaring algorithms for $\\exp$ may suffer from round-off amplification, and minuscule negative values may arise even if the exact solution is nonnegative. Such values are typically of magnitude comparable to machine precision (e.g., $\\approx 10^{-16}$ to $\\approx 10^{-12}$).\n- Magnitude of the minimum value of $N(t+h)$: If it is close to machine precision, we assign code $2$ for round-off. If substantially negative with a Metzler matrix, we assign code $3$, indicating error amplification due to step size or ill-conditioned evaluation.\n\nAlgorithmic steps for each scenario:\n1. Parse parameters: initial $N(0)$, flux $\\phi$, cross sections, decay constants, yields, and time step $h$.\n2. Compute neutron-induced removal rates: $\\lambda_f(\\text{U-235}) = \\phi \\sigma_f(\\text{U-235}) \\cdot 10^{-24}$, $\\lambda_c(\\text{U-235}) = \\phi \\sigma_c(\\text{U-235}) \\cdot 10^{-24}$, and $\\lambda_a(\\text{Xe-135}) = \\phi \\sigma_a(\\text{Xe-135}) \\cdot 10^{-24}$.\n3. Assemble $A$:\n   - $A_{1,1} = -\\left(\\lambda_f + \\lambda_c\\right)$,\n   - $A_{2,1} = \\lambda_c$ (except Scenario $4$, where $A_{2,1} = -\\lambda_c$),\n   - $A_{3,3} = -\\lambda(\\text{I-135})$,\n   - $A_{4,3} = \\lambda(\\text{I-135})$,\n   - $A_{4,4} = -\\left(\\lambda(\\text{Xe-135}) + \\lambda_a(\\text{Xe-135})\\right)$,\n   - other entries are zero as per the simplified chain.\n4. Assemble $q$:\n   - $q_3 = Y \\cdot \\lambda_f \\cdot N_1(0)$ (constant over the step),\n   - all other components zero.\n5. Form the augmented matrix $\\mathcal{A}$ and augmented initial state $X(0)$, compute $X(h) = \\exp(\\mathcal{A} h) X(0)$ using a reliable matrix exponential routine, and extract $N(h)$.\n6. Check strict positivity: compute $m = \\min_i N_i(h)$, set $b = \\text{True}$ if all $N_i(h) > 0$. If $b = \\text{False}$, perform diagnostics:\n   - If $A$ is not Metzler, set $d = 1$.\n   - Else if $|m|$ is less than a round-off threshold (e.g., $10^{-12}$), set $d = 2$.\n   - Else set $d = 3$.\n7. Report $[b, m, d]$ for each scenario.\n\nScientific realism and units are enforced by using physically plausible fluxes, cross sections, half-lives, and yields. The chosen scenarios test:\n- A typical thermal reactor step (Scenario $1$),\n- An extremely stiff case with long step (Scenario $2$),\n- A decay-only boundary case with zero flux (Scenario $3$),\n- A diagnostic edge case with intentionally inconsistent off-diagonal (Scenario $4$) to validate detection of structural violations.\n\nThe final program aggregates the results for all scenarios into a single line matching the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef build_scenario(scenario_id):\n    # Common parameters\n    # Nuclide order: [U235, U236, I135, Xe135]\n    n = 4\n    ln2 = np.log(2.0)\n\n    if scenario_id == 1:\n        N0 = np.array([3.000e-4, 0.0, 0.0, 0.0])  # atoms/b-cm\n        phi = 3.000e14  # n/cm^2/s\n        sigma_f_U235 = 580.0  # barns\n        sigma_c_U235 = 100.0  # barns\n        sigma_a_Xe135 = 2.000e6  # barns\n        # Optional small absorption for I-135 is neglected in A assembly\n        lambda_I135 = ln2 / 23652.0  # 1/s\n        lambda_Xe135 = ln2 / 32904.0  # 1/s\n        Y_I135_from_U235_f = 0.062  # fraction per fission\n        h = 21600.0  # s\n\n    elif scenario_id == 2:\n        N0 = np.array([3.000e-4, 0.0, 0.0, 0.0])\n        phi = 1.000e15\n        sigma_f_U235 = 580.0\n        sigma_c_U235 = 100.0\n        sigma_a_Xe135 = 2.000e6\n        lambda_I135 = ln2 / 23652.0\n        lambda_Xe135 = ln2 / 32904.0\n        Y_I135_from_U235_f = 0.062\n        h = 3.600e6\n\n    elif scenario_id == 3:\n        N0 = np.array([1.000e-6, 0.0, 2.000e-6, 0.0])\n        phi = 0.0\n        sigma_f_U235 = 580.0\n        sigma_c_U235 = 100.0\n        sigma_a_Xe135 = 2.000e6\n        lambda_I135 = ln2 / 23652.0\n        lambda_Xe135 = ln2 / 32904.0\n        Y_I135_from_U235_f = 0.062\n        h = 86400.0\n\n    elif scenario_id == 4:\n        N0 = np.array([3.000e-4, 0.0, 0.0, 0.0])\n        phi = 3.000e14\n        sigma_f_U235 = 580.0\n        sigma_c_U235 = 100.0\n        sigma_a_Xe135 = 2.000e6\n        lambda_I135 = ln2 / 23652.0\n        lambda_Xe135 = ln2 / 32904.0\n        Y_I135_from_U235_f = 0.062\n        h = 3600.0\n    else:\n        raise ValueError(\"Unknown scenario\")\n\n    # Compute neutron-induced rates (1/s)\n    # barns to cm^2: 1 barn = 1e-24 cm^2\n    barn_to_cm2 = 1.0e-24\n    lambda_f_U235 = phi * sigma_f_U235 * barn_to_cm2\n    lambda_c_U235 = phi * sigma_c_U235 * barn_to_cm2\n    lambda_a_Xe135 = phi * sigma_a_Xe135 * barn_to_cm2\n\n    # Assemble A (4x4)\n    A = np.zeros((n, n), dtype=float)\n    # U-235 removal\n    A[0, 0] = -(lambda_f_U235 + lambda_c_U235)\n    # U-236 production from U-235 capture\n    A_capture = lambda_c_U235\n    if scenario_id == 4:\n        # Intentionally inconsistent sign to test diagnostic\n        A_capture = -lambda_c_U235\n    A[1, 0] = A_capture\n    # I-135 decay to Xe-135\n    A[2, 2] = -lambda_I135\n    A[3, 2] = lambda_I135\n    # Xe-135 removal by decay and absorption\n    A[3, 3] = -(lambda_Xe135 + lambda_a_Xe135)\n\n    # Assemble constant source q (4)\n    q = np.zeros(n, dtype=float)\n    q[2] = Y_I135_from_U235_f * lambda_f_U235 * N0[0]\n\n    return N0, A, q, h\n\ndef augmented_expm_step(N0, A, q, h):\n    # Build augmented matrix of size (n+1)x(n+1)\n    n = A.shape[0]\n    Aug = np.zeros((n + 1, n + 1), dtype=float)\n    Aug[:n, :n] = A\n    Aug[:n, n] = q\n    # Last row is zeros, last column already zero except Aug[:n, n] = q\n    X0 = np.concatenate([N0, np.array([1.0], dtype=float)])\n    Xh = expm(Aug * h) @ X0\n    Nh = Xh[:n]\n    return Nh\n\ndef check_metzler(A, tol=0.0):\n    n = A.shape[0]\n    for j in range(n):\n        for i in range(n):\n            if j != i and A[j, i] < -tol:\n                return False\n    return True\n\ndef stiffness_ratio(A):\n    # Use eigenvalues of A; ignore zero real parts in denominator\n    eigvals = np.linalg.eigvals(A)\n    reals = np.abs(np.real(eigvals))\n    max_real = np.max(reals)\n    # Find smallest positive nonzero real part\n    positive = reals[reals > 0.0]\n    if positive.size == 0:\n        return np.inf\n    min_real = np.min(positive)\n    if min_real == 0.0:\n        return np.inf\n    return float(max_real / min_real)\n\ndef diagnose(A, min_val, h):\n    # Diagnostic codes:\n    # 0: No violation\n    # 1: Not Metzler (negative off-diagonal)\n    # 2: Violation but near round-off (|min| < 1e-12)\n    # 3: Violation with Metzler and materially negative\n    if min_val > 0.0:\n        return 0\n    # Violation cases\n    if not check_metzler(A, tol=0.0):\n        return 1\n    if abs(min_val) < 1.0e-12:\n        return 2\n    return 3\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4]\n\n    results = []\n    for case_id in test_cases:\n        N0, A, q, h = build_scenario(case_id)\n        Nh = augmented_expm_step(N0, A, q, h)\n        min_val = float(np.min(Nh))\n        all_positive = bool(np.all(Nh > 0.0))\n        diag_code = diagnose(A, min_val, h)\n        # Append [boolean, min_value, diagnosis_code]\n        results.append([all_positive, min_val, diag_code])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and floats are printed in Python standard formatting.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, float):\n            return repr(item)\n        elif isinstance(item, int):\n            return str(item)\n        elif isinstance(item, list):\n            return \"[\" + \",\".join(format_item(x) for x in item) + \"]\"\n        else:\n            return str(item)\n\n    print(\"[\" + \",\".join(format_item(r) for r in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The most advanced reactor simulations must contend with depletion operators that change over time, making fixed-step methods either inaccurate or inefficient. This coding practice  delves into the crucial topic of adaptive time-stepping by having you implement a step-doubling error estimation scheme. By comparing a single-step solution against a more accurate two-half-step solution, you will estimate the local error and develop logic to accept or reject a step, and dynamically recommend a new, more appropriate step size.",
            "id": "4234758",
            "problem": "You are given a linear time-dependent nuclide depletion model formulated as an ordinary differential equation (ODE) for the vector of nuclide number densities. The model is\n$$\n\\frac{d\\mathbf{N}(t)}{dt} = \\mathbf{A}(t)\\,\\mathbf{N}(t),\n$$\nwhere $\\mathbf{N}(t) \\in \\mathbb{R}^3$ is the vector of nuclide number densities with components expressed in atoms per cubic centimeter (atoms/cm$^3$), and $\\mathbf{A}(t) \\in \\mathbb{R}^{3\\times 3}$ is the depletion operator with entries expressed in inverse seconds ($\\mathrm{s}^{-1}$). The operator varies linearly in time within each step, i.e.,\n$$\n\\mathbf{A}(t) = \\mathbf{A}_0 + (t - t_n)\\,\\mathbf{B},\n$$\nwhere $t_n$ is the step start time, $\\mathbf{A}_0 = \\mathbf{A}(t_n)$, and $\\mathbf{B} = \\frac{d\\mathbf{A}}{dt}\\bigg|_{t=t_n}$ is constant over the step.\n\nYou must implement a step-doubling procedure to estimate the local error introduced by freezing the operator over a time step. Consider a single step of size $\\Delta t$ starting at $t_n$, and define two propagations:\n\n1. A single full step with the operator frozen at the start of the step, producing $\\mathbf{N}_{\\mathrm{full}}$.\n2. Two half steps, where the first half uses the operator at $t_n$ and the second half updates the operator to the midpoint $t_n + \\tfrac{\\Delta t}{2}$, producing $\\mathbf{N}_{\\mathrm{half\\_2}}$.\n\nDefine the local error estimate as the componentwise difference $\\mathbf{e} = \\mathbf{N}_{\\mathrm{half\\_2}} - \\mathbf{N}_{\\mathrm{full}}$. Use a weighted infinity norm to produce a dimensionless scalar error measure,\n$$\n\\eta = \\max_i \\frac{|e_i|}{\\mathrm{atol} + \\mathrm{rtol}\\,|\\left(\\mathbf{N}_{\\mathrm{half\\_2}}\\right)_i|},\n$$\nwhere $\\mathrm{atol}$ is an absolute tolerance (atoms/cm$^3$) and $\\mathrm{rtol}$ is a relative tolerance (dimensionless). Accept the step if and only if $\\eta \\le 1$. Recommend a new step size\n$$\n\\Delta t_{\\mathrm{new}} = \\Delta t \\times \\operatorname{clip}\\left(s\\,\\eta^{-\\frac{1}{p+1}}, f_{\\min}, f_{\\max}\\right),\n$$\nwhere $p$ is the method order, $s$ is a safety factor, $f_{\\min}$ is a minimum growth/shrink factor, and $f_{\\max}$ is a maximum growth/shrink factor. In this problem take $p=1$, $s=0.9$, $f_{\\min}=0.2$, and $f_{\\max}=5.0$. Express the recommended next step size in seconds.\n\nThe test suite is defined by four cases. For all cases, take the initial time as $t_n = 0$, and the initial number densities as\n$$\n\\mathbf{N}_0 = \\begin{bmatrix} 3.0\\times 10^{20} \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\ \\text{atoms/cm}^3.\n$$\nDefine a simple transmutation/decay chain with three nuclides such that the operator has the structure\n$$\n\\mathbf{A}(t) = \\begin{bmatrix}\n-(\\lambda_{12} + r_1(t)) & 0 & 0 \\\\\n\\lambda_{12} + r_1(t) & -(\\lambda_{23} + r_2(t)) & 0 \\\\\n0 & \\lambda_{23} + r_2(t) & 0\n\\end{bmatrix},\n$$\nwith\n$$\nr_1(t) = r_{10} + \\beta_1 t,\\quad r_2(t) = r_{20} + \\beta_2 t,\n$$\nwhere $\\lambda_{12}$ and $\\lambda_{23}$ are decay rates (in $\\mathrm{s}^{-1}$), $r_{10}$ and $r_{20}$ are initial reaction rates (in $\\mathrm{s}^{-1}$), and $\\beta_1$ and $\\beta_2$ are their time derivatives (in $\\mathrm{s}^{-2}$). Then\n$$\n\\mathbf{A}_0 = \\mathbf{A}(t_n) = \\mathbf{A}(0),\\quad \\mathbf{B} = \\frac{d\\mathbf{A}}{dt}\\bigg|_{t=0} = \\begin{bmatrix}\n-\\beta_1 & 0 & 0 \\\\\n\\beta_1 & -\\beta_2 & 0 \\\\\n0 & \\beta_2 & 0\n\\end{bmatrix}.\n$$\n\nUse the following numerical values in each case:\n\n- Case $1$ (mild operator variation, happy path):\n  - $\\Delta t = 3600.0$ seconds,\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $r_{10} = 5.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $r_{20} = 1.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $\\beta_1 = 1.0\\times 10^{-12}\\ \\mathrm{s}^{-2}$,\n  - $\\beta_2 = 5.0\\times 10^{-13}\\ \\mathrm{s}^{-2}$,\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$,\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$.\n\n- Case $2$ (strong operator variation, likely rejection):\n  - $\\Delta t = 3600.0$ seconds,\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $r_{10} = 5.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $r_{20} = 1.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $\\beta_1 = 1.0\\times 10^{-10}\\ \\mathrm{s}^{-2}$,\n  - $\\beta_2 = 5.0\\times 10^{-11}\\ \\mathrm{s}^{-2}$,\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$,\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$.\n\n- Case $3$ (boundary-like scenario):\n  - $\\Delta t = 7200.0$ seconds,\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $r_{10} = 3.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $r_{20} = 0.5\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $\\beta_1 = 5.0\\times 10^{-12}\\ \\mathrm{s}^{-2}$,\n  - $\\beta_2 = 2.5\\times 10^{-12}\\ \\mathrm{s}^{-2}$,\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$,\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$.\n\n- Case $4$ (no operator variation, edge case):\n  - $\\Delta t = 3600.0$ seconds,\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n  - $r_{10} = 5.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $r_{20} = 1.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$,\n  - $\\beta_1 = 0.0\\ \\mathrm{s}^{-2}$,\n  - $\\beta_2 = 0.0\\ \\mathrm{s}^{-2}$,\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$,\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$.\n\nYour program must, for each case, construct $\\mathbf{A}_0$ and $\\mathbf{B}$, perform the one full step and the two half steps as described, compute the error measure $\\eta$, decide step acceptance, and compute the recommended next step size $\\Delta t_{\\mathrm{new}}$ in seconds. The final output for each case must be a list\n$$\n[\\text{accept},\\ \\Delta t_{\\mathrm{new}},\\ \\eta],\n$$\nwhere $\\text{accept}$ is a boolean indicating whether the step is accepted, $\\Delta t_{\\mathrm{new}}$ is a floating-point number in seconds, and $\\eta$ is a floating-point number. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$). All quantities are to be expressed as booleans or floating-point numbers as specified. All time-related quantities must be in seconds, and all density-related quantities must be in atoms/cm$^3$.",
            "solution": "The problem requires the implementation of an adaptive time-stepping algorithm based on a step-doubling error estimation procedure for a system of linear ordinary differential equations (ODEs) that models nuclide depletion. The core of the solution involves comparing a less accurate numerical propagation with a more accurate one to estimate the local error and adjust the step size accordingly.\n\nThe governing physical model is the nuclide depletion equation:\n$$\n\\frac{d\\mathbf{N}(t)}{dt} = \\mathbf{A}(t)\\,\\mathbf{N}(t)\n$$\nwhere $\\mathbf{N}(t)$ is the vector of nuclide number densities and $\\mathbf{A}(t)$ is the time-dependent depletion operator matrix. For this problem, the operator's time dependence is assumed to be linear within a single time step $[t_n, t_n + \\Delta t]$:\n$$\n\\mathbf{A}(t) = \\mathbf{A}(t_n) + (t - t_n)\\,\\mathbf{B} = \\mathbf{A}_0 + (t - t_n)\\,\\mathbf{B}\n$$\nwhere $\\mathbf{A}_0$ is the operator at the beginning of the step and $\\mathbf{B}$ is its constant time derivative over that step.\n\nThe fundamental numerical method used for propagation is based on approximating the operator $\\mathbf{A}(t)$ as constant over a given interval. The solution to the constant-coefficient ODE $\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}_{\\text{const}}\\mathbf{N}$ is $\\mathbf{N}(t_n+h) = e^{\\mathbf{A}_{\\text{const}}h}\\mathbf{N}(t_n)$, where $e^{(\\cdot)}$ denotes the matrix exponential. This problem uses a predictor-corrector-style approach to estimate the error introduced by this constant-coefficient approximation.\n\nThe error estimation is performed via a step-doubling (or embedded Runge-Kutta-like) procedure. Two different numerical solutions for the state at time $t_n + \\Delta t$ are computed:\n1.  **Full Step Solution ($\\mathbf{N}_{\\mathrm{full}}$)**: A single propagation over the full step duration $\\Delta t$ is performed, using the operator frozen at the start time $t_n$. This serves as the lower-order, less accurate solution.\n    $$\n    \\mathbf{N}_{\\mathrm{full}} = e^{\\mathbf{A}_0 \\Delta t} \\mathbf{N}(t_n)\n    $$\n2.  **Two Half-Steps Solution ($\\mathbf{N}_{\\mathrm{half\\_2}}$)**: The propagation is split into two steps of size $\\frac{\\Delta t}{2}$. The operator is re-evaluated at the midpoint, providing a more accurate representation of its time dependence. This serves as the higher-order, more accurate \"reference\" solution.\n    -   The first half-step propagates the solution from $t_n$ to $t_n + \\frac{\\Delta t}{2}$ using the operator at the start, $\\mathbf{A}_0 = \\mathbf{A}(t_n)$:\n        $$\n        \\mathbf{N}_{\\mathrm{half\\_1}} = e^{\\mathbf{A}_0 \\frac{\\Delta t}{2}} \\mathbf{N}(t_n)\n        $$\n    -   The second half-step propagates from $t_n + \\frac{\\Delta t}{2}$ to $t_n + \\Delta t$. For this step, the operator is updated to its value at the midpoint, $\\mathbf{A}_{\\mathrm{mid}} = \\mathbf{A}(t_n + \\frac{\\Delta t}{2}) = \\mathbf{A}_0 + \\mathbf{B}\\frac{\\Delta t}{2}$:\n        $$\n        \\mathbf{N}_{\\mathrm{half\\_2}} = e^{\\mathbf{A}_{\\mathrm{mid}} \\frac{\\Delta t}{2}} \\mathbf{N}_{\\mathrm{half\\_1}} = e^{(\\mathbf{A}_0 + \\frac{\\Delta t}{2}\\mathbf{B})\\frac{\\Delta t}{2}} e^{\\mathbf{A}_0 \\frac{\\Delta t}{2}} \\mathbf{N}(t_n)\n        $$\n\nThe difference between these two solutions, $\\mathbf{e} = \\mathbf{N}_{\\mathrm{half\\_2}} - \\mathbf{N}_{\\mathrm{full}}$, provides an estimate of the local error of the less accurate full-step method. To obtain a single dimensionless scalar error measure $\\eta$, a weighted infinity norm is used:\n$$\n\\eta = \\max_i \\frac{|e_i|}{\\mathrm{atol} + \\mathrm{rtol}\\,|\\left(\\mathbf{N}_{\\mathrm{half\\_2}}\\right)_i|}\n$$\nwhere $\\mathrm{atol}$ and $\\mathrm{rtol}$ are user-defined absolute and relative tolerances, respectively. The step is deemed acceptable if this normalized error is less than or equal to $1$, i.e., $\\eta \\le 1$.\n\nBased on the value of $\\eta$, a new step size for the next integration step is recommended using the standard formula for adaptive step size control:\n$$\n\\Delta t_{\\mathrm{new}} = \\Delta t \\times \\operatorname{clip}\\left(s\\,\\eta^{-\\frac{1}{p+1}}, f_{\\min}, f_{\\max}\\right)\n$$\nThe parameters are given as the safety factor $s=0.9$, the minimum and maximum step size change factors $f_{\\min}=0.2$ and $f_{\\max}=5.0$, and the method order $p=1$. The order $p=1$ is appropriate because the underlying full-step method is a first-order approximation (analogous to Forward Euler in its treatment of the operator's time dependence).\n\nThe implementation proceeds by first constructing the matrices $\\mathbf{A}_0$ and $\\mathbf{B}$ for each test case from the provided parameters $\\lambda_{12}, \\lambda_{23}, r_{10}, r_{20}, \\beta_1, \\beta_2$. The initial density vector $\\mathbf{N}_0$ is constant for all cases. The matrix exponential operations are performed using the `scipy.linalg.expm` function. The two propagation paths are calculated, followed by the computation of the error vector $\\mathbf{e}$ and the scalar measure $\\eta$. A special check is included for the case where $\\eta$ is numerically zero (as in Case 4 where $\\mathbf{B}=\\mathbf{0}$), in which case the step size growth is limited by $f_{\\max}$ to prevent division by zero and ensure a maximal, but bounded, step increase. Finally, the acceptance boolean, the new step size $\\Delta t_{\\mathrm{new}}$, and the error measure $\\eta$ are compiled for each case and formatted into the required output structure.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the test cases and printing of results.\n    \"\"\"\n\n    def _calculate_step_result(params):\n        \"\"\"\n        Performs the step-doubling error estimation for a single case.\n\n        Args:\n            params (tuple): A tuple containing the parameters for a single test case.\n\n        Returns:\n            list: A list containing [accept, dt_new, eta].\n        \"\"\"\n        dt, lambda12, lambda23, r10, r20, beta1, beta2, rtol, atol = params\n        \n        # Fixed parameters from problem statement\n        N0 = np.array([3.0e20, 0.0, 0.0])\n        p = 1.0      # Method order\n        s = 0.9      # Safety factor\n        f_min = 0.2  # Minimum growth/shrink factor\n        f_max = 5.0  # Maximum growth/shrink factor\n\n        # Construct the operator matrix at t=t_n=0 (A0) and its time derivative (B)\n        A0 = np.array([\n            [-(lambda12 + r10), 0, 0],\n            [  lambda12 + r10, -(lambda23 + r20), 0],\n            [  0,               lambda23 + r20,  0]\n        ])\n        \n        B = np.array([\n            [-beta1,    0, 0],\n            [ beta1, -beta2, 0],\n            [     0,  beta2, 0]\n        ])\n\n        # 1. Full step propagation: Propagate from t_n to t_n + dt using A0\n        M_full = A0 * dt\n        N_full = expm(M_full) @ N0\n\n        # 2. Two half-steps propagation\n        dt_half = dt / 2.0\n        \n        # First half-step: Propagate from t_n to t_n + dt/2 using A0\n        M_half1 = A0 * dt_half\n        N_half_1 = expm(M_half1) @ N0\n\n        # Second half-step: Propagate from t_n + dt/2 to t_n + dt using A(t_n + dt/2)\n        A_mid = A0 + B * dt_half\n        M_half2 = A_mid * dt_half\n        N_half_2 = expm(M_half2) @ N_half_1\n\n        # 3. Compute the scalar error measure, eta\n        error_vec = N_half_2 - N_full\n        \n        # Denominator for the weighted norm: atol + rtol * |(N_half_2)_i|\n        tolerance_vec = atol + rtol * np.abs(N_half_2)\n\n        # Calculate eta = max_i (|e_i| / tolerance_i)\n        # Add a small float to the denominator for numerical stability, though atol > 0 should suffice.\n        eta_vec = np.abs(error_vec) / (tolerance_vec + np.finfo(float).tiny)\n        eta = np.max(eta_vec)\n\n        # 4. Decide step acceptance and recommend new step size\n        accept = eta <= 1.0\n        \n        # Handle the case where eta is zero or very close to it to avoid division by zero\n        # and to correctly apply the maximum step size growth factor. A small\n        # floating point tolerance is appropriate.\n        if eta < 1e-15:\n            factor = f_max\n        else:\n            # The method order p is 1. The formula is s * eta**(-1/(p+1)).\n            factor = s * (eta ** (-1.0 / (p + 1.0)))\n            factor = np.clip(factor, f_min, f_max)\n        \n        dt_new = dt * factor\n        \n        # Return a standard Python bool for consistent string formatting\n        return [bool(accept), dt_new, eta]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mild operator variation, happy path)\n        (3600.0, 1.0e-6, 2.0e-6, 5.0e-8, 1.0e-8, 1.0e-12, 5.0e-13, 1.0e-8, 1.0e10),\n        # Case 2 (strong operator variation, likely rejection)\n        (3600.0, 1.0e-6, 2.0e-6, 5.0e-8, 1.0e-8, 1.0e-10, 5.0e-11, 1.0e-8, 1.0e10),\n        # Case 3 (boundary-like scenario)\n        (7200.0, 1.0e-6, 2.0e-6, 3.0e-8, 0.5e-8, 5.0e-12, 2.5e-12, 1.0e-8, 1.0e10),\n        # Case 4 (no operator variation, edge case)\n        (3600.0, 1.0e-6, 2.0e-6, 5.0e-8, 1.0e-8, 0.0, 0.0, 1.0e-8, 1.0e10),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = _calculate_step_result(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list in Python is '[item1, item2, ...]',\n    # which preserves the required spaces and boolean capitalization.\n    # The overall format will be [[res1], [res2], ...].\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}