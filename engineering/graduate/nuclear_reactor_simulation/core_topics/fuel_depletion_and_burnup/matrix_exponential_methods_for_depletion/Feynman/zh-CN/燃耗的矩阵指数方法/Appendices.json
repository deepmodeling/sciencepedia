{
    "hands_on_practices": [
        {
            "introduction": "掌握任何数值方法的第一步，都是用一个已知精确解的问题来检验它。本练习将通过一个简单的双核素衰变链来验证矩阵指数公式的正确性。通过将其结果与从标量常微分方程（ODEs）直接推导出的解进行比较，这项练习  旨在加深你对状态转移矩阵理论基础的理解。",
            "id": "4234748",
            "problem": "在一个均匀零通量栅元中，考虑一个双核素链，其中核素 $1$ 以衰变常数 $\\lambda_{1} > 0$ 衰变为核素 $2$，核素 $2$ 以衰变常数 $\\lambda_{2} > 0$ 衰变为一个稳定的吸收体。不存在其他反应或源。设核素清单向量为 $n(t) = \\begin{pmatrix} n_{1}(t) \\\\ n_{2}(t) \\end{pmatrix}$，初始条件为 $n(0) = \\begin{pmatrix} n_{1,0} \\\\ n_{2,0} \\end{pmatrix}$。燃耗方程是线性的、时不变的，可以写成 $\\frac{d}{dt} n(t) = A n(t)$ 的形式，其中 $A$ 是一个常数矩阵。假设 $\\lambda_{1} \\neq \\lambda_{2}$。\n\n仅使用基本放射性衰变定律和作为线性时不变系统解算子的矩阵指数的定义，执行以下操作：\n\n- 根据物理描述确定系统矩阵 $A$。\n- 从标量常微分方程（ODE）出发，推导 $n_{2}(\\Delta t)$ 关于 $n_{1,0}$、$n_{2,0}$、$\\lambda_{1}$、$\\lambda_{2}$ 和 $\\Delta t$ 的闭式表达式。\n- 独立地，从状态转移矩阵 $\\Phi(t) = \\exp(A t)$ 作为 $\\frac{d}{dt}\\Phi(t) = A \\Phi(t)$ 且 $\\Phi(0) = I$ 的唯一解的定义出发，确定 $\\exp(A \\Delta t)$ 的 (2,1) 元。\n- 验证将 $\\exp(A \\Delta t)$ 应用于 $n(0)$ 可以再现任意 $n_{1,0}$ 和 $n_{2,0}$ 下的 $n_{2}(\\Delta t)$ 闭式解。\n\n请提供 $\\exp(A \\Delta t)$ 的 (2,1) 元的符号表达式作为最终答案。不需要进行数值计算，也不需要报告单位。答案应该是一个单一的闭式解析表达式。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、适定的，并且没有矛盾或歧义。它代表了核工程和数学物理中的一个标准问题。因此，我们可以进行完整求解。\n\n该问题要求对一个双核素放射性衰变链进行多步推导和验证。设 $n_1(t)$ 和 $n_2(t)$ 分别为时刻 $t$ 时核素1和核素2的浓度。\n\n**1. 确定系统矩阵 $A$**\n\n物理过程是衰变链 $1 \\rightarrow 2 \\rightarrow \\text{稳定}$。\n核素1的浓度 $n_1(t)$ 的变化率仅由其自身的放射性衰变决定。衰变速率与其浓度成正比，衰变常数为 $\\lambda_1$。\n$$ \\frac{d n_1(t)}{dt} = -\\lambda_1 n_1(t) $$\n核素2的浓度 $n_2(t)$ 的变化率有两个贡献：一个来自核素1衰变的源项，一个来自其自身衰变的损耗项。来自核素1的生成率为 $\\lambda_1 n_1(t)$，损耗率为 $\\lambda_2 n_2(t)$。\n$$ \\frac{d n_2(t)}{dt} = \\lambda_1 n_1(t) - \\lambda_2 n_2(t) $$\n这两个耦合的一阶线性常微分方程可以用矩阵形式表示为 $\\frac{d}{dt} n(t) = A n(t)$：\n$$ \\frac{d}{dt} \\begin{pmatrix} n_1(t) \\\\ n_2(t) \\end{pmatrix} = \\begin{pmatrix} -\\lambda_1 & 0 \\\\ \\lambda_1 & -\\lambda_2 \\end{pmatrix} \\begin{pmatrix} n_1(t) \\\\ n_2(t) \\end{pmatrix} $$\n通过观察，系统矩阵 $A$ 为：\n$$ A = \\begin{pmatrix} -\\lambda_1 & 0 \\\\ \\lambda_1 & -\\lambda_2 \\end{pmatrix} $$\n\n**2. 从标量常微分方程推导 $n_2(\\Delta t)$**\n\n首先，我们求解带有初始条件 $n_1(0) = n_{1,0}$ 的关于 $n_1(t)$ 的常微分方程：\n$$ \\frac{dn_1}{dt} = -\\lambda_1 n_1(t) \\implies n_1(t) = n_{1,0} \\exp(-\\lambda_1 t) $$\n接下来，我们将此解代入关于 $n_2(t)$ 的常微分方程中：\n$$ \\frac{dn_2}{dt} = \\lambda_1 n_{1,0} \\exp(-\\lambda_1 t) - \\lambda_2 n_2(t) $$\n这可以重写为一个标准的一阶线性常微分方程：\n$$ \\frac{dn_2}{dt} + \\lambda_2 n_2(t) = \\lambda_1 n_{1,0} \\exp(-\\lambda_1 t) $$\n我们使用积分因子 $\\mu(t) = \\exp\\left(\\int \\lambda_2 dt\\right) = \\exp(\\lambda_2 t)$ 来求解。将方程两边乘以 $\\mu(t)$：\n$$ \\exp(\\lambda_2 t) \\frac{dn_2}{dt} + \\lambda_2 \\exp(\\lambda_2 t) n_2(t) = \\lambda_1 n_{1,0} \\exp((\\lambda_2 - \\lambda_1)t) $$\n左边是乘积 $n_2(t)\\mu(t)$ 的导数：\n$$ \\frac{d}{dt} \\left( n_2(t) \\exp(\\lambda_2 t) \\right) = \\lambda_1 n_{1,0} \\exp((\\lambda_2 - \\lambda_1)t) $$\n将两边从 $0$ 到 $t$ 积分：\n$$ \\int_0^t \\frac{d}{d\\tau} \\left( n_2(\\tau) \\exp(\\lambda_2 \\tau) \\right) d\\tau = \\int_0^t \\lambda_1 n_{1,0} \\exp((\\lambda_2 - \\lambda_1)\\tau) d\\tau $$\n$$ \\left[ n_2(\\tau) \\exp(\\lambda_2 \\tau) \\right]_0^t = \\lambda_1 n_{1,0} \\left[ \\frac{\\exp((\\lambda_2 - \\lambda_1)\\tau)}{\\lambda_2 - \\lambda_1} \\right]_0^t $$\n这一步是有效的，因为题目说明了 $\\lambda_1 \\neq \\lambda_2$。\n$$ n_2(t) \\exp(\\lambda_2 t) - n_2(0) \\exp(0) = \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp((\\lambda_2 - \\lambda_1)t) - 1 \\right) $$\n使用初始条件 $n_2(0) = n_{2,0}$：\n$$ n_2(t) \\exp(\\lambda_2 t) = n_{2,0} + \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp(\\lambda_2 t)\\exp(-\\lambda_1 t) - 1 \\right) $$\n两边乘以 $\\exp(-\\lambda_2 t)$ 以分离出 $n_2(t)$：\n$$ n_2(t) = n_{2,0} \\exp(-\\lambda_2 t) + \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp(-\\lambda_1 t) - \\exp(-\\lambda_2 t) \\right) $$\n最后，在时间 $t = \\Delta t$ 处求值：\n$$ n_2(\\Delta t) = n_{2,0} \\exp(-\\lambda_2 \\Delta t) + \\frac{\\lambda_1 n_{1,0}}{\\lambda_2 - \\lambda_1} \\left( \\exp(-\\lambda_1 \\Delta t) - \\exp(-\\lambda_2 \\Delta t) \\right) $$\n\n**3. 确定 $\\exp(A \\Delta t)$ 的 (2,1) 元**\n\n设 $\\Phi(t) = \\exp(A t)$ 为状态转移矩阵。它是矩阵微分方程 $\\frac{d}{dt}\\Phi(t) = A \\Phi(t)$ 在初始条件 $\\Phi(0) = I$（单位矩阵）下的唯一解。设 $\\Phi(t) = \\begin{pmatrix} \\Phi_{11}(t) & \\Phi_{12}(t) \\\\ \\Phi_{21}(t) & \\Phi_{22}(t) \\end{pmatrix}$。\n该矩阵方程展开为关于 $\\Phi(t)$ 各元素的常微分方程组：\n$$ \\frac{d}{dt} \\begin{pmatrix} \\Phi_{11} & \\Phi_{12} \\\\ \\Phi_{21} & \\Phi_{22} \\end{pmatrix} = \\begin{pmatrix} -\\lambda_1 & 0 \\\\ \\lambda_1 & -\\lambda_2 \\end{pmatrix} \\begin{pmatrix} \\Phi_{11} & \\Phi_{12} \\\\ \\Phi_{21} & \\Phi_{22} \\end{pmatrix} = \\begin{pmatrix} -\\lambda_1 \\Phi_{11} & -\\lambda_1 \\Phi_{12} \\\\ \\lambda_1 \\Phi_{11} - \\lambda_2 \\Phi_{21} & \\lambda_1 \\Phi_{12} - \\lambda_2 \\Phi_{22} \\end{pmatrix} $$\n初始条件为 $\\Phi_{11}(0) = 1$，$\\Phi_{12}(0) = 0$，$\\Phi_{21}(0) = 0$ 和 $\\Phi_{22}(0) = 1$。\n为求 (2,1) 元 $\\Phi_{21}(t)$，我们必须求解常微分方程：\n$$ \\frac{d\\Phi_{21}}{dt} = \\lambda_1 \\Phi_{11}(t) - \\lambda_2 \\Phi_{21}(t) $$\n这需要先求出 $\\Phi_{11}(t)$。从矩阵方程组可知，其常微分方程为 $\\frac{d\\Phi_{11}}{dt} = -\\lambda_1 \\Phi_{11}$，初始条件为 $\\Phi_{11}(0)=1$。其解为 $\\Phi_{11}(t) = \\exp(-\\lambda_1 t)$。\n将此解代入 $\\Phi_{21}(t)$ 的方程中：\n$$ \\frac{d\\Phi_{21}}{dt} + \\lambda_2 \\Phi_{21}(t) = \\lambda_1 \\exp(-\\lambda_1 t) $$\n这是一个初始条件为 $\\Phi_{21}(0) = 0$ 的一阶线性常微分方程。此方程的形式与 $n_2(t)$ 的方程相同，只是将 $n_{1,0}$ 替换为 1，将 $n_{2,0}$ 替换为 0。使用相同的积分因子法，或直接代入前面推导的通解形式：\n$$ \\Phi_{21}(t) = 0 \\cdot \\exp(-\\lambda_2 t) + \\frac{\\lambda_1 \\cdot 1}{\\lambda_2 - \\lambda_1} \\left( \\exp(-\\lambda_1 t) - \\exp(-\\lambda_2 t) \\right) $$\n$$ \\Phi_{21}(t) = \\frac{\\lambda_1}{\\lambda_2 - \\lambda_1} \\left(\\exp(-\\lambda_1 t) - \\exp(-\\lambda_2 t)\\right) $$\n因此，$\\exp(A \\Delta t)$ 的 (2,1) 元为：\n$$ (\\exp(A \\Delta t))_{2,1} = \\Phi_{21}(\\Delta t) = \\frac{\\lambda_1}{\\lambda_2 - \\lambda_1} \\left(\\exp(-\\lambda_1 \\Delta t) - \\exp(-\\lambda_2 \\Delta t)\\right) $$\n\n**4. 验证**\n\n系统的解由 $n(\\Delta t) = \\exp(A \\Delta t) n(0)$ 给出。我们关注这个向量方程的第二个分量：\n$$ n_2(\\Delta t) = (\\exp(A \\Delta t))_{2,1} n_{1,0} + (\\exp(A \\Delta t))_{2,2} n_{2,0} $$\n我们已经求出了 $(\\exp(A \\Delta t))_{2,1}$。现在我们来求 $(\\exp(A \\Delta t))_{2,2} = \\Phi_{22}(\\Delta t)$。其常微分方程为 $\\frac{d\\Phi_{22}}{dt} = \\lambda_1 \\Phi_{12} - \\lambda_2 \\Phi_{22}$，初始条件为 $\\Phi_{22}(0)=1$。首先，我们需要 $\\Phi_{12}(t)$。其常微分方程为 $\\frac{d\\Phi_{12}}{dt} = -\\lambda_1 \\Phi_{12}$，初始条件为 $\\Phi_{12}(0)=0$。唯一的解是 $\\Phi_{12}(t)=0$。\n$\\Phi_{22}$ 的常微分方程简化为 $\\frac{d\\Phi_{22}}{dt} = -\\lambda_2 \\Phi_{22}$，初始条件为 $\\Phi_{22}(0)=1$。其解为 $\\Phi_{22}(t)=\\exp(-\\lambda_2 t)$。\n将 $\\Phi_{21}(\\Delta t)$ 和 $\\Phi_{22}(\\Delta t)$ 的表达式代入 $n_2(\\Delta t)$ 的方程中：\n$$ n_2(\\Delta t) = \\left( \\frac{\\lambda_1}{\\lambda_2 - \\lambda_1} \\left(\\exp(-\\lambda_1 \\Delta t) - \\exp(-\\lambda_2 \\Delta t)\\right) \\right) n_{1,0} + \\left( \\exp(-\\lambda_2 \\Delta t) \\right) n_{2,0} $$\n这个表达式与第2部分通过求解标量常微分方程推导出的表达式完全相同。结果是一致的，从而验证了计算。矩阵指数的 (2,1) 元正确地表示了核素1的初始浓度对核素2最终浓度的贡献。",
            "answer": "$$\\boxed{\\frac{\\lambda_{1}}{\\lambda_{2} - \\lambda_{1}} (\\exp(-\\lambda_{1} \\Delta t) - \\exp(-\\lambda_{2} \\Delta t))}$$"
        },
        {
            "introduction": "在从理论转向实践的过程中，真实的损耗问题通常包含外部源项，并涉及大型、刚性矩阵。本练习  将演示如何使用矩阵增广技术处理非齐次系统。更重要的是，它将教你如何实施关键的物理现实性检查（如核素密度的正定性），并诊断可能违反这些物理约束的数值伪影。",
            "id": "4234763",
            "problem": "考虑核反应堆模拟中的一个燃耗步，该燃耗步被建模为单个时间区间上的线性分段常数系统。令核素数密度向量表示为 $N(t) \\in \\mathbb{R}^n$（包含 $n$ 种核素），并假设在该区间内中子通量 $\\phi$ 为常数。控制方程为线性非齐次系统\n$$\n\\frac{d}{dt} N(t) = A N(t) + q,\n$$\n其中 $A \\in \\mathbb{R}^{n \\times n}$ 是由衰变常数和中子诱发反应率构成的燃耗/嬗变矩阵，$q \\in \\mathbb{R}^n$ 是一个常数源项（例如，来自在该步长内被视为常数的裂变产额）。假设所有量在长度为 $h$ 的时间区间内都是恒定的，因此在时间 $t+h$ 的精确解是良定义的。核素数密度的单位是原子数/靶恩-厘米 ($\\text{atoms}/\\text{b}\\text{-}\\text{cm}$)，通量 $\\phi$ 的单位是中子数/平方厘米/秒 ($\\text{n}/\\text{cm}^2/\\text{s}$)，截面的单位是靶恩，时间的单位是秒。\n\n基本原理：\n- 线性一阶常微分方程以及通过矩阵指数求解常系数系统精确解的方法。\n- 核素平衡：对于每种核素 $i$，对角线元素 $A_{ii}$ 是其所有移除率之和的负值，而非对角线元素 $A_{ji}$（其中 $j \\neq i$）是从 $i$ 到 $j$ 的非负转移率（当物理上一致时）。\n- 对于一个衰变常数为 $\\lambda_i$ 的衰变过程，若其以分支比 $\\beta_{i \\to j}$ 产生子核 $j$，则生成率贡献为 $A_{j i} = \\beta_{i \\to j} \\lambda_i$，移除率贡献为 $A_{i i} = -\\lambda_i$。对于在通量 $\\phi$ 下，微观截面为 $\\sigma_i$ 的核素 $i$ 发生的中子吸收，其移除率为 $\\lambda^{(n)}_i = \\phi \\sigma_i \\times 10^{-24}$ (单位 $\\text{s}^{-1}$)，任何被追踪的嬗变产额 $y_{i \\to j}$ 会贡献 $A_{j i} = y_{i \\to j} \\lambda^{(n)}_i$。可以包含一个常数源 $q_j$ 来表示（例如）在该步长内被视为常数的裂变产额。\n\n任务：\n1. 使用矩阵指数法，通过增广系统以消除非齐次项，为每个给定场景精确计算 $N(t+h)$。引入一个 $n+1$ 维的增广状态 $X(t) = \\begin{bmatrix} N(t) \\\\ 1 \\end{bmatrix}$，使得\n$$\n\\frac{d}{dt} X(t) = \\begin{bmatrix} A & q \\\\ 0\\cdot\\mathbf{1}^\\top & 0 \\end{bmatrix} X(t),\n$$\n其中 $0\\cdot\\mathbf{1}^\\top$ 表示长度为 $n$ 的零行向量。于是\n$$\nX(t+h) = \\exp\\!\\left(\\begin{bmatrix} A & q \\\\ 0 & 0 \\end{bmatrix} h\\right) X(t), \\quad \\text{并且} \\quad N(t+h) = \\left[ X(t+h) \\right]_{1:n}.\n$$\n2. 对计算出的密度 $N(t+h)$ 执行严格正性检查：确定每个分量是否严格大于 $0$，不设容差。\n3. 如果有任何分量不严格大于 $0$，通过报告最小分量值来记录此违规，并使用以下指标诊断可能的数值原因：\n   - 检查 $A$ 是否为 Metzler 矩阵，即对于 $j \\ne i$ 是否有 $A_{j i} \\ge 0$。若不满足，则表明模型结构不一致，无法生成正半群。\n   - 通过比率估算刚度\n     $$\n     S = \\frac{\\max_i |\\Re(\\lambda_i(A))|}{\\min_{i: |\\Re(\\lambda_i(A))| > 0} |\\Re(\\lambda_i(A))|},\n     $$\n     其中 $\\lambda_i(A)$ 是 $A$ 的特征值。极大的 $S$ 值与大的 $h$ 相结合，表明计算矩阵指数时可能存在舍入误差放大。\n   - 报告负值的大小是处于机器精度量级还是显著为负。\n4. 对于每个测试场景，输出一个三元组 $[b, m, d]$，其中 $b$ 是一个布尔值，表示 $N(t+h)$ 的所有分量是否都严格为正；$m$ 是 $N(t+h)$ 的最小分量（一个浮点数）；$d$ 是一个整型诊断代码，定义如下：\n   - $0$：未发生违规（所有分量严格为正）。\n   - $1$：矩阵不是 Metzler 矩阵（检测到负的非对角线元素）。\n   - $2$：发生违规，但最小值的绝对值接近机器精度（解释为极端刚度下的舍入误差）。\n   - $3$：在 Metzler 矩阵下发生违规，且数值大小显著为负（解释为由于步长和病态条件导致的误差放大）。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个场景的三元组本身也用方括号括起来并用逗号分隔，例如：$[ [b_1,m_1,d_1],[b_2,m_2,d_2],\\ldots ]$。\n\n测试套件：\n使用以下四个场景。所有密度单位应为 $\\text{atoms}/\\text{b}\\text{-}\\text{cm}$，所有时间单位应为 $\\text{s}$。对于所有场景，核素排序为 $[\\text{U}\\text{-}235, \\text{U}\\text{-}236, \\text{I}\\text{-}135, \\text{Xe}\\text{-}135]$。\n\n- 场景 1（基准热中子通量，中等步长）：\n  - 初始密度：$N(0) = [3.000 \\times 10^{-4}, 0.000, 0.000, 0.000]$。\n  - 通量：$\\phi = 3.000 \\times 10^{14}$。\n  - 截面（靶恩）：$\\sigma_f(\\text{U}\\text{-}235) = 580.0$，$\\sigma_c(\\text{U}\\text{-}235) = 100.0$，$\\sigma_a(\\text{Xe}\\text{-}135) = 2.000 \\times 10^{6}$，$\\sigma_a(\\text{I}\\text{-}135) = 6.0$。\n  - 衰变常数：$\\lambda(\\text{I}\\text{-}135) = \\ln(2)/23652.0$，$\\lambda(\\text{Xe}\\text{-}135) = \\ln(2)/32904.0$。\n  - 裂变产额：$Y(\\text{I}\\text{-}135 \\leftarrow \\text{U}\\text{-}235\\ \\text{fission}) = 0.062$。\n  - 步长：$h = 21600.0$。\n\n- 场景 2（极端刚度，长步长）：\n  - 初始密度：$N(0) = [3.000 \\times 10^{-4}, 0.000, 0.000, 0.000]$。\n  - 通量：$\\phi = 1.000 \\times 10^{15}$。\n  - 截面（靶恩）：与场景 1 相同。\n  - 衰变常数：与场景 1 相同。\n  - 裂变产额：与场景 1 相同。\n  - 步长：$h = 3.600 \\times 10^{6}$。\n\n- 场景 3（仅衰变，零通量边界情况）：\n  - 初始密度：$N(0) = [1.000 \\times 10^{-6}, 0.000, 2.000 \\times 10^{-6}, 0.000]$。\n  - 通量：$\\phi = 0.0$。\n  - 截面（靶恩）：与场景 1 相同。\n  - 衰变常数：与场景 1 相同。\n  - 裂变产额：$Y(\\text{I}\\text{-}135 \\leftarrow \\text{U}\\text{-}235\\ \\text{fission}) = 0.062$（因通量为零而未使用）。\n  - 步长：$h = 86400.0$。\n\n- 场景 4（具有不一致非对角线元素的诊断边缘案例）：\n  - 初始密度：$N(0) = [3.000 \\times 10^{-4}, 0.000, 0.000, 0.000]$。\n  - 通量：$\\phi = 3.000 \\times 10^{14}$。\n  - 截面（靶恩）：与场景 1 相同。\n  - 衰变常数：与场景 1 相同。\n  - 裂变产额：与场景 1 相同。\n  - 步长：$h = 3600.0$。\n  - 修改：将 $\\text{U}\\text{-}235 \\to \\text{U}\\text{-}236$ 俘获转移的符号反转，使得 $A_{2,1} = -\\lambda^{(n)}_{\\text{U}\\text{-}235,\\text{capture}}$，从而产生一个负的非对角线元素（这是故意设置的不一致性，仅用于测试诊断功能）。\n\n所有场景的组装细节：\n- 计算 $\\lambda^{(n)}_{\\text{U}\\text{-}235,\\text{fission}} = \\phi \\sigma_f(\\text{U}\\text{-}235) \\times 10^{-24}$ 和 $\\lambda^{(n)}_{\\text{U}\\text{-}235,\\text{capture}} = \\phi \\sigma_c(\\text{U}\\text{-}235) \\times 10^{-24}$。\n- $\\text{U}\\text{-}235$ 上的移除：$A_{1,1} = -\\left(\\lambda^{(n)}_{\\text{U}\\text{-}235,\\text{fission}} + \\lambda^{(n)}_{\\text{U}\\text{-}235,\\text{capture}}\\right)$。\n- 向 $\\text{U}\\text{-}236$ 的俘获转移：$A_{2,1} = +\\lambda^{(n)}_{\\text{U}\\text{-}235,\\text{capture}}$，场景 4 除外，其中 $A_{2,1}$ 被取反。\n- 向 $\\text{I}\\text{-}135$ 的裂变产额源：$q_3 = Y \\cdot \\lambda^{(n)}_{\\text{U}\\text{-}235,\\text{fission}} \\cdot N_1(0)$。\n- $\\text{I}\\text{-}135$ 衰变为 $\\text{Xe}\\text{-}135$：$A_{4,3} = \\lambda(\\text{I}\\text{-}135)$ 且 $A_{3,3} = -\\lambda(\\text{I}\\text{-}135)$。\n- $\\text{Xe}\\text{-}135$ 的移除：$A_{4,4} = -\\left(\\lambda(\\text{Xe}\\text{-}135) + \\phi \\sigma_a(\\text{Xe}\\text{-}135) \\times 10^{-24}\\right)$。\n- $\\text{I}\\text{-}135$ 的吸收在生成项中被忽略，如果需要，仅在移除项中包含；对于本测试，按上述方式设置 $A_{3,3}$，不包含中子吸收贡献，以简化衰变链。\n\n你的程序必须：\n- 精确实现增广矩阵指数法来计算 $N(t+h)$。\n- 对于每个场景，根据上述规则计算严格正性的布尔结果、$N(t+h)$ 的最小分量值（单位为 $\\text{atoms}/\\text{b}\\text{-}\\text{cm}$）以及诊断代码。\n- 按照前面描述的格式，生成包含四个场景结果列表的单行输出，数值以标准十进制表示法打印。",
            "solution": "在具有恒定系数的单个步长内，控制燃耗过程的方程是线性的、分段恒定的。从线性系统的基本定律出发，\n$$\n\\frac{d}{dt} N(t) = A N(t) + q,\n$$\n当 $A \\in \\mathbb{R}^{n \\times n}$ 为常数且 $q \\in \\mathbb{R}^n$ 在该区间上为常数时，精确解可从线性常微分方程理论中得出。具体来说，齐次解由矩阵指数决定，\n$$\nN_{\\text{hom}}(t+h) = \\exp(A h) \\, N(t),\n$$\n而完整解通过常数变易法将强迫项包含进来，\n$$\nN(t+h) = \\exp(A h)\\, N(t) + \\int_0^h \\exp(A \\tau) \\, q \\, d\\tau.\n$$\n当 $A$ 可逆时，该积分可以写成 $A^{-1}(\\exp(A h) - I)q$，但当 $A$ 是奇异或接近奇异时，这种方法并不稳健。一种有原则且数值稳定的方法是通过用一个常数分量来增广状态，将非齐次系统转换为一个 $n+1$ 维的齐次系统。定义增广状态\n$$\nX(t) = \\begin{bmatrix} N(t) \\\\ 1 \\end{bmatrix},\n$$\n以及增广系统矩阵\n$$\n\\mathcal{A} = \\begin{bmatrix} A & q \\\\ 0\\cdot\\mathbf{1}^\\top & 0 \\end{bmatrix}.\n$$\n那么\n$$\n\\frac{d}{dt} X(t) = \\mathcal{A} X(t),\n$$\n其精确解为\n$$\nX(t+h) = \\exp(\\mathcal{A} h)\\, X(t).\n$$\n$X(t+h)$ 的前 $n$ 个分量精确地给出了 $N(t+h)$。这种变换基于线性系统理论中经过充分检验的事实，避免了显式求逆 $A$ 或计算积分的需要，同时保持在矩阵指数法的框架内。\n\n$A$ 和 $q$ 的组装利用了核素平衡的物理原理。对于核素 $i$，移除率作为负项贡献给 $A_{ii}$，而向子核的转移则贡献给非对角线元素。每个核素的中子诱发反应率由通量和截面在一致单位下的乘积给出：当截面单位为靶恩，通量单位为 $\\text{n}/\\text{cm}^2/\\text{s}$ 时，每个原子的移除率为 $\\lambda^{(n)} = \\phi \\sigma \\times 10^{-24}$ (单位 $\\text{s}^{-1}$)。对于衰变过程，移除贡献为 $-\\lambda$，而以分支比 $\\beta$ 向子核的转移则在相应的非对角线元素上贡献 $\\beta \\lambda$。\n\n正性考量源于 $A$ 的结构。如果 $A$ 是一个 Metzler 矩阵（所有非对角线元素均为非负），并且系统在生成项非负的意义上是守恒的，那么矩阵指数 $\\exp(A t)$ 会生成一个正半群，并在非负初始条件和非负输入下保持状态的非负性。在这种情况下，对于严格正的初始条件，精确解是严格正的（除非源项贡献可能为零）。然而，$\\exp(\\mathcal{A} h)$ 的数值计算可能会因为浮点舍入误差或刚度下的误差放大而引入微小的负分量。\n\n为了诊断违规，我们检查：\n- $A$ 的 Metzler 属性：验证对于 $j \\ne i$ 是否有 $A_{j i} \\ge 0$。如果不满足，则模型结构本身就破坏了正性，任何观察到的负值都不是由数值计算引起的，而是由不一致的耦合造成的。\n- 刚度比，\n$$\nS = \\frac{\\max_i |\\Re(\\lambda_i(A))|}{\\min_{i: |\\Re(\\lambda_i(A))| > 0} |\\Re(\\lambda_i(A))|},\n$$\n其中 $\\lambda_i(A)$ 是特征值。大的 $S$ 值表明时间尺度相差悬殊。与大的 $h$ 结合时，用于计算 $\\exp$ 的缩放平方算法可能会遭受舍入误差放大，即使精确解是非负的，也可能出现微小的负值。这些值的量级通常与机器精度相当（例如，$\\approx 10^{-16}$ 到 $\\approx 10^{-12}$）。\n- $N(t+h)$ 最小值的量级：如果它接近机器精度，我们分配代码 $2$ 表示舍入误差。如果在 Metzler 矩阵的情况下出现显著的负值，我们分配代码 $3$，表示由于步长或病态评估导致的误差放大。\n\n每个场景的算法步骤：\n1. 解析参数：初始 $N(0)$、通量 $\\phi$、截面、衰变常数、产额和时间步长 $h$。\n2. 计算中子诱发的移除率：$\\lambda_f(\\text{U}\\text{-}235) = \\phi \\sigma_f(\\text{U}\\text{-}235) \\cdot 10^{-24}$，$\\lambda_c(\\text{U}\\text{-}235) = \\phi \\sigma_c(\\text{U}\\text{-}235) \\cdot 10^{-24}$，以及 $\\lambda_a(\\text{Xe}\\text{-}135) = \\phi \\sigma_a(\\text{Xe}\\text{-}135) \\cdot 10^{-24}$。\n3. 组装 $A$：\n   - $A_{1,1} = -\\left(\\lambda_f + \\lambda_c\\right)$，\n   - $A_{2,1} = \\lambda_c$ (场景 4 除外，其中 $A_{2,1} = -\\lambda_c$)，\n   - $A_{3,3} = -\\lambda(\\text{I}\\text{-}135)$，\n   - $A_{4,3} = \\lambda(\\text{I}\\text{-}135)$，\n   - $A_{4,4} = -\\left(\\lambda(\\text{Xe}\\text{-}135) + \\lambda_a(\\text{Xe}\\text{-}135)\\right)$，\n   - 根据简化的衰变链，其他项为零。\n4. 组装 $q$：\n   - $q_3 = Y \\cdot \\lambda_f \\cdot N_1(0)$ (在步长内为常数)，\n   - 所有其他分量为零。\n5. 构造增广矩阵 $\\mathcal{A}$ 和增广初始状态 $X(0)$，使用可靠的矩阵指数例程计算 $X(h) = \\exp(\\mathcal{A} h) X(0)$，并提取 $N(h)$。\n6. 检查严格正性：计算 $m = \\min_i N_i(h)$，如果所有 $N_i(h) > 0$，则设置 $b = \\text{True}$。如果 $b = \\text{False}$，则执行诊断：\n   - 如果 $A$ 不是 Metzler 矩阵，设置 $d = 1$。\n   - 否则，如果 $|m|$ 小于一个舍入阈值（例如 $10^{-12}$），设置 $d = 2$。\n   - 否则，设置 $d = 3$。\n7. 为每个场景报告 $[b, m, d]$。\n\n通过使用物理上合理的通量、截面、半衰期和产额来确保科学真实性和单位一致性。所选场景测试：\n- 一个典型的热中子反应堆步长（场景 1），\n- 一个具有长步长的极端刚性案例（场景 2），\n- 一个零通量的纯衰变边界案例（场景 3），\n- 一个具有故意设置的不一致非对角线元素的诊断边缘案例（场景 4），用于验证对结构性违规的检测。\n\n最终程序将所有场景的结果汇总到符合要求格式的单行中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef build_scenario(scenario_id):\n    # Common parameters\n    # Nuclide order: [U235, U236, I135, Xe135]\n    n = 4\n    ln2 = np.log(2.0)\n\n    if scenario_id == 1:\n        N0 = np.array([3.000e-4, 0.0, 0.0, 0.0])  # atoms/b-cm\n        phi = 3.000e14  # n/cm^2/s\n        sigma_f_U235 = 580.0  # barns\n        sigma_c_U235 = 100.0  # barns\n        sigma_a_Xe135 = 2.000e6  # barns\n        # Optional small absorption for I-135 is neglected in A assembly\n        lambda_I135 = ln2 / 23652.0  # 1/s\n        lambda_Xe135 = ln2 / 32904.0  # 1/s\n        Y_I135_from_U235_f = 0.062  # fraction per fission\n        h = 21600.0  # s\n\n    elif scenario_id == 2:\n        N0 = np.array([3.000e-4, 0.0, 0.0, 0.0])\n        phi = 1.000e15\n        sigma_f_U235 = 580.0\n        sigma_c_U235 = 100.0\n        sigma_a_Xe135 = 2.000e6\n        lambda_I135 = ln2 / 23652.0\n        lambda_Xe135 = ln2 / 32904.0\n        Y_I135_from_U235_f = 0.062\n        h = 3.600e6\n\n    elif scenario_id == 3:\n        N0 = np.array([1.000e-6, 0.0, 2.000e-6, 0.0])\n        phi = 0.0\n        sigma_f_U235 = 580.0\n        sigma_c_U235 = 100.0\n        sigma_a_Xe135 = 2.000e6\n        lambda_I135 = ln2 / 23652.0\n        lambda_Xe135 = ln2 / 32904.0\n        Y_I135_from_U235_f = 0.062\n        h = 86400.0\n\n    elif scenario_id == 4:\n        N0 = np.array([3.000e-4, 0.0, 0.0, 0.0])\n        phi = 3.000e14\n        sigma_f_U235 = 580.0\n        sigma_c_U235 = 100.0\n        sigma_a_Xe135 = 2.000e6\n        lambda_I135 = ln2 / 23652.0\n        lambda_Xe135 = ln2 / 32904.0\n        Y_I135_from_U235_f = 0.062\n        h = 3600.0\n    else:\n        raise ValueError(\"Unknown scenario\")\n\n    # Compute neutron-induced rates (1/s)\n    # barns to cm^2: 1 barn = 1e-24 cm^2\n    barn_to_cm2 = 1.0e-24\n    lambda_f_U235 = phi * sigma_f_U235 * barn_to_cm2\n    lambda_c_U235 = phi * sigma_c_U235 * barn_to_cm2\n    lambda_a_Xe135 = phi * sigma_a_Xe135 * barn_to_cm2\n\n    # Assemble A (4x4)\n    A = np.zeros((n, n), dtype=float)\n    # U-235 removal\n    A[0, 0] = -(lambda_f_U235 + lambda_c_U235)\n    # U-236 production from U-235 capture\n    A_capture = lambda_c_U235\n    if scenario_id == 4:\n        # Intentionally inconsistent sign to test diagnostic\n        A_capture = -lambda_c_U235\n    A[1, 0] = A_capture\n    # I-135 decay to Xe-135\n    A[2, 2] = -lambda_I135\n    A[3, 2] = lambda_I135\n    # Xe-135 removal by decay and absorption\n    A[3, 3] = -(lambda_Xe135 + lambda_a_Xe135)\n\n    # Assemble constant source q (4)\n    q = np.zeros(n, dtype=float)\n    q[2] = Y_I135_from_U235_f * lambda_f_U235 * N0[0]\n\n    return N0, A, q, h\n\ndef augmented_expm_step(N0, A, q, h):\n    # Build augmented matrix of size (n+1)x(n+1)\n    n = A.shape[0]\n    Aug = np.zeros((n + 1, n + 1), dtype=float)\n    Aug[:n, :n] = A\n    Aug[:n, n] = q\n    # Last row is zeros, last column already zero except Aug[:n, n] = q\n    X0 = np.concatenate([N0, np.array([1.0], dtype=float)])\n    Xh = expm(Aug * h) @ X0\n    Nh = Xh[:n]\n    return Nh\n\ndef check_metzler(A, tol=0.0):\n    n = A.shape[0]\n    for j in range(n):\n        for i in range(n):\n            if j != i and A[j, i]  -tol:\n                return False\n    return True\n\ndef stiffness_ratio(A):\n    # Use eigenvalues of A; ignore zero real parts in denominator\n    eigvals = np.linalg.eigvals(A)\n    reals = np.abs(np.real(eigvals))\n    max_real = np.max(reals)\n    # Find smallest positive nonzero real part\n    positive = reals[reals > 0.0]\n    if positive.size == 0:\n        return np.inf\n    min_real = np.min(positive)\n    if min_real == 0.0:\n        return np.inf\n    return float(max_real / min_real)\n\ndef diagnose(A, min_val, h):\n    # Diagnostic codes:\n    # 0: No violation\n    # 1: Not Metzler (negative off-diagonal)\n    # 2: Violation but near round-off (|min|  1e-12)\n    # 3: Violation with Metzler and materially negative\n    if min_val > 0.0:\n        return 0\n    # Violation cases\n    if not check_metzler(A, tol=0.0):\n        return 1\n    if abs(min_val)  1.0e-12:\n        return 2\n    return 3\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [1, 2, 3, 4]\n\n    results = []\n    for case_id in test_cases:\n        N0, A, q, h = build_scenario(case_id)\n        Nh = augmented_expm_step(N0, A, q, h)\n        min_val = float(np.min(Nh))\n        all_positive = bool(np.all(Nh > 0.0))\n        diag_code = diagnose(A, min_val, h)\n        # Append [boolean, min_value, diagnosis_code]\n        results.append([all_positive, min_val, diag_code])\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and floats are printed in Python standard formatting.\n    def format_item(item):\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, float):\n            return repr(item)\n        elif isinstance(item, int):\n            return str(item)\n        elif isinstance(item, list):\n            return \"[\" + \",\".join(format_item(x) for x in item) + \"]\"\n        else:\n            return str(item)\n\n    print(\"[\" + \",\".join(format_item(r) for r in results) + \"]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在前两个练习的基础上，我们将处理一个更复杂的场景：由于通量或温度反馈等因素，损耗算符本身随时间变化。本练习  引入了步长加倍法，这是一种估算局部截断误差的经典方法。通过实施一个自适应步长控制算法，你将学会在更真实、动态的模拟中如何确保计算的准确性和效率。",
            "id": "4234758",
            "problem": "给定一个线性时变核素损耗模型，该模型被表述为关于核素数密度向量的常微分方程（ODE）。该模型为\n$$\n\\frac{d\\mathbf{N}(t)}{dt} = \\mathbf{A}(t)\\,\\mathbf{N}(t),\n$$\n其中 $\\mathbf{N}(t) \\in \\mathbb{R}^3$ 是核素数密度向量，其分量单位为原子/立方厘米（$\\text{atoms/cm}^3$），$\\mathbf{A}(t) \\in \\mathbb{R}^{3\\times 3}$ 是损耗算子，其条目单位为秒的倒数（$\\mathrm{s}^{-1}$）。在每个步长内，该算子随时间线性变化，即\n$$\n\\mathbf{A}(t) = \\mathbf{A}_0 + (t - t_n)\\,\\mathbf{B},\n$$\n其中 $t_n$ 是步长的开始时间，$\\mathbf{A}_0 = \\mathbf{A}(t_n)$，且 $\\mathbf{B} = \\frac{d\\mathbf{A}}{dt}\\bigg|_{t=t_n}$ 在该步长内为常数。\n\n您必须实现一个步长加倍程序，以估计在时间步长内冻结算子所引入的局部误差。考虑一个从 $t_n$ 开始、大小为 $\\Delta t$ 的单步，并定义两种演化：\n\n1. 使用在步长开始时冻结的算子进行一次完整的单步演化，得到 $\\mathbf{N}_{\\mathrm{full}}$。\n2. 两次半步演化，其中前半步使用 $t_n$ 处的算子，后半步将算子更新至中点 $t_n + \\tfrac{\\Delta t}{2}$，得到 $\\mathbf{N}_{\\mathrm{half\\_2}}$。\n\n将局部误差估计定义为分量差 $\\mathbf{e} = \\mathbf{N}_{\\mathrm{half\\_2}} - \\mathbf{N}_{\\mathrm{full}}$。使用加权无穷范数生成一个无量纲的标量误差度量，\n$$\n\\eta = \\max_i \\frac{|e_i|}{\\mathrm{atol} + \\mathrm{rtol}\\,|\\left(\\mathbf{N}_{\\mathrm{half\\_2}}\\right)_i|},\n$$\n其中 $\\mathrm{atol}$ 是绝对容差（单位：$\\text{atoms/cm}^3$），$\\mathrm{rtol}$ 是相对容差（无量纲）。当且仅当 $\\eta \\le 1$ 时，接受该步长。推荐一个新的步长\n$$\n\\Delta t_{\\mathrm{new}} = \\Delta t \\times \\operatorname{clip}\\left(s\\,\\eta^{-\\frac{1}{p+1}}, f_{\\min}, f_{\\max}\\right),\n$$\n其中 $p$ 是方法阶数，$s$ 是安全因子，$f_{\\min}$ 是最小增长/收缩因子，$f_{\\max}$ 是最大增长/收缩因子。在本问题中，取 $p=1$，$s=0.9$，$f_{\\min}=0.2$ 和 $f_{\\max}=5.0$。以秒为单位表示推荐的下一步长。\n\n测试套件由四个案例定义。对于所有案例，取初始时间为 $t_n = 0$，初始数密度为\n$$\n\\mathbf{N}_0 = \\begin{bmatrix} 3.0\\times 10^{20} \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}\\ \\text{atoms/cm}^3.\n$$\n定义一个包含三种核素的简单嬗变/衰变链，使得算子具有以下结构\n$$\n\\mathbf{A}(t) = \\begin{bmatrix}\n-(\\lambda_{12} + r_1(t))  0  0 \\\\\n\\lambda_{12} + r_1(t)  -(\\lambda_{23} + r_2(t))  0 \\\\\n0  \\lambda_{23} + r_2(t)  0\n\\end{bmatrix},\n$$\n其中\n$$\nr_1(t) = r_{10} + \\beta_1 t,\\quad r_2(t) = r_{20} + \\beta_2 t,\n$$\n此处 $\\lambda_{12}$ 和 $\\lambda_{23}$ 是衰变率（单位：$\\mathrm{s}^{-1}$），$r_{10}$ 和 $r_{20}$ 是初始反应率（单位：$\\mathrm{s}^{-1}$），$\\beta_1$ 和 $\\beta_2$ 是它们的时间导数（单位：$\\mathrm{s}^{-2}$）。则\n$$\n\\mathbf{A}_0 = \\mathbf{A}(t_n) = \\mathbf{A}(0),\\quad \\mathbf{B} = \\frac{d\\mathbf{A}}{dt}\\bigg|_{t=0} = \\begin{bmatrix}\n-\\beta_1  0  0 \\\\\n\\beta_1  -\\beta_2  0 \\\\\n0  \\beta_2  0\n\\end{bmatrix}.\n$$\n\n在每个案例中使用以下数值：\n\n- 案例 $1$ （算子变化温和，理想情况）：\n  - $\\Delta t = 3600.0$ 秒，\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $r_{10} = 5.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $r_{20} = 1.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $\\beta_1 = 1.0\\times 10^{-12}\\ \\mathrm{s}^{-2}$，\n  - $\\beta_2 = 5.0\\times 10^{-13}\\ \\mathrm{s}^{-2}$，\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$，\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$。\n\n- 案例 $2$ （算子变化剧烈，可能被拒绝）：\n  - $\\Delta t = 3600.0$ 秒，\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $r_{10} = 5.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $r_{20} = 1.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $\\beta_1 = 1.0\\times 10^{-10}\\ \\mathrm{s}^{-2}$，\n  - $\\beta_2 = 5.0\\times 10^{-11}\\ \\mathrm{s}^{-2}$，\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$，\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$。\n\n- 案例 $3$ （类似边界情况的场景）：\n  - $\\Delta t = 7200.0$ 秒，\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $r_{10} = 3.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $r_{20} = 0.5\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $\\beta_1 = 5.0\\times 10^{-12}\\ \\mathrm{s}^{-2}$，\n  - $\\beta_2 = 2.5\\times 10^{-12}\\ \\mathrm{s}^{-2}$，\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$，\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$。\n\n- 案例 $4$ （算子无变化，边缘情况）：\n  - $\\Delta t = 3600.0$ 秒，\n  - $\\lambda_{12} = 1.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $\\lambda_{23} = 2.0\\times 10^{-6}\\ \\mathrm{s}^{-1}$，\n  - $r_{10} = 5.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $r_{20} = 1.0\\times 10^{-8}\\ \\mathrm{s}^{-1}$，\n  - $\\beta_1 = 0.0\\ \\mathrm{s}^{-2}$，\n  - $\\beta_2 = 0.0\\ \\mathrm{s}^{-2}$，\n  - $\\mathrm{rtol} = 1.0\\times 10^{-8}$，\n  - $\\mathrm{atol} = 1.0\\times 10^{10}$ atoms/cm$^3$。\n\n对于每个案例，您的程序必须构建 $\\mathbf{A}_0$ 和 $\\mathbf{B}$，执行所述的一次全步和两次半步演化，计算误差度量 $\\eta$，决定步长是否接受，并计算推荐的下一步长 $\\Delta t_{\\mathrm{new}}$（以秒为单位）。每个案例的最终输出必须是一个列表\n$$\n[\\text{accept},\\ \\Delta t_{\\mathrm{new}},\\ \\eta],\n$$\n其中 $\\text{accept}$ 是一个布尔值，指示步长是否被接受，$\\Delta t_{\\mathrm{new}}$ 是一个以秒为单位的浮点数，$\\eta$ 是一个浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$）。本问题不涉及角度。不涉及百分比；所有量都必须按指定表示为布尔值或浮点数。所有与时间相关的量必须以秒为单位，所有与密度相关的量必须以原子/立方厘米为单位。",
            "solution": "该问题要求为模拟核素损耗的线性常微分方程（ODE）组实现一种基于步长加倍误差估计程序的自适应时间步长算法。该解决方案的核心在于，通过比较一个精度较低的数值演化与一个精度较高的数值演化来估计局部误差，并相应地调整步长。\n\n控制物理模型是核素损耗方程：\n$$\n\\frac{d\\mathbf{N}(t)}{dt} = \\mathbf{A}(t)\\,\\mathbf{N}(t)\n$$\n其中 $\\mathbf{N}(t)$ 是核素数密度向量，$\\mathbf{A}(t)$ 是时变损耗算子矩阵。对于本问题，假设在一个时间步长 $[t_n, t_n + \\Delta t]$ 内，算子的时间依赖性是线性的：\n$$\n\\mathbf{A}(t) = \\mathbf{A}(t_n) + (t - t_n)\\,\\mathbf{B} = \\mathbf{A}_0 + (t - t_n)\\,\\mathbf{B}\n$$\n其中 $\\mathbf{A}_0$ 是步长开始时的算子，$\\mathbf{B}$ 是其在该步长内恒定的时间导数。\n\n用于演化的基本数值方法基于将算子 $\\mathbf{A}(t)$ 在给定区间内近似为常数。常系数ODE $\\frac{d\\mathbf{N}}{dt} = \\mathbf{A}_{\\text{const}}\\mathbf{N}$ 的解为 $\\mathbf{N}(t_n+h) = e^{\\mathbf{A}_{\\text{const}}h}\\mathbf{N}(t_n)$，其中 $e^{(\\cdot)}$ 表示矩阵指数。本问题使用一种预测-校正风格的方法来估计这种常系数近似所引入的误差。\n\n误差估计通过步长加倍（或类似嵌入式Runge-Kutta）程序执行。计算在时间 $t_n + \\Delta t$ 状态的两种不同数值解：\n1.  **全步解（$\\mathbf{N}_{\\mathrm{full}}$）**：在整个步长 $\\Delta t$ 上进行一次演化，使用在开始时间 $t_n$ 冻结的算子。这作为低阶、精度较低的解。\n    $$\n    \\mathbf{N}_{\\mathrm{full}} = e^{\\mathbf{A}_0 \\Delta t} \\mathbf{N}(t_n)\n    $$\n2.  **两次半步解（$\\mathbf{N}_{\\mathrm{half\\_2}}$）**：演化被分为两个大小为 $\\frac{\\Delta t}{2}$ 的步骤。算子在时间中点被重新评估，从而更精确地表示其时间依赖性。这作为高阶、精度较高的“参考”解。\n    -   第一个半步使用起始算子 $\\mathbf{A}_0 = \\mathbf{A}(t_n)$ 将解从 $t_n$ 演化到 $t_n + \\frac{\\Delta t}{2}$：\n        $$\n        \\mathbf{N}_{\\mathrm{half\\_1}} = e^{\\mathbf{A}_0 \\frac{\\Delta t}{2}} \\mathbf{N}(t_n)\n        $$\n    -   第二个半步将解从 $t_n + \\frac{\\Delta t}{2}$ 演化到 $t_n + \\Delta t$。对于此步，算子被更新为其在中点的值，$\\mathbf{A}_{\\mathrm{mid}} = \\mathbf{A}(t_n + \\frac{\\Delta t}{2}) = \\mathbf{A}_0 + \\mathbf{B}\\frac{\\Delta t}{2}$：\n        $$\n        \\mathbf{N}_{\\mathrm{half\\_2}} = e^{\\mathbf{A}_{\\mathrm{mid}} \\frac{\\Delta t}{2}} \\mathbf{N}_{\\mathrm{half\\_1}} = e^{(\\mathbf{A}_0 + \\frac{\\Delta t}{2}\\mathbf{B})\\frac{\\Delta t}{2}} e^{\\mathbf{A}_0 \\frac{\\Delta t}{2}} \\mathbf{N}(t_n)\n        $$\n\n这两个解之间的差异 $\\mathbf{e} = \\mathbf{N}_{\\mathrm{half\\_2}} - \\mathbf{N}_{\\mathrm{full}}$，为精度较低的全步长方法提供了局部误差的估计。为了获得单一的无量纲标量误差度量 $\\eta$，使用加权无穷范数：\n$$\n\\eta = \\max_i \\frac{|e_i|}{\\mathrm{atol} + \\mathrm{rtol}\\,|\\left(\\mathbf{N}_{\\mathrm{half\\_2}}\\right)_i|}\n$$\n其中 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 分别是用户定义的绝对和相对容差。如果这个归一化误差小于或等于 $1$，即 $\\eta \\le 1$，则认为该步长是可接受的。\n\n基于 $\\eta$ 的值，使用自适应步长控制的标准公式推荐下一个积分步长的新步长：\n$$\n\\Delta t_{\\mathrm{new}} = \\Delta t \\times \\operatorname{clip}\\left(s\\,\\eta^{-\\frac{1}{p+1}}, f_{\\min}, f_{\\max}\\right)\n$$\n给定的参数为安全因子 $s=0.9$，最小和最大步长变化因子 $f_{\\min}=0.2$ 和 $f_{\\max}=5.0$，以及方法阶数 $p=1$。阶数 $p=1$ 是合适的，因为底层的全步长方法是一阶近似（在其对算子时间依赖性的处理上类似于前向欧拉法）。\n\n实现过程首先根据提供的参数 $\\lambda_{12}, \\lambda_{23}, r_{10}, r_{20}, \\beta_1, \\beta_2$ 为每个测试案例构建矩阵 $\\mathbf{A}_0$ 和 $\\mathbf{B}$。初始密度向量 $\\mathbf{N}_0$ 对所有案例都是恒定的。矩阵指数运算使用 `scipy.linalg.expm` 函数执行。计算两个演化路径，然后计算误差向量 $\\mathbf{e}$ 和标量度量 $\\eta$。包含了一个特殊检查，用于处理 $\\eta$ 在数值上为零的情况（如案例4中 $\\mathbf{B}=\\mathbf{0}$），此时步长增长由 $f_{\\max}$ 限制，以防止除零错误并确保步长增加最大化但有界。最后，对每个案例，将接受布尔值、新步长 $\\Delta t_{\\mathrm{new}}$ 和误差度量 $\\eta$ 汇编并格式化为所需的输出结构。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the test cases and printing of results.\n    \"\"\"\n\n    def _calculate_step_result(params):\n        \"\"\"\n        Performs the step-doubling error estimation for a single case.\n\n        Args:\n            params (tuple): A tuple containing the parameters for a single test case.\n\n        Returns:\n            list: A list containing [accept, dt_new, eta].\n        \"\"\"\n        dt, lambda12, lambda23, r10, r20, beta1, beta2, rtol, atol = params\n        \n        # Fixed parameters from problem statement\n        N0 = np.array([3.0e20, 0.0, 0.0])\n        p = 1.0      # Method order\n        s = 0.9      # Safety factor\n        f_min = 0.2  # Minimum growth/shrink factor\n        f_max = 5.0  # Maximum growth/shrink factor\n\n        # Construct the operator matrix at t=t_n=0 (A0) and its time derivative (B)\n        A0 = np.array([\n            [-(lambda12 + r10), 0, 0],\n            [  lambda12 + r10, -(lambda23 + r20), 0],\n            [  0,               lambda23 + r20,  0]\n        ])\n        \n        B = np.array([\n            [-beta1,    0, 0],\n            [ beta1, -beta2, 0],\n            [     0,  beta2, 0]\n        ])\n\n        # 1. Full step propagation: Propagate from t_n to t_n + dt using A0\n        M_full = A0 * dt\n        N_full = expm(M_full) @ N0\n\n        # 2. Two half-steps propagation\n        dt_half = dt / 2.0\n        \n        # First half-step: Propagate from t_n to t_n + dt/2 using A0\n        M_half1 = A0 * dt_half\n        N_half_1 = expm(M_half1) @ N0\n\n        # Second half-step: Propagate from t_n + dt/2 to t_n + dt using A(t_n + dt/2)\n        A_mid = A0 + B * dt_half\n        M_half2 = A_mid * dt_half\n        N_half_2 = expm(M_half2) @ N_half_1\n\n        # 3. Compute the scalar error measure, eta\n        error_vec = N_half_2 - N_full\n        \n        # Denominator for the weighted norm: atol + rtol * |(N_half_2)_i|\n        tolerance_vec = atol + rtol * np.abs(N_half_2)\n\n        # Calculate eta = max_i (|e_i| / tolerance_i)\n        # Add a small float to the denominator for numerical stability, though atol > 0 should suffice.\n        eta_vec = np.abs(error_vec) / (tolerance_vec + np.finfo(float).tiny)\n        eta = np.max(eta_vec)\n\n        # 4. Decide step acceptance and recommend new step size\n        accept = eta = 1.0\n        \n        # Handle the case where eta is zero or very close to it to avoid division by zero\n        # and to correctly apply the maximum step size growth factor. A small\n        # floating point tolerance is appropriate.\n        if eta  1e-15:\n            factor = f_max\n        else:\n            # The method order p is 1. The formula is s * eta**(-1/(p+1)).\n            factor = s * (eta ** (-1.0 / (p + 1.0)))\n            factor = np.clip(factor, f_min, f_max)\n        \n        dt_new = dt * factor\n        \n        # Return a standard Python bool for consistent string formatting\n        return [bool(accept), dt_new, eta]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mild operator variation, happy path)\n        (3600.0, 1.0e-6, 2.0e-6, 5.0e-8, 1.0e-8, 1.0e-12, 5.0e-13, 1.0e-8, 1.0e10),\n        # Case 2 (strong operator variation, likely rejection)\n        (3600.0, 1.0e-6, 2.0e-6, 5.0e-8, 1.0e-8, 1.0e-10, 5.0e-11, 1.0e-8, 1.0e10),\n        # Case 3 (boundary-like scenario)\n        (7200.0, 1.0e-6, 2.0e-6, 3.0e-8, 0.5e-8, 5.0e-12, 2.5e-12, 1.0e-8, 1.0e10),\n        # Case 4 (no operator variation, edge case)\n        (3600.0, 1.0e-6, 2.0e-6, 5.0e-8, 1.0e-8, 0.0, 0.0, 1.0e-8, 1.0e10),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result = _calculate_step_result(case_params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list in Python is '[item1, item2, ...]',\n    # which preserves the required spaces and boolean capitalization.\n    # The overall format will be [[res1], [res2], ...].\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}