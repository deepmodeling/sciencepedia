{
    "hands_on_practices": [
        {
            "introduction": "在实现任何数值模型之前，理解其数学基础至关重要。本练习  将指导您推导一个同时包含放射性衰变和中子诱发反应的嬗变链的解析解，这是对经典贝特曼方程的推广。这项实践有助于您从第一性原理层面加深对核素消耗方程如何构建的理解。",
            "id": "4233533",
            "problem": "考虑一个由三种核素组成的线性嬗变-衰变链，标记为 $1 \\to 2 \\to 3$。该链在均匀介质中，受不随时间变化的单能群中子注量率 $\\phi$ 的影响而演化。每种核素 $i \\in \\{1,2,3\\}$ 都进行放射性衰变，其衰变常数为 $\\lambda_i$，并通过中子诱发移除，其微观截面为 $\\sigma_{i,r}$，因此每个核素的总移除率为 $\\alpha_i \\equiv \\lambda_i + \\phi \\sigma_{i,r}$。链上的生成仅发生于从 $1$ 到 $2$ 以及从 $2$ 到 $3$（不存在从 $1$ 到 $3$ 的直接生成），其有效链式生成率定义为 $p_{12} \\equiv \\beta_{1\\to 2}\\lambda_1 + \\phi \\sigma_{1\\to 2}$ 和 $p_{23} \\equiv \\beta_{2\\to 3}\\lambda_2 + \\phi \\sigma_{2\\to 3}$，其中 $\\beta_{i\\to i+1}$ 是链内的衰变分支比，$\\sigma_{i\\to i+1}$ 是使核素 $i$ 嬗变为 $i+1$ 的中子反应的微观截面。假设 $\\phi$、所有的 $\\lambda_i$、所有的 $\\sigma_{i,r}$ 和所有的 $\\sigma_{i\\to i+1}$ 都不随时间变化，并假设 $\\alpha_1$、$\\alpha_2$ 和 $\\alpha_3$ 两两不等。在时间 $t=0$ 时的初始核素数量为 $N_1(0)$、$N_2(0)$ 和 $N_3(0)$。\n\n仅从每种核素的基本核素数量平衡原理出发——即变化率等于该核素的总生成率减去其总移除率——推导控制 $N_1(t)$、$N_2(t)$ 和 $N_3(t)$ 的耦合线性常微分方程(组) (ODEs)。利用这些常微分方程，证明中子诱发嬗变的存在会改变经典 Bateman 系数的结构，即将所有指数因子和部分分式分母中的纯放射性衰变常数替换为总移除率 $\\alpha_i$。然后，显式计算修正后的 Bateman 系数 $C_1(t)$、$C_2(t)$ 和 $C_3(t)$，这些系数由以下表示式定义：\n$$\nN_3(t) \\equiv C_1(t)\\,N_1(0) + C_2(t)\\,N_2(0) + C_3(t)\\,N_3(0),\n$$\n并用 $t$、$\\alpha_i$ 和 $p_{ij}$ 表示。你可以假设除了指定的生成和损耗路径外，没有其他路径。请将你的最终结果以行向量 $(C_1(t),\\,C_2(t),\\,C_3(t))$ 的闭式解析表达式形式给出。最终表达式无需进行数值取整，也无需报告单位。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 第1步：提取已知条件\n-   **核素链：** 由三种核素组成的线性链，$1 \\to 2 \\to 3$。\n-   **中子注量率：** $\\phi$，恒定且不随时间变化。\n-   **衰变常数：** 核素 $i \\in \\{1,2,3\\}$ 的衰变常数 $\\lambda_i$。\n-   **微观移除截面：** 核素 $i$ 的微观移除截面 $\\sigma_{i,r}$。\n-   **每个核素的总移除率：** $\\alpha_i \\equiv \\lambda_i + \\phi \\sigma_{i,r}$，对于核素 $i$。\n-   **有效链式生成率：**\n    -   $p_{12} \\equiv \\beta_{1\\to 2}\\lambda_1 + \\phi \\sigma_{1\\to 2}$\n    -   $p_{23} \\equiv \\beta_{2\\to 3}\\lambda_2 + \\phi \\sigma_{2\\to 3}$\n-   **衰变分支比：** $\\beta_{i\\to i+1}$。\n-   **微观嬗变截面：** $\\sigma_{i\\to i+1}$。\n-   **约束条件：** 所有参数（$\\phi$, $\\lambda_i$, $\\sigma_{i,r}$, $\\sigma_{i\\to i+1}$）均为常数。移除率 $\\alpha_1$、$\\alpha_2$ 和 $\\alpha_3$ 两两不等。\n-   **初始条件：** 时间 $t=0$ 时的核素数量为 $N_1(0)$、$N_2(0)$ 和 $N_3(0)$。\n-   **目标：** 推导控制性常微分方程，并找出表达式 $N_3(t) = C_1(t)N_1(0) + C_2(t)N_2(0) + C_3(t)N_3(0)$ 中的系数 $C_1(t)$、$C_2(t)$ 和 $C_3(t)$。\n\n### 第2步：使用提取的已知条件进行验证\n-   **科学依据：** 该问题使用标准的燃耗方程（也称为 Bateman 方程，推广用于燃耗计算）来描述核嬗变和衰变。这是核反应堆物理和工程学中一个基本且成熟的模型。移除率和生成路径的定义都是标准的。该问题在科学上是合理的。\n-   **适定性：** 该问题是求解一个具有常系数和指定初始条件的耦合线性一阶常微分方程组。这构成了一个适定的初值问题，保证了其解的唯一性和稳定性。$\\alpha_1$、$\\alpha_2$ 和 $\\alpha_3$ 两两不等这一明确条件确保了标准解形式中的分母不为零，这对于所采用的方法至关重要。\n-   **客观性：** 问题陈述使用了精确、无歧义的数学和物理术语。所有量都有正式定义。没有主观或基于观点的成分。\n\n### 第3步：结论与行动\n该问题在科学上是合理的、适定的、客观的且自洽的。这是一个有效的问题。可以开始求解过程。\n\n### 控制性常微分方程的推导\n\n核素数量 $N_i(t)$ 的演化遵循核素数量平衡原理：某种核素数量的时间变化率等于其总生成率减去其总移除率。\n\n对于核素 1：\n-   生成率：$0$（它是链的起点）。\n-   移除率：通过放射性衰变（速率为 $\\lambda_1 N_1$）和中子诱发反应（速率为 $\\phi \\sigma_{1,r} N_1$）发生。总移除率为 $(\\lambda_1 + \\phi \\sigma_{1,r}) N_1 = \\alpha_1 N_1$。\n-   $N_1(t)$ 的常微分方程为：\n    $$ \\frac{dN_1}{dt} = - \\alpha_1 N_1(t) $$\n\n对于核素 2：\n-   生成率：核素 2 由核素 1 生成。生成率是核素 1 衰变速率（$\\beta_{1\\to 2}\\lambda_1 N_1$）和核素 1 中子嬗变速率（$\\phi \\sigma_{1\\to 2} N_1$）之和。总生成率为 $(\\beta_{1\\to 2}\\lambda_1 + \\phi \\sigma_{1\\to 2}) N_1 = p_{12} N_1$。\n-   移除率：与核素 1 类似，总移除率为 $(\\lambda_2 + \\phi \\sigma_{2,r}) N_2 = \\alpha_2 N_2$。\n-   $N_2(t)$ 的常微分方程为：\n    $$ \\frac{dN_2}{dt} = p_{12} N_1(t) - \\alpha_2 N_2(t) $$\n\n对于核素 3：\n-   生成率：核素 3 由核素 2 生成，总速率为 $(\\beta_{2\\to 3}\\lambda_2 + \\phi \\sigma_{2\\to 3}) N_2 = p_{23} N_2$。\n-   移除率：总移除率为 $(\\lambda_3 + \\phi \\sigma_{3,r}) N_3 = \\alpha_3 N_3$。\n-   $N_3(t)$ 的常微分方程为：\n    $$ \\frac{dN_3}{dt} = p_{23} N_2(t) - \\alpha_3 N_3(t) $$\n\n这三个方程构成了一个耦合的线性一阶常微分方程组。\n\n### 常微分方程的求解与系数的推导\n\n该方程组是线性的，因此解可以表示为初始条件的线性组合，$N_3(t) = C_1(t)N_1(0) + C_2(t)N_2(0) + C_3(t)N_3(0)$。我们可以通过求解仅有对应初始条件 $N_i(0)$ 非零的情况下的方程组来找到每个系数 $C_i(t)$，这是叠加原理的直接应用。\n\n**1. $C_3(t)$ 的推导**\n假设初始条件为 $N_1(0)=0$、$N_2(0)=0$ 且 $N_3(0) \\neq 0$。方程组得到显著简化。对于所有 $t \\ge 0$，$N_1(t)=0$ 和 $N_2(t)=0$。$N_3(t)$ 的方程变为：\n$$ \\frac{dN_3}{dt} = - \\alpha_3 N_3(t) $$\n根据初始条件 $N_3(0)$，解为：\n$$ N_3(t) = N_3(0) \\exp(-\\alpha_3 t) $$\n根据定义，该解为 $C_3(t)N_3(0)$，因此：\n$$ C_3(t) = \\exp(-\\alpha_3 t) $$\n\n**2. $C_2(t)$ 的推导**\n假设初始条件为 $N_1(0)=0$、$N_2(0) \\neq 0$ 且 $N_3(0)=0$。\n$N_2(t)$ 的方程为 $\\frac{dN_2}{dt} = -\\alpha_2 N_2(t)$，解得 $N_2(t) = N_2(0)\\exp(-\\alpha_2 t)$。\n$N_3(t)$ 的方程成为一个非齐次线性常微分方程：\n$$ \\frac{dN_3}{dt} + \\alpha_3 N_3(t) = p_{23} N_2(t) = p_{23} N_2(0) \\exp(-\\alpha_2 t) $$\n使用积分因子 $I(t) = \\exp(\\int \\alpha_3 dt) = \\exp(\\alpha_3 t)$，我们得到：\n$$ \\frac{d}{dt}(N_3(t) \\exp(\\alpha_3 t)) = p_{23} N_2(0) \\exp(-\\alpha_2 t) \\exp(\\alpha_3 t) = p_{23} N_2(0) \\exp((\\alpha_3 - \\alpha_2)t) $$\n从 $0$ 到 $t$ 积分，并使用初始条件 $N_3(0)=0$：\n$$ N_3(t) \\exp(\\alpha_3 t) = \\int_0^t p_{23} N_2(0) \\exp((\\alpha_3 - \\alpha_2)\\tau) d\\tau = p_{23} N_2(0) \\left[ \\frac{\\exp((\\alpha_3 - \\alpha_2)\\tau)}{\\alpha_3 - \\alpha_2} \\right]_0^t $$\n这里使用了条件 $\\alpha_2 \\neq \\alpha_3$。\n$$ N_3(t) \\exp(\\alpha_3 t) = p_{23} N_2(0) \\frac{\\exp((\\alpha_3 - \\alpha_2)t) - 1}{\\alpha_3 - \\alpha_2} $$\n两边乘以 $\\exp(-\\alpha_3 t)$:\n$$ N_3(t) = p_{23} N_2(0) \\frac{\\exp(-\\alpha_2 t) - \\exp(-\\alpha_3 t)}{\\alpha_3 - \\alpha_2} $$\n因此，系数 $C_2(t)$ 是：\n$$ C_2(t) = p_{23} \\frac{\\exp(-\\alpha_2 t) - \\exp(-\\alpha_3 t)}{\\alpha_3 - \\alpha_2} $$\n\n**3. $C_1(t)$ 的推导**\n假设初始条件为 $N_1(0) \\neq 0$、$N_2(0)=0$ 且 $N_3(0)=0$。\n首先，求解 $N_1(t)$：$N_1(t) = N_1(0) \\exp(-\\alpha_1 t)$。\n接下来，求解 $N_2(t)$：\n$$ \\frac{dN_2}{dt} + \\alpha_2 N_2(t) = p_{12} N_1(0) \\exp(-\\alpha_1 t) $$\n使用积分因子 $\\exp(\\alpha_2 t)$ 和初始条件 $N_2(0)=0$，解为：\n$$ N_2(t) = p_{12} N_1(0) \\frac{\\exp(-\\alpha_1 t) - \\exp(-\\alpha_2 t)}{\\alpha_2 - \\alpha_1} $$\n现在，求解 $N_3(t)$：\n$$ \\frac{dN_3}{dt} + \\alpha_3 N_3(t) = p_{23} N_2(t) = p_{23} p_{12} N_1(0) \\frac{\\exp(-\\alpha_1 t) - \\exp(-\\alpha_2 t)}{\\alpha_2 - \\alpha_1} $$\n使用积分因子 $\\exp(\\alpha_3 t)$ 和 $N_3(0)=0$：\n$$ N_3(t)\\exp(\\alpha_3 t) = \\frac{p_{23} p_{12} N_1(0)}{\\alpha_2-\\alpha_1} \\int_0^t \\left( \\exp((\\alpha_3-\\alpha_1)\\tau) - \\exp((\\alpha_3-\\alpha_2)\\tau) \\right) d\\tau $$\n$$ N_3(t)\\exp(\\alpha_3 t) = \\frac{p_{23} p_{12} N_1(0)}{\\alpha_2-\\alpha_1} \\left( \\frac{\\exp((\\alpha_3-\\alpha_1)t)-1}{\\alpha_3-\\alpha_1} - \\frac{\\exp((\\alpha_3-\\alpha_2)t)-1}{\\alpha_3-\\alpha_2} \\right) $$\n两边乘以 $\\exp(-\\alpha_3 t)$ 并重新整理得到：\n$$ N_3(t) = \\frac{p_{23} p_{12} N_1(0)}{\\alpha_2-\\alpha_1} \\left( \\frac{\\exp(-\\alpha_1 t) - \\exp(-\\alpha_3 t)}{\\alpha_3-\\alpha_1} - \\frac{\\exp(-\\alpha_2 t) - \\exp(-\\alpha_3 t)}{\\alpha_3-\\alpha_2} \\right) $$\n为了获得标准的对称 Bateman 形式，我们将具有相同指数因子的项收集起来：\n$$ C_1(t) = p_{12} p_{23} \\left[ \\frac{\\exp(-\\alpha_1 t)}{(\\alpha_2-\\alpha_1)(\\alpha_3-\\alpha_1)} + \\frac{\\exp(-\\alpha_2 t)}{(\\alpha_1-\\alpha_2)(\\alpha_3-\\alpha_2)} + \\frac{\\exp(-\\alpha_3 t)}{(\\alpha_1-\\alpha_3)(\\alpha_2-\\alpha_3)} \\right] $$\n这个 $C_1(t)$ 的表达式展示了所要求的修正结构。与纯放射性衰变的经典 Bateman 方程相比，衰变常数 $\\lambda_i$ 在所有指数项和分母中被总移除率 $\\alpha_i = \\lambda_i + \\phi \\sigma_{i,r}$ 替代。此外，原本是简单衰变常数（或分支比乘以衰变常数）的中间生成项，被有效链式生成率 $p_{ij} = \\beta_{i\\to i+1}\\lambda_i + \\phi \\sigma_{i\\to i+1}$ 替代，后者同时考虑了衰变和中子俘获产生的核素。\n\n最终结果是这三个系数组成的行向量。",
            "answer": "$$ \\boxed{\\begin{pmatrix} p_{12} p_{23} \\left( \\frac{\\exp(-\\alpha_1 t)}{(\\alpha_2-\\alpha_1)(\\alpha_3-\\alpha_1)} + \\frac{\\exp(-\\alpha_2 t)}{(\\alpha_1-\\alpha_2)(\\alpha_3-\\alpha_2)} + \\frac{\\exp(-\\alpha_3 t)}{(\\alpha_1-\\alpha_3)(\\alpha_2-\\alpha_3)} \\right) & p_{23} \\frac{\\exp(-\\alpha_2 t) - \\exp(-\\alpha_3 t)}{\\alpha_3 - \\alpha_2} & \\exp(-\\alpha_3 t) \\end{pmatrix}} $$"
        },
        {
            "introduction": "现在我们将理论付诸实践。由于解析解通常仅限于简单情况，实际问题往往需要数值方法。本练习  要求您编写代码来数值求解一个消耗问题，并将其结果与精确的解析解进行比较。这是程序验证中的一个基本步骤，它突显了时间步长等数值参数对计算结果的影响。",
            "id": "4233519",
            "problem": "考虑一个代表核反应堆模拟中损耗的三核素线性嬗变衰变链。令数密度矢量为 $y(t) = \\begin{bmatrix} N_1(t) \\\\ N_2(t) \\\\ N_3(t) \\end{bmatrix}$，其中 $N_i(t)$ 表示核素 $i$ 的原子数密度，单位为原子/立方厘米。该演化过程由一个具有常系数和第一种核素的恒定源项的常微分方程（ODE）控制：\n$$\n\\frac{d}{dt} y(t) = A\\,y(t) + s,\n$$\n其中\n$$\nA = \\begin{bmatrix}\n-\\lambda_1  0  0 \\\\\nb_1 \\lambda_1  -\\lambda_2  0 \\\\\n0  b_2 \\lambda_2  -\\lambda_3\n\\end{bmatrix}, \\quad\ns = \\begin{bmatrix} q \\\\ 0 \\\\ 0 \\end{bmatrix}.\n$$\n此处，$\\lambda_i$ 是以 $\\mathrm{s}^{-1}$ 为单位的恒定移除率，可包括放射性衰变和有效的中子致移除（例如吸收）；$b_1$ 和 $b_2$ 是转移到链中下一个核素的分支产额（无量纲）；$q$ 是核素1的恒定外部产生率，单位为原子/立方厘米·秒。时间 $t$ 以秒为单位。假设初始条件 $y(0) = y_0$ 已给定。\n\n任务：\n1. 从线性时不变系统的基本定义和叠加原理出发，推导具有恒定矩阵 $A$ 和恒定源 $s$ 的系统的解析解 $y(t)$。请勿使用现成的快捷公式；通过考虑齐次解和特解，并使用常数变易法将它们组合，从第一性原理推导表达式。\n2. 设计一个一阶数值实现，该实现使用线性链方法，在固定时间步长 $\\Delta t$ 上通过显式时间推进来顺序更新链。在每个时间步内，首先使用其移除项和源项更新核素1，然后使用根据步长开始时的值计算出的核素1的流出量来更新核素2，最后使用根据步长开始时的值计算出的核素2的流出量来更新核素3。这种显式顺序更新必须在每个子步骤中使用母核素更新前的值。\n3. 对于下述测试套件中的每种情况，使用解析解和数值实现方法计算最终时间 $T$ 时的最终状态 $y(T)$，并计算在 $t=T$ 时三个核素的两个误差范数：相对 $L^2$ 范数和相对 $L^\\infty$ 范数，定义如下：\n$$\nE_2 = \\frac{\\|y_{\\text{num}}(T) - y_{\\text{exact}}(T)\\|_2}{\\|y_{\\text{exact}}(T)\\|_2}, \\quad\nE_\\infty = \\frac{\\|y_{\\text{num}}(T) - y_{\\text{exact}}(T)\\|_\\infty}{\\|y_{\\text{exact}}(T)\\|_\\infty}.\n$$\n$E_2$ 和 $E_\\infty$ 均为无量纲。\n4. 您的程序必须实现此过程，并生成单行输出，其中包含一个逗号分隔的列表，形式为 $[E_2^{(1)},E_\\infty^{(1)},E_2^{(2)},E_\\infty^{(2)},\\dots]$，并用方括号括起来，其中上标表示测试用例的索引。\n\n物理和数值单位：\n- 时间 $t$ 必须以秒为单位。\n- 移除率 $\\lambda_i$ 必须以 $\\mathrm{s}^{-1}$ 为单位。\n- 源 $q$ 必须以原子/立方厘米·秒为单位。\n- 数密度 $N_i(t)$ 必须以原子/立方厘米为单位。\n- 误差范数必须是无量纲的。\n\n测试套件：\n- 情况1（正常路径，中等时间步长）：$\\lambda_1 = 0.02$，$\\lambda_2 = 0.15$，$\\lambda_3 = 10^{-6}$，$b_1 = 1$，$b_2 = 1$，$q = 10^{19}$，$y_0 = \\begin{bmatrix} 2\\times 10^{20} \\\\ 0 \\\\ 0 \\end{bmatrix}$，$\\Delta t = 0.5$，$T = 10$。\n- 情况2（小时间步长边界）：与情况1参数相同，但 $\\Delta t = 0.01$ 且 $T = 10$。\n- 情况3（大时间步长压力测试）：与情况1参数相同，但 $\\Delta t = 2.0$ 且 $T = 10$。\n- 情况4（刚性链）：$\\lambda_1 = 5.0$，$\\lambda_2 = 0.05$，$\\lambda_3 = 10^{-5}$，$b_1 = 1$，$b_2 = 1$，$q = 10^{19}$，$y_0 = \\begin{bmatrix} 10^{19} \\\\ 2\\times 10^{18} \\\\ 0 \\end{bmatrix}$，$\\Delta t = 0.1$，$T = 10$。\n- 情况5（近简并的相等速率）：$\\lambda_1 = 0.1$，$\\lambda_2 = 0.1$，$\\lambda_3 = 0.1$，$b_1 = 1$，$b_2 = 1$，$q = 5\\times 10^{18}$，$y_0 = \\begin{bmatrix} 10^{20} \\\\ 5\\times 10^{19} \\\\ 0 \\end{bmatrix}$，$\\Delta t = 0.5$，$T = 10$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$）。每个 $result_i$ 必须是对应于每个测试用例指定误差范数的浮点数。",
            "solution": "该问题被评估为有效，因为它在科学上基于核嬗变和衰变原理，在数学上是适定的线性初值问题，并且客观地规定了所有必要的参数和条件。\n\n### 步骤1：解析解的推导\n\n该问题描述了一个三核素系统的演化，该系统由一个线性、非齐次、常系数的常微分方程（ODE）控制：\n$$\n\\frac{d}{dt} y(t) = A\\,y(t) + s\n$$\n初始条件为 $y(0) = y_0$。矢量 $y(t)$ 和 $s$ 以及矩阵 $A$ 由下式给出：\n$$\ny(t) = \\begin{bmatrix} N_1(t) \\\\ N_2(t) \\\\ N_3(t) \\end{bmatrix}, \\quad\nA = \\begin{bmatrix}\n-\\lambda_1  0  0 \\\\\nb_1 \\lambda_1  -\\lambda_2  0 \\\\\n0  b_2 \\lambda_2  -\\lambda_3\n\\end{bmatrix}, \\quad\ns = \\begin{bmatrix} q \\\\ 0 \\\\ 0 \\end{bmatrix}\n$$\n线性非齐次ODE的解是相应齐次方程的通解 $y_h(t)$ 与非齐次方程的一个特解 $y_p(t)$ 之和。\n\n**1. 齐次解：**\n齐次方程为 $\\frac{d}{dt} y_h(t) = A y_h(t)$。该系统的解由下式给出：\n$$\ny_h(t) = e^{At} C\n$$\n其中 $C$ 是由初始条件决定的常数矢量，$e^{At}$ 是矩阵指数，由其泰勒级数展开定义：\n$$\ne^{At} = I + At + \\frac{(At)^2}{2!} + \\frac{(At)^3}{3!} + \\dots = \\sum_{k=0}^\\infty \\frac{(At)^k}{k!}\n$$\n其中 $I$ 是单位矩阵。\n\n**2. 特解（常数变易法）：**\n为求特解，我们使用常数变易法，将常数矢量 $C$ 提升为一个与时间相关的函数 $c(t)$。我们假设解的形式为：\n$$\ny(t) = e^{At} c(t)\n$$\n将其代入原始非齐次ODE：\n$$\n\\frac{d}{dt} [e^{At} c(t)] = A [e^{At} c(t)] + s\n$$\n对左侧应用乘积法则求导：\n$$\n\\left(\\frac{d}{dt} e^{At}\\right) c(t) + e^{At} \\frac{d}{dt} c(t) = A e^{At} c(t) + s\n$$\n矩阵指数的导数是 $\\frac{d}{dt} e^{At} = A e^{At}$。代入可得：\n$$\nA e^{At} c(t) + e^{At} \\frac{d}{dt} c(t) = A e^{At} c(t) + s\n$$\n$A e^{At} c(t)$ 项从两侧消去，剩下：\n$$\ne^{At} \\frac{d}{dt} c(t) = s\n$$\n乘以 $e^{At}$ 的逆，即 $e^{-At}$：\n$$\n\\frac{d}{dt} c(t) = e^{-At} s\n$$\n对两边从 $\\tau=0$ 到 $\\tau=t$ 积分：\n$$\n\\int_0^t \\frac{d}{d\\tau} c(\\tau) \\,d\\tau = \\int_0^t e^{-A\\tau} s \\,d\\tau\n$$\n$$\nc(t) - c(0) = \\int_0^t e^{-A\\tau} s \\,d\\tau\n$$\n\n**3. 组合并应用初始条件：**\n完整解为 $y(t) = e^{At} c(t) = e^{At} \\left(c(0) + \\int_0^t e^{-A\\tau} s \\,d\\tau\\right)$。\n在 $t=0$ 时，我们有 $y(0) = y_0$。将此应用于我们的解形式：\n$$\ny(0) = e^{A \\cdot 0} c(0) = I c(0) = c(0)\n$$\n因此，积分常数矢量就是初始条件矢量，$c(0) = y_0$。\n将其代回，得到完整解为：\n$$\ny(t) = e^{At} \\left(y_0 + \\int_0^t e^{-A\\tau} s \\,d\\tau\\right) = e^{At} y_0 + e^{At} \\int_0^t e^{-A\\tau} s \\,d\\tau\n$$\n积分项可以通过将 $e^{At}$ 移入积分内部来简化（因为它相对于积分变量 $\\tau$ 是常数）：\n$$\ny(t) = e^{At} y_0 + \\int_0^t e^{A(t-\\tau)} s \\,d\\tau\n$$\n由于 $A$ 和 $s$ 是常数，并且对于给定的测试用例（所有 $\\lambda_i > 0$）$A$ 是可逆的，因此可以直接计算该积分：\n$$\n\\int_0^t e^{A(t-\\tau)} s \\,d\\tau = \\left[ -A^{-1} e^{A(t-\\tau)} \\right]_{\\tau=0}^{\\tau=t} s = \\left( -A^{-1} e^{A \\cdot 0} - (-A^{-1} e^{At}) \\right) s = A^{-1} (e^{At} - I) s\n$$\n因此，最终的解析解是：\n$$\ny_{\\text{exact}}(t) = e^{At} y_0 + A^{-1}(e^{At} - I)s\n$$\n此形式将用于在 $t=T$ 时进行精确计算。\n\n### 步骤2：数值实现\n\n问题指定了一个采用显式时间推进的一阶数值格式。该ODE系统为：\n$$\n\\frac{d N_1}{dt} = -\\lambda_1 N_1 + q \\\\\n\\frac{d N_2}{dt} = b_1 \\lambda_1 N_1 - \\lambda_2 N_2 \\\\\n\\frac{d N_3}{dt} = b_2 \\lambda_2 N_2 - \\lambda_3 N_3\n$$\n该数值方法是时间步长 $\\Delta t$ 上的前向欧拉（Forward Euler）更新规则。令 $y^n$ 表示在时间 $t_n = n \\Delta t$ 时的核素密度矢量。下一个时间步的矢量 $y^{n+1}$ 通过将导数近似为 $\\frac{dy}{dt} \\approx \\frac{y^{n+1} - y^n}{\\Delta t}$ 并在时间 $t_n$ 处计算右侧项得到。\n$$\n\\frac{y^{n+1} - y^n}{\\Delta t} = A y^n + s\n$$\n这给出了更新规则：\n$$\ny^{n+1} = y^n + \\Delta t (A y^n + s)\n$$\n此公式与问题描述中“在每个顺序更新步骤中为母核素使用‘更新前的值’”的要求一致。实现将从初始条件 $y_{\\text{num}}(0) = y_0$ 开始，并迭代应用此公式共 $N = T / \\Delta t$ 步，以求得 $y_{\\text{num}}(T)$。\n\n### 步骤3：误差范数计算\n\n在最终时间 $T$，我们将得到解析解 $y_{\\text{exact}}(T)$ 和数值近似解 $y_{\\text{num}}(T)$。相对误差范数计算如下：\n\n相对 $L^2$（欧几里得）范数误差：\n$$\nE_2 = \\frac{\\|y_{\\text{num}}(T) - y_{\\text{exact}}(T)\\|_2}{\\|y_{\\text{exact}}(T)\\|_2} = \\frac{\\sqrt{\\sum_{i=1}^3 (N_{i, \\text{num}}(T) - N_{i, \\text{exact}}(T))^2}}{\\sqrt{\\sum_{i=1}^3 (N_{i, \\text{exact}}(T))^2}}\n$$\n相对 $L^\\infty$（最大值）范数误差：\n$$\nE_\\infty = \\frac{\\|y_{\\text{num}}(T) - y_{\\text{exact}}(T)\\|_\\infty}{\\|y_{\\text{exact}}(T)\\|_\\infty} = \\frac{\\max_i |N_{i, \\text{num}}(T) - N_{i, \\text{exact}}(T)|}{\\max_i |N_{i, \\text{exact}}(T)|}\n$$\n将为提供的每个测试用例计算这些量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the nuclear depletion problem for a set of test cases.\n    For each case, it computes the exact solution and a numerical approximation,\n    then calculates the relative L2 and L-infinity error norms.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, moderate time step)\n        {'lambda1': 0.02, 'lambda2': 0.15, 'lambda3': 1e-6, 'b1': 1.0, 'b2': 1.0, 'q': 1e19,\n         'y0': np.array([2e20, 0, 0]), 'dt': 0.5, 'T': 10.0},\n        # Case 2 (small time step boundary)\n        {'lambda1': 0.02, 'lambda2': 0.15, 'lambda3': 1e-6, 'b1': 1.0, 'b2': 1.0, 'q': 1e19,\n         'y0': np.array([2e20, 0, 0]), 'dt': 0.01, 'T': 10.0},\n        # Case 3 (large time step stress)\n        {'lambda1': 0.02, 'lambda2': 0.15, 'lambda3': 1e-6, 'b1': 1.0, 'b2': 1.0, 'q': 1e19,\n         'y0': np.array([2e20, 0, 0]), 'dt': 2.0, 'T': 10.0},\n        # Case 4 (stiff chain)\n        {'lambda1': 5.0, 'lambda2': 0.05, 'lambda3': 1e-5, 'b1': 1.0, 'b2': 1.0, 'q': 1e19,\n         'y0': np.array([1e19, 2e18, 0]), 'dt': 0.1, 'T': 10.0},\n        # Case 5 (near-degenerate equal rates)\n        {'lambda1': 0.1, 'lambda2': 0.1, 'lambda3': 0.1, 'b1': 1.0, 'b2': 1.0, 'q': 5e18,\n         'y0': np.array([1e20, 5e19, 0]), 'dt': 0.5, 'T': 10.0},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Extract parameters for the current case\n        l1, l2, l3 = case['lambda1'], case['lambda2'], case['lambda3']\n        b1, b2 = case['b1'], case['b2']\n        q = case['q']\n        y0 = case['y0'].astype(np.float64).reshape(3, 1)\n        dt = case['dt']\n        T = case['T']\n\n        # Define the system matrix A and source vector s\n        A = np.array([\n            [-l1, 0, 0],\n            [b1 * l1, -l2, 0],\n            [0, b2 * l2, -l3]\n        ], dtype=np.float64)\n        \n        s = np.array([q, 0, 0], dtype=np.float64).reshape(3, 1)\n\n        # 1. Analytic Solution\n        # y_exact(t) = exp(At) * y0 + A_inv * (exp(At) - I) * s\n        I = np.identity(3)\n        A_inv = np.linalg.inv(A)\n        exp_At = expm(A * T)\n        \n        term1 = exp_At @ y0\n        term2 = A_inv @ (exp_At - I) @ s\n        y_exact_T = term1 + term2\n\n        # 2. Numerical Solution (Forward Euler)\n        # y_n+1 = y_n + dt * (A * y_n + s)\n        num_steps = int(round(T / dt))\n        y_num = y0.copy()\n        \n        for _ in range(num_steps):\n            y_num = y_num + dt * (A @ y_num + s)\n        \n        y_num_T = y_num\n\n        # 3. Error Calculation\n        diff_vec = y_num_T - y_exact_T\n        \n        # Calculate norms\n        norm_exact_2 = np.linalg.norm(y_exact_T, ord=2)\n        norm_exact_inf = np.linalg.norm(y_exact_T, ord=np.inf)\n        \n        norm_diff_2 = np.linalg.norm(diff_vec, ord=2)\n        norm_diff_inf = np.linalg.norm(diff_vec, ord=np.inf)\n\n        # Avoid division by zero if the exact solution is zero (unlikely here)\n        E2 = norm_diff_2 / norm_exact_2 if norm_exact_2 > 0 else 0.0\n        Einf = norm_diff_inf / norm_exact_inf if norm_exact_inf > 0 else 0.0\n\n        results.extend([E2, Einf])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们来探讨一个更真实、更复杂的场景。真实的反应堆模拟要求将中子输运与核素消耗耦合起来。这项高级实践  将实现一种预测-校正格式，该格式考虑了当中子材料库存演变时中子注量的变化。此练习展示了如何处理中子学和消耗计算之间的反馈效应，这是反应堆模拟中的一个核心挑战。",
            "id": "4233562",
            "problem": "要求您在一个线性链耗尽背景下，实现一个基于数学原理的通量形状预测器。该模型包含 $m$ 个空间区域，每个区域内有一个三核素的顺序链。为方便构造，本问题中所有量均为无量纲，且归一化对通量形状施加了一个固定的标量约束。您的任务是从第一性原理出发，推导如何通过基于灵敏度的预测器来更新因核素存量变化引起的通量形状，这种变化如何影响嬗变链反应率，以及如何使用预测-校正方法计算校正后的核素存量。\n\n推导的基本依据是以下定律和定义，您必须从此出发：\n\n- 稳态中子输运的离散平衡方程在一个线性算子下，对于通量形状向量 $\\phi \\in \\mathbb{R}^m$ 可以表示为 $L(\\Sigma)\\,\\phi = q$，并带有一个归一化约束 $w^\\top \\phi = P$。这里，$L(\\Sigma) = K - \\operatorname{diag}(\\Sigma)$ 是一个依赖于宏观吸收截面向量 $\\Sigma \\in \\mathbb{R}^m$ 的线性算子，$K \\in \\mathbb{R}^{m \\times m}$ 是一个耦合矩阵，$q \\in \\mathbb{R}^m$ 是一个固定源，$w \\in \\mathbb{R}^m$ 是一个权重向量，$P \\in \\mathbb{R}$ 是固定的归一化幅度。\n- 通量形状对参数向量的一阶灵敏度可以通过对控制方程和归一化约束进行微分来推导。\n- 链式耗尽由一个线性常微分方程（ODE）建模，该方程描述了每个区域内核素存量向量随时间步长的变化，其速率在时间步长内是恒定的。该过程由一个矩阵控制，此矩阵通过反应项与局部通量呈线性关系。\n\n该系统每个区域有三个核素，标记为 $X_1 \\to X_2 \\to X_3$，在区域 $k$ 中的动力学如下：\n- 核素存量向量为 $N_k = [N_{k,1}, N_{k,2}, N_{k,3}]^\\top$。\n- 区域 $k$ 的宏观吸收截面为 $\\Sigma_k = \\alpha_1 N_{k,1} + \\alpha_2 N_{k,2} + \\alpha_3 N_{k,3}$，其中 $\\alpha_i$ 是固定系数。\n- 区域 $k$ 的链式反应率依赖于局部通量分量 $\\phi_k$ 以及反应系数 $s_1$ 和 $s_2$：\n  - $X_1 \\to X_2$ 的反应率为 $r_{12,k} = s_1\\,\\phi_k\\,N_{k,1}$。\n  - $X_2 \\to X_3$ 的反应率为 $r_{23,k} = s_2\\,\\phi_k\\,N_{k,2}$。\n- 对于 $X_1$ 和 $X_2$，衰变移除率分别为 $d_1$ 和 $d_2$。区域 $k$ 的耗尽矩阵 $A_k(\\phi_k)$ 为：\n  $$\n  A_k(\\phi_k) =\n  \\begin{bmatrix}\n    -(d_1 + s_1 \\phi_k)  0  0 \\\\\n    s_1 \\phi_k  -(d_2 + s_2 \\phi_k)  0 \\\\\n    0  s_2 \\phi_k  0\n  \\end{bmatrix}.\n  $$\n\n定义增广线性系统\n$$\n\\begin{bmatrix}\nL(\\Sigma)  c \\\\\nw^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nq \\\\ P\n\\end{bmatrix},\n$$\n其中 $c = w$，$\\lambda$ 是一个用于强制执行归一化的拉格朗日乘子。这个增广系统同时编码了平衡方程和归一化约束。为了构建通量形状预测器，考虑由预测核素存量 $N_k^{\\mathrm{pred}}$ 引起的变化 $\\Delta \\Sigma$，并计算一阶修正\n$$\n\\phi_{\\mathrm{pred}} \\approx \\phi + J_\\Sigma\\,\\Delta \\Sigma,\n$$\n其中 $J_\\Sigma \\in \\mathbb{R}^{m \\times m}$ 是雅可比矩阵，其列向量 $\\frac{\\partial \\phi}{\\partial \\Sigma_k}$ 通过对增广系统关于 $\\Sigma_k$ 微分来确定。\n\n预测步骤使用矩阵指数在时间步长 $\\Delta t$ 内以恒定速率推进每个区域的核素存量：\n$$\nN_k^{\\mathrm{pred}} = \\exp\\!\\left(A_k(\\phi_k)\\,\\Delta t\\right)\\,N_k.\n$$\n利用预测通量 $\\phi_{\\mathrm{pred}}$ 和预测核素存量 $N_k^{\\mathrm{pred}}$，使用对称预测-校正方法（休恩方法）形成校正后的核素存量：\n$$\nN_k^{\\mathrm{corr}} = N_k + \\tfrac{1}{2}\\,\\Delta t \\left( A_k(\\phi_k)\\,N_k + A_k(\\phi_{\\mathrm{pred},k})\\,N_k^{\\mathrm{pred}} \\right).\n$$\n\n您的程序必须为以下固定参数、测试用例和所需输出实现此过程。所有变量都是无量纲的，因此不使用物理单位。\n\n所有测试用例共享的固定模型参数：\n- 区域数 $m = 2$。\n- 耦合矩阵 $K = \\begin{bmatrix} 2.0  -0.5 \\\\ -0.5  1.5 \\end{bmatrix}$。\n- 源 $q = \\begin{bmatrix} 0.1 \\\\ 0.1 \\end{bmatrix}$。\n- 权重向量 $w = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$ 和归一化幅度 $P = 1.0$。\n- 截面系数 $\\alpha_1 = 0.02$, $\\alpha_2 = 0.01$, $\\alpha_3 = 0.005$。\n- 反应系数 $s_1 = 0.03$, $s_2 = 0.025$。\n- 衰变移除系数 $d_1 = 0.001$, $d_2 = 0.0015$。\n\n对于每个测试用例，输入包括每个区域的初始核素存量和一个时间步长 $\\Delta t$。测试套件如下：\n- 测试用例 1（一般情况）：$\\Delta t = 1.0$, $N_1 = [10.0, 2.0, 0.0]^\\top$, $N_2 = [8.0, 1.0, 0.0]^\\top$。\n- 测试用例 2（小时间步长边界情况）：$\\Delta t = 0.0001$, $N_1 = [10.0, 2.0, 0.0]^\\top$, $N_2 = [8.0, 1.0, 0.0]^\\top$。\n- 测试用例 3（零分量边界情况）：$\\Delta t = 0.5$, $N_1 = [15.0, 0.0, 0.0]^\\top$, $N_2 = [0.0, 5.0, 0.0]^\\top$。\n\n对于每个测试用例，执行以下步骤：\n1. 根据初始核素存量计算宏观吸收向量 $\\Sigma$。\n2. 求解增广系统，得到归一化为 $w^\\top \\phi = P$ 的初始通量形状 $\\phi$。\n3. 构建各区域的耗尽矩阵 $A_k(\\phi_k)$，并使用矩阵指数在 $\\Delta t$ 时间内计算预测核素存量 $N_k^{\\mathrm{pred}}$。\n4. 根据 $N_k^{\\mathrm{pred}} - N_k$ 计算 $\\Delta \\Sigma$。\n5. 通过对增广系统关于 $\\Sigma$ 的每个分量进行微分，并使用相同的增广矩阵求解 $\\frac{\\partial \\phi}{\\partial \\Sigma_k}$，来计算通量形状的雅可比矩阵 $J_\\Sigma$。\n6. 构建预测通量 $\\phi_{\\mathrm{pred}} = \\phi + J_\\Sigma\\,\\Delta \\Sigma$。\n7. 计算初始总链式反应率 $R_{12}^{\\mathrm{init}} = \\sum_{k=1}^m s_1\\,\\phi_k\\,N_{k,1}$ 和预测的总链式反应率 $R_{12}^{\\mathrm{pred}} = \\sum_{k=1}^m s_1\\,\\phi_{\\mathrm{pred},k}\\,N_{k,1}^{\\mathrm{pred}}$。\n8. 构建校正后的核素存量 $N_k^{\\mathrm{corr}} = N_k + \\tfrac{1}{2}\\,\\Delta t \\left( A_k(\\phi_k)\\,N_k + A_k(\\phi_{\\mathrm{pred},k})\\,N_k^{\\mathrm{pred}} \\right)$。\n\n您的程序必须为每个测试用例按顺序输出以下汇总结果，形式为单行、用方括号括起来的逗号分隔列表：\n- 通量形状幅度的相对 $L^2$ 变化 $\\left\\|\\phi_{\\mathrm{pred}} - \\phi\\right\\|_2 / \\left\\|\\phi\\right\\|_2$。\n- 初始总 $X_1 \\to X_2$ 链式反应率 $R_{12}^{\\mathrm{init}}$。\n- 预测的总 $X_1 \\to X_2$ 链式反应率 $R_{12}^{\\mathrm{pred}}$。\n- 所有区域的校正后核素存量，按顺序拼接为 $[N_{1,1}^{\\mathrm{corr}}, N_{1,2}^{\\mathrm{corr}}, N_{1,3}^{\\mathrm{corr}}, N_{2,1}^{\\mathrm{corr}}, N_{2,2}^{\\mathrm{corr}}, N_{2,3}^{\\mathrm{corr}}]$。\n\n因此，对于三个测试用例，程序将按顺序输出3个块，每块包含9个数字，形成一个包含27个浮点数的单一列表：\n$$\n\\big[\n\\text{rel\\_flux\\_change}_1,\\; R_{12,1}^{\\mathrm{init}},\\; R_{12,1}^{\\mathrm{pred}},\\; N_{1,1,1}^{\\mathrm{corr}},\\; N_{1,2,1}^{\\mathrm{corr}},\\; N_{1,3,1}^{\\mathrm{corr}},\\; N_{2,1,1}^{\\mathrm{corr}},\\; N_{2,2,1}^{\\mathrm{corr}},\\; N_{2,3,1}^{\\mathrm{corr}},\\; \\text{rel\\_flux\\_change}_2,\\; \\ldots,\\; N_{2,3,3}^{\\mathrm{corr}}\n\\big].\n$$\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。不应打印任何额外文本。",
            "solution": "该问题要求实现一种带有通量反馈的预测-校正耗尽算法，其中通量反馈通过一阶灵敏度分析计算。我们将详细阐述单个时间步长的数学和算法流程，该流程将应用于每个测试用例。\n\n**1. 初始状态计算（通量和耗尽率）**\n\n系统的初始状态由 $m$ 个区域中每个区域的核素存量 $N_k$ 定义。这些核素存量决定了宏观吸收截面 $\\Sigma_k$，进而影响中子通量形状 $\\phi$。\n\n首先，我们使用给定的核素数密度 $N_{k,i}$ 和系数 $\\alpha_i$ 之间的线性关系，为每个区域 $k \\in \\{1, \\dots, m\\}$ 计算宏观吸收截面：\n$$\n\\Sigma_k = \\sum_{i=1}^{3} \\alpha_i N_{k,i}\n$$\n这定义了宏观吸收截面向量 $\\Sigma = [\\Sigma_1, \\dots, \\Sigma_m]^\\top$。\n\n在已知 $\\Sigma$ 的情况下，通过求解离散中子平衡方程及其归一化约束来找到稳态中子通量形状 $\\phi$。问题指定了一个结合了这两个方程的增广线性系统：\n$$\n\\begin{bmatrix}\nL(\\Sigma)  c \\\\\nw^\\top  0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi \\\\ \\lambda\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nq \\\\ P\n\\end{bmatrix}\n$$\n这里，$L(\\Sigma) = K - \\operatorname{diag}(\\Sigma)$ 是线性输运算子，$K$ 是耦合矩阵，$q$ 是固定中子源，$w$ 是权重向量，$P$ 是总功率归一化值，$c=w$ 是增广系统的一个给定选择，$\\lambda$ 是强制执行约束的拉格朗日乘子。我们定义增广矩阵 $A_{\\text{aug}}(\\Sigma)$ 和增广右端向量 $b_{\\text{aug}}$：\n$$\nA_{\\text{aug}}(\\Sigma) = \\begin{bmatrix} K - \\operatorname{diag}(\\Sigma)  w \\\\ w^\\top  0 \\end{bmatrix}, \\quad b_{\\text{aug}} = \\begin{bmatrix} q \\\\ P \\end{bmatrix}\n$$\n增广状态向量 $[\\phi^\\top, \\lambda]^\\top$ 通过求解这个 $(m+1) \\times (m+1)$ 线性系统得到：\n$$\n\\begin{bmatrix} \\phi \\\\ \\lambda \\end{bmatrix} = A_{\\text{aug}}^{-1}(\\Sigma) \\, b_{\\text{aug}}\n$$\n这提供了初始通量向量 $\\phi = [\\phi_1, \\dots, \\phi_m]^\\top$。\n\n**2. 预测步骤：核素存量演化**\n\n核素存量在时间步长 $\\Delta t$ 内的变化由一个线性常微分方程组 $\\frac{d N_k}{dt} = A_k(\\phi_k) N_k$ 控制。对于在该步长内恒定的通量 $\\phi_k$，解由矩阵指数给出。预测步骤通过假设初始通量 $\\phi$ 在整个时间步长 $\\Delta t$ 内保持不变来计算预测的核素存量 $N_k^{\\text{pred}}$。\n\n对于每个区域 $k$，使用初始通量分量 $\\phi_k$、衰变常数 $d_i$ 和反应系数 $s_i$ 构建耗尽矩阵 $A_k(\\phi_k)$：\n$$\nA_k(\\phi_k) =\n\\begin{bmatrix}\n-(d_1 + s_1 \\phi_k)  0  0 \\\\\ns_1 \\phi_k  -(d_2 + s_2 \\phi_k)  0 \\\\\n0  s_2 \\phi_k  0\n\\end{bmatrix}\n$$\n然后计算预测的核素存量向量 $N_k^{\\text{pred}}$：\n$$\nN_k^{\\text{pred}} = \\exp(A_k(\\phi_k)\\,\\Delta t)\\,N_k\n$$\n\n**3. 通量形状预测器：灵敏度分析**\n\n核素存量的变化 $\\Delta N_k = N_k^{\\text{pred}} - N_k$ 会引起宏观截面的变化 $\\Delta \\Sigma$。这反过来又会扰动通量形状。我们使用一阶泰勒展开来近似这个通量扰动 $\\Delta \\phi$：\n$$\n\\phi(\\Sigma + \\Delta\\Sigma) \\approx \\phi(\\Sigma) + J_\\Sigma \\Delta\\Sigma\n$$\n其中 $J_\\Sigma$ 是通量关于截面的雅可比矩阵，其元素为 $(J_\\Sigma)_{ij} = \\frac{\\partial \\phi_i}{\\partial \\Sigma_j}$。因此，预测通量为 $\\phi_{\\text{pred}} = \\phi + \\Delta\\phi = \\phi + J_\\Sigma \\Delta\\Sigma$。\n\n为了找到雅可比矩阵的列向量 $\\frac{\\partial \\phi}{\\partial \\Sigma_j}$，我们对增广系统 $A_{\\text{aug}}(\\Sigma)[\\phi^\\top, \\lambda]^\\top = b_{\\text{aug}}$ 关于单个截面分量 $\\Sigma_j$ 进行微分，使用乘法法则：\n$$\n\\frac{\\partial A_{\\text{aug}}}{\\partial \\Sigma_j} \\begin{bmatrix} \\phi \\\\ \\lambda \\end{bmatrix} + A_{\\text{aug}} \\frac{\\partial}{\\partial \\Sigma_j} \\begin{bmatrix} \\phi \\\\ \\lambda \\end{bmatrix} = \\frac{\\partial b_{\\text{aug}}}{\\partial \\Sigma_j} = \\mathbf{0}\n$$\n增广矩阵关于 $\\Sigma_j$ 的导数为：\n$$\n\\frac{\\partial A_{\\text{aug}}}{\\partial \\Sigma_j} = \\frac{\\partial}{\\partial \\Sigma_j} \\begin{bmatrix} K - \\operatorname{diag}(\\Sigma)  w \\\\ w^\\top  0 \\end{bmatrix} = \\begin{bmatrix} -\\operatorname{diag}(e_j)  \\mathbf{0}_{m\\times1} \\\\ \\mathbf{0}_{1\\times m}  0 \\end{bmatrix}\n$$\n其中 $e_j$ 是 $\\mathbb{R}^m$ 中的第 $j$ 个标准基向量。将此矩阵应用于状态向量得到：\n$$\n\\frac{\\partial A_{\\text{aug}}}{\\partial \\Sigma_j} \\begin{bmatrix} \\phi \\\\ \\lambda \\end{bmatrix} = \\begin{bmatrix} -\\phi_j e_j \\\\ 0 \\end{bmatrix}\n$$\n这是一个 $(m+1)$ 维向量，其第 $j$ 个位置的值为 $-\\phi_j$，其他位置为零。重新整理微分后的方程，得到一个关于灵敏度向量的线性系统：\n$$\nA_{\\text{aug}} \\begin{bmatrix} \\partial \\phi / \\partial \\Sigma_j \\\\ \\partial \\lambda / \\partial \\Sigma_j \\end{bmatrix} = - \\begin{bmatrix} -\\phi_j e_j \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} \\phi_j e_j \\\\ 0 \\end{bmatrix}\n$$\n对于每个 $j \\in \\{1, \\dots, m\\}$，我们求解这个线性系统。解向量的前 $m$ 个分量构成了雅可比矩阵 $J_\\Sigma$ 的第 $j$ 列。矩阵 $A_{\\text{aug}}$ 与用于求解初始通量的矩阵相同，这使得求解过程更高效。\n\n计算出雅可比矩阵 $J_\\Sigma$ 后，我们首先根据预测的核素存量计算截面的变化：\n$$\n\\Delta \\Sigma_k = \\sum_{i=1}^{3} \\alpha_i (N_{k,i}^{\\text{pred}} - N_{k,i})\n$$\n这给出了向量 $\\Delta\\Sigma$。然后找到预测通量：\n$$\n\\phi_{\\text{pred}} = \\phi + J_\\Sigma\\,\\Delta\\Sigma\n$$\n\n**4. 校正步骤：校正核素存量**\n\n最后一步是使用校正步骤来改进核素存量的计算。问题指定了一个对称的预测-校正方法，即休恩（Heun）方法或梯形法则方法。该方法对时间步长开始时（使用初始状态 $\\phi, N_k$）和结束时（使用预测状态 $\\phi_{\\text{pred}}, N_k^{\\text{pred}}$）的反应率进行平均。\n\n校正后的核素存量 $N_k^{\\text{corr}}$ 使用以下公式计算：\n$$\nN_k^{\\text{corr}} = N_k + \\frac{\\Delta t}{2} \\left( A_k(\\phi_k) N_k + A_k(\\phi_{\\mathrm{pred},k}) N_k^{\\text{pred}} \\right)\n$$\n其中 $A_k(\\phi_{\\mathrm{pred},k})$ 是使用区域 $k$ 中的预测通量 $\\phi_{\\mathrm{pred}, k}$ 构建的耗尽矩阵。这完成了预测-校正循环。\n\n**5. 所需输出**\n\n最后，对于每个测试用例，我们计算指定的输出量：\n- 通量变化的相对 $L^2$ 范数：$\\frac{\\|\\phi_{\\text{pred}} - \\phi\\|_2}{\\|\\phi\\|_2}$。\n- 反应 $X_1 \\to X_2$ 的初始总速率：$R_{12}^{\\text{init}} = \\sum_{k=1}^m s_1\\,\\phi_k\\,N_{k,1}$。\n- 反应 $X_1 \\to X_2$ 的预测总速率：$R_{12}^{\\text{pred}} = \\sum_{k=1}^m s_1\\,\\phi_{\\text{pred},k}\\,N_{k,1}^{\\text{pred}}$。\n- 所有区域校正后核素存量的拼接向量。\n\n此过程将被实现并对所有提供的测试用例重复执行。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements a predictor-corrector depletion calculation with flux feedback\n    based on first-order sensitivity analysis.\n    \"\"\"\n    \n    # Fixed model parameters\n    m = 2  # Number of zones\n    K = np.array([[2.0, -0.5], [-0.5, 1.5]])\n    q = np.array([0.1, 0.1])\n    w = np.array([1.0, 1.0])\n    P = 1.0\n    alphas = np.array([0.02, 0.01, 0.005])  # alpha_1, alpha_2, alpha_3\n    s1, s2 = 0.03, 0.025\n    d1, d2 = 0.001, 0.0015\n\n    # Test cases\n    test_cases = [\n        # (dt, N1_initial, N2_initial)\n        (1.0, np.array([10.0, 2.0, 0.0]), np.array([8.0, 1.0, 0.0])),\n        (0.0001, np.array([10.0, 2.0, 0.0]), np.array([8.0, 1.0, 0.0])),\n        (0.5, np.array([15.0, 0.0, 0.0]), np.array([0.0, 5.0, 0.0]))\n    ]\n    \n    all_results = []\n\n    for dt, N1_init, N2_init in test_cases:\n        N_init = [N1_init, N2_init]\n\n        # Step 1: Compute initial macroscopic absorption vector Sigma\n        Sigma = np.array([np.dot(alphas, N) for N in N_init])\n\n        # Step 2: Solve for the initial flux shape phi\n        L = K - np.diag(Sigma)\n        A_aug = np.zeros((m + 1, m + 1))\n        A_aug[:m, :m] = L\n        A_aug[:m, m] = w\n        A_aug[m, :m] = w\n        b_aug = np.append(q, P)\n        \n        x_aug = np.linalg.solve(A_aug, b_aug)\n        phi = x_aug[:m]\n\n        # Step 3: Compute predictor inventories N_pred\n        N_pred = []\n        depletion_matrices_init = []\n        for k in range(m):\n            phi_k = phi[k]\n            A_k = np.array([\n                [-(d1 + s1 * phi_k), 0, 0],\n                [s1 * phi_k, -(d2 + s2 * phi_k), 0],\n                [0, s2 * phi_k, 0]\n            ])\n            depletion_matrices_init.append(A_k)\n            N_k_pred = expm(A_k * dt) @ N_init[k]\n            N_pred.append(N_k_pred)\n\n        # Step 4: Compute Delta_Sigma\n        Sigma_pred = np.array([np.dot(alphas, N) for N in N_pred])\n        Delta_Sigma = Sigma_pred - Sigma\n\n        # Step 5: Compute the flux-shape Jacobian J_Sigma\n        J_Sigma = np.zeros((m, m))\n        for j in range(m):\n            rhs_j = np.zeros(m + 1)\n            rhs_j[j] = phi[j]\n            sensitivity_vec_aug = np.linalg.solve(A_aug, rhs_j)\n            J_Sigma[:, j] = sensitivity_vec_aug[:m]\n\n        # Step 6: Form the predicted flux phi_pred\n        phi_pred = phi + J_Sigma @ Delta_Sigma\n\n        # Step 7: Compute initial and predicted total chain rates\n        R12_init = s1 * (phi[0] * N1_init[0] + phi[1] * N2_init[0])\n        R12_pred = s1 * (phi_pred[0] * N_pred[0][0] + phi_pred[1] * N_pred[1][0])\n\n        # Step 8: Form corrected inventories N_corr\n        N_corr_flat = []\n        for k in range(m):\n            phi_pred_k = phi_pred[k]\n            A_k_pred = np.array([\n                [-(d1 + s1 * phi_pred_k), 0, 0],\n                [s1 * phi_pred_k, -(d2 + s2 * phi_pred_k), 0],\n                [0, s2 * phi_pred_k, 0]\n            ])\n            # Heun's method\n            deriv_init = depletion_matrices_init[k] @ N_init[k]\n            deriv_pred = A_k_pred @ N_pred[k]\n            N_k_corr = N_init[k] + 0.5 * dt * (deriv_init + deriv_pred)\n            N_corr_flat.extend(N_k_corr)\n\n        # Aggregate results for this test case\n        rel_flux_change = np.linalg.norm(phi_pred - phi) / np.linalg.norm(phi)\n        \n        case_results = [\n            rel_flux_change,\n            R12_init,\n            R12_pred\n        ]\n        case_results.extend(N_corr_flat)\n        all_results.extend(case_results)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{val:.12f}' for val in all_results)}]\")\n\nsolve()\n```"
        }
    ]
}