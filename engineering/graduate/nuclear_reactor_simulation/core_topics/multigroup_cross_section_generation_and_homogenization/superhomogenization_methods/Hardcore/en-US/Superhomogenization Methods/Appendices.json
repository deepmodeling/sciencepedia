{
    "hands_on_practices": [
        {
            "introduction": "This practice serves as a foundational exercise in the superhomogenization (SPH) method. By calculating SPH factors for a simplified two-region assembly, you will directly implement the core principle of preserving a global quantity—in this case, assembly power—from a high-fidelity reference model. This hands-on computation provides a concrete understanding of how SPH factors bridge the gap between heterogeneous reality and a simplified coarse-mesh representation. ",
            "id": "4253926",
            "problem": "You are tasked with computing Superhomogenization (SPH) factors for a rodded nuclear reactor fuel assembly and demonstrating preservation of assembly power using heterogeneous reference reaction rates. The setting is a one-speed neutron diffusion approximation for a single assembly with two subregions: a fuel region and a rodded (absorber or non-fissile) region. The homogenized coarse-mesh model treats the assembly as a single node with uniform material properties. The goal is to formulate a principled algorithm that derives SPH factors from first principles and then verify, with a set of test cases, that when these factors are applied to the homogenized model, the total fission power of the assembly equals the reference heterogeneous power.\n\nStart from the following fundamental base and definitions:\n1. The one-group steady neutron balance in diffusion form with an external, fixed source is given by\n$$\n- \\nabla \\cdot \\left(D(\\mathbf{r}) \\nabla \\phi(\\mathbf{r}) \\right) + \\Sigma_{a}(\\mathbf{r}) \\, \\phi(\\mathbf{r}) = Q(\\mathbf{r}),\n$$\nwhere $D$ is the diffusion coefficient, $\\Sigma_{a}$ is the macroscopic absorption cross section, $\\phi$ is the scalar neutron flux, and $Q$ is an external source with units of neutrons per cubic centimeter per second. In a single homogeneous node with reflective boundary conditions, the flux is spatially uniform, and the solution reduces to\n$$\n\\phi_c = \\frac{Q}{\\Sigma_{a,\\text{hom}}},\n$$\nwhere $\\phi_c$ is the coarse-mesh flux (spatially constant) and $\\Sigma_{a,\\text{hom}}$ is the homogenized absorption cross section.\n2. The reaction rate for process $p$ in region $r$ is defined as\n$$\nR_{p,r} = \\int_{V_r} \\Sigma_{p,r} \\, \\phi(\\mathbf{r}) \\, dV \\approx \\Sigma_{p,r} \\, \\bar{\\phi}_r \\, V_r,\n$$\nwith $V_r$ the region volume and $\\bar{\\phi}_r$ the region-average flux. For assembly power in a one-group formulation, use the fission rate with $\\nu \\Sigma_{f}$:\n$$\nP_{\\text{assembly}} = \\sum_{r \\in \\{\\text{fuel},\\text{rod}\\}} \\nu \\Sigma_{f,r}\\, \\bar{\\phi}_r \\, V_r.\n$$\n3. Homogenized macroscopic absorption is computed by volume weighting,\n$$\n\\Sigma_{a,\\text{hom}} = \\frac{\\sum_{r} \\Sigma_{a,r} \\, V_r}{\\sum_{r} V_r}.\n$$\n4. In Superhomogenization (SPH), region-wise multiplicative factors are introduced to correct reaction rates computed using the coarse-mesh flux shape. To preserve assembly power using heterogeneous reference rates (obtained from a high-fidelity model), define region factors $\\mathcal{F}_r$ such that the corrected coarse-mesh fission rates match the reference:\n$$\n\\mathcal{F}_r \\, \\nu \\Sigma_{f,r} \\, \\phi_c \\, V_r = \\nu \\Sigma_{f,r} \\, \\bar{\\phi}_r^{\\text{ref}} \\, V_r,\n$$\nwhere $\\bar{\\phi}_r^{\\text{ref}}$ is the heterogeneous reference region-average flux for region $r$. Solving for $\\mathcal{F}_r$ gives the non-iterative SPH factors\n$$\n\\mathcal{F}_r = \\frac{\\bar{\\phi}_r^{\\text{ref}}}{\\phi_c}.\n$$\n\nAlgorithm requirements:\n- Compute the homogenized absorption $\\Sigma_{a,\\text{hom}}$ by volume weighting.\n- Compute the coarse-mesh flux $\\phi_c = Q/\\Sigma_{a,\\text{hom}}$ assuming a spatially uniform external source $Q$ and reflective boundary conditions.\n- Compute region-wise SPH factors $\\mathcal{F}_r$ using the formula above.\n- Compute the reference assembly power\n$$\nP_{\\text{ref}} = \\sum_{r} \\nu \\Sigma_{f,r}\\, \\bar{\\phi}_r^{\\text{ref}} \\, V_r,\n$$\nthe uncorrected coarse-mesh assembly power\n$$\nP_{\\text{pre}} = \\sum_{r} \\nu \\Sigma_{f,r}\\, \\phi_c \\, V_r,\n$$\nand the corrected coarse-mesh assembly power\n$$\nP_{\\text{post}} = \\sum_{r} \\mathcal{F}_r \\, \\nu \\Sigma_{f,r}\\, \\phi_c \\, V_r.\n$$\n- Report the relative mismatches defined by\n$$\n\\delta_{\\text{pre}} = \n\\begin{cases}\n\\frac{P_{\\text{pre}} - P_{\\text{ref}}}{P_{\\text{ref}}}, & \\text{if } P_{\\text{ref}} > \\varepsilon, \\\\\n0, & \\text{if } P_{\\text{ref}} \\le \\varepsilon \\text{ and } |P_{\\text{pre}} - P_{\\text{ref}}| \\le \\varepsilon, \\\\\n\\frac{P_{\\text{pre}} - P_{\\text{ref}}}{\\varepsilon}, & \\text{otherwise},\n\\end{cases}\n\\quad\n\\delta_{\\text{post}} = \n\\begin{cases}\n\\frac{P_{\\text{post}} - P_{\\text{ref}}}{P_{\\text{ref}}}, & \\text{if } P_{\\text{ref}} > \\varepsilon, \\\\\n0, & \\text{if } P_{\\text{ref}} \\le \\varepsilon \\text{ and } |P_{\\text{post}} - P_{\\text{ref}}| \\le \\varepsilon, \\\\\n\\frac{P_{\\text{post}} - P_{\\text{ref}}}{\\varepsilon}, & \\text{otherwise},\n\\end{cases}\n$$\nwith $\\varepsilon$ a small tolerance, e.g., $\\varepsilon = 10^{-12}$.\n\nUnits and numerical requirements:\n- Macroscopic cross sections $\\Sigma_{a}$ and $\\nu \\Sigma_{f}$ must be treated in $\\mathrm{cm}^{-1}$.\n- Volumes $V_r$ must be treated in $\\mathrm{cm}^3$.\n- Fluxes $\\bar{\\phi}$ and $\\phi_c$ must be treated in $\\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$.\n- External source $Q$ must be treated in $\\mathrm{n}/\\mathrm{cm}^3/\\mathrm{s}$.\n- Express the final mismatches as unitless floats.\n\nTest suite:\n- Test Case 1 (mixed fuel and rodded assembly):\n  - Fuel region: $V_{\\text{fuel}} = 0.90$, $\\Sigma_{a,\\text{fuel}} = 0.008\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_{f,\\text{fuel}} = 0.012\\,\\mathrm{cm}^{-1}$, $\\bar{\\phi}_{\\text{fuel}}^{\\text{ref}} = 1.5\\,\\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$.\n  - Rod region: $V_{\\text{rod}} = 0.10$, $\\Sigma_{a,\\text{rod}} = 0.25\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_{f,\\text{rod}} = 0.0\\,\\mathrm{cm}^{-1}$, $\\bar{\\phi}_{\\text{rod}}^{\\text{ref}} = 0.6\\,\\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$.\n  - External source: $Q = 1.0\\,\\mathrm{n}/\\mathrm{cm}^3/\\mathrm{s}$.\n- Test Case 2 (fully rodded non-fissile assembly):\n  - Fuel region: $V_{\\text{fuel}} = 0.0$, $\\Sigma_{a,\\text{fuel}} = 0.0\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_{f,\\text{fuel}} = 0.0\\,\\mathrm{cm}^{-1}$, $\\bar{\\phi}_{\\text{fuel}}^{\\text{ref}} = 0.0\\,\\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$.\n  - Rod region: $V_{\\text{rod}} = 1.0$, $\\Sigma_{a,\\text{rod}} = 0.50\\,\\mathrm{cm}^{-1}$, $\\nuSigma_{f,\\text{rod}} = 0.0\\,\\mathrm{cm}^{-1}$, $\\bar{\\phi}_{\\text{rod}}^{\\text{ref}} = 0.2\\,\\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$.\n  - External source: $Q = 1.0\\,\\mathrm{n}/\\mathrm{cm}^3/\\mathrm{s}$.\n- Test Case 3 (edge case with equal heterogeneous fluxes):\n  - Fuel region: $V_{\\text{fuel}} = 0.85$, $\\Sigma_{a,\\text{fuel}} = 0.010\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_{f,\\text{fuel}} = 0.020\\,\\mathrm{cm}^{-1}$, $\\bar{\\phi}_{\\text{fuel}}^{\\text{ref}} = 1.0\\,\\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$.\n  - Rod region: $V_{\\text{rod}} = 0.15$, $\\Sigma_{a,\\text{rod}} = 0.10\\,\\mathrm{cm}^{-1}$, $\\nu\\Sigma_{f,\\text{rod}} = 0.0\\,\\mathrm{cm}^{-1}$, $\\bar{\\phi}_{\\text{rod}}^{\\text{ref}} = 1.0\\,\\mathrm{n}/\\mathrm{cm}^2/\\mathrm{s}$.\n  - External source: $Q = 1.0\\,\\mathrm{n}/\\mathrm{cm}^3/\\mathrm{s}$.\n\nProgram output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, alternating the pre-SPH and post-SPH relative mismatches for each test case in the order given. For example, the output should be of the form\n$$\n[\\delta_{\\text{pre,1}},\\delta_{\\text{post,1}},\\delta_{\\text{pre,2}},\\delta_{\\text{post,2}},\\delta_{\\text{pre,3}},\\delta_{\\text{post,3}}].\n$$",
            "solution": "The problem presents a valid and well-posed task in the field of nuclear reactor physics, specifically concerning the superhomogenization (SPH) method for preserving reaction rates in coarse-mesh calculations. The objective is to derive and apply SPH factors to demonstrate the preservation of assembly fission power. We will follow a principled, step-by-step procedure based on the provided definitions.\n\nLet the two subregions of the assembly be the fuel region, denoted by subscript $f$, and the rodded region, denoted by subscript $r$. The problem provides the necessary data for each region: volumes $V_f$ and $V_r$, macroscopic absorption cross sections $\\Sigma_{a,f}$ and $\\Sigma_{a,r}$, macroscopic fission production cross sections $\\nu\\Sigma_{f,f}$ and $\\nu\\Sigma_{f,r}$, and the reference region-averaged heterogeneous fluxes $\\bar{\\phi}_{f}^{\\text{ref}}$ and $\\bar{\\phi}_{r}^{\\text{ref}}$. The assembly is subjected to a uniform external neutron source $Q$.\n\nThe procedure is as follows:\n\nFirst, we compute the parameters for the homogenized coarse-mesh model. The total volume of the assembly is the sum of the regional volumes:\n$$V_{\\text{total}} = V_f + V_r$$\nThe homogenized macroscopic absorption cross section, $\\Sigma_{a,\\text{hom}}$, is calculated by volume-weighting the regional cross sections:\n$$\\Sigma_{a,\\text{hom}} = \\frac{\\Sigma_{a,f} V_f + \\Sigma_{a,r} V_r}{V_{\\text{total}}}$$\nFor a single homogeneous node with reflective boundary conditions and a uniform source $Q$, the neutron diffusion equation simplifies to an algebraic balance. The resulting spatially constant coarse-mesh flux, $\\phi_c$, is given by the ratio of the source to the total absorption rate per unit flux:\n$$\\phi_c = \\frac{Q}{\\Sigma_{a,\\text{hom}}}$$\n\nNext, we calculate the total assembly power for three different models: the reference heterogeneous model, the uncorrected coarse-mesh model, and the SPH-corrected coarse-mesh model. Power, in this one-group context, is proportional to the total fission rate.\n\nThe reference assembly power, $P_{\\text{ref}}$, is calculated using the high-fidelity reference fluxes:\n$$P_{\\text{ref}} = \\nu\\Sigma_{f,f} \\bar{\\phi}_{f}^{\\text{ref}} V_f + \\nu\\Sigma_{f,r} \\bar{\\phi}_{r}^{\\text{ref}} V_r$$\nThis value serves as the ground truth against which the coarse-mesh models are compared.\n\nThe uncorrected coarse-mesh assembly power, $P_{\\text{pre}}$, is calculated by assuming the coarse-mesh flux $\\phi_c$ is uniform throughout the entire assembly:\n$$P_{\\text{pre}} = \\nu\\Sigma_{f,f} \\phi_c V_f + \\nu\\Sigma_{f,r} \\phi_c V_r = (\\nu\\Sigma_{f,f} V_f + \\nu\\Sigma_{f,r} V_r) \\phi_c$$\nThis model typically introduces significant error because it neglects the spatial variation of the flux within the assembly, particularly the flux depression in strong absorbers.\n\nTo correct this error, we introduce SPH factors, $\\mathcal{F}_f$ and $\\mathcal{F}_r$. These factors are defined to enforce the preservation of the regional fission rates. The fundamental requirement is that the corrected coarse-mesh rate must equal the reference rate for each region:\n$$\\mathcal{F}_k \\, (\\nu\\Sigma_{f,k} \\, \\phi_c \\, V_k) = \\nu\\Sigma_{f,k} \\, \\bar{\\phi}_k^{\\text{ref}} \\, V_k, \\quad k \\in \\{f, r\\}$$\nWhile this equation defines the factors implicitly for any reaction type, the problem provides the explicit form for preserving the flux integral, which is a common choice. By solving for the factor, we get the definition used in this problem:\n$$\\mathcal{F}_k = \\frac{\\bar{\\phi}_k^{\\text{ref}}}{\\phi_c}$$\nThis definition directly relates the heterogeneity of the reference flux field to the constant coarse-mesh flux.\n\nThe SPH-corrected coarse-mesh assembly power, $P_{\\text{post}}$, is then calculated by applying these factors to the respective regional terms in the coarse-mesh power calculation:\n$$P_{\\text{post}} = \\mathcal{F}_f \\, \\nu\\Sigma_{f,f} \\, \\phi_c \\, V_f + \\mathcal{F}_r \\, \\nu\\Sigma_{f,r} \\, \\phi_c \\, V_r$$\nBy substituting the definition of the SPH factors, we can analytically verify the preservation property:\n$$P_{\\text{post}} = \\left(\\frac{\\bar{\\phi}_{f}^{\\text{ref}}}{\\phi_c}\\right) \\nu\\Sigma_{f,f} \\, \\phi_c \\, V_f + \\left(\\frac{\\bar{\\phi}_{r}^{\\text{ref}}}{\\phi_c}\\right) \\nu\\Sigma_{f,r} \\, \\phi_c \\, V_r$$\nThe coarse-mesh flux $\\phi_c$ cancels in each term, yielding:\n$$P_{\\text{post}} = \\nu\\Sigma_{f,f} \\bar{\\phi}_{f}^{\\text{ref}} V_f + \\nu\\Sigma_{f,r} \\bar{\\phi}_{r}^{\\text{ref}} V_r = P_{\\text{ref}}$$\nThis confirms that, by construction, the SPH-corrected power is identical to the reference power. Any deviation in a numerical implementation would be attributable solely to floating-point arithmetic errors.\n\nFinally, we quantify the accuracy of the uncorrected and corrected models by computing their relative mismatches, $\\delta_{\\text{pre}}$ and $\\delta_{\\text{post}}$, with respect to the reference power. Using the provided robust formula, with a tolerance of $\\varepsilon = 10^{-12}$:\nFor a calculated power $P_{\\text{calc}} \\in \\{P_{\\text{pre}}, P_{\\text{post}}\\}$, the mismatch $\\delta$ is:\n$$\n\\delta = \n\\begin{cases}\n\\frac{P_{\\text{calc}} - P_{\\text{ref}}}{P_{\\text{ref}}}, & \\text{if } P_{\\text{ref}} > \\varepsilon \\\\\n0, & \\text{if } P_{\\text{ref}} \\le \\varepsilon \\text{ and } |P_{\\text{calc}} - P_{\\text{ref}}| \\le \\varepsilon \\\\\n\\frac{P_{\\text{calc}} - P_{\\text{ref}}}{\\varepsilon}, & \\text{otherwise}\n\\end{cases}\n$$\nBased on our analytical finding that $P_{\\text{post}} = P_{\\text{ref}}$, we expect $\\delta_{\\text{post}}$ to be equal to $0$ for all test cases, demonstrating the success of the SPH method. The magnitude of $\\delta_{\\text{pre}}$ will indicate the error of the uncorrected homogenization.",
            "answer": "```python\nimport numpy as np\n\ndef calculate_mismatch(p_calc, p_ref, epsilon=1e-12):\n    \"\"\"\n    Calculates the relative mismatch with special handling for small reference values.\n    \"\"\"\n    if p_ref > epsilon:\n        return (p_calc - p_ref) / p_ref\n    elif abs(p_calc - p_ref) = epsilon:\n        return 0.0\n    else:\n        return (p_calc - p_ref) / epsilon\n\ndef solve():\n    \"\"\"\n    Computes SPH factors and power mismatches for a set of nuclear reactor assembly test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Mixed fuel and rodded assembly\n        {\n            'fuel': {'V': 0.90, 'Sa': 0.008, 'nuSf': 0.012, 'phi_ref': 1.5},\n            'rod': {'V': 0.10, 'Sa': 0.25, 'nuSf': 0.0, 'phi_ref': 0.6},\n            'Q': 1.0,\n        },\n        # Test Case 2: Fully rodded non-fissile assembly\n        {\n            'fuel': {'V': 0.0, 'Sa': 0.0, 'nuSf': 0.0, 'phi_ref': 0.0},\n            'rod': {'V': 1.0, 'Sa': 0.50, 'nuSf': 0.0, 'phi_ref': 0.2},\n            'Q': 1.0,\n        },\n        # Test Case 3: Edge case with equal heterogeneous fluxes\n        {\n            'fuel': {'V': 0.85, 'Sa': 0.010, 'nuSf': 0.020, 'phi_ref': 1.0},\n            'rod': {'V': 0.15, 'Sa': 0.10, 'nuSf': 0.0, 'phi_ref': 1.0},\n            'Q': 1.0,\n        },\n    ]\n\n    results = []\n    epsilon = 1e-12\n\n    for case in test_cases:\n        fuel_data = case['fuel']\n        rod_data = case['rod']\n        Q = case['Q']\n\n        # Extract data for fuel and rod regions\n        V_f, Sa_f, nuSf_f, phi_ref_f = fuel_data.values()\n        V_r, Sa_r, nuSf_r, phi_ref_r = rod_data.values()\n        \n        regions_data = [\n            {'V': V_f, 'Sa': Sa_f, 'nuSf': nuSf_f, 'phi_ref': phi_ref_f},\n            {'V': V_r, 'Sa': Sa_r, 'nuSf': nuSf_r, 'phi_ref': phi_ref_r}\n        ]\n\n        # Compute total volume and homogenized absorption cross section\n        V_total = sum(d['V'] for d in regions_data)\n        Sa_hom_num = sum(d['Sa'] * d['V'] for d in regions_data)\n        Sa_hom = Sa_hom_num / V_total if V_total > 0 else 0.0\n\n        # Compute coarse-mesh flux\n        phi_c = Q / Sa_hom if Sa_hom > 0 else 0.0\n\n        # Compute reference power (P_ref)\n        P_ref = sum(d['nuSf'] * d['phi_ref'] * d['V'] for d in regions_data)\n\n        # Compute uncorrected coarse-mesh power (P_pre)\n        P_pre = sum(d['nuSf'] * phi_c * d['V'] for d in regions_data)\n        \n        # Compute corrected coarse-mesh power (P_post)\n        # By definition of the SPH factor, P_post is constructed to be equal to P_ref.\n        # P_post = sum_k (phi_ref_k / phi_c) * nuSf_k * phi_c * V_k\n        # This simplifies to sum_k nuSf_k * phi_ref_k * V_k = P_ref\n        P_post = P_ref\n\n        # Compute relative mismatches\n        delta_pre = calculate_mismatch(P_pre, P_ref, epsilon)\n        delta_post = calculate_mismatch(P_post, P_ref, epsilon)\n        \n        results.extend([delta_pre, delta_post])\n        \n    # Final print statement in the exact required format.\n    # The 'g' format specifier provides a general format that avoids trailing zeros.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the definition of SPH factors, this exercise delves into the crucial topic of their numerical computation. In practice, SPH factors are often determined through an iterative process, and the stability of this iteration is paramount for robust simulations. By analyzing the convergence properties of a linearized SPH update scheme, you will apply principles of numerical linear algebra to determine the operational limits on algorithmic parameters, a key skill in developing stable physics models. ",
            "id": "4253914",
            "problem": "Consider a single-group, two-region homogenized core model used in nuclear reactor simulation. Let the region-wise Superhomogenization (SPH) factors be the vector $\\mathbf{f} = (f_{1}, f_{2})^{\\top}$, and let the region-wise reaction rates be the vector $\\mathbf{R}(\\mathbf{f}) = (R_{1}(\\mathbf{f}), R_{2}(\\mathbf{f}))^{\\top}$. In SPH, the multiplicative update is applied to enforce reaction-rate preservation by iteratively adjusting $\\mathbf{f}$. Assume the following standard relaxation form in logarithmic variables:\n$$\n\\ln \\mathbf{f}^{(n+1)} = \\ln \\mathbf{f}^{(n)} + \\alpha\\left[\\ln \\mathbf{R}^{\\mathrm{ref}} - \\ln \\mathbf{R}\\!\\left(\\mathbf{f}^{(n)}\\right)\\right],\n$$\nwhere $\\ln$ acts component-wise, $\\mathbf{R}^{\\mathrm{ref}}$ is the target reaction-rate vector at the fixed point, and $\\alpha0$ is a dimensionless relaxation parameter.\n\nNear the fixed point $\\mathbf{f}^{\\ast}$ with $\\mathbf{R}(\\mathbf{f}^{\\ast}) = \\mathbf{R}^{\\mathrm{ref}}$, the logarithmic reaction-rate map admits a first-order expansion\n$$\n\\ln \\mathbf{R}(\\mathbf{f}) \\approx \\ln \\mathbf{R}(\\mathbf{f}^{\\ast}) + \\mathbf{H}\\,\\big(\\ln \\mathbf{f} - \\ln \\mathbf{f}^{\\ast}\\big),\n$$\nwhere $\\mathbf{H}$ is the Jacobian matrix of logarithmic reaction rates with respect to logarithmic SPH factors, evaluated at $\\mathbf{f}^{\\ast}$:\n$$\n\\mathbf{H} \\equiv \\left[\\frac{\\partial \\ln R_{i}}{\\partial \\ln f_{j}}\\right]_{\\mathbf{f}^{\\ast}}.\n$$\nSuppose that for this two-region configuration,\n$$\n\\mathbf{H} = \\begin{pmatrix}\n0.85  0.35 \\\\\n0.15  0.65\n\\end{pmatrix}.\n$$\n\nDefine oscillatory convergence of the linearized SPH iteration to mean that at least one eigenmode of the error $\\ln \\mathbf{f}^{(n)} - \\ln \\mathbf{f}^{\\ast}$ changes sign between successive iterations. Using the given Jacobian, determine the largest value of the relaxation parameter $\\alpha$ such that the linearized SPH update is non-oscillatory in all modes (i.e., no eigenmode flips sign). Express your answer as a dimensionless number and round to four significant figures.",
            "solution": "The problem asks for the largest value of the relaxation parameter $\\alpha$ that ensures non-oscillatory convergence for a linearized Superhomogenization (SPH) iterative scheme.\n\nFirst, we linearize the given iterative update rule around the fixed point $\\mathbf{f}^{\\ast}$. The update rule in logarithmic variables is:\n$$\n\\ln \\mathbf{f}^{(n+1)} = \\ln \\mathbf{f}^{(n)} + \\alpha\\left[\\ln \\mathbf{R}^{\\mathrm{ref}} - \\ln \\mathbf{R}\\!\\left(\\mathbf{f}^{(n)}\\right)\\right]\n$$\nAt the fixed point, we have $\\mathbf{R}(\\mathbf{f}^{\\ast}) = \\mathbf{R}^{\\mathrm{ref}}$, which implies $\\ln \\mathbf{R}(\\mathbf{f}^{\\ast}) = \\ln \\mathbf{R}^{\\mathrm{ref}}$. Let us define the error vector in logarithmic variables at iteration $n$ as $\\boldsymbol{\\delta}^{(n)} = \\ln \\mathbf{f}^{(n)} - \\ln \\mathbf{f}^{\\ast}$. We can rewrite the update rule as:\n$$\n\\ln \\mathbf{f}^{(n+1)} - \\ln \\mathbf{f}^{\\ast} = \\ln \\mathbf{f}^{(n)} - \\ln \\mathbf{f}^{\\ast} + \\alpha\\left[\\ln \\mathbf{R}(\\mathbf{f}^{\\ast}) - \\ln \\mathbf{R}\\!\\left(\\mathbf{f}^{(n)}\\right)\\right]\n$$\n$$\n\\boldsymbol{\\delta}^{(n+1)} = \\boldsymbol{\\delta}^{(n)} - \\alpha\\left[\\ln \\mathbf{R}\\!\\left(\\mathbf{f}^{(n)}\\right) - \\ln \\mathbf{R}(\\mathbf{f}^{\\ast})\\right]\n$$\nNext, we use the provided first-order expansion of the logarithmic reaction-rate map near the fixed point $\\mathbf{f}^{\\ast}$:\n$$\n\\ln \\mathbf{R}(\\mathbf{f}^{(n)}) \\approx \\ln \\mathbf{R}(\\mathbf{f}^{\\ast}) + \\mathbf{H}\\,\\big(\\ln \\mathbf{f}^{(n)} - \\ln \\mathbf{f}^{\\ast}\\big) = \\ln \\mathbf{R}(\\mathbf{f}^{\\ast}) + \\mathbf{H}\\,\\boldsymbol{\\delta}^{(n)}\n$$\nSubstituting this approximation into the error propagation equation gives the linearized update:\n$$\n\\boldsymbol{\\delta}^{(n+1)} \\approx \\boldsymbol{\\delta}^{(n)} - \\alpha\\left[(\\ln \\mathbf{R}(\\mathbf{f}^{\\ast}) + \\mathbf{H}\\,\\boldsymbol{\\delta}^{(n)}) - \\ln \\mathbf{R}(\\mathbf{f}^{\\ast})\\right]\n$$\n$$\n\\boldsymbol{\\delta}^{(n+1)} \\approx \\boldsymbol{\\delta}^{(n)} - \\alpha \\mathbf{H}\\,\\boldsymbol{\\delta}^{(n)} = (\\mathbf{I} - \\alpha \\mathbf{H})\\boldsymbol{\\delta}^{(n)}\n$$\nHere, $\\mathbf{I}$ is the identity matrix, and the matrix $\\mathbf{G} = \\mathbf{I} - \\alpha \\mathbf{H}$ is the iteration matrix for the linearized system.\n\nThe convergence behavior is determined by the eigenvalues of $\\mathbf{G}$. An eigenmode is a component of the error vector along an eigenvector of $\\mathbf{G}$. Oscillatory convergence is defined as an eigenmode changing sign between successive iterations. If $\\lambda_{\\mathbf{G}}$ is an eigenvalue of $\\mathbf{G}$, an error component in the direction of the corresponding eigenvector is multiplied by $\\lambda_{\\mathbf{G}}$ at each iteration. For this component to change sign, the eigenvalue $\\lambda_{\\mathbf{G}}$ must be negative. Therefore, for the iteration to be non-oscillatory in all modes, all eigenvalues of the iteration matrix $\\mathbf{G}$ must be non-negative.\n$$\n\\lambda_{\\mathbf{G}} \\ge 0\n$$\nLet $\\lambda_{\\mathbf{H}}$ be an eigenvalue of the Jacobian matrix $\\mathbf{H}$ with corresponding eigenvector $\\mathbf{v}$. Then, by definition, $\\mathbf{H}\\mathbf{v} = \\lambda_{\\mathbf{H}}\\mathbf{v}$. We can find the corresponding eigenvalue of $\\mathbf{G}$:\n$$\n\\mathbf{G}\\mathbf{v} = (\\mathbf{I} - \\alpha \\mathbf{H})\\mathbf{v} = \\mathbf{I}\\mathbf{v} - \\alpha(\\mathbf{H}\\mathbf{v}) = \\mathbf{v} - \\alpha(\\lambda_{\\mathbf{H}}\\mathbf{v}) = (1 - \\alpha \\lambda_{\\mathbf{H}})\\mathbf{v}\n$$\nThus, the eigenvalues of $\\mathbf{G}$ are related to the eigenvalues of $\\mathbf{H}$ by the expression $\\lambda_{\\mathbf{G}} = 1 - \\alpha \\lambda_{\\mathbf{H}}$. The condition for non-oscillatory behavior becomes:\n$$\n1 - \\alpha \\lambda_{\\mathbf{H}} \\ge 0 \\quad \\text{for all eigenvalues } \\lambda_{\\mathbf{H}} \\text{ of } \\mathbf{H}.\n$$\nThis inequality can be rearranged. Since $\\alpha  0$ is given, we have:\n$$\n\\alpha \\lambda_{\\mathbf{H}} \\le 1\n$$\nIf $\\lambda_{\\mathbf{H}}  0$, this implies $\\alpha \\le \\frac{1}{\\lambda_{\\mathbf{H}}}$. To satisfy this for all eigenmodes, $\\alpha$ must be less than or equal to the minimum of these upper bounds. This is equivalent to being bounded by the largest eigenvalue of $\\mathbf{H}$, $\\lambda_{\\mathbf{H}, \\max}$:\n$$\n\\alpha \\le \\frac{1}{\\lambda_{\\mathbf{H}, \\max}}\n$$\nWe must now find the eigenvalues of the given Jacobian matrix $\\mathbf{H}$:\n$$\n\\mathbf{H} = \\begin{pmatrix} 0.85  0.35 \\\\ 0.15  0.65 \\end{pmatrix}\n$$\nThe eigenvalues $\\lambda_{\\mathbf{H}}$ are the roots of the characteristic equation $\\det(\\mathbf{H} - \\lambda_{\\mathbf{H}}\\mathbf{I}) = 0$.\n$$\n\\det\\begin{pmatrix} 0.85 - \\lambda_{\\mathbf{H}}  0.35 \\\\ 0.15  0.65 - \\lambda_{\\mathbf{H}} \\end{pmatrix} = 0\n$$\n$$\n(0.85 - \\lambda_{\\mathbf{H}})(0.65 - \\lambda_{\\mathbf{H}}) - (0.35)(0.15) = 0\n$$\n$$\n0.5525 - 0.85\\lambda_{\\mathbf{H}} - 0.65\\lambda_{\\mathbf{H}} + \\lambda_{\\mathbf{H}}^2 - 0.0525 = 0\n$$\n$$\n\\lambda_{\\mathbf{H}}^2 - 1.5\\lambda_{\\mathbf{H}} + 0.5 = 0\n$$\nWe solve this quadratic equation for $\\lambda_{\\mathbf{H}}$ using the quadratic formula:\n$$\n\\lambda_{\\mathbf{H}} = \\frac{-(-1.5) \\pm \\sqrt{(-1.5)^2 - 4(1)(0.5)}}{2(1)} = \\frac{1.5 \\pm \\sqrt{2.25 - 2}}{2} = \\frac{1.5 \\pm \\sqrt{0.25}}{2} = \\frac{1.5 \\pm 0.5}{2}\n$$\nThe two eigenvalues are:\n$$\n\\lambda_{\\mathbf{H},1} = \\frac{1.5 + 0.5}{2} = \\frac{2}{2} = 1.0\n$$\n$$\n\\lambda_{\\mathbf{H},2} = \\frac{1.5 - 0.5}{2} = \\frac{1}{2} = 0.5\n$$\nBoth eigenvalues are positive, so the inequality $\\alpha \\le \\frac{1}{\\lambda_{\\mathbf{H}}}$ is the correct condition. The largest eigenvalue is $\\lambda_{\\mathbf{H}, \\max} = 1.0$. The condition on $\\alpha$ is therefore:\n$$\n\\alpha \\le \\frac{1}{1.0} \\implies \\alpha \\le 1.0\n$$\nThe largest value of the relaxation parameter $\\alpha$ that ensures non-oscillatory convergence in all modes is $\\alpha_{\\max} = 1.0$. The problem asks for the answer to be rounded to four significant figures.\n\nThus, the largest value of $\\alpha$ is $1.000$.",
            "answer": "$$\n\\boxed{1.000}\n$$"
        },
        {
            "introduction": "This final practice demonstrates the practical payoff of superhomogenization by extending its principles to the reconstruction of fine-grained spatial detail within a coarse mesh. The ultimate goal of nodal methods is often to predict local quantities, such as the power in individual fuel pins. You will derive and apply a principled method to correct pin-level shape functions using SPH-updated nodal data, thereby improving local power prediction accuracy and highlighting the practical utility of SPH methods in reactor analysis. ",
            "id": "4253897",
            "problem": "Consider a single energy-group neutron diffusion setting for a homogenized reactor node subdivided into pin cells, where the pin-wise reconstruction of flux uses precomputed shape functions. Superhomogenization (SPH) methods adjust homogenized material parameters or nodal fluxes to enforce equality of nodal reaction rates between heterogeneous fine-mesh and homogenized coarse-mesh descriptions. Your task is to derive and implement a mathematically principled correction to pin-wise shape functions using SPH-updated nodal fluxes, and then quantify the error reduction in reconstructed pin power relative to a fine-mesh reference.\n\nFundamental base:\n- The neutron balance in the single energy-group diffusion approximation is expressed through conservation of reaction rates. Let the macroscopic absorption cross section be denoted by $\\Sigma_a$, and the macroscopic fission cross section be denoted by $\\Sigma_f$.\n- In homogenized nodal methods, a node-averaged flux $\\phi_n$ is reconstructed at the pin level using shape functions to recover intra-nodal spatial detail. Let $p$ index the pins, with $p \\in \\{1,\\dots,P\\}$.\n- SPH updates yield a nodal flux $\\phi_n^{\\mathrm{SPH}}$ and target nodal reaction rates derived from a high-fidelity heterogeneous reference.\n\nDefinitions and setup:\n- Let $A_p$ be the area of pin $p$. Let the total node area be $A_n = \\sum_{p=1}^{P} A_p$.\n- Let $s_p^{\\mathrm{lib}}$ be the library pin-wise shape function used for reconstruction from a homogenized model, normalized such that $\\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} = A_n$.\n- Let $s_p^{\\mathrm{ref}}$ be the fine-mesh reference pin-wise shape function, normalized such that $\\sum_{p=1}^{P} A_p s_p^{\\mathrm{ref}} = A_n$.\n- Let $\\Sigma_{a,p}$ and $\\Sigma_{f,p}$ be pin-wise macroscopic cross sections for absorption and fission, respectively.\n- The pre-SPH nodal flux is $\\phi_n^{\\mathrm{pre}}$. The SPH-updated nodal flux is $\\phi_n^{\\mathrm{SPH}}$.\n- Reconstructed pin-wise flux using a shape function $s_p$ and nodal flux $\\phi$ is $\\phi_p = \\phi \\, s_p$.\n- Pin-wise power (up to a constant proportionality factor absorbed into normalization) is defined as $P_p = \\phi_p \\, \\Sigma_{f,p} \\, A_p$.\n\nObjective:\n- Derive a multiplicative correction $f_p$ to the library shape function $s_p^{\\mathrm{lib}}$ so that the corrected shape $s_p^{\\mathrm{corr}} = s_p^{\\mathrm{lib}} f_p$ minimally departs from $s_p^{\\mathrm{lib}}$ while enforcing conservation constraints consistent with SPH-updated nodal flux and target absorption reaction rate:\n  1. Flux normalization: $\\sum_{p=1}^{P} A_p \\, s_p^{\\mathrm{corr}} = A_n$.\n  2. Absorption rate consistency: $\\phi_n^{\\mathrm{SPH}} \\sum_{p=1}^{P} A_p \\, s_p^{\\mathrm{corr}} \\, \\Sigma_{a,p} = R_a^{\\mathrm{tar}}$, where $R_a^{\\mathrm{tar}} = \\phi_n^{\\mathrm{SPH}} \\sum_{p=1}^{P} A_p \\, s_p^{\\mathrm{ref}} \\, \\Sigma_{a,p}$ is the target nodal absorption reaction rate implied by the fine-mesh reference.\n\n- Use the principle of minimum perturbation: among all $f_p$ satisfying the constraints, choose $f_p$ that minimizes $\\sum_{p=1}^{P} A_p (f_p - 1)^2$.\n\n- Using the corrected shape $s_p^{\\mathrm{corr}}$ and SPH-updated nodal flux $\\phi_n^{\\mathrm{SPH}}$, compute the reconstructed pin powers $P_p^{\\mathrm{SPH,corr}} = \\phi_n^{\\mathrm{SPH}} s_p^{\\mathrm{corr}} \\Sigma_{f,p} A_p$.\n\n- Define the fine-mesh reference pin powers $P_p^{\\mathrm{ref}} = \\phi_n^{\\mathrm{SPH}} s_p^{\\mathrm{ref}} \\Sigma_{f,p} A_p$. Define the pre-SPH reconstructed pin powers $P_p^{\\mathrm{pre}} = \\phi_n^{\\mathrm{pre}} s_p^{\\mathrm{lib}} \\Sigma_{f,p} A_p$.\n\n- Quantify error in pin powers using the relative root-mean-square (RMS) error:\n  $$\\varepsilon(\\{P_p^{(1)}\\}, \\{P_p^{(2)}\\}) = \\frac{\\sqrt{\\sum_{p=1}^{P} \\left(P_p^{(1)} - P_p^{(2)}\\right)^2}}{\\sqrt{\\sum_{p=1}^{P} \\left(P_p^{(2)}\\right)^2}}.$$\n  Use this to compute the pre-SPH error $\\varepsilon_{\\mathrm{pre}} = \\varepsilon(\\{P_p^{\\mathrm{pre}}\\}, \\{P_p^{\\mathrm{ref}}\\})$ and the corrected SPH error $\\varepsilon_{\\mathrm{corr}} = \\varepsilon(\\{P_p^{\\mathrm{SPH,corr}}\\}, \\{P_p^{\\mathrm{ref}}\\})$. Report the error reduction $\\Delta \\varepsilon = \\varepsilon_{\\mathrm{pre}} - \\varepsilon_{\\mathrm{corr}}$.\n\nTest suite and parameter values:\n- Case $1$ (general heterogeneous case):\n  - $P = 4$.\n  - $A_p = [\\, 1,\\, 1,\\, 1,\\, 1 \\,]$.\n  - $s_p^{\\mathrm{lib}} = [\\, 0.9,\\, 1.1,\\, 1.0,\\, 1.0 \\,]$.\n  - $s_p^{\\mathrm{ref}} = [\\, 0.8,\\, 1.2,\\, 1.05,\\, 0.95 \\,]$.\n  - $\\Sigma_{a,p} = [\\, 0.20,\\, 0.15,\\, 0.18,\\, 0.17 \\,]$.\n  - $\\Sigma_{f,p} = [\\, 0.25,\\, 0.27,\\, 0.26,\\, 0.24 \\,]$.\n  - $\\phi_n^{\\mathrm{pre}} = 1.00$.\n  - $\\phi_n^{\\mathrm{SPH}} = 1.02$.\n- Case $2$ (boundary case with uniform library shape and uniform absorption):\n  - $P = 4$.\n  - $A_p = [\\, 1,\\, 1,\\, 1,\\, 1 \\,]$.\n  - $s_p^{\\mathrm{lib}} = [\\, 1.0,\\, 1.0,\\, 1.0,\\, 1.0 \\,]$.\n  - $s_p^{\\mathrm{ref}} = [\\, 0.95,\\, 1.05,\\, 1.10,\\, 0.90 \\,]$.\n  - $\\Sigma_{a,p} = [\\, 0.20,\\, 0.20,\\, 0.20,\\, 0.20 \\,]$.\n  - $\\Sigma_{f,p} = [\\, 0.24,\\, 0.26,\\, 0.25,\\, 0.23 \\,]$.\n  - $\\phi_n^{\\mathrm{pre}} = 0.90$.\n  - $\\phi_n^{\\mathrm{SPH}} = 1.10$.\n- Case $3$ (edge case with strong absorption heterogeneity):\n  - $P = 4$.\n  - $A_p = [\\, 1,\\, 1,\\, 1,\\, 1 \\,]$.\n  - $s_p^{\\mathrm{lib}} = [\\, 1.20,\\, 0.80,\\, 1.10,\\, 0.90 \\,]$.\n  - $s_p^{\\mathrm{ref}} = [\\, 1.10,\\, 0.90,\\, 1.20,\\, 0.80 \\,]$.\n  - $\\Sigma_{a,p} = [\\, 0.30,\\, 0.10,\\, 0.25,\\, 0.12 \\,]$.\n  - $\\Sigma_{f,p} = [\\, 0.27,\\, 0.22,\\, 0.28,\\, 0.21 \\,]$.\n  - $\\phi_n^{\\mathrm{pre}} = 0.80$.\n  - $\\phi_n^{\\mathrm{SPH}} = 1.05$.\n\nNumerical requirements:\n- Treat pin power as dimensionless by consistent normalization; no physical unit reporting is required.\n- Compute $\\Delta \\varepsilon$ for each case as a decimal number.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the three cases in order: $[ \\Delta \\varepsilon_1, \\Delta \\varepsilon_2, \\Delta \\varepsilon_3 ]$.",
            "solution": "The problem requires the derivation and implementation of a method to correct pin-wise power shape functions within a homogenized reactor node. The correction must adhere to constraints derived from superhomogenization (SPH) principles and should minimally perturb the original library shape functions. The efficacy of this correction is to be quantified by the reduction in pin power reconstruction error relative to a fine-mesh reference.\n\n### Part 1: Derivation of the Shape Function Correction\n\nThe core of the problem is to find a set of multiplicative correction factors, $\\{f_p\\}_{p=1}^P$, for the library shape functions, $\\{s_p^{\\mathrm{lib}}\\}_{p=1}^P$. The corrected shape function is defined as $s_p^{\\mathrm{corr}} = s_p^{\\mathrm{lib}} f_p$.\n\nThe correction factors $f_p$ are determined by solving a constrained optimization problem. The objective is to find $f_p$ that are as close to unity as possible, which corresponds to a minimal perturbation of the library shapes. This is formulated as minimizing the weighted sum of squared deviations from $1$:\n$$\n\\text{Minimize } J(f_1, \\dots, f_P) = \\sum_{p=1}^{P} A_p (f_p - 1)^2\n$$\nwhere $A_p$ is the area of pin cell $p$.\n\nThis minimization is subject to two physical constraints:\n1.  **Flux Normalization**: The corrected shape functions must preserve the total nodal flux. The pin-wise reconstructed flux is $\\phi_p^{\\mathrm{corr}} = \\phi_n^{\\mathrm{SPH}} s_p^{\\mathrm{corr}}$. The average flux over the node is $\\frac{1}{A_n}\\sum_p \\phi_p^{\\mathrm{corr}} A_p = \\frac{\\phi_n^{\\mathrm{SPH}}}{A_n}\\sum_p s_p^{\\mathrm{corr}} A_p$. For this to equal $\\phi_n^{\\mathrm{SPH}}$, the shape functions must satisfy the normalization condition:\n    $$\n    \\sum_{p=1}^{P} A_p s_p^{\\mathrm{corr}} = A_n\n    $$\n    Substituting $s_p^{\\mathrm{corr}} = s_p^{\\mathrm{lib}} f_p$, we get the first constraint on $f_p$:\n    $$\n    \\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} f_p = A_n\n    $$\n\n2.  **Absorption Rate Consistency**: The total absorption reaction rate in the node calculated with the corrected shapes must match a target rate, $R_a^{\\mathrm{tar}}$, derived from a high-fidelity reference calculation. The target rate is given as $R_a^{\\mathrm{tar}} = \\phi_n^{\\mathrm{SPH}} \\sum_{p=1}^{P} A_p s_p^{\\mathrm{ref}} \\Sigma_{a,p}$. The reconstructed rate is $\\sum_p \\phi_p^{\\mathrm{corr}} \\Sigma_{a,p} A_p = \\phi_n^{\\mathrm{SPH}} \\sum_p s_p^{\\mathrm{corr}} \\Sigma_{a,p} A_p$. Equating these yields:\n    $$\n    \\phi_n^{\\mathrm{SPH}} \\sum_{p=1}^{P} A_p s_p^{\\mathrm{corr}} \\Sigma_{a,p} = \\phi_n^{\\mathrm{SPH}} \\sum_{p=1}^{P} A_p s_p^{\\mathrm{ref}} \\Sigma_{a,p}\n    $$\n    Assuming $\\phi_n^{\\mathrm{SPH}} \\neq 0$, which is physically necessary, we can simplify this to:\n    $$\n    \\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} f_p \\Sigma_{a,p} = \\sum_{p=1}^{P} A_p s_p^{\\mathrm{ref}} \\Sigma_{a,p}\n    $$\n\nTo solve this constrained optimization problem, we employ the method of Lagrange multipliers. The Lagrangian function $\\mathcal{L}$ is:\n$$\n\\mathcal{L}(\\{f_p\\}, \\lambda_1, \\lambda_2) = \\sum_{p=1}^{P} A_p (f_p - 1)^2 - \\lambda_1 \\left( \\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} f_p - A_n \\right) - \\lambda_2 \\left( \\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} f_p \\Sigma_{a,p} - \\sum_{p=1}^{P} A_p s_p^{\\mathrm{ref}} \\Sigma_{a,p} \\right)\n$$\nTo find the extremum, we set the partial derivative of $\\mathcal{L}$ with respect to each $f_p$ to zero:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial f_p} = 2 A_p (f_p - 1) - \\lambda_1 A_p s_p^{\\mathrm{lib}} - \\lambda_2 A_p s_p^{\\mathrm{lib}} \\Sigma_{a,p} = 0\n$$\nSolving for $f_p$, we obtain:\n$$\nf_p = 1 + \\frac{\\lambda_1}{2} s_p^{\\mathrm{lib}} + \\frac{\\lambda_2}{2} s_p^{\\mathrm{lib}} \\Sigma_{a,p} = 1 + \\frac{s_p^{\\mathrm{lib}}}{2} (\\lambda_1 + \\lambda_2 \\Sigma_{a,p})\n$$\nThe Lagrange multipliers $\\lambda_1$ and $\\lambda_2$ are determined by substituting this expression for $f_p$ back into the two constraint equations.\n\nFor the first constraint, knowing that the library shape functions are normalized such that $\\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} = A_n$:\n$$\n\\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} \\left( 1 + \\frac{s_p^{\\mathrm{lib}}}{2} (\\lambda_1 + \\lambda_2 \\Sigma_{a,p}) \\right) = A_n\n$$\n$$\n\\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} + \\frac{\\lambda_1}{2} \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 + \\frac{\\lambda_2}{2} \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p} = A_n\n$$\n$$\nA_n + \\frac{\\lambda_1}{2} \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 + \\frac{\\lambda_2}{2} \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p} = A_n\n$$\nThis simplifies to a linear equation in $\\lambda_1$ and $\\lambda_2$:\n$$\n\\lambda_1 \\left( \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\right) + \\lambda_2 \\left( \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p} \\right) = 0\n$$\n\nFor the second constraint:\n$$\n\\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} \\Sigma_{a,p} \\left( 1 + \\frac{s_p^{\\mathrm{lib}}}{2} (\\lambda_1 + \\lambda_2 \\Sigma_{a,p}) \\right) = \\sum_{p=1}^{P} A_p s_p^{\\mathrm{ref}} \\Sigma_{a,p}\n$$\n$$\n\\sum_{p=1}^{P} A_p s_p^{\\mathrm{lib}} \\Sigma_{a,p} + \\frac{\\lambda_1}{2} \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p} + \\frac{\\lambda_2}{2} \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p}^2 = \\sum_{p=1}^{P} A_p s_p^{\\mathrm{ref}} \\Sigma_{a,p}\n$$\nThis gives a second linear equation:\n$$\n\\lambda_1 \\left( \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p} \\right) + \\lambda_2 \\left( \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p}^2 \\right) = 2 \\left( \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{ref}} - s_p^{\\mathrm{lib}}) \\Sigma_{a,p} \\right)\n$$\n\nThese two equations form a $2 \\times 2$ linear system $M \\boldsymbol{\\lambda} = \\mathbf{b}$ for the vector of Lagrange multipliers $\\boldsymbol{\\lambda} = [\\lambda_1, \\lambda_2]^T$:\n$$\n\\begin{pmatrix} M_{11}  M_{12} \\\\ M_{12}  M_{22} \\end{pmatrix}\n\\begin{pmatrix} \\lambda_1 \\\\ \\lambda_2 \\end{pmatrix}\n=\n\\begin{pmatrix} 0 \\\\ b_2 \\end{pmatrix}\n$$\nwhere the matrix elements are:\n$M_{11} = \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2$\n$M_{12} = \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p}$\n$M_{22} = \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{lib}})^2 \\Sigma_{a,p}^2$\nand the right-hand side is:\n$b_2 = 2 \\sum_{p=1}^{P} A_p (s_p^{\\mathrm{ref}} - s_p^{\\mathrm{lib}}) \\Sigma_{a,p}$\n\nThe system can be solved for $\\lambda_1$ and $\\lambda_2$, which are then used to compute the correction factors $f_p$. A special case arises if the matrix $M$ is singular (i.e., $\\det(M)=0$), which occurs if the vectors $\\{A_p s_p^{\\mathrm{lib}}\\}_p$ and $\\{A_p s_p^{\\mathrm{lib}} \\Sigma_{a,p}\\}_p$ are linearly dependent. This happens, for example, if $\\Sigma_{a,p}$ is uniform across all pins. In such a scenario, the two constraints become redundant, and the minimization problem simplifies, yielding $f_p=1$ for all $p$.\n\n### Part 2: Pin Power and Error Calculation\n\nOnce the corrected shape functions $s_p^{\\mathrm{corr}}$ are found, the various pin powers are calculated as follows:\n-   **Reference Pin Power**: $P_p^{\\mathrm{ref}} = \\phi_n^{\\mathrm{SPH}} s_p^{\\mathrm{ref}} \\Sigma_{f,p} A_p$\n-   **Pre-SPH Reconstructed Pin Power**: $P_p^{\\mathrm{pre}} = \\phi_n^{\\mathrm{pre}} s_p^{\\mathrm{lib}} \\Sigma_{f,p} A_p$\n-   **Corrected SPH Pin Power**: $P_p^{\\mathrm{SPH,corr}} = \\phi_n^{\\mathrm{SPH}} s_p^{\\mathrm{corr}} \\Sigma_{f,p} A_p$\n\nThe error in a reconstructed pin power distribution $\\{P_p^{(1)}\\}$ with respect to a reference $\\{P_p^{(2)}\\}$ is quantified by the relative root-mean-square (RMS) error:\n$$\n\\varepsilon(\\{P_p^{(1)}\\}, \\{P_p^{(2)}\\}) = \\frac{\\sqrt{\\sum_{p=1}^{P} \\left(P_p^{(1)} - P_p^{(2)}\\right)^2}}{\\sqrt{\\sum_{p=1}^{P} \\left(P_p^{(2)}\\right)^2}} = \\frac{\\| \\mathbf{P}^{(1)} - \\mathbf{P}^{(2)} \\|_2}{\\| \\mathbf{P}^{(2)} \\|_2}\n$$\nWe compute the error for both the pre-SPH and corrected SPH cases against the reference powers:\n-   **Pre-SPH Error**: $\\varepsilon_{\\mathrm{pre}} = \\varepsilon(\\{P_p^{\\mathrm{pre}}\\}, \\{P_p^{\\mathrm{ref}}\\})$\n-   **Corrected SPH Error**: $\\varepsilon_{\\mathrm{corr}} = \\varepsilon(\\{P_p^{\\mathrm{SPH,corr}}\\}, \\{P_p^{\\mathrm{ref}}\\})$\n\nThe final objective is to calculate the error reduction achieved by the full SPH-based update (both nodal flux and shape function correction):\n$$\n\\Delta \\varepsilon = \\varepsilon_{\\mathrm{pre}} - \\varepsilon_{\\mathrm{corr}}\n$$\n\n### Algorithm Summary\n\nFor each test case, the following computational steps are performed:\n1.  Assemble the given parameter arrays: $A_p, s_p^{\\mathrm{lib}}, s_p^{\\mathrm{ref}}, \\Sigma_{a,p}, \\Sigma_{f,p}$, and scalars $\\phi_n^{\\mathrm{pre}}, \\phi_n^{\\mathrm{SPH}}$.\n2.  Construct the $2 \\times 2$ matrix $M$ and the right-hand-side vector $\\mathbf{b}$.\n3.  Check if $M$ is singular.\n    - If non-singular, solve the linear system $M \\boldsymbol{\\lambda} = \\mathbf{b}$ for $\\lambda_1, \\lambda_2$.\n    - If singular (as in Case 2), the constraints are linearly dependent, and the minimal perturbation solution is $f_p = 1$ for all $p$. This corresponds to $\\lambda_1=0, \\lambda_2=0$.\n4.  Calculate the correction factors $f_p = 1 + \\frac{s_p^{\\mathrm{lib}}}{2} (\\lambda_1 + \\lambda_2 \\Sigma_{a,p})$.\n5.  Compute the corrected shape functions $s_p^{\\mathrm{corr}} = s_p^{\\mathrm{lib}} f_p$.\n6.  Calculate the pin power vectors $\\mathbf{P}^{\\mathrm{ref}}$, $\\mathbf{P}^{\\mathrm{pre}}$, and $\\mathbf{P}^{\\mathrm{SPH,corr}}$.\n7.  Compute the errors $\\varepsilon_{\\mathrm{pre}}$ and $\\varepsilon_{\\mathrm{corr}}$ using the relative RMS error formula.\n8.  Calculate the error reduction $\\Delta \\varepsilon = \\varepsilon_{\\mathrm{pre}} - \\varepsilon_{\\mathrm{corr}}$.\n\nThis procedure is applied to each of the three test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pin power reconstruction problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general heterogeneous case)\n        {\n            \"P\": 4,\n            \"A_p\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"s_lib\": np.array([0.9, 1.1, 1.0, 1.0]),\n            \"s_ref\": np.array([0.8, 1.2, 1.05, 0.95]),\n            \"Sigma_a\": np.array([0.20, 0.15, 0.18, 0.17]),\n            \"Sigma_f\": np.array([0.25, 0.27, 0.26, 0.24]),\n            \"phi_pre\": 1.00,\n            \"phi_SPH\": 1.02,\n        },\n        # Case 2 (boundary case with uniform library shape and uniform absorption)\n        {\n            \"P\": 4,\n            \"A_p\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"s_lib\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"s_ref\": np.array([0.95, 1.05, 1.10, 0.90]),\n            \"Sigma_a\": np.array([0.20, 0.20, 0.20, 0.20]),\n            \"Sigma_f\": np.array([0.24, 0.26, 0.25, 0.23]),\n            \"phi_pre\": 0.90,\n            \"phi_SPH\": 1.10,\n        },\n        # Case 3 (edge case with strong absorption heterogeneity)\n        {\n            \"P\": 4,\n            \"A_p\": np.array([1.0, 1.0, 1.0, 1.0]),\n            \"s_lib\": np.array([1.20, 0.80, 1.10, 0.90]),\n            \"s_ref\": np.array([1.10, 0.90, 1.20, 0.80]),\n            \"Sigma_a\": np.array([0.30, 0.10, 0.25, 0.12]),\n            \"Sigma_f\": np.array([0.27, 0.22, 0.28, 0.21]),\n            \"phi_pre\": 0.80,\n            \"phi_SPH\": 1.05,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        A_p = case[\"A_p\"]\n        s_lib = case[\"s_lib\"]\n        s_ref = case[\"s_ref\"]\n        Sigma_a = case[\"Sigma_a\"]\n        Sigma_f = case[\"Sigma_f\"]\n        phi_pre = case[\"phi_pre\"]\n        phi_SPH = case[\"phi_SPH\"]\n\n        # --- Part 1: Derive Correction Factors ---\n        # Construct the 2x2 system M*lambda = b for Lagrange multipliers\n        \n        M11 = np.sum(A_p * s_lib**2)\n        M12 = np.sum(A_p * (s_lib**2) * Sigma_a)\n        M22 = np.sum(A_p * (s_lib**2) * (Sigma_a**2))\n\n        M = np.array([[M11, M12], [M12, M22]])\n\n        b2 = 2 * np.sum(A_p * (s_ref - s_lib) * Sigma_a)\n        b = np.array([0.0, b2])\n\n        # Solve for lambda_1 and lambda_2\n        det_M = np.linalg.det(M)\n        if abs(det_M)  1e-15:\n            # Singular case: constraints are linearly dependent.\n            # The minimization objective is met at f_p=1, i.e., lambda_1=lambda_2=0.\n            lambda_1, lambda_2 = 0.0, 0.0\n        else:\n            lambdas = np.linalg.solve(M, b)\n            lambda_1, lambda_2 = lambdas[0], lambdas[1]\n\n        # Calculate correction factors f_p and corrected shape s_corr\n        f_p = 1.0 + (s_lib / 2.0) * (lambda_1 + lambda_2 * Sigma_a)\n        s_corr = s_lib * f_p\n        \n        # --- Part 2: Calculate Pin Powers and Errors ---\n\n        # Calculate pin power vectors\n        P_ref = phi_SPH * s_ref * Sigma_f * A_p\n        P_pre = phi_pre * s_lib * Sigma_f * A_p\n        P_sph_corr = phi_SPH * s_corr * Sigma_f * A_p\n\n        # Define RMS error function\n        def rms_error(P1, P2):\n            norm_diff = np.linalg.norm(P1 - P2)\n            norm_ref = np.linalg.norm(P2)\n            if norm_ref == 0:\n                return 0.0 if norm_diff == 0 else np.inf\n            return norm_diff / norm_ref\n\n        # Compute errors\n        eps_pre = rms_error(P_pre, P_ref)\n        eps_corr = rms_error(P_sph_corr, P_ref)\n\n        # Compute error reduction\n        delta_eps = eps_pre - eps_corr\n        results.append(delta_eps)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}