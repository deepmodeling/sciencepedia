{
    "hands_on_practices": [
        {
            "introduction": "Before utilizing scattering matrices in complex reactor simulations, we must first ensure they are physically meaningful. A matrix that violates fundamental principles such as particle conservation or detailed balance will produce unphysical results. This practice  guides you through the essential process of verification and validation, where you will implement checks to confirm that a given scattering matrix adheres to these critical physical laws.",
            "id": "4259640",
            "problem": "You are to implement a Verification and Validation (VV) program for multigroup neutron scattering matrices in nuclear reactor simulation. The physical context is the multigroup approximation of the steady-state neutron balance derived from the Boltzmann transport equation, in which the scattering source term is discretized by energy groups. Let there be $G$ energy groups with representative energies $\\{E_g\\}_{g=1}^G$. Let $\\mathbf{S}$ be the scattering matrix where the entry $S_{g',g}$ represents the group transfer cross section from source group $g$ to destination group $g'$, with units $\\mathrm{cm^{-1}}$. The total scattering cross section for group $g$ is $\\sigma_s^g$ with units $\\mathrm{cm^{-1}}$.\n\nFrom first principles:\n- The neutron number density and collision rates are nonnegative, implying $S_{g',g} \\ge 0$.\n- Conservation of scattering out of a group requires the sum of transfers from source group $g$ equals the total scattering cross section of that group, i.e., $\\sum_{g'=1}^G S_{g',g} = \\sigma_s^g$.\n- In high-energy (fast) groups, energy loss per collision is dominantly positive (energy decreases), so upscattering is negligible compared to downscattering.\n- In thermal equilibrium with a moderator at temperature $T$, microscopic reversibility and time-reversal invariance (detailed balance) imply that the scattering kernel is symmetric under weighting by the equilibrium neutron flux. In the multigroup setting, this yields a reciprocity condition for groups within the thermal energy range:\n$$\n\\phi^{\\mathrm{eq}}(E_g) \\, S_{h,g} \\approx \\phi^{\\mathrm{eq}}(E_h) \\, S_{g,h}, \\quad \\text{for thermal } g,h,\n$$\nwhere the equilibrium neutron flux is proportional to speed times the Maxwell-Boltzmann number density, $\\phi^{\\mathrm{eq}}(E) \\propto v(E)\\, e^{-E/(k_B T)}$, and with $v(E) \\propto \\sqrt{E}$ for nonrelativistic neutrons. Thus one may take\n$$\n\\phi^{\\mathrm{eq}}(E) = \\sqrt{E} \\, \\exp\\!\\left(-\\frac{E}{k_B T}\\right).\n$$\n\nYour task is to write a program to check the following properties of a given scattering matrix:\n1. Nonnegativity: $S_{g',g} \\ge 0$ for all $g',g$.\n2. Column-sum conservation: $\\sum_{g'} S_{g',g} = \\sigma_s^g$ for all $g$, within an absolute tolerance $\\epsilon$.\n3. Fast-group upscattering negligibility: for each source group $g$ with $E_g \\ge E_c$, the ratio\n$$\nr_g = \\frac{\\sum_{g':\\, E_{g'} > E_g} S_{g',g}}{\\sigma_s^g}\n$$\nmust satisfy $r_g \\le r_{\\max}$.\n4. Thermal reciprocity (detailed balance): for all ordered pairs $(g,h)$ with $g \\ne h$ and $E_g \\le E_{\\mathrm{th,max}}$, $E_h \\le E_{\\mathrm{th,max}}$, the weighted symmetry\n$$\n\\phi^{\\mathrm{eq}}(E_g) \\, S_{h,g} \\approx \\phi^{\\mathrm{eq}}(E_h) \\, S_{g,h}\n$$\nmust hold within a relative tolerance $\\delta$. Use the Boltzmann constant $k_B = 8.617333262145 \\times 10^{-5} \\, \\mathrm{eV/K}$.\n\nImplement these checks in a general function and then evaluate the following five test cases. In all cases, use $G = 4$ groups, energies in electronvolts (eV), temperature in Kelvin (K), and cross sections in $\\mathrm{cm^{-1}}$. Use $\\epsilon = 10^{-10}$, $\\delta = 10^{-10}$, $E_c = 1000$ eV, and $E_{\\mathrm{th,max}} = 0.1$ eV. Use $r_{\\max} = 10^{-3}$.\n\nTest suite specifications:\n- Test case 1 (happy path):\n  - Energies: $E = [2 \\times 10^6,\\, 5 \\times 10^5,\\, 0.05,\\, 0.02]$ eV.\n  - Temperature: $T = 300$ K.\n  - Total scattering: $\\sigma_s = [0.8,\\, 0.7,\\, 0.5,\\, 0.4]$ $\\mathrm{cm^{-1}}$.\n  - Scattering matrix $\\mathbf{S}$: Let $x = 0.2$ and $y = \\left(\\frac{\\phi^{\\mathrm{eq}}(E_3)}{\\phi^{\\mathrm{eq}}(E_4)}\\right) x$ at $T=300$ K. The matrix is:\n  $$\n  \\mathbf{S} = \\begin{pmatrix}\n  0.0  0.0  0.0  0.0 \\\\\n  0.3  0.0  0.0  0.0 \\\\\n  0.3  0.4  0.5-x  y \\\\\n  0.2  0.3  x  0.4-y\n  \\end{pmatrix}\n  $$\n- Test case 2 (nonnegativity violation):\n  - Same as test case 1, but with $S_{4,2} = -0.01$ (transfer from group 2 to 4).\n- Test case 3 (column-sum conservation violation):\n  - Same as test case 1, but with $S_{4,1} = 0.201$ (transfer from group 1 to 4).\n- Test case 4 (thermal reciprocity violation):\n  - Same as test case 1, but modify the transfer from group 4 to 3, $S_{3,4} = 1.2\\, y$, and adjust $S_{4,4} = 0.4 - 1.2\\, y$ to maintain column sum.\n- Test case 5 (fast upscattering violation):\n  - Same as test case 1, but modify column 2 (transfers from group 2) to be $[S_{1,2}, S_{2,2}, S_{3,2}, S_{4,2}] = [0.01,\\, 0.0,\\, 0.39,\\, 0.3]$.\n\nYour program should produce a single line of output containing the results (pass/fail for each test case) as a comma-separated list enclosed in square brackets, where each result is a boolean. For example: $[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True}, \\mathrm{False}, \\mathrm{True} ]$. No additional text should be printed.",
            "solution": "The problem statement has been evaluated and is determined to be **valid**.\n\nIt is scientifically grounded, deriving its requirements from fundamental principles of neutron transport physics within the multigroup approximation method, a standard technique in nuclear reactor analysis. The principles of nonnegativity of cross sections, conservation of particles in scattering events, dominant energy loss (downscattering) for fast neutrons, and detailed balance (reciprocity) for thermal neutrons are all well-established and correctly stated. The matrix convention used (where $S_{g',g}$ represents transfer from source group $g$ to destination group $g'$ with column-sum conservation) is standard in the field and consistent with the main body of the article.\n\nThe problem is well-posed. It provides all necessary data, constants (e.g., `$k_B$`), and definitions (e.g., `$\\phi^{\\mathrm{eq}}(E)$`) for the task. The validation criteria are specified with unambiguous quantitative thresholds and tolerances (`$\\epsilon, \\delta, E_c, E_{\\mathrm{th,max}}, r_{\\max}$`). The test cases are explicitly defined, enabling a unique and verifiable solution.\n\nThe language used is objective and precise, free from any subjective or ambiguous terminology. All elements of the problem are formalizable into a computational algorithm. The construction of the test cases is consistent and serves to rigorously test each of the specified validation criteria.\n\nTherefore, the problem is sound and admits a formal solution.\n\nThe solution will be implemented as a Python program that defines a primary validation function. This function will perform four sequential checks on a given scattering matrix and its related physical parameters. The program will then construct and evaluate five specific test cases as defined in the problem description, reporting a boolean result for each.\n\nThe core of the solution is a function, `validate_scattering_matrix`, which takes as input the scattering matrix `$S$`, the vector of total scattering cross sections `$\\sigma_s$`, the vector of group energies `$E$`, the moderator temperature `$T$`, and the validation parameters `$\\epsilon, \\delta, E_c, E_{\\mathrm{th,max}}, r_{\\max}$`. This function sequentially performs the four required checks.\n\n1.  **Nonnegativity Check**: This check enforces the physical principle that cross sections, which are related to interaction probabilities, cannot be negative. The condition is `$S_{g',g} \\ge 0$` for all group indices `$g, g'$`. This is implemented by verifying that all elements of the input matrix `$S$` are greater than or equal to zero.\n\n2.  **Column-Sum Conservation Check**: This check enforces the conservation of neutrons during the scattering process. For any initial source group `$g$`, the sum of all cross sections for scattering into any final destination group `$g'$` (including in-scattering to group `$g$` itself) must equal the total scattering cross section `$\\sigma_s^g$` for that source group. The condition is `$\\left| \\left( \\sum_{g'=1}^G S_{g',g} \\right) - \\sigma_s^g \\right| \\le \\epsilon$`, where `$\\epsilon$` is a small absolute tolerance to account for floating-point inaccuracies. This is implemented by computing the sum of each column of the matrix `$S$` and comparing it to the corresponding element in the `$\\sigma_s$` vector.\n\n3.  **Fast-Group Upscattering Check**: This check is based on the kinematics of neutron scattering. High-energy (fast) neutrons predominantly lose energy (downscatter) upon colliding with moderator nuclei. Gaining energy (upscattering) is a rare event. The check quantifies this by identifying \"fast\" source groups (where `$E_g \\ge E_c$`) and ensuring that the fraction of scattering events that result in upscattering is negligible. The upscattering ratio for a fast source group `$g$` is defined as `$r_g = (\\sum_{g': E_{g'} > E_g} S_{g',g}) / \\sigma_s^g$`. This ratio must not exceed a specified maximum, `$r_g \\le r_{\\max}$`. Note that if `$\\sigma_s^g = 0$`, then all `$S_{g',g}` must also be zero for the conservation and nonnegativity properties to hold, making `$r_g = 0/0$`, which is physically interpreted as `$0$`. The implementation iterates through all source groups, identifies fast groups based on the energy threshold `$E_c$`, calculates `$r_g$`, and compares it to `$r_{\\max}$`.\n\n4.  **Thermal Reciprocity Check**: This check validates the principle of detailed balance, which arises from time-reversal invariance in systems at thermal equilibrium. For neutrons in the thermal energy range (where `$E_g, E_h \\le E_{\\mathrm{th,max}}$`), the rates of scattering from group `$g$` to `$h$` and from `$h$` to `$g$` are related by the equilibrium flux spectrum, `$\\phi^{\\mathrm{eq}}(E)$`. The condition is `$\\phi^{\\mathrm{eq}}(E_g) S_{h,g} \\approx \\phi^{\\mathrm{eq}}(E_h) S_{g,h}`. The equilibrium flux is given by `$\\phi^{\\mathrm{eq}}(E) = \\sqrt{E} \\exp(-E/(k_B T))$`. The check is implemented by identifying all pairs of distinct thermal groups `$(g,h)$` and verifying that the reciprocity relation holds within a specified relative tolerance `$\\delta$`. A robust numerical comparison, such as `$\\left| L - R \\right| \\le \\delta \\cdot \\max(\\left|L\\right|, \\left|R\\right|)$` where `$L = \\phi^{\\mathrm{eq}}(E_g) S_{h,g}$` and `$R = \\phi^{\\mathrm{eq}}(E_h) S_{g,h}$`, is used to handle potential floating-point issues and division by zero.\n\nThe main program defines the five test cases. A base matrix is constructed for the first test case, which is designed to pass all checks. The remaining four cases are constructed by making specific modifications to the base case, with each modification designed to cause a specific check to fail. The validation function is called for each case, and the boolean results are aggregated into a list for final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef validate_scattering_matrix(S, sigma_s, E, T, G, epsilon, delta, E_c, r_max, E_th_max, k_B):\n    \"\"\"\n    Performs Verification and Validation checks on a multigroup scattering matrix.\n    Matrix convention: S[g', g] is transfer from source group g to destination g'.\n    \n    Returns True if all checks pass, False otherwise.\n    \"\"\"\n    \n    # Check 1: Nonnegativity\n    if not np.all(S >= 0):\n        return False\n        \n    # Check 2: Column-sum conservation\n    col_sums = np.sum(S, axis=0)\n    if not np.all(np.abs(col_sums - sigma_s) = epsilon):\n        return False\n        \n    # Check 3: Fast-group upscattering negligibility\n    # For each source group g\n    for g in range(G):\n        if E[g] >= E_c: # This is a fast source group\n            upscatter_sum = 0.0\n            # Sum over destination groups gp with higher energy\n            for gp in range(G):\n                if E[gp] > E[g]:\n                    upscatter_sum += S[gp, g]\n            \n            if sigma_s[g] > 0:\n                ratio = upscatter_sum / sigma_s[g]\n                if ratio > r_max:\n                    return False\n            # If sigma_s[g] is 0, upscatter_sum must also be 0, so ratio is 0.\n\n    # Check 4: Thermal reciprocity (detailed balance)\n    kBT = k_B * T\n    def phi_eq(energy):\n        if energy = 0: return 0.0 # Avoid math domain error for sqrt\n        return np.sqrt(energy) * np.exp(-energy / kBT)\n\n    thermal_group_indices = [g for g in range(G) if E[g] = E_th_max]\n    \n    for i in range(len(thermal_group_indices)):\n        for j in range(i + 1, len(thermal_group_indices)):\n            g = thermal_group_indices[i]\n            h = thermal_group_indices[j]\n            \n            phi_g = phi_eq(E[g])\n            phi_h = phi_eq(E[h])\n            \n            # lhs: rate g->h, rhs: rate h->g\n            # S[h,g] is transfer from g to h\n            lhs = phi_g * S[h, g]\n            # S[g,h] is transfer from h to g\n            rhs = phi_h * S[g, h]\n            \n            denominator = max(np.abs(lhs), np.abs(rhs))\n            \n            if denominator > 0:\n                relative_diff = np.abs(lhs - rhs) / denominator\n                if relative_diff > delta:\n                    return False\n            # If denominator is 0, then lhs and rhs are 0, so they are equal.\n\n    return True\n\ndef solve():\n    # Define problem constants and parameters\n    G = 4\n    epsilon = 1e-10\n    delta = 1e-10\n    E_c = 1000.0  # eV\n    r_max = 1e-3\n    E_th_max = 0.1  # eV\n    k_B = 8.617333262145e-5  # eV/K\n\n    # Base parameters for the test cases\n    E_base = np.array([2e6, 5e5, 0.05, 0.02])\n    T_base = 300.0\n    sigma_s_base = np.array([0.8, 0.7, 0.5, 0.4])\n\n    def get_base_matrix():\n        S = np.zeros((G, G))\n        \n        x = 0.2\n        kBT = k_B * T_base\n        phi_E3 = np.sqrt(E_base[2]) * np.exp(-E_base[2] / kBT)\n        phi_E4 = np.sqrt(E_base[3]) * np.exp(-E_base[3] / kBT)\n        y = (phi_E3 / phi_E4) * x\n        \n        # Matrix S[g', g] where g is source, g' is destination\n        # Column g=1 (from group 1)\n        S[:, 0] = [0.0, 0.3, 0.3, 0.2]\n        # Column g=2 (from group 2)\n        S[:, 1] = [0.0, 0.0, 0.4, 0.3]\n        # Column g=3 (from group 3)\n        S[:, 2] = [0.0, 0.0, 0.5 - x, x]\n        # Column g=4 (from group 4)\n        S[:, 3] = [0.0, 0.0, y, 0.4 - y]\n        \n        return S\n\n    # Prepare list of test cases\n    test_cases = []\n    \n    # Test case 1 (happy path)\n    s1 = get_base_matrix()\n    test_cases.append((s1, sigma_s_base, E_base, T_base))\n\n    # Test case 2 (nonnegativity violation)\n    s2 = get_base_matrix()\n    s2[3, 1] = -0.01  # S_4,2 (from 2 to 4) = -0.01\n    test_cases.append((s2, sigma_s_base, E_base, T_base))\n\n    # Test case 3 (column-sum conservation violation)\n    s3 = get_base_matrix()\n    s3[3, 0] = 0.201 # S_4,1 (from 1 to 4) = 0.201\n    test_cases.append((s3, sigma_s_base, E_base, T_base))\n    \n    # Test case 4 (thermal reciprocity violation)\n    s4 = get_base_matrix()\n    x = 0.2\n    kBT = k_B * T_base\n    phi_E3 = np.sqrt(E_base[2]) * np.exp(-E_base[2] / kBT)\n    phi_E4 = np.sqrt(E_base[3]) * np.exp(-E_base[3] / kBT)\n    y = (phi_E3 / phi_E4) * x\n    s4[2, 3] = 1.2 * y  # S_3,4 (from 4 to 3) = 1.2 * y\n    s4[3, 3] = 0.4 - 1.2 * y # S_4,4 adjusted to conserve column sum\n    test_cases.append((s4, sigma_s_base, E_base, T_base))\n\n    # Test case 5 (fast upscattering violation)\n    s5 = get_base_matrix()\n    # Modify column 2 (from group 2)\n    s5[:, 1] = [0.01, 0.0, 0.39, 0.3]\n    test_cases.append((s5, sigma_s_base, E_base, T_base))\n\n    # Run validation for all test cases\n    results = []\n    for case in test_cases:\n        S, sigma_s, E, T = case\n        is_valid = validate_scattering_matrix(S, sigma_s, E, T, G, epsilon, delta, E_c, r_max, E_th_max, k_B)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Multigroup scattering matrices are practical approximations derived from the underlying continuous-energy physics of neutron interactions. This exercise  provides direct experience with this crucial homogenization process. By integrating a given double-differential scattering kernel over specified energy groups, you will construct a group-to-group upscattering cross section, gaining insight into how the abstract theory of scattering is translated into the concrete numerical data used in simulations.",
            "id": "4259645",
            "problem": "Consider a homogeneous moderator in steady-state neutron transport where scattering is modeled by a double-differential microscopic scattering cross section. The microscopic scattering source term in the linear Boltzmann equation is defined by\n$$\nQ_{s}(E,\\Omega) \\;=\\; \\int_{0}^{\\infty} \\int_{4\\pi} \\frac{d^{2}\\sigma_{s}}{dE \\, d\\Omega}(E' \\rightarrow E, \\Omega' \\rightarrow \\Omega) \\, \\phi(E',\\Omega') \\, d\\Omega' \\, dE' ,\n$$\nwhere $E$ and $E'$ are the outgoing and incoming neutron energies, respectively, $\\Omega$ and $\\Omega'$ are the corresponding directions, $\\phi(E',\\Omega')$ is the angular flux, and $\\frac{d^{2}\\sigma_{s}}{dE \\, d\\Omega}$ is the double-differential microscopic scattering cross section. Assume isotropic scattering in the laboratory frame, so that\n$$\n\\frac{d^{2}\\sigma_{s}}{dE \\, d\\Omega}(E' \\rightarrow E, \\Omega' \\rightarrow \\Omega) \\;=\\; \\frac{\\Sigma_{s}^{0}(E')}{4\\pi} \\, K(E;E') ,\n$$\nwhere $\\Sigma_{s}^{0}(E')$ is the total microscopic scattering cross section for incoming energy $E'$, and $K(E;E')$ is an energy-transfer kernel normalized as $\\int_{0}^{\\infty} K(E;E') \\, dE \\,=\\, 1$. Consider a two-group energy structure defined by\n- Group $1$: $E' \\in [0,\\, 0.5]$ eV,\n- Group $2$: $E \\in [0.5,\\, \\infty)$ eV,\nand a flat flux-weighting function in the incoming group, $w(E') = 1$, with group normalization\n$$\nW_{1} \\;=\\; \\int_{0}^{0.5} w(E') \\, dE' \\;=\\; 0.5 \\;\\text{eV}.\n$$\nThe energy-transfer kernel is specified to capture both downscattering and upscattering with a simple, physically plausible mixture,\n$$\nK(E;E') \\;=\\; p \\, \\frac{H(E' - E)}{E'} \\;+\\; (1-p) \\, \\lambda \\, \\exp\\!\\big(-\\lambda (E - E')\\big) \\, H(E - E') ,\n$$\nwhere $H(\\cdot)$ is the Heaviside function, $p \\in [0,1]$ is the downscattering fraction, and $\\lambda  0$ is an energy-decay parameter controlling the upscattering tail. In this moderator, take $\\Sigma_{s}^{0}(E') = 4$ barns for all $E' \\in [0,\\, 0.5]$ eV, $p = 0.8$, and $\\lambda = 2$ eV$^{-1}$. Starting from the definition of the microscopic scattering source and the multigroup flux-weighted transfer matrix, construct the isotropic ($l=0$ Legendre moment) upscattering transfer matrix element from Group $1$ to Group $2$, denoted $\\Sigma_{s,1 \\rightarrow 2}^{(0)}$, as an energy-and-angle integral of the given double-differential cross section averaged over the incoming group with the specified weighting. Then evaluate this element exactly. Express the final value in barns. Round your answer to $4$ significant figures.",
            "solution": "The user wants me to solve a problem.\n\nThe problem is considered valid.\n\n### Step 1: Formal Definition of the Multigroup Transfer Cross Section\nThe problem asks for the evaluation of the isotropic ($l=0$) group-to-group scattering cross section, which transfers neutrons from energy group $g'$ to group $g$. The general definition for the $l$-th Legendre moment of this cross section, averaged over the source group $g'$ with a weighting function $w(E')$, is:\n$$\n\\Sigma_{s,g' \\rightarrow g}^{(l)} = \\frac{\\int_{E' \\in g'} w(E') \\int_{E \\in g} \\Sigma_{s}^{(l)}(E' \\rightarrow E) \\, dE \\, dE'}{\\int_{E' \\in g'} w(E') \\, dE'}\n$$\nwhere $\\Sigma_{s}^{(l)}(E' \\rightarrow E)$ is the $l$-th Legendre moment of the differential energy-transfer cross section. The denominator is the normalization factor for the source group, denoted $W_{g'}$.\n\nFor this problem, we are interested in the isotropic component, so $l=0$. The transfer is from Group $1$ to Group $2$, so $g'=1$ and $g=2$. The problem provides the following specifics:\n- Source Group $1$: $E' \\in [0, 0.5]$ eV.\n- Destination Group $2$: $E \\in [0.5, \\infty)$ eV.\n- Weighting function: $w(E') = 1$ for $E' \\in [0, 0.5]$ eV.\n- Normalization factor: $W_{1} = \\int_{0}^{0.5} (1) \\, dE' = 0.5$ eV.\n\nThe expression for the desired cross section, $\\Sigma_{s,1 \\rightarrow 2}^{(0)}$, is:\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = \\frac{1}{W_{1}} \\int_{0}^{0.5} w(E') \\int_{0.5}^{\\infty} \\Sigma_{s}^{(0)}(E' \\rightarrow E) \\, dE \\, dE'\n$$\n\n### Step 2: Determine the Isotropic Energy-Transfer Kernel $\\Sigma_{s}^{(0)}(E' \\rightarrow E)$\nThe problem states that scattering is isotropic in the laboratory frame. The double-differential microscopic cross section is given as:\n$$\n\\frac{d^{2}\\sigma_{s}}{dE \\, d\\Omega}(E' \\rightarrow E, \\Omega' \\rightarrow \\Omega) = \\frac{\\Sigma_{s}^{0}(E')}{4\\pi} \\, K(E;E')\n$$\nThe problem uses the notation $\\Sigma_s^0(E')$ for what is functionally a microscopic cross section, as the final answer is requested in barns. We will proceed with this notation. The isotropic energy-transfer kernel, $\\Sigma_{s}^{(0)}(E' \\rightarrow E)$, is obtained by integrating the double-differential cross section over all outgoing solid angles $\\Omega$:\n$$\n\\Sigma_{s}^{(0)}(E' \\rightarrow E) = \\int_{4\\pi} \\frac{d^{2}\\sigma_{s}}{dE \\, d\\Omega}(E' \\rightarrow E, \\Omega' \\rightarrow \\Omega) \\, d\\Omega\n$$\nSubstituting the given expression:\n$$\n\\Sigma_{s}^{(0)}(E' \\rightarrow E) = \\int_{4\\pi} \\left( \\frac{\\Sigma_{s}^{0}(E')}{4\\pi} \\, K(E;E') \\right) d\\Omega\n$$\nSince the integrand is independent of the angle $\\Omega$, the integral over $4\\pi$ steradians is simply the integrand multiplied by $4\\pi$.\n$$\n\\Sigma_{s}^{(0)}(E' \\rightarrow E) = \\left( \\frac{\\Sigma_{s}^{0}(E')}{4\\pi} \\, K(E;E') \\right) \\times 4\\pi = \\Sigma_{s}^{0}(E') \\, K(E;E')\n$$\n\n### Step 3: Set Up the Specific Integral for $\\Sigma_{s,1 \\rightarrow 2}^{(0)}$\nWe can now assemble the complete integral for $\\Sigma_{s,1 \\rightarrow 2}^{(0)}$ by substituting all the given information:\n- $W_{1} = 0.5$ eV\n- $w(E') = 1$\n- $\\Sigma_{s}^{(0)}(E' \\rightarrow E) = \\Sigma_{s}^{0}(E') \\, K(E;E')$\n- $\\Sigma_{s}^{0}(E') = 4$ barns for $E' \\in [0, 0.5]$ eV\n- $K(E;E') = p \\, \\frac{H(E' - E)}{E'} + (1-p) \\, \\lambda \\, \\exp\\!\\big(-\\lambda (E - E')\\big) \\, H(E - E')$, with $p = 0.8$ and $\\lambda = 2$ eV$^{-1}$.\n\nThe integral becomes:\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = \\frac{1}{0.5} \\int_{0}^{0.5} (1) \\int_{0.5}^{\\infty} \\left( 4 \\cdot K(E;E') \\right) \\, dE \\, dE'\n$$\nThe integration domain is for $E' \\in [0, 0.5]$ and $E \\in [0.5, \\infty)$. In this entire domain, the outgoing energy $E$ is always greater than the incoming energy $E'$. This means $E > E'$ or $E - E' > 0$. We analyze the Heaviside functions in the kernel $K(E;E')$ under this condition:\n- The downscattering term contains $H(E' - E)$. Since $E' - E  0$, $H(E' - E) = 0$. This term vanishes.\n- The upscattering term contains $H(E - E')$. Since $E - E' > 0$, $H(E - E') = 1$. This term is retained.\n\nTherefore, for the transfer from Group $1$ to Group $2$, the only relevant part of the kernel is the upscattering component:\n$$\nK(E;E') = (1-p) \\, \\lambda \\, \\exp\\!\\big(-\\lambda (E - E')\\big)\n$$\nSubstituting this simplified kernel into our integral:\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = \\frac{4}{0.5} \\int_{0}^{0.5} \\int_{0.5}^{\\infty} \\left( (1-p) \\, \\lambda \\, \\exp\\!\\big(-\\lambda (E - E')\\big) \\right) \\, dE \\, dE'\n$$\nPlugging in the numerical values $p = 0.8$ and $\\lambda = 2$:\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = 8 \\int_{0}^{0.5} \\int_{0.5}^{\\infty} \\left( (1 - 0.8) \\cdot 2 \\cdot \\exp\\!\\big(-2 (E - E')\\big) \\right) \\, dE \\, dE'\n$$\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = 8 \\int_{0}^{0.5} \\int_{0.5}^{\\infty} 0.4 \\cdot \\exp(-2E) \\exp(2E') \\, dE \\, dE'\n$$\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = 3.2 \\int_{0}^{0.5} \\exp(2E') \\left( \\int_{0.5}^{\\infty} \\exp(-2E) \\, dE \\right) dE'\n$$\n\n### Step 4: Evaluate the Integral\nWe first evaluate the inner integral with respect to $E$:\n$$\n\\int_{0.5}^{\\infty} \\exp(-2E) \\, dE = \\left[ -\\frac{1}{2} \\exp(-2E) \\right]_{E=0.5}^{\\infty} = 0 - \\left( -\\frac{1}{2} \\exp(-2 \\cdot 0.5) \\right) = \\frac{1}{2} \\exp(-1)\n$$\nNow, substitute this result back into the expression for $\\Sigma_{s,1 \\rightarrow 2}^{(0)}$:\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = 3.2 \\int_{0}^{0.5} \\exp(2E') \\left( \\frac{1}{2} \\exp(-1) \\right) dE' = 1.6 \\, \\exp(-1) \\int_{0}^{0.5} \\exp(2E') \\, dE'\n$$\nNext, we evaluate the outer integral with respect to $E'$:\n$$\n\\int_{0}^{0.5} \\exp(2E') \\, dE' = \\left[ \\frac{1}{2} \\exp(2E') \\right]_{E'=0}^{0.5} = \\frac{1}{2} \\left( \\exp(2 \\cdot 0.5) - \\exp(2 \\cdot 0) \\right) = \\frac{1}{2} (\\exp(1) - \\exp(0)) = \\frac{1}{2} (e - 1)\n$$\nFinally, we combine all parts to find the exact value of $\\Sigma_{s,1 \\rightarrow 2}^{(0)}$:\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = 1.6 \\, \\exp(-1) \\cdot \\frac{1}{2} (e - 1) = 0.8 \\, \\exp(-1) (e - 1) = 0.8 \\left( \\frac{e - 1}{e} \\right) = 0.8 \\left( 1 - \\frac{1}{e} \\right)\n$$\nThe units of this cross section are barns, inherited from $\\Sigma_{s}^{0}(E')$.\n\n### Step 5: Numerical Calculation\nThe problem requires a numerical answer rounded to $4$ significant figures. We calculate the value of the analytical expression:\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} = 0.8 \\left( 1 - \\exp(-1) \\right)\n$$\nUsing the value $e \\approx 2.71828$:\n$$\n\\exp(-1) \\approx 0.36787944\n$$\n$$\n1 - \\exp(-1) \\approx 1 - 0.36787944 = 0.63212056\n$$\n$$\n\\Sigma_{s,1 \\rightarrow 2}^{(0)} \\approx 0.8 \\times 0.63212056 = 0.50569645 \\text{ barns}\n$$\nRounding this result to $4$ significant figures, we get $0.5057$.",
            "answer": "$$\n\\boxed{0.5057}\n$$"
        },
        {
            "introduction": "The structural difference between a purely downscattering matrix and one that includes upscattering is a defining factor in the performance of numerical solvers. This practice  explores the computational consequences of upscattering on the convergence of the classical source iteration method. By calculating the spectral radius of the iteration matrix, you will quantitatively measure this impact and understand why the presence of upscattering necessitates more sophisticated solution algorithms in reactor physics codes.",
            "id": "4235000",
            "problem": "Consider the steady-state multigroup neutron diffusion balance in a single homogeneous spatial cell with three energy groups. The algebraic form of the balance for group $g \\in \\{1,2,3\\}$ is given by\n$$\n\\left(\\Sigma_{r,g} + D_g B^2\\right)\\,\\phi_g \\;=\\; \\sum_{g' \\neq g} \\Sigma_{s,\\,g \\leftarrow g'}\\,\\phi_{g'} \\;+\\; Q_g,\n$$\nwhere $D_g$ is the diffusion coefficient (in meters), $B^2$ is the geometric buckling (in inverse square meters), $\\Sigma_{r,g}$ is the removal macroscopic cross section (in inverse meters), $\\Sigma_{s,\\,g \\leftarrow g'}$ is the scattering macroscopic cross section from group $g'$ into group $g$ (in inverse meters), and $Q_g$ is an external source (in inverse meters). Define the diagonal matrix\n$$\nA \\;=\\; \\mathrm{diag}\\!\\left(\\Sigma_{r,1}+D_1 B^2,\\; \\Sigma_{r,2}+D_2 B^2,\\; \\Sigma_{r,3}+D_3 B^2\\right),\n$$\nand the off-diagonal scattering matrix $S$ with entries $S_{g,g'} = \\Sigma_{s,\\,g \\leftarrow g'}$ for $g \\neq g'$ and $S_{g,g} = 0$. The classical source iteration update can be written as\n$$\n\\boldsymbol{\\phi}^{(k+1)} \\;=\\; A^{-1} S \\,\\boldsymbol{\\phi}^{(k)} \\;+\\; A^{-1} \\boldsymbol{Q}.\n$$\nThe convergence rate of source iteration is governed by the spectral radius\n$$\n\\rho\\!\\left(A^{-1} S\\right) \\;=\\; \\max_i \\left|\\lambda_i\\!\\left(A^{-1} S\\right)\\right|,\n$$\nwhere $\\lambda_i(\\cdot)$ denotes the eigenvalues of the matrix argument.\n\nYour task is to write a complete, runnable program that computes the spectral radius $\\rho\\!\\left(A^{-1} S\\right)$ for each of the following four test cases. Each test case specifies the diffusion coefficients, geometric buckling, removal cross sections, and scattering matrix. All diffusion coefficients $D_g$ are given in meters, all cross sections ($\\Sigma_{r,g}$ and all entries of $S$) are given in inverse meters, and $B^2$ is given in inverse square meters. The spectral radius is dimensionless and must be reported as a float rounded to six decimal places.\n\nTest case 1 (no upscatter, strictly downscatter):\n- $D = [1.0,\\;0.8,\\;0.6]$ meters\n- $B^2 = 0.01$ inverse square meters\n- $\\Sigma_r = [0.4,\\;0.25,\\;0.15]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.0  0.0 \\\\\n0.14  0.0  0.0 \\\\\n0.03  0.09  0.0\n\\end{bmatrix}$ inverse meters\n\nTest case 2 (mild upscatter):\n- $D = [1.0,\\;0.8,\\;0.6]$ meters\n- $B^2 = 0.01$ inverse square meters\n- $\\Sigma_r = [0.4,\\;0.25,\\;0.15]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.01  0.005 \\\\\n0.14  0.0  0.02 \\\\\n0.03  0.09  0.0\n\\end{bmatrix}$ inverse meters\n\nTest case 3 (strong upscatter):\n- $D = [1.0,\\;0.8,\\;0.6]$ meters\n- $B^2 = 0.01$ inverse square meters\n- $\\Sigma_r = [0.4,\\;0.25,\\;0.15]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.06  0.03 \\\\\n0.16  0.0  0.07 \\\\\n0.035  0.10  0.0\n\\end{bmatrix}$ inverse meters\n\nTest case 4 (near a challenging regime with significant upscatter and reduced leakage/removal):\n- $D = [1.4,\\;1.1,\\;0.7]$ meters\n- $B^2 = 0.003$ inverse square meters\n- $\\Sigma_r = [0.22,\\;0.16,\\;0.10]$ inverse meters\n- $S = \\begin{bmatrix}\n0.0  0.07  0.035 \\\\\n0.10  0.0  0.05 \\\\\n0.03  0.07  0.0\n\\end{bmatrix}$ inverse meters\n\nProgram requirements:\n- For each test case, construct $A$ and $S$, form $M = A^{-1} S$, and compute $\\rho(M)$ as the maximum absolute value of the eigenvalues of $M$.\n- Express each spectral radius as a float rounded to six decimal places (dimensionless).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4]\"), where $r_i$ corresponds to the spectral radius for test case $i$ in the order listed.\n\nAdditionally, in your solution, explain from first principles why upscattering modifies the matrix structure in a way that increases $\\rho\\!\\left(A^{-1}S\\right)$ and why a preconditioning strategy that treats the upscatter implicitly can be necessary to restore rapid convergence when $\\rho\\!\\left(A^{-1}S\\right)$ approaches one. No physical angles are involved in this problem, so no angle unit specification is needed.",
            "solution": "The problem asks for the computation of the spectral radius of the source iteration matrix for the multigroup neutron diffusion equation under various scattering conditions, and for a theoretical explanation of the impact of upscattering on convergence.\n\nThe steady-state multigroup diffusion equation for a homogeneous medium can be written in matrix form. For a vector of group fluxes $\\boldsymbol{\\phi} = [\\phi_1, \\phi_2, \\dots, \\phi_G]^T$ and an external source vector $\\boldsymbol{Q} = [Q_1, Q_2, \\dots, Q_G]^T$, the balance equation is:\n$$\n(L+R)\\boldsymbol{\\phi} = S\\boldsymbol{\\phi} + \\boldsymbol{Q}\n$$\nHere, $L$ is a matrix representing neutron loss due to leakage, and $R$ is a matrix representing neutron loss due to removal (absorption and out-of-group scattering). $S$ is the in-scattering matrix. In this problem, the total loss operator is given by the diagonal matrix $A$, where its diagonal elements are $A_{gg} = \\Sigma_{r,g} + D_g B^2$. This term combines removal within group $g$, characterized by the macroscopic removal cross section $\\Sigma_{r,g}$, and leakage out of the spatial domain for group $g$, approximated by $D_g B^2$. Thus, $A \\equiv L+R$. The matrix $S$ contains the off-diagonal scattering cross sections $\\Sigma_{s, g \\leftarrow g'}$ which represent neutrons scattering from group $g'$ into group $g$. The problem can be compactly expressed as:\n$$\nA\\boldsymbol{\\phi} = S\\boldsymbol{\\phi} + \\boldsymbol{Q}\n$$\nThe classical source iteration method solves this system by treating the entire scattering source term $S\\boldsymbol{\\phi}$ explicitly. Given an estimate of the flux vector from the previous iteration, $\\boldsymbol{\\phi}^{(k)}$, the next estimate $\\boldsymbol{\\phi}^{(k+1)}$ is found by solving:\n$$\nA\\boldsymbol{\\phi}^{(k+1)} = S\\boldsymbol{\\phi}^{(k)} + \\boldsymbol{Q}\n$$\nSince $A$ is a diagonal matrix, its inverse $A^{-1}$ is trivial to compute (it is a diagonal matrix whose elements are the reciprocals of the elements of $A$). The iteration can thus be written as:\n$$\n\\boldsymbol{\\phi}^{(k+1)} = A^{-1}S\\boldsymbol{\\phi}^{(k)} + A^{-1}\\boldsymbol{Q}\n$$\nThis is a fixed-point iteration of the form $\\boldsymbol{x}^{(k+1)} = M\\boldsymbol{x}^{(k)} + \\boldsymbol{c}$, where the iteration matrix is $M = A^{-1}S$. The convergence of such an iteration is guaranteed if the spectral radius of the iteration matrix, $\\rho(M)$, is less than $1$. The asymptotic rate of convergence is determined by $\\rho(M)$; the closer $\\rho(M)$ is to $1$, the slower the convergence. The spectral radius is defined as the maximum absolute value of the eigenvalues of the matrix: $\\rho(M) = \\max_i |\\lambda_i(M)|$.\n\nLet us analyze the structure of the iteration matrix $M$ and its dependence on scattering properties. By convention, energy groups are indexed from higher energy to lower energy (group $1$ is the fastest, group $G$ is the slowest).\n- **Downscattering**: A neutron collision results in energy loss, moving it from a higher energy group $g'$ to a lower energy group $g$ (where $g > g'$). In the scattering matrix $S$, this corresponds to non-zero entries $S_{gg'}$ in the strictly lower triangular part of the matrix.\n- **Upscattering**: A neutron collision results in energy gain, moving it from a lower energy group $g'$ to a higher energy group $g$ (where $g  g'$). This is physically significant only for thermal neutrons that gain energy from colliding with hot moderator nuclei. In the scattering matrix $S$, this corresponds to non-zero entries $S_{gg'}$ in the strictly upper triangular part of the matrix.\n\n**Impact of Upscattering on the Spectral Radius $\\rho(A^{-1}S)$**\n\n1.  **Case 1: No Upscattering (Strictly Downscatter)**\n    When only downscattering is present, the scattering matrix $S$ is strictly lower triangular. Its upper triangular and diagonal entries are all zero. The matrix $A$ is diagonal with positive entries. The iteration matrix $M = A^{-1}S$ is the product of a diagonal matrix and a strictly lower triangular matrix, which results in another strictly lower triangular matrix. A fundamental property of triangular matrices is that their eigenvalues are their diagonal elements. For a strictly lower triangular matrix, all diagonal elements are zero. Therefore, all eigenvalues of $M$ are zero, and its spectral radius is $\\rho(M) = 0$. This implies that the source iteration converges in a finite number of steps (at most $G$ iterations for a $G$-group problem), as the matrix $M$ is nilpotent ($M^G = 0$). Test Case 1 exemplifies this scenario.\n\n2.  **Case 2: Upscattering Present**\n    When upscattering occurs, the matrix $S$ has non-zero entries in its upper triangle. Consequently, the iteration matrix $M = A^{-1}S$ is no longer triangular. It possesses a more general structure with non-zero entries above and below the diagonal. This structure introduces cycles in the energy group coupling. For instance, a neutron can downscatter from group $1$ to group $2$, and then upscatter from group $2$ back to group $1$. This bidirectional coupling means that the matrix $M$ is no longer nilpotent and can have non-zero eigenvalues. The magnitude of these eigenvalues, and thus the spectral radius, depends on the strength of the coupling terms (the elements of $S$) relative to the strength of the removal terms (the diagonal elements of $A$). As the magnitude of upscattering terms in $S$ increases, or as the magnitude of removal/leakage terms in $A$ decreases (e.g., in a large, low-absorption system), the eigenvalues of $M$ tend to increase in magnitude. This leads to an increase in the spectral radius $\\rho(M)$, slowing down the convergence of the source iteration. As $\\rho(M)$ approaches $1$, the number of iterations required for convergence can become prohibitively large.\n\n**Necessity of Preconditioning for Upscatter Problems**\n\nWhen strong upscattering and low removal/leakage cause $\\rho(A^{-1}S)$ to be close to $1$, the standard source iteration is impractical. An acceleration technique, or preconditioning, is necessary. The slow convergence arises because the explicit treatment of the entire scattering matrix $S$ fails to capture the strong, implicit coupling between groups introduced by upscattering.\n\nA common and effective preconditioning strategy is to treat the problematic upscattering terms implicitly. We can split the scattering matrix $S$ into its strictly lower triangular part $S_L$ (downscattering) and its strictly upper triangular part $S_U$ (upscattering): $S = S_L + S_U$.\nThe original equation $A\\boldsymbol{\\phi} = (S_L + S_U)\\boldsymbol{\\phi} + \\boldsymbol{Q}$ can be rearranged as:\n$$\n(A - S_U)\\boldsymbol{\\phi} = S_L\\boldsymbol{\\phi} + \\boldsymbol{Q}\n$$\nThis suggests an alternative iterative scheme:\n$$\n(A - S_U)\\boldsymbol{\\phi}^{(k+1)} = S_L\\boldsymbol{\\phi}^{(k)} + \\boldsymbol{Q}\n$$\nThe update step is $\\boldsymbol{\\phi}^{(k+1)} = (A - S_U)^{-1}S_L\\boldsymbol{\\phi}^{(k)} + (A - S_U)^{-1}\\boldsymbol{Q}$. The iteration matrix for this preconditioned scheme is $M' = (A - S_U)^{-1}S_L$.\nThe matrix $(A - S_U)$ is upper triangular (since $A$ is diagonal and $S_U$ is strictly upper triangular) and its diagonal elements are the positive elements of $A$. It is therefore always invertible, and the system can be efficiently solved at each iteration step using back-substitution. By moving the upscattering term to the left-hand side, we are solving for its effects implicitly within each iteration. The resulting iteration matrix $M'$ typically has a much smaller spectral radius than the original $M = A^{-1}(S_L+S_U)$, dramatically accelerating convergence. This method effectively decouples the energy groups in the forward-solving direction, breaking the cycles that slowed down the original iteration.\n\nThe numerical calculations for the four test cases will now be performed based on the formula $\\rho(A^{-1}S)$.\nFor each case:\n1. Construct the diagonal matrix $A$ with elements $A_{gg} = \\Sigma_{r,g} + D_g B^2$.\n2. Invert $A$ to get $A^{-1}$.\n3. Form the iteration matrix $M = A^{-1} S$.\n4. Compute the eigenvalues of $M$.\n5. Find the maximum absolute value of the eigenvalues to obtain the spectral radius $\\rho(M)$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral radius for the source iteration matrix in multigroup\n    neutron diffusion for four test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"D\": np.array([1.0, 0.8, 0.6]),\n            \"B2\": 0.01,\n            \"Sigma_r\": np.array([0.4, 0.25, 0.15]),\n            \"S\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.14, 0.0, 0.0],\n                [0.03, 0.09, 0.0]\n            ])\n        },\n        {\n            \"D\": np.array([1.0, 0.8, 0.6]),\n            \"B2\": 0.01,\n            \"Sigma_r\": np.array([0.4, 0.25, 0.15]),\n            \"S\": np.array([\n                [0.0, 0.01, 0.005],\n                [0.14, 0.0, 0.02],\n                [0.03, 0.09, 0.0]\n            ])\n        },\n        {\n            \"D\": np.array([1.0, 0.8, 0.6]),\n            \"B2\": 0.01,\n            \"Sigma_r\": np.array([0.4, 0.25, 0.15]),\n            \"S\": np.array([\n                [0.0, 0.06, 0.03],\n                [0.16, 0.0, 0.07],\n                [0.035, 0.10, 0.0]\n            ])\n        },\n        {\n            \"D\": np.array([1.4, 1.1, 0.7]),\n            \"B2\": 0.003,\n            \"Sigma_r\": np.array([0.22, 0.16, 0.10]),\n            \"S\": np.array([\n                [0.0, 0.07, 0.035],\n                [0.10, 0.0, 0.05],\n                [0.03, 0.07, 0.0]\n            ])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        D = case[\"D\"]\n        B2 = case[\"B2\"]\n        Sigma_r = case[\"Sigma_r\"]\n        S = case[\"S\"]\n\n        # 1. Construct the diagonal matrix A.\n        # A_gg = Sigma_r,g + D_g * B^2\n        A_diag = Sigma_r + D * B2\n        \n        # A is a diagonal matrix.\n        # A = np.diag(A_diag)\n\n        # 2. Invert A. For a diagonal matrix, the inverse is a diagonal\n        # matrix with the reciprocal of the diagonal elements. This is more\n        # efficient than a general inversion.\n        A_inv_diag = 1.0 / A_diag\n        A_inv = np.diag(A_inv_diag)\n        \n        # 3. Form the iteration matrix M = A^-1 * S.\n        M = A_inv @ S\n\n        # 4. Compute the eigenvalues of M.\n        eigenvalues = np.linalg.eigvals(M)\n        \n        # 5. Find the spectral radius as the maximum absolute value of the eigenvalues.\n        spectral_radius = np.max(np.abs(eigenvalues))\n        \n        results.append(spectral_radius)\n\n    # Format results to six decimal places and print in the required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}