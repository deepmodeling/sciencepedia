{
    "hands_on_practices": [
        {
            "introduction": "在反应堆模拟中，我们需要的温度往往不存在于预先制备的截面库中。本练习旨在通过亲手实现基本的“在线”多普勒展宽算法，来解决这一核心问题。通过将精确的卷积计算结果与简单的线性插值进行对比，您将深刻理解为何需要发展更复杂的在线展宽技术，并掌握评估其必要性的基本方法 。",
            "id": "4239879",
            "problem": "一个核反应堆模拟程序必须在请求的温度不存在于制表库中时，实时计算中子截面的温度展宽。考虑一个在零温度下由单能级布莱特-维格纳（SLBW）形式描述的孤立共振。目标是计算在请求温度下的多普勒展宽截面，并将其与两个制表温度之间的朴素线性插值进行比较。制定并实施一个程序，对于给定测试套件中的每个案例，使用自由气体多普勒核计算共振能量处的展宽截面，并量化与线性插值的偏差。\n\n起点和定义：\n- SLBW零温度共振截面被建模为一个洛伦兹函数\n$$\n\\sigma_0(E) = \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2},\n$$\n其中 $E$ 是能量，单位为电子伏特（eV），$E_r$ 是共振能量，单位为 eV，$\\Gamma$ 是总宽度，单位为 eV，$\\sigma_\\text{peak}$ 是在 $E = E_r$ 处的峰值截面，单位为靶恩（barns）。\n- 靶核的热运动被假定服从麦克斯韦-玻尔兹曼分布，导致的多普勒展宽在能量平方根（也称为 $u$-）空间中表示为高斯卷积。定义 $u = \\sqrt{E}$，以及自由气体多普勒核\n$$\nG(u,u';T,A) = \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u)^2}{\\mu(T,A)^2}\\right),\n$$\n其中 $u$-空间中的核宽度参数为\n$$\n\\mu(T,A) = \\sqrt{\\frac{\\theta(T)}{A}},\n\\quad\n\\theta(T) = k_B T \\text{ in eV},\n$$\n$k_B$ 是玻尔兹曼常数，$A$ 是靶核与中子的质量比（无量纲）。温度 $T$ 下的展宽截面则为\n$$\n\\sigma(E,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u,u';T,A)\\, \\mathrm{d}u'.\n$$\n- 考虑的温度是 $T_1 = 800$ 开尔文（K），$T = 873$ K，和 $T_2 = 900$ K。玻尔兹曼常数必须使用电子伏特每开尔文为单位，$k_B = 8.617333262145\\times 10^{-5}$ eV/K。\n- 对于每个测试案例，截面要被评估的能量是 $E = E_r$。\n\n需要实现的任务：\n1. 使用上述基本原理，通过实时多普勒展宽（$u$-空间中的高斯卷积）计算 $\\sigma(E_r, T)$。\n2. 类似地计算 $\\sigma(E_r, T_1)$ 和 $\\sigma(E_r, T_2)$。\n3. 计算在 $T$ 处，两个制表温度之间的线性插值：\n$$\n\\sigma_\\text{lin}(E_r, T) = \\sigma(E_r, T_1) + \\frac{T - T_1}{T_2 - T_1}\\left[\\sigma(E_r, T_2) - \\sigma(E_r, T_1)\\right].\n$$\n4. 使用以下方式量化在 $E = E_r$ 处实时展宽值与线性插值之间的差异：\n   - 绝对差异，单位为靶恩，\n   $$\n   \\Delta_\\text{abs} = \\sigma(E_r, T) - \\sigma_\\text{lin}(E_r, T),\n   $$\n   - 小数形式的相对差异，\n   $$\n   \\Delta_\\text{frac} = \\frac{\\Delta_\\text{abs}}{\\sigma(E_r, T)}.\n   $$\n\n物理单位和数值报告：\n- 能量 $E$、$E_r$ 和宽度 $\\Gamma$ 的单位是电子伏特（eV）。\n- 温度 $T$ 的单位是开尔文（K）。\n- 截面和差异 $\\Delta_\\text{abs}$ 的单位是靶恩。\n- 相对差异 $\\Delta_\\text{frac}$ 必须以小数形式报告（无百分号）。\n- 所有浮点数输出均四舍五入到六位小数。\n\n测试套件：\n对于每个参数集，在 $E = E_r$ 处，使用指定的 $A$、$\\Gamma$ 和 $\\sigma_\\text{peak}$ 进行评估：\n- 案例1（重核素，窄共振，高峰值）：$A = 238$，$E_r = 6.670$ eV，$\\Gamma = 0.030$ eV，$\\sigma_\\text{peak} = 3000.0$ 靶恩。\n- 案例2（中等质量，中等宽度）：$A = 56$，$E_r = 2.000$ eV，$\\Gamma = 0.300$ eV，$\\sigma_\\text{peak} = 100.0$ 靶恩。\n- 案例3（轻核素，宽共振）：$A = 1$，$E_r = 1.000$ eV，$\\Gamma = 0.500$ eV，$\\sigma_\\text{peak} = 20.0$ 靶恩。\n- 案例4（重核素，极窄共振，非常高峰值）：$A = 238$，$E_r = 0.500$ eV，$\\Gamma = 0.001$ eV，$\\sigma_\\text{peak} = 10000.0$ 靶恩。\n\n算法要求：\n- 在 $u$-空间中实现高斯卷积积分，其中 $u = \\sqrt{E}$ 且 $\\mu(T,A) = \\sqrt{\\theta(T)/A}$，$\\theta(T) = k_B T$（单位 eV）。对 $u' \\in [0,\\infty)$ 进行积分；为了数值稳定性和效率，可以将积分范围截断为 $u' \\in [\\max(0,u-8\\mu), u+8\\mu]$，因为高斯函数在 $\\pm 8\\mu$ 之外的尾部可以忽略不计。\n- 使用适合平滑高斯加权洛伦兹函数的稳健数值积分方法。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试案例贡献一个包含两个元素的列表 $[\\Delta_\\text{abs}, \\Delta_\\text{frac}]$，顺序如此。例如，\n$[[\\Delta_\\text{abs,1},\\Delta_\\text{frac,1}],[\\Delta_\\text{abs,2},\\Delta_\\text{frac,2}],\\dots]$。",
            "solution": "该问题要求计算单个共振的中子截面多普勒展宽，并与线性温度插值进行比较。该过程基于核反应堆物理的既定原理。\n\n计算的基础是孤立共振在绝对零度（$T=0$ K）下的单能级布莱特-维格纳（SLBW）公式，由一个洛伦兹函数给出：\n$$\n\\sigma_0(E) = \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(E - E_r)^2 + (\\Gamma/2)^2}\n$$\n这里，$E$ 是中子能量，$E_r$ 是共振中心能量，$\\Gamma$ 是总共振宽度，$\\sigma_\\text{peak}$ 是在 $E = E_r$ 处出现的最大截面值。所有能量单位均为电子伏特（eV），截面单位为靶恩。\n\n在有限温度下，靶核处于热运动中。在自由气体模型中，这种运动由速度的麦克斯韦-玻尔兹曼分布描述。其对观测截面的影响是一种展宽现象，数学上表示为零温截面与多普勒核的卷积。这种卷积最方便地在能量平方根空间（或称 $u$-空间）中表示，其中 $u = \\sqrt{E}$。在温度 $T$ 下的展宽截面 $\\sigma(E,T)$ 由下式给出：\n$$\n\\sigma(E,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u,u';T,A)\\, \\mathrm{d}u'\n$$\n函数 $G(u,u';T,A)$ 是自由气体多普勒核，它在 $u$-空间中是一个高斯函数：\n$$\nG(u,u';T,A) = \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u)^2}{\\mu(T,A)^2}\\right)\n$$\n高斯核的宽度参数 $\\mu(T,A)$ 包含了热运动的物理学：\n$$\n\\mu(T,A) = \\sqrt{\\frac{\\theta(T)}{A}}\n$$\n其中 $\\theta(T) = k_B T$ 是以 eV 为单位的热能，$k_B$ 是玻尔兹曼常数（$8.617333262145\\times 10^{-5}$ eV/K），$A$ 是靶核质量与中子质量之比。核中的变量 $u$ 对应于评估能量 $E$（即 $u=\\sqrt{E}$），而 $u'$ 是积分变量，代表进行卷积的整个能量谱。\n\n问题要求在共振能量 $E = E_r$ 处进行评估。因此，我们设置 $u = u_r = \\sqrt{E_r}$。对于给定温度 $T$，需要计算的积分为：\n$$\n\\sigma(E_r,T) = \\int_0^\\infty \\sigma_0(u'^2)\\, G(u_r,u';T,A)\\, \\mathrm{d}u'\n$$\n代入 $\\sigma_0$ 和 $G$ 的表达式，被积函数变为：\n$$\n\\text{Integrand}(u') = \\left( \\sigma_\\text{peak} \\frac{(\\Gamma/2)^2}{(u'^2 - E_r)^2 + (\\Gamma/2)^2} \\right) \\left( \\frac{1}{\\sqrt{\\pi}\\,\\mu(T,A)} \\exp\\!\\left(-\\frac{(u'-u_r)^2}{\\mu(T,A)^2}\\right) \\right)\n$$\n这个定积分必须进行数值计算。一种稳健的方法，如由Python中 `scipy.integrate.quad` 提供的自适应求积法，适合此任务。积分在 $u'$ 从 $0$ 到 $\\infty$ 的范围内进行。为了提高数值效率，问题允许将积分范围截断为 $[\\max(0, u_r - 8\\mu), u_r + 8\\mu]$，因为高斯核在此区间外的贡献可以忽略不计。\n\n对于每个测试案例，总体算法如下：\n1.  对于三个温度中的每一个，$T_1 = 800$ K、$T = 873$ K 和 $T_2 = 900$ K，通过数值求解上面定义的卷积积分，计算在共振峰值处的相应展宽截面 $\\sigma(E_r, T_1)$、$\\sigma(E_r, T)$ 和 $\\sigma(E_r, T_2)$。\n\n2.  使用在边界温度 $T_1$ 和 $T_2$ 处计算的值，计算在 $T=873$ K 处的线性插值截面：\n$$\n\\sigma_\\text{lin}(E_r, T) = \\sigma(E_r, T_1) + \\frac{T - T_1}{T_2 - T_1}\\left[\\sigma(E_r, T_2) - \\sigma(E_r, T_1)\\right]\n$$\n\n3.  通过计算精确展宽值与插值之间的绝对和相对差异，来量化这种线性近似引入的误差：\n    -   绝对差异：$\\Delta_\\text{abs} = \\sigma(E_r, T) - \\sigma_\\text{lin}(E_r, T)$\n    -   相对差异：$\\Delta_\\text{frac} = \\frac{\\Delta_\\text{abs}}{\\sigma(E_r, T)}$\n\n4.  对于每个测试案例，收集最终结果 $\\Delta_\\text{abs}$ 和 $\\Delta_\\text{frac}$，并以六位小数的精度报告。此分析展示了截面对温度的非线性依赖关系，以及在某些核模拟情境中使用的简单插值方案可能带来的不准确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the Doppler broadening problem for the given test cases.\n    \"\"\"\n    \n    # Define constants and fixed temperatures\n    KB = 8.617333262145e-5  # Boltzmann constant in eV/K\n    T1 = 800.0  # K\n    T = 873.0   # K\n    T2 = 900.0  # K\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (A, Er, Gamma, sigma_peak)\n        (238.0, 6.670, 0.030, 3000.0),\n        (56.0, 2.000, 0.300, 100.0),\n        (1.0, 1.000, 0.500, 20.0),\n        (238.0, 0.500, 0.001, 10000.0),\n    ]\n\n    # List to store the results for all cases\n    all_results = []\n\n    def zero_temp_xs(u_prime_sq, Er, Gamma, sigma_peak):\n        \"\"\"\n        Calculates the zero-temperature SLBW cross section.\n        u_prime_sq is u'^2, which is the energy E.\n        \"\"\"\n        half_gamma_sq = (Gamma / 2.0)**2\n        return sigma_peak * half_gamma_sq / ((u_prime_sq - Er)**2 + half_gamma_sq)\n\n    def calculate_broadened_xs(Er, Gamma, sigma_peak, A, temp):\n        \"\"\"\n        Computes the Doppler-broadened cross section at E=Er for a given temperature.\n        \"\"\"\n        # Thermal energy theta\n        theta = KB * temp\n        \n        # Kernel width parameter mu\n        mu = np.sqrt(theta / A)\n        \n        # u-space evaluation point\n        u_r = np.sqrt(Er)\n        \n        # Define the integrand for the convolution\n        def integrand(u_prime):\n            # Gaussian kernel G(u_r, u_prime; T, A)\n            gaussian_kernel = (1.0 / (np.sqrt(np.pi) * mu)) * np.exp(-((u_prime - u_r)**2) / mu**2)\n            \n            # Zero-temperature cross section sigma_0(u_prime^2)\n            sigma_0_val = zero_temp_xs(u_prime**2, Er, Gamma, sigma_peak)\n            \n            return sigma_0_val * gaussian_kernel\n\n        # Integration limits\n        u_min = max(0.0, u_r - 8.0 * mu)\n        u_max = u_r + 8.0 * mu\n        \n        # Perform numerical integration\n        result, _ = integrate.quad(integrand, u_min, u_max, epsabs=1e-12, epsrel=1e-12)\n        \n        return result\n\n    for case in test_cases:\n        A, Er, Gamma, sigma_peak = case\n        \n        # 1. Compute on-the-fly broadened cross section at T\n        sigma_T = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T)\n        \n        # 2. Compute broadened cross sections at T1 and T2\n        sigma_T1 = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T1)\n        sigma_T2 = calculate_broadened_xs(Er, Gamma, sigma_peak, A, T2)\n        \n        # 3. Compute the linearly interpolated value\n        sigma_lin = sigma_T1 + (T - T1) / (T2 - T1) * (sigma_T2 - sigma_T1)\n        \n        # 4. Quantify the differences\n        delta_abs = sigma_T - sigma_lin\n        delta_frac = delta_abs / sigma_T if sigma_T != 0 else 0.0\n        \n        # Store results rounded to six decimal places\n        all_results.append(f\"[{delta_abs:.6f},{delta_frac:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了多普勒展宽的基本计算方法之后，我们必须关注其数值实现的精度和稳定性。本练习将引导您深入探讨卷积积分计算中的一个常见陷阱——数值抵消导致的精度损失，并实践一种更稳健的计算方案。通过将您的计算结果与基于法捷耶娃函数（Faddeeva function）的精确解析解进行比较，您将学会如何量化和改进数值算法的精度 。",
            "id": "4239886",
            "problem": "考虑一个静止各向同性介质中的单共振吸收截面，其由洛伦兹线型与热多普勒展宽卷积近似。设未展宽的截面由面积归一化的洛伦兹函数建模，由下式给出：$$\\ell(x;\\gamma)=\\frac{1}{\\pi}\\frac{\\gamma}{x^2+\\gamma^2},$$ 其中 $x=E-E_r$ 是相对于共振能量 $E_r$ 的能量偏移，单位为电子伏特 (eV)，$\\gamma$ 是半峰半宽，单位为电子伏特 (eV)。物理截面（单位为靶恩）为：$$\\sigma_0(E)=S_{\\text{area}}\\ \\ell(E-E_r;\\gamma),$$ 其中 $S_{\\text{area}}$ 的单位是靶恩$\\cdot$电子伏特，它缩放线型下的面积以匹配共振的物理强度。\n\n假设在给定能量 $E$ 和温度下进行在线评估时，多普勒展宽可以表示为与能量空间中的高斯函数的卷积，$$g(x;\\sigma)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right),$$ 其中 $\\sigma$ 是一个热宽度参数，单位为电子伏特 (eV)。那么，在能量 $E$ 处的经多普勒展宽的截面就是福格特 (Voigt) 卷积，$$\\sigma_D(E)=\\int_{-\\infty}^{\\infty}\\sigma_0(E')\\ g(E-E';\\sigma)\\ \\mathrm{d}E'=\\int_{-\\infty}^{\\infty}S_{\\text{area}}\\ \\ell(E'-E_r;\\gamma)\\ g(E-E';\\sigma)\\ \\mathrm{d}E'.$$\n\n当 $\\gamma$ 很小时，被积函数在 $E'\\approx E_r$ 附近急剧达到峰值；当 $\\sigma$ 很小时，高斯因子在 $E'\\approx E$ 附近急剧达到峰值。在 $E\\approx E_r$ 附近，如果没有进行仔细的缩放，直接在原始 $E'$-空间中进行求和，卷积的数值积分可能会因为累积大量大贡献项之间的微小差异而遭受有效数字损失。一个数学上等效的重新参数化和缩放可以缓解这个问题。定义平移和缩放后的变量：$$y=\\frac{E'-E_r}{\\sigma},\\quad y_0=\\frac{E-E_r}{\\sigma},$$ 因此：$$g(E-E';\\sigma)=\\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right),\\quad \\ell(E'-E_r;\\gamma)=\\ell(\\sigma y;\\gamma)=\\frac{1}{\\pi}\\frac{\\gamma}{(\\sigma y)^2+\\gamma^2}.$$ 在这个 $y$-空间中，卷积变为：$$\\sigma_D(E)=S_{\\text{area}}\\ \\sigma\\ \\int_{-\\infty}^{\\infty}\\frac{1}{\\pi}\\frac{\\gamma}{(\\sigma y)^2+\\gamma^2}\\ \\frac{1}{\\sqrt{2\\pi}}\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right)\\ \\mathrm{d}y.$$ 可以通过以下方式构建一个数值稳定的累加方案：(i) 通过将指数分解为如下形式来移动高斯函数，以消除近似对称的抵消：$$\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right)=\\exp\\left(-\\frac{y^2}{2}\\right)\\exp\\left(-\\frac{y_0^2}{2}\\right)\\exp(y\\,y_0),$$ 以及 (ii) 在对称的 $y$-网格上执行补偿求和（例如，Kahan 求和），以在存在宽动态范围时减少舍入误差。作为高精度参考，福格特 (Voigt) 分布可以通过法捷耶娃 (Faddeeva) 函数得到精确表示，$$V(x;\\sigma,\\gamma)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\ \\Re\\left[w\\!\\left(\\frac{x+i\\gamma}{\\sigma\\sqrt{2}}\\right)\\right],$$ 其中 $w(z)$ 是缩放的复误差函数。展宽后的截面则为：$$\\sigma_D^{\\text{ref}}(E)=S_{\\text{area}}\\ V(E-E_r;\\sigma,\\gamma).$$\n\n您的任务是编写一个完整的程序，该程序：\n- 为 $\\sigma_D(E)$ 实现三种计算方案：\n  $1.$ 一种在 $E'$-空间中使用均匀 $E'$-网格和简单求和的朴素矩形积分法。\n  $2.$ 一种在 $y$-空间中使用变量 $y$、上述指数分解和 Kahan 补偿求和的稳定积分法。\n  $3.$ 一种使用基于法捷耶娃函数的福格特表示的高精度参考评估。\n- 对于每个测试用例，计算朴素方案和稳定方案相对于参考方案的相对误差，定义为：$$\\varepsilon=\\left|\\frac{\\sigma_D^{\\text{approx}}(E)-\\sigma_D^{\\text{ref}}(E)}{\\sigma_D^{\\text{ref}}(E)}\\right|.$$\n- 将所有相对误差在一行中输出，形式为方括号内以逗号分隔的列表（例如，$$[\\varepsilon_1,\\varepsilon_2,\\varepsilon_3]$$）。不要打印任何其他文本。\n\n假设能量单位为电子伏特 (eV)，宽度单位为电子伏特 (eV)，截面单位为靶恩。将所有相对误差表示为无量纲浮点数。使用以下测试套件，它涵盖了一个“理想路径”案例、一个近共振边缘案例、一个远翼案例和一个窄洛伦兹案例：\n- 测试用例 1：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.03$, $\\sigma=0.02$, $E=6.67$。\n- 测试用例 2：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.03$, $\\sigma=0.001$, $E=6.670000001$ (即 $E=E_r+10^{-9}$)。\n- 测试用例 3：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.03$, $\\sigma=0.05$, $E=6.87$ (即 $E=E_r+0.20$)。\n- 测试用例 4：$S_{\\text{area}}=100$, $E_r=6.67$, $\\gamma=0.001$, $\\sigma=0.01$, $E=6.67$。\n\n在您的实现中：\n- 在 $E'$ 空间中使用一个以 $E_r$ 为中心的对称有限区间进行积分，其宽度应足够大以捕获洛伦兹因子和高斯因子的有效支撑集。一个合理的选择是设置半宽 $L$ 为 $$L=\\max\\{8\\sigma,\\ 30\\gamma\\},$$ 并在 $E'\\in[E_r-L,\\ E_r+L]$ 上积分。\n- 对两种积分法都使用一个包含 $N$ 个点的均匀网格；确保朴素方案和稳定方案的 $N$ 值相同，以便它们的采样分辨率可以直接比较。设 $N$ 为固定值，其选择旨在平衡运行时间和准确性。\n- 对于稳定的 $y$-空间积分法，在 $y\\in[-L/\\sigma,\\ L/\\sigma]$ 上使用变换 $E' = E_r + \\sigma y$，并包含雅可比因子 $\\sigma$。\n\n您的程序应生成单行输出，其中包含测试套件中按顺序排列的相对误差，每个案例贡献两个浮点数，分别对应朴素方案和稳定方案。最终输出格式必须为 $$[\\varepsilon_{1,\\text{naive}},\\varepsilon_{1,\\text{stabilized}},\\varepsilon_{2,\\text{naive}},\\varepsilon_{2,\\text{stabilized}},\\varepsilon_{3,\\text{naive}},\\varepsilon_{3,\\text{stabilized}},\\varepsilon_{4,\\text{naive}},\\varepsilon_{4,\\text{stabilized}}].$$",
            "solution": "用户要求编写一个程序，使用三种不同的数值方案计算单个核共振的多普勒展宽截面，并评估它们的相对误差。该问题在科学上是合理的、提法恰当，并为严格实现提供了足够的细节。它涉及核反应堆物理学中的一个标准课题——截面的在线计算，并突出了一个与积分中有效数字损失相关的真实数值挑战。因此，该问题被认为是有效的，并有必要提供完整的解决方案。\n\n问题的核心是计算卷积积分，该积分定义了多普勒展宽截面 $\\sigma_D(E)$：\n$$\n\\sigma_D(E) = \\int_{-\\infty}^{\\infty}\\sigma_0(E')\\ g(E-E';\\sigma)\\ \\mathrm{d}E'\n$$\n此处，$\\sigma_0(E)$ 是未展宽的截面，由洛伦兹分布建模，而 $g(x;\\sigma)$ 是代表热运动的高斯核。\n$$\n\\sigma_0(E) = S_{\\text{area}} \\cdot \\ell(E-E_r;\\gamma) = S_{\\text{area}} \\cdot \\frac{1}{\\pi}\\frac{\\gamma}{(E-E_r)^2+\\gamma^2}\n$$\n$$\ng(x;\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\n$$\n其中 $S_{\\text{area}}$ 是共振强度，$E_r$ 是共振能量，$\\gamma$ 是共振的固有半峰半宽 (HWHM)，$\\sigma$ 是热宽度参数。\n\n我们将实现并比较三种评估该积分的方法。\n\n**方法1：朴素的 $E'$-空间积分法**\n\n此方法使用简单的矩形积分法则直接近似卷积积分。积分域被截断为一个有限的对称区间 $[E_r-L, E_r+L]$，其中 $L = \\max\\{8\\sigma, 30\\gamma\\}$ 的选择是为了使其足够大，以包含洛伦兹函数和高斯函数的显著贡献。我们将此区间划分为 $N$ 个点，记为 $E'_i$，具有均匀的步长 $\\Delta E' = 2L/(N-1)$。然后，该积分通过以下求和来近似：\n$$\n\\sigma_{D,\\text{naive}}(E) \\approx \\sum_{i=0}^{N-1} \\sigma_0(E'_i) \\ g(E-E'_i;\\sigma) \\ \\Delta E'\n$$\n这种方法简单直接，但可能会遭受数值不稳定的影响。当对被积函数求和时，特别是在 $E \\approx E_r$ 的情况下，来自 $E' > E$ 和 $E'  E$ 的贡献可能大小几乎相等、符号相反，如果处理不当，会导致相减抵消和精度损失。\n\n**方法2：稳定的 $y$-空间积分法**\n\n为了增强数值稳定性，我们进行变量替换 $y = (E'-E_r)/\\sigma$，这将积分网格中心置于新变量 $y=0$ 处，并按热宽度 $\\sigma$ 对其进行缩放。此变换的雅可比行列式为 $\\mathrm{d}E' = \\sigma\\,\\mathrm{d}y$。积分变为：\n$$\n\\sigma_D(E) = \\frac{S_{\\text{area}}\\sigma}{\\pi\\sqrt{2\\pi}} \\int_{-L/\\sigma}^{L/\\sigma} \\frac{\\gamma}{(\\sigma y)^2+\\gamma^2} \\exp\\left(-\\frac{(y-y_0)^2}{2}\\right) \\mathrm{d}y\n$$\n其中 $y_0 = (E-E_r)/\\sigma$。为了进行数值评估，指数项被分解以避免当 $y$ 和 $y_0$ 都很大时可能出现的浮点溢出和精度损失：\n$$\n\\exp\\left(-\\frac{(y-y_0)^2}{2}\\right) = \\exp\\left(-\\frac{y_0^2}{2}\\right) \\exp(y y_0) \\exp\\left(-\\frac{y^2}{2}\\right)\n$$\n项 $\\exp(-y_0^2/2)$ 相对于积分变量 $y$ 是常数，可以从求和中提出。积分是在均匀网格 $y_i \\in [-L/\\sigma, L/\\sigma]$ 上执行的，步长为 $\\Delta y$。\n\n为了通过减少舍入误差累积来进一步提高准确性（当对大量具有宽动态范围的浮点值求和时，这种累积很普遍），我们采用 Kahan 补偿求和。该算法维持一个运行的补偿项，以核算每次加法中丢失的低位比特。对于一个数值序列 $v_i$ 的求和计算如下：\n`sum = 0`, `c = 0`\n对于每个 `v_i`：\n  `y_term = v_i - c`\n  `t = sum + y_term`\n  `c = (t - sum) - y_term`\n  `sum = t`\n\n稳定计算的最终表达式为：\n$$\n\\sigma_{D,\\text{stabilized}}(E) \\approx \\frac{S_{\\text{area}}\\sigma}{\\pi\\sqrt{2\\pi}} \\exp\\left(-\\frac{y_0^2}{2}\\right) \\left( \\sum_{i=0}^{N-1} \\left[ \\frac{\\gamma}{(\\sigma y_i)^2+\\gamma^2} \\exp(y_i y_0) \\exp\\left(-\\frac{y_i^2}{2}\\right) \\right]_{\\text{Kahan}} \\right) \\Delta y\n$$\n\n**方法3：使用法捷耶娃函数进行参考计算**\n\n洛伦兹函数和高斯函数的卷积产生福格特分布，它可以使用法捷耶娃函数 $w(z) = e^{-z^2}\\text{erfc}(-iz)$ 进行解析表示。这提供了一个高精度的参考，可以用来与数值积分进行比较。福格特分布 $V(x;\\sigma,\\gamma)$ 由下式给出：\n$$\nV(x;\\sigma,\\gamma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\ \\Re\\left[w\\left(\\frac{x+i\\gamma}{\\sigma\\sqrt{2}}\\right)\\right]\n$$\n多普勒展宽截面随后可直接计算为：\n$$\n\\sigma_{D,\\text{ref}}(E) = S_{\\text{area}} \\cdot V(E-E_r; \\sigma, \\gamma)\n$$\n我们将使用 `scipy.special.wofz` 函数，它是法捷耶娃函数 $w(z)$ 的一个数值实现。\n\n**误差分析**\n\n对于每个测试用例，将计算朴素方案和稳定方案相对于参考方案的相对误差 $\\varepsilon$：\n$$\n\\varepsilon = \\left|\\frac{\\sigma_D^{\\text{approx}}(E) - \\sigma_D^{\\text{ref}}(E)}{\\sigma_D^{\\text{ref}}(E)}\\right|\n$$\n对于方法1和方法2，将使用固定的积分点数 $N=20001$，以确保对它们的内在准确性和稳定性进行公平比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import wofz\n\ndef solve():\n    \"\"\"\n    Computes Doppler-broadened cross sections using three methods and their relative errors.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # S_area, Er, gamma, sigma, E\n        (100.0, 6.67, 0.03, 0.02, 6.67),\n        (100.0, 6.67, 0.03, 0.001, 6.670000001),\n        (100.0, 6.67, 0.03, 0.05, 6.87),\n        (100.0, 6.67, 0.001, 0.01, 6.67),\n    ]\n\n    results = []\n    N = 20001 # Number of quadrature points\n\n    for case in test_cases:\n        S_area, Er, gamma, sigma, E = case\n        \n        # --- Method 3: Reference Calculation (Faddeeva Function) ---\n        x = E - Er\n        # Argument for the Faddeeva function w(z)\n        z = (x + 1j * gamma) / (sigma * np.sqrt(2))\n        \n        # Voigt profile V(x, sigma, gamma)\n        V = np.real(wofz(z)) / (sigma * np.sqrt(2 * np.pi))\n        sigma_ref = S_area * V\n\n        # Define integration limits\n        L = max(8 * sigma, 30 * gamma)\n\n        # --- Method 1: Naive E'-space Quadrature ---\n        e_prime_grid = np.linspace(Er - L, Er + L, N)\n        delta_ep = 2 * L / (N - 1)\n\n        def lorentzian(val, g):\n            return (1 / np.pi) * g / (val**2 + g**2)\n\n        def gaussian(val, s):\n            return (1 / (s * np.sqrt(2 * np.pi))) * np.exp(-val**2 / (2 * s**2))\n\n        integrand_naive = S_area * lorentzian(e_prime_grid - Er, gamma) * gaussian(E - e_prime_grid, sigma)\n        sigma_naive = np.sum(integrand_naive) * delta_ep\n        \n        # --- Method 2: Stabilized y-space Quadrature with Kahan Summation ---\n        y_grid = np.linspace(-L / sigma, -L / sigma + (N-1)*(2*L/(sigma*(N-1))), N) # Avoids endpoint imprecision\n        delta_y = 2 * L / (sigma * (N-1))\n        y0 = (E - Er) / sigma\n\n        def kahan_sum(arr):\n            s = 0.0\n            c = 0.0\n            for val in arr:\n                y_term = val - c\n                t = s + y_term\n                c = (t - s) - y_term\n                s = t\n            return s\n            \n        # Terms inside the Kahan sum, using the factored exponential\n        terms_to_sum = (gamma / ((sigma * y_grid)**2 + gamma**2)) * \\\n                       np.exp(-y_grid**2 / 2) * \\\n                       np.exp(y_grid * y0)\n        \n        sum_k = kahan_sum(terms_to_sum)\n\n        # Prefactor combines all constant terms\n        prefactor = (S_area * sigma / (np.pi * np.sqrt(2 * np.pi))) * np.exp(-y0**2 / 2)\n        \n        sigma_stabilized = prefactor * sum_k * delta_y\n\n        # --- Calculate Relative Errors ---\n        if sigma_ref != 0:\n            err_naive = abs((sigma_naive - sigma_ref) / sigma_ref)\n            err_stabilized = abs((sigma_stabilized - sigma_ref) / sigma_ref)\n        else: # Handle cases where reference is zero (not expected here)\n            err_naive = 0.0 if sigma_naive == 0.0 else np.inf\n            err_stabilized = 0.0 if sigma_stabilized == 0.0 else np.inf\n\n        results.append(err_naive)\n        results.append(err_stabilized)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的多物理场耦合模拟中，温度场是动态变化的，在每个微小的温度步长上都重新进行完整的展宽计算是不切实际的。本练习将指导您设计并实现一种高效的缓存策略，该策略利用截面对温度 $T$ 的泰勒展开来近似计算微小温变后的截面。您将学习如何推导一个严格的误差边界，并用它来判断何时可以安全地使用近似值，从而在保证精度的前提下大幅提升计算效率 。",
            "id": "4239871",
            "problem": "考虑在对数能量空间中建模的一维微观截面的多普勒展宽。令 $u = \\ln(E/E_{\\mathrm{ref}})$ 为无量纲对数能量变量，其中 $E$ 的单位为电子伏特，$E_{\\mathrm{ref}}$ 是一个固定的参考能量。未展宽截面是一个函数 $\\sigma(u)$，单位为靶恩。在绝对温度 $T$（单位为开尔文）下的理想化多普勒展宽算子被建模为与一个宽度依赖于温度的高斯核的卷积。具体来说，对于给定的常数 $\\alpha$（单位为开尔文的倒数），定义标准差 $s(T) = \\sqrt{\\alpha T}$ 和核函数\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi}\\,s(T)} \\exp\\!\\left(-\\frac{u^2}{2 s(T)^2}\\right).\n$$\n那么，在温度 $T$ 下的多普勒展宽截面为\n$$\n\\sigma_T(u) = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,K(u-u';T)\\,du'.\n$$\n在核反应堆模拟的在线使用中，连续输运扫描之间遇到的温度可能仅有微小增量之差。一种缓存方案旨在重用在基准温度 $T_0$ 下已计算的展宽值，以近似在 $T_1 = T_0 + \\Delta T$ 下的展宽值，而无需显式地重新计算在 $T_1$ 时的卷积，同时界定其近似误差。\n\n设计并实现一个程序，该程序：\n1. 使用 $\\sigma_T(u)$ 关于 $T$ 在 $T_0$ 附近的一阶 Taylor 展开：\n$$\n\\sigma_{T_1}(u) \\approx \\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T=T_0},\n$$\n其中，关于 $T$ 的导数通过在积分号下对核函数进行微分来计算：\n$$\n\\frac{\\partial \\sigma_T(u)}{\\partial T} = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,\\frac{\\partial K(u-u';T)}{\\partial T}\\,du'.\n$$\n类似地，二阶导数出现在 Taylor 余项中：\n$$\n\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2} = \\int_{-\\infty}^{\\infty} \\sigma(u')\\,\\frac{\\partial^2 K(u-u';T)}{\\partial T^2}\\,du'.\n$$\n2. 基于依赖关系 $s(T)=\\sqrt{\\alpha T}$，推导并使用 $\\frac{\\partial K(u;T)}{\\partial T}$ 和 $\\frac{\\partial^2 K(u;T)}{\\partial T^2}$ 的闭式表达式，除基本的高斯微分外，不使用任何快捷公式。\n3. 按如下方式实现一个缓存方案：在一组离散的 $u$ 值上计算并存储 $\\sigma_{T_0}(u)$ 和 $\\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}$，并用它们来近似 $\\sigma_{T_1}(u)$。使用二阶 Taylor 余项建立绝对近似误差的严格界限：\n$$\n\\left|\\sigma_{T_1}(u) - \\left[\\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}\\right]\\right| \\le \\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|.\n$$\n4. 使用间距为 $\\Delta u$ 的均匀网格 $u_j$ 和线性卷积将关于 $u$ 的积分离散化，确保积分近似包含因子 $\\Delta u$ 以使单位保持一致。\n5. 假设 $u$ 的定义域足够宽，以至于对于所考虑的温度，高斯核在边界处的值可以忽略不计。\n使用以下科学上合理的截面模型：\n$$\n\\sigma(u) = A_1 \\exp\\!\\left(-\\frac{(u-u_1)^2}{2 b_1^2}\\right) + A_2 \\exp\\!\\left(-\\frac{(u-u_2)^2}{2 b_2^2}\\right) + \\sigma_{\\mathrm{bg}},\n$$\n参数为 $A_1 = 50$ 靶恩, $u_1 = -0.5$, $b_1 = 0.05$, $A_2 = 20$ 靶恩, $u_2 = 0.8$, $b_2 = 0.1$, 以及 $\\sigma_{\\mathrm{bg}} = 1$ 靶恩。\n6. 使用 $\\alpha = 10^{-4}$（开尔文的倒数）。\n7. 对于下面提供的每个测试用例，在 $u$ 网格上计算以下量：\n   - 跨 $u$ 的最大绝对 Taylor 余项界，等于 $\\max_u \\left(\\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|\\right)$，以靶恩为单位表示。\n   - 跨 $u$ 的最大绝对实际误差，等于 $\\max_u \\left|\\sigma_{T_1}(u) - \\left[\\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}\\right]\\right|$，以靶恩为单位表示。\n   - 一个布尔决策，指示缓存方案是否可接受，其定义为误差界小于或等于指定的绝对容差 $\\varepsilon$（单位为靶恩）。\n8. 使用一个在 $u \\in [-3,3]$ 区间上含 $N = 2048$ 个点的均匀网格，并按照下面指定的确切格式为每个测试用例输出结果。\n\n推导依据和约束：\n- 从高斯卷积的基本形式以及通过 $s(T) = \\sqrt{\\alpha T}$ 对 $K(u;T)$ 关于 $T$ 进行链式法则微分开始。\n- 除了高斯导数恒等式和 Taylor 余项定理之外，不提供任何快捷公式。\n- 通过在离散卷积中乘以 $\\Delta u$ 来确保数值实现与积分的单位一致。\n\n测试套件参数值：\n- 用例 1: $T_0 = 300$ 开尔文, $\\Delta T = 5$ 开尔文, $\\varepsilon = 0.02$ 靶恩。\n- 用例 2: $T_0 = 900$ 开尔文, $\\Delta T = 10$ 开尔文, $\\varepsilon = 0.04$ 靶恩。\n- 用例 3: $T_0 = 300$ 开尔文, $\\Delta T = 0$ 开尔文, $\\varepsilon = 10^{-8}$ 靶恩。\n- 用例 4: $T_0 = 300$ 开尔文, $\\Delta T = 50$ 开尔文, $\\varepsilon = 0.2$ 靶恩。\n- 用例 5: $T_0 = 50$ 开尔文, $\\Delta T = 5$ 开尔文, $\\varepsilon = 0.02$ 靶恩。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身是按 $[\\text{界限}, \\text{实际值}, \\text{是否通过}]$ 顺序排列的包含三个元素的列表。例如：\n$[[b_1,a_1,o_1],[b_2,a_2,o_2],\\dots]$。\n所有绝对误差必须以靶恩为单位表示为十进制数，布尔值 $o_i$ 必须是 $\\text{True}$ 或 $\\text{False}$（不带百分号）。",
            "solution": "问题陈述已经过分析，并被认为是有效的。它在科学上植根于核反应堆物理学的原理，特别是中子截面多普勒展宽的建模。该问题是适定的，提供了所有必要的参数、一个清晰的物理模型和一组具体的计算任务。语言客观，设置内部一致且物理上合理。\n\n问题的核心是使用在基准温度 $T_0$ 附近的一阶 Taylor 展开来近似温度 $T_1 = T_0 + \\Delta T$ 下的多普勒展宽截面 $\\sigma_{T_1}(u)$，并对该近似的误差进行界定。展宽截面 $\\sigma_T(u)$ 定义为一个未展宽截面 $\\sigma(u)$ 与一个其宽度依赖于温度的高斯核 $K(u;T)$ 的卷积。\n\n解决方案主要分为三个部分：\n1.  高斯核的一阶和二阶温度导数 $\\frac{\\partial K}{\\partial T}$ 和 $\\frac{\\partial^2 K}{\\partial T^2}$ 的解析推导。\n2.  设计一种数值算法来计算卷积积分和所需的误差度量。\n3.  实现该算法以求解给定的测试用例。\n\n**1. 核函数导数的推导**\n\n高斯核由下式给出\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi}\\,s(T)} \\exp\\!\\left(-\\frac{u^2}{2 s(T)^2}\\right)\n$$\n其中标准差 $s(T)$ 定义为 $s(T) = \\sqrt{\\alpha T}$。我们可以将核函数显式地表示为温度 $T$ 的函数：\n$$\nK(u;T) = \\frac{1}{\\sqrt{2\\pi \\alpha T}} \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)\n$$\n\n**一阶导数, $\\frac{\\partial K(u;T)}{\\partial T}$**\n我们使用乘法法则对 $K(u;T)$ 关于 $T$ 求导。令 $f(T) = (2\\pi \\alpha T)^{-1/2}$ 且 $g(T) = \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)$。其导数为：\n$$\n\\frac{df}{dT} = -\\frac{1}{2}(2\\pi \\alpha T)^{-3/2} \\cdot (2\\pi \\alpha) = -\\frac{1}{2T} (2\\pi \\alpha T)^{-1/2}\n$$\n$$\n\\frac{dg}{dT} = \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right) \\cdot \\left(\\frac{u^2}{2 \\alpha T^2}\\right)\n$$\n应用乘法法则，$\\frac{\\partial K}{\\partial T} = \\frac{df}{dT}g(T) + f(T)\\frac{dg}{dT}$：\n$$\n\\frac{\\partial K}{\\partial T} = \\left(-\\frac{1}{2T} \\frac{1}{\\sqrt{2\\pi \\alpha T}}\\right) \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right) + \\frac{1}{\\sqrt{2\\pi \\alpha T}} \\left(\\frac{u^2}{2 \\alpha T^2} \\exp\\!\\left(-\\frac{u^2}{2 \\alpha T}\\right)\\right)\n$$\n提出原始核函数 $K(u;T)$ 作为公因子：\n$$\n\\frac{\\partial K}{\\partial T} = K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2 \\alpha T^2}\\right)\n$$\n代入 $s(T)^2 = \\alpha T$，我们得到一阶导数的最终形式：\n$$\n\\frac{\\partial K(u;T)}{\\partial T} = \\frac{1}{2T} K(u;T) \\left(\\frac{u^2}{s(T)^2} - 1\\right)\n$$\n\n**二阶导数, $\\frac{\\partial^2 K(u;T)}{\\partial T^2}$**\n我们再次使用乘法法则对 $\\frac{\\partial K}{\\partial T}$ 关于 $T$ 求导，作用于表达式 $\\frac{\\partial K}{\\partial T} = K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)$：\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = \\frac{\\partial}{\\partial T}\\left(K(u;T)\\right) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) + K(u;T) \\frac{\\partial}{\\partial T}\\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)\n$$\n代入 $\\frac{\\partial K}{\\partial T}$ 的表达式并计算二阶导数项：\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = \\left( K(u;T) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) \\right) \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right) + K(u;T) \\left(\\frac{1}{2T^2} - \\frac{2u^2}{2\\alpha T^3}\\right)\n$$\n提出 $K(u;T)$ 作为公因子并化简：\n$$\n\\frac{\\partial^2 K}{\\partial T^2} = K(u;T) \\left[ \\left(-\\frac{1}{2T} + \\frac{u^2}{2\\alpha T^2}\\right)^2 + \\frac{1}{2T^2} - \\frac{u^2}{\\alpha T^3} \\right]\n$$\n$$\n= K(u;T) \\left[ \\frac{1}{4T^2} - \\frac{u^2}{2\\alpha T^3} + \\frac{u^4}{4\\alpha^2 T^4} + \\frac{1}{2T^2} - \\frac{u^2}{\\alpha T^3} \\right]\n$$\n$$\n= K(u;T) \\left[ \\frac{u^4}{4\\alpha^2 T^4} - \\frac{3u^2}{2\\alpha T^3} + \\frac{3}{4T^2} \\right]\n$$\n提出 $\\frac{1}{4T^2}$ 作为公因子并代入 $s(T)^2 = \\alpha T$：\n$$\n\\frac{\\partial^2 K(u;T)}{\\partial T^2} = \\frac{K(u;T)}{4T^2} \\left[ \\frac{u^4}{(\\alpha T)^2} - \\frac{6u^2}{\\alpha T} + 3 \\right] = \\frac{1}{4T^2} K(u;T) \\left(\\frac{u^4}{s(T)^4} - \\frac{6u^2}{s(T)^2} + 3\\right)\n$$\n这些推导出的 $\\frac{\\partial K}{\\partial T}$ 和 $\\frac{\\partial^2 K}{\\partial T^2}$ 表达式被用来定义卷积所需的相应核函数。\n\n**2. 数值算法**\n\n展宽截面 $\\sigma_T(u)$ 及其温度导数通过卷积积分计算：\n$$\n\\sigma_T(u) = (\\sigma * K_T)(u), \\quad \\frac{\\partial \\sigma_T(u)}{\\partial T} = \\left(\\sigma * \\frac{\\partial K_T}{\\partial T}\\right)(u), \\quad \\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2} = \\left(\\sigma * \\frac{\\partial^2 K_T}{\\partial T^2}\\right)(u)\n$$\n其中 $K_T(u) = K(u;T)$。这些卷积使用快速傅里叶变换（FFT）进行数值实现，这是一种基于卷积定理 $\\mathcal{F}\\{f*g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}$ 的高效方法。离散卷积计算必须乘以网格间距 $\\Delta u$ 来近似该积分。\n\n每个测试用例 $(T_0, \\Delta T, \\varepsilon)$ 的算法如下：\n1.  **网格与函数设置**：在区间 $[-3, 3]$ 上建立一个包含 $N=2048$ 个点的对数能量 $u$ 的均匀网格。网格间距为 $\\Delta u = 6/(N-1)$。根据其指定的函数形式，在该网格上计算未展宽截面 $\\sigma(u)$。\n2.  **在 $T_0$ 下的核函数计算**：使用基准温度 $T_0$ 计算标准差 $s_0 = \\sqrt{\\alpha T_0}$。然后使用推导出的公式在 $u$ 网格上计算离散核函数 $K(u;T_0)$、$\\left.\\frac{\\partial K(u;T)}{\\partial T}\\right|_{T_0}$ 和 $\\left.\\frac{\\partial^2 K(u;T)}{\\partial T^2}\\right|_{T_0}$。\n3.  **在 $T_0$ 下的卷积**：使用基于 FFT 的卷积（`scipy.signal.fftconvolve`）计算展宽截面 $\\sigma_{T_0}(u)$ 及其导数 $\\left.\\frac{\\partial \\sigma_T}{\\partial T}\\right|_{T_0}$ 和 $\\left.\\frac{\\partial^2 \\sigma_T}{\\partial T^2}\\right|_{T_0}$。每个卷积结果都乘以 $\\Delta u$。\n4.  **在 $T_1$ 下的计算**：为了找到实际误差，在 $T_1 = T_0 + \\Delta T$ 下计算“真实”的展宽截面 $\\sigma_{T_1}(u)$。这涉及到计算核函数 $K(u;T_1)$ 并将其与 $\\sigma(u)$ 进行卷积。\n5.  **误差与界限计算**：\n    *   计算一阶 Taylor 近似：$\\sigma_{\\text{approx}}(u) = \\sigma_{T_0}(u) + \\Delta T \\left.\\frac{\\partial \\sigma_T(u)}{\\partial T}\\right|_{T_0}$。\n    *   最大实际误差是 $|\\sigma_{T_1}(u) - \\sigma_{\\text{approx}}(u)|$ 在整个网格上的最大值。\n    *   最大误差界计算为 $\\max_u \\left(\\frac{(\\Delta T)^2}{2} \\left|\\left.\\frac{\\partial^2 \\sigma_T(u)}{\\partial T^2}\\right|_{T_0}\\right|\\right)$。\n6.  **可接受性检查**：如果计算出的最大误差界小于或等于指定的容差 $\\varepsilon$，则该缓存方案被认为是可接受的。\n\n此过程被系统地应用于每个测试用例，以生成所需的输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import fftconvolve\n\ndef solve():\n    \"\"\"\n    Solves the Doppler broadening problem by implementing a Taylor-based caching scheme\n    and evaluating its accuracy and error bounds for several test cases.\n    \"\"\"\n\n    # Define constants and problem parameters.\n    A1 = 50.0  # barns\n    u1 = -0.5\n    b1 = 0.05\n    A2 = 20.0  # barns\n    u2 = 0.8\n    b2 = 0.1\n    sigma_bg = 1.0  # barns\n    alpha = 1e-4  # 1/Kelvin\n    N = 2048\n    u_min, u_max = -3.0, 3.0\n\n    # Define the unbroadened cross section function.\n    def get_sigma_unbroadened(u_grid):\n        \"\"\"Computes the unbroadened cross section on a given grid.\"\"\"\n        term1 = A1 * np.exp(-(u_grid - u1)**2 / (2 * b1**2))\n        term2 = A2 * np.exp(-(u_grid - u2)**2 / (2 * b2**2))\n        return term1 + term2 + sigma_bg\n\n    # Define the kernel and its temperature derivatives.\n    def get_kernels(u_grid, T):\n        \"\"\"Computes the Gaussian kernel and its 1st and 2nd T-derivatives.\"\"\"\n        if T == 0:\n            raise ValueError(\"Temperature must be positive.\")\n        \n        s2 = alpha * T\n        s = np.sqrt(s2)\n\n        # Gaussian kernel K(u;T)\n        K = (1 / (np.sqrt(2 * np.pi) * s)) * np.exp(-u_grid**2 / (2 * s2))\n\n        # First derivative dK/dT\n        factor_dK = (1 / (2 * T)) * (u_grid**2 / s2 - 1)\n        dK_dT = K * factor_dK\n        \n        # Second derivative d^2K/dT^2\n        factor_d2K = (1 / (4 * T**2)) * (u_grid**4 / s2**2 - 6 * u_grid**2 / s2 + 3)\n        d2K_dT2 = K * factor_d2K\n        \n        return K, dK_dT, d2K_dT2\n\n    def process_case(T0, dT, epsilon):\n        \"\"\"\n        Processes a single test case: computes error bound, actual error, and admissibility.\n        \"\"\"\n        u_grid = np.linspace(u_min, u_max, N)\n        du = u_grid[1] - u_grid[0]\n        \n        sigma_u = get_sigma_unbroadened(u_grid)\n\n        # --- Calculations at T0 ---\n        K_T0, dK_dT_T0, d2K_dT2_T0 = get_kernels(u_grid, T0)\n        \n        # Convolutions at T0. Multiply by du to approximate the integral.\n        sigma_T0 = fftconvolve(sigma_u, K_T0, mode='same') * du\n        dsigma_dT_T0 = fftconvolve(sigma_u, dK_dT_T0, mode='same') * du\n        d2sigma_dT2_T0 = fftconvolve(sigma_u, d2K_dT2_T0, mode='same') * du\n        \n        # --- \"True\" calculation at T1 for actual error benchmark ---\n        T1 = T0 + dT\n        \n        if np.isclose(T1, T0):\n            sigma_T1 = sigma_T0\n        else:\n            K_T1, _, _ = get_kernels(u_grid, T1)\n            sigma_T1 = fftconvolve(sigma_u, K_T1, mode='same') * du\n\n        # --- Taylor approximation, actual error, and error bound ---\n        sigma_approx = sigma_T0 + dT * dsigma_dT_T0\n        \n        max_actual_error = np.max(np.abs(sigma_T1 - sigma_approx))\n        \n        max_error_bound = (dT**2 / 2) * np.max(np.abs(d2sigma_dT2_T0))\n        \n        is_admissible = max_error_bound = epsilon\n        \n        # Handle the special case where dT is zero\n        if np.isclose(dT, 0.0):\n            max_actual_error = 0.0\n            max_error_bound = 0.0\n            is_admissible = max_error_bound = epsilon\n\n        return [max_error_bound, max_actual_error, is_admissible]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (T0, Delta T, epsilon)\n        (300.0, 5.0, 0.02),\n        (900.0, 10.0, 0.04),\n        (300.0, 0.0, 1e-8),\n        (300.0, 50.0, 0.2),\n        (50.0, 5.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        T0, dT, epsilon = case\n        result = process_case(T0, dT, epsilon)\n        results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for bound, actual, ok in results:\n        result_strings.append(f'[{bound},{actual},{ok}]')\n        \n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}