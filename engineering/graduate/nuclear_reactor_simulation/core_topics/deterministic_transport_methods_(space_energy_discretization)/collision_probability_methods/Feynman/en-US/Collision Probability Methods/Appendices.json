{
    "hands_on_practices": [
        {
            "introduction": "The best way to build confidence in a computational method is to test it against a case with a known analytical solution. This first practice grounds your understanding of Collision Probability Methods (CPM) by connecting the abstract theory of integral transport to tangible, verifiable results. You will derive the exact self-collision and transmission probabilities for a simple slab from first principles and then construct a basic Monte Carlo simulation to numerically confirm your analytical formulas, providing deep insight into the physics of neutron flight and collision .",
            "id": "4217775",
            "problem": "Design a validation experiment for the Collision Probability Method (CPM) in one-dimensional slab geometry with vacuum boundaries, based on first principles of neutral particle transport. Consider a homogeneous slab of thickness $L$ with macroscopic total cross section $\\Sigma_t$ that is spatially constant. Neutrons are born uniformly in space and isotropically in direction. The CPM quantities of interest are the region self-collision probability $P_{jj}$ (the probability that a neutron’s first interaction occurs in the slab before escape) and the total transmission probability $T$ (the probability that a neutron escapes through either boundary without any interaction). The goal is to derive closed-form expressions for $P_{jj}$ and $T$ using generalized exponential integrals, and then to validate these expressions via a numerical experiment.\n\nBegin from the linear Boltzmann equation for neutral particles in steady-state, monoenergetic form in one dimension, and employ the first-flight (uncollided) survival probability. For an emitted neutron at position $x \\in [0,L]$ with directional cosine $\\mu \\in [-1,1]$, the distance to the nearest vacuum boundary along its flight direction is $d(x,\\mu)$, and the probability of first-flight survival to that boundary is $\\exp(-\\Sigma_t d(x,\\mu))$. With a uniform spatial source and isotropic angular distribution, the average escape probability through either boundary is obtained by integrating this survival probability over $x$ and $\\mu$, and the average collision probability in the slab follows as the complement.\n\nTasks:\n1. Derive, from the survival probability and the uniform-isotropic sampling of $x$ and $\\mu$, a closed-form expression for the total transmission probability $T$ in terms of the generalized exponential integral function. Express the result in terms of the dimensionless optical thickness $a = \\Sigma_t L$. Your derivation must show all steps from the integral definition to the closed form and must use only the following base elements:\n    - The definition of first-flight survival probability $\\exp(-\\Sigma_t d(x,\\mu))$.\n    - Uniform spatial sampling over $x \\in [0,L]$ and isotropic angular sampling over $\\mu \\in [-1,1]$.\n    - The generalized exponential integral $E_n(x)$ defined by $E_n(x) = \\int_{1}^{\\infty} \\frac{e^{-x t}}{t^n} \\, dt$.\n2. From your expression for $T$, obtain the self-collision probability $P_{jj}$ solely as a consequence of conservation of probability in this vacuum-bounded single-region slab.\n3. Propose and implement a numerical experiment using random sampling (Monte Carlo) that estimates $T$ and $P_{jj}$ directly from the definitions, by simulating a large number of independent neutron histories:\n    - Sample $x$ uniformly in $[0,L]$ and $\\mu$ uniformly in $[-1,1]$.\n    - Compute the distance $d(x,\\mu)$ to the vacuum boundary along the sampled direction.\n    - Sample a free-flight path length $s$ from the exponential distribution with mean $1/\\Sigma_t$ and decide escape versus collision by comparing $s$ with $d(x,\\mu)$.\n    - Estimate $T$ as the fraction of histories that escape, and $P_{jj}$ as the fraction that collide before escape.\n4. The physical units must be used as follows: express slab thickness $L$ in centimeters and macroscopic total cross section $\\Sigma_t$ in inverse centimeters. The probabilities $T$ and $P_{jj}$ are dimensionless numbers in $[0,1]$.\n5. Use the following test suite of parameter sets $(L,\\Sigma_t)$, where $L$ is in centimeters and $\\Sigma_t$ is in inverse centimeters:\n    - Test 1 (thin slab): $(10.0, 0.01)$.\n    - Test 2 (moderate slab): $(10.0, 0.1)$.\n    - Test 3 (thick slab): $(10.0, 1.0)$.\n    - Test 4 (very thick slab): $(100.0, 0.5)$.\n6. In your program, for each test case, compute the analytical $T$ and $P_{jj}$ from your derived closed-form, and compare them against the Monte Carlo estimates. Use a uniform accuracy tolerance of $\\varepsilon = 10^{-3}$ on the absolute difference for both $T$ and $P_{jj}$.\n7. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each entry must be a boolean indicating whether both $T$ and $P_{jj}$ passed the accuracy check for the corresponding test case, in the test suite order. For example, a valid output line is of the form $[true\\_or\\_false\\_1,true\\_or\\_false\\_2,true\\_or\\_false\\_3,true\\_or\\_false\\_4]$, where each $true\\_or\\_false\\_k$ is either $\\mathrm{True}$ or $\\mathrm{False}$.",
            "solution": "The problem statement poses a well-defined and scientifically grounded task in the field of neutral particle transport theory. It requests the derivation of fundamental quantities in the Collision Probability Method (CPM) for a one-dimensional slab geometry, followed by a numerical validation using a Monte Carlo simulation. The problem is self-contained, logically consistent, and free of any scientific or mathematical flaws. Therefore, a solution is warranted.\n\nThe core of the problem is to determine the fate of neutrons born from a uniform and isotropic source within a homogeneous slab of thickness $L$ and macroscopic total cross section $\\Sigma_t$. A neutron can either undergo its first interaction inside the slab or escape through one of the vacuum boundaries. We are asked to find the probabilities of these two mutually exclusive events: the self-collision probability $P_{jj}$ and the total transmission (escape) probability $T$.\n\n**1. Derivation of the Total Transmission Probability, $T$**\n\nThe total transmission probability $T$ is the average probability that a neutron, born according to the specified source distribution, will escape the slab without any interaction. The probability that a neutron starting at position $x$ and traveling in a direction specified by the cosine $\\mu$ escapes is given by the first-flight survival probability, $e^{-\\Sigma_t d(x,\\mu)}$, where $d(x,\\mu)$ is the path length from $x$ to the nearest boundary along the direction $\\mu$.\n\nThe source is uniform in space over the interval $x \\in [0, L]$ and isotropic in direction. For one-dimensional slab geometry, an isotropic source is represented by a uniform probability distribution for the directional cosine $\\mu$ over the interval $[-1, 1]$. The averaging over the normalized source distribution is therefore:\n$$ T = \\int_{0}^{L} \\frac{1}{L} \\, dx \\int_{-1}^{1} \\frac{1}{2} \\, d\\mu \\, e^{-\\Sigma_t d(x, \\mu)} = \\frac{1}{2L} \\int_{0}^{L} dx \\int_{-1}^{1} d\\mu \\, e^{-\\Sigma_t d(x, \\mu)} $$\n\nThe distance to the boundary, $d(x, \\mu)$, depends on the sign of $\\mu$:\n- For $\\mu > 0$ (rightward travel), the boundary is at $x=L$. The distance is $d(x, \\mu) = (L-x)/\\mu$.\n- For $\\mu < 0$ (leftward travel), the boundary is at $x=0$. The distance is $d(x, \\mu) = (0-x)/\\mu = -x/\\mu = x/|\\mu|$.\n\nWe can split the integral over $\\mu$ into two parts:\n$$ T = \\frac{1}{2L} \\left[ \\int_{0}^{L} dx \\int_{0}^{1} d\\mu \\, e^{-\\Sigma_t (L-x)/\\mu} + \\int_{0}^{L} dx \\int_{-1}^{0} d\\mu \\, e^{+\\Sigma_t x/\\mu} \\right] $$\n\nLet's evaluate the first term, which represents the probability of escape through the right boundary, $T_{right}$:\n$$ T_{right} = \\frac{1}{2L} \\int_{0}^{1} d\\mu \\int_{0}^{L} dx \\, e^{-\\Sigma_t (L-x)/\\mu} $$\nFirst, we integrate over position $x$. Let $y = L-x$, so $dy = -dx$.\n$$ \\int_{0}^{L} e^{-\\Sigma_t (L-x)/\\mu} \\, dx = \\int_{L}^{0} e^{-\\Sigma_t y/\\mu} \\, (-dy) = \\int_{0}^{L} e^{-\\Sigma_t y/\\mu} \\, dy $$\n$$ \\int_{0}^{L} e^{-\\Sigma_t y/\\mu} \\, dy = \\left[ -\\frac{\\mu}{\\Sigma_t} e^{-\\Sigma_t y/\\mu} \\right]_{0}^{L} = \\frac{\\mu}{\\Sigma_t} \\left(1 - e^{-\\Sigma_t L/\\mu}\\right) $$\nSubstituting this back into the expression for $T_{right}$:\n$$ T_{right} = \\frac{1}{2L} \\int_{0}^{1} \\frac{\\mu}{\\Sigma_t} \\left(1 - e^{-\\Sigma_t L/\\mu}\\right) d\\mu = \\frac{1}{2L\\Sigma_t} \\int_{0}^{1} \\left(\\mu - \\mu e^{-\\Sigma_t L/\\mu}\\right) d\\mu $$\nLet $a = \\Sigma_t L$ be the dimensionless optical thickness of the slab. The expression becomes:\n$$ T_{right} = \\frac{1}{2a} \\left[ \\int_{0}^{1} \\mu \\, d\\mu - \\int_{0}^{1} \\mu e^{-a/\\mu} \\, d\\mu \\right] $$\nThe first integral is elementary: $\\int_{0}^{1} \\mu \\, d\\mu = [\\mu^2/2]_0^1 = 1/2$.\nFor the second integral, we perform a change of variables. Let $t = 1/\\mu$, so $\\mu = 1/t$ and $d\\mu = -1/t^2 \\, dt$. The integration limits change from $\\mu \\in (0,1]$ to $t \\in (\\infty, 1]$.\n$$ \\int_{0}^{1} \\mu e^{-a/\\mu} \\, d\\mu = \\int_{\\infty}^{1} \\frac{1}{t} e^{-at} \\left(-\\frac{1}{t^2}\\right) dt = \\int_{1}^{\\infty} \\frac{e^{-at}}{t^3} \\, dt $$\nThis integral is, by definition, the generalized exponential integral of order $3$, $E_3(a)$, where $E_n(x) = \\int_{1}^{\\infty} \\frac{e^{-xt}}{t^n} \\, dt$.\nTherefore, $\\int_{0}^{1} \\mu e^{-a/\\mu} \\, d\\mu = E_3(a)$.\nSubstituting these results back, we find the escape probability through the right boundary:\n$$ T_{right} = \\frac{1}{2a} \\left(\\frac{1}{2} - E_3(a)\\right) $$\nDue to the symmetry of the uniform source and slab geometry, the escape probability through the left boundary, $T_{left}$, is identical to $T_{right}$. The total transmission probability is $T = T_{left} + T_{right} = 2T_{right}$.\n$$ T(a) = 2 \\cdot \\frac{1}{2a} \\left(\\frac{1}{2} - E_3(a)\\right) = \\frac{1 - 2E_3(a)}{2a} $$\nThis is the required closed-form expression for the total transmission probability.\n\n**2. Derivation of the Self-Collision Probability, $P_{jj}$**\n\nFor a neutron born within the single homogeneous region (denoted by index $j$), there are only two possible outcomes in this system with vacuum boundaries: it either collides within the region or it escapes. This is an expression of the conservation of particles (or probability).\n$$ P_{jj} + T = 1 $$\nTherefore, the self-collision probability $P_{jj}$ is simply the complement of the total transmission probability:\n$$ P_{jj}(a) = 1 - T(a) = 1 - \\frac{1 - 2E_3(a)}{2a} $$\n\n**3. Design of the Numerical Validation Experiment**\n\nTo validate the derived analytical expressions, we construct a direct simulation of the physical process using the Monte Carlo method. For a large number of independent trials (neutron histories), we track the fate of each neutron according to the fundamental principles outlined in the problem.\n\nFor each of $N$ neutron histories:\n1.  **Sample Initial State**: A neutron is born at a position $x$ and with a directional cosine $\\mu$.\n    - Position $x$ is sampled from a uniform distribution over $[0, L]$: $x = L \\cdot \\xi_1$, where $\\xi_1 \\sim U(0,1)$.\n    - Direction $\\mu$ is sampled from a uniform distribution over $[-1, 1]$: $\\mu = 2 \\cdot \\xi_2 - 1$, where $\\xi_2 \\sim U(0,1)$.\n\n2.  **Determine Distance to Boundary**: The distance $d$ a neutron must travel to escape is calculated based on its starting position and direction:\n    $$ d(x, \\mu) = \\begin{cases} (L-x)/\\mu & \\text{if } \\mu > 0 \\\\ -x/\\mu & \\text{if } \\mu < 0 \\\\ \\infty & \\text{if } \\mu = 0 \\end{cases} $$\n\n3.  **Sample Path Length**: The distance $s$ a neutron travels before its first interaction (collision) is a random variable governed by the exponential probability distribution $p(s) = \\Sigma_t e^{-\\Sigma_t s}$. This can be sampled using the inverse transform method:\n    - $s = -\\frac{\\ln(\\xi_3)}{\\Sigma_t}$, where $\\xi_3 \\sim U(0,1)$.\n\n4.  **Determine Fate**: The neutron's fate is decided by comparing the sampled path length $s$ to the distance to the boundary $d$:\n    - If $s < d$, the neutron collides before it can escape. We tally this as a collision event.\n    - If $s \\ge d$, the neutron escapes without an interaction. We tally this as a transmission (escape) event.\n\n5.  **Estimate Probabilities**: After simulating $N$ histories, we count the total number of escapes, $N_{esc}$, and collisions, $N_{coll}$. The probabilities are estimated as the fractions of these outcomes:\n    - $T_{MC} \\approx N_{esc} / N$\n    - $P_{jj, MC} \\approx N_{coll} / N$\nBy construction, $N_{esc} + N_{coll} = N$, so the estimates also satisfy $T_{MC} + P_{jj, MC} = 1$. The physical units of $L$ (cm) and $\\Sigma_t$ (cm$^{-1}$) are consistent, yielding a dimensionless optical thickness $a=\\Sigma_t L$.\n\nThe comparison of the analytical results ($T(a), P_{jj}(a)$) with the Monte Carlo estimates ($T_{MC}, P_{jj, MC}$) provides a robust validation of the derived formulas. The agreement is expected to improve as the number of histories $N$ increases, with the statistical uncertainty of the Monte Carlo estimates scaling as $1/\\sqrt{N}$. The provided implementation will use a sufficiently large $N$ to meet the specified accuracy tolerance.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import expn\n\ndef solve():\n    \"\"\"\n    Performs the validation experiment for the Collision Probability Method\n    in 1D slab geometry.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (L [cm], Sigma_t [1/cm]).\n    test_cases = [\n        (10.0, 0.01),   # Test 1 (thin slab)\n        (10.0, 0.1),    # Test 2 (moderate slab)\n        (10.0, 1.0),    # Test 3 (thick slab)\n        (100.0, 0.5),   # Test 4 (very thick slab)\n    ]\n\n    # Number of neutron histories for the Monte Carlo simulation.\n    # Chosen to be large enough to meet the specified tolerance with high confidence.\n    N_HISTORIES = 5_000_000\n\n    # Accuracy tolerance for validation.\n    TOLERANCE = 1e-3\n\n    # List to store the boolean validation results.\n    results = []\n\n    # Use a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed=42)\n\n    for L, Sigma_t in test_cases:\n        # --- Analytical Calculation ---\n\n        # Calculate the dimensionless optical thickness 'a'.\n        a = Sigma_t * L\n\n        # Handle the case a -> 0 separately to avoid division by zero,\n        # although the test cases do not include a=0.\n        # In the limit a -> 0, T -> 1.\n        if np.isclose(a, 0.0):\n            T_analytical = 1.0\n        else:\n            # Use scipy.special.expn(n, x) for the generalized exponential integral E_n(x).\n            E3_a = expn(3, a)\n            # Derived formula for total transmission probability T.\n            T_analytical = (1.0 - 2.0 * E3_a) / (2.0 * a)\n\n        # Derived formula for self-collision probability P_jj.\n        P_jj_analytical = 1.0 - T_analytical\n\n        # --- Monte Carlo Simulation ---\n\n        # 1. Sample initial positions and directions.\n        # x is uniform in [0, L]\n        x_samples = L * rng.random(N_HISTORIES)\n        # mu is uniform in [-1, 1]\n        mu_samples = 2.0 * rng.random(N_HISTORIES) - 1.0\n\n        # 2. Compute distance to boundary for each neutron.\n        # Initialize distance array with infinity.\n        d_to_boundary = np.full(N_HISTORIES, np.inf)\n\n        # Create masks for positive and negative directions.\n        # This approach robustly handles mu=0, where d remains infinity.\n        mask_pos = mu_samples > 0\n        mask_neg = mu_samples < 0\n\n        # Calculate distance for rightward-moving neutrons.\n        d_to_boundary[mask_pos] = (L - x_samples[mask_pos]) / mu_samples[mask_pos]\n        # Calculate distance for leftward-moving neutrons.\n        d_to_boundary[mask_neg] = -x_samples[mask_neg] / mu_samples[mask_neg]\n\n        # 3. Sample free-flight path lengths from the exponential distribution.\n        # s = -ln(xi) / Sigma_t, where xi is a uniform random number in (0, 1].\n        # We sample from [0,1) but numerically the probability of 0 is negligible.\n        if np.isclose(Sigma_t, 0.0):\n            # For a \"vacuum\" slab, path length is infinite.\n            s_path_lengths = np.full(N_HISTORIES, np.inf)\n        else:\n            s_path_lengths = -np.log(rng.random(N_HISTORIES)) / Sigma_t\n\n        # 4. Determine fate: collision vs. escape.\n        # A neutron escapes if its path length is >= the distance to the boundary.\n        escapes = np.sum(s_path_lengths >= d_to_boundary)\n\n        # 5. Estimate probabilities.\n        T_mc = escapes / N_HISTORIES\n        P_jj_mc = 1.0 - T_mc\n\n        # --- Validation ---\n\n        # Check if the absolute differences are within the tolerance.\n        pass_T = np.abs(T_analytical - T_mc) < TOLERANCE\n        pass_Pjj = np.abs(P_jj_analytical - P_jj_mc) < TOLERANCE\n\n        # The problem requires a check for both, although they are dependent.\n        validation_passed = pass_T and pass_Pjj\n        results.append(validation_passed)\n\n    # Final print statement in the exact required format.\n    # map(str,...) converts Python's True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While calculating individual collision probabilities is a fundamental skill, the true power of CPM is realized when analyzing coupled, multiplying systems that model a nuclear reactor. This exercise moves beyond single-region analysis to the core problem in reactor physics: determining the system's criticality, represented by the effective multiplication factor, $k_{\\text{eff}}$. You will formulate the governing CPM equations for a two-region system as a generalized eigenvalue problem, a crucial step that translates the physics of neutron balance into the linear algebra framework solved by production-level reactor analysis codes .",
            "id": "4217785",
            "problem": "Consider a steady-state, one-speed, isotropic-scattering system composed of two homogeneous regions with vacuum boundaries and no external source. Let region $1$ and region $2$ have total cross sections $\\Sigma_{t,1}$ and $\\Sigma_{t,2}$, scattering cross sections $\\Sigma_{s,1}$ and $\\Sigma_{s,2}$, and volumes $V_1$ and $V_2$, respectively. Assume neutron production by fission occurs only in region $1$, with average neutrons per fission times macroscopic fission cross section $\\nu \\Sigma_{f,1}$, and that neutron emission spectrum is single-group (so no energy coupling). Let $P_{ij}$ denote the collision probability that a neutron born uniformly and isotropically in region $j$ will suffer its next collision in region $i$. The region-averaged fluxes are $\\phi_1$ and $\\phi_2$, and the region-wise source densities are $S_1$ and $S_2$. In the eigenvalue formulation, the fission source density is scaled by the effective multiplication factor $k_{\\mathrm{eff}}$ as $S_{f,1} = \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1$, while scattering source densities are $S_{s,i} = \\Sigma_{s,i} \\phi_i$.\n\nUsing the collision probability method, the fundamental balance is that the total collision rate in region $i$ equals the fraction of all births in every region that collide in region $i$, that is, $\\Sigma_{t,i} \\phi_i V_i = \\sum_{j=1}^2 P_{ij} S_j V_j$. With $S_1 = \\Sigma_{s,1} \\phi_1 + \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1$ and $S_2 = \\Sigma_{s,2} \\phi_2$, this yields a generalized eigenvalue problem for $k_{\\mathrm{eff}}$ coupled to $\\phi_1$ and $\\phi_2$. A practical solution employs an iterative search for $k_{\\mathrm{eff}}$ that alternates between solving a fixed-source linear system and updating $k_{\\mathrm{eff}}$ based on the resulting fission source.\n\nWhich option correctly sets up the collision probability method equations for the two-region $k_{\\mathrm{eff}}$ problem and outlines a convergent iterative algorithm for determining $k_{\\mathrm{eff}}$?\n\nA. The region-averaged collision balances are\n$$\n\\Sigma_{t,1} \\phi_1 V_1 = P_{11} V_1 \\left(\\Sigma_{s,1} \\phi_1 + \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1\\right) + P_{12} V_2 \\left(\\Sigma_{s,2} \\phi_2\\right),\n$$\n$$\n\\Sigma_{t,2} \\phi_2 V_2 = P_{21} V_1 \\left(\\Sigma_{s,1} \\phi_1 + \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1\\right) + P_{22} V_2 \\left(\\Sigma_{s,2} \\phi_2\\right).\n$$\nRearranged as a generalized eigenvalue problem,\n$$\n\\begin{bmatrix}\n\\Sigma_{t,1} V_1 - P_{11} V_1 \\Sigma_{s,1} & - P_{12} V_2 \\Sigma_{s,2} \\\\\n- P_{21} V_1 \\Sigma_{s,1} & \\Sigma_{t,2} V_2 - P_{22} V_2 \\Sigma_{s,2}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi_1 \\\\ \\phi_2\n\\end{bmatrix}\n=\n\\frac{1}{k_{\\mathrm{eff}}}\n\\begin{bmatrix}\nP_{11} V_1 \\nu \\Sigma_{f,1} & 0 \\\\\nP_{21} V_1 \\nu \\Sigma_{f,1} & 0\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi_1 \\\\ \\phi_2\n\\end{bmatrix}.\n$$\nAn iterative algorithm:\n- Initialize $k_{\\mathrm{eff}}^{(0)}$ and a positive flux $\\phi^{(0)}$.\n- For iteration $m$, form the fixed fission source vector $b^{(m)}$ with components $b_1^{(m)} = P_{11} V_1 \\nu \\Sigma_{f,1} \\phi_1^{(m)}$, $b_2^{(m)} = P_{21} V_1 \\nu \\Sigma_{f,1} \\phi_1^{(m)}$.\n- Solve the linear system\n$$\n\\begin{bmatrix}\n\\Sigma_{t,1} V_1 - P_{11} V_1 \\Sigma_{s,1} & - P_{12} V_2 \\Sigma_{s,2} \\\\\n- P_{21} V_1 \\Sigma_{s,1} & \\Sigma_{t,2} V_2 - P_{22} V_2 \\Sigma_{s,2}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\phi_1^{(m+1)} \\\\ \\phi_2^{(m+1)}\n\\end{bmatrix}\n=\n\\frac{1}{k_{\\mathrm{eff}}^{(m)}}\n\\begin{bmatrix}\nb_1^{(m)} \\\\ b_2^{(m)}\n\\end{bmatrix}.\n$$\n- Update\n$$\nk_{\\mathrm{eff}}^{(m+1)} = k_{\\mathrm{eff}}^{(m)} \\, \\frac{\\nu \\Sigma_{f,1} \\phi_1^{(m+1)} V_1}{\\nu \\Sigma_{f,1} \\phi_1^{(m)} V_1},\n$$\noptionally normalizing $\\phi^{(m+1)}$ by fixing $\\nu \\Sigma_{f,1} \\phi_1^{(m+1)} V_1$ to a constant. Iterate until $k_{\\mathrm{eff}}$ and $\\phi$ converge.\n\nB. The region-averaged balances are\n$$\n\\phi_1 = \\frac{P_{11} S_1 + P_{12} S_2}{\\Sigma_{t,2}}, \\quad \\phi_2 = \\frac{P_{21} S_1 + P_{22} S_2}{\\Sigma_{t,1}},\n$$\nwith $S_1 = \\Sigma_{s,1} \\phi_1 + \\nu \\Sigma_{f,1} \\phi_1$ and $S_2 = \\Sigma_{s,2} \\phi_2$. The algorithm initializes $k_{\\mathrm{eff}}^{(0)}$ and then updates\n$$\nk_{\\mathrm{eff}}^{(m+1)} = \\frac{\\Sigma_{a,1} \\phi_1^{(m+1)} V_1 + \\Sigma_{a,2} \\phi_2^{(m+1)} V_2}{\\Sigma_{a,1} \\phi_1^{(m)} V_1 + \\Sigma_{a,2} \\phi_2^{(m)} V_2},\n$$\nwhere $\\Sigma_{a,i} = \\Sigma_{t,i} - \\Sigma_{s,i}$.\n\nC. The balances are\n$$\n\\Sigma_{t,1} \\phi_1 V_1 = P_{11} V_1 \\left(\\Sigma_{s,1} \\phi_1\\right) + P_{12} V_2 \\left(\\Sigma_{s,2} \\phi_2\\right),\n$$\n$$\n\\Sigma_{t,2} \\phi_2 V_2 = P_{21} V_1 \\left(\\Sigma_{s,1} \\phi_1\\right) + P_{22} V_2 \\left(\\Sigma_{s,2} \\phi_2\\right),\n$$\nwith the fission source added to region $2$ as $S_{f,2} = \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1$. The iteration solves\n$$\n\\left[\\Sigma_{t} V - P V \\Sigma_s\\right] \\phi^{(m+1)} = \\frac{1}{k_{\\mathrm{eff}}^{(m)}} \\begin{bmatrix} 0 \\\\ V_2 \\nu \\Sigma_{f,1} \\phi_1^{(m)} \\end{bmatrix},\n$$\nand updates\n$$\nk_{\\mathrm{eff}}^{(m+1)} = \\frac{\\phi_1^{(m+1)} + \\phi_2^{(m+1)}}{\\phi_1^{(m)} + \\phi_2^{(m)}}.\n$$\n\nD. The balances are written as\n$$\n\\left(I - P\\right) \\begin{bmatrix} \\phi_1 \\\\ \\phi_2 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n$$\nwith $S_1 = \\Sigma_{s,1} \\phi_1 + \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1$ and $S_2 = \\Sigma_{s,2} \\phi_2$. The algorithm sets $k_{\\mathrm{eff}}$ by requiring zero leakage, i.e.,\n$$\nk_{\\mathrm{eff}}^{(m+1)} = \\frac{\\sum_{j} \\left(1 - \\sum_{i} P_{ij}\\right) S_j^{(m)} V_j}{\\sum_{j} \\left(1 - \\sum_{i} P_{ij}\\right) S_j^{(m-1)} V_j},\n$$\nand stops when leakage vanishes.\n\nSelect the correct option.",
            "solution": "The user wants me to validate the provided problem statement and, if valid, derive the correct formulation for a two-region $k_{\\mathrm{eff}}$ eigenvalue problem using the collision probability method (CPM), and then evaluate the given options.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\n*   **System**: Steady-state, one-speed, isotropic scattering, two homogeneous regions, vacuum boundaries, no external source.\n*   **Region 1**: Total cross section $\\Sigma_{t,1}$, scattering cross section $\\Sigma_{s,1}$, volume $V_1$, fission term $\\nu \\Sigma_{f,1}$, region-averaged flux $\\phi_1$, source density $S_1$.\n*   **Region 2**: Total cross section $\\Sigma_{t,2}$, scattering cross section $\\Sigma_{s,2}$, volume $V_2$, region-averaged flux $\\phi_2$, source density $S_2$. No fission.\n*   **Collision Probability $P_{ij}$**: Probability a neutron born uniformly and isotropically in region $j$ has its next collision in region $i$.\n*   **Source Densities**:\n    *   $S_{f,1} = \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1$ (fission, scaled by eigenvalue $k_{\\mathrm{eff}}$)\n    *   $S_{s,i} = \\Sigma_{s,i} \\phi_i$ (scattering)\n    *   $S_1 = S_{s,1} + S_{f,1} = \\Sigma_{s,1} \\phi_1 + \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1$\n    *   $S_2 = S_{s,2} = \\Sigma_{s,2} \\phi_2$\n*   **Fundamental Balance Equation**: $\\Sigma_{t,i} \\phi_i V_i = \\sum_{j=1}^2 P_{ij} S_j V_j$. This states that the collision rate in region $i$ equals the rate of first collisions in region $i$ for neutrons born in all regions.\n*   **Iterative Solution**: The problem describes a standard power-iteration-like method, alternating between a fixed-source solve and an update of the eigenvalue $k_{\\mathrm{eff}}$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem statement is scientifically sound, well-posed, and objective. It provides a standard formulation of a common problem in nuclear reactor physics, specifically the cell/assembly calculation using integral transport theory (collision probability method). The concepts, variables, and governing equations are all standard and correctly defined within this context. There are no contradictions, missing information, or pseudoscientific elements. The problem is a valid test of understanding of numerical methods in reactor analysis.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. I will now proceed with the derivation and evaluation of the options.\n\n### Derivation of the CPM Equations\n\nThe fundamental balance equation for region $i$ is given as:\n$$ \\Sigma_{t,i} \\phi_i V_i = \\sum_{j=1}^2 P_{ij} S_j V_j $$\nThis equates the total collision rate in region $i$ to the sum of neutrons born in each region $j$ that then have their first collision in region $i$.\n\nWe write out this balance for each of the two regions.\n\n**For region 1 ($i=1$):**\n$$ \\Sigma_{t,1} \\phi_1 V_1 = P_{11} S_1 V_1 + P_{12} S_2 V_2 $$\nSubstitute the expressions for the source densities $S_1$ and $S_2$:\n$$ \\Sigma_{t,1} \\phi_1 V_1 = P_{11} V_1 \\left( \\Sigma_{s,1} \\phi_1 + \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1 \\right) + P_{12} V_2 \\left( \\Sigma_{s,2} \\phi_2 \\right) $$\n\n**For region 2 ($i=2$):**\n$$ \\Sigma_{t,2} \\phi_2 V_2 = P_{21} S_1 V_1 + P_{22} S_2 V_2 $$\nSubstitute the expressions for the source densities $S_1$ and $S_2$:\n$$ \\Sigma_{t,2} \\phi_2 V_2 = P_{21} V_1 \\left( \\Sigma_{s,1} \\phi_1 + \\frac{1}{k_{\\mathrm{eff}}} \\nu \\Sigma_{f,1} \\phi_1 \\right) + P_{22} V_2 \\left( \\Sigma_{s,2} \\phi_2 \\right) $$\nThese two equations represent the coupled system for the fluxes $\\phi_1$ and $\\phi_2$ and the eigenvalue $k_{\\mathrm{eff}}$.\n\n### Transformation to a Generalized Eigenvalue Problem\n\nTo solve this system, we rearrange the equations to isolate the terms multiplied by $\\frac{1}{k_{\\mathrm{eff}}}$. This puts the system into the standard generalized eigenvalue problem form $M\\vec{\\phi} = \\lambda F \\vec{\\phi}$, where $\\lambda = \\frac{1}{k_{\\mathrm{eff}}}$ and $\\vec{\\phi} = [\\phi_1, \\phi_2]^T$.\n\nFrom the equation for region 1:\n$$ \\Sigma_{t,1} \\phi_1 V_1 = P_{11} V_1 \\Sigma_{s,1} \\phi_1 + P_{12} V_2 \\Sigma_{s,2} \\phi_2 + \\frac{1}{k_{\\mathrm{eff}}} P_{11} V_1 \\nu \\Sigma_{f,1} \\phi_1 $$\n$$ (\\Sigma_{t,1} V_1 - P_{11} V_1 \\Sigma_{s,1}) \\phi_1 - (P_{12} V_2 \\Sigma_{s,2}) \\phi_2 = \\frac{1}{k_{\\mathrm{eff}}} (P_{11} V_1 \\nu \\Sigma_{f,1}) \\phi_1 $$\n\nFrom the equation for region 2:\n$$ \\Sigma_{t,2} \\phi_2 V_2 = P_{21} V_1 \\Sigma_{s,1} \\phi_1 + P_{22} V_2 \\Sigma_{s,2} \\phi_2 + \\frac{1}{k_{\\mathrm{eff}}} P_{21} V_1 \\nu \\Sigma_{f,1} \\phi_1 $$\n$$ -(P_{21} V_1 \\Sigma_{s,1}) \\phi_1 + (\\Sigma_{t,2} V_2 - P_{22} V_2 \\Sigma_{s,2}) \\phi_2 = \\frac{1}{k_{\\mathrm{eff}}} (P_{21} V_1 \\nu \\Sigma_{f,1}) \\phi_1 $$\n\nThese two linear equations can be written in matrix form:\n$$\n\\underbrace{\n\\begin{bmatrix}\n\\Sigma_{t,1} V_1 - P_{11} V_1 \\Sigma_{s,1} & -P_{12} V_2 \\Sigma_{s,2} \\\\\n-P_{21} V_1 \\Sigma_{s,1} & \\Sigma_{t,2} V_2 - P_{22} V_2 \\Sigma_{s,2}\n\\end{bmatrix}\n}_{M}\n\\begin{bmatrix} \\phi_1 \\\\ \\phi_2 \\end{bmatrix}\n= \\frac{1}{k_{\\mathrm{eff}}}\n\\underbrace{\n\\begin{bmatrix}\nP_{11} V_1 \\nu \\Sigma_{f,1} & 0 \\\\\nP_{21} V_1 \\nu \\Sigma_{f,1} & 0\n\\end{bmatrix}\n}_{F}\n\\begin{bmatrix} \\phi_1 \\\\ \\phi_2 \\end{bmatrix}\n$$\nThe matrix $M$ represents neutron loss due to collisions and transport, offset by in-scattering. The matrix $F$ represents neutron production from fission.\n\n### Iterative Solution (Power Iteration)\n\nThe eigenvalue problem $M\\vec{\\phi} = \\frac{1}{k_{\\mathrm{eff}}} F\\vec{\\phi}$ is typically solved using the power iteration method (also known as source iteration in this context).\n\n1.  Start with an initial guess for the flux eigenvector $\\vec{\\phi}^{(0)}$ and the eigenvalue $k_{\\mathrm{eff}}^{(0)}$.\n2.  For iteration $m=0, 1, 2, \\dots$:\n    a. Calculate the fission source vector based on the previous iteration's flux: $\\vec{S}_f^{(m)} = F \\vec{\\phi}^{(m)}$.\n    b. Solve the following fixed-source linear system for the new flux vector $\\vec{\\phi}^{(m+1)}$:\n    $$ M \\vec{\\phi}^{(m+1)} = \\frac{1}{k_{\\mathrm{eff}}^{(m)}} \\vec{S}_f^{(m)} = \\frac{1}{k_{\\mathrm{eff}}^{(m)}} F \\vec{\\phi}^{(m)} $$\n    c. Calculate the total fission neutron production rate from the new flux: $Q_f^{(m+1)} = \\nu \\Sigma_{f,1} \\phi_1^{(m+1)} V_1$.\n    d. Update the eigenvalue using the ratio of fission production rates:\n    $$ k_{\\mathrm{eff}}^{(m+1)} = k_{\\mathrm{eff}}^{(m)} \\frac{Q_f^{(m+1)}}{Q_f^{(m)}} = k_{\\mathrm{eff}}^{(m)} \\frac{\\nu \\Sigma_{f,1} \\phi_1^{(m+1)} V_1}{\\nu \\Sigma_{f,1} \\phi_1^{(m)} V_1} $$\n    This can also be interpreted as $k_{\\mathrm{eff}}^{(m+1)} = \\frac{\\text{Production from } \\vec{\\phi}^{(m+1)}}{\\text{Source used for } \\vec{\\phi}^{(m+1)}} = \\frac{\\nu \\Sigma_{f,1} \\phi_1^{(m+1)} V_1}{(\\nu \\Sigma_{f,1} \\phi_1^{(m)} V_1) / k_{\\mathrm{eff}}^{(m)}}$.\n3.  Repeat until $k_{\\mathrm{eff}}$ and $\\vec{\\phi}$ converge. The flux vector is typically normalized at each step to prevent its magnitude from becoming too large or small.\n\n### Option-by-Option Analysis\n\n**Option A:**\nThis option presents the two balance equations exactly as derived above. It then correctly rearranges them into the generalized eigenvalue matrix problem $M\\vec{\\phi} = \\frac{1}{k_{\\mathrm{eff}}} F\\vec{\\phi}$, with matrices $M$ and $F$ that match our derivation. Finally, it outlines the power iteration algorithm. The linear system to be solved at each step, $M\\vec{\\phi}^{(m+1)} = \\frac{1}{k_{\\mathrm{eff}}^{(m)}} F\\vec{\\phi}^{(m)}$, is correctly stated. The update rule for $k_{\\mathrm{eff}}$ is the standard source-ratio method, which is also correct.\n**Verdict: Correct**\n\n**Option B:**\nThe balance equations are fundamentally flawed. They have swapped denominators ($\\Sigma_{t,2}$ for the $\\phi_1$ equation and vice versa) and omit the volumes $V_i$. The source definition $S_1$ is missing the crucial eigenvalue scaling factor $\\frac{1}{k_{\\mathrm{eff}}}$. The proposed $k_{\\mathrm{eff}}$ update formula is a ratio of total absorption rates, which is physically meaningless for determining the multiplication factor.\n**Verdict: Incorrect**\n\n**Option C:**\nThe balance equations incorrectly omit the fission source from the expression for $S_1$. It then contradicts the problem statement by asserting the fission source is added to region $2$. The iterative algorithm's right-hand-side vector is inconsistent with the physics of neutron transport (implying fission neutrons only collide in region 2) and contains a dimensionally incorrect term. The $k_{\\mathrm{eff}}$ update formula, a simple ratio sum of fluxes, lacks any physical basis.\n**Verdict: Incorrect**\n\n**Option D:**\nThe initial matrix equation, $\\left(I - P\\right) \\vec{\\phi} = 0$, does not represent the neutron balance equation and is physically obscure. The algorithm's premise of setting $k_{\\mathrm{eff}}$ by requiring zero leakage is physically incorrect for a finite system with vacuum boundaries, which must leak neutrons to be in a steady state. The update formula for $k_{\\mathrm{eff}}$ is just a ratio of total leakage rates between iterations, which is not a valid method for determining $k_{\\mathrm{eff}}$.\n**Verdict: Incorrect**\n\nBased on the detailed derivation, only Option A provides a completely correct representation of the collision probability method for this eigenvalue problem and a valid iterative solution scheme.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "In any real-world engineering simulation, the input parameters—such as material cross sections and physical dimensions—are never known with perfect certainty. A robust analysis requires understanding how these input uncertainties propagate through the physical model to affect the final results. This advanced practice places the CPM calculation into a modern research context by using it as a \"forward model\" within a Bayesian uncertainty quantification (BUQ) framework, giving you hands-on experience with the powerful combination of transport physics and statistical inference .",
            "id": "4217767",
            "problem": "Consider a two-region, one-dimensional slab geometry used in collision probability methods for nuclear reactor simulation. Region $i$ (fuel) occupies the interval $x \\in [0,L_i]$ and region $j$ (moderator) occupies $x \\in [L_i, L_i + L_j]$. Vacuum boundary conditions exist at $x = 0$ and $x = L_i + L_j$. A uniform, isotropic volumetric source of neutrons of intensity $S_i$ (neutrons per second) operates in region $i$. The total macroscopic cross section $\\Sigma_{t,k}$ in region $k \\in \\{i,j\\}$ is spatially uniform within each region.\n\nThe collision probability $P_{ij}$ is defined as the probability that the first collision of a neutron born in region $i$ occurs in region $j$. Begin from the following fundamental bases:\n- Neutron exponential attenuation: the survival probability along a straight path of length $s$ in a homogeneous region with total macroscopic cross section $\\Sigma_t$ is $\\exp(-\\Sigma_t s)$.\n- Isotropic emission: for planar geometry, the direction cosine $\\mu$ between the flight direction and the $x$-axis is distributed uniformly on $[-1,1]$.\n- First collision is the first interaction event encountered along the straight-line trajectory; there is no scattering or geometry change before the first collision.\n\nUsing only these bases, formulate $P_{ij}$ for the specified slab geometry as an average (over birth position and direction) of the event that there is no collision in region $i$ before the interface at $x=L_i$, followed by a collision in region $j$ before exiting to vacuum at $x=L_i+L_j$. You must not introduce any shortcut formulas beyond what follows from the fundamental bases.\n\nUncertainty is present in both material and geometric properties. Use a Bayesian uncertainty quantification (BUQ) framework:\n- Priors:\n  - $\\Sigma_{t,i}$ and $\\Sigma_{t,j}$ have independent lognormal priors with specified means $m_{\\Sigma_{t,i}}$ and $m_{\\Sigma_{t,j}}$ (in $\\mathrm{cm}^{-1}$), and specified coefficients of variation $\\mathrm{cv}_{\\Sigma_{t,i}}$ and $\\mathrm{cv}_{\\Sigma_{t,j}}$ (unitless).\n  - $L_i$ and $L_j$ have independent truncated normal priors with specified means $m_{L_i}$ and $m_{L_j}$ (in $\\mathrm{cm}$), standard deviations $s_{L_i}$ and $s_{L_j}$ (in $\\mathrm{cm}$), truncated below at $0$ (in $\\mathrm{cm}$).\n- Observation model:\n  - A detector provides a measured count rate $y_j$ (dimensionless counts per second), modeled as $y_j \\sim \\mathcal{N}(S_i P_{ij}, \\sigma_{\\mathrm{obs}}^2)$, where $\\sigma_{\\mathrm{obs}}$ (in counts per second) is known.\n\nImplement a Monte Carlo (MC) estimator to compute $P_{ij}$ for a given parameter set $(\\Sigma_{t,i}, \\Sigma_{t,j}, L_i, L_j)$ by sampling birth positions uniformly in $x \\in [0,L_i]$ and direction cosines $\\mu$ uniformly in $\\mu \\in (0,1]$ to represent right-going neutrons towards region $j$, and averaging the event probability implied by the fundamental bases. Then perform importance sampling to approximate the posterior distribution of $P_{ij}$ given the observation $y_j$, using prior samples and Gaussian likelihood weights proportional to $\\exp\\left(-\\frac{1}{2}\\left(\\frac{y_j - S_i P_{ij}}{\\sigma_{\\mathrm{obs}}}\\right)^2\\right)$.\n\nFor each test case, compute the posterior mean and posterior variance of $P_{ij}$. Express $P_{ij}$ as a dimensionless probability (unitless). Use angles in radians implicitly via the direction cosine distribution on $[-1,1]$. Ensure all lengths are in $\\mathrm{cm}$ and all macroscopic cross sections are in $\\mathrm{cm}^{-1}$. Use a fixed random seed for reproducibility.\n\nTest suite parameter sets:\n- Case $1$ (happy path, moderate uncertainties):\n  - $m_{\\Sigma_{t,i}} = 0.8\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,i}} = 0.20$\n  - $m_{\\Sigma_{t,j}} = 0.5\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,j}} = 0.25$\n  - $m_{L_i} = 2.0\\,\\mathrm{cm}$, $s_{L_i} = 0.2\\,\\mathrm{cm}$\n  - $m_{L_j} = 4.0\\,\\mathrm{cm}$, $s_{L_j} = 0.3\\,\\mathrm{cm}$\n  - $S_i = 1.0\\times 10^{6}$ (neutrons per second), $y_j = 2.10\\times 10^{5}$ (counts per second), $\\sigma_{\\mathrm{obs}} = 2.00\\times 10^{4}$ (counts per second)\n  - Number of prior samples $N_{\\mathrm{prior}} = 400$, inner MC samples per prior draw $N_{\\mathrm{inner}} = 600$\n- Case $2$ (boundary geometry: thin moderator region):\n  - $m_{\\Sigma_{t,i}} = 0.9\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,i}} = 0.15$\n  - $m_{\\Sigma_{t,j}} = 0.6\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,j}} = 0.20$\n  - $m_{L_i} = 3.0\\,\\mathrm{cm}$, $s_{L_i} = 0.3\\,\\mathrm{cm}$\n  - $m_{L_j} = 0.5\\,\\mathrm{cm}$, $s_{L_j} = 0.05\\,\\mathrm{cm}$\n  - $S_i = 1.5\\times 10^{6}$ (neutrons per second), $y_j = 3.80\\times 10^{4}$ (counts per second), $\\sigma_{\\mathrm{obs}} = 1.00\\times 10^{4}$ (counts per second)\n  - Number of prior samples $N_{\\mathrm{prior}} = 500$, inner MC samples per prior draw $N_{\\mathrm{inner}} = 500$\n- Case $3$ (material edge: strong absorption in region $i$):\n  - $m_{\\Sigma_{t,i}} = 3.0\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,i}} = 0.30$\n  - $m_{\\Sigma_{t,j}} = 0.4\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,j}} = 0.30$\n  - $m_{L_i} = 2.0\\,\\mathrm{cm}$, $s_{L_i} = 0.2\\,\\mathrm{cm}$\n  - $m_{L_j} = 3.0\\,\\mathrm{cm}$, $s_{L_j} = 0.3\\,\\mathrm{cm}$\n  - $S_i = 1.0\\times 10^{6}$ (neutrons per second), $y_j = 7.00\\times 10^{3}$ (counts per second), $\\sigma_{\\mathrm{obs}} = 5.00\\times 10^{3}$ (counts per second)\n  - Number of prior samples $N_{\\mathrm{prior}} = 450$, inner MC samples per prior draw $N_{\\mathrm{inner}} = 600$\n\nYour program must:\n- Implement the BUQ via importance sampling as described.\n- For each case, return the posterior mean and posterior variance of $P_{ij}$ as floats.\n- Use a single fixed random seed.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as $[\\text{mean}_1,\\text{var}_1,\\text{mean}_2,\\text{var}_2,\\text{mean}_3,\\text{var}_3]$.\n- Round each float in the output to $6$ decimal places.",
            "solution": "This problem requires deriving an estimator for a collision probability and using it within a Bayesian uncertainty quantification framework.\n\n#### 1. Formulation of the $P_{ij}$ Estimator\n\nThe quantity to compute is $P_{ij}$, the probability that a neutron born uniformly and isotropically in region $i$ (from $x=0$ to $x=L_i$) has its first collision in region $j$ (from $x=L_i$ to $x=L_i+L_j$).\n\n-   A neutron is born at position $x_0$, sampled from a uniform distribution $\\mathcal{U}(0, L_i)$.\n-   Its direction of flight is given by the cosine $\\mu$, sampled from a uniform distribution $\\mathcal{U}(-1, 1)$.\n-   For a neutron to reach region $j$, it must be born with a positive direction cosine, $\\mu > 0$. Due to the isotropic source, the probability of this is $1/2$.\n-   Given a birth at $(x_0, \\mu)$ with $\\mu > 0$, the neutron must first travel from $x_0$ to the interface at $x=L_i$ without colliding. The path length in region $i$ is $s_i = (L_i - x_0) / \\mu$. The probability of surviving this path is $p_{\\text{surv}, i} = \\exp(-\\Sigma_{t,i} s_i)$.\n-   Having reached region $j$, the neutron must then collide within this region. The total path length available in region $j$ before exiting to vacuum is $s_j = L_j / \\mu$. The probability of *not* colliding in region $j$ is $\\exp(-\\Sigma_{t,j} s_j)$. Therefore, the probability of colliding in region $j$ is $p_{\\text{coll}, j} = 1 - \\exp(-\\Sigma_{t,j} s_j)$.\n-   The combined probability for a specific right-going neutron born at $x_0$ with direction $\\mu$ is the product of these two independent events: $p(x_0, \\mu) = \\exp(-\\Sigma_{t,i} \\frac{L_i - x_0}{\\mu}) \\left(1 - \\exp(-\\Sigma_{t,j} \\frac{L_j}{\\mu})\\right)$.\n\n$P_{ij}$ is the expectation of this event probability over all possible births. This involves integrating over the normalized distributions of $x_0$ and $\\mu$:\n$$ P_{ij} = \\int_{0}^{L_i} \\frac{dx_0}{L_i} \\int_{-1}^{1} \\frac{d\\mu}{2} \\cdot (\\text{event probability}) $$\nSince the event probability is zero for $\\mu \\le 0$, the integral simplifies to:\n$$ P_{ij} = \\frac{1}{2L_i} \\int_{0}^{L_i} \\int_{0}^{1} \\exp\\left(-\\Sigma_{t,i} \\frac{L_i - x_0}{\\mu}\\right) \\left(1 - \\exp\\left(-\\Sigma_{t,j} \\frac{L_j}{\\mu}\\right)\\right) d\\mu \\, dx_0 $$\nA Monte Carlo method can estimate this integral. The estimator for $P_{ij}$ based on $N_{\\text{inner}}$ samples is:\n$$ \\hat{P}_{ij} = \\frac{1}{2} \\cdot \\frac{1}{N_{\\text{inner}}} \\sum_{k=1}^{N_{\\text{inner}}} \\exp\\left(-\\Sigma_{t,i} \\frac{L_i - x_{0,k}}{\\mu_k}\\right) \\left(1 - \\exp\\left(-\\Sigma_{t,j} \\frac{L_j}{\\mu_k}\\right)\\right) $$\nwhere $\\{x_{0,k}\\}_{k=1}^{N_{\\text{inner}}}$ are samples from $\\mathcal{U}(0, L_i)$ and $\\{\\mu_k\\}_{k=1}^{N_{\\text{inner}}}$ are samples from $\\mathcal{U}(0, 1)$. The factor of $1/2$ correctly accounts for the fact that only half of the isotropically emitted neutrons are directed towards region $j$.\n\n#### 2. Bayesian Uncertainty Quantification via Importance Sampling\nThe BUQ framework aims to find the posterior distribution $p(P_{ij} | y_j)$ given the prior distributions of the input parameters and the observed data $y_j$. The algorithm is:\n1.  **Draw from Priors**: Generate $N_{\\text{prior}}$ samples for the parameters $(\\Sigma_{t,i}, \\Sigma_{t,j}, L_i, L_j)$ from their specified prior distributions.\n2.  **Evaluate the Model**: For each parameter set $m$, compute the corresponding collision probability $P_{ij}^{(m)}$ using the Monte Carlo estimator $\\hat{P}_{ij}$ described above with $N_{\\text{inner}}$ samples.\n3.  **Compute Importance Weights**: The posterior is proportional to the likelihood times the prior, $p(\\theta|y) \\propto \\mathcal{L}(y|\\theta)p(\\theta)$. Since we sampled from the prior $p(\\theta)$, the importance weights are the likelihood values. Given the observation model $y_j \\sim \\mathcal{N}(S_i P_{ij}, \\sigma_{\\mathrm{obs}}^2)$, the weight for the $m$-th sample is:\n    $$ w^{(m)} \\propto \\exp\\left(-\\frac{1}{2}\\left(\\frac{y_j - S_i P_{ij}^{(m)}}{\\sigma_{\\mathrm{obs}}}\\right)^2\\right) $$\n4.  **Normalize Weights**: To form a valid probability distribution, the weights are normalized:\n    $$ W^{(m)} = \\frac{w^{(m)}}{\\sum_{k=1}^{N_{\\text{prior}}} w^{(k)}} $$\n5.  **Compute Posterior Moments**: The posterior mean and variance of $P_{ij}$ are approximated by the weighted sums over the prior samples:\n    -   Posterior Mean: $E[P_{ij} | y_j] \\approx \\sum_{m=1}^{N_{\\text{prior}}} W^{(m)} P_{ij}^{(m)}$\n    -   Posterior Variance: $\\mathrm{Var}[P_{ij} | y_j] \\approx \\left(\\sum_{m=1}^{N_{\\text{prior}}} W^{(m)} (P_{ij}^{(m)})^2\\right) - \\left(E[P_{ij} | y_j]\\right)^2$\n\nThis procedure is implemented in the provided Python code for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import truncnorm\n\ndef estimate_pij(params, n_inner, rng):\n    \"\"\"\n    Estimates the collision probability P_ij using a Monte Carlo estimator.\n    \n    Args:\n        params (tuple): A tuple containing (sigma_ti, sigma_tj, li, lj).\n        n_inner (int): The number of inner loop Monte Carlo samples.\n        rng (np.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The estimated collision probability P_ij.\n    \"\"\"\n    sigma_ti, sigma_tj, li, lj = params\n\n    if li <= 0 or lj <= 0:\n        return 0.0\n\n    # Sample birth positions x_0 uniformly in [0, L_i]\n    x0_samples = rng.uniform(0, li, n_inner)\n    \n    # Sample direction cosines mu uniformly in (0, 1)\n    mu_samples = rng.uniform(0, 1, n_inner)\n\n    # Path length in region i\n    s_i = (li - x0_samples) / mu_samples\n    # Path length in region j\n    s_j = lj / mu_samples\n\n    # Probability of the event for each sample:\n    # survives region i AND collides in region j\n    event_prob = np.exp(-sigma_ti * s_i) * (1 - np.exp(-sigma_tj * s_j))\n\n    # The MC estimate of the integral over x0 and mu\n    integral_estimate = np.mean(event_prob)\n    \n    # P_ij includes a factor of 1/2 for the isotropic source (only neutrons with mu > 0 can reach region j)\n    p_ij = 0.5 * integral_estimate\n    \n    return p_ij\n\ndef process_case(case, rng):\n    \"\"\"\n    Performs Bayesian Uncertainty Quantification for a single test case.\n\n    Args:\n        case (dict): A dictionary containing all parameters for the case.\n        rng (np.random.Generator): The random number generator instance.\n\n    Returns:\n        tuple: A tuple containing (posterior_mean, posterior_variance).\n    \"\"\"\n    # Unpack case parameters\n    m_sigma_i, cv_sigma_i = case[\"m_sigma_i\"], case[\"cv_sigma_i\"]\n    m_sigma_j, cv_sigma_j = case[\"m_sigma_j\"], case[\"cv_sigma_j\"]\n    m_li, s_li = case[\"m_li\"], case[\"s_li\"]\n    m_lj, s_lj = case[\"m_lj\"], case[\"s_lj\"]\n    s_i = case[\"s_i\"]\n    y_j = case[\"y_j\"]\n    sigma_obs = case[\"sigma_obs\"]\n    n_prior = case[\"n_prior\"]\n    n_inner = case[\"n_inner\"]\n\n    # 1. Generate samples from prior distributions\n    \n    # Lognormal for Sigma_t\n    def get_lognormal_params(m, cv):\n        if m <= 0 or cv <= 0:\n            raise ValueError(\"Mean and CV for lognormal must be positive.\")\n        sigma_ln_sq = np.log(cv**2 + 1)\n        mu_ln = np.log(m) - 0.5 * sigma_ln_sq\n        return mu_ln, np.sqrt(sigma_ln_sq)\n\n    mu_ln_i, sigma_ln_i = get_lognormal_params(m_sigma_i, cv_sigma_i)\n    sigma_ti_samples = rng.lognormal(mu_ln_i, sigma_ln_i, n_prior)\n    \n    mu_ln_j, sigma_ln_j = get_lognormal_params(m_sigma_j, cv_sigma_j)\n    sigma_tj_samples = rng.lognormal(mu_ln_j, sigma_ln_j, n_prior)\n\n    # Truncated Normal for L\n    def get_truncnorm_samples(m, s, size):\n        a = (0 - m) / s\n        b = np.inf\n        return truncnorm.rvs(a, b, loc=m, scale=s, size=size, random_state=rng)\n\n    li_samples = get_truncnorm_samples(m_li, s_li, n_prior)\n    lj_samples = get_truncnorm_samples(m_lj, s_lj, n_prior)\n\n    # 2. Evaluate the model (P_ij) for each prior sample\n    p_ij_samples = np.zeros(n_prior)\n    prior_params = zip(sigma_ti_samples, sigma_tj_samples, li_samples, lj_samples)\n    for i, params in enumerate(prior_params):\n        p_ij_samples[i] = estimate_pij(params, n_inner, rng)\n\n    # 3. Compute importance weights\n    predicted_counts = s_i * p_ij_samples\n    log_weights = -0.5 * ((y_j - predicted_counts) / sigma_obs)**2\n    \n    # 4. Normalize weights using log-sum-exp trick for numerical stability\n    log_weights_max = np.max(log_weights)\n    weights_unnorm = np.exp(log_weights - log_weights_max)\n    weights_norm = weights_unnorm / np.sum(weights_unnorm)\n\n    # 5. Compute posterior mean and variance\n    post_mean = np.sum(weights_norm * p_ij_samples)\n    post_mean_sq = np.sum(weights_norm * p_ij_samples**2)\n    post_var = post_mean_sq - post_mean**2\n\n    return post_mean, post_var\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Fixed random seed for reproducibility\n    seed = 42\n    rng = np.random.default_rng(seed)\n    \n    test_cases = [\n        {\n            \"m_sigma_i\": 0.8, \"cv_sigma_i\": 0.20,\n            \"m_sigma_j\": 0.5, \"cv_sigma_j\": 0.25,\n            \"m_li\": 2.0, \"s_li\": 0.2,\n            \"m_lj\": 4.0, \"s_lj\": 0.3,\n            \"s_i\": 1.0e6, \"y_j\": 2.10e5, \"sigma_obs\": 2.00e4,\n            \"n_prior\": 400, \"n_inner\": 600,\n        },\n        {\n            \"m_sigma_i\": 0.9, \"cv_sigma_i\": 0.15,\n            \"m_sigma_j\": 0.6, \"cv_sigma_j\": 0.20,\n            \"m_li\": 3.0, \"s_li\": 0.3,\n            \"m_lj\": 0.5, \"s_lj\": 0.05,\n            \"s_i\": 1.5e6, \"y_j\": 3.80e4, \"sigma_obs\": 1.00e4,\n            \"n_prior\": 500, \"n_inner\": 500,\n        },\n        {\n            \"m_sigma_i\": 3.0, \"cv_sigma_i\": 0.30,\n            \"m_sigma_j\": 0.4, \"cv_sigma_j\": 0.30,\n            \"m_li\": 2.0, \"s_li\": 0.2,\n            \"m_lj\": 3.0, \"s_lj\": 0.3,\n            \"s_i\": 1.0e6, \"y_j\": 7.00e3, \"sigma_obs\": 5.00e3,\n            \"n_prior\": 450, \"n_inner\": 600,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        mean, var = process_case(case, rng)\n        results.extend([mean, var])\n    \n    # Format the output as specified\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}