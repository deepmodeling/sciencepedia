{
    "hands_on_practices": [
        {
            "introduction": "这项实践是理解碰撞概率的基石。我们将通过从第一性原理出发，推导简单板栅几何中自碰撞和透射概率的解析表达式，从而搭建起抽象理论与具体数值模拟之间的桥梁。然后，你将实现一个蒙特卡洛模拟来验证这些理论公式，从而对这些概率的物理意义建立起坚实而直观的理解()。",
            "id": "4217775",
            "problem": "基于中性粒子输运的第一性原理，为一维真空边界平板几何中的碰撞概率法（CPM）设计一个验证性实验。考虑一个厚度为 $L$ 的均匀平板，其宏观总截面 $\\Sigma_t$ 在空间上是常数。中子在空间上均匀、方向上各向同性地产生。我们关心的CPM量是区域自碰撞概率 $P_{jj}$（中子在逃逸出平板前，其首次相互作用发生在平板内的概率）和总透射概率 $T$（中子未发生任何相互作用就从任一边界逃逸的概率）。目标是利用广义指数积分推导出 $P_{jj}$ 和 $T$ 的闭式表达式，然后通过数值实验来验证这些表达式。\n\n从一维、稳态、单能形式的中性粒子线性玻尔兹曼方程出发，并利用首次飞行（未碰撞）存活概率。对于在位置 $x \\in [0,L]$、方向余弦为 $\\mu \\in [-1,1]$ 的一个出射中子，其沿飞行方向到最近真空边界的距离为 $d(x,\\mu)$，首次飞行至该边界的存活概率为 $\\exp(-\\Sigma_t d(x,\\mu))$。对于均匀空间源和各向同性角分布，通过对存活概率在 $x$ 和 $\\mu$ 上积分，可以得到通过任一边界的平均逃逸概率，而平板内的平均碰撞概率则由其补集得出。\n\n任务：\n1. 根据存活概率以及对 $x$ 和 $\\mu$ 的均匀-各向同性抽样，推导一个用广义指数积分函数表示的总透射概率 $T$ 的闭式表达式。用无量纲光学厚度 $a = \\Sigma_t L$ 来表示结果。你的推导必须展示从积分定义到闭式解的所有步骤，并且只能使用以下基本要素：\n    - 首次飞行存活概率的定义 $\\exp(-\\Sigma_t d(x,\\mu))$。\n    - 在 $x \\in [0,L]$ 上进行均匀空间抽样，在 $\\mu \\in [-1,1]$ 上进行各向同性角向抽样。\n    - 由 $E_n(x) = \\int_{1}^{\\infty} \\frac{e^{-x t}}{t^n} \\, dt$ 定义的广义指数积分 $E_n(x)$。\n2. 从你得到的 $T$ 的表达式出发，仅根据此真空边界单区域平板中的概率守恒，求出区域自碰撞概率 $P_{jj}$。\n3. 提出并实现一个使用随机抽样（蒙特卡罗）的数值实验，通过模拟大量独立的中子历史，直接根据定义估算 $T$ 和 $P_{jj}$：\n    - 在 $[0,L]$ 上均匀抽样 $x$，在 $[-1,1]$ 上均匀抽样 $\\mu$。\n    - 计算沿抽样方向到真空边界的距离 $d(x,\\mu)$。\n    - 从均值为 $1/\\Sigma_t$ 的指数分布中抽样一个自由飞行程长 $s$，并通过比较 $s$ 和 $d(x,\\mu)$ 来决定是逃逸还是碰撞。\n    - 将逃逸的历史所占的比例作为 $T$ 的估计值，将碰撞的历史所占的比例作为 $P_{jj}$ 的估计值。\n4. 必须使用以下物理单位：平板厚度 $L$ 以厘米表示，宏观总截面 $\\Sigma_t$ 以厘米的倒数表示。概率 $T$ 和 $P_{jj}$ 是在 $[0,1]$ 区间内的无量纲数。\n5. 使用以下参数集测试套件 $(L,\\Sigma_t)$，其中 $L$ 的单位是厘米，$\\Sigma_t$ 的单位是厘米的倒数：\n    - 测试1（薄板）: $(10.0, 0.01)$。\n    - 测试2（中等厚度板）: $(10.0, 0.1)$。\n    - 测试3（厚板）: $(10.0, 1.0)$。\n    - 测试4（非常厚的板）: $(100.0, 0.5)$。\n6. 在你的程序中，对每个测试用例，根据你推导的闭式解计算解析的 $T$ 和 $P_{jj}$，并将它们与蒙特卡罗的估计值进行比较。对 $T$ 和 $P_{jj}$ 的绝对差使用统一的精度容差 $\\varepsilon = 10^{-3}$。\n7. 你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目必须是一个布尔值，表示相应的测试用例（按测试套件的顺序）中，$T$ 和 $P_{jj}$ 是否都通过了精度检查。例如，一个有效的输出行形式为 $[true\\_or\\_false\\_1,true\\_or\\_false\\_2,true\\_or\\_false\\_3,true\\_or\\_false\\_4]$，其中每个 $true\\_or\\_false\\_k$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。",
            "solution": "问题陈述在中性粒子输运理论领域提出了一个定义明确且有科学依据的任务。它要求推导一维平板几何中碰撞概率法（CPM）的基本量，并随后使用蒙特卡罗模拟进行数值验证。该问题是自洽的、逻辑一致的，并且没有任何科学或数学上的缺陷。因此，有必要提供一个解答。\n\n问题的核心是确定在一个厚度为 $L$、宏观总截面为 $\\Sigma_t$ 的均匀平板内，由均匀各向同性源产生的中子的归宿。一个中子要么在平板内部发生首次相互作用，要么从某个真空边界逃逸。我们需要求解这两个互斥事件的概率：自碰撞概率 $P_{jj}$ 和总透射（逃逸）概率 $T$。\n\n**1. 总透射概率 $T$ 的推导**\n\n总透射概率 $T$ 是一个根据指定源分布产生的中子在不发生任何相互作用的情况下逃逸出平板的平均概率。一个从中子位置 $x$ 出发，沿着由方向余弦 $\\mu$ 指定的方向运动的中子，其逃逸概率由首次飞行存活概率 $e^{-\\Sigma_t d(x,\\mu)}$ 给出，其中 $d(x,\\mu)$ 是从 $x$ 沿方向 $\\mu$ 到最近边界的程长。\n\n源在空间区间 $x \\in [0, L]$ 上是均匀的，在方向上是各向同性的。对于一维平板几何，各向同性源由方向余弦 $\\mu$ 在区间 $[-1, 1]$ 上的均匀概率分布表示。因此，对归一化源分布的平均为：\n$$ T = \\int_{0}^{L} \\frac{1}{L} \\, dx \\int_{-1}^{1} \\frac{1}{2} \\, d\\mu \\, e^{-\\Sigma_t d(x, \\mu)} = \\frac{1}{2L} \\int_{0}^{L} dx \\int_{-1}^{1} d\\mu \\, e^{-\\Sigma_t d(x, \\mu)} $$\n\n到边界的距离 $d(x, \\mu)$ 取决于 $\\mu$ 的符号：\n- 对于 $\\mu > 0$（向右行进），边界在 $x=L$。距离为 $d(x, \\mu) = (L-x)/\\mu$。\n- 对于 $\\mu  0$（向左行进），边界在 $x=0$。距离为 $d(x, \\mu) = (0-x)/\\mu = -x/\\mu = x/|\\mu|$。\n\n我们可以将关于 $\\mu$ 的积分拆分为两部分：\n$$ T = \\frac{1}{2L} \\left[ \\int_{0}^{L} dx \\int_{0}^{1} d\\mu \\, e^{-\\Sigma_t (L-x)/\\mu} + \\int_{0}^{L} dx \\int_{-1}^{0} d\\mu \\, e^{+\\Sigma_t x/\\mu} \\right] $$\n\n让我们计算第一项，它代表从右边界逃逸的概率 $T_{\\text{right}}$：\n$$ T_{\\text{right}} = \\frac{1}{2L} \\int_{0}^{1} d\\mu \\int_{0}^{L} dx \\, e^{-\\Sigma_t (L-x)/\\mu} $$\n首先，我们对位置 $x$ 进行积分。令 $y = L-x$，则 $dy = -dx$。\n$$ \\int_{0}^{L} e^{-\\Sigma_t (L-x)/\\mu} \\, dx = \\int_{L}^{0} e^{-\\Sigma_t y/\\mu} \\, (-dy) = \\int_{0}^{L} e^{-\\Sigma_t y/\\mu} \\, dy $$\n$$ \\int_{0}^{L} e^{-\\Sigma_t y/\\mu} \\, dy = \\left[ -\\frac{\\mu}{\\Sigma_t} e^{-\\Sigma_t y/\\mu} \\right]_{0}^{L} = \\frac{\\mu}{\\Sigma_t} \\left(1 - e^{-\\Sigma_t L/\\mu}\\right) $$\n将此结果代回 $T_{\\text{right}}$ 的表达式中：\n$$ T_{\\text{right}} = \\frac{1}{2L} \\int_{0}^{1} \\frac{\\mu}{\\Sigma_t} \\left(1 - e^{-\\Sigma_t L/\\mu}\\right) d\\mu = \\frac{1}{2L\\Sigma_t} \\int_{0}^{1} \\left(\\mu - \\mu e^{-\\Sigma_t L/\\mu}\\right) d\\mu $$\n令 $a = \\Sigma_t L$ 为平板的无量纲光学厚度。表达式变为：\n$$ T_{\\text{right}} = \\frac{1}{2a} \\left[ \\int_{0}^{1} \\mu \\, d\\mu - \\int_{0}^{1} \\mu e^{-a/\\mu} \\, d\\mu \\right] $$\n第一个积分是初等的：$\\int_{0}^{1} \\mu \\, d\\mu = [\\mu^2/2]_0^1 = 1/2$。\n对于第二个积分，我们进行变量替换。令 $t = 1/\\mu$，则 $\\mu = 1/t$ 且 $d\\mu = -1/t^2 \\, dt$。积分限从 $\\mu \\in (0,1]$ 变为 $t \\in (\\infty, 1]$。\n$$ \\int_{0}^{1} \\mu e^{-a/\\mu} \\, d\\mu = \\int_{\\infty}^{1} \\frac{1}{t} e^{-at} \\left(-\\frac{1}{t^2}\\right) dt = \\int_{1}^{\\infty} \\frac{e^{-at}}{t^3} \\, dt $$\n根据定义，这个积分是3阶广义指数积分，$E_3(a)$，其中 $E_n(x) = \\int_{1}^{\\infty} \\frac{e^{-xt}}{t^n} \\, dt$。\n因此，$\\int_{0}^{1} \\mu e^{-a/\\mu} \\, d\\mu = E_3(a)$。将这些结果代回，我们得到通过右边界的逃逸概率：\n$$ T_{\\text{right}} = \\frac{1}{2a} \\left(\\frac{1}{2} - E_3(a)\\right) $$\n由于均匀源和平板几何的对称性，通过左边界的逃逸概率 $T_{\\text{left}}$ 与 $T_{\\text{right}}$ 相同。总透射概率为 $T = T_{\\text{left}} + T_{\\text{right}} = 2T_{\\text{right}}$。\n$$ T(a) = 2 \\cdot \\frac{1}{2a} \\left(\\frac{1}{2} - E_3(a)\\right) = \\frac{1}{a} \\left(\\frac{1}{2} - E_3(a)\\right) = \\frac{1 - 2E_3(a)}{2a} $$\n这就是所要求的总透射概率的闭式表达式。\n\n**2. 自碰撞概率 $P_{jj}$ 的推导**\n\n对于在单一均匀区域（用下标 $j$ 表示）内产生的中子，在这个具有真空边界的系统中只有两种可能的结果：它要么在区域内碰撞，要么逃逸。这是粒子数（或概率）守恒的体现。\n$$ P_{jj} + T = 1 $$\n因此，自碰撞概率 $P_{jj}$ 就是总透射概率的补集：\n$$ P_{jj}(a) = 1 - T(a) = 1 - \\frac{1 - 2E_3(a)}{2a} $$\n\n**3. 数值验证实验的设计**\n\n为了验证推导出的解析表达式，我们使用蒙特卡罗方法构建了该物理过程的直接模拟。对于大量的独立试验（中子历史），我们根据问题中概述的基本原理追踪每个中子的归宿。\n\n对于 $N$ 个中子历史中的每一个：\n1.  **抽样初始状态**：中子在位置 $x$ 和方向余弦 $\\mu$ 处产生。\n    - 位置 $x$ 从 $[0, L]$ 上的均匀分布中抽样：$x = L \\cdot \\xi_1$，其中 $\\xi_1 \\sim U(0,1)$。\n    - 方向 $\\mu$ 从 $[-1, 1]$ 上的均匀分布中抽样：$\\mu = 2 \\cdot \\xi_2 - 1$，其中 $\\xi_2 \\sim U(0,1)$。\n\n2.  **确定到边界的距离**：中子必须行进以逃逸的距离 $d$ 是根据其起始位置和方向计算的：\n    $$ d(x, \\mu) = \\begin{cases} (L-x)/\\mu   \\text{if } \\mu > 0 \\\\ -x/\\mu   \\text{if } \\mu  0 \\\\ \\infty   \\text{if } \\mu = 0 \\end{cases} $$\n\n3.  **抽样程长**：中子在首次相互作用（碰撞）前行进的距离 $s$ 是一个随机变量，服从指数概率分布 $p(s) = \\Sigma_t e^{-\\Sigma_t s}$。这可以使用逆变换法进行抽样：\n    - $s = -\\frac{\\ln(\\xi_3)}{\\Sigma_t}$，其中 $\\xi_3 \\sim U(0,1)$。\n\n4.  **确定归宿**：通过比较抽样程长 $s$ 和到边界的距离 $d$ 来决定中子的归宿：\n    - 如果 $s  d$，中子在逃逸前发生碰撞。我们将其计为一次碰撞事件。\n    - 如果 $s \\ge d$，中子未经相互作用而逃逸。我们将其计为一次透射（逃逸）事件。\n\n5.  **估计概率**：模拟 $N$ 个历史后，我们统计总的逃逸数 $N_{\\text{esc}}$ 和碰撞数 $N_{\\text{coll}}$。概率被估计为这些结果的比例：\n    - $T_{\\text{MC}} \\approx N_{\\text{esc}} / N$\n    - $P_{jj, \\text{MC}} \\approx N_{\\text{coll}} / N$\n根据构造，$N_{\\text{esc}} + N_{\\text{coll}} = N$，因此估计值也满足 $T_{\\text{MC}} + P_{jj, \\text{MC}} = 1$。$L$ (cm) 和 $\\Sigma_t$ (cm$^{-1}$) 的物理单位是一致的，得到一个无量纲的光学厚度 $a=\\Sigma_t L$。\n\n将解析结果（$T(a), P_{jj}(a)$）与蒙特卡罗估计值（$T_{\\text{MC}}, P_{jj, \\text{MC}}$）进行比较，为推导出的公式提供了强有力的验证。随着历史数 $N$ 的增加，一致性预计会提高，蒙特卡罗估计的统计不确定度与 $1/\\sqrt{N}$ 成比例。提供的实现将使用足够大的 $N$ 来满足指定的精度容差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import expn\n\ndef solve():\n    \"\"\"\n    Performs the validation experiment for the Collision Probability Method\n    in 1D slab geometry.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (L [cm], Sigma_t [1/cm]).\n    test_cases = [\n        (10.0, 0.01),   # Test 1 (thin slab)\n        (10.0, 0.1),    # Test 2 (moderate slab)\n        (10.0, 1.0),    # Test 3 (thick slab)\n        (100.0, 0.5),   # Test 4 (very thick slab)\n    ]\n\n    # Number of neutron histories for the Monte Carlo simulation.\n    # Chosen to be large enough to meet the specified tolerance with high confidence.\n    N_HISTORIES = 5_000_000\n\n    # Accuracy tolerance for validation.\n    TOLERANCE = 1e-3\n\n    # List to store the boolean validation results.\n    results = []\n\n    # Use a fixed seed for reproducibility.\n    rng = np.random.default_rng(seed=42)\n\n    for L, Sigma_t in test_cases:\n        # --- Analytical Calculation ---\n\n        # Calculate the dimensionless optical thickness 'a'.\n        a = Sigma_t * L\n\n        # Handle the case a -> 0 separately to avoid division by zero,\n        # although the test cases do not include a=0.\n        # In the limit a -> 0, T -> 1.\n        if np.isclose(a, 0.0):\n            T_analytical = 1.0\n        else:\n            # Use scipy.special.expn(n, x) for the generalized exponential integral E_n(x).\n            E3_a = expn(3, a)\n            # Derived formula for total transmission probability T.\n            T_analytical = (1.0 - 2.0 * E3_a) / (2.0 * a)\n\n        # Derived formula for self-collision probability P_jj.\n        P_jj_analytical = 1.0 - T_analytical\n\n        # --- Monte Carlo Simulation ---\n\n        # 1. Sample initial positions and directions.\n        # x is uniform in [0, L]\n        x_samples = L * rng.random(N_HISTORIES)\n        # mu is uniform in [-1, 1]\n        mu_samples = 2.0 * rng.random(N_HISTORIES) - 1.0\n\n        # 2. Compute distance to boundary for each neutron.\n        # Initialize distance array with infinity.\n        d_to_boundary = np.full(N_HISTORIES, np.inf)\n\n        # Create masks for positive and negative directions.\n        # This approach robustly handles mu=0, where d remains infinity.\n        mask_pos = mu_samples > 0\n        mask_neg = mu_samples  0\n\n        # Calculate distance for rightward-moving neutrons.\n        d_to_boundary[mask_pos] = (L - x_samples[mask_pos]) / mu_samples[mask_pos]\n        # Calculate distance for leftward-moving neutrons.\n        d_to_boundary[mask_neg] = -x_samples[mask_neg] / mu_samples[mask_neg]\n\n        # 3. Sample free-flight path lengths from the exponential distribution.\n        # s = -ln(xi) / Sigma_t, where xi is a uniform random number in (0, 1].\n        # We sample from [0,1) but numerically the probability of 0 is negligible.\n        if np.isclose(Sigma_t, 0.0):\n            # For a \"vacuum\" slab, path length is infinite.\n            s_path_lengths = np.full(N_HISTORIES, np.inf)\n        else:\n            s_path_lengths = -np.log(rng.random(N_HISTORIES)) / Sigma_t\n\n        # 4. Determine fate: collision vs. escape.\n        # A neutron escapes if its path length is >= the distance to the boundary.\n        escapes = np.sum(s_path_lengths >= d_to_boundary)\n\n        # 5. Estimate probabilities.\n        T_mc = escapes / N_HISTORIES\n        P_jj_mc = 1.0 - T_mc\n\n        # --- Validation ---\n\n        # Check if the absolute differences are within the tolerance.\n        pass_T = np.abs(T_analytical - T_mc)  TOLERANCE\n        pass_Pjj = np.abs(P_jj_analytical - P_jj_mc)  TOLERANCE\n\n        # The problem requires a check for both, although they are dependent.\n        validation_passed = pass_T and pass_Pjj\n        results.append(validation_passed)\n\n    # Final print statement in the exact required format.\n    # map(str,...) converts Python's True/False to strings \"True\"/\"False\".\n    # In Python, str(True) is \"True\", which is not what the problem asks for.\n    # It asks for \"true_or_false\". However, the example output is `[True,False...]`.\n    # I will stick to the Python standard `True`/`False` which is more standard for data exchange.\n    # Let me re-read the example output format: `[true_or_false_1,true_or_false_2,...]`\n    # and `each true_or_false_k is True or False`. This is ambiguous.\n    # The example `[true_or_false_1,...]` hints at lower-case strings. But the later part hints at Python bools.\n    # The previous `solve()` had `print(f\"[{','.join(map(str, results))}]\")` which produces `[True,True,True,True]`.\n    # Let's keep it consistent.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一项实践将我们的分析提升到考虑实验和制造不确定性的现实情况。你将构建一个贝叶斯不确定性量化框架，以确定材料截面和几何尺寸的不确定性如何传播到碰撞概率 $P_{ij}$。通过将 $P_{ij}$ 的蒙特卡洛估计与重要性采样相结合，这项练习让你得以一窥输运理论在模型验证和数据同化等现代研究级应用中的风采()。",
            "id": "4217767",
            "problem": "考虑一种用于核反应堆模拟中碰撞概率方法的双区一维平板几何。区域 $i$（燃料）占据区间 $x \\in [0,L_i]$，区域 $j$（慢化剂）占据区间 $x \\in [L_i, L_i + L_j]$。在 $x = 0$ 和 $x = L_i + L_j$ 处存在真空边界条件。一个强度为 $S_i$（中子数/秒）的均匀、各向同性的中子体源在区域 $i$ 中作用。区域 $k \\in \\{i,j\\}$ 中的总宏观截面 $\\Sigma_{t,k}$ 在每个区域内是空间均匀的。\n\n碰撞概率 $P_{ij}$ 定义为在区域 $i$ 中出生的中子在区域 $j$ 中发生首次碰撞的概率。请从以下基本原理出发：\n- 中子指数衰减：在总宏观截面为 $\\Sigma_t$ 的均匀区域中，沿长度为 $s$ 的直线路径的存活概率为 $\\exp(-\\Sigma_t s)$。\n- 各向同性发射：对于平面几何，飞行方向与 $x$ 轴之间的方向余弦 $\\mu$ 在 $[-1,1]$ 上均匀分布。\n- 首次碰撞是沿直线轨迹遇到的第一个相互作用事件；在首次碰撞之前没有散射或几何变化。\n\n仅使用这些基本原理，将指定平板几何的 $P_{ij}$ 表述为一个事件的平均值（对出生位置和方向进行平均），该事件为：在到达 $x=L_i$ 处的界面前在区域 $i$ 中没有发生碰撞，随后在离开到 $x=L_i+L_j$ 处的真空之前在区域 $j$ 中发生碰撞。除了从基本原理推导出的内容外，您不得引入任何捷径公式。\n\n材料和几何属性都存在不确定性。使用贝叶斯不确定性量化（BUQ）框架：\n- 先验：\n  - $\\Sigma_{t,i}$ 和 $\\Sigma_{t,j}$ 具有独立的对数正态先验，具有指定的均值 $m_{\\Sigma_{t,i}}$ 和 $m_{\\Sigma_{t,j}}$（单位 $\\mathrm{cm}^{-1}$），以及指定的变异系数 $\\mathrm{cv}_{\\Sigma_{t,i}}$ 和 $\\mathrm{cv}_{\\Sigma_{t,j}}$（无量纲）。\n  - $L_i$ 和 $L_j$ 具有独立的截断正态先验，具有指定的均值 $m_{L_i}$ 和 $m_{L_j}$（单位 $\\mathrm{cm}$），标准差 $s_{L_i}$ 和 $s_{L_j}$（单位 $\\mathrm{cm}$），并在 $0$（单位 $\\mathrm{cm}$）处向下截断。\n- 观测模型：\n  - 一个探测器提供一个测量的计数率 $y_j$（无量纲计数/秒），模型为 $y_j \\sim \\mathcal{N}(S_i P_{ij}, \\sigma_{\\mathrm{obs}}^2)$，其中 $\\sigma_{\\mathrm{obs}}$（单位 计数/秒）是已知的。\n\n实现一个蒙特卡罗（MC）估计器，通过在 $x \\in [0,L_i]$ 中均匀抽样出生位置和在 $\\mu \\in (0,1]$ 中均匀抽样方向余弦 $\\mu$（以表示朝向区域 $j$ 的向右行进的中子），并对基本原理所蕴含的事件概率进行平均，来为给定的参数集 $(\\Sigma_{t,i}, \\Sigma_{t,j}, L_i, L_j)$ 计算 $P_{ij}$。然后执行重要性抽样，使用先验样本和与 $\\exp\\left(-\\frac{1}{2}\\left(\\frac{y_j - S_i P_{ij}}{\\sigma_{\\mathrm{obs}}}\\right)^2\\right)$ 成比例的高斯似然权重，来近似给定观测 $y_j$ 的 $P_{ij}$ 的后验分布。\n\n对于每个测试案例，计算 $P_{ij}$ 的后验均值和后验方差。将 $P_{ij}$ 表示为无量纲概率（无单位）。通过在 $[-1,1]$ 上的方向余弦分布隐式地使用弧度制角度。确保所有长度单位为 $\\mathrm{cm}$，所有宏观截面单位为 $\\mathrm{cm}^{-1}$。使用固定的随机种子以保证可复现性。\n\n测试套件参数集：\n- 案例 1（正常路径，中等不确定性）：\n  - $m_{\\Sigma_{t,i}} = 0.8\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,i}} = 0.20$\n  - $m_{\\Sigma_{t,j}} = 0.5\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,j}} = 0.25$\n  - $m_{L_i} = 2.0\\,\\mathrm{cm}$, $s_{L_i} = 0.2\\,\\mathrm{cm}$\n  - $m_{L_j} = 4.0\\,\\mathrm{cm}$, $s_{L_j} = 0.3\\,\\mathrm{cm}$\n  - $S_i = 1.0\\times 10^{6}$ (中子/秒), $y_j = 2.10\\times 10^{5}$ (计数/秒), $\\sigma_{\\mathrm{obs}} = 2.00\\times 10^{4}$ (计数/秒)\n  - 先验样本数 $N_{\\mathrm{prior}} = 400$, 每个先验抽样的内部MC样本数 $N_{\\mathrm{inner}} = 600$\n- 案例 2（边界几何：薄慢化剂区）：\n  - $m_{\\Sigma_{t,i}} = 0.9\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,i}} = 0.15$\n  - $m_{\\Sigma_{t,j}} = 0.6\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,j}} = 0.20$\n  - $m_{L_i} = 3.0\\,\\mathrm{cm}$, $s_{L_i} = 0.3\\,\\mathrm{cm}$\n  - $m_{L_j} = 0.5\\,\\mathrm{cm}$, $s_{L_j} = 0.05\\,\\mathrm{cm}$\n  - $S_i = 1.5\\times 10^{6}$ (中子/秒), $y_j = 3.80\\times 10^{4}$ (计数/秒), $\\sigma_{\\mathrm{obs}} = 1.00\\times 10^{4}$ (计数/秒)\n  - 先验样本数 $N_{\\mathrm{prior}} = 500$, 每个先验抽样的内部MC样本数 $N_{\\mathrm{inner}} = 500$\n- 案例 3（材料边缘：区域 $i$ 中强吸收）：\n  - $m_{\\Sigma_{t,i}} = 3.0\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,i}} = 0.30$\n  - $m_{\\Sigma_{t,j}} = 0.4\\,\\mathrm{cm}^{-1}$, $\\mathrm{cv}_{\\Sigma_{t,j}} = 0.30$\n  - $m_{L_i} = 2.0\\,\\mathrm{cm}$, $s_{L_i} = 0.2\\,\\mathrm{cm}$\n  - $m_{L_j} = 3.0\\,\\mathrm{cm}$, $s_{L_j} = 0.3\\,\\mathrm{cm}$\n  - $S_i = 1.0\\times 10^{6}$ (中子/秒), $y_j = 7.00\\times 10^{3}$ (计数/秒), $\\sigma_{\\mathrm{obs}} = 5.00\\times 10^{3}$ (计数/秒)\n  - 先验样本数 $N_{\\mathrm{prior}} = 450$, 每个先验抽样的内部MC样本数 $N_{\\mathrm{inner}} = 600$\n\n您的程序必须：\n- 按所述通过重要性抽样实现BUQ。\n- 对每个案例，以浮点数形式返回 $P_{ij}$ 的后验均值和后验方差。\n- 使用单一固定的随机种子。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[\\text{mean}_1,\\text{var}_1,\\text{mean}_2,\\text{var}_2,\\text{mean}_3,\\text{var}_3]$。\n- 将输出中的每个浮点数四舍五入到 $6$ 位小数。",
            "solution": "用户提供的问题是计算核工程领域一个良构的任务，它结合了中子输运物理与贝叶斯不确定性量化。我将首先验证问题陈述，并在确认其有效性后，提供详细的解决方案。\n\n### 步骤 1：提取给定信息\n-   **几何与区域**：一维平板，区域 $i$（燃料）位于 $x \\in [0,L_i]$，区域 $j$（慢化剂）位于 $x \\in [L_i, L_i + L_j]$。\n-   **边界**：在 $x=0$ 和 $x = L_i + L_j$ 处为真空条件。\n-   **源**：在区域 $i$ 内有一个强度为 $S_i$ 的均匀、各向同性中子体源。\n-   **性质**：各自区域内的总宏观截面 $\\Sigma_{t,i}$ 和 $\\Sigma_{t,j}$ 在空间上是均匀的。\n-   **核心定义**：$P_{ij}$ 是一个在区域 $i$ 中出生的中子在区域 $j$ 中发生首次碰撞的概率。\n-   **基本原理**：\n    1.  在路径长度为 $s$ 上的存活概率为 $\\exp(-\\Sigma_t s)$。\n    2.  对于平板中的各向同性发射，方向余弦 $\\mu$ 在 $[-1,1]$ 上均匀分布。\n    3.  分析只考虑首次碰撞事件。\n-   **计算方法**：\n    -   $P_{ij}$ 将通过蒙特卡罗（MC）估计器计算，方法是对出生位置 $x_0 \\in [0,L_i]$（均匀）和向右的方向余弦 $\\mu \\in (0,1]$（均匀）进行平均。\n    -   将使用重要性抽样进行贝叶斯不确定性量化（BUQ）。\n-   **先验**：\n    -   $\\Sigma_{t,i}, \\Sigma_{t,j}$：独立的对数正态先验，具有指定的均值（$m_{\\Sigma_{t,k}}$）和变异系数（$\\mathrm{cv}_{\\Sigma_{t,k}}$）。\n    -   $L_i, L_j$：在 $0$ 处截断的独立正态先验，具有指定的均值（$m_{L_k}$）和标准差（$s_{L_k}$）。\n-   **观测模型（似然）**：一个测量的计数率 $y_j$ 由一个正态分布 $y_j \\sim \\mathcal{N}(S_i P_{ij}, \\sigma_{\\mathrm{obs}}^2)$ 建模，其中 $\\sigma_{\\mathrm{obs}}$ 已知。\n-   **重要性抽样权重**：与 $\\exp\\left(-\\frac{1}{2}\\left(\\frac{y_j - S_i P_{ij}}{\\sigma_{\\mathrm{obs}}}\\right)^2\\right)$ 成正比。\n-   **输出**：对于每个测试案例，计算 $P_{ij}$ 的后验均值和后验方差。\n-   **数值参数**：为三个测试案例提供了先验、观测模型和样本大小（$N_{\\mathrm{prior}}$, $N_{\\mathrm{inner}}$）的具体值。\n-   **可复现性**：必须使用固定的随机种子。\n-   **输出格式**：单行 `[mean_1,var_1,mean_2,var_2,mean_3,var_3]`，数值四舍五入到 $6$ 位小数。\n\n### 步骤 2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估：\n\n1.  **科学或事实上的不健全性**：问题基于中子输运理论（积分输运方程）的基本、公认原理和标准统计方法（通过重要性抽样进行贝叶斯推断）。所有物理和数学概念都是健全的。\n2.  **不可形式化或不相关**：问题定义严谨，直接关系到所要求的*核反应堆模拟*中的*碰撞概率方法*。它完全可以形式化为一个计算算法。\n3.  **不完整或矛盾的设置**：为每个测试案例指定了所有必要的数据、分布和参数。问题是自洽且内部一致的。对 $\\mu \\in (0,1]$ 进行抽样的指令是平板几何的标准方法，当与一个因子 $1/2$ 结合以考虑各向同性源时，可以正确地模拟物理过程。\n4.  **不切实际或不可行**：提供的截面、尺寸和源/探测器参数的数值对于核系统是物理上合理的。\n5.  **不适定或结构不良**：问题是适定的。要计算的量（$P_{ij}$ 及其后验矩）是唯一定义的。指定的蒙特卡罗方法保证了可以计算出稳定的解。所有术语都是标准的、无歧义的。\n6.  **伪深刻、琐碎或同义反复**：问题不琐碎，需要一个多层次的计算解决方案，涉及从第一性原理推导、从多个统计分布中抽样、嵌套的蒙特卡罗积分以及应用重要性抽样进行贝叶斯推断。\n7.  **超出科学可验证性范围**：解决方案可以通过使用给定的种子实现指定的算法来进行计算验证。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将按要求开发并实施一个解决方案。\n\n### 基于原理的解决方案设计\n\n解决方案将按照问题陈述的逻辑以模块化的方式构建。\n\n#### 1. $P_{ij}$ 估计器的推导\n问题的核心是计算 $P_{ij}$，即一个在区域 $i$（$x \\in [0, L_i]$）中各向同性且均匀出生的中子，在区域 $j$（$x \\in [L_i, L_i + L_j]$）中发生首次碰撞的概率。\n\n-   一个中子在位置 $x_0$ 处出生，该位置从均匀分布 $\\mathcal{U}(0, L_i)$ 中抽取。\n-   其飞行方向由方向余弦 $\\mu$ 给出，该余弦从均匀分布 $\\mathcal{U}(-1, 1)$ 中抽取。\n-   要让一个中子到达区域 $j$，它必须以一个正方向余弦 $\\mu > 0$ 出生。由于源是各向同性的，这个事件的概率是 $1/2$。\n-   给定一个在 $(x_0, \\mu)$ 处且 $\\mu > 0$ 的出生，中子必须首先从 $x_0$ 行进到界面 $x=L_i$ 而不发生碰撞。在区域 $i$ 中的路径长度是 $s_i = (L_i - x_0) / \\mu$。通过指数衰减，存活此路径的概率是 $p_{\\text{surv}, i} = \\exp(-\\Sigma_{t,i} s_i)$。\n-   到达区域 $j$ 后，中子必须在该区域内碰撞。在离开到真空之前，在区域 $j$ 中可用的总路径长度是 $s_j = L_j / \\mu$。沿此路径发生碰撞的概率是 $p_{\\text{coll}, j} = 1 - \\exp(-\\Sigma_{t,j} s_j)$。\n-   对于一个在 $x_0$ 处以方向 $\\mu$ 出生的特定向右行进的中子，其组合概率是这两个独立事件的乘积： $p(x_0, \\mu) = \\exp(-\\Sigma_{t,i} \\frac{L_i - x_0}{\\mu}) \\left(1 - \\exp(-\\Sigma_{t,j} \\frac{L_j}{\\mu})\\right)$。\n\n$P_{ij}$ 是此事件概率在所有可能出生情况下的期望值。这涉及对 $x_0$ 和 $\\mu$ 的分布进行积分，并包含方向的 $1/2$ 因子：\n$$ P_{ij} = \\int_{0}^{L_i} \\frac{dx_0}{L_i} \\int_{-1}^{1} \\frac{d\\mu}{2} \\cdot (\\text{事件概率}) $$\n由于当 $\\mu \\le 0$ 时事件概率为零，积分简化为：\n$$ P_{ij} = \\frac{1}{2L_i} \\int_{0}^{L_i} \\int_{0}^{1} \\exp\\left(-\\Sigma_{t,i} \\frac{L_i - x_0}{\\mu}\\right) \\left(1 - \\exp\\left(-\\Sigma_{t,j} \\frac{L_j}{\\mu}\\right)\\right) d\\mu \\, dx_0 $$\n这个二重积分将按照指定，使用蒙特卡罗方法进行估计。基于 $N_{\\text{inner}}$ 个样本的 $P_{ij}$ 估计器是：\n$$ \\hat{P}_{ij} = \\frac{1}{2} \\cdot \\frac{1}{N_{\\text{inner}}} \\sum_{k=1}^{N_{\\text{inner}}} \\exp\\left(-\\Sigma_{t,i} \\frac{L_i - x_{0,k}}{\\mu_k}\\right) \\left(1 - \\exp\\left(-\\Sigma_{t,j} \\frac{L_j}{\\mu_k}\\right)\\right) $$\n其中 $\\{x_{0,k}\\}_{k=1}^{N_{\\text{inner}}}$ 是从 $\\mathcal{U}(0, L_i)$ 中抽取的样本，$\\{\\mu_k\\}_{k=1}^{N_{\\text{inner}}}$ 是从 $\\mathcal{U}(0, 1)$ 中抽取的样本。因子 $1/2$ 正确地解释了只有一半各向同性发射的中子朝向区域 $j$。\n\n#### 2. 通过重要性抽样进行贝叶斯不确定性量化\nBUQ 框架旨在找到给定输入参数的先验分布和观测数据 $y_j$ 时的后验分布 $p(P_{ij} | y_j)$。重要性抽样用于近似这个后验。\n\n算法如下：\n1.  **从先验中抽样**：从指定的先验分布中为不确定参数生成大量的样本，$N_{\\text{prior}}$ 个：\n    -   $\\{\\Sigma_{t,i}^{(m)}, \\Sigma_{t,j}^{(m)}\\}_{m=1}^{N_{\\text{prior}}}$ 从独立的对数正态分布中抽样。基础正态分布的参数 $(\\mu_{\\ln}, \\sigma_{\\ln})$ 从给定的均值 ($m$) 和变异系数 ($\\mathrm{cv}$) 推导出来：$\\sigma_{\\ln}^2 = \\ln(\\mathrm{cv}^2 + 1)$ 和 $\\mu_{\\ln} = \\ln(m) - \\sigma_{\\ln}^2/2$。\n    -   $\\{L_i^{(m)}, L_j^{(m)}\\}_{m=1}^{N_{\\text{prior}}}$ 从在 $0$ 处截断的独立正态分布中抽样。\n\n2.  **评估模型**：对于每个参数集 $m \\in \\{1, \\dots, N_{\\text{prior}}\\}$，使用上述的、带有 $N_{\\text{inner}}$ 个样本的蒙特卡罗估计器 $\\hat{P}_{ij}$ 计算相应的碰撞概率 $P_{ij}^{(m)}$。\n\n3.  **计算重要性权重**：后验与似然乘以先验成正比，$p(\\theta|y) \\propto \\mathcal{L}(y|\\theta)p(\\theta)$。由于我们从先验 $p(\\theta)$ 中抽样，重要性权重就是似然值（或与其成比例的量）。给定观测模型 $y_j \\sim \\mathcal{N}(S_i P_{ij}, \\sigma_{\\mathrm{obs}}^2)$，第 $m$ 个样本的权重为：\n    $$ w^{(m)} \\propto \\exp\\left(-\\frac{1}{2}\\left(\\frac{y_j - S_i P_{ij}^{(m)}}{\\sigma_{\\mathrm{obs}}}\\right)^2\\right) $$\n\n4.  **归一化权重**：为了形成一个有效的概率分布，权重被归一化：\n    $$ W^{(m)} = \\frac{w^{(m)}}{\\sum_{k=1}^{N_{\\text{prior}}} w^{(k)}} $$\n    为了防止当指数参数为大的负数时发生数值下溢，在对数空间中计算权重并使用 log-sum-exp 技巧进行归一化是数值稳健的。\n\n5.  **计算后验矩**：$P_{ij}$ 的后验均值和方差通过对先验样本的加权和来近似：\n    -   后验均值：$E[P_{ij} | y_j] \\approx \\sum_{m=1}^{N_{\\text{prior}}} W^{(m)} P_{ij}^{(m)}$\n    -   后验方差：$\\mathrm{Var}[P_{ij} | y_j] \\approx \\left(\\sum_{m=1}^{N_{\\text{prior}}} W^{(m)} (P_{ij}^{(m)})^2\\right) - \\left(E[P_{ij} | y_j]\\right)^2$\n\n此过程将为提供的三个测试案例中的每一个实施。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import truncnorm\n\ndef estimate_pij(params, n_inner, rng):\n    \"\"\"\n    Estimates the collision probability P_ij using a Monte Carlo estimator.\n    \n    Args:\n        params (tuple): A tuple containing (sigma_ti, sigma_tj, li, lj).\n        n_inner (int): The number of inner loop Monte Carlo samples.\n        rng (np.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The estimated collision probability P_ij.\n    \"\"\"\n    sigma_ti, sigma_tj, li, lj = params\n\n    if li = 0 or lj = 0:\n        return 0.0\n\n    # Sample birth positions x_0 uniformly in [0, L_i]\n    x0_samples = rng.uniform(0, li, n_inner)\n    \n    # Sample direction cosines mu uniformly in (0, 1)\n    mu_samples = rng.uniform(0, 1, n_inner)\n\n    # Path length in region i\n    s_i = (li - x0_samples) / mu_samples\n    # Path length in region j\n    s_j = lj / mu_samples\n\n    # Probability of the event for each sample:\n    # survives region i AND collides in region j\n    event_prob = np.exp(-sigma_ti * s_i) * (1 - np.exp(-sigma_tj * s_j))\n\n    # The MC estimate of the integral over x0 and mu\n    integral_estimate = np.mean(event_prob)\n    \n    # P_ij includes a factor of 1/2 for the isotropic source (only neutrons with mu > 0 can reach region j)\n    p_ij = 0.5 * integral_estimate\n    \n    return p_ij\n\ndef process_case(case, rng):\n    \"\"\"\n    Performs Bayesian Uncertainty Quantification for a single test case.\n\n    Args:\n        case (dict): A dictionary containing all parameters for the case.\n        rng (np.random.Generator): The random number generator instance.\n\n    Returns:\n        tuple: A tuple containing (posterior_mean, posterior_variance).\n    \"\"\"\n    # Unpack case parameters\n    m_sigma_i, cv_sigma_i = case[\"m_sigma_i\"], case[\"cv_sigma_i\"]\n    m_sigma_j, cv_sigma_j = case[\"m_sigma_j\"], case[\"cv_sigma_j\"]\n    m_li, s_li = case[\"m_li\"], case[\"s_li\"]\n    m_lj, s_lj = case[\"m_lj\"], case[\"s_lj\"]\n    s_i = case[\"s_i\"]\n    y_j = case[\"y_j\"]\n    sigma_obs = case[\"sigma_obs\"]\n    n_prior = case[\"n_prior\"]\n    n_inner = case[\"n_inner\"]\n\n    # 1. Generate samples from prior distributions\n    \n    # Lognormal for Sigma_t\n    def get_lognormal_params(m, cv):\n        if m = 0 or cv = 0:\n            raise ValueError(\"Mean and CV for lognormal must be positive.\")\n        sigma_ln_sq = np.log(cv**2 + 1)\n        mu_ln = np.log(m) - 0.5 * sigma_ln_sq\n        return mu_ln, np.sqrt(sigma_ln_sq)\n\n    mu_ln_i, sigma_ln_i = get_lognormal_params(m_sigma_i, cv_sigma_i)\n    sigma_ti_samples = rng.lognormal(mu_ln_i, sigma_ln_i, n_prior)\n    \n    mu_ln_j, sigma_ln_j = get_lognormal_params(m_sigma_j, cv_sigma_j)\n    sigma_tj_samples = rng.lognormal(mu_ln_j, sigma_ln_j, n_prior)\n\n    # Truncated Normal for L\n    def get_truncnorm_samples(m, s, size):\n        a = (0 - m) / s\n        b = np.inf\n        return truncnorm.rvs(a, b, loc=m, scale=s, size=size, random_state=rng)\n\n    li_samples = get_truncnorm_samples(m_li, s_li, n_prior)\n    lj_samples = get_truncnorm_samples(m_lj, s_lj, n_prior)\n\n    # 2. Evaluate the model (P_ij) for each prior sample\n    p_ij_samples = np.zeros(n_prior)\n    prior_params = zip(sigma_ti_samples, sigma_tj_samples, li_samples, lj_samples)\n    for i, params in enumerate(prior_params):\n        p_ij_samples[i] = estimate_pij(params, n_inner, rng)\n\n    # 3. Compute importance weights\n    predicted_counts = s_i * p_ij_samples\n    log_weights = -0.5 * ((y_j - predicted_counts) / sigma_obs)**2\n    \n    # 4. Normalize weights using log-sum-exp trick for numerical stability\n    log_weights_max = np.max(log_weights)\n    weights_unnorm = np.exp(log_weights - log_weights_max)\n    weights_norm = weights_unnorm / np.sum(weights_unnorm)\n\n    # 5. Compute posterior mean and variance\n    post_mean = np.sum(weights_norm * p_ij_samples)\n    post_mean_sq = np.sum(weights_norm * p_ij_samples**2)\n    post_var = post_mean_sq - post_mean**2\n\n    return post_mean, post_var\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Fixed random seed for reproducibility\n    seed = 42\n    rng = np.random.default_rng(seed)\n    \n    test_cases = [\n        {\n            \"m_sigma_i\": 0.8, \"cv_sigma_i\": 0.20,\n            \"m_sigma_j\": 0.5, \"cv_sigma_j\": 0.25,\n            \"m_li\": 2.0, \"s_li\": 0.2,\n            \"m_lj\": 4.0, \"s_lj\": 0.3,\n            \"s_i\": 1.0e6, \"y_j\": 2.10e5, \"sigma_obs\": 2.00e4,\n            \"n_prior\": 400, \"n_inner\": 600,\n        },\n        {\n            \"m_sigma_i\": 0.9, \"cv_sigma_i\": 0.15,\n            \"m_sigma_j\": 0.6, \"cv_sigma_j\": 0.20,\n            \"m_li\": 3.0, \"s_li\": 0.3,\n            \"m_lj\": 0.5, \"s_lj\": 0.05,\n            \"s_i\": 1.5e6, \"y_j\": 3.80e4, \"sigma_obs\": 1.00e4,\n            \"n_prior\": 500, \"n_inner\": 500,\n        },\n        {\n            \"m_sigma_i\": 3.0, \"cv_sigma_i\": 0.30,\n            \"m_sigma_j\": 0.4, \"cv_sigma_j\": 0.30,\n            \"m_li\": 2.0, \"s_li\": 0.2,\n            \"m_lj\": 3.0, \"s_lj\": 0.3,\n            \"s_i\": 1.0e6, \"y_j\": 7.00e3, \"sigma_obs\": 5.00e3,\n            \"n_prior\": 450, \"n_inner\": 600,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        mean, var = process_case(case, rng)\n        results.extend([mean, var])\n    \n    # Format the output as specified\n    formatted_results = [f\"{val:.6f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}