{
    "hands_on_practices": [
        {
            "introduction": "$P_N$近似方法的核心在于将角中子通量展开为一组正交多项式。这个练习旨在通过罗德里格斯公式推导这些关键的基函数——勒让德多项式，并验证它们在输运理论中至关重要的正交性和归一化性质，从而巩固您对这些基本构件的理解。通过完成这个基础推导，您将为后续更复杂的$P_N$应用打下坚实的数学基础。",
            "id": "4256614",
            "problem": "在一维板状几何中子输运中，球谐函数 ($P_N$) 近似将中子角通量密度的角度依赖性，用方向余弦变量 $\\mu \\in [-1,1]$ 上的勒让德多项式展开。从勒让德多项式的罗德里格斯构造的基本定义出发，并将其视为与单位权重下 $[-1,1]$ 上的勒让德微分算子相关的正交本征函数，推导前四个勒让德多项式 $P_{0}(\\mu)$ 到 $P_{3}(\\mu)$。然后，确认其归一化与输运理论的惯例一致，即对于 $l=0,1,2,3$，有 $P_{l}(1)=1$；并且在 $[-1,1]$ 上权重为1的正交性成立，使得自内积满足 $\\int_{-1}^{1} P_{l}(\\mu)^{2} \\, d\\mu = \\frac{2}{2l+1}$（对于 $l=0,1,2,3$），且交叉内积满足 $\\int_{-1}^{1} P_{l}(\\mu) P_{m}(\\mu) \\, d\\mu=0$（对于 $l \\neq m$ 且 $l,m \\in \\{0,1,2,3\\}$）。以 $\\mu$ 的函数形式，显式地给出这四个多项式的闭合形式。最终答案必须是将这四个多项式集合成一个单行矩阵。无需四舍五入。",
            "solution": "问题要求从罗德里格斯构造出发，推导前四个勒让德多项式 $P_{0}(\\mu)$ 到 $P_{3}(\\mu)$。这些多项式是中子输运方程 $P_N$ 近似方法的基础，在该方法中，它们构成了在方向余弦定义域 $\\mu \\in [-1, 1]$ 上展开中子通量密度角度依赖性的正交基。在推导出多项式之后，必须显式地验证它们的归一化和正交性，这些性质对于它们在输运理论中的应用至关重要。\n\n勒让德多项式 $P_{l}(\\mu)$ 的罗德里格斯公式为：\n$$ P_{l}(\\mu) = \\frac{1}{2^{l} l!} \\frac{d^{l}}{d\\mu^{l}} (\\mu^2 - 1)^l $$\n我们将对 $l=0, 1, 2, 3$ 应用此公式。\n\n对于 $l=0$：\n$$ P_{0}(\\mu) = \\frac{1}{2^{0} 0!} \\frac{d^{0}}{d\\mu^{0}} (\\mu^2 - 1)^0 = \\frac{1}{1 \\cdot 1} \\cdot 1 = 1 $$\n\n对于 $l=1$：\n$$ P_{1}(\\mu) = \\frac{1}{2^{1} 1!} \\frac{d}{d\\mu} (\\mu^2 - 1)^1 = \\frac{1}{2} (2\\mu) = \\mu $$\n\n对于 $l=2$：\n$$ P_{2}(\\mu) = \\frac{1}{2^{2} 2!} \\frac{d^2}{d\\mu^2} (\\mu^2 - 1)^2 = \\frac{1}{8} \\frac{d^2}{d\\mu^2} (\\mu^4 - 2\\mu^2 + 1) $$\n一阶导数为 $\\frac{d}{d\\mu}(\\mu^4 - 2\\mu^2 + 1) = 4\\mu^3 - 4\\mu$。\n二阶导数为 $\\frac{d}{d\\mu}(4\\mu^3 - 4\\mu) = 12\\mu^2 - 4$。\n因此，\n$$ P_{2}(\\mu) = \\frac{1}{8} (12\\mu^2 - 4) = \\frac{4}{8} (3\\mu^2 - 1) = \\frac{1}{2} (3\\mu^2 - 1) $$\n\n对于 $l=3$：\n$$ P_{3}(\\mu) = \\frac{1}{2^{3} 3!} \\frac{d^3}{d\\mu^3} (\\mu^2 - 1)^3 = \\frac{1}{8 \\cdot 6} \\frac{d^3}{d\\mu^3} (\\mu^6 - 3\\mu^4 + 3\\mu^2 - 1) $$\n一阶导数为 $6\\mu^5 - 12\\mu^3 + 6\\mu$。\n二阶导数为 $30\\mu^4 - 36\\mu^2 + 6$。\n三阶导数为 $120\\mu^3 - 72\\mu$。\n因此，\n$$ P_{3}(\\mu) = \\frac{1}{48} (120\\mu^3 - 72\\mu) = \\frac{24}{48} (5\\mu^3 - 3\\mu) = \\frac{1}{2} (5\\mu^3 - 3\\mu) $$\n\n前四个勒让德多项式为：\n$P_0(\\mu) = 1$\n$P_1(\\mu) = \\mu$\n$P_2(\\mu) = \\frac{1}{2}(3\\mu^2 - 1)$\n$P_3(\\mu) = \\frac{1}{2}(5\\mu^3 - 3\\mu)$\n\n接下来，我们验证对于 $l = 0, 1, 2, 3$ 的归一化条件 $P_{l}(1)=1$。\n对于 $l=0$：$P_{0}(1) = 1$。\n对于 $l=1$：$P_{1}(1) = 1$。\n对于 $l=2$：$P_{2}(1) = \\frac{1}{2}(3(1)^2 - 1) = \\frac{1}{2}(2) = 1$。\n对于 $l=3$：$P_{3}(1) = \\frac{1}{2}(5(1)^3 - 3(1)) = \\frac{1}{2}(2) = 1$。\n归一化条件得到满足。\n\n最后，我们验证在区间 $[-1,1]$ 上权重为1的正交关系。\n\n首先，自内积：$\\int_{-1}^{1} P_{l}(\\mu)^2 \\, d\\mu = \\frac{2}{2l+1}$。\n对于 $l=0$：$\\int_{-1}^{1} P_{0}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} 1^2 \\, d\\mu = [\\mu]_{-1}^{1} = 1 - (-1) = 2$。公式给出 $\\frac{2}{2(0)+1} = 2$。\n对于 $l=1$：$\\int_{-1}^{1} P_{1}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} \\mu^2 \\, d\\mu = \\left[\\frac{\\mu^3}{3}\\right]_{-1}^{1} = \\frac{1}{3} - \\frac{-1}{3} = \\frac{2}{3}$。公式给出 $\\frac{2}{2(1)+1} = \\frac{2}{3}$。\n对于 $l=2$：$\\int_{-1}^{1} P_{2}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} \\left(\\frac{1}{2}(3\\mu^2 - 1)\\right)^2 \\, d\\mu = \\frac{1}{4} \\int_{-1}^{1} (9\\mu^4 - 6\\mu^2 + 1) \\, d\\mu = \\frac{1}{4} \\left[ \\frac{9\\mu^5}{5} - 2\\mu^3 + \\mu \\right]_{-1}^{1} = \\frac{1}{4} \\left( (\\frac{9}{5} - 2 + 1) - (-\\frac{9}{5} + 2 - 1) \\right) = \\frac{1}{4} \\left( \\frac{4}{5} - (-\\frac{4}{5}) \\right) = \\frac{1}{4} \\left(\\frac{8}{5}\\right) = \\frac{2}{5}$。公式给出 $\\frac{2}{2(2)+1} = \\frac{2}{5}$。\n对于 $l=3$：$\\int_{-1}^{1} P_{3}(\\mu)^2 \\, d\\mu = \\int_{-1}^{1} \\left(\\frac{1}{2}(5\\mu^3 - 3\\mu)\\right)^2 \\, d\\mu = \\frac{1}{4} \\int_{-1}^{1} (25\\mu^6 - 30\\mu^4 + 9\\mu^2) \\, d\\mu = \\frac{1}{4} \\left[ \\frac{25\\mu^7}{7} - 6\\mu^5 + 3\\mu^3 \\right]_{-1}^{1} = \\frac{1}{4} \\left( (\\frac{25}{7} - 6 + 3) - (-\\frac{25}{7} + 6 - 3) \\right) = \\frac{1}{4} \\left( \\frac{4}{7} - (-\\frac{4}{7}) \\right) = \\frac{1}{4} \\left(\\frac{8}{7}\\right) = \\frac{2}{7}$。公式给出 $\\frac{2}{2(3)+1} = \\frac{2}{7}$。\n所有自内积均正确。\n\n其次，交叉内积：$\\int_{-1}^{1} P_{l}(\\mu) P_{m}(\\mu) \\, d\\mu = 0$ (对于 $l \\neq m$)。\n我们注意到，当 $l$ 为偶数时，$P_l(\\mu)$ 是偶函数；当 $l$ 为奇数时，$P_l(\\mu)$ 是奇函数。一个偶函数与一个奇函数的乘积在对称区间如 $[-1,1]$ 上的积分为零。\n宇称混合的情况（$l$ 为偶数，$m$ 为奇数，反之亦然）：\n$\\int_{-1}^{1} P_{0}(\\mu)P_{1}(\\mu) \\, d\\mu = 0$\n$\\int_{-1}^{1} P_{0}(\\mu)P_{3}(\\mu) \\, d\\mu = 0$\n$\\int_{-1}^{1} P_{1}(\\mu)P_{2}(\\mu) \\, d\\mu = 0$\n$\\int_{-1}^{1} P_{2}(\\mu)P_{3}(\\mu) \\, d\\mu = 0$\n由于被积函数的宇称性，这些积分全为零。\n\n宇称相同的情况：\n对于 $l=0, m=2$：\n$\\int_{-1}^{1} P_{0}(\\mu)P_{2}(\\mu) \\, d\\mu = \\int_{-1}^{1} (1) \\left(\\frac{1}{2}(3\\mu^2 - 1)\\right) \\, d\\mu = \\frac{1}{2} [\\mu^3 - \\mu]_{-1}^{1} = \\frac{1}{2} ((1-1) - (-1 - (-1))) = 0$。\n对于 $l=1, m=3$：\n$\\int_{-1}^{1} P_{1}(\\mu)P_{3}(\\mu) \\, d\\mu = \\int_{-1}^{1} (\\mu) \\left(\\frac{1}{2}(5\\mu^3 - 3\\mu)\\right) \\, d\\mu = \\frac{1}{2} \\int_{-1}^{1} (5\\mu^4 - 3\\mu^2) \\, d\\mu = \\frac{1}{2} [\\mu^5 - \\mu^3]_{-1}^{1} = \\frac{1}{2} ((1-1) - (-1 - (-1))) = 0$。\n对于所有 $l, m \\in \\{0, 1, 2, 3\\}$ 且 $l \\neq m$ 的配对，正交性得到确认。\n\n推导和验证完成。这四个多项式在最终答案中给出。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix} 1 & \\mu & \\frac{1}{2}(3\\mu^2 - 1) & \\frac{1}{2}(5\\mu^3 - 3\\mu) \\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "中子输运程序通常计算的是角通量的各阶矩，而非角通量本身。本练习将引导您完成关键的后续步骤：如何从这些计算出的矩重构角通量分布。此外，本练习还揭示了$P_N$方法的一个已知缺陷——可能出现非物理的负通量值，并提供了一种检验方法，这对于评估近似解的物理实在性至关重要。",
            "id": "4256647",
            "problem": "考虑一维平板几何中的单速稳态中子输运，其中角通量 $\\psi(x,\\mu)$ 取决于空间坐标 $x$ 和方向余弦 $\\mu \\in [-1,1]$。球谐函数 (SH) 方法使用勒让德多项式 $P_{\\ell}(\\mu)$ 来近似角依赖性，输运求解器通常计算一组有限的勒让德矩 $\\{\\phi_{\\ell}(x)\\}_{\\ell=0}^{N}$，其中每个矩由基本关系 $\\phi_{\\ell}(x) = \\int_{-1}^{1} \\psi(x,\\mu) P_{\\ell}(\\mu)\\,d\\mu$ 定义。勒让德多项式满足经过充分检验的正交性 $\\int_{-1}^{1} P_{\\ell}(\\mu) P_{m}(\\mu)\\,d\\mu = \\frac{2}{2\\ell+1}\\delta_{\\ell m}$，其中 $\\delta_{\\ell m}$ 是克罗内克 δ 符号。物理角通量必须对所有 $\\mu \\in [-1,1]$ 和所有 $x$ 满足 $\\psi(x,\\mu) \\ge 0$。\n\n仅从这些事实出发，推导如何使用 $N=3$ 的勒让德多项式截断展开，从计算出的矩 $\\{\\phi_{\\ell}(x)\\}_{\\ell=0}^{N}$ 重构近似角通量 $\\psi_{N}(x,\\mu)$。然后实现此重构，并通过在 $\\mu$ 的 $M=1001$ 个点的均匀网格上评估重构的 $\\psi_{3}(x,\\mu)$，检查其最小值是否非负，从而评估 $\\psi_{3}(x,\\mu)$ 在整个角域 $\\mu \\in [-1,1]$ 上的正性。\n\n您的程序必须：\n- 实现重构算法，该算法使用最高3阶的勒让德多项式，将固定空间坐标 $x$ 处的给定矩列表 $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\}$ 映射到截断角通量近似 $\\psi_{3}(x,\\mu)$。\n- 在 $[-1,1]$ 区间上，在一个包含 $M=1001$ 个点的 $\\mu$ 均匀网格上评估 $\\psi_{3}(x,\\mu)$。\n- 返回一个布尔值，指示重构的通量在所有采样角度上是否非负，即 $\\min_{\\mu \\in [-1,1]} \\psi_{3}(x,\\mu) \\ge 0$ 是否成立。\n\n不需要物理单位，因为 $\\mu$ 根据定义是无量纲的（极角的余弦），并且输入中没有明确出现角度；因此不需要指定角度单位。在所描述的数值网格意义上，正性检查必须是精确的。\n\n在单个空间位置 $x$ 处使用以下矩集测试套件：\n- 测试 $1$ (各向同性正参考): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.0, 0.0, 0.0\\}$。\n- 测试 $2$ (强一阶矩各向异性): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.6, 0.0, 0.0\\}$。\n- 测试 $3$ (线性各向异性但具有 $A=0.7, \\alpha=0.8$ 的正底层分布): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.4, 0.37333333333333335, 0.0, 0.0\\}$。\n- 测试 $4$ (通过 $P_{2}$ 分量实现的偶数各向异性，具有 $A=0.9, \\beta=1.5$): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.8, 0.0, 0.54, 0.0\\}$。\n- 测试 $5$ (边界线性情况，具有 $A=0.5, \\alpha=1.0$): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.3333333333333333, 0.0, 0.0\\}$。\n- 测试 $6$ (标量通量为零的不可实现矩集): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{0.0, 0.3, 0.0, 0.0\\}$。\n- 测试 $7$ (混合高阶各向异性): $\\{\\phi_{0},\\phi_{1},\\phi_{2},\\phi_{3}\\} = \\{1.0, 0.2, 0.1, -0.05\\}$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表（例如 `[result1,result2,...]`），每个条目是对应于相应测试用例的正性评估的布尔值，按上面列出的顺序排列。",
            "solution": "该问题要求推导一种方法，用于从给定的勒让德矩集 $\\{\\phi_{\\ell}(x)\\}_{\\ell=0}^{N}$ 重构近似角中子通量 $\\psi_N(x, \\mu)$，然后针对 $N=3$ 的情况实现此重构以评估其正性。问题设定在一维平板几何中，其中 $\\psi$ 取决于位置 $x$ 和极角的余弦 $\\mu \\in [-1,1]$。推导将在固定的空间坐标 $x$ 处进行，因此为了符号简化，将省略对 $x$ 的依赖，例如写作 $\\psi(\\mu)$ 和 $\\phi_{\\ell}$。\n\n球谐函数 ($P_N$) 方法的基础是用勒让德多项式 $P_{\\ell}(\\mu)$ 的截断级数来近似角通量 $\\psi(\\mu)$：\n$$\n\\psi_N(\\mu) = \\sum_{\\ell=0}^{N} c_{\\ell} P_{\\ell}(\\mu)\n$$\n这里，$\\psi_N(\\mu)$ 是对真实通量 $\\psi(\\mu)$ 的 $N$ 阶近似，而 $\\{c_{\\ell}\\}_{\\ell=0}^{N}$ 是我们必须确定的未知展开系数。\n\n问题提供了通量的勒让德矩的定义：\n$$\n\\phi_m = \\int_{-1}^{1} \\psi(\\mu) P_m(\\mu) \\,d\\mu\n$$\n为了将给定的矩 $\\{\\phi_m\\}$ 与未知系数 $\\{c_\\ell\\}$ 联系起来，我们施加一个条件，即近似通量 $\\psi_N(\\mu)$ 的矩必须等于给定的矩，对于所有阶数直到 $N$：\n$$\n\\phi_m = \\int_{-1}^{1} \\psi_N(\\mu) P_m(\\mu) \\,d\\mu \\quad \\text{for } m = 0, 1, \\dots, N\n$$\n将 $\\psi_N(\\mu)$ 的级数展开式代入此方程得到：\n$$\n\\phi_m = \\int_{-1}^{1} \\left( \\sum_{\\ell=0}^{N} c_{\\ell} P_{\\ell}(\\mu) \\right) P_m(\\mu) \\,d\\mu\n$$\n根据积分的线性性质，我们可以交换求和与积分的顺序：\n$$\n\\phi_m = \\sum_{\\ell=0}^{N} c_{\\ell} \\int_{-1}^{1} P_{\\ell}(\\mu) P_m(\\mu) \\,d\\mu\n$$\n问题陈述提供了勒让德多项式的正交性：\n$$\n\\int_{-1}^{1} P_{\\ell}(\\mu) P_m(\\mu) \\,d\\mu = \\frac{2}{2\\ell+1} \\delta_{\\ell m}\n$$\n其中 $\\delta_{\\ell m}$ 是克罗内克 δ 符号，当 $\\ell = m$ 时为 $1$，否则为 $0$。\n\n将此正交关系代入 $\\phi_m$ 的方程中：\n$$\n\\phi_m = \\sum_{\\ell=0}^{N} c_{\\ell} \\left( \\frac{2}{2\\ell+1} \\delta_{\\ell m} \\right)\n$$\n对于给定的 $m$（其中 $0 \\le m \\le N$），对 $\\ell$ 的求和会简化为单个非零项，这发生在 $\\ell=m$ 时：\n$$\n\\phi_m = c_m \\left( \\frac{2}{2m+1} \\right)\n$$\n我们现在可以解出未知系数 $c_m$：\n$$\nc_m = \\frac{2m+1}{2} \\phi_m\n$$\n这提供了展开系数和给定矩之间的直接关系。通过将 $c_\\ell$ 的这个表达式代回 $\\psi_N(\\mu)$ 的原始级数，我们得到最终的重构公式：\n$$\n\\psi_N(\\mu) = \\sum_{\\ell=0}^{N} \\frac{2\\ell+1}{2} \\phi_{\\ell} P_{\\ell}(\\mu)\n$$\n问题指定了 $N=3$ 阶的近似。因此，要实现的重构公式是：\n$$\n\\psi_3(\\mu) = \\frac{1}{2}\\phi_0 P_0(\\mu) + \\frac{3}{2}\\phi_1 P_1(\\mu) + \\frac{5}{2}\\phi_2 P_2(\\mu) + \\frac{7}{2}\\phi_3 P_3(\\mu)\n$$\n前四个勒让德多项式是：\n- $P_0(\\mu) = 1$\n- $P_1(\\mu) = \\mu$\n- $P_2(\\mu) = \\frac{1}{2}(3\\mu^2 - 1)$\n- $P_3(\\mu) = \\frac{1}{2}(5\\mu^3 - 3\\mu)$\n\n数值任务是在 $\\mu \\in [-1,1]$ 域内的一个包含 $M=1001$ 个点的均匀网格上，为给定的矩集 $\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3\\}$ 计算 $\\psi_3(\\mu)$ 的表达式。在此网格上计算出 $\\psi_3(\\mu)$ 的值后，我们找到最小值。如果该最小值大于或等于 $0$，则重构通量被认为是非负的，评估结果为正 (True)。否则，为负 (False)。物理公理 $\\psi(x,\\mu) \\ge 0$ 并不总是被截断的 $P_N$ 近似所保持，此程序旨在测试这种违规情况。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre\n\ndef solve():\n    \"\"\"\n    Solves the problem by reconstructing the angular flux from moments\n    for a series of test cases and checking for positivity.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Isotropic positive reference\n        [1.0, 0.0, 0.0, 0.0],\n        # Test 2: Strong first-moment anisotropy\n        [1.0, 0.6, 0.0, 0.0],\n        # Test 3: Linearly anisotropic but positive underlying distribution\n        [1.4, 0.37333333333333335, 0.0, 0.0],\n        # Test 4: Even anisotropy via P2 component\n        [1.8, 0.0, 0.54, 0.0],\n        # Test 5: Boundary-linear case\n        [1.0, 0.3333333333333333, 0.0, 0.0],\n        # Test 6: Non-realizable moment set with zero scalar flux\n        [0.0, 0.3, 0.0, 0.0],\n        # Test 7: Mixed higher-order anisotropy\n        [1.0, 0.2, 0.1, -0.05],\n    ]\n\n    def check_positivity_for_moments(moments, M=1001, N=3):\n        \"\"\"\n        Reconstructs the P3-approximated angular flux from Legendre moments\n        and checks if it is non-negative over the angular domain.\n\n        Args:\n            moments (list or np.ndarray): A list of Legendre moments [phi_0, phi_1, phi_2, phi_3].\n            M (int): The number of points in the uniform angular grid.\n            N (int): The order of the P_N approximation.\n\n        Returns:\n            bool: True if the minimum of the reconstructed flux is >= 0, False otherwise.\n        \"\"\"\n        # Create a uniform grid of M points for the direction cosine mu in [-1, 1].\n        mu_grid = np.linspace(-1.0, 1.0, M)\n        \n        # Initialize the reconstructed flux array.\n        psi_N = np.zeros_like(mu_grid)\n        \n        # The reconstruction formula is:\n        # psi_N(mu) = sum_{l=0 to N} (2*l + 1) / 2 * phi_l * P_l(mu)\n        for l in range(N + 1):\n            # Get the Legendre polynomial of order l.\n            # scipy.special.legendre(l) returns a callable poly1d object.\n            P_l = legendre(l)\n            phi_l = moments[l]\n            psi_N += (2 * l + 1) / 2.0 * phi_l * P_l(mu_grid)\n            \n        # Find the minimum value of the reconstructed flux on the grid.\n        min_psi = np.min(psi_N)\n        \n        # Return True if the minimum value is non-negative, False otherwise.\n        # A small tolerance is not used as per problem specification.\n        return min_psi >= 0.0\n\n    results = []\n    for case in test_cases:\n        is_positive = check_positivity_for_moments(case)\n        results.append(is_positive)\n\n    # Final print statement in the exact required format \"[True,False,True,...]\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，我们不仅要执行一次计算，更要关心“我的近似解有多好？”以及如何改进它。本练习引入了一种实用方法，用于估算达到给定精度目标所需的$P_N$近似阶数($N$)。通过一个简化但符合物理实际的误差模型，您将学习如何将近似理论与实际的误差控制联系起来，这是数值模拟中一项高级但至关重要的技能。",
            "id": "4256628",
            "problem": "考虑线性玻尔兹曼输运方程的稳态、单能、一维平板模型，该模型处于均匀介质中，总截面为常数，且材料性质没有空间变化。角通量由 $\\psi(x,\\mu)$ 表示，其中 $x$ 是空间坐标，$\\mu\\in[-1,1]$ 是极向角的余弦。标量通量定义为角积分 $\\phi(x)=\\int_{-1}^{1}\\psi(x,\\mu)\\,d\\mu$。在 $N$ 阶球谐函数近似（$P_{N}$ 近似）中，角通量由勒让德多项式的有限级数表示，这等价于由最高为 $N$ 阶的角矩表示。\n\n假设一个构造的精确角解，其勒让德矩（在一维平板中的球谐函数矩）对于所有整数 $\\ell\\ge 1$ 满足已知的代数衰减 $|\\psi_{\\ell}(x)|=C\\,\\ell^{-p}$，其中常数 $C>0$ 和 $p>0$ 与 $x$ 无关。进一步假设 $P_{N}$ 闭合是在 $\\ell=N+1$ 处的标准零闭合，并且在任意 $x$ 处产生的标量通量误差满足以下形式的稳定性界\n$$\n\\left|\\phi(x)-\\phi^{(N)}(x)\\right|\\le \\kappa\\,\\left|\\psi_{N+1}(x)\\right|,\n$$\n其中 $\\phi^{(N)}(x)$ 是由 $P_{N}$ 近似产生的标量通量，$\\kappa>0$ 是一个耦合常数，反映了矩系统中近邻输运/散射耦合的强度。这个界与一维平板几何中勒让德矩输运方程的三对角递推结构是一致的。\n\n你的任务是编写一个完整、可运行的程序，对于几个测试用例，给定 $(p,C,\\epsilon,\\kappa)$，计算使得上述误差界保证绝对标量通量误差在任何地方都不超过目标精度 $\\epsilon>0$ 的最小非负整数 $N$（在这里，空间依赖性无关紧要，因为在构造解的假设下，该界在 $x$ 上是均匀的）。如果没有有限的 $N$ 能够在该衰减模型下保证目标精度（例如，如果 $p\\le 0$ 以至于首个被忽略的矩不衰减），则程序必须为该测试用例返回 $-1$。\n\n仅从以下基本依据出发：\n- 标量通量的定义 $\\phi(x)=\\int_{-1}^{1}\\psi(x,\\mu)\\,d\\mu$。\n- $\\psi$ 作为角矩级数的球谐函数（$P_{N}$）表示。\n- 构造的角矩衰减 $|\\psi_{\\ell}|=C\\,\\ell^{-p}$。\n- 在 $\\ell=N+1$ 处零闭合下，由三对角矩耦合所蕴含的稳定性界 $\\left|\\phi-\\phi^{(N)}\\right|\\le \\kappa\\,\\left|\\psi_{N+1}\\right|$。\n\n从第一性原理推导如何根据 $(p,C,\\epsilon,\\kappa)$ 确定最小的 $N$。在代码中实现你推导的方法，并为每个测试用例计算所需的 $N$。程序必须是纯数学和逻辑的；此问题中不需要物理单位。\n\n测试套件：\n- 情况 1：$p=3$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-3}$。\n- 情况 2：$p=2.1$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-6}$。\n- 情况 3：$p=5$, $C=2$, $\\kappa=0.5$, $\\epsilon=10^{-6}$。\n- 情况 4：$p=0$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-4}$。\n- 情况 5：$p=10$, $C=1$, $\\kappa=1$, $\\epsilon=10^{-12}$。\n\n答案规格：\n- 对于每个测试用例，输出一个整数：满足推导条件的最小 $N\\in\\{0,1,2,\\dots\\}$，如果根据给定参数不可能满足，则输出 $-1$。\n- 最终输出必须是单行，包含一个逗号分隔的五个整数列表，用方括号括起来，顺序与测试套件相同（例如，$[n_{1},n_{2},n_{3},n_{4},n_{5}]$）。",
            "solution": "问题要求找到 $P_N$ 近似的最小非负整数阶数 $N$，使得标量通量的绝对误差 $|\\phi(x) - \\phi^{(N)}(x)|$ 保证不大于指定的容差 $\\epsilon$。推导从给定的第一性原理出发。\n\n需要满足的条件是：\n$$\n\\left|\\phi(x)-\\phi^{(N)}(x)\\right| \\le \\epsilon\n$$\n对于给定的容差 $\\epsilon > 0$。\n\n问题提供了一个稳定性界，它将标量通量误差与角通量的首个被忽略的勒让德矩 $\\psi_{N+1}(x)$ 联系起来：\n$$\n\\left|\\phi(x)-\\phi^{(N)}(x)\\right| \\le \\kappa\\,\\left|\\psi_{N+1}(x)\\right|\n$$\n其中 $\\kappa > 0$ 是一个已知常数。为确保满足我们的误差条件，只需要求上界也满足该条件即可：\n$$\n\\kappa\\,\\left|\\psi_{N+1}(x)\\right| \\le \\epsilon\n$$\n\n我们得到了一个构造解的角矩大小的模型，该模型指出，对于任何整数 $\\ell \\ge 1$，矩会代数衰减：\n$$\n\\left|\\psi_{\\ell}(x)\\right| = C\\,\\ell^{-p}\n$$\n常数 $C > 0$ 和 $p > 0$ 是给定的，并且与空间变量 $x$ 无关。这种在 $x$ 上的均匀性使我们可以在不考虑空间依赖性的情况下处理该不等式。我们可以通过令 $\\ell = N+1$ 来找到首个被忽略的矩 $\\psi_{N+1}$ 的大小：\n$$\n\\left|\\psi_{N+1}(x)\\right| = C\\,(N+1)^{-p}\n$$\n这对于 $N+1 \\ge 1$ 成立，即对任何非负整数 $N$ 都成立。\n\n将此表达式代入我们的充分条件，得到一个关于所需近似阶数 $N$ 的不等式：\n$$\n\\kappa\\,C\\,(N+1)^{-p} \\le \\epsilon\n$$\n我们的任务是找到满足此不等式的最小非负整数 $N$，其中参数 $(p, C, \\kappa, \\epsilon)$ 是给定的。\n\n我们必须首先分析衰减参数 $p$ 的作用。问题指出，如果没有有限的 $N$ 能够保证目标精度（例如，如果 $p \\le 0$ 以至于矩不衰减），则结果应为 $-1$。让我们来研究这种情况。\n如果 $p = 0$，不等式变为 $\\kappa\\,C \\le \\epsilon$。左侧是一个常数值。如果此条件不成立，则任何 $N$ 值都无法满足该不等式。如果 $p  0$，令 $p' = -p > 0$。不等式变为 $\\kappa\\,C\\,(N+1)^{p'} \\le \\epsilon$。在这种情况下，左侧是 $N$ 的增函数。如果对于 $N=0$ 精度要求未被满足，那么对于任何更大的 $N$ 也肯定不会被满足。因此，对于任何 $p \\le 0$，误差界不一定随着 $N$ 的增加而减小，因此不能保证收敛到任意小的 $\\epsilon$。根据问题的规范，对于任何 $p \\le 0$ 的情况，所需的阶数是未定义的，我们必须报告 $-1$。\n\n现在，我们考虑 $p  0$ 的主要情况。所有参数 $\\kappa, C, \\epsilon, p$ 都是正实数。我们可以用代数方法解出关于 $N$ 的不等式：\n$$\n\\kappa\\,C\\,(N+1)^{-p} \\le \\epsilon\n$$\n除以 $\\kappa\\,C$（为正数）：\n$$\n(N+1)^{-p} \\le \\frac{\\epsilon}{\\kappa C}\n$$\n两边取倒数会使不等号反向，因为两边都是正数：\n$$\n(N+1)^p \\ge \\frac{\\kappa C}{\\epsilon}\n$$\n对两边取 $p$ 次方根（对于正基数是单调运算）：\n$$\nN+1 \\ge \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p}\n$$\n最后，分离出 $N$：\n$$\nN \\ge \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1\n$$\n这个不等式为 $N$ 提供了一个下界。我们在寻找满足此条件的最小非负整数 $N$。令 $N_{min} = \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1$。满足 $N \\ge N_{min}$ 的最小整数由向上取整函数（ceiling function）$\\lceil N_{min} \\rceil$ 给出。然而，近似阶数 $N$ 不能为负，因此它必须是一个非负整数，即 $N \\in \\{0, 1, 2, \\dots\\}$。因此，最终答案是 $0$ 和 $\\lceil N_{min} \\rceil$ 中的较大者。\n这可以表示为：\n$$\nN = \\max\\left(0, \\left\\lceil \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1 \\right\\rceil\\right)\n$$\n这个公式正确地处理了右侧为负数的情况（意味着 $N=0$ 就足够了），并确保结果是一个非负整数。\n\n总之，算法如下：\n1.  给定参数 $(p, C, \\kappa, \\epsilon)$。\n2.  如果 $p \\le 0$，则所需的 $N$ 为 $-1$。\n3.  如果 $p  0$，计算 $N_{min} = \\left(\\frac{\\kappa C}{\\epsilon}\\right)^{1/p} - 1$。\n4.  结果是满足 $N \\ge N_{min}$ 的最小非负整数，计算为 $\\max(0, \\lceil N_{min} \\rceil)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a suite of test cases, calculating the minimum\n    P_N order N required to meet a given error tolerance.\n    \"\"\"\n\n    # Test cases are provided as tuples of (p, C, kappa, epsilon).\n    test_cases = [\n        (3, 1, 1, 1e-3),    # Case 1\n        (2.1, 1, 1, 1e-6),  # Case 2\n        (5, 2, 0.5, 1e-6),  # Case 3\n        (0, 1, 1, 1e-4),    # Case 4\n        (10, 1, 1, 1e-12),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        p, C, kappa, epsilon = case\n        result = compute_required_N(p, C, kappa, epsilon)\n        results.append(result)\n\n    # The final output must be a single line containing a comma-separated\n    # list of the five integers enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_required_N(p, C, kappa, epsilon):\n    \"\"\"\n    Calculates the smallest non-negative integer N based on the derived formula.\n\n    The problem requires finding the smallest non-negative integer N such that:\n    kappa * C * (N + 1)**(-p) = epsilon\n\n    Args:\n        p (float): The decay exponent of the angular moments.\n        C (float): The decay coefficient of the angular moments.\n        kappa (float): The stability coupling constant.\n        epsilon (float): The target absolute error tolerance.\n\n    Returns:\n        int: The smallest non-negative integer N, or -1 if no such N exists.\n    \"\"\"\n    # According to the problem statement and derivation, if p = 0, the\n    # error bound does not necessarily decay with N, so convergence to an\n    # arbitrary epsilon is not guaranteed. In this case, we return -1.\n    if p = 0:\n        return -1\n\n    # For p > 0, we solve the inequality for N:\n    # (N + 1)**p >= (kappa * C) / epsilon\n    # N + 1 >= ((kappa * C) / epsilon)**(1/p)\n    # N >= ((kappa * C) / epsilon)**(1/p) - 1\n\n    # Calculate the lower bound for N.\n    # Note: All parameters kappa, C, epsilon are given as positive.\n    n_lower_bound = (kappa * C / epsilon)**(1 / p) - 1\n\n    # The required N must be an integer. The smallest integer satisfying\n    # N >= n_lower_bound is the ceiling of n_lower_bound.\n    # We use np.ceil for this calculation.\n    n_integer = np.ceil(n_lower_bound)\n\n    # The order N must also be non-negative. If the calculated integer value\n    # is negative, it means that even N=0 already satisfies the condition.\n    # The smallest non-negative integer is thus max(0, n_integer).\n    required_n = int(max(0, n_integer))\n\n    return required_n\n\n# Execute the main solver function.\nsolve()\n```"
        }
    ]
}