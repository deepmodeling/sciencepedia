{
    "hands_on_practices": [
        {
            "introduction": "Particle transport simulation is fundamentally a geometric problem of tracking paths through a defined space. Before we can model complex nuclear interactions, we must first master the algorithm that determines a particle's trajectory and its intersection with physical boundaries. This practice will guide you in implementing a robust boundary-crossing algorithm, a core component of any Monte Carlo code that answers the question: \"How far can this particle travel before hitting something?\" .",
            "id": "4218147",
            "problem": "In continuous-energy Monte Carlo (MC) neutron transport, a particle track is advanced by free-flight distances until a collision or boundary crossing is encountered. A boundary crossing query reduces to ray-surface intersection in three-dimensional Euclidean geometry. Consider a particle with position $x_0 \\in \\mathbb{R}^3$ and direction $\\mathbf{u} \\in \\mathbb{R}^3$, where the track is parameterized by $x(s) = x_0 + s \\mathbf{u}$ for $s \\ge 0$. The algorithm must determine the nearest surface crossing along the track within a maximum flight distance $R_{\\max} > 0$, under the following valid geometry assumptions: a finite set of analytic surfaces from a catalog comprising planes, spheres, and right circular cylinders of finite extent along the axis, all with well-defined implicit equations. Continuous-energy Monte Carlo extends to geometries described by Constructive Solid Geometry (CSG), but for this problem the surfaces are given directly, and the task is restricted to computing the nearest crossing to any single surface in the list.\n\nYour task:\n\n1) Implement a boundary crossing algorithm that, given $x_0$, $\\mathbf{u}$, a finite list of surfaces, a numerical tolerance $\\epsilon > 0$, and a maximum flight distance $R_{\\max} > 0$, returns the identifier of the surface with the smallest valid positive intersection distance $s \\in (\\epsilon, R_{\\max}]$ and the corresponding distance $s$. If no surface intersects the ray in $(\\epsilon, R_{\\max}]$, return the pair `(-1, R_{\\max})`. All distances must be expressed in meters and rounded to six decimal places.\n\n2) Prove that, under the stated valid geometry assumptions, the algorithm terminates in a finite number of steps.\n\nMathematical and algorithmic requirements:\n\n- The particle direction $\\mathbf{u}$ should be treated as a general vector; normalization is permitted but not required. The algorithm must rely only on first principles of Euclidean geometry (e.g., dot products and norms) and analytic root finding for polynomials of degree at most two. The problem must be framed without shortcut formulas; derive the intersection conditions from $x(s) = x_0 + s \\mathbf{u}$ and the implicit surface definitions.\n\n- Surfaces:\n  - Plane: specified by a point $p \\in \\mathbb{R}^3$ and a unit normal $n \\in \\mathbb{R}^3$ through the implicit equation $n \\cdot (x - p) = 0$.\n  - Sphere: specified by a center $c \\in \\mathbb{R}^3$ and radius $r > 0$ through the implicit equation $\\|x - c\\|^2 = r^2$.\n  - Cylinder (finite along the axis): right circular cylinder aligned with the $z$-axis, specified by radius $r > 0$, axial bounds $z_{\\min}  z_{\\max}$, and the side surface implicit equation $x_x^2 + x_y^2 = r^2$ together with the axial constraint $z_{\\min} \\le x_z \\le z_{\\max}$.\n\n- The algorithm must discard intersections with $s \\le \\epsilon$ to avoid self-intersections when starting on a boundary, and discard intersections with $s > R_{\\max}$. For the cylinder side surface, an intersection is valid only if the hit point’s $z$-coordinate lies in $[z_{\\min}, z_{\\max}]$.\n\n- Physical and numerical units: report distances in meters; angles, if any, should be treated in radians. Round each reported distance to six decimal places.\n\n- Final output format: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a two-element list `[id, d]` consisting of the integer identifier and the float distance in meters with six decimal places, e.g., `[[0,1.234567],[1,0.500000],[-1,10.000000]]`.\n\nTest suite:\n\nImplement the algorithm and evaluate it on the following test cases. In each case, $x_0$, $\\mathbf{u}$, $\\epsilon$, and $R_{\\max}$ are specified, and the surfaces are given as a list with identifiers.\n\n- Case $1$ (happy path inside a sphere): surfaces: a single sphere with identifier $0$, center `c = (0, 0, 0)`, radius `r = 2`. Ray: `x_0 = (0, 0, 1)`, `u = (0, 0, 1)`, `epsilon = 10e-9`, `R_max = 100`. The nearest crossing is expected at a finite $s$.\n\n- Case $2$ (boundary start on a plane): surfaces: two planes, identifiers $0$ and $1$. Plane $0$: point `p = (0, 0, 0)`, normal `n = (0, 0, 1)`. Plane $1$: point `p = (0, 0, 5)`, normal `n = (0, 0, 1)`. Ray: `x_0 = (0, 0, 0)`, `u = (0, 0, 1)`, `epsilon = 10e-9`, `R_max = 100`. The intersection with plane $0$ occurs at $s = 0$, which must be discarded; the next valid crossing is finite.\n\n- Case $3$ (parallel ray with no intersection within range): surfaces: a single plane with identifier $0$, point `p = (1, 0, 0)`, normal `n = (1, 0, 0)`. Ray: `x_0 = (0, 0, 0)`, `u = (0, 1, 0)`, `epsilon = 10e-9`, `R_max = 10`. The ray is parallel to the plane; no intersection should be found within $(\\epsilon, R_{\\max}]$.\n\n- Case $4$ (no intersection with a sphere): surfaces: a single sphere with identifier $0$, center `c = (0, 0, 0)`, radius `r = 1`. Ray: `x_0 = (0, 2, 0)`, `u = (1, 0, 0)`, `epsilon = 10e-9`, `R_max = 10`. The ray misses the sphere; no intersection should be found within $(\\epsilon, R_{\\max}]$.\n\n- Case $5$ (finite cylinder side hit): surfaces: a single finite cylinder side surface with identifier $0$, radius `r = 1`, axial bounds `z_min = 0`, `z_max = 3`. Ray: `x_0 = (0.5, 0, 1)`, `u = (1, 0, 0)`, `epsilon = 10e-9`, `R_max = 100`. The nearest valid crossing with the side surface occurs at a finite $s$ and must satisfy the axial constraint.\n\nYour implementation must produce a single line containing the list of `[id, d]` pairs for the five cases in the order given.",
            "solution": "The problem requires the development of a boundary crossing algorithm fundamental to continuous-energy Monte Carlo particle transport methods. The algorithm must determine the nearest intersection point between a particle's trajectory, modeled as a geometric ray, and a set of predefined analytic surfaces.\n\n**1. Algorithmic Framework and Problem Formulation**\n\nLet the particle's trajectory be a ray defined by the parametric equation $x(d) = x_0 + d\\mathbf{v}$, where $x_0 \\in \\mathbb{R}^3$ is the initial position, $\\mathbf{v} \\in \\mathbb{R}^3$ is a unit direction vector ($\\|\\mathbf{v}\\| = 1$), and $d \\ge 0$ is the distance along the ray from $x_0$. The input direction vector $\\mathbf{u}$ is first normalized to obtain $\\mathbf{v} = \\mathbf{u} / \\|\\mathbf{u}\\|$, ensuring that the parameter $d$ represents the true physical distance in meters. This normalization is a permitted step that simplifies the subsequent geometric calculations.\n\nThe problem is to find the minimum valid intersection distance $d_{\\min}$ and the corresponding surface identifier $id_{\\min}$. A distance $d$ is considered valid if it satisfies $d \\in (\\epsilon, R_{\\max}]$, where $\\epsilon > 0$ is a small tolerance to avoid self-intersection at the starting point, and $R_{\\max} > 0$ is the maximum flight distance for the current transport step.\n\nThe algorithm proceeds as follows:\n1. Initialize the minimum distance found so far to the maximum allowed distance, $d_{\\min} \\leftarrow R_{\\max}$, and the corresponding surface identifier to a sentinel value, $id_{\\min} \\leftarrow -1$.\n2. For each surface in the provided finite list, calculate an ordered set of positive intersection distances $\\{d_i\\}$.\n3. For each calculated distance $d_i$, check for validity. An intersection is valid if $d_i \\in (\\epsilon, d_{\\min})$.\n4. If a valid intersection is found, update the state: $d_{\\min} \\leftarrow d_i$ and $id_{\\min} \\leftarrow$ current surface identifier. The search range for subsequent surfaces is now reduced to $(\\epsilon, d_{\\min})$.\n5. After iterating through all surfaces, the pair $(id_{\\min}, d_{\\min})$ is the result.\n\n**2. Derivation of Ray-Surface Intersection Distances**\n\nThe core of the algorithm is the analytic calculation of the intersection distance $d$ for each type of surface. This is achieved by substituting the ray equation into the implicit equation of the surface and solving for $d$.\n\n**2.1. Ray-Plane Intersection**\nA plane is defined by a point $p \\in \\mathbb{R}^3$ and a unit normal vector $n \\in \\mathbb{R}^3$. The implicit equation is $n \\cdot (x - p) = 0$.\nSubstituting the ray equation $x(d) = x_0 + d\\mathbf{v}$:\n$$n \\cdot ((x_0 + d\\mathbf{v}) - p) = 0$$\nExpanding the dot product:\n$$n \\cdot (x_0 - p) + d(n \\cdot \\mathbf{v}) = 0$$\nSolving for $d$:\n$$d = \\frac{n \\cdot (p - x_0)}{n \\cdot \\mathbf{v}}$$\nThis expression is defined only if the denominator $n \\cdot \\mathbf{v} \\neq 0$.\n- If $|n \\cdot \\mathbf{v}|$ is smaller than a numerical precision tolerance, the ray is considered parallel to the plane. In this case, no intersection occurs unless the ray lies within the plane (i.e., $n \\cdot (p - x_0) = 0$), which is not a discrete crossing event and is thus ignored for $d > 0$.\n- If $n \\cdot \\mathbf{v} \\neq 0$, a unique intersection distance $d$ is computed.\n\n**2.2. Ray-Sphere Intersection**\nA sphere is defined by a center $c \\in \\mathbb{R}^3$ and a radius $r > 0$. The implicit equation is $\\|x - c\\|^2 = r^2$.\nLet $\\Delta x_c = x_0 - c$. Substituting the ray equation $x(d) = x_0 + d\\mathbf{v} = c + \\Delta x_c + d\\mathbf{v}$:\n$$\\|(\\Delta x_c + d\\mathbf{v})\\|^2 - r^2 = 0$$\nExpanding the squared norm, which is a dot product with itself:\n$$(\\Delta x_c + d\\mathbf{v}) \\cdot (\\Delta x_c + d\\mathbf{v}) - r^2 = 0$$\n$$\\|\\Delta x_c\\|^2 + 2d(\\Delta x_c \\cdot \\mathbf{v}) + d^2\\|\\mathbf{v}\\|^2 - r^2 = 0$$\nSince $\\mathbf{v}$ is a unit vector, $\\|\\mathbf{v}\\|^2 = 1$. This yields a quadratic equation in $d$ of the form $ad^2 + bd + c_{Q} = 0$:\n$$d^2 + (2(\\Delta x_c \\cdot \\mathbf{v}))d + (\\|\\Delta x_c\\|^2 - r^2) = 0$$\nThe coefficients are: $a=1$, $b=2((x_0-c)\\cdot\\mathbf{v})$, and $c_{Q}=\\|x_0-c\\|^2 - r^2$.\nThe discriminant is $\\mathcal{D} = b^2 - 4ac_{Q}$.\n- If $\\mathcal{D}  0$, there are no real roots, and the ray misses the sphere.\n- If $\\mathcal{D} \\ge 0$, there are one or two real roots, given by the quadratic formula:\n$$d = \\frac{-b \\pm \\sqrt{\\mathcal{D}}}{2a} = -\\frac{b}{2} \\pm \\frac{\\sqrt{\\mathcal{D}}}{2}$$\nLet $b' = b/2 = (x_0-c)\\cdot\\mathbf{v}$ and $c' = c_{Q}$. The equation is $d^2+2b'd+c'=0$ and solutions are $d = -b' \\pm \\sqrt{b'^2-c'}$.\nThe two potential distances are $d_1 = -b' - \\sqrt{b'^2 - c'}$ and $d_2 = -b' + \\sqrt{b'^2 - c'}$. The smallest positive distance greater than $\\epsilon$ among these roots is chosen as the candidate intersection distance.\n\n**2.3. Ray-Cylinder Intersection**\nA right circular cylinder aligned with the $z$-axis is defined by a radius $r > 0$ and axial bounds $z_{\\min}, z_{\\max}$. The side surface has the implicit equation $x_x^2 + x_y^2 = r^2$ for $z_{\\min} \\le x_z \\le z_{\\max}$.\nThe components of the ray are $x_x(d) = x_{0x} + dv_x$ and $x_y(d) = x_{0y} + dv_y$. Substituting these into the side surface equation:\n$$(x_{0x} + dv_x)^2 + (x_{0y} + dv_y)^2 - r^2 = 0$$\nExpanding and collecting terms in powers of $d$:\n$$d^2(v_x^2 + v_y^2) + d(2(x_{0x}v_x + x_{0y}v_y)) + (x_{0x}^2 + x_{0y}^2 - r^2) = 0$$\nThis is a quadratic equation $ad^2 + bd + c_{Q} = 0$ with coefficients:\n- $a = v_x^2 + v_y^2$\n- $b = 2(x_{0x}v_x + x_{0y}v_y)$\n- $c_{Q} = x_{0x}^2 + x_{0y}^2 - r^2$\nThe roots $d_i$ are found using the quadratic formula, as for the sphere. If $a \\approx 0$ (i.e., the ray is nearly parallel to the $z$-axis), the equation degenerates to a linear one.\nFor each valid root $d_i > \\epsilon$, a further check is required. The $z$-coordinate of the intersection point, $z_{hit} = x_{0z} + d_i v_z$, must lie within the cylinder's axial bounds:\n$$z_{\\min} \\le z_{hit} \\le z_{\\max}$$\nOnly if this condition is met is the intersection distance $d_i$ considered valid. The smallest such $d_i$ is the candidate distance for this surface.\n\n**3. Proof of Termination**\nThe problem statement guarantees a finite set of surfaces. Let this number be $N$. The algorithm consists of a single loop that iterates $N$ times. Within each iteration, the work performed is constant with respect to the problem size (apart from $N$). For each surface type (plane, sphere, cylinder), the algorithm executes a fixed sequence of steps:\n- Vector operations (normalization, dot product, norm), which are constant-time operations for three-dimensional vectors.\n- Solving at most one polynomial equation of degree one or two. This also takes a constant number of arithmetic operations.\n- A fixed number of comparisons to validate the resulting distance(s).\n\nThe total number of operations is therefore proportional to $N$. Since $N$ is finite, the algorithm is guaranteed to execute in a finite number of steps and terminate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numerical tolerance for floating point comparisons, e.g., checking for parallelism.\nZERO_TOLERANCE = 1e-12\n\ndef _find_valid_roots(a, b, c, epsilon):\n    \"\"\"\n    Solves a quadratic equation ad^2 + bd + c = 0 and returns a list of \n    valid roots d  epsilon.\n    \"\"\"\n    roots = []\n    \n    if abs(a)  ZERO_TOLERANCE:\n        # Linear equation: bd + c = 0\n        if abs(b)  ZERO_TOLERANCE:\n            d = -c / b\n            if d  epsilon:\n                roots.append(d)\n    else:\n        # Quadratic equation\n        discriminant = b**2 - 4 * a * c\n        if discriminant = 0:\n            sqrt_disc = np.sqrt(discriminant)\n            d1 = (-b - sqrt_disc) / (2 * a)\n            d2 = (-b + sqrt_disc) / (2 * a)\n            \n            # Roots should be sorted to check the smallest positive one first\n            sorted_roots = sorted([d1, d2])\n            for d in sorted_roots:\n                if d  epsilon:\n                    roots.append(d)\n    return roots\n\ndef _intersect_plane(x0, v, p, n, epsilon):\n    \"\"\"Calculates intersection distance with a plane.\"\"\"\n    nv_dot = n.dot(v)\n    if abs(nv_dot)  ZERO_TOLERANCE:\n        return []  # Ray is parallel to the plane\n    \n    d = n.dot(p - x0) / nv_dot\n    if d  epsilon:\n        return [d]\n    return []\n\ndef _intersect_sphere(x0, v, c, r, epsilon):\n    \"\"\"Calculates intersection distance(s) with a sphere.\"\"\"\n    delta_x = x0 - c\n    \n    # Coefficients for ad^2 + bd + c = 0\n    # Since v is normalized, a = v.dot(v) = 1\n    a = 1.0\n    b = 2 * delta_x.dot(v)\n    c_q = delta_x.dot(delta_x) - r**2\n    \n    return _find_valid_roots(a, b, c_q, epsilon)\n\ndef _intersect_cylinder_side(x0, v, r, z_min, z_max, epsilon):\n    \"\"\"Calculates intersection distance(s) with a finite z-aligned cylinder side.\"\"\"\n    # Coefficients for ad^2 + bd + c = 0\n    a = v[0]**2 + v[1]**2\n    b = 2 * (x0[0]*v[0] + x0[1]*v[1])\n    c_q = x0[0]**2 + x0[1]**2 - r**2\n    \n    potential_distances = _find_valid_roots(a, b, c_q, epsilon)\n    \n    valid_distances = []\n    for d in potential_distances:\n        # Check if the hit point is within the axial bounds\n        z_hit = x0[2] + d * v[2]\n        if z_min = z_hit = z_max:\n            valid_distances.append(d)\n            \n    return valid_distances\n\ndef find_nearest_crossing(x0, u, surfaces, epsilon, R_max):\n    \"\"\"\n    Finds the nearest valid surface crossing for a particle track.\n\n    Args:\n        x0 (np.ndarray): Particle starting position.\n        u (np.ndarray): Particle direction vector (not necessarily normalized).\n        surfaces (list): A list of surface description dictionaries.\n        epsilon (float): Small positive distance to avoid self-intersection.\n        R_max (float): Maximum flight distance.\n\n    Returns:\n        tuple: (surface_id, distance) for the nearest crossing. \n               If no crossing, returns (-1, R_max).\n    \"\"\"\n    norm_u = np.linalg.norm(u)\n    if norm_u  ZERO_TOLERANCE:\n        return -1, R_max # No movement\n    v = u / norm_u\n\n    min_dist = R_max\n    min_id = -1\n\n    for surface in surfaces:\n        s_id = surface['id']\n        s_type = surface['type']\n        params = surface['params']\n        \n        distances = []\n        if s_type == 'plane':\n            distances = _intersect_plane(x0, v, params['p'], params['n'], epsilon)\n        elif s_type == 'sphere':\n            distances = _intersect_sphere(x0, v, params['c'], params['r'], epsilon)\n        elif s_type == 'cylinder_side':\n            distances = _intersect_cylinder_side(x0, v, params['r'], params['z_min'], params['z_max'], epsilon)\n        \n        for d in distances:\n            if d  min_dist:\n                min_dist = d\n                min_id = s_id\n    \n    return min_id, min_dist\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the boundary crossing algorithm.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path inside a sphere)\n        {\n            'x0': np.array([0.0, 0.0, 1.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 2.0}}\n            ]\n        },\n        # Case 2 (boundary start on a plane)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 0.0]), 'n': np.array([0.0, 0.0, 1.0])}},\n                {'id': 1, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 5.0]), 'n': np.array([0.0, 0.0, 1.0])}}\n            ]\n        },\n        # Case 3 (parallel ray with no intersection)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 1.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([1.0, 0.0, 0.0]), 'n': np.array([1.0, 0.0, 0.0])}}\n            ]\n        },\n        # Case 4 (no intersection with a sphere)\n        {\n            'x0': np.array([0.0, 2.0, 0.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 1.0}}\n            ]\n        },\n        # Case 5 (finite cylinder side hit)\n        {\n            'x0': np.array([0.5, 0.0, 1.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'cylinder_side', 'params': {'r': 1.0, 'z_min': 0.0, 'z_max': 3.0}}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res_id, res_dist = find_nearest_crossing(\n            case['x0'], case['u'], case['surfaces'], case['epsilon'], case['R_max']\n        )\n        results.append([res_id, res_dist])\n\n    results_str = [f\"[{item[0]},{item[1]:.6f}]\" for item in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A reliable simulation must be built on a foundation of verifiable physics, with conservation laws serving as the ultimate check on algorithmic correctness. This exercise challenges you to construct a complete, albeit simplified, transport simulation that tracks a neutron from source to termination. By meticulously accounting for all energy pathways—deposition through scattering and absorption versus leakage—you will verify that your code upholds the fundamental principle of energy conservation within statistical limits .",
            "id": "4218173",
            "problem": "Consider a homogeneous spherical region of radius $R$ with a vacuum boundary, containing a single fictitious nuclide that undergoes elastic scattering and absorption. A set of independent neutron histories is launched from the sphere center according to an isotropic point source with monoenergetic kinetic energy $E_0$ expressed in megaelectronvolts (MeV). The objective is to construct a continuous-energy Monte Carlo algorithm that verifies the energy accounting identity by direct simulation: the total deposited energy equals the total source energy minus the total leakage energy, within the statistical uncertainty of the Monte Carlo estimators.\n\nUse the following scientifically standard bases:\n- The linear Boltzmann transport equation energy balance in integral form implies that, for an isolated system with a vacuum boundary, kinetic energy introduced by the source is partitioned between energy deposited in the medium and energy carried out across the boundary.\n- In elastic scattering of a neutron off a stationary target nucleus of mass ratio $A$ (target mass divided by neutron mass), with scattering isotropic in the center-of-mass frame, the outgoing neutron energy $E'$ in the laboratory frame is given by\n$$\n\\frac{E'}{E} \\;=\\; \\frac{A^2 + 1 + 2 A \\mu_{\\text{cm}}}{(A+1)^2},\n$$\nwhere $E$ is the incoming energy and $\\mu_{\\text{cm}} = \\cos\\theta_{\\text{cm}}$ is the cosine of the scattering angle in the center-of-mass frame. The laboratory scattering angle $\\theta_{\\text{lab}}$ satisfies\n$$\n\\tan\\theta_{\\text{lab}} \\;=\\; \\frac{\\sin\\theta_{\\text{cm}}}{\\cos\\theta_{\\text{cm}} + 1/A},\n$$\nso that\n$$\n\\mu_{\\text{lab}} \\;=\\; \\cos\\theta_{\\text{lab}} \\;=\\; \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}.\n$$\n- In absorption, the neutron kinetic energy is deposited locally as heat. In elastic scattering, the energy deposited as material heating per collision equals the energy loss $E - E'$. With a vacuum boundary, any neutron that reaches the boundary leaks out carrying its current kinetic energy.\n\nLet the macroscopic cross sections be continuous-energy functions of $E$ with units in inverse centimeters ($\\text{cm}^{-1}$):\n- The scattering macroscopic cross section is $\\Sigma_s(E) = \\Sigma_{s0}$ (constant).\n- The absorption macroscopic cross section is $\\Sigma_a(E) = \\dfrac{\\Sigma_{a0}}{\\sqrt{E/\\text{MeV}}}$, representing a $1/v$-like behavior with energy measured in megaelectronvolts. The total macroscopic cross section is $\\Sigma_t(E) = \\Sigma_s(E) + \\Sigma_a(E)$.\nFree-flight distances to the next collision are sampled from the exponential distribution with mean $1/\\Sigma_t(E)$, i.e., $s = -\\ln u / \\Sigma_t(E)$ where $u$ is uniform on $(0,1)$.\n\nGeometry and kinematics:\n- The neutron starts at the origin with an isotropic direction. The distance to the spherical boundary along the current direction is the positive root of $t^2 + 2 (\\boldsymbol{r}\\cdot\\boldsymbol{u}) t + ( \\|\\boldsymbol{r}\\|^2 - R^2 ) = 0$, where $\\boldsymbol{r}$ is the current position and $\\boldsymbol{u}$ is the current unit direction vector.\n- If the sampled free-flight distance $s$ exceeds the boundary distance $d_{\\text{exit}}$, the neutron leaks and carries its current energy $E$ out of the system.\n- If a collision occurs before boundary crossing, it is absorption with probability $\\Sigma_a(E)/\\Sigma_t(E)$ and elastic scattering otherwise. In absorption, deposit $E$ and terminate the history. In elastic scattering, deposit $E - E'$ as heat, update the direction by rotating with polar cosine $\\mu_{\\text{lab}}$ and a uniform azimuth, set the energy to $E'$, and continue the history.\n\nTask:\n1. Implement a continuous-energy Monte Carlo simulation that tallies, for each history $i$, the source energy $S_i = E_0$, the total deposited energy $D_i$ (sum of $E - E'$ over elastic scattering events plus $E$ for absorption), and the leakage energy $L_i$ (the energy at boundary crossing). Define the per-history energy balance residual $B_i = S_i - D_i - L_i$ in MeV.\n2. For $N$ histories, estimate the sample mean $\\bar{B} = \\dfrac{1}{N}\\sum_{i=1}^N B_i$ and the sample standard deviation $s_B$ with the usual unbiased estimator. Using the Central Limit Theorem (CLT), verify the energy accounting identity by checking the inequality\n$$\n|\\bar{B}| \\;\\le\\; z \\,\\frac{s_B}{\\sqrt{N}},\n$$\nwith $z = 3$, i.e., within three standard errors. If $s_B = 0$, treat $|\\bar{B}| \\le \\varepsilon$ with a small numerical tolerance $\\varepsilon$ as verification.\n3. Report, for each specified test case, a boolean result indicating whether the identity is verified within statistical uncertainty.\n\nUnits:\n- Energies must be handled and tallied in megaelectronvolts (MeV).\n- Distances are in centimeters ($\\text{cm}$).\n- Cross sections are in inverse centimeters ($\\text{cm}^{-1}$).\n- Angles must be sampled and manipulated in radians.\n\nTest Suite:\nProvide results for the following parameter sets, each acting as an independent test case:\n- Case A (general mixed interactions): $N = 8000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.20\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.05\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$.\n- Case B (pure absorption medium): $N = 10000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.00\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.10\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$.\n- Case C (pure scattering hydrogen, small sphere): $N = 10000$, $R = 10\\,\\text{cm}$, $\\Sigma_{s0} = 0.10\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$.\n- Case D (near vacuum, large sphere): $N = 10000$, $R = 100\\,\\text{cm}$, $\\Sigma_{s0} = 0.005\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), where each result is a boolean indicating whether the energy accounting identity is verified within three standard errors for the corresponding test case.",
            "solution": "The problem requires the construction of a continuous-energy Monte Carlo neutron transport simulation to verify the energy conservation identity within a finite spherical medium. The identity states that the total energy introduced by a source must equal the sum of the energy deposited within the medium and the energy that leaks out of the system. The verification is to be performed by checking that the mean of the per-history energy balance residual is statistically indistinguishable from zero.\n\nThe solution is founded on the principle of energy conservation as applied to the linear Boltzmann transport equation for neutral particles. For a steady-state system with a source $S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega})$, the energy balance can be expressed as:\n$$\n\\int_V d\\boldsymbol{r} \\int_{4\\pi} d\\boldsymbol{\\Omega} \\int_0^\\infty dE \\, E \\, S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega}) \\;=\\; \\int_V d\\boldsymbol{r} \\int_0^\\infty dE \\, E_{\\text{dep}}(\\boldsymbol{r}, E) + \\int_{\\partial V} d\\boldsymbol{s} \\int_0^\\infty dE \\, E \\, (\\boldsymbol{n} \\cdot \\boldsymbol{\\Omega}) \\, \\Psi(\\boldsymbol{r}_s, E, \\boldsymbol{\\Omega})\n$$\nwhere the left side is the total source energy, the first term on the right is the total deposited energy, and the second term is the total leakage energy across the surface $\\partial V$. The Monte Carlo method provides a means to estimate these integral quantities by simulating a large number of individual particle histories. The problem states that the per-history balance $S_i - D_i - L_i$ must be tallied, where $S_i$ is the source energy, $D_i$ is the total energy deposited, and $L_i$ is the leakage energy for history $i$. By construction, for an analog simulation with perfect arithmetic, this residual $B_i = S_i - D_i - L_i$ is identically zero for every history. The task thus becomes a code verification problem, testing if the implementation correctly conserves energy at each step, such that the computed residuals are zero within floating-point precision.\n\nThe algorithm proceeds by simulating $N$ independent neutron histories. Each history traces a single neutron from its emission at the source to its termination by absorption or leakage.\n\n1.  **Source Particle Initialization**: Each neutron history $i$ begins with a particle at the center of the sphere, $\\boldsymbol{r} = (0,0,0)$. The source energy is fixed at $S_i = E_0$. The initial direction of travel, a unit vector $\\boldsymbol{u}$, is sampled from an isotropic distribution. This is achieved by sampling the polar angle cosine $\\mu_z = \\cos\\theta$ uniformly from $[-1, 1]$ and the azimuthal angle $\\phi$ uniformly from $[0, 2\\pi]$, then constructing the direction vector $\\boldsymbol{u} = (\\sqrt{1-\\mu_z^2}\\cos\\phi, \\sqrt{1-\\mu_z^2}\\sin\\phi, \\mu_z)$. For each history, the tallies for deposited energy $D_i$ and leakage energy $L_i$ are initialized to $0$.\n\n2.  **Neutron Transport Loop**: The core of the simulation is a loop that advances the neutron from one event to the next. In each step of the loop, the neutron is at position $\\boldsymbol{r}$ with energy $E$ and direction $\\boldsymbol{u}$.\n    -   **Cross Section Evaluation**: The macroscopic total cross section $\\Sigma_t(E)$ is computed as the sum of the scattering cross section, $\\Sigma_s(E) = \\Sigma_{s0}$, and the absorption cross section, $\\Sigma_a(E) = \\Sigma_{a0}/\\sqrt{E}$.\n    -   **Distance to Collision**: The path length $s$ to the next potential collision is sampled from an exponential probability distribution with mean free path $1/\\Sigma_t(E)$. This is done by sampling a uniform random number $\\xi_1 \\in (0,1)$ and calculating $s = -\\ln(\\xi_1) / \\Sigma_t(E)$. If $\\Sigma_t(E) = 0$, the path length is infinite.\n    -   **Distance to Boundary**: The distance $d_{\\text{exit}}$ from the current position $\\boldsymbol{r}$ to the spherical boundary of radius $R$ along the current direction $\\boldsymbol{u}$ is determined. This is the positive root of the quadratic equation $t^2 + 2(\\boldsymbol{r}\\cdot\\boldsymbol{u})t + (\\|\\boldsymbol{r}\\|^2 - R^2) = 0$, which is $d_{\\text{exit}} = -(\\boldsymbol{r}\\cdot\\boldsymbol{u}) + \\sqrt{(\\boldsymbol{r}\\cdot\\boldsymbol{u})^2 - (\\|\\boldsymbol{r}\\|^2 - R^2)}$.\n    -   **Event Determination**: The sampled distance to collision $s$ is compared with the distance to the boundary $d_{\\text{exit}}$.\n        -   If $s \\ge d_{\\text{exit}}$, the neutron reaches the boundary without colliding. It leaks from the system. The leakage energy for the history is set to the neutron's current energy, $L_i = E$, and the history is terminated.\n        -   If $s  d_{\\text{exit}}$, the neutron travels a distance $s$ and undergoes a collision. The particle's position is updated to $\\boldsymbol{r}' = \\boldsymbol{r} + s\\boldsymbol{u}$.\n\n3.  **Collision Physics**: If a collision occurs, its type is determined probabilistically.\n    -   A random number $\\xi_2 \\in (0,1)$ is sampled.\n    -   If $\\xi_2  \\Sigma_a(E) / \\Sigma_t(E)$, the collision is an **absorption**. The neutron's entire kinetic energy $E$ is deposited in the material. The deposited energy tally is updated, $D_i \\leftarrow D_i + E$, and the history is terminated.\n    -   Otherwise, the collision is **elastic scattering**. The neutron loses some energy and changes direction.\n        -   **Energy kinematics**: The outgoing energy $E'$ is determined by the scattering kinematics. For isotropic scattering in the center-of-mass (CM) frame, the cosine of the CM scattering angle, $\\mu_{\\text{cm}}$, is sampled uniformly from $[-1, 1]$. The new energy in the laboratory frame is $E' = E \\frac{A^2 + 1 + 2A\\mu_{\\text{cm}}}{(A+1)^2}$.\n        -   **Energy Deposition**: The energy lost by the neutron is deposited as heat. The tally is updated: $D_i \\leftarrow D_i + (E - E')$. The neutron's energy is then updated to $E'$.\n        -   **Direction Kinematics**: The neutron's direction vector $\\boldsymbol{u}$ is updated. The cosine of the laboratory scattering angle is $\\mu_{\\text{lab}} = \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}$. A random azimuthal scattering angle $\\phi_{\\text{azimuth}} \\in [0, 2\\pi]$ is sampled. The old direction vector $\\boldsymbol{u}$ is rotated by the polar angle $\\theta_{\\text{lab}} = \\arccos(\\mu_{\\text{lab}})$ and azimuthal angle $\\phi_{\\text{azimuth}}$ to obtain the new direction $\\boldsymbol{u}'$. The neutron's direction is updated to $\\boldsymbol{u}'$.\n        -   The transport loop then continues from step 2 with the updated particle state ($\\boldsymbol{r}', E', \\boldsymbol{u}'$).\n\n4.  **Tallying and Statistical Analysis**: After each history $i$ terminates, the energy balance residual is calculated: $B_i = S_i - D_i - L_i$. Due to the manner of tallying, where every change in kinetic energy is accounted for as either deposited or eventually leaked, this value should be numerically very close to zero.\n    After all $N$ histories are completed, the sample of residuals $\\{B_1, B_2, \\dots, B_N\\}$ is analyzed. The sample mean $\\bar{B} = \\frac{1}{N}\\sum_{i=1}^N B_i$ and the unbiased sample standard deviation $s_B = \\sqrt{\\frac{1}{N-1}\\sum_{i=1}^N (B_i - \\bar{B})^2}$ are computed.\n    The energy accounting identity is considered verified if the mean residual is consistent with zero within three standard errors of the mean, i.e., $|\\bar{B}| \\le 3 \\frac{s_B}{\\sqrt{N}}$.\n    In the special case where numerical errors are so small that the computed $s_B$ is zero, the verification is performed by checking if $|\\bar{B}|$ is smaller than a small tolerance $\\varepsilon$, for example, $\\varepsilon = 10^{-12}$. This confirms that the implementation maintains energy conservation to within floating-point precision. This process is repeated for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotate_direction(direction_vec, mu_lab, phi_azimuth):\n    \"\"\"\n    Rotates a direction vector by a polar angle (specified by its cosine mu_lab)\n    and an azimuthal angle phi_azimuth.\n    Uses the MCNP standard rotation formula.\n    \"\"\"\n    u, v, w = direction_vec\n    sin_theta_lab = np.sqrt(1.0 - mu_lab**2)\n    cos_phi = np.cos(phi_azimuth)\n    sin_phi = np.sin(phi_azimuth)\n\n    # Handle the case where the initial direction is nearly aligned with the z-axis\n    # to avoid division by zero in the standard formula.\n    if np.abs(w)  1.0 - 1e-9:\n        u_prime = sin_theta_lab * cos_phi\n        v_prime = sin_theta_lab * sin_phi\n        w_prime = mu_lab * np.sign(w)\n    else:\n        # Standard rotation formula\n        temp = np.sqrt(1.0 - w**2)\n        u_prime = u * mu_lab + (sin_theta_lab / temp) * (u * w * cos_phi - v * sin_phi)\n        v_prime = v * mu_lab + (sin_theta_lab / temp) * (v * w * cos_phi + u * sin_phi)\n        w_prime = w * mu_lab - sin_theta_lab * temp * cos_phi\n\n    return np.array([u_prime, v_prime, w_prime], dtype=np.float64)\n\ndef simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng):\n    \"\"\"\n    Simulates a single neutron history from source to termination.\n    Returns the energy balance residual for the history.\n    \"\"\"\n    # Particle state variables\n    pos = np.zeros(3, dtype=np.float64)\n    energy = np.float64(E0)\n\n    # Sample isotropic source direction\n    mu_z = 2.0 * rng.random() - 1.0\n    phi = 2.0 * np.pi * rng.random()\n    sin_theta = np.sqrt(1.0 - mu_z**2)\n    direction = np.array([sin_theta * np.cos(phi),\n                          sin_theta * np.sin(phi),\n                          mu_z], dtype=np.float64)\n\n    # History tallies\n    deposited_energy = np.float64(0.0)\n    leakage_energy = np.float64(0.0)\n\n    while True:\n        # Check for particle termination by energy threshold (unlikely here)\n        if energy = 0.0:\n            break\n\n        # Macroscopic cross sections\n        sigma_s = np.float64(Sigma_s0)\n        sigma_a = np.float64(Sigma_a0 / np.sqrt(energy)) if energy  0 else np.inf\n        sigma_t = sigma_s + sigma_a\n\n        # Sample distance to collision\n        if sigma_t == 0.0:\n            dist_to_collision = np.inf\n        else:\n            dist_to_collision = -np.log(rng.random()) / sigma_t\n\n        # Calculate distance to sphere boundary\n        r_dot_u = np.dot(pos, direction)\n        r_sq = np.dot(pos, pos)\n        discriminant = r_dot_u**2 - (r_sq - R**2)\n        dist_to_boundary = -r_dot_u + np.sqrt(discriminant)\n        \n        # Determine event: leakage or collision\n        if dist_to_collision = dist_to_boundary:\n            leakage_energy = energy\n            break  # History terminates\n        else:\n            # Move particle to collision site\n            pos += dist_to_collision * direction\n\n            # Determine collision type: absorption or scattering\n            prob_absorption = sigma_a / sigma_t\n            if rng.random()  prob_absorption:\n                deposited_energy += energy\n                break  # History terminates\n            else:\n                # Elastic scattering\n                # Sample CM scattering cosine\n                mu_cm = 2.0 * rng.random() - 1.0\n\n                # Calculate new energy\n                a_plus_1_sq = (A + 1.0)**2\n                energy_prime = energy * (A**2 + 1.0 + 2.0 * A * mu_cm) / a_plus_1_sq\n\n                # Deposit energy loss\n                deposited_energy += (energy - energy_prime)\n\n                # Update particle energy\n                energy = energy_prime\n\n                # Update particle direction\n                mu_lab_num = mu_cm + 1.0 / A\n                mu_lab_den = np.sqrt(1.0 + 2.0 * mu_cm / A + 1.0 / A**2)\n                mu_lab = mu_lab_num / mu_lab_den\n                \n                phi_scatter = 2.0 * np.pi * rng.random()\n                direction = rotate_direction(direction, mu_lab, phi_scatter)\n\n    # Calculate and return the energy balance residual\n    residual = E0 - deposited_energy - leakage_energy\n    return residual\n\ndef run_simulation(N, R, Sigma_s0, Sigma_a0, A, E0):\n    \"\"\"\n    Runs N histories for a given problem configuration and verifies the energy balance.\n    \"\"\"\n    rng = np.random.default_rng(seed=12345)\n    residuals = np.zeros(N, dtype=np.float64)\n\n    for i in range(N):\n        residuals[i] = simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng)\n    \n    mean_B = np.mean(residuals)\n    std_B = np.std(residuals, ddof=1)\n\n    if std_B == 0.0:\n        # If std dev is numerically zero, all residuals are identical.\n        # Check if the mean (and thus all residuals) is near zero.\n        epsilon = 1e-12 \n        return np.abs(mean_B) = epsilon\n    else:\n        # Standard statistical check\n        z = 3.0\n        standard_error = std_B / np.sqrt(N)\n        return np.abs(mean_B) = z * standard_error\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'N': 8000, 'R': 50.0, 'Sigma_s0': 0.20, 'Sigma_a0': 0.05, 'A': 12.0, 'E0': 2.0},\n        # Case B\n        {'N': 10000, 'R': 50.0, 'Sigma_s0': 0.00, 'Sigma_a0': 0.10, 'A': 12.0, 'E0': 2.0},\n        # Case C\n        {'N': 10000, 'R': 10.0, 'Sigma_s0': 0.10, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n        # Case D\n        {'N': 10000, 'R': 100.0, 'Sigma_s0': 0.005, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        is_verified = run_simulation(**case_params)\n        # The output format requires Python's True/False to be converted to lowercase.\n        results.append(str(is_verified).lower())\n    \n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "The power of continuous-energy Monte Carlo lies in its ability to capture the detailed physics of neutron interactions, particularly in the resonance energy regions. Simply using average cross sections can lead to significant errors by failing to account for the phenomenon of self-shielding, where high resonance peaks depress the local neutron flux. This practice demonstrates the quantitative difference between using simplified average cross sections and a more accurate probability-table method, revealing the crucial role of detailed data representation in achieving accurate reaction rate estimates .",
            "id": "4218148",
            "problem": "Construct a self-contained program that quantifies the bias introduced by replacing probability-table sampling of unresolved resonance cross sections with average cross sections in estimating fuel absorption reaction rate density in a homogenized pin-cell model. Derive the estimation logic from first principles of neutron transport and Monte Carlo (MC) simulation and implement both methods under a common, physically plausible model.\n\nAssume a homogenized, infinite-medium approximation of a pin-cell fuel region in the unresolved resonance region, where the scalar flux at energy $E$ is modeled by the balance of a uniform, isotropic volumetric source and removal by the total macroscopic cross section. Specifically, assume the scalar flux is given by $\\phi(E) = S(E) / \\Sigma_{t}(E)$, where $S(E)$ is the source strength per unit energy per unit volume and $\\Sigma_{t}(E)$ is the total macroscopic cross section. The fuel absorption reaction rate density is defined by the fundamental relation $R_{a} = \\int \\phi(E) \\, \\Sigma_{a,f}(E) \\, dE$, where $\\Sigma_{a,f}(E)$ is the fuel absorption macroscopic cross section. Express all reaction rate densities in $\\text{s}^{-1}\\text{cm}^{-3}$ and energies in electronvolts (eV). Angles do not appear in this problem.\n\nModel the source spectrum over an energy interval $[E_{\\min}, E_{\\max}]$ in the unresolved region by a normalized slowing-down spectrum $f(E)$ proportional to $1/E$, i.e., $f(E) = C / E$ with $C$ chosen such that $\\int_{E_{\\min}}^{E_{\\max}} f(E) \\, dE = 1$. Let the volumetric source be $S(E) = Q \\, f(E)$, where $Q$ is the total source rate density in $\\text{s}^{-1}\\text{cm}^{-3}$.\n\nModel the fuel macroscopic cross section in the unresolved region as follows. The energy-dependent average fuel total macroscopic cross section is $\\overline{\\Sigma}_{f}(E) = B + A E^{-\\alpha}$, with $A > 0$, $\\alpha > 0$, and $B \\ge 0$. The fuel absorption is a fixed fraction of the fuel total cross section: $\\Sigma_{a,f}(E) = p_{a} \\, \\Sigma_{f}(E)$, with $0  p_{a}  1$. The total macroscopic cross section for removal is $\\Sigma_{t}(E) = \\Sigma_{b} + \\Sigma_{f}(E)$, where $\\Sigma_{b}$ is an energy-independent background macroscopic cross section accounting for moderator and structural materials. In the probability-table approach, unresolved resonance fluctuations are represented by a distribution for $\\Sigma_{f}(E)$ at each energy with mean $\\overline{\\Sigma}_{f}(E)$ and coefficient of variation depending on $\\Sigma_{b}$. Use a lognormal distribution for $\\Sigma_{f}(E)$ with mean $\\overline{\\Sigma}_{f}(E)$ and coefficient of variation\n$$\n\\mathrm{cv}_{b} = \\frac{\\mathrm{cv}_{0}}{\\sqrt{1 + \\Sigma_{b} / \\Sigma_{\\mathrm{ref}}}},\n$$\nwhere $\\mathrm{cv}_{0} > 0$ and $\\Sigma_{\\mathrm{ref}} > 0$ are constants. For a lognormal distribution with mean $m$ and coefficient of variation $c$, the logarithmic parameters are $\\sigma^{2} = \\ln(1 + c^{2})$ and $\\mu = \\ln(m) - \\frac{1}{2}\\sigma^{2}$. In the average-cross-section approach, set $\\Sigma_{f}(E) = \\overline{\\Sigma}_{f}(E)$ deterministically.\n\nUnder these assumptions:\n- The probability-table estimate of the reaction rate density is the expectation\n$$\nR_{a}^{\\mathrm{PT}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\mathbb{E}_{\\Sigma_{f} \\sim \\mathrm{LogNormal}(\\mu(E),\\sigma^{2}(E))} \\left( \\frac{p_{a} \\, \\Sigma_{f}}{\\Sigma_{b} + \\Sigma_{f}} \\right) \\right].\n$$\n- The average-cross-section estimate is\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} \\right].\n$$\n\nDefine the relative bias as a decimal (not as a percentage sign) by\n$$\n\\delta = \\frac{R_{a}^{\\mathrm{AVG}} - R_{a}^{\\mathrm{PT}}}{R_{a}^{\\mathrm{PT}}}.\n$$\n\nYour program must:\n- Implement a Monte Carlo estimator for $R_{a}^{\\mathrm{PT}}$ using $N$ samples by drawing energies $E$ from $f(E)$ and drawing $\\Sigma_{f}$ from the corresponding lognormal distribution, then averaging the quantity $p_{a} \\, \\Sigma_{f} / (\\Sigma_{b} + \\Sigma_{f})$, multiplied by $Q$.\n- Implement a numerical integral for $R_{a}^{\\mathrm{AVG}}$ over $[E_{\\min}, E_{\\max}]$ using a suitable quadrature with the integrand $f(E) \\, p_{a} \\, \\overline{\\Sigma}_{f}(E) / (\\Sigma_{b} + \\overline{\\Sigma}_{f}(E))$, multiplied by $Q$.\n- Compute and return the relative bias $\\delta$ for each test case.\n\nUse the following test suite, which exercises typical, high-background, and low-background regimes:\n1. Happy path case: $E_{\\min} = 10 \\,\\mathrm{eV}$, $E_{\\max} = 1000 \\,\\mathrm{eV}$, $Q = 10^{6} \\,\\mathrm{s}^{-1}\\mathrm{cm}^{-3}$, $A = 0.6 \\,\\mathrm{cm}^{-1} \\,\\mathrm{eV}^{\\alpha}$, $\\alpha = 0.5$, $B = 0.1 \\,\\mathrm{cm}^{-1}$, $\\Sigma_{b} = 0.5 \\,\\mathrm{cm}^{-1}$, $p_{a} = 0.3$, $\\mathrm{cv}_{0} = 0.8$, $\\Sigma_{\\mathrm{ref}} = 1.0 \\,\\mathrm{cm}^{-1}$, $N = 200000$, seed $= 12345$.\n2. High background case: same as case $1$ except $\\Sigma_{b} = 5.0 \\,\\mathrm{cm}^{-1}$, seed $= 23456$.\n3. Low background case: same as case $1$ except $\\Sigma_{b} = 0.05 \\,\\mathrm{cm}^{-1}$, seed $= 34567$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3]`), where each result is the relative bias $\\delta$ for the corresponding test case, expressed as a float. No additional text should be printed.",
            "solution": "The objective is to quantify the relative bias $\\delta$ introduced when unresolved resonance cross sections, represented by a probability table, are replaced by their average values in the calculation of a fuel absorption reaction rate. The relative bias is defined as $\\delta = (R_{a}^{\\mathrm{AVG}} - R_{a}^{\\mathrm{PT}}) / R_{a}^{\\mathrm{PT}}$, where $R_{a}^{\\mathrm{AVG}}$ is the reaction rate density calculated using average cross sections and $R_{a}^{\\mathrm{PT}}$ is the rate calculated using the probability-table method.\n\nFirst, we establish the procedure for calculating the average-cross-section reaction rate, $R_{a}^{\\mathrm{AVG}}$. The problem defines this quantity as an expectation over the source energy spectrum $f(E)$:\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} \\right]\n$$\nBy definition of expectation, this can be written as a definite integral over the energy range $[E_{\\min}, E_{\\max}]$:\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\int_{E_{\\min}}^{E_{\\max}} \\frac{p_{a} \\, \\overline{\\Sigma}_{f}(E)}{\\Sigma_{b} + \\overline{\\Sigma}_{f}(E)} f(E) \\, dE\n$$\nSubstituting the given functional forms for the source spectrum, $f(E) = C/E$ (where $C = 1/\\ln(E_{\\max}/E_{\\min})$ is the normalization constant), and the average fuel cross section, $\\overline{\\Sigma}_{f}(E) = B + A E^{-\\alpha}$, we obtain the integral to be computed:\n$$\nR_{a}^{\\mathrm{AVG}} = Q \\int_{E_{\\min}}^{E_{\\max}} \\left[ \\frac{p_{a} (B + A E^{-\\alpha})}{\\Sigma_{b} + B + A E^{-\\alpha}} \\right] \\frac{C}{E} \\, dE\n$$\nThis integral does not have a straightforward analytical solution and is therefore evaluated using numerical quadrature. The implementation will use a high-precision adaptive quadrature method from the `scipy.integrate` library.\n\nNext, we devise the method for estimating the probability-table reaction rate, $R_{a}^{\\mathrm{PT}}$. This quantity is defined by a nested expectation:\n$$\nR_{a}^{\\mathrm{PT}} = Q \\, \\mathbb{E}_{E \\sim f}\\left[ \\mathbb{E}_{\\Sigma_{f} \\sim \\mathrm{LogNormal}(\\mu(E),\\sigma^{2}(E))} \\left( \\frac{p_{a} \\, \\Sigma_{f}}{\\Sigma_{b} + \\Sigma_{f}} \\right) \\right]\n$$\nThis structure is ideally suited for evaluation by a Monte Carlo method. The Law of Total Expectation allows us to estimate the nested expectation by sampling from the joint probability distribution of energy $E$ and fuel cross section $\\Sigma_{f}$. The estimation algorithm proceeds in $N$ trials, as follows:\n\n1.  For each trial $i \\in \\{1, ..., N\\}$, first sample an energy $E_i$ from the source distribution $f(E) \\propto 1/E$. This is achieved using the inverse transform sampling method. The cumulative distribution function (CDF) is $F(E) = \\int_{E_{\\min}}^{E} f(e) \\, de = \\frac{\\ln(E/E_{\\min})}{\\ln(E_{\\max}/E_{\\min})}$. Setting $F(E_i)$ equal to a uniform random variate $u_i \\sim U(0,1)$ and solving for $E_i$ yields the sampling formula:\n    $$\n    E_i = E_{\\min} \\left(\\frac{E_{\\max}}{E_{\\min}}\\right)^{u_i}\n    $$\n\n2.  For each sampled energy $E_i$, we determine the parameters of the lognormal distribution for the fuel cross section $\\Sigma_f$. The mean of the distribution is the energy-dependent average cross section, $m(E_i) = \\overline{\\Sigma}_{f}(E_i) = B + A E_i^{-\\alpha}$. The coefficient of variation, $c = \\mathrm{cv}_b$, is given as constant with respect to energy: $\\mathrm{cv}_{b} = \\mathrm{cv}_{0} / \\sqrt{1 + \\Sigma_{b} / \\Sigma_{\\mathrm{ref}}}$. The parameters of the underlying normal distribution, $\\mu(E_i)$ and $\\sigma^2$, are calculated using the standard formulas for a lognormal distribution:\n    $$\n    \\sigma^2 = \\ln(1 + c^2)\n    $$\n    $$\n    \\mu(E_i) = \\ln(m(E_i)) - \\frac{1}{2}\\sigma^2\n    $$\n\n3.  With the parameters for the distribution at energy $E_i$ fully defined, sample a value for the fuel cross section, $\\Sigma_{f,i}$, from the distribution $\\mathrm{LogNormal}(\\mu(E_i), \\sigma^2)$.\n\n4.  Using the sampled values $E_i$ and $\\Sigma_{f,i}$, compute the value of the quantity of interest for the $i$-th trial:\n    $$\n    v_i = \\frac{p_{a} \\, \\Sigma_{f,i}}{\\Sigma_{b} + \\Sigma_{f,i}}\n    $$\n\nThe Monte Carlo estimate of the total expectation is the sample mean of these values:\n$$\n\\mathbb{E}[\\dots] \\approx \\frac{1}{N} \\sum_{i=1}^{N} v_i\n$$\nFinally, the probability-table reaction rate is obtained by multiplying this estimate by the total source rate density $Q$:\n$$\nR_{a}^{\\mathrm{PT}} \\approx Q \\left(\\frac{1}{N} \\sum_{i=1}^{N} v_i\\right)\n$$\n\nThe program implements these two distinct computational paths. For each test case, it calculates $R_{a}^{\\mathrm{AVG}}$ via numerical quadrature and estimates $R_{a}^{\\mathrm{PT}}$ via the described Monte Carlo algorithm, using the specified number of samples $N$ and random seed for reproducibility. The relative bias $\\delta$ is then computed and reported. This physically grounded, first-principles approach correctly quantifies the self-shielding effect, where flux depression within resonances (captured by the probability-table method) leads to a lower effective absorption rate compared to the simplified average-cross-section approach.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Happy path\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 0.5, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 12345},\n        # Case 2: High background\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 5.0, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 23456},\n        # Case 3: Low background\n        {'E_min': 10.0, 'E_max': 1000.0, 'Q': 1e6, 'A': 0.6, 'alpha': 0.5, 'B': 0.1,\n         'Sigma_b': 0.05, 'p_a': 0.3, 'cv_0': 0.8, 'Sigma_ref': 1.0, 'N': 200000, 'seed': 34567}\n    ]\n\n    results = []\n    for params in test_cases:\n        # Calculate the relative bias for each case.\n        result = calculate_bias(**params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_bias(E_min, E_max, Q, A, alpha, B, Sigma_b, p_a, cv_0, Sigma_ref, N, seed):\n    \"\"\"\n    Calculates the relative bias between average-cross-section and probability-table\n    methods for estimating fuel absorption reaction rate density.\n\n    Args:\n        E_min (float): Minimum energy in eV.\n        E_max (float): Maximum energy in eV.\n        Q (float): Total source rate density in s^-1 cm^-3.\n        A (float): Parameter for average fuel cross section.\n        alpha (float): Parameter for average fuel cross section.\n        B (float): Parameter for average fuel cross section.\n        Sigma_b (float): Background macroscopic cross section in cm^-1.\n        p_a (float): Absorption probability for fuel.\n        cv_0 (float): Base coefficient of variation.\n        Sigma_ref (float): Reference cross section for cv calculation in cm^-1.\n        N (int): Number of Monte Carlo samples.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: The relative bias delta.\n    \"\"\"\n    # Normalization constant for the 1/E source spectrum f(E)\n    C = 1.0 / np.log(E_max / E_min)\n\n    # --- 1. Calculation of R_a^AVG using numerical quadrature ---\n    \n    # Define the average fuel cross section as a function of energy\n    def avg_sigma_f(E):\n        return B + A * E**(-alpha)\n\n    # Define the integrand for the R_a^AVG calculation\n    def integrand_avg(E):\n        sigma_f_bar = avg_sigma_f(E)\n        # Integrand is f(E) * g(E), where g(E) is the quantity being averaged\n        quantity = (p_a * sigma_f_bar) / (Sigma_b + sigma_f_bar)\n        pdf = C / E\n        return quantity * pdf\n\n    # Numerically integrate over the energy range\n    integral_avg, _ = quad(integrand_avg, E_min, E_max)\n    R_a_AVG = Q * integral_avg\n\n    # --- 2. Calculation of R_a^PT using Monte Carlo simulation ---\n\n    # Initialize a random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Step 2a: Sample N energies from the f(E) = C/E distribution\n    # Using inverse transform sampling: E = E_min * (E_max / E_min)^u, where u ~ U(0,1)\n    u_samples = rng.uniform(0.0, 1.0, size=N)\n    E_samples = E_min * (E_max / E_min)**u_samples\n\n    # Step 2b: Determine parameters for the lognormal distribution of Sigma_f\n    # Coefficient of variation for Sigma_f, constant over energy for a given case\n    cv_b = cv_0 / np.sqrt(1 + Sigma_b / Sigma_ref)\n    \n    # Variance of the underlying normal distribution, also constant\n    lognormal_sigma_sq = np.log(1 + cv_b**2)\n    lognormal_sigma = np.sqrt(lognormal_sigma_sq)\n\n    # Mean of Sigma_f at each sampled energy\n    mean_sigma_f_samples = avg_sigma_f(E_samples)\n    \n    # Mean (mu) of the underlying normal distribution at each sampled energy\n    lognormal_mu_samples = np.log(mean_sigma_f_samples) - 0.5 * lognormal_sigma_sq\n\n    # Step 2c: Sample Sigma_f from LogNormal(mu(E), sigma^2)\n    # numpy's lognormal takes mu and sigma (std dev of underlying normal)\n    sigma_f_samples = rng.lognormal(mean=lognormal_mu_samples, sigma=lognormal_sigma, size=N)\n\n    # Step 2d: Calculate the quantity of interest for each sample\n    quantity_pt_samples = (p_a * sigma_f_samples) / (Sigma_b + sigma_f_samples)\n\n    # Estimate the expectation by averaging over all samples\n    expectation_pt = np.mean(quantity_pt_samples)\n    \n    # Calculate the total reaction rate for the probability-table method\n    R_a_PT = Q * expectation_pt\n    \n    # --- 3. Calculation of Relative Bias ---\n    if R_a_PT == 0:\n        # Avoid division by zero, though physically R_a_PT should be positive\n        return np.inf if R_a_AVG  R_a_PT else 0.0\n\n    delta = (R_a_AVG - R_a_PT) / R_a_PT\n    \n    return delta\n\nsolve()\n```"
        }
    ]
}