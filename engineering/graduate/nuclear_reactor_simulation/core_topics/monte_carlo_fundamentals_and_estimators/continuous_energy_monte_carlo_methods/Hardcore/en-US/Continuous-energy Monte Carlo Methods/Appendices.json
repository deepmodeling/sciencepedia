{
    "hands_on_practices": [
        {
            "introduction": "Before a particle can undergo complex nuclear interactions, it must first navigate the problem's geometric space. This fundamental exercise challenges you to implement a boundary crossing algorithm, a cornerstone of any particle transport code. By calculating the distance to the nearest surface for various analytical shapes, you will build the core ray-tracing engine that determines where and when a particle's journey is interrupted by either a boundary or a collision. ",
            "id": "4218147",
            "problem": "In continuous-energy Monte Carlo (MC) neutron transport, a particle track is advanced by free-flight distances until a collision or boundary crossing is encountered. A boundary crossing query reduces to ray-surface intersection in three-dimensional Euclidean geometry. Consider a particle with position $x_0 \\in \\mathbb{R}^3$ and direction $\\mathbf{u} \\in \\mathbb{R}^3$, where the track is parameterized by $x(s) = x_0 + s \\mathbf{u}$ for $s \\ge 0$. The algorithm must determine the nearest surface crossing along the track within a maximum flight distance $R_{\\max}  0$, under the following valid geometry assumptions: a finite set of analytic surfaces from a catalog comprising planes, spheres, and right circular cylinders of finite extent along the axis, all with well-defined implicit equations. Continuous-energy Monte Carlo extends to geometries described by Constructive Solid Geometry (CSG), but for this problem the surfaces are given directly, and the task is restricted to computing the nearest crossing to any single surface in the list.\n\nYour task:\n\n1) Implement a boundary crossing algorithm that, given $x_0$, $\\mathbf{u}$, a finite list of surfaces, a numerical tolerance $\\epsilon  0$, and a maximum flight distance $R_{\\max}  0$, returns the identifier of the surface with the smallest valid positive intersection distance $s \\in (\\epsilon, R_{\\max}]$ and the corresponding distance $s$. If no surface intersects the ray in $(\\epsilon, R_{\\max}]$, return the pair $(-1, R_{\\max})$. All distances must be expressed in meters and rounded to six decimal places.\n\n2) Prove that, under the stated valid geometry assumptions, the algorithm terminates in a finite number of steps.\n\nMathematical and algorithmic requirements:\n\n- The particle direction $\\mathbf{u}$ should be treated as a general vector; normalization is permitted but not required. The algorithm must rely only on first principles of Euclidean geometry (e.g., dot products and norms) and analytic root finding for polynomials of degree at most two. The problem must be framed without shortcut formulas; derive the intersection conditions from $x(s) = x_0 + s \\mathbf{u}$ and the implicit surface definitions.\n\n- Surfaces:\n  - Plane: specified by a point $p \\in \\mathbb{R}^3$ and a unit normal $n \\in \\mathbb{R}^3$ through the implicit equation $n \\cdot (x - p) = 0$.\n  - Sphere: specified by a center $c \\in \\mathbb{R}^3$ and radius $r  0$ through the implicit equation $\\|x - c\\|^2 = r^2$.\n  - Cylinder (finite along the axis): right circular cylinder aligned with the $z$-axis, specified by radius $r  0$, axial bounds $z_{\\min}  z_{\\max}$, and the side surface implicit equation $x_x^2 + x_y^2 = r^2$ together with the axial constraint $z_{\\min} \\le x_z \\le z_{\\max}$.\n\n- The algorithm must discard intersections with $s \\le \\epsilon$ to avoid self-intersections when starting on a boundary, and discard intersections with $s  R_{\\max}$. For the cylinder side surface, an intersection is valid only if the hit pointâ€™s $z$-coordinate lies in $[z_{\\min}, z_{\\max}]$.\n\n- Physical and numerical units: report distances in meters; angles, if any, should be treated in radians. Round each reported distance to six decimal places.\n\n- Final output format: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a two-element list $[id, d]$ consisting of the integer identifier and the float distance in meters with six decimal places, e.g., $[[0,1.234567],[1,0.500000],[-1,10.000000]]$.\n\nTest suite:\n\nImplement the algorithm and evaluate it on the following test cases. In each case, $x_0$, $\\mathbf{u}$, $\\epsilon$, and $R_{\\max}$ are specified, and the surfaces are given as a list with identifiers.\n\n- Case $1$ (happy path inside a sphere): surfaces: a single sphere with identifier $0$, center $c = (0, 0, 0)$, radius $r = 2$. Ray: $x_0 = (0, 0, 1)$, $\\mathbf{u} = (0, 0, 1)$, $\\epsilon = 10^{-9}$, $R_{\\max} = 100$. The nearest crossing is expected at a finite $s$.\n\n- Case $2$ (boundary start on a plane): surfaces: two planes, identifiers $0$ and $1$. Plane $0$: point $p = (0, 0, 0)$, normal $n = (0, 0, 1)$. Plane $1$: point $p = (0, 0, 5)$, normal $n = (0, 0, 1)$. Ray: $x_0 = (0, 0, 0)$, $\\mathbf{u} = (0, 0, 1)$, $\\epsilon = 10^{-9}$, $R_{\\max} = 100$. The intersection with plane $0$ occurs at $s = 0$, which must be discarded; the next valid crossing is finite.\n\n- Case $3$ (parallel ray with no intersection within range): surfaces: a single plane with identifier $0$, point $p = (1, 0, 0)$, normal $n = (1, 0, 0)$. Ray: $x_0 = (0, 0, 0)$, $\\mathbf{u} = (0, 1, 0)$, $\\epsilon = 10^{-9}$, $R_{\\max} = 10$. The ray is parallel to the plane; no intersection should be found within $(\\epsilon, R_{\\max}]$.\n\n- Case $4$ (no intersection with a sphere): surfaces: a single sphere with identifier $0$, center $c = (0, 0, 0)$, radius $r = 1$. Ray: $x_0 = (0, 2, 0)$, $\\mathbf{u} = (1, 0, 0)$, $\\epsilon = 10^{-9}$, $R_{\\max} = 10$. The ray misses the sphere; no intersection should be found within $(\\epsilon, R_{\\max}]$.\n\n- Case $5$ (finite cylinder side hit): surfaces: a single finite cylinder side surface with identifier $0$, radius $r = 1$, axial bounds $z_{\\min} = 0$, $z_{\\max} = 3$. Ray: $x_0 = (0.5, 0, 1)$, $\\mathbf{u} = (1, 0, 0)$, $\\epsilon = 10^{-9}$, $R_{\\max} = 100$. The nearest valid crossing with the side surface occurs at a finite $s$ and must satisfy the axial constraint.\n\nYour implementation must produce a single line containing the list of $[id, d]$ pairs for the five cases in the order given.",
            "solution": "The problem requires the development of a boundary crossing algorithm fundamental to continuous-energy Monte Carlo particle transport methods. The algorithm must determine the nearest intersection point between a particle's trajectory, modeled as a geometric ray, and a set of predefined analytic surfaces.\n\n**1. Algorithmic Framework and Problem Formulation**\n\nLet the particle's trajectory be a ray defined by the parametric equation $x(d) = x_0 + d\\mathbf{v}$, where $x_0 \\in \\mathbb{R}^3$ is the initial position, $\\mathbf{v} \\in \\mathbb{R}^3$ is a unit direction vector ($\\|\\mathbf{v}\\| = 1$), and $d \\ge 0$ is the distance along the ray from $x_0$. The input direction vector $\\mathbf{u}$ is first normalized to obtain $\\mathbf{v} = \\mathbf{u} / \\|\\mathbf{u}\\|$, ensuring that the parameter $d$ represents the true physical distance in meters. This normalization is a permitted step that simplifies the subsequent geometric calculations.\n\nThe problem is to find the minimum valid intersection distance $d_{\\min}$ and the corresponding surface identifier $id_{\\min}$. A distance $d$ is considered valid if it satisfies $d \\in (\\epsilon, R_{\\max}]$, where $\\epsilon  0$ is a small tolerance to avoid self-intersection at the starting point, and $R_{\\max}  0$ is the maximum flight distance for the current transport step.\n\nThe algorithm proceeds as follows:\n1. Initialize the minimum distance found so far to the maximum allowed distance, $d_{\\min} \\leftarrow R_{\\max}$, and the corresponding surface identifier to a sentinel value, $id_{\\min} \\leftarrow -1$.\n2. For each surface in the provided finite list, calculate an ordered set of positive intersection distances $\\{d_i\\}$.\n3. For each calculated distance $d_i$, check for validity. An intersection is valid if $d_i \\in (\\epsilon, d_{\\min})$.\n4. If a valid intersection is found, update the state: $d_{\\min} \\leftarrow d_i$ and $id_{\\min} \\leftarrow$ current surface identifier. The search range for subsequent surfaces is now reduced to $(\\epsilon, d_{\\min})$.\n5. After iterating through all surfaces, the pair $(id_{\\min}, d_{\\min})$ is the result.\n\n**2. Derivation of Ray-Surface Intersection Distances**\n\nThe core of the algorithm is the analytic calculation of the intersection distance $d$ for each type of surface. This is achieved by substituting the ray equation into the implicit equation of the surface and solving for $d$.\n\n**2.1. Ray-Plane Intersection**\nA plane is defined by a point $p \\in \\mathbb{R}^3$ and a unit normal vector $n \\in \\mathbb{R}^3$. The implicit equation is $n \\cdot (x - p) = 0$.\nSubstituting the ray equation $x(d) = x_0 + d\\mathbf{v}$:\n$$n \\cdot ((x_0 + d\\mathbf{v}) - p) = 0$$\nExpanding the dot product:\n$$n \\cdot (x_0 - p) + d(n \\cdot \\mathbf{v}) = 0$$\nSolving for $d$:\n$$d = \\frac{n \\cdot (p - x_0)}{n \\cdot \\mathbf{v}}$$\nThis expression is defined only if the denominator $n \\cdot \\mathbf{v} \\neq 0$.\n- If $|n \\cdot \\mathbf{v}|$ is smaller than a numerical precision tolerance, the ray is considered parallel to the plane. In this case, no intersection occurs unless the ray lies within the plane (i.e., $n \\cdot (p - x_0) = 0$), which is not a discrete crossing event and is thus ignored for $d  0$.\n- If $n \\cdot \\mathbf{v} \\neq 0$, a unique intersection distance $d$ is computed.\n\n**2.2. Ray-Sphere Intersection**\nA sphere is defined by a center $c \\in \\mathbb{R}^3$ and a radius $r  0$. The implicit equation is $\\|x - c\\|^2 = r^2$.\nLet $\\Delta x_c = x_0 - c$. Substituting the ray equation $x(d) = x_0 + d\\mathbf{v} = c + \\Delta x_c + d\\mathbf{v}$:\n$$\\|(\\Delta x_c + d\\mathbf{v})\\|^2 - r^2 = 0$$\nExpanding the squared norm, which is a dot product with itself:\n$$(\\Delta x_c + d\\mathbf{v}) \\cdot (\\Delta x_c + d\\mathbf{v}) - r^2 = 0$$\n$$\\|\\Delta x_c\\|^2 + 2d(\\Delta x_c \\cdot \\mathbf{v}) + d^2\\|\\mathbf{v}\\|^2 - r^2 = 0$$\nSince $\\mathbf{v}$ is a unit vector, $\\|\\mathbf{v}\\|^2 = 1$. This yields a quadratic equation in $d$ of the form $ad^2 + bd + c_{_Q} = 0$:\n$$d^2 + (2(\\Delta x_c \\cdot \\mathbf{v}))d + (\\|\\Delta x_c\\|^2 - r^2) = 0$$\nThe coefficients are: $a=1$, $b=2((x_0-c)\\cdot\\mathbf{v})$, and $c_{_Q}=\\|x_0-c\\|^2 - r^2$.\nThe discriminant is $\\mathcal{D} = b^2 - 4ac_{_Q}$.\n- If $\\mathcal{D}  0$, there are no real roots, and the ray misses the sphere.\n- If $\\mathcal{D} \\ge 0$, there are one or two real roots, given by the quadratic formula:\n$$d = \\frac{-b \\pm \\sqrt{\\mathcal{D}}}{2a} = -\\frac{b}{2} \\pm \\frac{\\sqrt{\\mathcal{D}}}{2}$$\nLet $b' = b/2 = (x_0-c)\\cdot\\mathbf{v}$ and $c' = c_{_Q}$. The equation is $d^2+2b'd+c'=0$ and solutions are $d = -b' \\pm \\sqrt{b'^2-c'}$.\nThe two potential distances are $d_1 = -b' - \\sqrt{b'^2 - c'}$ and $d_2 = -b' + \\sqrt{b'^2 - c'}$. The smallest positive distance greater than $\\epsilon$ among these roots is chosen as the candidate intersection distance.\n\n**2.3. Ray-Cylinder Intersection**\nA right circular cylinder aligned with the $z$-axis is defined by a radius $r  0$ and axial bounds $z_{\\min}, z_{\\max}$. The side surface has the implicit equation $x_x^2 + x_y^2 = r^2$ for $z_{\\min} \\le x_z \\le z_{\\max}$.\nThe components of the ray are $x_x(d) = x_{0x} + dv_x$ and $x_y(d) = x_{0y} + dv_y$. Substituting these into the side surface equation:\n$$(x_{0x} + dv_x)^2 + (x_{0y} + dv_y)^2 - r^2 = 0$$\nExpanding and collecting terms in powers of $d$:\n$$d^2(v_x^2 + v_y^2) + d(2(x_{0x}v_x + x_{0y}v_y)) + (x_{0x}^2 + x_{0y}^2 - r^2) = 0$$\nThis is a quadratic equation $ad^2 + bd + c_{_Q} = 0$ with coefficients:\n- $a = v_x^2 + v_y^2$\n- $b = 2(x_{0x}v_x + x_{0y}v_y)$\n- $c_{_Q} = x_{0x}^2 + x_{0y}^2 - r^2$\nThe roots $d_i$ are found using the quadratic formula, as for the sphere. If $a \\approx 0$ (i.e., the ray is nearly parallel to the $z$-axis), the equation degenerates to a linear one.\nFor each valid root $d_i  \\epsilon$, a further check is required. The $z$-coordinate of the intersection point, $z_{hit} = x_{0z} + d_i v_z$, must lie within the cylinder's axial bounds:\n$$z_{\\min} \\le z_{hit} \\le z_{\\max}$$\nOnly if this condition is met is the intersection distance $d_i$ considered valid. The smallest such $d_i$ is the candidate distance for this surface.\n\n**3. Proof of Termination**\nThe problem statement guarantees a finite set of surfaces. Let this number be $N$. The algorithm consists of a single loop that iterates $N$ times. Within each iteration, the work performed is constant with respect to the problem size (apart from $N$). For each surface type (plane, sphere, cylinder), the algorithm executes a fixed sequence of steps:\n- Vector operations (normalization, dot product, norm), which are constant-time operations for three-dimensional vectors.\n- Solving at most one polynomial equation of degree one or two. This also takes a constant number of arithmetic operations.\n- A fixed number of comparisons to validate the resulting distance(s).\n\nThe total number of operations is therefore proportional to $N$. Since $N$ is finite, the algorithm is guaranteed to execute in a finite number of steps and terminate.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numerical tolerance for floating point comparisons, e.g., checking for parallelism.\nZERO_TOLERANCE = 1e-12\n\ndef _find_valid_roots(a, b, c, epsilon):\n    \"\"\"\n    Solves a quadratic equation ad^2 + bd + c = 0 and returns a list of \n    valid roots d  epsilon.\n    \"\"\"\n    roots = []\n    \n    if abs(a)  ZERO_TOLERANCE:\n        # Linear equation: bd + c = 0\n        if abs(b)  ZERO_TOLERANCE:\n            d = -c / b\n            if d  epsilon:\n                roots.append(d)\n    else:\n        # Quadratic equation\n        discriminant = b**2 - 4 * a * c\n        if discriminant = 0:\n            sqrt_disc = np.sqrt(discriminant)\n            d1 = (-b - sqrt_disc) / (2 * a)\n            d2 = (-b + sqrt_disc) / (2 * a)\n            \n            # Roots should be sorted to check the smallest positive one first\n            sorted_roots = sorted([d1, d2])\n            for d in sorted_roots:\n                if d  epsilon:\n                    roots.append(d)\n    return roots\n\ndef _intersect_plane(x0, v, p, n, epsilon):\n    \"\"\"Calculates intersection distance with a plane.\"\"\"\n    nv_dot = n.dot(v)\n    if abs(nv_dot)  ZERO_TOLERANCE:\n        return []  # Ray is parallel to the plane\n    \n    d = n.dot(p - x0) / nv_dot\n    if d  epsilon:\n        return [d]\n    return []\n\ndef _intersect_sphere(x0, v, c, r, epsilon):\n    \"\"\"Calculates intersection distance(s) with a sphere.\"\"\"\n    delta_x = x0 - c\n    \n    # Coefficients for ad^2 + bd + c = 0\n    # Since v is normalized, a = v.dot(v) = 1\n    a = 1.0\n    b = 2 * delta_x.dot(v)\n    c_q = delta_x.dot(delta_x) - r**2\n    \n    return _find_valid_roots(a, b, c_q, epsilon)\n\ndef _intersect_cylinder_side(x0, v, r, z_min, z_max, epsilon):\n    \"\"\"Calculates intersection distance(s) with a finite z-aligned cylinder side.\"\"\"\n    # Coefficients for ad^2 + bd + c = 0\n    a = v[0]**2 + v[1]**2\n    b = 2 * (x0[0]*v[0] + x0[1]*v[1])\n    c_q = x0[0]**2 + x0[1]**2 - r**2\n    \n    potential_distances = _find_valid_roots(a, b, c_q, epsilon)\n    \n    valid_distances = []\n    for d in potential_distances:\n        # Check if the hit point is within the axial bounds\n        z_hit = x0[2] + d * v[2]\n        if z_min = z_hit = z_max:\n            valid_distances.append(d)\n            \n    return valid_distances\n\ndef find_nearest_crossing(x0, u, surfaces, epsilon, R_max):\n    \"\"\"\n    Finds the nearest valid surface crossing for a particle track.\n\n    Args:\n        x0 (np.ndarray): Particle starting position.\n        u (np.ndarray): Particle direction vector (not necessarily normalized).\n        surfaces (list): A list of surface description dictionaries.\n        epsilon (float): Small positive distance to avoid self-intersection.\n        R_max (float): Maximum flight distance.\n\n    Returns:\n        tuple: (surface_id, distance) for the nearest crossing. \n               If no crossing, returns (-1, R_max).\n    \"\"\"\n    norm_u = np.linalg.norm(u)\n    if norm_u  ZERO_TOLERANCE:\n        return -1, R_max # No movement\n    v = u / norm_u\n\n    min_dist = R_max\n    min_id = -1\n\n    for surface in surfaces:\n        s_id = surface['id']\n        s_type = surface['type']\n        params = surface['params']\n        \n        distances = []\n        if s_type == 'plane':\n            distances = _intersect_plane(x0, v, params['p'], params['n'], epsilon)\n        elif s_type == 'sphere':\n            distances = _intersect_sphere(x0, v, params['c'], params['r'], epsilon)\n        elif s_type == 'cylinder_side':\n            distances = _intersect_cylinder_side(x0, v, params['r'], params['z_min'], params['z_max'], epsilon)\n        \n        for d in distances:\n            if d  min_dist:\n                min_dist = d\n                min_id = s_id\n    \n    return min_id, min_dist\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the boundary crossing algorithm.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path inside a sphere)\n        {\n            'x0': np.array([0.0, 0.0, 1.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 2.0}}\n            ]\n        },\n        # Case 2 (boundary start on a plane)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 0.0, 1.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 0.0]), 'n': np.array([0.0, 0.0, 1.0])}},\n                {'id': 1, 'type': 'plane', 'params': {'p': np.array([0.0, 0.0, 5.0]), 'n': np.array([0.0, 0.0, 1.0])}}\n            ]\n        },\n        # Case 3 (parallel ray with no intersection)\n        {\n            'x0': np.array([0.0, 0.0, 0.0]), 'u': np.array([0.0, 1.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'plane', 'params': {'p': np.array([1.0, 0.0, 0.0]), 'n': np.array([1.0, 0.0, 0.0])}}\n            ]\n        },\n        # Case 4 (no intersection with a sphere)\n        {\n            'x0': np.array([0.0, 2.0, 0.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 10.0,\n            'surfaces': [\n                {'id': 0, 'type': 'sphere', 'params': {'c': np.array([0.0, 0.0, 0.0]), 'r': 1.0}}\n            ]\n        },\n        # Case 5 (finite cylinder side hit)\n        {\n            'x0': np.array([0.5, 0.0, 1.0]), 'u': np.array([1.0, 0.0, 0.0]),\n            'epsilon': 1e-9, 'R_max': 100.0,\n            'surfaces': [\n                {'id': 0, 'type': 'cylinder_side', 'params': {'r': 1.0, 'z_min': 0.0, 'z_max': 3.0}}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res_id, res_dist = find_nearest_crossing(\n            case['x0'], case['u'], case['surfaces'], case['epsilon'], case['R_max']\n        )\n        results.append([res_id, res_dist])\n\n    results_str = [f\"[{item[0]},{item[1]:.6f}]\" for item in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A correctly implemented Monte Carlo simulation must adhere to fundamental conservation laws. This practice guides you in constructing a complete, miniature transport code to verify one of the most important principles: the conservation of energy. You will simulate particle histories from source to termination, meticulously tracking energy as it is deposited through collisions or carried away by leakage, ensuring the final energy balance closes to within statistical precision. ",
            "id": "4218173",
            "problem": "Consider a homogeneous spherical region of radius $R$ with a vacuum boundary, containing a single fictitious nuclide that undergoes elastic scattering and absorption. A set of independent neutron histories is launched from the sphere center according to an isotropic point source with monoenergetic kinetic energy $E_0$ expressed in megaelectronvolts (MeV). The objective is to construct a continuous-energy Monte Carlo algorithm that verifies the energy accounting identity by direct simulation: the total deposited energy equals the total source energy minus the total leakage energy, within the statistical uncertainty of the Monte Carlo estimators.\n\nUse the following scientifically standard bases:\n- The linear Boltzmann transport equation energy balance in integral form implies that, for an isolated system with a vacuum boundary, kinetic energy introduced by the source is partitioned between energy deposited in the medium and energy carried out across the boundary.\n- In elastic scattering of a neutron off a stationary target nucleus of mass ratio $A$ (target mass divided by neutron mass), with scattering isotropic in the center-of-mass frame, the outgoing neutron energy $E'$ in the laboratory frame is given by\n$$\n\\frac{E'}{E} \\;=\\; \\frac{A^2 + 1 + 2 A \\mu_{\\text{cm}}}{(A+1)^2},\n$$\nwhere $E$ is the incoming energy and $\\mu_{\\text{cm}} = \\cos\\theta_{\\text{cm}}$ is the cosine of the scattering angle in the center-of-mass frame. The laboratory scattering angle $\\theta_{\\text{lab}}$ satisfies\n$$\n\\tan\\theta_{\\text{lab}} \\;=\\; \\frac{\\sin\\theta_{\\text{cm}}}{\\cos\\theta_{\\text{cm}} + 1/A},\n$$\nso that\n$$\n\\mu_{\\text{lab}} \\;=\\; \\cos\\theta_{\\text{lab}} \\;=\\; \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}.\n$$\n- In absorption, the neutron kinetic energy is deposited locally as heat. In elastic scattering, the energy deposited as material heating per collision equals the energy loss $E - E'$. With a vacuum boundary, any neutron that reaches the boundary leaks out carrying its current kinetic energy.\n\nLet the macroscopic cross sections be continuous-energy functions of $E$ with units in inverse centimeters ($\\text{cm}^{-1}$):\n- The scattering macroscopic cross section is $\\Sigma_s(E) = \\Sigma_{s0}$ (constant).\n- The absorption macroscopic cross section is $\\Sigma_a(E) = \\dfrac{\\Sigma_{a0}}{\\sqrt{E/\\text{MeV}}}$, representing a $1/v$-like behavior with energy measured in megaelectronvolts. The total macroscopic cross section is $\\Sigma_t(E) = \\Sigma_s(E) + \\Sigma_a(E)$.\nFree-flight distances to the next collision are sampled from the exponential distribution with mean $1/\\Sigma_t(E)$, i.e., $s = -\\ln u / \\Sigma_t(E)$ where $u$ is uniform on $(0,1)$.\n\nGeometry and kinematics:\n- The neutron starts at the origin with an isotropic direction. The distance to the spherical boundary along the current direction is the positive root of $t^2 + 2 (\\boldsymbol{r}\\cdot\\boldsymbol{u}) t + ( \\|\\boldsymbol{r}\\|^2 - R^2 ) = 0$, where $\\boldsymbol{r}$ is the current position and $\\boldsymbol{u}$ is the current unit direction vector.\n- If the sampled free-flight distance $s$ exceeds the boundary distance $d_{\\text{exit}}$, the neutron leaks and carries its current energy $E$ out of the system.\n- If a collision occurs before boundary crossing, it is absorption with probability $\\Sigma_a(E)/\\Sigma_t(E)$ and elastic scattering otherwise. In absorption, deposit $E$ and terminate the history. In elastic scattering, deposit $E - E'$ as heat, update the direction by rotating with polar cosine $\\mu_{\\text{lab}}$ and a uniform azimuth, set the energy to $E'$, and continue the history.\n\nTask:\n1. Implement a continuous-energy Monte Carlo simulation that tallies, for each history $i$, the source energy $S_i = E_0$, the total deposited energy $D_i$ (sum of $E - E'$ over elastic scattering events plus $E$ for absorption), and the leakage energy $L_i$ (the energy at boundary crossing). Define the per-history energy balance residual $B_i = S_i - D_i - L_i$ in MeV.\n2. For $N$ histories, estimate the sample mean $\\bar{B} = \\dfrac{1}{N}\\sum_{i=1}^N B_i$ and the sample standard deviation $s_B$ with the usual unbiased estimator. Using the Central Limit Theorem (CLT), verify the energy accounting identity by checking the inequality\n$$\n|\\bar{B}| \\;\\le\\; z \\,\\frac{s_B}{\\sqrt{N}},\n$$\nwith $z = 3$, i.e., within three standard errors. If $s_B = 0$, treat $|\\bar{B}| \\le \\varepsilon$ with a small numerical tolerance $\\varepsilon$ as verification.\n3. Report, for each specified test case, a boolean result indicating whether the identity is verified within statistical uncertainty.\n\nUnits:\n- Energies must be handled and tallied in megaelectronvolts (MeV).\n- Distances are in centimeters ($\\text{cm}$).\n- Cross sections are in inverse centimeters ($\\text{cm}^{-1}$).\n- Angles must be sampled and manipulated in radians.\n\nTest Suite:\nProvide results for the following parameter sets, each acting as an independent test case:\n- Case A (general mixed interactions): $N = 8000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.20\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.05\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$.\n- Case B (pure absorption medium): $N = 10000$, $R = 50\\,\\text{cm}$, $\\Sigma_{s0} = 0.00\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.10\\,\\text{cm}^{-1}$, $A = 12$, $E_0 = 2.0\\,\\text{MeV}$.\n- Case C (pure scattering hydrogen, small sphere): $N = 10000$, $R = 10\\,\\text{cm}$, $\\Sigma_{s0} = 0.10\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$.\n- Case D (near vacuum, large sphere): $N = 10000$, $R = 100\\,\\text{cm}$, $\\Sigma_{s0} = 0.005\\,\\text{cm}^{-1}$, $\\Sigma_{a0} = 0.00\\,\\text{cm}^{-1}$, $A = 1$, $E_0 = 2.0\\,\\text{MeV}$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$\\text{result1}$,$\\text{result2}$,$\\text{result3}$,$\\text{result4}$]\"), where each result is a boolean indicating whether the energy accounting identity is verified within three standard errors for the corresponding test case.",
            "solution": "The problem requires the construction of a continuous-energy Monte Carlo neutron transport simulation to verify the energy conservation identity within a finite spherical medium. The identity states that the total energy introduced by a source must equal the sum of the energy deposited within the medium and the energy that leaks out of the system. The verification is to be performed by checking that the mean of the per-history energy balance residual is statistically indistinguishable from zero.\n\nThe solution is founded on the principle of energy conservation as applied to the linear Boltzmann transport equation for neutral particles. For a steady-state system with a source $S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega})$, the energy balance can be expressed as:\n$$\n\\int_V d\\boldsymbol{r} \\int_{4\\pi} d\\boldsymbol{\\Omega} \\int_0^\\infty dE \\, E \\, S(\\boldsymbol{r}, E, \\boldsymbol{\\Omega}) \\;=\\; \\int_V d\\boldsymbol{r} \\int_0^\\infty dE \\, E_{\\text{dep}}(\\boldsymbol{r}, E) + \\int_{\\partial V} d\\boldsymbol{s} \\int_0^\\infty dE \\, E \\, (\\boldsymbol{n} \\cdot \\boldsymbol{\\Omega}) \\, \\Psi(\\boldsymbol{r}_s, E, \\boldsymbol{\\Omega})\n$$\nwhere the left side is the total source energy, the first term on the right is the total deposited energy, and the second term is the total leakage energy across the surface $\\partial V$. The Monte Carlo method provides a means to estimate these integral quantities by simulating a large number of individual particle histories. The problem states that the per-history balance $S_i - D_i - L_i$ must be tallied, where $S_i$ is the source energy, $D_i$ is the total energy deposited, and $L_i$ is the leakage energy for history $i$. By construction, for an analog simulation with perfect arithmetic, this residual $B_i = S_i - D_i - L_i$ is identically zero for every history. The task thus becomes a code verification problem, testing if the implementation correctly conserves energy at each step, such that the computed residuals are zero within floating-point precision.\n\nThe algorithm proceeds by simulating $N$ independent neutron histories. Each history traces a single neutron from its emission at the source to its termination by absorption or leakage.\n\n1.  **Source Particle Initialization**: Each neutron history $i$ begins with a particle at the center of the sphere, $\\boldsymbol{r} = (0,0,0)$. The source energy is fixed at $S_i = E_0$. The initial direction of travel, a unit vector $\\boldsymbol{u}$, is sampled from an isotropic distribution. This is achieved by sampling the polar angle cosine $\\mu_z = \\cos\\theta$ uniformly from $[-1, 1]$ and the azimuthal angle $\\phi$ uniformly from $[0, 2\\pi]$, then constructing the direction vector $\\boldsymbol{u} = (\\sqrt{1-\\mu_z^2}\\cos\\phi, \\sqrt{1-\\mu_z^2}\\sin\\phi, \\mu_z)$. For each history, the tallies for deposited energy $D_i$ and leakage energy $L_i$ are initialized to $0$.\n\n2.  **Neutron Transport Loop**: The core of the simulation is a loop that advances the neutron from one event to the next. In each step of the loop, the neutron is at position $\\boldsymbol{r}$ with energy $E$ and direction $\\boldsymbol{u}$.\n    -   **Cross Section Evaluation**: The macroscopic total cross section $\\Sigma_t(E)$ is computed as the sum of the scattering cross section, $\\Sigma_s(E) = \\Sigma_{s0}$, and the absorption cross section, $\\Sigma_a(E) = \\Sigma_{a0}/\\sqrt{E}$.\n    -   **Distance to Collision**: The path length $s$ to the next potential collision is sampled from an exponential probability distribution with mean free path $1/\\Sigma_t(E)$. This is done by sampling a uniform random number $\\xi_1 \\in (0,1)$ and calculating $s = -\\ln(\\xi_1) / \\Sigma_t(E)$. If $\\Sigma_t(E) = 0$, the path length is infinite.\n    -   **Distance to Boundary**: The distance $d_{\\text{exit}}$ from the current position $\\boldsymbol{r}$ to the spherical boundary of radius $R$ along the current direction $\\boldsymbol{u}$ is determined. This is the positive root of the quadratic equation $t^2 + 2(\\boldsymbol{r}\\cdot\\boldsymbol{u})t + (\\|\\boldsymbol{r}\\|^2 - R^2) = 0$, which is $d_{\\text{exit}} = -(\\boldsymbol{r}\\cdot\\boldsymbol{u}) + \\sqrt{(\\boldsymbol{r}\\cdot\\boldsymbol{u})^2 - (\\|\\boldsymbol{r}\\|^2 - R^2)}$.\n    -   **Event Determination**: The sampled distance to collision $s$ is compared with the distance to the boundary $d_{\\text{exit}}$.\n        -   If $s \\ge d_{\\text{exit}}$, the neutron reaches the boundary without colliding. It leaks from the system. The leakage energy for the history is set to the neutron's current energy, $L_i = E$, and the history is terminated.\n        -   If $s  d_{\\text{exit}}$, the neutron travels a distance $s$ and undergoes a collision. The particle's position is updated to $\\boldsymbol{r}' = \\boldsymbol{r} + s\\boldsymbol{u}$.\n\n3.  **Collision Physics**: If a collision occurs, its type is determined probabilistically.\n    -   A random number $\\xi_2 \\in (0,1)$ is sampled.\n    -   If $\\xi_2  \\Sigma_a(E) / \\Sigma_t(E)$, the collision is an **absorption**. The neutron's entire kinetic energy $E$ is deposited in the material. The deposited energy tally is updated, $D_i \\leftarrow D_i + E$, and the history is terminated.\n    -   Otherwise, the collision is **elastic scattering**. The neutron loses some energy and changes direction.\n        -   **Energy kinematics**: The outgoing energy $E'$ is determined by the scattering kinematics. For isotropic scattering in the center-of-mass (CM) frame, the cosine of the CM scattering angle, $\\mu_{\\text{cm}}$, is sampled uniformly from $[-1, 1]$. The new energy in the laboratory frame is $E' = E \\frac{A^2 + 1 + 2A\\mu_{\\text{cm}}}{(A+1)^2}$.\n        -   **Energy Deposition**: The energy lost by the neutron is deposited as heat. The tally is updated: $D_i \\leftarrow D_i + (E - E')$. The neutron's energy is then updated to $E'$.\n        -   **Direction Kinematics**: The neutron's direction vector $\\boldsymbol{u}$ is updated. The cosine of the laboratory scattering angle is $\\mu_{\\text{lab}} = \\frac{\\mu_{\\text{cm}} + 1/A}{\\sqrt{1 + 2\\mu_{\\text{cm}}/A + 1/A^2}}$. A random azimuthal scattering angle $\\phi_{\\text{azimuth}} \\in [0, 2\\pi]$ is sampled. The old direction vector $\\boldsymbol{u}$ is rotated by the polar angle $\\theta_{\\text{lab}} = \\arccos(\\mu_{\\text{lab}})$ and azimuthal angle $\\phi_{\\text{azimuth}}$ to obtain the new direction $\\boldsymbol{u}'$. The neutron's direction is updated to $\\boldsymbol{u}'$.\n        -   The transport loop then continues from step 2 with the updated particle state ($\\boldsymbol{r}', E', \\boldsymbol{u}'$).\n\n4.  **Tallying and Statistical Analysis**: After each history $i$ terminates, the energy balance residual is calculated: $B_i = S_i - D_i - L_i$. Due to the manner of tallying, where every change in kinetic energy is accounted for as either deposited or eventually leaked, this value should be numerically very close to zero.\n    After all $N$ histories are completed, the sample of residuals $\\{B_1, B_2, \\dots, B_N\\}$ is analyzed. The sample mean $\\bar{B} = \\frac{1}{N}\\sum_{i=1}^N B_i$ and the unbiased sample standard deviation $s_B = \\sqrt{\\frac{1}{N-1}\\sum_{i=1}^N (B_i - \\bar{B})^2}$ are computed.\n    The energy accounting identity is considered verified if the mean residual is consistent with zero within three standard errors of the mean, i.e., $|\\bar{B}| \\le 3 \\frac{s_B}{\\sqrt{N}}$.\n    In the special case where numerical errors are so small that the computed $s_B$ is zero, the verification is performed by checking if $|\\bar{B}|$ is smaller than a small tolerance $\\varepsilon$, for example, $\\varepsilon = 10^{-12}$. This confirms that the implementation maintains energy conservation to within floating-point precision. This process is repeated for each test case provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotate_direction(direction_vec, mu_lab, phi_azimuth):\n    \"\"\"\n    Rotates a direction vector by a polar angle (specified by its cosine mu_lab)\n    and an azimuthal angle phi_azimuth.\n    Uses the MCNP standard rotation formula.\n    \"\"\"\n    u, v, w = direction_vec\n    sin_theta_lab = np.sqrt(1.0 - mu_lab**2)\n    cos_phi = np.cos(phi_azimuth)\n    sin_phi = np.sin(phi_azimuth)\n\n    # Handle the case where the initial direction is nearly aligned with the z-axis\n    # to avoid division by zero in the standard formula.\n    if np.abs(w)  1.0 - 1e-9:\n        u_prime = sin_theta_lab * cos_phi\n        v_prime = sin_theta_lab * sin_phi\n        w_prime = mu_lab * np.sign(w)\n    else:\n        # Standard rotation formula\n        temp = np.sqrt(1.0 - w**2)\n        u_prime = u * mu_lab + (sin_theta_lab / temp) * (u * w * cos_phi - v * sin_phi)\n        v_prime = v * mu_lab + (sin_theta_lab / temp) * (v * w * cos_phi + u * sin_phi)\n        w_prime = w * mu_lab - sin_theta_lab * temp * cos_phi\n\n    return np.array([u_prime, v_prime, w_prime], dtype=np.float64)\n\ndef simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng):\n    \"\"\"\n    Simulates a single neutron history from source to termination.\n    Returns the energy balance residual for the history.\n    \"\"\"\n    # Particle state variables\n    pos = np.zeros(3, dtype=np.float64)\n    energy = np.float64(E0)\n\n    # Sample isotropic source direction\n    mu_z = 2.0 * rng.random() - 1.0\n    phi = 2.0 * np.pi * rng.random()\n    sin_theta = np.sqrt(1.0 - mu_z**2)\n    direction = np.array([sin_theta * np.cos(phi),\n                          sin_theta * np.sin(phi),\n                          mu_z], dtype=np.float64)\n\n    # History tallies\n    deposited_energy = np.float64(0.0)\n    leakage_energy = np.float64(0.0)\n\n    while True:\n        # Check for particle termination by energy threshold (unlikely here)\n        if energy = 0.0:\n            break\n\n        # Macroscopic cross sections\n        sigma_s = np.float64(Sigma_s0)\n        sigma_a = np.float64(Sigma_a0 / np.sqrt(energy)) if energy  0 else np.inf\n        sigma_t = sigma_s + sigma_a\n\n        # Sample distance to collision\n        if sigma_t == 0.0:\n            dist_to_collision = np.inf\n        else:\n            dist_to_collision = -np.log(rng.random()) / sigma_t\n\n        # Calculate distance to sphere boundary\n        r_dot_u = np.dot(pos, direction)\n        r_sq = np.dot(pos, pos)\n        discriminant = r_dot_u**2 - (r_sq - R**2)\n        dist_to_boundary = -r_dot_u + np.sqrt(discriminant)\n        \n        # Determine event: leakage or collision\n        if dist_to_collision = dist_to_boundary:\n            leakage_energy = energy\n            break  # History terminates\n        else:\n            # Move particle to collision site\n            pos += dist_to_collision * direction\n\n            # Determine collision type: absorption or scattering\n            prob_absorption = sigma_a / sigma_t\n            if rng.random()  prob_absorption:\n                deposited_energy += energy\n                break  # History terminates\n            else:\n                # Elastic scattering\n                # Sample CM scattering cosine\n                mu_cm = 2.0 * rng.random() - 1.0\n\n                # Calculate new energy\n                a_plus_1_sq = (A + 1.0)**2\n                energy_prime = energy * (A**2 + 1.0 + 2.0 * A * mu_cm) / a_plus_1_sq\n\n                # Deposit energy loss\n                deposited_energy += (energy - energy_prime)\n\n                # Update particle energy\n                energy = energy_prime\n\n                # Update particle direction\n                mu_lab_num = mu_cm + 1.0 / A\n                mu_lab_den = np.sqrt(1.0 + 2.0 * mu_cm / A + 1.0 / A**2)\n                mu_lab = mu_lab_num / mu_lab_den\n                \n                phi_scatter = 2.0 * np.pi * rng.random()\n                direction = rotate_direction(direction, mu_lab, phi_scatter)\n\n    # Calculate and return the energy balance residual\n    residual = E0 - deposited_energy - leakage_energy\n    return residual\n\ndef run_simulation(N, R, Sigma_s0, Sigma_a0, A, E0):\n    \"\"\"\n    Runs N histories for a given problem configuration and verifies the energy balance.\n    \"\"\"\n    rng = np.random.default_rng(seed=12345)\n    residuals = np.zeros(N, dtype=np.float64)\n\n    for i in range(N):\n        residuals[i] = simulate_history(R, Sigma_s0, Sigma_a0, A, E0, rng)\n    \n    mean_B = np.mean(residuals)\n    std_B = np.std(residuals, ddof=1)\n\n    if std_B == 0.0:\n        # If std dev is numerically zero, all residuals are identical.\n        # Check if the mean (and thus all residuals) is near zero.\n        epsilon = 1e-12 \n        return np.abs(mean_B) = epsilon\n    else:\n        # Standard statistical check\n        z = 3.0\n        standard_error = std_B / np.sqrt(N)\n        return np.abs(mean_B) = z * standard_error\n\ndef solve():\n    \"\"\"\n    Main function to define, run, and report results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'N': 8000, 'R': 50.0, 'Sigma_s0': 0.20, 'Sigma_a0': 0.05, 'A': 12.0, 'E0': 2.0},\n        # Case B\n        {'N': 10000, 'R': 50.0, 'Sigma_s0': 0.00, 'Sigma_a0': 0.10, 'A': 12.0, 'E0': 2.0},\n        # Case C\n        {'N': 10000, 'R': 10.0, 'Sigma_s0': 0.10, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n        # Case D\n        {'N': 10000, 'R': 100.0, 'Sigma_s0': 0.005, 'Sigma_a0': 0.00, 'A': 1.0, 'E0': 2.0},\n    ]\n\n    results = []\n    for case_params in test_cases:\n        is_verified = run_simulation(**case_params)\n        # The output format requires Python's True/False to be converted to lowercase.\n        results.append(str(is_verified).lower())\n    \n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Accurately modeling the fission process is central to reactor analysis. While the average number of neutrons produced per fission, $\\nu(E)$, is a continuous function of energy, the actual outcome of any single event must be an integer. This exercise addresses this dichotomy by having you design and validate a 'floor-plus-Bernoulli' sampler, a clever and essential algorithm that produces the correct integer distribution while rigorously conserving the physical, energy-dependent mean multiplicity. ",
            "id": "4218152",
            "problem": "You are tasked with designing and validating an energy-dependent integer multiplicity sampler suitable for continuous-energy Monte Carlo methods in nuclear reactor simulation. In such methods, neutron-induced reactions produce a random integer count of secondaries, with the expected count depending on the incident neutron energy. The goal is to construct a floor-plus-Bernoulli integer sampling algorithm that conserves the prescribed average multiplicity as a function of energy across many events.\n\nStarting point and core definitions: In a single reaction event at energy $E$ (measured in megaelectronvolt (MeV)), let $N(E)$ denote the integer number of secondary neutrons produced, and define the energy-dependent average multiplicity $\\nu(E)$ as the conditional expectation $\\nu(E) = \\mathbb{E}[N(E)\\mid E]$. In a Monte Carlo tally, the conservation requirement is that the sample average of $N(E)$ equals $\\nu(E)$ in the limit of many statistically independent events at fixed $E$, and that the mixture-average over an energy distribution equals the corresponding energy-weighted average of $\\nu(E)$. You must design an algorithm that, for each $E$, produces integer outputs $N$ whose expectation equals $\\nu(E)$.\n\nFor this exercise, adopt the following scientifically plausible, monotonic average prompt neutron multiplicity per fission for uranium-$235$ as a function of incident neutron energy:\n$$\n\\nu(E) = \\nu_0 + \\alpha \\,\\ln\\!\\big(1 + \\frac{E}{E_c}\\big),\n$$\nwith constants $\\nu_0 = 2.4$, $\\alpha = 0.3$, and $E_c = 1$ MeV. This form increases slowly with $E$ and produces realistic values over fast energies. All energies $E$ are to be provided and interpreted in MeV. All multiplicities are in units of neutrons per fission. All logarithms are natural logarithms.\n\nAlgorithmic task:\n- Define a function that computes $\\nu(E)$ using the expression above.\n- Construct a floor-plus-Bernoulli sampler that, for a given $E$, returns an integer $N$ such that $\\mathbb{E}[N\\mid E] = \\nu(E)$. The sampler must operate by computing $k(E) = \\lfloor \\nu(E) \\rfloor$ and the fractional part $f(E) = \\nu(E) - k(E)$, and then returning $N = k(E)$ with probability $1 - f(E)$ or $N = k(E) + 1$ with probability $f(E)$. Use a high-quality pseudorandom number generator and seed it with $42$ for reproducibility. Clip the fractional part to the interval $[0,1]$ to guard against numerical roundoff.\n- Validate the conservation of the expected value in a set of test cases by estimating the absolute error between the sample mean and the exact mean derived from $\\nu(E)$.\n- In a mixed-energy validation, sample energies according to prescribed weights and verify that the overall sample mean conserves the energy-weighted average multiplicity.\n\nTest suite (all energies in MeV, all outputs to be expressed as floats in neutrons per fission):\n- Case $1$: $E = 0$, sample size $M = 100000$. Output the absolute error $|\\overline{N} - \\nu(E)|$, where $\\overline{N}$ is the sample mean over $M$ trials at fixed $E$.\n- Case $2$: $E = 1$, sample size $M = 100000$. Output the absolute error as in Case $1$.\n- Case $3$: $E = 10$, sample size $M = 100000$. Output the absolute error as in Case $1$.\n- Case $4$: Choose $E$ such that $\\nu(E) = 3$ exactly. Using the given form, this is $E^\\star = E_c\\big(\\exp\\big(\\frac{3 - \\nu_0}{\\alpha}\\big) - 1\\big)$. Use $E^\\star$ with sample size $M = 100000$. Output the absolute error as in Case $1$.\n- Case $5$: Mixed-energy sampling with energies $[0, 1, 10]$ and weights $[0.5, 0.3, 0.2]$ (dimensionless). Draw $M = 100000$ events by first sampling an energy according to the weights and then sampling $N$ using the floor-plus-Bernoulli method at that energy. Output the absolute error between the overall sample mean and the energy-weighted average multiplicity $\\sum_i w_i \\nu(E_i)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the float absolute error for Case $i$, in units of neutrons per fission. Use the pseudorandom number generator seed $42$ to ensure deterministic outputs.",
            "solution": "The problem is found to be valid as it is scientifically grounded, self-contained, well-posed, and directly pertinent to the field of computational nuclear engineering. The provided physical model and algorithmic prescription are consistent and formalizable.\n\nThe task is to design and validate a floor-plus-Bernoulli integer sampling algorithm for simulating the number of secondary neutrons, $N$, produced in a neutron-induced reaction. The expected number of such neutrons, denoted as the average multiplicity $\\nu(E)$, is a continuous function of the incident neutron energy $E$. The fundamental requirement for any such sampling algorithm is that the expectation of the sampled integer count $N(E)$ must be equal to the continuous-valued mean multiplicity $\\nu(E)$.\n\nThe provided model for the average prompt neutron multiplicity for uranium-$235$ is:\n$$\n\\nu(E) = \\nu_0 + \\alpha \\,\\ln\\!\\big(1 + \\frac{E}{E_c}\\big)\n$$\nwhere $E$ is the incident neutron energy in units of MeV. The constants are given as $\\nu_0 = 2.4$ (neutrons/fission), $\\alpha = 0.3$ (dimensionless), and $E_c = 1$ MeV. All logarithms are natural logarithms.\n\nThe floor-plus-Bernoulli sampling algorithm is constructed as follows. For a given energy $E$, a value of $\\nu(E)$ is computed. This value is then decomposed into its integer and fractional parts:\n1.  The floor, $k(E) = \\lfloor \\nu(E) \\rfloor$.\n2.  The fractional part, $f(E) = \\nu(E) - k(E)$. By definition, $0 \\le f(E)  1$.\n\nThe algorithm then samples an integer $N$ from a Bernoulli-like distribution. The outcome $N$ can only take two possible values: $k(E)$ or $k(E) + 1$. The probabilities are defined as:\n- $P(N = k(E)) = 1 - f(E)$\n- $P(N = k(E) + 1) = f(E)$\n\nThe expectation of the sampled integer $N$ at a fixed energy $E$ can be shown to be exactly $\\nu(E)$:\n$$\n\\mathbb{E}[N \\mid E] = \\big(k(E)\\big) \\cdot P(N = k(E)) + \\big(k(E) + 1\\big) \\cdot P(N = k(E) + 1)\n$$\n$$\n\\mathbb{E}[N \\mid E] = k(E) \\cdot (1 - f(E)) + (k(E) + 1) \\cdot f(E)\n$$\n$$\n\\mathbb{E}[N \\mid E] = k(E) - k(E)f(E) + k(E)f(E) + f(E) = k(E) + f(E)\n$$\nBy substituting $k(E) + f(E) = \\nu(E)$, we demonstrate that $\\mathbb{E}[N \\mid E] = \\nu(E)$. This mathematical property ensures that the sampler conserves the mean multiplicity, which is the central requirement of the problem.\n\nThe validation of the implemented sampler is performed across five test cases, using a sample size of $M = 100000$ for each and a pseudorandom number generator seeded with $42$ for reproducibility. The validation metric is the absolute error between the sample mean $\\overline{N}$ and the theoretical expected value.\n\nCase $1$: Fixed energy $E = 0$ MeV.\nThe theoretical mean is $\\nu(0) = 2.4 + 0.3 \\ln(1 + 0/1) = 2.4$.\nThe algorithm will sample from the integers $2$ and $3$ to achieve this mean.\n\nCase $2$: Fixed energy $E = 1$ MeV.\nThe theoretical mean is $\\nu(1) = 2.4 + 0.3 \\ln(1 + 1/1) = 2.4 + 0.3 \\ln(2) \\approx 2.60794414$.\nThe algorithm will sample from the integers $2$ and $3$.\n\nCase $3$: Fixed energy $E = 10$ MeV.\nThe theoretical mean is $\\nu(10) = 2.4 + 0.3 \\ln(1 + 10/1) = 2.4 + 0.3 \\ln(11) \\approx 3.11936853$.\nThe algorithm will sample from the integers $3$ and $4$.\n\nCase $4$: Fixed energy $E^\\star$ chosen such that $\\nu(E^\\star) = 3$.\nThe required energy is $E^\\star = E_c\\big(\\exp\\big(\\frac{3 - \\nu_0}{\\alpha}\\big) - 1\\big) = 1 \\cdot \\big(\\exp\\big(\\frac{3 - 2.4}{0.3}\\big) - 1\\big) = \\exp(2) - 1 \\approx 6.38905610$ MeV.\nThe theoretical mean is exactly $\\nu(E^\\star) = 3$. Since the fractional part $f(E^\\star)$ is $0$, the sampler should deterministically return the integer $3$. Thus, the sample mean $\\overline{N}$ should be exactly $3$, and the absolute error is expected to be $0$.\n\nCase $5$: Mixed-energy sampling.\nEnergies $E_i$ are $[0, 1, 10]$ MeV with corresponding weights $w_i = [0.5, 0.3, 0.2]$.\nThe theoretical energy-weighted average multiplicity is $\\bar{\\nu} = \\sum_{i} w_i \\nu(E_i)$.\n$\\bar{\\nu} = 0.5 \\cdot \\nu(0) + 0.3 \\cdot \\nu(1) + 0.2 \\cdot \\nu(10)$\n$\\bar{\\nu} = 0.5 \\cdot (2.4) + 0.3 \\cdot (2.4 + 0.3\\ln(2)) + 0.2 \\cdot (2.4 + 0.3\\ln(11))$\n$\\bar{\\nu} \\approx 0.5(2.4) + 0.3(2.60794414) + 0.2(3.11936853) \\approx 2.60625706$.\nThe simulation involves drawing $M=100000$ samples, where for each sample, an energy is first chosen from the discrete distribution, and then the multiplicity is sampled at that energy. The overall sample mean is compared to $\\bar{\\nu}$.\n\nThe following Python code implements this logic to compute the absolute errors for all five cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and validates a floor-plus-Bernoulli integer sampler for\n    continuous-energy Monte Carlo methods.\n    \"\"\"\n    \n    # Define constants from the problem statement\n    NU0 = 2.4\n    ALPHA = 0.3\n    EC = 1.0  # MeV\n    \n    # Set up the pseudorandom number generator with the specified seed\n    RNG = np.random.default_rng(42)\n    \n    def nu_func(E):\n        \"\"\"\n        Computes the energy-dependent average multiplicity nu(E).\n        \n        Args:\n            E (float): Incident neutron energy in MeV.\n            \n        Returns:\n            float: Average multiplicity nu at energy E.\n        \"\"\"\n        return NU0 + ALPHA * np.log(1 + E / EC)\n\n    def floor_plus_bernoulli_sampler(E, rng):\n        \"\"\"\n        Samples an integer multiplicity N such that E[N|E] = nu(E).\n\n        Args:\n            E (float): Incident neutron energy in MeV.\n            rng (numpy.random.Generator): The random number generator instance.\n\n        Returns:\n            int: A sampled integer multiplicity N.\n        \"\"\"\n        nu_val = nu_func(E)\n        k = np.floor(nu_val)\n        f = nu_val - k\n        # Clip fractional part to handle potential floating point roundoff\n        f_clipped = np.clip(f, 0.0, 1.0)\n        \n        if rng.random()  f_clipped:\n            return int(k + 1)\n        else:\n            return int(k)\n\n    # Define the test cases from the problem statement.\n    M_SAMPLES = 100000\n    test_cases = [\n        {'type': 'fixed_E', 'E': 0.0, 'M': M_SAMPLES},\n        {'type': 'fixed_E', 'E': 1.0, 'M': M_SAMPLES},\n        {'type': 'fixed_E', 'E': 10.0, 'M': M_SAMPLES},\n        {'type': 'fixed_E', 'E': EC * (np.exp((3.0 - NU0) / ALPHA) - 1.0), 'M': M_SAMPLES},\n        {'type': 'mixed_E', 'Es': [0.0, 1.0, 10.0], 'weights': [0.5, 0.3, 0.2], 'M': M_SAMPLES}\n    ]\n\n    results = []\n    \n    # Process each test case\n    for i, case in enumerate(test_cases):\n        if case['type'] == 'fixed_E':\n            E = case['E']\n            M = case['M']\n            \n            # Theoretical mean\n            exact_mean = nu_func(E)\n            \n            # Monte Carlo simulation\n            samples = [floor_plus_bernoulli_sampler(E, RNG) for _ in range(M)]\n            sample_mean = np.mean(samples)\n            \n            # Calculate absolute error\n            abs_error = np.abs(sample_mean - exact_mean)\n            results.append(abs_error)\n            \n        elif case['type'] == 'mixed_E':\n            Es = case['Es']\n            weights = case['weights']\n            M = case['M']\n            \n            # Theoretical weighted average mean\n            exact_means_per_E = [nu_func(e) for e in Es]\n            weighted_exact_mean = np.dot(weights, exact_means_per_E)\n            \n            # Monte Carlo simulation for mixed energy\n            # 1. Sample energies according to weights\n            sampled_energies = RNG.choice(Es, size=M, p=weights)\n            \n            # 2. Sample multiplicity for each sampled energy\n            samples = [floor_plus_bernoulli_sampler(e, RNG) for e in sampled_energies]\n            sample_mean = np.mean(samples)\n            \n            # Calculate absolute error\n            abs_error = np.abs(sample_mean - weighted_exact_mean)\n            results.append(abs_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}