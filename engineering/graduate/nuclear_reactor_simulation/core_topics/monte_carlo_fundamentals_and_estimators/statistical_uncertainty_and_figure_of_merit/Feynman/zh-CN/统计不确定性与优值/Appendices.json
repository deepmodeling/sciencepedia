{
    "hands_on_practices": [
        {
            "introduction": "在任何蒙特卡罗临界计算中，首要任务是确保所分析的数据来自已收敛的、稳定的裂变源分布。本练习将指导您实现一种自动化方法，通过同时监测有效增殖因子 $k_{\\mathrm{eff}}$ 和源熵的平稳性来客观地确定预烧阶段的结束点。您将应用统计检验来判断趋势是否在统计上和实践上可以忽略不计，这是保证后续不确定性量化可靠性的关键一步。",
            "id": "4251796",
            "problem": "您将执行一项针对核反应堆模拟的蒙特卡洛临界监测任务。目标是通过同时监测有效增殖因数 $k_{\\mathrm{eff}}$ 的漂移和裂变源分布的源熵，来确定需要舍弃的初始非活跃（燃耗）循环数。在确定合理的燃耗期后，您必须计算为 $k_{\\mathrm{eff}}$ 估计量定义的品质因子（FOM）。\n\n您必须从基本原理出发：基于大数定律的蒙特卡洛样本均值收敛、基于最小二乘回归的线性趋势检测，以及离散概率分布的香农熵。设计并实现一个采用以下原理的测试：\n\n- 对于最近的 $W$ 个连续循环窗口，评估两个时间序列的稳定性：逐循环的 $k_{\\mathrm{eff}}$ 估计值 $\\{k_i\\}$ 和源熵值 $\\{H_i\\}$。对每个序列，使用普通最小二乘法对窗口数据拟合一个 $y_i = a + b x_i$ 形式的简单线性回归，其中 $x_i$ 是窗口内的循环索引。使用置信水平为 $1-\\alpha$ 的双侧置信区间，判断斜率 $b$ 是否在统计上与零无法区分。同时，要求 $\\lvert b \\rvert$ 低于相应指标的指定绝对容差。\n- 在首个满足以下条件的循环索引 $i^\\star \\ge W$ 处宣布收敛：$k_{\\mathrm{eff}}$ 序列和源熵序列这两个指标，在以 $i^\\star$ 结尾的最近 $W$ 个循环窗口上，均通过了零斜率置信区间检验和绝对斜率容差检验。所选的燃耗循环数即为索引 $i^\\star$。\n- 确定 $i^\\star$ 后，使用活跃循环 $i^\\star+1,\\dots,N$ 计算 $k_{\\mathrm{eff}}$ 估计量的品质因子（FOM）。使用批次均值平均的标准相对标准误差定义：若 $\\bar{k}$ 是活跃循环中 $k_{\\mathrm{eff}}$ 的样本均值， $s^2$ 是活跃循环中各循环 $k_{\\mathrm{eff}}$ 批次均值的无偏样本方差， $t_c$ 是每个循环的时间（秒），则相对标准误差为 $R = \\frac{s/\\sqrt{n}}{\\bar{k}}$，其中 $n$ 是活跃循环数。品质因子为 $F = \\frac{1}{R^2 \\, T}$，其中 $T = n \\, t_c$。最终的 FOM 以 $\\mathrm{s}^{-1}$（每秒）为单位表示，不进行四舍五入。\n\n注意事项和要求：\n- 对于一个非负分量之和为一的离散分布 $p \\in \\mathbb{R}^M$，其香农熵为 $H(p) = -\\sum_{j=1}^{M} p_j \\ln p_j$（自然对数）。熵的单位是奈特（nats）。\n- 最小二乘斜率及其双侧置信区间必须使用普通最小二乘法和自由度为 $n-2$ 的学生t分布计算，其中 $n$ 是窗口中的数据点数。使用每个测试用例中指定的置信水平 $1-\\alpha$。\n- 如果在模拟结束时没有循环满足收敛准则（即不存在 $i^\\star$），则将燃耗循环数设为 $N$，并将 FOM 设为 $0.0$。\n\n测试套件：\n在以下4个测试用例上实现并评估您的方法。在所有用例中，每个循环的时间 $t_c$ 以秒为单位给出，最终的 FOM 必须以 $\\mathrm{s}^{-1}$ 报告。\n\n对于每个用例，您必须按规定以编程方式生成 $\\{k_i\\}_{i=1}^{N}$ 和源概率向量 $\\{p_i\\}_{i=1}^{N}$，然后计算 $H_i = -\\sum_{j=1}^{M} p_{i,j} \\ln p_{i,j}$。\n\n- 用例1（理想情况）：\n  - 参数：$N=120$, $M=10$, $t_c=0.4$, $W=20$, $\\alpha=0.05$, $k$斜率容差 $\\tau_k = 3\\times 10^{-4}$ /循环, 熵斜率容差 $\\tau_H = 1.5\\times 10^{-3}$ 奈特/循环。\n  - $k_{\\mathrm{eff}}$ 序列：对于循环索引 $i \\in \\{1,\\dots,N\\}$,\n    $$k_i = 0.96 + 0.0012 \\cdot \\min(i, 35) + 0.0004 \\sin(0.31 i).$$\n  - 源分布：定义 $\\alpha_i = 3.0 \\exp(-i/18.0)$ 和原始分数 $r_{i,j} = \\exp\\big(-\\alpha_i \\cdot (j-1)\\big)$，其中 $j \\in \\{1,\\dots,M\\}$。归一化为 $p_{i,j} = r_{i,j} / \\sum_{\\ell=1}^{M} r_{i,\\ell}$。\n\n- 用例2（接近容差的慢漂移）：\n  - 参数：$N=150$, $M=12$, $t_c=0.6$, $W=25$, $\\alpha=0.05$, $\\tau_k = 2\\times 10^{-4}$ /循环, $\\tau_H = 9\\times 10^{-4}$ 奈特/循环。\n  - $k_{\\mathrm{eff}}$ 序列：\n    $$k_i = 0.98 + 0.00018 \\cdot \\min(i, 70) + 0.00025 \\sin(0.2 i).$$\n  - 源分布：$\\alpha_i = 2.5 \\exp(-i/40.0)$, $r_{i,j} = \\exp\\big(-\\alpha_i \\cdot (j-1)\\big)$, $p_{i,j} = r_{i,j} / \\sum_{\\ell=1}^{M} r_{i,\\ell}$。\n\n- 用例3（永不收敛；边界情况）：\n  - 参数：$N=80$, $M=8$, $t_c=0.5$, $W=20$, $\\alpha=0.05$, $\\tau_k = 1\\times 10^{-4}$ /循环, $\\tau_H = 5\\times 10^{-4}$ 奈特/循环。\n  - $k_{\\mathrm{eff}}$ 序列：\n    $$k_i = 0.90 + 0.0005 \\cdot i + 0.0001 \\sin(0.37 i).$$\n  - 源分布：$\\alpha_i = 3.0 \\exp(-i/200.0)$, $r_{i,j} = \\exp\\big(-\\alpha_i \\cdot (j-1)\\big)$, $p_{i,j} = r_{i,j} / \\sum_{\\ell=1}^{M} r_{i,\\ell}$。\n\n- 用例4（稳态附近的高频噪声）：\n  - 参数：$N=100$, $M=16$, $t_c=0.3$, $W=20$, $\\alpha=0.05$, $\\tau_k = 3\\times 10^{-4}$ /循环, $\\tau_H = 1.0\\times 10^{-3}$ 奈特/循环。\n  - $k_{\\mathrm{eff}}$ 序列：\n    $$k_i = 1.00 + 0.0006 \\sin(0.5 i).$$\n  - 源分布：$\\alpha_i = 1.8 \\exp(-i/5.0)$, $r_{i,j} = \\exp\\big(-\\alpha_i \\cdot (j-1)\\big)$, $p_{i,j} = r_{i,j} / \\sum_{\\ell=1}^{M} r_{i,\\ell}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含所有4个测试用例的结果，聚合为单个 Python 风格的列表的列表。每个内部列表包含两个值：所选的燃耗循环数和计算出的 FOM（单位为 $\\mathrm{s}^{-1}$）。要求的格式为\n  $$[[b_1, f_1], [b_2, f_2], [b_3, f_3], [b_4, f_4]],$$\n  其中每个 $b_i$ 是一个整数，每个 $f_i$ 是一个浮点数。不应包含任何其他文本。不要对浮点数进行四舍五入。\n\n角度单位不适用。没有百分比需要报告。所有物理时间都必须以秒为单位处理。FOM 必须以 $\\mathrm{s}^{-1}$ 表示。",
            "solution": "该问题要求实现一个算法，用于确定蒙特卡洛核反应堆模拟的燃耗期，并随后计算品质因子（FOM）。解决方案分为三个主要阶段：数据生成、收敛性分析和 FOM 计算。\n\n### 1. 数据生成\n对于每个测试用例，在 $N$ 个循环上生成两个时间序列：有效增殖因数 $\\{k_i\\}_{i=1}^N$ 和源熵 $\\{H_i\\}_{i=1}^N$。\n\n每个循环 $i \\in \\{1, \\dots, N\\}$ 的 $k_{\\mathrm{eff}}$ 值 $k_i$ 是直接根据每个具体案例提供的解析函数生成的。\n\n源熵值 $H_i$ 由源概率分布 $\\{p_{i,j}\\}_{j=1}^M$ 导出。对每个循环 $i$，首先使用其特定于案例的公式计算参数 $\\alpha_i$。然后使用该参数定义一组原始分数 $r_{i,j} = \\exp\\big(-\\alpha_i \\cdot (j-1)\\big)$，其中 $j \\in \\{1, \\dots, M\\}$。这些分数被归一化以形成概率分布 $p_i = \\{p_{i,1}, \\dots, p_{i,M}\\}$，其中 $p_{i,j} = r_{i,j} / \\sum_{\\ell=1}^{M} r_{i,\\ell}$。然后根据所提供的定义，使用自然对数计算循环 $i$ 的香农熵：\n$$\nH_i = H(p_i) = -\\sum_{j=1}^{M} p_{i,j} \\ln p_{i,j}\n$$\n熵的单位是奈特（nats）。\n\n### 2. 收敛检测\n问题的核心是找到最佳的燃耗循环数 $i^\\star$。这通过迭代检查 $\\{k_i\\}$ 和 $\\{H_i\\}$ 两个时间序列的统计平稳性来实现。对合适的 $i^\\star$ 的搜索从第 $W$ 个循环开始，一直进行到第 $N$ 个循环，其中 $W$ 是指定的窗口大小。\n\n对于每个候选循环 $i \\in \\{W, \\dots, N\\}$，我们分析最近 $W$ 个循环窗口内的数据，即循环 $\\{i-W+1, \\dots, i\\}$。对于此窗口内的时间序列 $\\{y_j\\}$，我们执行包含两个检验的稳定性分析。\n\n首先，将一个简单线性回归模型 $y_j = a + b x_j$ 拟合到数据点 $(x_j, y_j)$，其中 $\\{y_j\\}$ 是来自窗口的 $W$ 个值，$\\{x_j\\}$ 是对应的索引，可以方便地设置为 $\\{0, 1, \\dots, W-1\\}$。该回归线的斜率 $b$ 表示数据的趋势。\n\n稳定性分析对估计的斜率 $\\hat{b}$ 施加了两个条件：\n\n1.  **零斜率置信区间检验**：斜率必须在统计上与零无法区分。这通过检查数值 0 是否位于真实斜率 $b$ 的双侧置信区间内来验证。该区间由 $\\hat{b} \\pm t_{\\alpha/2, W-2} \\cdot SE(\\hat{b})$ 给出，其中 $SE(\\hat{b})$ 是斜率估计的标准误差，而 $t_{\\alpha/2, W-2}$ 是在置信水平 $1-\\alpha$ 下、自由度为 $W-2$ 的学生t分布的临界值。此条件等价于检查 $|\\hat{b}| \\le t_{\\alpha/2, W-2} \\cdot SE(\\hat{b})$。在实现中，使用 `scipy.stats.linregress` 函数获取 $\\hat{b}$ 和 $SE(\\hat{b})$，并使用 `scipy.stats.t.ppf` 查找临界 $t$ 值。\n\n2.  **绝对斜率容差检验**：斜率的绝对值必须小于给定的实际容差，即 $|\\hat{b}|  \\tau$。这确保了任何残余趋势不仅在统计上不显著，而且在实际上也可以忽略不计。分别为 $k_{\\mathrm{eff}}$ 和熵序列指定了单独的容差 $\\tau_k$ 和 $\\tau_H$。\n\n在第一个使得 $\\{k_i\\}$ 和 $\\{H_i\\}$ 两个时间序列在以 $i^\\star$ 结尾的窗口上 **同时** 满足 **两个** 稳定性条件的循环 $i^\\star$ 处，宣布收敛。如果在模拟结束前没有找到这样的循环，则将燃耗循环数设为 $i^\\star = N$。\n\n### 3. 品质因子（FOM）计算\n一旦确定了燃耗循环数 $i^\\star$，剩余的循环，即从 $i^\\star+1$ 到 $N$，被视为“活跃”循环。设 $n = N - i^\\star$ 为活跃循环的数量。\n\n如果 $n  2$，则无法计算有意义的样本方差。在这种情况下，以及在未找到收敛的情况下（$i^\\star = N$，因此 $n=0$），FOM 设为 $0.0$。\n\n否则，在 $n$ 个活跃循环上为 $k_{\\mathrm{eff}}$ 估计量计算 FOM。设这些循环的 $k_{\\mathrm{eff}}$ 值集合为 $\\{k_{\\text{active}}\\}$。我们首先计算这些值的样本均值 $\\bar{k}$ 和无偏样本方差 $s^2$：\n$$\n\\bar{k} = \\frac{1}{n} \\sum_{k_j \\in \\{k_{\\text{active}}\\}} k_j\n$$\n$$\ns^2 = \\frac{1}{n-1} \\sum_{k_j \\in \\{k_{\\text{active}}\\}} (k_j - \\bar{k})^2\n$$\n均值的相对标准误差 $R$ 由 $R = \\frac{s/\\sqrt{n}}{\\bar{k}}$ 给出。活跃循环的总计算时间为 $T = n \\cdot t_c$，其中 $t_c$ 是每个循环的时间。品质因子定义为：\n$$\nF = \\frac{1}{R^2 T}\n$$\n代入 $R$ 和 $T$ 的表达式，我们可以简化 $F$ 的公式：\n$$\nF = \\frac{1}{\\left(\\frac{s^2/n}{\\bar{k}^2}\\right) (n \\cdot t_c)} = \\frac{\\bar{k}^2}{s^2 \\cdot t_c}\n$$\n这个简化公式用于最终计算。得到的 FOM 单位为 $\\mathrm{s}^{-1}$。每个用例的最终输出是一个包含整数燃耗循环数 $i^\\star$ 和浮点数 FOM 值的数对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import t, linregress\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases and prints the final result.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"id\": 1,\n            \"N\": 120, \"M\": 10, \"tc\": 0.4, \"W\": 20, \"alpha\": 0.05,\n            \"tau_k\": 3e-4, \"tau_H\": 1.5e-3,\n            \"k_func\": lambda i: 0.96 + 0.0012 * min(i, 35) + 0.0004 * np.sin(0.31 * i),\n            \"alpha_func\": lambda i: 3.0 * np.exp(-i / 18.0)\n        },\n        {\n            \"id\": 2,\n            \"N\": 150, \"M\": 12, \"tc\": 0.6, \"W\": 25, \"alpha\": 0.05,\n            \"tau_k\": 2e-4, \"tau_H\": 9e-4,\n            \"k_func\": lambda i: 0.98 + 0.00018 * min(i, 70) + 0.00025 * np.sin(0.2 * i),\n            \"alpha_func\": lambda i: 2.5 * np.exp(-i / 40.0)\n        },\n        {\n            \"id\": 3,\n            \"N\": 80, \"M\": 8, \"tc\": 0.5, \"W\": 20, \"alpha\": 0.05,\n            \"tau_k\": 1e-4, \"tau_H\": 5e-4,\n            \"k_func\": lambda i: 0.90 + 0.0005 * i + 0.0001 * np.sin(0.37 * i),\n            \"alpha_func\": lambda i: 3.0 * np.exp(-i / 200.0)\n        },\n        {\n            \"id\": 4,\n            \"N\": 100, \"M\": 16, \"tc\": 0.3, \"W\": 20, \"alpha\": 0.05,\n            \"tau_k\": 3e-4, \"tau_H\": 1.0e-3,\n            \"k_func\": lambda i: 1.00 + 0.0006 * np.sin(0.5 * i),\n            \"alpha_func\": lambda i: 1.8 * np.exp(-i / 5.0)\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_pair = _process_case(params)\n        all_results.append(result_pair)\n\n    # Use str() on the list of lists to get the Python-style representation\n    # which matches the required output format including spaces.\n    print(str(all_results))\n\ndef _check_stability(y_window, x_reg, W, alpha, tolerance):\n    \"\"\"\n    Checks if a time series window is stable based on linear regression.\n    \"\"\"\n    # Perform Ordinary Least Squares regression\n    regression = linregress(x_reg, y_window)\n    slope = regression.slope\n    std_err_slope = regression.stderr\n\n    # Degrees of freedom for t-distribution is n-2\n    df = W - 2\n    \n    # Critical t-value for a two-sided test\n    t_crit = t.ppf(1 - alpha / 2, df)\n    \n    # Condition 1: Slope is statistically indistinguishable from zero\n    # This checks if 0 is within the confidence interval of the slope.\n    is_zero_slope = abs(slope) = t_crit * std_err_slope\n    \n    # Condition 2: Slope is below an absolute tolerance\n    is_small_slope = abs(slope)  tolerance\n    \n    return is_zero_slope and is_small_slope\n\ndef _process_case(params):\n    \"\"\"\n    Executes the full analysis for a single test case.\n    \"\"\"\n    N = params['N']\n    M = params['M']\n    tc = params['tc']\n    W = params['W']\n    alpha = params['alpha']\n    tau_k = params['tau_k']\n    tau_H = params['tau_H']\n    k_func = params['k_func']\n    alpha_func = params['alpha_func']\n\n    # 1. Data Generation\n    # Use 1-based cycle indices as per the problem description for function evaluation\n    cycle_indices_1_based = np.arange(1, N + 1)\n    \n    k_series = np.array([k_func(i) for i in cycle_indices_1_based])\n    \n    h_series = np.zeros(N)\n    for i_idx, i_1b in enumerate(cycle_indices_1_based):\n        alpha_i = alpha_func(i_1b)\n        j_indices = np.arange(1, M + 1)\n        r_ij = np.exp(-alpha_i * (j_indices - 1))\n        p_ij = r_ij / np.sum(r_ij)\n        # Shannon entropy calculation. Use a mask for p_ij=0 to avoid log(0).\n        # Although for the given formulae, p_ij is always > 0.\n        valid_p = p_ij[p_ij > 0]\n        h_series[i_idx] = -np.sum(valid_p * np.log(valid_p))\n\n    # 2. Convergence Detection\n    burn_in_cycle = N  # Default value if convergence is not found\n    x_reg = np.arange(W)\n    \n    # Iterate through possible end-of-window cycles (1-based index)\n    for i_star in range(W, N + 1):\n        # Window indices for array slicing (0-based)\n        start_idx = i_star - W\n        end_idx = i_star\n        \n        # Check stability for k_eff\n        k_window = k_series[start_idx:end_idx]\n        k_stable = _check_stability(k_window, x_reg, W, alpha, tau_k)\n        \n        if not k_stable:\n            continue\n            \n        # Check stability for entropy\n        h_window = h_series[start_idx:end_idx]\n        h_stable = _check_stability(h_window, x_reg, W, alpha, tau_H)\n        \n        if h_stable:\n            burn_in_cycle = i_star\n            break\n            \n    # 3. Figure of Merit (FOM) Calculation\n    n_active = N - burn_in_cycle\n    \n    # FOM requires at least 2 data points to compute variance\n    if n_active  2:\n        fom = 0.0\n    else:\n        # Active cycles are from burn_in_cycle + 1 to N.\n        # In 0-based indexing, slice is from burn_in_cycle to N.\n        active_k_series = k_series[burn_in_cycle:N]\n        \n        k_bar = np.mean(active_k_series)\n        s_sq = np.var(active_k_series, ddof=1)\n        \n        # If variance is zero (all values are identical), FOM is undefined (infinite).\n        # We set it to 0.0 as a practical matter, though it's unlikely with given functions.\n        if s_sq == 0:\n            fom = 0.0\n        else:\n            # FOM = k_bar^2 / (s^2 * t_c)\n            fom = (k_bar**2) / (s_sq * tc)\n            \n    return [burn_in_cycle, fom]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "丢弃瞬态循环后，我们得到的稳态数据序列虽然是平稳的，但由于裂变源的代际耦合而存在自相关性。本练习旨在解决如何从此类数据中可靠地估计不确定性的核心问题，您将设计一种优化的批处理策略。通过推导并最小化一个目标函数，您将在减少批内残余自相关偏差与减小批均值方差估计量的统计波动之间找到一个有原则的平衡点。",
            "id": "4251697",
            "problem": "给定一个蒙特卡罗模拟中每次历史的反应堆功率分布统计量的程式化模型。设每次历史的统计量为一个平稳标量时间序列 $\\{X_n\\}_{n=1}^{N}$，其均值为 $\\mu > 0$，平稳方差为 $\\sigma_X^2$。假设自相关函数是几何形式的，即对于滞后 $k \\ge 0$ 有 $\\rho(k) = \\phi^{k}$，其中 $|\\phi|  1$，这与平稳性条件下的一阶自回归模型 $AR(1)$ 一致。历史数为 $N$，每次历史的平均执行时间为 $t_h$，单位为 $\\mathrm{s}$。\n\n分批策略将 $N$ 个样本划分为 $M$ 个连续的批次，每批大小为 $B$，且满足约束 $N = B M$。批次均值法使用这 $M$ 个批次均值来估计总体样本均值的方差，并进而估计相对误差。然而，当数据自相关时，在选择 $B$ 和 $M$ 时存在一种权衡：较大的 $B$ 会减少每个批次均值方差中由自相关引起的偏差，而较大的 $M$ 则会提高从批次均值计算出的方差估计量的稳定性（即减少其抽样方差）。您的任务是设计一个算法，在给定 $(N, \\phi, \\sigma_X^2, \\mu, t_h)$ 的情况下，选择满足 $N = B M$ 的正整数 $(B, M)$，以一种基于基本定义且有原则的方式来平衡这两种效应。\n\n基本原理：\n- 对于一个具有自相关函数 $\\rho(k)$ 和平稳方差 $\\sigma_X^2$ 的平稳过程，当 $N$ 较大时，样本均值 $\\bar{X}_N$ 的方差满足 $\\operatorname{Var}(\\bar{X}_N) \\approx \\sigma_X^2 \\, \\tau_{\\mathrm{int}} / N$，其中 $\\tau_{\\mathrm{int}} = 1 + 2\\sum_{k=1}^{\\infty} \\rho(k)$ 是积分自相关时间。\n- 对于几何自相关 $\\rho(k) = \\phi^k$，当 $|\\phi|  1$ 时，$\\tau_{\\mathrm{int}}$ 存在。\n- 批次均值法形成 $M$ 个批次均值 $\\{Y_i\\}_{i=1}^{M}$，每个均值是对 $B$ 个连续 $X_n$ 的平均，并使用 $\\{Y_i\\}$ 的样本方差来估计 $\\operatorname{Var}(\\bar{X}_N)$。\n- 反应堆蒙特卡罗中的品质因子 (FOM) 定义为 $\\mathrm{FOM} = 1 / (R^2 T)$，其中 $R$ 是 $\\mu$ 的估计量的相对误差，以小数表示（非百分比），$T$ 是总模拟挂钟时间，单位为 $\\mathrm{s}$。\n\n设计要求：\n- 从这些定义和 $AR(1)$ 自相关的性质出发，推导出一个明确的标量目标函数，该目标函数能够捕捉批次内残余自相关导致的偏差与批次均值方差估计量的抽样方差之间的权衡。使用此目标函数在 $N$ 的整数分解中选择 $(B, M)$，并满足 $M \\ge 3$。您的推导必须从上述定义开始，并且只能依赖于关于自协方差和以及独立高斯批次均值样本方差的抽样分布的经过充分检验的结论。\n- 选择 $(B, M)$ 后，使用适用于 $AR(1)$ 模型的积分自相关时间计算总体样本均值的预测相对误差 $R$，即 $R = \\sqrt{\\operatorname{Var}(\\bar{X}_N)}/\\mu$，并计算 $\\mathrm{FOM}$，单位为 $1/\\mathrm{s}$。\n\n单位和输出：\n- 以 $\\mathrm{s}$ 为单位表示总时间 $T$，$T = N \\, t_h$。\n- 以小数（非百分比）表示相对误差 $R$，以 $1/\\mathrm{s}$ 为单位表示 $\\mathrm{FOM}$。\n- 将所有浮点输出四舍五入到 $6$ 位小数。\n\n测试套件：\n为以下参数集提供结果，每个参数集为一个元组 $(N, \\phi, \\sigma_X^2, \\mu, t_h)$：\n- 情况 1：$(N = 100000, \\phi = 0.6, \\sigma_X^2 = 1.0, \\mu = 1.0, t_h = 1.0 \\times 10^{-5}\\ \\mathrm{s})$。\n- 情况 2：$(N = 200000, \\phi = 0.95, \\sigma_X^2 = 1.0, \\mu = 5.0, t_h = 5.0 \\times 10^{-6}\\ \\mathrm{s})$。\n- 情况 3：$(N = 50000, \\phi = 0.0, \\sigma_X^2 = 4.0, \\mu = 10.0, t_h = 2.0 \\times 10^{-5}\\ \\mathrm{s})$。\n- 情况 4：$(N = 2400, \\phi = 0.85, \\sigma_X^2 = 0.25, \\mu = 0.5, t_h = 1.0 \\times 10^{-3}\\ \\mathrm{s})$。\n- 情况 5：$(N = 10000, \\phi = 0.99, \\sigma_X^2 = 1.0, \\mu = 1.0, t_h = 1.0 \\times 10^{-4}\\ \\mathrm{s})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含每个测试用例结果的逗号分隔列表。每个结果必须是 $[B,M,R,\\mathrm{FOM}]$ 形式的列表，其中 $B$ 和 $M$ 是整数，$R$ 和 $\\mathrm{FOM}$ 是四舍五入到 $6$ 位小数的浮点数。整行必须用方括号括起来，例如 $[[B_1,M_1,R_1,\\mathrm{FOM}_1],[B_2,M_2,R_2,\\mathrm{FOM}_2],\\dots]$。",
            "solution": "我们从具有自相关函数 $\\rho(k)$ 和平稳方差 $\\sigma_X^2$ 的平稳时间序列的样本均值方差出发。一个经过充分检验的结果是，对于较大的 $N$，样本均值的方差由下式给出\n$$\n\\operatorname{Var}(\\bar{X}_N) \\approx \\frac{\\sigma_X^2}{N} \\left(1 + 2\\sum_{k=1}^{\\infty} \\rho(k)\\right) = \\frac{\\sigma_X^2 \\, \\tau_{\\mathrm{int}}}{N},\n$$\n其中 $\\tau_{\\mathrm{int}}$ 是积分自相关时间。对于几何自相关 $\\rho(k) = \\phi^k$（其中 $|\\phi|  1$），我们计算\n$$\n\\sum_{k=1}^{\\infty} \\rho(k) = \\sum_{k=1}^{\\infty} \\phi^k = \\frac{\\phi}{1 - \\phi},\n$$\n所以\n$$\n\\tau_{\\mathrm{int}} = 1 + 2 \\frac{\\phi}{1 - \\phi} = \\frac{1 + \\phi}{1 - \\phi}.\n$$\n\n批次均值：将 $N$ 个样本划分为 $M$ 个大小为 $B$ 的连续批次，其中 $N = B M$。令 $Y_i$ 表示第 $i$ 个批次的均值。在平稳过程中，长度为 $B$ 的批次均值的精确方差可以用自协方差函数 $\\gamma_k = \\operatorname{Cov}(X_t, X_{t+k}) = \\sigma_X^2 \\rho(k)$ 来表示：\n$$\n\\operatorname{Var}(Y) = \\frac{1}{B^2} \\sum_{i=1}^{B} \\sum_{j=1}^{B} \\gamma_{|i - j|} = \\frac{\\sigma_X^2}{B^2} \\left( B + 2 \\sum_{k=1}^{B-1} (B - k) \\rho(k) \\right).\n$$\n定义有限尺寸有效积分自相关因子\n$$\n\\tau_{\\mathrm{eff}}(B) = \\frac{1}{B} \\left( B + 2 \\sum_{k=1}^{B-1} (B - k) \\rho(k) \\right),\n$$\n因此 $\\operatorname{Var}(Y) = \\sigma_X^2 \\, \\tau_{\\mathrm{eff}}(B)/B$。当 $B \\to \\infty$ 时，$\\tau_{\\mathrm{eff}}(B) \\to \\tau_{\\mathrm{int}}$。\n\n我们通过对 $M$ 个批次均值进行平均来估计 $\\operatorname{Var}(\\bar{X}_N)$。对于近似独立的的高斯批次均值，其样本方差 $S_Y^2$ 的期望为 $E[S_Y^2] = \\operatorname{Var}(Y)$，方差为\n$$\n\\operatorname{Var}(S_Y^2) = \\frac{2 \\operatorname{Var}(Y)^2}{M - 1},\n$$\n这是独立高斯变量样本方差的一个标准结果。$\\operatorname{Var}(\\bar{X}_N)$ 的批次均值估计量为 $\\widehat{V} = S_Y^2 / M$。其相对于真实长期方差 $V = \\sigma_X^2 \\tau_{\\mathrm{int}}/N$ 的偏差来自于用 $\\tau_{\\mathrm{eff}}(B)$ 替代 $\\tau_{\\mathrm{int}}$：\n$$\nE[\\widehat{V}] = \\frac{\\operatorname{Var}(Y)}{M} = \\frac{\\sigma_X^2 \\, \\tau_{\\mathrm{eff}}(B)}{B M} = \\frac{\\sigma_X^2 \\, \\tau_{\\mathrm{eff}}(B)}{N}.\n$$\n因此偏差为\n$$\n\\mathrm{Bias} = E[\\widehat{V}] - V = \\frac{\\sigma_X^2}{N} \\left( \\tau_{\\mathrm{eff}}(B) - \\tau_{\\mathrm{int}} \\right).\n$$\n$\\widehat{V}$ 的方差是\n$$\n\\operatorname{Var}(\\widehat{V}) = \\frac{\\operatorname{Var}(S_Y^2)}{M^2} = \\frac{2 \\operatorname{Var}(Y)^2}{M^2 (M - 1)} = \\frac{2 (\\sigma_X^2)^2 \\, \\tau_{\\mathrm{eff}}(B)^2}{B^2 M^2 (M - 1)}.\n$$\n使用 $B M = N$，我们简化得：\n$$\n\\operatorname{Var}(\\widehat{V}) = \\frac{2 (\\sigma_X^2)^2 \\, \\tau_{\\mathrm{eff}}(B)^2}{N^2 (M - 1)}.\n$$\n\n一个用于平衡偏差和抽样方差的有原则的标量目标是 $\\widehat{V}$ 的均方误差 (MSE)，\n$$\n\\mathrm{MSE}(B, M) = \\mathrm{Bias}^2 + \\operatorname{Var}(\\widehat{V}) = \\frac{(\\sigma_X^2)^2}{N^2} \\left[ \\left( \\tau_{\\mathrm{eff}}(B) - \\tau_{\\mathrm{int}} \\right)^2 + \\frac{2 \\, \\tau_{\\mathrm{eff}}(B)^2}{M - 1} \\right],\n$$\n约束条件为 $N = B M$ 和 $M \\ge 3$。由于对于固定的 $N$，前置因子 $(\\sigma_X^2)^2/N^2$ 在所有允许的 $(B, M)$ 中保持不变，因此最小化问题简化为选择 $(B, M)$ 来最小化\n$$\nJ(B, M) = \\left( \\tau_{\\mathrm{eff}}(B) - \\tau_{\\mathrm{int}} \\right)^2 + \\frac{2 \\, \\tau_{\\mathrm{eff}}(B)^2}{M - 1},\n$$\n其中 $M = N/B$。这个目标清晰地捕捉了权衡关系：第一项惩罚批次内的残余自相关偏差，该偏差随 $B$ 的增大而减小；第二项惩罚方差估计量的抽样方差，该方差随 $M$ 的增大而减小。\n\n对于几何自相关，我们可以解析地计算 $\\tau_{\\mathrm{eff}}(B)$。写出\n$$\n\\sum_{k=1}^{B-1} (B - k) \\phi^k = B \\sum_{k=1}^{B-1} \\phi^k - \\sum_{k=1}^{B-1} k \\phi^k,\n$$\n并使用 $|\\phi|  1$ 和整数 $m = B - 1$ 条件下几何级数和加权几何级数的闭合形式：\n$$\n\\sum_{k=1}^{m} \\phi^k = \\frac{\\phi \\left(1 - \\phi^{m}\\right)}{1 - \\phi}, \\quad \\sum_{k=1}^{m} k \\phi^k = \\frac{\\phi \\left(1 - (m+1)\\phi^{m} + m \\phi^{m+1}\\right)}{(1 - \\phi)^2}.\n$$\n代入可得\n$$\n\\tau_{\\mathrm{eff}}(B) = \\frac{1}{B} \\left( B + 2 \\left[ B \\cdot \\frac{\\phi(1 - \\phi^{B-1})}{1 - \\phi} - \\frac{\\phi \\left(1 - B \\phi^{B-1} + (B - 1)\\phi^{B}\\right)}{(1 - \\phi)^2} \\right] \\right).\n$$\n\n算法：\n- 对于每个测试用例 $(N, \\phi, \\sigma_X^2, \\mu, t_h)$，在 $|\\phi|  1$ 的情况下计算 $\\tau_{\\mathrm{int}} = (1 + \\phi)/(1 - \\phi)$。\n- 枚举所有能整除 $N$ 的正整数批次大小 $B$，其对应的 $M = N/B$ 满足 $M \\ge 3$。\n- 对于每个允许的 $B$，使用上述闭合形式（或直接求和进行数值验证）计算 $\\tau_{\\mathrm{eff}}(B)$。\n- 评估 $J(B, M) = (\\tau_{\\mathrm{eff}}(B) - \\tau_{\\mathrm{int}})^2 + 2 \\tau_{\\mathrm{eff}}(B)^2/(M - 1)$，并选择使 $J$ 最小化的 $(B, M)$；如果存在平局，任何一个最小化者都是可接受的。\n- 使用 $AR(1)$ 模型下的真实长期方差计算总体样本均值的预测相对误差 $R$：\n$$\nR = \\frac{\\sqrt{\\operatorname{Var}(\\bar{X}_N)}}{\\mu} = \\frac{\\sqrt{\\sigma_X^2 \\, \\tau_{\\mathrm{int}}/N}}{\\mu}.\n$$\n- 计算总时间 $T = N \\, t_h$（单位为 $\\mathrm{s}$）和品质因子 (FOM)，定义为\n$$\n\\mathrm{FOM} = \\frac{1}{R^2 T} = \\frac{1}{\\left(\\sigma_X^2 \\, \\tau_{\\mathrm{int}}/N\\right)\\left(1/\\mu^2\\right) \\cdot N \\, t_h} = \\frac{\\mu^2}{\\sigma_X^2 \\, \\tau_{\\mathrm{int}} \\, t_h},\n$$\n单位为 $1/\\mathrm{s}$。请注意，$\\mathrm{FOM}$ 与 $N$ 无关，因为 $R^2 \\propto 1/N$ 而 $T \\propto N$。\n\n实现细节：\n- 将 $R$ 和 $\\mathrm{FOM}$ 四舍五入到 $6$ 位小数。\n- 针对指定的测试套件，生成形如 $[[B_1,M_1,R_1,\\mathrm{FOM}_1],[B_2,M_2,R_2,\\mathrm{FOM}_2],\\dots]$ 的单行输出。\n\n此过程遵循了相关数据的方差基本定义、基于高斯假设的批次均值估计，以及反应堆蒙特卡罗中使用的品质因子 (FOM) 的标准定义。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef tau_int(phi: float) -> float:\n    \"\"\"\n    Integrated autocorrelation time for geometric autocorrelation rho(k) = phi^k, |phi|  1:\n    tau_int = (1 + phi) / (1 - phi)\n    \"\"\"\n    if abs(phi) >= 1.0:\n        raise ValueError(\"phi must satisfy |phi|  1.\")\n    return (1.0 + phi) / (1.0 - phi)\n\ndef tau_eff(B: int, phi: float) -> float:\n    \"\"\"\n    Finite-size effective autocorrelation factor for batch size B and rho(k) = phi^k:\n    tau_eff(B) = (1/B) * (B + 2 * sum_{k=1}^{B-1} (B - k) phi^k)\n    Uses closed-form sums for numerical stability.\n    \"\"\"\n    if B = 0:\n        raise ValueError(\"Batch size B must be positive.\")\n    if abs(phi)  1e-15:\n        # No autocorrelation: tau_eff = 1 for any B\n        return 1.0\n    if abs(phi) >= 1.0:\n        raise ValueError(\"phi must satisfy |phi|  1.\")\n    m = B - 1\n    # Geometric sum: sum_{k=1}^{m} phi^k\n    S1 = phi * (1.0 - phi**m) / (1.0 - phi)\n    # Weighted geometric sum: sum_{k=1}^{m} k * phi^k\n    S2 = phi * (1.0 - (m + 1) * phi**m + m * phi**(m + 1)) / ((1.0 - phi) ** 2)\n    S = B * S1 - S2\n    return (B + 2.0 * S) / B\n\ndef enumerate_divisors(n: int) -> list:\n    \"\"\"\n    Enumerate all positive divisors of n.\n    \"\"\"\n    divs = set()\n    i = 1\n    while i * i = n:\n        if n % i == 0:\n            divs.add(i)\n            divs.add(n // i)\n        i += 1\n    return sorted(divs)\n\ndef select_batching(N: int, phi: float) -> tuple:\n    \"\"\"\n    Select (B, M) minimizing J(B, M) = (tau_eff(B) - tau_int)^2 + 2 * tau_eff(B)^2 / (M - 1),\n    subject to N = B * M and M >= 3, over integer divisors B of N.\n    Returns (B_opt, M_opt).\n    \"\"\"\n    ti = tau_int(phi)\n    best_B, best_M = None, None\n    best_J = None\n    for B in enumerate_divisors(N):\n        M = N // B\n        if M  3:\n            continue\n        te = tau_eff(B, phi)\n        J = (te - ti) ** 2 + 2.0 * (te ** 2) / (M - 1)\n        if (best_J is None) or (J  best_J):\n            best_J = J\n            best_B = B\n            best_M = M\n    # Fallback: if no admissible (B, M), choose M=2 if possible, else B=N, M=1\n    if best_B is None:\n        for B in enumerate_divisors(N):\n            M = N // B\n            if M >= 2:\n                te = tau_eff(B, phi)\n                J = (te - ti) ** 2 + 2.0 * (te ** 2) / max(M - 1, 1)\n                if (best_J is None) or (J  best_J):\n                    best_J = J\n                    best_B = B\n                    best_M = M\n        if best_B is None:\n            best_B = N\n            best_M = 1\n    return best_B, best_M\n\ndef compute_relative_error(N: int, phi: float, sigma2: float, mu: float) -> float:\n    \"\"\"\n    R = sqrt(Var(mean)) / mu = sqrt(sigma2 * tau_int / N) / mu\n    \"\"\"\n    ti = tau_int(phi)\n    return np.sqrt(sigma2 * ti / N) / mu\n\ndef compute_fom(phi: float, sigma2: float, mu: float, t_h: float) -> float:\n    \"\"\"\n    FOM = 1 / (R^2 * T) = mu^2 / (sigma2 * tau_int * t_h), units 1/s\n    \"\"\"\n    ti = tau_int(phi)\n    return (mu ** 2) / (sigma2 * ti * t_h)\n\ndef format_result(B: int, M: int, R: float, FOM: float) -> str:\n    \"\"\"\n    Format as [B,M,R,FOM] with floats rounded to 6 decimals and no spaces.\n    \"\"\"\n    return f\"[{B},{M},{R:.6f},{FOM:.6f}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (N, phi, sigma_X^2, mu, t_h)\n    test_cases = [\n        (100000, 0.6, 1.0, 1.0, 1.0e-5),\n        (200000, 0.95, 1.0, 5.0, 5.0e-6),\n        (50000, 0.0, 4.0, 10.0, 2.0e-5),\n        (2400, 0.85, 0.25, 0.5, 1.0e-3),\n        (10000, 0.99, 1.0, 1.0, 1.0e-4),\n    ]\n\n    results_str = []\n    for N, phi, sigma2, mu, t_h in test_cases:\n        B, M = select_batching(N, phi)\n        R = compute_relative_error(N, phi, sigma2, mu)\n        fom = compute_fom(phi, sigma2, mu, t_h)\n        results_str.append(format_result(B, M, R, fom))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "第一个练习强调了正确识别预烧阶段的重要性，而本练习将量化未能正确执行此步骤所带来的后果。您将推导并应用一个模型，该模型分析了当瞬态（未收敛）数据与稳态数据混合时，对最终 $k_{\\mathrm{eff}}$ 估计值及其不确定性（置信区间宽度）的影响。通过这个实践，您将深刻理解不正确的预烧处理如何引入偏差，并可能导致对统计不确定性的错误高估或低估。",
            "id": "4251733",
            "problem": "蒙特卡洛临界模拟逐周期地估算有效中子增殖因子 $k_{\\mathrm{eff}}$。设随机变量 $X_i$ 表示每个周期的 $k_{\\mathrm{eff}}$ 估算值。在实践中，初始的几个周期是瞬态的（burn-in），需要被舍弃以避免因裂变源收敛而产生的偏差。考虑这样一种情况：一位分析师在形成最终估算值和不确定度时，错误地将 $n_t$ 个瞬态周期与 $n_s$ 个稳态周期包含在内。假设存在以下物理上真实且科学上一致的模型：\n- 瞬态周期是独立同分布的，其均值为 $m_t$，方差为 $\\sigma_t^2$。\n- 稳态周期是独立同分布的，其均值为 $m_s$，方差为 $\\sigma_s^2$。\n- 由于裂变源耦合，连续的周期是相关的，其特征是所有周期都具有一个恒定的积分自相关时间（IAT）$\\tau \\ge 1$。这意味着对于 $n$ 个样本，平稳序列的样本均值的方差按 $\\sigma^2 \\tau / n$ 的比例缩放。\n- 瞬态周期和稳态周期的混合序列是非平稳的，因为瞬态阶段的均值不同。使用两个阶段的全方差公式来处理所有包含周期内的总方差。\n\n从以下基本原理出发：\n- 中心极限定理（CLT）表明，弱相关序列的样本均值在分布上收敛于一个正态随机变量，其方差由积分自相关时间（IAT）放大。\n- 置信水平为 $0.95$ 的正态分布均值的置信区间使用标准正态分布的 $0.975$ 分位数。\n- 对于权重分别为 $w$ 和 $1-w$ 的两个子总体的混合，全方差公式指出，总方差等于组内方差的加权平均值加上组均值的方差。\n\n您的任务是从第一性原理出发，推导一个算法，用以计算当错误地包含瞬态周期时，对 $k_{\\mathrm{eff}}$ 的 $0.95$ 置信水平的置信区间宽度的影响。具体来说，程序必须：\n1. 使用所有周期（瞬态加稳态）计算样本均值的 $0.95$ 置信区间的宽度。\n2. 仅使用稳态周期（正确做法）计算样本均值的 $0.95$ 置信区间的宽度。\n3. 报告这些宽度的比率 $R$ 以及定义为 $(W_{\\mathrm{all}} - W_{\\mathrm{steady}})/W_{\\mathrm{steady}}$ 的带符号相对差异 $D$。\n4. 如果包含瞬态周期导致不确定度的过高估计（即 $R  1$），则返回布尔值 true，否则返回 false。\n\n所涉及的所有量均为无量纲。不需要物理单位。在所有推理中，将置信水平表示为小数 $0.95$。不涉及角度。百分比必须按已指明的方式表示为小数。\n\n测试套件：\n为以下参数集提供结果。对于每种情况，程序应将 $(n_t, n_s, m_t, m_s, \\sigma_t, \\sigma_s, \\tau)$ 作为输入。\n\n- 情况 A（一般现实情况）：\n  $n_t = 50$, $n_s = 950$, $m_t = 1.010$, $m_s = 1.000$, $\\sigma_t = 0.008$, $\\sigma_s = 0.006$, $\\tau = 3.0$。\n- 情况 B（均值相等，瞬态方差较高）：\n  $n_t = 200$, $n_s = 800$, $m_t = 1.000$, $m_s = 1.000$, $\\sigma_t = 0.010$, $\\sigma_s = 0.006$, $\\tau = 2.5$。\n- 情况 C（均值相等，瞬态方差较低）：\n  $n_t = 100$, $n_s = 900$, $m_t = 1.000$, $m_s = 1.000$, $\\sigma_t = 0.004$, $\\sigma_s = 0.006$, $\\tau = 3.5$。\n- 情况 D（边界：无瞬态周期）：\n  $n_t = 0$, $n_s = 1000$, $m_t = 1.000$, $m_s = 1.000$, $\\sigma_t = 0.006$, $\\sigma_s = 0.006$, $\\tau = 2.0$。\n- 情况 E（瞬态部分大且偏差显著）：\n  $n_t = 400$, $n_s = 600$, $m_t = 1.050$, $m_s = 1.000$, $\\sigma_t = 0.010$, $\\sigma_s = 0.006$, $\\tau = 4.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果应为一个形式为 $[W_{\\mathrm{all}}, W_{\\mathrm{steady}}, R, D, \\text{布尔值}]$ 的列表，其中 $W_{\\mathrm{all}}$ 和 $W_{\\mathrm{steady}}$ 是浮点数，$R$ 和 $D$ 是浮点数，布尔值是 true 或 false。例如：$[[0.001,0.002,0.5,-0.5,false],[\\dots]]$。",
            "solution": "目标是推导一个算法，用以量化在有效增殖因子 $k_{\\mathrm{eff}}$ 的蒙特卡洛估算中错误地包含 $n_t$ 个瞬态周期的影响，而该估算本应仅基于 $n_s$ 个稳态周期。我们将计算两种情况下 $0.95$ 置信区间的宽度：仅使用稳态周期的正确分析（$W_{\\mathrm{steady}}$），以及使用所有周期的不正确分析（$W_{\\mathrm{all}}$）。基于这些，我们将确定比率 $R = W_{\\mathrm{all}}/W_{\\mathrm{steady}}$、相对差异 $D = R-1$，以及不确定度是否被高估。\n\n首先，我们建立均值的双边置信区间宽度的一般公式。根据中心极限定理，从均值为 $\\mu$、方差为 $\\sigma^2$ 的分布中抽取的 $n$ 个观测值的样本均值 $\\bar{X}$ 近似服从正态分布，$\\bar{X} \\sim N(\\mu, \\sigma_{\\bar{X}}^2)$，其中 $\\sigma_{\\bar{X}}^2 = \\mathrm{Var}(\\bar{X})$。置信水平为 $1-\\alpha$ 的置信区间宽度 $W$ 由下式给出：\n$$ W = 2 \\cdot z_{1-\\alpha/2} \\cdot \\sigma_{\\bar{X}} $$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。对于指定的 $0.95$ 置信水平，我们有 $\\alpha=0.05$，并使用分位数 $z_{0.975}$。\n\n问题陈述，对于一个包含 $n$ 个周期、每周期方差为 $\\sigma^2$、积分自相关时间（IAT）为 $\\tau$ 的平稳序列，样本均值的方差被 IAT 放大：\n$$ \\mathrm{Var}(\\bar{X}) = \\frac{\\sigma^2 \\tau}{n} $$\n\n**1. 正确分析：仅稳态周期**\n\n在正确分析中，我们只考虑 $n_s$ 个稳态周期。这是一个平稳序列。\n给定的参数是每周期均值 $m_s$ 和每周期方差 $\\sigma_s^2$。\n样本数量为 $n_s$。\n样本均值 $\\bar{X}_s$ 的方差为：\n$$ \\mathrm{Var}(\\bar{X}_s) = \\frac{\\sigma_s^2 \\tau}{n_s} $$\n均值的标准误是该方差的平方根：\n$$ \\sigma_{\\bar{X}_s} = \\sqrt{\\frac{\\sigma_s^2 \\tau}{n_s}} = \\sigma_s \\sqrt{\\frac{\\tau}{n_s}} $$\n因此，我们记为 $W_{\\mathrm{steady}}$ 的 $0.95$ 置信区间的宽度为：\n$$ W_{\\mathrm{steady}} = 2 \\cdot z_{0.975} \\cdot \\sigma_s \\sqrt{\\frac{\\tau}{n_s}} $$\n该公式在 $n_s > 0$ 时有效。\n\n**2. 错误分析：所有周期（瞬态 + 稳态）**\n\n在错误分析中，分析师将 $n_t$ 个瞬态周期与 $n_s$ 个稳态周期合并，总共 $N = n_t + n_s$ 个周期。由于两个阶段的均值不同（$m_t$ vs. $m_s$），这个组合集合是非平稳的。\n\n为了确定这个混合总体的方差，我们使用指定的总方差公式。设 $X$ 是一个随机变量，表示从 $N$ 个周期的组合池中抽取的单个周期的 $k_{\\mathrm{eff}}$。设 $Y$ 是一个指示周期类型（瞬态或稳态）的指示变量。$X$ 的总方差为 $\\mathrm{Var}(X) = E[\\mathrm{Var}(X|Y)] + \\mathrm{Var}(E[X|Y])$。\n\n两个子总体的权重分别为 $w_t = n_t/N$ 和 $w_s = n_s/N$。\n\n第一项，条件方差的期望值（组内方差），是两个阶段方差的加权平均值：\n$$ E[\\mathrm{Var}(X|Y)] = w_t \\cdot \\mathrm{Var}(X|Y=\\text{transient}) + w_s \\cdot \\mathrm{Var}(X|Y=\\text{steady-state}) = w_t \\sigma_t^2 + w_s \\sigma_s^2 $$\n\n第二项，条件期望的方差（组间方差），捕捉了由于均值不同而产生的变异性：\n$$ E[X|Y] = \\begin{cases} m_t  \\text{with probability } w_t \\\\ m_s  \\text{with probability } w_s \\end{cases} $$\n这个离散随机变量的方差为：\n$$ \\mathrm{Var}(E[X|Y]) = w_t w_s (m_t - m_s)^2 $$\n\n结合这些项，混合总体的有效每周期方差 $\\sigma_{\\mathrm{all}}^2$ 为：\n$$ \\sigma_{\\mathrm{all}}^2 = (w_t \\sigma_t^2 + w_s \\sigma_s^2) + w_t w_s (m_t - m_s)^2 $$\n代入权重 $w_t=n_t/N$ 和 $w_s=n_s/N$：\n$$ \\sigma_{\\mathrm{all}}^2 = \\left(\\frac{n_t}{N}\\sigma_t^2 + \\frac{n_s}{N}\\sigma_s^2\\right) + \\frac{n_t n_s}{N^2}(m_t - m_s)^2 $$\n\n分析师错误地将此非平稳序列视为平稳序列，会使用此有效每周期方差来计算 $N$ 个周期上样本均值的方差。使用给定的常数 $\\tau$ 应用 IAT 校正：\n$$ \\mathrm{Var}(\\bar{X}_{\\mathrm{all}}) = \\frac{\\sigma_{\\mathrm{all}}^2 \\tau}{N} $$\n对应的均值标准误为：\n$$ \\sigma_{\\bar{X}_{\\mathrm{all}}} = \\sqrt{\\frac{\\sigma_{\\mathrm{all}}^2 \\tau}{N}} = \\sigma_{\\mathrm{all}} \\sqrt{\\frac{\\tau}{N}} $$\n对于这个不正确的分析，$0.95$ 置信区间的宽度 $W_{\\mathrm{all}}$ 为：\n$$ W_{\\mathrm{all}} = 2 \\cdot z_{0.975} \\cdot \\sigma_{\\mathrm{all}} \\sqrt{\\frac{\\tau}{N}} = 2 \\cdot z_{0.975} \\cdot \\sqrt{\\sigma_{\\mathrm{all}}^2} \\sqrt{\\frac{\\tau}{n_t+n_s}} $$\n\n**3. 最终量**\n\n利用 $W_{\\mathrm{steady}}$ 和 $W_{\\mathrm{all}}$ 的表达式，我们可以计算所需的度量。\n\n宽度的比率 $R$ 为：\n$$ R = \\frac{W_{\\mathrm{all}}}{W_{\\mathrm{steady}}} = \\frac{2 \\cdot z_{0.975} \\cdot \\sigma_{\\mathrm{all}} \\sqrt{\\tau/N}}{2 \\cdot z_{0.975} \\cdot \\sigma_s \\sqrt{\\tau/n_s}} = \\frac{\\sigma_{\\mathrm{all}}}{\\sigma_s} \\sqrt{\\frac{n_s}{N}} = \\frac{\\sigma_{\\mathrm{all}}}{\\sigma_s} \\sqrt{\\frac{n_s}{n_t+n_s}} $$\n\n带符号的相对差异 $D$ 为：\n$$ D = \\frac{W_{\\mathrm{all}} - W_{\\mathrm{steady}}}{W_{\\mathrm{steady}}} = \\frac{W_{\\mathrm{all}}}{W_{\\mathrm{steady}}} - 1 = R - 1 $$\n\n最后，如果不确定度被高估，即分析师报告了更大的不确定度（即更宽的置信区间），则布尔指标为真，这对应于条件 $W_{\\mathrm{all}} > W_{\\mathrm{steady}}$。这等价于 $R > 1$。\n\n该算法包括使用为每个测试用例提供的参数计算这些量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the effect on the confidence interval for k-eff when transient\n    cycles are incorrectly included in a Monte Carlo simulation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (n_t, n_s, m_t, m_s, sigma_t, sigma_s, tau)\n    test_cases = [\n        # Case A (general realistic case)\n        (50, 950, 1.010, 1.000, 0.008, 0.006, 3.0),\n        # Case B (equal means, higher transient variance)\n        (200, 800, 1.000, 1.000, 0.010, 0.006, 2.5),\n        # Case C (equal means, lower transient variance)\n        (100, 900, 1.000, 1.000, 0.004, 0.006, 3.5),\n        # Case D (boundary: no transient cycles)\n        (0, 1000, 1.000, 1.000, 0.006, 0.006, 2.0),\n        # Case E (large transient fraction and significant bias)\n        (400, 600, 1.050, 1.000, 0.010, 0.006, 4.0),\n    ]\n\n    results = []\n    \n    # Quantile for 95% confidence interval (two-sided)\n    z_0975 = norm.ppf(0.975)\n\n    for case in test_cases:\n        n_t, n_s, m_t, m_s, sigma_t, sigma_s, tau = case\n\n        # Ensure variances are used, not standard deviations, in formulas\n        var_t = sigma_t**2\n        var_s = sigma_s**2\n\n        # 1. Compute W_steady (correct case)\n        # Width of the 0.95 CI using only steady-state cycles\n        if n_s = 0:\n            # Avoid division by zero; physically n_s must be > 0\n            W_steady = np.inf\n        else:\n            std_err_steady = sigma_s * np.sqrt(tau / n_s)\n            W_steady = 2 * z_0975 * std_err_steady\n\n        # 2. Compute W_all (incorrect case)\n        # Width of the 0.95 CI using all (transient + steady) cycles\n        N = n_t + n_s\n        if N == 0:\n            # No cycles, width is undefined or infinite\n            W_all, R, D, is_overestimated = np.nan, np.nan, np.nan, False\n        else:\n            w_t = n_t / N\n            w_s = n_s / N\n\n            # Effective per-cycle variance from the law of total variance\n            # sigma_all^2 = E[Var(X|Y)] + Var(E[X|Y])\n            within_group_var = (w_t * var_t) + (w_s * var_s)\n            between_group_var = w_t * w_s * (m_t - m_s)**2\n            var_all = within_group_var + between_group_var\n            \n            sigma_all = np.sqrt(var_all)\n\n            std_err_all = sigma_all * np.sqrt(tau / N)\n            W_all = 2 * z_0975 * std_err_all\n\n            # 3. Compute ratio R and difference D\n            if W_steady == 0 or np.isinf(W_steady):\n                R = np.inf if W_all > 0 else np.nan\n            else:\n                R = W_all / W_steady\n            \n            D = R - 1\n            \n            # 4. Determine if uncertainty is overestimated\n            is_overestimated = R > 1\n\n        results.append([W_all, W_steady, R, D, is_overestimated])\n\n    # Helper function to format each result list according to the spec\n    def format_result(res_list):\n        return f\"[{res_list[0]},{res_list[1]},{res_list[2]},{res_list[3]},{str(res_list[4]).lower()}]\"\n\n    # Final print statement in the exact required format\n    formatted_results = [format_result(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}