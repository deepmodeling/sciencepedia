{
    "hands_on_practices": [
        {
            "introduction": "掌握有限元方法（FEM）的核心，始于从第一性原理构建并求解一个基本问题。本练习将指导您完成一个一维泊松问题的完整流程，从推导弱形式到组装全局矩阵并施加边界条件。通过这个基础实践，您将深入理解将连续物理模型转化为离散代数系统的基本步骤，这是构建任何数字孪生模型的基础。",
            "id": "4222526",
            "problem": "在信息物理系统 (CPS) 中，数字孪生 (DT) 需要一个数值稳定且物理可解释的一维扩散场代理模型。考虑在域 $[0,1]$ 上的一个一维泊松问题，该问题具有齐次狄利克雷边界条件，用于模拟一个由强形式 $-u''(x)=f(x)$ 控制的归一化无量纲场 $u(x)$，且满足 $u(0)=0$ 和 $u(1)=0$。假设存在均匀体源 $f(x)=1$。将使用有限元法 (FEM) 在适用于数字孪生部署的均匀网格上，通过分段线性基函数进行离散化。\n\n从控制微分方程及其弱形式出发，按以下步骤进行，不使用任何预先推导的快捷公式：\n\n- 使用标准 Galerkin 方法：将强形式乘以测试函数 $v(x)$ 并在 $[0,1]$ 上积分，应用分部积分和本质边界条件，从而推导出弱形式。\n- 在一个包含 $N=4$ 个单元的均匀网格上构建分段线性有限元基函数 $\\{\\phi_{i}(x)\\}$，节点为 $x_{i}=i h$，其中 $i=0,1,2,3,4$，且 $h=1/4$。\n- 通过在单个单元上使用局部基和从参考单元的映射，计算弱问题的双线性形式，从而推导出单元刚度矩阵。\n- 通过对单元贡献求和来组装全局刚度矩阵和全局载荷向量，然后通过消除受约束的自由度来施加狄利克雷边界条件。\n- 求解得到的线性系统以获得内部节点值，并确定在中点 $x=1/2$ 处的离散有限元近似解。\n\n将最终答案表示为一个纯数（无量纲）。如果存在精确的封闭形式解，请以精确形式给出。",
            "solution": "问题陈述已经过验证，被认为是有效的。这是一个源自计算力学的适定的、有科学依据的问题，内容自洽，没有矛盾或歧义。因此，我们可以开始求解。\n\n一维场 $u(x)$ 的控制常微分方程，或称强形式，如下所示：\n$$ -u''(x) = f(x) \\quad \\text{for } x \\in (0, 1) $$\n其中均匀源项 $f(x) = 1$。该问题满足齐次狄利克雷边界条件：\n$$ u(0) = 0 \\quad \\text{and} \\quad u(1) = 0 $$\n\n为了推导弱形式，我们遵循 Galerkin 步骤。我们将强形式乘以一个测试函数 $v(x)$，并在域 $\\Omega = [0,1]$ 上进行积分。测试函数 $v(x)$ 必须属于求解空间，并且必须满足本质（狄利克雷）边界条件的齐次形式，即 $v(0)=0$ 和 $v(1)=0$。\n$$ \\int_{0}^{1} -u''(x) v(x) \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx $$\n对左侧项应用分部积分，$\\int u' dv = uv - \\int v du$，我们令 $-u'' dx$ 为 $dv$，$v$ 为 $u$，得到：\n$$ \\left[ -u'(x) v(x) \\right]_{0}^{1} + \\int_{0}^{1} u'(x) v'(x) \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx $$\n边界项 $[ -u'(x) v(x) ]_{0}^{1}$ 计算结果为 $-u'(1)v(1) - (-u'(0)v(0))$。由于测试函数必须满足 $v(0)=0$ 和 $v(1)=0$，该边界项完全为零。得到的弱形式为：寻找 $u(x)$，使得对于所有有效的测试函数 $v(x)$，\n$$ \\int_{0}^{1} u'(x) v'(x) \\, dx = \\int_{0}^{1} f(x) v(x) \\, dx $$\n这可以表示为一个双线性形式 $a(u,v)$ 和一个线性泛函 $L(v)$：\n$$ a(u, v) = \\int_{0}^{1} u'(x) v'(x) \\, dx $$\n$$ L(v) = \\int_{0}^{1} f(x) v(x) \\, dx $$\n\n对于有限元法 (FEM)，我们将域 $[0,1]$ 离散化为 $N=4$ 个均匀单元。这在位置 $x_i = i h$ 处创建了 $N+1=5$ 个节点，其中 $i \\in \\{0, 1, 2, 3, 4\\}$，单元大小为 $h = 1/N = 1/4$。这些节点位于 $x_0=0$、$x_1=1/4$、$x_2=1/2$、$x_3=3/4$ 和 $x_4=1$。\n\n有限元近似解 $u_h(x)$ 表示为分段线性基函数 $\\phi_j(x)$ 的线性组合：\n$$ u_h(x) = \\sum_{j=0}^{4} U_j \\phi_j(x) $$\n此处，$U_j$ 是场的未知节点值，$U_j = u_h(x_j)$，而 $\\phi_j(x)$ 是“帽子”函数，其定义为 $\\phi_j(x_i) = \\delta_{ij}$（克罗内克 δ）。对于 Galerkin 方法，我们从与基函数相同的空间中选择测试函数 $v(x)$，即对于每个内部节点 $i$，$v(x) = \\phi_i(x)$。\n\n将近似解 $u_h(x)$ 代入每个基函数 $\\phi_i(x)$ 对应的弱形式，得到一个线性方程组 $KU=F$，其中：\n$$ K_{ij} = a(\\phi_j, \\phi_i) = \\int_{0}^{1} \\phi_j'(x) \\phi_i'(x) \\, dx $$\n$$ F_i = L(\\phi_i) = \\int_{0}^{1} f(x) \\phi_i(x) \\, dx $$\n\n我们首先计算单个单元 $\\Omega_e = [x_k, x_{k+1}]$ 对全局矩阵的贡献。我们通过仿射映射 $x(\\xi) = x_k + h\\xi$ 将该单元映射到参考单元 $\\hat{\\Omega}=[0,1]$，其中 $\\xi \\in [0,1]$。导数映射为 $\\frac{d}{dx} = \\frac{d\\xi}{dx} \\frac{d}{d\\xi} = \\frac{1}{h}\\frac{d}{d\\xi}$，微分元为 $dx = h\\,d\\xi$。参考单元上的局部基函数为 $\\psi_1(\\xi) = 1-\\xi$ 和 $\\psi_2(\\xi) = \\xi$，其导数分别为 $\\psi_1'(\\xi)=-1$ 和 $\\psi_2'(\\xi)=1$。\n\n单元刚度矩阵 $K^e$ 的分量为 $k^e_{mn}$：\n$$ k^e_{mn} = \\int_{0}^{1} \\left(\\frac{1}{h}\\frac{d\\psi_m}{d\\xi}\\right) \\left(\\frac{1}{h}\\frac{d\\psi_n}{d\\xi}\\right) (h\\,d\\xi) = \\frac{1}{h}\\int_{0}^{1} \\frac{d\\psi_m}{d\\xi}\\frac{d\\psi_n}{d\\xi}\\,d\\xi $$\n计算各分量：\n$k^e_{11} = \\frac{1}{h}\\int_{0}^{1} (-1)(-1) \\, d\\xi = \\frac{1}{h}$\n$k^e_{12} = \\frac{1}{h}\\int_{0}^{1} (-1)(1) \\, d\\xi = -\\frac{1}{h}$\n$k^e_{21} = \\frac{1}{h}\\int_{0}^{1} (1)(-1) \\, d\\xi = -\\frac{1}{h}$\n$k^e_{22} = \\frac{1}{h}\\int_{0}^{1} (1)(1) \\, d\\xi = \\frac{1}{h}$\n因此，单元刚度矩阵为：\n$$ K^e = \\frac{1}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} $$\n\n单元载荷向量 $F^e$ 的分量为 $f^e_m$：\n$$ f^e_m = \\int_{0}^{1} f(x(\\xi)) \\psi_m(\\xi) (h\\,d\\xi) $$\n已知 $f(x)=1$，则变为：\n$$ f^e_m = \\int_{0}^{1} (1) \\psi_m(\\xi) (h\\,d\\xi) = h \\int_{0}^{1} \\psi_m(\\xi) \\,d\\xi $$\n$f^e_1 = h \\int_{0}^{1} (1-\\xi) \\,d\\xi = h [\\xi - \\frac{\\xi^2}{2}]_0^1 = \\frac{h}{2}$\n$f^e_2 = h \\int_{0}^{1} \\xi \\,d\\xi = h [\\frac{\\xi^2}{2}]_0^1 = \\frac{h}{2}$\n因此，单元载荷向量为：\n$$ F^e = \\frac{h}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} $$\n\n为 $N=4$ 个单元和 $N+1=5$ 个节点（$0,1,2,3,4$）组装全局矩阵：\n$$ K = \\frac{1}{h} \\begin{pmatrix} 1 & -1 & 0 & 0 & 0 \\\\ -1 & 2 & -1 & 0 & 0 \\\\ 0 & -1 & 2 & -1 & 0 \\\\ 0 & 0 & -1 & 2 & -1 \\\\ 0 & 0 & 0 & -1 & 1 \\end{pmatrix} $$\n$$ F = \\begin{pmatrix} h/2 \\\\ h/2+h/2 \\\\ h/2+h/2 \\\\ h/2+h/2 \\\\ h/2 \\end{pmatrix} = \\begin{pmatrix} h/2 \\\\ h \\\\ h \\\\ h \\\\ h/2 \\end{pmatrix} $$\n\n完整的线性系统 $KU=F$ 为：\n$$ \\frac{1}{h} \\begin{pmatrix} 1 & -1 & 0 & 0 & 0 \\\\ -1 & 2 & -1 & 0 & 0 \\\\ 0 & -1 & 2 & -1 & 0 \\\\ 0 & 0 & -1 & 2 & -1 \\\\ 0 & 0 & 0 & -1 & 1 \\end{pmatrix} \\begin{pmatrix} U_0 \\\\ U_1 \\\\ U_2 \\\\ U_3 \\\\ U_4 \\end{pmatrix} = h \\begin{pmatrix} 1/2 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 1/2 \\end{pmatrix} $$\n\n现在我们施加狄利克雷边界条件 $u(0)=0 \\implies U_0=0$ 和 $u(1)=0 \\implies U_4=0$。使用消除法，我们移除与受约束自由度（$0$ 和 $4$）相对应的行和列，得到一个关于未知内部节点值 $U_1, U_2, U_3$ 的简化系统：\n$$ \\frac{1}{h} \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} \\begin{pmatrix} U_1 \\\\ U_2 \\\\ U_3 \\end{pmatrix} = h \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n两边乘以 $h$，我们得到：\n$$ \\begin{pmatrix} 2 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 2 \\end{pmatrix} \\begin{pmatrix} U_1 \\\\ U_2 \\\\ U_3 \\end{pmatrix} = h^2 \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix} $$\n由于 $h=1/4$，我们有 $h^2=1/16$。该方程组为：\n1. $2U_1 - U_2 = 1/16$\n2. $-U_1 + 2U_2 - U_3 = 1/16$\n3. $-U_2 + 2U_3 = 1/16$\n\n由于问题的对称性（均匀网格、均匀源项、对称域），我们可以推断出 $U_1 = U_3$。将此代入第二个方程，得到 $-2U_1 + 2U_2 = 1/16$。现在我们得到一个关于 $U_1$ 和 $U_2$ 的 $2 \\times 2$ 系统：\n$2U_1 - U_2 = 1/16$\n$-2U_1 + 2U_2 = 1/16$\n将这两个方程相加，得到：\n$$ (2U_1 - U_2) + (-2U_1 + 2U_2) = \\frac{1}{16} + \\frac{1}{16} $$\n$$ U_2 = \\frac{2}{16} = \\frac{1}{8} $$\n将 $U_2 = 1/8$ 代回第一个方程：\n$$ 2U_1 - \\frac{1}{8} = \\frac{1}{16} \\implies 2U_1 = \\frac{1}{8} + \\frac{1}{16} = \\frac{2}{16} + \\frac{1}{16} = \\frac{3}{16} \\implies U_1 = \\frac{3}{32} $$\n节点解的值为 $U_1=3/32$、$U_2=1/8$ 和 $U_3=3/32$。\n\n问题要求计算中点 $x=1/2$ 处的离散有限元近似解。该点对应于节点 $x_2$。根据定义，有限元解在节点处的值就是节点值本身：\n$$ u_h(x=1/2) = u_h(x_2) = U_2 $$\n因此，所求的值为 $U_2$。\n\n$$ U_2 = \\frac{1}{8} $$",
            "answer": "$$\\boxed{\\frac{1}{8}}$$"
        },
        {
            "introduction": "真实世界的组件很少具有简单的几何形状，因此精确建模复杂几何是数字孪生的一项关键挑战。本练习介绍了至关重要的等参映射概念，以四节点四边形单元为例。您将推导雅可比矩阵（Jacobian matrix），并分析单元变形如何影响插值精度，从而掌握使用有限元灵活处理复杂几何的强大技术。",
            "id": "4222514",
            "problem": "一个用于信息物理系统 (CPS) 的数字孪生 (DT) 使用有限元法 (FEM) 和双线性四节点（$4$-node）四边形等参单元来监控一个弹性膜。自然坐标为 $(\\xi,\\eta)\\in[-1,1]\\times[-1,1]$，采用标准节点排序 $1:(-1,-1)$, $2:(1,-1)$, $3:(1,1)$, $4:(-1,1)$。双线性形函数为\n$$\nN_{1}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta).\n$$\n物理坐标的等参映射定义为\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i},\\qquad\ny(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}.\n$$\n考虑一个由扭曲振幅 $\\alpha\\in\\mathbb{R}$ 参数化的几何扭曲单元族，其节点坐标为\n$$\n(x_{1},y_{1})=(0,0),\\quad (x_{2},y_{2})=(L,0),\\quad (x_{3},y_{3})=(L(1+\\alpha),H),\\quad (x_{4},y_{4})=(0,H),\n$$\n其中 $L>0$ 和 $H>0$ 分别是 $x$ 和 $y$ 方向上的特征长度。从上述基本定义出发，完成以下任务：\n\n1. 推导等参映射的雅可比矩阵，\n$$\nJ(\\xi,\\eta)=\n\\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta}\\\\[4pt]\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{pmatrix},\n$$\n用节点坐标和形函数导数的符号形式表示。\n\n2. 对于给定的扭曲单元，获得雅可比行列式 $\\det J(\\xi,\\eta)$ 的闭式表达式，作为 $L$、$H$、$\\alpha$ 和 $(\\xi,\\eta)$ 的函数。\n\n3. 使用由 $J(\\xi,\\eta)$ 编码的映射性质，解释非仿射扭曲（即 $\\alpha\\neq 0$）如何影响线性物理场 $u(x,y)=a\\,x+b\\,y+c$ 在双线性等参插值下的插值精度。你的解释应参考由 $J(\\xi,\\eta)$ 引起的度量的变化，以及线性场被精确再现的条件。\n\n作为最终答案，提交第 $2$ 部分中 $\\det J(\\xi,\\eta)$ 的解析表达式。不需要进行数值计算或四舍五入。",
            "solution": "该问题陈述是有限元法 (FEM) 基础知识方面一个定义明确的练习，特别涉及双线性四边形单元的等参映射性质。所有定义、数据和条件都已提供，科学上合理且内部一致。因此，该问题是有效的，可以推导出完整的解。\n\n解答按题目要求分为三个部分。\n\n### 第1部分：雅可比矩阵的推导\n\n等参映射通过形函数 $N_i(\\xi, \\eta)$ 和节点坐标 $(x_i, y_i)$ 将物理坐标 $(x, y)$ 与自然坐标 $(\\xi, \\eta)$ 联系起来：\n$$\nx(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,x_{i}\n$$\n$$\ny(\\xi,\\eta)=\\sum_{i=1}^{4}N_{i}(\\xi,\\eta)\\,y_{i}\n$$\n此变换的雅可比矩阵 $J(\\xi, \\eta)$ 定义为：\n$$\nJ(\\xi,\\eta)=\n\\begin{pmatrix}\n\\frac{\\partial x}{\\partial \\xi} & \\frac{\\partial x}{\\partial \\eta}\\\\[4pt]\n\\frac{\\partial y}{\\partial \\xi} & \\frac{\\partial y}{\\partial \\eta}\n\\end{pmatrix}\n$$\n雅可比矩阵的分量是通过对映射方程关于自然坐标求导得到的。应用链式法则，我们得到：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} x_i, \\qquad \\frac{\\partial x}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} x_i\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\xi} y_i, \\qquad \\frac{\\partial y}{\\partial \\eta} = \\sum_{i=1}^{4} \\frac{\\partial N_i}{\\partial \\eta} y_i\n$$\n为了继续，我们首先计算双线性形函数的偏导数：\n$$\nN_{1}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1-\\eta) \\quad \\implies \\quad \\frac{\\partial N_1}{\\partial \\xi} = -\\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_1}{\\partial \\eta} = -\\frac{1}{4}(1-\\xi)\n$$\n$$\nN_{2}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1-\\eta) \\quad \\implies \\quad \\frac{\\partial N_2}{\\partial \\xi} = \\frac{1}{4}(1-\\eta), \\quad \\frac{\\partial N_2}{\\partial \\eta} = -\\frac{1}{4}(1+\\xi)\n$$\n$$\nN_{3}(\\xi,\\eta)=\\frac{1}{4}(1+\\xi)(1+\\eta) \\quad \\implies \\quad \\frac{\\partial N_3}{\\partial \\xi} = \\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_3}{\\partial \\eta} = \\frac{1}{4}(1+\\xi)\n$$\n$$\nN_{4}(\\xi,\\eta)=\\frac{1}{4}(1-\\xi)(1+\\eta) \\quad \\implies \\quad \\frac{\\partial N_4}{\\partial \\xi} = -\\frac{1}{4}(1+\\eta), \\quad \\frac{\\partial N_4}{\\partial \\eta} = \\frac{1}{4}(1-\\xi)\n$$\n将这些代入雅可比分量的表达式中，即可得到以节点坐标 $(x_i, y_i)$ 和形函数导数表示的雅可比矩阵的一般符号形式。\n\n### 第2部分：扭曲单元的雅可比行列式\n\n现在我们专门研究由以下节点坐标定义的单元：\n$$\n(x_{1},y_{1})=(0,0),\\quad (x_{2},y_{2})=(L,0),\\quad (x_{3},y_{3})=(L(1+\\alpha),H),\\quad (x_{4},y_{4})=(0,H)\n$$\n其中 $L>0$ 且 $H>0$。我们计算雅可比矩阵 $J(\\xi, \\eta)$ 的每个分量。\n\n分量 $J_{11} = \\frac{\\partial x}{\\partial \\xi}$:\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{\\partial N_1}{\\partial \\xi}x_1 + \\frac{\\partial N_2}{\\partial \\xi}x_2 + \\frac{\\partial N_3}{\\partial \\xi}x_3 + \\frac{\\partial N_4}{\\partial \\xi}x_4\n$$\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\left(-\\frac{1}{4}(1-\\eta)\\right)(0) + \\left(\\frac{1}{4}(1-\\eta)\\right)(L) + \\left(\\frac{1}{4}(1+\\eta)\\right)(L(1+\\alpha)) + \\left(-\\frac{1}{4}(1+\\eta)\\right)(0)\n$$\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\frac{L}{4} \\left[ (1-\\eta) + (1+\\eta)(1+\\alpha) \\right] = \\frac{L}{4} \\left[ 1 - \\eta + 1 + \\eta + \\alpha + \\alpha\\eta \\right] = \\frac{L}{4}(2+\\alpha+\\alpha\\eta)\n$$\n\n分量 $J_{12} = \\frac{\\partial x}{\\partial \\eta}$:\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{\\partial N_1}{\\partial \\eta}x_1 + \\frac{\\partial N_2}{\\partial \\eta}x_2 + \\frac{\\partial N_3}{\\partial \\eta}x_3 + \\frac{\\partial N_4}{\\partial \\eta}x_4\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\left(-\\frac{1}{4}(1-\\xi)\\right)(0) + \\left(-\\frac{1}{4}(1+\\xi)\\right)(L) + \\left(\\frac{1}{4}(1+\\xi)\\right)(L(1+\\alpha)) + \\left(\\frac{1}{4}(1-\\xi)\\right)(0)\n$$\n$$\n\\frac{\\partial x}{\\partial \\eta} = \\frac{L}{4} \\left[ -(1+\\xi) + (1+\\xi)(1+\\alpha) \\right] = \\frac{L}{4} (1+\\xi) [-1 + 1+\\alpha] = \\frac{L \\alpha}{4}(1+\\xi)\n$$\n\n分量 $J_{21} = \\frac{\\partial y}{\\partial \\xi}$:\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{\\partial N_1}{\\partial \\xi}y_1 + \\frac{\\partial N_2}{\\partial \\xi}y_2 + \\frac{\\partial N_3}{\\partial \\xi}y_3 + \\frac{\\partial N_4}{\\partial \\xi}y_4\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\left(-\\frac{1}{4}(1-\\eta)\\right)(0) + \\left(\\frac{1}{4}(1-\\eta)\\right)(0) + \\left(\\frac{1}{4}(1+\\eta)\\right)(H) + \\left(-\\frac{1}{4}(1+\\eta)\\right)(H)\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\frac{H}{4} (1+\\eta) - \\frac{H}{4} (1+\\eta) = 0\n$$\n\n分量 $J_{22} = \\frac{\\partial y}{\\partial \\eta}$:\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{\\partial N_1}{\\partial \\eta}y_1 + \\frac{\\partial N_2}{\\partial \\eta}y_2 + \\frac{\\partial N_3}{\\partial \\eta}y_3 + \\frac{\\partial N_4}{\\partial \\eta}y_4\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\left(-\\frac{1}{4}(1-\\xi)\\right)(0) + \\left(-\\frac{1}{4}(1+\\xi)\\right)(0) + \\left(\\frac{1}{4}(1+\\xi)\\right)(H) + \\left(\\frac{1}{4}(1-\\xi)\\right)(H)\n$$\n$$\n\\frac{\\partial y}{\\partial \\eta} = \\frac{H}{4} \\left[ (1+\\xi) + (1-\\xi) \\right] = \\frac{H}{4}(2) = \\frac{H}{2}\n$$\n\n因此，雅可比矩阵为：\n$$\nJ(\\xi,\\eta)=\n\\begin{pmatrix}\n\\frac{L}{4}(2+\\alpha+\\alpha\\eta) & \\frac{L \\alpha}{4}(1+\\xi)\\\\[4pt]\n0 & \\frac{H}{2}\n\\end{pmatrix}\n$$\n雅可比行列式 $\\det J(\\xi,\\eta)$ 为：\n$$\n\\det J(\\xi,\\eta) = \\left( \\frac{L}{4}(2+\\alpha+\\alpha\\eta) \\right) \\left( \\frac{H}{2} \\right) - \\left( \\frac{L \\alpha}{4}(1+\\xi) \\right) (0)\n$$\n$$\n\\det J(\\xi,\\eta) = \\frac{LH}{8}(2+\\alpha+\\alpha\\eta)\n$$\n\n### 第3部分：非仿射扭曲对插值精度的影响\n\n使用等参格式对标量场 $u(x,y)$ 的插值由 $\\hat{u}(\\xi,\\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) u_i$ 给出，其中 $u_i = u(x_i, y_i)$。\n\n对于线性物理场 $u(x,y) = a\\,x+b\\,y+c$，插值场 $\\hat{u}$ 为：\n$$\n\\hat{u}(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi,\\eta) (a\\,x_i+b\\,y_i+c) = a \\sum_{i=1}^4 N_i x_i + b \\sum_{i=1}^4 N_i y_i + c \\sum_{i=1}^4 N_i\n$$\n根据等参映射的定义，$\\sum N_i x_i = x(\\xi,\\eta)$ 且 $\\sum N_i y_i = y(\\xi,\\eta)$。根据单位分解性质，$\\sum N_i = 1$。因此，\n$$\n\\hat{u}(\\xi, \\eta) = a\\,x(\\xi,\\eta) + b\\,y(\\xi,\\eta) + c = u(x(\\xi,\\eta), y(\\xi,\\eta))\n$$\n这表明双线性等参单元可以**精确地**再现任何线性场，无论几何扭曲如何（即对于任何 $\\alpha$）。\n\n当考虑场的*导数*（梯度）时，精度问题就出现了，这对于有限元法计算诸如应变或热通量等量至关重要。$u(x,y)$ 的真实梯度是恒定的：$(\\frac{\\partial u}{\\partial x}, \\frac{\\partial u}{\\partial y}) = (a, b)$。插值场的梯度使用逆雅可比矩阵计算：\n$$\n\\begin{pmatrix} \\frac{\\partial \\hat{u}}{\\partial x} \\\\ \\frac{\\partial \\hat{u}}{\\partial y} \\end{pmatrix} = J^{-1} \\begin{pmatrix} \\frac{\\partial \\hat{u}}{\\partial \\xi} \\\\ \\frac{\\partial \\hat{u}}{\\partial \\eta} \\end{pmatrix}\n$$\n由于 $\\hat{u}(\\xi,\\eta) = a\\,x(\\xi,\\eta)+b\\,y(\\xi,\\eta)+c$，其关于自然坐标的导数为 $\\frac{\\partial \\hat{u}}{\\partial \\xi} = a\\frac{\\partial x}{\\partial \\xi} + b\\frac{\\partial y}{\\partial \\xi}$ 和 $\\frac{\\partial \\hat{u}}{\\partial \\eta} = a\\frac{\\partial x}{\\partial \\eta} + b\\frac{\\partial y}{\\partial \\eta}$。用矩阵形式表示，即 $(\\frac{\\partial \\hat{u}}{\\partial \\xi}, \\frac{\\partial \\hat{u}}{\\partial \\eta})^T = J^T (a,b)^T$。\n将此代入梯度公式，得到：\n$$\n\\begin{pmatrix} \\frac{\\partial \\hat{u}}{\\partial x} \\\\ \\frac{\\partial \\hat{u}}{\\partial y} \\end{pmatrix} = J^{-1} J^T \\begin{pmatrix} a \\\\ b \\end{pmatrix}\n$$\n为了精确再现梯度，我们要求插值梯度等于 $(a,b)^T$。这当且仅当 $J^{-1}J^T = I$（单位矩阵）时成立，这意味着 $J^T = J$。雅可比矩阵必须是对称的。\n\n我们来检验一下我们的雅可比矩阵的对称性：\n$$\nJ(\\xi,\\eta)= \\begin{pmatrix} J_{11} & J_{12} \\\\ J_{21} & J_{22} \\end{pmatrix} =\n\\begin{pmatrix}\n\\frac{L}{4}(2+\\alpha+\\alpha\\eta) & \\frac{L \\alpha}{4}(1+\\xi)\\\\[4pt]\n0 & \\frac{H}{2}\n\\end{pmatrix}\n$$\n对称性要求 $J_{12} = J_{21}$。这意味着 $\\frac{L \\alpha}{4}(1+\\xi) = 0$。由于 $L>0$ 且此式必须对所有 $\\xi \\in [-1,1]$ 成立，该条件简化为 $\\alpha=0$。\n\n如果 $\\alpha=0$，单元是一个矩形（从参考正方形进行的仿射映射），$J=\\text{diag}(L/2, H/2)$ 是常数且对称的，恒定梯度可以被精确再现。\n如果 $\\alpha \\neq 0$，单元是一个非平行四边形的四边形，代表一个非仿射映射。雅可比矩阵 $J(\\xi,\\eta)$ 不是对称的，也不是常数。矩阵 $J^{-1}J^T$ 不是单位矩阵，其元素依赖于 $\\xi$ 和 $\\eta$。因此，计算出的梯度 $(\\frac{\\partial \\hat{u}}{\\partial x}, \\frac{\\partial \\hat{u}}{\\partial y})$ 在单元内不是常数，并且不等于真实梯度 $(a, b)$。\n\n总之，非仿射扭曲（$\\alpha \\neq 0$）会导致线性场*梯度*的插值精度损失。这种扭曲在单元上引入了一个非均匀的几何度量（与 $J^T J$ 相关），这意味着映射会非均匀地扭曲几何形状。虽然场值保持精确，但导数变成了位置的函数，因此是不精确的。这是扭曲等参单元的一个基本限制。",
            "answer": "$$\n\\boxed{\\frac{LH}{8}(2+\\alpha+\\alpha\\eta)}\n$$"
        },
        {
            "introduction": "为了使数字孪生能够精确预测其物理对应物的行为，高保真度的非线性模型是必不可少的。本练习将带您进入非线性分析领域，并介绍一种用于计算精确切线刚度矩阵的现代计算技术——自动微分（Automatic Differentiation, AD）。通过亲手实现并对比基于AD的牛顿法与传统有限差分法的性能，您将体会到鲁棒求解器对于可靠的数字孪生操作的决定性意义。",
            "id": "4222504",
            "problem": "考虑将自动微分（AD）嵌入到有限元法（FEM）代码中，为一个一维非线性杆模型计算精确的算法切线。该模型是信息物理系统（CPS）中数字孪生（DT）的本构核心。杆占据长度为 $L$ 的区间，具有恒定的横截面积 $A$，并使用 $n$ 个线性二节点单元进行离散化，节点位移汇集在向量 $u \\in \\mathbb{R}^{n+1}$ 中。左端固定，$u_0 = 0$，并在最右侧节点施加一个非零外力 $P$。材料响应由一个单调且光滑的非线性应力-应变关系 $\\sigma(\\varepsilon)$ 来表征。您的任务是从第一性原理出发，推导并实现牛顿法的残差和切线算子，然后比较基于AD的精确切线和有限差分切线的迭代次数和鲁棒性，并强调其对可靠的DT操作的影响。\n\n使用以下基本原理：\n- 一维杆在轴向载荷下的平衡弱形式要求内虚功与外虚功平衡。在每个长度为 $l_e$ 的单元上使用线性形函数，每个单元上的应变 $\\varepsilon_e$ 为常数，应力为 $\\sigma(\\varepsilon_e)$，则单元内力向量等于\n$$\nf_e = \\int_{0}^{l_e} B^\\top \\sigma(\\varepsilon_e) A \\, dx = A\\,l_e\\,B^\\top \\sigma(\\varepsilon_e),\n$$\n其中 $B = [-1/l_e,\\;1/l_e]$ 是二节点单元的应变-位移矩阵，$\\varepsilon_e = (u_j - u_i)/l_e$ 对应局部节点索引 $i$ 和 $j$。\n- 自由度的全局残差 $R(u)$ 等于组装后的内力贡献减去外力向量 $F_{\\text{ext}}$，牛顿更新求解\n$$\nK(u)\\,\\Delta u = -R(u), \\quad u \\leftarrow u + \\Delta u,\n$$\n其中 $K(u)$ 是由雅可比矩阵 $K(u) = \\frac{\\partial R}{\\partial u}$ 定义的切线刚度矩阵。\n- 自动微分（AD）可以通过算术运算精确地传播导数，以计算 $K(u)$，而无需符号推导或有限差分。\n\n采用无量纲本构律以专注于算法基础，避免物理单位：设应力由下式给出\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3,\n$$\n其中 $E$ 和 $\\alpha$ 是无量纲参数，$\\varepsilon$ 是无量纲工程应变，所有变量均为无量纲。离散化使用 $n$ 个等长段，因此 $l_e = L/n$。\n\n在完整的程序中实现以下内容：\n1. 使用单元公式和边界条件，为自由度组装全局残差 $R(u)$。对节点 $1,\\dots,n$ 使用未知数向量 $u_{\\text{free}} \\in \\mathbb{R}^n$，并固定 $u_0 = 0$。外力向量除最右侧的自由节点外处处为零，在该节点处其值等于 $P$。\n2. 实现两个切线算子：\n   - 一个基于AD的精确切线 $K_{\\text{AD}}(u)$，通过对自由度进行前向模式AD计算，其中每个标量变量携带一个长度为 $n$ 的导数向量。\n   - 一个有限差分切线 $K_{\\text{FD}}(u)$，对每个自由度使用中心差分和一个小的微扰量 $h$。\n3. 实现一个带有回溯线搜索的牛顿求解器，该求解器更新 $u$ 直到残差范数足够小。对 $K_{\\text{AD}}(u)$ 和 $K_{\\text{FD}}(u)$ 使用相同的求解器结构。\n4. 对于每个测试案例，报告AD和FD切线收敛所需的牛顿迭代总次数，并计算比率 $\\rho = \\text{iterations}_{\\text{FD}} / \\text{iterations}_{\\text{AD}}$（以浮点数形式）。\n\n使用以下无量纲测试套件来探究算法行为：\n- 案例A（理想情况，线性定律）：$n = \\,4$, $L = \\,1$, $A = \\,1$, $E = \\,1$, $\\alpha = \\,0$, $P = \\,1$。\n- 案例B（轻度非线性，中等网格）：$n = \\,8$, $L = \\,1$, $A = \\,1$, $E = \\,1$, $\\alpha = \\,10$, $P = \\,2$。\n- 案例C（较强非线性，更细网格）：$n = \\,16$, $L = \\,1$, $A = \\,1$, $E = \\,1$, $\\alpha = \\,100$, $P = \\,4$。\n- 案例D（较小面积的刚性响应，最细网格）：$n = \\,32$, $L = \\,1$, $A = \\,0.5$, $E = \\,1$, $\\alpha = \\,1000$, $P = \\,4$。\n\n在此一维轴向问题中，角度单位不适用。所有量均为无量纲数。\n\n您的程序应生成单行输出，其中包含案例A–D的比率 $\\rho$，格式为逗号分隔的列表，并用方括号括起来，例如 $[r_A,r_B,r_C,r_D]$，其中每个 $r_\\cdot$ 都是一个浮点数。不应打印任何其他文本。\n\n最终输出为浮点数，必须完全按照规定进行汇总。程序必须完全自包含，不需要用户输入，并且必须仅依赖于规定的库和Python标准库。",
            "solution": "用户提供了有效的问题陈述。\n\n### 引言与基于原理的公式化\n\n该问题要求为杆单元实现一个一维非线性有限元法（FEM）求解器。目标是比较当牛顿-拉夫逊求解器所需的切线刚度矩阵通过两种不同方法计算时的性能：自动微分（AD）和有限差分（FD）。性能通过收敛所需的迭代次数来衡量，这对信息物理系统（CPS）中数字孪生（DT）的效率和可靠性有直接影响，因为在这些系统中，快速而准确的模型更新至关重要。\n\n物理模型是一根长度为 $L$、面积为 $A$ 的杆，一端固定（$u_0=0$），另一端承受点载荷 $P$。材料表现出由以下本构律给出的非线性应力-应变响应：\n$$\n\\sigma(\\varepsilon) = E\\,\\varepsilon + \\alpha\\,\\varepsilon^3\n$$\n其中 $\\sigma$ 是无量纲应力，$\\varepsilon$ 是无量纲应变，而 $E$ 和 $\\alpha$ 是材料参数。该杆被离散化为 $n$ 个等长的线性二节点单元，长度为 $l_e = L/n$。\n\n### 残差向量组装\n\n系统的平衡由弱形式表达，即内力之和必须与外力平衡。对于一组节点位移 $u$，残差向量 $R(u)$ 代表了这种不平衡：\n$$\nR(u) = F_{\\text{int}}(u) - F_{\\text{ext}}\n$$\n其中 $F_{\\text{int}}(u)$ 是由单元贡献组装而成的内力向量，$F_{\\text{ext}}$ 是施加的外力向量。当 $R(u) = 0$ 时，系统处于平衡状态。\n\n对于连接节点 $i$ 和 $j$（位移分别为 $u_i$ 和 $u_j$）的单个单元 $e$，应变为常数：$\\varepsilon_e = (u_j - u_i) / l_e$。相应的应力为 $\\sigma_e = \\sigma(\\varepsilon_e)$。该单元的内力向量由下式给出：\n$$\nf_e = A\\, \\sigma_e \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\n该向量表示单元对其节点施加的力。全局内力向量 $F_{\\text{int}}$ 是通过在每个节点上对这些贡献求和来组装的。对于连接到单元 $k-1$（左侧）和单元 $k$（右侧）的内部节点 $k$，内力为 $F_{\\text{int}, k} = A(\\sigma_{k-1} - \\sigma_k)$。对于最右侧的自由节点 $n$，内力为 $F_{\\text{int}, n} = A\\sigma_{n-1}$。\n\n对应 $n$ 个自由度（节点 $1, \\dots, n$）的外力向量 $F_{\\text{ext}}$ 除了最后一个分量外处处为零，该分量对应于节点 $n$，其值为 $P$。\n\n### 切线刚度矩阵\n\n牛顿-拉夫逊法是一种寻找 $R(u)=0$ 根的迭代过程。它在当前位移估计 $u_k$ 处将系统线性化，并求解更新量 $\\Delta u$：\n$$\nK(u_k) \\, \\Delta u = -R(u_k)\n$$\n然后，新的位移为 $u_{k+1} = u_k + s\\,\\Delta u$，其中 $s$ 是由线搜索确定的步长。矩阵 $K(u)$ 是切线刚度矩阵，定义为残差相对于位移的雅可比矩阵：$K(u) = \\frac{\\partial R(u)}{\\partial u}$。\n\n单元切线刚度矩阵 $k_e$ 是单元力向量 $f_e$ 相对于单元节点位移 $[u_i, u_j]^\\top$ 的导数：\n$$\nk_e = \\frac{\\partial f_e}{\\partial [u_i, u_j]^\\top} = \\frac{A}{l_e} \\frac{\\partial \\sigma_e}{\\partial \\varepsilon_e} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\n项 $\\frac{\\partial \\sigma_e}{\\partial \\varepsilon_e}$ 是切线模量，$E_t = E + 3\\alpha\\varepsilon_e^2$。全局切线矩阵 $K(u)$ 是通过与力向量组装类似的方式由这些单元矩阵 $k_e$ 组装而成。\n\n### 算法切线实现\n\n**1. 自动微分（AD）切线，$K_{\\text{AD}}$**\n\nAD 计算以计算机程序形式指定的函数的精确导数。我们使用带有向量值导数的前向模式AD。我们定义一个 `Dual` 数类来同时表示一个值及其导数。一个变量 $x$ 由一对 $(x, \\dot{x})$ 表示，其中 $\\dot{x} = \\frac{\\partial x}{\\partial u_{\\text{free}}}$ 是一个大小为 $n$ 的向量。算术运算被重载以根据微积分法则传播导数：\n- $(x, \\dot{x}) + (y, \\dot{y}) = (x+y, \\dot{x}+\\dot{y})$\n- $(x, \\dot{x}) \\cdot (y, \\dot{y}) = (xy, x\\dot{y} + y\\dot{x})$\n- $(x, \\dot{x})^c = (x^c, c x^{c-1} \\dot{x})$\n\n为了在单次传递中计算完整的雅可比矩阵 $K = \\frac{\\partial R}{\\partial u_{\\text{free}}}$，我们“播种”输入向量 $u_{\\text{free}}$。每个分量 $u_j$ 都被初始化为一个 `Dual` 数，其值为其本身，导数向量为第 $j$ 个标准基向量 $e_j \\in \\mathbb{R}^n$。\n$$\nu_{\\text{free}, j} \\rightarrow \\text{Dual}(u_{\\text{free}, j}, e_j)\n$$\n然后，残差组装代码被精确执行一次。由于每个操作都被重载，输出的残差向量 $R$ 也将是一个 `Dual` 数的向量。第 $i$ 个分量将是 $\\text{Dual}(R_i, \\frac{\\partial R_i}{\\partial u_{\\text{free}}})$。第 $i$ 个对偶数的导数部分恰好是雅可比矩阵 $K_{\\text{AD}}$ 的第 $i$ 行。该方法产生精确（达到机器精度）的切线矩阵。\n\n**2. 有限差分（FD）切线，$K_{\\text{FD}}$**\n\nFD 通过在微扰点处评估函数来近似导数。切线矩阵的第 $j$ 列可以使用中心差分公式来近似：\n$$\nK_{FD, \\cdot j} = \\frac{\\partial R}{\\partial u_j} \\approx \\frac{R(u + h\\,e_j) - R(u - h\\,e_j)}{2h}\n$$\n其中 $h$ 是一个小的微扰步长（例如，$10^{-7}$），$e_j$ 是第 $j$ 个标准基向量。这种方法需要对残差函数进行 $2n$ 次评估才能构建完整的 $n \\times n$ 切线矩阵。其精度受到截断误差（来自公式）和舍入误差（来自两个相近数的相减）的影响，而 $h$ 的选择至关重要。\n\n### 牛顿求解器与比较\n\n实现了一个带有回溯线搜索的牛顿-拉夫逊求解器。线搜索减小步长 $s$（从 $s=1$ 开始），直到新残差的范数小于当前范数，从而确保向解收敛。求解器分别使用 $K_{\\text{AD}}$ 和 $K_{\\text{FD}}$ 运行。\n\n对于线性问题（案例A，$\\alpha=0$），两种方法都应产生精确的切线，并在一次迭代中收敛，得出比率 $\\rho=1.0$。对于非线性问题，$K_{\\text{AD}}$ 保持精确，保留了牛顿法的二次收敛速度。而 $K_{\\text{FD}}$ 是一个近似，这会使收敛速度最多降至超线性，并可能需要显著更多的迭代次数，尤其是在切线刚度变化迅速的强非线性情况下。比率 $\\rho = \\text{iterations}_{\\text{FD}} / \\text{iterations}_{\\text{AD}}$ 预计将 $\\ge 1$，更大的值表明基于AD的方法具有更优的鲁棒性和效率。这种鲁棒性对于数字孪生至关重要，因为它们必须在多样化甚至极端的操作条件下与其物理对应物保持同步。",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"A class to represent dual numbers for forward-mode automatic differentiation.\"\"\"\n    def __init__(self, value, derivative):\n        self.value = float(value)\n        self.derivative = np.array(derivative, dtype=float)\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value + other.value, self.derivative + other.derivative)\n        return Dual(self.value + other, self.derivative)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value - other.value, self.derivative - other.derivative)\n        return Dual(self.value - other, self.derivative)\n\n    def __rsub__(self, other):\n        return Dual(other - self.value, -self.derivative)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.value * other.value, self.value * other.derivative + other.value * self.derivative)\n        return Dual(self.value * other, other * self.derivative)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n    \n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            val = self.value / other.value\n            der = (self.derivative * other.value - self.value * other.derivative) / (other.value ** 2)\n            return Dual(val, der)\n        val = self.value / other\n        der = self.derivative / other\n        return Dual(val, der)\n\n    def __rtruediv__(self, other):\n        val = other / self.value\n        der = (-other * self.derivative) / (self.value ** 2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        if isinstance(power, (int, float)):\n            return Dual(self.value ** power, power * (self.value ** (power - 1)) * self.derivative)\n        raise NotImplementedError(\"Power for Dual numbers must be a scalar.\")\n\n    def __neg__(self):\n        return Dual(-self.value, -self.derivative)\n\ndef assemble_residual(u_free, n, L, A, E, alpha, P):\n    \"\"\"\n    Assembles the residual vector. Polymorphic to handle both floats and Dual numbers.\n    \"\"\"\n    num_free_dofs = n\n    l_e = L / n\n\n    if num_free_dofs > 0 and isinstance(u_free[0], Dual):\n        is_ad_mode = True\n        derivative_size = len(u_free[0].derivative)\n        zero_val = Dual(0.0, np.zeros(derivative_size))\n        u_full = [zero_val] + list(u_free)\n        F_int_full = [zero_val] * (n + 1)\n    else:\n        is_ad_mode = False\n        u_full = np.concatenate(([0.0], u_free))\n        F_int_full = np.zeros(n + 1)\n\n    for e in range(n):\n        u_i = u_full[e]\n        u_j = u_full[e+1]\n        \n        strain = (u_j - u_i) / l_e\n        stress = E * strain + alpha * strain**3\n        force_scalar = A * stress\n        \n        F_int_full[e] = F_int_full[e] - force_scalar\n        F_int_full[e+1] = F_int_full[e+1] + force_scalar\n\n    F_int_free = F_int_full[1:]\n\n    if is_ad_mode:\n        F_ext_free = [zero_val] * num_free_dofs\n        if P != 0:\n            F_ext_free[-1] = Dual(P, np.zeros(derivative_size))\n        R = [F_int_free[i] - F_ext_free[i] for i in range(num_free_dofs)]\n    else:\n        F_ext_free = np.zeros(num_free_dofs)\n        if P != 0:\n            F_ext_free[-1] = P\n        R = np.array(F_int_free) - F_ext_free\n        \n    return R\n\ndef get_tangent_ad(u_free, n, L, A, E, alpha, P):\n    \"\"\"Computes the residual and exact tangent stiffness matrix using AD.\"\"\"\n    num_free_dofs = len(u_free)\n    u_free_dual = [Dual(u_free[i], np.eye(1, num_free_dofs, i)[0]) for i in range(num_free_dofs)]\n    \n    R_dual = assemble_residual(u_free_dual, n, L, A, E, alpha, P)\n    \n    R_val = np.array([r.value for r in R_dual])\n    K = np.array([r.derivative for r in R_dual])\n    \n    return R_val, K\n\ndef get_tangent_fd(u_free, h, n, L, A, E, alpha, P):\n    \"\"\"Computes the residual and approximate tangent stiffness matrix using FD.\"\"\"\n    num_free_dofs = len(u_free)\n    K = np.zeros((num_free_dofs, num_free_dofs))\n    \n    R0 = assemble_residual(u_free, n, L, A, E, alpha, P)\n\n    for j in range(num_free_dofs):\n        u_plus = u_free.copy()\n        u_minus = u_free.copy()\n        u_plus[j] += h\n        u_minus[j] -= h\n        \n        R_plus = assemble_residual(u_plus, n, L, A, E, alpha, P)\n        R_minus = assemble_residual(u_minus, n, L, A, E, alpha, P)\n        \n        K[:, j] = (R_plus - R_minus) / (2 * h)\n        \n    return R0, K\n\ndef newton_solver(tangent_method, n, L, A, E, alpha, P):\n    \"\"\"\n    Performs Newton-Raphson iteration to solve the nonlinear system.\n    \"\"\"\n    u_free = np.zeros(n)\n    h_fd = 1e-7\n    max_iter = 50\n    tol = 1e-9\n\n    for i in range(max_iter):\n        if tangent_method == 'AD':\n            R, K = get_tangent_ad(u_free, n, L, A, E, alpha, P)\n        else: # 'FD'\n            R, K = get_tangent_fd(u_free, h_fd, n, L, A, E, alpha, P)\n        \n        res_norm = np.linalg.norm(R)\n        if res_norm < tol:\n            return i\n\n        try:\n            delta_u = np.linalg.solve(K, -R)\n        except np.linalg.LinAlgError:\n            return max_iter # Failure to solve\n\n        # Backtracking line search\n        s = 1.0\n        for _ in range(10): # Max 10 line search steps\n            u_try = u_free + s * delta_u\n            R_try = assemble_residual(u_try, n, L, A, E, alpha, P)\n            if np.linalg.norm(R_try) < res_norm:\n                break\n            s *= 0.5\n        \n        u_free = u_free + s * delta_u\n\n    return max_iter\n\ndef solve():\n    test_cases = [\n        (4, 1.0, 1.0, 1.0, 0.0, 1.0),    # Case A\n        (8, 1.0, 1.0, 1.0, 10.0, 2.0),   # Case B\n        (16, 1.0, 1.0, 1.0, 100.0, 4.0), # Case C\n        (32, 1.0, 0.5, 1.0, 1000.0, 4.0),# Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        n, L, A, E, alpha, P = params\n        \n        iterations_ad = newton_solver('AD', n, L, A, E, alpha, P)\n        if iterations_ad == 0: iterations_ad = 1 # Linear problem converges in 1 step from zero guess\n        \n        iterations_fd = newton_solver('FD', n, L, A, E, alpha, P)\n        if iterations_fd == 0: iterations_fd = 1\n\n        ratio = float(iterations_fd) / float(iterations_ad)\n        results.append(ratio)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}