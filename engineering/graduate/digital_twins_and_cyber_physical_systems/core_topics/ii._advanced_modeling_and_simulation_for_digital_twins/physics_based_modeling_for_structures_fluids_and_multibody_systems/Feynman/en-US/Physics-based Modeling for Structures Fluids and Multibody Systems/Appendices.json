{
    "hands_on_practices": [
        {
            "introduction": "A foundational skill in physics-based modeling is the ability to predict the dynamic behavior of structures. This practice focuses on the free vibration of an Euler-Bernoulli beam, a canonical problem in structural mechanics. By discretizing the governing partial differential equation using the Finite Element Method, you will assemble global stiffness and mass matrices to formulate a generalized eigenvalue problem, whose solution yields the natural frequencies and mode shapes of the structure . This exercise provides hands-on experience in implementing a complete FEM workflow, from element formulation to the application of boundary conditions for different support scenarios.",
            "id": "4235351",
            "problem": "Consider a one-dimensional Euler–Bernoulli beam model used within a Digital Twin for a Cyber-Physical System (CPS), in which a structural subsystem is represented by a physics-based finite element discretization. The goal is to assemble the global stiffness and mass matrices for a mesh of beam elements and to impose essential and natural boundary conditions consistently in the weak form. The task culminates in computing the smallest positive natural angular frequency for several boundary condition scenarios.\n\nUse the following fundamental base:\n- Newton’s second law of motion applied to continua and the Euler–Bernoulli kinematic assumption that cross-sections remain orthogonal to the neutral axis, leading to the governing equation for free transverse vibrations, $$E I \\, w''''(x,t) + \\rho A \\, \\ddot{w}(x,t) = 0,$$ where $w(x,t)$ is the transverse displacement, $E$ is the Young’s modulus (in $\\mathrm{Pa}$), $I$ is the second moment of area (in $\\mathrm{m^4}$), $\\rho$ is the mass density (in $\\mathrm{kg/m^3}$), and $A$ is the cross-sectional area (in $\\mathrm{m^2}$).\n- The weak form derived from the principle of virtual work or Hamilton’s principle, invoking suitable test functions and integration by parts, which reveals how essential and natural boundary conditions arise as constraints on trial functions and as boundary terms, respectively.\n\nDiscretize the beam domain of length $L$ into $N_{\\mathrm{e}}$ uniform two-node Euler–Bernoulli beam elements. Each node has two Degrees of Freedom (DOF): the transverse displacement $w$ (in $\\mathrm{m}$) and the rotation $\\theta = \\partial w / \\partial x$ (in radians). Use cubic Hermite interpolation for the element field approximation. Assemble the global stiffness matrix $K$ and the global mass matrix $M$ by summing the element contributions over the mesh. Do not introduce any artificial numerical damping or lumped mass approximations; use the consistent mass matrix derived from the kinetic energy.\n\nImpose boundary conditions as follows:\n- Essential (Dirichlet) boundary conditions are enforced on the global system by restricting the corresponding DOFs (e.g., removing rows and columns associated with constrained DOFs). Examples: clamped support applies $w = 0$ and $\\theta = 0$ at the support; simply supported applies $w = 0$ at the support while the bending moment condition is natural.\n- Natural (Neumann-type) boundary conditions enter through boundary terms in the weak form and, for free vibration without external boundary tractions, result in zero bending moment $M = E I \\, w''$ and zero shear force $V = - E I \\, w'''$ at free boundaries if not otherwise specified. For simply supported ends, the bending moment vanishes naturally.\n\nSolve the generalized eigenvalue problem $$K \\, \\phi = \\lambda \\, M \\, \\phi,$$ where $\\lambda = \\omega^2$ and $\\omega$ is the natural angular frequency (in $\\mathrm{rad/s}$). For each test case, compute the smallest positive $\\omega$.\n\nUse the following test suite, with all quantities in the International System of Units (SI):\n- Case $1$ (Cantilever, steel): $E = 210 \\times 10^9$, $I = 8 \\times 10^{-6}$, $\\rho = 7800$, $A = 3 \\times 10^{-3}$, $L = 2$, $N_{\\mathrm{e}} = 8$. Boundary conditions: clamped at $x = 0$ (essential $w(0)=0$, $\\theta(0)=0$), free at $x = L$ (natural $M(L)=0$, $V(L)=0$).\n- Case $2$ (Simply supported, steel): same $E$, $I$, $\\rho$, $A$, $L$, $N_{\\mathrm{e}}$ as Case $1$. Boundary conditions: simply supported at both $x=0$ and $x=L$ (essential $w(0)=0$, $w(L)=0$), with natural vanishing bending moment at both ends.\n- Case $3$ (Fixed–fixed, steel): same $E$, $I$, $\\rho$, $A$, $L$, $N_{\\mathrm{e}}$ as Case $1$. Boundary conditions: clamped at both $x=0$ and $x=L$ (essential $w(0)=0$, $\\theta(0)=0$, $w(L)=0$, $\\theta(L)=0$).\n- Case $4$ (Simply supported, aluminum, coarse mesh): $E = 70 \\times 10^9$, $I = 1 \\times 10^{-6}$, $\\rho = 2700$, $A = 5 \\times 10^{-4}$, $L = 1$, $N_{\\mathrm{e}} = 2$. Boundary conditions: simply supported at both ends.\n\nAngles must be treated in radians. Express the final angular frequencies in $\\mathrm{rad/s}$, each rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is the smallest positive natural angular frequency for the corresponding case (as a float in $\\mathrm{rad/s}$, rounded to six decimal places).",
            "solution": "The user-provided problem is assessed to be **valid**. It is scientifically grounded in the principles of structural mechanics, specifically Euler-Bernoulli beam theory and the Finite Element Method (FEM). The problem is well-posed, with all necessary parameters, boundary conditions, and material properties defined for each test case, ensuring a unique and meaningful solution can be obtained. The language is objective and unambiguous. We may therefore proceed to a solution.\n\nThe problem requires the computation of the fundamental natural angular frequency, $\\omega$, for a one-dimensional beam under various boundary conditions. This is achieved by solving the generalized eigenvalue problem derived from the finite element discretization of the governing partial differential equation for free transverse vibrations:\n$$\nE I \\frac{\\partial^4 w}{\\partial x^4}(x,t) + \\rho A \\frac{\\partial^2 w}{\\partial t^2}(x,t) = 0\n$$\nwhere $E$ is Young's modulus, $I$ is the second moment of area, $\\rho$ is the mass density, $A$ is the cross-sectional area, and $w(x,t)$ is the transverse displacement. Assuming harmonic motion, $w(x,t) = \\phi(x) e^{i\\omega t}$, the equation becomes an ordinary differential equation:\n$$\nE I \\frac{d^4 \\phi}{dx^4}(x) - \\rho A \\omega^2 \\phi(x) = 0\n$$\nThe Finite Element Method is based on the weak (variational) form of this equation. By multiplying by a test function $\\delta \\phi(x)$ and integrating over the domain length $L$, and then applying integration by parts twice, we obtain the weak form. This process naturally separates the terms into those related to strain energy and kinetic energy, and also reveals the essential (Dirichlet) and natural (Neumann) boundary conditions.\n\nThe domain of length $L$ is discretized into $N_{\\mathrm{e}}$ uniform finite elements, each of length $l_e = L/N_{\\mathrm{e}}$. For a two-node Euler-Bernoulli beam element, each node has two degrees of freedom (DOFs): a transverse displacement, $w$, and a rotation, $\\theta = dw/dx$. The nodal displacement vector for an element is $\\mathbf{d}_e = [w_i, \\theta_i, w_j, \\theta_j]^T$. The displacement field within the element is approximated using cubic Hermite shape functions $\\mathbf{N}(\\xi) = [N_1(\\xi), N_2(\\xi), N_3(\\xi), N_4(\\xi)]$, where $\\xi = x/l_e$ is the natural coordinate varying from $0$ to $1$:\n$$\nw(\\xi) = \\mathbf{N}(\\xi) \\mathbf{d}_e\n$$\nFrom the weak form, the element stiffness matrix, $\\mathbf{k}_e$, is derived from the strain energy contribution:\n$$\n\\mathbf{k}_e = \\int_{0}^{l_e} E I \\left( \\frac{d^2\\mathbf{N}}{dx^2} \\right)^T \\left( \\frac{d^2\\mathbf{N}}{dx^2} \\right) dx = \\frac{EI}{l_e^3}\n\\begin{pmatrix}\n12 & 6 l_e & -12 & 6 l_e \\\\\n6 l_e & 4 l_e^2 & -6 l_e & 2 l_e^2 \\\\\n-12 & -6 l_e & 12 & -6 l_e \\\\\n6 l_e & 2 l_e^2 & -6 l_e & 4 l_e^2\n\\end{pmatrix}\n$$\nThe consistent mass matrix, $\\mathbf{M}_e$, is derived from the kinetic energy contribution:\n$$\n\\mathbf{M}_e = \\int_{0}^{l_e} \\rho A \\mathbf{N}^T \\mathbf{N} dx = \\frac{\\rho A l_e}{420}\n\\begin{pmatrix}\n156 & 22 l_e & 54 & -13 l_e \\\\\n22 l_e & 4 l_e^2 & 13 l_e & -3 l_e^2 \\\\\n54 & 13 l_e & 156 & -22 l_e \\\\\n-13 l_e & -3 l_e^2 & -22 l_e & 4 l_e^2\n\\end{pmatrix}\n$$\nThe global stiffness matrix $\\mathbf{K}$ and global mass matrix $\\mathbf{M}$ are constructed by assembling the contributions from all $N_{\\mathrm{e}}$ elements. The total number of DOFs for the system of $N_e+1$ nodes is $N_{dof} = 2(N_e+1)$. The assembly process maps the local DOFs of each element to their corresponding global DOFs.\n\nThis procedure results in the global system of equations for free vibration, which is a generalized eigenvalue problem:\n$$\n\\mathbf{K} \\boldsymbol{\\phi} = \\lambda \\mathbf{M} \\boldsymbol{\\phi}\n$$\nwhere $\\boldsymbol{\\phi}$ is the global vector of nodal displacements and rotations, and $\\lambda = \\omega^2$ are the eigenvalues, representing the squares of the natural angular frequencies.\n\nEssential boundary conditions, such as those for clamped or simply supported ends, are constraints on the displacement or rotation DOFs. These are imposed by removing the rows and columns corresponding to the constrained DOFs from the global matrices $\\mathbf{K}$ and $\\mathbf{M}$. This yields a reduced, but still symmetric and positive-definite, system:\n$$\n\\mathbf{K}_{red} \\boldsymbol{\\phi}_{red} = \\lambda \\mathbf{M}_{red} \\boldsymbol{\\phi}_{red}\n$$\nThis reduced system is then solved numerically. For each case, we identify the constrained DOFs:\n- **Case 1 (Cantilever):** Clamped at $x=0$ (node $0$). DOFs for $w(0)$ and $\\theta(0)$ are constrained. These are global DOFs $0$ and $1$.\n- **Case 2 (Simply supported):** Simply supported at $x=0$ (node $0$) and $x=L$ (node $N_e$). DOFs for $w(0)$ and $w(L)$ are constrained. These are global DOFs $0$ and $2N_e$.\n- **Case 3 (Fixed-fixed):** Clamped at $x=0$ (node $0$) and $x=L$ (node $N_e$). DOFs for $w(0)$, $\\theta(0)$, $w(L)$, and $\\theta(L)$ are constrained. These are global DOFs $0$, $1$, $2N_e$, and $2N_e+1$.\n- **Case 4 (Simply supported):** Same as Case 2. DOFs $0$ and $2N_e$ are constrained.\n\nBy solving the eigenvalue problem for the reduced system, we obtain a set of eigenvalues $\\lambda_i$. The smallest positive eigenvalue, $\\lambda_{min}$, corresponds to the fundamental mode of vibration. The smallest positive natural angular frequency is then calculated as $\\omega = \\sqrt{\\lambda_{min}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef get_element_matrices(E, I, rho, A, le):\n    \"\"\"\n    Computes the element stiffness and consistent mass matrices for an Euler-Bernoulli beam.\n\n    Args:\n        E (float): Young's modulus.\n        I (float): Second moment of area.\n        rho (float): Mass density.\n        A (float): Cross-sectional area.\n        le (float): Element length.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the (4, 4) element stiffness matrix\n                                       and the (4, 4) element mass matrix.\n    \"\"\"\n    # Element stiffness matrix (ke)\n    c1 = E * I / le**3\n    ke = c1 * np.array([\n        [12, 6 * le, -12, 6 * le],\n        [6 * le, 4 * le**2, -6 * le, 2 * le**2],\n        [-12, -6 * le, 12, -6 * le],\n        [6 * le, 2 * le**2, -6 * le, 4 * le**2]\n    ])\n\n    # Element consistent mass matrix (me)\n    c2 = rho * A * le / 420\n    me = c2 * np.array([\n        [156, 22 * le, 54, -13 * le],\n        [22 * le, 4 * le**2, 13 * le, -3 * le**2],\n        [54, 13 * le, 156, -22 * le],\n        [-13 * le, -3 * le**2, -22 * le, 4 * le**2]\n    ])\n\n    return ke, me\n\ndef solve_beam_vibration(E, I, rho, A, L, Ne, bc_type):\n    \"\"\"\n    Assembles global matrices, applies boundary conditions, and solves for the\n    smallest positive natural angular frequency.\n\n    Args:\n        E (float): Young's modulus.\n        I (float): Second moment of area.\n        rho (float): Mass density.\n        A (float): Cross-sectional area.\n        L (float): Beam length.\n        Ne (int): Number of elements.\n        bc_type (str): Type of boundary condition ('cantilever', 'simply-supported', 'fixed-fixed').\n\n    Returns:\n        float: The smallest positive natural angular frequency in rad/s.\n    \"\"\"\n    # 1. Element properties and matrices\n    le = L / Ne\n    ke, me = get_element_matrices(E, I, rho, A, le)\n\n    # 2. Assembly of global matrices\n    num_nodes = Ne + 1\n    num_dofs = 2 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    M = np.zeros((num_dofs, num_dofs))\n\n    for i in range(Ne):\n        # Global DOF indices for element i (connecting nodes i and i+1)\n        dof_indices = np.array([2*i, 2*i + 1, 2*(i+1), 2*(i+1) + 1])\n        # Add element matrices to global matrices using np.ix_ for indexing\n        K[np.ix_(dof_indices, dof_indices)] += ke\n        M[np.ix_(dof_indices, dof_indices)] += me\n\n    # 3. Apply boundary conditions\n    all_dofs = np.arange(num_dofs)\n    constrained_dofs = []\n\n    if bc_type == 'cantilever':\n        # Clamped at x=0 (node 0): displacement and rotation are zero.\n        constrained_dofs = [0, 1]\n    elif bc_type == 'simply-supported':\n        # Simply supported at x=0 (node 0) and x=L (node Ne): displacements are zero.\n        constrained_dofs = [0, 2 * Ne]\n    elif bc_type == 'fixed-fixed':\n        # Clamped at x=0 (node 0) and x=L (node Ne): displacements and rotations are zero.\n        constrained_dofs = [0, 1, 2 * Ne, 2 * Ne + 1]\n\n    active_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n    \n    K_red = K[np.ix_(active_dofs, active_dofs)]\n    M_red = M[np.ix_(active_dofs, active_dofs)]\n\n    # 4. Solve the generalized eigenvalue problem\n    # eigh returns eigenvalues in ascending order.\n    eigenvalues, _ = eigh(K_red, M_red)\n\n    # 5. Find the smallest positive eigenvalue (lambda = omega^2)\n    # Filter out any non-positive values that might arise from numerical error\n    positive_eigenvalues = eigenvalues[eigenvalues > 1e-6]\n    \n    if len(positive_eigenvalues) == 0:\n        # This should not occur for the given non-trivial boundary conditions\n        return 0.0\n\n    lambda_min = positive_eigenvalues[0]\n\n    # 6. Calculate the smallest positive natural angular frequency (omega)\n    omega_min = np.sqrt(lambda_min)\n\n    return omega_min\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (Cantilever, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'cantilever'},\n        # Case 2 (Simply supported, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'simply-supported'},\n        # Case 3 (Fixed-fixed, steel)\n        {'E': 210e9, 'I': 8e-6, 'rho': 7800, 'A': 3e-3, 'L': 2.0, 'Ne': 8, 'bc_type': 'fixed-fixed'},\n        # Case 4 (Simply supported, aluminum, coarse mesh)\n        {'E': 70e9, 'I': 1e-6, 'rho': 2700, 'A': 5e-4, 'L': 1.0, 'Ne': 2, 'bc_type': 'simply-supported'},\n    ]\n\n    results = []\n    for params in test_cases:\n        omega = solve_beam_vibration(**params)\n        # Round and format as a string with 6 decimal places\n        results.append(f\"{omega:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Many real-world cyber-physical systems involve the interaction between different physical domains, such as fluids and structures. This exercise delves into the complexities of Fluid-Structure Interaction (FSI) using a simplified one-dimensional model that captures the essential challenges of partitioned coupling schemes . You will implement a Dirichlet-Neumann staggered algorithm, exploring the critical roles of under-relaxation and sub-iterations in stabilizing the solution, particularly in the presence of strong \"added-mass\" effects. This practice is crucial for understanding the numerical instabilities inherent in multiphysics simulations and the techniques used to overcome them.",
            "id": "4235330",
            "problem": "Consider a one-dimensional piston-like Fluid–Structure Interaction (FSI) model formulated in the Arbitrary Lagrangian–Eulerian (ALE) frame, where a rigid interface of a linear elastic structure of mass $m_s$ and stiffness $k_s$ moves in the axial direction of a fluid column of length $L$ and cross-sectional area $A$. The fluid has density $\\rho_f$ and is assumed incompressible with spatially uniform axial acceleration induced by the interface motion. Let the interface displacement at the end of the current time step be $u_{n+1}$, and let the previous two displacements be $u_n$ and $u_{n-1}$, respectively. The time step size is $\\Delta t$. The external fluid loading is a uniform far-field pressure $p_0$ producing a net interface force $F_{\\text{ext}} = p_0 A$. The fluid added-mass in this configuration is $M_a = \\rho_f A L$. The interface acceleration is discretized by the standard centered approximation $a(u_{n+1}) = \\dfrac{u_{n+1} - 2 u_n + u_{n-1}}{\\Delta t^2}$ in the ALE frame with mesh motion matching the piston.\n\nThe Dirichlet–Neumann staggered partitioned coupling proceeds in subiterations $k = 0,1,2,\\dots$ per time step as follows: given an interface displacement guess $u^{k}$, solve the fluid subproblem with the Dirichlet boundary condition provided by $u^{k}$ to obtain the interface traction $F_f^{k}$; then solve the structure subproblem with this traction as a Neumann boundary to obtain an updated interface displacement $u_{\\text{struct}}^{k+1}$. Under-relaxation is applied to stabilize the subiterations by setting $u^{k+1} = u^{k} + \\omega \\left(u_{\\text{struct}}^{k+1} - u^{k}\\right)$, with the relaxation factor $\\omega \\in (0,1]$. The subiterations are repeated $m$ times per time step. The coupling is deemed converged when $|u^{m} - u^{\\star}| \\le \\varepsilon$, where $u^{\\star}$ is the monolithic solution of the coupled problem at the end of the time step, and $\\varepsilon$ is a prescribed tolerance.\n\nStarting only from fundamental laws, derive a complete algorithm for one time step that:\n- models the fluid traction based on the uniform fluid added-mass $M_a$ and the ALE acceleration approximation,\n- models the structure dynamics by Newton’s second law and linear elasticity,\n- computes the monolithic coupled solution $u^{\\star}$ for the given time step,\n- implements the Dirichlet–Neumann staggered subiterations with under-relaxation,\n- checks convergence after $m$ subiterations against $u^{\\star}$ with tolerance $\\varepsilon$.\n\nUse the following physical base:\n- Newton’s second law $F = m a$ applied to both the fluid column and the structural degree-of-freedom,\n- incompressible fluid with uniform axial acceleration in a piston-like geometry,\n- linear elasticity with stiffness $k_s$ producing a restoring force $k_s u_{n+1}$,\n- centered acceleration approximation $a(u_{n+1}) = \\dfrac{u_{n+1} - 2 u_n + u_{n-1}}{\\Delta t^2}$.\n\nUnits must be consistent in the International System of Units (SI): express all given quantities in $\\mathrm{kg}$, $\\mathrm{m}$, $\\mathrm{s}$, and $\\mathrm{Pa}$, and compute the displacement in $\\mathrm{m}$. Angles are not used in this problem. The relaxation factor must be a unitless scalar and the convergence tolerance must be a positive scalar.\n\nYour program must implement the derived algorithm and evaluate the following test suite. In all cases use $u_n = 0\\,\\mathrm{m}$ and $u_{n-1} = 0\\,\\mathrm{m}$ and tolerance $\\varepsilon = 10^{-3}\\,\\mathrm{m}$. For clarity, each test case is a tuple $(\\rho_f, A, L, m_s, k_s, \\Delta t, \\omega, m, p_0)$:\n- Test Case $1$ (happy path, light fluid, stiff structure, small time step): $(\\rho_f = 1.2\\,\\mathrm{kg/m^3}, A = 0.01\\,\\mathrm{m^2}, L = 1.0\\,\\mathrm{m}, m_s = 1.0\\,\\mathrm{kg}, k_s = 100\\,\\mathrm{N/m}, \\Delta t = 0.01\\,\\mathrm{s}, \\omega = 1.0, m = 10, p_0 = 1000\\,\\mathrm{Pa})$.\n- Test Case $2$ (moderate fluid–structure density ratio, under-relaxation and many subiterations): $(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 10.0\\,\\mathrm{kg}, k_s = 1000\\,\\mathrm{N/m}, \\Delta t = 0.1\\,\\mathrm{s}, \\omega = 1.0, m = 40, p_0 = 1000\\,\\mathrm{Pa})$.\n- Test Case $3$ (destabilized by added mass, under-relaxation insufficient): $(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 8.0\\,\\mathrm{kg}, k_s = 100\\,\\mathrm{N/m}, \\Delta t = 0.05\\,\\mathrm{s}, \\omega = 0.5, m = 50, p_0 = 1000\\,\\mathrm{Pa})$.\n- Test Case $4$ (stabilized by structural stiffness and larger time step): $(\\rho_f = 1000\\,\\mathrm{kg/m^3}, A = 0.02\\,\\mathrm{m^2}, L = 0.8\\,\\mathrm{m}, m_s = 10.0\\,\\mathrm{kg}, k_s = 5000\\,\\mathrm{N/m}, \\Delta t = 0.2\\,\\mathrm{s}, \\omega = 1.0, m = 5, p_0 = 1000\\,\\mathrm{Pa})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases. Each result is a boolean indicating whether the coupling converged within the given tolerance after $m$ subiterations, i.e., the format must be exactly like $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right]$.",
            "solution": "The problem requires the derivation and implementation of a partitioned algorithm for a one-dimensional fluid-structure interaction (FSI) problem, and the validation of its convergence against a monolithic solution for several test cases. The derivation will proceed from the fundamental principles specified.\n\n### 1. Governing Equations\nLet $u(t)$ be the displacement of the solid interface at time $t$. The positive direction is taken along the axis of the fluid column. The problem involves a single time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$. We use the notation $u_{n+1}$, $u_n$, and $u_{n-1}$ for the displacements at times $t_{n+1}$, $t_n$, and $t_{n-1}$ respectively. The interface acceleration at time $t_{n+1}$ is approximated by a second-order centered difference scheme:\n$$a_{n+1} = \\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}$$\n\n#### a. Structure Dynamics\nThe structure is modeled as a linear mass-spring system. According to Newton's second law, the sum of forces on the structural mass $m_s$ equals its mass times acceleration. The forces are the elastic restoring force from the spring, $-k_s u_{n+1}$, and the force exerted by the fluid on the interface, $F_{\\text{fluid}}$.\n$$m_s a_{n+1} + k_s u_{n+1} = F_{\\text{fluid}}$$\nSubstituting the acceleration approximation, we get the discretized equation for the structure:\n$$m_s \\left(\\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u_{n+1} = F_{\\text{fluid}}$$\n\n#### b. Fluid Dynamics\nThe fluid is modeled as a rigid column of mass $M_a = \\rho_f A L$, known as the added mass. The fluid column's acceleration is identical to the interface acceleration, $a_{n+1}$, due to the incompressibility assumption and the piston-like geometry. The net force on the fluid column is the difference between the force at the interface (exerted by the structure) and the force at the far end (from the external pressure $p_0$). By Newton's third law, the force exerted by the structure on the fluid is $-F_{\\text{fluid}}$. The force from the far-field pressure is $p_0 A$. Thus, the net force on the fluid is $p_0 A - F_{\\text{fluid}}$.\n\nApplying Newton's second law to the fluid mass $M_a$:\n$$M_a a_{n+1} = p_0 A - F_{\\text{fluid}}$$\nThis equation can be rearranged to express the fluid force in terms of the system's motion and external pressure:\n$$F_{\\text{fluid}} = p_0 A - M_a a_{n+1}$$\nSubstituting the acceleration approximation:\n$$F_{\\text{fluid}} = p_0 A - M_a \\left(\\frac{u_{n+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right)$$\n\n### 2. Monolithic (Fully Coupled) Solution $u^{\\star}$\nThe monolithic solution, denoted $u^{\\star}$, is obtained by solving the fluid and structure equations simultaneously, ensuring that the displacement $u_{n+1}$ and the interface force $F_{\\text{fluid}}$ are consistent. We substitute the expression for $F_{\\text{fluid}}$ from the fluid equation into the structure equation:\n$$m_s a_{n+1} + k_s u_{n+1} = p_0 A - M_a a_{n+1}$$\nGrouping terms with acceleration $a_{n+1}$:\n$$(m_s + M_a) a_{n+1} + k_s u_{n+1} = p_0 A$$\nThis is the equation of motion for the fully coupled system. The total inertia is the sum of the structural mass and the fluid added mass, $m_s + M_a$. We now substitute the discrete approximation for acceleration, with $u_{n+1}$ replaced by $u^{\\star}$:\n$$(m_s + M_a) \\left(\\frac{u^{\\star} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u^{\\star} = p_0 A$$\nTo solve for $u^{\\star}$, we rearrange the terms:\n$$u^{\\star} \\left(\\frac{m_s + M_a}{\\Delta t^2} + k_s\\right) = p_0 A + \\frac{m_s + M_a}{\\Delta t^2}(2u_n - u_{n-1})$$\nThe monolithic solution for the displacement at the end of the time step is thus:\n$$u^{\\star} = \\frac{p_0 A + \\frac{m_s + M_a}{\\Delta t^2}(2u_n - u_{n-1})}{\\frac{m_s + M_a}{\\Delta t^2} + k_s}$$\n\n### 3. Dirichlet–Neumann Partitioned Algorithm\nThe partitioned scheme solves the fluid and structure subproblems iteratively within the time step. Let $k$ be the subiteration index.\n\n#### a. Fluid Subproblem (Dirichlet)\nGiven a guess for the interface displacement at subiteration $k$, $u_{n+1}^k$, we solve for the resulting fluid traction $F_f^k$. This is a Dirichlet problem for the fluid, as the boundary motion is prescribed. The fluid traction is defined as the total force exerted on the structure, which includes the external pressure effects transmitted through the fluid. The problem states that the fluid subproblem yields the interface traction $F_f^k$. Based on our derivation, the total force from the fluid on the structure is $F_{\\text{fluid}} = p_0 A - M_a a_{n+1}$. In the partitioned context, we define the fluid traction map as:\n$$F_f^k = p_0 A - M_a \\left(\\frac{u_{n+1}^k - 2u_n + u_{n-1}}{\\Delta t^2}\\right)$$\n\n#### b. Structure Subproblem (Neumann)\nGiven the fluid traction $F_f^k$ from the fluid solve, we solve for the structural displacement $u_{\\text{struct},n+1}^{k+1}$. This is a Neumann problem, as the boundary loading is prescribed.\n$$m_s \\left(\\frac{u_{\\text{struct},n+1}^{k+1} - 2u_n + u_{n-1}}{\\Delta t^2}\\right) + k_s u_{\\text{struct},n+1}^{k+1} = F_f^k$$\nSolving for $u_{\\text{struct},n+1}^{k+1}$:\n$$u_{\\text{struct},n+1}^{k+1} = \\frac{F_f^k + \\frac{m_s}{\\Delta t^2}(2u_n - u_{n-1})}{\\frac{m_s}{\\Delta t^2} + k_s}$$\n\n#### c. Under-relaxation\nTo stabilize the subiterations, especially in cases with strong added-mass effects, the updated displacement guess $u_{n+1}^{k+1}$ is computed as a weighted average of the previous guess and the new structural displacement:\n$$u_{n+1}^{k+1} = u_{n+1}^k + \\omega \\left(u_{\\text{struct},n+1}^{k+1} - u_{n+1}^k\\right) = (1-\\omega)u_{n+1}^k + \\omega u_{\\text{struct},n+1}^{k+1}$$\nwhere $\\omega \\in (0, 1]$ is the relaxation factor.\n\n### 4. Algorithm for One Time Step\nBased on the derivations above, the algorithm to be implemented is as follows:\n\n1.  **Inputs**: $\\rho_f, A, L, m_s, k_s, \\Delta t, \\omega, m, p_0$, and previous displacements $u_n, u_{n-1}$. For this problem, $u_n=0$ and $u_{n-1}=0$. The tolerance is $\\varepsilon=10^{-3}$.\n2.  **Initialization**:\n    *   Calculate added mass: $M_a = \\rho_f A L$.\n    *   Calculate external force term: $F_{\\text{ext}} = p_0 A$.\n    *   Define historical displacement term: $U_{\\text{hist}} = 2u_n - u_{n-1}$.\n3.  **Calculate Monolithic Solution**: Compute $u^{\\star}$ using its derived formula.\n$$u^{\\star} = \\frac{p_0 A + \\frac{m_s + M_a}{\\Delta t^2} U_{\\text{hist}}}{\\frac{m_s + M_a}{\\Delta t^2} + k_s}$$\n4.  **Partitioned Subiterations**:\n    *   Initialize the displacement guess: $u_{n+1}^0 = u_n$.\n    *   Loop for $k$ from $0$ to $m-1$:\n        i.  **Fluid Solve**: Compute traction $F_f^k$ using $u_{n+1}^k$.\n            $$F_f^k = F_{\\text{ext}} - M_a \\left(\\frac{u_{n+1}^k - U_{\\text{hist}}}{\\Delta t^2}\\right)$$\n        ii. **Structure Solve**: Compute $u_{\\text{struct},n+1}^{k+1}$ using $F_f^k$.\n            $$u_{\\text{struct},n+1}^{k+1} = \\frac{F_f^k + \\frac{m_s}{\\Delta t^2} U_{\\text{hist}}}{\\frac{m_s}{\\Delta t^2} + k_s}$$\n        iii. **Relaxation**: Update the displacement guess for the next subiteration.\n            $$u_{n+1}^{k+1} = (1-\\omega)u_{n+1}^k + \\omega u_{\\text{struct},n+1}^{k+1}$$\n5.  **Convergence Check**: After $m$ iterations, the final iterated solution is $u_{n+1}^m$. Check if the convergence criterion is met:\n    $$|u_{n+1}^m - u^{\\star}| \\le \\varepsilon$$\n6.  **Output**: Return `True` if the criterion is met, `False` otherwise.\nThis structured algorithm will be implemented for each provided test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_fsi_simulation(params):\n    \"\"\"\n    Solves one time step of a 1D FSI problem using a partitioned scheme\n    and checks for convergence against the monolithic solution.\n\n    Args:\n        params (tuple): A tuple containing the physical and numerical parameters:\n            (rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0, u_n, u_n_minus_1, epsilon)\n\n    Returns:\n        bool: True if the partitioned scheme converged within m iterations, False otherwise.\n    \"\"\"\n    rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0, u_n, u_n_minus_1, epsilon = params\n\n    # 1. Initialization and pre-calculations\n    # Added mass of the fluid column\n    M_a = rho_f * A * L\n    # Total effective mass of the coupled system\n    M_tot = m_s + M_a\n    # External force from far-field pressure\n    F_ext = p_0 * A\n    # Historical displacement term from previous time steps\n    U_hist = 2 * u_n - u_n_minus_1\n    \n    # Coefficients for discretized equations\n    # Inertial coefficient for the total system\n    C_M_tot_dt2 = M_tot / (delta_t**2)\n    # Inertial coefficient for the structure\n    C_ms_dt2 = m_s / (delta_t**2)\n    # Inertial coefficient for the fluid (added mass)\n    C_Ma_dt2 = M_a / (delta_t**2)\n\n    # 2. Compute the monolithic (fully coupled) solution u_star\n    # Denominator of the monolithic solution expression\n    denom_star = C_M_tot_dt2 + k_s\n    # Numerator of the monolithic solution expression\n    num_star = F_ext + C_M_tot_dt2 * U_hist\n    \n    # Handle the case where the denominator is zero to avoid division by zero\n    if denom_star == 0:\n        # This physical configuration would imply an unconstrained system,\n        # which is not expected for the given problems.\n        # But as a safeguard: If numerator is also zero, any displacement is a solution (ill-posed).\n        # If numerator is non-zero, no solution exists. In either case, it's problematic.\n        # For the purpose of this problem, let's treat this as a failure.\n        return False\n        \n    u_star = num_star / denom_star\n\n    # 3. Perform partitioned subiterations\n    # Initialize the displacement guess for the current time step n+1\n    u_k = u_n \n    \n    # Effective stiffness of the structure sub-problem\n    S_s = C_ms_dt2 + k_s\n\n    for _ in range(m):\n        # a. Fluid subproblem: Given u_k, calculate fluid traction F_f_k\n        # This is the force the fluid exerts on the structure.\n        F_f_k = F_ext - C_Ma_dt2 * (u_k - U_hist)\n\n        # b. Structure subproblem: Given F_f_k, calculate new displacement u_struct_k_plus_1\n        # Denominator is the effective stiffness S_s.\n        if S_s == 0:\n            # Another safeguard for a physically unconstrained structural subproblem.\n            return False\n            \n        u_struct_k_plus_1 = (F_f_k + C_ms_dt2 * U_hist) / S_s\n\n        # c. Under-relaxation: Update the displacement guess for the next iteration\n        u_k_plus_1 = (1.0 - omega) * u_k + omega * u_struct_k_plus_1\n        u_k = u_k_plus_1\n        \n        # Check for non-physical divergence (overflow)\n        if not np.isfinite(u_k):\n            return False\n\n    # The final iterated displacement after m subiterations\n    u_m = u_k\n    \n    # 4. Convergence check\n    # Check if the absolute difference between the final iterated solution\n    # and the monolithic solution is within the prescribed tolerance.\n    converged = abs(u_m - u_star) = epsilon\n    \n    return converged\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Common parameters for all test cases\n    u_n = 0.0  # m\n    u_n_minus_1 = 0.0  # m\n    epsilon = 1e-3  # m\n\n    # Test cases: (rho_f, A, L, m_s, k_s, delta_t, omega, m, p_0)\n    test_cases_params = [\n        (1.2, 0.01, 1.0, 1.0, 100, 0.01, 1.0, 10, 1000),  # Case 1\n        (1000, 0.02, 0.8, 10.0, 1000, 0.1, 1.0, 40, 1000), # Case 2\n        (1000, 0.02, 0.8, 8.0, 100, 0.05, 0.5, 50, 1000), # Case 3\n        (1000, 0.02, 0.8, 10.0, 5000, 0.2, 1.0, 5, 1000),  # Case 4\n    ]\n\n    # Append common parameters to each test case tuple\n    test_cases = [params + (u_n, u_n_minus_1, epsilon) for params in test_cases_params]\n\n    results = []\n    for case in test_cases:\n        result = run_fsi_simulation(case)\n        results.append(str(result).lower()) # Convert boolean to lowercase string 'true'/'false'\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While high-fidelity physics-based models provide accuracy, their computational cost can be prohibitive for the real-time decision-making required by digital twins. This hands-on practice introduces Reduced Order Modeling (ROM), a powerful technique for creating computationally efficient surrogate models. You will implement a full model reduction pipeline for a parameterized elastic bar, starting from a finite element discretization and constructing a low-dimensional basis using a greedy algorithm that iteratively samples the parameter space . This exercise demonstrates how to build a real-time ROM that preserves parametric dependencies, a key enabling technology for predictive digital twins.",
            "id": "4235354",
            "problem": "Consider a one-dimensional linear elastic rod as a canonical cyber-physical system to ground a Reduced Order Model (ROM) for a digital twin. The rod occupies the spatial domain $[0,1]$, has constant cross-sectional area $A=1$, and is subject to a uniform body force $q=1$. Its static equilibrium follows from force balance and the constitutive relation of linear elasticity: the Cauchy stress $\\sigma$ satisfies $\\frac{d}{dx}\\sigma + b = 0$ with body force density $b=q$, and the stress–strain relationship is $\\sigma(x) = E(x;\\mu)\\,\\epsilon(x)$ with strain $\\epsilon(x) = \\frac{du}{dx}$. Combining these, the governing strong form of the boundary-value problem is the second-order differential equation\n$$\n-\\frac{d}{dx}\\Big(E(x;\\mu)\\,\\frac{du}{dx}\\Big) = q,\\quad x\\in(0,1),\n$$\nwith boundary conditions $u(0)=0$ (essential boundary condition) and $\\sigma(1)=E(1;\\mu)\\,u'(1)=0$ (natural traction-free boundary condition). The parameter vector $\\mu=(\\mu_1,\\mu_2)$ controls a piecewise-constant Young’s modulus $E(x;\\mu)$ such that $E(x;\\mu)=\\mu_1$ for $x\\in[0,0.5]$ and $E(x;\\mu)=\\mu_2$ for $x\\in(0.5,1]$. The resulting discretized operator is symmetric positive definite (SPD), enabling stable model reduction.\n\nStarting from the fundamental weak form, find $u\\in V$ such that for all test functions $v\\in V$,\n$$\n\\int_{0}^{1} E(x;\\mu)\\,\\frac{du}{dx}\\,\\frac{dv}{dx}\\,dx = \\int_{0}^{1} q\\,v\\,dx,\n$$\nwhere $V=\\{v\\in H^1(0,1)\\mid v(0)=0\\}$. Approximate $u$ by a piecewise-linear finite element discretization on a uniform mesh of $N$ elements with nodes $\\{x_i\\}_{i=0}^{N}$, $x_i = i/N$, and remove the essential boundary degree of freedom $u(0)=0$ to obtain a reduced linear system\n$$\nA(\\mu)\\,u(\\mu) = f,\n$$\nwhere $A(\\mu)\\in\\mathbb{R}^{n\\times n}$ is SPD, $n=N$, $u(\\mu)\\in\\mathbb{R}^{n}$ are the free nodal displacements, and $f\\in\\mathbb{R}^{n}$ is the load vector from the uniform body force. By the spatial partition of $E(x;\\mu)$, the stiffness operator admits an affine decomposition\n$$\nA(\\mu) = \\mu_1\\,K_1 + \\mu_2\\,K_2,\n$$\nwhere $K_1$ and $K_2$ are the stiffness matrices assembled from the left half $[0,0.5]$ and right half $(0.5,1]$ of the domain, respectively, using standard linear finite elements. Let the load be assembled from $q=1$ using the standard element load vector formula consistent with the weak form and the chosen basis.\n\nDefine the Reduced Order Model (ROM) subspace $V_r = \\operatorname{span}\\{ \\phi_1,\\dots,\\phi_r\\}$, where $\\{\\phi_j\\}$ are orthonormal basis vectors obtained by a greedy algorithm over a training parameter set. For any parameter $\\mu$, the ROM solution $\\hat{u}(\\mu)\\in V_r$ is computed by solving the reduced system\n$$\nA_r(\\mu)\\,a(\\mu) = V^\\top f,\\quad A_r(\\mu) = V^\\top A(\\mu)\\,V = \\mu_1\\,K_{1,r} + \\mu_2\\,K_{2,r},\n$$\nwhere $V=[\\phi_1\\,\\cdots\\,\\phi_r]\\in\\mathbb{R}^{n\\times r}$, $K_{1,r}=V^\\top K_1 V$, and $K_{2,r}=V^\\top K_2 V$. The ROM state is then $\\hat{u}(\\mu)=V\\,a(\\mu)$. The greedy algorithm constructs $V$ iteratively by selecting parameters that maximize an a posteriori residual-based error indicator. Specifically, at iteration $k$ with current basis $V_k$, for each $\\mu$ in the training set, compute the reduced solution $\\hat{u}_k(\\mu)$ and the residual $r_k(\\mu) = f - A(\\mu)\\,\\hat{u}_k(\\mu)$. Select the next parameter $\\mu^{(k+1)}$ that maximizes $\\|r_k(\\mu)\\|_2$, compute the full-order solution $u(\\mu^{(k+1)})$, orthonormalize it against $V_k$, and augment the basis.\n\nYour task is to implement the following end-to-end pipeline:\n- Assemble the linear finite element model for the described rod with $N=60$ elements, $A=1$, and $q=1$, enforcing the boundary conditions $u(0)=0$ and traction-free at $x=1$. Construct the affine stiffness decomposition $A(\\mu)=\\mu_1 K_1 + \\mu_2 K_2$ with $K_1$ and $K_2$ corresponding to the left and right halves of the domain.\n- Define a uniform training parameter grid $\\mathcal{P}_{\\text{train}} = \\{\\mu_1^i\\}\\times\\{\\mu_2^j\\}$ with $\\mu_1^i$ and $\\mu_2^j$ linearly spaced in $[0.5,5.0]$ using $8$ points per dimension, and initialize the greedy algorithm at the center parameter $\\mu^{(1)}=(2.75,2.75)$.\n- Run a greedy basis construction up to a maximum of $r_{\\max}=8$ basis vectors or until the maximum residual norm over $\\mathcal{P}_{\\text{train}}$ drops below a tolerance $\\varepsilon=10^{-8}$.\n- Precompute the reduced operators $K_{1,r}$ and $K_{2,r}$ and use them to evaluate $A_r(\\mu)$ via interpolation for real-time twin updates.\n- For the test suite below, compute the full-order solution $u(\\mu)$ and the ROM solution $\\hat{u}(\\mu)$, and report the relative error\n$$\ne(\\mu) = \\frac{\\|u(\\mu) - \\hat{u}(\\mu)\\|_2}{\\|u(\\mu)\\|_2}.\n$$\nAll quantities are dimensionless, and norms are standard Euclidean norms.\n\nUse the following test suite of parameter values:\n1. $\\mu=(0.5,0.5)$,\n2. $\\mu=(5.0,5.0)$,\n3. $\\mu=(0.5,5.0)$,\n4. $\\mu=(5.0,0.5)$,\n5. $\\mu=(2.0,3.5)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e(\\mu^{(1)}),e(\\mu^{(2)}),\\dots]$). The outputs must be floats corresponding to the five test cases, in the order listed above.",
            "solution": "The problem requires the implementation of a reduced order modeling pipeline for a one-dimensional linear elastic bar. The process involves three main stages: first, the formulation of a high-fidelity finite element model (FEM); second, the construction of a reduced basis using a greedy algorithm; and third, the evaluation of the resulting reduced order model (ROM) against test cases.\n\n### 1. Finite Element Model (FEM) Assembly\n\nThe governing equation for the static displacement $u(x)$ of the bar is a second-order boundary value problem:\n$$\n-\\frac{d}{dx}\\Big(E(x;\\mu)\\,\\frac{du}{dx}\\Big) = q,\\quad x\\in(0,1),\n$$\nwith boundary conditions $u(0)=0$ and $E(1;\\mu)u'(1)=0$. The Young's modulus $E(x;\\mu)$ is piecewise constant, controlled by the parameter vector $\\mu=(\\mu_1, \\mu_2)$.\n\nTo solve this numerically, we first derive the weak form by multiplying by a test function $v(x)$ from the space $V=\\{v\\in H^1(0,1)\\mid v(0)=0\\}$ and integrating over the domain. Using integration by parts and applying the boundary conditions, we obtain:\n$$\n\\int_{0}^{1} E(x;\\mu)\\,\\frac{du}{dx}\\,\\frac{dv}{dx}\\,dx = \\int_{0}^{1} q\\,v\\,dx, \\quad \\forall v \\in V.\n$$\nThe domain $[0,1]$ is discretized into $N=60$ uniform finite elements of length $h=1/N = 1/60$. The displacement field $u(x)$ is approximated by a sum of piecewise-linear basis functions (hat functions) $N_i(x)$: $u_h(x) = \\sum_{i=0}^{N} u_i N_i(x)$. Since $u(0)=0$, the degree of freedom $u_0$ is fixed, and the unknown solution vector consists of the nodal displacements $u = [u_1, u_2, \\dots, u_N]^\\top \\in \\mathbb{R}^N$.\n\nSubstituting the approximation into the weak form leads to the linear system $A(\\mu)u(\\mu)=f$. The problem states that the stiffness matrix $A(\\mu)$ has an affine parametric dependence: $A(\\mu) = \\mu_1 K_1 + \\mu_2 K_2$.\n- $K_1$ is the stiffness matrix contribution from the left half of the domain, $x\\in[0,0.5]$, where $E(x;\\mu)=\\mu_1$.\n- $K_2$ is the stiffness matrix contribution from the right half, $x\\in(0.5,1]$, where $E(x;\\mu)=\\mu_2$.\n\nThese matrices are assembled using the standard linear element stiffness matrix for an element of length $h_e$ and unit Young's modulus, which is $k_e = \\frac{1}{h_e}\\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}$. Here, $h_e=h=1/60$.\n- $K_1$ is assembled from the first $N/2=30$ elements (from node $0$ to $30$).\n- $K_2$ is assembled from the last $N/2=30$ elements (from node $30$ to $60$).\nThe system matrices are of size $n \\times n$ where $n=N=60$.\n\nThe force vector $f \\in \\mathbb{R}^N$ is assembled from the right-hand side of the weak form, $\\int_0^1 q v dx$. For a uniform load $q=1$, the entry $f_i$ corresponding to node $i$ is $f_i = \\int_0^1 q N_i(x) dx$. For an interior node $i \\in \\{1,\\dots,N-1\\}$, $f_i=qh=1/60$. For the natural boundary node $i=N$, $f_N = qh/2 = 1/120$.\n\n### 2. Greedy Algorithm for Basis Construction\n\nThe goal of the ROM is to approximate the full-order solution $u(\\mu)$ as a linear combination of a few basis vectors, $\\hat{u}(\\mu) = V a(\\mu)$, where $V \\in \\mathbb{R}^{n \\times r}$ is a matrix whose columns $\\{\\phi_j\\}_{j=1}^r$ form an orthonormal basis for the reduced space, and $r \\ll n$. The basis $V$ is constructed iteratively using a weak greedy algorithm.\n\nThe procedure is as follows:\n1.  **Initialization**: The algorithm is initialized with the parameter $\\mu^{(1)}=(2.75, 2.75)$. The full-order solution $u(\\mu^{(1)})$ is computed by solving $A(\\mu^{(1)})u(\\mu^{(1)})=f$. The first basis vector is the normalized solution: $\\phi_1 = u(\\mu^{(1)}) / \\|u(\\mu^{(1)})\\|_2$. The basis is $V_1 = [\\phi_1]$.\n2.  **Iteration**: For each step $k=1, \\dots, r_{\\max}-1$:\n    a.  **Error Estimation**: For each parameter $\\mu$ in a discrete training set $\\mathcal{P}_{\\text{train}}$, the ROM solution $\\hat{u}_k(\\mu) = V_k (V_k^\\top A(\\mu) V_k)^{-1} V_k^\\top f$ is computed. The quality of this approximation is measured by the Euclidean norm of the residual vector, $\\|r_k(\\mu)\\|_2 = \\|f - A(\\mu)\\hat{u}_k(\\mu)\\|_2$.\n    b.  **Parameter Selection**: The next parameter for basis enrichment, $\\mu^{(k+1)}$, is chosen to be the one that maximizes this residual norm over the training set: $\\mu^{(k+1)} = \\arg\\max_{\\mu \\in \\mathcal{P}_{\\text{train}}} \\|r_k(\\mu)\\|_2$.\n    c.  **Termination Check**: If the maximum residual norm over $\\mathcal{P}_{\\text{train}}$ falls below a tolerance $\\varepsilon=10^{-8}$, the algorithm terminates.\n    d.  **Basis Augmentation**: A \"snapshot\" solution $u(\\mu^{(k+1)})$ is computed. This snapshot is then made orthogonal to the existing basis vectors in $V_k$ using the Modified Gram-Schmidt procedure: $\\tilde{\\phi}_{k+1} = u(\\mu^{(k+1)}) - V_k V_k^\\top u(\\mu^{(k+1)})$. The new basis vector is the normalized result: $\\phi_{k+1} = \\tilde{\\phi}_{k+1} / \\|\\tilde{\\phi}_{k+1}\\|_2$. The basis is augmented: $V_{k+1} = [V_k, \\phi_{k+1}]$.\nThe process continues until the basis size reaches $r_{\\max}=8$ or the error tolerance is met. The training set $\\mathcal{P}_{\\text{train}}$ is a uniform grid of $8 \\times 8 = 64$ points over the parameter domain $[\\mu_1, \\mu_2] \\in [0.5, 5.0] \\times [0.5, 5.0]$.\n\n### 3. ROM Evaluation\n\nOnce the final basis $V$ of size $n \\times r$ is constructed, the reduced operators are pre-computed:\n$$\nK_{1,r} = V^\\top K_1 V \\in \\mathbb{R}^{r \\times r}\n$$\n$$\nK_{2,r} = V^\\top K_2 V \\in \\mathbb{R}^{r \\times r}\n$$\n$$\nf_r = V^\\top f \\in \\mathbb{R}^{r}\n$$\nFor any new parameter $\\mu_{\\text{test}}$, the ROM provides a real-time solution. The reduced stiffness matrix is assembled efficiently as $A_r(\\mu_{\\text{test}}) = \\mu_1 K_{1,r} + \\mu_2 K_{2,r}$. The reduced system $A_r(\\mu_{\\text{test}})a(\\mu_{\\text{test}}) = f_r$ is solved for the coefficients $a(\\mu_{\\text{test}})$, which is computationally cheap due to its small size ($r \\times r$). The ROM solution is then reconstructed as $\\hat{u}(\\mu_{\\text{test}}) = V a(\\mu_{\\text{test}})$.\n\nFor each of the five test parameter sets, both the full-order solution $u(\\mu)$ and the reduced-order solution $\\hat{u}(\\mu)$ are computed. The accuracy of the ROM is quantified by the relative Euclidean error:\n$$\ne(\\mu) = \\frac{\\|u(\\mu) - \\hat{u}(\\mu)\\|_2}{\\|u(\\mu)\\|_2}.\n$$\nThe implementation calculates these five error values and presents them as the final output.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the end-to-end pipeline for creating and evaluating a\n    Reduced Order Model (ROM) for a 1D elastic rod.\n    \"\"\"\n    # 1. FEM Assembly\n    N = 60\n    q = 1.0\n    h = 1.0 / N\n\n    # Assemble affine stiffness components K1, K2 based on unit modulus.\n    # Element stiffness matrix for E=1, A=1.\n    k_elem = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n    # Use (N+1)x(N+1) global matrices for assembly, then slice to apply BC.\n    K1_glob = np.zeros((N + 1, N + 1))\n    N_left = N // 2 # Number of elements in the left half [0, 0.5]\n    for i in range(N_left):\n        K1_glob[i:i+2, i:i+2] += k_elem\n\n    K2_glob = np.zeros((N + 1, N + 1))\n    for i in range(N_left, N):\n        K2_glob[i:i+2, i:i+2] += k_elem\n\n    # Apply essential BC u(0)=0 by removing the first row and column.\n    # The system size becomes n=N for DOFs u_1, ..., u_N.\n    K1 = K1_glob[1:, 1:]\n    K2 = K2_glob[1:, 1:]\n\n    # Assemble force vector f for q=1.\n    # f_i = integral(q * N_i(x) dx), where N_i is the hat function.\n    f = np.ones(N) * q * h\n    f[-1] = q * h / 2.0\n\n    # 2. Greedy Algorithm for Basis Construction\n    r_max = 8\n    epsilon = 1e-8\n\n    # Define training parameter set\n    mu_pts = np.linspace(0.5, 5.0, 8)\n    P_train = [(m1, m2) for m1 in mu_pts for m2 in mu_pts]\n\n    # Initialize with the solution at the center parameter\n    mu_initial = (2.75, 2.75)\n    A_initial = mu_initial[0] * K1 + mu_initial[1] * K2\n    u_initial = np.linalg.solve(A_initial, f)\n    V = (u_initial / np.linalg.norm(u_initial))[:, np.newaxis]\n\n    # Start greedy iterations\n    r = 1\n    while r  r_max:\n        max_res_norm = -1.0\n        mu_next = None\n\n        # Precompute reduced operators for the current basis V\n        K1r = V.T @ K1 @ V\n        K2r = V.T @ K2 @ V\n        fr = V.T @ f\n\n        # Find parameter in training set that maximizes the residual norm\n        for mu_train in P_train:\n            mu1_train, mu2_train = mu_train\n            A_train = mu1_train * K1 + mu2_train * K2\n\n            # Solve the reduced system\n            Ar_train = mu1_train * K1r + mu2_train * K2r\n            \n            try:\n                a_train = np.linalg.solve(Ar_train, fr)\n            except np.linalg.LinAlgError:\n                # Should not happen for SPD matrices, but as a safeguard\n                continue\n\n            u_hat = V @ a_train\n\n            # Compute residual of the full-order system\n            res = f - (A_train @ u_hat)\n            res_norm = np.linalg.norm(res)\n\n            if res_norm > max_res_norm:\n                max_res_norm = res_norm\n                mu_next = mu_train\n\n        # Check for convergence\n        if max_res_norm  epsilon:\n            break\n        \n        # Generate new basis vector from the selected parameter\n        A_next = mu_next[0] * K1 + mu_next[1] * K2\n        u_snap = np.linalg.solve(A_next, f)\n\n        # Orthonormalize snapshot against the current basis\n        u_orth = u_snap - V @ (V.T @ u_snap)\n        norm_u_orth = np.linalg.norm(u_orth)\n        \n        # Add new vector to basis if it's not linearly dependent\n        if norm_u_orth > 1e-10:\n            phi_new = u_orth / norm_u_orth\n            V = np.hstack([V, phi_new[:, np.newaxis]])\n            r += 1\n        else:\n            # The snapshot is already in the basis span, stop.\n            break\n\n    # 3. Evaluation on Test Cases\n    test_cases = [\n        (0.5, 0.5),\n        (5.0, 5.0),\n        (0.5, 5.0),\n        (5.0, 0.5),\n        (2.0, 3.5),\n    ]\n\n    results = []\n\n    # Precompute final reduced operators with the final basis V\n    K1r_final = V.T @ K1 @ V\n    K2r_final = V.T @ K2 @ V\n    fr_final = V.T @ f\n\n    for mu_test in test_cases:\n        mu1_test, mu2_test = mu_test\n\n        # Compute Full-Order Model (FOM) solution\n        A_fom = mu1_test * K1 + mu2_test * K2\n        u_fom = np.linalg.solve(A_fom, f)\n\n        # Compute Reduced-Order Model (ROM) solution\n        Ar_rom = mu1_test * K1r_final + mu2_test * K2r_final\n        a_rom = np.linalg.solve(Ar_rom, fr_final)\n        u_rom = V @ a_rom\n\n        # Calculate relative error\n        error_norm = np.linalg.norm(u_fom - u_rom)\n        fom_norm = np.linalg.norm(u_fom)\n        relative_error = error_norm / fom_norm if fom_norm > 0 else 0.0\n        results.append(relative_error)\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}