{
    "hands_on_practices": [
        {
            "introduction": "A core task in any Hardware-in-the-Loop (HIL) setup is bridging the gap between the purely numerical world of the simulation and the physical voltage and current signals of the hardware under test. This exercise focuses on the fundamental process of scaling, where you will determine the correct gain to map a simulated physical quantity to a real-world analog voltage range. Mastering this ensures the fidelity of the interaction between the digital twin and the physical component .",
            "id": "3845342",
            "problem": "A digital real-time simulator (DRTS) is used for hardware-in-the-loop (HIL) testing of a current-controlled power converter. The simulated plant is modeled in International System of Units (SI), so the inductor current state variable is in amperes. The physical controller hardware expects an analog input voltage from the DRTS on a dedicated analog channel that represents the commanded inductor current. The analog input voltage range is from $0$ to $10$ volts, and the inductor current command range is from $0$ to $100$ amperes. The DRTS analog output stage is calibrated so that $0$ volts is produced when the output command is zero and the stage saturates at $10$ volts; offset and gain errors are negligible for the purpose of design.\n\nStarting from first principles of dimensional analysis and linear mappings between physical quantities, justify the use of an affine mapping between the simulated current and the output voltage that preserves the endpoints. Then, under the stated constraints that $0$ amperes must map to $0$ volts and $100$ amperes must map to $10$ volts, compute the scaling factor (gain) that multiplies the inductor current to produce the analog voltage. Express the scaling factor in $\\text{V/A}$. The final answer must be a single real number.",
            "solution": "The problem requires a formal justification for the use of a specific function to map a simulated physical quantity, inductor current $I$ (in amperes, $\\text{A}$), to an analog signal, voltage $V$ (in volts, $\\text{V}$). The function must satisfy specific boundary conditions. Following this justification, the scaling factor of this function must be computed.\n\nFirst, we justify the choice of the function $V = f(I)$. The simplest continuous function that maps one interval of real numbers to another is an affine transformation. This type of function is described by the general form:\n$$V = kI + V_0$$\nwhere $k$ is the scaling factor (or gain) and $V_0$ is the offset. This choice is supported by the principle of parsimony, as a more complex, non-linear function would require additional justification or constraints not provided in the problem statement.\n\nWe must verify that this functional form is dimensionally consistent. Let $[X]$ denote the physical dimension of a quantity $X$. The dimension of voltage is electric potential, and the dimension of current is electric current. For the equation to be valid, each term must have the dimension of electric potential.\n$$[V] = [k][I] + [V_0]$$\nThis implies that the dimension of the offset, $[V_0]$, must be the same as the dimension of voltage, $[V]$. It also implies that the dimension of the product $kI$, $[k][I]$, must be equal to $[V]$. Consequently, the dimension of the scaling factor $k$ must be:\n$$[k] = \\frac{[V]}{[I]}$$\nThis corresponds to units of volts per ampere ($\\text{V/A}$), which is dimensionally equivalent to electrical resistance. The affine mapping is, therefore, physically and dimensionally sound.\n\nThe problem specifies the domain and codomain for this mapping, as well as the behavior at the endpoints. The input current range is from $I_{min} = 0 \\text{ A}$ to $I_{max} = 100 \\text{ A}$. The output voltage range is from $V_{min} = 0 \\text{ V}$ to $V_{max} = 10 \\text{ V}$. The mapping must satisfy the following two conditions:\n$1$. $f(I_{min}) = V_{min} \\implies f(0 \\text{ A}) = 0 \\text{ V}$\n$2$. $f(I_{max}) = V_{max} \\implies f(100 \\text{ A}) = 10 \\text{ V}$\n\nWe can use these two conditions to determine the unknown parameters $k$ and $V_0$ by substituting them into the general affine equation $V = kI + V_0$.\n\nUsing the first condition:\n$$0 \\text{ V} = k \\cdot (0 \\text{ A}) + V_0$$\nThis equation immediately yields the value of the offset:\n$$V_0 = 0 \\text{ V}$$\nThe fact that the offset is zero indicates that the relationship is not just affine, but purely linear (a direct proportionality). This aligns perfectly with the problem stating that \"$0$ volts is produced when the output command is zero\" and \"offset and gain errors are negligible\". The mapping function simplifies to:\n$$V = kI$$\n\nNow, we apply the second condition to this simplified linear function:\n$$10 \\text{ V} = k \\cdot (100 \\text{ A})$$\nSolving for the scaling factor $k$:\n$$k = \\frac{10 \\text{ V}}{100 \\text{ A}}$$\n$$k = 0.1 \\text{ V/A}$$\n\nThe scaling factor, or gain, is therefore $0.1 \\text{ V/A}$. The use of an affine mapping is justified as it represents the simplest dimensionally consistent function whose two parameters are uniquely determined by the two physical constraints provided. The derived linear relationship $V = (0.1 \\text{ V/A}) \\cdot I$ correctly maps the entire current range $[0 \\text{ A}, 100 \\text{ A}]$ to the voltage range $[0 \\text{ V}, 10 \\text{ V}]$, preserving the endpoint relationships.",
            "answer": "$$\\boxed{0.1}$$"
        },
        {
            "introduction": "HIL simulations are not just about model accuracy; they are fundamentally about real-time performance, where computations must complete within strict deadlines. This practice delves into the critical concept of schedulability, using the Earliest Deadline First (EDF) policy as a framework. You will analyze how increasing model fidelity impacts processor load and determine the absolute performance limit of the real-time system, a crucial trade-off in any HIL design .",
            "id": "4225896",
            "problem": "A real-time Hardware-In-the-Loop (HIL) digital twin testbed runs on a single preemptive processor and uses earliest deadline first (EDF) scheduling. In the HIL loop, four periodic tasks execute on the target: the plant integrator, sensor emulation, actuator driver, and network telemetry. Each job of a task is released at the start of its period and must complete by its relative deadline, which equals its period. The system is strictly single-core with no background tasks, and jobs may be preempted.\n\nTo increase model fidelity, the plant and signal processing operations are scaled by a dimensionless fidelity factor $s \\ge 0$, which increases their Worst-Case Execution Times (WCETs). The WCETs and periods are:\n- Plant integrator: period $T_{1} = 1\\,\\mathrm{ms}$, execution time $C_{1}(s) = 0.27\\,\\mathrm{ms} + 0.15\\,\\mathrm{ms} \\cdot s$.\n- Sensor emulation: period $T_{2} = 2\\,\\mathrm{ms}$, execution time $C_{2}(s) = 0.305\\,\\mathrm{ms} + 0.05\\,\\mathrm{ms} \\cdot s$.\n- Actuator driver: period $T_{3} = 5\\,\\mathrm{ms}$, execution time $C_{3}(s) = 0.21\\,\\mathrm{ms} + 0.02\\,\\mathrm{ms} \\cdot s^{2}$.\n- Network telemetry: period $T_{4} = 10\\,\\mathrm{ms}$, execution time $C_{4} = 0.62\\,\\mathrm{ms}$.\n\nDesign the EDF scheduling policy by specifying the relative deadlines for each task and the scheduling rule that determines job priorities at runtime. Starting from first principles of real-time feasibility under EDF for single-core preemptive systems with implicit deadlines (relative deadlines equal to periods), derive the schedulability criterion in terms of processor demand over any interval and show how it constrains the aggregate execution demand of these periodic tasks. Then, using that criterion, determine the maximum fidelity scaling factor $s_{\\max}$ such that the system remains schedulable.\n\nExpress your final answer as a pure number for $s_{\\max}$, rounded to four significant figures. No units are required for the final answer.",
            "solution": "The problem asks for the design of an Earliest Deadline First (EDF) scheduling policy and the calculation of the maximum fidelity scaling factor $s_{\\max}$ that ensures the schedulability of a set of four periodic tasks on a single-core preemptive processor.\n\nFirst, we address the design of the EDF scheduling policy. The policy consists of two main components: the assignment of deadlines and the runtime scheduling rule.\n\n$1$. **Deadline Assignment**: The problem specifies that for each task $\\tau_i$, its relative deadline $D_i$ is equal to its period $T_i$. This is known as an implicit deadline system. The given tasks are:\n- Task $\\tau_1$ (Plant integrator): $T_1 = 1\\,\\mathrm{ms}$, so its relative deadline is $D_1 = 1\\,\\mathrm{ms}$.\n- Task $\\tau_2$ (Sensor emulation): $T_2 = 2\\,\\mathrm{ms}$, so its relative deadline is $D_2 = 2\\,\\mathrm{ms}$.\n- Task $\\tau_3$ (Actuator driver): $T_3 = 5\\,\\mathrm{ms}$, so its relative deadline is $D_3 = 5\\,\\mathrm{ms}$.\n- Task $\\tau_4$ (Network telemetry): $T_4 = 10\\,\\mathrm{ms}$, so its relative deadline is $D_4 = 10\\,\\mathrm{ms}$.\n\n$2$. **Scheduling Rule**: EDF is a dynamic priority scheduling algorithm. The scheduling rule is as follows: At any given time, the ready job with the earliest absolute deadline is selected for execution. The absolute deadline of a job is calculated as its release time plus its relative deadline. If a new job is released that has an earlier absolute deadline than the currently executing job, the current job is preempted and the new job begins execution.\n\nNext, we derive the schedulability criterion. The fundamental condition for schedulability on a single processor is that the cumulative processor demand over any time interval must not exceed the length of that interval. For a set of $n$ periodic tasks, the processor demand function $h(t)$ over an interval of length $t$ is given by the sum of the execution requirements of all jobs that must start and complete within that interval. For implicit deadline tasks, this is:\n$$h(t) = \\sum_{i=1}^{n} \\left\\lfloor \\frac{t}{T_i} \\right\\rfloor C_i$$\nThe necessary and sufficient condition for schedulability under EDF is $h(t) \\le t$ for all $t > 0$.\n\nFor the special, but common, case of a set of independent, preemptable, periodic tasks with implicit deadlines ($D_i = T_i$) running on a single processor, Liu and Layland proved that this condition simplifies to a much more tractable test based on total processor utilization. The utilization of a single task $\\tau_i$ is $U_i = C_i / T_i$, which represents the fraction of processor time consumed by that task. The total processor utilization $U$ is the sum of individual utilizations:\n$$U = \\sum_{i=1}^{n} U_i = \\sum_{i=1}^{n} \\frac{C_i}{T_i}$$\nThe necessary and sufficient condition for schedulability in this context is $U \\le 1$. This condition is both necessary (if $U > 1$, the tasks demand more processing time than is available in the long run) and sufficient (if $U \\le 1$, no deadlines will ever be missed).\n\nWe now apply this schedulability criterion to the given task set. The Worst-Case Execution Times (WCETs) $C_i$ are functions of the fidelity factor $s$. The total utilization $U(s)$ is therefore also a function of $s$.\nThe tasks are:\n- $\\tau_1$: $T_1 = 1\\,\\mathrm{ms}$, $C_1(s) = (0.27 + 0.15s)\\,\\mathrm{ms}$\n- $\\tau_2$: $T_2 = 2\\,\\mathrm{ms}$, $C_2(s) = (0.305 + 0.05s)\\,\\mathrm{ms}$\n- $\\tau_3$: $T_3 = 5\\,\\mathrm{ms}$, $C_3(s) = (0.21 + 0.02s^2)\\,\\mathrm{ms}$\n- $\\tau_4$: $T_4 = 10\\,\\mathrm{ms}$, $C_4 = 0.62\\,\\mathrm{ms}$\n\nThe total utilization $U(s)$ is:\n$$U(s) = \\frac{C_1(s)}{T_1} + \\frac{C_2(s)}{T_2} + \\frac{C_3(s)}{T_3} + \\frac{C_4}{T_4}$$\nSubstituting the given values (note that the units of milliseconds, $\\mathrm{ms}$, cancel in each term):\n$$U(s) = \\frac{0.27 + 0.15s}{1} + \\frac{0.305 + 0.05s}{2} + \\frac{0.21 + 0.02s^2}{5} + \\frac{0.62}{10}$$\nSimplifying each term:\n$$U(s) = (0.27 + 0.15s) + (0.1525 + 0.025s) + (0.042 + 0.004s^2) + 0.062$$\nCollecting terms by powers of $s$:\n$$U(s) = (0.004)s^2 + (0.15 + 0.025)s + (0.27 + 0.1525 + 0.042 + 0.062)$$\n$$U(s) = 0.004s^2 + 0.175s + 0.5265$$\nFor the system to be schedulable, we must satisfy the condition $U(s) \\le 1$:\n$$0.004s^2 + 0.175s + 0.5265 \\le 1$$\nWe rearrange this into a standard quadratic inequality form, $as^2 + bs + c \\le 0$:\n$$0.004s^2 + 0.175s - 0.4735 \\le 0$$\nTo find the values of $s$ for which this inequality holds, we first find the roots of the corresponding quadratic equation $0.004s^2 + 0.175s - 0.4735 = 0$. We use the quadratic formula $s = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$ with $a=0.004$, $b=0.175$, and $c=-0.4735$.\n\nFirst, we compute the discriminant $\\Delta = b^2 - 4ac$:\n$$\\Delta = (0.175)^2 - 4(0.004)(-0.4735)$$\n$$\\Delta = 0.030625 + 0.007576 = 0.038201$$\nThe roots are:\n$$s = \\frac{-0.175 \\pm \\sqrt{0.038201}}{2(0.004)} = \\frac{-0.175 \\pm 0.19545076...}{0.008}$$\nThis gives two roots:\n$$s_1 = \\frac{-0.175 - 0.19545076...}{0.008} \\approx -46.3063$$\n$$s_2 = \\frac{-0.175 + 0.19545076...}{0.008} \\approx 2.556345$$\nThe quadratic function $f(s) = 0.004s^2 + 0.175s - 0.4735$ represents a parabola opening upwards. Therefore, the inequality $f(s) \\le 0$ is satisfied for values of $s$ between the two roots, i.e., $s_1 \\le s \\le s_2$.\n\nThe problem states that the fidelity factor $s$ must be non-negative, so $s \\ge 0$. Combining this physical constraint with the schedulability constraint, the permissible range for $s$ is $0 \\le s \\le s_2$.\nThe maximum value of the fidelity scaling factor, $s_{\\max}$, is therefore the positive root, $s_2$.\n$$s_{\\max} \\approx 2.556345$$\nThe problem requires the answer to be rounded to four significant figures.\n$$s_{\\max} \\approx 2.556$$",
            "answer": "$$\\boxed{2.556}$$"
        },
        {
            "introduction": "One of the primary benefits of HIL simulation is the ability to safely test control algorithms under realistic, non-ideal conditions like actuator saturation. This advanced exercise tackles the problem of integrator windup, a common issue when physical actuators cannot deliver the commanded output. You will design and verify a back-calculation anti-windup compensator, demonstrating how HIL can be used to validate robust control strategies before deployment on physical hardware .",
            "id": "4225902",
            "problem": "A real-time Hardware-in-the-Loop (HIL) setup is used to validate the anti-windup design of a digital twin for a single-input single-output mechatronic servo. The physical plant (emulated on the HIL) is modeled as a second-order continuous-time system with unit static gain:\n$$\nG(s) = \\frac{1}{s^{2} + 10 s + 100}.\n$$\nLet the plant state be $x = \\begin{pmatrix} x_{1} \\\\ x_{2} \\end{pmatrix}$ with output $y = x_{1}$ and actuator output $u_{a}$ entering as input to the plant in controllable canonical form:\n$$\n\\dot{x}_{1} = x_{2}, \\qquad \\dot{x}_{2} = -100 x_{1} - 10 x_{2} + u_{a}.\n$$\nThe actuator exhibits a first-order lag and hard saturation at $\\pm U_{\\max}$, modeled as\n$$\n\\dot{u}_{a} = \\frac{-u_{a} + \\operatorname{sat}(u_{c})}{\\tau_{a}}, \\qquad \\operatorname{sat}(u_{c}) = \\begin{cases}\nU_{\\max}, & u_{c} \\ge U_{\\max},\\\\\nu_{c}, & |u_{c}| < U_{\\max},\\\\\n- U_{\\max}, & u_{c} \\le - U_{\\max},\n\\end{cases}\n$$\nwith $U_{\\max} = 5$ and $\\tau_{a} = 0.02$. The reference is $r = 0$, and the control error is $e = r - y = -y$.\n\nA Proportional-Integral-Derivative (PID) controller is implemented with the derivative path disabled (that is, $K_{d} = 0$, so the controller reduces to a Proportional-Integral (PI) form), using gains $K_{p} = 40$ and $K_{i} = 100$.\nLet $z$ denote the integrator state of the controller, so that the nominal controller output before saturation is $u_{c} = K_{p} e + K_{i} z$, with the ideal integrator law $\\dot{z} = e$.\n\nTo prevent integrator windup during saturation in the HIL, a back-calculation anti-windup compensator is added to the integrator channel:\n$$\n\\dot{z} = e + K_{aw}\\big(\\operatorname{sat}(u_{c}) - u_{c}\\big),\n$$\nwhere $K_{aw} > 0$ is a constant to be chosen.\n\nThe HIL executes a zero-order-hold discrete implementation with sample time $T_{s} = 0.001$, but you may assume that $T_{s}$ is sufficiently small relative to the plant and actuator time constants so that continuous-time stability properties carry over to the sampled implementation.\n\nTask:\n- Using only foundational definitions of proportional-integral control, actuator saturation, and first-order tracking dynamics, derive the relationship between the anti-windup gain $K_{aw}$, the integral gain $K_{i}$, and a desired controller-output tracking time constant $T_{t}$ such that, under saturation, the controller internal signal $u_{c}$ tracks the saturated signal $\\operatorname{sat}(u_{c})$ with first-order dynamics of time constant $T_{t}$. Then impose the physically motivated design choice $T_{t} = \\tau_{a}$.\n- Compute the numerical value of $K_{aw}$ for the given parameters.\n- Verify internal closed-loop stability under hard saturation (that is, while $\\operatorname{sat}(u_{c})$ is clamped to a constant $\\pm U_{\\max}$) by analyzing the eigenvalues of the augmented continuous-time linear system comprising the plant, the actuator lag, and the controller integrator with anti-windup. Your verification must proceed from first principles and must not invoke any shortcut formulas.\n- Conclude why, given $T_{s} \\ll \\min\\{ \\tau_{a}, 1/10, 1/5 \\}$, the discrete-time HIL implementation inherits stability.\n\nExpress the final anti-windup gain $K_{aw}$ as a pure number (dimensionless) and round your answer to four significant figures.",
            "solution": "The solution proceeds in four parts as requested by the task description.\n\n**Part 1: Derivation of the Anti-Windup Gain Relationship**\n\nThe goal is to establish a relationship between the anti-windup gain $K_{aw}$ and a desired time constant $T_t$ for the internal controller signal $u_c$ to track the saturated signal $\\operatorname{sat}(u_c)$.\n\nThe nominal controller output is given by:\n$$u_{c} = K_{p} e + K_{i} z$$\nTo analyze the dynamics of $u_c$, we differentiate this expression with respect to time:\n$$\\dot{u}_{c} = K_{p} \\dot{e} + K_{i} \\dot{z}$$\nThe anti-windup modification to the integrator is given by:\n$$\\dot{z} = e + K_{aw}\\big(\\operatorname{sat}(u_{c}) - u_{c}\\big)$$\nSubstituting this expression for $\\dot{z}$ into the equation for $\\dot{u}_c$:\n$$\\dot{u}_{c} = K_{p} \\dot{e} + K_{i} \\left( e + K_{aw}\\big(\\operatorname{sat}(u_{c}) - u_{c}\\big) \\right)$$\n$$\\dot{u}_{c} = K_{p} \\dot{e} + K_{i} e + K_{i} K_{aw} \\operatorname{sat}(u_{c}) - K_{i} K_{aw} u_{c}$$\nWe can rearrange this equation to highlight the dynamics of $u_c$:\n$$\\dot{u}_{c} + K_{i} K_{aw} u_{c} = K_{i} K_{aw} \\operatorname{sat}(u_{c}) + K_{p} \\dot{e} + K_{i} e$$\nThis is a first-order linear ordinary differential equation for $u_c$. We want $u_c$ to track $\\operatorname{sat}(u_c)$ with first-order dynamics characterized by a time constant $T_t$. A standard first-order system with time constant $T_t$ tracking a reference $R(t)$ can be written as $T_t \\dot{y} + y = R(t)$.\nTo match our equation to this form, we can rewrite it as:\n$$\\frac{1}{K_{i} K_{aw}} \\dot{u}_{c} + u_{c} = \\operatorname{sat}(u_{c}) + \\frac{1}{K_{i} K_{aw}}(K_{p} \\dot{e} + K_{i} e)$$\nThe term $(K_{p} \\dot{e} + K_{i} e)$ acts as a disturbance to the tracking dynamics. The desired response is governed by the homogeneous part of the equation, which has a time constant:\n$$T_{t} = \\frac{1}{K_{i} K_{aw}}$$\nThis is the desired relationship. It dictates how fast the internal signal $u_c$ converges to the saturated output $\\operatorname{sat}(u_c)$ when the actuator is saturated. This prevents the integrator state $z$ from accumulating further error.\n\n**Part 2: Computation of the Numerical Value for $K_{aw}$**\n\nThe problem specifies the physically motivated design choice of setting the controller-output tracking time constant $T_t$ equal to the actuator time constant $\\tau_a$.\n$$T_{t} = \\tau_{a}$$\nSubstituting this into the derived relationship:\n$$\\tau_{a} = \\frac{1}{K_{i} K_{aw}}$$\nSolving for the anti-windup gain $K_{aw}$:\n$$K_{aw} = \\frac{1}{K_{i} \\tau_{a}}$$\nWe are given the numerical values $K_{i} = 100$ and $\\tau_{a} = 0.02$.\n$$K_{aw} = \\frac{1}{100 \\times 0.02} = \\frac{1}{2} = 0.5$$\nAs requested, rounding to four significant figures gives $0.5000$.\n\n**Part 3: Verification of Internal Closed-Loop Stability**\n\nWe must verify the stability of the augmented system under hard saturation. The augmented state vector is $X = \\begin{pmatrix} x_{1} & x_{2} & u_{a} & z \\end{pmatrix}^{T}$. The system dynamics are:\n$$\n\\begin{align*}\n\\dot{x}_{1} &= x_{2} \\\\\n\\dot{x}_{2} &= -100 x_{1} - 10 x_{2} + u_{a} \\\\\n\\dot{u}_{a} &= \\frac{-u_{a} + \\operatorname{sat}(u_{c})}{\\tau_{a}} \\\\\n\\dot{z} &= e + K_{aw}(\\operatorname{sat}(u_{c}) - u_{c})\n\\end{align*}\n$$\nUnder hard saturation, $\\operatorname{sat}(u_{c})$ becomes a constant value, either $U_{\\max}$ or $-U_{\\max}$. Let's denote this constant as $U_{sat}$. The system becomes linear time-invariant (LTI) with constant inputs. Stability is determined by the system matrix $A$ in the state-space representation $\\dot{X} = AX + B U_{ext}$.\n\nLet's express the inputs to the state equations in terms of the state variables:\n$e = -y = -x_{1}$\n$u_{c} = K_{p} e + K_{i} z = -K_{p} x_{1} + K_{i} z$\n\nSubstituting these into the state equations:\n$$\n\\begin{align*}\n\\dot{x}_{1} &= x_{2} \\\\\n\\dot{x}_{2} &= -100 x_{1} - 10 x_{2} + u_{a} \\\\\n\\dot{u}_{a} &= -\\frac{1}{\\tau_{a}} u_{a} + \\frac{1}{\\tau_{a}} U_{sat} \\\\\n\\dot{z} &= -x_{1} + K_{aw}\\big(U_{sat} - (-K_{p} x_{1} + K_{i} z)\\big) \\\\\n&= -x_{1} + K_{aw} U_{sat} + K_{aw} K_{p} x_{1} - K_{aw} K_{i} z \\\\\n&= (K_{aw} K_{p} - 1) x_{1} - K_{aw} K_{i} z + K_{aw} U_{sat}\n\\end{align*}\n$$\nThe system matrix $A$ is therefore:\n$$A = \\begin{pmatrix}\n0 & 1 & 0 & 0 \\\\\n-100 & -10 & 1 & 0 \\\\\n0 & 0 & -1/\\tau_a & 0 \\\\\nK_{aw}K_p - 1 & 0 & 0 & -K_{aw}K_i\n\\end{pmatrix}$$\nStability is determined by the eigenvalues of $A$, which are the roots of the characteristic equation $\\det(\\lambda I - A) = 0$.\n$$\\det \\begin{pmatrix}\n\\lambda & -1 & 0 & 0 \\\\\n100 & \\lambda+10 & -1 & 0 \\\\\n0 & 0 & \\lambda+1/\\tau_a & 0 \\\\\n-(K_{aw}K_p - 1) & 0 & 0 & \\lambda+K_{aw}K_i\n\\end{pmatrix} = 0$$\nWe can expand the determinant along the fourth column. This yields:\n$$(\\lambda+K_{aw}K_i) \\det \\begin{pmatrix}\n\\lambda & -1 & 0 \\\\\n100 & \\lambda+10 & -1 \\\\\n0 & 0 & \\lambda+1/\\tau_a\n\\end{pmatrix} = 0$$\nThis reveals one eigenvalue, $\\lambda_4 = -K_{aw}K_i$. Next, we expand the $3 \\times 3$ determinant along its third row:\n$$(\\lambda+K_{aw}K_i) (\\lambda+1/\\tau_a) \\det \\begin{pmatrix}\n\\lambda & -1 \\\\\n100 & \\lambda+10\n\\end{pmatrix} = 0$$\nThis reveals a second eigenvalue, $\\lambda_3 = -1/\\tau_a$. The remaining two eigenvalues are the roots of:\n$$\\lambda(\\lambda+10) - (-1)(100) = 0$$\n$$\\lambda^2 + 10\\lambda + 100 = 0$$\nThis is the characteristic polynomial of the open-loop plant, $G(s)$. The eigenvalues are:\n$$\\lambda_{1,2} = \\frac{-10 \\pm \\sqrt{10^2 - 4(1)(100)}}{2} = \\frac{-10 \\pm \\sqrt{100 - 400}}{2} = \\frac{-10 \\pm \\sqrt{-300}}{2} = -5 \\pm i\\sqrt{75} = -5 \\pm 5i\\sqrt{3}$$\nFor stability, the real parts of all eigenvalues must be negative.\n- $\\operatorname{Re}(\\lambda_{1,2}) = -5  0$.\n- $\\lambda_3 = -1/\\tau_a = -1/0.02 = -50  0$.\n- $\\lambda_4 = -K_{aw}K_i = -0.5 \\times 100 = -50  0$. Note that due to our design choice $K_{aw} = 1/(K_i \\tau_a)$, we have $\\lambda_4 = -(1/(K_i \\tau_a)) K_i = -1/\\tau_a = \\lambda_3$.\n\nAll eigenvalues, $\\{-5 + 5i\\sqrt{3}, -5 - 5i\\sqrt{3}, -50, -50\\}$, have negative real parts. Therefore, the augmented closed-loop system is stable under hard saturation.\n\n**Part 4: Stability of the Discrete-Time Implementation**\n\nThe stability of a discrete-time LTI system obtained by applying a zero-order hold (ZOH) to a continuous-time LTI system is directly related to the stability of the underlying continuous-time system.\nLet the continuous-time system be $\\dot{X}(t) = A X(t)$. Its ZOH discretization with sample time $T_s$ is $X_{k+1} = A_d X_k$, where the discrete system matrix is $A_d = \\exp(A T_s)$.\nIf $\\lambda_i$ are the eigenvalues of the continuous-time matrix $A$, then the eigenvalues of the discrete-time matrix $A_d$ are $\\mu_i = \\exp(\\lambda_i T_s)$.\nFor the discrete-time system to be stable, all its eigenvalues $\\mu_i$ must lie within the unit circle in the complex plane, i.e., $|\\mu_i|  1$ for all $i$.\nLet's analyze the magnitude of a discrete eigenvalue $\\mu_i$:\n$$|\\mu_i| = |\\exp(\\lambda_i T_s)| = |\\exp\\big((\\operatorname{Re}(\\lambda_i) + i\\operatorname{Im}(\\lambda_i)) T_s\\big)|$$\n$$|\\mu_i| = |\\exp(\\operatorname{Re}(\\lambda_i)T_s) \\cdot \\exp(i\\operatorname{Im}(\\lambda_i)T_s)| = |\\exp(\\operatorname{Re}(\\lambda_i)T_s)| \\cdot |\\exp(i\\operatorname{Im}(\\lambda_i)T_s)|$$\nSince $|\\exp(i\\theta)| = 1$ for any real $\\theta$, this simplifies to:\n$$|\\mu_i| = |\\exp(\\operatorname{Re}(\\lambda_i)T_s)|$$\nBecause $T_s > 0$ and the exponential of a real number is always positive, we have:\n$$|\\mu_i| = \\exp(\\operatorname{Re}(\\lambda_i)T_s)$$\nThe stability condition $|\\mu_i|  1$ thus becomes $\\exp(\\operatorname{Re}(\\lambda_i)T_s)  1$. Taking the natural logarithm of both sides (since $\\ln$ is a monotonically increasing function) gives:\n$$\\operatorname{Re}(\\lambda_i)T_s  \\ln(1) = 0$$\nAs $T_s > 0$, this is equivalent to the condition $\\operatorname{Re}(\\lambda_i)  0$.\nThis establishes a fundamental result: a continuous-time LTI system is stable if and only if its ZOH discretization is stable.\nIn Part 3, we proved that all eigenvalues of the continuous-time system matrix $A$ have negative real parts. Therefore, the corresponding discrete-time system used in the HIL simulation is also guaranteed to be stable. The condition $T_{s} \\ll \\min\\{ \\tau_{a}, 1/10, 1/5 \\}$ ensures that the sampling is sufficiently fast to capture all relevant system dynamics ($1/5=0.2$ relates to the plant's slowest pole, $1/10=0.1$ to the plant's damping, and $\\tau_a=0.02$ to the fastest shared pole), reinforcing that the continuous-time analysis accurately predicts the discrete system's behavior.",
            "answer": "$$\n\\boxed{0.5000}\n$$"
        }
    ]
}