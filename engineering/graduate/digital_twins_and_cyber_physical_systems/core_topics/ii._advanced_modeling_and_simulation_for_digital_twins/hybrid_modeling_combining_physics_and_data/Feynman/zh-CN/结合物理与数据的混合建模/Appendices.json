{
    "hands_on_practices": [
        {
            "introduction": "混合建模通常从增强我们已有深入理解的物理模型开始。第一个实践练习将通过一个常见的工程挑战——在一个简单的机械系统中辨识复杂的非线性摩擦力——来阐释这一原则。通过将数据驱动的摩擦模型嵌入到牛顿第二定律这一已知的物理框架中，你将学习如何从含噪声的数据中估计参数，并同时确保模型的物理一致性，例如保证能量耗散的非负性 。",
            "id": "4226933",
            "problem": "考虑一个单自由度信息物理系统，其物理设备和数字孪生共享一个混合模型，该模型将基于物理的结构与数据驱动的摩擦力耦合在一起。设该物理设备为一个位于线性弹簧上的质点，其阻尼与速度相关且未知。纵向运动由牛顿第二运动定律和胡克定律描述。其控制物理原理是：合力等于质量乘以加速度。将位置表示为 $x(t)$（单位：米），速度表示为 $v(t)$（单位：米/秒），加速度表示为 $a(t)$（单位：米/秒²），外部驱动力表示为 $u(t)$（单位：牛顿），质量表示为 $m$（单位：千克），线性刚度表示为 $k$（单位：牛顿/米），摩擦力表示为 $F_{\\mathrm{fric}}(t)$（单位：牛顿）。基本方程为：\n$$ m \\, a(t) = u(t) - k \\, x(t) - F_{\\mathrm{fric}}(t). $$\n为确保物理上一致的非负能量耗散，我们将摩擦力表示为一个类粘性项，其有效摩擦系数取决于速度大小，因此\n$$ F_{\\mathrm{fric}}(t) = c\\big(|v(t)|\\big)\\, v(t), \\quad c\\big(|v(t)|\\big) \\ge 0, $$\n这会产生瞬时功率耗散\n$$ P_{\\mathrm{diss}}(t) = F_{\\mathrm{fric}}(t)\\, v(t) \\ge 0. $$\n我们采用以下混合建模方案：结构模型（$m$ 和 $k$）从物理学中已知，而有效摩擦系数 $c\\big(|v|\\big)$ 则使用一个能保持正性的最小参数基从数据中学习得到。具体来说，令\n$$ c\\big(|v|\\big) = \\alpha_0 + \\alpha_1 |v|, $$\n其中未知系数 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$ 将根据时间序列数据和物理方程进行推断。学习目标是找到 $\\alpha_0$ 和 $\\alpha_1$，在 $\\alpha_0$ 和 $\\alpha_1$ 的非负约束下，最小化测量的外力 $u(t)$ 与混合模型预测的力之间的失配，从而保证 $P_{\\mathrm{diss}}(t) \\ge 0$。该建模假设对于润滑接触是科学上现实的，在润滑接触中，粘性摩擦力随速度增加而增加。\n\n您的任务是实现一个程序，该程序：\n- 通过已知的运动剖面激励系统，为指定参数生成合成数据 $(x(t), v(t), a(t), u(t))$，根据物理原理计算设计信号，并使用非负最小二乘法 (NNLS) 估计 $(\\alpha_0,\\alpha_1)$。NNLS 是 Non-Negative Least Squares 的缩写。\n- 计算均方根速度\n$$ v_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} v(t_i)^2}, $$\n并报告在此速度下的标量有效摩擦系数，\n$$ c_{\\mathrm{eff}} = \\alpha_0 + \\alpha_1 \\, v_{\\mathrm{rms}}, $$\n单位为 $\\mathrm{N\\cdot s/m}$。\n- 通过检查以下公式来验证整个数据集上耗散的正性：\n$$ P_{\\mathrm{diss}}(t_i) = \\big(\\alpha_0 v(t_i) + \\alpha_1 |v(t_i)| v(t_i)\\big)\\, v(t_i) \\ge 0 $$\n对于所有样本 $t_i$。如果每个样本都满足该不等式（在浮点数运算精度内，这里由于系数的非负性和二次非负性，计算是精确的），则布尔值应为真，否则为假。\n\n程序应为每个测试用例实现以下数据生成协议：\n- 时间样本 $t_i = i \\, \\Delta t$，其中 $i = 0,1,\\dots,N-1$，并指定了 $N$ 和 $\\Delta t$（单位：秒）。\n- 运动剖面 $x(t) = X_0 \\sin(\\omega t)$，其中 $X_0$ 单位为米，角频率 $\\omega$ 单位为弧度/秒。则 $v(t) = X_0 \\omega \\cos(\\omega t)$ 且 $a(t) = -X_0 \\omega^2 \\sin(\\omega t)$。\n- 真实摩擦系数 $(\\alpha_0^{\\mathrm{true}}, \\alpha_1^{\\mathrm{true}})$ 产生摩擦力 $F_{\\mathrm{fric}}^{\\mathrm{true}}(t) = \\alpha_0^{\\mathrm{true}} v(t) + \\alpha_1^{\\mathrm{true}} |v(t)| v(t)$。\n- 测量的驱动力为 $u(t) = m a(t) + k x(t) + F_{\\mathrm{fric}}^{\\mathrm{true}}(t) + \\eta(t)$，其中 $\\eta(t)$ 是附加的零均值高斯噪声（单位：牛顿），使用给定的标准差和每个测试用例固定的随机种子生成，以确保可复现性。\n\n估计协议：\n- 利用物理方程，重新整理测量方程以分离出摩擦力的贡献：\n$$ b(t) = u(t) - m a(t) - k x(t) = \\alpha_0 v(t) + \\alpha_1 |v(t)| v(t). $$\n- 通过求解 NNLS 问题，从样本 $\\{b(t_i), v(t_i)\\}_{i=1}^N$ 中估计 $(\\alpha_0,\\alpha_1)$，该问题在 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$ 的约束下最小化残差平方和。\n\n单位和输出规范：\n- 质量 $m$ 的单位是 $\\mathrm{kg}$，刚度 $k$ 的单位是 $\\mathrm{N/m}$，位置 $x$ 的单位是 $\\mathrm{m}$，速度 $v$ 的单位是 $\\mathrm{m/s}$，加速度 $a$ 的单位是 $\\mathrm{m/s^2}$，力 $u$ 的单位是 $\\mathrm{N}$，摩擦系数 $\\alpha_0$ 的单位是 $\\mathrm{N\\cdot s/m}$，$\\alpha_1$ 的单位是 $\\mathrm{N\\cdot s^2/m^2}$，以及 $c_{\\mathrm{eff}}$ 的单位是 $\\mathrm{N\\cdot s/m}$。角度单位是弧度。输出中不出现百分比。\n- 对于每个测试用例，程序应输出一个列表 $[c_{\\mathrm{eff}}, \\mathrm{flag}]$，其中 $c_{\\mathrm{eff}}$ 是一个单位为 $\\mathrm{N\\cdot s/m}$ 的浮点数，$\\mathrm{flag}$ 是一个布尔值，指示是否所有样本都满足 $P_{\\mathrm{diss}}(t_i) \\ge 0$。\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果，例如：$[[c_1,\\mathrm{flag}_1],[c_2,\\mathrm{flag}_2],[c_3,\\mathrm{flag}_3]]$。\n\n测试套件：\n- 案例1（正常路径）：$m = 2.0$, $k = 5.0$, $X_0 = 0.15$, $\\omega = 3.0$, $\\Delta t = 0.01$, $N = 1000$, $\\alpha_0^{\\mathrm{true}} = 0.8$, $\\alpha_1^{\\mathrm{true}} = 0.3$, 噪声标准差 $= 0.05$ 牛顿, 随机种子 $= 42$。\n- 案例2（边界条件：纯粘性）：$m = 1.2$, $k = 8.0$, $X_0 = 0.08$, $\\omega = 2.5$, $\\Delta t = 0.01$, $N = 800$, $\\alpha_0^{\\mathrm{true}} = 1.0$, $\\alpha_1^{\\mathrm{true}} = 0.0$, 噪声标准差 $= 0.02$ 牛顿, 随机种子 $= 123$。\n- 案例3（边缘情况：接近零的速度）：$m = 3.5$, $k = 4.0$, $X_0 = 0.02$, $\\omega = 1.5$, $\\Delta t = 0.01$, $N = 600$, $\\alpha_0^{\\mathrm{true}} = 0.5$, $\\alpha_1^{\\mathrm{true}} = 0.1$, 噪声标准差 $= 0.01$ 牛顿, 随机种子 $= 7$。\n\n您的实现必须是确定性的，使用指定的种子，并严格遵守最终的输出格式。",
            "solution": "该问题要求为一个单自由度信息物理系统估计摩擦参数。该系统由一个物理设备（表示为质量为 $m$、刚度为 $k$ 的线性弹簧上的一个质点）及其数字孪生组成。解决方案采用一种混合模型，该模型将已知的基于物理的结构与用于摩擦力的数据驱动部分相结合。\n\n质点的运动控制方程源自牛顿第二定律：\n$$ m \\, a(t) = u(t) - k \\, x(t) - F_{\\mathrm{fric}}(t) $$\n其中 $x(t)$、$v(t)$ 和 $a(t)$ 分别是质点的位置、速度和加速度。项 $u(t)$ 表示外部驱动力，$F_{\\mathrm{fric}}(t)$ 是摩擦力。\n\n摩擦力使用混合方法建模。该模型结构受物理启发，确保由摩擦力耗散的瞬时功率 $P_{\\mathrm{diss}}(t) = F_{\\mathrm{fric}}(t)v(t)$ 始终为非负。这是通过将摩擦力定义为以下形式实现的：\n$$ F_{\\mathrm{fric}}(t) = c\\big(|v(t)|\\big)\\, v(t) $$\n其中有效摩擦系数 $c\\big(|v(t)|\\big)$ 是速度大小 $|v(t)|$ 的一个非负函数。数据驱动部分是该系数的参数形式，需要从数据中学习：\n$$ c\\big(|v(t)|\\big) = \\alpha_0 + \\alpha_1 |v(t)| $$\n参数 $\\alpha_0$ 和 $\\alpha_1$ 是未知的，必须进行估计。为确保 $P_{\\mathrm{diss}}(t) = (\\alpha_0 + \\alpha_1 |v(t)|)v(t)^2 \\ge 0$，我们必须强制施加约束 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$。\n\n为了估计 $\\alpha_0$ 和 $\\alpha_1$，我们首先重新整理控制方程，以分离出包含未知数的项。这在可测量量和参数之间建立了一个线性关系：\n$$ u(t) - m \\, a(t) - k \\, x(t) = \\alpha_0 v(t) + \\alpha_1 |v(t)| v(t) $$\n该方程构成了线性回归问题的基础。我们定义一个目标变量 $b(t) = u(t) - m \\, a(t) - k \\, x(t)$。给定一组 $N$ 个时间序列测量值 $(x(t_i), v(t_i), a(t_i), u(t_i))$（$i=0, \\dots, N-1$），我们可以构建一个线性方程组：\n$$ \\mathbf{b} \\approx \\mathbf{A} \\boldsymbol{\\alpha} $$\n其中 $\\mathbf{b}$ 是一个大小为 $N$ 的列向量，其元素为 $b(t_i)$；$\\boldsymbol{\\alpha}$ 是参数列向量 $[\\alpha_0, \\alpha_1]^T$；$\\mathbf{A}$ 是 $N \\times 2$ 的设计矩阵，其行向量为 $[v(t_i), |v(t_i)|v(t_i)]$。近似符号 $\\approx$ 表明 $u(t)$ 中存在测量噪声。\n\n估计任务是找到向量 $\\boldsymbol{\\alpha}$，使其在物理约束 $\\alpha_0 \\ge 0$ 和 $\\alpha_1 \\ge 0$ 的条件下，最小化残差平方和 $||\\mathbf{A}\\boldsymbol{\\alpha} - \\mathbf{b}||_2^2$。这是一个非负最小二乘 (NNLS) 问题。可以使用标准优化例程（如 `scipy.optimize.nnls`）高效求解。\n\n对于每个测试用例，总体算法流程如下：\n1.  **数据生成**：创建一个合成数据集。\n    -   生成一个时间向量 $t$，包含 $N$ 个样本，时间步长为 $\\Delta t$。\n    -   指定一个正弦运动剖面 $x(t) = X_0 \\sin(\\omega t)$。速度 $v(t)$ 和加速度 $a(t)$ 通过解析微分获得。\n    -   使用给定的真实参数 $(\\alpha_0^{\\mathrm{true}}, \\alpha_1^{\\mathrm{true}})$ 计算真实摩擦力 $F_{\\mathrm{fric}}^{\\mathrm{true}}(t)$。\n    -   通过评估 $m a(t) + k x(t) + F_{\\mathrm{fric}}^{\\mathrm{true}}(t)$ 并添加具有指定标准差和固定随机种子的零均值高斯噪声，来合成“测量”的驱动力 $u(t)$，以确保可复现性。\n\n2.  **参数估计**：\n    -   根据生成的数据 $(x, v, a, u)$ 和已知的系统参数 $(m, k)$ 构建目标向量 $\\mathbf{b}$ 和设计矩阵 $\\mathbf{A}$。\n    -   求解 NNLS 问题以获得估计参数 $\\hat{\\alpha}_0$ 和 $\\hat{\\alpha}_1$。\n\n3.  **输出计算**：\n    -   计算时间序列上的均方根速度：$v_{\\mathrm{rms}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} v(t_i)^2}$。\n    -   计算此速度下的有效摩擦系数：$c_{\\mathrm{eff}} = \\hat{\\alpha}_0 + \\hat{\\alpha}_1 v_{\\mathrm{rms}}$。\n    -   对所有时间样本验证耗散功率的非负性，$P_{\\mathrm{diss}}(t_i) = (\\hat{\\alpha}_0 + \\hat{\\alpha}_1 |v(t_i)|) v(t_i)^2 \\ge 0$。由于 NNLS 保证 $\\hat{\\alpha}_0 \\ge 0$ 和 $\\hat{\\alpha}_1 \\ge 0$，且 $v(t_i)^2 \\ge 0$ 和 $|v(t_i)| \\ge 0$，因此该条件在数学上保证得到满足。布尔标志用作对这一理论属性的确认。\n\n4.  **格式化**：将每个案例的最终结果（一个包含 $c_{\\mathrm{eff}}$ 和布尔标志的列表）格式化为字符串。然后将这些字符串汇总为指定的最终列表格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Solves the hybrid modeling problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path\n        (2.0, 5.0, 0.15, 3.0, 0.01, 1000, 0.8, 0.3, 0.05, 42),\n        # Case 2: boundary condition (purely viscous)\n        (1.2, 8.0, 0.08, 2.5, 0.01, 800, 1.0, 0.0, 0.02, 123),\n        # Case 3: edge case (near-zero speeds)\n        (3.5, 4.0, 0.02, 1.5, 0.01, 600, 0.5, 0.1, 0.01, 7),\n    ]\n\n    results_list = []\n    \n    for case in test_cases:\n        m, k, X0, omega, dt, N, alpha0_true, alpha1_true, noise_std, seed = case\n\n        # 1. Generate synthetic data\n        # Time vector\n        t = np.arange(N) * dt\n        \n        # Motion profile\n        x = X0 * np.sin(omega * t)\n        v = X0 * omega * np.cos(omega * t)\n        a = -X0 * omega**2 * np.sin(omega * t)\n        \n        # True friction force\n        F_fric_true = alpha0_true * v + alpha1_true * np.abs(v) * v\n        \n        # Generate reproducible noise\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(loc=0.0, scale=noise_std, size=N)\n        \n        # Synthesize measured actuation force\n        u = m * a + k * x + F_fric_true + noise\n\n        # 2. Set up and solve the NNLS problem\n        # Target vector b(t) = u(t) - m*a(t) - k*x(t)\n        b = u - m * a - k * x\n        \n        # Design matrix A(t) = [v(t), |v(t)|v(t)]\n        A = np.vstack([v, np.abs(v) * v]).T\n        \n        # Solve for alpha = [alpha0, alpha1] using Non-Negative Least Squares\n        alpha_est, _ = nnls(A, b)\n        alpha0_est, alpha1_est = alpha_est\n\n        # 3. Calculate specified outputs\n        # Root-mean-square speed\n        v_rms = np.sqrt(np.mean(v**2))\n        \n        # Effective friction coefficient at v_rms\n        c_eff = alpha0_est + alpha1_est * v_rms\n        \n        # Verify positivity of dissipated power\n        # P_diss = (alpha0*v + alpha1*|v|*v)*v = alpha0*v^2 + alpha1*|v|*v^2\n        # Since alpha0_est, alpha1_est from NNLS are >= 0, and v^2, |v| >=0,\n        # P_diss is guaranteed to be non-negative.\n        dissipated_power = (alpha0_est * v + alpha1_est * np.abs(v) * v) * v\n        dissipation_positive_flag = np.all(dissipated_power >= 0.0)\n\n        # Append result for the current case\n        results_list.append([c_eff, dissipation_positive_flag])\n\n    # Final print statement in the exact required format.\n    # The format [[c1,flag1],[c2,flag2]] is achieved by printing the\n    # string representation of the list of lists and removing spaces.\n    print(str(results_list).replace(\" \", \"\"))\n\nsolve()\n\n```"
        },
        {
            "introduction": "任何物理模型所面临的一个关键考验是其遵守基本守恒定律的能力。本实践将探讨如何在不违反质量守恒的前提下，将数据驱动的修正项整合到流体动力学模型中。你将通过实现一个有限体积法模拟，来直接比较“守恒的”通量形式修正与“非守恒的”源项形式修正，从而对如何设计结构上可靠的混合模型获得具体的认识 。",
            "id": "4226924",
            "problem": "考虑一个长度为 $L$ 的一维周期性域，离散为 $N_x$ 个宽度为 $\\Delta x = L / N_x$ 的控制体。令 $u(x,t)$ 表示一个标量场，代表信息物理系统（CPS）数字孪生中守恒量的密度。基于物理的基线模型是一个线性平流偏微分方程（PDE），由连续性定律控制，表示为 $\\partial_t u + \\partial_x f_p(u) = 0$，其中 $f_p(u) = c u$，常数 $c$ 为平流速度。为了提高模型保真度，引入了一个数据驱动的学习修正项。混合模型可以是以下两种之一：\n- 守恒修正：存在一个通量函数 $g(u)$，使得学习项以散度形式进入方程，即 $\\partial_t u + \\partial_x f_p(u) + \\partial_x g(u) = 0$。\n- 非守恒修正：学习项以源项 $s(u)$ 形式进入方程，即 $\\partial_t u + \\partial_x f_p(u) = s(u)$。\n\n在周期性边界条件下，如果学习修正是守恒的（通量形式），则 $u$ 在整个域上的空间积分 $M(t) = \\int_0^L u(x,t) \\, dx$ 必须随时间保持恒定。为了在离散仿真中验证此属性，我们计算总质量与其初始值的绝对偏差的时间积分：\n$$\nI = \\int_0^T \\left| M(t) - M(0) \\right| \\, dt.\n$$\n一个近似守恒的格式将产生接近于零的 $I$；我们将 $I$ 与指定的容差 $\\varepsilon$ 进行比较，以返回一个布尔判定结果。初始条件中使用的三角函数的角度单位必须是弧度。\n\n离散数值格式要求：\n- 使用有限体积法（FVM）以确保在没有源项的情况下，通量差能够对消并保证质量守恒。对于索引为 $i \\in \\{0,1,\\dots,N_x-1\\}$ 的每个控制体，在一个时间步长 $\\Delta t$ 内，使用在 $i+1/2$ 和 $i-1/2$ 处的面通量将 $u_i^n$ 更新为 $u_i^{n+1}$，这些面通量是物理通量与（若适用）学习通量之和。对于 $c>0$ 的线性平流，物理通量使用迎风格式，学习通量使用中心平均以保证守恒性。对于非守恒情况，在单元中心添加源项。离散格式必须遵循周期性边界条件。所有计算均不带物理单位，任何三角函数求值均使用弧度。\n\n初始条件：\n- 使用 $u(x,0) = u_0(x) = a_0 + a_1 \\sin(2 \\pi x / L)$，其中 $a_0$ 和 $a_1$ 为指定值。由于正弦项的均值为零，积分 $M(0)$ 等于 $a_0 L$。\n\n验证指标和决策规则：\n- 通过在仿真步骤上进行数值积分来计算 $I$ 的离散近似值：\n$$\nI \\approx \\sum_{n=1}^{N_t} \\Delta t \\, \\left| M^n - M^0 \\right|, \\quad M^n \\approx \\Delta x \\sum_{i=0}^{N_x-1} u_i^n,\n$$\n其中 $N_t$ 是时间步数。\n- 如果 $I \\le \\varepsilon$，则声明学习修正为守恒的，否则为非守恒的。程序必须为每个测试用例输出一个布尔值。\n\n测试套件和参数：\n- 以下测试涵盖了一个典型的守恒学习修正、一个非守恒源项、一个零修正的边缘情况以及一个粗网格的边界情况场景。对于所有情况，使用 $L = 1$（无量纲）、$c > 0$ 和周期性边界条件。\n\n1. 正常情况（守恒学习通量）：\n    - $N_x = 128$，$L = 1$，$c = 1$，$\\Delta x = L/N_x$，$\\Delta t = 0.5 \\, \\Delta x / c$，$T = 0.5$，$a_0 = 0.7$，$a_1 = 0.3$，学习通量 $g(u) = \\alpha u^3$ 且 $\\alpha = 0.2$，容差 $\\varepsilon = 10^{-10}$。\n2. 非守恒源项：\n    - $N_x = 128$，$L = 1$，$c = 1$，$\\Delta x = L/N_x$，$\\Delta t = 0.5 \\, \\Delta x / c$，$T = 0.5$，$a_0 = 0.7$，$a_1 = 0.3$，源项 $s(u) = \\beta u$ 且 $\\beta = 0.05$，容差 $\\varepsilon = 10^{-6}$。\n3. 零学习修正（边缘情况）：\n    - $N_x = 256$，$L = 1$，$c = 1$，$\\Delta x = L/N_x$，$\\Delta t = 0.5 \\, \\Delta x / c$，$T = 0.5$，$a_0 = 0.7$，$a_1 = 0.3$，学习通量 $g(u) = \\alpha u^3$ 且 $\\alpha = 0$，容差 $\\varepsilon = 10^{-12}$。\n4. 接近 Courant–Friedrichs–Lewy (CFL) 极限的粗网格（边界情况）：\n    - $N_x = 8$，$L = 1$，$c = 1$，$\\Delta x = L/N_x$，$\\Delta t = \\Delta x / c$，$T = 0.25$，$a_0 = 0.7$，$a_1 = 0.3$，学习通量 $g(u) = \\alpha u^3$ 且 $\\alpha = 5.0$，容差 $\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含测试套件的布尔结果，格式为方括号内以逗号分隔的列表（例如，“[True,False,True,True]”）。",
            "solution": "该问题是有效的，因为它具有科学依据、提法恰当、客观且完整。它提出了一个计算物理学领域的明确任务，与混合建模有关，这是信息物理系统研究中的一个前沿课题。该问题基于守恒定律的基本原理及其使用有限体积法（FVM）的数值解法。所有参数和数值格式都已明确定义，从而可以得到唯一且可验证的解。\n\n问题的核心是验证标量场 $u(x,t)$ 的两种混合模型的质量守恒属性。$u$ 的演化由一个偏微分方程（PDE）控制。\n该PDE的一般形式为 $\\partial_t u + \\partial_x F(u) = S(u)$，其中 $F(u)$ 是总通量，$S(u)$ 是源项。\n在此问题中，总通量是基于物理的通量 $f_p(u) = c u$ 和学习修正通量 $g(u)$ 的和。源项用 $s(u)$ 表示。\n- **守恒**模型将修正项以通量形式表示：$F(u) = c u + g(u)$ 且 $S(u)=0$。其PDE为 $\\partial_t u + \\partial_x (c u + g(u)) = 0$。\n- **非守恒**模型将修正项作为源项：$F(u) = c u$ 且 $S(u) = s(u)$。其PDE为 $\\partial_t u + \\partial_x (c u) = s(u)$。\n\n对于长度为 $L$ 的周期性域，质量守恒原理指出，如果控制方程是守恒的，则总质量 $M(t) = \\int_0^L u(x,t) \\, dx$ 是恒定的。这可以通过在整个域上对守恒PDE进行积分来证明：\n$$ \\frac{dM}{dt} = \\frac{d}{dt} \\int_0^L u \\, dx = \\int_0^L \\partial_t u \\, dx = - \\int_0^L \\partial_x F(u) \\, dx $$\n根据微积分基本定理，这变为：\n$$ \\frac{dM}{dt} = - [F(u(L,t)) - F(u(0,t))] $$\n由于周期性边界条件，$u(L,t) = u(0,t)$，因此 $F(u(L,t)) = F(u(0,t))$。这导致 $\\frac{dM}{dt} = 0$，意味着 $M(t)$ 是恒定的。\n如果存在源项 $S(u)$，则 $\\frac{dM}{dt} = \\int_0^L S(u) \\, dx$，这通常不为零，因此质量不守恒。\n\n我们将实现一个有限体积法（FVM）格式来数值求解该PDE。对于宽度为 $\\Delta x$ 的控制体 $i$，其半离散FVM形式为：\n$$ \\frac{du_i}{dt} = - \\frac{1}{\\Delta x} (F_{i+1/2} - F_{i-1/2}) + S_i $$\n其中 $u_i$ 是 $u$ 的单元平均值，$F_{i\\pm1/2}$ 是单元面上的数值通量，$S_i$ 是单元平均源项。使用前向欧拉法在一个时间步长 $\\Delta t$ 上进行时间积分：\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2}^n - F_{i-1/2}^n) + \\Delta t S_i^n $$\n问题指定了数值通量：\n- 物理通量 $f_p(u) = cu$ ($c>0$)：迎风格式，因此 $f_{p, i+1/2} = f_p(u_i) = c u_i$。\n- 学习通量 $g(u)$：中心平均，因此 $g_{i+1/2} = \\frac{g(u_i) + g(u_{i+1})}{2}$。\n- 在面 $i+1/2$ 处的总通量：$F_{i+1/2} = c u_i + \\frac{g(u_i) + g(u_{i+1})}{2}$。\n- 在单元 $i$ 处的源项是 $S_i = s(u_i)$。\n\n对于周期性域，FVM的一个关键特性是，如果没有源项，离散总质量 $M^n = \\Delta x \\sum_{i=0}^{N_x-1} u_i^n$ 是精确守恒的。这是因为将更新方程对所有单元 $i$ 求和，在周期性边界条件下，通量差会形成一个可对消为零的伸缩求和：$\\sum_{i=0}^{N_x-1} (F_{i+1/2} - F_{i-1/2}) = 0$。因此，$\\sum_i u_i^{n+1} = \\sum_i u_i^n$，意味着 $M^{n+1} = M^n$。\n\n验证过程涉及计算积分 $I = \\int_0^T |M(t) - M(0)| \\, dt$，其离散近似为 $I \\approx \\sum_{n=1}^{N_t} \\Delta t |M^n - M^0|$。如果格式是守恒的，$M^n$ 应在浮点精度范围内等于 $M^0$，使得 $I$ 非常接近于零。如果 $I \\le \\varepsilon$，则模型被认为是守恒的。\n\n实现将通过创建一个仿真函数来进行，该函数接受每个测试用例的参数。该函数将：\n1. 初始化网格和初始条件 $u(x,0) = a_0 + a_1 \\sin(2 \\pi x / L)$。\n2. 计算初始质量 $M^0$。\n3. 循环执行时间步，直到达到最终时间 $T$。在每一步中：\n   a. 计算所有单元面上的数值通量和单元中心的源项，使用 `numpy.roll` 处理周期性边界。\n   b. 使用FVM公式更新解向量 $u$。\n   c. 计算当前质量 $M^n$，并将 $\\Delta t |M^n - M^0|$ 加到累积积分 $I$ 中。\n4. 循环结束后，将最终的 $I$ 与给定的容差 $\\varepsilon$ 进行比较，以返回一个布尔结果。\n\n此程序将应用于指定的四个测试用例。对于守恒情况（1、3、4），预期结果为 `True`，对于非守恒情况（2），预期结果为 `False`，因为FVM格式的数值守恒性与情况4中可能出现的数值稳定性问题无关。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def run_simulation(Nx, L, c, cfl, T, a0, a1, alpha, beta, epsilon):\n        \"\"\"\n        Runs a single simulation case for the hybrid model validation.\n\n        Args:\n            Nx (int): Number of control volumes.\n            L (float): Domain length.\n            c (float): Advection speed.\n            cfl (float): CFL number to determine the time step.\n            T (float): Total simulation time.\n            a0 (float): Constant part of initial condition.\n            a1 (float): Amplitude of sine part of initial condition.\n            alpha (float): Coefficient for the learned conservative flux g(u).\n            beta (float): Coefficient for the learned non-conservative source s(u).\n            epsilon (float): Tolerance for the conservation integral.\n\n        Returns:\n            bool: True if the model is conservative (I <= epsilon), False otherwise.\n        \"\"\"\n        # 1. Setup discretization and grid\n        dx = L / Nx\n        dt = cfl * dx / c\n        \n        # 2. Initialize the solution field u\n        # Cell centers for finite volume method\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        u = a0 + a1 * np.sin(2 * np.pi * x_centers / L)\n        \n        # 3. Define learned correction functions\n        def g(u_vec):\n            if alpha == 0.0:\n                # Return scalar 0.0 to enable broadcasting\n                return 0.0\n            return alpha * u_vec**3\n            \n        def s(u_vec):\n            if beta == 0.0:\n                return 0.0\n            return beta * u_vec\n            \n        # 4. Calculate initial mass and initialize validation integral\n        m0 = np.sum(u) * dx\n        integral_I = 0.0\n        \n        current_time = 0.0\n        \n        # 5. Time-stepping loop\n        while current_time < T:\n            # Use smaller timestep if the default dt overshoots T\n            dt_step = min(dt, T - current_time)\n            \n            # --- FVM Update Step ---\n            # Periodic boundaries are handled implicitly by np.roll.\n            u_prev = np.roll(u, 1) # u at i-1\n            u_next = np.roll(u, -1) # u at i+1\n            \n            # Physics flux (fp): upwind for c > 0\n            # fp at face i+1/2 is c*u_i\n            # fp at face i-1/2 is c*u_{i-1}\n            fp_plus = c * u\n            fp_minus = c * u_prev\n            \n            # Learned flux (g): centered average\n            # g at face i+1/2 is (g(u_i) + g(u_{i+1}))/2\n            # g at face i-1/2 is (g(u_{i-1}) + g(u_i))/2\n            g_vals = g(u)\n            if alpha != 0.0:\n                g_next_vals = np.roll(g_vals, -1)\n                g_prev_vals = np.roll(g_vals, 1)\n                fg_plus = (g_vals + g_next_vals) * 0.5\n                fg_minus = (g_prev_vals + g_vals) * 0.5\n            else:\n                fg_plus = 0.0\n                fg_minus = 0.0\n\n            # Total numerical flux at faces\n            F_plus = fp_plus + fg_plus   # Flux at i+1/2\n            F_minus = fp_minus + fg_minus # Flux at i-1/2\n            \n            # Learned source term (S)\n            S = s(u)\n            \n            # Update solution using Forward Euler FVM scheme\n            u = u - (dt_step / dx) * (F_plus - F_minus) + dt_step * S\n            # --- End of FVM Update Step ---\n            \n            current_time += dt_step\n            \n            # 6. Update the conservation validation integral I\n            m_current = np.sum(u) * dx\n            integral_I += dt_step * np.abs(m_current - m0)\n            \n        # 7. Return the boolean verdict\n        return integral_I <= epsilon\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Happy path (conservative learned flux)\n        {'Nx': 128, 'L': 1.0, 'c': 1.0, 'cfl': 0.5, 'T': 0.5, 'a0': 0.7, 'a1': 0.3, 'alpha': 0.2, 'beta': 0.0, 'epsilon': 1e-10},\n        # 2. Non-conservative source\n        {'Nx': 128, 'L': 1.0, 'c': 1.0, 'cfl': 0.5, 'T': 0.5, 'a0': 0.7, 'a1': 0.3, 'alpha': 0.0, 'beta': 0.05, 'epsilon': 1e-6},\n        # 3. Zero learned correction (edge case)\n        {'Nx': 256, 'L': 1.0, 'c': 1.0, 'cfl': 0.5, 'T': 0.5, 'a0': 0.7, 'a1': 0.3, 'alpha': 0.0, 'beta': 0.0, 'epsilon': 1e-12},\n        # 4. Coarse grid near CFL limit (boundary case)\n        {'Nx': 8, 'L': 1.0, 'c': 1.0, 'cfl': 1.0, 'T': 0.25, 'a0': 0.7, 'a1': 0.3, 'alpha': 5.0, 'beta': 0.0, 'epsilon': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当使用像神经网络这样灵活的函数逼近器时，如何施加如边界条件之类的物理约束是一个关键的设计抉择。本练习对比了两种强有力的技术：通过约束模型架构实现的“硬”约束，以及通过在损失函数中添加惩罚项实现的“软”约束。通过推导惩罚项方法的梯度，你将对训练物理知识通知的神经网络时所涉及的优化动态及其内在权衡有更深刻的理解 。",
            "id": "4226906",
            "problem": "一个一维导热杆的数字孪生 (DT)——一种代表性的信息物理系统 (CPS)——模拟了空间域 $x \\in [0,1]$ 上的稳态温度场 $u(x)$。该温度场必须满足狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 1$，以及一个本问题中无需考虑的物理残差。您正在比较两种混合建模策略，这两种策略通过人工神经网络 (ANN) 结合物理和数据来表示解的未知分量。\n\n策略 A（通过约束架构进行硬性强制）：使用形式为 $u_{\\mathrm{c}}(x;\\theta) = g(x) + s(x)\\,N(x;\\theta)$ 的试探解，其中 $g(x)$ 是一个满足边界条件的固定函数，$s(x)$ 是一个满足 $s(0) = 0$ 和 $s(1) = 0$ 的固定函数，而 $N(x;\\theta)$ 是一个参数为 $\\theta$ 的人工神经网络。\n\n策略 B（通过损失惩罚进行软性强制）：使用一个无约束的人工神经网络 $u_{\\mathrm{u}}(x;\\theta)$，并通过边界惩罚项对损失函数中的边界违规进行惩罚\n$$\nL_{\\mathrm{bc}}(\\theta) = \\lambda \\left[ \\left(u_{\\mathrm{u}}(0;\\theta) - 0\\right)^{2} + \\left(u_{\\mathrm{u}}(1;\\theta) - 1\\right)^{2} \\right],\n$$\n其中 $\\lambda > 0$ 是一个固定的标量权重。\n\n对于策略 A，令 $g(x) = x$ 且 $s(x) = x(1-x)$。对于策略 B，采用一个显式的无约束人工神经网络拟设 $u_{\\mathrm{u}}(x;\\theta) = \\theta_{1}\\,\\tanh\\!\\left(\\theta_{2}\\,x\\right)$，其参数向量为 $\\theta = (\\theta_{1},\\theta_{2})$。\n\n任务：\n- 根据边界条件的基本定义以及性质 $s(0)=0$ 和 $s(1)=0$，解释为什么策略 A 对所有 $\\theta$ 值都能强制满足边界条件。\n- 从 $L_{\\mathrm{bc}}(\\theta)$ 的定义和梯度的链式法则出发，为策略 B 在给定拟设 $u_{\\mathrm{u}}(x;\\theta) = \\theta_{1}\\,\\tanh\\!\\left(\\theta_{2}\\,x\\right)$ 下，推导其精确的解析梯度 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta)$。将最终答案表示为关于 $\\lambda$、$\\theta_{1}$ 和 $\\theta_{2}$ 的单个闭式行向量。不要代入数值。\n- 基于约束优化和光滑罚函数法的基本原理，简要讨论在可行域附近，策略 A 和策略 B 的优化曲面有何不同。\n\n您的最终答案必须是策略 B 的梯度向量，以单个闭式解析表达式的形式给出。请使用 $\\mathrm{pmatrix}$ 环境将梯度表示为一个行矩阵。无需四舍五入，也无需单位。",
            "solution": "所述问题在科学上是合理的、良定的和自洽的。它描述了在物理知识启发的机器学习中，强制施加边界条件的两种常用技术之间的标准比较：通过架构构建的硬性强制和通过损失函数中的惩罚项的软性强制。所有必要的定义和函数都已提供，任务是数学原理的直接应用。因此，该问题是有效的，可以给出解答。\n\n该问题要求完成三个不同的任务：解释为什么策略 A 满足边界条件，推导策略 B 的边界损失梯度，以及简要讨论由此产生的优化曲面。\n\n首先，我们分析策略 A，它使用的试探解为 $u_{\\mathrm{c}}(x;\\theta) = g(x) + s(x)\\,N(x;\\theta)$。问题指明函数 $g(x)$ 必须满足狄利克雷边界条件，函数 $s(x)$ 在边界处必须为零。给定的边界条件是 $u(0)=0$ 和 $u(1)=1$。\n对于策略 A，给定 $g(x)=x$ 和 $s(x)=x(1-x)$。让我们验证这些辅助函数是否满足其要求。\n对于 $g(x)$，我们有 $g(0)=0$ 和 $g(1)=1$，因此它正确地满足了边界条件。\n对于 $s(x)$，我们有 $s(0)=0(1-0)=0$ 和 $s(1)=1(1-1)=0$，因此它正确地在边界处为零。\n\n现在，我们在边界 $x=0$ 和 $x=1$ 处计算试探解 $u_{\\mathrm{c}}(x;\\theta)$ 的值：\n在 $x=0$ 处：\n$u_{\\mathrm{c}}(0;\\theta) = g(0) + s(0)\\,N(0;\\theta)$\n代入值 $g(0)=0$ 和 $s(0)=0$：\n$u_{\\mathrm{c}}(0;\\theta) = 0 + (0) \\cdot N(0;\\theta) = 0$\n这个结果与神经网络输出 $N(0;\\theta)$ 的值无关，因此对任何参数向量 $\\theta$ 都成立。\n\n在 $x=1$ 处：\n$u_{\\mathrm{c}}(1;\\theta) = g(1) + s(1)\\,N(1;\\theta)$\n代入值 $g(1)=1$ 和 $s(1)=0$：\n$u_{\\mathrm{c}}(1;\\theta) = 1 + (0) \\cdot N(1;\\theta) = 1$\n这个结果也与 $N(1;\\theta)$ 的值无关，对任何参数向量 $\\theta$ 都成立。\n因此，通过其构造本身，策略 A 中的试探解 $u_{\\mathrm{c}}(x;\\theta)$ 对神经网络参数 $\\theta$ 的所有可能选择，都能严格强制满足狄利克雷边界条件 $u(0)=0$ 和 $u(1)=1$。\n\n接下来，我们处理策略 B 并推导边界损失函数 $L_{\\mathrm{bc}}(\\theta)$ 的梯度。参数向量为 $\\theta = (\\theta_1, \\theta_2)$。梯度是一个行向量，由 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta) = \\begin{pmatrix} \\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_1}  \\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_2} \\end{pmatrix}$ 给出。\n边界损失定义为：\n$$L_{\\mathrm{bc}}(\\theta) = \\lambda \\left[ \\left(u_{\\mathrm{u}}(0;\\theta) - 0\\right)^{2} + \\left(u_{\\mathrm{u}}(1;\\theta) - 1\\right)^{2} \\right]$$\n无约束人工神经网络的特定拟设是 $u_{\\mathrm{u}}(x;\\theta) = \\theta_{1}\\,\\tanh(\\theta_{2}\\,x)$。\n\n首先，我们在边界 $x=0$ 和 $x=1$ 处计算拟设的值：\n$$u_{\\mathrm{u}}(0;\\theta) = \\theta_{1}\\,\\tanh(\\theta_{2} \\cdot 0) = \\theta_{1}\\,\\tanh(0) = 0$$\n$$u_{\\mathrm{u}}(1;\\theta) = \\theta_{1}\\,\\tanh(\\theta_{2} \\cdot 1) = \\theta_{1}\\,\\tanh(\\theta_{2})$$\n将这些代入损失函数，可简化表达式：\n$L_{\\mathrm{bc}}(\\theta) = \\lambda \\left[ (0)^{2} + (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)^{2} \\right] = \\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)^{2}$\n\n现在，我们使用链式法则计算关于 $\\theta_1$ 和 $\\theta_2$ 的偏导数。\n对于 $\\theta_1$：\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_1} = \\lambda \\cdot 2 (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\frac{\\partial}{\\partial \\theta_1}(\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)$$\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_1} = 2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\tanh(\\theta_{2})$$\n\n对于 $\\theta_2$：\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_2} = \\lambda \\cdot 2 (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\frac{\\partial}{\\partial \\theta_2}(\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)$$\n我们需要 $\\tanh(z)$ 的导数，即 $\\frac{d}{dz}\\tanh(z) = \\frac{1}{\\cosh^2(z)}$。应用链式法则：\n$$\\frac{\\partial}{\\partial \\theta_2}(\\theta_{1}\\,\\tanh(\\theta_{2})) = \\theta_1 \\cdot \\frac{1}{\\cosh^2(\\theta_2)}$$\n将此代回 $L_{\\mathrm{bc}}$ 的偏导数中：\n$$\\frac{\\partial L_{\\mathrm{bc}}}{\\partial \\theta_2} = 2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1) \\cdot \\frac{\\theta_1}{\\cosh^2(\\theta_2)}$$\n\n组合这两个分量，我们得到梯度向量 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta)$：\n$$\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta) = \\begin{pmatrix} 2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)\\tanh(\\theta_{2}) & 2\\lambda (\\theta_{1}\\,\\tanh(\\theta_{2}) - 1)\\frac{\\theta_1}{\\cosh^2(\\theta_2)} \\end{pmatrix}$$\n\n最后，我们简要讨论两种策略之间优化曲面的差异。\n在策略 A 中，满足边界条件是一个硬约束，通过架构来强制执行。$\\theta$ 的整个参数空间都映射到一个函数空间，其中所有函数相对于边界条件都是可行的。优化算法由物理残差损失（未指定，但假定存在）驱动，在这个可行子空间内进行搜索。优化曲面仅由物理损失决定，优化器永远不会被引导去修正边界违规，因为违规根本不会发生。\n\n相比之下，策略 B 通过罚函数法采用软约束。$\\theta$ 的参数空间映射到一个更大的函数空间，其中大部分函数是不可行的（即违反边界条件）。边界损失 $L_{\\mathrm{bc}}(\\theta)$ 在总损失曲面中创建了一个惩罚“井”或“谷”。该惩罚项的最小值（在 $L_{\\mathrm{bc}}=0$ 处）定义了参数空间中的可行区域。总损失曲面是物理损失和该惩罚项的叠加。对于任何有限的惩罚权重 $\\lambda$，总损失的全局最小值很可能是一个点，在该点边界条件仅被近似满足，这代表了在满足物理规律和满足边界条件之间的一种折衷。在可行区域附近，惩罚项的梯度 $\\nabla_{\\theta} L_{\\mathrm{bc}}(\\theta)$ 主导了搜索方向，将参数拉向满足边界条件的方向。这可能会引入陡峭的梯度和潜在的数值刚度问题，与策略 A 相比，使得优化问题更具挑战性，因为在策略 A 中，搜索被内在地限制在可行集内。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2\\lambda (\\theta_1 \\tanh(\\theta_2) - 1) \\tanh(\\theta_2)  & 2\\lambda (\\theta_1 \\tanh(\\theta_2) - 1) \\frac{\\theta_1}{\\cosh^2(\\theta_2)} \\end{pmatrix}}\n$$"
        }
    ]
}