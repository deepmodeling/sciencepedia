{
    "hands_on_practices": [
        {
            "introduction": "数值稳定性是任何可靠模拟的基石。本练习将引导你完成一个基础的分析过程，以确定联合仿真的稳定性边界。通过分析一个简单但具有代表性的耦合电路系统，你将推导出为防止仿真结果发散所允许的最大通信步长 $H$——这是每位仿真工程师都必须掌握的关键技能。",
            "id": "4208719",
            "problem": "一个线性阻容网络的数字孪生被划分为两个异构模拟器，它们使用雅可比方案以宏步长 $H$ 进行协同仿真。子系统 $1$ 由一个到地的电容器 $C_{1}$ 和一个到地的电导 $G_{1}$ 组成，其边界节点电压为 $V_{1}(t)$。子系统 $2$ 由一个到地的电容器 $C_{2}$ 和一个到地的电导 $G_{2}$ 组成，其边界节点电压为 $V_{2}(t)$。两个子系统通过其边界节点之间的一个电导 $G_{c}$ 互连，使得连续时间节点动力学遵循基尔霍夫电流定律 (KCL)。由于零阶保持交换，每个模拟器在每个宏步长内对其子系统进行积分，同时邻居的边界电压保持恒定。每个子系统都使用显式欧拉法在宏步长上前进。\n\n从KCL和显式欧拉法的定义出发，构建离散时间互连映射，将 $t_{n}$ 时的边界电压 $\\begin{pmatrix} V_{1}^{n} \\\\ V_{2}^{n} \\end{pmatrix}$推进到 $t_{n+1} = t_{n} + H$ 时的 $\\begin{pmatrix} V_{1}^{n+1} \\\\ V_{2}^{n+1} \\end{pmatrix}$。使用这个 $2 \\times 2$ 离散更新的特征值分析，推导出最大的宏步长 $H_{\\max}$，使得更新矩阵的谱半径严格小于 $1$。将你的最终答案表示为关于 $C_{1}$, $C_{2}$, $G_{1}$, $G_{2}$ 和 $G_{c}$ 的 $H_{\\max}$ 的单一闭式解析表达式。以秒为单位表示 $H_{\\max}$。不要在方框内的最终答案中包含单位。",
            "solution": "问题陈述被评估为具有科学依据、适定且客观。它描述了线性时不变系统协同仿真方法的数值分析中的一个标准问题。所有必要信息均已提供，问题没有矛盾或歧义。因此，该问题是有效的，并将推导出一个解决方案。\n\n第一步是使用基尔霍夫电流定律 (KCL) 在两个边界节点处建立控制系统动力学的连续时间常微分方程 (ODE)。\n\n在节点 $1$ 处，流出该节点的电流总和必须为零。流过电容器 $C_1$ 的电流是 $C_1 \\frac{dV_1}{dt}$，流过到地电导 $G_1$ 的电流是 $G_1 V_1$，流过耦合电导 $G_c$ 的电流是 $G_c(V_1 - V_2)$。在节点 $1$ 应用KCL：\n$$ C_1 \\frac{dV_1}{dt} + G_1 V_1 + G_c (V_1 - V_2) = 0 $$\n对 $\\frac{dV_1}{dt}$ 进行整理：\n$$ \\frac{dV_1}{dt} = - \\frac{G_1 + G_c}{C_1} V_1 + \\frac{G_c}{C_1} V_2 $$\n\n类似地，在节点 $2$ 处，流出该节点的电流总和必须为零。流过电容器 $C_2$ 的电流是 $C_2 \\frac{dV_2}{dt}$，流过到地电导 $G_2$ 的电流是 $G_2 V_2$，流过耦合电导 $G_c$ 的电流是 $G_c(V_2 - V_1)$。在节点 $2$ 应用KCL：\n$$ C_2 \\frac{dV_2}{dt} + G_2 V_2 + G_c (V_2 - V_1) = 0 $$\n对 $\\frac{dV_2}{dt}$ 进行整理：\n$$ \\frac{dV_2}{dt} = \\frac{G_c}{C_2} V_1 - \\frac{G_2 + G_c}{C_2} V_2 $$\n\n问题指定了使用宏步长 $H$ 的雅可比协同仿真方案。在此方案中，每个子系统在区间 $[t_n, t_{n+1}]$ 上进行积分，使用来自邻近子系统在区间开始时（$t_n$）的边界值。这是对耦合变量的零阶保持 (ZOH)。每个子系统内部使用的积分器是显式欧拉法。\n\n对于子系统 $1$，在 $[t_n, t_{n+1}]$ 上积分的ODE将 $V_2$ 视为等于 $V_2^n = V_2(t_n)$ 的常数：\n$$ \\frac{dV_1}{dt} = - \\frac{G_1 + G_c}{C_1} V_1 + \\frac{G_c}{C_1} V_2^n $$\n应用显式欧拉法 $y_{k+1} = y_k + h f(t_k, y_k)$，步长为 $H = t_{n+1} - t_n$：\n$$ V_1^{n+1} = V_1^n + H \\left( - \\frac{G_1 + G_c}{C_1} V_1^n + \\frac{G_c}{C_1} V_2^n \\right) $$\n$$ V_1^{n+1} = \\left( 1 - H \\frac{G_1 + G_c}{C_1} \\right) V_1^n + \\left( H \\frac{G_c}{C_1} \\right) V_2^n $$\n\n对于子系统 $2$，积分的ODE将 $V_1$ 视为等于 $V_1^n = V_1(t_n)$ 的常数：\n$$ \\frac{dV_2}{dt} = \\frac{G_c}{C_2} V_1^n - \\frac{G_2 + G_c}{C_2} V_2 $$\n应用显式欧拉法，步长为 $H$：\n$$ V_2^{n+1} = V_2^n + H \\left( \\frac{G_c}{C_2} V_1^n - \\frac{G_2 + G_c}{C_2} V_2^n \\right) $$\n$$ V_2^{n+1} = \\left( H \\frac{G_c}{C_2} \\right) V_1^n + \\left( 1 - H \\frac{G_2 + G_c}{C_2} \\right) V_2^n $$\n\n这两个离散时间方程可以写成矩阵形式，它定义了从时间 $t_n$ 的状态到时间 $t_{n+1}$ 的状态的互连映射：\n$$ \\begin{pmatrix} V_1^{n+1} \\\\ V_2^{n+1} \\end{pmatrix} = \\begin{pmatrix} 1 - H \\frac{G_1 + G_c}{C_1}  H \\frac{G_c}{C_1} \\\\ H \\frac{G_c}{C_2}  1 - H \\frac{G_2 + G_c}{C_2} \\end{pmatrix} \\begin{pmatrix} V_1^n \\\\ V_2^n \\end{pmatrix} $$\n令更新矩阵为 $M$。协同仿真是稳定的当且仅当 $M$ 的谱半径 $\\rho(M)$ 严格小于 $1$。谱半径是 $M$ 的特征值的最大绝对值。我们通过求解特征方程 $\\det(M - \\lambda I) = 0$ 来找到 $M$ 的特征值 $\\lambda$。\n为简化符号，令：\n$a = \\frac{G_1+G_c}{C_1}$， $b = \\frac{G_c}{C_1}$， $c = \\frac{G_c}{C_2}$， $d = \\frac{G_2+G_c}{C_2}$。矩阵 $M$ 为：\n$$ M = \\begin{pmatrix} 1 - Ha  Hb \\\\ Hc  1 - Hd \\end{pmatrix} $$\n特征方程为：\n$$ \\det \\begin{pmatrix} 1 - Ha - \\lambda  Hb \\\\ Hc  1 - Hd - \\lambda \\end{pmatrix} = 0 $$\n$$ (1 - Ha - \\lambda)(1 - Hd - \\lambda) - H^2bc = 0 $$\n$$ \\lambda^2 - (2 - H(a+d))\\lambda + (1 - H(a+d) + H^2ad - H^2bc) = 0 $$\n$\\lambda$ 的解由二次公式给出：\n$$ \\lambda = \\frac{2 - H(a+d) \\pm \\sqrt{(2 - H(a+d))^2 - 4(1 - H(a+d) + H^2(ad - bc))}}{2} $$\n平方根下的项简化为：\n$$ (4 - 4H(a+d) + H^2(a+d)^2) - (4 - 4H(a+d) + 4H^2(ad - bc)) = H^2((a+d)^2 - 4ad + 4bc) = H^2((a-d)^2 + 4bc) $$\n所以，特征值为：\n$$ \\lambda = \\frac{2 - H(a+d) \\pm H\\sqrt{(a-d)^2 + 4bc}}{2} $$\n$$ \\lambda = 1 - \\frac{H}{2}(a+d) \\pm \\frac{H}{2}\\sqrt{(a-d)^2 + 4bc} $$\n由于所有物理参数 $C_1, C_2, G_1, G_2, G_c$ 都是非负的，所以项 $a, b, c, d$ 也是非负的。平方根下的项是正的，因此特征值是实数。令 $k = \\sqrt{(a-d)^2 + 4bc}$。\n两个特征值是 $\\lambda_1 = 1 - \\frac{H}{2}(a+d-k)$ 和 $\\lambda_2 = 1 - \\frac{H}{2}(a+d+k)$。\n为了稳定性，我们要求对于 $i=1, 2$ 都有 $|\\lambda_i|  1$，对于实数特征值，这意味着 $-1  \\lambda_i  1$。\n\n我们可以证明 $a+d-k  0$，因为 $(a+d)^2 = (a-d)^2+4ad  (a-d)^2+4bc = k^2$（由于可以证明 $adbc$）。因此，$a+dk$。\n这意味着对于 $H0$，$\\frac{H}{2}(a+d-k)$ 和 $\\frac{H}{2}(a+d+k)$ 都是正的，因此两个特征值都小于 $1$。稳定性受限于下界，即 $\\lambda_i  -1$。\n\n对 $\\lambda_1$ 的条件是：\n$$ 1 - \\frac{H}{2}(a+d-k)  -1 \\implies 2  \\frac{H}{2}(a+d-k) \\implies H  \\frac{4}{a+d-k} $$\n对 $\\lambda_2$ 的条件是：\n$$ 1 - \\frac{H}{2}(a+d+k)  -1 \\implies 2  \\frac{H}{2}(a+d+k) \\implies H  \\frac{4}{a+d+k} $$\n由于 $k0$，我们有 $a+d+k  a+d-k$，这意味着 $\\frac{4}{a+d+k}  \\frac{4}{a+d-k}$。$H$ 的稳定域必须满足这两个不等式，因此它受到更严格的那个约束。因此，最大的宏步长 $H_{\\max}$ 由两个界限中较小的一个给出：\n$$ H_{\\max} = \\frac{4}{a+d+k} $$\n将 $a, d,$ 和 $k$ 的表达式代回：\n$$ H_{\\max} = \\frac{4}{(a+d) + \\sqrt{(a-d)^2 + 4bc}} $$\n$$ H_{\\max} = \\frac{4}{\\left(\\frac{G_1+G_c}{C_1} + \\frac{G_2+G_c}{C_2}\\right) + \\sqrt{\\left(\\frac{G_1+G_c}{C_1} - \\frac{G_2+G_c}{C_2}\\right)^2 + 4\\left(\\frac{G_c}{C_1}\\right)\\left(\\frac{G_c}{C_2}\\right)}} $$\n这个表达式可以写成：\n$$ H_{\\max} = \\frac{4}{\\left(\\frac{G_1+G_c}{C_1} + \\frac{G_2+G_c}{C_2}\\right) + \\sqrt{\\left(\\frac{G_1+G_c}{C_1} - \\frac{G_2+G_c}{C_2}\\right)^2 + \\frac{4G_c^2}{C_1 C_2}}} $$\n这是最大稳定宏步长 $H_{\\max}$ 的最终闭式表达式。$G/C$ 的单位是 $1/s$，所以 $H_{\\max}$ 的表达式正确地得出秒的单位。",
            "answer": "$$\\boxed{\\frac{4}{\\left(\\frac{G_{1}+G_{c}}{C_{1}} + \\frac{G_{2}+G_{c}}{C_{2}}\\right) + \\sqrt{\\left(\\frac{G_{1}+G_{c}}{C_{1}} - \\frac{G_{2}+G_{c}}{C_{2}}\\right)^{2} + \\frac{4G_{c}^{2}}{C_{1} C_{2}}}}}$$"
        },
        {
            "introduction": "除了简单的数值发散问题，许多信息物理系统本质上是“混合”的，即融合了连续动态与离散事件。本练习将解决一个关键挑战：如何确保在通信步长之间不会遗漏任何离散事件。我们将运用利普希茨连续性（Lipschitz continuity）等数学工具，推导出一个“安全”的步长，以保证事件检测的完整性，这是确保联合仿真正确性的核心环节之一。",
            "id": "4208801",
            "problem": "考虑一个信息物理系统数字孪生中的异构系统联合仿真，其中一个连续时间常微分方程 (ODE) 子系统和一个离散事件子系统通过宏步长通信进行耦合。连续时间子系统由初值问题 $\\dot{x}(t) = f(x(t), u(t), t)$ 描述，其状态为 $x(t) \\in \\mathbb{R}^{n}$，输入 $u(t)$ 在每个宏步长内保持恒定。当事件保护函数 $g(x,t)$ 穿过零点，即 $g(x(t), t)$ 的符号发生改变时，离散事件子系统会触发一个事件。\n\n假设对于从时间 $t_{k}$ 开始的当前宏步长，在某个紧凑的前向不变域上，以下基本性质成立：\n- ODE 子系统对状态时间导数提供了一个一致界：对于所有 $t \\in [t_{k}, t_{k} + H]$，有 $\\|\\dot{x}(t)\\| \\leq B_{x}$。\n- 事件保护函数 $g(x,t)$ 关于状态是利普希茨连续的，常数为 $L_{x} \\geq 0$；关于时间也是利普希茨连续的，常数为 $L_{t} \\geq 0$。因此对于域中的所有 $(x,t)$ 和 $(y,s)$，有 $|g(x,t) - g(y,s)| \\leq L_{x}\\|x - y\\| + L_{t}|t - s|$。\n- 在通信时刻 $t_{k}$，已知状态 $x_{k} := x(t_{k})$ 得到的保护函数值 $g_{k} := g(x_{k}, t_{k}) \\neq 0$ 为非零。\n\n你的任务是确定一个安全的宏步长 $H$，以确保在这些假设下，当仅使用宏步长端点上 $g$ 的值进行事件检测时，开区间 $(t_{k}, t_{k} + H)$ 内不会错过 $g(x(t), t)$ 的任何零点穿越。从所述的界和定义出发，推导出一个关于 $H$ 的最大阈值的解析表达式，该表达式保证保护函数在区间内部不会穿过零点，并且纯粹用 $g_{k}$、$B_{x}$、$L_{x}$ 和 $L_{t}$ 表示。\n\n请以单个闭式表达式的形式提供最终答案。无需进行数值计算。",
            "solution": "问题要求为联合仿真框架推导一个安全的宏步长 $H$。在此情境下，“安全”意味着保证在开时间区间 $(t_{k}, t_{k} + H)$ 内，事件保护函数 $g(x(t), t)$ 的任何零点穿越都不会被错过。系统状态为 $x(t)$，仿真从时间 $t_k$ 开始以宏步长进行。我们已知步长开始时的状态 $x_{k} = x(t_{k})$ 和保护函数值 $g_{k} = g(x_{k}, t_{k})$，以及关键条件 $g_{k} \\neq 0$。\n\n如果在某个时间 $t \\in (t_k, t_k+H)$，函数 $g(x(t), t)$ 的符号与 $g_{k}$ 的符号不同，则会错过一个零点穿越。根据介值定理，符号的改变意味着函数必定在区间内的某个点穿过了零。为了保证不错过任何零点穿越，我们必须确保对于开区间 $(t_k, t_k+H)$ 内的所有 $t$，保护函数值的变化量 $|g(x(t), t) - g_{k}|$ 严格小于其与零的初始距离，即 $|g_{k}|$。\n\n让我们为任意 $t \\in (t_{k}, t_{k} + H)$ 的变化量 $|g(x(t), t) - g_{k}|$ 建立一个上界。我们已知保护函数 $g$ 关于其两个自变量（状态 $x$ 和时间 $t$）是利普希茨连续的，各自的利普希茨常数为 $L_{x} \\ge 0$ 和 $L_{t} \\ge 0$。在点 $(x(t), t)$ 和 $(x_k, t_k) = (x(t_k), t_k)$ 之间应用利普希茨连续性的定义，我们有：\n$$|g(x(t), t) - g(x_{k}, t_{k})| \\leq L_{x}\\|x(t) - x_{k}\\| + L_{t}|t - t_{k}|$$\n由于 $t  t_{k}$，我们可以写成 $|t - t_{k}| = t - t_{k}$。令 $\\delta t = t-t_k$。不等式变为：\n$$|g(x(t), t) - g_{k}| \\leq L_{x}\\|x(t) - x(t_k)\\| + L_{t}(t - t_{k})$$\n\n接下来，我们必须对 $\\|x(t) - x(t_k)\\|$ 项进行界定。状态向量 $x(t)$ 根据常微分方程 $\\dot{x}(t) = f(x(t), u(t), t)$ 演化。根据微积分基本定理，状态在区间 $[t_{k}, t]$ 上的变化是其导数的积分：\n$$x(t) - x(t_k) = \\int_{t_{k}}^{t} \\dot{x}(\\tau) d\\tau$$\n取范数并应用积分的三角不等式（也称为闵可夫斯基积分不等式），我们得到：\n$$\\|x(t) - x(t_k)\\| = \\left\\| \\int_{t_{k}}^{t} \\dot{x}(\\tau) d\\tau \\right\\| \\leq \\int_{t_{k}}^{t} \\|\\dot{x}(\\tau)\\| d\\tau$$\n我们已知在宏步长区间内，状态导数的范数有一个一致界 $\\|\\dot{x}(t)\\| \\leq B_{x}$。将此界代入积分中得到：\n$$\\int_{t_{k}}^{t} \\|\\dot{x}(\\tau)\\| d\\tau \\leq \\int_{t_{k}}^{t} B_{x} d\\tau = B_{x}(t - t_{k})$$\n因此，我们得到了状态偏差的一个界：\n$$\\|x(t) - x(t_k)\\| \\leq B_{x}(t - t_{k})$$\n\n现在我们将此界代回到保护函数变化的不等式中：\n$$|g(x(t), t) - g_{k}| \\leq L_{x} (B_{x}(t - t_{k})) + L_{t}(t - t_{k})$$\n提出公因式 $(t-t_k)$，我们得到一个关于 $g$ 的变化的综合界：\n$$|g(x(t), t) - g_{k}| \\leq (L_{x}B_{x} + L_{t})(t - t_{k})$$\n\n为防止在 $t \\in (t_{k}, t_{k}+H)$ 发生零点穿越，$g(x(t), t)$ 的符号必须与 $g_k$ 的符号保持一致。\n让我们根据 $g_k$ 的符号分两种情况进行分析。令 $K = L_{x}B_{x} + L_{t}$。该界为 $|g(x(t), t) - g_{k}| \\leq K(t - t_{k})$。\n\n情况 1：$g_{k}  0$。我们必须确保对于所有 $t \\in (t_k, t_k+H)$，有 $g(x(t), t)  0$。\n根据反三角不等式，我们可以写出 $g(x(t), t) = g_k + (g(x(t), t) - g_k)$，这意味着 $g(x(t), t) \\geq g_k - |g(x(t), t) - g_k|$。\n使用我们推导出的界，我们有：\n$$g(x(t), t) \\geq g_k - K(t - t_{k})$$\n为了使 $g(x(t), t)$ 严格为正，我们需要 $g_k - K(t - t_{k})  0$，即 $g_k  K(t - t_{k})$。这个条件必须对所有 $t \\in (t_k, t_k+H)$ 成立。对于最大的 $t-t_k$ 值（趋近于 $H$），该条件最为严格。因此，我们必须要求 $g_k \\geq \\sup_{t \\in (t_k, t_k+H)} K(t-t_k) = K H$。如果这个条件成立，那么对于任何 $t \\in (t_k, t_k+H)$，我们有 $t-t_k  H$，这意味着 $K(t-t_k)  KH \\le g_k$，从而确保 $g(x(t), t)0$。\n\n情况 2：$g_k  0$。我们必须确保对于所有 $t \\in (t_k, t_k+H)$，有 $g(x(t), t)  0$。\n根据三角不等式，$g(x(t), t) = g_k + (g(x(t), t) - g_k)$，这意味着 $g(x(t), t) \\leq g_k + |g(x(t), t) - g_k|$。\n使用我们的界：\n$$g(x(t), t) \\leq g_k + K(t - t_{k})$$\n为了使 $g(x(t), t)$ 严格为负，我们需要 $g_k + K(t - t_{k})  0$，即 $K(t - t_{k})  -g_k$。由于 $g_k  0$，所以 $-g_k = |g_k|$。条件变为 $K(t - t_{k})  |g_k|$。这个条件必须对所有 $t \\in (t_k, t_k+H)$ 成立，这就要求 $KH \\leq |g_k|$。\n\n两种情况都导向关于 $H$ 的相同条件：\n$$K H \\leq |g_k|$$\n将 $K = L_{x}B_{x} + L_{t}$ 代回，我们得到：\n$$(L_{x}B_{x} + L_{t}) H \\leq |g_{k}|$$\n\n问题要求 $H$ 的最大阈值。从该不等式中，我们可以解出 $H$：\n$$H \\leq \\frac{|g_{k}|}{L_{x}B_{x} + L_{t}}$$\n这个不等式定义了所有安全步长的集合。保证安全的 $H$ 的最大可能值是这个集合的上界。我们必须考虑分母 $L_{x}B_{x} + L_{t}$ 为零的情况。鉴于 $L_x \\ge 0$、$L_t \\ge 0$ 和 $B_x \\ge 0$，分母仅在 $L_t=0$ 且 $L_x=0$ 或 $B_x=0$ 时为零。在这种情况下，保护函数的值在区间内不能改变，并且由于 $g_k \\neq 0$，它永远不会穿过零点。该公式通过暗示对 $H$ 没有上限（除以零）来正确反映这一点。假设分母不为零，则 $H$ 的最大阈值为：\n$$H_{\\text{max}} = \\frac{|g_{k}|}{L_{x}B_{x} + L_{t}}$$\n该表达式代表了可以从时间 $t_k$ 开始采取的最大宏步长，同时保证在开区间 $(t_k, t_k+H)$ 内的任何零点穿越事件都不会被漏检。\n最终表达式仅用所需的变量 $g_k$、$B_x$、$L_x$ 和 $L_t$ 来表示。",
            "answer": "$$\\boxed{\\frac{|g_{k}|}{L_{x}B_{x} + L_{t}}}$$"
        },
        {
            "introduction": "数字孪生越来越多地集成机器学习模型来表征复杂或未知的系统组件。本练习旨在解决一个前沿挑战：当联合仿真回路中包含此类数据驱动模型时，如何保证整个系统的稳定性。通过在工作点对神经网络进行线性化，我们将分析模型自身的属性（以及诸如梯度正则化等控制这些属性的技术）如何直接影响联合仿真的稳定性。",
            "id": "4208733",
            "problem": "给定一个离散时间协同仿真设置，用于模拟一个简化的信息物理系统场景，该系统包含两个耦合的异构子系统。子系统 $\\mathrm{A}$（例如，一个机械质量-阻尼器抽象模型）和子系统 $\\mathrm{B}$（例如，一个热阻-热容抽象模型）在一个大小为 $H$ 的宏观步长上独立积分，并且仅在宏观步长的边界处交换边界值（并行 Jacobi 协同仿真）。耦合通过一个接口映射实现，该映射是一个黑箱机器学习（ML）组件，其接口雅可比矩阵可以带有或不带有梯度正则化。您的任务是实现一个程序，为给定的测试套件计算线性化宏观步长协同仿真算子的谱稳定性，并将结果汇总到单行输出中。\n\n子系统满足以下连续时间动态方程：\n- 子系统 $\\mathrm{A}$：$\\dfrac{dx}{dt} = -a x + b u$，其中 $x$ 是子系统 $\\mathrm{A}$ 的状态，$u$ 是其输入。\n- 子系统 $\\mathrm{B}$：$\\dfrac{dy}{dt} = -c y + d v$，其中 $y$ 是子系统 $\\mathrm{B}$ 的状态，$v$ 是其输入。\n\n协同仿真耦合由 $u = k\\,y$ 和 $v = f(x)$ 给出，其中 $f$ 是机器学习接口映射。在每个大小为 $H$ 的宏观步长内，子系统 $\\mathrm{A}$ 使用显式欧拉法积分，子系统 $\\mathrm{B}$ 使用隐式欧拉法积分，两者在整个宏观步长内都保持输入恒定（并行 Jacobi 更新）。该机器学习接口映射是一个单隐藏单元神经网络\n$$\nf(x) = w_2 \\tanh\\left(w_1 x + b_1\\right) + b_2,\n$$\n其在 $x = 0$ 附近的线性化由其雅可比矩阵 $f'(0)$ 决定。接口映射的梯度正则化版本强制执行一个雅可比范数界\n$$\n\\left| f'(0) \\right| \\le L_{\\mathrm{reg}},\n$$\n也就是说，用于稳定性分析的有效线性化增益被裁剪到区间 $[-L_{\\mathrm{reg}}, L_{\\mathrm{reg}}]$ 内。\n\n从基本离散化法则（显式欧拉和隐式欧拉）以及关于原点的线性化出发，推导宏观步长线性化更新矩阵 $M$，使得\n$$\n\\begin{bmatrix}\nx_{k+1}\\\\\ny_{k+1}\n\\end{bmatrix}\n=\nM\n\\begin{bmatrix}\nx_k\\\\\ny_k\n\\end{bmatrix}.\n$$\n用 $a$、$b$、$c$、$d$、$k$、$H$ 和 $f'(0)$ 表示 $M$。对于测试套件中的每组参数，计算谱半径 $\\rho(M)$（定义为 $M$ 的特征值的最大绝对值）。需要分别计算非正则化情况（使用给定机器学习映射的实际 $f'(0)$）和梯度正则化情况（使用裁剪后的 $f'(0)$）。本问题中无需报告物理单位；不涉及角度。\n\n使用链式法则根据给定的机器学习参数计算 $f'(0)$。对于给定的 $f(x)$，其在原点的导数为\n$$\nf'(0) = w_2 \\left(1 - \\tanh^2(b_1)\\right) w_1,\n$$\n在应用裁剪进行正则化之前，该值被用作线性化接口增益。梯度正则化的线性化增益为\n$$\nf'_{\\mathrm{reg}}(0) = \\mathrm{clip}\\left(f'(0), -L_{\\mathrm{reg}}, L_{\\mathrm{reg}}\\right).\n$$\n\n测试套件：\n使用以下五组参数。对于每种情况，按规定处理机器学习映射，并计算非正则化和正则化接口雅可比矩阵的谱半径。\n\n- 情况 1（正则化后预期会有改善）：\n  - $a = 1.0$, $b = 1.0$, $c = 3.0$, $d = 1.0$, $k = 1.0$, $H = 0.2$\n  - $w_1 = 3.0$, $w_2 = 1.0$, $b_1 = 0.0$, $b_2 = 0.0$\n  - $L_{\\mathrm{reg}} = 0.8$\n- 情况 2（已稳定；正则化不改变定性稳定性）：\n  - $a = 1.0$, $b = 1.0$, $c = 3.0$, $d = 1.0$, $k = 1.0$, $H = 0.2$\n  - $w_1 = 0.7$, $w_2 = \\dfrac{5}{7} \\approx 0.7142857$, $b_1 = 0.0$, $b_2 = 0.0$\n  - $L_{\\mathrm{reg}} = 0.8$\n- 情况 3（宏观步长较小；尽管接口斜率大但仍稳定）：\n  - $a = 1.0$, $b = 1.0$, $c = 3.0$, $d = 1.0$, $k = 1.0$, $H = 0.01$\n  - $w_1 = 4.0$, $w_2 = 1.0$, $b_1 = 0.0$, $b_2 = 0.0$\n  - $L_{\\mathrm{reg}} = 0.8$\n- 情况 4（非正则化情况下的近边界行为）：\n  - $a = 1.0$, $b = 1.0$, $c = 3.0$, $d = 1.0$, $k = 1.0$, $H = 0.2$\n  - $w_1 = 2.8$, $w_2 = 1.0$, $b_1 = 0.0$, $b_2 = 0.0$\n  - $L_{\\mathrm{reg}} = 2.0$\n- 情况 5（中等斜率；两种情况下均稳定）：\n  - $a = 1.0$, $b = 1.0$, $c = 3.0$, $d = 1.0$, $k = 1.0$, $H = 0.2$\n  - $w_1 = 1.0$, $w_2 = 1.0$, $b_1 = 0.0$, $b_2 = 0.0$\n  - $L_{\\mathrm{reg}} = 0.5$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于从 1 到 5 的每个测试用例，按顺序先输出非正则化的谱半径，再输出正则化的谱半径，两者均为浮点数。例如，输出格式为\n$$\n[\\rho_{\\text{unreg,1}}, \\rho_{\\text{reg,1}}, \\rho_{\\text{unreg,2}}, \\rho_{\\text{reg,2}}, \\rho_{\\text{unreg,3}}, \\rho_{\\text{reg,3}}, \\rho_{\\text{unreg,4}}, \\rho_{\\text{reg,4}}, \\rho_{\\text{unreg,5}}, \\rho_{\\text{reg,5}}].\n$$\n\n您的程序必须是完整的、无需用户输入即可运行的，并且不得访问外部文件或网络。使用纯 Python 和允许的库实现所有计算。",
            "solution": "用户提供了一个来自信息物理系统数值分析领域的有效且适定的问题陈述。任务是分析一个 Jacobi 型协同仿真方案的数值稳定性，该方案用于求解两个耦合的线性常微分方程（ODE），其中耦合由一个神经网络介导。该分析将通过推导线性化的宏观步长更新矩阵并计算其谱半径来执行。\n\n问题建模过程如下。首先，我们建立耦合系统的控制方程和协同仿真协议。其次，我们将指定的数值积分方法应用于每个子系统，以推导离散时间更新方程。第三，我们将这些方程组合成一个单一的矩阵算子。最后，我们为给定的测试用例计算该算子的谱半径。\n\n两个子系统的连续时间动态方程由下式给出：\n子系统 $\\mathrm{A}$：$\\dfrac{dx}{dt} = -a x + b u$\n子系统 $\\mathrm{B}$：$\\dfrac{dy}{dt} = -c y + d v$\n\n耦合由关系式 $u = k\\,y$ 和 $v = f(x)$ 定义。问题指定了一个并行的 Jacobi 协同仿真方案。这意味着对于从时间 $t_k$ 到 $t_{k+1} = t_k + H$ 的一个宏观步长，每个子系统的输入是根据区间开始时的状态 $(x_k, y_k)$ 计算的，并在整个区间内保持恒定。\n子系统 $\\mathrm{A}$ 的输入是 $u_k = k y_k$。\n子系统 $\\mathrm{B}$ 的输入是 $v_k = f(x_k)$。\n\n分析基于在平衡点 $(x, y) = (0, 0)$ 附近的线性化。子系统在其状态和输入方面已经是线性的。耦合 $u=ky$ 也是线性的。耦合 $v=f(x)$ 是非线性的，必须进行线性化。$f(x)$ 在 $x=0$ 附近的一阶泰勒展开为 $f(x) \\approx f(0) + f'(0)x$。所提供的神经网络形式为 $f(x) = w_2 \\tanh(w_1 x + b_1) + b_2$。对于所有测试用例，参数 $b_1$ 和 $b_2$ 均为零，这意味着 $f(0) = w_2 \\tanh(0) + 0 = 0$。因此，子系统 $\\mathrm{B}$ 的线性化输入是 $v_k = f'(0) x_k$。雅可比矩阵 $f'(0)$ 由 $f'(0) = w_2 \\left(1 - \\tanh^2(b_1)\\right) w_1$ 给出。\n\n我们现在推导每个子系统在一个大小为 $H$ 的宏观步长上的离散时间更新方程。\n\n对于子系统 $\\mathrm{A}$，使用显式欧拉法。需要积分的常微分方程是 $\\dfrac{dx}{dt} = -a x + b u_k$，其中 $u_k = k y_k$ 是常数。\n显式欧拉法的更新公式是：\n$$x_{k+1} = x_k + H \\left( \\frac{dx}{dt} \\right)\\bigg|_{t=t_k}$$\n$$x_{k+1} = x_k + H (-a x_k + b u_k)$$\n代入 $u_k = k y_k$：\n$$x_{k+1} = x_k + H (-a x_k + b k y_k)$$\n$$x_{k+1} = (1 - aH) x_k + (b k H) y_k$$\n\n对于子系统 $\\mathrm{B}$，使用隐式欧拉法。常微分方程是 $\\dfrac{dy}{dt} = -c y + d v_k$，其中 $v_k = f'(0) x_k$ 是常数。\n隐式欧拉法的更新公式是：\n$$y_{k+1} = y_k + H \\left( \\frac{dy}{dt} \\right)\\bigg|_{t=t_{k+1}}$$\n$$y_{k+1} = y_k + H (-c y_{k+1} + d v_k)$$\n我们必须求解 $y_{k+1}$：\n$$y_{k+1} + c H y_{k+1} = y_k + d H v_k$$\n$$y_{k+1}(1 + c H) = y_k + d H v_k$$\n代入 $v_k = f'(0) x_k$：\n$$y_{k+1}(1 + c H) = y_k + d H f'(0) x_k$$\n$$y_{k+1} = \\left(\\frac{d H f'(0)}{1 + c H}\\right) x_k + \\left(\\frac{1}{1 + c H}\\right) y_k$$\n\n我们现在可以将这两个线性更新方程组合成一个单一的矩阵系统：\n$$\n\\begin{bmatrix}\nx_{k+1}\\\\\ny_{k+1}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 - aH  b k H \\\\\n\\frac{d H f'(0)}{1 + c H}  \\frac{1}{1 + c H}\n\\end{bmatrix}\n\\begin{bmatrix}\nx_k\\\\\ny_k\n\\end{bmatrix}\n$$\n这就得到了宏观步长协同仿真算子 $M$：\n$$\nM =\n\\begin{bmatrix}\n1 - aH  b k H \\\\\n\\frac{d H f'(0)}{1 + c H}  \\frac{1}{1 + c H}\n\\end{bmatrix}\n$$\n协同仿真方案的稳定性由谱半径 $\\rho(M) = \\max_i |\\lambda_i|$ 决定，其中 $\\lambda_i$ 是 $M$ 的特征值。当且仅当 $\\rho(M)  1$ 时，该方案是稳定的。\n\n对于每个测试用例，我们执行两次计算：\n$1$. 非正则化情况：我们计算 $f'(0) = w_2 (1 - \\tanh^2(b_1)) w_1$ 并使用该值构建矩阵 $M_{\\text{unreg}}$。然后我们计算 $\\rho(M_{\\text{unreg}})$。\n$2$. 梯度正则化情况：我们首先计算非正则化的 $f'(0)$。然后，我们应用裁剪以获得正则化的雅可比矩阵，$f'_{\\text{reg}}(0) = \\text{clip}(f'(0), -L_{\\mathrm{reg}}, L_{\\mathrm{reg}})$。我们使用这个裁剪后的值来构建矩阵 $M_{\\text{reg}}$ 并计算其谱半径 $\\rho(M_{\\text{reg}})$。\n\n接下来的程序将为测试套件中提供的每组参数实现此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral stability for a co-simulation scheme across a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple format: (a, b, c, d, k, H, w1, w2, b1, b2, L_reg)\n    test_cases = [\n        # Case 1\n        (1.0, 1.0, 3.0, 1.0, 1.0, 0.2, 3.0, 1.0, 0.0, 0.0, 0.8),\n        # Case 2\n        (1.0, 1.0, 3.0, 1.0, 1.0, 0.2, 0.7, 5.0/7.0, 0.0, 0.0, 0.8),\n        # Case 3\n        (1.0, 1.0, 3.0, 1.0, 1.0, 0.01, 4.0, 1.0, 0.0, 0.0, 0.8),\n        # Case 4\n        (1.0, 1.0, 3.0, 1.0, 1.0, 0.2, 2.8, 1.0, 0.0, 0.0, 2.0),\n        # Case 5\n        (1.0, 1.0, 3.0, 1.0, 1.0, 0.2, 1.0, 1.0, 0.0, 0.0, 0.5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, c, d, k, H, w1, w2, b1, b2, L_reg = case\n\n        # Compute the unregularized linearized interface gain f'(0)\n        # f'(x) = d/dx [w2 * tanh(w1*x + b1) + b2] = w2 * sech^2(w1*x + b1) * w1\n        # sech^2(z) = 1 - tanh^2(z)\n        # f'(0) = w2 * (1 - tanh^2(b1)) * w1\n        fp0_unreg = w2 * (1 - np.tanh(b1)**2) * w1\n        \n        # Compute the regularized linearized interface gain\n        fp0_reg = np.clip(fp0_unreg, -L_reg, L_reg)\n        \n        # --- Unregularized case ---\n        \n        # Construct the macro-step matrix M_unreg\n        m11_unreg = 1 - a * H\n        m12_unreg = b * k * H\n        m21_unreg = (d * H * fp0_unreg) / (1 + c * H)\n        m22_unreg = 1 / (1 + c * H)\n        \n        M_unreg = np.array([\n            [m11_unreg, m12_unreg],\n            [m21_unreg, m22_unreg]\n        ])\n        \n        # Compute the eigenvalues and the spectral radius\n        eigenvalues_unreg = np.linalg.eigvals(M_unreg)\n        rho_unreg = np.max(np.abs(eigenvalues_unreg))\n        results.append(rho_unreg)\n        \n        # --- Regularized case ---\n        \n        # Construct the macro-step matrix M_reg\n        # m11, m12, m22 are the same as the unregularized case\n        m21_reg = (d * H * fp0_reg) / (1 + c * H)\n        \n        M_reg = np.array([\n            [m11_unreg, m12_unreg],\n            [m21_reg, m22_unreg]\n        ])\n        \n        # Compute the eigenvalues and the spectral radius\n        eigenvalues_reg = np.linalg.eigvals(M_reg)\n        rho_reg = np.max(np.abs(eigenvalues_reg))\n        results.append(rho_reg)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}