{
    "hands_on_practices": [
        {
            "introduction": "Transitioning a control system from a continuous-time design to a digital implementation introduces fundamental trade-offs. This first practice explores the critical relationship between the sampling period, $T_s$, and system stability. By analyzing the phase lag introduced by the Zero-Order Hold (ZOH) process, you will derive a maximum allowable sampling period that preserves a desired phase margin, providing a tangible link between a core design parameter and the robustness of the discrete-time system .",
            "id": "4236257",
            "problem": "A Processor-In-The-Loop (PIL) setup is used to validate a digital twin of a cyber-physical system where the plant is modeled as a first-order stable system. The continuous-time plant is given by $G(s)=\\frac{1}{s+a}$ with $a>0$. A continuous-time Proportional-Integral (PI) controller is designed as $C(s)=K_{p}+\\frac{K_{i}}{s}$, and then implemented digitally on the processor with sampling period $T_{s}$; the Digital-to-Analog Converter (DAC) applies a Zero-Order Hold (ZOH) on the control signal. The ZOH frequency response is $H_{\\text{ZOH}}(j\\omega)=\\frac{1-\\exp(-j\\omega T_{s})}{j\\omega T_{s}}$, which can be written as $H_{\\text{ZOH}}(j\\omega)=\\exp\\!\\big(-j\\omega T_{s}/2\\big)\\,\\operatorname{sinc}\\!\\big(\\omega T_{s}/2\\big)$, where $\\operatorname{sinc}(x)=\\frac{\\sin x}{x}$.\n\nStarting from the fundamental definition of gain crossover frequency $\\omega_{c}$ as the solution of $\\big|L(j\\omega_{c})\\big|=1$ for the continuous-time loop $L(s)=C(s)G(s)$, and the phase margin as $\\mathrm{PM}_{c}=\\pi+\\arg\\!\\big(L(j\\omega_{c})\\big)$, derive an analytic expression for the maximum sampling period $T_{s,\\max}$ that guarantees the discrete-time implementation preserves a phase margin strictly above $45^{\\circ}$ (i.e., above $\\pi/4$ radians), by accounting for the added phase of the ZOH at $\\omega_{c}$. Assume the crossover shift due to the ZOH magnitude attenuation is negligible for the purpose of deriving a conservative bound on $T_{s}$.\n\nThen, for the parameter values $K_{p}=2$, $K_{i}=100$, and $a=50$, compute the numerical value of $T_{s,\\max}$. Express $T_{s,\\max}$ in seconds and round your final result to four significant figures. State the final answer as a single real number.",
            "solution": "The problem statement is evaluated to be scientifically grounded, well-posed, objective, and complete. It describes a standard problem in digital control theory concerning the stability degradation due to sampling and hold operations. All parameters and models provided are standard and consistent. The problem is therefore deemed valid and a solution will be provided.\n\nThe continuous-time open-loop transfer function, $L(s)$, is the product of the controller transfer function, $C(s)$, and the plant transfer function, $G(s)$.\n$$L(s) = C(s)G(s)$$\nGiven $C(s)=K_{p}+\\frac{K_{i}}{s}$ and $G(s)=\\frac{1}{s+a}$, we have:\n$$L(s) = \\left(K_{p}+\\frac{K_{i}}{s}\\right) \\left(\\frac{1}{s+a}\\right) = \\frac{K_{p}s+K_{i}}{s(s+a)}$$\nThe frequency response is obtained by substituting $s = j\\omega$:\n$$L(j\\omega) = \\frac{K_{i} + jK_{p}\\omega}{j\\omega(j\\omega+a)} = \\frac{K_{i} + jK_{p}\\omega}{-\\omega^2 + ja\\omega}$$\nThe gain crossover frequency, $\\omega_{c}$, is defined by the condition $|L(j\\omega_{c})|=1$.\n$$|L(j\\omega_{c})| = \\frac{|K_{i} + jK_{p}\\omega_{c}|}{|-\\omega_{c}^2 + ja\\omega_{c}|} = \\frac{\\sqrt{K_{i}^2 + (K_{p}\\omega_{c})^2}}{\\sqrt{(-\\omega_{c}^2)^2 + (a\\omega_{c})^2}} = \\frac{\\sqrt{K_{i}^2 + K_{p}^2\\omega_{c}^2}}{\\omega_{c}\\sqrt{\\omega_{c}^2 + a^2}}$$\nSetting the magnitude to $1$ and squaring both sides gives:\n$$\\frac{K_{i}^2 + K_{p}^2\\omega_{c}^2}{\\omega_{c}^2(\\omega_{c}^2 + a^2)} = 1$$\n$$K_{i}^2 + K_{p}^2\\omega_{c}^2 = \\omega_{c}^4 + a^2\\omega_{c}^2$$\nRearranging this yields a quadratic equation for $\\omega_{c}^2$:\n$$\\omega_{c}^4 + (a^2 - K_{p}^2)\\omega_{c}^2 - K_{i}^2 = 0$$\nSolving for $\\omega_{c}^2$ using the quadratic formula (and choosing the positive root, as $\\omega_{c}^2$ must be positive):\n$$\\omega_{c}^2 = \\frac{-(a^2 - K_{p}^2) + \\sqrt{(a^2 - K_{p}^2)^2 - 4(1)(-K_{i}^2)}}{2} = \\frac{K_{p}^2 - a^2 + \\sqrt{(K_{p}^2 - a^2)^2 + 4K_{i}^2}}{2}$$\nThe continuous-time phase margin, $\\mathrm{PM}_{c}$, is given by $\\mathrm{PM}_{c}=\\pi+\\arg(L(j\\omega_{c}))$. The phase of $L(j\\omega)$ is:\n$$\\arg(L(j\\omega)) = \\arg(K_{i} + jK_{p}\\omega) - \\arg(s(s+a))|_{s=j\\omega} = \\arctan\\left(\\frac{K_{p}\\omega}{K_{i}}\\right) - \\left(\\frac{\\pi}{2} + \\arctan\\left(\\frac{\\omega}{a}\\right)\\right)$$\nThus, the continuous phase margin at $\\omega_c$ is:\n$$\\mathrm{PM}_{c} = \\pi + \\arctan\\left(\\frac{K_{p}\\omega_{c}}{K_{i}}\\right) - \\frac{\\pi}{2} - \\arctan\\left(\\frac{\\omega_{c}}{a}\\right) = \\frac{\\pi}{2} + \\arctan\\left(\\frac{K_{p}\\omega_{c}}{K_{i}}\\right) - \\arctan\\left(\\frac{\\omega_{c}}{a}\\right)$$\nThe digital implementation introduces a Zero-Order Hold (ZOH) circuit. The frequency response of the ZOH imparts a phase lag given by $\\arg(H_{\\text{ZOH}}(j\\omega)) = -\\frac{\\omega T_{s}}{2}$. This phase lag reduces the phase margin of the system.\nThe problem states to assume that the crossover frequency $\\omega_{c}$ is not affected by the magnitude attenuation of the ZOH. Therefore, the new phase margin, $\\mathrm{PM}_{d}$, can be calculated by subtracting the ZOH phase lag evaluated at $\\omega_{c}$ from the continuous-time phase margin $\\mathrm{PM}_{c}$.\n$$\\mathrm{PM}_{d} = \\mathrm{PM}_{c} - \\frac{\\omega_{c}T_{s}}{2}$$\nThe problem requires that the phase margin of the discrete-time implementation be strictly greater than $45^{\\circ}$, which is $\\frac{\\pi}{4}$ radians.\n$$\\mathrm{PM}_{d} > \\frac{\\pi}{4}$$\n$$\\mathrm{PM}_{c} - \\frac{\\omega_{c}T_{s}}{2} > \\frac{\\pi}{4}$$\nSolving for the sampling period $T_{s}$:\n$$\\frac{\\omega_{c}T_{s}}{2} < \\mathrm{PM}_{c} - \\frac{\\pi}{4}$$\n$$T_{s} < \\frac{2}{\\omega_{c}}\\left(\\mathrm{PM}_{c} - \\frac{\\pi}{4}\\right)$$\nThis gives the maximum sampling period, $T_{s,\\max}$, as the upper bound of this inequality:\n$$T_{s,\\max} = \\frac{2}{\\omega_{c}}\\left(\\mathrm{PM}_{c} - \\frac{\\pi}{4}\\right)$$\nSubstituting the expression for $\\mathrm{PM}_{c}$:\n$$T_{s,\\max} = \\frac{2}{\\omega_{c}}\\left(\\left(\\frac{\\pi}{2} + \\arctan\\left(\\frac{K_{p}\\omega_{c}}{K_{i}}\\right) - \\arctan\\left(\\frac{\\omega_{c}}{a}\\right)\\right) - \\frac{\\pi}{4}\\right)$$\n$$T_{s,\\max} = \\frac{2}{\\omega_{c}}\\left(\\frac{\\pi}{4} + \\arctan\\left(\\frac{K_{p}\\omega_{c}}{K_{i}}\\right) - \\arctan\\left(\\frac{\\omega_{c}}{a}\\right)\\right)$$\nThis is the required analytical expression.\n\nNow, we compute the numerical value for the given parameters: $K_{p}=2$, $K_{i}=100$, and $a=50$.\nA key observation is that the PI controller's zero is at $s = -K_{i}/K_{p} = -100/2 = -50$. The plant's pole is at $s = -a = -50$. Thus, there is a pole-zero cancellation.\nThe open-loop transfer function simplifies significantly:\n$$L(s) = \\frac{K_{p}(s+K_{i}/K_{p})}{s(s+a)} = \\frac{2(s+50)}{s(s+50)} = \\frac{2}{s}$$\nWith this simplified form, we can easily find $\\omega_{c}$ and $\\mathrm{PM}_{c}$.\nThe magnitude is $|L(j\\omega)| = |\\frac{2}{j\\omega}| = \\frac{2}{\\omega}$.\nThe gain crossover frequency $\\omega_{c}$ is found from $|L(j\\omega_{c})|=1$:\n$$\\frac{2}{\\omega_{c}} = 1 \\implies \\omega_{c} = 2 \\; \\text{rad/s}$$\nThe phase of the simplified system is $\\arg(L(j\\omega)) = \\arg(\\frac{2}{j\\omega}) = \\arg(-j\\frac{2}{\\omega}) = -\\frac{\\pi}{2}$ for all $\\omega>0$.\nThe continuous-time phase margin is:\n$$\\mathrm{PM}_{c} = \\pi + \\arg(L(j\\omega_{c})) = \\pi - \\frac{\\pi}{2} = \\frac{\\pi}{2}$$\nNow we substitute these values into the expression for $T_{s,\\max}$:\n$$T_{s,\\max} = \\frac{2}{\\omega_{c}}\\left(\\mathrm{PM}_{c} - \\frac{\\pi}{4}\\right) = \\frac{2}{2}\\left(\\frac{\\pi}{2} - \\frac{\\pi}{4}\\right) = 1 \\cdot \\frac{\\pi}{4} = \\frac{\\pi}{4}$$\nTo obtain the numerical value, we compute $\\pi/4$ and round to four significant figures.\n$$T_{s,\\max} = \\frac{\\pi}{4} \\approx 0.78539816... \\; \\text{s}$$\nRounding to four significant figures gives:\n$$T_{s,\\max} \\approx 0.7854 \\; \\text{s}$$",
            "answer": "$$\\boxed{0.7854}$$"
        },
        {
            "introduction": "While the choice of sampling period $T_s$ is critical from a control theory standpoint, it is equally important to verify that the target processor can complete its required tasks within this timeframe. This exercise moves from system-level theory to the practicalities of real-time execution on the processor . You will learn to account for the worst-case execution time (WCET) of your control task, alongside system overheads like context switches and interrupts, to determine if the implementation is schedulable and meets its hard real-time deadlines.",
            "id": "4236201",
            "problem": "In a processor-in-the-loop (PIL) experiment for a sampled-data control loop in a cyber-physical system, a single periodic control task is executed at the sampling period $T_{s}$. The task runs on the target processor with preemptive fixed-priority scheduling and is the only periodic task in the system during the experiment. The following conditions hold.\n\n- The control task has a worst-case execution time (WCET) $C$ on the target processor.\n- A context switch incurs a fixed overhead $S$ per switch, incurred once at task dispatch and once at task completion.\n- During each sampling period, an asynchronous input/output (I/O) interrupt arrives and preempts the processor for a worst-case duration $I$; assume worst-case phasing so that exactly one such preemption occurs during each sampling period.\n- Actuation is performed at the end of the control computation and is followed immediately by an optional post-actuation diagnostic routine with execution time $D$ that must also complete before the end of the same sampling period if it is to be included.\n- There is no overlap or parallelism; all execution and overheads consume the same single-core processor resource.\n\nStarting from first principles of real-time scheduling for a single periodic task, define the available slack within each sampling period as the time remaining after accounting for the control taskâ€™s WCET, the two context switches per period, and the single worst-case I/O interrupt preemption. Then derive the remaining slack margin after allocating the post-actuation diagnostic routine within the same sampling period.\n\nGiven the numerical values $T_{s}=1\\ \\text{ms}$, $C=0.6\\ \\text{ms}$, $S=0.05\\ \\text{ms}$, $I=0.1\\ \\text{ms}$, and $D=0.2\\ \\text{ms}$, compute the remaining slack margin. State whether the slack suffices for the diagnostic routine based on the sign of the remaining margin. Express the final remaining slack margin in milliseconds. Do not round the result.",
            "solution": "The problem asks for the calculation of the remaining slack margin in a single-task real-time system. This margin represents the unused processor time within a sampling period after all worst-case computational and overhead demands are met.\n\nFirst, we identify all sources of processor time consumption within one sampling period, $T_s$. The total time required, $T_{\\text{total}}$, is the sum of the worst-case execution time of the control task ($C$), the overhead for two context switches ($2S$), the preemption time from the I/O interrupt ($I$), and the execution time of the optional diagnostic routine ($D$). All times are additive since they consume the same single-core processor resource.\n$$T_{\\text{total}} = C + 2S + I + D$$\nThe remaining slack margin, $\\sigma_{\\text{rem}}$, is the difference between the total time available in the period, $T_s$, and the total time consumed, $T_{\\text{total}}$.\n$$\\sigma_{\\text{rem}} = T_s - T_{\\text{total}} = T_s - (C + 2S + I + D)$$\nThis formula represents the remaining time before the deadline is missed in the worst-case scenario. A non-negative value ($\\sigma_{\\text{rem}} \\ge 0$) indicates that the system is schedulable and the diagnostic routine can be included.\n\nNow, we substitute the given numerical values:\n- $T_s = 1\\ \\text{ms}$\n- $C = 0.6\\ \\text{ms}$\n- $S = 0.05\\ \\text{ms}$\n- $I = 0.1\\ \\text{ms}$\n- $D = 0.2\\ \\text{ms}$\n\n$$\\sigma_{\\text{rem}} = 1 - (0.6 + 2 \\times 0.05 + 0.1 + 0.2)$$\n$$\\sigma_{\\text{rem}} = 1 - (0.6 + 0.1 + 0.1 + 0.2)$$\n$$\\sigma_{\\text{rem}} = 1 - 1.0$$\n$$\\sigma_{\\text{rem}} = 0\\ \\text{ms}$$\n\nThe remaining slack margin is exactly $0$ ms. Since the margin is non-negative ($0 \\ge 0$), the slack is sufficient to include the diagnostic routine. However, this means the system utilizes 100% of the processor time in the worst-case scenario and has no further capacity to handle additional execution time or jitter.",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "Beyond ensuring that computations are completed on time, Processor-in-the-Loop simulation is essential for uncovering discrepancies in the computational results themselves. This final practice confronts a subtle but critical source of divergence between Software-in-the-Loop (SIL) and PIL environments: hardware-specific arithmetic behavior . By examining the case of signed integer overflow, you will see how a seemingly simple logical expression can yield different results on a host PC versus the target processor, demonstrating why verifying code on the actual hardware is an indispensable step in developing safe and reliable cyber-physical systems.",
            "id": "4236240",
            "problem": "Consider a digital twin of a simple decision logic used in a cyber-physical controller. The digital twin is evaluated in a Software-in-the-Loop (SIL) environment using unbounded mathematical integers, while the actual processor is evaluated in a Processor-in-the-Loop (PIL) environment using fixed-width two's-complement signed integers. Let the logic be: return $1$ if $x+1 > x$, else return $0$. In mathematical integers, the strict total order guarantees that for any integer $x$, the relation $x+1 > x$ holds. In two's-complement $n$-bit signed integers, $x$ is representable only if $x \\in [-(2^{n-1}), 2^{n-1}-1]$, and addition is performed modulo $2^n$ followed by two's-complement interpretation. In the C programming language, signed integer overflow is undefined behavior, allowing compilers in SIL builds to assume that $x+1$ cannot overflow and to optimize conditionals such as $x+1 > x$ as always true, while on actual hardware in PIL the wrap-around arithmetic may make $x+1 > x$ false at the upper boundary $x = 2^{n-1}-1$. This can produce divergent outputs between SIL and PIL.\n\nYour task is to implement a program that:\n- Models the SIL decision using mathematical integers, that is, evaluates whether $x+1 > x$ over $\\mathbb{Z}$ and outputs $1$ if true and $0$ otherwise.\n- Models the PIL decision using $n$-bit two's-complement signed integers, that is, computes $x+1$ with wrap-around modulo $2^n$, interprets both $x$ and $x+1$ as signed values, and then evaluates whether the signed $x+1$ is greater than $x$, outputting $1$ if true and $0$ otherwise.\n- Computes a divergence flag showing whether the SIL and PIL outputs differ for the given $(n,x)$ pair.\n- Computes a static analysis safety predicate that forbids undefined behavior for the expression $x+1$ in $n$-bit two's-complement signed arithmetic, expressed as the condition $x \\in [-(2^{n-1}), (2^{n-1}-1) - 1]$, which ensures $x+1$ is representable without overflow. Output this predicate as a boolean.\n\nUse the following test suite of $(n,x)$ pairs to exercise normal operation, boundary conditions, and different bit-widths:\n- $(n,x) = (32, 0)$\n- $(n,x) = (32, 2^{31}-1)$\n- $(n,x) = (32, -1)$\n- $(n,x) = (16, 2^{15}-1)$\n- $(n,x) = (16, -2^{15})$\n\nFor each test case, produce a four-element list $[s, p, d, q]$ where:\n- $s$ is the SIL output as an integer ($1$ or $0$).\n- $p$ is the PIL output as an integer ($1$ or $0$).\n- $d$ is a boolean indicating whether the outputs diverge, i.e., whether $s \\neq p$.\n- $q$ is a boolean indicating whether the static analysis safety predicate holds for $x+1$ under $n$-bit signed arithmetic.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The required format is a list of lists, in the order of the test suite, for example, $[[s_1,p_1,d_1,q_1],[s_2,p_2,d_2,q_2],\\dots]$ with no extra whitespace or text. There are no physical units or angle units involved in this problem, and all outputs are dimensionless integers and booleans.",
            "solution": "The problem requires an analysis of the divergence between a mathematical model (Software-in-the-Loop, SIL) and a hardware-specific model (Processor-in-the-Loop, PIL) for a simple control logic. The logic is to return $1$ if $x+1 > x$ and $0$ otherwise. The divergence arises from the differing properties of unbounded mathematical integers versus fixed-width two's-complement signed integers. The task is to compute four values for given pairs of bit-width $n$ and integer $x$: the SIL output $s$, the PIL output $p$, a divergence flag $d$, and a static analysis safety predicate $q$.\n\nThe solution is developed by modeling each of these four components based on their formal definitions.\n\n1.  **SIL Model Output ($s$)**\n\nThe SIL environment is defined as using unbounded mathematical integers, denoted by the set $\\mathbb{Z}$. In this system, the ordering of integers is a strict total order. For any integer $x \\in \\mathbb{Z}$, the successor of $x$, which is $x+1$, is axiomatically greater than $x$. Therefore, the condition $x+1 > x$ is a tautology; it is always true. The SIL model output $s$, which evaluates this condition, will consequently always be $1$.\n\n$s = 1 \\quad \\forall x \\in \\mathbb{Z}$\n\n2.  **Static Analysis Safety Predicate ($q$)**\n\nThe static analysis predicate a-priori checks if an operation might lead to undefined behavior. In C, signed integer overflow is undefined behavior. To prevent overflow for the expression $x+1$ using $n$-bit signed integers, the result $x+1$ must also be representable within the valid range $[-(2^{n-1}), 2^{n-1}-1]$. Given that the input $x$ is already within this range, we only need to ensure that adding $1$ does not exceed the maximum value.\n\nThe maximum representable value is $x_{max} = 2^{n-1}-1$. If $x = x_{max}$, then $x+1 = 2^{n-1}$, which is outside the representable range, causing an overflow. For any $x < x_{max}$, $x+1$ will be less than or equal to $x_{max}$ and thus will not overflow. The safety predicate is therefore the condition that $x$ is strictly less than the maximum possible value.\n\n$q = (x < 2^{n-1}-1)$\n\nThe problem statement defines the predicate as $x \\in [-(2^{n-1}), (2^{n-1}-1) - 1]$. Since $x$ is given to be in the representable range $[-(2^{n-1}), 2^{n-1}-1]$, the lower bound check is implicitly satisfied. The upper bound check is $x \\leq (2^{n-1}-1) - 1$, which is equivalent to $x < 2^{n-1}-1$. The predicate $q$ is a boolean that is true if this condition holds.\n\n3.  **PIL Model Output ($p$)**\n\nThe PIL environment models a physical processor using $n$-bit two's-complement signed integer arithmetic. In this system, addition is performed modulo $2^n$. The range of representable numbers is $[x_{min}, x_{max}]$, where $x_{min} = -(2^{n-1})$ and $x_{max} = 2^{n-1}-1$.\n\nFor most values of $x$, the computed value of $x+1$ in this system matches the mathematical result, and thus $x+1 > x$ holds true. However, there is a critical exception at the upper boundary.\n\nWhen $x = x_{max} = 2^{n-1}-1$, the operation $x+1$ results in an overflow. In two's-complement arithmetic, the bit pattern for $x_{max}$ is a $0$ followed by $n-1$ ones ($011...1$). Adding $1$ to this pattern yields a $1$ followed by $n-1$ zeros ($100...0$), which is the representation of the minimum value, $x_{min} = -(2^{n-1})$.\n\nSo, for $x = 2^{n-1}-1$, the PIL evaluates:\n$(x+1)_{PIL} = -(2^{n-1})$\n\nThe comparison then becomes:\n$-(2^{n-1}) > 2^{n-1}-1$\n\nThis inequality is false. Thus, for $x = 2^{n-1}-1$, the PIL output is $p=0$. For all other representable values of $x$ (i.e., $x \\in [-(2^{n-1}), 2^{n-1}-2]$), the result of $x+1$ does not wrap around in this manner, and the comparison $x+1 > x$ remains true, yielding $p=1$.\n\nThe implementation of this model can be achieved efficiently by utilizing the fixed-width integer types provided by the `numpy` library (e.g., `numpy.int32` for $n=32$), which naturally handle the wrap-around arithmetic characteristic of hardware processors.\n\n4.  **Divergence Flag ($d$)**\n\nThe divergence flag $d$ simply indicates whether the SIL and PIL models produce different outputs. It is a boolean value computed by the logical inequality $s \\neq p$. Based on the analysis above, divergence will occur if and only if $x = 2^{n-1}-1$, which is precisely the case where the static analysis predicate $q$ is false.\n\n$d = (s \\neq p)$\n\nThe program will iterate through the provided test cases. For each pair $(n, x)$, it will:\n- Set $s=1$.\n- Calculate $p$ by performing the addition and comparison using `numpy`'s fixed-width integer types corresponding to the bit-width $n$.\n- Calculate $d$ by comparing $s$ and $p$.\n- Calculate $q$ by comparing $x$ to the computed threshold $2^{n-1}-1$.\nThe final result is a list of these four-element lists.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Analyzes divergence between SIL and PIL models for the logic x+1 > x.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 0),\n        (32, 2**31 - 1),\n        (32, -1),\n        (16, 2**15 - 1),\n        (16, -2**15),\n    ]\n\n    results = []\n    for n, x in test_cases:\n        # 1. Calculate s: SIL (Software-in-the-Loop) output\n        # In mathematical integers, x+1 > x is always true.\n        s = 1\n\n        # 2. Calculate p: PIL (Processor-in-the-Loop) output\n        # Model n-bit two's-complement signed integer arithmetic.\n        # numpy's fixed-width integers model hardware overflow correctly.\n        if n == 16:\n            dtype = np.int16\n        elif n == 32:\n            dtype = np.int32\n        else:\n            # As per problem constraints, only n=16 and n=32 are used.\n            # This is a fallback that would raise an error for other n.\n            raise ValueError(f\"Unsupported bit-width: {n}\")\n        \n        x_pil = dtype(x)\n        one_pil = dtype(1)\n        x_plus_1_pil = x_pil + one_pil\n        \n        # Perform the comparison in the PIL model.\n        if x_plus_1_pil > x_pil:\n            p = 1\n        else:\n            p = 0\n            \n        # 3. Calculate d: Divergence flag\n        # True if SIL and PIL outputs differ.\n        d = (s != p)\n        \n        # 4. Calculate q: Static analysis safety predicate\n        # Checks if x+1 would overflow in signed n-bit arithmetic.\n        # The condition is x < 2**(n-1) - 1.\n        max_val = 2**(n - 1) - 1\n        q = (x < max_val)\n\n        results.append([s, p, d, q])\n\n    # Format the output string as a list of lists with no extra whitespace.\n    inner_strings = []\n    for res_list in results:\n        # Convert each element in the sublist to a string\n        # and join with commas.\n        str_list = [str(item) for item in res_list]\n        inner_str = ','.join(str_list)\n        inner_strings.append(f\"[{inner_str}]\")\n    \n    # Join the inner list strings with commas and enclose in brackets.\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output.replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}