{
    "hands_on_practices": [
        {
            "introduction": "为保证信息物理系统的可靠性，对其数字孪生模型实施语义约束至关重要。本实践练习 () 将引导你完成一项本体工程中的基础任务：使用描述逻辑 (DL) 定义一条公理，确保每个传感器都必须测量一个物理量。随后，你将实现一个验证检查器，从而亲身体验形式语义如何转化为在封闭世界假设下的实用数据完整性检查。",
            "id": "4245038",
            "problem": "您的任务是在信息物理系统 (CPS) 的背景下，形式化并检查一个语义约束。目标是使用Web本体语言 (OWL) 的函数式语法，在描述逻辑 (DL) 中构建一条公理，该公理强制要求类 $Sensor$ 的每个实例都必须通过对象属性 $measures$ 与类 $QuantityKind$ 的某个实例相关联，这里使用存在量词约束 $\\exists$。然后，您必须实现一个程序，该程序在给定一组个体、类断言和属性断言的情况下，通过封闭世界验证机制，为几个测试用例确定该公理是否得到满足。程序应将子类公理视为推断支持，这意味着 $QuantityKind$ 的子类的实例也算作满足存在量词约束。\n\n使用的基本基础包括描述逻辑的标准模型论语义：给定一个解释 $\\mathcal{I}$，其域为 $\\Delta^\\mathcal{I}$，一个类 $C$ 被解释为子集 $C^\\mathcal{I} \\subseteq \\Delta^\\mathcal{I}$，一个对象属性 $p$ 被解释为二元关系 $p^\\mathcal{I} \\subseteq \\Delta^\\mathcal{I} \\times \\Delta^\\mathcal{I}$。存在量词约束被解释为 $$(\\exists p.C)^\\mathcal{I} = \\{ x \\in \\Delta^\\mathcal{I} \\mid \\exists y \\in \\Delta^\\mathcal{I} \\text{ such that } (x,y) \\in p^\\mathcal{I} \\text{ and } y \\in C^\\mathcal{I} \\}.$$ 子类关系 $A \\sqsubseteq B$ 被解释为 $A^\\mathcal{I} \\subseteq B^\\mathcal{I}$。\n\n构建以下 OWL 函数式语法公理集，以捕捉预期的 DL 约束：\n\n- 使用基础前缀 $: = \\langle http://example.org/cps\\# \\rangle$。\n- 声明相关的类和对象属性：\n  - $Declaration(Class(:Sensor))$\n  - $Declaration(Class(:QuantityKind))$\n  - $Declaration(ObjectProperty(:measures))$\n- 陈述强制存在量词约束的子类公理：\n  - $SubClassOf(:Sensor\\ ObjectSomeValuesFrom(:measures\\ :QuantityKind))$\n- 您可以根据测试套件的需要，包含额外的类声明，如 $:Temperature$、$:Pressure$、$:Actuator$ 和 $:Unit$，以及子类公理，如 $SubClassOf(:Temperature\\ :QuantityKind)$ 和 $SubClassOf(:Pressure\\ :QuantityKind)$。\n\n您的程序必须在一组测试数据集上为上述公理实现封闭世界验证。对于给定的数据集，程序必须检查是否对于每个被断言为 $Sensor$ 类型的个体 $x$，都存在至少一个个体 $y$，使得 $(x,y)$ 通过 $measures$ 被断言，并且 $y$ 被断言为 $QuantityKind$ 类型或某个类 $C$ 的类型，其中给定的子类公理 $C \\sqsubseteq QuantityKind$ 成立（包括子类关系的链）。如果任何 $Sensor$ 个体未能满足此条件，则该数据集的结果为 $False$；否则为 $True$。\n\n物理单位不适用。角度不适用。百分比不适用。\n\n测试套件和参数：\n您的程序必须硬编码并评估以下 $6$ 个数据集。每个数据集包括：\n- 一个有限的类声明集（仅名称）。\n- 一组子类公理，形式为有序对 $(A, B)$，表示 $A \\sqsubseteq B$。\n- 一个从个体到其断言类集合的映射。\n- 一组 $measures$ 边，形式为有序对 $(subject, object)$。\n\n待评估的数据集：\n- 数据集 $1$ (正常路径): 类 $\\{Sensor, QuantityKind\\}$；子类公理 $\\emptyset$；类型 $\\{s1 \\mapsto \\{Sensor\\}, q1 \\mapsto \\{QuantityKind\\}\\}$；边 $\\{(s1, q1)\\}$；预期结果 $True$。\n- 数据集 $2$ (子类满足): 类 $\\{Sensor, QuantityKind, Temperature\\}$；子类公理 $\\{(Temperature, QuantityKind)\\}$；类型 $\\{s2 \\mapsto \\{Sensor\\}, t1 \\mapsto \\{Temperature\\}\\}$；边 $\\{(s2, t1)\\}$；预期结果 $True$。\n- 数据集 $3$ (违规：无测量): 类 $\\{Sensor, QuantityKind\\}$；子类公理 $\\emptyset$；类型 $\\{s3 \\mapsto \\{Sensor\\}\\}$；边 $\\emptyset$；预期结果 $False$。\n- 数据集 $4$ (违规：目标类型错误): 类 $\\{Sensor, QuantityKind, Actuator\\}$；子类公理 $\\emptyset$；类型 $\\{s4 \\mapsto \\{Sensor\\}, a1 \\mapsto \\{Actuator\\}\\}$；边 $\\{(s4, a1)\\}$；预期结果 $False$。\n- 数据集 $5$ (多个测量其中一个有效): 类 $\\{Sensor, QuantityKind, Unit, Pressure\\}$；子类公理 $\\{(Pressure, QuantityKind)\\}$；类型 $\\{s5 \\mapsto \\{Sensor\\}, u1 \\mapsto \\{Unit\\}, p1 \\mapsto \\{Pressure\\}\\}$；边 $\\{(s5, u1), (s5, p1)\\}$；预期结果 $True$。\n- 数据集 $6$ (违规：未知目标类型): 类 $\\{Sensor, QuantityKind\\}$；子类公理 $\\emptyset$；类型 $\\{s6 \\mapsto \\{Sensor\\}, e4 \\mapsto \\emptyset\\}$；边 $\\{(s6, e4)\\}$；预期结果 $False$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含数据集 1 到 6 的结果，格式为方括号内的逗号分隔列表，例如 $[result_1,result_2,\\dots,result_6]$，其中每个 $result_i$ 是按规定计算出的布尔值 $True$ 或 $False$。不应打印任何其他文本。",
            "solution": "用户提供了一个科学上合理、定义明确且完整的问题。它基于描述逻辑 (DL) 的标准原则及其在使用 Web 本体语言 (OWL) 进行语义建模中的应用，这些都是计算机科学和知识表示领域的核心主题。问题在于形式化一个约束，然后为其实现一个验证检查器。\n\n该问题是有效的。\n\n核心任务是在封闭世界假设下，根据一个语义公理来验证一组断言。需要强制执行的公理是，类 $Sensor$ 的每个实例都必须通过对象属性 $measures$ 与类 $QuantityKind$ 的至少一个实例相关联。在描述逻辑中，这表示为一个子类公理：\n$$\nSensor \\sqsubseteq \\exists measures.QuantityKind\n$$\n该公理指出，类 $Sensor$ 是测量某个 $QuantityKind$ 的事物的类的子类。存在量词约束 $(\\exists p.C)^\\mathcal{I}$ 的语义是个体的集合 $\\{ x \\in \\Delta^\\mathcal{I} \\mid \\exists y \\in \\Delta^\\mathcal{I} \\text{ such that } (x,y) \\in p^\\mathcal{I} \\text{ and } y \\in C^\\mathcal{I} \\}$. 将此应用于该公理，对于任何个体 $x \\in Sensor^\\mathcal{I}$，必须有 $x \\in (\\exists measures.QuantityKind)^\\mathcal{I}$。这意味着必须存在一个个体 $y$，使得 $(x,y) \\in measures^\\mathcal{I}$ 且 $y \\in QuantityKind^\\mathcal{I}$。\n\n问题指定必须考虑子类关系。形式为 $A \\sqsubseteq B$ 的公理意味着类 $A$ 的任何实例也是类 $B$ 的实例，即 $A^\\mathcal{I} \\subseteq B^\\mathcal{I}$。这种关系是传递性的。因此，如果一个个体 $y$ 是类 $C$ 的实例，并且存在一个子类公理链 $C \\sqsubseteq D_1$, $D_1 \\sqsubseteq D_2$, ..., $D_n \\sqsubseteq QuantityKind$，那么 $y$ 也被认为是 $QuantityKind$ 的实例。\n\n验证必须在封闭世界假设下执行。这意味着我们只考虑每个数据集中明确陈述的事实（类断言、属性断言和子类公理）。如果一个事实没有被陈述，则假定其为假。\n\n验证给定数据集的算法如下：\n\n1.  **识别有效目标类**：首先，我们必须确定能够满足 $measures$ 属性右侧的完整类集。这个集合，我们称之为 $V_{QK}$，包括 $QuantityKind$ 本身以及所有被传递地定义为 $QuantityKind$ 子类的类。子类公理，其形式为表示 $A \\sqsubseteq B$ 的有序对 $(A, B)$，可以被建模为一个有向图，其中从 $A$ 到 $B$ 存在一条边。如果图中存在从类 $C$ 到 $QuantityKind$ 的路径，则类 $C$ 属于 $V_{QK}$。这可以通过从节点 $C$ 开始执行图遍历（例如，广度优先搜索或深度优先搜索）来确定 $QuantityKind$ 是否可达。\n\n2.  **识别传感器个体**：根据提供的类型断言，我们编制一个所有被明确声明为类 $Sensor$ 实例的个体的列表。\n\n3.  **迭代并验证每个传感器**：对于每个被识别为 $Sensor$ 的个体 $s$，我们必须验证它是否满足条件。对单个传感器 $s$ 的验证如下：\n    a.  找到所有形式为 $(s, y)$ 的关于属性 $measures$ 的属性断言。设所有这类目标个体的集合为 $Y_s$。\n    b.  如果集合 $Y_s$ 为空，则传感器 $s$ 验证失败，因为没有存在性满足（$\\neg \\exists y$）。因此整个数据集无效，结果为 $False$。\n    c.  如果 $Y_s$ 不为空，我们必须检查是否至少有一个个体 $y \\in Y_s$ 是有效目标类的实例。对于每个 $y \\in Y_s$，我们从类型映射中检索其断言的类。设这个类的集合为 $C_y$。\n    d.  然后我们检查是否有任何类 $c \\in C_y$ 是在步骤 1 中确定的有效目标类集 $V_{QK}$ 的成员。\n    e.  如果我们找到至少一个 $y \\in Y_s$，其至少有一个类 $c \\in C_y$ 是一个有效的目标类，那么传感器 $s$ 满足该公理。然后我们可以继续处理下一个传感器。\n    f. 如果在检查了给定传感器 $s$ 的所有 $y \\in Y_s$ 之后，没有找到这样的有效目标个体，则传感器 $s$ 违反了该公理。整个数据集无效，结果为 $False$。\n\n4.  **最终结果**：如果类 $Sensor$ 的所有个体都成功通过步骤 3 的验证，则该数据集被认为是有效的，结果为 $True$。只要有一个传感器个体失败，整个数据集的判定结果就是 $False$。\n\n该算法正确地实现了指定 DL 公理的封闭世界验证，包括对传递性子类层次结构的支持，正如问题陈述所要求的那样。可以使用此过程系统地评估提供的测试用例，以得出预期的布尔结果。例如，在数据集 $2$ 中，类型为 $Temperature$ 的个体是一个有效的目标，因为提供了公理 $Temperature \\sqsubseteq QuantityKind$。在数据集 $5$ 中，传感器测量两个事物，一个是 $Unit$ 的实例，另一个是 $Pressure$ 的实例。由于给定了 $Pressure \\sqsubseteq QuantityKind$，对 $Pressure$ 实例的测量足以满足该传感器的公理，即使对 $Unit$ 实例的测量是无效的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are permitted.\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results.\n    \"\"\"\n\n    # Test Suite and Parameters\n    # Each dataset is a tuple: (class_declarations, subclass_axioms, type_assertions, measures_edges)\n    test_cases = [\n        # Dataset 1 (happy path)\n        (\n            {'Sensor', 'QuantityKind'},\n            set(),\n            {'s1': {'Sensor'}, 'q1': {'QuantityKind'}},\n            {('s1', 'q1')}\n        ),\n        # Dataset 2 (subclass satisfaction)\n        (\n            {'Sensor', 'QuantityKind', 'Temperature'},\n            {('Temperature', 'QuantityKind')},\n            {'s2': {'Sensor'}, 't1': {'Temperature'}},\n            {('s2', 't1')}\n        ),\n        # Dataset 3 (violation: no measurement)\n        (\n            {'Sensor', 'QuantityKind'},\n            set(),\n            {'s3': {'Sensor'}},\n            set()\n        ),\n        # Dataset 4 (violation: wrong target type)\n        (\n            {'Sensor', 'QuantityKind', 'Actuator'},\n            set(),\n            {'s4': {'Sensor'}, 'a1': {'Actuator'}},\n            {('s4', 'a1')}\n        ),\n        # Dataset 5 (multiple measures with one valid)\n        (\n            {'Sensor', 'QuantityKind', 'Unit', 'Pressure'},\n            {('Pressure', 'QuantityKind')},\n            {'s5': {'Sensor'}, 'u1': {'Unit'}, 'p1': {'Pressure'}},\n            {('s5', 'u1'), ('s5', 'p1')}\n        ),\n        # Dataset 6 (violation: unknown target type)\n        (\n            {'Sensor', 'QuantityKind'},\n            set(),\n            {'s6': {'Sensor'}, 'e4': set()},\n            {('s6', 'e4')}\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(validate_dataset(*case))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_dataset(classes, subclass_axioms, types, edges):\n    \"\"\"\n    Validates a single dataset against the semantic constraint.\n\n    Args:\n        classes (set): Set of class names.\n        subclass_axioms (set): Set of (subclass, superclass) tuples.\n        types (dict): Mapping from individual name to a set of its class names.\n        edges (set): Set of (subject, object) tuples for the 'measures' property.\n\n    Returns:\n        bool: True if the dataset is valid, False otherwise.\n    \"\"\"\n    # Build a graph-like structure for subclass relationships for efficient lookup.\n    # The map stores {subclass: [list of direct superclasses]}.\n    subclass_map = {}\n    for sub, sup in subclass_axioms:\n        if sub not in subclass_map:\n            subclass_map[sub] = []\n        subclass_map[sub].append(sup)\n\n    # Memoization cache for is_subclass_of checks to avoid re-computation.\n    memo = {}\n    def is_subclass_of(child, parent):\n        if (child, parent) in memo:\n            return memo[(child, parent)]\n        \n        if child == parent:\n            memo[(child, parent)] = True\n            return True\n\n        # BFS to find a path from child to parent in the subclass graph.\n        q = [child]\n        visited = {child}\n        while q:\n            current = q.pop(0)\n            if current == parent:\n                memo[(child, parent)] = True\n                return True\n            for superclass in subclass_map.get(current, []):\n                if superclass not in visited:\n                    visited.add(superclass)\n                    q.append(superclass)\n        \n        memo[(child, parent)] = False\n        return False\n\n    def is_valid_target_type(cls):\n        \"\"\"Checks if a class is QuantityKind or a subclass thereof.\"\"\"\n        return is_subclass_of(cls, 'QuantityKind')\n\n    # Find all individuals asserted to be of type 'Sensor'.\n    sensor_individuals = {ind for ind, ind_types in types.items() if 'Sensor' in ind_types}\n    \n    if not sensor_individuals:\n        return True # Vacuously true if there are no sensors.\n\n    # Create a mapping from subject to a list of objects for 'measures' edges.\n    measures_map = {}\n    for subj, obj in edges:\n        if subj not in measures_map:\n            measures_map[subj] = []\n        measures_map[subj].append(obj)\n\n    # For each sensor, check if the axiom is satisfied.\n    for sensor in sensor_individuals:\n        measured_individuals = measures_map.get(sensor, [])\n\n        if not measured_individuals:\n            return False # Fails if sensor measures nothing.\n\n        is_satisfied = False\n        for measured_ind in measured_individuals:\n            target_types = types.get(measured_ind, set())\n            \n            # Check if any type of the target individual is a valid type.\n            for t_type in target_types:\n                if is_valid_target_type(t_type):\n                    is_satisfied = True\n                    break # Found a valid measurement, no need to check other types.\n            if is_satisfied:\n                break # Found a valid measured individual, move to the next sensor.\n\n        if not is_satisfied:\n            return False # This sensor fails to satisfy the axiom.\n\n    return True # All sensors satisfied the axiom.\n\nsolve()\n```"
        },
        {
            "introduction": "当信息物理系统的知识库填充了数据后，为实现监控和决策，检索具体且与上下文相关的信变得至关重要。本练习 () 聚焦于使用SPARQL（RDF知识图谱的标准查询语言）来查询语义数据。你将构建一个不仅能根据时间和数值阈值过滤数据，还能执行单位归一化的查询，从而展示SOSA和QUDT等本体如何实现强大的、基于物理现实的数据检索。",
            "id": "4244964",
            "problem": "给定一个概念性的信息物理系统，其中的传感器使用资源描述框架 (RDF) 和传感器、观测、样本和执行器 (SOSA) 本体进行建模，同时结合使用量、单位、维度和数据 (QUDT) 模式来描述量和单位。请构建一个 SPARQL 协议和 RDF 查询语言 (SPARQL) 查询，该查询用于选择测量属性为“温度”(Temperature) 的不同传感器，且这些传感器记录的测量值在归一化为国际单位制 (SI) 基本单位开尔文后，在指定的包含性时间窗口 $[t_{\\text{start}}, t_{\\text{end}}]$ 内严格大于一个阈值 $T_{max}$。归一化过程必须确保在开尔文、摄氏度和华氏度读数之间进行能够感知单位的比较。阈值 $T_{max}$ 以开尔文为单位提供，并且必须解释为 $xsd:double$ 类型。时间窗口端点 $t_{\\text{start}}$ 和 $t_{\\text{end}}$ 以 $xsd:dateTime$ 字面量形式提供，并且必须包含这两个端点。\n\n使用以下词汇和结构：\n- 观测符合 SOSA 标准：每次观测通过 $sosa{:}madeBySensor$ 链接到观测传感器，通过 $sosa{:}observedProperty$ 链接到观测属性，通过 $sosa{:}resultTime$ 链接到结果时间，并通过 $sosa{:}hasResult$ 链接到一个量值。\n- 量值符合 QUDT 标准：结果节点通过 $qudt{:}numericValue$ 提供数值字面量，并通过 $qudt{:}unit$ 提供单位。\n- 需要考虑的单位是开尔文、摄氏度和华氏度。SPARQL 查询的编写必须确保只转换这些已识别的单位；对于单位无法识别或缺失的观测，必须从结果中排除，以保证科学上的严谨性。\n\n您的程序必须：\n1. 构建一个参数化的 SPARQL 查询，该查询：\n   - 选择 $?sensor$。\n   - 确保 $sosa{:}observedProperty$ 是“温度”。\n   - 在与 $T_{max}$ 比较之前，将数值归一化为开尔文。\n   - 应用包含性时间窗口 $[t_{\\text{start}}, t_{\\text{end}}]$。\n   - 返回不同的传感器。\n2. 模拟该查询在以下数据集上的评估，该数据集被建模为一组观测。每次观测是一个元组 $(\\text{传感器 IRI}, \\text{属性 IRI}, \\text{数值}, \\text{单位代码}, \\text{ISO 8601 时间})$。单位以代码形式出现：“K”代表开尔文，“C”代表摄氏度，“F”代表华氏度，“UNKNOWN”代表单位无法识别。属性 IRI 使用 \"http://example.org/property/Temperature\" 代表“温度”，使用 \"http://example.org/property/Humidity\" 代表“湿度”。传感器 IRI 遵循 \"http://example.org/sensor/sensorX\" 格式。时间是协调世界时 (Coordinated Universal Time) 的 ISO 8601 字符串，以 \"Z\" 结尾。数据如下：\n   - $(\\text{\"http://example.org/sensor/sensorA\"}, \\text{\"http://example.org/property/Temperature\"}, 36.5, \\text{\"C\"}, \\text{\"2023-09-15T10:30:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorA\"}, \\text{\"http://example.org/property/Temperature\"}, 309.15, \\text{\"K\"}, \\text{\"2023-09-15T12:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorB\"}, \\text{\"http://example.org/property/Temperature\"}, 100.0, \\text{\"F\"}, \\text{\"2023-09-15T11:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorC\"}, \\text{\"http://example.org/property/Temperature\"}, 310.0, \\text{\"K\"}, \\text{\"2023-09-15T10:59:59Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorD\"}, \\text{\"http://example.org/property/Temperature\"}, -10.0, \\text{\"C\"}, \\text{\"2023-09-15T10:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorE\"}, \\text{\"http://example.org/property/Temperature\"}, 37.0, \\text{\"C\"}, \\text{\"2023-09-15T11:30:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorF\"}, \\text{\"http://example.org/property/Temperature\"}, 310.0, \\text{\"UNKNOWN\"}, \\text{\"2023-09-15T11:00:00Z\"})$\n   - $(\\text{\"http://example.org/sensor/sensorG\"}, \\text{\"http://example.org/property/Humidity\"}, 0.50, \\text{\"UNKNOWN\"}, \\text{\"2023-09-15T11:00:00Z\"})$\n3. 针对以下每个测试用例，根据数据集评估所构建的查询逻辑。对于每个测试用例，计算查询所选出的不同传感器的数量。\n   - 测试用例 1 (正常路径)：$T_{max} = 310.0$ K, $t_{\\text{start}} = \\text{\"2023-09-15T10:00:00Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T12:00:00Z\"}$。\n   - 测试用例 2 (时间边界的包含性与严格阈值)：$T_{max} = 310.0$ K, $t_{\\text{start}} = \\text{\"2023-09-15T10:59:59Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T11:00:00Z\"}$。\n   - 测试用例 3 (低阈值下的多重选择)：$T_{max} = 300.0$ K, $t_{\\text{start}} = \\text{\"2023-09-15T10:00:00Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T12:00:00Z\"}$。\n   - 测试用例 4 (单个时间点的窄时间窗口)：$T_{max} = 309.7$ K, $t_{\\text{start}} = \\text{\"2023-09-15T11:30:00Z\"}$, $t_{\\text{end}} = \\text{\"2023-09-15T11:30:00Z\"}$。\n\n需应用的规则和约束：\n- 只有“温度”属性的观测才有资格。\n- 只有集合 $\\{\\text{开尔文}, \\text{摄氏度}, \\text{华氏度}\\}$ 中的单位被认可用于归一化；任何其他单位都必须从考虑范围中排除。\n- 比较必须是严格大于 $T_{max}$。\n- 时间窗口 $[t_{\\text{start}}, t_{\\text{end}}]$ 包含两个端点。\n- 所有数值量和阈值在归一化后均以开尔文为单位；$T_{max}$ 以开尔文为单位提供，并且在 SPARQL 查询中必须作为 $xsd{:}double$ 字面量处理。\n- 不涉及角度单位。\n- 程序的最终输出必须是单行，内容是一个方括号括起来的逗号分隔列表，其中每个元素是对应测试用例所选出的不同传感器的数量（整数），顺序与上面列出的测试用例一致。例如：$[\\text{result1}, \\text{result2}, \\text{result3}, \\text{result4}]$。\n\n您的任务是构建 SPARQL 查询字符串，其中包含适当的单位归一化和时间过滤，并实现一个模拟，以在所提供的数据集上评估其执行，从而为测试套件生成所要求的整数计数。",
            "solution": "该问题被认为是有效的，因为它具有科学依据、定义明确且客观。它提供了一套完整且一致的需求、数据和约束来构建一个形式化的解决方案。该任务涉及设计一个 SPARQL 查询并模拟其逻辑，这是使用语义网技术和知识图谱的标准实践，与信息物理系统的建模直接相关。\n\n解决方案包含两个主要部分：SPARQL 查询的概念设计和基于 Python 的模拟，用于根据提供的数据集和测试用例评估查询逻辑。\n\n首先，我们设计 SPARQL 查询。该查询必须选择满足多个条件的不同的传感器。此类查询的结构如下：\n\n1.  **前缀**：为了缩短查询，我们为所使用的本体定义了前缀：`sosa` 用于传感器、观测、样本和执行器本体，`qudt` 用于量、单位、维度和数据模式，`xsd` 用于 XML 模式数据类型。\n2.  **选择子句**：查询必须返回不同的传感器，这通过 `SELECT DISTINCT ?sensor` 实现。\n3.  **图模式匹配**：`WHERE` 子句定义了用于查找相关观测的图模式。我们从一个观测 (`?obs`) 遍历到其关联的传感器 (`?sensor`)、观测属性、结果时间 (`?time`) 和结果 (`?result`)。再进一步遍历结果节点，以找到其数值 (`?value`) 和单位代码 (`?unitCode`)。\n4.  **单位归一化**：查询使用 `BIND` 和 `IF` 语句将不同单位的温度值归一化为开尔文。\n5.  **过滤**：`FILTER` 子句用于应用时间和阈值约束，确保结果在指定时间窗口内且高于温度阈值，并且单位是已知的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\nfrom datetime import datetime, timezone\n\ndef solve():\n    \"\"\"\n    Constructs and simulates a SPARQL query to find sensors reporting high temperatures.\n    \"\"\"\n    \n    # Dataset modeled as a list of tuples:\n    # (sensor IRI, property IRI, numeric value, unit code, ISO 8601 time)\n    dataset = [\n        (\"http://example.org/sensor/sensorA\", \"http://example.org/property/Temperature\", 36.5, \"C\", \"2023-09-15T10:30:00Z\"),\n        (\"http://example.org/sensor/sensorA\", \"http://example.org/property/Temperature\", 309.15, \"K\", \"2023-09-15T12:00:00Z\"),\n        (\"http://example.org/sensor/sensorB\", \"http://example.org/property/Temperature\", 100.0, \"F\", \"2023-09-15T11:00:00Z\"),\n        (\"http://example.org/sensor/sensorC\", \"http://example.org/property/Temperature\", 310.0, \"K\", \"2023-09-15T10:59:59Z\"),\n        (\"http://example.org/sensor/sensorD\", \"http://example.org/property/Temperature\", -10.0, \"C\", \"2023-09-15T10:00:00Z\"),\n        (\"http://example.org/sensor/sensorE\", \"http://example.org/property/Temperature\", 37.0, \"C\", \"2023-09-15T11:30:00Z\"),\n        (\"http://example.org/sensor/sensorF\", \"http://example.org/property/Temperature\", 310.0, \"UNKNOWN\", \"2023-09-15T11:00:00Z\"),\n        (\"http://example.org/sensor/sensorG\", \"http://example.org/property/Humidity\", 0.50, \"UNKNOWN\", \"2023-09-15T11:00:00Z\"),\n    ]\n\n    # Test cases: (T_max in Kelvin, t_start string, t_end string)\n    test_cases = [\n        (310.0, \"2023-09-15T10:00:00Z\", \"2023-09-15T12:00:00Z\"),\n        (310.0, \"2023-09-15T10:59:59Z\", \"2023-09-15T11:00:00Z\"),\n        (300.0, \"2023-09-15T10:00:00Z\", \"2023-09-15T12:00:00Z\"),\n        (309.7, \"2023-09-15T11:30:00Z\", \"2023-09-15T11:30:00Z\"),\n    ]\n\n    results = []\n\n    # Constants and recognized values\n    TEMPERATURE_PROPERTY_IRI = \"http://example.org/property/Temperature\"\n    RECOGNIZED_UNITS = {\"K\", \"C\", \"F\"}\n\n    for t_max, t_start_str, t_end_str in test_cases:\n        selected_sensors = set()\n\n        # Parse time boundaries once per test case\n        t_start_dt = datetime.fromisoformat(t_start_str)\n        t_end_dt = datetime.fromisoformat(t_end_str)\n\n        for sensor_iri, prop_iri, num_val, unit, time_str in dataset:\n            # 1. Filter by property\n            if prop_iri != TEMPERATURE_PROPERTY_IRI:\n                continue\n\n            # 2. Filter by recognized units\n            if unit not in RECOGNIZED_UNITS:\n                continue\n\n            # 3. Filter by time window (inclusive)\n            obs_time_dt = datetime.fromisoformat(time_str)\n            if not (t_start_dt = obs_time_dt = t_end_dt):\n                continue\n            \n            # 4. Normalize value to Kelvin\n            value_in_k = 0.0\n            if unit == \"C\":\n                value_in_k = num_val + 273.15\n            elif unit == \"F\":\n                value_in_k = (num_val - 32.0) * 5.0 / 9.0 + 273.15\n            elif unit == \"K\":\n                value_in_k = num_val\n            \n            # 5. Filter by threshold (strictly greater)\n            if value_in_k > t_max:\n                selected_sensors.add(sensor_iri)\n        \n        # The result is the number of distinct sensors found\n        results.append(len(selected_sensors))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "随着本体模型的演化，相互冲突的信息可能会被引入，导致逻辑不一致性，从而破坏整个知识库的可靠性。本实践练习 () 深入探讨了本体调试和修复这一关键任务。通过分析一组相互冲突的公理和断言，你将学会如何识别不一致性的最小原因（冲突集），并计算出最小修复集，为维护复杂语义模型的逻辑健全性提供形式化基础。",
            "id": "4244997",
            "problem": "考虑一个在描述逻辑 (DL) 中指定的网络物理系统 (CPS) 本体片段，该片段旨在用于数字孪生模型。设类为 $\\mathsf{Sensor}$、$\\mathsf{Actuator}$、$\\mathsf{Device}$、$\\mathsf{TemperatureSensor}$、$\\mathsf{ValveActuator}$、$\\mathsf{SenseRole}$ 和 $\\mathsf{ActRole}$。设对象属性为 $\\mathsf{hasRole}$。TBox 公理如下：\n1. $\\mathsf{TemperatureSensor} \\sqsubseteq \\mathsf{Sensor}$，\n2. $\\mathsf{ValveActuator} \\sqsubseteq \\mathsf{Actuator}$，\n3. $\\mathsf{Sensor} \\sqsubseteq \\mathsf{Device}$，\n4. $\\mathsf{Actuator} \\sqsubseteq \\mathsf{Device}$，\n5. $\\mathsf{Sensor} \\sqcap \\mathsf{Actuator} \\sqsubseteq \\bot$，\n6. $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$，\n7. $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$。\n\n考虑包含个体 $x_1$、$x_2$、$x_3$、$r_1$、$r_2$ 和以下断言的 ABox：\n- $\\mathsf{hasRole}(x_1, r_1)$, $r_1 : \\mathsf{SenseRole}$,\n- $\\mathsf{hasRole}(x_1, r_2)$, $r_2 : \\mathsf{ActRole}$,\n- $\\mathsf{hasRole}(x_2, r_2)$, $x_2 : \\mathsf{TemperatureSensor}$,\n- $\\mathsf{hasRole}(x_3, r_1)$, $x_3 : \\mathsf{ValveActuator}$.\n\n假设采用描述逻辑的标准一阶语义和开放世界假设，如同在网络本体语言 (OWL) 中一样。仅使用 DL 的基础语义（类解释、角色解释、包含和不相交性），首先确定本体 $\\mathcal{O}$ 是否一致。然后，将修复限制为仅删除 ABox（不允许更改 TBox），以便所有三个个体 $x_1$、$x_2$ 和 $x_3$ 不再违反不相交公理。\n\n将最小 ABox 删除修复集定义为一个 ABox 断言集合，移除该集合可以产生一个一致的本体，并且该集合是包含最小的且具有最小可能基数。计算 $\\mathcal{O}$ 的不同最小 ABox 删除修复集的数量 $N$。只报告 $N$ 作为最终答案。无需四舍五入；将最终答案表示为不带单位的整数。",
            "solution": "问题要求计算给定本体 $\\mathcal{O}$ 的不同最小 ABox 删除修复集的数量 $N$。如果一个本体有模型，则它是一致的。如果公理在逻辑上导致矛盾，例如一个个体既是一个类的实例又是其补集的实例，就会出现不一致性。$\\mathcal{O}$ 的 TBox 包含不相交公理 $\\mathsf{Sensor} \\sqcap \\mathsf{Actuator} \\sqsubseteq \\bot$，该公理断言没有个体可以同时是类 $\\mathsf{Sensor}$ 和类 $\\mathsf{Actuator}$ 的实例。我们必须首先通过检查是否有任何个体违反此公理来确定本体是否一致。\n\nTBox 公理如下：\n$1.$ $\\mathsf{TemperatureSensor} \\sqsubseteq \\mathsf{Sensor}$\n$2.$ $\\mathsf{ValveActuator} \\sqsubseteq \\mathsf{Actuator}$\n$3.$ $\\mathsf{Sensor} \\sqsubseteq \\mathsf{Device}$\n$4.$ $\\mathsf{Actuator} \\sqsubseteq \\mathsf{Device}$\n$5.$ $\\mathsf{Sensor} \\sqcap \\mathsf{Actuator} \\sqsubseteq \\bot$\n$6.$ $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$\n$7.$ $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$\n\nABox 包含以下 $8$ 个断言，为了清晰起见，我们对其进行标记：\n$\\mathcal{A}_1: \\mathsf{hasRole}(x_1, r_1)$\n$\\mathcal{A}_2: r_1 : \\mathsf{SenseRole}$\n$\\mathcal{A}_3: \\mathsf{hasRole}(x_1, r_2)$\n$\\mathcal{A}_4: r_2 : \\mathsf{ActRole}$\n$\\mathcal{A}_5: \\mathsf{hasRole}(x_2, r_2)$\n$\\mathcal{A}_6: x_2 : \\mathsf{TemperatureSensor}$\n$\\mathcal{A}_7: \\mathsf{hasRole}(x_3, r_1)$\n$\\mathcal{A}_8: x_3 : \\mathsf{ValveActuator}$\n\n**第 1 步：检查不一致性**\n\n我们分析每个个体 $x_1$、$x_2$ 和 $x_3$ 的类成员关系。\n\n对于个体 $x_1$：\n- 根据 ABox 断言 $\\mathcal{A}_1: \\mathsf{hasRole}(x_1, r_1)$ 和 $\\mathcal{A}_2: r_1 : \\mathsf{SenseRole}$，我们可以推断出 $x_1$ 是类 $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole}$ 的一个实例。\n- 根据 TBox 公理 $6$, $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$，我们得出结论 $x_1 : \\mathsf{Sensor}$。\n- 根据 ABox 断言 $\\mathcal{A}_3: \\mathsf{hasRole}(x_1, r_2)$ 和 $\\mathcal{A}_4: r_2 : \\mathsf{ActRole}$，我们可以推断出 $x_1$ 是类 $\\exists \\mathsf{hasRole}.\\mathsf{ActRole}$ 的一个实例。\n- 根据 TBox 公理 $7$, $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$，我们得出结论 $x_1 : \\mathsf{Actuator}$。\n由于 $x_1$ 同时是 $\\mathsf{Sensor}$ 和 $\\mathsf{Actuator}$ 的实例，这违反了不相交公理 $5$。因此，该本体不一致，且 $x_1$ 是矛盾的来源之一。\n\n对于个体 $x_2$：\n- 根据 ABox 断言 $\\mathcal{A}_6: x_2 : \\mathsf{TemperatureSensor}$ 和 TBox 公理 $1$, $\\mathsf{TemperatureSensor} \\sqsubseteq \\mathsf{Sensor}$，我们得出结论 $x_2 : \\mathsf{Sensor}$。\n- 根据 ABox 断言 $\\mathcal{A}_5: \\mathsf{hasRole}(x_2, r_2)$ 和 $\\mathcal{A}_4: r_2 : \\mathsf{ActRole}$，我们推断出 $x_2 : \\exists \\mathsf{hasRole}.\\mathsf{ActRole}$。\n- 根据 TBox 公理 $7$, $\\exists \\mathsf{hasRole}.\\mathsf{ActRole} \\sqsubseteq \\mathsf{Actuator}$，我们得出结论 $x_2 : \\mathsf{Actuator}$。\n由于 $x_2$ 同时是 $\\mathsf{Sensor}$ 和 $\\mathsf{Actuator}$ 的实例，这违反了公理 $5$。个体 $x_2$ 也是矛盾的来源之一。\n\n对于个体 $x_3$：\n- 根据 ABox 断言 $\\mathcal{A}_7: \\mathsf{hasRole}(x_3, r_1)$ 和 $\\mathcal{A}_2: r_1 : \\mathsf{SenseRole}$，我们推断出 $x_3 : \\exists \\mathsf{hasRole}.\\mathsf{SenseRole}$。\n- 根据 TBox 公理 $6$, $\\exists \\mathsf{hasRole}.\\mathsf{SenseRole} \\sqsubseteq \\mathsf{Sensor}$，我们得出结论 $x_3 : \\mathsf{Sensor}$。\n- 根据 ABox 断言 $\\mathcal{A}_8: x_3 : \\mathsf{ValveActuator}$ 和 TBox 公理 $2$, $\\mathsf{ValveActuator} \\sqsubseteq \\mathsf{Actuator}$，我们得出结论 $x_3 : \\mathsf{Actuator}$。\n由于 $x_3$ 同时是 $\\mathsf{Sensor}$ 和 $\\mathsf{Actuator}$ 的实例，这违反了公理 $5$。个体 $x_3$ 也是矛盾的来源之一。\n\n**第 2 步：识别最小原因（冲突集）**\n\n为了仅通过删除 ABox 断言来修复本体，我们必须识别导致每个不一致性的最小 ABox 断言集。这些被称为冲突集（或理由）。\n\n- 对于 $x_1$，不一致性源于导致 $x_1:\\mathsf{Sensor}$ 和 $x_1:\\mathsf{Actuator}$ 的断言组合。最小 ABox 断言集是 $\\{\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3, \\mathcal{A}_4\\}$。设其为冲突集 $C_1$。从 $C_1$ 中移除任何单个断言都会解决 $x_1$ 的矛盾。\n\n- 对于 $x_2$，不一致性是由导致 $x_2:\\mathsf{Sensor}$ 和 $x_2:\\mathsf{Actuator}$ 的断言引起的。最小集是 $\\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\}$。设其为冲突集 $C_2$。\n\n- 对于 $x_3$，不一致性是由导致 $x_3:\\mathsf{Sensor}$ 和 $x_3:\\mathsf{Actuator}$ 的断言引起的。最小集是 $\\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\}$。设其为冲突集 $C_3$。\n\n所以我们有以下冲突集集合：\n$C_1 = \\{\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3, \\mathcal{A}_4\\}$\n$C_2 = \\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\}$\n$C_3 = \\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\}$\n\n**第 3 步：计算最小修复集**\n\n修复集是一个 ABox 断言集合，移除该集合可以使本体变得一致。为了解决所有三个矛盾，修复集必须“命中”每个冲突集。也就是说，一个修复集 $R$ 必须与 $C_1$、$C_2$ 和 $C_3$ 中的每一个都有非空交集。这样的集合被称为集合 $\\{C_1, C_2, C_3\\}$ 的命中集。\n\n问题将“最小 ABox 删除修复集”定义为“包含最小的且具有最小可能基数”。根据定义，具有最小可能基数的命中集是一个最小命中集。任何最小命中集也是包含最小的。因此，我们需要找到 $\\{C_1, C_2, C_3\\}$ 的最小基数命中集的数量。\n\n首先，我们确定最小基数。\n- 基数为 $1$：是否存在一个能命中所有三个集合的单一断言？这需要一个元素存在于交集 $C_1 \\cap C_2 \\cap C_3 = \\{\\mathcal{A}_1, \\mathcal{A}_2, \\mathcal{A}_3, \\mathcal{A}_4\\} \\cap \\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\} \\cap \\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\} = \\emptyset$ 中。由于交集为空，没有单个断言可以修复所有三个不一致性。最小基数大于 $1$。\n\n- 基数为 $2$：我们能找到大小为 $2$ 的命中集吗？如果集合 $\\{\\alpha, \\beta\\}$ 与 $C_1$、$C_2$ 和 $C_3$ 相交，则它是一个命中集。如果一个元素命中两个冲突集，而另一个元素命中第三个，这是可能的。让我们检查冲突集的两两交集：\n  - $C_1 \\cap C_2 = \\{\\mathcal{A}_4\\}$。如果我们在修复集中选择 $\\mathcal{A}_4$，我们就命中了 $C_1$ 和 $C_2$。为了命中剩下的集合 $C_3 = \\{\\mathcal{A}_2, \\mathcal{A}_7, \\mathcal{A}_8\\}$，我们可以添加它的任何一个元素。这给了我们三个可能的大小为 $2$ 的修复集：$\\{\\mathcal{A}_4, \\mathcal{A}_2\\}$、$\\{\\mathcal{A}_4, \\mathcal{A}_7\\}$ 和 $\\{\\mathcal{A}_4, \\mathcal{A}_8\\}$。\n  - $C_1 \\cap C_3 = \\{\\mathcal{A}_2\\}$。如果我们选择 $\\mathcal{A}_2$，我们就命中了 $C_1$ 和 $C_3$。为了命中剩下的集合 $C_2 = \\{\\mathcal{A}_4, \\mathcal{A}_5, \\mathcal{A}_6\\}$，我们可以添加它的任何一个元素。这给了我们三个可能的大小为 $2$ 的修复集：$\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$、$\\{\\mathcal{A}_2, \\mathcal{A}_5\\}$ 和 $\\{\\mathcal{A}_2, \\mathcal{A}_6\\}$。\n  - $C_2 \\cap C_3 = \\emptyset$。没有单个元素能同时命中 $C_2$ 和 $C_3$。\n\n由于我们已经找到了大小为 $2$ 的修复集，因此修复集的最小可能基数为 $2$。\n\n**第 4 步：计算不同的最小修复集**\n\n我们现在列出所有基数为 $2$ 的不同修复集：\n从对 $C_1 \\cap C_2$ 的分析中：\n$1.$ $\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$\n$2.$ $\\{\\mathcal{A_4}, \\mathcal{A}_7\\}$\n$3.$ $\\{\\mathcal{A}_4, \\mathcal{A}_8\\}$\n\n从对 $C_1 \\cap C_3$ 的分析中：\n$4.$ $\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$ (这与集合 $1$ 相同)\n$5.$ $\\{\\mathcal{A}_2, \\mathcal{A}_5\\}$\n$6.$ $\\{\\mathcal{A}_2, \\mathcal{A}_6\\}$\n\n合并这些列表并去除重复项，我们得到以下不同的最小修复集：\n$1.$ $\\{\\mathcal{A}_2, \\mathcal{A}_4\\}$\n$2.$ $\\{\\mathcal{A}_4, \\mathcal{A}_7\\}$\n$3.$ $\\{\\mathcal{A}_4, \\mathcal{A}_8\\}$\n$4.$ $\\{\\mathcal{A}_2, \\mathcal{A}_5\\}$\n$5.$ $\\{\\mathcal{A}_2, \\mathcal{A}_6\\}$\n\n共有 $5$ 个不同的最小 ABox 删除修复集。每个集合的基数都是 $2$，这是可能的最小值，并且是包含最小的。因此，数量 $N$ 是 $5$。",
            "answer": "$$\\boxed{5}$$"
        }
    ]
}