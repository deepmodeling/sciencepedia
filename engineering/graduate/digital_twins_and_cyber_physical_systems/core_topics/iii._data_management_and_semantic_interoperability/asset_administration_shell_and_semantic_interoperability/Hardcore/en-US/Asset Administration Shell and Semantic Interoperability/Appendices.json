{
    "hands_on_practices": [
        {
            "introduction": "Before semantic interoperability can be achieved, the foundational structure of the digital representation must be correct and verifiable. This first practice focuses on the essential task of translating the formal rules of the Asset Administration Shell (AAS) metamodel into a concrete, valid instance. By building a programmatic validator , you will engage directly with core principles like identifier uniqueness, referable naming conventions, and the hierarchical relationship between an AAS, its Submodels, and Properties, establishing a solid base for all subsequent applications.",
            "id": "4206044",
            "problem": "You are to construct and validate a minimal yet structurally coherent instance of an Asset Administration Shell (AAS) for a single physical asset, focusing on semantic interoperability through explicit semantic identifiers. The objective is to formalize the construction and validation via first principles of identity, referability, and semantic referencing, and then implement these rules as a program. The final output must be a single-line list of booleans representing the validity of each test case.\n\nFundamental base and core definitions:\n- An Asset Administration Shell (AAS) is a digital representation of an asset capturing identification, administrative information, and submodels. In the simplified minimal instance, the AAS is modeled as a pair of identifiable elements: the AAS itself and one Submodel. Only the AAS and Submodel are identifiable elements having globally unique identifiers. A SubmodelElement, specifically a Property, is referable but not identifiable.\n- Global uniqueness is ensured by identifiers that are either Universally Unique Identifiers (UUID) or Internationalized Resource Identifiers (IRI). For computational purposes, an IRI of the form $\\text{urn:uuid:}\\langle\\text{uuid}\\rangle$ and web IRIs of the form $\\text{http}://\\ldots$ or $\\text{https}://\\ldots$ are considered valid.\n- Semantic interoperability requires each Property to carry a $\\text{semanticId}$ referencing a globally resolvable concept reference (modeled here as an IRI).\n\nMinimal JSON representation to construct:\n- The instance is a JSON object with two top-level members:\n  - $\\text{assetAdministrationShell}$: an object with fields $\\text{id}$, $\\text{idShort}$, $\\text{administration}$, $\\text{assetInformation}$, and $\\text{submodels}$.\n  - $\\text{submodel}$: an object with fields $\\text{id}$, $\\text{idShort}$, and $\\text{submodelElements}$.\n- Field-level structure:\n  - $\\text{assetAdministrationShell.id}$: a globally unique identifier (IRI or URN with UUID).\n  - $\\text{assetAdministrationShell.idShort}$: a referable name satisfying naming constraints.\n  - $\\text{assetAdministrationShell.administration}$: an object containing $\\text{version}$ and $\\text{revision}$ as strings.\n  - $\\text{assetInformation.globalAssetId}$: a globally unique identifier of the underlying physical asset.\n  - $\\text{assetAdministrationShell.submodels}$: a list containing a single reference object with the field $\\text{id}$ equal to $\\text{submodel.id}$.\n  - $\\text{submodel.id}$: a globally unique identifier distinct from $\\text{assetAdministrationShell.id}$ and $\\text{assetInformation.globalAssetId}$.\n  - $\\text{submodel.idShort}$: a referable name satisfying naming constraints.\n  - $\\text{submodel.submodelElements}$: a list containing exactly $3$ Property objects.\n  - Each Property object contains $\\text{modelType} = \\text{\"Property\"}$, $\\text{idShort}$, $\\text{semanticId}$, $\\text{valueType}$, and $\\text{value}$.\n\nNaming and typing constraints defined from first principles:\n- Referable naming for $\\text{idShort}$:\n  - Let $\\Sigma_{\\text{alnum}}$ be the set of alphanumeric characters and $\\Sigma_{\\_}$ be the underscore. The allowed alphabet is $\\Sigma = \\Sigma_{\\text{alnum}} \\cup \\{\\_\\}$.\n  - The name must start with a letter. Formally, for a string $s$ with length $\\ell$, $s \\in \\Sigma^\\ell$, $1 \\leq \\ell \\leq 128$, and the first character $s_1 \\in \\{A,\\ldots,Z,a,\\ldots,z\\}$.\n  - All subsequent characters $s_i \\in \\Sigma$ for $i \\in \\{2,\\ldots,\\ell\\}$.\n- Global identifier validity:\n  - An identifier $u$ is valid if it is either a URN of the form $\\text{urn:uuid:}\\langle\\text{uuid}\\rangle$ where $\\langle\\text{uuid}\\rangle$ matches the canonical UUID version $4$ pattern, or a web IRI starting with $\\text{http}://$ or $\\text{https}://$ followed by a non-empty path.\n- Cardinality constraints:\n  - The list $\\text{submodel.submodelElements}$ must have length exactly $3$: $|\\text{submodel.submodelElements}| = 3$.\n  - The list $\\text{assetAdministrationShell.submodels}$ must have length exactly $1$: $|\\text{assetAdministrationShell.submodels}| = 1$.\n- Administrative information constraints:\n  - Both $\\text{version}$ and $\\text{revision}$ must exist as non-empty strings, each consisting of digits only. Formally, if $\\text{version} = v$ and $\\text{revision} = r$, then $v \\in \\{0,1,2,\\ldots\\}$ and $r \\in \\{0,1,2,\\ldots\\}$ when interpreted as strings of digits.\n- Property typing and semantics:\n  - Each Property must have a $\\text{valueType} \\in \\{\\text{\"string\"}, \\text{\"integer\"}, \\text{\"double\"}, \\text{\"boolean\"}\\}$.\n  - Its $\\text{value}$ must be of the corresponding primitive type: string, integer, floating-point (for $\\text{\"double\"}$), or boolean, respectively. For $\\text{\"double\"}$, the value may be a real number; in practice, this is a floating-point representation.\n  - Each Property must have a $\\text{semanticId}$ that is a valid IRI (either $\\text{http}/\\text{https}$ or $\\text{urn:uuid}$).\n- Uniqueness constraints:\n  - The identifiers $\\text{assetAdministrationShell.id}$, $\\text{submodel.id}$, and $\\text{assetInformation.globalAssetId}$ must be pairwise distinct.\n  - The $\\text{idShort}$ values within the set of Properties in the Submodel must be pairwise distinct.\n\nProgram requirements:\n- Implement a program that, for each test case, constructs a minimal AAS instance JSON object as described, then validates it against the constraints above. The program must return a boolean for each test case indicating validity.\n- The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\text{[result1,result2,\\ldots]}$).\n\nTest suite:\n- There are $6$ test cases. Each case requires constructing one AAS instance with one Submodel and exactly $3$ Properties.\n- The parameters for each test case are as follows:\n  1. Happy path (expected validity: true):\n     - $\\text{AAS.idShort} = \\text{\"AAS\\_Drive\"}$, $\\text{Submodel.idShort} = \\text{\"DriveSM\"}$, $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$.\n     - Property $1$: $\\text{idShort} = \\text{\"nominalTorque\"}$, $\\text{valueType} = \\text{\"integer\"}$, $\\text{value} = 120$, $\\text{semanticId} = \\text{\"http://example.org/cd#nominalTorque\"}$.\n     - Property $2$: $\\text{idShort} = \\text{\"ratedSpeed\"}$, $\\text{valueType} = \\text{\"double\"}$, $\\text{value} = 1500.0$, $\\text{semanticId} = \\text{\"http://example.org/cd#ratedSpeed\"}$.\n     - Property $3$: $\\text{idShort} = \\text{\"manufacturerName\"}$, $\\text{valueType} = \\text{\"string\"}$, $\\text{value} = \\text{\"Acme Motors\"}$, $\\text{semanticId} = \\text{\"http://example.org/cd#manufacturerName\"}$.\n     - All identifiers ($\\text{AAS.id}$, $\\text{Submodel.id}$, $\\text{globalAssetId}$) are distinct valid UUID URNs.\n  2. Boundary naming length (expected validity: true):\n     - $\\text{Submodel.idShort} = \\text{\"DriveSM\"}$, $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$.\n     - Property $1$: $\\text{idShort}$ is a string of length $128$, starting with a letter, e.g., $\\text{\"A\"}$ followed by $127$ underscores or alphanumerics, with $\\text{valueType} = \\text{\"string\"}$, $\\text{value} = \\text{\"X\"}$, $\\text{semanticId} = \\text{\"http://example.org/cd#longId\"}$.\n     - Properties $2$ and $3$ use valid short names and semantics similar to Case $1$.\n     - All identifiers are distinct valid UUID URNs.\n  3. Invalid Submodel referable name (expected validity: false):\n     - $\\text{Submodel.idShort} = \\text{\"1SubmodelX\"}$ (violates the starting-letter constraint), $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$.\n     - Properties are valid as in Case $1$.\n     - All identifiers are distinct valid UUID URNs.\n  4. Duplicate global identifiers (expected validity: false):\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$.\n     - Force $\\text{Submodel.id} = \\text{AAS.id}$ (violates pairwise distinctness), with Properties valid as in Case $1$.\n     - $\\text{globalAssetId}$ is a distinct valid UUID URN.\n  5. Missing administrative field (expected validity: false):\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}\\}$ (missing $\\text{revision}$).\n     - Other fields match Case $1$ and are otherwise valid.\n  6. Missing Property semantic identifier (expected validity: false):\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$.\n     - Properties $1$ and $2$ valid as in Case $1$; Property $3$ has a missing $\\text{semanticId}$ (e.g., $\\text{semanticId} = \\text{null}$ or omitted).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\text{[true,false,true,\\ldots]}$). The elements must be booleans in lower case.",
            "solution": "The problem statement is assessed to be **valid**. It is scientifically grounded in the domain of digital twins and the Asset Administration Shell (AAS) specification, well-posed with clear and formalizable constraints, and objective in its language. The task is to construct a validator for a minimal AAS instance according to a precise set of rules and evaluate it against a given test suite.\n\nThe solution is implemented as a Python program centered around a validator class, `AASValidator`. This class encapsulates all the logic required to verify an AAS instance against the stipulated rules. The design of the validator is based on a hierarchical, principle-based approach, ensuring each constraint from the problem statement is methodically checked.\n\nThe validation process is decomposed into several logical steps, each handled by a dedicated method within the `AASValidator` class. A top-level `validate` method orchestrates the entire process, returning `True` only if all checks pass. To robustly handle malformed inputs, such as missing keys or incorrect data structures, the main validation logic is enclosed in a `try...except` block; any structural error will cause an exception and result in an immediate `False` return, indicating an invalid instance.\n\nThe validation rules are categorized and implemented as follows:\n\n1.  **Structural and Cardinality Validation**: The first step is to verify the fundamental structure of the JSON object. The validator checks for the existence and correct types (i.e., dictionary, list) of all required keys at every level: the root object (`assetAdministrationShell`, `submodel`), the AAS object (`id`, `idShort`, `administration`, `assetInformation`, `submodels`), the Submodel object (`id`, `idShort`, `submodelElements`), and so on. Cardinality constraints are also enforced here, specifically ensuring that the `submodels` list contains exactly one element ($|\\text{assetAdministrationShell.submodels}| = 1$) and the `submodelElements` list contains exactly three elements ($|\\text{submodel.submodelElements}| = 3$).\n\n2.  **Identifier Syntax Validation**: Two types of identifiers are defined: referable names (`idShort`) and globally unique identifiers.\n    -   **`idShort` Validation**: A helper method, `_is_valid_idshort`, implements the naming constraint. For a given `idShort` string $s$ of length $\\ell$, it verifies that $1 \\le \\ell \\le 128$, the first character $s_1$ is an ASCII letter, and all subsequent characters belong to the set of alphanumeric characters or the underscore. This is efficiently implemented using a regular expression: `^[a-zA-Z][a-zA-Z0-9_]{0,127}$`.\n    -   **Global Identifier Validation**: Another helper, `_is_valid_global_id`, validates globally unique identifiers. It checks if an identifier string conforms to one of two patterns: a URN for a version $4$ UUID (e.g., `urn:uuid:...`), validated with a specific regular expression, or a web IRI. An IRI is considered valid if it starts with `http://` or `https://` and is followed by a non-empty authority and path, which is robustly checked using Python's standard `urllib.parse.urlparse` function. This check is applied to `assetAdministrationShell.id`, `submodel.id`, `assetInformation.globalAssetId`, and every `semanticId` of each `Property`.\n\n3.  **Relational Constraint Validation**: This step ensures the integrity of relationships between different parts of the AAS instance.\n    -   **Identifier Uniqueness**: The global identifiers for the AAS, the Submodel, and the physical Asset (`assetAdministrationShell.id`, `submodel.id`, `assetInformation.globalAssetId`) must be pairwise distinct. This is verified by collecting them into a set and checking if the set's size is equal to $3$.\n    -   **`idShort` Uniqueness**: Within the list of `submodelElements`, all `Property` elements must have unique `idShort` values. This is checked by collecting all property `idShort`s into a list and comparing its length to the length of a set constructed from that list.\n    -   **Reference Integrity**: The reference from the AAS to its Submodel must be correct. The validator confirms that the `id` field within the single object in the `assetAdministrationShell.submodels` list is identical to the `submodel.id`.\n\n4.  **Semantic and Content Validation**: This final stage inspects the content and typing of specific fields.\n    -   **Administrative Information**: The `administration` object is checked to ensure it contains both a `version` and a `revision` key, and that their values are non-empty strings composed exclusively of digits.\n    -   **Property-Level Validation**: Each of the three `Property` objects in `submodelElements` is meticulously checked. The `modelType` must be the string `\"Property\"`. The `semanticId` must be a valid global identifier. The `valueType` must be one of the allowed strings (`\"string\"`, `\"integer\"`, `\"double\"`, `\"boolean\"`). Crucially, the type of the `value` field must correspond to its `valueType`. For instance, if `valueType` is `\"integer\"`, the `value` must be a Python `int` (and not a `bool`, as `bool` is a subclass of `int`).\n\nTo execute the test suite, a `build_instance` function is defined to programmatically construct the AAS JSON structure for each test case. The main `solve` function iterates through the $6$ test cases, building each instance, passing it to the `AASValidator`, and collecting the boolean results. The final list of booleans is then formatted into the required single-line string output.",
            "answer": "```python\nimport re\nimport uuid\nfrom urllib.parse import urlparse\n\nclass AASValidator:\n    \"\"\"\n    Validates a minimal AAS instance against a set of formal rules.\n    \"\"\"\n    def __init__(self):\n        self.uuid_urn_pattern = re.compile(\n            r'^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',\n            re.IGNORECASE\n        )\n        self.idshort_pattern = re.compile(r'^[a-zA-Z][a-zA-Z0-9_]{0,127}$')\n\n    def _is_valid_idshort(self, name: str) -> bool:\n        \"\"\"Validates a referable name (idShort).\"\"\"\n        if not isinstance(name, str):\n            return False\n        return bool(self.idshort_pattern.match(name))\n\n    def _is_valid_global_id(self, identifier: str) -> bool:\n        \"\"\"Validates a globally unique identifier (IRI or URN).\"\"\"\n        if not isinstance(identifier, str):\n            return False\n        \n        # Check for UUID URN\n        if self.uuid_urn_pattern.match(identifier):\n            return True\n        \n        # Check for Web IRI with non-empty path\n        if identifier.startswith(('http://', 'https://')):\n            try:\n                parsed = urlparse(identifier)\n                # Must have scheme, network location, and a non-empty path\n                if parsed.scheme and parsed.netloc and parsed.path:\n                    return True\n            except (ValueError, TypeError):\n                return False\n        \n        return False\n\n    def _validate_administration(self, admin: dict) -> bool:\n        \"\"\"Validates the administration object.\"\"\"\n        if not isinstance(admin, dict): return False\n        version = admin.get('version')\n        revision = admin.get('revision')\n        \n        if not (version and isinstance(version, str) and version.isdigit()):\n            return False\n        if not (revision and isinstance(revision, str) and revision.isdigit()):\n            return False\n        return True\n\n    def _validate_properties(self, props: list) -> bool:\n        \"\"\"Validates the list of submodel elements (Properties).\"\"\"\n        if not isinstance(props, list) or len(props) != 3:\n            return False\n        \n        id_shorts = []\n        for prop in props:\n            if not isinstance(prop, dict): return False\n            \n            if prop.get('modelType') != 'Property': return False\n            \n            id_short = prop.get('idShort')\n            if not self._is_valid_idshort(id_short): return False\n            id_shorts.append(id_short)\n            \n            if not self._is_valid_global_id(prop.get('semanticId')): return False\n            \n            value_type = prop.get('valueType')\n            value = prop.get('value')\n            \n            type_map = {\n                'string': str, 'integer': int, 'double': float, 'boolean': bool\n            }\n            if value_type not in type_map: return False\n            \n            expected_type = type_map[value_type]\n            \n            # The value could be missing. A missing value is not of the expected type.\n            if value is None and expected_type is not type(None):\n                # A special check is needed if 'None' is a valid value, but it is not here.\n                # Here we handle missing 'value' key, which get() returns as None.\n                if 'value' not in prop: return False\n\n            if not isinstance(value, expected_type): return False\n            if value_type == 'integer' and isinstance(value, bool): return False\n\n        if len(set(id_shorts)) != len(id_shorts): return False\n        \n        return True\n\n    def validate(self, instance: dict) -> bool:\n        \"\"\"Performs a full validation of the AAS instance.\"\"\"\n        try:\n            # 1. Root structure and key existence\n            aas = instance['assetAdministrationShell']\n            sm = instance['submodel']\n            \n            aas_id = aas['id']\n            aas_idshort = aas['idShort']\n            aas_admin = aas['administration']\n            aas_asset_info = aas['assetInformation']\n            aas_submodels = aas['submodels']\n            global_asset_id = aas_asset_info['globalAssetId']\n            \n            sm_id = sm['id']\n            sm_idshort = sm['idShort']\n            sm_elements = sm['submodelElements']\n            \n            # 2. Global Identifier validity and uniqueness\n            if not all(map(self._is_valid_global_id, [aas_id, sm_id, global_asset_id])):\n                return False\n            if len({aas_id, sm_id, global_asset_id}) != 3:\n                return False\n\n            # 3. idShort validity\n            if not self._is_valid_idshort(aas_idshort) or not self._is_valid_idshort(sm_idshort):\n                return False\n                \n            # 4. Administration info\n            if not self._validate_administration(aas_admin):\n                return False\n            \n            # 5. Cardinality and References\n            if not isinstance(aas_submodels, list) or len(aas_submodels) != 1:\n                return False\n            if aas_submodels[0].get('id') != sm_id:\n                return False\n                \n            # 6. Properties validation (includes own cardinality check)\n            if not self._validate_properties(sm_elements):\n                return False\n\n        except (KeyError, TypeError, IndexError):\n            return False\n            \n        return True\n\ndef build_instance(\n    aas_idshort=\"AAS_Drive\",\n    sm_idshort=\"DriveSM\",\n    admin_info={'version': '1', 'revision': '0'},\n    aas_id=None,\n    sm_id=None,\n    asset_id=None,\n    properties=None\n):\n    \"\"\"Builds a test AAS instance dictionary.\"\"\"\n    aas_id = aas_id or f\"urn:uuid:{uuid.uuid4()}\"\n    sm_id = sm_id or f\"urn:uuid:{uuid.uuid4()}\"\n    asset_id = asset_id or f\"urn:uuid:{uuid.uuid4()}\"\n\n    if properties is None:\n        properties = [\n            {'modelType': 'Property', 'idShort': 'nominalTorque', 'valueType': 'integer', 'value': 120, 'semanticId': 'http://example.org/cd#nominalTorque'},\n            {'modelType': 'Property', 'idShort': 'ratedSpeed', 'valueType': 'double', 'value': 1500.0, 'semanticId': 'http://example.org/cd#ratedSpeed'},\n            {'modelType': 'Property', 'idShort': 'manufacturerName', 'valueType': 'string', 'value': 'Acme Motors', 'semanticId': 'http://example.org/cd#manufacturerName'}\n        ]\n\n    return {\n        'assetAdministrationShell': {\n            'id': aas_id, 'idShort': aas_idshort, 'administration': admin_info,\n            'assetInformation': {'globalAssetId': asset_id},\n            'submodels': [{'id': sm_id}]\n        },\n        'submodel': {\n            'id': sm_id, 'idShort': sm_idshort, 'submodelElements': properties\n        }\n    }\n\ndef solve():\n    \"\"\"Constructs test cases, validates them, and prints results.\"\"\"\n    test_cases = []\n\n    # Case 1: Happy path\n    test_cases.append(build_instance())\n\n    # Case 2: Boundary naming length\n    props_c2 = [p.copy() for p in build_instance()['submodel']['submodelElements']]\n    props_c2[0] = {'modelType': 'Property', 'idShort': 'A' + '_' * 127, 'valueType': 'string', 'value': 'X', 'semanticId': 'http://example.org/cd#longId'}\n    test_cases.append(build_instance(properties=props_c2))\n\n    # Case 3: Invalid Submodel referable name\n    test_cases.append(build_instance(sm_idshort=\"1SubmodelX\"))\n\n    # Case 4: Duplicate global identifiers\n    dup_id = f\"urn:uuid:{uuid.uuid4()}\"\n    test_cases.append(build_instance(aas_id=dup_id, sm_id=dup_id))\n\n    # Case 5: Missing administrative field\n    test_cases.append(build_instance(admin_info={'version': '1'}))\n\n    # Case 6: Missing Property semantic identifier\n    props_c6 = [p.copy() for p in build_instance()['submodel']['submodelElements']]\n    props_c6[2]['semanticId'] = None\n    test_cases.append(build_instance(properties=props_c6))\n\n    validator = AASValidator()\n    results = [validator.validate(case) for case in test_cases]\n\n    print(f\"[{','.join([str(r).lower() for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A structurally valid AAS is merely the starting point; its true value is realized when its machine-readable semantics are used to derive actionable intelligence from raw data. This exercise demonstrates the tangible benefits of semantic interoperability by tasking you with a common engineering scenario: fusing heterogeneous sensor data . You will apply the explicit unit conversion information, a key feature of a semantically described Submodel, to normalize measurements to a common physical reference (SI units) and rigorously quantify the propagation of uncertainty.",
            "id": "4205975",
            "problem": "A manufacturing cell is represented by a Digital Twin whose Asset Administration Shell (AAS) exposes three Property elements with explicit semantic descriptions for unit and conversion to the International System of Units (SI). Each Property provides a raw sensor output with a one-standard-deviation uncertainty and an associated linear conversion model to the SI base units. The AAS declares the following semantics and values:\n- Temperature Property: raw value $x_T = 95.7\\,^{\\circ}\\text{F}$ with standard uncertainty $\\sigma_{x_T} = 0.35\\,^{\\circ}\\text{F}$. The ConceptDescription specifies a linear conversion to kelvin (SI) of the form $u_T = a_T x_T + b_T$ with $a_T = \\frac{5}{9}$ and $b_T = 273.15 - \\frac{5}{9}\\cdot 32$.\n- Pressure Property: raw value $x_P = 1.842\\,\\text{bar}$ with standard uncertainty $\\sigma_{x_P} = 0.008\\,\\text{bar}$. The ConceptDescription specifies the SI conversion $u_P = a_P x_P + b_P$ with $a_P = 10^{5}$ and $b_P = 0$, yielding pascal (SI).\n- Acceleration Property: raw value $x_A = 0.0365\\,\\text{g}$ with standard uncertainty $\\sigma_{x_A} = 0.0018\\,\\text{g}$. The ConceptDescription specifies the SI conversion $u_A = a_A x_A + b_A$ with $a_A = 9.80665$ and $b_A = 0$, yielding $\\mathrm{m \\cdot s^{-2}}$ (SI).\n\nThe AAS also defines a virtual, dimensionless aggregate indicator $y$ for semantic interoperability across systems, computed from the SI-normalized values via\n$$\ny = w_T \\frac{u_T - T_0}{T_s} + w_P \\frac{u_P}{P_s} + w_A \\frac{u_A}{A_s},\n$$\nwhere $w_T = 0.4$, $w_P = 0.35$, $w_A = 0.25$, $T_0 = 293.15\\,\\mathrm{K}$, $T_s = 300\\,\\mathrm{K}$, $P_s = 2.5 \\times 10^{5}\\,\\mathrm{Pa}$, and $A_s = 1\\,\\mathrm{m \\cdot s^{-2}}$.\n\nStarting from first principles of unit conversion and uncertainty propagation for linear models, do the following:\n1. Convert each raw sensor output to its SI value $u_T$, $u_P$, and $u_A$, and compute their standard uncertainties $\\sigma_{u_T}$, $\\sigma_{u_P}$, and $\\sigma_{u_A}$, respectively.\n2. Under the assumption that the raw sensor uncertainties are mutually independent and that the linear conversion models and the aggregate indicator definition are exact, derive the standard uncertainty $\\sigma_y$ of $y$.\n\nReport only the final value of the standard uncertainty $\\sigma_y$ of $y$ as a single real number, dimensionless. Round your answer to four significant figures.",
            "solution": "The problem is assessed to be valid as it is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of data and definitions, requiring the application of standard principles of unit conversion and uncertainty propagation.\n\nThe task is to compute the standard uncertainty, $\\sigma_y$, of a dimensionless aggregate indicator, $y$. This requires a two-step process: first, converting each raw sensor measurement to its corresponding SI value and propagating its uncertainty; second, combining these propagated uncertainties to find the final uncertainty of $y$.\n\nThe fundamental principle for propagating uncertainty for a function $f(z_1, z_2, \\dots, z_n)$ of independent variables $z_i$ with standard uncertainties $\\sigma_{z_i}$ is given by the formula for the variance $\\sigma_f^2$:\n$$\n\\sigma_f^2 = \\sum_{i=1}^{n} \\left( \\frac{\\partial f}{\\partial z_i} \\right)^2 \\sigma_{z_i}^2\n$$\nFor a linear transformation of a single variable, $u = ax + b$, where $a$ and $b$ are exact constants, the partial derivative $\\frac{\\partial u}{\\partial x}$ is simply $a$. The uncertainty in $u$, $\\sigma_u$, is therefore related to the uncertainty in $x$, $\\sigma_x$, by:\n$$\n\\sigma_u = |a| \\sigma_x\n$$\n\nWe will now apply these principles to each property.\n\n**Part 1: Conversion and Uncertainty Propagation for Individual Properties**\n\n1.  **Temperature ($T$)**\n    The raw value is $x_T = 95.7\\,^{\\circ}\\text{F}$ with standard uncertainty $\\sigma_{x_T} = 0.35\\,^{\\circ}\\text{F}$. The conversion to the SI unit kelvin ($\\mathrm{K}$) is given by the linear model $u_T = a_T x_T + b_T$, with exact coefficients $a_T = \\frac{5}{9}$ and $b_T = 273.15 - \\frac{5}{9} \\cdot 32$.\n\n    The SI value $u_T$ is:\n    $$\n    u_T = \\frac{5}{9} x_T + 273.15 - \\frac{5}{9} \\cdot 32 = \\frac{5}{9}(x_T - 32) + 273.15\n    $$\n    $$\n    u_T = \\frac{5}{9}(95.7 - 32) + 273.15 = \\frac{5}{9}(63.7) + 273.15 \\approx 35.3889\\,\\mathrm{K} + 273.15\\,\\mathrm{K} = 308.5389\\,\\mathrm{K}\n    $$\n    The standard uncertainty $\\sigma_{u_T}$ is calculated by propagating $\\sigma_{x_T}$ through the linear model:\n    $$\n    \\sigma_{u_T} = |a_T| \\sigma_{x_T} = \\frac{5}{9} \\cdot (0.35\\,^{\\circ}\\text{F}) \\approx 0.1944\\,\\mathrm{K}\n    $$\n    We will retain the exact fractional form $\\sigma_{u_T} = \\frac{5}{9} \\cdot \\frac{35}{100} = \\frac{7}{36}\\,\\mathrm{K}$ for intermediate calculations to prevent rounding errors.\n\n2.  **Pressure ($P$)**\n    The raw value is $x_P = 1.842\\,\\text{bar}$ with standard uncertainty $\\sigma_{x_P} = 0.008\\,\\text{bar}$. The conversion to the SI unit pascal ($\\mathrm{Pa}$) is $u_P = a_P x_P + b_P$, with $a_P = 10^5$ and $b_P = 0$.\n\n    The SI value $u_P$ is:\n    $$\n    u_P = 10^5 \\cdot (1.842) = 184200\\,\\mathrm{Pa} = 1.842 \\times 10^5\\,\\mathrm{Pa}\n    $$\n    The standard uncertainty $\\sigma_{u_P}$ is:\n    $$\n    \\sigma_{u_P} = |a_P| \\sigma_{x_P} = 10^5 \\cdot (0.008) = 800\\,\\mathrm{Pa}\n    $$\n\n3.  **Acceleration ($A$)**\n    The raw value is $x_A = 0.0365\\,\\text{g}$ with standard uncertainty $\\sigma_{x_A} = 0.0018\\,\\text{g}$. The conversion to the SI unit $\\mathrm{m \\cdot s^{-2}}$ is $u_A = a_A x_A + b_A$, with $a_A = 9.80665$ and $b_A = 0$.\n\n    The SI value $u_A$ is:\n    $$\n    u_A = 9.80665 \\cdot (0.0365) \\approx 0.35794\\,\\mathrm{m \\cdot s^{-2}}\n    $$\n    The standard uncertainty $\\sigma_{u_A}$ is:\n    $$\n    \\sigma_{u_A} = |a_A| \\sigma_{x_A} = 9.80665 \\cdot (0.0018) \\approx 0.01765\\,\\mathrm{m \\cdot s^{-2}}\n    $$\n\n**Part 2: Uncertainty Propagation for the Aggregate Indicator ($y$)**\n\nThe aggregate indicator $y$ is defined as a linear combination of the SI-converted values $u_T$, $u_P$, and $u_A$:\n$$\ny = w_T \\frac{u_T - T_0}{T_s} + w_P \\frac{u_P}{P_s} + w_A \\frac{u_A}{A_s}\n$$\nThis can be rewritten to highlight the linear dependence on the variables with uncertainty:\n$$\ny = \\left(\\frac{w_T}{T_s}\\right) u_T + \\left(\\frac{w_P}{P_s}\\right) u_P + \\left(\\frac{w_A}{A_s}\\right) u_A - \\frac{w_T T_0}{T_s}\n$$\nThe problem states that all weighting ($w_T, w_P, w_A$) and scaling ($T_0, T_s, P_s, A_s$) factors are exact. The raw sensor uncertainties are mutually independent, which implies that the SI-converted uncertainties ($\\sigma_{u_T}, \\sigma_{u_P}, \\sigma_{u_A}$) are also mutually independent.\n\nThe partial derivatives of $y$ with respect to each variable are:\n$$\n\\frac{\\partial y}{\\partial u_T} = \\frac{w_T}{T_s} \\quad ; \\quad \\frac{\\partial y}{\\partial u_P} = \\frac{w_P}{P_s} \\quad ; \\quad \\frac{\\partial y}{\\partial u_A} = \\frac{w_A}{A_s}\n$$\nThe variance of $y$, $\\sigma_y^2$, is the sum of the squared partial derivatives multiplied by the variances of the corresponding variables:\n$$\n\\sigma_y^2 = \\left(\\frac{w_T}{T_s}\\right)^2 \\sigma_{u_T}^2 + \\left(\\frac{w_P}{P_s}\\right)^2 \\sigma_{u_P}^2 + \\left(\\frac{w_A}{A_s}\\right)^2 \\sigma_{u_A}^2\n$$\nWe now substitute the given and calculated values:\n- $w_T = 0.4$, $T_s = 300\\,\\mathrm{K}$, $\\sigma_{u_T} = \\frac{7}{36}\\,\\mathrm{K}$\n- $w_P = 0.35$, $P_s = 2.5 \\times 10^5\\,\\mathrm{Pa}$, $\\sigma_{u_P} = 800\\,\\mathrm{Pa}$\n- $w_A = 0.25$, $A_s = 1\\,\\mathrm{m \\cdot s^{-2}}$, $\\sigma_{u_A} = 9.80665 \\cdot 0.0018 \\approx 0.01765197\\,\\mathrm{m \\cdot s^{-2}}$\n\nCalculating each term of the sum for $\\sigma_y^2$:\n- Temperature term:\n$$\n\\left(\\frac{0.4}{300}\\right)^2 \\left(\\frac{7}{36}\\right)^2 = \\left(\\frac{1}{750}\\right)^2 \\left(\\frac{49}{1296}\\right) \\approx 6.72148 \\times 10^{-8}\n$$\n- Pressure term:\n$$\n\\left(\\frac{0.35}{2.5 \\times 10^5}\\right)^2 (800)^2 = (1.4 \\times 10^{-6})^2 (6.4 \\times 10^5) = 1.2544 \\times 10^{-6}\n$$\n- Acceleration term:\n$$\n\\left(\\frac{0.25}{1}\\right)^2 (9.80665 \\cdot 0.0018)^2 = (0.25)^2 (0.01765197)^2 \\approx 1.947448 \\times 10^{-5}\n$$\nSumming these terms to find the total variance $\\sigma_y^2$:\n$$\n\\sigma_y^2 \\approx (6.72148 \\times 10^{-8}) + (1.2544 \\times 10^{-6}) + (1.947448 \\times 10^{-5})\n$$\n$$\n\\sigma_y^2 \\approx (0.0672148 \\times 10^{-6}) + (1.2544 \\times 10^{-6}) + (19.47448 \\times 10^{-6})\n$$\n$$\n\\sigma_y^2 \\approx 20.79609 \\times 10^{-6} = 2.079609 \\times 10^{-5}\n$$\nFinally, the standard uncertainty $\\sigma_y$ is the square root of the variance:\n$$\n\\sigma_y = \\sqrt{2.079609 \\times 10^{-5}} \\approx 0.004560273\n$$\nThe problem requires the answer to be rounded to four significant figures. The fifth significant figure is $2$, so we round down.\n$$\n\\sigma_y \\approx 0.004560\n$$\nThe final zero is significant and must be retained. The indicator $y$ is dimensionless, so its uncertainty $\\sigma_y$ is also dimensionless.",
            "answer": "$$\\boxed{0.004560}$$"
        },
        {
            "introduction": "To ensure interoperability at scale, validation must move beyond ad-hoc scripts to a formal, logic-based framework that is both robust and extensible. This advanced practice explores how representing the AAS using Semantic Web standards like the Resource Description Framework (RDF) enables such a framework. By implementing a minimal reasoner based on RDF Schema (RDFS) entailment rules , you will gain a deeper understanding of how formal semantics can be used to automatically infer relationships, check for type consistency, and validate the structural integrity of digital twin models across a distributed ecosystem.",
            "id": "4206006",
            "problem": "You are to construct, reason over, and validate Resource Description Framework (RDF) graphs that model a minimal Asset Administration Shell (AAS) Submodel with Properties connected via semantic identifiers to external Internationalized Resource Identifiers (IRIs). Begin from the formal semantics of RDF and RDF Schema (RDFS), and derive an algorithm that performs minimal RDFS closure necessary for validation. The target of the reasoning is to ensure that the AAS Submodel and its Properties conform to simple structural rules that capture semantic interoperability: correct typing via domains and ranges, transitive propagation of subclass types, and constraints on the presence and form of semantic identifiers. The objective is to produce a single program that builds five test graphs, computes their RDFS closure based on minimal schema axioms, validates each graph against the constraints, and outputs one boolean per test graph in a single line.\n\nFundamental base to use:\n- Resource Description Framework (RDF) defines a graph $G$ as a set of triples $(s, p, o)$, where $s$ is the subject, $p$ is the predicate, and $o$ is the object. The RDF Schema (RDFS) vocabulary includes $ \\text{rdf:type} $, $ \\text{rdfs:subClassOf} $, $ \\text{rdfs:domain} $, and $ \\text{rdfs:range} $.\n- RDF Schema (RDFS) entailment rules include:\n  1. If $(p, \\text{rdfs:domain}, C)$ and $(s, p, o)$ appear in $G$, then $(s, \\text{rdf:type}, C)$ is entailed.\n  2. If $(p, \\text{rdfs:range}, C)$ and $(s, p, o)$ appear in $G$, then $(o, \\text{rdf:type}, C)$ is entailed.\n  3. If $(A, \\text{rdfs:subClassOf}, B)$ and $(B, \\text{rdfs:subClassOf}, D)$ are in $G$, then $(A, \\text{rdfs:subClassOf}, D)$ is entailed (transitivity).\n  4. If $(x, \\text{rdf:type}, A)$ and $(A, \\text{rdfs:subClassOf}, B)$, then $(x, \\text{rdf:type}, B)$ is entailed.\n\nScenario and vocabulary:\n- Asset Administration Shell (AAS) Submodel and Property classes:\n  - $ \\text{aas:Submodel} $, $ \\text{aas:Property} $, $ \\text{aas:Referable} $, $ \\text{rdfs:Resource} $.\n- Properties:\n  - $ \\text{aas:hasProperty} $ with $ \\text{rdfs:domain} = \\text{aas:Submodel} $ and $ \\text{rdfs:range} = \\text{aas:Property} $.\n  - $ \\text{aas:semanticId} $ with $ \\text{rdfs:domain} = \\text{aas:Property} $ and $ \\text{rdfs:range} = \\text{rdfs:Resource} $.\n- Subclass axioms:\n  - $(\\text{aas:Submodel}, \\text{rdfs:subClassOf}, \\text{aas:Referable})$,\n  - $(\\text{aas:Property}, \\text{rdfs:subClassOf}, \\text{aas:Referable})$,\n  - $(\\text{aas:Referable}, \\text{rdfs:subClassOf}, \\text{rdfs:Resource})$.\n\nValidation constraints to check after RDFS closure for each test graph:\n- Constraint $C_1$: For each triple $(s, \\text{aas:hasProperty}, o)$, the closure must entail $(s, \\text{rdf:type}, \\text{aas:Submodel})$ and $(o, \\text{rdf:type}, \\text{aas:Property})$.\n- Constraint $C_2$: For each $o$ that is an object of $ \\text{aas:hasProperty} $ triples, there must exist exactly $1$ triple $(o, \\text{aas:semanticId}, i)$. The $i$ must denote an external IRI of the form beginning with either the scheme \"https://\" or \"http://\".\n- Constraint $C_3$: Disjointness by design of the AAS meta-model: an entity typed as $ \\text{aas:Property} $ must not also be typed as $ \\text{aas:Submodel} $ in the closure.\n\nTest suite:\nConstruct the following five RDF graphs by adding the schema axioms above to each case-specific set of triples. Use the identifiers $ \\text{ex:SM}k $ and $ \\text{ex:P}k $ for $k \\in \\{1,2,3,4,5\\}$.\n\n- Case $1$ (happy path):\n  - $(\\text{ex:SM1}, \\text{aas:hasProperty}, \\text{ex:P1})$,\n  - $(\\text{ex:P1}, \\text{aas:semanticId}, \\text{https://example.org/concepts/temperature})$.\n\n- Case $2$ (missing semantic identifier):\n  - $(\\text{ex:SM2}, \\text{aas:hasProperty}, \\text{ex:P2})$.\n\n- Case $3$ (cardinality violation):\n  - $(\\text{ex:SM3}, \\text{aas:hasProperty}, \\text{ex:P3})$,\n  - $(\\text{ex:P3}, \\text{aas:semanticId}, \\text{https://ex.org/c1})$,\n  - $(\\text{ex:P3}, \\text{aas:semanticId}, \\text{https://ex.org/c2})$.\n\n- Case $4$ (type conflict):\n  - $(\\text{ex:SM4}, \\text{aas:hasProperty}, \\text{ex:P4})$,\n  - $(\\text{ex:P4}, \\text{rdf:type}, \\text{aas:Submodel})$,\n  - $(\\text{ex:P4}, \\text{aas:semanticId}, \\text{https://ex.org/c3})$.\n\n- Case $5$ (non-external IRI):\n  - $(\\text{ex:SM5}, \\text{aas:hasProperty}, \\text{ex:P5})$,\n  - $(\\text{ex:P5}, \\text{aas:semanticId}, \\text{ftp://ex.org/c4})$.\n\nYour program must:\n- Programmatically construct the full graph for each case by adding the shared schema axioms and the case-specific triples.\n- Compute the minimal RDFS closure implied by the rules stated above.\n- Validate constraints $C_1$, $C_2$, and $C_3$ for each case.\n- Produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is a boolean indicating whether the corresponding case passes all validation constraints.\n\nAll outputs are unitless and must be booleans. No angles or percentages are involved. The program must be a complete, runnable script that produces the specified single-line output.",
            "solution": "The problem requires the creation and validation of five Resource Description Framework (RDF) graphs, each modeling a minimal Asset Administration Shell (AAS) Submodel. The process involves two main stages: first, computing the RDFS closure for each graph based on a provided set of entailment rules, and second, validating the resulting complete graph against a set of three structural and semantic constraints.\n\nAn RDF graph $G$ is a set of triples $(s, p, o)$, where $s$ is a subject, $p$ is a predicate (property), and $o$ is an object. The vocabulary and schema for this problem are defined using RDF and RDF Schema (RDFS) terms.\n\n**1. Vocabulary and Schema Definition**\n\nFirst, we establish the vocabulary (the set of terms used for classes and properties) and the schema axioms (triples that define relationships between vocabulary terms). These form the base knowledge, common to all five test cases.\n\nThe vocabulary terms are:\n- Classes: $\\text{aas:Submodel}$, $\\text{aas:Property}$, $\\text{aas:Referable}$, $\\text{rdfs:Resource}$\n- Properties: $\\text{aas:hasProperty}$, $\\text{aas:semanticId}$\n- RDFS terms: $\\text{rdf:type}$, $\\text{rdfs:subClassOf}$, $\\text{rdfs:domain}$, $\\text{rdfs:range}$\n\nThe schema axioms are a set of $7$ triples:\n\\begin{itemize}\n    \\item $(\\text{aas:hasProperty}, \\text{rdfs:domain}, \\text{aas:Submodel})$\n    \\item $(\\text{aas:hasProperty}, \\text{rdfs:range}, \\text{aas:Property})$\n    \\item $(\\text{aas:semanticId}, \\text{rdfs:domain}, \\text{aas:Property})$\n    \\item $(\\text{aas:semanticId}, \\text{rdfs:range}, \\text{rdfs:Resource})$\n    \\item $(\\text{aas:Submodel}, \\text{rdfs:subClassOf}, \\text{aas:Referable})$\n    \\item $(\\text{aas:Property}, \\text{rdfs:subClassOf}, \\text{aas:Referable})$\n    \\item $(\\text{aas:Referable}, \\text{rdfs:subClassOf}, \\text{rdfs:Resource})$\n\\end{itemize}\n\n**2. RDFS Closure Algorithm**\n\nThe core of the reasoning process is to compute the deductive closure of each graph. The closure is the set of all triples that are either explicitly stated or can be inferred by applying the given entailment rules. The provided rules are a subset of standard RDFS entailment. We can implement a forward-chaining algorithm that iteratively applies these rules until no new triples can be inferred. This is known as reaching a fixed point.\n\nThe algorithm proceeds as follows:\nLet $G_{initial}$ be the graph containing the schema axioms plus the triples for a specific test case.\n$1.$ Initialize the closure $G_{closure} \\leftarrow G_{initial}$.\n$2.$ Repeatedly apply the following rules to $G_{closure}$ until no new triples can be added in a full pass:\n    - **Rule 1 (Domain Inference):** For every triple $(p, \\text{rdfs:domain}, C)$ and $(s, p, o)$ in $G_{closure}$, add the triple $(s, \\text{rdf:type}, C)$ to $G_{closure}$.\n    - **Rule 2 (Range Inference):** For every triple $(p, \\text{rdfs:range}, C)$ and $(s, p, o)$ in $G_{closure}$, add the triple $(o, \\text{rdf:type}, C)$ to $G_{closure}$.\n    - **Rule 3 (Subclass Transitivity):** For every pair of triples $(A, \\text{rdfs:subClassOf}, B)$ and $(B, \\text{rdfs:subClassOf}, D)$ in $G_{closure}$, add the triple $(A, \\text{rdfs:subClassOf}, D)$ to $G_{closure}$.\n    - **Rule 4 (Type Propagation):** For every pair of triples $(x, \\text{rdf:type}, A)$ and $(A, \\text{rdfs:subClassOf}, B)$ in $G_{closure}$, add the triple $(x, \\text{rdf:type}, B)$ to $G_{closure}$.\n$3.$ The process terminates when an iteration produces no new triples. The resulting $G_{closure}$ is the deductive closure.\n\n**3. Validation Constraints**\n\nOnce the closure is computed for a graph, it must be validated against three constraints ($C_1, C_2, C_3$).\n\n- **Constraint $C_1$:** This constraint verifies the correct typing of subjects and objects of the $\\text{aas:hasProperty}$ predicate. For each triple $(s, \\text{aas:hasProperty}, o)$ in the graph, we must check if the closure $G_{closure}$ entails both $(s, \\text{rdf:type}, \\text{aas:Submodel})$ and $(o, \\text{rdf:type}, \\text{aas:Property})$. These types are typically inferred via the $\\text{rdfs:domain}$ and $\\text{rdfs:range}$ rules.\n\n- **Constraint $C_2$:** This constraint concerns the `semanticId` of a Property. For each AAS Property $o$ that is an object of an $\\text{aas:hasProperty}$ triple, we must verify two conditions:\n    1.  There must exist exactly one triple of the form $(o, \\text{aas:semanticId}, i)$ in the graph. This is a cardinality constraint.\n    2.  The object $i$ of this triple, which is an Internationalized Resource Identifier (IRI), must be an external one, specifically starting with the scheme `http://` or `https://`.\n\n- **Constraint $C_3$:** This is a disjointness constraint, reflecting a fundamental aspect of the AAS metamodel: an entity cannot be both a Submodel and a Property. We must check that for any entity $x$ in the graph, it is not the case that the closure entails both $(x, \\text{rdf:type}, \\text{aas:Property})$ and $(x, \\text{rdf:type}, \\text{aas:Submodel})$.\n\n**4. Analysis of Test Cases**\n\nThe program will apply this entire process to each of the five test cases. A brief analysis predicts the outcome for each:\n\n- **Case 1 (Happy Path):** All rules and constraints are satisfied. The domain/range rules infer the correct types. The `semanticId` exists with cardinality $1$ and has a valid `https` IRI. No type conflicts exist. This case should be valid.\n- **Case 2 (Missing Semantic Identifier):** A Property, $\\text{ex:P2}$, is declared but lacks an associated $\\text{aas:semanticId}$ triple. This violates the cardinality part of constraint $C_2$. This case should be invalid.\n- **Case 3 (Cardinality Violation):** The Property $\\text{ex:P3}$ has two $\\text{aas:semanticId}$ triples. This violates the \"exactly $1$\" condition of constraint $C_2$. This case should be invalid.\n- **Case 4 (Type Conflict):** The entity $\\text{ex:P4}$ is explicitly typed as $\\text{aas:Submodel}$. The RDFS range rule on $\\text{aas:hasProperty}$ will also infer its type as $\\text{aas:Property}$. The closure will therefore contain both $(\\text{ex:P4}, \\text{rdf:type}, \\text{aas:Submodel})$ and $(\\text{ex:P4}, \\text{rdf:type}, \\text{aas:Property})$, violating constraint $C_3$. This case should be invalid.\n- **Case 5 (Non-external IRI):** The `semanticId` for $\\text{ex:P5}$ is an IRI with the `ftp://` scheme. This is not `http://` or `https://`, violating the IRI format requirement of constraint $C_2$. This case should be invalid.\n\nThe expected output is a list of booleans: `[true, false, false, false, false]`. The final program will implement the described logic to compute and return this result.",
            "answer": "```python\ndef solve():\n    \"\"\"\n    Constructs, reasons over, and validates five RDF graphs modeling an AAS\n    Submodel. The program computes a minimal RDFS closure for each graph\n    and validates it against a set of constraints.\n    \"\"\"\n\n    # --- Vocabulary Definition ---\n    RDF_TYPE = 'rdf:type'\n    RDFS_SUBCLASSOF = 'rdfs:subClassOf'\n    RDFS_DOMAIN = 'rdfs:domain'\n    RDFS_RANGE = 'rdfs:range'\n    RDFS_RESOURCE = 'rdfs:Resource'\n    AAS_SUBMODEL = 'aas:Submodel'\n    AAS_PROPERTY = 'aas:Property'\n    AAS_REFERABLE = 'aas:Referable'\n    AAS_HASPROPERTY = 'aas:hasProperty'\n    AAS_SEMANTICID = 'aas:semanticId'\n\n    # --- Schema Axioms (Common to all test cases) ---\n    schema_axioms = {\n        (AAS_HASPROPERTY, RDFS_DOMAIN, AAS_SUBMODEL),\n        (AAS_HASPROPERTY, RDFS_RANGE, AAS_PROPERTY),\n        (AAS_SEMANTICID, RDFS_DOMAIN, AAS_PROPERTY),\n        (AAS_SEMANTICID, RDFS_RANGE, RDFS_RESOURCE),\n        (AAS_SUBMODEL, RDFS_SUBCLASSOF, AAS_REFERABLE),\n        (AAS_PROPERTY, RDFS_SUBCLASSOF, AAS_REFERABLE),\n        (AAS_REFERABLE, RDFS_SUBCLASSOF, RDFS_RESOURCE),\n    }\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            ('ex:SM1', AAS_HASPROPERTY, 'ex:P1'),\n            ('ex:P1', AAS_SEMANTICID, 'https://example.org/concepts/temperature'),\n        },\n        # Case 2 (missing semantic identifier)\n        {\n            ('ex:SM2', AAS_HASPROPERTY, 'ex:P2'),\n        },\n        # Case 3 (cardinality violation)\n        {\n            ('ex:SM3', AAS_HASPROPERTY, 'ex:P3'),\n            ('ex:P3', AAS_SEMANTICID, 'https://ex.org/c1'),\n            ('ex:P3', AAS_SEMANTICID, 'https://ex.org/c2'),\n        },\n        # Case 4 (type conflict)\n        {\n            ('ex:SM4', AAS_HASPROPERTY, 'ex:P4'),\n            ('ex:P4', RDF_TYPE, AAS_SUBMODEL),\n            ('ex:P4', AAS_SEMANTICID, 'https://ex.org/c3'),\n        },\n        # Case 5 (non-external IRI)\n        {\n            ('ex:SM5', AAS_HASPROPERTY, 'ex:P5'),\n            ('ex:P5', AAS_SEMANTICID, 'ftp://ex.org/c4'),\n        },\n    ]\n\n    def compute_closure(initial_graph):\n        \"\"\"Computes the RDFS closure using a fixed-point iteration.\"\"\"\n        closure = set(initial_graph)\n        while True:\n            newly_added_triples = set()\n            \n            domains = {p: c for p, r, c in closure if r == RDFS_DOMAIN}\n            ranges = {p: c for p, r, c in closure if r == RDFS_RANGE}\n            subclasses = {(a, b) for a, p, b in closure if p == RDFS_SUBCLASSOF}\n            types = {(x, a) for x, p, a in closure if p == RDF_TYPE}\n\n            # Rules 1  2: Domain and Range\n            for s, p, o in closure:\n                if p in domains:\n                    newly_added_triples.add((s, RDF_TYPE, domains[p]))\n                if p in ranges:\n                    newly_added_triples.add((o, RDF_TYPE, ranges[p]))\n            \n            # Rule 3: Subclass Transitivity\n            for a, b1 in subclasses:\n                for b2, d in subclasses:\n                    if b1 == b2:\n                        newly_added_triples.add((a, RDFS_SUBCLASSOF, d))\n            \n            # Rule 4: Type Propagation\n            for x, a1 in types:\n                for a2, b in subclasses:\n                    if a1 == a2:\n                        newly_added_triples.add((x, RDF_TYPE, b))\n            \n            truly_new = newly_added_triples - closure\n            if not truly_new:\n                break\n            closure.update(truly_new)\n        return closure\n\n    def validate_graph(initial_graph, closure):\n        \"\"\"Validates a closure against constraints C1, C2, and C3.\"\"\"\n        # --- Pre-computation for validation ---\n        has_property_triples = [(s, o) for s, p, o in initial_graph if p == AAS_HASPROPERTY]\n        \n        types_in_closure = {}\n        for s, p, o in closure:\n            if p == RDF_TYPE:\n                if s not in types_in_closure:\n                    types_in_closure[s] = set()\n                types_in_closure[s].add(o)\n\n        # --- Constraint C1: Domain and Range of aas:hasProperty ---\n        for s, o in has_property_triples:\n            if AAS_SUBMODEL not in types_in_closure.get(s, set()) or \\\n               AAS_PROPERTY not in types_in_closure.get(o, set()):\n                return False\n\n        # --- Constraint C2: Cardinality and Form of aas:semanticId ---\n        properties_in_use = {o for s, o in has_property_triples}\n        for prop in properties_in_use:\n            semantic_id_triples = [t for t in initial_graph if t[0] == prop and t[1] == AAS_SEMANTICID]\n            if len(semantic_id_triples) != 1:\n                return False\n            \n            iri = semantic_id_triples[0][2]\n            if not isinstance(iri, str) or not (iri.startswith('http://') or iri.startswith('https://')):\n                return False\n        \n        # --- Constraint C3: Disjointness of Property and Submodel ---\n        for entity_types in types_in_closure.values():\n            if AAS_PROPERTY in entity_types and AAS_SUBMODEL in entity_types:\n                return False\n\n        return True\n\n    results = []\n    for case_triples in test_cases:\n        initial_graph = schema_axioms.union(case_triples)\n        closure = compute_closure(initial_graph)\n        is_valid = validate_graph(initial_graph, closure)\n        results.append(is_valid)\n    \n    # Format output as a list of lowercase booleans\n    print(f\"[{','.join([str(r).lower() for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}