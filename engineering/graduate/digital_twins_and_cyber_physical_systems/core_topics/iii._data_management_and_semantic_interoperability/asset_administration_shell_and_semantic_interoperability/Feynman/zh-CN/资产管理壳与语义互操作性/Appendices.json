{
    "hands_on_practices": [
        {
            "introduction": "掌握资产管理壳 (AAS) 的第一步是理解其基本结构。本练习将引导您通过编程方式构建并验证一个最小化的 AAS 实例 。此过程重点关注全局唯一标识符、可引用名称 ($idShort$) 以及 AAS、其子模型和属性之间的关系等核心原则，旨在通过动手实践来巩固您对 AAS 基础语法和结构规则的理解。",
            "id": "4206044",
            "problem": "您的任务是为一个单一物理资产构建并验证一个最小但结构一致的资产管理壳 (AAS) 实例，重点是通过显式语义标识符实现语义互操作性。目标是通过身份、可引用性和语义引用的第一性原理来形式化构建和验证过程，然后将这些规则实现为一个程序。最终输出必须是一个单行布尔值列表，表示每个测试用例的有效性。\n\n基本和核心定义：\n- 资产管理壳 (AAS) 是资产的数字表示，捕获其身份标识、管理信息和子模型。在简化的最小实例中，AAS 被建模为一对可识别元素：AAS 本身和一个子模型。只有 AAS 和子模型是具有全局唯一标识符的可识别元素。子模型元素（具体来说是属性）是可引用的，但不是可识别的。\n- 全局唯一性由通用唯一标识符 (UUID) 或国际化资源标识符 (IRI) 来保证。出于计算目的，形式为 $\\text{urn:uuid:}\\langle\\text{uuid}\\rangle$ 的 IRI 和形式为 $\\text{http}://\\ldots$ 或 $\\text{https}://\\ldots$ 的 Web IRI 均被视为有效。\n- 语义互操作性要求每个属性都带有一个 $\\text{semanticId}$，该 ID 引用一个全局可解析的概念引用（此处建模为 IRI）。\n\n要构建的最小 JSON 表示：\n- 该实例是一个 JSON 对象，包含两个顶级成员：\n  - $\\text{assetAdministrationShell}$：一个对象，包含字段 $\\text{id}$、$\\text{idShort}$、$\\text{administration}$、$\\text{assetInformation}$ 和 $\\text{submodels}$。\n  - $\\text{submodel}$：一个对象，包含字段 $\\text{id}$、$\\text{idShort}$ 和 $\\text{submodelElements}$。\n- 字段级结构：\n  - $\\text{assetAdministrationShell.id}$：一个全局唯一标识符（IRI 或带有 UUID 的 URN）。\n  - $\\text{assetAdministrationShell.idShort}$：一个满足命名约束的可引用名称。\n  - $\\text{assetAdministrationShell.administration}$：一个对象，包含作为字符串的 $\\text{version}$ 和 $\\text{revision}$。\n  - $\\text{assetInformation.globalAssetId}$：底层物理资产的全局唯一标识符。\n  - $\\text{assetAdministrationShell.submodels}$：一个列表，包含一个引用对象，其字段 $\\text{id}$ 等于 $\\text{submodel.id}$。\n  - $\\text{submodel.id}$：一个全局唯一标识符，与 $\\text{assetAdministrationShell.id}$ 和 $\\text{assetInformation.globalAssetId}$ 不同。\n  - $\\text{submodel.idShort}$：一个满足命名约束的可引用名称。\n  - $\\text{submodel.submodelElements}$：一个列表，恰好包含 $3$ 个属性对象。\n  - 每个属性对象包含 $\\text{modelType} = \\text{\"Property\"}$、$\\text{idShort}$、$\\text{semanticId}$、$\\text{valueType}$ 和 $\\text{value}$。\n\n根据第一性原理定义的命名和类型约束：\n- $\\text{idShort}$ 的可引用命名：\n  - 设 $\\Sigma_{\\text{alnum}}$ 为字母数字字符集，$\\Sigma_{\\_}$ 为下划线。允许的字母表为 $\\Sigma = \\Sigma_{\\text{alnum}} \\cup \\{\\_\\}$。\n  - 名称必须以字母开头。形式上，对于长度为 $\\ell$ 的字符串 $s$，$s \\in \\Sigma^\\ell$，$1 \\leq \\ell \\leq 128$，且第一个字符 $s_1 \\in \\{A,\\ldots,Z,a,\\ldots,z\\}$。\n  - 所有后续字符 $s_i \\in \\Sigma$，其中 $i \\in \\{2,\\ldots,\\ell\\}$。\n- 全局标识符有效性：\n  - 一个标识符 $u$ 如果是形式为 $\\text{urn:uuid:}\\langle\\text{uuid}\\rangle$ 的 URN（其中 $\\langle\\text{uuid}\\rangle$ 匹配规范的 UUID 版本 4 模式），或者是一个以 $\\text{http}://$ 或 $\\text{https}://$ 开头后跟非空路径的 Web IRI，则该标识符是有效的。\n- 基数约束：\n  - 列表 $\\text{submodel.submodelElements}$ 的长度必须恰好为 $3$：$|\\text{submodel.submodelElements}| = 3$。\n  - 列表 $\\text{assetAdministrationShell.submodels}$ 的长度必须恰好为 $1$：$|\\text{assetAdministrationShell.submodels}| = 1$。\n- 管理信息约束：\n  - $\\text{version}$ 和 $\\text{revision}$ 都必须作为非空字符串存在，且每个字符串仅由数字组成。形式上，如果 $\\text{version} = v$ 且 $\\text{revision} = r$，那么当解释为数字字符串时，$v \\in \\{0,1,2,\\ldots\\}$ 且 $r \\in \\{0,1,2,\\ldots\\}$。\n- 属性类型和语义：\n  - 每个属性必须有一个 $\\text{valueType} \\in \\{\\text{\"string\"}, \\text{\"integer\"}, \\text{\"double\"}, \\text{\"boolean\"}\\}$。\n  - 其 $\\text{value}$ 必须是相应的原始类型：分别为字符串、整数、浮点数（对于 $\\text{\"double\"}$）或布尔值。对于 $\\text{\"double\"}$，该值可以是一个实数；在实践中，这是一个浮点表示。\n  - 每个属性必须有一个 $\\text{semanticId}$，它是一个有效的 IRI（$\\text{http}/\\text{https}$ 或 $\\text{urn:uuid}$）。\n- 唯一性约束：\n  - 标识符 $\\text{assetAdministrationShell.id}$、$\\text{submodel.id}$ 和 $\\text{assetInformation.globalAssetId}$ 必须两两不同。\n  - 子模型中属性集合内的 $\\text{idShort}$ 值必须两两不同。\n\n程序要求：\n- 实现一个程序，对于每个测试用例，构建一个如上所述的最小 AAS 实例 JSON 对象，然后根据上述约束对其进行验证。该程序必须为每个测试用例返回一个布尔值，以指示其有效性。\n- 程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\text{[result1,result2,\\ldots]}$）。\n\n测试套件：\n- 共有 $6$ 个测试用例。每个用例都需要构建一个带有一个子模型和恰好 $3$ 个属性的 AAS 实例。\n- 每个测试用例的参数如下：\n  1. 正常路径 (预期有效性: true):\n     - $\\text{AAS.idShort} = \\text{\"AAS\\_Drive\"}$，$\\text{Submodel.idShort} = \\text{\"DriveSM\"}$，$\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性 $1$：$\\text{idShort} = \\text{\"nominalTorque\"}$，$\\text{valueType} = \\text{\"integer\"}$，$\\text{value} = 120$，$\\text{semanticId} = \\text{\"http://example.org/cd#nominalTorque\"}$。\n     - 属性 $2$：$\\text{idShort} = \\text{\"ratedSpeed\"}$，$\\text{valueType} = \\text{\"double\"}$，$\\text{value} = 1500.0$，$\\text{semanticId} = \\text{\"http://example.org/cd#ratedSpeed\"}$。\n     - 属性 $3$：$\\text{idShort} = \\text{\"manufacturerName\"}$，$\\text{valueType} = \\text{\"string\"}$，$\\text{value} = \\text{\"Acme Motors\"}$，$\\text{semanticId} = \\text{\"http://example.org/cd#manufacturerName\"}$。\n     - 所有标识符（$\\text{AAS.id}$、$\\text{Submodel.id}$、$\\text{globalAssetId}$）都是不同的有效 UUID URN。\n  2. 边界命名长度 (预期有效性: true):\n     - $\\text{Submodel.idShort} = \\text{\"DriveSM\"}$，$\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性 $1$：$\\text{idShort}$ 是一个长度为 $128$ 的字符串，以字母开头，例如 $\\text{\"A\"}$ 后跟 $127$ 个下划线或字母数字字符，$\\text{valueType} = \\text{\"string\"}$，$\\text{value} = \\text{\"X\"}$，$\\text{semanticId} = \\text{\"http://example.org/cd#longId\"}$。\n     - 属性 $2$ 和 $3$ 使用有效的短名称和类似于用例 $1$ 的语义。\n     - 所有标识符都是不同的有效 UUID URN。\n  3. 无效的子模型可引用名称 (预期有效性: false):\n     - $\\text{Submodel.idShort} = \\text{\"1SubmodelX\"}$ (违反了以字母开头的约束)，$\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性均有效，如用例 $1$ 所示。\n     - 所有标识符都是不同的有效 UUID URN。\n  4. 重复的全局标识符 (预期有效性: false):\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 强制 $\\text{Submodel.id} = \\text{AAS.id}$ (违反了两两不同性)，属性均有效，如用例 $1$ 所示。\n     - $\\text{globalAssetId}$ 是一个不同的有效 UUID URN。\n  5. 缺失管理字段 (预期有效性: false):\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}\\}$ (缺少 $\\text{revision}$)。\n     - 其他字段与用例 $1$ 匹配，并且在其他方面有效。\n  6. 缺失属性语义标识符 (预期有效性: false):\n     - $\\text{administration} = \\{\\text{version} = \\text{\"1\"}, \\text{revision} = \\text{\"0\"}\\}$。\n     - 属性 $1$ 和 $2$ 有效，如用例 $1$ 所示；属性 $3$ 缺少 $\\text{semanticId}$ (例如，$\\text{semanticId} = \\text{null}$ 或被省略)。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\text{[true,false,true,\\ldots]}$）。元素必须是小写的布尔值。",
            "solution": "问题陈述经评估为 **有效**。它在科学上植根于数字孪生和资产管理壳 (AAS) 规范领域，定义明确，具有清晰且可形式化的约束，并且语言客观。任务是根据一组精确的规则构建一个最小 AAS 实例的验证器，并根据给定的测试套件对其进行评估。\n\n解决方案以一个 Python 程序实现，该程序围绕一个验证器类 `AASValidator` 构建。该类封装了根据规定规则验证 AAS 实例所需的所有逻辑。验证器的设计基于一种分层的、基于原则的方法，确保问题陈述中的每个约束都得到系统地检查。\n\n验证过程被分解为几个逻辑步骤，每个步骤由 `AASValidator` 类中的一个专用方法处理。一个顶层的 `validate` 方法协调整个过程，仅当所有检查都通过时才返回 `True`。为了稳健地处理格式错误的输入（例如缺失的键或不正确的数据结构），主验证逻辑被包含在一个 `try...except` 块中；任何结构性错误都会引发异常，并导致立即返回 `False`，表示实例无效。\n\n验证规则分类并实现如下：\n\n1.  **结构和基数验证**：第一步是验证 JSON 对象的基本结构。验证器检查所有必需键的存在性和正确类型（即字典、列表），这包括每个层级：根对象（`assetAdministrationShell`、`submodel`）、AAS 对象（`id`、`idShort`、`administration`、`assetInformation`、`submodels`）、子模型对象（`id`、`idShort`、`submodelElements`）等。基数约束也在此处强制执行，特别是确保 `submodels` 列表恰好包含一个元素（$|\\text{assetAdministrationShell.submodels}| = 1$），`submodelElements` 列表恰好包含三个元素（$|\\text{submodel.submodelElements}| = 3$）。\n\n2.  **标识符语法验证**：定义了两种类型的标识符：可引用名称（`idShort`）和全局唯一标识符。\n    -   **`idShort` 验证**：一个辅助方法 `_is_valid_idshort` 实现了命名约束。对于一个给定的长度为 $\\ell$ 的 `idShort` 字符串 $s$，它验证 $1 \\le \\ell \\le 128$，第一个字符 $s_1$ 是一个 ASCII 字母，并且所有后续字符都属于字母数字字符或下划线集合。这通过一个正则表达式高效实现：`^[a-zA-Z][a-zA-Z0-9_]{0,127}$`。\n    -   **全局标识符验证**：另一个辅助方法 `_is_valid_global_id` 验证全局唯一标识符。它检查一个标识符字符串是否符合两种模式之一：版本 4 UUID 的 URN（例如 `urn:uuid:...`），通过一个特定的正则表达式进行验证；或一个 Web IRI。如果一个 IRI 以 `http://` 或 `https://` 开头，后跟非空的权威和路径，则认为其有效，这通过 Python 的标准 `urllib.parse.urlparse` 函数进行稳健检查。此检查应用于 `assetAdministrationShell.id`、`submodel.id`、`assetInformation.globalAssetId` 以及每个 `Property` 的 `semanticId`。\n\n3.  **关系约束验证**：此步骤确保 AAS 实例不同部分之间关系的完整性。\n    -   **标识符唯一性**：AAS、子模型和物理资产的全局标识符（`assetAdministrationShell.id`、`submodel.id`、`assetInformation.globalAssetId`）必须两两不同。这通过将它们收集到一个集合中并检查集合的大小是否等于 $3$ 来验证。\n    -   **`idShort` 唯一性**：在 `submodelElements` 列表中，所有 `Property` 元素必须具有唯一的 `idShort` 值。这通过将所有属性的 `idShort` 收集到一个列表中，并将其长度与从该列表构建的集合的长度进行比较来检查。\n    -   **引用完整性**：从 AAS 到其子模型的引用必须正确。验证器确认 `assetAdministrationShell.submodels` 列表中单个对象内的 `id` 字段与 `submodel.id` 相同。\n\n4.  **语义和内容验证**：这最后一个阶段检查特定字段的内容和类型。\n    -   **管理信息**：检查 `administration` 对象以确保其包含 `version` 和 `revision` 两个键，并且它们的值是仅由数字组成的非空字符串。\n    -   **属性级别验证**：对 `submodelElements` 中的三个 `Property` 对象中的每一个进行详尽地检查。`modelType` 必须是字符串 `\"Property\"`。`semanticId` 必须是有效的全局标识符。`valueType` 必须是允许的字符串之一（`\"string\"`、`\"integer\"`、`\"double\"`、`\"boolean\"`）。至关重要的是，`value` 字段的类型必须与其 `valueType` 相对应。例如，如果 `valueType` 是 `\"integer\"`，则 `value` 必须是 Python 的 `int`（而不是 `bool`，因为 `bool` 是 `int` 的子类）。\n\n为执行测试套件，定义了一个 `build_instance` 函数，用于为每个测试用例以编程方式构建 AAS JSON 结构。主 `solve` 函数遍历 6 个测试用例，构建每个实例，将其传递给 `AASValidator`，并收集布尔结果。最终的布尔值列表随后被格式化为所需的单行字符串输出。",
            "answer": "```python\nimport re\nimport uuid\nfrom urllib.parse import urlparse\n\nclass AASValidator:\n    \"\"\"\n    Validates a minimal AAS instance against a set of formal rules.\n    \"\"\"\n    def __init__(self):\n        self.uuid_urn_pattern = re.compile(\n            r'^urn:uuid:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$',\n            re.IGNORECASE\n        )\n        self.idshort_pattern = re.compile(r'^[a-zA-Z][a-zA-Z0-9_]{0,127}$')\n\n    def _is_valid_idshort(self, name: str) -> bool:\n        \"\"\"Validates a referable name (idShort).\"\"\"\n        if not isinstance(name, str):\n            return False\n        return bool(self.idshort_pattern.match(name))\n\n    def _is_valid_global_id(self, identifier: str) -> bool:\n        \"\"\"Validates a globally unique identifier (IRI or URN).\"\"\"\n        if not isinstance(identifier, str):\n            return False\n        \n        # Check for UUID URN\n        if self.uuid_urn_pattern.match(identifier):\n            return True\n        \n        # Check for Web IRI with non-empty path\n        if identifier.startswith(('http://', 'https://')):\n            try:\n                parsed = urlparse(identifier)\n                # Must have scheme, network location, and a non-empty path\n                if parsed.scheme and parsed.netloc and parsed.path:\n                    return True\n            except (ValueError, TypeError):\n                return False\n        \n        return False\n\n    def _validate_administration(self, admin: dict) -> bool:\n        \"\"\"Validates the administration object.\"\"\"\n        if not isinstance(admin, dict): return False\n        version = admin.get('version')\n        revision = admin.get('revision')\n        \n        if not (version and isinstance(version, str) and version.isdigit()):\n            return False\n        if not (revision and isinstance(revision, str) and revision.isdigit()):\n            return False\n        return True\n\n    def _validate_properties(self, props: list) -> bool:\n        \"\"\"Validates the list of submodel elements (Properties).\"\"\"\n        if not isinstance(props, list) or len(props) != 3:\n            return False\n        \n        id_shorts = []\n        for prop in props:\n            if not isinstance(prop, dict): return False\n            \n            if prop.get('modelType') != 'Property': return False\n            \n            id_short = prop.get('idShort')\n            if not self._is_valid_idshort(id_short): return False\n            id_shorts.append(id_short)\n            \n            if not self._is_valid_global_id(prop.get('semanticId')): return False\n            \n            value_type = prop.get('valueType')\n            value = prop.get('value')\n            \n            type_map = {\n                'string': str, 'integer': int, 'double': float, 'boolean': bool\n            }\n            if value_type not in type_map: return False\n            \n            expected_type = type_map[value_type]\n            \n            # The value could be missing. A missing value is not of the expected type.\n            if value is None and expected_type is not type(None):\n                # A special check is needed if 'None' is a valid value, but it is not here.\n                # Here we handle missing 'value' key, which get() returns as None.\n                if 'value' not in prop: return False\n\n            if not isinstance(value, expected_type): return False\n            if value_type == 'integer' and isinstance(value, bool): return False\n\n        if len(set(id_shorts)) != len(id_shorts): return False\n        \n        return True\n\n    def validate(self, instance: dict) -> bool:\n        \"\"\"Performs a full validation of the AAS instance.\"\"\"\n        try:\n            # 1. Root structure and key existence\n            aas = instance['assetAdministrationShell']\n            sm = instance['submodel']\n            \n            aas_id = aas['id']\n            aas_idshort = aas['idShort']\n            aas_admin = aas['administration']\n            aas_asset_info = aas['assetInformation']\n            aas_submodels = aas['submodels']\n            global_asset_id = aas_asset_info['globalAssetId']\n            \n            sm_id = sm['id']\n            sm_idshort = sm['idShort']\n            sm_elements = sm['submodelElements']\n            \n            # 2. Global Identifier validity and uniqueness\n            if not all(map(self._is_valid_global_id, [aas_id, sm_id, global_asset_id])):\n                return False\n            if len({aas_id, sm_id, global_asset_id}) != 3:\n                return False\n\n            # 3. idShort validity\n            if not self._is_valid_idshort(aas_idshort) or not self._is_valid_idshort(sm_idshort):\n                return False\n                \n            # 4. Administration info\n            if not self._validate_administration(aas_admin):\n                return False\n            \n            # 5. Cardinality and References\n            if not isinstance(aas_submodels, list) or len(aas_submodels) != 1:\n                return False\n            if aas_submodels[0].get('id') != sm_id:\n                return False\n                \n            # 6. Properties validation (includes own cardinality check)\n            if not self._validate_properties(sm_elements):\n                return False\n\n        except (KeyError, TypeError, IndexError):\n            return False\n            \n        return True\n\ndef build_instance(\n    aas_idshort=\"AAS_Drive\",\n    sm_idshort=\"DriveSM\",\n    admin_info={'version': '1', 'revision': '0'},\n    aas_id=None,\n    sm_id=None,\n    asset_id=None,\n    properties=None\n):\n    \"\"\"Builds a test AAS instance dictionary.\"\"\"\n    aas_id = aas_id or f\"urn:uuid:{uuid.uuid4()}\"\n    sm_id = sm_id or f\"urn:uuid:{uuid.uuid4()}\"\n    asset_id = asset_id or f\"urn:uuid:{uuid.uuid4()}\"\n\n    if properties is None:\n        properties = [\n            {'modelType': 'Property', 'idShort': 'nominalTorque', 'valueType': 'integer', 'value': 120, 'semanticId': 'http://example.org/cd#nominalTorque'},\n            {'modelType': 'Property', 'idShort': 'ratedSpeed', 'valueType': 'double', 'value': 1500.0, 'semanticId': 'http://example.org/cd#ratedSpeed'},\n            {'modelType': 'Property', 'idShort': 'manufacturerName', 'valueType': 'string', 'value': 'Acme Motors', 'semanticId': 'http://example.org/cd#manufacturerName'}\n        ]\n\n    return {\n        'assetAdministrationShell': {\n            'id': aas_id, 'idShort': aas_idshort, 'administration': admin_info,\n            'assetInformation': {'globalAssetId': asset_id},\n            'submodels': [{'id': sm_id}]\n        },\n        'submodel': {\n            'id': sm_id, 'idShort': sm_idshort, 'submodelElements': properties\n        }\n    }\n\ndef solve():\n    \"\"\"Constructs test cases, validates them, and prints results.\"\"\"\n    test_cases = []\n\n    # Case 1: Happy path\n    test_cases.append(build_instance())\n\n    # Case 2: Boundary naming length\n    props_c2 = [p.copy() for p in build_instance()['submodel']['submodelElements']]\n    props_c2[0] = {'modelType': 'Property', 'idShort': 'A' + '_' * 127, 'valueType': 'string', 'value': 'X', 'semanticId': 'http://example.org/cd#longId'}\n    test_cases.append(build_instance(properties=props_c2))\n\n    # Case 3: Invalid Submodel referable name\n    test_cases.append(build_instance(sm_idshort=\"1SubmodelX\"))\n\n    # Case 4: Duplicate global identifiers\n    dup_id = f\"urn:uuid:{uuid.uuid4()}\"\n    test_cases.append(build_instance(aas_id=dup_id, sm_id=dup_id))\n\n    # Case 5: Missing administrative field\n    test_cases.append(build_instance(admin_info={'version': '1'}))\n\n    # Case 6: Missing Property semantic identifier\n    props_c6 = [p.copy() for p in build_instance()['submodel']['submodelElements']]\n    props_c6[2]['semanticId'] = None\n    test_cases.append(build_instance(properties=props_c6))\n\n    validator = AASValidator()\n    results = [validator.validate(case) for case in test_cases]\n\n    print(f\"[{','.join([str(r).lower() for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本结构之后，下一步是确保数据的质量和语义一致性。本练习将介绍一种形式化的验证方法，即应用形状约束语言 (SHACL) 的核心概念来为状态监测子模型定义和实施一系列规则 。您将学习如何强制执行强制性属性、正确的数据类型、有效的单位以及数值范围，从而体验语义技术如何自动化验证过程并保障互操作性。",
            "id": "4205984",
            "problem": "您的任务是使用形状约束语言 (SHACL)，在资产管理壳 (AAS) 的背景下，为状态监控子模型形式化验证。目标是构建一个等效于 SHACL 的形状图，并在一个抽象的资源描述框架 (RDF) 表示上，以编程形式实现其验证语义。其目的是检测缺失的属性和无效的属性值，通过强制执行一致的数据类型、单位和范围来支持语义互操作性。验证必须基于形状约束语言 (SHACL)、资源描述框架 (RDF) 和资产管理壳 (AAS) 中子模型概念的核心定义，并且必须能够纯粹地表示为对类型化数据的数学约束。\n\n定义与基本基础：\n- 一个子模型实例表示为一个有限的属性集，每个属性是一个具有以下属性的节点：一个语义标识符、一个测量值、一个声明的数据类型和一个声明的单位。形式上，一个子模型实例是一个有限关系，它将属性名称映射到一个属性元组。设所需属性的集合表示为 $\\mathcal{P} = \\{\\text{vibrationVelocityRMS}, \\text{temperature}, \\text{rotationalSpeed}\\}$。\n- 一个 SHACL 节点形状 (Node Shape) 定义为对目标节点的一组约束。对于每个属性 $p \\in \\mathcal{P}$，约束包括：最小基数、数据类型、单位一致性（包括允许的转换）和范围界限。设每个属性的规范单位为：振动速度为 $\\text{m/s}$，温度为 $\\text{K}$，转速为 $\\text{rad/s}$。\n- 单位转换函数必须将提供的值映射到规范单位。允许的单位转换如下：\n  1. 振动速度：使用 $v_{\\text{m/s}} = v_{\\text{mm/s}} \\times 10^{-3}$ 从 $\\text{mm/s} \\to \\text{m/s}$，以及使用 $v_{\\text{m/s}} = v_{\\text{m/s}}$ 从 $\\text{m/s} \\to \\text{m/s}$。\n  2. 温度：使用 $T_{\\text{K}} = T_{\\text{degC}} + 273.15$ 从 $\\text{degC} \\to \\text{K}$，以及使用 $T_{\\text{K}} = T_{\\text{K}}$ 从 $\\text{K} \\to \\text{K}$。\n  3. 转速：使用 $\\omega_{\\text{rad/s}} = \\text{RPM} \\cdot \\frac{2\\pi}{60}$ 从 $\\text{RPM} \\to \\text{rad/s}$，以及使用 $\\omega_{\\text{rad/s}} = \\omega_{\\text{rad/s}}$ 从 $\\text{rad/s} \\to \\text{rad/s}$。\n- 范围约束以规范单位定义：\n  1. 振动速度：$0 \\le v_{\\text{m/s}} \\le 0.05$。\n  2. 温度：$273.15 \\le T_{\\text{K}} \\le 353.15$。\n  3. 转速：$0 \\le \\omega_{\\text{rad/s}} \\le 500$。\n- 基数约束：对于每个 $p \\in \\mathcal{P}$，最小计数为 $1$（必须存在）。\n- 数据类型约束：对于每个属性值 $x$，其 Python 级别的类型必须对应于一个数值（实数），即 $x \\in \\mathbb{R}$。\n\n您的程序必须：\n1. 构建一个等效于 SHACL 的形状图作为内部数据结构，为每个属性 $p \\in \\mathcal{P}$ 编码：规范单位、允许的单位转换、数据类型要求（实值）以及包含边界的范围。\n2. 实现一个验证器，对每个子模型实例进行以下操作：\n   - 检查存在性：如果一个必需的属性 $p$ 缺失，则记录一个违规。\n   - 检查数据类型：如果存在的值不是实数，则记录一个违规。\n   - 检查单位：如果声明的单位不在属性 $p$ 允许的可转换单位之列，则记录一个违规。\n   - 使用上述公式执行到规范单位的单位转换，然后检查范围：如果转换后的值落在包含边界之外，则记录一个违规。\n   - 当且仅当总违规数为 $0$ 时，一个子模型实例被认为是有效的。\n3. 将验证器应用于以下子模型实例的测试套件。所有物理量必须按照其声明的单位进行解释和验证。规范单位如上定义；在范围检查之前，必须进行转换以产生规范单位。在适用的情况下，角度必须以弧度处理。给定的输入包括值和单位；您必须在必要时将其转换为规范单位。明确地说，值应被视为实数，并且必须遵守包含边界。\n\n测试套件：\n- 测试用例 1（正常路径）：\n  - $\\text{vibrationVelocityRMS} = 4.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 310.0$，单位为 $\\text{K}$。\n  - $\\text{rotationalSpeed} = 1800.0$，单位为 $\\text{RPM}$。\n- 测试用例 2（缺失属性）：\n  - $\\text{vibrationVelocityRMS} = 2.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature}$ 缺失。\n  - $\\text{rotationalSpeed} = 120.0$，单位为 $\\text{rad/s}$。\n- 测试用例 3（无效数据类型）：\n  - $\\text{vibrationVelocityRMS} = 1.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 300.0$，单位为 $\\text{K}$。\n  - $\\text{rotationalSpeed} = \"\\!100\"$（一个字符串），单位为 $\\text{rad/s}$。\n- 测试用例 4（无效单位）：\n  - $\\text{vibrationVelocityRMS} = 3.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 100.0$，单位为 $\\text{F}$。\n  - $\\text{rotationalSpeed} = 50.0$，单位为 $\\text{rad/s}$。\n- 测试用例 5（边界条件）：\n  - $\\text{vibrationVelocityRMS} = 50.0$，单位为 $\\text{mm/s}$。\n  - $\\text{temperature} = 273.15$，单位为 $\\text{K}$。\n  - $\\text{rotationalSpeed} = 500.0$，单位为 $\\text{rad/s}$。\n\n答案规范：\n- 对于每个测试用例，生成一个对 $[b, n]$，其中 $b$ 是一个布尔值，指示实例是否有效，$n$ 是检测到的违规整数计数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，例如：$[[\\text{True},0],[\\text{False},2],\\ldots]$。\n\n不允许外部输入。所有常量和转换都必须在程序内部实现。数值结果必须使用上述规则精确计算。输出只包含布尔值和整数，按指定格式单行输出，不含其他文本。",
            "solution": "我们首先使用形状约束语言 (SHACL) 和资源描述框架 (RDF) 的定义，并在资产管理壳 (AAS) 的背景下，来形式化验证问题。一个状态监控子模型的实例可以表示为从属性名称到属性元组的有限映射。设强制属性集为 $\\mathcal{P} = \\{\\text{vibrationVelocityRMS}, \\text{temperature}, \\text{rotationalSpeed}\\}$。对于每个属性 $p \\in \\mathcal{P}$，SHACL 节点形状 (Node Shape) 指定了以下约束：(i) 最小基数为 $1$（存在性），(ii) 要求为实值数值类型的数据类型约束，(iii) 在一个允许集合下的单位一致性，该集合提供到规范单位的转换，以及 (iv) 以规范单位表示的包含边界的范围界限。\n\n我们将形状图编码为一个结构化映射。对于每个属性 $p$，我们存储：\n- 规范单位 $u_p$。\n- 一组允许的单位，其到 $u_p$ 的转换由形式为 $$y = a \\cdot x + b,$$ 的线性变换指定，其中 $x$ 是以声明单位提供的值，$y$ 是转换后以规范单位表示的值。具体来说：\n  - 对于振动速度，我们对 $\\text{mm/s}$ 使用 $y = 10^{-3} \\cdot x$，对 $\\text{m/s}$ 使用 $y = 1 \\cdot x$，规范单位为 $\\text{m/s}$。\n  - 对于温度，我们对 $\\text{degC}$ 使用 $y = 1 \\cdot x + 273.15$，对 $\\text{K}$ 使用 $y = 1 \\cdot x$，规范单位为 $\\text{K}$。\n  - 对于转速，我们对 $\\text{RPM}$ 使用 $y = \\frac{2\\pi}{60} \\cdot x$，对 $\\text{rad/s}$ 使用 $y = 1 \\cdot x$，规范单位为 $\\text{rad/s}$。\n- 以规范单位表示的包含边界 $[\\ell_p, u_p]$，即：\n  - 振动速度：$[0, 0.05]$ in $\\text{m/s}$。\n  - 温度：$[273.15, 353.15]$ in $\\text{K}$。\n  - 转速：$[0, 500]$ in $\\text{rad/s}$。\n\n验证器源自 SHACL 语义：\n1. 存在性规则：对于每个 $p \\in \\mathcal{P}$，强制执行 $\\text{minCount} \\ge 1$。如果属性 $p$ 缺失，记录一个违规。\n2. 数据类型规则：如果属性 $p$ 存在，检查其值 $x$ 是否为实值，即 $x \\in \\mathbb{R}$。如果不是，记录一个违规。在程序上，我们检查 Python 级别的类型是否对应于数值类型（整数或浮点数）以表示 $\\mathbb{R}$ 的元素。\n3. 单位一致性与转换：如果属性 $p$ 声明的单位 $u$ 不在允许的集合中，记录一个违规。如果 $u$ 是允许的，应用转换 $y = a \\cdot x + b$ 以获得规范值 $y$。\n4. 范围规则：一旦转换为规范单位，检查包含边界 $\\ell_p \\le y \\le u_p$。如果不满足，记录一个违规。\n\n一个子模型实例当且仅当总违规计数为 $0$ 时有效。这对应于 SHACL 节点形状语义下所有属性约束的逻辑合取。\n\n我们将此应用于测试套件：\n\n- 测试用例 1：\n  - $\\text{vibrationVelocityRMS} = 4.0$ $\\text{mm/s}$ 转换为 $y = 4.0 \\cdot 10^{-3} = 0.004$ $\\text{m/s}$，且 $0 \\le 0.004 \\le 0.05$ 成立。\n  - $\\text{temperature} = 310.0$ $\\text{K}$ 无需转换，满足 $273.15 \\le 310.0 \\le 353.15$。\n  - $\\text{rotationalSpeed} = 1800.0$ $\\text{RPM}$ 转换为 $y = 1800.0 \\cdot \\frac{2\\pi}{60} = 60\\pi \\approx 188.4955592$ $\\text{rad/s}$，且 $0 \\le 188.4955592 \\le 500$ 成立。\n  - 违规数：$0$。有效：$\\text{True}$。\n\n- 测试用例 2：\n  - $\\text{vibrationVelocityRMS} = 2.0$ $\\text{mm/s}$ 转换为 $0.002$ $\\text{m/s}$，在范围内。\n  - $\\text{temperature}$ 缺失，违反 $\\text{minCount} \\ge 1$。\n  - $\\text{rotationalSpeed} = 120.0$ $\\text{rad/s}$ 在范围内。\n  - 违规数：$1$。有效：$\\text{False}$。\n\n- 测试用例 3：\n  - $\\text{vibrationVelocityRMS} = 1.0$ $\\text{mm/s}$ 转换为 $0.001$ $\\text{m/s}$，在范围内。\n  - $\\text{temperature} = 300.0$ $\\text{K}$ 在范围内。\n  - $\\text{rotationalSpeed} = \"\\!100\"$ 不是实值，违反数据类型约束；单位是允许的，但由于数据类型无效，跳过转换和范围检查。\n  - 违规数：$1$。有效：$\\text{False}$。\n\n- 测试用例 4：\n  - $\\text{vibrationVelocityRMS} = 3.0$ $\\text{mm/s}$ 转换为 $0.003$ $\\text{m/s}$，在范围内。\n  - $\\text{temperature} = 100.0$ 的单位 $\\text{F}$ 不在允许的集合 $\\{\\text{K}, \\text{degC}\\}$ 中，违反单位一致性（不执行转换）。\n  - $\\text{rotationalSpeed} = 50.0$ $\\text{rad/s}$ 在范围内。\n  - 违规数：$1$。有效：$\\text{False}$。\n\n- 测试用例 5：\n  - $\\text{vibrationVelocityRMS} = 50.0$ $\\text{mm/s}$ 转换为 $0.05$ $\\text{m/s}$，恰好在上限，包含边界允许此值。\n  - $\\text{temperature} = 273.15$ $\\text{K}$ 恰好在下限，允许。\n  - $\\text{rotationalSpeed} = 500.0$ $\\text{rad/s}$ 恰好在上限，允许。\n  - 违规数：$0$。有效：$\\text{True}$。\n\n因此，每个测试用例的预期输出为 $[\\text{True}, 0]$、$[\\text{False}, 1]$、$[\\text{False}, 1]$、$[\\text{False}, 1]$ 和 $[\\text{True}, 0]$。最终输出格式为单行，包含这些对的列表，以逗号分隔，并用方括号括起来，不含空格，即 $[[\\text{True},0],[\\text{False},1],[\\text{False},1],[\\text{False},1],[\\text{True},0]]$。\n\n程序按照规定构建形状图，根据 SHACL 语义实现验证器，将其应用于测试套件，并打印单行结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_shape_graph():\n    \"\"\"\n    Construct a SHACL-equivalent shape graph for the Condition Monitoring Submodel.\n    Each property has:\n      - canonical_unit: the unit to which all values are converted\n      - converters: mapping from allowed unit to (factor, offset) for linear conversion y = factor*x + offset\n      - min_value and max_value: inclusive bounds in canonical units\n    \"\"\"\n    shape = {\n        \"vibrationVelocityRMS\": {\n            \"canonical_unit\": \"m/s\",\n            \"converters\": {\n                \"m/s\": (1.0, 0.0),\n                \"mm/s\": (1e-3, 0.0),\n            },\n            \"min_value\": 0.0,\n            \"max_value\": 0.05,\n        },\n        \"temperature\": {\n            \"canonical_unit\": \"K\",\n            \"converters\": {\n                \"K\": (1.0, 0.0),\n                \"degC\": (1.0, 273.15),  # T_K = T_degC + 273.15\n            },\n            \"min_value\": 273.15,\n            \"max_value\": 353.15,\n        },\n        \"rotationalSpeed\": {\n            \"canonical_unit\": \"rad/s\",\n            \"converters\": {\n                \"rad/s\": (1.0, 0.0),\n                \"RPM\": (2.0 * np.pi / 60.0, 0.0),  # omega_rad/s = RPM * 2*pi/60\n            },\n            \"min_value\": 0.0,\n            \"max_value\": 500.0,\n        },\n    }\n    return shape\n\ndef is_real_number(x):\n    \"\"\"Check if x is a real-number type (int or float) excluding booleans.\"\"\"\n    # Booleans are instances of int in Python, so exclude them explicitly.\n    return isinstance(x, (int, float)) and not isinstance(x, bool)\n\ndef validate_submodel(instance, shape):\n    \"\"\"\n    Validate a single submodel instance against the shape.\n    Returns (is_valid: bool, violations_count: int).\n    Rules:\n      - Missing required property => +1 violation\n      - Non-numeric value => +1 violation\n      - Unit not in converters => +1 violation\n      - Converted value outside inclusive [min_value, max_value] => +1 violation\n    \"\"\"\n    violations = 0\n    props = instance.get(\"properties\", {})\n\n    for prop_name, constraints in shape.items():\n        if prop_name not in props:\n            violations += 1\n            continue\n\n        prop = props[prop_name]\n        value = prop.get(\"value\", None)\n        unit = prop.get(\"unit\", None)\n\n        # Datatype validation\n        if not is_real_number(value):\n            violations += 1\n            # Skip further checks for this property since value is invalid\n            # (prevents double-counting due to failed conversion or range)\n            continue\n\n        # Unit conformity\n        converters = constraints[\"converters\"]\n        if unit not in converters:\n            violations += 1\n            # Skip conversion and range check since unit is invalid\n            continue\n\n        factor, offset = converters[unit]\n        canonical_value = factor * float(value) + offset\n\n        # Range check (inclusive)\n        min_v = constraints[\"min_value\"]\n        max_v = constraints[\"max_value\"]\n        if not (min_v = canonical_value = max_v):\n            violations += 1\n\n    is_valid = (violations == 0)\n    return is_valid, violations\n\ndef render_no_spaces(results):\n    \"\"\"\n    Render the results list with no spaces, handling nested lists and booleans/ints.\n    Example: [[True,0],[False,1]] (no spaces).\n    \"\"\"\n    def render_item(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(render_item(x) for x in item) + \"]\"\n        elif isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        elif isinstance(item, (int, float)):\n            # For floats, use default str conversion\n            return str(item)\n        else:\n            # Should not occur; we only expect bool/int/float or lists thereof.\n            return str(item)\n    return \"[\" + \",\".join(render_item(x) for x in results) + \"]\"\n\ndef solve():\n    shape = build_shape_graph()\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 4.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 310.0, \"datatype\": \"xsd:double\", \"unit\": \"K\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 1800.0, \"datatype\": \"xsd:double\", \"unit\": \"RPM\"},\n            },\n        },\n        # Test case 2 (missing temperature)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 2.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                # \"temperature\" missing\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 120.0, \"datatype\": \"xsd:double\", \"unit\": \"rad/s\"},\n            },\n        },\n        # Test case 3 (invalid datatype for rotationalSpeed)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 1.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 300.0, \"datatype\": \"xsd:double\", \"unit\": \"K\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": \"100\", \"datatype\": \"xsd:string\", \"unit\": \"rad/s\"},\n            },\n        },\n        # Test case 4 (invalid unit for temperature)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 3.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 100.0, \"datatype\": \"xsd:double\", \"unit\": \"F\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 50.0, \"datatype\": \"xsd:double\", \"unit\": \"rad/s\"},\n            },\n        },\n        # Test case 5 (boundary conditions)\n        {\n            \"type\": \"ConditionMonitoringSubmodel\",\n            \"properties\": {\n                \"vibrationVelocityRMS\": {\"semanticId\": \"onto:VibrationVelocityRMS\", \"value\": 50.0, \"datatype\": \"xsd:double\", \"unit\": \"mm/s\"},\n                \"temperature\": {\"semanticId\": \"onto:Temperature\", \"value\": 273.15, \"datatype\": \"xsd:double\", \"unit\": \"K\"},\n                \"rotationalSpeed\": {\"semanticId\": \"onto:RotationalSpeed\", \"value\": 500.0, \"datatype\": \"xsd:double\", \"unit\": \"rad/s\"},\n            },\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        is_valid, violations = validate_submodel(case, shape)\n        results.append([is_valid, violations])\n\n    # Final print statement in the exact required format (no spaces).\n    print(render_no_spaces(results))\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这个实践环节将展示一个定义明确且经过验证的 AAS 所带来的实际价值。利用一个包含语义化描述属性（如单位）的子模型，您将练习把测量值转换到标准单位制 ($SI$ 单位) 并计算测量不确定性的传播 。该练习连接了数字孪生中的数据表示与现实世界中的工程分析，突显了语义互操作性如何为可靠、自动化的计算提供支持。",
            "id": "4205975",
            "problem": "一个制造单元由一个数字孪生表示，其资产管理壳（AAS）暴露了三个属性（Property）元素，这些元素带有用于单位和转换为国际单位制（SI）的明确语义描述。每个属性提供一个原始传感器输出，该输出带有一倍标准差不确定度，并附有一个到国际单位制基本单位的线性转换模型。AAS声明了以下语义和值：\n- 温度属性：原始值 $x_T = 95.7\\,\\mathrm{^{\\circ}F}$，标准不确定度 $\\sigma_{x_T} = 0.35\\,\\mathrm{^{\\circ}F}$。概念描述（ConceptDescription）指定了一个到开尔文（SI）的线性转换，形式为 $u_T = a_T x_T + b_T$，其中 $a_T = \\frac{5}{9}$ 且 $b_T = 273.15 - \\frac{5}{9}\\cdot 32$。\n- 压力属性：原始值 $x_P = 1.842\\,\\mathrm{bar}$，标准不确定度 $\\sigma_{x_P} = 0.008\\,\\mathrm{bar}$。概念描述指定了SI转换 $u_P = a_P x_P + b_P$，其中 $a_P = 10^{5}$ 且 $b_P = 0$，得到帕斯卡（SI）。\n- 加速度属性：原始值 $x_A = 0.0365\\,\\mathrm{g}$，标准不确定度 $\\sigma_{x_A} = 0.0018\\,\\mathrm{g}$。概念描述指定了SI转换 $u_A = a_A x_A + b_A$，其中 $a_A = 9.80665$ 且 $b_A = 0$，得到 $\\mathrm{m\\,s^{-2}}$（SI）。\n\nAAS还定义了一个用于跨系统语义互操作性的虚拟、无量纲聚合指标 $y$，该指标通过SI归一化后的值计算得出：\n$$\ny = w_T \\frac{u_T - T_0}{T_s} + w_P \\frac{u_P}{P_s} + w_A \\frac{u_A}{A_s},\n$$\n其中 $w_T = 0.4$，$w_P = 0.35$，$w_A = 0.25$，$T_0 = 293.15\\,\\mathrm{K}$，$T_s = 300\\,\\mathrm{K}$，$P_s = 2.5 \\times 10^{5}\\,\\mathrm{Pa}$，以及 $A_s = 1\\,\\mathrm{m\\,s^{-2}}$。\n\n从线性模型的单位转换和不确定度传播的第一性原理出发，执行以下操作：\n1. 将每个原始传感器输出转换为其SI值 $u_T$、$u_P$ 和 $u_A$，并分别计算它们的标准不确定度 $\\sigma_{u_T}$、$\\sigma_{u_P}$ 和 $\\sigma_{u_A}$。\n2. 在原始传感器不确定度相互独立，且线性转换模型和聚合指标定义是精确的假设下，推导出 $y$ 的标准不确定度 $\\sigma_y$。\n\n仅报告 $y$ 的标准不确定度 $\\sigma_y$ 的最终值，该值应为一个无量纲的实数。将您的答案四舍五入到四位有效数字。",
            "solution": "该问题被评估为有效，因为它有科学依据、提法得当且客观。它提供了一套完整且一致的数据和定义，需要应用单位转换和不确定度传播的标准原理。\n\n任务是计算无量纲聚合指标 $y$ 的标准不确定度 $\\sigma_y$。这需要一个两步过程：首先，将每个原始传感器测量值转换为其对应的SI值并传播其不确定度；其次，组合这些传播后的不确定度以求得 $y$ 的最终不确定度。\n\n对于一个由具有标准不确定度 $\\sigma_{z_i}$ 的独立变量 $z_i$ 构成的函数 $f(z_1, z_2, \\dots, z_n)$，其不确定度传播的基本原理由方差 $\\sigma_f^2$ 的公式给出：\n$$\n\\sigma_f^2 = \\sum_{i=1}^{n} \\left( \\frac{\\partial f}{\\partial z_i} \\right)^2 \\sigma_{z_i}^2\n$$\n对于单个变量的线性变换 $u = ax + b$，其中 $a$ 和 $b$ 是精确常数，偏导数 $\\frac{\\partial u}{\\partial x}$ 就是 $a$。因此，$u$ 的不确定度 $\\sigma_u$ 与 $x$ 的不确定度 $\\sigma_x$ 的关系为：\n$$\n\\sigma_u = |a| \\sigma_x\n$$\n\n我们现在将这些原理应用于每个属性。\n\n**第1部分：单个属性的转换和不确定度传播**\n\n1.  **温度 ($T$)**\n    原始值为 $x_T = 95.7\\,^{\\circ}\\mathrm{F}$，标准不确定度为 $\\sigma_{x_T} = 0.35\\,^{\\circ}\\mathrm{F}$。到SI单位开尔文（$\\mathrm{K}$）的转换由线性模型 $u_T = a_T x_T + b_T$ 给出，其精确系数为 $a_T = \\frac{5}{9}$ 和 $b_T = 273.15 - \\frac{5}{9} \\cdot 32$。\n\n    SI值 $u_T$ 为：\n    $$\n    u_T = \\frac{5}{9} x_T + 273.15 - \\frac{5}{9} \\cdot 32 = \\frac{5}{9}(x_T - 32) + 273.15\n    $$\n    $$\n    u_T = \\frac{5}{9}(95.7 - 32) + 273.15 = \\frac{5}{9}(63.7) + 273.15 \\approx 35.3889\\,\\mathrm{K} + 273.15\\,\\mathrm{K} = 308.5389\\,\\mathrm{K}\n    $$\n    标准不确定度 $\\sigma_{u_T}$ 通过在线性模型中传播 $\\sigma_{x_T}$ 来计算：\n    $$\n    \\sigma_{u_T} = |a_T| \\sigma_{x_T} = \\frac{5}{9} \\cdot (0.35\\,\\mathrm{^{\\circ}F}) \\approx 0.1944\\,\\mathrm{K}\n    $$\n    为防止舍入误差，我们将在中间计算中保留精确的分数形式 $\\sigma_{u_T} = \\frac{5}{9} \\cdot \\frac{35}{100} = \\frac{7}{36}\\,\\mathrm{K}$。\n\n2.  **压力 ($P$)**\n    原始值为 $x_P = 1.842\\,\\mathrm{bar}$，标准不确定度为 $\\sigma_{x_P} = 0.008\\,\\mathrm{bar}$。到SI单位帕斯卡（$\\mathrm{Pa}$）的转换为 $u_P = a_P x_P + b_P$，其中 $a_P = 10^5$ 且 $b_P = 0$。\n\n    SI值 $u_P$ 为：\n    $$\n    u_P = 10^5 \\cdot (1.842) = 184200\\,\\mathrm{Pa} = 1.842 \\times 10^5\\,\\mathrm{Pa}\n    $$\n    标准不确定度 $\\sigma_{u_P}$ 为：\n    $$\n    \\sigma_{u_P} = |a_P| \\sigma_{x_P} = 10^5 \\cdot (0.008) = 800\\,\\mathrm{Pa}\n    $$\n\n3.  **加速度 ($A$)**\n    原始值为 $x_A = 0.0365\\,\\mathrm{g}$，标准不确定度为 $\\sigma_{x_A} = 0.0018\\,\\mathrm{g}$。到SI单位 $\\mathrm{m\\,s^{-2}}$ 的转换为 $u_A = a_A x_A + b_A$，其中 $a_A = 9.80665$ 且 $b_A = 0$。\n\n    SI值 $u_A$ 为：\n    $$\n    u_A = 9.80665 \\cdot (0.0365) \\approx 0.35794\\,\\mathrm{m\\,s^{-2}}\n    $$\n    标准不确定度 $\\sigma_{u_A}$ 为：\n    $$\n    \\sigma_{u_A} = |a_A| \\sigma_{x_A} = 9.80665 \\cdot (0.0018) \\approx 0.01765\\,\\mathrm{m\\,s^{-2}}\n    $$\n\n**第2部分：聚合指标 ($y$) 的不确定度传播**\n\n聚合指标 $y$ 被定义为SI转换后的值 $u_T$、$u_P$ 和 $u_A$ 的线性组合：\n$$\ny = w_T \\frac{u_T - T_0}{T_s} + w_P \\frac{u_P}{P_s} + w_A \\frac{u_A}{A_s}\n$$\n这可以重写以突出其对具有不确定度的变量的线性依赖关系：\n$$\ny = \\left(\\frac{w_T}{T_s}\\right) u_T + \\left(\\frac{w_P}{P_s}\\right) u_P + \\left(\\frac{w_A}{A_s}\\right) u_A - \\frac{w_T T_0}{T_s}\n$$\n问题陈述所有权重（$w_T, w_P, w_A$）和缩放（$T_0, T_s, P_s, A_s$）因子都是精确的。原始传感器的不确定度是相互独立的，这意味着SI转换后的不确定度（$\\sigma_{u_T}, \\sigma_{u_P}, \\sigma_{u_A}$）也是相互独立的。\n\n$y$ 对每个变量的偏导数是：\n$$\n\\frac{\\partial y}{\\partial u_T} = \\frac{w_T}{T_s} \\quad ; \\quad \\frac{\\partial y}{\\partial u_P} = \\frac{w_P}{P_s} \\quad ; \\quad \\frac{\\partial y}{\\partial u_A} = \\frac{w_A}{A_s}\n$$\n$y$ 的方差 $\\sigma_y^2$ 是偏导数的平方乘以相应变量的方差之和：\n$$\n\\sigma_y^2 = \\left(\\frac{w_T}{T_s}\\right)^2 \\sigma_{u_T}^2 + \\left(\\frac{w_P}{P_s}\\right)^2 \\sigma_{u_P}^2 + \\left(\\frac{w_A}{A_s}\\right)^2 \\sigma_{u_A}^2\n$$\n我们现在代入给定值和计算值：\n- $w_T = 0.4$，$T_s = 300\\,\\mathrm{K}$，$\\sigma_{u_T} = \\frac{7}{36}\\,\\mathrm{K}$\n- $w_P = 0.35$，$P_s = 2.5 \\times 10^5\\,\\mathrm{Pa}$，$\\sigma_{u_P} = 800\\,\\mathrm{Pa}$\n- $w_A = 0.25$，$A_s = 1\\,\\mathrm{m\\,s^{-2}}$，$\\sigma_{u_A} = 9.80665 \\cdot 0.0018 \\approx 0.01765197\\,\\mathrm{m\\,s^{-2}}$\n\n计算 $\\sigma_y^2$ 的和中的每一项：\n- 温度项：\n$$\n\\left(\\frac{0.4}{300}\\right)^2 \\left(\\frac{7}{36}\\right)^2 = \\left(\\frac{1}{750}\\right)^2 \\left(\\frac{49}{1296}\\right) \\approx 6.72148 \\times 10^{-8}\n$$\n- 压力项：\n$$\n\\left(\\frac{0.35}{2.5 \\times 10^5}\\right)^2 (800)^2 = (1.4 \\times 10^{-6})^2 (6.4 \\times 10^5) = 1.2544 \\times 10^{-6}\n$$\n- 加速度项：\n$$\n\\left(\\frac{0.25}{1}\\right)^2 (9.80665 \\cdot 0.0018)^2 = (0.25)^2 (0.01765197)^2 \\approx 1.947448 \\times 10^{-5}\n$$\n将这些项相加以求得总方差 $\\sigma_y^2$：\n$$\n\\sigma_y^2 \\approx (6.72148 \\times 10^{-8}) + (1.2544 \\times 10^{-6}) + (1.947448 \\times 10^{-5})\n$$\n$$\n\\sigma_y^2 \\approx (0.0672148 \\times 10^{-6}) + (1.2544 \\times 10^{-6}) + (19.47448 \\times 10^{-6})\n$$\n$$\n\\sigma_y^2 \\approx 20.79609 \\times 10^{-6} = 2.079609 \\times 10^{-5}\n$$\n最后，标准不确定度 $\\sigma_y$ 是方差的平方根：\n$$\n\\sigma_y = \\sqrt{2.079609 \\times 10^{-5}} \\approx 0.004560273\n$$\n问题要求答案四舍五入到四位有效数字。第五位有效数字是2，所以我们向下舍入。\n$$\n\\sigma_y \\approx 0.004560\n$$\n最后的零是有效数字，必须保留。指标 $y$ 是无量纲的，所以其不确定度 $\\sigma_y$ 也是无量纲的。",
            "answer": "$$\\boxed{0.004560}$$"
        }
    ]
}