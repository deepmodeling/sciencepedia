## 引言
数字孪生作为物理世界在数字空间的动态映射，其真正价值在于能够整合来自不同来源的[异构数据](@entry_id:265660)，形成一个全面、一致的系统视图，从而实现高级的分析、预测与优化。然而，这一愿景面临着一个根本性的障碍：[数据互操作性](@entry_id:926300)。当不同的系统、设备和应用程序使用各自的语言、格式和约定来描述[世界时](@entry_id:275204)，它们之间便筑起了一道道“数字巴别塔”，使得数据交换流于形式，却无法实现真正的理解与协同。本文旨在系统性地拆解并攻克这一挑战，为构建无缝互联的[数字孪生](@entry_id:171650)态系统提供一个清晰的路线图。

本文将通过三个核心章节，引导读者深入[数据互操作性](@entry_id:926300)的世界。首先，在“原理与机制”一章中，我们将建立一个分层框架，从基础的语法兼容性到深度的语义一致性，再到组织间的可信数据交换，详细剖析实现互操作所需的各项标准和核心机制。接着，在“应用与跨学科连接”一章中，我们将展示这些理论和标准如何在[智能制造](@entry_id:1131785)、能源系统、医疗保健等关键领域落地，解决实际问题并催生跨学科创新。最后，通过一系列精心设计的“动手实践”，读者将有机会将所学知识应用于具体场景，巩固对身份对齐、不确定性传播等核心概念的理解。通过本次学习，您将掌握构建稳健、可扩展且真正智能的[数字孪生](@entry_id:171650)系统所必备的互操作性知识体系。

## 原理与机制

在数字孪生的构建与集成过程中，[数据互操作性](@entry_id:926300)并非一个单一的问题，而是一个多层次、多维度的复杂挑战。它要求异构系统不仅能够交换数据，更要能够准确无误地理解和处理这些数据。本章旨在深入剖析实现[数字孪生](@entry_id:171650)[数据互操作性](@entry_id:926300)的核心原理与关键机制，通过分层解构，从基础的语法兼容性到深度的语义一致性，再到组织间的可信数据交换，系统性地建立一个完整的知识框架。

### 互操作性的基础：分层与分级

要系统地理解[互操作性](@entry_id:750761)，首先需要一个结构化的框架来组织不同的技术关注点。[工业4.0](@entry_id:1126475)参考架构模型（RAMI 4.0）提供了一个优秀的分层视角，它将复杂的工业系统解构为若干个正交的层次。我们可以借鉴这个模型来剖析[数字孪生](@entry_id:171650)的互操作性需求。

一个典型的[分层模型](@entry_id:274952)将[互操作性](@entry_id:750761)划分为以下几个关键层次：

*   **资产层 (Asset Layer)**：物理世界的实体本身，例如一台电机或一个生产单元。
*   **集成层 (Integration Layer)**：将物理资产与其数字表达（即数字孪生）进行绑定的层面。此处的互操作性关注的是如何通过传感器、执行器和网关将物理世界的状态和行为稳定地映射到数字世界。
*   **通信层 (Communication Layer)**：负责数据在不同系统间的传输，涉及网络协议和端点定义。此层的互操作性确保数据包能够从一个节点可靠地传递到另一个节点。
*   **信息层 (Information Layer)**：关注数据的结构和语义。它定义了数据模型、模式（schema）以及用于解释数据含义的元数据。
*   **[功能层](@entry_id:924927) (Functional Layer)**：暴露数字孪生所提供的服务、操作和行为。此层的互操作性保证一个系统可以调用另一个系统的功能并理解其行为。
*   **业务层 (Business Layer)**：涉及组织层面的策略、规则和流程。它规定了数据和服务的使用约束、许可、合规性要求等。

为了使这些抽象层次具体化，我们可以考察一个关键的工业标准——**资产管理壳 (Asset Administration Shell, AAS)**。AAS作为[工业4.0](@entry_id:1126475)中[数字孪生](@entry_id:171650)的[标准化](@entry_id:637219)实现，其内部结构与RAMI 4.0的[层次模型](@entry_id:274952)形成了精确的对应关系。例如，AAS的资产引用和标识符主要作用于**集成层**，它们将数字壳层与其对应的物理资产唯一绑定。定义了通信协议（如[OPC UA](@entry_id:1129137)、MQTT、HTTP）端点的通信描述符则属于**通信层**。承载数据结构和语义的**[子模](@entry_id:148922)型 (Submodel)** 及其包含的属性、关系和引用了**概念描述 (ConceptDescription)** 的语义标识符，构成了**信息层**的核心。AAS定义的**操作 (Operation)** 和**事件 (Event)** 暴露了可调用的服务，对应于**[功能层](@entry_id:924927)**。而包含使用约束、许可等规则的策略性子模型，则属于**业务层** 。通过这种映射，我们得以清晰地看到，实现一个完整的、可互操作的数字孪生，必须在每一个层次上都采用适当的标准和机制。

### 语法互操作性：[数据结构](@entry_id:262134)与演化

语法互操作性是实现数据交换的基础，它确保一个系统能够正确地解析和处理从另一个系统接收到的[数据结构](@entry_id:262134)。如果说通信层保证了[比特流](@entry_id:164631)的到达，那么语法[互操作性](@entry_id:750761)则保证了这些[比特流](@entry_id:164631)可以被成功地解码为有结构的数据。

#### 模式语言

实现语法互操作性的核心工具是**模式语言 (Schema Language)**。模式是对数据结构、类型和约束的正式规约。目前，主流的模式语言可分为两大类：

1.  **基于文本的模式**：例如 **JSON Schema** 和 **XML Schema Definition (XSD)**。它们分别用于描述JSON和XML数据的结构。这类模式语言通常具有丰富的类型系统和强大的约束定义能力（如[正则表达式](@entry_id:265845)、[数值范围](@entry_id:752817)等）。它们的优点是可读性强，易于调试，但缺点是序列化后的数据相对冗长。

2.  **基于二进制的模式**：例如 **Apache Avro** 和 **Protocol Buffers (ProtoBuf)**。它们通常与一个紧凑的二进制编码格式相伴而生，旨在实现高性能的数据传输。这类模式通常是强类型的，但其约束定义能力可能不如JSON Schema或XSD丰富。

选择哪种模式语言取决于具体的工程目标。若优先考虑高性能传输和强类型[演化支](@entry_id:171685)持，Avro和ProtoBuf是更优的选择。若需要丰富的约束验证能力和人类可读的数据格式，JSON Schema和XSD则更具优势 。

#### 模式演化与兼容性

在长生命周期的数字孪生系统中，数据模式的变更不可避免。**模式演化 (Schema Evolution)** 指的是数据模式随时间发生变化的过程，而**兼容性 (Compatibility)** 则是衡量演化后系统能否继续正常工作的关键指标。在流式处理的场景下，我们通常从消费者（Consumer）程序的角度来定义兼容性。假设一个消费者程序 $C$ 是针对旧模式 $S_{old}$ 构建的，它能够处理符合该模式的语料库 $L(S_{old})$ 中的所有消息。

*   **向后兼容性 (Backward Compatibility)**：指旧的消费者程序能够处理由新的生产者程序产生的、符合新模式 $S_{new}$ 的数据。也就是说，对于任何消息 $m \in L(S_{new})$，消费者 $C_{old}(m)$ 仍然能够被定义（即不会崩溃或出错）。例如，从一个只包含必需字段的模式 $S_0$ 演化到 $S_1$，其中只是增加了一个带有默认值的可选字段。对于一个能够忽略未知字段的“宽容”型消费者而言，这种演化是向后兼容的。

*   **向前兼容性 (Forward Compatibility)**：指新的消费者程序能够处理由旧的生产者程序产生的、符合旧模式 $S_{old}$ 的数据。例如，在上述 $S_0 \to S_1$ 的演化中，一个针对 $S_1$ 构建的新消费者，当它收到一条来自旧模式 $S_0$ 的消息时，它能够处理缺失的那个可选字段（例如使用其默认值），因此这种演化是向前兼容的。

*   **完全兼容性 (Full Compatibility)**：同时满足向后兼容性和向前兼容性。

兼容性还可以根据其保证的程度分为**弱兼容性**和**强兼容性**：

*   **弱兼容性 (Weak Compatibility)** 仅仅保证语法上的可[解析性](@entry_id:140716)。消费者程序不会因为遇到未知字段或可兼容的类型变化（如从整数到浮点数）而崩溃，但其业务逻辑的正确性无法保证。例如，如果一个字段的单位从摄氏度变为华氏度，而消费者程序对此并不知情，它虽然能解析出数值，但会做出完全错误的判断。

*   **强兼容性 (Strong Compatibility)** 则保证了**语义守恒**。这意味着存在一个适配器（adapter），可以将新模式下的消息转换为旧模式下的消息，使得消费者程序的“可观察语义”（即基于其所关心字段的计算结果）保持不变。这通常需要模式系统支持字段别名、[单位转换](@entry_id:136593)等元数据。

不同的模式语言对演化提供了不同程度的支持。例如，Apache Avro定义了明确的**读写模式解析 (writer-reader schema resolution)** 规则，可以自动处理字段的增删和重命名（通过[别名](@entry_id:146322)），提供了强大的兼容性保证。Protocol Buffers则依赖于稳定不变的数字**字段标签 (field tags)**，只要标签不变，字段名可以随意更改，从而实现兼容性。相比之下，JSON Schema和XSD本身并未标准化自动的跨版本解析流程，兼容性管理更多地依赖于约定和外部工具 。

### [语义互操作性](@entry_id:923778)：建立共享的意义

语法[互操作性](@entry_id:750761)解决了“如何解析数据”的问题，而**[语义互操作性](@entry_id:923778) (Semantic Interoperability)** 则解决了“如何理解数据”的问题。它确保不同的系统能够对同一份数据达成共识，消除[歧义](@entry_id:276744)。

想象一个场景：两个[数字孪生](@entry_id:171650)在交换关于设备转速的数据。一个孪生使用字段名 `rotational_speed`，单位是**弧度/秒 (rad/s)**；另一个孪生使用字段名 `rpm`，单位是**转/分钟 (revolutions per minute)**。尽管它们都使用相同的JSON格式，并且数据类型都是浮点数，但一个简单的应用如果直接比较这两个值，将会得出灾难性的错误结论。这个问题暴露了[语义互操作性](@entry_id:923778)的两大核心挑战：**同义词问题**（`rotational_speed` 和 `rpm` 都指代转速）和**单位不一致问题** 。

要解决这些问题，我们需要超越[数据结构](@entry_id:262134)本身，引入能够被机器解释的意义模型。

#### [本体](@entry_id:264049)与受控词表

**本体 (Ontology)** 是一种对特定领域知识的明确、形式化的规约。在[数字孪生](@entry_id:171650)领域，[本体](@entry_id:264049)通过为概念、属性和关系提供唯一的标识符和形式化的公理，来建立一个共享的意义框架。**Web本体语言 (Web Ontology Language, OWL)** 是构建[本体](@entry_id:264049)的W3C标准。一个OWL本体通常包含：

*   **术语公理集 (Terminological Box, TBox)**：定义了领域的通用概念（类）和它们之间的关系（属性）。例如，TBox可以声明 `ex:rotational_speed` 和 `ex:rpm` 都是 `ex:AngularVelocity` 这个概念的子属性或等价属性。
*   **断言公理集 (Assertional Box, ABox)**：包含了关于领域中具体实例（个体）的断言。例如，`MyMotor ex:hasAngularVelocity 10.47`。

通过使用[本体](@entry_id:264049)，我们可以将数据中的符号（如JSON字段名）“锚定”到[本体](@entry_id:264049)中定义明确的概念上。这样，一个**[推理机](@entry_id:154913) (Reasoner)** 就可以利用TBox中的公理，自动推断出 `rotational_speed` 和 `rpm` 指的是同一回事，从而实现自动化的数据融合 。

与本体密切相关的是**受控词表 (Controlled Vocabulary)**，它为特定领域的术语提供了明确的定义和唯一的标识符。在处理物理量时，单位的互操作性至关重要。

*   **统一单位代码 (Unified Code for Units of Measure, UCUM)** 是一种用于在电子系统中明确表示和交换计量单位的标准。它的核心作用是提供一套无[歧义](@entry_id:276744)的**语法**，用于书写和解析单位字符串（例如，`m/s` 代表米每秒，`[in_i]` 代表国际英寸）。这解决了单位表示不一的语法问题。

*   **量、单位、维度和数据类型 (Quantities, Units, Dimensions and Data Types, QUDT)** 是一个更为丰富的**语义**词表。它不仅定义了单位，还定义了**量纲 (Dimension)** 和**量的种类 (Quantity Kind)**。通过QUDT，我们可以将一个UCUM单位字符串关联到其完整的物理上下文中。例如，QUDT可以告诉我们，“牛顿米 (N.m)”的量纲是 $M \cdot L^2 \cdot T^{-2}$，并且它可以同时是“能量”和“力矩”这两个不同量的种类的单位。

一个健壮的单位[互操作性](@entry_id:750761)框架，需要同时使用UCUM和QUDT。UCUM负责解析和规范化单位的语法表达，而QUDT则提供必要的语义信息，以进行[量纲一致性](@entry_id:271193)检查（例如，不能将长度和质量相加）、正确的[单位转换](@entry_id:136593)（包括处理像温度这样的**仿射标度**，其转换公式为 $x' = \alpha x + \beta$），以及区分具有相同量纲但不同物理意义的量（如能量与力矩）。

### [互操作性](@entry_id:750761)的特定领域

除了通用的语法和语义挑战，数字孪生在多个特定领域也面临着独特的互操作性需求，并催生了相应的标准和机制。

#### 身份标识

互操作的第一步是能够唯一地指代同一个事物。一个全局、持久、可解析的**标识符 (Identifier)** 体系是数字孪生态系统的基石。

*   **UUID (Universally Unique Identifier)**：一个128位的数字，其设计目标是在没有中心协调的情况下实现大规模的唯一性。例如，版本4的UUID使用122位随机数，在生成 $10^8$ 个标识符时，发生碰撞（即重复）的概率大约在 $10^{-21}$ 的量级，在实践中可以认为是唯一的。UUID的优点是支持离线、分布式生成，但其本身只是一个数字，不包含任何可解析的信息 。

*   **URI (Uniform Resource Identifier)** 和 **IRI (Internationalized Resource Identifier)**：URI（特别是基于HTTP的URL）提供了一个全球性的、可解析的标识符方案。其唯一性由域名系统（DNS）的层级化治理模型保证。IRI则是URI的扩展，允许使用非[ASCII](@entry_id:163687)字符，更便于人类阅读。URI/IRI的主要优势在于其**可[解析性](@entry_id:140716) (Resolvability)**——可以通过网络协议（如HTTP）获取被标识资源的表示或元数据。

一个最佳实践是将UUID和URI结合使用：使用UUID保证全局唯一性并支持离线生成，然后将其嵌入到一个由特定组织管理的、基于DNS的HTTP URI模板中（例如，`https://example.org/twins/uuid/{uuid-string}`）。这样既获得了UUID的唯一性和分布式生成能力，又获得了URI的可[解析性](@entry_id:140716)和明确的治理归属 。

#### [时序数据](@entry_id:636380)

数字孪生是动态的，其数据通常是带有时间戳的事件流。在分布式环境中，正确[处理时间](@entry_id:196496)是保证[数据一致性](@entry_id:748190)的关键。

*   **墙上时钟时间 (Wall-Clock Time)**：这是我们日常使用的、与现实世界同步的时间（例如，通过NTP协议同步的UTC时间）。它的主要作用是在不同数据源之间对齐事件，将它们放置在一个共同的现实时间轴上。然而，墙上时钟可能会因为NTP的**步进式校正 (step correction)** 而发生跳跃甚至倒退。

*   **单调时钟时间 (Monotonic Time)**：这是一种从某个时间点（如系统启动）开始计数的、严格单调递增的时钟。它不受墙上时钟校正的影响。它的主要作用是精确地记录在**同一个数据源内部**事件发生的先后顺序（即“发生于……之前”关系）。

一个健壮的时序[数据[互操作](@entry_id:926300)性](@entry_id:750761)策略必须同时使用这两种时间。事件数据应包含：(1) 一个符合 **ISO 8601** 标准、带有明确时区偏移（如`Z`表示UTC）和足够精度（如毫秒或微秒）的墙上时钟时间戳，用于跨源对齐；(2) 一个来自源内部的单调计数器。在合并来自多个源的事件流时，应采用一个复合排序键：首先按墙上时钟时间戳排序，当时间戳相同时，再按一个唯一的、稳定的源标识符排序，最后可按单调计数器排序，以确保最终的事件序列是确定且可复现的 。

#### 地理空间数据

许多数字孪生（如城市、交通、管网）都与地理空间位置紧密相关。地理[空间数据](@entry_id:924273)的互操作性核心在于处理**[坐标参考系统](@entry_id:1123059) (Coordinate Reference System, CRS)**。

*   **CRS** 定义了如何将地球表面的位置映射到一组数字坐标。不同的CRS（如投影坐标系和地理坐标系）使用不同的基准、单位和投影方法。**EPSG代码** 是一个为全球数千种CRS分配唯一数字标识符的权威注册表（例如，`EPSG:4326` 代表WGS 84地理坐标系，`EPSG:25832` 代表ETRS89 / UTM zone 32N投影坐标系）。

*   **WKT (Well-Known Text)** 是一种用于详细描述CR[S参数](@entry_id:754557)（如基准、[椭球体](@entry_id:165811)、投影方法、单位、轴向等）的文本格式。

*   **GeoJSON** 是一种基于JSON的、用于编码地理[数据结构](@entry_id:262134)的开放标准格式。根据其最新标准 **RFC 7946**，GeoJSON有一个严格规定：所有坐标**必须**是WGS 84（即`EPSG:4326`）下的经纬度，并且坐标顺序**必须**是“经度-纬度”。同时，标准禁止在GeoJSON文档中声明自定义的CRS。

当需要将一个使用投影坐标（如UTM，单位为米）的系统数据，与另一个使用地理坐标的系统[数据集成](@entry_id:748204)，并统一以GeoJSON格式发布时，正确的集成策略是：
1.  明确识别源CRS（如`EPSG:25832`）和目标CRS（`EPSG:4326`）。
2.  执行一个精确的**坐标转换**操作，将源坐标从米转换为WGS 84下的经纬度。
3.  在生成GeoJSON时，严格遵守“经度-纬度”的坐标顺序。
4.  不在输出的GeoJSON中包含任何已废弃的`crs`成员。
任何跳过坐标转换或搞错坐标轴顺序的做法，都会导致地理位置的严重错误 。

### 形式化与验证[互操作性](@entry_id:750761)

为了构建可扩展、可维护且真正可互操作的数字孪生态系统，我们需要超越临时的解决方案，采用更形式化和系统化的方法来定义和验证互操作性。

#### 模型驱动的[互操作性](@entry_id:750761)

模型驱动工程 (Model-Driven Engineering, MDE) 提供了一种强大的方法论，即通过建立一个**元模型 (Metamodel)** 来形式化地定义[数字孪生](@entry_id:171650)的“语言”。**元对象设施 (Meta Object Facility, MOF)** 是一个定义元模型的标准，它提供了一个四层架构：

*   **M3 (元元模型层)**：定义了构建元模型的基本概念，如`Class`, `Attribute`, `Association`。
*   **M2 (元模型层)**：定义了特定领域（如[数字孪生](@entry_id:171650)）的语言。例如，我们可以创建一个M2元模型来定义**数字孪生定义语言 (Digital Twins Definition Language, DTDL)** 的核心概念，如`Interface`, `Property`, `Telemetry`, `Relationship` 等，以及它们之间的关系和约束。
*   **M1 (模型层)**：是M2元模型的实例。一个具体的DTDL接口定义（例如，一个“[恒温器](@entry_id:143395)”接口的JSON-LD文件）就是一个M1模型。
*   **M0 (数据/实例层)**：是M1模型的实例。一个正在运行的、具体的[恒温器](@entry_id:143395)[数字孪生](@entry_id:171650)实例就是M0层的数据。

通过这种分层方法，我们可以精确地定义数字孪生应该具备哪些结构和能力，并为自动化的[代码生成](@entry_id:747434)、验证和模型转换奠定坚实的基础 。

#### [知识图谱](@entry_id:906868)[互操作性](@entry_id:750761)

当[数字孪生](@entry_id:171650)之间的关系变得复杂时，我们需要一个能够表达丰富连接和上下文的数据模型。[知识图谱](@entry_id:906868)为此提供了两种主流选择：

1.  **资源描述框架 (Resource Description Framework, RDF)**：作为W3C语义网技术栈的基石，RDF使用三元组 `(主语, 谓语, 宾语)` 来描述事物及其关系。其核心优势在于，主语、谓语和作为资源的宾语都由全局唯一的IRI标识，这为跨系统、去中心化的[数据融合](@entry_id:141454)提供了天然的基础。然而，RDF的基本模型是[二元关系](@entry_id:270321)。要描述一个关系本身的属性（例如，A“测量”B这个事实的发生时间），需要使用**具体化 (Reification)** 或命名图等更复杂的模式。

2.  **标记属性图 (Labeled Property Graph, LPG)**：LPG模型在工业界（特别是图数据库领域）被广泛采用。它由节点和关系组成，节点和关系都可以拥有标签和一组键值对形式的属性。LPG的优势在于其直观性，特别是它可以直接在关系（边）上附加属性，这使得对关系进行元[数据标注](@entry_id:635459)变得非常简单。然而，LPG的节点和关系标识符通常是系统本地的，缺乏一个内置的全局唯一性机制，这给跨系统的[数据集成](@entry_id:748204)带来了挑战。

在选择数据模型时，需要权衡RDF在全局互操作性上的优势与LPG在模型直观性上的便利 。

#### 符合性测试

声称遵循某个标准并不等同于真正实现了互操作性。**符合性测试 (Conformance Testing)** 是验证一个实现是否严格遵守其所声称标准的所有强制性规范的系统过程。一个严谨的符合性测试框架包括：

*   **测试套件 (Test Suite)**：一组可执行的测试用例，旨在覆盖标准的所有**规范性要求 (normative requirements)**。
*   **正面与负面测试**：正面[测试验证](@entry_id:921279)实现对有效输入的处理是否正确；负面测试则验证实现对无效输入的拒绝和错误处理是否符合规范。
*   **测试预言机 (Test Oracle)**：用于判断测试结果是否正确的权威来源。真正的预言机是标准规范本身，而不是任何特定的实现。
*   **参考实现 (Reference Implementation)**：一个已知良好（但不一定是完美）的实现。它不应被用作唯一的预言机，但可以作为互操作测试的伙伴或进行差异化比较的基准。

针对数字孪生中常用的标准，如[OPC UA](@entry_id:1129137)（设备层协议）、NGSI-LD（上下文信息API）和[SHACL](@entry_id:1131523)（语义约束验证），都需要进行多层次的符合性测试，从协议层的握手和编码，到API层的HTTP交互和JSON-LD上下文处理，再到数据层的RDF图谱验证，以确保端到端的互操作性得以实现 。

### 组织互操作性：数据空间与主权

最后，互操作性的范畴从技术层面延伸至组织层面。当数字孪生态系统跨越多个企业或组织时，信任、安全和数据控制成为首要问题。

**数据空间 (Data Space)** 是一个由多个参与方组成的、基于共同规则和标准进行可信数据共享的**联邦式 (federated)** 生态系统。其核心原则是：

*   **[数据主权](@entry_id:902387) (Data Sovereignty)**：数据提供方在数据共享后，依然保留对数据的有效控制权。这需要技术手段来强制执行数据使用策略（例如，数据仅可用于聚合分析、30天后必须删除等）。

*   **互操作性 (Interoperability)**：在数据空间内，来自不同参与方的[异构数据](@entry_id:265660)和系统能够无缝对接和协同工作。

*   **信任 (Trust)**：参与方的身份和声明是可验证的，并且交互的安全保证级别可以量化和评估。

为了实现这样一个联邦式的数据空间，**国际数据空间协会 (International Data Spaces Association, IDSA)** 和 **Gaia-X** 等倡议提供了关键的架构和规范。IDSA定义了一个**连接器 (Connector)** 架构，它作为数据交换的网关，能够强制执行数据使用策略（所谓的“粘性策略”），并管理参与方的身份。Gaia-X则提供了一个更高层次的联邦服务框架，通过**[可验证凭证](@entry_id:896439) (Verifiable Credentials)** 和**去中心化标识符 (Decentralized Identifiers)** 等技术，建立一个去中心化的信任基础设施，使得参与方可以在不依赖中央机构、不集中存储数据的前提下，实现安全、合规、主权可控的数据共享 。

综上所述，从底层的语法解析到顶层的组织信任，[数字孪生](@entry_id:171650)的[数据互操作性](@entry_id:926300)是一个层层递进、环环相扣的体系。只有在每个层面上都采用严谨的原理和成熟的机制，才能构建起一个真正互联互通、智能协同的数字孪生世界。