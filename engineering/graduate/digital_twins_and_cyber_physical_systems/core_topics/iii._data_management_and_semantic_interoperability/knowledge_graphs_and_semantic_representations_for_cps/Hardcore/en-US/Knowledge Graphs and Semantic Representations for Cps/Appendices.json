{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of building robust knowledge graphs for Cyber-Physical Systems is the ability to precisely define what constitutes a valid entity. This first practice focuses on translating a formal requirement—that a `SensingDevice` must have at least one `Measurement` output—into a concrete OWL class expression using a qualified cardinality restriction. By implementing a validation algorithm based on the model-theoretic semantics of Description Logics, you will gain hands-on experience in bridging the gap between abstract logical definitions and their practical application in code .",
            "id": "4228925",
            "problem": "You are working within the domain of knowledge graphs and semantic representations for Cyber-Physical Systems (CPS), targeting the Web Ontology Language (OWL) class modeling of devices and their outputs. The fundamental base for this problem is the model-theoretic semantics of Description Logic (DL) underlying OWL, where classes are interpreted as sets and properties as binary relations over a universe of discourse. Specifically, rely on the following fundamentals:\n- An interpretation assigns to each class symbol a subset of a domain and to each property symbol a binary relation over the domain.\n- A cardinality restriction on a property counts the number of distinct successors satisfying a given class membership under that property, aligned with set-theoretic counting and relational composition.\n\nObjective: Construct the OWL class expression for a SensingDevice that must have at least one Measurement output and demonstrate how this requirement is captured using an OWL restriction with minimum cardinality. Then, implement an algorithm that, given a finite knowledge graph consisting of individual types and property edges, decides for each test instance whether it satisfies the qualified minimum cardinality requirement.\n\nDefinitions to use:\n- Let $\\Delta^{I}$ denote the universe of interpretation.\n- Let $P^{I} \\subseteq \\Delta^{I} \\times \\Delta^{I}$ denote the interpretation of a property.\n- Let $C^{I} \\subseteq \\Delta^{I}$ denote the interpretation of a class.\n- A qualified minimum cardinality restriction is satisfied by an individual $x \\in \\Delta^{I}$ if the number of distinct $P^{I}$-successors of $x$ that are in $C^{I}$ is at least $n$, for some integer $n \\ge 0$.\n\nTask details:\n1. Formulate the class expression for “SensingDevice with at least one Measurement output” using a qualified minimum cardinality restriction on the property “hasOutput” relative to the class “Measurement,” with the minimum count $n = 1$. Do not present the target formula directly in the problem statement; instead, your algorithmic solution must derive it from the aforementioned fundamentals of interpretation and cardinality.\n2. Implement a program that:\n   - Represents a small knowledge graph with individuals, their types, and a property adjacency structure for “hasOutput.”\n   - For each test case device, computes whether it satisfies the qualified minimum cardinality requirement “hasOutput at least $1$ Measurement” by counting distinct successors typed as Measurement.\n   - Returns a boolean for each test case indicating satisfaction.\n\nAssumptions:\n- Counting is over distinct successors, that is, if there are repeated edges to the same individual, they contribute only once to the cardinality.\n- An edge $(x,y)$ contributes to the count only if $y$ is typed as Measurement.\n- Absence of a property edge yields a count of $0$.\n\nTest suite:\nUse the following six test cases. Each case is a self-contained configuration of types and property edges for a single device identifier. The property of interest is “hasOutput,” the target class is “Measurement,” and the minimum qualified cardinality is $1$.\n\n- Case A (happy path): Device $s_1$ has one output $m_1$; $m_1$ is typed Measurement.\n  - Types: $s_1 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$\n  - Edges: $(s_1, \\text{hasOutput}, m_1)$\n  - Expected boolean: True\n\n- Case B (boundary: duplicates do not inflate cardinality): Device $s_2$ has two edges to the same output $m_1$; $m_1$ is typed Measurement; distinct count is $1$.\n  - Types: $s_2 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$\n  - Edges: $(s_2, \\text{hasOutput}, m_1)$ twice\n  - Expected boolean: True\n\n- Case C (edge case: zero outputs): Device $s_3$ has no outputs.\n  - Types: $s_3 \\mapsto \\{\\text{SensingDevice}\\}$\n  - Edges: none\n  - Expected boolean: False\n\n- Case D (failure: non-measurement output only): Device $s_4$ has one output $nm_1$; $nm_1$ is typed NonMeasurement.\n  - Types: $s_4 \\mapsto \\{\\text{SensingDevice}\\}$, $nm_1 \\mapsto \\{\\text{NonMeasurement}\\}$\n  - Edges: $(s_4, \\text{hasOutput}, nm_1)$\n  - Expected boolean: False\n\n- Case E (mixed outputs): Device $s_5$ has outputs $m_2$ and $nm_1$; $m_2$ is typed Measurement; $nm_1$ is typed NonMeasurement; distinct Measurement count is $1$.\n  - Types: $s_5 \\mapsto \\{\\text{SensingDevice}\\}$, $m_2 \\mapsto \\{\\text{Measurement}\\}$, $nm_1 \\mapsto \\{\\text{NonMeasurement}\\}$\n  - Edges: $(s_5, \\text{hasOutput}, m_2)$ and $(s_5, \\text{hasOutput}, nm_1)$\n  - Expected boolean: True\n\n- Case F (multiple distinct measurement outputs): Device $s_6$ has outputs $m_1$ and $m_2$; both typed Measurement; distinct count is $2 \\ge 1$.\n  - Types: $s_6 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$, $m_2 \\mapsto \\{\\text{Measurement}\\}$\n  - Edges: $(s_6, \\text{hasOutput}, m_1)$ and $(s_6, \\text{hasOutput}, m_2)$\n  - Expected boolean: True\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, “[result1,result2,...]”), where each result is a boolean corresponding to the cases A through F in order.",
            "solution": "The problem is valid. It is scientifically grounded in the formal model-theoretic semantics of Description Logics (DL), which form the basis for the Web Ontology Language (OWL). The problem is well-posed, providing a clear objective, complete definitions, and a set of unambiguous test cases. It correctly tasks the user with applying the formal definition of a qualified cardinality restriction to a practical verification algorithm.\n\nThe core of this problem is to formalize and verify a statement about a class of objects within a knowledge graph. The statement is: “a `SensingDevice` that has at least one output which is a `Measurement`.” This is a common modeling pattern in designing ontologies for Cyber-Physical Systems (CPS), where ensuring data integrity and proper system composition is critical.\n\nWe begin by formalizing the statement using the concepts of Description Logic. Let the base class be $SensingDevice$, the property be $hasOutput$, and the qualifying class for the output be $Measurement$. The requirement can be expressed as a complex class definition, which is the intersection (conjunction) of the base class and a restriction on its property.\n\nThe restriction is a qualified minimum cardinality restriction. In DL syntax, it is written as $(\\ge n \\ P.C)$, where $n$ is the minimum number of connections, $P$ is the property, and $C$ is the qualifying class for the objects connected via $P$. For our specific case, the property $P$ is $hasOutput$, the qualifying class $C$ is $Measurement$, and the minimum number of connections $n$ is $1$. The restriction is therefore $(\\ge 1 \\ hasOutput.Measurement)$.\n\nThe complete class expression for a “SensingDevice with at least one Measurement output” is the intersection of the base class and this restriction:\n$$\nSensingDevice \\sqcap (\\ge 1 \\ hasOutput.Measurement)\n$$\nwhere $\\sqcap$ denotes the class intersection operator.\n\nTo understand how this formal expression is verified, we turn to the model-theoretic semantics provided. An interpretation $\\mathcal{I} = (\\Delta^{\\mathcal{I}}, \\cdot^{\\mathcal{I}})$ consists of a non-empty domain of individuals $\\Delta^{\\mathcal{I}}$ and an interpretation function $\\cdot^{\\mathcal{I}}$ that maps class names to subsets of $\\Delta^{\\mathcal{I}}$ and property names to binary relations on $\\Delta^{\\mathcal{I}}$.\n\nAn individual $x \\in \\Delta^{\\mathcal{I}}$ is an instance of the class expression $SensingDevice \\sqcap (\\ge 1 \\ hasOutput.Measurement)$ if and only if it satisfies both parts of the conjunction:\n$1$. $x \\in (SensingDevice)^{\\mathcal{I}}$\n$2$. $x \\in (\\ge 1 \\ hasOutput.Measurement)^{\\mathcal{I}}$\n\nThe first condition simply means that the individual $x$ must be of type $SensingDevice$. The second condition is defined by the semantics of qualified minimum cardinality restrictions. An individual $x$ satisfies this condition if the cardinality of the set of its distinct successors via the $hasOutput$ property, which are also members of the $Measurement$ class, is greater than or equal to $1$. Formally:\n$$\n|\\{ y \\in \\Delta^{\\mathcal{I}} \\mid (x, y) \\in (hasOutput)^{\\mathcal{I}} \\land y \\in (Measurement)^{\\mathcal{I}} \\}| \\ge 1\n$$\nHere, $(hasOutput)^{\\mathcal{I}}$ is the set of all pairs $(u,v)$ related by the $hasOutput$ property, and $(Measurement)^{\\mathcal{I}}$ is the set of all individuals of type $Measurement$. The set $\\{ y \\in \\Delta^{\\mathcal{I}} \\mid \\dots \\}$ collects all distinct individuals $y$ that are connected to $x$ via $hasOutput$ and are typed as $Measurement$. The operator $|\\cdot|$ calculates the size of this set.\n\nThe algorithm to verify this condition for a given device in a finite knowledge graph directly implements this semantic definition.\n$1$. **Identify the device ($x$)** to be checked from the test case.\n$2$. **Retrieve all successors ($y$)** of $x$ connected by the $hasOutput$ property. This corresponds to finding all $y$ such that the edge $(x, \\text{hasOutput}, y)$ exists in the graph. The problem specifies that absence of an edge results in a count of $0$, which happens naturally if this set is empty.\n$3$. **Ensure distinctness**. The semantic definition counts elements of a set, so any duplicate successors must be counted only once. This is achieved by creating a set of the successor individuals.\n$4$. **Filter by type**. For each distinct successor $y$, we check if it is an instance of the $Measurement$ class. This corresponds to checking if $y \\in (Measurement)^{\\mathcal{I}}$.\n$5$. **Count and compare**. We count the number of distinct successors that meet the type requirement. Let this count be $c$. The condition is satisfied if $c \\ge 1$.\n\nThis step-by-step procedure is implemented for each of the six test cases provided, yielding a boolean result indicating whether the device in each case is a member of the defined class. For instance, in Case E, device $s_5$ has two distinct successors, $m_2$ and $nm_1$. Of these, only $m_2$ is of type $Measurement$. The count of qualified successors is therefore $1$. Since $1 \\ge 1$, the condition is met and the result is True. In Case D, device $s_4$ has one successor, $nm_1$, which is not of type $Measurement$. The count is $0$. Since $0 < 1$, the condition is not met and the result is False. This logic is applied consistently across all cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates devices against a qualified minimum cardinality restriction.\n    \n    The problem asks to implement a check for the Description Logic class expression:\n    SensingDevice ⊓ (≥ 1 hasOutput.Measurement)\n    \n    This means for a device to be valid, it must have at least one distinct\n    successor via the 'hasOutput' property that is of type 'Measurement'.\n    \"\"\"\n\n    # Test suite definition. Each case represents a small knowledge graph\n    # configuration for a single device under test.\n    # Structure: (device_id_to_check, types_dictionary, edges_dictionary)\n    # - types_dictionary: maps individual IDs to a set of their class types.\n    # - edges_dictionary: maps a source ID to a list of target IDs for the\n    #   'hasOutput' property.\n    test_cases = [\n        # Case A: Happy path. s1 has one Measurement output.\n        (\n            's1',\n            {'s1': {'SensingDevice'}, 'm1': {'Measurement'}},\n            {'s1': ['m1']}\n        ),\n        # Case B: Boundary. Duplicate edges to the same output count as one.\n        (\n            's2',\n            {'s2': {'SensingDevice'}, 'm1': {'Measurement'}},\n            {'s2': ['m1', 'm1']}\n        ),\n        # Case C: Edge case. s3 has no outputs.\n        (\n            's3',\n            {'s3': {'SensingDevice'}},\n            {} # No edges for s3\n        ),\n        # Case D: Failure. s4's only output is not a Measurement.\n        (\n            's4',\n            {'s4': {'SensingDevice'}, 'nm1': {'NonMeasurement'}},\n            {'s4': ['nm1']}\n        ),\n        # Case E: Mixed outputs. s5 has one Measurement and one non-Measurement.\n        (\n            's5',\n            {'s5': {'SensingDevice'}, 'm2': {'Measurement'}, 'nm1': {'NonMeasurement'}},\n            {'s5': ['m2', 'nm1']}\n        ),\n        # Case F: Multiple distinct Measurement outputs.\n        (\n            's6',\n            {'s6': {'SensingDevice'}, 'm1': {'Measurement'}, 'm2': {'Measurement'}},\n            {'s6': ['m1', 'm2']}\n        ),\n    ]\n\n    results = []\n    # Parameters for the qualified cardinality restriction\n    target_class = 'Measurement'\n    min_cardinality = 1\n\n    for device_id, types, edges in test_cases:\n        # Retrieve the list of successors for the device via 'hasOutput'.\n        # If the device has no outgoing edges, .get() returns an empty list.\n        successors = edges.get(device_id, [])\n\n        # The semantics require counting *distinct* successors. A set handles this.\n        distinct_successors = set(successors)\n\n        # Count the number of distinct successors that are of the target class.\n        qualified_count = 0\n        for successor_id in distinct_successors:\n            # Get the types of the successor. Default to an empty set if not found.\n            successor_types = types.get(successor_id, set())\n            if target_class in successor_types:\n                qualified_count += 1\n        \n        # Check if the count meets the minimum cardinality requirement.\n        is_satisfied = qualified_count >= min_cardinality\n        results.append(is_satisfied)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str, ...) converts each boolean (True/False) to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond validating individual entities, the true power of semantic technologies lies in automated reasoning. This exercise explores two fundamental inference patterns: traversing class hierarchies using Resource Description Framework Schema (RDFS) subclassing and merging duplicate entities using the Web Ontology Language (OWL) identity relation, `owl:sameAs`. You will first write a SPARQL query to materialize the class hierarchy and then implement an algorithm to see how identity resolution can dramatically change the results of analytical queries, such as counting the number of assets in a given category .",
            "id": "4228964",
            "problem": "You are given a scenario in which Cyber-Physical System (CPS) asset categories are represented in a Resource Description Framework (RDF) knowledge graph. Reasoning over the Resource Description Framework Schema (RDFS) subclass hierarchy and the Web Ontology Language (OWL) identity relation must be handled in a principled way. The fundamental base consists of the following assumptions: the RDFS subclass relation is reflexive and transitive, and the OWL identity relation equates Internationalized Resource Identifiers (IRIs) into equivalence classes. Formally, let $C$ be a finite set of classes and let $R \\subseteq C \\times C$ be the explicit subclass relation. The reflexive-transitive closure $R^{*}$ satisfies that for all $c \\in C$, $(c,c) \\in R^{*}$, and for all $c_{1},c_{2},c_{3} \\in C$, if $(c_{1},c_{2}) \\in R^{*}$ and $(c_{2},c_{3}) \\in R^{*}$ then $(c_{1},c_{3}) \\in R^{*}$. Let $I$ be a finite set of asset IRIs and let $E \\subseteq I \\times I$ be the OWL identity relation denoted as $owl:sameAs$, which is an equivalence relation, that is, $E$ is reflexive, symmetric, and transitive. A type assertion is a pair $(i,c)$ with $i \\in I$ and $c \\in C$ indicating that the asset IRI $i$ has type $c$.\n\nTask A: Write a SPARQL CONSTRUCT query that materializes the RDFS subclass closure restricted to CPS asset categories, assumed to be under the namespace prefix “cps:” with a root category “cps:AssetCategory”. The query must produce all triples of the form “?c rdfs:subClassOf ?sup” where $(c,sup) \\in R^{*}$ and $c$ is reachable from “cps:AssetCategory” via $R^{*}$. Explain, in terms of the OWL identity relation $owl:sameAs$, why materializing inferred triples may change the answers of SELECT queries that count assets, if equivalence class merging is or is not performed.\n\nTask B: Implement a program that performs the following computations for multiple test cases, each consisting of:\n- A finite set of CPS classes $C$.\n- A set of explicit RDFS subclass edges $R$.\n- A mapping of asset IRIs $I$ to their asserted classes.\n- A set of OWL identity pairs $E$ representing $owl:sameAs$ statements.\n- A designated target supercategory $c_{\\mathrm{target}} \\in C$.\n\nFor each test case, your program must:\n1. Compute the reflexive-transitive closure $R^{*}$ over the given $R$.\n2. Propagate types upward: for each $(i,c)$, infer $(i,s)$ for all $s$ such that $(c,s) \\in R^{*}$.\n3. Compute the raw count $n_{\\mathrm{raw}}$ as the number of distinct IRIs $i \\in I$ that have inferred type $c_{\\mathrm{target}}$ after upward propagation.\n4. Compute the merged count $n_{\\mathrm{merged}}$ by collapsing $I$ into equivalence classes induced by $E$, and counting how many distinct equivalence classes contain at least one IRI with inferred type $c_{\\mathrm{target}}$ after upward propagation.\n5. Return a boolean flag $b_{\\mathrm{changed}}$ that is $true$ if and only if $n_{\\mathrm{raw}} \\neq n_{\\mathrm{merged}}$.\n\nYour program should output the results for the provided test suite as a single line containing a comma-separated list enclosed in square brackets, where each element is a per-test-case list of the form “[n_raw,n_merged,b_changed]” with no spaces. For example, “[ [a,b,c], [d,e,f] ]” must be printed as “[ [a,b,c],[d,e,f] ]” but with no spaces; thus the exact required format is “[list1,list2,...]” and within each list there also must be no spaces.\n\nTest Suite:\nUse the following three test cases, covering a general case, a case with $owl:sameAs$ aliasing, and a boundary condition with subclass cycles.\n\nTest case one (general chain with multiple assets):\n- Classes $C$: {\"cps:AssetCategory\",\"cps:Sensor\",\"cps:TemperatureSensor\",\"cps:Actuator\"}.\n- Subclass edges $R$: {(\"cps:Sensor\",\"cps:AssetCategory\"),(\"cps:TemperatureSensor\",\"cps:Sensor\"),(\"cps:Actuator\",\"cps:AssetCategory\")}.\n- Asset types: {(\"asset_alpha\",\"cps:TemperatureSensor\"),(\"asset_beta\",\"cps:Sensor\"),(\"asset_gamma\",\"cps:Actuator\")}.\n- Identity $E$: empty set.\n- Target $c_{\\mathrm{target}}$: \"cps:AssetCategory\".\nExpected qualitative behavior: upward propagation should type all assets as \"cps:AssetCategory\".\n\nTest case two (aliasing under $owl:sameAs$):\n- Classes $C$: {\"cps:AssetCategory\",\"cps:Sensor\",\"cps:TemperatureSensor\",\"cps:Actuator\"}.\n- Subclass edges $R$: {(\"cps:Sensor\",\"cps:AssetCategory\"),(\"cps:TemperatureSensor\",\"cps:Sensor\"),(\"cps:Actuator\",\"cps:AssetCategory\")}.\n- Asset types: {(\"asset_delta\",\"cps:Sensor\"),(\"asset_delta_alias\",\"cps:Sensor\"),(\"asset_epsilon\",\"cps:TemperatureSensor\"),(\"asset_epsilon_alias\",\"cps:TemperatureSensor\")}.\n- Identity $E$: {(\"asset_delta\",\"asset_delta_alias\"),(\"asset_epsilon\",\"asset_epsilon_alias\")}.\n- Target $c_{\\mathrm{target}}$: \"cps:AssetCategory\".\nExpected qualitative behavior: raw counting uses distinct IRIs; merged counting uses equivalence classes, reducing the count.\n\nTest case three (boundary with subclass cycle and identity):\n- Classes $C$: {\"cps:AssetCategory\",\"cps:X\",\"cps:Y\"}.\n- Subclass edges $R$: {(\"cps:X\",\"cps:Y\"),(\"cps:Y\",\"cps:X\"),(\"cps:X\",\"cps:AssetCategory\"),(\"cps:Y\",\"cps:AssetCategory\")}.\n- Asset types: {(\"asset_zeta\",\"cps:X\"),(\"asset_eta\",\"cps:Y\")}.\n- Identity $E$: {(\"asset_zeta\",\"asset_eta\")}.\n- Target $c_{\\mathrm{target}}$: \"cps:AssetCategory\".\nExpected qualitative behavior: the cycle ensures both classes are above each other but both lead to the target; identity merges the two IRIs.\n\nThe final output format must be a single line with the three per-test-case results in order, as a comma-separated list enclosed in square brackets, with no spaces anywhere. Each per-test-case element must be a list of the form “[n_raw,n_merged,b_changed]”, and the overall output must look like “[result_case_one,result_case_two,result_case_three]”, where “result_case_*” are the per-case lists without spaces.",
            "solution": "The problem is well-posed, scientifically grounded in the formal semantics of RDF Schema (RDFS) and the Web Ontology Language (OWL), and provides a complete and consistent set of definitions and data for computation. The tasks are algorithmically tractable and directly relevant to reasoning over knowledge graphs in a Cyber-Physical System (CPS) context. Therefore, the problem is valid.\n\n### Task A: SPARQL Query and Explanation\n\nThe first task is to provide a SPARQL `CONSTRUCT` query to materialize the reflexive-transitive closure of the `rdfs:subClassOf` hierarchy and to explain the effect of `owl:sameAs` on asset counting queries.\n\n#### SPARQL `CONSTRUCT` Query\n\nSPARQL $1.1$ supports property paths, which allow for the concise expression of traversal over a graph. The reflexive-transitive closure of a property `p` can be expressed as `p*`. The problem asks for the materialization of all pairs $(c, \\text{sup}) \\in R^*$, where $R^*$ is the reflexive-transitive closure of the explicit subclass relation $R$, for all classes $c$ that are themselves subclasses of `cps:AssetCategory`. In RDF, an explicit subclass assertion $(c_1, c_2) \\in R$ is represented by the triple `c1 rdfs:subClassOf c2`. The condition that a class $c$ is a subclass of `cps:AssetCategory` is `(c, cps:AssetCategory) \\in R^*`, which translates to the SPARQL path `?c rdfs:subClassOf* cps:AssetCategory`. The query must construct all inferred `?c rdfs:subClassOf ?sup` triples.\n\nThe following SPARQL `CONSTRUCT` query accomplishes this. It first identifies all classes `?c` that are in the subclass hierarchy under `cps:AssetCategory` (including itself). Then, for each such class, it finds all its superclasses `?sup` via the reflexive-transitive closure of `rdfs:subClassOf`.\n\n```sparql\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\nPREFIX cps: <http://example.org/ontology/cps#>\n\nCONSTRUCT {\n  ?c rdfs:subClassOf ?sup .\n}\nWHERE {\n  # Constraint: ?c must be a subclass of the root category.\n  # This corresponds to (?c, cps:AssetCategory) belonging to R*.\n  ?c rdfs:subClassOf* cps:AssetCategory .\n  \n  # Generation: For each such ?c, find all its superclasses ?sup.\n  # This corresponds to finding all ?sup such that (?c, ?sup) is in R*.\n  ?c rdfs:subClassOf* ?sup .\n}\n```\n\n#### Explanation of `owl:sameAs` Impact on Counting\n\nThe materialization of inferred triples, such as from RDFS subclassing or OWL identity, can change the results of SPARQL `SELECT` queries, particularly those involving aggregation like `COUNT`. The `owl:sameAs` relation is central to this.\n\nThe relation `owl:sameAs` is defined in OWL as an equivalence relation, meaning for IRIs $i_1, i_2, i_3 \\in I$:\n1.  **Reflexivity**: $(i_1, i_1) \\in E$.\n2.  **Symmetry**: If $(i_1, i_2) \\in E$, then $(i_2, i_1) \\in E$.\n3.  **Transitivity**: If $(i_1, i_2) \\in E$ and $(i_2, i_3) \\in E$, then $(i_1, i_3) \\in E$.\n\nThis relation partitions the set of all IRIs $I$ into disjoint equivalence classes. All IRIs within a single equivalence class are understood to refer to the same single entity.\n\nConsider a query to count distinct assets of a target type $c_{\\mathrm{target}}$:\n`SELECT (COUNT(DISTINCT ?asset) AS ?count) WHERE { ?asset a <target_class> . }`\n\nThe difference in counts arises from how the `DISTINCT` keyword is interpreted by a SPARQL engine, depending on whether it performs OWL reasoning.\n\n*   **Without `owl:sameAs` Reasoning (Raw Count)**: A standard RDF engine without OWL reasoning treats each IRI as a unique identifier. The `COUNT(DISTINCT ?asset)` operation counts the number of unique IRIs that are bound to the `?asset` variable and satisfy the condition `?asset a c_{\\mathrm{target}}`. If two distinct IRIs, say `asset_delta` and `asset_delta_alias`, both have type $c_{\\mathrm{target}}$ (either asserted or inferred via RDFS reasoning), they will be counted as two separate items. This corresponds to the calculation of $n_{\\mathrm{raw}}$.\n\n*   **With `owl:sameAs` Reasoning (Merged Count)**: An OWL-aware reasoner semantically merges all IRIs linked by `owl:sameAs`. When the query is executed, the `DISTINCT` keyword operates on the conceptual entities, not the IRIs. All IRIs in an equivalence class are treated as one. If an equivalence class contains multiple IRIs that satisfy the type condition, the entire class is counted only once. This corresponds to the calculation of $n_{\\mathrm{merged}}$.\n\nTherefore, materializing inferred triples via `owl:sameAs` (or, more accurately, enabling OWL reasoning) can change the answers to counting queries. The raw count, $n_{\\mathrm{raw}}$, is the cardinality of the set of individual IRIs $\\{i \\in I \\mid (i, c_{\\mathrm{target}}) \\text{ inferred}\\}$. The merged count, $n_{\\mathrm{merged}}$, is the cardinality of the set of equivalence classes $\\{[i]_E \\mid \\exists j \\in [i]_E \\text{ s.t. } (j, c_{\\mathrm{target}}) \\text{ inferred}\\}$. Since each equivalence class can contain one or more IRIs, it follows that $n_{\\mathrm{raw}} \\ge n_{\\mathrm{merged}}$. The count changes ($n_{\\mathrm{raw}} > n_{\\mathrm{merged}}$) if and only if there exists at least one equivalence class with more than one member IRI, where each of those members has the inferred type $c_{\\mathrm{target}}$.\n\n### Task B: Algorithm Implementation\n\nThe program must implement the specified five-step computation for each test case.\n\n1.  **Compute Reflexive-Transitive Closure $R^*$**: The set of subclass edges $R$ defines a directed graph on the set of classes $C$. The reflexive-transitive closure $R^*$ corresponds to the reachability relation in this graph. This can be computed efficiently using the Floyd-Warshall algorithm on an adjacency matrix representation of the graph. Let $A$ be an $N \\times N$ matrix for $N=|C|$ classes, where $A[i,j] = 1$ if $(c_i, c_j) \\in R$ or $i=j$, and $0$ otherwise. The closure is found by iterating for $k, i, j \\in \\{1, \\dots, N\\}$, $A[i,j] = A[i,j] \\lor (A[i,k] \\land A[k,j])$.\n\n2.  **Propagate Types Upward**: For each asset IRI $i$ with an asserted type $c$, we infer that $i$ also has type $s$ for every superclass $s$ of $c$. This means for every pair $(c,s) \\in R^*$, if an asset has type $c$, it also has type $s$. We build a mapping from each IRI in a test case to the set of all its inferred types.\n\n3.  **Compute Raw Count $n_{\\mathrm{raw}}$**: We iterate through all IRIs and count how many unique IRIs have $c_{\\mathrm{target}}$ in their set of inferred types. This is the cardinality of the set $\\{i \\in I \\mid c_{\\mathrm{target}} \\in \\text{inferred\\_types}(i)\\}$.\n\n4.  **Compute Merged Count $n_{\\mathrm{merged}}$**: First, we partition the set of all asset IRIs $I$ into equivalence classes based on the `owl:sameAs` relation $E$. This is a classic connected components problem on the graph formed by IRIs as nodes and pairs in $E$ as edges. A Disjoint Set Union (DSU) data structure is ideal for this. After computing the equivalence classes, we count the number of distinct classes that contain at least one IRI of type $c_{\\mathrm{target}}$.\n\n5.  **Compute Flag $b_{\\mathrm{changed}}$**: This is a direct comparison, $b_{\\mathrm{changed}} = (n_{\\mathrm{raw}} \\neq n_{\\mathrm{merged}})$. The result is formatted as a lowercase boolean string ($\\text{`true`}$ or $\\text{`false`}$).\n\nThe implementation will process a list of test cases, applying this logic to each and formatting the final output as a single, space-free line.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by processing a suite of test cases, each involving\n    RDFS subclass reasoning and OWL identity merging for CPS asset categories.\n    \"\"\"\n    test_cases = [\n        {\n            \"C\": {\"cps:AssetCategory\", \"cps:Sensor\", \"cps:TemperatureSensor\", \"cps:Actuator\"},\n            \"R\": {(\"cps:Sensor\", \"cps:AssetCategory\"), (\"cps:TemperatureSensor\", \"cps:Sensor\"), (\"cps:Actuator\", \"cps:AssetCategory\")},\n            \"asset_types\": {(\"asset_alpha\", \"cps:TemperatureSensor\"), (\"asset_beta\", \"cps:Sensor\"), (\"asset_gamma\", \"cps:Actuator\")},\n            \"E\": set(),\n            \"c_target\": \"cps:AssetCategory\",\n        },\n        {\n            \"C\": {\"cps:AssetCategory\", \"cps:Sensor\", \"cps:TemperatureSensor\", \"cps:Actuator\"},\n            \"R\": {(\"cps:Sensor\", \"cps:AssetCategory\"), (\"cps:TemperatureSensor\", \"cps:Sensor\"), (\"cps:Actuator\", \"cps:AssetCategory\")},\n            \"asset_types\": {(\"asset_delta\", \"cps:Sensor\"), (\"asset_delta_alias\", \"cps:Sensor\"), (\"asset_epsilon\", \"cps:TemperatureSensor\"), (\"asset_epsilon_alias\", \"cps:TemperatureSensor\")},\n            \"E\": {(\"asset_delta\", \"asset_delta_alias\"), (\"asset_epsilon\", \"asset_epsilon_alias\")},\n            \"c_target\": \"cps:AssetCategory\",\n        },\n        {\n            \"C\": {\"cps:AssetCategory\", \"cps:X\", \"cps:Y\"},\n            \"R\": {(\"cps:X\", \"cps:Y\"), (\"cps:Y\", \"cps:X\"), (\"cps:X\", \"cps:AssetCategory\"), (\"cps:Y\", \"cps:AssetCategory\")},\n            \"asset_types\": {(\"asset_zeta\", \"cps:X\"), (\"asset_eta\", \"cps:Y\")},\n            \"E\": {(\"asset_zeta\", \"asset_eta\")},\n            \"c_target\": \"cps:AssetCategory\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        classes = sorted(list(case[\"C\"]))\n        class_to_idx = {cls: i for i, cls in enumerate(classes)}\n        num_classes = len(classes)\n\n        # 1. Compute reflexive-transitive closure R* using Floyd-Warshall\n        closure = np.zeros((num_classes, num_classes), dtype=bool)\n        for i in range(num_classes):\n            closure[i, i] = True  # Reflexivity\n        for sub, sup in case[\"R\"]:\n            if sub in class_to_idx and sup in class_to_idx:\n                closure[class_to_idx[sub], class_to_idx[sup]] = True\n        \n        for k in range(num_classes):\n            for i in range(num_classes):\n                for j in range(num_classes):\n                    closure[i, j] = closure[i, j] or (closure[i, k] and closure[k, j])\n\n        # 2. Propagate types upward\n        all_asset_iris = {iri for iri, _ in case[\"asset_types\"]}\n        inferred_types = {iri: set() for iri in all_asset_iris}\n\n        for iri, asset_class in case[\"asset_types\"]:\n            if asset_class in class_to_idx:\n                c_idx = class_to_idx[asset_class]\n                for s_idx in range(num_classes):\n                    if closure[c_idx, s_idx]:\n                        inferred_types[iri].add(classes[s_idx])\n        \n        # 3. Compute raw count n_raw\n        iris_with_target_type = {\n            iri for iri, types in inferred_types.items() \n            if case[\"c_target\"] in types\n        }\n        n_raw = len(iris_with_target_type)\n\n        # 4. Compute merged count n_merged\n        # DSU for equivalence classes from E\n        parent = {iri: iri for iri in all_asset_iris}\n        def find(i):\n            if parent[i] == i:\n                return i\n            parent[i] = find(parent[i])\n            return parent[i]\n\n        def union(i, j):\n            root_i = find(i)\n            root_j = find(j)\n            if root_i != root_j:\n                parent[root_j] = root_i\n\n        for i1, i2 in case[\"E\"]:\n            union(i1, i2)\n\n        counted_components = {find(iri) for iri in iris_with_target_type}\n        n_merged = len(counted_components)\n\n        # 5. Compute boolean flag b_changed\n        b_changed = n_raw != n_merged\n\n        results.append([n_raw, n_merged, b_changed])\n\n    formatted_results = [f\"[{r[0]},{r[1]},{str(r[2]).lower()}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In real-world systems, knowledge is often incomplete, noisy, and sourced from multiple, variably-trusted systems, making identity uncertain. This final practice moves from reasoning with clean, predefined data to the complex challenge of entity resolution—deciding if two descriptions refer to the same physical component. You will construct and implement a sophisticated workflow that fuses multiple evidence sources, including string similarity, property constraints, and provenance, to make principled, automated merge decisions .",
            "id": "4228994",
            "problem": "In a Knowledge Graph (KG) for Cyber-Physical Systems (CPS), entity resolution must decide whether two nodes represent the same physical component. Construct a mathematically grounded workflow that uses string similarity, property constraints, and provenance to decide identity merges. Implement a program that, for a given test suite of candidate pairs, outputs whether each pair should be merged. The workflow should be derived from first principles of equivalence relations and multi-criteria decision rules.\n\nFundamental base and definitions:\n- An identity merge must satisfy the logic of an equivalence relation: reflexivity, symmetry, and transitivity. In practice, the decision rule must be symmetric with respect to the two entities and grounded in observable properties and provenance.\n- Let $A$ and $B$ denote two entities with attributes. Define a token-based string similarity $s_{\\text{name}} \\in [0,1]$ as the Jaccard similarity between token sets extracted from names. Tokenization must convert to lowercase and split on any non-alphanumeric character, discarding empty tokens. For tokens $T_A$ and $T_B$, let\n$$\ns_{\\text{name}} = \\frac{|T_A \\cap T_B|}{|T_A \\cup T_B|}.\n$$\n- Define a three-dimensional Euclidean location distance $d$ between coordinates $(x_A,y_A,z_A)$ and $(x_B,y_B,z_B)$, with\n$$\nd = \\sqrt{(x_A - x_B)^2 + (y_A - y_B)^2 + (z_A - z_B)^2},\n$$\nexpressed in $\\mathrm{m}$ (meters).\n- Define a location closeness score $s_{\\text{loc}} \\in [0,1]$ by\n$$\ns_{\\text{loc}} = \\max\\left(0, 1 - \\frac{d}{D_{\\text{max}}}\\right),\n$$\nwith $D_{\\text{max}} = 10 \\ \\mathrm{m}$.\n- Let indicator signals be defined for properties that contribute to similarity when they are available on both entities:\n  - Serial number indicator $I_{\\text{serial}} = 1$ if both serial numbers exist and are equal; otherwise undefined if one or both are missing; it is never $0$ because differing serials are handled as a hard constraint failure below.\n  - Manufacturer indicator $I_{\\text{manuf}} = 1$ if both manufacturers exist and are equal, and $0$ if both exist and differ; undefined if one or both are missing.\n- Define a property similarity $s_{\\text{prop}} \\in [0,1]$ as the mean of all defined signals among $\\{s_{\\text{loc}}, I_{\\text{serial}}, I_{\\text{manuf}}\\}$. If none are defined, set $s_{\\text{prop}} = 0$.\n- Define a convex combination\n$$\n\\sigma = w_s \\, s_{\\text{name}} + w_p \\, s_{\\text{prop}},\n$$\nwith weights $w_s = 0.6$ and $w_p = 0.4$, satisfying $w_s + w_p = 1$.\n- Let provenance trust values $t_A \\in [0,1]$ and $t_B \\in [0,1]$ be assigned to entities $A$ and $B$. Define the pairwise trust dampening\n$$\n\\tau = \\min(t_A, t_B),\n$$\nand the damped combined score\n$$\n\\sigma' = \\tau \\, \\sigma.\n$$\n- Define hard constraints that must hold prior to scoring:\n  1. If both serial numbers exist and are different, then do not merge.\n  2. If both types exist and are different, then do not merge.\n  3. If both units exist and are different, then do not merge.\n  4. If $d > D_{\\text{hard}}$ with $D_{\\text{hard}} = 10 \\ \\mathrm{m}$, then do not merge.\n- Define a serial override consistent with physical identity: if both serial numbers exist and are equal, and none of the hard constraints are violated, then merge regardless of $\\sigma'$.\n- Otherwise, adopt the decision rule: merge if and only if $\\sigma' \\ge \\theta$ with threshold $\\theta = 0.5$.\n\nYour task is to implement this workflow in a program. Physical units to use for distance are $\\mathrm{m}$ (meters). No angle units are involved. The output for each candidate pair must be a boolean.\n\nTest suite:\nUse the following eight candidate pairs as inputs. Each entity is specified as a dictionary of attributes: name (string), type (string or None), unit (string or None), manufacturer (string or None), serial (string or None), location (triplet of floats in $\\mathrm{m}$), trust (float in $[0,1]$).\n\n1. Happy path with serial equality and close location:\n   - $A$: name \"Temp Sensor A\", type \"sensor\", unit \"Celsius\", manufacturer \"Acme\", serial \"SN-001\", location $(0,0,0)$ $\\mathrm{m}$, trust $0.9$.\n   - $B$: name \"Temperature Sensor A\", type \"sensor\", unit \"Celsius\", manufacturer \"Acme\", serial \"SN-001\", location $(3,0,0)$ $\\mathrm{m}$, trust $0.8$.\n2. Boundary location case at $10 \\ \\mathrm{m}$ with serial equality:\n   - $A$: name \"Pump-01\", type \"actuator\", unit \"L/s\", manufacturer \"Globex\", serial \"P01X\", location $(100,50,0)$ $\\mathrm{m}$, trust $0.7$.\n   - $B$: name \"Pump01\", type \"actuator\", unit \"L/s\", manufacturer \"Globex\", serial \"P01X\", location $(110,50,0)$ $\\mathrm{m}$, trust $0.7$.\n3. Unit mismatch case:\n   - $A$: name \"Room Temp Sensor\", type \"sensor\", unit \"Celsius\", manufacturer \"Acme\", serial \"SN-777\", location $(10,10,2)$ $\\mathrm{m}$, trust $0.95$.\n   - $B$: name \"Room Temperature Sensor\", type \"sensor\", unit \"Kelvin\", manufacturer \"Acme\", serial \"SN-778\", location $(11,11,2)$ $\\mathrm{m}$, trust $0.9$.\n4. Type mismatch case:\n   - $A$: name \"Valve Position Unit 7\", type \"sensor\", unit \"position\", manufacturer \"Initech\", serial \"VP-007\", location $(25,0,0)$ $\\mathrm{m}$, trust $0.85$.\n   - $B$: name \"Valve Controller 7\", type \"actuator\", unit \"position\", manufacturer \"Initech\", serial \"VC-007\", location $(25.5,0,0)$ $\\mathrm{m}$, trust $0.9$.\n5. High similarity but low provenance trust:\n   - $A$: name \"Motor RPM Sensor\", type \"sensor\", unit \"RPM\", manufacturer \"Acme\", serial None, location $(200,75,0)$ $\\mathrm{m}$, trust $0.3$.\n   - $B$: name \"Motor Rotation Sensor\", type \"sensor\", unit \"RPM\", manufacturer \"Acme\", serial None, location $(202,77,0)$ $\\mathrm{m}$, trust $0.4$.\n6. Different names but equal serial numbers:\n   - $A$: name \"Building B Floor 2 Zone 3 Thermistor\", type \"sensor\", unit \"Celsius\", manufacturer \"ThermoCorp\", serial \"TH-2203\", location $(500,200,5)$ $\\mathrm{m}$, trust $0.9$.\n   - $B$: name \"Z3-B2 Temperature Probe\", type \"sensor\", unit \"Celsius\", manufacturer \"ThermoCorp\", serial \"TH-2203\", location $(503,201,5)$ $\\mathrm{m}$, trust $0.85$.\n7. Missing unit on one entity:\n   - $A$: name \"Humidity Sensor East\", type \"sensor\", unit None, manufacturer \"EnviroSys\", serial None, location $(0,50,0)$ $\\mathrm{m}$, trust $0.95$.\n   - $B$: name \"East Humidity Sensor\", type \"sensor\", unit \"percent\", manufacturer \"EnviroSys\", serial None, location $(0.5,50.2,0)$ $\\mathrm{m}$, trust $0.9$.\n8. Location just above the hard threshold:\n   - $A$: name \"Pressure Sensor North\", type \"sensor\", unit \"bar\", manufacturer \"Acme\", serial \"PSN-100\", location $(0,0,0)$ $\\mathrm{m}$, trust $0.9$.\n   - $B$: name \"North Pressure Sensor\", type \"sensor\", unit \"bar\", manufacturer \"Acme\", serial \"PSN-101\", location $(0,10.0001,0)$ $\\mathrm{m}$, trust $0.9$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"). Each result must be a boolean corresponding to the merge decision for the respective test case in the order given. The physical distance must be computed in $\\mathrm{m}$, and booleans must be printed as either \"True\" or \"False\".",
            "solution": "The problem requires the construction and implementation of a rigorous, mathematically-grounded workflow for entity resolution in a Knowledge Graph for Cyber-Physical Systems (CPS). The workflow must decide whether two entities, $A$ and $B$, represent the same physical component. The provided specification is self-contained, logically consistent, and scientifically sound, forming a valid basis for a solution. The core of the solution is a multi-stage decision process derived from first principles of evidence fusion and rule-based logic.\n\nThe logical foundation of the decision process is designed to approximate an equivalence relation. The decision rule for a pair $(A, B)$ is symmetric, as all calculations (Jaccard similarity, Euclidean distance, minimum of trust scores) are symmetric with respect to the order of $A$ and $B$. This ensures that the decision for $(A, B)$ is identical to the decision for $(B, A)$.\n\nThe workflow is structured as a hierarchical application of rules, proceeding from definitive evidence to probabilistic scoring:\n\nStep 1: Hard Constraint Evaluation\nThis initial step serves as a set of inviolable falsification rules. If any of these conditions are met, the hypothesis that $A$ and $B$ are identical is immediately rejected. These constraints represent strong negative evidence that is sufficient to terminate the process.\nLet $d$ be the Euclidean distance in meters ($\\mathrm{m}$) between the locations of entities $A$ and $B$. The hard constraints are:\n1.  If both entities have serial numbers and they are different, they cannot be the same component.\n2.  If both entities have types and they are different (e.g., 'sensor' vs. 'actuator'), they are functionally distinct and thus not identical.\n3.  If both entities have specified units and they are different (e.g., 'Celsius' vs. 'Kelvin'), they measure different physical properties or use incompatible scales, implying they are not the same component.\n4.  If the physical distance $d$ exceeds a hard threshold, $D_{\\text{hard}} = 10 \\ \\mathrm{m}$, the entities are considered too far apart to be the same component. The rule is to not merge if $d > 10$.\n\nStep 2: Serial Number Override\nThis step represents a form of strong positive evidence. A serial number is typically a unique identifier for a physical device.\nThe rule is as follows: if both entities have serial numbers, they are identical, and none of the hard constraints from Step 1 are violated, the entities are merged. This decision is made regardless of any other similarity scores, as the matching serial numbers provide overwhelming evidence of identity.\n\nStep 3: Probabilistic Scoring and Thresholding\nIf the decision is not resolved by the definitive rules in Steps 1 and 2, a scoring mechanism is employed to weigh the combined evidence. This applies when information is incomplete (e.g., missing serial numbers) or conflicting.\n\nFirst, two primary similarity scores are calculated:\n    - String Similarity, $s_{\\text{name}}$: The Jaccard similarity of name tokens, $s_{\\text{name}} = \\frac{|T_A \\cap T_B|}{|T_A \\cup T_B|}$, where $T_A$ and $T_B$ are the sets of alphanumeric tokens from the lowercase names of the entities. This measures semantic overlap in their descriptions.\n    - Property Similarity, $s_{\\text{prop}}$: This score aggregates similarity across various physical and logical attributes. It is the arithmetic mean of the defined indicator signals from the set $\\{s_{\\text{loc}}, I_{\\text{serial}}, I_{\\text{manuf}}\\}$.\n        - Location Closeness, $s_{\\text{loc}} = \\max\\left(0, 1 - \\frac{d}{D_{\\text{max}}}\\right)$ with $D_{\\text{max}} = 10 \\ \\mathrm{m}$. This score is $1$ for co-located entities and decays linearly to $0$ as the distance $d$ approaches $10 \\ \\mathrm{m}$.\n        - Serial Number Indicator, $I_{\\text{serial}}$: This is $1$ if serial numbers match. However, due to the logic flow (Step 1 and 2), this signal is never defined at Step 3. If serials matched, the override would have triggered; if they differed, a hard constraint would have failed. This step only runs if at least one serial is missing.\n        - Manufacturer Indicator, $I_{\\text{manuf}}$: This is $1$ if manufacturers match and $0$ if they differ (assuming both are known).\n\nNext, these scores are combined into a single score, $\\sigma$, using a convex combination: $\\sigma = w_s s_{\\text{name}} + w_p s_{\\text{prop}}$, with weights $w_s = 0.6$ and $w_p = 0.4$. This reflects a greater emphasis on name similarity.\n\nFinally, the score is dampened by a provenance trust factor. Data sources in a real-world KG have varying reliability. The pairwise trust dampening, $\\tau = \\min(t_A, t_B)$, ensures that a match is only as trustworthy as the least trusted source. The damped score is $\\sigma' = \\tau \\sigma$.\n\nThe final decision is made by comparing this damped score to a threshold $\\theta = 0.5$. A merge is performed if and only if $\\sigma' \\ge 0.5$.\n\nApplying this workflow to the test suite:\n\nCase 1: $A($ `...serial=\"SN-001\"`$, ...)$, $B($ `...serial=\"SN-001\"`$, ...)$.\n- Hard constraints: All pass.\n- Serial override: Serials exist and are equal. Rule applies. Decision: **True**.\n\nCase 2: $A($ `...serial=\"P01X\"`$, loc=(100,50,0))$, $B($ `...serial=\"P01X\"`$, loc=(110,50,0))$.\n- Distance $d = 10.0 \\ \\mathrm{m}$. Hard constraint $d > 10$ is not met. All other hard constraints pass.\n- Serial override: Serials exist and are equal. Rule applies. Decision: **True**.\n\nCase 3: $A($ `...unit=\"Celsius\", serial=\"SN-777\"`$), B($ `...unit=\"Kelvin\", serial=\"SN-778\"`$)$.\n- Hard constraint: Units exist and are different. Rule applies. Decision: **False**.\n- Hard constraint: Serials exist and are different. Rule also applies. Decision: **False**.\n\nCase 4: $A($ `...type=\"sensor\", serial=\"VP-007\"`$), B($ `...type=\"actuator\", serial=\"VC-007\"`$)$.\n- Hard constraint: Types exist and are different. Rule applies. Decision: **False**.\n- Hard constraint: Serials exist and are different. Rule also applies. Decision: **False**.\n\nCase 5: $A($ `...trust=0.3`$), B($ `...trust=0.4`$)$. No serials.\n- Hard constraints: All pass. Serial override: Not applicable.\n- Scoring:\n    - $s_{\\text{name}}$ for names \"Motor RPM Sensor\" and \"Motor Rotation Sensor\" is $2/4 = 0.5$.\n    - $d = \\sqrt{(202-200)^2 + (77-75)^2} = \\sqrt{8} \\approx 2.828 \\ \\mathrm{m}$.\n    - $s_{\\text{loc}} = 1 - \\sqrt{8}/10 \\approx 0.717$. $I_{\\text{manuf}} = 1$ (both \"Acme\"). $I_{\\text{serial}}$ is undefined.\n    - $s_{\\text{prop}} = (0.717 + 1)/2 = 0.8585$.\n    - $\\sigma = 0.6 \\times 0.5 + 0.4 \\times 0.8585 = 0.3 + 0.3434 = 0.6434$.\n    - $\\tau = \\min(0.3, 0.4) = 0.3$.\n    - $\\sigma' = 0.3 \\times 0.6434 = 0.193$.\n- Decision: $0.193 < 0.5$. **False**.\n\nCase 6: $A($ `...name=\"Building B...\", serial=\"TH-2203\"`$), B($ `...name=\"Z3-B2...\", serial=\"TH-2203\"`$)$.\n- Hard constraints: All pass.\n- Serial override: Serials exist and are equal. Rule applies. Decision: **True**.\n\nCase 7: $A($ `...unit=None`$), B($ `...unit=\"percent\"`$)$. No serials.\n- Hard constraints: All pass (unit constraint requires *both* to exist). Serial override: Not applicable.\n- Scoring:\n    - $s_{\\text{name}}$ for \"Humidity Sensor East\" and \"East Humidity Sensor\" is $3/3 = 1.0$.\n    - $d = \\sqrt{0.5^2 + 0.2^2} = \\sqrt{0.29} \\approx 0.539 \\ \\mathrm{m}$.\n    - $s_{\\text{loc}} = 1 - \\sqrt{0.29}/10 \\approx 0.946$. $I_{\\text{manuf}} = 1$.\n    - $s_{\\text{prop}} = (0.946 + 1)/2 = 0.973$.\n    - $\\sigma = 0.6 \\times 1.0 + 0.4 \\times 0.973 = 0.6 + 0.3892 = 0.9892$.\n    - $\\tau = \\min(0.95, 0.9) = 0.9$.\n    - $\\sigma' = 0.9 \\times 0.9892 \\approx 0.89$.\n- Decision: $0.89 \\ge 0.5$. **True**.\n\nCase 8: $A($ `loc=(0,0,0)`$), B($ `loc=(0,10.0001,0)`$)$. Serials differ.\n- Distance $d = 10.0001 \\ \\mathrm{m}$.\n- Hard constraint: Serials exist and are different. Rule applies. Decision: **False**.\n- Hard constraint: $d = 10.0001 > 10$. Rule also applies. Decision: **False**.",
            "answer": "```python\nimport numpy as np\nimport re\n\ndef solve():\n    \"\"\"\n    Main function to run the entity resolution workflow on a test suite.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    D_MAX = 10.0\n    D_HARD = 10.0\n    W_S = 0.6\n    W_P = 0.4\n    THETA = 0.5\n\n    test_cases = [\n        # Case 1\n        (\n            {\"name\": \"Temp Sensor A\", \"type\": \"sensor\", \"unit\": \"Celsius\", \"manufacturer\": \"Acme\", \"serial\": \"SN-001\", \"location\": (0, 0, 0), \"trust\": 0.9},\n            {\"name\": \"Temperature Sensor A\", \"type\": \"sensor\", \"unit\": \"Celsius\", \"manufacturer\": \"Acme\", \"serial\": \"SN-001\", \"location\": (3, 0, 0), \"trust\": 0.8},\n        ),\n        # Case 2\n        (\n            {\"name\": \"Pump-01\", \"type\": \"actuator\", \"unit\": \"L/s\", \"manufacturer\": \"Globex\", \"serial\": \"P01X\", \"location\": (100, 50, 0), \"trust\": 0.7},\n            {\"name\": \"Pump01\", \"type\": \"actuator\", \"unit\": \"L/s\", \"manufacturer\": \"Globex\", \"serial\": \"P01X\", \"location\": (110, 50, 0), \"trust\": 0.7},\n        ),\n        # Case 3\n        (\n            {\"name\": \"Room Temp Sensor\", \"type\": \"sensor\", \"unit\": \"Celsius\", \"manufacturer\": \"Acme\", \"serial\": \"SN-777\", \"location\": (10, 10, 2), \"trust\": 0.95},\n            {\"name\": \"Room Temperature Sensor\", \"type\": \"sensor\", \"unit\": \"Kelvin\", \"manufacturer\": \"Acme\", \"serial\": \"SN-778\", \"location\": (11, 11, 2), \"trust\": 0.9},\n        ),\n        # Case 4\n        (\n            {\"name\": \"Valve Position Unit 7\", \"type\": \"sensor\", \"unit\": \"position\", \"manufacturer\": \"Initech\", \"serial\": \"VP-007\", \"location\": (25, 0, 0), \"trust\": 0.85},\n            {\"name\": \"Valve Controller 7\", \"type\": \"actuator\", \"unit\": \"position\", \"manufacturer\": \"Initech\", \"serial\": \"VC-007\", \"location\": (25.5, 0, 0), \"trust\": 0.9},\n        ),\n        # Case 5\n        (\n            {\"name\": \"Motor RPM Sensor\", \"type\": \"sensor\", \"unit\": \"RPM\", \"manufacturer\": \"Acme\", \"serial\": None, \"location\": (200, 75, 0), \"trust\": 0.3},\n            {\"name\": \"Motor Rotation Sensor\", \"type\": \"sensor\", \"unit\": \"RPM\", \"manufacturer\": \"Acme\", \"serial\": None, \"location\": (202, 77, 0), \"trust\": 0.4},\n        ),\n        # Case 6\n        (\n            {\"name\": \"Building B Floor 2 Zone 3 Thermistor\", \"type\": \"sensor\", \"unit\": \"Celsius\", \"manufacturer\": \"ThermoCorp\", \"serial\": \"TH-2203\", \"location\": (500, 200, 5), \"trust\": 0.9},\n            {\"name\": \"Z3-B2 Temperature Probe\", \"type\": \"sensor\", \"unit\": \"Celsius\", \"manufacturer\": \"ThermoCorp\", \"serial\": \"TH-2203\", \"location\": (503, 201, 5), \"trust\": 0.85},\n        ),\n        # Case 7\n        (\n            {\"name\": \"Humidity Sensor East\", \"type\": \"sensor\", \"unit\": None, \"manufacturer\": \"EnviroSys\", \"serial\": None, \"location\": (0, 50, 0), \"trust\": 0.95},\n            {\"name\": \"East Humidity Sensor\", \"type\": \"sensor\", \"unit\": \"percent\", \"manufacturer\": \"EnviroSys\", \"serial\": None, \"location\": (0.5, 50.2, 0), \"trust\": 0.9},\n        ),\n        # Case 8\n        (\n            {\"name\": \"Pressure Sensor North\", \"type\": \"sensor\", \"unit\": \"bar\", \"manufacturer\": \"Acme\", \"serial\": \"PSN-100\", \"location\": (0, 0, 0), \"trust\": 0.9},\n            {\"name\": \"North Pressure Sensor\", \"type\": \"sensor\", \"unit\": \"bar\", \"manufacturer\": \"Acme\", \"serial\": \"PSN-101\", \"location\": (0, 10.0001, 0), \"trust\": 0.9},\n        ),\n    ]\n\n    def tokenize(name_str):\n        \"\"\"Converts a name string to a set of lowercase alphanumeric tokens.\"\"\"\n        if not name_str:\n            return set()\n        # Split on any sequence of one or more non-alphanumeric characters\n        tokens = re.split(r'[^a-zA-Z0-9]+', name_str.lower())\n        # Filter out empty strings that result from splitting\n        return {token for token in tokens if token}\n\n    def decide_merge(entity_a, entity_b):\n        \"\"\"\n        Implements the complete decision workflow for a pair of entities.\n        \"\"\"\n        # Step 1: Calculate distance and check hard constraints\n        loc_a, loc_b = np.array(entity_a['location']), np.array(entity_b['location'])\n        distance = np.linalg.norm(loc_a - loc_b)\n\n        if distance > D_HARD:\n            return False\n        \n        serial_a, serial_b = entity_a['serial'], entity_b['serial']\n        if serial_a is not None and serial_b is not None and serial_a != serial_b:\n            return False\n\n        type_a, type_b = entity_a['type'], entity_b['type']\n        if type_a is not None and type_b is not None and type_a != type_b:\n            return False\n\n        unit_a, unit_b = entity_a['unit'], entity_b['unit']\n        if unit_a is not None and unit_b is not None and unit_a != unit_b:\n            return False\n\n        # Step 2: Serial number override\n        if serial_a is not None and serial_a == serial_b:\n            return True\n\n        # Step 3: Probabilistic scoring and thresholding\n        \n        # String similarity\n        tokens_a = tokenize(entity_a['name'])\n        tokens_b = tokenize(entity_b['name'])\n        intersection_size = len(tokens_a.intersection(tokens_b))\n        union_size = len(tokens_a.union(tokens_b))\n        s_name = intersection_size / union_size if union_size > 0 else 0\n\n        # Property similarity\n        prop_signals = []\n        \n        # Location closeness\n        s_loc = max(0, 1 - (distance / D_MAX))\n        prop_signals.append(s_loc)\n        \n        # Manufacturer indicator\n        manuf_a, manuf_b = entity_a['manufacturer'], entity_b['manufacturer']\n        if manuf_a is not None and manuf_b is not None:\n            i_manuf = 1.0 if manuf_a == manuf_b else 0.0\n            prop_signals.append(i_manuf)\n            \n        # Serial indicator is never defined at this stage, per the problem logic\n\n        s_prop = np.mean(prop_signals) if prop_signals else 0\n\n        # Combined score\n        sigma = W_S * s_name + W_P * s_prop\n\n        # Provenance damping\n        tau = min(entity_a['trust'], entity_b['trust'])\n        sigma_prime = tau * sigma\n\n        # Final decision\n        return sigma_prime >= THETA\n\n    results = []\n    for case in test_cases:\n        entity_a, entity_b = case\n        result = decide_merge(entity_a, entity_b)\n        results.append(result)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}