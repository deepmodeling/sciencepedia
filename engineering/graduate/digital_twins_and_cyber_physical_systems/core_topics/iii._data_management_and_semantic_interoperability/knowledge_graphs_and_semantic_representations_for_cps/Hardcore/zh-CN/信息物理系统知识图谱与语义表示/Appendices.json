{
    "hands_on_practices": [
        {
            "introduction": "我们如何以机器可理解的方式，形式化地定义“传感设备”这样的概念？本实践深入探讨了使用Web本体语言 (OWL) 进行语义建模的核心。你将通过编程实现对一个基本OWL构造——限定基数约束 (qualified cardinality restriction) 的检查，以强制规定一个设备必须至少有一个特定类型的输出 。这项练习将巩固你对描述逻辑 (Description Logic) 语义如何转化为知识图谱中实用数据验证规则的理解。",
            "id": "4228925",
            "problem": "您正在信息物理系统（CPS）的知识图谱和语义表示领域工作，目标是为设备及其输出进行Web本体语言（OWL）类建模。此问题的基本依据是OWL底层的描述逻辑（DL）的模型论语义，其中类被解释为集合，属性被解释为论域上的二元关系。具体来说，请依赖以下基本原理：\n- 一个解释将每个类符号分配给一个域的子集，并将每个属性符号分配给该域上的一个二元关系。\n- 属性上的基数限制计算在该属性下满足给定类成员资格的不同后继者的数量，这与集合论计数和关系组合一致。\n\n目标：为必须具有至少一个Measurement输出的SensingDevice构建OWL类表达式，并演示如何使用带有最小基数的OWL限制来捕捉此要求。然后，实现一个算法，该算法给定一个由个体类型和属性边组成的有限知识图谱，为每个测试实例判断其是否满足限定最小基数要求。\n\n使用的定义：\n- 令 $\\Delta^{I}$ 表示解释的论域。\n- 令 $P^{I} \\subseteq \\Delta^{I} \\times \\Delta^{I}$ 表示属性的解释。\n- 令 $C^{I} \\subseteq \\Delta^{I}$ 表示类的解释。\n- 对于某个整数 $n \\ge 0$，如果一个个体 $x \\in \\Delta^{I}$ 的不同 $P^{I}$-后继者中属于 $C^{I}$ 的数量至少为 $n$，则该个体满足限定最小基数限制。\n\n任务详情：\n1. 使用关于属性“hasOutput”相对于类“Measurement”的限定最小基数限制，为“至少有一个Measurement输出的SensingDevice”构建类表达式，最小计数 $n = 1$。不要在问题陈述中直接给出目标公式；相反，您的算法解决方案必须从上述解释和基数的基本原理中推导出它。\n2. 实现一个程序，该程序：\n   - 表示一个包含个体、其类型以及“hasOutput”属性邻接结构的小型知识图谱。\n   - 对于每个测试用例设备，通过计算类型为Measurement的不同后继者的数量，来计算它是否满足“hasOutput至少有$1$个Measurement”的限定最小基数要求。\n   - 为每个测试用例返回一个布尔值，指示是否满足要求。\n\n假设：\n- 计数是针对不同后继者的，也就是说，如果存在到同一个体的重复边，它们对基数的贡献只有一次。\n- 仅当 $y$ 的类型为Measurement时，边 $(x,y)$ 才计入总数。\n- 缺少属性边将导致计数为$0$。\n\n测试套件：\n使用以下六个测试用例。每个用例都是单个设备标识符的类型和属性边的自包含配置。感兴趣的属性是“hasOutput”，目标类是“Measurement”，限定最小基数为$1$。\n\n- 情况 A（正常路径）：设备 $s_1$ 有一个输出 $m_1$；$m_1$ 的类型为Measurement。\n  - 类型：$s_1 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$\n  - 边：$(s_1, \\text{hasOutput}, m_1)$\n  - 预期布尔值：True\n\n- 情况 B（边界情况：重复项不增加基数）：设备 $s_2$ 有两条到相同输出 $m_1$ 的边；$m_1$ 的类型为Measurement；不同项计数为$1$。\n  - 类型：$s_2 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$\n  - 边：$(s_2, \\text{hasOutput}, m_1)$ 两次\n  - 预期布尔值：True\n\n- 情况 C（边缘情况：零输出）：设备 $s_3$ 没有输出。\n  - 类型：$s_3 \\mapsto \\{\\text{SensingDevice}\\}$\n  - 边：无\n  - 预期布尔值：False\n\n- 情况 D（失败：仅有非测量输出）：设备 $s_4$ 有一个输出 $nm_1$；$nm_1$ 的类型为NonMeasurement。\n  - 类型：$s_4 \\mapsto \\{\\text{SensingDevice}\\}$, $nm_1 \\mapsto \\{\\text{NonMeasurement}\\}$\n  - 边：$(s_4, \\text{hasOutput}, nm_1)$\n  - 预期布尔值：False\n\n- 情况 E（混合输出）：设备 $s_5$ 有输出 $m_2$ 和 $nm_1$；$m_2$ 的类型为Measurement；$nm_1$ 的类型为NonMeasurement；不同的Measurement计数为$1$。\n  - 类型：$s_5 \\mapsto \\{\\text{SensingDevice}\\}$, $m_2 \\mapsto \\{\\text{Measurement}\\}$, $nm_1 \\mapsto \\{\\text{NonMeasurement}\\}$\n  - 边：$(s_5, \\text{hasOutput}, m_2)$ 和 $(s_5, \\text{hasOutput}, nm_1)$\n  - 预期布尔值：True\n\n- 情况 F（多个不同的测量输出）：设备 $s_6$ 有输出 $m_1$ 和 $m_2$；两者类型均为Measurement；不同项计数为$2 \\ge 1$。\n  - 类型：$s_6 \\mapsto \\{\\text{SensingDevice}\\}$, $m_1 \\mapsto \\{\\text{Measurement}\\}$, $m_2 \\mapsto \\{\\text{Measurement}\\}$\n  - 边：$(s_6, \\text{hasOutput}, m_1)$ 和 $(s_6, \\text{hasOutput}, m_2)$\n  - 预期布尔值：True\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,...]”），其中每个结果是按顺序对应于情况A到F的布尔值。",
            "solution": "此问题是有效的。它在科学上基于描述逻辑（DL）的形式化模型论语义，而描述逻辑是Web本体语言（OWL）的基础。该问题陈述清晰，提供了明确的目标、完整的定义和一组无歧义的测试用例。它正确地要求用户将限定基数限制的形式化定义应用于实际的验证算法。\n\n此问题的核心是形式化并验证一个关于知识图谱中一类对象的陈述。该陈述是：“一个`SensingDevice`，它至少有一个作为`Measurement`的输出。”这在为信息物理系统（CPS）设计本体时是一种常见的建模模式，确保数据完整性和正确的系统组装至关重要。\n\n我们首先使用描述逻辑的概念来形式化该陈述。设基类为$SensingDevice$，属性为$hasOutput$，输出的限定类为$Measurement$。该要求可以表示为一个复杂的类定义，即基类与其属性上的一个限制的交集（合取）。\n\n该限制是一个限定最小基数限制。在DL语法中，它被写作 $(\\ge n \\ P.C)$，其中 $n$ 是最小连接数， $P$ 是属性， $C$ 是通过 $P$ 连接的对象的限定类。对于我们的具体情况，属性 $P$ 是 $hasOutput$，限定类 $C$ 是 $Measurement$，最小连接数 $n$ 是 $1$。因此，该限制是 $(\\ge 1 \\ hasOutput.Measurement)$。\n\n“至少有一个Measurement输出的SensingDevice”的完整类表达式是基类与此限制的交集：\n$$\nSensingDevice \\sqcap (\\ge 1 \\ hasOutput.Measurement)\n$$\n其中 $\\sqcap$ 表示类交集运算符。\n\n为了理解如何验证这个形式化表达式，我们转向所提供的模型论语义。一个解释 $\\mathcal{I} = (\\Delta^{\\mathcal{I}}, \\cdot^{\\mathcal{I}})$ 包含一个非空个体域 $\\Delta^{\\mathcal{I}}$ 和一个解释函数 $\\cdot^{\\mathcal{I}}$，该函数将类名映射到 $\\Delta^{\\mathcal{I}}$ 的子集，将属性名映射到 $\\Delta^{\\mathcal{I}}$ 上的二元关系。\n\n一个个体 $x \\in \\Delta^{\\mathcal{I}}$ 是类表达式 $SensingDevice \\sqcap (\\ge 1 \\ hasOutput.Measurement)$ 的一个实例，当且仅当它满足合取的两个部分：\n$1$. $x \\in (SensingDevice)^{\\mathcal{I}}$\n$2$. $x \\in (\\ge 1 \\ hasOutput.Measurement)^{\\mathcal{I}}$\n\n第一个条件仅意味着个体 $x$ 必须是 $SensingDevice$ 类型。第二个条件由限定最小基数限制的语义定义。一个个体 $x$ 满足此条件，如果其通过 $hasOutput$ 属性连接的、同时也是 $Measurement$ 类成员的不同后继者的集合的基数大于或等于 $1$。形式上：\n$$\n|\\{ y \\in \\Delta^{\\mathcal{I}} \\mid (x, y) \\in (hasOutput)^{\\mathcal{I}} \\land y \\in (Measurement)^{\\mathcal{I}} \\}| \\ge 1\n$$\n在这里，$(hasOutput)^{\\mathcal{I}}$ 是所有由 $hasOutput$ 属性关联的对 $(u,v)$ 的集合，而 $(Measurement)^{\\mathcal{I}}$ 是所有 $Measurement$ 类型个体的集合。集合 $\\{ y \\in \\Delta^{\\mathcal{I}} \\mid \\dots \\}$ 收集了所有通过 $hasOutput$ 连接到 $x$ 且类型为 $Measurement$ 的不同个体 $y$。运算符 $|\\cdot|$ 计算该集合的大小。\n\n在一个有限知识图谱中为给定设备验证此条件的算法直接实现了这个语义定义。\n$1$. **识别设备 ($x$)**：从测试用例中检查的设备。\n$2$. **检索所有后继者 ($y$)**：检索所有通过 $hasOutput$ 属性与 $x$ 连接的后继者 $y$。这对应于在图中找到所有使得边 $(x, \\text{hasOutput}, y)$ 存在的 $y$。问题规定，缺少边导致计数为 $0$，如果此集合为空，则自然发生。\n$3$. **确保唯一性**。语义定义计算集合的元素，因此任何重复的后继者必须只计算一次。这通过创建一个后继者个体的集合来实现。\n$4$. **按类型筛选**。对于每个不同的后继者 $y$，我们检查它是否是 $Measurement$ 类的实例。这对应于检查 $y \\in (Measurement)^{\\mathcal{I}}$。\n$5$. **计数和比较**。我们计算满足类型要求的不同后继者的数量。设此计数为 $c$。如果 $c \\ge 1$，则条件满足。\n\n这个分步过程被应用于所提供的六个测试用例中的每一个，从而得出一个布尔结果，指示每个用例中的设备是否是所定义类的成员。例如，在情况E中，设备 $s_5$ 有两个不同的后继者，$m_2$ 和 $nm_1$。其中，只有 $m_2$ 是 $Measurement$ 类型。因此，符合条件的后继者数量为 $1$。由于 $1 \\ge 1$，条件满足，结果为True。在情况D中，设备 $s_4$ 有一个后继者 $nm_1$，它不是 $Measurement$ 类型。计数为 $0$。由于 $0  1$，条件不满足，结果为False。这个逻辑在所有用例中都得到一致的应用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates devices against a qualified minimum cardinality restriction.\n    \n    The problem asks to implement a check for the Description Logic class expression:\n    SensingDevice ⊓ (≥ 1 hasOutput.Measurement)\n    \n    This means for a device to be valid, it must have at least one distinct\n    successor via the 'hasOutput' property that is of type 'Measurement'.\n    \"\"\"\n\n    # Test suite definition. Each case represents a small knowledge graph\n    # configuration for a single device under test.\n    # Structure: (device_id_to_check, types_dictionary, edges_dictionary)\n    # - types_dictionary: maps individual IDs to a set of their class types.\n    # - edges_dictionary: maps a source ID to a list of target IDs for the\n    #   'hasOutput' property.\n    test_cases = [\n        # Case A: Happy path. s1 has one Measurement output.\n        (\n            's1',\n            {'s1': {'SensingDevice'}, 'm1': {'Measurement'}},\n            {'s1': ['m1']}\n        ),\n        # Case B: Boundary. Duplicate edges to the same output count as one.\n        (\n            's2',\n            {'s2': {'SensingDevice'}, 'm1': {'Measurement'}},\n            {'s2': ['m1', 'm1']}\n        ),\n        # Case C: Edge case. s3 has no outputs.\n        (\n            's3',\n            {'s3': {'SensingDevice'}},\n            {} # No edges for s3\n        ),\n        # Case D: Failure. s4's only output is not a Measurement.\n        (\n            's4',\n            {'s4': {'SensingDevice'}, 'nm1': {'NonMeasurement'}},\n            {'s4': ['nm1']}\n        ),\n        # Case E: Mixed outputs. s5 has one Measurement and one non-Measurement.\n        (\n            's5',\n            {'s5': {'SensingDevice'}, 'm2': {'Measurement'}, 'nm1': {'NonMeasurement'}},\n            {'s5': ['m2', 'nm1']}\n        ),\n        # Case F: Multiple distinct Measurement outputs.\n        (\n            's6',\n            {'s6': {'SensingDevice'}, 'm1': {'Measurement'}, 'm2': {'Measurement'}},\n            {'s6': ['m1', 'm2']}\n        ),\n    ]\n\n    results = []\n    # Parameters for the qualified cardinality restriction\n    target_class = 'Measurement'\n    min_cardinality = 1\n\n    for device_id, types, edges in test_cases:\n        # Retrieve the list of successors for the device via 'hasOutput'.\n        # If the device has no outgoing edges, .get() returns an empty list.\n        successors = edges.get(device_id, [])\n\n        # The semantics require counting *distinct* successors. A set handles this.\n        distinct_successors = set(successors)\n\n        # Count the number of distinct successors that are of the target class.\n        qualified_count = 0\n        for successor_id in distinct_successors:\n            # Get the types of the successor. Default to an empty set if not found.\n            successor_types = types.get(successor_id, set())\n            if target_class in successor_types:\n                qualified_count += 1\n        \n        # Check if the count meets the minimum cardinality requirement.\n        is_satisfied = qualified_count = min_cardinality\n        results.append(is_satisfied)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str, ...) converts each boolean (True/False) to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个定义良好的模型只有在数据遵循其规范时才有用，因此数据验证至关重要。本实践介绍了形状约束语言 (SHACL)，这是W3C推荐的用于验证RDF图谱的标准。你将构建一个验证器，用于检查知识图谱中的信息物理系统组件是否符合预定义的“形状”，这些形状规定了属性、数据类型和基数等规则。这项动手任务对于确保大规模知识图谱的一致性和完整性至关重要。",
            "id": "4228930",
            "problem": "考虑一个在信息物理系统 (CPS) 背景下，使用形状约束语言 (SHACL) 对知识图谱 (KG) 进行的简化验证任务。该 KG 被建模为一个有限的资源描述框架 (RDF) 图，包含节点、属性和类型化值。您需要实现一个验证器，在给定一个 KG 片段和一组 SHACL 形状的情况下，计算违规总数以及导致至少一次违规的节点集合。此任务要求基于形式化定义和约束进行精确实现。\n\n基本基础：\n- 资源描述框架 (RDF) 定义三元组为 $$(s,p,o) \\in N \\times P \\times (N \\cup L),$$ 其中 $N$ 是国际化资源标识符 (IRI) 的集合， $P$ 是属性 (IRI) 的集合，而 $L$ 是类型化字面量的集合。一个类型化字面量是一个对 $(v, d)$，其中 $v$ 是一个值， $d$ 是一个数据类型。\n- 形状约束语言 (SHACL) 通过形状来定义对节点的约束。一个形状 $S$ 将一个目标类 $C$ (由一个 IRI 标识) 与一组属性形状相关联，这些属性形状限制了通过属性路径 (IRI) 可达的值。一个属性形状可以约束：最小计数 ($\\text{minCount}$)、最大计数 ($\\text{maxCount}$)、节点种类 (IRI 或字面量)、数据类型 (例如，整数、浮点数、字符串)，以及数值边界 (最小包含值、最大包含值或最小排除值)。一个封闭形状也可以限制允许的属性集。\n\n要实现的验证器语义：\n- 如果节点 $n \\in N$ 具有一个 RDF 类型三元组 $(n, \\text{rdf:type}, C)$，其中 $C$ 是形状 $S$ 的目标类，则该节点将根据形状 $S$ 进行验证。\n- 对于每个路径为 $p$ 的属性形状：\n  - 计数约束：如果 $n$ 处 $p$ 的值的数量小于 $\\text{minCount}$，或超过 $\\text{maxCount}$，则为该属性形状记录一次违规。\n  - 节点种类约束：对于 $p$ 的每个值，如果一个值不是预期的种类 (IRI 或字面量)，则为每个违规值记录一次违规。\n  - 数据类型约束：对于 $p$ 的每个字面量值，如果其数据类型与预期的数据类型不匹配，则为每个违规值记录一次违规。\n  - 数值边界：对于每个数值字面量值 (视情况为整数或浮点数)，如果它违反了边界 (小于 $\\text{minInclusive}$，大于 $\\text{maxInclusive}$，或不严格大于 $\\text{minExclusive}$)，则为每个违规值记录一次违规。\n- 对于一个封闭形状，如果一个节点有任何不在允许集中的属性，则为每个多余的属性记录一次违规 (无论其基数如何)。\n- 总违规数是所有形状和节点上记录的所有违规的总和。如果一个节点在任何适用形状下有至少一个记录在案的违规，则认为该节点“导致”了违规。\n\n缩略词：\n- 知识图谱 (Knowledge Graph, KG)\n- 资源描述框架 (Resource Description Framework, RDF)\n- 形状约束语言 (Shapes Constraint Language, SHACL)\n- 信息物理系统 (Cyber-Physical Systems, CPS)\n\n所有测试用例中使用的形状：\n- 传感器形状，目标类 IRI 为 \"ex:Sensor\"：\n  - 属性 \"ex:hasSamplingPeriod\"：节点种类为字面量，数据类型为整数，$\\text{minCount} = 1$，$\\text{minInclusive} = 1$，$\\text{maxInclusive} = 60$。\n  - 属性 \"ex:connectedTo\"：节点种类为 IRI，$\\text{minCount} = 1$。\n- 执行器形状，目标类 IRI 为 \"ex:Actuator\"：\n  - 属性 \"ex:hasPowerRating\"：节点种类为字面量，数据类型为浮点数，$\\text{minExclusive} = 0$。\n  - 属性 \"ex:controlledBy\"：节点种类为 IRI，$\\text{minCount} = 1$，$\\text{maxCount} = 1$。\n- 控制器形状，目标类 IRI 为 \"ex:Controller\"：\n  - 属性 \"ex:controls\"：节点种类为 IRI，$\\text{minCount} = 2$。\n  - 封闭形状：只允许在允许集 $\\{\\text{ex:controls}\\}$ 中的属性，此外总是允许 $\\{\\text{rdf:type}\\}$。\n\nKG 表示法：\n- 每个节点都是从属性 IRI 到值列表的映射。\n- 一个值要么是 IRI，要么是字面量。一个字面量用一个 Python 值和一个数据类型 IRI 来表示。数值字面量适当地使用 Python 整数或浮点数。\n\n您的任务：\n- 根据上述语义实现验证器。\n- 将其应用于下面的测试套件。\n- 对于每个测试用例，输出一个由总违规数和导致至少一次违规的节点 IRI 的排序列表组成的对。\n\n测试套件：\n- 测试用例 $1$ (一般情况)：\n  - 节点：\n    - \"ex:S1\": \n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 值为 $0$ 的整数字面量\n      - \"ex:connectedTo\": 不存在\n    - \"ex:S2\":\n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 值为 $10$ 的整数字面量\n      - \"ex:connectedTo\": [\"ex:A1\"]\n    - \"ex:A1\":\n      - \"rdf:type\": [\"ex:Actuator\"]\n      - \"ex:hasPowerRating\": 值为 $-5.0$ 的浮点数字面量\n      - \"ex:controlledBy\": [\"ex:C1\"]\n    - \"ex:C1\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": [\"ex:S2\", \"ex:A1\"]\n      - \"ex:hasExtraProperty\": 字符串字面量 \"foo\"\n    - \"ex:U1\":\n      - \"rdf:type\": [\"ex:Unknown\"]\n      - \"ex:random\": 字符串字面量 \"bar\"\n- 测试用例 $2$ (除一个严格边界外，所有边界条件都满足)：\n  - 节点：\n    - \"ex:S3\":\n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 值为 $60$ 的整数字面量\n      - \"ex:connectedTo\": [\"ex:A2\"]\n    - \"ex:A2\":\n      - \"rdf:type\": [\"ex:Actuator\"]\n      - \"ex:hasPowerRating\": 值为 $0.0$ 的浮点数字面量\n      - \"ex:controlledBy\": [\"ex:C2\"]\n    - \"ex:C2\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": [\"ex:S3\", \"ex:A2\"]\n- 测试用例 $3$ (数据类型和节点种类不匹配以及计数违规的边缘情况)：\n  - 节点：\n    - \"ex:S4\":\n      - \"rdf:type\": [\"ex:Sensor\"]\n      - \"ex:hasSamplingPeriod\": 字符串字面量 \"ten\"\n      - \"ex:connectedTo\": 字符串字面量 \"ex:C3\"\n    - \"ex:A3\":\n      - \"rdf:type\": [\"ex:Actuator\"]\n      - \"ex:hasPowerRating\": 值为 $10.0$ 的浮点数字面量\n      - \"ex:controlledBy\": [\"ex:C3\", \"ex:C4\"]\n    - \"ex:C3\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": []\n    - \"ex:C4\":\n      - \"rdf:type\": [\"ex:Controller\"]\n      - \"ex:controls\": [\"ex:S4\"]\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个结果的形式为 $[v, L]$，其中 $v$ 是一个整数违规计数，$L$ 是导致违规的节点 IRI 的排序列表。例如，输出应如下所示：$$[[v_1, L_1],[v_2, L_2],[v_3, L_3]]$$ 除了列表格式本身固有的空格外，不应有其他空格。节点 IRI 在每个 $L$ 中应按升序字典序排序。",
            "solution": "用户提供了一个问题，要求基于形状约束语言 (SHACL) 的一个子集，为知识图谱 (KG) 实现一个验证器。该问题定义清晰，科学上基于 RDF 和 SHACL 的原则，并提供了一套明确的规则和测试用例。因此，该问题被认为是有效的。\n\n解决方案将首先使用 Python 数据结构对 KG 和 SHACL 形状进行建模，然后创建一个系统地应用指定规则的验证函数来实现。\n\n**1. 数据表示**\n\n*   **知识图谱 (KG):** KG 将表示为一个字典，将节点 IRI (字符串) 映射到它们的属性。每个属性又是一个字典，将属性 IRI (字符串) 映射到一个值列表。\n*   **值:** 一个值可以是国际化资源标识符 (IRI) 或字面量。\n    *   一个 IRI 由 Python `str` 表示。\n    *   一个字面量由 Python `tuple` 表示，形式为 `(value, datatype_iri)`，其中 `value` 是字面量的值 (例如 `int`, `float`, 或 `str`)，而 `datatype_iri` 是一个标识数据类型的 `str` (例如 `\"integer\"`, `\"float\"`)。\n*   **SHACL 形状:** 形状集将表示为一个字典，其键为目标类 IRI (字符串)。每个值是定义该形状约束的字典，包括属性形状以及该形状是否封闭。\n\n**2. 验证器设计**\n\n解决方案的核心是一个 `validate_kg` 函数，它接收一个 KG 和形状定义作为输入。它将返回违规总数和导致至少一次违规的节点集合。\n\n验证过程对 KG 中的每个节点按以下步骤进行：\n1.  **识别适用形状:** 验证器检查节点的 `rdf:type` 属性。对于与形状定义中目标类匹配的每个类型，相应形状的约束将应用于该节点。\n2.  **初始化违规计数:** 为当前节点的违规初始化一个局部计数器为 $0$。\n3.  **应用形状约束:** 对每个适用的形状，执行以下检查：\n    *   **封闭形状约束:** 如果形状被定义为封闭 (`closed: true`)，验证器会遍历该节点的所有属性。对于每个不在形状允许属性集中的属性，计为一次违规。`rdf:type` 属性被隐式允许。\n    *   **属性形状约束:** 验证器遍历主形状中定义的每个属性形状。对于每个属性形状，它将以下约束应用于节点上相应属性的值：\n        *   **基数约束 (`minCount`, `maxCount`):** 计算属性值的数量。如果此计数小于 `minCount` 或大于 `maxCount`，则为基数约束记录一次违规。\n        *   **值级别约束:** 然后，验证器遍历属性的每个单独值，并应用进一步的检查：\n            *   **节点种类约束 (`nodeKind`):** 验证值是否为预期的种类 (IRI 或字面量)。为每个不符合所需种类的值记录一次违规。如果种类不正确，则跳过对该值的进一步检查 (数据类型、数值边界)，因为它们不适用。\n            *   **数据类型约束 (`datatype`):** 对于字面量值，检查其数据类型 IRI 是否与属性形状中指定的相匹配。为每个不匹配项记录一次违规。如果数据类型不正确，则跳过后续的数值边界检查。\n            *   **数值边界约束 (`minInclusive`, `maxInclusive`, `minExclusive`):** 对于具有正确数据类型的数值字面量，验证器检查其值是否遵守给定的边界。为每个未满足的边界记录一次违规。\n\n4.  **汇总结果:** 在检查完一个节点的所有适用形状后，如果该节点的局部违规计数器大于 $0$，则将此计数加到全局总违规计数器中，并将该节点的 IRI 添加到违规节点集合中。\n\n5.  **最终输出:** 处理完 KG 中的所有节点后，该函数返回总违规计数和违规节点 IRI 的集合。然后主程序按要求对违规节点列表进行字典序排序。\n\n这种系统地应用规则确保了所有约束都得到正确检查，并且违规计数按照问题陈述中的规定进行汇总。\n\n实现将把这些步骤转化为 Python 代码。将使用辅助函数 `is_iri` 和 `is_literal` 来根据其 Python 表示 (`str` vs. `tuple`) 区分两种类型的值。问题陈述中提供的测试用例将使用这些数据结构进行编码，并传递给验证器以生成最终结果。\n\n让我们以 `测试用例 1` 中的节点 `ex:C1` 为例进行追踪：\n*   **节点:** `ex:C1` 的 `rdf:type` 为 `ex:Controller`。\n*   **适用形状:** `ex:Controller` 形状。\n*   **验证:**\n    1.  **封闭形状约束:** 该形状是封闭的，允许的属性为 `{\"ex:controls\", \"rdf:type\"}`。该节点有一个属性 `ex:hasExtraProperty`，它不在允许的集合中。这产生 $1$ 次违规。\n    2.  **属性形状 `ex:controls`:** 该形状要求 `minCount = 2` 和 `nodeKind = IRI`。\n        *   **基数:** 该节点有两个 `ex:controls` 的值：`[\"ex:S2\", \"ex:A1\"]`。计数为 $2$，满足 `minCount = 2`。没有违规。\n        *   **值级别:** `\"ex:S2\"` 和 `\"ex:A1\"` 都是字符串，因此被正确识别为 IRI。没有违规。\n*   **`ex:C1` 的总计:** 该节点有 $1$ 次违规。它被添加到违规节点列表中。\n\n这个详细的、基于规则的过程将对所有节点和所有测试用例实施，以产生所需的输出。",
            "answer": "```python\nimport numpy as np\n# No other libraries are permitted, as per the rules.\n\ndef solve():\n    \"\"\"\n    Main function to define shapes, test cases, run validation, and print results.\n    \"\"\"\n\n    # SHACL shapes definition as per the problem statement.\n    # The datatypes 'integer', 'float', 'string' are used as simplified IRIs.\n    shapes = {\n        \"ex:Sensor\": {\n            \"properties\": {\n                \"ex:hasSamplingPeriod\": {\n                    \"nodeKind\": \"Literal\",\n                    \"datatype\": \"integer\",\n                    \"minCount\": 1,\n                    \"minInclusive\": 1,\n                    \"maxInclusive\": 60,\n                },\n                \"ex:connectedTo\": {\n                    \"nodeKind\": \"IRI\",\n                    \"minCount\": 1,\n                },\n            },\n            \"closed\": False,\n        },\n        \"ex:Actuator\": {\n            \"properties\": {\n                \"ex:hasPowerRating\": {\n                    \"nodeKind\": \"Literal\",\n                    \"datatype\": \"float\",\n                    \"minExclusive\": 0.0,\n                },\n                \"ex:controlledBy\": {\n                    \"nodeKind\": \"IRI\",\n                    \"minCount\": 1,\n                    \"maxCount\": 1,\n                },\n            },\n            \"closed\": False,\n        },\n        \"ex:Controller\": {\n            \"properties\": {\n                \"ex:controls\": {\n                    \"nodeKind\": \"IRI\",\n                    \"minCount\": 2,\n                },\n            },\n            \"closed\": True,\n            \"allowedProperties\": {\"rdf:type\", \"ex:controls\"},\n        },\n    }\n\n    # Test suite definition. Literals are represented as (value, datatype_iri) tuples.\n    # IRIs are represented as strings.\n    test_cases = [\n        # Test Case 1\n        {\n            \"ex:S1\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(0, \"integer\")],\n            },\n            \"ex:S2\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(10, \"integer\")],\n                \"ex:connectedTo\": [\"ex:A1\"],\n            },\n            \"ex:A1\": {\n                \"rdf:type\": [\"ex:Actuator\"],\n                \"ex:hasPowerRating\": [(-5.0, \"float\")],\n                \"ex:controlledBy\": [\"ex:C1\"],\n            },\n            \"ex:C1\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [\"ex:S2\", \"ex:A1\"],\n                \"ex:hasExtraProperty\": [(\"foo\", \"string\")],\n            },\n            \"ex:U1\": {\n                \"rdf:type\": [\"ex:Unknown\"],\n                \"ex:random\": [(\"bar\", \"string\")],\n            },\n        },\n        # Test Case 2\n        {\n            \"ex:S3\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(60, \"integer\")],\n                \"ex:connectedTo\": [\"ex:A2\"],\n            },\n            \"ex:A2\": {\n                \"rdf:type\": [\"ex:Actuator\"],\n                \"ex:hasPowerRating\": [(0.0, \"float\")],\n                \"ex:controlledBy\": [\"ex:C2\"],\n            },\n            \"ex:C2\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [\"ex:S3\", \"ex:A2\"],\n            },\n        },\n        # Test Case 3\n        {\n            \"ex:S4\": {\n                \"rdf:type\": [\"ex:Sensor\"],\n                \"ex:hasSamplingPeriod\": [(\"ten\", \"string\")],\n                \"ex:connectedTo\": [(\"ex:C3\", \"string\")],\n            },\n            \"ex:A3\": {\n                \"rdf:type\": [\"ex:Actuator\"],\n                \"ex:hasPowerRating\": [(10.0, \"float\")],\n                \"ex:controlledBy\": [\"ex:C3\", \"ex:C4\"],\n            },\n            \"ex:C3\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [],\n            },\n            \"ex:C4\": {\n                \"rdf:type\": [\"ex:Controller\"],\n                \"ex:controls\": [\"ex:S4\"],\n            },\n        },\n    ]\n\n    results = []\n    for kg in test_cases:\n        total_violations, violating_nodes = validate_kg(kg, shapes)\n        results.append([total_violations, sorted(list(violating_nodes))])\n        \n    # Format the final output string precisely as required.\n    print(f\"[{','.join(map(str, results)).replace(' ', '')}]\")\n\n\ndef is_iri(value):\n    \"\"\"Checks if a value represents an IRI (is a string).\"\"\"\n    return isinstance(value, str)\n\ndef is_literal(value):\n    \"\"\"Checks if a value represents a Literal (is a (value, type) tuple).\"\"\"\n    return isinstance(value, tuple) and len(value) == 2 and isinstance(value[1], str)\n\ndef validate_kg(kg, shapes):\n    \"\"\"\n    Validates a Knowledge Graph against a set of SHACL shapes.\n    \n    Args:\n        kg (dict): The Knowledge Graph to validate.\n        shapes (dict): The SHACL shapes definition.\n        \n    Returns:\n        tuple: A pair (total_violations, violating_nodes_set).\n    \"\"\"\n    total_violations = 0\n    violating_nodes = set()\n\n    for node_iri, node_data in kg.items():\n        node_violations = 0\n        node_types = node_data.get(\"rdf:type\", [])\n        \n        for node_type in node_types:\n            if node_type not in shapes:\n                continue\n            \n            shape = shapes[node_type]\n            \n            # --- Closed Shape Validation ---\n            if shape.get(\"closed\", False):\n                allowed_props = shape.get(\"allowedProperties\", set())\n                for prop in node_data.keys():\n                    if prop not in allowed_props:\n                        node_violations += 1\n\n            # --- Property Shape Validation ---\n            for prop_iri, prop_shape in shape.get(\"properties\", {}).items():\n                values = node_data.get(prop_iri, [])\n                num_values = len(values)\n\n                # Count Constraints\n                if \"minCount\" in prop_shape and num_values  prop_shape[\"minCount\"]:\n                    node_violations += 1\n                if \"maxCount\" in prop_shape and num_values  prop_shape[\"maxCount\"]:\n                    node_violations += 1\n                \n                # Value-level Constraints\n                for value in values:\n                    # Node Kind Constraint\n                    if \"nodeKind\" in prop_shape:\n                        kind = prop_shape[\"nodeKind\"]\n                        if kind == \"IRI\" and not is_iri(value):\n                            node_violations += 1\n                            continue\n                        if kind == \"Literal\" and not is_literal(value):\n                            node_violations += 1\n                            continue\n                    \n                    if is_literal(value):\n                        lit_val, lit_type = value\n                        \n                        # Datatype Constraint\n                        if \"datatype\" in prop_shape and lit_type != prop_shape[\"datatype\"]:\n                            node_violations += 1\n                            continue\n                        \n                        # Numeric Bounds Constraints (only for numeric Python types)\n                        if isinstance(lit_val, (int, float)):\n                            if \"minInclusive\" in prop_shape and lit_val  prop_shape[\"minInclusive\"]:\n                                node_violations += 1\n                            if \"maxInclusive\" in prop_shape and lit_val  prop_shape[\"maxInclusive\"]:\n                                node_violations += 1\n                            if \"minExclusive\" in prop_shape and lit_val = prop_shape[\"minExclusive\"]:\n                                node_violations += 1\n\n        if node_violations  0:\n            total_violations += node_violations\n            violating_nodes.add(node_iri)\n            \n    return total_violations, violating_nodes\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}