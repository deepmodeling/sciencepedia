{
    "hands_on_practices": [
        {
            "introduction": "The foundation of a trusted boot is the ability to create an immutable record of the boot process, often achieved using a Platform Configuration Register (PCR) within a Trusted Platform Module (TPM). This exercise  provides a simplified but powerful numerical model to demystify the core mechanism of PCR extension, where each software component is measured and its hash is sequentially added to the chain of trust. By working through this model, you will gain a concrete understanding of how trust is rooted in hardware and extended through the boot sequence.",
            "id": "4220165",
            "problem": "Consider a Trusted Platform Module (TPM) that maintains a Platform Configuration Register (PCR) during trusted boot to accumulate measurements of the boot state. The PCR is extended sequentially with each measurement using a collision-resistant cryptographic hash function. In this problem, the extension operation is defined on a numeric model where the concatenation operator is encoded arithmetically. Specifically, let the concatenation of two nonnegative integers $x$ and $y$, written $x \\,\\|\\, y$, be the injective encoding $x \\cdot B + y$ with $B = 1000$ and the constraint $0 \\leq y < B$. The hash function is instantiated as\n$$H(z) = \\left(\\left(\\alpha z + \\beta \\right) \\bmod M\\right)^{3} \\bmod M,$$\nwith $M = 101$, $\\alpha = 7$, and $\\beta = 13$. Assume $H$ is collision-resistant in the modeled domain. The PCR update rule for a measurement $m$ is defined by $PCR \\leftarrow H\\!\\left(PCR \\,\\|\\, m\\right)$, applied sequentially to each measurement in order.\n\nGiven the initial register $PCR^{(0)} = 42$ and the three measurements $m_1 = 317$, $m_2 = 29$, and $m_3 = 880$, compute the final value $PCR^{(3)}$ after performing three sequential extensions under the stated rule and hash instantiation. Express your final answer as an integer in base $10$. No rounding is required.",
            "solution": "The problem is valid as it presents a well-defined computational task based on a mathematical model of a cryptographic process. All required data and rules are provided, and there are no internal contradictions or scientific inaccuracies within the model's framework.\n\nThe task is to compute the final value of a Platform Configuration Register, denoted as $PCR^{(3)}$, after three sequential updates. The process starts with an initial value $PCR^{(0)}$ and applies an extension operation for each of the three measurements $m_1$, $m_2$, and $m_3$ in order.\n\nThe given parameters are:\n- Initial PCR value: $PCR^{(0)} = 42$\n- Measurements: $m_1 = 317$, $m_2 = 29$, $m_3 = 880$\n- Concatenation encoding base: $B = 1000$\n- Hash function parameters: $\\alpha = 7$, $\\beta = 13$, and modulus $M = 101$.\n\nThe PCR update rule for a measurement $m$ is given by $PCR_{new} \\leftarrow H(PCR_{old} \\,\\|\\, m)$. The concatenation $x \\,\\|\\, y$ is arithmetically defined as $x \\cdot B + y$. The hash function is $H(z) = ((\\alpha z + \\beta) \\bmod M)^{3} \\bmod M$.\n\nWe will perform the calculation in three steps.\n\n### Step 1: Calculation of $PCR^{(1)}$\nThe first update uses $PCR^{(0)}$ and the measurement $m_1$.\nThe new PCR value, $PCR^{(1)}$, is given by $H(PCR^{(0)} \\,\\|\\, m_1)$.\n\nFirst, we compute the concatenated value, let's call it $C_1$:\n$$C_1 = PCR^{(0)} \\cdot B + m_1 = 42 \\cdot 1000 + 317 = 42000 + 317 = 42317$$\n\nNext, we apply the hash function $H$ to $C_1$. This involves first computing the inner expression $(\\alpha C_1 + \\beta) \\pmod{M}$:\n$$(\\alpha C_1 + \\beta) \\pmod{M} = (7 \\cdot 42317 + 13) \\pmod{101}$$\n$$7 \\cdot 42317 + 13 = 296219 + 13 = 296232$$\nTo find the value modulo $101$, we perform division:\n$$296232 = 2932 \\cdot 101 + 100$$\nSo, $296232 \\equiv 100 \\pmod{101}$.\n\nNow we compute the final hash value by cubing this result and taking the modulus again:\n$$PCR^{(1)} = (100)^{3} \\pmod{101}$$\nSince $100 \\equiv -1 \\pmod{101}$, we can simplify this calculation:\n$$PCR^{(1)} \\equiv (-1)^{3} \\pmod{101} \\equiv -1 \\pmod{101} \\equiv 100 \\pmod{101}$$\nThus, the PCR value after the first extension is $PCR^{(1)} = 100$.\n\n### Step 2: Calculation of $PCR^{(2)}$\nThe second update uses $PCR^{(1)}$ and the measurement $m_2$.\nThe new PCR value, $PCR^{(2)}$, is given by $H(PCR^{(1)} \\,\\|\\, m_2)$.\n\nFirst, we compute the concatenated value, $C_2$:\n$$C_2 = PCR^{(1)} \\cdot B + m_2 = 100 \\cdot 1000 + 29 = 100000 + 29 = 100029$$\n\nNext, we apply the hash function $H$ to $C_2$. We compute $(\\alpha C_2 + \\beta) \\pmod{M}$:\n$$(\\alpha C_2 + \\beta) \\pmod{M} = (7 \\cdot 100029 + 13) \\pmod{101}$$\nWe can simplify the calculation by first reducing $C_2$ modulo $101$:\n$$100029 = 990 \\cdot 101 + 39 \\implies C_2 \\equiv 39 \\pmod{101}$$\nNow substitute this into the expression:\n$$(7 \\cdot 39 + 13) \\pmod{101} = (273 + 13) \\pmod{101} = 286 \\pmod{101}$$\n$$286 = 2 \\cdot 101 + 84 \\implies 286 \\equiv 84 \\pmod{101}$$\n\nNow we compute the final hash value by cubing this result:\n$$PCR^{(2)} = (84)^{3} \\pmod{101}$$\nSince $84 \\equiv -17 \\pmod{101}$, we have:\n$$PCR^{(2)} \\equiv (-17)^{3} \\pmod{101} \\equiv -(17^{3}) \\pmod{101}$$\nLet's compute $17^3 \\pmod{101}$:\n$$17^{2} = 289 = 2 \\cdot 101 + 87 \\implies 17^{2} \\equiv 87 \\pmod{101}$$\n$$17^{3} = 17^{2} \\cdot 17 \\equiv 87 \\cdot 17 \\pmod{101} = 1479 \\pmod{101}$$\n$$1479 = 14 \\cdot 101 + 65 \\implies 1479 \\equiv 65 \\pmod{101}$$\nSubstituting back:\n$$PCR^{(2)} \\equiv -65 \\pmod{101} \\equiv 101 - 65 \\pmod{101} \\equiv 36 \\pmod{101}$$\nThus, the PCR value after the second extension is $PCR^{(2)} = 36$.\n\n### Step 3: Calculation of $PCR^{(3)}$\nThe third and final update uses $PCR^{(2)}$ and the measurement $m_3$.\nThe final PCR value, $PCR^{(3)}$, is given by $H(PCR^{(2)} \\,\\|\\, m_3)$.\n\nFirst, we compute the concatenated value, $C_3$:\n$$C_3 = PCR^{(2)} \\cdot B + m_3 = 36 \\cdot 1000 + 880 = 36000 + 880 = 36880$$\n\nNext, we apply the hash function $H$ to $C_3$. We compute $(\\alpha C_3 + \\beta) \\pmod{M}$:\n$$(\\alpha C_3 + \\beta) \\pmod{M} = (7 \\cdot 36880 + 13) \\pmod{101}$$\nWe first reduce $C_3$ modulo $101$:\n$$36880 = 365 \\cdot 101 + 15 \\implies C_3 \\equiv 15 \\pmod{101}$$\nNow substitute this into the expression:\n$$(7 \\cdot 15 + 13) \\pmod{101} = (105 + 13) \\pmod{101} = 118 \\pmod{101}$$\n$$118 = 1 \\cdot 101 + 17 \\implies 118 \\equiv 17 \\pmod{101}$$\n\nFinally, we compute the final hash value by cubing this result:\n$$PCR^{(3)} = (17)^{3} \\pmod{101}$$\nWe have already calculated this value in the previous step:\n$$17^{3} \\equiv 65 \\pmod{101}$$\nThus, the final PCR value after three extensions is $PCR^{(3)} = 65$.",
            "answer": "$$\\boxed{65}$$"
        },
        {
            "introduction": "While the conceptual model of a measured boot is elegant, its implementation in a resource-constrained embedded device presents significant engineering challenges, especially concerning memory. A secure bootloader must operate within strict limits, and this practice  simulates a real-world scenario where you must perform a first-principles analysis of memory consumption. Mastering the calculation of peak stack and heap requirements for cryptographic operations is an essential skill for designing robust and secure cyber-physical systems.",
            "id": "4220180",
            "problem": "Consider a secure trusted boot process in a resource-constrained embedded device within a cyber-physical system whose Digital Twin models memory budgets to detect unsafe configurations at boot time. The bootloader performs two sequential phases: streaming hash computation over a firmware image and Elliptic Curve Digital Signature Algorithm (ECDSA) verification of the resulting digest against a manifest resident in non-volatile storage. The system uses a Harvard architecture microcontroller with a $32$-bit word size. The following assumptions define the execution and memory model:\n\n1. Fundamental definitions:\n   - The stack is a last-in-first-out region used for function call frames, automatic (local) variables, and saved registers. At any instant, the required stack memory equals the sum of the active frames and their local storage. The peak stack requirement is the maximum of this sum over the two phases.\n   - The heap is a dynamically managed region used for long-lived objects and buffers allocated by the bootloader prior to the phases. The required heap memory equals the sum of concurrently allocated heap objects.\n\n2. Hashing phase:\n   - The Secure Hash Algorithm $256$ (SHA-256) implementation maintains:\n     - A message schedule array $W$ of $64$ words on the stack.\n     - A chaining state array $H$ of $8$ words on the stack.\n     - $6$ additional $32$-bit temporary words on the stack.\n   - The bootloader main frame stores the final $256$-bit digest ($32$ bytes) on the stack between phases to avoid heap exposure.\n   - Assume a per-frame saved-register overhead of $m$ bytes for the bootloader main, $r_h$ bytes for the hashing function frame, and $r_v$ bytes for the verifier function frame. For this microcontroller, take $m = 64$, $r_h = 64$, and $r_v = 64$.\n\n3. Verification phase:\n   - ECDSA over the NIST P-256 curve uses $256$-bit scalars and coordinates.\n   - The verifier implementation allocates on the stack:\n     - $7$ temporary $256$-bit scalars (each $32$ bytes).\n     - A modular inversion scratch array of $16$ words.\n\n4. Heap allocations:\n   - The bootloader allocates two double-buffered input buffers of size $b$ bytes each for streaming the firmware image.\n   - The signature structure, inclusive of its encoding and metadata, has size $s$ bytes and is allocated on the heap for the duration of both phases.\n\nAssume the hashing phase completes before the verification phase begins (i.e., the hashing function’s frame is not simultaneously active with the verifier’s frame), but the bootloader main frame remains active across both phases while retaining the $32$-byte digest on its stack. Using only these assumptions and standard word-size arithmetic ($1$ word $=$ $4$ bytes), derive from first principles symbolic expressions, in bytes, for:\n\n- The peak stack memory requirement across both phases.\n- The total heap memory requirement across both phases.\n\nExpress the final result as a single row matrix with two entries $\\left[ \\text{stack}, \\text{heap} \\right]$ in bytes. No numerical rounding is required. Use bytes as the unit for any quantities described in the text; do not include units in the final boxed expression.",
            "solution": "The problem requires the derivation of symbolic expressions for the peak stack memory requirement and the total heap memory requirement for a trusted boot process in an embedded device. The process consists of two sequential phases: a hashing phase and a verification phase.\n\nFirst, we establish the fundamental unit conversions based on the problem statement. The microcontroller has a $32$-bit word size, which is equivalent to $4$ bytes.\n$$\n1 \\text{ word} = 32 \\text{ bits} = 4 \\text{ bytes}\n$$\n\nThe final result will be presented as a row matrix $[M_{stack, peak}, M_{heap}]$, where $M_{stack, peak}$ is the peak stack memory and $M_{heap}$ is the total heap memory, both in bytes.\n\n**1. Heap Memory Requirement ($M_{heap}$)**\n\nThe heap is used for objects that persist across both the hashing and verification phases. According to the problem statement, the following objects are allocated on the heap:\n- Two double-buffered input buffers, each of size $b$ bytes.\n- One signature structure of size $s$ bytes.\n\nSince these objects exist concurrently, the total heap memory requirement, $M_{heap}$, is the sum of their sizes.\n$$\nM_{heap} = b + b + s = 2b + s\n$$\n\n**2. Peak Stack Memory Requirement ($M_{stack, peak}$)**\n\nThe stack memory usage changes depending on the execution phase. The bootloader's main function frame is active during both phases, while the hashing function's frame is active only during the hashing phase, and the verifier function's frame is active only during the verification phase. The peak stack requirement is the maximum stack size reached during either of these two phases.\n\nFirst, we calculate the size of the main bootloader's stack frame, $S_{main}$. This frame contains its saved-register overhead, $m$, and the $256$-bit SHA-256 digest, which is stored on the stack between phases.\n- Saved-register overhead, $m = 64$ bytes.\n- Digest size = $256$ bits = $\\frac{256}{8}$ bytes = $32$ bytes.\n\nThe size of the main frame is therefore:\n$$\nS_{main} = m + 32 \\text{ bytes} = 64 + 32 = 96 \\text{ bytes}\n$$\n\nNext, we calculate the total stack usage during each phase.\n\n**Phase 1: Hashing**\n\nDuring the hashing phase, the call stack consists of the main function and the hashing function. The total stack usage, $M_{stack, 1}$, is the sum of the main frame size ($S_{main}$) and the hashing function's frame size ($S_{h, frame}$).\n\nThe hashing function's frame ($S_{h, frame}$) consists of:\n- Saved-register overhead, $r_h = 64$ bytes.\n- SHA-256 message schedule array $W$: $64$ words = $64 \\times 4 = 256$ bytes.\n- SHA-256 chaining state array $H$: $8$ words = $8 \\times 4 = 32$ bytes.\n- Additional temporary variables: $6$ words = $6 \\times 4 = 24$ bytes.\n\nThe size of the hashing frame is:\n$$\nS_{h, frame} = r_h + (64 \\times 4) + (8 \\times 4) + (6 \\times 4) = 64 + 256 + 32 + 24 = 376 \\text{ bytes}\n$$\nThe total stack usage during the hashing phase is:\n$$\nM_{stack, 1} = S_{main} + S_{h, frame} = 96 + 376 = 472 \\text{ bytes}\n$$\n\n**Phase 2: Verification**\n\nDuring the verification phase, the call stack consists of the main function and the verifier function. The total stack usage, $M_{stack, 2}$, is the sum of the main frame size ($S_{main}$) and the verifier function's frame size ($S_{v, frame}$).\n\nThe verifier function's frame ($S_{v, frame}$) consists of:\n- Saved-register overhead, $r_v = 64$ bytes.\n- $7$ temporary $256$-bit scalars: $7 \\times (\\frac{256}{8}) = 7 \\times 32 = 224$ bytes.\n- A modular inversion scratch array: $16$ words = $16 \\times 4 = 64$ bytes.\n\nThe size of the verifier frame is:\n$$\nS_{v, frame} = r_v + (7 \\times 32) + (16 \\times 4) = 64 + 224 + 64 = 352 \\text{ bytes}\n$$\nThe total stack usage during the verification phase is:\n$$\nM_{stack, 2} = S_{main} + S_{v, frame} = 96 + 352 = 448 \\text{ bytes}\n$$\n\n**Peak Stack Calculation**\n\nThe peak stack memory requirement, $M_{stack, peak}$, is the maximum of the stack usage in the two phases.\n$$\nM_{stack, peak} = \\max(M_{stack, 1}, M_{stack, 2}) = \\max(472, 448) = 472 \\text{ bytes}\n$$\n\n**Conclusion**\n\nThe derived expressions are:\n- Peak stack memory requirement: $M_{stack, peak} = 472$ bytes.\n- Total heap memory requirement: $M_{heap} = 2b + s$ bytes.\n\nThe final result is the row matrix $[M_{stack, peak}, M_{heap}]$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n472 & 2b+s\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "In addition to memory, time is a critical constraint for cyber-physical systems, where a delayed boot can have serious operational consequences, potentially desynchronizing the physical asset from its digital twin. This exercise  challenges you to calculate the expected total boot latency by integrating deterministic performance data with probabilistic models of system jitters and delays. This analysis is vital for verifying that a device can meet its real-time operational deadlines while still maintaining a strong security posture.",
            "id": "4220179",
            "problem": "A cyber-physical systems (CPS) device with a digital twin enforces a trusted boot with a strict provisioning deadline to ensure that the digital twin can synchronize state with the physical asset before actuation. The boot process is strictly sequential (no overlap) and consists of four stages: hashing the firmware image, verifying the signature, initializing input/output (I/O), and performing attestation. Assume all random components are independent. Use only fundamental definitions of expected value, linearity of expectation, and rate-throughput-cycle relationships to derive the expected boot latency.\n\nModel each stage as follows.\n\n- Hashing stage: The device hashes a firmware image of size $64$ mebibytes (MiB), where $1$ MiB $= 2^{20}$ bytes. A cryptographic accelerator sustains a throughput of $350$ megabytes per second (MB/s), interpreted as $350 \\times 10^{6}$ bytes per second. A bus arbitration setup time adds an independent exponential delay $X$ with rate $\\lambda_{h} = 500 \\ \\text{s}^{-1}$.\n- Signature verification stage: An Elliptic Curve Digital Signature Algorithm (ECDSA) P-$256$ verification requires $5.2 \\times 10^{6}$ cycles on a $200 \\times 10^{6}$ hertz processor. An additional independent cache jitter $Y$ is exponential with rate $\\lambda_{v} = 1000 \\ \\text{s}^{-1}$.\n- I/O initialization stage: Deterministic sub-steps complete in $17$ milliseconds, $24$ milliseconds, and $12$ milliseconds, respectively.\n- Attestation stage: A Trusted Platform Module (TPM) quote generation time $Z$ is gamma distributed with shape $k = 3$ and scale $\\theta = 0.004$ seconds, and the network round-trip time $W$ is exponential with mean $0.030$ seconds.\n\nLet the hard real-time deadline be $D = 0.30$ seconds. Using first principles, compute the expected total boot latency and then compute the slack $s = D - \\mathbb{E}[T]$. Round your final numerical result for $s$ to four significant figures. Express the final answer in seconds.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It contains all necessary information to proceed with a solution.\n\nThe total boot latency, denoted by the random variable $T$, is the sum of the latencies of the four sequential stages: hashing ($T_h$), signature verification ($T_v$), I/O initialization ($T_{io}$), and attestation ($T_a$).\n$$T = T_h + T_v + T_{io} + T_a$$\nBy the linearity of expectation, the expected total boot latency $\\mathbb{E}[T]$ is the sum of the expected latencies of each stage:\n$$\\mathbb{E}[T] = \\mathbb{E}[T_h] + \\mathbb{E}[T_v] + \\mathbb{E}[T_{io}] + \\mathbb{E}[T_a]$$\nWe will compute the expected latency for each stage individually.\n\n1.  **Expected Hashing Latency $\\mathbb{E}[T_h]$**\n    The hashing stage latency $T_h$ consists of a deterministic time to hash the firmware image and an independent, random bus arbitration delay $X$.\n    $$T_h = T_{h, \\text{det}} + X$$\n    The deterministic time is the ratio of the firmware size to the accelerator's throughput. The firmware size is $64$ MiB, which is $64 \\times 2^{20}$ bytes. The throughput is $350$ MB/s, which is $350 \\times 10^{6}$ bytes/s.\n    $$T_{h, \\text{det}} = \\frac{\\text{Size}}{\\text{Throughput}} = \\frac{64 \\times 2^{20} \\ \\text{bytes}}{350 \\times 10^{6} \\ \\text{bytes/s}}$$\n    The random delay $X$ follows an exponential distribution with rate $\\lambda_{h} = 500 \\ \\text{s}^{-1}$. The expected value of an exponential random variable with rate $\\lambda$ is $1/\\lambda$.\n    $$\\mathbb{E}[X] = \\frac{1}{\\lambda_h} = \\frac{1}{500} \\ \\text{s} = 0.002 \\ \\text{s}$$\n    Therefore, the expected hashing latency is:\n    $$\\mathbb{E}[T_h] = T_{h, \\text{det}} + \\mathbb{E}[X] = \\frac{64 \\times 2^{20}}{350 \\times 10^{6}} \\ \\text{s} + 0.002 \\ \\text{s}$$\n\n2.  **Expected Signature Verification Latency $\\mathbb{E}[T_v]$**\n    The signature verification latency $T_v$ consists of a deterministic time for the CPU computation and an independent, random cache jitter delay $Y$.\n    $$T_v = T_{v, \\text{det}} + Y$$\n    The deterministic time is the ratio of the required processor cycles to the processor's frequency. The number of cycles is $5.2 \\times 10^{6}$ and the frequency is $200 \\times 10^{6}$ Hz (cycles/s).\n    $$T_{v, \\text{det}} = \\frac{\\text{Cycles}}{\\text{Frequency}} = \\frac{5.2 \\times 10^{6} \\ \\text{cycles}}{200 \\times 10^{6} \\ \\text{cycles/s}} = 0.026 \\ \\text{s}$$\n    The random jitter $Y$ follows an exponential distribution with rate $\\lambda_{v} = 1000 \\ \\text{s}^{-1}$.\n    $$\\mathbb{E}[Y] = \\frac{1}{\\lambda_v} = \\frac{1}{1000} \\ \\text{s} = 0.001 \\ \\text{s}$$\n    Therefore, the expected signature verification latency is:\n    $$\\mathbb{E}[T_v] = T_{v, \\text{det}} + \\mathbb{E}[Y] = 0.026 \\ \\text{s} + 0.001 \\ \\text{s} = 0.027 \\ \\text{s}$$\n\n3.  **Expected I/O Initialization Latency $\\mathbb{E}[T_{io}]$**\n    The I/O initialization stage consists of three deterministic sub-steps. Its total latency $T_{io}$ is the sum of their durations. Since the stage is deterministic, its expected value is the value itself.\n    $$T_{io} = 17 \\ \\text{ms} + 24 \\ \\text{ms} + 12 \\ \\text{ms} = 53 \\ \\text{ms} = 0.053 \\ \\text{s}$$\n    $$\\mathbb{E}[T_{io}] = 0.053 \\ \\text{s}$$\n\n4.  **Expected Attestation Latency $\\mathbb{E}[T_a]$**\n    The attestation latency $T_a$ is the sum of the TPM quote generation time $Z$ and the network round-trip time $W$.\n    $$T_a = Z + W$$\n    The time $Z$ is a gamma-distributed random variable with shape parameter $k = 3$ and scale parameter $\\theta = 0.004$ s. The expected value of a gamma distribution is $k\\theta$.\n    $$\\mathbb{E}[Z] = k\\theta = 3 \\times 0.004 \\ \\text{s} = 0.012 \\ \\text{s}$$\n    The time $W$ is an exponential random variable with a given mean of $0.030$ s.\n    $$\\mathbb{E}[W] = 0.030 \\ \\text{s}$$\n    Therefore, the expected attestation latency is:\n    $$\\mathbb{E}[T_a] = \\mathbb{E}[Z] + \\mathbb{E}[W] = 0.012 \\ \\text{s} + 0.030 \\ \\text{s} = 0.042 \\ \\text{s}$$\n\nNow, we sum the expected values of each stage to find the total expected boot latency $\\mathbb{E}[T]$.\n$$\\mathbb{E}[T] = \\mathbb{E}[T_h] + \\mathbb{E}[T_v] + \\mathbb{E}[T_{io}] + \\mathbb{E}[T_a]$$\nLet's first calculate the numerical value for $\\mathbb{E}[T_h]$.\n$$\\mathbb{E}[T_h] = \\frac{64 \\times 1048576}{350 \\times 10^{6}} \\ \\text{s} + 0.002 \\ \\text{s} = \\frac{67108864}{350000000} \\ \\text{s} + 0.002 \\ \\text{s}$$\n$$\\mathbb{E}[T_h] \\approx 0.19173961 \\ \\text{s} + 0.002 \\ \\text{s} = 0.19373961 \\ \\text{s}$$\nSubstituting the numerical values for all stages:\n$$\\mathbb{E}[T] \\approx 0.19373961 \\ \\text{s} + 0.027 \\ \\text{s} + 0.053 \\ \\text{s} + 0.042 \\ \\text{s}$$\n$$\\mathbb{E}[T] \\approx 0.31573961 \\ \\text{s}$$\nThe problem defines the slack $s$ as the difference between the hard real-time deadline $D = 0.30$ s and the expected total boot latency.\n$$s = D - \\mathbb{E}[T]$$\n$$s \\approx 0.30 \\ \\text{s} - 0.31573961 \\ \\text{s} = -0.01573961 \\ \\text{s}$$\nThe problem requires the final numerical result for $s$ to be rounded to four significant figures.\n$$s \\approx -0.01574 \\ \\text{s}$$\nA negative value for $s$ indicates that, on average, the boot process is expected to miss the deadline.",
            "answer": "$$\\boxed{-0.01574}$$"
        }
    ]
}