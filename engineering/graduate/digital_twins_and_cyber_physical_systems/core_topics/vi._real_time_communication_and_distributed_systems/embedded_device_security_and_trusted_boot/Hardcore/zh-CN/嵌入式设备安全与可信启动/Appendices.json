{
    "hands_on_practices": [
        {
            "introduction": "平台配置寄存器 (Platform Configuration Register, PCR) 是可信启动过程的基石，它通过密码学方法记录和总结了系统启动的每个阶段。本练习将通过一个简化的数学模型，帮助你亲手实践 PCR 的核心工作原理——顺序、不可逆的度量扩展，这是建立硬件信任根的关键。通过这个练习，你将深入理解信任链是如何通过一系列哈希运算逐步建立起来的。",
            "id": "4220165",
            "problem": "考虑一个可信平台模块 (TPM)，它在可信引导过程中维护一个平台配置寄存器 (PCR)，用以累积引导状态的度量值。PCR 使用一个抗碰撞的密码学哈希函数，随每次度量而依次扩展。在本题中，扩展操作定义在一个数值模型上，其中连接运算符被算术编码。具体来说，设两个非负整数 $x$ 和 $y$ 的连接（记为 $x \\,\\|\\, y$）为单射编码 $x \\cdot B + y$，其中 $B = 1000$ 且约束条件为 $0 \\le y  B$。哈希函数实例化为\n$$H(z) = \\left(\\left(\\alpha z + \\beta \\right) \\bmod M\\right)^{3} \\bmod M,$$\n其中 $M = 101$，$\\alpha = 7$，$\\beta = 13$。假设 $H$ 在所建模的域中是抗碰撞的。对于一个度量值 $m$，$PCR$ 的更新规则定义为 $PCR \\leftarrow H\\!\\left(PCR \\,\\|\\, m\\right)$，并按顺序依次应用于每个度量值。\n\n给定初始寄存器值 $PCR^{(0)} = 42$ 以及三个度量值 $m_1 = 317$，$m_2 = 29$ 和 $m_3 = 880$，请根据所述规则和哈希实例化，在执行三次连续扩展后计算最终值 $PCR^{(3)}$。最终答案以10进制整数形式表示。无需四舍五入。",
            "solution": "该问题是有效的，因为它提出了一个基于密码学过程数学模型的、定义明确的计算任务。所有需要的数据和规则都已提供，并且在模型框架内没有内部矛盾或科学上的不准确性。\n\n任务是计算平台配置寄存器在三次连续更新后的最终值，记为 $PCR^{(3)}$。该过程从初始值 $PCR^{(0)}$ 开始，并按顺序对三个度量值 $m_1$、$m_2$ 和 $m_3$ 中的每一个应用扩展操作。\n\n给定的参数如下：\n- 初始PCR值：$PCR^{(0)} = 42$\n- 度量值：$m_1 = 317$，$m_2 = 29$，$m_3 = 880$\n- 连接编码基数：$B = 1000$\n- 哈希函数参数：$\\alpha = 7$，$\\beta = 13$，模数 $M = 101$。\n\n对于一个度量值 $m$，$PCR$ 的更新规则由 $PCR_{new} \\leftarrow H(PCR_{old} \\,\\|\\, m)$ 给出。连接 $x \\,\\|\\, y$ 在算术上定义为 $x \\cdot B + y$。哈希函数为 $H(z) = ((\\alpha z + \\beta) \\bmod M)^{3} \\bmod M$。\n\n我们将分三步进行计算。\n\n### 第1步：计算 $PCR^{(1)}$\n第一次更新使用 $PCR^{(0)}$ 和度量值 $m_1$。\n新的PCR值 $PCR^{(1)}$ 由 $H(PCR^{(0)} \\,\\|\\, m_1)$ 给出。\n\n首先，我们计算连接后的值，称之为 $C_1$：\n$$C_1 = PCR^{(0)} \\cdot B + m_1 = 42 \\cdot 1000 + 317 = 42000 + 317 = 42317$$\n\n接下来，我们将哈希函数 $H$ 应用于 $C_1$。这需要先计算内部表达式 $(\\alpha C_1 + \\beta) \\pmod{M}$：\n$$(\\alpha C_1 + \\beta) \\pmod{M} = (7 \\cdot 42317 + 13) \\pmod{101}$$\n$$7 \\cdot 42317 + 13 = 296219 + 13 = 296232$$\n为了求模101的值，我们执行除法：\n$$296232 = 2932 \\cdot 101 + 100$$\n所以，$296232 \\equiv 100 \\pmod{101}$。\n\n现在我们通过对该结果求立方并再次取模来计算最终哈希值：\n$$PCR^{(1)} = (100)^{3} \\pmod{101}$$\n由于 $100 \\equiv -1 \\pmod{101}$，我们可以简化此计算：\n$$PCR^{(1)} \\equiv (-1)^{3} \\pmod{101} \\equiv -1 \\pmod{101} \\equiv 100 \\pmod{101}$$\n因此，第一次扩展后的PCR值为 $PCR^{(1)} = 100$。\n\n### 第2步：计算 $PCR^{(2)}$\n第二次更新使用 $PCR^{(1)}$ 和度量值 $m_2$。\n新的PCR值 $PCR^{(2)}$ 由 $H(PCR^{(1)} \\,\\|\\, m_2)$ 给出。\n\n首先，我们计算连接后的值 $C_2$：\n$$C_2 = PCR^{(1)} \\cdot B + m_2 = 100 \\cdot 1000 + 29 = 100000 + 29 = 100029$$\n\n接下来，我们将哈希函数 $H$ 应用于 $C_2$。我们计算 $(\\alpha C_2 + \\beta) \\pmod{M}$：\n$$(\\alpha C_2 + \\beta) \\pmod{M} = (7 \\cdot 100029 + 13) \\pmod{101}$$\n我们可以通过先将 $C_2$ 对 101 取模来简化计算：\n$$100029 = 990 \\cdot 101 + 39 \\implies C_2 \\equiv 39 \\pmod{101}$$\n现在将此代入表达式：\n$$(7 \\cdot 39 + 13) \\pmod{101} = (273 + 13) \\pmod{101} = 286 \\pmod{101}$$\n$$286 = 2 \\cdot 101 + 84 \\implies 286 \\equiv 84 \\pmod{101}$$\n\n现在我们通过对该结果求立方来计算最终哈希值：\n$$PCR^{(2)} = (84)^{3} \\pmod{101}$$\n由于 $84 \\equiv -17 \\pmod{101}$，我们有：\n$$PCR^{(2)} \\equiv (-17)^{3} \\pmod{101} \\equiv -(17^{3}) \\pmod{101}$$\n让我们计算 $17^3 \\pmod{101}$：\n$$17^{2} = 289 = 2 \\cdot 101 + 87 \\implies 17^{2} \\equiv 87 \\pmod{101}$$\n$$17^{3} = 17^{2} \\cdot 17 \\equiv 87 \\cdot 17 \\pmod{101} = 1479 \\pmod{101}$$\n$$1479 = 14 \\cdot 101 + 65 \\implies 1479 \\equiv 65 \\pmod{101}$$\n代回：\n$$PCR^{(2)} \\equiv -65 \\pmod{101} \\equiv 101 - 65 \\pmod{101} \\equiv 36 \\pmod{101}$$\n因此，第二次扩展后的PCR值为 $PCR^{(2)} = 36$。\n\n### 第3步：计算 $PCR^{(3)}$\n第三次也是最后一次更新使用 $PCR^{(2)}$ 和度量值 $m_3$。\n最终的PCR值 $PCR^{(3)}$ 由 $H(PCR^{(2)} \\,\\|\\, m_3)$ 给出。\n\n首先，我们计算连接后的值 $C_3$：\n$$C_3 = PCR^{(2)} \\cdot B + m_3 = 36 \\cdot 1000 + 880 = 36000 + 880 = 36880$$\n\n接下来，我们将哈希函数 $H$ 应用于 $C_3$。我们计算 $(\\alpha C_3 + \\beta) \\pmod{M}$：\n$$(\\alpha C_3 + \\beta) \\pmod{M} = (7 \\cdot 36880 + 13) \\pmod{101}$$\n我们首先将 $C_3$ 对 101 取模：\n$$36880 = 365 \\cdot 101 + 15 \\implies C_3 \\equiv 15 \\pmod{101}$$\n现在将此代入表达式：\n$$(7 \\cdot 15 + 13) \\pmod{101} = (105 + 13) \\pmod{101} = 118 \\pmod{101}$$\n$$118 = 1 \\cdot 101 + 17 \\implies 118 \\equiv 17 \\pmod{101}$$\n\n最后，我们通过对该结果求立方来计算最终哈希值：\n$$PCR^{(3)} = (17)^{3} \\pmod{101}$$\n我们已在上一步中计算过此值：\n$$17^{3} \\equiv 65 \\pmod{101}$$\n因此，三次扩展后的最终PCR值为 $PCR^{(3)} = 65$。",
            "answer": "$$\\boxed{65}$$"
        },
        {
            "introduction": "实现可信启动中的密码学操作并非没有代价，尤其是在资源受限的嵌入式设备中，内存是至关重要的稀缺资源。本练习将引导你分析一个真实安全引导加载程序 (bootloader) 的栈 (stack) 和堆 (heap) 内存需求，这是嵌入式系统工程师必须掌握的一项关键技能。通过精确计算内存占用，可以确保引导加载程序在满足安全要求的同时，能够在硬件限制下稳定运行。",
            "id": "4220180",
            "problem": "考虑一个网络物理系统中的资源受限嵌入式设备的安全可信启动过程，该系统的数字孪生对内存预算进行建模，以在启动时检测不安全的配置。引导加载程序执行两个顺序阶段：对固件镜像进行流式哈希计算，以及根据驻留在非易失性存储中的清单，对生成的摘要进行椭圆曲线数字签名算法 (ECDSA) 验证。该系统使用一个具有$32$位字长的哈佛架构微控制器。以下假设定义了执行和内存模型：\n\n1. 基本定义：\n   - 栈是一个后进先出的区域，用于存放函数调用帧、自动（局部）变量和已保存的寄存器。在任何时刻，所需的栈内存等于活动帧及其局部存储的总和。峰值栈需求是这两个阶段中此总和的最大值。\n   - 堆是一个动态管理的区域，用于存放在这些阶段之前由引导加载程序分配的长生命周期对象和缓冲区。所需的堆内存等于并发分配的堆对象的总和。\n\n2. 哈希阶段：\n   - 安全哈希算法 $256$ (SHA-256) 的实现维护：\n     - 栈上的一个 $64$ 字的消息调度数组 $W$。\n     - 栈上的一个 $8$ 字的链式状态数组 $H$。\n     - 栈上的 $6$ 个额外的 $32$位临时字。\n   - 引导加载程序主帧在阶段之间将最终的 $256$位摘要（$32$ 字节）存储在栈上，以避免堆暴露。\n   - 假设引导加载程序主帧的每帧寄存器保存开销为 $m$ 字节，哈希函数帧为 $r_h$ 字节，验证函数帧为 $r_v$ 字节。对于此微控制器，取 $m = 64$，$r_h = 64$，$r_v = 64$。\n\n3. 验证阶段：\n   - 基于 NIST P-256 曲线的 ECDSA 使用 $256$位的标量和坐标。\n   - 验证器的实现在栈上分配：\n     - $7$ 个临时的 $256$位标量（每个 $32$ 字节）。\n     - 一个 $16$ 字的模逆运算暂存数组。\n\n4. 堆分配：\n   - 引导加载程序分配两个大小各为 $b$ 字节的双缓冲输入缓冲区，用于固件镜像的流式传输。\n   - 签名结构，包括其编码和元数据，大小为 $s$ 字节，并在两个阶段的持续时间内分配在堆上。\n\n假设哈希阶段在验证阶段开始前完成（即，哈希函数的帧不与验证器的帧同时活动），但引导加载程序的主帧在两个阶段中保持活动，同时在其栈上保留 $32$字节的摘要。仅使用这些假设和标准的字长算术（$1$ 字 $=$ $4$ 字节），从第一性原理推导以下内容的符号表达式（以字节为单位）：\n\n- 跨越两个阶段的峰值栈内存需求。\n- 跨越两个阶段的总堆内存需求。\n\n将最终结果表示为一个包含两个条目 $\\left[ \\text{stack}, \\text{heap} \\right]$ 的单行矩阵，单位为字节。无需进行数值舍入。使用字节作为文本中描述的任何数量的单位；不要在最终的方框表达式中包含单位。",
            "solution": "该问题要求为嵌入式设备中的可信启动过程推导峰值栈内存需求和总堆内存需求的符号表达式。该过程包括两个顺序阶段：一个哈希阶段和一个验证阶段。\n\n首先，我们根据问题陈述建立基本单位换算。该微控制器具有 $32$ 位字长，等同于 $4$ 字节。\n$$\n1 \\text{ word} = 32 \\text{ bits} = 4 \\text{ bytes}\n$$\n\n最终结果将以行矩阵 $[M_{stack, peak}, M_{heap}]$ 的形式呈现，其中 $M_{stack, peak}$ 是峰值栈内存，$M_{heap}$ 是总堆内存，单位均为字节。\n\n**1. 堆内存需求 ($M_{heap}$)**\n\n堆用于在哈希和验证两个阶段都持续存在的对象。根据问题陈述，以下对象被分配在堆上：\n- 两个双缓冲输入缓冲区，每个大小为 $b$ 字节。\n- 一个大小为 $s$ 字节的签名结构。\n\n由于这些对象并发存在，总堆内存需求 $M_{heap}$ 是它们大小的总和。\n$$\nM_{heap} = b + b + s = 2b + s\n$$\n\n**2. 峰值栈内存需求 ($M_{stack, peak}$)**\n\n栈内存使用情况根据执行阶段而变化。引导加载程序的主函数帧在两个阶段都处于活动状态，而哈希函数的帧仅在哈希阶段活动，验证函数的帧仅在验证阶段活动。峰值栈需求是在这两个阶段中达到的最大栈大小。\n\n首先，我们计算主引导加载程序栈帧的大小 $S_{main}$。该帧包含其寄存器保存开销 $m$ 和在阶段之间存储在栈上的 $256$位 SHA-256 摘要。\n- 寄存器保存开销，$m = 64$ 字节。\n- 摘要大小 = $256$ 位 = $\\frac{256}{8}$ 字节 = $32$ 字节。\n\n因此，主帧的大小为：\n$$\nS_{main} = m + 32 \\text{ bytes} = 64 + 32 = 96 \\text{ bytes}\n$$\n\n接下来，我们计算每个阶段的总栈使用量。\n\n**阶段 1：哈希**\n\n在哈希阶段，调用栈由主函数和哈希函数组成。总栈使用量 $M_{stack, 1}$ 是主帧大小 ($S_{main}$) 和哈希函数帧大小 ($S_{h, frame}$) 的总和。\n\n哈希函数帧 ($S_{h, frame}$) 由以下部分组成：\n- 寄存器保存开销，$r_h = 64$ 字节。\n- SHA-256 消息调度数组 $W$：$64$ 字 = $64 \\times 4 = 256$ 字节。\n- SHA-256 链式状态数组 $H$：$8$ 字 = $8 \\times 4 = 32$ 字节。\n- 额外的临时变量：$6$ 字 = $6 \\times 4 = 24$ 字节。\n\n哈希帧的大小为：\n$$\nS_{h, frame} = r_h + (64 \\times 4) + (8 \\times 4) + (6 \\times 4) = 64 + 256 + 32 + 24 = 376 \\text{ bytes}\n$$\n哈希阶段的总栈使用量为：\n$$\nM_{stack, 1} = S_{main} + S_{h, frame} = 96 + 376 = 472 \\text{ bytes}\n$$\n\n**阶段 2：验证**\n\n在验证阶段，调用栈由主函数和验证函数组成。总栈使用量 $M_{stack, 2}$ 是主帧大小 ($S_{main}$) 和验证函数帧大小 ($S_{v, frame}$) 的总和。\n\n验证函数帧 ($S_{v, frame}$) 由以下部分组成：\n- 寄存器保存开销，$r_v = 64$ 字节。\n- $7$ 个临时的 $256$位标量：$7 \\times (\\frac{256}{8}) = 7 \\times 32 = 224$ 字节。\n- 一个模逆运算暂存数组：$16$ 字 = $16 \\times 4 = 64$ 字节。\n\n验证帧的大小为：\n$$\nS_{v, frame} = r_v + (7 \\times 32) + (16 \\times 4) = 64 + 224 + 64 = 352 \\text{ bytes}\n$$\n验证阶段的总栈使用量为：\n$$\nM_{stack, 2} = S_{main} + S_{v, frame} = 96 + 352 = 448 \\text{ bytes}\n$$\n\n**峰值栈计算**\n\n峰值栈内存需求 $M_{stack, peak}$ 是两个阶段中栈使用量的最大值。\n$$\nM_{stack, peak} = \\max(M_{stack, 1}, M_{stack, 2}) = \\max(472, 448) = 472 \\text{ bytes}\n$$\n\n**结论**\n\n推导出的表达式为：\n- 峰值栈内存需求：$M_{stack, peak} = 472$ 字节。\n- 总堆内存需求：$M_{heap} = 2b + s$ 字节。\n\n最终结果是行矩阵 $[M_{stack, peak}, M_{heap}]$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n472  2b+s\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "即使部署了强大的可信启动机制，系统仍然可能存在安全漏洞，特别是在物理层面。本练习将焦点从实现转向安全分析，模拟一种常见的“回滚攻击” (rollback attack)，这种攻击可由电源电压暂降 (brownout) 等物理事件触发。通过计算攻击成功的期望次数，你将学习如何量化安全风险，这是设计高弹性信息物理系统 (CPS) 的核心能力之一。",
            "id": "4220148",
            "problem": "一个信息物理系统采用一种可信启动机制，该机制通过存储在可信平台模块（TPM）中的单调版本计数器来强制执行反回滚。反回滚规则是：仅当镜像的版本号大于或等于单调计数器的值时，该镜像才被接受用于启动。在一个特定的嵌入式设备中，工程师们发现在电源循环期间的掉电条件下，一个硬件竞争条件可以在比较逻辑运行之前将单调计数器重置为零。该设备的电源和时钟域的数字孪生对此事件进行建模，并估计如下：在任何给定的攻击尝试的电源循环中，单调计数器重置为零的概率为 $p$，且各次尝试之间相互独立。如果计数器重置发生在版本比较之前，从而导致一个较旧的镜像被接受，则该回滚尝试被认为是“成功的”。在第一次成功回滚之后，一个“篡改锁定”位会被设置，以防止任何进一步的回滚（因此在单个设备上的所有尝试中，最多只能发生一次成功的回滚）。一名攻击者在单个设备上执行 $n$ 次独立的、由掉电引起的电源循环作为回滚尝试。\n\n仅从概率公理（补集和独立性）以及离散随机变量的期望定义出发，推导出一个关于 $n$ 次尝试中成功回滚次数期望值的封闭形式解析表达式，该表达式是 $p$ 和 $n$ 的函数。将您的最终答案表示为单个封闭形式表达式。无需四舍五入。",
            "solution": "该问题要求推导在 $n$ 次尝试中成功回滚次数的期望值。\n\n设 $X$ 是一个随机变量，表示在 $n$ 次尝试中成功回滚的次数。\n根据问题描述，“在第一次成功回滚之后，一个‘篡改锁定’位会被设置，以防止任何进一步的回滚”。这意味着在 $n$ 次尝试中，最多只能有一次成功。因此，随机变量 $X$ 只能取两个值：0（没有成功的回滚）或 1（有一次成功的回滚）。\n\n根据期望值的定义，对于一个离散随机变量，其期望值为：\n$$E[X] = \\sum_{k} k \\cdot P(X=k)$$\n在我们的情况下，这个和只有两项：\n$$E[X] = 0 \\cdot P(X=0) + 1 \\cdot P(X=1) = P(X=1)$$\n因此，我们只需要计算事件“$X=1$”的概率，即在 $n$ 次尝试中至少有一次成功的概率。\n\n直接计算 $P(X=1)$ 可能比较复杂。一个更简单的方法是计算其补集事件的概率，即事件“$X=0$”（在 $n$ 次尝试中没有一次成功）。\n\n*   单次尝试成功的概率（即计数器被重置）为 $p$。\n*   因此，单次尝试失败的概率（即计数器未被重置）为 $1-p$。\n\n由于每次尝试都是独立的，所以 $n$ 次尝试全部失败的概率是每次尝试失败概率的乘积：\n$$P(X=0) = (1-p) \\cdot (1-p) \\cdot \\ldots \\cdot (1-p) \\quad (n \\text{ 次})$$\n$$P(X=0) = (1-p)^n$$\n\n事件“至少有一次成功”($X=1$) 与事件“没有成功”($X=0$) 是互补的，所以它们的概率之和为 1。\n$$P(X=1) + P(X=0) = 1$$\n因此，我们可以求得 $P(X=1)$：\n$$P(X=1) = 1 - P(X=0) = 1 - (1-p)^n$$\n\n因为 $E[X] = P(X=1)$，所以成功回滚次数的期望值为：\n$$E[X] = 1 - (1-p)^n$$\n这就是关于 $p$ 和 $n$ 的封闭形式解析表达式。",
            "answer": "$$\\boxed{1 - (1-p)^{n}}$$"
        }
    ]
}