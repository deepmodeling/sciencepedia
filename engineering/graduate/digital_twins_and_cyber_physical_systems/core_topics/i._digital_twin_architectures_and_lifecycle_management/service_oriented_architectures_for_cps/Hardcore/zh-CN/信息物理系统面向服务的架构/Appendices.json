{
    "hands_on_practices": [
        {
            "introduction": "在许多信息物理系统（CPS）中，特别是那些涉及安全关键功能的系统，服务必须提供硬实时保障。本练习将介绍响应时间分析（Response Time Analysis, RTA），这是实时系统理论的基石，它使我们能够确定性地验证一个服务即使在来自更高优先级任务的最坏情况干扰下，是否仍能满足其严格的截止时间要求 。掌握这种计算方法对于构建可预测且可靠的CPS至关重要。",
            "id": "4245887",
            "problem": "一个用于机器人生产单元的信息物理系统 (CPS) 在边缘控制器上使用面向服务的架构 (SOA) 实现。该边缘控制器在单处理器上使用固定优先级抢占式调度 (FPPS) 并采用速率单调优先级分配方案来执行服务任务：周期较短的服务具有较高的优先级。所有服务都是严格周期性的、独立的（无共享资源或自中断），并且没有释放抖动。通信和中间件开销已包含在最坏情况执行时间 (WCETs) 中。考虑以下服务，它们都映射到同一个处理器上：\n\n- 传感器预处理服务：周期 $T_{1} = 5\\,\\mathrm{ms}$，最坏情况执行时间 $C_{1} = 1\\,\\mathrm{ms}$。\n- 遥测编码服务：周期 $T_{2} = 10\\,\\mathrm{ms}$，最坏情况执行时间 $C_{2} = 1.5\\,\\mathrm{ms}$。\n- 执行器看门狗服务：周期 $T_{3} = 20\\,\\mathrm{ms}$，最坏情况执行时间 $C_{3} = 2\\,\\mathrm{ms}$。\n- 数字孪生状态协调服务（我们关注的任务）：周期 $T_{4} = 40\\,\\mathrm{ms}$，最坏情况执行时间 $C_{4} = 4\\,\\mathrm{ms}$，相对截止时间 $D_{4} = 12\\,\\mathrm{ms}$。\n\n你需要计算在所有更高优先级服务同步释放的情况下，数字孪生状态协调服务的最坏情况响应时间 $R_{4}$，计算需使用固定优先级系统的基本繁忙窗口论证以及响应时间的定义（自身执行时间加上所有更高优先级服务的干扰）。判断该服务相对于其相对截止时间 $D_{4}$ 是否可调度。\n\n将你的最终答案以双分量向量 $(R_{4}, s)$ 的形式报告，其中 $R_{4}$ 是最坏情况响应时间，$s$ 是一个指示符，定义为：如果 $R_{4} \\leq D_{4}$，则 $s = 1$，否则 $s = 0$。以毫秒为单位表示 $R_{4}$。提供 $R_{4}$ 的精确值（不要四舍五入）。",
            "solution": "该问题是有效的，因为它科学地基于实时系统分析的原理，问题设定良好，数据充分且一致，陈述客观。它代表了响应时间分析在固定优先级抢占式系统中的一个标准应用。\n\n该问题要求计算第四个服务（任务 $\\tau_4$）的最坏情况响应时间 $R_4$，并判断其可调度性。系统采用固定优先级抢占式调度 (FPPS) 和速率单调优先级分配方案。\n\n首先，我们确定每个服务的优先级。在速率单调调度下，周期越短，优先级越高。令 $P_i$ 表示服务 $\\tau_i$ 的优先级。$P_i$ 的数值越小，表示优先级越高。\n各周期分别为 $T_1 = 5\\,\\mathrm{ms}$、$T_2 = 10\\,\\mathrm{ms}$、$T_3 = 20\\,\\mathrm{ms}$ 和 $T_4 = 40\\,\\mathrm{ms}$。\n由于 $T_1  T_2  T_3  T_4$，优先级分配如下：\n- 服务 $\\tau_1$：优先级 $P_1 = 1$（最高）\n- 服务 $\\tau_2$：优先级 $P_2 = 2$\n- 服务 $\\tau_3$：优先级 $P_3 = 3$\n- 服务 $\\tau_4$：优先级 $P_4 = 4$（最低）\n\n我们关注的任务是 $\\tau_4$。其最坏情况响应时间 $R_4$ 使用响应时间分析 (RTA) 来确定。最坏情况发生在临界瞬间，即 $\\tau_4$ 与所有更高优先级的任务（$\\tau_1, \\tau_2, \\tau_3$）同时释放。响应时间 $R_4$ 是其自身最坏情况执行时间 $C_4$ 与在区间 $[0, R_4)$ 内所有更高优先级任务造成的总干扰之和。来自更高优先级任务 $\\tau_j$ 的干扰是其在该区间内的激活次数乘以其执行时间 $C_j$。任务 $\\tau_j$ 在长度为 $t$ 的区间内的激活次数由 $\\lceil \\frac{t}{T_j} \\rceil$ 给出。\n\n任务 $\\tau_i$ 的响应时间 $R_i$ 是满足以下方程的最小正值 $t$：\n$$t = C_i + \\sum_{j \\in hp(i)} \\left\\lceil \\frac{t}{T_j} \\right\\rceil C_j$$\n其中 $hp(i)$ 是比 $\\tau_i$ 优先级更高的任务集合。\n\n对于任务 $\\tau_4$，更高优先级的任务集合是 $hp(4) = \\{\\tau_1, \\tau_2, \\tau_3\\}$。$R_4$ 的方程为：\n$$R_4 = C_4 + \\left\\lceil \\frac{R_4}{T_1} \\right\\rceil C_1 + \\left\\lceil \\frac{R_4}{T_2} \\right\\rceil C_2 + \\left\\lceil \\frac{R_4}{T_3} \\right\\rceil C_3$$\n该方程使用迭代方法求解。设 $w$ 为正在计算的繁忙窗口的长度。\n$$w^{(n+1)} = C_4 + \\sum_{j=1}^{3} \\left\\lceil \\frac{w^{(n)}}{T_j} \\right\\rceil C_j$$\n迭代从一个初始猜测值开始，通常为 $w^{(0)} = C_4$。当 $w^{(n+1)} = w^{(n)}$ 时，迭代收敛。这个不动点就是最坏情况响应时间 $R_4$。\n\n给定的参数如下：\n- $C_1 = 1\\,\\mathrm{ms}$，$T_1 = 5\\,\\mathrm{ms}$\n- $C_2 = 1.5\\,\\mathrm{ms}$，$T_2 = 10\\,\\mathrm{ms}$\n- $C_3 = 2\\,\\mathrm{ms}$，$T_3 = 20\\,\\mathrm{ms}$\n- $C_4 = 4\\,\\mathrm{ms}$\n\n迭代公式变为：\n$$w^{(n+1)} = 4 + \\left\\lceil \\frac{w^{(n)}}{5} \\right\\rceil(1) + \\left\\lceil \\frac{w^{(n)}}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{w^{(n)}}{20} \\right\\rceil(2)$$\n\n我们开始迭代。\n第0步：用 $w^{(0)} = C_4 = 4$ 初始化。\n$$w^{(0)} = 4$$\n\n第1步：使用 $w^{(0)} = 4$ 计算 $w^{(1)}$。\n$$w^{(1)} = 4 + \\left\\lceil \\frac{4}{5} \\right\\rceil(1) + \\left\\lceil \\frac{4}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{4}{20} \\right\\rceil(2)$$\n$$w^{(1)} = 4 + (1)(1) + (1)(1.5) + (1)(2) = 4 + 1 + 1.5 + 2 = 8.5$$\n\n第2步：使用 $w^{(1)} = 8.5$ 计算 $w^{(2)}$。\n$$w^{(2)} = 4 + \\left\\lceil \\frac{8.5}{5} \\right\\rceil(1) + \\left\\lceil \\frac{8.5}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{8.5}{20} \\right\\rceil(2)$$\n$$w^{(2)} = 4 + \\lceil 1.7 \\rceil(1) + \\lceil 0.85 \\rceil(1.5) + \\lceil 0.425 \\rceil(2)$$\n$$w^{(2)} = 4 + (2)(1) + (1)(1.5) + (1)(2) = 4 + 2 + 1.5 + 2 = 9.5$$\n\n第3步：使用 $w^{(2)} = 9.5$ 计算 $w^{(3)}$。\n$$w^{(3)} = 4 + \\left\\lceil \\frac{9.5}{5} \\right\\rceil(1) + \\left\\lceil \\frac{9.5}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{9.5}{20} \\right\\rceil(2)$$\n$$w^{(3)} = 4 + \\lceil 1.9 \\rceil(1) + \\lceil 0.95 \\rceil(1.5) + \\lceil 0.475 \\rceil(2)$$\n$$w^{(3)} = 4 + (2)(1) + (1)(1.5) + (1)(2) = 4 + 2 + 1.5 + 2 = 9.5$$\n\n由于 $w^{(3)} = w^{(2)} = 9.5$，迭代已收敛。服务 $\\tau_4$ 的最坏情况响应时间为 $R_4 = 9.5\\,\\mathrm{ms}$。\n\n接下来，我们必须通过将其最坏情况响应时间 $R_4$ 与其相对截止时间 $D_4$ 进行比较，来判断该服务是否可调度。问题陈述 $D_4 = 12\\,\\mathrm{ms}$。\n可调度性条件是 $R_4 \\le D_4$。\n代入数值，我们检查 $9.5 \\le 12$ 是否成立。此不等式为真。\n因此，数字孪生状态协调服务是可调度的。\n\n问题要求一个双分量向量 $(R_4, s)$，其中 $R_4$ 是最坏情况响应时间，$s$ 是一个指示变量。指示符 $s$ 的定义为：如果 $R_4 \\le D_4$，则 $s=1$；否则 $s=0$。\n由于 $R_4 = 9.5\\,\\mathrm{ms}$ 且 $R_4 \\leq D_4$，我们得到 $s=1$。\n因此得到的向量是 $(9.5, 1)$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 9.5  1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "尽管硬实时保障对某些任务至关重要，但复杂CPS中的许多服务在软实时约束下运行，在这些约束中，绝对的确定性是不切实际的。本练习探讨了在服务水平协议（SLA）中形式化的概率性保障概念，并演示了如何运用统计学原理来分析端到端延迟 。你将学习如何计算一个能够以高概率满足的截止时间，这是大规模、面向服务的系统中常见的需求。",
            "id": "4245817",
            "problem": "一个信息物理系统 (CPS) 部署了一个控制回路，该回路以面向服务的架构实现，由一系列微服务组成：感知、通信、边缘融合、数字孪生预测和驱动。端到端请求延迟是各阶段延迟的总和。对于给定的运行机制，每个阶段的延迟被建模为一个具有有限二阶矩的独立随机变量，测量结果表明各个阶段的近似高斯分布概要（以毫秒 ms 为单位）如下：感知的均值为 $2.0$，标准差为 $0.4$；通信的均值为 $5.0$，标准差为 $1.5$；边缘融合的均值为 $3.5$，标准差为 $0.7$；数字孪生预测的均值为 $8.0$，标准差为 $2.0$；驱动的均值为 $1.5$，标准差为 $0.3$。\n\n从实时保证和服务水平协议 (SLA) 的基本定义出发，解释在 CPS 中软实时和硬实时服务保证之间的区别。然后，构建一个 SLA 声明，通过要求控制回路的端到端延迟满足 $P(\\text{延迟} \\leq D) \\geq 0.999$ 来量化一个概率性截止时间。最后，在独立性和有限方差的假设下，并使用适用于服务组合中随机延迟总和的、经过充分检验的概率原理，推导出满足 $P(\\text{延迟} \\leq D) \\geq 0.999$ 的最小截止时间 $D$，并根据所提供的数据计算其数值。\n\n将 $D$ 的数值答案四舍五入到四位有效数字，并以毫秒 (ms) 表示。",
            "solution": "该问题要求解释实时保证，并为一个信息物理系统 (CPS) 控制回路计算概率性延迟截止时间。该问题具有科学依据，提法明确，并包含了获得唯一解所需的所有信息。因此，该问题是有效的。\n\n首先，我们解决问题的概念部分：在 CPS 背景下，软实时和硬实时服务保证的区别。\n\n实时系统是一种计算系统，其结果的正确性不仅取决于其逻辑值，还取决于其交付的时间。截止时间是一个特定任务必须完成的时间限制。\n\n1.  **硬实时保证**：在一个具有硬实时保证的系统中，错过截止时间即构成整个系统的故障。这种故障的后果通常是灾难性的，可能导致生命损失、重大财务损害或任务失败。因此，系统设计必须保证在所有指定的操作条件下，每个截止时间都确定性地得到满足。这些保证是绝对的，而非概率性的。处理器必须在预先计算的最坏情况执行时间 (WCET) 内执行任务。例子包括飞机中的飞行控制系统、汽车中的防抱死制动系统以及医用心脏起搏器。硬实时系统的 SLA 将是绝对的，例如，“延迟应小于或等于 $10$ 毫秒，在 $100\\%$ 的时间内满足。”\n\n2.  **软实时保证**：在一个具有软实时保证的系统中，错过截止时间是不希望发生的，并且会降低系统性能或服务质量，但它不是一个关键性故障。随着错过更多截止时间，系统的效用可能会下降，但整个系统仍能继续运行。此类系统中的保证通常是统计性或概率性的。本问题提供了一个以服务水平协议 (SLA) 形式制定的软实时保证的典型例子。例子包括实时视频流，其中偶尔的掉帧是可以接受的，或者数据记录系统，其中丢失少量数据点是可以容忍的。\n\n该问题要求根据所提供的概率性要求构建一个 SLA 声明。这样的 SLA 为 CPS 控制回路形式化了一个软实时保证。该声明如下：\n控制回路的端到端延迟，用随机变量 $L$ 表示，不得超过截止时间 $D$ 的概率至少为 $0.999$。形式上，这写作：\n$$P(L \\leq D) \\geq 0.999$$\n\n接下来，我们推导满足此 SLA 的截止时间 $D$ 的值。端到端延迟 $L$ 是五个顺序微服务延迟的总和：感知 ($L_s$)、通信 ($L_c$)、边缘融合 ($L_f$)、数字孪生预测 ($L_p$) 和驱动 ($L_a$) 。\n$$L = L_s + L_c + L_f + L_p + L_a$$\n问题陈述，这些阶段延迟是独立随机变量。根据独立随机变量之和的期望和方差的基本性质：\n\n总延迟的均值 $\\mu_L$ 是各个均值的总和：\n$$\\mu_L = E[L] = E[L_s] + E[L_c] + E[L_f] + E[L_p] + E[L_a]$$\n总延迟的方差 $\\sigma_L^2$ 是各个方差的总和：\n$$\\sigma_L^2 = \\text{Var}(L) = \\text{Var}(L_s) + \\text{Var}(L_c) + \\text{Var}(L_f) + \\text{Var}(L_p) + \\text{Var}(L_a)$$\n标准差为 $\\sigma_L = \\sqrt{\\sigma_L^2}$。\n\n问题提供了以下数据（以毫秒 ms 为单位）：\n-   感知：$\\mu_s = 2.0$, $\\sigma_s = 0.4 \\implies \\sigma_s^2 = 0.16$\n-   通信：$\\mu_c = 5.0$, $\\sigma_c = 1.5 \\implies \\sigma_c^2 = 2.25$\n-   边缘融合：$\\mu_f = 3.5$, $\\sigma_f = 0.7 \\implies \\sigma_f^2 = 0.49$\n-   数字孪生预测：$\\mu_p = 8.0$, $\\sigma_p = 2.0 \\implies \\sigma_p^2 = 4.00$\n-   驱动：$\\mu_a = 1.5$, $\\sigma_a = 0.3 \\implies \\sigma_a^2 = 0.09$\n\n我们计算总均值和方差：\n$$\\mu_L = 2.0 + 5.0 + 3.5 + 8.0 + 1.5 = 20.0 \\, \\text{ms}$$\n$$\\sigma_L^2 = 0.16 + 2.25 + 0.49 + 4.00 + 0.09 = 6.99 \\, \\text{ms}^2$$\n总标准差为 $\\sigma_L = \\sqrt{6.99} \\, \\text{ms}$。\n\n问题指导我们使用“适用于随机延迟总和的、经过充分检验的概率原理”。这一点，结合各个阶段的“近似高斯分布概要”，证明了使用中心极限定理 (CLT) 的合理性。CLT 指出，多个具有有限均值和方差的独立随机变量之和趋向于正态分布。因此，我们将总延迟 $L$ 建模为一个正态随机变量，$L \\sim \\mathcal{N}(\\mu_L, \\sigma_L^2)$。\n\n我们需要找到满足 $P(L \\leq D) \\geq 0.999$ 的最小截止时间 $D$。这可以通过求解等式来找到：\n$$P(L \\leq D) = 0.999$$\n为了解决这个问题，我们将随机变量 $L$ 标准化为一个标准正态变量 $Z \\sim \\mathcal{N}(0, 1)$，其中 $Z = \\frac{L - \\mu_L}{\\sigma_L}$。\n$$P\\left(\\frac{L - \\mu_L}{\\sigma_L} \\leq \\frac{D - \\mu_L}{\\sigma_L}\\right) = 0.999$$\n$$P\\left(Z \\leq \\frac{D - \\mu_L}{\\sigma_L}\\right) = 0.999$$\n设 $\\Phi(z)$ 为标准正态分布的累积分布函数 (CDF)。我们在寻找值 $z_{0.999}$，使得 $\\Phi(z_{0.999}) = 0.999$。这个值是标准正态分布的第 $99.9$ 百分位数。\n$$\\frac{D - \\mu_L}{\\sigma_L} = z_{0.999}$$\n求解 $D$：\n$$D = \\mu_L + z_{0.999} \\sigma_L$$\n根据标准统计表或计算工具， $z_{0.999}$ 的值约为 $3.09023$。\n\n现在我们代入数值：\n$$D = 20.0 + (3.09023) \\times \\sqrt{6.99}$$\n计算数值：\n$$\\sqrt{6.99} \\approx 2.6438608$$\n$$D \\approx 20.0 + (3.09023) \\times (2.6438608)$$\n$$D \\approx 20.0 + 8.170246$$\n$$D \\approx 28.170246 \\, \\text{ms}$$\n\n问题要求将 $D$ 的数值答案四舍五入到四位有效数字。\n$$D \\approx 28.17 \\, \\text{ms}$$\n\n这是确保端到端延迟在此界限内的概率至少为 $99.9\\%$ 的最小截止时间。",
            "answer": "$$\\boxed{28.17}$$"
        },
        {
            "introduction": "定义性能保障只是第一步，构建能够主动执行这些保障的系统才是真正的工程挑战。本动手练习将从分析转向实现，要求你创建一个准入控制算法来执行服务水平协议（SLA） 。通过将用于流量调节的令牌桶机制与截止时间检查相结合，你将开发一个实用的工具，用于管理负载并维护关键服务的实时性能。",
            "id": "4245779",
            "problem": "考虑一个基于面向服务的架构 (SOA) 构建的信息物理系统 (CPS)，其中单个关键微服务处理由数字孪生发出的控制回路请求。您必须形式化服务水平协议 (SLA) 条款以约束时间保证，并实现一个具体的执行机制，该机制通过节流或卸载负载来保证控制截止时间。\n\n从排队论和实时系统中的以下基础概念开始。对于一个具有确定性服务时间的单服务器、先进先出 (FIFO) 系统，一个被接纳的请求的响应时间等于其等待时间和服务时间之和。利特尔法则将系统中的平均请求数与吞吐量和系统中的平均逗留时间关联起来。接纳控制必须通过限制每个请求的等待时间和服务时间来确保稳定性并遵守截止时间。漏桶或令牌桶速率限制器通过一个持续速率和一个有限的突发量来约束被接纳的到达过程。\n\n您的任务是编码以下 SLA 条款，并用一个算法来执行它们：\n\n1. 硬截止时间条款：对于每个被接纳的、索引为 $j$ 的请求，其到达时间为 $t_j$，确定性服务时间为 $s$，每个请求的硬截止时间为 $D$，其响应时间 $R_j$ 必须满足 $R_j \\le D$。等价地，在接纳时预测的完成时间，计算为 $\\max(t_j, T_{\\text{free}}) + s$（其中 $T_{\\text{free}}$ 是服务器变为空闲的当前时间），必须满足 $\\max(t_j, T_{\\text{free}}) + s \\le t_j + D$。\n\n2. 通过令牌桶的节流条款：被接纳的到达过程受一个令牌桶的约束，其参数为桶容量 $B$（个令牌）和令牌生成速率 $\\rho$（个令牌/秒）。令牌以速率 $\\rho$ 持续累积，直至达到容量 $B$。每个被接纳的请求消耗一个令牌。当可用令牌少于一个时到达的请求必须立即被拒绝，以满足节流条款。假定在 $t=0$ 时，初始令牌数为 $B$。\n\n3. 结合两种条款的接纳规则：在每个请求于时间 $t$ 到达时，通过加上 $\\rho (t - t_{\\text{last}})$ 来更新令牌数，并以 $B$ 为上限，其中 $t_{\\text{last}}$ 是上次令牌更新的时间。如果至少有一个可用令牌，则计算预测的完成时间 $T_{\\text{finish}} = \\max(t, T_{\\text{free}}) + s$。当且仅当 $T_{\\text{finish}} \\le t + D$ 时接纳该请求，然后消耗一个令牌并更新 $T_{\\text{free}} \\leftarrow T_{\\text{finish}}$。如果没有可用令牌或 $T_{\\text{finish}}  t + D$，则拒绝该请求。调度策略是单服务器的 FIFO。\n\n所有时间量必须以秒为单位表示。没有角度。每个测试用例所关注的结果是由所述执行机制产生的被接纳的请求数（一个整数）。\n\n实现一个完整的、可运行的程序，该程序无需输入，使用上述确切算法模拟以下四个测试用例，并输出单行，其中包含一个用方括号括起来的逗号分隔列表，内容为与测试用例顺序相同的被接纳请求计数，即 $[n_1,n_2,n_3,n_4]$。\n\n使用以下测试套件。每个用例定义了 $(\\rho, B, s, D, \\text{arrivals})$，其中 arrivals 是以秒为单位的到达时间列表。\n\n测试用例 $1$（理想路径，持续速率低于服务能力且截止时间宽松）：\n- $\\rho = 40$ 令牌/秒。\n- $B = 8$ 令牌。\n- $s = 0.02$ 秒。\n- $D = 0.10$ 秒。\n- 到达：$30$ 次到达，时间为 $[\\,0.00, 0.025, 0.050, 0.075, 0.100, 0.125, 0.150, 0.175, 0.200, 0.225, 0.250, 0.275, 0.300, 0.325, 0.350, 0.375, 0.400, 0.425, 0.450, 0.475, 0.500, 0.525, 0.550, 0.575, 0.600, 0.625, 0.650, 0.675, 0.700, 0.725\\,]$ 秒。\n\n测试用例 $2$（边界条件，到达速率接近容量，截止时间更紧）：\n- $\\rho = 50$ 令牌/秒。\n- $B = 5$ 令牌。\n- $s = 0.02$ 秒。\n- $D = 0.05$ 秒。\n- 到达：$60$ 次到达，时间为 $[\\,0.000, 0.016667, 0.033333, 0.050000, 0.066667, 0.083333, 0.100000, 0.116667, 0.133333, 0.150000, 0.166667, 0.183333, 0.200000, 0.216667, 0.233333, 0.250000, 0.266667, 0.283333, 0.300000, 0.316667, 0.333333, 0.350000, 0.366667, 0.383333, 0.400000, 0.416667, 0.433333, 0.450000, 0.466667, 0.483333, 0.500000, 0.516667, 0.533333, 0.550000, 0.566667, 0.583333, 0.600000, 0.616667, 0.633333, 0.650000, 0.666667, 0.683333, 0.700000, 0.716667, 0.733333, 0.750000, 0.766667, 0.783333, 0.800000, 0.816667, 0.833333, 0.850000, 0.866667, 0.883333, 0.900000, 0.916667, 0.933333, 0.950000, 0.966667, 0.983333\\,]$ 秒。\n\n测试用例 $3$（突发负载，节流容量至关重要，截止时间适中）：\n- $\\rho = 30$ 令牌/秒。\n- $B = 10$ 令牌。\n- $s = 0.025$ 秒。\n- $D = 0.08$ 秒。\n- 到达：$40$ 次到达，包含两次突发，第一次突发在 $[\\,0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19\\,]$ 秒，第二次突发在 $[\\,0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69\\,]$ 秒。\n\n测试用例 $4$（严重过载和紧迫的截止时间，卸载占主导地位）：\n- $\\rho = 60$ 令牌/秒。\n- $B = 5$ 令牌。\n- $s = 0.015$ 秒。\n- $D = 0.03$ 秒。\n- 到达：$100$ 次到达，时间为 $[\\,0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.20, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.30, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69, 0.70, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.80, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99\\,]$ 秒。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[n_1,n_2,n_3,n_4]$，其中 $n_k$ 是您的执行机制为测试用例 $k$ 计算出的被接纳请求的整数计数。不允许有其他输出。",
            "solution": "该问题要求为单服务器排队系统设计并实现一个接纳控制算法，该系统代表了信息物理系统中的一个关键微服务。其目标是执行与硬截止时间和请求节流相关的服务水平协议 (SLA) 条款。该系统被建模为一个具有确定性服务时间的单服务器、先进先出 (FIFO) 队列。\n\n在任何给定时间，系统的状态可由三个变量描述：\n1.  $T_{\\text{free}}$: 单个服务器将可用于处理下一个请求的时间。初始时，在时间 $t=0$，服务器是空闲的，因此 $T_{\\text{free}} = 0$。\n2.  $N_{\\text{tokens}}$: 令牌桶中可用令牌的数量。该桶的容量为 $B$，并以每秒 $\\rho$ 个令牌的速率重新填充。初始时，在时间 $t=0$，桶是满的，因此 $N_{\\text{tokens}} = B$。\n3.  $t_{\\text{last}}$: 用于计算令牌补充的最后一个事件（即最后一个请求到达）的时间。初始时，$t_{\\text{last}} = 0$。\n\n接纳控制机制在每个请求到达时被触发。假设一个请求在时间 $t$ 到达。该算法按规定顺序执行一系列检查。\n\n首先，我们更新可用令牌的数量。自上次更新以来经过的时间是 $\\Delta t = t - t_{\\text{last}}$。在此期间，生成了 $\\rho \\cdot \\Delta t$ 个新令牌。令牌数量被更新并以桶容量 $B$ 为上限：\n$$N_{\\text{tokens}} \\leftarrow \\min(B, N_{\\text{tokens}} + \\rho \\cdot (t - t_{\\text{last}}))$$\n更新后，我们设置 $t_{\\text{last}} \\leftarrow t$，将当前到达时间标记为下次更新的新参考点。\n\n第一个接纳控制过滤器是节流条款。只有在至少有一个令牌可供消耗时，请求才能被考虑接纳。\n$$N_{\\text{tokens}} \\ge 1$$\n如果不满足此条件，则该请求被拒绝（卸载），并且不再对此请求执行进一步检查。\n\n如果有足够的令牌，则评估第二个过滤器，即硬截止时间条款。对于 FIFO 系统，一个在时间 $t$ 到达的新请求，其服务开始时间不能早于其到达时间 $t$，也不能早于服务器变为空闲的时间 $T_{\\text{free}}$。因此，该请求的服务开始时间 $T_{\\text{start}}$ 将是：\n$$T_{\\text{start}} = \\max(t, T_{\\text{free}})$$\n给定一个确定性的服务时间 $s$，该请求将在时间 $T_{\\text{finish}}$ 完成其执行：\n$$T_{\\text{finish}} = T_{\\text{start}} + s = \\max(t, T_{\\text{free}}) + s$$\n硬截止时间条款规定，任何被接纳请求的响应时间不得超过时长 $D$。响应时间是从到达至完成的总时长，即 $T_{\\text{finish}} - t$。因此，接纳条件是：\n$$T_{\\text{finish}} - t \\le D \\quad \\iff \\quad T_{\\text{finish}} \\le t + D$$\n代入 $T_{\\text{finish}}$ 的表达式，该检查变为：\n$$\\max(t, T_{\\text{free}}) + s \\le t + D$$\n如果此不等式成立，则该请求可以满足其截止时间。如果不成立，则拒绝该请求以防止未来的 SLA 违规。\n\n一个请求当且仅当它同时通过令牌可用性检查和截止时间检查时才被接纳。在接纳后，系统状态更新如下：\n1.  消耗一个令牌：$N_{\\text{tokens}} \\leftarrow N_{\\text{tokens}} - 1$。\n2.  服务器现在被占用以服务此请求，因此其下一次空闲时间被更新为此请求的完成时间：$T_{\\text{free}} \\leftarrow T_{\\text{finish}}$。\n\n通过遍历按时间排序的请求到达序列并对每个请求应用此逻辑，我们可以模拟系统的行为并确定被接纳的请求总数。将使用指定的参数 $(\\rho, B, s, D)$ 和到达时间序列，对所提供的四个测试用例中的每一个进行模拟。最终输出是每个用例中被接纳请求的整数计数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_admission_control(rho, B, s, D, arrivals):\n    \"\"\"\n    Simulates the admission control logic for a sequence of requests.\n\n    Args:\n        rho (float): Token generation rate (tokens/sec).\n        B (int): Token bucket capacity.\n        s (float): Deterministic service time (sec).\n        D (float): Hard deadline (sec).\n        arrivals (list[float]): A list of request arrival times.\n\n    Returns:\n        int: The total number of admitted requests.\n    \"\"\"\n    \n    # State variables initialization\n    # T_free: The time when the server becomes free.\n    # tokens: The current number of tokens in the bucket.\n    # t_last: The time of the last token update.\n    # admitted_count: The counter for admitted requests.\n    T_free = 0.0\n    tokens = float(B)\n    t_last = 0.0\n    admitted_count = 0\n    \n    # Process each request arrival in sequence.\n    # The arrivals list is assumed to be sorted by time.\n    for t_arrival in arrivals:\n        # Step 1: Update token count based on elapsed time.\n        # Tokens accrue continuously. The number of new tokens is rho * delta_t.\n        # The total is capped at the bucket capacity B.\n        time_elapsed = t_arrival - t_last\n        tokens = min(float(B), tokens + rho * time_elapsed)\n        t_last = t_arrival\n        \n        # Step 2: Check for token availability (Throttle Clause).\n        # A request requires one full token to be considered.\n        if tokens  1.0:\n            # Reject the request due to insufficient tokens.\n            continue\n            \n        # Step 3: Check deadline (Hard Deadline Clause).\n        # Calculate the predicted start and finish times.\n        # A request starts at max(arrival_time, server_free_time).\n        t_start = max(t_arrival, T_free)\n        t_finish = t_start + s\n        \n        # The request is rejected if its finish time exceeds the deadline.\n        # The deadline expires at arrival_time + D.\n        if t_finish > t_arrival + D:\n            # Reject the request due to a predicted deadline miss.\n            continue\n            \n        # Step 4: Admit the request.\n        # The request passed both admission control checks.\n        admitted_count += 1\n        \n        # Update state variables upon admission.\n        # Consume one token.\n        tokens -= 1.0\n        # The server will be busy until the request is finished.\n        T_free = t_finish\n        \n    return admitted_count\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the simulation for each, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case: (rho, B, s, D, arrivals)\n    test_cases = [\n        (\n            40.0, 8, 0.02, 0.10,\n            np.arange(0.00, 0.725 + 1e-9, 0.025).tolist()\n        ),\n        (\n            50.0, 5, 0.02, 0.05,\n            [k * (1.0/60.0) for k in range(60)]\n        ),\n        (\n            30.0, 10, 0.025, 0.08,\n            np.concatenate([\n                np.arange(0.00, 0.19 + 1e-9, 0.01),\n                np.arange(0.50, 0.69 + 1e-9, 0.01)\n            ]).tolist()\n        ),\n        (\n            60.0, 5, 0.015, 0.03,\n            np.arange(0.00, 0.99 + 1e-9, 0.01).tolist()\n        )\n    ]\n\n    results = []\n    for params in test_cases:\n        rho, B, s, D, arrivals = params\n        admitted_count = simulate_admission_control(rho, B, s, D, arrivals)\n        results.append(admitted_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}