{
    "hands_on_practices": [
        {
            "introduction": "In many cyber-physical systems, ensuring that tasks complete within strict time constraints is not just a performance goalâ€”it is a critical safety requirement. This practice provides a foundational tool for verifying such hard real-time guarantees in a service-oriented context. By applying classical Response Time Analysis (RTA), you will calculate the worst-case response time for a service running alongside other competing services, allowing you to deterministically assess whether it can meet its deadline .",
            "id": "4245887",
            "problem": "A cyber-physical system (CPS) for a robotic production cell is implemented using a Service-Oriented Architecture (SOA) on an edge controller. The edge controller executes service tasks on a single processor using Fixed-Priority Preemptive Scheduling (FPPS) with rate-monotonic priority assignment: services with shorter period have higher priority. All services are strictly periodic, independent (no shared resources or self-suspensions), and have no release jitter. Communication and middleware overheads are already included in the worst-case execution times (WCETs). Consider the following services, all mapped to the same processor:\n\n- Sensor preprocessing service: period $T_{1} = 5\\,\\mathrm{ms}$, worst-case execution time $C_{1} = 1\\,\\mathrm{ms}$.\n- Telemetry encoding service: period $T_{2} = 10\\,\\mathrm{ms}$, worst-case execution time $C_{2} = 1.5\\,\\mathrm{ms}$.\n- Actuator watchdog service: period $T_{3} = 20\\,\\mathrm{ms}$, worst-case execution time $C_{3} = 2\\,\\mathrm{ms}$.\n- Digital twin state reconciliation service (the task of interest): period $T_{4} = 40\\,\\mathrm{ms}$, worst-case execution time $C_{4} = 4\\,\\mathrm{ms}$, and relative deadline $D_{4} = 12\\,\\mathrm{ms}$.\n\nYou are to compute the worst-case response time $R_{4}$ of the digital twin state reconciliation service under synchronous release of all higher-priority services, using the foundational busy-window argument for fixed-priority systems and the definition of response time as own execution plus interference from all higher-priority services. Determine whether the service is schedulable with respect to its relative deadline $D_{4}$.\n\nReport your final answer as a two-component vector $(R_{4}, s)$, where $R_{4}$ is the worst-case response time and $s$ is an indicator defined by $s = 1$ if $R_{4} \\leq D_{4}$ and $s = 0$ otherwise. Express $R_{4}$ in milliseconds. Provide the exact value of $R_{4}$ (no rounding).",
            "solution": "The problem requires calculating the worst-case response time, $R_4$, for the fourth service (task $\\tau_4$) and determining its schedulability under Fixed-Priority Preemptive Scheduling (FPPS) with a rate-monotonic priority assignment.\n\nFirst, we establish the priority of each service. Under rate-monotonic scheduling, a shorter period corresponds to a higher priority.\nThe periods are $T_1 = 5\\,\\mathrm{ms}$, $T_2 = 10\\,\\mathrm{ms}$, $T_3 = 20\\,\\mathrm{ms}$, and $T_4 = 40\\,\\mathrm{ms}$.\nSince $T_1 < T_2 < T_3 < T_4$, the priorities are assigned from highest (1) to lowest (4): $\\tau_1, \\tau_2, \\tau_3, \\tau_4$.\n\nThe worst-case response time $R_i$ for a task $\\tau_i$ is found by solving the following equation iteratively, starting with an initial guess (e.g., $C_i$):\n$$R_i = C_i + \\sum_{j \\in hp(i)} \\left\\lceil \\frac{R_i}{T_j} \\right\\rceil C_j$$\nwhere $hp(i)$ is the set of tasks with higher priority than $\\tau_i$.\n\nFor task $\\tau_4$, the set of higher-priority tasks is $hp(4) = \\{\\tau_1, \\tau_2, \\tau_3\\}$. The equation for its response time $R_4$ is:\n$$R_4 = C_4 + \\left\\lceil \\frac{R_4}{T_1} \\right\\rceil C_1 + \\left\\lceil \\frac{R_4}{T_2} \\right\\rceil C_2 + \\left\\lceil \\frac{R_4}{T_3} \\right\\rceil C_3$$\nWe solve this iteratively, letting $w$ be the current estimate for the response time. The given parameters are $C_1 = 1$, $T_1 = 5$; $C_2 = 1.5$, $T_2 = 10$; $C_3 = 2$, $T_3 = 20$; and $C_4 = 4$.\n\nThe iterative formula is:\n$$w^{(n+1)} = 4 + \\left\\lceil \\frac{w^{(n)}}{5} \\right\\rceil(1) + \\left\\lceil \\frac{w^{(n)}}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{w^{(n)}}{20} \\right\\rceil(2)$$\n\nLet's start the iteration:\n- **Step 0:** Initialize with $w^{(0)} = C_4 = 4$.\n- **Step 1:** Calculate $w^{(1)}$ using $w^{(0)} = 4$.\n  $$w^{(1)} = 4 + \\left\\lceil \\frac{4}{5} \\right\\rceil(1) + \\left\\lceil \\frac{4}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{4}{20} \\right\\rceil(2) = 4 + 1(1) + 1(1.5) + 1(2) = 8.5$$\n- **Step 2:** Calculate $w^{(2)}$ using $w^{(1)} = 8.5$.\n  $$w^{(2)} = 4 + \\left\\lceil \\frac{8.5}{5} \\right\\rceil(1) + \\left\\lceil \\frac{8.5}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{8.5}{20} \\right\\rceil(2) = 4 + 2(1) + 1(1.5) + 1(2) = 9.5$$\n- **Step 3:** Calculate $w^{(3)}$ using $w^{(2)} = 9.5$.\n  $$w^{(3)} = 4 + \\left\\lceil \\frac{9.5}{5} \\right\\rceil(1) + \\left\\lceil \\frac{9.5}{10} \\right\\rceil(1.5) + \\left\\lceil \\frac{9.5}{20} \\right\\rceil(2) = 4 + 2(1) + 1(1.5) + 1(2) = 9.5$$\n\nSince $w^{(3)} = w^{(2)} = 9.5$, the iteration has converged. The worst-case response time is $R_4 = 9.5\\,\\mathrm{ms}$.\n\nNext, we check for schedulability by comparing $R_4$ to the deadline $D_4 = 12\\,\\mathrm{ms}$.\nThe condition is $R_4 \\le D_4$. Since $9.5 \\le 12$, the condition is met, and the service is schedulable. The indicator variable is $s=1$.\n\nThe final answer is the vector $(R_4, s)$, which is $(9.5, 1)$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 9.5 & 1 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Beyond timing, the overall reliability of a CPS function depends on how its constituent services are architecturally composed. This exercise delves into the principles of reliability engineering, asking you to model and quantify the end-to-end success probability of a mission composed of multiple microservices. You will derive and compare the reliability of series and parallel compositions, gaining quantitative insight into the trade-offs between simple pipelines and fault-tolerant, redundant designs .",
            "id": "4245895",
            "problem": "A Cyber-Physical System (CPS) adopts a Service-Oriented Architecture (SOA) to orchestrate stateless microservices that provide sensing and actuation capabilities. A Digital Twin (DT) monitors service reliability and uses these estimates to reason about end-to-end mission assurance. Reliability is defined as the probability that a service completes its task without failure during the time it is engaged. Formally, for service $i$, let $T_i$ be the failure time, modeled by an exponential distribution with constant hazard (failure rate) $\\lambda_i$, and let $\\tau_i$ be the deterministic engagement time of service $i$ per invocation. The single-service reliability is the survival function $R_i(\\tau_i) = \\mathbb{P}\\{T_i > \\tau_i\\}$.\n\nConsider two orchestration patterns for an end-to-end operation:\n\n- Series composition: the pipeline invokes three independent services $S_1 \\rightarrow S_2 \\rightarrow S_3$ sequentially, and success occurs only if all three complete without failure during their respective engagement times.\n- Parallel composition: three independent, functionally equivalent services $S_1$, $S_2$, and $S_3$ are invoked concurrently as redundancy, and the operation is deemed successful if at least one service returns a correct result without failing during its engagement time.\n\nAssume the independence of service failure processes and constant hazards. Using the fundamental laws of probability (Kolmogorov axioms) and the exponential survival model, derive the combined reliability expressions for the series and parallel orchestrations in terms of $\\lambda_i$ and $\\tau_i$. Then, evaluate both expressions for the following scientifically plausible parameters monitored by the Digital Twin:\n- $\\lambda_1 = 2.0\\ \\text{s}^{-1}$, $\\tau_1 = 0.5\\ \\text{s}$,\n- $\\lambda_2 = 3.0\\ \\text{s}^{-1}$, $\\tau_2 = 0.3\\ \\text{s}$,\n- $\\lambda_3 = 5.0\\ \\text{s}^{-1}$, $\\tau_3 = 0.2\\ \\text{s}$.\n\nRound your final numerical results to four significant figures. Express all probabilities as decimals (no percentage signs). The final answer must report the two reliabilities, for series and parallel, respectively, as a single row matrix.",
            "solution": "First, we formalize the reliability of a single service $i$. The failure time $T_i$ is exponentially distributed with rate $\\lambda_i$. The reliability $R_i(\\tau_i)$ is the survival probability over a deterministic engagement time $\\tau_i$, given by the survival function:\n$$R_i(\\tau_i) = \\mathbb{P}\\{T_i > \\tau_i\\} = \\exp(-\\lambda_i \\tau_i)$$\nLet $R_i$ denote $R_i(\\tau_i)$ for simplicity.\n\n**1. Series Composition Reliability ($R_{\\text{series}}$)**\nIn a series composition, the system succeeds only if all independent services succeed. The probability of success is the product of their individual reliabilities:\n$$R_{\\text{series}} = R_1 R_2 R_3 = \\exp(-\\lambda_1 \\tau_1) \\exp(-\\lambda_2 \\tau_2) \\exp(-\\lambda_3 \\tau_3) = \\exp\\left(-\\sum_{i=1}^{3} \\lambda_i \\tau_i\\right)$$\n\n**2. Parallel Composition Reliability ($R_{\\text{parallel}}$)**\nIn a parallel composition, the system succeeds if at least one service succeeds. It is simpler to calculate the probability of the complementary event: total system failure, which occurs if all independent services fail. The probability of failure (unreliability) of service $i$ is $Q_i = 1 - R_i$. The probability of total system failure is $Q_{\\text{parallel}} = Q_1 Q_2 Q_3$. The reliability is therefore:\n$$R_{\\text{parallel}} = 1 - Q_{\\text{parallel}} = 1 - (1 - R_1)(1 - R_2)(1 - R_3) = 1 - \\prod_{i=1}^{3} (1 - \\exp(-\\lambda_i \\tau_i))$$\n\n**Numerical Evaluation**\nWe evaluate these expressions using the provided parameters. First, calculate the dimensionless products $\\lambda_i \\tau_i$:\n- $\\lambda_1 \\tau_1 = (2.0\\ \\text{s}^{-1}) \\times (0.5\\ \\text{s}) = 1.0$\n- $\\lambda_2 \\tau_2 = (3.0\\ \\text{s}^{-1}) \\times (0.3\\ \\text{s}) = 0.9$\n- $\\lambda_3 \\tau_3 = (5.0\\ \\text{s}^{-1}) \\times (0.2\\ \\text{s}) = 1.0$\n\n**For the series composition:**\n$$R_{\\text{series}} = \\exp(-(1.0 + 0.9 + 1.0)) = \\exp(-2.9) \\approx 0.05502322...$$\nRounding to four significant figures, $R_{\\text{series}} \\approx 0.05502$.\n\n**For the parallel composition:**\n$$R_{\\text{parallel}} = 1 - \\left( (1 - \\exp(-1.0)) (1 - \\exp(-0.9)) (1 - \\exp(-1.0)) \\right)$$\nUsing intermediate values:\n- $1 - \\exp(-1.0) \\approx 0.63212056$\n- $1 - \\exp(-0.9) \\approx 0.59343034$\n$$R_{\\text{parallel}} = 1 - (0.63212056)^2 \\times 0.59343034 \\approx 1 - 0.23710839 = 0.76289161...$$\nRounding to four significant figures, $R_{\\text{parallel}} \\approx 0.7629$.\n\nThe final results for the series and parallel reliabilities are $0.05502$ and $0.7629$, respectively.",
            "answer": "$$\\boxed{\\begin{pmatrix}0.05502 & 0.7629\\end{pmatrix}}$$"
        },
        {
            "introduction": "While design-time analysis is crucial, real-world systems must dynamically adapt to fluctuating workloads to uphold their performance promises. This final practice moves from static analysis to runtime enforcement by asking you to implement a concrete admission control algorithm that enforces a Service-Level Agreement (SLA). You will translate formal SLA clauses for throttling and deadlines into a functional simulation, learning how to actively manage load to protect a critical service and guarantee its stability and responsiveness .",
            "id": "4245779",
            "problem": "Consider a Cyber-Physical System (CPS) built with a Service-Oriented Architecture (SOA), where a single critical microservice handles control-loop requests issued by a Digital Twin. You must formalize Service Level Agreement (SLA) clauses that constrain timing guarantees and implement a concrete enforcement mechanism that throttles or sheds load to preserve control deadlines.\n\nStart from the following foundational base in queueing and real-time systems. For a single-server, First-In, First-Out (FIFO) system with deterministic service time, the response time of an admitted request equals the sum of its waiting time and its service time. Little's Law relates average number-in-system to throughput and average time-in-system. Admission control must ensure stability and respect deadlines by bounding per-request waiting and service times. A leaky-bucket or token-bucket rate limiter constrains the admitted arrival process by a sustained rate and a finite burst.\n\nYour task is to encode the following SLA clauses and enforce them with an algorithm:\n\n1. Hard deadline clause: For every admitted request indexed by $j$ with arrival time $t_j$, deterministic service time $s$, and per-request hard deadline $D$, the response time $R_j$ must satisfy $R_j \\le D$. Equivalently, the predicted completion time at admission, computed as $\\max(t_j, T_{\\text{free}}) + s$, where $T_{\\text{free}}$ is the current time when the server becomes free, must satisfy $\\max(t_j, T_{\\text{free}}) + s \\le t_j + D$.\n\n2. Throttle clause via token bucket: The admitted arrival process is constrained by a token bucket with parameters bucket capacity $B$ (tokens) and token generation rate $\\rho$ (tokens per second). Tokens accumulate continuously at rate $\\rho$ up to capacity $B$. Each admitted request consumes one token. Requests arriving when fewer than one token is available must be rejected immediately to satisfy the throttle clause. The initial token count is assumed to be $B$ at $t = 0$.\n\n3. Admission rule combining both clauses: Upon each request arrival at time $t$, update the token count by adding $\\rho (t - t_{\\text{last}})$ and capping by $B$, where $t_{\\text{last}}$ is the last token update time. If at least one token is available, compute the predicted finish time $T_{\\text{finish}} = \\max(t, T_{\\text{free}}) + s$. Admit the request if and only if $T_{\\text{finish}} \\le t + D$, then consume one token and update $T_{\\text{free}} \\leftarrow T_{\\text{finish}}$. If no token is available or if $T_{\\text{finish}} > t + D$, reject the request. The scheduling discipline is FIFO with a single server.\n\nAll time quantities must be expressed in seconds. There are no angles. The outcome of interest per test case is the number of admitted requests (an integer), produced by the described enforcement.\n\nImplement a complete, runnable program that, with no input, simulates the four test cases below using the exact algorithm above and outputs a single line containing a comma-separated list enclosed in square brackets of the admitted counts in the same order as the test cases, i.e., $[n_1,n_2,n_3,n_4]$.\n\nUse the following test suite. Each case defines $(\\rho, B, s, D, \\text{arrivals})$, where arrivals is the list of arrival times in seconds.\n\nTest Case $1$ (happy path, sustained rate below service capacity and deadlines loose):\n- $\\rho = 40$ tokens per second.\n- $B = 8$ tokens.\n- $s = 0.02$ seconds.\n- $D = 0.10$ seconds.\n- Arrivals: $30$ arrivals at times $[\\,0.00, 0.025, 0.050, 0.075, 0.100, 0.125, 0.150, 0.175, 0.200, 0.225, 0.250, 0.275, 0.300, 0.325, 0.350, 0.375, 0.400, 0.425, 0.450, 0.475, 0.500, 0.525, 0.550, 0.575, 0.600, 0.625, 0.650, 0.675, 0.700, 0.725\\,]$ seconds.\n\nTest Case $2$ (boundary condition, arrival near capacity, tighter deadlines):\n- $\\rho = 50$ tokens per second.\n- $B = 5$ tokens.\n- $s = 0.02$ seconds.\n- $D = 0.05$ seconds.\n- Arrivals: $60$ arrivals at times $[\\,0.000, 0.016667, 0.033333, 0.050000, 0.066667, 0.083333, 0.100000, 0.116667, 0.133333, 0.150000, 0.166667, 0.183333, 0.200000, 0.216667, 0.233333, 0.250000, 0.266667, 0.283333, 0.300000, 0.316667, 0.333333, 0.350000, 0.366667, 0.383333, 0.400000, 0.416667, 0.433333, 0.450000, 0.466667, 0.483333, 0.500000, 0.516667, 0.533333, 0.550000, 0.566667, 0.583333, 0.600000, 0.616667, 0.633333, 0.650000, 0.666667, 0.683333, 0.700000, 0.716667, 0.733333, 0.750000, 0.766667, 0.783333, 0.800000, 0.816667, 0.833333, 0.850000, 0.866667, 0.883333, 0.900000, 0.916667, 0.933333, 0.950000, 0.966667, 0.983333\\,]$ seconds.\n\nTest Case $3$ (burst load, throttle capacity critical, deadlines moderate):\n- $\\rho = 30$ tokens per second.\n- $B = 10$ tokens.\n- $s = 0.025$ seconds.\n- $D = 0.08$ seconds.\n- Arrivals: $40$ arrivals comprising two bursts, first burst at $[\\,0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19\\,]$ seconds and second burst at $[\\,0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69\\,]$ seconds.\n\nTest Case $4$ (severe overload and tight deadlines, shedding dominates):\n- $\\rho = 60$ tokens per second.\n- $B = 5$ tokens.\n- $s = 0.015$ seconds.\n- $D = 0.03$ seconds.\n- Arrivals: $100$ arrivals at times $[\\,0.00, 0.01, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.19, 0.20, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.30, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41, 0.42, 0.43, 0.44, 0.45, 0.46, 0.47, 0.48, 0.49, 0.50, 0.51, 0.52, 0.53, 0.54, 0.55, 0.56, 0.57, 0.58, 0.59, 0.60, 0.61, 0.62, 0.63, 0.64, 0.65, 0.66, 0.67, 0.68, 0.69, 0.70, 0.71, 0.72, 0.73, 0.74, 0.75, 0.76, 0.77, 0.78, 0.79, 0.80, 0.81, 0.82, 0.83, 0.84, 0.85, 0.86, 0.87, 0.88, 0.89, 0.90, 0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99\\,]$ seconds.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[n_1,n_2,n_3,n_4]$, where $n_k$ is the integer count of admitted requests for Test Case $k$ computed by your enforcement mechanism. No other output is permitted.",
            "solution": "The problem requires the design and implementation of an admission control algorithm for a single-server queueing system, representing a critical microservice in a Cyber-Physical System. The objective is to enforce Service Level Agreement (SLA) clauses related to hard deadlines and request throttling. The system is modeled as a single-server, First-In, First-Out (FIFO) queue with deterministic service time.\n\nThe state of the system at any given time can be described by three variables:\n1.  $T_{\\text{free}}$: The time at which the single server will become available to process the next request. Initially, at time $t=0$, the server is idle, so $T_{\\text{free}} = 0$.\n2.  $N_{\\text{tokens}}$: The number of available tokens in a token bucket. The bucket has a capacity of $B$ and is refilled at a rate of $\\rho$ tokens per second. Initially, at time $t=0$, the bucket is full, so $N_{\\text{tokens}} = B$.\n3.  $t_{\\text{last}}$: The time of the last event (i.e., the last request arrival) used to calculate token replenishment. Initially, $t_{\\text{last}} = 0$.\n\nThe admission control mechanism is triggered upon the arrival of each request. Let a request arrive at time $t$. The algorithm proceeds in a sequence of checks as specified.\n\nFirst, we update the number of available tokens. The time elapsed since the last update is $\\Delta t = t - t_{\\text{last}}$. During this interval, $\\rho \\cdot \\Delta t$ new tokens have been generated. The number of tokens is updated and capped by the bucket capacity $B$:\n$$N_{\\text{tokens}} \\leftarrow \\min(B, N_{\\text{tokens}} + \\rho \\cdot (t - t_{\\text{last}}))$$\nAfter this update, we set $t_{\\text{last}} \\leftarrow t$ to mark the current arrival time as the new reference for the next update.\n\nThe first admission control filter is the throttle clause. A request can only be considered for admission if at least one token is available to be consumed.\n$$N_{\\text{tokens}} \\ge 1$$\nIf this condition is not met, the request is rejected (shed), and no further checks are performed for this request.\n\nIf sufficient tokens are available, the second filter, the hard deadline clause, is evaluated. For a FIFO system, a new request arriving at time $t$ can begin service no earlier than its arrival time $t$, and no earlier than the time the server becomes free, $T_{\\text{free}}$. Thus, the start time of service for this request, $T_{\\text{start}}$, will be:\n$$T_{\\text{start}} = \\max(t, T_{\\text{free}})$$\nGiven a deterministic service time $s$, the request will complete its execution at time $T_{\\text{finish}}$:\n$$T_{\\text{finish}} = T_{\\text{start}} + s = \\max(t, T_{\\text{free}}) + s$$\nThe hard deadline clause states that the response time for any admitted request must not exceed a duration $D$. The response time is the total duration from arrival to completion, $T_{\\text{finish}} - t$. The admission condition is therefore:\n$$T_{\\text{finish}} - t \\le D \\quad \\iff \\quad T_{\\text{finish}} \\le t + D$$\nSubstituting the expression for $T_{\\text{finish}}$, the check becomes:\n$$\\max(t, T_{\\text{free}}) + s \\le t + D$$\nIf this inequality holds, the request can meet its deadline. If it does not, the request is rejected to prevent a future SLA violation.\n\nA request is admitted if and only if it passes both the token availability check and the deadline check. Upon admission, the system state is updated as follows:\n1.  One token is consumed: $N_{\\text{tokens}} \\leftarrow N_{\\text{tokens}} - 1$.\n2.  The server is now committed to servicing this request, so its next free time is updated to the finish time of this request: $T_{\\text{free}} \\leftarrow T_{\\text{finish}}$.\n\nBy iterating through a time-ordered sequence of request arrivals and applying this logic for each, we can simulate the system's behavior and determine the total number of admitted requests. The simulation will be performed for each of the four test cases provided, using the specified parameters $(\\rho, B, s, D)$ and arrival time sequences. The final output is an integer count of admitted requests for each case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_admission_control(rho, B, s, D, arrivals):\n    \"\"\"\n    Simulates the admission control logic for a sequence of requests.\n\n    Args:\n        rho (float): Token generation rate (tokens/sec).\n        B (int): Token bucket capacity.\n        s (float): Deterministic service time (sec).\n        D (float): Hard deadline (sec).\n        arrivals (list[float]): A list of request arrival times.\n\n    Returns:\n        int: The total number of admitted requests.\n    \"\"\"\n    \n    # State variables initialization\n    # T_free: The time when the server becomes free.\n    # tokens: The current number of tokens in the bucket.\n    # t_last: The time of the last token update.\n    # admitted_count: The counter for admitted requests.\n    T_free = 0.0\n    tokens = float(B)\n    t_last = 0.0\n    admitted_count = 0\n    \n    # Process each request arrival in sequence.\n    # The arrivals list is assumed to be sorted by time.\n    for t_arrival in arrivals:\n        # Step 1: Update token count based on elapsed time.\n        # Tokens accrue continuously. The number of new tokens is rho * delta_t.\n        # The total is capped at the bucket capacity B.\n        time_elapsed = t_arrival - t_last\n        tokens = min(float(B), tokens + rho * time_elapsed)\n        t_last = t_arrival\n        \n        # Step 2: Check for token availability (Throttle Clause).\n        # A request requires one full token to be considered.\n        if tokens < 1.0:\n            # Reject the request due to insufficient tokens.\n            continue\n            \n        # Step 3: Check deadline (Hard Deadline Clause).\n        # Calculate the predicted start and finish times.\n        # A request starts at max(arrival_time, server_free_time).\n        t_start = max(t_arrival, T_free)\n        t_finish = t_start + s\n        \n        # The request is rejected if its finish time exceeds the deadline.\n        # The deadline expires at arrival_time + D.\n        if t_finish > t_arrival + D:\n            # Reject the request due to a predicted deadline miss.\n            continue\n            \n        # Step 4: Admit the request.\n        # The request passed both admission control checks.\n        admitted_count += 1\n        \n        # Update state variables upon admission.\n        # Consume one token.\n        tokens -= 1.0\n        # The server will be busy until the request is finished.\n        T_free = t_finish\n        \n    return admitted_count\n\ndef solve():\n    \"\"\"\n    Defines the test cases, runs the simulation for each, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case: (rho, B, s, D, arrivals)\n    test_cases = [\n        (\n            40.0, 8, 0.02, 0.10,\n            np.arange(0.00, 0.725 + 1e-9, 0.025).tolist()\n        ),\n        (\n            50.0, 5, 0.02, 0.05,\n            [k * (1.0/60.0) for k in range(60)]\n        ),\n        (\n            30.0, 10, 0.025, 0.08,\n            np.concatenate([\n                np.arange(0.00, 0.19 + 1e-9, 0.01),\n                np.arange(0.50, 0.69 + 1e-9, 0.01)\n            ]).tolist()\n        ),\n        (\n            60.0, 5, 0.015, 0.03,\n            np.arange(0.00, 0.99 + 1e-9, 0.01).tolist()\n        )\n    ]\n\n    results = []\n    for params in test_cases:\n        rho, B, s, D, arrivals = params\n        admitted_count = simulate_admission_control(rho, B, s, D, arrivals)\n        results.append(admitted_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}