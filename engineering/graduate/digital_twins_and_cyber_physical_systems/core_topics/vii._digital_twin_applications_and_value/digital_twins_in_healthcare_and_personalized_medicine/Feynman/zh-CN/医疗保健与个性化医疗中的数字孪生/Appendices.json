{
    "hands_on_practices": [
        {
            "introduction": "构建医疗健康数字孪体的第一步，通常是利用患者的特异性数据来对一个通用生理或药理模型进行“个性化”。本练习将通过一个实际案例，指导您如何使用治疗药物监测（TDM）数据来校准一个药代动力学（PK）模型，从而估算特定患者的关键参数。这是构建个性化医疗工具的一项核心技能，能帮助您将理论模型与临床观测数据紧密结合起来。",
            "id": "4217319",
            "problem": "使用通过治疗药物监测（TDM）测量值校准的单室药代动力学（PK）模型，构建用于个性化万古霉素治疗的数字孪生。从质量平衡和一级消除出发，考虑体内药物量 $A(t)$ 和浓度 $C(t)$，它们通过 $C(t) = A(t)/V$ 相关联，其中 $V$ 是表观分布容积，单位为升。静脉输注在输注期间被建模为速率为 $R(t)$（单位为 $\\mathrm{mg}/\\mathrm{h}$）的零级输入，在其他时间则无输入。消除过程为一级消除，消除速率常数为 $k_e$，单位为 $\\mathrm{h}^{-1}$。质量平衡得出常微分方程 $dA/dt = -k_e A + R(t)$，因此有 $dC/dt = -k_e C + R(t)/V$。假设在时间 $t_i$ 的 TDM 观测值 $y_i$ 满足 $y_i = C(t_i) + \\epsilon_i$，其中 $\\epsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ 是方差未知的独立高斯噪声。\n\n您的任务是实现一个程序，为每个提供的测试用例执行以下操作：\n\n- 在高斯噪声假设下，通过最大似然估计法估计个性化参数 $k_e$ 和 $V$，这简化为最小化预测浓度 $C(t_i)$ 与观测值 $y_i$ 之间的残差平方和。\n- 使用估计出的参数，计算在给药方案下，时间窗口 $[0,T]$（$T$ 的单位为小时）内的个性化浓度轨迹 $C(t)$。\n- 计算以下输出：\n  1. 估计的消除速率 $k_e$，单位为 $\\mathrm{h}^{-1}$，四舍五入到3位小数。\n  2. 估计的容积 $V$，单位为 $\\mathrm{L}$，四舍五入到3位小数。\n  3. $[0,T]$ 范围内的最大浓度，单位为 $\\mathrm{mg}/\\mathrm{L}$，四舍五入到3位小数。\n  4. $t = T$ 时的浓度，单位为 $\\mathrm{mg}/\\mathrm{L}$，四舍五入到3位小数。\n  5. $[0,T]$ 范围内的浓度-时间曲线下面积，单位为 $\\mathrm{mg}\\cdot\\mathrm{h}/\\mathrm{L}$，四舍五入到3位小数。\n\n仅使用科学上合理的假设。每次给药的输注方案是分段恒定的，具有已知的剂量 $D$（单位为 $\\mathrm{mg}$）和输注持续时间 $\\tau$（单位为 $\\mathrm{h}$）。对于每个测试用例，假设初始药物量 $A(0) = 0$。\n\n将校准实现为非线性最小二乘法，参数具有物理上合理的边界，并能跨分段的输注和消除区间对 $A(t)$ 进行数值稳定的传播。程序必须是自包含的，并能生成下述确切的最终输出格式。\n\n答案单位与四舍五入：\n- $k_e$ 以 $\\mathrm{h}^{-1}$ 表示，$V$ 以 $\\mathrm{L}$ 表示，浓度以 $\\mathrm{mg}/\\mathrm{L}$ 表示，曲线下面积以 $\\mathrm{mg}\\cdot\\mathrm{h}/\\mathrm{L}$ 表示。\n- 所有输出均四舍五入到3位小数。\n- 本问题不涉及角度。\n\n测试套件：\n为以下案例提供结果。在所有案例中，给药方案数组将每次输注列为 $(t_{\\text{start}}, \\tau, D)$，其中时间和持续时间的单位为 $\\mathrm{h}$，剂量的单位为 $\\mathrm{mg}$。\n\n- 案例1（典型成人，每12小时一次）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 1, 1000), (12, 1, 1000)]$，TDM 观测值（时间点和测量浓度）为 $[(1, 21.1), (11.5, 6.0), (13, 26.4), (23.5, 7.1)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n- 案例2（单次给药，短时输注）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 0.5, 1500)]$，TDM 观测值为 $[(0.5, 27.2), (2, 23.4), (8, 15.8), (24, 3.0)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n- 案例3（每8小时一次，长时输注）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 2, 750), (8, 2, 750), (16, 2, 750)]$，TDM 观测值为 $[(2, 15.9), (10, 21.5), (15.5, 9.4), (18, 22.2)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n- 案例4（每12小时一次，较慢消除，较大容积）：$T = 24\\,\\mathrm{h}$，方案 $[(0, 1, 750), (12, 1, 750)]$，TDM 观测值为 $[(1, 10.6), (13, 15.6), (23.5, 8.1)]$，单位为 $\\mathrm{mg}/\\mathrm{L}$。\n\n算法要求：\n- 使用在 $R$ 恒定的区间上 $dA/dt = -k_e A + R$ 的解，以及在输注之外的时间 $R=0$ 的解，精确地在每个区间上传播 $A(t)$。\n- 计算 $C(t) = A(t)/V$。\n- 对于曲线下面积，使用 $A(t)$ 在每个区间上的精确积分，再除以 $V$。\n- 使用非线性最小二乘法，参数边界为 $k_e \\in [0.02, 1.0]$ 和 $V \\in [10, 100]$，并采用合理的初始猜测值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表中的每个元素是对应案例的结果。每个案例的结果是一个包含5个浮点数的列表，按上述顺序排列，所有数值均四舍五入到3位小数，并用方括号括起来。例如，输出应类似于 $[[k_{e,1},V_1,\\max C_1,C_1(T),\\mathrm{AUC}_1],[k_{e,2},V_2,\\max C_2,C_2(T),\\mathrm{AUC}_2],\\dots]$。",
            "solution": "该问题要求开发一种计算方法，利用治疗药物监测（TDM）数据来个性化万古霉素治疗的单室药代动力学（PK）模型。这包括估计患者特异性参数，并用这些参数来预测药物的浓度曲线和相关的临床指标。这个问题在科学上是适定的，并为提供一个完整的解决方案提供了所有必要的信息。\n\n其基本原理是将质量平衡应用于代表身体的单个、均匀混合的房室中的药物量 $A(t)$。该房室的表观容积为 $V$。药物量与浓度 $C(t)$ 之间的关系由 $C(t) = A(t)/V$ 给出。$A(t)$ 的动态由以下一阶线性常微分方程（ODE）描述：\n$$\n\\frac{dA}{dt} = -k_e A(t) + R(t)\n$$\n其中 $k_e$ 是一级消除速率常数，单位为 $\\mathrm{h}^{-1}$，$R(t)$ 是药物给药速率，单位为 $\\mathrm{mg}/\\mathrm{h}$。对于静脉输注，$R(t)$ 是一个分段常数函数。在持续时间为 $\\tau$、总剂量为 $D$ 的输注期间，它等于一个恒定速率 $R_{inf} = D/\\tau$，在其他时间则 $R(t)=0$。初始条件指定为 $A(0) = 0$。\n\n解决方案的核心在于求解此常微分方程，并用它来预测浓度，然后将这些浓度用于参数估计框架。\n\n**1. 药代动力学模型的解析解**\n\n该常微分方程在输注速率 $R$ 恒定的连续时间区间上求解。对于区间 $[t_a, t_b]$，初始药物量为 $A(t_a)$，恒定速率为 $R$，则 $A(t)$ 在 $t \\in [t_a, t_b]$ 上的解析解为：\n$$\nA(t) = \\frac{R}{k_e} + \\left(A(t_a) - \\frac{R}{k_e}\\right) e^{-k_e (t - t_a)}\n$$\n当没有输注时，$R=0$，方程简化为纯指数衰减：\n$$\nA(t) = A(t_a) e^{-k_e (t - t_a)}\n$$\n这些方程使我们能够在一个由输注和消除阶段组成的方案中，将药物量 $A(t)$ 从一个时间点精确地传播到下一个时间点。\n\n**2. 通过非线性最小二乘法进行参数估计**\n\n个体的 PK 参数 $k_e$ 和 $V$ 是未知的，必须根据 TDM 数据进行估计。数据由数对 $(t_i, y_i)$ 组成，其中 $y_i$ 是在时间 $t_i$ 测得的浓度。这些观测值的模型是 $y_i = C(t_i) + \\epsilon_i$，其中 $C(t_i) = A(t_i)/V$ 是真实浓度，$\\epsilon_i$ 是均值为0的独立同分布高斯随机测量误差。\n\n在此假设下，最大似然估计等价于最小化模型预测浓度与观测浓度之间的残差平方和（SSR）：\n$$\n\\text{SSR}(k_e, V) = \\sum_{i} \\left( C(t_i; k_e, V) - y_i \\right)^2 = \\sum_{i} \\left( \\frac{A(t_i; k_e)}{V} - y_i \\right)^2\n$$\n这是一个非线性最小二乘问题。我们寻求参数值 $(\\hat{k}_e, \\hat{V})$ 来最小化此目标函数，并受物理上合理的边界 $k_e \\in [0.02, 1.0]\\,\\mathrm{h}^{-1}$ 和 $V \\in [10, 100]\\,\\mathrm{L}$ 的约束。该优化以数值方式执行，使用带有界限约束的算法（例如 L-BFGS-B）的 `scipy.optimize.minimize` 函数是合适的。\n\n**3. 派生药代动力学指标的计算**\n\n一旦确定了个体的最优参数 $(\\hat{k}_e, \\hat{V})$，我们就可以计算所需的治疗指标。\n\n- **最大浓度 ($C_{max}$)**: 浓度 $C(t)$ 在输注期间增加（假设初始浓度低于该次输注的稳态值），在消除期间减少。因此，时间窗口 $[0, T]$ 内的峰浓度将出现在某个输注期的结束时刻。具体步骤是模拟完整的浓度曲线，并找出在每个输注结束的特定时间点所达到的最大值。\n\n- **$T$ 时刻的浓度 ($C(T)$)**: 使用估计的参数 $\\hat{k}_e$ 和 $\\hat{V}$ 将模型向前传播到时间 $T$ 来计算此值。\n\n- **曲线下面积 (AUC)**: 区间 $[0, T]$ 上的 AUC 是浓度-时间曲线的积分：\n$$\n\\text{AUC}_{[0,T]} = \\int_0^T C(t) dt = \\frac{1}{\\hat{V}} \\int_0^T A(t) dt\n$$\n为按要求精确计算此值，我们在每个分段常数区间上对 $A(t)$ 的解析解进行积分。通过对 ODE 本身进行积分，可以推导出一个在速率 $R$ 恒定的区间 $[t_a, t_b]$ 上对 $A(t)$ 进行积分的数值稳定且简洁的公式：\n$$\n\\int_{t_a}^{t_b} \\frac{dA}{dt} dt = A(t_b) - A(t_a) = \\int_{t_a}^{t_b} (-k_e A(t) + R) dt = -k_e \\int_{t_a}^{t_b} A(t) dt + R(t_b - t_a)\n$$\n整理后可得积分公式：\n$$\n\\int_{t_a}^{t_b} A(t) dt = \\frac{A(t_a) - A(t_b) + R(t_b - t_a)}{k_e}\n$$\n总积分 $\\int_0^T A(t) dt$ 是通过在一个由所有输注开始/结束时间点和最终时间 $T$ 组成的时间线上，将这些区间积分相加得到的。最终的 AUC 是该总积分除以估计的容积 $\\hat{V}$。\n\n**算法实现**\n\n一个稳健的实现将包括三个主要部分：\n1.  一个核心模拟函数，在给定参数 $(k_e, V)$、给药方案和一组评估时间点的情况下，传播 $A(t)$ 并可选择性地计算 $A(t)$ 在整个时间线上的积分。该函数将对每个区间使用解析解。\n2.  一个用于优化器的目标函数，它以参数 $(k_e, V)$ 为输入，调用模拟函数以获取在 TDM 时间点的预测浓度，并返回 SSR。\n3.  一个主循环，它对每个测试用例调用优化程序以找到 $(\\hat{k}_e, \\hat{V})$，然后使用这些最优参数来计算并格式化五个所需的输出指标。\n\n整个过程将药代动力学的原理转化为用于模型个性化和预测的具体计算工作流，为药物治疗的数字孪生奠定了基础。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the pharmacokinetic modeling problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 1.0, 1000.0), (12.0, 1.0, 1000.0)],\n            \"tdm_data\": [(1.0, 21.1), (11.5, 6.0), (13.0, 26.4), (23.5, 7.1)],\n        },\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 0.5, 1500.0)],\n            \"tdm_data\": [(0.5, 27.2), (2.0, 23.4), (8.0, 15.8), (24.0, 3.0)],\n        },\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 2.0, 750.0), (8.0, 2.0, 750.0), (16.0, 2.0, 750.0)],\n            \"tdm_data\": [(2.0, 15.9), (10.0, 21.5), (15.5, 9.4), (18.0, 22.2)],\n        },\n        {\n            \"T\": 24.0,\n            \"schedule\": [(0.0, 1.0, 750.0), (12.0, 1.0, 750.0)],\n            \"tdm_data\": [(1.0, 10.6), (13.0, 15.6), (23.5, 8.1)],\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        tdm_times = np.array([d[0] for d in case[\"tdm_data\"]])\n        tdm_obs = np.array([d[1] for d in case[\"tdm_data\"]])\n\n        def _propagate(ke, schedule, eval_times):\n            \"\"\"\n            Propagates the amount of drug A(t) over time.\n            \"\"\"\n            # Create a timeline of events (infusion starts/ends, evaluation points)\n            event_times = {0.0}\n            rate_changes = {}\n\n            for start, duration, dose in schedule:\n                if duration > 0:\n                    rate = dose / duration\n                    end = start + duration\n                    event_times.add(start)\n                    event_times.add(end)\n                    rate_changes[start] = rate_changes.get(start, 0) + rate\n                    rate_changes[end] = rate_changes.get(end, 0) - rate\n\n            if eval_times is not None:\n                for t in eval_times:\n                    event_times.add(t)\n\n            sorted_times = sorted(list(event_times))\n            \n            # Since eval_times might contain duplicates after adding to a set\n            eval_times_set = set(eval_times) if eval_times is not None else set()\n            \n            A = 0.0\n            current_rate = 0.0\n            last_t = 0.0\n            \n            amount_at_eval_times = {}\n\n            for t in sorted_times:\n                if t > last_t:\n                    dt = t - last_t\n                    A_start_interval = A\n                    if current_rate > 1e-9: # Infusion phase\n                        A = (current_rate / ke) + (A_start_interval - current_rate / ke) * np.exp(-ke * dt)\n                    else: # Elimination phase\n                        A = A_start_interval * np.exp(-ke * dt)\n\n                if t in rate_changes:\n                    current_rate += rate_changes[t]\n\n                if t in eval_times_set:\n                    amount_at_eval_times[t] = A\n                \n                last_t = t\n                \n            # Return amounts in the same order as eval_times\n            ordered_amounts = [amount_at_eval_times[t] for t in eval_times]\n            return ordered_amounts\n\n        def objective_function(params):\n            ke, V = params\n            predicted_amounts = _propagate(ke, case[\"schedule\"], tdm_times)\n            predicted_concentrations = np.array(predicted_amounts) / V\n            ssr = np.sum((predicted_concentrations - tdm_obs) ** 2)\n            return ssr\n        \n        # Parameter estimation\n        initial_guess = [0.1, 40.0]\n        bounds = [(0.02, 1.0), (10.0, 100.0)]\n        result = minimize(objective_function, initial_guess, method='L-BFGS-B', bounds=bounds)\n        ke_opt, V_opt = result.x\n\n        # Calculate final outputs with optimized parameters\n        T = case[\"T\"]\n        \n        # Create a timeline for final calculations (AUC, Cmax, C(T))\n        event_times = {0.0, T}\n        rate_changes = {}\n        infusion_end_times = []\n\n        for start, duration, dose in case[\"schedule\"]:\n            if duration > 0:\n                rate = dose / duration\n                end = start + duration\n                event_times.add(start)\n                event_times.add(end)\n                infusion_end_times.append(end)\n                rate_changes[start] = rate_changes.get(start, 0) + rate\n                rate_changes[end] = rate_changes.get(end, 0) - rate\n\n        sorted_times = sorted(list(event_times))\n        \n        A = 0.0\n        current_rate = 0.0\n        last_t = 0.0\n        auc_A = 0.0\n        amount_at_event_times = {}\n\n        for t in sorted_times:\n            if t > last_t:\n                dt = t - last_t\n                A_start_interval = A\n                if current_rate > 1e-9:\n                    A = (current_rate / ke_opt) + (A_start_interval - current_rate / ke_opt) * np.exp(-ke_opt * dt)\n                else:\n                    A = A_start_interval * np.exp(-ke_opt * dt)\n                \n                # Accumulate integral of A(t)\n                auc_A += (A_start_interval - A + current_rate * dt) / ke_opt\n\n            if t in rate_changes:\n                current_rate += rate_changes[t]\n\n            amount_at_event_times[t] = A\n            last_t = t\n        \n        # 1.  2. Estimated parameters\n        ke_final = round(ke_opt, 3)\n        V_final = round(V_opt, 3)\n        \n        # 3. Maximum Concentration\n        C_at_inf_ends = [amount_at_event_times[t] / V_opt for t in infusion_end_times if t = T]\n        C_max = round(max(C_at_inf_ends) if C_at_inf_ends else 0.0, 3)\n\n        # 4. Concentration at T\n        C_T = round(amount_at_event_times[T] / V_opt, 3)\n\n        # 5. Area Under the Curve\n        AUC = round(auc_A / V_opt, 3)\n\n        all_results.append([ke_final, V_final, C_max, C_T, AUC])\n    \n    # Format the final output string\n    result_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]},{r[3]},{r[4]}]\" for r in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "一个经过个性化校准的模型，只有当其参数是可信的时，才具有临床应用价值。然而，仅凭有限的、含噪声的数据，我们未必能唯一地确定所有模型参数。本练习探讨了“实际可辨识性”（practical identifiability）这一关键概念，并指导您使用剖面似然法（profile likelihood）来评估可用数据是否足以约束模型参数。掌握此方法对于确保数字孪体预测的可靠性至关重要。",
            "id": "4217304",
            "problem": "用于医疗保健中个性化药物治疗的数字孪生是患者药物浓度动态学的计算副本，用于个性化给药决策。它是一个信息物理系统（CPS）的典型示例，其中计算模型通过物理测量值持续更新。为了使数字孪生在临床上具有可行性，其动力学模型的参数必须能够从可用数据中进行实践辨识。本问题的目标是使用剖面似然法对单室静脉推注药代动力学模型的实践可辨识性进行可操作化，并实现一个程序，该程序能根据明确的标准，为每个参数和每个测试用例确定其剖面是有界的还是平坦的。\n\n基本原理和设置：考虑一个单室静脉推注模型，其药物浓度 $C(t)$ 由下式给出：\n$$\nC(t) \\;=\\; \\frac{D}{V} \\, e^{-k_e \\, t},\n$$\n其中 $t$ 是时间，$D$ 是剂量，$V$ 是分布容积，$k_e$ 是一级消除速率常数。假设在时间 $t_i$ 的测量值 $y_i$ 满足：\n$$\ny_i \\;=\\; C(t_i) + \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),\n$$\n其中 $\\varepsilon_i$ 是方差为 $\\sigma^2$ 的独立高斯噪声。在独立高斯误差的假设下，对数似然 $\\ell(\\theta)$ 与残差平方和的负数成正比，\n$$\n-2 \\log L(\\theta) \\;=\\; \\sum_{i=1}^{n} \\frac{(y_i - C(t_i;\\theta))^2}{\\sigma^2} + \\text{constant},\n$$\n其中 $\\theta$ 表示由待估计参数组成的参数向量。参数 $\\theta_j$ 的剖面似然定义为：\n$$\n\\ell_p(\\theta_j) \\;=\\; \\max_{\\theta_{-j}} \\ell(\\theta_j,\\theta_{-j}),\n$$\n这等价于在保持 $\\theta_j$ 固定的同时，对除 $\\theta_j$ 之外的所有参数最小化 $-2\\log L$。\n\n实践可辨识性标准：对于单个参数剖面，定义偏差\n$$\nD(\\theta) \\;=\\; \\sum_{i=1}^n \\frac{(y_i - C(t_i;\\theta))^2}{\\sigma^2}.\n$$\n令 $D_{\\min}$ 为所有参数下的最小偏差。对于 $95\\%$ 的置信水平，令 $q_{0.95}$ 为自由度为 $1$ 的卡方分布的 $0.95$ 分位数。$\\theta_j$ 的 $95\\%$ 基于剖面的置信集为：\n$$\n\\mathcal{S}_j \\;=\\; \\left\\{\\theta_j \\,\\middle|\\, D_j(\\theta_j) \\le D_{\\min} + q_{0.95}\\right\\},\n$$\n其中 $D_j(\\theta_j)$ 是在固定 $\\theta_j$ 的情况下，对除 $\\theta_j$ 之外的所有参数最小化 $D$ 所得到的剖面偏差。在数值实践中，如果集合 $\\mathcal{S}_j$ 是一个严格包含在为 $\\theta_j$ 探索的网格内的有界区间（即，它不触及网格边界），我们则将该参数分类为具有有界剖面（实践上可辨识的）。如果 $\\mathcal{S}_j$ 触及边界或在未超过阈值 $D_{\\min}+q_{0.95}$ 的情况下横跨整个网格，则该剖面是平坦或无界的（实践上不可辨识的）。\n\n程序要求：实现一个程序，对下述每个测试用例，该程序能从真实（ground-truth）参数生成合成数据，通过对待估计参数进行优化来计算全局最小偏差 $D_{\\min}$，通过固定一个网格的值并优化其余参数来为每个待估计参数构建剖面似然，并根据上述标准确定每个参数的剖面是有界还是平坦的。使用以下网格进行剖面分析：\n- 对于 $k_e$：在 $[0.05, 1.0]\\,\\mathrm{hr}^{-1}$ 范围内取 $50$ 个等距点。\n- 对于 $V$：在 $[5.0, 50.0]\\,\\mathrm{L}$ 范围内取 $50$ 个等距点。\n- 对于 $D$：在 $[50.0, 500.0]\\,\\mathrm{mg}$ 范围内取 $50$ 个等距点。\n对自由参数使用有界优化，边界如下：\n- $k_e \\in [0.01, 5.0]\\,\\mathrm{hr}^{-1}$，\n- $V \\in [1.0, 200.0]\\,\\mathrm{L}$，\n- $D \\in [10.0, 1000.0]\\,\\mathrm{mg}$。\n\n数据生成：对于每个测试用例，设置固定的随机种子以确保可复现性，并从 $\\mathcal{N}(0,\\sigma^2)$ 中抽取 $\\varepsilon_i$。\n\n单位：时间 $t$ 单位为 $\\mathrm{hr}$，剂量 $D$ 单位为 $\\mathrm{mg}$，容积 $V$ 单位为 $\\mathrm{L}$，浓度 $C$ 和 $y_i$ 单位为 $\\mathrm{mg}/\\mathrm{L}$，消除速率 $k_e$ 单位为 $\\mathrm{hr}^{-1}$。\n\n测试套件和覆盖范围：\n- 用例 1 (理想路径)：已知剂量 $D$ 被视为固定值 $D = 100\\,\\mathrm{mg}$。待估计参数：$k_e$ 和 $V$。真实值：$k_e = 0.4\\,\\mathrm{hr}^{-1}$，$V = 20\\,\\mathrm{L}$。采样时间：$t = [0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]\\,\\mathrm{hr}$。噪声标准差：$\\sigma = 0.2\\,\\mathrm{mg}/\\mathrm{L}$。\n- 用例 2 (结构不可辨识性)：未知剂量 $D$ 被包含在待估计参数中：$k_e$、$V$、$D$。真实值：$k_e = 0.4\\,\\mathrm{hr}^{-1}$，$V = 20\\,\\mathrm{L}$，$D = 100\\,\\mathrm{mg}$。采样时间：$t = [0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]\\,\\mathrm{hr}$。噪声标准差：$\\sigma = 0.2\\,\\mathrm{mg}/\\mathrm{L}$。\n- 用例 3 (边界和稀疏性边缘情况)：未知剂量 $D$ 被包含在待估计参数中：$k_e$、$V$、$D$。真实值：$k_e = 0.4\\,\\mathrm{hr}^{-1}$，$V = 20\\,\\mathrm{L}$，$D = 100\\,\\mathrm{mg}$。采样时间集中在零附近：$t = [0.0, 0.1, 0.2, 0.3]\\,\\mathrm{hr}$。噪声标准差：$\\sigma = 0.05\\,\\mathrm{mg}/\\mathrm{L}$。\n- 用例 4 (高噪声压力测试)：已知剂量 $D$ 被视为固定值 $D = 100\\,\\mathrm{mg}$。待估计参数：$k_e$ 和 $V$。真实值：$k_e = 0.4\\,\\mathrm{hr}^{-1}$，$V = 20\\,\\mathrm{L}$。采样时间：$t = [0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]\\,\\mathrm{hr}$。噪声标准差：$\\sigma = 2.0\\,\\mathrm{mg}/\\mathrm{L}$。\n\n要求输出：对于每个用例，按用例定义中列出的参数顺序，生成一个布尔值列表，依次指示每个估计参数的剖面是有界（true）还是平坦/无界（false）。具体来说：\n- 用例 1：输出 $[b_{k_e}, b_V]$，\n- 用例 2：输出 $[b_{k_e}, b_V, b_D]$，\n- 用例 3：输出 $[b_{k_e}, b_V, b_D]$，\n- 用例 4：输出 $[b_{k_e}, b_V]$。\n程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个用例的列表本身也用方括号括起来。例如，输出格式应如下所示：$[\\,[\\cdot,\\cdot],\\,[\\cdot,\\cdot,\\cdot],\\,\\ldots\\,]$。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n最终指令：使用 Python 编程，通过数值优化构建似然剖面，并应用上述可辨识性标准。确保所有计算均遵循提供的单位，程序无需外部输入即可运行，并严格按照指定格式打印一行输出。",
            "solution": "该问题要求使用剖面似然法评估单室药代动力学模型中参数的实践可辨识性。这包括生成合成数据，执行数值优化以找到全局似然和剖面似然，并应用统计标准将每个参数的剖面分类为‘有界’（可辨识）或‘平坦/无界’（不可辨识）。\n\n药代动力学模型描述了静脉推注后药物浓度 $C(t)$ 随时间 $t$ 的变化。该模型由下式给出：\n$$\nC(t) \\;=\\; \\frac{D}{V} \\, e^{-k_e \\, t}\n$$\n此处，$D$ 是给药剂量，$V$ 是分布容积，$k_e$ 是一级消除速率常数。待估计的参数向量用 $\\theta$ 表示。\n\n数据由在时间 $t_i$ 采集的测量值 $y_i$ 组成，这些测量值被建模为真实浓度加上独立同分布的高斯噪声：\n$$\ny_i \\;=\\; C(t_i; \\theta) + \\varepsilon_i, \\quad \\text{where} \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)\n$$\n假设噪声方差 $\\sigma^2$ 已知。在此假设下，最大化似然函数 $L(\\theta)$ 等价于最小化由方差加权的残差平方和。这产生了偏差函数 $D(\\theta)$：\n$$\nD(\\theta) \\;=\\; \\sum_{i=1}^{n} \\frac{(y_i - C(t_i;\\theta))^2}{\\sigma^2}\n$$\n对所有参数 $\\theta$ 最小化 $D(\\theta)$，可以得到最大似然估计 $\\hat{\\theta}$ 和最小偏差 $D_{\\min} = D(\\hat{\\theta})$。\n\n为了评估单个参数（例如 $\\theta_j$）的可辨识性，我们采用剖面似然法。对于 $\\theta_j$ 的一个固定值，我们对所有其他参数 $\\theta_{-j}$ 最小化偏差函数。此过程定义了 $\\theta_j$ 的剖面偏差：\n$$\nD_j(\\theta_j) \\;=\\; \\min_{\\theta_{-j}} D\\left(\\theta = (\\theta_j, \\theta_{-j})\\right)\n$$\n通过在 $\\theta_j$ 的一个值网格上计算 $D_j(\\theta_j)$，我们获得了该参数的剖面。\n\n实践可辨识性标准基于似然比检验。在 $95\\%$ 置信水平下，与数据一致的参数 $\\theta_j$ 的值集合由下式给出：\n$$\n\\mathcal{S}_j \\;=\\; \\left\\{\\theta_j \\,\\middle|\\, D_j(\\theta_j) \\le D_{\\min} + q_{0.95}\\right\\}\n$$\n其中 $q_{0.95}$ 是自由度为 $1$ 的卡方分布的 $0.95$ 分位数（约等于 $3.841$）。这对应于偏差变化的阈值。\n\n如果置信集 $\\mathcal{S}_j$ 在指定的数值网格上求值时，形成一个不包含网格端点的区间，那么参数 $\\theta_j$ 就被认为是**实践上可辨识的**（具有‘有界’剖面）。这表明数据提供了足够的信息将参数约束在一个有限的范围内。相反，如果置信集 $\\mathcal{S}_j$ 延伸到网格的一侧或两侧边界，那么该参数就是**实践上不可辨识的**（具有‘平坦’或‘无界’剖面）。这意味着数据不足以约束该参数，这可能是由于结构模型属性（如参数冗余）或实践限制（如稀疏采样、高噪声）造成的。\n\n解决此问题的算法对每个测试用例按以下步骤进行：\n1.  **数据合成**：使用真实参数在指定时间点 $t_i$ 生成合成浓度数据 $y_i$，并添加指定标准差 $\\sigma$ 的高斯噪声。固定的随机种子确保可复现性。\n2.  **全局偏差最小化**：在给定边界的约束下，对所有可估计参数数值最小化偏差函数 $D(\\theta)$。此优化过程得到全局最小偏差 $D_{\\min}$。\n3.  **剖面偏差计算**：对于每个待估计的参数：a. 遍历该参数的预定义值网格。b. 在每个网格点上，固定当前参数，并对其余自由参数（同样受其边界约束）进行数值最小化偏差。c. 存储得到的最小化偏差。这些值的集合构成了该参数的剖面偏差。\n4.  **可辨识性评估**：a. 计算偏差阈值 $T = D_{\\min} + q_{0.95}$。b. 对于每个参数的剖面，找出剖面偏差小于或等于 $T$ 的网格点。c. 如果这个点集非空，且其最小和最大索引严格位于网格边界之内（即不是第一个或最后一个索引），则该参数被分类为‘有界’（True）。否则，它被分类为‘平坦/无界’（False）。\n\n此程序应用于四个不同的用例，旨在测试不同的可辨识性场景：\n-   **用例 1**：一个具有低噪声和充足数据的良态问题，其中 $k_e$ 和 $V$ 预期都是可辨识的。\n-   **用例 2**：一个表现出结构不可辨识性的用例。模型 $C(t) = (D/V) e^{-k_e t}$ 对 $D$ 和 $V$ 的单个值不敏感，只对其比率 $D/V$ 敏感。因此，虽然 $k_e$ 应该是可辨识的，但 $D$ 和 $V$ 预期是不可辨识的。\n-   **用例 3**：一个采样稀疏且集中在早期时间点的用例。这种实践限制，加上 $D$ 和 $V$ 的结构不可辨识性，预期会使所有三个参数（$k_e$、$V$、$D$）都不可辨识。短时间过程几乎不提供关于指数衰减率 $k_e$ 的信息。\n-   **用例 4**：一个与用例 1 相同但噪声水平很高的用例。低信噪比预期会使似然曲面变平，导致 $k_e$ 和 $V$ 都出现实践上的不可辨识性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Performs practical identifiability analysis for a one-compartment pharmacokinetic model\n    using the profile likelihood method for four distinct test cases.\n    \"\"\"\n\n    # --- Configuration and Test Cases ---\n\n    # Chi-square quantile for 95% confidence interval with 1 degree of freedom\n    q_095 = chi2.ppf(0.95, df=1)\n\n    # Profiling grids\n    grids = {\n        'ke': np.linspace(0.05, 1.0, 50),\n        'V': np.linspace(5.0, 50.0, 50),\n        'D': np.linspace(50.0, 500.0, 50)\n    }\n\n    # Optimization bounds\n    bounds = {\n        'ke': (0.01, 5.0),\n        'V': (1.0, 200.0),\n        'D': (10.0, 1000.0)\n    }\n    \n    # Test cases defined in a structured list\n    test_cases = [\n        {\n            'name': 'Case 1 (Happy Path)',\n            'params_to_estimate': ['ke', 'V'],\n            'fixed_params': {'D': 100.0},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]),\n            'sigma': 0.2,\n            'seed': 42\n        },\n        {\n            'name': 'Case 2 (Structural Non-identifiability)',\n            'params_to_estimate': ['ke', 'V', 'D'],\n            'fixed_params': {},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]),\n            'sigma': 0.2,\n            'seed': 43\n        },\n        {\n            'name': 'Case 3 (Boundary and Sparsity)',\n            'params_to_estimate': ['ke', 'V', 'D'],\n            'fixed_params': {},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.1, 0.2, 0.3]),\n            'sigma': 0.05,\n            'seed': 44\n        },\n        {\n            'name': 'Case 4 (High Noise)',\n            'params_to_estimate': ['ke', 'V'],\n            'fixed_params': {'D': 100.0},\n            'ground_truth': {'ke': 0.4, 'V': 20.0, 'D': 100.0},\n            'times': np.array([0.0, 0.5, 1.0, 2.0, 4.0, 6.0, 8.0]),\n            'sigma': 2.0,\n            'seed': 45\n        }\n    ]\n\n    # --- Helper Functions ---\n\n    def model(t, ke, V, D):\n        \"\"\" One-compartment IV bolus model \"\"\"\n        # Handle t=0 case to avoid issues with large negative exponents if ke is large\n        # Also, V cannot be zero. Optimizer bounds prevent this, but good practice.\n        if V == 0: return np.inf\n        C0 = D / V\n        return C0 * np.exp(-ke * t)\n\n    def deviance(params, param_names, t, y, sigma, fixed_params):\n        \"\"\" Calculates the deviance (proportional to -2 * log-likelihood) \"\"\"\n        all_params = dict(zip(param_names, params))\n        all_params.update(fixed_params)\n        \n        ke = all_params['ke']\n        V = all_params['V']\n        D = all_params['D']\n\n        y_model = model(t, ke, V, D)\n        residuals = y - y_model\n        return np.sum(residuals**2) / (sigma**2)\n\n    # --- Main Processing Loop ---\n    \n    final_results = []\n\n    for case in test_cases:\n        # 1. Generate synthetic data\n        np.random.seed(case['seed'])\n        gt = case['ground_truth']\n        y_true = model(case['times'], gt['ke'], gt['V'], gt['D'])\n        y_data = y_true + np.random.normal(0, case['sigma'], size=len(case['times']))\n\n        params_to_estimate = case['params_to_estimate']\n        \n        # 2. Global optimization to find D_min\n        initial_guess = [gt[p] for p in params_to_estimate]\n        opt_bounds = [bounds[p] for p in params_to_estimate]\n        \n        res_global = minimize(\n            deviance,\n            x0=initial_guess,\n            args=(params_to_estimate, case['times'], y_data, case['sigma'], case['fixed_params']),\n            method='L-BFGS-B',\n            bounds=opt_bounds\n        )\n        D_min = res_global.fun\n        threshold = D_min + q_095\n\n        case_results = []\n        # 3. Profile likelihood for each parameter\n        for i, p_fixed_name in enumerate(params_to_estimate):\n            profile_grid = grids[p_fixed_name]\n            profile_deviance = np.zeros_like(profile_grid)\n            \n            p_optim_names = [p for p in params_to_estimate if p != p_fixed_name]\n            \n            for j, p_fixed_value in enumerate(profile_grid):\n                \n                # Define objective for the nested optimization\n                def inner_objective(p_optim_values):\n                    current_fixed_params = {p_fixed_name: p_fixed_value}\n                    current_fixed_params.update(case['fixed_params'])\n                    return deviance(p_optim_values, p_optim_names, case['times'], y_data, case['sigma'], current_fixed_params)\n\n                # Set up for inner optimization\n                inner_initial_guess = [gt[p] for p in p_optim_names]\n                inner_bounds = [bounds[p] for p in p_optim_names]\n\n                # If no other params to optimize, just calculate deviance\n                if not p_optim_names:\n                    profile_deviance[j] = inner_objective([])\n                    continue\n                \n                res_profile = minimize(\n                    inner_objective,\n                    x0=inner_initial_guess,\n                    method='L-BFGS-B',\n                    bounds=inner_bounds\n                )\n                profile_deviance[j] = res_profile.fun\n\n            # 4. Assess identifiability\n            within_threshold_indices = np.where(profile_deviance = threshold)[0]\n            \n            is_bounded = False\n            if len(within_threshold_indices) > 0:\n                min_idx = np.min(within_threshold_indices)\n                max_idx = np.max(within_threshold_indices)\n                if min_idx > 0 and max_idx  len(profile_grid) - 1:\n                    is_bounded = True\n            \n            case_results.append(is_bounded)\n            \n        final_results.append(case_results)\n\n    # Format and print the final output\n    output_str = '[' + ','.join([str(res) for res in final_results]) + ']'\n    output_str = output_str.replace(\"'\", \"\").replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "数字孪体的最终目标是成为一个强大的决策支持工具，帮助预测不同干预措施的后果。本练习将展示如何利用一个经过个性化的肿瘤生长动力学模型，在计算机上模拟并比较不同的化疗给药方案。通过这种“在硅”（in-silico）的比较与优化，您可以探索并识别出针对特定患者参数的潜在最优治疗策略。",
            "id": "4217334",
            "problem": "考虑一个简化的、针对个性化医疗中细胞毒性化疗下肿瘤负荷的患者特异性数字孪生，该模型由具有逻辑斯谛增长和剂量依赖性杀伤项的单室肿瘤群体建模。设肿瘤群体为 $N(t)$（单位：细胞），并假设其动态由常微分方程（ODE）控制 $$\\dot N(t) = r\\,N(t)\\left(1 - \\frac{N(t)}{K}\\right) - \\kappa\\,u(t)\\,N(t),$$ 其中 $r$ 是内禀增长率（单位：$\\mathrm{day}^{-1}$），$K$ 是承载能力（单位：细胞），$\\kappa$ 是药物杀伤敏感性参数（单位：$(\\mathrm{mg}/\\mathrm{m}^2)^{-1}$），$u(t)$ 是化疗输注速率（单位：$\\mathrm{mg}/\\mathrm{m}^2/\\mathrm{day}$）。假设 $t$ 以天为单位测量，浓度被整合到有效输注速率 $u(t)$ 中，因此 $\\kappa\\,u(t)$ 的单位为 $\\mathrm{day}^{-1}$。设初始肿瘤群体为 $N(0) = N_0$（单位：细胞）。该常微分方程是一个质量平衡模型，结合了经过充分检验的逻辑斯谛增长和与剂量率成正比的一阶杀伤项。\n\n您的任务是编写一个完整的程序，对于每个代表患者特异性参数集的给定测试用例，评估一组给药方案 $u(t)$。这些方案都在一个固定的时间范围 $[0,T]$（单位：天）内消耗相同的总剂量预算 $B$（单位：$\\mathrm{mg}/\\mathrm{m}^2$）。对于每种方案，通过对常微分方程进行积分来计算无量纲的归一化累积负荷 $$A = \\frac{1}{T}\\int_0^T \\frac{N(t)}{K}\\,dt,$$ 如果肿瘤在某个时间 $t_\\mathrm{ext} \\le T$ 达到灭绝（$N(t)=0$），则在计算 $A$ 时，对于所有 $t \\in [t_\\mathrm{ext}, T]$，均视为 $N(t)=0$。在规定的方案下，找出使 $A$ 最小化的给药方案。如果最佳的两个或多个方案出现平局，即 $|A_i - A_j| \\le 10^{-6}$，则选择索引最小的方案。\n\n每个测试用例需要比较的给药方案如下：\n- 方案 $0$（节拍式）：对于所有 $t \\in [0,T]$，$u(t) = \\frac{B}{T}$，否则 $u(t)=0$。\n- 方案 $1$（每周脉冲，每次 $1$ 天）：在 $t=0,7,14,\\dots$ 开始且严格小于 $T$ 的日期，以速率 $u(t) = \\frac{B}{n_\\mathrm{w}}$ 输注 $1$ 天，其中 $n_\\mathrm{w}$ 是 $[0,T)$ 内的脉冲次数；否则 $u(t)=0$。\n- 方案 $2$（每两周脉冲，每次 $1$ 天）：在 $t=0,14,28,\\dots$ 开始且严格小于 $T$ 的日期，以速率 $u(t) = \\frac{B}{n_\\mathrm{b}}$ 输注 $1$ 天，其中 $n_\\mathrm{b}$ 是 $[0,T)$ 内的脉冲次数；否则 $u(t)=0$。\n- 方案 $3$（前负荷，前 $3$ 天）：对于 $t \\in [0,d)$，其中 $d=\\min(3,T)$，$u(t) = \\frac{B}{d}$，否则 $u(t)=0$。\n\n为了数值上的真实性，所有参数都具有科学合理性且自洽。使用以下参数集 $(r,K,\\kappa,N_0,T,B)$ 的测试套件：\n- 案例 $1$：$(0.03,\\,10^9,\\,0.002,\\,10^8,\\,42,\\,600)$\n- 案例 $2$：$(0.06,\\,10^9,\\,0.0015,\\,2\\times 10^8,\\,42,\\,600)$\n- 案例 $3$：$(0.03,\\,10^9,\\,0.0005,\\,10^8,\\,42,\\,600)$\n- 案例 $4$：$(0.005,\\,10^9,\\,0.002,\\,3\\times 10^8,\\,42,\\,600)$\n- 案例 $5$（无治疗预算的边界条件）：$(0.03,\\,10^9,\\,0.002,\\,10^8,\\,42,\\,0)$\n\n所有时间量必须以天为单位处理，$N(t)$ 必须解释为细胞数，输注速率 $u(t)$ 的单位为 $\\mathrm{mg}/\\mathrm{m}^2/\\mathrm{day}$，$A$ 是无量纲的。\n\n您的程序应按顺序为上述每个案例输出最优方案的索引，并将结果聚合到单行输出中，形式为用方括号括起来的逗号分隔列表。例如，输出格式应为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$，其中每个 $\\text{result}_i$ 是集合 $\\{0,1,2,3\\}$ 中的一个整数。",
            "solution": "用户提供的问题是计算系统生物学和个性化医疗领域中一个有效且适定的任务。它要求通过将一组离散的方案与一个生物学相关的目标函数进行比较，来优化化疗给药策略。其基础模型是一个标准的逻辑斯谛增长模型，并用一阶药物杀伤项进行了修正，这是对治疗下肿瘤动态的一个有科学依据的简化。所有参数、约束和目标函数都得到了清晰且一致的定义。\n\n问题在于，对于每个患者特异性参数集，要找出四种已定义的给药方案中哪一种能够最小化归一化累积肿瘤负荷 $A$。这需要为每个方案求解一个常微分方程（ODE），然后对得到的肿瘤群体轨迹进行积分评估。\n\n控制肿瘤群体 $N(t)$ 的常微分方程为：\n$$\n\\dot N(t) = \\frac{dN}{dt} = r\\,N(t)\\left(1 - \\frac{N(t)}{K}\\right) - \\kappa\\,u(t)\\,N(t)\n$$\n初始条件为 $N(0) = N_0$。参数包括内禀增长率 $r$、承载能力 $K$、药物杀伤敏感性 $\\kappa$ 和初始肿瘤大小 $N_0$。函数 $u(t)$ 是随时间变化的化学疗法输注速率。\n\n目标是最小化归一化累积肿瘤负荷，这是一个定义如下的无量纲量：\n$$\nA[u] = \\frac{1}{T}\\int_0^T \\frac{N(t; u)}{K}\\,dt\n$$\n其中 $N(t; u)$ 是在控制方案 $u(t)$ 下，在时间范围 $[0, T]$ 内常微分方程的解。所有方案都必须遵守固定的总剂量预算 $B$，即 $\\int_0^T u(t)\\,dt = B$。\n\n需要比较的四种方案是：\n1.  **方案 $0$（节拍式）：**在整个时间范围内进行连续、恒定的输注。\n    $$\n    u_0(t) = \\begin{cases} B/T  \\text{for } t \\in [0, T] \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n2.  **方案 $1$（每周脉冲）：**在每周开始时进行短暂的高剂量输注。设周期为 $P_1 = 7$ 天。脉冲次数 $n_\\mathrm{w}$ 是满足 $k P_1  T$ 的非负整数 $k$ 的数量。\n    $$\n    u_1(t) = \\begin{cases} B/n_\\mathrm{w}  \\text{if } t \\in [kP_1, kP_1+1) \\text{ for some integer } k \\ge 0 \\text{ with } kP_1  T \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n3.  **方案 $2$（每两周脉冲）：**与每周脉冲类似，但周期为 $P_2 = 14$ 天。脉冲次数为 $n_\\mathrm{b}$。\n    $$\n    u_2(t) = \\begin{cases} B/n_\\mathrm{b}  \\text{if } t \\in [kP_2, kP_2+1) \\text{ for some integer } k \\ge 0 \\text{ with } kP_2  T \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n4.  **方案 $3$（前负荷）：**在治疗期开始时以高速率输注全部剂量。设 $d = \\min(3, T)$。\n    $$\n    u_3(t) = \\begin{cases} B/d  \\text{for } t \\in [0, d) \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n该常微分方程是一个伯努利方程，对于分段常数 $u(t)$ 可以解析求解。然而，数值方法更稳健、更通用，并且在处理复杂边界条件时不易出现实现错误。我们将采用高质量的数值常微分方程求解器。\n\n**数值积分策略：**\n解决方案的核心在于对每个方案的常微分方程进行数值积分。\n-   **ODE 求解器：**我们使用 `scipy.integrate.solve_ivp`，一个现代的自适应步长求解器。该函数非常适合处理系统潜在的刚性动态（例如，快速细胞杀伤后缓慢再生）。我们将其配置为产生密集输出，即解的连续插值，从而可以在任何时间点进行精确评估。\n-   **肿瘤灭绝：**问题规定，如果 $N(t)$ 达到零，它将保持为零。由于细胞群体 $N(t)$ 不能为负，且常微分方程确保 $N(t)$ 仅从正初始条件渐近趋近于零，我们将“达到灭绝”解释为一个实际阈值。我们将此阈值设为 $N(t)  1$ 个细胞，因为非整数的细胞群体不符合物理实际。`solve_ivp` 的 `events` 功能用于检测解 $N(t)$ 何时从上方穿过此阈值。当此事件发生时，积分在事件时间 $t_\\mathrm{ext}$ 终止。\n-   **目标函数计算：**$A$ 的积分使用 `scipy.integrate.quad` 计算。鉴于 `solve_ivp` 的密集输出，这能提供积分的高度精确评估。如果在 $t_\\mathrm{ext}  T$ 时发生灭绝事件，则积分仅计算到 $t_\\mathrm{ext}$，因为当 $t > t_\\mathrm{ext}$ 时 $N(t)=0$：\n    $$\n    A = \\frac{1}{TK} \\int_0^{t_\\mathrm{ext}} N(t)\\,dt\n    $$\n    其中，如果没有发生灭绝事件，则 $t_\\mathrm{ext} = T$。\n\n**算法步骤：**\n总体算法系统地评估每个案例和方案：\n1.  遍历五个参数集（测试用例）中的每一个。\n2.  对于每个案例，遍历四种给药方案（索引 $0$ 到 $3$）。\n3.  对于每种方案：\n    a. 根据方案的定义以及案例参数 $T$ 和 $B$ 构建相应的控制函数 $u(t)$。\n    b. 定义常微分方程的右侧函数，该函数包含特定的 $u(t)$。\n    c. 为 ODE 求解器定义一个终止事件，以处理 $N(t)  1$ 时的肿瘤灭绝。\n    d. 使用 `solve_ivp` 在 $[0, T]$ 上数值求解初值问题。\n    e. 使用 `quad` 对所得解进行积分，以计算目标函数 $A$。\n4.  在评估完给定案例的所有四种方案后，确定 $A$ 的最小值。\n5.  确定最优方案的索引。如果出现平局，即对于最佳方案 $|A_i - A_j| \\le 10^{-6}$，则根据问题的平局打破规则选择索引最小的方案。\n6.  收集所有测试用例的最优索引。\n7.  将最终结果格式化为用方括号括起来的逗号分隔列表。\n\n这种有原则且稳健的数值方法确保了对治疗方案的准确可靠比较，从而为每个患者特异性模型确定最佳策略。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the tumor growth ODE for various chemotherapy schedules to find the optimal one.\n    \"\"\"\n\n    test_cases = [\n        # (r, K, kappa, N0, T, B)\n        (0.03, 1e9, 0.002, 1e8, 42, 600),\n        (0.06, 1e9, 0.0015, 2e8, 42, 600),\n        (0.03, 1e9, 0.0005, 1e8, 42, 600),\n        (0.005, 1e9, 0.002, 3e8, 42, 600),\n        (0.03, 1e9, 0.002, 1e8, 42, 0),\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        r, K, kappa, N0, T, B = case\n        \n        # Define the four dosing schedules u(t)\n        schedules = []\n\n        # Schedule 0: Metronomic\n        def u0(t, T_loc=T, B_loc=B):\n            if 0 = t = T_loc:\n                return B_loc / T_loc if T_loc > 0 else 0\n            return 0\n        schedules.append(u0)\n\n        # Schedule 1: Weekly pulses\n        def u1(t, T_loc=T, B_loc=B):\n            if t  0 or t >= T_loc or T_loc = 0:\n                return 0\n            period = 7\n            # Number of pulses: non-negative integers k where k*period  T\n            num_pulses = math.floor((T_loc - 1e-9) / period) + 1\n            if num_pulses == 0: return 0\n            pulse_rate = B_loc / num_pulses\n            if (t / period) - math.floor(t / period)  (1 / period):\n                return pulse_rate\n            return 0\n        schedules.append(u1)\n        \n        # Schedule 2: Biweekly pulses\n        def u2(t, T_loc=T, B_loc=B):\n            if t  0 or t >= T_loc or T_loc = 0:\n                return 0\n            period = 14\n            num_pulses = math.floor((T_loc - 1e-9) / period) + 1\n            if num_pulses == 0: return 0\n            pulse_rate = B_loc / num_pulses\n            if (t / period) - math.floor(t / period)  (1 / period):\n                return pulse_rate\n            return 0\n        schedules.append(u2)\n        \n        # Schedule 3: Front-loaded\n        def u3(t, T_loc=T, B_loc=B):\n            d = min(3, T_loc)\n            if 0 = t  d:\n                return B_loc / d if d > 0 else 0\n            return 0\n        schedules.append(u3)\n\n        A_values = []\n        for u_func in schedules:\n            # Define the ODE system\n            def ode_func(t, y, r_loc, K_loc, kappa_loc, u_f):\n                N = y[0]\n                # Ensure N doesn't go below 0 for robustness\n                if N  0:\n                    N = 0\n                dN_dt = r_loc * N * (1 - N / K_loc) - kappa_loc * u_f(t) * N\n                return [dN_dt]\n\n            # Event function to detect tumor extinction (N  1 cell)\n            def extinction(t, y, *args):\n                return y[0] - 1\n            extinction.terminal = True\n            extinction.direction = -1\n\n            # Solve the ODE\n            sol = solve_ivp(\n                lambda t, y: ode_func(t, y, r, K, kappa, u_func),\n                (0, T),\n                [N0],\n                dense_output=True,\n                events=extinction,\n                method='RK45',\n                atol=1e-8,\n                rtol=1e-8\n            )\n\n            # Determine the integration end time\n            t_end = T\n            if sol.t_events and len(sol.t_events[0]) > 0:\n                t_end = sol.t_events[0][0]\n\n            # Calculate the cumulative burden using quad for accuracy\n            # Integrate the dense solution N(t)\n            integral_val, _ = quad(lambda t: sol.sol(t)[0], 0, t_end)\n            \n            # Calculate normalized cumulative burden A\n            A = (1 / (T * K)) * integral_val if T > 0 else 0.\n            A_values.append(A)\n\n        # Find the best schedule index with tie-breaking\n        min_A = min(A_values)\n        \n        # Find all indices that are close to the minimum value\n        tied_indices = np.where(np.isclose(A_values, min_A, rtol=0, atol=1e-6))[0]\n        \n        # Choose the one with the smallest index\n        best_index = np.min(tied_indices)\n        final_results.append(best_index)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```"
        }
    ]
}