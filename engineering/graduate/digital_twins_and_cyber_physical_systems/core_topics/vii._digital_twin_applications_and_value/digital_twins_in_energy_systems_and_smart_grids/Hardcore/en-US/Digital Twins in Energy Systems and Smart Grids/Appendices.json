{
    "hands_on_practices": [
        {
            "introduction": "A core function of a smart grid's digital twin is to optimize operations for economic efficiency. This exercise simulates this task through economic dispatch, a fundamental problem of allocating power generation among different units to meet system demand at the lowest possible cost. By implementing an algorithm based on the equal incremental cost criterion, you will gain hands-on experience with the constrained optimization methods that enable a digital twin to make real-time, cost-effective decisions. ",
            "id": "4216903",
            "problem": "A digital twin of a smart grid aggregator performs steady-state economic dispatch for a set of thermal generators modeled by quadratic fuel cost functions. The digital twin maintains the real power balance constraint between supply and demand and enforces generator operating limits. Consider three generators indexed by $i \\in \\{1,2,3\\}$, each with a convex quadratic cost function $C_i(P_i) = a_i + b_i P_i + c_i P_i^2$ and operating limits $P_i^{\\min} \\le P_i \\le P_i^{\\max}$, where $P_i$ is the real power output in megawatts (MW), $a_i$ is the fixed hourly cost in dollars per hour ($/\\text{h}$), $b_i$ is the linear cost coefficient in dollars per megawatt-hour ($/(\\text{MW} \\cdot \\text{h})$), and $c_i$ is the quadratic cost coefficient in dollars per megawatt-squared hour ($/(\\text{MW}^2 \\cdot \\text{h})$). The system load $P_D$ (in MW) must be exactly met by the sum of generator outputs. Transmission losses are neglected, yielding the single equality constraint $\\sum_{i=1}^{3} P_i = P_D$.\n\nThe fundamental base for this problem is:\n- The physical power balance law $\\sum_{i=1}^{3} P_i = P_D$ in steady state.\n- Convexity of $C_i(P_i)$ for each generator due to $c_i > 0$, which implies a unique global minimizer of the economic dispatch objective when feasible.\n- The Karush-Kuhn-Tucker (KKT) conditions for convex optimization, comprising stationarity, primal feasibility, dual feasibility, and complementary slackness, applied to the constrained minimization of $\\sum_{i=1}^{3} C_i(P_i)$ subject to the equality constraint and bound constraints.\n\nYour task is to write a complete, runnable program that, for each test case, computes the economic dispatch setpoints $P_1$, $P_2$, and $P_3$ (in MW) that minimize the total cost $\\sum_{i=1}^{3} C_i(P_i)$ subject to $\\sum_{i=1}^{3} P_i = P_D$ and $P_i^{\\min} \\le P_i \\le P_i^{\\max}$. If the load is infeasible (i.e., $P_D < \\sum_{i=1}^{3} P_i^{\\min}$ or $P_D > \\sum_{i=1}^{3} P_i^{\\max}$), the program must return a boolean indicating infeasibility.\n\nThe program must implement a principled algorithm derived from the fundamental base and must not rely on ad hoc shortcuts. The computed outputs for feasible cases must be floats rounded to three decimal places and represent power in MW and total cost in dollars per hour ($/\\text{h}$). No angles are involved in this problem. For any infeasible test case, the program must output the boolean $false$ instead of numerical results.\n\nUse the following test suite with specified parameter values:\n- Test case $1$ (general feasible case with interior solution expected):\n  - Generator $1$: $a_1 = 100$, $b_1 = 18$, $c_1 = 0.035$, $P_1^{\\min} = 40$, $P_1^{\\max} = 200$.\n  - Generator $2$: $a_2 = 120$, $b_2 = 16$, $c_2 = 0.040$, $P_2^{\\min} = 30$, $P_2^{\\max} = 150$.\n  - Generator $3$: $a_3 = 150$, $b_3 = 20$, $c_3 = 0.030$, $P_3^{\\min} = 50$, $P_3^{\\max} = 180$.\n  - Load: $P_D = 320$.\n- Test case $2$ (boundary case at minimum aggregate output):\n  - Same generators as test case $1$.\n  - Load: $P_D = 120$ (equals $\\sum_{i=1}^{3} P_i^{\\min}$).\n- Test case $3$ (boundary case at maximum aggregate output):\n  - Same generators as test case $1$.\n  - Load: $P_D = 530$ (equals $\\sum_{i=1}^{3} P_i^{\\max}$).\n- Test case $4$ (infeasible high load):\n  - Same generators as test case $1$.\n  - Load: $P_D = 600$ (exceeds $\\sum_{i=1}^{3} P_i^{\\max}$).\n- Test case $5$ (near-minimum feasible case where some generators may bind at lower limits):\n  - Same generators as test case $1$.\n  - Load: $P_D = 160$.\n\nOutput specification:\n- For each feasible test case, return a list $[P_1, P_2, P_3, \\text{total\\_cost}]$ where $P_1$, $P_2$, and $P_3$ are in MW and $\\text{total\\_cost}$ is in $/h$, all rounded to three decimal places.\n- For each infeasible test case, return the boolean $false$.\n- Your program should produce a single line of output containing the aggregated results of all test cases as a comma-separated list enclosed in square brackets, for example, $[result_1, result_2, \\dots]$, where each $result_k$ is either a list as specified or the boolean $false$.",
            "solution": "The posed problem is a classic, well-posed, and scientifically grounded problem in power systems engineering known as Economic Dispatch. It is a constrained optimization problem, and its validity is confirmed based on the following analysis. All data required for a unique solution are provided, the cost functions are convex, and the constraints are linear, which guarantees a unique global minimum when a feasible solution exists. The problem is free of contradictions, ambiguities, and factual errors. We may therefore proceed with a formal solution.\n\nThe objective is to minimize the total generation cost, $J$, which is the sum of the individual generator costs:\n$$\n\\text{Minimize } J = \\sum_{i=1}^{3} C_i(P_i) = \\sum_{i=1}^{3} (a_i + b_i P_i + c_i P_i^2)\n$$\nsubject to two types of constraints:\n\n1.  **Power Balance Constraint**: The total power generated must exactly meet the system load demand, $P_D$. Transmission losses are neglected, yielding the equality constraint:\n    $$\n    \\sum_{i=1}^{3} P_i = P_D\n    $$\n\n2.  **Generator Operating Limits**: Each generator $i$ has a minimum and maximum power output, forming a set of inequality constraints (box constraints):\n    $$\n    P_i^{\\min} \\le P_i \\le P_i^{\\max} \\quad \\text{for } i \\in \\{1, 2, 3\\}\n    $$\n\nThis is a convex optimization problem because the objective function is a sum of convex quadratic functions (since all $c_i > 0$), and the constraints define a convex feasible region. The solution can be systematically found by applying the Karush-Kuhn-Tucker (KKT) conditions.\n\nWe form the Lagrangian function, $\\mathcal{L}$, which incorporates the objective function and all constraints:\n$$\n\\mathcal{L} = \\sum_{i=1}^{3} C_i(P_i) + \\lambda \\left(P_D - \\sum_{i=1}^{3} P_i\\right) + \\sum_{i=1}^{3} \\mu_i (P_i - P_i^{\\max}) + \\sum_{i=1}^{3} \\nu_i (P_i^{\\min} - P_i)\n$$\nwhere $\\lambda$ is the Lagrange multiplier for the power balance equality constraint, and $\\mu_i$ and $\\nu_i$ are the KKT multipliers for the upper and lower bound inequality constraints, respectively. The term $\\lambda$ has a crucial economic interpretation as the system's incremental cost of energy, often called the system marginal price, in units of dollars per megawatt-hour ($/(\\text{MW} \\cdot \\text{h})$).\n\nThe first-order necessary condition for optimality (stationarity) is found by setting the partial derivative of the Lagrangian with respect to each decision variable $P_i$ to zero:\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial P_i} = \\frac{dC_i(P_i)}{dP_i} - \\lambda + \\mu_i - \\nu_i = 0\n$$\nSince $\\frac{dC_i}{dP_i} = b_i + 2 c_i P_i$, which is the incremental cost ($IC_i$) of generator $i$, we have:\n$$\nIC_i(P_i) = b_i + 2 c_i P_i = \\lambda - \\mu_i + \\nu_i\n$$\nThe KKT conditions also include primal feasibility (the original constraints must be met), dual feasibility ($\\mu_i \\ge 0$, $\\nu_i \\ge 0$), and complementary slackness ($\\mu_i (P_i - P_i^{\\max}) = 0$ and $\\nu_i (P_i^{\\min} - P_i) = 0$).\n\nThese conditions lead to a clear dispatch logic:\n- If a generator operates strictly within its limits ($P_i^{\\min} < P_i < P_i^{\\max}$), then its multipliers $\\mu_i$ and $\\nu_i$ must be zero. This simplifies the stationarity condition to $IC_i(P_i) = \\lambda$. This is the \"equal incremental cost criterion\": all generators not at their limits must operate at the same incremental cost, equal to the system marginal price $\\lambda$.\n- If a generator is at its maximum limit ($P_i = P_i^{\\max}$), then $\\nu_i = 0$ and $\\mu_i \\ge 0$, which implies $IC_i(P_i^{\\max}) \\le \\lambda$.\n- If a generator is at its minimum limit ($P_i = P_i^{\\min}$), then $\\mu_i = 0$ and $\\nu_i \\ge 0$, which implies $IC_i(P_i^{\\min}) \\ge \\lambda$.\n\nThis framework provides a principled algorithm for finding the optimal dispatch. The core of the problem is to find the single value of $\\lambda$ that causes the sum of the resulting power outputs to exactly match the load $P_D$.\n\n**Algorithm: Lambda-Iteration using Bisection Search**\n\n1.  **Feasibility Check**: First, we verify if the load $P_D$ is serviceable.\n    - Calculate total minimum capacity: $P_{\\text{total}}^{\\min} = \\sum_{i=1}^{3} P_i^{\\min}$.\n    - Calculate total maximum capacity: $P_{\\text{total}}^{\\max} = \\sum_{i=1}^{3} P_i^{\\max}$.\n    - If $P_D < P_{\\text{total}}^{\\min}$ or $P_D > P_{\\text{total}}^{\\max}$, no feasible solution exists. The problem is declared infeasible.\n\n2.  **Iterative Search for $\\lambda$**: For a feasible load, we must find the optimal $\\lambda$. We can express each $P_i$ as a function of $\\lambda$ and the generator limits. From $b_i + 2 c_i P_i = \\lambda$, we get an unconstrained power $P_i^{\\text{unconstrained}} = (\\lambda - b_i) / (2c_i)$. Accounting for limits, the actual dispatch is:\n    $$\n    P_i(\\lambda) = \\max(P_i^{\\min}, \\min(P_i^{\\max}, \\frac{\\lambda - b_i}{2c_i}))\n    $$\n    The goal is to solve the equation $f(\\lambda) = \\sum_{i=1}^{3} P_i(\\lambda) - P_D = 0$. Since $f(\\lambda)$ is a monotonically non-decreasing function of $\\lambda$, we can use a robust numerical method like bisection search to find its root.\n    a.  **Establish Search Bounds**: We need a search interval $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ for $\\lambda$. A safe, sufficiently wide range (e.g., $[0, 1000]$) can be chosen, as the algorithm will converge regardless.\n    b.  **Iterate**: The bisection method proceeds by repeatedly halving the search interval:\n        i.  Calculate the midpoint $\\lambda_{\\text{mid}} = (\\lambda_{\\text{low}} + \\lambda_{\\text{high}}) / 2$.\n        ii. Calculate the total power dispatched for this $\\lambda_{\\text{mid}}$: $P_{\\text{total}} = \\sum_{i=1}^{3} P_i(\\lambda_{\\text{mid}})$.\n        iii. If $P_{\\text{total}} < P_D$, it means our incremental cost $\\lambda_{\\text{mid}}$ is too low to incentivize enough generation. We update $\\lambda_{\\text{low}} = \\lambda_{\\text{mid}}$.\n        iv. If $P_{\\text{total}} > P_D$, our $\\lambda_{\\text{mid}}$ is too high. We update $\\lambda_{\\text{high}} = \\lambda_{\\text{mid}}$.\n    c.  **Termination**: The iteration continues for a fixed number of steps or until the interval $[\\lambda_{\\text{low}}, \\lambda_{\\text{high}}]$ is sufficiently small, guaranteeing a precise value for $\\lambda$.\n\n3.  **Final Calculation**: Once the optimal $\\lambda$ is found, the final dispatch for each generator, $[P_1, P_2, P_3]$, is calculated using the $P_i(\\lambda)$ formula. The total minimum cost is then computed by substituting these power values back into the sum of cost functions, $\\sum C_i(P_i)$. The results are then rounded as specified.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the economic dispatch problem for all test cases.\n    \"\"\"\n\n    # Generator parameters: (a, b, c, P_min, P_max)\n    gen_params = [\n        (100, 18, 0.035, 40, 200),  # Gen 1\n        (120, 16, 0.040, 30, 150),  # Gen 2\n        (150, 20, 0.030, 50, 180)   # Gen 3\n    ]\n\n    # Test cases: Load P_D in MW\n    test_cases_pd = [320, 120, 530, 600, 160]\n\n    results = []\n    for p_d in test_cases_pd:\n        result = calculate_dispatch(gen_params, p_d)\n        results.append(result)\n\n    # Format the final output string\n    formatted_results = []\n    for res in results:\n        if isinstance(res, bool):\n            formatted_results.append(str(res).lower())\n        else:\n            # Format list to string '[v1, v2, ...]' without extra spaces\n            formatted_list = f\"[{','.join(f'{v:.3f}' for v in res)}]\"\n            formatted_results.append(formatted_list)\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_dispatch(generators, p_d):\n    \"\"\"\n    Calculates the economic dispatch for a set of generators and a given load.\n\n    Args:\n        generators (list of tuples): Each tuple contains (a, b, c, p_min, p_max).\n        p_d (float): The total load demand in MW.\n\n    Returns:\n        list: A list [P1, P2, P3, total_cost] for a feasible solution, \n              rounded to three decimal places.\n        bool: False if the load is infeasible.\n    \"\"\"\n    p_mins = np.array([g[3] for g in generators])\n    p_maxs = np.array([g[4] for g in generators])\n    \n    p_total_min = np.sum(p_mins)\n    p_total_max = np.sum(p_maxs)\n\n    # Step 1: Feasibility Check\n    if not (p_total_min <= p_d <= p_total_max):\n        return False\n\n    # Special boundary cases for efficiency\n    if p_d == p_total_min:\n        powers = p_mins\n    elif p_d == p_total_max:\n        powers = p_maxs\n    else:\n        # Step 2: Iterative Search for lambda using Bisection\n        b_coeffs = np.array([g[1] for g in generators])\n        c_coeffs = np.array([g[2] for g in generators])\n        \n        lambda_low = 0.0\n        lambda_high = 200.0  # A sufficiently large upper bound for lambda\n        tolerance = 1e-7\n        max_iterations = 100\n\n        for _ in range(max_iterations):\n            lambda_mid = (lambda_low + lambda_high) / 2.0\n            \n            # Calculate power from each generator for the current lambda\n            # P_i = (lambda - b_i) / (2 * c_i)\n            # Clip is used to enforce generator limits P_min <= P_i <= P_max\n            current_powers = np.clip((lambda_mid - b_coeffs) / (2 * c_coeffs), p_mins, p_maxs)\n            \n            power_total = np.sum(current_powers)\n            power_mismatch = power_total - p_d\n            \n            if abs(power_mismatch) < tolerance:\n                break\n            \n            if power_mismatch < 0:\n                lambda_low = lambda_mid\n            else:\n                lambda_high = lambda_mid\n        \n        final_lambda = (lambda_low + lambda_high) / 2.0\n        powers = np.clip((final_lambda - b_coeffs) / (2 * c_coeffs), p_mins, p_maxs)\n\n    # Step 3: Final Calculation\n    total_cost = 0.0\n    for i, p_i in enumerate(powers):\n        a, b, c, _, _ = generators[i]\n        total_cost += a + b * p_i + c * p_i**2\n        \n    return [powers[0], powers[1], powers[2], total_cost]\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond routine optimization, a digital twin must ensure the grid's resilience against unexpected failures. This practice delves into contingency analysis, where the digital twin simulates the impact of losing a critical component, like a transmission line. You will apply a practical, two-stage methodology that combines a fast but approximate DC power flow screening with a more precise AC power flow refinement, a technique widely used to rapidly identify and validate potential overloads. ",
            "id": "4217031",
            "problem": "A utility operates a three-bus segment of a smart grid with a high-fidelity digital twin (a virtual replica driven by Phasor Measurement Unit (PMU) data). The digital twin supports contingency analysis by rapidly screening potential line overloads using the Direct Current (DC) power flow approximation and then refining flagged cases with Alternating Current (AC) power flow checks that leverage measured voltage magnitudes.\n\nConsider buses labeled $1$, $2$, and $3$, with bus $3$ serving as the slack bus (reference angle). The network consists of lossless lines with series reactances $X_{12}$, $X_{23}$, and $X_{13}$ and no shunt elements. The system base is 100 MVA. The digital twin reports pre-contingency net real power injections (in per unit on the 100 MVA base) of $P_{1} = 0.6$, $P_{2} = -0.1$, and $P_{3}$ balancing the remainder. The line parameters are:\n- $X_{12} = 0.1$ (so $b_{12} = 1/X_{12} = 10$),\n- $X_{23} = 0.2$ (so $b_{23} = 1/X_{23} = 5$),\n- $X_{13} = 0.125$ (so $b_{13} = 1/X_{13} = 8$).\n\nThe thermal limit of line $(1,2)$ is $55$ MW. The utility considers the single contingency of tripping line $(1,3)$.\n\nStarting from the AC real power flow on a lossless line $(i,j)$,\n$$\nP_{ij} = V_{i} V_{j} |Y_{ij}| \\sin(\\theta_{i} - \\theta_{j}),\n$$\nand the nodal real power balance,\n$$\nP_{i} = \\sum_{j \\in \\mathcal{N}(i)} V_{i} V_{j} |Y_{ij}| \\sin(\\theta_{i} - \\theta_{j}),\n$$\nderive a fast screening method using the DC power flow approximation—namely, $V_{i} \\approx 1$, $\\sin(\\theta_{i} - \\theta_{j}) \\approx \\theta_{i} - \\theta_{j}$, lines are purely reactive so $|Y_{ij}| = b_{ij} = 1/X_{ij}$—to compute the post-contingency bus voltage angles and identify whether line $(1,2)$ is likely to violate its limit. Then, perform an AC refinement using the digital twin’s measured post-contingency voltage magnitudes at buses $1$ and $2$, namely $V_{1} = 0.98$ and $V_{2} = 1.02$, together with the DC-computed angle difference for the tripped topology. Use\n$$\nP_{12}^{\\mathrm{AC}} = V_{1} V_{2} b_{12} \\sin(\\theta_{1} - \\theta_{2})\n$$\nfor the refined check.\n\nProvide the final AC-refined post-contingency real power flow on line $(1,2)$ expressed in MW, and round your answer to four significant figures. Assume bus $3$ angle is $0$ in the DC solution and that the DC angles computed for the tripped topology are sufficiently accurate to use in the AC refinement’s sine evaluation.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, objective, and complete. All data and conditions appear consistent with established principles of power system analysis. The problem describes a realistic scenario for a digital twin application in contingency analysis, providing all necessary parameters and assumptions to derive a unique solution. The problem is therefore deemed valid.\n\nThe solution proceeds in two stages as requested: first, a fast screening using the Direct Current (DC) power flow approximation to compute post-contingency bus voltage angles, followed by a refined power flow calculation using the Alternating Current (AC) formula with measured voltage magnitudes.\n\nFirst, we establish the DC power flow model from the given AC power flow equations. The AC real power flow on a lossless line $(i,j)$ is given by\n$$\nP_{ij} = V_{i} V_{j} |Y_{ij}| \\sin(\\theta_{i} - \\theta_{j})\n$$\nThe DC approximation relies on three assumptions for a high-voltage transmission network:\n1.  Voltage magnitudes are approximately nominal: $V_{i} \\approx 1$ p.u. for all buses $i$.\n2.  The angle difference across lines is small, so $\\sin(\\theta_{i} - \\theta_{j}) \\approx \\theta_{i} - \\theta_{j}$ (angles in radians).\n3.  Transmission lines are predominantly reactive, so line impedance is $Z_{ij} = jX_{ij}$ and the line admittance magnitude is $|Y_{ij}| = 1/X_{ij} = b_{ij}$, where $b_{ij}$ is the line susceptance.\n\nApplying these approximations yields the DC power flow formula for a line:\n$$\nP_{ij} \\approx (1)(1) b_{ij} (\\theta_{i} - \\theta_{j}) = b_{ij}(\\theta_{i} - \\theta_{j})\n$$\nThe nodal real power balance for bus $i$ is $P_{i} = \\sum_{j} P_{ij}$, which becomes:\n$$\nP_{i} \\approx \\sum_{j} b_{ij}(\\theta_{i} - \\theta_{j})\n$$\nThis forms a system of linear equations that can be written in matrix form as $P = B \\theta$, where $P$ is the vector of nodal power injections, $B$ is the susceptance matrix of the network, and $\\theta$ is the vector of bus voltage angles.\n\nThe problem specifies a contingency where line $(1,3)$ is tripped. We must analyze the post-contingency system. The power injections at the non-slack buses ($1$ and $2$) are assumed to remain constant at their pre-contingency values: $P_{1} = 0.6$ p.u. and $P_{2} = -0.1$ p.u. Bus $3$ is the slack bus, so its angle is the reference, $\\theta_{3} = 0$.\n\nIn the post-contingency network, line $(1,3)$ is removed. The remaining connections are line $(1,2)$ with $X_{12} = 0.1$ p.u. ($b_{12} = 10$ p.u.) and line $(2,3)$ with $X_{23} = 0.2$ p.u. ($b_{23} = 5$ p.u.). We construct the reduced susceptance matrix $B'$ for the non-slack buses ($1$ and $2$).\n\nThe elements of the $B'$ matrix are:\n$B'_{11} = \\sum_{j \\neq 1} b_{1j} = b_{12} = 10$\n$B'_{22} = \\sum_{j \\neq 2} b_{2j} = b_{21} + b_{23} = b_{12} + b_{23} = 10 + 5 = 15$\n$B'_{12} = B'_{21} = -b_{12} = -10$\n\nThe DC power flow matrix equation for the post-contingency state is:\n$$\n\\begin{pmatrix} P_{1} \\\\ P_{2} \\end{pmatrix} = B' \\begin{pmatrix} \\theta_{1} \\\\ \\theta_{2} \\end{pmatrix}\n$$\nSubstituting the known values:\n$$\n\\begin{pmatrix} 0.6 \\\\ -0.1 \\end{pmatrix} = \\begin{pmatrix} 10 & -10 \\\\ -10 & 15 \\end{pmatrix} \\begin{pmatrix} \\theta_{1} \\\\ \\theta_{2} \\end{pmatrix}\n$$\nTo solve for the angles $\\theta_{1}$ and $\\theta_{2}$, we find the inverse of the $B'$ matrix. The determinant is $\\det(B') = (10)(15) - (-10)(-10) = 150 - 100 = 50$.\nThe inverse matrix is:\n$$\n(B')^{-1} = \\frac{1}{50} \\begin{pmatrix} 15 & 10 \\\\ 10 & 10 \\end{pmatrix} = \\begin{pmatrix} 0.3 & 0.2 \\\\ 0.2 & 0.2 \\end{pmatrix}\n$$\nNow, we can solve for the angle vector:\n$$\n\\begin{pmatrix} \\theta_{1} \\\\ \\theta_{2} \\end{pmatrix} = (B')^{-1} \\begin{pmatrix} P_{1} \\\\ P_{2} \\end{pmatrix} = \\begin{pmatrix} 0.3 & 0.2 \\\\ 0.2 & 0.2 \\end{pmatrix} \\begin{pmatrix} 0.6 \\\\ -0.1 \\end{pmatrix}\n$$\nCalculating the individual angles:\n$$\n\\theta_{1} = (0.3)(0.6) + (0.2)(-0.1) = 0.18 - 0.02 = 0.16 \\text{ rad}\n$$\n$$\n\\theta_{2} = (0.2)(0.6) + (0.2)(-0.1) = 0.12 - 0.02 = 0.10 \\text{ rad}\n$$\nThe post-contingency DC power flow on line $(1,2)$ is $P_{12}^{\\mathrm{DC}} = b_{12}(\\theta_{1} - \\theta_{2}) = 10(0.16 - 0.10) = 10(0.06) = 0.6$ p.u. On a $100$ MVA base, this is $0.6 \\times 100 = 60$ MW. Since this exceeds the thermal limit of $55$ MW, a more accurate AC refinement is warranted.\n\nFor the AC refinement, we use the provided formula and the digital twin's measured post-contingency voltage magnitudes, $V_{1} = 0.98$ p.u. and $V_{2} = 1.02$ p.u. We use the angle difference computed from the DC model, $\\Delta\\theta = \\theta_{1} - \\theta_{2} = 0.06$ rad, as specified.\nThe AC-refined power flow on line $(1,2)$ is:\n$$\nP_{12}^{\\mathrm{AC}} = V_{1} V_{2} b_{12} \\sin(\\theta_{1} - \\theta_{2})\n$$\nSubstituting the values:\n$$\nP_{12}^{\\mathrm{AC}} = (0.98)(1.02)(10) \\sin(0.06)\n$$\nFirst, calculate the product of voltages: $V_{1} V_{2} = 0.98 \\times 1.02 = 0.9996$.\nThe flow in per unit is:\n$$\nP_{12}^{\\mathrm{AC}}[\\text{p.u.}] = (0.9996)(10) \\sin(0.06) = 9.996 \\sin(0.06)\n$$\nUsing a calculator for $\\sin(0.06)$ (in radians):\n$$\n\\sin(0.06) \\approx 0.059964006\n$$\n$$\nP_{12}^{\\mathrm{AC}}[\\text{p.u.}] \\approx 9.996 \\times 0.059964006 \\approx 0.599400199\n$$\nTo express this value in MW, we multiply by the system base MVA:\n$$\nP_{12}^{\\mathrm{AC}}[\\mathrm{MW}] = P_{12}^{\\mathrm{AC}}[\\text{p.u.}] \\times 100 \\text{ MVA} \\approx 0.599400199 \\times 100 = 59.9400199 \\text{ MW}\n$$\nRounding the final answer to four significant figures, we get $59.94$ MW.",
            "answer": "$$\\boxed{59.94}$$"
        },
        {
            "introduction": "As digital twins increasingly incorporate complex machine learning models, ensuring their transparency and trustworthiness becomes paramount. This exercise introduces a powerful technique from explainable AI (XAI) to interpret the predictions of a surrogate model used for voltage monitoring. You will implement the calculation of Shapley values to attribute a model's prediction to individual system features, providing crucial insights into why the digital twin anticipates a potential voltage violation. ",
            "id": "4217006",
            "problem": "You are developing a Digital Twin (DT) of a distribution feeder in a smart grid, where the DT uses a surrogate model to predict the monitored bus voltage magnitude in per-unit (pu). In this cyber-physical context, you are asked to compute feature attributions for the surrogate model’s voltage limit predictions using Shapley values from cooperative game theory, and to interpret the operational implications. Start from fundamental definitions. Specifically, consider the following deterministic surrogate model that maps system features to the predicted voltage magnitude:\n$$\nf(\\mathbf{x}) = v_0 + s_1\\big(x_1 - b_1\\big) + s_2\\big(x_2 - b_2\\big) + s_3\\big(x_3 - b_3\\big) + s_4\\big(x_4 - b_4\\big) + s_{12}\\big(x_1 - b_1\\big)\\big(x_2 - b_2\\big)\n$$\nwhere $f(\\mathbf{x})$ is the voltage magnitude in per-unit, $\\mathbf{x} = [x_1,x_2,x_3,x_4]$ are the features, $\\mathbf{b} = [b_1,b_2,b_3,b_4]$ are the baseline feature values, $v_0$ is the baseline voltage magnitude at the monitored bus, $s_i$ are linear sensitivities, and $s_{12}$ is a bilinear interaction sensitivity capturing the interaction between the net load and distributed generation. The features are:\n- $x_1$: net load at the monitored node in kilowatts (kW),\n- $x_2$: photovoltaic distributed generation output in kilowatts (kW),\n- $x_3$: reactive power injection from a capacitor bank in kilovolt-amperes reactive (kVAr),\n- $x_4$: transformer tap position offset (dimensionless tap steps).\n\nUse the following scientifically plausible parameter values:\n- $v_0 = 1.00$ (pu),\n- $s_1 = -0.0002$ (pu per kW),\n- $s_2 = +0.00015$ (pu per kW),\n- $s_3 = +0.00005$ (pu per kVAr),\n- $s_4 = +0.01$ (pu per tap step),\n- $s_{12} = -1\\times 10^{-7}$ (pu per $\\mathrm{kW}^2$),\n- $\\mathbf{b} = [500,\\,100,\\,0,\\,0]$ with units aligned as above.\n\nDefine the operational voltage band with a lower limit $v_{\\mathrm{L}} = 0.95$ (pu) and an upper limit $v_{\\mathrm{U}} = 1.05$ (pu). A predicted voltage $f(\\mathbf{x})$ violates limits if $f(\\mathbf{x}) < v_{\\mathrm{L}}$ or $f(\\mathbf{x}) > v_{\\mathrm{U}}$.\n\nShapley values from cooperative game theory attribute the prediction difference $f(\\mathbf{x}) - f(\\mathbf{b})$ to each feature by averaging its marginal contribution over all coalitions of features. Formally define the coalition value using the surrogate model with missing features set to their baseline. Implement the exact Shapley computation from the definition by enumerating all coalitions and using the appropriate factorial weights for each coalition size.\n\nTest Suite:\nCompute Shapley values for the following feature vectors $\\mathbf{x}$, in the given order $[x_1,x_2,x_3,x_4]$ with units $[\\mathrm{kW},\\mathrm{kW},\\mathrm{kVAr},\\text{tap steps}]$:\n- Case $A$: $\\mathbf{x} = [450,\\,300,\\,200,\\,1]$,\n- Case $B$: $\\mathbf{x} = [700,\\,50,\\,0,\\,0]$,\n- Case $C$: $\\mathbf{x} = [500,\\,100,\\,0,\\,3]$,\n- Case $D$: $\\mathbf{x} = [500,\\,100,\\,0,\\,0]$,\n- Case $E$: $\\mathbf{x} = [400,\\,400,\\,500,\\,2]$.\n\nFor each case, compute:\n- the Shapley attribution vector $\\boldsymbol{\\phi} = [\\phi_1,\\phi_2,\\phi_3,\\phi_4]$ in per-unit (pu),\n- the predicted voltage $f(\\mathbf{x})$ in per-unit (pu),\n- the limit violation boolean where $f(\\mathbf{x}) < v_{\\mathrm{L}}$ or $f(\\mathbf{x}) > v_{\\mathrm{U}}$.\n\nExpress all Shapley values and predicted voltages in per-unit (pu), rounded to exactly six decimal places. The boolean must be expressed as a boolean value (either True or False). Your program should produce a single line of output containing the results as a comma-separated list of five sublists, one per case, where each sublist is formatted as:\n$$\n[\\phi_1,\\phi_2,\\phi_3,\\phi_4,f(\\mathbf{x}),\\text{violation}]\n$$\nFor example, the final output format must be:\n$$\n[[\\ldots],[\\ldots],[\\ldots],[\\ldots],[\\ldots]]\n$$\nwith no extra whitespace or text beyond this single line.\n\nDesign for coverage:\n- Case $A$ is a typical daytime scenario where photovoltaic generation and capacitive support may push voltage near or above the upper limit.\n- Case $B$ is a high load, low generation scenario testing near the lower bound.\n- Case $C$ isolates a dominant transformer tap operation effect.\n- Case $D$ is the baseline operating point to verify that Shapley values are zeros and the voltage equals the baseline.\n- Case $E$ is an extreme high-generation, high-reactive, reduced load scenario stressing the upper limit.\n\nYour implementation must be exact and general for $M = 4$ features as defined above, using the coalition enumeration definition. The output must follow the specified single-line format, with per-unit values rounded to six decimal places.",
            "solution": "The problem statement has been rigorously validated and is determined to be sound. It is scientifically grounded in the principles of power systems engineering and cooperative game theory, is mathematically well-posed, and provides a complete, unambiguous set of data and instructions. The task is to compute feature attributions for a given surrogate model of a smart grid component using the exact definition of Shapley values.\n\nThe core of the problem is to attribute the deviation of a predicted bus voltage from its baseline value to the contributing system features. This is a classic problem in model interpretability, here applied to a digital twin for a power distribution system.\n\nFirst, we define the components of the model as provided. The set of features, or players in the cooperative game, is $N = \\{1, 2, 3, 4\\}$. The surrogate model for the voltage magnitude $f(\\mathbf{x})$ is given by:\n$$\nf(\\mathbf{x}) = v_0 + \\sum_{i=1}^{4} s_i(x_i - b_i) + s_{12}(x_1 - b_1)(x_2 - b_2)\n$$\nwhere $\\mathbf{x} = [x_1, x_2, x_3, x_4]$ is the feature vector and $\\mathbf{b} = [b_1, b_2, b_3, b_4]$ is the vector of baseline feature values. Let us denote the deviation of each feature from its baseline as $\\delta_i = x_i - b_i$. The model can be written more compactly as:\n$$\nf(\\mathbf{x}) = v_0 + s_1\\delta_1 + s_2\\delta_2 + s_3\\delta_3 + s_4\\delta_4 + s_{12}\\delta_1\\delta_2\n$$\nThe baseline prediction is $f(\\mathbf{b}) = v_0$, as all $\\delta_i$ are zero when $\\mathbf{x} = \\mathbf{b}$. The total change in prediction to be attributed is $\\Delta f = f(\\mathbf{x}) - f(\\mathbf{b})$.\n\nThe Shapley value $\\phi_i$ for a feature $i$ is its average marginal contribution to all possible coalitions of features. A coalition is any subset $S$ of the set of all features $N$. The value of a coalition $S$, denoted $v(S)$, is defined as the model's prediction when only the features in $S$ are active (i.e., take their values from $\\mathbf{x}$), while features not in $S$ remain at their baseline values (from $\\mathbf{b}$). Let $\\mathbf{x}_S$ be a feature vector such that its $j$-th component is $x_j$ if $j \\in S$ and $b_j$ if $j \\notin S$. Then, $v(S) = f(\\mathbf{x}_S) - f(\\mathbf{b})$. The value of the empty coalition $v(\\emptyset)$ is $f(\\mathbf{b}) - f(\\mathbf{b}) = 0$.\n\nThe formula for the Shapley value of feature $i$ is:\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|! (|N| - |S| - 1)!}{|N|!} \\left[ v(S \\cup \\{i\\}) - v(S) \\right]\n$$\nHere, $|N|=4$. The term $v(S \\cup \\{i\\}) - v(S)$ is the marginal contribution of feature $i$ to the coalition $S$. The formula averages these marginal contributions over all possible coalitions $S$ that do not contain $i$, weighted by a combinatorial factor.\n\nTo implement this, we must create a computational procedure that strictly follows this definition. For each feature $i \\in \\{1, 2, 3, 4\\}$, we must iterate through all $2^{|N|-1} = 2^3 = 8$ subsets $S$ of the other features. For each such coalition $S$, we compute the value function $v(S)$ and $v(S \\cup \\{i\\})$.\n\nThe value function $v(C)$ for any coalition $C \\subseteq N$ is:\n$$\nv(C) = \\sum_{j \\in C} s_j \\delta_j + \\begin{cases} s_{12} \\delta_1 \\delta_2 & \\text{if } \\{1, 2\\} \\subseteq C \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nThe computational algorithm will proceed as follows:\n1. For each test case vector $\\mathbf{x}$, first calculate the deviations $\\delta_i = x_i - b_i$.\n2. Initialize the Shapley value vector $\\boldsymbol{\\phi} = [0, 0, 0, 0]$.\n3. For each feature $i \\in \\{1, 2, 3, 4\\}$:\n    a. Define the set of other features $N' = N \\setminus \\{i\\}$.\n    b. Iterate through all subsets $S \\subseteq N'$. This can be done by looping an integer from $0$ to $2^{3}-1$ and using its bit representation to form the coalition $S$.\n    c. For each $S$, calculate the marginal contribution $\\Delta_i(S) = v(S \\cup \\{i\\}) - v(S)$.\n    d. Calculate the weight $W(|S|) = \\frac{|S|! (3 - |S|)!}{4!}$.\n    e. Add the weighted contribution to the total for feature $i$: $\\phi_i = \\phi_i + W(|S|) \\times \\Delta_i(S)$.\n4. After iterating through all coalitions for all features, the vector $\\boldsymbol{\\phi}$ will contain the complete Shapley attributions.\n\nFor this specific polynomial model, it is possible to derive analytical expressions for the Shapley values. The contribution of linear terms is allocated entirely to the respective feature, while the contribution of interaction terms is divided equally among the interacting features. This yields:\n$$\n\\phi_1 = s_1\\delta_1 + \\frac{1}{2}s_{12}\\delta_1\\delta_2\n$$\n$$\n\\phi_2 = s_2\\delta_2 + \\frac{1}{2}s_{12}\\delta_1\\delta_2\n$$\n$$\n\\phi_3 = s_3\\delta_3\n$$\n$$\n\\phi_4 = s_4\\delta_4\n$$\nWhile these formulas offer a convenient way to verify the results, the problem explicitly requires an implementation based on coalition enumeration. The provided code will therefore perform this enumeration. The analytical result serves as an independent validation of the code's correctness.\n\nFinally, for each test case, we compute the predicted voltage $f(\\mathbf{x})$, the Shapley vector $\\boldsymbol{\\phi}$, and the boolean voltage limit violation, which is `True` if $f(\\mathbf{x}) < 0.95$ or $f(\\mathbf{x}) > 1.05$. All numerical results are rounded to six decimal places as required. The final output is a single-line string representation of a list containing the results for all five test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing Shapley values for a smart grid surrogate model.\n    \"\"\"\n\n    # Define model parameters and constants\n    params = {\n        'v0': 1.00,\n        's1': -0.0002,\n        's2': +0.00015,\n        's3': +0.00005,\n        's4': +0.01,\n        's12': -1e-7\n    }\n    b = np.array([500.0, 100.0, 0.0, 0.0]) # Baseline feature vector\n    v_L = 0.95\n    v_U = 1.05\n    M = 4 # Number of features\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([450.0, 300.0, 200.0, 1.0]),  # Case A\n        np.array([700.0, 50.0, 0.0, 0.0]),    # Case B\n        np.array([500.0, 100.0, 0.0, 3.0]),    # Case C\n        np.array([500.0, 100.0, 0.0, 0.0]),    # Case D\n        np.array([400.0, 400.0, 500.0, 2.0]),  # Case E\n    ]\n\n    def surrogate_model(x_vec: np.ndarray) -> float:\n        \"\"\"\n        Computes the predicted voltage using the surrogate model.\n        \n        Args:\n            x_vec: A numpy array of features [x1, x2, x3, x4].\n        \n        Returns:\n            The predicted voltage magnitude in per-unit.\n        \"\"\"\n        delta = x_vec - b\n        \n        term1 = params['s1'] * delta[0]\n        term2 = params['s2'] * delta[1]\n        term3 = params['s3'] * delta[2]\n        term4 = params['s4'] * delta[3]\n        term12 = params['s12'] * delta[0] * delta[1]\n        \n        return params['v0'] + term1 + term2 + term3 + term4 + term12\n\n    def calculate_shapley_values(x_vec: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Computes the exact Shapley values by enumerating all coalitions.\n        \n        Args:\n            x_vec: The feature vector for which to compute attributions.\n            \n        Returns:\n            A numpy array containing the Shapley values [phi1, phi2, phi3, phi4].\n        \"\"\"\n        \n        def value_function(coalition: list, current_x: np.ndarray) -> float:\n            \"\"\"\n            Calculates the value of a coalition of features.\n            v(S) = f(x_S) - f(b)\n            \"\"\"\n            x_S = np.copy(b)\n            for feature_idx in coalition:\n                x_S[feature_idx] = current_x[feature_idx]\n            \n            # Since f(b) = v0, the value is f(x_S) - v0.\n            return surrogate_model(x_S) - params['v0']\n\n        phis = np.zeros(M)\n        factorials = [math.factorial(i) for i in range(M + 1)]\n        \n        feature_indices = list(range(M))\n\n        for i in range(M):\n            shapley_i = 0.0\n            other_features = [j for j in feature_indices if j != i]\n            \n            for k in range(len(other_features) + 1):\n                for S_tuple in combinations(other_features, k):\n                    S = list(S_tuple)\n                    \n                    # Marginal contribution of feature i to coalition S\n                    # v(S U {i}) - v(S)\n                    marginal_contrib = value_function(S + [i], x_vec) - value_function(S, x_vec)\n                    \n                    # Weight for this coalition size\n                    s_cardinality = len(S)\n                    weight = (factorials[s_cardinality] * factorials[M - 1 - s_cardinality]) / factorials[M]\n                    \n                    shapley_i += weight * marginal_contrib\n                    \n            phis[i] = shapley_i\n            \n        return phis\n\n    results = []\n    for x_case in test_cases:\n        # Calculate Shapley values, predicted voltage, and violation status\n        phi_vector = calculate_shapley_values(x_case)\n        voltage = surrogate_model(x_case)\n        violation = not (v_L <= voltage <= v_U)\n        \n        # Format the results according to the specification\n        phi_str_list = [f\"{p:.6f}\" for p in phi_vector]\n        voltage_str = f\"{voltage:.6f}\"\n        violation_str = str(violation)\n        \n        sublist_items = phi_str_list + [voltage_str, violation_str]\n        sublist_str = f\"[{','.join(sublist_items)}]\"\n        results.append(sublist_str)\n\n    # Final print statement in the exact required format.\n    final_output_str = f\"[{','.join(results)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}