{
    "hands_on_practices": [
        {
            "introduction": "Digital twins for Vehicle-to-Everything (V2X) systems require high-fidelity models of communication latency to be effective. A critical component of this latency is the serialization delay, which is determined by the message size and the physical layer's transmission characteristics. This exercise  provides hands-on practice in calculating this fundamental delay from first principles of the IEEE 802.11p standard, building a concrete understanding of how application-level data design directly impacts real-time network performance.",
            "id": "4227915",
            "problem": "A city-scale digital twin of Vehicle-to-Everything (V2X) communications is being calibrated to predict end-to-end message latency for Intelligent Transportation Systems (ITS). Two safety-critical broadcast messages are considered: the Cooperative Awareness Message (CAM) and the Basic Safety Message (BSM). Both are transmitted over Institute of Electrical and Electronics Engineers 802.11p Orthogonal Frequency-Division Multiplexing (OFDM) at a fixed physical layer (PHY) rate. The goal is to quantify, from first principles, the end-to-end delay impact attributable solely to the difference in message size between CAM and BSM when all other delay components remain identical.\n\nAssume the following physically realistic and self-consistent conditions:\n- The PHY data rate is fixed at $R = 6\\ \\mathrm{Mb/s}$, with IEEE 802.11p OFDM parameters: each symbol duration is $T_{sym} = 8\\ \\mu\\mathrm{s}$ and each data symbol carries $N_{dbps} = 48$ payload bits.\n- The Physical Layer Convergence Protocol (PLCP) adds $s = 16$ service bits and $t = 6$ tail bits to every MAC Protocol Data Unit (MPDU).\n- Broadcast transmission is used (no acknowledgments), and channel access, interframe spaces, propagation, and processing delays are assumed equal for both messages; thus, the only difference in end-to-end delay arises from the serialization and symbol packing of the MPDU.\n- A constant overhead of $O = 60$ bytes is present in both messages (including Medium Access Control (MAC) header, Logical Link Control/Subnetwork Access Protocol (LLC/SNAP), Frame Check Sequence (FCS), and elliptic-curve digital signature), independent of the application payload type.\n- The CAM application payload size is $L_{\\mathrm{CAM}}^{app} = 300$ bytes, and the BSM application payload size is $L_{\\mathrm{BSM}}^{app} = 190$ bytes.\n\nLet $L_{\\mathrm{CAM}} = O + L_{\\mathrm{CAM}}^{app}$ and $L_{\\mathrm{BSM}} = O + L_{\\mathrm{BSM}}^{app}$ denote the MPDU lengths (in bytes) submitted to the PLCP for CAM and BSM, respectively. Using standard IEEE 802.11p OFDM symbol packing, the data field of an MPDU is transmitted in an integer number of OFDM symbols determined by the PLCP framing, and the serialization time is the product of that symbol count and $T_{sym}$.\n\nTask: Derive from the definitions of data rate and OFDM symbol packing the end-to-end delay impact attributable solely to the difference in message size, defined as the CAM serialization time minus the BSM serialization time. Express your final answer in milliseconds and round to four significant figures.",
            "solution": "The problem has been validated and is deemed scientifically grounded, well-posed, objective, and solvable. The provided parameters are consistent with the IEEE 802.11p standard for Vehicular Ad Hoc Networks (VANETs).\n\nThe objective is to determine the difference in serialization time between a Cooperative Awareness Message (CAM) and a Basic Safety Message (BSM). This difference, $\\Delta T$, is defined as the serialization time for CAM, $T_{\\mathrm{CAM}}$, minus the serialization time for BSM, $T_{\\mathrm{BSM}}$. The problem states that this delay difference arises solely from the serialization of the MAC Protocol Data Unit (MPDU) at the physical layer.\n\nThe serialization time for a packet in an IEEE 802.11p Orthogonal Frequency-Division Multiplexing (OFDM) system is determined by the number of OFDM symbols required to transmit the packet's bits. This process is governed by the Physical Layer Convergence Protocol (PLCP).\n\nFirst, let's establish the general formula for the serialization time, $T_{ser}$, of an MPDU of length $L$ bytes.\nThe total number of bits in the MPDU is $8L$.\nThe PLCP adds $s$ service bits and $t$ tail bits to the MPDU. The total number of bits to be transmitted in the data field of the PLCP frame is:\n$$N_{bits} = s + 8L + t$$\nThe given parameters are $s = 16$ bits and $t = 6$ bits.\n\nThese $N_{bits}$ are packed into OFDM symbols. Each data symbol carries $N_{dbps}$ payload bits. The number of symbols required, $N_{sym}$, must be an integer, sufficient to carry all $N_{bits}$. Therefore, we must use the ceiling function:\n$$N_{sym} = \\left\\lceil \\frac{N_{bits}}{N_{dbps}} \\right\\rceil = \\left\\lceil \\frac{s + 8L + t}{N_{dbps}} \\right\\rceil$$\nThe problem specifies $N_{dbps} = 48$ bits per symbol.\n\nThe total serialization time is the product of the number of symbols and the duration of each symbol, $T_{sym}$:\n$$T_{ser} = N_{sym} \\times T_{sym}$$\nThe symbol duration is given as $T_{sym} = 8\\ \\mu s$.\n\nNow, we apply this procedure to the CAM and BSM messages separately.\n\nFor the Cooperative Awareness Message (CAM):\nThe application payload size is $L_{\\mathrm{CAM}}^{app} = 300$ bytes.\nThe common overhead is $O = 60$ bytes.\nThe total MPDU length for CAM is:\n$$L_{\\mathrm{CAM}} = O + L_{\\mathrm{CAM}}^{app} = 60 + 300 = 360\\ \\text{bytes}$$\nThe total number of bits to be framed by the PLCP for the CAM is:\n$$N_{\\mathrm{bits, CAM}} = s + 8L_{\\mathrm{CAM}} + t = 16 + 8(360) + 6 = 16 + 2880 + 6 = 2902\\ \\text{bits}$$\nThe number of OFDM symbols required for the CAM is:\n$$N_{\\mathrm{sym, CAM}} = \\left\\lceil \\frac{2902}{48} \\right\\rceil = \\lceil 60.4583... \\rceil = 61\\ \\text{symbols}$$\nThe serialization time for the CAM is:\n$$T_{\\mathrm{CAM}} = N_{\\mathrm{sym, CAM}} \\times T_{sym} = 61 \\times 8\\ \\mu s = 488\\ \\mu s$$\n\nFor the Basic Safety Message (BSM):\nThe application payload size is $L_{\\mathrm{BSM}}^{app} = 190$ bytes.\nThe common overhead is $O = 60$ bytes.\nThe total MPDU length for BSM is:\n$$L_{\\mathrm{BSM}} = O + L_{\\mathrm{BSM}}^{app} = 60 + 190 = 250\\ \\text{bytes}$$\nThe total number of bits to be framed by the PLCP for the BSM is:\n$$N_{\\mathrm{bits, BSM}} = s + 8L_{\\mathrm{BSM}} + t = 16 + 8(250) + 6 = 16 + 2000 + 6 = 2022\\ \\text{bits}$$\nThe number of OFDM symbols required for the BSM is:\n$$N_{\\mathrm{sym, BSM}} = \\left\\lceil \\frac{2022}{48} \\right\\rceil = \\lceil 42.125 \\rceil = 43\\ \\text{symbols}$$\nThe serialization time for the BSM is:\n$$T_{\\mathrm{BSM}} = N_{\\mathrm{sym, BSM}} \\times T_{sym} = 43 \\times 8\\ \\mu s = 344\\ \\mu s$$\n\nFinally, the end-to-end delay impact attributable to the message size difference is the difference between the two serialization times:\n$$\\Delta T = T_{\\mathrm{CAM}} - T_{\\mathrm{BSM}} = 488\\ \\mu s - 344\\ \\mu s = 144\\ \\mu s$$\n\nThe problem requires the answer to be expressed in milliseconds (ms) and rounded to four significant figures.\n$$\\Delta T = 144\\ \\mu s = 144 \\times 10^{-3}\\ \\text{ms} = 0.144\\ \\text{ms}$$\nRounding to four significant figures, we get $0.1440$ ms.",
            "answer": "$$\\boxed{0.1440}$$"
        },
        {
            "introduction": "The safety and performance of applications like Cooperative Adaptive Cruise Control (CACC) are fundamentally limited by the timeliness of V2X communication. Any communication delay introduces a phase lag into the vehicle's control loop, which can erode stability margins and, in the worst case, cause unsafe oscillations. This practice  allows you to apply classical control theory to determine the maximum tolerable delay, $\\tau_{\\max}$, for a CACC system, thereby forging a crucial link between network Quality of Service (QoS) and cyber-physical system safety.",
            "id": "4227873",
            "problem": "A Cooperative Adaptive Cruise Control (CACC) follower in an Intelligent Transportation System uses Vehicle-to-Everything (V2X) communication to track the leader vehicle’s longitudinal velocity. The CACC controller is implemented over a cyber-physical digital twin that monitors and enforces communication constraints. The follower’s longitudinal dynamics are approximated by a first-order actuator followed by an integrator, modeled as the linear time-invariant plant\n$$\nP(s) = \\frac{1}{s\\left(1 + s T_a\\right)},\n$$\nwhere $T_a$ is a known actuator time constant. The velocity-tracking controller is a proportional-derivative (PD) compensator\n$$\nC(s) = k\\left(1 + s T_d\\right),\n$$\nwith gain $k$ and derivative time $T_d$. The V2X link introduces a communication delay $\\tau$, which enters the loop as a pure time-delay factor $\\exp(-s \\tau)$ multiplying the open-loop transfer function. Assume unity feedback for velocity tracking from the leader’s velocity to the follower’s velocity and that the loop, in the absence of delay, is minimum phase. The string stability requirement in this simplified setting is that the closed-loop inter-vehicle velocity transfer function exhibits no amplification of disturbances across the platoon, which is ensured if the closed-loop remains stable and does not produce gain peaking near the gain crossover.\n\nStarting from the base facts that a linear time delay contributes a frequency-dependent phase shift $-\\omega \\tau$ and that the Nyquist stability interpretation via phase margin quantifies the allowable additional phase lag before instability at the gain crossover frequency, use Nyquist reasoning to determine the maximum allowable communication delay $\\tau_{\\max}$ that preserves string stability for the following parameters:\n- $T_a = 0.2\\,\\mathrm{s}$,\n- $k = 1.5$,\n- $T_d = 0.3\\,\\mathrm{s}$.\n\nExpress your final answer in $\\mathrm{s}$ and round your answer to four significant figures.",
            "solution": "The problem requires determining the maximum allowable communication delay, $\\tau_{\\max}$, for a Cooperative Adaptive Cruise Control (CACC) system that preserves stability. The analysis will be conducted using the Nyquist stability criterion, specifically by relating the delay to the phase margin of the system.\n\nThe system consists of a plant $P(s)$, a controller $C(s)$, and a communication delay modeled as $\\exp(-s\\tau)$, arranged in a unity feedback configuration. The open-loop transfer function, $L(s)$, is given by the product of these components:\n$$L(s) = C(s)P(s)\\exp(-s\\tau)$$\n\nThe plant is given by $P(s) = \\frac{1}{s(1 + sT_a)}$ and the controller is $C(s) = k(1 + sT_d)$. Substituting the given parameter values, $T_a = 0.2\\,\\mathrm{s}$, $k = 1.5$, and $T_d = 0.3\\,\\mathrm{s}$, we first define the open-loop transfer function in the absence of delay, denoted as $L_0(s)$:\n$$L_0(s) = C(s)P(s) = \\frac{k(1 + sT_d)}{s(1 + sT_a)} = \\frac{1.5(1 + 0.3s)}{s(1 + 0.2s)}$$\n\nThe maximum allowable delay $\\tau_{\\max}$ corresponds to the delay that brings the system to the verge of instability. In the frequency domain, this occurs when the phase of the total open-loop system $L(j\\omega)$ reaches $-\\pi$ radians (or $-180^\\circ$) at the gain crossover frequency, $\\omega_{gc}$. The gain crossover frequency is defined as the frequency at which the magnitude of the open-loop transfer function without delay, $|L_0(j\\omega_{gc})|$, is equal to $1$. The delay term $\\exp(-j\\omega\\tau)$ has a unity magnitude for all frequencies and thus does not affect the gain crossover frequency.\n\nFirst, we find $\\omega_{gc}$ by solving $|L_0(j\\omega_{gc})| = 1$. The frequency response of $L_0(s)$ is:\n$$L_0(j\\omega) = \\frac{1.5(1 + 0.3j\\omega)}{j\\omega(1 + 0.2j\\omega)}$$\nThe magnitude is:\n$$|L_0(j\\omega)| = \\frac{1.5|1 + 0.3j\\omega|}{|j\\omega||1 + 0.2j\\omega|} = \\frac{1.5 \\sqrt{1^2 + (0.3\\omega)^2}}{\\omega \\sqrt{1^2 + (0.2\\omega)^2}}$$\nSetting the magnitude to $1$ at $\\omega = \\omega_{gc}$:\n$$\\frac{1.5 \\sqrt{1 + 0.09\\omega_{gc}^2}}{\\omega_{gc} \\sqrt{1 + 0.04\\omega_{gc}^2}} = 1$$\nSquaring both sides of the equation yields:\n$$(1.5)^2 (1 + 0.09\\omega_{gc}^2) = \\omega_{gc}^2 (1 + 0.04\\omega_{gc}^2)$$\n$$2.25 (1 + 0.09\\omega_{gc}^2) = \\omega_{gc}^2 + 0.04\\omega_{gc}^4$$\n$$2.25 + 0.2025\\omega_{gc}^2 = \\omega_{gc}^2 + 0.04\\omega_{gc}^4$$\nRearranging this into a standard polynomial form gives a quartic equation in $\\omega_{gc}$, which is quadratic in $\\omega_{gc}^2$:\n$$0.04\\omega_{gc}^4 + (1 - 0.2025)\\omega_{gc}^2 - 2.25 = 0$$\n$$0.04\\omega_{gc}^4 + 0.7975\\omega_{gc}^2 - 2.25 = 0$$\nLet $x = \\omega_{gc}^2$. The equation becomes $0.04x^2 + 0.7975x - 2.25 = 0$. We solve for $x$ using the quadratic formula, $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$:\n$$x = \\frac{-0.7975 \\pm \\sqrt{(0.7975)^2 - 4(0.04)(-2.25)}}{2(0.04)}$$\n$$x = \\frac{-0.7975 \\pm \\sqrt{0.63600625 + 0.36}}{0.08} = \\frac{-0.7975 \\pm \\sqrt{0.99600625}}{0.08}$$\nSince $x = \\omega_{gc}^2$ must be a positive real number, we take the positive root:\n$$x = \\frac{-0.7975 + \\sqrt{0.99600625}}{0.08} \\approx \\frac{-0.7975 + 0.9980011}{0.08} \\approx 2.506264$$\nThus, the gain crossover frequency is:\n$$\\omega_{gc} = \\sqrt{x} \\approx \\sqrt{2.506264} \\approx 1.583118\\,\\mathrm{rad/s}$$\n\nNext, we calculate the phase margin ($PM$) of the system without delay. The phase margin is the difference between the phase of $L_0(j\\omega_{gc})$ and $-\\pi$.\n$$PM = \\pi + \\angle L_0(j\\omega_{gc})$$\nThe phase of $L_0(j\\omega)$ is:\n$$\\angle L_0(j\\omega) = \\angle(1.5) + \\angle(1 + 0.3j\\omega) - \\angle(j\\omega) - \\angle(1 + 0.2j\\omega)$$\n$$\\angle L_0(j\\omega) = 0 + \\arctan(0.3\\omega) - \\frac{\\pi}{2} - \\arctan(0.2\\omega)$$\nAt $\\omega = \\omega_{gc} \\approx 1.583118\\,\\mathrm{rad/s}$:\n$$\\angle L_0(j\\omega_{gc}) = \\arctan(0.3 \\times 1.583118) - \\frac{\\pi}{2} - \\arctan(0.2 \\times 1.583118)$$\n$$\\angle L_0(j\\omega_{gc}) \\approx \\arctan(0.474935) - \\frac{\\pi}{2} - \\arctan(0.316624)$$\nIn radians, this is approximately:\n$$\\angle L_0(j\\omega_{gc}) \\approx 0.443195 - 1.570796 - 0.306509 \\approx -1.43411\\,\\mathrm{rad}$$\nThe phase margin is therefore:\n$$PM = \\pi + (-1.43411) \\approx 3.14159 - 1.43411 \\approx 1.70748\\,\\mathrm{rad}$$\n\nThe communication delay $\\exp(-s\\tau)$ introduces a phase lag of $\\phi_{delay} = \\omega\\tau$. The system becomes marginally stable when this additional phase lag at the gain crossover frequency is equal to the phase margin of the undelayed system.\n$$\\omega_{gc} \\tau_{\\max} = PM$$\nSolving for the maximum allowable delay, $\\tau_{\\max}$:\n$$\\tau_{\\max} = \\frac{PM}{\\omega_{gc}}$$\nSubstituting the calculated values:\n$$\\tau_{\\max} \\approx \\frac{1.70748\\,\\mathrm{rad}}{1.583118\\,\\mathrm{rad/s}} \\approx 1.078556\\,\\mathrm{s}$$\n\nRounding the result to four significant figures, we get $1.079\\,\\mathrm{s}$.",
            "answer": "$$\\boxed{1.079}$$"
        },
        {
            "introduction": "Efficiently managing a platoon of connected vehicles requires moving beyond single-vehicle controllers to a coordinated, system-level approach. Model Predictive Control (MPC) offers a powerful framework for this task, enabling the optimization of platoon behavior over a future time horizon while respecting numerous physical and safety constraints. This hands-on coding exercise  challenges you to formulate and solve a complete MPC problem for a vehicle platoon, translating high-level goals into a concrete, solvable convex optimization problem—a core skill for designing the next generation of intelligent transportation systems.",
            "id": "4227926",
            "problem": "Consider a longitudinal platoon of connected vehicles using Vehicle-to-Everything (V2X) communication within a cyber-physical system and its Digital Twin. The Digital Twin predicts the near-future trajectory of the platoon under a Model Predictive Control (MPC) policy. Each vehicle has jerk (time derivative of acceleration) as the control input. The objective is to derive a convex MPC formulation that respects acceleration, jerk, and inter-vehicle safety distance constraints, and to compute an optimal control sequence over a finite horizon.\n\nLet there be $N$ vehicles indexed by $i \\in \\{1, \\dots, N\\}$, in a single-lane platoon with vehicle $i=1$ as the leader. The discrete-time horizon is $k \\in \\{0, 1, \\dots, H\\}$ with time step $\\Delta t$. For vehicle $i$ at time step $k$, the state variables are position $x_{i,k}$ in $\\mathrm{m}$, velocity $v_{i,k}$ in $\\mathrm{m/s}$, and acceleration $a_{i,k}$ in $\\mathrm{m/s^2}$. The control input is jerk $j_{i,k}$ in $\\mathrm{m/s^3}$, applied during $[k\\Delta t, (k+1)\\Delta t)$.\n\nUse kinematic relations derived from fundamental definitions:\n- Velocity is the time derivative of position, $v = \\frac{dx}{dt}$, and acceleration is the time derivative of velocity, $a = \\frac{dv}{dt}$. Jerk is $j = \\frac{da}{dt}$.\n- Under piecewise-constant jerk over each step, the exact discrete update is:\n$$\na_{i,k+1} = a_{i,k} + \\Delta t \\, j_{i,k},\n$$\n$$\nv_{i,k+1} = v_{i,k} + \\Delta t \\, a_{i,k} + \\tfrac{1}{2} \\Delta t^2 \\, j_{i,k},\n$$\n$$\nx_{i,k+1} = x_{i,k} + \\Delta t \\, v_{i,k} + \\tfrac{1}{2} \\Delta t^2 \\, a_{i,k} + \\tfrac{1}{6} \\Delta t^3 \\, j_{i,k}.\n$$\n\nThe objective is to minimize a convex quadratic cost over the horizon:\n$$\nJ = \\sum_{k=1}^{H} \\sum_{i=1}^{N} \\left( w_v \\, (v_{i,k} - v_{\\mathrm{ref}})^2 + w_a \\, a_{i,k}^2 \\right) + \\sum_{k=0}^{H-1} \\sum_{i=1}^{N} w_j \\, j_{i,k}^2,\n$$\nwhere $v_{\\mathrm{ref}}$ is the desired speed (assumed constant), and $w_v$, $w_a$, $w_j$ are nonnegative weights.\n\nImpose the following constraints for all vehicles and steps:\n- Acceleration bounds: $-a_{\\max} \\le a_{i,k} \\le a_{\\max}$ for all $i$ and $k \\in \\{1, \\dots, H\\}$.\n- Jerk bounds: $-j_{\\max} \\le j_{i,k} \\le j_{\\max}$ for all $i$ and $k \\in \\{0, \\dots, H-1\\}$.\n- Nonnegative speed: $v_{i,k} \\ge 0$ for all $i$ and $k \\in \\{1, \\dots, H\\}$.\n- Safety distance using a time-headway policy: for followers $i \\in \\{2, \\dots, N\\}$ and all $k \\in \\{1, \\dots, H\\}$,\n$$\nx_{i-1,k} - x_{i,k} \\ge d_0 + T \\, v_{i,k},\n$$\nwhere $d_0$ is the standstill distance in $\\mathrm{m}$ and $T$ is the time headway in $\\mathrm{s}$.\n\nYou must:\n- Formulate the MPC by explicitly stating its decision variables, dynamics, and constraints as above.\n- Compute the optimal jerk sequence $\\{j_{i,k}\\}$ over the horizon for each of the provided test cases using numerical optimization.\n- Report, for each test case, the optimal objective value $J^\\star$ as a floating-point number. No physical unit is required for $J^\\star$.\n\nTest Suite:\nUse the following three parameter sets, where every number in the list is in its respective physical unit as specified above.\n\n- Case $1$ (nominal conditions):\n    - $N = 3$, $H = 5$, $\\Delta t = 0.2$.\n    - $v_{\\mathrm{ref}} = 22.0$.\n    - Initial states: $x_0 = [0.0, -35.0, -70.0]$, $v_0 = [20.0, 20.0, 20.0]$, $a_0 = [0.0, 0.0, 0.0]$.\n    - Constraints: $a_{\\max} = 3.0$, $j_{\\max} = 1.5$, $d_0 = 5.0$, $T = 1.2$.\n    - Weights: $w_v = 1.0$, $w_a = 0.1$, $w_j = 0.01$.\n\n- Case $2$ (tight safety distance and reduced jerk):\n    - $N = 3$, $H = 5$, $\\Delta t = 0.2$.\n    - $v_{\\mathrm{ref}} = 20.0$.\n    - Initial states: $x_0 = [0.0, -29.0, -58.0]$, $v_0 = [20.0, 20.0, 20.0]$, $a_0 = [0.0, 0.0, 0.0]$.\n    - Constraints: $a_{\\max} = 3.0$, $j_{\\max} = 1.0$, $d_0 = 5.0$, $T = 1.2$.\n    - Weights: $w_v = 1.0$, $w_a = 0.1$, $w_j = 0.01$.\n\n- Case $3$ (near-maximum initial accelerations and higher reference speed):\n    - $N = 3$, $H = 5$, $\\Delta t = 0.2$.\n    - $v_{\\mathrm{ref}} = 25.0$.\n    - Initial states: $x_0 = [0.0, -40.0, -80.0]$, $v_0 = [23.0, 21.0, 19.0]$, $a_0 = [2.5, 0.0, -1.0]$.\n    - Constraints: $a_{\\max} = 3.0$, $j_{\\max} = 1.5$, $d_0 = 5.0$, $T = 1.2$.\n    - Weights: $w_v = 1.0$, $w_a = 0.1$, $w_j = 0.01$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases, for example: $[J^\\star_{\\text{case 1}}, J^\\star_{\\text{case 2}}, J^\\star_{\\text{case 3}}]$. Each $J^\\star$ should be printed as a floating-point number. No angles or percentage signs are involved; no unit should be printed for $J^\\star$.",
            "solution": "The posed problem is scientifically sound, mathematically well-defined, and self-contained. It constitutes a standard optimal control problem for a multi-agent system, specifically a platoon of vehicles. The objective is to compute an optimal control sequence by minimizing a quadratic cost function subject to linear constraints over a finite time horizon. This structure is characteristic of a Model Predictive Control (MPC) formulation, which can be cast as a convex Quadratic Program (QP). A convex QP with a non-empty feasible region guarantees the existence of a unique global minimum, which makes the problem well-posed. We shall proceed with a formal derivation and numerical solution.\n\nThe MPC formulation is defined by its core components: the decision variables, the system dynamics, the objective function, and the constraints.\n\n**1. Decision Variables**\n\nThe control inputs to the system are the jerk values for each vehicle at each time step over the prediction horizon. The decision variable for the optimization is a single vector, $\\mathbf{u}$, that concatenates all these jerk values:\n$$\n\\mathbf{u} = [j_{1,0}, \\dots, j_{N,0}, j_{1,1}, \\dots, j_{N,1}, \\dots, j_{1,H-1}, \\dots, j_{N,H-1}]^T \\in \\mathbb{R}^{NH}\n$$\nHere, $N$ is the number of vehicles and $H$ is the length of the prediction horizon. The optimizer's task is to find the optimal vector $\\mathbf{u}^\\star$ that minimizes the objective function while satisfying all constraints.\n\n**2. System Dynamics**\n\nThe state of vehicle $i$ at discrete time step $k$ is given by the vector $\\mathbf{s}_{i,k} = [x_{i,k}, v_{i,k}, a_{i,k}]^T$. The problem provides the exact discrete-time update equations under the assumption of piecewise-constant jerk $j_{i,k}$ over the interval $[k\\Delta t, (k+1)\\Delta t)$. These can be expressed in a linear state-space form for each vehicle:\n$$\n\\mathbf{s}_{i,k+1} = \\mathbf{A}_d \\mathbf{s}_{i,k} + \\mathbf{B}_d j_{i,k}\n$$\nwhere the state transition matrix $\\mathbf{A}_d$ and the control matrix $\\mathbf{B}_d$ are:\n$$\n\\mathbf{A}_d = \\begin{pmatrix} 1 & \\Delta t & \\frac{1}{2} \\Delta t^2 \\\\ 0 & 1 & \\Delta t \\\\ 0 & 0 & 1 \\end{pmatrix}, \\quad \\mathbf{B}_d = \\begin{pmatrix} \\frac{1}{6} \\Delta t^3 \\\\ \\frac{1}{2} \\Delta t^2 \\\\ \\Delta t \\end{pmatrix}\n$$\nBy recursively applying this update rule from the given initial state $\\mathbf{s}_{i,0}$, any future state $\\mathbf{s}_{i,k}$ can be expressed as an affine function of the initial state and the control inputs $\\{j_{i,0}, \\dots, j_{i,k-1}\\}$. Consequently, every state variable ($x_{i,k}, v_{i,k}, a_{i,k}$) across the entire horizon is an affine function of the decision vector $\\mathbf{u}$.\n\n**3. Objective Function**\n\nThe objective is to minimize the quadratic cost function $J$:\n$$\nJ(\\mathbf{u}) = \\sum_{k=1}^{H} \\sum_{i=1}^{N} \\left( w_v \\, (v_{i,k}(\\mathbf{u}) - v_{\\mathrm{ref}})^2 + w_a \\, a_{i,k}(\\mathbf{u})^2 \\right) + \\sum_{k=0}^{H-1} \\sum_{i=1}^{N} w_j \\, j_{i,k}^2\n$$\nThe state variables $v_{i,k}$ and $a_{i,k}$ are functions of the decision vector $\\mathbf{u}$. Since these dependencies are affine, each term in the sum is a quadratic function of $\\mathbf{u}$. The total cost $J(\\mathbf{u})$ is therefore a quadratic function of $\\mathbf{u}$. Given that the weights $w_v, w_a, w_j$ are nonnegative and specifically $w_j > 0$ in the test cases, the objective function is strictly convex with respect to $\\mathbf{u}$.\n\n**4. Constraints**\n\nAll constraints must also be expressed as functions of the decision vector $\\mathbf{u}$.\n\n- **Jerk Constraints**: $-j_{\\max} \\le j_{i,k} \\le j_{\\max}$ for all $i$ and $k \\in \\{0, \\dots, H-1\\}$. These are simple box constraints on the elements of the decision vector $\\mathbf{u}$.\n\n- **Acceleration Constraints**: $-a_{\\max} \\le a_{i,k}(\\mathbf{u}) \\le a_{\\max}$ for $i \\in \\{1, \\dots, N\\}, k \\in \\{1, \\dots, H\\}$. Since $a_{i,k}(\\mathbf{u})$ is an affine function of $\\mathbf{u}$, these are a set of linear inequality constraints.\n\n- **Nonnegative Speed**: $v_{i,k}(\\mathbf{u}) \\ge 0$ for $i \\in \\{1, \\dots, N\\}, k \\in \\{1, \\dots, H\\}$. Similarly, since $v_{i,k}(\\mathbf{u})$ is an affine function of $\\mathbf{u}$, these are also linear inequality constraints.\n\n- **Safety Distance**: $x_{i-1,k}(\\mathbf{u}) - x_{i,k}(\\mathbf{u}) \\ge d_0 + T \\, v_{i,k}(\\mathbf{u})$ for followers $i \\in \\{2, \\dots, N\\}$ and $k \\in \\{1, \\dots, H\\}$. This can be rewritten as $x_{i-1,k}(\\mathbf{u}) - x_{i,k}(\\mathbf{u}) - T \\, v_{i,k}(\\mathbf{u}) - d_0 \\ge 0$. As $x_{i,k}$ and $v_{i,k}$ are affine in $\\mathbf{u}$, these too are linear inequality constraints on $\\mathbf{u}$.\n\n**5. Numerical Solution**\n\nThe problem is thus a strictly convex Quadratic Program (QP), characterized by a strictly convex quadratic objective and a set of linear constraints. Such problems have a unique global minimum. We will use the Sequential Least Squares Programming (SLSQP) algorithm, a general-purpose nonlinear optimization method available in the `SciPy` library. This approach is convenient as it does not require explicit construction of the large, sparse QP matrices ($\\mathbf{P}, \\mathbf{q}, \\mathbf{G}, \\mathbf{h}$). Instead, we provide the solver with functions that compute the objective value $J(\\mathbf{u})$ and the values of the constraint functions for a given decision vector $\\mathbf{u}$.\n\nThe process involves:\n1.  Defining a function that, given a control vector $\\mathbf{u}$, simulates the platoon dynamics over the horizon $H$ to compute the full state trajectories for all vehicles.\n2.  Defining the objective function $J(\\mathbf{u})$ which uses the simulated trajectories to calculate the total cost.\n3.  Defining a function that returns a vector of all inequality constraint values, which must be non-negative for a feasible solution.\n4.  Passing these functions, along with the box constraints on $\\mathbf{u}$, to the SLSQP solver to find the optimal control vector $\\mathbf{u}^\\star$ and the corresponding minimum cost $J^\\star = J(\\mathbf{u}^\\star)$.\n\nThis procedure is implemented for each of the specified test cases to find the optimal objective value.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the MPC problem for all test cases and prints the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Nominal conditions\n        {\n            \"N\": 3, \"H\": 5, \"dt\": 0.2, \"v_ref\": 22.0,\n            \"x0\": np.array([0.0, -35.0, -70.0]),\n            \"v0\": np.array([20.0, 20.0, 20.0]),\n            \"a0\": np.array([0.0, 0.0, 0.0]),\n            \"a_max\": 3.0, \"j_max\": 1.5, \"d0\": 5.0, \"T\": 1.2,\n            \"wv\": 1.0, \"wa\": 0.1, \"wj\": 0.01\n        },\n        # Case 2: Tight safety distance and reduced jerk\n        {\n            \"N\": 3, \"H\": 5, \"dt\": 0.2, \"v_ref\": 20.0,\n            \"x0\": np.array([0.0, -29.0, -58.0]),\n            \"v0\": np.array([20.0, 20.0, 20.0]),\n            \"a0\": np.array([0.0, 0.0, 0.0]),\n            \"a_max\": 3.0, \"j_max\": 1.0, \"d0\": 5.0, \"T\": 1.2,\n            \"wv\": 1.0, \"wa\": 0.1, \"wj\": 0.01\n        },\n        # Case 3: Near-maximum initial accelerations and higher reference speed\n        {\n            \"N\": 3, \"H\": 5, \"dt\": 0.2, \"v_ref\": 25.0,\n            \"x0\": np.array([0.0, -40.0, -80.0]),\n            \"v0\": np.array([23.0, 21.0, 19.0]),\n            \"a0\": np.array([2.5, 0.0, -1.0]),\n            \"a_max\": 3.0, \"j_max\": 1.5, \"d0\": 5.0, \"T\": 1.2,\n            \"wv\": 1.0, \"wa\": 0.1, \"wj\": 0.01\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        optimal_cost = solve_case(params)\n        results.append(optimal_cost)\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\n\ndef simulate(u, params):\n    \"\"\"\n    Simulates the platoon dynamics for a given control sequence (jerks).\n\n    Args:\n        u (np.ndarray): Flattened array of jerk controls of size (N*H).\n        params (dict): Dictionary of problem parameters.\n\n    Returns:\n        tuple: state trajectories (x, v, a) as np.ndarrays of shape (N, H+1).\n    \"\"\"\n    N, H, dt = params[\"N\"], params[\"H\"], params[\"dt\"]\n    x0, v0, a0 = params[\"x0\"], params[\"v0\"], params[\"a0\"]\n\n    j = u.reshape((N, H))\n    \n    x = np.zeros((N, H + 1))\n    v = np.zeros((N, H + 1))\n    a = np.zeros((N, H + 1))\n    \n    x[:, 0], v[:, 0], a[:, 0] = x0, v0, a0\n    \n    dt2_2 = 0.5 * dt**2\n    dt3_6 = (1/6) * dt**3\n\n    for k in range(H):\n        j_k = j[:, k]\n        x_k, v_k, a_k = x[:, k], v[:, k], a[:, k]\n        \n        a[:, k + 1] = a_k + dt * j_k\n        v[:, k + 1] = v_k + dt * a_k + dt2_2 * j_k\n        x[:, k + 1] = x_k + dt * v_k + dt2_2 * a_k + dt3_6 * j_k\n            \n    return x, v, a\n\n\ndef cost_function(u, params):\n    \"\"\"\n    Calculates the MPC objective function value.\n    \"\"\"\n    N, H = params[\"N\"], params[\"H\"]\n    v_ref, wv, wa, wj = params[\"v_ref\"], params[\"wa\"], params[\"wj\"]\n\n    j = u.reshape((N, H))\n    x, v, a = simulate(u, params)\n    \n    cost = 0.0\n    \n    # State cost (v, a) for k=1...H\n    cost += np.sum(wv * (v[:, 1:] - v_ref)**2)\n    cost += np.sum(wa * a[:, 1:]**2)\n    \n    # Control cost (j) for k=0...H-1\n    cost += np.sum(wj * j**2)\n            \n    return cost\n\n\ndef constraints_function(u, params):\n    \"\"\"\n    Calculates the values of all inequality constraints.\n    Expected form for SLSQP is g(u) >= 0.\n    \"\"\"\n    N, H = params[\"N\"], params[\"H\"]\n    a_max, d0, T = params[\"a_max\"], params[\"d0\"], params[\"T\"]\n    \n    x, v, a = simulate(u, params)\n    \n    # State trajectories from k=1 to H\n    x_h, v_h, a_h = x[:, 1:], v[:, 1:], a[:, 1:]\n\n    # Acceleration constraints: -a_max <= a <= a_max\n    accel_cons_lower = (a_h + a_max).flatten()\n    accel_cons_upper = (a_max - a_h).flatten()\n\n    # Nonnegative speed: v >= 0\n    speed_cons = v_h.flatten()\n\n    # Safety distance: x_{i-1} - x_i >= d0 + T*v_i\n    # This applies to followers, i=1..N-1 in 0-based indexing\n    headway = x_h[:-1, :] - x_h[1:, :]\n    required_dist = d0 + T * v_h[1:, :]\n    safety_cons = (headway - required_dist).flatten()\n\n    return np.concatenate([\n        accel_cons_lower,\n        accel_cons_upper,\n        speed_cons,\n        safety_cons\n    ])\n\n\ndef solve_case(params):\n    \"\"\"\n    Sets up and solves the optimization problem for a single test case.\n    \"\"\"\n    N, H, j_max = params[\"N\"], params[\"H\"], params[\"j_max\"]\n    \n    num_vars = N * H\n    u_initial = np.zeros(num_vars)\n    \n    jerk_bounds = [(-j_max, j_max)] * num_vars\n    \n    cons = {'type': 'ineq', 'fun': constraints_function, 'args': (params,)}\n    \n    result = minimize(\n        cost_function, \n        u_initial, \n        args=(params,),\n        method='SLSQP', \n        bounds=jerk_bounds, \n        constraints=[cons],\n        options={'ftol': 1e-9, 'disp': False}\n    )\n                      \n    return result.fun\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}