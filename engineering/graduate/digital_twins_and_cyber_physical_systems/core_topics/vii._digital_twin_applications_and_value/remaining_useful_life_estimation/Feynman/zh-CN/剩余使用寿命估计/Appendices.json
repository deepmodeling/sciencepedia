{
    "hands_on_practices": [
        {
            "introduction": "在简单的线性外推法基础上，更精密的RUL估算通常会引入基于物理或随机过程的系统模型。这种基于模型的方法能够更系统地处理系统动态和不确定性。本练习将引导您使用现代估计理论的基石——卡尔曼滤波器（Kalman filter），来解决一个更具挑战性的问题 。您将为一个被建模为带漂移的布朗运动的潜在退化过程构建状态空间模型，并利用卡尔曼滤波器从带噪声的测量数据中递归地估计其真实状态，从而获得对RUL的更精确、更可靠的估计。",
            "id": "4240318",
            "problem": "您的任务是形式化一个退化跟踪数字孪生模型，并为一个信息物理系统（CPS）实现一个剩余使用寿命（RUL）估算的计算程序。其潜在的退化被建模为一个通过带噪声测量观察到的漂移布朗运动。形式上，潜在退化状态 $x_k$ 以大小为 $\\Delta t$ 的离散时间步演化，遵循一个从带漂移的维纳过程中推导出的线性高斯状态空间表示。潜在状态 $x_k$ 只能通过一个被加性高斯噪声污染的测量值 $y_k$ 来观察，且初始状态是不确定的。\n\n从基本原理出发，使用以下基础构建线性高斯状态空间模型：\n\n- 连续时间维纳过程（布朗运动）$W_t$ 具有独立增量，满足 $W_{t+\\Delta t} - W_t \\sim \\mathcal{N}(0, \\Delta t)$。\n- 一个漂移布朗退化过程 $X_t$ 服从 $X_{t+\\Delta t} = X_t + \\mu \\Delta t + \\sqrt{q}\\,(W_{t+\\Delta t} - W_t)$，其中 $\\mu$ 是一个确定性漂移率（单位：退化量/单位时间），$q$ 是一个非负扩散系数（单位：退化量²/单位时间）。\n- 在由 $k \\in \\{1,2,\\ldots,N\\}$ 索引的离散时间点，我们定义 $x_k = X_{k \\Delta t}$。测量值服从 $y_k = x_k + v_k$，其中 $v_k \\sim \\mathcal{N}(0, r)$ 是独立同分布的测量噪声，其方差为 $r$（单位：退化量²）。初始状态 $x_0$ 具有高斯先验 $x_0 \\sim \\mathcal{N}(m_0, P_0)$。\n\n您的程序必须通过 Kalman 递归实现滤波分布计算，以获取在给定每个测试用例的测量值 $\\{y_k\\}_{k=1}^N$ 的条件下，$x_N$ 的后验均值 $m_{N\\mid N}$ 和方差 $P_{N\\mid N}$。基于滤波后的后验均值，根据漂移布朗模型计算达到上失效阈值 $L$（单位：退化量）的预期剩余使用寿命（RUL）。您必须以小时为单位表示预期的 RUL。对预期的 RUL 采用以下规则：\n- 如果 $m_{N\\mid N} \\ge L$，则预期的 RUL 为 $0$ 小时。\n- 如果 $m_{N\\mid N}  L$ 且 $\\mu \\le 0$，则预期的 RUL 为 $+\\infty$ 小时。\n- 如果 $m_{N\\mid N}  L$ 且 $\\mu  0$，则预期的 RUL 为 $\\dfrac{L - m_{N\\mid N}}{\\mu}$ 小时。\n\n在您的问题陈述中，不要使用任何专门的 Kalman 滤波“捷径”公式；您必须在解决方案中基于线性高斯状态空间原理推导并实现递归。所有数学符号、变量、函数、运算符和数字都必须用 LaTeX 书写。\n\n物理单位：以小时报告 RUL。不要使用百分比。不涉及角度。最终程序必须输出一行，其中包含一个用方括号括起来的逗号分隔列表，列表内容为每个测试用例的预期 RUL 值（以十进制浮点数表示）。当预期 RUL 为无穷大时，打印 Python 浮点数表示的 $+\\infty$。\n\n为以下参数集测试套件实现您的程序，这些参数集旨在测试不同场景，包括典型情况、已失效检测、小正漂移、负漂移和零漂移。每个测试用例指定 $(\\Delta t, \\mu, q, r, m_0, P_0, L, \\{y_k\\}_{k=1}^N)$：\n\n- 测试用例 A (典型正漂移)：\n  - $\\Delta t = 1.0$ 小时，\n  - $\\mu = 0.5$ 退化量/小时，\n  - $q = 0.2$ 退化量²/小时，\n  - $r = 0.5$ 退化量²，\n  - $m_0 = 0.0$ 退化量，\n  - $P_0 = 1.0$ 退化量²，\n  - $L = 10.0$ 退化量，\n  - 测量值 $\\{y_k\\} = [0.2, 0.7, 1.3, 2.0, 2.4, 3.1, 3.9, 4.4, 5.2, 5.7]$ (单位：退化量)。\n- 测试用例 B (滤波后已失效)：\n  - $\\Delta t = 1.0$ 小时，\n  - $\\mu = 0.6$ 退化量/小时，\n  - $q = 0.1$ 退化量²/小时，\n  - $r = 0.05$ 退化量²，\n  - $m_0 = 2.5$ 退化量，\n  - $P_0 = 0.2$ 退化量²，\n  - $L = 4.0$ 退化量，\n  - 测量值 $\\{y_k\\} = [3.0, 3.8, 4.4]$ (单位：退化量)。\n- 测试用例 C (小正漂移)：\n  - $\\Delta t = 0.5$ 小时，\n  - $\\mu = 0.05$ 退化量/小时，\n  - $q = 0.1$ 退化量²/小时，\n  - $r = 0.1$ 退化量²，\n  - $m_0 = -0.2$ 退化量，\n  - $P_0 = 0.5$ 退化量²，\n  - $L = 1.0$ 退化量，\n  - 测量值 $\\{y_k\\} = [-0.1, 0.0, 0.1, 0.2, 0.25]$ (单位：退化量)。\n- 测试用例 D (负漂移)：\n  - $\\Delta t = 1.0$ 小时，\n  - $\\mu = -0.1$ 退化量/小时，\n  - $q = 0.3$ 退化量²/小时，\n  - $r = 0.2$ 退化量²，\n  - $m_0 = 2.0$ 退化量，\n  - $P_0 = 1.0$ 退化量²，\n  - $L = 5.0$ 退化量，\n  - 测量值 $\\{y_k\\} = [2.1, 2.0, 1.9, 1.8, 1.7]$ (单位：退化量)。\n- 测试用例 E (零漂移)：\n  - $\\Delta t = 1.0$ 小时，\n  - $\\mu = 0.0$ 退化量/小时，\n  - $q = 0.3$ 退化量²/小时，\n  - $r = 0.5$ 退化量²，\n  - $m_0 = 1.0$ 退化量，\n  - $P_0 = 0.5$ 退化量²，\n  - $L = 3.0$ 退化量，\n  - 测量值 $\\{y_k\\} = [1.1, 1.2, 1.25]$ (单位：退化量)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是根据滤波后验均值 $m_{N\\mid N}$ 和上述规则计算出的相应测试用例的预期 RUL（以小时为单位）。",
            "solution": "该问题要求为退化过程构建一个线性高斯状态空间模型，并实现一个 Kalman 滤波器来估计系统状态及其随后的剩余使用寿命（RUL）。解决方案分三个阶段呈现：首先，从给定的连续时间过程推导离散时间状态空间模型；其次，从基本原理逐步推导 Kalman 滤波器递归；第三，应用 RUL 估算规则。\n\n**1. 状态空间模型构建**\n\n退化过程由连续时间 $t$ 中的漂移布朗运动描述。潜在退化状态 $X_t$ 根据以下公式演化：\n$$X_{t+\\Delta t} = X_t + \\mu \\Delta t + \\sqrt{q}\\,(W_{t+\\Delta t} - W_t)$$\n其中 $\\mu$ 是漂移率， $q$ 是扩散系数， $W_t$ 是一个标准维纳过程，其增量是高斯的： $W_{t+\\Delta t} - W_t \\sim \\mathcal{N}(0, \\Delta t)$。\n\n我们通过考虑时间点 $t_k = k \\Delta t$（其中 $k \\in \\{0, 1, 2, \\ldots\\}$）来离散化此过程。令离散时间状态为 $x_k = X_{t_k}$。状态演化方程可以写为：\n$$x_k = x_{k-1} + \\mu \\Delta t + \\sqrt{q}\\,(W_{k\\Delta t} - W_{(k-1)\\Delta t})$$\n我们定义一个过程噪声项 $w_{k-1} = \\sqrt{q}\\,(W_{k\\Delta t} - W_{(k-1)\\Delta t})$。由于维纳增量是一个均值为 $0$、方差为 $\\Delta t$ 的随机变量，过程噪声 $w_{k-1}$ 也是一个高斯随机变量。其均值为 $E[w_{k-1}] = \\sqrt{q} E[W_{k\\Delta t} - W_{(k-1)\\Delta t}] = 0$。其方差，我们记为 $Q$，是 $\\text{Var}(w_{k-1}) = E[w_{k-1}^2] = q \\cdot E[(W_{k\\Delta t} - W_{(k-1)\\Delta t})^2] = q \\Delta t$。因此， $w_{k-1} \\sim \\mathcal{N}(0, Q)$，其中 $Q = q \\Delta t$。\n\n因此，状态转移方程为：\n$$x_k = x_{k-1} + \\mu \\Delta t + w_{k-1}$$\n该方程是标准线性状态空间形式 $x_k = A x_{k-1} + B u_{k-1} + w_{k-1}$。对于此标量系统，状态转移矩阵为 $A=1$。项 $\\mu \\Delta t$ 是一个确定性漂移，可以建模为控制输入 $u_{k-1} = \\mu \\Delta t$，相应的控制矩阵为 $B=1$。\n\n测量模型给定为 $y_k = x_k + v_k$，其中测量噪声 $v_k$ 从高斯分布 $v_k \\sim \\mathcal{N}(0, r)$ 中抽取。这直接对应于标准测量方程 $y_k = H x_k + v_k$。对于此标量系统，观测矩阵为 $H=1$，测量噪声方差为 $R=r$。\n\n初始状态 $x_0$ 假设具有高斯先验分布 $x_0 \\sim \\mathcal{N}(m_0, P_0)$。\n\n总结来说，线性高斯状态空间模型定义如下：\n- 状态方程：$x_k = 1 \\cdot x_{k-1} + 1 \\cdot (\\mu \\Delta t) + w_{k-1}$，其中 $w_{k-1} \\sim \\mathcal{N}(0, q \\Delta t)$\n- 测量方程：$y_k = 1 \\cdot x_k + v_k$，其中 $v_k \\sim \\mathcal{N}(0, r)$\n- 初始条件：$p(x_0) = \\mathcal{N}(x_0; m_0, P_0)$\n\n**2. Kalman 滤波器递归**\n\nKalman 滤波器提供了一种最优递归算法，用于在给定截至时间 $k$ 的所有测量值 $y_{1:k} = \\{y_1, y_2, \\ldots, y_k\\}$ 的情况下估计状态 $x_k$。该滤波器计算后验概率分布 $p(x_k | y_{1:k})$，对于线性高斯模型，该分布本身是高斯的：$p(x_k | y_{1:k}) = \\mathcal{N}(x_k; m_{k|k}, P_{k|k})$。递归在每个时间增量中分两步进行：预测和更新。\n\n我们从上一步的滤波估计开始， $p(x_{k-1} | y_{1:k-1}) = \\mathcal{N}(x_{k-1}; m_{k-1|k-1}, P_{k-1|k-1})$。初始状态为 $m_{0|0} = m_0$ 和 $P_{0|0} = P_0$。\n\n**预测步骤（时间更新）：**\n此步骤在考虑新测量值 $y_k$ 之前，使用模型预测时间 $k$ 的状态。我们计算预测分布 $p(x_k | y_{1:k-1}) = \\mathcal{N}(x_k; m_{k|k-1}, P_{k|k-1})$。\n预测均值 $m_{k|k-1}$ 是状态 $x_k$ 在先前数据条件下的期望：\n$$m_{k|k-1} = E[x_k | y_{1:k-1}] = E[A x_{k-1} + B u_{k-1} + w_{k-1} | y_{1:k-1}]$$\n$$m_{k|k-1} = A E[x_{k-1} | y_{1:k-1}] + B u_{k-1} = A m_{k-1|k-1} + B u_{k-1}$$\n预测协方差 $P_{k|k-1}$ 是此预测的方差：\n$$P_{k|k-1} = \\text{Var}(x_k | y_{1:k-1}) = \\text{Var}(A x_{k-1} + w_{k-1} | y_{1:k-1})$$\n$$P_{k|k-1} = A \\text{Var}(x_{k-1} | y_{1:k-1}) A^T + \\text{Var}(w_{k-1}) = A P_{k-1|k-1} A^T + Q$$\n\n对于我们的特定标量模型，有 $A=1$，$B=1$，$u_{k-1} = \\mu \\Delta t$ 和 $Q = q \\Delta t$：\n$$m_{k|k-1} = m_{k-1|k-1} + \\mu \\Delta t$$\n$$P_{k|k-1} = P_{k-1|k-1} + q \\Delta t$$\n\n**更新步骤（测量更新）：**\n此步骤使用新的测量值 $y_k$ 来更新预测的状态和协方差。我们通过贝叶斯规则将预测分布（此步骤的先验）与测量值的似然 $p(y_k | x_k) = \\mathcal{N}(y_k; H x_k, R)$ 相结合，以获得后验 $p(x_k | y_{1:k}) = \\mathcal{N}(x_k; m_{k|k}, P_{k|k})$。更新方程如下：\n\n1.  新息（或测量残差）：$\\tilde{y}_k = y_k - E[y_k | y_{1:k-1}] = y_k - H m_{k|k-1}$。这是实际测量与其预测之间的差异。\n2.  新息协方差：$S_k = \\text{Var}(\\tilde{y}_k) = H P_{k|k-1} H^T + R$。这表示新息中的不确定性。\n3.  Kalman 增益：$K_k = P_{k|k-1} H^T S_k^{-1}$。增益决定了新息对预测的修正程度。高增益更侧重于测量，而低增益更侧重于预测。\n4.  更新后均值：$m_{k|k} = m_{k|k-1} + K_k \\tilde{y}_k$。预测均值由加权新息进行调整。\n5.  更新后协方差：$P_{k|k} = (I - K_k H) P_{k|k-1}$。通过从测量中获得的信息来减少预测的不确定性。\n\n对于我们的标量模型，有 $H=1$ 和 $R=r$：\n$$\\tilde{y}_k = y_k - m_{k|k-1}$$\n$$S_k = P_{k|k-1} + r$$\n$$K_k = P_{k|k-1} (S_k)^{-1} = \\frac{P_{k|k-1}}{P_{k|k-1} + r}$$\n$$m_{k|k} = m_{k|k-1} + K_k (y_k - m_{k|k-1})$$\n$$P_{k|k} = (1 - K_k) P_{k|k-1}$$\n\n对 $k=1, \\ldots, N$ 执行此递归，得到最终的滤波估计 $(m_{N|N}, P_{N|N})$。\n\n**3. RUL 估算**\n\n预期的 RUL 是根据最终的滤波状态均值 $m_{N|N}$ 计算的，这是我们对当前退化水平的最佳估计。未来的预期退化路径假定遵循漂移 $\\mu$。从当前状态达到失效阈值 $L$ 的时间根据以下规则计算：\n\n- 如果 $m_{N|N} \\ge L$：估计的退化已经达到或超过了失效阈值。预期的 RUL 是 $0$ 小时。\n- 如果 $m_{N|N}  L$ 且 $\\mu \\le 0$：退化预计不会增加（平均而言可能减少或保持不变）。因此，预计不会达到阈值 $L$。预期的 RUL 被认为是无限的，即 $+\\infty$ 小时。\n- 如果 $m_{N|N}  L$ 且 $\\mu > 0$：退化预计以每小时 $\\mu$ 个单位的速率增加。直到失效的剩余退化量为 $\\Delta_L = L - m_{N|N}$。覆盖此量的预期时间是：\n$$ \\text{RUL} = \\frac{\\Delta_L}{\\mu} = \\frac{L - m_{N|N}}{\\mu} \\text{ 小时} $$\n\n实现将对每个测试用例应用这些状态空间、Kalman 滤波器和 RUL 方程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Remaining Useful Life (RUL) estimation problem for a series of test cases.\n    \"\"\"\n\n    # Each test case is a dictionary specifying the parameters for the degradation model and Kalman filter.\n    # The format is: (delta_t, mu, q, r, m0, P0, L, measurements) in SI-like units.\n    test_cases = [\n        # Test Case A (typical positive drift)\n        {\n            \"delta_t\": 1.0,  # hours\n            \"mu\": 0.5,      # degradation per hour\n            \"q\": 0.2,       # degradation^2 per hour\n            \"r\": 0.5,       # degradation^2\n            \"m0\": 0.0,      # degradation\n            \"P0\": 1.0,      # degradation^2\n            \"L\": 10.0,      # degradation\n            \"y\": [0.2, 0.7, 1.3, 2.0, 2.4, 3.1, 3.9, 4.4, 5.2, 5.7]  # degradation\n        },\n        # Test Case B (already failed after filtering)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": 0.6,\n            \"q\": 0.1,\n            \"r\": 0.05,\n            \"m0\": 2.5,\n            \"P0\": 0.2,\n            \"L\": 4.0,\n            \"y\": [3.0, 3.8, 4.4]\n        },\n        # Test Case C (small positive drift)\n        {\n            \"delta_t\": 0.5,\n            \"mu\": 0.05,\n            \"q\": 0.1,\n            \"r\": 0.1,\n            \"m0\": -0.2,\n            \"P0\": 0.5,\n            \"L\": 1.0,\n            \"y\": [-0.1, 0.0, 0.1, 0.2, 0.25]\n        },\n        # Test Case D (negative drift)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": -0.1,\n            \"q\": 0.3,\n            \"r\": 0.2,\n            \"m0\": 2.0,\n            \"P0\": 1.0,\n            \"L\": 5.0,\n            \"y\": [2.1, 2.0, 1.9, 1.8, 1.7]\n        },\n        # Test Case E (zero drift)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": 0.0,\n            \"q\": 0.3,\n            \"r\": 0.5,\n            \"m0\": 1.0,\n            \"P0\": 0.5,\n            \"L\": 3.0,\n            \"y\": [1.1, 1.2, 1.25]\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        rul = calculate_rul_with_kalman_filter(params)\n        results.append(rul)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The map(str, ...) ensures that infinity is printed as 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_rul_with_kalman_filter(params):\n    \"\"\"\n    Computes the filtered state and RUL for a single degradation process.\n\n    Args:\n        params (dict): A dictionary containing all model parameters.\n\n    Returns:\n        float: The estimated Remaining Useful Life in hours.\n    \"\"\"\n    # Extract parameters for clarity\n    delta_t = params[\"delta_t\"]\n    mu = params[\"mu\"]\n    q = params[\"q\"]\n    r = params[\"r\"]\n    m_current = params[\"m0\"]\n    P_current = params[\"P0\"]\n    L = params[\"L\"]\n    measurements = params[\"y\"]\n\n    # --- State-Space Model Parameters for the scalar case ---\n    # According to the derivation: x_k = A*x_{k-1} + B*u_{k-1} + w_{k-1}\n    # A = 1 (State transition matrix)\n    # B = 1 (Control input matrix)\n    # u = mu * delta_t (Control input, deterministic drift part)\n    # Q = q * delta_t (Process noise variance)\n    # According to the derivation: y_k = H*x_k + v_k\n    # H = 1 (Observation matrix)\n    # R = r (Measurement noise variance)\n    u_input = mu * delta_t\n    Q_noise_var = q * delta_t\n\n    # --- Kalman Filter Recursion ---\n    for y_k in measurements:\n        # 1. Prediction (Time Update)\n        m_predicted = m_current + u_input\n        P_predicted = P_current + Q_noise_var\n\n        # 2. Update (Measurement Update)\n        # Innovation (residual)\n        y_tilde = y_k - m_predicted\n        # Innovation covariance\n        S = P_predicted + r\n        # Kalman gain\n        K = P_predicted / S\n        # Updated state mean\n        m_current = m_predicted + K * y_tilde\n        # Updated state covariance\n        P_current = (1 - K) * P_predicted\n    \n    # Final filtered mean is m_current, which is m_{N|N}\n    m_N_N = m_current\n\n    # --- RUL Calculation ---\n    if m_N_N >= L:\n        # Already failed\n        return 0.0\n    elif m_N_N  L and mu = 0:\n        # Degradation is not expected to increase, will not reach threshold\n        return float('inf')\n    else:  # m_N_N  L and mu > 0\n        # Expected time to reach threshold L with positive drift mu\n        return (L - m_N_N) / mu\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "生成RUL预测本身并不是最终目的；其真正的价值在于预测的准确性以及它们能否指导及时的维护决策。因此，评估预测性能与做出预测同样重要。最后一个实践练习将视角从“如何预测”转向“如何评估”，要求您从第一性原理出发，推导并实现关键的性能指标 。您将不仅计算标准的准确性指标（如均方根误差 $RMSE$），还将构建一个考虑了过早和过晚维护的不同业务成本的非对称成本函数，从而全面评估RUL预测器在真实运营环境中的质量与实用价值。",
            "id": "4240256",
            "problem": "一个信息物理资产的数字孪生会流式传输一系列离散时间的剩余使用寿命 (RUL) 预测值。设由 $k \\in \\{0,1,\\dots, K-1\\}$ 索引的离散时刻的真实 RUL 表示为 $r_k$（单位为 $\\mathrm{h}$），数字孪生的预测值表示为 $\\hat{r}_k$（单位为 $\\mathrm{h}$）。定义预测误差为 $e_k = \\hat{r}_k - r_k$（单位为 $\\mathrm{h}$）。目标是纯粹从第一性原理出发，仅使用经验风险和成本敏感决策的基本构造，计算两个性能指标和一个操作决策标志：\n- 第一个指标应从 $\\mathbb{R}^K$ 中的欧几里得范数和对 $K$ 个样本求平均的原则出发推导得出，用以量化以小时为单位的典型误差幅度。\n- 第二个指标应从具有以下公理的单步成本出发推导得出：零误差时惩罚为零、误差幅度的单调性、凸性、正齐次性、增量的平移不变性，以及对高估和低估的不对称单位成本。高估（预测的 RUL 大于实际值，$e_k  0$）应产生每小时单位成本 $c_{+}$（单位为 $\\mathrm{CU}/\\mathrm{h}$），而低估（预测的 RUL 小于实际值，$e_k  0$）应产生每小时单位成本 $c_{-}$（单位为 $\\mathrm{CU}/\\mathrm{h}$），其中 $c_{+}$ 和 $c_{-}$ 是给定的。通过经验均值在时间上汇总此单步惩罚，以获得一个以成本单位（$\\mathrm{CU}$）表示的及时性指标。\n- 操作决策标志是为给定的采购提前期 $L$（单位为 $\\mathrm{h}$）和计划缓冲 $B$（单位为 $\\mathrm{h}$）定义的。当满足 $\\hat{r}_k \\le L + B$ 条件时，在第一个索引 $k$ 处下达维修订单。如果存在任何这样的索引 $k$ 且满足 $r_k \\ge L$，则声明调度成功；否则声明失败。这编码了以下规则：系统应在预测的 RUL 下降到至多 $L + B$ 时触发，但触发时的真实 RUL 必须至少为 $L$，以确保订单能在失效前到达。\n\n您必须：\n- 基于上述基础推导两个指标，不得使用任何预先给定的简化公式，并实现它们。\n- 对每个测试用例，计算：\n  $1)$ 第一个指标（单位为 $\\mathrm{h}$），\n  $2)$ 第二个指标（单位为 $\\mathrm{CU}$），\n  $3)$ 调度成功布尔值。\n\n所有 RUL 量均以 $\\mathrm{h}$ 表示，成本以 $\\mathrm{CU}$ 表示，并将所有浮点输出四舍五入到 $4$ 位小数。\n\n测试套件：\n- 测试用例 $1$：\n  - $r_k$ (单位 $\\mathrm{h}$): $\\{50, 40, 30, 20, 10, 0\\}$\n  - $\\hat{r}_k$ (单位 $\\mathrm{h}$): $\\{52, 41, 28, 18, 9, 0\\}$\n  - $c_{+} = 2$ (单位 $\\mathrm{CU}/\\mathrm{h}$), $c_{-} = 1$ (单位 $\\mathrm{CU}/\\mathrm{h}$)\n  - $L = 12$ (单位 $\\mathrm{h}$), $B = 4$ (单位 $\\mathrm{h}$)\n- 测试用例 $2$：\n  - $r_k$ (单位 $\\mathrm{h}$): $\\{40, 30, 20, 10, 0\\}$\n  - $\\hat{r}_k$ (单位 $\\mathrm{h}$): $\\{35, 25, 15, 5, 0\\}$\n  - $c_{+} = 2$ (单位 $\\mathrm{CU}/\\mathrm{h}$), $c_{-} = 1$ (单位 $\\mathrm{CU}/\\mathrm{h}$)\n  - $L = 10$ (单位 $\\mathrm{h}$), $B = 2$ (单位 $\\mathrm{h}$)\n- 测试用例 $3$：\n  - $r_k$ (单位 $\\mathrm{h}$): $\\{12, 8, 4, 0\\}$\n  - $\\hat{r}_k$ (单位 $\\mathrm{h}$): $\\{12, 8, 4, 0\\}$\n  - $c_{+} = 3$ (单位 $\\mathrm{CU}/\\mathrm{h}$), $c_{-} = 1$ (单位 $\\mathrm{CU}/\\mathrm{h}$)\n  - $L = 6$ (单位 $\\mathrm{h}$), $B = 0$ (单位 $\\mathrm{h}$)\n- 测试用例 $4$：\n  - $r_k$ (单位 $\\mathrm{h}$): $\\{24, 16, 8, 0\\}$\n  - $\\hat{r}_k$ (单位 $\\mathrm{h}$): $\\{34, 22, 10, 0\\}$\n  - $c_{+} = 3$ (单位 $\\mathrm{CU}/\\mathrm{h}$), $c_{-} = 0.5$ (单位 $\\mathrm{CU}/\\mathrm{h}$)\n  - $L = 8$ (单位 $\\mathrm{h}$), $B = 4$ (单位 $\\mathrm{h}$)\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个按测试用例排列的三元组列表，格式为\n$[ [m_1, t_1, s_1], [m_2, t_2, s_2], \\dots ]$\n其中 $m_i$ 是第一个指标（单位为 $\\mathrm{h}$，四舍五入到 $4$ 位小数），$t_i$ 是及时性指标（单位为 $\\mathrm{CU}$，四舍五入到 $4$ 位小数），$s_i$ 是测试用例 $i$ 的调度成功布尔值。打印的列表必须不含空格，数字必须以标准的十进制浮点数或整数形式呈现，并按指定进行四舍五入。例如：$[[m_1,t_1,s_1],[m_2,t_2,s_2],\\dots]$。",
            "solution": "我们将根据问题陈述中指定的第一性原理来推导这两个指标和决策标志的逻辑。\n\n**指标 1：误差幅度指标**\n\n问题要求从 $\\mathbb{R}^K$ 中的欧几里得范数和使用平均原则出发，推导出用于衡量“典型误差幅度”的指标。跨越 $K$ 个时间步的预测误差构成 $\\mathbb{R}^K$ 中的一个向量 $\\mathbf{e} = [e_0, e_1, \\dots, e_{K-1}]^T$。\n\n1.  该向量的欧几里得范数的平方为 $\\|\\mathbf{e}\\|_2^2 = \\sum_{k=0}^{K-1} e_k^2$。此量代表总平方误差。\n2.  为找到一个典型值或平均值，我们应用“对 $K$ 个样本求平均的原则”。我们计算平方误差的均值：$\\frac{1}{K} \\sum_{k=0}^{K-1} e_k^2$。这就是均方误差 (MSE)。\n3.  MSE 的单位是 $\\mathrm{h}^2$。为了回到原始的单位小时（$\\mathrm{h}$）并获得典型误差幅度的度量，我们对 MSE 取平方根。\n\n这就得到了均方根误差 (RMSE)，我们将其表示为 $m_1$：\n$$\nm_1 = \\sqrt{\\frac{1}{K} \\sum_{k=0}^{K-1} e_k^2} = \\sqrt{\\frac{1}{K} \\sum_{k=0}^{K-1} (\\hat{r}_k - r_k)^2}\n$$\n此公式满足所有条件：它源于欧几里得范数，包含了平均化，并得出一个具有正确单位（$\\mathrm{h}$）且代表典型误差幅度的量。\n\n**指标 2：及时性指标（不对称成本）**\n\n问题指定了一个具有多个公理的单步成本函数 $C(e_k)$，这导致对高估（$e_k  0$）和低估（$e_k  0$）的不对称惩罚。\n- 高估误差 $e_k  0$ 会产生每小时 $c_{+}$ 的成本，因此惩罚为 $c_{+} \\cdot e_k$。\n- 低估误差 $e_k  0$ 会根据误差幅度产生每小时 $c_{-}$ 的成本。其幅度为 $|e_k| = -e_k$，因此惩罚为 $c_{-} \\cdot |e_k| = c_{-} \\cdot (-e_k)$。\n- 零误差（$e_k = 0$）则不产生任何成本。\n\n这可以表示为单个函数：\n$$\nC(e_k) = \\begin{cases}\nc_{+} \\cdot e_k  \\text{if } e_k  0 \\\\\nc_{-} \\cdot (-e_k)  \\text{if } e_k  0 \\\\\n0  \\text{if } e_k = 0\n\\end{cases}\n$$\n这个函数可以使用 $\\max$ 函数更紧凑地写成：$C(e_k) = c_{+} \\max(0, e_k) + c_{-} \\max(0, -e_k)$。此函数满足所述的零误差时惩罚为零、单调性、凸性和正齐次性等公理。\n\n问题要求通过经验均值汇总此惩罚，以获得最终的及时性指标 $t_1$：\n$$\nt_1 = \\frac{1}{K} \\sum_{k=0}^{K-1} C(e_k) = \\frac{1}{K} \\sum_{k=0}^{K-1} \\left[ c_{+} \\max(0, \\hat{r}_k - r_k) + c_{-} \\max(0, r_k - \\hat{r}_k) \\right]\n$$\n$t_1$ 的单位是成本单位（$\\mathrm{CU}$），符合要求。\n\n**操作决策标志**\n\n操作决策标志 $s_1$ 的逻辑由一个顺序过程定义。\n\n1.  当预测的 RUL $\\hat{r}_k$ 首次降至或低于一个触发阈值时，安排维修订单。该阈值是采购提前期 $L$ 和计划缓冲 $B$ 的总和。设触发阈值为 $T = L + B$。\n2.  系统识别出首次满足触发条件的时间索引 $k^*$：\n    $$\n    k^* = \\min \\{k \\in \\{0, 1, \\dots, K-1\\} \\mid \\hat{r}_k \\le L + B \\}\n    $$\n3.  如果在观察窗口内不存在这样的索引 $k$（即对所有 $k$ 都有 $\\hat{r}_k  L + B$），则不会下达维修订单。这被视为灾难性故障，因为系统未能及时识别出维修需求。因此，调度是失败的。\n4.  如果找到了触发索引 $k^*$，当且仅当在该时刻的真实 RUL $r_{k^*}$ 足以覆盖提前期 $L$ 时，调度被声明为成功。即，成功的条件是 $r_{k^*} \\ge L$。\n5.  因此，布尔标志 $s_1$ 的计算如下：\n    - 找到索引集合 $S = \\{k \\mid \\hat{r}_k \\le L+B\\}$。\n    - 如果 $S$ 为空，则 $s_1 = \\text{False}$。\n    - 否则，令 $k^* = \\min(S)$。那么 $s_1 = (\\text{如果 } r_{k^*} \\ge L \\text{ 则 True 否则 False})$。\n\n此逻辑遵循一个现实的操作序列，其中决策是基于可用的预测做出的，而无需了解未来的状态。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RUL performance evaluation problem for a given set of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"r\": np.array([50, 40, 30, 20, 10, 0]),\n            \"r_hat\": np.array([52, 41, 28, 18, 9, 0]),\n            \"c_plus\": 2.0,\n            \"c_minus\": 1.0,\n            \"L\": 12.0,\n            \"B\": 4.0,\n        },\n        {\n            \"r\": np.array([40, 30, 20, 10, 0]),\n            \"r_hat\": np.array([35, 25, 15, 5, 0]),\n            \"c_plus\": 2.0,\n            \"c_minus\": 1.0,\n            \"L\": 10.0,\n            \"B\": 2.0,\n        },\n        {\n            \"r\": np.array([12, 8, 4, 0]),\n            \"r_hat\": np.array([12, 8, 4, 0]),\n            \"c_plus\": 3.0,\n            \"c_minus\": 1.0,\n            \"L\": 6.0,\n            \"B\": 0.0,\n        },\n        {\n            \"r\": np.array([24, 16, 8, 0]),\n            \"r_hat\": np.array([34, 22, 10, 0]),\n            \"c_plus\": 3.0,\n            \"c_minus\": 0.5,\n            \"L\": 8.0,\n            \"B\": 4.0,\n        },\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        r = case[\"r\"]\n        r_hat = case[\"r_hat\"]\n        c_plus = case[\"c_plus\"]\n        c_minus = case[\"c_minus\"]\n        L = case[\"L\"]\n        B = case[\"B\"]\n        \n        # Calculate error vector\n        e = r_hat - r\n        \n        # Metric 1: Root Mean Square Error (RMSE)\n        # m1 = sqrt( (1/K) * sum(e_k^2) )\n        m1 = np.sqrt(np.mean(e**2))\n        \n        # Metric 2: Timeliness Metric (Asymmetric Cost)\n        # t1 = (1/K) * sum( C(e_k) )\n        # C(e_k) = c_plus * max(0, e_k) + c_minus * max(0, -e_k)\n        overestimation_cost = c_plus * np.maximum(0, e)\n        underestimation_cost = c_minus * np.maximum(0, -e)\n        t1 = np.mean(overestimation_cost + underestimation_cost)\n        \n        # Operational Decision Flag\n        # s1 = success/failure boolean\n        trigger_threshold = L + B\n        trigger_indices = np.where(r_hat = trigger_threshold)[0]\n        \n        s1 = False # Default to failure\n        if trigger_indices.size > 0:\n            first_trigger_index = trigger_indices[0]\n            true_rul_at_trigger = r[first_trigger_index]\n            if true_rul_at_trigger >= L:\n                s1 = True\n\n        # Round floats to 4 decimal places for the result list\n        m1_rounded = round(m1, 4)\n        t1_rounded = round(t1, 4)\n        \n        all_results.append([m1_rounded, t1_rounded, s1])\n        \n    # Format the final output string to remove spaces\n    # Example: '[[1.5275, 1.8333, False], ...]' becomes '[[1.5275,1.8333,False],...]'\n    output_string = str(all_results).replace(\" \", \"\")\n    print(output_string)\n\nsolve()\n```"
        }
    ]
}