{
    "hands_on_practices": [
        {
            "introduction": "We begin our practical exploration with a fundamental data-driven approach to RUL estimation. This exercise  tasks you with implementing a linear extrapolation model, a common first step in many real-world prognostic systems. By fitting a line to recent sensor data trends, you will learn to predict the time until a critical failure threshold is reached, providing a tangible introduction to the core logic of prognostics.",
            "id": "4240301",
            "problem": "You are building a Remaining Useful Life (RUL) estimator for a rotating machine within a digital twin of a Cyber-Physical System. The digital twin maintains recent measurements of two fault-sensitive features extracted from vibration: the Root Mean Square (RMS) of acceleration and the kurtosis of the vibration signal. Over a short horizon, assume the degradation process can be locally approximated as linear in time due to slow variation relative to the sampling period. Failure is defined to occur when either feature reaches its respective failure threshold. Your task is to estimate the linear degradation rates from recent data and compute the RUL as the earliest predicted time to reach any threshold.\n\nFundamental base:\n- The Root Mean Square (RMS) of an acceleration segment of length $N$ samples is defined by $ \\mathrm{RMS} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} a_i^2} $, where $ a_i $ are the acceleration samples; its trend over time can be represented as a discrete-time series $ r_i $ sampled at times $ t_i $.\n- The kurtosis of a signal segment is defined by $ \\mathrm{Kurtosis} = \\frac{\\frac{1}{N}\\sum_{i=1}^{N} (x_i - \\mu)^4}{\\left(\\frac{1}{N}\\sum_{i=1}^{N} (x_i - \\mu)^2\\right)^2} $, where $ x_i $ are the samples and $ \\mu $ is the mean; its trend over time can be represented as a discrete-time series $ k_i $ sampled at times $ t_i $.\n- Over a short time window, linearization of the feature evolution is valid: $ r(t) \\approx m_r t + b_r $ and $ k(t) \\approx m_k t + b_k $.\n\nDefinitions:\n- Let $ \\Delta t $ be the sampling interval in hours.\n- Let $ r_i $ and $ k_i $ be the last $N$ observed values of RMS and kurtosis at times $ t_i = i \\Delta t $ for $ i = 0, 1, \\dots, N-1 $.\n- Let $ r_{\\mathrm{th}} $ and $ k_{\\mathrm{th}} $ be the respective failure thresholds for RMS and kurtosis.\n- Remaining Useful Life (RUL) is the smallest nonnegative time $ \\tau $ from the current time $ t_{N-1} $ until either $ r(t) $ or $ k(t) $ reaches its threshold. If either feature has already reached or exceeded its threshold at $ t_{N-1} $, RUL is $ 0 $. If the inferred degradation rate for a feature is nonpositive and its current value is below threshold, the crossing time for that feature is considered infinite.\n\nInstructions:\n1. Infer the linear degradation rate for each feature from the recent data window by fitting a straight line to $ (t_i, r_i) $ and $ (t_i, k_i) $ using ordinary least squares over the last $N$ samples.\n2. Compute the predicted crossing times $ t_r^\\star $ and $ t_k^\\star $ when $ r(t) $ and $ k(t) $ reach $ r_{\\mathrm{th}} $ and $ k_{\\mathrm{th}} $, respectively.\n3. Compute the RUL in hours as $ \\min\\left(\\max(0, t_r^\\star - t_{N-1}), \\max(0, t_k^\\star - t_{N-1})\\right) $ with the conventions: if the slope for a feature is nonpositive and its current value is below threshold, its crossing time contribution is infinite; if its current value is already at or above threshold, its RUL contribution is $ 0 $.\n4. Express the final RUL in hours, rounded to three decimals. Infinite values should be represented as $ \\infty $.\n\nTest suite:\nImplement your program for the following parameter sets. For each set, use the given arrays as $ r_i $ and $ k_i $, the given $ \\Delta t $ as the sampling interval in hours, and the given thresholds $ r_{\\mathrm{th}} $ and $ k_{\\mathrm{th}} $.\n\n- Case $ 1 $ (general increasing trends):\n  - $ \\Delta t = 0.5 $\n  - $ r_i = [1.20, 1.25, 1.28, 1.36, 1.45, 1.52, 1.62, 1.75] $\n  - $ k_i = [3.20, 3.25, 3.30, 3.35, 3.45, 3.55, 3.68, 3.82] $\n  - $ r_{\\mathrm{th}} = 2.20 $\n  - $ k_{\\mathrm{th}} = 5.00 $\n- Case $ 2 $ (kurtosis near threshold, RMS nearly flat):\n  - $ \\Delta t = 1.0 $\n  - $ r_i = [1.00, 0.98, 1.01, 1.02, 1.03, 1.05] $\n  - $ k_i = [4.80, 4.85, 4.88, 4.92, 4.95, 5.00, 5.05, 5.10] $\n  - $ r_{\\mathrm{th}} = 1.50 $\n  - $ k_{\\mathrm{th}} = 5.20 $\n- Case $ 3 $ (RMS already above threshold):\n  - $ \\Delta t = 0.25 $\n  - $ r_i = [1.40, 1.50, 1.65, 1.90] $\n  - $ k_i = [3.60, 3.70, 3.75, 3.80] $\n  - $ r_{\\mathrm{th}} = 1.80 $\n  - $ k_{\\mathrm{th}} = 6.00 $\n- Case $ 4 $ (RMS decreasing due to maintenance, kurtosis increasing):\n  - $ \\Delta t = 2.0 $\n  - $ r_i = [2.00, 1.95, 1.90, 1.85, 1.80] $\n  - $ k_i = [3.50, 3.60, 3.80, 4.10, 4.50] $\n  - $ r_{\\mathrm{th}} = 2.30 $\n  - $ k_{\\mathrm{th}} = 5.00 $\n- Case $ 5 $ (both features flat, no degradation evident):\n  - $ \\Delta t = 1.0 $\n  - $ r_i = [1.20, 1.20, 1.20, 1.20, 1.20] $\n  - $ k_i = [3.20, 3.20, 3.20, 3.20, 3.20] $\n  - $ r_{\\mathrm{th}} = 2.00 $\n  - $ k_{\\mathrm{th}} = 6.00 $\n\nFinal output format:\nYour program should produce a single line of output containing the RUL results for the five cases as a comma-separated list enclosed in square brackets in hours, rounded to three decimals (with infinite values represented as the literal $ \\mathrm{inf} $), for example $ [r_1, r_2, r_3, r_4, r_5] $ where each $ r_j $ is the RUL for case $ j $ in hours.",
            "solution": "This problem requires implementing a Remaining Useful Life (RUL) estimator based on linear extrapolation of degradation features. The core of the solution involves fitting a line to recent data points for each feature and then predicting when this line will cross a predefined failure threshold.\n\nThe overall approach for each test case is as follows:\n1.  **Process Each Feature Independently**: For each of the two features (RMS and Kurtosis), calculate its individual RUL.\n2.  **Model Degradation**: For a given feature time series $y_i$ observed at times $t_i = i \\Delta t$, fit a linear model $y(t) = mt + b$ using Ordinary Least Squares (OLS). The slope, $m$, represents the estimated degradation rate.\n3.  **Predict Time-to-Threshold**:\n    *   If the degradation rate $m$ is positive (i.e., the feature is degrading towards failure), calculate the time $t^\\star$ at which the feature is predicted to reach its threshold $y_{\\mathrm{th}}$. This is found by solving $y_{\\mathrm{th}} = mt^\\star + b$, which gives $t^\\star = (y_{\\mathrm{th}} - b) / m$.\n    *   The RUL is the time remaining from the last observation ($t_{N-1}$) until this predicted failure time. Thus, the RUL for the feature is $\\max(0, t^\\star - t_{N-1})$. The $\\max(0, \\dots)$ ensures the RUL is non-negative.\n4.  **Handle Special Cases**:\n    *   **Already Failed**: If the most recent measurement $y_{N-1}$ is already at or above the threshold $y_{\\mathrm{th}}$, the RUL is immediately $0$.\n    *   **No Degradation**: If the degradation rate $m$ is zero or negative, and the feature is below its threshold, it is not trending towards failure. In this scenario, its RUL is considered infinite ($\\infty$).\n5.  **Determine System RUL**: The system is considered to have failed as soon as the *first* feature reaches its threshold. Therefore, the overall RUL for the system is the minimum of the individual RULs calculated for each feature: $\\mathrm{RUL}_{\\text{system}} = \\min(\\mathrm{RUL}_{\\text{RMS}}, \\mathrm{RUL}_{\\text{Kurtosis}})$.\n\nThis logic is implemented for each of the five test cases to produce the final list of RUL values.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RUL estimation problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: general increasing trends\n        {\n            \"delta_t\": 0.5,\n            \"r_i\": [1.20, 1.25, 1.28, 1.36, 1.45, 1.52, 1.62, 1.75],\n            \"k_i\": [3.20, 3.25, 3.30, 3.35, 3.45, 3.55, 3.68, 3.82],\n            \"r_th\": 2.20,\n            \"k_th\": 5.00,\n        },\n        # Case 2: kurtosis near threshold, RMS nearly flat\n        {\n            \"delta_t\": 1.0,\n            \"r_i\": [1.00, 0.98, 1.01, 1.02, 1.03, 1.05],\n            \"k_i\": [4.80, 4.85, 4.88, 4.92, 4.95, 5.00, 5.05, 5.10],\n            \"r_th\": 1.50,\n            \"k_th\": 5.20,\n        },\n        # Case 3: RMS already above threshold\n        {\n            \"delta_t\": 0.25,\n            \"r_i\": [1.40, 1.50, 1.65, 1.90],\n            \"k_i\": [3.60, 3.70, 3.75, 3.80],\n            \"r_th\": 1.80,\n            \"k_th\": 6.00,\n        },\n        # Case 4: RMS decreasing, kurtosis increasing\n        {\n            \"delta_t\": 2.0,\n            \"r_i\": [2.00, 1.95, 1.90, 1.85, 1.80],\n            \"k_i\": [3.50, 3.60, 3.80, 4.10, 4.50],\n            \"r_th\": 2.30,\n            \"k_th\": 5.00,\n        },\n        # Case 5: both features flat\n        {\n            \"delta_t\": 1.0,\n            \"r_i\": [1.20, 1.20, 1.20, 1.20, 1.20],\n            \"k_i\": [3.20, 3.20, 3.20, 3.20, 3.20],\n            \"r_th\": 2.00,\n            \"k_th\": 6.00,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        rul_r = calculate_feature_rul(case[\"r_i\"], case[\"delta_t\"], case[\"r_th\"])\n        rul_k = calculate_feature_rul(case[\"k_i\"], case[\"delta_t\"], case[\"k_th\"])\n        \n        final_rul = min(rul_r, rul_k)\n        \n        if final_rul == float('inf'):\n            results.append(\"inf\")\n        else:\n            results.append(f\"{final_rul:.3f}\")\n            \n    print(f\"[{','.join(results)}]\")\n\ndef calculate_feature_rul(feature_values, delta_t, threshold):\n    \"\"\"\n    Calculates the RUL for a single feature.\n\n    Args:\n        feature_values (list): The list of recent feature measurements.\n        delta_t (float): The sampling interval in hours.\n        threshold (float): The failure threshold for the feature.\n\n    Returns:\n        float: The calculated RUL for the feature, which can be 0, a positive\n               number, or float('inf').\n    \"\"\"\n    N = len(feature_values)\n    \n    # If there's insufficient data to fit a line, we can't make a prediction.\n    if N  2:\n        return float('inf')\n\n    last_value = feature_values[-1]\n    \n    # If already at or above threshold, RUL is 0.\n    if last_value >= threshold:\n        return 0.0\n\n    time_vector = np.arange(N) * delta_t\n    \n    # Perform ordinary least squares linear regression to get slope (m) and intercept (b).\n    # np.polyfit returns [m, b] for a degree 1 polynomial.\n    m, b = np.polyfit(time_vector, feature_values, 1)\n\n    # If slope is non-positive, the feature is not degrading towards the threshold.\n    # Per the problem, its RUL contribution is infinite.\n    if m = 0:\n        return float('inf')\n\n    # Calculate the time (t_star) at which the linear model crosses the threshold.\n    # y(t) = m*t + b => t_star = (threshold - b) / m\n    t_star = (threshold - b) / m\n    \n    # RUL is the time from the last measurement to the crossing time.\n    time_of_last_measurement = time_vector[-1]\n    rul = t_star - time_of_last_measurement\n    \n    # RUL must be non-negative. If t_star is in the past, RUL is 0.\n    return max(0.0, rul)\n\nsolve()\n```"
        },
        {
            "introduction": "Building on the idea of tracking a trend, we now introduce a more powerful and principled method using a state-space model. This practice  challenges you to implement a Kalman filter to track a hidden degradation state, modeled as a drifted Brownian motion, from noisy measurements. This exercise is crucial for understanding how digital twins can optimally estimate the true health of a system by separating the signal of degradation from the noise.",
            "id": "4240318",
            "problem": "You are tasked with formalizing a degradation-tracking digital twin model and implementing a computational routine for Remaining Useful Life (RUL) estimation in a Cyber-Physical System (CPS). The underlying degradation is modeled as a drifted Brownian motion observed through noisy measurements. Formally, the latent degradation state $x_k$ evolves in discrete time steps of size $\\Delta t$ according to a linear Gaussian state-space representation derived from a Wiener process with drift. The latent state $x_k$ is only observable through a measurement $y_k$ corrupted by additive Gaussian noise, and the initial state is uncertain.\n\nStarting from fundamental principles, construct the linear Gaussian state-space model using the following base:\n\n- The continuous-time Wiener process (Brownian motion) $W_t$ has independent increments with $W_{t+\\Delta t} - W_t \\sim \\mathcal{N}(0, \\Delta t)$.\n- A drifted Brownian degradation process $X_t$ obeys $X_{t+\\Delta t} = X_t + \\mu \\Delta t + \\sqrt{q}\\,(W_{t+\\Delta t} - W_t)$, where $\\mu$ is a deterministic drift rate (units of degradation per unit time) and $q$ is a nonnegative diffusion coefficient (units of degradation squared per unit time).\n- At discrete times indexed by $k \\in \\{1,2,\\ldots,N\\}$, we define $x_k = X_{k \\Delta t}$. Measurements obey $y_k = x_k + v_k$ where $v_k \\sim \\mathcal{N}(0, r)$ are independent and identically distributed measurement noises with variance $r$ (units of degradation squared). The initial state $x_0$ has a Gaussian prior $x_0 \\sim \\mathcal{N}(m_0, P_0)$.\n\nYour program must implement the filtering distribution computation via Kalman recursion to obtain the posterior mean $m_{N\\mid N}$ and variance $P_{N\\mid N}$ of $x_N$ given measurements $\\{y_k\\}_{k=1}^N$ for each test case. Based on the filtered posterior mean, compute the expected Remaining Useful Life (RUL) to an upper failure threshold $L$ (units of degradation) under the drifted Brownian model. You must express the expected RUL in hours. Adopt the following rules for expected RUL:\n- If $m_{N\\mid N} \\ge L$, the expected RUL is $0$ hours.\n- If $m_{N\\mid N}  L$ and $\\mu \\le 0$, the expected RUL is $+\\infty$ hours.\n- If $m_{N\\mid N}  L$ and $\\mu  0$, the expected RUL is $\\dfrac{L - m_{N\\mid N}}{\\mu}$ hours.\n\nDo not use any specialized \"shortcut\" formulas for Kalman filtering in your problem statement; you must derive and implement the recursion based on linear-Gaussian state-space principles in your solution. All mathematical symbols, variables, functions, operators, and numbers must be written in LaTeX.\n\nPhysical units: report RUL in hours. Do not use percentages. No angles are involved. The final program must output a single line containing a comma-separated list enclosed in square brackets with the expected RUL values for each test case as decimal floats. When the expected RUL is infinite, print the Python floating-point representation of $+\\infty$.\n\nImplement your program for the following test suite of parameter sets, chosen to exercise different scenarios including a typical case, already-failed detection, small positive drift, negative drift, and zero drift. Each test case specifies $(\\Delta t, \\mu, q, r, m_0, P_0, L, \\{y_k\\}_{k=1}^N)$:\n\n- Test Case A (typical positive drift):\n  - $\\Delta t = 1.0$ hours,\n  - $\\mu = 0.5$ degradation per hour,\n  - $q = 0.2$ degradation squared per hour,\n  - $r = 0.5$ degradation squared,\n  - $m_0 = 0.0$ degradation,\n  - $P_0 = 1.0$ degradation squared,\n  - $L = 10.0$ degradation,\n  - Measurements $\\{y_k\\} = [0.2, 0.7, 1.3, 2.0, 2.4, 3.1, 3.9, 4.4, 5.2, 5.7]$ (degradation units).\n- Test Case B (already failed after filtering):\n  - $\\Delta t = 1.0$ hours,\n  - $\\mu = 0.6$ degradation per hour,\n  - $q = 0.1$ degradation squared per hour,\n  - $r = 0.05$ degradation squared,\n  - $m_0 = 2.5$ degradation,\n  - $P_0 = 0.2$ degradation squared,\n  - $L = 4.0$ degradation,\n  - Measurements $\\{y_k\\} = [3.0, 3.8, 4.4]$ (degradation units).\n- Test Case C (small positive drift):\n  - $\\Delta t = 0.5$ hours,\n  - $\\mu = 0.05$ degradation per hour,\n  - $q = 0.1$ degradation squared per hour,\n  - $r = 0.1$ degradation squared,\n  - $m_0 = -0.2$ degradation,\n  - $P_0 = 0.5$ degradation squared,\n  - $L = 1.0$ degradation,\n  - Measurements $\\{y_k\\} = [-0.1, 0.0, 0.1, 0.2, 0.25]$ (degradation units).\n- Test Case D (negative drift):\n  - $\\Delta t = 1.0$ hours,\n  - $\\mu = -0.1$ degradation per hour,\n  - $q = 0.3$ degradation squared per hour,\n  - $r = 0.2$ degradation squared,\n  - $m_0 = 2.0$ degradation,\n  - $P_0 = 1.0$ degradation squared,\n  - $L = 5.0$ degradation,\n  - Measurements $\\{y_k\\} = [2.1, 2.0, 1.9, 1.8, 1.7]$ (degradation units).\n- Test Case E (zero drift):\n  - $\\Delta t = 1.0$ hours,\n  - $\\mu = 0.0$ degradation per hour,\n  - $q = 0.3$ degradation squared per hour,\n  - $r = 0.5$ degradation squared,\n  - $m_0 = 1.0$ degradation,\n  - $P_0 = 0.5$ degradation squared,\n  - $L = 3.0$ degradation,\n  - Measurements $\\{y_k\\} = [1.1, 1.2, 1.25]$ (degradation units).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5]$), where each $r_i$ is the expected RUL in hours for the corresponding test case computed from the filtered posterior mean $m_{N\\mid N}$ and the above rules.",
            "solution": "The problem requires the formulation of a linear Gaussian state-space model for a degradation process and the implementation of a Kalman filter to estimate the system's state and subsequently its Remaining Useful Life (RUL). The solution is presented in three stages: first, the derivation of the discrete-time state-space model from the given continuous-time process; second, the step-by-step derivation of the Kalman filter recursion from fundamental principles; and third, the application of the RUL estimation rule.\n\n**1. State-Space Model Formulation**\n\nThe degradation process is described by a drifted Brownian motion in continuous time $t$. The latent degradation state $X_t$ evolves according to:\n$$X_{t+\\Delta t} = X_t + \\mu \\Delta t + \\sqrt{q}\\,(W_{t+\\Delta t} - W_t)$$\nwhere $\\mu$ is the drift rate, $q$ is the diffusion coefficient, and $W_t$ is a standard Wiener process whose increments are Gaussian: $W_{t+\\Delta t} - W_t \\sim \\mathcal{N}(0, \\Delta t)$.\n\nWe discretize this process by considering time points $t_k = k \\Delta t$ for $k \\in \\{0, 1, 2, \\ldots\\}$. Let the discrete-time state be $x_k = X_{t_k}$. The state evolution equation can be written as:\n$$x_k = x_{k-1} + \\mu \\Delta t + \\sqrt{q}\\,(W_{k\\Delta t} - W_{(k-1)\\Delta t})$$\nLet us define a process noise term $w_{k-1} = \\sqrt{q}\\,(W_{k\\Delta t} - W_{(k-1)\\Delta t})$. Since the Wiener increment is a random variable with mean $0$ and variance $\\Delta t$, the process noise $w_{k-1}$ is also a Gaussian random variable. Its mean is $E[w_{k-1}] = \\sqrt{q} E[W_{k\\Delta t} - W_{(k-1)\\Delta t}] = 0$. Its variance, which we denote as $Q$, is $\\text{Var}(w_{k-1}) = E[w_{k-1}^2] = q \\cdot E[(W_{k\\Delta t} - W_{(k-1)\\Delta t})^2] = q \\Delta t$. Thus, $w_{k-1} \\sim \\mathcal{N}(0, Q)$, where $Q = q \\Delta t$.\n\nThe state transition equation is therefore:\n$$x_k = x_{k-1} + \\mu \\Delta t + w_{k-1}$$\nThis equation is in the standard linear state-space form $x_k = A x_{k-1} + B u_{k-1} + w_{k-1}$. For this scalar system, the state transition matrix is $A=1$. The term $\\mu \\Delta t$ is a deterministic drift, which can be modeled as a control input $u_{k-1} = \\mu \\Delta t$ with a corresponding control matrix $B=1$.\n\nThe measurement model is given as $y_k = x_k + v_k$, where the measurement noise $v_k$ is drawn from a Gaussian distribution, $v_k \\sim \\mathcal{N}(0, r)$. This directly corresponds to the standard measurement equation $y_k = H x_k + v_k$. For this scalar system, the observation matrix is $H=1$, and the measurement noise variance is $R=r$.\n\nIn summary, the linear Gaussian state-space model is defined by:\n- State equation: $x_k = 1 \\cdot x_{k-1} + 1 \\cdot (\\mu \\Delta t) + w_{k-1}$, with $w_{k-1} \\sim \\mathcal{N}(0, q \\Delta t)$\n- Measurement equation: $y_k = 1 \\cdot x_k + v_k$, with $v_k \\sim \\mathcal{N}(0, r)$\n- Initial condition: $p(x_0) = \\mathcal{N}(x_0; m_0, P_0)$\n\n**2. Kalman Filter Recursion**\n\nThe Kalman filter provides an optimal recursive algorithm for estimating the state $x_k$ given all measurements up to time $k$, denoted by $y_{1:k} = \\{y_1, y_2, \\ldots, y_k\\}$. The filter computes the posterior probability distribution $p(x_k | y_{1:k})$, which for a linear Gaussian model is itself Gaussian: $p(x_k | y_{1:k}) = \\mathcal{N}(x_k; m_{k|k}, P_{k|k})$. The recursion proceeds in two steps for each time increment: prediction and update.\n\nWe start with the filtered estimate from the previous step, $p(x_{k-1} | y_{1:k-1}) = \\mathcal{N}(x_{k-1}; m_{k-1|k-1}, P_{k-1|k-1})$. The initial state is $m_{0|0} = m_0$ and $P_{0|0} = P_0$.\n\n**Prediction Step (Time Update):**\nThis step predicts the state at time $k$ using the model, before accounting for the new measurement $y_k$. We compute the predictive distribution $p(x_k | y_{1:k-1}) = \\mathcal{N}(x_k; m_{k|k-1}, P_{k|k-1})$.\nThe predicted mean $m_{k|k-1}$ is the expectation of the state $x_k$ conditioned on previous data:\n$$m_{k|k-1} = E[x_k | y_{1:k-1}] = E[A x_{k-1} + B u_{k-1} + w_{k-1} | y_{1:k-1}]$$\n$$m_{k|k-1} = A E[x_{k-1} | y_{1:k-1}] + B u_{k-1} = A m_{k-1|k-1} + B u_{k-1}$$\nThe predicted covariance $P_{k|k-1}$ is the variance of this prediction:\n$$P_{k|k-1} = \\text{Var}(x_k | y_{1:k-1}) = \\text{Var}(A x_{k-1} + w_{k-1} | y_{1:k-1})$$\n$$P_{k|k-1} = A \\text{Var}(x_{k-1} | y_{1:k-1}) A^T + \\text{Var}(w_{k-1}) = A P_{k-1|k-1} A^T + Q$$\n\nFor our specific scalar model, with $A=1$, $B=1$, $u_{k-1} = \\mu \\Delta t$, and $Q = q \\Delta t$:\n$$m_{k|k-1} = m_{k-1|k-1} + \\mu \\Delta t$$\n$$P_{k|k-1} = P_{k-1|k-1} + q \\Delta t$$\n\n**Update Step (Measurement Update):**\nThis step updates the predicted state and covariance using the new measurement $y_k$. We combine the predictive distribution (our prior for this step) with the likelihood of the measurement $p(y_k | x_k) = \\mathcal{N}(y_k; H x_k, R)$ via Bayes' rule to obtain the posterior $p(x_k | y_{1:k}) = \\mathcal{N}(x_k; m_{k|k}, P_{k|k})$. The update equations are:\n\n1.  Innovation (or measurement residual): $\\tilde{y}_k = y_k - E[y_k | y_{1:k-1}] = y_k - H m_{k|k-1}$. This is the difference between the actual measurement and its prediction.\n2.  Innovation covariance: $S_k = \\text{Var}(\\tilde{y}_k) = H P_{k|k-1} H^T + R$. This represents the uncertainty in the innovation.\n3.  Kalman gain: $K_k = P_{k|k-1} H^T S_k^{-1}$. The gain determines how much the prediction is corrected by the innovation. A high gain weights the measurement more, while a low gain weights the prediction more.\n4.  Updated mean: $m_{k|k} = m_{k|k-1} + K_k \\tilde{y}_k$. The predicted mean is adjusted by the weighted innovation.\n5.  Updated covariance: $P_{k|k} = (I - K_k H) P_{k|k-1}$. The prediction uncertainty is reduced by the information gained from the measurement.\n\nFor our scalar model with $H=1$ and $R=r$:\n$$\\tilde{y}_k = y_k - m_{k|k-1}$$\n$$S_k = P_{k|k-1} + r$$\n$$K_k = P_{k|k-1} (S_k)^{-1} = \\frac{P_{k|k-1}}{P_{k|k-1} + r}$$\n$$m_{k|k} = m_{k|k-1} + K_k (y_k - m_{k|k-1})$$\n$$P_{k|k} = (1 - K_k) P_{k|k-1}$$\n\nThis recursion is performed for $k=1, \\ldots, N$, yielding the final filtered estimate $(m_{N|N}, P_{N|N})$.\n\n**3. RUL Estimation**\n\nThe expected RUL is calculated from the final filtered state mean, $m_{N|N}$, which is our best estimate of the current degradation level. The future expected degradation path is assumed to follow the drift $\\mu$. The time to reach the failure threshold $L$ from the current state is calculated based on the following rules:\n\n- If $m_{N|N} \\ge L$: The estimated degradation has already reached or exceeded the failure threshold. The expected RUL is $0$ hours.\n- If $m_{N|N}  L$ and $\\mu \\le 0$: The degradation is not expected to increase (it may decrease or stay constant on average). Therefore, the threshold $L$ is not expected to be reached. The expected RUL is considered infinite, $+\\infty$ hours.\n- If $m_{N|N}  L$ and $\\mu  0$: The degradation is expected to increase at a rate of $\\mu$ units per hour. The remaining amount of degradation until failure is $\\Delta_L = L - m_{N|N}$. The expected time to cover this amount is:\n$$ \\text{RUL} = \\frac{\\Delta_L}{\\mu} = \\frac{L - m_{N|N}}{\\mu} \\text{ hours} $$\n\nThe implementation will apply these state-space, Kalman filter, and RUL equations to each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Remaining Useful Life (RUL) estimation problem for a series of test cases.\n    \"\"\"\n\n    # Each test case is a dictionary specifying the parameters for the degradation model and Kalman filter.\n    # The format is: (delta_t, mu, q, r, m0, P0, L, measurements) in SI-like units.\n    test_cases = [\n        # Test Case A (typical positive drift)\n        {\n            \"delta_t\": 1.0,  # hours\n            \"mu\": 0.5,      # degradation per hour\n            \"q\": 0.2,       # degradation^2 per hour\n            \"r\": 0.5,       # degradation^2\n            \"m0\": 0.0,      # degradation\n            \"P0\": 1.0,      # degradation^2\n            \"L\": 10.0,      # degradation\n            \"y\": [0.2, 0.7, 1.3, 2.0, 2.4, 3.1, 3.9, 4.4, 5.2, 5.7]  # degradation\n        },\n        # Test Case B (already failed after filtering)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": 0.6,\n            \"q\": 0.1,\n            \"r\": 0.05,\n            \"m0\": 2.5,\n            \"P0\": 0.2,\n            \"L\": 4.0,\n            \"y\": [3.0, 3.8, 4.4]\n        },\n        # Test Case C (small positive drift)\n        {\n            \"delta_t\": 0.5,\n            \"mu\": 0.05,\n            \"q\": 0.1,\n            \"r\": 0.1,\n            \"m0\": -0.2,\n            \"P0\": 0.5,\n            \"L\": 1.0,\n            \"y\": [-0.1, 0.0, 0.1, 0.2, 0.25]\n        },\n        # Test Case D (negative drift)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": -0.1,\n            \"q\": 0.3,\n            \"r\": 0.2,\n            \"m0\": 2.0,\n            \"P0\": 1.0,\n            \"L\": 5.0,\n            \"y\": [2.1, 2.0, 1.9, 1.8, 1.7]\n        },\n        # Test Case E (zero drift)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": 0.0,\n            \"q\": 0.3,\n            \"r\": 0.5,\n            \"m0\": 1.0,\n            \"P0\": 0.5,\n            \"L\": 3.0,\n            \"y\": [1.1, 1.2, 1.25]\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        rul = calculate_rul_with_kalman_filter(params)\n        results.append(rul)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The map(str, ...) ensures that infinity is printed as 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_rul_with_kalman_filter(params):\n    \"\"\"\n    Computes the filtered state and RUL for a single degradation process.\n\n    Args:\n        params (dict): A dictionary containing all model parameters.\n\n    Returns:\n        float: The estimated Remaining Useful Life in hours.\n    \"\"\"\n    # Extract parameters for clarity\n    delta_t = params[\"delta_t\"]\n    mu = params[\"mu\"]\n    q = params[\"q\"]\n    r = params[\"r\"]\n    m_current = params[\"m0\"]\n    P_current = params[\"P0\"]\n    L = params[\"L\"]\n    measurements = params[\"y\"]\n\n    # --- State-Space Model Parameters for the scalar case ---\n    # According to the derivation: x_k = A*x_{k-1} + B*u_{k-1} + w_{k-1}\n    # A = 1 (State transition matrix)\n    # B = 1 (Control input matrix)\n    # u = mu * delta_t (Control input, deterministic drift part)\n    # Q = q * delta_t (Process noise variance)\n    # According to the derivation: y_k = H*x_k + v_k\n    # H = 1 (Observation matrix)\n    # R = r (Measurement noise variance)\n    u_input = mu * delta_t\n    Q_noise_var = q * delta_t\n\n    # --- Kalman Filter Recursion ---\n    for y_k in measurements:\n        # 1. Prediction (Time Update)\n        m_predicted = m_current + u_input\n        P_predicted = P_current + Q_noise_var\n\n        # 2. Update (Measurement Update)\n        # Innovation (residual)\n        y_tilde = y_k - m_predicted\n        # Innovation covariance\n        S = P_predicted + r\n        # Kalman gain\n        K = P_predicted / S\n        # Updated state mean\n        m_current = m_predicted + K * y_tilde\n        # Updated state covariance\n        P_current = (1 - K) * P_predicted\n    \n    # Final filtered mean is m_current, which is m_{N|N}\n    m_N_N = m_current\n\n    # --- RUL Calculation ---\n    if m_N_N >= L:\n        # Already failed\n        return 0.0\n    elif m_N_N  L and mu = 0:\n        # Degradation is not expected to increase, will not reach threshold\n        return float('inf')\n    else:  # m_N_N  L and mu > 0\n        # Expected time to reach threshold L with positive drift mu\n        return (L - m_N_N) / mu\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "Many real-world degradation processes are inherently nonlinear, requiring more advanced techniques than the standard Kalman filter. In this final practice , you will implement an Extended Kalman Filter (EKF) to tackle a nonlinear degradation model. This exercise will not only teach you how to adapt filtering techniques for nonlinear dynamics but also how to perform open-loop prediction to forecast the evolution of the RUL and its associated uncertainty, a critical component of robust decision-making in predictive maintenance.",
            "id": "4240296",
            "problem": "Consider a single-degree-of-freedom degradation state modeled in discrete time by a nonlinear state transition with process noise and a direct measurement with measurement noise. Let the state be the cumulative damage index $x_k \\in \\mathbb{R}$ at discrete time $k$, with control input $u_k \\in \\mathbb{R}$. The dynamics are defined by\n$$\nx_{k+1} = f(x_k, u_k) + w_k,\n$$\nwhere $w_k$ is zero-mean Gaussian process noise with variance $Q$, and\n$$\nf(x, u) = x + \\alpha \\, u^{\\beta} \\, \\Delta t + \\gamma \\, x^2 \\, \\Delta t.\n$$\nMeasurements are given by\n$$\nz_k = h(x_k) + v_k,\\quad h(x)=x,\n$$\nwhere $v_k$ is zero-mean Gaussian measurement noise with variance $R$. The failure threshold is $L \\in \\mathbb{R}$, expressed as the unitless damage index at which the system is considered to have failed.\n\nYou must implement an Extended Kalman Filter (EKF) to update the prior belief at $k=0$ using the single measurement $z_0$, then perform open-loop prediction over a finite horizon of length $H$ steps using the given input sequence $\\{u_k\\}_{k=0}^{H-1}$. At each prediction step $k$, you must compute:\n- the predicted Remaining Useful Life (RUL) in hours, by locally linearizing the threshold-crossing time from the current predicted belief, and\n- the associated RUL variance in hours squared, by first-order uncertainty propagation.\n\nYou must assume that the RUL is the time until the predicted state trajectory, under the locally frozen degradation rate, reaches the threshold $L$. If the predicted degradation rate becomes arbitrarily small, guard against division by zero in your implementation in a scientifically sensible way. If the predicted state mean is at or above the threshold, report the RUL as zero hours with zero variance at that step.\n\nAll physical quantities must be handled in their proper units: $x_k$ and $L$ are dimensionless damage indices; $\\Delta t$ is in hours; the final RUL must be expressed in hours. Your program must output the RUL trajectory and the corresponding variance trajectory over the prediction horizon for each test case, with the RUL values rounded to $4$ decimal places and the variances rounded to $6$ decimal places.\n\nUse the following test suite with fixed parameters for each case. In all cases, the horizon is $H=8$ and the time step is $\\Delta t = 1.0$ hours.\n\nTest case $1$ (typical conditions):\n- $\\alpha = 0.08$, $\\beta = 1.4$, $\\gamma = 0.002$\n- $Q = 0.0001$, $R = 0.00025$\n- $L = 1.0$\n- Prior mean $x_{0|{-1}} = 0.20$, prior variance $P_{0|{-1}} = 0.01$\n- Measurement $z_0 = 0.22$\n- Input sequence $\\{u_k\\}_{k=0}^{7} = [0.60, 0.65, 0.70, 0.70, 0.72, 0.75, 0.75, 0.80]$\n\nTest case $2$ (near-threshold boundary):\n- $\\alpha = 0.08$, $\\beta = 1.4$, $\\gamma = 0.002$\n- $Q = 0.0001$, $R = 0.00025$\n- $L = 1.0$\n- Prior mean $x_{0|{-1}} = 0.90$, prior variance $P_{0|{-1}} = 0.005$\n- Measurement $z_0 = 0.88$\n- Input sequence $\\{u_k\\}_{k=0}^{7} = [0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50]$\n\nTest case $3$ (low-load, slow degradation edge case):\n- $\\alpha = 0.08$, $\\beta = 1.4$, $\\gamma = 0.002$\n- $Q = 0.0001$, $R = 0.00025$\n- $L = 1.0$\n- Prior mean $x_{0|{-1}} = 0.05$, prior variance $P_{0|{-1}} = 0.02$\n- Measurement $z_0 = 0.04$\n- Input sequence $\\{u_k\\}_{k=0}^{7} = [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]$\n\nFinal output format specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element corresponds to one test case and must itself be a list containing two lists: the first is the $H$-length list of RUL means (in hours, rounded to $4$ decimal places), and the second is the $H$-length list of the corresponding RUL variances (in hours squared, rounded to $6$ decimal places). Concretely, the output is\n$$\n[ [ \\text{RULs}_1, \\text{Vars}_1 ], [ \\text{RULs}_2, \\text{Vars}_2 ], [ \\text{RULs}_3, \\text{Vars}_3 ] ],\n$$\nwhere $\\text{RULs}_i$ and $\\text{Vars}_i$ are lists of $H$ floating-point numbers for test case $i$.",
            "solution": "The problem requires implementing an Extended Kalman Filter (EKF) to first update a prior belief about a system's degradation state using a measurement, and then to perform an open-loop prediction of the Remaining Useful Life (RUL) and its variance over a finite horizon.\n\nThe solution proceeds in two primary phases:\n1.  **EKF Update**: The initial prior belief of the system's state at time $k=0$, given by the mean $x_{0|{-1}}$ and variance $P_{0|{-1}}$, is updated using the measurement $z_0$ to produce the posterior (filtered) belief $(x_{0|0}, P_{0|0})$.\n2.  **Open-Loop Prediction and RUL Estimation**: Starting from the posterior state at $k=0$, an open-loop prediction is performed for a horizon of $H$ steps. At each step $k$ in the horizon, the predicted state $(\\hat{x}_{k|0}, \\hat{P}_{k|0})$ is used to compute the RUL and its associated variance. The state is then propagated to the next time step, $k+1$.\n\nHereafter, we denote the state estimate and its variance at prediction step $k$ as $(\\hat{x}_k, \\hat{P}_k)$.\n\n**1. EKF Update at Time `k=0`**\n\nGiven the prior state estimate $x_{0|{-1}}$ and its variance $P_{0|{-1}}$, and a measurement $z_0$, we update the state. The measurement model is linear:\n$$\nz_k = h(x_k) + v_k \\quad \\text{with} \\quad h(x_k) = x_k\n$$\nThe Jacobian of the measurement function, $H_k$, is the derivative of $h(x)$ with respect to $x$, which is simply $1$.\n$$\nH_k = \\frac{\\partial h}{\\partial x} \\bigg|_{\\hat{x}_k} = 1\n$$\nThe EKF update equations for a linear measurement model are identical to the standard Kalman filter equations:\n- **Innovation Covariance ($S_0$)**: $S_0 = H_0 P_{0|{-1}} H_0^T + R = P_{0|{-1}} + R$\n- **Kalman Gain ($K_0$)**: $K_0 = P_{0|{-1}} H_0^T S_0^{-1} = P_{0|{-1}} (P_{0|{-1}} + R)^{-1}$\n- **Posterior State Mean ($x_{0|0}$ or $\\hat{x}_0$)**: $\\hat{x}_0 = x_{0|{-1}} + K_0 (z_0 - x_{0|{-1}})$\n- **Posterior State Variance ($P_{0|0}$ or $\\hat{P}_0$)**: $\\hat{P}_0 = (I - K_0 H_0) P_{0|{-1}} = (1 - K_0) P_{0|{-1}}$\n\nThis gives the initial state $(\\hat{x}_0, \\hat{P}_0)$ for the prediction horizon.\n\n**2. Prediction Loop and RUL Estimation (`k = 0, ..., H-1`)**\n\nFor each step $k$ in the prediction horizon, we perform two tasks: RUL estimation based on the current state $(\\hat{x}_k, \\hat{P}_k)$, and prediction of the next state $(\\hat{x}_{k+1}, \\hat{P}_{k+1})$.\n\n**a. RUL Estimation at Step `k`**\n\nThe RUL is defined as the time it takes for the damage index to reach the failure threshold $L$, assuming the degradation rate is \"locally frozen\" at its current value. The continuous-time degradation rate is $\\frac{dx}{dt} = \\alpha u^\\beta + \\gamma x^2$. We evaluate this rate at the state mean $\\hat{x}_k$ using the input $u_k$.\n$$\n\\text{rate}_k = \\dot{x}_k = \\alpha u_k^{\\beta} + \\gamma \\hat{x}_k^2\n$$\n- **RUL Mean**: The time to failure is the remaining damage capacity divided by the rate. Since $\\Delta t$ is in hours, the rate's units are hours$^{-1}$, and the RUL is in hours.\n$$\n\\text{RUL}_k = \\frac{L - \\hat{x}_k}{\\dot{x}_k} = \\frac{L - \\hat{x}_k}{\\alpha u_k^{\\beta} + \\gamma \\hat{x}_k^2}\n$$\nIf $\\hat{x}_k \\ge L$, the RUL is set to $0$. To prevent division by zero, the denominator is floored at a small positive value $\\epsilon > 0$.\n\n- **RUL Variance**: We use first-order uncertainty propagation. The RUL is a function $\\rho(x_k)$ of the random variable $x_k$ (which has mean $\\hat{x}_k$ and variance $\\hat{P}_k$).\n$$\n\\text{Var}(\\text{RUL}_k) \\approx \\left( \\frac{\\partial \\rho}{\\partial x} \\bigg|_{\\hat{x}_k} \\right)^2 \\hat{P}_k\n$$\nThe required Jacobian (derivative) is calculated using the quotient rule:\n$$\n\\frac{\\partial \\rho}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\frac{L-x}{\\alpha u_k^{\\beta} + \\gamma x^2} \\right) = \\frac{-1(\\alpha u_k^{\\beta} + \\gamma x^2) - (L-x)(2\\gamma x)}{(\\alpha u_k^{\\beta} + \\gamma x^2)^2} = \\frac{-\\alpha u_k^{\\beta} + \\gamma x^2 - 2\\gamma L x}{(\\alpha u_k^{\\beta} + \\gamma x^2)^2}\n$$\nThe variance is then computed by squaring this Jacobian evaluated at $\\hat{x}_k$ and multiplying by $\\hat{P}_k$. If $\\hat{x}_k \\ge L$, the variance is $0$.\n\n**b. State Prediction for Step `k+1`**\n\nThe state is propagated using the nonlinear state transition function $f(x, u) = x + (\\alpha u^{\\beta} + \\gamma x^2)\\Delta t$. The EKF propagates the mean through the nonlinear function and the variance through its linearization.\n$$\n\\hat{x}_{k+1} = f(\\hat{x}_k, u_k) = \\hat{x}_k + (\\alpha u_k^{\\beta} + \\gamma \\hat{x}_k^2)\\Delta t\n$$\nThe variance is propagated using the Jacobian of the state transition function, $F_k$:\n$$\nF_k = \\frac{\\partial f}{\\partial x} \\bigg|_{\\hat{x}_k, u_k} = 1 + 2\\gamma \\hat{x}_k \\Delta t\n$$\nThe predicted variance $\\hat{P}_{k+1}$ is then:\n$$\n\\hat{P}_{k+1} = F_k \\hat{P}_k F_k^T + Q = (1 + 2\\gamma \\hat{x}_k \\Delta t)^2 \\hat{P}_k + Q\n$$\nwhere $Q$ is the process noise variance. This procedure is iterated for $k$ from $0$ to $H-1$, generating a trajectory of RUL estimates and their variances.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(alpha, beta, gamma, Q, R, L, x0_prior, P0_prior, z0, u_seq, H, dt):\n    \"\"\"\n    Performs EKF update and open-loop RUL prediction for a single test case.\n    \"\"\"\n    \n    # EKF Update at k=0\n    # Measurement is linear: h(x) = x, so Jacobian H_k = 1\n    S0 = P0_prior + R\n    K0 = P0_prior / S0\n    x0_posterior = x0_prior + K0 * (z0 - x0_prior)\n    P0_posterior = (1.0 - K0) * P0_prior\n\n    x_hat = x0_posterior\n    P_hat = P0_posterior\n\n    rul_trajectory = []\n    var_trajectory = []\n\n    # Small epsilon to avoid division by zero\n    epsilon = 1e-9\n\n    # Prediction Loop\n    for k in range(H):\n        u_k = u_seq[k]\n\n        # RUL Calculation at step k\n        if x_hat >= L:\n            rul_k = 0.0\n            var_k = 0.0\n        else:\n            # Degradation rate (per hour)\n            degradation_rate = alpha * np.power(u_k, beta) + gamma * np.power(x_hat, 2)\n            \n            # Guard against division by zero\n            if degradation_rate  epsilon:\n                degradation_rate = epsilon\n\n            # RUL mean (in hours)\n            rul_k = (L - x_hat) / degradation_rate\n\n            # RUL variance (in hours^2)\n            # Jacobian of RUL function w.r.t. x\n            numerator_j_rul = -alpha * np.power(u_k, beta) + gamma * np.power(x_hat, 2) - 2 * gamma * L * x_hat\n            denominator_j_rul = np.power(degradation_rate, 2)\n            j_rul = numerator_j_rul / denominator_j_rul\n\n            var_k = np.power(j_rul, 2) * P_hat\n\n        rul_trajectory.append(rul_k)\n        var_trajectory.append(var_k)\n\n        # State Prediction for step k+1\n        # Jacobian of state transition function f(x,u) w.r.t. x\n        F_k = 1.0 + 2.0 * gamma * x_hat * dt\n        \n        # Predict next state mean\n        x_hat_next = x_hat + (alpha * np.power(u_k, beta) + gamma * np.power(x_hat, 2)) * dt\n        \n        # Predict next state variance\n        P_hat_next = np.power(F_k, 2) * P_hat + Q\n        \n        x_hat = x_hat_next\n        P_hat = P_hat_next\n        \n    return rul_trajectory, var_trajectory\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and format the output.\n    \"\"\"\n    test_cases = [\n        {\n            \"alpha\": 0.08, \"beta\": 1.4, \"gamma\": 0.002, \"Q\": 0.0001, \"R\": 0.00025, \"L\": 1.0, \n            \"x0_prior\": 0.20, \"P0_prior\": 0.01, \"z0\": 0.22,\n            \"u_seq\": [0.60, 0.65, 0.70, 0.70, 0.72, 0.75, 0.75, 0.80]\n        },\n        {\n            \"alpha\": 0.08, \"beta\": 1.4, \"gamma\": 0.002, \"Q\": 0.0001, \"R\": 0.00025, \"L\": 1.0,\n            \"x0_prior\": 0.90, \"P0_prior\": 0.005, \"z0\": 0.88,\n            \"u_seq\": [0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50]\n        },\n        {\n            \"alpha\": 0.08, \"beta\": 1.4, \"gamma\": 0.002, \"Q\": 0.0001, \"R\": 0.00025, \"L\": 1.0,\n            \"x0_prior\": 0.05, \"P0_prior\": 0.02, \"z0\": 0.04,\n            \"u_seq\": [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]\n        }\n    ]\n    H = 8\n    dt = 1.0\n\n    all_results = []\n    for params in test_cases:\n        ruls, variances = run_simulation(\n            params[\"alpha\"], params[\"beta\"], params[\"gamma\"],\n            params[\"Q\"], params[\"R\"], params[\"L\"],\n            params[\"x0_prior\"], params[\"P0_prior\"], params[\"z0\"],\n            params[\"u_seq\"], H, dt\n        )\n        all_results.append([ruls, variances])\n\n    # Manually format the output string to match the required format without spaces.\n    case_strings = []\n    for case_result in all_results:\n        # case_result is a list: [ list_of_ruls, list_of_variances ]\n        ruls, variances = case_result\n        ruls_str = f\"[{','.join([f'{r:.4f}' for r in ruls])}]\"\n        vars_str = f\"[{','.join([f'{v:.6f}' for v in variances])}]\"\n        case_strings.append(f\"[{ruls_str},{vars_str}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}