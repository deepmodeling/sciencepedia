{
    "hands_on_practices": [
        {
            "introduction": "在掌握了基本的线性外推法之后，我们进一步深入到概率预后学的核心。简单的趋势拟合无法系统地处理退化过程中的内在随机性以及测量数据中存在的噪声。本练习  引入了一个更为精密的框架：将退化过程建模为一个带有漂移的布朗运动，并应用卡尔曼滤波器来解决这个问题。你将学习如何构建线性高斯状态空间模型，并实现卡尔曼递归算法，从一系列带噪声的测量中最优地估计系统的潜在退化状态，最终基于这个经过滤波的状态来预测RUL。",
            "id": "4240318",
            "problem": "您的任务是形式化一个退化跟踪数字孪生模型，并在一个信息物理系统 (CPS) 中实现一个用于剩余使用寿命 (RUL) 估计的计算程序。潜在的退化过程被建模为一个通过含噪声的测量观测到的带漂移的布朗运动。形式上，潜在退化状态 $x_k$ 以大小为 $\\Delta t$ 的离散时间步演化，遵循一个从带漂移的维纳过程派生出的线性高斯状态空间表示。潜在状态 $x_k$ 只能通过一个被加性高斯噪声污染的测量值 $y_k$ 观测到，并且初始状态是不确定的。\n\n从基本原理出发，使用以下基础构建线性高斯状态空间模型：\n\n- 连续时间维纳过程（布朗运动）$W_t$ 具有独立增量，且 $W_{t+\\Delta t} - W_t \\sim \\mathcal{N}(0, \\Delta t)$。\n- 一个带漂移的布朗退化过程 $X_t$ 遵循 $X_{t+\\Delta t} = X_t + \\mu \\Delta t + \\sqrt{q}\\,(W_{t+\\Delta t} - W_t)$，其中 $\\mu$ 是一个确定性漂移率（单位：退化单位/每单位时间），$q$ 是一个非负扩散系数（单位：退化单位的平方/每单位时间）。\n- 在由 $k \\in \\{1,2,\\ldots,N\\}$ 索引的离散时间点，我们定义 $x_k = X_{k \\Delta t}$。测量值遵循 $y_k = x_k + v_k$，其中 $v_k \\sim \\mathcal{N}(0, r)$ 是独立同分布的测量噪声，其方差为 $r$（单位：退化单位的平方）。初始状态 $x_0$ 具有高斯先验 $x_0 \\sim \\mathcal{N}(m_0, P_0)$。\n\n您的程序必须通过卡尔曼递归实现滤波分布计算，以针对每个测试用例，在给定测量值 $\\{y_k\\}_{k=1}^N$ 的条件下，获得 $x_N$ 的后验均值 $m_{N\\mid N}$ 和方差 $P_{N\\mid N}$。基于滤波后验均值，在带漂移的布朗模型下，计算到达失效阈值上限 $L$（单位：退化单位）的期望剩余使用寿命 (RUL)。您必须以小时为单位表示期望 RUL。采用以下规则计算期望 RUL：\n- 如果 $m_{N\\mid N} \\ge L$，期望 RUL 为 $0$ 小时。\n- 如果 $m_{N\\mid N}  L$ 且 $\\mu \\le 0$，期望 RUL 为 $+\\infty$ 小时。\n- 如果 $m_{N\\mid N}  L$ 且 $\\mu > 0$，期望 RUL 为 $\\dfrac{L - m_{N\\mid N}}{\\mu}$ 小时。\n\n请勿在您的问题陈述中使用任何专门的卡尔曼滤波“快捷”公式；您必须在您的解决方案中基于线性高斯状态空间原理推导并实现该递归。所有数学符号、变量、函数、运算符和数字都必须用 LaTeX 书写。\n\n物理单位：以小时报告 RUL。不要使用百分比。不涉及角度。最终程序必须输出一行，其中包含一个用方括号括起来的逗号分隔列表，其中包含每个测试用例的期望 RUL 值（作为十进制浮点数）。当期望 RUL 为无穷大时，打印 Python 的 $+\\infty$ 浮点数表示。\n\n请为以下参数集测试套件实现您的程序，这些参数集旨在测试不同场景，包括典型情况、已失效检测、小正漂移、负漂移和零漂移。每个测试用例指定 $(\\Delta t, \\mu, q, r, m_0, P_0, L, \\{y_k\\}_{k=1}^N)$：\n\n- 测试用例 A (典型正漂移):\n  - $\\Delta t = 1.0$ 小时,\n  - $\\mu = 0.5$ 退化单位/小时,\n  - $q = 0.2$ 退化单位的平方/小时,\n  - $r = 0.5$ 退化单位的平方,\n  - $m_0 = 0.0$ 退化单位,\n  - $P_0 = 1.0$ 退化单位的平方,\n  - $L = 10.0$ 退化单位,\n  - 测量值 $\\{y_k\\} = [0.2, 0.7, 1.3, 2.0, 2.4, 3.1, 3.9, 4.4, 5.2, 5.7]$ (退化单位)。\n- 测试用例 B (滤波后已失效):\n  - $\\Delta t = 1.0$ 小时,\n  - $\\mu = 0.6$ 退化单位/小时,\n  - $q = 0.1$ 退化单位的平方/小时,\n  - $r = 0.05$ 退化单位的平方,\n  - $m_0 = 2.5$ 退化单位,\n  - $P_0 = 0.2$ 退化单位的平方,\n  - $L = 4.0$ 退化单位,\n  - 测量值 $\\{y_k\\} = [3.0, 3.8, 4.4]$ (退化单位)。\n- 测试用例 C (小正漂移):\n  - $\\Delta t = 0.5$ 小时,\n  - $\\mu = 0.05$ 退化单位/小时,\n  - $q = 0.1$ 退化单位的平方/小时,\n  - $r = 0.1$ 退化单位的平方,\n  - $m_0 = -0.2$ 退化单位,\n  - $P_0 = 0.5$ 退化单位的平方,\n  - $L = 1.0$ 退化单位,\n  - 测量值 $\\{y_k\\} = [-0.1, 0.0, 0.1, 0.2, 0.25]$ (退化单位)。\n- 测试用例 D (负漂移):\n  - $\\Delta t = 1.0$ 小时,\n  - $\\mu = -0.1$ 退化单位/小时,\n  - $q = 0.3$ 退化单位的平方/小时,\n  - $r = 0.2$ 退化单位的平方,\n  - $m_0 = 2.0$ 退化单位,\n  - $P_0 = 1.0$ 退化单位的平方,\n  - $L = 5.0$ 退化单位,\n  - 测量值 $\\{y_k\\} = [2.1, 2.0, 1.9, 1.8, 1.7]$ (退化单位)。\n- 测试用例 E (零漂移):\n  - $\\Delta t = 1.0$ 小时,\n  - $\\mu = 0.0$ 退化单位/小时,\n  - $q = 0.3$ 退化单位的平方/小时,\n  - $r = 0.5$ 退化单位的平方,\n  - $m_0 = 1.0$ 退化单位,\n  - $P_0 = 0.5$ 退化单位的平方,\n  - $L = 3.0$ 退化单位,\n  - 测量值 $\\{y_k\\} = [1.1, 1.2, 1.25]$ (退化单位)。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）的结果，其中每个 $r_i$ 是根据滤波后验均值 $m_{N\\mid N}$ 和上述规则计算出的相应测试用例的期望 RUL（以小时为单位）。",
            "solution": "该问题要求为一个退化过程构建线性高斯状态空间模型，并实现一个卡尔曼滤波器来估计系统状态，进而估算其剩余使用寿命 (RUL)。解决方案分三个阶段呈现：首先，从给定的连续时间过程推导离散时间状态空间模型；其次，从基本原理分步推导卡尔曼滤波递归；第三，应用 RUL 估算规则。\n\n**1. 状态空间模型构建**\n\n退化过程由连续时间 $t$ 中的带漂移布朗运动描述。潜在退化状态 $X_t$ 根据以下公式演化：\n$$X_{t+\\Delta t} = X_t + \\mu \\Delta t + \\sqrt{q}\\,(W_{t+\\Delta t} - W_t)$$\n其中 $\\mu$ 是漂移率， $q$ 是扩散系数，而 $W_t$ 是一个标准维纳过程，其增量是高斯的：$W_{t+\\Delta t} - W_t \\sim \\mathcal{N}(0, \\Delta t)$。\n\n我们通过考虑时间点 $t_k = k \\Delta t$（对于 $k \\in \\{0, 1, 2, \\ldots\\}$）来离散化这个过程。设离散时间状态为 $x_k = X_{t_k}$。状态演化方程可以写为：\n$$x_k = x_{k-1} + \\mu \\Delta t + \\sqrt{q}\\,(W_{k\\Delta t} - W_{(k-1)\\Delta t})$$\n我们定义一个过程噪声项 $w_{k-1} = \\sqrt{q}\\,(W_{k\\Delta t} - W_{(k-1)\\Delta t})$。由于维纳增量是一个均值为 $0$、方差为 $\\Delta t$ 的随机变量，过程噪声 $w_{k-1}$ 也是一个高斯随机变量。其均值为 $E[w_{k-1}] = \\sqrt{q} E[W_{k\\Delta t} - W_{(k-1)\\Delta t}] = 0$。其方差（我们表示为 $Q$）为 $\\text{Var}(w_{k-1}) = E[w_{k-1}^2] = q \\cdot E[(W_{k\\Delta t} - W_{(k-1)\\Delta t})^2] = q \\Delta t$。因此，$w_{k-1} \\sim \\mathcal{N}(0, Q)$，其中 $Q = q \\Delta t$。\n\n因此，状态转移方程为：\n$$x_k = x_{k-1} + \\mu \\Delta t + w_{k-1}$$\n这个方程是标准线性状态空间形式 $x_k = A x_{k-1} + B u_{k-1} + w_{k-1}$。对于这个标量系统，状态转移矩阵为 $A=1$。项 $\\mu \\Delta t$ 是一个确定性漂移，可以建模为控制输入 $u_{k-1} = \\mu \\Delta t$，相应的控制矩阵为 $B=1$。\n\n测量模型给出为 $y_k = x_k + v_k$，其中测量噪声 $v_k$ 从高斯分布中抽取，$v_k \\sim \\mathcal{N}(0, r)$。这直接对应于标准测量方程 $y_k = H x_k + v_k$。对于这个标量系统，观测矩阵为 $H=1$，测量噪声方差为 $R=r$。\n\n初始状态 $x_0$ 假定具有高斯先验分布 $x_0 \\sim \\mathcal{N}(m_0, P_0)$。\n\n总结来说，线性高斯状态空间模型由以下部分定义：\n- 状态方程：$x_k = 1 \\cdot x_{k-1} + 1 \\cdot (\\mu \\Delta t) + w_{k-1}$，其中 $w_{k-1} \\sim \\mathcal{N}(0, q \\Delta t)$\n- 测量方程：$y_k = 1 \\cdot x_k + v_k$，其中 $v_k \\sim \\mathcal{N}(0, r)$\n- 初始条件：$p(x_0) = \\mathcal{N}(x_0; m_0, P_0)$\n\n**2. 卡尔曼滤波递归**\n\n卡尔曼滤波器提供了一种最优递归算法，用于在给定截至时间 $k$ 的所有测量值 $y_{1:k} = \\{y_1, y_2, \\ldots, y_k\\}$ 的情况下估计状态 $x_k$。该滤波器计算后验概率分布 $p(x_k | y_{1:k})$，对于线性高斯模型，该分布本身是高斯的：$p(x_k | y_{1:k}) = \\mathcal{N}(x_k; m_{k|k}, P_{k|k})$。递归在每个时间增量中分两步进行：预测和更新。\n\n我们从上一步的滤波估计开始，$p(x_{k-1} | y_{1:k-1}) = \\mathcal{N}(x_{k-1}; m_{k-1|k-1}, P_{k-1|k-1})$。初始状态为 $m_{0|0} = m_0$ 和 $P_{0|0} = P_0$。\n\n**预测步骤（时间更新）：**\n此步骤在考虑新测量值 $y_k$ 之前，使用模型预测时间 $k$ 的状态。我们计算预测分布 $p(x_k | y_{1:k-1}) = \\mathcal{N}(x_k; m_{k|k-1}, P_{k|k-1})$。\n预测均值 $m_{k|k-1}$ 是状态 $x_k$ 在给定先前数据条件下的期望值：\n$$m_{k|k-1} = E[x_k | y_{1:k-1}] = E[A x_{k-1} + B u_{k-1} + w_{k-1} | y_{1:k-1}]$$\n$$m_{k|k-1} = A E[x_{k-1} | y_{1:k-1}] + B u_{k-1} = A m_{k-1|k-1} + B u_{k-1}$$\n预测协方差 $P_{k|k-1}$ 是此预测的方差：\n$$P_{k|k-1} = \\text{Var}(x_k | y_{1:k-1}) = \\text{Var}(A x_{k-1} + w_{k-1} | y_{1:k-1})$$\n$$P_{k|k-1} = A \\text{Var}(x_{k-1} | y_{1:k-1}) A^T + \\text{Var}(w_{k-1}) = A P_{k-1|k-1} A^T + Q$$\n\n对于我们的特定标量模型，其中 $A=1$，$B=1$，$u_{k-1} = \\mu \\Delta t$，以及 $Q = q \\Delta t$：\n$$m_{k|k-1} = m_{k-1|k-1} + \\mu \\Delta t$$\n$$P_{k|k-1} = P_{k-1|k-1} + q \\Delta t$$\n\n**更新步骤（测量更新）：**\n此步骤使用新的测量值 $y_k$ 来更新预测的状态和协方差。我们通过贝叶斯法则将预测分布（此步骤的先验）与测量的似然 $p(y_k | x_k) = \\mathcal{N}(y_k; H x_k, R)$ 相结合，以获得后验 $p(x_k | y_{1:k}) = \\mathcal{N}(x_k; m_{k|k}, P_{k|k})$。更新方程如下：\n\n1. 新息（或测量残差）：$\\tilde{y}_k = y_k - E[y_k | y_{1:k-1}] = y_k - H m_{k|k-1}$。这是实际测量值与其预测值之间的差异。\n2. 新息协方差：$S_k = \\text{Var}(\\tilde{y}_k) = H P_{k|k-1} H^T + R$。这表示新息中的不确定性。\n3. 卡尔曼增益：$K_k = P_{k|k-1} H^T S_k^{-1}$。增益决定了预测被新息修正的程度。高增益更看重测量值，而低增益更看重预测值。\n4. 更新后均值：$m_{k|k} = m_{k|k-1} + K_k \\tilde{y}_k$。预测均值由加权新息进行调整。\n5. 更新后协方差：$P_{k|k} = (I - K_k H) P_{k|k-1}$。通过从测量中获得的信息来减少预测的不确定性。\n\n对于我们的标量模型，其中 $H=1$ 和 $R=r$：\n$$\\tilde{y}_k = y_k - m_{k|k-1}$$\n$$S_k = P_{k|k-1} + r$$\n$$K_k = P_{k|k-1} (S_k)^{-1} = \\frac{P_{k|k-1}}{P_{k|k-1} + r}$$\n$$m_{k|k} = m_{k|k-1} + K_k (y_k - m_{k|k-1})$$\n$$P_{k|k} = (1 - K_k) P_{k|k-1}$$\n\n对 $k=1, \\ldots, N$ 执行此递归，得到最终的滤波估计 $(m_{N|N}, P_{N|N})$。\n\n**3. RUL 估算**\n\n期望 RUL 是根据最终的滤波状态均值 $m_{N|N}$ 计算的，这是我们对当前退化水平的最佳估计。未来期望的退化路径假定遵循漂移 $\\mu$。从当前状态达到失效阈值 $L$ 的时间根据以下规则计算：\n\n- 如果 $m_{N|N} \\ge L$：估计的退化程度已经达到或超过了失效阈值。期望 RUL 为 $0$ 小时。\n- 如果 $m_{N|N}  L$ 且 $\\mu \\le 0$：退化预计不会增加（平均而言可能减少或保持不变）。因此，预计不会达到阈值 $L$。期望 RUL 被认为是无限的，即 $+\\infty$ 小时。\n- 如果 $m_{N|N}  L$ 且 $\\mu > 0$：退化预计以每小时 $\\mu$ 个单位的速率增加。距离失效的剩余退化量为 $\\Delta_L = L - m_{N|N}$。覆盖此退化量所需的期望时间是：\n$$ \\text{RUL} = \\frac{\\Delta_L}{\\mu} = \\frac{L - m_{N|N}}{\\mu} \\text{ 小时} $$\n\n该实现将把这些状态空间、卡尔曼滤波和 RUL 方程应用于每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Remaining Useful Life (RUL) estimation problem for a series of test cases.\n    \"\"\"\n\n    # Each test case is a dictionary specifying the parameters for the degradation model and Kalman filter.\n    # The format is: (delta_t, mu, q, r, m0, P0, L, measurements) in SI-like units.\n    test_cases = [\n        # Test Case A (typical positive drift)\n        {\n            \"delta_t\": 1.0,  # hours\n            \"mu\": 0.5,      # degradation per hour\n            \"q\": 0.2,       # degradation^2 per hour\n            \"r\": 0.5,       # degradation^2\n            \"m0\": 0.0,      # degradation\n            \"P0\": 1.0,      # degradation^2\n            \"L\": 10.0,      # degradation\n            \"y\": [0.2, 0.7, 1.3, 2.0, 2.4, 3.1, 3.9, 4.4, 5.2, 5.7]  # degradation\n        },\n        # Test Case B (already failed after filtering)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": 0.6,\n            \"q\": 0.1,\n            \"r\": 0.05,\n            \"m0\": 2.5,\n            \"P0\": 0.2,\n            \"L\": 4.0,\n            \"y\": [3.0, 3.8, 4.4]\n        },\n        # Test Case C (small positive drift)\n        {\n            \"delta_t\": 0.5,\n            \"mu\": 0.05,\n            \"q\": 0.1,\n            \"r\": 0.1,\n            \"m0\": -0.2,\n            \"P0\": 0.5,\n            \"L\": 1.0,\n            \"y\": [-0.1, 0.0, 0.1, 0.2, 0.25]\n        },\n        # Test Case D (negative drift)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": -0.1,\n            \"q\": 0.3,\n            \"r\": 0.2,\n            \"m0\": 2.0,\n            \"P0\": 1.0,\n            \"L\": 5.0,\n            \"y\": [2.1, 2.0, 1.9, 1.8, 1.7]\n        },\n        # Test Case E (zero drift)\n        {\n            \"delta_t\": 1.0,\n            \"mu\": 0.0,\n            \"q\": 0.3,\n            \"r\": 0.5,\n            \"m0\": 1.0,\n            \"P0\": 0.5,\n            \"L\": 3.0,\n            \"y\": [1.1, 1.2, 1.25]\n        },\n    ]\n\n    results = []\n    for params in test_cases:\n        rul = calculate_rul_with_kalman_filter(params)\n        results.append(rul)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The map(str, ...) ensures that infinity is printed as 'inf'.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef calculate_rul_with_kalman_filter(params):\n    \"\"\"\n    Computes the filtered state and RUL for a single degradation process.\n\n    Args:\n        params (dict): A dictionary containing all model parameters.\n\n    Returns:\n        float: The estimated Remaining Useful Life in hours.\n    \"\"\"\n    # Extract parameters for clarity\n    delta_t = params[\"delta_t\"]\n    mu = params[\"mu\"]\n    q = params[\"q\"]\n    r = params[\"r\"]\n    m_current = params[\"m0\"]\n    P_current = params[\"P0\"]\n    L = params[\"L\"]\n    measurements = params[\"y\"]\n\n    # --- State-Space Model Parameters for the scalar case ---\n    # According to the derivation: x_k = A*x_{k-1} + B*u_{k-1} + w_{k-1}\n    # A = 1 (State transition matrix)\n    # B = 1 (Control input matrix)\n    # u = mu * delta_t (Control input, deterministic drift part)\n    # Q = q * delta_t (Process noise variance)\n    # According to the derivation: y_k = H*x_k + v_k\n    # H = 1 (Observation matrix)\n    # R = r (Measurement noise variance)\n    u_input = mu * delta_t\n    Q_noise_var = q * delta_t\n\n    # --- Kalman Filter Recursion ---\n    for y_k in measurements:\n        # 1. Prediction (Time Update)\n        m_predicted = m_current + u_input\n        P_predicted = P_current + Q_noise_var\n\n        # 2. Update (Measurement Update)\n        # Innovation (residual)\n        y_tilde = y_k - m_predicted\n        # Innovation covariance\n        S = P_predicted + r\n        # Kalman gain\n        K = P_predicted / S\n        # Updated state mean\n        m_current = m_predicted + K * y_tilde\n        # Updated state covariance\n        P_current = (1 - K) * P_predicted\n    \n    # Final filtered mean is m_current, which is m_{N|N}\n    m_N_N = m_current\n\n    # --- RUL Calculation ---\n    if m_N_N >= L:\n        # Already failed\n        return 0.0\n    elif m_N_N  L and mu = 0:\n        # Degradation is not expected to increase, will not reach threshold\n        return float('inf')\n    else:  # m_N_N  L and mu > 0\n        # Expected time to reach threshold L with positive drift mu\n        return (L - m_N_N) / mu\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "现实世界中的许多退化过程，如裂纹扩展或腐蚀，其行为本质上是非线性的。为了应对这一挑战，我们必须将线性模型的思想推广到更广泛的场景中。这个高级实践  将指导你应用扩展卡尔曼滤波器（EKF）来处理一个非线性的退化模型。你将学习如何通过在每个时间步对系统动态进行局部线性化，来估计非线性系统的状态，并在此基础上预测RUL。更重要的是，本练习还要求你计算RUL预测的方差，这对于理解和量化预测结果的不确定性至关重要，是构建可靠数字孪生模型的关键一步。",
            "id": "4240296",
            "problem": "考虑一个单自由度退化状态，该状态通过带有过程噪声的非线性状态转移和带有测量噪声的直接测量在离散时间内建模。设状态为离散时间 $k$ 的累积损伤指数 $x_k \\in \\mathbb{R}$，控制输入为 $u_k \\in \\mathbb{R}$。其动力学定义为\n$$\nx_{k+1} = f(x_k, u_k) + w_k,\n$$\n其中 $w_k$ 是均值为零、方差为 $Q$ 的高斯过程噪声，并且\n$$\nf(x, u) = x + \\alpha \\, u^{\\beta} \\, \\Delta t + \\gamma \\, x^2 \\, \\Delta t.\n$$\n测量值由下式给出\n$$\nz_k = h(x_k) + v_k,\\quad h(x)=x,\n$$\n其中 $v_k$ 是均值为零、方差为 $R$ 的高斯测量噪声。失效阈值为 $L \\in \\mathbb{R}$，表示为系统被认为失效时的无量纲损伤指数。\n\n您必须实现一个扩展卡尔曼滤波器（EKF），使用单个测量值 $z_0$ 更新 $k=0$ 时的先验置信度，然后使用给定的输入序列 $\\{u_k\\}_{k=0}^{H-1}$ 在长度为 $H$ 步的有限视界内执行开环预测。在每个预测步骤 $k$，您必须计算：\n- 预测的剩余使用寿命（RUL），单位为小时，通过从当前预测的置信度对阈值穿越时间进行局部线性化得到，以及\n- 相关的 RUL 方差，单位为小时的平方，通过一阶不确定性传播得到。\n\n您必须假设 RUL 是在局部冻结的退化率下，预测状态轨迹达到阈值 $L$ 所需的时间。如果预测的退化率变得任意小，请在您的实现中以科学合理的方式防止除零错误。如果预测的状态均值等于或高于阈值，则在该步骤报告 RUL 为零小时，方差为零。\n\n所有物理量必须以其正确的单位处理：$x_k$ 和 $L$ 是无量纲的损伤指数；$\\Delta t$ 的单位是小时；最终的 RUL 必须以小时为单位表示。您的程序必须为每个测试用例输出预测视界内的 RUL 轨迹和相应的方差轨迹，其中 RUL 值四舍五入到 $4$ 位小数，方差四舍五入到 $6$ 位小数。\n\n对每个案例使用以下具有固定参数的测试套件。在所有情况下，视界为 $H=8$，时间步长为 $\\Delta t = 1.0$ 小时。\n\n测试用例 $1$（典型条件）：\n- $\\alpha = 0.08$，$\\beta = 1.4$，$\\gamma = 0.002$\n- $Q = 0.0001$， $R = 0.00025$\n- $L = 1.0$\n- 先验均值 $x_{0|{-1}} = 0.20$，先验方差 $P_{0|{-1}} = 0.01$\n- 测量值 $z_0 = 0.22$\n- 输入序列 $\\{u_k\\}_{k=0}^{7} = [0.60, 0.65, 0.70, 0.70, 0.72, 0.75, 0.75, 0.80]$\n\n测试用例 $2$（近阈值边界）：\n- $\\alpha = 0.08$，$\\beta = 1.4$，$\\gamma = 0.002$\n- $Q = 0.0001$， $R = 0.00025$\n- $L = 1.0$\n- 先验均值 $x_{0|{-1}} = 0.90$，先验方差 $P_{0|{-1}} = 0.005$\n- 测量值 $z_0 = 0.88$\n- 输入序列 $\\{u_k\\}_{k=0}^{7} = [0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50]$\n\n测试用例 $3$（低负载、慢退化边缘案例）：\n- $\\alpha = 0.08$，$\\beta = 1.4$，$\\gamma = 0.002$\n- $Q = 0.0001$， $R = 0.00025$\n- $L = 1.0$\n- 先验均值 $x_{0|{-1}} = 0.05$，先验方差 $P_{0|{-1}} = 0.02$\n- 测量值 $z_0 = 0.04$\n- 输入序列 $\\{u_k\\}_{k=0}^{7} = [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]$\n\n最终输出格式规范：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个元素对应一个测试用例，并且本身必须是一个包含两个列表的列表：第一个是长度为 $H$ 的 RUL 均值列表（单位为小时，四舍五入到 $4$ 位小数），第二个是长度为 $H$ 的相应 RUL 方差列表（单位为小时的平方，四舍五入到 $6$ 位小数）。具体来说，输出为\n$$\n[ [ \\text{RULs}_1, \\text{Vars}_1 ], [ \\text{RULs}_2, \\text{Vars}_2 ], [ \\text{RULs}_3, \\text{Vars}_3 ] ],\n$$\n其中 $\\text{RULs}_i$ 和 $\\text{Vars}_i$ 是测试用例 $i$ 的 $H$ 个浮点数列表。",
            "solution": "问题陈述经评估有效。它具有科学依据，问题设定良好，并提供了解决问题所需的所有必要信息。这是扩展卡尔曼滤波器（EKF）在预测与健康管理（prognostics and health management）背景下用于状态估计和后续剩余使用寿命（RUL）预测的标准应用。该模型虽然经过简化，但代表了常见的退化过程，并且所需的计算在数学上是合理的。\n\n解决方案主要分两个阶段进行：\n1.  **EKF 更新**：使用测量值 $z_0$ 更新系统在时间 $k=0$ 时的初始先验置信度（由均值 $x_{0|{-1}}$ 和方差 $P_{0|{-1}}$ 给出），以产生后验（滤波后）置信度 $(x_{0|0}, P_{0|0})$。\n2.  **开环预测与 RUL 估计**：从 $k=0$ 时的后验状态开始，在长度为 $H$ 步的视界内执行开环预测。在视界内的每一步 $k$，使用预测状态 $(\\hat{x}_{k|0}, \\hat{P}_{k|0})$ 来计算 RUL 及其相关方差。然后将状态传播到下一个时间步 $k+1$。\n\n此后，我们将预测步骤 $k$ 的状态估计及其方差表示为 $(\\hat{x}_k, \\hat{P}_k)$。\n\n**1. 时间 `k=0` 时的 EKF 更新**\n\n给定先验状态估计 $x_{0|{-1}}$ 及其方差 $P_{0|{-1}}$，以及测量值 $z_0$，我们更新状态。测量模型是线性的：\n$$\nz_k = h(x_k) + v_k \\quad \\text{with} \\quad h(x_k) = x_k\n$$\n测量函数 $h(x)$ 关于 $x$ 的雅可比矩阵 $H_k$ 就是其导数，即为 $1$。\n$$\nH_k = \\frac{\\partial h}{\\partial x} \\bigg|_{\\hat{x}_k} = 1\n$$\n对于线性测量模型，EKF 更新方程为：\n- **新息协方差 ($S_0$)**：$S_0 = H_0 P_{0|{-1}} H_0^T + R = P_{0|{-1}} + R$\n- **卡尔曼增益 ($K_0$)**：$K_0 = P_{0|{-1}} H_0^T S_0^{-1} = P_{0|{-1}} (P_{0|{-1}} + R)^{-1}$\n- **后验状态均值 ($x_{0|0}$ 或 $\\hat{x}_0$)**：$\\hat{x}_0 = x_{0|{-1}} + K_0 (z_0 - x_{0|{-1}})$\n- **后验状态方差 ($P_{0|0}$ 或 $\\hat{P}_0$)**：$\\hat{P}_0 = (I - K_0 H_0) P_{0|{-1}} = (1 - K_0) P_{0|{-1}}$\n\n这给出了预测视界的初始状态 $(\\hat{x}_0, \\hat{P}_0)$。\n\n**2. 预测循环与 RUL 估计 (`k = 0, ..., H-1`)**\n\n对于预测视界中的每一步 $k$，我们执行两个任务：基于当前状态 $(\\hat{x}_k, \\hat{P}_k)$ 进行 RUL 估计，以及预测下一状态 $(\\hat{x}_{k+1}, \\hat{P}_{k+1})$。\n\n**a. 步骤 `k` 的 RUL 估计**\n\nRUL 定义为假设退化率“局部冻结”在当前值时，损伤指数达到失效阈值 $L$ 所需的时间。连续时间退化率为 $\\frac{dx}{dt} = \\alpha u^\\beta + \\gamma x^2$。我们使用输入 $u_k$ 在状态均值 $\\hat{x}_k$ 处评估此速率。\n$$\n\\text{rate}_k = \\dot{x}_k = \\alpha u_k^{\\beta} + \\gamma \\hat{x}_k^2\n$$\n- **RUL 均值**：到达失效的时间是剩余损伤容量除以速率。时间步长 $\\Delta t$ 以小时为单位，因此速率单位为 $1/\\text{小时}$。因此，RUL 的单位是小时。\n$$\n\\text{RUL}_k = \\frac{L - \\hat{x}_k}{\\dot{x}_k} = \\frac{L - \\hat{x}_k}{\\alpha u_k^{\\beta} + \\gamma \\hat{x}_k^2}\n$$\n如果 $\\hat{x}_k \\ge L$，则 RUL 设为 $0$。为防止除以一个非常小或为零的速率，分母被限制在一个小的正值 $\\epsilon  0$ 以上。\n\n- **RUL 方差**：我们使用一阶不确定性传播。RUL 是随机变量 $x_k$ 的函数 $\\rho(x_k)$，该随机变量的均值为 $\\hat{x}_k$，方差为 $\\hat{P}_k$。\n$$\n\\text{Var}(\\text{RUL}_k) \\approx \\left( \\frac{\\partial \\rho}{\\partial x} \\bigg|_{\\hat{x}_k} \\right)^2 \\hat{P}_k\n$$\n所需的雅可比矩阵（导数）为：\n$$\n\\frac{\\partial \\rho}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\frac{L-x}{\\alpha u_k^{\\beta} + \\gamma x^2} \\right) = \\frac{-1(\\alpha u_k^{\\beta} + \\gamma x^2) - (L-x)(2\\gamma x)}{(\\alpha u_k^{\\beta} + \\gamma x^2)^2} = \\frac{-\\alpha u_k^{\\beta} + \\gamma x^2 - 2\\gamma L x}{(\\alpha u_k^{\\beta} + \\gamma x^2)^2}\n$$\n然后通过将此雅可比矩阵在 $\\hat{x}_k$ 处求值并平方，再乘以 $\\hat{P}_k$ 来计算方差。如果 $\\hat{x}_k \\ge L$，则方差为 $0$。\n\n**b. 步骤 `k+1` 的状态预测**\n\n状态通过非线性状态转移函数 $f(x, u) = x + (\\alpha u^{\\beta} + \\gamma x^2)\\Delta t$ 进行传播。EKF 通过非线性函数传播均值，并通过其线性化传播方差。\n$$\n\\hat{x}_{k+1} = f(\\hat{x}_k, u_k) = \\hat{x}_k + (\\alpha u_k^{\\beta} + \\gamma \\hat{x}_k^2)\\Delta t\n$$\n方差使用状态转移函数的雅可比矩阵 $F_k$ 进行传播。\n$$\nF_k = \\frac{\\partial f}{\\partial x} \\bigg|_{\\hat{x}_k, u_k} = 1 + 2\\gamma \\hat{x}_k \\Delta t\n$$\n则预测方差 $\\hat{P}_{k+1}$ 为：\n$$\n\\hat{P}_{k+1} = F_k \\hat{P}_k F_k^T + Q = (1 + 2\\gamma \\hat{x}_k \\Delta t)^2 \\hat{P}_k + Q\n$$\n其中 $Q$ 是过程噪声方差。对 $k$ 从 $0$ 到 $H-1$ 迭代此过程，生成 RUL 估计及其方差的轨迹。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(alpha, beta, gamma, Q, R, L, x0_prior, P0_prior, z0, u_seq, H, dt):\n    \"\"\"\n    Performs EKF update and open-loop RUL prediction for a single test case.\n    \"\"\"\n    \n    # EKF Update at k=0\n    # Measurement is linear: h(x) = x, so Jacobian H_k = 1\n    S0 = P0_prior + R\n    K0 = P0_prior / S0\n    x0_posterior = x0_prior + K0 * (z0 - x0_prior)\n    P0_posterior = (1.0 - K0) * P0_prior\n\n    x_hat = x0_posterior\n    P_hat = P0_posterior\n\n    rul_trajectory = []\n    var_trajectory = []\n\n    # Small epsilon to avoid division by zero\n    epsilon = 1e-9\n\n    # Prediction Loop\n    for k in range(H):\n        u_k = u_seq[k]\n\n        # RUL Calculation at step k\n        if x_hat >= L:\n            rul_k = 0.0\n            var_k = 0.0\n        else:\n            # Degradation rate (per hour)\n            degradation_rate = alpha * np.power(u_k, beta) + gamma * np.power(x_hat, 2)\n            \n            # Guard against division by zero\n            if degradation_rate  epsilon:\n                degradation_rate = epsilon\n\n            # RUL mean (in hours)\n            rul_k = (L - x_hat) / degradation_rate\n\n            # RUL variance (in hours^2)\n            # Jacobian of RUL function w.r.t. x\n            numerator_j_rul = -alpha * np.power(u_k, beta) + gamma * np.power(x_hat, 2) - 2 * gamma * L * x_hat\n            denominator_j_rul = np.power(degradation_rate, 2)\n            j_rul = numerator_j_rul / denominator_j_rul\n\n            var_k = np.power(j_rul, 2) * P_hat\n\n        rul_trajectory.append(rul_k)\n        var_trajectory.append(var_k)\n\n        # State Prediction for step k+1\n        # Jacobian of state transition function f(x,u) w.r.t. x\n        F_k = 1.0 + 2.0 * gamma * x_hat * dt\n        \n        # Predict next state mean\n        x_hat_next = x_hat + (alpha * np.power(u_k, beta) + gamma * np.power(x_hat, 2)) * dt\n        \n        # Predict next state variance\n        P_hat_next = np.power(F_k, 2) * P_hat + Q\n        \n        x_hat = x_hat_next\n        P_hat = P_hat_next\n        \n    return rul_trajectory, var_trajectory\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and format the output.\n    \"\"\"\n    test_cases = [\n        {\n            \"alpha\": 0.08, \"beta\": 1.4, \"gamma\": 0.002, \"Q\": 0.0001, \"R\": 0.00025, \"L\": 1.0, \n            \"x0_prior\": 0.20, \"P0_prior\": 0.01, \"z0\": 0.22,\n            \"u_seq\": [0.60, 0.65, 0.70, 0.70, 0.72, 0.75, 0.75, 0.80]\n        },\n        {\n            \"alpha\": 0.08, \"beta\": 1.4, \"gamma\": 0.002, \"Q\": 0.0001, \"R\": 0.00025, \"L\": 1.0,\n            \"x0_prior\": 0.90, \"P0_prior\": 0.005, \"z0\": 0.88,\n            \"u_seq\": [0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50, 0.50]\n        },\n        {\n            \"alpha\": 0.08, \"beta\": 1.4, \"gamma\": 0.002, \"Q\": 0.0001, \"R\": 0.00025, \"L\": 1.0,\n            \"x0_prior\": 0.05, \"P0_prior\": 0.02, \"z0\": 0.04,\n            \"u_seq\": [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]\n        }\n    ]\n    H = 8\n    dt = 1.0\n\n    all_results = []\n    for params in test_cases:\n        ruls, variances = run_simulation(\n            params[\"alpha\"], params[\"beta\"], params[\"gamma\"],\n            params[\"Q\"], params[\"R\"], params[\"L\"],\n            params[\"x0_prior\"], params[\"P0_prior\"], params[\"z0\"],\n            params[\"u_seq\"], H, dt\n        )\n        all_results.append([ruls, variances])\n\n    # Manually format the output string to match the required format without spaces.\n    case_strings = []\n    for case_result in all_results:\n        # case_result is a list: [ list_of_ruls, list_of_variances ]\n        ruls, variances = case_result\n        ruls_str = f\"[{','.join([f'{r:.4f}' for r in ruls])}]\"\n        vars_str = f\"[{','.join([f'{v:.6f}' for v in variances])}]\"\n        case_strings.append(f\"[{ruls_str},{vars_str}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}