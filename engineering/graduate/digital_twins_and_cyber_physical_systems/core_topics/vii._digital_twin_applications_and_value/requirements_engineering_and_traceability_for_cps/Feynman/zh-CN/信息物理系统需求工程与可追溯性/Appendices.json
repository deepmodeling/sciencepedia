{
    "hands_on_practices": [
        {
            "introduction": "在信息物理系统的开发中，确保每个需求都得到实现，并且每一行代码都服务于一个明确的需求，是保证项目质量和可维护性的基石。本练习  引导您使用可追溯性矩阵这一基本工具，将需求与代码模块之间的关系建模为一个二分图。通过分析该矩阵的行和与列和，您将学习如何系统地识别出“孤立需求”（未被任何代码模块实现的需求）和“无效代码”（不对应任何需求的代码），这是可追溯性分析中的一项核心技能。",
            "id": "4240765",
            "problem": "一个信息物理系统 (CPS) 项目维护一组功能需求和一组代码模块之间的可追溯性链接。将此可追溯性建模为一个二分图，其顶点集为 $R$ (需求) 和 $C$ (代码模块)，边集为 $E \\subseteq R \\times C$，其中 $(r_{i}, c_{j}) \\in E$ 表示从需求 $r_{i}$ 到代码模块 $c_{j}$ 的一条可追溯性链接。令二分追溯矩阵为邻接矩阵 $M \\in \\{0,1\\}^{n_{R} \\times n_{C}}$，其元素为\n$$\nM_{i,j} =\n\\begin{cases}\n1  \\text{if } (r_{i}, c_{j}) \\in E,\\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n对 $i \\in \\{0,1,\\dots,n_{R}-1\\}$ 和 $j \\in \\{0,1,\\dots,n_{C}-1\\}$ 采用零基索引。\n\n基于集合论和图论的定义：\n- 一个需求 $r_{i}$ 是孤儿需求，当且仅当它没有任何关联边，即 $\\nexists\\, j \\in \\{0,1,\\dots,n_{C}-1\\}$ 使得 $M_{i,j} = 1$。\n- 一个代码模块 $c_{j}$ 是死代码（相对于指定的需求而言），当且仅当它没有任何关联边，即 $\\nexists\\, i \\in \\{0,1,\\dots,n_{R}-1\\}$ 使得 $M_{i,j} = 1$。\n\n任务：\n1. 基于上述定义，推导一个算法。该算法在给定 $n_{R}$、$n_{C}$ 和一个有限的链接集 $E$ 的情况下，构造矩阵 $M$ 并检测集合\n$$\nO = \\{\\, i \\in \\{0,\\dots,n_{R}-1\\} \\mid \\sum_{j=0}^{n_{C}-1} M_{i,j} = 0 \\,\\}\n\\quad\\text{and}\\quad\nD = \\{\\, j \\in \\{0,\\dots,n_{C}-1\\} \\mid \\sum_{i=0}^{n_{R}-1} M_{i,j} = 0 \\,\\},\n$$\n其中 $O$ 是孤儿需求的索引集，$D$ 是死代码模块的索引集。您的推导必须从上述核心定义和二分图中顶点的度的基本性质出发，而不是从一个预先给定的简化公式开始。\n\n2. 将该算法实现为一个完整的程序，对于提供的测试套件中的每个测试用例，输出 $O$ 和 $D$ 中排序后的索引列表。\n\n3. 通过将 $O$ 解释为未实现或未追溯的需求，并将 $D$ 解释为与任何需求都无关的代码，来确保科学真实性；并基于所采用的形式化模型，论证检测的正确性。\n\n输入固定在程序内部；不读取外部输入。\n\n始终使用零基索引。\n\n用于覆盖典型和边界场景的测试套件：\n- 测试用例 1 (正常路径)：$n_{R} = 4$，$n_{C} = 5$，$E = \\{(0,0),(0,3),(1,1),(1,3),(3,4)\\}$。预期概念性结果：至少一个孤儿需求和一个死代码模块。\n- 测试用例 2 (完全连接)：$n_{R} = 3$，$n_{C} = 3$，$E = \\{(i,j) \\mid i \\in \\{0,1,2\\}, j \\in \\{0,1,2\\}\\}$。预期概念性结果：没有孤儿需求和死代码。\n- 测试用例 3 (没有链接)：$n_{R} = 2$，$n_{C} = 3$，$E = \\varnothing$。预期概念性结果：所有需求都是孤儿需求，所有模块都是死代码。\n- 测试用例 4 (没有需求)：$n_{R} = 0$，$n_{C} = 3$，$E = \\varnothing$。预期概念性结果：没有孤儿需求（因为没有需求，所以当然没有），所有模块都是死代码。\n- 测试用例 5 (没有模块)：$n_{R} = 2$，$n_{C} = 0$，$E = \\varnothing$。预期概念性结果：所有需求都是孤儿需求，没有模块可标记为死代码。\n\n最终输出格式规范：\n- 对于每个测试用例 $t \\in \\{1,2,3,4,5\\}$，计算列表对 $[O_{t}, D_{t}]$，其中 $O_{t}$ 是孤儿需求索引的排序列表，$D_{t}$ 是死代码索引的排序列表。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表，每个元素本身是一个包含两个列表的数组。例如，一个语法上类似的形状是 $[[[],[]],[[0],[1,2]]]$（这只是一个示例形状，不是上述测试套件的答案）。",
            "solution": "该问题要求推导并实现一种算法，用于在需求可追溯性模型中识别未追溯的实体。该模型是一个二分图，连接一组需求 $R$ 和一组代码模块 $C$。需要识别的实体是“孤儿需求”（未链接到任何代码模块的需求）和“死代码”（未链接到任何需求的代码模块）。该解决方案从图论和线性代数的第一性原理推导而来。\n\n### 1. 从第一性原理推导\n\n可追溯性系统被建模为一个二分图 $G = (R \\cup C, E)$，其中 $R = \\{r_0, r_1, \\dots, r_{n_R-1}\\}$ 是需求顶点的集合，$C = \\{c_0, c_1, \\dots, c_{n_C-1}\\}$ 是代码模块顶点的集合，$E \\subseteq R \\times C$ 是表示可追溯性链接的边集。该图的结构由其双邻接矩阵捕获，问题将其定义为追溯矩阵 $M \\in \\{0, 1\\}^{n_R \\times n_C}$。元素 $M_{i,j} = 1$ 表示存在一条边 $(r_i, c_j) \\in E$，而 $M_{i,j}=0$ 表示该边不存在。\n\n图中顶点的一个基本属性是它的度，记为 $\\deg(v)$，即与该顶点关联的边的数量。孤儿需求和死代码的定义可以直接用这个概念来表达。\n\n**孤儿需求：**\n需求 $r_i$ 被定义为孤儿需求，如果它没有任何关联边。用图论的术语来说，这等同于声明顶点 $r_i$ 的度为零：$\\deg(r_i) = 0$。\n\n顶点 $r_i \\in R$ 的度可以从追溯矩阵 $M$ 计算得出。元素 $M_{i,j}$ 为 1 当且仅当有一条连接 $r_i$ 和 $c_j$ 的边。因此，连接到 $r_i$ 的总边数，也就是它的度，是矩阵 $M$ 第 $i$ 行所有元素的和。\n$$\n\\deg(r_i) = \\sum_{j=0}^{n_C-1} M_{i,j}\n$$\n将孤儿需求的定义与其度的计算相结合，我们发现需求 $r_i$ 是孤儿需求当且仅当：\n$$\n\\sum_{j=0}^{n_C-1} M_{i,j} = 0\n$$\n这个推导验证了为孤儿需求索引集 $O$ 提供的公式。算法必须找到所有对应行和为零的行索引 $i$。\n\n**死代码模块：**\n同样地，一个代码模块 $c_j$ 被定义为死代码，如果它没有任何关联边。这等同于声明顶点 $c_j$ 的度为零：$\\deg(c_j) = 0$。\n\n顶点 $c_j \\in C$ 的度可以从矩阵 $M$ 的列计算得出。元素 $M_{i,j}$ 为 1 当且仅当有一条连接 $c_j$ 和 $r_i$ 的边。因此，连接到 $c_j$ 的总边数是 $M$ 第 $j$ 列所有元素的和。\n$$\n\\deg(c_j) = \\sum_{i=0}^{n_R-1} M_{i,j}\n$$\n因此，一个代码模块 $c_j$ 被归类为死代码当且仅当：\n$$\n\\sum_{i=0}^{n_R-1} M_{i,j} = 0\n$$\n这个推导验证了为死代码模块索引集 $D$ 提供的公式。算法必须找到所有对应列和为零的列索引 $j$。\n\n### 2. 算法设计与正确性\n\n基于以上推导，可以设计一个直接的算法。\n\n1.  **矩阵构造**：给定维度 $n_R$ 和 $n_C$ 以及链接集 $E$，构造 $n_R \\times n_C$ 的追溯矩阵 $M$。这可以通过初始化一个 $n_R \\times n_C$ 的零矩阵，然后对每个链接 $(i, j) \\in E$ 设置 $M_{i,j} = 1$ 来完成。此步骤将基于集合的边表示法正确地转换为矩阵模型。\n\n2.  **度计算**：计算矩阵 $M$ 的每一行和每一列的和。第 $i$ 行的和得出 $\\deg(r_i)$，第 $j$ 列的和得出 $\\deg(c_j)$。使用向量化操作可以高效地执行此计算。\n\n3.  **索引识别**：识别和为零的行和列的索引。行和为 0 的索引 $i$ 的集合构成了孤儿需求索引集 $O$。列和为 0 的索引 $j$ 的集合构成了死代码模块索引集 $D$。根据问题规范，生成的索引列表应进行排序。\n\n该算法的正确性是可证明的，因为每个步骤都是对形式化推导出的数学条件的直接实现。该模型本身是用于可追溯性分析的一种科学上合理的抽象。在实践中，识别孤儿需求（$O$ 的元素）对项目管理至关重要，因为它标记出那些可能未实现或其实现未被正式追溯的需求，这对项目完成和验证构成了风险。识别死代码（$D$ 的元素）对代码质量和维护至关重要，因为它指出了没有任何指定需求为其提供依据的代码，这些代码可以被安全地移除，从而降低复杂性和维护成本。所提出的算法为执行此分析提供了一种可靠且自动化的方法。该形式体系能够优雅地处理边界情况，例如没有需求（$n_R=0$）或没有代码模块（$n_C=0$）。例如，如果 $n_R=0$，则没有需求可以是孤儿，因此 $O=\\varnothing$。一个 $0 \\times n_C$ 矩阵的列和全部为 0，从而正确地将所有存在的代码模块识别为死代码。",
            "answer": "```python\nimport numpy as np\n\ndef find_untraced(n_r, n_c, links):\n    \"\"\"\n    Constructs the trace matrix and finds orphan requirements and dead code.\n\n    Args:\n        n_r (int): The number of requirements.\n        n_c (int): The number of code modules.\n        links (list of tuples): The set of traceability links (i, j).\n\n    Returns:\n        list: A list containing two lists: the sorted indices of orphan\n              requirements and the sorted indices of dead code modules.\n    \"\"\"\n    # The matrix M is initialized with zeros.\n    # For n_r=0, its shape is (0, n_c). For n_c=0, its shape is (n_r, 0).\n    # This unified setup correctly handles all boundary conditions without\n    # special case logic.\n    M = np.zeros((n_r, n_c), dtype=int)\n\n    # Populate the matrix from the edge set.\n    # If links is empty, or n_r=0, or n_c=0, this block is correctly skipped\n    # or has no effect, leaving M as a zero matrix.\n    if links:\n        # Unzip the list of tuples into row and column indices for efficient assignment.\n        rows, cols = zip(*links)\n        M[rows, cols] = 1\n\n    # Calculate row sums. The sum of row i corresponds to the degree of requirement r_i.\n    # If n_r=0, row_sums is an empty array.\n    # If n_c=0, row_sums is an array of n_r zeros, correctly marking all requirements as orphans.\n    row_sums = M.sum(axis=1)\n\n    # Calculate column sums. The sum of column j corresponds to the degree of module c_j.\n    # If n_c=0, col_sums is an empty array.\n    # If n_r=0, col_sums is an array of n_c zeros, correctly marking all modules as dead code.\n    col_sums = M.sum(axis=0)\n\n    # An orphan requirement has a degree of 0, meaning its corresponding row sum is 0.\n    # np.where returns sorted indices, which satisfies the problem requirements.\n    # The result is converted to a standard Python list.\n    orphan_reqs_indices = np.where(row_sums == 0)[0].tolist()\n\n    # A dead code module has a degree of 0, meaning its corresponding column sum is 0.\n    dead_code_indices = np.where(col_sums == 0)[0].tolist()\n\n    return [orphan_reqs_indices, dead_code_indices]\n\ndef solve():\n    \"\"\"\n    Runs the traceability analysis on a predefined test suite and prints the results.\n    \"\"\"\n    # Test suite covering typical, fully connected, empty, and boundary scenarios.\n    test_suite = [\n        # Test case 1 (happy path)\n        (4, 5, [(0, 0), (0, 3), (1, 1), (1, 3), (3, 4)]),\n        # Test case 2 (fully connected)\n        (3, 3, [(i, j) for i in range(3) for j in range(3)]),\n        # Test case 3 (no links)\n        (2, 3, []),\n        # Test case 4 (no requirements)\n        (0, 3, []),\n        # Test case 5 (no modules)\n        (2, 0, [])\n    ]\n    \n    all_results = []\n    for n_r, n_c, E in test_suite:\n        result = find_untraced(n_r, n_c, E)\n        all_results.append(result)\n\n    # Format the final output string precisely as specified in the problem statement.\n    # The output is a single-line string representation of a list of lists,\n    # with no whitespace between elements.\n    # e.g., [[[O1],[D1]],[[O2],[D2]],...]\n    results_str_parts = []\n    for res_pair in all_results:\n        # res_pair is a list like [[0, 1], [0, 1, 2]]\n        # Format the list of orphan indices, e.g., '[0,1]'\n        o_list_str = f\"[{','.join(map(str, res_pair[0]))}]\"\n        # Format the list of dead code indices, e.g., '[0,1,2]'\n        d_list_str = f\"[{','.join(map(str, res_pair[1]))}]\"\n        # Combine them into the pair format, e.g., '[[0,1],[0,1,2]]'\n        results_str_parts.append(f\"[{o_list_str},{d_list_str}]\")\n    \n    final_output = f\"[{','.join(results_str_parts)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "信息物理系统的许多关键需求本质上是定量的和概率性的，例如网络可靠性或响应时间。简单地检查是否存在追溯链接已不足够，我们必须验证系统在实际运行中是否能以一定的置信度满足这些量化指标。本实践  将可追溯性从结构层面提升到性能验证层面，指导您应用统计推断方法，为系统性能（如数据包丢失率 $p$）构建置信区间，并将其与形式化需求（如 $p \\le 0.02$）进行比较，从而做出有数据支持的合规性决策。",
            "id": "4240737",
            "problem": "一个由数字孪生 (DT) 监控的信息物理系统 (CPS) 必须满足一项网络可靠性要求，即真实丢包率至多为 $p \\le 0.02$。为了可追溯性，该要求按如下方式进行操作化：一个包含 $n = 1000$ 个已发送数据包的监控窗口被视为 $n$ 次独立同分布的伯努利试验，其丢包指示符为 $Y_i \\in \\{0,1\\}$，其中 $\\Pr(Y_i = 1) = p$ 是未知的丢包概率。DT 在此窗口内记录到 $x = 15$ 次丢包。\n\n从伯努利模型和中心极限定理出发，推导经验丢包率 $\\hat{p}$ 以及 $p$ 的一个近似的 95% 单侧置信上限。使用正态近似来证明单侧置信界构造的合理性，并陈述一个可追溯至该要求的合规性决策规则（即，如果该上限至多为 $0.02$，则在 0.95 的置信水平上认为要求得到满足）。\n\n只报告 $p$ 的 95% 单侧置信上限，以小数形式表示，并四舍五入到四位有效数字。报告的数字中不允许使用百分号。",
            "solution": "该问题需要进行验证。\n\n### 步骤 1：提取已知条件\n-   **要求**：真实丢包率至多为 $p \\le 0.02$。\n-   **监控窗口大小**：$n = 1000$ 个数据包。\n-   **模型**：$n$ 次独立同分布的伯努利试验。\n-   **丢包指示符**：$Y_i \\in \\{0, 1\\}$。\n-   **丢包概率**：$\\Pr(Y_i = 1) = p$。\n-   **观测数据**：窗口内发生 $x = 15$ 次丢包。\n-   **方法论**：使用中心极限定理和对伯努利/二项分布的正态近似，推导 $p$ 的一个近似的 95% 单侧置信上限。\n-   **合规性决策规则**：如果上限至多为 $0.02$，则在 0.95 的置信水平上认为要求得到满足。\n-   **输出要求**：以小数形式报告 $p$ 的 95% 单侧置信上限，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：该问题在标准统计理论中有坚实的基础。使用伯努利试验对丢包进行建模、使用中心极限定理 (CLT) 进行大样本近似，以及构建置信区间，这些都是统计推断和工程可靠性中的基本技术。\n-   **适定性**：该问题是适定的。它提供了所有必要的数据（$n$、$x$、置信水平），并指定了理论方法（CLT、正态近似）以求得唯一的数值答案。\n-   **客观性**：该问题以精确、客观的语言陈述，没有主观或模糊的术语。\n-   **一致性检查**：当 $np$ 和 $n(1-p)$ 都足够大（通常大于 5）时，对二项分布进行正态近似是合适的。使用样本估计值 $\\hat{p} = x/n = 15/1000 = 0.015$，我们发现 $n\\hat{p} = 1000 \\times 0.015 = 15$ 和 $n(1-\\hat{p}) = 1000 \\times (1 - 0.015) = 985$。这两个值都远大于 5，从而验证了使用正态近似的合理性。\n\n### 步骤 3：结论与行动\n该问题被认为是有效的，因为它在科学上是合理的、适定的、客观的且内部一致的。将推导解答。\n\n### 解答推导\n该问题要求基于一个样本计算总体比例 $p$ 的单侧置信上限。\n\n令 $X$ 为 $n$ 个数据包样本中观测到的丢包总数。数据包传输序列被建模为 $n$ 次独立同分布的伯努利试验。因此，$X$ 服从二项分布，$X \\sim B(n, p)$，其中 $p$ 是真实的、未知的丢包概率。\n\n$p$ 的点估计量是样本比例，记为 $\\hat{p}$：\n$$ \\hat{p} = \\frac{X}{n} $$\n该估计量的期望值为 $E[\\hat{p}] = p$，其方差为 $\\text{Var}(\\hat{p}) = \\frac{p(1-p)}{n}$。\n\n根据中心极限定理，对于足够大的样本量 $n$，$\\hat{p}$ 的抽样分布可以用正态分布近似：\n$$ \\hat{p} \\approx N\\left(p, \\frac{p(1-p)}{n}\\right) $$\n这意味着标准化随机变量 $Z$ 近似为一个标准正态随机变量，$Z \\sim N(0, 1)$：\n$$ Z = \\frac{\\hat{p} - p}{\\sqrt{\\frac{p(1-p)}{n}}} $$\n为了构造 $p$ 的一个单侧 $100(1-\\alpha)\\%$ 置信区间，我们寻找一个上限 $p_{upper}$，使得 $\\Pr(p \\le p_{upper}) = 1-\\alpha$。这等价于找到不被观测数据在统计上拒绝的 $p$ 值集合。我们从单侧区间的概率陈述开始：\n$$ \\Pr\\left( \\frac{\\hat{p} - p}{\\sqrt{\\frac{p(1-p)}{n}}} > -z_{1-\\alpha} \\right) = 1-\\alpha $$\n其中 $z_{1-\\alpha}$ 是标准正态分布的 $(1-\\alpha)$-分位数。对于 95% 的置信水平，$1-\\alpha = 0.95$，所以 $\\alpha = 0.05$。临界值是 $z_{0.95}$，约等于 $1.645$。\n\n分母中的标准误差项 $\\sqrt{p(1-p)/n}$ 取决于未知参数 $p$。正如问题所建议的，正态近似的一个常见且直接的应用是在标准误差项中用估计量 $\\hat{p}$ 替代 $p$。这就得到了估计的标准误差 $SE(\\hat{p})$：\n$$ SE(\\hat{p}) = \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} $$\n置信区间则由以下关系构建：\n$$ \\frac{\\hat{p} - p}{SE(\\hat{p})} > -z_{1-\\alpha} $$\n重新整理这个不等式以求解 $p$，得到其上限：\n$$ \\hat{p} - p > -z_{1-\\alpha} \\times SE(\\hat{p}) $$\n$$ p  \\hat{p} + z_{1-\\alpha} \\times SE(\\hat{p}) $$\n因此，单侧置信上限 $p_{upper}$ 由以下公式给出：\n$$ p_{upper} = \\hat{p} + z_{1-\\alpha} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} $$\n现在，我们将给定的值代入此公式。\n-   样本量，$n = 1000$。\n-   丢包次数，$x = 15$。\n-   置信水平，$1-\\alpha = 0.95$，这给出 $z_{0.95} \\approx 1.64485...$。我们将使用常用值 $z_{0.95} = 1.645$。\n\n首先，计算样本比例 $\\hat{p}$：\n$$ \\hat{p} = \\frac{15}{1000} = 0.015 $$\n接下来，计算上限 $p_{upper}$：\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{\\frac{0.015(1 - 0.015)}{1000}} $$\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{\\frac{0.015 \\times 0.985}{1000}} $$\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{\\frac{0.014775}{1000}} $$\n$$ p_{upper} = 0.015 + 1.645 \\sqrt{0.000014775} $$\n$$ p_{upper} = 0.015 + 1.645 \\times 0.0038438262... $$\n$$ p_{upper} = 0.015 + 0.0063230941... $$\n$$ p_{upper} = 0.0213230941... $$\n问题要求答案四舍五入到四位有效数字。第一位有效数字是百分位上的 $2$。第四位有效数字是万分位上的第二个 $2$。其后一位数字是 $3$，小于 $5$，所以我们向下舍入。\n$$ p_{upper} \\approx 0.02132 $$\n这个上限就是答案。作为推理过程的一部分，我们现在可以应用可追溯性规则。要求是 $p \\le 0.02$。由于我们在 95% 置信水平下计算出的上限 $p_{upper} \\approx 0.02132$ 大于 $0.02$，我们得出结论，该系统在此置信水平下不满足指定的可靠性要求。这展示了操作数据到正式要求的可追溯性。",
            "answer": "$$\\boxed{0.02132}$$"
        },
        {
            "introduction": "现代信息物理系统通常在连续时间内运行，并依赖于可能存在误差的传感器数据。验证其是否满足复杂的时序安全需求（例如，“在任何时候，车距都不能小于安全阈值”）是一项重大挑战。本高级练习  引入信号时序逻辑（STL）作为一种精确描述这类动态行为的形式化语言。您将深入探索“稳健满足”的概念，并推导如何在存在有界测量不确定性 $\\|\\epsilon(t)\\|_{2} \\leq \\delta$ 的情况下，通过收紧监控阈值来保证系统真实状态满足原始安全需求，这是设计高可靠性CPS监控系统的关键技术。",
            "id": "4240700",
            "problem": "一个数字孪生（DT）为一个自动驾驶汽车信息物理系统（CPS）监控其车头时距安全要求。在每个时刻 $t$，该DT接收一个测量特征向量 $z_{m}(t) \\in \\mathbb{R}^{3}$，它是真实特征向量 $z(t)$ 与一个未知测量误差 $\\epsilon(t)$ 的和，该误差在欧几里得范数（也称为$2$-范数）下有已知界：对所有 $t$ 都有 $\\|\\epsilon(t)\\|_{2} \\leq \\delta$。特征向量 $z(t)$ 聚合了距离等效量（距离、转换后的相对速度、转换后的相对加速度），因此每个分量的单位都是米。该DT监控信号时序逻辑（STL）要求\n$$\n\\varphi \\;=\\; \\mathbf{G}_{[0,\\,10]}\\big(a^{\\top} z(t) \\leq \\beta\\big) \\;\\wedge\\; \\mathbf{F}_{[2,\\,5]}\\big(d^{\\top} z(t) \\geq \\eta\\big),\n$$\n其中 $\\mathbf{G}$ 表示信号时序逻辑（STL）中的“总是”算子，$\\mathbf{F}$ 表示“最终”算子，$a, d \\in \\mathbb{R}^{3}$ 是常系数向量，$\\beta, \\eta \\in \\mathbb{R}$ 是单位为米的常数阈值。\n\n仅从STL中原子谓词和时序算子的形式化鲁棒满足语义，以及从欧几里得范数导出的Lipschitz界出发，推导被监控阈值的充分收紧条件，从而使得DT的监控在有界测量不确定性下是可靠的；也就是说，如果DT报告测量信号 $z_{m}(t)$ 满足收紧后的要求，那么真实信号 $z(t)$ 满足原始要求 $\\varphi$。\n\n给定具体数据\n$$\na = \\begin{pmatrix}2 \\\\ -1 \\\\ 3\\end{pmatrix}, \\quad d = \\begin{pmatrix}1 \\\\ 2 \\\\ -1\\end{pmatrix}, \\quad \\beta = 1.2 \\text{ m}, \\quad \\eta = 0.3 \\text{ m}, \\quad \\delta = 0.05 \\text{ m},\n$$\n计算DT必须在不等式 $a^{\\top} z_{m}(t) \\leq \\beta_{\\text{adj}}$ 和 $d^{\\top} z_{m}(t) \\geq \\eta_{\\text{adj}}$ 中使用的调整后阈值 $\\beta_{\\text{adj}}$ 和 $\\eta_{\\text{adj}}$，以保证如上所述对 $\\varphi$ 的可靠监控。最终的调整后阈值以米为单位表示，并将答案四舍五入到四位有效数字。",
            "solution": "我们从信号时序逻辑（STL）的鲁棒满足语义开始。对于形式为 $g(x(t)) \\leq 0$ 的原子谓词，其鲁棒语义定义为 $\\rho_{g}(x,t) = -g(x(t))$。对于形式为 $h(x(t)) \\geq 0$ 的原子谓词，其鲁棒语义为 $\\rho_{h}(x,t) = h(x(t))$。在区间 $I$ 上的时序算子“总是” $\\mathbf{G}_{I}$ 和“最终” $\\mathbf{F}_{I}$ 分别通过下确界和上确界定义：$\\rho_{\\mathbf{G}_{I}\\phi}(x) = \\inf_{t \\in I} \\rho_{\\phi}(x,t)$ 和 $\\rho_{\\mathbf{F}_{I}\\psi}(x) = \\sup_{t \\in I} \\rho_{\\psi}(x,t)$。合取满足 $\\rho_{\\phi \\wedge \\psi}(x,t) = \\min\\{\\rho_{\\phi}(x,t), \\rho_{\\psi}(x,t)\\}$。如果一个公式的鲁棒语义为非负，则该公式得到满足。\n\n我们识别原子谓词：\n- 对于 $a^{\\top} z(t) \\leq \\beta$，定义 $g_{1}(z(t)) := a^{\\top} z(t) - \\beta \\leq 0$。其鲁棒语义为 $\\rho_{1}(z,t) = \\beta - a^{\\top} z(t)$。\n- 对于 $d^{\\top} z(t) \\geq \\eta$，定义 $h_{2}(z(t)) := d^{\\top} z(t) - \\eta \\geq 0$。其鲁棒语义为 $\\rho_{2}(z,t) = d^{\\top} z(t) - \\eta$。\n\n在测量不确定性下，监视器观测到 $z_{m}(t) = z(t) + \\epsilon(t)$，其中 $\\|\\epsilon(t)\\|_{2} \\leq \\delta$。我们现在使用欧几里得范数和柯西-施瓦茨不等式来界定由 $\\epsilon(t)$ 引起的鲁棒语义偏差。\n\n对于第一个谓词，\n$$\n\\big|\\rho_{1}(z_{m},t) - \\rho_{1}(z,t)\\big| \\;=\\; \\big| \\big(\\beta - a^{\\top} z_{m}(t)\\big) - \\big(\\beta - a^{\\top} z(t)\\big) \\big|\n\\;=\\; \\big| - a^{\\top} \\epsilon(t)\\big|\n\\;\\leq\\; \\|a\\|_{2}\\,\\|\\epsilon(t)\\|_{2}\n\\;\\leq\\; \\|a\\|_{2}\\,\\delta.\n$$\n因此，对所有 $t$，我们有逐点下界\n$$\n\\rho_{1}(z,t) \\;\\geq\\; \\rho_{1}(z_{m},t) - \\|a\\|_{2}\\,\\delta.\n$$\n在 $t \\in [0,10]$ 上取下确界，该界保持不变：\n$$\n\\rho_{\\mathbf{G}_{[0,10]}(a^{\\top} z \\leq \\beta)}(z) \\;=\\; \\inf_{t \\in [0,10]} \\rho_{1}(z,t)\n\\;\\geq\\; \\inf_{t \\in [0,10]} \\big(\\rho_{1}(z_{m},t) - \\|a\\|_{2}\\,\\delta\\big)\n\\;=\\; \\inf_{t \\in [0,10]} \\rho_{1}(z_{m},t) - \\|a\\|_{2}\\,\\delta.\n$$\n因此，确保 $\\rho_{\\mathbf{G}_{[0,10]}(a^{\\top} z \\leq \\beta)}(z) \\geq 0$ 的一个充分条件是\n$$\n\\inf_{t \\in [0,10]} \\rho_{1}(z_{m},t) \\;\\geq\\; \\|a\\|_{2}\\,\\delta,\n$$\n这等价于要求对所有 $t \\in [0,10]$，\n$$\n\\beta - a^{\\top} z_{m}(t) \\;\\geq\\; \\|a\\|_{2}\\,\\delta\n\\quad\\Longleftrightarrow\\quad\na^{\\top} z_{m}(t) \\;\\leq\\; \\beta - \\|a\\|_{2}\\,\\delta.\n$$\n这确定了第一个不等式的调整后阈值为\n$$\n\\beta_{\\text{adj}} \\;=\\; \\beta - \\|a\\|_{2}\\,\\delta.\n$$\n\n对于第二个谓词，\n$$\n\\big|\\rho_{2}(z_{m},t) - \\rho_{2}(z,t)\\big|\n\\;=\\; \\big| \\big(d^{\\top} z_{m}(t) - \\eta\\big) - \\big(d^{\\top} z(t) - \\eta\\big) \\big|\n\\;=\\; \\big| d^{\\top} \\epsilon(t)\\big|\n\\;\\leq\\; \\|d\\|_{2}\\,\\delta.\n$$\n因此，对所有 $t$，我们有\n$$\n\\rho_{2}(z,t) \\;\\geq\\; \\rho_{2}(z_{m},t) - \\|d\\|_{2}\\,\\delta.\n$$\n在 $t \\in [2,5]$ 上取上确界，不等式的方向保持不变：\n$$\n\\rho_{\\mathbf{F}_{[2,5]}(d^{\\top} z \\geq \\eta)}(z) \\;=\\; \\sup_{t \\in [2,5]} \\rho_{2}(z,t)\n\\;\\geq\\; \\sup_{t \\in [2,5]} \\big(\\rho_{2}(z_{m},t) - \\|d\\|_{2}\\,\\delta\\big)\n\\;=\\; \\sup_{t \\in [2,5]} \\rho_{2}(z_{m},t) - \\|d\\|_{2}\\,\\delta.\n$$\n因此，确保 $\\rho_{\\mathbf{F}_{[2,5]}(d^{\\top} z \\geq \\eta)}(z) \\geq 0$ 的一个充分条件是\n$$\n\\sup_{t \\in [2,5]} \\rho_{2}(z_{m},t) \\;\\geq\\; \\|d\\|_{2}\\,\\delta,\n$$\n这意味着存在某个 $t \\in [2,5]$ 使得\n$$\nd^{\\top} z_{m}(t) - \\eta \\;\\geq\\; \\|d\\|_{2}\\,\\delta\n\\quad\\Longleftrightarrow\\quad\nd^{\\top} z_{m}(t) \\;\\geq\\; \\eta + \\|d\\|_{2}\\,\\delta.\n$$\n这确定了第二个不等式的调整后阈值为\n$$\n\\eta_{\\text{adj}} \\;=\\; \\eta + \\|d\\|_{2}\\,\\delta.\n$$\n\n因为鲁棒语义中的合取是逐点最小值，并且两个收紧后的条件都确保了它们各自在真实信号上的鲁棒语义为非负，所以它们的合取也为非负，从而使得对 $\\varphi$ 的监控是可靠的。\n\n我们现在计算数值。首先，计算欧几里得范数：\n$$\n\\|a\\|_{2} \\;=\\; \\sqrt{2^{2} + (-1)^{2} + 3^{2}} \\;=\\; \\sqrt{14},\n\\qquad\n\\|d\\|_{2} \\;=\\; \\sqrt{1^{2} + 2^{2} + (-1)^{2}} \\;=\\; \\sqrt{6}.\n$$\n然后，\n$$\n\\beta_{\\text{adj}} \\;=\\; \\beta - \\|a\\|_{2}\\,\\delta \\;=\\; 1.2 - \\sqrt{14}\\times 0.05,\n$$\n$$\n\\eta_{\\text{adj}} \\;=\\; \\eta + \\|d\\|_{2}\\,\\delta \\;=\\; 0.3 + \\sqrt{6}\\times 0.05.\n$$\n计算这些值：\n$$\n\\sqrt{14} \\approx 3.74165738677394 \\;\\Longrightarrow\\; \\|a\\|_{2}\\,\\delta \\approx 3.74165738677394 \\times 0.05 \\approx 0.187082869338697,\n$$\n$$\n\\beta_{\\text{adj}} \\approx 1.2 - 0.187082869338697 \\approx 1.01291713066130,\n$$\n$$\n\\sqrt{6} \\approx 2.44948974278318 \\;\\Longrightarrow\\; \\|d\\|_{2}\\,\\delta \\approx 2.44948974278318 \\times 0.05 \\approx 0.122474487139159,\n$$\n$$\n\\eta_{\\text{adj}} \\approx 0.3 + 0.122474487139159 \\approx 0.422474487139159.\n$$\n以米为单位表示，并四舍五入到四位有效数字，\n$$\n\\beta_{\\text{adj}} \\approx 1.013 \\text{ m}, \\qquad \\eta_{\\text{adj}} \\approx 0.4225 \\text{ m}.\n$$\n这些是在给定的有界测量不确定性下，确保对原始STL要求进行可靠监控的调整后阈值。",
            "answer": "$$\\boxed{\\begin{pmatrix}1.013  0.4225\\end{pmatrix}}$$"
        }
    ]
}