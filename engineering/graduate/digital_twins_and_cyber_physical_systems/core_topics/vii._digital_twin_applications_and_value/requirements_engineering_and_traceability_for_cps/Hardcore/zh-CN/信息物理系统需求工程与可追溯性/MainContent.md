## 引言
信息物理系统（CPS）通过计算、网络与物理过程的深度融合，正在重塑我们的世界，从自动驾驶汽车到[智能电网](@entry_id:1131783)，其复杂性和关键性日益凸显。然而，这种复杂性也带来了巨大的工程挑战：如何确保系统在满足功能目标的同时，还能达到严苛的性能、安全与可靠性标准？成功的关键在于一个坚实的基础——系统化的[需求工程](@entry_id:1130885)与贯穿始终的可追溯性。

本文旨在解决从模糊的利益相关者意图到精确、可验证的工程实现的转化难题。在安全关键领域，任何需求的[歧义](@entry_id:276744)或遗漏都可能导致灾难性后果，因此，建立一个严谨的框架来捕获、分析、规约和管理需求至关重要。

为了系统性地构建这一知识体系，本文将分为三个核心部分。在“原理与机制”一章中，我们将奠定理论基础，详细阐述[需求工程](@entry_id:1130885)的核心概念、从[危害分析](@entry_id:174599)到安全需求的派生过程、用于精确化的[形式化方法](@entry_id:1125241)，以及实现生命周期管理的可追溯性机制。接着，在“应用与跨学科连接”一章中，我们将展示这些原则如何应用于解决性能与实时性、功能安全与[风险管理](@entry_id:141282)、以及[网络安全](@entry_id:262820)与信任工程等关键领域的实际问题。最后，通过“动手实践”部分，读者将有机会亲手应用所学知识，解决具体的工程挑战。

让我们首先从构建这一切的基石——[需求工程](@entry_id:1130885)的基本原理与机制开始。

## 原理与机制

### 信息物理系统[需求工程](@entry_id:1130885)基础

在信息物理系统（CPS）的复杂工程实践中，精确定义和系统管理需求是项目成功的基石。这不仅仅是记录利益相关者的期望，更是构建一个贯穿系统整个生命周期的、严谨且一致的逻辑框架。本节将从基本原则出发，阐述CPS中[需求工程](@entry_id:1130885)的核心概念。

#### 工程制品层级：需求、规约与设计

系统工程的核心活动之一，是将模糊的利益相关者需求，逐层分解和精确化为可执行的工程指令。这个过程产生了不同层级的工程制品，其中**需求（Requirement）**、**规约（Specification）**和**设计决策（Design Decision）**是三个关键概念，必须严格区分。

- **需求**是最高层级的抽象，它描述了系统必须“做什么”（what），即系统的目标和必须满足的约束，但并不涉及“如何做”（how）。一个良好的需求应该是可测试、可衡量且**解决方案中立（solution-neutral）**的。它代表了利益相关者的根本需求。

- **规约**是需求的技术性转化。它将需求分解为系统或子系统必须达到的、可验证的性能指标和行为。规约充当了从抽象需求到具体设计的桥梁，它定义了系统“做得多好”（how well），但仍尽量避免锁定具体的实现机制。

- **设计决策**是最低层级的具体实现方案。它描述了系统“如何做”，包括选择特定的算法、硬件组件、软件架构和材料等，以满足规约中定义的技术指标。

为了清晰地理解这些区别，我们可以分析一个自动驾驶汽车紧急制动系统的例子。假设我们正在设计一个系统，以避免与前方静止障碍物发生碰撞。

一个恰当的**需求**可以是：“在最大行驶速度 $v_{\mathrm{max}}$ 内、路面摩擦系数不低于 $\mu_{\mathrm{min}}$ 且端到端感知-执行延迟不超过 $t_{\mathrm{max}}$ 的条件下，车辆应能避免与其车道内检测到的任何静止障碍物发生碰撞。同时，每小时的危险失效概率不应超过 $\lambda_{\mathrm{PFH}}$。” 这个陈述定义了系统必须完成的任务（避免碰撞）、任务的操作边界条件以及一个量化的安全目标，但没有规定使用何种刹车技术或控制策略。

接下来，工程团队需要将此需求转化为技术**规约**。基于经典力学，总停车距离 $d_{\mathrm{stop}}$ 是延迟期间的滑行距离 $v_0 t_{\mathrm{lat}}$ 与制动距离 $\frac{v_0^2}{2a}$ 的总和，其中最大减速度 $a$ 受限于轮胎与路面的摩擦力，即 $a \le \mu g$。因此，一个规约可以是：“制动控制器应生成一个减速曲线 $a(t)$，使得在所有规定条件（$v_0 \le v_{\mathrm{max}}$, $\mu \ge \mu_{\mathrm{min}}$, $t_{\mathrm{lat}} \le t_{\mathrm{max}}$）下，最终的停车距离 $d_{\mathrm{stop}}$ 小于或等于一个由需求推导出的安全距离界限 $d_{\mathrm{req}}$。控制器还应向[数字孪生](@entry_id:171650)体（Digital Twin）提供[遥测](@entry_id:199548)数据，以验证 $d_{\mathrm{stop}} \le d_{\mathrm{req}}$。” 此规约将抽象的安全需求量化为一个可验证的物理不等式，但仍未指定控制器的具体实现。

最后，**设计决策**将选择具体的实现方案。例如：“采用限制加加速度（jerk）的[模型预测控制](@entry_id:1128006)（MPC）算法，其中 $|\dot{a}(t)| \le J_{\mathrm{max}}$；选择型号为 HP$42$ 的液压套件和牌号为 M$3$ 的刹车片材料；并集成一个基于车轮滑移率的[摩擦系数](@entry_id:150354)估算器。” 这些都是为满足规约而做出的具体技术选择。

这个从需求到规约再到设计的层级结构，确保了开发过程的逻辑清晰和可追溯性。

#### 功能性与非功能性需求

在定义了需求是什么之后，我们还需要对需求本身进行分类。最经典和基础的分类是区分**功能性需求（Functional Requirements）**和**非功能性需求（Non-Functional Requirements, NFRs）**。

传统上，功能性需求定义系统应具备的能力，即“做什么”，而非功能性需求定义系统的质量属性，即“做得多好”。然而，在复杂的CPS中，这种简单的划分有时会变得模糊。一个更严谨的、基于系统行为模型的定义能够提供更清晰的界限。

我们可以将CPS的行为看作一个从输入（sensed input）$s(t)$和内部状态（internal state）$x(t)$到输出（actuator command）$u(t)$的映射。一个系统的执行轨迹（trace）则是一个记录了这些变量随时间变化的时间序列 $b=\{(t_i,s(t_i),x(t_i),u(t_i))\}_{i=1}^N$。

- **功能性需求**明确约束了系统的核心行为映射 $f: \mathcal{I} \times \mathcal{X} \to \mathcal{O}$ 和状态转换规则。它直接定义了系统在给定输入和状态下的预期输出或行为。
- **非功能性需求**则是对系统执行轨迹的度量属性施加约束，它本身不改变行为映射 $f$。这些约束通常通过在轨迹上定义的度量函数 $m:\mathcal{B}\to\mathbb{R}^k$ 来表达。

考虑一个用于仓库自动化搬运的CPS。以下几个候选需求可以很好地说明这种区分：
- $R_1$: “当检测到托盘存在时，控制器应闭合夹爪执行器 $A$。” 这是一个典型的**功能性需求**，因为它定义了一个事件-条件-动作（Event-Condition-Action）规则，直接约束了系统的行为映射。
- $R_2$: “控制器应实现[比例-积分控制](@entry_id:276983)律 $u(t)=K_p e(t)+K_i \int_0^t e(\tau)\,d\tau$。” 这同样是一个**功能性需求**，因为它精确定义了从误差信号 $e(t)$到控制指令 $u(t)$的计算逻辑，即行为映射本身。

与此相对，以下需求则属于非功能性类别：
- $R_3$: “在额定网络负载下，从传感器捕获到执行器指令发出的端到端延迟，不得超过 $15\,\mathrm{ms}$ 的概率应至少为 $0.999$。” 这是一个**非功能性需求**。它没有改变控制器“做什么”的逻辑，而是对执行轨迹的一个可测量属性——**延迟（latency）** $L=t_{\text{cmd}}-t_{\text{sense}}$——施加了一个统计约束。
- $R_4$: “在一次 $300\,\mathrm{s}$ 的任务中，CPS消耗的总能量不得超过 $50\,\mathrm{kJ}$。” 这也是一个**非功能性需求**。它约束的是轨迹的另一个度量——**能量消耗（energy consumption）** $E = \int_{0}^{T} P(t)\,dt$，其中 $P(t)$是[瞬时功率](@entry_id:174754)。

这种基于行为模型和轨迹度量的区分方法，为我们提供了一种避免类别重叠的系统性方法。任何混合了能力和质量的模糊陈述，都应被分解为纯粹的功能性需求和纯粹的非功能性需求，从而使每个需求都能被精确地分类、分配和验证。

### 安全、风险与需求派生

在航空、医疗、自动驾驶等安全关键（safety-critical）的CPS领域，[需求工程](@entry_id:1130885)与安全工程紧密耦合。系统的需求不仅源于功能目标，更重要的是源于对潜在危害的系统性分析和规避。这个过程由[IEC 61508](@entry_id:1126352)、[ISO 26262](@entry_id:1126786)等国际安全标准所指导。

#### 从危害到安全需求

理解从[危害分析](@entry_id:174599)到需求派生的过程，需要首先明确几个核心概念：

- **危害（Hazard）**：危害是造成伤害的潜在根源。它是一个静态的概念，描述了一种可能导致不良后果的状态或情景，但尚未发生。例如，在一个人类与机器人协作的工作单元中，“机器人手臂的意外高速运动”就是一个危害。

- **严重性（Severity, S）**：指危害发生后可能造成的伤害程度。这可以从轻微擦伤到严重的人员伤亡或重大的财产损失。

- **概率（Probability, P）**：指在特定操作情境下，导致危害发生的事件序列出现的可能性。CPS的复杂交互性意味着概率通常不是一个固定值，它会受到操作模式、环境条件和系统老化等多种因素的影响。[数字孪生](@entry_id:171650)技术可以通过[分析物](@entry_id:199209)理系统的实时[遥测](@entry_id:199548)数据，动态估计特定危害事件的发生频率和暴露（Exposure）情况，从而为概率评估提供数据支持。

- **风险（Risk）**：风险是危害、严重性和概率的综合体现，通常被定义为危害发生后所造成后果的严重性与其发生概率的函数。安全工程的目标不是完全消除风险（这通常是不可能的），而是将风险降低到可接受的水平（As Low As Reasonably Practicable, ALARP）。

当识别出不可接受的风险后，就需要引入**安全功能（Safety Function）**来降低风险。例如，针对“机器人意外高速运动”的危害，可以设计一个紧急停止（Emergency Stop）安全功能。而该安全功能必须满足的需求，即**安全需求（Safety Requirement）**，则直接由所需的风险降低程度决定。

[IEC 61508](@entry_id:1126352)和[ISO 26262](@entry_id:1126786)等标准为这个过程提供了系统化的指导。它们定义了**安全完整性等级（Safety Integrity Level, SIL）**或**[汽车安全](@entry_id:1121271)完整性等级（Automotive Safety Integrity Level, ASIL）**。这是一个离散的等级（例如，SIL 1到SIL 4），用于表示安全功能所需达到的性能水平。SIL/ASIL等级越高，意味着需要应对的风险越高，因此对安全功能失效概率的要求也越严格。

对于高强度或连续运行的CPS（如机器人协作单元），[IEC 61508](@entry_id:1126352)通常使用**每小时危险失效概率（Probability of Dangerous Failure per Hour, PFH）**作为衡量指标。SIL等级与PFH目标直接对应，例如，一个SIL 3的安全功能可能被要求其PFH值低于 $10^{-7}$ 次/小时。这个量化的PFH目标就成了一个顶层的、可验证的非功能性安全需求。为了实现这一目标，标准进一步规定了在架构设计（如冗余通道）、诊断覆盖率和开发流程等方面的具体要求。这些要求会被逐层分解为更具体的技术安全需求，并贯穿整个设计和验证过程。

### 需求的精确化与形式化

自然语言是需求捕获的起点，但其固有的模糊性、歧义性和不完整性是导致工程缺陷的主要原因之一。对于CPS而言，其“信息”与“物理”行为的紧密耦合特性，使得需求的任何一点不精确都可能导致灾难性后果。因此，将需求从非形式化语言精确化为数学上无歧义的**形式化语言（Formal Language）**，是现代CPS工程的关键一步。

#### 面向离散事件系统的[时序逻辑](@entry_id:181558)

CPS的行为通常包含离散的事件序列，例如传感器触发、网络消息收发或控制器模式切换。**线性[时序逻辑](@entry_id:181558)（Linear Temporal Logic, LTL）**是一种强大的形式化语言，能够精确描述这类事件序列应遵循的规则。

LTL通过引入时间操作符来扩展标准的[命题逻辑](@entry_id:143535)，例如：
- $\mathbf{G} \phi$ （Globally）：断言属性 $\phi$ 在未来的所有时刻都成立。
- $\mathbf{F} \phi$ （Finally/Eventually）：断言属性 $\phi$ 在未来的某个时刻终将成立。
- $\phi_1 \mathbf{U} \phi_2$ （Until）：断言属性 $\phi_1$ 必须一直成立，直到属性 $\phi_2$ 成立为止。

考虑一个传感器网络中的需求：“每当一个请求（$req$）发出后，必须在5个时间步内收到一个确认（$ack$）。”。这个需求用自然语言描述似乎很清晰，但“之内”的边界条件等细节可能产生[歧义](@entry_id:276744)。使用带时间边界的LTL，我们可以将其无歧义地表述为：
$$ \mathbf{G}(req \rightarrow \mathbf{F}_{\le 5}\,ack) $$
这里的 $\rightarrow$ 是逻辑蕴含。该公式的精确语义是：对于任意时刻 $k$，如果 $req$ 在时刻 $k$ 为真，那么在时间区间 $[k, k+5]$ 内必须存在至少一个时刻 $j$，使得 $ack$ 在时刻 $j$ 为真。

这种形式化的最大优势在于其可操作性。一个LTL公式可以被系统地、自动地转换为一个**运行时监视器（Runtime Monitor）**。对于上述公式，其违规条件是：存在一个时刻 $k$，在 $k$ 时刻发生了 $req$，但在整个 $[k, k+5]$ 时间窗内都没有发生 $ack$。一个监视器可以在当前时刻 $t$ 回看，检查是否存在一个 $req$ 事件发生在时刻 $t-5$，并且在 $[t-5, t]$ 这个长度为6的滑动窗口内从未见过 $ack$。如果此条件成立，监视器就在时刻 $t$ 发出违规警报。这种从形式化需求到可执行监视器的自动转换，为系统在开发和运行阶段的持续验证提供了坚实基础。

#### 面向连续信号系统的[时序逻辑](@entry_id:181558)

CPS的另一半是物理世界，其状态通常由连续变化的信号（如温度、速度、压力）来描述。**[信号时序逻辑](@entry_id:1131627)（Signal Temporal Logic, STL）**是LTL的扩展，专门用于描述这类实值信号的属性。

STL不仅包含时序操作符，还允许在公式中直接嵌入关于信号值的谓词。例如，一个监控CPS[状态变量](@entry_id:138790) $x(t)$ 的安全需求：“在时间区间 $[0, 10]$ 内，$x(t)$ 的值必须始终不大于2”，可以用STL公式简洁地表示为：
$$ \varphi = \mathbf{G}_{[0,10]}(x(t) \le 2) $$
这个公式的布尔语义很直观：如果信号 $x(t)$ 在 $[0,10]$ 的每一个时刻都满足 $x(t) \le 2$，则该信号满足公式 $\varphi$。

然而，STL的真正威力在于其**定量语义（Quantitative Semantics）**，也称为**鲁棒性（Robustness）**。鲁棒性度量 $\rho(\varphi, x, t)$ 不仅回答“是否”满足需求，更回答了“以多大裕量”满足或“以多大程度”违反了需求。一个正的鲁棒性值表示满足，其大小代表了安全裕量；一个负值表示违反，其绝对值代表了违规的严重程度。

对于上述公式 $\varphi=\mathbf{G}_{[0,10]}(x(t)\le 2)$，其鲁棒性被定义为在指定时间区间内，信号值与阈值之间最小的“距离”。形式上，谓词 $x(t) \le 2$ 的鲁棒性是 $2 - x(t)$。$\mathbf{G}_{[0,10]}$ 操作符的鲁棒性则取其内部公式在整个时间区间上的鲁棒性的最小值（infimum）。因此，整个公式的鲁棒性为：
$$ \rho(\varphi, x, 0) = \inf_{t \in [0,10]} (2 - x(t)) = 2 - \sup_{t \in [0,10]} x(t) $$
这意味着鲁棒性等于阈值 $2$ 与信号 $x(t)$ 在区间 $[0,10]$ 上的最大值之差。

例如，如果一个信号为 $x(t) = 1.5 + 0.2\sin(\pi t)$，其在 $[0,10]$ 区间内的最大值为 $1.7$（在 $t=0.5, 2.5, \dots$ 等时刻达到）。那么该信号满足 $\varphi$ 的鲁棒性为 $\rho = 2 - 1.7 = 0.3$。这个 $0.3$ 的正值不仅确认了需求被满足，还量化地告诉我们，系统有 $0.3$ 的安全裕量。任何幅度小于 $0.3$ 的噪声或扰动叠加在信号上，都不会导致该安全需求的违反。鲁棒性语义在[参数优化](@entry_id:151785)、灵敏度分析和基于测试的[证伪](@entry_id:260896)（falsification）中扮演着至关重要的角色。

#### 基于合约的设计

当系统规模扩大，将其分解为多个交互组件是管理复杂度的唯一途径。**基于合约的设计（Contract-Based Design）**为这种分解提供了形式化框架。每个组件都附有一个**合约（Contract）**，明确规定了其与环境（即其他组件）交互的责任和权利。

一个组件合约通常被定义为一个**假设-保证（Assume-Guarantee）**对 $(A, G)$。
- **假设（Assumption, A）**是组件对其环境行为的预期。它约束了组件接收的输入信号。组件只有在环境遵守假设的前提下，才有义务履行其保证。
- **保证（Guarantee, G）**是组件对其自身行为的承诺。它约束了组件在给定满足假设的输入时产生的输出。

形式上，我们可以将一个组件 $M$ 的行为建模为一个[非确定性](@entry_id:273591)的输入-输出关系 $R_M \subseteq U^{\mathbb{N}} \times Y^{\mathbb{N}}$，其中 $U$ 是输入字母表，$Y$ 是输出字母表。$(u,y) \in R_M$ 表示组件在接收到输入轨迹 $u$ 时，可能产生输出轨迹 $y$。

一个组件 $M$ 满足合约 $(A, G)$，记为 $M \models (A \Rightarrow G)$，其语义为：对于**任何**满足假设 $A$ 的输入轨迹 $u$，组件 $M$ **所有**可能的输出轨迹 $y$ 都必须使得 $(u, y)$ 这一组合行为满足保证 $G$。

这个定义可以用[谓词逻辑](@entry_id:266105)精确表述为：
$$ M \models (A \Rightarrow G) \iff \forall u \in U^{\mathbb{N}} . \big(A(u) \Rightarrow \forall y \in Y^{\mathbb{N}} . ((u,y) \in R_M \Rightarrow G(u,y))\big) $$
这里的关键在于两个[全称量词](@entry_id:145989)：它必须对所有合法的环境行为（$\forall u$ s.t. $A(u)$）成立，并且必须对组件自身所有不确定的内部选择（$\forall y$ s.t. $(u,y) \in R_M$）都成立。

这个定义也可以用[集合论](@entry_id:137783)等价地表达。令 $A^\sharp$ 为满足 $A$ 的所有输入轨迹集合，$G^\sharp$ 为满足 $G$ 的所有输入-输出轨迹对集合。那么，满足合约的条件可以写作：
$$ R_M \cap (A^\sharp \times Y^{\mathbb{N}}) \subseteq G^\sharp $$
这个表达式的含义是：组件 $M$ 在其环境遵守假设 $A$ 时所能产生的所有行为（即交集 $R_M \cap (A^\sharp \times Y^{\mathbb{N}})$），都必须是保证 $G$所允许的行为（即 $G^\sharp$ 的子集）。

基于合约的设计允许工程师独立地设计和验证每个组件，只要保证组件间的合约相互匹配。这极大地简化了大型复杂CPS的分析和集成过程。

### 可追溯性与生命周期管理

需求一旦被定义、形式化并分配，它们并不会就此固定不变。在CPS漫长的生命周期中，需求会演化，设计会变更，新的风险可能被发现。**可追溯性（Traceability）**是在这些复杂多变的工程制品之间建立和维护[关联关系](@entry_id:158296)，从而实现系统性变更管理、覆盖率分析和合规性验证的机制。

#### 可追溯性的角色与结构

可追溯性本质上是工程制品之间的一个依赖网络。我们可以将其建模为一个[有向图](@entry_id:920596) $G=(V, E)$，其中节点 $V$ 代表各种工程制品（如危害、需求、设计模型、代码模块、测试用例、分析报告），而边 $E$ 则代表它们之间的依赖关系（如`refines`、`implements`、`verifies`等）。这个图谱是整个系统工程知识库的骨架。

##### 验证与确认（V&V）

在可追溯性框架下，两个核心的生命周期活动——**验证（Verification）**和**确认（Validation）**——获得了清晰的定义和操作路径。

- **验证**旨在回答：“我们是否正确地构建了系统？”（Are we building the system right?）。它评估工程制品是否符合其直接的上游规约。在我们的追溯图中，验证活动主要关注从需求到设计再到实现的**“向下”**链接。例如，验证一个代码模块就是检查它是否正确实现了分配给它的技术需求。这通过单元测试、代码审查、[静态分析](@entry_id:755368)和形式化证明等手段完成。验证证据 $\pi_{\mathrm{ver}}(r, a, \sigma)=1$ 表明，在观察到的行为 $\sigma$下，制品 $a$ 满足了需求 $r$。

- **确认**旨在回答：“我们构建了正确的系统吗？”（Are we building the right system?）。它评估最终成型的系统是否满足了利益相关者的真实需求和预期用途，尤其是在其预期的操作环境中。确认活动关注从需求**“向上”**链接到利益相关者目标（stakeholder goals）和操作场景（operational scenarios）。例如，确认[自动驾驶](@entry_id:270800)汽车的安全性，不仅需要验证其代码是否符合需求，更需要在真实的或高保真的仿真环境中（如利用数字孪生），测试它是否能在各种复杂的交通场景下有效避免事故，满足“安全”这一首要目标（overarching goal）。确认证据 $\pi_{\mathrm{val}}(r,g,e,\sigma)=1$ 表明，在环境 $e$ 和目标 $g$ 的背景下，需求 $r$ 的实现是充分且恰当的。

在使用[数字孪生](@entry_id:171650)进行V&V时，一个核心挑战是模型**保真度（Fidelity）**。任何源自数字孪生模型的证据，其有效性都取决于该模型与物理实体行为的一致性。因此，在确认过程中，必须持续监控并确保[数字孪生](@entry_id:171650)与物理系统之间的偏差 $\Delta(t) = \|\mathbf{y}_{\mathrm{DT}}(t) - \mathbf{y}_{\mathrm{phy}}(t)\|$ 保持在可接受的界限 $\delta$ 之内。

##### 双向可追溯性的必要性

仅有从高层需求到低层实现的“前向”追溯链接是远远不够的。在[安全关键系统](@entry_id:1131166)中，**双向可追溯性（Bidirectional Traceability）**是强制性的。它不仅允许我们从需求追到实现，还允许我们从任何一个底层制品反向追溯到其源头的需求、风险和动机。

双向追溯的必要性可以通过一个安全场景生动地说明。考虑一个协作机器人，其安全需求 $R_1$ 规定[接触力](@entry_id:165079) $F_{\text{contact}}$ 不得超过 $150\,\mathrm{N}$。该力的大小取决于一个控制器参数 $k_f$ 和一个通过校准得到的物理[齿轮比](@entry_id:270296)参数 $g$。假设系统只有从 $R_1$ 到设计再到 $k_f$ 的前向链接。在一次维护后，机器人的物理部件被重新校准，导致[齿轮比](@entry_id:270296) $g$ 发生了 $10\%$ 的变化。这是一个底层校准文件的变更。由于缺乏从 $g$ 到上游的**反向链接**，变更影响分析无法察觉到这个改动会影响到安全需求 $R_1$。结果，没有人重新验证系统，而实际上，新的接触力可能已经超过了 $165\,\mathrm{N}$，导致了一个未被发现的严重安全隐患。

要解决这个问题，必须建立从底层制品到上层需求的 traceability path。例如，通过建立 $A_g \leftrightarrow M \leftrightarrow R_1$ 的双向链接（其中 $A_g$ 是[齿轮比](@entry_id:270296)的校准制品，$M$ 是分析模型），任何对 $A_g$ 的修改都会立即触发一个向上游的变更传播，通知相关人员必须重新评估和验证安全需求 $R_1$ 是否仍然满足。

##### 变更影响分析

双向可追溯性为**变更影响分析（Change Impact Analysis）**提供了机制基础。当系统中任何一个制品发生变更时，我们可以通过遍历追溯图来系统性地识别所有可能受影响的其他制品。

我们可以将变更影响分析形式化为一个在追溯图 $G$ 上的**[可达性问题](@entry_id:273375)**。一个变更事件由发生变更的节点 $x$、变更类型 $\delta$ 和变更发生的上下文 $\theta$ (如时间、操作模式) 定义。影响的传播并不是无条件的，它取决于：
1.  **传播策略（Propagation Policy）$\Pi$**：一个[策略函数](@entry_id:136948) $\Pi(\tau(e), \delta, \theta)$ 决定了对于类型为 $\tau(e)$ 的边，在变更类型为 $\delta$ 和上下文为 $\theta$ 时，影响是否允许传播。例如，一个需求的“澄清”变更可能只影响其下游的实现，而一个“删除”变更则会影响所有相关的制品。
2.  **动态激活（Dynamic Activation）$\alpha$**：对于代表动态依赖（如数据流）的边，其影响[传播能力](@entry_id:756124)可能取决于系统当前的操作模式。激活谓词 $\alpha(e, \theta)$ 判断边 $e$ 在上下文 $\theta$ 中是否是活动的。

受影响制品的集合 $I$ 是从初始变更节点 $x$ 开始，遵循所有满足传播策略和激活条件的有向边，进行[传递闭包](@entry_id:262879)所能到达的所有节点的集合。这个集合可以通过一个**最小不动点（least fixpoint）**计算来迭代求得。从初始集合 $S_0 = \{x\}$ 开始，反复应用扩展函数 $F(S) = S \cup \{ v \mid \exists u \in S, \exists e: \mathrm{src}(e)=u, \mathrm{dst}(e)=v, \dots \}$，直到集合 $S$ 不再增大为止。这个最终的集合 $I$ 就是完整的、最小的受影响制品集。

##### 可追溯性质量度量

建立追溯链接本身并不能保证质量。一个杂乱、错误或不完整的追溯图谱可能比没有还要糟糕，因为它会带来虚假的安全感。因此，必须对可追溯性本身的质量进行度量和管理。关键的质量度量包括：

- **覆盖率（Coverage）**：确保[关键路径](@entry_id:265231)是完整的。例如，对于安全需求，覆盖率度量从危害（Hazard）到需求（Requirement），再到设计（Design）、代码（Code）、测试（Test）直至最终验证证据（Verification Evidence）的端到端追溯链的完整[性比](@entry_id:172643)例。任何一个断裂的链条都意味着安全论证存在缺口。
- **正确性（Correctness）**：确保追溯链接是有意义和准确的。这可以通过专家评审的抽样检查来评估，并使用统计指标如**[精确率](@entry_id:190064)（Precision）**（存在的链接中有多少是正确的）和**召回率（Recall）**（所有应存在的链接中有多少被找到了）来量化。对于安全关键系统，这两个指标都必须非常高（例如，$>0.98$）。
- **完整性（Completeness）**：从另一个角度看覆盖率，确保所有顶层制品（如所有已识别的危害）都被下游的制品充分地覆盖和处理。
- **及时性（Timeliness）**：确保在发生变更后，追溯信息和受影响的制品能够被及时地更新。这通常通过服务水平目标（SLO）来定义，例如，“$99\%$ 的需求变更必须在 $24$ 小时内完成其影响分析并更新所有下游制品”，并设置一个最坏情况下的硬性截止时间。

##### 在[基于模型的系统工程](@entry_id:1128002)（MBSE）中的实现

可追溯性的抽象图模型在现代**[基于模型的系统工程](@entry_id:1128002)（Model-Based Systems Engineering, MBSE）**实践中得到了具体的实现。**系统建模语言（Systems Modeling Language, SysML）**提供了一套标准的图和关系，用于构建集成的系统模型，其中包括了强大的需求建模和追溯能力。

在SysML中，需求本身被视为一等模型公民，拥有ID、文本描述和属性。它们之间的追溯关系通过特定的构造型（stereotypes）来表示：
- **`«satisfy»`**: 从一个设计制品（如一个`Block`）指向一个需求。这是一种强语义链接，断言该设计制品在所有允许的条件下都能满足该需求。
- **`«verify»`**: 从一个测试用例或分析活动（`Activity`）指向一个需求。它表示该活动为需求的满足提供了证据。与`«satisfy»`不同，`«verify»`通过测试仅证明在采样执行下的满足性，而非普遍的正确性。
- **`«refine»` / `«deriveReqt»`**: 在需求之间建立层级关系。这表示子需求是对父需求的逻辑强化，即满足所有子需求是满足父需求的充分条件（但通常不是必要条件）。例如，一个系统级的“settling time $\le 1$s”需求，可以被分解为对控制器[阻尼比](@entry_id:262264)（$\zeta \ge 0.7$）和机械结构固有频率（$\omega_n \ge 8$ rad/s）的两个派生需求。这种分解的有效性通常由一个**参数图（Parametric Diagram）**中的物理或控制理论约束来保证。
- **`«trace»`**: 一个通用的、语义较弱的导航链接，用于表示两个模型元素之间存在某种非正式的关联。

通过在统一的MBSE环境中系统地使用这些关系，工程师们构建了一个活的、可查询、可分析的追溯图谱，将本章讨论的所有原则和机制——从需求定义、形式化、安全分析到V&V——集成到一个连贯的框架之中。