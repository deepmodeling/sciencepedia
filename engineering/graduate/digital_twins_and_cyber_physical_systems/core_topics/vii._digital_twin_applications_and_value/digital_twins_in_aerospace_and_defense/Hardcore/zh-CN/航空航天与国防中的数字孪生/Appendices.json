{
    "hands_on_practices": [
        {
            "introduction": "任何高保真度数字孪生的基石都是一个精确的数学模型。本练习旨在通过一个核心的航空航天应用场景，将理论与实践相结合：利用运行数据来校准一个物理信息模型。我们将为一个简化的涡扇发动机数字孪生推导并校准其参数，这是一个典型的“灰箱”建模任务，它教授了系统辨识这一基本技能，对于创建能够准确反映物理实体行为的数字孪生至关重要。",
            "id": "4216540",
            "problem": "在航空航天与国防 (AD) 领域的涡扇发动机数字孪生 (DT) 背景下，考虑一个从第一性原理构建的、基于物理信息的灰箱辨识任务。从转子动力学平衡出发，该平衡遵循牛顿第二旋转定律：转子的角动量因燃油扭矩与空气动力负载之间的差异而改变。在某个工作点附近进行线性化，并以周期 $\\Delta t$ 进行离散时间采样后，可得到转子转速偏差 $n_k$ 的一阶离散动力学模型，以及到推力偏差 $T_k$ 的静态仿射映射：\n- 状态更新：$n_{k+1} = a\\,n_k + b\\,u_k + w_k$，\n- 测量：$T_k = \\gamma\\,n_k + \\eta\\,u_k + v_k$，\n其中 $u_k$ 是指令燃油流量偏差（无量纲），$a$ 和 $b$ 是反映转子惯量和空气动力阻尼的离散时间系数，$\\gamma$ 和 $\\eta$ 参数化了推力如何依赖于转子转速和燃油流量，而 $w_k$ 和 $v_k$ 是零均值过程噪声和测量噪声。推力 $T_k$ 的单位是牛顿 (N)。过程噪声和测量噪声被建模为高斯噪声，且测量具有已知的、可能非均匀的标准差。\n\n从这些基本定义出发，通过消除未测量的状态 $n_k$，推导出一个仅依赖于可观测量 $T_k$ 和 $u_k$ 的可辨识回归模型。然后，将测量噪声视为异方差的，其标准差 $\\sigma_k$ 对于 $T_k$ 是已知的。利用在高斯噪声下最大似然估计 (MLE) 与广义最小二乘法 (GLS) 一致的原理，使用提供的运行数据集来标定这个可观测回归模型的参数。为确保数值稳定性并处理潜在的近奇异法方程，应使用 Tikhonov 正则化，在参数法向矩阵上增加一个小的超参数 $\\lambda = 10^{-6}$。在所有计算中，将 $b'$ 和 $\\eta$ 解释为以牛顿 (N) 为单位，将 $a$ 解释为无量纲，但仅打印数值，不带单位。\n\n必须用已知的标准差对残差进行白化，以评估拟合优度。使用以下指标量化拟合优度：\n- 白化残差平方均值，定义为 $\\frac{1}{N}\\sum_{k} \\left(\\frac{r_k}{\\sigma_k}\\right)^2$，其中 $r_k$ 是对应于回归输出的推力样本处的残差。\n- 在已知方差的异方差高斯噪声下的赤池信息准则 (AIC)，定义为 $AIC = 2p - 2\\log L$，其中 $p$ 是标定的参数数量，$\\log L = -\\frac{1}{2}\\sum_k \\left[\\log(2\\pi \\sigma_k^2) + \\frac{r_k^2}{\\sigma_k^2}\\right]$ 是对数似然。\n\n实现一个程序，执行以下步骤：\n1. 从上述基本定律和定义出发，在消除了 $n_k$ 后，推导出以 $T_{k+1}$、$T_k$、$u_k$ 和 $u_{k+1}$ 表示的可观测线性回归模型。使用岭正则化 $\\lambda = 10^{-6}$ 的 GLS 方法标定其参数。\n2. 计算每个输出样本的残差，用提供的标准差进行白化，计算白化残差平方均值，并使用异方差高斯似然计算 $AIC$。\n\n使用以下三个运行数据集的测试套件。每个数据集提供输入指令序列 $u_k$（无量纲）、测量的推力 $T_k$（单位：牛顿 N）和测量标准差 $\\sigma_k$（单位：牛顿 N）。所有序列都已时间对齐并均匀采样；您必须在连续索引 $k$ 上构建回归样本，其中 $T_{k+1}$ 由 $(T_k, u_k, u_{k+1})$ 预测。在每个数据集中，当数组长度为 $K$ 时，使用样本 $k=0,1,\\dots, K-2$。\n\n数据集 1（典型激励，中等噪声）：\n- $u^{(1)} = [0.20, 0.20, 0.25, 0.25, 0.35, 0.35, 0.30, 0.40, 0.50, 0.50, 0.45, 0.55, 0.60]$\n- $T^{(1)} = [150.0, 152.5, 165.0, 170.0, 230.0, 235.0, 225.0, 275.0, 340.0, 345.0, 335.0, 390.0, 420.0]$ 单位：N\n- $\\sigma^{(1)} = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]$ 单位：N\n\n数据集 2（近边际稳定，响应慢，噪声较低）：\n- $u^{(2)} = [0.30, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41]$\n- $T^{(2)} = [240.0, 242.0, 244.5, 247.0, 249.0, 251.5, 254.0, 256.0, 258.5, 261.0, 263.0, 265.5]$ 单位：N\n- $\\sigma^{(2)} = [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0]$ 单位：N\n\n数据集 3（激励弱，输入近乎恒定，噪声小）：\n- $u^{(3)} = [0.40, 0.40, 0.40, 0.41, 0.39, 0.40, 0.40, 0.41, 0.39, 0.40]$\n- $T^{(3)} = [300.0, 301.0, 300.5, 302.0, 299.0, 300.5, 300.0, 302.0, 298.5, 300.0]$ 单位：N\n- $\\sigma^{(3)} = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]$ 单位：N\n\n对于每个数据集 $i \\in \\{1,2,3\\}$，计算：\n- 标定后的回归参数 $[a^{(i)}, b^{\\prime (i)}, \\eta^{(i)}]$，其中 $a$ 是无量纲的，$b'$ 和 $\\eta$ 的单位均为 N，\n- 白化残差平方均值，\n- 赤池信息准则。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个包含三个子列表的列表，每个数据集一个子列表，每个子列表按 $[a, b', \\eta, \\text{MSWR}, \\text{AIC}]$ 的顺序排列。以标准十进制形式打印每个浮点数。例如，输出必须类似于\n$[[a_1,b'_1,\\eta_1,mswr_1,aic_1],[a_2,b'_2,\\eta_2,mswr_2,aic_2],[a_3,b'_3,\\eta_3,mswr_3,aic_3]]$。",
            "solution": "该问题要求使用运行数据对一个简化的涡扇发动机模型进行参数辨识。这是一个灰箱辨识任务，从一个基于物理信息的状态空间模型开始，推导出一个可观测的回归形式。\n\n### 步骤 1：可观测回归模型的推导\n\n所提供的涡扇发动机动力学的离散时间线性化模型由一个状态空间表示给出：\n1.  转子转速偏差 $n_k$ 的状态更新方程：\n    $$n_{k+1} = a\\,n_k + b\\,u_k + w_k \\quad (*)$$\n2.  推力偏差 $T_k$ 的测量方程：\n    $$T_k = \\gamma\\,n_k + \\eta\\,u_k + v_k \\quad (**)$$\n\n在这里，$n_k$ 是未测量的状态变量（转子转速），而 $T_k$（推力）和 $u_k$（燃油流量指令）是可观测量。项 $w_k$ 和 $v_k$ 分别代表零均值的高斯过程噪声和测量噪声。与 $T_k$ 相关的测量噪声 $v_k$ 是异方差的，具有已知的标准差 $\\sigma_k$。\n\n目标是推导出一个仅关联可观测变量的方程。这通过代数方法消除未观测状态 $n_k$ 来实现。从测量方程 $(**)$，我们可以将 $n_k$ 表示为：\n$$\\gamma\\,n_k = T_k - \\eta\\,u_k - v_k$$\n假设 $\\gamma \\neq 0$（这是一个物理上的必要条件，因为转子转速必须影响推力），我们得到：\n$$n_k = \\frac{1}{\\gamma}(T_k - \\eta\\,u_k - v_k)$$\n\n为了将其代入状态更新方程 $(*)$，我们还需要 $n_{k+1}$ 的表达式。将 $n_k$ 表达式中的时间索引从 $k$ 推进到 $k+1$ 得到：\n$$n_{k+1} = \\frac{1}{\\gamma}(T_{k+1} - \\eta\\,u_{k+1} - v_{k+1})$$\n\n现在，将 $n_k$ 和 $n_{k+1}$ 的表达式代入状态方程 $(*)$：\n$$\\frac{1}{\\gamma}(T_{k+1} - \\eta\\,u_{k+1} - v_{k+1}) = a\\left[\\frac{1}{\\gamma}(T_k - \\eta\\,u_k - v_k)\\right] + b\\,u_k + w_k$$\n\n为了简化，我们将整个方程乘以 $\\gamma$：\n$$T_{k+1} - \\eta\\,u_{k+1} - v_{k+1} = a(T_k - \\eta\\,u_k - v_k) + \\gamma b\\,u_k + \\gamma w_k$$\n\n我们重新整理这个方程，将可观测项分组到一侧，噪声项分组到另一侧。我们寻求一个能预测下一个推力测量值 $T_{k+1}$ 的模型：\n$$T_{k+1} = a\\,T_k - a\\eta\\,u_k + \\gamma b\\,u_k + \\eta\\,u_{k+1} + (v_{k+1} - a\\,v_k + \\gamma w_k)$$\n\n对输入 $u_k$ 的系数进行分组，我们得到：\n$$T_{k+1} = a\\,T_k + (\\gamma b - a\\eta)\\,u_k + \\eta\\,u_{k+1} + \\epsilon_{k+1}$$\n其中 $\\epsilon_{k+1} = v_{k+1} - a\\,v_k + \\gamma w_k$ 是一个复合的有色噪声项。\n\n该方程是一个标准的线性回归形式，具体来说是一个带外部输入的自回归模型 (ARX)。需要辨识的参数是可观测项的系数。我们为回归模型定义新的参数：\n- $\\theta_1 = a$\n- $\\theta_2 = b' = \\gamma b - a\\eta$\n- $\\theta_3 = \\eta$\n\n问题规定 $a$ 是无量纲的，而 $b'$ 和 $\\eta$ 的单位是牛顿 ($N$)，这与推导出的方程一致，其中 $T_k$ 的单位是 $N$，$u_k$ 是无量纲的。因此，可辨识的回归模型是：\n$$T_{k+1} = a\\,T_k + b'\\,u_k + \\eta\\,u_{k+1} + \\epsilon_{k+1} \\quad (***)$$\n\n### 步骤 2：使用带正则化的广义最小二乘法 (GLS) 进行参数估计\n\n误差项 $\\epsilon_{k+1}$ 是噪声源的移动平均，使其具有序列相关性。然而，在方程误差法中，一个常见且有效的简化是假设误差主要由最近的测量噪声主导，即 $\\epsilon_{k+1} \\approx v_{k+1}$。在此假设下，误差近似不相关，但保留了测量噪声的异方差性，即 $\\text{Var}(\\epsilon_{k+1}) \\approx \\text{Var}(v_{k+1}) = \\sigma_{k+1}^2$。\n\n这种异方差性促使我们使用广义最小二乘法 (GLS)。对于高斯噪声，GLS 等价于最大似然估计 (MLE)。GLS 通过将每个回归方程除以其误差项的标准差来进行标准化。对于方程 $(***)$，标准差是 $\\sigma_{k+1}$。这个过程称为白化，它产生：\n$$\\frac{T_{k+1}}{\\sigma_{k+1}} = a\\left(\\frac{T_k}{\\sigma_{k+1}}\\right) + b'\\left(\\frac{u_k}{\\sigma_{k+1}}\\right) + \\eta\\left(\\frac{u_{k+1}}{\\sigma_{k+1}}\\right) + \\frac{\\epsilon_{k+1}}{\\sigma_{k+1}}$$\n新的误差项的方差近似为 $1$，使得问题适合在变换后的变量上应用普通最小二乘法 (OLS)。\n\n对于一个长度为 $K$ 的数据集，我们可以为 $k \\in \\{0, 1, \\dots, K-2\\}$ 构建 $N = K-1$ 个这样的方程。我们可以将其表示为矩阵形式 $\\tilde{\\mathbf{Y}} = \\tilde{\\mathbf{X}}\\theta$，其中 $\\theta = [a, b', \\eta]^T$。\n- 白化响应向量是 $\\tilde{\\mathbf{Y}} \\in \\mathbb{R}^{N}$：\n  $$\\tilde{\\mathbf{Y}} = \\begin{bmatrix} T_1 / \\sigma_1 \\\\ T_2 / \\sigma_2 \\\\ \\vdots \\\\ T_{K-1} / \\sigma_{K-1} \\end{bmatrix}$$\n- 白化回归矩阵是 $\\tilde{\\mathbf{X}} \\in \\mathbb{R}^{N \\times 3}$：\n  $$\\tilde{\\mathbf{X}} = \\begin{bmatrix}\n  T_0 / \\sigma_1  u_0 / \\sigma_1  u_1 / \\sigma_1 \\\\\n  T_1 / \\sigma_2  u_1 / \\sigma_2  u_2 / \\sigma_2 \\\\\n  \\vdots  \\vdots  \\vdots \\\\\n  T_{K-2} / \\sigma_{K-1}  u_{K-2} / \\sigma_{K-1}  u_{K-1} / \\sigma_{K-1}\n  \\end{bmatrix}$$\n\n问题要求使用 Tikhonov 正则化（岭回归）以确保数值稳定性。参数向量 $\\theta$ 通过最小化正则化平方误差来找到：\n$$\\min_{\\theta} ||\\tilde{\\mathbf{Y}} - \\tilde{\\mathbf{X}}\\theta||_2^2 + \\lambda ||\\theta||_2^2$$\n其中 $\\lambda = 10^{-6}$ 是正则化超参数。这个问题的解由正则化法方程给出：\n$$\\hat{\\theta} = (\\tilde{\\mathbf{X}}^T\\tilde{\\mathbf{X}} + \\lambda\\mathbf{I})^{-1}\\tilde{\\mathbf{X}}^T\\tilde{\\mathbf{Y}}$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。\n\n### 步骤 3：拟合优度评估\n\n一旦估计出参数向量 $\\hat{\\theta} = [\\hat{a}, \\hat{b}', \\hat{\\eta}]^T$，我们就评估模型的性能。\n\n首先，我们计算模型对输出样本 $k=1, \\dots, K-1$ 的预测值 $\\hat{T}_{k+1}$ 和相应的残差 $r_{k+1}$：\n$$\\hat{T}_{k+1} = \\hat{a}\\,T_k + \\hat{b}'\\,u_k + \\hat{\\eta}\\,u_{k+1}$$\n$$r_{k+1} = T_{k+1} - \\hat{T}_{k+1}$$\n\n**白化残差平方均值 (MSWR)** 衡量了以噪声方差为单位的平均平方误差：\n$$\\text{MSWR} = \\frac{1}{N}\\sum_{k=1}^{K-1} \\left(\\frac{r_k}{\\sigma_k}\\right)^2$$\n其中 $N = K-1$ 是拟合数据点的数量。\n\n**赤池信息准则 (AIC)** 提供了一种衡量模型质量的指标，该指标对复杂性进行惩罚。对于一个具有 $p$ 个参数和已知方差 $\\sigma_k^2$ 的异方差高斯噪声模型，AIC 定义为 $AIC = 2p - 2\\log L$。对数似然 $L$ 是：\n$$\\log L = -\\frac{1}{2}\\sum_{k=1}^{K-1} \\left[\\log(2\\pi \\sigma_k^2) + \\frac{r_k^2}{\\sigma_k^2}\\right]$$\n这里，$p=3$（对于 $a, b', \\eta$）。求和是在 $N=K-1$ 个输出样本上进行的。这可以重写为计算形式：\n$$\\text{AIC} = 2p + \\sum_{k=1}^{N} \\left[\\log(2\\pi\\sigma_{k, \\text{out}}^2) + \\left(\\frac{r_{k, \\text{out}}}{\\sigma_{k, \\text{out}}}\\right)^2\\right] = 2p + N\\log(2\\pi) + 2\\sum_{k=1}^{N}\\log(\\sigma_{k, \\text{out}}) + N \\cdot \\text{MSWR}$$\n其中求和及各项是针对 $N$ 个输出样本进行索引的。\n\n这个全面的程序可以对发动机模型进行稳健的标定，并对其预测准确性和统计有效性进行量化评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process datasets and print the final results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset 1\n        {\n            \"u\": np.array([0.20, 0.20, 0.25, 0.25, 0.35, 0.35, 0.30, 0.40, 0.50, 0.50, 0.45, 0.55, 0.60]),\n            \"T\": np.array([150.0, 152.5, 165.0, 170.0, 230.0, 235.0, 225.0, 275.0, 340.0, 345.0, 335.0, 390.0, 420.0]),\n            \"sigma\": np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]),\n        },\n        # Dataset 2\n        {\n            \"u\": np.array([0.30, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41]),\n            \"T\": np.array([240.0, 242.0, 244.5, 247.0, 249.0, 251.5, 254.0, 256.0, 258.5, 261.0, 263.0, 265.5]),\n            \"sigma\": np.array([3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0]),\n        },\n        # Dataset 3\n        {\n            \"u\": np.array([0.40, 0.40, 0.40, 0.41, 0.39, 0.40, 0.40, 0.41, 0.39, 0.40]),\n            \"T\": np.array([300.0, 301.0, 300.5, 302.0, 299.0, 300.5, 300.0, 302.0, 298.5, 300.0]),\n            \"sigma\": np.array([2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_dataset(case[\"u\"], case[\"T\"], case[\"sigma\"])\n        results.append(result)\n\n    # Format the final output string manually to match the required format without spaces.\n    sublist_strs = []\n    for sublist in results:\n        # Each float is converted to its standard string representation.\n        sublist_strs.append(f\"[{','.join(map(str, sublist))}]\")\n    \n    final_output = f\"[{','.join(sublist_strs)}]\"\n    print(final_output)\n\ndef process_dataset(u, T, sigma):\n    \"\"\"\n    Performs GLS regression with regularization and calculates goodness-of-fit metrics.\n\n    Args:\n        u (np.array): Input command sequence.\n        T (np.array): Measured thrust sequence.\n        sigma (np.array): Measurement standard deviation sequence.\n\n    Returns:\n        list: A list containing [a, b', eta, MSWR, AIC].\n    \"\"\"\n    lambda_reg = 1e-6\n    \n    # 1. Prepare data for regression\n    # The regression predicts T_{k+1} from (T_k, u_k, u_{k+1}).\n    # For a dataset of length K, we form N = K-1 regression samples.\n    K = len(T)\n    N = K - 1\n\n    # Output samples (T_1, ..., T_{K-1})\n    T_out = T[1:]\n    sigma_out = sigma[1:]\n\n    # Regressor samples (T_0, ..., T_{K-2}), (u_0, ..., u_{K-2}), (u_1, ..., u_{K-1})\n    T_reg = T[:-1]\n    u_reg = u[:-1]\n    u_reg_p1 = u[1:]\n\n    # 2. Formulate whitened (GLS) problem\n    # Divide each regression equation by the corresponding sigma of the output.\n    Y_tilde = T_out / sigma_out\n\n    X_tilde_col1 = T_reg / sigma_out\n    X_tilde_col2 = u_reg / sigma_out\n    X_tilde_col3 = u_reg_p1 / sigma_out\n    \n    X_tilde = np.stack([X_tilde_col1, X_tilde_col2, X_tilde_col3], axis=1)\n\n    # 3. Solve for parameters using regularized least squares\n    num_params = X_tilde.shape[1]\n    I = np.identity(num_params)\n    \n    # Normal matrix H = X_tilde^T * X_tilde + lambda * I\n    H = X_tilde.T @ X_tilde + lambda_reg * I\n    # Right-hand side g = X_tilde^T * Y_tilde\n    g = X_tilde.T @ Y_tilde\n    \n    # Solve H * theta = g for theta\n    theta = np.linalg.solve(H, g)\n    a, b_prime, eta = theta\n\n    # 4. Calculate goodness-of-fit metrics\n    # Predict thrust using the obtained parameters\n    T_pred = a * T_reg + b_prime * u_reg + eta * u_reg_p1\n    \n    # Calculate residuals\n    residuals = T_out - T_pred\n    \n    # Calculate whitened residuals\n    whitened_residuals = residuals / sigma_out\n    \n    # Mean of Squared Whitened Residuals (MSWR)\n    mswr = np.mean(whitened_residuals**2)\n    \n    # Akaike Information Criterion (AIC)\n    p = num_params\n    # logL = -0.5 * sum(log(2*pi*sigma_k^2) + (r_k/sigma_k)^2)\n    # AIC = 2*p - 2*logL\n    logL = -0.5 * np.sum(np.log(2 * np.pi * sigma_out**2) + whitened_residuals**2)\n    aic = 2 * p - 2 * logL\n    \n    return [a, b_prime, eta, mswr, aic]\n\n\nsolve()\n\n```"
        },
        {
            "introduction": "数字孪生的一个关键功能是实时估计其物理对应物的状态，尤其是在测量数据含有噪声或存在非线性动态时。本练习将带领您实践两种现代估计理论中的基石算法：扩展卡尔曼滤波器（EKF）和无迹卡尔曼滤波器（UKF）。通过在一个非线性目标跟踪问题中比较它们的性能，您将深入理解它们在不同条件下的优劣，这对于为航空航天平台设计鲁棒的导航和跟踪系统至关重要。",
            "id": "4216505",
            "problem": "在国防背景下，航空航天跟踪数字孪生必须融合非线性雷达测量值，以实时估计运动学状态。考虑一个用于空中目标的平面地基跟踪数字孪生，其被建模为一个离散时间非线性系统。在时间步 $k$ 的目标状态为 $x_k = [p_{x,k}, p_{y,k}, v_k, \\psi_k]^\\top$，其中 $p_{x,k}$ 和 $p_{y,k}$ 是以米为单位的平面笛卡尔坐标位置分量，$v_k$ 是以米/秒为单位的速度，$\\psi_k$ 是以弧度为单位的航向角。控制输入是一个已知的恒定转弯速率 $\\omega$，单位为弧度/秒。动力学遵循运动学的基本原理：\n$$\np_{x,k+1} = p_{x,k} + \\Delta t \\, v_k \\cos(\\psi_k), \\quad\np_{y,k+1} = p_{y,k} + \\Delta t \\, v_k \\sin(\\psi_k),\n$$\n$$\nv_{k+1} = v_k, \\quad\n\\psi_{k+1} = \\psi_k + \\omega \\Delta t,\n$$\n带有加性零均值高斯过程噪声 $w_k \\sim \\mathcal{N}(0, Q)$，其中 $Q$ 是一个 $4 \\times 4$ 的协方差矩阵。位于原点的固定式地基雷达提供测量值 $z_k = [r_k, \\theta_k]^\\top$，其中\n$$\nr_k = \\sqrt{p_{x,k}^2 + p_{y,k}^2}, \\quad\n\\theta_k = \\operatorname{atan2}(p_{y,k}, p_{x,k}),\n$$\n带有加性零均值高斯测量噪声 $v_k \\sim \\mathcal{N}(0, R)$，其中 $R$ 是一个 $2 \\times 2$ 的协方差矩阵。在计算差值或平均值时，角度必须以弧度处理，并归一化到区间 $(-\\pi, \\pi]$。\n\n实现扩展卡尔曼滤波器（EKF）和无迹卡尔曼滤波器（UKF），以基于给定的测量序列计算后验状态估计和后验协方差矩阵。EKF必须通过围绕当前估计值对非线性动力学和测量函数进行一阶线性化来推导。UKF必须通过使用确定性sigma点集和适当权重的无迹变换来推导。对两个滤波器使用相同的仿真真值和测量值，以便在非线性条件下公平比较其性能。\n\n基本依据和假设：\n- 离散时间状态空间系统遵循 $x_{k+1} = f(x_k) + w_k$ 和 $z_k = h(x_k) + v_k$，其中 $w_k$ 和 $v_k$ 是相互独立的零均值高斯噪声。\n- 地面真值轨迹由无噪声动力学 $x_{k+1}^{\\text{true}} = f(x_k^{\\text{true}})$ 生成，然后测量值由 $z_k = h(x_k^{\\text{true}}) + v_k$ 形成。\n- 使用固定的伪随机种子 $42$ 以便可复现地生成测量噪声。\n\n滤波的初始条件（所有测试用例通用）：\n- 初始真值状态 $x_0^{\\text{true}} = [p_{x,0}, p_{y,0}, v_0, \\psi_0]^\\top$ 是依情况而定的（具体如下所述）。\n- 初始状态估计 $x_0 = x_0^{\\text{true}} + [\\delta p_x, \\delta p_y, \\delta v, \\delta \\psi]^\\top$，其中 $\\delta p_x = 50 \\,\\text{m}$，$\\delta p_y = -50 \\,\\text{m}$，$\\delta v = -20 \\,\\text{m/s}$，以及 $\\delta \\psi = 5^\\circ$ 转换为弧度。\n- 初始协方差 $P_0 = \\operatorname{diag}([\\sigma_{p_x}^2, \\sigma_{p_y}^2, \\sigma_v^2, \\sigma_\\psi^2])$，其中 $\\sigma_{p_x} = 100 \\,\\text{m}$，$\\sigma_{p_y} = 100 \\,\\text{m}$，$\\sigma_v = 25 \\,\\text{m/s}$，以及 $\\sigma_\\psi = 10^\\circ$ 转换为弧度。\n- 过程噪声协方差 $Q = \\operatorname{diag}([\\sigma_{q,p_x}^2, \\sigma_{q,p_y}^2, \\sigma_{q,v}^2, \\sigma_{q,\\psi}^2])$，依情况而定（具体如下所述）。\n\nEKF规范：\n- 对 $f(\\cdot)$ 和 $h(\\cdot)$ 使用一阶泰勒线性化，以推导状态转移雅可比矩阵 $F_k = \\left.\\frac{\\partial f}{\\partial x}\\right|_{x=x_k}$ 和测量雅可比矩阵 $H_k = \\left.\\frac{\\partial h}{\\partial x}\\right|_{x=\\hat{x}_{k|k-1}}$。\n- 预测：$\\hat{x}_{k|k-1} = f(\\hat{x}_{k-1|k-1})$，$P_{k|k-1} = F_{k-1} P_{k-1|k-1} F_{k-1}^\\top + Q$。\n- 更新：$S_k = H_k P_{k|k-1} H_k^\\top + R$，$K_k = P_{k|k-1} H_k^\\top S_k^{-1}$，新息 $\\nu_k = z_k - h(\\hat{x}_{k|k-1})$（其角度分量需归一化），后验 $\\hat{x}_{k|k} = \\hat{x}_{k|k-1} + K_k \\nu_k$，$P_{k|k} = (I - K_k H_k) P_{k|k-1}$。\n\nUKF规范：\n- 使用带有参数 $\\alpha$、$\\beta$ 和 $\\kappa$ 的无迹变换。令状态维度 $n = 4$ 且 $\\lambda = \\alpha^2 (n + \\kappa) - n$。使用 $(n + \\lambda) P_{k-1|k-1}$ 的 Cholesky 因子，围绕 $\\hat{x}_{k-1|k-1}$ 生成 $2n+1$ 个 sigma 点。对均值和协方差使用相应的权重 $W^{(m)}$ 和 $W^{(c)}$。将 sigma 点通过 $f(\\cdot)$ 和 $h(\\cdot)$ 传播，对角度分量应用考虑角度的平均法，对差值应用角度归一化。分别在预测和测量协方差步骤中加入 $Q$ 和 $R$。使用互协方差和卡尔曼增益执行标准的UKF更新。\n\n性能指标：\n- 为每个滤波器计算在整个序列上的位置均方根误差（RMSE）：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{k=1}^N \\left[(\\hat{p}_{x,k} - p_{x,k}^{\\text{true}})^2 + (\\hat{p}_{y,k} - p_{y,k}^{\\text{true}})^2\\right]},\n$$\n单位为米。将所有RMSE值表示为十进制数（打印输出中不含单位，但数值必须对应于米）。同时计算比率 $\\rho = \\text{RMSE}_{\\text{UKF}} / \\text{RMSE}_{\\text{EKF}}$（无量纲）。\n\n测试套件和参数：\n- 情况 $1$（一般情况，轻度非线性）：\n  - $\\Delta t = 1 \\,\\text{s}$，$N = 20$，$\\omega = 0.05 \\,\\text{rad/s}$，$v_0 = 250 \\,\\text{m/s}$，$x_0^{\\text{true}} = [1000 \\,\\text{m}, 0 \\,\\text{m}, v_0, 0 \\,\\text{rad}]^\\top$。\n  - 测量噪声：$\\sigma_r = 30 \\,\\text{m}$，$\\sigma_\\theta = 0.5^\\circ$ 转换为弧度；$R = \\operatorname{diag}([\\sigma_r^2, \\sigma_\\theta^2])$。\n  - 过程噪声：$\\sigma_{q,p_x} = 5 \\,\\text{m}$，$\\sigma_{q,p_y} = 5 \\,\\text{m}$，$\\sigma_{q,v} = 1 \\,\\text{m/s}$，$\\sigma_{q,\\psi} = 0.1^\\circ$ 转换为弧度。\n- 情况 $2$（更高非线性度，更急转弯和更近距离）：\n  - $\\Delta t = 0.5 \\,\\text{s}$，$N = 40$，$\\omega = 0.2 \\,\\text{rad/s}$，$v_0 = 200 \\,\\text{m/s}$，$x_0^{\\text{true}} = [500 \\,\\text{m}, 200 \\,\\text{m}, v_0, \\frac{\\pi}{6} \\,\\text{rad}]^\\top$。\n  - 测量噪声：$\\sigma_r = 20 \\,\\text{m}$，$\\sigma_\\theta = 0.3^\\circ$ 转换为弧度；$R = \\operatorname{diag}([\\sigma_r^2, \\sigma_\\theta^2])$。\n  - 过程噪声：$\\sigma_{q,p_x} = 3 \\,\\text{m}$，$\\sigma_{q,p_y} = 3 \\,\\text{m}$，$\\sigma_{q,v} = 2 \\,\\text{m/s}$，$\\sigma_{q,\\psi} = 0.2^\\circ$ 转换为弧度。\n- 情况 $3$（测量噪声非常大）：\n  - $\\Delta t = 1 \\,\\text{s}$，$N = 30$，$\\omega = 0.1 \\,\\text{rad/s}$，$v_0 = 220 \\,\\text{m/s}$，$x_0^{\\text{true}} = [1500 \\,\\text{m}, -300 \\,\\text{m}, v_0, \\frac{\\pi}{4} \\,\\text{rad}]^\\top$。\n  - 测量噪声：$\\sigma_r = 100 \\,\\text{m}$，$\\sigma_\\theta = 1.5^\\circ$ 转换为弧度；$R = \\operatorname{diag}([\\sigma_r^2, \\sigma_\\theta^2])$。\n  - 过程噪声：$\\sigma_{q,p_x} = 10 \\,\\text{m}$，$\\sigma_{q,p_y} = 10 \\,\\text{m}$，$\\sigma_{q,v} = 5 \\,\\text{m/s}$，$\\sigma_{q,\\psi} = 0.5^\\circ$ 转换为弧度。\n- 情况 $4$（靠近原点的几何结构增加了雅可比矩阵的敏感性）：\n  - $\\Delta t = 0.5 \\,\\text{s}$，$N = 25$，$\\omega = 0.15 \\,\\text{rad/s}$，$v_0 = 180 \\,\\text{m/s}$，$x_0^{\\text{true}} = [50 \\,\\text{m}, 50 \\,\\text{m}, v_0, -\\frac{\\pi}{3} \\,\\text{rad}]^\\top$。\n  - 测量噪声：$\\sigma_r = 10 \\,\\text{m}$，$\\sigma_\\theta = 0.8^\\circ$ 转换为弧度；$R = \\operatorname{diag}([\\sigma_r^2, \\sigma_\\theta^2])$。\n  - 过程噪声：$\\sigma_{q,p_x} = 2 \\,\\text{m}$，$\\sigma_{q,p_y} = 2 \\,\\text{m}$，$\\sigma_{q,v} = 1 \\,\\text{m/s}$，$\\sigma_{q,\\psi} = 0.3^\\circ$ 转换为弧度。\n\nUKF参数（所有情况通用）：$\\alpha = 10^{-3}$，$\\beta = 2$，$\\kappa = 0$。\n\n你的程序必须：\n- 使用指定的 $x_0^{\\text{true}}$、$\\Delta t$、$N$ 和 $\\omega$ 来仿真真值轨迹和测量序列，其中测量噪声使用种子 $42$ 生成。\n- 运行EKF和UKF，计算 $k = 1, \\ldots, N$ 的后验估计 $\\hat{x}_{k|k}$ 和后验协方差 $P_{k|k}$。\n- 为每种情况计算EKF和UKF的位置RMSE（单位：米），以及比率 $\\rho$（无量纲）。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须是扁平化的，并按 $[\\text{RMSE}_{\\text{EKF},1}, \\text{RMSE}_{\\text{UKF},1}, \\rho_1, \\text{RMSE}_{\\text{EKF},2}, \\text{RMSE}_{\\text{UKF},2}, \\rho_2, \\text{RMSE}_{\\text{EKF},3}, \\text{RMSE}_{\\text{UKF},3}, \\rho_3, \\text{RMSE}_{\\text{EKF},4}, \\text{RMSE}_{\\text{UKF},4}, \\rho_4]$ 的顺序排列。\n\n所有角度必须始终以弧度为单位。将所有RMSE值表示为米单位的十进制数。比率必须表示为十进制数。",
            "solution": "用户在非线性状态估计领域提供了一个定义明确的航空航天跟踪应用问题。任务是实现、比较和评估扩展卡尔曼滤波器（EKF）和无迹卡尔曼滤波器（UKF）的性能。问题陈述经确认在科学上是合理的、自洽的且客观的。它为进行求解提供了所有必要的模型、参数和初始条件。\n\n解决方案需要实现以下组件：\n1.  一个仿真环境，用于生成空中目标的地面真值轨迹以及相应的带噪声雷达测量值。\n2.  扩展卡尔曼滤波器算法，该算法在每个时间步对非线性系统和测量模型进行线性化。\n3.  无迹卡尔曼滤波器算法，该算法使用一组确定性采样点（sigma点）来捕捉状态分布的均值和协方差，为非线性系统提供比EKF线性化通常更准确的近似。\n4.  一个用于计算两种滤波器相对于地面真值的位置估算均方根误差（RMSE）的例程。\n\n在时间步 $k$ 的目标状态由向量 $x_k = [p_{x,k}, p_{y,k}, v_k, \\psi_k]^\\top$ 表示，其中 $(p_{x,k}, p_{y,k})$ 是笛卡尔坐标位置，$v_k$ 是速度，$\\psi_k$ 是航向角。来自雷达的测量值为 $z_k = [r_k, \\theta_k]^\\top$，包括距离和方位角。所有角度量均以弧度处理，并特别注意归一化到区间 $(-\\pi, \\pi]$。\n\n首先，我们定义非线性状态转移函数 $f(\\cdot)$ 和测量函数 $h(\\cdot)$：\n状态转移函数 $x_{k+1} = f(x_k, u_k)$ 由下式给出，其中控制输入 $u_k$ 包括转弯速率 $\\omega$ 和时间步长 $\\Delta t$：\n$$f(x_k) = \\begin{bmatrix} p_{x,k} + \\Delta t \\, v_k \\cos(\\psi_k) \\\\ p_{y,k} + \\Delta t \\, v_k \\sin(\\psi_k) \\\\ v_k \\\\ \\psi_k + \\omega \\Delta t \\end{bmatrix}$$\n测量函数 $z_k = h(x_k)$ 为：\n$$h(x_k) = \\begin{bmatrix} \\sqrt{p_{x,k}^2 + p_{y,k}^2} \\\\ \\operatorname{atan2}(p_{y,k}, p_{x,k}) \\end{bmatrix}$$\n\n一个辅助函数 `normalize_angle` 对于正确处理循环量至关重要。它将任何给定的角度调整到区间 $(-\\pi, \\pi]$。这在计算新息或对角度求平均值时是关键。\n\n对于EKF，我们必须推导 $f$ 和 $h$ 的雅可比矩阵。状态转移雅可比矩阵 $F_k = \\frac{\\partial f}{\\partial x}|_{\\hat{x}_{k-1|k-1}}$ 是：\n$$F_k = \\begin{bmatrix} 1  0  \\Delta t \\cos(\\hat{\\psi}_{k-1|k-1})  -\\Delta t \\hat{v}_{k-1|k-1} \\sin(\\hat{\\psi}_{k-1|k-1}) \\\\ 0  1  \\Delta t \\sin(\\hat{\\psi}_{k-1|k-1})  \\Delta t \\hat{v}_{k-1|k-1} \\cos(\\hat{\\psi}_{k-1|k-1}) \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\end{bmatrix}$$\n测量雅可比矩阵 $H_k = \\frac{\\partial h}{\\partial x}|_{\\hat{x}_{k|k-1}}$ 是：\n$$H_k = \\begin{bmatrix} \\frac{\\hat{p}_{x,k|k-1}}{\\sqrt{\\hat{p}_{x,k|k-1}^2 + \\hat{p}_{y,k|k-1}^2}}  \\frac{\\hat{p}_{y,k|k-1}}{\\sqrt{\\hat{p}_{x,k|k-1}^2 + \\hat{p}_{y,k|k-1}^2}}  0  0 \\\\ -\\frac{\\hat{p}_{y,k|k-1}}{\\hat{p}_{x,k|k-1}^2 + \\hat{p}_{y,k|k-1}^2}  \\frac{\\hat{p}_{x,k|k-1}}{\\hat{p}_{x,k|k-1}^2 + \\hat{p}_{y,k|k-1}^2}  0  0 \\end{bmatrix}$$\n然后EKF继续其标准的预测和更新两步循环，使用这些雅可比矩阵来传播协方差矩阵。角度 `theta` 的新息必须进行归一化。\n\n对于UKF，我们采用无迹变换。给定状态维度 $n=4$ 和指定的参数 $\\alpha=10^{-3}$、$\\beta=2$、$\\kappa=0$，我们首先计算缩放参数 $\\lambda = \\alpha^2(n+\\kappa)-n$。然后我们使用缩放后协方差矩阵 $(n+\\lambda)P$ 的Cholesky分解，在当前状态估计周围生成一组 $2n+1=9$ 个sigma点。这些 sigma 点通过非线性函数 $f$ 和 $h$ 进行传播。然后使用一组精心选择的权重，从变换后的 sigma 点重构出预测状态、预测测量值及其各自的协方差。一个关键的实现细节是角度的处理：角度 sigma 点（对于 $\\psi$ 和 $\\theta$）的均值必须通过对其正弦和余弦的加权和取 `atan2` 来计算。同样，涉及角度的差值也必须进行归一化。\n\n主程序逻辑将遍历四个不同的测试用例。对于每个用例：\n1.  设置特定的参数（$\\Delta t$、$N$、$\\omega$、噪声协方差、初始真值状态）。\n2.  滤波器的初始状态和协方差根据指定的方式从初始真值状态派生而来。\n3.  地面真值轨迹使用函数 $f$ 确定性地生成。\n4.  使用以指定种子 $42$ 初始化的伪随机数生成器，从地面真值生成带噪声的测量值。\n5.  EKF和UKF在 $N$ 个时间步的序列上执行，每个滤波器处理相同的测量数据。\n6.  计算并存储两个滤波器的位置RMSE及其比率 $\\rho$。\n\n最后，将所有四个用例收集到的结果按要求格式化为单个字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy  # Allowed, though not strictly necessary for this implementation\n\ndef solve():\n    \"\"\"\n    Implements and compares EKF and UKF for a nonlinear tracking problem\n    across four test cases.\n    \"\"\"\n\n    def normalize_angle(angle):\n        \"\"\"Normalize an angle to the range [-pi, pi].\"\"\"\n        return (angle + np.pi) % (2 * np.pi) - np.pi\n\n    def state_transition_function(x, dt, omega):\n        \"\"\"\n        Computes the state transition for the constant turn rate model.\n        x = [px, py, v, psi]\n        \"\"\"\n        px, py, v, psi = x\n        px_new = px + dt * v * np.cos(psi)\n        py_new = py + dt * v * np.sin(psi)\n        v_new = v\n        psi_new = psi + omega * dt # Normalization applied after in filters\n        return np.array([px_new, py_new, v_new, psi_new])\n\n    def measurement_function(x):\n        \"\"\"\n        Computes the measurement [range, bearing] from the state.\n        \"\"\"\n        px, py, _, _ = x\n        r = np.sqrt(px**2 + py**2)\n        theta = np.arctan2(py, px)\n        return np.array([r, theta])\n\n    def state_jacobian(x, dt):\n        \"\"\"\n        Computes the Jacobian of the state transition function (F).\n        The omega term is part of the model, not the state.\n        \"\"\"\n        _, _, v, psi = x\n        F = np.eye(4)\n        F[0, 2] = dt * np.cos(psi)\n        F[0, 3] = -dt * v * np.sin(psi)\n        F[1, 2] = dt * np.sin(psi)\n        F[1, 3] = dt * v * np.cos(psi)\n        return F\n\n    def measurement_jacobian(x):\n        \"\"\"\n        Computes the Jacobian of the measurement function (H).\n        \"\"\"\n        px, py, _, _ = x\n        r_sq = px**2 + py**2\n        if r_sq  1e-9:  # Avoid division by zero\n            r_sq = 1e-9\n        r = np.sqrt(r_sq)\n        H = np.zeros((2, 4))\n        H[0, 0] = px / r\n        H[0, 1] = py / r\n        H[1, 0] = -py / r_sq\n        H[1, 1] = px / r_sq\n        return H\n\n    def run_ekf(measurements, x0, P0, Q, R, dt, omega, N):\n        \"\"\"Runs the Extended Kalman Filter simulation.\"\"\"\n        x_est = x0.copy()\n        P_est = P0.copy()\n        est_history = np.zeros((N, 4))\n\n        for k in range(N):\n            # Predict\n            F = state_jacobian(x_est, dt)\n            x_pred = state_transition_function(x_est, dt, omega)\n            x_pred[3] = normalize_angle(x_pred[3])\n            P_pred = F @ P_est @ F.T + Q\n\n            # Update\n            H = measurement_jacobian(x_pred)\n            z_pred = measurement_function(x_pred)\n            \n            y = measurements[k] - z_pred\n            y[1] = normalize_angle(y[1]) # Normalize angle innovation\n\n            S = H @ P_pred @ H.T + R\n            K = P_pred @ H.T @ np.linalg.inv(S)\n            \n            x_est = x_pred + K @ y\n            x_est[3] = normalize_angle(x_est[3]) # Normalize heading\n            P_est = (np.eye(4) - K @ H) @ P_pred\n\n            est_history[k] = x_est\n\n        return est_history\n\n    def run_ukf(measurements, x0, P0, Q, R, dt, omega, N):\n        \"\"\"Runs the Unscented Kalman Filter simulation.\"\"\"\n        n = 4  # State dimension\n        alpha = 1e-3\n        beta = 2.0\n        kappa = 0.0\n        \n        lambda_ = alpha**2 * (n + kappa) - n\n        \n        # Weights for mean\n        Wm = np.full(2 * n + 1, 1 / (2 * (n + lambda_)))\n        Wm[0] = lambda_ / (n + lambda_)\n        \n        # Weights for covariance\n        Wc = np.full(2 * n + 1, 1 / (2 * (n + lambda_)))\n        Wc[0] = lambda_ / (n + lambda_) + (1 - alpha**2 + beta)\n\n        x_est = x0.copy()\n        P_est = P0.copy()\n        est_history = np.zeros((N, 4))\n\n        for k in range(N):\n            # --- PREDICT ---\n            \n            # 1. Generate sigma points\n            L = np.linalg.cholesky((n + lambda_) * P_est)\n            sigmas = np.zeros((2 * n + 1, n))\n            sigmas[0] = x_est\n            for i in range(n):\n                sigmas[i + 1] = x_est + L[:, i]\n                sigmas[i + 1 + n] = x_est - L[:, i]\n            \n            # 2. Propagate sigma points through dynamics\n            sigmas_pred = np.array([state_transition_function(s, dt, omega) for s in sigmas])\n            \n            # 3. Calculate predicted mean\n            x_pred = np.zeros(n)\n            # Linear components\n            x_pred[:3] = np.sum(Wm[:, np.newaxis] * sigmas_pred[:, :3], axis=0)\n            # Angular component (psi)\n            sum_sin = np.sum(Wm * np.sin(sigmas_pred[:, 3]))\n            sum_cos = np.sum(Wm * np.cos(sigmas_pred[:, 3]))\n            x_pred[3] = np.arctan2(sum_sin, sum_cos)\n\n            # 4. Calculate predicted covariance\n            P_pred = np.zeros((n, n))\n            for i in range(2 * n + 1):\n                diff = sigmas_pred[i] - x_pred\n                diff[3] = normalize_angle(diff[3])\n                P_pred += Wc[i] * np.outer(diff, diff)\n            P_pred += Q\n            \n            # --- UPDATE ---\n\n            # 5. Propagate predicted sigma points through measurement model\n            Z_sigmas = np.array([measurement_function(s) for s in sigmas_pred])\n            \n            # 6. Calculate predicted measurement\n            z_pred = np.zeros(2)\n            # Linear component (r)\n            z_pred[0] = np.sum(Wm * Z_sigmas[:, 0])\n            # Angular component (theta)\n            sum_sin = np.sum(Wm * np.sin(Z_sigmas[:, 1]))\n            sum_cos = np.sum(Wm * np.cos(Z_sigmas[:, 1]))\n            z_pred[1] = np.arctan2(sum_sin, sum_cos)\n            \n            # 7. Calculate innovation covariance (S) and cross-covariance (T)\n            S = np.zeros((2, 2))\n            T = np.zeros((n, 2))\n            for i in range(2 * n + 1):\n                # Measurement residual\n                z_diff = Z_sigmas[i] - z_pred\n                z_diff[1] = normalize_angle(z_diff[1])\n                S += Wc[i] * np.outer(z_diff, z_diff)\n                \n                # State residual\n                x_diff = sigmas_pred[i] - x_pred\n                x_diff[3] = normalize_angle(x_diff[3])\n                T += Wc[i] * np.outer(x_diff, z_diff)\n            S += R\n            \n            # 8. Calculate Kalman gain and update state/covariance\n            K = T @ np.linalg.inv(S)\n            y = measurements[k] - z_pred\n            y[1] = normalize_angle(y[1])\n            \n            x_est = x_pred + K @ y\n            x_est[3] = normalize_angle(x_est[3])\n            P_est = P_pred - K @ S @ K.T\n            \n            est_history[k] = x_est\n\n        return est_history\n\n    def calculate_rmse(estimates, truth):\n        \"\"\"Calculates position RMSE.\"\"\"\n        pos_errors = estimates[:, :2] - truth[:, :2]\n        squared_errors = np.sum(pos_errors**2, axis=1)\n        return np.sqrt(np.mean(squared_errors))\n\n    test_cases = [\n        # Case 1\n        {\n            'dt': 1.0, 'N': 20, 'omega': 0.05, 'v0': 250.0,\n            'x0_true': np.array([1000.0, 0.0, 250.0, 0.0]),\n            'sigma_r': 30.0, 'sigma_theta_deg': 0.5,\n            'sigma_q_p': 5.0, 'sigma_q_v': 1.0, 'sigma_q_psi_deg': 0.1\n        },\n        # Case 2\n        {\n            'dt': 0.5, 'N': 40, 'omega': 0.2, 'v0': 200.0,\n            'x0_true': np.array([500.0, 200.0, 200.0, np.pi/6]),\n            'sigma_r': 20.0, 'sigma_theta_deg': 0.3,\n            'sigma_q_p': 3.0, 'sigma_q_v': 2.0, 'sigma_q_psi_deg': 0.2\n        },\n        # Case 3\n        {\n            'dt': 1.0, 'N': 30, 'omega': 0.1, 'v0': 220.0,\n            'x0_true': np.array([1500.0, -300.0, 220.0, np.pi/4]),\n            'sigma_r': 100.0, 'sigma_theta_deg': 1.5,\n            'sigma_q_p': 10.0, 'sigma_q_v': 5.0, 'sigma_q_psi_deg': 0.5\n        },\n        # Case 4\n        {\n            'dt': 0.5, 'N': 25, 'omega': 0.15, 'v0': 180.0,\n            'x0_true': np.array([50.0, 50.0, 180.0, -np.pi/3]),\n            'sigma_r': 10.0, 'sigma_theta_deg': 0.8,\n            'sigma_q_p': 2.0, 'sigma_q_v': 1.0, 'sigma_q_psi_deg': 0.3\n        }\n    ]\n\n    all_results = []\n    \n    # Common initial estimate perturbations\n    delta_x = np.array([50.0, -50.0, -20.0, np.deg2rad(5)])\n    P0_diag = np.array([100.0**2, 100.0**2, 25.0**2, np.deg2rad(10.0)**2])\n    P0 = np.diag(P0_diag)\n\n    for case in test_cases:\n        # Setup case parameters\n        dt, N, omega = case['dt'], case['N'], case['omega']\n        x0_true = case['x0_true']\n\n        # Initial conditions for filters\n        x0 = x0_true + delta_x\n        x0[3] = normalize_angle(x0[3])\n        \n        # Process Noise Covariance Q\n        Q_diag = np.array([\n            case['sigma_q_p']**2, \n            case['sigma_q_p']**2, \n            case['sigma_q_v']**2, \n            np.deg2rad(case['sigma_q_psi_deg'])**2\n        ])\n        Q = np.diag(Q_diag)\n\n        # Measurement Noise Covariance R\n        R_diag = np.array([\n            case['sigma_r']**2, \n            np.deg2rad(case['sigma_theta_deg'])**2\n        ])\n        R = np.diag(R_diag)\n        \n        # Generate data\n        rng = np.random.default_rng(42)\n        truth_history = np.zeros((N, 4))\n        measurements = np.zeros((N, 2))\n        \n        x_true = x0_true.copy()\n        for k in range(N):\n            # The problem states to use the true state from the previous step k to generate z_k\n            # and the true state for k+1. Let's start with x0_true for z_0, then evolve.\n            # But the problem asks for posterior for k=1..N, so we need N measurements starting from x1_true.\n            # So, we first evolve the state from x0_true to x1_true, then generate z1, and so on.\n            x_true = state_transition_function(x_true, dt, omega)\n            x_true[3] = normalize_angle(x_true[3])\n            truth_history[k] = x_true\n\n            # Generate noisy measurement\n            z_true = measurement_function(x_true)\n            v_k = rng.multivariate_normal([0, 0], R)\n            measurements[k] = z_true + v_k\n            measurements[k, 1] = normalize_angle(measurements[k, 1])\n\n        # Run filters\n        ekf_history = run_ekf(measurements, x0, P0, Q, R, dt, omega, N)\n        ukf_history = run_ukf(measurements, x0, P0, Q, R, dt, omega, N)\n        \n        # Calculate performance metrics\n        rmse_ekf = calculate_rmse(ekf_history, truth_history)\n        rmse_ukf = calculate_rmse(ukf_history, truth_history)\n        rho = rmse_ukf / rmse_ekf if rmse_ekf != 0 else float('inf')\n        \n        all_results.extend([rmse_ekf, rmse_ukf, rho])\n\n    # Final print statement\n    print(f\"[{','.join(f'{x:.6f}' for x in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数字孪生在预测和预防安全关键问题方面展现出巨大价值，允许工程师在虚拟环境中探索物理系统可能遇到的危险。本练习深入探讨了航空航天领域一个至关重要的课题——气动弹性力学，并指导您如何通过求解耦合系统的特征值问题来预测飞行器的颤振速度。这项实践充分展示了数字孪生作为虚拟测试平台的能力，能够在真实飞行发生前识别和规避潜在的灾难性风险。",
            "id": "4216584",
            "problem": "航空航天与国防领域的数字孪生致力于通过将结构模型与气动模型耦合，并通过特征值问题分析其稳定性，来可靠地预测气动弹性颤振速度。考虑一个代表单位翼展升力面沉浮和俯仰运动的两自由度典型翼段。设广义坐标为 $q(t) = [h(t), \\alpha(t)]^\\top$，其中 $h$ 是单位为 $\\mathrm{m}$ 的沉浮位移，$\\alpha$ 是单位为 $\\mathrm{rad}$ 的俯仰角。耦合的线性化运动方程可以写为\n$$\n\\mathbf{M} \\ddot{q}(t) + \\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\\dot{q}(t) + \\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right) q(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{M} \\in \\mathbb{R}^{2\\times 2}$ 是对称正定的结构质量矩阵，$\\mathbf{C}_0 \\in \\mathbb{R}^{2\\times 2}$ 是结构阻尼矩阵，$\\mathbf{K}_0 \\in \\mathbb{R}^{2\\times 2}$ 是结构刚度矩阵，而 $\\mathbf{C}_1, \\mathbf{K}_1 \\in \\mathbb{R}^{2\\times 2}$ 是随动压 $q(U)$ 线性变化的气动影响矩阵。动压由经过充分验证的公式给出\n$$\nq(U) = \\tfrac{1}{2}\\,\\rho\\,U^2,\n$$\n其中 $\\rho$ 是空气密度，单位为 $\\mathrm{kg/m^3}$，$U$ 是空速，单位为 $\\mathrm{m/s}$。\n\n定义一阶状态向量 $x(t) = [q(t)^\\top, \\dot{q}(t)^\\top]^\\top \\in \\mathbb{R}^{4}$，并构建状态矩阵 $\\mathbf{A}(U) \\in \\mathbb{R}^{4\\times 4}$ 如下\n$$\n\\mathbf{A}(U) = \n\\begin{bmatrix}\n\\mathbf{0}_{2\\times 2}  \\mathbf{I}_{2\\times 2} \\\\\n-\\mathbf{M}^{-1}\\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right)  -\\mathbf{M}^{-1}\\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\n\\end{bmatrix}.\n$$\n对于给定的 $U$，$\\mathbf{A}(U)$ 的特征值 $\\{\\lambda_i(U)\\}_{i=1}^4$ 描述了系统的稳定性。设\n$$\n\\sigma(U) = \\max_{\\{i:\\ \\mathrm{Im}(\\lambda_i(U)) \\neq 0\\}} \\mathrm{Re}\\left(\\lambda_i(U)\\right)\n$$\n为振荡（虚部非零）特征值中的最大实部。将区间 $[U_{\\min}, U_{\\max}]$ 上的颤振速度 $U_f$ 定义为此区间内使 $\\sigma(U)$ 从负值穿越到非负值的最小 $U$，即满足 $\\sigma(U) = 0$、$\\sigma(U^-)  0$、$\\sigma(U^+) \\ge 0$ 且控制特征值对的 $\\mathrm{Im}(\\lambda_i(U)) \\neq 0$ 的最小 $U$。如果区间内不存在这样的 $U$，则报告 $U_f = -1.0$。\n\n使用此基于原理的定义，实现一个数值程序，该程序：\n- 对于每个测试案例，构建 $\\mathbf{A}(U)$，计算 $\\sigma(U)$，通过扫描 $U$ 在指定区间上找到 $\\sigma(U)$ 根的区间，并通过二分法优化颤振速度 $U_f$，直到绝对区间宽度小于 $10^{-3}\\ \\mathrm{m/s}$。\n- 将计算出的 $U_f$ 与飞行测试数据进行比较，以评估数字孪生模型的置信度。\n\n每个测试用例的置信度评估规则：\n- 如果飞行测试提供了实测颤振速度 $U_{\\text{meas}}$（标志 $f=1$），则当 $U_f \\neq -1.0$ 且 $|U_f - U_{\\text{meas}}| \\le \\Delta_U$ 时，声明模型可信，其中 $\\Delta_U$ 是一个以 $\\mathrm{m/s}$ 为单位的容差。\n- 如果飞行测试表明在 $U_{\\text{env}}$ 之前未发生颤振（标志 $f=0$），则当 $U_f = -1.0$ 或 $U_f > U_{\\text{env}}$ 时，声明模型可信。\n\n科学基础和单位：\n- 使用 $q(U) = \\tfrac{1}{2}\\rho U^2$，其中 $\\rho = 1.225\\ \\mathrm{kg/m^3}$。\n- 所有速度必须以 $\\mathrm{m/s}$ 表示。\n- 角度以 $\\mathrm{rad}$ 为单位。\n- 返回的颤振速度必须四舍五入到三位小数，如果在搜索区间内未检测到颤振，则返回 $-1.0$。\n\n测试套件。对于所有案例，$q(U)$ 如上所示线性缩放气动矩阵。使用以下结构和气动参数及飞行测试元数据：\n\n基础结构和气动矩阵（所有案例通用）：\n- $\\mathbf{M} = \\begin{bmatrix} 70.0  12.0 \\\\ 12.0  900.0 \\end{bmatrix}$.\n- $\\mathbf{K}_0 = \\begin{bmatrix} 1.6\\times 10^{6}  0.0 \\\\ 0.0  1.2\\times 10^{5} \\end{bmatrix}$.\n- $\\mathbf{C}_0 = \\beta\\,\\mathbf{M} + \\alpha\\,\\mathbf{K}_0$，其中 $\\beta = 20.0$ 且 $\\alpha = 2.0\\times 10^{-3}$。\n- 气动基础矩阵 $\\mathbf{K}_1^{\\text{base}} = \\begin{bmatrix} -150.0  -800.0 \\\\ -800.0  -16000.0 \\end{bmatrix}$，$\\mathbf{C}_1^{\\text{base}} = \\begin{bmatrix} 200.0  1200.0 \\\\ 1200.0  30000.0 \\end{bmatrix}$。\n- 对于每个案例，根据案例指定的比例因子 $s$，设置 $\\mathbf{K}_1 = s\\cdot \\mathbf{K}_1^{\\text{base}}$ 和 $\\mathbf{C}_1 = s\\cdot \\mathbf{C}_1^{\\text{base}}$。\n\n案例：\n1. 案例 A（标称柔度）：\n   - 比例因子 $s = 1.0$。\n   - 搜索区间 $[U_{\\min}, U_{\\max}] = [40.0, 220.0]\\ \\mathrm{m/s}$。\n   - 飞行测试标志 $f=1$，实测颤振速度 $U_{\\text{meas}} = 165.0\\ \\mathrm{m/s}$。\n   - 置信度容差 $\\Delta_U = 15.0\\ \\mathrm{m/s}$。\n\n2. 案例 B（增刚机翼，扩展包线）：\n   - 比例因子 $s = 0.1$。\n   - 搜索区间 $[U_{\\min}, U_{\\max}] = [40.0, 220.0]\\ \\mathrm{m/s}$。\n   - 飞行测试标志 $f=0$，在 $U_{\\text{env}} = 220.0\\ \\mathrm{m/s}$ 之前未发生颤振。\n   - 此案例不使用置信度容差 $\\Delta_U$。\n\n3. 案例 C（软机翼，低速敏感性）：\n   - 比例因子 $s = 2.0$。\n   - 搜索区间 $[U_{\\min}, U_{\\max}] = [20.0, 120.0]\\ \\mathrm{m/s}$。\n   - 飞行测试标志 $f=1$，实测颤振速度 $U_{\\text{meas}} = 60.0\\ \\mathrm{m/s}$。\n   - 置信度容差 $\\Delta_U = 15.0\\ \\mathrm{m/s}$。\n\n算法要求：\n- 严格按照定义构建 $\\mathbf{A}(U)$。\n- 在区间上对 $U$ 进行密集扫描以定位 $\\sigma(U)$ 的符号变化，然后对该区间应用二分法求解 $\\sigma(U)=0$，直至达到指定容差。\n- 计算 $\\sigma(U)$ 时，仅考虑虚部非零的特征值；如果在给定的 $U$ 下所有特征值的虚部均为零，则为了区间划分的目的，将 $\\sigma(U)$ 视为 $-\\infty$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果：$[U_f^{A}, \\text{cred}^{A}, U_f^{B}, \\text{cred}^{B}, U_f^{C}, \\text{cred}^{C}]$。\n- 每个 $U_f^{(\\cdot)}$ 必须以 $\\mathrm{m/s}$ 为单位，四舍五入到三位小数；如果在该案例的指定区间内未发现颤振，则报告 $-1.0$。\n- 每个 $\\text{cred}^{(\\cdot)}$ 必须是如上定义的布尔值。\n\n不允许外部输入；所有参数都作为常量嵌入程序中。",
            "solution": "所提出的问题是计算气动弹性力学领域一个定义明确且有科学依据的练习，该学科是航空航天工程的核心分支。它要求确定一个两自由度典型翼段模型的颤振速度，并随后根据提供的飞行测试数据对此数字孪生预测进行置信度评估。该问题是有效的，因为它是自洽的、逻辑一致的，并且基于结构动力学和空气动力学的既定原理。\n\n求解方法分为四个主要阶段：系统建模、稳定性分析、数值求根和置信度评估。\n\n首先，系统的控制方程被表述为状态空间形式。给定的二阶线性常微分方程是：\n$$\n\\mathbf{M} \\ddot{q}(t) + \\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\\dot{q}(t) + \\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right) q(t) = \\mathbf{0}\n$$\n其中 $q(t) = [h(t), \\alpha(t)]^\\top$ 代表沉浮和俯仰自由度。通过定义状态向量 $x(t) = [q(t)^\\top, \\dot{q}(t)^\\top]^\\top$，该方程被转换为一阶系统 $\\dot{x}(t) = \\mathbf{A}(U) x(t)$。这导出了状态矩阵 $\\mathbf{A}(U)$：\n$$\n\\mathbf{A}(U) = \n\\begin{bmatrix}\n\\mathbf{0}_{2\\times 2}  \\mathbf{I}_{2\\times 2} \\\\\n-\\mathbf{M}^{-1}\\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right)  -\\mathbf{M}^{-1}\\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\n\\end{bmatrix}\n$$\n矩阵 $\\mathbf{K}_0$、$\\mathbf{C}_0$ 和 $\\mathbf{M}$ 是恒定的结构属性。气动矩阵 $\\mathbf{K}_1$ 和 $\\mathbf{C}_1$ 按动压 $q(U) = \\frac{1}{2}\\rho U^2$ 进行缩放，其中 $\\rho = 1.225\\ \\mathrm{kg/m^3}$，$U$ 是空速。\n\n首先构造常数矩阵。结构质量矩阵 $\\mathbf{M}$ 和刚度矩阵 $\\mathbf{K}_0$ 已给出。结构阻尼矩阵 $\\mathbf{C}_0$ 定义为 Rayleigh 阻尼模型：$\\mathbf{C}_0 = \\beta\\mathbf{M} + \\alpha\\mathbf{K}_0$，其中常数 $\\beta = 20.0$ 和 $\\alpha = 2.0\\times 10^{-3}$ 已指定。质量矩阵的逆 $\\mathbf{M}^{-1}$ 只计算一次并存储，因为它对于所有速度和案例都是恒定的。\n\n对于每个测试案例，使用特定案例的比例因子 $s$ 来确定气动矩阵 $\\mathbf{K}_1 = s \\cdot \\mathbf{K}_1^{\\text{base}}$ 和 $\\mathbf{C}_1 = s \\cdot \\mathbf{C}_1^{\\text{base}}$。\n\n其次，通过分析状态矩阵 $\\mathbf{A}(U)$ 的特征值 $\\{\\lambda_i(U)\\}_{i=1}^4$ 来评估系统的稳定性。颤振是一种动态不稳定性，当某个振荡模式变为无阻尼时发生。稳定性度量 $\\sigma(U)$ 定义为所有虚部非零的特征值的最大实部：\n$$\n\\sigma(U) = \\max_{\\{i:\\ \\mathrm{Im}(\\lambda_i(U)) \\neq 0\\}} \\mathrm{Re}\\left(\\lambda_i(U)\\right)\n$$\n如果 $\\sigma(U)  0$，系统是稳定的；如果在颤振边界上 $\\sigma(U) = 0$，系统是临界稳定的；如果 $\\sigma(U) > 0$，系统是不稳定的。如果在给定的空速 $U$ 下，所有特征值都是纯实数（非振荡发散），我们为了划定区间的目的，将 $\\sigma(U)$ 视为 $-\\infty$，因为这些模式与颤振无关。\n\n第三，通过数值方法找到颤振速度 $U_f$。$U_f$ 被定义为在指定搜索区间 $[U_{\\min}, U_{\\max}]$ 内，$\\sigma(U)$ 从负值变为非负值的最小空速 $U$。这对应于求解方程 $\\sigma(U) = 0$ 的最小根。数值程序是一个两步过程：\n1.  **区间划定**：使用离散空速的精细网格扫描区间 $[U_{\\min}, U_{\\max}]$，$U_j$。对于每个 $U_j$，计算函数 $\\sigma(U_j)$ 的值。满足 $\\sigma(U_j)  0$ 和 $\\sigma(U_{j+1}) \\ge 0$ 的第一对连续点 $(U_j, U_{j+1})$ 构成了一个包含根 $U_f$ 的区间 $[U_j, U_{j+1}]$。如果在整个区间内未发现此类符号变化，我们断定没有发生颤振，并将 $U_f$ 设置为 $-1.0$。选择 200 个点的扫描分辨率以确保找到一个稳健的区间。\n2.  **优化**：一旦找到区间 $[a, b]$，就采用二分法来优化根。这种迭代算法反复将区间减半，同时确保根始终位于区间内。该过程持续进行，直到区间宽度 $|b - a|$ 小于 $10^{-3}\\ \\mathrm{m/s}$ 的要求容差。然后将最终优化区间的中心点作为颤振速度 $U_f$。\n\n第四，对于每个案例，使用计算出的颤振速度 $U_f$ 与提供的飞行测试数据进行对比，以评估数字孪生模型的置信度。规则应用如下：\n-   如果测试表明在实测速度 $U_{\\text{meas}}$（标志 $f=1$）下发生颤振，则当模型找到了颤振速度（$U_f \\neq -1.0$）且该速度与实测值的差在容差 $\\Delta_U$ 之内时，即 $|U_f - U_{\\text{meas}}| \\le \\Delta_U$，模型是可信的。\n-   如果测试表明在探索到的空速 $U_{\\text{env}}$（标志 $f=0$）之前没有发生颤振，则当模型预测在该区间内没有颤振（$U_f = -1.0$）或预测的颤振速度高于已探索的包线（$U_f > U_{\\text{env}}$）时，模型是可信的。\n\n最终结果，包括四舍五入后的颤振速度 $U_f$（或 $-1.0$）和三个测试案例各自的布尔置信度评估，被编译成指定的单一列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the aeroelastic flutter problem for three test cases, assesses model\n    credibility, and prints the results in the specified format.\n    \"\"\"\n\n    # Scientific base constants and units\n    RHO = 1.225  # Air density in kg/m^3\n\n    # Base structural and aerodynamic matrices\n    M = np.array([[70.0, 12.0], [12.0, 900.0]])\n    K0 = np.array([[1.6e6, 0.0], [0.0, 1.2e5]])\n    \n    # Rayleigh damping parameters\n    BETA = 20.0\n    ALPHA = 2.0e-3\n    C0 = BETA * M + ALPHA * K0\n    \n    # Aerodynamic base matrices\n    K1_base = np.array([[-150.0, -800.0], [-800.0, -16000.0]])\n    C1_base = np.array([[200.0, 1200.0], [1200.0, 30000.0]])\n    \n    # Pre-compute constant matrix inverse and identity/zero blocks for efficiency\n    M_inv = np.linalg.inv(M)\n    I2 = np.identity(2)\n    Z2 = np.zeros((2, 2))\n    \n    # Numerical procedure constants\n    BISECTION_TOLERANCE = 1e-3\n    SCAN_POINTS = 200\n\n    def compute_sigma(U, K1, C1):\n        \"\"\"\n        Computes the stability metric sigma(U) for a given airspeed U.\n        \n        Args:\n            U (float): Airspeed in m/s.\n            K1 (np.ndarray): Aerodynamic stiffness matrix.\n            C1 (np.ndarray): Aerodynamic damping matrix.\n        \n        Returns:\n            float: The maximum real part of the oscillatory eigenvalues of A(U),\n                   or -inf if no oscillatory eigenvalues exist.\n        \"\"\"\n        if U  0:\n            return -np.inf # Physically meaningless, treated as stable.\n        \n        q_U = 0.5 * RHO * U**2\n        \n        K_U = K0 + q_U * K1\n        C_U = C0 + q_U * C1\n        \n        A_bottom_left = -M_inv @ K_U\n        A_bottom_right = -M_inv @ C_U\n        A = np.block([[Z2, I2], [A_bottom_left, A_bottom_right]])\n        \n        eigenvalues = np.linalg.eigvals(A)\n        \n        # Filter for oscillatory eigenvalues (non-zero imaginary part)\n        # Using a small tolerance for floating point comparisons\n        oscillatory_eigs = eigenvalues[np.abs(np.imag(eigenvalues)) > 1e-9]\n        \n        if oscillatory_eigs.size == 0:\n            return -np.inf\n            \n        return np.max(np.real(oscillatory_eigs))\n\n    def find_flutter_speed(U_min, U_max, K1, C1):\n        \"\"\"\n        Finds the flutter speed using scanning for bracketing and bisection for refinement.\n        \n        Returns:\n            float: The flutter speed U_f in m/s, or -1.0 if no flutter is found.\n        \"\"\"\n        # Step 1: Bracketing by scanning the interval\n        U_scan = np.linspace(U_min, U_max, SCAN_POINTS)\n        sigma_scan = np.array([compute_sigma(U, K1, C1) for U in U_scan])\n        \n        bracket = None\n        for i in range(len(U_scan) - 1):\n            if sigma_scan[i]  0 and sigma_scan[i+1] >= 0:\n                bracket = [U_scan[i], U_scan[i+1]]\n                break\n        \n        if bracket is None:\n            return -1.0\n\n        # Step 2: Refinement using bisection\n        a, b = bracket\n        max_iter = 100 # Safety break for bisection loop\n        for _ in range(max_iter):\n            if (b - a)  BISECTION_TOLERANCE:\n                break\n            mid = (a + b) / 2.0\n            sigma_mid = compute_sigma(mid, K1, C1)\n            \n            if sigma_mid  0:\n                a = mid\n            else:\n                b = mid\n        \n        U_f = (a + b) / 2.0\n        return U_f\n\n    def assess_credibility(U_f, flight_test_data):\n        \"\"\"\n        Assesses model credibility based on the computed U_f and flight test data.\n        \n        Returns:\n            bool: True if the model is credible, False otherwise.\n        \"\"\"\n        f_flag, test_speed, delta_U = flight_test_data\n        \n        if f_flag == 1:  # Measured flutter speed U_meas\n            U_meas = test_speed\n            return U_f != -1.0 and abs(U_f - U_meas) = delta_U\n        elif f_flag == 0:  # No flutter up to envelope speed U_env\n            U_env = test_speed\n            return U_f == -1.0 or U_f > U_env\n        return False\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # Case A: Nominal flexibility\n        {'s': 1.0, 'U_interval': [40.0, 220.0], 'flight_data': (1, 165.0, 15.0)},\n        # Case B: Stiffened wing\n        {'s': 0.1, 'U_interval': [40.0, 220.0], 'flight_data': (0, 220.0, None)},\n        # Case C: Soft wing\n        {'s': 2.0, 'U_interval': [20.0, 120.0], 'flight_data': (1, 60.0, 15.0)},\n    ]\n\n    final_results = []\n    for case in test_cases:\n        s = case['s']\n        U_min, U_max = case['U_interval']\n        \n        # Construct case-specific aerodynamic matrices\n        K1 = s * K1_base\n        C1 = s * C1_base\n        \n        # Compute flutter speed\n        U_f = find_flutter_speed(U_min, U_max, K1, C1)\n        \n        # Assess credibility\n        credibility = assess_credibility(U_f, case['flight_data'])\n        \n        # Append results, rounding U_f to 3 decimal places\n        final_results.append(round(U_f, 3) if U_f != -1.0 else -1.0)\n        final_results.append(credibility)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}