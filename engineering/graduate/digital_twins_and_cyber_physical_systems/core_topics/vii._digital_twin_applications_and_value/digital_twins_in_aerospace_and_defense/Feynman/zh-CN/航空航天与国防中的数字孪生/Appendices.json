{
    "hands_on_practices": [
        {
            "introduction": "航空航天数字孪生的一个关键应用是在设计阶段预测和预防灾难性的气动弹性不稳定现象，例如颤振。本练习将引导你通过构建一个耦合结构动力学和空气动力学的状态空间模型来计算飞行器的颤振速度。通过求解特征值问题并分析系统稳定性随空速的变化，你将能够亲手实践数字孪生在飞行器设计与安全认证中的核心预测能力。",
            "id": "4216584",
            "problem": "航空航天与国防领域的气动弹性力学数字孪生，旨在通过耦合结构模型与气动模型，并通过特征值问题分析其稳定性，从而可信地预测颤振速度。考虑一个代表单位翼展升力面沉浮和俯仰的两自由度典型翼段。令广义坐标为 $q(t) = [h(t), \\alpha(t)]^\\top$，其中 $h$ 是以 $\\mathrm{m}$ 为单位的沉浮位移，$\\alpha$ 是以 $\\mathrm{rad}$ 为单位的俯仰角。耦合线性化运动方程可写作：\n$$\n\\mathbf{M} \\ddot{q}(t) + \\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\\dot{q}(t) + \\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right) q(t) = \\mathbf{0},\n$$\n其中 $\\mathbf{M} \\in \\mathbb{R}^{2\\times 2}$ 是对称正定结构质量矩阵，$\\mathbf{C}_0 \\in \\mathbb{R}^{2\\times 2}$ 是结构阻尼矩阵，$\\mathbf{K}_0 \\in \\mathbb{R}^{2\\times 2}$ 是结构刚度矩阵，$\\mathbf{C}_1, \\mathbf{K}_1 \\in \\mathbb{R}^{2\\times 2}$ 是随动压 $q(U)$ 线性变化的气动影响矩阵。动压由经过充分验证的公式给出：\n$$\nq(U) = \\tfrac{1}{2}\\,\\rho\\,U^2,\n$$\n其中 $\\rho$ 是空气密度（单位 $\\mathrm{kg/m^3}$），$U$ 是空速（单位 $\\mathrm{m/s}$）。\n\n定义一阶状态向量 $x(t) = [q(t)^\\top, \\dot{q}(t)^\\top]^\\top \\in \\mathbb{R}^{4}$，并通过以下方式构造状态矩阵 $\\mathbf{A}(U) \\in \\mathbb{R}^{4\\times 4}$：\n$$\n\\mathbf{A}(U) = \n\\begin{bmatrix}\n\\mathbf{0}_{2\\times 2} & \\mathbf{I}_{2\\times 2} \\\\\n-\\mathbf{M}^{-1}\\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right) & -\\mathbf{M}^{-1}\\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\n\\end{bmatrix}.\n$$\n对于给定的 $U$，$\\mathbf{A}(U)$ 的特征值 $\\{\\lambda_i(U)\\}_{i=1}^4$ 表征其稳定性。令\n$$\n\\sigma(U) = \\max_{\\{i:\\ \\mathrm{Im}(\\lambda_i(U)) \\neq 0\\}} \\mathrm{Re}\\left(\\lambda_i(U)\\right)\n$$\n为所有振荡（虚部非零）特征值中的最大实部。将区间 $[U_{\\min}, U_{\\max}]$ 上的颤振速度 $U_f$ 定义为该区间内使 $\\sigma(U)$ 从负值穿越到非负值的最小速度 $U$，即满足 $\\sigma(U) = 0$、$\\sigma(U^-) < 0$、$\\sigma(U^+)\\ge 0$ 且控制特征值对的 $\\mathrm{Im}(\\lambda_i(U)) \\neq 0$ 的最小 $U$。如果区间内不存在这样的 $U$，则报告 $U_f = -1.0$。\n\n使用这个基于原理的定义，实现一个数值程序，该程序：\n- 对每个测试用例，构造 $\\mathbf{A}(U)$，计算 $\\sigma(U)$，通过扫描 $U$ 在指定区间上找到 $\\sigma(U)$ 的根的搜索区间，并通过二分法精化颤振速度 $U_f$，直到区间绝对宽度小于 $10^{-3}\\ \\mathrm{m/s}$。\n- 将计算出的 $U_f$ 与飞行测试数据进行比较，以评估数字孪生模型的置信度。\n\n每个测试用例的置信度评估规则：\n- 如果飞行测试提供了测量的颤振速度 $U_{\\text{meas}}$（标志 $f=1$），则当 $U_f \\neq -1.0$ 且 $|U_f - U_{\\text{meas}}| \\le \\Delta_U$ 时，判定模型为可信，其中 $\\Delta_U$ 是以 $\\mathrm{m/s}$ 为单位的容差。\n- 如果飞行测试表明在 $U_{\\text{env}}$ 速度以下未发生颤振（标志 $f=0$），则当 $U_f = -1.0$ 或 $U_f > U_{\\text{env}}$ 时，判定模型为可信。\n\n科学基础和单位：\n- 使用 $q(U) = \\tfrac{1}{2}\\rho U^2$，其中 $\\rho = 1.225\\ \\mathrm{kg/m^3}$。\n- 所有速度必须以 $\\mathrm{m/s}$ 表示。\n- 角度以 $\\mathrm{rad}$ 为单位。\n- 返回的颤振速度必须四舍五入到三位小数，如果在搜索区间内未检测到颤振，则返回 $-1.0$。\n\n测试套件。对于所有用例，$q(U)$ 如上所示线性缩放气动矩阵。使用以下结构和气动参数以及飞行测试元数据：\n\n基础结构和气动矩阵（所有用例通用）：\n- $\\mathbf{M} = \\begin{bmatrix} 70.0 & 12.0 \\\\ 12.0 & 900.0 \\end{bmatrix}$。\n- $\\mathbf{K}_0 = \\begin{bmatrix} 1.6\\times 10^{6} & 0.0 \\\\ 0.0 & 1.2\\times 10^{5} \\end{bmatrix}$。\n- $\\mathbf{C}_0 = \\beta\\,\\mathbf{M} + \\alpha\\,\\mathbf{K}_0$，其中 $\\beta = 20.0$ 且 $\\alpha = 2.0\\times 10^{-3}$。\n- 气动基矩阵 $\\mathbf{K}_1^{\\text{base}} = \\begin{bmatrix} -150.0 & -800.0 \\\\ -800.0 & -16000.0 \\end{bmatrix}$，$\\mathbf{C}_1^{\\text{base}} = \\begin{bmatrix} 200.0 & 1200.0 \\\\ 1200.0 & 30000.0 \\end{bmatrix}$。\n- 对于每个用例，设置 $\\mathbf{K}_1 = s\\cdot \\mathbf{K}_1^{\\text{base}}$ 和 $\\mathbf{C}_1 = s\\cdot \\mathbf{C}_1^{\\text{base}}$，其中每个用例指定一个比例因子 $s$。\n\n用例：\n1. 用例 A（标称柔度）：\n   - 比例因子 $s = 1.0$。\n   - 搜索区间 $[U_{\\min}, U_{\\max}] = [40.0, 220.0]\\ \\mathrm{m/s}$。\n   - 飞行测试标志 $f=1$，测量的颤振速度 $U_{\\text{meas}} = 165.0\\ \\mathrm{m/s}$。\n   - 置信度容差 $\\Delta_U = 15.0\\ \\mathrm{m/s}$。\n\n2. 用例 B（加筋机翼，扩展包线）：\n   - 比例因子 $s = 0.1$。\n   - 搜索区间 $[U_{\\min}, U_{\\max}] = [40.0, 220.0]\\ \\mathrm{m/s}$。\n   - 飞行测试标志 $f=0$，在 $U_{\\text{env}} = 220.0\\ \\mathrm{m/s}$ 速度以下无颤振。\n   - 置信度容差 $\\Delta_U$ 此用例未使用。\n\n3. 用例 C（软机翼，低速敏感性）：\n   - 比例因子 $s = 2.0$。\n   - 搜索区间 $[U_{\\min}, U_{\\max}] = [20.0, 120.0]\\ \\mathrm{m/s}$。\n   - 飞行测试标志 $f=1$，测量的颤振速度 $U_{\\text{meas}} = 60.0\\ \\mathrm{m/s}$。\n   - 置信度容差 $\\Delta_U = 15.0\\ \\mathrm{m/s}$。\n\n算法要求：\n- 精确按照定义构造 $\\mathbf{A}(U)$。\n- 在区间内对 $U$ 进行密集扫描以定位 $\\sigma(U)$ 的符号变化，然后在该区间上应用二分法求解 $\\sigma(U)=0$，直至达到指定容差。\n- 在计算 $\\sigma(U)$ 时，仅考虑虚部非零的特征值；如果在给定的 $U$ 下所有特征值的虚部均为零，则为便于划分区间，将 $\\sigma(U)$ 视为 $-\\infty$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果：$[U_f^{A}, \\text{cred}^{A}, U_f^{B}, \\text{cred}^{B}, U_f^{C}, \\text{cred}^{C}]$。\n- 每个 $U_f^{(\\cdot)}$ 必须以 $\\mathrm{m/s}$ 为单位，四舍五入到三位小数；如果在该用例的指定区间内未发现颤振，则报告 $-1.0$。\n- 每个 $\\text{cred}^{(\\cdot)}$ 必须是如上定义的布尔值。\n- 不允许外部输入；所有参数都作为常量嵌入在程序中。",
            "solution": "所提出的问题是计算气动弹性力学中一个提法得当且有科学依据的练习，而计算气动弹性力学是航空航天工程的核心学科。它要求确定一个两自由度典型翼段模型的颤振速度，并随后对照提供的飞行测试数据对该数字孪生预测进行置信度评估。该问题是有效的，因为它是自洽的、逻辑一致的，并且基于结构动力学和空气动力学的公认原理。\n\n求解方法分为四个主要阶段：系统建模、稳定性分析、数值求根和置信度评估。\n\n首先，将系统的控制方程表述为状态空间形式。给定的二阶线性常微分方程为：\n$$\n\\mathbf{M} \\ddot{q}(t) + \\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\\dot{q}(t) + \\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right) q(t) = \\mathbf{0}\n$$\n其中 $q(t) = [h(t), \\alpha(t)]^\\top$ 代表沉浮和俯仰自由度。通过定义状态向量 $x(t) = [q(t)^\\top, \\dot{q}(t)^\\top]^\\top$，将其转换为一阶系统 $\\dot{x}(t) = \\mathbf{A}(U) x(t)$。这导出了由下式给出的状态矩阵 $\\mathbf{A}(U)$：\n$$\n\\mathbf{A}(U) = \n\\begin{bmatrix}\n\\mathbf{0}_{2\\times 2} & \\mathbf{I}_{2\\times 2} \\\\\n-\\mathbf{M}^{-1}\\left(\\mathbf{K}_0 + q(U)\\,\\mathbf{K}_1\\right) & -\\mathbf{M}^{-1}\\left(\\mathbf{C}_0 + q(U)\\,\\mathbf{C}_1\\right)\n\\end{bmatrix}\n$$\n矩阵 $\\mathbf{K}_0$、$\\mathbf{C}_0$ 和 $\\mathbf{M}$ 是恒定的结构属性。气动矩阵 $\\mathbf{K}_1$ 和 $\\mathbf{C}_1$ 按动压 $q(U) = \\frac{1}{2}\\rho U^2$ 进行缩放，其中 $\\rho = 1.225\\ \\mathrm{kg/m^3}$，$U$ 是空速。\n\n首先构造常数矩阵。给定了结构质量矩阵 $\\mathbf{M}$ 和刚度矩阵 $\\mathbf{K}_0$。结构阻尼矩阵 $\\mathbf{C}_0$ 定义为 Rayleigh 阻尼模型：$\\mathbf{C}_0 = \\beta\\mathbf{M} + \\alpha\\mathbf{K}_0$，其中指定常数 $\\beta = 20.0$ 和 $\\alpha = 2.0\\times 10^{-3}$。质量矩阵的逆 $\\mathbf{M}^{-1}$ 只计算一次并存储，因为它对于所有速度和用例都是恒定的。\n\n对于每个测试用例，使用特定用例的比例因子 $s$ 来确定气动矩阵 $\\mathbf{K}_1 = s \\cdot \\mathbf{K}_1^{\\text{base}}$ 和 $\\mathbf{C}_1 = s \\cdot \\mathbf{C}_1^{\\text{base}}$。\n\n其次，通过分析状态矩阵 $\\mathbf{A}(U)$ 的特征值 $\\{\\lambda_i(U)\\}_{i=1}^4$ 来评估系统的稳定性。颤振是一种动态不稳定性，当一个振荡模态变为无阻尼时发生。稳定性指标 $\\sigma(U)$ 定义为所有具有非零虚部的特征值的最大实部：\n$$\n\\sigma(U) = \\max_{\\{i:\\ \\mathrm{Im}(\\lambda_i(U)) \\neq 0\\}} \\mathrm{Re}\\left(\\lambda_i(U)\\right)\n$$\n如果 $\\sigma(U) < 0$，系统是稳定的；如果在颤振边界上 $\\sigma(U) = 0$，系统是临界稳定的；如果 $\\sigma(U) > 0$，系统是不稳定的。如果在给定的空速 $U$ 下，所有特征值都是纯实数（非振荡发散），我们为了划分区间的目的，将 $\\sigma(U)$ 视为 $-\\infty$，因为这些模态与颤振无关。\n\n第三，通过数值方法找到颤振速度 $U_f$。$U_f$ 定义为在指定的搜索区间 $[U_{\\min}, U_{\\max}]$ 内，使 $\\sigma(U)$ 从负值穿越到非负值的最小空速 $U$。这对应于找到方程 $\\sigma(U) = 0$ 的最小根。数值程序是一个两步过程：\n1.  **区间划分**：用离散空速的细密网格 $U_j$ 扫描区间 $[U_{\\min}, U_{\\max}]$。对每个 $U_j$，计算函数 $\\sigma(U_j)$ 的值。第一对满足 $\\sigma(U_j) < 0$ 和 $\\sigma(U_{j+1}) \\ge 0$ 的连续点 $(U_j, U_{j+1})$ 构成包含根 $U_f$ 的区间 $[U_j, U_{j+1}]$。如果在整个区间内没有发现这样的符号变化，我们断定没有发生颤振，并将 $U_f$ 设置为 $-1.0$。选择 $200$ 个点的扫描分辨率以确保找到一个可靠的区间。\n2.  **精化**：一旦找到一个区间 $[a, b]$，就采用二分法来精化根。这种迭代算法重复地将区间减半，同时确保根始终位于区间内。该过程持续进行，直到区间宽度 $|b - a|$ 小于所需的 $10^{-3}\\ \\mathrm{m/s}$ 容差。然后将最终精化区间的中点作为颤振速度 $U_f$。\n\n第四，对于每个用例，使用计算出的颤振速度 $U_f$ 对照提供的飞行测试数据来评估数字孪生模型的置信度。规则应用如下：\n-   如果测试表明在测量速度 $U_{\\text{meas}}$ 时发生颤振（标志 $f=1$），则当模型找到了颤振速度（$U_f \\neq -1.0$）且该速度与测量值的差在容差 $\\Delta_U$ 之内，即 $|U_f - U_{\\text{meas}}| \\le \\Delta_U$ 时，模型是可信的。\n-   如果测试表明在探索的空速 $U_{\\text{env}}$ 以下没有颤振（标志 $f=0$），则当模型预测在区间内没有颤振（$U_f = -1.0$）或预测的颤振速度高于探索的包线（$U_f > U_{\\text{env}}$）时，模型是可信的。\n\n最终结果，包括每个测试用例四舍五入后的颤振速度 $U_f$（或 $-1.0$）和布尔值的置信度评估，被编译成指定的单一列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the aeroelastic flutter problem for three test cases, assesses model\n    credibility, and prints the results in the specified format.\n    \"\"\"\n\n    # Scientific base constants and units\n    RHO = 1.225  # Air density in kg/m^3\n\n    # Base structural and aerodynamic matrices\n    M = np.array([[70.0, 12.0], [12.0, 900.0]])\n    K0 = np.array([[1.6e6, 0.0], [0.0, 1.2e5]])\n    \n    # Rayleigh damping parameters\n    BETA = 20.0\n    ALPHA = 2.0e-3\n    C0 = BETA * M + ALPHA * K0\n    \n    # Aerodynamic base matrices\n    K1_base = np.array([[-150.0, -800.0], [-800.0, -16000.0]])\n    C1_base = np.array([[200.0, 1200.0], [1200.0, 30000.0]])\n    \n    # Pre-compute constant matrix inverse and identity/zero blocks for efficiency\n    M_inv = np.linalg.inv(M)\n    I2 = np.identity(2)\n    Z2 = np.zeros((2, 2))\n    \n    # Numerical procedure constants\n    BISECTION_TOLERANCE = 1e-3\n    SCAN_POINTS = 200\n\n    def compute_sigma(U, K1, C1):\n        \"\"\"\n        Computes the stability metric sigma(U) for a given airspeed U.\n        \n        Args:\n            U (float): Airspeed in m/s.\n            K1 (np.ndarray): Aerodynamic stiffness matrix.\n            C1 (np.ndarray): Aerodynamic damping matrix.\n        \n        Returns:\n            float: The maximum real part of the oscillatory eigenvalues of A(U),\n                   or -inf if no oscillatory eigenvalues exist.\n        \"\"\"\n        if U  0:\n            return -np.inf # Physically meaningless, treated as stable.\n        \n        q_U = 0.5 * RHO * U**2\n        \n        K_U = K0 + q_U * K1\n        C_U = C0 + q_U * C1\n        \n        A_bottom_left = -M_inv @ K_U\n        A_bottom_right = -M_inv @ C_U\n        A = np.block([[Z2, I2], [A_bottom_left, A_bottom_right]])\n        \n        eigenvalues = np.linalg.eigvals(A)\n        \n        # Filter for oscillatory eigenvalues (non-zero imaginary part)\n        # Using a small tolerance for floating point comparisons\n        oscillatory_eigs = eigenvalues[np.abs(np.imag(eigenvalues)) > 1e-9]\n        \n        if oscillatory_eigs.size == 0:\n            return -np.inf\n            \n        return np.max(np.real(oscillatory_eigs))\n\n    def find_flutter_speed(U_min, U_max, K1, C1):\n        \"\"\"\n        Finds the flutter speed using scanning for bracketing and bisection for refinement.\n        \n        Returns:\n            float: The flutter speed U_f in m/s, or -1.0 if no flutter is found.\n        \"\"\"\n        # Step 1: Bracketing by scanning the interval\n        U_scan = np.linspace(U_min, U_max, SCAN_POINTS)\n        sigma_scan = np.array([compute_sigma(U, K1, C1) for U in U_scan])\n        \n        bracket = None\n        for i in range(len(U_scan) - 1):\n            if sigma_scan[i]  0 and sigma_scan[i+1] >= 0:\n                bracket = [U_scan[i], U_scan[i+1]]\n                break\n        \n        if bracket is None:\n            return -1.0\n\n        # Step 2: Refinement using bisection\n        a, b = bracket\n        max_iter = 100 # Safety break for bisection loop\n        for _ in range(max_iter):\n            if (b - a)  BISECTION_TOLERANCE:\n                break\n            mid = (a + b) / 2.0\n            sigma_mid = compute_sigma(mid, K1, C1)\n            \n            if sigma_mid  0:\n                a = mid\n            else:\n                b = mid\n        \n        U_f = (a + b) / 2.0\n        return U_f\n\n    def assess_credibility(U_f, flight_test_data):\n        \"\"\"\n        Assesses model credibility based on the computed U_f and flight test data.\n        \n        Returns:\n            bool: True if the model is credible, False otherwise.\n        \"\"\"\n        f_flag, test_speed, delta_U = flight_test_data\n        \n        if f_flag == 1:  # Measured flutter speed U_meas\n            U_meas = test_speed\n            return U_f != -1.0 and abs(U_f - U_meas) = delta_U\n        elif f_flag == 0:  # No flutter up to envelope speed U_env\n            U_env = test_speed\n            return U_f == -1.0 or U_f > U_env\n        return False\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # Case A: Nominal flexibility\n        {'s': 1.0, 'U_interval': [40.0, 220.0], 'flight_data': (1, 165.0, 15.0)},\n        # Case B: Stiffened wing\n        {'s': 0.1, 'U_interval': [40.0, 220.0], 'flight_data': (0, 220.0, None)},\n        # Case C: Soft wing\n        {'s': 2.0, 'U_interval': [20.0, 120.0], 'flight_data': (1, 60.0, 15.0)},\n    ]\n\n    final_results = []\n    for case in test_cases:\n        s = case['s']\n        U_min, U_max = case['U_interval']\n        \n        # Construct case-specific aerodynamic matrices\n        K1 = s * K1_base\n        C1 = s * C1_base\n        \n        # Compute flutter speed\n        U_f = find_flutter_speed(U_min, U_max, K1, C1)\n        \n        # Assess credibility\n        credibility = assess_credibility(U_f, case['flight_data'])\n        \n        # Append results, rounding U_f to 3 decimal places\n        final_results.append(round(U_f, 3) if U_f != -1.0 else -1.0)\n        final_results.append(credibility)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "为了使数字孪生能够精确反映物理实体的真实状态和性能，必须使用实际运行数据对其模型进行校准。本练习将重点关注一个涡扇发动机数字孪生，你将从第一性原理出发，推导出一个可供辨识的回归模型，并利用模拟的运行数据来校准关键参数。这项实践将使你掌握灰箱系统辨识、广义最小二乘估计以及模型拟合优度评估等高级技术，这些都是创建高保真度数字孪生的核心技能。",
            "id": "4216540",
            "problem": "在航空航天与国防 (AD) 领域的涡轮风扇发动机数字孪生 (DT) 背景下，考虑一个基于第一性原理构建的灰箱、物理信息引导的辨识任务。从转子动力学平衡开始，该平衡遵循牛顿第二旋转定律：转子的角动量因燃料扭矩和空气动力负载之间的差异而改变。在某个工作点附近进行线性化，并以周期 $\\Delta t$ 进行离散时间采样后，可以得到转子速度偏差 $n_k$ 的一阶离散动力学模型，以及到推力偏差 $T_k$ 的静态仿射映射：\n- 状态更新：$n_{k+1} = a\\,n_k + b\\,u_k + w_k$，\n- 测量：$T_k = \\gamma\\,n_k + \\eta\\,u_k + v_k$，\n其中 $u_k$ 是指令燃油流量偏差（无量纲），$a$ 和 $b$ 是反映转子惯量和空气动力阻尼的离散时间系数，$\\gamma$ 和 $\\eta$ 参数化了推力如何依赖于转子速度和燃油流量，而 $w_k$ 和 $v_k$ 是零均值过程噪声和测量噪声。推力 $T_k$ 以牛顿（N）为单位测量。过程噪声和测量噪声被建模为高斯噪声，且测量的标准差已知，可能为异构。\n\n从这些基本定义出发，通过消除未测量的状态 $n_k$，推导出一个仅依赖于可观测量 $T_k$ 和 $u_k$ 的可辨识回归模型。然后，将测量噪声视为异方差的，其中 $T_k$ 的标准差 $\\sigma_k$ 已知。利用高斯噪声下最大似然估计 (MLE) 与广义最小二乘法 (GLS) 一致的原理，使用提供的运行数据集来校准这个可观测回归模型的参数。为确保数值稳定性并处理潜在的近奇异法方程，使用 Tikhonov 正则化，将一个小的超参数 $\\lambda = 10^{-6}$ 添加到参数法向矩阵中。在所有计算中，将 $b'$ 和 $\\eta$ 解释为牛顿（N），将 $a$ 解释为无量纲，但仅打印不带单位的数值。\n\n必须用已知的标准差对残差进行白化，以评估拟合优度。使用以下指标量化拟合优度：\n- 白化残差平方均值，定义为 $\\frac{1}{N}\\sum_{k} \\left(\\frac{r_k}{\\sigma_k}\\right)^2$，其中 $r_k$ 是对应于回归输出的推力样本处的残差。\n- 在已知方差的异方差高斯噪声下的 Akaike 信息准则 (AIC)，定义为 $AIC = 2p - 2\\log L$，其中 $p$ 是校准的参数数量，$\\log L = -\\frac{1}{2}\\sum_k \\left[\\log(2\\pi \\sigma_k^2) + \\frac{r_k^2}{\\sigma_k^2}\\right]$ 是对数似然。\n\n实现一个程序，执行以下步骤：\n1. 从上述基本定律和定义出发，推导出在消除 $n_k$ 后，模型所隐含的关于 $T_{k+1}$、$T_k$、$u_k$ 和 $u_{k+1}$ 的可观测线性回归模型。使用带有岭正则化 $\\lambda = 10^{-6}$ 的 GLS 校准其参数。\n2. 计算每个输出样本的残差，用提供的标准差进行白化，计算白化残差平方均值，并使用异方差高斯似然计算 $AIC$。\n\n使用以下包含三个运行数据集的测试套件。每个数据集提供输入指令序列 $u_k$（无量纲）、测量的推力 $T_k$（单位：牛顿 N）和测量标准差 $\\sigma_k$（单位：牛顿 N）。所有序列都已时间对齐且均匀采样；您必须在连续的索引 $k$ 上构建回归样本，其中 $T_{k+1}$ 是根据 $(T_k, u_k, u_{k+1})$ 预测的。在每个数据集中，当数组长度为 $K$ 时，使用样本 $k=0,1,\\dots, K-2$。\n\n数据集 1（典型激励，中等噪声）：\n- $u^{(1)} = [0.20, 0.20, 0.25, 0.25, 0.35, 0.35, 0.30, 0.40, 0.50, 0.50, 0.45, 0.55, 0.60]$\n- $T^{(1)} = [150.0, 152.5, 165.0, 170.0, 230.0, 235.0, 225.0, 275.0, 340.0, 345.0, 335.0, 390.0, 420.0]$ (单位: N)\n- $\\sigma^{(1)} = [5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]$ (单位: N)\n\n数据集 2（近边际稳定，响应慢，较低噪声）：\n- $u^{(2)} = [0.30, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41]$\n- $T^{(2)} = [240.0, 242.0, 244.5, 247.0, 249.0, 251.5, 254.0, 256.0, 258.5, 261.0, 263.0, 265.5]$ (单位: N)\n- $\\sigma^{(2)} = [3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0]$ (单位: N)\n\n数据集 3（低激励，近恒定输入，小噪声）：\n- $u^{(3)} = [0.40, 0.40, 0.40, 0.41, 0.39, 0.40, 0.40, 0.41, 0.39, 0.40]$\n- $T^{(3)} = [300.0, 301.0, 300.5, 302.0, 299.0, 300.5, 300.0, 302.0, 298.5, 300.0]$ (单位: N)\n- $\\sigma^{(3)} = [2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]$ (单位: N)\n\n对于每个数据集 $i \\in \\{1,2,3\\}$，计算：\n- 校准的回归参数 $[\\,a^{(i)}, b^{\\prime (i)}, \\eta^{(i)}\\,]$，其中 $a$ 是无量纲的，而 $b'$ 和 $\\eta$ 的单位均为 N，\n- 白化残差平方均值，\n- Akaike 信息准则。\n\n最终输出格式：您的程序应生成单行输出，包含一个含三个子列表的列表，每个子列表对应一个数据集，且每个子列表的顺序为 $[\\,a, b', \\eta, \\text{MSWR}, \\text{AIC}\\,]$。以标准十进制形式打印每个浮点数。例如，输出必须类似于\n$[\\,[a_1,b'_1,\\eta_1,mswr_1,aic_1],[a_2,b'_2,\\eta_2,mswr_2,aic_2],[a_3,b'_3,\\eta_3,mswr_3,aic_3]\\,]$。",
            "solution": "该问题要求使用运行数据对一个简化的涡轮风扇发动机模型进行参数辨识。这是一个灰箱辨识任务，从一个物理信息引导的状态空间模型出发，推导出一个可观测的回归形式。\n\n### 第1步：推导可观测回归模型\n\n所提供的涡轮风扇发动机动力学的离散时间线性化模型由一个状态空间表示给出：\n1.  转子速度偏差 $n_k$ 的状态更新方程：\n    $$n_{k+1} = a\\,n_k + b\\,u_k + w_k \\quad (*)$$\n2.  推力偏差 $T_k$ 的测量方程：\n    $$T_k = \\gamma\\,n_k + \\eta\\,u_k + v_k \\quad (**)$$\n\n在这里，$n_k$ 是未测量的状态变量（转子速度），而 $T_k$（推力）和 $u_k$（燃油流量指令）是可观测量。$w_k$ 和 $v_k$ 分别代表零均值的高斯过程噪声和测量噪声。与 $T_k$ 相关的测量噪声 $v_k$ 是异方差的，其标准差 $\\sigma_k$ 已知。\n\n目标是推导出一个只涉及可观测变量的方程。这通过代数方法消除未观测状态 $n_k$ 来实现。从测量方程 $(**)$，我们可以将 $n_k$ 表示为：\n$$\\gamma\\,n_k = T_k - \\eta\\,u_k - v_k$$\n假设 $\\gamma \\neq 0$（这是一个物理上的必然要求，因为转子速度必须影响推力），我们有：\n$$n_k = \\frac{1}{\\gamma}(T_k - \\eta\\,u_k - v_k)$$\n\n为了将此式代入状态更新方程 $(*)$，我们还需要 $n_{k+1}$ 的表达式。将 $n_k$ 表达式中的时间索引从 $k$ 推进到 $k+1$ 可得：\n$$n_{k+1} = \\frac{1}{\\gamma}(T_{k+1} - \\eta\\,u_{k+1} - v_{k+1})$$\n\n现在，将 $n_k$ 和 $n_{k+1}$ 的表达式代入状态方程 $(*)$：\n$$\\frac{1}{\\gamma}(T_{k+1} - \\eta\\,u_{k+1} - v_{k+1}) = a\\left[\\frac{1}{\\gamma}(T_k - \\eta\\,u_k - v_k)\\right] + b\\,u_k + w_k$$\n\n为简化起见，我们将整个方程乘以 $\\gamma$：\n$$T_{k+1} - \\eta\\,u_{k+1} - v_{k+1} = a(T_k - \\eta\\,u_k - v_k) + \\gamma b\\,u_k + \\gamma w_k$$\n\n我们重排此方程，将可观测项归于一侧，噪声项归于另一侧。我们寻求一个能预测下一个推力测量值 $T_{k+1}$ 的模型：\n$$T_{k+1} = a\\,T_k - a\\eta\\,u_k + \\gamma b\\,u_k + \\eta\\,u_{k+1} + (v_{k+1} - a\\,v_k + \\gamma w_k)$$\n\n合并输入 $u_k$ 的系数，我们得到：\n$$T_{k+1} = a\\,T_k + (\\gamma b - a\\eta)\\,u_k + \\eta\\,u_{k+1} + \\epsilon_{k+1}$$\n其中 $\\epsilon_{k+1} = v_{k+1} - a\\,v_k + \\gamma w_k$ 是一个复合有色噪声项。\n\n此方程是标准的线性回归形式，具体来说是一个自回归带外源输入 (ARX) 模型。待辨识的参数是可观测项的系数。让我们为我们的回归定义新的参数：\n- $\\theta_1 = a$\n- $\\theta_2 = b' = \\gamma b - a\\eta$\n- $\\theta_3 = \\eta$\n\n问题指明 $a$ 是无量纲的，而 $b'$ 和 $\\eta$ 的单位是牛顿 ($N$)，这与推导出的方程一致，其中 $T_k$ 的单位是 $N$，$u_k$ 是无量纲的。因此，可辨识的回归模型是：\n$$T_{k+1} = a\\,T_k + b'\\,u_k + \\eta\\,u_{k+1} + \\epsilon_{k+1} \\quad (***)$$\n\n### 第2步：使用带正则化的广义最小二乘法 (GLS) 进行参数估计\n\n误差项 $\\epsilon_{k+1}$ 是噪声源的移动平均，这使其具有序列相关性。然而，在方程误差法中，一个常见且有效的简化是假设误差主要由最新的测量噪声主导，即 $\\epsilon_{k+1} \\approx v_{k+1}$。在此假设下，误差近似不相关，但保留了测量噪声的异方差性，即 $\\text{Var}(\\epsilon_{k+1}) \\approx \\text{Var}(v_{k+1}) = \\sigma_{k+1}^2$。\n\n这种异方差性促使我们使用广义最小二乘法 (GLS)。对于高斯噪声，GLS 等价于最大似然估计 (MLE)。GLS 通过将每个回归方程除以其误差项的标准差来进行标准化。对于方程 $(***)$，标准差是 $\\sigma_{k+1}$。这个过程，称为白化，得到：\n$$\\frac{T_{k+1}}{\\sigma_{k+1}} = a\\left(\\frac{T_k}{\\sigma_{k+1}}\\right) + b'\\left(\\frac{u_k}{\\sigma_{k+1}}\\right) + \\eta\\left(\\frac{u_{k+1}}{\\sigma_{k+1}}\\right) + \\frac{\\epsilon_{k+1}}{\\sigma_{k+1}}$$\n新的误差项的方差近似为 $1$，这使得问题适用于对变换后的变量使用普通最小二乘法 (OLS)。\n\n对于一个长度为 $K$ 的数据集，我们可以为 $k \\in \\{0, 1, \\dots, K-2\\}$ 构建 $N = K-1$ 个这样的方程。我们可以将其表示为矩阵形式 $\\tilde{\\mathbf{Y}} = \\tilde{\\mathbf{X}}\\theta$，其中 $\\theta = [a, b', \\eta]^T$。\n- 白化响应向量为 $\\tilde{\\mathbf{Y}} \\in \\mathbb{R}^{N}$：\n  $$\\tilde{\\mathbf{Y}} = \\begin{bmatrix} T_1 / \\sigma_1 \\\\ T_2 / \\sigma_2 \\\\ \\vdots \\\\ T_{K-1} / \\sigma_{K-1} \\end{bmatrix}$$\n- 白化回归矩阵为 $\\tilde{\\mathbf{X}} \\in \\mathbb{R}^{N \\times 3}$：\n  $$\\tilde{\\mathbf{X}} = \\begin{bmatrix}\n  T_0 / \\sigma_1  u_0 / \\sigma_1  u_1 / \\sigma_1 \\\\\n  T_1 / \\sigma_2  u_1 / \\sigma_2  u_2 / \\sigma_2 \\\\\n  \\vdots  \\vdots  \\vdots \\\\\n  T_{K-2} / \\sigma_{K-1}  u_{K-2} / \\sigma_{K-1}  u_{K-1} / \\sigma_{K-1}\n  \\end{bmatrix}$$\n\n问题要求使用 Tikhonov 正则化（岭回归）来确保数值稳定性。参数向量 $\\theta$ 通过最小化正则化平方误差找到：\n$$\\min_{\\theta} ||\\tilde{\\mathbf{Y}} - \\tilde{\\mathbf{X}}\\theta||_2^2 + \\lambda ||\\theta||_2^2$$\n其中 $\\lambda = 10^{-6}$ 是正则化超参数。该问题的解由正则化法方程给出：\n$$\\hat{\\theta} = (\\tilde{\\mathbf{X}}^T\\tilde{\\mathbf{X}} + \\lambda\\mathbf{I})^{-1}\\tilde{\\mathbf{X}}^T\\tilde{\\mathbf{Y}}$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。\n\n### 第3步：拟合优度评估\n\n一旦估计出参数向量 $\\hat{\\theta} = [\\hat{a}, \\hat{b}', \\hat{\\eta}]^T$，我们便评估模型的性能。\n\n首先，我们计算模型对输出样本 $k=1, \\dots, K-1$ 的预测值 $\\hat{T}_{k+1}$ 和相应的残差 $r_{k+1}$：\n$$\\hat{T}_{k+1} = \\hat{a}\\,T_k + \\hat{b}'\\,u_k + \\hat{\\eta}\\,u_{k+1}$$\n$$r_{k+1} = T_{k+1} - \\hat{T}_{k+1}$$\n\n**白化残差平方均值 (MSWR)** 以噪声方差为单位衡量平均平方误差：\n$$\\text{MSWR} = \\frac{1}{N}\\sum_{k=1}^{K-1} \\left(\\frac{r_k}{\\sigma_k}\\right)^2$$\n其中 $N = K-1$ 是拟合的数据点数量。\n\n**Akaike 信息准则 (AIC)** 提供了一个衡量模型质量的指标，它对复杂性进行惩罚。对于一个有 $p$ 个参数且具有已知方差 $\\sigma_k^2$ 的异方差高斯噪声模型，AIC 定义为 $AIC = 2p - 2\\log L$。对数似然 $L$ 为：\n$$\\log L = -\\frac{1}{2}\\sum_{k=1}^{K-1} \\left[\\log(2\\pi \\sigma_k^2) + \\frac{r_k^2}{\\sigma_k^2}\\right]$$\n这里，$p=3$（对应 $a, b', \\eta$）。求和是针对 $N=K-1$ 个输出样本。为便于计算，这可以重写为：\n$$\\text{AIC} = 2p + \\sum_{k=1}^{N} \\left[\\log(2\\pi\\sigma_{k, \\text{out}}^2) + \\left(\\frac{r_{k, \\text{out}}}{\\sigma_{k, \\text{out}}}\\right)^2\\right] = 2p + N\\log(2\\pi) + 2\\sum_{k=1}^{N}\\log(\\sigma_{k, \\text{out}}) + N \\cdot \\text{MSWR}$$\n其中求和及各项都是针对 $N$ 个输出样本的索引。\n\n这个综合性程序能够对发动机模型进行鲁棒校准，并对其预测准确性和统计有效性进行定量评估。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process datasets and print the final results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset 1\n        {\n            \"u\": np.array([0.20, 0.20, 0.25, 0.25, 0.35, 0.35, 0.30, 0.40, 0.50, 0.50, 0.45, 0.55, 0.60]),\n            \"T\": np.array([150.0, 152.5, 165.0, 170.0, 230.0, 235.0, 225.0, 275.0, 340.0, 345.0, 335.0, 390.0, 420.0]),\n            \"sigma\": np.array([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0]),\n        },\n        # Dataset 2\n        {\n            \"u\": np.array([0.30, 0.31, 0.32, 0.33, 0.34, 0.35, 0.36, 0.37, 0.38, 0.39, 0.40, 0.41]),\n            \"T\": np.array([240.0, 242.0, 244.5, 247.0, 249.0, 251.5, 254.0, 256.0, 258.5, 261.0, 263.0, 265.5]),\n            \"sigma\": np.array([3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0, 3.0]),\n        },\n        # Dataset 3\n        {\n            \"u\": np.array([0.40, 0.40, 0.40, 0.41, 0.39, 0.40, 0.40, 0.41, 0.39, 0.40]),\n            \"T\": np.array([300.0, 301.0, 300.5, 302.0, 299.0, 300.5, 300.0, 302.0, 298.5, 300.0]),\n            \"sigma\": np.array([2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0, 2.0]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_dataset(case[\"u\"], case[\"T\"], case[\"sigma\"])\n        results.append(result)\n\n    # Format the final output string manually to match the required format without spaces.\n    sublist_strs = []\n    for sublist in results:\n        # Each float is converted to its standard string representation.\n        sublist_strs.append(f\"[{','.join(map(str, sublist))}]\")\n    \n    final_output = f\"[{','.join(sublist_strs)}]\"\n    print(final_output)\n\ndef process_dataset(u, T, sigma):\n    \"\"\"\n    Performs GLS regression with regularization and calculates goodness-of-fit metrics.\n\n    Args:\n        u (np.array): Input command sequence.\n        T (np.array): Measured thrust sequence.\n        sigma (np.array): Measurement standard deviation sequence.\n\n    Returns:\n        list: A list containing [a, b', eta, MSWR, AIC].\n    \"\"\"\n    lambda_reg = 1e-6\n    \n    # 1. Prepare data for regression\n    # The regression predicts T_{k+1} from (T_k, u_k, u_{k+1}).\n    # For a dataset of length K, we form N = K-1 regression samples.\n    K = len(T)\n    N = K - 1\n\n    # Output samples (T_1, ..., T_{K-1})\n    T_out = T[1:]\n    sigma_out = sigma[1:]\n\n    # Regressor samples (T_0, ..., T_{K-2}), (u_0, ..., u_{K-2}), (u_1, ..., u_{K-1})\n    T_reg = T[:-1]\n    u_reg = u[:-1]\n    u_reg_p1 = u[1:]\n\n    # 2. Formulate whitened (GLS) problem\n    # Divide each regression equation by the corresponding sigma of the output.\n    Y_tilde = T_out / sigma_out\n\n    X_tilde_col1 = T_reg / sigma_out\n    X_tilde_col2 = u_reg / sigma_out\n    X_tilde_col3 = u_reg_p1 / sigma_out\n    \n    X_tilde = np.stack([X_tilde_col1, X_tilde_col2, X_tilde_col3], axis=1)\n\n    # 3. Solve for parameters using regularized least squares\n    num_params = X_tilde.shape[1]\n    I = np.identity(num_params)\n    \n    # Normal matrix H = X_tilde^T * X_tilde + lambda * I\n    H = X_tilde.T @ X_tilde + lambda_reg * I\n    # Right-hand side g = X_tilde^T * Y_tilde\n    g = X_tilde.T @ Y_tilde\n    \n    # Solve H * theta = g for theta\n    theta = np.linalg.solve(H, g)\n    a, b_prime, eta = theta\n\n    # 4. Calculate goodness-of-fit metrics\n    # Predict thrust using the obtained parameters\n    T_pred = a * T_reg + b_prime * u_reg + eta * u_reg_p1\n    \n    # Calculate residuals\n    residuals = T_out - T_pred\n    \n    # Calculate whitened residuals\n    whitened_residuals = residuals / sigma_out\n    \n    # Mean of Squared Whitened Residuals (MSWR)\n    mswr = np.mean(whitened_residuals**2)\n    \n    # Akaike Information Criterion (AIC)\n    p = num_params\n    # logL = -0.5 * sum(log(2*pi*sigma_k^2) + (r_k/sigma_k)^2)\n    # AIC = 2*p - 2*logL\n    logL = -0.5 * np.sum(np.log(2 * np.pi * sigma_out**2) + whitened_residuals**2)\n    aic = 2 * p - 2 * logL\n    \n    return [a, b_prime, eta, mswr, aic]\n\n\nsolve()\n\n```"
        },
        {
            "introduction": "将数字孪生集成到实时控制回路中，会引入通信和计算延迟，这可能对系统稳定性构成严重威胁。本练习模拟了一个无人机（UAV）的俯仰角速率控制器与一个数字孪生协同工作的场景，要求你分析整个“传感器-孪生-执行器”路径上的延迟预算。通过将时间延迟转化为相位滞后并分析其对相位裕度的影响，你将学会如何量化和约束数字孪生系统的端到端延迟，以确保闭环系统的稳定性。",
            "id": "4216510",
            "problem": "一架无人驾驶飞行器 (UAV) 的俯仰角速率内环控制器与一个在国防航空电子网络中的边缘计算节点上运行的监控数字孪生 (DT) 集成。在无网络或计算延迟的情况下进行测试时，标称连续时间控制器的单位增益交越频率为 $\\omega_{c} = 28 \\ \\text{rad/s}$，相位裕度为 $48^{\\circ}$。该数字孪生 (DT) 被添加至传感器-孪生-执行器路径中，并带有一个零阶保持器 (ZOH) 和一个 $T_{s} = 12 \\ \\text{ms}$ 的均匀采样周期。通信和处理链包括 $8 \\ \\text{ms}$ 的上行最坏情况延迟（传感器到 DT）、$4 \\ \\text{ms}$ 的基线 DT 处理时间、$5 \\ \\text{ms}$ 的下行最坏情况延迟（DT 到执行器）以及 $1 \\ \\text{ms}$ 的执行器驱动保持时间。提议在 DT 内部运行一个分析模块，它会引入一个待确定的额外处理时间 $\\tau_{a}$。\n\n假设遵循以下建模原则：\n- 从奈奎斯特稳定性判据和相位裕度的定义出发，结合纯时间延迟的拉普拉斯域表示。\n- 将所有传输、采样和处理延迟视为在环路中引入一个等效纯时间延迟。将增益交越频率处的零阶保持器 (ZOH) 建模为其小角度相位行为导出的等效纯延迟。\n- 所有角度均使用弧度。\n\n从第一性原理出发，确定在闭环系统保持稳定的前提下，分析模块允许的最大处理时间 $\\tau_{a,\\max}$。最终结果以毫秒表示，并四舍五入到三位有效数字。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、提法恰当且客观。\n\n**步骤 1：提取已知条件**\n- 标称单位增益交越频率：$\\omega_{c} = 28 \\ \\text{rad/s}$\n- 标称相位裕度：$\\phi_{m, \\text{nom}} = 48^{\\circ}$\n- 采样周期：$T_{s} = 12 \\ \\text{ms} = 12 \\times 10^{-3} \\ \\text{s}$\n- 上行延迟：$\\tau_{\\text{up}} = 8 \\ \\text{ms} = 8 \\times 10^{-3} \\ \\text{s}$\n- 基线数字孪生 (DT) 处理时间：$\\tau_{\\text{DT,base}} = 4 \\ \\text{ms} = 4 \\times 10^{-3} \\ \\text{s}$\n- 下行延迟：$\\tau_{\\text{down}} = 5 \\ \\text{ms} = 5 \\times 10^{-3} \\ \\text{s}$\n- 执行器驱动保持时间：$\\tau_{\\text{act}} = 1 \\ \\text{ms} = 1 \\times 10^{-3} \\ \\text{s}$\n- 额外分析处理时间：$\\tau_{a}$\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于经典和数字控制理论的基本原理，特别是奈奎斯特稳定性判据、相位裕度，以及时间延迟和采样（零阶保持器）对系统稳定性的影响。这些都是工程学中的标准概念。\n- **提法恰当性**：该问题提供了所有必要的参数和一个明确的目标。时间延迟、相位滞后和相位裕度之间的关系使得可以计算出唯一的最大允许额外延迟。\n- **客观性**：该问题使用精确的技术语言陈述，没有歧义或主观性陈述。\n\n**步骤 3：结论与行动**\n该问题被认为是有效的，因为它具有科学依据、提法恰当且客观。将按要求从第一性原理推导出解决方案。\n\n支配该问题的基本原理是相位裕度与稳定性之间的关系。开环系统的相位裕度 $\\phi_m$ 是在增益交越频率 $\\omega_c$ 处，为使闭环系统达到临界稳定状态所需的额外相位滞后量。标称系统的相位裕度为 $\\phi_{m, \\text{nom}} = 48^{\\circ}$。当由时间延迟引入的总相位滞后完全消耗掉这个裕度时，系统变得不稳定。\n\n稳定性的极限条件是新的相位裕度 $\\phi_{m, \\text{new}}$ 变为零。\n$$ \\phi_{m, \\text{new}} = \\phi_{m, \\text{nom}} - \\Delta\\phi_{\\text{total}} \\ge 0 $$\n其中 $\\Delta\\phi_{\\text{total}}$ 是由数字实现和通信网络引入的总相位滞后。因此，最大允许相位滞后等于标称相位裕度。\n$$ \\Delta\\phi_{\\text{total,max}} = \\phi_{m, \\text{nom}} $$\n问题要求所有角度都使用弧度。我们将标称相位裕度从度转换为弧度。\n$$ \\phi_{m, \\text{nom, rad}} = 48^{\\circ} \\times \\frac{\\pi}{180^{\\circ}} = \\frac{4\\pi}{15} \\ \\text{rad} $$\n一个纯时间延迟 $\\tau$ 的拉普拉斯域表示为 $G_d(s) = \\exp(-s\\tau)$。在频域中（$s=j\\omega$），这会引入一个相位移 $\\angle G_d(j\\omega) = -\\omega\\tau$。因此，相位滞后为 $\\omega\\tau$。\n\n问题陈述，所有延迟都应被视为一个等效纯时间延迟 $\\tau_{\\text{total}}$。这个总延迟是所有单个延迟分量的总和。相位滞后在增益交越频率 $\\omega_c$ 处进行评估。\n$$ \\Delta\\phi_{\\text{total}} = \\omega_c \\tau_{\\text{total}} $$\n系统可以容忍的最大总等效延迟可以通过将相位滞后与可用相位裕度相等来求得。\n$$ \\omega_c \\tau_{\\text{total,max}} = \\phi_{m, \\text{nom, rad}} $$\n$$ \\tau_{\\text{total,max}} = \\frac{\\phi_{m, \\text{nom, rad}}}{\\omega_c} $$\n代入给定值：\n$$ \\tau_{\\text{total,max}} = \\frac{4\\pi/15}{28} = \\frac{4\\pi}{15 \\times 28} = \\frac{\\pi}{15 \\times 7} = \\frac{\\pi}{105} \\ \\text{s} $$\n这个总延迟 $\\tau_{\\text{total}}$ 是恒定的传输和处理延迟、额外的分析处理时间 $\\tau_a$ 以及零阶保持器 (ZOH) 的等效延迟之和。采样周期为 $T_s$ 的 ZOH 的传递函数为 $G_{\\text{zoh}}(s) = \\frac{1 - \\exp(-sT_s)}{s}$。其相位恰好为 $\\angle G_{\\text{zoh}}(j\\omega) = -\\frac{\\omega T_s}{2}$。这对应于一个等效纯时间延迟 $\\tau_{\\text{zoh}} = \\frac{T_s}{2}$，这是标准近似，并且与问题中使用小角度相位行为的指令一致。\n\n总等效延迟为：\n$$ \\tau_{\\text{total}} = \\tau_{\\text{up}} + \\tau_{\\text{DT,base}} + \\tau_{\\text{down}} + \\tau_{\\text{act}} + \\tau_{a} + \\tau_{\\text{zoh}} $$\n$$ \\tau_{\\text{total}} = \\tau_{\\text{up}} + \\tau_{\\text{DT,base}} + \\tau_{\\text{down}} + \\tau_{\\text{act}} + \\tau_{a} + \\frac{T_s}{2} $$\n在稳定性极限处，$\\tau_{\\text{total}} = \\tau_{\\text{total,max}}$，且分析处理时间达到其最大值 $\\tau_{a} = \\tau_{a,\\max}$。\n$$ \\tau_{\\text{total,max}} = \\left( \\tau_{\\text{up}} + \\tau_{\\text{DT,base}} + \\tau_{\\text{down}} + \\tau_{\\text{act}} + \\frac{T_s}{2} \\right) + \\tau_{a,\\max} $$\n我们现在可以求解 $\\tau_{a,\\max}$：\n$$ \\tau_{a,\\max} = \\tau_{\\text{total,max}} - \\left( \\tau_{\\text{up}} + \\tau_{\\text{DT,base}} + \\tau_{\\text{down}} + \\tau_{\\text{act}} + \\frac{T_s}{2} \\right) $$\n让我们以秒为单位计算已知延迟的总和：\n$$ \\tau_{\\text{known}} = (8 + 4 + 5 + 1) \\times 10^{-3} + \\frac{12 \\times 10^{-3}}{2} $$\n$$ \\tau_{\\text{known}} = 18 \\times 10^{-3} + 6 \\times 10^{-3} = 24 \\times 10^{-3} \\ \\text{s} $$\n现在我们将此值和 $\\tau_{\\text{total,max}}$ 的值代入 $\\tau_{a,\\max}$ 的方程中。\n$$ \\tau_{a,\\max} = \\frac{\\pi}{105} \\ \\text{s} - 24 \\times 10^{-3} \\ \\text{s} $$\n对此表达式进行数值计算：\n$$ \\tau_{a,\\max} \\approx 0.02991993 \\ \\text{s} - 0.024 \\ \\text{s} = 0.00591993 \\ \\text{s} $$\n问题要求结果以毫秒为单位。\n$$ \\tau_{a,\\max} \\approx 5.91993 \\ \\text{ms} $$\n四舍五入到三位有效数字，我们得到：\n$$ \\tau_{a,\\max} \\approx 5.92 \\ \\text{ms} $$",
            "answer": "$$\\boxed{5.92}$$"
        }
    ]
}