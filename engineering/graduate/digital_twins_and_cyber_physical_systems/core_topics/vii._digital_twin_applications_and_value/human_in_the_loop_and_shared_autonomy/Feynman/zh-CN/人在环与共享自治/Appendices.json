{
    "hands_on_practices": [
        {
            "introduction": "设计任何有效的共享自主系统的第一步是理解并量化人类伙伴的行为。本练习  将指导您完成一个基础但至关重要的系统辨识任务：从数字孪生生成的时序数据中校准人类操作员的控制模型。通过这个实践，您将学习如何使用网格搜索和最小二乘法等技术来估计一个描述人类感应-运动响应的简化模型，并验证其预测能力。",
            "id": "4226720",
            "problem": "考虑一个单自由度跟踪任务数字孪生中的人在回路共享自主场景。一名人类操作员和一个自主助手共同产生一个控制动作，以减少一个标量跟踪误差信号。数字孪生提供了一个同步的跟踪误差和已执行控制动作的时间序列。目标是根据数据校准一个参数化的人类控制模型，并在一个留出数据集上进行验证，仅使用下面陈述的基础假设和定义。\n\n基础建模假设：\n1) 人类产生的控制动作被建模为对经过滤波的内部误差感知的带噪声线性反馈。连续时间内部感知 $s(t)$ 满足一阶线性微分方程 $\\tau \\, \\frac{d s(t)}{d t} + s(t) = e(t)$，其中 $e(t)$ 是外部可测量的跟踪误差，$\\tau > 0$ 是人类时间常数。人类控制信号为 $u_{\\mathrm{h}}(t) = K_{\\mathrm{h}} \\, s(t) + w(t)$，其中 $K_{\\mathrm{h}}$ 是人类反馈增益，$w(t)$ 是方差为 $\\sigma^2$ 的零均值高斯白噪声。\n2) 自主系统应用一个已知的线性反馈 $u_{\\mathrm{a}}(t) = -K_{\\mathrm{a}} \\, e(t)$，其中 $K_{\\mathrm{a}}$ 是已知的正数。执行的控制指令是一个凸组合 $u(t) = \\alpha \\, u_{\\mathrm{h}}(t) + (1 - \\alpha) \\, u_{\\mathrm{a}}(t)$，其中混合系数 $\\alpha \\in (0,1]$ 是已知的。\n3) 数字孪生以固定的采样周期 $\\Delta t > 0$ 提供离散时间样本。内部感知的离散近似使用应用于连续时间模型的前向欧拉法，得到 $s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}\\,(e_k - s_k)$，其中样本索引 $k \\in \\{0,1,\\dots\\}$，初始条件为 $s_0 = 0$。三角函数内部使用的所有角度均为弧度。\n\n校准目标：\n给定 $N$ 对 $(e_k, u_k)$（$k = 0,1,\\dots,N-1$），以及已知的 $\\Delta t$、$\\alpha$ 和 $K_{\\mathrm{a}}$，通过在关于 $u_{\\mathrm{h},k}$ 的零均值独立高斯噪声模型下最大化似然来估计人类参数 $\\tau$、 $K_{\\mathrm{h}}$ 和 $\\sigma^2$。您必须将 $\\tau$ 视为非线性参数，将 $K_{\\mathrm{h}}$ 视为线性参数。使用网格搜索对限制在 $\\tau \\in [\\tau_{\\min}, \\tau_{\\max}]$ 范围内的 $\\tau$ 进行均匀网格搜索，并为每个 $\\tau$ 计算 $K_{\\mathrm{h}}$ 的闭式最小二乘估计，然后计算 $\\sigma^2$ 的最大似然估计。选择使负对数似然最小的 $\\tau$。\n\n验证目标：\n给定一个长度为 $N_{\\mathrm{val}}$ 的留出数据集 $(e^{\\mathrm{val}}_k, u^{\\mathrm{val}}_k)$，通过使用校准的 $\\hat{\\tau}$ 运行相同的前向欧拉递推并使用无噪声的 $\\hat{K}_{\\mathrm{h}}$ 来计算单步预测 $\\hat{u}^{\\mathrm{val}}_k$。评估归一化均方根误差，其定义为 $\\mathrm{NRMSE} = \\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\hat{u}^{\\mathrm{val}}_k\\right)^2} \\Big/ \\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\bar{u}^{\\mathrm{val}}\\right)^2}$，其中 $\\bar{u}^{\\mathrm{val}}$ 是 $u^{\\mathrm{val}}_k$ 的样本均值。归一化均方根误差是无量纲的。所有时间常数必须以秒为单位表示。\n\n数据生成（须由您的程序严格按照规定实现）：\n- 对于任何给定的 $\\Delta t$、$N$ 以及频率 $f_1$、$f_2$（单位为赫兹），定义 $t_k = k \\, \\Delta t$ 和激励误差序列 $e_k = \\sin(2\\pi f_1 t_k) + 0.5 \\, \\sin(2\\pi f_2 t_k)$，其中 $k = 0,1,\\dots,N-1$。验证误差序列使用相同的公式，但频率为 $f_1^{\\mathrm{val}}$ 和 $f_2^{\\mathrm{val}}$。\n- 执行的指令序列由人在回路模型生成：首先，递归计算 $s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}\\,(e_k - s_k)$，其中 $s_0 = 0$；然后计算 $u_{\\mathrm{h},k} = K_{\\mathrm{h}} \\, s_k + w_k$，其中 $w_k \\sim \\mathcal{N}(0,\\sigma^2)$；自主指令为 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} \\, e_k$；执行的指令为 $u_k = \\alpha \\, u_{\\mathrm{h},k} + (1 - \\alpha)\\, u_{\\mathrm{a},k}$。用于验证预测 $\\hat{u}^{\\mathrm{val}}_k$ 的是不含噪声的相同递归过程；测量的验证指令 $u^{\\mathrm{val}}_k$ 包含如上所述抽样的噪声。\n- 随机性必须是可复现的。对于每个数据集，使用一个独立的固定种子为伪随机数生成器抽取 $\\{w_k\\}$。\n\n估计方法（须由您的程序严格按照规定实现）：\n- 对于一个候选 $\\tau$，通过运行 $s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}\\,(e_k - s_k)$（其中 $s_0 = 0$）并计算 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} e_k$ 来形成确定性回归量序列。定义混合的自主补偿响应 $z_k = u_k - (1 - \\alpha)\\, u_{\\mathrm{a},k}$ 和回归量 $\\phi_k = \\alpha \\, s_k$。$K_{\\mathrm{h}}$ 的最小二乘估计为 $\\hat{K}_{\\mathrm{h}}(\\tau) = \\frac{\\sum_{k=0}^{N-1} \\phi_k z_k}{\\sum_{k=0}^{N-1} \\phi_k^2}$。残差为 $r_k(\\tau) = z_k - \\phi_k \\, \\hat{K}_{\\mathrm{h}}(\\tau)$，噪声方差的最大似然估计为 $\\hat{\\sigma}^2(\\tau) = \\frac{1}{N} \\sum_{k=0}^{N-1} r_k(\\tau)^2$。负对数似然（不含与参数无关的加法常数）为 $J(\\tau) = \\frac{N}{2} \\log\\left(\\hat{\\sigma}^2(\\tau)\\right)$。在网格上选择使 $J(\\tau)$ 最小的 $\\hat{\\tau}$，并设置 $\\hat{K}_{\\mathrm{h}} = \\hat{K}_{\\mathrm{h}}(\\hat{\\tau})$ 和 $\\hat{\\sigma}^2 = \\hat{\\sigma}^2(\\hat{\\tau})$。\n\n网格规格：\n- 对于每个测试用例，在 $\\tau \\in [\\tau_{\\min}, \\tau_{\\max}]$ 上使用一个包含 $M = 300$ 个点的均匀网格，其中 $\\tau_{\\min} = \\max\\{0.55 \\, \\Delta t, 0.02\\}$ 且 $\\tau_{\\max} = 0.6$。这确保了前向欧拉递推是稳定的，因为 $0  \\frac{\\Delta t}{\\tau}  2$。\n\n测试套件：\n使用以下参数实现三个独立的校准和验证任务。所有时间常数和采样周期都以秒为单位；频率以赫兹为单位；增益是无量纲的；噪声标准差的单位与控制指令相同；三角函数内部的角度以弧度为单位。对于每种情况，都生成一个训练数据集和一个验证数据集。\n\n情况 A：\n- $\\Delta t = 0.02$，$\\alpha = 0.7$，$K_{\\mathrm{a}} = 0.9$，$K_{\\mathrm{h}} = 1.1$，$\\tau = 0.15$，$\\sigma = 0.05$，\n- $N = 1500$，$N_{\\mathrm{val}} = 800$，\n- $f_1 = 0.3$，$f_2 = 0.7$，$f_1^{\\mathrm{val}} = 0.45$，$f_2^{\\mathrm{val}} = 1.1$，\n- 训练种子 $= 12345$，验证种子 $= 54321$。\n\n情况 B：\n- $\\Delta t = 0.05$，$\\alpha = 0.9$，$K_{\\mathrm{a}} = 1.0$，$K_{\\mathrm{h}} = 0.8$，$\\tau = 0.03$，$\\sigma = 0.02$，\n- $N = 1200$，$N_{\\mathrm{val}} = 600$，\n- $f_1 = 0.2$，$f_2 = 0.5$，$f_1^{\\mathrm{val}} = 0.35$，$f_2^{\\mathrm{val}} = 0.9$，\n- 训练种子 $= 22222$，验证种子 $= 33333$。\n\n情况 C：\n- $\\Delta t = 0.01$，$\\alpha = 0.6$，$K_{\\mathrm{a}} = 1.2$，$K_{\\mathrm{h}} = 1.8$，$\\tau = 0.25$，$\\sigma = 0.08$，\n- $N = 2000$，$N_{\\mathrm{val}} = 1000$，\n- $f_1 = 0.4$，$f_2 = 0.95$，$f_1^{\\mathrm{val}} = 0.25$，$f_2^{\\mathrm{val}} = 0.6$，\n- 训练种子 $= 44444$，验证种子 $= 55555$。\n\n要求输出：\n- 对于每种情况，使用上述程序计算校准后的元组 $(\\hat{\\tau}, \\hat{K}_{\\mathrm{h}}, \\hat{\\sigma}^2)$，并根据留出数据集计算验证的 $\\mathrm{NRMSE}$。按此顺序将所有四个值报告为实数。\n- 单位：$\\hat{\\tau}$ 以秒为单位报告；其他量与模型单位一致，对于 $\\hat{K}_{\\mathrm{h}}$ 和 $\\mathrm{NRMSE}$ 是无量纲的，而 $\\hat{\\sigma}^2$ 的单位与控制指令的平方相同。\n- 数值格式：将每个报告的数字四舍五入到六位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个含三个列表的列表，每个案例一个，其中每个内部列表为 $[\\hat{\\tau}, \\hat{K}_{\\mathrm{h}}, \\hat{\\sigma}^2, \\mathrm{NRMSE}]$，每个值四舍五入到六位小数，并且行中没有任何空格。例如：“[[0.123456,1.234567,0.012345,0.345678],[...],[...]]”。程序不得读取任何输入，也不得打印任何其他内容。",
            "solution": "该问题要求在一个“人在回路”共享自主系统中，对一个用于人类操作员控制行为的参数化模型进行校准和验证。任务是从综合生成的跟踪误差和控制动作的时间序列中，估计人类的感知时间常数 $\\tau$、反馈增益 $K_{\\mathrm{h}}$ 和噪声方差 $\\sigma^2$，然后在一个独立的数据集上验证校准后的模型。\n\n解决方案主要分三个阶段进行：（1）数据生成，（2）模型校准，以及（3）模型验证。\n\n**1. 数据生成**\n\n问题明确规定了生成训练和验证数据集的精确流程。\n- 跟踪误差信号 $e_k$ 是两个正弦波的确定性总和：$e_k = \\sin(2\\pi f_1 t_k) + 0.5 \\sin(2\\pi f_2 t_k)$，其中 $t_k = k \\Delta t$。\n- 人类操作员对误差的内部感知 $s_k$ 被建模为误差 $e_k$ 的一阶低通滤波版本。其离散时间动态由连续时间模型 $\\tau \\dot{s} + s = e$ 的前向欧拉近似给出：\n$$s_{k+1} = s_k + \\frac{\\Delta t}{\\tau}(e_k - s_k)$$\n初始条件为 $s_0 = 0$。\n- 人类的控制动作 $u_{\\mathrm{h},k}$ 是对此内部状态的带噪声线性反馈：\n$$u_{\\mathrm{h},k} = K_{\\mathrm{h}} s_k + w_k$$\n其中 $w_k$ 是从均值为零、方差为 $\\sigma^2$ 的高斯分布中抽取的独立样本，即 $w_k \\sim \\mathcal{N}(0, \\sigma^2)$。\n- 自主助手提供一个简单的比例控制动作 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} e_k$。\n- 最终执行的控制指令 $u_k$ 是人类和自主控制动作的凸组合，由混合系数 $\\alpha$ 控制：\n$$u_k = \\alpha u_{\\mathrm{h},k} + (1 - \\alpha) u_{\\mathrm{a},k}$$\n这个完整的生成模型被实现用于产生训练数据对 $(e_k, u_k)$ 和验证数据对 $(e^{\\mathrm{val}}_k, u^{\\mathrm{val}}_k)$，并使用独立的伪随机数生成器种子以保证可复现性。\n\n**2. 模型校准**\n\n校准的目标是从训练数据 $(e_k, u_k)$ 和已知的系统参数 $(\\Delta t, \\alpha, K_{\\mathrm{a}})$ 中估计参数 $(\\tau, K_{\\mathrm{h}}, \\sigma^2)$。该估计策略利用了模型的结构特性，即模型在 $\\tau$ 上是非线性的，但在 $K_{\\mathrm{h}}$ 上是线性的。这是一个可分离的非线性最小二乘问题。\n\n首先，我们重排共享控制方程以分离出人类的贡献。给定 $u_k$ 和 $e_k$，我们可以计算自主系统的贡献 $u_{\\mathrm{a},k} = -K_{\\mathrm{a}} e_k$。人类的贡献（经 $\\alpha$ 缩放）则为：\n$$\\alpha u_{\\mathrm{h},k} = u_k - (1 - \\alpha) u_{\\mathrm{a},k}$$\n我们将这个可观测量定义为 $z_k \\equiv u_k - (1-\\alpha)u_{\\mathrm{a},k}$。代入 $u_{\\mathrm{h},k}$ 的模型，我们得到回归方程：\n$$z_k = \\alpha (K_{\\mathrm{h}} s_k + w_k) = K_{\\mathrm{h}} (\\alpha s_k) + \\alpha w_k$$\n该方程在参数 $K_{\\mathrm{h}}$ 上是线性的，但在 $\\tau$ 上是非线性的，因为 $s_k$ 是 $\\tau$ 的函数。\n\n估计过程通过对非线性参数 $\\tau$ 进行网格搜索来完成。对于 $[\\tau_{\\min}, \\tau_{\\max}]$ 上均匀网格中的每个候选值 $\\tau_{\\mathrm{cand}}$，我们执行以下步骤：\n- **生成回归量：** 使用已知的训练误差 $e_k$ 和候选值 $\\tau_{\\mathrm{cand}}$，通过前向欧拉递推计算内部状态序列 $s_k(\\tau_{\\mathrm{cand}})$。回归量则为 $\\phi_k(\\tau_{\\mathrm{cand}}) = \\alpha s_k(\\tau_{\\mathrm{cand}})$。\n- **估计 $K_{\\mathrm{h}}$：** 对于一个固定的 $\\tau$，模型为 $z_k = K_{\\mathrm{h}} \\phi_k + \\text{噪声}$。最小化误差平方和的标准线性最小二乘估计 $K_{\\mathrm{h}}$ 为：\n$$\\hat{K}_{\\mathrm{h}}(\\tau_{\\mathrm{cand}}) = \\frac{\\sum_{k=0}^{N-1} \\phi_k z_k}{\\sum_{k=0}^{N-1} \\phi_k^2}$$\n- **估计噪声方差：** 此回归的残差为 $r_k(\\tau_{\\mathrm{cand}}) = z_k - \\hat{K}_{\\mathrm{h}}(\\tau_{\\mathrm{cand}}) \\phi_k$。问题将“噪声方差”的最大似然估计定义为这些残差的样本方差：\n$$\\hat{\\sigma}^2(\\tau_{\\mathrm{cand}}) = \\frac{1}{N} \\sum_{k=0}^{N-1} r_k(\\tau_{\\mathrm{cand}})^2$$\n请注意，这些残差 $r_k$ 是对缩放后的观测噪声 $\\alpha w_k$ 的估计，因此如此定义的 $\\hat{\\sigma}^2$ 是对 $\\alpha^2 \\sigma^2$ 的估计。我们遵循此问题的明确定义。\n- **评估成本函数：** 最优的 $\\tau$ 通过最大化剖面似然函数找到，这等价于最小化负对数似然。在不考虑加性常数的情况下，负对数似然由下式给出：\n$$J(\\tau_{\\mathrm{cand}}) = \\frac{N}{2} \\log\\left(\\hat{\\sigma}^2(\\tau_{\\mathrm{cand}})\\right)$$\n最小化 $J(\\tau_{\\mathrm{cand}})$ 等价于最小化残差方差 $\\hat{\\sigma}^2(\\tau_{\\mathrm{cand}})$。\n- **选择最优参数：** 网格搜索找到使 $J(\\tau)$ 最小的值 $\\hat{\\tau}$。最终的估计值即为 $\\hat{\\tau}$，以及对应的 $\\hat{K}_{\\mathrm{h}} = \\hat{K}_{\\mathrm{h}}(\\hat{\\tau})$ 和 $\\hat{\\sigma}^2 = \\hat{\\sigma}^2(\\hat{\\tau})$。\n\n**3. 模型验证**\n\n校准模型 $(\\hat{\\tau}, \\hat{K}_{\\mathrm{h}})$ 的性能在一个留出的验证数据集 $(e^{\\mathrm{val}}_k, u^{\\mathrm{val}}_k)$ 上进行评估。这包括生成控制指令的单步预测，并将其与测量的指令进行比较。\n\n- **预测：** 预测的控制信号 $\\hat{u}^{\\mathrm{val}}_k$ 是使用校准后的模型参数生成的，但不包含噪声项。对于每一步 $k$：\n    1. 使用验证误差 $e^{\\mathrm{val}}_k$ 和估计的时间常数 $\\hat{\\tau}$ 更新预测的内部状态 $\\hat{s}^{\\mathrm{val}}_k$：\n       $$\\hat{s}^{\\mathrm{val}}_{k+1} = \\hat{s}^{\\mathrm{val}}_k + \\frac{\\Delta t}{\\hat{\\tau}}(e^{\\mathrm{val}}_k - \\hat{s}^{\\mathrm{val}}_k), \\quad \\hat{s}^{\\mathrm{val}}_0=0$$\n    2. 预测的无噪声人类指令为 $\\hat{u}_{\\mathrm{h},k}^{\\mathrm{val}} = \\hat{K}_{\\mathrm{h}} \\hat{s}^{\\mathrm{val}}_k$。\n    3. 最终的预测指令进行混合：$\\hat{u}^{\\mathrm{val}}_k = \\alpha \\hat{u}_{\\mathrm{h},k}^{\\mathrm{val}} + (1 - \\alpha) u_{\\mathrm{a},k}^{\\mathrm{val}}$，其中 $u_{\\mathrm{a},k}^{\\mathrm{val}} = -K_{\\mathrm{a}} e^{\\mathrm{val}}_k$。\n\n- **评估指标：** 预测准确性通过归一化均方根误差（NRMSE）来量化，其定义为预测误差的均方根（RMS）除以测量的验证信号的标准差：\n$$\\mathrm{NRMSE} = \\frac{\\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\hat{u}^{\\mathrm{val}}_k\\right)^2}}{\\sqrt{\\frac{1}{N_{\\mathrm{val}}} \\sum_{k=0}^{N_{\\mathrm{val}} - 1} \\left(u^{\\mathrm{val}}_k - \\bar{u}^{\\mathrm{val}}\\right)^2}}$$\n其中 $\\bar{u}^{\\mathrm{val}}$ 是测量的验证信号 $u^{\\mathrm{val}}_k$ 的样本均值。该指标提供了一个与尺度无关的模型拟合度量。\n\n这整个过程对三个指定的测试用例都进行了实现，严格遵守了所提供的参数、数据生成过程、估计方法和网格规格。",
            "answer": "```python\nimport numpy as np\n\ndef generate_data(dt, alpha, Ka, Kh, tau_true, sigma, freqs, N, seed):\n    \"\"\"\n    Generates synthetic data for the human-in-the-loop tracking task.\n    \"\"\"\n    f1, f2 = freqs\n    rng = np.random.default_rng(seed)\n    \n    t = np.arange(N) * dt\n    e = np.sin(2 * np.pi * f1 * t) + 0.5 * np.sin(2 * np.pi * f2 * t)\n    \n    s = np.zeros(N)\n    u_h = np.zeros(N)\n    u_a = -Ka * e\n    u = np.zeros(N)\n    w = rng.normal(0, sigma, N)\n    \n    for k in range(N - 1):\n        # Calculate controls at step k based on state s[k]\n        u_h[k] = Kh * s[k] + w[k]\n        u[k] = alpha * u_h[k] + (1 - alpha) * u_a[k]\n        \n        # Update state for step k+1 based on error and state at k\n        s[k+1] = s[k] + (dt / tau_true) * (e[k] - s[k])\n        \n    # Final step calculation\n    k = N - 1\n    u_h[k] = Kh * s[k] + w[k]\n    u[k] = alpha * u_h[k] + (1 - alpha) * u_a[k]\n    \n    return e, u\n\ndef calibrate_model(e_train, u_train, dt, alpha, Ka, N, M_grid=300):\n    \"\"\"\n    Calibrates the human model parameters using grid search and least squares.\n    \"\"\"\n    tau_min = max(0.55 * dt, 0.02)\n    tau_max = 0.6\n    tau_grid = np.linspace(tau_min, tau_max, M_grid)\n    \n    best_J = np.inf\n    hat_tau, hat_Kh, hat_sigma_sq = 0.0, 0.0, 0.0\n    \n    u_a_train = -Ka * e_train\n    z_train = u_train - (1 - alpha) * u_a_train\n    \n    for tau_cand in tau_grid:\n        s_cand = np.zeros(N)\n        for k in range(N - 1):\n            s_cand[k+1] = s_cand[k] + (dt / tau_cand) * (e_train[k] - s_cand[k])\n            \n        phi = alpha * s_cand\n        \n        phi_sq_sum = np.dot(phi, phi)\n        if phi_sq_sum  1e-15:\n            continue\n\n        Kh_cand = np.dot(phi, z_train) / phi_sq_sum\n        \n        r = z_train - phi * Kh_cand\n        sigma_sq_cand = np.mean(r**2)\n        \n        if sigma_sq_cand  1e-15:\n            continue\n            \n        J = N / 2.0 * np.log(sigma_sq_cand)\n        \n        if J  best_J:\n            best_J = J\n            hat_tau = tau_cand\n            hat_Kh = Kh_cand\n            hat_sigma_sq = sigma_sq_cand\n            \n    return hat_tau, hat_Kh, hat_sigma_sq\n\ndef validate_model(e_val, u_val, hat_tau, hat_Kh, dt, alpha, Ka, N_val):\n    \"\"\"\n    Validates the calibrated model and computes NRMSE.\n    \"\"\"\n    s_pred = np.zeros(N_val)\n    u_pred = np.zeros(N_val)\n    u_a_val = -Ka * e_val\n    \n    for k in range(N_val - 1):\n        u_h_pred_k = hat_Kh * s_pred[k]\n        u_pred[k] = alpha * u_h_pred_k + (1 - alpha) * u_a_val[k]\n        s_pred[k+1] = s_pred[k] + (dt / hat_tau) * (e_val[k] - s_pred[k])\n        \n    k = N_val - 1\n    u_h_pred_k = hat_Kh * s_pred[k]\n    u_pred[k] = alpha * u_h_pred_k + (1 - alpha) * u_a_val[k]\n    \n    rmse_num = np.sqrt(np.mean((u_val - u_pred)**2))\n    std_den = np.std(u_val)\n    \n    if std_den  1e-15:\n        return np.inf if rmse_num > 1e-15 else 0.0\n    \n    nrmse = rmse_num / std_den\n    return nrmse\n\ndef solve():\n    \"\"\"\n    Main function to run the calibration and validation for all test cases.\n    \"\"\"\n    # M_grid is the number of points in the tau grid search\n    M_grid = 300\n\n    test_cases = [\n        {\n            # Case A\n            'params': {'dt': 0.02, 'alpha': 0.7, 'Ka': 0.9, 'Kh': 1.1, 'tau': 0.15, 'sigma': 0.05},\n            'data': {'N': 1500, 'N_val': 800, 'f1': 0.3, 'f2': 0.7, 'f1_val': 0.45, 'f2_val': 1.1},\n            'seeds': {'train': 12345, 'val': 54321}\n        },\n        {\n            # Case B\n            'params': {'dt': 0.05, 'alpha': 0.9, 'Ka': 1.0, 'Kh': 0.8, 'tau': 0.03, 'sigma': 0.02},\n            'data': {'N': 1200, 'N_val': 600, 'f1': 0.2, 'f2': 0.5, 'f1_val': 0.35, 'f2_val': 0.9},\n            'seeds': {'train': 22222, 'val': 33333}\n        },\n        {\n            # Case C\n            'params': {'dt': 0.01, 'alpha': 0.6, 'Ka': 1.2, 'Kh': 1.8, 'tau': 0.25, 'sigma': 0.08},\n            'data': {'N': 2000, 'N_val': 1000, 'f1': 0.4, 'f2': 0.95, 'f1_val': 0.25, 'f2_val': 0.6},\n            'seeds': {'train': 44444, 'val': 55555}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p = case['params']\n        d = case['data']\n        s = case['seeds']\n\n        # 1. Generate training and validation data\n        e_train, u_train = generate_data(p['dt'], p['alpha'], p['Ka'], p['Kh'], p['tau'], p['sigma'], \n                                         (d['f1'], d['f2']), d['N'], s['train'])\n        e_val, u_val = generate_data(p['dt'], p['alpha'], p['Ka'], p['Kh'], p['tau'], p['sigma'], \n                                     (d['f1_val'], d['f2_val']), d['N_val'], s['val'])\n\n        # 2. Calibrate model parameters\n        hat_tau, hat_Kh, hat_sigma_sq = calibrate_model(e_train, u_train, p['dt'], p['alpha'], p['Ka'], d['N'], M_grid)\n\n        # 3. Validate model and compute NRMSE\n        nrmse = validate_model(e_val, u_val, hat_tau, hat_Kh, p['dt'], p['alpha'], p['Ka'], d['N_val'])\n\n        all_results.append([hat_tau, hat_Kh, hat_sigma_sq, nrmse])\n\n    # Format the final output string\n    result_str = \",\".join([f\"[{','.join([f'{v:.6f}' for v in res])}]\" for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦我们有了人类和自主系统的模型，核心挑战就变成了如何智慧地融合它们的输入。简单的平均或切换远远不够。本练习  将此仲裁问题构建为一个带约束的多目标优化问题，这是一种在机器人和控制领域中非常强大的范式。您将学习如何通过最小化一个综合成本函数来找到最优的控制指令，该函数权衡了系统安全性、任务性能以及对人类意图的尊重。",
            "id": "4226636",
            "problem": "考虑一个信息物理系统的共享自主控制器，其中数字孪生预测了控制输入与安全相关状态之间的线性化映射。设控制输入为向量 $u \\in \\mathbb{R}^2$。数字孪生提供一个线性映射 $S \\in \\mathbb{R}^{2 \\times 2}$ 和一个期望的安全参考 $s_{\\mathrm{ref}} \\in \\mathbb{R}^2$。自主模块提出 $u_{\\mathrm{auto}} \\in \\mathbb{R}^2$，而人类操作员提出 $u_{\\mathrm{human}} \\in \\mathbb{R}^2$。一个信任参数 $\\tau \\in [0,1]$ 调节赋予自主模块和人类操作员的相对权重。定义权重 $w_{\\mathrm{p}}(\\tau) = \\beta (1 - \\tau)$ 和 $w_{\\mathrm{h}}(\\tau) = \\beta \\tau$（其中 $\\beta  0$），以及一个固定的安全-性能权重 $w_{\\mathrm{s}}  0$。\n\n该多目标优化问题是找到 $u^\\star$ 以最小化以下成本：\n$$\nJ(u; \\tau) = w_{\\mathrm{s}} \\lVert S u - s_{\\mathrm{ref}} \\rVert_2^2 + w_{\\mathrm{p}}(\\tau) \\lVert u - u_{\\mathrm{auto}} \\rVert_2^2 + w_{\\mathrm{h}}(\\tau) \\lVert u - u_{\\mathrm{human}} \\rVert_2^2\n$$\n服从以下线性安全约束\n$$\nc^\\top u \\le d,\n$$\n其中 $c \\in \\mathbb{R}^2$ 且 $d \\in \\mathbb{R}$。\n\n仅从凸优化的基本定义和二次型的结构出发，不使用任何预先推导的快捷公式，推导此问题的必要最优性条件，并实现一个算法，为给定的参数集计算 $u^\\star$。推导必须基于第一性原理：正定二次型的性质、梯度以及由线性不等式施加的可行性条件。\n\n您的程序必须为下面指定的每个测试用例计算 $u^\\star$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。输出列表中的每个元素本身都必须是一个双元素列表，代表相应测试用例的最优控制 $u^\\star$，每个数字四舍五入到六位小数，例如 $[[u_{1,1},u_{1,2}],[u_{2,1},u_{2,2}],\\ldots]$。不应打印任何额外文本。\n\n不涉及物理单位；所有量均为无量纲。不使用角度。不得出现百分比；任何小数部分都应表示为十进制数。\n\n测试套件：\n- 案例 $1$（一般“顺利”路径）：\n  - $S = \\begin{bmatrix} 1.0  0.2 \\\\ 0.1  1.5 \\end{bmatrix}$,\n  - $s_{\\mathrm{ref}} = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$,\n  - $u_{\\mathrm{auto}} = \\begin{bmatrix} 0.5 \\\\ -0.3 \\end{bmatrix}$,\n  - $u_{\\mathrm{human}} = \\begin{bmatrix} 0.0 \\\\ 0.8 \\end{bmatrix}$,\n  - $\\beta = 2.0$,\n  - $w_{\\mathrm{s}} = 1.0$,\n  - $c = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$,\n  - $d = 1.0$,\n  - $\\tau = 0.5$.\n- 案例 $2$（激活的安全约束）：\n  - $S$、$s_{\\mathrm{ref}}$、$u_{\\mathrm{auto}}$、$u_{\\mathrm{human}}$、$\\beta$、$w_{\\mathrm{s}}$、$c$ 同案例 $1$,\n  - $d = 0.5$,\n  - $\\tau = 0.5$.\n- 案例 $3$（信任边界在 $\\tau = 0$）：\n  - $S$、$s_{\\mathrm{ref}}$、$u_{\\mathrm{auto}}$、$u_{\\mathrm{human}}$、$\\beta$、$w_{\\mathrm{s}}$、$c$ 同案例 $1$,\n  - $d = 0.55$,\n  - $\\tau = 0.0$.\n- 案例 $4$（信任边界在 $\\tau = 1$ 且在约束边界上可行）：\n  - $S$、$s_{\\mathrm{ref}}$、$u_{\\mathrm{auto}}$、$u_{\\mathrm{human}}$、$\\beta$、$w_{\\mathrm{s}}$、$c$ 同案例 $1$,\n  - $\\tau = 1.0$,\n  - 设置 $d$ 等于 $c^\\top u_{\\mathrm{uncon}}$，其中 $u_{\\mathrm{uncon}}$ 是案例 4 中给定参数的无约束最小化解。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个案例的 $u^\\star$ 按案例 1 到 4 的顺序列出，每个均为一个双元素列表，四舍五入到六位小数，例如：$[[x_{1,1},x_{1,2}],[x_{2,1},x_{2,2}],[x_{3,1},x_{3,2}],[x_{4,1},x_{4,2}]]$。",
            "solution": "该问题是寻找最优控制输入 $u^\\star \\in \\mathbb{R}^2$，以最小化一个受单线性不等式约束的二次成本函数。这是一个经典的二次规划（QP）问题。其解可以从第一性原理出发，使用针对约束优化的 Karush-Kuhn-Tucker (KKT) 条件推导得出。\n\n该优化问题表述为：\n$$\n\\min_{u \\in \\mathbb{R}^2} J(u; \\tau) = w_{\\mathrm{s}} \\lVert S u - s_{\\mathrm{ref}} \\rVert_2^2 + w_{\\mathrm{p}}(\\tau) \\lVert u - u_{\\mathrm{auto}} \\rVert_2^2 + w_{\\mathrm{h}}(\\tau) \\lVert u - u_{\\mathrm{human}} \\rVert_2^2\n$$\n服从以下约束：\n$$\nc^\\top u \\le d\n$$\n\n为清晰起见，我们将权重表示为 $w_s$、$w_p$ 和 $w_h$。\n\n**1. 成本函数的展开与简化**\n\n成本函数 $J(u)$ 是欧几里得范数平方和。我们展开每一项，将 $J(u)$ 表示为标准的二次型。使用恒等式 $\\lVert x \\rVert_2^2 = x^\\top x$，我们有：\n- $w_s \\lVert S u - s_{\\mathrm{ref}} \\rVert_2^2 = w_s (u^\\top S^\\top S u - 2 s_{\\mathrm{ref}}^\\top S u + s_{\\mathrm{ref}}^\\top s_{\\mathrm{ref}})$\n- $w_p \\lVert u - u_{\\mathrm{auto}} \\rVert_2^2 = w_p (u^\\top u - 2 u_{\\mathrm{auto}}^\\top u + u_{\\mathrm{auto}}^\\top u_{\\mathrm{auto}})$\n- $w_h \\lVert u - u_{\\mathrm{human}} \\rVert_2^2 = w_h (u^\\top u - 2 u_{\\mathrm{human}}^\\top u + u_{\\mathrm{human}}^\\top u_{\\mathrm{human}})$\n\n将这些项相加并按 $u$ 的幂次分组，我们可以将 $J(u)$ 写成 $J(u) = u^\\top A u - 2 b^\\top u + \\gamma$ 的形式，其中不依赖于 $u$ 的项被收集到 $\\gamma$ 中。\n\n二次项是 $u^\\top (w_s S^\\top S + w_p I + w_h I) u$。线性项是 $-2 (w_s s_{\\mathrm{ref}}^\\top S + w_p u_{\\mathrm{auto}}^\\top + w_h u_{\\mathrm{human}}^\\top) u$。\n\n我们定义矩阵 $A \\in \\mathbb{R}^{2 \\times 2}$ 和向量 $b \\in \\mathbb{R}^2$ 如下：\n$A = w_s S^\\top S + (w_p + w_h)I$\n$b = w_s S^\\top s_{\\mathrm{ref}} + w_p u_{\\mathrm{auto}} + w_h u_{\\mathrm{human}}$\n\n使用定义 $w_p(\\tau) = \\beta (1 - \\tau)$ 和 $w_h(\\tau) = \\beta \\tau$，它们的和是 $w_p + w_h = \\beta$。\n因此，表达式变为：\n$$\nA = w_s S^\\top S + \\beta I\n$$\n$$\nb = w_s S^\\top s_{\\mathrm{ref}} + \\beta(1-\\tau) u_{\\mathrm{auto}} + \\beta\\tau u_{\\mathrm{human}}\n$$\n成本函数现在是 $J(u) = u^\\top A u - 2 b^\\top u + \\text{常数}$。\n\n**2. 凸性与无约束解**\n\n为求 $J(u)$ 的最小值，我们首先计算它关于 $u$ 的梯度：\n$$\n\\nabla_u J(u) = 2 A u - 2 b\n$$\n成本函数的海森矩阵是 $\\nabla_u^2 J(u) = 2A = 2(w_s S^\\top S + \\beta I)$。由于 $w_s  0$ 且 $\\beta  0$，并且 $S^\\top S$ 是一个半正定矩阵，因此海森矩阵是一个半正定矩阵（$2w_s S^\\top S$）与一个正定矩阵（$2\\beta I$）之和。因此，海森矩阵是正定的。这证明了 $J(u)$ 是一个严格凸函数，从而保证了存在唯一的全局最小值。\n\n对于无约束问题，通过将梯度设为零来找到最小值 $u_{\\mathrm{uncon}}$：\n$$\n\\nabla_u J(u_{\\mathrm{uncon}}) = 2 A u_{\\mathrm{uncon}} - 2 b = 0\n$$\n$$\nA u_{\\mathrm{uncon}} = b\n$$\n由于 $A$ 是正定的，它是可逆的。唯一的无约束最小化解是：\n$$\nu_{\\mathrm{uncon}} = A^{-1} b\n$$\n\n**3. 约束问题的 Karush-Kuhn-Tucker (KKT) 条件**\n\n对于约束问题，我们使用 KKT 条件。拉格朗日函数是：\n$\\mathcal{L}(u, \\lambda) = J(u) + \\lambda(c^\\top u - d)$，其中 $\\lambda$ 是拉格朗日乘子。\n\n最优解 $u^\\star$ 和乘子 $\\lambda^\\star$ 的 KKT 条件是：\n1.  **平稳性 (Stationarity):** $\\nabla_u \\mathcal{L}(u^\\star, \\lambda^\\star) = \\nabla_u J(u^\\star) + \\lambda^\\star c = 0$\n2.  **原始可行性 (Primal Feasibility):** $c^\\top u^\\star - d \\le 0$\n3.  **对偶可行性 (Dual Feasibility):** $\\lambda^\\star \\ge 0$\n4.  **互补松弛性 (Complementary Slackness):** $\\lambda^\\star (c^\\top u^\\star - d) = 0$\n\n根据互补松弛性条件，我们分析两种不同的情况。\n\n**情况 I：约束非激活 ($c^\\top u^\\star - d  0$)。**\n根据互补松弛性，如果 $c^\\top u^\\star - d  0$，则 $\\lambda^\\star$ 必须为 $0$。\n将 $\\lambda^\\star = 0$ 代入平稳性条件，得到：\n$$\n\\nabla_u J(u^\\star) = 0\n$$\n这与无约束最小值的条件相同。因此，如果无约束解 $u_{\\mathrm{uncon}}$ 满足原始可行性条件，即 $c^\\top u_{\\mathrm{uncon}} \\le d$，那么它就是约束问题的最优解：\n$$\nu^\\star = u_{\\mathrm{uncon}} \\quad \\text{如果 } c^\\top u_{\\mathrm{uncon}} \\le d\n$$\n该解在 $\\lambda^\\star=0$ 的情况下满足所有 KKT 条件。\n\n**情况 II：约束激活 ($c^\\top u^\\star = d$)。**\n当无约束解不可行时，即 $c^\\top u_{\\mathrm{uncon}} > d$，就会出现这种情况。因此，最优解必须位于可行域的边界上，$c^\\top u^\\star = d$。在这种情况下，乘子 $\\lambda^\\star$ 可以为正。\n\n我们使用平稳性条件来用 $\\lambda^\\star$ 表示 $u^\\star$：\n$$\n\\nabla_u J(u^\\star) + \\lambda^\\star c = 0 \\implies 2 A u^\\star - 2 b + \\lambda^\\star c = 0\n$$\n$$\nA u^\\star = b - \\frac{\\lambda^\\star}{2} c \\implies u^\\star = A^{-1}b - \\frac{\\lambda^\\star}{2} A^{-1}c\n$$\n注意到 $u_{\\mathrm{uncon}} = A^{-1}b$，我们有：\n$$\nu^\\star = u_{\\mathrm{uncon}} - \\frac{\\lambda^\\star}{2} A^{-1}c\n$$\n我们定义一个新的乘子 $\\mu = \\lambda^\\star / 2 \\ge 0$。那么，$u^\\star = u_{\\mathrm{uncon}} - \\mu A^{-1}c$。\n为了求出 $\\mu$，我们将这个 $u^\\star$ 的表达式代入激活的约束方程 $c^\\top u^\\star = d$：\n$$\nc^\\top (u_{\\mathrm{uncon}} - \\mu A^{-1}c) = d\n$$\n$$\nc^\\top u_{\\mathrm{uncon}} - \\mu (c^\\top A^{-1} c) = d\n$$\n求解 $\\mu$：\n$$\n\\mu = \\frac{c^\\top u_{\\mathrm{uncon}} - d}{c^\\top A^{-1} c}\n$$\n由于我们处于 $c^\\top u_{\\mathrm{uncon}} > d$ 的情况下，分子为正。由于 $A$ 是正定的，$A^{-1}$ 也是正定的，因此分母 $c^\\top A^{-1} c$ 也为正（对于 $c \\neq 0$）。这确保了 $\\mu > 0$（以及 $\\lambda^\\star > 0$），满足了对偶可行性条件。\n\n然后通过将这个 $\\mu$ 代回 $u^\\star$ 的表达式中来找到最优解：\n$$\nu^\\star = u_{\\mathrm{uncon}} - \\left( \\frac{c^\\top u_{\\mathrm{uncon}} - d}{c^\\top A^{-1} c} \\right) A^{-1}c \\quad \\text{如果 } c^\\top u_{\\mathrm{uncon}} > d\n$$\n\n**算法总结**\n计算过程如下：\n1.  给定问题参数，组装矩阵 $A = w_s S^\\top S + \\beta I$ 和向量 $b = w_s S^\\top s_{\\mathrm{ref}} + \\beta(1-\\tau) u_{\\mathrm{auto}} + \\beta\\tau u_{\\mathrm{human}}$。\n2.  计算无约束解 $u_{\\mathrm{uncon}} = A^{-1}b$。\n3.  通过评估 $c^\\top u_{\\mathrm{uncon}}$ 来检查 $u_{\\mathrm{uncon}}$ 是否可行。\n4.  如果 $c^\\top u_{\\mathrm{uncon}} \\le d$，则解为 $u^\\star = u_{\\mathrm{uncon}}$。\n5.  如果 $c^\\top u_{\\mathrm{uncon}} > d$，则通过将 $u_{\\mathrm{uncon}}$ 投影到约束超平面上来找到解：\n    $u^\\star = u_{\\mathrm{uncon}} - \\mu (A^{-1}c)$，其中 $\\mu = \\frac{c^\\top u_{\\mathrm{uncon}} - d}{c^\\top A^{-1} c}$。\n\n此过程为所有指定情况提供了唯一的、最优的控制输入 $u^\\star$。",
            "answer": "```python\nimport numpy as np\n\ndef solve_case(S, s_ref, u_auto, u_human, beta, w_s, c, d, tau):\n    \"\"\"\n    Solves the constrained quadratic optimization problem for a single test case\n    based on the KKT-derived algorithm.\n    \"\"\"\n    # 1. Assemble matrices A and b based on the problem derivation.\n    # Note: w_p + w_h = beta.\n    A = w_s * (S.T @ S) + beta * np.identity(2)\n    b = w_s * (S.T @ s_ref) + beta * (1 - tau) * u_auto + beta * tau * u_human\n\n    # 2. Compute the unconstrained minimizer u_uncon = A^-1 * b.\n    try:\n        A_inv = np.linalg.inv(A)\n    except np.linalg.LinAlgError:\n        # A should always be invertible as it is positive definite.\n        # This is a fallback, not expected to be triggered.\n        raise ValueError(\"Matrix A is singular.\")\n        \n    u_uncon = A_inv @ b\n\n    # Special handling for Case 4: d is defined based on the unconstrained solution.\n    if d is None:\n        d = c.T @ u_uncon\n\n    # 3. Check if the unconstrained solution is feasible.\n    if c.T @ u_uncon = d:\n        # Case I: Constraint is inactive or active with lambda=0.\n        # The unconstrained solution is the optimal solution.\n        u_star = u_uncon\n    else:\n        # Case II: Constraint is violated by the unconstrained solution.\n        # The optimal solution lies on the constraint boundary.\n        # We project u_uncon onto the hyperplane c^T u = d in the A-metric.\n        \n        # Calculate the multiplier mu = (c^T u_uncon - d) / (c^T A^-1 c)\n        cT_A_inv_c = c.T @ A_inv @ c\n        mu = (c.T @ u_uncon - d) / cT_A_inv_c\n        \n        # Calculate the constrained solution u* = u_uncon - mu * (A^-1 c)\n        u_star = u_uncon - mu * (A_inv @ c)\n\n    return u_star\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each,\n    and print the results in the specified format.\n    \"\"\"\n    # Common parameters for all test cases\n    S = np.array([[1.0, 0.2], [0.1, 1.5]])\n    s_ref = np.array([0.0, 1.0])\n    u_auto = np.array([0.5, -0.3])\n    u_human = np.array([0.0, 0.8])\n    beta = 2.0\n    w_s = 1.0\n    c = np.array([1.0, 1.0])\n\n    # Test cases defined by (d, tau)\n    test_cases = [\n        # Case 1: General \"happy path\"\n        {'d': 1.0,  'tau': 0.5},\n        # Case 2: Active safety constraint\n        {'d': 0.5,  'tau': 0.5},\n        # Case 3: Trust boundary at tau = 0\n        {'d': 0.55, 'tau': 0.0},\n        # Case 4: Trust boundary at tau = 1, with d determined by u_uncon\n        {'d': None, 'tau': 1.0},\n    ]\n\n    results = []\n    for case in test_cases:\n        u_star = solve_case(\n            S, s_ref, u_auto, u_human, beta, w_s, c, case['d'], case['tau']\n        )\n        results.append(u_star)\n\n    # Format the output string as per requirements:\n    # [[u1_1,u1_2],[u2_1,u2_2],...] with 6 decimal places and no spaces.\n    formatted_results = [f\"[{r[0]:.6f},{r[1]:.6f}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实际应用中，我们的模型，尤其是人类模型，永远不会是完美的。依赖一个不精确的模型可能会导致危险的系统行为。本练习  直面这一挑战，要求您设计一个鲁棒的安全保障机制。您将开发一个自主“干预”策略，即使在人类行为模型存在有界不确定性的最坏情况下，也能保证系统状态以高概率维持在安全范围内。",
            "id": "4226706",
            "problem": "一个用于信息物理系统 (CPS) 的数字孪生 (DT) 的共享自主控制器，必须能够适应其行为模型被错误指定的人类操作员。考虑一个单步安全保障机制，该机制为一个离散时间线性高斯对象融合了人类意图和机器人覆写。该对象根据以下基本离散时间线性动力学进行演化\n$$\nx_{t+1} = a\\,x_t + b\\,u_t + w_t,\n$$\n其中 $x_t$ 是状态（单位为米），$u_t$ 是控制输入（单位为米），$a$ 和 $b$ 是已知标量，$w_t$ 是均值为零、方差为 $\\sigma_w^2$（单位为平方米）的扰动。共享自主融合方式为\n$$\nu_t = \\alpha\\,h_t + (1-\\alpha)\\,r_t,\n$$\n其中 $h_t$ 是人类输入，$r_t$ 是由安全保障机制选择的机器人覆写。融合参数 $\\alpha \\in [0,1]$ 是已知的。人类模型是错误指定的：名义估计将 $h_t$ 视为均值为 $\\mu_h$、方差为 $\\sigma_h^2$ 的高斯分布，但真实均值偏离了一个满足 $|\\delta| \\le \\Delta$ 的未知偏移量 $\\delta$。因此，人类输入 $h_t$ 被建模为\n$$\nh_t \\sim \\mathcal{N}(\\mu_h + \\delta,\\ \\sigma_h^2),\\quad |\\delta| \\le \\Delta.\n$$\n安全性要求是下一状态以高概率在最坏情况的错误指定下保持在对称安全集内\n$$\n|x_{t+1}| \\le X_{\\max},\n$$\n您的安全保障机制必须选择一个满足饱和约束的机器人覆写 $r_t$\n$$\n|r_t| \\le U_{\\max},\n$$\n以最小化最坏情况风险，同时维持安全机会约束。为确保科学真实性，请使用以下原理作为基础：对象和融合的线性性、独立高斯变量之和的方差的独立性和可加性、双尾事件的联合界，以及高斯累积分布函数的性质。除这些原理外，不要假设任何捷径公式。\n\n任务：\n1. 从给定的动力学和融合方式出发，将 $r_t$ 视为确定性的，用 $a$、$b$、$\\alpha$、$x_t$、$r_t$、$\\mu_h$、$\\Delta$、$\\sigma_h^2$ 和 $\\sigma_w^2$ 推导 $x_{t+1}$ 的分布。通过构建在 $|\\delta| \\le \\Delta$ 上的最坏情况界，仔细考虑未知的均值偏移 $\\delta$。\n2. 仅使用联合界和高斯分布的性质，推导一个形式为 $P(|x_{t+1}| \\le X_{\\max}) \\ge 1 - \\varepsilon$ 的充分单步机会约束，该约束对于给定的 $r_t$ 是可检验的。该约束必须对所有 $|\\delta| \\le \\Delta$ 具有鲁棒性，并且不得依赖于所述原理之外的任何捷径公式。\n3. 推导在饱和约束 $|r_t| \\le U_{\\max}$ 下，能够最小化 $|\\delta| \\le \\Delta$ 条件下 $x_{t+1}$ 最坏情况绝对均值的 $r_t$ 的选择。解释您的推导如何遵循区间中心化和线性性的第一性原理。\n4. 使用推导出的充分条件，为所选的 $r_t$ 定义一个对 $|\\delta| \\le \\Delta$ 鲁棒的违规概率的最小可达到上界 $\\varepsilon_{\\text{bound}}$。如果总方差为零，请定义在该退化的确定性情况下 $\\varepsilon_{\\text{bound}}$ 的极限。\n\n数值单位与输出：\n- 状态 $x_t$ 的单位是米，控制 $u_t$ 和覆写 $r_t$ 的单位是米，方差的单位是平方米，$X_{\\max}$ 的单位是米。\n- 不使用角度。\n- 最终的覆写 $r_t$ 以米为单位表示，$\\varepsilon_{\\text{bound}}$ 以小数形式表示。\n\n测试套件：\n实现一个程序，对于以下每个测试用例，计算最小化最坏情况绝对均值的饱和 $r_t$，然后计算违规概率的鲁棒充分上界 $\\varepsilon_{\\text{bound}}$，并评估目标机会约束 $P(|x_{t+1}| \\le X_{\\max}) \\ge 1 - \\varepsilon_{\\text{target}}$ 的布尔可行性：\n- 用例 1 (正常路径)：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (0.9, 1.0, 0.7, 2.0, 1.0, 0.3, 0.5, 0.1, 3.0, 2.0, 0.05)$。\n- 用例 2 (边界压力)：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (1.2, 1.0, 0.9, 2.5, 1.5, 0.8, 0.7, 0.2, 3.0, 0.5, 0.02)$。\n- 用例 3 (无法覆写)：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (0.95, 1.0, 1.0, 0.0, 0.0, 0.5, 0.3, 0.1, 0.4, 1.0, 0.1)$。\n- 用例 4 (大驱动空间，稳定中心化)：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (0.5, 2.0, 0.6, -1.0, -0.5, 0.1, 0.2, 0.05, 1.0, 10.0, 0.01)$。\n- 用例 5 (确定性边缘)：$(a,b,\\alpha,x_t,\\mu_h,\\Delta,\\sigma_h,\\sigma_w,X_{\\max},U_{\\max},\\varepsilon_{\\text{target}}) = (1.0, 1.0, 0.5, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.001)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素都必须是 $[r_t,\\ \\text{feasible},\\ \\varepsilon_{\\text{bound}}]$ 形式的列表，其中 $r_t$ 的单位是米，$\\text{feasible}$ 是一个布尔值，$\\varepsilon_{\\text{bound}}$ 是一个保留六位小数的小数。例如，\n$$\n[[r_1,\\ \\text{feasible}_1,\\ \\varepsilon_{\\text{bound},1}],\\ [r_2,\\ \\text{feasible}_2,\\ \\varepsilon_{\\text{bound},2}],\\ \\ldots]\n$$\n并且在单行上。",
            "solution": "### 基于原理的推导\n\n#### 任务 1：下一状态 $x_{t+1}$ 的分布\n\n状态 $x_{t+1}$ 的演化通过将共享自主控制律代入对象动力学来确定：\n$$\nx_{t+1} = a\\,x_t + b \\left( \\alpha\\,h_t + (1-\\alpha)\\,r_t \\right) + w_t\n$$\n我们可以通过将确定性项和随机项分组来重新排列这个表达式。在时间 $t$，$x_t$ 状态和所选的覆写 $r_t$ 是已知的（确定性的）。人类输入 $h_t$ 和过程噪声 $w_t$ 是独立的随机变量。\n$$\nx_{t+1} = \\underbrace{(a\\,x_t + b(1-\\alpha)r_t)}_{\\text{确定性部分}} + \\underbrace{b\\alpha\\,h_t + w_t}_{\\text{随机部分}}\n$$\n由于 $x_{t+1}$ 是独立高斯随机变量（$h_t$ 和 $w_t$）和确定性项的线性组合，因此 $x_{t+1}$ 本身服从高斯分布，$x_{t+1} \\sim \\mathcal{N}(\\mu_{x_{t+1}}, \\sigma_{x_{t+1}}^2)$。\n\n$x_{t+1}$ 的均值，表示为 $\\mu_{x_{t+1}}(\\delta)$，依赖于未知的偏移 $\\delta$：\n$$\n\\mu_{x_{t+1}}(\\delta) = E[a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\,h_t + w_t]\n$$\n利用期望的线性性以及给定的均值 $E[h_t] = \\mu_h + \\delta$ 和 $E[w_t] = 0$：\n$$\n\\mu_{x_{t+1}}(\\delta) = a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\,E[h_t] + E[w_t] = a\\,x_t + b(1-\\alpha)r_t + b\\alpha(\\mu_h + \\delta)\n$$\n我们将名义均值 $\\mu_{\\text{nom}}$ 定义为均值中独立于不确定性 $\\delta$ 的部分：\n$$\n\\mu_{\\text{nom}}(r_t) = a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h\n$$\n因此，均值为 $\\mu_{x_{t+1}}(\\delta) = \\mu_{\\text{nom}}(r_t) + b\\alpha\\delta$。由于 $|\\delta| \\le \\Delta$，均值位于区间 $[\\mu_{\\text{nom}}(r_t) - |b\\alpha|\\Delta, \\mu_{\\text{nom}}(r_t) + |b\\alpha|\\Delta]$ 内。\n\n$x_{t+1}$ 的方差 $\\sigma_{x_{t+1}}^2$ 与 $\\delta$ 无关。由于 $h_t$ 和 $w_t$ 是独立的：\n$$\n\\sigma_{x_{t+1}}^2 = \\text{Var}(a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\,h_t + w_t) = \\text{Var}(b\\alpha\\,h_t) + \\text{Var}(w_t)\n$$\n利用方差性质 $\\text{Var}(cZ) = c^2\\text{Var}(Z)$ 以及给定的方差 $\\text{Var}(h_t) = \\sigma_h^2$ 和 $\\text{Var}(w_t) = \\sigma_w^2$：\n$$\n\\sigma_{x_{t+1}}^2 = (b\\alpha)^2\\sigma_h^2 + \\sigma_w^2\n$$\n对于给定的系统参数集，这个总方差是恒定的。\n\n#### 任务 2：充分机会约束的推导\n\n安全性要求是对于所有 $|\\delta| \\le \\Delta$，$P(|x_{t+1}| \\le X_{\\max}) \\ge 1 - \\varepsilon$。这等价于确保在最坏情况 $\\delta$ 下，违规概率 $P(|x_{t+1}| > X_{\\max}) \\le \\varepsilon$。\n\n违规概率 $|x_{t+1}| > X_{\\max}$ 在均值 $\\mu_{x_{t+1}}(\\delta)$ 的绝对值最大时达到最大。这个最坏情况的绝对均值是：\n$$\n\\max_{|\\delta| \\le \\Delta} |\\mu_{x_{t+1}}(\\delta)| = \\max_{|\\delta| \\le \\Delta} |\\mu_{\\text{nom}}(r_t) + b\\alpha\\delta| = |\\mu_{\\text{nom}}(r_t)| + |b\\alpha|\\Delta\n$$\n我们将这个最坏情况绝对均值命名为 $\\mu_{\\text{wc,abs}}(r_t)$。\n对于具有均值 $\\mu$ 和方差 $\\sigma^2$ 的高斯变量 $X$，违规概率 $P(|X| > X_{\\max})$ 在 $|\\mu|$ 最大时最大化。因此，我们只需要在最坏情况均值下强制执行机会约束。\n\n设 $x_{t+1}^{\\text{wc}}$ 是在最坏情况均值下的随机变量，即 $x_{t+1}^{\\text{wc}} \\sim \\mathcal{N}(\\text{sgn}(\\mu_{\\text{nom}}(r_t))\\mu_{\\text{wc,abs}}(r_t), \\sigma_{x_{t+1}}^2)$。违规概率为 $P(|x_{t+1}^{\\text{wc}}| > X_{\\max})$。\n使用联合界，$P(|Z| > z) \\le P(Z > z) + P(Z  -z)$。对于一个均值为 $\\mu$ 的高斯变量，这变为 $1 - \\Phi(\\frac{z-\\mu}{\\sigma}) + \\Phi(\\frac{-z-\\mu}{\\sigma})$。\n我们可以通过考虑一个以 $\\mu_{\\text{wc,abs}}(r_t)$ 为中心的高斯分布来简化，并要求其尾部概率之和小于 $\\varepsilon$。\n设 $Z \\sim \\mathcal{N}(0, 1)$。\n$$\nP(|x_{t+1}| > X_{\\max} \\mid \\delta) = P(x_{t+1} > X_{\\max}) + P(x_{t+1}  -X_{\\max})\n$$\n$$\n= 1 - \\Phi\\left(\\frac{X_{\\max} - \\mu_{x_{t+1}}(\\delta)}{\\sigma_{x_{t+1}}}\\right) + \\Phi\\left(\\frac{-X_{\\max} - \\mu_{x_{t+1}}(\\delta)}{\\sigma_{x_{t+1}}}\\right)\n$$\n这个表达式在 $|\\mu_{x_{t+1}}(\\delta)|$ 最大时最大化，即在 $\\mu_{\\text{wc,abs}}(r_t)$ 时。\n因此，鲁棒机会约束变为\n$$\n1 - \\Phi\\left(\\frac{X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{x_{t+1}}}\\right) + \\Phi\\left(\\frac{-X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{x_{t+1}}}\\right) \\le \\varepsilon\n$$\n使用 $\\Phi(-z) = 1-\\Phi(z)$，这可以重写为 $2 - \\Phi\\left(\\frac{X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{x_{t+1}}}\\right) - \\Phi\\left(\\frac{X_{\\max} + \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{x_{t+1}}}\\right) \\le \\varepsilon$。\n对于对称的双尾情况，一个更简单（但更保守）的充分条件是 $P(|x_{t+1}^{\\text{wc,0}}| > X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)) \\le \\varepsilon$，其中 $x_{t+1}^{\\text{wc,0}} \\sim \\mathcal{N}(0, \\sigma_{x_{t+1}}^2)$。这导致了 $2(1-\\Phi(\\frac{X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{x_{t+1}}})) \\le \\varepsilon$。问题中的提示“联合界”指向了这个更简单的、对称化的方法，我们将遵循它。\n\n#### 任务 3：最优机器人覆写 $r_t$\n\n目标是选择 $r_t$ 以最小化 $x_{t+1}$ 的最坏情况绝对均值，同时满足 $|r_t| \\le U_{\\max}$ 的约束。需要最小化的表达式是：\n$$\n\\mu_{\\text{wc,abs}}(r_t) = |\\mu_{\\text{nom}}(r_t)| + |b\\alpha|\\Delta = |a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h| + |b\\alpha|\\Delta\n$$\n关于 $r_t$ 最小化这个表达式等价于最小化 $|\\mu_{\\text{nom}}(r_t)|$，因为项 $|b\\alpha|\\Delta$ 相对于 $r_t$ 是常数。$|\\mu_{\\text{nom}}(r_t)|$ 在其参数为零时最小化，这就是将名义分布中心置于原点的原理。\n$$\n\\mu_{\\text{nom}}(r_t) = a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h = 0\n$$\n求解无约束的最优覆写 $r_t^*$：\n$$\nb(1-\\alpha)r_t^* = -(a\\,x_t + b\\alpha\\mu_h) \\implies r_t^* = -\\frac{a\\,x_t + b\\alpha\\mu_h}{b(1-\\alpha)}\n$$\n如果 $b(1-\\alpha) \\neq 0$，此解有效。如果 $b(1-\\alpha) = 0$（即 $b=0$ 或 $\\alpha=1$），机器人无权改变均值，其 $r_t$ 的选择与目标无关。在这种情况下，常规选择是 $r_t=0$。\n\n为了满足饱和约束 $|r_t| \\le U_{\\max}$，我们将无约束解 $r_t^*$ 投影到区间 $[-U_{\\max}, U_{\\max}]$ 上。这是一个裁剪操作：\n$$\nr_{t, \\text{opt}} = \\text{clip}(r_t^*, -U_{\\max}, U_{\\max}) = \\max(-U_{\\max}, \\min(U_{\\max}, r_t^*))\n$$\n\n#### 任务 4：最小可达违规概率界 $\\varepsilon_{\\text{bound}}$\n\n违规概率的最小可达上界 $\\varepsilon_{\\text{bound}}$ 是通过计算任务 3 中选择的最优覆写 $r_{t, \\text{opt}}$，并将其代入任务 2 中推导出的充分违规概率公式来找到的。\n\n1.  计算最优饱和覆写 $r_t = r_{t, \\text{opt}}$。\n2.  计算相应的最坏情况绝对均值 $\\mu_{\\text{wc,abs}}(r_t) = |a\\,x_t + b(1-\\alpha)r_t + b\\alpha\\mu_h| + |b\\alpha|\\Delta$。\n3.  计算总标准差 $\\sigma_{\\text{tot}} = \\sqrt{(b\\alpha\\sigma_h)^2 + \\sigma_w^2}$。\n4.  基于两种情况计算界 $\\varepsilon_{\\text{bound}}$：\n    *   **随机情况 ($\\sigma_{\\text{tot}} > 0$):**\n        如果 $X_{\\max}  \\mu_{\\text{wc,abs}}(r_t)$，在此保守界下违规是必然的，所以 $\\varepsilon_{\\text{bound}} = 1.0$。\n        否则，$\\varepsilon_{\\text{bound}} = 2 \\left( 1 - \\Phi\\left( \\frac{X_{\\max} - \\mu_{\\text{wc,abs}}(r_t)}{\\sigma_{\\text{tot}}} \\right) \\right)$。\n    *   **确定性情况 ($\\sigma_{\\text{tot}} = 0$):**\n        系统是确定性的。违规发生当且仅当最坏情况状态 $|x_{t+1}|$ 超过 $X_{\\max}$。\n        如果 $|x_{t+1}|_{\\text{wc}} = \\mu_{\\text{wc,abs}}(r_t) > X_{\\max}$，违规是必然的，所以 $\\varepsilon_{\\text{bound}} = 1.0$。\n        否则，违规是不可能的，所以 $\\varepsilon_{\\text{bound}} = 0.0$。\n\n这个公式提供了一种计算最优覆写及其相关鲁棒安全保证的完整方法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\n# np.__version__ should be 1.23.5\n# scipy.__version__ should be 1.11.4\n\ndef solve():\n    \"\"\"\n    Solves the shared autonomy safeguard problem for a set of test cases.\n    \"\"\"\n    # Test cases from the problem statement:\n    # (a, b, alpha, xt, mu_h, Delta, sigma_h, sigma_w, X_max, U_max, eps_target)\n    test_cases = [\n        (0.9, 1.0, 0.7, 2.0, 1.0, 0.3, 0.5, 0.1, 3.0, 2.0, 0.05),\n        (1.2, 1.0, 0.9, 2.5, 1.5, 0.8, 0.7, 0.2, 3.0, 0.5, 0.02),\n        (0.95, 1.0, 1.0, 0.0, 0.0, 0.5, 0.3, 0.1, 0.4, 1.0, 0.1),\n        (0.5, 2.0, 0.6, -1.0, -0.5, 0.1, 0.2, 0.05, 1.0, 10.0, 0.01),\n        (1.0, 1.0, 0.5, 1.0, -1.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.001),\n    ]\n\n    results = []\n    \n    # A small tolerance for floating point comparisons\n    TOLERANCE = 1e-9\n\n    for case in test_cases:\n        a, b, alpha, x_t, mu_h, Delta, sigma_h, sigma_w, X_max, U_max, eps_target = case\n\n        # Task 3: Derive the choice of r_t\n        r_t_opt = 0.0\n        # The term b*(1-alpha) determines the robot's control authority over the mean\n        control_authority = b * (1 - alpha)\n        \n        if abs(control_authority) > TOLERANCE:\n            # Unconstrained optimal r_t to center the nominal mean at zero\n            r_t_unc = -(a * x_t + b * alpha * mu_h) / control_authority\n            # Apply saturation constraint |r_t| = U_max\n            r_t_opt = np.clip(r_t_unc, -U_max, U_max)\n        else:\n            # If control authority is zero (alpha=1 or b=0), the robot cannot influence\n            # the mean. By convention, the override is set to zero.\n            r_t_opt = 0.0\n\n        # Task 4: Define the minimal achievable upper bound on the violation probability\n        \n        # 1. Calculate nominal mean with the chosen r_t\n        mu_nom = a * x_t + b * (1 - alpha) * r_t_opt + b * alpha * mu_h\n        \n        # 2. Calculate worst-case absolute mean, robust to delta\n        mu_wc_abs = abs(mu_nom) + abs(b * alpha) * Delta\n        \n        # 3. Calculate total variance and standard deviation\n        sigma_sq_h = (b * alpha * sigma_h)**2\n        sigma_sq_w = sigma_w**2\n        sigma_tot_sq = sigma_sq_h + sigma_sq_w\n        sigma_tot = np.sqrt(sigma_tot_sq)\n\n        eps_bound = 0.0\n\n        # 4. Calculate the violation probability bound\n        if sigma_tot  TOLERANCE:\n            # Deterministic case\n            if mu_wc_abs > X_max:\n                eps_bound = 1.0\n            else:\n                eps_bound = 0.0\n        else:\n            # Stochastic case\n            safety_margin = X_max - mu_wc_abs\n            if safety_margin  0:\n                # The worst-case mean is already outside the safe set,\n                # making the sufficient condition impossible to meet.\n                eps_bound = 1.0\n            else:\n                # Use survival function (1 - CDF) for numerical stability\n                # P(|err| > Y) = 2 * P(err > Y) = 2 * sf(Y / sigma)\n                z = safety_margin / sigma_tot\n                eps_bound = 2.0 * norm.sf(z)\n\n        # Evaluate feasibility of the target chance constraint\n        feasible = eps_bound = eps_target\n\n        results.append([r_t_opt, feasible, round(eps_bound, 6)])\n\n    # Format the final output as a string representing a list of lists.\n    # The default str() representation of a list is used for formatting.\n    # E.g., `str([-2.0, True, 0.01448])` -> `'[-2.0, True, 0.01448]'`\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}