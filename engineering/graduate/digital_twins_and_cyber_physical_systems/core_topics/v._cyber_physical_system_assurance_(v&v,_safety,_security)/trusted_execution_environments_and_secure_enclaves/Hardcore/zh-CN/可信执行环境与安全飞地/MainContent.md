## 引言
在当今高度互联的数字世界中，数据和代码的安全性面临着前所未有的挑战。传统的安全模型通常假设操作系统（OS）或[虚拟机](@entry_id:756518)管理程序（[Hypervisor](@entry_id:750489)）是可信的，但随着攻击手段日益复杂，这种信任基础正变得越来越脆弱。一旦这些特权软件被攻破，其上运行的所有应用程序的机密性和完整性都将岌岌可危。[可信执行环境](@entry_id:756203)（Trusted Execution Environment, TEE）作为一种革命性的硬件安全技术应运而生，旨在解决这一根本性问题。它通过在处理器内部创建被称为“[安全飞地](@entry_id:754618)”（[Secure Enclave](@entry_id:754618)s）的隔离执行区域，即使在操作系统和[虚拟机](@entry_id:756518)管理程序完全被恶意控制的情况下，也能为敏感代码和数据提供强有力的保护。

然而，要有效利用这一强大技术，仅仅了解其“能做什么”是远远不够的，更需要深入理解其“如何做到”以及在实践中需要注意的各种复杂性和权衡。本文旨在填补理论与实践之间的鸿沟，为读者提供一个关于TEE的系统性、深层次的指南。我们将从第一性原理出发，逐步揭开TEE的神秘面纱。

在“原理与机制”一章中，我们将深入剖析构成TEE安全基石的核心概念，包括[可信计算基](@entry_id:756201)（TCB）的最小化原则、明确的对手模型，以及由硬件强制执行的隔离、证明和状态持久化机制。接着，在“应用与跨学科连接”一章中，我们将视野扩展到现实世界，探讨TEE如何在网络物理系统、[机密计算](@entry_id:747674)、数据科学和云原生等前沿领域中发挥关键作用，解决具体的安全与隐私挑战。最后，“动手实践”部分将提供一系列精心设计的编程问题，让读者通过实际操作来量化TEE的开销、理解其性能影响，并学习抵御[侧信道攻击](@entry_id:275985)的关键编程范式。通过这一结构化的学习路径，读者将能够建立起对TEE技术的全面认知，为其在未来系统设计和安全研究中的应用打下坚实的基础。

## 原理与机制

在介绍性章节中，我们确立了[可信执行环境](@entry_id:756203)（TEE）作为在潜在恶意主机环境中保护计算机密性和完整性的关键技术。本章将深入探讨支撑这些强大安全保障的核心原理和底层机制。我们将从定义 TEE 安全模型的基石开始，然后剖析不同的 TEE 架构范式，并详细研究处理器用以强制隔离、证明身份和维护持久状态的具体硬件机制。最后，我们将探讨这些机制的局限性，特别是[侧信道攻击](@entry_id:275985)所带来的挑战。

### 可信执行的基本原理

任何安全系统的价值都取决于其基础原理的严谨性。对于 TEE 而言，三个核心概念构成了其安全论证的基石：[可信计算基](@entry_id:756201)（TCB）、明确定义的对手模型以及一套强大的安全保证。

#### [可信计算基](@entry_id:756201)（TCB）：对最小化的追求

一个系统的安全性最终依赖于其**[可信计算基](@entry_id:756201)（Trusted Computing Base, TCB）**的正确运行。TCB 被定义为必须始终被信任以确保系统安全策略得以强制执行的硬件、固件和软件组件的最小集合。TCB 的一个核心设计原则是**最小化**。TCB 越小，其包含漏洞或配置错误的可能性就越低，从而使得验证其正确性变得更加可行，攻击面也随之减小。TEE 的主要价值主张之一就是它能够显著缩小 TCB 的范围。

#### 对手模型：我们防范的对象是谁？

TEE 的设计旨在抵御一类非常强大且普遍存在的对手：**特权软件**。在一个典型的 TEE 威胁模型中，我们假设对手已经完全控制了主机系统，包括操作系统（OS）、[虚拟机](@entry_id:756518)管理程序（[Hypervisor](@entry_id:750489)）以及所有驱动程序。这样的对手可以读取和修改主内存中的任意数据，调度或停止进程，并与外围设备交互。TEE 的目标是在这样一个充满敌意的环境中，为应用程序开辟出一片安全的“飞地”（Enclave），使其代码和数据在执行期间免受特权软件对手的窥探和篡改。

理解 TEE 所排除的对手是至关重要的。为了更清晰地界定其范围，我们可以将其与另外两种常见的[硬件安全](@entry_id:169931)技术进行对比 ：

-   **[可信平台模块](@entry_id:756204)（Trusted Platform Module, [TPM](@entry_id:170576)）**：TPM 是一种被动的、功能固定的协处理器，主要提供密钥存储、平台完整性度量（通过安全启动）和签名（证明）等功能。它的 TCB 仅限于 TPM 芯片本身及其固件。TPM 保护的是其内部的密钥和度量过程不被主机软件（包括特权软件）篡改或窃取，但它**不提供[通用计算](@entry_id:275847)**能力。也就是说，你不能在 TPM 内部运行一个通用的数字孪生控制器。

-   **[硬件安全](@entry_id:169931)模块（Hardware Security Module, HSM）**：HSM 是一种专用的、高强度的外部加密设备，旨在提供高性能的加密操作和安全的密钥管理。它的 TCB 是整个 HSM 设备，其设计旨在抵御包括特权软件和一定程度的**物理攻击**在内的强大对手。然而，与 [TPM](@entry_id:170576) 类似，标准 HSM 也不为在主机 CPU 上运行的任意应用程序代码提供执行时保护，其执行能力仅限于内部预定义的加密和策略功能。

-   **[可信执行环境](@entry_id:756203)（Trusted Execution Environment, TEE）**：与前两者不同，TEE 的核心功能是**为[通用计算](@entry_id:275847)提供机密性和完整性保护**。它的 TCB 被设计为仅包含 CPU 硬件、其微码以及一小部分支持性运行时代码，明确地将庞大而复杂的主机操作系统和[虚拟机](@entry_id:756518)管理程序**排除在外**。这使得 TEE 能够在一个假定已被攻陷的系统上，安全地执行用户定义的任意代码，例如数字孪生的[状态估计器](@entry_id:272846)和控制器。

#### 核心[安全保证](@entry_id:1131169)：机密性、完整性与证明

基于最小化的 TCB 和明确的对手模型，TEE 提供了三个核心的安全保证：

1.  **执行时的机密性（Confidentiality）**：TEE 确保在其内部执行的代码和处理的数据在运行时对 TCB 之外的任何软件（包括操作系统和[虚拟机](@entry_id:756518)管理程序）都是不可见的。这是通过硬件[内存加密](@entry_id:751857)和[访问控制](@entry_id:746212)来实现的，即使对手拥有系统的[最高权](@entry_id:202808)限，也只能看到加密后的内存内容。

2.  **执行时的完整性（Integrity）**：TEE 确保其内部的代码和数据不会被 TCB 之外的实体非法篡改。硬件机制会检测并阻止任何未经授权的修改尝试，保证了计算过程的正确性。

3.  **证明（Attestation）**：这是 TEE 最具变革性的能力之一。**证明**是一个过程，通过该过程，TEE 能够向一个远程方（验证者）提供一个加密签名过的证据，证明其正在一个真实的、符合特定安全标准的硬件上运行着特定的、未经修改的代码。这个证据使得远程方可以信任在该 TEE 内部产生的计算结果，而无需信任运行该 TEE 的整个计算机系统。

### [可信执行环境](@entry_id:756203)的架构模型

虽然所有 TEE 都共享上述基本原理，但它们在实现隔离的具体架构上存在显著差异。这些差异决定了 TCB 的确切边界，并影响了它们在不同场景下的适用性，例如在多租户云环境中。

#### 基于进程的 TEE 与基于[虚拟机](@entry_id:756518)的 TEE

当前主流的 TEE 架构可以分为两类：基于进程的模型和基于[虚拟机](@entry_id:756518)的模型 。

-   **基于进程的 TEE（例如，[Intel SGX](@entry_id:750706)）**：这种模型在单个用户空间进程内部创建一个或多个被称为**飞地（Enclave）**的隔离区域。保护边界被精确地绘制在应用程序的特定部分周围。在这种架构下，主机操作系统和[虚拟机](@entry_id:756518)管理程序都位于 TCB **之外**，并被视为潜在的对手。CPU 硬件负责强制执行隔离，阻止 OS/[Hypervisor](@entry_id:750489) 访问飞地的私有内存。因此，其 TCB 极其微小，主要由 CPU 和飞地内的代码本身构成。这种精细的粒度使得应用程序开发者可以精确控制信任边界，但通常需要对应用程序进行专门的修改以适应飞地编程模型。

-   **基于[虚拟机](@entry_id:756518)的 TEE（例如，[AMD SEV](@entry_id:1120976)-SNP, Intel TDX）**：这种模型将保护边界扩展到整个**[虚拟机](@entry_id:756518)（VM）**。它利用硬件[内存加密](@entry_id:751857)和完整性保护技术，保护整个 VM 的内存免受底层[虚拟机](@entry_id:756518)管理程序的侵害。因此，对于运行在“机密[虚拟机](@entry_id:756518)”（Confidential VM）中的应用程序而言，云服务提供商的[虚拟机](@entry_id:756518)管理程序位于 TCB **之外**。然而，一个关键的区别是，该 VM 内部的**客户操作系统（Guest OS）**现在成为了应用程序 TCB 的**一部分**。[硬件保护](@entry_id:750157)的是 VM 与 [Hypervisor](@entry_id:750489) 之间的边界，而不是 VM 内部应用程序与客户操作系统之间的边界。这意味着，应用程序的安全性现在依赖于其所在的整个客户操作系统的正确性。这种架构的优势在于它通常不需要修改应用程序（“直接迁移” lift-and-shift），但其 TCB 比基于进程的 TEE 要大得多，因为它包含了整个客户操作系统。

#### 系统级分区：ARM TrustZone 模型

另一种重要的 TEE 架构是 **ARM TrustZone**。与上述模型不同，TrustZone 将整个系统（包括处理器、内存和外设）在硬件层面划分为两个“世界”：**安全世界（Secure World）**和**普通世界（Normal World）** 。

-   **普通世界**运行着我们熟悉的富操作系统，如 Linux 或 Android，以及其上的各种应用程序。
-   **安全世界**则运行着一个独立的、小型的、高度可信的操作系统和一些可信应用（Trusted Applications, TA）。

硬件通过一个特殊的“世界位”来强制隔离，确保普通世界的代码无法访问安全世界的内存资源。然而，这种架构存在一个根本性的特点：整个系统中只有一个安全世界。这意味着，如果要在多租户云环境中为每个租户提供 TEE，所有租户的可信应用都必须在同一个安全世界中共存。它们之间的隔离必须依赖于在安全世界中运行的软件（如安全操作系统），而不再是纯粹的硬件隔离。这导致了几个问题：

1.  **庞大的 TCB**：对于任何一个租户来说，其 TCB 不仅包括自己的应用，还包括安全操作系统、所有驱动程序以及所有其他租户的应用。这极大地增加了攻击面。
2.  **弱化的租户间隔离**：租户间的防线从硬件变成了软件。
3.  **粗粒度的证明**：证明机制通常只能对整个安全世界的镜像进行一次性的度量，而难以实现对每个租户应用的独立、细粒度证明。

因此，虽然 TrustZone 在移动设备等单用户、功能固定的场景中非常有效，但其单体式、系统级的划分使其在需要支持多个动态、相互不信任的实体的现代[云计算](@entry_id:747395)场景中，不如基于 enclave/VM 的模型灵活和安全。

### TEE 的核心机制

TEE 的[安全保证](@entry_id:1131169)并非凭空而来，而是由一系列精密的硬件机制共同实现的。这些机制协同工作，构成了从启动到运行再到状态保存的完整安全链条。

#### 建立信任链：[安全启动](@entry_id:754616)

所有信任都必须有一个源头。对于 TEE 平台而言，这个源头是**安全启动（Secure Boot）**过程，它植根于一个不可变的[硬件信任根](@entry_id:1125916)（Root of Trust），通常是处理器 ROM 中的一段代码和嵌入的供应商公钥 。[安全启动过程](@entry_id:754617)结合了两种机制：

-   **认证启动（Authenticated Boot）**：这是一个**预防性**机制。从 ROM 代码开始，每个启动阶段的组件都会在加载并执行下一个阶段的组件之前，使用可信的公钥验证其[数字签名](@entry_id:269311)。这形成了一条**[信任链](@entry_id:747264)**：ROM 验证[引导加载程序](@entry_id:746922)，引导加载程序验证操作系统，依此类推。只有签名正确的组件才会被执行，从而阻止了恶意代码在启动过程的早期注入。

-   **[度量启动](@entry_id:751820)（Measured Boot）**：这是一个**报告性**机制。在认证启动的每个阶段，被加载组件的加密哈希（即“度量值”）会被记录到一个特殊的、仅支持扩展（append-only）的 CPU 寄存器中，称为**平台配置寄存器（Platform Configuration Registers, PCRs）**。这个过程是累积且顺序相关的：$PCR_{new} \leftarrow H(PCR_{old} \parallel \text{measurement})$。最终，PCRs 中包含了整个启动链的唯一“指纹”。

这两个机制是相辅相成的。认证启动确保了执行环境的初始完整性，而[度量启动](@entry_id:751820)则为后续的[远程证明](@entry_id:754241)过程提供了可验证的证据。一个至关重要的原则是：**信任链的完整性取决于其最薄弱的环节**。例如，如果一个本应由供应商签名的微码更新，由于配置错误而被一个未经授权的密钥签名并通过了验证，那么整个[信任链](@entry_id:747264)就在第一环被打破了。此时，即使后续的操作系统和飞地度量值看起来都“正确”，这些度量本身也已不再可信，因为执行度量操作的处理器本身可能已经被恶意微码所控制。一个看似成功的[远程证明](@entry_id:754241)，如果其基础（即微码）是不可信的，那么这个证明就是毫无价值的谎言。

#### 强制隔离：深入处理器内部

一旦可信的 TEE [运行时环境](@entry_id:754454)被建立起来，处理器就必须通过硬件机制来强制执行隔离，保护飞地或机密 VM 免受特权软件的侵害。

以 **[Intel SGX](@entry_id:750706)** 为例，它依赖于三个关键组件协同工作 ：

1.  **飞地[页缓存](@entry_id:753070)（Enclave Page Cache, EPC）**：这是物理内存中一块被 CPU 保留的专用区域，专门用于存放飞地的代码和数据页。
2.  **飞地[页缓存](@entry_id:753070)映射（Enclave Page Cache Map, EPCM）**：这是一个位于 CPU 内部、由硬件管理的安全元数据结构。对于 EPC 中的每一个物理页，EPCM 都会记录该页属于哪个飞地、其访问权限（读/写/执行）以及版本号等信息。当任何代码（无论是飞地内部还是外部）尝试访问一个 EPC 页时，CPU 硬件都会强制检查 EPCM，确保访问的发起者身份与页面所有者匹配，且操作符合权限设置。这个检查是独立于且优先于操作系统控制的[页表](@entry_id:753080)的。因此，即使恶意操作系统修改[页表](@entry_id:753080)，试图将一个飞地页映射到另一个进程的地址空间，硬件层面的 EPCM 检查也会使其失败。
3.  **[内存加密](@entry_id:751857)引擎（Memory Encryption Engine, MEE）**：为了防止对手通过物理探针或 DMA 攻击直接从内存总线上窃取数据，MEE 会使用仅存于 CPU 内部的密钥，自动对所有离开 CPU 写入到 EPC 的数据进行加密和完整性保护。当数据从内存读回 CPU 时，MEE 会对其进行解密和完整性校验。任何在内存中对密文的篡改都会在校验阶段被发现，从而触发错误。

这三者共同构成了一道坚固的防线：EPC 提供了物理上的专属区域，EPCM 在硬件层面绑定了物理页与飞地身份，而 MEE 则保护了数据在 CPU 之外的机密性和完整性。

而在 **[AMD SEV](@entry_id:1120976)-SNP** 这类基于 VM 的 TEE 中，采用了不同的机制来应对来自[虚拟机](@entry_id:756518)管理程序的威胁 。其核心是**[反向映射](@entry_id:1121305)表（Reverse Map Table, RMP）**。

-   **[反向映射](@entry_id:1121305)表（RMP）**：与 SGX 的 EPCM 类似，RMP 也是一个由[硬件保护](@entry_id:750157)的元[数据结构](@entry_id:262134)，它为系统中的每一个物理内存页记录其所有者（属于哪个 VM 或 [Hypervisor](@entry_id:750489)）以及状态（如是否为私有页、是否已验证）。当 VM 尝试访问一个内存页时，硬件会检查 RMP 以确保该页确实属于该 VM。更重要的是，RMP 旨在防止[虚拟机](@entry_id:756518)管理程序进行恶意替换。
-   **页验证（PVALIDATE）**：一个机密 VM 在启动时或运行时，可以由其内部的可信代码（如客户操作系统）对自己拥有的内存页执行 `PVALIDATE` 指令。一旦一个页面被标记为“已验证”，[虚拟机](@entry_id:756518)管理程序就无法再通过 `RMPUPDATE` 指令修改该页的 RMP 条目（例如，将其所有权转移给另一个 VM）。
-   **联合防御**：假设一个恶意 [Hypervisor](@entry_id:750489) 试图通过修改嵌套[页表](@entry_id:753080)（NPT），将一个包含 VM 正常代码的物理页 $h$ 指向一个包含恶意代码的物理页 $h'$。当 VM 的 vCPU 尝试执行代码时，[地址转换](@entry_id:746280)会指向 $h'$。此时，硬件会检查 RMP。由于 $h'$ 是由 [Hypervisor](@entry_id:750489) 植入的，它从未被 VM 内部的可信[代码验证](@entry_id:146541)过，其 RMP 状态将是“未验证”。硬件检查失败，并产生一个 RMP 违规异常，从而阻止了恶意代码的执行。这一机制确保了 [Hypervisor](@entry_id:750489) 虽然控制着[内存映射](@entry_id:175224)，却无法在不被检测到的情况下破坏 VM 的内存完整性。

#### 证明身份：证明机制详解

证明是 TEE 将其内部信任状态传递给外部世界的桥梁。根据验证者的位置，证明可以分为本地证明和[远程证明](@entry_id:754241) 。

-   **本地证明（Local Attestation）**：发生在同一台物理机器上的两个飞地之间。其目标是让一个飞地（发送者）向另一个飞地（目标）证明自己的身份。由于它们共享同一个 CPU 作为[信任根](@entry_id:754420)，这个过程可以高效地通过**对称密钥加密**完成。发送者请求 CPU 生成一个包含其身份度量值（`MRENCLAVE`）和目标飞地信息的报告（`REPORT`）。CPU 使用一个只有目标飞地才能通过 `EGETKEY` 指令在当前 CPU 上派生出的对称密钥（报告密钥），为这份报告生成一个**消息认证码（Message Authentication Code, MAC）**。目标飞地在收到报告和 MAC 后，自己派生出相同的密钥来验证 MAC 的有效性。如果验证通过，它就能确信报告内容真实且专为自己生成。

-   **[远程证明](@entry_id:754241)（Remote Attestation）**：发生在 TEE 与一个网络上的远程验证者之间。由于不存在共享的[信任根](@entry_id:754420)，必须使用**[公钥密码学](@entry_id:150737)**。飞地请求平台生成一个“引用”（`QUOTE`），其内容与报告类似，包含了飞地的度量值和验证者提供的随机数（`nonce`，用于防重放）。这个引用由一个平台独有的、硬件绑定的**证明私钥**进行签名。为了让远程验证者信任这个签名，平台还必须提供一个**证书链**，该证书链从证明公钥开始，一直追溯到一个广受信任的根[证书颁发机构](@entry_id:1122212)（CA），例如芯片制造商（如 Intel）的根 CA。远程验证者首先验证整个证书链，确保证明密钥来自一个真实的 TEE 平台，然后再用该公钥验证引用的签名。验证成功后，验证者就可以相信引用中的度量值，从而确认飞地的身份。

#### TCB 更新与撤销：DCAP 的作用

平台的安全状态不是一成不变的。随着新的漏洞被发现，CPU 微码、固件和 TEE 相关的系统组件（统称为 TCB 组件）都需要更新。[远程证明](@entry_id:754241)不仅要验证飞地本身，还必须验证其运行所在的整个平台 TCB 是否处于最新的、未被曝出漏洞的[安全状态](@entry_id:754485)。

Intel 的**数据中心证明原语（Data Center Attestation Primitives, DCAP）**模型为此提供了一套机制 。验证者在验证引用时，除了证书链，还需要获取由 Intel 提供的“旁系佐证材料”（collateral），其中最重要的是 **TCB 信息（TCBInfo）**结构。

-   **TCBInfo**：这个结构描述了特定平台 TCB 组件（如 `CPUSVN`，即 CPU 安全版本号）的各种组合及其对应的安全状态（如 “UpToDate”、“OutOfDate” 等）。当 Intel 发布安全公告并提供微码更新后，他们会发布新的 TCVInfo，将旧的、有漏洞的 `CPUSVN` 标记为 “OutOfDate”。
-   **验证策略**：远程验证者的策略必须是：当收到的引用中所报告的平台 TCB 版本在最新的 TCBInfo 中被标记为 “OutOfDate” 时，必须拒绝该引用。
-   **滚动更新的挑战**：这给服务运营商带来了运维上的挑战。假设一个服务由 $N=10$ 个 TEE 实例组成，并要求至少有 $q=7$ 个实例同时可用才能维持服务。在安全更新后，所有实例的微码都已过时。如果运营商立即在验证服务器上启用新的 TCBInfo 并强制执行新策略，所有 10 个实例的证明都会失败，导致服务中断。正确的做法是：
    1.  继续使用旧策略，同时以小批量（例如，批次大小 $b \le N-q=3$）的方式对 TEE 实例进行微码更新。
    2.  等待至少 $q=7$ 个实例完成更新并通过了新版微码的证明。
    3.  此时，在验证服务器上切换到新策略。由于已有 7 个实例符合新标准，服务得以维持。
    4.  继续更新剩余的实例。
    这个过程展示了 TEE 安全运维的复杂性，它需要在保证安全性和维持服务可用性之间进行精细的权衡。

#### 维持状态：密封机制

飞地是无状态的，其内存在关机后即消失。为了让飞地能够安全地持久化敏感数据（如密钥、配置或状态），TEE 提供了**密封（Sealing）**机制。密封是指使用一个只有当前平台上的特定飞地才能派生出的密钥来加密数据。

这个密封密钥派生自一个 CPU 内部独一无二的主密钥（`K_master`），并通过一个**密钥派生函数（Key Derivation Function, KDF）**生成 。派生过程的输入（即 KDF 的“盐”）决定了密钥的范围，主要有两种策略：

1.  **基于 MRENCLAVE 的策略**：密封密钥与飞地的**代码度量值（`MRENCLAVE`）**绑定。这意味着只有代码完全一模一样的飞地才能派生出相同的密钥来解封数据。这种策略提供了最严格的绑定，适用于当数据格式与代码逻辑紧密耦合，任何代码变更都可能导致数据误解的场景。例如，在一次重大的软件重构后，为了防止新代码错误地处理旧格式的状态数据，就应该使用此策略。

2.  **基于 MRSIGNER 的策略**：密封密钥与飞地的**签名者身份（`MRSIGNER`）**绑定。`MRSIGNER` 是对用于签署飞地的公钥的哈希。只要飞地由同一个开发者（拥有相同的签名私钥）签名，即使代码不同（`MRENCLAVE` 不同），它们也能派生出相同的密钥。为了防止降级攻击（即用一个旧的、有漏洞版本的飞地去解封新版本创建的数据），该策略还与**ISV 安全版本号（`ISVSVN`）**相结合。硬件会确保只有 `ISVSVN` 大于或等于数据密封时所用 `ISVSVN` 的飞地才能解封数据。这提供了**仅向前的兼容性**，非常适合需要进行滚动升级的场景，例如，一个新版本的 CPS [数字孪生](@entry_id:171650)需要能够读取并迁移上一版本留下的状态。

### 局限性与高级主题：[侧信道](@entry_id:754810)的现实

尽管 TEE 提供了强大的硬件隔离，但其安全边界并非无懈可击。信息可以通过意想不到的“[侧信道](@entry_id:754810)”泄露。一个典型的例子是**基于页错误的[侧信道攻击](@entry_id:275985)（Page-Fault Side-Channel）** 。

如前所述，特权操作系统控制着[页表](@entry_id:753080)。虽然它无法读取飞地的加密内存，但它可以控制哪些内存页“在场”（present）。恶意操作系统可以故意将飞地的所有代码页都标记为“不在场”。当飞地执行时，它会按其[控制流](@entry_id:273851)顺序访问这些代码页。每次访问一个不在场的页面，都会触发一个**页错误**，将控制权交还给操作系统。操作系统通过观察发生页错误的虚拟地址，就能得知飞地刚刚访问了哪个代码页。

考虑一个在飞地中实现的卡尔曼滤波器。该滤波器包含一个门控逻辑：如果传入的测量值与预测值的马氏距离 $d^2$ 在阈值 $\tau$ 之内，则执行状态更新（代码位于页面 $P_g$）；否则，跳过更新（代码位于页面 $P_s$）。恶意操作系统通过操纵[页表](@entry_id:753080)，可以观察到在每次迭代中是 $P_g$ 还是 $P_s$ 先被访问，从而以很高的[概率推断](@entry_id:1130186)出秘密的内部决策分支（即 $d^2 \le \tau$ 是否成立）。

我们可以将此过程形式化为一个贝叶斯决策问题。设秘密分支为 $B \in \{1, 0\}$（1 代表更新，0 代表跳过），其先验概率为 $\Pr(B=1) = p$。操作系统观察到的页错误为 $Z \in \{g, s\}$。由于[微架构](@entry_id:751960)的复杂性（如[乱序执行](@entry_id:753020)），观察存在噪声，由条件概率 $\Pr(Z|B)$ 描述。对手的目标是根据观察 $Z$ 估计 $\hat{B}$，并最小化[错误概率](@entry_id:267618) $P_{err}$。通过计算后验概率或似然比 $\Lambda(Z) = \frac{\Pr(Z|B=1)}{\Pr(Z|B=0)}$，对手可以构建一个**最大后验（MAP）**决策规则：
$$
\hat{B}(Z) = \begin{cases}
1,  \text{if } \Lambda(Z) > \frac{1-p}{p} \\
0,  \text{otherwise}
\end{cases}
$$
这个例证深刻地表明，TEE 的安全模型主要保护的是数据的**内容**，而对访问模式、时间等**[元数据](@entry_id:275500)**的保护则要弱得多。这些元数据泄露构成了持续的研究领域和现实的威胁，要求 TEE 应用的开发者必须编写能够抵御[侧信道攻击](@entry_id:275985)的代码，例如，通过将不同分支的代码布局在同一页面上来混淆页访问模式。