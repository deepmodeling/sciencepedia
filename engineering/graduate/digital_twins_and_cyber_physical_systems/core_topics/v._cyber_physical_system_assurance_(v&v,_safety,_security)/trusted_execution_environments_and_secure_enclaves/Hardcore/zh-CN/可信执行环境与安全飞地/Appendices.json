{
    "hands_on_practices": [
        {
            "introduction": "深入理解可信执行环境（TEE）不仅需要掌握其安全保证，还需要量化其资源成本。本练习将引导您计算可信执行环境的一个基本开销——用于管理安全内存的元数据所占用的空间。通过这个计算，您将能具体理解在类似Intel SGX的TEE中，安全隔离并非“免费”的，它需要固定的硬件资源，这对于资源受限的边缘设备尤为重要。",
            "id": "4252373",
            "problem": "一个信息物理系统（CPS）边缘节点在可信执行环境（TEE）中托管一个数字孪生，以保护状态估计和控制计算的完整性和机密性。TEE 使用一个安全 enclave 抽象，其中包含一个用于存放 enclave 内代码和数据的 Enclave 页面缓存（EPC），以及一个用于跟踪每个 EPC 页面所有权和访问属性的 Enclave 页面缓存映射表（EPCM）。EPC 的容量固定为 $128\\ \\mathrm{MiB}$，EPC 页面大小为 $4\\ \\mathrm{KiB}$，EPCM 为每个 EPC 页面存储 $64\\ \\mathrm{bytes}$ 的元数据。仅使用二进制单位的基本定义和基于页面的计算方法，推导 EPCM 元数据占用空间（以 mebibyte 为单位）。\n\n假设和基本定义：\n- 一 mebibyte 等于 $1\\ \\mathrm{MiB} = 2^{20}\\ \\mathrm{bytes}$。\n- 一 kibibyte 等于 $1\\ \\mathrm{KiB} = 2^{10}\\ \\mathrm{bytes}$。\n- EPC 页面的数量由 EPC 总容量除以页面大小得出。\n- EPCM 占用空间等于 EPC 页面数量乘以每个页面的元数据大小。\n\n以 $\\mathrm{MiB}$ 为单位表示最终结果。无需四舍五入。此外，从第一性原理出发，解释此元数据占用空间如何影响在 TEE 内执行的内存受限的 CPS 工作负载，特别是对于必须在固定大小的 EPC 内运行并保持可预测延迟的硬实时任务；您的讨论应基于推导出的占用空间和内存受限行为，而不涉及未经测试或专有的机制。",
            "solution": "问题陈述经评估有效。它在科学上基于计算机体系结构和可信执行环境的原理，问题提出得当，数据充分且一致，表述客观。\n\n解答过程分为两部分：首先，推导 Enclave 页面缓存映射表（EPCM）的占用空间；其次，解释其对信息物理系统（CPS）工作负载的影响。\n\n**第 1 部分：EPCM 元数据占用空间的推导**\n\n设 $C_{EPC}$ 表示 Enclave 页面缓存（EPC）的总容量，$S_{page}$ 表示单个 EPC 页面的大小，$S_{meta}$ 表示 EPCM 中为每个 EPC 页面存储的元数据的大小。\n\n给定值为：\n- $C_{EPC} = 128\\ \\mathrm{MiB}$\n- $S_{page} = 4\\ \\mathrm{KiB}$\n- $S_{meta} = 64\\ \\mathrm{bytes}$\n\n二进制单位的基本定义为：\n- $1\\ \\mathrm{MiB} = 2^{20}\\ \\mathrm{bytes}$\n- $1\\ \\mathrm{KiB} = 2^{10}\\ \\mathrm{bytes}$\n\n首先，我们必须将所有量表示为一个共同的基本单位，即字节（bytes）。\n\nEPC 容量（以字节为单位）为：\n$$C_{EPC} = 128 \\times (1\\ \\mathrm{MiB}) = 2^{7} \\times 2^{20}\\ \\mathrm{bytes} = 2^{27}\\ \\mathrm{bytes}$$\n\nEPC 页面大小（以字节为单位）为：\n$$S_{page} = 4 \\times (1\\ \\mathrm{KiB}) = 2^{2} \\times 2^{10}\\ \\mathrm{bytes} = 2^{12}\\ \\mathrm{bytes}$$\n\n每个页面的元数据大小已按字节给出：\n$$S_{meta} = 64\\ \\mathrm{bytes} = 2^{6}\\ \\mathrm{bytes}$$\n\nEPC 页面的总数（记为 $N_{pages}$）由 EPC 总容量除以单个页面的大小确定，如问题假设中所述。\n$$N_{pages} = \\frac{C_{EPC}}{S_{page}} = \\frac{2^{27}\\ \\mathrm{bytes}}{2^{12}\\ \\mathrm{bytes}} = 2^{(27-12)} = 2^{15}$$\n因此，EPC 中有 $2^{15} = 32768$ 个页面。\n\nEPCM 的总占用空间（记为 $F_{EPCM}$）是 EPC 页面数量乘以每个页面的元数据大小。\n$$F_{EPCM} = N_{pages} \\times S_{meta} = 2^{15} \\times 2^{6}\\ \\mathrm{bytes} = 2^{(15+6)}\\ \\mathrm{bytes} = 2^{21}\\ \\mathrm{bytes}$$\n\n问题要求以 mebibytes（$\\mathrm{MiB}$）为单位表示最终结果。要将 EPCM 占用空间从字节转换为 $\\mathrm{MiB}$，我们将其除以一 mebibyte 中的字节数。\n$$F_{EPCM\\ (\\mathrm{in\\ MiB})} = \\frac{F_{EPCM}}{1\\ \\mathrm{MiB}} = \\frac{2^{21}\\ \\mathrm{bytes}}{2^{20}\\ \\mathrm{bytes/MiB}} = 2^{(21-20)}\\ \\mathrm{MiB} = 2^{1}\\ \\mathrm{MiB} = 2\\ \\mathrm{MiB}$$\nEPCM 元数据占用空间恰好为 $2\\ \\mathrm{MiB}$。\n\n**第 2 部分：对内存受限的 CPS 工作负载的影响**\n\n从第一性原理出发，推导出的 $2\\ \\mathrm{MiB}$ 的 EPCM 占用空间对内存受限的 CPS 工作负载有直接且显著的影响，特别是那些具有硬实时要求的工作负载。\n\n1.  **固定的资源开销**：EPCM 是一个由硬件管理的数据结构，位于处理器预留内存中，与 EPC 本身分离。推导出的 $2\\ \\mathrm{MiB}$ 占用空间代表了固定的、静态的内存开销。这部分内存由 TEE 基础设施消耗，enclave 或系统上的任何其他软件都无法使用。为 TEE 机制保留的总物理内存是 EPC 和 EPCM 容量之和，在本例中为 $128\\ \\mathrm{MiB} + 2\\ \\mathrm{MiB} = 130\\ \\mathrm{MiB}$。虽然相对于 $128\\ \\mathrm{MiB}$ 的 EPC 而言，$2\\ \\mathrm{MiB}$ 的开销可能看起来很小，但这是提供安全保障所必须付出的、不可协商的代价。\n\n2.  **有限的 EPC 瓶颈**：对于在 TEE 内部运行的硬实时任务，例如为关键控制回路执行状态估计的数字孪生，可预测的延迟至关重要。为实现这一点，任务的整个工作集（代码和数据）必须驻留在固定大小的 EPC（$128\\ \\mathrm{MiB}$）内。这可以防止一类与内存访问相关的非确定性延迟。\n\n3.  **安全分页与延迟灾难**：如果工作负载是内存受限的——即其内存需求超过了 EPC 容量——CPU 必须采用一种称为安全分页（或交换）的机制。当 enclave 需要一个当前不在 EPC 中的页面时，必须将一个驻留页面驱逐到不受信任的主内存中。此过程包括：\n    - CPU 查询 EPCM 以确定要驱逐的候选页面。\n    - 在将页面内容写入主 RAM 之前，对其进行加密并生成完整性保护标签（例如，MAC）。\n    - 页面换出后，从主 RAM 加载所需的页面。\n    - 解密传入的页面并验证其完整性标签。\n    - 用新页面的状态和位置更新 EPCM。\n\n4.  **违反实时性保证**：每次安全页面的换入/换出操作都涉及由处理器的微码或硬件逻辑执行的计算密集型加密功能。这会在执行路径中引入极高且（至关重要的是）可变的延迟。对于硬实时系统，其中控制决策必须在严格的截止时间（例如，毫秒级）内做出，这种不可预测的延迟是灾难性的。单次页面错误就可能导致错过截止时间，从而可能导致 CPS 系统不稳定或物理故障。\n\n总之，EPCM 是实现对有限 EPC 进行管理的机制。其自身的 $2\\ \\mathrm{MiB}$ 占用空间量化了提供安全、隔离的执行环境所需的部分静态资源成本。对于硬实时 CPS 工作负载而言，其根本限制在于严格要求其整个内存工作集必须完全容纳在 EPC 内，以避免安全分页带来的灾难性的、非确定性的延迟惩罚，而这种行为正是由 CPU 使用 EPCM 直接管理的。因此，EPC 的有限大小是决定在 TEE 内部署给定实时任务可行性的主要制约因素。",
            "answer": "$$\n\\boxed{2}\n$$"
        },
        {
            "introduction": "除了静态的内存开销，在可信执行环境中运行代码还会引入动态的性能成本。由于安全区（enclave）与外部世界隔离，处理中断等外部事件会强制执行一次昂贵的上下文切换，即异步安全区退出（AEX）。本练习旨在帮助您量化这些中断在实时控制周期内累积造成的最大延迟，这对于评估TEE在网络物理系统等时间敏感应用中的可行性至关重要。",
            "id": "4252420",
            "problem": "一个信息物理系统 (CPS) 数字孪生控制器在一个可信执行环境 (TEE) 中执行，例如英特尔软件防护扩展 (SGX)。在此环境中，任何外部中断都会导致一次异步飞地退出 (AEX)，之后控制器恢复执行。控制器的操作控制周期长度为 $T_{p} = 10\\,\\text{ms}$。中断过程是速率受限的：中断之间的最小到达间隔时间为 $1/\\lambda$，其中 $\\lambda$ 是最大中断速率。每次 AEX 处理都会在执行恢复前引入一个大小为 $c$ 的额外延迟。\n\n假设如下：\n- 中断速率界限为 $\\lambda = 1\\,\\text{kHz}$，意味着最小到达间隔时间为 $1/\\lambda$。\n- 每次中断的 AEX 处理延迟预算为 $c = 8\\,\\mu\\text{s}$。\n- 用于计算中断的控制周期窗口为半开区间 $[0, T_{p})$，并且中断可能在此窗口内以对抗性的方式排列。\n\n从速率受限到达过程的定义和时间窗口计数论证出发，推导在窗口 $[0, T_{p})$ 内可能发生的最坏情况下的中断次数，并由此计算单个控制周期内仅由 AEX 处理引起的最坏情况下的附加延迟。将您的最终答案表示为以微秒为单位的单个实数。不要四舍五入；请提供精确值。",
            "solution": "用户希望确定在单个控制周期内最坏情况下的中断次数以及由异步飞地退出 (AEX) 产生的总附加延迟。\n\n首先，我们必须验证问题陈述。\n\n### 步骤 1：提取给定条件\n-   控制周期：$T_{p} = 10\\,\\text{ms}$\n-   最大中断速率：$\\lambda = 1\\,\\text{kHz}$\n-   中断之间的最小到达间隔时间：$1/\\lambda$\n-   每次中断的 AEX 处理延迟：$c = 8\\,\\mu\\text{s}$\n-   用于计算中断的控制周期窗口：$[0, T_{p})$\n-   中断可能在此窗口内以对抗性的方式排列。\n\n### 步骤 2：使用提取的给定条件进行验证\n该问题在实时系统和计算机体系结构领域具有科学依据，特别是与可信执行环境相关。控制周期、速率受限中断和事件处理延迟等概念都是标准概念。提供的数值（$T_p = 10\\,\\text{ms}$、$\\lambda = 1\\,\\text{kHz}$、$c=8\\,\\mu\\text{s}$）在物理上是合理的，并且与现代计算硬件一致。该问题是适定的，因为它要求基于一个明确定义的模型（半开时间区间内的速率受限到达）进行最坏情况分析，这会导出一个唯一的、可推导的解。语言客观而精确。不存在科学、逻辑或事实上的矛盾。该问题是完整且自洽的。\n\n### 步骤 3：结论与行动\n问题是有效的。我们将继续进行求解。\n\n问题是要求解在持续时间为 $T_p$ 的时间窗口内可能发生的最坏情况下的中断次数，我们将其表示为 $N_{max}$。该窗口是半开区间 $[0, T_p)$。中断是速率受限到达过程的一部分，其中任意两个连续中断之间的最小时间间隔为 $T_{min} = 1/\\lambda$。\n\n为了找到最坏情况下的中断次数，我们必须考虑在给定约束下可能的最密集的中断排列。这种情况发生在第一次中断发生在区间的最初始时刻，并且后续中断以允许的最快速度到达，即间隔恰好为 $T_{min}$。这就是问题中提到的“对抗性排列”。\n\n设中断的到达时间为 $t_0, t_1, t_2, \\dots$。对于最坏情况，我们将第一次中断置于最早的可能时刻 $t_0 = 0$。后续的中断将发生在 $t_1 = T_{min}$，$t_2 = 2T_{min}$，并且一般地，第 $k$ 次中断（使用从0开始的索引）发生在时间 $t_k = k \\cdot T_{min}$。\n\n为了使时间 $t_k$ 发生的中断被计数，它必须落在指定的区间 $[0, T_p)$ 内。这施加了条件：\n$$0 \\le t_k  T_p$$\n代入我们的 $t_k$ 表达式：\n$$k \\cdot T_{min}  T_p$$\n这等价于：\n$$k  \\frac{T_p}{T_{min}}$$\n由于 $k$ 必须是一个非负整数（$k=0, 1, 2, \\dots$），我们需要找到满足此不等式的非负整数的数量。这个数量将给我们最大中断次数 $N_{max}$。满足 $k  X$ 的非负整数 $k$ 的数量由向上取整函数（ceiling function）$\\lceil X \\rceil$ 给出。因此，最大中断次数为：\n$$N_{max} = \\left\\lceil \\frac{T_p}{T_{min}} \\right\\rceil$$\n\n现在，我们代入给定值。控制周期为 $T_p = 10\\,\\text{ms} = 10 \\times 10^{-3}\\,\\text{s}$。\n最大中断速率为 $\\lambda = 1\\,\\text{kHz} = 1000\\,\\text{s}^{-1}$。\n最小到达间隔时间为 $T_{min} = 1/\\lambda = 1 / (1000\\,\\text{s}^{-1}) = 10^{-3}\\,\\text{s} = 1\\,\\text{ms}$。\n\n我们现在可以计算比率 $T_p/T_{min}$：\n$$\\frac{T_p}{T_{min}} = \\frac{10 \\times 10^{-3}\\,\\text{s}}{1 \\times 10^{-3}\\,\\text{s}} = 10$$\n使用这个值，我们求得最坏情况下的中断次数：\n$$N_{max} = \\lceil 10 \\rceil = 10$$\n为了验证这一点，对抗性的中断时间将是 $0\\,\\text{ms}$，$1\\,\\text{ms}$，$2\\,\\text{ms}$，$\\dots$，$9\\,\\text{ms}$。下一次中断将发生在 $10\\,\\text{ms}$，这不在区间 $[0, 10\\,\\text{ms})$ 内。这证实了在最坏情况下恰好有10次中断。\n\n问题接着要求计算单个控制周期内由 AEX 处理引起的最坏情况下的附加延迟。$N_{max}$ 次中断中的每一次都会引入 $c = 8\\,\\mu\\text{s}$ 的延迟。最坏情况下的总延迟 $L_{max}$ 是中断次数与每次中断延迟的乘积。\n$$L_{max} = N_{max} \\cdot c$$\n代入我们已有的值：\n$$L_{max} = 10 \\cdot 8\\,\\mu\\text{s} = 80\\,\\mu\\text{s}$$\n最坏情况下的附加延迟是 $80$ 微秒。最终答案应表示为以微秒为单位的单个实数。",
            "answer": "$$\n\\boxed{80}\n$$"
        },
        {
            "introduction": "即使代码和数据位于受保护的安全区内存中，攻击者仍可能通过侧信道攻击窃取机密信息。一个典型的例子是，程序的内存访问模式会因处理的秘密数据不同而变化，从而泄露信息。本练习将通过一个实际的编码任务，教您一种关键的防御技术——数据无感知编程，即编写执行路径和内存访问模式不依赖于秘密输入的恒定时间代码。",
            "id": "4252350",
            "problem": "一个在可信执行环境（TEE）中执行的系统，必须对一个模拟信息物理数字孪生状态变量的数据流进行阈值事件评估。设输入为一个有限实数序列 $x = (x_0, x_1, \\dots, x_{n-1})$ 和一个公开的阈值 $t \\in \\mathbb{R}$。目标输出是一个二进制序列 $y \\in \\{0,1\\}^n$，其中对于每个索引 $i \\in \\{0,1,\\dots,n-1\\}$，元素 $y_i$ 编码了 $x_i$ 是否达到或超过阈值，具体为：如果 $x_i \\ge t$ 则 $y_i = 1$，否则 $y_i = 0$。一个常规的基于分支的例程通过从 $0$ 到 $n-1$ 迭代 $i$ 并对每个元素执行一次条件分支来计算 $y$。在常数时间实现的约束下，该例程必须被重写为数据无感知的，以使其执行时间和内存访问模式不依赖于秘密输入 $x$。假设在一个泄露模型中，对手只观察对输出数组进行写操作的内存地址序列（对手既不观察写入的实际数据值，也不观察寄存器内容，并且指令时间被理想化为与数据无关），同时阈值 $t$ 是公开的，而输入 $x$ 是秘密的。\n\n从存在内存访问模式泄露情况下的数据无感知和常数时间编程的基本定义出发，将基于分支的阈值处理例程重写为数据无感知的等效版本。证明在给定的泄露模型下，重写后例程的泄露受限于固定的内存访问模式，因此与 $x$ 无关。然后，实现基于分支的例程（仅在真分支上写入，否则跳过写入，并假设输出数组已预先初始化为零）和数据无感知的例程（在每个索引处都执行写入），并在以下测试套件上比较它们的输出和泄露特性。\n\n使用如下定义的泄露函数 $\\mathcal{L}$。对于一个程序 $P$ 和输入 $(x,t)$，泄露轨迹 $\\mathcal{L}_P(x,t)$ 是 $P$ 处理 $(x,t)$ 时写入的输出数组索引的序列。例如，如果 $P$ 按升序在索引 $i \\in S \\subseteq \\{0,1,\\dots,n-1\\}$ 处写入，那么 $\\mathcal{L}_P(x,t)$ 就是这些索引的有序列表。设最坏情况泄露边界（以比特为单位）为程序 $P$ 在所有固定长度为 $n$ 的可能输入上可以产生的不同泄露轨迹数量的以 2 为底的对数，即 $\\log_2 |\\{\\mathcal{L}_P(x,t) : x \\in \\mathbb{R}^n\\}|$。\n\n实现一个程序，对每个测试用例计算并返回以下结果列表：\n- 一个布尔值，指示基于分支的例程和数据无感知的例程是否产生相同的输出 $y$。\n- 一个整数，等于数据无感知例程执行的输出写入次数。\n- 一个整数，等于基于分支的例程执行的输出写入次数。\n- 一个整数，等于给定输入长度 $n$ 时，数据无感知例程的最坏情况泄露边界（以比特为单位）。\n- 一个整数，等于给定输入长度 $n$ 时，基于分支的例程的最坏情况泄露边界（以比特为单位）。\n\n测试套件由以下参数集 $(x,t)$ 组成：\n- 情况 1（一般情况）：$x = (0.1, 0.9, 0.5, 0.4999, 0.75, 0.0, 1.0, 0.33)$，$t = 0.5$。\n- 情况 2（边界条件，等于阈值）：$x = (0.7, 0.7, 0.7, 0.7, 0.7)$，$t = 0.7$。\n- 情况 3（边缘情况，空输入）：$x = ()$，$t = 0.5$。\n- 情况 4（边缘情况，阈值高于所有输入）：$x = (0.2, 0.1, 0.0, 0.3, 0.4, 0.25)$，$t = 10.0$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个用方括号括起来的逗号分隔列表。例如，输出格式必须严格符合以下形式\n$[ [r_{1,1}, r_{1,2}, r_{1,3}, r_{1,4}, r_{1,5}], [r_{2,1}, r_{2,2}, r_{2,3}, r_{2,4}, r_{2,5}], [r_{3,1}, r_{3,2}, r_{3,3}, r_{3,4}, r_{3,5}], [r_{4,1}, r_{4,2}, r_{4,3}, r_{4,4}, r_{4,5}] ]$\n其中每个 $r_{i,j}$ 是测试用例 $i$ 的指定布尔值或整数之一。",
            "solution": "该问题要求将一个标准的基于分支的阈值处理算法转换为一个数据无感知的等效算法，使其适用于内存访问模式可能成为信息泄露来源的可信执行环境（TEE）。我们将首先根据所提供的定义来形式化描述这些例程及其泄露属性，然后介绍针对指定测试用例的实现细节。\n\n设输入序列为 $x = (x_0, x_1, \\dots, x_{n-1}) \\in \\mathbb{R}^n$，公开阈值为 $t \\in \\mathbb{R}$。目标是计算输出序列 $y = (y_0, y_1, \\dots, y_{n-1}) \\in \\{0,1\\}^n$，其中如果 $x_i \\ge t$ 则 $y_i = 1$，否则 $y_i = 0$。输入 $x$ 是秘密的。对手观察写入输出数组 $y$ 的索引序列。程序 $P$ 的泄露是轨迹 $\\mathcal{L}_P(x,t)$，定义为写入内存的索引的有序序列。对于固定的 $n$，最坏情况泄露边界为 $\\log_2|\\{\\mathcal{L}_P(x,t) : x \\in \\mathbb{R}^n\\}|$。\n\n数据无感知算法是指其内存访问模式与秘密数据无关的算法。在我们的情境中，这意味着对于给定长度 $n$ 的所有秘密输入 $x$，写入索引序列 $\\mathcal{L}_P(x,t)$ 必须相同。\n\n**1. 基于分支的（不安全）例程**\n\n常规的、基于分支的例程，我们记为 $P_b$，由以下逻辑描述。输出数组 $y$ 被预初始化为全零。\n`for i from 0 to n-1:`\n`  if x[i] = t:`\n`    y[i] = 1`\n\n只有当条件 $x_i \\ge t$ 为真时，才会对与 $y_i$ 对应的内存位置进行写入。由于 $x$ 是秘密的，这个条件依赖于秘密数据。\n\n$P_b$ 的泄露分析：\n泄露轨迹 $\\mathcal{L}_{P_b}(x,t)$ 由满足 $x_i \\ge t$ 的索引 $i$ 的有序序列组成。设 $S_x = \\{i \\in \\{0, \\dots, n-1\\} \\mid x_i \\ge t\\}$。那么 $\\mathcal{L}_{P_b}(x,t)$ 就是 $S_x$ 中元素按升序排列的序列。\n\n为了确定最坏情况的泄露，我们必须计算可能出现的不同泄露轨迹的数量。对于任意索引子集 $S \\subseteq \\{0, \\dots, n-1\\}$，我们可以构造一个输入 $x \\in \\mathbb{R}^n$ 使得 $S_x = S$。例如，可以为所有 $i \\in S$ 定义 $x_i = t+1$，为所有 $i \\notin S$ 定义 $x_i = t-1$。由于 $t$ 是公开的，这样的 $x$ 总是可以被构造出来。\n所有可能的索引集的集合是 $\\{0, \\dots, n-1\\}$ 的幂集，它有 $2^n$ 个元素。这些子集中的每一个都对应一个唯一的、不同的泄露轨迹。\n因此，不同泄露轨迹的数量为 $|\\{\\mathcal{L}_{P_b}(x,t) : x \\in \\mathbb{R}^n\\}| = 2^n$。\n\n最坏情况泄露边界为 $\\log_2(2^n) = n$ 比特。这意味着对于每个位置 $i$，该例程泄露了一比特的信息，即 $x_i \\ge t$ 是否成立。该例程不是数据无感知的。对于 $n=0$ 的特殊情况，只有一个可能的输入（空序列）和一个轨迹（空轨迹），所以轨迹数量为 $1$，泄露为 $\\log_2(1) = 0$。\n\n**2. 数据无感知的（安全）例程**\n\n为了消除依赖于数据的内存访问模式，算法必须被重写，以在每个索引 $i \\in \\{0, \\dots, n-1\\}$ 处都执行写操作，而不管 $x$ 中的值如何。这就是数据无感知执行的原则。写入的值仍然可以依赖于数据，但对于给定的循环迭代，写入的位置必须是固定的。这将依赖于数据的控制流转换为依赖于数据的值计算。\n\n布尔表达式 $x_i \\ge t$ 的值为真或假。在大多数编程环境中，这可以转换为一个整数，真为 $1$，假为 $0$。我们记为 $P_{do}$ 的数据无感知例程可以表示为：\n`for i from 0 to n-1:`\n`  y[i] = int(x[i] = t)`\n\n该例程为从 $0$ 到 $n-1$ 的每个 $i$ 向 $y_i$ 写入一个值。写入的值正是期望的输出（如果 $x_i \\ge t$ 则为 $1$，否则为 $0$），因此功能正确性得以保持。\n\n**3. 数据无感知例程的安全性证明**\n\n我们现在证明，在给定的泄露模型下，重写后的例程 $P_{do}$ 是数据无感知的，并且其泄露与秘密输入 $x$ 无关。\n\n证明：\n例程 $P_{do}$ 以索引 $i$ 从 $0$ 迭代到 $n-1$。在每次迭代 $i$ 中，它都精确地对输出数组中与索引 $i$ 对应的位置执行一次写操作。因此，写入索引的序列确定性地为 $(0, 1, \\dots, n-1)$。\n\n泄露轨迹为 $\\mathcal{L}_{P_{do}}(x,t) = (0, 1, \\dots, n-1)$。对于任何输入 $x \\in \\mathbb{R}^n$ 和任何阈值 $t \\in \\mathbb{R}$，此轨迹都是相同的。内存访问序列是固定的，仅取决于输入的长度 $n$，而与其值无关。\n\n所有可能的泄露轨迹集合是 $\\{\\mathcal{L}_{P_{do}}(x,t) : x \\in \\mathbb{R}^n\\} = \\{(0, 1, \\dots, n-1)\\}$。该集合只包含一个元素。\n该集合的基数为 $1$。\n\n因此，对于任何 $n \\ge 0$，最坏情况泄露边界为 $\\log_2(1) = 0$ 比特。$0$ 比特的泄露意味着对手通过观察内存写入模式无法获得关于秘密输入 $x$ 的任何信息。这证明了重写的例程在指定的泄露模型下是数据无感知的。\n\n**4. 实现与评估**\n\n使用两种例程的实现来评估所提供的测试用例。\n\n- **`branch_based_threshold(x, t)`**：实现 $P_b$。它初始化一个全零数组，并有条件地写入 1，同时计算写入次数。\n- **`data_oblivious_threshold(x, t)`**：实现 $P_{do}$。它使用向量化操作来计算结果，这等效于数据无感知的循环。写入次数始终等于输入长度 $n$。\n\n每个测试用例的结果计算如下：\n- **输出比较**：一个布尔值，指示两种例程的最终数组 `y` 是否相同。\n- **数据无感知写入次数**：始终为 $n$。\n- **基于分支的写入次数**：$x$ 中满足 $x_i \\ge t$ 的元素数量。\n- **数据无感知泄露边界**：始终为 $0$。\n- **基于分支的泄露边界**：$n$。",
            "answer": "[[True,8,4,0,8],[True,5,5,0,5],[True,0,0,0,0],[True,6,0,0,6]]"
        }
    ]
}