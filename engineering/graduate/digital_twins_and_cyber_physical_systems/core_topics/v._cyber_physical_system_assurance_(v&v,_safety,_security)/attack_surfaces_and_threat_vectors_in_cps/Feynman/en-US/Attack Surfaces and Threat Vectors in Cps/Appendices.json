{
    "hands_on_practices": [
        {
            "introduction": "An attack on a sensor provides a direct vector for an adversary to manipulate a system's perception of the physical world. This exercise puts you in the role of an attacker aiming to create a stealthy spoofing signal. By modeling the physical dynamics of a thermal system and the response characteristics of its sensor, you will derive the precise signal needed to make the system's digital twin perceive a false, but physically plausible, temperature profile . This practice demonstrates how fundamental knowledge of system dynamics is crucial for both designing and defending against sophisticated attacks.",
            "id": "4206240",
            "problem": "A heated chamber in a Cyber-Physical System (CPS) is modeled as a lumped thermal mass monitored by a temperature sensor. The digital twin receives a temperature stream through the sensor channel, which is vulnerable to sensor spoofing. An adversary aims to inject a spoof signal to make the digital twin’s received temperature trajectory match a physically plausible heat-up profile over a warm-up interval, exploiting the attack surface exposed by the sensor interface.\n\nThe chamber has mass $m$, specific heat $c_p$, ambient temperature $T_a$, and an aggregate heat-loss coefficient $k$ (e.g., $k = hA$ for convection across area $A$ with coefficient $h$). The actuator applies a constant heating power $P$ (actual), and the target profile to be mimicked corresponds to a constant heating power $P^{\\star}$ (target). The first law of thermodynamics for a lumped system yields the energy balance\n$$\nm c_p \\frac{dT(t)}{dt} = P - k\\big(T(t) - T_a\\big),\n$$\nwith initial condition $T(0) = T_a$. Define the thermal time constant $\\tau_{th} = \\frac{m c_p}{k}$.\n\nThe temperature sensor is modeled as a first-order linear time-invariant transfer function with gain $k_s$ (volts per kelvin) and time constant $\\tau_s$, governed in the time domain by\n$$\n\\tau_s \\frac{dy(t)}{dt} + y(t) = k_s T(t),\n$$\nwith initial condition $y(0) = k_s T(0)$. The digital signal consumed by the twin is\n$$\nr(t) = y(t) + s(t),\n$$\nwhere $s(t)$ is the attacker’s additive spoof signal injected post-sensor.\n\nThe adversary’s goal is to choose $s(t)$ such that $|r(t) - y^{\\star}(t)| \\leq \\epsilon$ for all $t \\in [0, t_f]$, where $t_f > 0$ is the duration of interest. Let $T^{\\star}(t)$ solve the energy balance with $P^{\\star}$ and $T^{\\star}(0) = T_a$, and let $y^{\\star}(t)$ solve the sensor dynamics with input $T^{\\star}(t)$ and $y^{\\star}(0) = k_s T_a$. Assume $\\tau_{th} \\neq \\tau_s$ and $t \\geq 0$.\n\nStarting only from the energy balance and the sensor differential equations above, derive the closed-form expression for the required spoof signal $s(t)$ that achieves $|r(t) - y^{\\star}(t)| \\leq \\epsilon$ for all $t \\in [0, t_f]$ by exact tracking (that is, by choosing $r(t) \\equiv y^{\\star}(t)$). Express the final answer for $s(t)$ in volts as a function of $t$ (in seconds), and do not perform any numerical rounding.",
            "solution": "The user wants me to find the required spoof signal, $s(t)$, that an adversary must inject to make the received temperature signal, $r(t)$, match a target trajectory, $y^{\\star}(t)$, exactly.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n- **System Dynamics (Chamber):** $m c_p \\frac{dT(t)}{dt} = P - k(T(t) - T_a)$\n- **Initial Condition (Chamber):** $T(0) = T_a$\n- **Parameters (Chamber):** Mass $m$, specific heat $c_p$, ambient temperature $T_a$, heat-loss coefficient $k$, actual heating power $P$, target heating power $P^{\\star}$.\n- **Definition (Thermal Time Constant):** $\\tau_{th} = \\frac{m c_p}{k}$\n- **System Dynamics (Sensor):** $\\tau_s \\frac{dy(t)}{dt} + y(t) = k_s T(t)$\n- **Initial Condition (Sensor):** $y(0) = k_s T(0)$\n- **Parameters (Sensor):** Gain $k_s$, time constant $\\tau_s$.\n- **Signal Model:** $r(t) = y(t) + s(t)$, where $s(t)$ is the spoof signal.\n- **Adversary Goal:** Achieve $|r(t) - y^{\\star}(t)| \\leq \\epsilon$ for $t \\in [0, t_f]$.\n- **Method:** Exact tracking, i.e., $r(t) = y^{\\star}(t)$.\n- **Target Trajectory:** $y^{\\star}(t)$ is the sensor output corresponding to the chamber being heated by $P^{\\star}$ instead of $P$. Specifically, $T^{\\star}(t)$ solves the chamber dynamics with power $P^{\\star}$ and initial condition $T^{\\star}(0) = T_a$, and $y^{\\star}(t)$ solves the sensor dynamics with input $T^{\\star}(t)$ and initial condition $y^{\\star}(0) = k_s T_a$.\n- **Constraint:** $\\tau_{th} \\neq \\tau_s$.\n- **Objective:** Find the closed-form expression for $s(t)$.\n\n**1.2. Validate Using Extracted Givens**\n- **Scientific Grounding:** The problem is based on the first law of thermodynamics (lumped-capacitance model) and first-order linear time-invariant (LTI) system models for sensors. These are standard, well-established models in engineering and physics. The context of sensor spoofing in Cyber-Physical Systems (CPS) is a realistic and critical area of study in cybersecurity.\n- **Well-Posedness:** The problem is mathematically well-posed. It involves solving a system of linear ordinary differential equations (ODEs) with specified initial conditions. All necessary parameters and relationships are defined. The objective is clearly stated, and the condition of exact tracking, $r(t) = y^{\\star}(t)$, removes any ambiguity, leading to a unique solution for $s(t)$. The constraint $\\tau_{th} \\neq \\tau_s$ is explicitly provided, which is necessary to avoid indeterminate forms in the solution, indicating careful construction.\n- **Objectivity:** The problem is stated in precise, objective, and mathematical language, free from any subjective or biased claims.\n\n**1.3. Verdict and Action**\nThe problem is valid. It is scientifically sound, well-posed, objective, and complete. I will proceed with deriving the solution.\n\n### Step 2: Derivation of the Spoof Signal $s(t)$\n\nThe goal is to find the spoof signal $s(t)$ that achieves exact tracking, i.e., $r(t) = y^{\\star}(t)$. From the definition of the received signal, $r(t) = y(t) + s(t)$, we can express the required spoof signal as:\n$$\ns(t) = y^{\\star}(t) - y(t)\n$$\nTo find $s(t)$, we must first find explicit expressions for the actual sensor output $y(t)$ and the target sensor output $y^{\\star}(t)$. This requires solving the underlying differential equations for the chamber temperature and then for the sensor response.\n\n**2.1. Solve for the Chamber Temperature $T(t)$**\nThe energy balance equation is:\n$$\nm c_p \\frac{dT(t)}{dt} = P - k\\big(T(t) - T_a\\big)\n$$\nUsing the definition $\\tau_{th} = \\frac{m c_p}{k}$, we can rewrite the equation as:\n$$\n\\tau_{th} \\frac{dT(t)}{dt} = \\frac{P}{k} - (T(t) - T_a)\n$$\n$$\n\\tau_{th} \\frac{dT(t)}{dt} + T(t) = \\frac{P}{k} + T_a\n$$\nThis is a standard first-order linear ODE. The solution consists of a homogeneous part and a particular (steady-state) part. The steady-state temperature, $T_{ss}$, is found by setting $\\frac{dT}{dt} = 0$, which gives $T_{ss} = \\frac{P}{k} + T_a$.\nThe general solution is of the form $T(t) = T_{ss} + C \\exp(-t/\\tau_{th})$. We find the constant $C$ using the initial condition $T(0) = T_a$:\n$$\nT_a = \\left(\\frac{P}{k} + T_a\\right) + C \\exp(0) \\implies C = -\\frac{P}{k}\n$$\nThus, the actual temperature trajectory is:\n$$\nT(t) = \\left(\\frac{P}{k} + T_a\\right) - \\frac{P}{k} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right) = T_a + \\frac{P}{k}\\left(1 - \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\\right)\n$$\nBy direct analogy, the target temperature trajectory $T^{\\star}(t)$, corresponding to heating power $P^{\\star}$, is:\n$$\nT^{\\star}(t) = T_a + \\frac{P^{\\star}}{k}\\left(1 - \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\\right)\n$$\n\n**2.2. Solve for the Sensor Output $y(t)$**\nThe sensor dynamics are given by:\n$$\n\\tau_s \\frac{dy(t)}{dt} + y(t) = k_s T(t)\n$$\nwith initial condition $y(0) = k_s T(0) = k_s T_a$. The forcing function is $k_s T(t) = k_s T_a + \\frac{k_s P}{k}\\left(1 - \\exp(-t/\\tau_{th})\\right)$. This is a first-order linear ODE for $y(t)$ with a forcing term composed of a constant and an exponential. The general solution is the sum of a homogeneous solution, $y_h(t) = A \\exp(-t/\\tau_s)$, and a particular solution, $y_p(t)$. Given the form of the forcing term, we seek a particular solution of the form $y_p(t) = B + C \\exp(-t/\\tau_{th})$. Substituting this into the ODE for $y(t)$:\n$$\n\\tau_s \\left(-\\frac{C}{\\tau_{th}} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\\right) + \\left(B + C \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\\right) = k_s T_a + \\frac{k_s P}{k} - \\frac{k_s P}{k} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\n$$\n$$\nB + C\\left(1 - \\frac{\\tau_s}{\\tau_{th}}\\right)\\exp\\left(-\\frac{t}{\\tau_{th}}\\right) = \\left(k_s T_a + \\frac{k_s P}{k}\\right) - \\frac{k_s P}{k} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\n$$\nBy equating coefficients of the constant and exponential terms (which is valid since $\\tau_{th} \\neq \\tau_s$):\n- Constant term: $B = k_s T_a + \\frac{k_s P}{k}$\n- Exponential term: $C\\left(1 - \\frac{\\tau_s}{\\tau_{th}}\\right) = -\\frac{k_s P}{k} \\implies C = -\\frac{k_s P/k}{1 - \\tau_s/\\tau_{th}} = -\\frac{k_s P \\tau_{th}}{k(\\tau_{th} - \\tau_s)}$\n\nThe general solution for $y(t)$ is:\n$$\ny(t) = A \\exp\\left(-\\frac{t}{\\tau_s}\\right) + k_s T_a + \\frac{k_s P}{k} - \\frac{k_s P \\tau_{th}}{k(\\tau_{th} - \\tau_s)} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\n$$\nUsing the initial condition $y(0) = k_s T_a$:\n$$\nk_s T_a = A + k_s T_a + \\frac{k_s P}{k} - \\frac{k_s P \\tau_{th}}{k(\\tau_{th} - \\tau_s)}\n$$\n$$\nA = \\frac{k_s P \\tau_{th}}{k(\\tau_{th} - \\tau_s)} - \\frac{k_s P}{k} = \\frac{k_s P}{k}\\left(\\frac{\\tau_{th}}{\\tau_{th} - \\tau_s} - 1\\right) = \\frac{k_s P}{k}\\left(\\frac{\\tau_{th} - (\\tau_{th} - \\tau_s)}{\\tau_{th} - \\tau_s}\\right) = \\frac{k_s P \\tau_s}{k(\\tau_{th} - \\tau_s)}\n$$\nSubstituting $A$ back, the full solution for the actual sensor output $y(t)$ is:\n$$\ny(t) = k_s T_a + \\frac{k_s P}{k} + \\frac{k_s P \\tau_s}{k(\\tau_{th} - \\tau_s)} \\exp\\left(-\\frac{t}{\\tau_s}\\right) - \\frac{k_s P \\tau_{th}}{k(\\tau_{th} - \\tau_s)} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\n$$\nThe target sensor output $y^{\\star}(t)$ follows the same form, with $P$ replaced by $P^{\\star}$:\n$$\ny^{\\star}(t) = k_s T_a + \\frac{k_s P^{\\star}}{k} + \\frac{k_s P^{\\star} \\tau_s}{k(\\tau_{th} - \\tau_s)} \\exp\\left(-\\frac{t}{\\tau_s}\\right) - \\frac{k_s P^{\\star} \\tau_{th}}{k(\\tau_{th} - \\tau_s)} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\n$$\n\n**2.3. Compute the Spoof Signal $s(t)$**\nFinally, we compute $s(t) = y^{\\star}(t) - y(t)$. Subtracting the expression for $y(t)$ from that of $y^{\\star}(t)$, the $k_s T_a$ terms cancel. We can factor out the difference in power, $(P^{\\star} - P)$, from the remaining terms:\n$$\ns(t) = \\left(\\frac{k_s P^{\\star}}{k} - \\frac{k_s P}{k}\\right) + \\left(\\frac{k_s P^{\\star} \\tau_s}{k(\\tau_{th} - \\tau_s)} - \\frac{k_s P \\tau_s}{k(\\tau_{th} - \\tau_s)}\\right) \\exp\\left(-\\frac{t}{\\tau_s}\\right) - \\left(\\frac{k_s P^{\\star} \\tau_{th}}{k(\\tau_{th} - \\tau_s)} - \\frac{k_s P \\tau_{th}}{k(\\tau_{th} - \\tau_s)}\\right) \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\n$$\nFactoring out the common terms yields the final expression for the spoof signal:\n$$\ns(t) = \\frac{k_s(P^{\\star} - P)}{k} + \\frac{k_s(P^{\\star} - P)\\tau_s}{k(\\tau_{th} - \\tau_s)} \\exp\\left(-\\frac{t}{\\tau_s}\\right) - \\frac{k_s(P^{\\star} - P)\\tau_{th}}{k(\\tau_{th} - \\tau_s)} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right)\n$$\nThis can be written more compactly by factoring out the steady-state difference:\n$$\ns(t) = \\frac{k_s (P^{\\star} - P)}{k} \\left[ 1 + \\frac{\\tau_s}{\\tau_{th} - \\tau_s} \\exp\\left(-\\frac{t}{\\tau_s}\\right) - \\frac{\\tau_{th}}{\\tau_{th} - \\tau_s} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right) \\right]\n$$\nThis expression represents the signal in volts that the attacker must add to the true sensor output to perfectly mimic the target trajectory on the digital twin.",
            "answer": "$$\\boxed{\\frac{k_s (P^{\\star} - P)}{k} \\left[ 1 + \\frac{\\tau_s}{\\tau_{th} - \\tau_s} \\exp\\left(-\\frac{t}{\\tau_s}\\right) - \\frac{\\tau_{th}}{\\tau_{th} - \\tau_s} \\exp\\left(-\\frac{t}{\\tau_{th}}\\right) \\right]}$$"
        },
        {
            "introduction": "After understanding how attacks are crafted, the next logical step is to build defenses, starting with detection. This problem explores parity-space methods, a powerful technique that leverages sensor redundancy to detect anomalies. Your task is to construct a statistically sound detector and then analyze its fundamental limitations by investigating a \"stealthy\" threat vector . By proving that an attack aligned with the parity matrix's nullspace is invisible to the detector, you will uncover the critical concept of a detector's blind spots and learn why no single defense is foolproof.",
            "id": "4206276",
            "problem": "A Cyber-Physical System (CPS) is monitored by a redundant sensor suite. The measurement at a given sampling instant is modeled as $y \\in \\mathbb{R}^{m}$ with $y = H x + v + a$, where $x \\in \\mathbb{R}^{n}$ is the system state, $H \\in \\mathbb{R}^{m \\times n}$ is a known measurement sensitivity matrix, $v \\in \\mathbb{R}^{m}$ is zero-mean Gaussian noise with covariance $\\Sigma \\in \\mathbb{R}^{m \\times m}$ that is symmetric positive definite, and $a \\in \\mathbb{R}^{m}$ is an adversarial sensor attack vector in the measurement channel. A parity matrix $P \\in \\mathbb{R}^{p \\times m}$ with full row rank is given and satisfies the nulling property $P H = 0$.\n\nConstruct a parity-space detector by forming a residual that eliminates the nominal state influence and define a statistically sound scalar detection statistic using a whitened residual energy based on the noise covariance. Then, consider a stealthy threat vector aligned with the parity nullspace, specifically $a = \\epsilon a_{0}$ with $\\epsilon \\in \\mathbb{R}$ and $a_{0} \\in \\mathcal{N}(P)$, where $\\mathcal{N}(P)$ denotes the nullspace of $P$. Define the small-signal sensitivity of the detector to this attack direction as\n$$\nS \\triangleq \\lim_{\\epsilon \\to 0} \\frac{\\mathbb{E}\\!\\left[J(\\epsilon)\\right] - \\mathbb{E}\\!\\left[J(0)\\right]}{\\epsilon^{2}},\n$$\nwhere $J(\\epsilon)$ is the detector’s scalar statistic under attack amplitude $\\epsilon$ and $\\mathbb{E}[\\cdot]$ denotes expectation with respect to the measurement noise.\n\nStarting from the core definitions of parity relations in redundant measurement sets and standard properties of Gaussian noise and quadratic forms, derive $S$ in closed form as an analytic expression in terms of $P$, $\\Sigma$, and $a_{0}$. The final answer must be a single real number or closed-form expression. No rounding is required.",
            "solution": "The user wants to derive the small-signal sensitivity $S$ of a parity-space detector to a specific type of stealthy attack. The derivation will proceed in four main steps: 1) construction of the parity-space residual and the detection statistic, 2) calculation of the expected value of the statistic under attack, 3) derivation of the general sensitivity expression, and 4) evaluation of this expression for the specific attack defined in the problem.\n\nStep 1: Construct the Detector\nThe measurement model for the Cyber-Physical System (CPS) is given by\n$$y = H x + v + a$$\nwhere $y \\in \\mathbb{R}^{m}$ is the measurement vector, $x \\in \\mathbb{R}^{n}$ is the state vector, $H \\in \\mathbb{R}^{m \\times n}$ is the measurement matrix, $v \\in \\mathbb{R}^{m}$ is zero-mean Gaussian noise with covariance $\\Sigma = \\Sigma^T > 0$, and $a \\in \\mathbb{R}^{m}$ is an adversarial attack vector.\n\nA parity-space detector is constructed using a parity matrix $P \\in \\mathbb{R}^{p \\times m}$ that has the property $P H = 0$. This property ensures that the resulting signal is independent of the system state $x$. A residual vector $r \\in \\mathbb{R}^{p}$ is formed by projecting the measurement $y$ onto the parity space:\n$$r = P y = P(H x + v + a)$$\nUsing the property $P H = 0$, the expression for the residual simplifies to:\n$$r = P H x + P v + P a = 0 \\cdot x + P v + P a = P v + P a$$\nThe residual $r$ is a random vector whose statistics depend on the noise $v$ and the attack $a$. The mean of the residual is:\n$$\\mathbb{E}[r] = \\mathbb{E}[P v + P a] = P\\mathbb{E}[v] + P a = P \\cdot 0 + Pa = Pa$$\nThe covariance of the residual, denoted $\\Sigma_r$, is:\n$$\\Sigma_r = \\text{Cov}(r) = \\mathbb{E}\\left[(r-\\mathbb{E}[r])(r-\\mathbb{E}[r])^T\\right] = \\mathbb{E}\\left[(Pv)(Pv)^T\\right] = P\\mathbb{E}[vv^T]P^T = P \\Sigma P^T$$\nSince $P$ has full row rank and $\\Sigma$ is symmetric positive definite, $\\Sigma_r = P\\Sigma P^T$ is a $p \\times p$ symmetric positive definite matrix and is thus invertible.\n\nA statistically sound scalar detection statistic, $J$, is defined as the whitened energy of the residual. This corresponds to the squared Mahalanobis distance of the residual vector, which is given by:\n$$J = r^T \\Sigma_r^{-1} r = (Pv + Pa)^T (P\\Sigma P^T)^{-1} (Pv + Pa)$$\n\nStep 2: Calculate the Expected Value of the Statistic\nThe problem defines the attack as $a = \\epsilon a_0$, where $\\epsilon \\in \\mathbb{R}$ is the attack amplitude and $a_0 \\in \\mathbb{R}^m$ is the attack direction. The detection statistic as a function of $\\epsilon$ is:\n$$J(\\epsilon) = (Pv + \\epsilon Pa_0)^T (P\\Sigma P^T)^{-1} (Pv + \\epsilon Pa_0)$$\nTo analyze the sensitivity, we first find the expected value of $J(\\epsilon)$ with respect to the noise $v$. Let's expand the quadratic form:\n$$J(\\epsilon) = v^T P^T (P\\Sigma P^T)^{-1} P v + 2\\epsilon v^T P^T (P\\Sigma P^T)^{-1} P a_0 + \\epsilon^2 a_0^T P^T (P\\Sigma P^T)^{-1} P a_0$$\nTaking the expectation of each term:\n$$\\mathbb{E}[J(\\epsilon)] = \\mathbb{E}\\left[v^T P^T (P\\Sigma P^T)^{-1} P v\\right] + 2\\epsilon \\mathbb{E}\\left[v^T\\right] P^T (P\\Sigma P^T)^{-1} P a_0 + \\epsilon^2 a_0^T P^T (P\\Sigma P^T)^{-1} P a_0$$\nSince the noise is zero-mean, $\\mathbb{E}[v] = 0$, which implies $\\mathbb{E}[v^T] = 0^T = 0$. The middle term is therefore zero.\n$$\\mathbb{E}[J(\\epsilon)] = \\mathbb{E}\\left[v^T P^T (P\\Sigma P^T)^{-1} P v\\right] + \\epsilon^2 a_0^T P^T (P\\Sigma P^T)^{-1} P a_0$$\nThe first term is a scalar, so we can use the trace property $\\text{tr}(A) = A$ for a scalar $A$ and the linearity of expectation and trace, $\\mathbb{E}\\left[\\text{tr}(X)\\right] = \\text{tr}\\left(\\mathbb{E}[X]\\right)$.\n$$\\mathbb{E}\\left[v^T P^T (P\\Sigma P^T)^{-1} P v\\right] = \\mathbb{E}\\left[\\text{tr}\\left(v^T P^T (P\\Sigma P^T)^{-1} P v\\right)\\right] = \\mathbb{E}\\left[\\text{tr}\\left(P v v^T P^T (P\\Sigma P^T)^{-1}\\right)\\right]$$\n$$= \\text{tr}\\left(\\mathbb{E}\\left[P v v^T P^T (P\\Sigma P^T)^{-1}\\right]\\right) = \\text{tr}\\left(P \\mathbb{E}[v v^T] P^T (P\\Sigma P^T)^{-1}\\right)$$\nSince $\\mathbb{E}[v v^T] = \\Sigma$, this becomes:\n$$= \\text{tr}\\left(P \\Sigma P^T (P\\Sigma P^T)^{-1}\\right) = \\text{tr}(I_p) = p$$\nHere, $I_p$ is the $p \\times p$ identity matrix. This term is the expected value of the statistic in the absence of an attack, $\\mathbb{E}[J(0)] = p$.\n\nSubstituting this back, we get the expected value of the statistic under attack:\n$$\\mathbb{E}[J(\\epsilon)] = p + \\epsilon^2 (Pa_0)^T (P\\Sigma P^T)^{-1} (Pa_0)$$\n\nStep 3: Derive the General Sensitivity Expression\nThe small-signal sensitivity $S$ is defined as:\n$$S \\triangleq \\lim_{\\epsilon \\to 0} \\frac{\\mathbb{E}\\!\\left[J(\\epsilon)\\right] - \\mathbb{E}\\!\\left[J(0)\\right]}{\\epsilon^{2}}$$\nSubstituting the expressions for $\\mathbb{E}[J(\\epsilon)]$ and $\\mathbb{E}[J(0)]$:\n$$S = \\lim_{\\epsilon \\to 0} \\frac{\\left(p + \\epsilon^2 (Pa_0)^T (P\\Sigma P^T)^{-1} (Pa_0)\\right) - p}{\\epsilon^{2}}$$\n$$S = \\lim_{\\epsilon \\to 0} \\frac{\\epsilon^2 (Pa_0)^T (P\\Sigma P^T)^{-1} (Pa_0)}{\\epsilon^{2}}$$\nCanceling the $\\epsilon^2$ terms, we obtain the general expression for the sensitivity to an attack in the direction $a_0$:\n$$S = (Pa_0)^T (P\\Sigma P^T)^{-1} (Pa_0)$$\n\nStep 4: Evaluate for the Specific Stealthy Attack\nThe problem specifies a particular type of stealthy attack where the attack direction $a_0$ lies in the nullspace of the parity matrix $P$. This is stated as $a_0 \\in \\mathcal{N}(P)$. By the definition of the nullspace, for any vector $z \\in \\mathcal{N}(P)$, the product $Pz$ is the zero vector. Therefore, for the given attack direction $a_0$:\n$$P a_0 = 0$$\nThis condition signifies that the attack is designed to be perfectly nulled by the parity matrix $P$, making it invisible to the residual $r=Pv+Pa_0\\epsilon = Pv$.\n\nSubstituting this condition into the general expression for sensitivity $S$:\n$$S = (0)^T (P\\Sigma P^T)^{-1} (0)$$\nThe product of a zero vector with any matrix results in a zero vector or a zero scalar. Thus,\n$$S = 0$$\nThe sensitivity of the detector to an attack vector aligned with the nullspace of the parity matrix is zero. This result is logically consistent, as such an attack is, by definition of the parity-space detector, perfectly stealthy and generates no detectable signature in the residual.",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "The ultimate goal in CPS security is not just detection, but resilience—the ability of a system to function correctly despite being under attack. This final practice challenges you to build a resilient state estimator for a digital twin capable of tolerating a number of compromised sensors. You will apply advanced concepts from sparse recovery and convex optimization to formulate an estimator that can distinguish the true system state from a sparse set of malicious inputs . This capstone exercise bridges theory and practice by guiding you through the implementation of an attack-resilient estimation algorithm as a linear program.",
            "id": "4206212",
            "problem": "Consider a discrete-time linear Cyber-Physical System (CPS) where a Digital Twin (DT) is used to estimate the state from sensor measurements possibly contaminated by adversarial attacks. The dynamics are given by $x_{t+1} = A x_t + B u_t$ and the measurement model is $y_t = C x_t + a_t$, where $x_t \\in \\mathbb{R}^n$ is the system state, $u_t \\in \\mathbb{R}^p$ is a known input, $y_t \\in \\mathbb{R}^m$ is the sensor output, $A \\in \\mathbb{R}^{n \\times n}$, $B \\in \\mathbb{R}^{n \\times p}$, $C \\in \\mathbb{R}^{m \\times n}$, and $a_t \\in \\mathbb{R}^m$ is an adversarial sensor attack vector that is $s$-sparse at each time $t$ (meaning at most $s$ components of $a_t$ are nonzero). Assume zero process noise and exact dynamics.\n\nYou are asked to design and analyze an estimator that tolerates $s$-sparse sensor attacks using the following optimization problem over a horizon $t = 0,1,\\dots,T$:\nminimize $\\sum_{t=0}^{T} \\| y_t - C \\hat{x}_t - \\hat{a}_t \\|_1$ subject to the dynamics $ \\hat{x}_{t+1} = A \\hat{x}_t + B u_t$, and a structural $s$-sparsity of $\\hat{a}_t$. In the noise-free case with exact dynamics and measurements, this can be equivalently written as minimizing $\\sum_{t=0}^{T} \\| \\hat{a}_t \\|_1$ subject to $y_t = C \\hat{x}_t + \\hat{a}_t$ and $\\hat{x}_{t+1} = A \\hat{x}_t + B u_t$. Starting from fundamental definitions of observability and sparse recovery, derive conditions under which exact recovery of the true state trajectory $\\{x_t\\}_{t=0}^{T}$ is guaranteed, and then implement a solver that computes $\\{\\hat{x}_t\\}_{t=0}^{T}$ by casting the estimator into a linear program using variable splitting with nonnegative auxiliary variables to represent the $\\ell_1$ norm.\n\nYour program must implement the specified estimator and evaluate exact recovery on the following test suite. In all cases, use $T$ as specified, with times $t = 0,1,\\dots,T$, known $A$, $B$, $C$, $u_t$, and construct $y_t$ from a ground-truth trajectory and specified attacks. Numerical values are given below. Exact recovery should be evaluated by checking whether $\\max_{t} \\| \\hat{x}_t - x_t \\|_\\infty \\le \\varepsilon$ for a tolerance of $\\varepsilon = 10^{-8}$. For each test case, return a boolean indicating exact recovery ($\\text{True}$ if the inequality holds, otherwise $\\text{False}$).\n\nTest case $1$ (happy path, observable and recoverable, $s=1$):\n- $n=2$, $m=5$, $p=2$, $T=3$.\n- $A = \\begin{bmatrix} 1.0 & 0.2 \\\\ 0.0 & 0.9 \\end{bmatrix}$.\n- $B = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$.\n- $u_t = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ for all $t$.\n- $C = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 1 & 1 \\\\ 2 & -1 \\\\ 1 & 2 \\end{bmatrix}$.\n- $x_0 = \\begin{bmatrix} 1.0 \\\\ -0.5 \\end{bmatrix}$, and $x_{t+1} = A x_t$ (since $u_t = 0$).\n- Attack index at each time is sensor $4$ (the fourth row of $C$), with magnitude $0.2$: $a_t = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.2 \\\\ 0.0 \\end{bmatrix}$ for each $t$.\n- Measurements $y_t = C x_t + a_t$.\n\nTest case $2$ (failure due to insufficient un-attacked information, $s=2$):\n- $n=2$, $m=3$, $p=2$, $T=2$.\n- $A = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$.\n- $B = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\end{bmatrix}$.\n- $u_t = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ for all $t$.\n- $C = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ 0 & 0 \\end{bmatrix}$.\n- True state $x_t = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ for all $t$.\n- Attack on sensors $1$ and $2$ at all times: $a_t = \\begin{bmatrix} 2.0 \\\\ -1.0 \\\\ 0.0 \\end{bmatrix}$.\n- Measurements $y_t = C x_t + a_t = \\begin{bmatrix} 2.0 \\\\ -1.0 \\\\ 0.0 \\end{bmatrix}$, which are indistinguishable from the attack-free case $a_t = 0$, $x_t = \\begin{bmatrix} 2.0 \\\\ -1.0 \\end{bmatrix}$.\n\nTest case $3$ (no attack, $s=0$):\n- $n=3$, $m=4$, $p=3$, $T=3$.\n- $A = \\begin{bmatrix} 0.9 & 0.1 & 0.0 \\\\ 0.0 & 0.85 & 0.1 \\\\ 0.0 & 0.0 & 0.95 \\end{bmatrix}$.\n- $B = \\begin{bmatrix} 1.0 & 0.0 & 0.0 \\\\ 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\end{bmatrix}$.\n- $u_t = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$ for all $t$.\n- $C = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 1 & 1 \\end{bmatrix}$.\n- $x_0 = \\begin{bmatrix} 1.0 \\\\ -1.0 \\\\ 0.5 \\end{bmatrix}$, and $x_{t+1} = A x_t$.\n- No attack: $a_t = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 0.0 \\end{bmatrix}$.\n- Measurements $y_t = C x_t$.\n\nYour program should compute the estimator solution by solving the equivalent linear program that minimizes $\\sum_{t=0}^{T} \\| \\hat{a}_t \\|_1$ subject to $y_t = C \\hat{x}_t + \\hat{a}_t$ and $\\hat{x}_{t+1} = A \\hat{x}_t + B u_t$, implemented via variable splitting $\\hat{a}_t = \\hat{a}_t^{+} - \\hat{a}_t^{-}$ with $\\hat{a}_t^{+} \\ge 0$, $\\hat{a}_t^{-} \\ge 0$, and objective $\\sum_{t=0}^{T} \\mathbf{1}^\\top (\\hat{a}_t^{+} + \\hat{a}_t^{-})$. After solving, check exact recovery against the ground-truth $\\{x_t\\}$ using the $\\varepsilon$ criterion above.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$), where each $r_i$ is a boolean corresponding to test case $i$ in order.",
            "solution": "The problem asks for the derivation of recovery conditions and the implementation of a resilient state estimator for a discrete-time linear time-invariant (LTI) Cyber-Physical System (CPS) subject to sparse sensor attacks. The estimator is realized as a Digital Twin (DT), a model-based replica of the system, that synchronizes its state with the physical system by processing measurements corrupted by an adversary.\n\nThe system dynamics and measurement model are given by:\n$$ \\hat{x}_{t+1} = A \\hat{x}_t + B u_t $$\n$$ y_t = C x_t + a_t $$\nwhere $x_t \\in \\mathbb{R}^n$ is the state, $u_t \\in \\mathbb{R}^p$ is the known input, $y_t \\in \\mathbb{R}^m$ is the measurement, and $a_t \\in \\mathbb{R}^m$ is an $s$-sparse adversarial attack vector. The estimator aims to find the state trajectory $\\{\\hat{x}_t\\}_{t=0}^T$ and the attack trajectory $\\{\\hat{a}_t\\}_{t=0}^T$ that are consistent with the known dynamics and measurements.\n\nThe proposed estimator is based on the following optimization problem, assuming noise-free measurements and dynamics:\n$$ \\underset{\\{\\hat{x}_t\\}, \\{\\hat{a}_t\\}}{\\text{minimize}} \\quad \\sum_{t=0}^{T} \\| \\hat{a}_t \\|_1 $$\n$$ \\text{subject to} \\quad y_t = C \\hat{x}_t + \\hat{a}_t, \\quad t=0, \\dots, T $$\n$$ \\hat{x}_{t+1} = A \\hat{x}_t + B u_t, \\quad t=0, \\dots, T-1 $$\nThe use of the $\\ell_1$-norm serves as a convex proxy for finding the sparsest possible attack vector sequence that explains the measurements.\n\n**Derivation of Exact Recovery Conditions**\n\nTo analyze the conditions for exact state recovery, we first express the entire problem over the time horizon $t=0, \\dots, T$ in a compact form. The state at any time $t$ can be expressed as a function of the initial state $\\hat{x}_0$ and the sequence of inputs $\\{u_k\\}_{k=0}^{t-1}$:\n$$ \\hat{x}_t = A^t \\hat{x}_0 + \\sum_{k=0}^{t-1} A^{t-k-1} B u_k $$\nLet $w_t = \\sum_{k=0}^{t-1} A^{t-k-1} B u_k$ represent the part of the state at time $t$ driven by the known inputs (with $w_0=0$). The measurement equation becomes:\n$$ y_t = C (A^t \\hat{x}_0 + w_t) + \\hat{a}_t $$\nRearranging this equation, we can isolate the known quantities:\n$$ y_t - C w_t = (C A^t) \\hat{x}_0 + \\hat{a}_t $$\nLet $\\tilde{y}_t = y_t - C w_t$. We can stack these equations for $t=0, \\dots, T$:\n$$\n\\begin{bmatrix} \\tilde{y}_0 \\\\ \\tilde{y}_1 \\\\ \\vdots \\\\ \\tilde{y}_T \\end{bmatrix}\n=\n\\begin{bmatrix} C \\\\ CA \\\\ \\vdots \\\\ CA^T \\end{bmatrix} \\hat{x}_0\n+\n\\begin{bmatrix} \\hat{a}_0 \\\\ \\hat{a}_1 \\\\ \\vdots \\\\ \\hat{a}_T \\end{bmatrix}\n$$\nThis can be written compactly as $\\mathbf{Y}_{\\text{eff}} = \\mathcal{O}_T \\hat{x}_0 + \\hat{\\mathbf{A}}$, where $\\mathbf{Y}_{\\text{eff}}$ is the stacked vector of effective measurements, $\\mathcal{O}_T$ is the extended observability matrix over the horizon $T$, and $\\hat{\\mathbf{A}}$ is the stacked attack vector. The optimization problem is now equivalent to finding an initial state $\\hat{x}_0$ and a stacked attack vector $\\hat{\\mathbf{A}}$ that solve:\n$$ \\underset{\\hat{x}_0, \\hat{\\mathbf{A}}}{\\text{minimize}} \\quad \\|\\hat{\\mathbf{A}}\\|_1 \\quad \\text{subject to} \\quad \\mathbf{Y}_{\\text{eff}} = \\mathcal{O}_T \\hat{x}_0 + \\hat{\\mathbf{A}} $$\nLet the true initial state be $x_0$ and the true stacked attack be $\\mathbf{A}$. This pair is a feasible solution: $\\mathbf{Y}_{\\text{eff}} = \\mathcal{O}_T x_0 + \\mathbf{A}$. An optimal solution found by the estimator, $(\\hat{x}_0, \\hat{\\mathbf{A}})$, must also be feasible, so $\\mathbf{Y}_{\\text{eff}} = \\mathcal{O}_T \\hat{x}_0 + \\hat{\\mathbf{A}}$.\n\nSubtracting these two equations yields:\n$$ \\mathcal{O}_T (\\hat{x}_0 - x_0) = \\mathbf{A} - \\hat{\\mathbf{A}} $$\nLet the error in the initial state be $e_0 = \\hat{x}_0 - x_0$. Then the error in the attack vector is $\\hat{\\mathbf{A}} - \\mathbf{A} = -\\mathcal{O}_T e_0$.\nExact recovery of the state means that any optimal solution must have $\\hat{x}_0 = x_0$, which implies $e_0 = 0$.\nThe true solution $(x_0, \\mathbf{A})$ has an objective value of $\\|\\mathbf{A}\\|_1$. For any optimal solution $(\\hat{x}_0, \\hat{\\mathbf{A}})$, we must have $\\|\\hat{\\mathbf{A}}\\|_1 \\le \\|\\mathbf{A}\\|_1$.\nSubstituting $\\hat{\\mathbf{A}} = \\mathbf{A} - \\mathcal{O}_T e_0$, the condition for exact recovery is that for any non-zero error $e_0 \\in \\mathbb{R}^n$, the following inequality must hold:\n$$ \\|\\mathbf{A} - \\mathcal{O}_T e_0\\|_1 > \\|\\mathbf{A}\\|_1 $$\nThis is a standard condition from the theory of sparse recovery. It guarantees that any attempt to explain the measurements with an incorrect state (i.e., $e_0 \\ne 0$) will necessitate an attack vector estimate $\\hat{\\mathbf{A}}$ that is \"less sparse\" (has a larger $\\ell_1$-norm) than the true attack vector $\\mathbf{A}$.\n\nThis abstract condition can be translated into a more practical system-theoretic property. A widely used sufficient condition for such recovery is that the null space of the matrix $[\\mathcal{O}_T \\quad -I]$ does not contain \"sparse\" vectors. This leads to conditions on the observability of the system. A strong sufficient condition for exact recovery is that the system must remain observable even if the adversary corrupts the $s$ sensors and we also hypothetically lose another $s$ sensors that are most aligned with the state error. This leads to the requirement that for any set of sensors $I \\subseteq \\{1, \\dots, m\\}$ with $|I| \\ge m-2s$, the pair $(C_I, A)$ must be observable, where $C_I$ are the rows of $C$ corresponding to indices in $I$. A necessary condition for this is $m > 2s$. If $m \\le 2s$, an adversary can potentially manipulate the measurements to perfectly mimic the effect of a state deviation, making them indistinguishable. This is demonstrated in Test Case 2, where $m=3$ and $s=2$, leading to $m \\le 2s$ and a failure of recovery. The core issue is that a state error can produce a sparse output, which is then mistaken for part of the attack.\n\n**Linear Programming Formulation**\n\nThe optimization problem is not in standard linear program (LP) form due to the $\\ell_1$-norm. We can transform it into an LP using variable splitting. For each component of the attack vector $\\hat{a}_{t,i}$, we introduce two non-negative variables $\\hat{a}_{t,i}^+$ and $\\hat{a}_{t,i}^-$ such that:\n$$ \\hat{a}_{t,i} = \\hat{a}_{t,i}^+ - \\hat{a}_{t,i}^- \\quad \\text{with} \\quad \\hat{a}_{t,i}^+ \\ge 0, \\hat{a}_{t,i}^- \\ge 0 $$\nThe $\\ell_1$-norm can then be expressed as $\\|\\hat{a}_t\\|_1 = \\sum_i |\\hat{a}_{t,i}|$. At the optimum of the minimization problem, we will have $|\\hat{a}_{t,i}| = \\hat{a}_{t,i}^+ + \\hat{a}_{t,i}^-$. The objective function becomes linear:\n$$ \\underset{\\hat{x}_0, \\{\\hat{a}_t^+\\}, \\{\\hat{a}_t^-\\}}{\\text{minimize}} \\quad \\sum_{t=0}^{T} \\sum_{i=1}^{m} (\\hat{a}_{t,i}^+ + \\hat{a}_{t,i}^-) $$\nsubject to the constraints for $t=0, ..., T$:\n$$ \\tilde{y}_t = (C A^t) \\hat{x}_0 + \\hat{a}_t^+ - \\hat{a}_t^- $$\n$$ \\hat{a}_t^+ \\ge 0, \\quad \\hat{a}_t^- \\ge 0 $$\nThis is a standard LP problem. The decision variables are the initial state $\\hat{x}_0 \\in \\mathbb{R}^n$ (unrestricted in sign) and the auxiliary attack variables $\\{\\hat{a}_t^+, \\hat{a}_t^-\\}_{t=0}^T$, which are non-negative.\nWe construct the matrices for the standard LP form $\\min c^T z$ s.t. $A_{\\text{eq}} z = b_{\\text{eq}}$ and $z \\ge 0$ (for some components).\nThe variable vector is $z = [\\hat{x}_0^T, (\\hat{a}_0^+)^T, (\\hat{a}_0^-)^T, \\dots, (\\hat{a}_T^+)^T, (\\hat{a}_T^-)^T]^T$.\nThe cost vector $c$ has zeros corresponding to $\\hat{x}_0$ and ones corresponding to all components of $\\hat{a}_t^+$ and $\\hat{a}_t^-$.\nThe equality constraint matrix $A_{\\text{eq}}$ and vector $b_{\\text{eq}}$ are built by stacking the rewritten measurement equations for each time step. The non-negativity constraints on $\\hat{a}_t^+$ and $\\hat{a}_t^-$ are handled via variable bounds. After solving the LP for the optimal $\\hat{x}_0$, the full estimated state trajectory $\\{\\hat{x}_t\\}_{t=0}^T$ is reconstructed using the system dynamics.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves for the estimated state trajectory for three test cases\n    and checks for exact recovery.\n    \"\"\"\n    \n    # Tolerance for exact recovery check\n    RECOVERY_TOLERANCE = 1e-8\n    \n    test_cases = [\n        {\n            \"n\": 2, \"m\": 5, \"p\": 2, \"T\": 3, \"s\": 1,\n            \"A\": np.array([[1.0, 0.2], [0.0, 0.9]]),\n            \"B\": np.eye(2),\n            \"C\": np.array([[1, 0], [0, 1], [1, 1], [2, -1], [1, 2]]),\n            \"u_t\": np.zeros(2), \n            \"x0\": np.array([1.0, -0.5]),\n            \"a_t\": np.array([0.0, 0.0, 0.0, 0.2, 0.0])\n        },\n        {\n            \"n\": 2, \"m\": 3, \"p\": 2, \"T\": 2, \"s\": 2,\n            \"A\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"B\": np.eye(2),\n            \"C\": np.array([[1, 0], [0, 1], [0, 0]]),\n            \"u_t\": np.zeros(2),\n            \"x0\": np.zeros(2),\n            \"a_t\": np.array([2.0, -1.0, 0.0])\n        },\n        {\n            \"n\": 3, \"m\": 4, \"p\": 3, \"T\": 3, \"s\": 0,\n            \"A\": np.array([[0.9, 0.1, 0.0], [0.0, 0.85, 0.1], [0.0, 0.0, 0.95]]),\n            \"B\": np.eye(3),\n            \"C\": np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1], [1, 1, 1]]),\n            \"u_t\": np.zeros(3),\n            \"x0\": np.array([1.0, -1.0, 0.5]),\n            \"a_t\": np.zeros(4)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n, m, p, T = case[\"n\"], case[\"m\"], case[\"p\"], case[\"T\"]\n        A, B, C = case[\"A\"], case[\"B\"], case[\"C\"]\n        u_t, x0, a_t = case[\"u_t\"], case[\"x0\"], case[\"a_t\"]\n        \n        horizon_len = T + 1\n\n        # 1. Generate ground truth trajectory and measurements\n        x_true = [x0]\n        y_meas = []\n        \n        current_x = x0\n        for t in range(T):\n            current_x = A @ current_x + B @ u_t\n            x_true.append(current_x)\n            \n        for t in range(horizon_len):\n            y_t = C @ x_true[t] + a_t\n            y_meas.append(y_t)\n            \n        # 2. Formulate the Linear Program\n        # Decision variables vector z = [x0_hat, a0_p, a0_n, a1_p, a1_n, ..., aT_p, aT_n]\n        # Size of z: n + 2 * m * horizon_len\n        num_vars = n + 2 * m * horizon_len\n\n        # Cost vector c\n        c = np.zeros(num_vars)\n        c[n:] = 1.0  # Minimize sum(a_p + a_n)\n\n        # Equality constraints: A_eq * z = b_eq\n        # y_t - C*w_t = C*A^t*x0_hat + a_t_p - a_t_n\n        # Since u_t = 0 for all cases, w_t = 0.\n        A_eq = np.zeros((m * horizon_len, num_vars))\n        b_eq = np.concatenate(y_meas)\n\n        A_powers = [np.linalg.matrix_power(A, t) for t in range(horizon_len)]\n        \n        for t in range(horizon_len):\n            row_start, row_end = t * m, (t + 1) * m\n            \n            # Coefficient for x0_hat: C * A^t\n            A_eq[row_start:row_end, 0:n] = C @ A_powers[t]\n            \n            # Coefficient for a_t_p: I\n            ap_col_start = n + t * 2 * m\n            ap_col_end = ap_col_start + m\n            A_eq[row_start:row_end, ap_col_start:ap_col_end] = np.eye(m)\n            \n            # Coefficient for a_t_n: -I\n            an_col_start = ap_col_end\n            an_col_end = an_col_start + m\n            A_eq[row_start:row_end, an_col_start:an_col_end] = -np.eye(m)\n\n        # Bounds for variables\n        # x0_hat is unbounded\n        # a_p, a_n are non-negative\n        bounds = [(None, None)] * n + [(0, None)] * (2 * m * horizon_len)\n        \n        # 3. Solve the LP\n        res = linprog(c, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if not res.success:\n            # If solver fails, recovery has failed.\n            results.append(False)\n            continue\n            \n        # 4. Extract solution and evaluate recovery\n        x0_hat = res.x[0:n]\n        \n        # Reconstruct estimated trajectory\n        x_hat = [x0_hat]\n        current_x_hat = x0_hat\n        for t in range(T):\n            current_x_hat = A @ current_x_hat + B @ u_t\n            x_hat.append(current_x_hat)\n            \n        # Calculate max infinity norm of the error\n        max_error = 0.0\n        for t in range(horizon_len):\n            error = np.linalg.norm(x_hat[t] - x_true[t], ord=np.inf)\n            if error > max_error:\n                max_error = error\n        \n        recovery_success = max_error <= RECOVERY_TOLERANCE\n        results.append(recovery_success)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}