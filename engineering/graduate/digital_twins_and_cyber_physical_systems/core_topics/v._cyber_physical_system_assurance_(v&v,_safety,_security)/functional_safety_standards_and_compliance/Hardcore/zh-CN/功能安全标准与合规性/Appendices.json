{
    "hands_on_practices": [
        {
            "introduction": "功能安全分析的核心在于量化风险。其中，危险未探测失效速率（$\\lambda_{DU}$）是评估安全完整性水平（SIL）的基石。本练习将指导您如何从基本原理出发，为一个由数字孪生监控的复杂执行器计算这一关键指标。通过这个实践，您将学习如何处理多种失效模式以及依赖于具体工况的诊断覆盖率，从而将一个复杂的问题分解为可管理的、可计算的多个部分。",
            "id": "4223905",
            "problem": "某流程工厂中的一个安全相关的信息物理执行器由一个基于高保真模型的数字孪生 (DT) 进行监控，该数字孪生执行实时和定期的诊断。为符合国际电工委员会 (IEC) 61508 功能安全要求，危险未探测故障率必须从第一性原理进行量化。\n\n假设危险故障遵循泊松过程，并被划分为三种统计独立的危险故障模式，其小时恒定故障率分别为：卡在关闭位置，故障率为 $\\lambda_{\\mathrm{SC}} = 1.1 \\times 10^{-6}$；卡在打开位置，故障率为 $\\lambda_{\\mathrm{SO}} = 0.9 \\times 10^{-6}$；以及响应缓慢，故障率为 $\\lambda_{\\mathrm{SR}} = 2.5 \\times 10^{-6}$。数字孪生的诊断功能对这些模式产生不同的探测特性：\n- 对于卡在关闭位置的故障，探测到的危险故障比例为 $d_{\\mathrm{SC}} = 0.98$。\n- 对于卡在打开位置的故障，探测到的危险故障比例为 $d_{\\mathrm{SO}} = 0.85$。\n- 对于响应缓慢的故障，探测概率取决于分数减速率 $s \\in [0,1]$，该值在 $[0,1]$ 上均匀分布。对于给定的 $s$，数字孪生探测到该故障的概率为 $p_{D}(s) = 1 - \\exp(-k s)$，其中 $k = 3$。\n\n从以下定义出发：(i) 总危险故障率是各模式故障率之和，(ii) 诊断覆盖率 (DC) 是在所述假设下，由诊断功能探测到的危险故障率所占的比例，以及 (iii) 危险未探测故障是那些未被诊断功能探测到的危险故障，请推导出一个用总危险故障率 $\\lambda_{D}$ 和诊断覆盖率 $DC$ 表示的危险未探测故障率 $\\lambda_{DU}$ 的表达式。然后，通过首先评估响应缓慢模式的平均探测比例，再汇总所有模式的结果，根据给定数据计算 $\\lambda_{DU}$。\n\n将最终的危险未探测故障率以小时故障数 ($1/\\mathrm{h}$) 为单位表示，并将您的答案四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、内容自洽且定义明确。该问题基于可靠性工程和功能安全 (IEC 61508) 的标准原理，使用泊松过程来描述故障率，这是一种常用且有效的模型。所有必要的参数（$\\lambda_{\\mathrm{SC}}$, $\\lambda_{\\mathrm{SO}}$, $\\lambda_{\\mathrm{SR}}$, $d_{\\mathrm{SC}}$, $d_{\\mathrm{SO}}$, $k$）和分布（$s$ 的均匀分布）均已提供。定义清晰，问题可进行数学形式化。因此，该问题被认为是有效的，并着手求解。\n\n问题要求完成两项主要任务：首先，推导出一个用总危险故障率 $\\lambda_{D}$ 和诊断覆盖率 $DC$ 表示的危险未探测故障率 $\\lambda_{DU}$ 的表达式；其次，根据所提供的数据计算 $\\lambda_{DU}$ 的数值。\n\n首先，我们推导 $\\lambda_{DU}$ 的通用表达式。\n总危险故障率 $\\lambda_{D}$ 是探测到的危险故障率 $\\lambda_{DD}$ 和未探测到的危险故障率 $\\lambda_{DU}$ 之和。\n$$\n\\lambda_{D} = \\lambda_{DD} + \\lambda_{DU}\n$$\n诊断覆盖率 $DC$ 定义为由诊断功能探测到的危险故障率所占的比例。\n$$\nDC = \\frac{\\lambda_{DD}}{\\lambda_{D}}\n$$\n根据 $DC$ 的定义，我们可以将 $\\lambda_{DD}$ 表示为：\n$$\n\\lambda_{DD} = \\lambda_{D} \\cdot DC\n$$\n将此 $\\lambda_{DD}$ 的表达式代入第一个方程，得到：\n$$\n\\lambda_{D} = (\\lambda_{D} \\cdot DC) + \\lambda_{DU}\n$$\n求解 $\\lambda_{DU}$，我们得到所需的关系式：\n$$\n\\lambda_{DU} = \\lambda_{D} - (\\lambda_{D} \\cdot DC) = \\lambda_{D} (1 - DC)\n$$\n\n接下来，我们计算 $\\lambda_{DU}$ 的数值。总危险未探测故障率是来自三种独立故障模式——卡在关闭位置 (SC)、卡在打开位置 (SO) 和响应缓慢 (SR)——的危险未探测故障率之和。\n$$\n\\lambda_{DU} = \\lambda_{DU, \\mathrm{SC}} + \\lambda_{DU, \\mathrm{SO}} + \\lambda_{DU, \\mathrm{SR}}\n$$\n对于每种模式 $i$，危险未探测故障率由 $\\lambda_{DU, i} = \\lambda_{i}(1 - d_{i})$ 给出，其中 $\\lambda_{i}$ 是该模式的故障率，而 $d_{i}$ 是相应的探测比例（或该模式的诊断覆盖率）。\n\n对于卡在关闭位置的模式：\n故障率为 $\\lambda_{\\mathrm{SC}} = 1.1 \\times 10^{-6} \\, \\mathrm{h}^{-1}$。\n探测比例为 $d_{\\mathrm{SC}} = 0.98$。\n危险未探测故障率为：\n$$\n\\lambda_{DU, \\mathrm{SC}} = \\lambda_{\\mathrm{SC}} (1 - d_{\\mathrm{SC}}) = (1.1 \\times 10^{-6}) (1 - 0.98) = (1.1 \\times 10^{-6})(0.02) = 0.022 \\times 10^{-6} \\, \\mathrm{h}^{-1}\n$$\n\n对于卡在打开位置的模式：\n故障率为 $\\lambda_{\\mathrm{SO}} = 0.9 \\times 10^{-6} \\, \\mathrm{h}^{-1}$。\n探测比例为 $d_{\\mathrm{SO}} = 0.85$。\n危险未探测故障率为：\n$$\n\\lambda_{DU, \\mathrm{SO}} = \\lambda_{\\mathrm{SO}} (1 - d_{\\mathrm{SO}}) = (0.9 \\times 10^{-6}) (1 - 0.85) = (0.9 \\times 10^{-6})(0.15) = 0.135 \\times 10^{-6} \\, \\mathrm{h}^{-1}\n$$\n\n对于响应缓慢的模式：\n故障率为 $\\lambda_{\\mathrm{SR}} = 2.5 \\times 10^{-6} \\, \\mathrm{h}^{-1}$。\n探测概率 $p_{D}(s) = 1 - \\exp(-ks)$ 是分数减速率 $s$ 的函数，而 $s$ 是在区间 $[0,1]$ 上均匀分布的随机变量。$s$ 的概率密度函数 (PDF) 为：当 $s \\in [0,1]$ 时，$f(s) = 1$；否则 $f(s) = 0$。\n为了求出该模式的危险未探测故障率，我们首先需要平均探测比例 $\\bar{d}_{\\mathrm{SR}}$。这是 $p_{D}(s)$ 的期望值。\n$$\n\\bar{d}_{\\mathrm{SR}} = E[p_{D}(s)] = \\int_{0}^{1} p_{D}(s) f(s) \\, ds = \\int_{0}^{1} (1 - \\exp(-ks)) \\cdot 1 \\, ds\n$$\n在常数 $k=3$ 的条件下，积分变为：\n$$\n\\bar{d}_{\\mathrm{SR}} = \\int_{0}^{1} (1 - \\exp(-3s)) \\, ds = \\left[s - \\frac{\\exp(-3s)}{-3}\\right]_{0}^{1} = \\left[s + \\frac{1}{3}\\exp(-3s)\\right]_{0}^{1}\n$$\n在积分上下限处求值：\n$$\n\\bar{d}_{\\mathrm{SR}} = \\left(1 + \\frac{1}{3}\\exp(-3)\\right) - \\left(0 + \\frac{1}{3}\\exp(0)\\right) = 1 + \\frac{1}{3}e^{-3} - \\frac{1}{3} = \\frac{2}{3} + \\frac{1}{3}e^{-3}\n$$\n该模式下未探测故障的比例是 $1 - \\bar{d}_{\\mathrm{SR}}$：\n$$\n1 - \\bar{d}_{\\mathrm{SR}} = 1 - \\left(\\frac{2}{3} + \\frac{1}{3}e^{-3}\\right) = \\frac{1}{3} - \\frac{1}{3}e^{-3} = \\frac{1 - e^{-3}}{3}\n$$\n响应缓慢模式的危险未探测故障率为：\n$$\n\\lambda_{DU, \\mathrm{SR}} = \\lambda_{\\mathrm{SR}} (1 - \\bar{d}_{\\mathrm{SR}}) = (2.5 \\times 10^{-6}) \\left(\\frac{1 - \\exp(-3)}{3}\\right)\n$$\n现在，我们将所有模式的未探测故障率相加，以求得总危险未探测故障率 $\\lambda_{DU}$：\n$$\n\\lambda_{DU} = \\lambda_{DU, \\mathrm{SC}} + \\lambda_{DU, \\mathrm{SO}} + \\lambda_{DU, \\mathrm{SR}}\n$$\n$$\n\\lambda_{DU} = 0.022 \\times 10^{-6} + 0.135 \\times 10^{-6} + (2.5 \\times 10^{-6}) \\left(\\frac{1 - \\exp(-3)}{3}\\right)\n$$\n$$\n\\lambda_{DU} = \\left(0.022 + 0.135 + \\frac{2.5}{3}(1 - \\exp(-3))\\right) \\times 10^{-6}\n$$\n$$\n\\lambda_{DU} = \\left(0.157 + \\frac{2.5}{3}(1 - \\exp(-3))\\right) \\times 10^{-6}\n$$\n现在我们计算其数值：\n$$\n1 - \\exp(-3) \\approx 1 - 0.049787068 = 0.950212932\n$$\n$$\n\\frac{2.5}{3}(1 - \\exp(-3)) \\approx 0.833333333 \\times 0.950212932 \\approx 0.79184411\n$$\n$$\n\\lambda_{DU} \\approx (0.157 + 0.79184411) \\times 10^{-6} = 0.94884411 \\times 10^{-6} \\, \\mathrm{h}^{-1}\n$$\n将此结果写成标准科学记数法：\n$$\n\\lambda_{DU} \\approx 9.4884411 \\times 10^{-7} \\, \\mathrm{h}^{-1}\n$$\n题目要求将最终答案四舍五入到四位有效数字。\n$$\n\\lambda_{DU} \\approx 9.488 \\times 10^{-7} \\, \\mathrm{h}^{-1}\n$$\n这就是最终的危险未探测故障率。",
            "answer": "$$\n\\boxed{9.488 \\times 10^{-7}}\n$$"
        },
        {
            "introduction": "单个组件的可靠性固然重要，但功能安全最终要保障的是整个系统的安全。故障树分析（FTA）是一种强大且直观的自顶向下演绎逻辑工具，用于探究组件故障如何组合并最终导致系统级危险事件。本练习将带您构建一个典型机器人单元的安全功能故障树，并综合考虑组件不可用度、冗余架构、共因失效（CCF）以及人为因素，来定量评估顶事件发生的概率。",
            "id": "4223977",
            "problem": "一个机器人装配单元由一个保护性停止功能来保障安全，当有人出现在协作区域时，该功能必须将危险运动带入安全状态。该单元由一个双通道存在感应子系统、一个单通道安全逻辑求解器和最终断电路径中的双串联电源接触器组成。该单元的数字孪生已被用于估计稳态运行条件下的基本事件率和修复特性。要求您为危险顶事件构建故障树的逻辑结构，然后根据基本事件率和逻辑结构，使用与功能安全实践（例如，国际电工委员会 (IEC) 61508）一致的第一性原理可靠性和概率论证，推导出任意时刻的顶事件概率。\n\n将危险顶事件 $\\mathcal{H}$ 定义为“危险的机器人运动与协作区域内的人员存在同时发生”。逻辑结构如下，与故障树分析 (FTA) 一致：\n\n- 顶事件发生，当且仅当事件 $\\mathcal{Z}$ = “人员存在于协作区域”与事件 $\\mathcal{F}$ = “保护性停止功能危险失效”同时发生。因此，$\\mathcal{H}$ 是 $\\mathcal{Z}$ 和 $\\mathcal{F}$ 的逻辑与。\n- 事件 $\\mathcal{F}$ 发生，当且仅当以下任一互斥的失效模式发生：\n  1. 两个存在感应通道都发生危险失效，导致未生成需求（一个 1-out-of-2 感应架构在两个通道都失效时失效）。\n  2. 安全逻辑求解器（一个单通道安全可编程逻辑控制器 (PLC)）处于危险失效状态。\n  3. 两个串联的电源接触器都处于粘连闭合的危险失效状态，从而无法断电（一个 1-out-of-2 架构在两个通道都失效时失效）。\n\n假设所有组件都是可修复的，其失效时间和修复时间服从指数分布，具有恒定的危险失效率 $\\lambda$ 和修复率 $\\mu$，并且单个组件的稳态不可用度为 $Q \\equiv \\frac{\\lambda}{\\lambda + \\mu}$。假设不同子系统之间是独立的，除了每个冗余对内的共因失效 (CCF)，其通过 $\\beta$ 因子模型建模：对于两个具有相同单通道不可用度 $Q$ 的相同通道，要求“两个通道都失效”的失效逻辑的对级不可用度为 $Q_{\\text{pair}} \\approx \\beta Q + (1 - \\beta) Q^{2}$，其中 $\\beta \\in [0,1]$ 是 CCF 分数。在适当的情况下，对低概率事件的并集使用稀有事件近似。\n\n从数字孪生和维护日志中获得的基本参数如下：\n- 存在感应通道 A 和 B（相同）：危险失效率 $\\lambda_{s} = 2 \\times 10^{-6}\\,\\text{h}^{-1}$，修复率 $\\mu_{s} = \\frac{1}{8}\\,\\text{h}^{-1}$，共因失效分数 $\\beta_{s} = 0.05$。\n- 安全 PLC：危险失效率 $\\lambda_{p} = 1 \\times 10^{-6}\\,\\text{h}^{-1}$，修复率 $\\mu_{p} = \\frac{1}{4}\\,\\text{h}^{-1}$。\n- 电源接触器 K$1$ 和 K$2$（相同）：危险失效率 $\\lambda_{k} = 3 \\times 10^{-6}\\,\\text{h}^{-1}$，修复率 $\\mu_{k} = \\frac{1}{12}\\,\\text{h}^{-1}$，共因失效分数 $\\beta_{k} = 0.02$。\n- 在任意时刻，人员存在于协作区域的概率为 $P(\\mathcal{Z}) = p_{Z} = 0.02$（以小数表示，而非百分比）。\n\n仅使用上述基本定义和近似，推导任意时刻稳态顶事件概率 $P(\\mathcal{H})$ 的闭式表达式。然后使用所提供的参数进行数值计算。将最终答案表示为无量纲小数，并四舍五入到三位有效数字。不要使用百分号。",
            "solution": "本问题要求推导并计算危险顶事件 $\\mathcal{H}$ 的稳态概率，该事件定义为“危险的机器人运动与协作区域内的人员存在同时发生”。\n\n首先，我们根据所提供的定义建立问题的逻辑结构。顶事件 $\\mathcal{H}$ 发生，当且仅当事件 $\\mathcal{Z}$（“人员存在于协作区域”）和事件 $\\mathcal{F}$（“保护性停止功能危险失效”）同时发生。保护功能（硬件）的状态与人员存在在统计上是独立的。因此，顶事件的概率是这两个独立事件概率的乘积：\n$$P(\\mathcal{H}) = P(\\mathcal{Z} \\land \\mathcal{F}) = P(\\mathcal{Z}) P(\\mathcal{F})$$\n人员存在的概率给定为 $P(\\mathcal{Z}) = p_Z = 0.02$。保护功能失效的概率 $P(\\mathcal{F})$ 是其稳态不可用度，我们将其表示为 $Q_{\\text{sys}}$。\n$$P(\\mathcal{H}) = p_Z Q_{\\text{sys}}$$\n\n事件 $\\mathcal{F}$ 是三个独立子系统失效的逻辑或：感应子系统（$\\mathcal{F}_S$）、逻辑求解器/PLC 子系统（$\\mathcal{F}_P$）和最终接触器子系统（$\\mathcal{F}_K$）。\n$$\\mathcal{F} = \\mathcal{F}_S \\lor \\mathcal{F}_P \\lor \\mathcal{F}_K$$\n由于这些子系统的危险失效概率预计非常小，我们可以对事件的并集概率使用稀有事件近似，即对于低概率的独立事件 $A$ 和 $B$，$P(A \\lor B) \\approx P(A) + P(B)$。将此应用于三个子系统：\n$$Q_{\\text{sys}} = P(\\mathcal{F}) \\approx P(\\mathcal{F}_S) + P(\\mathcal{F}_P) + P(\\mathcal{F}_K)$$\n我们将子系统不可用度表示为 $Q_S = P(\\mathcal{F}_S)$，$Q_P = P(\\mathcal{F}_P)$ 和 $Q_K = P(\\mathcal{F}_K)$。因此，$Q_{\\text{sys}} \\approx Q_S + Q_P + Q_K$。我们现在计算这些项中的每一项。\n\n1.  **安全 PLC 子系统不可用度 ($Q_P$)**\n    这是一个单通道子系统。其稳态不可用度由单个可修复组件的公式给出：\n    $$Q_P = \\frac{\\lambda_p}{\\lambda_p + \\mu_p}$$\n    使用所提供的参数 $\\lambda_{p} = 1 \\times 10^{-6}\\,\\text{h}^{-1}$ 和 $\\mu_{p} = \\frac{1}{4}\\,\\text{h}^{-1} = 0.25\\,\\text{h}^{-1}$：\n    $$Q_P = \\frac{1 \\times 10^{-6}}{1 \\times 10^{-6} + 0.25} = \\frac{1 \\times 10^{-6}}{0.250001} \\approx 3.999984 \\times 10^{-6}$$\n\n2.  **存在感应子系统不可用度 ($Q_S$)**\n    这是一个双通道子系统，当两个通道都失效时发生危险失效（2-out-of-2 失效逻辑）。问题为此配置提供了 $\\beta$ 因子模型：\n    $$Q_S \\approx \\beta_s Q_s + (1 - \\beta_s) Q_s^{2}$$\n    其中 $Q_s$ 是单个感应通道的不可用度，$\\beta_s$ 是共因失效 (CCF) 分数。\n    首先，我们使用参数 $\\lambda_{s} = 2 \\times 10^{-6}\\,\\text{h}^{-1}$ 和 $\\mu_{s} = \\frac{1}{8}\\,\\text{h}^{-1} = 0.125\\,\\text{h}^{-1}$ 计算 $Q_s$：\n    $$Q_s = \\frac{\\lambda_s}{\\lambda_s + \\mu_s} = \\frac{2 \\times 10^{-6}}{2 \\times 10^{-6} + 0.125} = \\frac{2 \\times 10^{-6}}{0.125002} \\approx 1.5999744 \\times 10^{-5}$$\n    现在，我们将此值与 $\\beta_s = 0.05$ 一起用于 CCF 公式中：\n    $$Q_S \\approx (0.05)(1.5999744 \\times 10^{-5}) + (1 - 0.05)(1.5999744 \\times 10^{-5})^2$$\n    $$Q_S \\approx 7.999872 \\times 10^{-7} + (0.95)(2.5599181 \\times 10^{-10})$$\n    $$Q_S \\approx 7.999872 \\times 10^{-7} + 2.431922 \\times 10^{-10} \\approx 8.002304 \\times 10^{-7}$$\n\n3.  **电源接触器子系统不可用度 ($Q_K$)**\n    这也是一个双通道子系统，当两个接触器都粘连闭合时发生危险失效（无法断电）（2-out-of-2 失效逻辑）。适用相同的 $\\beta$ 因子模型：\n    $$Q_K \\approx \\beta_k Q_k + (1 - \\beta_k) Q_k^{2}$$\n    首先，我们使用参数 $\\lambda_{k} = 3 \\times 10^{-6}\\,\\text{h}^{-1}$ 和 $\\mu_{k} = \\frac{1}{12}\\,\\text{h}^{-1} \\approx 0.083333\\,\\text{h}^{-1}$ 计算单个接触器的不可用度 $Q_k$：\n    $$Q_k = \\frac{\\lambda_k}{\\lambda_k + \\mu_k} = \\frac{3 \\times 10^{-6}}{3 \\times 10^{-6} + \\frac{1}{12}} = \\frac{3 \\times 10^{-6}}{0.083336333...} \\approx 3.5998704 \\times 10^{-5}$$\n    现在，我们将此值与 $\\beta_k = 0.02$ 一起用于 CCF 公式中：\n    $$Q_K \\approx (0.02)(3.5998704 \\times 10^{-5}) + (1 - 0.02)(3.5998704 \\times 10^{-5})^2$$\n    $$Q_K \\approx 7.1997408 \\times 10^{-7} + (0.98)(1.2959067 \\times 10^{-9})$$\n    $$Q_K \\approx 7.1997408 \\times 10^{-7} + 1.269988 \\times 10^{-9} \\approx 7.212440 \\times 10^{-7}$$\n\n$P(\\mathcal{H})$ 的闭式表达式为：\n$$P(\\mathcal{H}) \\approx p_Z \\left( \\left[ \\beta_s \\frac{\\lambda_s}{\\lambda_s + \\mu_s} + (1-\\beta_s) \\left(\\frac{\\lambda_s}{\\lambda_s + \\mu_s}\\right)^2 \\right] + \\left[ \\frac{\\lambda_p}{\\lambda_p + \\mu_p} \\right] + \\left[ \\beta_k \\frac{\\lambda_k}{\\lambda_k + \\mu_k} + (1-\\beta_k) \\left(\\frac{\\lambda_k}{\\lambda_k + \\mu_k}\\right)^2 \\right] \\right)$$\n\n现在，我们将子系统不可用度相加，以求得总系统不可用度 $Q_{\\text{sys}}$：\n$$Q_{\\text{sys}} \\approx Q_S + Q_P + Q_K$$\n$$Q_{\\text{sys}} \\approx (8.002304 \\times 10^{-7}) + (3.999984 \\times 10^{-6}) + (7.212440 \\times 10^{-7})$$\n$$Q_{\\text{sys}} \\approx (0.8002304 + 3.999984 + 0.7212440) \\times 10^{-6}$$\n$$Q_{\\text{sys}} \\approx 5.5214584 \\times 10^{-6}$$\n\n最后，我们将系统不可用度乘以人员存在的概率 $p_Z = 0.02$，来计算顶事件概率 $P(\\mathcal{H})$：\n$$P(\\mathcal{H}) = p_Z Q_{\\text{sys}}$$\n$$P(\\mathcal{H}) \\approx (0.02) \\times (5.5214584 \\times 10^{-6})$$\n$$P(\\mathcal{H}) \\approx 1.10429168 \\times 10^{-7}$$\n\n按要求将结果四舍五入到三位有效数字：\n$$P(\\mathcal{H}) \\approx 1.10 \\times 10^{-7}$$\n这个值表示在任意时刻，发现系统处于危险状态的概率，即当人员存在于协作区域时，机器人能够进行危险运动。",
            "answer": "$$\\boxed{1.10 \\times 10^{-7}}$$"
        },
        {
            "introduction": "对于包含故障修复和动态行为的复杂系统，静态分析方法（如故障树）可能不足以完全捕捉其可靠性特征。连续时间马尔可夫链（CTMC）为这类系统提供了一种强大的动态建模框架，能够清晰地描述系统在故障与修复事件驱动下不同状态间的转移。在此实践中，您将从最基本的平衡方程出发，为经典的“三取二”（2oo3）冗余系统建立马尔可夫模型，并推导其稳态危险失效概率，从而深入理解系统在长期运行中的动态可靠性表现。",
            "id": "4223917",
            "problem": "考虑一个与安全相关的控制功能，该功能在一个信息物理系统（CPS）中通过一个二取三（2oo3）冗余投票架构实现，其行为由一个数字孪生体（Digital Twin）镜像。在国际电工委员会（IEC）61508功能安全的背景下，使用连续时间马尔可夫链（CTMC）对危险未检测故障和带修复的自动诊断进行建模。假设以下科学上标准且被广泛接受的基础：\n\n- 3个相同通道中的每一个都可能发生危险故障且初始时未被检测到，其故障时间服从独立的指数分布，每个通道的故障率为 $\\lambda$（单位：$h^{-1}$）。\n- 自动诊断系统持续监控系统，并对潜在的危险故障独立地启动修复操作。每个故障通道的修复时间服从独立的指数分布，每个故障通道的修复率为 $\\mu$（单位：$h^{-1}$），修复后通道恢复至“如新”状态。假设 $\\mu > 0$。\n- 各通道以及诊断修复操作在通道间和时间上都是统计独立的。\n- 当处于正常工作状态的通道少于2个时，2oo3 系统发生危险故障，这在此模型中等同于同时有至少2个通道处于潜在危险故障状态。\n\n构建一个CTMC，其中每个状态 $S_i$（$i \\in \\{0,1,2,3\\}$）表示潜在危险故障通道的数量为 $i$。仅使用CTMC的基本定义（稳态下的状态平衡和指数转移率），并且不使用任何快捷公式，从第一性原理出发推导系统处于危险故障状态的稳态概率（即在稳态时处于 $S_2$ 或 $S_3$ 状态的概率）。您必须将此概率表示为无量纲的小数（不带百分号）。\n\n然后，实现一个程序，对于指定的 $(\\lambda,\\mu)$ 对，计算并输出每对参数的稳态危险故障概率。所有输入 $\\lambda$ 和 $\\mu$ 的单位均为 $h^{-1}$，输出为无量纲小数。\n\n测试套件：\n- 案例 1（正常路径）：$\\lambda = 1\\times 10^{-6}$, $\\mu = 1\\times 10^{-3}$。\n- 案例 2（边界，无故障）：$\\lambda = 0$, $\\mu = 1\\times 10^{-3}$。\n- 案例 3（快速修复）：$\\lambda = 1\\times 10^{-5}$, $\\mu = 1$。\n- 案例 4（修复远慢于故障）：$\\lambda = 1\\times 10^{-3}$, $\\mu = 1\\times 10^{-6}$。\n- 案例 5（速率均衡）：$\\lambda = 1\\times 10^{-4}$, $\\mu = 1\\times 10^{-4}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`\"[result_1,result_2,\\dots]\"`)，其中每个 $result_i$ 是对应测试案例计算出的危险故障概率，以小数形式表示。",
            "solution": "在尝试任何解决方案之前，用户提供的问题陈述都会经过严格的验证过程。\n\n### 步骤 1：提取已知条件\n- **系统架构**：二取三（2oo3）冗余投票架构。\n- **系统背景**：信息物理系统（CPS），其行为由数字孪生体镜像，在 IEC 61508 功能安全标准下进行分析。\n- **建模技术**：连续时间马尔可夫链（CTMC）。\n- **故障模式**：危险未检测故障。\n- **组件**：3个相同通道。\n- **故障过程**：每个通道的故障时间服从独立的指数分布，故障率为 $\\lambda$（单位：$h^{-1}$）。\n- **修复过程**：自动诊断系统对潜在故障启动修复。每个故障通道的修复时间服从独立的指数分布，修复率为 $\\mu$（单位：$h^{-1}$）。修复将通道恢复至“如新”状态。给定条件 $\\mu > 0$。\n- **独立性**：所有通道故障和修复操作在统计上是独立的。\n- **系统故障条件**：当正常工作的通道少于2个时，2oo3 系统发生危险故障，这等同于有2个或更多通道处于潜在危险故障状态。\n- **CTMC 状态**：状态 $S_i$ 表示系统有 $i$ 个潜在危险故障通道，其中 $i \\in \\{0, 1, 2, 3\\}$。\n- **目标**：从第一性原理（状态平衡方程）推导系统处于危险故障状态（$S_2$ 或 $S_3$）的稳态概率。结果需表示为无量纲小数。\n- **实现任务**：开发一个 Python 程序，为给定的 $(\\lambda, \\mu)$ 对计算此概率。\n- **测试套件**：\n  - 案例 1：$\\lambda = 1 \\times 10^{-6} \\, h^{-1}$，$\\mu = 1 \\times 10^{-3} \\, h^{-1}$。\n  - 案例 2：$\\lambda = 0 \\, h^{-1}$，$\\mu = 1 \\times 10^{-3} \\, h^{-1}$。\n  - 案例 3：$\\lambda = 1 \\times 10^{-5} \\, h^{-1}$，$\\mu = 1 \\, h^{-1}$。\n  - 案例 4：$\\lambda = 1 \\times 10^{-3} \\, h^{-1}$，$\\mu = 1 \\times 10^{-6} \\, h^{-1}$。\n  - 案例 5：$\\lambda = 1 \\times 10^{-4} \\, h^{-1}$，$\\mu = 1 \\times 10^{-4} \\, h^{-1}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题被认定为有效。\n- **科学依据**：该问题基于使用连续时间马尔可夫链进行可靠性和安全性分析的标准且科学上公认的方法论，这是可靠性工程以及像 IEC 61508 这类标准所推荐实践的基石。指数分布和统计独立性的假设是创建易于处理且易于理解的模型（生灭过程）的标准做法。\n- **良构性**：问题定义清晰。它描述了一个有限状态、不可约的 CTMC。条件 $\\mu > 0$ 确保了链是遍历的，从而保证了唯一、稳定且有意义的稳态概率分布的存在。待计算的量已明确定义。\n- **客观性**：问题陈述使用精确、客观、无歧义的科学语言编写。所有术语要么是该领域的标准术语，要么已明确定义。\n- **完整性与一致性**：问题提供了构建模型和推导解决方案所需的所有必要信息（状态、故障率、修复率、系统故障定义）。不存在矛盾之处。\n- **真实性**：该模型是一个标准的、尽管是简化的冗余安全系统表示。测试套件中的参数值在物理上是合理的，可用于表示组件可靠性和维护效率的各种场景。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个完整的、有理有据的解决方案。\n\n### 从第一性原理推导\n该系统可以建模为一个生灭过程，它是CTMC的一个特例。状态 $S_i$ 由故障通道的数量 $i$ 定义，其中 $i \\in \\{0, 1, 2, 3\\}$。\n\n**1. 确定转移率**\n假设系统处于状态 $S_i$，意味着有 $i$ 个通道发生故障，$3-i$ 个通道仍在运行。\n-   **故障（出生）率**：$3-i$ 个运行通道中的每一个都可能以速率 $\\lambda$ 发生故障。由于独立性，从 $S_i$ 到 $S_{i+1}$ 的总转移率为 $(3-i)\\lambda$。\n-   **修复（死亡）率**：$i$ 个故障通道中的每一个都可能以速率 $\\mu$ 被修复。由于独立性，从 $S_i$ 到 $S_{i-1}$ 的总转移率为 $i\\mu$。\n\n具体的转移率如下：\n-   从 $S_0$ 到 $S_1$：3 个通道可能发生故障。速率：$3\\lambda$。\n-   从 $S_1$ 到 $S_0$：1 个通道可以被修复。速率：$\\mu$。\n-   从 $S_1$ 到 $S_2$：2 个通道可能发生故障。速率：$2\\lambda$。\n-   从 $S_2$ 到 $S_1$：2 个通道可以被修复。速率：$2\\mu$。\n-   从 $S_2$ 到 $S_3$：1 个通道可能发生故障。速率：$\\lambda$。\n-   从 $S_3$ 到 $S_2$：3 个通道可以被修复。速率：$3\\mu$。\n\n状态转移图如下：\n$$ S_0 \\underset{\\mu}{\\stackrel{3\\lambda}{\\rightleftharpoons}} S_1 \\underset{2\\mu}{\\stackrel{2\\lambda}{\\rightleftharpoons}} S_2 \\underset{3\\mu}{\\stackrel{\\lambda}{\\rightleftharpoons}} S_3 $$\n\n**2. 建立并求解平衡方程**\n设 $P_i$ 为处于状态 $S_i$ 的稳态概率。在稳态下，流入任何状态的速率等于流出该状态的速率。对于生灭过程，我们可以使用跨越相邻状态之间假设切面的细致平衡方程。\n\n-   $S_0$ 和 $S_1$ 之间的平衡：\n    $$ P_0 (3\\lambda) = P_1 \\mu \\implies P_1 = P_0 \\frac{3\\lambda}{\\mu} $$\n-   $S_1$ 和 $S_2$ 之间的平衡：\n    $$ P_1 (2\\lambda) = P_2 (2\\mu) \\implies P_2 = P_1 \\frac{2\\lambda}{2\\mu} = P_1 \\frac{\\lambda}{\\mu} $$\n    代入 $P_1$ 的表达式：\n    $$ P_2 = \\left(P_0 \\frac{3\\lambda}{\\mu}\\right) \\frac{\\lambda}{\\mu} = P_0 \\frac{3\\lambda^2}{\\mu^2} $$\n-   $S_2$ 和 $S_3$ 之间的平衡：\n    $$ P_2 \\lambda = P_3 (3\\mu) \\implies P_3 = P_2 \\frac{\\lambda}{3\\mu} $$\n    代入 $P_2$ 的表达式：\n    $$ P_3 = \\left(P_0 \\frac{3\\lambda^2}{\\mu^2}\\right) \\frac{\\lambda}{3\\mu} = P_0 \\frac{\\lambda^3}{\\mu^3} $$\n\n**3. 应用归一化条件**\n所有稳态概率的总和必须等于 $1$。\n$$ \\sum_{i=0}^{3} P_i = P_0 + P_1 + P_2 + P_3 = 1 $$\n将 $P_1$、$P_2$ 和 $P_3$ 用 $P_0$ 表示的表达式代入：\n$$ P_0 + P_0 \\frac{3\\lambda}{\\mu} + P_0 \\frac{3\\lambda^2}{\\mu^2} + P_0 \\frac{\\lambda^3}{\\mu^3} = 1 $$\n提出因子 $P_0$：\n$$ P_0 \\left(1 + \\frac{3\\lambda}{\\mu} + \\frac{3\\lambda^2}{\\mu^2} + \\frac{\\lambda^3}{\\mu^3}\\right) = 1 $$\n设 $\\rho = \\frac{\\lambda}{\\mu}$。括号中的表达式是 $(1+\\rho)^3$ 的二项式展开：\n$$ P_0 (1 + 3\\rho + 3\\rho^2 + \\rho^3) = P_0 (1+\\rho)^3 = 1 $$\n求解 $P_0$：\n$$ P_0 = \\frac{1}{(1+\\rho)^3} = \\frac{1}{(1 + \\lambda/\\mu)^3} $$\n\n**4. 计算危险故障概率**\n如果系统处于 $S_2$ 或 $S_3$ 状态，则它处于危险故障状态。危险故障的总概率 $P_{fail}$ 是概率 $P_2$ 和 $P_3$ 的和。\n$$ P_{fail} = P_2 + P_3 $$\n我们用 $\\rho = \\lambda/\\mu$ 来表示 $P_2$ 和 $P_3$：\n$$ P_2 = P_0 \\frac{3\\lambda^2}{\\mu^2} = P_0 (3\\rho^2) = \\frac{3\\rho^2}{(1+\\rho)^3} $$\n$$ P_3 = P_0 \\frac{\\lambda^3}{\\mu^3} = P_0 \\rho^3 = \\frac{\\rho^3}{(1+\\rho)^3} $$\n将这些概率相加得到最终表达式：\n$$ P_{fail} = \\frac{3\\rho^2}{(1+\\rho)^3} + \\frac{\\rho^3}{(1+\\rho)^3} = \\frac{3\\rho^2 + \\rho^3}{(1+\\rho)^3} $$\n这就是基于第一性原理推导出的 2oo3 系统危险故障的稳态概率。该公式将在程序中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\n# Execution Environment:\n# language: Python\n# version: 3.12\n# libraries:\n# - name: numpy\n#   version: 1.23.5\n# - name: scipy\n#   version: 1.11.4\n\ndef calculate_dangerous_failure_probability(lambda_rate, mu_rate):\n    \"\"\"\n    Calculates the steady-state dangerous failure probability for a 2oo3 system.\n\n    The system is modeled by a Continuous-Time Markov Chain, resulting in the\n    following formula for the probability of being in a dangerous state (2 or 3\n    channels failed):\n    P_fail = (3*rho^2 + rho^3) / (1 + rho)^3\n    where rho = lambda_rate / mu_rate.\n\n    Args:\n        lambda_rate (float): The failure rate per channel (h^-1).\n        mu_rate (float): The repair rate per failed channel (h^-1).\n\n    Returns:\n        float: The dimensionless steady-state dangerous failure probability.\n    \"\"\"\n    # Per the problem description, mu_rate is always > 0.\n    # We must handle the case where lambda_rate is 0.\n    if lambda_rate == 0:\n        return 0.0\n\n    # The ratio of failure rate to repair rate.\n    rho = lambda_rate / mu_rate\n\n    # Numerator of the P_fail formula: 3*rho^2 + rho^3\n    numerator = 3 * np.power(rho, 2) + np.power(rho, 3)\n\n    # Denominator of the P_fail formula: (1 + rho)^3\n    denominator = np.power(1 + rho, 3)\n\n    # In the case where rho is extremely large, both numerator and denominator\n    # can become inf, leading to nan. However, the limit as rho -> inf is 1.\n    # The standard floating point arithmetic handles this case correctly\n    # for plausible large numbers.\n    if denominator == 0:\n        # This case is physically impossible given rho >= 0.\n        # It would only happen on overflow if 1+rho is too big, but numerator\n        # would overflow first or at the same time.\n        return 1.0 # The theoretical limit as rho -> infinity.\n        \n    return numerator / denominator\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating the dangerous failure probability\n    for a predefined suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (lambda_rate, mu_rate) in h^-1.\n    test_cases = [\n        (1e-6, 1e-3),  # Case 1 (happy path)\n        (0.0, 1e-3),   # Case 2 (boundary, no failures)\n        (1e-5, 1.0),   # Case 3 (fast repair)\n        (1e-3, 1e-6),  # Case 4 (repair much slower than failure)\n        (1e-4, 1e-4),  # Case 5 (balanced rates)\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_val, mu_val = case\n        result = calculate_dangerous_failure_probability(lambda_val, mu_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., \"[result_1,result_2,...,result_n]\"\n    # Using a general format specifier to represent floats compactly.\n    print(f\"[{','.join(f'{r:g}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}