{
    "hands_on_practices": [
        {
            "introduction": "本实践探讨了设计入侵检测器的一项基本任务。通过监测数字孪生预测与实际传感器测量值之间的残差，我们可以发现异常。练习  要求你应用经典的 Neyman-Pearson 框架，推导出一个能保证特定误报率 $ \\alpha $ 的检测阈值，这在任何现实世界的检测系统中都是一个关键的权衡。",
            "id": "4228432",
            "problem": "一个信息物理系统 (CPS) 使用数字孪生来预测传感器输出。设离散时间索引 $k$ 处的残差定义为 $r_{k} = y_{k} - \\hat{y}_{k}$，其中 $y_{k}$ 是测量输出，$\\hat{y}_{k}$ 是数字孪生的预测值。一个入侵检测系统 (IDS) 监控 $|r_{k}|$ 以检测在攻击假设下表现为均值偏移的驱动或传感器欺骗攻击。在无攻击假设 $H_{0}$ 下，由于传感器噪声和模型失配，残差 $r_{k}$ 被建模为方差为 $\\sigma^{2}$ 的零均值高斯分布，即 $r_{k} \\sim \\mathcal{N}(0,\\sigma^{2})$。在攻击假设 $H_{1}$ 下，残差分布的均值发生偏移，但方差近似保持为 $\\sigma^{2}$。使用 Neyman-Pearson 框架，设计一个双边标量阈值 $\\tau$ 用于当 $|r_{k}| > \\tau$ 时拒绝 $H_{0}$ 的检验，使得对于给定的设计参数 $\\alpha \\in (0,1)$，误报概率满足 $\\mathbb{P}(|r_{k}| > \\tau \\mid H_{0}) = \\alpha$。从高斯尾部概率和 Neyman-Pearson 准则的基本定义出发，推导出 $\\tau$ 关于 $\\alpha$ 和 $\\sigma$ 的显式闭合形式表达式。请以符号形式表示您的最终答案；不需要数值近似。",
            "solution": "首先验证问题陈述，以确保其科学合理、适定且客观。\n\n### 步骤 1：提取已知条件\n- 离散时间索引 $k$ 处的残差定义为 $r_{k} = y_{k} - \\hat{y}_{k}$。\n- $y_{k}$ 是来自信息物理系统 (CPS) 的测量输出。\n- $\\hat{y}_{k}$ 是来自数字孪生的预测输出。\n- 零假设 $H_{0}$ 对应于无攻击情景。\n- 在 $H_{0}$ 下，残差 $r_{k}$ 服从方差为 $\\sigma^{2}$ 的零均值高斯分布：$r_{k} \\sim \\mathcal{N}(0,\\sigma^{2})$。\n- 备择假设 $H_{1}$ 对应于残差均值发生偏移的攻击情景。\n- 入侵检测系统 (IDS) 采用一个决策规则：如果残差的绝对值超过阈值 $\\tau$，即 $|r_{k}| > \\tau$，则拒绝 $H_{0}$。\n- 误报概率被约束为 $\\mathbb{P}(|r_{k}| > \\tau \\mid H_{0}) = \\alpha$。\n- 参数 $\\alpha$ 是一个给定的设计参数，使得 $\\alpha \\in (0,1)$。\n- 目标是推导出阈值 $\\tau$ 关于 $\\alpha$ 和 $\\sigma$ 的闭合形式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据提取的信息对问题进行严格审查。\n\n- **科学依据**：该问题在统计检测理论中有充分的依据，该理论是信号处理和控制工程的核心学科。将噪声和模型失配建模为零均值高斯过程是一种标准且被广泛接受的做法。使用 Neyman-Pearson 框架设计具有固定误报率的检测器是假设检验中的一个基本概念。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。它提供了足够的信息来确定阈值 $\\tau$ 的一个唯一、稳定且有意义的解。对于高斯分布，误报概率 $\\alpha$ 与阈值 $\\tau$ 之间的关系是单调的，这确保了对于任何有效的 $\\alpha$ 都存在唯一的解。\n- **客观性**：该问题使用精确、无歧义且客观的技术语言陈述。没有主观或基于观点的断言。\n\n### 步骤 3：结论与行动\n该问题被认为是有效的，因为它是科学合理、适定且客观的。验证标准中列出的缺陷均不存在。因此，将推导完整的解。\n\n### 解题推导\n目标是确定满足指定误报概率的阈值 $\\tau$。误报概率是在零假设 $H_{0}$ 实际为真时拒绝它的概率。\n\n决策规则是如果 $|r_{k}| > \\tau$，则拒绝 $H_{0}$。因此，误报概率 $\\alpha$ 由以下条件给出：\n$$\n\\mathbb{P}(|r_{k}| > \\tau \\mid H_{0}) = \\alpha\n$$\n在零假设 $H_{0}$ 下，残差 $r_{k}$ 的分布为 $r_{k} \\sim \\mathcal{N}(0, \\sigma^{2})$。\n\n事件 $|r_{k}| > \\tau$ 等价于两个不相交事件的并集：$r_{k} > \\tau$ 或 $r_{k}  -\\tau$。因此，该概率可以写为：\n$$\n\\mathbb{P}(|r_{k}| > \\tau \\mid H_{0}) = \\mathbb{P}(r_{k} > \\tau \\mid H_{0}) + \\mathbb{P}(r_{k}  -\\tau \\mid H_{0})\n$$\n高斯分布 $\\mathcal{N}(0, \\sigma^{2})$ 关于其均值 $0$ 是对称的。这种对称性意味着两个尾部的概率相等：\n$$\n\\mathbb{P}(r_{k} > \\tau \\mid H_{0}) = \\mathbb{P}(r_{k}  -\\tau \\mid H_{0})\n$$\n将此代入 $\\alpha$ 的表达式中，我们得到：\n$$\n\\alpha = 2 \\cdot \\mathbb{P}(r_{k} > \\tau \\mid H_{0})\n$$\n由此，我们可以分离出单边尾部概率：\n$$\n\\mathbb{P}(r_{k} > \\tau \\mid H_{0}) = \\frac{\\alpha}{2}\n$$\n为了计算这个概率，我们对随机变量 $r_{k}$ 进行标准化。令 $Z$ 为一个标准正态随机变量，$Z \\sim \\mathcal{N}(0, 1)$。我们可以写成 $r_{k} = \\sigma Z$。不等式 $r_{k} > \\tau$ 随后等价于 $\\sigma Z > \\tau$，或 $Z > \\frac{\\tau}{\\sigma}$。\n\n概率条件变为：\n$$\n\\mathbb{P}\\left(Z > \\frac{\\tau}{\\sigma}\\right) = \\frac{\\alpha}{2}\n$$\n设 $\\Phi(z)$ 为标准正态分布的累积分布函数 (CDF)，定义为 $\\Phi(z) = \\mathbb{P}(Z \\le z)$。尾部概率可以用 CDF 表示：\n$$\n\\mathbb{P}(Z > z) = 1 - \\mathbb{P}(Z \\le z) = 1 - \\Phi(z)\n$$\n将此应用于我们的方程，其中 $z = \\frac{\\tau}{\\sigma}$：\n$$\n1 - \\Phi\\left(\\frac{\\tau}{\\sigma}\\right) = \\frac{\\alpha}{2}\n$$\n我们现在可以解出 CDF 的参数：\n$$\n\\Phi\\left(\\frac{\\tau}{\\sigma}\\right) = 1 - \\frac{\\alpha}{2}\n$$\n为了分离出 $\\frac{\\tau}{\\sigma}$，我们应用标准正态 CDF 的逆函数，即分位数函数，记为 $\\Phi^{-1}$。分位数函数 $\\Phi^{-1}(p)$ 返回值 $z$，使得 $\\mathbb{P}(Z \\le z) = p$。\n$$\n\\frac{\\tau}{\\sigma} = \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)\n$$\n最后，解出阈值 $\\tau$，我们得到显式的闭合形式表达式：\n$$\n\\tau = \\sigma \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)\n$$\n此表达式提供了所需的双边标量阈值 $\\tau$，作为已知系统参数 $\\sigma$ 和期望误报概率 $\\alpha$ 的函数。项 $\\Phi^{-1}(1 - \\frac{\\alpha}{2})$ 表示来自标准正态分布的临界值，对应于 $\\frac{\\alpha}{2}$ 的上尾概率。",
            "answer": "$$\n\\boxed{\\sigma \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)}\n$$"
        },
        {
            "introduction": "设计出检测器后，我们如何衡量其性能？在信息物理系统中，真实的攻击很少发生，这导致了数据中严重的类别不平衡。本练习  将演示如何计算和解释精确率（precision）、召回率（recall）和 $F_1$ 分数等关键指标，揭示一个表面上看起来准确率很高的检测器可能存在的性能弱点。",
            "id": "4228486",
            "problem": "一个信息物理系统 (CPS) 配水管网的数字孪生 (DT) 被用于生成带标签的运行数据，以评估一个入侵检测系统 (IDS)。该 DT 运行一个基于物理的水力动力学仿真，并注入对抗性执行器命令序列和传感器欺骗轨迹，以产生基准真相异常。在一个覆盖 $10000$ 个离散控制周期的评估窗口内，DT 将 $100$ 个周期标记为真实异常，将 $9900$ 个周期标记为真实正常。IDS 根据 DT 预测状态与观测状态之间的残差将周期标记为异常。由此产生的混淆计数为：真阳性 ($TP$) $=70$，假阳性 ($FP$) $=300$，假阴性 ($FN$) $=30$，以及真阴性 ($TN$) $=9600$。\n\n仅从二元检测中条件事件分类质量的核心定义出发，计算检测器的精确率 $P$、召回率 $R$ 和 $F_1$ 分数。将 $P$、$R$ 和 $F_1$ 均表示为小数，并将您的答案四舍五入至四位有效数字。\n\n计算出这些值后，讨论 CPS 中严重的类别不平衡（即真实异常以低基准率发生）如何扭曲这些指标，并解释为什么这会导致对检测器性能得出误导性结论。您的讨论应将计算出的值与不平衡现象联系起来，并从基本定义出发进行推理，而不使用超出这些定义的任何快捷公式。",
            "solution": "该问题要求计算一个二元分类器的三个标准性能指标——精确率 ($P$)、召回率 ($R$) 和 $F_1$ 分数——并随后讨论类别不平衡对这些指标的影响。\n\n首先，我们从入侵检测系统 (IDS) 评估产生的混淆矩阵中确定给定数量：\n- 真阳性 ($TP$)：被正确识别为异常的异常周期数。$TP = 70$。\n- 假阳性 ($FP$)：被错误识别为异常的正常周期数。$FP = 300$。\n- 假阴性 ($FN$)：被错误识别为正常的异常周期数。$FN = 30$。\n- 真阴性 ($TN$)：被正确识别为正常的正常周期数。$TN = 9600$。\n\n实际正例（真实异常）的总数是 $AP = TP + FN = 70 + 30 = 100$。\n实际负例（真实正常状态）的总数是 $AN = TN + FP = 9600 + 300 = 9900$。\n预测总数是 $N = TP + TN + FP + FN = 70 + 9600 + 300 + 30 = 10000$。\n\n我们根据精确率、召回率和 $F_1$ 分数的基本定义进行计算。\n\n精确率 ($P$) 定义为真阳性与被分类为阳性的实例总数（即真阳性与假阳性之和）的比率。它衡量的是阳性预测的准确性。\n$$P = \\frac{TP}{TP + FP}$$\n代入给定值：\n$$P = \\frac{70}{70 + 300} = \\frac{70}{370} = \\frac{7}{37}$$\n作为四舍五入到四位有效数字的小数，结果是：\n$$P \\approx 0.1892$$\n\n召回率 ($R$)，也称为灵敏度或真阳性率，定义为真阳性与实际正例总数（即真阳性与假阴性之和）的比率。它衡量分类器找出所有正例的能力。\n$$R = \\frac{TP}{TP + FN}$$\n代入给定值：\n$$R = \\frac{70}{70 + 30} = \\frac{70}{100} = 0.7$$\n表示为四位有效数字，结果是：\n$$R = 0.7000$$\n\n$F_1$ 分数是精确率和召回率的调和平均数。它旨在平衡这两个指标。$F_\\beta$ 分数的一般公式是 $(1+\\beta^2) \\frac{P \\cdot R}{(\\beta^2 \\cdot P) + R}$，对于 $F_1$ 分数，$\\beta=1$。\n$$F_1 = 2 \\cdot \\frac{P \\cdot R}{P + R}$$\n或者，它可以直接用混淆矩阵的各分量表示：\n$$F_1 = \\frac{2TP}{2TP + FP + FN}$$\n为求精确，使用后一个公式：\n$$F_1 = \\frac{2 \\cdot 70}{2 \\cdot 70 + 300 + 30} = \\frac{140}{140 + 330} = \\frac{140}{470} = \\frac{14}{47}$$\n作为四舍五入到四位有效数字的小数，结果是：\n$$F_1 \\approx 0.2979$$\n\n关于类别不平衡的讨论：\n该数据集表现出严重的类别不平衡。正类别（异常）的基准率极低：\n$$\\text{Base Rate} = \\frac{AP}{N} = \\frac{100}{10000} = 0.01$$\n这意味着只有 $1\\%$ 的周期是异常的，而 $99\\%$ 是正常的。这种不平衡严重扭曲了对性能指标的解释。\n\n对精确率的影响是深远的。公式 $P = \\frac{TP}{TP + FP}$ 表明，精确率对假阳性 ($FP$) 的数量很敏感。在高度不平衡的场景中，实际负例 ($AN=9900$) 的数量是巨大的。即使是低的假阳性率 ($FPR = \\frac{FP}{AN} = \\frac{300}{9900} \\approx 0.0303$) 也能产生大量的绝对假阳性数 ($FP=300$)。这些假阳性在精确率计算的分母中压倒了真阳性 ($TP=70$)。计算出的精确率 $P \\approx 0.1892$ 表明，IDS 发出的警报中有超过 $81\\%$ 是错误的。对于控制室的操作员来说，这意味着他们花费在调查警报上的大部分时间都将被浪费，导致警报疲劳和对系统信任的丧失。\n\n召回率，定义为 $R = \\frac{TP}{TP + FN}$，仅以实际正例为条件。其计算独立于真阴性或假阳性的数量。因此，它不受大量负样本的直接扭曲。我们计算出的召回率 $R=0.7000$ 表明 IDS 成功检测出所有发生的真实异常中的 $70\\%$。虽然这看起来是合理的性能，但它没有提供关于错误警报成本的任何信息。一个系统可以通过过度敏感来实现高召回率，将许多正常事件标记为异常，而这恰恰是导致低精确率的原因。\n\n$F_1$ 分数作为精确率和召回率的调和平均数，旨在捕捉这种权衡。由于调和平均数受较小值的影响很大，低精确率 ($P \\approx 0.1892$) 将 $F_1$ 分数拉低至 $F_1 \\approx 0.2979$，尽管召回率要高得多 ($R=0.7000$)。因此，$F_1$ 分数正确地反映了检测器的整体效用因相对于真实检测的错误警报率高得不可接受而较差。\n\n这种情况凸显了为什么像准确率这样的指标在不平衡的背景下可能具有危险的误导性。该 IDS 的准确率为：\n$$\\text{Accuracy} = \\frac{TP + TN}{N} = \\frac{70 + 9600}{10000} = 0.9670$$\n$96.7\\%$ 的准确率乍一看似乎非常出色。然而，一个平凡的“总是正常”分类器将达到 $\\frac{AN}{N} = \\frac{9900}{10000} = 0.99$ 或 $99\\%$ 的准确率。因此，这个复杂的 IDS 在整体准确率方面比一个平凡基线的表现还要差。对精确率和召回率的分析揭示了准确率所掩盖的这一关键弱点。由类别不平衡驱动的低精确率，是检测器实际性能不佳的关键指标，这一事实被低 $F_1$ 分数恰当地总结了。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1892  0.7000  0.2979\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "为了构建强大的防御体系，我们必须首先理解攻击者的能力。本实践让你站在攻击者的角度，体验如何在不被发现的情况下破坏一个系统。在练习  中，你将首先推导一种隐蔽的虚假数据注入（FDI）攻击的数学策略，然后通过编写仿真程序，观察物理系统状态如何在不触发任何警报的情况下被危险地操控。",
            "id": "4228462",
            "problem": "考虑一个标量信息物理系统 (Cyber-Physical System, CPS) 水箱，其水位在离散时间上通过以下状态更新和测量方程进行建模\n$$x_{k+1} = x_k + u_k + w_k,$$\n$$y_k = x_k + v_k + a_k,$$\n其中 $x_k$ 是离散时间 $k$ 时以米为单位的真实水位，$u_k$ 是以米为单位的已知控制输入，$w_k$ 是以米为单位的过程噪声，$v_k$ 是以米为单位的测量噪声，以及 $a_k$ 是以米为单位的附加传感器虚假数据注入 (False Data Injection, FDI) 攻击信号。一个数字孪生观测器采用 Luenberger 结构\n$$\\hat{x}_{k+1} = \\hat{x}_k + u_k + L \\left(y_k - \\hat{x}_k\\right),$$\n其中 $\\hat{x}_k$ 是以米为单位的估计水位，而 $L \\in \\mathbb{R}$ 是一个固定的观测器增益。攻击检测器监测残差\n$r_k = y_k - \\hat{x}_k$,\n并在 $|r_k|$ 偏离零时发出警报。一个全知的对手，完全了解 $x_k$、$\\hat{x}_k$、$u_k$、$v_k$ 和模型，试图通过在每一步强制 $r_k = 0$ 来保持隐蔽。\n\n任务：\n1. 仅使用上述系统定义，从第一性原理出发，推导出一个针对 $a_k$ 的传感器攻击律，该攻击律能对所有 $k$ 强制 $r_k = 0$，然后推导在这种隐蔽攻击下闭环估计误差 $e_k := x_k - \\hat{x}_k$ 的动态特性。\n2. 根据推导出的误差动态特性，得到经过 $N$ 步后的最终物理偏差 $e_N = x_N - \\hat{x}_N$ 关于初始偏差 $e_0$ 和噪声序列 $\\{w_k\\}$ 的表达式。\n3. 在有限时域内实现对被控对象、观测器和隐蔽 FDI 攻击的仿真。该仿真必须精确实现推导出的攻击策略，逐步更新 $x_k$ 和 $\\hat{x}_k$，并计算最终偏差 $e_N$。\n\n物理单位：所有 $x_k$、$\\hat{x}_k$、$u_k$、$w_k$、$v_k$ 和 $a_k$ 都以米为单位。您必须以米为单位报告每个请求的最终偏差 $e_N$，并四舍五入到六位小数。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件：\n仿真以下参数集。每个集合都指定了 $N$、$L$、$x_0$、$\\hat{x}_0$ 以及序列 $\\{u_k\\}_{k=0}^{N-1}$、$\\{w_k\\}_{k=0}^{N-1}$ 和 $\\{v_k\\}_{k=0}^{N-1}$，所有单位均为米。\n\n- 案例 A (正常情况)：$N=5$，$L=0.6$，$x_0=1.0$，$\\hat{x}_0=1.0$，$u=[0.1, 0.1, 0.1, 0.1, 0.1]$，$w=[0.0, 0.02, -0.01, 0.0, 0.03]$，$v=[0.0, 0.0, 0.0, 0.0, 0.0]$。\n- 案例 B (边界情况，完美增益与非零测量噪声)：$N=4$，$L=1.0$，$x_0=1.5$，$\\hat{x}_0=1.7$，$u=[0.0, 0.0, 0.0, 0.0]$，$w=[0.0, 0.0, 0.0, 0.0]$，$v=[0.2, -0.1, 0.05, 0.0]$。\n- 案例 C (边缘情况，零时域)：$N=0$，$L=0.5$，$x_0=0.0$，$\\hat{x}_0=0.0$，$u=[\\,]$，$w=[\\,]$，$v=[\\,]$。\n- 案例 D (混合输入与过程噪声)：$N=6$，$L=0.3$，$x_0=1.0$，$\\hat{x}_0=0.8$，$u=[0.1, -0.05, 0.0, 0.05, 0.1, -0.1]$，$w=[0.02, 0.02, -0.01, 0.0, 0.01, 0.03]$，$v=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$。\n- 案例 E (非零过程噪声与测量噪声)：$N=3$，$L=0.8$，$x_0=2.0$，$\\hat{x}_0=2.0$，$u=[0.05, 0.0, -0.05]$，$w=[0.05, -0.02, 0.04]$，$v=[-0.1, 0.2, 0.0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格。列表中的每个条目是按 A、B、C、D、E 顺序排列的一个测试案例的最终偏差 $e_N$（单位为米）。每个条目必须四舍五入到六位小数，例如，“[0.040000,-0.200000,0.000000,0.270000,0.070000]”。",
            "solution": "该问题是有效的，因为它以线性系统和控制理论的标准原理为科学依据，是适定的、客观的，并为推导和仿真提供了完整且一致的设置。\n\n### 第 1 部分：隐蔽攻击律和误差动态的推导\n\n问题陈述为信息物理系统 (CPS) 和数字孪生观测器提供了以下离散时间模型：\n\n系统状态更新：\n$$x_{k+1} = x_k + u_k + w_k$$\n系统测量：\n$$y_k = x_k + v_k + a_k$$\n观测器状态更新：\n$$\\hat{x}_{k+1} = \\hat{x}_k + u_k + L (y_k - \\hat{x}_k)$$\n残差定义为：\n$$r_k = y_k - \\hat{x}_k$$\n估计误差定义为：\n$$e_k = x_k - \\hat{x}_k$$\n\n**攻击律 $a_k$ 的推导**\n\n一个全知的对手旨在通过对所有时间步 $k$ 强制执行条件 $r_k = 0$ 来保持隐蔽。\n从残差的定义开始：\n$$r_k = y_k - \\hat{x}_k$$\n将残差设为零：\n$$y_k - \\hat{x}_k = 0 \\implies y_k = \\hat{x}_k$$\n这意味着对手必须操纵传感器测量值 $y_k$，使其与观测器当前的状态估计值 $\\hat{x}_k$ 完全相等。\n我们将 $y_k$ 的测量方程代入：\n$$x_k + v_k + a_k = \\hat{x}_k$$\n求解所需的攻击信号 $a_k$，我们得到传感器攻击律：\n$$a_k = \\hat{x}_k - x_k - v_k$$\n正如问题中全知对手的假设所指出的，这种攻击要求对手在每个时间步 $k$ 都完全了解系统的真实状态 $x_k$、观测器的估计状态 $\\hat{x}_k$ 以及测量噪声 $v_k$。\n\n**闭环误差动态的推导**\n\n接下来，我们推导在这种隐蔽攻击下估计误差 $e_k = x_k - \\hat{x}_k$ 的动态特性。下一个时间步的误差 $e_{k+1}$ 为：\n$$e_{k+1} = x_{k+1} - \\hat{x}_{k+1}$$\n代入状态更新 $x_{k+1}$ 和观测器更新 $\\hat{x}_{k+1}$ 的表达式：\n$$e_{k+1} = (x_k + u_k + w_k) - \\left( \\hat{x}_k + u_k + L (y_k - \\hat{x}_k) \\right)$$\n控制输入 $u_k$ 被消去：\n$$e_{k+1} = (x_k - \\hat{x}_k) + w_k - L (y_k - \\hat{x}_k)$$\n注意到 $e_k = x_k - \\hat{x}_k$ 且 $r_k = y_k - \\hat{x}_k$，我们可以将其写为：\n$$e_{k+1} = e_k + w_k - L r_k$$\n这是一般的误差动态方程。现在，我们应用隐蔽攻击条件 $r_k = 0$。方程显著简化为：\n$$e_{k+1} = e_k + w_k - L(0)$$\n$$e_{k+1} = e_k + w_k$$\n这就是指定隐蔽攻击下的闭环估计误差动态。该动态表明，误差演变为过程噪声 $w_k$ 的一个积分器。观测器增益 $L$ 和测量噪声 $v_k$ 已被对手的策略完全抵消了效果。\n\n### 第 2 部分：最终偏差 $e_N$ 的表达式\n\n使用推导出的误差动态 $e_{k+1} = e_k + w_k$，我们可以通过展开递推来找到经过 $N$ 步后的最终偏差 $e_N$ 的闭式表达式：\n当 $k=0$ 时：\n$$e_1 = e_0 + w_0$$\n当 $k=1$ 时：\n$$e_2 = e_1 + w_1 = (e_0 + w_0) + w_1$$\n当 $k=2$ 时：\n$$e_3 = e_2 + w_2 = (e_0 + w_0 + w_1) + w_2$$\n延续此模式，我们可以通过归纳法看出，在任何步骤 $k$ 的误差是初始误差 $e_0$ 加上截至步骤 $k-1$ 的所有过程噪声项之和。对于最终步骤 $N$，此关系为：\n$$e_N = e_0 + \\sum_{k=0}^{N-1} w_k$$\n初始偏差为 $e_0 = x_0 - \\hat{x}_0$。因此，最终偏差为：\n$$e_N = (x_0 - \\hat{x}_0) + \\sum_{k=0}^{N-1} w_k$$\n该表达式表明，在隐蔽攻击下，最终误差仅由初始误差和时域内的累积过程噪声决定。\n\n### 第 3 部分：仿真实现\n\n仿真将在一个 $N$ 步的时域内（从 $k=0$到 $k=N-1$）逐步实现系统和观测器的动态。对于每一步 $k$，仿真将执行以下操作：\n1.  读取当前状态 $x_k$、$\\hat{x}_k$ 和外生输入 $u_k$、$w_k$、$v_k$。\n2.  使用推导出的定律计算隐蔽攻击信号 $a_k$：$a_k = \\hat{x}_k - x_k - v_k$。\n3.  计算被篡改的传感器测量值：$y_k = x_k + v_k + a_k$。根据构造，这将确保 $y_k = \\hat{x}_k$。\n4.  使用其动态更新观测器状态为 $\\hat{x}_{k+1}$：$\\hat{x}_{k+1} = \\hat{x}_k + u_k + L (y_k - \\hat{x}_k)$。由于 $y_k - \\hat{x}_k = 0$，此式简化为 $\\hat{x}_{k+1} = \\hat{x}_k + u_k$。\n5.  使用其动态更新系统的真实状态为 $x_{k+1}$：$x_{k+1} = x_k + u_k + w_k$。\n6.  新的状态 $x_{k+1}$ 和 $\\hat{x}_{k+1}$ 成为下一次迭代的当前状态。\n\n经过 $N$ 次迭代后，仿真将计算出最终状态 $x_N$ 和 $\\hat{x}_N$。然后计算最终偏差 $e_N = x_N - \\hat{x}_N$。对每个测试案例都会计算此值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a CPS, a Luenberger observer, and a stealthy FDI attack.\n    Calculates the final estimation error for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, x0, x_hat0, u, w, v)\n        # Case A: happy path\n        {'N': 5, 'L': 0.6, 'x0': 1.0, 'x_hat0': 1.0, \n         'u': [0.1, 0.1, 0.1, 0.1, 0.1], \n         'w': [0.0, 0.02, -0.01, 0.0, 0.03], \n         'v': [0.0, 0.0, 0.0, 0.0, 0.0]},\n        # Case B: boundary, perfect gain with nonzero measurement noise\n        {'N': 4, 'L': 1.0, 'x0': 1.5, 'x_hat0': 1.7, \n         'u': [0.0, 0.0, 0.0, 0.0], \n         'w': [0.0, 0.0, 0.0, 0.0], \n         'v': [0.2, -0.1, 0.05, 0.0]},\n        # Case C: edge, zero horizon\n        {'N': 0, 'L': 0.5, 'x0': 0.0, 'x_hat0': 0.0, \n         'u': [], 'w': [], 'v': []},\n        # Case D: mixed inputs and process noise\n        {'N': 6, 'L': 0.3, 'x0': 1.0, 'x_hat0': 0.8, \n         'u': [0.1, -0.05, 0.0, 0.05, 0.1, -0.1], \n         'w': [0.02, 0.02, -0.01, 0.0, 0.01, 0.03], \n         'v': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]},\n        # Case E: nonzero process and measurement noise\n        {'N': 3, 'L': 0.8, 'x0': 2.0, 'x_hat0': 2.0, \n         'u': [0.05, 0.0, -0.05], \n         'w': [0.05, -0.02, 0.04], \n         'v': [-0.1, 0.2, 0.0]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        x = case['x0']\n        x_hat = case['x_hat0']\n        u_seq = case['u']\n        w_seq = case['w']\n        v_seq = case['v']\n\n        # Simulation loop from k=0 to N-1\n        # This loop will not execute if N=0, which is the correct behavior.\n        for k in range(N):\n            # Get current inputs and noises for step k\n            u_k = u_seq[k]\n            w_k = w_seq[k]\n            v_k = v_seq[k]\n\n            # 1. Adversary computes the stealthy attack signal a_k to enforce r_k = 0\n            # a_k = x_hat_k - x_k - v_k\n            a_k = x_hat - x - v_k\n\n            # 2. System generates the compromised measurement y_k\n            # y_k = x_k + v_k + a_k\n            y_k = x + v_k + a_k\n\n            # 3. Observer updates its state estimate\n            # The residual r_k = y_k - x_hat is zero by construction of a_k\n            # x_hat_{k+1} = x_hat_k + u_k + L * (y_k - x_hat_k)\n            x_hat_next = x_hat + u_k + L * (y_k - x_hat)\n\n            # 4. Plant updates its true state\n            # x_{k+1} = x_k + u_k + w_k\n            x_next = x + u_k + w_k\n            \n            # 5. Advance time by updating states for the next iteration\n            x = x_next\n            x_hat = x_hat_next\n\n        # After the loop, x and x_hat are x_N and x_hat_N\n        final_deviation = x - x_hat\n        results.append(final_deviation)\n\n    # Format the results into the required single-line string\n    # E.g., \"[0.040000,-0.200000,0.000000,0.270000,0.070000]\"\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the simulation and print the final result.\nsolve()\n```"
        }
    ]
}