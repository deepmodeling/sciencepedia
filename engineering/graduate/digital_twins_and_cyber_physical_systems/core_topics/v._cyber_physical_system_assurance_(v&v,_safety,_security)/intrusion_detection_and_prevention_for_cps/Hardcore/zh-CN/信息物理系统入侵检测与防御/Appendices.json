{
    "hands_on_practices": [
        {
            "introduction": "信息物理系统（CPS）中入侵检测系统的核心任务是区分正常操作和恶意攻击。一种基本方法是监测“残差”，即系统数字孪生模型的预测值与物理传感器的实际测量值之间的差异。此练习将指导您使用经典的Neyman-Pearson框架，根据可接受的误报率，从第一性原理出发，为基于高斯噪声模型的残差设计一个检测阈值。这项实践对于理解检测理论中灵敏度与特异性之间的基本权衡至关重要。",
            "id": "4228432",
            "problem": "一个信息物理系统（CPS）采用数字孪生来预测传感器输出。设离散时间索引 $k$ 处的残差定义为 $r_{k} = y_{k} - \\hat{y}_{k}$，其中 $y_{k}$ 是测量输出，$\\hat{y}_{k}$ 是数字孪生的预测值。一个入侵检测系统（IDS）监控 $|r_{k}|$ 以检测执行器或传感器欺骗攻击，这些攻击在攻击假设下表现为均值偏移。在无攻击假设 $H_{0}$ 下，由于传感器噪声和模型失配，残差 $r_{k}$ 被建模为均值为零、方差为 $\\sigma^{2}$ 的高斯分布，即 $r_{k} \\sim \\mathcal{N}(0,\\sigma^{2})$。在攻击假设 $H_{1}$ 下，残差分布的均值发生偏移，但方差近似保持为 $\\sigma^{2}$。使用 Neyman-Pearson 框架，设计一个双边标量阈值 $\\tau$ 用于检验，当 $|r_{k}|  \\tau$ 时拒绝 $H_{0}$，使得误报概率对于给定的设计参数 $\\alpha \\in (0,1)$ 满足 $\\mathbb{P}(|r_{k}|  \\tau \\mid H_{0}) = \\alpha$。从高斯尾部概率和 Neyman-Pearson 准则的基本定义出发，推导出 $\\tau$ 关于 $\\alpha$ 和 $\\sigma$ 的显式闭式表达式。以符号形式表示您的最终答案；不需要数值近似。",
            "solution": "首先对问题陈述进行验证，以确保其科学上合理、适定且客观。\n\n### 步骤 1：提取已知条件\n- 离散时间索引 $k$ 处的残差定义为 $r_{k} = y_{k} - \\hat{y}_{k}$。\n- $y_{k}$ 是来自信息物理系统（CPS）的测量输出。\n- $\\hat{y}_{k}$ 是来自数字孪生的预测输出。\n- 零假设 $H_{0}$ 对应于无攻击情景。\n- 在 $H_{0}$ 下，残差 $r_{k}$ 服从均值为零、方差为 $\\sigma^{2}$ 的高斯分布：$r_{k} \\sim \\mathcal{N}(0,\\sigma^{2})$。\n- 备择假设 $H_{1}$ 对应于残差均值发生偏移的攻击情景。\n- 入侵检测系统（IDS）采用决策规则：如果残差的绝对值超过阈值 $\\tau$，即 $|r_{k}|  \\tau$，则拒绝 $H_{0}$。\n- 误报概率被约束为 $\\mathbb{P}(|r_{k}|  \\tau \\mid H_{0}) = \\alpha$。\n- 参数 $\\alpha$ 是一个给定的设计参数，满足 $\\alpha \\in (0,1)$。\n- 目标是推导出阈值 $\\tau$ 关于 $\\alpha$ 和 $\\sigma$ 的闭式表达式。\n\n### 步骤 2：使用提取的已知条件进行验证\n基于提取的信息，对问题进行严格审查。\n\n- **科学基础**：该问题在统计检测理论中有充分的依据，该理论是信号处理和控制工程的核心学科。将噪声和模型失配建模为零均值高斯过程是一种标准且被广泛接受的做法。使用 Neyman-Pearson 框架设计具有固定误报率的检测器是假设检验中的一个基本概念。该问题在科学和数学上是合理的。\n- **适定性**：该问题是适定的。它提供了足够的信息来确定阈值 $\\tau$ 的一个唯一、稳定且有意义的解。对于高斯分布，误报概率 $\\alpha$ 和阈值 $\\tau$ 之间的关系是单调的，这确保了对于任何有效的 $\\alpha$ 都存在唯一的解。\n- **客观性**：该问题使用精确、无歧义且客观的技术语言进行陈述。没有主观或基于观点的论断。\n\n### 步骤 3：结论与行动\n该问题被认为是有效的，因为它科学合理、适定且客观。验证标准中列出的缺陷均不存在。因此，将推导完整的解。\n\n### 求解推导\n目标是确定满足指定误报概率的阈值 $\\tau$。误报概率是在零假设 $H_{0}$ 实际为真时拒绝它的概率。\n\n决策规则是如果 $|r_{k}|  \\tau$，则拒绝 $H_{0}$。因此，误报概率 $\\alpha$ 由以下条件给出：\n$$\n\\mathbb{P}(|r_{k}|  \\tau \\mid H_{0}) = \\alpha\n$$\n在零假设 $H_{0}$ 下，残差 $r_{k}$ 的分布为 $r_{k} \\sim \\mathcal{N}(0, \\sigma^{2})$。\n\n事件 $|r_{k}|  \\tau$ 等价于两个不相交事件的并集：$r_{k}  \\tau$ 或 $r_{k}  -\\tau$。因此，该概率可以写为：\n$$\n\\mathbb{P}(|r_{k}|  \\tau \\mid H_{0}) = \\mathbb{P}(r_{k}  \\tau \\mid H_{0}) + \\mathbb{P}(r_{k}  -\\tau \\mid H_{0})\n$$\n高斯分布 $\\mathcal{N}(0, \\sigma^{2})$ 关于其均值 $0$ 是对称的。这种对称性意味着两个尾部的概率相等：\n$$\n\\mathbb{P}(r_{k}  \\tau \\mid H_{0}) = \\mathbb{P}(r_{k}  -\\tau \\mid H_{0})\n$$\n将此代入 $\\alpha$ 的表达式中，我们得到：\n$$\n\\alpha = 2 \\cdot \\mathbb{P}(r_{k}  \\tau \\mid H_{0})\n$$\n由此，我们可以分离出单边尾部概率：\n$$\n\\mathbb{P}(r_{k}  \\tau \\mid H_{0}) = \\frac{\\alpha}{2}\n$$\n为了计算这个概率，我们对随机变量 $r_{k}$ 进行标准化。设 $Z$ 是一个标准正态随机变量，$Z \\sim \\mathcal{N}(0, 1)$。我们可以写成 $r_{k} = \\sigma Z$。那么不等式 $r_{k}  \\tau$ 等价于 $\\sigma Z  \\tau$，或 $Z  \\frac{\\tau}{\\sigma}$。\n\n概率条件变为：\n$$\n\\mathbb{P}\\left(Z  \\frac{\\tau}{\\sigma}\\right) = \\frac{\\alpha}{2}\n$$\n设 $\\Phi(z)$ 是标准正态分布的累积分布函数（CDF），定义为 $\\Phi(z) = \\mathbb{P}(Z \\le z)$。尾部概率可以用 CDF 表示为：\n$$\n\\mathbb{P}(Z  z) = 1 - \\mathbb{P}(Z \\le z) = 1 - \\Phi(z)\n$$\n将此应用于我们的方程，其中 $z = \\frac{\\tau}{\\sigma}$：\n$$\n1 - \\Phi\\left(\\frac{\\tau}{\\sigma}\\right) = \\frac{\\alpha}{2}\n$$\n我们现在可以解出 CDF 的参数：\n$$\n\\Phi\\left(\\frac{\\tau}{\\sigma}\\right) = 1 - \\frac{\\alpha}{2}\n$$\n为了分离出 $\\frac{\\tau}{\\sigma}$，我们应用标准正态 CDF 的反函数，即分位数函数，记为 $\\Phi^{-1}$。分位数函数 $\\Phi^{-1}(p)$ 返回使得 $\\mathbb{P}(Z \\le z) = p$ 的值 $z$。\n$$\n\\frac{\\tau}{\\sigma} = \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)\n$$\n最后，解出阈值 $\\tau$，我们得到显式的闭式表达式：\n$$\n\\tau = \\sigma \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)\n$$\n这个表达式提供了所需的双边标量阈值 $\\tau$，它是已知系统参数 $\\sigma$ 和期望误报概率 $\\alpha$ 的函数。项 $\\Phi^{-1}(1 - \\frac{\\alpha}{2})$ 代表了标准正态分布中对应于上尾概率为 $\\frac{\\alpha}{2}$ 的临界值。",
            "answer": "$$\n\\boxed{\\sigma \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2}\\right)}\n$$"
        },
        {
            "introduction": "设计检测器后，评估其在真实场景中的性能至关重要。此练习将带您从理论走向实践，通过分析一个入侵检测系统在模拟水分配网络中的性能输出来评估其有效性。您将计算如精确率（precision）、召回率（recall）和 $F_1$ 分数等关键指标，并深入探讨在CPS安全领域中普遍存在的类别不平衡问题（即攻击事件远少于正常事件）如何扭曲这些指标，以及为何像准确率（accuracy）这样的指标可能会产生误导。",
            "id": "4228486",
            "problem": "一个信息物理系统（CPS）供水管网的数字孪生（DT）被用于生成带标签的运行数据，以评估一个入侵检测系统（IDS）。该数字孪生运行一个基于物理的液压动力学仿真，并注入对抗性的执行器命令序列和传感器欺骗轨迹，以产生地面真实（ground-truth）的异常。在一个覆盖 $10000$ 个离散控制周期的单一评估窗口中，数字孪生将 $100$ 个周期标记为真实异常，将 $9900$ 个周期标记为真实正常。入侵检测系统基于数字孪生预测状态与观测状态之间的残差来标记异常周期。由此产生的混淆计数为：真正例（$TP$）$=70$，假正例（$FP$）$=300$，假反例（$FN$）$=30$，以及真反例（$TN$）$=9600$。\n\n仅从二元检测中条件事件分类质量的核心定义出发，计算该检测器的精确率 $P$、召回率 $R$ 和 $F_{1}$ 分数 $F_{1}$。将 $P$、$R$ 和 $F_{1}$ 均表示为小数，并四舍五入到四位有效数字。\n\n计算出这些值后，讨论CPS中严重的类别不平衡（即真实异常以很低的基础率出现）如何扭曲这些指标，并解释为什么这可能导致对检测器性能得出误导性结论。你的讨论应将计算出的值与不平衡问题联系起来，并基于基本定义进行推理，而不使用这些定义之外的任何捷径公式。",
            "solution": "该问题要求计算一个二元分类器的三个标准性能指标——精确率（$P$）、召回率（$R$）和 $F_1$ 分数——并随后讨论类别不平衡对这些指标的影响。\n\n首先，我们从入侵检测系统（IDS）评估得出的混淆矩阵中确定给定的量：\n- 真正例（$TP$）：被正确识别为异常的异常周期数。$TP = 70$。\n- 假正例（$FP$）：被错误识别为异常的正常周期数。$FP = 300$。\n- 假反例（$FN$）：被错误识别为正常的异常周期数。$FN = 30$。\n- 真反例（$TN$）：被正确识别为正常的正常周期数。$TN = 9600$。\n\n实际正例（真实异常）的总数为 $AP = TP + FN = 70 + 30 = 100$。\n实际反例（真实正常状态）的总数为 $AN = TN + FP = 9600 + 300 = 9900$。\n预测总数为 $N = TP + TN + FP + FN = 70 + 9600 + 300 + 30 = 10000$。\n\n我们继续根据基本定义计算精确率、召回率和 $F_1$ 分数。\n\n精确率（$P$）定义为真正例与被分类为正例的总实例数（即真正例与假正例之和）之比。它衡量的是正例预测的准确性。\n$$P = \\frac{TP}{TP + FP}$$\n代入给定值：\n$$P = \\frac{70}{70 + 300} = \\frac{70}{370} = \\frac{7}{37}$$\n作为小数并四舍五入到四位有效数字，结果是：\n$$P \\approx 0.1892$$\n\n召回率（$R$），也称为灵敏度或真正例率，定义为真正例与实际正例总数（即真正例与假反例之和）之比。它衡量分类器找出所有正例的能力。\n$$R = \\frac{TP}{TP + FN}$$\n代入给定值：\n$$R = \\frac{70}{70 + 30} = \\frac{70}{100} = 0.7$$\n表示为四位有效数字，结果是：\n$$R = 0.7000$$\n\n$F_1$ 分数是精确率和召回率的调和平均数。它旨在平衡这两个指标。$F_\\beta$ 分数的一般公式是 $(1+\\beta^2) \\frac{P \\cdot R}{(\\beta^2 \\cdot P) + R}$，对于 $F_1$，$\\beta=1$。\n$$F_1 = 2 \\cdot \\frac{P \\cdot R}{P + R}$$\n或者，它可以直接用混淆矩阵的各分量表示：\n$$F_1 = \\frac{2TP}{2TP + FP + FN}$$\n为求精确，使用后一个公式：\n$$F_1 = \\frac{2 \\cdot 70}{2 \\cdot 70 + 300 + 30} = \\frac{140}{140 + 330} = \\frac{140}{470} = \\frac{14}{47}$$\n作为小数并四舍五入到四位有效数字，结果是：\n$$F_1 \\approx 0.2979$$\n\n关于类别不平衡的讨论：\n该数据集表现出严重的类别不平衡。正例类别（异常）的基础率极低：\n$$\\text{Base Rate} = \\frac{AP}{N} = \\frac{100}{10000} = 0.01$$\n这意味着只有 $1\\%$ 的周期是异常的，而 $99\\%$ 是正常的。这种不平衡显著地扭曲了对性能指标的解读。\n\n对精确率的影响是深远的。公式 $P = \\frac{TP}{TP + FP}$ 表明，精确率对假正例（$FP$）的数量很敏感。在高度不平衡的场景中，实际反例（$AN=9900$）的数量非常庞大。即使一个较低的假正例率（$FPR = \\frac{FP}{AN} = \\frac{300}{9900} \\approx 0.0303$）也能产生大量的绝对假正例数（$FP=300$）。在精确率的计算中，这些假正例在分母中压倒了真正例（$TP=70$）。计算出的精确率 $P \\approx 0.1892$ 表明，IDS发出的警报中超过 $81\\%$ 是错误的。对于控制室的操作员来说，这意味着他们花费在调查警报上的大部分时间都将被浪费，从而导致警报疲劳和对系统信任的丧失。\n\n召回率，定义为 $R = \\frac{TP}{TP + FN}$，仅以实际正例为条件。它的计算独立于真反例或假正例的数量。因此，它不会被大量的反例样本直接扭曲。我们计算出的召回率 $R=0.7000$ 表示IDS成功检测出所有发生的真实异常中的 $70\\%$。虽然这看起来性能尚可，但它没有提供关于误报代价的任何信息。一个系统可以通过过度敏感来实现高召回率，将许多正常事件标记为异常，而这正是导致低精确率的原因。\n\n$F_1$ 分数作为精确率和召回率的调和平均数，旨在捕捉这种权衡。由于调和平均数受较小值的影响很大，尽管召回率（$R=0.7000$）高得多，但低精确率（$P \\approx 0.1892$）将 $F_1$ 分数拉低至 $F_1 \\approx 0.2979$。$F_1$ 分数因此正确地反映出，由于相对于真实检测的误报率高得无法接受，检测器的整体效用很差。\n\n这种情况凸显了为什么像准确率这样的指标在不平衡的背景下可能具有危险的误导性。该IDS的准确率为：\n$$\\text{Accuracy} = \\frac{TP + TN}{N} = \\frac{70 + 9600}{10000} = 0.9670$$\n$96.7\\%$ 的准确率乍一看似乎非常出色。然而，一个简单的“永远正常”分类器将达到 $\\frac{AN}{N} = \\frac{9900}{10000} = 0.99$，即 $99\\%$ 的准确率。因此，在整体准确率方面，这个复杂的IDS的表现比一个简单的基线还要差。对精确率和召回率的分析揭示了这一被准确率所掩盖的关键弱点。由类别不平衡导致的低精确率，是检测器实际性能不佳的关键指标，而低 $F_1$ 分数恰当地总结了这一事实。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1892  0.7000  0.2979\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "为了构建更具弹性的系统，我们必须理解攻击者的思维方式和攻击策略。此练习将让您扮演一个高级攻击者的角色，其目标是在不被发现的情况下破坏物理过程。您将推导并模拟一种“隐蔽”的虚假数据注入（FDI）攻击，该攻击巧妙地操纵传感器读数，以在破坏物理水箱系统的同时，欺骗基于数字孪生的观测器，从而使其完全无法察觉。这项实践揭示了确保状态估计完整性所面临的严峻挑战，并提供了对高级攻击向量的深刻见解。",
            "id": "4228462",
            "problem": "考虑一个标量信息物理系统 (CPS) 水箱水位模型，其在离散时间下的状态更新和量测方程由下式给出\n$$x_{k+1} = x_k + u_k + w_k,$$\n$$y_k = x_k + v_k + a_k,$$\n其中 $x_k$ 是离散时间 $k$ 时的真实水位（单位：米），$u_k$ 是已知的控制输入（单位：米），$w_k$ 是过程噪声（单位：米），$v_k$ 是量测噪声（单位：米），$a_k$ 是加性传感器虚假数据注入 (FDI) 攻击信号（单位：米）。一个数字孪生观测器采用 Luenberger 结构\n$$\\hat{x}_{k+1} = \\hat{x}_k + u_k + L \\left(y_k - \\hat{x}_k\\right),$$\n其中 $\\hat{x}_k$ 是估计的水位（单位：米），$L \\in \\mathbb{R}$ 是一个固定的观测器增益。攻击检测器监测残差\n$$r_k = y_k - \\hat{x}_k,$$\n并在 $|r_k|$ 偏离零时发出警报。一个全知对手，完全了解 $x_k$、$\\hat{x}_k$、$u_k$、$v_k$ 和模型，试图通过在每一步强制 $r_k = 0$ 来保持隐蔽。\n\n任务：\n1. 仅使用上述系统定义，从第一性原理推导出一个传感器攻击法则 $a_k$，该法则对所有 $k$ 强制 $r_k = 0$，然后推导在这种隐蔽攻击下闭环估计误差动态 $e_k := x_k - \\hat{x}_k$。\n2. 从推导出的误差动态中，获得经过 $N$ 步后的最终物理偏差 $e_N = x_N - \\hat{x}_N$ 的表达式，该表达式是初始偏差 $e_0$ 和噪声序列 $\\{w_k\\}$ 的函数。\n3. 在有限时域内实现对被控对象、观测器和隐蔽 FDI 攻击的仿真。该仿真必须精确实现推导出的攻击策略，逐步更新 $x_k$ 和 $\\hat{x}_k$，并计算最终偏差 $e_N$。\n\n物理单位：所有 $x_k$、$\\hat{x}_k$、$u_k$、$w_k$、$v_k$ 和 $a_k$ 的单位均为米。您必须以米为单位报告每个所要求的最终偏差 $e_N$，并四舍五入到六位小数。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n测试套件：\n仿真以下参数集。每个集合都指定了 $N$、$L$、$x_0$、$\\hat{x}_0$ 以及序列 $\\{u_k\\}_{k=0}^{N-1}$、$\\{w_k\\}_{k=0}^{N-1}$ 和 $\\{v_k\\}_{k=0}^{N-1}$，所有单位均为米。\n\n- 案例 A (理想情况)：$N=5$, $L=0.6$, $x_0=1.0$, $\\hat{x}_0=1.0$, $u=[0.1, 0.1, 0.1, 0.1, 0.1]$, $w=[0.0, 0.02, -0.01, 0.0, 0.03]$, $v=[0.0, 0.0, 0.0, 0.0, 0.0]$。\n- 案例 B (边界情况，存在非零量测噪声的完美增益)：$N=4$, $L=1.0$, $x_0=1.5$, $\\hat{x}_0=1.7$, $u=[0.0, 0.0, 0.0, 0.0]$, $w=[0.0, 0.0, 0.0, 0.0]$, $v=[0.2, -0.1, 0.05, 0.0]$。\n- 案例 C (边缘情况，零时域)：$N=0$, $L=0.5$, $x_0=0.0$, $\\hat{x}_0=0.0$, $u=[\\,]$, $w=[\\,]$, $v=[\\,]$。\n- 案例 D (混合输入和过程噪声)：$N=6$, $L=0.3$, $x_0=1.0$, $\\hat{x}_0=0.8$, $u=[0.1, -0.05, 0.0, 0.05, 0.1, -0.1]$, $w=[0.02, 0.02, -0.01, 0.0, 0.01, 0.03]$, $v=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]$。\n- 案例 E (非零过程噪声和量测噪声)：$N=3$, $L=0.8$, $x_0=2.0$, $\\hat{x}_0=2.0$, $u=[0.05, 0.0, -0.05]$, $w=[0.05, -0.02, 0.04]$, $v=[-0.1, 0.2, 0.0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格。列表中的每个条目是按 A、B、C、D、E 顺序排列的一个测试案例的最终偏差 $e_N$（单位：米）。每个条目必须四舍五入到六位小数，例如：“[0.040000,-0.200000,0.000000,0.270000,0.070000]”。",
            "solution": "该问题是有效的，因为它科学地基于线性系统和控制理论的标准原理，问题陈述清晰，客观，并为推导和仿真提供了完整且一致的设置。\n\n### 第 1 部分：隐蔽攻击法则和误差动态的推导\n\n问题陈述为信息物理系统 (CPS) 和数字孪生观测器提供了以下离散时间模型：\n\n系统状态更新：\n$$x_{k+1} = x_k + u_k + w_k$$\n系统量测：\n$$y_k = x_k + v_k + a_k$$\n观测器状态更新：\n$$\\hat{x}_{k+1} = \\hat{x}_k + u_k + L (y_k - \\hat{x}_k)$$\n残差定义为：\n$$r_k = y_k - \\hat{x}_k$$\n估计误差定义为：\n$$e_k = x_k - \\hat{x}_k$$\n\n**攻击法则 $a_k$ 的推导**\n\n一个全知对手旨在通过在所有时间步 $k$ 强制条件 $r_k = 0$ 来保持隐蔽。\n从残差的定义开始：\n$$r_k = y_k - \\hat{x}_k$$\n将残差设为零：\n$$y_k - \\hat{x}_k = 0 \\implies y_k = \\hat{x}_k$$\n这意味着对手必须操纵传感器量测值 $y_k$，使其与观测器当前的状态估计值 $\\hat{x}_k$ 完全相等。\n我们代入 $y_k$ 的量测方程：\n$$x_k + v_k + a_k = \\hat{x}_k$$\n求解所需的攻击信号 $a_k$，我们得到传感器攻击法则：\n$$a_k = \\hat{x}_k - x_k - v_k$$\n根据问题中全知对手的假设，此攻击要求对手在每个时间步 $k$ 都完全了解系统的真实状态 $x_k$、观测器的估计状态 $\\hat{x}_k$ 以及量测噪声 $v_k$。\n\n**闭环误差动态的推导**\n\n接下来，我们推导在这种隐蔽攻击下估计误差 $e_k = x_k - \\hat{x}_k$ 的动态。下一时间步的误差 $e_{k+1}$ 是：\n$$e_{k+1} = x_{k+1} - \\hat{x}_{k+1}$$\n代入状态更新 $x_{k+1}$ 和观测器更新 $\\hat{x}_{k+1}$ 的表达式：\n$$e_{k+1} = (x_k + u_k + w_k) - \\left( \\hat{x}_k + u_k + L (y_k - \\hat{x}_k) \\right)$$\n控制输入 $u_k$ 被消去：\n$$e_{k+1} = (x_k - \\hat{x}_k) + w_k - L (y_k - \\hat{x}_k)$$\n注意到 $e_k = x_k - \\hat{x}_k$ 和 $r_k = y_k - \\hat{x}_k$，我们可以将其写为：\n$$e_{k+1} = e_k + w_k - L r_k$$\n这是一般的误差动态方程。现在，我们应用隐蔽攻击条件 $r_k = 0$。方程显著简化为：\n$$e_{k+1} = e_k + w_k - L(0)$$\n$$e_{k+1} = e_k + w_k$$\n这就是在指定隐蔽攻击下的闭环估计误差动态。该动态表明，误差的演化如同过程噪声 $w_k$ 的积分器。观测器增益 $L$ 和量测噪声 $v_k$ 已被对手的策略完全抵消了作用。\n\n### 第 2 部分：最终偏差 $e_N$ 的表达式\n\n使用推导出的误差动态 $e_{k+1} = e_k + w_k$，我们可以通过展开递归来找到 $N$ 步后最终偏差 $e_N$ 的闭式表达式：\n当 $k=0$ 时：\n$$e_1 = e_0 + w_0$$\n当 $k=1$ 时：\n$$e_2 = e_1 + w_1 = (e_0 + w_0) + w_1$$\n当 $k=2$ 时：\n$$e_3 = e_2 + w_2 = (e_0 + w_0 + w_1) + w_2$$\n延续此模式，我们可以通过归纳法看出，在任意步骤 $k$ 的误差是初始误差 $e_0$ 加上截至步骤 $k-1$ 的所有过程噪声项的总和。对于最终步骤 $N$，此关系为：\n$$e_N = e_0 + \\sum_{k=0}^{N-1} w_k$$\n初始偏差为 $e_0 = x_0 - \\hat{x}_0$。因此，最终偏差为：\n$$e_N = (x_0 - \\hat{x}_0) + \\sum_{k=0}^{N-1} w_k$$\n该表达式表明，在隐蔽攻击下，最终误差仅由初始误差和时域范围内的累积过程噪声决定。\n\n### 第 3 部分：仿真实现\n\n仿真将从 $k=0$ 到 $k=N-1$，在 $N$ 步的时域内逐步实现系统和观测器的动态。对于每一步 $k$，仿真将执行以下操作：\n1. 读取当前状态 $x_k$、$\\hat{x}_k$ 以及外生输入 $u_k$、$w_k$、$v_k$。\n2. 使用推导出的法则计算隐蔽攻击信号 $a_k$：$a_k = \\hat{x}_k - x_k - v_k$。\n3. 计算被篡改的传感器量测值：$y_k = x_k + v_k + a_k$。根据构造，这将确保 $y_k = \\hat{x}_k$。\n4. 使用其动态更新观测器状态为 $\\hat{x}_{k+1}$：$\\hat{x}_{k+1} = \\hat{x}_k + u_k + L (y_k - \\hat{x}_k)$。由于 $y_k - \\hat{x}_k = 0$，此式简化为 $\\hat{x}_{k+1} = \\hat{x}_k + u_k$。\n5. 使用其动态更新系统真实状态为 $x_{k+1}$：$x_{k+1} = x_k + u_k + w_k$。\n6. 新状态 $x_{k+1}$ 和 $\\hat{x}_{k+1}$ 成为下一次迭代的当前状态。\n\n经过 $N$ 次迭代后，仿真将计算出最终状态 $x_N$ 和 $\\hat{x}_N$。然后计算最终偏差为 $e_N = x_N - \\hat{x}_N$。对每个测试案例都会计算此值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a CPS, a Luenberger observer, and a stealthy FDI attack.\n    Calculates the final estimation error for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, x0, x_hat0, u, w, v)\n        # Case A: happy path\n        {'N': 5, 'L': 0.6, 'x0': 1.0, 'x_hat0': 1.0, \n         'u': [0.1, 0.1, 0.1, 0.1, 0.1], \n         'w': [0.0, 0.02, -0.01, 0.0, 0.03], \n         'v': [0.0, 0.0, 0.0, 0.0, 0.0]},\n        # Case B: boundary, perfect gain with nonzero measurement noise\n        {'N': 4, 'L': 1.0, 'x0': 1.5, 'x_hat0': 1.7, \n         'u': [0.0, 0.0, 0.0, 0.0], \n         'w': [0.0, 0.0, 0.0, 0.0], \n         'v': [0.2, -0.1, 0.05, 0.0]},\n        # Case C: edge, zero horizon\n        {'N': 0, 'L': 0.5, 'x0': 0.0, 'x_hat0': 0.0, \n         'u': [], 'w': [], 'v': []},\n        # Case D: mixed inputs and process noise\n        {'N': 6, 'L': 0.3, 'x0': 1.0, 'x_hat0': 0.8, \n         'u': [0.1, -0.05, 0.0, 0.05, 0.1, -0.1], \n         'w': [0.02, 0.02, -0.01, 0.0, 0.01, 0.03], \n         'v': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]},\n        # Case E: nonzero process and measurement noise\n        {'N': 3, 'L': 0.8, 'x0': 2.0, 'x_hat0': 2.0, \n         'u': [0.05, 0.0, -0.05], \n         'w': [0.05, -0.02, 0.04], \n         'v': [-0.1, 0.2, 0.0]}\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        L = case['L']\n        x = case['x0']\n        x_hat = case['x_hat0']\n        u_seq = case['u']\n        w_seq = case['w']\n        v_seq = case['v']\n\n        # Simulation loop from k=0 to N-1\n        # This loop will not execute if N=0, which is the correct behavior.\n        for k in range(N):\n            # Get current inputs and noises for step k\n            u_k = u_seq[k]\n            w_k = w_seq[k]\n            v_k = v_seq[k]\n\n            # 1. Adversary computes the stealthy attack signal a_k to enforce r_k = 0\n            # a_k = x_hat_k - x_k - v_k\n            a_k = x_hat - x - v_k\n\n            # 2. System generates the compromised measurement y_k\n            # y_k = x_k + v_k + a_k\n            y_k = x + v_k + a_k\n\n            # 3. Observer updates its state estimate\n            # The residual r_k = y_k - x_hat is zero by construction of a_k\n            # x_hat_{k+1} = x_hat_k + u_k + L * (y_k - x_hat_k)\n            x_hat_next = x_hat + u_k + L * (y_k - x_hat)\n\n            # 4. Plant updates its true state\n            # x_{k+1} = x_k + u_k + w_k\n            x_next = x + u_k + w_k\n            \n            # 5. Advance time by updating states for the next iteration\n            x = x_next\n            x_hat = x_hat_next\n\n        # After the loop, x and x_hat are x_N and x_hat_N\n        final_deviation = x - x_hat\n        results.append(final_deviation)\n\n    # Format the results into the required single-line string\n    # E.g., \"[0.040000,-0.200000,0.000000,0.270000,0.070000]\"\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the simulation and print the final result.\nsolve()\n```"
        }
    ]
}