{
    "hands_on_practices": [
        {
            "introduction": "在网络物理系统 (CPS) 中，数字证书是设备身份和权限的基石。然而，证书并非“一刀切”的；其内容必须精确地反映其预定用途，以遵循最小权限原则。本练习将指导您为一个需要支持 TLS 客户端认证和代码签名的传感器设计一个最优的 X.509 证书配置文件，重点是正确选择 `keyUsage` 和 `extendedKeyUsage` 扩展，这对于任何 PKI 架构师来说都是一项基础而关键的技能 。",
            "id": "4237459",
            "problem": "一个信息物理系统 (CPS) 部署使用了一组嵌入式传感器，这些传感器必须通过传输层安全性协议 (TLS) $1.3$ 使用客户端认证与网关服务进行相互认证，并且还必须接受通过代码签名验证其真实性的空中下载 (over-the-air) 固件包。每个传感器都配置有一个终端实体 X.509 证书，而不是证书颁发机构 (CA) 证书。公钥基础设施 (PKI) 遵循 RFC $5280$ 的语义：密钥用法扩展限制了主题公钥允许的操作，增强密钥用法扩展指明了证书可用于的特定目的，而扩展上的关键标志表示如果信赖方不理解该扩展，则必须拒绝该证书。\n\n从以下基本事实出发：\n- 在 X.509 中，密钥用法扩展列举了比特级别的权限，例如数字签名创建、密钥加密和密钥协商。这些比特位限制了主题公钥允许的操作，存在与实际使用的协议不对应的比特位违反了最小权限安全原则。\n- 在 X.509 中，增强密钥用法 (EKU) 扩展使用对象标识符 (OID) 指定应用级别的目的。对于 TLS 客户端认证，EKU `id-kp-clientAuth` 的 OID 为 $1.3.6.1.5.5.7.3.2$。对于代码签名，EKU `id-kp-codeSigning` 的 OID 为 $1.3.6.1.5.5.7.3.3$。\n- TLS $1.3$ 使用 `CertificateVerify` 消息，其中客户端通过计算通信记录（transcript）的数字签名来证明其拥有私钥；TLS $1.3$ 不使用静态 RSA 密钥传输，因此不需要密钥加密。固件代码签名同样依赖于对软件工件的数字签名。\n- 在 RFC $5280$ 中，如果一个扩展被标记为关键 (critical)，不理解该扩展的客户端必须拒绝该证书。密钥用法扩展通常被标记为关键，以确保信赖方正确强制执行公钥约束。增强密钥用法扩展通常是非关键的 (non-critical)，以保持兼容性，同时仍为知晓此扩展的应用程序提供目的约束。基本约束扩展指示 CA 能力；传感器的终端实体证书不得声明具有 CA 能力。\n\n设计一个适用于支持 TLS $1.3$ 下的 TLS 客户端认证和代码签名的 CPS 传感器的终端实体证书配置文件，通过选择正确的密钥用法比特位和增强密钥用法 OID 的组合，并指明哪些扩展必须标记为关键以强制执行正确的行为而不破坏兼容性。哪个选项最合适？\n\nA. `keyUsage` 设置了 `digitalSignature`；没有 `keyEncipherment`、`keyAgreement` 和 `keyCertSign`；`keyUsage` 标记为关键 (critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键 (non-critical)。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)（或省略）。没有 `anyExtendedKeyUsage` ($2.5.29.37.0$) 。`Subject Alternative Name` 携带一个设备标识符且为非关键 (non-critical)。\n\nB. `keyUsage` 设置了 `digitalSignature` 和 `keyEncipherment`；`keyUsage` 为非关键 (non-critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为关键 (critical)。`basicConstraints` 被省略。\n\nC. `keyUsage` 设置了 `digitalSignature` 且为非关键 (non-critical)。`extendedKeyUsage` 仅包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)；没有代码签名 EKU。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)。\n\nD. `keyUsage` 设置了 `contentCommitment` (`nonRepudiation`) 但没有 `digitalSignature`；`keyUsage` 为关键 (critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键 (non-critical)。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)。\n\nE. `keyUsage` 设置了 `digitalSignature` 且为关键 (critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)、`id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$) 和 `anyExtendedKeyUsage` ($2.5.29.37.0$)；`extendedKeyUsage` 为非关键 (non-critical)。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)。\n\n选择唯一的最佳选项。",
            "solution": "用户要求为信息物理系统 (CPS) 传感器设计并选择一个合适的 X.509 证书配置文件。分析将分两个阶段进行：问题验证，然后是解决方案的详细推导和对所提供选项的评估。\n\n### 问题验证\n\n首先，必须验证问题陈述的科学合理性、一致性和客观性。\n\n#### 步骤1：提取已知条件\n\n问题提供了以下数据和约束：\n- **系统**：一个包含嵌入式传感器的 CPS 部署。\n- **用例1**：通过传输层安全性协议 (TLS) $1.3$ 使用客户端认证与网关服务进行相互认证。\n- **用例2**：通过代码签名验证空中下载的固件包。\n- **证书类型**：每个传感器都配置有终端实体 X.509 证书，而不是证书颁发机构 (CA) 证书。\n- **遵循标准**：公钥基础设施 (PKI) 遵循 RFC $5280$。\n- **基本事实1 (keyUsage)**：`keyUsage` 扩展包含比特级别的权限。其目的是限制主题公钥的操作。设置未使用的比特位违反了最小权限原则，是不可取的。\n- **基本事实2 (extendedKeyUsage)**：`extendedKeyUsage` (EKU) 扩展使用对象标识符 (OID) 指定应用级别的目的。TLS 客户端认证使用 `id-kp-clientAuth` (OID $1.3.6.1.5.5.7.3.2$)。代码签名使用 `id-kp-codeSigning` (OID $1.3.6.1.5.5.7.3.3$)。\n- **基本事实3 (协议)**：TLS $1.3$ 客户端认证涉及客户端在 `CertificateVerify` 消息中计算通信记录的数字签名。TLS $1.3$ 不使用静态 RSA 密钥传输，因此不需要 `keyEncipherment`。固件代码签名依赖于数字签名。\n- **基本事实4 (扩展与关键性)**：如果一个扩展被标记为`critical` (关键)，不理解它的信赖方必须拒绝该证书。`keyUsage` 通常被标记为`critical`以实现严格强制。`extendedKeyUsage` 通常为`non-critical` (非关键) 以保证兼容性。`basicConstraints` 指示 CA 能力；终端实体证书不得声明具有 CA 能力。\n\n#### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行分析。\n\n- **科学依据**：问题紧密基于已建立的现实世界标准，包括 X.509、RFC $5280$ 和 TLS $1.3$。关于数字签名在 TLS $1.3$ 客户端认证和代码签名中如何使用的描述是准确的。提供的 OID 是正确的。所引用的安全原则（如最小权限原则）是正确的且相关的。该场景是 PKI 在物联网/信息物理系统 (IoT/CPS) 环境中的一个标准且实际的应用。\n- **适定性**：问题定义清晰。它要求基于一组特定的要求和原则来设计证书配置文件。可以从所提供的信息中推导出一个唯一的、最佳实践的解决方案。\n- **客观性**：语言精确且技术性强。它依赖于已建立标准 (RFC) 中的定义，而不是主观看法。\n\n该问题没有任何无效性缺陷。它并非科学上不合理、不可形式化、不完整、不切实际、不适定或微不足道。这是应用密码学和网络安全领域中一个结构良好的问题。\n\n#### 步骤3：结论与行动\n\n问题陈述是有效的。现在开始解决方案的推导过程。\n\n### 解决方案推导\n\n最优的证书配置文件必须满足从已知条件中推导出的所有要求。\n\n1.  **`keyUsage` 扩展分析**：\n    - CPS 传感器执行两种操作：TLS $1.3$ 客户端认证和代码签名验证。\n    - 问题明确指出，TLS $1.3$ 客户端认证是通过客户端计算数字签名来执行的。这要求在 `keyUsage` 扩展中设置 `digitalSignature` 位。\n    - 问题指出，固件真实性通过代码签名进行验证，这也依赖于数字签名。这加强了对 `digitalSignature` 位的需求。\n    - 问题指出，TLS $1.3$ 不使用静态 RSA 密钥传输，因此不需要 `keyEncipherment` 位。\n    - 现代 TLS 密钥建立（例如，ECDHE）使用临时密钥，而证书的密钥用于认证，而非直接的密钥协商。因此，`keyAgreement` 位是不合适的。\n    - 该证书是终端实体证书，而不是 CA 证书。因此，`keyCertSign` 和 `cRLSign` 位绝不能被设置。\n    - 如问题陈述中提到的，遵循最小权限原则，规定只应设置必要的比特位。因此，`keyUsage` 扩展应仅包含 `digitalSignature` 位。\n    - 根据基本事实，`keyUsage` 扩展应标记为`critical` (关键)，以确保所有信赖方都强制执行这些约束。\n\n2.  **`extendedKeyUsage` (EKU) 扩展分析**：\n    - 证书必须对两种不同的应用目的有效。\n    - 对于 TLS 客户端认证，EKU 必须包含 OID `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)。\n    - 对于代码签名，EKU 必须包含 OID `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)。\n    - 因此，`extendedKeyUsage` 扩展必须同时包含这两个 OID。\n    - 包含特殊的 OID `anyExtendedKeyUsage` ($2.5.29.37.0$) 将允许证书用于任何目的，这直接违反了最小权限原则。必须排除它。\n    - 根据基本事实，`extendedKeyUsage` 扩展通常被标记为`non-critical` (非关键)，以确保与可能不识别此扩展的系统的向后兼容性。\n\n3.  **`basicConstraints` 扩展分析**：\n    - 该证书用于终端实体（传感器），而非 CA。\n    - 根据 RFC $5280$，对于终端实体证书，`basicConstraints` 扩展可以完全省略。然而，一个安全最佳实践是包含它并明确将 `cA` 布尔值设置为 `false`。\n    - 如果存在，对于终端实体证书，此扩展应为`non-critical` (非关键) 以避免兼容性问题。\n\n### 推导出的配置文件摘要\n\n- **`keyUsage`**：必须设置 `digitalSignature` 位。不得设置 `keyEncipherment`、`keyAgreement`、`keyCertSign`。\n- **`keyUsage` 关键性**：`critical` (关键)。\n- **`extendedKeyUsage`**：必须包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)。\n- **`extendedKeyUsage` 关键性**：`non-critical` (非关键)。\n- **`basicConstraints`**：如果存在，必须设置 `cA=false` 并为 `non-critical` (非关键)。省略也是可以接受的，但不够明确。\n- **其他属性**：不应存在 `anyExtendedKeyUsage` OID。\n\n### 逐项选项分析\n\n现在，我们根据推导出的配置文件评估每个选项。\n\n**A. `keyUsage` 设置了 `digitalSignature`；没有 `keyEncipherment`、`keyAgreement` 和 `keyCertSign`；`keyUsage` 标记为关键 (critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键 (non-critical)。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)（或省略）。没有 `anyExtendedKeyUsage` ($2.5.29.37.0$) 。`Subject Alternative Name` 携带一个设备标识符且为非关键 (non-critical)。**\n- `keyUsage`: 正确，仅包含 `digitalSignature`。\n- `keyUsage` 关键性: `critical` (关键)，符合最佳实践。\n- `extendedKeyUsage`: 正确，包含两个所需的 OID。\n- `extendedKeyUsage` 关键性: `non-critical` (非关键)，符合兼容性的最佳实践。\n- `basicConstraints`: 为终端实体证书正确指定。\n- `anyExtendedKeyUsage`: 正确地排除了。\n此选项完全符合基于问题陈述和安全最佳实践推导出的配置文件。提及 `Subject Alternative Name` 是一个关于设备身份的现实细节，但不改变核心分析。\n**结论：正确**\n\n**B. `keyUsage` 设置了 `digitalSignature` 和 `keyEncipherment`；`keyUsage` 为非关键 (non-critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为关键 (critical)。`basicConstraints` 被省略。**\n- `keyUsage`: 不正确。它包含了 `keyEncipherment`，这对于 TLS $1.3$ 是不必要的，并违反了最小权限原则。\n- `keyUsage` 关键性: `non-critical` (非关键)。这比建议的 `critical` 安全性更弱。\n- `extendedKeyUsage` 关键性: `critical` (关键)。这不典型，并且可能降低兼容性，与问题中的指导相反。\n**结论：不正确**\n\n**C. `keyUsage` 设置了 `digitalSignature` 且为非关键 (non-critical)。`extendedKeyUsage` 仅包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)；没有代码签名 EKU。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)。**\n- `extendedKeyUsage`: 不正确。它缺少 `id-kp-codeSigning` EKU，因此该证书将无法用于验证固件更新。这未能满足一个主要要求。\n- `keyUsage` 关键性: `non-critical` (非关键)。这是一个较弱的配置。\n**结论：不正确**\n\n**D. `keyUsage` 设置了 `contentCommitment` (`nonRepudiation`) 但没有 `digitalSignature`；`keyUsage` 为关键 (critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键 (non-critical)。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)。**\n- `keyUsage`: 不正确。TLS 中的技术认证机制和通用代码签名需要 `digitalSignature` 位。`contentCommitment` (或 `nonRepudiation`) 位具有不同且更强的语义含义，在此处并不需要。如果未声明 `digitalSignature`，合规的信赖方将拒绝该证书用于认证。\n**结论：不正确**\n\n**E. `keyUsage` 设置了 `digitalSignature` 且为关键 (critical)。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)、`id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$) 和 `anyExtendedKeyUsage` ($2.5.29.37.0$)；`extendedKeyUsage` 为非关键 (non-critical)。`basicConstraints` 存在且 `CA=false` 并为非关键 (non-critical)。**\n- `extendedKeyUsage`: 不正确。包含 `anyExtendedKeyUsage` 破坏了另外两个 EKU 的特异性，并通过允许证书用于任何目的而违反了最小权限原则。当意图是特定用途时，这是一个重大的安全反模式。\n**结论：不正确**\n\n基于此分析，选项 A 是唯一一个根据所述要求和既定安全原则正确配置证书扩展、关键性和用途的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "拥有一个正确设计的证书只是第一步；该证书必须在一个信任链中得到正确验证。本练习深入探讨了证书路径验证的严谨逻辑，特别是上级证书颁发机构（CA）施加的约束（如 `Name Constraints`）如何影响信任链下游证书的有效性。掌握这种验证逻辑对于调试复杂的 PKI 问题以及设计安全的多租户或分段式 CPS 环境至关重要 。",
            "id": "4237511",
            "problem": "一个网络物理系统 (CPS) 的运维方维护着一个公钥基础设施 (PKI)，用于绑定现场设备及其数字孪生的身份。考虑一个证书路径 $Root \\to SubCA \\to EE$，其中 $Root$是信任锚，$SubCA$是一个中间证书颁发机构，$EE$是一个由 $\\mathrm{PlantB}$ 中的控制器使用的终端实体设备证书。$SubCA$ 证书包含指示 $CA=\\text{true}$ 的基本约束扩展，并携带以下扩展：(i) 一个包含策略对象标识符 $P_1$ 的证书策略扩展，以及 (ii) 一个名称约束扩展，其中包含一个类型为 $\\text{directoryName}$ 的 $\\text{permittedSubtrees}$ 约束，该约束仅允许使用者可分辨名称以 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 开头的证书。$EE$ 证书的使用者可分辨名称为 $OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$，并包含一个含有 $P_1$ 的证书策略扩展。假设 $EE$ 证书中缺少使用者备用名称 ($SAN$)，并且依赖方的初始可接受策略集包含 $P_1$。所有证书在其他方面均格式正确、未过期且密码学上有效。\n\n根据第 5280 号征求意见稿 (RFC 5280) 中规定的互联网 X.509 公钥基础设施 (PKI) 证书路径验证的基本原则，判断 $EE$ 证书在 $Root \\to SubCA \\to EE$ 路径下是否有效，如果无效，请指出确切的失败点。选择最佳答案。\n\nA. $EE$ 证书无效；失败发生在应用 $SubCA$ 名称约束中类型为 $\\text{directoryName}$ 的 $\\text{permittedSubtrees}$ 时，因为 $EE$ 的使用者 $OU=\\mathrm{PlantB}$ 不在允许的子树 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 内。\n\nB. $EE$ 证书有效；策略匹配 ($P_1$)，且名称约束不适用于使用者可分辨名称中的 $OU$ 属性。\n\nC. $EE$ 证书无效；失败发生在信任锚处，因为 $Root$ 未声明策略 $P_1$。\n\nD. $EE$ 证书有效；$SubCA$ 名称约束仅适用于使用者备用名称 ($SAN$) 条目，而不适用于使用者可分辨名称。",
            "solution": "在尝试任何解答之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知信息\n- **证书路径：** $Root \\to SubCA \\to EE$\n- **信任锚：** $Root$\n- **中间 CA：** $SubCA$\n- **终端实体：** $EE$ (位于 $\\mathrm{PlantB}$ 的控制器)\n- **$SubCA$ 证书扩展：**\n    1.  基本约束：$CA=\\text{true}$。\n    2.  证书策略：包含策略对象标识符 (OID) $P_1$。\n    3.  名称约束：包含一个类型为 `directoryName` 的 `permittedSubtrees` 约束，该约束仅允许使用者可分辨名称以前缀 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 开头的证书。\n- **$EE$ 证书属性：**\n    1.  使用者可分辨名称 (DN)：$OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$。\n    2.  证书策略扩展：包含策略 OID $P_1$。\n    3.  使用者备用名称 ($SAN$) 扩展：缺失。\n- **依赖方初始状态：**\n    1.  初始可接受策略集包含 $P_1$。\n- **假设：** 证书的所有其他方面（签名、有效期、吊销状态）均有效。\n- **治理标准：** 第 5280 号征求意见稿 (RFC 5280) 中规定的互联网 X.509 公钥基础设施 (PKI) 证书路径验证。\n- **问题：** 判断 $EE$ 证书在给定路径下是否有效，并指出确切的失败点（如果有）。\n\n### 步骤 2：使用提取的已知信息进行验证\n对问题陈述的有效性进行评估。\n\n- **科学依据：** 该问题完全基于定义明确的 X.509 证书路径验证技术标准 RFC 5280。证书路径、信任锚、证书扩展（基本约束、名称约束、证书策略）和可分辨名称等概念都是 PKI 的标准和基础。将其应用于网络物理系统 (CPS) 是一个现实的背景。该问题在科学和技术上是合理的。\n- **问题适定性：** 该问题提供了一个具体的证书链、证书的相关内容以及依赖方的初始状态。它要求根据指定的标准来确定有效性。信息足以通过应用 RFC 5280 的规则得出一个唯一的、确定性的结论。\n- **客观性：** 该问题使用来自相关 RFC 的精确、无歧义的技术术语进行陈述。没有主观或基于意见的元素。\n\n该问题不存在任何无效性缺陷。这是一个关于技术标准应用的、格式良好的问题。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将根据 RFC 5280 的原则推导出解决方案。\n\n### 解决方案推导\n证书路径 $Root \\to SubCA \\to EE$ 的验证是按顺序进行的。我们关注的是在由前一个证书 $SubCA$ 建立的上下文中，对终端实体 $EE$ 的证书进行处理。需要评估的关键扩展是存在于 $SubCA$ 证书中的名称约束扩展。\n\n指导原则在 RFC 5280 第 4.2.1.10 节“名称约束”中指定。该节指出：\n“名称约束扩展（必须仅在 CA 证书中使用）指明了一个命名空间，证书路径中所有后续证书的使用者名称都必须位于该命名空间内。”\n\n它进一步阐明了哪些名称受此约束：\n“为实现名称约束的目的，使用者名称被定义为 subject 字段中的使用者可分辨名称 (DN) 和/或使用者备用名称扩展中的名称。……一个被认证的使用者名称必须采用可以与约束进行匹配的形式。”\n\n对于 `directoryName` 这一特定类型：\n“directoryName 的名称约束表示为一个 DN。如果一个名称是约束的 DN，或者是一个更长的 DN 且该约束是其前缀，则该名称位于该子树内。”\n\n让我们将这些规则应用于给定的问题：\n1.  路径验证算法处理 $SubCA$ 证书。它遇到了一个名称约束扩展。这对路径中的所有后续证书（在本例中是 $EE$ 证书）建立了一个约束。\n2.  该约束是一个类型为 `directoryName` 的 `permittedSubtrees`，其值（基准）为 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$。\n3.  然后，算法处理 $EE$ 证书，以检查其使用者名称是否符合此约束。\n4.  RFC 5280 要求检查 `使用者备用名称` ($SAN$) 和 `使用者` 可分辨名称。问题陈述指出 $SAN$ 缺失，因此我们必须检查 `使用者` DN。\n5.  $EE$ 证书的 `使用者` DN 是 $OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$。\n6.  验证检查是确定 $EE$ 的使用者 DN 是否在允许的子树内。这意味着约束中的基准 DN 必须是使用者 DN 的前缀。\n    -   约束基准 DN：$OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$\n    -   $EE$ 使用者 DN：$OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$\n7.  比较显示，约束 DN 不是使用者 DN 的前缀。最具体的属性，即组织单位 ($OU$)，不同 ($OU=\\mathrm{PlantA}$ vs. $OU=\\mathrm{PlantB}$)。因此，使用者名称 $OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 不在以 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 为根的允许子树内。\n8.  这构成了对名称约束的违反。根据 RFC 5280 第 6.1.4 节步骤 (k)，如果违反了名称约束，则必须拒绝该证书。路径验证在此时失败。\n\n因此，由于名称约束违规，该证书无效。其他方面，如证书策略扩展，也会被处理。在这里，策略 $P_1$ 同时存在于 $SubCA$ 和 $EE$ 证书中，并且依赖方接受 $P_1$，因此策略验证可能会成功。然而，由于名称约束导致的失败是决定性的，并终止了路径验证。\n\n### 选项评估\n\n**A. $EE$ 证书无效；失败发生在应用 $SubCA$ 名称约束中类型为 $\\text{directoryName}$ 的 $\\text{permittedSubtrees}$ 时，因为 $EE$ 的使用者 $OU=\\mathrm{PlantB}$ 不在允许的子树 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 内。**\n该陈述正确地指出证书是无效的。它精确地指出了原因：违反了来自 $SubCA$ 证书的 `Name Constraints` 扩展。它准确地解释了 $EE$ 证书的使用者 DN（包含 $OU=\\mathrm{PlantB}$）不属于由约束定义的允许子树，该约束要求前缀为 $OU=\\mathrm{PlantA}$。这与从 RFC 5280 推导出的结论完全一致。\n**结论：正确**\n\n**B. $EE$ 证书有效；策略匹配 ($P_1$)，且名称约束不适用于使用者可分辨名称中的 $OU$ 属性。**\n该陈述在两点上是错误的。首先，如上所述，证书是无效的。其次，声称名称约束不适用于 $OU$ 属性是错误的。`directoryName` 约束通过执行前缀匹配，适用于整个可分辨名称结构，包括 $OU$ 属性。策略匹配是无关紧要的，因为名称约束检查失败了。\n**结论：错误**\n\n**C. $EE$ 证书无效；失败发生在信任锚处，因为 $Root$ 未声明策略 $P_1$。**\n该陈述是错误的。虽然证书无效，但引用的原因不正确。根据 RFC 5280，路径验证过程是用用户提供的一组策略（`initial-policy-set`）初始化的。并不要求信任锚本身包含这些策略之一。路径验证的失败是由于名称约束，而不是在根部的策略处理。\n**结论：错误**\n\n**D. $EE$ 证书有效；$SubCA$ 名称约束仅适用于使用者备用名称 ($SAN$) 条目，而不适用于使用者可分辨名称。**\n该陈述是错误的。它声称证书有效，这与推导相矛盾。其提供的核心理由在事实上是错误的。如 RFC 5280 第 4.2.1.10 节明确指出，名称约束同时适用于 `使用者` 可分辨名称和 `使用者备用名称` 扩展中的任何名称。\n**结论：错误**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在实际部署中，PKI 的正确性必须与高性能相结合，尤其是在处理大规模设备连接的 CPS 控制器中。密码学操作的计算成本可能成为系统瓶颈。本练习将理论与实践相结合，应用排队论来建模和预测处理大量 TLS 握手的控制器所经历的延迟，从而使我们能够根据性能数据在不同的加密算法（如 ECDSA 和 RSA）之间做出明智的选择 。",
            "id": "4237545",
            "problem": "一个用作数字孪生编排节点的信息物理系统 (CPS) 控制器，使用公钥基础设施 (PKI) 来终止来自分布式现场设备的双向传输层安全 (TLS) 连接。每个传入的双向 TLS 握手都要求控制器执行恰好 $s$ 次独立的签名验证（一次对客户端 CertificateVerify 消息的验证和一次对客户端终端实体证书签名的验证），因此 $s=2$。该控制器以每秒 $\\Lambda=2000$ 个连接的总速率接收连接，这可以建模为一个泊松过程。签名验证阶段作为单线程服务运行，可建模为 M/M/1 排队。有两种候选算法可用于客户端认证：\n\n- 基于 NIST P-256 曲线的椭圆曲线数字签名算法 (ECDSA)，其测得的验证吞吐量为每秒 $5000$ 次验证。\n- 使用 $2048$ 位密钥的 Rivest–Shamir–Adleman (RSA) 算法，其测得的验证吞吐量为每秒 $800$ 次验证。\n\n假设服务时间呈指数分布，其均值为测得吞吐量的倒数，并且到达是独立的。控制器的端到端握手延迟预算为每个连接的签名验证阶段专门分配了 $B=20$ 毫秒。仅使用吞吐量、到达率以及 M/M/1 排队关于稳定性和系统中期望时间的基本定义，从第一性原理推导每种算法的预期单位连接验证延迟，确定哪种算法能够满足延迟预算，并为满足预算的算法计算延迟余量 $M=B - T_{\\text{verify}}$，其中 $T_{\\text{verify}}$ 是归因于签名验证阶段的预期单位连接验证延迟。将您的最终余量以毫秒为单位表示，并将答案四舍五入到四位有效数字。",
            "solution": "该场景是一个在信息物理系统 (CPS) 控制器中处理双向传输层安全 (TLS) 握手签名验证任务的单一服务站。每个连接需要 $s=2$ 次独立的签名验证任务。连接的到达过程被建模为速率为 $\\Lambda=2000$ 连接/秒的泊松过程，每个连接贡献 $s$ 个任务。因此，验证任务的总到达率为\n$$\n\\lambda = s \\Lambda.\n$$\n对于每种算法，都有一个以“操作数/秒”为单位的测得验证吞吐量，我们将其解释为 M/M/1 服务站的服务率。令 $\\mu$ 表示以“验证任务数/秒”为单位的服务率。对于椭圆曲线数字签名算法 (ECDSA) P-256，$\\mu_{E}=5000$。对于使用 $2048$ 位密钥的 Rivest–Shamir–Adleman (RSA) 算法，$\\mu_{R}=800$。\n\n在到达率为 $\\lambda$、服务率为 $\\mu$ 的 M/M/1 模型下，稳定性要求 $\\lambda < \\mu$。对于一个稳定的 M/M/1 系统，单个任务（验证任务）在系统中的期望时间（等待时间加服务时间）由从 Little 法则和稳态队长推导出的著名结果给出：\n$$\nW = \\frac{1}{\\mu - \\lambda}.\n$$\n这个结果是由于系统中的期望任务数为\n$$\nL = \\frac{\\lambda}{\\mu - \\lambda},\n$$\n并且根据 Little 法则 $L = \\lambda W$，因此 $W = L/\\lambda = 1/(\\mu - \\lambda)$。\n\n每个连接需要 $s$ 个这样的任务。将每个验证任务视为独立排队和服务的（在其他到达任务中，一个连接的多个任务按期望顺序处理），每个连接的预期总验证延迟是 $s$ 个任务的总和：\n$$\nT_{\\text{verify}} = s W = \\frac{s}{\\mu - \\lambda}.\n$$\n我们现在为每种算法实例化 $\\lambda$ 和 $\\mu$：\n$$\n\\lambda = s \\Lambda = 2 \\times 2000 = 4000.\n$$\n\n1. 椭圆曲线数字签名算法 (ECDSA) P-256：\n   - 服务率 $\\mu_{E} = 5000$。\n   - 检查稳定性：$\\lambda = 4000 < \\mu_{E} = 5000$，因此系统是稳定的。\n   - 预期的单位连接验证延迟：\n     $$\n     T_{\\text{verify},E} = \\frac{s}{\\mu_{E} - \\lambda} = \\frac{2}{5000 - 4000} = \\frac{2}{1000} = 0.002 \\text{ 秒}。\n     $$\n     使用 $1 \\text{ 秒} = 1000 \\text{ 毫秒}$ 转换为毫秒，得到\n     $$\n     T_{\\text{verify},E} = 0.002 \\times 1000 = 2 \\text{ 毫秒}。\n     $$\n\n2. Rivest–Shamir–Adleman (RSA) $2048$：\n   - 服务率 $\\mu_{R} = 800$。\n   - 检查稳定性：$\\lambda = 4000 > \\mu_{R} = 800$，因此 M/M/1 系统是不稳定的；系统中的期望时间会发散，不存在有限的预期验证延迟。因此，在此配置下，RSA-2048 无法满足任何有限的延迟预算。\n\n只有椭圆曲线数字签名算法 (ECDSA) P-256 满足稳定性准则，可以根据延迟预算进行评估。分配给验证的延迟预算为 $B = 20$ 毫秒。椭圆曲线数字签名算法 (ECDSA) 的延迟余量为\n$$\nM = B - T_{\\text{verify},E} = 20 - 2 = 18 \\text{ 毫秒}。\n$$\n将 $18$ 毫秒四舍五入到四位有效数字得到 $18.00$ 毫秒。要求的最终答案是满足预算的算法（即椭圆曲线数字签名算法 (ECDSA) P-256）的延迟余量，以毫秒为单位。",
            "answer": "$$\\boxed{18.00}$$"
        }
    ]
}