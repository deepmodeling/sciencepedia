{
    "hands_on_practices": [
        {
            "introduction": "在为网络物理系统（CPS）设计公钥基础设施（PKI）时，首要任务是精确定义每个设备证书的用途和权限。本练习将引导您为一个既需要通过TLS进行客户端验证，又需要支持固件代码签名的传感器设计一个符合最小权限原则的X.509证书配置文件。通过实践，您将学会如何正确配置`keyUsage`和`extendedKeyUsage`扩展，以确保安全性和互操作性。",
            "id": "4237459",
            "problem": "一个物理信息系统 (CPS) 部署使用了一批嵌入式传感器，这些传感器必须通过传输层安全 (TLS) $1.3$ 协议使用客户端认证与网关服务进行相互认证，并且还必须接受通过代码签名验证其真实性的空中下载 (OTA) 固件包。每个传感器都配备一个终端实体 X.509 证书，而不是证书颁发机构 (CA) 证书。该公钥基础设施 (PKI) 遵循征求意见稿 (RFC) $5280$ 的语义：密钥用法扩展限制了主体公钥允许的操作，增强型密钥用法扩展指明了证书可以用于的特定目的，而扩展上的关键标志表示如果依赖方不理解该扩展，则必须拒绝该证书。\n\n基于以下基本事实：\n- 在 X.509 中，密钥用法扩展枚举了位级别的权限，例如数字签名创建、密钥加密和密钥协商。这些位限制了主体公钥允许的操作，而设置了与实际使用的协议不对应的位会违反最小权限安全原则。\n- 在 X.509 中，增强型密钥用法 (EKU) 扩展使用对象标识符 (OIDs) 来指定应用级别的目的。对于 TLS 客户端认证，EKU `id-kp-clientAuth` 的 OID 是 $1.3.6.1.5.5.7.3.2$。对于代码签名，EKU `id-kp-codeSigning` 的 OID 是 $1.3.6.1.5.5.7.3.3$。\n- TLS $1.3$ 使用 `CertificateVerify` 消息，客户端在其中通过计算通信记录的数字签名来证明其拥有私钥；TLS $1.3$ 不使用静态 RSA 密钥传输，因此不需要密钥加密。固件代码签名同样依赖于对软件工件的数字签名。\n- 在 RFC $5280$ 中，如果一个扩展被标记为关键，不理解该扩展的客户端必须拒绝该证书。密钥用法扩展通常被标记为关键，以确保依赖方正确执行公钥约束。增强型密钥用法扩展通常是非关键的，以保持兼容性，同时仍向知晓的应用程序提供目的约束。基本约束扩展表明 CA 能力；传感器的终端实体证书不得声称具有 CA 能力。\n\n请设计一个适用于支持 TLS $1.3$ 下的 TLS 客户端认证和代码签名的 CPS 传感器的终端实体证书配置文件，方法是选择正确的密钥用法位和增强型密钥用法 OID 的组合，并指明哪些扩展必须标记为关键以强制执行正确的行为而不破坏兼容性。哪个选项最合适？\n\nA. `keyUsage` 设置了 `digitalSignature`；没有 `keyEncipherment`、`keyAgreement` 和 `keyCertSign`；`keyUsage` 标记为关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键。`basicConstraints` 存在且 `CA=false` 并为非关键（或省略）。不包含 `anyExtendedKeyUsage` ($2.5.29.37.0$)。主体备用名称 (`Subject Alternative Name`) 携带设备标识符且为非关键。\n\nB. `keyUsage` 设置了 `digitalSignature` 和 `keyEncipherment`；`keyUsage` 为非关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为关键。`basicConstraints` 被省略。\n\nC. `keyUsage` 设置了 `digitalSignature` 且为非关键。`extendedKeyUsage` 只包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)；没有代码签名的 EKU。`basicConstraints` 存在且 `CA=false` 并为非关键。\n\nD. `keyUsage` 设置了 `contentCommitment` (nonRepudiation) 但没有设置 `digitalSignature`；`keyUsage` 为关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键。`basicConstraints` 存在且 `CA=false` 并为非关键。\n\nE. `keyUsage` 设置了 `digitalSignature` 且为关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)、`id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$) 和 `anyExtendedKeyUsage` ($2.5.29.37.0$)；`extendedKeyUsage` 为非关键。`basicConstraints` 存在且 `CA=false` 并为非关键。\n\n选择唯一的最佳选项。",
            "solution": "用户要求为物理信息系统 (CPS) 传感器设计并选择一个合适的 X.509 证书配置文件。分析将分两个阶段进行：首先是问题验证，然后是解决方案的详细推导和对所提供选项的评估。\n\n### 问题验证\n\n首先，必须对问题陈述的科学合理性、一致性和客观性进行验证。\n\n#### 步骤1：提取已知条件\n\n问题提供了以下数据和约束：\n- **系统**：一个带有嵌入式传感器的 CPS 部署。\n- **用例1**：通过传输层安全 (TLS) $1.3$ 协议使用客户端认证与网关服务进行相互认证。\n- **用例2**：通过代码签名验证空中下载固件包的真实性。\n- **证书类型**：每个传感器都配备一个终端实体 X.509 证书，而不是证书颁发机构 (CA) 证书。\n- **管辖标准**：公钥基础设施 (PKI) 遵循征求意见稿 (RFC) $5280$。\n- **基本事实1 (`keyUsage`)**：`keyUsage` 扩展包含位级别的权限。其目的是限制主体公钥的操作。违反最小权限原则（通过设置未使用的位）是不可取的。\n- **基本事实2 (`extendedKeyUsage`)**：`extendedKeyUsage` (EKU) 扩展使用对象标识符 (OIDs) 指定应用级别的目的。\n    - TLS 客户端认证使用 `id-kp-clientAuth` (OID $1.3.6.1.5.5.7.3.2$)。\n    - 代码签名使用 `id-kp-codeSigning` (OID $1.3.6.1.5.5.7.3.3$)。\n- **基本事实3 (协议)**:\n    - TLS $1.3$ 客户端认证涉及客户端在 `CertificateVerify` 消息中计算通信记录的数字签名。\n    - TLS $1.3$ 不使用静态 RSA 密钥传输，因此不需要 `keyEncipherment`。\n    - 固件代码签名依赖于数字签名。\n- **基本事实4 (扩展与关键性)**:\n    - 如果一个扩展被标记为 `critical`，不理解它的依赖方必须拒绝该证书。\n    - `keyUsage` 通常被标记为 `critical` 以进行严格执行。\n    - `extendedKeyUsage` 通常是 `non-critical` 以保证兼容性。\n    - `basicConstraints` 表示 CA 能力；终端实体证书不得声称具有此能力。\n\n#### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行分析。\n\n- **科学依据充分**：该问题牢固地基于已建立的现实世界标准，包括 X.509、RFC $5280$ 和 TLS $1.3$。关于数字签名在 TLS $1.3$ 客户端认证和代码签名中如何使用的描述是准确的。提供的 OID 是正确的。所引用的安全原则（如最小权限）是正确的且相关的。该场景是 PKI 在物联网/CPS 背景下的标准和实际应用。\n- **定义明确**：问题定义清晰。它要求基于一组特定的要求和原则来设计证书配置文件。可以从所提供的信息中推导出一个唯一的、最佳实践的解决方案。\n- **客观性**：语言精确且技术性强。它依赖于既定标准 (RFCs) 的定义，而非主观意见。\n\n该问题不存在任何无效性缺陷。它不是科学上不合理、不可形式化、不完整、不切实际、不适定或琐碎的。这是一个在应用密码学和网络安全领域结构良好的问题。\n\n#### 步骤3：结论与行动\n\n问题陈述是**有效的**。现在将进行求解过程。\n\n### 求解推导\n\n最佳证书配置文件必须满足从已知条件中推导出的所有要求。\n\n1.  **`keyUsage` 扩展分析**：\n    - CPS 传感器执行两个操作：TLS $1.3$ 客户端认证和代码签名验证。\n    - 问题明确指出，TLS $1.3$ 客户端认证是通过客户端计算数字签名来执行的。这要求在 `keyUsage` 扩展中设置 `digitalSignature` 位。\n    - 问题指出固件的真实性通过代码签名来验证，这也依赖于数字签名。这加强了对 `digitalSignature` 位的需求。\n    - 问题指出 TLS $1.3$ 不使用静态 RSA 密钥传输，所以不需要 `keyEncipherment` 位。\n    - 现代 TLS 密钥建立（例如 ECDHE）使用临时密钥，证书的密钥用于认证，而非直接的密钥协商。因此，`keyAgreement` 位不适用。\n    - 该证书是终端实体证书，而不是 CA 证书。因此，`keyCertSign` 和 `cRLSign` 位绝不能设置。\n    - 援引问题陈述中提到的最小权限原则，规定只应设置必要的位。因此，`keyUsage` 扩展应仅包含 `digitalSignature` 位。\n    - 根据基本事实，`keyUsage` 扩展应标记为 `critical`，以确保所有依赖方都强制执行这些约束。\n\n2.  **`extendedKeyUsage` (EKU) 扩展分析**：\n    - 证书必须对两个不同的应用目的有效。\n    - 对于 TLS 客户端认证，EKU 必须包含 OID `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)。\n    - 对于代码签名，EKU 必须包含 OID `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)。\n    - 因此，`extendedKeyUsage` 扩展必须包含这两个 OID。\n    - 包含特殊的 OID `anyExtendedKeyUsage` ($2.5.29.37.0$) 将允许证书用于任何目的，这直接违反了最小权限原则。必须排除它。\n    - 根据基本事实，`extendedKeyUsage` 扩展通常标记为 `non-critical`，以确保与可能无法识别此扩展的系统向后兼容。\n\n3.  **`basicConstraints` 扩展分析**：\n    - 该证书适用于终端实体（传感器），而不是 CA。\n    - 根据 RFC $5280$，对于终端实体证书，`basicConstraints` 扩展可以完全省略。然而，安全最佳实践是包含它并明确将 `cA` 布尔值设置为 `false`。\n    - 如果存在，此扩展对于终端实体证书应为 `non-critical`，以避免兼容性问题。\n\n### 推导出的配置文件摘要\n\n- **`keyUsage`**：必须设置 `digitalSignature` 位。不得设置 `keyEncipherment`、`keyAgreement`、`keyCertSign`。\n- **`keyUsage` 关键性**：`critical`。\n- **`extendedKeyUsage`**：必须包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)。\n- **`extendedKeyUsage` 关键性**：`non-critical`。\n- **`basicConstraints`**：如果存在，必须设为 `cA=false` 且为 `non-critical`。省略也是可接受的，但不够明确。\n- **其他属性**：不应存在 `anyExtendedKeyUsage` OID。\n\n### 逐项分析选项\n\n现在，我们根据推导出的配置文件评估每个选项。\n\n**A. `keyUsage` 设置了 `digitalSignature`；没有 `keyEncipherment`、`keyAgreement` 和 `keyCertSign`；`keyUsage` 标记为关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键。`basicConstraints` 存在且 `CA=false` 并为非关键（或省略）。不包含 `anyExtendedKeyUsage` ($2.5.29.37.0$)。主体备用名称 (`Subject Alternative Name`) 携带设备标识符且为非关键。**\n- `keyUsage`：正确地只包含 `digitalSignature`。\n- `keyUsage` 关键性：`critical`，符合最佳实践。\n- `extendedKeyUsage`：正确地包含两个必需的 OID。\n- `extendedKeyUsage` 关键性：`non-critical`，符合兼容性的最佳实践。\n- `basicConstraints`：为终端实体证书正确指定。\n- `anyExtendedKeyUsage`：正确地被排除。\n此选项完美匹配基于问题陈述和安全最佳实践推导出的配置文件。提及 `Subject Alternative Name` 是一个现实的细节，但不改变核心分析。\n**结论：正确**\n\n**B. `keyUsage` 设置了 `digitalSignature` 和 `keyEncipherment`；`keyUsage` 为非关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为关键。`basicConstraints` 被省略。**\n- `keyUsage`：不正确。它包含了 `keyEncipherment`，这对于 TLS $1.3$ 是不必要的，并且违反了最小权限原则。\n- `keyUsage` 关键性：`non-critical`。这是一种比推荐的 `critical` 更弱的安全姿态。\n- `extendedKeyUsage` 关键性：`critical`。这不典型，并且会降低兼容性，与问题中的指导相反。\n**结论：不正确**\n\n**C. `keyUsage` 设置了 `digitalSignature` 且为非关键。`extendedKeyUsage` 只包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)；没有代码签名的 EKU。`basicConstraints` 存在且 `CA=false` 并为非关键。**\n- `extendedKeyUsage`：不正确。它缺少 `id-kp-codeSigning` EKU，因此该证书对验证固件更新无效。这未能满足一个主要要求。\n- `keyUsage` 关键性：`non-critical`。这是一个较弱的姿态。\n**结论：不正确**\n\n**D. `keyUsage` 设置了 `contentCommitment` (nonRepudiation) 但没有设置 `digitalSignature`；`keyUsage` 为关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$) 和 `id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$)；`extendedKeyUsage` 为非关键。`basicConstraints` 存在且 `CA=false` 并为非关键。**\n- `keyUsage`：不正确。`digitalSignature` 位对于 TLS 中的技术认证机制和通用代码签名是必需的。`contentCommitment`（或 `nonRepudiation`）位具有不同的、更强的语义含义，此处并不需要。如果未声明 `digitalSignature`，合规的依赖方将拒绝该证书用于认证。\n**结论：不正确**\n\n**E. `keyUsage` 设置了 `digitalSignature` 且为关键。`extendedKeyUsage` 包含 `id-kp-clientAuth` ($1.3.6.1.5.5.7.3.2$)、`id-kp-codeSigning` ($1.3.6.1.5.5.7.3.3$) 和 `anyExtendedKeyUsage` ($2.5.29.37.0$)；`extendedKeyUsage` 为非关键。`basicConstraints` 存在且 `CA=false` 并为非关键。**\n- `extendedKeyUsage`：不正确。包含 `anyExtendedKeyUsage` 破坏了其他两个 EKU 的特指性，并通过允许证书用于任何目的而违反了最小权限原则。当意图是特定用途时，这是一个严重的安全反模式。\n**结论：不正确**\n\n基于此分析，选项A是唯一一个根据所述要求和既定安全原则正确配置证书扩展、关键性和用途的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在一个大型、分段的网络物理系统中，仅靠正确配置单个证书是不够的，我们还需要在整个PKI体系中强制执行安全策略和信任边界。本练习探讨了X.509证书路径验证中的一个关键高级特性——名称约束（`Name Constraints`）扩展。您将分析一个具体的证书链，判断其有效性，并理解如何利用名称约束来限制证书颁发机构（CA）的权限范围，从而实现精细化的访问控制。",
            "id": "4237511",
            "problem": "一个信息物理系统（CPS）的运营者维护着一个公钥基础设施（PKI），用于将现场设备及其数字孪生的身份进行绑定。考虑一个证书路径 $Root \\to SubCA \\to EE$，其中 $Root$ 是信任锚，$SubCA$ 是一个中间证书颁发机构，而 $EE$ 是由 $\\mathrm{PlantB}$ 中的一个控制器使用的终端实体设备证书。$SubCA$ 证书包含一个表明 $CA=\\text{true}$ 的基本约束扩展，并携带以下扩展：(i) 一个包含策略对象标识符 $P_1$ 的证书策略扩展，以及 (ii) 一个名称约束扩展，其中包含一个类型为 $\\text{directoryName}$ 的 $\\text{permittedSubtrees}$ 约束，该约束仅允许专有名称以 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 开头的主体。$EE$ 证书的主体专有名称为 $OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$，并包含一个含有 $P_1$ 的证书策略扩展。假设 $EE$ 证书中不存在主体别名（$SAN$），并且依赖方的初始可接受策略集包含 $P_1$。所有证书在其他方面均格式正确、未过期且密码学上有效。\n\n根据征求意见稿（RFC）5280 中规定的互联网 X.509 公钥基础设施（PKI）证书路径验证的基本原则，判断 $EE$ 证书在 $Root \\to SubCA \\to EE$ 路径下是否有效，如果无效，请指出确切的失败点。选择最佳答案。\n\nA. $EE$ 证书无效；失败发生在应用 $SubCA$ 的类型为 $\\text{directoryName}$ 的名称约束 $\\text{permittedSubtrees}$ 时，因为 $EE$ 的主体 $OU=\\mathrm{PlantB}$ 不在允许的子树 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 内。\n\nB. $EE$ 证书有效；策略匹配（$P_1$），且名称约束不适用于主体专有名称中的 $OU$ 属性。\n\nC. $EE$ 证书无效；失败发生在信任锚处，因为 $Root$ 没有声明策略 $P_1$。\n\nD. $EE$ 证书有效；$SubCA$ 的名称约束仅适用于主体别名（$SAN$）条目，而不适用于主体专有名称。",
            "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- **证书路径：** $Root \\to SubCA \\to EE$\n- **信任锚：** $Root$\n- **中间CA：** $SubCA$\n- **终端实体：** $EE$（位于标识为 $\\mathrm{PlantB}$ 的地点中的控制器）\n- **$SubCA$ 证书扩展：**\n    1.  基本约束：$CA=\\text{true}$。\n    2.  证书策略：包含策略对象标识符 (OID) $P_1$。\n    3.  名称约束：包含一个类型为 `directoryName` 的 `permittedSubtrees` 约束，该约束仅允许专有名称以前缀 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 开头的主体。\n- **$EE$ 证书属性：**\n    1.  主体专有名称 (DN)：$OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$。\n    2.  证书策略扩展：包含策略 OID $P_1$。\n    3.  主体别名 ($SAN$) 扩展：不存在。\n- **依赖方初始状态：**\n    1.  初始可接受策略集包含 $P_1$。\n- **假设：** 证书的所有其他方面（签名、有效期、撤销状态）均有效。\n- **治理标准：** 互联网 X.509 公钥基础设施（PKI）证书路径验证，如征求意见稿（RFC）5280 中所规定。\n- **问题：** 判断 $EE$ 证书在给定路径下的有效性，并指出确切的失败点（如果有）。\n\n### 步骤2：使用提取的已知条件进行验证\n对问题陈述的有效性进行评估。\n\n- **科学依据：** 该问题完全基于用于 X.509 证书路径验证的明确技术标准 RFC 5280。证书路径、信任锚、证书扩展（基本约束、名称约束、证书策略）和专有名称等概念都是 PKI 的标准和基础。将其应用于信息物理系统（CPS）是一个现实的背景。该问题在科学和技术上是合理的。\n- **定义明确：** 该问题提供了具体的证书链、证书的相关内容以及依赖方的初始状态。它要求基于指定的标准来确定有效性。信息足以通过应用 RFC 5280 的规则得出一个唯一的、确定性的结论。\n- **客观性：** 该问题使用相关 RFC 中精确、明确的技术术语进行陈述。没有主观或基于意见的元素。\n\n该问题没有任何无效性缺陷。这是一个关于技术标准应用的、格式良好的问题。\n\n### 步骤3：结论与行动\n问题是**有效的**。将根据 RFC 5280 的原则推导出解决方案。\n\n### 解决方案的推导\n证书路径 $Root \\to SubCA \\to EE$ 的验证是按顺序进行的。我们关心的是在由前一个证书 $SubCA$ 建立的上下文中，对终端实体 $EE$ 的证书进行处理。需要评估的关键扩展是存在于 $SubCA$ 证书中的名称约束扩展。\n\n指导原则在 RFC 5280 的 4.2.1.10 节“名称约束”中有详细说明。该节规定：\n“名称约束扩展必须仅在 CA 证书中使用，它指定了一个命名空间，证书路径中所有后续证书的主体名称都必须位于该命名空间内。”\n\n它进一步阐明了哪些名称受此约束：\n“为了名称约束的目的，主体名称被定义为 subject 字段中的主体专有名称（DN）和/或主体别名扩展中的名称。... 一个被认证的主体名称必须采用可以与约束进行匹配的形式。”\n\n对于具体的 `directoryName` 类型：\n“对于 directoryName 的名称约束表示为一个 DN。如果一个名称是该约束的 DN，或者是一个更长的 DN 且该约束是其前缀，则该名称位于子树内。”\n\n让我们将这些规则应用于给定的问题：\n1.  路径验证算法处理 $SubCA$ 证书。它遇到了一个名称约束扩展。这对路径中所有后续证书（在本例中是 $EE$ 证书）建立了一个约束。\n2.  该约束是一个类型为 `directoryName` 的 `permittedSubtrees`，其值（基准）为 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$。\n3.  然后，算法处理 $EE$ 证书，以检查其主体名称是否符合此约束。\n4.  RFC 5280 要求同时检查 `Subject Alternative Name` ($SAN$) 和 `subject` 专有名称。问题陈述中说明 $SAN$ 不存在，所以我们必须检查 `subject` DN。\n5.  $EE$ 证书的 `subject` DN 是 $OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$。\n6.  验证检查是为了确定 $EE$ 的主体 DN 是否在允许的子树内。这意味着来自约束的基准 DN 必须是主体 DN 的一个前缀。\n    -   约束基准 DN: $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$\n    -   $EE$ 主体 DN: $OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$\n7.  比较表明，约束 DN 不是主体 DN 的前缀。最具体的属性，即组织单位 ($OU$)，不相同 ($OU=\\mathrm{PlantA}$ vs. $OU=\\mathrm{PlantB}$)。因此，主体名称 $OU=\\mathrm{PlantB}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 不在以 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 为根的允许子树内。\n8.  这构成了对名称约束的违反。根据 RFC 5280 第 6.1.4 节步骤 (k)，如果名称约束被违反，该证书必须被拒绝。路径验证在此失败。\n\n因此，由于名称约束违规，该证书无效。其他方面，如证书策略扩展，也会被处理。在这里，策略 $P_1$ 同时存在于 $SubCA$ 和 $EE$ 证书中，并且依赖方接受 $P_1$，因此策略验证可能会成功。然而，由于名称约束导致的失败是决定性的，并终止了路径验证。\n\n### 选项评估\n\n**A. $EE$ 证书无效；失败发生在应用 $SubCA$ 的类型为 $\\text{directoryName}$ 的名称约束 $\\text{permittedSubtrees}$ 时，因为 $EE$ 的主体 $OU=\\mathrm{PlantB}$ 不在允许的子树 $OU=\\mathrm{PlantA}, O=\\mathrm{Acme}, C=\\mathrm{US}$ 内。**\n该陈述正确地指出了证书是无效的。它精确地指出了原因：违反了来自 $SubCA$ 证书的 `Name Constraints` 扩展。它准确地解释了 $EE$ 证书的主体 DN 包含 $OU=\\mathrm{PlantB}$，不属于由约束定义的允许子树，该约束要求前缀为 $OU=\\mathrm{PlantA}$。这与从 RFC 5280 推导出的结论完全一致。\n**结论：正确**\n\n**B. $EE$ 证书有效；策略匹配（$P_1$），且名称约束不适用于主体专有名称中的 $OU$ 属性。**\n该陈述在两点上是错误的。首先，如上所述，证书是无效的。其次，声称名称约束不适用于 $OU$ 属性是错误的。`directoryName` 约束通过执行前缀匹配，适用于整个专有名称结构，包括 $OU$ 属性。策略匹配是无关紧要的，因为名称约束检查失败了。\n**结论：不正确**\n\n**C. $EE$ 证书无效；失败发生在信任锚处，因为 $Root$ 没有声明策略 $P_1$。**\n该陈述是错误的。虽然证书是无效的，但引用的原因不正确。根据 RFC 5280，路径验证过程使用用户提供的一组策略（`initial-policy-set`）进行初始化。并不要求信任锚本身包含这些策略之一。路径验证的失败是由于名称约束，而不是在根部的策略处理。\n**结论：不正确**\n\n**D. $EE$ 证书有效；$SubCA$ 的名称约束仅适用于主体别名（$SAN$）条目，而不适用于主体专有名称。**\n该陈述是错误的。它声称证书有效，这与推导相矛盾。其提供的核心理由在事实上是错误的。正如 RFC 5280 第 4.2.1.10 节明确指出的，名称约束同时适用于 `subject` 专有名称和 `Subject Alternative Name` 扩展中的任何名称。\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在高性能网络物理系统（如数字孪生编排节点）中，密码学算法的选择直接影响系统的延迟和稳定性。本练习将理论与实践相结合，要求您应用排队论（`Queuing Theory`）来分析和比较不同签名算法（ECDSA与RSA）对TLS握手延迟的影响。通过计算，您将量化性能差异，并为满足严格延迟预算的系统选择最优算法，这对于确保实时CPS应用的响应能力至关重要。",
            "id": "4237545",
            "problem": "一个作为数字孪生编排节点的信息物理系统（Cyber-Physical Systems, CPS）控制器，使用公钥基础设施（Public Key Infrastructure, PKI）来终止来自分布式现场设备的双向传输层安全（Transport Layer Security, TLS）连接。每次传入的双向 TLS 握手都要求控制器执行恰好 $s$ 次独立的签名验证（一次对客户端 CertificateVerify 消息的验证和一次对客户端终端实体证书签名的验证），因此 $s=2$。控制器接收连接的总速率为 $\\Lambda=2000$ 连接/秒，这可以建模为一个泊松过程。签名验证阶段作为一个单线程服务运行，可以建模为 $M/M/1$ 队列。有两种候选算法可用于客户端认证：\n\n- 基于 NIST P-256 曲线的椭圆曲线数字签名算法（Elliptic Curve Digital Signature Algorithm, ECDSA），其测得的验证吞吐量为 $5000$ 次验证/秒。\n- 使用 $2048$ 位密钥的 Rivest–Shamir–Adleman (RSA) 算法，其测得的验证吞吐量为 $800$ 次验证/秒。\n\n假设服务时间呈指数分布，其均值为测得吞吐量的倒数，且到达是独立的。控制器的端到端握手延迟预算为每个连接的签名验证阶段专门分配了 $B=20$ 毫秒。仅使用吞吐量、到达率以及关于稳定性和系统中期望时间的 $M/M/1$ 队列结果的基本定义，从第一性原理推导出每种算法的每个连接的期望验证延迟，确定哪种算法可以满足延迟预算，并为满足预算的算法计算延迟余量 $M=B - T_{\\text{verify}}$，其中 $T_{\\text{verify}}$ 是归因于签名验证阶段的每个连接的期望验证延迟。以毫秒为单位表示最终余量，并将答案四舍五入到四位有效数字。",
            "solution": "该场景是一个处理信息物理系统（CPS）控制器中双向传输层安全（TLS）握手签名验证任务的单个服务站。每个连接需要 $s=2$ 次独立的签名验证任务。连接的到达过程被建模为速率为 $\\Lambda=2000$ 连接/秒的泊松过程，每个连接贡献 $s$ 个任务。因此，验证任务的总到达率为\n$$\n\\lambda = s \\Lambda.\n$$\n对于每种算法，都有一个以操作/秒为单位的测得验证吞吐量，我们将其解释为 $M/M/1$ 服务站的服务率。设 $\\mu$ 表示以验证任务/秒为单位的服务率。对于 Elliptic Curve Digital Signature Algorithm (ECDSA) P-256，$\\mu_{E}=5000$。对于使用 $2048$ 位密钥的 Rivest–Shamir–Adleman (RSA)，$\\mu_{R}=800$。\n\n在到达率为 $\\lambda$、服务率为 $\\mu$ 的 $M/M/1$ 模型下，稳定性要求 $\\lambda < \\mu$。对于一个稳定的 $M/M/1$ 系统，单个作业（验证任务）在系统中的期望时间（等待时间加服务时间）由从 Little’s law 和稳态队长推导出的著名结果给出：\n$$\nW = \\frac{1}{\\mu - \\lambda}.\n$$\n这个结果是因为系统中的期望数量为\n$$\nL = \\frac{\\lambda}{\\mu - \\lambda},\n$$\n并且根据 Little’s law，$L = \\lambda W$，因此 $W = L/\\lambda = 1/(\\mu - \\lambda)$。\n\n每个连接需要 $s$ 个这样的任务。将每个验证任务视为独立排队和服务的（在期望中，一个连接的任务在其他到达的任务中按顺序处理），每个连接的期望总验证延迟是 $s$ 个任务的总和：\n$$\nT_{\\text{verify}} = s W = \\frac{s}{\\mu - \\lambda}.\n$$\n我们现在为每种算法实例化 $\\lambda$ 和 $\\mu$：\n$$\n\\lambda = s \\Lambda = 2 \\times 2000 = 4000.\n$$\n\n1. Elliptic Curve Digital Signature Algorithm (ECDSA) P-256：\n   - 服务率 $\\mu_{E} = 5000$。\n   - 检查稳定性：$\\lambda = 4000 < \\mu_{E} = 5000$，因此系统是稳定的。\n   - 每个连接的期望验证延迟：\n     $$\n     T_{\\text{verify},E} = \\frac{s}{\\mu_{E} - \\lambda} = \\frac{2}{5000 - 4000} = \\frac{2}{1000} = 0.002 \\text{ seconds}.\n     $$\n     使用 $1 \\text{ second} = 1000 \\text{ milliseconds}$ 转换为毫秒，得到\n     $$\n     T_{\\text{verify},E} = 0.002 \\times 1000 = 2 \\text{ milliseconds}.\n     $$\n\n2. Rivest–Shamir–Adleman (RSA) $2048$：\n   - 服务率 $\\mu_{R} = 800$。\n   - 检查稳定性：$\\lambda = 4000 > \\mu_{R} = 800$，因此 $M/M/1$ 系统是不稳定的；系统中的期望时间是发散的，不存在有限的期望验证延迟。因此，在这种配置下，RSA-2048 无法满足任何有限的延迟预算。\n\n只有 Elliptic Curve Digital Signature Algorithm (ECDSA) P-256 满足稳定性准则，可以根据延迟预算进行评估。分配给验证的延迟预算为 $B = 20$ 毫秒。Elliptic Curve Digital Signature Algorithm (ECDSA) 的延迟余量为\n$$\nM = B - T_{\\text{verify},E} = 20 - 2 = 18 \\text{ milliseconds}.\n$$\n将 $18$ 毫秒四舍五入到四位有效数字得到 $18.00$ 毫秒。所要求的最终答案是满足预算的算法（即 Elliptic Curve Digital Signature Algorithm (ECDSA) P-256）的延迟余量（以毫秒为单位）。",
            "answer": "$$\\boxed{18.00}$$"
        }
    ]
}