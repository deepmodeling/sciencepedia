{
    "hands_on_practices": [
        {
            "introduction": "Many cyber-physical systems rely on state estimators and residual-based detectors to ensure normal operation. The core idea is that significant deviations between measurements and model predictions signal an anomaly or attack. This exercise challenges that assumption by exploring the concept of an unobservable, or \"stealthy,\" false data injection attack. By deriving the algebraic conditions for such an attack using linear algebra, you will gain a fundamental understanding of a critical vulnerability class where an adversary can manipulate the system's perceived state without triggering an alarm .",
            "id": "4244500",
            "problem": "In a linearized monitoring layer of a Cyber-Physical System (CPS), the digital twin uses a static measurement model $y \\in \\mathbb{R}^{m}$ given by $y = Hx + e$, where $x \\in \\mathbb{R}^{n}$ is the system state, $H \\in \\mathbb{R}^{m \\times n}$ is the measurement matrix, and $e \\in \\mathbb{R}^{m}$ is measurement noise. The residual-based bad-data detector computes the residual $r = y - H\\hat{x}$, where the state estimate $\\hat{x}$ is obtained by the least-squares estimator $\\hat{x} \\in \\arg\\min_{z \\in \\mathbb{R}^{n}} \\|y - Hz\\|_{2}$. An adversary injects a false data vector $a \\in \\mathbb{R}^{m}$ so that the measured vector becomes $y' = y + a$. An attack is said to be unobservable if the residual under attack equals the nominal residual, i.e., $r' = r$, where $r' = y' - H\\hat{x}'$ and $\\hat{x}'$ is the least-squares estimate from $y'$.\n\nStarting only from the definitions of least-squares projection in Euclidean space and the residual, derive the algebraic characterization of all unobservable attacks. Express the final result as a closed-form expression for a general unobservable attack vector solely in terms of $H$ and a free parameter. Your final answer must be a single closed-form expression and contain no words.",
            "solution": "The problem requires the derivation of the algebraic characterization of all unobservable attack vectors $a$. An attack is defined as unobservable if the measurement residual remains unchanged after the injection of false data.\n\nLet us begin with the definitions provided. The nominal measurement model is $y = Hx + e$, where $y \\in \\mathbb{R}^{m}$, $x \\in \\mathbb{R}^{n}$, $H \\in \\mathbb{R}^{m \\times n}$, and $e \\in \\mathbb{R}^{m}$. The state estimate $\\hat{x}$ is obtained via the least-squares method:\n$$ \\hat{x} \\in \\arg\\min_{z \\in \\mathbb{R}^{n}} \\|y - Hz\\|_{2} $$\nThis minimization problem has a unique geometric interpretation. The vector $H\\hat{x}$ is the orthogonal projection of the measurement vector $y$ onto the column space of the matrix $H$, which we denote as $\\text{Im}(H)$. Let $P_{H}$ be the orthogonal projection matrix that projects vectors in $\\mathbb{R}^{m}$ onto the subspace $\\text{Im}(H)$. Then, we can write:\n$$ H\\hat{x} = P_{H}y $$\nThe nominal residual vector, $r$, is defined as $r = y - H\\hat{x}$. Substituting the expression for $H\\hat{x}$, we obtain:\n$$ r = y - P_{H}y = (I - P_{H})y $$\nHere, $I$ is the $m \\times m$ identity matrix. The matrix $I - P_{H}$ is itself a projection matrix. It projects vectors onto the orthogonal complement of $\\text{Im}(H)$, which is the null space of the transpose of $H$, denoted $\\mathcal{N}(H^T)$.\n\nNow, we consider the system under attack. An adversary injects a false data vector $a \\in \\mathbb{R}^{m}$, resulting in a new measurement vector $y' = y + a$. The least-squares estimate under attack, $\\hat{x}'$, is found by minimizing $\\|y' - Hz\\|_{2}$:\n$$ \\hat{x}' \\in \\arg\\min_{z \\in \\mathbb{R}^{n}} \\|y' - Hz\\|_{2} $$\nAnalogous to the nominal case, the resulting vector $H\\hat{x}'$ is the orthogonal projection of the attacked measurement vector $y'$ onto the column space of $H$:\n$$ H\\hat{x}' = P_{H}y' $$\nThe residual under attack, $r'$, is then:\n$$ r' = y' - H\\hat{x}' = y' - P_{H}y' = (I - P_{H})y' $$\nAn attack is defined as unobservable if the residual does not change, i.e., $r' = r$. We enforce this condition using the derived expressions for the residuals:\n$$ (I - P_{H})y' = (I - P_{H})y $$\nSubstitute $y' = y + a$ into this equation:\n$$ (I - P_{H})(y + a) = (I - P_{H})y $$\nBy the linearity of the matrix-vector product, we can expand the left side of the equation:\n$$ (I - P_{H})y + (I - P_{H})a = (I - P_{H})y $$\nSubtracting the term $(I - P_{H})y$ from both sides, we are left with a condition solely on the attack vector $a$:\n$$ (I - P_{H})a = 0 $$\nThis equation signifies that the projection of the attack vector $a$ onto the subspace $\\mathcal{N}(H^T)$ is the zero vector. This is only true if the vector $a$ is orthogonal to every vector in $\\mathcal{N}(H^T)$. The set of all vectors orthogonal to $\\mathcal{N}(H^T)$ is precisely its orthogonal complement, $(\\mathcal{N}(H^T))^{\\perp}$. By the fundamental theorem of linear algebra, the orthogonal complement of the null space of $H^T$ is the column space (image) of $H$. Therefore, the condition is equivalent to:\n$$ a \\in \\text{Im}(H) $$\nThis means that for an attack to be unobservable, the attack vector $a$ must lie in the column space of the measurement matrix $H$. Any vector in the column space of $H$ can be expressed as a linear combination of the columns of $H$. This can be written in a compact form by stating that there must exist a vector $c \\in \\mathbb{R}^n$ such that:\n$$ a = Hc $$\nThe vector $c$ is a free parameter vector that defines a specific unobservable attack. This expression provides the complete algebraic characterization of all unobservable attack vectors.",
            "answer": "$$ \\boxed{Hc} $$"
        },
        {
            "introduction": "After establishing that stealthy attacks are theoretically possible, it's crucial to analyze their tangible impact on physical infrastructure. Power systems, with their reliance on precise, synchronized measurements, are particularly vulnerable to timing attacks. This practice provides a concrete example of the cyber-physical link, requiring you to quantify the physical consequences—a false differential current—of a cyber-attack in the form of a GPS timing offset . This skill is essential for assessing the real-world risk posed by such vulnerabilities in critical infrastructure protection.",
            "id": "4244553",
            "problem": "A transmission line in a cyber-physical power system uses a line current differential protection scheme implemented with time-synchronized phasor measurements at terminals A and B. Each terminal hosts a Phasor Measurement Unit (PMU) that computes the fundamental-frequency current phasor from uniformly sampled data using a one-cycle Discrete Fourier Transform (DFT) at the nominal frequency. The sampling rate is $f_{s} = 4800\\,\\text{Hz}$ on a $f_{0} = 60\\,\\text{Hz}$ system, so that $N = 80$ samples per nominal cycle are used. The relay computes the differential current decision variable as the magnitude $I_{\\text{diff}} = \\left| \\hat{I}_{A} + \\hat{I}_{B} \\right|$, where $\\hat{I}_{A}$ and $\\hat{I}_{B}$ are the complex phasor estimates produced by the PMUs at A and B, respectively. Under secure operation with through-load (no internal fault), the true synchronized phasors satisfy $\\hat{I}_{B}^{\\text{true}} = -\\hat{I}_{A}^{\\text{true}}$ because the terminal currents are equal in magnitude and opposite in direction when referenced to a consistent sign convention.\n\nAn adversary successfully induces a Global Positioning System (GPS) time offset of $\\Delta t = 50\\,\\mu\\text{s}$ at terminal B only, causing terminal B’s PMU to compute its DFT phasor against a reference that is shifted in time relative to terminal A. Assume ideal anti-aliasing, no measurement noise, a rectangular one-cycle window, and that the fundamental input is a perfect sinusoid at the nominal frequency $f_{0}$. The through current magnitude at each terminal is $1.2$ per-unit on a $I_{\\text{base}} = 2\\,\\text{kA}$ base, and per-unit is defined on this base.\n\nStarting only from fundamental definitions of uniform sampling, the $N$-point DFT at the fundamental, and the relation between continuous-time shifts and complex exponentials in Fourier analysis, derive the resulting closed-form expression for the false differential current magnitude $I_{\\text{diff}}$ caused solely by the time offset at terminal B, and compute the minimum per-unit pickup threshold $T_{\\min}$ such that the relay decision rule $I_{\\text{diff}} > T$ does not falsely trip under the stated through-load. Express $T_{\\min}$ in per-unit and round your answer to four significant figures.",
            "solution": "The problem requires us to derive the magnitude of a false differential current, $I_{\\text{diff}}$, that arises from a time synchronization error at one of two measurement terminals, and then to determine the minimum relay setting to prevent a false operation.\n\nLet $\\hat{I}_{A}^{\\text{true}}$ and $\\hat{I}_{B}^{\\text{true}}$ be the true complex phasors of the currents at terminals A and B, respectively, under a through-load condition. A consistent sign convention for differential protection dictates that current entering the protected zone is positive. For a through-load, the current entering at terminal A equals the current exiting at terminal B. Therefore, their true phasors are equal in magnitude and opposite in direction:\n$$ \\hat{I}_{B}^{\\text{true}} = -\\hat{I}_{A}^{\\text{true}} $$\nThe magnitude of the current at each terminal is given as $I_{\\text{mag}} = 1.2\\,\\text{p.u.}$. Thus, we have:\n$$ |\\hat{I}_{A}^{\\text{true}}| = |\\hat{I}_{B}^{\\text{true}}| = I_{\\text{mag}} = 1.2\\,\\text{p.u.} $$\nThe PMU at terminal A is assumed to have a perfect time reference. Therefore, its measured phasor, $\\hat{I}_{A}$, is equal to the true phasor:\n$$ \\hat{I}_{A} = \\hat{I}_{A}^{\\text{true}} $$\nThe PMU at terminal B is subject to a time offset of $\\Delta t = 50\\,\\mu\\text{s}$. This means its local clock is delayed by $\\Delta t$ with respect to the true system time. If the true system time is $t$, the PMU at B believes the time is $t' = t - \\Delta t$. Consequently, when it performs its DFT calculation over what it perceives to be a one-cycle window, it is actually processing the signal from the time interval $[t, t+T_0]$ instead of the correct interval $[t', t'+T_0] = [t-\\Delta t, t-\\Delta t+T_0]$. This is equivalent to analyzing a time-advanced version of the signal, $i_B(t'+\\Delta t)$.\n\nA fundamental property of the Fourier transform is that a time shift in the time domain corresponds to a phase shift in the frequency domain. For a signal $x(t)$ with Fourier transform $X(\\omega)$, the transform of the time-shifted signal $x(t - t_0)$ is $X(\\omega)e^{-j\\omega t_0}$. Conversely, the transform of a time-advanced signal $x(t+t_0)$ is $X(\\omega)e^{j\\omega t_0}$.\n\nThe PMU at B effectively measures the phasor of the signal $i_B(t'+\\Delta t)$. Therefore, the measured phasor $\\hat{I}_B$ is the true phasor $\\hat{I}_B^{\\text{true}}$ multiplied by a complex exponential corresponding to a time advance of $\\Delta t$ at the fundamental angular frequency $\\omega_0 = 2\\pi f_0$:\n$$ \\hat{I}_{B} = \\hat{I}_{B}^{\\text{true}} e^{j\\omega_0 \\Delta t} = \\hat{I}_{B}^{\\text{true}} e^{j2\\pi f_0 \\Delta t} $$\nNow, we can compute the differential current decision variable, $I_{\\text{diff}}$, using the measured phasors:\n$$ I_{\\text{diff}} = |\\hat{I}_{A} + \\hat{I}_{B}| $$\nSubstituting the expressions for the measured phasors:\n$$ I_{\\text{diff}} = |\\hat{I}_{A}^{\\text{true}} + \\hat{I}_{B}^{\\text{true}} e^{j2\\pi f_0 \\Delta t}| $$\nUsing the through-load condition $\\hat{I}_{B}^{\\text{true}} = -\\hat{I}_{A}^{\\text{true}}$:\n$$ I_{\\text{diff}} = |\\hat{I}_{A}^{\\text{true}} - \\hat{I}_{A}^{\\text{true}} e^{j2\\pi f_0 \\Delta t}| $$\nFactor out $\\hat{I}_{A}^{\\text{true}}$:\n$$ I_{\\text{diff}} = |\\hat{I}_{A}^{\\text{true}}(1 - e^{j2\\pi f_0 \\Delta t})| = |\\hat{I}_{A}^{\\text{true}}| |1 - e^{j2\\pi f_0 \\Delta t}| $$\nLet $\\theta = 2\\pi f_0 \\Delta t$. The expression becomes:\n$$ I_{\\text{diff}} = I_{\\text{mag}} |1 - e^{j\\theta}| $$\nTo evaluate the magnitude $|1 - e^{j\\theta}|$, we use Euler's formula, $e^{j\\theta} = \\cos(\\theta) + j\\sin(\\theta)$:\n$$ |1 - e^{j\\theta}| = |1 - (\\cos(\\theta) + j\\sin(\\theta))| = |(1 - \\cos(\\theta)) - j\\sin(\\theta)| $$\nThe magnitude of a complex number $x+jy$ is $\\sqrt{x^2+y^2}$:\n$$ |1 - e^{j\\theta}| = \\sqrt{(1-\\cos(\\theta))^2 + (-\\sin(\\theta))^2} = \\sqrt{1 - 2\\cos(\\theta) + \\cos^2(\\theta) + \\sin^2(\\theta)} $$\nUsing the identity $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$:\n$$ |1 - e^{j\\theta}| = \\sqrt{1 - 2\\cos(\\theta) + 1} = \\sqrt{2(1 - \\cos(\\theta))} $$\nUsing the half-angle trigonometric identity $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$:\n$$ |1 - e^{j\\theta}| = \\sqrt{2(2\\sin^2\\left(\\frac{\\theta}{2}\\right))} = \\sqrt{4\\sin^2\\left(\\frac{\\theta}{2}\\right)} = \\left|2\\sin\\left(\\frac{\\theta}{2}\\right)\\right| $$\nSubstituting this back into the expression for $I_{\\text{diff}}$:\n$$ I_{\\text{diff}} = I_{\\text{mag}} \\left|2\\sin\\left(\\frac{2\\pi f_0 \\Delta t}{2}\\right)\\right| = 2I_{\\text{mag}} |\\sin(\\pi f_0 \\Delta t)| $$\nSince $f_0 = 60\\,\\text{Hz}$ and $\\Delta t = 50 \\times 10^{-6}\\,\\text{s}$ are both positive, the argument $\\pi f_0 \\Delta t$ is a small positive angle, for which the sine is positive. Thus, the absolute value is redundant. The final closed-form expression for the false differential current is:\n$$ I_{\\text{diff}} = 2 I_{\\text{mag}} \\sin(\\pi f_0 \\Delta t) $$\nThis completes the first part of the task.\n\nFor the second part, we must find the minimum pickup threshold $T_{\\min}$ that prevents a false trip. The relay trip condition is $I_{\\text{diff}} > T$. To remain secure (not trip) under this condition, the threshold $T$ must be set greater than or equal to the calculated $I_{\\text{diff}}$. The minimum value for such a threshold is therefore equal to the value of $I_{\\text{diff}}$ we just derived.\n$$ T_{\\min} = I_{\\text{diff}} = 2 I_{\\text{mag}} \\sin(\\pi f_0 \\Delta t) $$\nWe substitute the given numerical values: $I_{\\text{mag}} = 1.2\\,\\text{p.u.}$, $f_0 = 60\\,\\text{Hz}$, and $\\Delta t = 50 \\times 10^{-6}\\,\\text{s}$.\n$$ T_{\\min} = 2(1.2) \\sin(\\pi \\cdot 60 \\cdot 50 \\times 10^{-6}) $$\n$$ T_{\\min} = 2.4 \\sin(3000 \\pi \\times 10^{-6}) $$\n$$ T_{\\min} = 2.4 \\sin(0.003\\pi) $$\nThe argument of the sine function is in radians. Now we compute the numerical value:\n$$ 0.003\\pi \\approx 0.009424778\\,\\text{rad} $$\n$$ T_{\\min} = 2.4 \\times \\sin(0.009424778) \\approx 2.4 \\times 0.009424433 $$\n$$ T_{\\min} \\approx 0.02261864\\,\\text{p.u.} $$\nThe problem requires the answer rounded to four significant figures.\n$$ T_{\\min} \\approx 0.02262\\,\\text{p.u.} $$\nThis is the minimum per-unit pickup threshold required to ensure the relay does not falsely trip due to the specified $50\\,\\mu\\text{s}$ time synchronization error.",
            "answer": "$$ \\boxed{0.02262} $$"
        },
        {
            "introduction": "Since attacks can be both stealthy and physically damaging, we need robust methods to guarantee safety. Formal verification techniques offer a way to mathematically prove that a system will not enter an unsafe state, even under attack. This hands-on coding exercise introduces you to reachability analysis using zonotopes, a powerful method for over-approximating all possible system states over time . By implementing this algorithm, you will learn how to formally verify whether a CPS remains within its safe operating envelope despite uncertainties and bounded adversarial inputs.",
            "id": "4244543",
            "problem": "Consider a discrete-time Linear Time-Invariant (LTI) Cyber-Physical System (CPS), where the system state evolves as $x_{k+1} = A x_k + B u_k + E a_k$. Here, $x_k \\in \\mathbb{R}^n$ is the state at step $k$, $u_k \\in \\mathbb{R}^p$ is a bounded control input, and $a_k \\in \\mathbb{R}^q$ is a bounded attack input. A Digital Twin is tasked to over-approximate the reachable set of states under these bounded inputs and to verify whether a safety property holds for all states reachable over a finite horizon.\n\nUse the set representation known as a zonotope. A zonotope $Z$ is defined by a center $c \\in \\mathbb{R}^n$ and generator columns $G \\in \\mathbb{R}^{n \\times m}$, and represents the set $Z = \\{ c + G \\xi \\mid \\xi \\in \\mathbb{R}^m, \\|\\xi\\|_{\\infty} \\le 1 \\}$. The Minkowski sum of two zonotopes $Z_1 = (c_1, G_1)$ and $Z_2 = (c_2, G_2)$ is the zonotope $(c_1 + c_2, [G_1 \\; G_2])$, and the linear image of a zonotope $Z = (c,G)$ under a matrix $M$ is the zonotope $(M c, M G)$. Using these two operations, the reachable zonotope at step $k+1$ under bounded control and attack inputs represented as zonotopes $U = (c_u, G_u)$ and $A_{\\text{atk}} = (c_a, G_a)$, respectively, is computed by\n$$\nZ_{k+1} = A Z_k \\oplus B U \\oplus E A_{\\text{atk}},\n$$\nstarting from an initial zonotope $Z_0 = (c_0, G_0)$.\n\nThe safety property is specified by a convex polytope $S = \\{ x \\in \\mathbb{R}^n \\mid H x \\le b \\}$, where $H \\in \\mathbb{R}^{r \\times n}$ and $b \\in \\mathbb{R}^r$. For each inequality row vector $h_i^\\top$ of $H$ and bound $b_i$, the zonotope $Z = (c,G)$ satisfies $h_i^\\top x \\le b_i$ for all $x \\in Z$ if and only if\n$$\nh_i^\\top c + \\sum_{j=1}^m |h_i^\\top g_j| \\le b_i,\n$$\nwhere $g_j$ denotes the $j$-th generator column of $G$. Therefore, verifying $Z \\subseteq S$ reduces to checking the above inequality for all rows $i \\in \\{1,\\dots,r\\}$.\n\nYour task is to implement a program that:\n- Over-approximates the reachable zonotopes $\\{Z_k\\}_{k=0}^H$ for a finite horizon $H$ using the recursion above with zonotope operations.\n- Verifies whether the safety property holds for every reachable zonotope $Z_k$ with $k \\in \\{0,1,\\dots,H\\}$.\n\nExpress the final results for several test cases as booleans, each indicating whether the property holds for all steps in the specified horizon. The program must produce a single output line containing a comma-separated list of booleans enclosed in square brackets, for example, $[{\\tt True},{\\tt False}]$.\n\nNo physical units are involved in this problem. All angles, if any, must be in radians (although none are used here). Percentages are not used.\n\nUse the following test suite of parameter values, which collectively test a general case, a boundary condition, a degenerate case with no generators, and an attack-dominated violation case:\n\nTest Case $1$ (general \"happy path\"):\n- $A = \\begin{bmatrix} 0.92 & 0.08 \\\\ 0.00 & 0.96 \\end{bmatrix}$, $B = \\begin{bmatrix} 0.10 \\\\ 0.05 \\end{bmatrix}$, $E = \\begin{bmatrix} 0.05 \\\\ 0.02 \\end{bmatrix}$.\n- $Z_0$: $c_0 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $G_0 = \\begin{bmatrix} 0.02 & 0.00 \\\\ 0.00 & 0.02 \\end{bmatrix}$.\n- Control zonotope $U$: $c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_u = \\begin{bmatrix} 0.10 \\end{bmatrix}$.\n- Attack zonotope $A_{\\text{atk}}$: $c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_a = \\begin{bmatrix} 0.05 \\end{bmatrix}$.\n- Safety polytope $S$ axis-aligned box with $H = \\begin{bmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 0 & 1 \\\\ 0 & -1 \\end{bmatrix}$ and $b = \\begin{bmatrix} 0.50 \\\\ 0.50 \\\\ 0.50 \\\\ 0.50 \\end{bmatrix}$.\n- Horizon $H = 15$ (integers count of steps).\n\nTest Case $2$ (boundary condition):\n- $A = \\begin{bmatrix} 1.00 & 0.00 \\\\ 0.00 & 1.00 \\end{bmatrix}$, $B = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $E = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$.\n- $Z_0$: $c_0 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $G_0 = \\begin{bmatrix} 0.50 \\\\ 0.00 \\end{bmatrix}$ (a single generator column).\n- Control zonotope $U$: $c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_u$ is the empty matrix in $\\mathbb{R}^{1 \\times 0}$.\n- Attack zonotope $A_{\\text{atk}}$: $c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_a$ is the empty matrix in $\\mathbb{R}^{1 \\times 0}$.\n- Safety polytope $S$ with $H = \\begin{bmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 0 & 1 \\\\ 0 & -1 \\end{bmatrix}$ and $b = \\begin{bmatrix} 0.50 \\\\ 0.50 \\\\ 10.00 \\\\ 10.00 \\end{bmatrix}$.\n- Horizon $H = 1$.\n\nTest Case $3$ (degenerate zonotope, violation):\n- $A = \\begin{bmatrix} 1.00 & 0.00 \\\\ 0.00 & 1.00 \\end{bmatrix}$, $B = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $E = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$.\n- $Z_0$: $c_0 = \\begin{bmatrix} 1.20 \\\\ 0.00 \\end{bmatrix}$, $G_0$ is the empty matrix in $\\mathbb{R}^{2 \\times 0}$.\n- Control zonotope $U$: $c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_u$ is the empty matrix in $\\mathbb{R}^{1 \\times 0}$.\n- Attack zonotope $A_{\\text{atk}}$: $c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_a$ is the empty matrix in $\\mathbb{R}^{1 \\times 0}$.\n- Safety polytope $S$ with $H = \\begin{bmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 0 & 1 \\\\ 0 & -1 \\end{bmatrix}$ and $b = \\begin{bmatrix} 1.00 \\\\ 1.00 \\\\ 1.00 \\\\ 1.00 \\end{bmatrix}$.\n- Horizon $H = 5$.\n\nTest Case $4$ (attack-dominated violation):\n- $A = \\begin{bmatrix} 0.98 & 0.05 \\\\ 0.00 & 0.97 \\end{bmatrix}$, $B = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $E = \\begin{bmatrix} 0.20 \\\\ 0.10 \\end{bmatrix}$.\n- $Z_0$: $c_0 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $G_0 = \\begin{bmatrix} 0.01 & 0.00 \\\\ 0.00 & 0.01 \\end{bmatrix}$.\n- Control zonotope $U$: $c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_u$ is the empty matrix in $\\mathbb{R}^{1 \\times 0}$.\n- Attack zonotope $A_{\\text{atk}}$: $c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$, $G_a = \\begin{bmatrix} 0.20 \\end{bmatrix}$.\n- Safety polytope $S$ with $H = \\begin{bmatrix} 1 & 0 \\\\ -1 & 0 \\\\ 0 & 1 \\\\ 0 & -1 \\end{bmatrix}$ and $b = \\begin{bmatrix} 0.30 \\\\ 0.30 \\\\ 0.30 \\\\ 0.30 \\end{bmatrix}$.\n- Horizon $H = 10$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[{\\tt True},{\\tt False},{\\tt True},{\\tt False}]$), corresponding to Test Cases $1$ through $4$ in order.",
            "solution": "The problem requires the verification of a safety property for a discrete-time Linear Time-Invariant (LTI) Cyber-Physical System over a finite time horizon. The system dynamics are given by the state-space equation $x_{k+1} = A x_k + B u_k + E a_k$, where $x_k \\in \\mathbb{R}^n$ is the state vector, $u_k \\in \\mathbb{R}^p$ is the control input, and $a_k \\in \\mathbb{R}^q$ is an attack input at step $k$. The analysis is to be performed using zonotope-based reachability analysis, which provides an over-approximate set of all possible states.\n\nA zonotope $Z$ is a set defined by a center $c \\in \\mathbb{R}^n$ and a generator matrix $G \\in \\mathbb{R}^{n \\times m}$, such that $Z = \\{ c + G \\xi \\mid \\xi \\in \\mathbb{R}^m, \\|\\xi\\|_{\\infty} \\le 1 \\}$. The core of the reachability computation relies on two fundamental operations on zonotopes:\n1.  **Linear Transformation**: The image of a zonotope $Z = (c, G)$ under a linear map represented by a matrix $M$ is another zonotope $M Z = (M c, M G)$.\n2.  **Minkowski Sum**: The Minkowski sum of two zonotopes $Z_1 = (c_1, G_1)$ and $Z_2 = (c_2, G_2)$ is the zonotope $Z_1 \\oplus Z_2 = (c_1 + c_2, [G_1 \\; G_2])$, where $[G_1 \\; G_2]$ is the horizontal concatenation of the generator matrices.\n\nThe reachable set of states at step $k+1$, denoted as the zonotope $Z_{k+1}$, is computed from the zonotope at step $k$, $Z_k$, and the zonotopes representing the bounded control and attack inputs, $U = (c_u, G_u)$ and $A_{\\text{atk}} = (c_a, G_a)$, respectively. The propagation rule is:\n$$Z_{k+1} = A Z_k \\oplus B U \\oplus E A_{\\text{atk}}$$\nBy applying the definitions of the linear transformation and Minkowski sum, we derive the recursive formulas for the center $c_{k+1}$ and generator matrix $G_{k+1}$ of the zonotope $Z_{k+1}$:\n$$c_{k+1} = A c_k + B c_u + E c_a$$\n$$G_{k+1} = [A G_k \\quad B G_u \\quad E G_a]$$\n\nThe safety property is specified by a convex polytope $S = \\{ x \\in \\mathbb{R}^n \\mid H x \\le b \\}$, where $H \\in \\mathbb{R}^{r \\times n}$ and $b \\in \\mathbb{R}^r$. A zonotope $Z_k = (c_k, G_k)$ is contained within $S$ if and only if for every row $h_i^\\top$ of $H$ and its corresponding bound $b_i$, the following inequality holds:\n$$h_i^\\top c_k + \\sum_{j=1}^m |h_i^\\top g_j| \\le b_i$$\nwhere $g_j$ are the columns of $G_k$. The summation term $\\sum_{j=1}^m |h_i^\\top g_j|$ is equivalent to the L1-norm of the row vector $h_i^\\top G_k$, which we can write as $\\|h_i^\\top G_k\\|_1$.\n\nThe algorithm to solve the problem for each test case is as follows:\n1.  Initialize a boolean flag, `is_safe_for_horizon`, to `True`.\n2.  Set the initial zonotope $(c_k, G_k)$ to the given $(c_0, G_0)$.\n3.  Iterate for each time step $k$ from $0$ to the specified horizon $H$.\n4.  At each step $k$, verify if the current zonotope $Z_k = (c_k, G_k)$ satisfies the safety property. This involves checking the inequality $h_i^\\top c_k + \\|h_i^\\top G_k\\|_1 \\le b_i$ for all rows $i=1, \\dots, r$ of the matrix $H$.\n5.  If any of these inequalities are violated, the system is unsafe. Set `is_safe_for_horizon` to `False` and break the loop for the current test case.\n6.  If the safety check passes and $k < H$, compute the next reachable zonotope $Z_{k+1} = (c_{k+1}, G_{k+1})$ using the propagation formulas. Update $(c_k, G_k)$ to $(c_{k+1}, G_{k+1})$ for the next iteration.\n7.  After the loop completes, the value of `is_safe_for_horizon` is the result for that test case.\n\nThis procedure is implemented and applied to the four provided test cases. The implementation uses the `numpy` library for efficient matrix and vector computations. It correctly handles zonotopes with empty generator matrices, which represent single points; for such zonotopes, the term $\\|h_i^\\top G_k\\|_1$ correctly evaluates to $0$.\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_verification(A, B, E, z0_c, z0_G, u_c, u_G, a_c, a_G, H_safe, b_safe, horizon):\n    \"\"\"\n    Performs reachability analysis and safety verification for a single test case.\n\n    Args:\n        A, B, E (np.ndarray): System matrices.\n        z0_c, z0_G (np.ndarray): Center and generators of the initial zonotope Z0.\n        u_c, u_G (np.ndarray): Center and generators of the control zonotope U.\n        a_c, a_G (np.ndarray): Center and generators of the attack zonotope A_atk.\n        H_safe (np.ndarray): Matrix defining the safety polytope S.\n        b_safe (np.ndarray): Vector defining the safety polytope S.\n        horizon (int): The finite time horizon for verification.\n\n    Returns:\n        bool: True if the system is safe for all steps up to the horizon, False otherwise.\n    \"\"\"\n    c_k = z0_c\n    G_k = z0_G\n    \n    for k in range(horizon + 1):\n        # Step 1: Safety Verification for Z_k = (c_k, G_k)\n        for i in range(H_safe.shape[0]):\n            h_i = H_safe[i, :]\n            b_i = b_safe[i]\n            \n            # The sum term is the L1 norm of the row vector h_i^T * G_k\n            # np.sum(np.abs(...)) is numerically robust for vectors.\n            l1_norm_term = np.sum(np.abs(h_i @ G_k))\n            \n            check_value = h_i @ c_k + l1_norm_term\n            \n            # Using a small tolerance for floating point comparisons\n            if check_value > b_i + 1e-9:\n                return False # Safety violated\n\n        # Step 2: Propagation to Z_{k+1}, if not the last step\n        if k  horizon:\n            c_k_plus_1 = A @ c_k + B @ u_c + E @ a_c\n            \n            G_k_plus_1_parts = []\n            if G_k.shape[1] > 0:\n                G_k_plus_1_parts.append(A @ G_k)\n            if u_G.shape[1] > 0:\n                G_k_plus_1_parts.append(B @ u_G)\n            if a_G.shape[1] > 0:\n                G_k_plus_1_parts.append(E @ a_G)\n            \n            if G_k_plus_1_parts:\n                G_k_plus_1 = np.hstack(G_k_plus_1_parts)\n            else: # If all generator matrices are empty\n                G_k_plus_1 = np.empty((A.shape[0], 0))\n\n            c_k = c_k_plus_1\n            G_k = G_k_plus_1\n            \n    return True # Safe for the entire horizon\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for CPS safety verification.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (general \"happy path\"):\n        {\n            \"A\": np.array([[0.92, 0.08], [0.00, 0.96]]),\n            \"B\": np.array([[0.10], [0.05]]),\n            \"E\": np.array([[0.05], [0.02]]),\n            \"z0_c\": np.array([0.00, 0.00]),\n            \"z0_G\": np.array([[0.02, 0.00], [0.00, 0.02]]),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.array([[0.10]]),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.array([[0.05]]),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([0.50, 0.50, 0.50, 0.50]),\n            \"horizon\": 15\n        },\n        # Test Case 2 (boundary condition):\n        {\n            \"A\": np.array([[1.00, 0.00], [0.00, 1.00]]),\n            \"B\": np.array([[0.00], [0.00]]),\n            \"E\": np.array([[0.00], [0.00]]),\n            \"z0_c\": np.array([0.00, 0.00]),\n            \"z0_G\": np.array([[0.50], [0.00]]),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.empty((1, 0)),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.empty((1, 0)),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([0.50, 0.50, 10.00, 10.00]),\n            \"horizon\": 1\n        },\n        # Test Case 3 (degenerate zonotope, violation):\n        {\n            \"A\": np.array([[1.00, 0.00], [0.00, 1.00]]),\n            \"B\": np.array([[0.00], [0.00]]),\n            \"E\": np.array([[0.00], [0.00]]),\n            \"z0_c\": np.array([1.20, 0.00]),\n            \"z0_G\": np.empty((2, 0)),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.empty((1, 0)),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.empty((1, 0)),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([1.00, 1.00, 1.00, 1.00]),\n            \"horizon\": 5\n        },\n        # Test Case 4 (attack-dominated violation):\n        {\n            \"A\": np.array([[0.98, 0.05], [0.00, 0.97]]),\n            \"B\": np.array([[0.00], [0.00]]),\n            \"E\": np.array([[0.20], [0.10]]),\n            \"z0_c\": np.array([0.00, 0.00]),\n            \"z0_G\": np.array([[0.01, 0.00], [0.00, 0.01]]),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.empty((1, 0)),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.array([[0.20]]),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([0.30, 0.30, 0.30, 0.30]),\n            \"horizon\": 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_verification(\n            case[\"A\"], case[\"B\"], case[\"E\"],\n            case[\"z0_c\"], case[\"z0_G\"],\n            case[\"u_c\"], case[\"u_G\"],\n            case[\"a_c\"], case[\"a_G\"],\n            case[\"H_safe\"], case[\"b_safe\"],\n            case[\"horizon\"]\n        )\n        results.append(result)\n    \n    # Final print statement in the exact required format.\n    # The output is directly computed and printed.\n    # For Test Case 1: True\n    # For Test Case 2: True\n    # For Test Case 3: False\n    # For Test Case 4: False\n    # Final result: [True,True,False,False]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# The solve function is not called here to avoid printing during XML generation.\n# The `answer` tag below contains the pre-computed result of running this code.\n```",
            "answer": "[True,True,False,False]"
        }
    ]
}