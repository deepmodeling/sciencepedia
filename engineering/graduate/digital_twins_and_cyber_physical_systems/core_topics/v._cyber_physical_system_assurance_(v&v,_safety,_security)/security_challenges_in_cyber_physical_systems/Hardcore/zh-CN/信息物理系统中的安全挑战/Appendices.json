{
    "hands_on_practices": [
        {
            "introduction": "在网络物理系统中，攻击者成功的关键往往在于其行动的隐蔽性。许多检测系统依赖于测量残差来识别异常，因此，理解攻击如何能绕过这些检测器至关重要。该练习将指导你从第一性原理出发，推导出一个虚假数据注入攻击能够保持“不可观测”或“隐形”的根本代数条件，这是设计更强大检测系统的基础 。",
            "id": "4244500",
            "problem": "在信息物理系统（CPS）的线性化监控层中，数字孪生使用由 $y = Hx + e$ 给出的静态测量模型 $y \\in \\mathbb{R}^{m}$，其中 $x \\in \\mathbb{R}^{n}$ 是系统状态，$H \\in \\mathbb{R}^{m \\times n}$ 是测量矩阵，$e \\in \\mathbb{R}^{m}$ 是测量噪声。基于残差的坏数据检测器计算残差 $r = y - H\\hat{x}$，其中状态估计 $\\hat{x}$ 是通过最小二乘估计器 $\\hat{x} \\in \\arg\\min_{z \\in \\mathbb{R}^{n}} \\|y - Hz\\|_{2}$ 得到的。攻击者注入一个虚假数据向量 $a \\in \\mathbb{R}^{m}$，使得测量向量变为 $y' = y + a$。如果攻击下的残差等于标称残差，即 $r' = r$，则称该攻击是不可观测的，其中 $r' = y' - H\\hat{x}'$，并且 $\\hat{x}'$ 是从 $y'$ 得到的最小二乘估计。\n\n仅从欧几里得空间中的最小二乘投影和残差的定义出发，推导所有不可观测攻击的代数表征。将最终结果表示为一个仅用 $H$ 和一个自由参数表示的通用不可观测攻击向量的闭式表达式。你的最终答案必须是一个单一的闭式表达式，并且不包含任何文字。",
            "solution": "该问题要求推导所有不可观测攻击向量 $a$ 的代数表征。如果测量残差在注入虚假数据后保持不变，则该攻击被定义为不可观测的。\n\n让我们从给定的定义开始。标称测量模型为 $y = Hx + e$，其中 $y \\in \\mathbb{R}^{m}$，$x \\in \\mathbb{R}^{n}$，$H \\in \\mathbb{R}^{m \\times n}$，$e \\in \\mathbb{R}^{m}$。状态估计 $\\hat{x}$ 通过最小二乘法获得：\n$$ \\hat{x} \\in \\arg\\min_{z \\in \\mathbb{R}^{n}} \\|y - Hz\\|_{2} $$\n这个最小化问题有一个独特的几何解释。向量 $H\\hat{x}$ 是测量向量 $y$ 在矩阵 $H$ 的列空间（我们记作 $\\text{Im}(H)$）上的正交投影。设 $P_{H}$ 是将 $\\mathbb{R}^{m}$ 中的向量投影到子空间 $\\text{Im}(H)$ 上的正交投影矩阵。那么，我们可以写成：\n$$ H\\hat{x} = P_{H}y $$\n标称残差向量 $r$ 定义为 $r = y - H\\hat{x}$。代入 $H\\hat{x}$ 的表达式，我们得到：\n$$ r = y - P_{H}y = (I - P_{H})y $$\n这里，$I$ 是 $m \\times m$ 的单位矩阵。矩阵 $I - P_{H}$ 本身也是一个投影矩阵。它将向量投影到 $\\text{Im}(H)$ 的正交补上，也就是 $H$ 的转置的零空间，记作 $\\mathcal{N}(H^T)$。\n\n现在，我们考虑受攻击的系统。攻击者注入一个虚假数据向量 $a \\in \\mathbb{R}^{m}$，得到一个新的测量向量 $y' = y + a$。攻击下的最小二乘估计 $\\hat{x}'$ 是通过最小化 $\\|y' - Hz\\|_{2}$ 找到的：\n$$ \\hat{x}' \\in \\arg\\min_{z \\in \\mathbb{R}^{n}} \\|y' - Hz\\|_{2} $$\n与标称情况类似，得到的向量 $H\\hat{x}'$ 是受攻击的测量向量 $y'$ 在 $H$ 的列空间上的正交投影：\n$$ H\\hat{x}' = P_{H}y' $$\n那么，攻击下的残差 $r'$ 是：\n$$ r' = y' - H\\hat{x}' = y' - P_{H}y' = (I - P_{H})y' $$\n如果残差不发生变化，即 $r' = r$，则攻击被定义为不可观测的。我们使用推导出的残差表达式来施加这个条件：\n$$ (I - P_{H})y' = (I - P_{H})y $$\n将 $y' = y + a$ 代入这个方程：\n$$ (I - P_{H})(y + a) = (I - P_{H})y $$\n根据矩阵-向量乘法的线性性质，我们可以展开方程的左边：\n$$ (I - P_{H})y + (I - P_{H})a = (I - P_{H})y $$\n从两边减去项 $(I - P_{H})y$，我们得到一个仅关于攻击向量 $a$ 的条件：\n$$ (I - P_{H})a = 0 $$\n这个方程意味着攻击向量 $a$ 在子空间 $\\mathcal{N}(H^T)$ 上的投影是零向量。这仅当向量 $a$ 与 $\\mathcal{N}(H^T)$ 中的每个向量都正交时才成立。所有与 $\\mathcal{N}(H^T)$ 正交的向量的集合正是其正交补 $(\\mathcal{N}(H^T))^{\\perp}$。根据线性代数基本定理，$H^T$ 的零空间的正交补是 $H$ 的列空间（像）。因此，该条件等价于：\n$$ a \\in \\text{Im}(H) $$\n这意味着，要使攻击不可观测，攻击向量 $a$ 必须位于测量矩阵 $H$ 的列空间中。$H$ 的列空间中的任何向量都可以表示为 $H$ 的列的线性组合。这可以写成一种紧凑形式，即必须存在一个向量 $c \\in \\mathbb{R}^n$ 使得：\n$$ a = Hc $$\n向量 $c$ 是一个定义特定不可观测攻击的自由参数向量。这个表达式提供了所有不可观测攻击向量的完整代数表征。",
            "answer": "$$ \\boxed{Hc} $$"
        },
        {
            "introduction": "网络攻击对物理世界的影响是网络物理系统安全的核心议题。本练习以电网保护系统为背景，模拟了一次针对GPS授时信号的攻击，该攻击会导致相量测量单元（PMU）产生时间偏差。通过此练习，你将亲手计算这种微小的网络时间误差如何被放大为错误的物理决策变量，从而定量理解网络安全漏洞如何直接转化为物理风险 。",
            "id": "4244553",
            "problem": "一个信息物理电力系统中的输电线路使用一种线路电流差动保护方案，该方案通过在A和B两个终端进行时间同步的相量测量来实现。每个终端都装有一个相量测量单元（PMU, Phasor Measurement Unit），该单元通过对均匀采样的数据进行计算，得出基频电流相量，其计算方法是使用标称频率下的单周期离散傅里叶变换（DFT, Discrete Fourier Transform）。在一个 $f_{0} = 60\\,\\text{Hz}$ 的系统中，采样率为 $f_{s} = 4800\\,\\text{Hz}$，因此每个标称周期使用 $N = 80$ 个样本。继电器计算差动电流决策变量，其值为幅值 $I_{\\text{diff}} = \\left| \\hat{I}_{A} + \\hat{I}_{B} \\right|$，其中 $\\hat{I}_{A}$ 和 $\\hat{I}_{B}$ 分别是A和B终端的复数相量估计值。在安全运行且为穿越性负荷（无内部故障）的情况下，真实的同步相量满足 $\\hat{I}_{B}^{\\text{true}} = -\\hat{I}_{A}^{\\text{true}}$，因为当参考一致的符号约定时，两终端的电流大小相等、方向相反。\n\n一个攻击者成功地仅在B终端引入了 $\\Delta t = 50\\,\\mu\\text{s}$ 的全球定位系统（GPS, Global Positioning System）时间偏移，导致B终端的PMU在计算其DFT相量时，所使用的参考时间相对于A终端发生了偏移。假设理想的抗混叠、无测量噪声、使用矩形单周期窗口，并且基频输入是在标称频率 $f_{0}$ 下的完美正弦波。每个终端的穿越电流幅值为 $1.2$ 标幺值，其基准值为 $I_{\\text{base}} = 2\\,\\text{kA}$，标幺值是在此基准上定义的。\n\n仅从均匀采样、基频下的 $N$ 点DFT以及傅里叶分析中连续时间偏移与复指数之间的关系等基本定义出发，推导仅由B终端时间偏移引起的虚假差动电流幅值 $I_{\\text{diff}}$ 的闭式表达式，并计算最小标幺值启动阈值 $T_{\\min}$，以确保继电器决策规则 $I_{\\text{diff}} > T$ 在所述穿越性负荷下不会发生误动。用标幺值表示 $T_{\\min}$，并将您的答案四舍五入至四位有效数字。",
            "solution": "该问题要求我们推导因两个测量终端之一的时间同步误差而产生的虚假差动电流幅值 $I_{\\text{diff}}$，然后确定防止误操作的最小继电器整定值。\n\n设 $\\hat{I}_{A}^{\\text{true}}$ 和 $\\hat{I}_{B}^{\\text{true}}$ 分别为在穿越性负荷条件下A终端和B终端电流的真实复数相量。差动保护的一致性符号约定规定，流入被保护区域的电流为正。对于穿越性负荷，在A终端流入的电流等于在B终端流出的电流。因此，它们的真实相量大小相等，方向相反：\n$$ \\hat{I}_{B}^{\\text{true}} = -\\hat{I}_{A}^{\\text{true}} $$\n每个终端的电流幅值给定为 $I_{\\text{mag}} = 1.2\\,\\text{p.u.}$。因此，我们有：\n$$ |\\hat{I}_{A}^{\\text{true}}| = |\\hat{I}_{B}^{\\text{true}}| = I_{\\text{mag}} = 1.2\\,\\text{p.u.} $$\n假设A终端的PMU具有完美的时间参考。因此，其测量的相量 $\\hat{I}_{A}$ 等于真实相量：\n$$ \\hat{I}_{A} = \\hat{I}_{A}^{\\text{true}} $$\nB终端的PMU受到 $\\Delta t = 50\\,\\mu\\text{s}$ 的时间偏移影响。这意味着其本地时钟相对于真实系统时间延迟了 $\\Delta t$。如果真实系统时间是 $t$，B终端的PMU认为时间是 $t' = t - \\Delta t$。因此，当它在其认为的一个周期窗口内执行DFT计算时，它实际上处理的是时间区间 $[t, t+T_0]$ 内的信号，而不是正确的区间 $[t', t'+T_0] = [t-\\Delta t, t-\\Delta t+T_0]$。这等效于分析信号的时间提前版本 $i_B(t'+\\Delta t)$。\n\n傅里叶变换的一个基本性质是，时域中的时间位移对应于频域中的相移。对于一个信号 $x(t)$，其傅里叶变换为 $X(\\omega)$，则时移信号 $x(t - t_0)$ 的变换是 $X(\\omega)e^{-j\\omega t_0}$。反之，时间提前信号 $x(t+t_0)$ 的变换是 $X(\\omega)e^{j\\omega t_0}$。\n\nB终端的PMU实际上测量的是信号 $i_B(t'+\\Delta t)$ 的相量。因此，测量的相量 $\\hat{I}_B$ 是真实相量 $\\hat{I}_B^{\\text{true}}$ 乘以一个对应于在基波角频率 $\\omega_0 = 2\\pi f_0$ 下时间提前 $\\Delta t$ 的复指数：\n$$ \\hat{I}_{B} = \\hat{I}_{B}^{\\text{true}} e^{j\\omega_0 \\Delta t} = \\hat{I}_{B}^{\\text{true}} e^{j2\\pi f_0 \\Delta t} $$\n现在，我们可以使用测量的相量计算差动电流决策变量 $I_{\\text{diff}}$：\n$$ I_{\\text{diff}} = |\\hat{I}_{A} + \\hat{I}_{B}| $$\n代入测量相量的表达式：\n$$ I_{\\text{diff}} = |\\hat{I}_{A}^{\\text{true}} + \\hat{I}_{B}^{\\text{true}} e^{j2\\pi f_0 \\Delta t}| $$\n使用穿越性负荷条件 $\\hat{I}_{B}^{\\text{true}} = -\\hat{I}_{A}^{\\text{true}}$：\n$$ I_{\\text{diff}} = |\\hat{I}_{A}^{\\text{true}} - \\hat{I}_{A}^{\\text{true}} e^{j2\\pi f_0 \\Delta t}| $$\n提出因子 $\\hat{I}_{A}^{\\text{true}}$：\n$$ I_{\\text{diff}} = |\\hat{I}_{A}^{\\text{true}}(1 - e^{j2\\pi f_0 \\Delta t})| = |\\hat{I}_{A}^{\\text{true}}| |1 - e^{j2\\pi f_0 \\Delta t}| $$\n令 $\\theta = 2\\pi f_0 \\Delta t$。表达式变为：\n$$ I_{\\text{diff}} = I_{\\text{mag}} |1 - e^{j\\theta}| $$\n为了计算幅值 $|1 - e^{j\\theta}|$，我们使用欧拉公式 $e^{j\\theta} = \\cos(\\theta) + j\\sin(\\theta)$：\n$$ |1 - e^{j\\theta}| = |1 - (\\cos(\\theta) + j\\sin(\\theta))| = |(1 - \\cos(\\theta)) - j\\sin(\\theta)| $$\n复数 $x+jy$ 的幅值为 $\\sqrt{x^2+y^2}$：\n$$ |1 - e^{j\\theta}| = \\sqrt{(1-\\cos(\\theta))^2 + (-\\sin(\\theta))^2} = \\sqrt{1 - 2\\cos(\\theta) + \\cos^2(\\theta) + \\sin^2(\\theta)} $$\n使用恒等式 $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$：\n$$ |1 - e^{j\\theta}| = \\sqrt{1 - 2\\cos(\\theta) + 1} = \\sqrt{2(1 - \\cos(\\theta))} $$\n使用半角三角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$ |1 - e^{j\\theta}| = \\sqrt{2(2\\sin^2\\left(\\frac{\\theta}{2}\\right))} = \\sqrt{4\\sin^2\\left(\\frac{\\theta}{2}\\right)} = \\left|2\\sin\\left(\\frac{\\theta}{2}\\right)\\right| $$\n将此结果代回 $I_{\\text{diff}}$ 的表达式中：\n$$ I_{\\text{diff}} = I_{\\text{mag}} \\left|2\\sin\\left(\\frac{2\\pi f_0 \\Delta t}{2}\\right)\\right| = 2I_{\\text{mag}} |\\sin(\\pi f_0 \\Delta t)| $$\n由于 $f_0 = 60\\,\\text{Hz}$ 和 $\\Delta t = 50 \\times 10^{-6}\\,\\text{s}$ 均为正数，参数 $\\pi f_0 \\Delta t$ 是一个小的正角，其正弦值为正。因此，绝对值是多余的。虚假差动电流的最终闭式表达式为：\n$$ I_{\\text{diff}} = 2 I_{\\text{mag}} \\sin(\\pi f_0 \\Delta t) $$\n这就完成了任务的第一部分。\n\n对于第二部分，我们必须找到防止误动的最小启动阈值 $T_{\\min}$。继电器的动作条件是 $I_{\\text{diff}} > T$。为了在此条件下保持安全（不动作），阈值 $T$ 必须设置得大于或等于计算出的 $I_{\\text{diff}}$。因此，该阈值的最小值等于我们刚刚推导出的 $I_{\\text{diff}}$ 的值。\n$$ T_{\\min} = I_{\\text{diff}} = 2 I_{\\text{mag}} \\sin(\\pi f_0 \\Delta t) $$\n我们代入给定的数值：$I_{\\text{mag}} = 1.2\\,\\text{p.u.}$，$f_0 = 60\\,\\text{Hz}$，以及 $\\Delta t = 50 \\times 10^{-6}\\,\\text{s}$。\n$$ T_{\\min} = 2(1.2) \\sin(\\pi \\cdot 60 \\cdot 50 \\times 10^{-6}) $$\n$$ T_{\\min} = 2.4 \\sin(3000 \\pi \\times 10^{-6}) $$\n$$ T_{\\min} = 2.4 \\sin(0.003\\pi) $$\n正弦函数的参数以弧度为单位。现在我们计算数值：\n$$ 0.003\\pi \\approx 0.009424778\\,\\text{rad} $$\n$$ T_{\\min} = 2.4 \\times \\sin(0.009424778) \\approx 2.4 \\times 0.009424433 $$\n$$ T_{\\min} \\approx 0.02261864\\,\\text{p.u.} $$\n问题要求答案四舍五入到四位有效数字。\n$$ T_{\\min} \\approx 0.02262\\,\\text{p.u.} $$\n这是为确保继电器不会因指定的 $50\\,\\mu\\text{s}$ 时间同步误差而误动所需的最小标幺值启动阈值。",
            "answer": "$$ \\boxed{0.02262} $$"
        },
        {
            "introduction": "面对无穷多种可能的攻击向量，逐一分析是不现实的，我们需要能够提供形式化安全保证的工具。可达性分析是一种强大的技术，它能够计算出在所有可能的不确定性（包括攻击）下，系统状态可能到达的整个集合。本练习要求你通过编程实现一种基于“区域超胞”（zonotope）的可达性分析算法，以验证系统在有界攻击下是否始终保持在安全区域内，这代表了从被动防御到主动验证的范式转变 。",
            "id": "4244543",
            "problem": "考虑一个离散时间线性时不变 (LTI) 网络物理系统 (CPS)，其系统状态演化遵循 $x_{k+1} = A x_k + B u_k + E a_k$。其中，$x_k \\in \\mathbb{R}^n$ 是在步骤 $k$ 的状态，$u_k \\in \\mathbb{R}^p$ 是有界控制输入，$a_k \\in \\mathbb{R}^q$ 是有界攻击输入。一个数字孪生的任务是在这些有界输入下过近似状态的可达集，并验证安全属性是否对有限时间域内所有可达状态都成立。\n\n使用称为带状体 (zonotope) 的集合表示法。一个带状体 $Z$ 由一个中心 $c \\in \\mathbb{R}^n$ 和生成元矩阵 $G \\in \\mathbb{R}^{n \\times m}$ 定义，表示集合 $Z = \\{ c + G \\xi \\mid \\xi \\in \\mathbb{R}^m, \\|\\xi\\|_{\\infty} \\le 1 \\}$。两个带状体 $Z_1 = (c_1, G_1)$ 和 $Z_2 = (c_2, G_2)$ 的闵可夫斯基和 (Minkowski sum) 是带状体 $(c_1 + c_2, [G_1 \\; G_2])$，而一个带状体 $Z = (c,G)$ 在矩阵 $M$ 下的线性映射是带状体 $(M c, M G)$。使用这两种运算，在分别表示为带状体 $U = (c_u, G_u)$ 和 $A_{\\text{atk}} = (c_a, G_a)$ 的有界控制和攻击输入下，步骤 $k+1$ 的可达带状体通过\n$$\nZ_{k+1} = A Z_k \\oplus B U \\oplus E A_{\\text{atk}},\n$$\n计算得出，从初始带状体 $Z_0 = (c_0, G_0)$ 开始。\n\n安全属性由一个凸多胞体 $S = \\{ x \\in \\mathbb{R}^n \\mid H x \\le b \\}$ 指定，其中 $H \\in \\mathbb{R}^{r \\times n}$ 且 $b \\in \\mathbb{R}^r$。对于 $H$ 的每个不等式行向量 $h_i^\\top$ 和界限 $b_i$，当且仅当\n$$\nh_i^\\top c + \\sum_{j=1}^m |h_i^\\top g_j| \\le b_i,\n$$\n时，带状体 $Z = (c,G)$ 对所有 $x \\in Z$ 满足 $h_i^\\top x \\le b_i$，其中 $g_j$ 表示 $G$ 的第 $j$ 个生成元列。因此，验证 $Z \\subseteq S$ 可简化为对所有行 $i \\in \\{1,\\dots,r\\}$ 检查上述不等式。\n\n您的任务是实现一个程序，该程序：\n- 使用上述带状体运算的递归，为有限时间域 $T_{hor}$ 过近似可达带状体 $\\{Z_k\\}_{k=0}^{T_{hor}}$。\n- 验证对于每个可达带状体 $Z_k$（其中 $k \\in \\{0,1,\\dots,T_{hor}\\}$），安全属性是否成立。\n\n将多个测试用例的最终结果表示为布尔值，每个布尔值指示该属性在指定时间域的所有步骤中是否成立。程序必须生成单行输出，其中包含一个由方括号括起来的、逗号分隔的布尔值列表，例如，`[True, False]`。\n\n本问题不涉及物理单位。所有角度（若有）必须以弧度为单位（尽管此处未使用）。不使用百分比。\n\n使用以下参数值测试套件，该套件共同测试了一个通用情况、一个边界条件、一个无生成元的退化情况以及一个攻击主导的违规情况：\n\n测试用例 1 (通用的“理想路径”)：\n- $A = \\begin{bmatrix} 0.92  0.08 \\\\ 0.00  0.96 \\end{bmatrix}$，$B = \\begin{bmatrix} 0.10 \\\\ 0.05 \\end{bmatrix}$，$E = \\begin{bmatrix} 0.05 \\\\ 0.02 \\end{bmatrix}$。\n- $Z_0$：$c_0 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$，$G_0 = \\begin{bmatrix} 0.02  0.00 \\\\ 0.00  0.02 \\end{bmatrix}$。\n- 控制带状体 $U$：$c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_u = \\begin{bmatrix} 0.10 \\end{bmatrix}$。\n- 攻击带状体 $A_{\\text{atk}}$：$c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_a = \\begin{bmatrix} 0.05 \\end{bmatrix}$。\n- 安全多胞体 $S$ 是轴对齐的盒子，其 $H = \\begin{bmatrix} 1  0 \\\\ -1  0 \\\\ 0  1 \\\\ 0  -1 \\end{bmatrix}$ 和 $b = \\begin{bmatrix} 0.50 \\\\ 0.50 \\\\ 0.50 \\\\ 0.50 \\end{bmatrix}$。\n- 时间域 $T_{hor} = 15$ (整数步数)。\n\n测试用例 2 (边界条件)：\n- $A = \\begin{bmatrix} 1.00  0.00 \\\\ 0.00  1.00 \\end{bmatrix}$，$B = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$，$E = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$。\n- $Z_0$：$c_0 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$，$G_0 = \\begin{bmatrix} 0.50 \\\\ 0.00 \\end{bmatrix}$ (单个生成元列)。\n- 控制带状体 $U$：$c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_u$ 是 $\\mathbb{R}^{1 \\times 0}$ 中的空矩阵。\n- 攻击带状体 $A_{\\text{atk}}$：$c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_a$ 是 $\\mathbb{R}^{1 \\times 0}$ 中的空矩阵。\n- 安全多胞体 $S$，其 $H = \\begin{bmatrix} 1  0 \\\\ -1  0 \\\\ 0  1 \\\\ 0  -1 \\end{bmatrix}$ 和 $b = \\begin{bmatrix} 0.50 \\\\ 0.50 \\\\ 10.00 \\\\ 10.00 \\end{bmatrix}$。\n- 时间域 $T_{hor} = 1$。\n\n测试用例 3 (退化带状体，违规)：\n- $A = \\begin{bmatrix} 1.00  0.00 \\\\ 0.00  1.00 \\end{bmatrix}$，$B = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$，$E = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$。\n- $Z_0$：$c_0 = \\begin{bmatrix} 1.20 \\\\ 0.00 \\end{bmatrix}$，$G_0$ 是 $\\mathbb{R}^{2 \\times 0}$ 中的空矩阵。\n- 控制带状体 $U$：$c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_u$ 是 $\\mathbb{R}^{1 \\times 0}$ 中的空矩阵。\n- 攻击带状体 $A_{\\text{atk}}$：$c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_a$ 是 $\\mathbb{R}^{1 \\times 0}$ 中的空矩阵。\n- 安全多胞体 $S$，其 $H = \\begin{bmatrix} 1  0 \\\\ -1  0 \\\\ 0  1 \\\\ 0  -1 \\end{bmatrix}$ 和 $b = \\begin{bmatrix} 1.00 \\\\ 1.00 \\\\ 1.00 \\\\ 1.00 \\end{bmatrix}$。\n- 时间域 $T_{hor} = 5$。\n\n测试用例 4 (攻击主导的违规)：\n- $A = \\begin{bmatrix} 0.98  0.05 \\\\ 0.00  0.97 \\end{bmatrix}$，$B = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$，$E = \\begin{bmatrix} 0.20 \\\\ 0.10 \\end{bmatrix}$。\n- $Z_0$：$c_0 = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$，$G_0 = \\begin{bmatrix} 0.01  0.00 \\\\ 0.00  0.01 \\end{bmatrix}$。\n- 控制带状体 $U$：$c_u = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_u$ 是 $\\mathbb{R}^{1 \\times 0}$ 中的空矩阵。\n- 攻击带状体 $A_{\\text{atk}}$：$c_a = \\begin{bmatrix} 0.00 \\end{bmatrix}$，$G_a = \\begin{bmatrix} 0.20 \\end{bmatrix}$。\n- 安全多胞体 $S$，其 $H = \\begin{bmatrix} 1  0 \\\\ -1  0 \\\\ 0  1 \\\\ 0  -1 \\end{bmatrix}$ 和 $b = \\begin{bmatrix} 0.30 \\\\ 0.30 \\\\ 0.30 \\\\ 0.30 \\end{bmatrix}$。\n- 时间域 $T_{hor} = 10$。\n\n您的程序应生成单行输出，其中包含一个方括号括起来的、逗号分隔的结果列表（例如，`[True, False, True, False]`），按顺序对应测试用例 1 到 4。",
            "solution": "该问题要求在有限时间域内验证一个离散时间线性时不变 (LTI) 网络物理系统的安全属性。系统动力学由状态空间方程 $x_{k+1} = A x_k + B u_k + E a_k$ 给出，其中 $x_k \\in \\mathbb{R}^n$ 是状态向量，$u_k \\in \\mathbb{R}^p$ 是控制输入，$a_k \\in \\mathbb{R}^q$ 是步骤 $k$ 的攻击输入。分析将使用基于带状体的可达性分析方法进行，该方法提供所有可能状态的一个过近似集合。\n\n一个带状体 $Z$ 是由一个中心 $c \\in \\mathbb{R}^n$ 和一个生成元矩阵 $G \\in \\mathbb{R}^{n \\times m}$ 定义的集合，使得 $Z = \\{ c + G \\xi \\mid \\xi \\in \\mathbb{R}^m, \\|\\xi\\|_{\\infty} \\le 1 \\}$。可达性计算的核心依赖于对带状体的两个基本运算：\n1.  **线性变换**：一个带状体 $Z = (c, G)$ 在由矩阵 $M$ 表示的线性映射下的像是另一个带状体 $M Z = (M c, M G)$。\n2.  **闵可夫斯基和**：两个带状体 $Z_1 = (c_1, G_1)$ 和 $Z_2 = (c_2, G_2)$ 的闵可夫斯基和是带状体 $Z_1 \\oplus Z_2 = (c_1 + c_2, [G_1 \\; G_2])$，其中 $[G_1 \\; G_2]$ 是生成元矩阵的水平拼接。\n\n在步骤 $k+1$ 的可达状态集，表示为带状体 $Z_{k+1}$，是根据步骤 $k$ 的带状体 $Z_k$ 以及分别代表有界控制和攻击输入的带状体 $U = (c_u, G_u)$ 和 $A_{\\text{atk}} = (c_a, G_a)$ 计算得出的。传播规则是：\n$$Z_{k+1} = A Z_k \\oplus B U \\oplus E A_{\\text{atk}}$$\n通过应用线性变换和闵可夫斯基和的定义，我们推导出带状体 $Z_{k+1}$ 的中心 $c_{k+1}$ 和生成元矩阵 $G_{k+1}$ 的递归公式：\n$$c_{k+1} = A c_k + B c_u + E c_a$$\n$$G_{k+1} = [A G_k \\quad B G_u \\quad E G_a]$$\n\n安全属性由一个凸多胞体 $S = \\{ x \\in \\mathbb{R}^n \\mid H x \\le b \\}$ 指定，其中 $H \\in \\mathbb{R}^{r \\times n}$ 且 $b \\in \\mathbb{R}^r$。一个带状体 $Z_k = (c_k, G_k)$ 被包含在 $S$ 内，当且仅当对于 $H$ 的每一行 $h_i^\\top$ 及其对应的界限 $b_i$，以下不等式成立：\n$$h_i^\\top c_k + \\sum_{j=1}^m |h_i^\\top g_j| \\le b_i$$\n其中 $g_j$ 是 $G_k$ 的列。求和项 $\\sum_{j=1}^m |h_i^\\top g_j|$ 等价于行向量 $h_i^\\top G_k$ 的 L1 范数，我们可以写作 $\\|h_i^\\top G_k\\|_1$。\n\n解决每个测试用例的算法如下：\n1.  初始化一个布尔标志 `is_safe_for_horizon` 为 `True`。\n2.  将初始带状体 $(c_k, G_k)$ 设置为给定的 $(c_0, G_0)$。\n3.  对每个时间步 $k$（从 $0$ 到指定的时间域 $T_{hor}$）进行迭代。\n4.  在每个步骤 $k$，验证当前带状体 $Z_k = (c_k, G_k)$ 是否满足安全属性。这包括检查不等式 $h_i^\\top c_k + \\|h_i^\\top G_k\\|_1 \\le b_i$ 是否对矩阵 $H$ 的所有行 $i=1, \\dots, r$ 都成立。\n5.  如果任何这些不等式被违反，则系统是不安全的。将 `is_safe_for_horizon` 设置为 `False` 并中断当前测试用例的循环。\n6.  如果安全检查通过且 $k  T_{hor}$，则使用传播公式计算下一个可达带状体 $Z_{k+1} = (c_{k+1}, G_{k+1})$。将 $(c_k, G_k)$ 更新为 $(c_{k+1}, G_{k+1})$ 以进行下一次迭代。\n7.  循环完成后，`is_safe_for_horizon` 的值即为该测试用例的结果。\n\n此过程被实现并应用于所提供的四个测试用例。该实现使用 `numpy` 库进行高效的矩阵和向量计算。它能正确处理具有空生成元矩阵的带状体，这些带状体代表单个点；对于此类带状体，项 $\\|h_i^\\top G_k\\|_1$ 正确地计算为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_verification(A, B, E, z0_c, z0_G, u_c, u_G, a_c, a_G, H_safe, b_safe, horizon):\n    \"\"\"\n    Performs reachability analysis and safety verification for a single test case.\n\n    Args:\n        A, B, E (np.ndarray): System matrices.\n        z0_c, z0_G (np.ndarray): Center and generators of the initial zonotope Z0.\n        u_c, u_G (np.ndarray): Center and generators of the control zonotope U.\n        a_c, a_G (np.ndarray): Center and generators of the attack zonotope A_atk.\n        H_safe (np.ndarray): Matrix defining the safety polytope S.\n        b_safe (np.ndarray): Vector defining the safety polytope S.\n        horizon (int): The finite time horizon for verification.\n\n    Returns:\n        bool: True if the system is safe for all steps up to the horizon, False otherwise.\n    \"\"\"\n    c_k = z0_c\n    G_k = z0_G\n    \n    for k in range(horizon + 1):\n        # Step 1: Safety Verification for Z_k = (c_k, G_k)\n        for i in range(H_safe.shape[0]):\n            h_i = H_safe[i, :]\n            b_i = b_safe[i]\n            \n            # The sum term is the L1 norm of the row vector h_i^T * G_k\n            # np.sum(np.abs(...)) is numerically robust for vectors.\n            l1_norm_term = np.sum(np.abs(h_i @ G_k))\n            \n            check_value = h_i @ c_k + l1_norm_term\n            \n            # Using a small tolerance for floating point comparisons\n            if check_value > b_i + 1e-9:\n                return False # Safety violated\n\n        # Step 2: Propagation to Z_{k+1}, if not the last step\n        if k  horizon:\n            c_k_plus_1 = A @ c_k + B @ u_c + E @ a_c\n            \n            G_k_plus_1_parts = []\n            if G_k.shape[1] > 0:\n                G_k_plus_1_parts.append(A @ G_k)\n            if u_G.shape[1] > 0:\n                G_k_plus_1_parts.append(B @ u_G)\n            if a_G.shape[1] > 0:\n                G_k_plus_1_parts.append(E @ a_G)\n            \n            if G_k_plus_1_parts:\n                G_k_plus_1 = np.hstack(G_k_plus_1_parts)\n            else: # If all generator matrices are empty\n                G_k_plus_1 = np.empty((A.shape[0], 0))\n\n            c_k = c_k_plus_1\n            G_k = G_k_plus_1\n            \n    return True # Safe for the entire horizon\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for CPS safety verification.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (general \"happy path\"):\n        {\n            \"A\": np.array([[0.92, 0.08], [0.00, 0.96]]),\n            \"B\": np.array([[0.10], [0.05]]),\n            \"E\": np.array([[0.05], [0.02]]),\n            \"z0_c\": np.array([0.00, 0.00]),\n            \"z0_G\": np.array([[0.02, 0.00], [0.00, 0.02]]),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.array([[0.10]]),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.array([[0.05]]),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([0.50, 0.50, 0.50, 0.50]),\n            \"horizon\": 15\n        },\n        # Test Case 2 (boundary condition):\n        {\n            \"A\": np.array([[1.00, 0.00], [0.00, 1.00]]),\n            \"B\": np.array([[0.00], [0.00]]),\n            \"E\": np.array([[0.00], [0.00]]),\n            \"z0_c\": np.array([0.00, 0.00]),\n            \"z0_G\": np.array([[0.50], [0.00]]),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.empty((1, 0)),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.empty((1, 0)),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([0.50, 0.50, 10.00, 10.00]),\n            \"horizon\": 1\n        },\n        # Test Case 3 (degenerate zonotope, violation):\n        {\n            \"A\": np.array([[1.00, 0.00], [0.00, 1.00]]),\n            \"B\": np.array([[0.00], [0.00]]),\n            \"E\": np.array([[0.00], [0.00]]),\n            \"z0_c\": np.array([1.20, 0.00]),\n            \"z0_G\": np.empty((2, 0)),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.empty((1, 0)),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.empty((1, 0)),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([1.00, 1.00, 1.00, 1.00]),\n            \"horizon\": 5\n        },\n        # Test Case 4 (attack-dominated violation):\n        {\n            \"A\": np.array([[0.98, 0.05], [0.00, 0.97]]),\n            \"B\": np.array([[0.00], [0.00]]),\n            \"E\": np.array([[0.20], [0.10]]),\n            \"z0_c\": np.array([0.00, 0.00]),\n            \"z0_G\": np.array([[0.01, 0.00], [0.00, 0.01]]),\n            \"u_c\": np.array([0.00]),\n            \"u_G\": np.empty((1, 0)),\n            \"a_c\": np.array([0.00]),\n            \"a_G\": np.array([[0.20]]),\n            \"H_safe\": np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]),\n            \"b_safe\": np.array([0.30, 0.30, 0.30, 0.30]),\n            \"horizon\": 10\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_verification(\n            case[\"A\"], case[\"B\"], case[\"E\"],\n            case[\"z0_c\"], case[\"z0_G\"],\n            case[\"u_c\"], case[\"u_G\"],\n            case[\"a_c\"], case[\"a_G\"],\n            case[\"H_safe\"], case[\"b_safe\"],\n            case[\"horizon\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}