## 引言
信息物理系统（CPS）通过计算、通信与物理过程的深度融合，正在重塑我们的世界，从[自动驾驶](@entry_id:270800)汽车到智能电网，其应用无处不在。然而，这种离散[计算逻辑](@entry_id:136251)与连续物理动态的紧密耦合，也带来了前所未有的安全与可靠性挑战。传统的软件或[硬件验证](@entry_id:1125922)方法难以应对这种混合特性，导致系统可能出现灾难性故障。因此，开发能够严格保证CPS正确性的形式化验证方法已成为一个至关重要的研究领域。本文旨在系统性地介绍这些先进的验证技术，为分析和保证安全关键系统的行为提供数学上的确定性。

为了全面掌握这一领域，本文将分三个层次展开。首先，“原理与机制”一章将深入形式化验证的理论核心，系统介绍用于建模CPS的混成自动机、用于规约属性的[时间逻辑](@entry_id:181558)，以及[可达性](@entry_id:271693)分析等核心验证算法。接着，“应用与交叉学科关联”一章将理论联系实际，展示这些方法在自动驾驶、[网络控制](@entry_id:275222)和实时系统等领域的具体应用，并探讨其在安全认证中的作用。最后，“动手实践”部分将通过具体问题引导读者应用所学，将抽象概念转化为解决实际工程挑战的能力。现在，让我们从支撑形式化验证的理论基础和核心技术机制开始。

## 原理与机制

继前一章对信息物理系统（CPS）及其验证挑战进行宏观介绍之后，本章将深入探讨支撑形式化验证的理论基础和核心技术机制。我们将首先建立用于描述 CPS 行为的数学模型，然后介绍用于精确表达系统规约的形式化语言，最后系统地阐述用于证明模型满足其规约的各类验证算法与技术。本章的目标是为读者提供一个严谨、系统且深入的知识框架，使其能够理解并应用这些先进的验证方法。

### 信息物理系统的形式化模型

对 CPS 进行形式化验证的第一步是构建一个精确的、无歧义的数学模型。这个模型必须能够捕捉到离散[计算逻辑](@entry_id:136251)与连续物理过程之间复杂的相互作用。

#### 混成自动机：一种规范模型

在众多模型中，**混成自动机**（Hybrid Automaton）已成为描述 CPS 的一种规范性框架。它将[有限自动机](@entry_id:1124972)（用于离散逻辑）与常微分方程（用于连续动态）结合在一起。一个混成自动机 $\mathcal{H}$ 通常由一组元组定义，这些元组精确地描述了系统的结构和行为 。这些核心组件包括：

*   **离散部分**：
    *   一组有限的**离散位置**（或称模式）$L$，代表系统的不同操作模式，例如“加热”、“待机”或“巡航”。
    *   一组**边** $E \subseteq L \times L$，表示从一个模式到另一个模式的瞬时切换。

*   **连续部分**：
    *   一个**[连续状态空间](@entry_id:276130)** $X \subseteq \mathbb{R}^n$，其中向量 $x \in X$ 捕捉了系统的物理状态，如温度、位置、速度等。系统的完整状态是一个偶对 $(\ell, x)$，其中 $\ell \in L$ 是当前模式，$x \in X$ 是当前连续状态。

*   **耦合机制**：
    *   **流动态**（Flow Dynamics）$F$：该映射为每个位置 $\ell \in L$ 指定一个连续动态，通常由常微分方程（ODE）或[微分](@entry_id:158422)包含（differential inclusion）给出，形如 $\dot{x} = f(x)$ 或 $\dot{x} \in F(\ell)(x)$。这描述了当系统处于模式 $\ell$ 时，其物理状态如何随时间演化。
    *   **位置不变量**（Location Invariants）$I$：该映射为每个位置 $\ell \in L$ 分配一个不变集 $I(\ell) \subseteq X$。系统在模式 $\ell$ 中演化时，其连续状态 $x$ 必须始终保持在 $I(\ell)$ 内部。如果状态演化到不变集的边界，系统必须进行一次离散跳转，否则执行将受阻。
    *   **守卫**（Guards）$G$：该映射为每条边 $e \in E$ 分配一个守卫集 $G(e) \subseteq X$。从模式 $\ell$ 到 $\ell'$ 的跳转仅当系统当前连续状态 $x$ 满足 $G(e)$ 时才被允许（即 $x \in G(e)$）。
    *   **重置**（Resets）$R$：该映射为每条边 $e \in E$ 分配一个重置关系 $R(e) \subseteq X \times X$。当发生跳转时，连续状态会从跳转前的状态 $x$ 瞬时更新为跳转后的状态 $x'$，其中 $(x, x')$ 必须满足重置关系 $R(e)$。例如，一个简单的重置可能是将某个变量（如积分器）重置为零。

这套组件共同定义了系统的完整语义。系统行为由两种基本动作交错构成：沿着由流动态定义的轨迹进行的**连续演化**（flow），和满足守卫并应用重置的**离散跳转**（jump）。[安全验证](@entry_id:1131179)的核心任务之一，即所谓的**[可达性](@entry_id:271693)分析**，就是通过交替计算这两种动作，来构造系统所有可能达到的状态集合，并检查该集合是否与预定义的[不安全状态](@entry_id:756344)集相交。

#### 执行的语义：流、跳转与谷上行为

一个混成系统的**执行**（Execution）可以被形式化地描述为一个关于时间演化的状态序列。一个典型的无限执行由一系列切换时间点 $0 = t_0 \le t_1 \le t_2 \le \dots$ 和一个分段定义的轨迹组成 。在每个时间区间 $[t_i, t_{i+1})$ 内，系统处于某个模式 $\ell_i$，其连续状态 $x(t)$ 遵循该模式的流动态演化，并且始终满足位置不变量 $x(t) \in I(\ell_i)$。在每个切换时刻 $t_{i+1}$，系统发生一次离散跳转，从模式 $\ell_i$ 切换到 $\ell_{i+1}$，其状态必须满足相应的守卫和重置条件。

在分析混成系统时，一个关键的语义问题是**谷上行为**（Zeno Behavior）。一个无限执行如果其切换时间[序列收敛](@entry_id:143579)到一个有限的极限 $T = \lim_{i \to \infty} t_i  +\infty$，则称其为**谷上（Zeno）**的。这意味着系统在有限的时间内经历了无限次的离散跳转。与之相对，如果 $\lim_{i \to \infty} t_i = +\infty$，则称执行是**时间发散的**（Time-Divergent），这通常被认为是“行为良好”的。

一个经典的谷上行为例子是“弹跳球”模型：一个球在重力作用下下落，每次撞击地面时，其速度会因非[完全弹性碰撞](@entry_id:176075)而衰减（例如，变为 $v^+ = -c v^-$，其中[能量耗散](@entry_id:147406)系数 $c \in (0,1)$）。由于每次反弹的初始速度和最大高度都递减，每次弹跳的持续时间也随之缩短。这些持续时间构成一个收敛的[几何级数](@entry_id:158490)，导致球在有限时间内完成无限次弹跳，最终静止在地面上 。谷上行为并非总是需要被排除的病态现象；在某些模型中，它恰恰是对物理现实（如收敛到某个接触点）的忠实描述。然而，它对某些类型的属性（特别是**活性**，Liveness）的验证构成了重大挑战。

#### 专业化模型：时间与随机自动机

在混成自动机的一般框架下，存在一些为特定问题域量身定制的专业化模型。

*   **[时间自动机](@entry_id:1133177)**（Timed Automaton）：这是处理具有硬[实时约束](@entry_id:754130)的系统的关键模型。在[时间自动机](@entry_id:1133177)中，连续[状态变量](@entry_id:138790)仅限于一组特殊的**时钟**（clocks）$C$。所有时钟都以相同的速率前进，即 $\dot{c} = 1$ 对所有 $c \in C$ 成立。守卫和不变量都是关于时钟值的[线性约束](@entry_id:636966)，例如 $x \le 5$ 或 $x-y  2$ 。不变量 $I(\ell)$ 限制了一个模式 $\ell$ 能持续的最长时间（例如，时钟 $x$ 在进入模式 $\ell$ 时被重置，而不变量为 $x \le 5$，则该模式最多持续5个时间单位）。守卫则规定了跳转发生的精确时间窗口。理解不变量和守卫之间的区别至关重要：不变量约束**连续时间流逝**，而守卫仅在**离散跳转瞬间**起作用，用于使能跳转 。像 **UPPAAL** 这样的工具就是专门为分析[时间自动机](@entry_id:1133177)网络而设计的 。

*   **随机混成系统**（Stochastic Hybrid System）：为了对包含不确定性和噪声的 CPS 进行建模，我们在混成自动机中引入了概率。这可以通过多种方式实现，例如，在连续动态中加入随机扰动（如 $\dot{x} = f(x) + w$，其中 $w$ 是[随机过程](@entry_id:268487)），或为离散跳转的目标模式分配一个概率分布。在这样的模型中，[非确定性](@entry_id:273591)（由调度器或控制器做出的选择）和随机性（由概率律支配的偶然事件）被明确区分。一旦解决了[非确定性](@entry_id:273591)（即固定一个**调度器**），系统就演变成一个纯粹的[随机过程](@entry_id:268487)，其执行路径上便有了一个良定义的[概率测度](@entry_id:190821) 。像 **PRISM** 这样的工具专注于验证离散状态的[概率模型](@entry_id:265150)（如马尔可夫链），而更高级的模型则将这种[概率推理](@entry_id:273297)扩展到混成系统中 。

### 系统属性的规约

有了形式化模型后，我们需要一种同样形式化的语言来精确描述我们希望系统满足的属性或规约。

#### [安全性与活性](@entry_id:634196)二分法

在属性规约的最高层面上，存在一个由 Alpern 和 Schneider 提出的基本分类：**安全性**（Safety）和**活性**（Liveness）。这个分类基于属性被违反的方式。

*   **安全性属性**断言“坏事永远不会发生”。其关键特征是，任何对安全属性的违反都可以通过一个**有限的执行前缀**来无可辩驳地证明。例如，“温度从不超过100度”就是一个安全属性。一旦我们观察到一个温度达到101度的时刻，这个属性就被违反了，并且无论后续发生什么，这个违[反事实](@entry_id:923324)都无法被撤销。形式上，一个属性是安全的，当且仅当对于任何违反该属性的无限执行，都存在一个有限前缀，其所有无限扩展都违反该属性。

*   **活性属性**断言“好事最终会发生”。其关键特征是，对活性属性的违反**不能**通过任何有限执行前缀来证明。例如，“每次请求最终都会被响应”就是一个活性属性。即使我们观察了很长一段时间内一个请求都未被响应，我们也不能断定它永远不会被响应——响应可能在下一刻就会到来。只有在观察了整个无限执行之后，我们才能确定活性属性是否被违反。

这种区分至关重要，因为它直接关系到可以采用的验证技术。安全属性通常通过[证明系统](@entry_id:156272)状态始终停留在某个“安全”区域内来验证，这通常使用**不变量**（Invariants）来完成。而活性属性则需要更复杂的推理，如使用**排序函数**（Ranking Functions）来[证明系统](@entry_id:156272)正朝着某个目标状态取得进展，并且不会永远停滞不前 。

#### 用于规约的[时间逻辑](@entry_id:181558)

[时间逻辑](@entry_id:181558)提供了一种具有数学精确性的语言来表达关于系统行为随时间变化的属性。

*   **线性[时间逻辑](@entry_id:181558)（LTL）** 和 **[计算树逻辑](@entry_id:198041)（CTL）**：这是两种经典的时间逻辑 。LTL 在单个计算路径（一个无限的执行序列）上解释公式，其基本时序算子包括 $\mathbf{G}\phi$（全局，Globally，$\phi$ 在路径上一直为真）和 $\mathbf{F}\phi$（最终，Finally，$\phi$ 在路径上最终会为真）。CTL 则在由系统所有可能路径构成的“[计算树](@entry_id:267610)”上解释公式，它引入了路径[量词](@entry_id:159143) $\forall$（或 $A$，对所有路径）和 $\exists$（或 $E$，存在某条路径）来修饰时序算子。例如，$\forall\mathbf{G}(\textit{safe})$ 表示在所有可能的未来中，系统都将保持安全，这是一个典型的安全属性。$\forall\mathbf{F}(\textit{goal})$ 表示系统最终总能到达目标，这是一个活性属性。这两种逻辑都产生布尔（真/假）的满足性结果。

*   **度量时间逻辑（MTL）** 和 **信号[时间逻辑](@entry_id:181558)（STL）**：对于需要量化时间或信号值的 CPS，经典时间逻辑有所不足。MTL 通过为时序算子增加时间区间来扩展 LTL，例如 $\mathbf{G}_{[0, 5]}(\textit{temp}  80)$ 表示“在未来5个时间单位内，温度始终低于80度”。STL 则更进一步，它被设计用于解释实值信号（如传感器读数）。STL 的核心创新在于，它用关于实值的谓词（如 $x(t) \ge c$）替代了布尔原子命题，并引入了**定量鲁棒性语义**（Quantitative Robustness Semantics）。一个 STL 公式的鲁棒性是一个实数值，其正负号表示该公式是否被满足，而其绝对值则量化了满足或违反的“裕度”。例如，对于规约 $\phi \equiv \mathbf{G}_{[0,5]}(x(t)\ge 1)$ 和一个信号，如果其鲁棒性为 $\rho(\phi) = 0.5$，这表示信号不仅满足规约，而且即使信号整体下降 $0.5$，规约依然能被满足。如果鲁棒性为 $\rho(\phi) = -0.2$，这表示信号违反了规约，并且需要至少被提升 $0.2$ 才能恰好满足规约。这种定量信息在[系统设计](@entry_id:755777)和监控中极其宝贵 。

*   **概率[计算树逻辑](@entry_id:198041)（PCTL）**：当系统模型包含随机性时，我们需要能够表达概率性属性。PCTL 扩展了 CTL，引入了概率算子 $\mathsf{P}_{\bowtie p}[\psi]$，其含义是“路径属性 $\psi$ 成立的概率满足关系 $\bowtie p$”（其中 $\bowtie \in \{, \le, >, \ge\}$）。例如，$\mathsf{P}_{\ge 0.99}[\mathbf{F}^{\le 10}(\textit{safe})]$ 表示“系统在10个时间单位内达到安全状态的概率至少是 0.99” 。在包含[非确定性](@entry_id:273591)的系统中，该概率通常在所有可能的对抗性调度策略下取最小值（[最坏情况分析](@entry_id:168192)）。

#### 混成程序的逻辑：[微分](@entry_id:158422)[动态逻辑](@entry_id:165510)

**[微分](@entry_id:158422)[动态逻辑](@entry_id:165510)**（Differential Dynamic Logic, $d\mathcal{L}$）是一种极其强大的形式主义，它将规约逻辑与描述混成系统的**混成程序**（Hybrid Programs）无缝集成 。一个混成程序 $\alpha$ 可以包含离散赋值（$x:=e$）、[非确定性](@entry_id:273591)选择（$\alpha \cup \beta$）、顺序执行（$\alpha;\beta$）以及连续演化（$\{x'=f(x) \land H\}$）。

$d\mathcal{L}$ 的核心是两种模态算子：

*   **盒算子 $[\alpha]\phi$**：读作“在程序 $\alpha$ 的**所有**可能执行终止后，属性 $\phi$ 成立”。这是一个泛化了的安全属性。它断言，无论 $\alpha$ 中的[非确定性](@entry_id:273591)如何解决，只要它终止，其最终状态必然满足 $\phi$。

*   **菱形算子 $\langle\alpha\rangle\phi$**：读作“**存在**一种 $\alpha$ 的执行方式，使其终止后属性 $\phi$ 成立”。这是一个泛化了的能达性或活性属性。它断言，至少有一种方法可以执行 $\alpha$ 并达到一个满足 $\phi$ 的状态。

例如，对于一个自动驾驶汽车的混成程序 `Brake`，安全规约“刹车后速度最终为零”可以写作 `[Brake](speed = 0)`。$d\mathcal{L}$ 的美妙之处在于它提供了一个演绎[证明系统](@entry_id:156272)（proof calculus），使得这类复杂的混成系统属性可以通过逻辑推导来证明。**KeYmaera X** 是实现 $d\mathcal{L}$ 的一个先进的[定理证明](@entry_id:1132970)器 。

### 核心验证机制

有了模型和规约，接下来的问题是：我们如何自动或半自动地证明模型满足规约？本节将介绍几种核心的验证机制。

#### 可达性分析与基于集合的过近似

**可达性分析**是验证安全属性最直接和最基本的方法。其思想是计算出系统从一个初始状态集合出发，在所有可能的输入和扰动下，能够到达的所有状态的集合——即**可达集**（Reachable Set）。如果这个[可达集](@entry_id:276191)与预定义的[不安全状态](@entry_id:756344)集没有交集，那么系统就是安全的。

然而，对于具有连续动态的 CPS，精确计算可达集通常是不可能的。因此，我们转而计算一个包含真实可达集的**过近似集**（Over-approximation）$\widehat{\mathcal{R}}(t)$，使得 $\mathcal{R}(t) \subseteq \widehat{\mathcal{R}}(t)$。如果这个过近似集与不安[全集](@entry_id:264200)不相交，那么我们就可以**有声地**（soundly）断定系统是安全的。尽管这种方法可能因为近似过于粗糙而产生误报（即一个安全的系统可能无法被证明是安全的），但它绝不会产生漏报（即不会将不安全的系统误判为安全）。

为了在计算机中表示和计算这些状态集，研究人员开发了多种几何形状的表示方法，每种方法在[表达能力](@entry_id:149863)、计算复杂度和对不同动态的适应性上都有所取舍 ：

*   **[多胞体](@entry_id:635589)**（Polytopes）：由有限个[线性不等式](@entry_id:174297)（$Hx \le h$）的交集定义。它们可以精确表示[线性系统](@entry_id:147850)的可达集，但在[非线性变换](@entry_id:636115)和投影操作下计算成本高昂。
*   **椭球**（Ellipsoids）：由二次不等式（$(x-c)^T P^{-1} (x-c) \le 1$）定义。椭球在**线性变换**下是封闭的（一个椭球的[线性映射](@entry_id:185132)仍然是椭球），但它们在**[闵可夫斯基和](@entry_id:176841)**（Minkowski sum，用于叠加来自不同来源的扰动或输入）下不是封闭的，这使得处理输入和扰动时需要进行额外的过近似。
*   **带域**（Zonotopes）：表示为中心点与一组生成向量的[闵可夫斯基和](@entry_id:176841)。它们在**线性变换和[闵可夫斯基和](@entry_id:176841)**下都是封闭的，这使得它们对于处理具有附加输入的[线性系统](@entry_id:147850)非常高效。对于非线性系统，可以通过泰勒展开并将[余项](@entry_id:159839)用新的生成向量包裹起来，从而将[非线性](@entry_id:637147)动态嵌入到一个线性[微分](@entry_id:158422)包含中。这种技术使得带域成为处理[非线性系统](@entry_id:168347)的一种强大工具。

像 **SpaceEx** 这样的工具精于使用多胞体和[支撑函数](@entry_id:755667)等表示法来分析[分段仿射](@entry_id:638052)动态系统，而 **Flow*** 则利用**[泰勒模型](@entry_id:203285)**（Taylor Models）来为具有一般[非线性](@entry_id:637147)（甚至非多项式）动态的系统计算高精度的基于带域的过近似 。

#### 连续与混成动态的演绎方法

除了基于集合的显式计算，另一大类方法借鉴了控制理论中的思想，通过寻找辅助函数来间接[证明系统](@entry_id:156272)属性。

*   **[微分](@entry_id:158422)不变量**（Differential Invariants）：这是一个断言，它在系统的连续演化过程中始终为真。对于由不等式 $g(x) \le 0$ 定义的区域，证明其为不变量的一个充分条件是，在其边界 $g(x)=0$ 上，向量场 $f(x)$ 不指向区域外部。这可以通过计算 $g$ 沿 $f$ 的**[李导数](@entry_id:171745)**（Lie derivative）$\mathcal{L}_f g(x) = \nabla g(x) \cdot f(x)$ 并证明其在边界上非正（$\mathcal{L}_f g(x) \le 0$）来验证 。[微分](@entry_id:158422)不变量是证明连续动态安全性的基础。

*   **[屏障证书](@entry_id:1121354)**（Barrier Certificates）：这是[微分](@entry_id:158422)不变量思想的直接应用，专门用于证明安全性（即系统状态永远不会进入不安全区域 $U$）。一个[屏障证书](@entry_id:1121354)是一个函数 $B(x)$，它在初始状态集 $I$ 上为负，在不安全区域 $U$ 上为正。如果我们能证明 $B(x)$ 的[李导数](@entry_id:171745)在其零水平集（即屏障 $B(x)=0$）上非正，那么[系统轨迹](@entry_id:1132840)一旦从 $B(x)  0$ 的区域开始，就永远无法穿越屏障到达 $B(x) > 0$ 的区域。这有效地在安全区和不安全区之间建立了一道“屏障”，从而证明了系统的安全性 。

*   **[李雅普诺夫函数](@entry_id:273986)**（Lyapunov Functions）：与用于证明安全性的[屏障证书](@entry_id:1121354)不同，[李雅普诺夫函数](@entry_id:273986)主要用于[证明系统](@entry_id:156272)的**稳定性**，即系统状态会收敛到一个平衡点 $x^\star$。一个[李雅普诺夫函数](@entry_id:273986) $V(x)$ 是一个在平衡点 $x^\star$ 处取值为零、在其邻域内为正定的函数。如果其[李导数](@entry_id:171745)在邻域内是负半定的（$\mathcal{L}_f V(x) \le 0$），则系统是稳定的；如果是负定的（$\mathcal{L}_f V(x)  0$），则系统是[渐近稳定](@entry_id:168077)的。$V(x)$ 就像一个衡量系统“能量”的量，系统会沿着使其能量不增（或减少）的轨迹运动，最终趋于能量最低点，即平衡点 。

#### 时间与概率系统的模型检测

对于使用[时间自动机](@entry_id:1133177)或概率模型等专业化模型的系统，存在相应的自动化验证技术，通常称为**[模型检测](@entry_id:150498)**（Model Checking）。

*   对于**[时间自动机](@entry_id:1133177)**，尽管时钟是连续变量，但可以通过构造一个有限的、等价的[离散状态空间](@entry_id:146672)（称为“区域图”或更高效的“区域图”）来进行穷尽的[状态空间搜索](@entry_id:274289)。像 **UPPAAL** 这样的工具就实现了基于区域的算法，能够高效地验证 TCTL（[时间自动机](@entry_id:1133177)的 CTL 变体）公式，检查诸如[可达性](@entry_id:271693)、死锁和时序属性等问题 。

*   对于**概率系统**，如[离散时间马尔可夫链](@entry_id:263188)（DTMC）或[马尔可夫决策过程](@entry_id:140981)（MDP），[概率模型检测](@entry_id:192738)器（如 **PRISM**）可以计算满足给定 PCTL 属性的精确概率。例如，它可以回答“系统发生故障的概率是多少？”或“在满足某个性能指标的约束下，能达到的最大成功概率是多少？”这类定量问题  。

#### 组合式推理：[假设-保证合约](@entry_id:1121149)

随着 CPS 规模和复杂度的增加，对整个系统进行单一的、整体的验证（所谓的“单体式验证”）很快会面临**[状态空间爆炸](@entry_id:1132298)**问题，变得不可行。**组合式推理**（Compositional Reasoning）旨在通过“[分而治之](@entry_id:273215)”的策略来克服这一挑战。

**[假设-保证合约](@entry_id:1121149)**（Assume-Guarantee Contracts）是实现组合式推理的一种主流范式 。其核心思想是，将对整个系统的全局属性 $P$ 的验证，分解为对每个组件 $C_i$ 的局部验证。每个组件的规约被表述为一个合约 $(A_i, G_i)$：

*   **假设**（Assume）$A_i$：这是对组件所处的环境行为的约束。
*   **保证**（Guarantee）$G_i$：这是组件自身的行为承诺，**前提是**其环境满足了假设 $A_i$。

组件 $C_i$ 满足其合约，记为 $C_i \models (A_i, G_i)$，意味着“只要环境遵守 $A_i$，我就保证遵守 $G_i$”。

要证明由多个组件（如 $C_1$ 和 $C_2$）构成的系统满足全局属性 $P$，我们需要完成以下证明任务：
1.  **局部验证**：对每个组件 $C_i$，证明 $C_i \models (A_i, G_i)$。
2.  **假设卸载**（Assumption Discharge）：证明组件之间的交互能够满足彼此的假设。例如，在 $C_1$ 和 $C_2$ 构成的[闭环系统](@entry_id:270770)中，我们需要证明 $C_1$ 的保证 $G_1$ 能够满足 $C_2$ 的假设 $A_2$（即 $G_1 \Rightarrow A_2$），同时 $C_2$ 的保证 $G_2$ 也能满足 $C_1$ 的假设 $A_1$（即 $G_2 \Rightarrow A_1$）。
3.  **属性蕴含**：证明所有组件的保证合在一起足以推导出全局属性 $P$（即 $G_1 \land G_2 \Rightarrow P$）。

如果所有这些证明任务都得以完成，我们就可以断定整个系统满足属性 $P$。这种方法将一个大型验证[问题分解](@entry_id:272624)为多个规模更小、更易于处理的子问题，从而极大地提升了验证的可扩展性 。