{
    "hands_on_practices": [
        {
            "introduction": "将故障-运行系统中的冗余设计概念，转化为可量化的可靠性指标，是系统设计的第一步。本练习  将引导您使用连续时间马尔可夫链 (CTMC) 这一强大的随机过程工具，来为一个经典的双单元并联冗余系统建模。通过分析系统的状态（如正常运行单元的数量）及其之间的转换（如故障和修复），您将能从第一性原理出发，推导出系统的稳态可用性，从而深刻理解故障率 $\\lambda$ 和修复率 $\\mu$ 是如何共同决定一个高可用系统的性能边界。",
            "id": "4221276",
            "problem": "一个信息物理系统采用了一种故障-运行、故障切换的架构，其中包含两个相同的计算单元构成并行冗余。该系统的数字孪生（DT）监控单元的健康状况，并在发生故障时协调即时修复操作。每个物理单元的故障是独立发生的，每个故障单元的修复也是独立的，且故障和修复过程均被建模为无记忆过程。具体而言，我们基于标准的可靠性理论和随机过程理论，作如下建模假设：\n\n- 每个单元的故障遵循一个独立的泊松过程，其速率为 $\\lambda$，从而导致故障时间服从参数为 $\\lambda$ 的指数分布。\n- 每个故障单元由一个独立的修复通道进行恢复，其速率为 $\\mu$，从而导致修复时间服从参数为 $\\mu$ 的指数分布，并且在数字孪生发出故障通知后，修复立即开始。如果有 $k$ 个单元发生故障，则总的修复完成速率为 $k \\mu$。\n- 如果至少有一个单元在正常工作，则系统是可运行的（可用的），这符合故障-运行的设计；仅当两个单元都发生故障时，系统才不可用。\n\n将该系统建模为一个连续时间马尔可夫链（CTMC），其中状态 $i \\in \\{0,1,2\\}$ 表示正常工作的单元数量。状态转移通过单个单元的故障或单个单元的修复事件发生，这与无记忆假设和独立通道的设定是一致的。请从CTMC稳态分析的第一性原理出发，推导系统的稳态可用性，且不使用任何现成的可靠性捷径公式。稳态可用性定义为系统可运行的稳态概率，即系统处于状态 $i=1$ 或 $i=2$ 的稳态概率。\n\n将最终答案表示为一个仅含 $\\lambda$ 和 $\\mu$ 的单一闭式解析表达式。不需要进行数值近似或四舍五入。",
            "solution": "该问题是有效的。该系统可以建模为一个连续时间马尔可夫链（CTMC），其状态空间为 $S = \\{0, 1, 2\\}$，其中状态 $i$ 代表正常工作的单元数量。问题指明，单元的故障和修复是独立的无记忆过程，这为使用指数分布和CTMC模型提供了依据。这对应于一个经典的生灭过程。\n\n设 $\\pi_i$ 为系统处于状态 $i$ 的稳态概率。我们首先根据所提供的信息确定状态之间的转移速率。\n\n1.  **状态 2：两个单元都正常工作。**\n    唯一可能的转移是两个单元中的一个发生故障。由于每个单元的故障速率为 $\\lambda$ 且故障是独立的，因此离开状态 2 的总速率为 $2\\lambda$。此转移导致系统进入状态 1。\n    转移：$2 \\to 1$，速率为 $q_{2,1} = 2\\lambda$。\n\n2.  **状态 1：一个单元正常工作，一个单元已发生故障。**\n    从此状态出发，有两种可能的转移：\n    a. 剩余的正常工作单元发生故障。此事件发生的速率为 $\\lambda$。转移为 $1 \\to 0$。\n    b. 已故障的单元被修复。问题陈述，如果有 $k$ 个单元故障，总修复完成速率为 $k\\mu$。此处，有一个单元故障（$k=1$），因此修复速率为 $\\mu$。转移为 $1 \\to 2$。\n    离开状态 1 的总速率为 $(\\lambda + \\mu)$。\n    转移：$1 \\to 0$，速率为 $q_{1,0} = \\lambda$；以及 $1 \\to 2$，速率为 $q_{1,2} = \\mu$。\n\n3.  **状态 0：两个单元都已发生故障。**\n    唯一可能的转移是修复两个故障单元中的一个。此时有两个单元故障（$k=2$），因此总修复速率为 $2\\mu$。单个修复事件使系统转移到状态 1。\n    转移：$0 \\to 1$，速率为 $q_{0,1} = 2\\mu$。\n\n此生灭过程的状态转移图如下：\n$$\n\\text{状态 } 2 \\underset{\\mu}{\\stackrel{2\\lambda}{\\rightleftarrows}} \\text{状态 } 1 \\underset{2\\mu}{\\stackrel{\\lambda}{\\rightleftarrows}} \\text{状态 } 0\n$$\n\n为了求得稳态概率 $\\{\\pi_0, \\pi_1, \\pi_2\\}$，我们写出平衡方程。对于生灭过程，使用细致平衡方程即可，该方程表明，在稳态下，从状态 $i$ 到 $i-1$ 的流量速率等于从状态 $i-1$ 到 $i$ 的流量速率。\n\n状态 2 与状态 1 之间的平衡：\n$$\n\\pi_2 q_{2,1} = \\pi_1 q_{1,2} \\implies \\pi_2 (2\\lambda) = \\pi_1 \\mu\n$$\n由此，我们可以用 $\\pi_1$ 表示 $\\pi_2$：\n$$\n\\pi_2 = \\frac{\\mu}{2\\lambda} \\pi_1\n$$\n\n状态 1 与状态 0 之间的平衡：\n$$\n\\pi_1 q_{1,0} = \\pi_0 q_{0,1} \\implies \\pi_1 \\lambda = \\pi_0 (2\\mu)\n$$\n由此，我们可以用 $\\pi_1$ 表示 $\\pi_0$：\n$$\n\\pi_0 = \\frac{\\lambda}{2\\mu} \\pi_1\n$$\n\n所有稳态概率之和必须等于 1：\n$$\n\\pi_0 + \\pi_1 + \\pi_2 = 1\n$$\n将用 $\\pi_1$ 表示的 $\\pi_0$ 和 $\\pi_2$ 的表达式代入归一化方程：\n$$\n\\frac{\\lambda}{2\\mu} \\pi_1 + \\pi_1 + \\frac{\\mu}{2\\lambda} \\pi_1 = 1\n$$\n提出因子 $\\pi_1$：\n$$\n\\pi_1 \\left( \\frac{\\lambda}{2\\mu} + 1 + \\frac{\\mu}{2\\lambda} \\right) = 1\n$$\n为了解出 $\\pi_1$，我们为括号内的项找到一个公分母，即 $2\\lambda\\mu$：\n$$\n\\pi_1 \\left( \\frac{\\lambda^2}{2\\lambda\\mu} + \\frac{2\\lambda\\mu}{2\\lambda\\mu} + \\frac{\\mu^2}{2\\lambda\\mu} \\right) = 1\n$$\n合并分子中的各项：\n$$\n\\pi_1 \\left( \\frac{\\lambda^2 + 2\\lambda\\mu + \\mu^2}{2\\lambda\\mu} \\right) = 1\n$$\n分子是 $(\\lambda + \\mu)^2$ 的展开式：\n$$\n\\pi_1 \\left( \\frac{(\\lambda + \\mu)^2}{2\\lambda\\mu} \\right) = 1\n$$\n解出 $\\pi_1$：\n$$\n\\pi_1 = \\frac{2\\lambda\\mu}{(\\lambda + \\mu)^2}\n$$\n现在我们可以求出 $\\pi_0$ 和 $\\pi_2$：\n$$\n\\pi_0 = \\frac{\\lambda}{2\\mu} \\pi_1 = \\frac{\\lambda}{2\\mu} \\left( \\frac{2\\lambda\\mu}{(\\lambda + \\mu)^2} \\right) = \\frac{\\lambda^2}{(\\lambda + \\mu)^2}\n$$\n$$\n\\pi_2 = \\frac{\\mu}{2\\lambda} \\pi_1 = \\frac{\\mu}{2\\lambda} \\left( \\frac{2\\lambda\\mu}{(\\lambda + \\mu)^2} \\right) = \\frac{\\mu^2}{(\\lambda + \\mu)^2}\n$$\n\n问题将稳态可用性 $A$ 定义为系统可运行的稳态概率。系统在状态 1 和状态 2 时是可运行的。因此，可用性是处于这些状态的概率之和：\n$$\nA = \\pi_1 + \\pi_2\n$$\n或者，更简单地说，可用性是不可用性的补集。系统仅在状态 0 时不可用。\n$$\nA = 1 - \\pi_0\n$$\n使用 $\\pi_0$ 的表达式：\n$$\nA = 1 - \\frac{\\lambda^2}{(\\lambda + \\mu)^2}\n$$\n为了将其写成一个单一的闭式表达式，我们合并这些项：\n$$\nA = \\frac{(\\lambda + \\mu)^2 - \\lambda^2}{(\\lambda + \\mu)^2} = \\frac{(\\lambda^2 + 2\\lambda\\mu + \\mu^2) - \\lambda^2}{(\\lambda + \\mu)^2}\n$$\n$$\nA = \\frac{2\\lambda\\mu + \\mu^2}{(\\lambda + \\mu)^2}\n$$\n这也可以写成 $\\frac{\\mu(2\\lambda + \\mu)}{(\\lambda + \\mu)^2}$。推导出的表达式仅用故障率 $\\lambda$ 和修复率 $\\mu$ 来表示稳态可用性。",
            "answer": "$$\n\\boxed{\\frac{2\\lambda\\mu + \\mu^2}{(\\lambda + \\mu)^2}}\n$$"
        },
        {
            "introduction": "在实现故障-运行能力时，增加冗余计算任务会消耗宝贵的处理器资源，这在时间关键的赛博物理系统中可能导致任务错过最后期限。本练习  关注的正是可靠性设计与实时系统理论的交叉点。您将应用速率单调分析 (Rate Monotonic Analysis, RMA) 的基本原理，来评估一个增加了冗余备份任务的系统的可调度性，并计算出在保证所有任务（包括主任务和备份任务）都能满足其截止时间的前提下，冗余任务所允许的最大执行时间。",
            "id": "4221203",
            "problem": "一个带有数字孪生的信息物理系统持续监控一个安全关键型控制应用，该应用在单一部件故障下必须保持失效可操作性。为实现失效可操作行为，系统部署了在线冗余计算以进行故障切换，以便在发生故障时，冗余副本能够接管任务而不会错过截止时间。实时调度器采用固定优先级速率单调调度，并且任务满足经典周期性任务模型的假设：每个任务都是周期的、独立的、可抢占的，并且其相对截止时间等于其周期。\n\n主要工作负载包括三个周期性任务：$\\,\\text{Task}\\,1\\,$ 的执行时间为 $C_{1}=1.2\\,\\text{ms}$，周期为 $T_{1}=10\\,\\text{ms}$；$\\,\\text{Task}\\,2\\,$ 的执行时间为 $C_{2}=3.5\\,\\text{ms}$，周期为 $T_{2}=25\\,\\text{ms}$；$\\,\\text{Task}\\,3\\,$ 的执行时间为 $C_{3}=5.5\\,\\text{ms}$，周期为 $T_{3}=50\\,\\text{ms}$。为了在调度预算内提供故障切换能力，在线添加了两个相同的冗余副本任务。每个冗余任务的执行时间为 $C_r$（待定），周期为 $T_{r}=15\\,\\text{ms}$。将使用基于利用率的速率单调分析（RMA）充分可调度性测试，以确保所有任务在最坏情况下都能满足其截止时间。\n\n从周期性任务利用率和速率单调调度下固定优先级可调度性的基本定义出发，推导当添加两个冗余任务后，增强任务集的可调度性条件。利用此条件，计算：\n\n1. 每个冗余任务允许的最大执行时间 $C_{r,\\max}$，使得增强系统在速率单调分析下保持可调度。\n2. 增强系统中对应于任务总数的 RMA 利用率界限。\n\n将 $C_{r,\\max}$ 以毫秒表示，利用率界限以小数表示。将两个数值结果均四舍五入至四位有效数字。以二元行向量的形式 $\\big(C_{r,\\max},\\,U_{\\text{bound}}\\big)$ 提供最终答案。",
            "solution": "用户要求我验证问题陈述的有效性，如果有效，则提供一个合理的解决方案。\n\n### 第一步：提取给定信息\n\n问题陈述提供了以下信息：\n- **系统背景**：一个带有数字孪生的信息物理系统，用于安全关键型应用。\n- **弹性要求**：在单一部件故障下保持失效可操作性。\n- **弹性机制**：用于故障切换的在线冗余计算。\n- **调度算法**：固定优先级速率单调调度（RMS）。\n- **任务模型**：周期的、独立的、可抢占的任务，其相对截止时间等于周期。\n- **主要任务集**：\n  - 任务1 ($\\tau_1$)：执行时间 $C_1 = 1.2\\,\\text{ms}$，周期 $T_1 = 10\\,\\text{ms}$。\n  - 任务2 ($\\tau_2$)：执行时间 $C_2 = 3.5\\,\\text{ms}$，周期 $T_2 = 25\\,\\text{ms}$。\n  - 任务3 ($\\tau_3$)：执行时间 $C_3 = 5.5\\,\\text{ms}$，周期 $T_3 = 50\\,\\text{ms}$。\n- **冗余任务**：\n  - 任务数量：$2$。\n  - 执行时间：$C_r$（待定）。\n  - 周期：$T_r = 15\\,\\text{ms}$。\n- **可调度性测试**：基于利用率的速率单调分析（RMA）充分可调度性测试。\n- **目标**：\n  1. 计算每个冗余任务允许的最大执行时间 $C_{r,\\max}$。\n  2. 计算增强系统的 RMA 利用率界限 $U_{\\text{bound}}$。\n- **输出要求**：将两个结果均四舍五入至四位有效数字，并以二元行向量 $\\big(C_{r,\\max},\\,U_{\\text{bound}}\\big)$ 的形式呈现。\n\n### 第二步：使用提取的信息进行验证\n\n- **科学或事实不健全性**：该问题基于经典的实时调度理论，特别是速率单调调度和 Liu and Layland 的基于利用率的测试。这些是计算机科学与工程中的基本概念。使用冗余任务以实现失效可操作性的场景是安全关键型系统中的标准做法。其前提是科学合理的。\n- **不可形式化或不相关**：该问题在实时系统分析领域内是高度可形式化的。它与信息物理系统中失效可操作机制的设计直接相关。\n- **不完整或矛盾的设置**：主要任务和新增冗余任务的所有必要参数都已提供。目标明确，分析方法（基于利用率的RMA测试）也已明确指定。问题是自洽且完整的。\n- **不切实际或不可行**：执行时间和周期对于实时控制系统来说在数值上是合理的。该场景是实时系统设计中的一个标准练习。\n- **不适定或结构不良**：该问题是适定的。给定指定的可调度性测试，可以确定冗余任务执行时间的唯一最大值。结构清晰且合乎逻辑。\n- **伪深刻、琐碎或同义反复**：该问题需要对既定公式和代数运算进行直接但不琐碎的应用。这是一个测试对RMA原理理解的标准问题。\n- **超出科学可验证范围**：解决方案可以根据实时调度理论的原理独立推导和验证。\n\n### 第三步：结论与行动\n\n问题是**有效的**，因为它是科学合理的、适定的和完整的。将推导出一个解决方案。\n\n解决方案通过应用速率单调调度（RMS）的原理来进行。一个执行时间为 $C_i$、周期为 $T_i$ 的周期性任务 $\\tau_i$ 的利用率定义为 $U_i = \\frac{C_i}{T_i}$。对于一个包含 $n$ 个任务的集合，总处理器利用率是各个任务利用率之和，即 $U = \\sum_{i=1}^{n} U_i$。\n\n根据由 Liu and Layland 建立的 RMS 充分可调度性测试，一个包含 $n$ 个独立的、可抢占的、截止时间等于其周期的周期性任务集合是可调度的，如果其总利用率 $U$ 不超过利用率界限 $U_{\\text{bound}}(n)$：\n$$U \\le U_{\\text{bound}}(n) = n(2^{1/n} - 1)$$\n问题要求我们分析增强系统，该系统包括三个主要任务和两个冗余任务。这个增强任务集中的任务总数为 $n = 3 + 2 = 5$。\n\n首先，我们计算三个主要任务的利用率：\n- $U_1 = \\frac{C_1}{T_1} = \\frac{1.2\\,\\text{ms}}{10\\,\\text{ms}} = 0.12$\n- $U_2 = \\frac{C_2}{T_2} = \\frac{3.5\\,\\text{ms}}{25\\,\\text{ms}} = 0.14$\n- $U_3 = \\frac{C_3}{T_3} = \\frac{5.5\\,\\text{ms}}{50\\,\\text{ms}} = 0.11$\n\n主要任务的组合利用率为：\n$$U_{\\text{primary}} = U_1 + U_2 + U_3 = 0.12 + 0.14 + 0.11 = 0.37$$\n\n增强系统包括两个相同的冗余任务，每个任务的执行时间未知，为 $C_r$，周期为 $T_r = 15\\,\\text{ms}$。每个冗余任务的利用率为 $U_r = \\frac{C_r}{T_r}$。增强系统的总利用率为：\n$$U_{\\text{total}} = U_{\\text{primary}} + 2 U_r = 0.37 + 2 \\frac{C_r}{15}$$\n\n第一个目标是计算增强系统的 RMA 利用率界限。对于 $n=5$ 个任务，该界限为：\n$$U_{\\text{bound}} = U_{\\text{bound}}(5) = 5(2^{1/5} - 1)$$\n计算数值：\n$$U_{\\text{bound}} \\approx 5(1.14869835 - 1) = 5(0.14869835) \\approx 0.74349175$$\n四舍五入到四位有效数字，增强系统的 RMA 利用率界限为 $0.7435$。\n\n第二个目标是找到每个冗余任务允许的最大执行时间 $C_{r,\\max}$。为此，我们应用 RMA 充分条件。如果 $U_{\\text{total}} \\le U_{\\text{bound}}(5)$，则系统保证是可调度的。\n$$0.37 + 2 \\frac{C_r}{15} \\le 5(2^{1/5} - 1)$$\n$C_r$ 的最大值，记为 $C_{r,\\max}$，在等式成立时取得：\n$$0.37 + 2 \\frac{C_{r,\\max}}{15} = 5(2^{1/5} - 1)$$\n现在，我们求解 $C_{r,\\max}$：\n$$2 \\frac{C_{r,\\max}}{15} = 5(2^{1/5} - 1) - 0.37$$\n$$C_{r,\\max} = \\frac{15}{2} \\left[ 5(2^{1/5} - 1) - 0.37 \\right]$$\n代入先前计算的利用率界限值：\n$$C_{r,\\max} \\approx \\frac{15}{2} [0.74349175 - 0.37]$$\n$$C_{r,\\max} \\approx 7.5 [0.37349175]$$\n$$C_{r,\\max} \\approx 2.8011881\\,\\text{ms}$$\n四舍五入到四位有效数字，每个冗余任务允许的最大执行时间为 $C_{r,\\max} \\approx 2.801\\,\\text{ms}$。\n\n需要报告的两个量是 $C_{r,\\max}$ 和 $U_{\\text{bound}}$。\n$C_{r,\\max} = 2.801\\,\\text{ms}$\n$U_{\\text{bound}} = 0.7435$\n最终答案是包含这两个值的行向量。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.801  & 0.7435\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "除了被动地响应故障，更先进的设计理念是通过主动控制来确保系统始终不会进入不安全的状态。本练习  将带您探索控制屏障函数 (Control Barrier Functions, CBF) 这一前沿技术，它为设计可证明安全的控制器提供了严谨的数学框架。您将从第一性原理出发，为一个由 $h(x) \\ge 0$ 定义的安全区域推导出一个前向不变性条件，并构建一个二次规划 (QP) 问题，以合成一个“最小侵入式”控制器，该控制器在满足安全约束和执行器物理限制的同时，尽可能地追踪期望的性能指令。",
            "id": "4221269",
            "problem": "考虑一个控制仿射标量信息物理系统，该系统代表一个由其数字孪生监控的安全关键型执行器通道。连续时间对象动态模型为 $\\dot{x} = u$，其中 $x \\in \\mathbb{R}$ 是一个无量纲状态，$u \\in \\mathbb{R}$ 是一个无量纲控制输入。安全性要求由安全集 $\\mathcal{C} = \\{ x \\in \\mathbb{R} \\mid h(x) \\ge 0 \\}$ 编码，其中屏障函数为 $h(x) = x - x_{\\min}$，$x_{\\min} \\in \\mathbb{R}$ 是一个固定阈值。执行器具有硬性界限 $u \\in [u_{\\min}, u_{\\max}]$，其中 $u_{\\min}  u_{\\max}$，数字孪生提供期望输入 $u_{\\mathrm{des}}$ 以满足标称性能。所有量均为无量纲。\n\n您需要基于 $h(x)$ 的时间导数和一个严格递增、连续且在零点为零的函数 $\\alpha(\\cdot)$（一个$\\mathcal{K}$类函数），从第一性原理推导出 $\\mathcal{C}$ 的一个前向不变性充分条件。然后，利用该条件，合成一个最小侵入式控制器，该控制器在确保安全（当物理上可实现时）的同时，尽可能小地偏离 $u_{\\mathrm{des}}$，并为因执行器饱和导致安全约束不可行时指定一个故障切换策略。\n\n任务：\n\n1. 从安全集 $\\mathcal{C}$ 的定义、前向不变性（如果 $x(0) \\in \\mathcal{C}$，则对于所有 $t \\ge 0$ 都有 $x(t) \\in \\mathcal{C}$）以及标量系统 $\\dot{x} = u$ 与 $h(x) = x - x_{\\min}$ 出发，推导一个涉及 $\\dot{h}(x)$ 和 $\\alpha(h(x))$ 的充分条件，以保证 $\\mathcal{C}$ 的前向不变性。您的推导必须仅使用动态系统的基本事实，如链式法则、比较论证和$\\mathcal{K}$类函数的性质。不要预先假设最终的不等式形式；请从这些基础上明确地推导出来。\n\n2. 使用任务1中推导出的条件，建立一个形式为“最小化与 $u_{\\mathrm{des}}$ 的平方偏差，受限于安全条件和执行器界限”的凸优化问题。将此优化问题特化到标量情况，并提供基于到可行集上投影的解析解。清晰地解释当安全约束可行时（故障可操作），该解如何产生一个最小侵入式控制器，并为因执行器饱和导致其不可行时（故障安全）指定一个故障切换策略。\n\n3. 实现一个完整的程序，该程序：\n   - 使用$\\mathcal{K}$类函数 $\\alpha(s) = k s$，其中 $k > 0$。\n   - 对于下面的每个测试用例，计算控制量 $u^\\star$，该控制量在强制执行推导出的安全条件和执行器界限的同时，最小化与 $u_{\\mathrm{des}}$ 的平方偏差。如果安全约束不可行，程序必须应用一种故障切换控制，该控制在执行器界限下最大化 $h(x)$ 的瞬时增量（故障安全），并且必须报告安全约束未被满足。\n   - 对于每个测试用例，输出一个由所选控制量 $u^\\star$（一个浮点数）和一个布尔值（指示安全条件是否满足）组成的对。\n\n使用以下固定参数和测试套件（所有量均为无量纲）：\n- $k = 0.5$，\n- $x_{\\min} = 1.0$，\n- $u_{\\min} = -2.0$，\n- $u_{\\max} = 2.0$。\n\n测试用例 $(x, u_{\\mathrm{des}})$：\n- 用例 A：$x = 1.5$，$u_{\\mathrm{des}} = 0.0$。\n- 用例 B：$x = 1.0$，$u_{\\mathrm{des}} = 0.0$。\n- 用例 C：$x = 0.8$，$u_{\\mathrm{des}} = 0.0$。\n- 用例 D：$x = -4.0$，$u_{\\mathrm{des}} = 0.0$。\n- 用例 E：$x = 3.0$，$u_{\\mathrm{des}} = -3.0$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，列表中的每个元素本身是一个形式为 $[u^\\star,\\mathrm{flag}]$ 的双元素列表，其中 $u^\\star$ 是一个浮点数，$\\mathrm{flag}$ 是一个布尔值。例如：$[[u_1,\\mathrm{flag}_1],[u_2,\\mathrm{flag}_2],\\dots]$。\n\n您的解决方案必须科学上真实，并从所述基础推导而来。最终的程序必须是完整的，并且无需外部输入即可运行。",
            "solution": "该问题是有效的，因为它在控制理论，特别是控制屏障函数理论中有科学依据，是适定的，具有唯一且稳定的解，并提供了一套完整且一致的定义、参数和目标。\n\n根据要求，解决方案分三部分推导。\n\n### 任务1：前向不变性充分条件的推导\n\n目标是确保安全集 $\\mathcal{C} = \\{ x \\in \\mathbb{R} \\mid h(x) \\ge 0 \\}$ 的前向不变性，其中 $h(x) = x - x_{\\min}$。前向不变性意味着，如果初始状态 $x(0)$ 在 $\\mathcal{C}$ 中，那么状态轨迹 $x(t)$ 在所有未来时间 $t \\ge 0$ 内都保持在 $\\mathcal{C}$ 中。这等效于要求如果 $h(x(0)) \\ge 0$，那么对于所有 $t \\ge 0$ 都有 $h(x(t)) \\ge 0$。\n\n我们寻求一个关于控制输入 $u$ 的充分条件来保证这一性质。我们提出以下条件，这是（零化）控制屏障函数不等式的标准定义：\n$$ \\dot{h}(x(t)) \\ge -\\alpha(h(x(t))) $$\n其中 $\\alpha(\\cdot)$ 是一个严格递增、连续且在零点为零的函数（一个$\\mathcal{K}$类函数）。\n\n为了证明该条件对于前向不变性是充分的，令 $y(t) = h(x(t))$。轨迹上的条件变为 $\\dot{y}(t) \\ge -\\alpha(y(t))$。我们使用比较论证来分析这个微分不等式。\n\n考虑一个辅助标量变量 $z(t)$ 的初值问题：\n$$ \\dot{z}(t) = -\\alpha(z(t)), \\quad z(0) = y(0) = h(x(0)) $$\n由于 $\\alpha(\\cdot)$ 是一个$\\mathcal{K}$类函数，对于 $s > 0$ 有 $\\alpha(s) > 0$，且 $\\alpha(0) = 0$。这意味着如果 $z(t) > 0$，则 $\\dot{z}(t)  0$，导致 $z(t)$ 减小。如果 $z(t) = 0$，则 $\\dot{z}(t) = -\\alpha(0) = 0$，这意味着 $z=0$ 是一个平衡点。因此，如果初始条件为非负，$z(0) \\ge 0$，则解 $z(t)$ 在所有 $t \\ge 0$ 内将保持非负。\n\n根据微分不等式的比较引理，由于 $\\dot{y}(t) \\ge -\\alpha(y(t))$，$\\dot{z}(t) = -\\alpha(z(t))$，且 $y(0) = z(0)$，可以得出对于所有 $t \\ge 0$ 都有 $y(t) \\ge z(t)$。\n\n综合这些事实，如果我们从一个安全的初始条件 $x(0) \\in \\mathcal{C}$ 开始，则 $h(x(0)) \\ge 0$。这意味着 $y(0) \\ge 0$，因此 $z(0) \\ge 0$。从辅助系统的性质可知，对于所有 $t \\ge 0$ 都有 $z(t) \\ge 0$。比较引理随后得出：\n$$ h(x(t)) = y(t) \\ge z(t) \\ge 0 \\quad \\forall t \\ge 0 $$\n这证实了 $x(t)$ 保持在安全集 $\\mathcal{C}$ 中，从而证明了在条件 $\\dot{h}(x) \\ge -\\alpha(h(x))$ 下 $\\mathcal{C}$ 的前向不变性。\n\n现在，我们为给定系统特化此条件。$h(x)$ 的时间导数通过链式法则求得：\n$$ \\dot{h}(x) = \\frac{\\partial h}{\\partial x} \\dot{x} $$\n对于给定的屏障函数 $h(x) = x - x_{\\min}$，其偏导数为：\n$$ \\frac{\\partial h}{\\partial x} = \\frac{\\partial}{\\partial x}(x - x_{\\min}) = 1 $$\n将此结果和系统动态 $\\dot{x} = u$ 代入 $\\dot{h}(x)$ 的表达式中，得到：\n$$ \\dot{h}(x) = (1) \\cdot u = u $$\n因此，充分前向不变性条件成为对控制输入 $u$ 的一个直接约束：\n$$ u \\ge -\\alpha(h(x)) $$\n或者，代入 $h(x)$ 的定义：\n$$ u \\ge -\\alpha(x - x_{\\min}) $$\n\n### 任务2：最小侵入式控制器与故障切换策略\n\n目标是合成一个控制器，该控制器选择的输入 $u^\\star$ 在满足推导出的安全条件和物理执行器约束 $u \\in [u_{\\min}, u_{\\max}]$ 的同时，尽可能地接近期望输入 $u_{\\mathrm{des}}$。这可以被表述为一个凸优化问题，具体来说是一个二次规划（QP）问题：\n$$\n\\begin{aligned}\n u^\\star = \\underset{u \\in \\mathbb{R}}{\\text{argmin}}  \\frac{1}{2}(u - u_{\\mathrm{des}})^2 \\\\\n \\text{subject to}  u \\ge -\\alpha(x - x_{\\min}) \\\\\n  u \\ge u_{\\min} \\\\\n  u \\le u_{\\max}\n\\end{aligned}\n$$\n因子 $\\frac{1}{2}$ 是常规写法，不改变解。三个线性不等式约束为控制输入 $u$ 定义了一个可行集。该集合是一个区间 $[L, U]$，其中：\n$$ L = \\max(u_{\\min}, -\\alpha(x - x_{\\min})) $$\n$$ U = u_{\\max} $$\n\n当且仅当可行集非空时，存在可行解，这要求 $L \\le U$。由于给定 $u_{\\min}  u_{\\max}$，可行性检查简化为条件 $-\\alpha(x - x_{\\min}) \\le u_{\\max}$。\n\n**故障可操作（可行）情况：**\n如果 $-\\alpha(x - x_{\\min}) \\le u_{\\max}$，则容许控制集为非空。优化问题简化为在闭区间 $[L, U]$ 内寻找最接近 $u_{\\mathrm{des}}$ 的点。此问题的解析解是 $u_{\\mathrm{des}}$ 在区间 $[L, U]$ 上的投影：\n$$ u^\\star = \\text{proj}_{[L, U]}(u_{\\mathrm{des}}) = \\min(U, \\max(L, u_{\\mathrm{des}})) $$\n该控制器是“最小侵入式”的，因为如果期望输入已满足所有约束，它就等于 $u_{\\mathrm{des}}$。否则，它仅以满足最严格的活动约束（安全条件或执行器限制）所需的最小量偏离 $u_{\\mathrm{des}}$。\n\n**故障安全（不可行）情况：**\n如果 $-\\alpha(x - x_{\\min}) > u_{\\max}$，安全要求需要一个大于最大可能执行器输出的控制输入。可行集为空，没有任何控制输入能保证安全。这是一个故障安全条件。问题指定了一个故障切换策略：选择“最大化 $h(x)$ 的瞬时增量”的控制。由于 $\\dot{h}(x) = u$，我们必须选择使 $u$ 最大化的控制 $u \\in [u_{\\min}, u_{\\max}]$。该控制为：\n$$ u^\\star = u_{\\max} $$\n这个动作代表了系统尽最大努力向安全集移动，尽管在这一瞬间安全条件在技术上被违反了。当这种情况发生时，必须有一个标志指示安全约束未被满足。\n\n### 任务3：实现逻辑\n\n用于计算控制输入 $u^\\star$ 和安全标志的算法，使用指定的$\\mathcal{K}$类函数 $\\alpha(s) = ks$ 来实现任务2中的逻辑。\n\n对于给定的状态 $x$ 和期望控制 $u_{\\mathrm{des}}$，以及参数 $k$、$x_{\\min}$、$u_{\\min}$ 和 $u_{\\max}$：\n1.  计算强制执行安全的控制下界，我们将其表示为 $u_{\\text{safe-min}}$：\n    $$ u_{\\text{safe-min}} = -k(x - x_{\\min}) $$\n2.  检查可行性。如果安全约束能被执行器能力范围内的至少一个控制输入满足，即 $u_{\\text{safe-min}} \\le u_{\\max}$，则该约束是可行的。\n    -   **如果 $u_{\\text{safe-min}} > u_{\\max}$ (不可行/故障安全):** 无法保证安全。\n        -   所选控制是故障切换控制：$u^\\star = u_{\\max}$。\n        -   安全条件未满足，因此标志为 `False`。\n    -   **如果 $u_{\\text{safe-min}} \\le u_{\\max}$ (可行/故障可操作):** 可以保证安全。\n        -   控制的下界是执行器限制和安全约束中更严格的一个：$L = \\max(u_{\\min}, u_{\\text{safe-min}})$。\n        -   上界是 $U = u_{\\max}$。\n        -   最优控制 $u^\\star$ 是 $u_{\\mathrm{des}}$ 在区间 $[L, U]$ 上的投影。这可以计算为 $u^\\star = \\min(U, \\max(L, u_{\\mathrm{des}}))$。\n        -   安全条件得到满足，因此标志为 `True`。\n对每个提供的测试用例都实现了此逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are used.\n\ndef solve():\n    \"\"\"\n    Computes a minimally invasive safe controller for a set of test cases.\n    \"\"\"\n    # Define fixed parameters from the problem statement.\n    k = 0.5\n    x_min = 1.0\n    u_min = -2.0\n    u_max = 2.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.5, 0.0),   # Case A\n        (1.0, 0.0),   # Case B\n        (0.8, 0.0),   # Case C\n        (-4.0, 0.0),  # Case D\n        (3.0, -3.0),  # Case E\n    ]\n\n    results = []\n    for x, u_des in test_cases:\n        # Task 1  2: Calculate the safety constraint.\n        # The barrier function is h(x) = x - x_min.\n        # The class-K function is alpha(s) = k*s.\n        # The safety condition is u >= -alpha(h(x)), which means u >= -k*(x - x_min).\n        h_x = x - x_min\n        \n        # This is the minimum control value required to satisfy the CBF inequality.\n        u_safe_min = -k * h_x\n\n        # Task 2: Check for feasibility and apply fail-over policy if needed.\n        # The safety constraint is feasible if u_safe_min = u_max.\n        if u_safe_min > u_max:\n            # Infeasible case (Fail-Safe): The safety constraint cannot be satisfied.\n            # Apply fail-over policy: use the control that maximizes dh/dt = u.\n            u_star = u_max\n            is_safe = False\n        else:\n            # Feasible case (Fail-Operational): Synthesize the minimally invasive controller.\n            # The control must be in the interval [L, U], where:\n            # L = max(u_min, u_safe_min)\n            # U = u_max\n            # The solution u_star is the projection of u_des onto [L, U].\n            \n            # Using base Python min/max for clarity. This is equivalent to np.clip.\n            # Combine all lower bounds.\n            lower_bound = max(u_min, u_safe_min)\n            \n            # Project u_des onto the feasible interval [lower_bound, u_max].\n            # 1. Clamp u_des from below.\n            u_clamped_low = max(u_des, lower_bound)\n            # 2. Clamp the result from above.\n            u_star = min(u_clamped_low, u_max)\n            \n            is_safe = True\n\n        results.append([u_star, is_safe])\n\n    # Final print statement in the exact required format.\n    # The str() of a list like [1.0, True] is '[1.0, True]', which matches\n    # the required sub-format [u_star, flag].\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}