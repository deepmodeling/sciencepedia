## 引言
随着网络物理系统（CPS）和[数字孪生](@entry_id:171650)（DT）等智能系统的复杂性与自主性日益增长，确保其在动态、不确定的真实世界中安全可靠地运行，已成为一项严峻挑战。传统的离线验证技术，如[模型检测](@entry_id:150498)和测试，尽管强大，但在面对[状态空间爆炸](@entry_id:1132298)、模型与现实不一致、以及覆盖范围有限等问题时常常力不从心。这凸显了在系统运行时进行持续监控与验证的迫切需求，即[运行时验证](@entry_id:1131151)与监控（Runtime Verification and Monitoring）。

本文旨在系统性地介绍[运行时验证](@entry_id:1131151)与监控的核心知识体系，弥合理论与实践之间的鸿沟。通过本文的学习，读者将掌握如何利用形式化方法来精确定义和在线检查复杂系统的行为，即便是在存在噪声、延迟和[资源限制](@entry_id:192963)的真实环境下。

为实现这一目标，本文将分为三个核心章节：
- **第一章：原理与机制** 将深入剖明[运行时验证](@entry_id:1131151)的基础，区分其与相关技术的范畴，详细介绍用于描述系统行为的规范语言（如LTL和STL），并探讨从规范到监视器的实现机制，以及在实际应用中面临的同步、不确定性与分布式等挑战。
- **第二章：应用与跨学科连接** 将展示这些原理在网络物理系统、[数字孪生](@entry_id:171650)、安全工程、网络安全及系统资源管理等领域的广泛应用，揭示其作为连接[形式化方法](@entry_id:1125241)、控制理论与软件工程的桥梁作用。
- **第三章：动手实践** 将通过一系列精心设计的问题，引导读者将理论知识应用于解决具体的监控算法设计和鲁棒性分析问题，从而巩固和深化理解。

现在，让我们从[运行时验证](@entry_id:1131151)与监控的核心原理与机制开始，为构建更可信赖的智能系统奠定坚实的基础。

## 原理与机制

在介绍性章节之后，我们现在深入探讨[运行时验证](@entry_id:1131151)与监控的核心原理与机制。本章将系统性地阐述[运行时验证](@entry_id:1131151)的基础概念、用于描述系统行为的规范语言、从规范到监视器的转换过程，以及在网络物理系统（Cyber-Physical Systems, CPS）和[数字孪生](@entry_id:171650)（Digital Twins, DT）的实际应用中面临的关键挑战。最后，我们将介绍一些前沿的监控范式，包括主动干预和概率性方法。

### [运行时验证](@entry_id:1131151)的基础与范畴

[运行时验证](@entry_id:1131151)（Runtime Verification, RV）是一种在系统运行时，根据其可观测行为来判断系统是否符合预定义规范的轻量级形式化方法。为了精确理解其定位，我们必须将其与另外两种常见的验证技术——模型检测（Model Checking）和测试（Testing）——进行区分。

- **[模型检测](@entry_id:150498)** 是一种离线（offline）的、基于模型的穷尽式验证技术。它需要一个系统的有限状态模型（例如Kripke结构）和一个形式化规范。[模型检测](@entry_id:150498)器会探索模型的所有可能执行路径，以确定是否所有路径都满足规范。因此，它能提供关于模型的 **穷尽性保证**。然而，它分析的是抽象模型而非真实系统，且[状态空间爆炸](@entry_id:1132298)问题限制了其在复杂系统上的应用。

- **测试** 是一种基于样本的验证方法，通常也在系统部署前离线执行。它通过向系统实现提供一组选定的输入，并观察其输出，来检查在这些特定执行下的行为是否符合规范。测试直接在系统实现（或其精确副本）上运行，但它本质上是 **非穷尽的**，其覆盖范围受限于测试用例的数量和质量，因此无法提供完全的正确性保证。

- **[运行时验证](@entry_id:1131151)** 则是一种在线（online）活动。它在系统实际运行时，持续地监控从传感器或日志中获取的、可能不完整的观测序列。RV监视器根据这些有限的执行前缀，判断规范是否已被满足或违反。由于其在线性和基于实际执行的特性，RV的保证是 **有条件的**，即仅针对已观测到的行为。同时，由于传感器和日志的限制，RV通常在 **部分可观测性** 的条件下工作 。

总结来说，这三者在验证时机（在线/离线）、分析对象（模型/实现）和保证强度（穷尽/样本/条件）上各有侧重，形成了互补的关系。

#### 从被动观测到主动保障：[运行时验证](@entry_id:1131151)与[运行时保障](@entry_id:1131148)

[运行时验证](@entry_id:1131151)的核心功能是“验证”——即观测和判断。它是一种被动机制，其输出是关于规范满足情况的论断（verdict），如“满足”、“违反”或“不确定”。然而，在安全关键的CPS中，仅仅检测到违规可能为时已晚。这就引出了一个更进一步的概念：**[运行时保障](@entry_id:1131148)**（Runtime Assurance, RTA）。

**[运行时保障](@entry_id:1131148)** 将被动的监视与主动的控制相结合。它不仅包含一个用于预测和检测不安全趋势的RV监视器，还集成了一个 **安全盾**（safety shield）或安全滤波器。当监视器预测一个由高层自主控制器（如基于AI的规划器）发出的指令可能导致系统进入[不安全状态](@entry_id:756344)时，RTA机制会主动介入，**覆写**（override）该指令，代之以一个经过验证的、保证安全的备用指令。

考虑一个简单的一维[离散时间系统](@entry_id:263935)，其位置 $x_k$ 的演化由下式决定：
$$x_{k+1} = x_k + v_k \Delta t + d_k$$
其中 $v_k$ 是应用的速度指令，$\Delta t$ 是[采样周期](@entry_id:265475)，$d_k$ 是有界扰动，即 $|d_k| \le \bar{d}$。安全不变式要求 $x_k \ge 0$ 对所有 $k$ 成立。

一个RV监视器会观测 $x_k$ 序列并报告是否曾有 $x_k \lt 0$。而一个RTA系统则会做得更多。在每一步 $k$，它会分析高层自主系统请求的指令 $u_k$。为了保证安全，系统必须在最坏情况下（即 $d_k = -\bar{d}$）仍然满足不变式。这意味着任何被应用的指令 $v_k$ 都必须满足：
$$x_k + v_k \Delta t - \bar{d} \ge 0 \quad \iff \quad v_k \ge \frac{\bar{d} - x_k}{\Delta t}$$
这个不等式定义了所有**一步安全指令**的集合。

如果请求的指令 $u_k$ 不满足此条件，即 $x_k + u_k \Delta t - \bar{d} \lt 0$，RTA的安全盾就会介入。一个常见的策略是采用**最小偏离**原则，即选择安全指令集合中离 $u_k$ 最近的指令作为替代。在此例中，替代指令 $v_k'$ 将是：
$$v_k' = \max\left\{ u_k, \frac{\bar{d} - x_k}{\Delta t} \right\}$$
这个过程确保了无论高层控制器如何决策，最终施加于物理系统的指令始终是安全的。因此，RV是“诊断”，而RTA是“诊断并治疗” 。

### 规范语言：描述期望行为

要进行[运行时验证](@entry_id:1131151)，首先需要一种精确、无歧义的方式来描述我们关心的系统属性。时间逻辑（Temporal Logic）为此提供了强大的形式化工具。

#### [线性时间逻辑 (LTL)](@entry_id:1127293)

**线性[时间逻辑](@entry_id:181558)**（Linear Temporal Logic, LTL）是一种用于描述[离散时间系统](@entry_id:263935)上执行路径（迹）属性的语言。它非常适合于描述[采样数据系统](@entry_id:1131192)或事件序列的属性。LTL的语法建立在原子命题（如 `p`, `q`）和布尔连接词（$\neg$, $\lor$）之上，并引入了时间算子：

- $X\,\varphi$ (Next): $\varphi$ 在下一个时间步成立。
- $\varphi_1 \,U\, \varphi_2$ (Until): $\varphi_1$ 必须一直成立，直到 $\varphi_2$ 成立。

由这些基本算子可以派生出更直观的算子：

- $F\,\varphi$ (Finally/Eventually): $\varphi$ 最终会在未来的某个时间步成立（等价于 $\top \,U\, \varphi$）。
- $G\,\varphi$ (Globally/Always): $\varphi$ 在未来的所有时间步都成立（等价于 $\neg F \neg \varphi$）。

LTL的语义是在一个离散时间点序列（迹）上定义的。例如，在一个迹 $\pi$ 的第 $i$ 个时间点，$( \pi, i ) \models \varphi_1 \,U\, \varphi_2$ 当且仅当存在一个未来的时间点 $j \ge i$，使得 $(\pi, j) \models \varphi_2$，并且对于所有在 $i$ 和 $j$ 之间的时间点 $k$（$i \le k \lt j$），都有 $(\pi, k) \models \varphi_1$。LTL的算子是**无界**的，它们不涉及具体的度量时间。

#### 度量[时间逻辑](@entry_id:181558) (MTL) 与 信号[时间逻辑](@entry_id:181558) (STL)

对于CPS而言，时间不仅仅是[序关系](@entry_id:138937)，更是物理量。**度量[时间逻辑](@entry_id:181558)**（Metric Temporal Logic, MTL）通过为时间算子增加度量时间约束来扩展LTL。例如，$U$ 算子被替换为 $U_I$，其中 $I$ 是一个时间区间。$\varphi_1 \,U_I\, \varphi_2$ 意味着 $\varphi_1$ 必须成立，直到 $\varphi_2$ 在由 $I$ 指定的未来时间区间内成立。例如，$G_{[0, 5]} (p)$ 表示命题 $p$ 在从现在开始的5个时间单位内必须始终为真。MTL因此能够描述具有[实时约束](@entry_id:754130)的属性，并且其语义既可以定义在离散时间上，也可以定义在**稠密时间**（如 $\mathbb{R}_{\ge 0}$）上。

**信号时间逻辑**（Signal Temporal Logic, STL）是MTL的进一步发展，专为描述实值信号（如温度、电压）的属性而设计。其关键创新在于引入了**定量语义**（quantitative semantics），也称为**鲁棒性语义**（robustness semantics）。

传统的时间逻辑（包括LTL和MTL）提供的是布尔语义：一个属性对于一个给定的迹要么为真，要么为假。STL则更进一步，它计算一个实数值 $\rho$，称为**鲁棒度**，来衡量一个信号在多大程度上满足或违反一个规范。

- $\rho > 0$: 信号满足规范，$\rho$ 的值表示满足的“裕度”。值越大，信号离违反规范的边界越远。
- $\rho  0$: 信号违反规范，$\rho$ 的绝对值表示违反的“严重程度”。
- $\rho = 0$: 信号恰好在满足与违反的边界上。

STL的鲁棒性语义是[递归定义](@entry_id:266613)的。对于一个形如 $h(x(t)) \ge 0$ 的原子命题 $\mu$，其鲁棒度就是函数 $h(x(t))$ 的值。布尔连接词被映射为 `min` 和 `max` 运算，而时间算子则被映射为 `inf`（[下确界](@entry_id:140118)）和 `sup`（[上确界](@entry_id:140512)）运算 。

例如，对于一个规范 $\phi = G_{[a,b]} \mu$，其中 $\mu$ 的鲁棒度为 $\rho_\mu(x, t)$，整个规范 $\phi$ 在时刻 $t_0$ 的鲁棒度为：
$$\rho_{\phi}(x, t_0) = \inf_{t' \in [t_0+a, t_0+b]} \rho_\mu(x, t')$$
这表示在指定时间窗口内，信号满足原子命题的“最小裕度”。

**示例：计算STL鲁棒度**
假设一个数字孪生监控一个热力设备的温度 $y(t)$，安全规范要求在时间窗口 $[10, 25]$ 秒内，温度不得超过 $T_{\max} = 415$ K。该规范可写作 $\phi = G_{[10, 25]} p$，其中原子命题 $p$ 为 $y(t) \le 415$，其对应的鲁棒性函数为 $\mu(y(t)) = 415 - y(t)$。

假设测量的温度 $y(t) = x(t) + \eta(t)$，其中 $x(t) = 412 + 1.5\exp(-0.3(t-10)) + 0.8\cos(\frac{\pi}{15}(t-10))$ 是标称温度，而 $|\eta(t)| \le 0.4$ K 是有界噪声。我们需要计算在 $t=0$ 时，考虑最坏情况噪声下的鲁棒度 $\rho(\phi, y, 0)$。

根据定义：
$$\rho(\phi, y, 0) = \inf_{t' \in [10, 25]} (415 - y(t')) = 415 - \sup_{t' \in [10, 25]} y(t')$$
最坏情况是噪声最大化温度，所以 $y(t')$ 的[上确界](@entry_id:140512)是 $x(t')$ 的[上确界](@entry_id:140512)加上噪声界限 $\delta$。
$$\sup_{t' \in [10, 25]} y(t') = \left( \sup_{t' \in [10, 25]} x(t') \right) + 0.4$$
通过分析 $x(t)$ 的导数可以发现，在区间 $[10, 25]$ 上，$x(t)$ 是单调递减的。因此，其最大值出现在 $t=10$ 处，$x(10) = 412 + 1.5 + 0.8 = 414.3$ K。
于是，在最坏情况下，测得的最高温度为 $y_{\max} = 414.3 + 0.4 = 414.7$ K。
最终，鲁棒度为：
$$\rho = 415 - 414.7 = 0.3 \text{ K}$$
这个正值结果表明，即使在最坏的噪[声影](@entry_id:923047)响下，系统仍然安全地运行在规范内，并且距离安全边界的最小裕度是 $0.3$ K 。这种定量信息对于评估系统健康状况和进行[预测性维护](@entry_id:167809)至关重要。

### 从规范到监视器：实现机制

有了形式化的规范，下一步就是构建一个能够根据系统观测来检查该规范的监视器。构建方法取决于规范语言和系统的时间模型。

#### 基于自动机的LTL监视

对于LTL，标准方法是**基于自动机的**。任何一个LTL公式都可以被转换成一个等价的**Büchi自动机**（Büchi Automaton, BA）。Büchi自动机是一种在无限长输入（无限词）上运行的[有限自动机](@entry_id:1124972)，其接受条件定义为：若一条运行路径无限次地访问接受状态集合中的某个状态，则该路径被接受。

一个LTL公式所描述的语言（即所有满足该公式的迹的集合）恰好可以被一个Büchi自动机识别。因此，LTL的[运行时验证](@entry_id:1131151)问题可以转化为：检查系统正在生成的执行迹是否能被相应的Büchi自动机接受。

对于由多个子属性合取（$\land$）构成的复杂LTL规范，例如 $\varphi = \varphi_1 \land \varphi_2$，可以先分别为 $\varphi_1$ 和 $\varphi_2$ 构建Büchi自动机 $\mathcal{A}_1$ 和 $\mathcal{A}_2$，然后通过**乘积构造**（product construction）得到一个识别 $L(\varphi_1) \cap L(\varphi_2)$ 的**广义Büchi自动机**（Generalized Büchi Automaton, GBA）。一个GBA有多个接受状态集，一条运行路径被接受当且仅当它无限次地访问**每一个**接受状态集。随后，这个GBA可以被转换成一个等价的、只有一个接受状态集的标准Büchi自动机。

**示例：监视活动性(Liveness)属性**
考虑一个规范 $\varphi = G(p \rightarrow F q) \land GFr$，它要求“总是，如果 $p$ 发生，则未来某个时候 $q$ 必然发生”并且“$r$ 必须无限频繁地发生”。这两个都是**活动性属性**，它们要求“好的事情”最终会发生。

活动性属性对[运行时验证](@entry_id:1131151)提出了独特的挑战：它们无法在任何有限的执行前缀上被最终证实。例如，对于 $G(p \rightarrow F q)$，在观测到一个 $p$ 之后，我们必须永远等待一个 $q$。只要 $q$ 还没出现，我们就不能断定属性被满足，也不能断定它被违反。

Büchi自动机结构优雅地捕捉了这种无限的“义务”。例如，为 $G(p \rightarrow F q)$ 构建的自动机可能有两个状态：一个“无义务”状态，和一个在观测到 $p$ 但尚未观测到 $q$ 时进入的“等待q”状态。只有当执行能保证它不会永远停留在“等待q”状态（即无限次地返回“无义务”状态）时，该执行才被接受。类似地，为 $GFr$ 构建的自动机需要无限次地访问一个表示“刚刚看到r”的状态。通过乘积构造，我们可以得到一个追踪这两种义务的组合监视器 。

#### 连续信号的抽象

对于STL和稠密时间信号，监视器通常不依赖于自动机，而是作为一种[信号处理算法](@entry_id:201534)来实现。一个核心挑战是如何将连续的、实值的信号**抽象**为离散的事件序列，以便于逻辑处理。

一个简单的抽象方法是阈值检测：当信号 $x(t)$ 超过某个阈值 $\theta$ 时，生成一个事件。然而，如果信号在阈值附近有噪声或振荡，这种方法会导致所谓的**“[抖动](@entry_id:200248)”**（chatter）或**[芝诺现象](@entry_id:274041)**（Zeno phenomenon）——在有限时间内产生无限数量的事件，从而使监视器瘫痪。

为了解决这个问题，通常采用**滞回**（hysteresis）机制，类似于电子学中的[施密特触发器](@entry_id:166597)。该机制使用两个阈值：一个高阈值 $\theta_H$ 和一个低阈值 $\theta_L$ ($\theta_L  \theta_H$)。系统维护一个内部模式（`LOW` 或 `HIGH`）。

- 当系统处于 `LOW` 模式时，它只监测信号是否向上穿越**高阈值** $\theta_H$。一旦穿越，它就生成一个 `UP` 事件，并将模式切换到 `HIGH`。
- 当系统处于 `HIGH` 模式时，它只监测信号是否向下穿越**低阈值** $\theta_L$。一旦穿越，它就生成一个 `DOWN` 事件，并将模式切换到 `LOW`。

通过引入 $\theta_H - \theta_L$ 这个“滞回带”，信号必须在两个阈值之间进行一次完整的穿越才能生成一个新事件，这有效地过滤掉了阈值附近的微[小波](@entry_id:636492)动。只要信号的总变差（total variation）在任何有限时间段内是有限的，这种滞回抽象就能保证生成的事件数量也是有限的 。

### 网络物理系统中的实际挑战

将上述原理应用于真实的CPS和DT时，我们必须面对一系列源于物理世界和计算系统限制的挑战。

#### 监控架构：[同步与异步](@entry_id:170555)

监视器本身也是一段需要消耗计算资源的软件。它如何与被监控的控制任务集成，是一个重要的架构决策，主要有**同步监控**和**异步监控**两种模式。

- **同步监控**：监视代码作为被监控任务（如控制任务）的一部分以内联（inline）方式执行。
  - **优点**：检测延迟极低。一旦数据可用，监视器可立即执行。
  - **缺点**：增加了主任务的最坏情况执行时间（WCET），从而可能增加控制回路的响应时间[抖动](@entry_id:200248)（jitter），对控制性能产生**扰动**。

- **异步监控**：监视器作为一个独立的任务或线程运行。主任务仅负责将数据（非阻塞地）记录到一个共享缓冲区，由监视任务定期取出并处理。
  - **优点**：对主任务的扰动极小，有助于保持控制性能的确定性。
  - **缺点**：引入了额外的检测延迟。数据从产生到被监视器处理，最坏情况下可能需要等待一个监视任务的调度周期。

选择哪种架构取决于系统的具体需求。对于具有极快不稳定动态的系统，其安全边界可能在毫秒甚至微秒内被突破。在这种情况下，即使同步监控会引入[抖动](@entry_id:200248)，其低延迟的特性也可能是唯一可行的选择 [@problem_e.g., 4242409]。反之，如果控制性能对[抖动](@entry_id:200248)非常敏感，而安全裕度较大，异步监控则是更优的选择。

#### 不确定性下的监视：[可靠性与完备性](@entry_id:148267)

真实的CPS传感器测量总是伴随着噪声、延迟，并且采样是离散的。这些不完美性直接影响监视器的可靠性。我们用两个关键指标来评估监视器的质量：

- **可靠性（Soundness）**：如果监视器报告“违规”，那么系统是否真的发生了违规？一个可靠的监视器**不会产生误报（False Positives）**。
- **完备性（Completeness）**：如果系统真的发生了违规，监视器是否总能检测到？一个完备的监视器**不会产生漏报（False Negatives）**。

在存在噪声、延迟和离散采样的情况下，实现绝对的可靠性和完备性往往是不可能的，必须在两者之间做出权衡。通常，通过为监视器的决策阈值增加一个**安全裕度**（margin）来保证可靠性。

例如，若安全规范为 $x(t) \ge c$，而测量值 $y_k = x(t_k - \delta_k) + n_k$ 受到有界延迟 $\delta_k \in [0, \Delta]$、有界噪声 $|n_k| \le \epsilon$ 的影响，且信号变化率有界 $| \dot{x}(t) | \le B$。为了保证可靠性，监视器不能简单地在 $y_k  c$ 时报警。我们需要考虑最坏情况：一个恰好满足规范的信号（例如 $x(t)$ 始终在 $c$ 附近）可能产生的最低测量值是多少。这个最低值大约是 $c - B\Delta - \epsilon$。因此，为了避免误报，监视器只有在测量值 $y_k$ 低于某个更保守的阈值 $c - M$ 时才能报警，其中裕度 $M$ 必须足够大以覆盖所有不确定性，即 $M \ge B\Delta + \epsilon$。

反过来，这种保守性可能会损害完备性。一个真实的、但非常“浅”的违规（$x(t)$ 仅略低于 $c$）可能被正向的噪声所掩盖，导致测量值仍在报警阈值之上，从而造成漏报。因此，在设计监视器时，必须明确其在特定不确定性模型下的[可靠性与完备性](@entry_id:148267)保证 。

#### 分布式监控

许多大型CPS，如电网或车队，本质上是分布式的。对这类系统进行全局属性的监控，例如“所有车辆之间的距离都大于安全阈值”，引入了新的挑战：**时钟偏斜**（clock skew）和**通信延迟**。

每个分布式组件都有自己的本地时钟，这些时钟与真实时间之间存在有界但不确定的偏差（偏斜 $\epsilon$）。组件将带有本地时间戳的观测数据发送给一个中央监视器，这个过程又有有界的通信延迟 $\Delta$。

当中央监视器想要评估一个在真实时间 $t$ 的全局谓词 $\Phi(x_1(t), \dots, x_n(t))$ 时，它面临一个问题：它无法获得所有组件在**完全相同**真实时间 $t$ 的状态。由于时钟偏斜，一组带有相同时间戳的观测数据实际上可能来自一个跨度达 $2\epsilon$ 的真实时间窗口。

为了做出可靠的判断，监视器必须采取一种保守的方法。它需要考虑在由[时钟偏斜](@entry_id:177738)定义的不确定性窗口内所有可能的状态组合。这通常导致一个**[三值逻辑](@entry_id:153539)**的结论：

- **真（$\top$）**: 如果对于所有与时钟和延迟模型一致的可能状态组合，全局属性都成立。
- **假（$\perp$）**: 如果对于所有可能的组合，属性都不成立。
- **未知（$\mathsf{Unknown}$）**: 如果属性的真假取决于具体但未知的时钟偏斜和延迟。

此外，监视器必须等到收集了足够的数据才能做出判断。要评估真实时间 $t$ 的属性，它必须等待接收到所有可能影响该评估的观测数据。这包括在真实时间 $t+\epsilon$ 发生、带有相应时间戳的事件，该事件最晚会在真实时间 $t+\epsilon+\Delta$ 到达。这是分布式监控中检测延迟的一个基本下界 。

### 前沿范式：概率性[运行时验证](@entry_id:1131151)

最后，并非所有系统属性都是确定性的。在许多应用中，我们更关心系统行为的统计特性，例如“安全属性在99%的时间里都得到满足”。**概率性[运行时验证](@entry_id:1131151)**（Probabilistic Runtime Verification）将[统计假设检验](@entry_id:274987)的思想引入了监控领域。

其基本框架如下：我们将每次观测（例如，在一个时间窗口内属性是否满足）看作一次**[伯努利试验](@entry_id:268355)**，其成功概率为未知的 $p$。我们的目标是判断 $p$ 是否满足某个要求，例如 $p \ge \theta$。这是一个经典的统计问题。

我们可以设置一个假设检验，其中[原假设](@entry_id:265441) $H_0$ 为 $p \le \theta - \delta$，[备择假设](@entry_id:167270) $H_1$ 为 $p \ge \theta + \delta$。这里，$\delta$ 定义了一个“无关紧要区域”，以避免在边界 $\theta$ 附近做出困难的决策。我们希望以受控的[I型错误](@entry_id:163360)率 $\alpha$（误报，即当 $H_0$ 为真时拒绝 $H_0$）和[II型错误](@entry_id:173350)率 $\beta$（漏报，即当 $H_1$ 为真时未能拒绝 $H_0$）来做出决策。

**[序贯概率比检验](@entry_id:176474)**（Sequential Probability Ratio Test, SPRT）是解决此类问题的有效工具。与固定样本数量的检验不同，SPRT在每次观测后都会更新一个[对数似然比](@entry_id:274622)统计量。该统计量与两个阈值 $A$ 和 $B$（由 $\alpha$ 和 $\beta$ 决定）进行比较：

- 如果统计量超过上阈值 $A$，则停止并接受 $H_1$。
- 如果统计量低于下阈值 $B$，则停止并接受 $H_0$。
- 如果统计量在两者之间，则继续采样。

SPRT在达到相同错误率保证的情况下，平均所需的样本数量是最优的，这使其非常适合需要快速决策的在线监控场景 。

本章系统地梳理了[运行时验证](@entry_id:1131151)与监控的核心原理和机制，从基本定义出发，探讨了规范语言、监视器实现技术，并深入分析了在真实CPS环境下由计算架构、物理不确定性和分布式特性带来的挑战。最后，通过引入[运行时保障](@entry_id:1131148)和概率性验证等前沿范式，我们勾勒出该领域从被动观测向主动干预和统计推理演进的图景。