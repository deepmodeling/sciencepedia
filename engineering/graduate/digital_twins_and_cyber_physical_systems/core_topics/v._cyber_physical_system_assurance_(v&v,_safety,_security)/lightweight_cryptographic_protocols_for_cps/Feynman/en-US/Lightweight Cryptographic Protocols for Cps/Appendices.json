{
    "hands_on_practices": [
        {
            "introduction": "Before deploying a cryptographic protocol in a resource-constrained Cyber-Physical System (CPS), it is essential to quantify its performance and energy footprint. This exercise demonstrates how to translate the computational cost of a lightweight block cipher, measured in CPU cycles, into critical system-level metrics: data throughput and energy per bit. By working from first principles, you will gain the skills to evaluate whether a given algorithm is feasible for a specific hardware platform and its operational constraints, a fundamental step in designing efficient and sustainable CPS devices .",
            "id": "4229436",
            "problem": "A Cyber-Physical System (CPS) edge node uses the Lightweight Block Cipher (LBC) PRESENT with an $80$-bit key to encrypt telemetry, and its Digital Twin (DT) must predict performance and energy costs to evaluate protocol feasibility for real-time communication. The node is built on a Texas Instruments MSP430 Microcontroller (MSP430) clocked at $16 \\text{ MHz}$ and executes the software implementation of PRESENT-80 using $2400$ Central Processing Unit (CPU) cycles per $64$-bit block. The device operates at a supply of $3.3 \\text{ V}$ and draws $5 \\text{ mA}$ during encryption. Assume a steady-state regime in which the CPU is fully utilized by encryption, external input/output overheads are negligible, all blocks are processed back-to-back without stalls, and the supply current remains constant during operation.\n\nStarting from core definitions of time, rate, and energy, derive expressions for the throughput in bits per second and the energy per bit in joules per bit for this implementation, and then evaluate them numerically using the given parameters. Express the throughput in bits per second and the energy per bit in nanojoules per bit. Round both quantities to four significant figures.",
            "solution": "The problem is well-posed and scientifically grounded, providing all necessary parameters to derive and calculate the required performance metrics. We can proceed with the solution.\n\nThe problem requires the derivation and calculation of two key performance metrics for a cryptographic implementation on an embedded device: throughput and energy per bit. We will start from the core definitions of time, rate, power, and energy, and use the provided parameters to derive the required expressions.\n\nLet the following parameters be defined based on the givens:\n- Clock frequency: $f_{clk} = 16 \\text{ MHz} = 16 \\times 10^6 \\text{ s}^{-1}$\n- CPU cycles per block: $C_{block} = 2400$\n- Block size: $B_{size} = 64 \\text{ bits}$\n- Supply voltage: $V_{DD} = 3.3 \\text{ V}$\n- Supply current: $I_{DD} = 5 \\text{ mA} = 5 \\times 10^{-3} \\text{ A}$\n\nFirst, we derive the expression for throughput, denoted by $R$.\nThe time required to process a single block of data, $T_{block}$, is determined by the number of CPU cycles needed for the operation, $C_{block}$, and the CPU's clock frequency, $f_{clk}$. The relationship is:\n$$T_{block} = \\frac{C_{block}}{f_{clk}}$$\nThroughput, $R$, is defined as the number of bits processed per unit time. Under the assumption of continuous, back-to-back block processing, this is the block size in bits, $B_{size}$, divided by the time to process one block, $T_{block}$.\n$$R = \\frac{B_{size}}{T_{block}}$$\nSubstituting the expression for $T_{block}$ gives the general formula for throughput:\n$$R = \\frac{B_{size}}{\\left( \\frac{C_{block}}{f_{clk}} \\right)} = \\frac{B_{size} \\cdot f_{clk}}{C_{block}}$$\nNext, we derive the expression for the energy consumed per bit, denoted by $E_{bit}$.\nThe electrical power, $P$, consumed by the device during encryption is the product of the supply voltage, $V_{DD}$, and the supply current, $I_{DD}$. The problem states that the current is constant during this operation.\n$$P = V_{DD} \\cdot I_{DD}$$\nThe energy consumed to encrypt a single block, $E_{block}$, is the power multiplied by the time duration of the operation, which is $T_{block}$.\n$$E_{block} = P \\cdot T_{block} = (V_{DD} \\cdot I_{DD}) \\cdot \\left( \\frac{C_{block}}{f_{clk}} \\right)$$\nThe energy per bit, $E_{bit}$, is then the energy per block divided by the number of bits in a block, $B_{size}$.\n$$E_{bit} = \\frac{E_{block}}{B_{size}} = \\frac{V_{DD} \\cdot I_{DD} \\cdot C_{block}}{B_{size} \\cdot f_{clk}}$$\nThis expression for $E_{bit}$ is consistent with the alternative derivation as the ratio of power to throughput, $E_{bit} = \\frac{P}{R}$.\n\nNow, we substitute the given numerical values into the derived expressions to evaluate them.\nFor the throughput, $R$:\n$$R = \\frac{64 \\text{ bits} \\cdot (16 \\times 10^6 \\text{ s}^{-1})}{2400} = \\frac{1024 \\times 10^6}{2400} \\text{ bps} \\approx 426666.67 \\text{ bps}$$\nThe problem requires rounding to four significant figures.\n$$R \\approx 4.267 \\times 10^5 \\text{ bps}$$\n\nFor the energy per bit, $E_{bit}$:\n$$E_{bit} = \\frac{(3.3 \\text{ V}) \\cdot (5 \\times 10^{-3} \\text{ A}) \\cdot 2400}{64 \\cdot (16 \\times 10^6 \\text{ s}^{-1})}$$\n$$E_{bit} = \\frac{39.6 \\text{ J}}{1024 \\times 10^6 \\text{ bits}} \\approx 3.8671875 \\times 10^{-8} \\frac{\\text{J}}{\\text{bit}}$$\nThe problem requires the answer in nanojoules per bit (nJ/bit). Since $1 \\text{ J} = 10^9 \\text{ nJ}$, we convert the units:\n$$E_{bit} \\approx (3.8671875 \\times 10^{-8} \\frac{\\text{J}}{\\text{bit}}) \\cdot (10^9 \\frac{\\text{nJ}}{\\text{J}}) = 38.671875 \\frac{\\text{nJ}}{\\text{bit}}$$\nRounding to four significant figures, the energy per bit is:\n$$E_{bit} \\approx 38.67 \\frac{\\text{nJ}}{\\text{bit}}$$\nThe two final numerical values are the throughput in bits per second and the energy per bit in nanojoules per bit, rounded to four significant figures.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4.267 \\times 10^5 & 38.67\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Beyond raw throughput, many CPS applications depend on predictable, low-latency communication to maintain stability and responsiveness. This practice explores how to calculate the end-to-end cryptographic latency for modern Authenticated Encryption with Associated Data (AEAD) schemes and assess their suitability against a firm real-time deadline. By comparing two leading lightweight algorithms, you will learn to analyze the direct impact of cryptographic choice on the timing-critical operations of a CPS .",
            "id": "4229443",
            "problem": "In a Cyber-Physical System (CPS) with a Digital Twin, a $128$-byte sensor payload must be protected using Authenticated Encryption with Associated Data (AEAD) before being processed for state estimation and control. Consider two lightweight AEAD candidates: Ascon-$128$a and TinyJAMBU. A single encryption or decryption operation has been empirically measured to incur a processing cost that scales linearly with payload length, with per-byte cycle counts of $20$ cycles/byte for Ascon-$128$a and $12$ cycles/byte for TinyJAMBU. The computation is performed on a microcontroller unit (MCU) clocked at $32 \\text{ MHz}$. The end-to-end cryptographic latency is defined as the sum of the sender-side encryption latency and the receiver-side decryption latency, executed sequentially on identical MCUs, and communication and I/O latencies are ignored.\n\nStarting from first principles, namely that the time to execute a computation of $N$ cycles on a processor with clock frequency $f$ is $N/f$, and that the total cycles for a linear per-byte cost is the per-byte cycles multiplied by the payload length, derive the end-to-end cryptographic latency for each algorithm. Then, compute the tightest margin with respect to a real-time bound of $5 \\text{ ms}$, defined as the bound minus the maximum of the two end-to-end latencies.\n\nExpress the end-to-end latencies and the bound margin in milliseconds, and provide the final answer as a row matrix containing $\\big[$Ascon-$128$a end-to-end latency, TinyJAMBU end-to-end latency, minimum margin relative to $5 \\text{ ms}\\big]$. Round your final answer to four significant figures.",
            "solution": "The problem is deemed valid as it is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The scenario presented is a standard problem in embedded systems and applied cryptography, and the provided values are realistic.\n\nThe solution proceeds by applying the first principles provided. Let $L$ be the sensor payload length, $f$ be the clock frequency of the microcontroller unit (MCU), and $C_{byte}$ be the per-byte processing cost in cycles/byte for a given algorithm.\n\nThe givens are:\nPayload length, $L = 128$ bytes.\nMCU clock frequency, $f = 32 \\text{ MHz} = 32 \\times 10^6 \\text{ Hz}$.\nPer-byte cost for Ascon-$128$a, $C_{Ascon} = 20$ cycles/byte.\nPer-byte cost for TinyJAMBU, $C_{Tiny} = 12$ cycles/byte.\nReal-time bound, $T_{bound} = 5 \\text{ ms} = 5 \\times 10^{-3} \\text{ s}$.\n\nFrom first principles, the total number of cycles, $N$, required for a single cryptographic operation (encryption or decryption) on a payload of length $L$ is given by the linear cost model:\n$$N = C_{byte} \\times L$$\nThe time taken for this operation, $T_{op}$, is the total number of cycles divided by the clock frequency:\n$$T_{op} = \\frac{N}{f} = \\frac{C_{byte} \\times L}{f}$$\nThe end-to-end cryptographic latency, $T_{e2e}$, is defined as the sum of the sender-side encryption latency and the receiver-side decryption latency. Since the encryption and decryption operations have a symmetric cost, this is twice the time for a single operation:\n$$T_{e2e} = 2 \\times T_{op} = 2 \\times \\frac{C_{byte} \\times L}{f}$$\n\nWe now derive the end-to-end latency for each algorithm.\n\nFor Ascon-$128$a:\nThe total cycles for one operation are:\n$$N_{Ascon} = C_{Ascon} \\times L = 20 \\frac{\\text{cycles}}{\\text{byte}} \\times 128 \\text{ bytes} = 2560 \\text{ cycles}$$\nThe end-to-end latency for Ascon-$128$a is:\n$$T_{e2e, Ascon} = 2 \\times \\frac{N_{Ascon}}{f} = 2 \\times \\frac{2560 \\text{ cycles}}{32 \\times 10^6 \\text{ cycles/s}} = \\frac{5120}{32 \\times 10^6} \\text{ s} = 160 \\times 10^{-6} \\text{ s}$$\nConverting this to milliseconds:\n$$T_{e2e, Ascon} = 160 \\times 10^{-6} \\text{ s} \\times \\frac{1000 \\text{ ms}}{1 \\text{ s}} = 0.16 \\text{ ms}$$\n\nFor TinyJAMBU:\nThe total cycles for one operation are:\n$$N_{Tiny} = C_{Tiny} \\times L = 12 \\frac{\\text{cycles}}{\\text{byte}} \\times 128 \\text{ bytes} = 1536 \\text{ cycles}$$\nThe end-to-end latency for TinyJAMBU is:\n$$T_{e2e, Tiny} = 2 \\times \\frac{N_{Tiny}}{f} = 2 \\times \\frac{1536 \\text{ cycles}}{32 \\times 10^6 \\text{ cycles/s}} = \\frac{3072}{32 \\times 10^6} \\text{ s} = 96 \\times 10^{-6} \\text{ s}$$\nConverting this to milliseconds:\n$$T_{e2e, Tiny} = 96 \\times 10^{-6} \\text{ s} \\times \\frac{1000 \\text{ ms}}{1 \\text{ s}} = 0.096 \\text{ ms}$$\n\nNext, we compute the tightest margin with respect to the real-time bound. This is defined as the bound minus the maximum of the two end-to-end latencies.\nFirst, determine the maximum latency, $T_{max}$:\n$$T_{max} = \\max(T_{e2e, Ascon}, T_{e2e, Tiny}) = \\max(0.16 \\text{ ms}, 0.096 \\text{ ms}) = 0.16 \\text{ ms}$$\nThe margin, $M$, is then calculated as:\n$$M = T_{bound} - T_{max} = 5 \\text{ ms} - 0.16 \\text{ ms} = 4.84 \\text{ ms}$$\n\nThe problem requires the final answer to be rounded to four significant figures.\nThe Ascon-$128$a latency is $0.16 \\text{ ms}$, which becomes $0.1600 \\text{ ms}$.\nThe TinyJAMBU latency is $0.096 \\text{ ms}$, which becomes $0.09600 \\text{ ms}$.\nThe margin is $4.84 \\text{ ms}$, which becomes $4.840 \\text{ ms}$.\n\nThe results are presented as a row matrix: $\\big[$Ascon-$128$a latency, TinyJAMBU latency, margin$\\big]$.\nThe calculated values are $0.1600 \\text{ ms}$, $0.09600 \\text{ ms}$, and $4.840 \\text{ ms}$, respectively.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.1600 & 0.09600 & 4.840\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While performance metrics like speed and energy are critical, the primary purpose of cryptography is to provide security guarantees. This hands-on problem shifts focus to the probabilistic foundations of security by analyzing the collision resistance of a lightweight hash function. Using the principles of the classic birthday problem, you will derive the probability of two different inputs producing the same hash output, a crucial analysis for ensuring the reliability of applications like telemetry deduplication in a digital twin architecture .",
            "id": "4229400",
            "problem": "A Cyber-Physical System (CPS) telemetry pipeline for a digital twin uses the lightweight hash function PHOTON-$256$ to deduplicate sensor frames. Each telemetry frame is hashed, and a match in the hash table triggers deduplication. Assume that PHOTON-$256$ outputs are modeled as uniformly random and independent over a space of size $2^{256}$, consistent with the random oracle idealization. In a given collection interval, exactly $q = 2^{20}$ frames are hashed. Using the birthday bound as the foundational fact about collision probabilities for random functions, derive from first principles the collision probability after $q$ independent queries to a function with $n=256$-bit outputs. Then evaluate it for the given $q$ and $n$, expressing the final result as a single closed-form expression in powers of $2$. Finally, briefly discuss, based on your derivation, the implications for CPS telemetry deduplication reliability in an advanced graduate-level systems context. Provide only the collision probability as your final numerical expression. Do not approximate numerically; no rounding is required and no units are needed.",
            "solution": "The problem statement has been evaluated and is deemed valid. It is scientifically grounded in the principles of cryptography and probability theory, well-posed with sufficient and consistent information, and objective in its formulation. We may therefore proceed with the solution.\n\nThe problem requires the derivation and evaluation of the collision probability for a hash function. We are given the number of hashed items, $q$, and the size of the hash function's output space, $N$.\n\nThe specific parameters are:\n- Number of frames hashed, $q = 2^{20}$.\n- The hash function is PHOTON-$256$, which has an output of $n=256$ bits. The size of the codomain, or output space, is therefore $N = 2^{n} = 2^{256}$.\n- The hash function is modeled as a random oracle, meaning each of the $q$ outputs is an independent and uniformly random selection from the $N$ possible values.\n\nA collision occurs if at least two of the $q$ hashed frames produce the same output value. Let $P(C)$ denote the probability of such a collision. It is more straightforward to first calculate the complementary probability, $P(C')$, which is the probability of no collisions occurring. The collision probability is then $P(C) = 1 - P(C')$.\n\nFor no collisions to occur, all $q$ hash outputs must be distinct. Let us consider the sequence of $q$ hash outputs, $h_1, h_2, \\ldots, h_q$.\n- The first hash, $h_1$, can be any of the $N$ values.\n- For the second hash, $h_2$, to be different from $h_1$, it must be one of the remaining $N-1$ values. The probability of this is $\\frac{N-1}{N}$.\n- For the third hash, $h_3$, to be different from both $h_1$ and $h_2$ (which are already distinct), it must be one of the remaining $N-2$ values. The probability of this is $\\frac{N-2}{N}$.\n- This continues until the $q$-th hash, $h_q$, which must be different from the previous $q-1$ distinct hashes. It must be one of the remaining $N-(q-1)$ values. The probability is $\\frac{N-q+1}{N}$.\n\nThe total probability of no collisions, $P(C')$, is the product of these individual probabilities, as the hash outputs are independent:\n$$P(C') = \\frac{N}{N} \\times \\frac{N-1}{N} \\times \\frac{N-2}{N} \\times \\cdots \\times \\frac{N-q+1}{N}$$\nThis can be written in product notation as:\n$$P(C') = \\prod_{k=0}^{q-1} \\frac{N-k}{N} = \\prod_{k=0}^{q-1} \\left(1 - \\frac{k}{N}\\right)$$\nThis is the exact first-principles derivation of the no-collision probability. The collision probability is therefore:\n$$P(C) = 1 - \\prod_{k=0}^{q-1} \\left(1 - \\frac{k}{N}\\right)$$\n\nThe problem statement refers to the \"birthday bound as the foundational fact\". This indicates the use of the standard approximation for this probability, which is extremely accurate when $q \\ll N$. The approximation hinges on the Taylor series for the exponential function, where for small $x$, $1-x \\approx e^{-x}$. Applying this to each term in the product:\n$$P(C') = \\prod_{k=0}^{q-1} \\left(1 - \\frac{k}{N}\\right) \\approx \\prod_{k=0}^{q-1} \\exp\\left(-\\frac{k}{N}\\right) = \\exp\\left(-\\sum_{k=0}^{q-1} \\frac{k}{N}\\right)$$\nThe sum in the exponent is the sum of an arithmetic series:\n$$\\sum_{k=0}^{q-1} k = \\frac{(q-1)q}{2}$$\nSubstituting this back gives the approximation for the no-collision probability:\n$$P(C') \\approx \\exp\\left(-\\frac{q(q-1)}{2N}\\right)$$\nAnd thus the collision probability is:\n$$P(C) \\approx 1 - \\exp\\left(-\\frac{q(q-1)}{2N}\\right)$$\nFor cases where $q$ is large, the term $q(q-1)$ is very close to $q^2$. The problem asks for the result to be expressed in powers of $2$, which suggests a final form without terms like $2^{20}-1$. This implies that the approximation $q(q-1) \\approx q^2$ is intended. The relative error introduced by this is $\\frac{q^2 - q(q-1)}{q^2} = \\frac{q}{q^2} = \\frac{1}{q} = 2^{-20}$, which is negligible. This leads to the canonical birthday problem approximation:\n$$P(C) \\approx 1 - \\exp\\left(-\\frac{q^2}{2N}\\right)$$\nWe now evaluate this expression using the given values $q = 2^{20}$ and $N = 2^{256}$.\n$$P(C) \\approx 1 - \\exp\\left(-\\frac{(2^{20})^2}{2 \\cdot 2^{256}}\\right)$$\nFirst, we simplify the exponent:\n$$\\frac{(2^{20})^2}{2 \\cdot 2^{256}} = \\frac{2^{40}}{2^1 \\cdot 2^{256}} = \\frac{2^{40}}{2^{257}} = 2^{40-257} = 2^{-217}$$\nSubstituting this back into the probability expression gives the final closed-form result:\n$$P(C) \\approx 1 - \\exp(-2^{-217})$$\n\nFinally, a brief discussion on the implications for CPS telemetry deduplication reliability is warranted.\nThe calculated collision probability, $P(C) \\approx 1 - \\exp(-2^{-217})$, is an extraordinarily small number. For a small positive value $x$, the approximation $1-e^{-x} \\approx x$ holds. Thus, $P(C) \\approx 2^{-217}$. A collision in this context means that two distinct sensor frames are incorrectly identified as identical and the second one is discarded, resulting in data loss. The reliability of the deduplication component is inversely related to this probability. A value of $2^{-217}$ is so microscopically small that it is orders of magnitude lower than any other conceivable source of error in a cyber-physical system, such as hardware failures, network data corruption, or software bugs.\nFrom an advanced systems perspective, this result confirms that using a 256-bit cryptographic hash function for a workload of $2^{20}$ items provides a margin of safety against accidental collisions that is far beyond any practical requirement. The choice of a cryptographic-grade function like PHOTON also provides inherent resistance against adversarial attacks (e.g., second-preimage attacks) that would be a concern in a security-conscious application. For the stated purpose of simple deduplication, the system's reliability bottleneck will lie elsewhere; the hash-based mechanism is, for all practical purposes, perfectly reliable.",
            "answer": "$$\\boxed{1 - \\exp(-2^{-217})}$$"
        }
    ]
}