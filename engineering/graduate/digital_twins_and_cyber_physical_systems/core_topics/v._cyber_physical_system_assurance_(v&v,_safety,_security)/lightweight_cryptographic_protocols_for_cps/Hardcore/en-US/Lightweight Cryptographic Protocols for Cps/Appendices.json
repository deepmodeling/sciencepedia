{
    "hands_on_practices": [
        {
            "introduction": "Before deploying any cryptographic algorithm in a resource-constrained Cyber-Physical System, it is crucial to quantify its fundamental performance characteristics. This first practice provides a concrete exercise in translating low-level implementation details, such as clock cycles and power consumption, into high-level system metrics. By calculating the throughput and energy cost of a lightweight block cipher, you will gain essential skills for benchmarking and selecting appropriate cryptographic primitives for battery-powered or high-rate CPS devices .",
            "id": "4229436",
            "problem": "A Cyber-Physical System (CPS) edge node uses the Lightweight Block Cipher (LBC) PRESENT with an $80$-bit key to encrypt telemetry, and its Digital Twin (DT) must predict performance and energy costs to evaluate protocol feasibility for real-time communication. The node is built on a Texas Instruments MSP430 Microcontroller (MSP430) clocked at $16 \\text{ MHz}$ and executes the software implementation of PRESENT-80 using $2400$ Central Processing Unit (CPU) cycles per $64$-bit block. The device operates at a supply of $3.3 \\text{ V}$ and draws $5 \\text{ mA}$ during encryption. Assume a steady-state regime in which the CPU is fully utilized by encryption, external input/output overheads are negligible, all blocks are processed back-to-back without stalls, and the supply current remains constant during operation.\n\nStarting from core definitions of time, rate, and energy, derive expressions for the throughput in bits per second and the energy per bit in joules per bit for this implementation, and then evaluate them numerically using the given parameters. Express the throughput in bits per second and the energy per bit in nanojoules per bit. Round both quantities to four significant figures.",
            "solution": "The problem is well-posed and scientifically grounded, providing all necessary parameters to derive and calculate the required performance metrics. We can proceed with the solution.\n\nThe problem requires the derivation and calculation of two key performance metrics for a cryptographic implementation on an embedded device: throughput and energy per bit. We will start from the core definitions of time, rate, power, and energy, and use the provided parameters to derive the required expressions.\n\nLet the following parameters be defined based on the givens:\n- Clock frequency: $f_{clk} = 16 \\text{ MHz} = 16 \\times 10^6 \\text{ s}^{-1}$\n- CPU cycles per block: $C_{block} = 2400$\n- Block size: $B_{size} = 64 \\text{ bits}$\n- Supply voltage: $V_{DD} = 3.3 \\text{ V}$\n- Supply current: $I_{DD} = 5 \\text{ mA} = 5 \\times 10^{-3} \\text{ A}$\n\nFirst, we derive the expression for throughput, denoted by $R$.\nThe time required to process a single block of data, $T_{block}$, is determined by the number of CPU cycles needed for the operation, $C_{block}$, and the CPU's clock frequency, $f_{clk}$. The relationship is:\n$$T_{block} = \\frac{C_{block}}{f_{clk}}$$\nThroughput, $R$, is defined as the number of bits processed per unit time. Under the assumption of continuous, back-to-back block processing, this is the block size in bits, $B_{size}$, divided by the time to process one block, $T_{block}$.\n$$R = \\frac{B_{size}}{T_{block}}$$\nSubstituting the expression for $T_{block}$ gives the general formula for throughput:\n$$R = \\frac{B_{size}}{\\left( \\frac{C_{block}}{f_{clk}} \\right)} = \\frac{B_{size} \\cdot f_{clk}}{C_{block}}$$\nNext, we derive the expression for the energy consumed per bit, denoted by $E_{bit}$.\nThe electrical power, $P$, consumed by the device during encryption is the product of the supply voltage, $V_{DD}$, and the supply current, $I_{DD}$. The problem states that the current is constant during this operation.\n$$P = V_{DD} \\cdot I_{DD}$$\nThe energy consumed to encrypt a single block, $E_{block}$, is the power multiplied by the time duration of the operation, which is $T_{block}$.\n$$E_{block} = P \\cdot T_{block} = (V_{DD} \\cdot I_{DD}) \\cdot \\left( \\frac{C_{block}}{f_{clk}} \\right)$$\nThe energy per bit, $E_{bit}$, is then the energy per block divided by the number of bits in a block, $B_{size}$.\n$$E_{bit} = \\frac{E_{block}}{B_{size}} = \\frac{V_{DD} \\cdot I_{DD} \\cdot C_{block}}{B_{size} \\cdot f_{clk}}$$\nThis expression for $E_{bit}$ is consistent with the alternative derivation as the ratio of power to throughput, $E_{bit} = \\frac{P}{R}$.\n\nNow, we substitute the given numerical values into the derived expressions to evaluate them.\nFor the throughput, $R$:\n$$R = \\frac{64 \\text{ bits} \\cdot (16 \\times 10^6 \\text{ s}^{-1})}{2400} = \\frac{1024 \\times 10^6}{2400} \\text{ bps} \\approx 426666.67 \\text{ bps}$$\nThe problem requires rounding to four significant figures.\n$$R \\approx 4.267 \\times 10^5 \\text{ bps}$$\n\nFor the energy per bit, $E_{bit}$:\n$$E_{bit} = \\frac{(3.3 \\text{ V}) \\cdot (5 \\times 10^{-3} \\text{ A}) \\cdot 2400}{64 \\cdot (16 \\times 10^6 \\text{ s}^{-1})}$$\n$$E_{bit} = \\frac{39.6 \\text{ J}}{1024 \\times 10^6 \\text{ bits}} \\approx 3.8671875 \\times 10^{-8} \\frac{\\text{J}}{\\text{bit}}$$\nThe problem requires the answer in nanojoules per bit (nJ/bit). Since $1 \\text{ J} = 10^9 \\text{ nJ}$, we convert the units:\n$$E_{bit} \\approx (3.8671875 \\times 10^{-8} \\frac{\\text{J}}{\\text{bit}}) \\cdot (10^9 \\frac{\\text{nJ}}{\\text{J}}) = 38.671875 \\frac{\\text{nJ}}{\\text{bit}}$$\nRounding to four significant figures, the energy per bit is:\n$$E_{bit} \\approx 38.67 \\frac{\\text{nJ}}{\\text{bit}}$$\nThe two final numerical values are the throughput in bits per second and the energy per bit in nanojoules per bit, rounded to four significant figures.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4.267 \\times 10^5 & 38.67\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Building upon fundamental performance metrics, our next exercise places cryptographic analysis within a realistic CPS context: a real-time control loop. Many cyber-physical applications, from robotic actuators to industrial process controllers, depend on strict periodic execution to maintain stability and performance. This practice demonstrates how to derive a cryptographic computational budget directly from a control system's sampling period and assess whether a chosen authenticated encryption scheme is feasible within that tight deadline .",
            "id": "4229450",
            "problem": "A Proportional-Integral-Derivative (PID) controlled actuator in a Cyber-Physical System (CPS) is sampled periodically with sampling period $T_{s} = 2 \\text{ ms}$. To preserve closed-loop stability and limit jitter, the cryptographic processing for message authentication is constrained to consume no more than a fraction $\\alpha = 0.10$ of the sampling period per cycle. The actuator is driven by a Microcontroller Unit (MCU) clocked at frequency $f_{\\text{MCU}} = 48 \\text{ MHz}$. Authentication is implemented using Authenticated Encryption with Associated Data (AEAD), where the measured cost is $c_{b} = 30$ cycles per byte for a payload of $L = 64$ bytes. Assume the cryptographic cost scales linearly with payload size and neglect constant-time initialization costs, direct memory access (DMA) effects, and memory wait states so that cycles are directly proportional to execution time under the MCU clock.\n\nStarting from the definitions of periodic real-time scheduling and the relationship between execution time and clock cycles, derive:\n\n1. The maximum cycle budget $C_{\\max}$ available to authentication per sampling period.\n2. A feasibility indicator $\\varphi$ defined by $\\varphi = 1$ if the AEAD computation fits within the allowable budget (i.e., the required cycles do not exceed $C_{\\max}$), and $\\varphi = 0$ otherwise.\n\nProvide your final answer as a row matrix with the first entry equal to $C_{\\max}$ and the second entry equal to $\\varphi$. No rounding is required, and express all intermediate and final quantities in terms of cycles and unitless indicators as appropriate.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n**Step 1: Extract Givens**\n- Sampling period: $T_{s} = 2 \\text{ ms}$\n- Fraction of sampling period for cryptographic processing: $\\alpha = 0.10$\n- Microcontroller Unit (MCU) clock frequency: $f_{\\text{MCU}} = 48 \\text{ MHz}$\n- Cryptographic cost per byte: $c_{b} = 30 \\text{ cycles/byte}$\n- Payload size: $L = 64 \\text{ bytes}$\n- Assumptions: Linear scaling of cryptographic cost with payload size; negligible initialization costs, DMA effects, and memory wait states.\n- Required outputs:\n  1. Maximum cycle budget per sampling period, $C_{\\max}$.\n  2. Feasibility indicator, $\\varphi$, where $\\varphi = 1$ if computation is feasible and $\\varphi = 0$ otherwise.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is well-defined and scientifically grounded in the principles of real-time embedded systems and applied cryptography. The parameters provided ($T_s$, $f_{\\text{MCU}}$, $c_b$, $L$) are realistic for a modern Cyber-Physical System (CPS). The problem statement is unambiguous, self-contained, and has no internal contradictions. It does not violate any fundamental principles and is free of subjective claims. The problem is therefore deemed valid.\n\n**Step 3: Proceed to Solution**\n\nThe solution requires deriving two quantities: the maximum available cycle budget, $C_{\\max}$, and a feasibility indicator, $\\varphi$.\n\n**1. Derivation of the Maximum Cycle Budget ($C_{\\max}$)**\n\nThe total sampling period is given as $T_{s} = 2 \\text{ ms}$. This can be expressed in base SI units as:\n$$T_{s} = 2 \\times 10^{-3} \\text{ s}$$\nThe fraction of this period allocated to cryptographic processing is $\\alpha = 0.10$. Therefore, the maximum allowable execution time for authentication, denoted $T_{\\text{crypto,max}}$, is:\n$$T_{\\text{crypto,max}} = \\alpha \\times T_{s}$$\nSubstituting the given values:\n$$T_{\\text{crypto,max}} = 0.10 \\times (2 \\times 10^{-3} \\text{ s}) = 2 \\times 10^{-4} \\text{ s}$$\nThe MCU clock frequency is given as $f_{\\text{MCU}} = 48 \\text{ MHz}$, which is:\n$$f_{\\text{MCU}} = 48 \\times 10^6 \\text{ Hz} = 48 \\times 10^6 \\text{ cycles/s}$$\nThe relationship between execution time $t$, the number of clock cycles $C$, and the clock frequency $f$ is given by $t = C/f$. Consequently, the maximum number of cycles, $C_{\\max}$, that can be executed within the time budget $T_{\\text{crypto,max}}$ is:\n$$C_{\\max} = T_{\\text{crypto,max}} \\times f_{\\text{MCU}}$$\nSubstituting the derived and given values:\n$$C_{\\max} = (2 \\times 10^{-4} \\text{ s}) \\times (48 \\times 10^6 \\text{ cycles/s})$$\n$$C_{\\max} = (2 \\times 48) \\times 10^{-4} \\times 10^6 \\text{ cycles}$$\n$$C_{\\max} = 96 \\times 10^2 \\text{ cycles}$$\n$$C_{\\max} = 9600 \\text{ cycles}$$\n\n**2. Derivation of the Feasibility Indicator ($\\varphi$)**\n\nTo determine the feasibility, we must first calculate the number of cycles required for the AEAD authentication, denoted $C_{\\text{req}}$. The problem states that the cryptographic cost scales linearly with the payload size and that initialization costs are negligible. The cost per byte is $c_{b} = 30 \\text{ cycles/byte}$, and the payload size is $L = 64 \\text{ bytes}$.\nThe required number of cycles is therefore:\n$$C_{\\text{req}} = c_{b} \\times L$$\nSubstituting the given values:\n$$C_{\\text{req}} = (30 \\text{ cycles/byte}) \\times (64 \\text{ bytes})$$\n$$C_{\\text{req}} = 1920 \\text{ cycles}$$\nThe feasibility indicator $\\varphi$ is defined based on whether the required cycles fall within the maximum-allowed budget:\n$$\\varphi = \\begin{cases} 1 & \\text{if } C_{\\text{req}} \\le C_{\\max} \\\\ 0 & \\text{if } C_{\\text{req}} > C_{\\max} \\end{cases}$$\nWe compare the calculated required cycles with the maximum cycle budget:\n$$1920 \\text{ cycles} \\le 9600 \\text{ cycles}$$\nThe condition $C_{\\text{req}} \\le C_{\\max}$ is satisfied. Therefore, the feasibility indicator is:\n$$\\varphi = 1$$\n\nThe final answer requires a row matrix containing $C_{\\max}$ and $\\varphi$.\nThe calculated values are $C_{\\max} = 9600$ and $\\varphi = 1$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n9600 & 1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While performance is critical, a lightweight protocol is useless if it fails to provide adequate security. This final practice shifts our focus from speed and efficiency to the core security guarantees of a cryptographic primitive. You will explore one of the most famous principles in applied cryptography, the birthday bound, to quantify the risk of a collision in a lightweight hash function. This exercise will provide a tangible understanding of what a security level like '$256$ bits' means in a practical application like telemetry data deduplication .",
            "id": "4229400",
            "problem": "A Cyber-Physical System (CPS) telemetry pipeline for a digital twin uses the lightweight hash function PHOTON-$256$ to deduplicate sensor frames. Each telemetry frame is hashed, and a match in the hash table triggers deduplication. Assume that PHOTON-$256$ outputs are modeled as uniformly random and independent over a space of size $2^{256}$, consistent with the random oracle idealization. In a given collection interval, exactly $q = 2^{20}$ frames are hashed. Using the birthday bound as the foundational fact about collision probabilities for random functions, derive from first principles the collision probability after $q$ independent queries to a function with $n=256$-bit outputs. Then evaluate it for the given $q$ and $n$, expressing the final result as a single closed-form expression in powers of $2$. Finally, briefly discuss, based on your derivation, the implications for CPS telemetry deduplication reliability in an advanced graduate-level systems context. Provide only the collision probability as your final numerical expression. Do not approximate numerically; no rounding is required and no units are needed.",
            "solution": "The problem statement has been evaluated and is deemed valid. It is scientifically grounded in the principles of cryptography and probability theory, well-posed with sufficient and consistent information, and objective in its formulation. We may therefore proceed with the solution.\n\nThe problem requires the derivation and evaluation of the collision probability for a hash function. We are given the number of hashed items, $q$, and the size of the hash function's output space, $N$.\n\nThe specific parameters are:\n- Number of frames hashed, $q = 2^{20}$.\n- The hash function is PHOTON-$256$, which has an output of $n=256$ bits. The size of the codomain, or output space, is therefore $N = 2^{n} = 2^{256}$.\n- The hash function is modeled as a random oracle, meaning each of the $q$ outputs is an independent and uniformly random selection from the $N$ possible values.\n\nA collision occurs if at least two of the $q$ hashed frames produce the same output value. Let $P(C)$ denote the probability of such a collision. It is more straightforward to first calculate the complementary probability, $P(C')$, which is the probability of no collisions occurring. The collision probability is then $P(C) = 1 - P(C')$.\n\nFor no collisions to occur, all $q$ hash outputs must be distinct. Let us consider the sequence of $q$ hash outputs, $h_1, h_2, \\ldots, h_q$.\n- The first hash, $h_1$, can be any of the $N$ values.\n- For the second hash, $h_2$, to be different from $h_1$, it must be one of the remaining $N-1$ values. The probability of this is $\\frac{N-1}{N}$.\n- For the third hash, $h_3$, to be different from both $h_1$ and $h_2$ (which are already distinct), it must be one of the remaining $N-2$ values. The probability of this is $\\frac{N-2}{N}$.\n- This continues until the $q$-th hash, $h_q$, which must be different from the previous $q-1$ distinct hashes. It must be one of the remaining $N-(q-1)$ values. The probability is $\\frac{N-q+1}{N}$.\n\nThe total probability of no collisions, $P(C')$, is the product of these individual probabilities, as the hash outputs are independent:\n$$P(C') = \\frac{N}{N} \\times \\frac{N-1}{N} \\times \\frac{N-2}{N} \\times \\cdots \\times \\frac{N-q+1}{N}$$\nThis can be written in product notation as:\n$$P(C') = \\prod_{k=0}^{q-1} \\frac{N-k}{N} = \\prod_{k=0}^{q-1} \\left(1 - \\frac{k}{N}\\right)$$\nThis is the exact first-principles derivation of the no-collision probability. The collision probability is therefore:\n$$P(C) = 1 - \\prod_{k=0}^{q-1} \\left(1 - \\frac{k}{N}\\right)$$\n\nThe problem statement refers to the \"birthday bound as the foundational fact\". This indicates the use of the standard approximation for this probability, which is extremely accurate when $q \\ll N$. The approximation hinges on the Taylor series for the exponential function, where for small $x$, $1-x \\approx e^{-x}$. Applying this to each term in the product:\n$$P(C') = \\prod_{k=0}^{q-1} \\left(1 - \\frac{k}{N}\\right) \\approx \\prod_{k=0}^{q-1} \\exp\\left(-\\frac{k}{N}\\right) = \\exp\\left(-\\sum_{k=0}^{q-1} \\frac{k}{N}\\right)$$\nThe sum in the exponent is the sum of an arithmetic series:\n$$\\sum_{k=0}^{q-1} k = \\frac{(q-1)q}{2}$$\nSubstituting this back gives the approximation for the no-collision probability:\n$$P(C') \\approx \\exp\\left(-\\frac{q(q-1)}{2N}\\right)$$\nAnd thus the collision probability is:\n$$P(C) \\approx 1 - \\exp\\left(-\\frac{q(q-1)}{2N}\\right)$$\nFor cases where $q$ is large, the term $q(q-1)$ is very close to $q^2$. The problem asks for the result to be expressed in powers of $2$, which suggests a final form without terms like $2^{20}-1$. This implies that the approximation $q(q-1) \\approx q^2$ is intended. The relative error introduced by this is $\\frac{q^2 - q(q-1)}{q^2} = \\frac{q}{q^2} = \\frac{1}{q} = 2^{-20}$, which is negligible. This leads to the canonical birthday problem approximation:\n$$P(C) \\approx 1 - \\exp\\left(-\\frac{q^2}{2N}\\right)$$\nWe now evaluate this expression using the given values $q = 2^{20}$ and $N = 2^{256}$.\n$$P(C) \\approx 1 - \\exp\\left(-\\frac{(2^{20})^2}{2 \\cdot 2^{256}}\\right)$$\nFirst, we simplify the exponent:\n$$\\frac{(2^{20})^2}{2 \\cdot 2^{256}} = \\frac{2^{40}}{2^1 \\cdot 2^{256}} = \\frac{2^{40}}{2^{257}} = 2^{40-257} = 2^{-217}$$\nSubstituting this back into the probability expression gives the final closed-form result:\n$$P(C) \\approx 1 - \\exp(-2^{-217})$$\n\nFinally, a brief discussion on the implications for CPS telemetry deduplication reliability is warranted.\nThe calculated collision probability, $P(C) \\approx 1 - \\exp(-2^{-217})$, is an extraordinarily small number. For a small positive value $x$, the approximation $1-e^{-x} \\approx x$ holds. Thus, $P(C) \\approx 2^{-217}$. A collision in this context means that two distinct sensor frames are incorrectly identified as identical and the second one is discarded, resulting in data loss. The reliability of the deduplication component is inversely related to this probability. A value of $2^{-217}$ is so microscopically small that it is orders of magnitude lower than any other conceivable source of error in a cyber-physical system, such as hardware failures, network data corruption, or software bugs.\nFrom an advanced systems perspective, this result confirms that using a 256-bit cryptographic hash function for a workload of $2^{20}$ items provides a margin of safety against accidental collisions that is far beyond any practical requirement. The choice of a cryptographic-grade function like PHOTON also provides inherent resistance against adversarial attacks (e.g., second-preimage attacks) that would be a concern in a security-conscious application. For the stated purpose of simple deduplication, the system's reliability bottleneck will lie elsewhere; the hash-based mechanism is, for all practical purposes, perfectly reliable.",
            "answer": "$$\\boxed{1 - \\exp(-2^{-217})}$$"
        }
    ]
}