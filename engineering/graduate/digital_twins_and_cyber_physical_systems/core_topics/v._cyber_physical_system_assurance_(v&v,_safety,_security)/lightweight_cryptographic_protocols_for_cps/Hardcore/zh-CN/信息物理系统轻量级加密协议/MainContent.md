## 引言
信息物理系统（CPS）正日益成为连接数字世界与物理现实的核心，从[智能制造](@entry_id:1131785)到自动驾驶，其应用无处不在。然而，这些系统的安全却面临着一个独特的、根本性的挑战：构成CPS感知和执行末梢的大量设备，如传感器和执行器，通常在计算能力、内存和能源方面受到极大限制。传统的、为服务器和个人电脑设计的强大[密码学协议](@entry_id:275038)在这些资源受限的设备上往往无法运行，从而留下了一个巨大的安全缺口。本文旨在系统性地解决这一问题，为CPS量身定制轻量级密码协议。

在接下来的内容中，我们将分三个章节展开探讨。首先，在“原理与机制”部分，我们将通过定量分析揭示[轻量级密码学](@entry_id:1127225)的必要性，并深入剖析认证加密（AEAD）、[海绵构造](@entry_id:1132206)、[物理不可克隆函数](@entry_id:753421)（PUF）等核心构建模块的工作原理。其次，“应用与跨学科连接”部分将展示这些原理如何在实际系统中应用，从设备安全启动到大规模密钥管理，并探讨[密码学](@entry_id:139166)与控制理论、状态估计等领域的交叉影响。最后，“动手实践”部分将提供一系列计算问题，帮助您将理论知识转化为可量化的工程洞察。通过本次学习，您将掌握在资源受限环境中设计和评估安全CPS所需的核心知识。

## 原理与机制

### [轻量级密码学](@entry_id:1127225)的必要性：资源受限环境下的权衡

在深入探讨轻量级密码协议的具体机制之前，我们必须首先从根本上理解其存在的必要性。网络物理系统（CPS）的端节点，例如嵌入式传感器、执行器和控制器，通常在极其严苛的[资源限制](@entry_id:192963)下运行。这些限制涵盖了计算能力、内存大小和能量预算，与云后端或传统计算设备的环境形成鲜明对比。正是这种资源上的巨大差异，使得为前者设计的安全协议必须遵循与后者截然不同的设计哲学。

为了具体说明这一点，我们可以构建一个典型的CPS场景 。假设一个由电池供电的CPS端节点，其任务是执行一个周期为 $T_s = 2\,\text{ms}$ 的硬实时控制循环。在该周期内，控制算法的计算需要 $t_{\text{ctrl}} = 0.6\,\text{ms}$。该节点的微控制器（MCU）主频为 $f_{\text{node}} = 32\,\text{MHz}$，静态随机存取存储器（SRAM）容量为 $64\,\text{kB}$（其中 $60\,\text{kB}$ 已被占用），闪存（Flash）容量为 $128\,\text{kB}$（其中 $110\,\text{kB}$ 已被占用）。该节点必须使用认证加密（AEAD）方案来保护其发送给[数字孪生](@entry_id:171650)后端的 $256\,\text{byte}$ 消息。

现在，我们比较两种协议的适用性：一个“重量级”协议 $\mathcal{H}$ 和一个“轻量级”协议 $\mathcal{L}$。

- 协议 $\mathcal{H}$（重量级）：其AEAD计算成本为 $c_{\mathcal{H}} = 200\,\text{cycles/byte}$，代码大小为 $s_{\mathcal{H}} = 32\,\text{kB}$，运行时SRAM占用为 $r_{\mathcal{H}} = 6\,\text{kB}$。
- 协议 $\mathcal{L}$（轻量级）：其AEAD计算成本为 $c_{\mathcal{L}} = 30\,\text{cycles/byte}$，代码大小为 $s_{\mathcal{L}} = 8\,\text{kB}$，运行时SRAM占用为 $r_{\mathcal{L}} = 1\,\text{kB}$。

我们从三个方面——时间、内存和能量——来分析协议 $\mathcal{H}$ 在此端节点上的可行性。

1.  **实时性（时间）约束**：硬[实时系统](@entry_id:754137)的核心要求是所有任务必须在截止时间（deadline）内完成。在这里，总计算时间 $t_{\text{total}}$ 必须小于[采样周期](@entry_id:265475) $T_s$。
    对于协议 $\mathcal{H}$，加密所需的时间 $t_{\text{crypto}, \mathcal{H}}$ 为：
    $$t_{\text{crypto}, \mathcal{H}} = \frac{\text{消息长度} \times \text{每字节周期数}}{f_{\text{node}}} = \frac{256 \times 200}{32 \times 10^6} = 1.6\,\text{ms}$$
    因此，总时间 $t_{\text{total}, \mathcal{H}} = t_{\text{ctrl}} + t_{\text{crypto}, \mathcal{H}} = 0.6\,\text{ms} + 1.6\,\text{ms} = 2.2\,\text{ms}$。
    这个结果 $2.2\,\text{ms}$ 超过了 $2.0\,\text{ms}$ 的周期，违反了硬[实时约束](@entry_id:754130)。系统将无法正常工作。
    相比之下，协议 $\mathcal{L}$ 的加密时间仅为 $0.24\,\text{ms}$，总时间为 $0.84\,\text{ms}$，完全满足实时性要求。

2.  **内存约束**：
    -   **SRAM**：节点可用SRAM为 $64 - 60 = 4\,\text{kB}$。协议 $\mathcal{H}$ 需要 $r_{\mathcal{H}} = 6\,\text{kB}$，超出了可用容量。
    -   **Flash**：节点可用[闪存](@entry_id:176118)为 $128 - 110 = 18\,\text{kB}$。协议 $\mathcal{H}$ 的代码大小为 $s_{\mathcal{H}} = 32\,\text{kB}$，同样超出了可用容量。
    而协议 $\mathcal{L}$ 的内存占用（$1\,\text{kB}$ SRAM 和 $8\,\text{kB}$ Flash）则完全在预算之内。

3.  **[能量约束](@entry_id:1124454)**：对于电池供电的设备，能量消耗至关重要。动态能量消耗与总计算周期数成正比。协议 $\mathcal{H}$ 完成一次加密需要 $51200$ 个时钟周期，而协议 $\mathcal{L}$ 仅需 $7680$ 个周期。显然，协议 $\mathcal{H}$ 的能耗远高于协议 $\mathcal{L}$，这将显著缩短设备的电池寿命。

这个例子清晰地表明，传统的、资源密集型的[密码学](@entry_id:139166)实现（即“重量级”加密）在典型的CPS端节点上是不可行的。它不仅会因为违反实时性约束而导致系统功能失效，还会因为超出内存限制而无法部署。因此，**[轻量级密码学](@entry_id:1127225)**——那些为低计算能力、小内存和有限能量而优化的[密码学](@entry_id:139166)算法和协议——并非一种可有可无的选项，而是确保CPS端节点安全性的**根本前提**。

相比之下，处理这些数据的[数字孪生](@entry_id:171650)后端通常运行在云环境中，拥有数GHz的时钟频率、GB级的内存和几乎无限的电网供电。对于这样的平台，协议 $\mathcal{H}$ 带来的额外计算和内存开销微不足道，因此没有强制性需求去采用轻量级方案。这种在系统两端资源上的极端不对称性，是驱动[轻量级密码学](@entry_id:1127225)发展的核心动力。

### CPS通信的核心安全目标

在为CPS设计安全协议时，我们必须精确定义需要抵御的威胁。一个典型的CPS通信场景中，攻击者 $\mathcal{A}$ 能够拦截、注入、修改、延迟和重放网络上的消息。为了构建一个安全的系统，我们必须确保三个核心的密码学属性：**真实性（Authenticity）**、**完整性（Integrity）** 和 **新鲜度（Freshness）** 。

-   **真实性** 指的是确保消息确实来源于其声称的发送方。它旨在对抗**欺骗（Spoofing）**攻击，即攻击者伪造一个看起来合法的消息并注入网络。
-   **完整性** 指的是确保消息在传输过程中没有被篡改。它旨在对抗消息修改攻击。
-   **新鲜度** 指的是确保接收到的消息是及时的、非过时的。它旨在对抗**重放（Replay）**攻击（攻击者重新发送一个之前录制的合法消息）和**延迟（Delay）**攻击（攻击者恶意延长一个合法消息的传输时间）。在CPS中，一个过时的数据或指令可能与一个错误的数据同样危险。

#### 认证加密与关联数据（AEAD）

为了同时实现真实性和完整性，[现代密码学](@entry_id:274529)提供了一个强大的工具：**认证加密与关联数据（Authenticated Encryption with Associated Data, AEAD）**。AEAD是一种对称加密方案，它不仅对消息明文 $M$ 进行加密以保证**机密性（Confidentiality）**，还会生成一个**认证标签（Authentication Tag）** $T$ 来保证真实性和完整性。

一个AEAD方案的加密函数 $\mathsf{Enc}$ 可以表示为：
$$\mathsf{Enc}(K, N, A, M) \rightarrow (C, T)$$
其中，$K$ 是[共享密钥](@entry_id:261464)，$N$ 是一个每次加密都必须唯一的**Nonce**（Number used once），$A$ 是**关联数据（Associated Data）**，$M$ 是要加密的明文，$C$ 是生成的密文，$T$ 是认证标签。

解密函数 $\mathsf{Dec}$ 则相反：
$$\mathsf{Dec}(K, N, A, C, T) \rightarrow M \text{ or } \bot$$
接收方使用相同的 $K, N, A$ 和收到的 $C, T$ 来验证标签。如果验证通过，则解密 $C$ 并返回明文 $M$；如果 $C, T, A$ 或 $N$ 中有任何一部分被篡改，标签验证将失败，函数返回一个错误符号 $\bot$，从而拒绝该消息。

在[密码学](@entry_id:139166)理论中，AEAD的安全性由两个核心概念来刻画 ：
-   **IND-CCA（Indistinguishability under Chosen-Ciphertext Attack）**：选择密文攻击下的不可区分性，这是目前机密性的黄金标准。它要求即使攻击者拥有一个解密预言机（可以解密除挑战密文外的任何密文），也无法区分两个不同明文的加密结果。
-   **INT-CTXT（Integrity of Ciphertexts）**：密文完整性。它要求攻击者无法在没有密钥的情况下，伪造出一个能通过解密验证的新的有效密文。

一个设计良好的AEAD方案同时满足这两个属性。一个重要的理论结果是，如果一个方案满足较弱的机密性概念 **IND-CPA（Indistinguishability under Chosen-Plaintext Attack）** 并且同时满足 **INT-CTXT**，那么它就能被证明是IND-CCA安全的。

在CPS场景中，AEAD的“关联数据”$A$ 部分尤为重要。很多时候，消息包中包含一些无需加密但必须保证完整性的元数据，例如传感器ID、时间戳或[序列号](@entry_id:165652)。这些元数据可以作为关联数据 $A$ 输入到AEAD算法中。虽然 $A$ 本身不被加密，但它参与了认证标签 $T$ 的计算。这意味着对报头的任何篡改都会导致标签验证失败，从而保护了这些关键元数据的完整性 。

#### 通过Nonce和时间戳实现新鲜度

AEAD通过其认证标签保证了真实性和完整性，但新鲜度的保证则依赖于协议层面的设计，主要通过Nonce和时间戳来实现。

AEAD方案的一个核心要求是，在给定密钥 $K$ 的情况下，Nonce $N$ 绝不能重复使用。Nonce的重复使用会导致灾难性的安全失效，可能完全破坏机密性和完整性。因此，如何为每个数据包生成唯一的Nonce是协议设计的关键。主要有两种策略 ：

-   **基于计数器的Nonce**：发送方维护一个严格递增的计数器，并将当前计数值作为Nonce。这种方法的优点是确定性地保证了Nonce的唯一性（只要设备不发生状态重置）。然而，在存在丢包和[乱序](@entry_id:147540)的CPS网络中，它会变得很复杂。接收方需要维护一个“滑动窗口”来接收一定范围内的[乱序](@entry_id:147540)包，同时拒绝窗口之外的旧包和窗口内已接收的包。如果网络出现剧烈的[乱序](@entry_id:147540)或长时间的延迟，可能导致合法的包因其[序列号](@entry_id:165652)落在窗口之外而被错误地丢弃，从而影响系统的可用性。

-   **随机Nonce**：发送方为每个数据包生成一个足够长的随机数作为Nonce。例如，使用一个 $64$ 位的随机Nonce。其唯一性依赖于概率：在大量随机选择中发生碰撞（即重复）的概率极低。根据[生日问题](@entry_id:268167)，在发送 $n$ 个数据包后，一个 $b$ 位随机Nonce发生碰撞的概率约为 $p \approx \frac{n^2}{2^{b+1}}$。例如，对于一个每天发送 $10^5$ 个数据包的传感器，使用 $64$ 位随机Nonce，其在一个会话密钥生命周期内发生碰撞的概率约为 $10^{-10}$ 量级，可以忽略不计。接收方需要记录所有已见过的Nonce以防重放，这在拥有充足资源的[数字孪生](@entry_id:171650)后端是可行的（例如使用[布隆过滤器](@entry_id:636496)）。这种策略对网络丢包和[乱序](@entry_id:147540)具有很好的鲁棒性，因为Nonce之间没有顺[序关系](@entry_id:138937)。

除了Nonce，通过在关联数据中包含一个发送时间戳 $t_{\text{send}}$，并由接收方检查 $t_{\text{recv}} - t_{\text{send}} \le \Delta$（其中 $\Delta$ 是最大可容忍延迟），可以有效检测并拒绝被恶意延迟的消息，从而增强了新鲜度保证 。

### [轻量级密码学](@entry_id:1127225)的构造与实例

[轻量级密码学](@entry_id:1127225)的设计哲学是在满足严格安全标准的前提下，尽可能地减少计算复杂度和资源占用。这通常通过创新的算法构造来实现。

#### [海绵构造](@entry_id:1132206)（Sponge Construction）

**[海绵构造](@entry_id:1132206)**是现代对称[密码学](@entry_id:139166)（尤其是[轻量级密码学](@entry_id:1127225)）中一种极其重要和通用的设计模式。它使用一个固定长度的公开置换函数（Permutation）$f$ 或变换函数，来处理任意长度的输入并生成任意长度的输出。SHA-3哈希标准以及许多轻量级认证加密方案（如Ascon）都基于此构造。

[海绵构造](@entry_id:1132206)的核心思想是维护一个 $b$ 比特的内部状态，这个状态被分为两部分 ：
-   **速率（Rate）** $r$：状态中与外界直接交互的部分。输入消息块被[异或](@entry_id:172120)（XOR）到这部分，输出也从这部分提取。
-   **容量（Capacity）** $c$：状态中不与外界直接交互的“隐藏”部分。其大小为 $c = b - r$。

操作过程分为两个阶段：
1.  **吸收（Absorbing）**：将输入消息分割成 $r$ 比特的块。每个块依次与状态的速率部分进行[异或](@entry_id:172120)操作，然后对整个 $b$ 比特状态应用置换函数 $f$。
2.  **挤压（Squeezing）**：在所有输入块都被吸收后，从状态的速率部分提取 $r$ 比特的输出块，然后再次应用置换函数 $f$。这个过程可以重复进行，直到产生所需长度的输出。

[海绵构造](@entry_id:1132206)的安全性与容量 $c$ 密切相关。容量 $c$ 充当了抵御通用攻击（如碰撞攻击或[原像](@entry_id:150899)攻击）的安全屏障。对于一个输出为 $n$ 比特的[哈希函数](@entry_id:636237)，其抗碰撞攻击的强度由两个因素决定：一个是基于输出长度的生日攻击，复杂度约为 $2^{n/2}$；另一个是基于内部状态的攻击，其目标是在容量部分找到碰撞，复杂度约为 $2^{c/2}$。因此，总的抗碰撞安全性约为 $\min(c/2, n/2)$ 比特。

这揭示了一个关键的**权衡**：在固定的总状态宽度 $b$下，提高速率 $r$ 可以提升性能（因为每次置换能处理更多数据），但这必然会减小容量 $c$，从而降低内部安全性。轻量级设计者必须在这种性能和安全性之间做出审慎的选择。

#### 案例研究1：基于置换的AEAD（Ascon）

**Ascon**是美国国家标准与技术研究院（NIST）选定的[轻量级密码学](@entry_id:1127225)标准，它是一个基于[海绵构造](@entry_id:1132206)的AEAD方案，完美体现了上述设计原则 。

Ascon的内部状态大小为 $b=320$ 比特。对于其主要变体Ascon-128a，它被划分为 $r=64$ 比特的速率和 $c=256$ 比特的容量。这个选择提供了 $c/2 = 128$ 比特的核心安全强度，足以抵御所有已知的通用攻击，达到了与AES-128相当的安全水平。

Ascon的卓越性能和轻量级特性源于其核心的 $320$ 比特置换函数的设计。该置换函数由多轮迭代组成，每一轮都包含三个简单但高效的操作：
1.  **常数加法**：将一个轮常数异或到状态中，以破坏对称性。
2.  **置换层（S-box）**：这是唯一的[非线性](@entry_id:637147)操作。Ascon巧妙地避免了使用传统密码中的[查找表](@entry_id:177908)（S-box tables），因为[查找表](@entry_id:177908)会占用大量内存且易受缓存时序[侧信道攻击](@entry_id:275985)。取而代之，它使用了一种“位切片（bitsliced）”的实现方式，仅通过简单的[位运算](@entry_id:172125)（AND, XOR, NOT）来实现[非线性变换](@entry_id:636115)。
3.  **线性扩散层**：通过对状态字（$64$ 比特）进行[循环移位](@entry_id:177315)和异或，来混合状态中的比特，确保一个比特的变化能迅速扩散到整个状态。

这种完全基于[位运算](@entry_id:172125)和移位的设计，使得Ascon在几乎所有平台上都非常高效，尤其是在没有专用密码指令的 $32$ 位或 $8$ 位微控制器上。它的代码尺寸非常小，执行速度快，完美契合了CPS端节点的[资源限制](@entry_id:192963)。

#### 案例研究2：基于[移位寄存器](@entry_id:754780)的[流密码](@entry_id:265136)（Grain/Trivium）

除了基于分组密码或置换的[海绵构造](@entry_id:1132206)，另一类重要的轻量级原语是**[流密码](@entry_id:265136)**。[流密码](@entry_id:265136)生成一个伪随机的密钥流，然后将其与明文逐比特[异或](@entry_id:172120)来完成加密。**Grain**和**Trivium**是eSTREAM项目（一个寻找新的高性能[流密码](@entry_id:265136)的欧洲项目）中脱颖而出的两个轻量级[流密码](@entry_id:265136)的代表 。

它们的设计都基于**反馈[移位寄存器](@entry_id:754780)（Feedback Shift Registers）**，但通过引入[非线性](@entry_id:637147)来抵抗攻击。
-   **[线性反馈移位寄存器](@entry_id:154524)（LFSR）**：其状态更新是线性的（仅涉及[异或](@entry_id:172120)）。LFSR本身产生的序列[线性复杂度](@entry_id:144405)很低，可以被**Berlekamp–Massey算法**等代数攻击轻松破解。
-   **非[线性反馈[移位寄存](@entry_id:154524)器](@entry_id:754780)（NLFSR）**：其状态更新包含[非线性](@entry_id:637147)项（如比特的与运算）。

**Grain**的设计结合了一个LFSR和一个NLFSR。它的输出并非直接来自这两个寄存器，而是通过一个[非线性](@entry_id:637147)的**布尔函数（Boolean function）**进行过滤。这种“[非线性滤波器](@entry_id:271726)”的结构破坏了底层LFSR的线性，使得最终的密钥流具有非常高的[线性复杂度](@entry_id:144405)，从而能抵抗代数攻击。

**Trivium**则使用了三个相互交织的类NLFSR结构。其状态[更新函数](@entry_id:275392)是二次的（包含两个状态比特的与运算），这种固有的[非线性](@entry_id:637147)使其输出序列同样具有很高的[线性复杂度](@entry_id:144405)。

这两种设计都刻意避免了[查找表](@entry_id:177908)，只使用简单的[位运算](@entry_id:172125)，非常适合在硬件中以极低的门数实现，因此在芯片面积和能耗上极具优势。它们之间的权衡在于，Trivium拥有更大的内部状态和更长的初始化过程，旨在提供极高的安全冗余；而Grain则追求更小的状态和更快的初始化，以实现极致的轻量化。

### [信任根](@entry_id:754420)与设备身份

所有密码学操作的基础是密钥。在CPS设备上，密钥的生成、存储和管理本身就是一个巨大的挑战。

#### 熵源与[随机数生成](@entry_id:138812)

安全密钥必须是不可预测的，这意味着它们必须源于高质量的**熵（Entropy）**，即随机性。在物理设备上，熵通常来自物理噪声源，例如振荡器[抖动](@entry_id:200248)、热噪声等。这些源产生的原始[比特流](@entry_id:164631)构成了**真[随机数生成器](@entry_id:754049)（True Random Number Generator, TRNG）** 。

然而，物理熵源往往是不完美的。它们可能存在**偏差（bias）**（例如，输出‘1’的概率不等于‘0’）或相关性。直接使用这样的带有瑕疵的[比特流](@entry_id:164631)作为密钥是极其危险的。为了衡量随机性的质量，我们使用两个概念：
-   **香农熵（Shannon Entropy）** $H$：衡量序列的平均信息量或不确定性。对于一个只有两个结果（概率为 $p$ 和 $1-p$）的伯努利信源，其[香农熵](@entry_id:144587)为 $H = -p \log_2(p) - (1-p) \log_2(1-p)$。
-   **[最小熵](@entry_id:138837)（Min-Entropy）** $H_{\min}$：衡量序列中最可能出现的结果所包含的[信息量](@entry_id:272315)。$H_{\min} = -\log_2(p_{\max})$，其中 $p_{\max}$ 是最可能结果的概率。在[密码学](@entry_id:139166)中，[最小熵](@entry_id:138837)是衡量安全性的更保守、更合适的度量。

例如，一个TRNG输出‘1’的概率为 $p=0.6$，‘0’的概率为 $0.4$，那么其[最小熵](@entry_id:138837)仅为 $H_{\min} = -\log_2(0.6) \approx 0.737$ 比特/比特。这意味着每个原始比特只提供了约 $0.737$ 比特的安全性。

为了从有偏的熵源中提取出无偏、均匀的随机比特，必须使用**熵调节器（Entropy Conditioner）**或**[随机性提取器](@entry_id:270882)（Randomness Extractor）**。在实践中，一个[密码学哈希函数](@entry_id:274006)（如SHA-256）常被用作熵调节器。它将来自TRNG的、足够数量的原始比特作为输入，输出一个长度固定、统计上接近均匀分布的种子（seed）。要生成一个具有 $128$ 比特安全性的种子，我们至少需要 $128 / H_{\min} \approx 128 / 0.737 \approx 174$ 个这样的原始比特。

这个高质量的种子随后被输入到**确定性随机比特生成器（Deterministic Random Bit Generator, DRBG）**中。DRBG是一个算法，它以种子为起点，可以确定性地生成大量伪随机比特。DRBG输出的不可预测性完全依赖于种子的不可预测性。

#### 无存储密钥的设备身份：[物理不可克隆函数](@entry_id:753421)（PUF）

在某些极端场景下，即使在非易失性存储器（如Flash）中存储密钥也被认为是不安全的，因为攻击者可能通过物理手段读取存储内容。**[物理不可克隆函数](@entry_id:753421)（Physically Unclonable Function, PUF）**提供了一种创新的解决方案，它利用芯片制造过程中无法避免的、微观层面的随机物理差异来为每个设备生成独一无二的“数字指纹” 。

PUF可以被看作一个设备固有的、无法复制的物理系统。当给予一个输入**挑战（Challenge）** $C$ 时，它会产生一个输出**响应（Response）** $R$。对于同一个设备，相同的挑战会产生基本相同（但略有噪声）的响应；而对于不同的设备，即使是相同的挑战，其响应也应该是完全不相关的。

基于PUF的身份认证流程如下：
1.  **注册阶段**：在一个安全的环境中，对一个设备施加一个或多个挑战 $C$，并记录其对应的“黄金”响应 $R$。这些挑战-响应对（Challenge-Response Pairs, CRPs）存储在可信的验证方（如[数字孪生](@entry_id:171650)后端）。注意，设备本身不存储任何秘密。
2.  **验证阶段**：当需要验证设备身份时，验证方发送一个之前注册过的挑战 $C$ 给设备。设备通过其PUF生成一个实时响应 $R'$ 并发回。
3.  **决策**：验证方计算收到的 $R'$ 与存储的黄金响应 $R$ 之间的**[汉明距离](@entry_id:157657)（Hamming distance）**（即不一致的比特数）。由于物理噪声、温度变化和老化， $R'$ 不会与 $R$ 完全相同。因此，验证方设置一个[容错阈值](@entry_id:145119) $T$，如果[汉明距离](@entry_id:157657)小于或等于 $T$，则认证通过。

这个过程引入了两种错误率：
-   **错误拒绝率（False Reject Rate, FRR）**：合法设备的响应因噪声过大而被拒绝的概率。
-   **错误接受率（False Accept Rate, FAR）**：非法设备（冒名顶替者）的响应恰好与黄金响应足够接近而被接受的概率。

FRR和FAR的概率分布可以用[二项分布](@entry_id:141181)精确建模。设计PUF系统需要在选择阈值 $T$ 时权衡这两种错误率。为了处理PUF响应中的噪声并从中稳定地提取出可用的密码密钥，通常需要结合**[模糊提取器](@entry_id:1125425)（Fuzzy Extractor）**等[纠错](@entry_id:273762)技术，这些技术会生成一些非秘密的**辅助数据（Helper Data）**来帮助在每次使用时重建出完全相同的密钥。

### 实践考量与高级威胁

在将[轻量级密码学](@entry_id:1127225)应用于实际系统时，还必须考虑一些更复杂的现实因素。

#### 轻量级与硬件加速的权衡

“轻量级”并不总是等同于“最佳选择”。许多现代微控制器，即使是面向低功耗市场的，也可能集成了针对标准密码算法（如AES）的**硬件加速引擎**。在这种情况下，硬件执行的“重量级”算法可能比软件执行的“轻量级”算法更快、更节能 。

例如，在一个配备了AES硬件加速的 $100\,\text{MHz}$ MCU上，执行一次AES-128块操作可能只需要 $20$ 个[时钟周期](@entry_id:165839)。相比之下，用纯软件实现一个轻量级分组密码（如PRESENT），可能需要数百甚至上千个周期。尽管轻量级算法在软件实现上的代码尺寸更小，但在这种MCU上，AES-CC[M模式](@entry_id:915690)的总延迟和能耗可能远低于基于PRESENT的AEAD方案。

然而，在没有硬件加速的、更受限的MCU上（例如一个 $16\,\text{MHz}$ 的控制器），情况则完全相反。软件实现的AES非常耗时（可能需要超过 $1500$ 个周期），而专门为软件优化的轻量级密码（如PRESENT或Ascon）则表现出巨大优势，能耗和延迟都显著降低。

此外，**分组长度**也是一个重要的安全考量。像PRESENT这样的早期轻量级密码使用 $64$ 位的分组。根据[生日问题](@entry_id:268167)，当使用一个 $n$ 位分组密码加密大量数据块时，发生输入碰撞的概率会随着数据量的增加而上升。对于 $64$ 位分组密码，如果在一个密钥下加密的数据总量达到数十GB（大约 $2^{32}$ 个[数据块](@entry_id:748187)），[碰撞概率](@entry_id:269652)就会变得不可忽略，可能导致安全风险。因此，对于数据[吞吐量](@entry_id:271802)较高的应用，即使是在资源受限的设备上，选择具有 $128$ 位分组的密码（如AES或Ascon）也可能是必要的安全措施。

因此，为异构的CPS设备群选择密码方案时，必须进行一个系统的、多维度的决策分析，综合考虑每个设备类别的硬件能力、代码空间、延迟要求、能耗预算以及预期的总数据流量。

#### 物理安全：[侧信道攻击](@entry_id:275985)

最后，CPS设备通常部署在物理上可被接触的环境中，这使其面临一类独特的威胁：**[侧信道攻击](@entry_id:275985)（Side-Channel Attacks）**。攻击者不直接攻击算法的数学结构，而是通过观察设备在执行密码运算时的物理泄露（如功耗、执行时间、[电磁辐射](@entry_id:152916)）来推断密钥等秘密信息 。

-   **[计时攻击](@entry_id:756012)（Timing Attacks）**：如果一个密码学操作的执行时间依赖于秘密输入（例如，基于密钥的不同值执行了不同的分支或循环次数），攻击者就可以通过精确测量执行时间来推断密钥。即使是单个时钟周期的差异，在多次测量和统计分析下也可能被放大和利用。

-   **功耗分析攻击（Power Analysis Attacks）**：CMOS电路在进行计算时，其功耗与翻转的晶体管数量相关，而这又与正在处理的数据的汉明重量（数据中‘1’的个数）相关。通过监测设备的功耗曲线，攻击者可以推断出与密钥相关的中间值。

为了防御这些攻击，必须采取专门的对策：

-   **常数时间实现（Constant-Time Implementation）**：这是防御[计时攻击](@entry_id:756012)的根本方法。代码的执行路径和内存访问模式必须与所有秘密数据完全无关。这意味着不能有依赖于密钥的分支（`if (secret) ...`）或依赖于密钥的数组索引（`array[secret]`）。实现常数时间的代码需要非常谨慎的编程技巧。

-   **掩码（Masking）**：常数时间实现不能防御功耗分析，因为它只控制了执行流，而没有改变处理的数据本身。**掩码**是防御功耗攻击的主要技术。其基本思想是将一个秘密值 $S$ 分割成两个或多个随机的“份额”（shares），例如 $S = S_1 \oplus S_2$。密码运算全程都在这些份额上进行，而不是直接在 $S$ 上。由于 $S_1$ 和 $S_2$ 都是随机的，处理它们的中间功耗与原始秘密 $S$ 之间的关联就被打破了。

对于部署在物理不安全环境中的CPS设备，仅仅选择一个数学上安全的轻量级算法是远远不够的。其实现在设备上的具体代码必须经过精心的设计，以抵抗[侧信道攻击](@entry_id:275985)，确保物理层面的安全。