{
    "hands_on_practices": [
        {
            "introduction": "To effectively manage and improve the resilience of a Cyber-Physical System, we must first be able to quantify it. A fundamental and intuitive metric is the total performance loss incurred during a disruption, calculated as the integral of the performance deficit over time. This practice () challenges you to compute this resilience loss for two different hypothetical disruption scenarios, honing your ability to translate a system's performance curve into a tangible resilience score.",
            "id": "4240984",
            "problem": "A Digital Twin (DT) of a Cyber-Physical System (CPS) continuously estimates a normalized service level trajectory $Q(t)$, where $Q(t) \\in [0,1]$ and the nominal baseline is $Q_{\\text{base}}=1$. Consider a single disturbance event initiating at $t=0$, after which the system’s trajectory is piecewise, comprising a constant-loss phase followed by a linear recovery phase. The resilience loss $A$ is defined as the time integral of the performance deficit relative to the baseline over the entire event window until recovery completes, i.e., the area under $1 - Q(t)$ from the onset of the event until $Q(t)$ returns to $1$.\n\nScenario $1$ is described by an instantaneous drop to $Q(t)=0.4$ at $t=0$, holding at this level for $3$ minutes, followed by a linear recovery to $Q(t)=1$ over the next $5$ minutes. Scenario $2$ is described by an instantaneous drop to $Q(t)=0.6$ at $t=0$, holding at this level for $4$ minutes, followed by a linear recovery to $Q(t)=1$ over the next $3$ minutes.\n\nUsing the above fundamental definition of resilience loss, compute the resilience losses $A_1$ and $A_2$ for Scenario $1$ and Scenario $2$, respectively, and report the comparison as the exact ratio $r = A_1 / A_2$. Your final answer must be a single exact number with no units and no rounding.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the established principles of resilience engineering for cyber-physical systems, well-posed with a clear and complete set of definitions and data, and objective in its formulation. It presents a solvable mathematical problem without any logical contradictions, physical impossibilities, or ambiguities.\n\nThe resilience loss, $A$, is defined as the time integral of the performance deficit, $1 - Q(t)$, over the duration of the event, from its onset at $t=0$ until the system fully recovers to its baseline performance level, $Q_{\\text{base}}=1$. Mathematically, this is expressed as:\n$$A = \\int_{0}^{t_{\\text{recover}}} (1 - Q(t)) \\,dt$$\nWhere $t_{\\text{recover}}$ is the time at which $Q(t)$ returns to $1$.\n\nFor the piecewise trajectory described, consisting of a constant-loss phase followed by a linear recovery, this integral can be interpreted geometrically. The area representing the loss is composed of two parts: a rectangle corresponding to the constant-loss phase and a right-angled triangle corresponding to the linear recovery phase.\n\nLet $Q_{\\text{min}}$ be the service level during the constant-loss phase, $t_d$ be the duration of this phase, and $t_r$ be the duration of the linear recovery phase.\nThe performance deficit during the constant-loss phase is constant at $1 - Q_{\\text{min}}$. The area of the rectangular portion of the loss, $A_{\\text{rect}}$, is the product of this deficit and the duration $t_d$:\n$$A_{\\text{rect}} = (1 - Q_{\\text{min}}) \\times t_d$$\nDuring the linear recovery phase, the performance deficit decreases linearly from $1 - Q_{\\text{min}}$ to $0$ over the duration $t_r$. This forms a right-angled triangle. The area of this triangular portion of the loss, $A_{\\text{tri}}$, is:\n$$A_{\\text{tri}} = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times t_r \\times (1 - Q_{\\text{min}})$$\nThe total resilience loss $A$ is the sum of these two areas:\n$$A = A_{\\text{rect}} + A_{\\text{tri}} = (1 - Q_{\\text{min}})t_d + \\frac{1}{2}(1 - Q_{\\text{min}})t_r = (1 - Q_{\\text{min}})\\left(t_d + \\frac{t_r}{2}\\right)$$\n\nWe apply this formula to each scenario. The time units are consistently in minutes, so they will cancel out in the final ratio, and we can work directly with the given numerical values.\n\nFor Scenario $1$:\nThe system drops to a service level $Q_{\\text{min},1} = 0.4$.\nThe duration of the constant-loss phase is $t_{d,1} = 3$ minutes.\nThe duration of the linear recovery phase is $t_{r,1} = 5$ minutes.\nThe performance deficit is $1 - Q_{\\text{min},1} = 1 - 0.4 = 0.6$.\n\nThe resilience loss for Scenario $1$, $A_1$, is calculated as:\n$$A_1 = (1 - 0.4) \\left( 3 + \\frac{5}{2} \\right)$$\n$$A_1 = 0.6 \\left( 3 + 2.5 \\right)$$\n$$A_1 = 0.6 \\times 5.5 = \\frac{6}{10} \\times \\frac{55}{10} = \\frac{3}{5} \\times \\frac{11}{2} = \\frac{33}{10} = 3.3$$\n\nFor Scenario $2$:\nThe system drops to a service level $Q_{\\text{min},2} = 0.6$.\nThe duration of the constant-loss phase is $t_{d,2} = 4$ minutes.\nThe duration of the linear recovery phase is $t_{r,2} = 3$ minutes.\nThe performance deficit is $1 - Q_{\\text{min},2} = 1 - 0.6 = 0.4$.\n\nThe resilience loss for Scenario $2$, $A_2$, is calculated as:\n$$A_2 = (1 - 0.6) \\left( 4 + \\frac{3}{2} \\right)$$\n$$A_2 = 0.4 \\left( 4 + 1.5 \\right)$$\n$$A_2 = 0.4 \\times 5.5 = \\frac{4}{10} \\times \\frac{55}{10} = \\frac{2}{5} \\times \\frac{11}{2} = \\frac{11}{5} = \\frac{22}{10} = 2.2$$\n\nFinally, we compute the ratio $r = A_1 / A_2$.\n$$r = \\frac{A_1}{A_2} = \\frac{3.3}{2.2}$$\nTo express this as an exact fraction, we can write:\n$$r = \\frac{33/10}{22/10} = \\frac{33}{22}$$\nSimplifying the fraction by dividing the numerator and denominator by their greatest common divisor, which is $11$:\n$$r = \\frac{33 \\div 11}{22 \\div 11} = \\frac{3}{2}$$",
            "answer": "$$\\boxed{\\frac{3}{2}}$$"
        },
        {
            "introduction": "Real-world recovery planning rarely involves optimizing a single objective; it almost always requires balancing competing priorities. This exercise () simulates a realistic scenario where a Digital Twin is used to evaluate recovery options against conflicting metrics of speed, cost, and restoration level. You will apply formal principles of multi-criteria decision analysis, such as Pareto dominance and weighted-sum utility, to navigate these trade-offs and select the best strategy based on stakeholder preferences.",
            "id": "4240929",
            "problem": "A utility operator maintains a Digital Twin (DT) of a power-grid Cyber-Physical System (CPS) to plan recovery after a cyber-induced physical disruption. The system-wide service level is described by a normalized quality trajectory $Q(t) \\in [0,1]$, where $Q(t)$ decreases at the disruption onset and is later restored by recovery actions. Resilience assessment in this context prioritizes recovery speed, extent of service restoration, and resource expenditure. Two candidate recovery options $R_1$ and $R_2$ are simulated in the DT and evaluated by three metrics measured at the planning stage:\n- Recovery acceleration $A$ in units of $\\mathrm{h}^{-1}$, representing the characteristic rate parameter of first-order recovery toward a target service level.\n- Recovery expenditure $c$ in millions of dollars, representing the total additional cost attributable to the chosen recovery option.\n- Maximum incremental restoration $\\Delta Q_{\\max}$, a dimensionless fraction in $[0,1]$ representing the peak increase in normalized service level achievable by the option beyond the disrupted baseline.\n\nThe DT provides the following metric values:\n- For $R_1$: $A_1 = 0.8\\,\\mathrm{h}^{-1}$, $c_1 = 12$, $\\Delta Q_{\\max,1} = 0.35$.\n- For $R_2$: $A_2 = 0.5\\,\\mathrm{h}^{-1}$, $c_2 = 9$, $\\Delta Q_{\\max,2} = 0.45$.\n\nStakeholders (regulators, operators, and customers) have negotiated an aggregate weight vector over the three dimensions: $w_A = 0.5$, $w_c = 0.2$, $w_Q = 0.3$. To compare heterogeneous metrics, the planning team will normalize each metric to a dimensionless utility on $[0,1]$ using reference values that reflect aspirational targets and budget caps agreed in policy:\n- Reference acceleration $A_{\\mathrm{ref}} = 1.0\\,\\mathrm{h}^{-1}$.\n- Reference cost cap $c_{\\mathrm{ref}} = 15$ (millions of dollars).\n- Reference service restoration $\\Delta Q_{\\mathrm{ref}} = 0.5$.\n\nAssume the following decision principles:\n1. Use Pareto dominance with correct objective directions to eliminate any dominated option: recovery acceleration $A$ and maximum incremental restoration $\\Delta Q_{\\max}$ are objectives to be maximized, whereas cost $c$ is an objective to be minimized.\n2. If neither option is Pareto dominated, derive a dimensionless weighted-sum utility consistent with the stakeholder weights by mapping each metric to a $[0,1]$ utility via normalization with the provided reference values and aligning directions so that $1$ denotes ideal performance for each dimension.\n\nDecide between $R_1$ and $R_2$ accordingly, and report the weighted-sum utility of the selected option as a single number. Round your answer to four significant figures. Express the final value as a dimensionless number.",
            "solution": "We begin from fundamental multi-objective decision principles relevant to resilience planning in Cyber-Physical Systems (CPS). The normalized service level $Q(t)$ captures the system performance over time, while resilience-oriented metrics quantify recovery speed, restoration extent, and resource expenditure. The decision requires comparing two options $R_1$ and $R_2$ across three objectives with heterogeneous units. \n\nFirst, we apply Pareto dominance. An option $X$ Pareto dominates option $Y$ if, for all objectives, $X$ is at least as good as $Y$ in the correct direction and strictly better in at least one. Here:\n- Recovery acceleration $A$ is to be maximized.\n- Maximum incremental restoration $\\Delta Q_{\\max}$ is to be maximized.\n- Cost $c$ is to be minimized.\n\nWe list the metrics:\n- $R_1$: $A_1 = 0.8$, $c_1 = 12$, $\\Delta Q_{\\max,1} = 0.35$.\n- $R_2$: $A_2 = 0.5$, $c_2 = 9$, $\\Delta Q_{\\max,2} = 0.45$.\n\nComparisons:\n- For $A$: $A_1 = 0.8 > 0.5 = A_2$, so $R_1$ is better on $A$.\n- For $c$: $c_1 = 12 > 9 = c_2$, but since lower cost is better, $R_2$ is better on $c$.\n- For $\\Delta Q_{\\max}$: $\\Delta Q_{\\max,1} = 0.35 < 0.45 = \\Delta Q_{\\max,2}$, so $R_2$ is better on $\\Delta Q_{\\max}$.\n\nSince $R_1$ is better in $A$ but worse in both $c$ and $\\Delta Q_{\\max}$, and $R_2$ is better in two objectives but worse in one, neither option is at least as good in all objectives compared to the other. Therefore, neither $R_1$ nor $R_2$ Pareto dominates the other. Both lie on the Pareto front with respect to the two options.\n\nGiven no dominance, we proceed to construct a weighted-sum utility that is dimensionless and aligns objective directions. We normalize each metric to $[0,1]$ using the provided references:\n- For acceleration, higher is better; a natural normalization is the ratio to the reference:\n  $$u_A = \\frac{A}{A_{\\mathrm{ref}}}.$$\n- For cost, lower is better; we invert relative to the reference cap so that $0$ corresponds to hitting the cap and $1$ to zero cost:\n  $$u_c = 1 - \\frac{c}{c_{\\mathrm{ref}}}.$$\n- For restoration, higher is better; use the ratio to the target:\n  $$u_Q = \\frac{\\Delta Q_{\\max}}{\\Delta Q_{\\mathrm{ref}}}.$$\n\nThese utilities are in $[0,1]$ provided $A \\in [0, A_{\\mathrm{ref}}]$, $c \\in [0, c_{\\mathrm{ref}}]$, and $\\Delta Q_{\\max} \\in [0, \\Delta Q_{\\mathrm{ref}}]$, matching the planning references. We then combine them with stakeholder weights $w_A$, $w_c$, and $w_Q$ to form the overall utility:\n$$U = w_A\\,u_A + w_c\\,u_c + w_Q\\,u_Q,$$\nwhere $w_A = 0.5$, $w_c = 0.2$, and $w_Q = 0.3$.\n\nCompute the utilities for each option.\n\nFor $R_1$:\n- $$u_{A,1} = \\frac{A_1}{A_{\\mathrm{ref}}} = \\frac{0.8}{1.0} = 0.8.$$\n- $$u_{c,1} = 1 - \\frac{c_1}{c_{\\mathrm{ref}}} = 1 - \\frac{12}{15} = 1 - 0.8 = 0.2.$$\n- $$u_{Q,1} = \\frac{\\Delta Q_{\\max,1}}{\\Delta Q_{\\mathrm{ref}}} = \\frac{0.35}{0.5} = 0.7.$$\nThus,\n$$U_1 = (0.5)(0.8) + (0.2)(0.2) + (0.3)(0.7) = 0.4 + 0.04 + 0.21 = 0.65.$$\n\nFor $R_2$:\n- $$u_{A,2} = \\frac{A_2}{A_{\\mathrm{ref}}} = \\frac{0.5}{1.0} = 0.5.$$\n- $$u_{c,2} = 1 - \\frac{c_2}{c_{\\mathrm{ref}}} = 1 - \\frac{9}{15} = 1 - 0.6 = 0.4.$$\n- $$u_{Q,2} = \\frac{\\Delta Q_{\\max,2}}{\\Delta Q_{\\mathrm{ref}}} = \\frac{0.45}{0.5} = 0.9.$$\nThus,\n$$U_2 = (0.5)(0.5) + (0.2)(0.4) + (0.3)(0.9) = 0.25 + 0.08 + 0.27 = 0.60.$$\n\nTherefore, the weighted-sum utility favors $R_1$ with $U_1 = 0.65$ over $R_2$ with $U_2 = 0.60$. The decision is $R_1$. The requested output is the weighted-sum utility of the selected option, rounded to four significant figures. Rounding $0.65$ to four significant figures yields $0.6500$, expressed as a dimensionless number.",
            "answer": "$$\\boxed{0.6500}$$"
        },
        {
            "introduction": "Building on decision-making, this final practice introduces the critical challenge of uncertainty in recovery planning. Key parameters, such as repair durations, are seldom known with certainty. This advanced exercise () explores robust optimization, contrasting a schedule that is optimal for a single, nominal scenario against one that provides the best guaranteed performance across a range of possibilities. By implementing and comparing these approaches, you will directly quantify the value of planning for the worst case, a cornerstone of creating truly resilient systems.",
            "id": "4240927",
            "problem": "You are given a single-repair-crew recovery planning problem for a Cyber-Physical System (CPS) that uses a Digital Twin to simulate schedules under uncertainty. The resilience metric is defined as Availability (A), where Availability (A) is the fraction of time that components are operational during a fixed horizon. A deterministic schedule assumes nominal repair durations, while a robust schedule maximizes the worst-case Availability across a set of uncertainty scenarios. Your task is to compute and compare the worst-case Availability for deterministic versus robust schedules via scenario-based optimization.\n\nFundamental base and modeling assumptions:\n- There is a single repair crew processing a finite set of jobs (component repairs). Each job corresponds to a component failure that occurs at a known failure time and is repaired once the crew starts working on it.\n- Time and durations are expressed in hours. The fixed horizon length is denoted by $H$ (in hours). All failure times and repair durations are expressed in hours.\n- For each job $i \\in \\{1,\\dots,M\\}$, its failure time is $t_i \\in [0,H]$ (in hours).\n- Under each uncertainty scenario $s \\in \\{1,\\dots,S\\}$, the repair duration for job $i$ is $d_{i}^{(s)} \\ge 0$ (in hours).\n- The repair crew follows a static schedule represented by a permutation $\\pi$ of $\\{1,\\dots,M\\}$; the crew processes jobs in the order $(\\pi_1,\\pi_2,\\dots,\\pi_M)$.\n- The crew cannot repair a job before it fails. If the crew becomes available and the next job in sequence has not yet failed, the crew idles until that job’s failure time. The start time of job $j$ in scenario $s$ under schedule $\\pi$ is given by $x_{\\pi_j}^{(s)} = \\max\\left(x_{\\pi_{j-1}}^{(s)} + d_{\\pi_{j-1}}^{(s)},\\ t_{\\pi_j}\\right)$ with $x_{\\pi_1}^{(s)} = \\max(0,\\ t_{\\pi_1})$. The completion time is $c_{\\pi_j}^{(s)} = x_{\\pi_j}^{(s)} + d_{\\pi_j}^{(s)}$.\n- For each job $i$, the downtime contribution in scenario $s$ is $c_{i}^{(s)} - t_i$ (in hours), because the component is unavailable from failure until repair completion.\n- The total downtime across all jobs in scenario $s$ is $D^{(s)}(\\pi) = \\sum_{i=1}^{M} \\left(c_{i}^{(s)} - t_i\\right)$.\n- Availability (A) for schedule $\\pi$ in scenario $s$ is defined as $A^{(s)}(\\pi) = 1 - \\dfrac{D^{(s)}(\\pi)}{M \\cdot H}$. This normalizes downtime by the maximum possible uptime across $M$ components over the horizon $H$, ensuring $A^{(s)}(\\pi) \\in [0,1]$ provided repairs complete within the horizon.\n\nDeterministic versus robust schedules:\n- Deterministic schedule: Treat a designated nominal scenario $s_0$ as the true durations. Choose $\\pi_{\\mathrm{det}}$ that maximizes $A^{(s_0)}(\\pi)$ over all permutations.\n- Robust schedule: Choose $\\pi_{\\mathrm{rob}}$ that maximizes the worst-case Availability across scenarios, i.e., $\\pi_{\\mathrm{rob}} \\in \\arg\\max_{\\pi} \\min_{s \\in \\{1,\\dots,S\\}} A^{(s)}(\\pi)$.\n\nRequired computations:\n- Compute the worst-case Availability of the deterministic schedule, $\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$.\n- Compute the worst-case Availability of the robust schedule, $\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}})$.\n- Compute the improvement defined as $\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}) - \\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$.\n- All Availability values must be expressed as decimals (unitless fractions). All time values are in hours.\n\nAlgorithmic requirements:\n- Enumerate all permutations to find $\\pi_{\\mathrm{det}}$ and $\\pi_{\\mathrm{rob}}$ for the provided test cases. If ties occur when selecting a schedule, break ties by maximizing the average Availability across scenarios, $\\frac{1}{S}\\sum_{s=1}^{S} A^{(s)}(\\pi)$; if ties still persist, select the lexicographically smallest permutation.\n- Assume repairs can extend beyond the horizon $H$, but the downtime definition remains $c_i^{(s)} - t_i$; Availability can be less than $0$ in pathological cases, but the given test suite will be scientifically sound and keep values within reasonable ranges.\n\nTest suite:\nEach test case is specified by $(M, H, \\{t_i\\}_{i=1}^{M}, \\{d_i^{(s)}\\}_{i=1}^{M} \\text{ for } s=1,\\dots,S, s_0)$, where $s_0$ is the index of the nominal scenario used for the deterministic schedule. Time unit is hours. Availability must be output as decimals.\n\n- Test case $1$ (happy path):\n  - $M = 4$, $H = 20$.\n  - Failure times: $t = [0, 2, 5, 7]$ (hours).\n  - Scenarios ($S = 3$):\n    - $s = 1$: $d^{(1)} = [2, 5, 3, 4]$ (hours).\n    - $s = 2$: $d^{(2)} = [3, 6, 6, 3]$ (hours).\n    - $s = 3$: $d^{(3)} = [4, 7, 2, 5]$ (hours).\n  - Nominal scenario index: $s_0 = 1$.\n\n- Test case $2$ (boundary: identical failure times and symmetric durations):\n  - $M = 4$, $H = 10$.\n  - Failure times: $t = [0, 0, 0, 0]$ (hours).\n  - Scenarios ($S = 3$):\n    - $s = 1$: $d^{(1)} = [1, 1, 1, 1]$ (hours).\n    - $s = 2$: $d^{(2)} = [2, 2, 2, 2]$ (hours).\n    - $s = 3$: $d^{(3)} = [3, 3, 3, 3]$ (hours).\n  - Nominal scenario index: $s_0 = 1$.\n\n- Test case $3$ (edge: staggered failures and one heavy job with uncertain duration):\n  - $M = 4$, $H = 24$.\n  - Failure times: $t = [0, 4, 8, 12]$ (hours).\n  - Scenarios ($S = 3$):\n    - $s = 1$: $d^{(1)} = [5, 1, 1, 1]$ (hours).\n    - $s = 2$: $d^{(2)} = [8, 1, 1, 1]$ (hours).\n    - $s = 3$: $d^{(3)} = [10, 1, 1, 1]$ (hours).\n  - Nominal scenario index: $s_0 = 1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results aggregated across all test cases as a comma-separated list enclosed in square brackets, where each test case contributes a sub-list of three decimals in the order $[\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}}),\\ \\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}),\\ \\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}) - \\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})]$. For example, the output must look like:\n\"[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]\"\nAll Availability values must be decimals. Time values are in hours.",
            "solution": "The problem statement has been critically validated and is deemed to be a valid, well-posed, and scientifically grounded problem in the domain of scheduling and robust optimization for Cyber-Physical Systems.\n\nThe problem asks for the computation and comparison of deterministic and robust repair schedules for a single-crew system. The performance metric is Availability, $A$, defined as the fraction of time components are operational over a horizon $H$. The solution requires finding optimal schedules by enumerating all possible job permutations, as the number of jobs $M$ is small.\n\nThe core of the problem is to evaluate the Availability of a given repair schedule, $\\pi$, under various uncertainty scenarios, $s \\in \\{1,\\dots,S\\}$. A schedule $\\pi$ is a permutation of the $M$ jobs. For each job $i \\in \\{1, \\dots, M\\}$, its failure time is $t_i$ and its repair duration in scenario $s$ is $d_i^{(s)}$.\n\nFirst, we must calculate the completion time for each job under a given schedule $\\pi = (\\pi_1, \\dots, \\pi_M)$ and scenario $s$. The start time $x_{\\pi_j}^{(s)}$ of the $j$-th job in the sequence is determined by the completion of the previous job and the failure time of the current job. The crew is available after completing job $\\pi_{j-1}$ at time $c_{\\pi_{j-1}}^{(s)}$, and job $\\pi_j$ cannot start before it fails at time $t_{\\pi_j}$. The recurrence relations are:\n$$\nx_{\\pi_1}^{(s)} = \\max(0,\\ t_{\\pi_1})\n$$\n$$\nx_{\\pi_j}^{(s)} = \\max\\left(c_{\\pi_{j-1}}^{(s)}, t_{\\pi_j}\\right) \\quad \\text{for } j > 1\n$$\nwhere $c_{\\pi_{j-1}}^{(s)} = x_{\\pi_{j-1}}^{(s)} + d_{\\pi_{j-1}}^{(s)}$ is the completion time of the $(j-1)$-th job in the sequence. Consolidating these, the completion time of the $j$-th job in the sequence, $c_{\\pi_j}^{(s)}$, can be calculated iteratively. Once all completion times $c_i^{(s)}(\\pi)$ for $i=1,\\dots,M$ are found, the total downtime for schedule $\\pi$ in scenario $s$ is the sum of individual component downtimes:\n$$\nD^{(s)}(\\pi) = \\sum_{i=1}^{M} \\left(c_{i}^{(s)}(\\pi) - t_i\\right)\n$$\nThe Availability for schedule $\\pi$ in scenario $s$ is then given by:\n$$\nA^{(s)}(\\pi) = 1 - \\frac{D^{(s)}(\\pi)}{M \\cdot H}\n$$\nwhere $M \\cdot H$ is the total maximum operational time for all components.\n\nWith the evaluation function $A^{(s)}(\\pi)$ defined, we can find the two required schedules:\n\n1.  **Deterministic Schedule ($\\pi_{\\mathrm{det}}$)**: This schedule is optimal for a single, nominal scenario $s_0$. It is the permutation that maximizes the Availability in that scenario:\n    $$\n    \\pi_{\\mathrm{det}} \\in \\arg\\max_{\\pi} A^{(s_0)}(\\pi)\n    $$\n\n2.  **Robust Schedule ($\\pi_{\\mathrm{rob}}$)**: This schedule provides the best guaranteed performance across all possible scenarios. It is the permutation that maximizes the worst-case (minimum) Availability:\n    $$\n    \\pi_{\\mathrm{rob}} \\in \\arg\\max_{\\pi} \\min_{s \\in \\{1,\\dots,S\\}} A^{(s)}(\\pi)\n    $$\n\nThe problem specifies a clear, hierarchical tie-breaking rule. If multiple permutations yield the same optimal objective value, the one with the higher average Availability across all scenarios, $\\frac{1}{S}\\sum_{s=1}^{S} A^{(s)}(\\pi)$, is chosen. If a tie persists, the lexicographically smallest permutation is selected.\n\nThe solution is implemented by following these steps for each test case:\n1.  Generate all $M!$ permutations of the job indices $\\{0, \\dots, M-1\\}$.\n2.  For each permutation $\\pi$, calculate the vector of availabilities $[A^{(1)}(\\pi), \\dots, A^{(S)}(\\pi)]$.\n3.  For each permutation, also compute its nominal-scenario availability $A^{(s_0)}(\\pi)$, its worst-case (minimum) availability $\\min_s A^{(s)}(\\pi)$, and its average availability $\\frac{1}{S}\\sum_s A^{(s)}(\\pi)$.\n4.  To find $\\pi_{\\mathrm{det}}$, sort all permutations based on a tuple of criteria in descending order for the primary and secondary objectives and ascending for the tertiary: $(A^{(s_0)}(\\pi), \\frac{1}{S}\\sum_s A^{(s)}(\\pi), \\pi)$. The top entry is $\\pi_{\\mathrm{det}}$.\n5.  To find $\\pi_{\\mathrm{rob}}$, sort similarly using the criteria $(\\min_s A^{(s)}(\\pi), \\frac{1}{S}\\sum_s A^{(s)}(\\pi), \\pi)$. The top entry is $\\pi_{\\mathrm{rob}}$.\n6.  Finally, compute the required values: the worst-case availability of the deterministic schedule, $\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$; the worst-case availability of the robust schedule, $\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}})$; and the improvement, which is the difference between the two.\n\nThis procedure, while computationally intensive for large $M$, is guaranteed to find the correct optimal schedules for the small values specified in the test suite ($M=4$). The calculations are performed using floating-point arithmetic to produce the required decimal outputs.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"M\": 4, \"H\": 20.0,\n            \"t\": [0.0, 2.0, 5.0, 7.0],\n            \"d_scenarios\": [\n                [2.0, 5.0, 3.0, 4.0],\n                [3.0, 6.0, 6.0, 3.0],\n                [4.0, 7.0, 2.0, 5.0]\n            ],\n            \"s0\": 1\n        },\n        # Test case 2\n        {\n            \"M\": 4, \"H\": 10.0,\n            \"t\": [0.0, 0.0, 0.0, 0.0],\n            \"d_scenarios\": [\n                [1.0, 1.0, 1.0, 1.0],\n                [2.0, 2.0, 2.0, 2.0],\n                [3.0, 3.0, 3.0, 3.0]\n            ],\n            \"s0\": 1\n        },\n        # Test case 3\n        {\n            \"M\": 4, \"H\": 24.0,\n            \"t\": [0.0, 4.0, 8.0, 12.0],\n            \"d_scenarios\": [\n                [5.0, 1.0, 1.0, 1.0],\n                [8.0, 1.0, 1.0, 1.0],\n                [10.0, 1.0, 1.0, 1.0]\n            ],\n            \"s0\": 1\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        M, H, t, d_scenarios, s0 = case[\"M\"], case[\"H\"], case[\"t\"], case[\"d_scenarios\"], case[\"s0\"]\n        \n        S = len(d_scenarios)\n        s0_idx = s0 - 1\n        job_indices = range(M)\n        \n        all_perms = list(itertools.permutations(job_indices))\n        \n        eval_results = []\n        for pi in all_perms:\n            # Calculate availability for pi under all scenarios\n            availabilities = []\n            for s in range(S):\n                d_s = d_scenarios[s]\n                completion_times = {}\n                prev_c = 0.0\n                \n                for job_idx in pi:\n                    start_time = max(prev_c, t[job_idx])\n                    completion_time = start_time + d_s[job_idx]\n                    completion_times[job_idx] = completion_time\n                    prev_c = completion_time\n                \n                total_downtime = 0.0\n                for i in range(M):\n                    total_downtime += completion_times[i] - t[i]\n                \n                availability_s = 1.0 - total_downtime / (M * H)\n                availabilities.append(availability_s)\n                \n            min_A = min(availabilities)\n            avg_A = np.mean(availabilities)\n            nominal_A = availabilities[s0_idx]\n            \n            eval_results.append({\n                \"pi\": pi,\n                \"availabilities\": availabilities,\n                \"nominal_A\": nominal_A,\n                \"min_A\": min_A,\n                \"avg_A\": avg_A\n            })\n\n        # Find pi_det using tie-breaking rules\n        # Sort by nominal_A (desc), then avg_A (desc), then pi (asc)\n        det_candidates = sorted(eval_results, key=lambda x: (-x[\"nominal_A\"], -x[\"avg_A\"], x[\"pi\"]))\n        pi_det_result = det_candidates[0]\n\n        # Find pi_rob using tie-breaking rules\n        # Sort by min_A (desc), then avg_A (desc), then pi (asc)\n        rob_candidates = sorted(eval_results, key=lambda x: (-x[\"min_A\"], -x[\"avg_A\"], x[\"pi\"]))\n        pi_rob_result = rob_candidates[0]\n\n        # Calculate required outputs\n        worst_case_A_det = min(pi_det_result[\"availabilities\"])\n        worst_case_A_rob = pi_rob_result[\"min_A\"] # This is the value we maximized\n        improvement = worst_case_A_rob - worst_case_A_det\n\n        all_results.append([worst_case_A_det, worst_case_A_rob, improvement])\n\n    # Format output string to match \"[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]\"\n    inner_results_str = []\n    for res in all_results:\n        # Format each sub-list without spaces\n        inner_results_str.append(f\"[{','.join(map(str, res))}]\")\n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}