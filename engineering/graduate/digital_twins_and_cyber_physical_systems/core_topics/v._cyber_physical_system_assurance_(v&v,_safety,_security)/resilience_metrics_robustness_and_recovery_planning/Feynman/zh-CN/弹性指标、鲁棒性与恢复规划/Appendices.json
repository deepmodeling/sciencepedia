{
    "hands_on_practices": [
        {
            "introduction": "工程韧性的第一步是能够量化它。一个基础且直观的度量标准是系统在扰动事件中所承受的总性能损失，这通常被形象地描述为“韧性三角形”的面积。本练习将指导您使用一个常见的分段线性性能模型，为两个假设场景计算这一韧性损失。通过掌握这种计算，您将建立一项基本技能，用于定量比较不同扰动事件的严重程度以及恢复措施的有效性。",
            "id": "4240984",
            "problem": "一个信息物理系统（CPS）的数字孪生（DT）持续估计一个归一化的服务水平轨迹 $Q(t)$，其中 $Q(t) \\in [0,1]$，标称基线为 $Q_{\\text{base}}=1$。考虑一个在 $t=0$ 时刻开始的单一扰动事件，此后系统的轨迹是分段的，包括一个恒定损失阶段，随后是一个线性恢复阶段。韧性损失 $A$ 定义为在整个事件窗口内，从事件开始直到恢复完成，性能亏损相对于基线的时间积分，即从事件开始到 $Q(t)$ 返回到 $1$ 期间，$1 - Q(t)$ 曲线下方的面积。\n\n场景1描述为：在 $t=0$ 时刻瞬时下降至 $Q(t)=0.4$，该水平保持3分钟，然后在接下来的5分钟内线性恢复至 $Q(t)=1$。场景2描述为：在 $t=0$ 时刻瞬时下降至 $Q(t)=0.6$，该水平保持4分钟，然后在接下来的3分钟内线性恢复至 $Q(t)=1$。\n\n使用上述韧性损失的基本定义，分别计算场景1和场景2的韧性损失 $A_1$ 和 $A_2$，并以精确比率 $r = A_1 / A_2$ 的形式报告比较结果。你的最终答案必须是一个无单位、不进行四舍五入的精确数值。",
            "solution": "问题陈述经评估有效。它在科学上基于信息物理系统韧性工程的既定原则，提法得当，具有一套清晰完整的定义和数据，且其表述是客观的。它呈现了一个可解的数学问题，没有任何逻辑矛盾、物理不可能性或模糊之处。\n\n韧性损失 $A$ 定义为在事件持续时间内，从其在 $t=0$ 时刻开始，直到系统完全恢复到其基线性能水平 $Q_{\\text{base}}=1$ 为止，性能亏损 $1 - Q(t)$ 的时间积分。在数学上，这表示为：\n$$A = \\int_{0}^{t_{\\text{recover}}} (1 - Q(t)) \\,dt$$\n其中 $t_{\\text{recover}}$ 是 $Q(t)$ 返回到 $1$ 的时间。\n\n对于所描述的由一个恒定损失阶段后跟一个线性恢复阶段组成的分段轨迹，这个积分可以从几何上进行解释。代表损失的面积由两部分组成：一个对应于恒定损失阶段的矩形，以及一个对应于线性恢复阶段的直角三角形。\n\n设 $Q_{\\text{min}}$ 为恒定损失阶段的服务水平，$t_d$ 为此阶段的持续时间，$t_r$ 为线性恢复阶段的持续时间。\n在恒定损失阶段，性能亏损恒定为 $1 - Q_{\\text{min}}$。损失的矩形部分面积 $A_{\\text{rect}}$ 是该亏损与持续时间 $t_d$ 的乘积：\n$$A_{\\text{rect}} = (1 - Q_{\\text{min}}) \\times t_d$$\n在线性恢复阶段，性能亏损在持续时间 $t_r$ 内从 $1 - Q_{\\text{min}}$ 线性减少到 $0$。这形成一个直角三角形。损失的这部分三角形面积 $A_{\\text{tri}}$ 是：\n$$A_{\\text{tri}} = \\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times t_r \\times (1 - Q_{\\text{min}})$$\n总韧性损失 $A$ 是这两个面积之和：\n$$A = A_{\\text{rect}} + A_{\\text{tri}} = (1 - Q_{\\text{min}})t_d + \\frac{1}{2}(1 - Q_{\\text{min}})t_r = (1 - Q_{\\text{min}})\\left(t_d + \\frac{t_r}{2}\\right)$$\n\n我们将此公式应用于每个场景。时间单位统一为分钟，因此它们将在最终的比率中被抵消，我们可以直接使用给定的数值进行计算。\n\n对于场景1：\n系统下降至服务水平 $Q_{\\text{min},1} = 0.4$。\n恒定损失阶段的持续时间为 $t_{d,1} = 3$ 分钟。\n线性恢复阶段的持续时间为 $t_{r,1} = 5$ 分钟。\n性能亏损为 $1 - Q_{\\text{min},1} = 1 - 0.4 = 0.6$。\n\n场景1的韧性损失 $A_1$ 计算如下：\n$$A_1 = (1 - 0.4) \\left( 3 + \\frac{5}{2} \\right)$$\n$$A_1 = 0.6 \\left( 3 + 2.5 \\right)$$\n$$A_1 = 0.6 \\times 5.5 = \\frac{6}{10} \\times \\frac{55}{10} = \\frac{3}{5} \\times \\frac{11}{2} = \\frac{33}{10} = 3.3$$\n\n对于场景2：\n系统下降至服务水平 $Q_{\\text{min},2} = 0.6$。\n恒定损失阶段的持续时间为 $t_{d,2} = 4$ 分钟。\n线性恢复阶段的持续时间为 $t_{r,2} = 3$ 分钟。\n性能亏损为 $1 - Q_{\\text{min},2} = 1 - 0.6 = 0.4$。\n\n场景2的韧性损失 $A_2$ 计算如下：\n$$A_2 = (1 - 0.6) \\left( 4 + \\frac{3}{2} \\right)$$\n$$A_2 = 0.4 \\left( 4 + 1.5 \\right)$$\n$$A_2 = 0.4 \\times 5.5 = \\frac{4}{10} \\times \\frac{55}{10} = \\frac{2}{5} \\times \\frac{11}{2} = \\frac{11}{5} = \\frac{22}{10} = 2.2$$\n\n最后，我们计算比率 $r = A_1 / A_2$。\n$$r = \\frac{A_1}{A_2} = \\frac{3.3}{2.2}$$\n为了将其表示为精确分数，我们可以写作：\n$$r = \\frac{33/10}{22/10} = \\frac{33}{22}$$\n将分子和分母同时除以它们的最大公约数11来化简该分数：\n$$r = \\frac{33 \\div 11}{22 \\div 11} = \\frac{3}{2}$$",
            "answer": "$$\\boxed{\\frac{3}{2}}$$"
        },
        {
            "introduction": "现实世界中的恢复规划很少是优化单一指标，而更像是一种权衡的艺术。系统运营商通常必须在相互竞争的目标之间取得平衡，例如最小化成本、最大化恢复速度以及实现最高的服务水平。本练习将带您从简单的指标计算过渡到一个真实的决策场景，您需要运用结构化的多标准方法在两个恢复选项之间做出选择。您将应用帕累托优势 (Pareto dominance) 和加权和效用等概念来做出合理的决策，这反映了实际韧性工程中固有的复杂权衡。",
            "id": "4240929",
            "problem": "一个公共事业运营商维护一个电网信息物理系统（Cyber-Physical System, CPS）的数字孪生（Digital Twin, DT），用于规划在遭受网络引发的物理中断后的恢复工作。全系统的服务水平由一个归一化的质量轨迹 $Q(t) \\in [0,1]$ 描述，其中 $Q(t)$ 在中断发生时下降，随后通过恢复行动得以恢复。在此背景下，韧性评估优先考虑恢复速度、服务恢复程度和资源消耗。在DT中模拟了两个候选恢复方案 $R_1$ 和 $R_2$，并通过在规划阶段测量的三个指标进行评估：\n- 恢复加速度 $A$，单位为 $\\mathrm{h}^{-1}$，表示朝向目标服务水平的一阶恢复的特征速率参数。\n- 恢复支出 $c$，单位为百万美元，表示所选恢复方案产生的总额外成本。\n- 最大增量恢复量 $\\Delta Q_{\\max}$，一个在 $[0,1]$ 区间内的无量纲分数，表示该方案在受扰基线之上可实现的服务水平归一化峰值增量。\n\nDT提供了以下指标值：\n- 对于 $R_1$：$A_1 = 0.8\\,\\mathrm{h}^{-1}$，$c_1 = 12$，$\\Delta Q_{\\max,1} = 0.35$。\n- 对于 $R_2$：$A_2 = 0.5\\,\\mathrm{h}^{-1}$，$c_2 = 9$，$\\Delta Q_{\\max,2} = 0.45$。\n\n利益相关者（监管机构、运营商和客户）已就这三个维度协商出一个总权重向量：$w_A = 0.5$，$w_c = 0.2$，$w_Q = 0.3$。为了比较异构指标，规划团队将使用反映政策中商定的期望目标和预算上限的参考值，将每个指标归一化为 $[0,1]$ 上的无量纲效用：\n- 参考加速度 $A_{\\mathrm{ref}} = 1.0\\,\\mathrm{h}^{-1}$。\n- 参考成本上限 $c_{\\mathrm{ref}} = 15$（百万美元）。\n- 参考服务恢复量 $\\Delta Q_{\\mathrm{ref}} = 0.5$。\n\n假设遵循以下决策原则：\n1. 使用具有正确目标方向的Pareto支配来排除任何被支配的方案：恢复加速度 $A$ 和最大增量恢复量 $\\Delta Q_{\\max}$ 是需要最大化的目标，而成本 $c$ 是需要最小化的目标。\n2. 如果没有方案被Pareto支配，则通过使用提供的参考值将每个指标映射到 $[0,1]$ 的效用，并对齐方向以使 $1$ 表示每个维度的理想性能，从而得出一个与利益相关者权重一致的无量纲加权和效用。\n\n据此在 $R_1$ 和 $R_2$ 之间做出决定，并以单个数字报告所选方案的加权和效用。将您的答案四舍五入到四位有效数字。将最终值表示为无量纲数。",
            "solution": "我们从与信息物理系统（CPS）韧性规划相关的基本多目标决策原则入手。归一化的服务水平 $Q(t)$ 捕捉了系统随时间的性能，而面向韧性的指标则量化了恢复速度、恢复程度和资源消耗。该决策需要在三个具有异构单位的目标上比较两个方案 $R_1$ 和 $R_2$。\n\n首先，我们应用Pareto支配。如果对于所有目标，方案 $X$ 在正确的方向上至少与方案 $Y$ 一样好，并且在至少一个目标上严格优于 $Y$，则称方案 $X$ Pareto支配方案 $Y$。这里：\n- 恢复加速度 $A$ 需要最大化。\n- 最大增量恢复量 $\\Delta Q_{\\max}$ 需要最大化。\n- 成本 $c$ 需要最小化。\n\n我们列出这些指标：\n- $R_1$：$A_1 = 0.8$，$c_1 = 12$，$\\Delta Q_{\\max,1} = 0.35$。\n- $R_2$：$A_2 = 0.5$，$c_2 = 9$，$\\Delta Q_{\\max,2} = 0.45$。\n\n比较如下：\n- 对于 $A$：$A_1 = 0.8 > 0.5 = A_2$，因此 $R_1$ 在 $A$ 上更优。\n- 对于 $c$：$c_1 = 12 > 9 = c_2$，但由于成本越低越好，因此 $R_2$ 在 $c$ 上更优。\n- 对于 $\\Delta Q_{\\max}$：$\\Delta Q_{\\max,1} = 0.35  0.45 = \\Delta Q_{\\max,2}$，因此 $R_2$ 在 $\\Delta Q_{\\max}$ 上更优。\n\n由于 $R_1$ 在 $A$ 上更优，但在 $c$ 和 $\\Delta Q_{\\max}$ 上都较差，而 $R_2$ 在两个目标上更优，但在一个目标上较差，因此没有哪个方案在所有目标上都至少与另一个方案一样好。因此，$R_1$ 和 $R_2$ 均不 Pareto 支配对方。相对于这两个方案，它们都位于 Pareto 前沿上。\n\n鉴于没有支配关系，我们着手构建一个无量纲且对齐目标方向的加权和效用。我们使用提供的参考值将每个指标归一化到 $[0,1]$ 区间：\n- 对于加速度，越高越好；一个自然的归一化方法是与参考值的比率：\n  $$u_A = \\frac{A}{A_{\\mathrm{ref}}}.$$\n- 对于成本，越低越好；我们相对于参考上限进行反转，使得 $0$ 对应达到上限，$1$ 对应零成本：\n  $$u_c = 1 - \\frac{c}{c_{\\mathrm{ref}}}.$$\n- 对于恢复量，越高越好；使用与目标的比率：\n  $$u_Q = \\frac{\\Delta Q_{\\max}}{\\Delta Q_{\\mathrm{ref}}}.$$\n\n只要 $A \\in [0, A_{\\mathrm{ref}}]$，$c \\in [0, c_{\\mathrm{ref}}]$ 且 $\\Delta Q_{\\max} \\in [0, \\Delta Q_{\\mathrm{ref}}]$，这些效用值就在 $[0,1]$ 区间内，这与规划参考值相匹配。然后，我们将它们与利益相关者权重 $w_A$、$w_c$ 和 $w_Q$ 结合起来，形成总效用：\n$$U = w_A\\,u_A + w_c\\,u_c + w_Q\\,u_Q,$$\n其中 $w_A = 0.5$，$w_c = 0.2$，以及 $w_Q = 0.3$。\n\n计算每个方案的效用。\n\n对于 $R_1$：\n- $$u_{A,1} = \\frac{A_1}{A_{\\mathrm{ref}}} = \\frac{0.8}{1.0} = 0.8.$$\n- $$u_{c,1} = 1 - \\frac{c_1}{c_{\\mathrm{ref}}} = 1 - \\frac{12}{15} = 1 - 0.8 = 0.2.$$\n- $$u_{Q,1} = \\frac{\\Delta Q_{\\max,1}}{\\Delta Q_{\\mathrm{ref}}} = \\frac{0.35}{0.5} = 0.7.$$\n因此，\n$$U_1 = (0.5)(0.8) + (0.2)(0.2) + (0.3)(0.7) = 0.4 + 0.04 + 0.21 = 0.65.$$\n\n对于 $R_2$：\n- $$u_{A,2} = \\frac{A_2}{A_{\\mathrm{ref}}} = \\frac{0.5}{1.0} = 0.5.$$\n- $$u_{c,2} = 1 - \\frac{c_2}{c_{\\mathrm{ref}}} = 1 - \\frac{9}{15} = 1 - 0.6 = 0.4.$$\n- $$u_{Q,2} = \\frac{\\Delta Q_{\\max,2}}{\\Delta Q_{\\mathrm{ref}}} = \\frac{0.45}{0.5} = 0.9.$$\n因此，\n$$U_2 = (0.5)(0.5) + (0.2)(0.4) + (0.3)(0.9) = 0.25 + 0.08 + 0.27 = 0.60.$$\n\n因此，加权和效用更倾向于 $R_1$（$U_1 = 0.65$）而不是 $R_2$（$U_2 = 0.60$）。决策是选择 $R_1$。要求的输出是所选方案的加权和效用，四舍五入到四位有效数字。将 $0.65$ 四舍五入到四位有效数字得到 $0.6500$，表示为无量纲数。",
            "answer": "$$\\boxed{0.6500}$$"
        },
        {
            "introduction": "恢复规划中的一个决定性挑战是不确定性——修复时间、资源可用性和环境条件等因素很少能被精确预知。基于名义或平均情况假设进行规划可能会导致脆弱的调度方案，在现实中表现不佳。这个动手编程练习将让您通过比较确定性调度与鲁棒调度，来展示鲁棒优化的威力。通过实施一种为最坏情况进行优化的“最大-最小”策略，您将对如何设计恢复计划获得实践性的理解，这些计划不仅能应对特定的扰动，更能抵御不确定性本身。",
            "id": "4240927",
            "problem": "您面临一个针对信息物理系统（CPS）的单维修团队恢复规划问题，该系统使用数字孪生（Digital Twin）来模拟不确定性下的调度方案。韧性指标定义为可用性（A），即可用性（A）是在一个固定时间范围内组件正常运行的时间比例。确定性调度假设修复持续时间为标稱值，而鲁棒调度则在一系列不确定性场景中最大化最差情况下的可用性。您的任务是通过基于场景的优化来计算和比较确定性调度与鲁棒调度的最差情况可用性。\n\n基本和建模假设：\n- 有一个单维修团队处理一组有限的作业（组件修复）。每个作业对应一个在已知故障时间发生的组件故障，一旦团队开始处理，该故障就会被修复。\n- 时间和持续时间以小时为单位。固定时间范围长度表示为 $H$（单位：小时）。所有故障时间和修复持续时间都以小时表示。\n- 对于每个作业 $i \\in \\{1,\\dots,M\\}$，其故障时间为 $t_i \\in [0,H]$（单位：小时）。\n- 在每个不确定性场景 $s \\in \\{1,\\dots,S\\}$ 下，作业 $i$ 的修复持续时间为 $d_{i}^{(s)} \\ge 0$（单位：小时）。\n- 维修团队遵循一个由 $\\{1,\\dots,M\\}$ 的排列 $\\pi$ 表示的静态调度；团队按照 $(\\pi_1,\\pi_2,\\dots,\\pi_M)$ 的顺序处理作业。\n- 维修团队不能在作业发生故障前进行修复。如果团队空闲下来，而序列中的下一个作业尚未发生故障，则团队将闲置等待至该作业的故障时间。在调度 $\\pi$ 和场景 $s$ 下，作业 $j$ 的开始时间由 $x_{\\pi_j}^{(s)} = \\max\\left(x_{\\pi_{j-1}}^{(s)} + d_{\\pi_{j-1}}^{(s)},\\ t_{\\pi_j}\\right)$ 给出，其中 $x_{\\pi_1}^{(s)} = \\max(0,\\ t_{\\pi_1})$。完成时间为 $c_{\\pi_j}^{(s)} = x_{\\pi_j}^{(s)} + d_{\\pi_j}^{(s)}$。\n- 对于每个作业 $i$，在场景 $s$ 中的停机时间贡献为 $c_{i}^{(s)} - t_i$（单位：小时），因为组件从故障发生到修复完成期间是不可用的。\n- 在场景 $s$ 中，所有作业的总停机时间为 $D^{(s)}(\\pi) = \\sum_{i=1}^{M} \\left(c_{i}^{(s)} - t_i\\right)$。\n- 在场景 $s$ 中，调度 $\\pi$ 的可用性（A）定义为 $A^{(s)}(\\pi) = 1 - \\dfrac{D^{(s)}(\\pi)}{M \\cdot H}$。这将停机时间通过 $M$ 个组件在时间范围 $H$ 内的最大可能正常运行时间进行归一化，确保在修复能在时间范围内完成的情况下 $A^{(s)}(\\pi) \\in [0,1]$。\n\n确定性调度与鲁棒调度：\n- 确定性调度：将一个指定的标称场景 $s_0$ 视为真实的持续时间。选择使 $A^{(s_0)}(\\pi)$ 在所有排列中最大化的 $\\pi_{\\mathrm{det}}$。\n- 鲁棒调度：选择使所有场景中的最差情况可用性最大化的 $\\pi_{\\mathrm{rob}}$，即 $\\pi_{\\mathrm{rob}} \\in \\arg\\max_{\\pi} \\min_{s \\in \\{1,\\dots,S\\}} A^{(s)}(\\pi)$。\n\n所需计算：\n- 计算确定性调度的最差情况可用性，$\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$。\n- 计算鲁棒调度的最差情况可用性，$\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}})$。\n- 计算改进量，定义为 $\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}) - \\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$。\n- 所有可用性值必须表示为小数（无单位分数）。所有时间值均以小时为单位。\n\n算法要求：\n- 对于给定的测试用例，通过枚举所有排列来找到 $\\pi_{\\mathrm{det}}$ 和 $\\pi_{\\mathrm{rob}}$。如果在选择调度时出现平局，则通过最大化所有场景的平均可用性 $\\frac{1}{S}\\sum_{s=1}^{S} A^{(s)}(\\pi)$来打破平局；如果仍然存在平局，则选择字典序最小的排列。\n- 假设修复可以超出时间范围 $H$，但停机时间的定义仍然是 $c_i^{(s)} - t_i$；在病态情况下，可用性可能小于 $0$，但给定的测试套件将是科学合理的，并将值保持在合理范围内。\n\n测试套件：\n每个测试用例由 $(M, H, \\{t_i\\}_{i=1}^{M}, \\{d_i^{(s)}\\}_{i=1}^{M} \\text{ for } s=1,\\dots,S, s_0)$ 指定，其中 $s_0$ 是用于确定性调度的标稱场景的索引。时间单位是小时。可用性必须作为小数输出。\n\n- 测试用例 1（顺利路径）：\n  - $M = 4$， $H = 20$。\n  - 故障时间：$t = [0, 2, 5, 7]$（小时）。\n  - 场景（$S = 3$）：\n    - $s = 1$：$d^{(1)} = [2, 5, 3, 4]$（小时）。\n    - $s = 2$：$d^{(2)} = [3, 6, 6, 3]$（小时）。\n    - $s = 3$：$d^{(3)} = [4, 7, 2, 5]$（小时）。\n  - 标稱场景索引：$s_0 = 1$。\n\n- 测试用例 2（边界：相同的故障时间和对称的持续时间）：\n  - $M = 4$， $H = 10$。\n  - 故障时间：$t = [0, 0, 0, 0]$（小时）。\n  - 场景（$S = 3$）：\n    - $s = 1$：$d^{(1)} = [1, 1, 1, 1]$（小时）。\n    - $s = 2$：$d^{(2)} = [2, 2, 2, 2]$（小时）。\n    - $s = 3$：$d^{(3)} = [3, 3, 3, 3]$（小时）。\n  - 标稱场景索引：$s_0 = 1$。\n\n- 测试用例 3（边缘：交错的故障和一个具有不确定持续时间的重型作业）：\n  - $M = 4$， $H = 24$。\n  - 故障时间：$t = [0, 4, 8, 12]$（小时）。\n  - 场景（$S = 3$）：\n    - $s = 1$：$d^{(1)} = [5, 1, 1, 1]$（小时）。\n    - $s = 2$：$d^{(2)} = [8, 1, 1, 1]$（小时）。\n    - $s = 3$：$d^{(3)} = [10, 1, 1, 1]$（小时）。\n  - 标稱场景索引：$s_0 = 1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的聚合结果，格式为方括号括起来的逗号分隔列表，每个测试用例贡献一个包含三个小数的子列表，顺序为 $[\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}}),\\ \\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}),\\ \\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}}) - \\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})]$。例如，输出必须如下所示：\n\"[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]\"\n所有可用性值都必须是小数。时间值的单位是小时。角度单位不适用。",
            "solution": "问题陈述已经过严格验证，被认为是信息物理系统（Cyber-Physical Systems）调度和鲁棒优化领域中一个有效、适定且具有科学依据的问题。\n\n该问题要求计算和比较单团队系统的确定性和鲁棒性修复调度。性能指标是可用性 $A$，定义为在时间范围 $H$ 内组件正常运行的时间比例。由于作业数量 $M$ 很小，解决方案需要通过枚举所有可能的作业排列来找到最优调度。\n\n问题的核心是评估一个给定的修复调度 $\\pi$ 在各种不确定性场景 $s \\in \\{1,\\dots,S\\}$ 下的可用性。一个调度 $\\pi$ 是 $M$ 个作业的排列。对于每个作业 $i \\in \\{1, \\dots, M\\}$，其故障时间为 $t_i$，在场景 $s$ 中的修复持续时间为 $d_i^{(s)}$。\n\n首先，我们必须计算在给定调度 $\\pi = (\\pi_1, \\dots, \\pi_M)$ 和场景 $s$ 下每个作业的完成时间。序列中第 $j$ 个作业的開始時間 $x_{\\pi_j}^{(s)}$ 由前一个作业的完成时间和当前作业的故障时间决定。团队在时间 $c_{\\pi_{j-1}}^{(s)}$ 完成作业 $\\pi_{j-1}$ 后可用，而作业 $\\pi_j$ 不能在其故障时间 $t_{\\pi_j}$ 之前开始。递推关系为：\n$$\nx_{\\pi_1}^{(s)} = \\max(0,\\ t_{\\pi_1})\n$$\n$$\nx_{\\pi_j}^{(s)} = \\max\\left(c_{\\pi_{j-1}}^{(s)}, t_{\\pi_j}\\right) \\quad \\text{for } j  1\n$$\n其中 $c_{\\pi_{j-1}}^{(s)} = x_{\\pi_{j-1}}^{(s)} + d_{\\pi_{j-1}}^{(s)}$ 是序列中第 $(j-1)$ 个作业的完成时间。综合这些，序列中第 $j$ 个作业的完成时间 $c_{\\pi_j}^{(s)}$ 可以迭代计算。一旦找到所有作业 $i=1,\\dots,M$ 的完成时间 $c_i^{(s)}(\\pi)$，调度 $\\pi$ 在场景 $s$ 中的总停机时间是个别组件停机时间之和：\n$$\nD^{(s)}(\\pi) = \\sum_{i=1}^{M} \\left(c_{i}^{(s)}(\\pi) - t_i\\right)\n$$\n调度 $\\pi$ 在场景 $s$ 中的可用性则由以下公式给出：\n$$\nA^{(s)}(\\pi) = 1 - \\frac{D^{(s)}(\\pi)}{M \\cdot H}\n$$\n其中 $M \\cdot H$ 是所有组件的总最大运行时间。\n\n定义了评估函数 $A^{(s)}(\\pi)$ 后，我们可以找到所需的两种调度：\n\n1.  **确定性调度 ($\\pi_{\\mathrm{det}}$)**：此调度对于单个标称场景 $s_0$ 是最优的。它是使该场景中可用性最大化的排列：\n    $$\n    \\pi_{\\mathrm{det}} \\in \\arg\\max_{\\pi} A^{(s_0)}(\\pi)\n    $$\n\n2.  **鲁棒调度 ($\\pi_{\\mathrm{rob}}$)**：此调度提供了在所有可能场景中的最佳保证性能。它是最大化最差情况（最小）可用性的排列：\n    $$\n    \\pi_{\\mathrm{rob}} \\in \\arg\\max_{\\pi} \\min_{s \\in \\{1,\\dots,S\\}} A^{(s)}(\\pi)\n    $$\n\n问题指定了一个清晰的、分层的平局打破规则。如果多个排列产生相同的最优目标值，则选择在所有场景中具有更高平均可用性 $\\frac{1}{S}\\sum_{s=1}^{S} A^{(s)}(\\pi)$ 的那一个。如果仍然存在平局，则选择字典序最小的排列。\n\n该解决方案通过为每个测试用例执行以下步骤来实现：\n1.  生成作业索引 $\\{0, \\dots, M-1\\}$ 的所有 $M!$ 个排列。\n2.  对于每个排列 $\\pi$，计算可用性向量 $[A^{(1)}(\\pi), \\dots, A^{(S)}(\\pi)]$。\n3.  对于每个排列，还要计算其在标稱场景下的可用性 $A^{(s_0)}(\\pi)$、其最差情况（最小）可用性 $\\min_s A^{(s)}(\\pi)$ 以及其平均可用性 $\\frac{1}{S}\\sum_s A^{(s)}(\\pi)$。\n4.  为了找到 $\\pi_{\\mathrm{det}}$，根据一个标准元组对所有排列进行排序，主目标和次要目标按降序，第三目标按升序：$(A^{(s_0)}(\\pi), \\frac{1}{S}\\sum_s A^{(s)}(\\pi), \\pi)$。顶部的条目即为 $\\pi_{\\mathrm{det}}$。\n5.  为了找到 $\\pi_{\\mathrm{rob}}$，使用标准 $(\\min_s A^{(s)}(\\pi), \\frac{1}{S}\\sum_s A^{(s)}(\\pi), \\pi)$ 进行类似排序。顶部的条目即为 $\\pi_{\\mathrm{rob}}$。\n6.  最后，计算所需的值：确定性调度的最差情况可用性 $\\min_{s} A^{(s)}(\\pi_{\\mathrm{det}})$；鲁棒调度的最差情况可用性 $\\min_{s} A^{(s)}(\\pi_{\\mathrm{rob}})$；以及改进量，即两者之差。\n\n这个过程虽然对于大的 $M$ 来说计算量很大，但保证能为测试套件中指定的小值（$M=4$）找到正确的 optimal 调度。计算使用浮点运算来生成所需的小数输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"M\": 4, \"H\": 20.0,\n            \"t\": [0.0, 2.0, 5.0, 7.0],\n            \"d_scenarios\": [\n                [2.0, 5.0, 3.0, 4.0],\n                [3.0, 6.0, 6.0, 3.0],\n                [4.0, 7.0, 2.0, 5.0]\n            ],\n            \"s0\": 1\n        },\n        # Test case 2\n        {\n            \"M\": 4, \"H\": 10.0,\n            \"t\": [0.0, 0.0, 0.0, 0.0],\n            \"d_scenarios\": [\n                [1.0, 1.0, 1.0, 1.0],\n                [2.0, 2.0, 2.0, 2.0],\n                [3.0, 3.0, 3.0, 3.0]\n            ],\n            \"s0\": 1\n        },\n        # Test case 3\n        {\n            \"M\": 4, \"H\": 24.0,\n            \"t\": [0.0, 4.0, 8.0, 12.0],\n            \"d_scenarios\": [\n                [5.0, 1.0, 1.0, 1.0],\n                [8.0, 1.0, 1.0, 1.0],\n                [10.0, 1.0, 1.0, 1.0]\n            ],\n            \"s0\": 1\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        M, H, t, d_scenarios, s0 = case[\"M\"], case[\"H\"], case[\"t\"], case[\"d_scenarios\"], case[\"s0\"]\n        \n        S = len(d_scenarios)\n        s0_idx = s0 - 1\n        job_indices = range(M)\n        \n        all_perms = list(itertools.permutations(job_indices))\n        \n        eval_results = []\n        for pi in all_perms:\n            # Calculate availability for pi under all scenarios\n            availabilities = []\n            for s in range(S):\n                d_s = d_scenarios[s]\n                completion_times = {}\n                prev_c = 0.0\n                \n                for job_idx in pi:\n                    start_time = max(prev_c, t[job_idx])\n                    completion_time = start_time + d_s[job_idx]\n                    completion_times[job_idx] = completion_time\n                    prev_c = completion_time\n                \n                total_downtime = 0.0\n                for i in range(M):\n                    total_downtime += completion_times[i] - t[i]\n                \n                availability_s = 1.0 - total_downtime / (M * H)\n                availabilities.append(availability_s)\n                \n            min_A = min(availabilities)\n            avg_A = np.mean(availabilities)\n            nominal_A = availabilities[s0_idx]\n            \n            eval_results.append({\n                \"pi\": pi,\n                \"availabilities\": availabilities,\n                \"nominal_A\": nominal_A,\n                \"min_A\": min_A,\n                \"avg_A\": avg_A\n            })\n\n        # Find pi_det using tie-breaking rules\n        # Sort by nominal_A (desc), then avg_A (desc), then pi (asc)\n        det_candidates = sorted(eval_results, key=lambda x: (-x[\"nominal_A\"], -x[\"avg_A\"], x[\"pi\"]))\n        pi_det_result = det_candidates[0]\n\n        # Find pi_rob using tie-breaking rules\n        # Sort by min_A (desc), then avg_A (desc), then pi (asc)\n        rob_candidates = sorted(eval_results, key=lambda x: (-x[\"min_A\"], -x[\"avg_A\"], x[\"pi\"]))\n        pi_rob_result = rob_candidates[0]\n\n        # Calculate required outputs\n        worst_case_A_det = min(pi_det_result[\"availabilities\"])\n        worst_case_A_rob = pi_rob_result[\"min_A\"] # This is the value we maximized\n        improvement = worst_case_A_rob - worst_case_A_det\n\n        all_results.append([worst_case_A_det, worst_case_A_rob, improvement])\n\n    # Format output string to match \"[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3]]\"\n    inner_results_str = []\n    for res in all_results:\n        # Format each sub-list without spaces\n        inner_results_str.append(f\"[{','.join(map(str, res))}]\")\n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}