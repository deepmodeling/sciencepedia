{
    "hands_on_practices": [
        {
            "introduction": "Understanding formal specifications begins with computing their meaning on a given signal. This first practice provides a foundational exercise in calculating the quantitative semantics, or robustness, for a Signal Temporal Logic (STL) formula. You will work with the 'Globally' operator, $\\mathbf{G}$, which asserts that a property must hold continuously over a specified time interval, and connect its robustness value to the most extreme violation of the property .",
            "id": "4222915",
            "problem": "Consider a scalar Cyber-Physical System (CPS) signal specified by the digital twin as the continuous-time function $x:\\mathbb{R}_{\\ge 0}\\to\\mathbb{R}$ with $x(t)=\\sin t$. A requirement is formalized in Signal Temporal Logic (STL) as the formula $\\varphi=\\mathbf{G}_{[0,2\\pi]}\\,\\big(x(t)\\ge 0\\big)$, interpreted at the initial time $t=0$. Use the standard robust (quantitative) semantics of STL based on signed distances in the Euclidean metric on $\\mathbb{R}$, where for an atomic predicate $\\mu$ of the form $h(x(t))\\ge 0$ the robustness at time $t$ is $\\rho_{\\mu}(x,t)=h(x(t))$, the robustness of negation is $\\rho_{\\neg\\psi}(x,t)=-\\rho_{\\psi}(x,t)$, the robustness of conjunction is $\\rho_{\\psi_{1}\\wedge\\psi_{2}}(x,t)=\\min\\{\\rho_{\\psi_{1}}(x,t),\\rho_{\\psi_{2}}(x,t)\\}$, and the robustness of the globally operator is $\\rho_{\\mathbf{G}_{I}\\psi}(x,0)=\\inf_{\\tau\\in I}\\rho_{\\psi}(x,\\tau)$. \n\nStarting from these core definitions and standard properties of the sine function, determine whether the qualitative satisfaction $x\\models\\varphi$ holds and identify the exact time subintervals within $[0,2\\pi]$ where the predicate $x(t)\\ge 0$ is violated. Then compute the robustness $\\rho_{\\varphi}(x,0)$ as a single exact real number. For grading purposes, report only the robustness value as your final numerical answer. No rounding is required, and no physical units are involved. Angles are in radians.",
            "solution": "The problem requires the evaluation of a Signal Temporal Logic (STL) formula, $\\varphi=\\mathbf{G}_{[0,2\\pi]}\\,\\big(x(t)\\ge 0\\big)$, for a given signal $x(t)=\\sin t$. The evaluation involves determining both the qualitative satisfaction and the quantitative robustness, interpreted at time $t=0$.\n\nFirst, we analyze the structure of the STL formula $\\varphi$. It consists of a \"globally\" operator, $\\mathbf{G}_{I}$, applied over the time interval $I=[0, 2\\pi]$ to an atomic predicate, which we can denote as $\\psi$. The atomic predicate is $\\psi \\equiv \\big(x(t)\\ge 0\\big)$.\n\nThe predicate $\\psi$ is of the general form $h(x(t))\\ge 0$. In this specific case, the function $h$ is the identity function, i.e., $h(z)=z$, so that $h(x(t)) = x(t)$. The signal is given as $x(t) = \\sin t$. Therefore, the expression inside the predicate is simply $\\sin t \\ge 0$.\n\nAccording to the provided definition for the robust semantics of an atomic predicate, its robustness at a given time $\\tau$ is $\\rho_{\\psi}(x,\\tau) = h(x(\\tau))$. For our problem, this becomes:\n$$\n\\rho_{\\psi}(x,\\tau) = x(\\tau) = \\sin \\tau\n$$\n\nWe first address the qualitative satisfaction, denoted $x \\models \\varphi$. This is a Boolean property. The formula $\\varphi = \\mathbf{G}_{[0,2\\pi]}\\,(x(t)\\ge 0)$ is true if and only if the predicate $x(t)\\ge 0$ holds for all times $t$ in the interval $[0, 2\\pi]$. We must check if $\\sin t \\ge 0$ for all $t \\in [0, 2\\pi]$. The sine function is known to be non-negative for $t \\in [0, \\pi]$ and strictly negative for $t \\in (\\pi, 2\\pi)$. Since there exist times $t$ within the interval $[0, 2\\pi]$ for which $\\sin t < 0$, the condition is not satisfied for the entire interval. Specifically, the predicate $x(t) \\ge 0$ is violated on the open time subinterval $(\\pi, 2\\pi)$. Consequently, the qualitative satisfaction does not hold, i.e., $x \\not\\models \\varphi$.\n\nNext, we compute the quantitative robustness of the formula $\\varphi$ at the initial time $t=0$, denoted $\\rho_{\\varphi}(x,0)$. The definition for the robustness of the globally operator $\\mathbf{G}_{I}$ is given as:\n$$\n\\rho_{\\mathbf{G}_{I}\\psi}(x,0) = \\inf_{\\tau\\in I}\\rho_{\\psi}(x,\\tau)\n$$\nIn our case, the interval is $I = [0, 2\\pi]$ and the atomic robustness is $\\rho_{\\psi}(x,\\tau) = \\sin \\tau$. Substituting these into the formula, we get:\n$$\n\\rho_{\\varphi}(x,0) = \\inf_{\\tau\\in [0,2\\pi]} (\\sin \\tau)\n$$\nThis reduces the problem to finding the infimum (greatest lower bound) of the function $\\sin \\tau$ over the closed interval $[0, 2\\pi]$. Since the function $f(\\tau) = \\sin \\tau$ is continuous on the compact (closed and bounded) interval $[0, 2\\pi]$, the Extreme Value Theorem guarantees that it attains its minimum value on this interval. The infimum is therefore equal to the global minimum of the function on this interval.\n\nThe range of the sine function is $[-1, 1]$. We need to find the minimum value it takes for $\\tau \\in [0, 2\\pi]$. The minimum value of $\\sin \\tau$ is $-1$, and this value is attained at $\\tau = \\frac{3\\pi}{2}$. Since $\\frac{3\\pi}{2}$ is an element of the interval $[0, 2\\pi]$, the minimum value of $\\sin \\tau$ on this interval is indeed $-1$.\n\nTherefore, the robustness value is:\n$$\n\\rho_{\\varphi}(x,0) = \\min_{\\tau\\in [0,2\\pi]} (\\sin \\tau) = -1\n$$\nThe negative robustness value $\\rho_{\\varphi}(x,0) = -1 < 0$ is consistent with the qualitative finding that the property is violated ($x \\not\\models \\varphi$). The magnitude of the robustness, $|-1|=1$, quantifies the extent of the violation, representing the maximum signed distance by which the signal $x(t)$ drops below the threshold $0$.",
            "answer": "$$\\boxed{-1}$$"
        },
        {
            "introduction": "Cyber-physical systems operate in continuous time, but their digital twins monitor them through discrete samples. This practice bridges that fundamental gap by exploring the relationship between a continuous-time specification and the required fidelity of its digital monitor. You will determine the maximum sampling period that guarantees a critical system behavior is not missed by the discrete observations, a core challenge in designing reliable monitoring systems .",
            "id": "4222939",
            "problem": "Consider a cyber-physical system (CPS) whose plant state is a scalar output modeled by a continuous-time signal $x : \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}$ given by $x(t) = \\sin(\\omega t)$, where $\\omega$ is the angular frequency of the oscillator. Assume $\\omega = 1$ so that $x(t) = \\sin(t)$, with angles measured in radians and time in seconds. The system’s digital twin monitors $x(t)$ by uniform sampling at times $t_{k} = k \\Delta t$ for $k \\in \\mathbb{N}$ (zero sampling jitter and zero latency), producing a discrete-time observation $x[k] = x(t_{k})$.\n\nLet $\\varphi$ be a Metric Temporal Logic (MTL) formula defined as $\\varphi = \\mathbf{F}_{[0,\\pi]}(x \\ge 0.5)$. Under the continuous-time semantics of the bounded “Eventually” operator $\\mathbf{F}_{I}$ on an interval $I \\subseteq \\mathbb{R}_{\\ge 0}$, the formula $\\varphi$ is satisfied at time $t = 0$ if and only if there exists $t' \\in [0,\\pi]$ such that $x(t') \\ge 0.5$.\n\nIn order for the digital twin’s sampled trace to be sound for monitoring $\\varphi$ at $t=0$—that is, whenever the continuous plant satisfies $\\varphi$ at $t=0$, the sampled trace contains at least one index $k$ with $t_{k} \\in [0,\\pi]$ and $x[k] \\ge 0.5$—one must choose the sampling period $\\Delta t$ small enough to avoid missing the contiguous satisfaction window of the predicate $x \\ge 0.5$ within $[0,\\pi]$.\n\nStarting only from:\n- the definition of the continuous-time semantics of $\\mathbf{F}_{[0,\\pi]}$,\n- the trigonometric fact that $x(t) = \\sin(t)$ is strictly increasing on $[0,\\frac{\\pi}{2}]$ and strictly decreasing on $[\\frac{\\pi}{2},\\pi]$,\n- and the inverse-sine relation for thresholds of the form $\\sin(t) \\ge \\alpha$ with $\\alpha \\in (0,1)$,\n\nderive the tightest upper bound $\\Delta t^{\\star}$ on the sampling period such that any uniform sampler with $\\Delta t \\le \\Delta t^{\\star}$ must include at least one sample instant in the satisfaction window of $x \\ge 0.5$ within $[0,\\pi]$. Express your final answer for $\\Delta t^{\\star}$ in seconds. No rounding is required. Angles must be treated in radians.",
            "solution": "The problem requires finding the tightest upper bound on the sampling period, $\\Delta t^{\\star}$, that guarantees at least one sample point lands within the satisfaction window of the predicate $x(t) \\ge 0.5$ for the signal $x(t)=\\sin(t)$ over the interval $[0, \\pi]$.\n\nFirst, we identify the satisfaction window, which is the set of time instants $t \\in [0, \\pi]$ where $\\sin(t) \\ge 0.5$. To find this, we solve the equality $\\sin(t) = 0.5$.\nUsing the inverse-sine function, the principal solution is $t_1 = \\arcsin(0.5) = \\frac{\\pi}{6}$.\nDue to the symmetry of the sine function about $t = \\frac{\\pi}{2}$ in the interval $[0, \\pi]$, the second solution is $t_2 = \\pi - t_1 = \\pi - \\frac{\\pi}{6} = \\frac{5\\pi}{6}$.\nThe function $\\sin(t)$ is greater than or equal to $0.5$ between these two points. Thus, the satisfaction window is the continuous interval $S = [\\frac{\\pi}{6}, \\frac{5\\pi}{6}]$.\n\nThe duration of this satisfaction window is:\n$$L_S = t_2 - t_1 = \\frac{5\\pi}{6} - \\frac{\\pi}{6} = \\frac{4\\pi}{6} = \\frac{2\\pi}{3} \\text{ seconds}$$\n\nTo guarantee that at least one sample from a uniform sampler falls within this interval, regardless of the sampler's phase, the sampling period $\\Delta t$ must not exceed the length of the interval, $L_S$. If $\\Delta t > L_S$, it would be possible for two consecutive samples to fall just outside the interval on either side, thus \"missing\" it entirely.\nTherefore, the condition is $\\Delta t \\le L_S$.\n\nThe tightest upper bound, $\\Delta t^{\\star}$, is the maximum allowed value for $\\Delta t$, which is precisely the length of the interval.\n$$\\Delta t^{\\star} = L_S = \\frac{2\\pi}{3}$$",
            "answer": "$$\n\\boxed{\\frac{2\\pi}{3}}\n$$"
        },
        {
            "introduction": "Moving from manual calculation to automated analysis is a crucial step in applying formal methods to real-world systems. This practice challenges you to implement a software algorithm that computes the robustness of a composite Signal Temporal Logic (STL) formula involving logical and temporal operators. By working with sampled data and a set of test cases, you will translate the recursive definitions of STL semantics into a practical monitoring tool, solidifying your understanding of how these specifications are evaluated in code .",
            "id": "4222933",
            "problem": "Consider a Cyber-Physical System (CPS) paired with a Digital Twin, monitored by a formal specification written in Signal Temporal Logic (STL). Let the formula be $\\varphi = \\mathbf{G}_{[0,10]}(x \\le 2) \\wedge \\mathbf{F}_{[3,7]}(y \\ge 1)$, where $x$ and $y$ are real-valued signals sampled from the CPS at a uniform sampling period $\\Delta t = 0.1 \\text{ s}$. You are asked to implement the computation of the quantitative robustness of $\\varphi$ at the evaluation time $t = 5 \\text{ s}$ using sampled data arrays $x[k]$ and $y[k]$.\n\nFor quantitative semantics, use the following standard and widely accepted base principles for Signal Temporal Logic (STL):\n- Atomic predicate robustness: for $(x \\le 2)$, the robustness at time $t$ is $2 - x(t)$; for $(y \\ge 1)$, the robustness at time $t$ is $y(t) - 1$.\n- Conjunction semantics: the robustness of $\\psi_1 \\wedge \\psi_2$ is the minimum of the robustnesses of $\\psi_1$ and $\\psi_2$ at the same time.\n- Temporal operator semantics: the robustness of $\\mathbf{G}_{[a,b]} \\psi$ at time $t$ is the infimum of the robustness of $\\psi$ over all times in $t + [a,b]$; the robustness of $\\mathbf{F}_{[a,b]} \\psi$ at time $t$ is the supremum of the robustness of $\\psi$ over all times in $t + [a,b]$.\n\nAssume discrete-time evaluation aligned with the sampling grid. Let $t_k = k \\Delta t$ and let $k_0$ be such that $t_{k_0} = t$. For discrete evaluation windows, replace the continuous infimum and supremum by the minimum and maximum over sampled indices. Use inclusive interval bounds with index mapping defined exactly by $I_{\\mathbf{G}} = \\{k \\mid k_0 + \\lceil 0 / \\Delta t \\rceil \\le k \\le k_0 + \\lfloor 10 / \\Delta t \\rfloor\\}$ and $I_{\\mathbf{F}} = \\{k \\mid k_0 + \\lceil 3 / \\Delta t \\rceil \\le k \\le k_0 + \\lfloor 7 / \\Delta t \\rfloor\\}$. Angles used in any trigonometric signal definitions must be interpreted in radians.\n\nYour program must implement this robustness computation and evaluate it for the following test suite of four cases. In all cases, use $\\Delta t = 0.1 \\text{ s}$, $t \\in [0,15] \\text{ s}$, $t = 5 \\text{ s}$, and signals defined for $k = 0,1,2,\\dots,150$ so that $t_k = k \\Delta t$ covers the necessary windows. For each case, generate $x[k]$ and $y[k]$ according to the provided rules:\n\n- Case $1$ (general variation, happy path): $x[k] = 1.5 + 0.3 \\sin(0.5 \\, t_k)$ and $y[k] = 0.6 + 0.5 \\sin(0.7 \\, t_k)$. The sine arguments are in radians.\n- Case $2$ (boundary condition): $x[k] = 2.0$ and $y[k] = 1.0$ for all $k$.\n- Case $3$ (violation in the $\\mathbf{F}$ subformula): $x[k] = 1.0$ for all $k$ and $y[k] = 0.9$ for all $k$.\n- Case $4$ (violation in the $\\mathbf{G}$ subformula): $x[k] = 1.8$ for all $k$ except for indices with $t_k \\in [7.0, 7.5]$, where $x[k] = 2.5$; $y[k] = 1.2$ for all $k$.\n\nCompute the robustness value of $\\varphi$ at $t = 5 \\text{ s}$ for each case. The final output must be a single line containing the four robustness values in a comma-separated list enclosed in square brackets, in the order of the cases $1$ through $4$, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a real number. No units are required for robustness values. Ensure the program is self-contained and uses the specified runtime environment.\n\nYour implementation must strictly follow the discrete index mapping described above and must treat interval endpoints as inclusive. Your algorithm should not rely on any continuous-time interpolation. The output must be reproducible and deterministic given the signals as defined. The angle unit for any trigonometric function is radians.",
            "solution": "The objective is to compute the quantitative robustness of the STL formula $\\varphi = \\mathbf{G}_{[0,10]}(x \\le 2) \\wedge \\mathbf{F}_{[3,7]}(y \\ge 1)$ at the evaluation time $t = 5 \\text{ s}$ for a discrete-time system with sampling period $\\Delta t = 0.1 \\text{ s}$.\n\nThe computation proceeds by recursively evaluating the robustness of the subformulas based on the provided semantic rules.\n\n1.  **Formula Decomposition**: The top-level formula $\\varphi$ is a conjunction of two subformulas, $\\varphi_G = \\mathbf{G}_{[0,10]}(x \\le 2)$ and $\\varphi_F = \\mathbf{F}_{[3,7]}(y \\ge 1)$. The overall robustness is the minimum of the subformulas' robustnesses:\n    $$\n    \\rho(\\varphi, t) = \\min(\\rho(\\varphi_G, t), \\rho(\\varphi_F, t))\n    $$\n\n2.  **Discretization**: The evaluation time $t = 5 \\text{ s}$ corresponds to the discrete time index $k_0 = t / \\Delta t = 5 / 0.1 = 50$.\n\n3.  **Robustness of $\\varphi_G = \\mathbf{G}_{[0,10]}(x \\le 2)$**:\n    - The robustness of the atomic predicate $\\psi_x = (x \\le 2)$ at index $k$ is $\\rho(\\psi_x, k) = 2 - x[k]$.\n    - The robustness of the 'Globally' operator is the minimum of the atomic robustnesses over its time window. The discrete index window $I_G$ for the time interval $[t, t+10]$ (i.e., $[5, 15]$) is:\n      $I_G = \\{k \\mid k_0 + \\lceil 0/0.1 \\rceil \\le k \\le k_0 + \\lfloor 10/0.1 \\rfloor\\} = \\{k \\mid 50 \\le k \\le 150\\}$.\n    - The robustness is therefore: $\\rho(\\varphi_G, 50) = \\min_{k=50, \\dots, 150} (2 - x[k])$.\n\n4.  **Robustness of $\\varphi_F = \\mathbf{F}_{[3,7]}(y \\ge 1)$**:\n    - The robustness of the atomic predicate $\\psi_y = (y \\ge 1)$ at index $k$ is $\\rho(\\psi_y, k) = y[k] - 1$.\n    - The robustness of the 'Eventually' operator is the maximum of the atomic robustnesses over its window. The discrete index window $I_F$ for the time interval $[t+3, t+7]$ (i.e., $[8, 12]$) is:\n      $I_F = \\{k \\mid k_0 + \\lceil 3/0.1 \\rceil \\le k \\le k_0 + \\lfloor 7/0.1 \\rfloor\\} = \\{k \\mid 80 \\le k \\le 120\\}$.\n    - The robustness is therefore: $\\rho(\\varphi_F, 50) = \\max_{k=80, \\dots, 120} (y[k] - 1)$.\n\n5.  **Final Robustness Formula**:\n    Combining these, the final robustness value is computed using the generated signal arrays $x[k]$ and $y[k]$:\n    $$\n    \\rho(\\varphi, 50) = \\min \\left( \\min_{k=50, \\dots, 150} (2 - x[k]), \\max_{k=80, \\dots, 120} (y[k] - 1) \\right)\n    $$\n    This formula is implemented to evaluate the four test cases.\n    - **Case 1**: A general case where robustness depends on the extrema of sine functions over the windows.\n    - **Case 2** (Boundary): With $x[k]=2$ and $y[k]=1$, $\\rho_G=0$, $\\rho_F=0$, so the final robustness is $\\min(0,0)=0$.\n    - **Case 3** (F-violation): With $x[k]=1$ and $y[k]=0.9$, $\\rho_G=1$, $\\rho_F=-0.1$, so the final robustness is $\\min(1, -0.1)=-0.1$.\n    - **Case 4** (G-violation): With $x[k]$ violating its bound inside the G-window (giving $\\rho_G=-0.5$) and $y[k]$ satisfying its bound inside the F-window (giving $\\rho_F=0.2$), the final robustness is $\\min(-0.5, 0.2)=-0.5$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the quantitative robustness for an STL formula for four test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # We will simply use numbers 1 through 4 to identify the cases.\n    test_cases = [1, 2, 3, 4]\n\n    results = []\n    for case_num in test_cases:\n        # --- Problem Parameters ---\n        delta_t = 0.1\n        t_eval = 5.0\n        \n        # The signals are defined for t_k up to 15s, so we need k up to 150.\n        k_max = 150\n        time_vector = np.arange(k_max + 1) * delta_t # t_k = k * delta_t\n\n        # --- Signal Generation ---\n        if case_num == 1:\n            # Case 1: General variation\n            x_signal = 1.5 + 0.3 * np.sin(0.5 * time_vector)\n            y_signal = 0.6 + 0.5 * np.sin(0.7 * time_vector)\n        elif case_num == 2:\n            # Case 2: Boundary condition\n            x_signal = np.full_like(time_vector, 2.0)\n            y_signal = np.full_like(time_vector, 1.0)\n        elif case_num == 3:\n            # Case 3: Violation in the F subformula\n            x_signal = np.full_like(time_vector, 1.0)\n            y_signal = np.full_like(time_vector, 0.9)\n        elif case_num == 4:\n            # Case 4: Violation in the G subformula\n            x_signal = np.full_like(time_vector, 1.8)\n            # Anomaly for t_k in [7.0, 7.5]\n            # k * delta_t >= 7.0 => k >= 70\n            # k * delta_t = 7.5 => k = 75\n            anomaly_indices = np.where((time_vector >= 7.0)  (time_vector = 7.5))\n            x_signal[anomaly_indices] = 2.5\n            y_signal = np.full_like(time_vector, 1.2)\n\n        # --- Robustness Computation ---\n        k0 = int(t_eval / delta_t)\n\n        # Evaluate subformula phi_G = G_[0,10](x = 2)\n        # Robustness of (x = 2) at index k is (2 - x[k])\n        # Robustness of G_[a,b](psi) is min_{k in window}(rho(psi, k))\n        \n        # Define the discrete index window for G\n        a_g, b_g = 0.0, 10.0\n        k_start_g = k0 + int(np.ceil(a_g / delta_t))\n        k_end_g = k0 + int(np.floor(b_g / delta_t))\n        \n        # Extract the signal values over the window\n        x_window = x_signal[k_start_g : k_end_g + 1]\n        \n        # Compute robustness for the G subformula\n        rob_g = np.min(2.0 - x_window)\n\n        # Evaluate subformula phi_F = F_[3,7](y >= 1)\n        # Robustness of (y >= 1) at index k is (y[k] - 1)\n        # Robustness of F_[a,b](psi) is max_{k in window}(rho(psi, k))\n\n        # Define the discrete index window for F\n        a_f, b_f = 3.0, 7.0\n        k_start_f = k0 + int(np.ceil(a_f / delta_t))\n        k_end_f = k0 + int(np.floor(b_f / delta_t))\n\n        # Extract the signal values over the window\n        y_window = y_signal[k_start_f : k_end_f + 1]\n        \n        # Compute robustness for the F subformula\n        rob_f = np.max(y_window - 1.0)\n        \n        # Final robustness is for phi_G AND phi_F\n        # rho(psi1 AND psi2) = min(rho(psi1), rho(psi2))\n        final_robustness = min(rob_g, rob_f)\n        \n        results.append(final_robustness)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}