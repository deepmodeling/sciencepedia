{
    "hands_on_practices": [
        {
            "introduction": "Understanding formal specifications begins with moving beyond simple true/false checks to quantitative assessments. This first practice introduces the concept of *robustness* for a fundamental \"Always\" or \"Globally\" ($\\mathbf{G}$) property, which asserts that a condition must hold throughout a time interval. By calculating the robustness for a simple sinusoidal signal, you will learn how this quantitative metric captures not just whether a specification is met, but by how much, providing a deeper insight into system behavior .",
            "id": "4222915",
            "problem": "Consider a scalar Cyber-Physical System (CPS) signal specified by the digital twin as the continuous-time function $x:\\mathbb{R}_{\\ge 0}\\to\\mathbb{R}$ with $x(t)=\\sin t$. A requirement is formalized in Signal Temporal Logic (STL) as the formula $\\varphi=\\mathbf{G}_{[0,2\\pi]}\\,\\big(x(t)\\ge 0\\big)$, interpreted at the initial time $t=0$. Use the standard robust (quantitative) semantics of STL based on signed distances in the Euclidean metric on $\\mathbb{R}$, where for an atomic predicate $\\mu$ of the form $h(x(t))\\ge 0$ the robustness at time $t$ is $\\rho_{\\mu}(x,t)=h(x(t))$, the robustness of negation is $\\rho_{\\neg\\psi}(x,t)=-\\rho_{\\psi}(x,t)$, the robustness of conjunction is $\\rho_{\\psi_{1}\\wedge\\psi_{2}}(x,t)=\\min\\{\\rho_{\\psi_{1}}(x,t),\\rho_{\\psi_{2}}(x,t)\\}$, and the robustness of the globally operator is $\\rho_{\\mathbf{G}_{I}\\psi}(x,0)=\\inf_{\\tau\\in I}\\rho_{\\psi}(x,\\tau)$. \n\nStarting from these core definitions and standard properties of the sine function, determine whether the qualitative satisfaction $x\\models\\varphi$ holds and identify the exact time subintervals within $[0,2\\pi]$ where the predicate $x(t)\\ge 0$ is violated. Then compute the robustness $\\rho_{\\varphi}(x,0)$ as a single exact real number. For grading purposes, report only the robustness value as your final numerical answer. No rounding is required, and no physical units are involved. Angles are in radians.",
            "solution": "The problem requires the evaluation of a Signal Temporal Logic (STL) formula, $\\varphi=\\mathbf{G}_{[0,2\\pi]}\\,\\big(x(t)\\ge 0\\big)$, for a given signal $x(t)=\\sin t$. The evaluation involves determining both the qualitative satisfaction and the quantitative robustness, interpreted at time $t=0$.\n\nFirst, we analyze the structure of the STL formula $\\varphi$. It consists of a \"globally\" operator, $\\mathbf{G}_{I}$, applied over the time interval $I=[0, 2\\pi]$ to an atomic predicate, which we can denote as $\\psi$. The atomic predicate is $\\psi \\equiv \\big(x(t)\\ge 0\\big)$.\n\nThe predicate $\\psi$ is of the general form $h(x(t))\\ge 0$. In this specific case, the function $h$ is the identity function, i.e., $h(z)=z$, so that $h(x(t)) = x(t)$. The signal is given as $x(t) = \\sin t$. Therefore, the expression inside the predicate is simply $\\sin t \\ge 0$.\n\nAccording to the provided definition for the robust semantics of an atomic predicate, its robustness at a given time $\\tau$ is $\\rho_{\\psi}(x,\\tau) = h(x(\\tau))$. For our problem, this becomes:\n$$\n\\rho_{\\psi}(x,\\tau) = x(\\tau) = \\sin \\tau\n$$\n\nWe first address the qualitative satisfaction, denoted $x \\models \\varphi$. This is a Boolean property. The formula $\\varphi = \\mathbf{G}_{[0,2\\pi]}\\,(x(t)\\ge 0)$ is true if and only if the predicate $x(t)\\ge 0$ holds for all times $t$ in the interval $[0, 2\\pi]$. We must check if $\\sin t \\ge 0$ for all $t \\in [0, 2\\pi]$. The sine function is known to be non-negative for $t \\in [0, \\pi]$ and strictly negative for $t \\in (\\pi, 2\\pi)$. Since there exist times $t$ within the interval $[0, 2\\pi]$ for which $\\sin t  0$, the condition is not satisfied for the entire interval. Specifically, the predicate $x(t) \\ge 0$ is violated on the open time subinterval $(\\pi, 2\\pi)$. Consequently, the qualitative satisfaction does not hold, i.e., $x \\not\\models \\varphi$.\n\nNext, we compute the quantitative robustness of the formula $\\varphi$ at the initial time $t=0$, denoted $\\rho_{\\varphi}(x,0)$. The definition for the robustness of the globally operator $\\mathbf{G}_{I}$ is given as:\n$$\n\\rho_{\\mathbf{G}_{I}\\psi}(x,0) = \\inf_{\\tau\\in I}\\rho_{\\psi}(x,\\tau)\n$$\nIn our case, the interval is $I = [0, 2\\pi]$ and the atomic robustness is $\\rho_{\\psi}(x,\\tau) = \\sin \\tau$. Substituting these into the formula, we get:\n$$\n\\rho_{\\varphi}(x,0) = \\inf_{\\tau\\in [0,2\\pi]} (\\sin \\tau)\n$$\nThis reduces the problem to finding the infimum (greatest lower bound) of the function $\\sin \\tau$ over the closed interval $[0, 2\\pi]$. Since the function $f(\\tau) = \\sin \\tau$ is continuous on the compact (closed and bounded) interval $[0, 2\\pi]$, the Extreme Value Theorem guarantees that it attains its minimum value on this interval. The infimum is therefore equal to the global minimum of the function on this interval.\n\nThe range of the sine function is $[-1, 1]$. We need to find the minimum value it takes for $\\tau \\in [0, 2\\pi]$. The minimum value of $\\sin \\tau$ is $-1$, and this value is attained at $\\tau = \\frac{3\\pi}{2}$. Since $\\frac{3\\pi}{2}$ is an element of the interval $[0, 2\\pi]$, the minimum value of $\\sin \\tau$ on this interval is indeed $-1$.\n\nTherefore, the robustness value is:\n$$\n\\rho_{\\varphi}(x,0) = \\min_{\\tau\\in [0,2\\pi]} (\\sin \\tau) = -1\n$$\nThe negative robustness value $\\rho_{\\varphi}(x,0) = -1  0$ is consistent with the qualitative finding that the property is violated ($x \\not\\models \\varphi$). The magnitude of the robustness, $|-1|=1$, quantifies the extent of the violation, representing the maximum signed distance by which the signal $x(t)$ drops below the threshold $0$.",
            "answer": "$$\\boxed{-1}$$"
        },
        {
            "introduction": "Building on the \"Always\" operator, this exercise explores its logical dual, the \"Eventually\" or \"Finally\" ($\\mathbf{F}$) operator, which requires a condition to be met at least once within an interval. The true power of robustness, however, lies in its application; this practice demonstrates how the computed robustness value serves as a crucial guide for system testing and validation. You will see how the sign and magnitude of the robustness can direct a search for failure scenarios, a process known as falsification, which is essential for ensuring the safety and reliability of Cyber-Physical Systems .",
            "id": "4222917",
            "problem": "Consider a Cyber-Physical System (CPS) monitored by a digital twin. The digital twin maintains a scalar signal $x : \\mathbb{R}_{\\ge 0} \\to \\mathbb{R}$ representing a normalized resource level. Suppose the observed trajectory is $x(t) = 1 - 0.1 t$ for $t \\ge 0$. The system requirement is specified in Signal Temporal Logic (STL) as the formula $\\varphi = \\mathbf{F}_{[0,5]}(x(t) \\ge 0.6)$, interpreted under the standard continuous-time quantitative semantics on $\\mathbb{R}_{\\ge 0}$.\n\nStarting from the formal definition of the quantitative semantics of Signal Temporal Logic (STL) for atomic predicates and the temporal operator “eventually” over a bounded interval, derive and compute the robustness value $\\rho(x,\\varphi,0)$ for the given $x(t)$ and $\\varphi$. Then, explain how the computed robustness guides falsification by indicating how far the current behavior is from violating the specification and which aspects of the signal shape are most critical to adjust to drive the robustness below zero.\n\nProvide the numerical value of $\\rho(x,\\varphi,0)$ as your final answer. No rounding is required. Do not include units.",
            "solution": "The problem requires computing the robustness value, $\\rho(x,\\varphi,0)$, for the Signal Temporal Logic (STL) formula $\\varphi = \\mathbf{F}_{[0,5]}(x(t) \\ge 0.6)$ given the signal $x(t) = 1 - 0.1 t$. The computation follows the standard quantitative semantics of STL.\n\nFirst, we define the robustness for the atomic predicate $\\pi \\equiv (x(t) \\ge 0.6)$. Its robustness at any time $t'$ is the signed distance of the signal value from the threshold:\n$$\n\\rho(x, \\pi, t') = x(t') - 0.6\n$$\nThe full formula $\\varphi$ uses the \"eventually\" operator $\\mathbf{F}_{[0,5]}$. The robustness of this formula, evaluated at time $t=0$, is the maximum (supremum) robustness of the atomic predicate $\\pi$ over the specified time interval, which is $[0+0, 0+5] = [0, 5]$.\n$$\n\\rho(x, \\varphi, 0) = \\sup_{t' \\in [0, 5]} \\rho(x, \\pi, t') = \\sup_{t' \\in [0, 5]} (x(t') - 0.6)\n$$\nSubstituting the given signal trajectory $x(t') = 1 - 0.1 t'$ into the expression, we get:\n$$\n\\rho(x, \\varphi, 0) = \\sup_{t' \\in [0, 5]} ((1 - 0.1 t') - 0.6) = \\sup_{t' \\in [0, 5]} (0.4 - 0.1 t')\n$$\nThe function inside the supremum, $g(t') = 0.4 - 0.1 t'$, is a strictly decreasing linear function of $t'$. Therefore, its maximum value on the closed interval $[0, 5]$ occurs at the leftmost point, $t' = 0$.\nEvaluating at this point gives the robustness:\n$$\n\\rho(x, \\varphi, 0) = g(0) = 0.4 - 0.1(0) = 0.4\n$$\nThe robustness value is $0.4$.\n\nThe computed robustness also provides guidance for falsification, the process of finding a signal that violates the specification. A positive robustness of $0.4$ means the signal satisfies the property with a \"safety margin\" of $0.4$. To falsify the property, the signal must be altered so that the robustness becomes negative. The calculation shows that the peak satisfaction occurs at $t'=0$. This identifies the initial value of the signal, $x(0)$, as the most critical aspect for this specification. A falsification algorithm would be guided to reduce the value of $x(0)$. If $x(0)$ is lowered by more than $0.4$, while the signal remains decreasing, the specification will be violated. For example, changing the signal to $x_{new}(t) = 0.5 - 0.1t$ would yield a robustness of $0.5 - 0.6 = -0.1$, successfully falsifying the property.",
            "answer": "$$\\boxed{0.4}$$"
        },
        {
            "introduction": "The final step in mastering a concept is to implement it. This practice transitions from analytical problems to a practical coding exercise, mirroring the challenges faced when building a real-world digital twin monitor. You will develop an algorithm to compute the robustness for a compound specification involving multiple signals and a combination of logical ($\\wedge$) and temporal ($\\mathbf{G}$, $\\mathbf{F}$) operators on discrete, sampled data. This hands-on task solidifies your understanding by requiring you to translate the formal semantics into a concrete, executable program .",
            "id": "4222933",
            "problem": "Consider a Cyber-Physical System (CPS) paired with a Digital Twin, monitored by a formal specification written in Signal Temporal Logic (STL). Let the formula be $\\varphi = \\mathbf{G}_{[0,10]}(x \\le 2) \\wedge \\mathbf{F}_{[3,7]}(y \\ge 1)$, where $x$ and $y$ are real-valued signals sampled from the CPS at a uniform sampling period $\\Delta t = 0.1 \\text{ s}$. You are asked to implement the computation of the quantitative robustness of $\\varphi$ at the evaluation time $t = 5 \\text{ s}$ using sampled data arrays $x[k]$ and $y[k]$.\n\nFor quantitative semantics, use the following standard and widely accepted base principles for Signal Temporal Logic (STL):\n- Atomic predicate robustness: for $(x \\le 2)$, the robustness at time $t$ is $2 - x(t)$; for $(y \\ge 1)$, the robustness at time $t$ is $y(t) - 1$.\n- Conjunction semantics: the robustness of $\\psi_1 \\wedge \\psi_2$ is the minimum of the robustnesses of $\\psi_1$ and $\\psi_2$ at the same time.\n- Temporal operator semantics: the robustness of $\\mathbf{G}_{[a,b]} \\psi$ at time $t$ is the infimum of the robustness of $\\psi$ over all times in $t + [a,b]$; the robustness of $\\mathbf{F}_{[a,b]} \\psi$ at time $t$ is the supremum of the robustness of $\\psi$ over all times in $t + [a,b]$.\n\nAssume discrete-time evaluation aligned with the sampling grid. Let $t_k = k \\Delta t$ and let $k_0$ be such that $t_{k_0} = t$. For discrete evaluation windows, replace the continuous infimum and supremum by the minimum and maximum over sampled indices. Use inclusive interval bounds with index mapping defined exactly by $I_{\\mathbf{G}} = \\{k \\mid k_0 + \\lceil 0 / \\Delta t \\rceil \\le k \\le k_0 + \\lfloor 10 / \\Delta t \\rfloor\\}$ and $I_{\\mathbf{F}} = \\{k \\mid k_0 + \\lceil 3 / \\Delta t \\rceil \\le k \\le k_0 + \\lfloor 7 / \\Delta t \\rfloor\\}$. Angles used in any trigonometric signal definitions must be interpreted in radians.\n\nYour program must implement this robustness computation and evaluate it for the following test suite of four cases. In all cases, use $\\Delta t = 0.1 \\text{ s}$, $t \\in [0,15] \\text{ s}$, $t = 5 \\text{ s}$, and signals defined for $k = 0,1,2,\\dots,150$ so that $t_k = k \\Delta t$ covers the necessary windows. For each case, generate $x[k]$ and $y[k]$ according to the provided rules:\n\n- Case $1$ (general variation, happy path): $x[k] = 1.5 + 0.3 \\sin(0.5 \\, t_k)$ and $y[k] = 0.6 + 0.5 \\sin(0.7 \\, t_k)$. The sine arguments are in radians.\n- Case $2$ (boundary condition): $x[k] = 2.0$ and $y[k] = 1.0$ for all $k$.\n- Case $3$ (violation in the $\\mathbf{F}$ subformula): $x[k] = 1.0$ for all $k$ and $y[k] = 0.9$ for all $k$.\n- Case $4$ (violation in the $\\mathbf{G}$ subformula): $x[k] = 1.8$ for all $k$ except for indices with $t_k \\in [7.0, 7.5]$, where $x[k] = 2.5$; $y[k] = 1.2$ for all $k$.\n\nCompute the robustness value of $\\varphi$ at $t = 5 \\text{ s}$ for each case. The final output must be a single line containing the four robustness values in a comma-separated list enclosed in square brackets, in the order of the cases $1$ through $4$, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is a real number. No units are required for robustness values. Ensure the program is self-contained and uses the specified runtime environment.\n\nYour implementation must strictly follow the discrete index mapping described above and must treat interval endpoints as inclusive. Your algorithm should not rely on any continuous-time interpolation. The output must be reproducible and deterministic given the signals as defined. The angle unit for any trigonometric function is radians.",
            "solution": "The problem as stated is valid. It is scientifically grounded in the principles of formal verification for Cyber-Physical Systems (CPS) using Signal Temporal Logic (STL), is well-posed with all necessary parameters defined, and is expressed in objective, formal language. We may therefore proceed with the solution.\n\nThe objective is to compute the quantitative robustness of the STL formula $\\varphi = \\mathbf{G}_{[0,10]}(x \\le 2) \\wedge \\mathbf{F}_{[3,7]}(y \\ge 1)$ at the evaluation time $t = 5 \\text{ s}$ for a discrete-time system with sampling period $\\Delta t = 0.1 \\text{ s}$. The robustness, denoted $\\rho(\\varphi, t)$, provides a measure of how strongly a signal satisfies or violates a specification. A positive value indicates satisfaction, a negative value indicates violation, and a value of $0$ indicates satisfaction precisely at the boundary.\n\nThe computation proceeds by recursively evaluating the robustness of the subformulas.\n\n1.  **Top-Level Formula Decomposition**: The formula $\\varphi$ is a conjunction of two subformulas:\n    $\\varphi_G = \\mathbf{G}_{[0,10]}(x \\le 2)$\n    $\\varphi_F = \\mathbf{F}_{[3,7]}(y \\ge 1)$\n    So, $\\varphi = \\varphi_G \\wedge \\varphi_F$.\n\n    According to the provided semantics for conjunction, the overall robustness is the minimum of the robustness of its constituent parts:\n    $$\n    \\rho(\\varphi, t) = \\min(\\rho(\\varphi_G, t), \\rho(\\varphi_F, t))\n    $$\n\n2.  **Discretization of Parameters**: The problem is defined on a discrete time grid $t_k = k \\Delta t$, where $\\Delta t = 0.1 \\text{ s}$. The evaluation is at $t = 5 \\text{ s}$. The corresponding discrete time index $k_0$ is:\n    $$\n    k_0 = \\frac{t}{\\Delta t} = \\frac{5}{0.1} = 50\n    $$\n\n3.  **Robustness of Subformula $\\varphi_G$**:\n    The subformula is $\\varphi_G = \\mathbf{G}_{[0,10]}(x \\le 2)$. This is a \"Globally\" (or \"Always\") property over the time interval $[0, 10]$ seconds relative to the evaluation time. Let the atomic predicate be $\\psi_x = (x \\le 2)$.\n    \n    The robustness of the atomic predicate $\\psi_x$ at time $t_k$ is given by $\\rho(\\psi_x, t_k) = 2 - x(t_k)$. In our discrete framework, this is $2 - x[k]$.\n    \n    The robustness of $\\varphi_G$ at evaluation time $t$ (index $k_0$) is the minimum of the atomic predicate's robustness over the specified time window. The continuous-time definition is $\\rho(\\varphi_G, t) = \\inf_{t' \\in [t+0, t+10]} \\rho(\\psi_x, t')$. In the discrete setting, this becomes a minimum over a set of indices $I_G$:\n    $$\n    \\rho(\\varphi_G, k_0) = \\min_{k \\in I_G} (2 - x[k])\n    $$\n    The index set $I_G$ is explicitly defined as:\n    $$\n    I_G = \\{k \\mid k_0 + \\lceil 0 / \\Delta t \\rceil \\le k \\le k_0 + \\lfloor 10 / \\Delta t \\rfloor\\}\n    $$\n    Substituting $k_0=50$ and $\\Delta t=0.1$:\n    $\\lceil 0 / 0.1 \\rceil = \\lceil 0 \\rceil = 0$\n    $\\lfloor 10 / 0.1 \\rfloor = \\lfloor 100 \\rfloor = 100$\n    So, the index set for the \"Globally\" operator is $I_G = \\{k \\mid 50 + 0 \\le k \\le 50 + 100\\} = \\{k \\mid 50 \\le k \\le 150\\}$.\n    The robustness is therefore:\n    $$\n    \\rho(\\varphi_G, 50) = \\min_{k=50, \\dots, 150} (2 - x[k])\n    $$\n\n4.  **Robustness of Subformula $\\varphi_F$**:\n    The subformula is $\\varphi_F = \\mathbf{F}_{[3,7]}(y \\ge 1)$. This is an \"Eventually\" (or \"Finally\") property over the time interval $[3, 7]$ seconds relative to the evaluation time. Let the atomic predicate be $\\psi_y = (y \\ge 1)$.\n\n    The robustness of the atomic predicate $\\psi_y$ at time $t_k$ is given by $\\rho(\\psi_y, t_k) = y(t_k) - 1$, which is $y[k] - 1$ for the discrete signal.\n\n    The robustness of $\\varphi_F$ at evaluation time $t$ (index $k_0$) is the maximum of the atomic predicate's robustness over the specified time window. The continuous-time definition is $\\rho(\\varphi_F, t) = \\sup_{t' \\in [t+3, t+7]} \\rho(\\psi_y, t')$. Discretized, this is:\n    $$\n    \\rho(\\varphi_F, k_0) = \\max_{k \\in I_F} (y[k] - 1)\n    $$\n    The index set $I_F$ is explicitly defined as:\n    $$\n    I_F = \\{k \\mid k_0 + \\lceil 3 / \\Delta t \\rceil \\le k \\le k_0 + \\lfloor 7 / \\Delta t \\rfloor\\}\n    $$\n    Substituting $k_0=50$ and $\\Delta t=0.1$:\n    $\\lceil 3 / 0.1 \\rceil = \\lceil 30 \\rceil = 30$\n    $\\lfloor 7 / 0.1 \\rfloor = \\lfloor 70 \\rfloor = 70$\n    So, the index set for the \"Eventually\" operator is $I_F = \\{k \\mid 50 + 30 \\le k \\le 50 + 70\\} = \\{k \\mid 80 \\le k \\le 120\\}$.\n    The robustness is therefore:\n    $$\n    \\rho(\\varphi_F, 50) = \\max_{k=80, \\dots, 120} (y[k] - 1)\n    $$\n\n5.  **Final Robustness Formula**:\n    Combining these results, the final robustness value to be computed is:\n    $$\n    \\rho(\\varphi, 50) = \\min \\left( \\min_{k=50, \\dots, 150} (2 - x[k]), \\max_{k=80, \\dots, 120} (y[k] - 1) \\right)\n    $$\n    This formula will be implemented and evaluated for each of the four test cases. The signals $x[k]$ and $y[k]$ are first generated for $k \\in [0, 150]$ according to the rules of each case. Then, the relevant portions of these signal arrays are sliced and used in the computation.\n\n-   **Case 1**: $x[k] = 1.5 + 0.3 \\sin(0.5 \\, t_k)$, $y[k] = 0.6 + 0.5 \\sin(0.7 \\, t_k)$. The robustness will depend on the extrema of the sine functions over their respective discrete evaluation windows.\n-   **Case 2**: $x[k] = 2.0$, $y[k] = 1.0$. Both predicates are on their boundaries, so $\\rho(\\varphi_G, 50) = \\min(2 - 2) = 0$ and $\\rho(\\varphi_F, 50) = \\max(1 - 1) = 0$. The final robustness is $\\min(0, 0) = 0$.\n-   **Case 3**: $x[k] = 1.0$, $y[k] = 0.9$. $\\rho(\\varphi_G, 50) = \\min(2 - 1) = 1$. $\\rho(\\varphi_F, 50) = \\max(0.9 - 1) = -0.1$. The final robustness is $\\min(1, -0.1) = -0.1$, indicating a violation driven by the $\\mathbf{F}$ subformula.\n-   **Case 4**: $x[k]$ has a violation pulse and $y[k]$ is constant. The violation pulse of $x[k] = 2.5$ occurs for $t_k \\in [7.0, 7.5]$, which corresponds to indices $k \\in [70, 75]$. This falls within the window for $\\varphi_G$, so $\\rho(\\varphi_G, 50) = \\min(2-1.8, 2-2.5) = -0.5$. For $\\varphi_F$, $\\rho(\\varphi_F, 50) = \\max(1.2 - 1) = 0.2$. The final robustness is $\\min(-0.5, 0.2) = -0.5$.\n\nThe following program implements this logic.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the quantitative robustness for an STL formula for four test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # We will simply use numbers 1 through 4 to identify the cases.\n    test_cases = [1, 2, 3, 4]\n\n    results = []\n    for case_num in test_cases:\n        # --- Problem Parameters ---\n        delta_t = 0.1\n        t_eval = 5.0\n        \n        # The signals are defined for t_k up to 15s, so we need k up to 150.\n        k_max = 150\n        time_vector = np.arange(k_max + 1) * delta_t # t_k = k * delta_t\n\n        # --- Signal Generation ---\n        if case_num == 1:\n            # Case 1: General variation\n            x_signal = 1.5 + 0.3 * np.sin(0.5 * time_vector)\n            y_signal = 0.6 + 0.5 * np.sin(0.7 * time_vector)\n        elif case_num == 2:\n            # Case 2: Boundary condition\n            x_signal = np.full_like(time_vector, 2.0)\n            y_signal = np.full_like(time_vector, 1.0)\n        elif case_num == 3:\n            # Case 3: Violation in the F subformula\n            x_signal = np.full_like(time_vector, 1.0)\n            y_signal = np.full_like(time_vector, 0.9)\n        elif case_num == 4:\n            # Case 4: Violation in the G subformula\n            x_signal = np.full_like(time_vector, 1.8)\n            # Anomaly for t_k in [7.0, 7.5]\n            # k * delta_t = 7.0 = k = 70\n            # k * delta_t = 7.5 = k = 75\n            anomaly_indices = np.where((time_vector = 7.0)  (time_vector = 7.5))\n            x_signal[anomaly_indices] = 2.5\n            y_signal = np.full_like(time_vector, 1.2)\n\n        # --- Robustness Computation ---\n        k0 = int(t_eval / delta_t)\n\n        # Evaluate subformula phi_G = G_[0,10](x = 2)\n        # Robustness of (x = 2) at index k is (2 - x[k])\n        # Robustness of G_[a,b](psi) is min_{k in window}(rho(psi, k))\n        \n        # Define the discrete index window for G\n        a_g, b_g = 0.0, 10.0\n        k_start_g = k0 + int(np.ceil(a_g / delta_t))\n        k_end_g = k0 + int(np.floor(b_g / delta_t))\n        \n        # Extract the signal values over the window\n        x_window = x_signal[k_start_g : k_end_g + 1]\n        \n        # Compute robustness for the G subformula\n        rob_g = np.min(2.0 - x_window)\n\n        # Evaluate subformula phi_F = F_[3,7](y = 1)\n        # Robustness of (y = 1) at index k is (y[k] - 1)\n        # Robustness of F_[a,b](psi) is max_{k in window}(rho(psi, k))\n\n        # Define the discrete index window for F\n        a_f, b_f = 3.0, 7.0\n        k_start_f = k0 + int(np.ceil(a_f / delta_t))\n        k_end_f = k0 + int(np.floor(b_f / delta_t))\n\n        # Extract the signal values over the window\n        y_window = y_signal[k_start_f : k_end_f + 1]\n        \n        # Compute robustness for the F subformula\n        rob_f = np.max(y_window - 1.0)\n        \n        # Final robustness is for phi_G AND phi_F\n        # rho(psi1 AND psi2) = min(rho(psi1), rho(psi2))\n        final_robustness = min(rob_g, rob_f)\n        \n        results.append(final_robustness)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}