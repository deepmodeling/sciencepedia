## 引言
信息物理系统（Cyber-Physical Systems, CPS）作为计算进程与物理世界深度融合的产物，已成为从[自动驾驶](@entry_id:270800)、[智能制造](@entry_id:1131785)到医疗设备等关键领域的核心。这些系统的可靠性与安全性至关重要，任何微小的设计缺陷都可能导致灾难性后果。然而，由于离散控制逻辑与连续物理动态之间的复杂交互，仅靠传统的仿真和测试方法已不足以穷尽所有可能的行为，从而无法提供强有力的[安全保证](@entry_id:1131169)。为了弥合这一差距，形式化规范语言应运而生，它们提供了一种基于数学的、无[歧义](@entry_id:276744)的方式来建模系统行为、规定安全属性并进行严格验证。

本文将系统性地引导您进入CPS形式化规范语言的世界。我们将从构成这些语言的基石出发，逐步深入其在现代工程实践中的高级应用。通过阅读本文，您将能够理解并运用这些强大的工具来分析和设计更安全、更可靠的信息物理系统。文章分为三个核心部分：首先，在“原理与机制”一章中，我们将奠定理论基础，详细剖析[混合自动机](@entry_id:1126226)、各类时序逻辑（LTL、STL）以及[微分](@entry_id:158422)动力学逻辑（dL）的核心概念与验证机制。接着，在“应用与跨学科交叉”一章中，我们将展示这些理论如何在[运行时监控](@entry_id:1131150)、系统伪造、[控制器综合](@entry_id:261816)等实际场景中发挥威力，并揭示其与人工智能、控制论等领域的深刻联系。最后，“动手实践”部分将提供一系列精心设计的练习，帮助您将理论知识转化为实践技能。

## 原理与机制

本章旨在深入探讨用于信息物理系统（CPS）的形式化规范语言背后的核心原理与关键机制。继前一章对CPS及其验证挑战的总体介绍之后，我们将系统性地剖析用于描述系统行为、规定系统属性以及验证系统正确性的多种形式化方法。我们将从混合系统的基础模型——[自动机理论](@entry_id:276038)——出发，逐步过渡到能够精确捕捉实时和连续动态的逻辑语言，最终介绍支撑这些语言的验证算法与技术。

### 建模混合动态：基于自动机的形式化方法

信息物理系统（CPS）的本质特征是离散计算与连续物理过程的深度耦合。为了精确地描述这种混合行为，我们需要能够同时捕捉这两种动态的模型。[混合自动机](@entry_id:1126226)和[时间自动机](@entry_id:1133177)为此提供了强大的理论框架。

#### [混合自动机](@entry_id:1126226)

**[混合自动机](@entry_id:1126226)** (Hybrid Automaton) 是一个用于描述混合系统的数学模型，它将[有限自动机](@entry_id:1124972)的离散状态转换与[微分](@entry_id:158422)方程的连续演化相结合。一个混合自动机通常由以下几个部分构成 ：

*   一个有限的离散**位置**（locations）集合 $L$，代表系统的不同操作模式或离散状态。
*   一个[连续状态空间](@entry_id:276130) $X \subseteq \mathbb{R}^n$，其变量用于描述系统的物理属性（如位置、速度、温度等）。
*   一个**流条件**（flow condition）函数 $f$，为每个位置 $\ell \in L$ 指定一个向量场 $f_\ell: X \to \mathbb{R}^n$。当系统处于位置 $\ell$ 时，其连续状态 $x$ 的演化遵循[常微分方程](@entry_id:147024)（ODE）$\dot{x} = f_\ell(x)$。
*   一个**不变式**（invariant）函数 $Inv$，为每个位置 $\ell \in L$ 分配一个[不变集](@entry_id:275226) $Inv(\ell) \subseteq X$。系统只有当其连续状态 $x$ 满足 $x \in Inv(\ell)$ 时，才能停留在位置 $\ell$ 中进行连续演化。
*   一个有向**边**（edges）集合 $E \subseteq L \times L$，表示离散的转换。
*   一个**守卫**（guard）函数 $G$，为每条边 $e = (\ell, \ell') \in E$ 分配一个守卫集 $G(e) \subseteq X$。只有当系统的连续状态满足守卫条件时，即 $x \in G(e)$，这条离散转换才被启用。
*   一个**重置**（reset）映射 $R$，为每条边 $e$ 分配一个重置函数 $R_e: X \to X$。当发生离散转换时，系统的连续状态会瞬时地从 $x^-$ 变为 $x^+ = R_e(x^-)$。

混合自动机的**执行**（execution）是一系列连续演化（流）和离散转换（跳变）的交替序列。其语义精确地定义了何为一个有效的系统行为 ：

1.  **连续演化（流）**：在某个位置 $\ell_j$ 内，系统状态在时间区间 $[t_j, t_{j+1}]$ 上连续演化。在此期间，连续状态 $x(t)$ 必须始终满足位置不变式，即对于所有 $t \in [t_j, t_{j+1}]$，都有 $x(t) \in Inv(\ell_j)$。同时，状态的演化必须遵循该位置的流条件，即 $\dot{x}(t) = f_{\ell_j}(x(t))$。
2.  **离散转换（跳变）**：在时间 $t_{j+1}$，如果系统状态 $x(t_{j+1})$ 满足了某条从 $\ell_j$ 指向 $\ell_{j+1}$ 的边 $e_j$ 的守卫条件，即 $x(t_{j+1}) \in G(e_j)$，则系统可以发生一次瞬时的离散跳变。跳变后，新的连续状态由重置映射给出：$x(t_{j+1}) \leftarrow R_{e_j}(x(t_{j+1}))$。一个关键的约束是，重置后的新状态必须满足目标位置的不变式，即 $R_{e_j}(x(t_{j+1})) \in Inv(\ell_{j+1})$，否则该跳变是无效的。

如果一个轨迹到达不变式的边界，但没有任何守卫条件被满足，系统就会陷入**死锁**（deadlock）。

#### [时间自动机](@entry_id:1133177)

**[时间自动机](@entry_id:1133177)**（Timed Automaton）是混合自动机的一个重要特例，专门用于建模具有[实时约束](@entry_id:754130)的系统。在[时间自动机](@entry_id:1133177)中，所有的连续变量都是**时钟**（clocks），它们的[演化速率](@entry_id:202008)恒为1，即 $\dot{c} = 1$ 。

*   **时钟** $C$ 是一组非负实值变量，它们同步地随时间流逝而增长。
*   **守卫**是关于时钟值的线性不等式（例如 $x \le 5$ 或 $(x \le 5) \land (y \ge 8)$）。守卫在离散转换的瞬间被评估，决定转换是否可以发生。
*   **不变式**也是关于时钟值的线性不等式（例如 $y \lt 10$）。与一般[混合自动机](@entry_id:1126226)一样，不变式必须在整个连续演化期间保持成立。对于严格不等式（如 $y \lt 10$），系统必须在时钟值达到边界（即 $y=10$）*之前*离开当前位置。
*   **重置**操作将指定的时钟值瞬间设为0。

一个**时间发散**（time-divergent）的运行是指其经过的无限时间段的总和是无限的。反之，如果无限多次离散转换发生在一段有限的时间内，则称该行为是**[芝诺行为](@entry_id:268663)**（Zeno behavior）。例如，一个包含零时间延迟的无限自循环的运行不是时间发散的，而是芝诺的 。

#### 一个基础性挑战：[芝诺行为](@entry_id:268663)

[芝诺行为](@entry_id:268663)是混合系统建模中的一个核心理论问题。它指的是系统在有限时间内经历了无限次的离散跳变。这种行为在物理世界中通常是不可能的，但在数学模型中却可能出现，并给仿真和验证带来困难。

一个经典的例子是带有能量损失的**弹跳[球模型](@entry_id:161388)** 。设球的位置为 $x$，速度为 $v$，[重力加速度](@entry_id:173411)为 $g \gt 0$。
*   **流**：当 $x \gt 0$ 时，$\dot{x}=v, \dot{v}=-g$。
*   **跳变**：当 $x=0 \land v \lt 0$ 时，速度被重置为 $v^+ = -r v^-$，其中 $r \in (0,1)$ 是[恢复系数](@entry_id:170710)。

从高度 $h_0$ 静止下落，第一次下落的时间为 $\Delta t_0 = \sqrt{2h_0/g}$。由于每次碰撞后起跳速度都是前一次的 $r$ 倍，每次弹跳在空中停留的时间构成一个[几何级数](@entry_id:158490)。第 $k$ 次弹跳的持续时间为 $\Delta t_k = \Delta t_1 \cdot r^{k-1}$。所有弹跳的总时间是一个收敛的[几何级数](@entry_id:158490)之和：
$$
T^{\star} = \Delta t_0 + \sum_{k=1}^{\infty} \Delta t_k = \sqrt{\frac{2h_0}{g}} \left(1 + 2\sum_{k=1}^{\infty} r^k\right) = \sqrt{\frac{2h_0}{g}}\left(1+2\frac{r}{1-r}\right)
$$
由于 $T^{\star}$ 是一个有限值，这意味着球在有限时间内完成了无限次弹跳。这就是[芝诺行为](@entry_id:268663)。

为了在模型中排除这种理论上的行为，一种常见的方法是强制规定两次跳变之间必须有**最小[停留时间](@entry_id:263953)**（minimum dwell time）。例如，可以引入一个时钟 $z$，在每次跳变时重置为0，并在守卫条件中增加一项 $z \ge \delta$（其中 $\delta \gt 0$）。这一要求可以用**度量时序逻辑**（Metric Temporal Logic, MTL）精确地形式化。若令原子命题 $J$ 在跳变瞬间为真，则该属性可表示为 $\mathbf{G}(J \rightarrow \mathbf{G}_{(0,\delta)}\neg J)$，意为“全局地，每当一次跳变发生后，在接下来的 $(0, \delta)$ 时间段内，都不能再有跳变发生” 。

### 规定属性：[时序逻辑](@entry_id:181558)的领域

仅仅对系统行为进行建模是不够的；我们还需要一种精确的语言来描述我们期望系统满足或避免的属性。时序逻辑为此提供了形式化的基础。

#### 离散时间上的定性规范：线性[时序逻辑](@entry_id:181558) (LTL)

**线性[时序逻辑](@entry_id:181558)**（Linear Temporal Logic, LTL）是一种用于描述和推理关于计算路径（traces）上命题序列的逻辑。它在验证离散系统（如软件或[数字电路](@entry_id:268512)）中扮演着基础性角色。

LTL 的语法建立在原子命题（如 $p,q$）之上，通过布尔连接词（$\neg, \lor, \land, \rightarrow$）和时序算子来构建更复杂的公式 ：
*   $\mathbf{X}\varphi$ (Next)：$\varphi$ 在下一个状态成立。
*   $\varphi\,\mathbf{U}\,\psi$ (Until)：$\varphi$ 必须一直成立，直到 $\psi$ 最终成立。
*   $\mathbf{F}\varphi$ (Finally/Eventually)：$\varphi$ 最终会在未来的某个状态成立（等价于 $\top\,\mathbf{U}\,\varphi$）。
*   $\mathbf{G}\varphi$ (Globally/Always)：$\varphi$ 在未来所有的状态中都成立（等价于 $\neg\mathbf{F}\neg\varphi$）。

LTL 的语义是基于无限状态序列（迹）定义的。$(\sigma, i) \models \varphi$ 表示迹 $\sigma$ 在第 $i$ 个位置满足 $\varphi$。例如，$\mathbf{G}(p \rightarrow \mathbf{F}q)$ 这条公式的语义是：对于迹上的每一个点，如果 $p$ 在该点成立，那么在未来的某个点 $q$ 必然会成立。

根据 Alpern 和 Schneider 的理论，LTL 属性可以被分为两大类 ：
*   **安全性**（Safety）属性：断言“坏事永远不会发生”。任何对安全性属性的违反都可以在有限时间内被检测到。例如，$\mathbf{G}(\neg \text{error})$ 是一个安全性属性。
*   **活性**（Liveness）属性：断言“好事最终会发生”。活性属性的违反无法在有限时间内被确认，因为“好事”总有可能在未来发生。例如，$\mathbf{G}(p \rightarrow \mathbf{F}q)$ 是一个典型的活性属性。因为即使在观察到一个 $p$ 之后很长一段时间内都没有 $q$ 出现，我们也不能断定该属性被违反，因为 $q$ 仍可能在更遥远的未来出现。

#### 连续时间上的定量规范：[信号时序逻辑 (STL)](@entry_id:1131628)

对于 CPS 而言，LTL 的纯离散、定性语义是不够的。我们需要能够处理**[实时约束](@entry_id:754130)**和**实值信号**的逻辑。**[信号时序逻辑](@entry_id:1131627)**（Signal Temporal Logic, STL）是对 LTL 的重要扩展，它被设计用来描述实值、密集时间信号的属性 。

STL 继承并扩展了**度量时序逻辑**（Metric Temporal Logic, MTL），后者通过为时序算子增加时间区间 $I$ 来引入[实时约束](@entry_id:754130)，例如 $\mathbf{G}_I$（在区间 $I$ 内总是）和 $\mathbf{F}_I$（在区间 $I$ 内最终）。

**1. 布尔语义**

STL 的布尔语义定义了在给定时间点 $t$，一个信号 $x(t)$ 是否满足一个公式 $\varphi$。
*   **原子命题**不再是简单的布尔变量，而是信号值的谓词，形式为 $g(x(t)) \ge 0$，其中 $g$ 是一个实值函数。
*   **时序算子**的语义定义在相对于当前时间 $t$ 的未来时间区间上 。例如，对于区间 $I \subseteq \mathbb{R}_{\ge 0}$：
    *   $(x,t) \models \mathbf{F}_I \varphi$ 当且仅当存在 $\tau \in I$ 使得 $(x, t+\tau) \models \varphi$。
    *   $(x,t) \models \mathbf{G}_I \varphi$ 当且仅当对于所有 $\tau \in I$ 都有 $(x, t+\tau) \models \varphi$。

**2. 定量（鲁棒性）语义**

STL 最具变革性的特点是其**定量语义**或称**鲁棒性语义**（robust semantics）。它不仅回答一个属性是否被满足（布尔真/假），还量化了满足或违反的程度。这个量化的度量被称为**鲁棒性**，用函数 $\rho(x, \varphi, t)$ 表示 。

*   **符号与[真值](@entry_id:636547)**：$\rho$ 的符号与布尔语义一致。$\rho(x, \varphi, t) > 0$ 意味着属性被满足，$\rho(x, \varphi, t)  0$ 意味着属性被违反，而 $\rho(x, \varphi, t) = 0$ 表示信号轨迹恰好在满足与违反的边界上。
*   **大小与裕度**：$\rho$ 的绝对值 $|\rho|$ 量化了系统的“安全裕度”或“[误差幅度](@entry_id:169950)”。若 $\rho  0$，它表示信号可以在多大程度上被扰动而依然满足属性；若 $\rho  0$，它表示信号需要被“修正”多少才能恰好满足属性。

鲁棒性语义是[递归定义](@entry_id:266613)的  ：
*   原子谓词 $\mu := (g(x(t)) \ge 0)$：$\rho(x, \mu, t) = g(x(t))$。
*   布尔连接词：$\rho(x, \neg\varphi, t) = -\rho(x, \varphi, t)$；$\rho(x, \varphi_1 \land \varphi_2, t) = \min(\rho(x, \varphi_1, t), \rho(x, \varphi_2, t))$；$\rho(x, \varphi_1 \lor \varphi_2, t) = \max(\rho(x, \varphi_1, t), \rho(x, \varphi_2, t))$。
*   时序算子：
    *   $\rho(x, \mathbf{F}_I \varphi, t) = \sup_{\tau \in t+I} \rho(x, \varphi, \tau)$
    *   $\rho(x, \mathbf{G}_I \varphi, t) = \inf_{\tau \in t+I} \rho(x, \varphi, \tau)$

例如，考虑规范 $\varphi \equiv \mathbf{G}_{[0,5]}(x(t) \ge 1)$ 和信号：$t \in [0,3]$ 时 $x(t)=1.5$，$t \in (3,5]$ 时 $x(t)=0.8$。在 $t=0$ 处的鲁棒性计算如下 ：
$$
\rho(\varphi, x, 0) = \inf_{t \in [0,5]} \rho(x(t) \ge 1, x, t) = \inf_{t \in [0,5]} (x(t) - 1)
$$
在区间 $[0,3]$ 上，$x(t)-1 = 0.5$。在区间 $(3,5]$ 上，$x(t)-1 = -0.2$。因此，在整个 $[0,5]$ 区间上的[下确界](@entry_id:140118)是 $-0.2$。这个负值表明规范被违反，且信号至少需要被统一增加 $0.2$ 才能满足规范。

**3. 弥合理论与实践：采样所扮演的角色**

在实际的 CPS 中，信号通常是通过以某个采样周期 $\Delta t$ 进行**采样**来监控的。这就引出了一个关键问题：在采样点上满足的属性，是否意味着在所有连续时间点（即稠密时间）上也满足？

答案是否定的，除非满足特定条件 。从稠密时间满足到采样时间满足是直接的，因为采样点是时间轴的子集。然而，反向推断（从采样满足到稠密满足）则需要额外的假设。假设原子谓词 $\mu(x(t)) \ge 0$ 所涉及的函数 $\mu \circ x$ 是[利普希茨连续的](@entry_id:267396)，其[利普希茨常数](@entry_id:146583)为 $L$。如果在所有采样点上，属性 $\mu(x(t)) \ge 0$ 的鲁棒性至少为 $m$，即 $\mu(x(k\Delta t)) \ge m$。那么，为了保证在两个采样点之间 $\mu(x(t))$ 的值不会降到0以下，必须满足条件 $m  L \Delta t$。这个条件直观地意味着，在采样点处的“安全裕度” $m$ 必须大于信号在采样间隔 $\Delta t$ 内可能发生的最大变化量 $L \Delta t$。

### 集成框架：[微分](@entry_id:158422)动力学逻辑 (dL)

**[微分](@entry_id:158422)动力学逻辑**（Differential Dynamic Logic, dL）提供了一个更具表达[力的统一](@entry_id:158789)框架，它将离散程序结构与连续动态直接集成到逻辑公式中。dL 的核心是**混合程序**（hybrid programs），它们表示了状态间的转换关系。

dL 的语法和语义包括 ：
*   **赋值**：如 $x := e$。
*   **测试**：如 $?\psi$，只有当条件 $\psi$ 成立时才能继续执行。
*   **顺序组合**：$\alpha;\beta$，表示先执行 $\alpha$ 再执行 $\beta$。其语义是关系合成 $\llbracket\alpha;\beta\rrbracket = \llbracket\alpha\rrbracket \circ \llbracket\beta\rrbracket$。
*   **[非确定性](@entry_id:273591)选择**：$\alpha \cup \beta$，表示[非确定性](@entry_id:273591)地选择执行 $\alpha$ 或 $\beta$。其语义是关系并集 $\llbracket\alpha \cup \beta\rrbracket = \llbracket\alpha\rrbracket \cup \llbracket\beta\rrbracket$。
*   **[非确定性](@entry_id:273591)重复**：$\alpha^*$，表示将 $\alpha$ 执行任意 $k \ge 0$ 次。其语义是关系的自反[传递闭包](@entry_id:262879) $\llbracket\alpha^*\rrbracket = \bigcup_{k \in \mathbb{N}} \llbracket\alpha\rrbracket^k$。
*   **连续演化**：$x' = f(x) \ \\ Inv$。这表示变量 $x$ 按照[微分](@entry_id:158422)方程 $\dot{x}=f(x)$ 演化任意时间 $\tau \ge 0$，同时在整个[演化过程](@entry_id:175749)中必须始终满足演化域约束 $Inv$。

dL 中的属性通过模态算子来表达。**箱模态**（box modality）公式 $[\alpha]\varphi$ 断言：对于混合程序 $\alpha$ 的*所有*可能终止的执行，其最终状态都满足后置条件 $\varphi$。这使其成为表达**安全性**属性的自然选择。例如，要断言系统在遵循动态 $x'=f(x)$ 并保持在 $Inv$ 内演化后，最终状态必然满足 $\varphi$，可以写作 $[x'=f(x) \ \ \ Inv]\varphi$ 。

### 核心验证机制

有了建模语言和规范语言，我们还需要验证这些规范是否成立的机制。

#### 针对 LTL 的[自动机理论](@entry_id:276038)模型检测

**模型检测**（Model Checking）是一种自动化的验证技术。对于 LTL，**基于自动机的方法**是其理论核心。其基本思想是将验证问题 $M \models \varphi$（系统模型 $M$ 是否满足规范 $\varphi$）转化为自动机的语言空性检测问题 。

该过程的关键[等价关系](@entry_id:138275)是：
$$
M \models \varphi \iff L(M) \cap L(\neg\varphi) = \emptyset
$$
这里，$L(M)$ 是系统 $M$ 生成的所有可能行为（迹）的集合，$L(\neg\varphi)$ 是所有违反规范 $\varphi$ 的行为的集合。如果这两个集合的交集为空，则说明系统中不存在任何违反规范的行为，即系统满足规范。

具体步骤如下 ：
1.  **否定规范**：计算 LTL 规范的否定 $\neg\varphi$。例如，对于 $\varphi = \mathbf{G}(p \rightarrow \mathbf{F}q)$，其否定为 $\neg\varphi \equiv \mathbf{F}(p \land \mathbf{G}\neg q)$。这描述了一种“坏行为”：最终会到达一个状态，该状态满足 $p$，并且从那时起 $q$ 永远不为真。
2.  **构建 Büchi 自动机**：为否定后的公式 $\neg\varphi$ 构建一个**[非确定性](@entry_id:273591) Büchi 自动机**（Nondeterministic Büchi Automaton, NBA）$\mathcal{A}_{\neg\varphi}$。该自动机接受且仅接受所有满足 $\neg\varphi$ 的无限字（迹）。Büchi 自动机的接受条件是：存在一条运行，其无限次地访问接受状态。
3.  **构造乘积自动机**：将系统模型 $M$（也视为一个所有状态皆为接受状态的 NBA）与 $\mathcal{A}_{\neg\varphi}$ 同步相乘，得到乘积自动机 $M \times \mathcal{A}_{\neg\varphi}$。这个乘积自动机所接受的语言恰好是 $L(M) \cap L(\neg\varphi)$。
4.  **空性检测**：检查乘积自动机的语言是否为空。在有限状态的 NBA 中，语言非空当且仅当从某个初始状态出发，可以到达一个接受状态，并且这个接受状态位于一个环路中（或更一般地，一个**[强连通分量](@entry_id:270183)** (SCC) 中）。如果找不到这样的“可达的接受环”，则语言为空，原规范 $\varphi$ 得到验证。

#### 针对连续动态的[演绎验证](@entry_id:1123467)

对于包含连续动态的系统，遍历所有状态通常是不可行的。因此，需要采用基于数学推理的**[演绎验证](@entry_id:1123467)**（Deductive Verification）方法，如不变量证明。

**1. [微分](@entry_id:158422)不变量**

证明安全性的一个有力工具是寻找一个**向前不变集**（forward invariant set） $S$，该集合包含所有初始状态 ($X_0 \subseteq S$) 并且与不安全区域 $U$ 没有交集 ($S \cap U = \emptyset$)。如果能证明所有从 $S$ 出发的[系统轨迹](@entry_id:1132840)都会永远留在 $S$ 内，那么安全性就得到了保证。

**[微分](@entry_id:158422)不变量**（Differential Invariant）提供了一种代数方法来定义和验证这样的不变集 。通常，[不变集](@entry_id:275226)由一个[可微函数](@entry_id:144590) $g$ 的子[水平集](@entry_id:751248)定义，即 $S = \{x \mid g(x) \le 0\}$。要使该集合向前不变，[系统轨迹](@entry_id:1132840)在到达其边界 $\{x \mid g(x) = 0\}$ 时不能“穿出”。在边界上，梯度 $\nabla g(x)$ 指向集合外部。因此，速度向量 $f(x)$ 在 $\nabla g(x)$ 方向上的投影必须非正，即：
$$
\nabla g(x) \cdot f(x) \le 0 \quad \text{对于所有满足 } g(x)=0 \text{ 的 } x
$$
这个条件（有时称为[李导数](@entry_id:171745)非正）保证了向量场在边界上是指向内部或与之相切的，从而确保了集合的向前[不变性](@entry_id:140168)。

**2. [屏障证书](@entry_id:1121354)**

**[屏障证书](@entry_id:1121354)**（Barrier Certificate）是另一种强大的[演绎验证](@entry_id:1123467)工具，它通过构造一个“[势函数](@entry_id:176105)”或“屏障函数” $B(x)$ 来[直接证明](@entry_id:141172)初始集 $X_0$ 与不安全集 $U$ 的不可达性 。一个有效的[屏障证书](@entry_id:1121354) $B$ 必须满足以下三个条件：
1.  对于所有初始状态 $x \in X_0$，有 $B(x) \le 0$。
2.  对于所有[不安全状态](@entry_id:756344) $x \in U$，有 $B(x)  0$。
3.  函数 $B$ 的值沿[系统轨迹](@entry_id:1132840)必须是非增的。根据链式法则，这等价于要求 $B$ 的[李导数](@entry_id:171745)非正：
    $$
    \frac{d}{dt} B(x(t)) = \nabla B(x(t)) \cdot f(x(t)) \le 0 \quad \text{对于所有相关的状态 } x
    $$

如果能找到这样的函数 $B$，那么从 $X_0$ 出发的任何轨迹，其 $B$ 值初始为非正，并且永远不会增加。因此，该轨迹永远无法到达 $B$ 值为正的不安全区域 $U$，从而证明了系统的安全性。