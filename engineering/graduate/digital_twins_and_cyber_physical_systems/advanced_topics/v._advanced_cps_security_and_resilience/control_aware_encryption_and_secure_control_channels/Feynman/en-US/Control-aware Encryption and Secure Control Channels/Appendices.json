{
    "hands_on_practices": [
        {
            "introduction": "The first step in designing a secure control system is to understand the fundamental trade-offs. Adding cryptographic protection to a control loop is not a \"free\" operation; it inevitably introduces computational and network latency. This exercise provides a hands-on analysis of this critical effect, where you will use first principles of control theory to determine the maximum tolerable delay before a simple discrete-time system becomes unstable. By deriving the characteristic equation and analyzing its roots, you will directly quantify how security-induced latency can compromise the physical stability of a cyber-physical system. ",
            "id": "4210596",
            "problem": "A Digital Twin (DT) monitors and commands a Cyber-Physical System (CPS) implementing a discrete-time Linear Time-Invariant (LTI) scalar plant. The plant dynamics are given by $x_{k+1} = a x_k + b u_k$, where $x_k \\in \\mathbb{R}$ is the plant state and $u_k \\in \\mathbb{R}$ is the control input at discrete time $k \\in \\mathbb{Z}_{\\ge 0}$. The DT applies state feedback computed from the latest available state using a control-aware encryption and transport pipeline that introduces a constant, integer sample delay $\\ell \\in \\mathbb{Z}_{\\ge 0}$ between the measurement and actuation. The control law is $u_k = K x_{k-\\ell}$. The closed-loop is required to be Schur stable, meaning the spectral radius of the corresponding state transition operator must be strictly less than $1$.\n\nIn this setting, consider a specific CPS with parameters $a = 0.6$, $b = 1$, and $K = -0.8$. Assume the delay $\\ell$ is constant due to the encryption and transport pipeline. Starting from first principles, use the definition of Schur stability for discrete-time systems and fundamental algebraic tools to analyze the effect of $\\ell$ on the closed-loop eigenvalues. Determine the largest integer delay $\\ell$ for which the closed-loop spectral radius is strictly less than $1$.\n\nExpress your final answer as a single integer with no units. No rounding is needed.",
            "solution": "The problem requires finding the largest integer sample delay $\\ell \\in \\mathbb{Z}_{\\ge 0}$ for which a given discrete-time Linear Time-Invariant (LTI) system remains Schur stable.\n\nFirst, we must validate the problem statement.\n\n### Step 1: Extract Givens\n- Plant dynamics: $x_{k+1} = a x_k + b u_k$, where $x_k \\in \\mathbb{R}$ is the state, $u_k \\in \\mathbb{R}$ is the control input, and $k \\in \\mathbb{Z}_{\\ge 0}$ is the discrete time index.\n- System parameters: $a = 0.6$, $b = 1$.\n- Control law: $u_k = K x_{k-\\ell}$, with gain $K = -0.8$.\n- Delay: $\\ell \\in \\mathbb{Z}_{\\ge 0}$ is a constant, integer sample delay.\n- Stability requirement: The closed-loop system must be Schur stable, meaning the spectral radius of its state transition operator is strictly less than $1$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is based on fundamental principles of linear control theory, specifically the stability analysis of discrete-time systems with time delays. The concepts used (LTI systems, state feedback, Schur stability, characteristic equations) are standard and well-established in engineering and applied mathematics.\n- **Well-Posed:** The problem provides all necessary parameters ($a$, $b$, $K$) and a clear, formal objective: to find the maximum integer delay $\\ell$ that maintains Schur stability. The structure allows for a unique, meaningful solution.\n- **Objective:** The problem is stated using precise mathematical language and definitions, free of ambiguity or subjective claims.\n\nThe problem is self-contained, consistent, and scientifically sound. No flaws are identified.\n\n### Step 3: Verdict and Action\nThe problem is valid. A complete, reasoned solution will be provided.\n\n### Solution\nThe dynamics of the cyber-physical system are given by the discrete-time LTI equation:\n$$x_{k+1} = a x_k + b u_k$$\nThe control input is determined by a state-feedback law with a constant integer delay $\\ell$:\n$$u_k = K x_{k-\\ell}$$\nSubstituting the control law into the plant dynamics yields the closed-loop equation for the state $x_k$:\n$$x_{k+1} = a x_k + b K x_{k-\\ell}$$\nFor the system to be Schur stable, the eigenvalues of the closed-loop system's state transition operator must all have a magnitude strictly less than $1$. The eigenvalues are the roots of the system's characteristic equation.\n\nTo find the characteristic equation, we can utilize the z-transform. Let $X(z)$ be the z-transform of the state sequence $x_k$. Applying the z-transform to the closed-loop equation, we obtain:\n$$z X(z) = a X(z) + b K z^{-\\ell} X(z)$$\nAssuming a non-trivial solution ($X(z) \\neq 0$), we can divide by $X(z)$ to get the characteristic equation in terms of $z$:\n$$z = a + b K z^{-\\ell}$$\nMultiplying by $z^{\\ell}$ gives the polynomial form of the characteristic equation:\n$$z^{\\ell+1} = a z^{\\ell} + b K$$\n$$z^{\\ell+1} - a z^{\\ell} - b K = 0$$\nThe eigenvalues $\\lambda$ of the closed-loop system are the roots of this polynomial. Substituting the given parameters $a = 0.6$, $b = 1$, and $K = -0.8$, the characteristic equation becomes:\n$$\\lambda^{\\ell+1} - 0.6 \\lambda^{\\ell} + 0.8 = 0$$\nSchur stability requires that all roots $\\lambda_i$ of this polynomial satisfy $|\\lambda_i|  1$.\n\nThe system transitions from stable to unstable when at least one root lies on the boundary of the stability region, i.e., on the unit circle in the complex plane. We analyze this boundary case by letting $\\lambda = e^{i\\omega}$ for some frequency $\\omega \\in \\mathbb{R}$. Substituting this into the characteristic equation:\n$$e^{i\\omega(\\ell+1)} - 0.6 e^{i\\omega\\ell} + 0.8 = 0$$\nWe can rearrange this as:\n$$e^{i\\omega(\\ell+1)} = 0.6 e^{i\\omega\\ell} - 0.8$$\nTaking the squared magnitude of both sides:\n$$|e^{i\\omega(\\ell+1)}|^2 = |0.6 e^{i\\omega\\ell} - 0.8|^2$$\nThe magnitude of $e^{i\\phi}$ is always $1$. For the right-hand side, we expand the complex number:\n$$1^2 = |0.6(\\cos(\\omega\\ell) + i\\sin(\\omega\\ell)) - 0.8|^2$$\n$$1 = |(0.6\\cos(\\omega\\ell) - 0.8) + i(0.6\\sin(\\omega\\ell))|^2$$\n$$1 = (0.6\\cos(\\omega\\ell) - 0.8)^2 + (0.6\\sin(\\omega\\ell))^2$$\n$$1 = (0.36\\cos^2(\\omega\\ell) - 0.96\\cos(\\omega\\ell) + 0.64) + 0.36\\sin^2(\\omega\\ell)$$\n$$1 = 0.36(\\cos^2(\\omega\\ell) + \\sin^2(\\omega\\ell)) - 0.96\\cos(\\omega\\ell) + 0.64$$\nUsing the identity $\\cos^2(\\theta) + \\sin^2(\\theta) = 1$:\n$$1 = 0.36 - 0.96\\cos(\\omega\\ell) + 0.64$$\n$$1 = 1 - 0.96\\cos(\\omega\\ell)$$\nThis simplifies to:\n$$0 = -0.96\\cos(\\omega\\ell)$$\n$$\\cos(\\omega\\ell) = 0$$\nThis is a necessary condition for a root to lie on the unit circle. To find the corresponding frequency $\\omega$, we analyze the real and imaginary parts of the original complex equation $e^{i\\omega(\\ell+1)} - 0.6 e^{i\\omega\\ell} + 0.8 = 0$.\nThe imaginary part is:\n$$\\sin(\\omega(\\ell+1)) - 0.6\\sin(\\omega\\ell) = 0$$\nUsing the angle addition formula $\\sin(A+B) = \\sin(A)\\cos(B) + \\cos(A)\\sin(B)$:\n$$\\sin(\\omega\\ell)\\cos(\\omega) + \\cos(\\omega\\ell)\\sin(\\omega) - 0.6\\sin(\\omega\\ell) = 0$$\nSubstituting our condition $\\cos(\\omega\\ell) = 0$:\n$$\\sin(\\omega\\ell)\\cos(\\omega) + (0)\\sin(\\omega) - 0.6\\sin(\\omega\\ell) = 0$$\n$$\\sin(\\omega\\ell)(\\cos(\\omega) - 0.6) = 0$$\nSince $\\cos(\\omega\\ell) = 0$, it must be that $\\sin(\\omega\\ell) = \\pm 1 \\neq 0$. Therefore, the other factor must be zero:\n$$\\cos(\\omega) - 0.6 = 0 \\implies \\cos(\\omega) = 0.6$$\nThe crossing frequency $\\omega_c$ is any frequency such that $\\cos(\\omega_c) = 0.6$. The smallest positive such frequency is $\\omega_c = \\arccos(0.6)$.\n\nThe condition $\\cos(\\omega_c \\ell) = 0$ implies that $\\omega_c \\ell$ must be an odd multiple of $\\pi/2$:\n$$\\omega_c \\ell = (2n+1)\\frac{\\pi}{2} \\text{ for some integer } n \\ge 0$$\nThe critical delay $\\ell_{crit}$ at which the first root crosses the unit circle corresponds to the smallest positive value of $\\ell$, which occurs for $n=0$:\n$$\\omega_c \\ell_{crit} = \\frac{\\pi}{2}$$\n$$\\ell_{crit} = \\frac{\\pi/2}{\\omega_c} = \\frac{\\pi}{2 \\arccos(0.6)}$$\nTo find the largest integer $\\ell$ for which the system is stable, we must check if the system is stable for small $\\ell$ and then find the largest integer $\\ell  \\ell_{crit}$.\n\nFor $\\ell=0$, the characteristic equation is $\\lambda - 0.6\\lambda^0 + 0.8 = 0$, which simplifies to $\\lambda - 0.6 + 0.8 = 0$, yielding $\\lambda = -0.2$. Since $|\\lambda|=0.2  1$, the system is stable for $\\ell=0$. This implies the system is stable for all delays $0 \\le \\ell  \\ell_{crit}$.\n\nNow, we evaluate the numerical value of $\\ell_{crit}$. We know the values of cosine for common angles:\n$\\cos(\\pi/3) = 0.5$ and $\\cos(\\pi/4) = \\frac{\\sqrt{2}}{2} \\approx 0.707$.\nSince $0.5  0.6  0.707$, and arccosine is a decreasing function on its domain, we have:\n$$\\arccos(0.5)  \\arccos(0.6)  \\arccos(0.707)$$\n$$\\frac{\\pi}{3}  \\arccos(0.6)  \\frac{\\pi}{4}$$\nNow we can bound $\\ell_{crit}$:\n$$\\frac{\\pi/(2)}{\\pi/3}  \\ell_{crit}  \\frac{\\pi/(2)}{\\pi/4}$$\n$$1.5  \\ell_{crit}  2$$\nThe critical delay $\\ell_{crit}$ is a value between $1.5$ and $2$. The system is Schur stable for any integer delay $\\ell$ such that $\\ell  \\ell_{crit}$. The integers satisfying this condition are $\\ell=0$ and $\\ell=1$.\nThe largest such integer is $1$. For any integer delay $\\ell \\ge 2$, at least one eigenvalue will have a magnitude greater than or equal to $1$, making the system not strictly Schur stable.\n\nTherefore, the largest integer delay $\\ell$ for which the closed-loop spectral radius is strictly less than $1$ is $1$.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Once we understand that security measures impact real-time performance, the next step is to make informed design choices. This practice presents a classic dilemma in control-aware security: choosing between a standard, randomized encryption scheme that provides strong semantic security (Indistinguishability under Chosen-Plaintext Attack, or IND-CPA) and a deterministic scheme that offers lower overhead but leaks some information. You will perform a quantitative analysis of latency and bandwidth for both options to determine which one meets the strict operational deadlines of a control loop, forcing a pragmatic decision that balances cryptographic ideals with physical reality. ",
            "id": "4210549",
            "problem": "A Digital Twin (DT) of a Cyber-Physical System (CPS) implements a discrete-time controller with sampling period $T_s$ and transmits control commands over a dedicated secure channel. Commands are short and often repeat across successive samples because the plant spends extended intervals near steady-state. The secure channel must enforce confidentiality and integrity. Two designs are under consideration:\n\n- Design R: Advanced Encryption Standard (AES) in Galois/Counter Mode (GCM), which is a randomized authenticated encryption. Each packet includes an Initialization Vector (IV) of length $v$ and a Message Authentication Code (MAC) tag of length $t$. AES-GCM requires unique nonces (IVs) for security.\n\n- Design D: Deterministic Authenticated Encryption (DAE), which removes per-packet random IVs while preserving integrity with a MAC tag of length $t$. DAE is not Indistinguishability under Chosen-Plaintext Attack (IND-CPA) secure because identical plaintexts encrypt to identical ciphertexts under a fixed key and associated data, leaking equality patterns.\n\nAssume the following parameters and constraints hold for the control channel:\n\n- Sampling period $T_s = 3.3\\,\\mathrm{ms}$.\n- Link bandwidth $B = 192\\,\\mathrm{kbit/s}$.\n- Base network latency (propagation plus queuing under reserved service) $L_{\\text{base}} = 1.2\\,\\mathrm{ms}$.\n- Worst-case jitter bound $J_{\\max} = 0.3\\,\\mathrm{ms}$ for the secure-control path.\n- Encryption (and decryption) computational overhead per command is $E_{\\text{enc}} = 0.4\\,\\mathrm{ms}$ (the decryption overhead is absorbed at the actuator side and does not impact the DT’s outbound deadline).\n- Control command payload size $m = 12\\,\\mathrm{bytes}$.\n- MAC tag size $t = 16\\,\\mathrm{bytes}$.\n- IV size for randomized encryption $v = 12\\,\\mathrm{bytes}$ (Design R); Design D carries no random IV.\n- The reserved control slot on the link imposes a per-sample occupancy cap of $\\rho_{\\max} = 0.5$, where occupancy is defined as the serialization time divided by $T_s$.\n- End-to-end timing requirement: the actuation command must be delivered before the next sampling instant; i.e., the worst-case end-to-end latency must be strictly less than $T_s$.\n\nModel the per-packet worst-case end-to-end latency $L_{\\text{wc}}$ as the sum of the cryptographic processing time, the base network latency, the serialization delay, and jitter:\n$$\nL_{\\text{wc}} = E_{\\text{enc}} + L_{\\text{base}} + \\frac{S}{B} + J_{\\max},\n$$\nwhere $S$ is the total bytes transmitted for the encrypted packet. For Design R, $S_R = m + t + v$. For Design D, $S_D = m + t$.\n\nUse the provided parameters to compute the worst-case latency and the link occupancy for each design. Then, decide whether the control loop’s strict timing and bandwidth constraints justify relaxing semantic security (Indistinguishability under Chosen-Plaintext Attack (IND-CPA)) and favor Design D over Design R in this CPS with repeating commands.\n\nWhich option is most correct?\n\nA. Design D is justified. Under the given parameters, Design R violates the worst-case deadline and the occupancy cap, while Design D meets both. Because commands repeat, relaxing semantic security (accepting equality of ciphertexts) is permissible if complemented by per-epoch rekeying (e.g., re-derive the DAE key every $N$ samples) to bound linkability in time, together with integrity via MAC. This control-aware relaxation preserves closed-loop timing feasibility.\n\nB. Design R remains mandatory because semantic security must never be relaxed. Even if Design R exceeds the worst-case deadline and occupancy cap under the given parameters, randomized encryption’s IND-CPA security outweighs control timing, so the controller should accept missed deadlines.\n\nC. Design R can meet the constraints by reusing IVs to cut the $v$-byte overhead; nonce reuse does not compromise integrity in AES-GCM and is safe in a control setting with short messages.\n\nD. Design D is acceptable without any additional measures. Using a long-term static key and omitting rekeying or traffic shaping is secure enough in a control channel because the command alphabet is finite and equality leakage does not reveal actionable information to an adversary.",
            "solution": "The problem statement will first be validated for scientific soundness, consistency, and completeness before a solution is attempted.\n\n### Step 1: Extract Givens\n\nThe following parameters, definitions, and constraints are provided in the problem statement:\n-   **System**: Discrete-time controller in a Digital Twin (DT) of a Cyber-Physical System (CPS).\n-   **Sampling Period**: $T_s = 3.3\\,\\mathrm{ms}$.\n-   **Link Bandwidth**: $B = 192\\,\\mathrm{kbit/s}$.\n-   **Base Network Latency**: $L_{\\text{base}} = 1.2\\,\\mathrm{ms}$.\n-   **Worst-case Jitter Bound**: $J_{\\max} = 0.3\\,\\mathrm{ms}$.\n-   **Encryption Overhead**: $E_{\\text{enc}} = 0.4\\,\\mathrm{ms}$.\n-   **Control Command Payload Size**: $m = 12\\,\\mathrm{bytes}$.\n-   **MAC Tag Size**: $t = 16\\,\\mathrm{bytes}$.\n-   **IV Size (Design R)**: $v = 12\\,\\mathrm{bytes}$.\n-   **Occupancy Cap**: $\\rho_{\\max} = 0.5$.\n-   **Occupancy Definition**: Serialization time divided by $T_s$.\n-   **Timing Requirement**: Worst-case end-to-end latency $L_{\\text{wc}}$ must be strictly less than $T_s$.\n-   **Latency Model**: $L_{\\text{wc}} = E_{\\text{enc}} + L_{\\text{base}} + \\frac{S}{B} + J_{\\max}$.\n-   **Packet Size for Design R**: $S_R = m + t + v$.\n-   **Packet Size for Design D**: $S_D = m + t$.\n-   **Security Properties**:\n    -   Design R (AES-GCM) is a randomized authenticated encryption scheme aiming for Indistinguishability under Chosen-Plaintext Attack (IND-CPA) and requires unique nonces (IVs).\n    -   Design D (DAE) is a deterministic authenticated encryption scheme that is not IND-CPA secure, leaking equality of plaintexts.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is evaluated based on the established criteria:\n1.  **Scientific or Factual Soundness**: The problem is scientifically sound. It presents a realistic engineering trade-off between real-time performance (latency, bandwidth) and cryptographic security properties (confidentiality, integrity). The descriptions of AES-GCM and Deterministic Authenticated Encryption (DAE) are correct; AES-GCM's security relies on nonce uniqueness, and DAE intentionally sacrifices IND-CPA security to achieve determinism, which can sometimes have performance benefits (e.g., smaller packet size). The latency model is a standard and reasonable simplification of network delay components.\n2.  **Non-Formalizable or Irrelevant**: The problem is fully formalizable with given equations and parameters, and is directly relevant to the stated domain of secure control for CPS.\n3.  **Incomplete or Contradictory Setup**: The problem is self-contained. It provides all necessary numerical values, formulas, and constraints to perform the required analysis. There are no contradictions.\n4.  **Unrealistic or Infeasible**: The parameters are plausible for a modern industrial control system. A sampling period of $3.3\\,\\mathrm{ms}$ corresponds to a control frequency of approximately $303\\,\\mathrm{Hz}$, which is demanding but realistic for applications like motor control. The bandwidth and latency values are also within expected ranges for dedicated industrial networks.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed. It asks for a quantitative comparison followed by a qualitative judgment based on established engineering and security principles. A unique, stable, and meaningful analysis can be performed.\n\n### Step 3: Verdict and Action\nThe problem statement is **valid**. The scenario is a well-defined engineering problem that requires quantitative calculation and an informed decision based on balancing competing requirements. I will now proceed with the solution derivation.\n\n### Derivation and Analysis\n\nThe analysis requires computing the worst-case latency ($L_{\\text{wc}}$) and link occupancy ($\\rho$) for both Design R and Design D and comparing them against the given constraints: $L_{\\text{wc}}  T_s$ and $\\rho  \\rho_{\\max}$.\n\nFirst, establish constants and perform necessary unit conversions.\n-   $T_s = 3.3\\,\\mathrm{ms} = 3.3 \\times 10^{-3}\\,\\mathrm{s}$.\n-   $B = 192\\,\\mathrm{kbit/s} = 192 \\times 10^3\\,\\mathrm{bit/s}$.\n-   The conversion from bytes to bits is $1\\,\\mathrm{byte} = 8\\,\\mathrm{bits}$.\n\n**Analysis of Design R (Randomized AES-GCM)**\n\n1.  **Packet Size ($S_R$)**:\n    The total size is the sum of payload, MAC tag, and IV.\n    $$S_R = m + t + v = 12\\,\\mathrm{bytes} + 16\\,\\mathrm{bytes} + 12\\,\\mathrm{bytes} = 40\\,\\mathrm{bytes}$$\n    In bits, this is:\n    $$S_R = 40\\,\\mathrm{bytes} \\times 8\\,\\mathrm{bits/byte} = 320\\,\\mathrm{bits}$$\n\n2.  **Serialization Delay ($S_R/B$)**:\n    This is the time required to transmit the packet over the link.\n    $$\\frac{S_R}{B} = \\frac{320\\,\\mathrm{bits}}{192 \\times 10^3\\,\\mathrm{bit/s}} = \\frac{320}{192000}\\,\\mathrm{s} = \\frac{1}{600}\\,\\mathrm{s}$$\n    Converting to milliseconds:\n    $$\\frac{1}{600}\\,\\mathrm{s} \\times 1000\\,\\mathrm{ms/s} = \\frac{5}{3}\\,\\mathrm{ms} \\approx 1.667\\,\\mathrm{ms}$$\n\n3.  **Link Occupancy ($\\rho_R$)**:\n    This is the ratio of serialization delay to the sampling period.\n    $$\\rho_R = \\frac{S_R/B}{T_s} = \\frac{5/3\\,\\mathrm{ms}}{3.3\\,\\mathrm{ms}} \\approx \\frac{1.667}{3.3} \\approx 0.505$$\n    The occupancy cap is $\\rho_{\\max} = 0.5$. Since $\\rho_R \\approx 0.505  0.5$, **Design R violates the occupancy constraint**.\n\n4.  **Worst-Case Latency ($L_{\\text{wc, R}}$)**:\n    We sum the delay components.\n    $$L_{\\text{wc, R}} = E_{\\text{enc}} + L_{\\text{base}} + \\frac{S_R}{B} + J_{\\max}$$\n    $$L_{\\text{wc, R}} = 0.4\\,\\mathrm{ms} + 1.2\\,\\mathrm{ms} + \\frac{5}{3}\\,\\mathrm{ms} + 0.3\\,\\mathrm{ms} = 1.9\\,\\mathrm{ms} + \\frac{5}{3}\\,\\mathrm{ms} \\approx 1.9 + 1.667 = 3.567\\,\\mathrm{ms}$$\n    The timing deadline is $T_s = 3.3\\,\\mathrm{ms}$. Since $L_{\\text{wc, R}} \\approx 3.567\\,\\mathrm{ms}  3.3\\,\\mathrm{ms}$, **Design R violates the end-to-end timing constraint**.\n\n**Analysis of Design D (Deterministic DAE)**\n\n1.  **Packet Size ($S_D$)**:\n    The total size is the sum of payload and MAC tag, with no IV.\n    $$S_D = m + t = 12\\,\\mathrm{bytes} + 16\\,\\mathrm{bytes} = 28\\,\\mathrm{bytes}$$\n    In bits, this is:\n    $$S_D = 28\\,\\mathrm{bytes} \\times 8\\,\\mathrm{bits/byte} = 224\\,\\mathrm{bits}$$\n\n2.  **Serialization Delay ($S_D/B$)**:\n    $$\\frac{S_D}{B} = \\frac{224\\,\\mathrm{bits}}{192 \\times 10^3\\,\\mathrm{bit/s}} = \\frac{224}{192000}\\,\\mathrm{s} = \\frac{7}{6000}\\,\\mathrm{s}$$\n    Converting to milliseconds:\n    $$\\frac{7}{6000}\\,\\mathrm{s} \\times 1000\\,\\mathrm{ms/s} = \\frac{7}{6}\\,\\mathrm{ms} \\approx 1.167\\,\\mathrm{ms}$$\n\n3.  **Link Occupancy ($\\rho_D$)**:\n    $$\\rho_D = \\frac{S_D/B}{T_s} = \\frac{7/6\\,\\mathrm{ms}}{3.3\\,\\mathrm{ms}} \\approx \\frac{1.167}{3.3} \\approx 0.354$$\n    Since $\\rho_D \\approx 0.354  0.5$, **Design D meets the occupancy constraint**.\n\n4.  **Worst-Case Latency ($L_{\\text{wc, D}}$)**:\n    $$L_{\\text{wc, D}} = E_{\\text{enc}} + L_{\\text{base}} + \\frac{S_D}{B} + J_{\\max}$$\n    $$L_{\\text{wc, D}} = 0.4\\,\\mathrm{ms} + 1.2\\,\\mathrm{ms} + \\frac{7}{6}\\,\\mathrm{ms} + 0.3\\,\\mathrm{ms} = 1.9\\,\\mathrm{ms} + \\frac{7}{6}\\,\\mathrm{ms} \\approx 1.9 + 1.167 = 3.067\\,\\mathrm{ms}$$\n    Since $L_{\\text{wc, D}} \\approx 3.067\\,\\mathrm{ms}  3.3\\,\\mathrm{ms}$, **Design D meets the end-to-end timing constraint**.\n\n### Summary of Quantitative Results\n-   **Design R**: Violates both the occupancy constraint ($\\rho_R \\approx 0.505  0.5$) and the latency deadline ($L_{\\text{wc, R}} \\approx 3.567\\,\\mathrm{ms}  3.3\\,\\mathrm{ms}$). It is infeasible under the given parameters.\n-   **Design D**: Meets both the occupancy constraint ($\\rho_D \\approx 0.354  0.5$) and the latency deadline ($L_{\\text{wc, D}} \\approx 3.067\\,\\mathrm{ms}  3.3\\,\\mathrm{ms}$). It is feasible.\n\nThe quantitative analysis demonstrates that the system cannot function correctly with Design R, as it would miss deadlines, which can lead to control loop instability. Therefore, a solution that meets the timing constraints is necessary. The question becomes whether the security relaxation in Design D is justifiable.\n\n### Option-by-Option Analysis\n\n**A. Design D is justified. Under the given parameters, Design R violates the worst-case deadline and the occupancy cap, while Design D meets both. Because commands repeat, relaxing semantic security (accepting equality of ciphertexts) is permissible if complemented by per-epoch rekeying (e.g., re-derive the DAE key every $N$ samples) to bound linkability in time, together with integrity via MAC. This control-aware relaxation preserves closed-loop timing feasibility.**\n-   The first sentence is fully supported by the calculations above. Design R fails, and Design D succeeds.\n-   The second sentence addresses the security trade-off. It acknowledges the weakness of DAE (leakage of equality) but proposes a standard and effective mitigation: periodic rekeying. This bounds the duration over which an attacker can link identical commands, thus limiting the information leakage. This approach represents a sound engineering trade-off, prioritizing the fundamental operational requirement (timing feasibility for control stability) while adopting a measured, risk-managed approach to security. This philosophy is often termed \"security-control co-design.\" The presence of a MAC preserves integrity, which is often more critical than confidentiality in control systems.\n-   **Verdict: Correct.** This option accurately reflects the calculations and proposes a valid, responsible engineering compromise.\n\n**B. Design R remains mandatory because semantic security must never be relaxed. Even if Design R exceeds the worst-case deadline and occupancy cap under the given parameters, randomized encryption’s IND-CPA security outweighs control timing, so the controller should accept missed deadlines.**\n-   This option posits that a specific security property (IND-CPA) is an absolute requirement that must be met even at the cost of system failure. In a real-time control system, consistently missing deadlines leads to performance degradation and, critically, can cause instability, leading to physical damage or safety hazards. The purpose of security is to protect the function and safety of the system; an approach to security that compromises the system's fundamental function is illogical and dangerous. This absolutist view is poor engineering.\n-   **Verdict: Incorrect.**\n\n**C. Design R can meet the constraints by reusing IVs to cut the $v$-byte overhead; nonce reuse does not compromise integrity in AES-GCM and is safe in a control setting with short messages.**\n-   This option suggests a cryptographically catastrophic action. Reusing a nonce (IV) with the same key in AES-GCM completely breaks both its confidentiality and its authentication properties. Specifically, an attacker observing two ciphertexts encrypted with the same nonce can recover the authentication subkey, allowing them to forge messages at will. The statement that \"nonce reuse does not compromise integrity\" is factually and dangerously false. It is one of the most well-known vulnerabilities of GCM. The problem statement itself correctly notes that GCM requires *unique* nonces for security.\n-   **Verdict: Incorrect.**\n\n**D. Design D is acceptable without any additional measures. Using a long-term static key and omitting rekeying or traffic shaping is secure enough in a control channel because the command alphabet is finite and equality leakage does not reveal actionable information to an adversary.**\n-   This option correctly identifies that Design D is feasible but is overly complacent about the security risks. The leakage of command equality, especially with a long-term static key, can provide significant \"actionable information\" to an adversary via traffic analysis. An attacker could learn the system's operational patterns, detect transitions between states (e.g., from idle to active), and infer the system's response to events without ever decrypting a message. Claiming this leakage is not actionable is an unsubstantiated and risky assumption. Good security practice dictates that known information leaks should be mitigated if possible. Option A's suggestion of rekeying is a prudent mitigation that this option dismisses.\n-   **Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "A truly secure system must be resilient not only to network attacks but also to component failures and restarts. This advanced practice addresses the critical challenge of maintaining the integrity of a secure channel when a controller unexpectedly reboots and loses its volatile state, such as the sequence number used as a cryptographic nonce. By evaluating several recovery protocols, you will learn to identify subtle vulnerabilities and design a robust solution using a hardware root of trust, ensuring the system can recover its secure state without risking nonce reuse or denial-of-service attacks. ",
            "id": "4210573",
            "problem": "A cyber-physical system controller communicates with its actuator over an Authenticated Encryption with Associated Data (AEAD) channel instantiated by Galois/Counter Mode (GCM). The controller uses a per-packet sequence number as the AEAD nonce under a session key. The plant enforces an anti-replay policy with a sliding window over accepted nonces. The following fundamental base applies:\n\n- AEAD with Galois/Counter Mode (GCM) requires that, for a fixed key $K$, the nonce $N$ must be unique across all encryptions; reusing a nonce with the same key can break authenticity and confidentiality.\n- A sliding-window anti-replay filter maintains a lower bound $L$ and a window size $W \\in \\mathbb{N}$; a newly received packet with sequence $s$ is accepted if either $s  L$ and $s - L \\leq W$ and it is not a duplicate, or if $s$ advances $L$ by pushing the window forward.\n- A monotonic counter $e \\in \\mathbb{N}$ is one that can only increase, never decrease.\n\nSuppose the controller stores volatile state for the per-packet sequence number $s \\in \\mathbb{N}$ and loses all volatile state on restart. The plant’s anti-replay window maintains the largest accepted sequence number $\\hat{s}$ in the current epoch. The attacker can delay, drop, and replay messages and can trigger controller restarts, but cannot forge AEAD tags or break cryptographic assumptions. There exists a Trusted Platform Module (TPM) on the controller that can store and atomically update a non-volatile monotonic counter $e \\in \\mathbb{N}$ and a non-volatile long-term secret $K_{\\mathrm{master}}$, but the TPM writes are costly and should not be performed excessively. The plant maintains state across controller restarts.\n\nYou must reason from the above fundamentals to characterize how sequence numbers must be managed across controller restarts to prevent nonce or sequence reuse, and to propose a recovery protocol that guarantees monotonicity without risking denial-of-service by an adversary who can repeatedly force restarts or block messages. Consider the following candidate designs; each uses AEAD with nonces constructed from some sequence-related metadata, and each attempts to recover after a controller restart:\n\nA. After restart, the controller sends an unauthenticated “RESET” control-plane message, rotates to a fresh symmetric key $K'$, and restarts the per-packet sequence number at $s = 0$. The plant discards any packets under the old key and accepts packets under $K'$ with a fresh anti-replay window.\n\nB. The controller attempts to read the last known volatile $s$ from its local log and resumes at $s \\leftarrow s+1$. If $s$ is unavailable, it sets $s \\leftarrow 0$ and relies on the plant’s anti-replay window of size $W$ to reject duplicates.\n\nC. The controller maintains a non-volatile monotonic epoch counter $e$ in the TPM and derives the session key as $K_e = \\mathrm{PRF}(K_{\\mathrm{master}}, e \\parallel \\text{context})$. Per epoch, it initializes the per-packet index at $s = 0$ and uses a nonce $N = \\mathrm{Enc}(e, s)$ where $\\mathrm{Enc}$ is an injective encoding into the AEAD nonce space. Recovery uses a two-phase commit:\n   1. The controller proposes $e_{\\mathrm{next}} = e + 1$ to the plant in an authenticated message under the long-term identity (not using $K_e$), including an attestation of its current $e$.\n   2. The plant replies with a signed message containing its last accepted epoch $e_{\\mathrm{last}}$ and a challenge.\n   3. The controller sets $e_{\\mathrm{new}} = \\max(e_{\\mathrm{next}}, e_{\\mathrm{last}} + 1)$, commits $e_{\\mathrm{new}}$ atomically in the TPM, derives $K_{e_{\\mathrm{new}}}$, and starts with $s = 0$.\n   4. The plant updates its anti-replay state to the new epoch only upon verifying the first valid AEAD packet with nonce $(e_{\\mathrm{new}}, 0)$ and advances its window for that epoch. Proposals that do not complete are discarded by the controller without changing $e$.\n\nD. Nonces are chosen randomly: for each packet, the controller draws a fresh $96$-bit nonce $N \\leftarrow \\{0,1\\}^{96}$ uniformly at random, and sets $s$ to this random value. After restart, the controller continues choosing random nonces and relies on the extremely low collision probability to avoid nonce reuse. The plant accepts any nonce greater than the last according to numeric ordering, modulo wrap-around.\n\nE. The controller uses the same symmetric key $K$ across restarts. After restart, it sends a query to the plant over AEAD asking for the last accepted sequence number $\\hat{s}$, and then resumes with $s \\leftarrow \\hat{s} + 1$ so that nonces are strictly increasing.\n\nWhich design guarantees the required properties: prevention of nonce or sequence reuse even across restarts, monotonic progression of accepted nonces at the plant, and resistance to denial-of-service by an adversary who can force restarts or block handshake messages?\n\nChoose the single best option that meets all requirements.",
            "solution": "The user wants me to act as a meticulous STEM professor to validate and solve a problem concerning secure communication protocols in a cyber-physical system.\n\n### Problem Validation\n\nFirst, I will validate the problem statement according to the specified procedure.\n\n#### Step 1: Extract Givens\n\n-   **System:** A controller communicates with an actuator (plant) in a cyber-physical system.\n-   **Channel:** Authenticated Encryption with Associated Data (AEAD) using Galois/Counter Mode (GCM).\n-   **Nonce Generation:** The controller uses a per-packet sequence number as the AEAD nonce under a session key.\n-   **Plant Policy:** An anti-replay policy with a sliding window over accepted nonces.\n-   **GCM Requirement:** For a fixed key $K$, the nonce $N$ must be unique across all encryptions. Reusing a nonce with the same key can break authenticity and confidentiality.\n-   **Anti-Replay Policy:** A sliding-window filter with a lower bound $L$ and a window size $W \\in \\mathbb{N}$ accepts a new packet with sequence $s$ if $s  L$ and $s - L \\leq W$ and it is not a duplicate, or if $s$ advances $L$.\n-   **Monotonic Counter:** A monotonic counter $e \\in \\mathbb{N}$ can only increase.\n-   **Controller State:** Stores the per-packet sequence number $s \\in \\mathbb{N}$ in volatile memory, which is lost on restart.\n-   **Plant State:** Maintains the largest accepted sequence number $\\hat{s}$ in the current epoch, and this state persists across controller restarts.\n-   **Attacker Model:** The attacker can delay, drop, and replay messages, and can trigger controller restarts. The attacker cannot forge AEAD tags or break cryptographic assumptions.\n-   **Hardware Security Module:** The controller possesses a Trusted Platform Module (TPM).\n-   **TPM Capabilities:** The TPM can store and atomically update a non-volatile monotonic counter $e \\in \\mathbb{N}$ and a non-volatile long-term secret $K_{\\mathrm{master}}$.\n-   **TPM Constraint:** TPM writes are costly and should not be performed excessively.\n-   **Objective:** Find the design that guarantees:\n    1.  Prevention of nonce or sequence reuse, even across restarts.\n    2.  Monotonic progression of accepted nonces at the plant.\n    3.  Resistance to denial-of-service (DoS) by an adversary who can force restarts or block handshake messages.\n\n#### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded:** The problem is firmly rooted in established principles of cryptography (AEAD, GCM, nonce-respecting encryption), network security (anti-replay protocols), and systems security (use of a TPM for trusted state). The GCM nonce uniqueness requirement is a critical and well-known fact. The attacker model is standard for protocol analysis. The scenario is a canonical problem in designing resilient and secure cyber-physical systems. The problem is scientifically and factually sound.\n-   **Well-Posed:** The problem provides a clear objective and a set of constraints. It asks for an evaluation of several proposed designs against a set of well-defined security and liveness properties. A unique best option among the choices can be determined through logical deduction.\n-   **Objective:** The problem is stated in precise, technical language, free of ambiguity or subjectivity. The criteria for success (nonce uniqueness, monotonicity, DoS resistance) are objective.\n-   **Completeness and Consistency:** The problem provides all necessary information: the system components, their state management (volatile vs. non-volatile), security mechanisms, threat model, and available hardware primitives. The constraints are consistent and define the core challenge.\n-   **Realism:** This scenario is highly realistic. Controllers in industrial or embedded systems are subject to crashes and reboots, making the management of persistent sequence numbers a critical design concern. The use of a TPM to anchor a security protocol is a standard and recommended practice.\n\n#### Step 3: Verdict and Action\n\nThe problem statement is **valid**. It is well-defined, scientifically sound, and presents a non-trivial challenge in secure systems design. I will now proceed to derive the correct solution and evaluate each option.\n\n### Solution Derivation\n\nThe core of the problem lies in the disconnect between the controller's volatile state and the plant's persistent state. After a restart, the controller loses its current sequence number $s$, while the plant remembers the highest sequence number it has accepted, $\\hat{s}$. This creates two immediate problems if not handled correctly:\n\n1.  **Nonce Reuse:** If the controller reuses the same session key $K$ after a restart and begins its sequence number $s$ from a value less than or equal to $\\hat{s}$, it will reuse a nonce. For GCM, reusing a nonce with the same key is a catastrophic failure that compromises both confidentiality and authenticity.\n2.  **Denial-of-Service (DoS):** The plant's anti-replay window will reject any packet with a sequence number $s$ that is not greater than those it has already seen (specifically, those not in its current window). If the controller restarts its sequence numbering from $0$, all its initial messages will be dropped by the plant, leading to a DoS until $s$ eventually surpasses $\\hat{s}$.\n\nA robust solution must therefore ensure that after a restart, the controller begins using nonces that are guaranteed to be unique and acceptable to the plant. This can be achieved in two fundamental ways:\n-   **Key Rotation:** Start a new security context with a fresh cryptographic key $K'$. With a new key, the nonce sequence can be safely reset to $0$, as the uniqueness requirement for GCM nonces is per-key.\n-   **State Synchronization:** Recover the last state from the plant (or a trusted third party) and resume the sequence from a value guaranteed to be fresh, e.g., $\\hat{s} + 1$.\n\nThe solution must also be resilient to an active adversary who can trigger restarts and block messages. This implies any recovery handshake must be robust against message loss and replay, and progress must be durably stored. The TPM's non-volatile monotonic counter $e$ is the ideal tool for this, as it allows the controller to make persistent, irreversible forward progress. An epoch-based system, where each epoch $e$ has its own session key $K_e$ derived from $K_{\\mathrm{master}}$, is a natural fit.\n\n### Option-by-Option Analysis\n\n**A. After restart, the controller sends an unauthenticated “RESET” control-plane message, rotates to a fresh symmetric key $K'$, and restarts the per-packet sequence number at $s = 0$. The plant discards any packets under the old key and accepts packets under $K'$ with a fresh anti-replay window.**\n\n-   **Analysis:** This design correctly identifies the need for key rotation to allow resetting the sequence number. However, the mechanism is critically flawed. The \"RESET\" message is unauthenticated. An attacker can inject this message at any time to trigger a DoS, causing the plant to reject all subsequent legitimate packets sent under the old key. Conversely, an attacker can block the RESET message after a controller restart. The controller would start sending packets with the new key $K'$, but the plant would still be expecting the old key and reject them all. This lack of a secure, acknowledged handshake makes the protocol vulnerable.\n-   **Verdict: Incorrect.**\n\n**B. The controller attempts to read the last known volatile $s$ from its local log and resumes at $s \\leftarrow s+1$. If $s$ is unavailable, it sets $s \\leftarrow 0$ and relies on the plant’s anti-replay window of size $W$ to reject duplicates.**\n\n-   **Analysis:** This design has multiple severe flaws. The premise states the controller loses all *volatile* state. A local log, unless specifically implemented on non-volatile storage with atomic writes, is also unreliable or lost. The fallback, setting $s \\leftarrow 0$, is catastrophic. It assumes the key $K$ is reused across restarts. This leads to guaranteed nonce reuse, breaking GCM security. Furthermore, even if the GCM failure were ignored, restarting from $s=0$ when the plant's last seen sequence $\\hat{s}$ is large results in a prolonged DoS, as the plant will reject all packets with sequence numbers less than its anti-replay window's lower bound.\n-   **Verdict: Incorrect.**\n\n**C. The controller maintains a non-volatile monotonic epoch counter $e$ in the TPM and derives the session key as $K_e = \\mathrm{PRF}(K_{\\mathrm{master}}, e \\parallel \\text{context})$. Per epoch, it initializes the per-packet index at $s = 0$ and uses a nonce $N = \\mathrm{Enc}(e, s)$ where $\\mathrm{Enc}$ is an injective encoding into the AEAD nonce space. Recovery uses a two-phase commit...**\n\n-   **Analysis:** This design uses the TPM correctly to create a secure foundation for recovery.\n    1.  **Nonce Reuse Prevention:** The session key $K_e$ is tied to the epoch $e$, and the nonce is a function of both $e$ and the intra-epoch sequence number $s$. Since the protocol guarantees that $e$ is strictly increasing across restarts, the pair $(e,s)$ will be globally unique. Even if the key were not changed, the inclusion of $e$ in the nonce would ensure uniqueness. Using both a new key $K_e$ and including $e$ in the nonce provides defense-in-depth and robustly prevents nonce reuse.\n    2.  **Monotonic Progression:** The nonce, incorporating the strictly monotonic epoch $e$, provides a clear monotonic ordering.\n    3.  **DoS Resistance:** The two-phase commit handshake is robust.\n        -   The handshake is authenticated, preventing spoofing.\n        -   The logic $e_{\\mathrm{new}} = \\max(e_{\\mathrm{next}}, e_{\\mathrm{last}} + 1)$ correctly resolves any desynchronization between controller and plant.\n        -   The controller commits the new epoch to the TPM *only* after confirming with the plant, preventing wasted TPM writes if the handshake is interrupted. The rule \"Proposals that do not complete are discarded by the controller without changing $e$\" is crucial for this.\n        -   The plant only accepts the new epoch upon receipt of a valid AEAD packet, which serves as an implicit acknowledgment that the controller has successfully committed. This prevents the plant from getting stuck in an invalid state.\n    This architecture is a textbook example of a secure state-synchronization protocol resilient to network failures and adversarial interference. It meets all stated requirements.\n-   **Verdict: Correct.**\n\n**D. Nonces are chosen randomly: for each packet, the controller draws a fresh $96$-bit nonce $N \\leftarrow \\{0,1\\}^{96}$ uniformly at random, and sets $s$ to this random value. After restart, the controller continues choosing random nonces and relies on the extremely low collision probability to avoid nonce reuse. The plant accepts any nonce greater than the last according to numeric ordering, modulo wrap-around.**\n\n-   **Analysis:** This design is fundamentally flawed and internally inconsistent. The plant's policy requires a monotonically increasing sequence (\"accepts any nonce greater than the last\"). However, the controller generates nonces *randomly*. A randomly generated $96$-bit number has approximately a $50\\%$ probability of being numerically smaller than the previous one. This means, on average, the plant would reject half of all packets. This is a severe, self-inflicted DoS, rendering the system unusable. While random nonces are a valid strategy for GCM in some contexts (where no ordering is required), they are completely incompatible with the stated anti-replay mechanism.\n-   **Verdict: Incorrect.**\n\n**E. The controller uses the same symmetric key $K$ across restarts. After restart, it sends a query to the plant over AEAD asking for the last accepted sequence number $\\hat{s}$, and then resumes with $s \\leftarrow \\hat{s} + 1$ so that nonces are strictly increasing.**\n\n-   **Analysis:** This approach attempts state synchronization but contains a fatal bootstrapping problem and a liveness vulnerability. To send the initial query \"over AEAD\", the controller must construct a valid, authenticated packet. This requires a nonce. But the entire purpose of the query is to determine a safe nonce to use. This is a Catch-22. The controller has no way to safely send the first message. Even if one assumes a special out-of-band mechanism for this query, the protocol remains vulnerable. An attacker can allow the query-response to succeed, but then block the first data packet (at $s = \\hat{s}+1$) and trigger another controller restart. Since the controller has no non-volatile memory of its own progress, it will be reset to the same initial state of ignorance. It will re-query the plant, get the same $\\hat{s}$ (since no new packets were accepted), and try again with $\\hat{s}+1$. The attacker can repeat this indefinitely, preventing the system from ever making forward progress. This is a\nliveness failure and a form of DoS.\n-   **Verdict: Incorrect.**",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}