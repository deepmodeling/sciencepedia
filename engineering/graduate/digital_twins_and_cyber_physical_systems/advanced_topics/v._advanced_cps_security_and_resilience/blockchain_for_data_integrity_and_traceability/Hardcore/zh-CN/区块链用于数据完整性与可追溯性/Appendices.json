{
    "hands_on_practices": [
        {
            "introduction": "使用区块链保障数据完整性的基石是密码学哈希函数的安全性。本练习旨在量化这一安全性，具体探讨“抗碰撞性”这一关键属性。通过计算在给定哈希长度下发生碰撞的概率，您将亲身体会到现代密码学所提供的巨大安全保障，并理解为何我们可以信任哈希值来唯一地代表数字孪生中的海量数据。",
            "id": "4207086",
            "problem": "数字孪生是物理资产的计算表示，其状态变化会随时间被记录下来。考虑一个信息物理系统，其中每个数字孪生记录通过提交其内容物的加密哈希值，锚定到分布式账本技术（DLT）系统。假设哈希函数在随机预言机模型（ROM）下表现为理想的随机函数：对于固定的比特长度 $b$，每个输入都均匀且独立地映射到 $M = 2^{b}$ 个可能的输出之一。\n\n假设有 $n$ 条独立的记录被锚定，方法是将每条记录哈希为一个 $b$ 比特的摘要，并将该摘要包含在一个区块链交易中。定义碰撞为两个不同记录产生相同摘要的事件。仅从随机预言机模型（ROM）假设和有放回抽样的核心组合概率原理出发，推导碰撞概率 $p$ 作为 $n$ 和 $b$ 的函数的渐近表达式，该表达式在 $n \\ll 2^{b/2}$ 的范围内有效。然后，使用您推导的表达式，确定在此锚定场景中，当 $b = 256$ 时，使得碰撞概率满足 $p \\leq 10^{-6}$ 的最大值 $n$。将最终数值答案四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学上合理、定义明确且客观。\n\n### 第一步：提取已知条件\n- 数字孪生系统将记录锚定到分布式账本技术（DLT）系统。\n- 锚定是通过提交记录内容的加密哈希值来完成的。\n- 哈希函数在随机预言机模型（ROM）下被建模为理想的随机函数。\n- 哈希函数具有固定的比特长度 $b$。\n- 可能的哈希输出数量为 $M = 2^b$。\n- 每个输入都均匀且独立地映射到 $M$ 个输出之一。\n- 独立记录的数量为 $n$。\n- 碰撞被定义为两个不同记录产生相同哈希摘要的事件。\n- 任务1：在 $n \\ll 2^{b/2}$ 的范围内，推导碰撞概率 $p$ 作为 $n$ 和 $b$ 的函数的渐近表达式。此推导必须从有放回抽样的核心组合概率原理出发。\n- 任务2：使用推导出的表达式，确定当 $b=256$ 时，使得碰撞概率 $p \\leq 10^{-6}$ 的最大值 $n$。\n- 舍入说明：最终的 $n$ 值数值答案必须四舍五入到四位有效数字。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据。随机预言机模型是密码学中分析哈希函数安全性的标准理论工具。所描述的场景——哈希数据并将哈希值存储在区块链上以确保完整性——是DLT的一个常见且有效的应用。该问题是概率论中经典“生日问题”的一个变体。\n\n该问题定义明确。它提供了所有必要的参数（$n$、$b$、$p$）和一个明确的目标。要求在特定范围（$n \\ll 2^{b/2}$）内进行渐近推导是精确的。随后的数值计算基于特定的值和一个明确的约束，从而导出一个唯一的解。\n\n该问题是客观的。其语言是技术性的，没有歧义或主观陈述。\n\n问题陈述没有违反任何无效标准。它是科学上合理的、可形式化的、完整的和结构良好的。\n\n### 第三步：结论与行动\n该问题被判定为有效。将提供完整的解答。\n\n### 解答推导\n\n这个问题等同于生日问题。我们从一个包含 $M$ 种可能性的集合中，有放回地选择 $n$ 个项目（哈希值），我们想要找到至少有一次重复（即碰撞）的概率。\n\n设 $p$ 为至少发生一次碰撞的概率。首先计算其互补事件的概率 $p_{nc}$ 会更简单，即没有碰撞的概率。\n\n对 $n$ 条记录进行哈希的总可能结果数为 $M^n$，因为 $n$ 条记录中的每一条都可以独立地哈希到 $M$ 个值中的任意一个。\n\n对于没有碰撞的事件，每条记录必须哈希到唯一的值。\n第一条记录可以哈希到 $M$ 个值中的任意一个。\n第二条记录必须哈希到剩下的 $M-1$ 个值中的一个。\n第三条记录必须哈希到剩下的 $M-2$ 个值中的一个。\n...\n第 $n$ 条记录必须哈希到剩下的 $M-(n-1)$ 个值中的一个。\n\n没有碰撞的结果数是以下乘积：\n$$N_{nc} = M(M-1)(M-2)\\cdots(M-n+1)$$\n这是 $M$ 的 $n$-排列数，记作 $P(M, n)$。\n\n没有碰撞的概率 $p_{nc}$ 是有利结果数与总结果数的比值：\n$$p_{nc} = \\frac{M(M-1)\\cdots(M-n+1)}{M^n} = \\frac{M}{M} \\cdot \\frac{M-1}{M} \\cdot \\frac{M-2}{M} \\cdots \\frac{M-n+1}{M}$$\n这可以写成一个乘积形式：\n$$p_{nc} = \\prod_{k=0}^{n-1} \\left(1 - \\frac{k}{M}\\right)$$\n因此，至少发生一次碰撞的概率 $p$ 是：\n$$p = 1 - p_{nc} = 1 - \\prod_{k=0}^{n-1} \\left(1 - \\frac{k}{M}\\right)$$\n\n现在，我们必须推导在 $n \\ll 2^{b/2} = \\sqrt{M}$ 范围内有效的 $p$ 的渐近表达式。在此范围内，$n$ 远小于 $M$，这确保了对于乘积中的所有 $k$（$0 \\leq k  n$），$k/M$ 都非常小。\n\n我们可以分析 $p_{nc}$ 的自然对数：\n$$\\ln(p_{nc}) = \\ln\\left(\\prod_{k=0}^{n-1} \\left(1 - \\frac{k}{M}\\right)\\right) = \\sum_{k=0}^{n-1} \\ln\\left(1 - \\frac{k}{M}\\right)$$\n对于一个很小的值 $x$，自然对数的泰勒级数展开为 $\\ln(1-x) = -x - \\frac{x^2}{2} - \\frac{x^3}{3} - \\cdots$。由于 $k/M$ 很小，我们可以近似为 $\\ln(1 - k/M) \\approx -k/M$。\n$$\\ln(p_{nc}) \\approx \\sum_{k=0}^{n-1} \\left(-\\frac{k}{M}\\right) = -\\frac{1}{M} \\sum_{k=0}^{n-1} k$$\n前 $n-1$ 个非负整数的和由公式 $\\frac{(n-1)n}{2}$ 给出。\n$$\\ln(p_{nc}) \\approx -\\frac{n(n-1)}{2M}$$\n对两边取指数，得到 $p_{nc}$ 的一个近似值：\n$$p_{nc} \\approx \\exp\\left(-\\frac{n(n-1)}{2M}\\right)$$\n将此代入 $p$ 的表达式中：\n$$p \\approx 1 - \\exp\\left(-\\frac{n(n-1)}{2M}\\right)$$\n条件 $n \\ll \\sqrt{M}$ 意味着 $n^2 \\ll M$，这表示指数函数的参数 $y = \\frac{n(n-1)}{2M}$ 非常接近于零。我们可以使用 $e^{-y} = 1 - y + \\frac{y^2}{2!} - \\cdots$ 的泰勒级数展开。对于小的 $y$，我们可以近似为 $e^{-y} \\approx 1-y$。\n$$p \\approx 1 - \\left(1 - \\frac{n(n-1)}{2M}\\right) = \\frac{n(n-1)}{2M}$$\n对于大的 $n$，我们可以进一步近似 $n(n-1) \\approx n^2$，得到 $p \\approx \\frac{n^2}{2M}$。然而，表达式 $p \\approx \\frac{n(n-1)}{2M}$ 更为精确。代入 $M = 2^b$，推导出的渐近表达式为：\n$$p \\approx \\frac{n(n-1)}{2 \\cdot 2^b}$$\n\n这完成了问题的第一部分。对于第二部分，我们必须找到当哈希比特长度 $b = 256$ 时，使得 $p \\leq 10^{-6}$ 的最大值 $n$。\n我们使用推导出的渐近表达式：\n$$\\frac{n(n-1)}{2 \\cdot 2^{256}} \\leq 10^{-6}$$\n由于我们预计 $n$ 会是一个非常大的数，所以近似 $n(n-1) \\approx n^2$ 是高度精确的。不等式变为：\n$$\\frac{n^2}{2 \\cdot 2^{256}} \\leq 10^{-6}$$\n解出 $n$：\n$$n^2 \\leq 2 \\cdot 2^{256} \\cdot 10^{-6}$$\n$$n^2 \\leq 2^{257} \\cdot 10^{-6}$$\n$$n \\leq \\sqrt{2^{257} \\cdot 10^{-6}} = 2^{257/2} \\cdot 10^{-3} = 2^{128.5} \\cdot 10^{-3}$$\n为了计算这个值，我们使用以10为底的对数：\n$$\\log_{10}(n) \\leq \\log_{10}(2^{128.5} \\cdot 10^{-3})$$\n$$\\log_{10}(n) \\leq \\log_{10}(2^{128.5}) + \\log_{10}(10^{-3})$$\n$$\\log_{10}(n) \\leq 128.5 \\cdot \\log_{10}(2) - 3$$\n使用值 $\\log_{10}(2) \\approx 0.30102999566$：\n$$\\log_{10}(n) \\leq 128.5 \\cdot (0.30102999566) - 3$$\n$$\\log_{10}(n) \\leq 38.682354442 - 3$$\n$$\\log_{10}(n) \\leq 35.682354442$$\n为了求出 $n$，我们计算10的这个幂：\n$$n \\leq 10^{35.682354442} = 10^{0.682354442} \\cdot 10^{35}$$\n$$n \\leq 4.812328 \\times 10^{35}$$\n问题要求的是最大值 $n$。由于 $n$ 必须是整数，最大值为 $\\lfloor 4.812328 \\times 10^{35} \\rfloor$。根据指令，我们需要将最终数值答案四舍五入到四位有效数字。这得到：\n$$n_{max} \\approx 4.812 \\times 10^{35}$$\n我们必须验证这个 $n$ 值是否与推导所使用的 $n \\ll 2^{b/2}$ 范围一致。\n这里，$b=256$，所以 $2^{b/2} = 2^{128}$。\n$$2^{128} = 10^{\\log_{10}(2^{128})} = 10^{128 \\cdot \\log_{10}(2)} \\approx 10^{128 \\cdot 0.30103} \\approx 10^{38.53184} \\approx 3.403 \\times 10^{38}$$\n我们计算出的值 $n \\approx 4.812 \\times 10^{35}$ 确实远小于 $2^{128} \\approx 3.403 \\times 10^{38}$。比率是 $\\frac{n}{2^{128}} \\approx \\frac{4.812 \\times 10^{35}}{3.403 \\times 10^{38}} \\approx 1.4 \\times 10^{-3}$，这是一个很小的数。因此，使用渐近表达式是合理的。\n在保持碰撞概率低于 $10^{-6}$ 的情况下，可以锚定的最大记录数 $n$ 约为 $4.812 \\times 10^{35}$。",
            "answer": "$$\\boxed{4.812 \\times 10^{35}}$$"
        },
        {
            "introduction": "将每个事件的哈希值都记录在链上成本高昂且效率低下。默克尔树 (Merkle tree) 提供了一种优雅的解决方案，它允许我们用一个单一的哈希根 (Merkle root) 来锚定整个数据集，同时又能高效地验证任何单个事件的归属性。本练习  将带您深入实践层面，通过计算成员资格证明的大小和验证时间，您将理解在资源受限的客户端上进行数据溯源和审计所涉及的实际性能开销。",
            "id": "4207069",
            "problem": "生产环境中的一个信息物理系统（CPS）的数字孪生（Digital Twin）记录了一个包含 $10^{5}$ 个顺序事件的监管链。每个事件作为一个叶子节点被提交到一个仅追加的默克尔累加器（Merkle accumulator）中，该累加器采用二叉树结构构建，其中每个内部节点存储其两个子节点哈希值串联后的加密哈希值。默克尔根（Merkle root）被定期锚定在区块链上。一个计算资源有限的客户端验证单个事件的成员资格证明（membership proof），以确保数据的完整性和可追溯性。\n\n假设如下：\n- 加密哈希函数为安全哈希算法256（Secure Hash Algorithm 256, SHA-256），其输出长度为 $h=256$ 位，并接受可变长度的输入。\n- 累加器表示为一个完整的二叉默克尔树，其叶子节点对应于事件；当叶子节点数不是2的幂时，对树进行必要的填充，以使从任一叶子节点到根的路径长度等于 $\\lceil \\log_{2}(n) \\rceil$，其中 $n$ 是叶子节点的数量。\n- 一个叶子节点的成员资格证明包括沿其到根路径上的一系列兄弟节点的哈希值，以及每层一个用于指示该兄弟节点在左侧还是右侧的方向位。除这些组件外，证明中不包含额外的元数据或签名。\n- 客户端设备处理哈希的持续数据吞吐量为 $r=5 \\times 10^{6}$ 字节/秒，并且每次哈希调用会产生一个固定的开销 $t_{0}=4 \\times 10^{-4}$ 秒，该开销与输入长度无关。在验证的每一层，父节点的哈希值是通过计算当前节点哈希与其兄弟节点哈希的串联值得到的，因此每层的输入长度为 $2 \\times (h/8)$ 字节。\n\n任务：\n1. 计算单个事件的审计证明大小，以kibibyte（KiB）为单位，其中 $1$ Kibibyte $=1024$ 字节。计算中需包括方向位的开销，这些开销以字节形式打包（假设方向位被紧密打包，对于长度为 $L$ 层的路径，消耗 $\\lceil L/8 \\rceil$ 字节）。\n2. 计算客户端端到端验证单个成员资格证明所需的总验证时间（以秒为单位），计算中需考虑每次哈希的固定开销和每层的数据处理时间。\n\n将两个数值答案四舍五入至四位有效数字。以 $[$证明大小（KiB）$, $验证时间（秒）$]$ 的顺序，将最终答案表示为一个包含两个元素的行矩阵。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- 顺序事件数量（默克尔树中的叶子节点数）：$n = 10^{5}$\n- 哈希函数：SHA-256\n- 哈希输出长度：$h = 256$ 位\n- 默克尔树结构：一个完整的二叉树，经过填充以使从任一叶子节点到根的路径长度为 $L = \\lceil \\log_{2}(n) \\rceil$。\n- 成员资格证明内容：一系列兄弟节点的哈希值以及每层一个方向位。\n- 客户端哈希计算吞吐量：$r = 5 \\times 10^{6}$ 字节/秒\n- 每次哈希调用的固定开销：$t_{0} = 4 \\times 10^{-4}$ 秒\n- 验证期间每次哈希计算的输入长度：$2 \\times (h/8)$ 字节\n- 证明大小的目标单位：kibibyte (KiB)，其中 $1 \\text{ KiB} = 1024$ 字节\n- 验证时间的目标单位：秒\n- 精度要求：将最终数值答案四舍五入至四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n对问题的有效性进行评估。\n\n- **科学基础**：该问题基于计算机科学和密码学中公认的原理。默克尔累加器、SHA-256以及成员资格证明的概念是确保数据完整性的标准工具，尤其是在区块链和分布式账本技术中。其性能模型将固定的调用开销与依赖于数据吞吐量的成本分开，是性能分析中一种常见且合理的简化方法。\n- **适定性**：该问题是适定的。它提供了所有必要的参数（$n$、$h$、$r$、$t_0$）和一组明确的任务（计算证明大小和验证时间）。关于树结构和证明组成的定义清晰明确，可以导出一个唯一的解。\n- **客观性**：问题以客观、技术性的语言陈述，不含主观或推测性论断。\n- **完整性与一致性**：所提供的数据是自洽且一致的。使用 $L = \\lceil \\log_{2}(n) \\rceil$ 正确地处理了叶子节点数不为2的幂的树的路径长度问题。验证过程的描述与标准的默克尔证明验证一致。\n- **现实性**：参数是现实的。一个包含 $10^{5}$ 个事件的系统是常见的规模。一个哈希吞吐量为 $5$ MB/s、每次调用开销为 $0.4$ ms 的客户端设备对于现代嵌入式或移动硬件来说是合理的。\n\n### 第3步：结论与行动\n该问题被判定为**有效**，因为它具有科学依据、适定，且所有组成部分都一致且定义清晰。现在开始求解。\n\n### 解答\n\n解答分为两部分，对应于所要求的两项任务。\n\n**第1部分：审计证明大小计算**\n\n首先，我们确定默克尔树的层数，这决定了成员资格证明中组件的数量。对于一个有 $n$ 个叶子节点的树，从任一叶子节点到根的路径长度 $L$ 由下式给出：\n$$L = \\lceil \\log_{2}(n) \\rceil$$\n代入给定值 $n = 10^{5}$：\n$$L = \\lceil \\log_{2}(10^{5}) \\rceil = \\lceil 5 \\log_{2}(10) \\rceil$$\n使用对数的换底公式，$\\log_{2}(10) = \\frac{\\ln(10)}{\\ln(2)} \\approx \\frac{2.302585}{0.693147} \\approx 3.321928$。\n$$L = \\lceil 5 \\times 3.321928 \\rceil = \\lceil 16.60964 \\rceil = 17$$\n单个事件的成员资格证明必须包含从叶子节点到根的树的 $L=17$ 个层级中每一层的一个兄弟节点哈希。\n\n证明的大小 $S$ 是这些兄弟节点哈希的大小与方向位大小之和。\n\n单个哈希输出的大小为 $h = 256$ 位。以字节为单位，即：\n$$S_{hash} = \\frac{h}{8} = \\frac{256}{8} = 32 \\text{ 字节}$$\n证明中 $L$ 个兄弟节点哈希的总大小为：\n$$S_{hashes} = L \\times S_{hash} = 17 \\times 32 = 544 \\text{ 字节}$$\n\n证明还包括 $L = 17$ 个方向位。问题陈述这些位是紧密打包并存储在 $\\lceil L/8 \\rceil$ 字节中的。\n$$S_{bits} = \\lceil \\frac{L}{8} \\rceil = \\lceil \\frac{17}{8} \\rceil = \\lceil 2.125 \\rceil = 3 \\text{ 字节}$$\n\n证明的总大小（以字节为单位）是哈希数据和方向位数据之和：\n$$S_{total} = S_{hashes} + S_{bits} = 544 + 3 = 547 \\text{ 字节}$$\n\n为了将其转换为kibibyte (KiB)，我们使用换算因子 $1 \\text{ KiB} = 1024$ 字节。\n$$S_{\\text{KiB}} = \\frac{S_{total}}{1024} = \\frac{547}{1024} \\approx 0.5341796875 \\text{ KiB}$$\n四舍五入到四位有效数字，证明大小为 $0.5342$ KiB。\n\n**第2部分：验证时间计算**\n\n总验证时间 $T_{total}$ 是总固定开销时间 $T_{overhead}$ 和总数据处理时间 $T_{proc}$ 之和。\n$$T_{total} = T_{overhead} + T_{proc}$$\n验证要求客户端在每一层执行一次哈希计算，以将当前节点的哈希与其兄弟节点的哈希结合起来，然后向树的上方移动。由于有 $L=17$ 层，因此需要进行17次哈希计算。\n\n总固定开销是哈希调用次数乘以每次哈希的开销 $t_{0}$。\n$$T_{overhead} = L \\times t_{0} = 17 \\times (4 \\times 10^{-4} \\text{ s}) = 68 \\times 10^{-4} \\text{ s} = 0.0068 \\text{ s}$$\n\n数据处理时间取决于哈希函数必须处理的数据总量。在 $L=17$ 个层级的每一层，哈希函数的输入是两个哈希值的串联。这个输入的大小 $D_{input}$ 为：\n$$D_{input} = 2 \\times S_{hash} = 2 \\times 32 = 64 \\text{ 字节}$$\n所有 $L$ 层处理的总数据量 $D_{total}$ 为：\n$$D_{total} = L \\times D_{input} = 17 \\times 64 = 1088 \\text{ 字节}$$\n总数据处理时间是这个总数据大小除以客户端的处理吞吐量 $r$。\n$$T_{proc} = \\frac{D_{total}}{r} = \\frac{1088 \\text{ 字节}}{5 \\times 10^{6} \\text{ 字节/秒}} = 217.6 \\times 10^{-6} \\text{ s} = 0.0002176 \\text{ s}$$\n\n最后，总验证时间为：\n$$T_{total} = T_{overhead} + T_{proc} = 0.0068 \\text{ s} + 0.0002176 \\text{ s} = 0.0070176 \\text{ s}$$\n四舍五入到四位有效数字，验证时间为 $0.007018$ 秒。\n\n最终答案是证明大小（以KiB为单位）和验证时间（以秒为单位），表示为一个包含两个元素的行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.5342   0.007018\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "虽然默克尔证明对于验证单个事件是高效的，但在需要批量审计大量事件的场景下，其累积成本可能变得过高。本练习将向您介绍一种更前沿的密码学工具——简洁的非交互式知识论证 (Succinct Non-interactive Argument of Knowledge, SNARK)，它能为海量计算生成一个极小且验证极快的证明。通过直接比较传统默克尔证明与 SNARK 在验证成本上的差异，您将计算出后者的优势拐点，从而理解在设计大规模可追溯系统时，选择高级密码学方案的性能和经济驱动因素。",
            "id": "4207087",
            "problem": "一个信息物理系统（CPS）的数字孪生在每个时期（epoch）维护一个包含 $N$ 个事件的审计追踪。在每个时期结束时，系统会将一个基于 $N$ 个叶节点摘要、使用抗碰撞哈希函数 $H$ 构建的平衡 $b$ 元 Merkle 树的根发布到区块链上，从而为该时期审计数据的完整性和可追溯性做出承诺。\n\n一个验证者需要根据链上的 Merkle 根，检查给定时期中 $k$ 个特定事件的包含情况。有两种验证策略可供选择：\n\n1) 传统包含证明：对于每个事件，验证者重新计算直至已发布根的认证路径。根据平衡 $b$ 元 Merkle 树的定义，路径长度为 $L = \\lceil \\log_{b}(N) \\rceil$，因此每次事件验证需要 $L$ 次 $H$ 函数的应用。\n\n2) 通过简洁的非交互式知识论证（SNARK）进行简洁压缩：单个 SNARK 证明可证实这 $k$ 个事件相对于已发布的根被正确包含。验证该证明需要固定数量的密码学操作，这些操作不依赖于 $k$ 或 $N$：$p$ 次双线性配对评估，$q$ 次群指数运算，以及为处理公共输入而进行的 $r$ 次 $H$ 函数调用。\n\n假设独立操作的成本是可加的，并使用以下参数：\n- $N = 2^{20}$ 且 $b = 2$，\n- 一次哈希函数 $H$ 的调用耗时 $t_{h} = 1.2 \\times 10^{-7}\\ \\text{s}$，\n- 一次双线性配对耗时 $t_{\\text{pair}} = 2.6 \\times 10^{-3}\\ \\text{s}$，\n- 一次群指数运算耗时 $t_{\\exp} = 4.0 \\times 10^{-4}\\ \\text{s}$，\n- SNARK 验证器执行 $p = 3$ 次配对，$q = 6$ 次指数运算，以及 $r = 2$ 次哈希调用。\n\n从上述基本定义（平衡树中的 Merkle 路径长度、用于重新计算认证路径的抗碰撞哈希、SNARK 的固定操作验证以及独立操作成本的可加性）出发，推导两种策略总时间的符号表达式：验证 $k$ 个传统包含证明的 $T_{M}(k,N)$，以及验证一个覆盖 $k$ 个包含关系的简洁证明的 $T_{S}$。然后计算最小整数 $k^{\\star}$，使得 $T_{S} \\leq T_{M}(k^{\\star},N)$。将您的最终答案表示为不带单位的整数 $k^{\\star}$。由于结果是精确整数，无需按有效数字进行四舍五入。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、定义明确且客观的。它提供了一套自洽且一致的定义和参数，用于比较两种密码学验证策略。我们可以着手进行形式化求解。\n\n目标是找到事件的最小整数数量 $k^{\\star}$，使得使用简洁的非交互式知识论证（SNARK）的总验证时间小于或等于验证 $k^{\\star}$ 个独立 Merkle 树包含证明的总时间。\n\n首先，我们推导传统 Merkle 证明验证策略所需总时间的符号表达式，记为 $T_{M}(k, N, b)$。问题陈述指出，验证单个事件的包含需要重新计算认证路径。对于一个有 $N$ 个叶节点的平衡 $b$ 元 Merkle 树，此路径的长度 $L$ 由下式给出：\n$$L = \\lceil \\log_{b}(N) \\rceil$$\n验证这样一条路径的成本定义为 $L$ 次哈希函数 $H$ 的应用。单次哈希调用的时间为 $t_{h}$。因此，验证一个事件的时间是 $L \\times t_{h}$。\n假设验证 $k$ 个事件涉及 $k$ 次独立的证明验证，总时间是可加的。因此，验证 $k$ 个事件的总时间为：\n$$T_{M}(k, N, b) = k \\times L \\times t_{h} = k \\times \\lceil \\log_{b}(N) \\rceil \\times t_{h}$$\n\n接下来，我们推导 SNARK 验证策略所需时间的符号表达式 $T_{S}$。问题陈述指出，验证一个覆盖所有 $k$ 个事件的 SNARK 证明，需要固定数量的操作，且该数量与 $k$ 和 $N$ 无关。这些操作是 $p$ 次双线性配对、$q$ 次群指数运算和 $r$ 次哈希调用。这些单个操作的时间分别为 $t_{\\text{pair}}$、$t_{\\exp}$ 和 $t_{h}$。假设成本是可加的，SNARK 验证的总时间为：\n$$T_{S} = p \\times t_{\\text{pair}} + q \\times t_{\\exp} + r \\times t_{h}$$\n\n我们正在寻找最小整数 $k^{\\star}$，使得 SNARK 策略的效率至少与传统策略相当。这个条件由不等式表示：\n$$T_{S} \\leq T_{M}(k^{\\star}, N, b)$$\n代入 $T_{S}$ 和 $T_{M}$ 的推导表达式：\n$$p \\times t_{\\text{pair}} + q \\times t_{\\exp} + r \\times t_{h} \\leq k^{\\star} \\times \\lceil \\log_{b}(N) \\rceil \\times t_{h}$$\n为了找到最小整数 $k^{\\star}$，我们求解 $k^{\\star}$：\n$$k^{\\star} \\geq \\frac{p \\times t_{\\text{pair}} + q \\times t_{\\exp} + r \\times t_{h}}{\\lceil \\log_{b}(N) \\rceil \\times t_{h}}$$\n由于 $k^{\\star}$ 必须是整数，满足此不等式的最小值是右侧表达式的向上取整：\n$$k^{\\star} = \\left\\lceil \\frac{p \\times t_{\\text{pair}} + q \\times t_{\\exp} + r \\times t_{h}}{\\lceil \\log_{b}(N) \\rceil \\times t_{h}} \\right\\rceil$$\n\n现在，我们将给定的数值参数代入此表达式：\n- $N = 2^{20}$\n- $b = 2$\n- $p = 3$\n- $q = 6$\n- $r = 2$\n- $t_{h} = 1.2 \\times 10^{-7}\\ \\text{s}$\n- $t_{\\text{pair}} = 2.6 \\times 10^{-3}\\ \\text{s}$\n- $t_{\\exp} = 4.0 \\times 10^{-4}\\ \\text{s}$\n\n首先，我们计算 Merkle 路径长度 $L$：\n$$L = \\lceil \\log_{b}(N) \\rceil = \\lceil \\log_{2}(2^{20}) \\rceil = \\lceil 20 \\rceil = 20$$\n接下来，我们计算分子，即 SNARK 验证的总时间 $T_S$：\n$$T_{S} = (3 \\times 2.6 \\times 10^{-3}) + (6 \\times 4.0 \\times 10^{-4}) + (2 \\times 1.2 \\times 10^{-7})$$\n$$T_{S} = (7.8 \\times 10^{-3}) + (24.0 \\times 10^{-4}) + (2.4 \\times 10^{-7})$$\n$$T_{S} = (7.8 \\times 10^{-3}) + (2.4 \\times 10^{-3}) + (0.00024 \\times 10^{-3})$$\n$$T_{S} = 10.2 \\times 10^{-3} + 0.00024 \\times 10^{-3} = 1.02 \\times 10^{-2} + 2.4 \\times 10^{-7} = 0.0102 + 0.00000024 = 0.01020024\\ \\text{s}$$\n现在，我们计算分母，即验证一个传统 Merkle 证明的时间：\n$$L \\times t_{h} = 20 \\times (1.2 \\times 10^{-7}) = 24 \\times 10^{-7} = 2.4 \\times 10^{-6}\\ \\text{s}$$\n最后，我们计算比率并向上取整以求得 $k^{\\star}$：\n$$k^{\\star} = \\left\\lceil \\frac{0.01020024}{2.4 \\times 10^{-6}} \\right\\rceil = \\left\\lceil \\frac{0.01020024}{0.0000024} \\right\\rceil$$\n$$k^{\\star} = \\lceil 4250.1 \\rceil$$\n大于或等于 $4250.1$ 的最小整数是 $4251$。\n因此，使得基于 SNARK 的验证更具时间效益的最小事件数为 $k^{\\star} = 4251$。",
            "answer": "$$\\boxed{4251}$$"
        }
    ]
}