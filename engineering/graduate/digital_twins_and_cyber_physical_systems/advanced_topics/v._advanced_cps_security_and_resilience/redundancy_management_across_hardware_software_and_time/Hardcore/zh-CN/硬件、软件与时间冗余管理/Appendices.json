{
    "hands_on_practices": [
        {
            "introduction": "三模冗余（TMR）是构建高可靠性系统的基石，它通过复制计算模块并对结果进行多数表决来屏蔽单个组件的故障。这个练习将引导你分析一个经典的TMR系统，但它增加了一个关键的现实考量：表决器本身也可能失效 。通过从第一性原理推导系统可靠性，并为表决器设计冗余，你将学会如何识别和加固容错架构中的薄弱环节。",
            "id": "4239543",
            "problem": "一个信息物理系统由一个数字孪生（DT）模型监控，该模型通过协调硬件、软件和时间上的冗余，以在固定的任务周期内维持正确的致动指令。该系统采用三模冗余（TMR），其定义为三个相同的计算模块并行执行，然后由一个多数表决器将三个模块的输出映射为单个指令。可靠性被量化为组件或架构阶段在任务周期内正常运行的概率。假设所有组件之间以及时间上分离的操作之间都是独立的。\n\n每个计算模块在软件上使用时间冗余：单次计算尝试的成功概率为 $p_{s}$，软件在任务周期内重复计算 $k$ 次，只要有一次尝试成功，就接受该结果。模块级可靠性 $R$ 源于此时间冗余，并且必须在假设 $k$ 次尝试相互独立的前提下，从基本原理推导得出。\n\n在基准架构中，使用一个可靠性为 $R_{v}$ 的单多数表决器来组合三个模块的输出。当且仅当表决器正常工作且三个模块中至少有两个正常工作时，系统才能产生正确的致动指令。从基本原理推导基准系统的可靠性 $R_{\\text{baseline}}$。\n\n为减轻表决器处的单点故障，提出并分析一种冗余表决器架构：部署三个相同的表决器，对相同的三个模块输出进行操作，并通过三个表决器输出的多数（即，表决器之间的三取二多数）来接受最终指令。假设三个表决器输出的组合是通过一个共识机制实现的，其可靠性主要由表决器决定，在本计算中可以忽略不计。从基本原理推导改进后系统的可靠性 $R_{\\text{mitigated}}$。\n\n给定 $p_{s} = 0.88$，$k = 2$ 和 $R_{v} = 0.93$，计算可靠性提升因子 $\\eta = R_{\\text{mitigated}} / R_{\\text{baseline}}$。将您的答案四舍五入至五位有效数字，并以无量纲小数表示。",
            "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确且客观的。这是一个可靠性工程中的形式化问题，具有足够的信息以获得唯一解。\n\n求解过程分为四个阶段：\n1.  计算模块可靠性 $R$ 的推导。\n2.  基准系统可靠性 $R_{\\text{baseline}}$ 的推导。\n3.  改进后系统可靠性 $R_{\\text{mitigated}}$ 的推导。\n4.  可靠性提升因子 $\\eta$ 的计算。\n\n**1. 模块级可靠性 ($R$)**\n\n单个计算模块的可靠性由时间冗余方案确定。计算尝试 $k$ 次，只要至少有一次尝试成功，模块就正常运行。单次尝试的成功概率为 $p_s$。\n\n单次尝试的失败概率为 $1 - p_s$。\n由于所有 $k$ 次尝试都是独立的，所以所有 $k$ 次尝试都失败的概率是 $(1 - p_s)^k$。\n模块的可靠性 $R$ 是它不发生故障的概率，即所有尝试都失败的互补事件。\n$$R = 1 - (1 - p_s)^k$$\n\n**2. 基准系统可靠性 ($R_{\\text{baseline}}$)**\n\n基准架构由一个用于计算模块的三模冗余（TMR）阶段和一个随后的单多数表决器组成。如果 TMR 模块阶段提供了正确的多数输入且表决器正常工作，则系统成功。这代表了一个由两个逻辑组件组成的串联系统：模块阶段和表决器。\n\n表决器的可靠性给定为 $R_v$。\n\nTMR 模块阶段的可靠性，我们称之为 $R_{\\text{modules}}$，是三个相同模块中至少有两个正常工作的概率。正常工作的模块数量 $N$ 服从参数为 $n=3$（试验次数）和 $p=R$（每次试验的成功概率）的二项分布。其概率质量函数为 $P(N=j) = \\binom{3}{j} R^j (1-R)^{3-j}$。\n\n当 $N \\geq 2$ 时，模块阶段成功。\n$$R_{\\text{modules}} = P(N=2) + P(N=3)$$\n$$R_{\\text{modules}} = \\binom{3}{2} R^2 (1-R)^1 + \\binom{3}{3} R^3 (1-R)^0$$\n$$R_{\\text{modules}} = 3 R^2 (1-R) + 1 \\cdot R^3 \\cdot 1$$\n$$R_{\\text{modules}} = 3R^2 - 3R^3 + R^3 = 3R^2 - 2R^3$$\n\n总的基准系统可靠性是两个串联组件可靠性的乘积：\n$$R_{\\text{baseline}} = R_{\\text{modules}} \\times R_v = (3R^2 - 2R^3) R_v$$\n\n**3. 改进后系统可靠性 ($R_{\\text{mitigated}}$)**\n\n改进后的架构用一个 TMR 表决器阶段替换了单个表决器。三个相同的表决器接收来自三个模块的相同输出，它们的结果通过最终的多数规则进行组合。如果整个过程成功，则产生正确的最终指令。\n\n为了让系统产生正确的最终指令，必须满足两个相继的条件：\n1.  TMR 模块阶段必须产生正确的多数。如果少于两个模块是正确的，那么输入到表决器阶段的数据从根本上就是有缺陷的，无法生成正确的最终指令。该阶段的可靠性为 $R_{\\text{modules}} = 3R^2 - 2R^3$，如前所述。\n2.  假定模块阶段已经产生了正确的多数输入，TMR 表决器阶段必须正确处理此输入。每个表决器的可靠性为 $R_v$。如果表决器正常工作，它就能正确处理输入。如果三个表决器中至少有两个正常工作，则最终输出是正确的。\n\n因此，TMR 表决器阶段的可靠性 $R_{\\text{voters}}$ 是三个表决器中至少有两个正常工作的概率。这在结构上与模块 TMR 的计算相同，只是概率为 $R_v$ 而不是 $R$。\n$$R_{\\text{voters}} = 3R_v^2 - 2R_v^3$$\n\n改进后系统的可靠性是这两个串联阶段的乘积：\n$$R_{\\text{mitigated}} = R_{\\text{modules}} \\times R_{\\text{voters}} = (3R^2 - 2R^3)(3R_v^2 - 2R_v^3)$$\n\n**4. 可靠性提升因子 ($\\eta$)**\n\n可靠性乘性提升因子 $\\eta$ 是改进后系统可靠性与基准系统可靠性之比。\n$$\\eta = \\frac{R_{\\text{mitigated}}}{R_{\\text{baseline}}}$$\n代入上面推导出的表达式：\n$$\\eta = \\frac{(3R^2 - 2R^3)(3R_v^2 - 2R_v^3)}{(3R^2 - 2R^3)R_v}$$\n模块阶段可靠性的项 $(3R^2 - 2R^3)$ 被消去，因为它在两种架构中是共有的。这是预料之中的，因为提升完全是由于表决器架构的改变。\n$$\\eta = \\frac{3R_v^2 - 2R_v^3}{R_v}$$\n从分子中提出因子 $R_v$：\n$$\\eta = \\frac{R_v(3R_v - 2R_v^2)}{R_v} = 3R_v - 2R_v^2$$\n或者，换一种方式：\n$$\\eta = R_v(3 - 2R_v)$$\n\n现在，我们代入给定的数值 $R_v = 0.93$。请注意，计算 $\\eta$ 并不需要 $p_s$ 和 $k$ 的值。\n$$\\eta = 3(0.93) - 2(0.93)^2$$\n$$\\eta = 2.79 - 2(0.8649)$$\n$$\\eta = 2.79 - 1.7298$$\n$$\\eta = 1.0602$$\n结果 $1.0602$ 符合要求的五位有效数字。",
            "answer": "$$\\boxed{1.0602}$$"
        },
        {
            "introduction": "除了空间上的硬件复制，时间冗余是另一种强大的容错策略，它允许系统从故障中恢复，而不是仅仅屏蔽它们。本练习聚焦于检查点-回滚机制，这是时间冗余的一种典型实现 。你将从基本的泊松过程（Poisson process）假设出发，推导故障导致的期望工作损失，并最终通过最小化系统总开销率，求解出最优的检查点设置周期，深刻理解预防成本与恢复成本之间的权衡。",
            "id": "4239541",
            "problem": "一个信息物理系统 (CPS) 使用数字孪生 (DT) 来协调跨硬件、软件和时间的冗余。硬件和软件层的空间冗余将系统级有效故障过程简化为具有恒定速率 $\\lambda$（故障/秒）的平稳泊松过程。为了增加时间冗余，DT 强制执行周期性检查点：控制器状态每 $\\Delta$ 秒保存一次，每个检查点耗时 $c$ 秒，在此期间系统没有取得任何正向进展但保持安全。发生故障时，一个检查点-回滚机制会恢复最近的检查点并重新执行丢失的工作。假设恢复本身（不包括重新执行）的时间与 $\\Delta$ 相比可以忽略不计，并且 $\\lambda \\Delta$ 足够小，以至于在任何检查点间隔内发生一次以上故障的概率相对于 $\\mathcal{O}((\\lambda \\Delta)^{2})$ 项而言可以忽略不计。\n\n仅从泊松过程速率为 $\\lambda$ 的定义属性和指数分布的到达间隔时间的无记忆性出发，并且不引用任何预先推导的检查点公式，完成以下任务：\n\n- 从第一性原理出发，推导在所述假设下，每个检查点间隔的期望损失工作量 $E[L(\\Delta)]$ 作为 $\\lambda$ 和 $\\Delta$ 的函数的表达式。\n- 使用您的结果和周期性检查点成本 $c$，构建期望开销率（单位时钟时间内的损失有用时间）作为函数 $R(\\Delta)$，该函数考虑了检查点时间和因故障导致的期望重新执行时间。\n- 确定使 $R(\\Delta)$ 最小化的检查点周期 $\\Delta^{\\star}$。\n\n将你的最终答案报告为 $\\Delta^{\\star}$ 关于 $\\lambda$ 和 $c$ 的单个闭式符号表达式。将最优周期以秒为单位表示。不要代入任何数值，在最终的方框答案中不要包含任何单位。",
            "solution": "用户希望找到信息物理系统的最优检查点周期 `\\Delta^{\\star}`。这包括三个步骤：\n1. 推导每个检查点间隔的期望损失工作量 `E[L(\\Delta)]`。\n2. 构建期望开销率 `R(\\Delta)`。\n3. 确定使 `R(\\Delta)` 最小化的 `\\Delta`。\n\n### 第 1 步：期望损失工作量 `E[L(\\Delta)]` 的推导\n\n设 `L(\\Delta)` 为表示在持续时间为 `\\Delta` 的检查点间隔内因故障而损失的工作量的随机变量。在区间 `[0, \\Delta]` 内 `t_f` 时刻发生的故障会导致等于 `t_f` 的工作量损失。首次故障发生的时间 `T_f` 是一个速率为 `\\lambda` 的指数随机变量，因此其概率密度函数 (PDF) 为 `f(t) = \\lambda \\exp(-\\lambda t)` (当 `t \\ge 0`)，其累积分布函数 (CDF) 为 `F(t) = 1 - \\exp(-\\lambda t)`。\n\n问题陈述中说明我们可以忽略多于一次故障的概率。这意味着我们只需要考虑首次故障发生的时间。如果首次故障发生在时间 `t_f \\in [0, \\Delta]`，则损失的工作量为 `L = t_f`。如果在该间隔内没有发生故障 (`T_f > \\Delta`)，则损失的工作量为 `L=0`。\n\n非负随机变量 `L` 的期望值可以通过其互补累积分布函数 (CCDF) `P(L > t)` 来计算，即 `E[L] = \\int_{0}^{\\infty} P(L > t) dt`。\n对于 `t \\in [0, \\Delta]`，事件 `L > t` 发生的充要条件是首次故障 `T_f` 发生在区间 `(t, \\Delta]` 内。\n该事件的概率为：\n$$ P(L > t) = P(t  T_f \\le \\Delta) = F(\\Delta) - F(t) = (1 - \\exp(-\\lambda \\Delta)) - (1 - \\exp(-\\lambda t)) = \\exp(-\\lambda t) - \\exp(-\\lambda \\Delta) $$\n对于 `t  \\Delta`，`P(L  t) = 0`，因为可能的最大损失是 `\\Delta`。\n\n现在，我们可以计算期望损失工作量 `E[L(\\Delta)]`：\n$$ E[L(\\Delta)] = \\int_{0}^{\\Delta} P(L  t) dt = \\int_{0}^{\\Delta} (\\exp(-\\lambda t) - \\exp(-\\lambda \\Delta)) dt $$\n我们计算该积分：\n$$ E[L(\\Delta)] = \\left[ -\\frac{1}{\\lambda} \\exp(-\\lambda t) \\right]_{0}^{\\Delta} - \\int_{0}^{\\Delta} \\exp(-\\lambda \\Delta) dt $$\n$$ E[L(\\Delta)] = \\left( -\\frac{1}{\\lambda} \\exp(-\\lambda \\Delta) - \\left(-\\frac{1}{\\lambda} \\exp(0)\\right) \\right) - \\left[ t \\exp(-\\lambda \\Delta) \\right]_{0}^{\\Delta} $$\n$$ E[L(\\Delta)] = \\left( \\frac{1}{\\lambda} - \\frac{1}{\\lambda} \\exp(-\\lambda \\Delta) \\right) - \\Delta \\exp(-\\lambda \\Delta) $$\n$$ E[L(\\Delta)] = \\frac{1}{\\lambda} - \\left(\\frac{1}{\\lambda} + \\Delta\\right) \\exp(-\\lambda \\Delta) $$\n这是在仅考虑首次故障的假设下，期望损失工作量的精确表达式。\n\n问题陈述中说明 `\\lambda \\Delta` 足够小。这为对指数项 `\\exp(-\\lambda \\Delta)` 使用泰勒级数展开提供了依据。设 `x = \\lambda \\Delta`。展开式为 `\\exp(-x) \\approx 1 - x + \\frac{x^2}{2}`。\n将此代入 `E[L(\\Delta)]` 的表达式中：\n$$ E[L(\\Delta)] \\approx \\frac{1}{\\lambda} - \\left(\\frac{1}{\\lambda} + \\Delta\\right) \\left(1 - \\lambda \\Delta + \\frac{(\\lambda \\Delta)^2}{2}\\right) $$\n$$ E[L(\\Delta)] \\approx \\frac{1}{\\lambda} - \\left( \\frac{1}{\\lambda} - \\Delta + \\frac{\\lambda \\Delta^2}{2} + \\Delta - \\lambda \\Delta^2 + \\frac{\\lambda^2 \\Delta^3}{2} \\right) $$\n忽略 `\\Delta^3` 及更高阶的项：\n$$ E[L(\\Delta)] \\approx \\frac{1}{\\lambda} - \\left( \\frac{1}{\\lambda} - \\frac{\\lambda \\Delta^2}{2} \\right) = \\frac{\\lambda \\Delta^2}{2} $$\n这个一阶近似 `E[L(\\Delta)] \\approx \\frac{\\lambda \\Delta^2}{2}` 是标准的，并且与问题中关于 `\\lambda \\Delta` 很小的假设一致。\n\n### 第 2 步：开销率 `R(\\Delta)` 的构建\n\n目标是最小化“开销率”，其定义为“单位时钟时间内的损失有用时间”。\n我们来分析一个操作周期。为了取得 `\\Delta` 秒的有用进展，系统总共花费 `T_{cycle}` 的时钟时间。该时间由以下几部分组成：\n1.  有用工作的时间：`\\Delta`。\n2.  检查点的时间：`c`。\n3.  重新执行损失工作的时间，其平均值为 `E[L(\\Delta)]`。\n\n实现 `\\Delta` 秒进展的期望总时钟时间为：\n$$ E[T_{cycle}] = \\Delta + c + E[L(\\Delta)] $$\n此周期内的期望损失时间（开销）为：\n$$ E[T_{overhead}] = c + E[L(\\Delta)] $$\n开销率 `R(\\Delta)` 是期望开销时间与期望总时间的长期比率：\n$$ R(\\Delta) = \\frac{E[T_{overhead}]}{E[T_{cycle}]} = \\frac{c + E[L(\\Delta)]}{\\Delta + c + E[L(\\Delta)]} $$\n为了最小化 `R(\\Delta)`，我们可以等价地最小化一个更简单的函数。注意 `R(\\Delta) = 1 - \\frac{\\Delta}{\\Delta + c + E[L(\\Delta)]}`。最小化 `R(\\Delta)` 等价于最大化 `\\frac{\\Delta}{\\Delta + c + E[L(\\Delta)]}`，这代表了系统的吞吐量（单位时间内的有用工作）。而最大化此吞吐量又等价于最小化其倒数：\n$$ O_{eff}(\\Delta) = \\frac{\\Delta + c + E[L(\\Delta)]}{\\Delta} = 1 + \\frac{c + E[L(\\Delta)]}{\\Delta} $$\n最小化 `O_{eff}(\\Delta)` 等价于最小化 `g(\\Delta) = \\frac{c + E[L(\\Delta)]}{\\Delta}` 这一项。该项代表单位有用工作的开销时间。\n\n使用一阶近似 `E[L(\\Delta)] \\approx \\frac{\\lambda \\Delta^2}{2}`，我们得到：\n$$ g(\\Delta) = \\frac{c + \\frac{1}{2}\\lambda \\Delta^2}{\\Delta} = \\frac{c}{\\Delta} + \\frac{\\lambda \\Delta}{2} $$\n\n### 第 3 步：开销的最小化\n\n为了找到最小化开销的检查点周期 `\\Delta^{\\star}`，我们必须求函数 `g(\\Delta)` 的最小值。我们求 `g(\\Delta)` 关于 `\\Delta` 的一阶导数，并令其为零。\n$$ \\frac{d g}{d \\Delta} = \\frac{d}{d \\Delta} \\left( \\frac{c}{\\Delta} + \\frac{\\lambda \\Delta}{2} \\right) = -\\frac{c}{\\Delta^2} + \\frac{\\lambda}{2} $$\n令导数为零：\n$$ -\\frac{c}{\\Delta^2} + \\frac{\\lambda}{2} = 0 $$\n$$ \\frac{\\lambda}{2} = \\frac{c}{\\Delta^2} $$\n求解 `\\Delta^2`：\n$$ \\Delta^2 = \\frac{2c}{\\lambda} $$\n由于 `\\Delta` 必须是正的持续时间，我们取正平方根：\n$$ \\Delta^{\\star} = \\sqrt{\\frac{2c}{\\lambda}} $$\n为了确认这是一个最小值，我们检查二阶导数：\n$$ \\frac{d^2 g}{d \\Delta^2} = \\frac{d}{d \\Delta} \\left( -c \\Delta^{-2} + \\frac{\\lambda}{2} \\right) = 2c \\Delta^{-3} = \\frac{2c}{\\Delta^3} $$\n由于检查点成本 `c` 和间隔 `\\Delta` 都是正的物理量，`\\frac{2c}{\\Delta^3}` 总是正的。因此，`g(\\Delta)` 是一个凸函数，我们找到的临界点确实是一个最小值。\n\n最优检查点周期 `\\Delta^{\\star}` 是 `\\sqrt{\\frac{2c}{\\lambda}}`。",
            "answer": "$$\\boxed{\\sqrt{\\frac{2c}{\\lambda}}}$$"
        },
        {
            "introduction": "对于能够进行修复的动态系统，其长期可靠性通常用“可用性”来衡量，而马尔可夫链是分析可用性的黄金标准。这个实践任务要求你为一个带备用单元的执行器子系统构建一个连续时间马尔可夫链（CTMC）模型，该模型精细地刻画了从故障发生、检测、切换到修复的完整过程 。通过构建生成元矩阵并求解稳态概率，你将亲身体验如何将复杂的系统行为转化为可计算的数学模型，并定量评估不同冗余策略（如冷备份与温备份）和覆盖率对系统可用性的影响。",
            "id": "4239601",
            "problem": "考虑一个用于信息物理系统 (CPS) 执行器子系统的连续时间马尔可夫链 (CTMC) 模型，该子系统包含一个活动单元和一个备用单元。冗余配置可以是冷备或温备，通过闲置失效率来区分。该子系统会经历失效、检测、切换和修复过程。设该 CTMC 具有以下状态（为计算而索引），可用性定义为子系统提供驱动服务的状态：\n\n- 状态 $S_0$（索引 $0$）：两个单元均健康，主单元处于活动状态，服务可用。\n- 状态 $S_1$（索引 $1$）：活动单元健康，备用单元失效并正在修复，服务可用。\n- 状态 $S_2$（索引 $2$）：主单元已失效，备用单元健康，检测进行中，服务不可用。\n- 状态 $S_3$（索引 $3$）：备用单元切换为活动单元的过程进行中，服务不可用。\n- 状态 $S_4$（索引 $4$）：两个单元均已失效或覆盖失效发生，服务不可用。\n\n假设所有随机过程的时间均服从指数分布。定义以下参数，均为严格非负实数：\n\n- $ \\lambda_a $: 活动单元失效率（单位：$ \\mathrm{h}^{-1} $）。\n- $ \\lambda_{\\text{idle}} $: 闲置备用单元失效率（单位：$ \\mathrm{h}^{-1} $）。对于冷备，设置 $ \\lambda_{\\text{idle}} = 0 $；对于温备，使用一个正值。\n- $ \\mu $: 失效单元的修复率（单位：$ \\mathrm{h}^{-1} $）。\n- $ \\delta $: 主单元失效的检测率（单位：$ \\mathrm{h}^{-1} $）。\n- $ \\sigma $: 检测成功时的切换率（单位：$ \\mathrm{h}^{-1} $）。\n- $ c_d \\in [0,1] $: 检测覆盖率，即尝试检测时成功的概率。\n- $ c_s \\in [0,1] $: 切换覆盖率，即尝试切换时成功的概率。\n- $ \\lambda_{\\text{sw}} $: 切换过程中备用单元的失效风险率（单位：$ \\mathrm{h}^{-1} $）。\n\nCTMC 的转移由生成元矩阵 $ Q \\in \\mathbb{R}^{5 \\times 5} $ 定义，其非对角线元素由以下速率指定：\n\n- 从 $ S_0 $ 到 $ S_2 $，速率为 $ \\lambda_a $（活动单元失效，检测开始）。\n- 从 $ S_0 $ 到 $ S_1 $，速率为 $ \\lambda_{\\text{idle}} $（备用单元在闲置时失效）。\n- 从 $ S_1 $ 到 $ S_0 $，速率为 $ \\mu $（备用单元被修复）。\n- 从 $ S_1 $ 到 $ S_4 $，速率为 $ \\lambda_a $（备用单元已失效时活动单元失效）。\n- 从 $ S_2 $ 到 $ S_3 $，速率为 $ \\delta c_d $（检测成功）。\n- 从 $ S_2 $ 到 $ S_4 $，速率为 $ \\delta (1 - c_d) $（检测覆盖失效）。\n- 从 $ S_2 $ 到 $ S_4 $，速率为 $ \\lambda_{\\text{idle}} $（备用单元在等待检测期间失效）。\n- 从 $ S_3 $ 到 $ S_1 $，速率为 $ \\sigma c_s $（切换成功；备用单元变为活动单元，失效的主单元等待修复）。\n- 从 $ S_3 $ 到 $ S_4 $，速率为 $ \\sigma (1 - c_s) $（切换覆盖失效）。\n- 从 $ S_3 $ 到 $ S_4 $，速率为 $ \\lambda_{\\text{sw}} $（备用单元在切换期间失效）。\n- 从 $ S_4 $ 到 $ S_1 $，速率为 $ 2\\mu $（两个失效单元中的第一个被修复，恢复一个可提供服务的健康单元）。\n\n$ Q $ 的对角线元素定义为 $ Q_{ii} = -\\sum_{j \\neq i} Q_{ij} $，以确保每行之和为零。\n\n系统的稳态可用性 $ A $ 是 CTMC 处于提供服务状态的平稳概率，即\n$$\nA = \\pi_0 + \\pi_1,\n$$\n其中 $ \\pi \\in \\mathbb{R}^5 $ 满足 $ \\pi Q = 0 $ 和 $ \\sum_{i=0}^{4} \\pi_i = 1 $。\n\n任务：根据参数构建 $ Q $，计算平稳分布 $ \\pi $，并为每个测试用例输出稳态可用性 $ A $。所有速率的单位均为每小时（$ \\mathrm{h}^{-1} $）。可用性必须以十进制数（无量纲）形式输出，并四舍五入到六位小数。\n\n测试套件（每个测试用例是一个元组 $ (\\lambda_a, \\lambda_{\\text{idle}}, \\mu, \\delta, \\sigma, c_d, c_s, \\lambda_{\\text{sw}}) $）：\n\n1. 温备，高覆盖率，中等修复率：\n   - $ \\lambda_a = 1 \\times 10^{-4} $, $ \\lambda_{\\text{idle}} = 5 \\times 10^{-5} $, $ \\mu = 5 \\times 10^{-2} $, $ \\delta = 1.0 $, $ \\sigma = 2.0 $, $ c_d = 0.99 $, $ c_s = 0.98 $, $ \\lambda_{\\text{sw}} = 2 \\times 10^{-4} $。\n2. 冷备，完美覆盖率，快速修复：\n   - $ \\lambda_a = 5 \\times 10^{-5} $, $ \\lambda_{\\text{idle}} = 0.0 $, $ \\mu = 1.0 $, $ \\delta = 10.0 $, $ \\sigma = 20.0 $, $ c_d = 1.0 $, $ c_s = 1.0 $, $ \\lambda_{\\text{sw}} = 5 \\times 10^{-5} $。\n3. 温备，低覆盖率，慢修复率：\n   - $ \\lambda_a = 2 \\times 10^{-4} $, $ \\lambda_{\\text{idle}} = 1 \\times 10^{-4} $, $ \\mu = 1 \\times 10^{-3} $, $ \\delta = 0.2 $, $ \\sigma = 0.1 $, $ c_d = 0.7 $, $ c_s = 0.6 $, $ \\lambda_{\\text{sw}} = 2 \\times 10^{-4} $。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”），其中每个结果是对应测试用例的可用性 $ A $，四舍五入到六位小数。程序必须是自包含的，不得读取任何输入，并且必须使用上面提供的测试套件。",
            "solution": "该问题要求计算一个信息物理系统执行器子系统的稳态可用性，该子系统被建模为连续时间马尔可夫链 (CTMC)。解决方案涉及构建 CTMC 的生成元矩阵 $Q$，求解平稳概率分布 $\\pi$，然后将系统处于运行状态的概率相加。\n\n首先，我们根据所提供的规范来形式化 CTMC 模型。该系统由五个状态描述，索引从 $0$ 到 $4$：$S_0$（完全运行），$S_1$（备用单元在修复中但系统仍运行），$S_2$（主单元失效，检测进行中），$S_3$（切换进行中）和 $S_4$（系统失效）。\n\nCTMC 的动态由生成元矩阵 $Q \\in \\mathbb{R}^{5 \\times 5}$ 控制。非对角线元素 $Q_{ij}$（对于 $i \\neq j$）表示从状态 $S_i$ 到状态 $S_j$ 的转移速率。根据问题描述，这些速率是：\n- $Q_{0,1} = \\lambda_{\\text{idle}}$\n- $Q_{0,2} = \\lambda_a$\n- $Q_{1,0} = \\mu$\n- $Q_{1,4} = \\lambda_a$\n- $Q_{2,3} = \\delta c_d$\n- $Q_{2,4} = \\delta (1-c_d) + \\lambda_{\\text{idle}}$（两个并行转移的速率之和）\n- $Q_{3,1} = \\sigma c_s$\n- $Q_{3,4} = \\sigma (1-c_s) + \\lambda_{\\text{sw}}$（两个并行转移的速率之和）\n- $Q_{4,1} = 2\\mu$\n\n所有其他非对角线元素均为 $0$。对角线元素 $Q_{ii}$ 的定义使得每行之和为零，这是生成元矩阵的一个基本属性。因此，$Q_{ii} = -\\sum_{j \\neq i} Q_{ij}$。由此得出：\n- $Q_{0,0} = -(\\lambda_a + \\lambda_{\\text{idle}})$\n- $Q_{1,1} = -(\\mu + \\lambda_a)$\n- $Q_{2,2} = -(\\delta c_d + \\delta(1-c_d) + \\lambda_{\\text{idle}}) = -(\\delta + \\lambda_{\\text{idle}})$\n- $Q_{3,3} = -(\\sigma c_s + \\sigma(1-c_s) + \\lambda_{\\text{sw}}) = -(\\sigma + \\lambda_{\\text{sw}})$\n- $Q_{4,4} = -2\\mu$\n\n综上所述，生成元矩阵 $Q$ 为：\n$$\nQ = \\begin{pmatrix}\n-(\\lambda_a + \\lambda_{\\text{idle}})  \\lambda_{\\text{idle}}  \\lambda_a  0  0 \\\\\n\\mu  -(\\mu + \\lambda_a)  0  0  \\lambda_a \\\\\n0  0  -(\\delta + \\lambda_{\\text{idle}})  \\delta c_d  \\delta(1-c_d) + \\lambda_{\\text{idle}} \\\\\n0  \\sigma c_s  0  -(\\sigma + \\lambda_{\\text{sw}})  \\sigma(1-c_s) + \\lambda_{\\text{sw}} \\\\\n0  2\\mu  0  0  -2\\mu\n\\end{pmatrix}\n$$\n\n稳态或平稳概率分布是一个行向量 $\\pi = [\\pi_0, \\pi_1, \\pi_2, \\pi_3, \\pi_4]$，它满足两个条件：\n1. 全局平衡方程：$\\pi Q = 0$。\n2. 归一化约束：$\\sum_{i=0}^{4} \\pi_i = 1$。\n\n系统 $\\pi Q = 0$ 是一个齐次线性方程组。由于由 $\\pi$ 加权的 $Q$ 的列之和为零向量，且 $Q$ 的行之和为零，因此其中一个方程是多余的。为了找到 $\\pi$ 的唯一解，我们必须引入归一化约束。一种标准的数值方法是求解等价的转置系统 $Q^T \\pi^T = 0^T$ 以及归一化约束。\n\n我们可以构建一个新的线性方程组 $M\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x} = \\pi^T$。矩阵 $M$ 是通过取生成元矩阵的转置 $Q^T$，并将其中的一行（例如，最后一行）替换为全为 1 的行来形成的，该行代表归一化方程。向量 $\\mathbf{b}$ 是一个列向量，其元素均为零，但在对应的最后一个位置为 1。\n$$\nM = \\begin{pmatrix}\nQ_{00}  Q_{10}  Q_{20}  Q_{30}  Q_{40} \\\\\nQ_{01}  Q_{11}  Q_{21}  Q_{31}  Q_{41} \\\\\nQ_{02}  Q_{12}  Q_{22}  Q_{32}  Q_{42} \\\\\nQ_{03}  Q_{13}  Q_{23}  Q_{33}  Q_{43} \\\\\n1  1  1  1  1\n\\end{pmatrix}, \\quad \\mathbf{x} = \\begin{pmatrix} \\pi_0 \\\\ \\pi_1 \\\\ \\pi_2 \\\\ \\pi_3 \\\\ \\pi_4 \\end{pmatrix}, \\quad \\mathbf{b} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\n这个非齐次系统 $M\\mathbf{x} = \\mathbf{b}$ 对于 $\\mathbf{x} = \\pi^T$ 有一个唯一的解，可以使用数值线性代数求解器高效地找到。\n\n一旦计算出平稳概率 $\\pi_0, \\dots, \\pi_4$，就可以计算稳态可用性 $A$。可用性定义为系统处于提供服务状态的概率。根据问题描述，这些状态是 $S_0$ 和 $S_1$。\n$$\nA = \\pi_0 + \\pi_1\n$$\n\n该算法对每个测试用例按以下步骤进行：\n1. 分配给定的参数值：$\\lambda_a, \\lambda_{\\text{idle}}, \\mu, \\delta, \\sigma, c_d, c_s, \\lambda_{\\text{sw}}$。\n2. 构建 $5 \\times 5$ 的数值生成元矩阵 $Q$。\n3. 通过转置 $Q$ 并将其最后一行替换为 1 来形成矩阵 $M$。\n4. 形成向量 $\\mathbf{b} = [0, 0, 0, 0, 1]^T$。\n5. 求解线性系统 $M\\pi^T = \\mathbf{b}$ 以找到平稳概率 $\\pi$。\n6. 计算可用性 $A = \\pi_0 + \\pi_1$。\n7. 按要求将结果四舍五入到六位小数。\n\n此过程将应用于问题陈述中提供的三个测试套件中的每一个。最终输出是计算出的可用性值的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state availability of a CTMC model for a CPS actuator.\n    \"\"\"\n    # Test Suite (lambda_a, lambda_idle, mu, delta, sigma, c_d, c_s, lambda_sw)\n    test_cases = [\n        # 1. Warm spare, high coverage, moderate repair\n        (1e-4, 5e-5, 5e-2, 1.0, 2.0, 0.99, 0.98, 2e-4),\n        # 2. Cold spare, perfect coverage, fast repair\n        (5e-5, 0.0, 1.0, 10.0, 20.0, 1.0, 1.0, 5e-5),\n        # 3. Warm spare, poor coverage, slow repair\n        (2e-4, 1e-4, 1e-3, 0.2, 0.1, 0.7, 0.6, 2e-4),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambda_a, lambda_idle, mu, delta, sigma, c_d, c_s, lambda_sw = case\n\n        # Initialize the 5x5 generator matrix Q with zeros\n        Q = np.zeros((5, 5))\n\n        # Populate the off-diagonal elements of Q based on transition rates\n        # from state i to state j is Q[i, j]\n        \n        # From S0 (index 0)\n        Q[0, 1] = lambda_idle  # S0 -> S1 (spare fails)\n        Q[0, 2] = lambda_a     # S0 -> S2 (active fails)\n\n        # From S1 (index 1)\n        Q[1, 0] = mu           # S1 -> S0 (spare repaired)\n        Q[1, 4] = lambda_a     # S1 -> S4 (active fails)\n\n        # From S2 (index 2)\n        Q[2, 3] = delta * c_d                          # S2 -> S3 (detection succeeds)\n        Q[2, 4] = delta * (1 - c_d) + lambda_idle      # S2 -> S4 (detection fail or spare fail)\n\n        # From S3 (index 3)\n        Q[3, 1] = sigma * c_s                          # S3 -> S1 (switchover succeeds)\n        Q[3, 4] = sigma * (1 - c_s) + lambda_sw        # S3 -> S4 (switchover fail or spare fail)\n\n        # From S4 (index 4)\n        Q[4, 1] = 2 * mu       # S4 -> S1 (one unit repaired)\n\n        # Populate the diagonal elements of Q\n        for i in range(5):\n            Q[i, i] = -np.sum(Q[i, :])\n\n        # To find the stationary distribution pi, solve the system pi * Q = 0,\n        # which is equivalent to Q.T * pi.T = 0, subject to sum(pi) = 1.\n        # We replace one equation with the normalization constraint.\n        A_sys = Q.T\n        A_sys[-1, :] = 1.0  # Replace last row with all 1s for normalization\n\n        # Create the target vector b\n        b_sys = np.zeros(5)\n        b_sys[-1] = 1.0\n\n        # Solve the linear system A_sys * pi = b_sys for pi\n        try:\n            pi = np.linalg.solve(A_sys, b_sys)\n        except np.linalg.LinAlgError:\n            # Handle cases where the matrix may be singular, if necessary.\n            # For a well-defined irreducible CTMC, this should not happen.\n            pi = np.array([0.0, 0.0, 0.0, 0.0, 0.0]) # Failsafe\n\n        # Availability is the sum of probabilities of being in operational states S0 and S1\n        availability = pi[0] + pi[1]\n        \n        # Round to six decimal places and append to results\n        results.append(round(availability, 6))\n\n    # Format the final output string as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}