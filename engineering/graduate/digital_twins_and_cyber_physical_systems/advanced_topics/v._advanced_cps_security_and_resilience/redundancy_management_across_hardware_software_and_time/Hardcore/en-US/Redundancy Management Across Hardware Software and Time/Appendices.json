{
    "hands_on_practices": [
        {
            "introduction": "Triple Modular Redundancy (TMR) is a cornerstone of fault-tolerant design, using three identical modules and a majority voter to mask the failure of a single module. This exercise challenges you to quantify the reliability of a TMR system that also incorporates a time-redundancy element within each module, and then to evaluate a critical design enhancement by making the voter itself redundant . By comparing the two architectures, you will develop a practical understanding of how to analyze and mitigate single points of failure in a system.",
            "id": "4239543",
            "problem": "A cyber-physical system is supervised by a Digital Twin (DT) model that orchestrates redundancy across hardware, software, and time to maintain correct actuation commands during a fixed mission interval. The system employs Triple Modular Redundancy (TMR), defined as three identical compute modules executing in parallel, followed by a majority voter that maps the three module outputs to a single command. Reliability is quantified as the probability that a component or architectural stage operates correctly over the mission interval. Assume independence across all components and across time-separated operations.\n\nEach compute module uses time redundancy in software: a single computation attempt has success probability $p_{s}$, and the software repeats the computation $k$ times within the mission interval, accepting the result if at least one attempt succeeds. The module-level reliability $R$ emerges from this time redundancy and must be derived from first principles, assuming independence of the $k$ attempts.\n\nIn the baseline architecture, a single majority voter with reliability $R_{v}$ is used to combine the three module outputs. The system produces a correct actuation command if and only if the voter functions and at least two of the three modules function. Derive the baseline system reliability $R_{\\text{baseline}}$ from first principles.\n\nTo mitigate the single point-of-failure at the voter, propose and analyze a redundant-voter architecture: deploy three identical voters operating on the same three module outputs, and accept the final command by majority of the three voter outputs (that is, a two-out-of-three majority among the voters). Assume the combining of the three voter outputs is achieved by a consensus mechanism whose reliability is dominated by the voters and can be neglected for the purpose of this calculation. Derive the mitigated system reliability $R_{\\text{mitigated}}$ from first principles.\n\nGiven $p_{s} = 0.88$, $k = 2$, and $R_{v} = 0.93$, compute the multiplicative reliability improvement factor $\\eta = R_{\\text{mitigated}} / R_{\\text{baseline}}$. Round your answer to five significant figures and express it as a dimensionless decimal.",
            "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It is a formal problem in reliability engineering with sufficient information for a unique solution.\n\nThe solution proceeds in four stages:\n1.  Derivation of the compute module reliability, $R$.\n2.  Derivation of the baseline system reliability, $R_{\\text{baseline}}$.\n3.  Derivation of the mitigated system reliability, $R_{\\text{mitigated}}$.\n4.  Calculation of the reliability improvement factor, $\\eta$.\n\n**1. Module-Level Reliability ($R$)**\n\nThe reliability of a single compute module is determined by a time redundancy scheme. A computation is attempted $k$ times, and the module operates correctly if at least one attempt succeeds. The probability of success for a single attempt is $p_s$.\n\nThe probability of failure for a single attempt is $1 - p_s$.\nSince all $k$ attempts are independent, the probability that all $k$ attempts fail is $(1 - p_s)^k$.\nThe module's reliability, $R$, is the probability that it does not fail, which is the complement of all attempts failing.\n$$R = 1 - (1 - p_s)^k$$\n\n**2. Baseline System Reliability ($R_{\\text{baseline}}$)**\n\nThe baseline architecture consists of a Triple Modular Redundancy (TMR) stage for the compute modules, followed by a single majority voter. The system is successful if the TMR module stage provides a correct majority input AND the voter functions correctly. This represents a series system of two logical components: the module stage and the voter.\n\nThe reliability of the voter is given as $R_v$.\n\nThe reliability of the TMR module stage, let's call it $R_{\\text{modules}}$, is the probability that at least two of the three identical modules function correctly. The number of functioning modules, $N$, follows a binomial distribution with parameters $n=3$ (number of trials) and $p=R$ (probability of success for each trial). The probability mass function is $P(N=j) = \\binom{3}{j} R^j (1-R)^{3-j}$.\n\nThe module stage is successful if $N \\geq 2$.\n$$R_{\\text{modules}} = P(N=2) + P(N=3)$$\n$$R_{\\text{modules}} = \\binom{3}{2} R^2 (1-R)^1 + \\binom{3}{3} R^3 (1-R)^0$$\n$$R_{\\text{modules}} = 3 R^2 (1-R) + 1 \\cdot R^3 \\cdot 1$$\n$$R_{\\text{modules}} = 3R^2 - 3R^3 + R^3 = 3R^2 - 2R^3$$\n\nThe total baseline system reliability is the product of the reliabilities of the two components in series:\n$$R_{\\text{baseline}} = R_{\\text{modules}} \\times R_v = (3R^2 - 2R^3) R_v$$\n\n**3. Mitigated System Reliability ($R_{\\text{mitigated}}$)**\n\nThe mitigated architecture replaces the single voter with a TMR voter stage. Three identical voters receive the same outputs from the three modules, and their results are combined by a final majority rule. A correct final command is produced if the process as a whole succeeds.\n\nFor the system to produce a correct final command, two sequential conditions must be met:\n1.  The TMR module stage must produce a correct majority. If fewer than two modules are correct, the input to the voter stage is fundamentally flawed, and a correct final command cannot be generated. The reliability of this stage is $R_{\\text{modules}} = 3R^2 - 2R^3$, as derived previously.\n2.  Given that the module stage has produced a correct majority input, the TMR voter stage must correctly process this input. Each voter has a reliability of $R_v$. A voter correctly processes the input if it functions. The final output is correct if at least two of the three voters function correctly.\n\nThe reliability of the TMR voter stage, $R_{\\text{voters}}$, is therefore the probability that at least two out of three voters function. This is structurally identical to the module TMR calculation, but with probability $R_v$ instead of $R$.\n$$R_{\\text{voters}} = 3R_v^2 - 2R_v^3$$\n\nThe mitigated system reliability is the product of these two stages in series:\n$$R_{\\text{mitigated}} = R_{\\text{modules}} \\times R_{\\text{voters}} = (3R^2 - 2R^3)(3R_v^2 - 2R_v^3)$$\n\n**4. Reliability Improvement Factor ($\\eta$)**\n\nThe multiplicative reliability improvement factor $\\eta$ is the ratio of the mitigated system reliability to the baseline system reliability.\n$$\\eta = \\frac{R_{\\text{mitigated}}}{R_{\\text{baseline}}}$$\nSubstituting the expressions derived above:\n$$\\eta = \\frac{(3R^2 - 2R^3)(3R_v^2 - 2R_v^3)}{(3R^2 - 2R^3)R_v}$$\nThe term for the module stage reliability, $(3R^2 - 2R^3)$, cancels out, as it is common to both architectures. This is expected, as the improvement is solely due to the change in the voter architecture.\n$$\\eta = \\frac{3R_v^2 - 2R_v^3}{R_v}$$\nFactoring out $R_v$ from the numerator:\n$$\\eta = \\frac{R_v(3R_v - 2R_v^2)}{R_v} = 3R_v - 2R_v^2$$\nOr, alternatively:\n$$\\eta = R_v(3 - 2R_v)$$\n\nNow, we substitute the given numerical value $R_v = 0.93$. Note that the values for $p_s$ and $k$ are not required to calculate $\\eta$.\n$$\\eta = 3(0.93) - 2(0.93)^2$$\n$$\\eta = 2.79 - 2(0.8649)$$\n$$\\eta = 2.79 - 1.7298$$\n$$\\eta = 1.0602$$\nThe result $1.0602$ has five significant figures as requested.",
            "answer": "$$\\boxed{1.0602}$$"
        },
        {
            "introduction": "Temporal redundancy allows a system to recover from failures by re-executing lost work, with checkpoint-rollback being a primary implementation. This practice guides you through a first-principles derivation of the overhead associated with checkpointing, asking you to model the trade-off between the cost of saving state and the expected cost of re-computation after a failure . Your goal is to derive the optimal checkpoint interval, a fundamental result that provides deep insight into the management of time redundancy.",
            "id": "4239541",
            "problem": "A Cyber-Physical System (CPS) uses a Digital Twin (DT) to orchestrate redundancy across hardware, software, and time. Spatial redundancy at the hardware and software layers reduces the system-level effective failure process to a stationary Poisson process with constant rate $\\lambda$ (failures per second). To add temporal redundancy, the DT enforces periodic checkpointing: the controller state is saved every $\\Delta$ seconds, and each checkpoint takes $c$ seconds during which no forward progress is made but the system remains safe. Upon a failure, a checkpoint–rollback mechanism restores the most recent checkpoint and re-executes the lost work. Assume that recovery itself (excluding re-execution) is negligible compared to $\\Delta$, and that $\\lambda \\Delta$ is sufficiently small that the probability of more than one failure in any checkpoint interval is negligible relative to $\\mathcal{O}((\\lambda \\Delta)^2)$ terms.\n\nStarting only from the defining properties of a Poisson process with rate $\\lambda$ and the memoryless property of the exponential interarrival times, and without invoking any pre-derived checkpointing formulas, do the following:\n\n- Derive from first principles an expression for the expected lost work per checkpoint interval, $E[L(\\Delta)]$, as a function of $\\lambda$ and $\\Delta$ under the stated assumptions.\n- Using your result and the periodic checkpoint cost $c$, construct the expected overhead rate (lost useful time per unit wall-clock time) as a function $R(\\Delta)$ that accounts for both checkpointing time and expected re-execution time due to failures.\n- Determine the checkpoint period $\\Delta^{\\star}$ that minimizes $R(\\Delta)$.\n\nReport your final answer as a single closed-form symbolic expression for $\\Delta^{\\star}$ in terms of $\\lambda$ and $c$. Express the optimal period in seconds. Do not substitute any numerical values, and do not include any units in your final boxed answer.",
            "solution": "This problem requires a first-principles derivation of the optimal checkpointing period, $\\Delta^{\\star}$, for a system subject to failures following a Poisson process. The solution proceeds in three steps:\n1.  Derive the expected lost work per checkpoint interval, $E[L(\\Delta)]$.\n2.  Construct the expected overhead rate function, $R(\\Delta)$, and a related function to minimize.\n3.  Determine the $\\Delta$ that minimizes the overhead.\n\n### Step 1: Derivation of Expected Lost Work $E[L(\\Delta)]$\n\nLet $L(\\Delta)$ be the random variable representing the amount of work lost due to a failure within a checkpoint interval of duration $\\Delta$. A failure occurring at time $t_f$ within the interval $[0, \\Delta]$ results in a loss of work equal to $t_f$. The time to the first failure, $T_f$, is an exponential random variable with rate $\\lambda$, so its probability density function (PDF) is $f(t) = \\lambda \\exp(-\\lambda t)$ for $t \\ge 0$, and its cumulative distribution function (CDF) is $F(t) = 1 - \\exp(-\\lambda t)$.\n\nThe problem states that we can neglect the probability of more than one failure. This means we only need to consider the time to the first failure. If the first failure occurs at time $t_f \\in [0, \\Delta]$, the lost work is $L = t_f$. If no failure occurs in the interval ($T_f > \\Delta$), the lost work is $L=0$.\n\nThe expected value of a non-negative random variable $L$ can be calculated from its complementary cumulative distribution function (CCDF), $P(L > t)$, as $E[L] = \\int_{0}^{\\infty} P(L > t) dt$.\nFor $t \\in [0, \\Delta]$, the event $L > t$ occurs if and only if the first failure $T_f$ happens in the interval $(t, \\Delta]$.\nThe probability of this event is:\n$$ P(L > t) = P(t < T_f \\le \\Delta) = F(\\Delta) - F(t) = (1 - \\exp(-\\lambda \\Delta)) - (1 - \\exp(-\\lambda t)) = \\exp(-\\lambda t) - \\exp(-\\lambda \\Delta) $$\nFor $t > \\Delta$, $P(L > t) = 0$ since the maximum possible loss is $\\Delta$.\n\nNow, we can compute the expected lost work $E[L(\\Delta)]$:\n$$ E[L(\\Delta)] = \\int_{0}^{\\Delta} P(L > t) dt = \\int_{0}^{\\Delta} (\\exp(-\\lambda t) - \\exp(-\\lambda \\Delta)) dt $$\nWe evaluate the integral:\n$$ E[L(\\Delta)] = \\left[ -\\frac{1}{\\lambda} \\exp(-\\lambda t) \\right]_{0}^{\\Delta} - \\int_{0}^{\\Delta} \\exp(-\\lambda \\Delta) dt $$\n$$ E[L(\\Delta)] = \\left( -\\frac{1}{\\lambda} \\exp(-\\lambda \\Delta) - \\left(-\\frac{1}{\\lambda} \\exp(0)\\right) \\right) - \\left[ t \\exp(-\\lambda \\Delta) \\right]_{0}^{\\Delta} $$\n$$ E[L(\\Delta)] = \\left( \\frac{1}{\\lambda} - \\frac{1}{\\lambda} \\exp(-\\lambda \\Delta) \\right) - \\Delta \\exp(-\\lambda \\Delta) $$\n$$ E[L(\\Delta)] = \\frac{1}{\\lambda} - \\left(\\frac{1}{\\lambda} + \\Delta\\right) \\exp(-\\lambda \\Delta) $$\nThis is the exact expression for the expected lost work under the assumption that only the first failure matters.\n\nThe problem states that $\\lambda \\Delta$ is sufficiently small. This justifies using a Taylor series expansion for the exponential term. Let $x = \\lambda \\Delta$. The expansion is $\\exp(-x) \\approx 1 - x + \\frac{x^2}{2}$.\nSubstituting this into the expression for $E[L(\\Delta)]$:\n$$ E[L(\\Delta)] \\approx \\frac{1}{\\lambda} - \\left(\\frac{1}{\\lambda} + \\Delta\\right) \\left(1 - \\lambda \\Delta + \\frac{(\\lambda \\Delta)^2}{2}\\right) $$\n$$ E[L(\\Delta)] \\approx \\frac{1}{\\lambda} - \\left( \\frac{1}{\\lambda} - \\Delta + \\frac{\\lambda \\Delta^2}{2} + \\Delta - \\lambda \\Delta^2 + \\frac{\\lambda^2 \\Delta^3}{2} \\right) $$\nNeglecting terms of order $\\mathcal{O}(\\Delta^3)$ and higher:\n$$ E[L(\\Delta)] \\approx \\frac{1}{\\lambda} - \\left( \\frac{1}{\\lambda} - \\frac{\\lambda \\Delta^2}{2} \\right) = \\frac{\\lambda \\Delta^2}{2} $$\nThis first-order approximation $E[L(\\Delta)] \\approx \\frac{\\lambda \\Delta^2}{2}$ is standard and consistent with the problem's assumption about $\\lambda \\Delta$ being small.\n\n### Step 2: Construction of the Overhead Rate $R(\\Delta)$\n\nThe goal is to minimize the \"overhead rate\", defined as \"lost useful time per unit wall-clock time\".\nLet's analyze one operational cycle. To make $\\Delta$ seconds of useful progress, the system spends a total amount of wall-clock time $T_{cycle}$. This time is composed of:\n1.  The time for useful work: $\\Delta$.\n2.  The time for checkpointing: $c$.\n3.  The time for re-executing lost work, which on average is $E[L(\\Delta)]$.\n\nThe expected total wall-clock time to achieve $\\Delta$ seconds of progress is:\n$$ E[T_{cycle}] = \\Delta + c + E[L(\\Delta)] $$\nThe expected lost time (overhead) during this cycle is:\n$$ E[T_{overhead}] = c + E[L(\\Delta)] $$\nThe overhead rate $R(\\Delta)$ is the long-term ratio of expected overhead time to expected total time:\n$$ R(\\Delta) = \\frac{E[T_{overhead}]}{E[T_{cycle}]} = \\frac{c + E[L(\\Delta)]}{\\Delta + c + E[L(\\Delta)]} $$\nTo minimize $R(\\Delta)$, we can equivalently minimize a simpler function. Note that $R(\\Delta) = 1 - \\frac{\\Delta}{\\Delta + c + E[L(\\Delta)]}$. Minimizing $R(\\Delta)$ is equivalent to maximizing the system's throughput (useful work per unit time). Maximizing this throughput is equivalent to minimizing its reciprocal, the total time spent per unit of useful work:\n$$ O_{eff}(\\Delta) = \\frac{\\Delta + c + E[L(\\Delta)]}{\\Delta} = 1 + \\frac{c + E[L(\\Delta)]}{\\Delta} $$\nTo minimize $O_{eff}(\\Delta)$, we only need to minimize the fractional overhead term, which we define as $g(\\Delta)$:\n$$ g(\\Delta) = \\frac{c + E[L(\\Delta)]}{\\Delta} $$\nUsing the first-order approximation $E[L(\\Delta)] \\approx \\frac{1}{2}\\lambda \\Delta^2$, we have:\n$$ g(\\Delta) = \\frac{c + \\frac{1}{2}\\lambda \\Delta^2}{\\Delta} = \\frac{c}{\\Delta} + \\frac{\\lambda \\Delta}{2} $$\n\n### Step 3: Minimization of the Overhead\n\nTo find the checkpoint period $\\Delta^{\\star}$ that minimizes the overhead, we must find the minimum of the function $g(\\Delta)$. We take the first derivative of $g(\\Delta)$ with respect to $\\Delta$ and set it to zero.\n$$ \\frac{d g}{d \\Delta} = \\frac{d}{d \\Delta} \\left( \\frac{c}{\\Delta} + \\frac{\\lambda \\Delta}{2} \\right) = -\\frac{c}{\\Delta^2} + \\frac{\\lambda}{2} $$\nSetting the derivative to zero:\n$$ -\\frac{c}{\\Delta^2} + \\frac{\\lambda}{2} = 0 $$\n$$ \\frac{\\lambda}{2} = \\frac{c}{\\Delta^2} $$\nSolving for $\\Delta^2$:\n$$ \\Delta^2 = \\frac{2c}{\\lambda} $$\nSince $\\Delta$ must be a positive duration, we take the positive square root:\n$$ \\Delta^{\\star} = \\sqrt{\\frac{2c}{\\lambda}} $$\nTo confirm that this is a minimum, we check the second derivative:\n$$ \\frac{d^2 g}{d \\Delta^2} = \\frac{d}{d \\Delta} \\left( -c \\Delta^{-2} + \\frac{\\lambda}{2} \\right) = 2c \\Delta^{-3} = \\frac{2c}{\\Delta^3} $$\nSince the checkpoint cost $c$ and the interval $\\Delta$ are both positive physical quantities, $\\frac{2c}{\\Delta^3}$ is always positive. Therefore, $g(\\Delta)$ is a convex function, and the critical point we found is indeed a minimum.\n\nThe optimal checkpoint period $\\Delta^{\\star}$ is $\\sqrt{\\frac{2c}{\\lambda}}$.",
            "answer": "$$\\boxed{\\sqrt{\\frac{2c}{\\lambda}}}$$"
        },
        {
            "introduction": "To accurately predict the availability of complex cyber-physical systems, we must model the full lifecycle of failure, detection, recovery, and repair. This hands-on exercise requires you to construct a Continuous-Time Markov Chain (CTMC) for a redundant actuator subsystem, a powerful technique for modeling such state-based dynamics . By implementing and solving this model, you will compare different sparing strategies and quantify the impact of real-world factors like repair speed and imperfect recovery coverage on overall system availability.",
            "id": "4239601",
            "problem": "Consider a Continuous-Time Markov Chain (CTMC) model for a cyber-physical system (CPS) actuator subsystem with one active unit and one spare unit. The redundancy configuration can be a cold spare or a warm spare, distinguished by the idle failure rate. The subsystem experiences failure, detection, switchover, and repair processes. Let the CTMC have the following states, indexed for computation, with availability defined as the subsystem providing actuation service:\n\n- State $S_0$ (index $0$): Both units healthy, the primary is active, service available.\n- State $S_1$ (index $1$): Active unit healthy, spare failed and under repair, service available.\n- State $S_2$ (index $2$): Primary has failed, spare healthy, detection in progress, service unavailable.\n- State $S_3$ (index $3$): Switchover of spare to active in progress, service unavailable.\n- State $S_4$ (index $4$): Both units failed or coverage failure realized, service unavailable.\n\nAssume exponentially distributed times for all stochastic processes. Define the following parameters, all strictly nonnegative real numbers:\n\n- $ \\lambda_a $: Active unit failure rate (in $ \\mathrm{h}^{-1} $).\n- $ \\lambda_{\\text{idle}} $: Idle spare failure rate (in $ \\mathrm{h}^{-1} $). For a cold spare, set $ \\lambda_{\\text{idle}} = 0 $; for a warm spare, use a positive value.\n- $ \\mu $: Repair rate for a failed unit (in $ \\mathrm{h}^{-1} $).\n- $ \\delta $: Detection rate for a primary failure (in $ \\mathrm{h}^{-1} $).\n- $ \\sigma $: Switchover rate when detection succeeds (in $ \\mathrm{h}^{-1} $).\n- $ c_d \\in [0,1] $: Detection coverage, the probability that detection succeeds when attempted.\n- $ c_s \\in [0,1] $: Switchover coverage, the probability that switchover succeeds when attempted.\n- $ \\lambda_{\\text{sw}} $: Failure hazard rate for the spare while switchover is ongoing (in $ \\mathrm{h}^{-1} $).\n\nTransitions of the CTMC are defined by the generator matrix $ Q \\in \\mathbb{R}^{5 \\times 5} $ with off-diagonal entries specified by the following rates:\n\n- From $ S_0 $ to $ S_2 $ at rate $ \\lambda_a $ (active fails, detection begins).\n- From $ S_0 $ to $ S_1 $ at rate $ \\lambda_{\\text{idle}} $ (spare fails while idle).\n- From $ S_1 $ to $ S_0 $ at rate $ \\mu $ (spare repaired).\n- From $ S_1 $ to $ S_4 $ at rate $ \\lambda_a $ (active fails when spare is already failed).\n- From $ S_2 $ to $ S_3 $ at rate $ \\delta c_d $ (detection succeeds).\n- From $ S_2 $ to $ S_4 $ at rate $ \\delta (1 - c_d) $ (detection coverage failure).\n- From $ S_2 $ to $ S_4 $ at rate $ \\lambda_{\\text{idle}} $ (spare fails during detection wait).\n- From $ S_3 $ to $ S_1 $ at rate $ \\sigma c_s $ (switchover succeeds; spare becomes active, failed primary awaits repair).\n- From $ S_3 $ to $ S_4 $ at rate $ \\sigma (1 - c_s) $ (switchover coverage failure).\n- From $ S_3 $ to $ S_4 $ at rate $ \\lambda_{\\text{sw}} $ (spare fails during switchover).\n- From $ S_4 $ to $ S_1 $ at rate $ 2\\mu $ (first of two failed units repairs, restoring one healthy unit that can provide service).\n\nThe diagonal entries of $ Q $ are defined by $ Q_{ii} = -\\sum_{j \\neq i} Q_{ij} $ to ensure each row sums to zero.\n\nThe system’s steady-state availability $ A $ is the stationary probability that the CTMC resides in service-providing states, namely\n$$\nA = \\pi_0 + \\pi_1,\n$$\nwhere $ \\pi \\in \\mathbb{R}^5 $ satisfies $ \\pi Q = 0 $ and $ \\sum_{i=0}^{4} \\pi_i = 1 $.\n\nTask: Construct $ Q $ from the parameters, compute the stationary distribution $ \\pi $, and output the steady-state availability $ A $ for each test case. All rates are in per hour ($ \\mathrm{h}^{-1} $). The availability must be output as a decimal number (dimensionless), rounded to six decimal places.\n\nTest Suite (each test case is a tuple $ (\\lambda_a, \\lambda_{\\text{idle}}, \\mu, \\delta, \\sigma, c_d, c_s, \\lambda_{\\text{sw}}) $):\n\n1. Warm spare, high coverage, moderate repair:\n   - $ \\lambda_a = 1 \\times 10^{-4} $, $ \\lambda_{\\text{idle}} = 5 \\times 10^{-5} $, $ \\mu = 5 \\times 10^{-2} $, $ \\delta = 1.0 $, $ \\sigma = 2.0 $, $ c_d = 0.99 $, $ c_s = 0.98 $, $ \\lambda_{\\text{sw}} = 2 \\times 10^{-4} $.\n2. Cold spare, perfect coverage, fast repair:\n   - $ \\lambda_a = 5 \\times 10^{-5} $, $ \\lambda_{\\text{idle}} = 0.0 $, $ \\mu = 1.0 $, $ \\delta = 10.0 $, $ \\sigma = 20.0 $, $ c_d = 1.0 $, $ c_s = 1.0 $, $ \\lambda_{\\text{sw}} = 5 \\times 10^{-5} $.\n3. Warm spare, poor coverage, slow repair:\n   - $ \\lambda_a = 2 \\times 10^{-4} $, $ \\lambda_{\\text{idle}} = 1 \\times 10^{-4} $, $ \\mu = 1 \\times 10^{-3} $, $ \\delta = 0.2 $, $ \\sigma = 0.1 $, $ c_d = 0.7 $, $ c_s = 0.6 $, $ \\lambda_{\\text{sw}} = 2 \\times 10^{-4} $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"), where each result is the availability $ A $ for the corresponding test case, rounded to six decimal places. The program must be self-contained, must not read any input, and must use the test suite provided above.",
            "solution": "The problem requires the calculation of the steady-state availability of a cyber-physical system's actuator subsystem, which is modeled as a Continuous-Time Markov Chain (CTMC). The solution involves constructing the CTMC's generator matrix $Q$, solving for the stationary probability distribution $\\pi$, and then summing the probabilities of the system being in an operational state.\n\nFirst, we formalize the CTMC model based on the provided specifications. The system is described by five states, indexed from $0$ to $4$: $S_0$ (fully operational), $S_1$ (operational with spare under repair), $S_2$ (primary failed, detection in progress), $S_3$ (switchover in progress), and $S_4$ (system failed).\n\nThe dynamics of the CTMC are governed by the generator matrix $Q \\in \\mathbb{R}^{5 \\times 5}$. The off-diagonal elements $Q_{ij}$ (for $i \\neq j$) represent the transition rate from state $S_i$ to state $S_j$. Based on the problem description, these rates are:\n- $Q_{0,1} = \\lambda_{\\text{idle}}$\n- $Q_{0,2} = \\lambda_a$\n- $Q_{1,0} = \\mu$\n- $Q_{1,4} = \\lambda_a$\n- $Q_{2,3} = \\delta c_d$\n- $Q_{2,4} = \\delta (1-c_d) + \\lambda_{\\text{idle}}$ (sum of rates for two parallel transitions)\n- $Q_{3,1} = \\sigma c_s$\n- $Q_{3,4} = \\sigma (1-c_s) + \\lambda_{\\text{sw}}$ (sum of rates for two parallel transitions)\n- $Q_{4,1} = 2\\mu$\n\nAll other off-diagonal elements are $0$. The diagonal elements $Q_{ii}$ are defined such that the sum of each row is zero, which is a fundamental property of a generator matrix. Therefore, $Q_{ii} = -\\sum_{j \\neq i} Q_{ij}$. This gives:\n- $Q_{0,0} = -(\\lambda_a + \\lambda_{\\text{idle}})$\n- $Q_{1,1} = -(\\mu + \\lambda_a)$\n- $Q_{2,2} = -(\\delta c_d + \\delta(1-c_d) + \\lambda_{\\text{idle}}) = -(\\delta + \\lambda_{\\text{idle}})$\n- $Q_{3,3} = -(\\sigma c_s + \\sigma(1-c_s) + \\lambda_{\\text{sw}}) = -(\\sigma + \\lambda_{\\text{sw}})$\n- $Q_{4,4} = -2\\mu$\n\nPutting this together, the generator matrix $Q$ is:\n$$\nQ = \\begin{pmatrix}\n-(\\lambda_a + \\lambda_{\\text{idle}}) & \\lambda_{\\text{idle}} & \\lambda_a & 0 & 0 \\\\\n\\mu & -(\\mu + \\lambda_a) & 0 & 0 & \\lambda_a \\\\\n0 & 0 & -(\\delta + \\lambda_{\\text{idle}}) & \\delta c_d & \\delta(1-c_d) + \\lambda_{\\text{idle}} \\\\\n0 & \\sigma c_s & 0 & -(\\sigma + \\lambda_{\\text{sw}}) & \\sigma(1-c_s) + \\lambda_{\\text{sw}} \\\\\n0 & 2\\mu & 0 & 0 & -2\\mu\n\\end{pmatrix}\n$$\n\nThe steady-state or stationary probability distribution is a row vector $\\pi = [\\pi_0, \\pi_1, \\pi_2, \\pi_3, \\pi_4]$ that satisfies two conditions:\n1. The global balance equations: $\\pi Q = 0$.\n2. The normalization constraint: $\\sum_{i=0}^{4} \\pi_i = 1$.\n\nThe system $\\pi Q = 0$ is a system of homogeneous linear equations. Since the sum of the columns of $Q$ weighted by $\\pi$ is the zero vector, and the rows of $Q$ sum to zero, one of the equations is redundant. To find a unique solution for $\\pi$, we must incorporate the normalization constraint. A standard numerical method is to solve the equivalent transposed system $Q^T \\pi^T = 0^T$ along with the normalization constraint.\n\nWe can construct a new system of linear equations $M\\mathbf{x} = \\mathbf{b}$, where $\\mathbf{x} = \\pi^T$. The matrix $M$ is formed by taking the transpose of the generator matrix, $Q^T$, and replacing one of its rows (e.g., the last row) with a row of all ones, representing the normalization equation. The vector $\\mathbf{b}$ is a column vector of zeros, with a one in the corresponding last position.\n$$\nM = \\begin{pmatrix}\nQ_{00} & Q_{10} & Q_{20} & Q_{30} & Q_{40} \\\\\nQ_{01} & Q_{11} & Q_{21} & Q_{31} & Q_{41} \\\\\nQ_{02} & Q_{12} & Q_{22} & Q_{32} & Q_{42} \\\\\nQ_{03} & Q_{13} & Q_{23} & Q_{33} & Q_{43} \\\\\n1 & 1 & 1 & 1 & 1\n\\end{pmatrix}, \\quad \\mathbf{x} = \\begin{pmatrix} \\pi_0 \\\\ \\pi_1 \\\\ \\pi_2 \\\\ \\pi_3 \\\\ \\pi_4 \\end{pmatrix}, \\quad \\mathbf{b} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix}\n$$\nThis non-homogeneous system $M\\mathbf{x} = \\mathbf{b}$ has a unique solution for $\\mathbf{x} = \\pi^T$, which can be found efficiently using a numerical linear algebra solver.\n\nOnce the stationary probabilities $\\pi_0, \\dots, \\pi_4$ are computed, the steady-state availability $A$ is calculated. Availability is defined as the probability that the system is in a state where service is provided. According to the problem description, these are states $S_0$ and $S_1$.\n$$\nA = \\pi_0 + \\pi_1\n$$\n\nThe algorithm proceeds as follows for each test case:\n1. Assign the given parameter values: $\\lambda_a, \\lambda_{\\text{idle}}, \\mu, \\delta, \\sigma, c_d, c_s, \\lambda_{\\text{sw}}$.\n2. Construct the $5 \\times 5$ numerical generator matrix $Q$.\n3. Form the matrix $M$ by transposing $Q$ and replacing its last row with ones.\n4. Form the vector $\\mathbf{b} = [0, 0, 0, 0, 1]^T$.\n5. Solve the linear system $M\\pi^T = \\mathbf{b}$ to find the stationary probabilities $\\pi$.\n6. Calculate the availability $A = \\pi_0 + \\pi_1$.\n7. Round the result to six decimal places as required.\n\nThis procedure will be applied to each of the three test suites provided in the problem statement. The final output is a list of the computed availability values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state availability of a CTMC model for a CPS actuator.\n    \"\"\"\n    # Test Suite (lambda_a, lambda_idle, mu, delta, sigma, c_d, c_s, lambda_sw)\n    test_cases = [\n        # 1. Warm spare, high coverage, moderate repair\n        (1e-4, 5e-5, 5e-2, 1.0, 2.0, 0.99, 0.98, 2e-4),\n        # 2. Cold spare, perfect coverage, fast repair\n        (5e-5, 0.0, 1.0, 10.0, 20.0, 1.0, 1.0, 5e-5),\n        # 3. Warm spare, poor coverage, slow repair\n        (2e-4, 1e-4, 1e-3, 0.2, 0.1, 0.7, 0.6, 2e-4),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambda_a, lambda_idle, mu, delta, sigma, c_d, c_s, lambda_sw = case\n\n        # Initialize the 5x5 generator matrix Q with zeros\n        Q = np.zeros((5, 5))\n\n        # Populate the off-diagonal elements of Q based on transition rates\n        # from state i to state j is Q[i, j]\n        \n        # From S0 (index 0)\n        Q[0, 1] = lambda_idle  # S0 -> S1 (spare fails)\n        Q[0, 2] = lambda_a     # S0 -> S2 (active fails)\n\n        # From S1 (index 1)\n        Q[1, 0] = mu           # S1 -> S0 (spare repaired)\n        Q[1, 4] = lambda_a     # S1 -> S4 (active fails)\n\n        # From S2 (index 2)\n        Q[2, 3] = delta * c_d                          # S2 -> S3 (detection succeeds)\n        Q[2, 4] = delta * (1 - c_d) + lambda_idle      # S2 -> S4 (detection fail or spare fail)\n\n        # From S3 (index 3)\n        Q[3, 1] = sigma * c_s                          # S3 -> S1 (switchover succeeds)\n        Q[3, 4] = sigma * (1 - c_s) + lambda_sw        # S3 -> S4 (switchover fail or spare fail)\n\n        # From S4 (index 4)\n        Q[4, 1] = 2 * mu       # S4 -> S1 (one unit repaired)\n\n        # Populate the diagonal elements of Q\n        for i in range(5):\n            Q[i, i] = -np.sum(Q[i, :])\n\n        # To find the stationary distribution pi, solve the system pi * Q = 0,\n        # which is equivalent to Q.T * pi.T = 0, subject to sum(pi) = 1.\n        # We replace one equation with the normalization constraint.\n        A_sys = Q.T\n        A_sys[-1, :] = 1.0  # Replace last row with all 1s for normalization\n\n        # Create the target vector b\n        b_sys = np.zeros(5)\n        b_sys[-1] = 1.0\n\n        # Solve the linear system A_sys * pi = b_sys for pi\n        try:\n            pi = np.linalg.solve(A_sys, b_sys)\n        except np.linalg.LinAlgError:\n            # Handle cases where the matrix may be singular, if necessary.\n            # For a well-defined irreducible CTMC, this should not happen.\n            pi = np.array([0.0, 0.0, 0.0, 0.0, 0.0]) # Failsafe\n\n        # Availability is the sum of probabilities of being in operational states S0 and S1\n        availability = pi[0] + pi[1]\n        \n        # Round to six decimal places and append to results\n        results.append(round(availability, 6))\n\n    # Format the final output string as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}