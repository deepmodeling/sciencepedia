{
    "hands_on_practices": [
        {
            "introduction": "The interface between the physical world and the digital domain is a critical and often overlooked attack surface. Sensor measurements are inevitably quantized, and this discretization process can mask small, malicious analog perturbations, rendering them invisible to the digital twin. This exercise  challenges you to move beyond abstract threats by calculating the precise mathematical boundary for such an 'imperceptible' attack, revealing the interplay between signal processing and system security.",
            "id": "4204828",
            "problem": "A learning-enabled Cyber-Physical System (CPS) uses a Digital Twin (DT) state estimator that consumes quantized sensor measurements. Each scalar sensor channel is modeled as an ideal uniform mid-tread quantizer with step size $\\Delta > 0$ and a symmetric saturation limit $y_{\\max} > 0$. The pre-quantization analog measurement is $y \\in \\mathbb{R}$ and the adversary injects an additive perturbation $\\delta \\in \\mathbb{R}$ before quantization, with the constraint $\\|\\delta\\|_{\\infty} \\le \\epsilon$ (for a scalar, $\\|\\delta\\|_{\\infty} = |\\delta|$). The measurement is first saturated by $\\mathrm{sat}(x) = \\mathrm{sgn}(x)\\,\\min\\{|x|,\\,y_{\\max}\\}$ and then quantized by the mid-tread rounding map\n$$\nQ(x) \\;=\\; \\Delta \\cdot \\mathrm{clip}\\!\\left(\\mathrm{round}\\!\\left(\\frac{x}{\\Delta}\\right),\\, -K,\\, K\\right), \n\\quad K \\;=\\; \\left\\lfloor \\frac{y_{\\max}}{\\Delta} \\right\\rfloor,\n$$\nwhere $\\mathrm{round}(\\cdot)$ rounds to the nearest integer and $\\mathrm{clip}(z,-K,K) = \\max\\{-K, \\min\\{z, K\\}\\}$ enforces saturation in the code domain.\n\nThe DT’s imperceptibility criterion is that the digital output code does not change under attack, namely\n$$\nQ\\!\\big(\\mathrm{sat}(y+\\delta)\\big) \\;=\\; Q\\!\\big(\\mathrm{sat}(y)\\big).\n$$\nAssume the CPS calibration holds the nominal measurement at the center of its quantization cell and away from saturation, i.e., there exists $k \\in \\mathbb{Z}$ such that $y = k\\Delta$ and $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$.\n\nStarting only from the definitions above and standard properties of uniform quantization and saturation, derive:\n1. The largest $\\epsilon$ such that every adversarial perturbation with $\\|\\delta\\|_{\\infty} \\le \\epsilon$ remains imperceptible after quantization in the sense defined above.\n2. The effective attack power under these constraints, defined as\n$$\nP_{\\mathrm{eff}} \\;=\\; \\sup_{\\;|\\delta| \\le \\epsilon,\\;\\; Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))} \\; \\delta^{2}.\n$$\n\nExpress $\\epsilon$ in volts (V) and $P_{\\mathrm{eff}}$ in squared volts ($\\mathrm{V}^2$). Provide your final answer as a single closed-form analytic expression. No rounding is required.",
            "solution": "The problem asks for two quantities: the largest perturbation tolerance $\\epsilon$ that guarantees imperceptibility, and the effective attack power $P_{\\mathrm{eff}}$ under this constraint.\n\nFirst, we analyze the unperturbed system's output, $Q(\\mathrm{sat}(y))$.\nThe nominal measurement is given as $y = k\\Delta$ for some integer $k \\in \\mathbb{Z}$.\nIt is also constrained by $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$.\nSince $\\Delta > 0$, this implies $|y|  y_{\\max}$.\nThe saturation function is $\\mathrm{sat}(x) = \\mathrm{sgn}(x)\\min\\{|x|, y_{\\max}\\}$. As $|y|  y_{\\max}$, we have $\\mathrm{sat}(y) = y$.\nThe quantization function is $Q(x) = \\Delta \\cdot \\mathrm{clip}(\\mathrm{round}(x/\\Delta), -K, K)$, with $K = \\lfloor y_{\\max}/\\Delta \\rfloor$.\nFor the unperturbed input $y = k\\Delta$, the argument of the rounding function is $\\frac{y}{\\Delta} = \\frac{k\\Delta}{\\Delta} = k$. Since $k$ is an integer, $\\mathrm{round}(k) = k$.\nThe clipping function argument is thus $k$. The given condition $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$ implies $|k\\Delta| \\le y_{\\max} - \\frac{\\Delta}{2}$, which means $|k| \\le \\frac{y_{\\max}}{\\Delta} - \\frac{1}{2}$. Since $k$ is an integer, this requires $|k| \\le \\lfloor \\frac{y_{\\max}}{\\Delta} - \\frac{1}{2} \\rfloor$. As $\\lfloor z-\\frac{1}{2} \\rfloor \\le \\lfloor z \\rfloor$ for any $z \\in \\mathbb{R}$, it follows that $|k| \\le \\lfloor \\frac{y_{\\max}}{\\Delta} \\rfloor = K$.\nTherefore, the clipping function is inactive for the index $k$: $\\mathrm{clip}(k, -K, K) = k$.\nThe output for the unperturbed signal is $Q(\\mathrm{sat}(y)) = Q(y) = \\Delta \\cdot k = k\\Delta$.\n\nNext, we analyze the imperceptibility criterion: $Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y)) = k\\Delta$.\nLet $x' = \\mathrm{sat}(y+\\delta)$. The criterion becomes $Q(x') = k\\Delta$.\nGiven our finding that $|k| \\le K$, this simplifies to $\\Delta \\cdot \\mathrm{round}(x'/\\Delta) = k\\Delta$, which in turn requires $\\mathrm{round}(x'/\\Delta) = k$.\nFor the output of the $\\mathrm{round}(\\cdot)$ function to be the integer $k$, its argument must lie within the quantization cell corresponding to $k$. This cell includes all numbers closer to $k$ than to any other integer. This implies the condition $|\\frac{x'}{\\Delta} - k| \\le \\frac{1}{2}$, which is equivalent to $|x' - k\\Delta| \\le \\frac{\\Delta}{2}$.\n\nSo, the imperceptibility condition for any $\\delta$ is $|\\mathrm{sat}(y+\\delta) - k\\Delta| \\le \\frac{\\Delta}{2}$.\nWe need to find the largest $\\epsilon > 0$ such that this condition holds for all $\\delta$ satisfying $|\\delta| \\le \\epsilon$.\n\nLet's examine the saturation term $\\mathrm{sat}(y+\\delta)$. The magnitude of the perturbed signal is $|y+\\delta| \\le |y| + |\\delta|$.\nGiven the problem constraints, $|y| \\le y_{\\max} - \\frac{\\Delta}{2}$ and $|\\delta| \\le \\epsilon$.\nSo, $|y+\\delta| \\le (y_{\\max} - \\frac{\\Delta}{2}) + \\epsilon$.\nFor the signal to remain unsaturated, we would need $|y+\\delta| \\le y_{\\max}$. This implies $(y_{\\max} - \\frac{\\Delta}{2}) + \\epsilon \\le y_{\\max}$, which gives $\\epsilon \\le \\frac{\\Delta}{2}$.\nLet's test this bound. If we choose $\\epsilon = \\frac{\\Delta}{2}$, then for any $|\\delta| \\le \\frac{\\Delta}{2}$, we have:\n$$|y+\\delta| \\le |y| + |\\delta| \\le \\left(y_{\\max} - \\frac{\\Delta}{2}\\right) + \\frac{\\Delta}{2} = y_{\\max}$$\nThis shows that for any perturbation $\\delta$ with magnitude up to $\\frac{\\Delta}{2}$, the perturbed signal $y+\\delta$ does not saturate. Therefore, $\\mathrm{sat}(y+\\delta) = y+\\delta$.\n\nWith the saturation being inactive for the range of $\\delta$ in question, the imperceptibility condition $|\\mathrm{sat}(y+\\delta) - k\\Delta| \\le \\frac{\\Delta}{2}$ simplifies to:\n$$| (y+\\delta) - k\\Delta | \\le \\frac{\\Delta}{2}$$\nSubstituting $y=k\\Delta$:\n$$| (k\\Delta+\\delta) - k\\Delta | \\le \\frac{\\Delta}{2}$$\n$$| \\delta | \\le \\frac{\\Delta}{2}$$\nWe are tasked to find the largest $\\epsilon$ such that for every $\\delta$ with $|\\delta| \\le \\epsilon$, the imperceptibility condition holds. Our derivation shows the imperceptibility condition is equivalent to $|\\delta| \\le \\frac{\\Delta}{2}$.\nThus, we need to find the largest $\\epsilon$ such that the statement \"$|\\delta| \\le \\epsilon \\implies |\\delta| \\le \\frac{\\Delta}{2}$\" is true. This logical implication holds if and only if $\\epsilon \\le \\frac{\\Delta}{2}$.\nThe largest value of $\\epsilon$ that satisfies this is $\\epsilon = \\frac{\\Delta}{2}$.\n\nThis solves the first part of the problem.\n$\\epsilon = \\frac{\\Delta}{2}$.\n\nFor the second part, we must find the effective attack power, defined as:\n$$P_{\\mathrm{eff}} \\;=\\; \\sup_{\\;|\\delta| \\le \\epsilon,\\;\\; Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))} \\; \\delta^{2}$$\nWe have found that $\\epsilon = \\frac{\\Delta}{2}$.\nWe have also demonstrated that for any $\\delta$ such that $|\\delta| \\le \\epsilon$, the condition $Q(\\mathrm{sat}(y+\\delta)) = Q(\\mathrm{sat}(y))$ is satisfied.\nTherefore, the constraint set for the supremum is simply $|\\delta| \\le \\epsilon$, which is $|\\delta| \\le \\frac{\\Delta}{2}$.\nThe problem reduces to finding:\n$$P_{\\mathrm{eff}} = \\sup_{|\\delta| \\le \\frac{\\Delta}{2}} \\delta^2$$\nThe function $f(\\delta) = \\delta^2$ is maximized over the closed interval $[-\\frac{\\Delta}{2}, \\frac{\\Delta}{2}]$ at its endpoints, i.e., at $\\delta = \\frac{\\Delta}{2}$ and $\\delta = -\\frac{\\Delta}{2}$.\nThe supremum value is:\n$$P_{\\mathrm{eff}} = \\left(\\frac{\\Delta}{2}\\right)^2 = \\frac{\\Delta^2}{4}$$\n\nThe problem requires $\\epsilon$ in volts (V) and $P_{\\mathrm{eff}}$ in squared volts ($\\mathrm{V}^2$). This implies that the quantity $\\Delta$ is measured in volts. The derived expressions are dimensionally consistent.\n\nThe two results are $\\epsilon = \\frac{\\Delta}{2}$ and $P_{\\mathrm{eff}} = \\frac{\\Delta^2}{4}$. We present them as a single matrix expression as required.",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\Delta}{2}  \\frac{\\Delta^{2}}{4} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "To build robust defenses, one must first learn to think like an adversary. This practice  shifts the perspective from analyzing vulnerabilities to actively crafting an optimal attack on a learning-enabled system. You will design a feature-space perturbation to deceive a mobile robot's learned obstacle detector, with the objective of causing the avoidance policy to fail and forcing a safety violation.",
            "id": "4204841",
            "problem": "Consider a discrete-time Cyber-Physical System (CPS) consisting of a mobile robot and a learned obstacle detector. The robot has a planar kinematic model with curvature dynamics and bounded curvature-rate actuation. Let the robot state at time step $t$ be $x_t = [p_{x,t}, p_{y,t}, \\theta_t, \\kappa_t]$, where $p_{x,t}$ and $p_{y,t}$ are position in meters, $\\theta_t$ is heading in radians, and $\\kappa_t$ is curvature in inverse meters. The control input is $u_t = [v, \\Delta \\kappa_t]$, where $v$ is forward speed in meters per second and $\\Delta \\kappa_t$ is the curvature rate increment per time step in inverse meters. The discrete-time update over a time step $\\Delta t$ is\n$$\n\\begin{aligned}\np_{x,t+1} = p_{x,t} + v \\cos(\\theta_t)\\, \\Delta t,\\\\\np_{y,t+1} = p_{y,t} + v \\sin(\\theta_t)\\, \\Delta t,\\\\\n\\theta_{t+1} = \\theta_t + v\\, \\kappa_t\\, \\Delta t,\\\\\n\\kappa_{t+1} = \\kappa_t + \\Delta \\kappa_t,\n\\end{aligned}\n$$\nwith a bounded curvature-rate constraint $|\\Delta \\kappa_t| \\leq \\kappa_{\\mathrm{rate,max}}$.\n\nA learned obstacle detector operates on a two-dimensional feature vector $y_t \\in \\mathbb{R}^2$ constructed from the robot state and a fixed obstacle position $o = [o_x, o_y]$:\n$$\nr_t = \\sqrt{(o_x - p_{x,t})^2 + (o_y - p_{y,t})^2},\\quad\nb_t = \\mathrm{atan2}(o_y - p_{y,t}, o_x - p_{x,t}) - \\theta_t,\n$$\nwhere $r_t$ is the range in meters and $b_t$ is the bearing in radians. The feature vector is $y_t = [\\phi_1(r_t), \\phi_2(b_t)] = [1/r_t, \\cos(b_t)]$, which is dimensionless. The detector is a logistic classifier producing a probability $p_t \\in [0,1]$ via\n$$\np_t = \\sigma(w^\\top y_t + \\beta), \\quad \\text{with} \\quad \\sigma(z) = \\frac{1}{1 + e^{-z}},\n$$\nwhere $w \\in \\mathbb{R}^2$ and $\\beta \\in \\mathbb{R}$ are fixed learned parameters.\n\nA simple avoidance policy uses the detector output at $t=0$ to set the curvature-rate command for all subsequent steps:\n$$\n\\Delta \\kappa_t =\n\\begin{cases}\n-\\kappa_{\\mathrm{rate,max}}\\, \\mathrm{sign}(b_0),  \\text{if } p_0 \\ge \\tau,\\\\\n0,  \\text{if } p_0  \\tau,\n\\end{cases}\n\\quad \\text{for all } t \\in \\{0, 1, \\dots, N-1\\},\n$$\nwhere $\\tau \\in (0,1)$ is a fixed decision threshold, and $\\mathrm{sign}(\\cdot)$ denotes the sign function. This policy attempts to turn away from the obstacle when the detector indicates it is in the path. The minimum clearance relative to the obstacle over the horizon is\n$$\n\\mathrm{clearance}_{\\min} = \\min_{t \\in \\{0,1,\\dots,N\\}} \\sqrt{(o_x - p_{x,t})^2 + (o_y - p_{y,t})^2},\n$$\nand a safety requirement imposes $\\mathrm{clearance}_{\\min} \\ge d_{\\min}$, with $d_{\\min}$ in meters.\n\nAn adversary perturbs the detector input by adding a feature-space perturbation $\\delta \\in \\mathbb{R}^2$ at $t=0$, yielding the attacked feature vector $y_0^{\\mathrm{adv}} = y_0 + \\delta$, with perturbation budget constraint $\\|\\delta\\|_2 \\le \\varepsilon$, where $\\varepsilon$ is dimensionless. The objective of the adversary is to induce a control input sequence that violates the minimum clearance constraint, subject to the bounded curvature-rate constraint, by reducing the detector output below threshold $\\tau$.\n\nStarting from the above fundamentals, implement a program that computes, for each provided test case:\n- an adversarial feature perturbation $\\delta^\\star$ at $t=0$ that minimizes the logistic detector’s decision score under the budget $\\|\\delta\\|_2 \\le \\varepsilon$,\n- the resulting control input determined by the avoidance policy with $y_0^{\\mathrm{adv}}$,\n- the discrete-time trajectory over $N$ steps under the bounded curvature-rate constraint,\n- the minimum clearance, and a boolean indicating violation of the safety requirement, defined as $\\mathrm{clearance}_{\\min}  d_{\\min}$.\n\nUse the following fixed parameters across all test cases:\n- $v = 1.0$ meters per second,\n- $\\Delta t = 0.1$ seconds,\n- $\\kappa_{\\mathrm{rate,max}} = 0.02$ inverse meters per time step,\n- $N = 50$ time steps,\n- $d_{\\min} = 0.5$ meters,\n- $\\tau = 0.5$,\n- $w = [4.0, 6.0]$ (dimensionless),\n- $\\beta = -3.0$ (dimensionless),\n- initial state $x_0 = [0.0, 0.0, 0.0, 0.0]$ (meters, meters, radians, inverse meters).\n\nTest suite of four cases (express all angles in radians and distances in meters):\n1. Case A (happy path): obstacle at $o = [3.0, 0.2]$, attack budget $\\varepsilon = 0.65$.\n2. Case B (boundary budget): obstacle at $o = [3.0, 0.2]$, attack budget $\\varepsilon = 0.55$.\n3. Case C (edge, obstacle behind): obstacle at $o = [-2.0, 0.0]$, attack budget $\\varepsilon = 0.65$.\n4. Case D (edge, obstacle far ahead): obstacle at $o = [10.0, 0.0]$, attack budget $\\varepsilon = 0.65$.\n\nYour program must produce a single line of output containing the boolean violation results for the four cases, as a comma-separated list enclosed in square brackets, for example, \"[True,False,True,False]\". No additional text should be printed. Angles must be computed in radians and all distances must be in meters. The boolean values indicate whether the adversarial perturbation induces a violation ($\\mathrm{clearance}_{\\min}  d_{\\min}$) under the bounded curvature-rate constraint for each case.",
            "solution": "The solution process involves four main steps for each test case:\n1.  Compute the optimal adversarial perturbation $\\delta^\\star$.\n2.  Determine the control action based on the perturbed detector output.\n3.  Simulate the robot's trajectory under the determined control action.\n4.  Calculate the minimum clearance to the obstacle and check for a safety violation.\n\nThe fixed parameters for all computations are:\n- Speed $v = 1.0 \\, \\mathrm{m/s}$\n- Time step $\\Delta t = 0.1 \\, \\mathrm{s}$\n- Maximum curvature rate $\\kappa_{\\mathrm{rate,max}} = 0.02 \\, \\mathrm{m}^{-1}/\\mathrm{step}$\n- Simulation horizon $N = 50$ steps\n- Minimum required clearance $d_{\\min} = 0.5 \\, \\mathrm{m}$\n- Detector threshold $\\tau = 0.5$\n- Classifier weights $w = [4.0, 6.0]^\\top$ (dimensionless)\n- Classifier bias $\\beta = -3.0$ (dimensionless)\n- Initial state $x_0 = [p_{x,0}, p_{y,0}, \\theta_0, \\kappa_0] = [0.0, 0.0, 0.0, 0.0]$ in units of (m, m, rad, m⁻¹).\n\n**Step 1: Optimal Adversarial Perturbation**\n\nThe adversary's goal is to minimize the detector's output probability $p_0^{\\mathrm{adv}} = \\sigma(w^\\top y_0^{\\mathrm{adv}} + \\beta)$. The sigmoid function $\\sigma(z)$ is monotonically increasing. Therefore, minimizing $p_0^{\\mathrm{adv}}$ is equivalent to minimizing its argument, the decision score $S_{\\mathrm{adv}} = w^\\top y_0^{\\mathrm{adv}} + \\beta$.\n\nThe attacked feature vector is $y_0^{\\mathrm{adv}} = y_0 + \\delta$. Substituting this into the score gives:\n$$\nS_{\\mathrm{adv}}(\\delta) = w^\\top (y_0 + \\delta) + \\beta = (w^\\top y_0 + \\beta) + w^\\top \\delta\n$$\nThe first part, $(w^\\top y_0 + \\beta)$, is constant for a given scenario. To minimize $S_{\\mathrm{adv}}(\\delta)$, the adversary must minimize the term $w^\\top \\delta$. This is a dot product, which is minimized when the vector $\\delta$ points in the direction opposite to the vector $w$.\n\nThe adversary is constrained by a budget $\\|\\delta\\|_2 \\le \\varepsilon$. To achieve the maximum negative projection onto $w$, the perturbation $\\delta$ must have the maximum possible magnitude, $\\varepsilon$, and be aligned with the direction $-w$. Therefore, the optimal perturbation $\\delta^\\star$ is:\n$$\n\\delta^\\star = -\\varepsilon \\frac{w}{\\|w\\|_2}\n$$\nWith $w = [4.0, 6.0]^\\top$, the L2-norm is $\\|w\\|_2 = \\sqrt{4.0^2 + 6.0^2} = \\sqrt{16.0 + 36.0} = \\sqrt{52.0}$.\nThe optimal perturbation is a function of the attack budget $\\varepsilon$:\n$$\n\\delta^\\star = -\\frac{\\varepsilon}{\\sqrt{52.0}} [4.0, 6.0]^\\top\n$$\n\n**Step 2: Control Policy Decision**\n\nFor each test case, we first compute the initial unperturbed feature vector $y_0$. The initial state is $x_0 = [0,0,0,0]$.\n- The range to the obstacle $o=[o_x, o_y]$ is $r_0 = \\sqrt{(o_x - 0)^2 + (o_y - 0)^2} = \\sqrt{o_x^2 + o_y^2}$.\n- The bearing to the obstacle is $b_0 = \\mathrm{atan2}(o_y - 0, o_x - 0) - 0 = \\mathrm{atan2}(o_y, o_x)$.\n- The feature vector is $y_0 = [1/r_0, \\cos(b_0)]^\\top$.\n\nWe then compute the attacked feature vector $y_0^{\\mathrm{adv}} = y_0 + \\delta^\\star$ and the corresponding decision score $S_{\\mathrm{adv}} = w^\\top y_0^{\\mathrm{adv}} + \\beta$.\n\nThe avoidance policy is:\n$$\n\\Delta \\kappa =\n\\begin{cases}\n-\\kappa_{\\mathrm{rate,max}}\\, \\mathrm{sign}(b_0),  \\text{if } p_0^{\\mathrm{adv}} \\ge \\tau,\\\\\n0,  \\text{if } p_0^{\\mathrm{adv}}  \\tau,\n\\end{cases}\n$$\nwhere $\\Delta\\kappa$ is the constant curvature rate for all time steps $t=0, \\dots, N-1$. Since $\\tau=0.5$, the condition $p_0^{\\mathrm{adv}} \\ge \\tau$ is equivalent to $S_{\\mathrm{adv}} \\ge 0$, and $p_0^{\\mathrm{adv}}  \\tau$ is equivalent to $S_{\\mathrm{adv}}  0$. The adversary's goal is to make $S_{\\mathrm{adv}}  0$, which sets $\\Delta\\kappa=0$ and causes the robot to move straight, potentially into the obstacle.\n\n**Step 3: Trajectory Simulation**\n\nWith the constant curvature rate $\\Delta\\kappa$ determined, we simulate the robot's trajectory for $N=50$ steps. Starting with $x_0$, we iterate from $t=0$ to $N-1$ using the discrete-time dynamics:\n$$\n\\begin{aligned}\n\\kappa_{t+1} = \\kappa_t + \\Delta \\kappa \\\\\n\\theta_{t+1} = \\theta_t + v \\, \\kappa_t \\, \\Delta t \\\\\np_{x,t+1} = p_{x,t} + v \\cos(\\theta_t) \\, \\Delta t \\\\\np_{y,t+1} = p_{y,t} + v \\sin(\\theta_t) \\, \\Delta t\n\\end{aligned}\n$$\nWe store the position $[p_{x,t}, p_{y,t}]$ at each time step $t \\in \\{0, 1, \\dots, N\\}$.\n\n**Step 4: Minimum Clearance and Violation Check**\n\nAfter generating the full trajectory of positions, we compute the Euclidean distance to the obstacle $o$ at each time step:\n$$\nd_t = \\sqrt{(o_x - p_{x,t})^2 + (o_y - p_{y,t})^2} \\quad \\text{for } t \\in \\{0, 1, \\dots, N\\}\n$$\nThe minimum clearance over the horizon is $\\mathrm{clearance}_{\\min} = \\min_{t} d_t$.\nA safety violation occurs if this clearance is less than the required minimum, i.e., if $\\mathrm{clearance}_{\\min}  d_{\\min}$. We compute this boolean value for each test case.\n\nThis complete procedure is implemented for each of the four test cases provided in the problem statement. The final output is a list of these boolean violation indicators.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes adversarial attack outcomes for a CPS robot model.\n    For each test case, it calculates an optimal adversarial perturbation,\n    simulates the robot's trajectory under the attacked control policy,\n    and determines if a safety violation occurs.\n    \"\"\"\n\n    # Fixed parameters from the problem statement\n    v = 1.0  # meters per second\n    dt = 0.1  # seconds\n    kappa_rate_max = 0.02  # inverse meters per time step\n    N = 50  # time steps\n    d_min = 0.5  # meters\n    tau = 0.5  # dimensionless\n    w = np.array([4.0, 6.0])  # dimensionless\n    beta = -3.0  # dimensionless\n    x0 = np.array([0.0, 0.0, 0.0, 0.0])  # m, m, rad, 1/m\n\n    # Test cases: (obstacle_position, attack_budget_epsilon)\n    test_cases = [\n        (np.array([3.0, 0.2]), 0.65),  # Case A\n        (np.array([3.0, 0.2]), 0.55),  # Case B\n        (np.array([-2.0, 0.0]), 0.65),  # Case C\n        (np.array([10.0, 0.0]), 0.65),  # Case D\n    ]\n\n    results = []\n\n    # Calculate optimal perturbation direction\n    norm_w = np.linalg.norm(w)\n    w_dir_inv = -w / norm_w\n\n    for o, epsilon in test_cases:\n        # Step 1: Compute optimal adversarial perturbation delta_star\n        delta_star = epsilon * w_dir_inv\n\n        # Step 2: Determine control action with attacked detector\n        px0, py0, theta0, _ = x0\n        \n        # Calculate initial features\n        r0 = np.linalg.norm(o - x0[:2])\n        # Handle case where r0 is zero to avoid division by zero\n        if r0 == 0:\n            # If robot starts on the obstacle, it's a violation.\n            # However, problem setup ensures r0  0 for all test cases.\n            # We can treat y0 features as infinitely large.\n            # In practice, with this problem's test cases, this won't happen.\n            y0 = np.array([np.inf, 0.0])\n        else:\n            b0 = np.arctan2(o[1] - py0, o[0] - px0) - theta0\n            y0 = np.array([1.0 / r0, np.cos(b0)])\n\n        # Apply attack and get decision score\n        y0_adv = y0 + delta_star\n        score_adv = w @ y0_adv + beta\n        \n        # Decide on control input delta_kappa based on the policy\n        # Condition p_adv = tau is equivalent to score_adv = 0 for tau=0.5\n        delta_kappa = 0.0\n        if score_adv = 0:\n            delta_kappa = -kappa_rate_max * np.sign(b0)\n\n        # Step 3: Simulate the trajectory\n        x = x0.copy()\n        trajectory_positions = [x0[:2]]\n        for _ in range(N):\n            px, py, theta, kappa = x\n            \n            # Update state using discrete-time dynamics\n            kappa_next = kappa + delta_kappa\n            # Note: The model updates theta and position using state from start of timestep\n            theta_next = theta + v * kappa * dt\n            px_next = px + v * np.cos(theta) * dt\n            py_next = py + v * np.sin(theta) * dt\n            \n            x = np.array([px_next, py_next, theta_next, kappa_next])\n            trajectory_positions.append(x[:2])\n            \n        # Step 4: Calculate minimum clearance and check for violation\n        trajectory_positions = np.array(trajectory_positions)\n        distances_to_obstacle = np.linalg.norm(trajectory_positions - o, axis=1)\n        min_clearance = np.min(distances_to_obstacle)\n\n        violation = min_clearance  d_min\n        results.append(violation)\n\n    # Format the final output as a string\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate goal in designing secure cyber-physical systems is to provide formal guarantees of safety, even under adversarial conditions. This final practice focuses on defense, introducing reachability analysis as a powerful verification tool for learning-enabled systems. By implementing the specified algorithm , you will compute a formal over-approximation of all possible system states, thereby certifying that a neural network controller will keep the plant within a safe operating region despite bounded attacks and disturbances.",
            "id": "4204835",
            "problem": "Consider a discrete-time linear time-invariant plant controlled by a learning-enabled policy inside a Digital Twin of a Cyber-Physical System (CPS). The plant state is $x_t \\in \\mathbb{R}^2$, the control input is $u_t \\in \\mathbb{R}$, and the observed measurement is $y_t \\in \\mathbb{R}^2$. The dynamics are\n$$\nx_{t+1} = A x_t + B u_t + w_t,\n$$\nwhere $A \\in \\mathbb{R}^{2 \\times 2}$, $B \\in \\mathbb{R}^{2 \\times 1}$, and $w_t$ is an exogenous disturbance vector. The measurement is corrupted by adversarial sensor noise $\\delta_t$ so that\n$$\ny_t = x_t + \\delta_t.\n$$\nThe control input is generated by a feedforward Artificial Neural Network (ANN) with a single hidden layer and Rectified Linear Unit (ReLU) activation, which maps $y_t$ to $u_t = \\pi(y_t)$. The adversary chooses $\\delta_t$ within an elementwise interval budget and the environment injects $w_t$ within an elementwise interval budget. We seek a certified safety guarantee by over-approximating the reachable sets under these adversarial choices.\n\nFundamental basis:\n- The set-propagation of an affine map $z = W a + b$, where $a$ lies in an elementwise interval $[l,u]$, is bounded by the following monotonicity-based enclosure. Let $W^+ = \\max(W,0)$ and $W^- = \\min(W,0)$ be the elementwise nonnegative and nonpositive parts of $W$. Then the image interval $[l_z, u_z]$ is\n$$\nl_z = W^+ l + W^- u + b, \\quad u_z = W^+ u + W^- l + b.\n$$\n- The ReLU operation $\\mathrm{ReLU}(z) = \\max(0,z)$ is monotone elementwise, so if $z \\in [l,u]$ elementwise, then $\\mathrm{ReLU}(z) \\in [\\max(0,l), \\max(0,u)]$ elementwise.\n- The Minkowski sum of intervals satisfies $[l_1,u_1] + [l_2,u_2] = [l_1 + l_2, u_1 + u_2]$ elementwise.\n\nController architecture and parameters:\n- The hidden layer has $4$ units, with weights $W_1 \\in \\mathbb{R}^{4 \\times 2}$ and bias $b_1 \\in \\mathbb{R}^{4}$ given by\n$$\nW_1 = \\begin{bmatrix}\n1  0\\\\\n-1  0\\\\\n0  1\\\\\n0  -1\n\\end{bmatrix}, \\quad b_1 = \\begin{bmatrix} 0\\\\ 0\\\\ 0\\\\ 0 \\end{bmatrix}.\n$$\n- The output layer has weights $W_2 \\in \\mathbb{R}^{1 \\times 4}$ and bias $b_2 \\in \\mathbb{R}$ given by\n$$\nW_2 = \\begin{bmatrix} -1  1  -0.5  0.5 \\end{bmatrix}, \\quad b_2 = 0.\n$$\n- The activation is $\\mathrm{ReLU}$ between the layers, so for any input $y \\in \\mathbb{R}^2$,\n$$\nu = \\pi(y) = W_2 \\, \\mathrm{ReLU}(W_1 y + b_1) + b_2.\n$$\nThis network implements a piecewise-linear approximation of $u \\approx -x_1 - 0.5 x_2$.\n\nPlant model:\n- The plant matrices correspond to a discretized double integrator with sampling period $h = 0.1$,\n$$\nA = \\begin{bmatrix}\n1  0.1\\\\\n0  1\n\\end{bmatrix}, \\quad\nB = \\begin{bmatrix}\n0.005\\\\\n0.1\n\\end{bmatrix}.\n$$\n\nAdversarial input and disturbance sets:\n- The adversary can perturb each component of the observation within an elementwise bound $\\varepsilon \\ge 0$, so that $\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$ for all $t$.\n- The disturbance lies in an elementwise interval $w_t \\in [-\\bar{w}, \\bar{w}]^2$ for all $t$, where $\\bar{w} \\ge 0$ is a given scalar bound applied to both state components.\n\nInitial set:\n- The initial states lie in a box $x_0 \\in [\\underline{x}_0, \\overline{x}_0]$ with\n$$\n\\underline{x}_0 = \\begin{bmatrix} 0.045\\\\ -0.005 \\end{bmatrix}, \\quad\n\\overline{x}_0 = \\begin{bmatrix} 0.055\\\\ 0.005 \\end{bmatrix}.\n$$\n\nSafety specification:\n- The safety constraint requires that the position component $x_{t,1}$ satisfy $|x_{t,1}| \\le p_{\\max}$ for all times $t \\in \\{0,1,\\dots,T\\}$, that is, the polyhedral set\n$$\n\\mathcal{S}(p_{\\max}) = \\{ x \\in \\mathbb{R}^2 : C x \\le d \\}, \\quad\nC = \\begin{bmatrix} 1  0\\\\ -1  0 \\end{bmatrix}, \\quad\nd = \\begin{bmatrix} p_{\\max}\\\\ p_{\\max} \\end{bmatrix}.\n$$\n\nCertified safety problem:\n- Using only the fundamental facts stated above and the provided parameters, over-approximate the reachable state intervals $[ \\underline{x}_t, \\overline{x}_t ]$ recursively for $t = 0,1,\\dots,T$ by:\n    - Computing the observation interval $[ \\underline{y}_t, \\overline{y}_t ] = [ \\underline{x}_t - \\varepsilon \\mathbf{1}, \\overline{x}_t + \\varepsilon \\mathbf{1} ]$.\n    - Propagating $[ \\underline{y}_t, \\overline{y}_t ]$ through the ANN using interval bounds to obtain a control interval $[ \\underline{u}_t, \\overline{u}_t ]$.\n    - Propagating $[ \\underline{x}_t, \\overline{x}_t ]$ and $[ \\underline{u}_t, \\overline{u}_t ]$ through the plant dynamics with interval arithmetic and adding the disturbance interval $[-\\bar{w}, \\bar{w}]^2$ to obtain $[ \\underline{x}_{t+1}, \\overline{x}_{t+1} ]$.\n- A test for certified safety holds if and only if, for all $t \\in \\{0,1,\\dots,T\\}$, the worst-case value of each safety inequality is nonpositive, that is, the upper bounds of $C x_t - d$ over the interval $[ \\underline{x}_t, \\overline{x}_t ]$ are elementwise $\\le 0$.\n\nTest suite:\nFor each of the following parameter tuples $(\\varepsilon, p_{\\max}, T, \\bar{w})$, determine a boolean indicating whether the safety constraint is certified to hold for all admissible adversarial sensor noises and disturbances over the entire horizon $t \\in \\{0,1,\\dots,T\\}$.\n- Case $1$: $\\varepsilon = 0.01$, $p_{\\max} = 0.2$, $T = 20$, $\\bar{w} = 0.0005$.\n- Case $2$: $\\varepsilon = 0.05$, $p_{\\max} = 0.08$, $T = 30$, $\\bar{w} = 0.0005$.\n- Case $3$: $\\varepsilon = 0.0$, $p_{\\max} = 0.06$, $T = 10$, $\\bar{w} = 0.0$.\n- Case $4$: $\\varepsilon = 0.02$, $p_{\\max} = 0.1$, $T = 50$, $\\bar{w} = 0.0002$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the cases in the order above as a comma-separated list of Python boolean literals enclosed in square brackets, for example, $[ \\mathrm{True}, \\mathrm{False}, \\mathrm{True}, \\mathrm{True} ]$.\n- No units are required because all quantities are treated as dimensionless in this problem.",
            "solution": "The problem requires us to determine the certified safety of a control system by computing interval over-approximations of the reachable state sets. We will implement the specified recursive algorithm. Let the state interval at time $t$ be $[\\underline{x}_t, \\overline{x}_t]$. The goal is to compute the interval for the next state, $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$, and verify safety at each step.\n\n**1. Safety Verification**\nAt each discrete time step $t \\in \\{0, 1, \\dots, T\\}$, we must verify that the computed state interval $[\\underline{x}_t, \\overline{x}_t]$ is entirely contained within the safe set $\\mathcal{S}(p_{\\max})$. The safety condition is $|x_{t,1}| \\le p_{\\max}$, which translates to two inequalities: $x_{t,1} \\le p_{\\max}$ and $-x_{t,1} \\le p_{\\max}$. To check if these hold for the entire interval, we must check them for the worst-case values. This requires:\n- $\\max(x_{t,1}) = \\overline{x}_{t,1} \\le p_{\\max}$\n- $\\max(-x_{t,1}) = -\\underline{x}_{t,1} \\le p_{\\max}$, which is equivalent to $\\underline{x}_{t,1} \\ge -p_{\\max}$\nIf both conditions are met, the system is safe at time $t$. The overall system is certified safe if this holds for all $t$ from $0$ to $T$.\n\n**2. Reachable Set Propagation (from $t$ to $t+1$)**\n\n**Step 2.1: Observation Interval**\nThe measurement $y_t = x_t + \\delta_t$ is affected by an adversarial sensor attack $\\delta_t \\in [-\\varepsilon, \\varepsilon]^2$. Given the state interval $[\\underline{x}_t, \\overline{x}_t]$, the interval for the observation $y_t$ is found by the Minkowski sum of the state interval and the noise interval $[-\\varepsilon \\mathbf{1}, \\varepsilon \\mathbf{1}]$, where $\\mathbf{1}$ is a vector of ones.\n$$ \\underline{y}_t = \\underline{x}_t - \\varepsilon \\mathbf{1} $$\n$$ \\overline{y}_t = \\overline{x}_t + \\varepsilon \\mathbf{1} $$\n\n**Step 2.2: Control Input Interval**\nThe control input $u_t$ is determined by propagating the observation interval $[\\underline{y}_t, \\overline{y}_t]$ through the neural network controller $u_t = W_2 \\, \\mathrm{ReLU}(W_1 y_t + b_1) + b_2$.\n\n- **First Affine Transformation**: Let $z_{t,1} = W_1 y_t + b_1$. The interval for $z_{t,1}$ is $[\\underline{z}_{t,1}, \\overline{z}_{t,1}]$, computed using the specified monotonicity-based enclosure rule:\n  $$ \\underline{z}_{t,1} = W_1^+ \\underline{y}_t + W_1^- \\overline{y}_t + b_1 $$\n  $$ \\overline{z}_{t,1} = W_1^+ \\overline{y}_t + W_1^- \\underline{y}_t + b_1 $$\n  where $W_1^+ = \\max(W_1, 0)$ and $W_1^- = \\min(W_1, 0)$ are the element-wise positive and negative parts of $W_1$.\n\n- **ReLU Activation**: Let $a_{t,1} = \\mathrm{ReLU}(z_{t,1})$. The interval for the activation output, $[\\underline{a}_{t,1}, \\overline{a}_{t,1}]$, is found by applying ReLU to the bounds of its input interval:\n  $$ \\underline{a}_{t,1} = \\mathrm{ReLU}(\\underline{z}_{t,1}) = \\max(0, \\underline{z}_{t,1}) $$\n  $$ \\overline{a}_{t,1} = \\mathrm{ReLU}(\\overline{z}_{t,1}) = \\max(0, \\overline{z}_{t,1}) $$\n\n- **Second Affine Transformation (Output)**: The final control input is $u_t = W_2 a_{t,1} + b_2$. Its interval $[\\underline{u}_t, \\overline{u}_t]$ is computed similarly:\n  $$ \\underline{u}_t = W_2^+ \\underline{a}_{t,1} + W_2^- \\overline{a}_{t,1} + b_2 $$\n  $$ \\overline{u}_t = W_2^+ \\overline{a}_{t,1} + W_2^- \\underline{a}_{t,1} + b_2 $$\n\n**Step 2.3: Next State Interval**\nThe next state $x_{t+1} = A x_t + B u_t + w_t$ is a sum of three terms, each lying in an interval. The resulting interval for $x_{t+1}$ is the Minkowski sum of the intervals for each term.\n\n- **Interval for $A x_t$**: Using the affine propagation rule with input $x_t \\in [\\underline{x}_t, \\overline{x}_t]$:\n  $$ [\\underline{(Ax_t)}, \\overline{(Ax_t)}] = [A^+ \\underline{x}_t + A^- \\overline{x}_t, A^+ \\overline{x}_t + A^- \\underline{x}_t] $$\n- **Interval for $B u_t$**: Using the affine propagation rule with input $u_t \\in [\\underline{u}_t, \\overline{u}_t]$:\n  $$ [\\underline{(Bu_t)}, \\overline{(Bu_t)}] = [B^+ \\underline{u}_t + B^- \\overline{u}_t, B^+ \\overline{u}_t + B^- \\underline{u}_t] $$\n- **Interval for $w_t$**: This is given as $[-\\bar{w}\\mathbf{1}, \\bar{w}\\mathbf{1}]$.\n\nSumming these interval bounds gives the next state interval $[\\underline{x}_{t+1}, \\overline{x}_{t+1}]$:\n$$ \\underline{x}_{t+1} = (A^+ \\underline{x}_t + A^- \\overline{x}_t) + (B^+ \\underline{u}_t + B^- \\overline{u}_t) - \\bar{w}\\mathbf{1} $$\n$$ \\overline{x}_{t+1} = (A^+ \\overline{x}_t + A^- \\underline{x}_t) + (B^+ \\overline{u}_t + B^- \\underline{u}_t) + \\bar{w}\\mathbf{1} $$\n\nSince all elements of the given matrices $A$ and $B$ are non-negative, $A^+=A$, $A^-=0$, $B^+=B$, and $B^-=0$. The propagation rule simplifies to:\n$$ \\underline{x}_{t+1} = A \\underline{x}_t + B \\underline{u}_t - \\bar{w}\\mathbf{1} $$\n$$ \\overline{x}_{t+1} = A \\overline{x}_t + B \\overline{u}_t + \\bar{w}\\mathbf{1} $$\nThis complete recursive procedure is implemented for each test case to determine its certified safety status.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the certified safety problem for the four test cases specified.\n    \"\"\"\n    test_cases = [\n        # (epsilon, p_max, T, w_bar)\n        (0.01, 0.2, 20, 0.0005),\n        (0.05, 0.08, 30, 0.0005),\n        (0.0, 0.06, 10, 0.0),\n        (0.02, 0.1, 50, 0.0002),\n    ]\n\n    results = []\n    for case in test_cases:\n        is_safe = check_safety_certification(case)\n        results.append(is_safe)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef check_safety_certification(params):\n    \"\"\"\n    Performs reachability analysis for a given set of parameters to certify safety.\n\n    Args:\n        params (tuple): A tuple containing (epsilon, p_max, T, w_bar).\n\n    Returns:\n        bool: True if the system is certified safe, False otherwise.\n    \"\"\"\n    eps, p_max, T, w_bar = params\n\n    # --- System and Controller Parameters ---\n    # Using column vectors (shape N,1) for consistency in matrix operations.\n    \n    # Plant model\n    A = np.array([[1.0, 0.1], [0.0, 1.0]], dtype=float)\n    B = np.array([[0.005], [0.1]], dtype=float)\n\n    # Controller ANN parameters\n    W1 = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=float)\n    b1 = np.zeros((4, 1), dtype=float)\n    W2 = np.array([[-1, 1, -0.5, 0.5]], dtype=float)\n    b2 = np.array([[0.0]], dtype=float)\n\n    # Initial state set\n    x0_lower = np.array([[0.045], [-0.005]], dtype=float)\n    x0_upper = np.array([[0.055], [0.005]], dtype=float)\n\n    # Pre-compute positive and negative parts of weight matrices for propagation\n    W1_pos = np.maximum(W1, 0)\n    W1_neg = np.minimum(W1, 0)\n    W2_pos = np.maximum(W2, 0)\n    W2_neg = np.minimum(W2, 0)\n    \n    # Since A and B are non-negative, the general formula simplifies,\n    # but we implement the general form for correctness.\n    A_pos = np.maximum(A, 0)\n    A_neg = np.minimum(A, 0)\n    B_pos = np.maximum(B, 0)\n    B_neg = np.minimum(B, 0)\n\n    # Initialize current state interval\n    x_lower = x0_lower\n    x_upper = x0_upper\n\n    # Constant interval vectors for noise and disturbance\n    eps_vec = np.full((2, 1), eps)\n    w_bar_vec = np.full((2, 1), w_bar)\n\n    # --- Main Reachability Loop ---\n    for t in range(T + 1):\n        # 1. Safety Verification\n        # Check if the current reachable set violates the safety constraints.\n        # Condition: -p_max = x_t,1 = p_max\n        if x_upper[0, 0]  p_max or x_lower[0, 0]  -p_max:\n            return False  # Safety violated\n\n        # If it's the last time step, no need to compute the next state.\n        if t == T:\n            break\n\n        # 2. Reachable Set Propagation\n        \n        # 2.1. Observation Interval Calculation\n        y_lower = x_lower - eps_vec\n        y_upper = x_upper + eps_vec\n\n        # 2.2. Control Input Interval Calculation (propagate through ANN)\n        # First affine layer\n        z1_lower = W1_pos @ y_lower + W1_neg @ y_upper + b1\n        z1_upper = W1_pos @ y_upper + W1_neg @ y_lower + b1\n\n        # ReLU activation\n        a1_lower = np.maximum(0, z1_lower)\n        a1_upper = np.maximum(0, z1_upper)\n\n        # Output layer\n        u_lower = W2_pos @ a1_lower + W2_neg @ a1_upper + b2\n        u_upper = W2_pos @ a1_upper + W2_neg @ a1_lower + b2\n        \n        # 2.3. Next State Interval Calculation\n        # Contribution from Ax_t\n        ax_lower = A_pos @ x_lower + A_neg @ x_upper\n        ax_upper = A_pos @ x_upper + A_neg @ x_lower\n\n        # Contribution from Bu_t\n        bu_lower = B_pos @ u_lower + B_neg @ u_upper\n        bu_upper = B_pos @ u_upper + B_neg @ u_lower\n        \n        # Minkowski sum for the next state interval\n        x_next_lower = ax_lower + bu_lower - w_bar_vec\n        x_next_upper = ax_upper + bu_upper + w_bar_vec\n\n        # Update state for the next iteration\n        x_lower = x_next_lower\n        x_upper = x_next_upper\n\n    # If the loop completes without any safety violations, the property is certified.\n    return True\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}