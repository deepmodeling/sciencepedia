## 引言
随着信息物理系统（Cyber-Physical Systems, CPS）与数字孪生（Digital Twins）日益复杂，其对海量数据的处理与分析需求呈指数级增长。为了利用强大的计算资源，系统运营方常常将状态估计、预测性维护等计算密集型任务[外包](@entry_id:262441)给云平台。然而，这种[外包](@entry_id:262441)模式引入了严峻的安全与隐私挑战：如何在不可信的云环境中保护数据的机密性，并确保计算结果的完整性？传统的传输层加密仅能保护传输中的数据，一旦数据在云端解密进行计算，其隐私便暴露无遗，这构成了亟待解决的知识鸿沟。

本文旨在系统性地介绍两种能够应对此挑战的先进密码学技术：**[同态加密](@entry_id:1126158)（Homomorphic Encryption, HE）**与**[零知识证明](@entry_id:275593)（Zero-Knowledge Proofs, ZKP）**。读者将学习到，[同态加密](@entry_id:1126158)如何实现在加密数据上直接进行计算，从而保护“使用中数据”的机密性；而[零知识证明](@entry_id:275593)又如何提供一种机制，让云端能够证明其计算的正确性，同时不泄露任何额外信息。通过深入理解这两种技术的协同作用，我们将能够构建兼具隐私、安全与效率的新一代可信信息物理系统。

为实现这一目标，本文将分为三个核心章节展开。首先，在“**原理与机制**”一章中，我们将深入剖析[同态加密](@entry_id:1126158)的噪声管理机制与[零知识证明](@entry_id:275593)的形式化定义及通用构造方法。接着，在“**应用与交叉学科联系**”一章，我们将探索这些技术在隐私保护控制、可验证[外包](@entry_id:262441)计算以及[安全联邦学习](@entry_id:1131369)等具体场景中的应用范式。最后，“**动手实践**”部分将通过一系列精心设计的问题，帮助读者巩固理论知识并量化实际部署中的开销。这篇文章将为读者提供一个从理论基础到应用实践的完整知识框架。

## 原理与机制

### 在信息物理系统中的安全计算需求

信息物理系统（Cyber-Physical Systems, CPS）及其数字孪生（Digital Twins）的运行，依赖于物理世界与数字世界之间持续、双向的数据流。例如，一个部署在电网中的[数字孪生](@entry_id:171650)，需要持续同步物理资产的状态，进行状态估计、[预测性维护](@entry_id:167809)和控制[策略优化](@entry_id:635350)。当这些计算任务，特别是计算密集型部分，被[外包](@entry_id:262441)给不受信任的云平台时，一系列严峻的安全挑战便随之而来。我们必须在利用云端强大计算能力的同时，满足机密性、完整性和可用性（Confidentiality, Integrity, and Availability, CIA）这三大安全目标 。

**机密性 (Confidentiality)** 要求敏感数据，如传感器读数 $x$ 和系统模型参数 $\theta$，在存储、传输和**使用**过程中均不被泄露。传统的传输层安全协议（如TLS）仅能保护数据在传输过程中的安全，一旦数据到达云服务器并解密进行计算，其机密性便荡然无存。面对“诚实但好奇”（honest-but-curious）的云服务提供商——他们会遵循协议执行计算，但可能试图从处理的数据中学习秘密——我们需要一种能保护“使用中数据”的技术。**[同态加密](@entry_id:1126158) (Homomorphic Encryption, HE)** 正是为此而生。它允许在密文上直接进行计算，从而得到结果的密文，整个过程云端无需访问明文数据。

**完整性 (Integrity)** 要求计算结果必须是真实、准确、未经篡改的。云服务提供商的服务等级协议（SLA）是一种商业承诺，而非技术保障。一个强大的系统必须能抵御无意的计算错误（如硬件故障）或恶意的计算欺诈。**[零知识证明](@entry_id:275593) (Zero-Knowledge Proofs, ZKP)** 为[可验证计算](@entry_id:267455)（verifiable computation）提供了强有力的解决方案。云端作为证明者（Prover），可以生成一个[密码学](@entry_id:139166)证明，证实其返回的输出确实是基于给定的输入和公开的函数正确计算得出的，而验证者（Verifier，即CPS运营方）可以在不重复计算、不获取任何额外秘密信息的情况下高效地验证该证明。

**可用性 (Availability)** 在CPS的背景下，通常表现为严格的实时性约束。例如，一个控制回路的周期可能只有几十毫秒。然而，[同态加密](@entry_id:1126158)和[零知识证明](@entry_id:275593)等高级[密码学](@entry_id:139166)工具会带来显著的计算和通信开销，这直接威胁到系统的可用性。因此，在设计安全CPS架构时，必须仔细权衡安全性与性能，确保总延迟在时间预算之内 。

为了更严谨地刻画威胁，我们可以引入一个增强的**Dolev-Yao敌手模型**。该模型假定敌手完[全控制](@entry_id:275827)网络，可以窃听、注入、重放和修改消息。在此基础上，我们进一步赋予敌手物理篡改能力，允许其在有限时间内干扰传感器或执行器，并引入时钟偏差。在此模型下，端到端的安全机制变得至关重要。仅仅保护通信信道是不够的；我们需要从数据源头（如传感器的[可信执行环境](@entry_id:756203)TEE）到数据最终消费端（数字孪生内部）的全程保护。这套机制必须确保数据的机密性、真实性、新鲜度（freshness）以及计算的可验证性 。[同态加密](@entry_id:1126158)和[零知识证明](@entry_id:275593)的结合，正是构建这样一个端到端安全框架的核心支柱。

### [同态加密](@entry_id:1126158)：原理与基础

[同态加密](@entry_id:1126158)是一种允许对加密数据执行计算的密码学形式。一个[同态加密](@entry_id:1126158)方案通常由四个算法组成：[密钥生成](@entry_id:1126905) $\mathsf{KeyGen}$、加密 $\mathsf{Enc}$、解密 $\mathsf{Dec}$ 和同态评估 $\mathsf{Eval}$。其核心性质是，对于一个受支持的函数类别 $\mathcal{F}$ 中的任意函数 $f$，以及任意明文 $m_1, \dots, m_k$，以下关系成立：
$$ \mathsf{Dec}(\mathsf{sk}, \mathsf{Eval}(\mathsf{pk}, f, \mathsf{Enc}(\mathsf{pk}, m_1), \dots, \mathsf{Enc}(\mathsf{pk}, m_k))) = f(m_1, \dots, m_k) $$
其中 $\mathsf{pk}$ 是公钥，$\mathsf{sk}$ 是私钥。

#### 同态能力的谱系

根据其支持的[计算复杂性](@entry_id:204275)，[同态加密](@entry_id:1126158)方案可以分为几类，形成一个能力谱系 。

*   **部分[同态加密](@entry_id:1126158) (Partially Homomorphic Encryption, PHE)**：支持对密文无限次执行**一种**运算（通常是加法或乘法），但不能同时支持两种。例如，Paillier 密码系统是加法同态的，而未填充的 RSA 是乘法同态的。

*   **[有限级数](@entry_id:204312)[同态加密](@entry_id:1126158) (Somewhat Homomorphic Encryption, SHE)**：同时支持加法和乘法运算，但所能执行的乘法运算的次数（即计算电路的**乘法深度**）是有限的。这是因为每次运算，尤其是乘法，都会导致密文中“噪声”的增长，当噪声超过某个阈值时，解密将失败。

*   **分级[同态加密](@entry_id:1126158) (Leveled Homomorphic Encryption, LHE)**：这是一种更精细化的SHE。在[密钥生成](@entry_id:1126905)阶段，可以预先设定一个最大乘法深度 $L$。该方案保证能够正确评估任何深度不超过 $L$ 的电路，而无需执行昂贵的“噪声重置”操作。其密钥和密文的大小是安全参数 $\lambda$ 和深度 $L$ 的多项式函数。

*   **全[同态加密](@entry_id:1126158) (Fully Homomorphic Encryption, FHE)**：能够评估任意深度（理论上无限）的计算电路。这是通过一种名为**自举 (Bootstrapping)** 的“噪声重置”技术实现的。当密文噪声增长到接近临界值时，自举过程会同态地执行解密电路，从而在不泄露明文的情况下生成一个包含相同明文但噪声很低的新密文。

#### 安全性基石：环上容错学习问题 (RLWE)

现代大多数高效的[同态加密](@entry_id:1126158)方案，其安全性都基于**格[密码学](@entry_id:139166) (Lattice-based cryptography)** 中的困难问题，其中最核心的是**[容错](@entry_id:142190)学习 (Learning With Errors, LWE)** 问题及其代数变体——**环上容错学习 (Ring Learning With Errors, RLWE)** 问题 。

在一个典型的RLWE问题设定中，我们使用一个[代数结构](@entry_id:137052)，即**分圆环 (cyclotomic ring)** $R = \mathbb{Z}[x]/(x^n+1)$，其中 $n$通常是2的幂。所有运算都在一个模 $q$ 的环 $R_q = R/qR = \mathbb{Z}_q[x]/(x^n+1)$ 中进行。

**RLWE问题**的定义如下：

*   **搜索RLWE问题 (Search-RLWE)**：给定一个秘密 $s \in R_q$ 和一个窄的离散[高斯噪声](@entry_id:260752)分布 $D_{R, \sigma}$。敌手可以获得一系列样本 $(a_i, b_i) \in R_q \times R_q$，其中每个 $a_i$ 是从 $R_q$ 中均匀随机抽样的，而 $b_i = a_i s + e_i \pmod q$，其中 $e_i$ 是从 $D_{R, \sigma}$ 中独立抽样的噪声。搜索RLWE问题的目标是，根据这些样本恢复出秘密 $s$。

*   **判定RLWE问题 (Decision-RLWE)**：敌手的任务是区分两种分布：一种是如上所述生成的RLWE样本分布，另一种是 $R_q \times R_q$ 上的均匀随机分布。如果敌手无法以不可忽略的优势区分这两种分布，那么判定RLWE问题就被认为是困难的。

RLWE问题的困难性，即破解它所需的计算成本，由安全级别 $\lambda$ (通常表示为攻击成本的以2为底的对数) 来衡量。这个安全级别与参数 $(n, q, \sigma)$ 密切相关 ：

*   **环维度 $n$**：这是主要的安全性参数。已知的最强攻击（如[格基规约](@entry_id:1121367)算法）的复杂度随维度 $n$ 呈指数级增长。因此，增加 $n$ 会显著提高安全性。

*   **模数 $q$ 和噪声标准差 $\sigma$**：这两个参数共同决定了噪声的相对大小。关键在于**模数-噪声比** $q/\sigma$。当这个比值较大时（即噪声相对于模数很小），$b_i \approx a_i s$ 的近似关系更“干净”，问题变得更容易解决，安全性降低。反之，当 $q/\sigma$ 较小时（即噪声相对较大），问题变得更困难，安全性提高。然而，为了保证[同态加密](@entry_id:1126158)方案的正确解密，噪声必须保持在一定限度内，这限制了 $\sigma$ 不能无限大，而 $q$ 又需要足够大来容纳噪声的增长。因此，参数选择是在安全性、正确性和[计算效率](@entry_id:270255)之间进行的复杂权衡。

### [同态加密](@entry_id:1126158)：运行机制

理解[同态加密](@entry_id:1126158)的关键在于理解其核心挑战——**噪声管理**。

#### 核心挑战：噪声的产生与增长

在基于LWE/RLWE的方案中，噪声并非缺陷，而是安全性的根本来源。加密过程中有意引入一个小的随机噪声项 $e$，它能有效地掩盖秘密 $s$ 。以一个简化的BFV类方案为例，一个密文 $(c_0, c_1)$ 加密明文 $m$ 满足以下解密不变量：
$$ c_0 + c_1 s \equiv \Delta m + e \pmod{q} $$
其中 $\Delta$ 是一个缩放因子，用于将明文空间嵌入到密文空间中。这个小的噪声项 $e$ 在同态运算中会发生变化：

*   **同态加法**：两个密文 $(c_{1,0}, c_{1,1})$ 和 $(c_{2,0}, c_{2,1})$ 分别加密 $m_1$ 和 $m_2$，带有噪声 $e_1$ 和 $e_2$。它们的和是 $(c_{1,0}+c_{2,0}, c_{1,1}+c_{2,1})$。新密文的噪声是 $e_{\mathrm{add}} = e_1 + e_2$。如果 $e_1$ 和 $e_2$ 是独立的[中心化随机](@entry_id:918827)变量，那么新噪声的方差是两者方差之和，即 $\mathrm{Var}(e_{\mathrm{add}}) = \mathrm{Var}(e_1) + \mathrm{Var}(e_2)$。因此，加法会使噪声缓慢增长 。

*   **同态乘法**：乘法对噪声的影响要剧烈得多。两个密文的“内涵”相乘得到 $(\Delta m_1 + e_1)(\Delta m_2 + e_2) = \Delta^2 m_1 m_2 + \Delta(m_1 e_2 + m_2 e_1) + e_1 e_2$。新产生的噪声项 $e'_{\mathrm{mult}} = \Delta(m_1 e_2 + m_2 e_1) + e_1 e_2$ 包含三部分：两个交叉项和一个误差乘积项。其中交叉项 $m_1 e_2$ 和 $m_2 e_1$ 是噪声增长的主要来源，其幅度与明文 $m_i$ 的大小成正比。这导致噪声的**超线性增长**，极大地限制了可执行的乘法次数  。

#### 噪声控制技术

为了实现更深层次的计算，必须主动控制噪声的增长。

*   **重线性化 (Relinearization) 与密钥交换 (Key Switching)**：同态乘法不仅导致噪声爆炸，还会增加密文的维度。两个关于 $s$ 的线性函数相乘，会得到一个关于 $s$ 和 $s^2$ 的二次函数。这意味着密文从一个包含两个元素的向量 $(c_0, c_1)$ 变成一个包含三个元素的张量。为了将密文大小保持恒定，需要进行**重线性化**操作。该操作使用一个称为**评估密钥 (evaluation key)** 的公共辅助数据（本质上是 $s^2$ 在 $s$ 下的加密），将包含 $s^2$ 的项转换回等价的、仅含 $s$ 的[线性形式](@entry_id:276136)。这个过程会引入额外的噪声，但能将密文“压扁”回[标准尺](@entry_id:157855)寸。**密钥交换**是重线性化的一个推广，它允许将一个用私钥 $s$ 加密的密文，转换为一个用不同私钥 $s'$ 加密的、包含相同明文的新密文。这在多方参与的CPS场景中非常有用，例如，边缘设备可以使用各自的密钥加密数据，然后由[数字孪生](@entry_id:171650)将所有密文切换到统一的主密钥下进行联合处理 。

*   **模数切换 (Modulus Switching)**：这是BGV等方案中使用的主要噪声控制技术。在计算过程中，通过将密文模数从一个较大的 $q$ 切换到一个较小的 $q'$，可以按比例（大约 $q'/q$）缩小噪声的绝对大小，从而保持噪声与模数的相对比例稳定。这为后续的计算腾出了“噪声空间”。

*   **自举 (Bootstrapping)**：这是实现全[同态加密](@entry_id:1126158)（FHE）的终极武器。当密文的噪声即将[溢出](@entry_id:172355)时，自举程序会同态地（即在加密状态下）运行解密电路。它使用一个加密的私钥作为输入，对这个“脏”密文进行“解密”，从而得到一个包含同样明文但噪声被重置为初始水平的“干净”新密文。这个过程的开销非常大，但它使得理论上可以进行无限深度的计算 。

#### 具体方案示例：BFV

Brakerski/Fan-Vercauteren (BFV) 方案是一个流行的[同态加密](@entry_id:1126158)方案，它为整数或多项式算术设计。其核心机制直观地体现了上述原理 。

*   **加密**：明文 $m \in R_t = R/tR$ 首先被缩放因子 $\Delta = \lfloor q/t \rfloor$ 放大，嵌入到 $R_q$ 中，即 $\Delta m$。这使得明文信息占据了系数的最高位。然后，它被一个小的RLWE噪声 $e$ 掩盖，最终形成一个密文 $(c_0, c_1)$，满足 $c_0 + c_1 s \equiv \Delta m + e \pmod{q}$。

*   **解密**：计算 $v = (c_0 + c_1 s) \pmod{q}$。只要总噪声 $e'$ 的[无穷范数](@entry_id:637586) $\lVert e' \rVert_\infty$ 小于 $\Delta/2$，噪声就不会侵占到明文的最高位。此时，通过移除缩放并四舍五入即可恢复明文：$m = \lfloor \frac{v}{\Delta} \rceil \pmod{t}$。

*   **噪声管理**：[BFV方案](@entry_id:1121532)主要依赖重线性化来处理乘法后的密文维度问题。它不像BGV方案那样在计算过程中频繁地切换密文或明文模数。在BFV中，明文模数 $t$ 在整个计算过程中是固定的。这种通过缩放因子 $\Delta$ 在明文和噪声之间划分“空间”的设计，与BGV方案通过多级模数链来管理噪声形成了鲜明对比 。

### [零知识证明](@entry_id:275593)：原理与基础

[零知识证明](@entry_id:275593)允许一方（证明者）向另一方（验证者）证明某个论断为真，而除了该论断为真这一事实外，不泄露任何其他信息。

#### [证明系统](@entry_id:156272)的形式化定义

一个[零知识证明](@entry_id:275593)系统是为某个语言 $L$ 设计的。这个语言 $L$ 中的每个元素 $x$ 都代表一个真实的论断。这些论断通常由一个**NP关系** $R$ 来定义，该关系包含成对的实例（instance）$x$ 和见证（witness）$w$。语言 $L$ 就是所有存在有效见证的实例的集合：$L = \{x \mid \exists w, (x,w) \in R\}$。

在CPS[可验证计算](@entry_id:267455)的场景中 ：
*   **实例 $x$** 是公开信息，包括公钥 $\mathsf{pk}$、密文 $c$、公开的函数 $f$ 和声称的输出 $y$。即 $x = (\mathsf{pk}, c, f, y)$。
*   **见证 $w$** 是秘密信息，包括原始明文 $m$ 和加密时使用的随机性 $r$。即 $w = (m, r)$。
*   **关系 $R$** 定义了论断的有效性：$(x, w) \in R$ 当且仅当 $c = \mathsf{Enc}_{\mathsf{pk}}(m;r)$ 且 $y = f(m)$。

一个[交互式证明系统](@entry_id:272672) $(P, V)$ 必须满足以下三个核心属性 ：

1.  **完备性 (Completeness)**：对于任何真实的论断（即 $x \in L$），一个诚实的证明者 $P$ 总能以压倒性的概率（通常是 $1 - \mu(n)$，其中 $\mu$ 是可忽略函数）说服一个诚实的验证者 $V$。

2.  **可靠性 (Soundness)**：对于任何虚假的论断（即 $x \notin L$），任何（计算能力有界的）恶意证明者 $P^*$ 最多只能以可忽略的概率 $\nu(n)$ 欺骗诚实的验证者 $V$。

3.  **零知识性 (Zero-Knowledge)**：对于任何真实的论断 $x \in L$，验证者 $V$（即使是恶意的 $V^*$）从交互中除了得知“$x$ 确实在 $L$ 中”之外，学不到任何其他信息。这通常通过**模拟器 (Simulator)** 的概念来形式化：存在一个高效的模拟器 $S$，它仅凭公开的实例 $x$ 就能生成一个与真实交互记录（即 $V^*$ 的“视图”）在计算上不可区分的“伪造”交互记录。既然无需秘密见证就能伪造交互记录，那么真实的交互过程也就没有泄露任何关于见证的知识。

#### 经典范例：Schnorr协议

Schnorr协议是一个经典的三阶段交互式协议，用于证明者知道某个公开值 $y$ 关于基底 $g$ 的[离散对数](@entry_id:266196) $x$（即 $y = g^x$），而无需透露 $x$ 本身。它是许多现代密码系统的基石 。

协议流程如下：
1.  **承诺 (Commitment)**：证明者 $P$ 选择一个随机数 $r$，计算承诺 $t = g^r$，并发送给验证者 $V$。
2.  **挑战 (Challenge)**：验证者 $V$ 选择一个随机挑战 $c$，并发送给 $P$。
3.  **回应 (Response)**：证明者 $P$ 计算回应 $s = r + cx \pmod q$（其中 $q$ 是[群的阶](@entry_id:137115)），并发送给 $V$。

验证者通过检查等式 $g^s = t \cdot y^c$ 是否成立来进行验证。

*   **属性**：该协议是**完备的**。它具有一种称为**特殊可靠性 (Special Soundness)** 的强可靠性形式：如果一个证明者能对同一个承诺 $t$ 回应两个不同的挑战 $c$ 和 $c'$，那么其秘密 $x$ 就可以被提取出来。此外，它具有**诚实验证者零知识性 (Honest-Verifier Zero-Knowledge, HVZK)**，因为一个模拟器可以通过先选定 $s$ 和 $c$ 再反向计算出 $t = g^s y^{-c}$ 的方式，生成无法与真实交互区分的记录。

*   **非交互化：Fiat-Shamir变换**：为了适应CPS中可能存在的[异步通信](@entry_id:173592)或需要离线验证的场景，可以使用**Fiat-Shamir变换**将Schnorr这样的交互式协议转换为非交互式的。证明者不再等待验证者的挑战，而是通过哈希承诺值来自己生成挑战：$c = H(t, \text{...})$。然后，证明者发布一个包含 $(t, s)$ 的证明。这种转换的安全性证明依赖于一个理想化的模型，即**随机预言机模型 (Random Oracle Model, ROM)**，该模型将[哈希函数](@entry_id:636237) $H$ 视为一个完美的随机函数 。

### [零知识证明](@entry_id:275593)：[通用计算](@entry_id:275847)机制

Schnorr协议等经典协议只能证明关于特定代数关系的知识。为了证明任意计算（如执行一个复杂的[机器学习模型](@entry_id:262335)或CPS控制律）的正确性，我们需要更通用的[零知识证明](@entry_id:275593)机制，例如**ZK-[SNARK](@entry_id:264394)s (Zero-Knowledge Succinct Non-Interactive Argument of Knowledge)**。

#### [通用计算](@entry_id:275847)的编译流程

将一个[通用计算](@entry_id:275847)程序转化为[SNARK](@entry_id:264394)可以处理的形式，通常遵循一个编译流程 ：

1.  **计算到[算术电路](@entry_id:274364) (Arithmetic Circuit)**：首先，将高级计算程序（如用C++或Python编写的函数）“扁平化”为一个由加法和乘法门组成的[算术电路](@entry_id:274364)。电路的运算基于一个大的[有限域](@entry_id:142106) $\mathbb{F}_p$。非域内原生运算，如比较或[位运算](@entry_id:172125)，需要通过更复杂的电路（如位分解和范围约束）来模拟。

2.  **电路到R1CS (Rank-1 Constraint System)**：接下来，将[算术电路](@entry_id:274364)转化为一个等价的约束系统。**一阶[约束系统](@entry_id:164587) (R1CS)** 是最常用的格式之一。一个R1CS由一组约束组成，每个约束都形如：
    $$ (\langle \mathbf{L}_i, \mathbf{w} \rangle) \cdot (\langle \mathbf{R}_i, \mathbf{w} \rangle) = \langle \mathbf{O}_i, \mathbf{w} \rangle $$
    这里，$\mathbf{w}$ 是一个包含了所有计算变量的“见证向量”，包括公开输入、私有输入和所有电路中间门的输出值。向量 $\mathbf{L}_i, \mathbf{R}_i, \mathbf{O}_i$ 是由电路结构决定的常数向量。这个二次约束系统完美地捕捉了电路中每个门的操作。如果一个计算满足所有的R1CS约束，那么它就是正确的。

3.  **R1CS到QAP (Quadratic Arithmetic Program)**：R1CS虽然结构规整，但仍不便于[密码学](@entry_id:139166)处理。通过[多项式插值](@entry_id:145762)，可以将整个R1CS系统转化为一个关于多项式的等价问题，即**二次算术程序 (QAP)**。满足R1CS相当于证明某个由见证向量 $\mathbf{w}$ 构造的特定多项式 $P(x)$ 能被一个代表所有约束的“目标多项式” $t(x)$ 整除。

#### ZK-[SNARK](@entry_id:264394)s的实现

ZK-[SNARK](@entry_id:264394)s（如著名的Groth16协议）提供了一种高效的方式来证明和验证这种多项式[整除关系](@entry_id:148612) 。

*   **公共参考串 (Common Reference String, CRS)**：这类协议通常需要一个一次性的、可信的设置阶段来生成一个CRS。CRS包含了一系列经过加密的、与秘密值相关的参数。这个CRS对所有后续的证明和验证都是公开的。

*   **证明生成与验证**：证明者使用见证 $\mathbf{w}$ 和CRS来生成一个非常简短的（succinct）证明，其大小通常是恒定的，与原始计算的规模无关。验证者使用公开输入、CRS和这个简短的证明，通过执行几次**[双线性](@entry_id:146819)配对 (bilinear pairing)** 运算来检查证明的有效性。[双线性](@entry_id:146819)配对是一种特殊的映射，它允许在指数上进行乘法检查，从而能在加密状态下高效地验证QAP所要求的复杂多项式关系。验证过程也是**简洁的**，其计算量与原始计算规模无关。

*   **零知识性**：零知识性是通过在生成证明时引入随机性来实现的。证明者使用随机数来“致盲”证明元素，使得证明本身看起来像一个随机值，但仍然能够通过验证方程。

这些机制的结合，使得我们能够为在CPS中执行的、可能涉及[同态加密](@entry_id:1126158)数据的复杂计算，生成简洁、非交互式且零知识的[正确性证明](@entry_id:636428)。例如，可以生成一个ZKP来证明HE方案的评估密钥是根据某个秘密正确生成的，从而防止恶意评估密钥对系统造成的破坏，这进一步体现了HE和ZKP这两种技术的深刻协同作用 。