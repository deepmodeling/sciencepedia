{
    "hands_on_practices": [
        {
            "introduction": "功能安全标准（如 IEC 61508）要求对系统的安全性进行量化评估，这是构建安全案例的核心部分。本练习提供了一个具体的计算实例，旨在分析一个自动驾驶子系统的每小时危险失效概率 ($PFH$) 。通过这个练习，您将实践如何综合考虑硬件的基础失效率和不同的诊断机制（包括传统的硬件诊断和先进的数字孪生监控），以达到预设的安全完整性等级 (SIL) 或性能等级 (PL) 要求。这项实践有助于您深入理解诊断覆盖率等关键指标如何量化并直接影响整体系统安全论证的强度。",
            "id": "4239826",
            "problem": "信息物理系统 (CPS) 内的一个自主制动子系统正在根据国际电工委员会标准 IEC 61508 进行连续工作模式下的认证。认证目标是针对由三个串联组件（一个感知传感器 ($S$)、一个控制器 ($C$) 和一个执行器 ($A$)）构成的危险路径的每小时危险失效概率 (PFH)，记为 $\\lambda_{\\mathrm{PFH}}$。每个组件 $i \\in \\{S,C,A\\}$ 都有一个基本危险失效率 $\\lambda_{D,i}$ 和一个板载实现的嵌入式硬件诊断，其覆盖率为 $c_{h,i}$。增加了一个基于数字孪生的在线监视器，它对所有三个组件应用一个统一的可调覆盖率参数 $c_{dt} \\in [0,1]$，但其对组件 $i$ 的有效性受到一个有效性系数 $e_i \\in [0,1]$ 的限制，该系数用于量化组件 $i$ 中可被数字孪生模型和分析检测到的危险失效模式的比例。假设检测机制（硬件诊断和数字孪生监视器）独立作用于每个危险失效模式，并且一旦检测到失效，系统会立即转换到安全状态，因此检测到的危险失效不会对 $\\lambda_{\\mathrm{PFH}}$ 产生影响。假设失效率恒定（齐次泊松过程）、失效罕见，并且危险路径为串联结构，因此子系统级的 $\\lambda_{\\mathrm{PFH}}$ 是各组件级危险未检测失效率之和。\n\n子系统数据如下：\n- 传感器：$\\lambda_{D,S} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,S} = 0.55$，$e_{S} = 0.90$。\n- 控制器：$\\lambda_{D,C} = 1.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,C} = 0.65$，$e_{C} = 0.50$。\n- 执行器：$\\lambda_{D,A} = 2.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,A} = 0.40$，$e_{A} = 0.80$。\n\n认证目标为 $\\lambda_{\\mathrm{PFH,target}} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$。根据上述建模假设，计算满足 $\\lambda_{\\mathrm{PFH,target}}$ 所需的最小数字孪生覆盖率 $c_{dt}$。将最终答案表示为无单位分数，并四舍五入至四位有效数字。",
            "solution": "对用户提供的问题进行有效性评估。\n\n### 步骤 1：提取已知条件\n- **系统组件**：传感器 ($S$)、控制器 ($C$)、执行器 ($A$)，构成串联危险路径。\n- **认证目标**：每小时危险失效概率，$\\lambda_{\\mathrm{PFH,target}} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$。\n- **组件数据 ($i \\in \\{S,C,A\\}$)**：\n  - 基本危险失效率：$\\lambda_{D,i}$。\n  - 硬件诊断覆盖率：$c_{h,i}$。\n  - 数字孪生有效性系数：$e_i$。\n- **数字孪生 (DT) 监视器**：\n  - 统一可调覆盖率：$c_{dt} \\in [0,1]$。\n- **具体数据值**：\n  - 传感器 ($S$)：$\\lambda_{D,S} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,S} = 0.55$，$e_{S} = 0.90$。\n  - 控制器 ($C$)：$\\lambda_{D,C} = 1.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,C} = 0.65$，$e_{C} = 0.50$。\n  - 执行器 ($A$)：$\\lambda_{D,A} = 2.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,A} = 0.40$，$e_{A} = 0.80$。\n- **假设**：\n  - 硬件诊断和数字孪生监视器作为独立的检测机制。\n  - 检测到的危险失效得到安全处理，不会对 $\\lambda_{\\mathrm{PFH}}$ 产生影响。\n  - 子系统 $\\lambda_{\\mathrm{PFH}}$ 是各组件级危险未检测失效率 ($\\lambda_{\\mathrm{DU},i}$) 之和。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题很好地基于可靠性工程和功能安全的原则，这些原则由 IEC 61508 等标准定义。危险失效率、诊断覆盖率以及串联系统 PFH 的计算等概念都是标准方法。\n- **适定性**：该问题提供了所有必要的数据，并定义了构建和求解未知变量 $c_{dt}$ 所需的所有关系。预计存在唯一解。\n- **客观性**：该问题使用精确、量化且明确的语言进行陈述。\n- **结论**：该问题在科学合理性、完整性、一致性或客观性方面没有任何缺陷。它是信息物理系统安全领域中一个可形式化且相关的问题。\n\n### 步骤 3：结论与行动\n此问题**有效**。将推导解答。\n\n该问题要求计算为达到目标子系统每小时危险失效概率 $\\lambda_{\\mathrm{PFH,target}}$ 所需的最小数字孪生覆盖率 $c_{dt}$。\n\n根据问题陈述，子系统的 $\\lambda_{\\mathrm{PFH}}$ 是其各组件的危险未检测失效率 $\\lambda_{\\mathrm{DU},i}$ 之和。\n$$ \\lambda_{\\mathrm{PFH}} = \\sum_{i \\in \\{S,C,A\\}} \\lambda_{\\mathrm{DU},i} $$\n一个组件 $i$ 的危险失效仅在未被板载硬件诊断或数字孪生监视器检测到的情况下，才会对 $\\lambda_{\\mathrm{DU},i}$ 产生影响。问题陈述指出这两种检测机制是独立的。\n\n对于给定的组件 $i$，危险失效*未*被硬件诊断检测到的概率是 $(1 - c_{h,i})$。\n数字孪生监视器有一个覆盖率参数 $c_{dt}$，但其对组件 $i$ 的适用性受到有效性系数 $e_i$ 的限制。因此，数字孪生检测到组件 $i$ 上随机危险失效的有效概率是乘积 $e_i c_{dt}$。因此，危险失效*未*被数字孪生监视器检测到的概率是 $(1 - e_i c_{dt})$。\n\n由于两种检测机制的独立性，危险失效被*两种*机制都漏检的概率是它们各自未检测概率的乘积。\n$$ P(\\text{undetected}) = (1 - c_{h,i}) (1 - e_i c_{dt}) $$\n组件 $i$ 的危险未检测失效率 $\\lambda_{\\mathrm{DU},i}$ 是基本危险失效率 $\\lambda_{D,i}$ 乘以该未检测概率。\n$$ \\lambda_{\\mathrm{DU},i} = \\lambda_{D,i} (1 - c_{h,i})(1 - e_i c_{dt}) $$\n总系统 $\\lambda_{\\mathrm{PFH}}$ 是所有三个组件的总和：\n$$ \\lambda_{\\mathrm{PFH}} = \\sum_{i \\in \\{S,C,A\\}} \\lambda_{D,i} (1 - c_{h,i})(1 - e_i c_{dt}) $$\n为了找到所需的最小 $c_{dt}$，我们将 $\\lambda_{\\mathrm{PFH}}$ 设为目标值 $\\lambda_{\\mathrm{PFH,target}}$。\n$$ \\lambda_{\\mathrm{PFH,target}} = \\sum_{i \\in \\{S,C,A\\}} \\lambda_{D,i} (1 - c_{h,i})(1 - e_i c_{dt}) $$\n我们可以展开并重新整理此方程以求解 $c_{dt}$。\n$$ \\lambda_{\\mathrm{PFH,target}} = \\sum_{i} \\left[ \\lambda_{D,i}(1 - c_{h,i}) - c_{dt} \\cdot e_i \\lambda_{D,i}(1 - c_{h,i}) \\right] $$\n$$ \\lambda_{\\mathrm{PFH,target}} = \\sum_{i} \\lambda_{D,i}(1 - c_{h,i}) - c_{dt} \\sum_{i} e_i \\lambda_{D,i}(1 - c_{h,i}) $$\n重新整理以分离出含 $c_{dt}$ 的项：\n$$ c_{dt} \\sum_{i} e_i \\lambda_{D,i}(1 - c_{h,i}) = \\sum_{i} \\lambda_{D,i}(1 - c_{h,i}) - \\lambda_{\\mathrm{PFH,target}} $$\n最后，求解 $c_{dt}$：\n$$ c_{dt} = \\frac{\\sum_{i \\in \\{S,C,A\\}} \\lambda_{D,i}(1-c_{h,i}) - \\lambda_{\\mathrm{PFH,target}}}{\\sum_{i \\in \\{S,C,A\\}} e_i \\lambda_{D,i}(1-c_{h,i})} $$\n现在，我们代入给定的数值。首先，我们计算分子的求和项，它代表仅有硬件诊断时的基准 PFH：\n$$ \\sum_{i} \\lambda_{D,i}(1-c_{h,i}) = \\lambda_{D,S}(1-c_{h,S}) + \\lambda_{D,C}(1-c_{h,C}) + \\lambda_{D,A}(1-c_{h,A}) $$\n$$ = (2.0 \\times 10^{-6})(1 - 0.55) + (1.5 \\times 10^{-6})(1 - 0.65) + (2.5 \\times 10^{-6})(1 - 0.40) $$\n$$ = (2.0 \\times 10^{-6})(0.45) + (1.5 \\times 10^{-6})(0.35) + (2.5 \\times 10^{-6})(0.60) $$\n$$ = (0.90 \\times 10^{-6}) + (0.525 \\times 10^{-6}) + (1.50 \\times 10^{-6}) = 2.925 \\times 10^{-6}\\ \\text{h}^{-1} $$\n完整的分子是：\n$$ \\text{Numerator} = (2.925 \\times 10^{-6}) - (2.0 \\times 10^{-6}) = 0.925 \\times 10^{-6}\\ \\text{h}^{-1} $$\n接下来，我们计算分母的求和项：\n$$ \\sum_{i} e_i \\lambda_{D,i}(1-c_{h,i}) = e_S \\lambda_{D,S}(1-c_{h,S}) + e_C \\lambda_{D,C}(1-c_{h,C}) + e_A \\lambda_{D,A}(1-c_{h,A}) $$\n使用之前计算的组件项：\n$$ = (0.90)(0.90 \\times 10^{-6}) + (0.50)(0.525 \\times 10^{-6}) + (0.80)(1.50 \\times 10^{-6}) $$\n$$ = (0.81 \\times 10^{-6}) + (0.2625 \\times 10^{-6}) + (1.20 \\times 10^{-6}) = 2.2725 \\times 10^{-6}\\ \\text{h}^{-1} $$\n现在，我们计算 $c_{dt}$：\n$$ c_{dt} = \\frac{0.925 \\times 10^{-6}}{2.2725 \\times 10^{-6}} = \\frac{0.925}{2.2725} \\approx 0.4070429... $$\n问题要求答案四舍五入到四位有效数字。\n$$ c_{dt} \\approx 0.4070 $$\n该值是介于 0 和 1 之间的无单位分数，与其作为覆盖率参数的定义一致。",
            "answer": "$$\n\\boxed{0.4070}\n$$"
        },
        {
            "introduction": "除了硬件的可靠性，控制软件逻辑的正确性对自主系统的安全至关重要。在航空 (DO-178C) 和汽车 (ISO 26262) 等领域的认证标准中，对软件测试的覆盖率有极高要求，其中修正条件/判定覆盖 (MC/DC) 是最高安全等级下必须满足的结构覆盖率标准之一。本练习将引导您从第一性原理出发，为给定的逻辑模块和测试用例量化计算 MC/DC 覆盖率，从而深刻理解为何该标准能有效揭示被简单测试方法（如语句覆盖或分支覆盖）所忽略的逻辑缺陷 。",
            "id": "4239822",
            "problem": "您的任务是为几个布尔判定逻辑模块量化修正条件/判定覆盖 (MC/DC)，并论证为何在数字孪生和信息物理系统中的自主系统的安全关键认证方案中，最高安全保障等级强制要求达到 MC/DC。核心是仅使用布尔函数的语义，从命题逻辑的第一性原理计算 MC/DC。\n\n用作基本依据的定义：\n- 判定是一个布尔函数 $f:\\{0,1\\}^n \\rightarrow \\{0,1\\}$，作用于 $n$ 个原子条件 $(C_1,\\dots,C_n)$，其中 $0$ 表示假， $1$ 表示真。\n- 给定一个有限测试集 $T \\subset \\{0,1\\}^n$，如果存在两个测试 $\\mathbf{x},\\mathbf{y}\\in T$ 满足以下条件，则修正条件/判定覆盖 (MC/DC) 对条件 $C_i$ 成立：\n  - 对所有 $j\\neq i$，$\\mathbf{x}_j=\\mathbf{y}_j$ 且 $\\mathbf{x}_i \\neq \\mathbf{y}_i$ (仅 $C_i$ 不同)，并且\n  - $f(\\mathbf{x}) \\neq f(\\mathbf{y})$ (判定结果改变)。\n- 对于一个具有 $n$ 个条件、在测试集 $T$ 下的模块，其 MC/DC 覆盖率是分数 $k/n$，其中 $k$ 是使用 $T$ 中的测试满足上述独立性准则的条件数量。将覆盖率表示为 $[0,1]$ 区间内的小数，不带百分号。\n\n判定模块和所需的测试套件：\n- 模块 $\\mathcal{M}_1$ 的判定为 $E_1(C_1,C_2,C_3,C_4) = (C_1 \\land C_2) \\lor (C_3 \\land \\lnot C_4)$，有 $n=4$ 个条件。使用测试套件 $T_1$，它由以下输入元组组成，每个元组的顺序为 $(C_1,C_2,C_3,C_4)$：\n  - $(0,1,0,1)$，\n  - $(1,1,0,1)$，\n  - $(1,0,0,1)$，\n  - $(0,0,0,0)$，\n  - $(0,0,1,0)$，\n  - $(0,0,1,1)$。\n- 模块 $\\mathcal{M}_2$ 的判定为 $E_2(C_1,C_2,C_3) = C_1 \\land C_2 \\land C_3$，有 $n=3$ 个条件。使用测试套件 $T_2$：\n  - $(1,1,1)$，\n  - $(0,1,1)$，\n  - $(1,0,1)$，\n  - $(1,1,0)$。\n- 模块 $\\mathcal{M}_3$ 的判定为 $E_3(C_1,C_2,C_3) = C_1 \\lor (C_2 \\land C_3)$，有 $n=3$ 个条件。使用测试套件 $T_3$：\n  - $(0,0,0)$，\n  - $(1,0,0)$，\n  - $(0,0,1)$，\n  - $(0,1,1)$。\n- 模块 $\\mathcal{M}_4$ 的判定为 $E_4(C_1) = \\lnot C_1$，有 $n=1$ 个条件。使用测试套件 $T_4$：\n  - $(0)$，\n  - $(1)$。\n\n任务：\n- 实现一个程序，对于每个模块 $\\mathcal{M}_i$，仅使用上述定义，在其指定的测试套件 $T_i$ 下计算 MC/DC 覆盖率。对于每个模块，计算已覆盖条件的集合和覆盖率分数 $k/n$。\n- 每个模块的结果必须是等于覆盖率分数并四舍五入到三位小数的单个浮点数（不要使用百分号）。最终输出应是这四个模块的结果列表，顺序为 $(\\mathcal{M}_1,\\mathcal{M}_2,\\mathcal{M}_3,\\mathcal{M}_4)$。\n\n包含在您的内部推理中的论证理由（不由程序输出产生）：\n- 使用布尔函数的基本语义和 MC/DC 的独立性要求，解释为何 MC/DC 能检测复合判定中的屏蔽效应。\n- 使用广泛接受的认证实践，如 \"DO-$178$C Level A\" 和 \"ISO $26262$ ASIL D\"，解释为何在最高保障等级下 MC/DC 是必要的：它提供了每个原子条件都能独立影响判定结果的证据，这对于在安全关键的自主性中证明充分的结构覆盖至关重要。\n\n测试套件和最终输出规范：\n- 严格使用上述的 $T_1,T_2,T_3,T_4$ 和判定定义。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[0.750,1.000,0.667,1.000]\"）。将每个覆盖率表示为四舍五入到三位小数的小数。\n\n注释：\n- 不涉及物理单位。\n- 不涉及角度。\n- 不要将任何值表示为百分比。",
            "solution": "该问题要求针对四个不同的布尔判定逻辑模块，根据它们各自的判定函数和测试套件，计算修正条件/判定覆盖 (MC/DC)。MC/DC 覆盖率定义为能在给定测试集中找到独立对的条件所占的比例。对于条件 $C_i$ 的独立对，由两个测试向量组成，这两个向量仅在 $C_i$ 的值上不同，并且其判定结果也不同。该问题提法明确，科学上基于软件工程和形式逻辑的原理，并为获得唯一解提供了所有必要信息。\n\n我们将逐一分析每个模块，首先评估套件中每个测试的判定结果，然后系统地为每个条件搜索独立对。\n\n**模块 $\\mathcal{M}_1$**\n\n判定函数为 $E_1(C_1, C_2, C_3, C_4) = (C_1 \\land C_2) \\lor (C_3 \\land \\lnot C_4)$，有 $n=4$ 个条件。\n测试套件为 $T_1 = \\{(0,1,0,1), (1,1,0,1), (1,0,0,1), (0,0,0,0), (0,0,1,0), (0,0,1,1)\\}$。\n\n首先，我们计算 $T_1$ 中每个测试向量对应的 $E_1$ 结果：\n- $\\mathbf{t}_1 = (0,1,0,1): E_1(\\mathbf{t}_1) = (0 \\land 1) \\lor (0 \\land \\lnot 1) = 0 \\lor 0 = 0$\n- $\\mathbf{t}_2 = (1,1,0,1): E_1(\\mathbf{t}_2) = (1 \\land 1) \\lor (0 \\land \\lnot 1) = 1 \\lor 0 = 1$\n- $\\mathbf{t}_3 = (1,0,0,1): E_1(\\mathbf{t}_3) = (1 \\land 0) \\lor (0 \\land \\lnot 1) = 0 \\lor 0 = 0$\n- $\\mathbf{t}_4 = (0,0,0,0): E_1(\\mathbf{t}_4) = (0 \\land 0) \\lor (0 \\land \\lnot 0) = 0 \\lor 0 = 0$\n- $\\mathbf{t}_5 = (0,0,1,0): E_1(\\mathbf{t}_5) = (0 \\land 0) \\lor (1 \\land \\lnot 0) = 0 \\lor 1 = 1$\n- $\\mathbf{t}_6 = (0,0,1,1): E_1(\\mathbf{t}_6) = (0 \\land 0) \\lor (1 \\land \\lnot 1) = 0 \\lor 0 = 0$\n\n接下来，我们检查每个条件的 MC/DC 覆盖情况：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_1, \\mathbf{t}_2) = ((0,1,0,1), (1,1,0,1))$ 仅在 $C_1$ 上不同。其结果分别为 $E_1(\\mathbf{t}_1) = 0$ 和 $E_1(\\mathbf{t}_2) = 1$，是不同的。因此，$C_1$ 被覆盖。\n- **条件 $C_2$**：测试对 $(\\mathbf{t}_3, \\mathbf{t}_2) = ((1,0,0,1), (1,1,0,1))$ 仅在 $C_2$ 上不同。其结果分别为 $E_1(\\mathbf{t}_3) = 0$ 和 $E_1(\\mathbf{t}_2) = 1$，是不同的。因此，$C_2$ 被覆盖。\n- **条件 $C_3$**：测试对 $(\\mathbf{t}_4, \\mathbf{t}_5) = ((0,0,0,0), (0,0,1,0))$ 仅在 $C_3$ 上不同。其结果分别为 $E_1(\\mathbf{t}_4) = 0$ 和 $E_1(\\mathbf{t}_5) = 1$，是不同的。因此，$C_3$ 被覆盖。\n- **条件 $C_4$**：测试对 $(\\mathbf{t}_5, \\mathbf{t}_6) = ((0,0,1,0), (0,0,1,1))$ 仅在 $C_4$ 上不同。其结果分别为 $E_1(\\mathbf{t}_5) = 1$ 和 $E_1(\\mathbf{t}_6) = 0$，是不同的。因此，$C_4$ 被覆盖。\n\n所有 $k=4$ 个条件都被覆盖。$\\mathcal{M}_1$ 的 MC/DC 覆盖率为 $k/n = 4/4 = 1.0$。\n\n**模块 $\\mathcal{M}_2$**\n\n判定函数为 $E_2(C_1, C_2, C_3) = C_1 \\land C_2 \\land C_3$，有 $n=3$ 个条件。\n测试套件为 $T_2 = \\{(1,1,1), (0,1,1), (1,0,1), (1,1,0)\\}$。\n\n$T_2$ 的结果：\n- $\\mathbf{t}_1 = (1,1,1): E_2(\\mathbf{t}_1) = 1 \\land 1 \\land 1 = 1$\n- $\\mathbf{t}_2 = (0,1,1): E_2(\\mathbf{t}_2) = 0 \\land 1 \\land 1 = 0$\n- $\\mathbf{t}_3 = (1,0,1): E_2(\\mathbf{t}_3) = 1 \\land 0 \\land 1 = 0$\n- $\\mathbf{t}_4 = (1,1,0): E_2(\\mathbf{t}_4) = 1 \\land 1 \\land 0 = 0$\n\nMC/DC 覆盖情况检查：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_2, \\mathbf{t}_1) = ((0,1,1), (1,1,1))$ 仅在 $C_1$ 上不同。结果分别为 $0$ 和 $1$。$C_1$ 被覆盖。\n- **条件 $C_2$**：测试对 $(\\mathbf{t}_3, \\mathbf{t}_1) = ((1,0,1), (1,1,1))$ 仅在 $C_2$ 上不同。结果分别为 $0$ 和 $1$。$C_2$ 被覆盖。\n- **条件 $C_3$**：测试对 $(\\mathbf{t}_4, \\mathbf{t}_1) = ((1,1,0), (1,1,1))$ 仅在 $C_3$ 上不同。结果分别为 $0$ 和 $1$。$C_3$ 被覆盖。\n\n所有 $k=3$ 个条件都被覆盖。$\\mathcal{M}_2$ 的 MC/DC 覆盖率为 $k/n = 3/3 = 1.0$。\n\n**模块 $\\mathcal{M}_3$**\n\n判定函数为 $E_3(C_1, C_2, C_3) = C_1 \\lor (C_2 \\land C_3)$，有 $n=3$ 个条件。\n测试套件为 $T_3 = \\{(0,0,0), (1,0,0), (0,0,1), (0,1,1)\\}$。\n\n$T_3$ 的结果：\n- $\\mathbf{t}_1 = (0,0,0): E_3(\\mathbf{t}_1) = 0 \\lor (0 \\land 0) = 0$\n- $\\mathbf{t}_2 = (1,0,0): E_3(\\mathbf{t}_2) = 1 \\lor (0 \\land 0) = 1$\n- $\\mathbf{t}_3 = (0,0,1): E_3(\\mathbf{t}_3) = 0 \\lor (0 \\land 1) = 0$\n- $\\mathbf{t}_4 = (0,1,1): E_3(\\mathbf{t}_4) = 0 \\lor (1 \\land 1) = 1$\n\nMC/DC 覆盖情况检查：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_1, \\mathbf{t}_2) = ((0,0,0), (1,0,0))$ 仅在 $C_1$ 上不同。结果分别为 $0$ 和 $1$。$C_1$ 被覆盖。\n- **条件 $C_2$**：测试对 $(\\mathbf{t}_3, \\mathbf{t}_4) = ((0,0,1), (0,1,1))$ 仅在 $C_2$ 上不同。其他条件 $(C_1,C_3)$ 固定为 $(0,1)$。结果分别为 $E_3(\\mathbf{t}_3)=0$ 和 $E_3(\\mathbf{t}_4)=1$。$C_2$ 被覆盖。\n- **条件 $C_3$**：我们需要一个仅在 $C_3$ 上不同的测试对。$T_3$ 中唯一的此类测试对是 $(\\mathbf{t}_1, \\mathbf{t}_3) = ((0,0,0), (0,0,1))$。其结果分别为 $E_3(\\mathbf{t}_1) = 0$ 和 $E_3(\\mathbf{t}_3) = 0$。由于结果没有改变，这个测试对不满足 MC/DC 准则。$T_3$ 中不存在其他针对 $C_3$ 的测试对。因此，$C_3$ 未被覆盖。\n\n只有 $k=2$ 个条件（$C_1, C_2$）被覆盖。$\\mathcal{M}_3$ 的 MC/DC 覆盖率为 $k/n = 2/3 \\approx 0.667$。\n\n**模块 $\\mathcal{M}_4$**\n\n判定函数为 $E_4(C_1) = \\lnot C_1$，有 $n=1$ 个条件。\n测试套件为 $T_4 = \\{(0), (1)\\}$。\n\n$T_4$ 的结果：\n- $\\mathbf{t}_1 = (0): E_4(\\mathbf{t}_1) = \\lnot 0 = 1$\n- $\\mathbf{t}_2 = (1): E_4(\\mathbf{t}_2) = \\lnot 1 = 0$\n\nMC/DC 覆盖情况检查：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_1, \\mathbf{t}_2) = ((0), (1))$ 仅在 $C_1$ 上不同。结果分别为 $1$ 和 $0$。$C_1$ 被覆盖。\n\n所有 $k=1$ 个条件都被覆盖。$\\mathcal{M}_4$ 的 MC/DC 覆盖率为 $k/n = 1/1 = 1.0$。\n\n**结果总结**\n计算出的 MC/DC 覆盖率分数是：\n- $\\mathcal{M}_1$: $1.0$\n- $\\mathcal{M}_2$: $1.0$\n- $\\mathcal{M}_3$: $2/3 \\approx 0.667$\n- $\\mathcal{M}_4$: $1.0$",
            "answer": "[1.000,1.000,0.667,1.000]"
        },
        {
            "introduction": "对于与复杂环境持续交互的自主系统，仅靠传统的测试方法可能不足以保证在所有可能场景下的安全性，因为穷尽所有输入组合和时序行为几乎是不可能的。本练习将介绍模型检测 (Model Checking) 这一强大的形式化验证技术，它能够通过算法对系统模型的所有可达状态空间进行穷尽搜索，从而严格证明系统是否始终满足给定的安全规约。通过为一个简化的车辆跟驰场景构建一个模型检测器，您将获得形式化定义安全属性（不变式）并利用算法进行验证的实践经验，这是为高风险自主功能构建高置信度安全案例的关键一步 。",
            "id": "4239833",
            "problem": "您的任务是，在数字孪生和信息物理系统的背景下，针对自主系统控制器的认证，形式化地规约并通过模型检验来算法验证一个相关的安全属性。考虑一个简化的离散时间纵向跟车场景，其中一辆自车跟随一辆领头车。安全属性是在所有时间内保持安全的车头时距，表示为一个不变量。您的程序必须实现一个详尽的、基于有限状态的模型检验程序，该程序在量化的状态空间上运行，以判断在模型允许的环境（领头车）的所有非确定性行为下，该安全属性是否成立。所有速度单位为 $\\mathrm{m/s}$，加速度单位为 $\\mathrm{m/s^2}$，间距单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$。\n\n基本基础。使用以下经过充分测试的离散时间动态学纵向运动学更新法则，采样周期 $dt$ 固定：\n- 自车速度更新：$v_E(k+1) = \\max\\{0, \\min\\{v_{\\max}, v_E(k) + dt \\cdot a_E(k)\\}\\}$。\n- 领头车速度更新：$v_L(k+1) = \\max\\{0, \\min\\{v_{\\max}, v_L(k) + dt \\cdot a_L(k)\\}\\}$。\n- 间距更新：$g(k+1) = \\max\\{0, \\min\\{g_{\\max}, g(k) + dt \\cdot (v_L(k) - v_E(k))\\}\\}$。\n\n控制器与环境。自车控制器使用一种砰砰（bang-bang）法则，确定性地选择 $a_E(k)$，该法则旨在通过参数 $A_{E,\\text{accel}}$ 和 $A_{E,\\text{brake}}$ 保持车头时距：\n- 若 $g(k) \\le \\tau \\cdot v_E(k) + g_{\\min}$，则 $a_E(k) = -A_{E,\\text{brake}}$。\n- 否则，$a_E(k) = +A_{E,\\text{accel}}$。\n\n环境（领头车）是非确定性的，可以在每一步从有限集合 $A_L = \\{-A_{L,\\text{brake}}, 0, +A_{L,\\text{accel}}\\}$ 中选择 $a_L(k)$，但受限于上述的速度裁剪。\n\n形式化规约。在线性时序逻辑（LTL）中，将安全属性规约为不变量：\n$$\\varphi \\equiv \\mathbf{G}\\big(g \\ge \\tau \\cdot v_E + g_{\\min}\\big),$$\n即，“全局地，瞬时车距 $g$ 至少为安全阈值 $\\tau \\cdot v_E + g_{\\min}$。”\n\n用于有限状态模型检验的量化。将速度和车距分别量化到具有分辨率 $dv$ 和 $dg$ 的固定网格上。令离散速度集为 $V = \\{0, dv, 2dv, \\dots, v_{\\max}\\}$，离散车距集为 $G = \\{0, dg, 2dg, \\dots, g_{\\max}\\}$。在每次连续更新后，将值映射到 $V$ 或 $G$ 中最近的网格点（平局情况朝向最近的整数倍解析，并裁剪到边界）。状态为 $(v_L, v_E, g) \\in V \\times V \\times G$，每个测试案例给定初始状态 $(v_L(0), v_E(0), g(0))$，并如上所述量化到网格上。转移关系由运动学更新、控制器法则、环境行为和量化定义。模型检验任务是判断从初始状态可达的所有状态是否都满足 $\\varphi$。\n\n验证任务。从初始状态开始，对有限转移系统实施详尽的广度优先搜索。在发现每个状态时，立即检查不变量 $g \\ge \\tau \\cdot v_E + g_{\\min}$。如果任何可达状态违反该不变量，则返回布尔值 $False$；如果搜索达到一个不动点，没有新状态加入且未观察到不变量违规，则返回 $True$。此过程是在有限量化模型中对不变量的证明搜索，与通过数字孪生验证生成面向认证的证据相一致。\n\n角度单位：不适用。百分比：不适用。\n\n测试套件。对于每个测试案例，提供参数 $(dt,\\ \\tau,\\ g_{\\min},\\ dv,\\ dg,\\ v_{\\max},\\ g_{\\max},\\ A_{E,\\text{accel}},\\ A_{E,\\text{brake}},\\ A_{L,\\text{accel}},\\ A_{L,\\text{brake}},\\ v_L(0),\\ v_E(0),\\ g(0))$：\n- 案例 1（常规“理想路径”）：$dt=0.1$, $\\tau=1.5$, $g_{\\min}=2$, $dv=1$, $dg=1$, $v_{\\max}=40$, $g_{\\max}=80$, $A_{E,\\text{accel}}=2$, $A_{E,\\text{brake}}=3$, $A_{L,\\text{accel}}=1.5$, $A_{L,\\text{brake}}=2.5$, $v_L(0)=20$, $v_E(0)=18$, $g(0)=40$。\n- 案例 2（初始化时处于边界相等状态）：$dt=0.1$, $\\tau=1.5$, $g_{\\min}=2$, $dv=1$, $dg=0.5$, $v_{\\max}=40$, $g_{\\max}=80$, $A_{E,\\text{accel}}=2$, $A_{E,\\text{brake}}=3$, $A_{L,\\text{accel}}=1.5$, $A_{L,\\text{brake}}=2.5$, $v_L(0)=16$, $v_E(0)=15$, $g(0)=24.5$。\n- 案例 3（粗采样，潜在的离散化风险）：$dt=0.5$, $\\tau=1.5$, $g_{\\min}=2$, $dv=1$, $dg=1$, $v_{\\max}=40$, $g_{\\max}=80$, $A_{E,\\text{accel}}=2$, $A_{E,\\text{brake}}=3$, $A_{L,\\text{accel}}=1.5$, $A_{L,\\text{brake}}=2.5$, $v_L(0)=25$, $v_E(0)=23$, $g(0)=30$。\n- 案例 4（自车制动能力不足）：$dt=0.1$, $\\tau=1.5$, $g_{\\min}=2$, $dv=1$, $dg=1$, $v_{\\max}=40$, $g_{\\max}=80$, $A_{E,\\text{accel}}=2$, $A_{E,\\text{brake}}=1$, $A_{L,\\text{accel}}=1.5$, $A_{L,\\text{brake}}=3$, $v_L(0)=22$, $v_E(0)=22$, $g(0)=25$。\n- 案例 5（自车初始速度为零）：$dt=0.1$, $\\tau=1.5$, $g_{\\min}=2$, $dv=1$, $dg=1$, $v_{\\max}=40$, $g_{\\max}=80$, $A_{E,\\text{accel}}=2$, $A_{E,\\text{brake}}=3$, $A_{L,\\text{accel}}=1.5$, $A_{L,\\text{brake}}=2.5$, $v_L(0)=10$, $v_E(0)=0$, $g(0)=5$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5]”），其中每个结果是按上述顺序列出的测试案例的布尔决策。",
            "solution": "用户提供的问题是要求对一个简化的自主跟车模型的一个安全属性进行形式化验证。指定的验证方法是在一个有限的、量化的状态空间上进行显式状态模型检验。\n\n### 步骤 1：问题验证\n\n我将首先提取给定信息，并根据指定标准验证问题陈述。\n\n#### 提取的给定信息\n\n**1. 系统动力学（离散时间运动学更新）：**\n- 采样周期：$dt$\n- 自车速度更新：$v_E(k+1) = \\max\\{0, \\min\\{v_{\\max}, v_E(k) + dt \\cdot a_E(k)\\}\\}$\n- 领头车速度更新：$v_L(k+1) = \\max\\{0, \\min\\{v_{\\max}, v_L(k) + dt \\cdot a_L(k)\\}\\}$\n- 车间距更新：$g(k+1) = \\max\\{0, \\min\\{g_{\\max}, g(k) + dt \\cdot (v_L(k) - v_E(k))\\}\\}$\n\n**2. 自车控制器：**\n- 一个基于恒定车头时距策略的确定性砰砰（bang-bang）控制器。\n- 控制器参数：加速度 $A_{E,\\text{accel}}$，制动 $A_{E,\\text{brake}}$。\n- 自车加速度 $a_E(k)$ 的控制律：\n  - 如果 $g(k) \\le \\tau \\cdot v_E(k) + g_{\\min}$，则 $a_E(k) = -A_{E,\\text{brake}}$。\n  - 否则，$a_E(k) = +A_{E,\\text{accel}}$。\n\n**3. 环境模型（领头车）：**\n- 领头车的加速度 $a_L(k)$ 在每个时间步 $k$ 非确定性地选择。\n- 可能的动作集合是 $A_L = \\{-A_{L,\\text{brake}}, 0, +A_{L,\\text{accel}}\\}$。\n\n**4. 形式化安全属性：**\n- 该属性是一个不变量，用线性时序逻辑（LTL）指定为 $\\varphi \\equiv \\mathbf{G}\\big(g \\ge \\tau \\cdot v_E + g_{\\min}\\big)$。\n- 这意味着对于所有时间的所有可达状态，车距 $g$ 必须大于或等于由 $\\tau \\cdot v_E + g_{\\min}$ 定义的安全跟车距离。\n\n**5. 状态空间量化：**\n- 连续状态变量 $(v_L, v_E, g)$被量化到离散网格上。\n- 速度分辨率：$dv$。离散速度集：$V = \\{0, dv, 2dv, \\dots, v_{\\max}\\}$。\n- 车距分辨率：$dg$。离散车距集：$G = \\{0, dg, 2dg, \\dots, g_{\\max}\\}$。\n- 量化规则：一个连续值被映射到最近的网格点。\n- 有限模型的状态是一个元组 $(v_L, v_E, g) \\in V \\times V \\times G$。\n\n**6. 验证任务：**\n- 从给定的初始状态开始，实现一个详尽的广度优先搜索（BFS）。\n- 如果发现任何可达状态 $(v_L, v_E, g)$ 使得 $g  \\tau \\cdot v_E + g_{\\min}$，则该属性被违反，验证结果为 False。\n- 如果搜索探索了所有可达状态而没有发现违规，则该属性对模型成立，结果为 True。\n\n**7. 测试案例：**\n- 问题提供了五组特定的参数 $(dt, \\tau, g_{\\min}, dv, dg, v_{\\max}, g_{\\max}, A_{E,\\text{accel}}, A_{E,\\text{brake}}, A_{L,\\text{accel}}, A_{L,\\text{brake}}, v_L(0), v_E(0), g(0))$ 进行测试。\n\n#### 验证结论\n\n该问题是**有效的**。\n\n1.  **科学基础扎实：** 该问题基于运动学、控制理论和形式化方法的基本原理。离散时间更新方程是标准的一阶欧拉积分。恒定车头时距策略是汽车工程中一个公认的概念。验证方法，即通过在量化模型上进行BFS的显式状态模型检验，是计算机科学和信息物理系统工程中的一种标准且严谨的技术。\n2.  **适定的（Well-Posed）：** 该问题是适定的。状态空间虽然可能很大，但由于量化和有界变量而变得有限。转移关系定义清晰。每个测试案例都给定了初始状态。目标是判定一个属性，这对于有限系统是可判定的。BFS算法保证终止，并将产生唯一的布尔答案。\n3.  **客观性：** 问题使用精确的数学和算法语言指定，没有主观性或模糊性，唯一的微小例外是量化中的平局处理规则，这可以通过采用标准的、确定性的四舍五入方法来解决。\n4.  **未检测到其他缺陷：** 问题是自洽的，其参数在物理上是合理的，其结构是合乎逻辑的。它提出了一个非凡的挑战，直接触及了自主系统形式化验证的核心概念。\n\n### 步骤 2：解决方案设计\n\n该问题要求为不变量属性实现一个显式状态模型检验器。要检验的系统是一个有限转移系统，其中状态是量化的元组 $(v_L, v_E, g)$，转移由给定的动力学推导而来。算法将是广度优先搜索（BFS），以找到所有可达状态。\n\n**1. 状态表示与量化**\n系统的状态是一个由三个浮点数组成的元组 $(v_L, v_E, g)$，分别代表领头车速度、自车速度和车距。这些值被约束在一个离散的网格上。需要一个 `quantize` 函数来将动态更新产生的任何连续值映射到其对应的网格点。该函数将实现为 `quantized_value = resolution * round(continuous_value / resolution)`，然后裁剪到指定的范围 $[v_{\\min}, v_{\\max}]$ 或 $[g_{\\min}, g_{\\max}]$。标准的 `numpy.round` 函数（将 `x.5` 四舍五入到最近的偶数整数）提供了一个确定性且明确的平局处理规则。状态元组是可哈希的，可以高效地存储在一个集合中以跟踪已访问的状态。\n\n**2. 转移系统**\n转移系统可以看作一个有向图，其中节点是离散状态。如果状态 $S' = (v'_L, v'_E, g')$ 可以在一个时间步 $dt$ 内从状态 $S = (v_L, v_E, g)$ 到达，则存在一条从 $S$ 到 $S'$ 的边。要找到一个状态 $S$ 的所有后继状态：\n- 首先，根据应用于状态 $S$ 的控制器逻辑确定自车的加速度 $a_E$。\n- 其次，对于领头车在集合 $\\{-A_{L,\\text{brake}}, 0, +A_{L,\\text{accel}}\\}$ 中的每个可能的加速度 $a_L$：\n    - 使用状态 $S$ 的输入，通过运动学更新方程计算新的连续值 $(v'_{L,c}, v'_{E,c}, g'_c)$。\n    - 量化这些连续值以获得离散的后继状态 $S' = (\\text{quantize}(v'_{L,c}), \\text{quantize}(v'_{E,c}), \\text{quantize}(g'_c))$。\n此过程为每个状态 $S$ 生成最多三个后继状态。\n\n**3. 模型检验算法（用于不变量检验的BFS）**\n安全属性 $\\varphi \\equiv \\mathbf{G}(P)$ 其中 $P \\equiv (g \\ge \\tau \\cdot v_E + g_{\\min})$ 是一个不变量。验证它意味着确保谓词 $P$ 对所有可达状态都为真。\n算法如下：\n1.  为BFS初始化一个队列（或 `deque`）`frontier`，以及一个用于存储 `visited_states` 的 `set`。\n2.  量化给定的初始状态 $(v_L(0), v_E(0), g(0))$ 以获得初始离散状态 $S_0$。\n3.  **至关重要的是，检查谓词 $P$ 对 $S_0$ 是否成立。** 如果 $g_0  \\tau \\cdot v_{E0} + g_{\\min}$，不变量立即被违反。返回 `False`。\n4.  将 $S_0$ 添加到 `frontier` 和 `visited_states`。\n5.  开始主循环：当 `frontier` 不为空时：\n    a. 从 `frontier` 中出队一个状态 $S$。\n    b. 如转移系统逻辑中所述，生成 $S$ 的所有可能的后继状态 $\\{S'_1, S'_2, \\ldots\\}$。\n    c. 对于每个后继状态 $S'_i$：\n        i. 如果 $S'_i$ 未被访问过（即 $S'_i \\notin \\text{visited\\_states}$）：\n            - 检查谓词 $P$ 对 $S'_i$ 是否成立。如果为假，则找到了一个反例。属性 $\\varphi$ 被违反。返回 `False`。\n            - 如果 $P$ 成立，将 $S'_i$ 添加到 `visited_states` 并将其入队到 `frontier`。\n6.  如果循环完成，意味着已经探索了整个可达状态集，并且谓词 $P$ 对所有状态都为真。属性 $\\varphi$ 对模型成立。返回 `True`。\n\n此过程构成了对模型有限状态空间的穷举证明。",
            "answer": "[True,False,False,False,True]"
        }
    ]
}