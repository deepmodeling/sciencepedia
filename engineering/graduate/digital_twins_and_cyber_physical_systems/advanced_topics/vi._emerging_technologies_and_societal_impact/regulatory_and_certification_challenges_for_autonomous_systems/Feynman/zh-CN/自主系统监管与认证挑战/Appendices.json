{
    "hands_on_practices": [
        {
            "introduction": "功能安全标准（如IEC 61508）是认证关键自主系统的基石，它们使用如“每小时危险失效概率”（$\\lambda_{\\mathrm{PFH}}$）等量化指标来定义安全完整性等级（SIL）。本练习  提供了计算不同诊断机制（包括传统的硬件诊断和现代的数字孪生监视器）如何共同作用以满足系统级安全目标的实践。通过这个计算，您将把抽象的安全指标与具体的工程设计参数（如诊断覆盖率）联系起来，从而掌握量化安全分析的核心方法。",
            "id": "4239826",
            "problem": "一个信息物理系统（CPS）中的自动制动子系统正在根据国际电工委员会标准 61508（IEC 61508）进行连续运行模式的认证。认证目标是每小时危险失效概率（PFH），记为 $\\lambda_{\\mathrm{PFH}}$，针对由三个串联组件（感知传感器($S$)、控制器($C$)和执行器($A$)）构成的危险路径。每个组件 $i \\in \\{S,C,A\\}$ 都有一个基本危险失效率 $\\lambda_{D,i}$ 和一个板载实现的具有覆盖率 $c_{h,i}$ 的嵌入式硬件诊断。系统增加了一个基于数字孪生的在线监视器，其统一可调的覆盖率参数 $c_{dt} \\in [0,1]$ 应用于所有三个组件，但其对组件 $i$ 的有效性受到一个有效性系数 $e_i \\in [0,1]$ 的限制，该系数用于量化组件 $i$ 中可被数字孪生模型和分析检测到的危险失效模式的比例。假设检测机制（硬件诊断和数字孪生监视器）对每种危险失效模式独立作用，并且一旦检测到失效，系统会立即转换到安全状态，因此检测到的危险失效不会对 $\\lambda_{\\mathrm{PFH}}$ 产生贡献。假设失效率恒定（齐次泊松过程）、失效罕见，且危险路径为串联形式，因此子系统级的 $\\lambda_{\\mathrm{PFH}}$ 是各组件级危险未检测失效率之和。\n\n子系统数据如下：\n- 传感器：$\\lambda_{D,S} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,S} = 0.55$，$e_{S} = 0.90$。\n- 控制器：$\\lambda_{D,C} = 1.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,C} = 0.65$，$e_{C} = 0.50$。\n- 执行器：$\\lambda_{D,A} = 2.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,A} = 0.40$，$e_{A} = 0.80$。\n\n认证目标为 $\\lambda_{\\mathrm{PFH,target}} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$。根据上述建模假设，计算满足 $\\lambda_{\\mathrm{PFH,target}}$ 所需的最小数字孪生覆盖率 $c_{dt}$。将最终答案表示为一个无单位的分数，并四舍五入到四位有效数字。",
            "solution": "对用户提供的问题进行有效性评估。\n\n### 步骤 1：提取已知条件\n- **系统组件**：串联危险路径中的传感器（$S$）、控制器（$C$）、执行器（$A$）。\n- **认证目标**：每小时危险失效概率，$\\lambda_{\\mathrm{PFH,target}} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$。\n- **组件数据 ($i \\in \\{S,C,A\\}$)**：\n  - 基本危险失效率：$\\lambda_{D,i}$。\n  - 硬件诊断覆盖率：$c_{h,i}$。\n  - 数字孪生有效性系数：$e_i$。\n- **数字孪生（DT）监视器**：\n  - 统一可調覆盖率：$c_{dt} \\in [0,1]$。\n- **具体数据值**：\n  - 传感器 ($S$)：$\\lambda_{D,S} = 2.0 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,S} = 0.55$，$e_{S} = 0.90$。\n  - 控制器 ($C$)：$\\lambda_{D,C} = 1.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,C} = 0.65$，$e_{C} = 0.50$。\n  - 执行器 ($A$)：$\\lambda_{D,A} = 2.5 \\times 10^{-6}\\ \\text{h}^{-1}$，$c_{h,A} = 0.40$，$e_{A} = 0.80$。\n- **假设**：\n  - 硬件诊断和数字孪生监视器作为独立的检测机制运行。\n  - 检测到的危险失效得到安全处理，不计入 $\\lambda_{\\mathrm{PFH}}$。\n  - 子系统的 $\\lambda_{\\mathrm{PFH}}$ 是组件级危险未检测失效率 ($\\lambda_{\\mathrm{DU},i}$) 的总和。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题。\n- **科学依据**：该问题很好地基于可靠性工程和功能安全的原理，这些原理由 IEC 61508 等标准定义。危险失效率、诊断覆盖率以及串联系统 PFH 的计算等概念都是标准方法。\n- **适定性**：问题提供了构建并求解未知变量 $c_{dt}$ 所需的所有数据和关系定义。预期会有一个唯一解。\n- **客观性**：问题陈述使用了精确、定量且清晰无歧义的语言。\n- **结论**：该问题在科学合理性、完整性、一致性或客观性方面没有表现出任何缺陷。这是一个在信息物理系统安全领域中可形式化且相关的问题。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将推导解答。\n\n问题要求计算为达到目标子系统每小时危险失效概率 $\\lambda_{\\mathrm{PFH,target}}$ 所需的最小数字孪生覆盖率 $c_{dt}$。\n\n根据问题陈述，子系统的 $\\lambda_{\\mathrm{PFH}}$ 是其各组件的危险未检测失效率 $\\lambda_{\\mathrm{DU},i}$ 的总和。\n$$ \\lambda_{\\mathrm{PFH}} = \\sum_{i \\in \\{S,C,A\\}} \\lambda_{\\mathrm{DU},i} $$\n组件 $i$ 的危险失效仅在未被板载硬件诊断或数字孪生监视器检测到的情况下才会计入 $\\lambda_{\\mathrm{DU},i}$。问题陈述指出这两种检测机制是独立的。\n\n对于给定的组件 $i$，危险失效*未被*硬件诊断检测到的概率是 $(1 - c_{h,i})$。\n数字孪生监视器有一个覆盖率参数 $c_{dt}$，但其对组件 $i$ 的适用性受有效性系数 $e_i$ 的限制。因此，DT 检测到组件 $i$ 上随机危险失效的有效概率是乘积 $e_i c_{dt}$。因此，危险失效*未被* DT 监视器检测到的概率是 $(1 - e_i c_{dt})$。\n\n由于两种检测机制的独立性，危险失效被*两种*机制都漏检的概率是它们各自未检测概率的乘积。\n$$ P(\\text{未检测到}) = (1 - c_{h,i}) (1 - e_i c_{dt}) $$\n组件 $i$ 的危险未检测失效率 $\\lambda_{\\mathrm{DU},i}$ 是基本危险失效率 $\\lambda_{D,i}$ 乘以这个未检测概率。\n$$ \\lambda_{\\mathrm{DU},i} = \\lambda_{D,i} (1 - c_{h,i})(1 - e_i c_{dt}) $$\n整个系统的 $\\lambda_{\\mathrm{PFH}}$ 是所有三个组件的总和：\n$$ \\lambda_{\\mathrm{PFH}} = \\sum_{i \\in \\{S,C,A\\}} \\lambda_{D,i} (1 - c_{h,i})(1 - e_i c_{dt}) $$\n为了求得所需的最小 $c_{dt}$，我们将 $\\lambda_{\\mathrm{PFH}}$ 设为目标值 $\\lambda_{\\mathrm{PFH,target}}$。\n$$ \\lambda_{\\mathrm{PFH,target}} = \\sum_{i \\in \\{S,C,A\\}} \\lambda_{D,i} (1 - c_{h,i})(1 - e_i c_{dt}) $$\n我们可以展开并重排这个方程来求解 $c_{dt}$。\n$$ \\lambda_{\\mathrm{PFH,target}} = \\sum_{i} \\left[ \\lambda_{D,i}(1 - c_{h,i}) - c_{dt} \\cdot e_i \\lambda_{D,i}(1 - c_{h,i}) \\right] $$\n$$ \\lambda_{\\mathrm{PFH,target}} = \\sum_{i} \\lambda_{D,i}(1 - c_{h,i}) - c_{dt} \\sum_{i} e_i \\lambda_{D,i}(1 - c_{h,i}) $$\n重排以分离出含 $c_{dt}$ 的项：\n$$ c_{dt} \\sum_{i} e_i \\lambda_{D,i}(1 - c_{h,i}) = \\sum_{i} \\lambda_{D,i}(1 - c_{h,i}) - \\lambda_{\\mathrm{PFH,target}} $$\n最后，求解 $c_{dt}$：\n$$ c_{dt} = \\frac{\\sum_{i \\in \\{S,C,A\\}} \\lambda_{D,i}(1-c_{h,i}) - \\lambda_{\\mathrm{PFH,target}}}{\\sum_{i \\in \\{S,C,A\\}} e_i \\lambda_{D,i}(1-c_{h,i})} $$\n现在，我们代入给定的数值。首先，我们计算分子中的求和项，它代表仅有硬件诊断时的基线 PFH：\n$$ \\sum_{i} \\lambda_{D,i}(1-c_{h,i}) = \\lambda_{D,S}(1-c_{h,S}) + \\lambda_{D,C}(1-c_{h,C}) + \\lambda_{D,A}(1-c_{h,A}) $$\n$$ = (2.0 \\times 10^{-6})(1 - 0.55) + (1.5 \\times 10^{-6})(1 - 0.65) + (2.5 \\times 10^{-6})(1 - 0.40) $$\n$$ = (2.0 \\times 10^{-6})(0.45) + (1.5 \\times 10^{-6})(0.35) + (2.5 \\times 10^{-6})(0.60) $$\n$$ = (0.90 \\times 10^{-6}) + (0.525 \\times 10^{-6}) + (1.50 \\times 10^{-6}) = 2.925 \\times 10^{-6}\\ \\text{h}^{-1} $$\n完整的分子是：\n$$ \\text{Numerator} = (2.925 \\times 10^{-6}) - (2.0 \\times 10^{-6}) = 0.925 \\times 10^{-6}\\ \\text{h}^{-1} $$\n接下来，我们计算分母中的求和项：\n$$ \\sum_{i} e_i \\lambda_{D,i}(1-c_{h,i}) = e_S \\lambda_{D,S}(1-c_{h,S}) + e_C \\lambda_{D,C}(1-c_{h,C}) + e_A \\lambda_{D,A}(1-c_{h,A}) $$\n使用前面计算出的各分项：\n$$ = (0.90)(0.90 \\times 10^{-6}) + (0.50)(0.525 \\times 10^{-6}) + (0.80)(1.50 \\times 10^{-6}) $$\n$$ = (0.81 \\times 10^{-6}) + (0.2625 \\times 10^{-6}) + (1.20 \\times 10^{-6}) = 2.2725 \\times 10^{-6}\\ \\text{h}^{-1} $$\n现在，我们计算 $c_{dt}$：\n$$ c_{dt} = \\frac{0.925 \\times 10^{-6}}{2.2725 \\times 10^{-6}} = \\frac{0.925}{2.2725} \\approx 0.4070429... $$\n问题要求答案四舍五入到四位有效数字。\n$$ c_{dt} \\approx 0.4070 $$\n该值是介于 0 和 1 之间的无单位分数，与其作为覆盖率参数的定义一致。",
            "answer": "$$\n\\boxed{0.4070}\n$$"
        },
        {
            "introduction": "除了硬件的可靠性，实现控制逻辑的软件也必须经过严格的验证，尤其是在航空（DO-178C）和汽车（ISO 26262）等安全攸关领域。“改进的条件/判定覆盖”（MC/DC）是针对最高安全等级软件的一项强制性结构覆盖率标准。此练习  要求您从第一性原理出发计算MC/DC，这将帮助您深刻理解为何此标准能有效揭示逻辑代码中的“掩蔽效应”，并体会其在确保高置信度软件认证中的核心地位。",
            "id": "4239822",
            "problem": "您的任务是为几个布尔决策逻辑模块量化修正条件/判定覆盖 (MC/DC)，并论证为何在数字孪生和信息物理系统中的自主系统的安全关键认证方案中，最高安全保证等级强制要求达到 MC/DC。核心是仅使用布尔函数的语义，根据命题逻辑的基本原理来计算 MC/DC。\n\n用作基本依据的定义：\n- 判定是一个布尔函数 $f:\\{0,1\\}^n \\rightarrow \\{0,1\\}$，作用于 $n$ 个原子条件 $(C_1,\\dots,C_n)$，其中 $0$ 表示假，$1$ 表示真。\n- 给定一个有限测试集 $T \\subset \\{0,1\\}^n$，如果存在两个测试 $\\mathbf{x},\\mathbf{y}\\in T$ 满足以下条件，则修正条件/判定覆盖 (MC/DC) 对条件 $C_i$ 成立：\n  - 对所有 $j\\neq i$，$\\mathbf{x}_j=\\mathbf{y}_j$ 且 $\\mathbf{x}_i \\neq \\mathbf{y}_i$（仅 $C_i$ 不同），并且\n  - $f(\\mathbf{x}) \\neq f(\\mathbf{y})$（判定结果改变）。\n- 对于一个具有 $n$ 个条件并在 $T$ 下测试的模块，其 MC/DC 覆盖率是分数 $k/n$，其中 $k$ 是使用 $T$ 中的测试满足上述独立性准则的条件数量。将覆盖率表示为 $[0,1]$ 区间内的小数，不使用百分号。\n\n决策模块与所需测试套件：\n- 模块 $\\mathcal{M}_1$ 的判定为 $E_1(C_1,C_2,C_3,C_4) = (C_1 \\land C_2) \\lor (C_3 \\land \\lnot C_4)$，其中 $n=4$。使用由以下输入元组组成的测试套件 $T_1$，每个元组的顺序为 $(C_1,C_2,C_3,C_4)$：\n  - $(0,1,0,1)$，\n  - $(1,1,0,1)$，\n  - $(1,0,0,1)$，\n  - $(0,0,0,0)$，\n  - $(0,0,1,0)$，\n  - $(0,0,1,1)$。\n- 模块 $\\mathcal{M}_2$ 的判定为 $E_2(C_1,C_2,C_3) = C_1 \\land C_2 \\land C_3$，其中 $n=3$。使用测试套件 $T_2$：\n  - $(1,1,1)$，\n  - $(0,1,1)$，\n  - $(1,0,1)$，\n  - $(1,1,0)$。\n- 模块 $\\mathcal{M}_3$ 的判定为 $E_3(C_1,C_2,C_3) = C_1 \\lor (C_2 \\land C_3)$，其中 $n=3$。使用测试套件 $T_3$：\n  - $(0,0,0)$，\n  - $(1,0,0)$，\n  - $(0,0,1)$，\n  - $(0,1,1)$。\n- 模块 $\\mathcal{M}_4$ 的判定为 $E_4(C_1) = \\lnot C_1$，其中 $n=1$。使用测试套件 $T_4$：\n  - $(0)$，\n  - $(1)$。\n\n任务：\n- 实现一个程序，为每个模块 $\\mathcal{M}_i$，仅使用上述定义计算其在指定测试套件 $T_i$ 下的 MC/DC 覆盖率。对于每个模块，计算已覆盖条件的集合和覆盖率分数 $k/n$。\n- 每个模块的结果必须是等于覆盖率分数并四舍五入到三位小数的单个浮点数（不使用百分号）。最终输出应为这四个模块的结果列表，顺序为 $(\\mathcal{M}_1,\\mathcal{M}_2,\\mathcal{M}_3,\\mathcal{M}_4)$。\n\n包含在内部推理中的理由（不由程序输出产生）：\n- 使用布尔函数的基本语义和 MC/DC 的独立性要求，解释为何 MC/DC 能检测复合判定中的掩蔽效应。\n- 使用广泛接受的认证实践（如 “DO-178C Level A” 和 “ISO 26262 ASIL D”）解释为何在最高保证等级下 MC/DC 是必需的：它提供了每个原子条件都能独立影响判定结果的证据，这对于证明安全关键自主性中足够的结构覆盖率至关重要。\n\n测试套件和最终输出规范：\n- 严格使用上述 $T_1,T_2,T_3,T_4$ 和判定定义。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[0.750,1.000,0.667,1.000]”）。将每个覆盖率表示为四舍五入到三位的小数。\n\n注意：\n- 不涉及物理单位。\n- 不涉及角度。\n- 不要将任何值表示为百分比。",
            "solution": "该问题要求为四个不同的布尔决策逻辑模块计算修正条件/判定覆盖 (MC/DC)，给定它们各自的判定函数和测试套件。MC/DC 覆盖率定义为能在给定测试集中找到独立对的条件所占的比例。对于一个条件 $C_i$，其独立对由两个测试向量组成，这两个向量仅在 $C_i$ 的值上不同，并且其判定结果也不同。该问题是适定的，其科学基础是软件工程和形式逻辑的原理，并为得出唯一解提供了所有必要信息。\n\n我们将依次分析每个模块，首先评估测试套件中每个测试的判定结果，然后为每个条件系统地搜索独立对。\n\n**模块 $\\mathcal{M}_1$**\n\n判定函数为 $E_1(C_1, C_2, C_3, C_4) = (C_1 \\land C_2) \\lor (C_3 \\land \\lnot C_4)$，有 $n=4$ 个条件。\n测试套件为 $T_1 = \\{(0,1,0,1), (1,1,0,1), (1,0,0,1), (0,0,0,0), (0,0,1,0), (0,0,1,1)\\}$。\n\n首先，我们计算 $T_1$ 中每个测试向量对于 $E_1$ 的结果：\n- $\\mathbf{t}_1 = (0,1,0,1): E_1(\\mathbf{t}_1) = (0 \\land 1) \\lor (0 \\land \\lnot 1) = 0 \\lor 0 = 0$\n- $\\mathbf{t}_2 = (1,1,0,1): E_1(\\mathbf{t}_2) = (1 \\land 1) \\lor (0 \\land \\lnot 1) = 1 \\lor 0 = 1$\n- $\\mathbf{t}_3 = (1,0,0,1): E_1(\\mathbf{t}_3) = (1 \\land 0) \\lor (0 \\land \\lnot 1) = 0 \\lor 0 = 0$\n- $\\mathbf{t}_4 = (0,0,0,0): E_1(\\mathbf{t}_4) = (0 \\land 0) \\lor (0 \\land \\lnot 0) = 0 \\lor 0 = 0$\n- $\\mathbf{t}_5 = (0,0,1,0): E_1(\\mathbf{t}_5) = (0 \\land 0) \\lor (1 \\land \\lnot 0) = 0 \\lor 1 = 1$\n- $\\mathbf{t}_6 = (0,0,1,1): E_1(\\mathbf{t}_6) = (0 \\land 0) \\lor (1 \\land \\lnot 1) = 0 \\lor 0 = 0$\n\n接下来，我们检查每个条件的 MC/DC 覆盖情况：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_1, \\mathbf{t}_2) = ((0,1,0,1), (1,1,0,1))$ 仅在 $C_1$ 上不同。结果为 $E_1(\\mathbf{t}_1) = 0$ 和 $E_1(\\mathbf{t}_2) = 1$，是不同的。因此，$C_1$ 被覆盖。\n- **条件 $C_2$**：测试对 $(\\mathbf{t}_3, \\mathbf{t}_2) = ((1,0,0,1), (1,1,0,1))$ 仅在 $C_2$ 上不同。结果为 $E_1(\\mathbf{t}_3) = 0$ 和 $E_1(\\mathbf{t}_2) = 1$，是不同的。因此，$C_2$ 被覆盖。\n- **条件 $C_3$**：测试对 $(\\mathbf{t}_4, \\mathbf{t}_5) = ((0,0,0,0), (0,0,1,0))$ 仅在 $C_3$ 上不同。结果为 $E_1(\\mathbf{t}_4) = 0$ 和 $E_1(\\mathbf{t}_5) = 1$，是不同的。因此，$C_3$ 被覆盖。\n- **条件 $C_4$**：测试对 $(\\mathbf{t}_5, \\mathbf{t}_6) = ((0,0,1,0), (0,0,1,1))$ 仅在 $C_4$ 上不同。结果为 $E_1(\\mathbf{t}_5) = 1$ 和 $E_1(\\mathbf{t}_6) = 0$，是不同的。因此，$C_4$ 被覆盖。\n\n所有 $k=4$ 个条件都被覆盖。$\\mathcal{M}_1$ 的 MC/DC 覆盖率为 $k/n = 4/4 = 1.0$。\n\n**模块 $\\mathcal{M}_2$**\n\n判定函数为 $E_2(C_1, C_2, C_3) = C_1 \\land C_2 \\land C_3$，有 $n=3$ 个条件。\n测试套件为 $T_2 = \\{(1,1,1), (0,1,1), (1,0,1), (1,1,0)\\}$。\n\n$T_2$ 的结果：\n- $\\mathbf{t}_1 = (1,1,1): E_2(\\mathbf{t}_1) = 1 \\land 1 \\land 1 = 1$\n- $\\mathbf{t}_2 = (0,1,1): E_2(\\mathbf{t}_2) = 0 \\land 1 \\land 1 = 0$\n- $\\mathbf{t}_3 = (1,0,1): E_2(\\mathbf{t}_3) = 1 \\land 0 \\land 1 = 0$\n- $\\mathbf{t}_4 = (1,1,0): E_2(\\mathbf{t}_4) = 1 \\land 1 \\land 0 = 0$\n\nMC/DC 覆盖情况检查：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_2, \\mathbf{t}_1) = ((0,1,1), (1,1,1))$ 仅在 $C_1$ 上不同。结果为 $0$ 和 $1$。$C_1$ 被覆盖。\n- **条件 $C_2$**：测试对 $(\\mathbf{t}_3, \\mathbf{t}_1) = ((1,0,1), (1,1,1))$ 仅在 $C_2$ 上不同。结果为 $0$ 和 $1$。$C_2$ 被覆盖。\n- **条件 $C_3$**：测试对 $(\\mathbf{t}_4, \\mathbf{t}_1) = ((1,1,0), (1,1,1))$ 仅在 $C_3$ 上不同。结果为 $0$ 和 $1$。$C_3$ 被覆盖。\n\n所有 $k=3$ 个条件都被覆盖。$\\mathcal{M}_2$ 的 MC/DC 覆盖率为 $k/n = 3/3 = 1.0$。\n\n**模块 $\\mathcal{M}_3$**\n\n判定函数为 $E_3(C_1, C_2, C_3) = C_1 \\lor (C_2 \\land C_3)$，有 $n=3$ 个条件。\n测试套件为 $T_3 = \\{(0,0,0), (1,0,0), (0,0,1), (0,1,1)\\}$。\n\n$T_3$ 的结果：\n- $\\mathbf{t}_1 = (0,0,0): E_3(\\mathbf{t}_1) = 0 \\lor (0 \\land 0) = 0$\n- $\\mathbf{t}_2 = (1,0,0): E_3(\\mathbf{t}_2) = 1 \\lor (0 \\land 0) = 1$\n- $\\mathbf{t}_3 = (0,0,1): E_3(\\mathbf{t}_3) = 0 \\lor (0 \\land 1) = 0$\n- $\\mathbf{t}_4 = (0,1,1): E_3(\\mathbf{t}_4) = 0 \\lor (1 \\land 1) = 1$\n\nMC/DC 覆盖情况检查：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_1, \\mathbf{t}_2) = ((0,0,0), (1,0,0))$ 仅在 $C_1$ 上不同。结果为 $0$ 和 $1$。$C_1$ 被覆盖。\n- **条件 $C_2$**：测试对 $(\\mathbf{t}_3, \\mathbf{t}_4) = ((0,0,1), (0,1,1))$ 仅在 $C_2$ 上不同。其他条件 $(C_1,C_3)$ 固定为 $(0,1)$。结果为 $E_3(\\mathbf{t}_3)=0$ 和 $E_3(\\mathbf{t}_4)=1$。$C_2$ 被覆盖。\n- **条件 $C_3$**：我们需要一个仅在 $C_3$ 上不同的测试对。在 $T_3$ 中唯一的此类测试对是 $(\\mathbf{t}_1, \\mathbf{t}_3) = ((0,0,0), (0,0,1))$。结果为 $E_3(\\mathbf{t}_1) = 0$ 和 $E_3(\\mathbf{t}_3) = 0$。由于结果没有改变，该测试对不满足 MC/DC 准则。在 $T_3$ 中不存在其他针对 $C_3$ 的测试对。因此，$C_3$ 未被覆盖。\n\n只有 $k=2$ 个条件（$C_1, C_2$）被覆盖。$\\mathcal{M}_3$ 的 MC/DC 覆盖率为 $k/n = 2/3 \\approx 0.667$。\n\n**模块 $\\mathcal{M}_4$**\n\n判定函数为 $E_4(C_1) = \\lnot C_1$，有 $n=1$ 个条件。\n测试套件为 $T_4 = \\{(0), (1)\\}$。\n\n$T_4$ 的结果：\n- $\\mathbf{t}_1 = (0): E_4(\\mathbf{t}_1) = \\lnot 0 = 1$\n- $\\mathbf{t}_2 = (1): E_4(\\mathbf{t}_2) = \\lnot 1 = 0$\n\nMC/DC 覆盖情况检查：\n- **条件 $C_1$**：测试对 $(\\mathbf{t}_1, \\mathbf{t}_2) = ((0), (1))$ 仅在 $C_1$ 上不同。结果为 $1$ 和 $0$。$C_1$ 被覆盖。\n\n所有 $k=1$ 个条件都被覆盖。$\\mathcal{M}_4$ 的 MC/DC 覆盖率为 $k/n = 1/1 = 1.0$。\n\n**结果摘要**\n计算出的 MC/DC 覆盖率分数为：\n- $\\mathcal{M}_1$：$1.0$\n- $\\mathcal{M}_2$：$1.0$\n- $\\mathcal{M}_3$：$2/3 \\approx 0.667$\n- $\\mathcal{M}_4$：$1.0$",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the MC/DC coverage problem for four given modules.\n    \"\"\"\n\n    # Define the decision logic functions for each module.\n    # We use integers (0 for False, 1 for True) for compatibility with numpy.\n    def e1(c1, c2, c3, c4):\n        return int((c1 and c2) or (c3 and not c4))\n\n    def e2(c1, c2, c3):\n        return int(c1 and c2 and c3)\n\n    def e3(c1, c2, c3):\n        return int(c1 or (c2 and c3))\n\n    def e4(c1):\n        return int(not c1)\n\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (decision_function, test_suite, num_conditions)\n    test_cases = [\n        (e1, [\n            (0, 1, 0, 1),\n            (1, 1, 0, 1),\n            (1, 0, 0, 1),\n            (0, 0, 0, 0),\n            (0, 0, 1, 0),\n            (0, 0, 1, 1)\n        ], 4),\n        (e2, [\n            (1, 1, 1),\n            (0, 1, 1),\n            (1, 0, 1),\n            (1, 1, 0)\n        ], 3),\n        (e3, [\n            (0, 0, 0),\n            (1, 0, 0),\n            (0, 0, 1),\n            (0, 1, 1)\n        ], 3),\n        (e4, [\n            (0,),\n            (1,)\n        ], 1)\n    ]\n\n    def calculate_mcdc_coverage(decision_func, test_suite, n):\n        \"\"\"\n        Calculates MC/DC coverage for a given decision function, test suite, and number of conditions.\n        \n        Args:\n            decision_func: The Boolean decision function.\n            test_suite: A list of test vectors (tuples).\n            n: The number of conditions (int).\n            \n        Returns:\n            The MC/DC coverage as a float.\n        \"\"\"\n        tests = np.array(test_suite, dtype=int)\n        num_tests = len(tests)\n        covered_conditions = set()\n\n        # Pre-calculate decision outcomes for all tests for efficiency.\n        outcomes = np.array([decision_func(*test) for test in tests])\n        \n        # Iterate through each condition index i (from 0 to n-1)\n        for i in range(n):\n            is_condition_covered = False\n            # Iterate through all unique pairs of tests\n            for j1 in range(num_tests):\n                for j2 in range(j1 + 1, num_tests):\n                    test1 = tests[j1]\n                    test2 = tests[j2]\n                    \n                    # An \"independence pair\" for condition 'i' must meet two criteria:\n                    # 1. The two tests differ only in condition 'i'.\n                    # 2. The decision outcome changes between the two tests.\n                    \n                    # Criterion 1: Check if only condition 'i' differs.\n                    # A more efficient way using numpy:\n                    diff_mask = (test1 != test2)\n                    if np.sum(diff_mask) == 1 and diff_mask[i]:\n                        # This is an independence pair for condition 'i'.\n                        # Now check Criterion 2: decision outcome changes.\n                        if outcomes[j1] != outcomes[j2]:\n                            covered_conditions.add(i)\n                            is_condition_covered = True\n                            # Once a pair is found for condition 'i', we can move to the next condition.\n                            break\n                if is_condition_covered:\n                    break\n        \n        # Coverage is the fraction of covered conditions.\n        k = len(covered_conditions)\n        coverage = k / n if n > 0 else 0.0\n        return coverage\n\n    results = []\n    for func, suite, n_conds in test_cases:\n        coverage = calculate_mcdc_coverage(func, suite, n_conds)\n        # Round the result to three decimal places.\n        results.append(f\"{coverage:.3f}\")\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "基于机器学习的自主系统带来了一项新的认证挑战：如何确保系统在实际运行环境与训练数据分布不一致时仍然安全。一种关键的在线安全监控策略是实时检测输入数据的“分布偏移”（distribution shift）。本练习  将指导您构建一个基于马氏距离和假设检验的分布偏移检测器。您将学习如何使用卡方（$\\chi^2$）分布来计算关键性能指标——“虚警概率”（$\\alpha$），从而理解在确保安全性和维持系统可用性之间的权衡。",
            "id": "4239834",
            "problem": "一个信息物理系统（CPS）中的自主系统使用数字孪生（DT）来维护其训练数据分布的参考模型。为了满足安全监控的法规和认证目标，该系统必须以受控的误报概率（FAP）检测其运行数据流中具有统计显著性的分布偏移。考虑以下基于统计假设检验原理的检测机制：\n\n- 设训练分布为多元正态分布，其均值向量 $\\mu \\in \\mathbb{R}^d$ 和正定协方差矩阵 $\\Sigma \\in \\mathbb{R}^{d \\times d}$ 已知。\n- 设运行数据由 $n$ 个独立同分布（i.i.d.）的样本 $\\{x_i\\}_{i=1}^n$ 组成，其中每个 $x_i \\in \\mathbb{R}^d$。\n- 原假设 $H_0$ 断言运行数据与训练数据遵循相同的分布，即对于所有 $i \\in \\{1,\\dots,n\\}$，都有 $x_i \\sim \\mathcal{N}(\\mu, \\Sigma)$。\n- 定义聚合马氏平方统计量\n$$\nT = \\sum_{i=1}^{n} (x_i - \\mu)^\\top \\Sigma^{-1} (x_i - \\mu).\n$$\n- 决策规则为：对于选定的阈值 $\\tau \\geq 0$，如果 $T > \\tau$，则发出警报。在 $H_0$ 下，$T$ 服从自由度为 $n d$ 的卡方分布。\n\n任务：构建一个程序，给定 $(n, d, \\tau)$，计算在 $H_0$ 下的误报概率 $\\alpha$，\n$$\n\\alpha = \\Pr_{H_0}(T > \\tau),\n$$\n对于下方的每个测试用例，该概率应表示为十进制数（而非百分比）。此计算不涉及任何物理单位或角度单位。程序必须实现卡方分布的生存函数，以在 $H_0$ 下精确计算 $\\alpha$，而非通过仿真进行近似。\n\n测试套件：\n- 用例 $1$ (一般正常路径): $n = 50$, $d = 2$, $\\tau = 150.0$。\n- 用例 $2$ (阈值在零的边界情况): $n = 1$, $d = 2$, $\\tau = 0.0$。\n- 用例 $3$ (大样本情况，阈值在均值处): $n = 1000$, $d = 10$, $\\tau = 10000.0$。\n- 用例 $4$ (低自由度，中等阈值): $n = 5$, $d = 1$, $\\tau = 10.0$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result_1,result_2,result_3,result_4]$）。每个 $result_k$ 都必须是为用例 $k$ 计算出的 $\\alpha$ 值的浮点数。",
            "solution": "该问题要求为一个旨在检测自主系统中分布偏移的统计检验计算误报概率（以 $\\alpha$ 表示）。问题陈述提供了一个基于经典统计假设检验的全面且有效的框架。\n\n问题的有效性验证如下：\n- **科学依据**：该问题基于多元统计学中公认的原理。核心陈述，即检验统计量 $T$ 在原假设下服从卡方分布，是正确的。如果 $x_i \\sim \\mathcal{N}(\\mu, \\Sigma)$，那么马氏平方距离 $(x_i - \\mu)^\\top \\Sigma^{-1} (x_i - \\mu)$ 服从自由度为 $d$ 的卡方分布，记为 $\\chi^2_d$。检验统计量 $T$ 是 $n$ 个这样的独立同分布变量之和。卡方分布的一个基本性质是，独立的卡方变量之和也服从卡方分布，其自由度等于各个自由度之和。因此，$T = \\sum_{i=1}^{n} (x_i - \\mu)^\\top \\Sigma^{-1} (x_i - \\mu)$ 服从自由度为 $n \\times d$ 的卡方分布，即 $T \\sim \\chi^2_{nd}$。问题表述在数学上是合理的。\n- **适定性与完整性**：该问题是适定的。它为每个测试用例提供了所有必需的输入（$n, d, \\tau$），并明确定义了待计算量 $\\alpha$。输入与输出之间的关系是一个精确定义的统计函数，确保了唯一且有意义的解的存在。\n- **客观性与清晰性**：问题以精确、客观的数学语言陈述。涉及信息物理系统和数字孪生的背景为一项形式化的数学任务提供了现实的框架。\n\n该问题被认为是有效的，我们可以继续进行求解。\n\n任务是计算误报概率 $\\alpha$，即在原假设 $H_0$ 下，检验统计量 $T$ 超过阈值 $\\tau$ 的概率。其形式化表示为：\n$$\n\\alpha = \\Pr_{H_0}(T > \\tau)\n$$\n如前所述，在 $H_0$ 下，统计量 $T$ 服从自由度为 $k = nd$ 的卡方随机变量。因此，我们需要计算：\n$$\n\\alpha = \\Pr(X > \\tau) \\quad \\text{其中} \\quad X \\sim \\chi^2_k\n$$\n该概率对应于自由度为 $k$ 的卡方分布在点 $\\tau$ 处的生存函数（SF）。生存函数通常表示为 $S(x)$，是互补累积分布函数（CCDF），定义为 $S(x) = 1 - F(x)$，其中 $F(x)$ 是累积分布函数（CDF）。\n\n每个测试用例 $(n, d, \\tau)$ 的计算过程如下：\n$1$. 计算卡方分布的自由度：$k = n \\times d$。需要注意的是，$n$ 和 $d$ 都必须是正整数，在所有给定的测试用例中情况确实如此。\n$2$. 使用在阈值 $\\tau$ 处求值的 $\\chi^2_k$ 分布的生存函数来计算 $\\alpha$。这在计算上比 $1 - \\text{CDF}(\\tau)$ 更可取，特别是当 $\\tau$ 值很大以至于 $\\text{CDF}(\\tau)$ 接近 1 时，因为这样可以避免潜在的精度损失。\n\n我们将此过程应用于每个测试用例：\n\n- **用例 1**：$n = 50$, $d = 2$, $\\tau = 150.0$。\n  - 自由度 $k = 50 \\times 2 = 100$。\n  - 我们计算 $\\alpha_1 = \\Pr(\\chi^2_{100} > 150.0)$。\n\n- **用例 2**：$n = 1$, $d = 2$, $\\tau = 0.0$。\n  - 自由度 $k = 1 \\times 2 = 2$。\n  - 我们计算 $\\alpha_2 = \\Pr(\\chi^2_2 > 0.0)$。卡方分布定义在非负值上。作为一个连续分布，其值严格大于 0 的概率是 1，因为其值恰好为 0 的概率是零。因此，$\\alpha_2 = 1.0$。\n\n- **用例 3**：$n = 1000$, $d = 10$, $\\tau = 10000.0$。\n  - 自由度 $k = 1000 \\times 10 = 10000$。\n  - 我们计算 $\\alpha_3 = \\Pr(\\chi^2_{10000} > 10000.0)$。$\\chi^2_k$ 分布的均值是 $k$。在这里，阈值 $\\tau$ 恰好等于均值。对于大的 $k$，$\\chi^2_k$ 分布接近正态分布，变得更加对称。$\\chi^2_k$ 分布的中位数约为 $k - 2/3$。由于阈值略大于中位数，我们预计 $\\alpha_3$ 会略小于 $0.5$。\n\n- **用例 4**：$n = 5$, $d = 1$, $\\tau = 10.0$。\n  - 自由度 $k = 5 \\times 1 = 5$。\n  - 我们计算 $\\alpha_4 = \\Pr(\\chi^2_5 > 10.0)$。\n\n这些计算将使用 `scipy.stats.chi2.sf` 函数执行，该函数提供了卡方生存函数的数值稳健实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef solve():\n    \"\"\"\n    Computes the false alarm probability for detecting a distribution shift\n    based on an aggregated squared Mahalanobis statistic.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (n, d, tau), where:\n    # n: number of operational samples\n    # d: dimension of the data vectors\n    # tau: decision threshold\n    test_cases = [\n        (50, 2, 150.0),      # Case 1\n        (1, 2, 0.0),        # Case 2\n        (1000, 10, 10000.0),# Case 3\n        (5, 1, 10.0)        # Case 4\n    ]\n\n    results = []\n    for n, d, tau in test_cases:\n        # Under the null hypothesis H0, the aggregated squared Mahalanobis\n        # statistic T is distributed as a chi-square variable with k = n*d\n        # degrees of freedom.\n        # T ~ chi2(k) where k = n * d\n        degrees_of_freedom = n * d\n\n        # The false alarm probability alpha is the probability that T > tau,\n        # which is given by the survival function (sf) of the chi-square\n        # distribution, also known as the complementary cumulative\n        # distribution function (1 - CDF).\n        alpha = chi2.sf(tau, degrees_of_freedom)\n        \n        results.append(alpha)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver function.\nsolve()\n\n```"
        }
    ]
}