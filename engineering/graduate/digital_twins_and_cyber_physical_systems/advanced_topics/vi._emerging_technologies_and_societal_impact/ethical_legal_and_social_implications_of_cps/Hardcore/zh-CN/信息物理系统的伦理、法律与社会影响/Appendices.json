{
    "hands_on_practices": [
        {
            "introduction": "在设计诸如医疗设备或自动驾驶汽车等性命攸关的信息物理系统（CPS）时，确保高可靠性是一项核心的伦理要求。本练习将探讨如何应用可靠性工程中的标准模型，来量化一个系统的失效风险。通过分析一个采用冗余设计的传感器网络，您将学会使用“贝塔因子模型”来评估“共因失效”（Common Cause Failures）的影响，这是理解和减轻复杂系统风险的关键一步 。",
            "id": "4220283",
            "problem": "一家医院部署了一套用于闭环给药的信息物理系统（Cyber-Physical System, CPS），并通过一个数字孪生（Digital Twin）持续审计传感器的可靠性，以在“合理可行情况下尽可能低”（As Low As Reasonably Practicable, ALARP）原则下进行伦理风险管理。该CPS采用双冗余传感架构，其中任一传感器都能提供必要的测量值。在任务时间内，每个传感器的失效概率被建模为 $p$。对软件更新和环境应力源的审计报告了共因失效（Common Cause Failures, CCF）的存在，这由一个共因因子 $\\beta$ 来概括。$\\beta$ 定义为单个传感器失效概率中可归因于同时使两个冗余传感器都失效的机制的部分。$p$ 的剩余部分 $(1 - \\beta)$ 则归因于独立的、特定于传感器的失效机制。\n\n假设：\n- 在没有共因机制的条件下，两个传感器在统计上是独立的。\n- 在任务时间内，共因机制和独立失效机制是互斥的失效路径。\n- 任务时间内的失效概率 $p$ 足够小，以至于二阶项可以被视为由独立的失效机制引起，而无需在上述一阶分解之外对单传感器边际概率进行重新加权。\n\n从全概率定律和上述定义出发，推导双冗余传感器网络在任务时间内的系统级失效概率 $P_f$ 的混合表达式（用 $\\beta$ 和 $p$ 表示），并强调共因路径和独立路径各自的贡献。然后，对于 $p = 1.1 \\times 10^{-4}$ 和 $\\beta = 0.30$，计算 $P_f$ 的数值。将最终概率表示为小数，并将答案四舍五入到四位有效数字。无需单位。",
            "solution": "### 步骤1：提取已知条件\n- 系统架构：双冗余传感，任一传感器足以维持运行。系统仅在两个传感器都失效时才会失效。\n- 单传感器失效概率：$p$。\n- 共因因子：$\\beta$，定义为 $p$ 中可归因于同时使两个传感器都失效的机制的部分。\n- 独立失效贡献：$p$ 的 $(1 - \\beta)$ 部分归因于特定于传感器的失效机制。\n- 假设1：在没有共因机制的条件下，两个传感器在统计上是独立的。\n- 假设2：共因机制和独立失效机制是互斥的失效路径。\n- 假设3：$p$ 很小，允许将二阶项视为由独立机制引起而无需进一步修正。\n- 数值：$p = 1.1 \\times 10^{-4}$ 和 $\\beta = 0.30$。\n- 要求输出：推导系统级失效概率 $P_f$ 的表达式，并计算其数值，四舍五入到四位有效数字。\n\n### 步骤2：使用已知条件进行验证\n该问题是有效的。它采用了$\\beta$因子模型，这是可靠性工程中用于分析冗余系统中“共因失效”（CCF）的一种标准且成熟的方法。问题背景在科学上是恰当的，术语定义精确，所提供的数据和假设是自洽且一致的。不存在科学、逻辑或结构上的缺陷。\n\n### 步骤3：推导与求解\n\n令 $S_1$ 和 $S_2$ 分别表示传感器1和传感器2在任务时间内失效的事件。单个传感器的失效概率为 $P(S_1) = P(S_2) = p$。系统是双冗余的，意味着它仅在两个传感器都失效时才会失效。因此，系统级失效事件是交集 $S_1 \\cap S_2$，其概率为 $P_f = P(S_1 \\cap S_2)$。\n\n问题陈述指出，传感器失效可由两种互斥的路径引起：共因失效（CCF）和独立的、特定于传感器的失效。因此，我们可以根据这些路径分解系统失效概率。\n\n令 $p_{cc}$ 为单个传感器失效概率中归因于共因的部分，令 $p_{id}$ 为归因于独立原因的部分。根据问题对 $\\beta$ 的定义：\n- 单个传感器因共因失效的概率为 $p_{cc} = \\beta p$。\n- 单个传感器因独立原因失效的概率为 $p_{id} = (1 - \\beta)p$。\n\n单个传感器的总失效概率保持不变：$p = p_{cc} + p_{id} = \\beta p + (1-\\beta)p$。\n\n系统总失效概率 $P_f$ 是系统通过两种互斥路径失效的概率之和：\n1.  因共因事件导致的系统失效。\n2.  因两个传感器同时发生独立的失效导致的系统失效。\n\n我们来分析每条路径：\n\n**路径1：共因失效 (CCF)**\n问题将 $\\beta$ 定义为与“同时使两个冗余传感器都失效的机制”相关。根据此定义，一个共因失效事件会损害整个冗余对。发生此类事件并导致单个传感器失效的概率为 $\\beta p$。由于此事件使两个传感器都失效，因此系统因共因而失效的概率正是这个值。\n$$P_{\\text{系统失效 | CCF}} = \\beta p$$\n\n**路径2：独立失效 (IDF)**\n要使系统通过此路径失效，两个传感器都必须因其各自独立的、特定的原因而失效。单个传感器独立失效的概率为 $p_{id} = (1-\\beta)p$。\n根据这些失效在统计上是独立的假设，*两个*传感器都独立失效的概率是它们各自独立失效概率的乘积：\n$$P_{\\text{系统失效 | IDF}} = P(\\text{S1 独立失效}) \\times P(\\text{S2 独立失效})$$\n$$P_{\\text{系统失效 | IDF}} = p_{id} \\times p_{id} = ((1-\\beta)p)^2 = (1-\\beta)^2 p^2$$\n\n由于这两条失效路径是互斥的，总的系统级失效概率 $P_f$ 是它们概率之和：\n$$P_f = P_{\\text{系统失效 | CCF}} + P_{\\text{系统失效 | IDF}}$$\n$$P_f = \\beta p + (1-\\beta)^2 p^2$$\n这就是推导出的系统级失效概率的混合表达式，它强调了共因失效的线性贡献和独立失效的二次项贡献。\n\n现在，我们使用给定的参数计算 $P_f$ 的数值：$p = 1.1 \\times 10^{-4}$ 和 $\\beta = 0.30$。\n\n首先，将数值代入推导出的表达式：\n$$P_f = (0.30) \\times (1.1 \\times 10^{-4}) + (1 - 0.30)^2 \\times (1.1 \\times 10^{-4})^2$$\n\n计算每一项的贡献：\n共因失效项为：\n$$P_{\\text{CCF}} = 0.30 \\times 1.1 \\times 10^{-4} = 0.33 \\times 10^{-4} = 3.3 \\times 10^{-5}$$\n\n独立失效项为：\n$$(1 - 0.30)^2 = (0.70)^2 = 0.49$$\n$$(1.1 \\times 10^{-4})^2 = 1.21 \\times 10^{-8}$$\n$$P_{\\text{IDF}} = 0.49 \\times (1.21 \\times 10^{-8}) = 0.5929 \\times 10^{-8} = 5.929 \\times 10^{-9}$$\n\n将两项贡献相加，得到系统总失效概率：\n$$P_f = 3.3 \\times 10^{-5} + 5.929 \\times 10^{-9}$$\n为了相加，我们可以用相同的10的幂来表示它们：\n$$P_f = 3.3 \\times 10^{-5} + 0.005929 \\times 10^{-5}$$\n$$P_f = (3.3 + 0.005929) \\times 10^{-5}$$\n$$P_f = 3.305929 \\times 10^{-5}$$\n\n问题要求最终答案表示为小数，并四舍五入到四位有效数字。这个数是 $3.305929 \\times 10^{-5}$。前四位有效数字是 $3$、$3$、$0$ 和 $5$。第五位有效数字是 $9$，大于或等于 $5$，所以我们将第四位有效数字向上取整。第四位数字 $5$ 向上取整为 $6$。\n四舍五入后的值为 $3.306 \\times 10^{-5}$。\n\n表示为小数，即：\n$$P_f \\approx 0.00003306$$",
            "answer": "$$\\boxed{0.00003306}$$"
        },
        {
            "introduction": "信息物理系统越来越多地被用于分配关键资源，例如电网中的备用电力或公共服务。这引发了关于算法公平性的重要社会和伦理问题。本练习将介绍一种源自法律领域的标准化方法——“差异性影响分析”（Disparate Impact Analysis），用于审计算法决策是否存在对不同群体的偏见。通过计算选择率和差异性影响比率，您将学习如何将公平性这一抽象的伦理原则转化为可量化的工程指标 。",
            "id": "4220340",
            "problem": "一个城市运营着一个用于关键能源韧性的信息物理系统 (CPS)，该系统使用数字孪生 (DT) 在电网压力事件期间向家庭分配实时备用电池服务令牌。为了评估服务分配中的伦理公平性，该市采用了源自（美国）平等就业机会委员会 (EEOC) 五分之四规则的差异性影响评估方法，并将其推广到非雇佣性质的信息物理系统资源配置中。\n\n在一个稳定运营窗口期内汇总的数据显示了两个人口群体：一个弱势群体 $U$ 和一个优势群体 $P$。该 CPS 处理了来自群体 $U$ 的 $N_U$ 份申请，并向 $A_U$ 名申请人分配了令牌；它处理了来自群体 $P$ 的 $N_P$ 份申请，并向 $A_P$ 名申请人分配了令牌。在此期间，计数结果为 $N_U = 950$，$A_U = 171$，$N_P = 800$ 和 $A_P = 184$。\n\n从概率的频率主义解释出发，任何群体的选择率是获得分配结果的申请人数量与总申请人数量的比率。差异性影响比率定义为弱势群体的选择率除以所比较群体中的最高选择率。使用此定义和五分之四 ($0.8$) 规则作为合规性启发式方法，根据所提供的计数计算差异性影响比率，并确定在此数据下，该分配是否符合 $0.8$ 规则。\n\n以十进制形式表示您的最终答案，即差异性影响比率，并四舍五入到四位有效数字。不要包含任何单位。最终答案中不应提供任何中间量；只应报告差异性影响比率本身。",
            "solution": "我们从概率的频率主义解释开始，其中经验率是通过结果计数除以试验计数来计算的。对于任何群体 $G$，选择率 $r_G$ 定义为获得分配的案例数与申请人数的比率：\n$$\nr_G = \\frac{A_G}{N_G}\n$$\n在差异性影响框架下，差异性影响比率定义为弱势群体的选择率除以所比较群体中的最高选择率。设弱势群体为 $U$，其选择率为 $r_U$；优势群体为 $P$，其选择率为 $r_P$。令\n$$\nr_{\\max} = \\max\\{r_U, r_P\\}\n$$\n那么差异性影响比率 $\\rho$ 为\n$$\n\\rho = \\frac{r_U}{r_{\\max}}\n$$\n\n我们首先使用给定的计数计算选择率。对于弱势群体 $U$：\n$$\nr_U = \\frac{A_U}{N_U} = \\frac{171}{950}\n$$\n我们检查这个分数是否可以简化为有限小数。由于 $950 = 2 \\times 5^{2} \\times 19$，我们可以直接计算：\n$$\n\\frac{171}{950} = 0.18\n$$\n对于优势群体 $P$：\n$$\nr_P = \\frac{A_P}{N_P} = \\frac{184}{800}\n$$\n由于 $800 = 2^{5} \\times 5^{2}$，我们计算：\n$$\n\\frac{184}{800} = 0.23\n$$\n\n现在我们计算 $r_{\\max}$：\n$$\nr_{\\max} = \\max\\{0.18, 0.23\\} = 0.23\n$$\n因此，\n$$\n\\rho = \\frac{r_U}{r_{\\max}} = \\frac{0.18}{0.23}\n$$\n我们首先将这个比率表示为一个精确分数。注意到 $0.18 = \\frac{18}{100}$ 且 $0.23 = \\frac{23}{100}$，所以\n$$\n\\rho = \\frac{\\frac{18}{100}}{\\frac{23}{100}} = \\frac{18}{23}\n$$\n计算其十进制展开：\n$$\n\\frac{18}{23} \\approx 0.7826086956\\ldots\n$$\n将 $\\rho$ 四舍五入到四位有效数字，得到：\n$$\n\\rho \\approx 0.7826\n$$\n\n为了检验是否符合五分之四规则，我们将 $\\rho$ 与 $0.8$进行比较：\n$$\n0.7826  0.8,\n$$\n这表明在这些计数下，不符合 $0.8$ 规则。题目要求最终答案仅为差异性影响比率，并四舍五入到四位有效数字。因此，我们报告 $0.7826$。",
            "answer": "$$\\boxed{0.7826}$$"
        },
        {
            "introduction": "系统的安全性是其能够提供安全和公平服务的基础。一个易受攻击的系统无法保证其行为符合预期，可能导致灾难性后果。本练习将带您进入安全协议的形式化验证领域，通过一个指令通道重放攻击的场景，您将学习如何通过对时序、随机数（nonce）和时钟偏移进行精确的数学推理，来推导出一个保证系统弹性的严格判据 。",
            "id": "4220309",
            "problem": "给定一个用于数字孪生控制物理执行器的信息物理系统命令通道的形式化安全模型。命令由可信控制器发出，由执行器接收。每个命令都带有一个时间戳 $t_s$（单位：$\\mathrm{ms}$）和一个由控制器均匀随机生成且永不重用的唯一 nonce $n$。执行器维护一个容量为 $M$ 条目的有限缓存，用于存储最近见过的 nonce，并在溢出时使用先进先出（FIFO）策略驱逐最旧的 nonce。执行器的接受逻辑使用三个检查：安全时间戳、nonce 新鲜度和控制延迟安全性。\n\n环境假设如下：\n\n- 有界延迟：单向网络延迟的上限为 $\\Delta_{\\max}$（单位：$\\mathrm{ms}$）。攻击者可以重放任何先前观察到的数据包，但不能修改其字段。攻击者受到相同的网络延迟边界约束。\n- 有界时钟偏斜：接收方的本地时钟与发送方时钟之间的差异以 $|\\epsilon| \\le \\Sigma$（单位：$\\mathrm{ms}$）为界，这由安全时间同步保证。\n- 命令速率：合法命令以恒定速率 $r$（单位：$\\mathrm{messages}/\\mathrm{ms}$）发出，每个命令都带有一个新的 nonce。\n\n执行器当且仅当在接收时刻满足以下所有条件时，才会执行一个命令：\n\n- 时间戳新鲜度：$t_{\\text{now,local}} - t_s \\le W$，其中 $W$（单位：$\\mathrm{ms}$）是配置的新鲜度窗口。\n- Nonce 新鲜度：$n$ 不在 nonce 缓存中。\n- 控制延迟安全性：为保证在有偏斜情况下的实时安全性，执行器强制要求 $t_{\\text{now,local}} - t_s \\le D_{\\text{safe}} - \\Sigma$，其中 $D_{\\text{safe}}$（单位：$\\mathrm{ms}$）是为保证安全控制操作所允许的最大真实延迟。\n\n如果一个先前已被接受的命令在重放时被再次执行，则重放攻击成功。为了分析时钟偏斜下的最坏情况接受条件，使用一个经过充分检验的事实：如果 $|\\epsilon| \\le \\Sigma$，那么基于本地条件 $t_{\\text{now,local}} - t_s \\le W$ 的接受意味着真实时间年龄满足 $t_{\\text{now,real}} - t_{s,\\text{real}} \\le W + \\Sigma$。\n\n仅从上述基本定义和事实出发，推导出一个在该假设下既是必要条件又是充分条件的准则，以防止任何重放的命令被执行。你的推导必须用参数 $W$、$\\Sigma$、 $D_{\\text{safe}}$、$r$ 和 $M$ 来表示，所有参数均使用指定的统一单位。然后，实现一个程序，对测试套件中的每组参数，根据你推导的准则判断系统是否具有抗重放能力（输出 $True$）或不具抗重放能力（输出 $False$）。\n\n使用以下测试套件。所有时间单位均为 $\\mathrm{ms}$，$r$ 的单位为 $\\mathrm{messages}/\\mathrm{ms}$：\n\n- 测试 $1$（正常路径）：$(W, \\Sigma, D_{\\text{safe}}, r, M) = (100, 5, 80, 0.1, 10)$。\n- 测试 $2$（边界相等）：$(W, \\Sigma, D_{\\text{safe}}, r, M) = (100, 5, 80, 0.1, 8)$。\n- 测试 $3$（长窗口，缓存不足）：$(W, \\Sigma, D_{\\text{safe}}, r, M) = (1000, 10, 900, 0.2, 128)$。\n- 测试 $4$（小控制时域限制窗口）：$(W, \\Sigma, D_{\\text{safe}}, r, M) = (1000, 10, 50, 0.2, 11)$。\n- 测试 $5$（大偏斜，临界容量）：$(W, \\Sigma, D_{\\text{safe}}, r, M) = (30, 30, 100, 0.05, 3)$。\n\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[True,False,True,False,True]$）。\n\n注意：单向网络延迟上限 $\\Delta_{\\max}$ 是环境描述的一部分，但未作为输入参数出现在测试套件中，因为上述接受逻辑已经通过 $W$ 和 $D_{\\text{safe}}$ 内化了针对偏斜和延迟的最坏情况容限。所有中间推理过程均使用 $\\mathrm{ms}$ 和 $\\mathrm{messages}/\\mathrm{ms}$ 表示，并确保量纲一致性。",
            "solution": "目标是推导出一个必要且充分的准则，以防止重放的命令被执行器执行。如果一个命令数据包在被接受一次后，在被攻击者重放时又被第二次接受，则重放攻击成功。一个系统具有抗重放能力，当且仅当对于任何已被接受的命令数据包，该数据包的每一次后续重放都会被拒绝。\n\n一个命令数据包由其时间戳 $t_s$ 和 nonce $n$ 定义。为了让一个数据包在本地时间 $t_{\\text{now,local}}$ 被接受，它必须同时满足三个条件：\n1.  时间戳新鲜度：$t_{\\text{now,local}} - t_s \\le W$\n2.  Nonce 新鲜度：nonce $n$ 不在执行器的缓存中。\n3.  控制延迟安全性：$t_{\\text{now,local}} - t_s \\le D_{\\text{safe}} - \\Sigma$\n\n结合第一个和第三个条件，一个数据包仅在观测到的时间差 $t_{\\text{now,local}} - t_s$ 小于或等于 $W$ 和 $D_{\\text{safe}} - \\Sigma$ 时才被接受。我们可以定义一个有效接受窗口 $W_{\\text{eff}}$，它捕捉了这两个先验约束中最严格的一个：\n$$\nW_{\\text{eff}} = \\min(W, D_{\\text{safe}} - \\Sigma)\n$$\n因此，基于时间的接受条件简化为 $t_{\\text{now,local}} - t_s \\le W_{\\text{eff}}$。\n\n一次重放攻击涉及对同一个数据包 $(t_s, n)$ 的两次接受事件。设第一次合法接受发生在真实时间 $T_1$，第二次重放接受发生在真实时间 $T_2$，其中 $T_2 > T_1$。为了使攻击成功，该数据包必须在两个时间点都通过所有检查。具体来说，在 $T_2$ 时，时间戳检查必须通过，但对攻击者而言，nonce 检查必须失败。也就是说，在 $T_2$ 时，在 $T_1$ 时被添加到缓存中的 nonce $n$ 必须已不在缓存中。\n\n为了分析时序，我们必须在一个通用的参考系中进行，即真实时间。问题提供了一个连接本地时钟检查和真实时间的关键桥梁：基于 $t_{\\text{now,local}} - t_s \\le W_{\\text{eff}}$ 的接受意味着数据包的真实年龄 $T_{\\text{accept}} - T_s$ 满足 $T_{\\text{accept}} - T_s \\le W_{\\text{eff}} + \\Sigma$，其中 $T_s$ 是发送的真实时间。\n\n这定义了一个真实时间上的漏洞窗口。一个在真实时间 $T_s$ 发送的数据包可以在任何满足 $T_s \\le T_{\\text{accept}} \\le T_s + W_{\\text{eff}} + \\Sigma$ 的真实时间 $T_{\\text{accept}}$ 被接受。下界 $T_s$ 是由于因果关系（数据包不能在发送前到达），而上界则从接受逻辑中推导得出。这个真实时间漏洞窗口的总持续时间 $T_{\\text{vulnerable}}$ 是最晚和最早可能接受时间之差：\n$$\nT_{\\text{vulnerable}} = (T_s + W_{\\text{eff}} + \\Sigma) - T_s = W_{\\text{eff}} + \\Sigma\n$$\n攻击者只有在能在此窗口内找到两个接受时间 $T_1$ 和 $T_2$，且到 $T_2$ 时 nonce 已被驱逐的情况下才能成功。\n\n对抗重放的防御机制是 nonce 缓存。当一个命令在时间 $T_1$ 被接受时，其 nonce $n$ 被添加到大小为 $M$ 的 FIFO 缓存中。一旦 $M$ 个新的合法命令被接受，这个 nonce 就会被驱逐。由于合法命令以每毫秒 $r$ 条消息的恒定速率发出，发出（并随后接受）$M$ 个新命令所需的真实时间是 $M/r$。这个持续时间是 nonce 在缓存中的真实时间驻留期 $T_{\\text{cache}}$：\n$$\nT_{\\text{cache}} = \\frac{M}{r}\n$$\n\n为了使系统具有抗重放能力，必须保证 nonce 在整个真实时间漏洞窗口期间都保留在缓存中。如果攻击者在窗口内的任何时间 $T_2$ 重放数据包，nonce 检查（$n$ 不在缓存中）必须失败。这当且仅当缓存驻留时间严格大于漏洞窗口的持续时间时才能得到保证。如果两者相等，攻击者可以将重放时间安排在 nonce 被驱逐的精确时刻，此时“不在缓存中”的检查将通过。\n\n因此，抗重放能力的必要且充分条件是：\n$$\nT_{\\text{cache}} > T_{\\text{vulnerable}}\n$$\n代入这些持续时间的表达式，我们得到：\n$$\n\\frac{M}{r} > W_{\\text{eff}} + \\Sigma\n$$\n代入 $W_{\\text{eff}}$ 的定义，得到以输入参数表示的最终准则：\n$$\n\\frac{M}{r} > \\min(W, D_{\\text{safe}} - \\Sigma) + \\Sigma\n$$\n此不等式等价于 $M > r \\cdot (\\min(W, D_{\\text{safe}} - \\Sigma) + \\Sigma)$。当且仅当此条件成立时，系统被认为是抗重放的。如果 $D_{\\text{safe}} - \\Sigma \\le 0$，有效窗口 $W_{\\text{eff}}$ 可能为非正值，但逻辑仍然成立。一个非正的 $W_{\\text{eff}}$ 会严重限制或阻止接受，但形式化准则仍然能正确地判断抗重放能力。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the cyber-physical system replay resilience problem for a suite of test cases.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    # Each tuple is (W, Sigma, D_safe, r, M).\n    test_cases = [\n        (100, 5, 80, 0.1, 10),      # Test 1\n        (100, 5, 80, 0.1, 8),       # Test 2\n        (1000, 10, 900, 0.2, 128),   # Test 3\n        (1000, 10, 50, 0.2, 11),     # Test 4\n        (30, 30, 100, 0.05, 3),      # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        W, Sigma, D_safe, r, M = case\n\n        # The system is replay-resilient if and only if the following strict inequality holds:\n        # M  r * (min(W, D_safe - Sigma) + Sigma)\n        #\n        # Derivation:\n        # 1. The effective acceptance window based on local clock checks is\n        #    W_eff = min(W, D_safe - Sigma).\n        # 2. Based on the problem's fact about clock skew, the real-time vulnerability\n        #    window duration is T_vulnerable = W_eff + Sigma. This is the maximum\n        #    real-time span between the earliest and latest possible acceptance of a packet.\n        # 3. The real-time residency of a nonce in the FIFO cache of size M, with a\n        #    command rate of r, is T_cache = M / r.\n        # 4. For security, the nonce must remain in the cache longer than the packet is\n        #    vulnerable to acceptance. This requires a strict inequality to prevent\n        #    attacks at the boundary moment of eviction.\n        #    T_cache  T_vulnerable  =  M / r  W_eff + Sigma.\n        #    This is equivalent to M  r * (W_eff + Sigma).\n        \n        # Calculate the effective acceptance window in ms.\n        w_eff = min(W, D_safe - Sigma)\n        \n        # Calculate the right-hand side of the inequality. This represents the minimum\n        # number of cache slots required to outlast the vulnerability window.\n        required_cache_slots = r * (w_eff + Sigma)\n        \n        # Check if the available cache capacity M is strictly greater than the required capacity.\n        is_resilient = M > required_cache_slots\n        \n        results.append(is_resilient)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The boolean values True/False must be capitalized as per Python's str() conversion.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}