{
    "hands_on_practices": [
        {
            "introduction": "信息物理系统 (CPS) 的可靠性是其在医疗、交通等关键领域安全运行的基石。本练习将探讨如何量化一个采用双冗余传感器架构的 CPS 的系统级故障概率 。你将应用可靠性工程中广泛使用的 Beta 因子模型，来处理共因失效 (Common Cause Failures, CCF)——即单一原因导致多个冗余组件同时失效的风险，这是设计高可靠性系统时必须面对的核心挑战。通过这个实践，你将学会如何将系统设计原则转化为概率模型，从而进行定量的风险评估。",
            "id": "4220283",
            "problem": "一家医院部署了一套用于闭环给药的赛博物理系统（CPS），其数字孪生（Digital Twin）在该系统上持续审计传感器可靠性，以根据“合理可行最低”（ALARP）原则进行伦理风险管理。该CPS使用双冗余传感架构，其中任一传感器均可提供必要的测量。每个传感器在任务时间内的单传感器失效概率模型化为 $p$。对软件更新和环境应激源的审计报告了共因失效（CCF）的存在，这由一个共因因子 $\\beta$ 概括，定义为单传感器失效概率中可归因于同时使两个冗余传感器都失能的机制的部分。$p$ 的剩余部分 $(1 - \\beta)$ 归因于特殊的、传感器特定的失效机制。\n\n假设：\n- 在没有共因机制的条件下，两个传感器在统计上是独立的。\n- 在任务时间内，共因机制和特殊机制是互斥的失效路径。\n- 任务时间失效概率 $p$ 足够小，以至于二阶项可以被视为由独立的特殊机制引起，而无需在上述主阶分解之外对单传感器边际进行重新加权。\n\n从全概率定律和上述定义出发，推导双冗余传感器网络在任务时间内的系统级失效概率 $P_f$ 的混合表达式（用 $\\beta$ 和 $p$ 表示），并强调共因路径和独立路径各自的贡献。然后，对于 $p = 1.1 \\times 10^{-4}$ 和 $\\beta = 0.30$，计算 $P_f$ 的数值。将最终概率表示为小数，并将答案四舍五入到四位有效数字。无需单位。",
            "solution": "首先验证问题陈述，以确保其科学基础可靠、问题设定合理、客观且完整。\n\n### 第1步：提取已知条件\n-   系统架构：双冗余传感，任一传感器足以维持运行。当且仅当两个传感器都失效时，系统才会失效。\n-   单传感器失效概率：$p$。\n-   共因因子：$\\beta$，定义为 $p$ 中可归因于同时使两个传感器都失能的机制的部分。\n-   特殊失效贡献：$p$ 的 $(1 - \\beta)$ 部分归因于传感器特定的失效机制。\n-   假设1：在没有共因机制的条件下，两个传感器在统计上是独立的。\n-   假设2：共因机制和特殊机制是互斥的失效路径。\n-   假设3：$p$ 足够小，允许将二阶项视为由独立机制引起而无需进一步修正。\n-   数值：$p = 1.1 \\times 10^{-4}$ 和 $\\beta = 0.30$。\n-   要求输出：推导系统级失效概率 $P_f$ 的表达式，并计算其数值，四舍五入到四位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n问题是有效的。它采用了 Beta 因子模型，这是可靠性工程中分析冗余系统中“共因失效”（CCF）的一种标准且成熟的方法。问题背景科学上是恰当的，术语定义精确，所提供的数据和假设是自洽且一致的。不存在科学、逻辑或结构上的缺陷。\n\n### 第3步：推导与求解\n\n设 $S_1$ 和 $S_2$ 分别为传感器1和传感器2在任务时间内失效的事件。单传感器失效概率给定为 $P(S_1) = P(S_2) = p$。系统是双冗余的，意味着只有当两个传感器都失效时系统才会失效。因此，系统级失效事件是交集 $S_1 \\cap S_2$，其概率为 $P_f = P(S_1 \\cap S_2)$。\n\n问题陈述指出，传感器失效可由两种互斥的路径引起：共因失效（CCF）和特殊的、传感器特定的失效。因此，我们可以根据这些路径分解系统失效概率。\n\n设 $p_{cc}$ 是单传感器失效概率中可归因于共因的部分，而 $p_{id}$ 是可归因于特殊原因的部分。根据问题对 $\\beta$ 的定义：\n-   单个传感器因共因失效的概率为 $p_{cc} = \\beta p$。\n-   单个传感器因特殊原因失效的概率为 $p_{id} = (1 - \\beta)p$。\n\n单个传感器的总失效概率是守恒的：$p = p_{cc} + p_{id} = \\beta p + (1-\\beta)p$。\n\n总的系统失效概率 $P_f$ 是通过两种互斥路径导致系统失效的概率之和：\n1.  因共因事件导致的系统失效。\n2.  因两个传感器同时发生独立的特殊失效导致的系统失效。\n\n让我们分析每条路径：\n\n**路径1：共因失效 (CCF)**\n问题将 $\\beta$ 定义为与“同时使两个冗余传感器都失能的机制”相关。根据此定义，一个共因失效事件会危及整个冗余对。发生此类事件并导致单个传感器失效的概率为 $\\beta p$。由于该事件使两个传感器都失能，因此系统因共因而失效的概率恰好是这个值。\n$$P_{\\text{system failure | CCF}} = \\beta p$$\n\n**路径2：独立特殊失效 (IDF)**\n要使系统通过此路径失效，两个传感器都必须因其各自独立的、特定的原因而失效。单个传感器发生特殊失效的概率是 $p_{id} = (1-\\beta)p$。\n鉴于这些失效在统计上是独立的假设，*两个*传感器都发生特殊失效的概率是它们各自特殊失效概率的乘积：\n$$P_{\\text{system failure | IDF}} = P(\\text{S1 fails idio.}) \\times P(\\text{S2 fails idio.})$$\n$$P_{\\text{system failure | IDF}} = p_{id} \\times p_{id} = ((1-\\beta)p)^2 = (1-\\beta)^2 p^2$$\n\n由于这两条失效路径是互斥的，总的系统级失效概率 $P_f$ 是它们概率的和：\n$$P_f = P_{\\text{system failure | CCF}} + P_{\\text{system failure | IDF}}$$\n$$P_f = \\beta p + (1-\\beta)^2 p^2$$\n这就是推导出的系统级失效概率的混合表达式，它强调了来自共因失效的线性贡献和来自独立失效的二次方贡献。\n\n现在，我们使用给定的参数计算 $P_f$ 的数值：$p = 1.1 \\times 10^{-4}$ 和 $\\beta = 0.30$。\n\n首先，将数值代入推导出的表达式中：\n$$P_f = (0.30) \\times (1.1 \\times 10^{-4}) + (1 - 0.30)^2 \\times (1.1 \\times 10^{-4})^2$$\n\n计算每一项的贡献：\n共因失效项为：\n$$P_{\\text{CCF}} = 0.30 \\times 1.1 \\times 10^{-4} = 0.33 \\times 10^{-4} = 3.3 \\times 10^{-5}$$\n\n独立失效项为：\n$$(1 - 0.30)^2 = (0.70)^2 = 0.49$$\n$$(1.1 \\times 10^{-4})^2 = 1.21 \\times 10^{-8}$$\n$$P_{\\text{IDF}} = 0.49 \\times (1.21 \\times 10^{-8}) = 0.5929 \\times 10^{-8} = 5.929 \\times 10^{-9}$$\n\n将两项贡献相加，得到总的系统失效概率：\n$$P_f = 3.3 \\times 10^{-5} + 5.929 \\times 10^{-9}$$\n为了将它们相加，我们可以用相同的10的幂来表示它们：\n$$P_f = 3.3 \\times 10^{-5} + 0.0005929 \\times 10^{-5}$$\n$$P_f = (3.3 + 0.0005929) \\times 10^{-5}$$\n$$P_f = 3.3005929 \\times 10^{-5}$$\n\n问题要求最终答案以小数形式表示，并四舍五入到四位有效数字。该数字为 $3.3005929 \\times 10^{-5}$。前四位有效数字是 $3$、$3$、$0$ 和 $0$。第五位有效数字是 $5$，等于 $5$，所以我们将第四位有效数字向上取整。第四位数字 $0$ 向上取整为 $1$。\n四舍五入后的值为 $3.301 \\times 10^{-5}$。\n\n表示为小数，即：\n$$P_f \\approx 0.00003301$$",
            "answer": "$$\\boxed{0.00003301}$$"
        },
        {
            "introduction": "除了安全性和可靠性，公平性是信息物理系统伦理考量中的另一个重要支柱，尤其是在那些负责分配稀缺资源的系统中。本练习将带你进入算法公平性的审计实践，通过一个为家庭分配应急能源的 CPS 案例，来评估其决策是否存在歧视性影响 。你将使用源自美国平等就业机会委员会 (EEOC) 的“五分之四规则”，这是一个经典的法律启发式方法，来量化不同群体间服务分配结果的差异。这项实践旨在让你掌握一种量化和评估 CPS 公平性的实用工具，以识别和解决潜在的系统性偏见。",
            "id": "4220340",
            "problem": "一个城市运营着一个用于关键能源韧性的信息物理系统 (CPS)，该系统使用数字孪生 (DT) 在电网压力事件期间向住户分配实时电池备用服务令牌。为了评估服务分配中的伦理公平性，该市采用了源自 Equal Employment Opportunity Commission (EEOC) 五分之四规则的差异性影响评估方法，并将其推广到非雇佣场景下的CPS资源配置中。\n\n在一个稳定运营窗口期内汇总的数据显示了两个人口群体：一个弱势群体 $U$ 和一个优势群体 $P$。该CPS处理了来自群体 $U$ 的 $N_U$ 份申请，并向 $A_U$ 名申请人分配了令牌；同时处理了来自群体 $P$ 的 $N_P$ 份申请，并向 $A_P$ 名申请人分配了令牌。在此期间，统计计数为 $N_U = 950$，$A_U = 171$，$N_P = 800$，以及 $A_P = 184$。\n\n从频率主义的概率解释出发，任何群体的选择率是已分配结果数与总申请人数的比率。差异性影响比率定义为弱势群体的选择率除以所比较群体中的最高选择率。使用此定义和五分之四 ($0.8$) 规则作为合规性启发式方法，根据所提供的计数计算差异性影响比率，并判断在此数据下，该分配是否符合 $0.8$ 规则。\n\n将你的最终答案表示为差异性影响比率的小数形式，并四舍五入到四位有效数字。不包含任何单位。最终答案中不要提供任何中间量；只应报告差异性影响比率本身。",
            "solution": "我们从频率主义的概率解释开始，其中经验比率是通过结果计数除以试验计数来计算的。对于任何群体 $G$，选择率 $r_G$ 定义为已分配案例数与申请人数的比率：\n$$\nr_G = \\frac{A_G}{N_G}.\n$$\n在差异性影响框架下，差异性影响比率定义为弱势群体的选择率除以所比较群体中的最高选择率。设弱势群体为 $U$，其选择率为 $r_U$；优势群体为 $P$，其选择率为 $r_P$。令\n$$\nr_{\\max} = \\max\\{r_U, r_P\\}.\n$$\n那么差异性影响比率 $\\rho$ 是\n$$\n\\rho = \\frac{r_U}{r_{\\max}}.\n$$\n\n我们首先使用给定的计数计算选择率。对于弱势群体 $U$，\n$$\nr_U = \\frac{A_U}{N_U} = \\frac{171}{950}.\n$$\n我们检查这个分数是否可以简化为有限小数。由于 $950 = 2 \\times 5^{2} \\times 19$，我们可以直接计算：\n$$\n\\frac{171}{950} = 0.18.\n$$\n对于优势群体 $P$，\n$$\nr_P = \\frac{A_P}{N_P} = \\frac{184}{800}.\n$$\n由于 $800 = 2^{5} \\times 5^{2}$，我们计算：\n$$\n\\frac{184}{800} = 0.23.\n$$\n\n现在我们计算 $r_{\\max}$：\n$$\nr_{\\max} = \\max\\{0.18, 0.23\\} = 0.23.\n$$\n因此，\n$$\n\\rho = \\frac{r_U}{r_{\\max}} = \\frac{0.18}{0.23}.\n$$\n我们首先将这个比率表示为一个精确分数。注意到 $0.18 = \\frac{18}{100}$ 且 $0.23 = \\frac{23}{100}$，所以\n$$\n\\rho = \\frac{\\frac{18}{100}}{\\frac{23}{100}} = \\frac{18}{23}.\n$$\n计算其小数展开：\n$$\n\\frac{18}{23} \\approx 0.7826086956\\ldots\n$$\n将 $\\rho$ 四舍五入到四位有效数字得到：\n$$\n\\rho \\approx 0.7826.\n$$\n\n为了检验是否符合五分之四规则，将 $\\rho$ 与 $0.8$ 进行比较：$0.7826  0.8$，这表明在这些计数下不符合 $0.8$ 规则。题目要求最终答案仅为差异性影响比率，并四舍五入到四位有效数字。因此，我们报告 $0.7826$。",
            "answer": "$$\\boxed{0.7826}$$"
        },
        {
            "introduction": "现实世界中的 CPS 设计往往需要在性能、安全性、公平性等多个相互冲突的目标之间进行权衡。本练习将理论与实践相结合，要求你通过编写一个仿真程序来探索这些复杂的伦理权衡 。你将为一个简化的 CPS 实现一个可解释的、基于规则的控制器，并评估不同参数设置如何影响系统的整体性能、安全违规率以及不同用户群体间的公平性差距。通过定义一个综合性的“社会损失函数”，这项实践让你能够量化和系统地分析设计决策在不同伦理维度上的影响，从而更深刻地理解 CPS 设计中的多目标挑战。",
            "id": "4220301",
            "problem": "给定一个离散时间、单输入、单输出的线性时不变设备，该设备模拟一个简化的信息物理系统。其状态演化由以下基本状态更新方程定义\n$$\nx_{t+1} = a \\, x_t + b \\, u_t + w_t,\n$$\n其中，$x_t$ 是离散时间 $t$ 的标量状态，$u_t$ 是标量控制输入，$a$ 和 $b$ 是常数系数，$w_t$ 是已知的扰动序列。目标是使用一种可解释的基于规则的策略，在遵守安全约束的同时，跟踪一个已知的参考序列 $\\{r_t\\}_{t=0}^{T-1}$。其可解释性源于少数基于跟踪误差和上下文变量的、简单且人类可理解的规则。\n\n将跟踪误差定义为\n$$\ne_t = r_t - x_t.\n$$\n控制器是一个基于规则的策略，具有三种模式，由阈值和增益参数化，并由一个线性上下文项增强。令 $c \\in \\{-1, +1\\}$ 表示两个不同群体的二元上下文指标。该策略的运作方式如下：\n- 如果 $\\lvert e_t \\rvert \\ge \\theta_{\\mathrm{hi}}$，使用高增益规则 $u_t^{\\mathrm{raw}} = k_{\\mathrm{hi}} \\, e_t + b_{\\mathrm{ctx}} \\, c$。\n- 否则如果 $\\lvert e_t \\rvert \\le \\theta_{\\mathrm{lo}}$，使用低增益规则 $u_t^{\\mathrm{raw}} = k_{\\mathrm{lo}} \\, e_t + b_{\\mathrm{ctx}} \\, c$。\n- 否则，使用中增益规则 $u_t^{\\mathrm{raw}} = k_{\\mathrm{mid}} \\, e_t + b_{\\mathrm{ctx}} \\, c$。\n\n为了反映执行器的限制，施加的控制在极限值 $U_{\\mathrm{sat}}$ 处饱和：\n$$\nu_t = \\mathrm{clip}\\left(u_t^{\\mathrm{raw}}, -U_{\\mathrm{sat}}, U_{\\mathrm{sat}}\\right).\n$$\n\n安全性通过两个约束进行评估：状态安全边界 $\\lvert x_t \\rvert \\le X_{\\max}$ 和控制安全边界 $\\lvert u_t \\rvert \\le U_{\\mathrm{safe}}$。请注意，$U_{\\mathrm{safe}}$ 可能小于或等于 $U_{\\mathrm{sat}}$；即使执行器由于 $U_{\\mathrm{sat}}$ 可以物理上施加 $u_t$，违反 $U_{\\mathrm{safe}}$ 也会导致安全违规。\n\n您必须在长度为 $T$ 的有限时域内，针对两种上下文 $c \\in \\{-1, +1\\}$ 评估以下性能指标，每次模拟使用相同的设备、参考序列和扰动序列：\n- 特定群体的均方根误差 (RMSE):\n$$\n\\mathrm{RMSE}(c) = \\sqrt{\\frac{1}{T} \\sum_{t=0}^{T-1} e_t(c)^2}.\n$$\n- 两个群体的总体平均 RMSE：\n$$\n\\mathrm{RMSE}_{\\mathrm{overall}} = \\frac{1}{2}\\left(\\mathrm{RMSE}(+1) + \\mathrm{RMSE}(-1)\\right).\n$$\n- 公平性差异，即群体 RMSE 的绝对差值：\n$$\n\\Delta_{\\mathrm{fair}} = \\left| \\mathrm{RMSE}(+1) - \\mathrm{RMSE}(-1) \\right|.\n$$\n- 安全违规率，即在两个群体中，状态或控制违反其安全边界的时间步数所占的比例：\n$$\n\\rho_{\\mathrm{viol}} = \\frac{1}{2T} \\sum_{c \\in \\{-1,+1\\}} \\sum_{t=0}^{T-1} \\mathbf{1}\\left( \\lvert x_t(c) \\rvert  X_{\\max} \\ \\ \\text{or} \\ \\ \\lvert u_t(c) \\rvert  U_{\\mathrm{safe}} \\right),\n$$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数。\n\n为了量化性能、安全性和公平性之间的权衡，定义一个带有非负权重 $\\alpha, \\beta, \\gamma$ 的复合社会损失：\n$$\nL = \\alpha \\, \\mathrm{RMSE}_{\\mathrm{overall}} + \\beta \\, \\rho_{\\mathrm{viol}} + \\gamma \\, \\Delta_{\\mathrm{fair}}.\n$$\n\n假设所有模拟都遵循以下基本条件：\n- 初始状态为 $x_0 = 0$。\n- 在一个测试用例中，两种上下文 $c \\in \\{-1, +1\\}$ 使用相同的参考序列 $\\{r_t\\}$ 和扰动序列 $\\{w_t\\}$。\n- 在时间 $t$ 的误差 $e_t$ 是使用当前状态 $x_t$ 计算的，控制 $u_t$ 是根据规则计算并施加的，然后下一个状态 $x_{t+1}$ 是通过设备方程计算的。\n\n您的任务是实现一个程序，对于下面的每个测试用例，模拟双群组闭环系统，计算 $\\mathrm{RMSE}_{\\mathrm{overall}}$、$\\rho_{\\mathrm{viol}}$、$\\Delta_{\\mathrm{fair}}$ 和 $L$，并输出这些保留到 $6$ 位小数的值。\n\n测试套件：\n- 案例 1 (理想情况，具有轻微的上下文偏差和充足的安全裕度):\n  - 设备：$a = 0.9$， $b = 0.4$，时域 $T = 60$。\n  - 参考：阶跃序列 $r_t = 0$ (当 $t  10$)，$r_t = 1.0$ (当 $t \\ge 10$)。\n  - 扰动：$w_t = 0.02 \\sin\\left( \\frac{2\\pi t}{15} \\right)$ (当 $t = 0, \\dots, 59$)。\n  - 控制器阈值：$\\theta_{\\mathrm{lo}} = 0.05$， $\\theta_{\\mathrm{hi}} = 0.5$。\n  - 增益：$k_{\\mathrm{lo}} = 0.3$， $k_{\\mathrm{mid}} = 0.8$， $k_{\\mathrm{hi}} = 1.2$。\n  - 上下文偏差：$b_{\\mathrm{ctx}} = 0.1$。\n  - 饱和与安全：$U_{\\mathrm{sat}} = 2.0$， $U_{\\mathrm{safe}} = 1.5$， $X_{\\max} = 2.0$。\n  - 权重：$\\alpha = 1.0$， $\\beta = 3.0$， $\\gamma = 2.0$。\n- 案例 2 (更紧的安全约束，更激进的高增益，预期存在约束压力):\n  - 设备：$a = 0.9$， $b = 0.4$，时域 $T = 60$。\n  - 参考：阶跃序列 $r_t = 0$ (当 $t  10$)，$r_t = 1.0$ (当 $t \\ge 10$)。\n  - 扰动：$w_t = 0.02 \\sin\\left( \\frac{2\\pi t}{15} \\right)$。\n  - 控制器阈值：$\\theta_{\\mathrm{lo}} = 0.05$， $\\theta_{\\mathrm{hi}} = 0.5$。\n  - 增益：$k_{\\mathrm{lo}} = 0.3$， $k_{\\mathrm{mid}} = 0.8$， $k_{\\mathrm{hi}} = 1.5$。\n  - 上下文偏差：$b_{\\mathrm{ctx}} = 0.15$。\n  - 饱和与安全：$U_{\\mathrm{sat}} = 2.0$， $U_{\\mathrm{safe}} = 0.7$， $X_{\\max} = 1.0$。\n  - 权重：$\\alpha = 1.0$， $\\beta = 3.0$， $\\gamma = 2.0$。\n- 案例 3 (通过零上下文偏差和保守增益实现公平中性策略):\n  - 设备：$a = 0.95$， $b = 0.3$，时域 $T = 60$。\n  - 参考：斜坡阶跃 $r_t = 0$ (当 $t  5$)，$r_t = 0.5$ (当 $5 \\le t  30$)，$r_t = 1.0$ (当 $t \\ge 30$)。\n  - 扰动：$w_t = 0$ (对于所有 $t$)。\n  - 控制器阈值：$\\theta_{\\mathrm{lo}} = 0.02$， $\\theta_{\\mathrm{hi}} = 0.3$。\n  - 增益：$k_{\\mathrm{lo}} = 0.2$， $k_{\\mathrm{mid}} = 0.5$， $k_{\\mathrm{hi}} = 0.7$。\n  - 上下文偏差：$b_{\\mathrm{ctx}} = 0.0$。\n  - 饱和与安全：$U_{\\mathrm{sat}} = 1.0$， $U_{\\mathrm{safe}} = 1.0$， $X_{\\max} = 2.0$。\n  - 权重：$\\alpha = 1.0$， $\\beta = 3.0$， $\\gamma = 2.0$。\n- 案例 4 (更高扰动环境，中等增益，中等安全约束):\n  - 设备：$a = 0.9$， $b = 0.4$，时域 $T = 60$。\n  - 参考：围绕设定点的正弦波 $r_t = 0.8 + 0.2 \\sin\\left( \\frac{2\\pi t}{20} \\right)$。\n  - 扰动：$w_t = 0.2 \\sin\\left( \\frac{2\\pi t}{10} \\right)$。\n  - 控制器阈值：$\\theta_{\\mathrm{lo}} = 0.05$， $\\theta_{\\mathrm{hi}} = 0.4$。\n  - 增益：$k_{\\mathrm{lo}} = 0.4$， $k_{\\mathrm{mid}} = 0.9$， $k_{\\mathrm{hi}} = 1.1$。\n  - 上下文偏差：$b_{\\mathrm{ctx}} = 0.05$。\n  - 饱和与安全：$U_{\\mathrm{sat}} = 2.0$， $U_{\\mathrm{safe}} = 1.2$， $X_{\\max} = 1.2$。\n  - 权重：$\\alpha = 1.0$， $\\beta = 3.0$， $\\gamma = 2.0$。\n\n您的程序应生成单行输出，其中包含所有案例的结果，格式为一个逗号分隔的列表，并用方括号括起来。对于每个案例，返回一个包含四个浮点数的列表，顺序为 $[\\mathrm{RMSE}_{\\mathrm{overall}}, \\rho_{\\mathrm{viol}}, \\Delta_{\\mathrm{fair}}, L]$，每个值都四舍五入到 $6$ 位小数。因此，最终输出应该是一个列表的列表，例如：$[[x_1, y_1, z_1, \\ell_1],[x_2, y_2, z_2, \\ell_2],[x_3, y_3, z_3, \\ell_3],[x_4, y_4, z_4, \\ell_4]]$。",
            "solution": "该问题要求在一个基于规则的反馈控制器下，模拟一个离散时间、单输入单输出 (SISO) 的线性时不变 (LTI) 系统。模拟需要针对两个不同的上下文群体进行，并计算多个性能、安全性和公平性指标，最终汇总为一个复合社会损失函数。该问题定义明确，有科学依据，并包含得出唯一解所需的所有必要信息。\n\n首先，我们必须为由二元上下文指标 $c \\in \\{-1, +1\\}$ 标识的单个上下文群体，形式化模拟过程。系统状态在有限时域 $T$ 内演化。\n\n系统在时间 $t=0, 1, \\dots, T$ 的状态由 $x_t$ 表示。初始状态给定为 $x_0 = 0$。模拟从时间步 $t$ 从 $0$ 到 $T-1$ 迭代进行。\n\n对于每个时间步 $t \\in \\{0, 1, \\dots, T-1\\}$：\n1.  **计算跟踪误差**：跟踪误差 $e_t$ 是参考信号 $r_t$ 与当前状态 $x_t$ 之间的差值：\n    $$\n    e_t = r_t - x_t\n    $$\n2.  **应用基于规则的控制策略**：原始控制输入 $u_t^{\\mathrm{raw}}$ 基于误差 $e_t$ 的大小和上下文 $c$ 来确定。该策略由三个规则定义：\n    $$\n    u_t^{\\mathrm{raw}} =\n    \\begin{cases}\n    k_{\\mathrm{hi}} \\, e_t + b_{\\mathrm{ctx}} \\, c  \\text{if } \\lvert e_t \\rvert \\ge \\theta_{\\mathrm{hi}} \\\\\n    k_{\\mathrm{lo}} \\, e_t + b_{\\mathrm{ctx}} \\, c  \\text{if } \\lvert e_t \\rvert \\le \\theta_{\\mathrm{lo}} \\\\\n    k_{\\mathrm{mid}} \\, e_t + b_{\\mathrm{ctx}} \\, c  \\text{otherwise}\n    \\end{cases}\n    $$\n3.  **应用执行器饱和**：施加到设备的实际控制输入 $u_t$ 是被执行器饱和极限 $U_{\\mathrm{sat}}$ 削波后的原始输入：\n    $$\n    u_t = \\mathrm{clip}\\left(u_t^{\\mathrm{raw}}, -U_{\\mathrm{sat}}, U_{\\mathrm{sat}}\\right) = \\max(-U_{\\mathrm{sat}}, \\min(u_t^{\\mathrm{raw}}, U_{\\mathrm{sat}}))\n    $$\n4.  **评估安全违规**：在每个时间步 $t$，我们检查状态或控制输入是否超过其各自的安全边界 $X_{\\max}$ 和 $U_{\\mathrm{safe}}$。如果出现以下情况，则发生违规：\n    $$\n    \\lvert x_t \\rvert  X_{\\max} \\quad \\text{or} \\quad \\lvert u_t \\rvert  U_{\\mathrm{safe}}\n    $$\n    我们必须计算此类时间步的总数。\n\n5.  **更新状态**：系统在下一个时间步 $x_{t+1}$ 的状态是使用离散时间状态更新方程计算的，其中包含了施加的控制 $u_t$ 和已知的扰动 $w_t$：\n    $$\n    x_{t+1} = a \\, x_t + b \\, u_t + w_t\n    $$\n\n这个迭代过程在整个时域 $t=0, \\dots, T-1$ 内执行，生成状态 $\\{x_t\\}_{t=0}^{T}$、误差 $\\{e_t\\}_{t=0}^{T-1}$ 和控制 $\\{u_t\\}_{t=0}^{T-1}$ 的轨迹。\n\n对于每个测试用例，整个模拟过程执行两次：一次针对上下文 $c=+1$，一次针对 $c=-1$。这将产生两组轨迹，例如 $\\{x_t(+1)\\}$ 和 $\\{x_t(-1)\\}$。\n\n在两次模拟都完成后，我们计算所需的指标：\n\n- **特定群体的均方根误差 (RMSE)**：对于每个上下文 $c$，RMSE 计算如下：\n  $$\n  \\mathrm{RMSE}(c) = \\sqrt{\\frac{1}{T} \\sum_{t=0}^{T-1} e_t(c)^2}\n  $$\n- **总体 RMSE**：这是两个特定群体 RMSE 的平均值：\n  $$\n  \\mathrm{RMSE}_{\\mathrm{overall}} = \\frac{1}{2}\\left(\\mathrm{RMSE}(+1) + \\mathrm{RMSE}(-1)\\right)\n  $$\n- **公平性差异**：这是特定群体 RMSE 之间的绝对差值：\n  $$\n  \\Delta_{\\mathrm{fair}} = \\left| \\mathrm{RMSE}(+1) - \\mathrm{RMSE}(-1) \\right|\n  $$\n- **安全违规率**：我们首先计算每个群体的违规总数，记为 $N_{\\mathrm{viol}}(c) = \\sum_{t=0}^{T-1} \\mathbf{1}(\\lvert x_t(c) \\rvert  X_{\\max} \\text{ or } \\lvert u_t(c) \\rvert  U_{\\mathrm{safe}})$。该率则是两个群体的总违规数除以总时间步数：\n  $$\n  \\rho_{\\mathrm{viol}} = \\frac{N_{\\mathrm{viol}}(+1) + N_{\\mathrm{viol}}(-1)}{2T}\n  $$\n- **复合社会损失**：最后，社会损失 $L$ 是上述指标的加权和：\n  $$\n  L = \\alpha \\, \\mathrm{RMSE}_{\\mathrm{overall}} + \\beta \\, \\rho_{\\mathrm{viol}} + \\gamma \\, \\Delta_{\\mathrm{fair}}\n  $$\n  其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 是给定的非负权重。\n\n该实现将包含一个主函数，用于遍历所有测试用例。对于每个案例，它将调用一个模拟函数，该函数在内部为 $c=+1$ 和 $c=-1$ 运行该过程，然后计算并返回四个最终指标：$\\mathrm{RMSE}_{\\mathrm{overall}}$、$\\rho_{\\mathrm{viol}}$、$\\Delta_{\\mathrm{fair}}$ 和 $L$。参考序列 $\\{r_t\\}$ 和扰动序列 $\\{w_t\\}$ 将根据其函数形式为每个测试用例预先计算。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            \"a\": 0.9, \"b\": 0.4, \"T\": 60,\n            \"ref_spec\": (\"step\", {\"t_step\": 10, \"v_pre\": 0.0, \"v_post\": 1.0}),\n            \"dist_spec\": (\"sine\", {\"amp\": 0.02, \"period\": 15}),\n            \"theta_lo\": 0.05, \"theta_hi\": 0.5,\n            \"k_lo\": 0.3, \"k_mid\": 0.8, \"k_hi\": 1.2,\n            \"b_ctx\": 0.1,\n            \"U_sat\": 2.0, \"U_safe\": 1.5, \"X_max\": 2.0,\n            \"alpha\": 1.0, \"beta\": 3.0, \"gamma\": 2.0\n        },\n        # Case 2\n        {\n            \"a\": 0.9, \"b\": 0.4, \"T\": 60,\n            \"ref_spec\": (\"step\", {\"t_step\": 10, \"v_pre\": 0.0, \"v_post\": 1.0}),\n            \"dist_spec\": (\"sine\", {\"amp\": 0.02, \"period\": 15}),\n            \"theta_lo\": 0.05, \"theta_hi\": 0.5,\n            \"k_lo\": 0.3, \"k_mid\": 0.8, \"k_hi\": 1.5,\n            \"b_ctx\": 0.15,\n            \"U_sat\": 2.0, \"U_safe\": 0.7, \"X_max\": 1.0,\n            \"alpha\": 1.0, \"beta\": 3.0, \"gamma\": 2.0\n        },\n        # Case 3\n        {\n            \"a\": 0.95, \"b\": 0.3, \"T\": 60,\n            \"ref_spec\": (\"ramped_step\", {\"t1\": 5, \"v1\": 0.0, \"t2\": 30, \"v2\": 0.5, \"v3\": 1.0}),\n            \"dist_spec\": (\"zero\", {}),\n            \"theta_lo\": 0.02, \"theta_hi\": 0.3,\n            \"k_lo\": 0.2, \"k_mid\": 0.5, \"k_hi\": 0.7,\n            \"b_ctx\": 0.0,\n            \"U_sat\": 1.0, \"U_safe\": 1.0, \"X_max\": 2.0,\n            \"alpha\": 1.0, \"beta\": 3.0, \"gamma\": 2.0\n        },\n        # Case 4\n        {\n            \"a\": 0.9, \"b\": 0.4, \"T\": 60,\n            \"ref_spec\": (\"sine_offset\", {\"offset\": 0.8, \"amp\": 0.2, \"period\": 20}),\n            \"dist_spec\": (\"sine\", {\"amp\": 0.2, \"period\": 10}),\n            \"theta_lo\": 0.05, \"theta_hi\": 0.4,\n            \"k_lo\": 0.4, \"k_mid\": 0.9, \"k_hi\": 1.1,\n            \"b_ctx\": 0.05,\n            \"U_sat\": 2.0, \"U_safe\": 1.2, \"X_max\": 1.2,\n            \"alpha\": 1.0, \"beta\": 3.0, \"gamma\": 2.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        results.append(evaluate_case(params))\n\n    # Format the final output as a string representing a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_sequence(T, spec):\n    \"\"\"Generates reference or disturbance sequences.\"\"\"\n    seq_type, params = spec\n    t = np.arange(T)\n    if seq_type == \"step\":\n        seq = np.full(T, params[\"v_pre\"])\n        seq[params[\"t_step\"]:] = params[\"v_post\"]\n    elif seq_type == \"sine\":\n        seq = params[\"amp\"] * np.sin(2 * np.pi * t / params[\"period\"])\n    elif seq_type == \"ramped_step\":\n        seq = np.full(T, params[\"v1\"])\n        seq[params[\"t1\"]:params[\"t2\"]] = params[\"v2\"]\n        seq[params[\"t2\"]:] = params[\"v3\"]\n    elif seq_type == \"sine_offset\":\n        seq = params[\"offset\"] + params[\"amp\"] * np.sin(2 * np.pi * t / params[\"period\"])\n    elif seq_type == \"zero\":\n        seq = np.zeros(T)\n    return seq\n\ndef run_simulation(c, params, r_seq, w_seq):\n    \"\"\"\n    Runs the simulation for a single context group.\n    \n    Returns:\n        tuple: (RMSE for this group, number of violations for this group)\n    \"\"\"\n    T = params[\"T\"]\n    x = np.zeros(T + 1)\n    x[0] = 0.0\n    \n    errors = np.zeros(T)\n    violations = 0\n\n    for t in range(T):\n        # 1. Compute tracking error\n        e_t = r_seq[t] - x[t]\n        errors[t] = e_t\n\n        # 2. Apply rule-based control policy\n        e_abs = abs(e_t)\n        if e_abs = params[\"theta_hi\"]:\n            k = params[\"k_hi\"]\n        elif e_abs = params[\"theta_lo\"]:\n            k = params[\"k_lo\"]\n        else:\n            k = params[\"k_mid\"]\n        u_raw = k * e_t + params[\"b_ctx\"] * c\n        \n        # 3. Apply actuator saturation\n        u_t = np.clip(u_raw, -params[\"U_sat\"], params[\"U_sat\"])\n        \n        # 4. Assess safety violations\n        if abs(x[t])  params[\"X_max\"] or abs(u_t)  params[\"U_safe\"]:\n            violations += 1\n            \n        # 5. Update state\n        x[t+1] = params[\"a\"] * x[t] + params[\"b\"] * u_t + w_seq[t]\n\n    rmse = np.sqrt(np.mean(errors**2))\n    return rmse, violations\n\ndef evaluate_case(params):\n    \"\"\"\n    Evaluates a single test case by running simulations for c = +1 and c = -1.\n    \n    Returns:\n        list: [RMSE_overall, rho_viol, Delta_fair, L] rounded to 6 decimal places.\n    \"\"\"\n    T = params[\"T\"]\n    r_seq = generate_sequence(T, params[\"ref_spec\"])\n    w_seq = generate_sequence(T, params[\"dist_spec\"])\n\n    # Run for context c = +1\n    rmse_p1, viol_p1 = run_simulation(1, params, r_seq, w_seq)\n    \n    # Run for context c = -1\n    rmse_n1, viol_n1 = run_simulation(-1, params, r_seq, w_seq)\n\n    # Calculate metrics\n    rmse_overall = (rmse_p1 + rmse_n1) / 2.0\n    delta_fair = abs(rmse_p1 - rmse_n1)\n    rho_viol = (viol_p1 + viol_n1) / (2.0 * T)\n    \n    # Calculate composite loss\n    loss = (params[\"alpha\"] * rmse_overall + \n            params[\"beta\"] * rho_viol + \n            params[\"gamma\"] * delta_fair)\n\n    return [round(val, 6) for val in [rmse_overall, rho_viol, delta_fair, loss]]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}