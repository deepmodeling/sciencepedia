{
    "hands_on_practices": [
        {
            "introduction": "在可编程数据平面中，规则的重叠可能导致匹配行为的模糊性，这对需要确定性行为的信息物理系统（CPS）是不可接受的。本练习  旨在解决这一核心挑战，指导您如何通过基于规则具体性的系统化优先级分配来实现确定性匹配。此外，本练习还将这种逻辑层面的正确性与物理层面的性能联系起来，要求您计算在优先级队列系统中，关键流量的最坏情况延迟。",
            "id": "4246510",
            "problem": "一个类似 OpenFlow 的软件定义网络 (SDN) 数据平面被用于为安全关键型信息物理系统 (CPS) 强制执行通信策略。该 SDN 交换机使用整数规则优先级，其中较大的整数表示较高的匹配优先权。控制器编程了以下六条流规则，每条规则都有一个由虚拟局域网 (VLAN) 标识符、Internet 协议版本 4 (IPv4) 目的前缀和传输控制协议 (TCP) 目的端口组成的三字段谓词。通配符表示“任意值”。\n\n规则 $f_1$：VLAN $10$，IPv4 目的地址 $10.0.0.0/8$，TCP 目的端口任意。\n\n规则 $f_2$：VLAN $10$，IPv4 目的地址 $10.1.0.0/16$，TCP 目的端口 $12345$。\n\n规则 $f_3$ (安全关键型 CPS 控制)：VLAN $10$，IPv4 目的地址 $10.1.2.0/24$，TCP 目的端口 $12345$。\n\n规则 $f_4$：VLAN 任意，IPv4 目的地址 $10.1.2.0/24$，TCP 目的端口任意。\n\n规则 $f_5$：VLAN 任意，IPv4 目的地址任意，TCP 目的端口任意 (表未命中默认规则)。\n\n规则 $f_6$：VLAN $10$，IPv4 目的地址 $10.1.2.34/32$，TCP 目的端口任意。\n\n数据包的匹配方式为，在所有谓词被满足的规则中选择优先级最高的那条。为了在存在重叠通配符模式的情况下保证确定性的匹配顺序，控制器为规则的谓词定义了以下明确性度量。令 $s_{\\text{VLAN}}$ 为 VLAN 标识符中匹配的比特数（精确匹配计为 $12$ 比特；通配符计为 $0$），令 $s_{\\text{IP}}$ 为 IPv4 目的地址中匹配的前缀长度（从 $0$ 到 $32$），令 $s_{\\text{TCP}}$ 为 TCP 目的端口中匹配的比特数（精确匹配计为 $16$ 比特；通配符计为 $0$）。组合明确性为 $S = s_{\\text{VLAN}} + s_{\\text{IP}} + s_{\\text{TCP}}$。确定性优先级排序要求是：对于其匹配集合交集非空的任意一对规则，$S$ 值严格较大的规则必须具有严格更高的整数优先级；$S$ 值相同时必须按元组 $(s_{\\text{TCP}}, s_{\\text{IP}}, s_{\\text{VLAN}})$ 的字典序来打破平局，使得字典序中较大的元组对应的规则具有更高的优先级。所有六条规则必须被分配不同的整数优先级 $p_1, p_2, p_3, p_4, p_5, p_6$，其中 $p_i$ 是 $f_i$ 的优先级。\n\n此外，交换机调度器采用严格非抢占式优先级：匹配 $f_3$ 的数据包被放入高优先级队列，而所有其他数据包被放入一个单独的低优先级队列。链路速率为 $C = 1 \\times 10^{9}$ 比特/秒，最大低优先级帧大小为 $L_{\\text{BE}} = 1500$ 字节，安全关键型帧大小为 $L_{\\text{CPS}} = 100$ 字节，每包交换机处理时间为 $t_{\\text{proc}} = 5 \\,\\mu\\text{s}$，电缆长度为 $d = 100$ 米，介质中的传播速度为 $v = 2 \\times 10^{8}$ 米/秒。使用非抢占式严格优先级排队以及序列化和传播延迟的基本原理，推导安全关键流 $f_3$ 的数据包的最坏情况下单跳延迟 $\\Delta_{\\max}$。\n\n计算：\n- 满足上述确定性要求的整数优先级分配 $(p_1, p_2, p_3, p_4, p_5, p_6)$。\n- $f_3$ 的最坏情况下单跳延迟 $\\Delta_{\\max}$。\n\n将您的最终答案以单个行向量的形式报告，其中包含六个优先级，后跟标量 $\\Delta_{\\max}$。将延迟四舍五入到四位有效数字，并以毫秒为单位表示。",
            "solution": "该问题要求确定两个量：一组六条软件定义网络 (SDN) 流规则的整数优先级分配，以及一个特定安全关键流的最坏情况单跳延迟。解答分两部分推导。\n\n第 1 部分：整数优先级分配\n\n每个流规则 $f_i$ 的优先级由一个明确性度量决定。组合明确性 $S$ 定义为三个谓词字段的明确性之和：$S = s_{\\text{VLAN}} + s_{\\text{IP}} + s_{\\text{TCP}}$。各个明确性的定义如下：\n- $s_{\\text{VLAN}}$: 虚拟局域网 (VLAN) 标识符中匹配的比特数。精确匹配对应 $12$ 比特，而通配符对应 $0$ 比特。\n- $s_{\\text{IP}}$: Internet 协议版本 4 (IPv4) 目的地址的前缀长度，范围从 $0$ 到 $32$。\n- $s_{\\text{TCP}}$: 传输控制协议 (TCP) 目的端口中匹配的比特数。精确匹配对应 $16$ 比特，而通配符对应 $0$ 比特。\n\n规则排序基于以下标准：S 值严格较大的规则具有严格更高的优先权。如果 S 值出现平局，则通过元组 $(s_{\\text{TCP}}, s_{\\text{IP}}, s_{\\text{VLAN}})$ 的字典序来打破平局；字典序中较大的元组对应的规则具有更高的优先权。“较大的整数表示较高的匹配优先权”。我们将从 1 (最低) 到 6 (最高) 分配整数优先级。\n\n首先，我们为六条规则中的每一条计算明确性向量 $(s_{\\text{VLAN}}, s_{\\text{IP}}, s_{\\text{TCP}})$ 和组合明确性 $S$。\n\n- 规则 $f_1$: (VLAN $10$, IPv4 $10.0.0.0/8$, TCP 任意)\n  $s_{\\text{VLAN},1} = 12$, $s_{\\text{IP},1} = 8$, $s_{\\text{TCP},1} = 0$.\n  $S_1 = 12 + 8 + 0 = 20$。平局打破元组：$(0, 8, 12)$。\n\n- 规则 $f_2$: (VLAN $10$, IPv4 $10.1.0.0/16$, TCP $12345$)\n  $s_{\\text{VLAN},2} = 12$, $s_{\\text{IP},2} = 16$, $s_{\\text{TCP},2} = 16$.\n  $S_2 = 12 + 16 + 16 = 44$。平局打破元组：$(16, 16, 12)$。\n\n- 规则 $f_3$: (VLAN $10$, IPv4 $10.1.2.0/24$, TCP $12345$)\n  $s_{\\text{VLAN},3} = 12$, $s_{\\text{IP},3} = 24$, $s_{\\text{TCP},3} = 16$.\n  $S_3 = 12 + 24 + 16 = 52$。平局打破元组：$(16, 24, 12)$。\n\n- 规则 $f_4$: (VLAN 任意, IPv4 $10.1.2.0/24$, TCP 任意)\n  $s_{\\text{VLAN},4} = 0$, $s_{\\text{IP},4} = 24$, $s_{\\text{TCP},4} = 0$.\n  $S_4 = 0 + 24 + 0 = 24$。平局打破元组：$(0, 24, 0)$。\n\n- 规则 $f_5$: (VLAN 任意, IPv4 任意, TCP 任意)\n  $s_{\\text{VLAN},5} = 0$, $s_{\\text{IP},5} = 0$, $s_{\\text{TCP},5} = 0$.\n  $S_5 = 0 + 0 + 0 = 0$。平局打破元组：$(0, 0, 0)$。\n\n- 规则 $f_6$: (VLAN $10$, IPv4 $10.1.2.34/32$, TCP 任意)\n  $s_{\\text{VLAN},6} = 12$, $s_{\\text{IP},6} = 32$, $s_{\\text{TCP},6} = 0$.\n  $S_6 = 12 + 32 + 0 = 44$。平局打破元组：$(0, 32, 12)$。\n\n接下来，我们按优先权降序对规则进行排序。\n1.  $f_3$ 具有最高的组合明确性，$S_3 = 52$。\n2.  $f_2$ 和 $f_6$ 具有相同的明确性，$S_2 = S_6 = 44$。我们通过字典序比较它们的元组来应用平局打破规则：\n    - $f_2$: $(16, 16, 12)$\n    - $f_6$: $(0, 32, 12)$\n    由于 $16  0$，$f_2$ 的元组在字典序上更大。因此，$f_2$ 的优先权高于 $f_6$。\n3.  剩余规则的 $S$ 值是唯一的：$S_4 = 24$，$S_1 = 20$，以及 $S_5 = 0$。\n\n从最高优先权到最低的最终排名是：$f_3, f_2, f_6, f_4, f_1, f_5$。\n\n我们从 6 向下到 1 分配不同的整数优先级 $p_i$：\n- 优先权 1 (最高): $f_3 \\implies p_3 = 6$\n- 优先权 2: $f_2 \\implies p_2 = 5$\n- 优先权 3: $f_6 \\implies p_6 = 4$\n- 优先权 4: $f_4 \\implies p_4 = 3$\n- 优先权 5: $f_1 \\implies p_1 = 2$\n- 优先权 6 (最低): $f_5 \\implies p_5 = 1$\n\n最终的优先级分配向量是 $(p_1, p_2, p_3, p_4, p_5, p_6) = (2, 5, 6, 3, 1, 4)$。\n\n第 2 部分：最坏情况单跳延迟计算\n\n安全关键型数据包（匹配规则 $f_3$）的最坏情况单跳延迟 $\\Delta_{\\max}$ 是其通过交换机过程中在每个阶段（处理、排队、序列化（传输）和传播）所花费的最大时间之和。\n$$ \\Delta_{\\max} = t_{\\text{proc}} + t_{\\text{queue,max}} + t_{\\text{tx,CPS}} + t_{\\text{prop}} $$\n\n我们使用提供的值计算每个分量：\n- **处理延迟 ($t_{\\text{proc}}$)**：对于任何数据包，这都是一个给定的恒定值。\n  $$ t_{\\text{proc}} = 5 \\,\\mu\\text{s} = 5 \\times 10^{-6} \\, \\text{s} $$\n\n- **传播延迟 ($t_{\\text{prop}}$)**：这是信号传播电缆长度所需的时间。\n  $$ t_{\\text{prop}} = \\frac{d}{v} = \\frac{100 \\, \\text{m}}{2 \\times 10^{8} \\, \\text{m/s}} = 0.5 \\times 10^{-6} \\, \\text{s} = 0.5 \\,\\mu\\text{s} $$\n\n- **序列化延迟 ($t_{\\text{tx,CPS}}$)**：这是将安全关键型数据包的所有比特放到链路上所需的时间。其大小为 $L_{\\text{CPS}} = 100$ 字节。\n  $$ t_{\\text{tx,CPS}} = \\frac{L_{\\text{CPS}} \\times 8 \\, \\text{bits/byte}}{C} = \\frac{100 \\times 8}{1 \\times 10^{9} \\, \\text{bits/s}} = \\frac{800}{10^9} \\, \\text{s} = 0.8 \\times 10^{-6} \\, \\text{s} = 0.8 \\,\\mu\\text{s} $$\n\n- **排队延迟 ($t_{\\text{queue,max}}$)**：匹配 $f_3$ 的数据包被放入高优先级队列。所有其他数据包进入低优先级队列。调度器是严格非抢占式的。高优先级数据包的最坏情况排队延迟发生在其到达时发现服务器（链路）刚刚开始传输一个最大尺寸的低优先级数据包。由于非抢占式特性，高优先级数据包必须等待该传输完成。这个等待时间就是阻塞时间。低优先级（尽力而为）帧的最大尺寸为 $L_{\\text{BE}} = 1500$ 字节。\n  $$ t_{\\text{queue,max}} = \\frac{L_{\\text{BE}} \\times 8 \\, \\text{bits/byte}}{C} = \\frac{1500 \\times 8}{1 \\times 10^{9} \\, \\text{bits/s}} = \\frac{12000}{10^9} \\, \\text{s} = 12 \\times 10^{-6} \\, \\text{s} = 12 \\,\\mu\\text{s} $$\n  此计算假设队列中没有其他高优先级数据包，这是在没有高优先级流流量特征的情况下计算基本最坏情况阻塞的标准方法。\n\n- **总延迟 ($\\Delta_{\\max}$)**：我们将各个延迟分量相加。\n  $$ \\Delta_{\\max} = (5 + 12 + 0.8 + 0.5) \\,\\mu\\text{s} = 18.3 \\,\\mu\\text{s} $$\n  问题要求延迟以毫秒表示，并四舍五入到四位有效数字。\n  $$ \\Delta_{\\max} = 18.3 \\times 10^{-3} \\, \\text{ms} = 0.0183 \\, \\text{ms} $$\n  四舍五入到四位有效数字得到 $0.01830 \\, \\text{ms}$。\n\n最终的组合答案是由六个优先级后跟计算出的延迟所组成的行向量。\n$$ (p_1, p_2, p_3, p_4, p_5, p_6, \\Delta_{\\max}) = (2, 5, 6, 3, 1, 4, 0.01830) $$",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 2  5  6  3  1  4  0.01830 \\end{pmatrix} } $$"
        },
        {
            "introduction": "从数据平面转向控制平面，在逻辑上集中的SDN架构中，控制器的部署位置是影响网络性能和弹性的关键设计决策。本练习  将带您应对经典的控制器放置问题，即寻找最佳的控制器位置以最小化任意交换机与其控制器之间的最坏情况通信延迟。这个延迟直接决定了整个系统对网络事件的反应时间。",
            "id": "4246512",
            "problem": "考虑一个用于信息物理系统 (CPS) 的集中式软件定义网络 (SDN) 控制平面，其中一组交换机 $V=\\{1,2,3,4,5\\}$ 通过对称的通信延迟相互连接。该网络被建模为一个无向图，其中直接连接的交换机 $u$ 和 $v$ 之间的边延迟为 $w_{uv}$（单位为毫秒）。非零的直接链路及其延迟如下：\n- $w_{1,2}=3\\,\\mathrm{ms}$，\n- $w_{2,3}=2\\,\\mathrm{ms}$，\n- $w_{3,4}=4\\,\\mathrm{ms}$，\n- $w_{4,5}=3\\,\\mathrm{ms}$，\n- $w_{1,5}=8\\,\\mathrm{ms}$，\n- $w_{2,5}=5\\,\\mathrm{ms}$，\n- $w_{1,3}=6\\,\\mathrm{ms}$。\n\n所有未列出的链路没有直接连接。假设数据平面中的排队延迟可忽略不计，且每条路径上的延迟是对称的；也就是说，一条路径上的传播延迟等于其组成链路延迟的总和，并且反向路径具有相同的延迟。\n\n您需要在两个不同的交换机上放置 $k=2$ 个 SDN 控制器（控制器的位置必须从 $V$ 中选择）。每个交换机通过最短延迟路径向其最近的控制器发送控制消息，当控制器的响应返回到始发交换机时，相关的控制策略反应完成。假设控制器的处理时间为 $t_{\\mathrm{proc}}=2\\,\\mathrm{ms}$（此时间包括了控制器的计算和任何软件开销），交换机上的处理时间可忽略不计。\n\n从基本原理出发（最短路径延迟为链路延迟之和，反应时间为请求从交换机到控制器并返回响应所需的时间），确定：\n- 能够最小化从任何交换机到其最近控制器的最坏情况单向延迟的控制器布局，以及\n- 在该最优布局下，任何交换机事件所经历的控制策略反应时间的相应上界。\n\n以毫秒为单位表示最终的反应时间上界。无需四舍五入；报告精确值。",
            "solution": "该问题要求我们确定在一个由 $V=\\{1,2,3,4,5\\}$ 个交换机组成的网络中，放置 $k=2$ 个软件定义网络 (SDN) 控制器的最优位置，以最小化从任何交换机到其指定控制器的最坏情况单向通信延迟。随后，我们必须计算这种最优布局下控制策略反应时间的上界。\n\n这个问题是图论中无权顶点 $k$-中心问题的一个具体实例。我们旨在找到一个顶点子集 $C \\subset V$，其大小为 $|C|=k=2$，用作控制器的位置。目标是最小化从任意交换机 $v \\in V$到其在 $C$ 中最近的控制器的最大最短路径延迟。设 $d(u,v)$ 表示交换机 $u$ 和 $v$ 之间的最短路径延迟。该优化问题是找到集合 $C^*$ 来解决以下问题：\n$$ \\min_{C \\subset V, |C|=2} \\left( \\max_{v \\in V} \\left( \\min_{c \\in C} d(v,c) \\right) \\right) $$\n\n解决过程包括三个主要步骤：\n1.  计算给定网络图中所有节点对之间的最短路径延迟。\n2.  评估所有可能的控制器布局，以找到能最小化最坏情况单向延迟的布局。\n3.  使用最优布局的结果计算控制策略反应时间的上界。\n\n**步骤 1：所有节点对最短路径计算**\n\n交换机和链路组成的网络可以建模为一个无向图 $G=(V, E)$，其中 $V=\\{1,2,3,4,5\\}$，边权重是给定的延迟（单位为毫秒）。表示直接链路延迟（$w_{uv}$）的邻接矩阵如下所示（其中 $\\infty$ 表示没有直接链路）：\n$$ W = \\begin{pmatrix} 0  3  6  \\infty  8 \\\\ 3  0  2  \\infty  5 \\\\ 6  2  0  4  \\infty \\\\ \\infty  \\infty  4  0  3 \\\\ 8  5  \\infty  3  0 \\end{pmatrix} $$\n我们可以使用如 Floyd-Warshall 算法或从每个顶点运行 Dijkstra 算法来找到所有交换机对之间的最短路径延迟 $d(u,v)$。得到的所有节点对最短路径矩阵 $D$ 如下：\n$$ D = \\begin{pmatrix} 0  3  5  9  8 \\\\ 3  0  2  6  5 \\\\ 5  2  0  4  7 \\\\ 9  6  4  0  3 \\\\ 8  5  7  3  0 \\end{pmatrix} $$\n例如，从交换机 1 到交换机 3 的最短路径是 $d(1,3)=5\\,\\mathrm{ms}$，通过路径 $1 \\to 2 \\to 3$（延迟为 $3+2=5$），这比延迟为 $6\\,\\mathrm{ms}$ 的直接链路要短。\n\n**步骤 2：评估候选控制器布局**\n\n我们需要放置 $k=2$ 个控制器。可能的布局数量是从 5 个交换机中选择 2 个的方法数，即 $\\binom{5}{2} = \\frac{5 \\times 4}{2} = 10$。对于每个候选布局 $C = \\{c_1, c_2\\}$，我们计算最坏情况的单向延迟 $L(C) = \\max_{v \\in V} \\min(d(v, c_1), d(v, c_2))$。\n\n1.  $C = \\{1, 2\\}$：对于 $v \\in \\{1,2,3,4,5\\}$，到最近控制器的延迟为 $\\{\\min(d(1,1),d(1,2)), \\min(d(2,1),d(2,2)), \\dots\\}$。这得到 $\\{\\min(0,3), \\min(3,0), \\min(5,2), \\min(9,6), \\min(8,5)\\} = \\{0, 0, 2, 6, 5\\}$。$L(\\{1,2\\}) = \\max\\{0,0,2,6,5\\} = 6\\,\\mathrm{ms}$。\n2.  $C = \\{1, 3\\}$：延迟为 $\\{\\min(0,5), \\min(3,2), \\min(5,0), \\min(9,4), \\min(8,7)\\} = \\{0, 2, 0, 4, 7\\}$。$L(\\{1,3\\}) = \\max\\{0,2,0,4,7\\} = 7\\,\\mathrm{ms}$。\n3.  $C = \\{1, 4\\}$：延迟为 $\\{\\min(0,9), \\min(3,6), \\min(5,4), \\min(9,0), \\min(8,3)\\} = \\{0, 3, 4, 0, 3\\}$。$L(\\{1,4\\}) = \\max\\{0,3,4,0,3\\} = 4\\,\\mathrm{ms}$。\n4.  $C = \\{1, 5\\}$：延迟为 $\\{\\min(0,8), \\min(3,5), \\min(5,7), \\min(9,3), \\min(8,0)\\} = \\{0, 3, 5, 3, 0\\}$。$L(\\{1,5\\}) = \\max\\{0,3,5,3,0\\} = 5\\,\\mathrm{ms}$。\n5.  $C = \\{2, 3\\}$：延迟为 $\\{\\min(3,5), \\min(0,2), \\min(2,0), \\min(6,4), \\min(5,7)\\} = \\{3, 0, 0, 4, 5\\}$。$L(\\{2,3\\}) = \\max\\{3,0,0,4,5\\} = 5\\,\\mathrm{ms}$。\n6.  $C = \\{2, 4\\}$：延迟为 $\\{\\min(3,9), \\min(0,6), \\min(2,4), \\min(6,0), \\min(5,3)\\} = \\{3, 0, 2, 0, 3\\}$。$L(\\{2,4\\}) = \\max\\{3,0,2,0,3\\} = 3\\,\\mathrm{ms}$。\n7.  $C = \\{2, 5\\}$：延迟为 $\\{\\min(3,8), \\min(0,5), \\min(2,7), \\min(6,3), \\min(5,0)\\} = \\{3, 0, 2, 3, 0\\}$。$L(\\{2,5\\}) = \\max\\{3,0,2,3,0\\} = 3\\,\\mathrm{ms}$。\n8.  $C = \\{3, 4\\}$：延迟为 $\\{\\min(5,9), \\min(2,6), \\min(0,4), \\min(4,0), \\min(7,3)\\} = \\{5, 2, 0, 0, 3\\}$。$L(\\{3,4\\}) = \\max\\{5,2,0,0,3\\} = 5\\,\\mathrm{ms}$。\n9.  $C = \\{3, 5\\}$：延迟为 $\\{\\min(5,8), \\min(2,5), \\min(0,7), \\min(4,3), \\min(7,0)\\} = \\{5, 2, 0, 3, 0\\}$。$L(\\{3,5\\}) = \\max\\{5,2,0,3,0\\} = 5\\,\\mathrm{ms}$。\n10. $C = \\{4, 5\\}$：延迟为 $\\{\\min(9,8), \\min(6,5), \\min(4,7), \\min(0,3), \\min(3,0)\\} = \\{8, 5, 4, 0, 0\\}$。$L(\\{4,5\\}) = \\max\\{8,5,4,0,0\\} = 8\\,\\mathrm{ms}$。\n\n比较所有布局的最坏情况延迟，最小值为 $3\\,\\mathrm{ms}$。\n$$ \\min_{C} L(C) = 3\\,\\mathrm{ms} $$\n这个最小值可以通过两种不同的控制器布局实现：$C^*_1 = \\{2, 4\\}$ 和 $C^*_2 = \\{2, 5\\}$。两者都是最优布局。问题要求给出控制器布局，这两个集合中的任何一个都是正确答案。\n\n**步骤 3：计算控制策略反应时间上界**\n\n对于给定的交换机，控制策略反应时间是指消息到其指定控制器的往返时间，包括指定的控制器处理时间。\n设 $t_{\\text{one-way}}(v)$ 为交换机 $v$ 到其最近控制器的单向延迟。交换机 $v$ 的反应时间为：\n$$ T_{\\text{reaction}}(v) = t_{\\text{one-way}}(v) + t_{\\text{proc}} + t_{\\text{one-way}}(v) = 2 \\cdot t_{\\text{one-way}}(v) + t_{\\text{proc}} $$\n问题要求的是此反应时间的上界，它对应于在最优控制器布局下，经历最坏情况（最大）单向延迟的交换机。这个最大单向延迟正是我们所最小化的值 $L(C^*)$，即 $3\\,\\mathrm{ms}$。\n\n设 $L_{\\text{opt}} = \\max_{v \\in V} \\min_{c \\in C^*} d(v,c) = 3\\,\\mathrm{ms}$。\n给定的控制器处理时间为 $t_{\\text{proc}} = 2\\,\\mathrm{ms}$。\n因此，任何交换机所经历的控制策略反应时间的上界 $T_{\\text{reaction,max}}$ 为：\n$$ T_{\\text{reaction,max}} = 2 \\cdot L_{\\text{opt}} + t_{\\text{proc}} $$\n$$ T_{\\text{reaction,max}} = 2 \\cdot (3\\,\\mathrm{ms}) + 2\\,\\mathrm{ms} = 6\\,\\mathrm{ms} + 2\\,\\mathrm{ms} = 8\\,\\mathrm{ms} $$\n因此，在最优的控制器布局下（控制器位于交换机 $\\{2, 4\\}$ 或 $\\{2, 5\\}$），任何交换机将经历的最大反应时间为 $8\\,\\mathrm{ms}$。",
            "answer": "$$\\boxed{8}$$"
        },
        {
            "introduction": "在配置好数据和控制平面之后，下一个挑战是在线更新网络策略，同时不引入瞬态不一致性或违反安全不变性。本练习  探讨了在动态更新过程中可能出现的微妙竞态条件，并要求您识别出一种基于两阶段提交（2PC）原则的原子更新协议。掌握此项技能对于维护高可靠性CPS网络的运行至关重要。",
            "id": "4246519",
            "problem": "一个信息物理系统（CPS）的工厂网络通过软件定义网络（SDN）进行控制。一个数字孪生编排服务旨在为一组关键控制流 $\\mathcal{F}$ 将转发和管制策略从现有策略 $\\pi_0$ 转换到新策略 $\\pi_1$。转发结构由交换机 $S_1, S_2, \\dots, S_N$、一个为数据包添加标记的入口网关 $G$ 以及一个逻辑上集中的SDN控制器 $C$ 组成。网络必须维持一个安全不变量：在任何时间 $t$，对于任何传输中的数据包 $p$，沿其路径应用于 $p$ 的转发和管制决策都必须源自单一、明确定义的策略版本，该版本由在 $G$ 处设置的匹配字段中嵌入的版本标签 $v \\in \\{0,1\\}$ 建模，并且所有在 $S_1, \\dots, S_N$ 上匹配的规则都与该 $v$ 保持一致。控制器通过一个可靠的控制信道与每个交换机交互，该信道的最大单向传播延迟为 $D_{\\max}$，并且每个交换机在收到规则后最多需要 $T_{\\text{inst}}$ 的时间来安装和激活规则。数据包从入口到出口的最大网络驻留时间为 $T_{\\text{flight}}$。可能存在来自独立控制应用程序的并发更新，该程序会修改相同流 $\\mathcal{F}$ 的速率限制器（计量器），并且控制器异步处理消息。\n\n请从第一性原理出发，使用事件排序和原子性定义解释并发更新期间竞争条件的根本原因，然后确定在任意交错以及给定的边界条件 $D_{\\max}$、$T_{\\text{inst}}$ 和 $T_{\\text{flight}}$ 下，以下哪种两阶段提交（Two-Phase Commit, $2\\text{PC}$）序列能够保证 $\\mathcal{F}$ 的策略从 $\\pi_0$ 到 $\\pi_1$ 的原子性转换——即，没有数据包会被 $\\pi_0$ 和 $\\pi_1$ 规则的混合体处理。\n\n选择唯一的最佳序列：\n\nA. 准备阶段：对于每个 $S_i$，安装匹配 $v=1$ 的 $\\pi_1$ 规则，但不移除匹配 $v=0$ 的 $\\pi_0$ 规则，并安装本地屏障，以确保任何带有 $v=1$ 的数据包只有在 $\\pi_1$ 规则完全存在后才会被接受并一致地转发；向每个 $S_i$ 发出屏障指令并等待确认；仅当在控制器侧超时 $\\tau$ （选择的 $\\tau$ 满足 $\\tau \\ge D_{\\max} + T_{\\text{inst}}$）之前收到所有确认时才继续。提交阶段：原子地更新 $G$，为 $\\mathcal{F}$ 中的新数据包标记 $v=1$；同时维护两个版本；等待至少 $T_{\\text{flight}}$ 时间以允许所有 $v=0$ 的数据包排空后，垃圾回收 $\\pi_0$ 规则。任何未能在时间 $\\tau$ 内确认的交换机将触发其 $\\pi_1$ 暂存规则的回滚，并使系统保持在 $\\pi_0$ 状态。\n\nB. 准备阶段：在 $S_1$ 和 $S_2$ 上更新 $\\pi_1$ 规则并移除 $\\pi_0$ 规则；通过立即更新 $G$ 以标记 $v=1$ 来提交；然后在带宽允许的情况下，异步地在其余的 $S_i$ 上安装 $\\pi_1$ 规则。依赖从入口到出口路径上的有序更新来最小化不一致性窗口，而不使用版本标签或屏障。\n\nC. 准备阶段：在所有 $S_i$ 上安装 $\\pi_1$ 规则，并在任何快速确认的 $S_i$ 上移除 $\\pi_0$ 规则；为最小化延迟，在收到第一个屏障确认后即提交；更新 $G$ 以标记 $v=1$；如果任何 $S_j$ 速度较慢，带有 $v=1$ 的数据包将在 $S_j$ 处被临时丢弃，直到其安装完成。\n\nD. 单阶段乐观方法：向所有 $S_i$ 广播 $\\pi_1$ 规则更新，并立即更新 $G$ 以标记 $v=1$；依赖最终一致性和有界延迟 $D_{\\max}$ 及 $T_{\\text{inst}}$ 来确保网络快速收敛；在小于 $T_{\\text{flight}}$ 的固定宽限期后移除 $\\pi_0$ 规则以减少重叠。\n\nE. 准备阶段：获取关于集合 $\\mathcal{F}$ 的粗粒度控制器锁以阻塞并发的计量器更新；然后以任意顺序通过移除 $\\pi_0$ 规则并安装 $\\pi_1$ 规则来顺序更新每个 $S_i$；通过释放锁并更新 $G$ 以标记 $v=1$ 来提交；假设即使数据包遍历在不同时间更新的交换机，该锁也能确保端到端的原子性。\n\n通过选择能够正确强制执行原子性、防止竞争条件，同时遵守给定时间边界和安全不变量的选项来回答。",
            "solution": "该问题陈述是有效的。它提出了一个分布式系统领域中定义明确且具有科学依据的问题，具体涉及软件定义网络（SDN）环境中的原子性更新。其参数、约束和安全不变量都得到了清晰的定义并且是一致的。\n\n问题的核心在于，在存在网络延迟和潜在并发操作的情况下，如何保证策略更新在整个分布式系统（交换机集合 $S_i$）中的原子性。当一个操作的正确性取决于并发事件的不可预测顺序时，就会出现竞争条件。在此背景下，竞争条件有两个主要来源。\n\n首先，从第一性原理来看，分布式系统缺乏全局时钟和同步操作。事件排序是部分的。策略更新操作，虽然表现为单一的逻辑动作，但实际上是作为一组并发事件来实现的：从控制器 $C$ 到每个交换机 $S_i$ 的消息传输，以及随后在每个 $S_i$ 上的规则安装。设 $t_{send}(S_i)$ 是控制器向 $S_i$ 发送更新的时间，$t_{recv}(S_i)$ 是 $S_i$ 接收到它的时间，而 $t_{act}(S_i)$ 是新规则在 $S_i$ 上生效的时间。由于可变的传播延迟（最大为 $D_{\\max}$）和安装时间（最大为 $T_{\\text{inst}}$），不同交换机 $S_i$ 的生效时间 $t_{act}(S_i)$ 将会不同，并以不可预测的顺序发生。当一个数据包 $p$ 在此转换窗口期间穿越网络时，就会发生数据平面竞争条件。如果 $p$ 从 $S_i$ 传输到 $S_j$，并且 $t_{act}(S_i)$ 已过但 $t_{act}(S_j)$ 还未到，那么 $p$ 将在 $S_i$ 处被新策略 $\\pi_1$ 处理，而在 $S_j$ 处被旧策略 $\\pi_0$ 处理。这种观察到的混合、中间状态违反了指定的安全不变量。其根本原因是数据包在网络中的传播与状态更新在网络中的传播之间发生了竞争。\n\n其次，由于“来自独立控制应用程序的并发更新”，可能会发生控制平面竞争条件。这是一个经典的读-改-写（Read-Modify-Write）风险。策略更新过程可能会读取流规则的当前状态（例如，交换机 $S_i$ 上的策略 $\\pi_0$）来计算 $\\pi_1$ 的新规则。与此同时，另一个应用程序也可能读取相同的状态以应用修改（例如，更改速率限制器）。如果这些操作在没有同步的情况下交错执行，第二个写操作可能会覆盖第一个，导致“丢失更新”。此处的根本原因是控制平面内对共享状态表示的修改缺乏互斥性。\n\n一个原子性更新协议必须防止这两种类型的竞争条件。它必须确保没有数据包会观察到不一致的数据平面，并且并发的控制平面修改不会导致丢失更新。使用版本标签 $v \\in \\{0, 1\\}$ 通过逻辑上分离新旧策略的状态空间，为实现这一目标提供了基础机制。\n\n现在，我们评估每个提议的序列：\n\n**A. 准备阶段：对于每个 $S_i$，安装匹配 $v=1$ 的 $\\pi_1$ 规则，但不移除匹配 $v=0$ 的 $\\pi_0$ 规则，并安装本地屏障，以确保任何带有 $v=1$ 的数据包只有在 $\\pi_1$ 规则完全存在后才会被接受并一致地转发；向每个 $S_i$ 发出屏障指令并等待确认；仅当在控制器侧超时 $\\tau$ （选择的 $\\tau$ 满足 $\\tau \\ge D_{\\max} + T_{\\text{inst}}$）之前收到所有确认时才继续。提交阶段：原子地更新 $G$，为 $\\mathcal{F}$ 中的新数据包标记 $v=1$；同时维护两个版本；等待至少 $T_{\\text{flight}}$ 时间以允许所有 $v=0$ 的数据包排空后，垃圾回收 $\\pi_0$ 规则。任何未能在时间 $\\tau$ 内确认的交换机将触发其 $\\pi_1$ 暂存规则的回滚，并使系统保持在 $\\pi_0$ 状态。**\n\n该序列描述了一个正确的、基于版本的两阶段更新协议。\n1.  **准备阶段**：控制器指示所有交换机安装使用版本标签 $v=1$ 匹配的新策略规则 ($\\pi_1$)。关键的是，旧规则（$\\pi_0$，匹配 $v=0$）被保留下来。这是一种“先建后断”（make-before-break）策略。使用屏障并等待所有交换机的确认，确保了控制器在整个数据平面准备好处理 $\\pi_1$ 流量之前不会进入下一阶段。超时和回滚机制正确地实现了两阶段提交（2PC）协议的“中止”逻辑。超时条件 $\\tau \\ge D_{\\max} + T_{\\text{inst}}$ 确保控制器等待足够长的时间，以便消息到达交换机、被处理，并且一个确认被*处理*（如果屏障确认是在安装后发送的）。一个更保守的用于接收确认的超时时间将是 $2D_{\\max} + T_{\\text{inst}}$。然而，其意图是明确的，并且遵循了2PC模式。\n2.  **提交阶段**：提交是一个单一的原子操作：指示入口网关 $G$ 开始为新数据包标记 $v=1$。此后，所有新数据包都将携带标签 $v=1$，并且将只匹配 $\\pi_1$ 规则，这些规则保证存在于所有交换机上。网络中已有的带标签 $v=0$ 的数据包将继续匹配仍然存在的 $\\pi_0$ 规则。因此，没有任何数据包会被 $\\pi_0$ 和 $\\pi_1$ 规则的混合体处理。安全不变量得以维持。\n3.  **清理阶段**：“垃圾回收”步骤，即在等待 $T_{\\text{flight}}$ 后移除 $\\pi_0$ 规则，正确地确保了所有 $v=0$ 的数据包在它们的规则被删除之前已经离开网络，从而防止了数据包被丢弃。\n该协议通过确保新路径在使用前被完全配置，正确地解决了数据平面的竞争条件。它还缓解了控制平面的竞争条件，因为更新过程是为 $\\pi_1$ 创建*新*规则，而不是*原地*修改 $\\pi_0$，从而将更新与对活动 $\\pi_0$ 策略的并发修改隔离开来。\n\n结论：**正确**。\n\n**B. 准备阶段：在 $S_1$ 和 $S_2$ 上更新 $\\pi_1$ 规则并移除 $\\pi_0$ 规则；通过立即更新 $G$ 以标记 $v=1$ 来提交；然后在带宽允许的情况下，异步地在其余的 $S_i$ 上安装 $\\pi_1$ 规则。依赖从入口到出口路径上的有序更新来最小化不一致性窗口，而不使用版本标签或屏障。**\n\n该协议存在根本性缺陷。它在引导新流量之前仅更新交换机的一个子集（$S_1, S_2$），从而明确地创建了一个不一致的状态，而这些新流量随后需要穿越像 $S_3, \\dots, S_N$ 这样未更新的交换机。一个在 $S_1$ 处被 $\\pi_1$ 处理的数据包随后将在 $S_3$ 处被 $\\pi_0$ 处理。这直接违反了安全不变量。放弃使用版本标签移除了维持一致性的主要机制。依赖“路径上的有序更新”在具有不确定性延迟的分布式系统中并非保证。\n\n结论：**不正确**。\n\n**C. 准备阶段：在所有 $S_i$ 上安装 $\\pi_1$ 规则，并在任何快速确认的 $S_i$ 上移除 $\\pi_0$ 规则；为最小化延迟，在收到第一个屏障确认后即提交；更新 $G$ 以标记 $v=1$；如果任何 $S_j$ 速度较慢，带有 $v=1$ 的数据包将在 $S_j$ 处被临时丢弃，直到其安装完成。**\n\n这是一个实现不当、过于乐观的协议。在收到*第一个*确认后就提交，意味着控制器将触发入口网关 $G$ 发送带有 $v=1$ 的数据包，而此时其他交换机尚未准备好。该协议承认这种情况会发生，并将丢弃数据包作为解决方案。对于关键的CPS控制流，丢弃数据包是失败，而不是正确协议的一个特性。它违反了无缝转换的隐含目标。此外，在某些交换机上过早地移除 $\\pi_0$ 规则会使回滚变得复杂，并引入了另一个不一致的来源。\n\n结论：**不正确**。\n\n**D. 单阶段乐观方法：向所有 $S_i$ 广播 $\\pi_1$ 规则更新，并立即更新 $G$ 以标记 $v=1$；依赖最终一致性和有界延迟 $D_{\\max}$ 及 $T_{\\text{inst}}$ 来确保网络快速收敛；在小于 $T_{\\text{flight}}$ 的固定宽限期后移除 $\\pi_0$ 规则以减少重叠。**\n\n这种“广播并祈祷”（spray and pray）的方法不提供任何原子性保证。在来自 $G$ 的一个新标记的数据包和来自 $C$ 的规则更新传播之间存在明显的竞争条件。一个带有 $v=1$ 的数据包很可能在 $\\pi_1$ 规则到达并安装之前就到达交换机 $S_i$，导致该数据包被丢弃。“最终一致性”是此问题的错误一致性模型；它允许瞬态不一致，而这正是安全不变量明确禁止的。在小于 $T_{\\text{flight}}$ 的时间段后移除 $\\pi_0$ 规则也是不正确的，因为它保证了一些传输中的 $v=0$ 数据包的规则会在它们仍在传输时被移除。\n\n结论：**不正确**。\n\n**E. 准备阶段：获取关于集合 $\\mathcal{F}$ 的粗粒度控制器锁以阻塞并发的计量器更新；然后以任意顺序通过移除 $\\pi_0$ 规则并安装 $\\pi_1$ 规则来顺序更新每个 $S_i$；通过释放锁并更新 $G$ 以标记 $v=1$ 来提交；假设即使数据包遍历在不同时间更新的交换机，该锁也能确保端到端的原子性。**\n\n该选项混淆了控制平面同步和数据平面原子性。控制器进程内的锁可以解决控制平面的竞争条件（丢失更新问题），确保策略更新逻辑和计量器更新逻辑*在控制器软件内部*互不干扰。然而，这个锁对跨交换机的分布式状态没有影响。顺序更新交换机的过程会造成一个长期的全网不一致状态，其中一些交换机使用 $\\pi_0$ 而另一些使用 $\\pi_1$。假设控制器侧的锁“确保端到端原子性”是错误的；它混淆了两个不同的问题。数据平面一致性的分布式系统问题仍然完全未解决。\n\n结论：**不正确**。\n\n综上所述，只有选项 A 描述了一个正确使用版本控制和两阶段提交结构，以在给定条件下保证安全不变量的协议。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}