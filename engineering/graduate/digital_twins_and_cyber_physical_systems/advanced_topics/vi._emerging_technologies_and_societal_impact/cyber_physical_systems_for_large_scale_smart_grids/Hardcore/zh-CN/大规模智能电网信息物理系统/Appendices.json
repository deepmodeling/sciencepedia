{
    "hands_on_practices": [
        {
            "introduction": "本练习将引导您探索大规模电力系统中最核心的控制问题之一：负荷频率控制。通过建立一个包含下垂控制（一次调频）和积分控制（二次调频）的简化模型，您将推导出系统在应对负荷阶跃扰动时的动态响应。这项实践旨在加深您对反馈控制原理的理解，特别是积分环节如何在扰动后将系统频率精确恢复至标称值，这是确保电网可靠运行的基石 。",
            "id": "4211441",
            "problem": "一个大规模智能电网在一个信息物理系统中被建模为单区域聚合体，该系统带有一个数字孪生，用于估计系统频率偏差并分派控制指令。物理电网频率的聚合动态特性由摇摆方程以及线性化的一次和二次控制来建模。假设包含以下标准元素：\n\n- 聚合频率偏差的摇摆方程为 $M \\frac{d \\Delta \\omega(t)}{dt} = \\Delta P_{m}(t) - \\Delta P_{L}(t) - D \\Delta \\omega(t)$，其中 $M$ 是等效惯性常数，$D$ 是代表负荷-频率敏感度的等效阻尼系数，$\\Delta \\omega(t)$ 是角频率偏差（单位：弧度/秒），$\\Delta P_{m}(t)$ 是机械功率偏差，$\\Delta P_{L}(t)$ 是负荷偏差。\n- 一次下垂控制使用下垂系数 $R$，使得一次控制增益为 $K_{p} = \\frac{1}{R}$，其对机械功率的贡献为 $\\Delta P_{m,\\mathrm{pri}}(t) = - K_{p} \\Delta \\omega(t)$。\n- 二次控制（自动发电控制）使用增益为 $K_{i}$ 的积分作用，作用于测量的频率偏差，产生 $\\Delta P_{\\mathrm{sec}}(t)$，其关系为 $\\frac{d}{dt}\\Delta P_{\\mathrm{sec}}(t) = - K_{i} \\Delta \\omega(t)$。净机械功率偏差为 $\\Delta P_{m}(t) = \\Delta P_{m,\\mathrm{pri}}(t) + \\Delta P_{\\mathrm{sec}}(t)$。\n- 数字孪生提供精确的 $\\Delta \\omega(t)$；所有信号测量和执行机构均被理想化（无死区、延迟或饱和）。\n\n在时间 $t=0$ 时，该区域经历一个阶跃负荷增长，幅度为 $\\Delta P_{L}(t) = \\Delta P_{0} u(t)$，其中 $\\Delta P_{0} = 100$ MW，$u(t)$ 是单位阶跃函数。从上述定义和基本定律出发，推导从 $\\Delta P_{L}(s)$到 $\\Delta \\omega(s)$ 的闭环输入-输出关系，并用它来计算稳态频率偏差 $\\lim_{t \\to \\infty} \\Delta f(t)$，其中 $\\Delta f(t) = \\frac{\\Delta \\omega(t)}{2 \\pi}$。最终答案以赫兹（Hertz）为单位表示。不要四舍五入，以单个数字的形式提供精确值。",
            "solution": "该问题要求推导将负荷扰动映射到系统频率偏差的闭环传递函数，并随后计算阶跃负荷扰动下的稳态频率偏差。分析从所给出的单区域智能电网模型的动态方程开始。\n\n控制方程如下：\n1. 摇摆方程：$M \\frac{d \\Delta \\omega(t)}{dt} = \\Delta P_{m}(t) - \\Delta P_{L}(t) - D \\Delta \\omega(t)$\n2. 净机械功率：$\\Delta P_{m}(t) = \\Delta P_{m,\\mathrm{pri}}(t) + \\Delta P_{\\mathrm{sec}}(t)$\n3. 一次控制（下垂）：$\\Delta P_{m,\\mathrm{pri}}(t) = - K_{p} \\Delta \\omega(t)$\n4. 二次控制（积分作用）：$\\frac{d}{dt}\\Delta P_{\\mathrm{sec}}(t) = - K_{i} \\Delta \\omega(t)$\n\n为了推导传递函数，我们将这些时域方程转换到拉普拉斯域。假设系统在 $t=0$ 之前处于静止状态，所有初始条件均为零。方程的拉普拉斯变换为：\n\n1'. $M s \\Delta \\omega(s) = \\Delta P_{m}(s) - \\Delta P_{L}(s) - D \\Delta \\omega(s)$\n2'. $\\Delta P_{m}(s) = \\Delta P_{m,\\mathrm{pri}}(s) + \\Delta P_{\\mathrm{sec}}(s)$\n3'. $\\Delta P_{m,\\mathrm{pri}}(s) = - K_{p} \\Delta \\omega(s)$\n4'. $s \\Delta P_{\\mathrm{sec}}(s) = - K_{i} \\Delta \\omega(s)$，这意味着 $\\Delta P_{\\mathrm{sec}}(s) = -\\frac{K_{i}}{s} \\Delta \\omega(s)$\n\n我们将这些代数方程组合起来，以找出输入 $\\Delta P_{L}(s)$ 和输出 $\\Delta \\omega(s)$ 之间的关系。首先，将 $\\Delta P_{m,\\mathrm{pri}}(s)$ 和 $\\Delta P_{\\mathrm{sec}}(s)$ 的表达式代入净机械功率 $\\Delta P_{m}(s)$ 的方程中：\n$\\Delta P_{m}(s) = - K_{p} \\Delta \\omega(s) - \\frac{K_{i}}{s} \\Delta \\omega(s) = - \\left( K_{p} + \\frac{K_{i}}{s} \\right) \\Delta \\omega(s)$\n\n接着，将 $\\Delta P_{m}(s)$ 的这个表达式代入变换后的摇摆方程（1'）中：\n$M s \\Delta \\omega(s) = - \\left( K_{p} + \\frac{K_{i}}{s} \\right) \\Delta \\omega(s) - \\Delta P_{L}(s) - D \\Delta \\omega(s)$\n\n为了求解 $\\Delta \\omega(s)$，我们重新整理方程，将所有包含 $\\Delta \\omega(s)$ 的项移到等式左边：\n$M s \\Delta \\omega(s) + D \\Delta \\omega(s) + K_{p} \\Delta \\omega(s) + \\frac{K_{i}}{s} \\Delta \\omega(s) = - \\Delta P_{L}(s)$\n\n提出公因子 $\\Delta \\omega(s)$：\n$\\Delta \\omega(s) \\left( Ms + D + K_{p} + \\frac{K_{i}}{s} \\right) = - \\Delta P_{L}(s)$\n\n为简化括号中的表达式，我们进行通分，公分母为 $s$：\n$\\Delta \\omega(s) \\left( \\frac{Ms^{2} + (D + K_{p})s + K_{i}}{s} \\right) = - \\Delta P_{L}(s)$\n\n因此，闭环输入-输出关系，即传递函数 $G(s) = \\frac{\\Delta \\omega(s)}{\\Delta P_{L}(s)}$ 为：\n$$G(s) = \\frac{\\Delta \\omega(s)}{\\Delta P_{L}(s)} = \\frac{-s}{Ms^{2} + (D + K_{p})s + K_{i}}$$\n\n这是第一个要求的结果。现在我们来计算稳态频率偏差。电网经历一个幅度为 $\\Delta P_{0} = 100$ MW 的阶跃负荷增长，即 $\\Delta P_{L}(t) = \\Delta P_{0} u(t)$。该输入的拉普拉斯变换为：\n$\\Delta P_{L}(s) = \\mathcal{L}\\{\\Delta P_{0} u(t)\\} = \\frac{\\Delta P_{0}}{s}$\n\n拉普拉斯域中的角频率偏差 $\\Delta \\omega(s)$ 是传递函数 $G(s)$ 与输入 $\\Delta P_{L}(s)$ 的乘积：\n$\\Delta \\omega(s) = G(s) \\Delta P_{L}(s) = \\left( \\frac{-s}{Ms^{2} + (D + K_{p})s + K_{i}} \\right) \\left( \\frac{\\Delta P_{0}}{s} \\right)$\n$\\Delta \\omega(s) = \\frac{-\\Delta P_{0}}{Ms^{2} + (D + K_{p})s + K_{i}}$\n\n为了求出角频率偏差的稳态值 $\\Delta \\omega_{ss} = \\lim_{t \\to \\infty} \\Delta \\omega(t)$，我们应用拉普拉斯变换的终值定理（FVT）。该定理指出 $\\lim_{t \\to \\infty} y(t) = \\lim_{s \\to 0} s Y(s)$，前提是 $sY(s)$ 的所有极点都位于复平面的左半部分。系统的极点是特征方程 $Ms^{2} + (D + K_{p})s + K_{i} = 0$ 的根。对于一个物理上稳定的电力系统，惯性 $M$、阻尼 $D$、一次控制增益 $K_p$ 和二次控制增益 $K_i$ 均为正常数。二阶特征多项式的系数 $M > 0$，$(D + K_{p}) > 0$ 和 $K_{i} > 0$。根据劳斯-赫尔维茨稳定性判据，一个二阶系统是稳定的当且仅当其所有系数同号。由于所有系数均为正，该系统是稳定的，其极点位于左半平面，因此终值定理适用。\n\n应用终值定理：\n$\\Delta \\omega_{ss} = \\lim_{s \\to 0} s \\Delta \\omega(s) = \\lim_{s \\to 0} s \\left( \\frac{-\\Delta P_{0}}{Ms^{2} + (D + K_{p})s + K_{i}} \\right)$\n$\\Delta \\omega_{ss} = \\lim_{s \\to 0} \\frac{-s \\Delta P_{0}}{Ms^{2} + (D + K_{p})s + K_{i}}$\n\n将 $s=0$ 代入求极限：\n$\\Delta \\omega_{ss} = \\frac{-(0) \\Delta P_{0}}{M(0)^{2} + (D + K_{p})(0) + K_{i}} = \\frac{0}{K_{i}}$\n由于 $K_i$ 是非零增益，结果为：\n$\\Delta \\omega_{ss} = 0$ rad/s\n\n这个结果证明了积分控制的一个基本特性：对于阶跃输入，它能将稳态误差驱动至零。二次控制（AGC）确保在负荷扰动后，频率能返回其额定值。\n\n问题要求以赫兹（Hertz）为单位的稳态频率偏差 $\\Delta f_{ss}$。角频率偏差 $\\Delta \\omega$ 与频率偏差 $\\Delta f$ 之间的关系是 $\\Delta f(t) = \\frac{\\Delta \\omega(t)}{2 \\pi}$。\n因此，稳态值为：\n$\\Delta f_{ss} = \\lim_{t \\to \\infty} \\Delta f(t) = \\frac{1}{2 \\pi} \\lim_{t \\to \\infty} \\Delta \\omega(t) = \\frac{\\Delta \\omega_{ss}}{2 \\pi} = \\frac{0}{2 \\pi} = 0$ Hz。\n稳态频率偏差为 $0$ 赫兹。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "在理解了频率的稳态调节机制后，本练习将带您进入动态仿真的世界，以分析系统在重大扰动下的暂态行为。我们将电网抽象为一个混合系统，该系统会因线路跳闸等事件从并网模式切换到孤岛模式。通过建立并求解描述系统动态的常微分方程组，您将亲手模拟频率在孤岛事件发生后的演变轨迹，从而掌握分析信息物理系统关键事件响应的核心技能 。",
            "id": "4211450",
            "problem": "考虑一个大规模智能电网的聚合区域，该区域被建模为一个混合信息-物理系统，具有两种离散模式：标称运行（并网）和孤岛模式（线路跳闸事件后）。系统在时间 $t = 1\\ \\text{s}$ 时因联络线瞬时断开而从标称模式转换到孤岛模式。目标是使用基于电力系统基本动态学原理的连续时间模型，计算在一次频率下垂控制下的事件后频率轨迹。\n\n从代表该区域的等效发电机的摇摆方程开始。在区域功率基准上使用标幺值归一化，并包含与频率相关的负荷阻尼。令 $H$ 表示惯性常数（单位为秒），$f_0$ 表示标称频率（单位为赫兹），$\\Delta f(t)$ 表示频率偏差（单位为赫兹）。令 $\\Delta P_m(t)$ 表示机械功率偏离事件前平衡点的标幺值，令 $\\Delta P_e(t)$ 表示由扰动和负荷-频率效应引起的电功率偏离的标幺值。假设负荷-频率敏感性由线性阻尼系数 $D$（单位为标幺功率/标幺频率偏差）建模。假设一次控制由一个一阶调速器实现，其下垂系数为 $R$（单位为标幺频率/标幺功率），时间常数为 $T_g$（单位为秒）。假设聚合的电气扰动是在 $t = 1\\ \\text{s}$ 时施加的一个阶跃增量，其大小等于损失的输入功率 $P_{\\text{step}}$（标幺值），即 $\\Delta P_e(t)$ 在 $t = 1\\ \\text{s}$ 时包含一个大小为 $P_{\\text{step}}$ 的阶跃，代表孤岛化。\n\n您必须推导、实现并仿真由以下原理得出的连续动态过程：\n- 摇摆方程和功率平衡守恒，以及\n- 带有一阶执行器模型的调速器下垂定律。\n\n令混合切换定义如下：\n- 对于 $0 \\le t  1\\ \\text{s}$（标称运行模式），$\\Delta P_e(t) = 0$，系统处于平衡状态，$\\Delta f(0) = 0$ 且 $\\Delta P_m(0) = 0$。\n- 对于 $t \\ge 1\\ \\text{s}$（孤岛模式），$\\Delta P_e(t) = P_{\\text{step}}$，即有效电功率需求增加，其量等于损失的输入功率。\n\n仅使用这些基本原理和定义，为状态量 $\\Delta f(t)$（单位赫兹）和 $\\Delta P_m(t)$（单位标幺值）构建一个最小的连续时间常微分方程闭集，该方程组在上述混合激励 $\\Delta P_e(t)$ 的定义下对所有 $t \\ge 0$ 均有效。对下述测试套件中的每组参数，在有限时间域 $[0, T_{\\text{end}}]$ 上对所得系统进行数值积分。不指定数值积分方法；您可以使用任何适用于刚性或非刚性系统的标准方法。在 $t = 1\\ \\text{s}$ 时的离散事件必须作为模式切换，在激励项中精确执行。\n\n对每个测试用例，计算以下两个以赫兹表示的标量性能指标：\n1. 事件后的频率最低点（nadir），定义为 $\\min_{t \\in [1\\ \\text{s}, T_{\\text{end}}]} \\left(f_0 + \\Delta f(t)\\right)$，单位为赫兹，四舍五入到 $6$ 位小数。\n2. 时间 $t = 5\\ \\text{s}$ 时的绝对频率，即 $f_0 + \\Delta f(5\\ \\text{s})$，单位为赫兹，四舍五入到 $6$ 位小数。\n\n最终答案中出现的所有物理量都必须以赫兹报告。此问题不涉及角度，因此不需要角度单位。不得使用百分比；所有值均为实数。\n\n测试套件参数：\n- 用例 A（理想情况，$50$ 赫兹系统，中等惯量和下垂系数）：$f_0 = 50\\ \\text{Hz}$，$H = 5$，$D = 1$，$R = 0.05$，$T_g = 0.5\\ \\text{s}$，$P_{\\text{step}} = 0.2$，$T_{\\text{end}} = 10\\ \\text{s}$。\n- 用例 B（不同标称频率，低惯量，强一次响应）：$f_0 = 60\\ \\text{Hz}$，$H = 2$，$D = 0.5$，$R = 0.04$，$T_g = 0.2\\ \\text{s}$，$P_{\\text{step}} = 0.1$，$T_{\\text{end}} = 8\\ \\text{s}$。\n- 用例 C（高惯量，弱下垂，较大扰动）：$f_0 = 50\\ \\text{Hz}$，$H = 10$，$D = 2$，$R = 0.1$，$T_g = 1.0\\ \\text{s}$，$P_{\\text{step}} = 0.3$，$T_{\\text{end}} = 12\\ \\text{s}$。\n- 用例 D（可忽略扰动的边缘情况，无显式负荷阻尼）：$f_0 = 50\\ \\text{Hz}$，$H = 3$，$D = 0$，$R = 0.05$，$T_g = 0.05\\ \\text{s}$，$P_{\\text{step}} = 0.001$，$T_{\\text{end}} = 5.5\\ \\text{s}$。\n\n您的程序必须：\n- 实现从基本原理推导出的模型，以计算在 $t = 1\\ \\text{s}$ 处有混合切换的每个测试用例的 $\\Delta f(t)$ 和 $\\Delta P_m(t)$。\n- 对每个测试用例，输出上述指定的两个以赫兹为单位的指标，四舍五入到 $6$ 位小数。\n- 将四个用例的所有结果汇总到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{nadir}_A,\\ f_5^{(A)},\\ \\text{nadir}_B,\\ f_5^{(B)},\\ \\text{nadir}_C,\\ f_5^{(C)},\\ \\text{nadir}_D,\\ f_5^{(D)}]$，其中每个条目都是一个浮点数。\n\n最终输出必须严格遵循指定格式，只有一行，且无任何附加文本。",
            "solution": "该问题要求为孤岛电力系统区域的一次频率响应建立连续时间模型并进行数值求解。该模型必须从第一性原理推导得出，具体而言是摇摆方程和一阶调速器模型。我们将构建系统动态的状态空间表示。状态变量是频率偏差 $\\Delta f(t)$（单位赫兹）和机械功率偏差 $\\Delta P_m(t)$（单位标幺值 p.u.）。\n\n该系统由两个相互关联的物理原理定义：能量守恒（摇摆方程）和一次控制动作（调速器响应）。\n\n首先，我们建立摇摆方程，它控制着代表该区域的等效发电机的转速动态。将转子速度变化与功率不平衡关联起来的线性化摇摆方程由下式给出：\n$$\n\\frac{2H}{f_0} \\frac{d(\\Delta f)}{dt} = \\Delta P_m(t) - \\Delta P_{load}(t)\n$$\n此处，$H$ 是聚合惯性常数（单位为秒），$f_0$ 是标称系统频率（单位为赫兹），$\\Delta f(t)$ 是频率偏差（单位为赫兹），$\\Delta P_m(t)$ 是机械功率输入相对事件前平衡值的偏差（单位为标幺值 p.u.）。项 $\\Delta P_{load}(t)$ 代表总的电负荷偏差（单位为标幺值 p.u.）。这个总负荷偏差由两部分组成：外部扰动 $\\Delta P_e(t)$ 和频率相关的负荷响应（负荷阻尼）。\n\n外部扰动 $\\Delta P_e(t)$ 因 $t=1\\,\\text{s}$ 时的孤岛事件而被建模为一个阶跃函数：\n$$\n\\Delta P_e(t) = \\begin{cases} 0  \\text{for } t  1\\,\\text{s} \\\\ P_{\\text{step}}  \\text{for } t \\ge 1\\,\\text{s} \\end{cases}\n$$\n其中 $P_{\\text{step}}$ 是损失的输入功率的大小，这部分功率现在必须由本地发电提供，实际上相当于本地需求的瞬时增加。\n\n负荷阻尼效应模拟了许多电力负荷在频率下降时功耗略有降低的固有趋势。这由阻尼系数 $D$ 来量化，其单位定义为标幺值功率/标幺值频率偏差。标幺值频率偏差为 $\\frac{\\Delta f(t)}{f_0}$。因此，由阻尼引起的负荷变化为 $D \\frac{\\Delta f(t)}{f_0}$。该项通过抵消频率变化来稳定系统。\n\n总的电负荷偏差是扰动和阻尼效应的总和：\n$$\n\\Delta P_{load}(t) = \\Delta P_e(t) + D \\frac{\\Delta f(t)}{f_0}\n$$\n将此代入摇摆方程可得：\n$$\n\\frac{2H}{f_0} \\frac{d(\\Delta f)}{dt} = \\Delta P_m(t) - \\left( \\Delta P_e(t) + D \\frac{\\Delta f(t)}{f_0} \\right)\n$$\n重新整理以分离出第一个状态变量 $\\Delta f(t)$ 的导数，我们得到第一个常微分方程（ODE）：\n$$\n\\frac{d(\\Delta f)}{dt} = -\\frac{D}{2H} \\Delta f(t) + \\frac{f_0}{2H} \\Delta P_m(t) - \\frac{f_0}{2H} \\Delta P_e(t)\n$$\n\n其次，我们对一次频率控制动作进行建模，该动作由等效发电机的调速器执行。调速器根据频率偏差 $\\Delta f(t)$ 调整机械功率输入 $\\Delta P_m(t)$。该控制律基于下垂特性，即期望的稳态机械功率变化与频率偏差成正比。下垂系数 $R$ 定义为实现满标幺值功率响应所需的标幺值频率变化量。因此，调速器的目标功率参考值 $\\Delta P_{ref}(t)$ 为：\n$$\n\\Delta P_{ref}(t) = -\\frac{1}{R} \\left( \\frac{\\Delta f(t)}{f_0} \\right)\n$$\n负号确保频率下降（负的 $\\Delta f$）会产生增加机械功率的指令。\n\n问题指定了一个带时间常数 $T_g$ 的一阶执行器模型用于调速器。这意味着实际的机械功率 $\\Delta P_m(t)$ 以一阶滞后方式跟随参考值 $\\Delta P_{ref}(t)$：\n$$\nT_g \\frac{d(\\Delta P_m)}{dt} + \\Delta P_m(t) = \\Delta P_{ref}(t)\n$$\n代入 $\\Delta P_{ref}(t)$ 的表达式：\n$$\nT_g \\frac{d(\\Delta P_m)}{dt} + \\Delta P_m(t) = -\\frac{1}{R f_0} \\Delta f(t)\n$$\n重新整理以分离出第二个状态变量 $\\Delta P_m(t)$ 的导数，我们得到第二个常微分方程：\n$$\n\\frac{d(\\Delta P_m)}{dt} = -\\frac{1}{R T_g f_0} \\Delta f(t) - \\frac{1}{T_g} \\Delta P_m(t)\n$$\n\n现在我们有了一个由两个耦合的、线性的、一阶常微分方程组成的完整系统。令状态向量为 $x(t) = \\begin{bmatrix} \\Delta f(t) \\\\ \\Delta P_m(t) \\end{bmatrix}$。该系统可以写成状态空间形式 $\\dot{x}(t) = Ax(t) + Bu(t)$：\n$$\n\\frac{d}{dt} \\begin{bmatrix} \\Delta f(t) \\\\ \\Delta P_m(t) \\end{bmatrix} = \\begin{bmatrix} -\\frac{D}{2H}  \\frac{f_0}{2H} \\\\ -\\frac{1}{R T_g f_0}  -\\frac{1}{T_g} \\end{bmatrix} \\begin{bmatrix} \\Delta f(t) \\\\ \\Delta P_m(t) \\end{bmatrix} + \\begin{bmatrix} -\\frac{f_0}{2H} \\\\ 0 \\end{bmatrix} \\Delta P_e(t)\n$$\n系统在事件前处于平衡状态，因此在 $t=0$ 时的初始条件为：\n$$\n\\Delta f(0) = 0 \\quad \\text{and} \\quad \\Delta P_m(0) = 0\n$$\n对于测试套件中提供的每组参数，将对该常微分方程组从 $t=0$ 到 $t=T_{\\text{end}}$ 进行数值积分。使用标准的数值求解器即可，例如龙格-库塔法。输入 $\\Delta P_e(t)$ 的分段常数特性在定义导数的函数中直接处理。\n\n从得到的 $\\Delta f(t)$ 的时域解中，我们可以计算所需的指标：\n1.  频率最低点通过计算 $\\min_{t \\in [1, T_{\\text{end}}]} (f_0 + \\Delta f(t))$ 求得。这需要在事件后区间内的精细时间网格上评估解。\n2.  在 $t=5\\,\\text{s}$ 时的频率直接计算为 $f_0 + \\Delta f(5)$。\n\n至此，问题的建模过程完成。实现部分将涉及将此数学模型转换为代码，并针对给定的测试用例执行它。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Derives and solves the system of ODEs for primary frequency control\n    in a power system and computes specified performance metrics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, 50 hertz system, moderate inertia and droop)\n        {'f0': 50.0, 'H': 5.0, 'D': 1.0, 'R': 0.05, 'Tg': 0.5, 'P_step': 0.2, 'T_end': 10.0},\n        # Case B (different nominal frequency, low inertia, strong primary response)\n        {'f0': 60.0, 'H': 2.0, 'D': 0.5, 'R': 0.04, 'Tg': 0.2, 'P_step': 0.1, 'T_end': 8.0},\n        # Case C (high inertia, weak droop, larger disturbance)\n        {'f0': 50.0, 'H': 10.0, 'D': 2.0, 'R': 0.1, 'Tg': 1.0, 'P_step': 0.3, 'T_end': 12.0},\n        # Case D (edge case with negligible disturbance, no explicit load damping)\n        {'f0': 50.0, 'H': 3.0, 'D': 0.0, 'R': 0.05, 'Tg': 0.05, 'P_step': 0.001, 'T_end': 5.5}\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        f0 = case['f0']\n        H = case['H']\n        D = case['D']\n        R = case['R']\n        Tg = case['Tg']\n        P_step = case['P_step']\n        T_end = case['T_end']\n\n        # Define the system of ordinary differential equations (ODEs).\n        # y[0] is delta_f (frequency deviation in Hz)\n        # y[1] is delta_Pm (mechanical power deviation in p.u.)\n        def system_dynamics(t, y):\n            delta_f, delta_Pm = y\n            \n            # Hybrid switch for the electrical disturbance at t=1s\n            delta_Pe = P_step if t >= 1.0 else 0.0\n            \n            # Equation for d(delta_f)/dt from the swing equation\n            # d(df)/dt = -(D/(2H))*df + (f0/(2H))*dPm - (f0/(2H))*dPe\n            d_delta_f_dt = (f0 / (2.0 * H)) * (delta_Pm - delta_Pe) - (D / (2.0 * H)) * delta_f\n            \n            # Equation for d(delta_Pm)/dt from the first-order governor model\n            # d(dPm)/dt = -(1/(R*Tg*f0))*df - (1/Tg)*dPm\n            d_delta_Pm_dt = (-1.0 / (R * Tg * f0)) * delta_f - (1.0 / Tg) * delta_Pm\n            \n            return [d_delta_f_dt, d_delta_Pm_dt]\n\n        # Set initial conditions: system at equilibrium\n        y0 = [0.0, 0.0]\n        \n        # Set the time span for integration\n        t_span = [0.0, T_end]\n        \n        # Numerically solve the ODE system.\n        # dense_output=True allows for evaluation at any point in the interval.\n        sol = solve_ivp(system_dynamics, t_span, y0, method='RK45', dense_output=True, rtol=1e-8, atol=1e-8)\n        \n        # --- Calculate and store the performance metrics ---\n        \n        # 1. Frequency nadir (minimum frequency) post-event\n        # The nadir occurs after the disturbance at t=1.0s.\n        # We evaluate the solution on a fine grid to find the minimum.\n        t_eval_nadir = np.linspace(1.0, T_end, 2000)\n        delta_f_values = sol.sol(t_eval_nadir)[0]\n        nadir = f0 + np.min(delta_f_values)\n        \n        # 2. Absolute frequency at t=5s\n        # All T_end values are >= 5.5s, so t=5s is a valid point.\n        delta_f_at_5s = sol.sol(5.0)[0]\n        f_at_5s = f0 + delta_f_at_5s\n\n        # Append the rounded results to the list\n        all_results.append(round(nadir, 6))\n        all_results.append(round(f_at_5s, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后的这项实践将您的视角从传统发电机转向现代智能电网的核心——基于逆变器的资源。我们将探讨“虚拟同步机”（VSM）这一前沿的并网型控制策略，它能使逆变器模拟传统同步发电机的惯性和阻尼特性，从而主动支撑电网。您的任务是设计并实现一套参数整定算法，为VSM控制器选择合适的虚拟惯量 $M$ 和虚拟阻尼 $D$，以满足特定的动态性能指标，例如阻尼比和自然振荡频率 。",
            "id": "4211437",
            "problem": "考虑一个构网型逆变器，通过一个等效戴维南电抗连接到一个大规模智能电网的公共耦合点。该逆变器由虚拟同步电机（VSM）控制法则控制，该法则模拟了同步发电机的小信号动态特性。控制目标是选择 VSM 参数，以便在指定的短路比下达到目标阻尼比。在标幺值归一化下进行计算，其中基准电压等于额定母线电压，基准功率等于逆变器额定功率。假设系统处于平衡、正弦稳态，且角度偏差为小角度。\n\n基本依据与建模假设：\n- 跨电抗传输的交流有功功率遵循功角关系 $P = \\dfrac{V_1 V_2}{X} \\sin(\\delta)$，其中 $P$ 是有功功率，$V_1$ 和 $V_2$ 是母线电压幅值，$X$ 是串联电抗，$\\delta$ 是电角度差。对于工作点在 $V_1 \\approx V_2 \\approx 1$ 标幺值且 $\\delta \\approx 0$ 弧度附近的小偏差，线性化后得到 $P \\approx K_s \\, \\delta$，其中同步刚度 $K_s = \\dfrac{V_1 V_2}{X} \\approx \\dfrac{1}{X}$。\n- 公共耦合点的电网短路比 (SCR) 定义为 $\\mathrm{SCR} = \\dfrac{S_{\\text{sc}}}{S_{\\text{base}}}$，在 $V = 1$ 的标幺值下满足 $X_{\\text{th}} \\approx \\dfrac{1}{\\mathrm{SCR}}$。因此，小信号同步刚度为 $K_s \\approx \\mathrm{SCR}$。\n- 虚拟同步电机 (VSM) 的频率-角度动态特性被建模为关于角度偏差 $\\delta$ 的二阶摇摆方程：$$M \\, \\dfrac{d^2 \\delta}{dt^2} + D \\, \\dfrac{d \\delta}{dt} + K_s \\, \\delta = \\Delta P_m,$$ 其中 $M$ 是虚拟惯性系数，$D$ 是虚拟阻尼系数，$K_s$ 是同步刚度，$\\Delta P_m$ 是来自控制环路的小信号等效机械功率输入。角度单位为弧度，角频率单位为弧度/秒 ($\\mathrm{rad/s}$)。在标准二阶形式中，两边同除以 $M$ 可得：$$\\dfrac{d^2 \\delta}{dt^2} + \\dfrac{D}{M} \\dfrac{d \\delta}{dt} + \\dfrac{K_s}{M} \\delta = \\dfrac{\\Delta P_m}{M}.$$ 与具有自然频率 $\\omega_n$ 和阻尼比 $\\zeta$ 的标准二阶形式进行比较：$$\\dfrac{d^2 \\delta}{dt^2} + 2 \\zeta \\omega_n \\dfrac{d \\delta}{dt} + \\omega_n^2 \\delta = \\text{input},$$ 可得到等价关系 $\\omega_n^2 = \\dfrac{K_s}{M}$ 和 $2 \\zeta \\omega_n = \\dfrac{D}{M}$。\n\n你的任务：\n- 通过选择 $M$ 和 $D$ 来构建控制器参数化，以在给定的短路比 $\\mathrm{SCR}$ 下实现指定的目标阻尼比 $\\zeta_{\\text{target}}$ 和目标自然频率 $\\omega_{n,\\text{target}}$。利用基本关系推导并实现 $M$ 和 $D$ 关于 $K_s$、$\\zeta_{\\text{target}}$ 和 $\\omega_{n,\\text{target}}$ 的公式。\n- 对每个测试用例，计算：\n  - 根据 $\\mathrm{SCR}$ 使用 $K_s = \\mathrm{SCR}$ 计算同步刚度 $K_s$。\n  - 为实现目标 $\\zeta_{\\text{target}}$ 和 $\\omega_{n,\\text{target}}$ 而整定的参数 $M$ 和 $D$。\n  - 根据 $M$、$D$ 和 $K_s$，使用 $\\zeta_{\\text{achieved}} = \\dfrac{D}{2 \\sqrt{M K_s}}$ 和 $\\omega_{n,\\text{achieved}} = \\sqrt{\\dfrac{K_s}{M}}$ 计算实现的阻尼比 $\\zeta_{\\text{achieved}}$ 和自然频率 $\\omega_{n,\\text{achieved}}$。\n  - 齐次系统的闭环极点和一个布尔稳定性标志，指示是否所有极点都具有严格为负的实部（当 $M  0$、$D  0$ 和 $K_s  0$ 时，预期系统是稳定的）。你无需输出极点本身，只需输出布尔标志。\n  - 在标准二阶近似下，角度响应的单位阶跃超调量（以小数形式表示，不带百分号）。对于 $0  \\zeta  1$，使用 $$M_p = \\exp\\!\\left( -\\dfrac{\\zeta \\pi}{\\sqrt{1 - \\zeta^2}} \\right)$$。对于 $\\zeta \\ge 1$，设置 $M_p = 0$。同时生成一个布尔值，指示 $M_p \\le 0.1$ 是否成立。\n\n报告与单位：\n- 角度单位为弧度。自然频率 $\\omega_n$ 必须以 $\\mathrm{rad/s}$ 为单位报告。阻尼比 $\\zeta$ 是无量纲的。参数 $M$ 和 $D$ 应作为与上述归一化二阶形式一致的无量纲标幺值系数进行报告。\n- 除布尔标志外，所有数值输出必须为浮点数。\n- 对每个测试用例，按顺序 $[M, D, \\zeta_{\\text{achieved}}, \\omega_{n,\\text{achieved}}, \\text{stable}, M_p, \\text{overshoot\\_ok}]$ 输出一个列表，其中 $\\text{stable}$ 和 $\\text{overshoot\\_ok}$ 是布尔值。\n\n测试套件：\n使用以下测试用例集，每个用例指定为 $(\\mathrm{SCR}, \\zeta_{\\text{target}}, \\omega_{n,\\text{target}})$，其中 $\\omega_{n,\\text{target}}$ 的单位为 $\\mathrm{rad/s}$：\n- 用例 A (标准情况): $(5.0, 0.7, 2 \\pi \\cdot 3)$。\n- 用例 B (弱电网边缘情况): $(0.8, 0.05, 2 \\pi \\cdot 1)$。\n- 用例 C (强电网): $(10.0, 0.9, 2 \\pi \\cdot 5)$。\n- 用例 D (临界阻尼边界): $(3.0, 1.0, 2 \\pi \\cdot 2)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3]$）。每个 $result_i$ 必须是第 $i$ 个测试用例的结果列表 $[M, D, \\zeta_{\\text{achieved}}, \\omega_{n,\\text{achieved}}, \\text{stable}, M_p, \\text{overshoot\\_ok}]$，并按上述顺序排列。",
            "solution": "问题陈述已经过严格验证，并被认定为有效。它在科学上基于电力系统动态学和控制理论的既定原则，其定义和约束清晰完整，问题适定，并以客观、正式的语言表述。其中不存在矛盾、歧义或不成立的前提。因此，我们可以着手提供完整的解决方案。\n\n任务的核心是设计虚拟同步电机 (VSM) 控制器的参数，以满足构网型逆变器的指定动态性能目标。解决方案涉及从基本运动方程中推导控制器参数，然后将这些参数应用于一组测试用例。\n\n首先，我们为控制器设计建立理论基础。问题提供了逆变器角度偏差 $\\delta$ 的小信号动态特性，该动态特性由二阶摇摆方程控制：\n$$M \\, \\dfrac{d^2 \\delta}{dt^2} + D \\, \\dfrac{d \\delta}{dt} + K_s \\, \\delta = \\Delta P_m$$\n此处，$M$ 是虚拟惯性系数，$D$ 是虚拟阻尼系数，$K_s$ 是同步刚度系数，它代表电网同步逆变器的能力。问题指出，在标幺值下进行小信号分析时，$K_s$ 近似等于短路比 $\\mathrm{SCR}$。因此，$K_s = \\mathrm{SCR}$。\n\n为了系统地设计控制器参数 $M$ 和 $D$，我们将此物理模型与二阶线性时不变系统的标准形式进行比较：\n$$\\dfrac{d^2 \\delta}{dt^2} + 2 \\zeta \\omega_n \\dfrac{d \\delta}{dt} + \\omega_n^2 \\delta = \\text{input}$$\n其中 $\\zeta$ 是阻尼比，$\\omega_n$ 是自然振荡频率。通过将 VSM 方程除以 $M$，我们得到：\n$$\\dfrac{d^2 \\delta}{dt^2} + \\dfrac{D}{M} \\dfrac{d \\delta}{dt} + \\dfrac{K_s}{M} \\delta = \\dfrac{\\Delta P_m}{M}$$\n通过比较 $\\delta$ 及其导数项的系数，我们建立了物理参数（$M, D, K_s$）与性能指标（$\\zeta, \\omega_n$）之间的以下关键关系：\n$$(1) \\quad \\omega_n^2 = \\dfrac{K_s}{M}$$\n$$(2) \\quad 2 \\zeta \\omega_n = \\dfrac{D}{M}$$\n我们的目标是确定 $M$ 和 $D$，使系统达到目标自然频率 $\\omega_{n,\\text{target}}$ 和目标阻尼比 $\\zeta_{\\text{target}}$。\n\n从关系式 (1) 中，我们可以求解出实现 $\\omega_{n,\\text{target}}$ 所需的虚拟惯性 $M$：\n$$\\omega_{n,\\text{target}}^2 = \\dfrac{K_s}{M} \\implies M = \\dfrac{K_s}{\\omega_{n,\\text{target}}^2}$$\n该方程表明，所需的惯性与电网刚度 $K_s$ 成正比，与期望自然频率的平方成反比。更快的期望响应（更高的 $\\omega_{n,\\text{target}}$）需要更小的虚拟惯性。\n\n接下来，我们使用关系式 (2) 求解虚拟阻尼 $D$。在计算上，用输入参数而不是中间参数 $M$ 来表示 $D$ 更为稳健。我们可以将 (2) 重新排列为 $D = 2 \\zeta \\omega_n M$。代入我们推导出的 $M$ 表达式：\n$$D = 2 \\zeta_{\\text{target}} \\omega_{n,\\text{target}} \\left( \\dfrac{K_s}{\\omega_{n,\\text{target}}^2} \\right) \\implies D = \\dfrac{2 \\zeta_{\\text{target}} K_s}{\\omega_{n,\\text{target}}}$$\n该方程指定了实现目标阻尼比 $\\zeta_{\\text{target}}$ 所需的阻尼系数。$D$ 与目标阻尼比和电网刚度均成正比，与目标自然频率成反比。\n\n利用这两个公式，我们可以为任何给定的电网条件和性能目标计算所需的控制器参数。每个测试用例的步骤如下：\n\n1.  **计算同步刚度**：给定短路比 $\\mathrm{SCR}$，我们使用提供的近似公式确定刚度：$K_s = \\mathrm{SCR}$。\n\n2.  **计算控制器参数**：使用目标值 $\\zeta_{\\text{target}}$ 和 $\\omega_{n,\\text{target}}$ 以及计算出的 $K_s$，我们计算控制器参数：\n    - $M = \\dfrac{K_s}{\\omega_{n,\\text{target}}^2}$\n    - $D = \\dfrac{2 \\zeta_{\\text{target}} K_s}{\\omega_{n,\\text{target}}}$\n\n3.  **验证实现的性能**：我们使用提供的验证公式来确认我们选择的 $M$ 和 $D$ 能够产生预期的性能。\n    - $\\omega_{n,\\text{achieved}} = \\sqrt{\\dfrac{K_s}{M}} = \\sqrt{\\dfrac{K_s}{K_s / \\omega_{n,\\text{target}}^2}} = \\omega_{n,\\text{target}}$\n    - $\\zeta_{\\text{achieved}} = \\dfrac{D}{2 \\sqrt{M K_s}} = \\dfrac{2 \\zeta_{\\text{target}} K_s / \\omega_{n,\\text{target}}}{2 \\sqrt{(K_s / \\omega_{n,\\text{target}}^2) K_s}} = \\dfrac{2 \\zeta_{\\text{target}} K_s / \\omega_{n,\\text{target}}}{2 (K_s / \\omega_{n,\\text{target}})} = \\zeta_{\\text{target}}$\n    如代数简化所示，在计算精度的前提下，实现值将与目标值匹配。\n\n4.  **评估稳定性**：系统的稳定性由其特征方程 $M s^2 + D s + K_s = 0$ 的极点决定。系统稳定的充分必要条件是所有系数（$M, D, K_s$）均为正，这确保了极点具有严格为负的实部。对于所有测试用例，SCR 均为正，因此 $K_s > 0$。目标 $\\zeta_{\\text{target}}$ 和 $\\omega_{n,\\text{target}}$ 也为正。因此，我们计算 $M$ 和 $D$ 的公式将产生正值，从而保证稳定性。`stable` 标志将为 `True`。\n\n5.  **计算超调量**：二阶系统阶跃响应的百分比超调量 $M_p$ 是根据阻尼比 $\\zeta$ 计算的。\n    - 对于欠阻尼系统 ($0  \\zeta  1$)：$M_p = \\exp\\!\\left( -\\dfrac{\\zeta \\pi}{\\sqrt{1 - \\zeta^2}} \\right)$。\n    - 对于临界阻尼或过阻尼系统 ($\\zeta \\ge 1$)：响应没有超调，因此 $M_p = 0$。\n\n6.  **评估超调约束**：将计算出的超调量 $M_p$ 与指定的阈值 $0.1$ 进行比较。如果 $M_p \\le 0.1$，则布尔标志 `overshoot_ok` 设置为 `True`，否则为 `False`。\n\n遵循此程序对每个测试用例进行操作，我们将生成一个包含计算值的列表 $[M, D, \\zeta_{\\text{achieved}}, \\omega_{n,\\text{achieved}}, \\text{stable}, M_p, \\text{overshoot\\_ok}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes VSM controller parameters and performance metrics for given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (SCR, zeta_target, omega_n_target_Hz)\n    test_cases_hz = [\n        (5.0, 0.7, 3.0),   # Case A\n        (0.8, 0.05, 1.0),  # Case B\n        (10.0, 0.9, 5.0),  # Case C\n        (3.0, 1.0, 2.0)    # Case D\n    ]\n\n    # Convert Hz to rad/s for omega_n_target\n    test_cases = [\n        (scr, zeta_t, 2 * np.pi * w_n_t_hz)\n        for scr, zeta_t, w_n_t_hz in test_cases_hz\n    ]\n\n    results = []\n    for case in test_cases:\n        scr, zeta_target, omega_n_target = case\n\n        # Step 1: Calculate synchronizing stiffness Ks\n        # Ks is given as approximately equal to SCR in per-unit.\n        k_s = float(scr)\n\n        # Step 2: Calculate tuned parameters M and D\n        # M = Ks / omega_n_target^2\n        # D = 2 * zeta_target * Ks / omega_n_target\n        m = k_s / (omega_n_target**2)\n        d = (2 * zeta_target * k_s) / omega_n_target\n\n        # Step 3: Calculate achieved damping ratio and natural frequency\n        # These should match the targets due to the derivation.\n        # zeta_achieved = D / (2 * sqrt(M * Ks))\n        # omega_n_achieved = sqrt(Ks / M)\n        omega_n_achieved = np.sqrt(k_s / m)\n        zeta_achieved = d / (2 * np.sqrt(m * k_s))\n\n        # Step 4: Determine stability\n        # Stability is guaranteed if M, D, Ks are all positive.\n        # Given the inputs, Ks > 0, omega_n_target > 0, zeta_target > 0,\n        # which ensures M > 0 and D > 0.\n        stable = (m > 0 and d > 0 and k_s > 0)\n\n        # Step 5: Calculate unit-step overshoot Mp\n        # Mp = exp(-zeta*pi / sqrt(1 - zeta^2)) for 0  zeta  1\n        # Mp = 0 for zeta >= 1\n        if 0  zeta_achieved  1:\n            m_p = np.exp(-zeta_achieved * np.pi / np.sqrt(1 - zeta_achieved**2))\n        else: # zeta >= 1 (or zeta = 0, which is not expected here)\n            m_p = 0.0\n\n        # Step 6: Check if overshoot is acceptable (Mp = 0.1)\n        overshoot_ok = (m_p = 0.1)\n        \n        # Assemble the list of results for the current case\n        case_result = [\n            m,\n            d,\n            zeta_achieved,\n            omega_n_achieved,\n            stable,\n            m_p,\n            overshoot_ok\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}