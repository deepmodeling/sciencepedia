{
    "hands_on_practices": [
        {
            "introduction": "了解学习型组件对输入扰动的敏感性是形式验证中的一个核心任务。Lipschitz 常数是衡量这种敏感性的一个基本工具，它为函数输出的最大变化率提供了一个严格的界限。在此练习 () 中，您将从第一性原理出发，为一个基于 ReLU 网络的控制器推导并计算其 Lipschitz 常数，并应用它来评估系统在存在状态估计误差时的鲁棒性。",
            "id": "4223377",
            "problem": "一个信息物理系统的数字孪生使用了一个实现为前馈修正线性单元 (ReLU) 网络的、基于学习的控制器。闭环安全性的形式化验证要求界定控制器对状态估计失配的敏感性。考虑由下式定义的控制器映射 $u=\\phi(x)$：\n$$\n\\phi(x) \\;=\\; W_3\\,\\sigma\\!\\big(W_2\\,\\sigma\\!\\big(W_1\\,x + b_1\\big) + b_2\\big) + b_3,\n$$\n其中 $\\sigma(\\cdot)$ 是逐元素的修正线性单元 (ReLU)，$\\sigma(z)=\\max\\{0,z\\}$，逐坐标应用。权重矩阵和偏置为\n$$\nW_1=\\begin{pmatrix}3 & 0\\\\ 0 & 2\\\\ 0 & 0\\end{pmatrix},\\quad b_1=\\begin{pmatrix}0\\\\0\\\\0\\end{pmatrix},\\quad\nW_2=\\begin{pmatrix}0 & 1 & 0\\\\ 0 & 0 & 2\\end{pmatrix},\\quad b_2=\\begin{pmatrix}0\\\\0\\end{pmatrix},\\quad\nW_3=\\begin{pmatrix}5 & 0\\end{pmatrix},\\quad b_3=0.\n$$\n从第一性原理出发，从 Lipschitz 连续性的定义（即，如果对所有 $x, y$ 都有 $\\|f(x)-f(y)\\|_2\\le L\\|x-y\\|_2$，则函数 $f$ 是 $L$-Lipschitz 的）、诱导欧几里得算子范数 $\\|W\\|_2=\\sup_{\\|v\\|_2=1}\\|Wv\\|_2$ 的定义，以及仿射映射和 ReLU 非线性的基本性质入手。不要引入任何未经证明的捷径。\n\n任务：\n- 推导 $\\phi$ 关于 $\\ell_2$ 范数的全局 Lipschitz 常数 $L$ 的一个显式的、可计算的上界，用上述权重矩阵表示，并计算其确切值。\n- 假设数字孪生的状态估计 $\\hat{x}$ 满足估计误差的先验界 $\\|\\hat{x}-x\\|_2\\le \\varepsilon$，其中 $\\varepsilon=0.08$。使用你对 $L$ 的界来获得最小的显式数值半径 $r_u$，使得对于所有满足误差界的允许 $(x,\\hat{x})$，控制偏差满足 $|\\,\\phi(\\hat{x})-\\phi(x)\\,|\\le r_u$。将你的 $r_u$ 数值答案四舍五入到四位有效数字。不需要物理单位。\n- 用一两句话简要解释你计算出的 $L$ 值如何影响用于闭环系统形式化验证的鲁棒性声明。\n\n提供 $r_u$ 的值作为你的最终数值答案，四舍五入到四位有效数字。",
            "solution": "问题陈述经评估有效。它在神经网络形式化验证方法方面有科学依据，问题设定良好，提供了所有必要信息，并以客观的数学语言表达。它不包含矛盾、歧义或事实上的不健全之处。因此，我们可以着手解决。\n\n问题要求计算控制器映射 $\\phi(x)$ 的全局 Lipschitz 常数 $L$ 的一个上界，随后计算控制偏差的界 $r_u$，并解释 $L$ 在形式化验证中的作用。该控制器是一个前馈神经网络，是函数的复合。我们如下表示网络的各层：\n第一个仿射变换为 $f_1(x) = W_1 x + b_1$。\n第一个 ReLU 激活为 $g_1(z_1) = \\sigma(z_1)$。\n第二个仿射变换为 $f_2(z_2) = W_2 z_2 + b_2$。\n第二个 ReLU 激活为 $g_2(z_3) = \\sigma(z_3)$。\n最后的仿射变换为 $f_3(z_4) = W_3 z_4 + b_3$。\n\n完整的网络映射是这些函数的复合：$\\phi(x) = f_3(g_2(f_2(g_1(f_1(x)))))$。\n\nLipschitz 连续函数的一个基本性质是，一个 $L_f$-Lipschitz 函数 $f$ 和一个 $L_g$-Lipschitz 函数 $g$ 的复合 $g \\circ f$ 是一个 $(L_g L_f)$-Lipschitz 函数。这是因为 $\\|\\left(g \\circ f\\right)(x) - \\left(g \\circ f\\right)(y)\\|_2 = \\|g(f(x)) - g(f(y))\\|_2 \\le L_g \\|f(x) - f(y)\\|_2 \\le L_g (L_f \\|x-y\\|_2) = (L_g L_f) \\|x-y\\|_2$。\n通过递归应用此性质，$\\phi(x)$ 的全局 Lipschitz 常数 $L$ 的一个上界是其各构成层 Lipschitz 常数的乘积：\n$$\nL \\le L_{f_3} \\cdot L_{g_2} \\cdot L_{f_2} \\cdot L_{g_1} \\cdot L_{f_1}\n$$\n\n我们现在必须从第一性原理确定每一层的 Lipschitz 常数。\n\n首先，考虑一个通用的仿射层 $f(x) = Wx + b$。\n其 Lipschitz 常数通过分析 $\\|f(x) - f(y)\\|_2$ 来确定：\n$$\n\\|f(x) - f(y)\\|_2 = \\|(Wx+b) - (Wy+b)\\|_2 = \\|W(x-y)\\|_2\n$$\n根据诱导欧几里得算子范数的定义，对于任何向量 $v$，有 $\\|Wv\\|_2 \\le \\|W\\|_2 \\|v\\|_2$。令 $v = x-y$，我们得到：\n$$\n\\|W(x-y)\\|_2 \\le \\|W\\|_2 \\|x-y\\|_2\n$$\n因此，仿射映射 $f(x) = Wx + b$ 是 Lipschitz 连续的，其常数等于权重矩阵的算子范数，即 $L_f = \\|W\\|_2$。对于我们的网络，仿射层的 Lipschitz 常数分别为 $L_{f_1} = \\|W_1\\|_2$，$L_{f_2} = \\|W_2\\|_2$ 和 $L_{f_3} = \\|W_3\\|_2$。\n\n接下来，考虑逐元素的 ReLU 激活函数 $g(z) = \\sigma(z) = \\max\\{0, z\\}$。设 $z_a$ 和 $z_b$ 是两个向量。\n我们分析欧几里得距离的平方 $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2$：\n$$\n\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2 = \\sum_i \\left( \\max\\{0, (z_a)_i\\} - \\max\\{0, (z_b)_i\\} \\right)^2\n$$\n对于任何一对标量 $a$ 和 $b$，函数 $h(t)=\\max\\{0,t\\}$ 是 $1$-Lipschitz 的，意味着 $|\\max\\{0,a\\}-\\max\\{0,b\\}| \\le |a-b|$。这可以通过分情况证明：\n1. 如果 $a>0$ 且 $b>0$，则 $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |a-b|$。\n2. 如果 $a\\le0$ 且 $b\\le0$，则 $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |0-0| = 0 \\le |a-b|$。\n3. 如果 $a>0$ 且 $b\\le0$，则 $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |a-0| = a$。因为 $a>b$，所以 $|a-b| = a-b \\ge a$。因此 $a \\le |a-b|$。\n第四种情况（$a\\le0, b>0$）与第三种情况对称。在所有情况下，都有 $|\\max\\{0,a\\}-\\max\\{0,b\\}|^2 \\le |a-b|^2$。\n对所有分量求和：\n$$\n\\sum_i \\left( \\max\\{0, (z_a)_i\\} - \\max\\{0, (z_b)_i\\} \\right)^2 \\le \\sum_i \\left( (z_a)_i - (z_b)_i \\right)^2\n$$\n这等价于 $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2 \\le \\|z_a-z_b\\|_2^2$，这意味着 $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2 \\le \\|z_a-z_b\\|_2$。\n因此，逐元素的 ReLU 激活函数关于 $\\ell_2$ 范数是 $1$-Lipschitz 的。所以，$L_{g_1} = 1$ 且 $L_{g_2} = 1$。\n\n结合这些结果，得到 $\\phi$ 的 Lipschitz 常数的显式上界：\n$$\nL \\le \\|W_3\\|_2 \\cdot 1 \\cdot \\|W_2\\|_2 \\cdot 1 \\cdot \\|W_1\\|_2 = \\|W_1\\|_2 \\|W_2\\|_2 \\|W_3\\|_2\n$$\n\n我们现在计算这个上界的确切值。矩阵 $W$ 的诱导 $\\ell_2$-范数，记为 $\\|W\\|_2$，是其最大奇异值 $\\sigma_{\\max}(W)$。奇异值是矩阵 $W^T W$ 的特征值的平方根。\n\n对于 $W_1 = \\begin{pmatrix}3 & 0\\\\ 0 & 2\\\\ 0 & 0\\end{pmatrix}$：\n$W_1^T W_1 = \\begin{pmatrix}3 & 0 & 0\\\\ 0 & 2 & 0\\end{pmatrix} \\begin{pmatrix}3 & 0\\\\ 0 & 2\\\\ 0 & 0\\end{pmatrix} = \\begin{pmatrix}9 & 0\\\\ 0 & 4\\end{pmatrix}$。\n特征值为 $\\lambda_1 = 9$ 和 $\\lambda_2 = 4$。\n奇异值为 $\\sqrt{9}=3$ 和 $\\sqrt{4}=2$。最大的是 $3$。\n因此，$\\|W_1\\|_2 = 3$。\n\n对于 $W_2 = \\begin{pmatrix}0 & 1 & 0\\\\ 0 & 0 & 2\\end{pmatrix}$：\n$W_2^T W_2 = \\begin{pmatrix}0 & 0\\\\ 1 & 0\\\\ 0 & 2\\end{pmatrix} \\begin{pmatrix}0 & 1 & 0\\\\ 0 & 0 & 2\\end{pmatrix} = \\begin{pmatrix}0 & 0 & 0\\\\ 0 & 1 & 0\\\\ 0 & 0 & 4\\end{pmatrix}$。\n特征值为 $\\lambda_1 = 4$，$\\lambda_2 = 1$ 和 $\\lambda_3 = 0$。\n非零奇异值为 $\\sqrt{4}=2$ 和 $\\sqrt{1}=1$。最大的是 $2$。\n因此，$\\|W_2\\|_2 = 2$。\n\n对于 $W_3 = \\begin{pmatrix}5 & 0\\end{pmatrix}$：\n$W_3^T W_3 = \\begin{pmatrix}5\\\\ 0\\end{pmatrix} \\begin{pmatrix}5 & 0\\end{pmatrix} = \\begin{pmatrix}25 & 0\\\\ 0 & 0\\end{pmatrix}$。\n特征值为 $\\lambda_1 = 25$ 和 $\\lambda_2 = 0$。\n最大奇异值为 $\\sqrt{25}=5$。\n因此，$\\|W_3\\|_2 = 5$。\n\n$\\phi$ 的全局 Lipschitz 常数的计算上界，我们记为 $L_{bound}$，是：\n$$\nL_{bound} = \\|W_1\\|_2 \\|W_2\\|_2 \\|W_3\\|_2 = 3 \\cdot 2 \\cdot 5 = 30\n$$\n\n对于第二个任务，我们使用这个界来找到半径 $r_u$。根据 Lipschitz 连续性的定义，并注意到 $\\phi$ 的输出是标量（因此其 $\\ell_2$ 范数是其绝对值）：\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le L \\|\\hat{x} - x\\|_2\n$$\n使用我们的上界 $L_{bound} \\ge L$：\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le L_{bound} \\|\\hat{x} - x\\|_2\n$$\n给定 $\\|\\hat{x}-x\\|_2 \\le \\varepsilon$，其中 $\\varepsilon = 0.08$。代入数值：\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le 30 \\cdot 0.08 = 2.4\n$$\n基于我们推导的界，保证此不等式成立的最小显式数值半径 $r_u$ 是 $r_u = 2.4$。四舍五入到四位有效数字得到 $r_u = 2.400$。\n\n最后，我们解释 $L$ 在鲁棒性中的作用。Lipschitz 常数 $L$ 作为控制器敏感性的一个经认证的度量，提供了一个从输入扰动（如状态估计误差）到输出偏差的最坏情况放大因子。一个经过验证的较小的 $L$ 值意味着更高的鲁棒性，这使得证明闭环系统在存在不确定性的情况下仍保持在其安全运行范围内变得更容易，从而简化了形式化验证。",
            "answer": "$$\n\\boxed{2.400}\n$$"
        },
        {
            "introduction": "除了为系统行为提供边界之外，形式验证通常需要回答关于是否存在导致失效的特定输入的“是/否”问题。可满足性模理论 (SMT) 为此提供了一个强大的形式化框架。本练习 () 将指导您如何将一个针对线性分类器的安全验证问题，编码为一个可在量词无关线性实数算术 (QF_LRA) 理论中求解的 SMT 查询，并最终通过线性规划的可行性问题来判定其可满足性。",
            "id": "4223431",
            "problem": "信息物理系统中的一个支持学习的组件是一个多类线性分类器，它将输入向量 $\\mathbf{x} \\in \\mathbb{R}^n$ 映射到得分 $\\mathbf{s} = \\mathbf{W}\\mathbf{x} + \\mathbf{b}$，其中 $\\mathbf{W} \\in \\mathbb{R}^{m \\times n}$ 且 $\\mathbf{b} \\in \\mathbb{R}^m$。预测的类别是在标准 $\\operatorname{argmax}$ 决策规则下获得最大得分的索引 $c^\\star \\in \\{0,1,\\dots,m-1\\}$。给定一个真实类别标签 $y \\in \\{0,1,\\dots,m-1\\}$ 和一个目标类别 $c \\in \\{0,1,\\dots,m-1\\}$，如果 $y \\neq c$ 且预测满足 $c^\\star = c$，我们称该分类器错误分类到类别 $c$。数字孪生施加了形式为 $A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$ 的线性输入约束，以及逐元素的界限 $L \\le \\mathbf{x} \\le U$。为避免平局并提供鲁棒性，引入一个非负裕度 $\\gamma \\ge 0$，并要求类别 $c$ 的得分比每个竞争对手的得分至少高出 $\\gamma$：对于所有 $k \\in \\{0,1,\\dots,m-1\\}$ 且 $k \\neq c$，\n$$\\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma,$$\n其中 $\\mathbf{w}_j^\\top$ 表示 $\\mathbf{W}$ 的第 $j$ 行。\n\n任务：在无量词线性实数算术（QF_LRA）中，构建一个可满足性模理论（SMT）查询，以检查是否存在一个满足数字孪生约束并强制分类器以裕度 $\\gamma$ 预测为类别 $c$ 的输入 $\\mathbf{x}$，给定 $y \\neq c$。然后，实现一个程序，通过将约束归约为线性规划可行性问题，来判断所提供测试套件的此查询的可满足性。\n\n推导的基础：仅使用线性分类器的定义、$\\operatorname{argmax}$ 决策规则语义、实数算术上的一阶逻辑，以及通过线性规划可以判断实数上线性不等式合取式的可行性这一标准特征。\n\n要编码的精确SMT属性：判断以下表达式的真值\n$$\\exists \\mathbf{x} \\in \\mathbb{R}^n \\;\\; \\Big( A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}} \\;\\wedge\\; L \\le \\mathbf{x} \\le U \\;\\wedge\\; \\bigwedge_{k \\in \\{0,\\dots,m-1\\}\\setminus\\{c\\}} \\big( \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma \\big) \\Big),$$\n在附加条件 $y \\neq c$ 下。当且仅当存在一个具有指定裕度的错误分类输入时，该查询是可满足的。\n\n测试套件规范。对于每个测试用例，给定 $(n,m,\\mathbf{W},\\mathbf{b},A,\\mathbf{b}_{\\text{ineq}},L,U,y,c,\\gamma)$:\n\n- 测试用例 1（由于正裕度与不利几何形状而不可满足）：\n  - $n = 2$, $m = 3$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\\\ -1 & -1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1 & 1 \\\\ -1 & 0 \\\\ 0 & -1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。\n  - $y = 0$, $c = 2$, $\\gamma = 0.1$。\n\n- 测试用例 2（在严格为负的输入下可满足）：\n  - $n = 2$, $m = 3$。\n  - $\\mathbf{W} = \\begin{bmatrix} -1 & -1 \\\\ 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1 & 1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} -0.5 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} -1 \\\\ -1 \\end{bmatrix}$, $U = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n  - $y = 1$, $c = 0$, $\\gamma = 0.2$。\n\n- 测试用例 3（在3维空间中可满足，偏置有利于目标类别）：\n  - $n = 3$, $m = 3$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1 & 1 & 0 \\\\ 0 & 1 & 1 \\\\ -1 & 0 & 1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0.5 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1 & 1 & 1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1.5 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n  - $y = 0$, $c = 2$, $\\gamma = 0.0$。\n\n- 测试用例 4（根据定义不可满足，因为 $y = c$）：\n  - $n = 1$, $m = 2$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n  - $A$ 是空的 $0 \\times 1$ 矩阵，$\\mathbf{b}_{\\text{ineq}}$ 是空的。\n  - $L = \\begin{bmatrix} 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\end{bmatrix}$。\n  - $y = 1$, $c = 1$, $\\gamma = 0.0$。\n\n- 测试用例 5（在2维空间的裕度边界上可满足）：\n  - $n = 2$, $m = 2$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1 & 1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1.5 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。\n  - $y = 1$, $c = 0$, $\\gamma = 0.5$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$\\text{[result1,result2,result3]}$），其中每个条目都是一个布尔值，表示相应测试用例的 SMT 查询的可满足性。",
            "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤1：提取给定信息\n- 输入向量：$\\mathbf{x} \\in \\mathbb{R}^n$。\n- 多类线性分类器得分：$\\mathbf{s} = \\mathbf{W}\\mathbf{x} + \\mathbf{b}$，其中 $\\mathbf{W} \\in \\mathbb{R}^{m \\times n}$ 且 $\\mathbf{b} \\in \\mathbb{R}^m$。\n- 预测类别（决策规则）：$c^\\star = \\operatorname{argmax}_{j \\in \\{0,1,\\dots,m-1\\}} s_j$。\n- 真实类别：$y \\in \\{0,1,\\dots,m-1\\}$。\n- 错误分类的目标类别：$c \\in \\{0,1,\\dots,m-1\\}$。\n- 错误分类条件：$y \\neq c$ 且 $c^\\star = c$。\n- 数字孪生输入约束：$A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$。\n- 逐元素输入界限：$L \\le \\mathbf{x} \\le U$。\n- 鲁棒性裕度：$\\gamma \\ge 0$。\n- 鲁棒错误分类条件：对于所有 $k \\in \\{0,1,\\dots,m-1\\}$ 且 $k \\neq c$，$\\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma$，其中 $\\mathbf{w}_j^\\top$ 是 $\\mathbf{W}$ 的第 $j$ 行。\n- 待判定的SMT属性：$\\exists \\mathbf{x} \\in \\mathbb{R}^n \\;\\; \\Big( A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}} \\;\\wedge\\; L \\le \\mathbf{x} \\le U \\;\\wedge\\; \\bigwedge_{k \\in \\{0,\\dots,m-1\\}\\setminus\\{c\\}} \\big( \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma \\big) \\Big)$，在附加条件 $y \\neq c$ 下。\n- 测试套件：提供了五个测试用例，每个都包含 $(n,m,\\mathbf{W},\\mathbf{b},A,\\mathbf{b}_{\\text{ineq}},L,U,y,c,\\gamma)$ 的具体值。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准评估问题。\n- **科学基础**：该问题在机器学习、控制理论和形式化方法的交叉领域有坚实的基础。线性分类器、线性约束以及用于无量词线性实数算术（QF_LRA）的可满足性模理论（SMT）都是标准的、完善的概念。将 QF_LRA 可满足性问题归约为线性规划是计算逻辑和优化的基石。\n- **良构性**：任务是确定一组线性不等式的可满足性。这是一个经典的可行性问题，它有确定的答案：要么存在一个可行点（可满足），要么不存在（不可满足）。因此，该问题是良构的。\n- **客观性**：所有定义和任务都以数学精度指定，没有留下歧义或主观解释的空间。\n- **缺陷分析**：\n  1.  **科学/事实不健全**：无。数学和逻辑框架是健全的。\n  2.  **不可形式化/不相关**：无。问题被明确地形式化，并与所述的信息物理系统中验证支持学习的组件的领域直接相关。\n  3.  **不完整/矛盾**：问题是自洽的。每个测试用例都包含所有必要的数据。条件 $y \\neq c$ 是错误分类的定义性先决条件。测试用例 4 中 $y = c$ 的情况被正确处理为根据此定义不可满足，这是问题设置的逻辑结果，而不是其中的矛盾。\n  4.  **不现实/不可行**：参数是数值，不涉及物理单位，排除了量纲不一致的可能性。该设置是一个标准的抽象数学模型。\n  5.  **不当/结构不良**：无。决策问题定义清晰。\n  6.  **伪深刻/琐碎**：虽然单个测试用例可能易于分析，但整个问题需要系统地、正确地实现从 SMT 到 LP 的归约，这并非易事。\n  7.  **超出科学可验证性**：无。可满足性可以通过标准算法程序（线性规划）进行验证。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n问题的核心是确定一个在无量词线性实数算术（QF_LRA）理论中的存在量化公式的可满足性。该公式是关于实值向量 $\\mathbf{x} \\in \\mathbb{R}^n$ 的一组线性不等式的合取。这样一个 $\\mathbf{x}$ 的存在性可以通过将问题表述为线性规划（LP）可行性问题来判定。\n\n当且仅当存在一个 $\\mathbf{x}$ 同时满足三组约束时，SMT查询是可满足的：\n$1.$ 数字孪生的操作约束：$A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$。\n$2.$ 输入的逐元素界限：$L \\le \\mathbf{x} \\le U$。\n$3.$ 鲁棒错误分类条件：对于每个类别索引 $k$ 且 $k \\neq c$，目标类别 $c$ 的得分必须大于或等于类别 $k$ 的得分加上一个裕度 $\\gamma$。\n\n让我们将这些约束形式化为 LP 求解器所需的标准形式。待求的变量是 $\\mathbf{x}$。\n\n首先，附加条件 $y \\neq c$ 是错误分类的定义。如果 $y = c$，那么寻找一个*错误分类*输入的假设就是错误的。因此，不存在这样的输入，根据定义，查询是不可满足的。这构成了一个初步检查。\n\n假设 $y \\neq c$，我们组装线性不等式系统。\n数字孪生约束 $A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$ 已经是标准形式。\n\n逐元素界限 $L \\le \\mathbf{x} \\le U$ 等价于两个矩阵不等式 $\\mathbf{I}\\mathbf{x} \\le U$ 和 $-\\mathbf{I}\\mathbf{x} \\le -L$，其中 $\\mathbf{I}$ 是 $n \\times n$ 单位矩阵。然而，大多数 LP 求解器，包括 `scipy.optimize.linprog`，都直接接受箱式约束，这样更高效。我们将以 `(lower, upper)` 对的形式为 $\\mathbf{x}$ 的每个分量提供这些界限。\n\n鲁棒错误分类条件是为所有 $k \\in \\{0, 1, \\dots, m-1\\}$ 且 $k \\neq c$ 给出的：\n$$ \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma $$\n这些必须被重新排列成标准形式 $(\\text{matrix}) \\cdot \\mathbf{x} \\le (\\text{vector})$。通过将所有含 $\\mathbf{x}$ 的项移到一边，常数项移到另一边，我们得到：\n$$ (\\mathbf{w}_k - \\mathbf{w}_c)^\\top \\mathbf{x} \\le b_c - b_k - \\gamma $$\n对于每个竞争类别 $k$，都有一个这样的不等式，总共有 $m-1$ 个。\n\n结合所有这些不等式，我们构建一个单一的系统，形式为 $C_{\\text{total}}\\mathbf{x} \\le \\mathbf{d}_{\\text{total}}$，其中 $C_{\\text{total}}$ 是通过垂直堆叠矩阵 $A$ 和 $m-1$ 个行向量 $(\\mathbf{w}_k - \\mathbf{w}_c)^\\top$ 形成的，而 $\\mathbf{d}_{\\text{total}}$ 是通过堆叠向量 $\\mathbf{b}_{\\text{ineq}}$ 和 $m-1$ 个标量 $b_c - b_k - \\gamma$ 形成的。\n\n现在问题被归约为寻找是否存在一个 $\\mathbf{x}$ 满足 $C_{\\text{total}}\\mathbf{x} \\le \\mathbf{d}_{\\text{total}}$ 和 $L \\le \\mathbf{x} \\le U$。这是一个规范的 LP 可行性问题。我们可以通过提供一个空的目标函数（例如，最小化 $0^\\top\\mathbf{x}$）给 LP 求解器来解决它。如果求解器找到了一个可行解，那么原始的 SMT 查询是可满足的（`True`）。如果求解器确定可行集为空（即问题不可行），则查询是不可满足的（`False`）。\n\n实现将遵循此逻辑。对于每个测试用例，我们首先检查 $y=c$ 条件。如果不满足，我们构造不等式约束的矩阵和界限向量。然后，我们使用 `scipy.optimize.linprog` 来解决可行性问题。返回结果对象的 `success` 属性直接指示是否找到了可行解，从而回答了可满足性问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_satisfiability(n, m, W, b, A, b_ineq, L, U, y, c, gamma):\n    \"\"\"\n    Checks the satisfiability of the SMT query by reducing it to an LP feasibility problem.\n    \"\"\"\n    # By definition of misclassification, the ground truth y must not be the target class c.\n    # If y == c, the condition is not met, thus no such misclassifying input exists.\n    if y == c:\n        return False\n\n    # The goal is to find if a feasible x exists. This is an LP feasibility problem.\n    # We can set a null objective function, e.g., min 0^T * x.\n    # The vector of coefficients for the objective function.\n    c_obj = np.zeros(n)\n\n    # Aggregate all inequality constraints of the form A_ub * x = b_ub\n    A_ub_list = []\n    b_ub_list = []\n\n    # 1. Digital twin constraints: A*x = b_ineq\n    # Handle the case where A might be an empty matrix.\n    if A.shape[0] > 0:\n        A_ub_list.append(A)\n        b_ub_list.append(b_ineq.flatten())\n\n    # 2. Robust misclassification constraints:\n    # For all k != c, w_c^T*x + b_c >= w_k^T*x + b_k + gamma\n    # Rearranging gives: (w_k - w_c)^T*x = b_c - b_k - gamma\n    w_c_row = W[c, :]\n    b_c_val = b[c]\n    for k in range(m):\n        if k == c:\n            continue\n        w_k_row = W[k, :]\n        b_k_val = b[k]\n\n        # Form the inequality (w_k - w_c)^T * x = b_c - b_k - gamma\n        A_row = w_k_row - w_c_row\n        b_val = b_c_val - b_k_val - gamma\n\n        A_ub_list.append(A_row.reshape(1, -1))\n        b_ub_list.append(np.array([b_val]))\n\n    A_ub = None\n    b_ub = None\n    if A_ub_list:\n        A_ub = np.vstack(A_ub_list)\n        b_ub = np.concatenate(b_ub_list)\n\n    # 3. Element-wise bounds: L = x = U\n    # This is handled by the 'bounds' parameter of linprog.\n    # It expects a sequence of (min, max) pairs for each variable.\n    bounds = list(zip(L.flatten(), U.flatten()))\n\n    # Solve the linear programming feasibility problem.\n    # method='highs' is used as it is the recommended solver.\n    # If the problem is feasible, linprog returns success=True.\n    # If it is infeasible, it returns success=False.\n    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    # The satisfiability of the SMT query is equivalent to the feasibility of the LP.\n    return res.success\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (unsatisfiable)\n        {\n            \"n\": 2, \"m\": 3,\n            \"W\": np.array([[1., 0.], [0., 1.], [-1., -1.]]),\n            \"b\": np.array([0., 0., 0.]),\n            \"A\": np.array([[1., 1.], [-1., 0.], [0., -1.]]),\n            \"b_ineq\": np.array([1., 0., 0.]),\n            \"L\": np.array([0., 0.]), \"U\": np.array([1., 1.]),\n            \"y\": 0, \"c\": 2, \"gamma\": 0.1\n        },\n        # Test case 2 (satisfiable)\n        {\n            \"n\": 2, \"m\": 3,\n            \"W\": np.array([[-1., -1.], [1., 0.], [0., 1.]]),\n            \"b\": np.array([0., 0., 0.]),\n            \"A\": np.array([[1., 1.]]), \"b_ineq\": np.array([-0.5]),\n            \"L\": np.array([-1., -1.]), \"U\": np.array([0., 0.]),\n            \"y\": 1, \"c\": 0, \"gamma\": 0.2\n        },\n        # Test case 3 (satisfiable)\n        {\n            \"n\": 3, \"m\": 3,\n            \"W\": np.array([[1., 1., 0.], [0., 1., 1.], [-1., 0., 1.]]),\n            \"b\": np.array([0., 0., 0.5]),\n            \"A\": np.array([[1., 1., 1.]]), \"b_ineq\": np.array([1.5]),\n            \"L\": np.array([0., 0., 0.]), \"U\": np.array([1., 1., 1.]),\n            \"y\": 0, \"c\": 2, \"gamma\": 0.0\n        },\n        # Test case 4 (unsatisfiable by y=c)\n        {\n            \"n\": 1, \"m\": 2,\n            \"W\": np.array([[1.], [2.]]), \"b\": np.array([0., 0.]),\n            \"A\": np.empty((0, 1)), \"b_ineq\": np.empty(0),\n            \"L\": np.array([0.]), \"U\": np.array([1.]),\n            \"y\": 1, \"c\": 1, \"gamma\": 0.0\n        },\n        # Test case 5 (satisfiable)\n        {\n            \"n\": 2, \"m\": 2,\n            \"W\": np.array([[1., 0.], [0., 1.]]), \"b\": np.array([0., 0.]),\n            \"A\": np.array([[1., 1.]]), \"b_ineq\": np.array([1.5]),\n            \"L\": np.array([0., 0.]), \"U\": np.array([1., 1.]),\n            \"y\": 1, \"c\": 0, \"gamma\": 0.5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        is_sat = check_satisfiability(\n            case[\"n\"], case[\"m\"], case[\"W\"], case[\"b\"], case[\"A\"],\n            case[\"b_ineq\"], case[\"L\"], case[\"U\"], case[\"y\"], case[\"c\"], case[\"gamma\"]\n        )\n        results.append(is_sat)\n\n    # Final print statement in the exact required format.\n    # Outputting booleans as lowercase strings: 'true'/'false'.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "信息物理系统中的许多安全规约本质上是时间相关的，例如要求某个信号在一段时间内始终保持在安全阈值以下。信号时序逻辑 (STL) 是描述和验证这类动态行为的精确语言。本练习 () 旨在通过计算 STL 公式对于一个采样信号的鲁棒性值，让您掌握如何量化系统行为满足或违反时序规约的程度，这是运行时监控和验证的关键一步。",
            "id": "4223379",
            "problem": "一个数字孪生用于监控一个归一化跟踪误差信号 $x(t)$，该信号由嵌入在信息物理系统中的支持学习的状态估计器生成。验证任务通过信号时序逻辑 (STL) 公式 $\\varphi = \\Box_{[0,5]}(x \\le 1)$ 进行规约。通俗地讲，该公式要求归一化误差在时间区间 $[0,5]$ 内的所有时刻都保持在阈值 $1$ 或以下。该监视器处理一个采样信号 $x(t_k)$，其采样时刻 $t_k \\in [0,5]$ 是事件触发的，并使用 STL 的标准定量语义来评估鲁棒性。\n\n在时间区间 $[0,5]$ 内记录的样本如下：\n$t_0 = 0$， $x(t_0) = 0.72$；\n$t_1 = 0.3$， $x(t_1) = 0.88$；\n$t_2 = 0.9$， $x(t_2) = 1.05$；\n$t_3 = 1.4$， $x(t_3) = 0.97$；\n$t_4 = 2.1$， $x(t_4) = 0.91$；\n$t_5 = 2.7$， $x(t_5) = 1.02$；\n$t_6 = 3.2$， $x(t_6) = 0.95$；\n$t_7 = 3.8$， $x(t_7) = 0.89$；\n$t_8 = 4.4$， $x(t_8) = 1.10$；\n$t_9 = 5.0$， $x(t_9) = 0.93$。\n\n请使用适用于采样信号的信号时序逻辑鲁棒性语义和给定数据，通过评估所有样本 $t_k \\in [0,5]$ 的最小裕度 $1 - x(t_k)$，来计算 $\\varphi$ 在区间 $[0,5]$ 上的鲁棒性值。请将鲁棒性值表示为一个无量纲标量，并将最终答案四舍五入到三位有效数字。",
            "solution": "该问题要求基于一个信号的有限采样数据集，计算一个信号时序逻辑 (STL) 公式的鲁棒性值。对问题陈述的验证证实了其科学依据充分、提法得当，并包含了得出唯一解所需的所有必要信息。\n\nSTL 公式为 $\\varphi = \\Box_{[0,5]}(x \\le 1)$。该公式由一个作用于时间区间 $[0,5]$ 的时序算子“总是”($\\Box$)和一个原子谓词 $\\mu = (x \\le 1)$ 组成。\n\nSTL 的定量语义定义了一个鲁棒性值，记为 $\\rho(\\varphi, x)$，它衡量信号 $x(t)$ 满足公式 $\\varphi$ 的强度。正值表示满足，负值表示违反，零值表示在边界上满足。\n\n形式为 $f(x) \\ge c$ 的原子谓词的鲁棒性定义为表达式 $f(x) - c$ 的值。谓词 $\\mu = (x \\le 1)$ 可以重写为 $1 - x \\ge 0$。因此，其在特定时间 $t$ 的鲁棒性由以下公式给出：\n$$\n\\rho(\\mu, x, t) = 1 - x(t)\n$$\n该值表示信号 $x(t)$ 满足条件 $x \\le 1$ 的裕度。如果 $x(t)  1$，裕度为正；如果 $x(t)  1$，裕度为负。\n\n“总是”算子 $\\Box_{I}$ 断言子公式在区间 $I$ 内的所有时间点都成立。其鲁棒性定义为子公式在该区间上鲁棒性的下确界（对于有限点集则为最小值）。对于公式 $\\varphi = \\Box_{[0,5]}\\mu$，其连续时间鲁棒性为：\n$$\n\\rho(\\varphi, x) = \\inf_{t \\in [0,5]} \\rho(\\mu, x, t) = \\inf_{t \\in [0,5]} (1 - x(t))\n$$\n问题指明，监视器处理的是一个离散样本集 $\\{ (t_k, x(t_k)) \\}$，其中所有 $t_k \\in [0,5]$。根据问题中评估所有样本最小裕度的指令，鲁棒性计算是针对这个离散点集进行的。下确界算子变为最小算子：\n$$\n\\rho(\\varphi, x) = \\min_{k} (1 - x(t_k))\n$$\n其中 $k$ 遍历所有给定的样本。\n\n该表达式可以简化，注意到当 $x(t_k)$ 达到最大值时，$1 - x(t_k)$ 取得最小值。\n$$\n\\min_{k} (1 - x(t_k)) = 1 - \\max_{k} x(t_k)\n$$\n我们得到以下10个信号 $x(t)$ 的样本：\n$x(t_0) = 0.72$\n$x(t_1) = 0.88$\n$x(t_2) = 1.05$\n$x(t_3) = 0.97$\n$x(t_4) = 0.91$\n$x(t_5) = 1.02$\n$x(t_6) = 0.95$\n$x(t_7) = 0.89$\n$x(t_8) = 1.10$\n$x(t_9) = 0.93$\n\n我们必须找到这组信号值中的最大值。通过观察，最大值为：\n$$\n\\max_{k} x(t_k) = x(t_8) = 1.10\n$$\n现在，我们可以使用推导出的公式计算鲁棒性值：\n$$\n\\rho(\\varphi, x) = 1 - \\max_{k} x(t_k) = 1 - 1.10 = -0.10\n$$\n负号表示规约 $\\varphi$ 被违反。值 $-0.10$ 量化了这种违反的程度；在时间 $t_8 = 4.4$ 时，信号 $x(t_8)$ 超过了阈值 $1$ 的量为 $0.10$。\n\n问题要求将答案四舍五入到三位有效数字。计算出的值为 $-0.10$。第一个有效数字是数字 $1$。随后的零也是有效数字。为了用三位有效数字表示，我们将其写为 $-0.100$。",
            "answer": "$$\n\\boxed{-0.100}\n$$"
        }
    ]
}