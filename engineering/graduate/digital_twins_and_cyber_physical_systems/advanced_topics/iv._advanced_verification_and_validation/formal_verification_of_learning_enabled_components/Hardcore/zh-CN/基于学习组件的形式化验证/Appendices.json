{
    "hands_on_practices": [
        {
            "introduction": "在验证一个包含学习组件的复杂系统之前，理解其核心部件的内在属性至关重要。利普希茨常数（Lipschitz constant）是衡量神经网络对输入扰动敏感性的关键指标。本练习将引导你从第一性原理出发，计算一个ReLU网络的利普希茨常数上界，这是进行鲁棒性分析和后续形式化验证的基础技能 。",
            "id": "4223377",
            "problem": "一个信息物理系统的数字孪生使用一个实现为前馈修正线性单元 (ReLU) 网络的学习控制器。闭环安全的形式验证要求对控制器对状态估计失配的敏感度进行限定。考虑由下式定义的控制器映射 $u=\\phi(x)$\n$$\n\\phi(x) \\;=\\; W_3\\,\\sigma\\!\\big(W_2\\,\\sigma\\!\\big(W_1\\,x + b_1\\big) + b_2\\big) + b_3,\n$$\n其中 $\\sigma(\\cdot)$ 是逐元素的修正线性单元 (ReLU)，$\\sigma(z)=\\max\\{0,z\\}$ 按坐标逐个应用。权重矩阵和偏置为\n$$\nW_1=\\begin{pmatrix}3  0\\\\ 0  2\\\\ 0  0\\end{pmatrix},\\quad b_1=\\begin{pmatrix}0\\\\ 0\\\\ 0\\end{pmatrix},\\quad\nW_2=\\begin{pmatrix}0  1  0\\\\ 0  0  2\\end{pmatrix},\\quad b_2=\\begin{pmatrix}0\\\\ 0\\end{pmatrix},\\quad\nW_3=\\begin{pmatrix}5  0\\end{pmatrix},\\quad b_3=0.\n$$\n从第一性原理出发，从利普希茨连续性的定义（即，如果对于所有 $x,y$ 都有 $\\|f(x)-f(y)\\|_2\\le L\\|x-y\\|_2$，则函数 $f$ 是 $L$-利普希茨的）、诱导欧几里得算子范数的定义 $\\|W\\|_2=\\sup_{\\|v\\|_2=1}\\|Wv\\|_2$，以及仿射映射和 ReLU 非线性的基本性质开始。不要引入任何未经证明的捷径。\n\n任务：\n- 推导 $\\phi$ 关于 $\\ell_2$ 范数的全局利普希茨常数 $L$ 的一个显式、可计算的上界，用上述权重矩阵表示，并计算其精确值。\n- 假设数字孪生的状态估计 $\\hat{x}$ 满足关于估计误差的先验界 $\\|\\hat{x}-x\\|_2\\le \\varepsilon$，其中 $\\varepsilon=0.08$。使用你对 $L$ 的界来获得最小的显式数值半径 $r_u$，使得控制偏差对于所有服从该误差界的可容许 $(x,\\hat{x})$ 均满足 $|\\,\\phi(\\hat{x})-\\phi(x)\\,|\\le r_u$。将你的数值答案 $r_u$ 四舍五入到四位有效数字。不需要物理单位。\n- 用一两句话简要解释你计算出的 $L$ 值如何影响闭环系统形式验证中使用的鲁棒性声明。\n\n提供 $r_u$ 的值作为你的最终数值答案，四舍五入到四位有效数字。",
            "solution": "问题陈述经评估有效。它在科学上基于神经网络的形式验证方法，问题提法恰当，提供了所有必要信息，并以客观的数学语言表达。它不包含矛盾、歧义或事实上的不健全之处。因此，我们可以着手求解。\n\n该问题要求求解控制器映射 $\\phi(x)$ 的全局利普希茨常数 $L$ 的一个上界，随后计算控制偏差 $r_u$ 的一个界，并解释 $L$ 在形式验证中的作用。该控制器是一个前馈神经网络，是多个函数的复合。我们如下表示网络的各层：\n第一个仿射变换是 $f_1(x) = W_1 x + b_1$。\n第一个 ReLU 激活是 $g_1(z_1) = \\sigma(z_1)$。\n第二个仿射变换是 $f_2(z_2) = W_2 z_2 + b_2$。\n第二个 ReLU 激活是 $g_2(z_3) = \\sigma(z_3)$。\n最后的仿射变换是 $f_3(z_4) = W_3 z_4 + b_3$。\n\n完整的网络映射是这些函数的复合：$\\phi(x) = f_3(g_2(f_2(g_1(f_1(x)))))$。\n\n利普希茨连续函数的一个基本性质是，一个 $L_f$-利普希茨函数 $f$ 和一个 $L_g$-利普希茨函数 $g$ 的复合会产生一个 $(L_g L_f)$-利普希茨的函数 $g \\circ f$。这是因为 $\\|\\left(g \\circ f\\right)(x) - \\left(g \\circ f\\right)(y)\\|_2 = \\|g(f(x)) - g(f(y))\\|_2 \\le L_g \\|f(x) - f(y)\\|_2 \\le L_g (L_f \\|x-y\\|_2) = (L_g L_f) \\|x-y\\|_2$。\n通过递归地应用此性质，$\\phi(x)$ 的全局利普希茨常数 $L$ 的一个上界是其构成各层利普希茨常数的乘积：\n$$\nL \\le L_{f_3} \\cdot L_{g_2} \\cdot L_{f_2} \\cdot L_{g_1} \\cdot L_{f_1}\n$$\n\n我们现在必须从第一性原理出发，确定每一层的利普希茨常数。\n\n首先，考虑一个通用的仿射层 $f(x) = Wx + b$。\n其利普希茨常数通过分析 $\\|f(x) - f(y)\\|_2$ 来确定：\n$$\n\\|f(x) - f(y)\\|_2 = \\|(Wx+b) - (Wy+b)\\|_2 = \\|W(x-y)\\|_2\n$$\n根据诱导欧几里得算子范数的定义，对于任意向量 $v$，有 $\\|Wv\\|_2 \\le \\|W\\|_2 \\|v\\|_2$。令 $v = x-y$，我们有：\n$$\n\\|W(x-y)\\|_2 \\le \\|W\\|_2 \\|x-y\\|_2\n$$\n因此，仿射映射 $f(x) = Wx + b$ 是利普希茨连续的，其常数等于权重矩阵的算子范数，即 $L_f = \\|W\\|_2$。对于我们的网络，仿射层的利普希茨常数分别为 $L_{f_1} = \\|W_1\\|_2$、 $L_{f_2} = \\|W_2\\|_2$ 和 $L_{f_3} = \\|W_3\\|_2$。\n\n接下来，考虑逐元素的 ReLU 激活函数 $g(z) = \\sigma(z) = \\max\\{0, z\\}$。设 $z_a$ 和 $z_b$ 是两个向量。\n我们分析平方欧几里得距离 $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2$：\n$$\n\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2 = \\sum_i \\left( \\max\\{0, (z_a)_i\\} - \\max\\{0, (z_b)_i\\} \\right)^2\n$$\n对于任意一对标量 $a$ 和 $b$，函数 $h(t)=\\max\\{0,t\\}$ 是 $1$-利普希茨的，意味着 $|\\max\\{0,a\\}-\\max\\{0,b\\}| \\le |a-b|$。这可以通过分情况讨论来证明：\n1. 如果 $a0$ 且 $b0$，则 $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |a-b|$。\n2. 如果 $a\\le0$ 且 $b\\le0$，则 $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |0-0| = 0 \\le |a-b|$。\n3. 如果 $a0$ 且 $b\\le0$，则 $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |a-0| = a$。因为 $ab$，所以 $|a-b| = a-b \\ge a$。因此 $a \\le |a-b|$。\n第四种情况（$a\\le0, b0$）与第三种情况对称。在所有情况下，都有 $|\\max\\{0,a\\}-\\max\\{0,b\\}|^2 \\le |a-b|^2$。\n对所有分量求和：\n$$\n\\sum_i \\left( \\max\\{0, (z_a)_i\\} - \\max\\{0, (z_b)_i\\} \\right)^2 \\le \\sum_i \\left( (z_a)_i - (z_b)_i \\right)^2\n$$\n这等价于 $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2 \\le \\|z_a-z_b\\|_2^2$，这意味着 $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2 \\le \\|z_a-z_b\\|_2$。\n因此，逐元素的 ReLU 激活函数关于 $\\ell_2$ 范数是 $1$-利普希茨的。所以，$L_{g_1} = 1$ 且 $L_{g_2} = 1$。\n\n结合这些结果，得到 $\\phi$ 的利普希茨常数的显式上界：\n$$\nL \\le \\|W_3\\|_2 \\cdot 1 \\cdot \\|W_2\\|_2 \\cdot 1 \\cdot \\|W_1\\|_2 = \\|W_1\\|_2 \\|W_2\\|_2 \\|W_3\\|_2\n$$\n\n我们现在计算这个上界的精确值。矩阵 $W$ 的诱导 $\\ell_2$-范数，记为 $\\|W\\|_2$，是其最大奇异值 $\\sigma_{\\max}(W)$。奇异值是矩阵 $W^T W$ 的特征值的平方根。\n\n对于 $W_1 = \\begin{pmatrix}3  0\\\\ 0  2\\\\ 0  0\\end{pmatrix}$：\n$W_1^T W_1 = \\begin{pmatrix}3  0  0\\\\ 0  2  0\\end{pmatrix} \\begin{pmatrix}3  0\\\\ 0  2\\\\ 0  0\\end{pmatrix} = \\begin{pmatrix}9  0\\\\ 0  4\\end{pmatrix}$。\n特征值为 $\\lambda_1 = 9$ 和 $\\lambda_2 = 4$。\n奇异值为 $\\sqrt{9}=3$ 和 $\\sqrt{4}=2$。最大的是 $3$。\n因此，$\\|W_1\\|_2 = 3$。\n\n对于 $W_2 = \\begin{pmatrix}0  1  0\\\\ 0  0  2\\end{pmatrix}$：\n$W_2^T W_2 = \\begin{pmatrix}0  0\\\\ 1  0\\\\ 0  2\\end{pmatrix} \\begin{pmatrix}0  1  0\\\\ 0  0  2\\end{pmatrix} = \\begin{pmatrix}0  0  0\\\\ 0  1  0\\\\ 0  0  4\\end{pmatrix}$。\n特征值为 $\\lambda_1 = 4$、$\\lambda_2 = 1$ 和 $\\lambda_3 = 0$。\n非零奇异值为 $\\sqrt{4}=2$ 和 $\\sqrt{1}=1$。最大的是 $2$。\n因此，$\\|W_2\\|_2 = 2$。\n\n对于 $W_3 = \\begin{pmatrix}5  0\\end{pmatrix}$：\n$W_3^T W_3 = \\begin{pmatrix}5\\\\ 0\\end{pmatrix} \\begin{pmatrix}5  0\\end{pmatrix} = \\begin{pmatrix}25  0\\\\ 0  0\\end{pmatrix}$。\n特征值为 $\\lambda_1 = 25$ 和 $\\lambda_2 = 0$。\n最大奇异值为 $\\sqrt{25}=5$。\n因此，$\\|W_3\\|_2 = 5$。\n\n计算出的 $\\phi$ 的全局利普希茨常数的上界，我们记为 $L_{bound}$，是：\n$$\nL_{bound} = \\|W_1\\|_2 \\|W_2\\|_2 \\|W_3\\|_2 = 3 \\cdot 2 \\cdot 5 = 30\n$$\n\n对于第二个任务，我们使用这个界来找到半径 $r_u$。根据利普希茨连续性的定义，并注意到 $\\phi$ 的输出是一个标量（因此其 $\\ell_2$ 范数是其绝对值）：\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le L \\|\\hat{x} - x\\|_2\n$$\n使用我们的上界 $L_{bound} \\ge L$：\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le L_{bound} \\|\\hat{x} - x\\|_2\n$$\n我们已知 $\\|\\hat{x}-x\\|_2 \\le \\varepsilon$，其中 $\\varepsilon = 0.08$。代入这些值：\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le 30 \\cdot 0.08 = 2.4\n$$\n基于我们推导的界，保证此不等式的最小显式数值半径 $r_u$ 是 $r_u = 2.4$。四舍五入到四位有效数字得到 $r_u = 2.400$。\n\n最后，我们解释 $L$ 在鲁棒性中的作用。利普希茨常数 $L$ 作为控制器敏感度的一个可证度量，提供了一个从输入扰动（如状态估计误差）到输出偏差的最坏情况放大因子。一个经过验证的较小的 $L$ 值意味着更强的鲁棒性，这通过更容易地证明闭环系统在存在不确定性的情况下仍能保持在其安全操作范围内，从而简化了形式验证。",
            "answer": "$$\n\\boxed{2.400}\n$$"
        },
        {
            "introduction": "可满足性模理论（Satisfiability Modulo Theories, SMT）为形式化验证提供了一个强大的框架，能够精确地判定系统属性是否成立。本练习的核心任务是将一个安全属性——检查线性分类器在特定输入约束下是否存在误分类——转化为一个逻辑公式。通过求解该公式，我们可以严格证明或证否导致不安全行为的输入的存在性，从而为组件的可靠性提供保证 。",
            "id": "4223431",
            "problem": "信息物理系统中的一个支持学习的组件是一个多类线性分类器，它将输入向量 $\\mathbf{x} \\in \\mathbb{R}^n$ 映射到得分 $\\mathbf{s} = \\mathbf{W}\\mathbf{x} + \\mathbf{b}$，其中 $\\mathbf{W} \\in \\mathbb{R}^{m \\times n}$ 且 $\\mathbf{b} \\in \\mathbb{R}^m$。在标准的 $\\operatorname{argmax}$ 决策规则下，预测类别是获得最大分数的索引 $c^\\star \\in \\{0,1,\\dots,m-1\\}$。给定一个真实类别标签 $y \\in \\{0,1,\\dots,m-1\\}$ 和一个目标类别 $c \\in \\{0,1,\\dots,m-1\\}$，如果 $y \\neq c$ 且预测满足 $c^\\star = c$，我们称该分类器错误地分类到类别 $c$。数字孪生施加了形式为 $A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$ 的线性输入约束，以及逐元素的界限 $L \\le \\mathbf{x} \\le U$。为避免平局并提供鲁棒性，引入一个非负边距 $\\gamma \\ge 0$，并要求类别 $c$ 的分数比任何竞争类别至少高出 $\\gamma$：对于所有 $k \\in \\{0,1,\\dots,m-1\\}$ 且 $k \\neq c$，\n$$\\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma,$$\n其中 $\\mathbf{w}_j^\\top$ 表示 $\\mathbf{W}$ 的第 $j$ 行。\n\n任务：在无量词线性实数算术（Quantifier-Free Linear Real Arithmetic, QF_LRA）中，构建一个满足性模理论（Satisfiability Modulo Theories, SMT）查询，以检查是否存在一个输入 $\\mathbf{x}$，在满足数字孪生约束的条件下，强制分类器以边距 $\\gamma$ 预测为类别 $c$（给定 $y \\neq c$）。然后，通过将约束规约为线性规划可行性问题，实现一个程序来为所提供的测试套件判定此查询的可满足性。\n\n推导的基础依据：仅使用线性分类器的定义、$\\operatorname{argmax}$ 决策规则的语义、实数算术上的一阶逻辑，以及关于实数上线性不等式合取式的可行性可通过线性规划判定的标准特性。\n\n需要编码的精确SMT属性：判定下式的真值\n$$\\exists \\mathbf{x} \\in \\mathbb{R}^n \\;\\; \\Big( A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}} \\;\\wedge\\; L \\le \\mathbf{x} \\le U \\;\\wedge\\; \\bigwedge_{k \\in \\{0,\\dots,m-1\\}\\setminus\\{c\\}} \\big( \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma \\big) \\Big),$$\n在附加条件 $y \\neq c$ 下。当且仅当存在一个具有指定边距的误分类输入时，该查询是可满足的。\n\n测试套件规范。对于每个测试用例，给定 $(n,m,\\mathbf{W},\\mathbf{b},A,\\mathbf{b}_{\\text{ineq}},L,U,y,c,\\gamma)$：\n\n- 测试用例 1（由于正边距与不利的几何结构冲突而不可满足）：\n  - $n = 2$, $m = 3$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ -1  -1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1  1 \\\\ -1  0 \\\\ 0  -1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。\n  - $y = 0$, $c = 2$, $\\gamma = 0.1$。\n\n- 测试用例 2（在严格为负的输入下可满足）：\n  - $n = 2$, $m = 3$。\n  - $\\mathbf{W} = \\begin{bmatrix} -1  -1 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1  1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} -0.5 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} -1 \\\\ -1 \\end{bmatrix}$, $U = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n  - $y = 1$, $c = 0$, $\\gamma = 0.2$。\n\n- 测试用例 3（在 3 维空间中可满足，存在偏向目标类别的偏置）：\n  - $n = 3$, $m = 3$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1  1  0 \\\\ 0  1  1 \\\\ -1  0  1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0.5 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1  1  1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1.5 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$。\n  - $y = 0$, $c = 2$, $\\gamma = 0.0$。\n\n- 测试用例 4（根据定义不可满足，因为 $y = c$）：\n  - $n = 1$, $m = 2$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n  - $A$ 是空的 $0 \\times 1$ 矩阵，$\\mathbf{b}_{\\text{ineq}}$ 为空。\n  - $L = \\begin{bmatrix} 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\end{bmatrix}$。\n  - $y = 1$, $c = 1$, $\\gamma = 0.0$。\n\n- 测试用例 5（在 2 维空间的边距边界上可满足）：\n  - $n = 2$, $m = 2$。\n  - $\\mathbf{W} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n  - $A = \\begin{bmatrix} 1  1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1.5 \\end{bmatrix}$。\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。\n  - $y = 1$, $c = 0$, $\\gamma = 0.5$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\text{[result1,result2,result3]}$），其中每个条目都是一个布尔值，指示相应测试用例的SMT查询的可满足性。",
            "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤 1：提取给定条件\n- 输入向量：$\\mathbf{x} \\in \\mathbb{R}^n$。\n- 多类线性分类器得分：$\\mathbf{s} = \\mathbf{W}\\mathbf{x} + \\mathbf{b}$，其中 $\\mathbf{W} \\in \\mathbb{R}^{m \\times n}$ 且 $\\mathbf{b} \\in \\mathbb{R}^m$。\n- 预测类别（决策规则）：$c^\\star = \\operatorname{argmax}_{j \\in \\{0,1,\\dots,m-1\\}} s_j$。\n- 真实类别：$y \\in \\{0,1,\\dots,m-1\\}$。\n- 误分类的目标类别：$c \\in \\{0,1,\\dots,m-1\\}$。\n- 误分类条件：$y \\neq c$ 且 $c^\\star = c$。\n- 数字孪生输入约束：$A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$。\n- 逐元素输入界限：$L \\le \\mathbf{x} \\le U$。\n- 鲁棒性边距：$\\gamma \\ge 0$。\n- 鲁棒误分类条件：对于所有 $k \\in \\{0,1,\\dots,m-1\\}$ 且 $k \\neq c$，$\\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma$，其中 $\\mathbf{w}_j^\\top$ 是 $\\mathbf{W}$ 的第 $j$ 行。\n- 待判定的SMT属性：在附加条件 $y \\neq c$ 下，判定 $\\exists \\mathbf{x} \\in \\mathbb{R}^n \\;\\; \\Big( A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}} \\;\\wedge\\; L \\le \\mathbf{x} \\le U \\;\\wedge\\; \\bigwedge_{k \\in \\{0,\\dots,m-1\\}\\setminus\\{c\\}} \\big( \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma \\big) \\Big)$。\n- 测试套件：提供了五个测试用例，每个用例都给定了 $(n,m,\\mathbf{W},\\mathbf{b},A,\\mathbf{b}_{\\text{ineq}},L,U,y,c,\\gamma)$ 的具体值。\n\n### 步骤 2：使用提取的给定条件进行验证\n根据验证标准对问题进行评估。\n- **科学性**：该问题在机器学习、控制理论和形式化方法的交叉领域有坚实的基础。线性分类器、线性约束以及用于无量词线性实数算术（QF_LRA）的满足性模理论（SMT）都是标准且成熟的概念。将QF_LRA可满足性问题规约为线性规划是计算逻辑和优化的基石。\n- **适定性**：任务是确定一组线性不等式的可满足性。这是一个经典的可行性问题，其答案是确定的：要么存在可行点（可满足），要么不存在（不可满足）。因此，该问题是适定的。\n- **客观性**：所有定义和任务都以数学精度进行了规定，没有模糊或主观解释的余地。\n- **缺陷分析**：\n  1.  **科学/事实不准确**：无。数学和逻辑框架是健全的。\n  2.  **无法形式化/不相关**：无。问题被明确地形式化，并与所述的验证信息物理系统中支持学习的组件的领域直接相关。\n  3.  **不完整/矛盾**：问题是自洽的。每个测试用例都包含所有必要的数据。条件 $y \\neq c$ 是误分类的定义性先决条件。测试用例 4 中 $y = c$ 的情况被正确定性为根据此定义不可满足，这是问题设置的逻辑结果，而非其内部矛盾。\n  4.  **不切实际/不可行**：参数是数值的，不涉及物理单位，因此排除了量纲不一致的可能性。该设置是一个标准的抽象数学模型。\n  5.  **不适定/结构不良**：无。决策问题定义清晰。\n  6.  **伪深刻/琐碎**：虽然单个测试用例可能易于分析，但整个问题需要系统且正确地实现从 SMT 到 LP 的规约，这并非易事。\n  7.  **无法通过科学方法验证**：无。可满足性可以通过标准算法程序（线性规划）进行验证。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n问题的核心是确定在无量词线性实数算术（QF_LRA）理论中一个存在量化公式的可满足性。该公式是关于实值向量 $\\mathbf{x} \\in \\mathbb{R}^n$ 的一组线性不等式的合取。这样一个 $\\mathbf{x}$ 是否存在，可以通过将问题构建为一个线性规划（LP）可行性问题来判定。\n\n当且仅当存在一个 $\\mathbf{x}$ 同时满足三组约束时，该SMT查询是可满足的：\n1. 数字孪生的操作约束：$A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$。\n2. 输入的逐元素界限：$L \\le \\mathbf{x} \\le U$。\n3. 鲁棒误分类条件：对于每个类别索引 $k$（$k \\neq c$），目标类别 $c$ 的得分必须大于或等于类别 $k$ 的得分加上一个边距 $\\gamma$。\n\n让我们将这些约束形式化为LP求解器所需的标准形式。待求的变量是 $\\mathbf{x}$。\n\n首先，附加条件 $y \\neq c$ 是误分类的定义性条件。如果 $y = c$，那么寻找一个*误分类*输入的前提就不成立。因此，这样的输入不存在，根据定义，查询是不可满足的。这构成了一个初步检查。\n\n假设 $y \\neq c$，我们组建线性不等式系统。\n数字孪生约束 $A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$ 已经是标准形式。\n\n逐元素界限 $L \\le \\mathbf{x} \\le U$ 等价于两个矩阵不等式，$\\mathbf{I}\\mathbf{x} \\le U$ 和 $-\\mathbf{I}\\mathbf{x} \\le -L$，其中 $\\mathbf{I}$ 是 $n \\times n$ 的单位矩阵。然而，大多数LP求解器，包括 `scipy.optimize.linprog`，可以直接接受箱式约束，这更高效。我们将为 $\\mathbf{x}$ 的每个分量提供 `(下界, 上界)` 对形式的界限。\n\n对于所有 $k \\in \\{0, 1, \\dots, m-1\\}$ 且 $k \\neq c$，鲁棒误分类条件为：\n$$ \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma $$\n必须将这些不等式重排为标准形式 $(\\text{矩阵}) \\cdot \\mathbf{x} \\le (\\text{向量})$。通过将所有含 $\\mathbf{x}$ 的项移到一边，常数移到另一边，我们得到：\n$$ (\\mathbf{w}_k - \\mathbf{w}_c)^\\top \\mathbf{x} \\le b_c - b_k - \\gamma $$\n对于每个竞争类别 $k$，都有一个这样的不等式，总共有 $m-1$ 个。\n\n结合所有这些不等式，我们构建一个形如 $C_{\\text{total}}\\mathbf{x} \\le \\mathbf{d}_{\\text{total}}$ 的单一系统，其中 $C_{\\text{total}}$ 由矩阵 $A$ 和 $m-1$ 个行向量 $(\\mathbf{w}_k - \\mathbf{w}_c)^\\top$ 垂直堆叠而成，而 $\\mathbf{d}_{\\text{total}}$ 由向量 $\\mathbf{b}_{\\text{ineq}}$ 和 $m-1$ 个标量 $b_c - b_k - \\gamma$ 堆叠而成。\n\n问题现在规约为寻找是否存在一个 $\\mathbf{x}$ 使得 $C_{\\text{total}}\\mathbf{x} \\le \\mathbf{d}_{\\text{total}}$ 且 $L \\le \\mathbf{x} \\le U$。这是一个典型的LP可行性问题。我们可以通过将其提供给一个带有空目标函数（例如，最小化 $0^\\top\\mathbf{x}$）的LP求解器来解决它。如果求解器找到一个可行解，那么原始的SMT查询是可满足的（`True`）。如果求解器确定可行集为空（即问题不可行），那么查询是不可满足的（`False`）。\n\n实现将遵循这一逻辑。对于每个测试用例，我们首先检查 $y=c$ 条件。如果不满足该条件，我们将为不等式约束构建矩阵和界限向量。然后，我们使用 `scipy.optimize.linprog` 来解决可行性问题。返回的结果对象的 `success` 属性直接指示是否找到了可行解，从而回答了可满足性问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_satisfiability(n, m, W, b, A, b_ineq, L, U, y, c, gamma):\n    \"\"\"\n    Checks the satisfiability of the SMT query by reducing it to an LP feasibility problem.\n    \"\"\"\n    # By definition of misclassification, the ground truth y must not be the target class c.\n    # If y == c, the condition is not met, thus no such misclassifying input exists.\n    if y == c:\n        return False\n\n    # The goal is to find if a feasible x exists. This is an LP feasibility problem.\n    # We can set a null objective function, e.g., min 0^T * x.\n    # The vector of coefficients for the objective function.\n    c_obj = np.zeros(n)\n\n    # Aggregate all inequality constraints of the form A_ub * x = b_ub\n    A_ub_list = []\n    b_ub_list = []\n\n    # 1. Digital twin constraints: A*x = b_ineq\n    # Handle the case where A might be an empty matrix.\n    if A.shape[0] > 0:\n        A_ub_list.append(A)\n        b_ub_list.append(b_ineq.flatten())\n\n    # 2. Robust misclassification constraints:\n    # For all k != c, w_c^T*x + b_c >= w_k^T*x + b_k + gamma\n    # Rearranging gives: (w_k - w_c)^T*x = b_c - b_k - gamma\n    w_c_row = W[c, :]\n    b_c_val = b[c]\n    for k in range(m):\n        if k == c:\n            continue\n        w_k_row = W[k, :]\n        b_k_val = b[k]\n\n        # Form the inequality (w_k - w_c)^T * x = b_c - b_k - gamma\n        A_row = w_k_row - w_c_row\n        b_val = b_c_val - b_k_val - gamma\n\n        A_ub_list.append(A_row.reshape(1, -1))\n        b_ub_list.append(np.array([b_val]))\n\n    A_ub = None\n    b_ub = None\n    if A_ub_list:\n        A_ub = np.vstack(A_ub_list)\n        b_ub = np.concatenate(b_ub_list)\n\n    # 3. Element-wise bounds: L = x = U\n    # This is handled by the 'bounds' parameter of linprog.\n    # It expects a sequence of (min, max) pairs for each variable.\n    bounds = list(zip(L.flatten(), U.flatten()))\n\n    # Solve the linear programming feasibility problem.\n    # method='highs' is used as it is the recommended solver.\n    # If the problem is feasible, linprog returns success=True.\n    # If it is infeasible, it returns success=False.\n    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    # The satisfiability of the SMT query is equivalent to the feasibility of the LP.\n    return res.success\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (unsatisfiable)\n        {\n            \"n\": 2, \"m\": 3,\n            \"W\": np.array([[1., 0.], [0., 1.], [-1., -1.]]),\n            \"b\": np.array([0., 0., 0.]),\n            \"A\": np.array([[1., 1.], [-1., 0.], [0., -1.]]),\n            \"b_ineq\": np.array([1., 0., 0.]),\n            \"L\": np.array([0., 0.]), \"U\": np.array([1., 1.]),\n            \"y\": 0, \"c\": 2, \"gamma\": 0.1\n        },\n        # Test case 2 (satisfiable)\n        {\n            \"n\": 2, \"m\": 3,\n            \"W\": np.array([[-1., -1.], [1., 0.], [0., 1.]]),\n            \"b\": np.array([0., 0., 0.]),\n            \"A\": np.array([[1., 1.]]), \"b_ineq\": np.array([-0.5]),\n            \"L\": np.array([-1., -1.]), \"U\": np.array([0., 0.]),\n            \"y\": 1, \"c\": 0, \"gamma\": 0.2\n        },\n        # Test case 3 (satisfiable)\n        {\n            \"n\": 3, \"m\": 3,\n            \"W\": np.array([[1., 1., 0.], [0., 1., 1.], [-1., 0., 1.]]),\n            \"b\": np.array([0., 0., 0.5]),\n            \"A\": np.array([[1., 1., 1.]]), \"b_ineq\": np.array([1.5]),\n            \"L\": np.array([0., 0., 0.]), \"U\": np.array([1., 1., 1.]),\n            \"y\": 0, \"c\": 2, \"gamma\": 0.0\n        },\n        # Test case 4 (unsatisfiable by y=c)\n        {\n            \"n\": 1, \"m\": 2,\n            \"W\": np.array([[1.], [2.]]), \"b\": np.array([0., 0.]),\n            \"A\": np.empty((0, 1)), \"b_ineq\": np.empty(0),\n            \"L\": np.array([0.]), \"U\": np.array([1.]),\n            \"y\": 1, \"c\": 1, \"gamma\": 0.0\n        },\n        # Test case 5 (satisfiable)\n        {\n            \"n\": 2, \"m\": 2,\n            \"W\": np.array([[1., 0.], [0., 1.]]), \"b\": np.array([0., 0.]),\n            \"A\": np.array([[1., 1.]]), \"b_ineq\": np.array([1.5]),\n            \"L\": np.array([0., 0.]), \"U\": np.array([1., 1.]),\n            \"y\": 1, \"c\": 0, \"gamma\": 0.5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        is_sat = check_satisfiability(\n            case[\"n\"], case[\"m\"], case[\"W\"], case[\"b\"], case[\"A\"],\n            case[\"b_ineq\"], case[\"L\"], case[\"U\"], case[\"y\"], case[\"c\"], case[\"gamma\"]\n        )\n        results.append(is_sat)\n\n    # Final print statement in the exact required format.\n    # Outputting booleans as lowercase strings: 'true'/'false'.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了静态验证，对系统在运行过程中的动态行为进行监控同样至关重要。信号时序逻辑（Signal Temporal Logic, STL）是一种描述连续时间信号属性的形式化语言。本练习将演示如何计算STL公式的鲁棒性（robustness），该值量化了系统轨迹满足或违反给定时序规范的程度，是实现运行时验证和故障诊断的关键技术 。",
            "id": "4223379",
            "problem": "一个数字孪生监视着一个由嵌入在信息物理系统中的支持学习的状态估计器所生成的归一化跟踪误差信号 $x(t)$。该验证任务通过信号时序逻辑 (STL) 公式 $\\varphi = \\Box_{[0,5]}(x \\le 1)$ 进行规约，其通俗地要求归一化误差在区间 $[0,5]$ 内的所有时间点都保持在阈值 $1$ 或以下。该监视器处理带有事件触发采样时刻 $t_k \\in [0,5]$ 的采样信号 $x(t_k)$，并使用 STL 的标准定量语义来评估鲁棒性。\n\n在区间 $[0,5]$ 上记录的样本如下：\n$t_0 = 0$, $x(t_0) = 0.72$;\n$t_1 = 0.3$, $x(t_1) = 0.88$;\n$t_2 = 0.9$, $x(t_2) = 1.05$;\n$t_3 = 1.4$, $x(t_3) = 0.97$;\n$t_4 = 2.1$, $x(t_4) = 0.91$;\n$t_5 = 2.7$, $x(t_5) = 1.02$;\n$t_6 = 3.2$, $x(t_6) = 0.95$;\n$t_7 = 3.8$, $x(t_7) = 0.89$;\n$t_8 = 4.4$, $x(t_8) = 1.10$;\n$t_9 = 5.0$, $x(t_9) = 0.93$。\n\n请使用针对采样信号的信号时序逻辑鲁棒性语义和给定数据，通过评估所有样本 $t_k \\in [0,5]$ 的最小裕度 $1 - x(t_k)$，计算公式 $\\varphi$ 在区间 $[0,5]$ 上的鲁棒值。将该鲁棒值表示为一个无量纲标量，并将最终答案四舍五入至三位有效数字。",
            "solution": "该问题要求基于一个信号的有限采样数据集，计算一个信号时序逻辑 (STL) 公式的鲁棒值。对问题陈述的验证证实了其具有科学依据、是适定的，并包含了得出唯一解所需的所有必要信息。\n\nSTL 公式为 $\\varphi = \\Box_{[0,5]}(x \\le 1)$。该公式由一个应用于时间区间 $[0,5]$ 的时间算子“总是”（$\\Box$）和一个原子谓词 $\\mu = (x \\le 1)$ 组成。\n\nSTL 的定量语义定义了一个鲁棒值，记为 $\\rho(\\varphi, x)$，它衡量信号 $x(t)$ 满足公式 $\\varphi$ 的程度。正值表示满足，负值表示违反，零值表示在边界上满足。\n\n形式为 $f(x) \\ge c$ 的原子谓词的鲁棒性定义为表达式 $f(x) - c$ 的值。谓词 $\\mu = (x \\le 1)$ 可以重写为 $1 - x \\ge 0$。因此，其在特定时间 $t$ 的鲁棒性由下式给出：\n$$\n\\rho(\\mu, x, t) = 1 - x(t)\n$$\n这个值代表信号 $x(t)$ 满足条件 $x \\le 1$ 的裕度。如果 $x(t)  1$，裕度为正；如果 $x(t)  1$，裕度为负。\n\n“总是”算子 $\\Box_{I}$ 断言其子公式在区间 $I$ 内的所有时间点都成立。其鲁棒性定义为在该区间上子公式鲁棒性的下确界（对于有限点集，则为最小值）。对于公式 $\\varphi = \\Box_{[0,5]}\\mu$，其连续时间鲁棒性为：\n$$\n\\rho(\\varphi, x) = \\inf_{t \\in [0,5]} \\rho(\\mu, x, t) = \\inf_{t \\in [0,5]} (1 - x(t))\n$$\n问题指明，监视器是作用于一个离散样本集 $\\{ (t_k, x(t_k)) \\}$，其中所有 $t_k \\in [0,5]$。根据问题中“评估所有样本的最小裕度”的指示，鲁棒性计算是在这个离散点集上执行的。下确界算子变成了最小算子：\n$$\n\\rho(\\varphi, x) = \\min_{k} (1 - x(t_k))\n$$\n其中 $k$ 遍及所有提供的样本。\n\n注意到当 $x(t_k)$ 取最大值时，$1 - x(t_k)$ 取最小值，该表达式可以简化为：\n$$\n\\min_{k} (1 - x(t_k)) = 1 - \\max_{k} x(t_k)\n$$\n我们得到以下10个信号 $x(t)$ 的样本：\n$x(t_0) = 0.72$\n$x(t_1) = 0.88$\n$x(t_2) = 1.05$\n$x(t_3) = 0.97$\n$x(t_4) = 0.91$\n$x(t_5) = 1.02$\n$x(t_6) = 0.95$\n$x(t_7) = 0.89$\n$x(t_8) = 1.10$\n$x(t_9) = 0.93$\n\n我们必须在这组信号值中找到最大值。通过观察，最大值为：\n$$\n\\max_{k} x(t_k) = x(t_8) = 1.10\n$$\n现在，我们可以使用推导出的公式计算鲁棒值：\n$$\n\\rho(\\varphi, x) = 1 - \\max_{k} x(t_k) = 1 - 1.10 = -0.10\n$$\n负号表示规约 $\\varphi$ 被违反。数值 $-0.10$ 量化了这次违反的程度；在时间 $t_8 = 4.4$ 时，信号 $x(t_8)$ 超过了阈值 $1$，超出量为 $0.10$。\n\n问题要求答案四舍五入至三位有效数字。计算值为 $-0.10$。第一个有效数字是数字 $1$。随后的零也是有效数字。为了用三位有效数字表示，我们将其写作 $-0.100$。",
            "answer": "$$\n\\boxed{-0.100}\n$$"
        }
    ]
}