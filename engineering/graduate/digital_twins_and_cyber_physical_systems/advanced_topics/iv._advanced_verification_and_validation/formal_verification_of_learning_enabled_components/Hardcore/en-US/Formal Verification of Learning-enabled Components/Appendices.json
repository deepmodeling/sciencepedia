{
    "hands_on_practices": [
        {
            "introduction": "Formal verification often requires certifying that a learning-enabled component is robust to small input changes, such as those from sensor noise or state estimation errors. A key tool for this is the Lipschitz constant, which provides a worst-case bound on how much the component's output can change. This practice will guide you through deriving and computing this constant for a ReLU network from first principles, a fundamental skill for analyzing the robustness of neural networks .",
            "id": "4223377",
            "problem": "A digital twin of a cyber-physical system uses a learning-enabled controller realized as a feedforward Rectified Linear Unit (ReLU) network. Formal verification of closed-loop safety requires bounding the controller’s sensitivity to state-estimation mismatch. Consider the controller map $u=\\phi(x)$ defined by\n$$\n\\phi(x) \\;=\\; W_3\\,\\sigma\\!\\big(W_2\\,\\sigma\\!\\big(W_1\\,x + b_1\\big) + b_2\\big) + b_3,\n$$\nwhere $\\sigma(\\cdot)$ is the elementwise Rectified Linear Unit (ReLU), $\\sigma(z)=\\max\\{0,z\\}$ applied coordinatewise. The weight matrices and biases are\n$$\nW_1=\\begin{pmatrix}3  0 \\\\ 0  2 \\\\ 0  0\\end{pmatrix},\\quad b_1=\\begin{pmatrix}0 \\\\ 0 \\\\ 0\\end{pmatrix},\\quad\nW_2=\\begin{pmatrix}0  1  0 \\\\ 0  0  2\\end{pmatrix},\\quad b_2=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix},\\quad\nW_3=\\begin{pmatrix}5  0\\end{pmatrix},\\quad b_3=0.\n$$\nWork from first principles, beginning with the definition of Lipschitz continuity $($that is, a function $f$ is $L$-Lipschitz if $\\|f(x)-f(y)\\|_2\\le L\\|x-y\\|_2$ for all $x,y)$, the definition of the induced Euclidean operator norm $\\|W\\|_2=\\sup_{\\|v\\|_2=1}\\|Wv\\|_2$, and the basic properties of affine maps and the ReLU nonlinearity. Do not introduce any unproven shortcuts.\n\nTasks:\n- Derive an explicit, computable upper bound on the global Lipschitz constant $L$ of $\\phi$ with respect to the $\\ell_2$ norm, expressed in terms of the weight matrices above, and compute its exact value.\n- Suppose the digital twin’s state estimate $\\hat{x}$ satisfies an a priori bound on the estimation error $\\|\\hat{x}-x\\|_2\\le \\varepsilon$ with $\\varepsilon=0.08$. Use your bound on $L$ to obtain the smallest explicit numerical radius $r_u$ such that the control deviation satisfies $|\\,\\phi(\\hat{x})-\\phi(x)\\,|\\le r_u$ for all admissible $(x,\\hat{x})$ obeying the error bound. Round your numerical answer for $r_u$ to four significant figures. No physical units are required.\n- Briefly explain in one or two sentences how the value of $L$ you computed affects robustness claims used in formal verification of the closed-loop system.\n\nProvide as your final numeric answer the value of $r_u$ rounded to four significant figures.",
            "solution": "The problem asks for an upper bound on the global Lipschitz constant $L$ of the controller map $\\phi(x)$, the subsequent calculation of a bound on the control deviation $r_u$, and an explanation of the role of $L$ in formal verification. The controller is a feedforward neural network, which is a composition of functions. Let us denote the layers of the network as follows:\nThe first affine transformation is $f_1(x) = W_1 x + b_1$.\nThe first ReLU activation is $g_1(z_1) = \\sigma(z_1)$.\nThe second affine transformation is $f_2(z_2) = W_2 z_2 + b_2$.\nThe second ReLU activation is $g_2(z_3) = \\sigma(z_3)$.\nThe final affine transformation is $f_3(z_4) = W_3 z_4 + b_3$.\n\nThe complete network map is the composition of these functions: $\\phi(x) = f_3(g_2(f_2(g_1(f_1(x)))))$.\n\nA fundamental property of Lipschitz continuous functions is that the composition of an $L_f$-Lipschitz function $f$ and an $L_g$-Lipschitz function $g$ results in a function $g \\circ f$ that is $(L_g L_f)$-Lipschitz. This is because $\\|\\left(g \\circ f\\right)(x) - \\left(g \\circ f\\right)(y)\\|_2 = \\|g(f(x)) - g(f(y))\\|_2 \\le L_g \\|f(x) - f(y)\\|_2 \\le L_g (L_f \\|x-y\\|_2) = (L_g L_f) \\|x-y\\|_2$.\nBy applying this property recursively, an upper bound on the global Lipschitz constant $L$ of $\\phi(x)$ is the product of the Lipschitz constants of its constituent layers:\n$$\nL \\le L_{f_3} \\cdot L_{g_2} \\cdot L_{f_2} \\cdot L_{g_1} \\cdot L_{f_1}\n$$\n\nWe must now determine the Lipschitz constant for each layer from first principles.\n\nFirst, consider a general affine layer $f(x) = Wx + b$.\nIts Lipschitz constant is determined by analyzing $\\|f(x) - f(y)\\|_2$:\n$$\n\\|f(x) - f(y)\\|_2 = \\|(Wx+b) - (Wy+b)\\|_2 = \\|W(x-y)\\|_2\n$$\nBy the definition of the induced Euclidean operator norm, $\\|Wv\\|_2 \\le \\|W\\|_2 \\|v\\|_2$ for any vector $v$. Letting $v = x-y$, we have:\n$$\n\\|W(x-y)\\|_2 \\le \\|W\\|_2 \\|x-y\\|_2\n$$\nThus, the affine map $f(x) = Wx + b$ is Lipschitz continuous with a constant equal to the operator norm of the weight matrix, $L_f = \\|W\\|_2$. For our network, the Lipschitz constants of the affine layers are $L_{f_1} = \\|W_1\\|_2$, $L_{f_2} = \\|W_2\\|_2$, and $L_{f_3} = \\|W_3\\|_2$.\n\nNext, consider the elementwise ReLU activation function, $g(z) = \\sigma(z) = \\max\\{0, z\\}$. Let $z_a$ and $z_b$ be two vectors.\nWe analyze the squared Euclidean distance $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2$:\n$$\n\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2 = \\sum_i \\left( \\max\\{0, (z_a)_i\\} - \\max\\{0, (z_b)_i\\} \\right)^2\n$$\nFor any pair of scalars $a$ and $b$, the function $h(t)=\\max\\{0,t\\}$ is $1$-Lipschitz, meaning $|\\max\\{0,a\\}-\\max\\{0,b\\}| \\le |a-b|$. This can be shown by cases:\n1. If $a>0$ and $b>0$, $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |a-b|$.\n2. If $a\\le0$ and $b\\le0$, $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |0-0| = 0 \\le |a-b|$.\n3. If $a>0$ and $b\\le0$, $|\\max\\{0,a\\}-\\max\\{0,b\\}| = |a-0| = a$. Since $a>b$, $|a-b| = a-b \\ge a$. Thus $a \\le |a-b|$.\nThe fourth case ($a\\le0, b>0$) is symmetric to the third. In all cases, $|\\max\\{0,a\\}-\\max\\{0,b\\}|^2 \\le |a-b|^2$.\nSumming over all components:\n$$\n\\sum_i \\left( \\max\\{0, (z_a)_i\\} - \\max\\{0, (z_b)_i\\} \\right)^2 \\le \\sum_i \\left( (z_a)_i - (z_b)_i \\right)^2\n$$\nThis is equivalent to $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2^2 \\le \\|z_a-z_b\\|_2^2$, which implies $\\|\\sigma(z_a) - \\sigma(z_b)\\|_2 \\le \\|z_a-z_b\\|_2$.\nTherefore, the elementwise ReLU activation function is $1$-Lipschitz with respect to the $\\ell_2$ norm. So, $L_{g_1} = 1$ and $L_{g_2} = 1$.\n\nCombining these results yields the explicit upper bound for the Lipschitz constant of $\\phi$:\n$$\nL \\le \\|W_3\\|_2 \\cdot 1 \\cdot \\|W_2\\|_2 \\cdot 1 \\cdot \\|W_1\\|_2 = \\|W_1\\|_2 \\|W_2\\|_2 \\|W_3\\|_2\n$$\n\nWe now compute the exact value of this upper bound. The induced $\\ell_2$-norm of a matrix $W$, denoted $\\|W\\|_2$, is its largest singular value, $\\sigma_{\\max}(W)$. The singular values are the square roots of the eigenvalues of the matrix $W^T W$.\n\nFor $W_1 = \\begin{pmatrix}3  0\\\\ 0  2\\\\ 0  0\\end{pmatrix}$:\n$W_1^T W_1 = \\begin{pmatrix}3  0  0\\\\ 0  2  0\\end{pmatrix} \\begin{pmatrix}3  0\\\\ 0  2\\\\ 0  0\\end{pmatrix} = \\begin{pmatrix}9  0\\\\ 0  4\\end{pmatrix}$.\nThe eigenvalues are $\\lambda_1 = 9$ and $\\lambda_2 = 4$.\nThe singular values are $\\sqrt{9}=3$ and $\\sqrt{4}=2$. The largest is $3$.\nThus, $\\|W_1\\|_2 = 3$.\n\nFor $W_2 = \\begin{pmatrix}0  1  0\\\\ 0  0  2\\end{pmatrix}$:\n$W_2^T W_2 = \\begin{pmatrix}0  0\\\\ 1  0\\\\ 0  2\\end{pmatrix} \\begin{pmatrix}0  1  0\\\\ 0  0  2\\end{pmatrix} = \\begin{pmatrix}0  0  0\\\\ 0  1  0\\\\ 0  0  4\\end{pmatrix}$.\nThe eigenvalues are $\\lambda_1 = 4$, $\\lambda_2 = 1$, and $\\lambda_3 = 0$.\nThe non-zero singular values are $\\sqrt{4}=2$ and $\\sqrt{1}=1$. The largest is $2$.\nThus, $\\|W_2\\|_2 = 2$.\n\nFor $W_3 = \\begin{pmatrix}5  0\\end{pmatrix}$:\n$W_3^T W_3 = \\begin{pmatrix}5\\\\ 0\\end{pmatrix} \\begin{pmatrix}5  0\\end{pmatrix} = \\begin{pmatrix}25  0\\\\ 0  0\\end{pmatrix}$.\nThe eigenvalues are $\\lambda_1 = 25$ and $\\lambda_2 = 0$.\nThe largest singular value is $\\sqrt{25}=5$.\nThus, $\\|W_3\\|_2 = 5$.\n\nThe computed upper bound on the global Lipschitz constant of $\\phi$, which we denote $L_{bound}$, is:\n$$\nL_{bound} = \\|W_1\\|_2 \\|W_2\\|_2 \\|W_3\\|_2 = 3 \\cdot 2 \\cdot 5 = 30\n$$\n\nFor the second task, we use this bound to find the radius $r_u$. From the definition of Lipschitz continuity, and noting that the output of $\\phi$ is a scalar (so its $\\ell_2$ norm is its absolute value):\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le L \\|\\hat{x} - x\\|_2\n$$\nUsing our upper bound $L_{bound} \\ge L$:\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le L_{bound} \\|\\hat{x} - x\\|_2\n$$\nWe are given $\\|\\hat{x}-x\\|_2 \\le \\varepsilon$ with $\\varepsilon = 0.08$. Substituting the values:\n$$\n|\\phi(\\hat{x}) - \\phi(x)| \\le 30 \\cdot 0.08 = 2.4\n$$\nThe smallest explicit numerical radius $r_u$ that guarantees this inequality, based on our derived bound, is $r_u = 2.4$. Rounding to four significant figures gives $r_u = 2.400$.\n\nFinally, we explain the role of $L$ in robustness. The Lipschitz constant $L$ serves as a certified measure of the controller's sensitivity, providing a worst-case amplification factor from input perturbations (like state estimation errors) to output deviations. A smaller, verified value of $L$ implies greater robustness, which simplifies formal verification by making it easier to prove that the closed-loop system remains within its safe operational bounds despite uncertainties.",
            "answer": "$$\n\\boxed{2.400}\n$$"
        },
        {
            "introduction": "To guarantee the safety of a learning-enabled classifier, we must prove that no allowable input can lead to a critical misclassification. This practice introduces a powerful technique that translates this verification question into a Satisfiability Modulo Theories (SMT) query. You will learn how to encode the classifier's logic and the system's input constraints into a set of linear inequalities, whose feasibility can be definitively checked using a linear programming solver .",
            "id": "4223431",
            "problem": "A learning-enabled component in a cyber-physical system is a multi-class linear classifier that maps an input vector $\\mathbf{x} \\in \\mathbb{R}^n$ to scores $\\mathbf{s} = \\mathbf{W}\\mathbf{x} + \\mathbf{b}$, where $\\mathbf{W} \\in \\mathbb{R}^{m \\times n}$ and $\\mathbf{b} \\in \\mathbb{R}^m$. The predicted class is the index $c^\\star \\in \\{0,1,\\dots,m-1\\}$ achieving the maximum score under the standard $\\operatorname{argmax}$ decision rule. Given a ground-truth class label $y \\in \\{0,1,\\dots,m-1\\}$ and a target class $c \\in \\{0,1,\\dots,m-1\\}$, we say the classifier misclassifies into class $c$ if $y \\neq c$ and the prediction satisfies $c^\\star = c$. The digital twin imposes linear input constraints of the form $A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$, together with element-wise bounds $L \\le \\mathbf{x} \\le U$. To avoid ties and provide robustness, introduce a nonnegative margin $\\gamma \\ge 0$ and require that the score of class $c$ dominates every rival by at least $\\gamma$: for all $k \\in \\{0,1,\\dots,m-1\\}$ with $k \\neq c$, \n$$\\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma,$$\nwhere $\\mathbf{w}_j^\\top$ denotes the $j$-th row of $\\mathbf{W}$.\n\nTask: Formulate a Satisfiability Modulo Theories (SMT) query in Quantifier-Free Linear Real Arithmetic (QF\\_LRA) that checks whether there exists an input $\\mathbf{x}$ satisfying the digital twin constraints and forcing the classifier to predict class $c$ with margin $\\gamma$, given $y \\neq c$. Then, implement a program that decides the satisfiability of this query for the provided test suite by reducing the constraints to linear programming feasibility.\n\nFoundational base for derivation: use only the definitions of a linear classifier, the $\\operatorname{argmax}$ decision rule semantics, first-order logic over real arithmetic, and the standard characterization that feasibility of a conjunction of linear inequalities over reals can be decided via linear programming.\n\nPrecise SMT property to encode: decide the truth of\n$$\\exists \\mathbf{x} \\in \\mathbb{R}^n \\;\\; \\Big( A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}} \\;\\wedge\\; L \\le \\mathbf{x} \\le U \\;\\wedge\\; \\bigwedge_{k \\in \\{0,\\dots,m-1\\}\\setminus\\{c\\}} \\big( \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma \\big) \\Big),$$\nunder the side condition $y \\neq c$. The query is satisfiable if and only if there exists a misclassifying input with the specified margin.\n\nTest suite specification. For each test case, you are given $(n,m,\\mathbf{W},\\mathbf{b},A,\\mathbf{b}_{\\text{ineq}},L,U,y,c,\\gamma)$:\n\n- Test case $1$ (unsatisfiable due to positive margin against unfavorable geometry):\n  - $n = 2$, $m = 3$.\n  - $\\mathbf{W} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\\\ -1  -1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$.\n  - $A = \\begin{bmatrix} 1  1 \\\\ -1  0 \\\\ 0  -1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\end{bmatrix}$.\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$.\n  - $y = 0$, $c = 2$, $\\gamma = 0.1$.\n\n- Test case $2$ (satisfiable with strictly negative inputs):\n  - $n = 2$, $m = 3$.\n  - $\\mathbf{W} = \\begin{bmatrix} -1  -1 \\\\ 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$.\n  - $A = \\begin{bmatrix} 1  1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} -0.5 \\end{bmatrix}$.\n  - $L = \\begin{bmatrix} -1 \\\\ -1 \\end{bmatrix}$, $U = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n  - $y = 1$, $c = 0$, $\\gamma = 0.2$.\n\n- Test case $3$ (satisfiable in $3$ dimensions with a bias favoring the target class):\n  - $n = 3$, $m = 3$.\n  - $\\mathbf{W} = \\begin{bmatrix} 1  1  0 \\\\ 0  1  1 \\\\ -1  0  1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0.5 \\end{bmatrix}$.\n  - $A = \\begin{bmatrix} 1  1  1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1.5 \\end{bmatrix}$.\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$.\n  - $y = 0$, $c = 2$, $\\gamma = 0.0$.\n\n- Test case $4$ (unsatisfiable by definition since $y = c$):\n  - $n = 1$, $m = 2$.\n  - $\\mathbf{W} = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n  - $A$ is the empty $0 \\times 1$ matrix, and $\\mathbf{b}_{\\text{ineq}}$ is empty.\n  - $L = \\begin{bmatrix} 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\end{bmatrix}$.\n  - $y = 1$, $c = 1$, $\\gamma = 0.0$.\n\n- Test case $5$ (satisfiable at the margin boundary in $2$ dimensions):\n  - $n = 2$, $m = 2$.\n  - $\\mathbf{W} = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix}$, $\\mathbf{b} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$.\n  - $A = \\begin{bmatrix} 1  1 \\end{bmatrix}$, $\\mathbf{b}_{\\text{ineq}} = \\begin{bmatrix} 1.5 \\end{bmatrix}$.\n  - $L = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$, $U = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$.\n  - $y = 1$, $c = 0$, $\\gamma = 0.5$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\text{[result1,result2,result3]}$), where each entry is a boolean indicating satisfiability of the SMT query for the corresponding test case.",
            "solution": "The core of the problem is to determine the satisfiability of an existentially quantified formula in the theory of Quantifier-Free Linear Real Arithmetic (QF_LRA). The formula is a conjunction of linear inequalities over a real-valued vector $\\mathbf{x} \\in \\mathbb{R}^n$. The existence of such an $\\mathbf{x}$ can be decided by formulating the problem as a linear programming (LP) feasibility problem.\n\nThe SMT query is satisfiable if and only if there exists an $\\mathbf{x}$ that simultaneously satisfies three sets of constraints:\n1.  The digital twin's operational constraints: $A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$.\n2.  The element-wise bounds on the input: $L \\le \\mathbf{x} \\le U$.\n3.  The robust misclassification conditions: For every class index $k$ such that $k \\neq c$, the score of the target class $c$ must be greater than or equal to the score of class $k$ plus a margin $\\gamma$.\n\nLet us formalize these constraints into the standard form required for an LP solver. The variable to be found is $\\mathbf{x}$.\n\nFirst, the side condition $y \\neq c$ is definitional for a misclassification. If $y = c$, the premise of seeking a *misclassifying* input is false. Therefore, no such input exists, and the query is unsatisfiable by definition. This constitutes a preliminary check.\n\nAssuming $y \\neq c$, we assemble the system of linear inequalities. The digital twin constraints $A\\mathbf{x} \\le \\mathbf{b}_{\\text{ineq}}$ are already in the standard form.\n\nThe element-wise bounds $L \\le \\mathbf{x} \\le U$ are handled directly by the bounds parameter of standard LP solvers.\n\nThe robust misclassification conditions are given for all $k \\in \\{0, 1, \\dots, m-1\\}$ where $k \\neq c$:\n$$ \\mathbf{w}_c^\\top \\mathbf{x} + b_c \\ge \\mathbf{w}_k^\\top \\mathbf{x} + b_k + \\gamma $$\nThese must be rearranged into the standard form $(\\text{matrix}) \\cdot \\mathbf{x} \\le (\\text{vector})$. By moving all terms involving $\\mathbf{x}$ to one side and constants to the other, we obtain:\n$$ (\\mathbf{w}_k - \\mathbf{w}_c)^\\top \\mathbf{x} \\le b_c - b_k - \\gamma $$\nThere are $m-1$ such inequalities, one for each rival class $k$.\n\nCombining all these inequalities, we construct a single system of the form $C_{\\text{total}}\\mathbf{x} \\le \\mathbf{d}_{\\text{total}}$, where $C_{\\text{total}}$ is formed by vertically stacking the matrix $A$ and the $m-1$ row vectors $(\\mathbf{w}_k - \\mathbf{w}_c)^\\top$, and $\\mathbf{d}_{\\text{total}}$ is formed by stacking the vector $\\mathbf{b}_{\\text{ineq}}$ and the $m-1$ scalars $b_c - b_k - \\gamma$.\n\nThe problem is now reduced to finding if there exists an $\\mathbf{x}$ such that $C_{\\text{total}}\\mathbf{x} \\le \\mathbf{d}_{\\text{total}}$ and $L \\le \\mathbf{x} \\le U$. This is a canonical LP feasibility problem. We can solve it by providing it to an LP solver with a null objective function (e.g., minimize $0^\\top\\mathbf{x}$). If the solver finds a feasible solution, the original SMT query is satisfiable (`True`). If the solver determines the feasible set is empty (i.e., the problem is infeasible), the query is unsatisfiable (`False`).\n\nThe implementation will follow this logic. For each test case, we first check the $y=c$ condition. If it is met, the query is unsatisfiable. Otherwise, we construct the matrices for the inequality constraints and the bounds vector. We then use a standard LP solver to solve the feasibility problem. The solver's success status directly indicates whether a feasible solution was found, thereby answering the satisfiability question.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef check_satisfiability(n, m, W, b, A, b_ineq, L, U, y, c, gamma):\n    \"\"\"\n    Checks the satisfiability of the SMT query by reducing it to an LP feasibility problem.\n    \"\"\"\n    # By definition of misclassification, the ground truth y must not be the target class c.\n    # If y == c, the condition is not met, thus no such misclassifying input exists.\n    if y == c:\n        return False\n\n    # The goal is to find if a feasible x exists. This is an LP feasibility problem.\n    # We can set a null objective function, e.g., min 0^T * x.\n    # The vector of coefficients for the objective function.\n    c_obj = np.zeros(n)\n\n    # Aggregate all inequality constraints of the form A_ub * x = b_ub\n    A_ub_list = []\n    b_ub_list = []\n\n    # 1. Digital twin constraints: A*x = b_ineq\n    # Handle the case where A might be an empty matrix.\n    if A.shape[0] > 0:\n        A_ub_list.append(A)\n        b_ub_list.append(b_ineq.flatten())\n\n    # 2. Robust misclassification constraints:\n    # For all k != c, w_c^T*x + b_c >= w_k^T*x + b_k + gamma\n    # Rearranging gives: (w_k - w_c)^T*x = b_c - b_k - gamma\n    w_c_row = W[c, :]\n    b_c_val = b[c]\n    for k in range(m):\n        if k == c:\n            continue\n        w_k_row = W[k, :]\n        b_k_val = b[k]\n\n        # Form the inequality (w_k - w_c)^T * x = b_c - b_k - gamma\n        A_row = w_k_row - w_c_row\n        b_val = b_c_val - b_k_val - gamma\n\n        A_ub_list.append(A_row.reshape(1, -1))\n        b_ub_list.append(np.array([b_val]))\n\n    A_ub = None\n    b_ub = None\n    if A_ub_list:\n        A_ub = np.vstack(A_ub_list)\n        b_ub = np.concatenate(b_ub_list)\n\n    # 3. Element-wise bounds: L = x = U\n    # This is handled by the 'bounds' parameter of linprog.\n    # It expects a sequence of (min, max) pairs for each variable.\n    bounds = list(zip(L.flatten(), U.flatten()))\n\n    # Solve the linear programming feasibility problem.\n    # method='highs' is used as it is the recommended solver.\n    # If the problem is feasible, linprog returns success=True.\n    # If it is infeasible, it returns success=False.\n    res = linprog(c=c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n\n    # The satisfiability of the SMT query is equivalent to the feasibility of the LP.\n    return res.success\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (unsatisfiable)\n        {\n            \"n\": 2, \"m\": 3,\n            \"W\": np.array([[1., 0.], [0., 1.], [-1., -1.]]),\n            \"b\": np.array([0., 0., 0.]),\n            \"A\": np.array([[1., 1.], [-1., 0.], [0., -1.]]),\n            \"b_ineq\": np.array([1., 0., 0.]),\n            \"L\": np.array([0., 0.]), \"U\": np.array([1., 1.]),\n            \"y\": 0, \"c\": 2, \"gamma\": 0.1\n        },\n        # Test case 2 (satisfiable)\n        {\n            \"n\": 2, \"m\": 3,\n            \"W\": np.array([[-1., -1.], [1., 0.], [0., 1.]]),\n            \"b\": np.array([0., 0., 0.]),\n            \"A\": np.array([[1., 1.]]), \"b_ineq\": np.array([-0.5]),\n            \"L\": np.array([-1., -1.]), \"U\": np.array([0., 0.]),\n            \"y\": 1, \"c\": 0, \"gamma\": 0.2\n        },\n        # Test case 3 (satisfiable)\n        {\n            \"n\": 3, \"m\": 3,\n            \"W\": np.array([[1., 1., 0.], [0., 1., 1.], [-1., 0., 1.]]),\n            \"b\": np.array([0., 0., 0.5]),\n            \"A\": np.array([[1., 1., 1.]]), \"b_ineq\": np.array([1.5]),\n            \"L\": np.array([0., 0., 0.]), \"U\": np.array([1., 1., 1.]),\n            \"y\": 0, \"c\": 2, \"gamma\": 0.0\n        },\n        # Test case 4 (unsatisfiable by y=c)\n        {\n            \"n\": 1, \"m\": 2,\n            \"W\": np.array([[1.], [2.]]), \"b\": np.array([0., 0.]),\n            \"A\": np.empty((0, 1)), \"b_ineq\": np.empty(0),\n            \"L\": np.array([0.]), \"U\": np.array([1.]),\n            \"y\": 1, \"c\": 1, \"gamma\": 0.0\n        },\n        # Test case 5 (satisfiable)\n        {\n            \"n\": 2, \"m\": 2,\n            \"W\": np.array([[1., 0.], [0., 1.]]), \"b\": np.array([0., 0.]),\n            \"A\": np.array([[1., 1.]]), \"b_ineq\": np.array([1.5]),\n            \"L\": np.array([0., 0.]), \"U\": np.array([1., 1.]),\n            \"y\": 1, \"c\": 0, \"gamma\": 0.5\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        is_sat = check_satisfiability(\n            case[\"n\"], case[\"m\"], case[\"W\"], case[\"b\"], case[\"A\"],\n            case[\"b_ineq\"], case[\"L\"], case[\"U\"], case[\"y\"], case[\"c\"], case[\"gamma\"]\n        )\n        results.append(is_sat)\n\n    # Final print statement in the exact required format.\n    # Outputting booleans as lowercase strings: 'true'/'false'.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Cyber-physical systems operate over time, and their safety specifications often involve temporal constraints, such as ensuring a variable always stays below a threshold. Signal Temporal Logic (STL) provides a formal language for such specifications, and its quantitative semantics allow us to measure *how robustly* a system's behavior satisfies or violates a property. This exercise provides hands-on practice in computing the STL robustness value from a sampled signal trace, a core task in runtime monitoring and offline trace analysis .",
            "id": "4223379",
            "problem": "A digital twin monitors a normalized tracking error signal $x(t)$ generated by a learning-enabled state estimator embedded in a cyber-physical system. The verification task is specified in Signal Temporal Logic (STL) using the formula $\\varphi = \\Box_{[0,5]}(x \\le 1)$, which informally requires that the normalized error remain at or below the threshold $1$ for all times in the interval $[0,5]$. The monitor operates on a sampled signal $x(t_k)$ with event-triggered sampling instants $t_k \\in [0,5]$, and evaluates robustness using the standard quantitative semantics of STL.\n\nThe recorded samples over the interval $[0,5]$ are as follows:\n$t_0 = 0$, $x(t_0) = 0.72$;\n$t_1 = 0.3$, $x(t_1) = 0.88$;\n$t_2 = 0.9$, $x(t_2) = 1.05$;\n$t_3 = 1.4$, $x(t_3) = 0.97$;\n$t_4 = 2.1$, $x(t_4) = 0.91$;\n$t_5 = 2.7$, $x(t_5) = 1.02$;\n$t_6 = 3.2$, $x(t_6) = 0.95$;\n$t_7 = 3.8$, $x(t_7) = 0.89$;\n$t_8 = 4.4$, $x(t_8) = 1.10$;\n$t_9 = 5.0$, $x(t_9) = 0.93$.\n\nUsing the robustness semantics of Signal Temporal Logic for sampled signals and the given data, compute the robustness value of $\\varphi$ over the interval $[0,5]$ by evaluating the minimum margin $1 - x(t_k)$ across all samples $t_k \\in [0,5]$. Express the robustness value as a dimensionless scalar and round your final answer to three significant figures.",
            "solution": "The problem requires the computation of the robustness value for a Signal Temporal Logic (STL) formula, based on a finite set of sampled data from a signal. The validation of the problem statement confirms that it is scientifically grounded, well-posed, and contains all necessary information for a unique solution.\n\nThe STL formula is given as $\\varphi = \\Box_{[0,5]}(x \\le 1)$. This formula consists of a temporal operator, \"Always\" ($\\Box$), applied over the time interval $[0,5]$, and an atomic predicate, $\\mu = (x \\le 1)$.\n\nThe quantitative semantics of STL define a robustness value, denoted by $\\rho(\\varphi, x)$, which measures how strongly a signal $x(t)$ satisfies a formula $\\varphi$. A positive value indicates satisfaction, a negative value indicates violation, and a value of zero indicates satisfaction at the boundary.\n\nThe robustness of an atomic predicate of the form $f(x) \\ge c$ is defined as the value of the expression $f(x) - c$. The predicate $\\mu = (x \\le 1)$ can be rewritten as $1 - x \\ge 0$. Therefore, its robustness at a specific time $t$ is given by:\n$$\n\\rho(\\mu, x, t) = 1 - x(t)\n$$\nThis value represents the margin by which the signal $x(t)$ satisfies the condition $x \\le 1$. If $x(t)  1$, the margin is positive; if $x(t)  1$, the margin is negative.\n\nThe \"Always\" operator, $\\Box_{I}$, asserts that the subformula holds for all time points within the interval $I$. Its robustness is defined as the infimum (or minimum for a finite set of points) of the subformula's robustness over that interval. For the formula $\\varphi = \\Box_{[0,5]}\\mu$, the continuous-time robustness is:\n$$\n\\rho(\\varphi, x) = \\inf_{t \\in [0,5]} \\rho(\\mu, x, t) = \\inf_{t \\in [0,5]} (1 - x(t))\n$$\nThe problem specifies that the monitor operates on a set of discrete samples $\\{ (t_k, x(t_k)) \\}$ where all $t_k \\in [0,5]$. As per the problem's instruction to evaluate a minimum margin across all samples, the robustness computation is performed over this discrete set of points. The infimum operator becomes a minimum operator:\n$$\n\\rho(\\varphi, x) = \\min_{k} (1 - x(t_k))\n$$\nwhere $k$ ranges over all the provided samples.\n\nThis expression can be simplified by noting that the minimum of $1 - x(t_k)$ occurs when $x(t_k)$ is at its maximum.\n$$\n\\min_{k} (1 - x(t_k)) = 1 - \\max_{k} x(t_k)\n$$\nWe are given the following $10$ samples of the signal $x(t)$:\n$x(t_0) = 0.72$\n$x(t_1) = 0.88$\n$x(t_2) = 1.05$\n$x(t_3) = 0.97$\n$x(t_4) = 0.91$\n$x(t_5) = 1.02$\n$x(t_6) = 0.95$\n$x(t_7) = 0.89$\n$x(t_8) = 1.10$\n$x(t_9) = 0.93$\n\nWe must find the maximum value within this set of signal values. By inspection, the maximum value is:\n$$\n\\max_{k} x(t_k) = x(t_8) = 1.10\n$$\nNow, we can compute the robustness value using the derived formula:\n$$\n\\rho(\\varphi, x) = 1 - \\max_{k} x(t_k) = 1 - 1.10 = -0.10\n$$\nThe negative sign indicates that the specification $\\varphi$ is violated. The value $-0.10$ quantifies the extent of this violation; at time $t_8 = 4.4$, the signal $x(t_8)$ exceeded the threshold of $1$ by $0.10$.\n\nThe problem asks for the answer to be rounded to three significant figures. The calculated value is $-0.10$. The first significant figure is the digit $1$. The subsequent zero is also significant. To express this with three significant figures, we write it as $-0.100$.",
            "answer": "$$\n\\boxed{-0.100}\n$$"
        }
    ]
}