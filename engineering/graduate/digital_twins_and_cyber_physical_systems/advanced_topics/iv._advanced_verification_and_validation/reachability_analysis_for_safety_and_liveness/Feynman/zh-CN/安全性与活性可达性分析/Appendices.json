{
    "hands_on_practices": [
        {
            "introduction": "对具有无限状态的赛博物理系统进行验证是一项艰巨的任务。一个核心策略是“抽象”，即将无限的连续状态空间简化为一个有限的离散模型。本练习  将指导您完成这一基本过程，从一个简单的离散时间动力系统出发，通过划分状态空间来构建一个称为克里普克结构（Kripke structure）的有限状态自动机。您将学习如何将连续动态转化为离散转换，并利用这个抽象模型来验证一个基本的安全与活性属性，从而亲身体验连接连续系统与离散模型检验方法的桥梁。",
            "id": "4238602",
            "problem": "考虑一个一维离散时间信息物理系统 (Cyber-Physical System, CPS)，其动力学由 $x_{k+1} = f(x_{k}, u_{k}) = x_{k} + u_{k}$ 给出，其中状态空间为 $X = [0,6]$，控制输入集为 $U = \\{0,1,2\\}$。将 $X$ 划分为以下区域：对于 $i \\in \\{0,1,2,3,4\\}$，定义 $R_{i} = [i, i+1)$，并定义 $R_{5} = [5,6]$。引入原子命题 (Atomic Propositions, AP) 如下：对于每个 $i \\in \\{0,1,2,3,4,5\\}$，$r_{i}$ 表示属于 $R_{i}$；$g$ 表示目标区域 $R_{5}$；$\\mathit{unsafe}$ 表示不安全区域 $R_{3}$；$\\mathit{safe}$ 表示 $X$ 中 $R_{3}$ 的补集。初始区域为 $R_{0}$。使用 Kripke 结构的标准定义 $K = (S, S_{0}, R, AP, L)$，其中 $S$ 是抽象状态的有限集，$S_{0} \\subseteq S$ 是初始状态集，$R \\subseteq S \\times S$ 是由动力学和输入导出的全转移关系，$AP$ 是原子命题的有限集，$L: S \\to 2^{AP}$ 是一个标记函数。\n\n通过令 $S = \\{0,1,2,3,4,5\\}$（其中状态 $i$ 代表区域 $R_{i}$）和 $S_{0} = \\{0\\}$ 来构建有限 Kripke 结构抽象，并定义 $(i,j) \\in R$ 当且仅当存在 $x \\in R_{i}$ 和 $u \\in U$ 使得 $x + u \\in R_{j}$。请使用集合运算，以 $i$ 的形式明确指定 $S$ 上的标记函数 $L$ 的闭式形式。\n\n使用此 Kripke 结构，确定最小离散步数 $k_{\\min}$，使得存在一条从初始状态开始的路径，该路径能到达一个被 $g$ 标记的状态，并且在所有中间步骤中避开所有被 $\\mathit{unsafe}$ 标记的状态。请以单个整数 $k_{\\min}$ 的形式提供您的最终答案。无需四舍五入。",
            "solution": "分析问题陈述后，发现其是有效的。这是信息物理系统可达性分析领域中一个适定问题，它提供了一套完整且一致的定义和约束，用于构建有限抽象并解决一个带安全约束的可达性查询。\n\n任务是为给定的离散时间系统构建一个 Kripke 结构，然后找到从初始区域到达目标区域同时避开不安全区域所需的最小步数 $k_{\\min}$。\n\nKripke 结构 $K = (S, S_{0}, R, AP, L)$ 的组成部分定义如下：\n\n1.  **抽象状态集 $S$**：问题定义了 $S = \\{0, 1, 2, 3, 4, 5\\}$。每个状态 $i \\in S$ 是连续区域 $R_i$ 的一个抽象。\n\n2.  **初始状态集 $S_{0}$**：初始区域是 $R_0$，所以初始抽象状态集是 $S_{0} = \\{0\\}$。\n\n3.  **原子命题集 $AP$**：问题定义了 $AP = \\{r_0, r_1, r_2, r_3, r_4, r_5, g, \\mathit{unsafe}, \\mathit{safe}\\}$。\n\n4.  **标记函数 $L: S \\to 2^{AP}$**：标记函数 $L$ 将每个抽象状态 $i$ 映射到在相应区域 $R_i$ 中为真的原子命题集合。\n    -   如果状态在 $R_i$ 中，$r_i$ 为真。这意味着对于所有 $i \\in S$，$r_i \\in L(i)$。\n    -   对于目标区域 $R_5$，$g$ 为真。这意味着 $g \\in L(5)$。\n    -   对于不安全区域 $R_3$，$\\mathit{unsafe}$ 为真。这意味着 $\\mathit{unsafe} \\in L(3)$。\n    -   对于 $R_3$ 的补集，即区域 $R_0, R_1, R_2, R_4, R_5$，$\\mathit{safe}$ 为真。这意味着对于 $i \\in \\{0, 1, 2, 4, 5\\}$，$\\mathit{safe} \\in L(i)$。\n\n    我们可以为每个状态指定 $L$：\n    -   $L(0) = \\{r_{0}, \\mathit{safe}\\}$\n    -   $L(1) = \\{r_{1}, \\mathit{safe}\\}$\n    -   $L(2) = \\{r_{2}, \\mathit{safe}\\}$\n    -   $L(3) = \\{r_{3}, \\mathit{unsafe}\\}$\n    -   $L(4) = \\{r_{4}, \\mathit{safe}\\}$\n    -   $L(5) = \\{r_{5}, g, \\mathit{safe}\\}$\n\n    使用集合运算和分段定义，对于任何 $i \\in S$ 的闭式形式为：\n    $$ L(i) = \\{r_i\\} \\cup \\begin{cases} \\{g, \\mathit{safe}\\}   \\text{if } i=5 \\\\ \\{\\mathit{unsafe}\\}  \\text{if } i=3 \\\\ \\{\\mathit{safe}\\}  \\text{if } i \\in \\{0, 1, 2, 4\\} \\end{cases} $$\n\n5.  **转移关系 $R \\subseteq S \\times S$**：当且仅当存在一个状态 $x \\in R_i$ 和一个控制输入 $u \\in U$ 使得下一状态 $x_{k+1} = x + u$ 在 $R_j$ 中时，转移 $(i, j) \\in R$ 存在。这等价于检查从 $R_i$ 可达的连续状态集（表示为 $Post(R_i)$）是否与 $R_j$ 有非空交集。\n    从 $R_i$ 可达的连续状态集是 $Post(R_i) = \\{x+u \\mid x \\in R_i, u \\in U\\}$。\n\n    让我们计算每个状态 $i \\in S$ 的转移关系：\n    -   对于 $i \\in \\{0,1,2,3,4\\}$，$R_i = [i, i+1)$，$U=\\{0,1,2\\}$。\n        $Post(R_i) = [i, i+1) + \\{0,1,2\\} = [i, i+1) \\cup [i+1, i+2) \\cup [i+2, i+3) = [i, i+3)$。\n    -   对于 $i=5$，$R_5 = [5,6]$。\n        $Post(R_5) = [5,6] + \\{0,1,2\\} = [5,6] \\cup [6,7] \\cup [7,8] = [5,8]$。\n\n    现在我们检查与 $R_j$ 的交集：\n    -   从状态 $i=0$：$Post(R_0) = [0,3)$。这与 $R_0=[0,1)$、$R_1=[1,2)$ 和 $R_2=[2,3)$ 相交。所以，从状态 $0$ 的转移是到 $\\{0, 1, 2\\}$。\n    -   从状态 $i=1$：$Post(R_1) = [1,4)$。这与 $R_1=[1,2)$、$R_2=[2,3)$ 和 $R_3=[3,4)$ 相交。所以，从状态 $1$ 的转移是到 $\\{1, 2, 3\\}$。\n    -   从状态 $i=2$：$Post(R_2) = [2,5)$。这与 $R_2=[2,3)$、$R_3=[3,4)$ 和 $R_4=[4,5)$ 相交。所以，从状态 $2$ 的转移是到 $\\{2, 3, 4\\}$。\n    -   从状态 $i=3$：$Post(R_3) = [3,6)$。这与 $R_3=[3,4)$、$R_4=[4,5)$ 和 $R_5=[5,6]$ 相交。所以，从状态 $3$ 的转移是到 $\\{3, 4, 5\\}$。\n    -   从状态 $i=4$：$Post(R_4) = [4,7)$。这与 $R_4=[4,5)$ 和 $R_5=[5,6]$ 相交。所以，从状态 $4$ 的转移是到 $\\{4, 5\\}$。\n    -   从状态 $i=5$：$Post(R_5) = [5,8]$。在定义的状态空间内，这只与 $R_5=[5,6]$ 相交。所以，从状态 $5$ 的唯一转移是到其自身 $\\{5\\}$。\n\n    转移关系 $R$ 可以总结为邻接表：\n    -   $0 \\to \\{0, 1, 2\\}$\n    -   $1 \\to \\{1, 2, 3\\}$\n    -   $2 \\to \\{2, 3, 4\\}$\n    -   $3 \\to \\{3, 4, 5\\}$\n    -   $4 \\to \\{4, 5\\}$\n    -   $5 \\to \\{5\\}$\n\n现在，我们必须找到到达一个被 $g$ 标记的状态同时避开所有被 $\\mathit{unsafe}$ 标记的状态所需的最小离散步数 $k_{\\min}$。\n-   初始状态：$s_0 = 0$。\n-   目标状态 (用 $g$ 标记)：$S_g = \\{5\\}$。\n-   不安全状态 (用 $\\mathit{unsafe}$ 标记)：$S_u = \\{3\\}$。\n\n问题是在由 $(S, R)$ 定义的图中找到从状态 $0$ 到状态 $5$ 的最短路径，使得路径上没有中间状态在 $S_u$ 中。我们可以通过在“安全”子图上执行广度优先搜索 (BFS) 来解决这个问题，该子图是通过移除不安全状态 $S_u=\\{3\\}$ 及其所有关联边得到的。\n\n安全状态集是 $S_{\\mathit{safe}} = S \\setminus S_u = \\{0, 1, 2, 4, 5\\}$。\n安全转移关系 $R_{\\mathit{safe}}$ 只包含 $S_{\\mathit{safe}}$ 中状态之间的转移：\n-   从 $0$：$\\{0, 1, 2\\}$ 都是安全的。\n-   从 $1$：邻居是 $\\{1, 2, 3\\}$。安全邻居是 $\\{1, 2\\}$。\n-   从 $2$：邻居是 $\\{2, 3, 4\\}$。安全邻居是 $\\{2, 4\\}$。\n-   从 $4$：邻居是 $\\{4, 5\\}$。两者都是安全的。\n-   从 $5$：邻居是 $\\{5\\}$，是安全的。\n\n安全转移关系 $R_{\\mathit{safe}}$ 是：\n-   $0 \\to \\{0, 1, 2\\}$\n-   $1 \\to \\{1, 2\\}$\n-   $2 \\to \\{2, 4\\}$\n-   $4 \\to \\{4, 5\\}$\n-   $5 \\to \\{5\\}$\n\n我们从 $s_0=0$ 开始执行 BFS，以找到到 $S_g=\\{5\\}$ 的最短路径：\n-   **步骤 $k=0$**：队列用起始状态初始化。$Q = [0]$。已访问状态集为 $V=\\{0\\}$。\n-   **步骤 $k=1$**：将 $0$ 出队。其邻居为 $\\{0, 1, 2\\}$。\n    -   $0$ 已在 $V$ 中。\n    -   将 $1$ 添加到 $Q$ 和 $V$。\n    -   将 $2$ 添加到 $Q$ 和 $V$。\n    -   $Q=[1, 2]$，$V=\\{0, 1, 2\\}$。到状态 $1$ 和 $2$ 的距离为 $1$。\n-   **步骤 $k=2$**：\n    -   将 $1$ 出队。其邻居为 $\\{1, 2\\}$，都已在 $V$ 中。\n    -   将 $2$ 出队。其邻居为 $\\{2, 4\\}$。\n        -   $2$ 在 $V$ 中。\n        -   将 $4$ 添加到 $Q$ 和 $V$。\n    -   $Q=[4]$，$V=\\{0, 1, 2, 4\\}$。到状态 $4$ 的距离为 $2$。一条路径是 $0 \\to 2 \\to 4$。\n-   **步骤 $k=3$**：\n    -   将 $4$ 出队。其邻居为 $\\{4, 5\\}$。\n        -   $4$ 在 $V$ 中。\n        -   状态 $5$ 是目标状态。我们已经找到了最短路径。\n    -   路径长度为 $3$。一条可能的路径是 $0 \\to 2 \\to 4 \\to 5$。\n\n最小离散步数为 $3$。这对应于一个控制序列。例如：\n1.  从 $R_0$ 开始，应用 $u=2$。如果 $x_0 \\in [0,1)$，则 $x_1 = x_0+2 \\in [2,3) = R_2$。（步骤 1，状态为 $2$）\n2.  从 $R_2$ 开始，应用 $u=2$。如果 $x_1 \\in [2,3)$，则 $x_2 = x_1+2 \\in [4,5) = R_4$。（步骤 2，状态为 $4$）\n3.  从 $R_4$ 开始，应用 $u=1$。如果 $x_2 \\in [4,5)$，则 $x_3 = x_2+1 \\in [5,6) \\subseteq R_5$。（步骤 3，状态为 $5$，到达目标）\n\n最小步数 $k_{\\min}$ 为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "虽然抽象是验证的有力工具，但它有时会引入不必要的保守性。因此，直接处理连续状态集的方法在许多应用中更为精确。对于线性系统，支持函数（support functions）为表示和演化凸集（如可达集）提供了一个极其强大的框架。本编码练习  将这一优雅的理论付诸实践。您将遵循变分法公式，实现一个数值算法，用于计算连续时间线性系统的可达集支持函数，这是许多现代验证工具的基石。",
            "id": "4238587",
            "problem": "在信息物理系统 (Cyber-Physical Systems, CPS) 的数字孪生 (Digital Twin, DT) 模型背景下，给定一个线性时不变连续时间系统。其状态根据常微分方程 $\\dot{x} = A x + B u$ 演化，其中 $x \\in \\mathbb{R}^n$ 是状态， $u \\in \\mathbb{R}^m$ 是控制输入，取值于一个紧凸集 $U \\subset \\mathbb{R}^m$，$A \\in \\mathbb{R}^{n \\times n}$，$B \\in \\mathbb{R}^{n \\times m}$。初始状态属于一个紧凸集 $X_0 \\subset \\mathbb{R}^n$。目标是使用从基本事实推导出的有原则的构造方法，不使用任何捷径，计算在固定时间 $t$、给定方向 $l \\in \\mathbb{R}^n$ 上可达集的支撑函数。\n\n您必须使用的基本原理仅限于以下内容：\n- 线性常微分方程的常数变易解：对于任意 $t \\ge 0$，解满足 $x(t) = e^{A t} x(0) + \\int_0^t e^{A (t - \\tau)} B u(\\tau)\\, d\\tau$。\n- 紧凸集的支撑函数定义：对于任意紧凸集 $S \\subset \\mathbb{R}^k$，在方向 $l \\in \\mathbb{R}^k$ 上的支撑函数为 $h_S(l) = \\sup_{s \\in S} \\langle l, s \\rangle$。\n- 集合的 Minkowski 和及其基本性质。\n\n您必须实现一个方法，给定 $(A,B)$、$X_0$、$U$、$t$ 和 $l$，基于“凸集在线性算子和 Minkowski 积分下的像通过其支撑函数来处理”这一原理，返回在时间 $t$、方向 $l$ 上凸可达集支撑函数的数值近似值。您的算法必须仅依赖于这些原理和支撑函数的定义。除了这些基本原理外，您不得调用任何捷径公式或预先提供的结果。\n\n在您的实现中，您必须处理以下任一凸表示形式指定的输入集 $U$：\n- 由下界和上界 $[u_{\\min}, u_{\\max}] \\subset \\mathbb{R}^m$ 指定的盒集，其中 $u_{\\min}, u_{\\max} \\in \\mathbb{R}^m$ 且 $u_{\\min} \\le u_{\\max}$（分量比较）。\n- 以原点为中心、半径为 $r \\in \\mathbb{R}_{\\ge 0}$ 的欧几里得球，即 $\\{u \\in \\mathbb{R}^m : \\|u\\|_2 \\le r\\}$。\n- 由有限顶点集 $\\{v_i\\}_{i=1}^N \\subset \\mathbb{R}^m$ 指定的凸多胞体，其凸包为 $U$。\n\n您还必须处理以下任一凸表示形式指定的初始集 $X_0$：\n- 由下界和上界 $[x_{\\min}, x_{\\max}] \\subset \\mathbb{R}^n$ 指定的盒集。\n- 以原点为中心、半径为 $r_0 \\in \\mathbb{R}_{\\ge 0}$ 的欧几里得球。\n- 由 $\\mathbb{R}^n$ 中的有限顶点集指定的凸多胞体。\n\n您的数值方法应使用有原则的数值积分法则来近似由于 $U$ 对可达集的贡献而产生的时间积分。此问题不涉及角度，也不需要物理单位，因为问题是纯数学的。每个测试用例的输出必须是单个实数（浮点数），即在指定方向上的支撑函数值。\n\n测试套件：\n对于每个测试用例，计算给定 $(A,B)$、$X_0$ 和 $U$ 在指定时间 $t$ 和方向 $l$ 上的支撑函数。使用以下五个测试用例：\n\n- 测试用例 1（正常路径，二维稳定系统，非对称盒集输入）：\n  - $A = \\begin{bmatrix} -0.5   0.2 \\\\ -0.1   -0.3 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1   0 \\\\ 0   1 \\end{bmatrix}$,\n  - $X_0$ 是一个盒集，其中 $x_{\\min} = \\begin{bmatrix} -0.5 \\\\ -0.5 \\end{bmatrix}$ 且 $x_{\\max} = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$,\n  - $U$ 是一个盒集，其中 $u_{\\min} = \\begin{bmatrix} -1.0 \\\\ -0.5 \\end{bmatrix}$ 且 $u_{\\max} = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix}$,\n  - $t = 1.0$,\n  - $l = \\begin{bmatrix} 1.0 \\\\ -0.5 \\end{bmatrix}$.\n\n- 测试用例 2（边界情况：零输入集，仅初始集传播）：\n  - $A = \\begin{bmatrix} -0.5   0.2 \\\\ -0.1   -0.3 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1   0 \\\\ 0   1 \\end{bmatrix}$,\n  - $X_0$ 是一个盒集，其中 $x_{\\min} = \\begin{bmatrix} -1.0 \\\\ -1.0 \\end{bmatrix}$ 且 $x_{\\max} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$,\n  - $U$ 是单点集 $\\{0\\}$，表示为 $u_{\\min} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ 且 $u_{\\max} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ 的盒集,\n  - $t = 2.0$,\n  - $l = \\begin{bmatrix} 0.3 \\\\ 0.4 \\end{bmatrix}$.\n\n- 测试用例 3（边缘情况：二维不稳定系统，球输入，零初始集）：\n  - $A = \\begin{bmatrix} 0.4   0.6 \\\\ 0.0   0.2 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1   0 \\\\ 0   1 \\end{bmatrix}$,\n  - $X_0$ 是单点集 $\\{0\\}$，表示为 $x_{\\min} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ 且 $x_{\\max} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ 的盒集,\n  - $U$ 是 $\\mathbb{R}^2$ 中半径为 $r = 0.2$、以原点为中心的欧几里得球,\n  - $t = 0.5$,\n  - $l = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n\n- 测试用例 4（一维系统，区间输入，零初始集）：\n  - $A = \\begin{bmatrix} -1.0 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1.0 \\end{bmatrix}$,\n  - $X_0$ 是单点集 $\\{0\\}$，表示为 $x_{\\min} = \\begin{bmatrix} 0.0 \\end{bmatrix}$ 且 $x_{\\max} = \\begin{bmatrix} 0.0 \\end{bmatrix}$ 的盒集,\n  - $U$ 是一个盒集（区间），其中 $u_{\\min} = \\begin{bmatrix} 0.0 \\end{bmatrix}$ 且 $u_{\\max} = \\begin{bmatrix} 1.0 \\end{bmatrix}$,\n  - $t = 1.5$,\n  - $l = \\begin{bmatrix} 1.0 \\end{bmatrix}$.\n\n- 测试用例 5（三维稳定系统，球初始集，多胞体输入）：\n  - $A = \\begin{bmatrix} -0.2   0.1   0.0 \\\\ 0.0   -0.3   0.2 \\\\ 0.0   0.0   -0.1 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1.0   0.0 \\\\ 0.0   1.0 \\\\ 0.5   0.5 \\end{bmatrix}$,\n  - $X_0$ 是 $\\mathbb{R}^3$ 中半径为 $r_0 = 0.1$、以原点为中心的欧几里得球,\n  - $U$ 是 $\\mathbb{R}^2$ 中的一个凸多胞体，顶点为 $\\{ \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\begin{bmatrix} -1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ -1 \\end{bmatrix} \\}$,\n  - $t = 2.0$,\n  - $l = \\begin{bmatrix} 0.5 \\\\ -0.5 \\\\ 1.0 \\end{bmatrix}$.\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。对于上述五个测试用例，预期的输出格式为 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_i$ 是在指定时间、指定方向上为测试用例 $i$ 计算出的支撑函数值（一个浮点数）。不应打印任何其他文本。",
            "solution": "在尝试任何解决方案之前，需对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **系统动力学**：一个线性时不变连续时间系统，由常微分方程 (ODE) $\\dot{x} = A x + B u$ 描述。\n- **状态和输入**：状态为 $x \\in \\mathbb{R}^n$，控制输入为 $u \\in \\mathbb{R}^m$。\n- **状态集和输入集**：初始状态 $x(0)$ 位于一个紧凸集 $X_0 \\subset \\mathbb{R}^n$ 中。对于 $\\tau \\ge 0$，控制输入 $u(\\tau)$ 的取值范围为一个紧凸集 $U \\subset \\mathbb{R}^m$。\n- **系统矩阵**：$A \\in \\mathbb{R}^{n \\times n}$ 和 $B \\in \\mathbb{R}^{n \\times m}$。\n- **基本原理**：\n    1.  **常数变易解**：对于任意 $t \\ge 0$，ODE 的解为 $x(t) = e^{A t} x(0) + \\int_0^t e^{A (t - \\tau)} B u(\\tau)\\, d\\tau$。\n    2.  **支撑函数定义**：对于一个紧凸集 $S \\subset \\mathbb{R}^k$，其在方向 $l \\in \\mathbb{R}^k$ 上的支撑函数为 $h_S(l) = \\sup_{s \\in S} \\langle l, s \\rangle$。\n    3.  **Minkowski 和**：问题要求了解集合的 Minkowski 和及其基本性质。\n- **目标**：计算在固定时间 $t$、给定方向 $l \\in \\mathbb{R}^n$ 上可达集的支撑函数。\n- **集合表示**：\n    - $X_0$ 和 $U$ 可以是盒集（超矩形）、以原点为中心的欧几里得球，或由其顶点定义的凸多胞体。\n- **数值方法**：实现必须使用有原则的数值积分法则来近似时间积分。\n- **测试用例**：提供了五个具体的测试用例，包括矩阵 $A, B$、集合 $X_0$ 和 $U$ 的定义、时间 $t$ 和方向 $l$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学或事实上的不健全性**：该问题在科学和数学上是健全的。它基于线性系统理论和凸分析的基本概念。常数变易公式是线性 ODE 的正确解。支撑函数的定义和可达集的概念是控制理论和计算几何中的标准内容。所有原理在事实上都是正确的。\n2.  **不可形式化或不相关**：该问题是高度形式化的，并且与信息物理系统的可达性分析领域直接相关，这是指定领域的核心主题。\n3.  **不完整或矛盾的设置**：该问题是自洽的。对于每个测试用例，它都提供了所有必要的组件：系统矩阵 ($A, B$)、初始集和输入集的定义 ($X_0, U$)、时间范围 ($t$) 和方向向量 ($l$)。集合的规范是完整且明确的。\n4.  **不切实际或不可行**：所提供的矩阵和集合参数在数学上是良定义的，在问题的抽象数学框架内不代表物理上不可能或不一致的场景。\n5.  **不适定或结构不良**：该问题是适定的。对于具有紧凸初始集和输入集的 LTI 系统，任何时间 $t$ 的可达集也是紧凸的。对于任何给定的方向，紧集的支撑函数是良定义且唯一的。\n6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎。它要求从第一性原理出发推导解决方案，结合了线性代数、微分方程和凸分析的概念。它需要一个非平凡的数值实现。测试用例涵盖了一系列场景（稳定/不稳定、不同集合类型、退化情况），用于测试所推导方法的鲁棒性。\n7.  **超出科学可验证性范围**：该问题完全是数学问题，其结果可以通过解析计算（对于像测试用例 4 这样的简单情况）或与已建立的数值可达性工具进行比较来验证。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。它在科学上是健全的，适定的，并且提供了所有必要的信息。将基于规定的第一性原理构建解决方案。\n\n### 求解推导\n目标是计算在时间 $t$ 的可达集 $R(t)$ 在给定方向 $l \\in \\mathbb{R}^n$ 上的支撑函数。待计算的值为 $h_{R(t)}(l)$。\n\n可达集 $R(t)$ 是所有状态 $x(t)$ 的集合，这些状态是 ODE $\\dot{x} = A x + B u$ 的解，其中初始状态 $x(0) \\in X_0$，且可测控制输入函数 $u(\\cdot)$ 满足对于所有 $\\tau \\in [0, t]$ 都有 $u(\\tau) \\in U$。\n\n使用提供的常数变易公式，任何这样的状态 $x(t)$ 都可以写成：\n$$x(t) = e^{A t} x(0) + \\int_0^t e^{A (t - \\tau)} B u(\\tau)\\, d\\tau$$\n\n所有这些点 $x(t)$ 的集合可以使用集合论运算来表示。第一项 $e^{A t} x(0)$ 对应于初始集 $X_0$ 的线性变换。我们将这个变换后的集合表示为 $e^{A t} X_0 = \\{e^{A t} x_0 \\mid x_0 \\in X_0\\}$。\n\n第二项，即积分项，代表了控制输入的贡献。考虑到所有允许的控制函数 $u(\\cdot)$，该积分所有可能值的集合是时变集 $e^{A(t-\\tau)}BU$ 的 Minkowski 积分。这可以写作 $\\int_0^t e^{A (t - \\tau)} B U \\, d\\tau$。\n\n总可达集 $R(t)$ 是这两个集合的 Minkowski 和：\n$$R(t) = e^{A t} X_0 \\oplus \\int_0^t e^{A (t - \\tau)} B U \\, d\\tau$$\n其中 $\\oplus$ 表示 Minkowski 和，$S_1 \\oplus S_2 = \\{s_1 + s_2 \\mid s_1 \\in S_1, s_2 \\in S_2\\}$。\n\n支撑函数的一个基本性质是它们在 Minkowski 和上的可加性：$h_{S_1 \\oplus S_2}(l) = h_{S_1}(l) + h_{S_2}(l)$。将此性质应用于 $R(t)$ 的表达式：\n$$h_{R(t)}(l) = h_{e^{A t} X_0}(l) + h_{\\int_0^t e^{A (t - \\tau)} B U \\, d\\tau}(l)$$\n\n我们现在根据提供的第一性原理分别分析每一项。\n\n**第一项：来自初始集 $X_0$ 的贡献**\n第一项是集合 $X_0$ 线性变换后的支撑函数。对于任何线性映射 $M$ 和紧凸集 $S$，支撑函数满足 $h_{M S}(l) = h_S(M^T l)$。在我们的例子中，线性映射是 $M = e^{A t}$。其转置是 $M^T = (e^{A t})^T = e^{A^T t}$。\n因此，第一项变为：\n$$h_{e^{A t} X_0}(l) = h_{X_0}((e^{A t})^T l)$$\n\n**第二项：来自输入集 $U$ 的贡献**\n第二项是 Minkowski 积分的支撑函数。对于一个时变紧凸集 $K(\\tau)$，其 Minkowski 积分的支撑函数是其支撑函数的积分：$h_{\\int_0^t K(\\tau) d\\tau}(l) = \\int_0^t h_{K(\\tau)}(l) d\\tau$。\n在我们的例子中，$K(\\tau) = e^{A (t - \\tau)} B U$。这个集合的支撑函数由以下公式给出：\n$$h_{K(\\tau)}(l) = h_{e^{A (t - \\tau)} B U}(l)$$\n再次使用线性变换的性质，令 $M = e^{A (t - \\tau)} B$，我们有：\n$$h_{e^{A (t - \\tau)} B U}(l) = h_U((e^{A (t - \\tau)} B)^T l) = h_U(B^T (e^{A (t-\\tau)})^T l) = h_U(B^T e^{A^T (t-\\tau)} l)$$\n将此表达式从 $\\tau=0$ 到 $t$ 积分，得到第二项：\n$$h_{\\int_0^t e^{A (t - \\tau)} B U \\, d\\tau}(l) = \\int_0^t h_U(B^T e^{A^T (t-\\tau)} l) \\, d\\tau$$\n\n**最终公式和数值实现**\n结合两项，我们得到可达集支撑函数的精确公式：\n$$h_{R(t)}(l) = h_{X_0}((e^{A t})^T l) + \\int_0^t h_U(B^T e^{A^T (t-\\tau)} l) \\, d\\tau$$\n\n为了进行数值计算，通过变量替换来简化积分。令 $s = t - \\tau$。则 $ds = -d\\tau$。积分限从 $\\tau \\in [0, t]$ 变为 $s \\in [t, 0]$。\n$$\\int_0^t h_U(B^T e^{A^T (t-\\tau)} l) \\, d\\tau = \\int_t^0 h_U(B^T e^{A^T s} l) \\, (-ds) = \\int_0^t h_U(B^T e^{A^T s} l) \\, ds$$\n\n使用梯形法则来近似该积分。我们将区间 $[0, t]$ 离散化为 $N_{steps}$ 个宽度为 $\\Delta s = t / N_{steps}$ 的段。网格点为 $s_k = k \\Delta s$，其中 $k = 0, 1, \\dots, N_{steps}$。该积分近似为：\n$$\\int_0^t g(s) ds \\approx \\Delta s \\left( \\frac{g(s_0) + g(s_{N_{steps}})}{2} + \\sum_{k=1}^{N_{steps}-1} g(s_k) \\right)$$\n其中被积函数为 $g(s) = h_U(B^T e^{A^T s} l)$。\n\n**特定集合的支撑函数实现**\n\n计算需要评估特定集合表示的支撑函数 $h_{X_0}$ 和 $h_U$。设 $S$ 是一个通用的紧凸集，$v$ 是一个方向向量。\n\n1.  **盒集**：$S = \\{s \\mid s_{\\min} \\le s \\le s_{\\max}\\}$，其中向量不等式是分量比较的。\n    $h_S(v) = \\sup_{s \\in S} \\langle v, s \\rangle = \\sup_{s_{\\min} \\le s \\le s_{\\max}} \\sum_i v_i s_i$。当 $v_i \\ge 0$ 时选择 $s_i = s_{i, \\max}$，当 $v_i  0$ 时选择 $s_i = s_{i, \\min}$，可以达到上确界。\n    $$h_S(v) = \\sum_{i:v_i \\ge 0} v_i s_{i, \\max} + \\sum_{i:v_i  0} v_i s_{i, \\min}$$\n\n2.  **欧几里得球**：$S = \\{s \\in \\mathbb{R}^k : \\|s\\|_2 \\le r\\}$。\n    $h_S(v) = \\sup_{\\|s\\|_2 \\le r} \\langle v, s \\rangle$。根据柯西-施瓦茨不等式，这个上确界是 $r \\|v\\|_2$，当 $s$ 与 $v$ 平行时达到。\n    $$h_S(v) = r \\|v\\|_2$$\n\n3.  **凸多胞体**：$S = \\text{conv}(\\{p_1, \\dots, p_N\\})$，一个有限顶点集的凸包。\n    线性函数在凸多胞体上的最大值在其中一个顶点上达到。\n    $$h_S(v) = \\max_{i \\in \\{1, \\dots, N\\}} \\langle v, p_i \\rangle$$\n\n算法通过计算 $X_0$ 的项，然后数值计算 $U$ 项的积分，最后将结果相加来进行。这种有原则的方法严格遵守了问题的约束。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the reachability problem for the five test cases.\n    \"\"\"\n\n    def support_function(set_spec, direction):\n        \"\"\"\n        Computes the support function for a given set and direction.\n\n        Args:\n            set_spec: A tuple (type, params) describing the set.\n            direction: The direction vector l.\n\n        Returns:\n            The value of the support function.\n        \"\"\"\n        set_type, params = set_spec\n        \n        if direction.ndim == 0:\n            direction = np.array([direction])\n\n        if set_type == 'box':\n            min_bounds, max_bounds = params\n            # s_i is max_bounds_i if direction_i = 0, else min_bounds_i\n            s_star = np.where(direction = 0, max_bounds, min_bounds)\n            return np.dot(direction, s_star)\n        \n        elif set_type == 'ball':\n            radius = params\n            norm_direction = np.linalg.norm(direction)\n            if norm_direction == 0:\n                return 0.0\n            return radius * norm_direction\n\n        elif set_type == 'polytope':\n            vertices = params\n            if not vertices:\n                return 0.0\n            # sup over s in Conv(V) is max over v in V\n            return max(np.dot(v, direction) for v in vertices)\n        \n        else:\n            raise ValueError(f\"Unknown set type: {set_type}\")\n\n    def compute_reachable_set_support_function(A, B, X0_spec, U_spec, t, l, n_steps=2000):\n        \"\"\"\n        Computes the support function of the reachable set R(t) in direction l.\n\n        Args:\n            A, B: System matrices.\n            X0_spec: Specification for the initial set X0.\n            U_spec: Specification for the input set U.\n            t: Time horizon.\n            l: Direction vector.\n            n_steps: Number of steps for numerical integration.\n\n        Returns:\n            The value h_R(t)(l).\n        \"\"\"\n        # Term 1: Contribution from the initial set X0\n        # h_{exp(At)X0}(l) = h_{X0}(exp(A.T*t) @ l)\n        exp_At_T = expm(A.T * t)\n        l_prime_x0 = exp_At_T @ l\n        h_x0_term = support_function(X0_spec, l_prime_x0)\n        \n        # Term 2: Contribution from the input set U (integral term)\n        # integral from 0 to t of h_U(B.T @ exp(A.T*s) @ l) ds\n        # Use trapezoidal rule for numerical integration.\n        # Change of variables s = t - tau makes it integral from 0 to t.\n        \n        h_u_integral = 0.0\n        if t  0:\n            ds = t / n_steps\n            integrand_values = []\n            \n            for k in range(n_steps + 1):\n                s = k * ds\n                exp_As_T = expm(A.T * s)\n                l_prime_u = B.T @ exp_As_T @ l\n                integrand_value = support_function(U_spec, l_prime_u)\n                integrand_values.append(integrand_value)\n            \n            # Trapezoidal rule: ds * ( (f(0)+f(t))/2 + sum(f(s_k)) for k=1..n-1 )\n            h_u_integral = ds * ( (integrand_values[0] + integrand_values[-1]) / 2.0 + sum(integrand_values[1:-1]) )\n\n        return h_x0_term + h_u_integral\n\n    test_cases = [\n        { # Test case 1\n            \"A\": np.array([[-0.5, 0.2], [-0.1, -0.3]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"X0_spec\": ('box', (np.array([-0.5, -0.5]), np.array([0.5, 0.5]))),\n            \"U_spec\": ('box', (np.array([-1.0, -0.5]), np.array([1.0, 0.5]))),\n            \"t\": 1.0,\n            \"l\": np.array([1.0, -0.5])\n        },\n        { # Test case 2\n            \"A\": np.array([[-0.5, 0.2], [-0.1, -0.3]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"X0_spec\": ('box', (np.array([-1.0, -1.0]), np.array([1.0, 1.0]))),\n            \"U_spec\": ('box', (np.array([0.0, 0.0]), np.array([0.0, 0.0]))),\n            \"t\": 2.0,\n            \"l\": np.array([0.3, 0.4])\n        },\n        { # Test case 3\n            \"A\": np.array([[0.4, 0.6], [0.0, 0.2]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"X0_spec\": ('box', (np.array([0.0, 0.0]), np.array([0.0, 0.0]))),\n            \"U_spec\": ('ball', 0.2),  # radius 0.2\n            \"t\": 0.5,\n            \"l\": np.array([1.0, 1.0])\n        },\n        { # Test case 4\n            \"A\": np.array([[-1.0]]),\n            \"B\": np.array([[1.0]]),\n            \"X0_spec\": ('box', (np.array([0.0]), np.array([0.0]))),\n            \"U_spec\": ('box', (np.array([0.0]), np.array([1.0]))),\n            \"t\": 1.5,\n            \"l\": np.array([1.0])\n        },\n        { # Test case 5\n            \"A\": np.array([[-0.2, 0.1, 0.0], [0.0, -0.3, 0.2], [0.0, 0.0, -0.1]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0], [0.5, 0.5]]),\n            \"X0_spec\": ('ball', 0.1), # radius 0.1\n            \"U_spec\": ('polytope', [\n                np.array([1.0, 0.0]), np.array([0.0, 1.0]),\n                np.array([-1.0, 0.0]), np.array([0.0, -1.0])\n            ]),\n            \"t\": 2.0,\n            \"l\": np.array([0.5, -0.5, 1.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_reachable_set_support_function(\n            case[\"A\"], case[\"B\"], case[\"X0_spec\"], case[\"U_spec\"], case[\"t\"], case[\"l\"]\n        )\n        results.append(f\"{result:.7f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "验证非线性系统的安全性是一个重大挑战，因为线性方法通常不再适用。为了应对这一挑战，我们需要更强大的技术，例如障碍证书（barrier certificates）。障碍证书是一个函数，它能证明系统轨迹无法穿越某个“屏障”进入不安全区域。本练习  介绍了如何通过平方和（Sum-of-Squares, SOS）规划这一前沿技术来寻找多项式系统的障碍证书。您将学习如何将一个安全验证问题转化为一个凸优化问题，并编写代码来构建和求解一个简单的SOS程序，从而揭示这一现代控制与机器人学中关键范式的神秘面纱。",
            "id": "4238645",
            "problem": "考虑由常微分方程 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})$ 定义的平面多项式系统，其中 $\\mathbf{x} = (x,y) \\in \\mathbb{R}^2$，$\\mathbf{f}$ 是一个多项式向量场。圆形障碍物由集合 $\\mathcal{O} = \\{(x,y) \\in \\mathbb{R}^2 : (x - c_x)^2 + (y - c_y)^2 \\leq R^2\\}$ 指定，其中 $c_x, c_y \\in \\mathbb{R}$ 为给定常数且 $R  0$。设候选屏障多项式为 $B(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2$，并定义安全集 $\\mathcal{S} = \\{(x,y) \\in \\mathbb{R}^2 : B(x,y) \\geq 0\\}$，即障碍物的外部区域。\n\n在可达性分析中，屏障证书的目的是保证从 $\\mathcal{S}$ 内开始的轨迹永远不会进入 $\\mathcal{O}$ 的内部。保证 $\\mathcal{S}$ 前向不变性的一个标准充分条件是边界条件 $\\nabla B(x,y) \\cdot \\mathbf{f}(x,y) \\geq 0$ 对所有满足 $B(x,y) = 0$ 的 $(x,y)$ 成立。为通过多项式优化来强制满足此不等式，可以采用平方和 (SOS) 规划。具体来说，如果存在一个多项式 $\\lambda(x,y)$，使得多项式\n$$\np(x,y) \\triangleq \\nabla B(x,y) \\cdot \\mathbf{f}(x,y) - \\lambda(x,y) B(x,y)\n$$\n是一个平方和多项式，那么在边界 $B(x,y) = 0$ 上，就有 $\\nabla B(x,y) \\cdot \\mathbf{f}(x,y) \\geq 0$。平方和条件等价于存在一个关于适当单项式基的 $p(x,y)$ 的半正定格拉姆矩阵 (Gram matrix) 表示。对于二元二次多项式，可以使用基向量 $v(x,y) = [1, x, y]^\\top$，并寻找一个对称矩阵 $G \\succeq 0$，使得 $p(x,y) = v(x,y)^\\top G v(x,y)$。\n\n您的任务是编写一个程序，对下面的每个测试用例，构建一个针对标量搜索变量 $\\lambda \\in \\mathbb{R}$（限制为常数，即0次）的 SOS 程序，并判断是否存在一个 $\\lambda$ 值使得 $p(x,y)$ 是一个 SOS 多项式。该判断必须基于二次多项式的格拉姆矩阵方法，通过将 $p(x,y)$ 的多项式系数与由 $v(x,y)^\\top G v(x,y)$ 生成的系数相等，并验证得到的对称矩阵 $G$ 是否为半正定矩阵。由于 $B(x,y)$ 是二次的，并且测试套件中考虑的 $\\mathbf{f}(x,y)$ 是次数至多为一的多项式，因此当 $\\lambda$ 为常数时，多项式 $p(x,y)$ 保证是二次的；因此，使用基 $v(x,y) = [1,x,y]^\\top$ 的格拉姆矩阵方法是适用的。您必须在下面指定的有限网格上搜索 $\\lambda$。\n\n基本原理：\n- 用于前向不变性的屏障证书条件依赖于这样一个事实：如果方向导数 $\\dot{B}(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y)$ 在边界 $B(x,y) = 0$ 上非负，则轨迹无法从 $\\mathcal{S}$ 进入 $B(x,y)  0$ 的区域。\n- 平方和 (SOS) 多项式是可以写成有限个多项式平方之和的多项式。对于变量为 $x$ 和 $y$ 的二次多项式，其 SOS 属性等价于存在一个半正定格拉姆矩阵 $G$，使得该多项式可以写为 $v^\\top G v$ 的形式，其中 $v = [1,x,y]^\\top$。\n\n对于每个测试用例，您必须实现以下步骤：\n1. 构造屏障多项式 $B(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2$ 及其梯度 $\\nabla B(x,y)$。\n2. 按照测试用例的指定定义多项式向量场 $\\mathbf{f}(x,y)$。\n3. 对于标量 $\\lambda$，构造多项式 $p(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y) - \\lambda B(x,y)$。\n4. 对于区间 $[-10, 10]$ 内以 $0.05$ 为均匀增量的 $\\lambda$ 值网格，通过构建与二次型 $v^\\top G v$ 相对应的格拉姆矩阵 $G$（使其系数与 $p(x,y)$ 的系数匹配），并验证 $G$ 是否为半正定，来检查 $p(x,y)$ 是否为 SOS。\n5. 返回一个布尔值，指示网格上是否存在任何 $\\lambda$ 使得 $p(x,y)$ 成为一个 SOS 多项式。必须通过检查其所有特征值在数值容差内均为非负来证明 $G$ 是半正定的。\n\n测试套件规范：\n- 测试用例 1 (正常情况): $c_x = 0$, $c_y = 0$, $R = 1$, $\\mathbf{f}(x,y) = \\nabla B(x,y)$。\n- 测试用例 2 (边界情况): $c_x = 0$, $c_y = 0$, $R = 1$, $\\mathbf{f}(x,y) = J \\nabla B(x,y)$，其中 $J = \\begin{bmatrix} 0   -1 \\\\ 1   0 \\end{bmatrix}$ 是一个对向量场进行 $90^\\circ$（弧度）旋转的旋转矩阵，即 $J \\nabla B(x,y) = (-(\\partial B/\\partial y), \\partial B/\\partial x)$。\n- 测试用例 3 (重要边缘情况): $c_x = 0$, $c_y = 0$, $R = 1$, $\\mathbf{f}(x,y) = -\\nabla B(x,y)$。\n- 测试用例 4 (平移障碍物，一般情况): $c_x = 1$, $c_y = -0.5$, $R = 0.75$, $\\mathbf{f}(x,y) = \\nabla B(x,y) + J \\nabla B(x,y)$。\n\n答案规范：\n- 对于每个测试用例，输出一个布尔值，指示在指定网格中是否存在一个常数 $\\lambda$ 使得 $p(x,y)$ 是 SOS。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3,result4]\"）。\n- 输出中不得报告任何物理单位或角度；所有计算都纯粹是多项式和代数的。\n- 程序必须是完整且可运行的，使用针对二次多项式的格拉姆矩阵测试，并完全按照规定执行 $\\lambda$ 网格搜索。",
            "solution": "我们从连续时间动力学系统背景下的前向不变性屏障证书条件开始。令 $\\mathbf{x}(t)$ 满足 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})$，并设 $B(\\mathbf{x})$ 是一个连续可微的标量函数。如果要求集合 $\\mathcal{S} = \\{\\mathbf{x} : B(\\mathbf{x}) \\geq 0\\}$ 是前向不变的，一个基于生存理论 (viability theory) 和 Nagumo 关于微分包含的定理的充分条件是，方向导数在边界 $\\{\\mathbf{x} : B(\\mathbf{x}) = 0\\}$ 上满足 $\\dot{B}(\\mathbf{x}) = \\nabla B(\\mathbf{x}) \\cdot \\mathbf{f}(\\mathbf{x}) \\geq 0$。该边界条件意味着轨迹不能从安全集 $\\mathcal{S}$ 穿越到不安全集 $\\{\\mathbf{x} : B(\\mathbf{x})  0\\}$ 中。\n\n为了以计算上易于处理的方式对多项式系统强制执行边界非负性条件，我们使用平方和 (SOS) 技术。其核心思想是 S-过程 (S-procedure)：如果存在一个多项式 $\\lambda(\\mathbf{x})$ 使得\n$$\np(\\mathbf{x}) \\triangleq \\nabla B(\\mathbf{x}) \\cdot \\mathbf{f}(\\mathbf{x}) - \\lambda(\\mathbf{x}) B(\\mathbf{x})\n$$\n是 SOS，那么对于所有满足 $B(\\mathbf{x}) = 0$ 的 $\\mathbf{x}$，我们有 $p(\\mathbf{x}) = \\nabla B(\\mathbf{x}) \\cdot \\mathbf{f}(\\mathbf{x}) \\geq 0$，从而建立了所需的边界条件。这是因为项 $\\lambda(\\mathbf{x}) B(\\mathbf{x})$ 在边界上为零，而一个 SOS 多项式是全局非负的。\n\n在所考虑的具体场景中，我们采用屏障多项式 $B(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2$。其梯度为 $\\nabla B(x,y) = [2(x - c_x), 2(y - c_y)]^\\top$。我们考虑由 $\\nabla B(x,y)$ 及其通过矩阵\n$$\nJ = \\begin{bmatrix} 0   -1 \\\\ 1   0 \\end{bmatrix}.\n$$\n实现的 $90^\\circ$ 旋转所构造的多项式向量场。\n在四个测试用例中：\n- $\\mathbf{f}(x,y) = \\nabla B(x,y)$,\n- $\\mathbf{f}(x,y) = J \\nabla B(x,y)$,\n- $\\mathbf{f}(x,y) = -\\nabla B(x,y)$,\n- $\\mathbf{f}(x,y) = \\nabla B(x,y) + J \\nabla B(x,y)$,\n如果 $\\lambda$ 是一个常数标量，则多项式 $p(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y) - \\lambda B(x,y)$ 是二次的。因此，我们将 SOS 判定问题简化为针对二次多项式的格拉姆矩阵测试。\n\n对于一个二元二次多项式，\n$$\np(x,y) = a_{20} x^2 + a_{11} x y + a_{02} y^2 + a_{10} x + a_{01} y + a_{00},\n$$\n我们使用单项式基 $v(x,y) = [1, x, y]^\\top$ 并寻找一个对称矩阵\n$$\nG = \\begin{bmatrix}\ng_{00}   g_{01}   g_{02} \\\\\ng_{01}   g_{11}   g_{12} \\\\\ng_{02}   g_{12}   g_{22}\n\\end{bmatrix}\n$$\n使得 $p(x,y) = v(x,y)^\\top G v(x,y)$。匹配系数可以得到 $\\{g_{ij}\\}$ 和 $\\{a_{ij}\\}$ 之间的线性关系。具体而言，展开 $v^\\top G v$ 得到 $g_{11}$、$g_{22}$ 和 $2 g_{12}$ 分别是 $x^2$、$y^2$ 和 $xy$ 的系数；类似地，$2 g_{01}$ 和 $2 g_{02}$ 对应于 $x$ 和 $y$ 的系数，而 $g_{00}$ 对应于常数项。因此，可以直接从 $p(x,y)$ 的系数构造 $G$。多项式 $p(x,y)$ 是 SOS 当且仅当 $G \\succeq 0$，即 $G$ 是半正定的。对于二次多项式，这种等价性是精确的，因为二次多项式的 SOS 是线性多项式的平方和，这恰好可以由线性单项式基上的半正定格拉姆矩阵所捕捉。\n\n算法设计：\n1. 对于每个测试用例，根据给定的参数 $(c_x, c_y, R)$ 计算 $B$ 和 $\\nabla B$，然后根据用例指定 $\\mathbf{f}$。\n2. 计算 $p_0(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y)$。\n3. 对于区间 $[-10, 10]$ 内步长为 $0.05$ 的 $\\lambda$ 网格，构造 $p(x,y) = p_0(x,y) - \\lambda B(x,y)$ 并通过直接代数展开计算其系数向量 $(a_{20}, a_{11}, a_{02}, a_{10}, a_{01}, a_{00})$。\n4. 根据这些系数构建如上所述的格拉姆矩阵 $G$，并通过检查 $G$ 的所有特征值在数值容差范围内是否非负来测试 $G$ 是否为半正定。如果任何一个 $\\lambda$ 能得到一个半正定的 $G$，则存在一个常数 $\\lambda$ 使得 $p(x,y)$ 是 SOS，并且屏障证书条件在边界上成立。\n5. 为每个测试用例返回一个指示成功的布尔值。\n\n各用例的原理性论证：\n- 在 $\\mathbf{f} = \\nabla B$ 的情况下，方向导数为 $\\nabla B \\cdot \\nabla B = \\|\\nabla B\\|^2$，根据其构造就是一个平方和。当 $\\lambda = 0$ 时，$p$ 是 SOS，且边界条件成立，从而证明了 $\\mathcal{S}$ 的前向不变性。\n- 在 $\\mathbf{f} = J \\nabla B$ 的情况下，正交性意味着 $\\nabla B \\cdot J \\nabla B = 0$，因此 $p(x,y) = -\\lambda B(x,y)$。选择 $\\lambda = 0$ 会得到 $p \\equiv 0$，这是一个 SOS。边界条件 $\\dot{B} = 0$ 成立。\n- 在 $\\mathbf{f} = -\\nabla B$ 的情况下，我们有 $\\nabla B \\cdot \\mathbf{f} = -\\|\\nabla B\\|^2$，这在边界 $B = 0$ 上是严格为负的（因为在圆上 $\\|\\nabla B\\| \\neq 0$）。因此对于任何 $\\lambda$，$p|_{B=0} = -\\|\\nabla B\\|^2  0$，无法通过 $p(x,y)$ 获得 SOS 证书；算法会正确地报告失败。\n- 在平移的情况下 $\\mathbf{f} = \\nabla B + J \\nabla B$，旋转分量在与 $\\nabla B$ 的点积下消失，所以 $p_0 = \\|\\nabla B\\|^2$，与第一种情况一样，$\\lambda = 0$ 足以证明其为 SOS。\n\n该程序明确地实现了针对二次多项式的格拉姆矩阵方法，对标量 $\\lambda$ 进行搜索，并为四个用例返回一个布尔值列表。最终输出是包含在方括号中的、以逗号分隔的布尔结果的单行文本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gram_from_quadratic_coeffs(a20, a11, a02, a10, a01, a00):\n    \"\"\"\n    Construct the Gram matrix G for the quadratic polynomial\n    p(x,y) = a20*x^2 + a11*x*y + a02*y^2 + a10*x + a01*y + a00\n    with basis v = [1, x, y]^T, so that p(x,y) = v^T G v.\n\n    Expansion yields:\n    v^T G v = G00 + 2*G01*x + 2*G02*y + G11*x^2 + 2*G12*x*y + G22*y^2\n\n    Matching coefficients:\n    G11 = a20\n    G22 = a02\n    G12 = a11 / 2\n    G01 = a10 / 2\n    G02 = a01 / 2\n    G00 = a00\n    \"\"\"\n    G00 = a00\n    G01 = a10 / 2.0\n    G02 = a01 / 2.0\n    G11 = a20\n    G12 = a11 / 2.0\n    G22 = a02\n    G = np.array([[G00, G01, G02],\n                  [G01, G11, G12],\n                  [G02, G12, G22]], dtype=float)\n    return G\n\ndef is_psd(G, tol=1e-10):\n    \"\"\"Check if symmetric matrix G is positive semidefinite by eigenvalues.\"\"\"\n    # Ensure symmetry\n    G_sym = 0.5 * (G + G.T)\n    eigs = np.linalg.eigvalsh(G_sym)\n    return np.min(eigs) = -tol\n\ndef polynomial_coeffs_p0_and_B(cx, cy, R, f_type):\n    \"\"\"\n    Compute the coefficients of p0(x,y) = grad(B) . f(x,y) and B(x,y)\n    for given center (cx, cy), radius R, and f_type.\n\n    B(x,y) = (x - cx)^2 + (y - cy)^2 - R^2\n           = x^2 + y^2 - 2*cx*x - 2*cy*y + (cx^2 + cy^2 - R^2)\n\n    grad B = [2*(x - cx), 2*(y - cy)] = [gx, gy], with gx=2x-2cx, gy=2y-2cy.\n\n    f_type choices:\n    - \"grad\": f = [gx, gy]\n    - \"rot\":  f = [-gy, gx] (J*grad B)\n    - \"neggrad\": f = [-gx, -gy]\n    - \"sum\": f = [gx, gy] + [-gy, gx]\n    \"\"\"\n    # Coefficients of B: a20_B x^2 + a11_B xy + a02_B y^2 + a10_B x + a01_B y + a00_B\n    a20_B = 1.0\n    a11_B = 0.0\n    a02_B = 1.0\n    a10_B = -2.0 * cx\n    a01_B = -2.0 * cy\n    a00_B = cx * cx + cy * cy - R * R\n\n    # Define gx and gy symbolic structure; we will expand gx^2, gy^2 as needed.\n    # gx = 2x - 2cx; gy = 2y - 2cy.\n\n    # Compute p0 = grad(B) . f\n    if f_type == \"grad\":\n        # p0 = gx^2 + gy^2 = 4[(x - cx)^2 + (y - cy)^2]\n        # Expand:\n        a20_p0 = 4.0\n        a11_p0 = 0.0\n        a02_p0 = 4.0\n        a10_p0 = -8.0 * cx\n        a01_p0 = -8.0 * cy\n        a00_p0 = 4.0 * (cx * cx + cy * cy)\n    elif f_type == \"rot\":\n        # p0 = gx*(-gy) + gy*gx = -gx*gy + gy*gx = 0\n        a20_p0 = 0.0\n        a11_p0 = 0.0\n        a02_p0 = 0.0\n        a10_p0 = 0.0\n        a01_p0 = 0.0\n        a00_p0 = 0.0\n    elif f_type == \"neggrad\":\n        # p0 = -gx^2 - gy^2 = -4[(x - cx)^2 + (y - cy)^2]\n        a20_p0 = -4.0\n        a11_p0 = 0.0\n        a02_p0 = -4.0\n        a10_p0 = 8.0 * cx\n        a01_p0 = 8.0 * cy\n        a00_p0 = -4.0 * (cx * cx + cy * cy)\n    elif f_type == \"sum\":\n        # p0 = gx^2 + gy^2 + (gx*(-gy) + gy*gx) = gx^2 + gy^2\n        a20_p0 = 4.0\n        a11_p0 = 0.0\n        a02_p0 = 4.0\n        a10_p0 = -8.0 * cx\n        a01_p0 = -8.0 * cy\n        a00_p0 = 4.0 * (cx * cx + cy * cy)\n    else:\n        raise ValueError(\"Unsupported f_type\")\n\n    p0_coeffs = (a20_p0, a11_p0, a02_p0, a10_p0, a01_p0, a00_p0)\n    B_coeffs = (a20_B, a11_B, a02_B, a10_B, a01_B, a00_B)\n    return p0_coeffs, B_coeffs\n\ndef exists_lambda_making_p_sos(cx, cy, R, f_type, lam_min=-10.0, lam_max=10.0, lam_step=0.05, psd_tol=1e-10):\n    \"\"\"\n    Search for a constant lambda in [lam_min, lam_max] such that\n    p(x,y) = p0(x,y) - lambda * B(x,y) is SOS (quadratic Gram PSD test).\n    \"\"\"\n    p0_coeffs, B_coeffs = polynomial_coeffs_p0_and_B(cx, cy, R, f_type)\n    a20_p0, a11_p0, a02_p0, a10_p0, a01_p0, a00_p0 = p0_coeffs\n    a20_B,  a11_B,  a02_B,  a10_B,  a01_B,  a00_B  = B_coeffs\n\n    # Prepare lambda grid\n    n_steps = int(round((lam_max - lam_min) / lam_step)) + 1\n    # Ensure inclusion of lam=0 even with floating point roundup\n    lambdas = np.linspace(lam_min, lam_max, n_steps)\n\n    for lam in lambdas:\n        # p = p0 - lam * B\n        a20 = a20_p0 - lam * a20_B\n        a11 = a11_p0 - lam * a11_B\n        a02 = a02_p0 - lam * a02_B\n        a10 = a10_p0 - lam * a10_B\n        a01 = a01_p0 - lam * a01_B\n        a00 = a00_p0 - lam * a00_B\n\n        G = gram_from_quadratic_coeffs(a20, a11, a02, a10, a01, a00)\n        if is_psd(G, tol=psd_tol):\n            return True\n    return False\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (cx, cy, R, f_type)\n    test_cases = [\n        (0.0,  0.0, 1.0, \"grad\"),     # Test case 1: happy path\n        (0.0,  0.0, 1.0, \"rot\"),      # Test case 2: boundary case (rotation)\n        (0.0,  0.0, 1.0, \"neggrad\"),  # Test case 3: significant edge case (failure)\n        (1.0, -0.5, 0.75, \"sum\"),     # Test case 4: shifted obstacle, general case\n    ]\n\n    results = []\n    for cx, cy, R, f_type in test_cases:\n        feasible = exists_lambda_making_p_sos(cx, cy, R, f_type,\n                                              lam_min=-10.0, lam_max=10.0,\n                                              lam_step=0.05, psd_tol=1e-10)\n        results.append(feasible)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}