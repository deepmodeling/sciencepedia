{
    "hands_on_practices": [
        {
            "introduction": "为了验证复杂混合系统的安全性，一个核心方法是将其连续动态抽象为离散模型，从而应用模型检测等形式化方法。这个练习将指导你完成这一关键过程：从一个简单的一维网络物理系统出发，通过划分状态空间，构建一个称为Kripke结构体的有限状态模型。通过这个实践，你将掌握如何将连续系统的行为转化为可供逻辑分析的离散迁移系统，并在此基础上解决一个基本的安全规约下的可达性问题 。",
            "id": "4238602",
            "problem": "考虑一个一维离散时间信息物理系统（CPS），其动态由 $x_{k+1} = f(x_{k}, u_{k}) = x_{k} + u_{k}$ 给出，其中状态空间为 $X = [0,6]$，控制输入集为 $U = \\{0,1,2\\}$。将 $X$ 划分为以下区域：对于 $i \\in \\{0,1,2,3,4\\}$，定义 $R_{i} = [i, i+1)$，并定义 $R_{5} = [5,6]$。引入原子命题（AP）如下：对于每个 $i \\in \\{0,1,2,3,4,5\\}$，$r_{i}$ 表示属于区域 $R_{i}$；$g$ 表示目标区域 $R_{5}$；$\\mathit{unsafe}$ 表示不安全区域 $R_{3}$；$\\mathit{safe}$ 表示 $X$ 中 $R_{3}$ 的补集。初始区域为 $R_{0}$。使用 Kripke 结构的标准定义 $K = (S, S_{0}, R, AP, L)$，其中 $S$ 是抽象状态的有限集，$S_{0} \\subseteq S$ 是初始状态集，$R \\subseteq S \\times S$ 是由动态和输入导出的全转移关系，$AP$ 是原子命题的有限集，$L: S \\to 2^{AP}$ 是一个标记函数。\n\n通过取 $S = \\{0,1,2,3,4,5\\}$（其中状态 $i$ 代表区域 $R_{i}$），$S_{0} = \\{0\\}$ 来构建有限 Kripke 结构抽象，并定义当且仅当存在 $x \\in R_{i}$ 和 $u \\in U$ 使得 $x + u \\in R_{j}$ 时，有 $(i,j) \\in R$。使用集合运算，以 $i$ 的闭合形式明确指定 $S$ 上的标记函数 $L$。\n\n使用此 Kripke 结构，确定最小离散步数 $k_{\\min}$，使得存在一条从初始状态开始的路径，该路径到达一个由 $g$ 标记的状态，同时在所有中间步骤中避开所有由 $\\mathit{unsafe}$ 标记的状态。请以单个整数 $k_{\\min}$ 的形式提供您的最终答案。无需四舍五入。",
            "solution": "问题陈述经过分析，被认为是有效的。这是一个在信息物理系统可达性分析领域中定义明确的问题，提供了一套完整且一致的定义和约束，用于构建有限抽象并解决一个带安全约束的可达性查询。\n\n任务是为给定的离散时间系统构建一个 Kripke 结构，然后找到从初始区域到达目标区域同时避开不安全区域所需的最小步数 $k_{\\min}$。\n\nKripke 结构 $K = (S, S_{0}, R, AP, L)$ 的各组成部分定义如下：\n\n1.  **抽象状态集, $S$**：问题定义了 $S = \\{0, 1, 2, 3, 4, 5\\}$。每个状态 $i \\in S$ 是连续区域 $R_i$ 的抽象。\n\n2.  **初始状态集, $S_{0}$**：初始区域为 $R_0$，所以初始抽象状态集为 $S_{0} = \\{0\\}$。\n\n3.  **原子命题集, $AP$**：问题定义了 $AP = \\{r_0, r_1, r_2, r_3, r_4, r_5, g, \\mathit{unsafe}, \\mathit{safe}\\}$。\n\n4.  **标记函数, $L: S \\to 2^{AP}$**：标记函数 $L$ 将每个抽象状态 $i$ 映射到在相应区域 $R_i$ 中为真的原子命题集。\n    -   如果状态在 $R_i$ 中，则 $r_i$ 为真。这意味着对于所有 $i \\in S$，$r_i \\in L(i)$。\n    -   对于目标区域 $R_5$，$g$ 为真。这意味着 $g \\in L(5)$。\n    -   对于不安全区域 $R_3$，$\\mathit{unsafe}$ 为真。这意味着 $\\mathit{unsafe} \\in L(3)$。\n    -   对于 $R_3$ 的补集，即区域 $R_0, R_1, R_2, R_4, R_5$，$\\mathit{safe}$ 为真。这意味着对于 $i \\in \\{0, 1, 2, 4, 5\\}$，$\\mathit{safe} \\in L(i)$。\n\n    我们可以为每个状态指定 $L$：\n    -   $L(0) = \\{r_{0}, \\mathit{safe}\\}$\n    -   $L(1) = \\{r_{1}, \\mathit{safe}\\}$\n    -   $L(2) = \\{r_{2}, \\mathit{safe}\\}$\n    -   $L(3) = \\{r_{3}, \\mathit{unsafe}\\}$\n    -   $L(4) = \\{r_{4}, \\mathit{safe}\\}$\n    -   $L(5) = \\{r_{5}, g, \\mathit{safe}\\}$\n\n    使用集合运算和分段定义，对于任何 $i \\in S$ 的闭合形式为：\n    $$ L(i) = \\{r_i\\} \\cup \\begin{cases} \\{g, \\mathit{safe}\\}  \\text{if } i=5 \\\\ \\{\\mathit{unsafe}\\}  \\text{if } i=3 \\\\ \\{\\mathit{safe}\\}  \\text{if } i \\in \\{0, 1, 2, 4\\} \\end{cases} $$\n\n5.  **转移关系, $R \\subseteq S \\times S$**：当且仅当存在一个状态 $x \\in R_i$ 和一个控制输入 $u \\in U$，使得下一个状态 $x_{k+1} = x + u$ 位于 $R_j$ 中时，转移 $(i, j) \\in R$ 存在。这等价于检查从 $R_i$ 可达的连续状态集（表示为 $Post(R_i)$）是否与 $R_j$ 有非空交集。\n    从 $R_i$ 可达的连续状态集为 $Post(R_i) = \\{x+u \\mid x \\in R_i, u \\in U\\}$。\n\n    让我们计算每个状态 $i \\in S$ 的转移关系：\n    -   对于 $i \\in \\{0,1,2,3,4\\}$，$R_i = [i, i+1)$。$U=\\{0,1,2\\}$。\n        $Post(R_i) = [i, i+1) + \\{0,1,2\\} = [i, i+1) \\cup [i+1, i+2) \\cup [i+2, i+3) = [i, i+3)$。\n    -   对于 $i=5$，$R_5 = [5,6]$。\n        $Post(R_5) = [5,6] + \\{0,1,2\\} = [5,6] \\cup [6,7] \\cup [7,8] = [5,8]$。\n\n    现在我们检查与 $R_j$ 的交集：\n    -   从状态 $i=0$：$Post(R_0) = [0,3)$。这与 $R_0=[0,1)$、$R_1=[1,2)$ 和 $R_2=[2,3)$ 相交。所以，从状态 0 的转移是到 $\\{0, 1, 2\\}$。\n    -   从状态 $i=1$：$Post(R_1) = [1,4)$。这与 $R_1=[1,2)$、$R_2=[2,3)$ 和 $R_3=[3,4)$ 相交。所以，从状态 1 的转移是到 $\\{1, 2, 3\\}$。\n    -   从状态 $i=2$：$Post(R_2) = [2,5)$。这与 $R_2=[2,3)$、$R_3=[3,4)$ 和 $R_4=[4,5)$ 相交。所以，从状态 2 的转移是到 $\\{2, 3, 4\\}$。\n    -   从状态 $i=3$：$Post(R_3) = [3,6)$。这与 $R_3=[3,4)$、$R_4=[4,5)$ 和 $R_5=[5,6]$ 相交。所以，从状态 3 的转移是到 $\\{3, 4, 5\\}$。\n    -   从状态 $i=4$：$Post(R_4) = [4,7)$。这与 $R_4=[4,5)$ 和 $R_5=[5,6]$ 相交。所以，从状态 4 的转移是到 $\\{4, 5\\}$。\n    -   从状态 $i=5$：$Post(R_5) = [5,8]$。这在定义的状态空间内仅与 $R_5=[5,6]$ 相交。所以，从状态 5 的唯一转移是到其自身 $\\{5\\}$。\n\n    转移关系 $R$ 可以总结为邻接表：\n    -   $0 \\to \\{0, 1, 2\\}$\n    -   $1 \\to \\{1, 2, 3\\}$\n    -   $2 \\to \\{2, 3, 4\\}$\n    -   $3 \\to \\{3, 4, 5\\}$\n    -   $4 \\to \\{4, 5\\}$\n    -   $5 \\to \\{5\\}$\n\n现在，我们必须找到到达一个由 $g$ 标记的状态同时避开所有由 $\\mathit{unsafe}$ 标记的状态所需的最小离散步数 $k_{\\min}$。\n-   初始状态：$s_0 = 0$。\n-   目标状态（用 $g$ 标记）：$S_g = \\{5\\}$。\n-   不安全状态（用 $\\mathit{unsafe}$ 标记）：$S_u = \\{3\\}$。\n\n问题是在由 $(S, R)$ 定义的图中找到从状态 0 到状态 5 的最短路径，使得路径上没有中间状态属于 $S_u$。我们可以通过在“安全”子图上执行广度优先搜索（BFS）来解决这个问题，该子图是通过移除不安全状态 $S_u=\\{3\\}$ 及其所有相关边得到的。\n\n安全状态集为 $S_{\\mathit{safe}} = S \\setminus S_u = \\{0, 1, 2, 4, 5\\}$。\n安全转移关系 $R_{\\mathit{safe}}$ 只包含 $S_{\\mathit{safe}}$ 中状态之间的转移：\n-   从 0：$\\{0, 1, 2\\}$ 都是安全的。\n-   从 1：邻居为 $\\{1, 2, 3\\}$。安全邻居为 $\\{1, 2\\}$。\n-   从 2：邻居为 $\\{2, 3, 4\\}$。安全邻居为 $\\{2, 4\\}$。\n-   从 4：邻居为 $\\{4, 5\\}$。两者都是安全的。\n-   从 5：邻居为 $\\{5\\}$，是安全的。\n\n安全转移关系 $R_{\\mathit{safe}}$ 是：\n-   $0 \\to \\{0, 1, 2\\}$\n-   $1 \\to \\{1, 2\\}$\n-   $2 \\to \\{2, 4\\}$\n-   $4 \\to \\{4, 5\\}$\n-   $5 \\to \\{5\\}$\n\n我们从 $s_0=0$ 开始执行 BFS，以找到到 $S_g=\\{5\\}$ 的最短路径：\n-   **步骤 $k=0$**：队列用起始状态初始化。$Q = [0]$。已访问状态集为 $V=\\{0\\}$。\n-   **步骤 $k=1$**：将 0 出队。其邻居为 $\\{0, 1, 2\\}$。\n    -   $0$ 已在 $V$ 中。\n    -   将 1 添加到 $Q$ 和 $V$。\n    -   将 2 添加到 $Q$ 和 $V$。\n    -   $Q=[1, 2]$，$V=\\{0, 1, 2\\}$。到状态 1 和 2 的距离为 1。\n-   **步骤 $k=2$**：\n    -   将 1 出队。其邻居为 $\\{1, 2\\}$，两者都在 $V$ 中。\n    -   将 2 出队。其邻居为 $\\{2, 4\\}$。\n        -   $2$ 在 $V$ 中。\n        -   将 4 添加到 $Q$ 和 $V$。\n    -   $Q=[4]$，$V=\\{0, 1, 2, 4\\}$。到状态 4 的距离为 2。一条路径是 $0 \\to 2 \\to 4$。\n-   **步骤 $k=3$**：\n    -   将 4 出队。其邻居为 $\\{4, 5\\}$。\n        -   $4$ 在 $V$ 中。\n        -   状态 5 是目标状态。我们找到了最短路径。\n    -   路径长度为 3。一条可能的路径是 $0 \\to 2 \\to 4 \\to 5$。\n\n最小离散步数为 3。这对应于一个控制序列。例如：\n1.  从 $R_0$，应用 $u=2$。若 $x_0 \\in [0,1)$，则 $x_1 = x_0+2 \\in [2,3) = R_2$。（步骤 1，状态为 2）\n2.  从 $R_2$，应用 $u=2$。若 $x_1 \\in [2,3)$，则 $x_2 = x_1+2 \\in [4,5) = R_4$。（步骤 2，状态为 4）\n3.  从 $R_4$，应用 $u=1$。若 $x_2 \\in [4,5)$，则 $x_3 = x_2+1 \\in [5,6) \\subseteq R_5$。（步骤 3，状态为 5，到达目标）\n\n最小步数 $k_{\\min}$ 为 3。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "精确计算系统在所有可能输入下能够到达的所有状态（即可达集）往往是极其困难甚至不可能的。因此，在实践中，我们通常计算一个包含真实可达集的、形状更简单的“过近似”集。这个练习将深入探讨如何为一个线性系统构建一个多面体过近似，并使用一种强大的工具——支撑函数——来精确量化这种简化所引入的误差 。理解这种近似与误差之间的权衡对于设计可靠的控制器和验证系统至关重要。",
            "id": "4238593",
            "problem": "一个信息物理系统 (CPS) 的数字孪生监控一个离散时间线性代理模型，其状态 $x \\in \\mathbb{R}^{2}$ 由集值更新方程控制\n$$\nx^{+} \\in A x \\oplus B U,\n$$\n其中 $\\oplus$ 表示闵可夫斯基和，$A = \\mathrm{diag}(\\alpha,\\beta)$ 满足 $0  \\alpha  1$ 和 $0  \\beta  1$，$B = I_{2}$ 是单位矩阵，输入集是多面体菱形\n$$\nU = \\{ u \\in \\mathbb{R}^{2} : |u_{1}| + |u_{2}| \\leq 1 \\}.\n$$\n假设初始状态集为 $X_{0} = \\{0\\}$。\n\n仅使用闵可夫斯基和、凸集的线性映像以及支撑函数的基本定义和性质，完成以下任务：\n\n1. 推导精确的 $k$ 步可达集 $R_{k}$。\n2. 构造 $R_{k}$ 的一个多面体过近似 $P_{k}$，该近似是一个以原点为中心的 $\\ell_{1}$球（菱形），并具有保证 $R_{k} \\subseteq P_{k}$ 的最小可能半径 $\\rho_{k}$。\n3. 使用凸集之间有向豪斯多夫距离的支撑函数表征，推导过近似误差 $\\delta_{k}$ 的一个闭式上界。该误差定义为从 $P_{k}$ 到 $R_{k}$ 的有向豪斯多夫距离。\n\n将您的最终界限 $\\delta_{k}$ 表示为关于 $\\alpha$、$\\beta$ 和 $k$ 的单个闭式解析表达式。不需要数值近似，最终答案不带单位。最终表达式必须是单个解析表达式，而不是一个不等式或待解方程。",
            "solution": "该问题被评估为有效。这是一个适定、有科学依据的问题，属于线性系统可达性分析领域，是信息物理系统理论中的一个核心课题。所有定义均为标准定义，问题设置在内部是一致且完整的。\n\n任务是分析一个离散时间线性系统的可达集，找到一个特定的多面体过近似，并计算近似误差。\n\n系统动力学由集值递推关系给出：\n$$\nx^{+} \\in A x \\oplus B U\n$$\n初始状态集为 $X_0 = \\{0\\}$。矩阵为 $A = \\mathrm{diag}(\\alpha, \\beta)$ 和 $B=I_2$，其中 $0  \\alpha  1$ 且 $0  \\beta  1$。输入集是单位 $\\ell_1$球 $U = \\{ u \\in \\mathbb{R}^{2} : |u_1| + |u_2| \\leq 1 \\}$。符号 $\\oplus$ 表示闵可夫斯基和。\n\n**1. 精确的 $k$ 步可达集 $R_k$ 的推导**\n\n$k$ 步时的可达集 $R_k$ 是从 $X_0$ 出发所有可能状态的集合。我们可以通过展开递推关系来找到它。\n对于 $k=0$，可达集是初始集：$R_0 = X_0 = \\{0\\}$。\n对于 $k=1$：\n$$\nR_1 = A R_0 \\oplus B U = A\\{0\\} \\oplus I_2 U = \\{0\\} \\oplus U = U\n$$\n对于 $k=2$：\n$$\nR_2 = A R_1 \\oplus B U = A U \\oplus U\n$$\n对于 $k=3$：\n$$\nR_3 = A R_2 \\oplus B U = A (A U \\oplus U) \\oplus U = A^2 U \\oplus A U \\oplus U\n$$\n通过归纳法，经过 $k$ 步后的状态 $x(k)$ 是变换后的输入 $u(0), \\dots, u(k-1)$ 的和，其中每个 $u(i) \\in U$：\n$$\nx(k) = A^{k-1} B u(0) + A^{k-2} B u(1) + \\dots + A^0 B u(k-1)\n$$\n所有这些状态 $x(k)$ 的集合就是可达集 $R_k$。由于 $B=I_2$，这是变换后输入集的闵可夫斯基和：\n$$\nR_k = \\bigoplus_{i=0}^{k-1} A^i U\n$$\n矩阵 $A$ 是对角矩阵，所以 $A^i = \\mathrm{diag}(\\alpha^i, \\beta^i)$。集合 $A^i U$ 是 $U$ 在 $A^i$ 下的线性映像。对于任何点 $v \\in A^i U$，存在一个 $u \\in U$ 使得 $v = A^i u$，这意味着 $v_1 = \\alpha^i u_1$ 且 $v_2 = \\beta^i u_2$。由于 $|u_1| + |u_2| \\leq 1$，集合 $A^i U$ 中的点 $v$ 满足：\n$$\n\\left|\\frac{v_1}{\\alpha^i}\\right| + \\left|\\frac{v_2}{\\beta^i}\\right| \\leq 1\n$$\n每个集合 $A^i U$ 都是一个带状多面体（具体来说，是一个各向异性缩放的菱形）。带状多面体的闵可夫斯基和仍然是带状多面体。因此，$R_k = \\bigoplus_{i=0}^{k-1} A^i U$ 是 $k$ 步可达集的精确表征。\n\n**2. 过近似 $\\ell_1$球 $P_k$ 的构造**\n\n我们寻求最小的半径 $\\rho_k$ 使得 $R_k \\subseteq P_k$，其中 $P_k = \\{x \\in \\mathbb{R}^2 : |x_1| + |x_2| \\leq \\rho_k\\}$。集合 $P_k$ 是一个半径为 $\\rho_k$ 的 $\\ell_1$球，可以写成 $P_k = \\rho_k U$。\n最小的 $\\rho_k$ 是集合 $R_k$ 上 $\\ell_1$范数的最大值：\n$$\n\\rho_k = \\max_{x \\in R_k} ||x||_1 = \\max_{x \\in R_k} (|x_1|+|x_2|)\n$$\n任何点 $x \\in R_k$ 都具有形式 $x = \\sum_{i=0}^{k-1} x^{(i)}$，其中 $x^{(i)} \\in A^i U$。因此，对于某些 $u^{(i)} \\in U$ 的选择，$x = \\sum_{i=0}^{k-1} A^i u^{(i)}$。\n$x$ 的 $\\ell_1$范数是：\n$$\n||x||_1 = \\left|\\sum_{i=0}^{k-1} \\alpha^i u_1^{(i)}\\right| + \\left|\\sum_{i=0}^{k-1} \\beta^i u_2^{(i)}\\right|\n$$\n根据三角不等式，并且由于 $\\alpha^i > 0$ 和 $\\beta^i > 0$：\n$$\n||x||_1 \\leq \\sum_{i=0}^{k-1} \\left|\\alpha^i u_1^{(i)}\\right| + \\sum_{i=0}^{k-1} \\left|\\beta^i u_2^{(i)}\\right| = \\sum_{i=0}^{k-1} \\left(\\alpha^i |u_1^{(i)}| + \\beta^i |u_2^{(i)}|\\right)\n$$\n为了找到 $||x||_1$ 的最大值，我们可以最大化右侧。这涉及到对每个 $i$ 最大化表达式 $\\alpha^i |u_1| + \\beta^i |u_2|$，约束条件是 $|u_1|+|u_2| \\leq 1$。这是 $(|u_1|, |u_2|)$ 在一个单纯形上的线性函数，因此最大值在顶点处取得。$(|u_1|, |u_2|)$ 定义域的顶点是 $(0,0)$、$(1,0)$ 和 $(0,1)$。最大值是 $\\max(\\alpha^i, \\beta^i)$。\n因此，$||x||_1$ 的一个上界是 $\\sum_{i=0}^{k-1} \\max(\\alpha^i, \\beta^i)$。这个界是紧的，因为可以通过选择输入序列 $u^{(i)}$ 来对齐并最大化各项来实现。例如，如果 $\\alpha > \\beta$，那么对于所有 $i \\ge 1$，都有 $\\alpha^i > \\beta^i$。我们可以为所有 $i$ 选择 $u^{(i)} = (1,0)$。那么 $||x||_1 = |\\sum \\alpha^i| + 0 = \\sum \\alpha^i$。\n所以，$\\rho_k$ 由下式给出：\n$$\n\\rho_k = \\sum_{i=0}^{k-1} \\max(\\alpha^i, \\beta^i)\n$$\n由于 $\\alpha, \\beta \\in (0,1)$，如果 $\\alpha \\ne \\beta$，项 $\\max(\\alpha, \\beta)$ 决定了对于所有幂 $i \\ge 1$ 哪个更大。因此，$\\max(\\alpha^i, \\beta^i) = (\\max(\\alpha, \\beta))^i$。$i=0$ 的情况是 $\\max(1,1)=1$。所以该公式成立。\n使用几何级数求和公式：\n$$\n\\rho_k = \\sum_{i=0}^{k-1} (\\max(\\alpha, \\beta))^i = \\frac{1 - (\\max(\\alpha, \\beta))^k}{1 - \\max(\\alpha, \\beta)}\n$$\n过近似集是 $P_k = \\{x : ||x||_1 \\leq \\rho_k\\}$。\n\n**3. 误差界 $\\delta_k$ 的推导**\n\n过近似误差 $\\delta_k$ 是从 $P_k$ 到 $R_k$ 的有向豪斯多夫距离。对于凸集 $X, Y$，这由 $d(X, Y) = \\sup_{||l||_*=1}(h_X(l)-h_Y(l))$ 给出，通过支撑函数表示。假设距离使用标准的欧几里得范数，那么 $l$ 的对偶范数也是欧几里得范数，所以我们在 $||l||_2=1$ 上取上确界。\n$$\n\\delta_k = d(P_k, R_k) = \\sup_{||l||_2=1} (h_{P_k}(l) - h_{R_k}(l))\n$$\n首先，我们找到支撑函数。基本集 $U$ 的支撑函数是 $h_U(l) = \\sup_{u \\in U} l^T u = ||l||_\\infty = \\max(|l_1|, |l_2|)$。\n$R_k = \\bigoplus_{i=0}^{k-1} A^i U$ 的支撑函数是：\n$$\nh_{R_k}(l) = \\sum_{i=0}^{k-1} h_{A^i U}(l) = \\sum_{i=0}^{k-1} h_U((A^i)^T l) = \\sum_{i=0}^{k-1} \\max(|\\alpha^i l_1|, |\\beta^i l_2|)\n$$\n$P_k = \\rho_k U$ 的支撑函数是：\n$$\nh_{P_k}(l) = \\rho_k h_U(l) = \\rho_k \\max(|l_1|, |l_2|)\n$$\n代入 $\\rho_k = \\sum_{i=0}^{k-1} \\max(\\alpha^i, \\beta^i)$，差值为：\n$$\nh_{P_k}(l) - h_{R_k}(l) = \\left(\\sum_{i=0}^{k-1} \\max(\\alpha^i, \\beta^i)\\right)\\max(|l_1|, |l_2|) - \\sum_{i=0}^{k-1} \\max(\\alpha^i|l_1|, \\beta^i|l_2|)\n$$\n这可以写成一个和式：\n$$\nh_{P_k}(l) - h_{R_k}(l) = \\sum_{i=0}^{k-1} \\left[ \\max(\\alpha^i, \\beta^i)\\max(|l_1|, |l_2|) - \\max(\\alpha^i|l_1|, \\beta^i|l_2|) \\right]\n$$\n我们来分析第 $i$ 项 $C_i(l)$。对于 $i=0$，$\\alpha^0=\\beta^0=1$，所以 $C_0(l) = \\max(1,1)\\max(|l_1|,|l_2|) - \\max(|l_1|,|l_2|) = 0$。因此，求和实际上从 $i=1$ 开始。\n考虑 $i \\ge 1$。不失一般性，假设 $\\alpha > \\beta$。那么 $\\alpha^i > \\beta^i$ 并且 $\\max(\\alpha^i, \\beta^i) = \\alpha^i$。\n$$\nC_i(l) = \\alpha^i \\max(|l_1|, |l_2|) - \\max(\\alpha^i|l_1|, \\beta^i|l_2|)\n$$\n如果 $|l_1| \\ge |l_2|$，则 $\\max(|l_1|,|l_2|)=|l_1|$。同时 $\\alpha^i|l_1| > \\beta^i|l_1| \\ge \\beta^i|l_2|$，所以 $\\max(\\alpha^i|l_1|, \\beta^i|l_2|) = \\alpha^i|l_1|$。因此，$C_i(l) = \\alpha^i|l_1| - \\alpha^i|l_1| = 0$。\n如果 $|l_1|  |l_2|$，则 $\\max(|l_1|,|l_2|)=|l_2|$。该项变为：\n$$\nC_i(l) = \\alpha^i|l_2| - \\max(\\alpha^i|l_1|, \\beta^i|l_2|)\n$$\n由于 $\\max(a,b) \\ge b$，我们有 $\\max(\\alpha^i|l_1|, \\beta^i|l_2|) \\ge \\beta^i|l_2|$。因此，\n$$\nC_i(l) \\le \\alpha^i|l_2| - \\beta^i|l_2| = (\\alpha^i - \\beta^i)|l_2|\n$$\n因为我们在 $||l||_2=1$ 上进行最大化，所以有 $|l_2| \\le 1$。这意味着 $C_i(l) \\le \\alpha^i - \\beta^i$。\n当 $|l_2|=1$（因此 $l_1=0$，且 $l=(0, \\pm 1)$）并且上述不等式取等时，可以达到这个上界。在 $l=(0, 1)$ 处，有 $|l_2|=1$ 且 $\\max(\\alpha^i|l_1|, \\beta^i|l_2|) = \\max(0, \\beta^i) = \\beta^i|l_2|$。所以等号成立。\n$C_i(l)$ 的最大值是 $\\alpha^i - \\beta^i$，在 $l=(0, \\pm 1)$ 处取得。\n\n总误差为 $\\delta_k = \\sup_{||l||_2=1} \\sum_{i=1}^{k-1} C_i(l)$。由于对于 $i \\in \\{1,\\dots,k-1\\}$ 中的每个函数 $C_i(l)$ 都在相同的向量 $l$（例如，如果 $\\alpha\\beta$，则为 $l=(0,1)$）上取得最大值，所以和的上确界等于上确界的和：\n$$\n\\delta_k = \\sum_{i=1}^{k-1} \\sup_{||l||_2=1} C_i(l)\n$$\n如果 $\\alpha > \\beta$，则 $\\delta_k = \\sum_{i=1}^{k-1} (\\alpha^i - \\beta^i)$。如果 $\\beta > \\alpha$，通过从最大化方向 $l=(\\pm 1, 0)$ 开始的对称论证，可得 $\\delta_k = \\sum_{i=1}^{k-1} (\\beta^i - \\alpha^i)$。\n总的来说，$\\delta_k = \\sum_{i=1}^{k-1} |\\alpha^i - \\beta^i|$。由于对于所有 $i \\ge 1$，$\\alpha^i - \\beta^i$ 的符号是恒定的，我们可以写成：\n$$\n\\delta_k = \\left| \\sum_{i=1}^{k-1} (\\alpha^i - \\beta^i) \\right| = \\left| \\sum_{i=1}^{k-1} \\alpha^i - \\sum_{i=1}^{k-1} \\beta^i \\right|\n$$\n使用从索引 1 开始的 $k-1$ 项的几何级数求和公式：\n$$\n\\sum_{i=1}^{k-1} \\alpha^i = \\alpha \\frac{1-\\alpha^{k-1}}{1-\\alpha} = \\frac{\\alpha-\\alpha^k}{1-\\alpha}\n$$\n对于 $\\beta$ 也类似。因此，误差界是：\n$$\n\\delta_k = \\left| \\frac{\\alpha - \\alpha^k}{1-\\alpha} - \\frac{\\beta - \\beta^k}{1-\\beta} \\right|\n$$\n这个表达式是精确的有向豪斯多夫距离 $d(P_k, R_k)$，因此，它是最紧的可能误差上界。",
            "answer": "$$\\boxed{\\left| \\frac{\\alpha - \\alpha^k}{1-\\alpha} - \\frac{\\beta - \\beta^k}{1-\\beta} \\right|}$$"
        },
        {
            "introduction": "障碍证书为证明系统永远不会进入不安全区域提供了一种强大的代数方法。与直接计算可达集不同，该方法致力于寻找一个数学函数（即“障碍”），它能将初始状态集与不安全区域分离开，并且其存在本身就构成了系统安全的证明。这个练习将向你展示如何利用平方和 (Sum-of-Squares, SOS) 规划这一前沿技术，为多项式动态系统自动搜索这样的障碍证书 。这体现了如何将复杂的安全验证问题转化为一个可以由计算机高效求解的凸优化问题。",
            "id": "4238645",
            "problem": "考虑由常微分方程 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})$ 定义的平面多项式系统，其中 $\\mathbf{x} = (x,y) \\in \\mathbb{R}^2$ 且 $\\mathbf{f}$ 是一个多项式向量场。一个圆形障碍物由集合 $\\mathcal{O} = \\{(x,y) \\in \\mathbb{R}^2 : (x - c_x)^2 + (y - c_y)^2 \\leq R^2\\}$ 指定，其中 $c_x, c_y \\in \\mathbb{R}$ 和 $R > 0$ 是给定常数。令候选势垒多项式为 $B(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2$，并定义安全集 $\\mathcal{S} = \\{(x,y) \\in \\mathbb{R}^2 : B(x,y) \\geq 0\\}$，即障碍物的外部。\n\n在可达性分析中，势垒证书的目的是保证从 $\\mathcal{S}$ 开始的轨迹永远不会进入 $\\mathcal{O}$ 的内部。$\\mathcal{S}$ 的前向不变性的一个标准充分条件是边界条件 $\\nabla B(x,y) \\cdot \\mathbf{f}(x,y) \\geq 0$ 对所有满足 $B(x,y) = 0$ 的 $(x,y)$ 成立。为了通过多项式优化来强制满足此不等式，可以采用平方和 (Sum-of-Squares, SOS) 规划。具体来说，如果存在一个多项式 $\\lambda(x,y)$，使得多项式\n$$\np(x,y) \\triangleq \\nabla B(x,y) \\cdot \\mathbf{f}(x,y) - \\lambda(x,y) B(x,y)\n$$\n是一个平方和多项式，那么在边界 $B(x,y) = 0$ 上，$\\nabla B(x,y) \\cdot \\mathbf{f}(x,y) \\geq 0$ 成立。平方和条件等价于存在一个关于适当单项式基的 $p(x,y)$ 的半正定格拉姆矩阵表示。对于二元二次多项式，可以使用基向量 $v(x,y) = [1, x, y]^\\top$ 并寻找一个对称矩阵 $G \\succeq 0$ 使得 $p(x,y) = v(x,y)^\\top G v(x,y)$。\n\n您的任务是编写一个程序，对于下面的每个测试用例，为限制为常数（0次）的标量搜索变量 $\\lambda \\in \\mathbb{R}$ 构建SOS规划，并判断是否存在一个 $\\lambda$ 值使得 $p(x,y)$ 是SOS多项式。该判断必须基于二次多项式的格拉姆矩阵方法，通过将 $p(x,y)$ 的多项式系数与由 $v(x,y)^\\top G v(x,y)$ 生成的系数相等，并验证得到的对称矩阵 $G$ 是否为半正定。由于 $B(x,y)$ 是二次的，并且在测试套件中考虑的 $\\mathbf{f}(x,y)$ 将是次数至多为一的多项式，因此对于常数 $\\lambda$，$p(x,y)$ 保证是二次多项式；因此，使用基 $v(x,y) = [1,x,y]^\\top$ 的格拉姆矩阵方法是适用的。您必须在下面指定的有限网格上搜索 $\\lambda$。\n\n使用的基本原理：\n- 前向不变性的势垒证书条件依赖于这样一个事实：如果方向导数 $\\dot{B}(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y)$ 在边界 $B(x,y) = 0$ 上非负，则轨迹不能从 $\\mathcal{S}$ 进入 $B(x,y)  0$ 的区域。\n- 平方和 (SOS) 多项式是一个可以写成有限个多项式平方和的多项式。对于变量 $x$ 和 $y$ 的二次多项式，SOS性质等价于存在一个半正定格拉姆矩阵 $G$ 使得该多项式可以写成 $v^\\top G v$ 的形式，其中 $v = [1,x,y]^\\top$。\n\n您必须为每个测试用例实现以下步骤：\n1. 构造势垒多项式 $B(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2$ 及其梯度 $\\nabla B(x,y)$。\n2. 按照测试用例的规定定义多项式向量场 $\\mathbf{f}(x,y)$。\n3. 对于标量 $\\lambda$，构造多项式 $p(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y) - \\lambda B(x,y)$。\n4. 对于区间 $[-10, 10]$ 内以 $0.05$ 为均匀增量的 $\\lambda$ 值网格，通过构建与 $p(x,y)$ 系数匹配的二次型 $v^\\top G v$ 对应的格拉姆矩阵 $G$，并验证 $G$ 是否为半正定，来检查 $p(x,y)$ 是否为SOS多项式。\n5. 返回一个布尔值，指示网格上是否存在任何 $\\lambda$ 使得 $p(x,y)$ 为SOS多项式。必须通过检查 $G$ 的所有特征值在数值公差范围内均非负来证明其为半正定。\n\n测试套件规范：\n- 测试用例1（正常情况）：$c_x = 0$, $c_y = 0$, $R = 1$, $\\mathbf{f}(x,y) = \\nabla B(x,y)$。\n- 测试用例2（边界情况）：$c_x = 0$, $c_y = 0$, $R = 1$, $\\mathbf{f}(x,y) = J \\nabla B(x,y)$，其中 $J = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$ 是一个将向量场旋转 $90^\\circ$ 的矩阵，即 $J \\nabla B(x,y) = (-(\\partial B/\\partial y), \\partial B/\\partial x)$。\n- 测试用例3（重要边界情况）：$c_x = 0$, $c_y = 0$, $R = 1$, $\\mathbf{f}(x,y) = -\\nabla B(x,y)$。\n- 测试用例4（平移障碍物，一般情况）：$c_x = 1$, $c_y = -0.5$, $R = 0.75$, $\\mathbf{f}(x,y) = \\nabla B(x,y) + J \\nabla B(x,y)$。\n\n答案规范：\n- 对每个测试用例，输出一个布尔值，表示在指定网格中是否存在一个常数 $\\lambda$ 使得 $p(x,y)$ 为SOS多项式。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3,result4]”）。\n- 输出中不得报告任何物理单位或角度；所有计算都纯粹是多项式和代数的。\n\n程序必须是完整且可运行的，使用针对二次多项式的格拉姆矩阵检验，并完全按照规定执行 $\\lambda$ 网格搜索。",
            "solution": "我们从连续时间动力学系统背景下的前向不变性势垒证书条件开始。设 $\\mathbf{x}(t)$ 满足 $\\dot{\\mathbf{x}} = \\mathbf{f}(\\mathbf{x})$，并设 $B(\\mathbf{x})$ 是一个连续可微的标量函数。如果要求集合 $\\mathcal{S} = \\{\\mathbf{x} : B(\\mathbf{x}) \\geq 0\\}$ 是前向不变的，一个基于生存理论 (viability theory) 和关于微分包含的 Nagumo 定理的充分条件是，方向导数在边界 $\\{\\mathbf{x} : B(\\mathbf{x}) = 0\\}$ 上满足 $\\dot{B}(\\mathbf{x}) = \\nabla B(\\mathbf{x}) \\cdot \\mathbf{f}(\\mathbf{x}) \\geq 0$。该边界条件意味着轨迹不能从安全集 $\\mathcal{S}$ 穿越到不安全集 $\\{\\mathbf{x} : B(\\mathbf{x})  0\\}$ 中。\n\n为了以计算上易于处理的方式对多项式系统强制施加边界非负性条件，我们使用平方和 (SOS) 技术。其核心思想是 S-过程 (S-procedure)：如果存在一个多项式 $\\lambda(\\mathbf{x})$ 使得\n$$\np(\\mathbf{x}) \\triangleq \\nabla B(\\mathbf{x}) \\cdot \\mathbf{f}(\\mathbf{x}) - \\lambda(\\mathbf{x}) B(\\mathbf{x})\n$$\n是SOS多项式，那么对于所有满足 $B(\\mathbf{x}) = 0$ 的 $\\mathbf{x}$，我们有 $p(\\mathbf{x}) = \\nabla B(\\mathbf{x}) \\cdot \\mathbf{f}(\\mathbf{x}) \\geq 0$，从而建立了所需的边界条件。这是因为项 $\\lambda(\\mathbf{x}) B(\\mathbf{x})$ 在边界上为零，而一个SOS多项式是全局非负的。\n\n在所考虑的具体场景中，我们取势垒多项式 $B(x,y) = (x - c_x)^2 + (y - c_y)^2 - R^2$。其梯度为 $\\nabla B(x,y) = [2(x - c_x), 2(y - c_y)]^\\top$。我们考虑由 $\\nabla B(x,y)$ 及其通过矩阵\n$$\nJ = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}\n$$\n进行 $90^\\circ$ 旋转所构建的多项式向量场。在四个测试用例中：\n- $\\mathbf{f}(x,y) = \\nabla B(x,y)$，\n- $\\mathbf{f}(x,y) = J \\nabla B(x,y)$，\n- $\\mathbf{f}(x,y) = -\\nabla B(x,y)$，\n- $\\mathbf{f}(x,y) = \\nabla B(x,y) + J \\nabla B(x,y)$，\n如果 $\\lambda$ 是一个常数标量，那么多项式 $p(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y) - \\lambda B(x,y)$ 就是二次的。因此，我们将SOS决策简化为对二次多项式的格拉姆矩阵检验。\n\n对于一个二元二次多项式，\n$$\np(x,y) = a_{20} x^2 + a_{11} x y + a_{02} y^2 + a_{10} x + a_{01} y + a_{00},\n$$\n我们使用单项式基 $v(x,y) = [1, x, y]^\\top$ 并寻找一个对称矩阵\n$$\nG = \\begin{bmatrix}\ng_{00}  g_{01}  g_{02} \\\\\ng_{01}  g_{11}  g_{12} \\\\\ng_{02}  g_{12}  g_{22}\n\\end{bmatrix}\n$$\n使得 $p(x,y) = v(x,y)^\\top G v(x,y)$。匹配系数可以得到 $\\{g_{ij}\\}$ 和 $\\{a_{ij}\\}$ 之间的线性关系。具体来说，展开 $v^\\top G v$ 会得到 $x^2$、$y^2$ 和 $xy$ 的系数分别为 $g_{11}$、$g_{22}$ 和 $2 g_{12}$；类似地，$2 g_{01}$ 和 $2 g_{02}$ 对应于 $x$ 和 $y$ 的系数，$g_{00}$ 对应于常数项。因此，可以直接从 $p(x,y)$ 的系数构建 $G$。多项式 $p(x,y)$ 是SOS多项式当且仅当 $G \\succeq 0$，即 $G$ 是半正定的。对于二次多项式，这种等价性是精确的，因为二次多项式的SOS是线性多项式的平方和，这可以由线性单项式基上的半正定 (PSD) 格拉姆矩阵精确捕捉。\n\n算法设计：\n1. 对每个测试用例，根据给定的参数 $(c_x, c_y, R)$ 计算 $B$ 和 $\\nabla B$，然后根据具体情况指定 $\\mathbf{f}$。\n2. 计算 $p_0(x,y) = \\nabla B(x,y) \\cdot \\mathbf{f}(x,y)$。\n3. 对于步长为 $0.05$ 的 $\\lambda \\in [-10, 10]$ 网格，构造 $p(x,y) = p_0(x,y) - \\lambda B(x,y)$ 并通过直接代数展开计算其系数向量 $(a_{20}, a_{11}, a_{02}, a_{10}, a_{01}, a_{00})$。\n4. 根据上述方法由这些系数构建格拉姆矩阵 $G$，并通过检查 $G$ 的所有特征值在数值公差范围内是否非负来测试 $G$ 是否为半正定。如果任何一个 $\\lambda$ 能得到一个半正定 $G$，则存在一个常数 $\\lambda$ 使得 $p(x,y)$ 成为SOS多项式，并且势垒证书条件在边界上成立。\n5. 为每个测试用例返回一个表示成功的布尔值。\n\n各用例的原理证明：\n- 在 $\\mathbf{f} = \\nabla B$ 的情况下，方向导数为 $\\nabla B \\cdot \\nabla B = \\|\\nabla B\\|^2$，根据其构造就是一个平方和。当 $\\lambda = 0$ 时，$p$ 是SOS多项式，边界条件成立，从而证明了 $\\mathcal{S}$ 的前向不变性。\n- 在 $\\mathbf{f} = J \\nabla B$ 的情况下，正交性意味着 $\\nabla B \\cdot J \\nabla B = 0$，因此 $p(x,y) = -\\lambda B(x,y)$。选择 $\\lambda = 0$ 得到 $p \\equiv 0$，这是一个SOS多项式。边界条件 $\\dot{B} = 0$ 成立。\n- 在 $\\mathbf{f} = -\\nabla B$ 的情况下，我们有 $\\nabla B \\cdot \\mathbf{f} = -\\|\\nabla B\\|^2$，它在边界 $B = 0$ 上是严格为负的（因为在圆上 $\\|\\nabla B\\| \\neq 0$）。因此对于任何 $\\lambda$，$p|_{B=0} = -\\|\\nabla B\\|^2  0$，无法通过 $p(x,y)$ 获得SOS证书；算法将正确地报告失败。\n- 在平移的情况下 $\\mathbf{f} = \\nabla B + J \\nabla B$，旋转分量在与 $\\nabla B$ 的点积下消失，所以 $p_0 = \\|\\nabla B\\|^2$，与第一种情况一样，$\\lambda = 0$ 就足以证明其为SOS多项式。\n\n该程序明确实现了二次多项式的格拉姆矩阵方法，对 $\\lambda$ 进行标量搜索，并为四种情况返回一个布尔值列表。最终输出是包含在方括号中的、以逗号分隔的布尔结果的单行文本。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gram_from_quadratic_coeffs(a20, a11, a02, a10, a01, a00):\n    \"\"\"\n    Construct the Gram matrix G for the quadratic polynomial\n    p(x,y) = a20*x^2 + a11*x*y + a02*y^2 + a10*x + a01*y + a00\n    with basis v = [1, x, y]^T, so that p(x,y) = v^T G v.\n\n    Expansion yields:\n    v^T G v = G00 + 2*G01*x + 2*G02*y + G11*x^2 + 2*G12*x*y + G22*y^2\n\n    Matching coefficients:\n    G11 = a20\n    G22 = a02\n    G12 = a11 / 2\n    G01 = a10 / 2\n    G02 = a01 / 2\n    G00 = a00\n    \"\"\"\n    G00 = a00\n    G01 = a10 / 2.0\n    G02 = a01 / 2.0\n    G11 = a20\n    G12 = a11 / 2.0\n    G22 = a02\n    G = np.array([[G00, G01, G02],\n                  [G01, G11, G12],\n                  [G02, G12, G22]], dtype=float)\n    return G\n\ndef is_psd(G, tol=1e-10):\n    \"\"\"Check if symmetric matrix G is positive semidefinite by eigenvalues.\"\"\"\n    # Ensure symmetry\n    G_sym = 0.5 * (G + G.T)\n    eigs = np.linalg.eigvalsh(G_sym)\n    return np.min(eigs) = -tol\n\ndef polynomial_coeffs_p0_and_B(cx, cy, R, f_type):\n    \"\"\"\n    Compute the coefficients of p0(x,y) = grad(B) . f(x,y) and B(x,y)\n    for given center (cx, cy), radius R, and f_type.\n\n    B(x,y) = (x - cx)^2 + (y - cy)^2 - R^2\n           = x^2 + y^2 - 2*cx*x - 2*cy*y + (cx^2 + cy^2 - R^2)\n\n    grad B = [2*(x - cx), 2*(y - cy)] = [gx, gy], with gx=2x-2cx, gy=2y-2cy.\n\n    f_type choices:\n    - \"grad\": f = [gx, gy]\n    - \"rot\":  f = [-gy, gx] (J*grad B)\n    - \"neggrad\": f = [-gx, -gy]\n    - \"sum\": f = [gx, gy] + [-gy, gx]\n    \"\"\"\n    # Coefficients of B: a20_B x^2 + a11_B xy + a02_B y^2 + a10_B x + a01_B y + a00_B\n    a20_B = 1.0\n    a11_B = 0.0\n    a02_B = 1.0\n    a10_B = -2.0 * cx\n    a01_B = -2.0 * cy\n    a00_B = cx * cx + cy * cy - R * R\n\n    # Define gx and gy symbolic structure; we will expand gx^2, gy^2 as needed.\n    # gx = 2x - 2cx; gy = 2y - 2cy.\n\n    # Compute p0 = grad(B) . f\n    if f_type == \"grad\":\n        # p0 = gx^2 + gy^2 = 4[(x - cx)^2 + (y - cy)^2]\n        # Expand:\n        a20_p0 = 4.0\n        a11_p0 = 0.0\n        a02_p0 = 4.0\n        a10_p0 = -8.0 * cx\n        a01_p0 = -8.0 * cy\n        a00_p0 = 4.0 * (cx * cx + cy * cy)\n    elif f_type == \"rot\":\n        # p0 = gx*(-gy) + gy*gx = -gx*gy + gy*gx = 0\n        a20_p0 = 0.0\n        a11_p0 = 0.0\n        a02_p0 = 0.0\n        a10_p0 = 0.0\n        a01_p0 = 0.0\n        a00_p0 = 0.0\n    elif f_type == \"neggrad\":\n        # p0 = -gx^2 - gy^2 = -4[(x - cx)^2 + (y - cy)^2]\n        a20_p0 = -4.0\n        a11_p0 = 0.0\n        a02_p0 = -4.0\n        a10_p0 = 8.0 * cx\n        a01_p0 = 8.0 * cy\n        a00_p0 = -4.0 * (cx * cx + cy * cy)\n    elif f_type == \"sum\":\n        # p0 = gx^2 + gy^2 + (gx*(-gy) + gy*gx) = gx^2 + gy^2\n        a20_p0 = 4.0\n        a11_p0 = 0.0\n        a02_p0 = 4.0\n        a10_p0 = -8.0 * cx\n        a01_p0 = -8.0 * cy\n        a00_p0 = 4.0 * (cx * cx + cy * cy)\n    else:\n        raise ValueError(\"Unsupported f_type\")\n\n    p0_coeffs = (a20_p0, a11_p0, a02_p0, a10_p0, a01_p0, a00_p0)\n    B_coeffs = (a20_B, a11_B, a02_B, a10_B, a01_B, a00_B)\n    return p0_coeffs, B_coeffs\n\ndef exists_lambda_making_p_sos(cx, cy, R, f_type, lam_min=-10.0, lam_max=10.0, lam_step=0.05, psd_tol=1e-10):\n    \"\"\"\n    Search for a constant lambda in [lam_min, lam_max] such that\n    p(x,y) = p0(x,y) - lambda * B(x,y) is SOS (quadratic Gram PSD test).\n    \"\"\"\n    p0_coeffs, B_coeffs = polynomial_coeffs_p0_and_B(cx, cy, R, f_type)\n    a20_p0, a11_p0, a02_p0, a10_p0, a01_p0, a00_p0 = p0_coeffs\n    a20_B,  a11_B,  a02_B,  a10_B,  a01_B,  a00_B  = B_coeffs\n\n    # Prepare lambda grid\n    n_steps = int(round((lam_max - lam_min) / lam_step)) + 1\n    # Ensure inclusion of lam=0 even with floating point roundup\n    lambdas = np.linspace(lam_min, lam_max, n_steps)\n\n    for lam in lambdas:\n        # p = p0 - lam * B\n        a20 = a20_p0 - lam * a20_B\n        a11 = a11_p0 - lam * a11_B\n        a02 = a02_p0 - lam * a02_B\n        a10 = a10_p0 - lam * a10_B\n        a01 = a01_p0 - lam * a01_B\n        a00 = a00_p0 - lam * a00_B\n\n        G = gram_from_quadratic_coeffs(a20, a11, a02, a10, a01, a00)\n        if is_psd(G, tol=psd_tol):\n            return True\n    return False\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (cx, cy, R, f_type)\n    test_cases = [\n        (0.0,  0.0, 1.0, \"grad\"),     # Test case 1: happy path\n        (0.0,  0.0, 1.0, \"rot\"),      # Test case 2: boundary case (rotation)\n        (0.0,  0.0, 1.0, \"neggrad\"),  # Test case 3: significant edge case (failure)\n        (1.0, -0.5, 0.75, \"sum\"),     # Test case 4: shifted obstacle, general case\n    ]\n\n    results = []\n    for cx, cy, R, f_type in test_cases:\n        feasible = exists_lambda_making_p_sos(cx, cy, R, f_type,\n                                              lam_min=-10.0, lam_max=10.0,\n                                              lam_step=0.05, psd_tol=1e-10)\n        results.append(feasible)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}