{
    "hands_on_practices": [
        {
            "introduction": "Verifying properties of systems with infinite states often begins by creating a finite abstraction that captures the essential dynamics. This practice guides you through the fundamental process of converting a simple cyber-physical system into a discrete model known as a Kripke structure. By constructing this abstraction and searching for a path to a goal state while avoiding unsafe regions, you will directly apply the core principles that underpin automated model checking .",
            "id": "4238602",
            "problem": "Consider a one-dimensional discrete-time Cyber-Physical System (CPS) with dynamics given by $x_{k+1} = f(x_{k}, u_{k}) = x_{k} + u_{k}$, where the state space is $X = [0,6]$ and the control input set is $U = \\{0,1,2\\}$. Partition $X$ into the following regions: for $i \\in \\{0,1,2,3,4\\}$, define $R_{i} = [i, i+1)$ and define $R_{5} = [5,6]$. Introduce Atomic Propositions (AP) as follows: for each $i \\in \\{0,1,2,3,4,5\\}$, $r_{i}$ denotes membership in $R_{i}$; $g$ denotes the goal region $R_{5}$; $\\mathit{unsafe}$ denotes the unsafe region $R_{3}$; and $\\mathit{safe}$ denotes the complement of $R_{3}$ within $X$. The initial region is $R_{0}$. Use the standard definition of a Kripke structure $K = (S, S_{0}, R, AP, L)$ where $S$ is a finite set of abstract states, $S_{0} \\subseteq S$ is the set of initial states, $R \\subseteq S \\times S$ is a total transition relation induced by the dynamics and inputs, $AP$ is a finite set of atomic propositions, and $L: S \\to 2^{AP}$ is a labeling function.\n\nConstruct the finite Kripke structure abstraction by taking $S = \\{0,1,2,3,4,5\\}$ with state $i$ representing region $R_{i}$, $S_{0} = \\{0\\}$, and define $(i,j) \\in R$ if and only if there exists $x \\in R_{i}$ and $u \\in U$ such that $x + u \\in R_{j}$. Specify explicitly the labeling function $L$ on $S$ in closed form in terms of $i$ using set operations.\n\nUsing this Kripke structure, determine the minimal number of discrete steps $k_{\\min}$ such that there exists a path starting from the initial state that reaches a state labeled by $g$ while avoiding all states labeled by $\\mathit{unsafe}$ at all intermediate steps. Provide your final answer as the single integer $k_{\\min}$. No rounding is required.",
            "solution": "The problem statement is analyzed and found to be valid. It is a well-posed problem in the domain of reachability analysis for Cyber-Physical Systems, providing a complete and consistent set of definitions and constraints to construct a finite abstraction and solve a safety-constrained reachability query.\n\nThe task is to construct a Kripke structure for the given discrete-time system and then find the minimum number of steps $k_{\\min}$ to reach a goal region from an initial region while avoiding an unsafe region.\n\nThe components of the Kripke structure $K = (S, S_{0}, R, AP, L)$ are defined as follows:\n\n1.  **Set of abstract states, $S$**: The problem defines $S = \\{0, 1, 2, 3, 4, 5\\}$. Each state $i \\in S$ is an abstraction of the continuous region $R_i$.\n\n2.  **Set of initial states, $S_{0}$**: The initial region is $R_0$, so the set of initial abstract states is $S_{0} = \\{0\\}$.\n\n3.  **Set of Atomic Propositions, $AP$**: The problem defines $AP = \\{r_0, r_1, r_2, r_3, r_4, r_5, g, \\mathit{unsafe}, \\mathit{safe}\\}$.\n\n4.  **Labeling function, $L: S \\to 2^{AP}$**: The labeling function $L$ maps each abstract state $i$ to the set of atomic propositions that are true in the corresponding region $R_i$.\n    -   $r_i$ is true if the state is in $R_i$. This means $r_i \\in L(i)$ for all $i \\in S$.\n    -   $g$ is true for the goal region $R_5$. This means $g \\in L(5)$.\n    -   $\\mathit{unsafe}$ is true for the unsafe region $R_3$. This means $\\mathit{unsafe} \\in L(3)$.\n    -   $\\mathit{safe}$ is true for the complement of $R_3$, which corresponds to regions $R_0, R_1, R_2, R_4, R_5$. This means $\\mathit{safe} \\in L(i)$ for $i \\in \\{0, 1, 2, 4, 5\\}$.\n\n    We can specify $L$ for each state:\n    -   $L(0) = \\{r_{0}, \\mathit{safe}\\}$\n    -   $L(1) = \\{r_{1}, \\mathit{safe}\\}$\n    -   $L(2) = \\{r_{2}, \\mathit{safe}\\}$\n    -   $L(3) = \\{r_{3}, \\mathit{unsafe}\\}$\n    -   $L(4) = \\{r_{4}, \\mathit{safe}\\}$\n    -   $L(5) = \\{r_{5}, g, \\mathit{safe}\\}$\n\n    In closed form using set operations and piecewise definition, for any $i \\in S$:\n    $$ L(i) = \\{r_i\\} \\cup \\begin{cases} \\{g, \\mathit{safe}\\} & \\text{if } i=5 \\\\ \\{\\mathit{unsafe}\\} & \\text{if } i=3 \\\\ \\{\\mathit{safe}\\} & \\text{if } i \\in \\{0, 1, 2, 4\\} \\end{cases} $$\n\n5.  **Transition relation, $R \\subseteq S \\times S$**: The transition $(i, j) \\in R$ exists if and only if there is a state $x \\in R_i$ and a control input $u \\in U$ such that the next state $x_{k+1} = x + u$ is in $R_j$. This is equivalent to checking if the set of reachable continuous states from $R_i$, denoted $R_i + U$, has a non-empty intersection with $R_j$.\n    The set of reachable continuous states from $R_i$ is $Post(R_i) = \\{x+u \\mid x \\in R_i, u \\in U\\}$.\n\n    Let's compute the transition relation for each state $i \\in S$:\n    -   For $i \\in \\{0,1,2,3,4\\}$, $R_i = [i, i+1)$. $U=\\{0,1,2\\}$.\n        $Post(R_i) = [i, i+1) + \\{0,1,2\\} = [i, i+1) \\cup [i+1, i+2) \\cup [i+2, i+3) = [i, i+3)$.\n    -   For $i=5$, $R_5 = [5,6]$.\n        $Post(R_5) = [5,6] + \\{0,1,2\\} = [5,6] \\cup [6,7] \\cup [7,8] = [5,8]$.\n\n    Now we check for intersections with $R_j$:\n    -   From state $i=0$: $Post(R_0) = [0,3)$. This intersects $R_0=[0,1)$, $R_1=[1,2)$, and $R_2=[2,3)$. So, transitions from state $0$ are to $\\{0, 1, 2\\}$.\n    -   From state $i=1$: $Post(R_1) = [1,4)$. This intersects $R_1=[1,2)$, $R_2=[2,3)$, and $R_3=[3,4)$. So, transitions from state $1$ are to $\\{1, 2, 3\\}$.\n    -   From state $i=2$: $Post(R_2) = [2,5)$. This intersects $R_2=[2,3)$, $R_3=[3,4)$, and $R_4=[4,5)$. So, transitions from state $2$ are to $\\{2, 3, 4\\}$.\n    -   From state $i=3$: $Post(R_3) = [3,6)$. This intersects $R_3=[3,4)$, $R_4=[4,5)$, and $R_5=[5,6]$. So, transitions from state $3$ are to $\\{3, 4, 5\\}$.\n    -   From state $i=4$: $Post(R_4) = [4,7)$. This intersects $R_4=[4,5)$ and $R_5=[5,6]$. So, transitions from state $4$ are to $\\{4, 5\\}$.\n    -   From state $i=5$: $Post(R_5) = [5,8]$. This intersects only $R_5=[5,6]$ within the defined state space. So, the only transition from state $5$ is to itself, $\\{5\\}$.\n\n    The transition relation $R$ can be summarized as an adjacency list:\n    -   $0 \\to \\{0, 1, 2\\}$\n    -   $1 \\to \\{1, 2, 3\\}$\n    -   $2 \\to \\{2, 3, 4\\}$\n    -   $3 \\to \\{3, 4, 5\\}$\n    -   $4 \\to \\{4, 5\\}$\n    -   $5 \\to \\{5\\}$\n\nNow, we must find the minimal number of discrete steps $k_{\\min}$ to reach a state labeled by $g$ while avoiding all states labeled by $\\mathit{unsafe}$.\n-   Initial state: $s_0 = 0$.\n-   Goal states (labeled with $g$): $S_g = \\{5\\}$.\n-   Unsafe states (labeled with $\\mathit{unsafe}$): $S_u = \\{3\\}$.\n\nThe problem is to find the shortest path from state $0$ to state $5$ in the graph defined by $(S, R)$, such that no intermediate state on the path is in $S_u$. We can solve this by performing a Breadth-First Search (BFS) on the \"safe\" subgraph, which is obtained by removing the unsafe state $S_u=\\{3\\}$ and all incident edges.\n\nThe set of safe states is $S_{\\mathit{safe}} = S \\setminus S_u = \\{0, 1, 2, 4, 5\\}$.\nThe safe transition relation $R_{\\mathit{safe}}$ contains only transitions between states in $S_{\\mathit{safe}}$:\n-   From $0$: $\\{0, 1, 2\\}$ are all safe.\n-   From $1$: Neighbors are $\\{1, 2, 3\\}$. The safe neighbors are $\\{1, 2\\}$.\n-   From $2$: Neighbors are $\\{2, 3, 4\\}$. The safe neighbors are $\\{2, 4\\}$.\n-   From $4$: Neighbors are $\\{4, 5\\}$. Both are safe.\n-   From $5$: Neighbor is $\\{5\\}$, which is safe.\n\nThe safe transition relation $R_{\\mathit{safe}}$ is:\n-   $0 \\to \\{0, 1, 2\\}$\n-   $1 \\to \\{1, 2\\}$\n-   $2 \\to \\{2, 4\\}$\n-   $4 \\to \\{4, 5\\}$\n-   $5 \\to \\{5\\}$\n\nWe perform BFS starting from $s_0=0$ to find the shortest path to $S_g=\\{5\\}$:\n-   **Step $k=0$**: The queue is initialized with the start state. $Q = [0]$. The set of visited states is $V=\\{0\\}$.\n-   **Step $k=1$**: Dequeue $0$. Its neighbors are $\\{0, 1, 2\\}$.\n    -   $0$ is already in $V$.\n    -   Add $1$ to $Q$ and $V$.\n    -   Add $2$ to $Q$ and $V$.\n    -   $Q=[1, 2]$, $V=\\{0, 1, 2\\}$. The distance to states $1$ and $2$ is $1$.\n-   **Step $k=2$**:\n    -   Dequeue $1$. Its neighbors are $\\{1, 2\\}$, both are in $V$.\n    -   Dequeue $2$. Its neighbors are $\\{2, 4\\}$.\n        -   $2$ is in $V$.\n        -   Add $4$ to $Q$ and $V$.\n    -   $Q=[4]$, $V=\\{0, 1, 2, 4\\}$. The distance to state $4$ is $2$. A path is $0 \\to 2 \\to 4$.\n-   **Step $k=3$**:\n    -   Dequeue $4$. Its neighbors are $\\{4, 5\\}$.\n        -   $4$ is in $V$.\n        -   The state $5$ is the goal state. We have found the shortest path.\n    -   The length of the path is $3$. A possible path is $0 \\to 2 \\to 4 \\to 5$.\n\nThe minimal number of discrete steps is $3$. This corresponds to a control sequence. For instance:\n1.  From $R_0$, apply $u=2$. If $x_0 \\in [0,1)$, $x_1 = x_0+2 \\in [2,3) = R_2$. (Step 1, state is $2$)\n2.  From $R_2$, apply $u=2$. If $x_1 \\in [2,3)$, $x_2 = x_1+2 \\in [4,5) = R_4$. (Step 2, state is $4$)\n3.  From $R_4$, apply $u=1$. If $x_2 \\in [4,5)$, $x_3 = x_2+1 \\in [5,6) \\subseteq R_5$. (Step 3, state is $5$, goal reached)\n\nThe minimal number of steps $k_{\\min}$ is $3$.",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "In set-based reachability analysis, the choice of geometric representation for over-approximating reachable sets is critical for computational efficiency. This exercise provides a hands-on comparison between two common representations—zonotopes and ellipsoids—by analyzing how tightly they bound the one-step reachable set for different input models. Calculating the exact area ratios reveals fundamental geometric trade-offs that are independent of the specific system dynamics, offering key insights for designing effective verification algorithms .",
            "id": "4238580",
            "problem": "A two-dimensional discrete-time Linear Time-Invariant (LTI) system in a Digital Twin (DT) and Cyber-Physical System (CPS) context is given by $x_{k+1} = A x_{k} + B u_{k}$, where $x_{k} \\in \\mathbb{R}^{2}$, $u_{k} \\in \\mathbb{R}^{2}$, $A \\in \\mathbb{R}^{2 \\times 2}$, and $B \\in \\mathbb{R}^{2 \\times 2}$ is invertible. A DT uses reachability analysis for safety and liveness by constructing over-approximations of one-step input-induced reachable sets. Two bounded-input models are considered:\n- An $L_{\\infty}$-bounded input set $U_{\\infty} = \\{ u \\in \\mathbb{R}^{2} : \\|u\\|_{\\infty} \\leq 1 \\}$,\n- An $L_{2}$-bounded input set $U_{2} = \\{ u \\in \\mathbb{R}^{2} : \\|u\\|_{2} \\leq 1 \\}$.\n\nThe one-step input-induced reachable sets are $S_{\\infty} = B U_{\\infty}$ and $S_{2} = B U_{2}$. Consider two over-approximation families:\n- Zonotopic over-approximations with two generators aligned with the columns of $B$, i.e., the set $Z = B([-1,1]^{2})$.\n- Ellipsoidal over-approximations using the minimum-volume enclosing ellipsoid (Löwner ellipsoid).\n\nFor the $L_{\\infty}$ case, compare the minimum-volume enclosing ellipsoid of $S_{\\infty}$ to the zonotope $Z$, and for the $L_{2}$ case, compare the zonotope $Z$ to the minimum-volume enclosing ellipsoid of $S_{2}$. Using only foundational geometric and linear-algebraic facts about linear transformations, convex bodies, and volumes, derive the exact ratios\n$$r_{\\infty} = \\frac{\\operatorname{area}(\\text{minimum-volume ellipsoid containing } S_{\\infty})}{\\operatorname{area}(Z)} \\quad \\text{and} \\quad r_{2} = \\frac{\\operatorname{area}(Z)}{\\operatorname{area}(\\text{minimum-volume ellipsoid containing } S_{2})}.$$\n\nProvide the final answer as a single row matrix containing $r_{\\infty}$ and $r_{2}$, in exact analytic form. No rounding is required and no units should be used. The comparison must be based on the one-step input-induced reachable sets and must not assume any special structure of $A$ beyond dimensional consistency.",
            "solution": "The problem as stated is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The concepts presented are standard in the fields of control theory, convex optimization, and reachability analysis for cyber-physical systems. Therefore, the problem is valid, and a full solution is warranted.\n\nThe problem asks for the computation of two ratios, $r_{\\infty}$ and $r_{2}$, which quantify the tightness of different set-based over-approximations for one-step reachable sets of a discrete-time LTI system.\n\nThe system is given by $x_{k+1} = A x_{k} + B u_{k}$. The one-step input-induced reachable sets from the origin are of the form $B U$, where $U$ is the set of admissible inputs. The matrix $B \\in \\mathbb{R}^{2 \\times 2}$ is invertible, which implies $\\det(B) \\neq 0$. A key property of linear transformations is that for a measurable set $K \\subset \\mathbb{R}^{2}$, the area of its image under the transformation $B$ is given by $\\operatorname{area}(B(K)) = |\\det(B)| \\operatorname{area}(K)$.\n\nLet us first analyze the sets involved:\n1.  The input set $U_{\\infty} = \\{ u \\in \\mathbb{R}^{2} : \\|u\\|_{\\infty} \\leq 1 \\}$ is the square $[-1,1] \\times [-1,1]$ in $\\mathbb{R}^{2}$. Its area is $\\operatorname{area}(U_{\\infty}) = (1 - (-1)) \\times (1 - (-1)) = 2 \\times 2 = 4$.\n2.  The input set $U_{2} = \\{ u \\in \\mathbb{R}^{2} : \\|u\\|_{2} \\leq 1 \\}$ is the unit disk centered at the origin. Its area is $\\operatorname{area}(U_{2}) = \\pi (1)^{2} = \\pi$.\n3.  The reachable set $S_{\\infty} = B U_{\\infty}$ is the image of the square $U_{\\infty}$ under the linear map $B$. Since $B$ is a linear transformation, $S_{\\infty}$ is a parallelogram centered at the origin. Its area is $\\operatorname{area}(S_{\\infty}) = |\\det(B)| \\operatorname{area}(U_{\\infty}) = 4|\\det(B)|$.\n4.  The reachable set $S_{2} = B U_{2}$ is the image of the unit disk $U_{2}$ under the linear map $B$. The image of an ellipse (a circle is a special case) under a linear transformation is another ellipse. Thus, $S_{2}$ is an ellipse centered at the origin. Its area is $\\operatorname{area}(S_{2}) = |\\det(B)| \\operatorname{area}(U_{2}) = \\pi|\\det(B)|$.\n5.  The zonotope $Z = B([-1,1]^{2})$ is, by definition, the same set as $S_{\\infty}$. Thus, $Z = S_{\\infty}$.\n\nWe now compute the two required ratios.\n\n**Calculation of $r_{\\infty}$**\n\nThe ratio $r_{\\infty}$ is defined as:\n$$r_{\\infty} = \\frac{\\operatorname{area}(\\text{minimum-volume ellipsoid containing } S_{\\infty})}{\\operatorname{area}(Z)}$$\nAs established, $Z = S_{\\infty}$. Let $E_{\\text{out}}(K)$ denote the minimum-volume enclosing ellipsoid (also known as the Löwner-John ellipsoid) of a convex body $K$. The expression for $r_{\\infty}$ simplifies to:\n$$r_{\\infty} = \\frac{\\operatorname{area}(E_{\\text{out}}(S_{\\infty}))}{\\operatorname{area}(S_{\\infty})}$$\nA fundamental property of the Löwner-John ellipsoid is that the ratio of the volume of $E_{\\text{out}}(K)$ to the volume of $K$ is invariant under non-singular affine transformations. Since $S_{\\infty} = B(U_{\\infty})$ and $B$ is invertible, we have $E_{\\text{out}}(S_{\\infty}) = E_{\\text{out}}(B(U_{\\infty})) = B(E_{\\text{out}}(U_{\\infty}))$. Therefore, the ratio can be computed using the base set $U_{\\infty}$:\n$$r_{\\infty} = \\frac{\\operatorname{area}(E_{\\text{out}}(B(U_{\\infty})))}{\\operatorname{area}(B(U_{\\infty}))} = \\frac{\\operatorname{area}(B(E_{\\text{out}}(U_{\\infty})))}{\\operatorname{area}(B(U_{\\infty}))} = \\frac{|\\det(B)| \\operatorname{area}(E_{\\text{out}}(U_{\\infty}))}{|\\det(B)| \\operatorname{area}(U_{\\infty})} = \\frac{\\operatorname{area}(E_{\\text{out}}(U_{\\infty}))}{\\operatorname{area}(U_{\\infty})}$$\nWe need to find the minimum-area ellipse enclosing the square $U_{\\infty} = [-1,1]^2$. By symmetry, the minimum-area enclosing ellipse is the circumscribed circle of the square. The vertices of the square are $(\\pm 1, \\pm 1)$. The distance from the origin to any vertex is $\\sqrt{1^2 + 1^2} = \\sqrt{2}$. Thus, the circumscribed circle is centered at the origin and has a radius $R = \\sqrt{2}$.\nThe area of this enclosing circle (which is an ellipse) is $\\operatorname{area}(E_{\\text{out}}(U_{\\infty})) = \\pi R^2 = \\pi (\\sqrt{2})^2 = 2\\pi$.\nThe area of the square $U_{\\infty}$ is $4$.\nThe ratio is therefore:\n$$r_{\\infty} = \\frac{2\\pi}{4} = \\frac{\\pi}{2}$$\nThis is the classic John's theorem result for a parallelogram in $\\mathbb{R}^2$.\n\n**Calculation of $r_{2}$**\n\nThe ratio $r_{2}$ is defined as:\n$$r_{2} = \\frac{\\operatorname{area}(Z)}{\\operatorname{area}(\\text{minimum-volume ellipsoid containing } S_{2})}$$\nLet us compute the areas of the numerator and the denominator.\nThe numerator is $\\operatorname{area}(Z)$. As determined earlier, $Z = S_{\\infty} = B(U_{\\infty})$, so its area is:\n$$\\operatorname{area}(Z) = \\operatorname{area}(B(U_{\\infty})) = |\\det(B)| \\operatorname{area}(U_{\\infty}) = 4|\\det(B)|$$\nThe denominator is the area of the minimum-volume ellipsoid containing $S_{2}$, which is $\\operatorname{area}(E_{\\text{out}}(S_{2}))$. The set $S_{2} = B(U_{2})$ is the image of the unit disk $U_{2}$ under the transformation $B$. As the linear image of an ellipse, $S_{2}$ is itself an ellipse. The minimum-volume enclosing ellipsoid of an ellipse is the ellipse itself. Hence, $E_{\\text{out}}(S_{2}) = S_{2}$.\nThe area of the denominator is therefore $\\operatorname{area}(S_2)$:\n$$\\operatorname{area}(S_{2}) = \\operatorname{area}(B(U_{2})) = |\\det(B)| \\operatorname{area}(U_{2}) = |\\det(B)| \\pi$$\nNow we can compute the ratio $r_{2}$:\n$$r_{2} = \\frac{\\operatorname{area}(Z)}{\\operatorname{area}(S_{2})} = \\frac{4|\\det(B)|}{\\pi|\\det(B)|}$$\nSince $B$ is invertible, $\\det(B) \\neq 0$, so we can cancel the term $|\\det(B)|$:\n$$r_{2} = \\frac{4}{\\pi}$$\nThe two requested ratios are $r_{\\infty} = \\frac{\\pi}{2}$ and $r_{2} = \\frac{4}{\\pi}$. They are fundamental constants that do not depend on the specific choice of the invertible matrix $B$.",
            "answer": "$$\\boxed{\\begin{pmatrix} \\frac{\\pi}{2} & \\frac{4}{\\pi} \\end{pmatrix}}$$"
        },
        {
            "introduction": "Moving from theory to practice, this exercise involves implementing the computational engine for reachability analysis of linear systems using support functions. You will translate the elegant properties of convex sets and linear transformations into a working algorithm that can handle various set representations for initial states and inputs. This hands-on coding task solidifies the understanding of how abstract mathematical concepts provide a powerful and versatile foundation for building practical safety verification tools .",
            "id": "4238587",
            "problem": "You are given a linear time-invariant continuous-time system in the context of Digital Twin (DT) models of Cyber-Physical Systems (CPS). The state evolves according to the ordinary differential equation $\\dot{x} = A x + B u$, where $x \\in \\mathbb{R}^n$ is the state, $u \\in \\mathbb{R}^m$ is the control input taking values in a compact convex set $U \\subset \\mathbb{R}^m$, $A \\in \\mathbb{R}^{n \\times n}$, and $B \\in \\mathbb{R}^{n \\times m}$. The initial state belongs to a compact convex set $X_0 \\subset \\mathbb{R}^n$. The goal is to compute the support function of the reachable set at a fixed time $t$, in a given direction $l \\in \\mathbb{R}^n$, using a principled construction derived from fundamental facts without shortcuts.\n\nThe fundamental base you must use is limited to the following:\n- The variation-of-constants solution of linear ordinary differential equations: for any $t \\ge 0$, the solution satisfies $x(t) = e^{A t} x(0) + \\int_0^t e^{A (t - \\tau)} B u(\\tau)\\, d\\tau$.\n- The definition of the support function of a compact convex set: for any compact convex set $S \\subset \\mathbb{R}^k$, the support function in direction $l \\in \\mathbb{R}^k$ is $h_S(l) = \\sup_{s \\in S} \\langle l, s \\rangle$.\n- The Minkowski sum of sets and its basic properties.\n\nYou must implement a method that, given $(A,B)$, $X_0$, $U$, $t$, and $l$, returns a numerical approximation of the support function of the convex reachable set in direction $l$ at time $t$ based on the principle that convex set images under linear operators and Minkowski integrals are handled via their support functions. Your algorithm must rely solely on these principles and the definition of the support function. You must not invoke any shortcut formulas or pre-provided results beyond these fundamentals.\n\nIn your implementation, you must handle input sets $U$ specified as any of the following convex representations:\n- A box specified by lower and upper bounds $[u_{\\min}, u_{\\max}] \\subset \\mathbb{R}^m$, where $u_{\\min}, u_{\\max} \\in \\mathbb{R}^m$ with $u_{\\min} \\le u_{\\max}$ componentwise.\n- An Euclidean ball centered at the origin with radius $r \\in \\mathbb{R}_{\\ge 0}$, that is $\\{u \\in \\mathbb{R}^m : \\|u\\|_2 \\le r\\}$.\n- A convex polytope specified by a finite set of vertices $\\{v_i\\}_{i=1}^N \\subset \\mathbb{R}^m$ whose convex hull is $U$.\n\nYou must also handle initial sets $X_0$ specified as any of the following convex representations:\n- A box specified by lower and upper bounds $[x_{\\min}, x_{\\max}] \\subset \\mathbb{R}^n$.\n- An Euclidean ball centered at the origin with radius $r_0 \\in \\mathbb{R}_{\\ge 0}$.\n- A convex polytope specified by a finite set of vertices in $\\mathbb{R}^n$.\n\nYour numerical method should use a principled quadrature rule to approximate the time integral that arises from the contribution of $U$ to the reachable set. Angles are not involved in this problem, and no physical units are required because the problem is purely mathematical. The output for each test case must be a single real number (a float), which is the support function value in the prescribed direction.\n\nTest suite:\nFor each test case, compute the support function in the specified direction $l$ at time $t$ for the given $(A,B)$, $X_0$, and $U$. Use the following five test cases:\n\n- Test case $1$ (happy path, two-dimensional stable system, non-symmetric box input):\n  - $A = \\begin{bmatrix} -0.5 & 0.2 \\\\ -0.1 & -0.3 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n  - $X_0$ is a box with $x_{\\min} = \\begin{bmatrix} -0.5 \\\\ -0.5 \\end{bmatrix}$ and $x_{\\max} = \\begin{bmatrix} 0.5 \\\\ 0.5 \\end{bmatrix}$,\n  - $U$ is a box with $u_{\\min} = \\begin{bmatrix} -1.0 \\\\ -0.5 \\end{bmatrix}$ and $u_{\\max} = \\begin{bmatrix} 1.0 \\\\ 0.5 \\end{bmatrix}$,\n  - $t = 1.0$,\n  - $l = \\begin{bmatrix} 1.0 \\\\ -0.5 \\end{bmatrix}$.\n\n- Test case $2$ (boundary case: zero input set, propagation of initial set only):\n  - $A = \\begin{bmatrix} -0.5 & 0.2 \\\\ -0.1 & -0.3 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n  - $X_0$ is a box with $x_{\\min} = \\begin{bmatrix} -1.0 \\\\ -1.0 \\end{bmatrix}$ and $x_{\\max} = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$,\n  - $U$ is the singleton $\\{0\\}$ represented as a box with $u_{\\min} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ and $u_{\\max} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n  - $t = 2.0$,\n  - $l = \\begin{bmatrix} 0.3 \\\\ 0.4 \\end{bmatrix}$.\n\n- Test case $3$ (edge case: two-dimensional unstable system, ball input, zero initial set):\n  - $A = \\begin{bmatrix} 0.4 & 0.6 \\\\ 0.0 & 0.2 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}$,\n  - $X_0$ is the singleton $\\{0\\}$ represented as a box with $x_{\\min} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$ and $x_{\\max} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n  - $U$ is an Euclidean ball in $\\mathbb{R}^2$ of radius $r = 0.2$ centered at the origin,\n  - $t = 0.5$,\n  - $l = \\begin{bmatrix} 1.0 \\\\ 1.0 \\end{bmatrix}$.\n\n- Test case $4$ (one-dimensional system, interval input, zero initial set):\n  - $A = \\begin{bmatrix} -1.0 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1.0 \\end{bmatrix}$,\n  - $X_0$ is the singleton $\\{0\\}$ represented as a box with $x_{\\min} = \\begin{bmatrix} 0.0 \\end{bmatrix}$ and $x_{\\max} = \\begin{bmatrix} 0.0 \\end{bmatrix}$,\n  - $U$ is a box (interval) with $u_{\\min} = \\begin{bmatrix} 0.0 \\end{bmatrix}$ and $u_{\\max} = \\begin{bmatrix} 1.0 \\end{bmatrix}$,\n  - $t = 1.5$,\n  - $l = \\begin{bmatrix} 1.0 \\end{bmatrix}$.\n\n- Test case $5$ (three-dimensional stable system, ball initial set, polytope input):\n  - $A = \\begin{bmatrix} -0.2 & 0.1 & 0.0 \\\\ 0.0 & -0.3 & 0.2 \\\\ 0.0 & 0.0 & -0.1 \\end{bmatrix}$,\n  - $B = \\begin{bmatrix} 1.0 & 0.0 \\\\ 0.0 & 1.0 \\\\ 0.5 & 0.5 \\end{bmatrix}$,\n  - $X_0$ is an Euclidean ball in $\\mathbb{R}^3$ of radius $r_0 = 0.1$ centered at the origin,\n  - $U$ is a convex polytope in $\\mathbb{R}^2$ with vertices $\\{ \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\begin{bmatrix} -1 \\\\ 0 \\end{bmatrix}, \\begin{bmatrix} 0 \\\\ -1 \\end{bmatrix} \\}$,\n  - $t = 2.0$,\n  - $l = \\begin{bmatrix} 0.5 \\\\ -0.5 \\\\ 1.0 \\end{bmatrix}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For the above five test cases, the expected output format is $[r_1, r_2, r_3, r_4, r_5]$, where each $r_i$ is the computed support function value (a float) for test case $i$ in the specified direction at the specified time. No other text should be printed.",
            "solution": "The problem is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n- **System Dynamics**: A linear time-invariant continuous-time system described by the ordinary differential equation (ODE) $\\dot{x} = A x + B u$.\n- **State and Input**: The state is $x \\in \\mathbb{R}^n$, and the control input is $u \\in \\mathbb{R}^m$.\n- **State and Input Sets**: The initial state $x(0)$ is in a compact convex set $X_0 \\subset \\mathbb{R}^n$. The control input $u(\\tau)$ for $\\tau \\ge 0$ takes values in a compact convex set $U \\subset \\mathbb{R}^m$.\n- **System Matrices**: $A \\in \\mathbb{R}^{n \\times n}$ and $B \\in \\mathbb{R}^{n \\times m}$.\n- **Fundamental Principles**:\n    1.  **Variation-of-Constants Solution**: For any $t \\ge 0$, the solution to the ODE is $x(t) = e^{A t} x(0) + \\int_0^t e^{A (t - \\tau)} B u(\\tau)\\, d\\tau$.\n    2.  **Support Function Definition**: For a compact convex set $S \\subset \\mathbb{R}^k$, its support function in a direction $l \\in \\mathbb{R}^k$ is $h_S(l) = \\sup_{s \\in S} \\langle l, s \\rangle$.\n    3.  **Minkowski Sum**: The problem requires knowledge of the Minkowski sum of sets and its basic properties.\n- **Goal**: Compute the support function of the reachable set at a fixed time $t$ in a given direction $l \\in \\mathbb{R}^n$.\n- **Set Representations**:\n    - $X_0$ and $U$ can be a box (hyperrectangle), an Euclidean ball at the origin, or a convex polytope defined by its vertices.\n- **Numerical Method**: The implementation must use a principled quadrature rule to approximate the time integral.\n- **Test Cases**: Five specific test cases are provided with matrices $A, B$, set definitions for $X_0$ and $U$, time $t$, and direction $l$.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientific or Factual Unsoundness**: The problem is scientifically and mathematically sound. It is based on fundamental concepts of linear systems theory and convex analysis. The variation-of-constants formula is the correct solution for linear ODEs. The definition of the support function and the concept of a reachable set are standard in control theory and computational geometry. All principles are factually correct.\n2.  **Non-Formalizable or Irrelevant**: The problem is highly formal and directly relevant to the field of reachability analysis for cyber-physical systems, which is a core topic in the specified domain.\n3.  **Incomplete or Contradictory Setup**: The problem is self-contained. For each test case, it provides all necessary components: the system matrices ($A, B$), the definitions of the initial and input sets ($X_0, U$), the time horizon ($t$), and the direction vector ($l$). The specifications for the sets are complete and unambiguous.\n4.  **Unrealistic or Infeasible**: The provided matrices and set parameters are mathematically well-defined and do not represent physically impossible or inconsistent scenarios within the abstract mathematical framework of the problem.\n5.  **Ill-Posed or Poorly Structured**: The problem is well-posed. For an LTI system with compact and convex initial and input sets, the reachable set at any time $t$ is also compact and convex. The support function of a compact set is well-defined and unique for any given direction.\n6.  **Pseudo-Profound, Trivial, or Tautological**: The problem is not trivial. It requires deriving the solution from first principles, combining concepts from linear algebra, differential equations, and convex analysis. It necessitates a non-trivial numerical implementation. Test cases cover a range of scenarios (stable/unstable, different set types, degenerate cases) that test the robustness of the derived method.\n7.  **Outside Scientific Verifiability**: The problem is entirely mathematical, and the results can be verified through analytical calculations (for simple cases like Test Case 4) or comparison with established numerical reachability tools.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is scientifically sound, well-posed, and all necessary information is provided. A solution will be constructed based on the stipulated first principles.\n\n### Solution Derivation\nThe objective is to compute the support function of the reachable set at time $t$, denoted $R(t)$, in a given direction $l \\in \\mathbb{R}^n$. The value to be computed is $h_{R(t)}(l)$.\n\nThe reachable set $R(t)$ is the set of all states $x(t)$ that are solutions to the ODE $\\dot{x} = A x + B u$ with an initial state $x(0) \\in X_0$ and a measurable control input function $u(\\cdot)$ such that $u(\\tau) \\in U$ for all $\\tau \\in [0, t]$.\n\nUsing the provided variation-of-constants formula, any such state $x(t)$ can be written as:\n$$x(t) = e^{A t} x(0) + \\int_0^t e^{A (t - \\tau)} B u(\\tau)\\, d\\tau$$\n\nThe set of all such points $x(t)$ can be expressed using set-theoretic operations. The first term, $e^{A t} x(0)$, corresponds to the linear transformation of the initial set $X_0$. We denote this transformed set by $e^{A t} X_0 = \\{e^{A t} x_0 \\mid x_0 \\in X_0\\}$.\n\nThe second term, the integral, represents the contribution from the control input. The set of all possible values for this integral, considering all admissible control functions $u(\\cdot)$, is the Minkowski integral of the time-varying set $e^{A(t-\\tau)}BU$. This is written as $\\int_0^t e^{A (t - \\tau)} B U \\, d\\tau$.\n\nThe total reachable set $R(t)$ is the Minkowski sum of these two sets:\n$$R(t) = e^{A t} X_0 \\oplus \\int_0^t e^{A (t - \\tau)} B U \\, d\\tau$$\nwhere $\\oplus$ denotes the Minkowski sum, $S_1 \\oplus S_2 = \\{s_1 + s_2 \\mid s_1 \\in S_1, s_2 \\in S_2\\}$.\n\nA fundamental property of support functions is their additivity over the Minkowski sum: $h_{S_1 \\oplus S_2}(l) = h_{S_1}(l) + h_{S_2}(l)$. Applying this property to the expression for $R(t)$:\n$$h_{R(t)}(l) = h_{e^{A t} X_0}(l) + h_{\\int_0^t e^{A (t - \\tau)} B U \\, d\\tau}(l)$$\n\nWe now analyze each term separately based on the provided first principles.\n\n**Term 1: Contribution from the initial set $X_0$**\nThe first term is the support function of a linear transformation of the set $X_0$. For any linear map $M$ and compact convex set $S$, the support function satisfies $h_{M S}(l) = h_S(M^T l)$. In our case, the linear map is $M = e^{A t}$. Its transpose is $M^T = (e^{A t})^T = e^{A^T t}$.\nTherefore, the first term becomes:\n$$h_{e^{A t} X_0}(l) = h_{X_0}((e^{A t})^T l)$$\n\n**Term 2: Contribution from the input set $U$**\nThe second term is the support function of a Minkowski integral. For a time-varying compact convex set $K(\\tau)$, the support function of its Minkowski integral is the integral of its support function: $h_{\\int_0^t K(\\tau) d\\tau}(l) = \\int_0^t h_{K(\\tau)}(l) d\\tau$.\nIn our case, $K(\\tau) = e^{A (t - \\tau)} B U$. The support function of this set is given by:\n$$h_{K(\\tau)}(l) = h_{e^{A (t - \\tau)} B U}(l)$$\nUsing the property for linear transformations again, with $M = e^{A (t - \\tau)} B$, we have:\n$$h_{e^{A (t - \\tau)} B U}(l) = h_U((e^{A (t - \\tau)} B)^T l) = h_U(B^T (e^{A (t-\\tau)})^T l) = h_U(B^T e^{A^T (t-\\tau)} l)$$\nIntegrating this expression from $\\tau=0$ to $t$ gives the second term:\n$$h_{\\int_0^t e^{A (t - \\tau)} B U \\, d\\tau}(l) = \\int_0^t h_U(B^T e^{A^T (t-\\tau)} l) \\, d\\tau$$\n\n**Final Formula and Numerical Implementation**\nCombining both terms, we obtain the exact formula for the support function of the reachable set:\n$$h_{R(t)}(l) = h_{X_0}((e^{A t})^T l) + \\int_0^t h_U(B^T e^{A^T (t-\\tau)} l) \\, d\\tau$$\n\nFor numerical computation, the integral is simplified by a change of variables. Let $s = t - \\tau$. Then $ds = -d\\tau$. The integration limits change from $\\tau \\in [0, t]$ to $s \\in [t, 0]$.\n$$\\int_0^t h_U(B^T e^{A^T (t-\\tau)} l) \\, d\\tau = \\int_t^0 h_U(B^T e^{A^T s} l) \\, (-ds) = \\int_0^t h_U(B^T e^{A^T s} l) \\, ds$$\n\nThe integral is approximated using the trapezoidal rule. We discretize the interval $[0, t]$ into $N_{steps}$ segments of width $\\Delta s = t / N_{steps}$. The grid points are $s_k = k \\Delta s$ for $k = 0, 1, \\dots, N_{steps}$. The integral is approximated as:\n$$\\int_0^t g(s) ds \\approx \\Delta s \\left( \\frac{g(s_0) + g(s_{N_{steps}})}{2} + \\sum_{k=1}^{N_{steps}-1} g(s_k) \\right)$$\nwhere the integrand is $g(s) = h_U(B^T e^{A^T s} l)$.\n\n**Support Function Implementations for Specific Sets**\n\nThe computation requires evaluating the support functions $h_{X_0}$ and $h_U$ for the specific set representations. Let $S$ be a generic compact convex set and $v$ be a direction vector.\n\n1.  **Box**: $S = \\{s \\mid s_{\\min} \\le s \\le s_{\\max}\\}$, where vector inequalities are component-wise.\n    $h_S(v) = \\sup_{s \\in S} \\langle v, s \\rangle = \\sup_{s_{\\min} \\le s \\le s_{\\max}} \\sum_i v_i s_i$. The supremum is achieved by choosing $s_i = s_{i, \\max}$ if $v_i \\ge 0$ and $s_i = s_{i, \\min}$ if $v_i < 0$.\n    $$h_S(v) = \\sum_{i:v_i \\ge 0} v_i s_{i, \\max} + \\sum_{i:v_i < 0} v_i s_{i, \\min}$$\n\n2.  **Euclidean Ball**: $S = \\{s \\in \\mathbb{R}^k : \\|s\\|_2 \\le r\\}$.\n    $h_S(v) = \\sup_{\\|s\\|_2 \\le r} \\langle v, s \\rangle$. By the Cauchy-Schwarz inequality, this supremum is $r \\|v\\|_2$, achieved when $s$ is parallel to $v$.\n    $$h_S(v) = r \\|v\\|_2$$\n\n3.  **Convex Polytope**: $S = \\text{conv}(\\{p_1, \\dots, p_N\\})$, the convex hull of a finite set of vertices.\n    A linear function over a convex polytope attains its maximum at one of the vertices.\n    $$h_S(v) = \\max_{i \\in \\{1, \\dots, N\\}} \\langle v, p_i \\rangle$$\n\nThe algorithm proceeds by computing the term for $X_0$ and then numerically computing the integral for the $U$ term, summing the results. This principled approach adheres strictly to the problem's constraints.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the reachability problem for the five test cases.\n    \"\"\"\n\n    def support_function(set_spec, direction):\n        \"\"\"\n        Computes the support function for a given set and direction.\n\n        Args:\n            set_spec: A tuple (type, params) describing the set.\n            direction: The direction vector l.\n\n        Returns:\n            The value of the support function.\n        \"\"\"\n        set_type, params = set_spec\n        \n        if direction.ndim == 0:\n            direction = np.array([direction])\n\n        if set_type == 'box':\n            min_bounds, max_bounds = params\n            # s_i is max_bounds_i if direction_i >= 0, else min_bounds_i\n            s_star = np.where(direction >= 0, max_bounds, min_bounds)\n            return np.dot(direction, s_star)\n        \n        elif set_type == 'ball':\n            radius = params\n            norm_direction = np.linalg.norm(direction)\n            if norm_direction == 0:\n                return 0.0\n            return radius * norm_direction\n\n        elif set_type == 'polytope':\n            vertices = params\n            if not vertices:\n                return 0.0\n            # sup over s in Conv(V) is max over v in V\n            return max(np.dot(v, direction) for v in vertices)\n        \n        else:\n            raise ValueError(f\"Unknown set type: {set_type}\")\n\n    def compute_reachable_set_support_function(A, B, X0_spec, U_spec, t, l, n_steps=2000):\n        \"\"\"\n        Computes the support function of the reachable set R(t) in direction l.\n\n        Args:\n            A, B: System matrices.\n            X0_spec: Specification for the initial set X0.\n            U_spec: Specification for the input set U.\n            t: Time horizon.\n            l: Direction vector.\n            n_steps: Number of steps for numerical integration.\n\n        Returns:\n            The value h_R(t)(l).\n        \"\"\"\n        # Term 1: Contribution from the initial set X0\n        # h_{exp(At)X0}(l) = h_{X0}(exp(A.T*t) @ l)\n        exp_At_T = expm(A.T * t)\n        l_prime_x0 = exp_At_T @ l\n        h_x0_term = support_function(X0_spec, l_prime_x0)\n        \n        # Term 2: Contribution from the input set U (integral term)\n        # integral from 0 to t of h_U(B.T @ exp(A.T*s) @ l) ds\n        # Use trapezoidal rule for numerical integration.\n        # Change of variables s = t - tau makes it integral from 0 to t.\n        \n        h_u_integral = 0.0\n        if t > 0:\n            ds = t / n_steps\n            integrand_values = []\n            \n            for k in range(n_steps + 1):\n                s = k * ds\n                exp_As_T = expm(A.T * s)\n                l_prime_u = B.T @ exp_As_T @ l\n                integrand_value = support_function(U_spec, l_prime_u)\n                integrand_values.append(integrand_value)\n            \n            # Trapezoidal rule: ds * ( (f(0)+f(t))/2 + sum(f(s_k)) for k=1..n-1 )\n            h_u_integral = ds * ( (integrand_values[0] + integrand_values[-1]) / 2.0 + sum(integrand_values[1:-1]) )\n\n        return h_x0_term + h_u_integral\n\n    test_cases = [\n        { # Test case 1\n            \"A\": np.array([[-0.5, 0.2], [-0.1, -0.3]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"X0_spec\": ('box', (np.array([-0.5, -0.5]), np.array([0.5, 0.5]))),\n            \"U_spec\": ('box', (np.array([-1.0, -0.5]), np.array([1.0, 0.5]))),\n            \"t\": 1.0,\n            \"l\": np.array([1.0, -0.5])\n        },\n        { # Test case 2\n            \"A\": np.array([[-0.5, 0.2], [-0.1, -0.3]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"X0_spec\": ('box', (np.array([-1.0, -1.0]), np.array([1.0, 1.0]))),\n            \"U_spec\": ('box', (np.array([0.0, 0.0]), np.array([0.0, 0.0]))),\n            \"t\": 2.0,\n            \"l\": np.array([0.3, 0.4])\n        },\n        { # Test case 3\n            \"A\": np.array([[0.4, 0.6], [0.0, 0.2]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0]]),\n            \"X0_spec\": ('box', (np.array([0.0, 0.0]), np.array([0.0, 0.0]))),\n            \"U_spec\": ('ball', 0.2),  # radius 0.2\n            \"t\": 0.5,\n            \"l\": np.array([1.0, 1.0])\n        },\n        { # Test case 4\n            \"A\": np.array([[-1.0]]),\n            \"B\": np.array([[1.0]]),\n            \"X0_spec\": ('box', (np.array([0.0]), np.array([0.0]))),\n            \"U_spec\": ('box', (np.array([0.0]), np.array([1.0]))),\n            \"t\": 1.5,\n            \"l\": np.array([1.0])\n        },\n        { # Test case 5\n            \"A\": np.array([[-0.2, 0.1, 0.0], [0.0, -0.3, 0.2], [0.0, 0.0, -0.1]]),\n            \"B\": np.array([[1.0, 0.0], [0.0, 1.0], [0.5, 0.5]]),\n            \"X0_spec\": ('ball', 0.1), # radius 0.1\n            \"U_spec\": ('polytope', [\n                np.array([1.0, 0.0]), np.array([0.0, 1.0]),\n                np.array([-1.0, 0.0]), np.array([0.0, -1.0])\n            ]),\n            \"t\": 2.0,\n            \"l\": np.array([0.5, -0.5, 1.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_reachable_set_support_function(\n            case[\"A\"], case[\"B\"], case[\"X0_spec\"], case[\"U_spec\"], case[\"t\"], case[\"l\"]\n        )\n        results.append(f\"{result:.7f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}