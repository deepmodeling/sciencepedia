{
    "hands_on_practices": [
        {
            "introduction": "差分约束矩阵 (Difference Bound Matrix, DBM) 是表示时钟估值集合（称为“区域”）的关键数据结构。要构建时间自动机的分析工具，必须熟练掌握 DBM 的构建、闭包和求交等操作。本练习  提供了对这些基本操作的动手实践，让您深入理解区域的数学表示，并进一步展示如何在此基础上对系统行为进行优化分析。",
            "id": "4251940",
            "problem": "考虑一个分布式网络物理系统的数字孪生片段，该系统由一个带有两个实值时钟 $x$ 和 $y$ 的时间自动机建模。令 $x_0$ 表示一个固定值为 $0$ 的特殊零时钟。估值 $v$ 将每个时钟映射到一个实数，且 $v(x_0)=0$。区域 (zone) 是一个估值集合，由形如 $x_i - x_j \\leq c$ 的约束的合取所描述，其中 $x_i, x_j \\in \\{x_0, x, y\\}$ 且 $c \\in \\mathbb{R}$。差分约束矩阵 (Difference Bound Matrix, DBM) 是一个矩阵 $M$，其元素 $M_{ij} \\in \\mathbb{R} \\cup \\{\\infty\\}$ 编码了约束 $x_i - x_j \\leq M_{ij}$；由 $M$ 定义的区域表示为 $\\mathcal{Z}(M) = \\{ v \\mid \\forall i,j,\\ v(x_i)-v(x_j) \\leq M_{ij} \\}$。如果一个 DBM 对所有 $i$ 满足 $M_{ii} = 0$，且对所有 $i,j,k$ 满足 $M_{ij} \\leq M_{ik} + M_{kj}$，则称其为闭合的（或规范的）。\n\n两个基于 $\\{x,y\\}$ 的区域由以下约束给出。\n\n区域 $\\mathcal{Z}_1$：\n- $x - x_0 \\leq 5$,\n- $x_0 - x \\leq 0$,\n- $y - x_0 \\leq 4$,\n- $x_0 - y \\leq -1$,\n- $x - y \\leq 2$,\n- $y - x \\leq 1$.\n\n区域 $\\mathcal{Z}_2$：\n- $x - x_0 \\leq 6$,\n- $x_0 - x \\leq -2$,\n- $y - x_0 \\leq 3$,\n- $x - y \\leq \\frac{3}{2}$,\n- $y - x \\leq \\frac{1}{2}$.\n\n任务：\n1) 仅使用区域和差分约束矩阵 (DBM) 的核心定义，分别为区域 $\\mathcal{Z}_1$ 和 $\\mathcal{Z}_2$ 构建闭合的 DBM $M^{(1)}$ 和 $M^{(2)}$，时钟索引集为 $\\{0,1,2\\}$，对应于 $\\{x_0, x, y\\}$。显式计算在闭合操作下任何变得更紧的界。\n\n2) 从 DBM 和闭合性（三角不等式）的定义出发，从第一性原理推导交集区域 $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ 可由 DBM $M^{(\\wedge)}$ 表示，该 DBM 是通过对闭合 DBM 逐元素取最小值\n$$\nM^{(\\wedge)}_{ij} \\;=\\; \\min\\!\\big(M^{(1)}_{ij},\\, M^{(2)}_{ij}\\big)\n$$\n得到的。并通过计算此实例的 $M^{(\\wedge)}$ 并证明 $\\mathcal{Z}\\!\\big(M^{(\\wedge)}\\big) \\;=\\; \\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ 来验证这一点。\n\n3) 在交集区域 $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ 上，确定线性目标函数 $f(x,y) = x + 2y$ 的精确上确界。以单个精确实数形式给出最终答案。不要四舍五入；提供不带单位的精确值。",
            "solution": "该问题被验证为具有科学依据、适定、客观且一致。它代表了时间自动机和差分约束矩阵 (DBM) 理论中的一个标准练习。我们开始进行解答。\n\n时钟索引分配为 $0 \\to x_0$，$1 \\to x$ 和 $2 \\to y$。形如 $x_i - x_j \\leq c$ 的约束对应于 DBM 元素 $M_{ij} = c$。时钟 $x_0$ 固定为 $v(x_0)=0$。\n\n### 任务 1：构建闭合的 DBM\n\n如果一个 DBM $M$ 是路径一致的，即对于所有索引 $i,j,k$，三角不等式 $M_{ij} \\leq M_{ik} + M_{kj}$ 成立，那么它就是闭合的（或规范的）。此属性可通过对根据给定约束构建的初始 DBM 应用所有点对最短路径算法（例如 Floyd-Warshall 算法）来实现。该算法迭代地收紧界：对于从 $0$ 到 $2$ 的 $k$，对于所有的 $i,j$，更新 $M_{ij} \\leftarrow \\min(M_{ij}, M_{ik} + M_{kj})$。对角线元素 $M_{ii}$ 被初始化并保持为 $0$。未指定的非对角线元素被初始化为 $\\infty$。\n\n**区域 $\\mathcal{Z}_1$：**\n\n$\\mathcal{Z}_1$ 的约束为：\n- $x - x_0 \\leq 5 \\implies x_1 - x_0 \\leq 5 \\implies M_{10}^{(1)} = 5$\n- $x_0 - x \\leq 0 \\implies x_0 - x_1 \\leq 0 \\implies M_{01}^{(1)} = 0$\n- $y - x_0 \\leq 4 \\implies x_2 - x_0 \\leq 4 \\implies M_{20}^{(1)} = 4$\n- $x_0 - y \\leq -1 \\implies x_0 - x_2 \\leq -1 \\implies M_{02}^{(1)} = -1$\n- $x - y \\leq 2 \\implies x_1 - x_2 \\leq 2 \\implies M_{12}^{(1)} = 2$\n- $y - x \\leq 1 \\implies x_2 - x_1 \\leq 1 \\implies M_{21}^{(1)} = 1$\n\n$\\mathcal{Z}_1$ 的初始 DBM 为：\n$$ M_{init}^{(1)} = \\begin{pmatrix} 0  0  -1 \\\\ 5  0  2 \\\\ 4  1  0 \\end{pmatrix} $$\n我们应用 Floyd-Warshall 算法来闭合该矩阵。\n对于 $k=0$：\n$M_{12} \\leftarrow \\min(M_{12}, M_{10} + M_{02}) = \\min(2, 5 + (-1)) = \\min(2, 4) = 2$。无变化。\n$M_{21} \\leftarrow \\min(M_{21}, M_{20} + M_{01}) = \\min(1, 4 + 0) = \\min(1, 4) = 1$。无变化。\n对于 $k=1$：\n$M_{02} \\leftarrow \\min(M_{02}, M_{01} + M_{12}) = \\min(-1, 0 + 2) = \\min(-1, 2) = -1$。无变化。\n$M_{20} \\leftarrow \\min(M_{20}, M_{21} + M_{10}) = \\min(4, 1 + 5) = \\min(4, 6) = 4$。无变化。\n对于 $k=2$：\n$M_{01} \\leftarrow \\min(M_{01}, M_{02} + M_{21}) = \\min(0, -1 + 1) = \\min(0, 0) = 0$。无变化。\n$M_{10} \\leftarrow \\min(M_{10}, M_{12} + M_{20}) = \\min(5, 2 + 4) = \\min(5, 6) = 5$。无变化。\n\n在闭合过程中没有界被收紧。初始矩阵已经是闭合的。\n$\\mathcal{Z}_1$ 的闭合 DBM 为：\n$$ M^{(1)} = \\begin{pmatrix} 0  0  -1 \\\\ 5  0  2 \\\\ 4  1  0 \\end{pmatrix} $$\n\n**区域 $\\mathcal{Z}_2$：**\n\n$\\mathcal{Z}_2$ 的约束为：\n- $x - x_0 \\leq 6 \\implies x_1 - x_0 \\leq 6 \\implies M_{10}^{(2)} = 6$\n- $x_0 - x \\leq -2 \\implies x_0 - x_1 \\leq -2 \\implies M_{01}^{(2)} = -2$\n- $y - x_0 \\leq 3 \\implies x_2 - x_0 \\leq 3 \\implies M_{20}^{(2)} = 3$\n- 约束 $x_0-y \\leq c$ 未指定，因此 $M_{02}^{(2)} = \\infty$。\n- $x - y \\leq \\frac{3}{2} \\implies x_1 - x_2 \\leq \\frac{3}{2} \\implies M_{12}^{(2)} = \\frac{3}{2}$\n- $y - x \\leq \\frac{1}{2} \\implies x_2 - x_1 \\leq \\frac{1}{2} \\implies M_{21}^{(2)} = \\frac{1}{2}$\n\n$\\mathcal{Z}_2$ 的初始 DBM 为：\n$$ M_{init}^{(2)} = \\begin{pmatrix} 0  -2  \\infty \\\\ 6  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\n我们应用 Floyd-Warshall 算法。\n对于 $k=0$：没有元素改变，因为经过 $x_0$ 的路径不会提供比现有更紧的界。例如，$M_{21} \\leftarrow \\min(\\frac{1}{2}, M_{20}+M_{01}) = \\min(\\frac{1}{2}, 3-2) = \\min(\\frac{1}{2}, 1) = \\frac{1}{2}$。\n对于 $k=1$：\n$M_{02} \\leftarrow \\min(M_{02}, M_{01} + M_{12}) = \\min(\\infty, -2 + \\frac{3}{2}) = -\\frac{1}{2}$。**界被收紧。**\n$M_{20} \\leftarrow \\min(M_{20}, M_{21} + M_{10}) = \\min(3, \\frac{1}{2} + 6) = \\min(3, 6.5) = 3$。无变化。\n矩阵变为：\n$$ M_{k=1}^{(2)} = \\begin{pmatrix} 0  -2  -\\frac{1}{2} \\\\ 6  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\n对于 $k=2$：\n$M_{01} \\leftarrow \\min(M_{01}, M_{02} + M_{21}) = \\min(-2, -\\frac{1}{2} + \\frac{1}{2}) = \\min(-2, 0) = -2$。无变化。\n$M_{10} \\leftarrow \\min(M_{10}, M_{12} + M_{20}) = \\min(6, \\frac{3}{2} + 3) = \\min(6, \\frac{9}{2}) = \\frac{9}{2}$。**界被收紧。**\n$\\mathcal{Z}_2$ 的最终闭合 DBM 为：\n$$ M^{(2)} = \\begin{pmatrix} 0  -2  -\\frac{1}{2} \\\\ \\frac{9}{2}  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\n变得更紧的界是 $M_{02}^{(2)}$（从 $\\infty$ 到 $-\\frac{1}{2}$）和 $M_{10}^{(2)}$（从 $6$ 到 $\\frac{9}{2}$）。\n\n### 任务 2：区域的交集\n\n我们从第一性原理推导，两个区域 $\\mathcal{Z}_1 = \\mathcal{Z}(M^{(1)})$ 和 $\\mathcal{Z}_2 = \\mathcal{Z}(M^{(2)})$ 的交集由逐元素取最小值的 DBM 的区域给出。\n\n一个估值 $v$ 属于交集区域 $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ 当且仅当 $v$ 同时属于 $\\mathcal{Z}_1$ 和 $\\mathcal{Z}_2$。\n1. 根据 DBM 区域的定义，$v \\in \\mathcal{Z}_1$ 意味着对于所有时钟对 $(x_i, x_j)$，不等式 $v(x_i) - v(x_j) \\leq M^{(1)}_{ij}$ 成立。\n2. 类似地，$v \\in \\mathcal{Z}_2$ 意味着对于所有时钟对 $(x_i, x_j)$，$v(x_i) - v(x_j) \\leq M^{(2)}_{ij}$ 成立。\n3. 因此，要使 $v$ 处于交集中，它必须同时满足两组约束。对于任意给定的对 $(i,j)$，$v$ 必须同时满足 $v(x_i) - v(x_j) \\leq M^{(1)}_{ij}$ 和 $v(x_i) - v(x_j) \\leq M^{(2)}_{ij}$。\n4. 两个形如 $A \\leq B_1$ 和 $A \\leq B_2$ 的不等式的合取在逻辑上等价于单个更严格的不等式 $A \\leq \\min(B_1, B_2)$。\n5. 将此应用于我们的情况，对于每对 $(i,j)$，对估值 $v$ 的条件变为 $v(x_i) - v(x_j) \\leq \\min(M^{(1)}_{ij}, M^{(2)}_{ij})$。\n6. 由于这必须对所有对 $(i,j)$ 成立，交集区域 $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$ 是所有满足 $v(x_i) - v(x_j) \\leq \\min(M^{(1)}_{ij}, M^{(2)}_{ij})$（对于所有 $i,j$）的估值 $v$ 的集合。\n7. 让我们定义一个新的 DBM，$M^{(\\wedge)}$，其中 $M^{(\\wedge)}_{ij} = \\min(M^{(1)}_{ij}, M^{(2)}_{ij})$。步骤 6 中描述的估值集合正是区域 $\\mathcal{Z}(M^{(\\wedge)})$。推导至此完成。\n\n现在，我们使用闭合的 DBM $M^{(1)}$ 和 $M^{(2)}$ 计算此特定实例的 $M^{(\\wedge)}$：\n$$ M^{(1)} = \\begin{pmatrix} 0  0  -1 \\\\ 5  0  2 \\\\ 4  1  0 \\end{pmatrix}, \\quad M^{(2)} = \\begin{pmatrix} 0  -2  -\\frac{1}{2} \\\\ \\frac{9}{2}  0  \\frac{3}{2} \\\\ 3  \\frac{1}{2}  0 \\end{pmatrix} $$\n$$ M^{(\\wedge)}_{ij} = \\min(M^{(1)}_{ij}, M^{(2)}_{ij}) $$\n$$ M^{(\\wedge)} = \\begin{pmatrix}\n  \\min(0,0)  \\min(0,-2)  \\min(-1,-\\frac{1}{2}) \\\\\n  \\min(5, \\frac{9}{2})  \\min(0,0)  \\min(2, \\frac{3}{2}) \\\\\n  \\min(4,3)  \\min(1,\\frac{1}{2})  \\min(0,0)\n\\end{pmatrix} = \\begin{pmatrix}\n  0  -2  -1 \\\\\n  \\frac{9}{2}  0  \\frac{3}{2} \\\\\n  3  \\frac{1}{2}  0\n\\end{pmatrix} $$\nDBM $M^{(\\wedge)}$ 代表交集区域 $\\mathcal{Z}_1 \\cap \\mathcal{Z}_2$。这个矩阵恰好是闭合的，因此它为交集区域提供了最紧的约束。\n\n### 任务 3：$f(x,y) = x + 2y$ 的上确界\n\n我们寻求在交集区域 $\\mathcal{Z}_{int} = \\mathcal{Z}(M^{(\\wedge)})$ 上找到 $f(x,y) = x+2y$ 的上确界。对估值 $v(x)=x$ 和 $v(y)=y$ 的约束是从 $M^{(\\wedge)}$ 导出的，使用 $v(x_0)=0$：\n- $x_0 - x \\leq M^{(\\wedge)}_{01} \\implies 0 - x \\leq -2 \\implies x \\geq 2$\n- $x - x_0 \\leq M^{(\\wedge)}_{10} \\implies x - 0 \\leq \\frac{9}{2} \\implies x \\leq 4.5$\n- $x_0 - y \\leq M^{(\\wedge)}_{02} \\implies 0 - y \\leq -1 \\implies y \\geq 1$\n- $y - x_0 \\leq M^{(\\wedge)}_{20} \\implies y - 0 \\leq 3 \\implies y \\leq 3$\n- $y - x \\leq M^{(\\wedge)}_{21} \\implies y - x \\leq \\frac{1}{2} \\implies y \\leq x + \\frac{1}{2}$\n- $x - y \\leq M^{(\\wedge)}_{12} \\implies x - y \\leq \\frac{3}{2} \\implies y \\geq x - \\frac{3}{2}$\n\n这定义了一个线性规划问题：最大化 $x+2y$，约束条件为：\n$2 \\leq x \\leq 4.5$\n$1 \\leq y \\leq 3$\n$y \\geq x - 1.5$\n$y \\leq x + 0.5$\n\n可行域是一个紧致的凸多边形。线性函数在该区域上的上确界是其最大值，该值必须在其中一个顶点处达到。我们通过求约束边界线的交点来找到顶点。\n可行域的顶点是：\n1. $x=2$ 和 $y=x+0.5$ 的交点：$(x,y)=(2, 2.5)$。该点在可行域内。\n2. $y=3$ 和 $y=x+0.5$ 的交点：$(x,y)=(2.5, 3)$。该点在可行域内。\n3. $y=3$ 和 $x=4.5$ 的交点。这给出点 $(4.5, 3)$。检查其他约束：$3 \\geq 4.5 - 1.5 = 3$（成立）和 $3 \\leq 4.5 + 0.5 = 5$（成立）。该点是可行的。它也是 $y=x-1.5$ 和 $x=4.5$ 的交点。\n4. $y=1$ 和 $y=x-1.5$ 的交点：$(x,y)=(2.5, 1)$。该点在可行域内。\n5. $x=2$ 和 $y=1$ 的交点：$(x,y)=(2, 1)$。该点在可行域内。\n\n我们在每个顶点处计算目标函数 $f(x,y)=x+2y$ 的值：\n- $f(2, 1) = 2 + 2(1) = 4$\n- $f(2.5, 1) = 2.5 + 2(1) = 4.5$\n- $f(2, 2.5) = 2 + 2(2.5) = 2 + 5 = 7$\n- $f(2.5, 3) = 2.5 + 2(3) = 2.5 + 6 = 8.5$\n- $f(4.5, 3) = 4.5 + 2(3) = 4.5 + 6 = 10.5$\n\n这些值中的最大值是 $10.5$。目标函数 $f(x,y)=x+2y$ 在交集区域上的上确界是 $10.5$。",
            "answer": "$$\\boxed{\\frac{21}{2}}$$"
        },
        {
            "introduction": "在掌握了 DBM 的基本操作后，我们便可以着手构建一个完整的符号模型检测器。本练习  将指导您实现一个核心的前向可达性算法，用它来自动探索时间自动机的状态空间，并验证系统是否满足关键的安全属性。这是网络物理系统形式化验证中的一项基础而重要的任务。",
            "id": "4251986",
            "problem": "考虑一个用于数字孪生的、为信息物理系统实时行为建模的时间自动机。时间自动机定义为一个元组 $(L, \\ell_0, C, E, \\mathrm{Inv})$，其中 $L$ 是一个有限的位置集，$\\ell_0 \\in L$ 是初始位置，$C = \\{x_1, \\dots, x_m\\}$ 是一个有限的实值时钟集，$E \\subseteq L \\times \\mathcal{G}(C) \\times 2^C \\times L$ 是一个边集，其中 $\\mathcal{G}(C)$ 表示守卫，而 $\\mathrm{Inv}: L \\to \\mathcal{G}(C)$ 用于分配位置不变量。时钟随时间以速率 $1$ 连续演化，并可能在离散转换时重置为 $0$。\n\n符号可达性使用由差分约束矩阵 (Difference Bound Matrices, DBMs) 编码的区域 (zone)。DBM 是一个数组 $M \\in (\\mathbb{R} \\cup \\{\\infty\\})^{n \\times n}$，其中 $n = |C| + 1$，索引时钟 $x_0, x_1, \\dots, x_m$，而 $x_0$ 是一个特殊的零时钟，其值永不改变且始终为 $0$。每个条目 $M[i,j]$ 编码一个约束 $x_i - x_j \\leq b_{ij}$，而由 $M$ 表示的区域是所有编码约束的合取。DBM 必须是规范的（即，在三角不等式下闭合）以捕捉所有隐含的约束，这通过计算所有点对最短路径闭包 $M[i,j] \\leftarrow \\min(M[i,j], M[i,k] + M[k,j])$ 来实现，适用于所有索引 $i,j,k$。\n\n基于区域的时间自动机语义的基本操作包括：\n- 与守卫或不变量相交：合并约束 $x_i - x_j \\leq b$，然后重新计算规范闭包。\n- 在不变量 $\\mathrm{Inv}(\\ell)$ 下的时间流逝：从区域 $Z$ 开始，计算 $Z' = \\mathrm{Up}(Z \\cap \\mathrm{Inv}(\\ell)) \\cap \\mathrm{Inv}(\\ell)$，其中 $\\mathrm{Up}$ 操作移除所有形式为 $x_i - x_0 \\leq b$ 的上界（即，将它们设置为 $\\infty$），同时保留下界 $x_0 - x_i \\leq b$ 和时钟间差异约束。\n- 重置时钟 $x_r$：将 $x_r$ 的行和列设置为与 $x_0$ 的行和列相等，并设置 $M[r,r] = 0$，然后对 DBM 进行规范闭包。\n\n需要验证的安全属性：对于指定的时钟 $x$ 和常量界限 $c \\in \\mathbb{R}$，系统应确保在不安全位置的所有可达区域中，该区域都蕴含 $x \\leq c$。用 DBM 的术语来说，一个区域蕴含 $x \\leq c$ 当且仅当其规范闭包满足 $M[\\mathrm{idx}(x), \\mathrm{idx}(x_0)] \\leq c$。也就是说，该符号区域包含在半空间 $x - x_0 \\leq c$ 内。\n\n您的任务是编写一个完整的程序，该程序：\n1. 实现上述规定的基于 DBM 的时间自动机符号可达性分析。\n2. 通过验证在任何标记为不安全的位置的每个可达区域中 $M[\\mathrm{idx}(x), \\mathrm{idx}(x_0)] \\leq c$ 是否成立，来检查安全属性“在不安全位置时钟 $x$ 永不超过 $c$”。\n3. 使用以下自动机测试套件，每个套件都指定了位置、不变量、边、初始位置以及属性时钟索引和界限 $c$。时间单位为秒，但程序的输出是纯布爾值，无需单位转换。所有约束和界限均以非严格不等式给出：\n\n测试用例 1 (重置强制实现安全性):\n- 时钟: $C = \\{x\\}$，其中 $x$ 的索引为 $1$。\n- 位置: $L = \\{\\ell_0, \\ell_1\\}$，其中 $\\ell_1$ 为不安全位置。\n- 不变量: $\\mathrm{Inv}(\\ell_0): x \\leq 10$, $\\mathrm{Inv}(\\ell_1): x \\leq 2$。\n- 边: $(\\ell_0, x \\geq 4, \\{x\\}, \\ell_1)$；守卫 $x \\geq 4$ 编码为 $x_0 - x \\leq -4$；重置 $\\{x\\}$。\n- 初始位置: $\\ell_0$，所有时钟初始为 $0$。\n- 属性: 在不安全位置检查 $x \\leq c$，其中 $c = 2$。\n\n测试用例 2 (边界紧密相等):\n- 时钟: $C = \\{x\\}$，其中 $x$ 的索引为 $1$。\n- 位置: $L = \\{\\ell_0, \\ell_1\\}$，其中 $\\ell_1$ 为不安全位置。\n- 不变量: $\\mathrm{Inv}(\\ell_0): x \\leq 3$, $\\mathrm{Inv}(\\ell_1): x \\leq 3$。\n- 边: $(\\ell_0, x \\geq 3 \\wedge x \\leq 3, \\emptyset, \\ell_1)$；相等关系 $x = 3$ 编码为 $x_0 - x \\leq -3$ 和 $x - x_0 \\leq 3$。\n- 初始位置: $\\ell_0$。\n- 属性: 在不安全位置检查 $x \\leq c$，其中 $c = 3$。\n\n测试用例 3 (因不变量允许增长而导致违规):\n- 时钟: $C = \\{x\\}$，其中 $x$ 的索引为 $1$。\n- 位置: $L = \\{\\ell_0, \\ell_1\\}$，其中 $\\ell_1$ 为不安全位置。\n- 不变量: $\\mathrm{Inv}(\\ell_0): x \\leq 10$, $\\mathrm{Inv}(\\ell_1): x \\leq 10$。\n- 边: $(\\ell_0, x \\geq 4, \\emptyset, \\ell_1)$。\n- 初始位置: $\\ell_0$。\n- 属性: 在不安全位置检查 $x \\leq c$，其中 $c = 4$。\n\n测试用例 4 (不安全位置不可达):\n- 时钟: $C = \\{x\\}$，其中 $x$ 的索引为 $1$。\n- 位置: $L = \\{\\ell_0, \\ell_1\\}$，其中 $\\ell_1$ 为不安全位置。\n- 不变量: $\\mathrm{Inv}(\\ell_0): x \\leq 2$, $\\mathrm{Inv}(\\ell_1): x \\leq 10$。\n- 边: $(\\ell_0, x \\geq 5, \\emptyset, \\ell_1)$。\n- 初始位置: $\\ell_0$。\n- 属性: 在不安全位置检查 $x \\leq c$，其中 $c = 5$。\n\n测试用例 5 (通过双时钟的差分约束推导出的界限):\n- 时钟: $C = \\{x, y\\}$，其中 $x$ 的索引为 $1$，$y$ 的索引为 $2$。\n- 位置: $L = \\{\\ell_0, \\ell_1\\}$，其中 $\\ell_1$ 为不安全位置。\n- 不变量: $\\mathrm{Inv}(\\ell_0): y \\leq 3$, $\\mathrm{Inv}(\\ell_1): y \\leq 3$。\n- 边: $(\\ell_0, x - y \\leq 0, \\emptyset, \\ell_1)$；守卫 $x \\leq y$ 编码为 $x - y \\leq 0$。\n- 初始位置: $\\ell_0$。\n- 属性: 在不安全位置检查 $x \\leq c$，其中 $c = 3$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$）作为结果，其中每个 $r_i$ 是一个布尔值，表示属性在测试用例 $i$ 中是否成立。不应产生其他输出。",
            "solution": "所提出的问题是信息物理系统形式化方法领域一个有效且定义明确的练习。它要求使用差分约束矩阵 (DBM) 实现时间自动机的符号前向可达性算法，以验证一个安全属性。问题陈述在既有的时间自动机理论上具有科学依据，提供了一套完整且一致的定义、操作和测试用例，并且是客观表述的。因此，我将着手描述解决方案。\n\n任务的核心是实现一个符号状态空间探索算法。该算法迭代计算可达符号状态集，其中每个符号状态是一个由位置 $\\ell \\in L$ 和区域 $Z$ 组成的对 $(\\ell, Z)$。区域是时钟赋值的凸集，我们使用差分约束矩阵 (DBM) 来表示。该算法必须为指定不安全位置内的所有可达状态验证形式为 $x \\le c$ 的安全属性。\n\n对于一个包含 $m$ 个时钟的集合 $\\{x_1, \\dots, x_m\\}$，DBM $M$ 是一个 $(m+1) \\times (m+1)$ 的矩阵，其中额外的时钟 $x_0$ 是一个固定值为 $0$ 的虚拟时钟。一个条目 $M[i,j]$ 表示两个时钟之差的上界，编码了约束 $x_i - x_j \\le M[i,j]$。一个区域是满足由 DBM 定义的所有此类约束的所有时钟赋值的集合。为了使 DBM 成为一个有效且高效的表示，它必须处于规范形式，这通过计算其最短路径闭包来实现。这确保了所有隐含的约束都被显式化。Floyd-Warshall 算法是实现此目的的标准方法，其更新规则定义为 $M[i,j] \\leftarrow \\min(M[i,j], M[i,k] + M[k,j])$，适用于所有 $i,j,k$。一个区域为空当且仅当其规范 DBM 存在负的对角元素，这可以在规范化后通过检查 $M[0,0]  0$ 来检测。\n\n符号可达性算法按以下步骤进行：\n我们维护一个待探索的符号状态 $(\\ell, Z)$ 的 `waiting_list`，和一个已处理状态的 `passed_list`。算法以起始状态 $(\\ell_0, Z_0)$ 初始化，其中 $Z_0$ 表示初始时钟赋值（所有时钟均为 $0$）。\n\n算法的主循环如下：\n1.  从 `waiting_list` 中取出一个符号状态 $(\\ell, Z)$。\n2.  为避免冗余计算并确保系统在具有有限 bisimulation 的情况下终止，我们检查区域 $Z$ 是否已被先前访问过的同一位置的某个区域所包含。也就是说，如果 `passed_list` 中存在 $(\\ell, Z')$ 使得 $Z \\subseteq Z'$，我们就丢弃 $(\\ell, Z)$ 并继续。子集关系 $Z \\subseteq Z'$ 成立当且仅当对于所有索引 $i,j$，都有 $M_Z[i,j] \\le M_{Z'}[i,j]$。\n3.  如果未被包含，则将 $(\\ell, Z)$ 添加到 `passed_list`。\n4.  计算从 $(\\ell, Z)$ 出发通过时间流逝可达的状态集。这是时间后继区域，计算为 $Z_{\\text{succ}} = \\mathrm{Up}(Z \\cap \\mathrm{Inv}(\\ell)) \\cap \\mathrm{Inv}(\\ell)$。$\\mathrm{Up}$ 操作抽象掉时钟的特定上界，表示时间无限前进的效果。它通过将所有条目 $M[i,0]$ (对于 $i > 0$) 设置为 $\\infty$ 并重新规范化来实现。\n5.  如果位置 $\\ell$ 被指定为不安全，则必须对时间后继区域 $Z_{\\text{succ}}$ 检查安全属性。对于整个区域 $Z_{\\text{succ}}$，属性 $x \\le c$ 成立，条件是其 DBM $M_{\\text{succ}}$ 满足 $M_{\\text{succ}}[\\mathrm{idx}(x), \\mathrm{idx}(x_0)] \\le c$。如果在任何不安全位置的任何可达区域中此检查失败，则整个系统的属性被违反。\n6.  对于从位置 $\\ell$ 出发的每条出边 $(\\ell, g, R, \\ell')$，计算离散后繼状态。这包括：\n    a.  将时间后继区域 $Z_{\\text{succ}}$ 与边的守卫 $g$ 相交。这通过使用守卫约束更新 DBM 并重新规范化来完成。如果结果区域为空，则剪除此转换路径。\n    b.  对结果区域应用时钟重置 $R$。重置时钟 $x_r$ 对应于将其值设为 $0$ 同时保留其他时钟的值。在 DBM 术语中，这涉及将零时钟 $x_0$ 的行和列复制到 $x_r$ 的行和列，并重新规范化。\n    c.  将得到的符号状态 $(\\ell', Z_{\\text{new}})$ 添加到 `waiting_list` 中以供未来探索。\n\n当 `waiting_list` 变为空时，算法终止，此时所有可达的符号状态都已被探索。当且仅当在探索过程中没有违反属性时，安全属性被认为成立。此过程将被实现并应用于提供的五个测试用例中的每一个。\n\n初始区域 $Z_0$（所有时钟均为 $0$）由一个所有条目都为 $0$ 的 DBM 表示。\n约束转换如下：\n-   $x_i \\le c$ 变为 $x_i - x_0 \\le c$。\n-   $x_i \\ge c$ 变为 $x_0 - x_i \\le -c$。\n-   $x_i - x_j \\le c$ 是一个直接的 DBM 约束。\n\n该实现将封装这些 DBM 操作和可达性逻辑，为每个测试用例提供一个布尔结果，指示指定的安全属性是否得到维护。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef canonicalize(dbm):\n    \"\"\"\n    Applies the Floyd-Warshall algorithm to compute the canonical form of a DBM.\n    \"\"\"\n    n = dbm.shape[0]\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dbm[i, j] = min(dbm[i, j], dbm[i, k] + dbm[k, j])\n    return dbm\n\ndef is_empty(dbm):\n    \"\"\"\n    Checks if a zone represented by a DBM is empty.\n    A zone is empty if any diagonal element is negative after canonization.\n    \"\"\"\n    return dbm[0, 0]  0\n\ndef intersect(dbm, constraints):\n    \"\"\"\n    Intersects a zone with a set of constraints.\n    Constraints is a list of tuples (i, j, bound) for x_i - x_j = bound.\n    \"\"\"\n    new_dbm = dbm.copy()\n    for i, j, b in constraints:\n        if b  new_dbm[i, j]:\n            new_dbm[i, j] = b\n    \n    new_dbm = canonicalize(new_dbm)\n    return new_dbm\n\ndef time_elapse(dbm, inv_constraints):\n    \"\"\"\n    Computes the time-successor zone according to the problem's definition:\n    Z' = Up(Z intersect Inv(l)) intersect Inv(l).\n    \"\"\"\n    # 1. Z intersect Inv(l)\n    z_inv = intersect(dbm, inv_constraints)\n    if is_empty(z_inv):\n        return None\n\n    # 2. Up(z_inv)\n    num_clocks = z_inv.shape[0] - 1\n    for i in range(1, num_clocks + 1):\n        z_inv[i, 0] = np.inf\n    z_up = canonicalize(z_inv)\n    \n    # 3. z_up intersect Inv(l)\n    z_succ = intersect(z_up, inv_constraints)\n    if is_empty(z_succ):\n        return None\n\n    return z_succ\n\ndef reset(dbm, reset_indices):\n    \"\"\"\n    Resets specified clocks to 0.\n    \"\"\"\n    new_dbm = dbm.copy()\n    for r_idx in reset_indices:\n        # Copy row 0 to row r_idx\n        new_dbm[r_idx, :] = new_dbm[0, :]\n        # Copy column 0 to column r_idx\n        new_dbm[:, r_idx] = new_dbm[:, 0]\n        # Set diagonal to 0\n        new_dbm[r_idx, r_idx] = 0\n    \n    return canonicalize(new_dbm)\n\ndef is_subset(dbm1, dbm2):\n    \"\"\"\n    Checks if the zone of dbm1 is a subset of the zone of dbm2.\n    This holds if and only if for all i, j: dbm1[i,j] = dbm2[i,j].\n    \"\"\"\n    return np.all(dbm1 = dbm2)\n\ndef run_reachability(automaton):\n    \"\"\"\n    Performs symbolic forward reachability analysis for a given timed automaton.\n    \"\"\"\n    num_clocks = automaton['num_clocks']\n    initial_loc = automaton['initial_loc']\n    \n    # Initial zone: all clocks are 0. DBM is all zeros.\n    initial_dbm = np.zeros((num_clocks + 1, num_clocks + 1))\n    \n    waiting = deque([(initial_loc, initial_dbm)])\n    # passed: A dictionary mapping locations to lists of DBMs\n    passed = {loc: [] for loc in automaton['locations']}\n    \n    property_holds = True\n\n    while waiting:\n        loc, dbm = waiting.popleft()\n\n        # Subsumption check\n        is_subsumed = False\n        for old_dbm in passed[loc]:\n            if is_subset(dbm, old_dbm):\n                is_subsumed = True\n                break\n        if is_subsumed:\n            continue\n        \n        # Add to passed list, removing any zones that are now subsumed by the new one\n        passed[loc] = [old for old in passed[loc] if not is_subset(old, dbm)]\n        passed[loc].append(dbm)\n        \n        # 1. Time Elapse\n        invariant = automaton['invariants'].get(loc, [])\n        succ_dbm = time_elapse(dbm.copy(), invariant)\n\n        if succ_dbm is None:  # Empty zone after elapse\n            continue\n        \n        # 2. Check property if in unsafe location\n        if loc in automaton['unsafe_locs']:\n            prop_idx = automaton['prop_clock_idx']\n            prop_bound = automaton['prop_bound']\n            # Zone implies x = c iff M[idx(x), 0] = c\n            if not (succ_dbm[prop_idx, 0] = prop_bound):\n                property_holds = False\n                # We can stop early if we only care if a violation exists\n                return False\n\n        # 3. Discrete Transitions\n        for l_from, guard, resets, l_to in automaton['edges']:\n            if l_from != loc:\n                continue\n                \n            # Apply guard\n            guarded_dbm = intersect(succ_dbm.copy(), guard)\n            if is_empty(guarded_dbm):\n                continue\n            \n            # Apply resets\n            reset_dbm = reset(guarded_dbm, resets)\n\n            waiting.append((l_to, reset_dbm))\n            \n    return property_holds\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the analysis.\n    \"\"\"\n    # x0 is clock 0 (the zero clock)\n    # Test cases defined according to the problem statement.\n    test_cases = [\n        { # Case 1: reset enforces safety\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 10)], 1: [(1, 0, 2)]}, # x = 10, x = 2\n            'edges': [(0, [(0, 1, -4)], {1}, 1)], # loc0 -> loc1 if x >= 4, reset x\n            'prop_clock_idx': 1, 'prop_bound': 2\n        },\n        { # Case 2: boundary tight equality\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 3)], 1: [(1, 0, 3)]}, # x = 3, x = 3\n            'edges': [(0, [(0, 1, -3), (1, 0, 3)], set(), 1)], # loc0 -> loc1 if x = 3\n            'prop_clock_idx': 1, 'prop_bound': 3\n        },\n        { # Case 3: violation due to invariant allowing growth\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 10)], 1: [(1, 0, 10)]}, # x = 10, x = 10\n            'edges': [(0, [(0, 1, -4)], set(), 1)], # loc0 -> loc1 if x >= 4\n            'prop_clock_idx': 1, 'prop_bound': 4\n        },\n        { # Case 4: unsafe unreachable\n            'num_clocks': 1, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(1, 0, 2)], 1: [(1, 0, 10)]}, # x = 2, x = 10\n            'edges': [(0, [(0, 1, -5)], set(), 1)], # loc0 -> loc1 if x >= 5\n            'prop_clock_idx': 1, 'prop_bound': 5\n        },\n        { # Case 5: derived bound via difference constraints\n            'num_clocks': 2, 'locations': {0, 1}, 'initial_loc': 0, 'unsafe_locs': {1},\n            'invariants': {0: [(2, 0, 3)], 1: [(2, 0, 3)]}, # y = 3, y = 3\n            'edges': [(0, [(1, 2, 0)], set(), 1)], # loc0 -> loc1 if x = y\n            'prop_clock_idx': 1, 'prop_bound': 3\n        }\n    ]\n\n    results = []\n    for automaton in test_cases:\n        result = run_reachability(automaton)\n        results.append(result)\n    \n    # Format the final output as specified\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}