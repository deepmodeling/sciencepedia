{
    "hands_on_practices": [
        {
            "introduction": "编排器的一项主要任务是高效的资源管理。在部署复杂的分布式数字孪生之前，我们必须进行容量规划，以确保底层基础设施能够支持预期的负载。这个实践将指导你完成一个真实的资源需求计算过程，其中考虑了微服务、副本以及各种开销，对于设计可扩展且经济高效的赛博物理系统而言，这是一项基础技能。",
            "id": "4234442",
            "problem": "一个分布式数字孪生 (DDT) 被编排为一个微服务集群，其中每个微服务处理一个工业资产的不同流水线阶段。在标准编排部署下，资源需求在各个服务和副本之间是累加的，而开销则以乘法方式（分析和插桩）和加法方式（边车代理和运行时垫片）共同产生。假设跨资产呈线性扩展，且服务资源贡献的独立性意味着跨服务和副本的资源需求可累加聚合。集群强制执行服务水平协议 (SLA) 的预留空间，因此只有标称容量的一部分可用于工作负载。\n\n给定一个资产孪生的各服务基础资源使用量，按每个活跃副本测量：对于服务 $i \\in \\{1,2,3,4\\}$，中央处理器 (CPU) 核心数为 $c_i$，随机存取存储器 (RAM) 为 $m_i$ ($\\mathrm{GiB}$)，网络带宽为 $b_i$ (Mbps)：\n- 服务 $1$：$c_1 = 2.3$, $m_1 = 9$, $b_1 = 180$。\n- 服务 $2$：$c_2 = 3.1$, $m_2 = 14$, $b_2 = 350$。\n- 服务 $3$：$c_3 = 1.7$, $m_3 = 6$, $b_3 = 120$。\n- 服务 $4$：$c_4 = 2.9$, $m_4 = 10$, $b_4 = 400$。\n\n应用于每个副本的运营开销如下：\n- 乘法插桩因子：CPU 为 $(1+\\alpha_c)$，其中 $\\alpha_c = 0.07$；内存为 $(1+\\alpha_m)$，其中 $\\alpha_m = 0.04$；带宽为 $(1+\\alpha_b)$，其中 $\\alpha_b = 0.15$。\n- 加法边车/运行时垫片：每个副本需要 $\\delta_c = 0.08$ 个 CPU 核心，$\\delta_m = 0.5$ $\\mathrm{GiB}$ RAM，以及 $\\delta_b = 12$ $\\mathrm{Mbps}$ 带宽。\n\n为保证弹性，每个资产孪生的每个服务部署 $r_{\\text{active}} = 2$ 个活跃副本和 $r_{\\text{standby}} = 1$ 个热备副本。热备副本消耗活跃副本基础资源的一部分，CPU 比例为 $\\sigma_c = 0.6$，内存比例为 $\\sigma_m = 0.5$，带宽比例为 $\\sigma_b = 1$（因为它接收完整的流）。相同的乘法和加法开销适用于所有副本。\n\n集群为弹性和故障恢复预留了 $h = 0.15$ 的空间比例，因此可用容量是标称容量的 $(1-h)$ 倍。集群的标称容量为：CPU $C = 200$ 个核心，内存 $M = 1024$ $\\mathrm{GiB}$，带宽 $B = 80000$ $\\mathrm{Mbps}$。\n\n假设要同时为多个相同的资产提供服务，每个资产都需要上述的 DDT 服务集群和副本方案。仅使用跨服务和副本的累加性第一性原理以及给定的开销模型，推导出每个资产的总资源预算，并确定在不违反 CPU、内存和带宽的集群可用限制的情况下，可以同时部署的资产孪生的最大数量 $k_{\\max}$：\n$$\\sum \\text{CPU} \\le (1-h) C,\\quad \\sum \\text{MEM} \\le (1-h) M,\\quad \\sum \\text{BW} \\le (1-h) B.$$\n\n提供最终的 $k_{\\max}$ 作为无单位的整数。在最终答案中，除了取小于或等于极限比率的最大整数外，不需要进行其他舍入。",
            "solution": "该问题要求确定在具有指定资源容量和运营预留空间要求的集群上，可以同时托管的相同资产的最大数量 $k_{\\max}$。该解决方案是从资源累加性的第一性原理推导得出的。\n\n首先，我们为服务 $i$ 的单个副本建立资源消耗模型。所考虑的资源包括 CPU 核心 ($c$)、RAM ($m$) 和网络带宽 ($b$)。单个副本的总消耗量基于其基础使用量、一个乘法开销因子和一个加法开销。\n\n对于服务 $i$ 的一个**活跃**副本，其基础使用量为 $c_i$、$m_i$ 和 $b_i$。乘法开销因子为 $(1+\\alpha_c)$、$(1+\\alpha_m)$ 和 $(1+\\alpha_b)$，加法开销为 $\\delta_c$、$\\delta_m$ 和 $\\delta_b$。服务 $i$ 的一个活跃副本的总资源消耗为：\n- CPU 消耗：$c_{i, \\text{active}}^{\\text{total}} = c_i (1+\\alpha_c) + \\delta_c$\n- RAM 消耗：$m_{i, \\text{active}}^{\\text{total}} = m_i (1+\\alpha_m) + \\delta_m$\n- 带宽消耗：$b_{i, \\text{active}}^{\\text{total}} = b_i (1+\\alpha_b) + \\delta_b$\n\n对于服务 $i$ 的一个**热备**副本，其基础使用量是活跃副本基础使用量的一部分，由因子 $\\sigma_c$、$\\sigma_m$ 和 $\\sigma_b$ 指定。问题陈述，相同的开销适用于所有副本。因此，对于服务 $i$ 的一个备用副本：\n- CPU 消耗：$c_{i, \\text{standby}}^{\\text{total}} = (\\sigma_c c_i) (1+\\alpha_c) + \\delta_c$\n- RAM 消耗：$m_{i, \\text{standby}}^{\\text{total}} = (\\sigma_m m_i) (1+\\alpha_m) + \\delta_m$\n- 带宽消耗：$b_{i, \\text{standby}}^{\\text{total}} = (\\sigma_b b_i) (1+\\alpha_b) + \\delta_b$\n\n每个服务由 $r_{\\text{active}} = 2$ 个活跃副本和 $r_{\\text{standby}} = 1$ 个热备副本组成。服务 $i$ 的总资源消耗是其所有副本消耗的总和。对于通用资源 $X \\in \\{C, M, B\\}$，服务 $i$ 的总资源消耗（表示为 $X_{i}^{\\text{service}}$）由以下公式给出：$X_{i}^{\\text{service}} = r_{\\text{active}} \\cdot X_{i, \\text{active}}^{\\text{total}} + r_{\\text{standby}} \\cdot X_{i, \\text{standby}}^{\\text{total}}$。\n通过代入每种副本类型的表达式并重新组合各项，我们得到：\n- 服务 $i$ 的 CPU：$C_i^{\\text{service}} = (r_{\\text{active}} + r_{\\text{standby}}\\sigma_c)c_i(1+\\alpha_c) + (r_{\\text{active}}+r_{\\text{standby}})\\delta_c$\n- 服务 $i$ 的 RAM：$M_i^{\\text{service}} = (r_{\\text{active}} + r_{\\text{standby}}\\sigma_m)m_i(1+\\alpha_m) + (r_{\\text{active}}+r_{\\text{standby}})\\delta_m$\n- 服务 $i$ 的带宽：$B_i^{\\text{service}} = (r_{\\text{active}} + r_{\\text{standby}}\\sigma_b)b_i(1+\\alpha_b) + (r_{\\text{active}}+r_{\\text{standby}})\\delta_b$\n\n一个资产孪生的总资源预算（$C_{\\text{asset}}$、$M_{\\text{asset}}$、$B_{\\text{asset}}$）是所有 4 个服务（$i \\in \\{1,2,3,4\\}$）的资源总和。\n$C_{\\text{asset}} = \\sum_{i=1}^{4} C_i^{\\text{service}} = (r_{\\text{active}} + r_{\\text{standby}}\\sigma_c)(1+\\alpha_c)\\left(\\sum_{i=1}^{4} c_i\\right) + 4(r_{\\text{active}}+r_{\\text{standby}})\\delta_c$\n$M_{\\text{asset}} = \\sum_{i=1}^{4} M_i^{\\text{service}} = (r_{\\text{active}} + r_{\\text{standby}}\\sigma_m)(1+\\alpha_m)\\left(\\sum_{i=1}^{4} m_i\\right) + 4(r_{\\text{active}}+r_{\\text{standby}})\\delta_m$\n$B_{\\text{asset}} = \\sum_{i=1}^{4} B_i^{\\text{service}} = (r_{\\text{active}} + r_{\\text{standby}}\\sigma_b)(1+\\alpha_b)\\left(\\sum_{i=1}^{4} b_i\\right) + 4(r_{\\text{active}}+r_{\\text{standby}})\\delta_b$\n\n我们代入给定的数值。首先，对 4 个服务的基础资源求和：\n$\\sum_{i=1}^{4} c_i = 2.3 + 3.1 + 1.7 + 2.9 = 10.0$ 个 CPU 核心\n$\\sum_{i=1}^{4} m_i = 9 + 14 + 6 + 10 = 39$ GiB RAM\n$\\sum_{i=1}^{4} b_i = 180 + 350 + 120 + 400 = 1050$ Mbps\n\n接下来，我们使用提供的参数计算组合系数：\n$r_{\\text{active}} = 2$, $r_{\\text{standby}} = 1$\n$\\alpha_c = 0.07, \\alpha_m = 0.04, \\alpha_b = 0.15$\n$\\delta_c = 0.08, \\delta_m = 0.5, \\delta_b = 12$\n$\\sigma_c = 0.6, \\sigma_m = 0.5, \\sigma_b = 1$\n\n对于 CPU：\n- 有效副本乘数：$r_{\\text{active}} + r_{\\text{standby}}\\sigma_c = 2 + 1(0.6) = 2.6$\n- 乘法开销：$1+\\alpha_c = 1.07$\n- 总加法开销：$4(r_{\\text{active}}+r_{\\text{standby}})\\delta_c = 4(3)(0.08) = 0.96$ 个核心\n对于 RAM：\n- 有效副本乘数：$r_{\\text{active}} + r_{\\text{standby}}\\sigma_m = 2 + 1(0.5) = 2.5$\n- 乘法开销：$1+\\alpha_m = 1.04$\n- 总加法开销：$4(r_{\\text{active}}+r_{\\text{standby}})\\delta_m = 4(3)(0.5) = 6$ GiB\n对于带宽：\n- 有效副本乘数：$r_{\\text{active}} + r_{\\text{standby}}\\sigma_b = 2 + 1(1) = 3$\n- 乘法开销：$1+\\alpha_b = 1.15$\n- 总加法开销：$4(r_{\\text{active}}+r_{\\text{standby}})\\delta_b = 4(3)(12) = 144$ Mbps\n\n现在我们可以计算每个资产的总资源预算：\n$C_{\\text{asset}} = (2.6)(1.07)(10.0) + 0.96 = 27.82 + 0.96 = 28.78$ 个核心\n$M_{\\text{asset}} = (2.5)(1.04)(39) + 6 = 101.4 + 6 = 107.4$ GiB\n$B_{\\text{asset}} = (3)(1.15)(1050) + 144 = 3622.5 + 144 = 3766.5$ Mbps\n\n集群的可用容量是标称容量的 $(1-h)$ 倍，其中 $h=0.15$。\n$C_{\\text{usable}} = (1 - 0.15) \\times 200 = 0.85 \\times 200 = 170$ 个核心\n$M_{\\text{usable}} = (1 - 0.15) \\times 1024 = 0.85 \\times 1024 = 870.4$ GiB\n$B_{\\text{usable}} = (1 - 0.15) \\times 80000 = 0.85 \\times 80000 = 68000$ Mbps\n\n资产的最大数量 $k$ 受限于最紧张的资源。我们建立以下不等式：\n$k \\cdot C_{\\text{asset}} \\le C_{\\text{usable}} \\implies k \\le \\frac{C_{\\text{usable}}}{C_{\\text{asset}}}$\n$k \\cdot M_{\\text{asset}} \\le M_{\\text{usable}} \\implies k \\le \\frac{M_{\\text{usable}}}{M_{\\text{asset}}}$\n$k \\cdot B_{\\text{asset}} \\le B_{\\text{usable}} \\implies k \\le \\frac{B_{\\text{usable}}}{B_{\\text{asset}}}$\n\n代入计算出的值：\n$k \\le \\frac{170}{28.78} \\approx 5.9068$\n$k \\le \\frac{870.4}{107.4} \\approx 8.1042$\n$k \\le \\frac{68000}{3766.5} \\approx 18.0538$\n\n为了满足所有三个条件，$k$ 必须小于或等于这些比率中的最小值。因此，最大整数值 $k_{\\max}$ 是这个最小值的向下取整。\n$k_{\\max} = \\left\\lfloor \\min\\left( \\frac{170}{28.78}, \\frac{870.4}{107.4}, \\frac{68000}{3766.5} \\right) \\right\\rfloor$\n$k_{\\max} = \\lfloor \\min(5.9068..., 8.1042..., 18.0538...) \\rfloor$\n$k_{\\max} = \\lfloor 5.9068... \\rfloor = 5$\n\nCPU 资源是限制因素。该集群最多可以支持 5 个并发资产。",
            "answer": "$$\\boxed{5}$$"
        },
        {
            "introduction": "部署完成后，确保数字孪生状态的完整性至关重要。在分布式系统中，由于网络消息可能被复制或重新排序，这项任务变得极具挑战性。本实践探讨了编排器用来构建健壮工作流的基础技术——幂等性和去重——以保证每个操作都“精确执行一次”，从而防止数据损坏和状态不一致。",
            "id": "4234389",
            "problem": "一个分布式工作流编排器管理着一组用于信息物理资产的数字孪生（DTs）。对于每个以 $i \\in \\{1,\\dots,N\\}$ 索引的资产，其孪生体 $T_i$ 暴露一个确定性状态转移接口，其中任何命令 $c$ 都会在孪生体状态集 $S$ 上引起一个纯函数 $f_c:S \\to S$，并将该转移提交到持久化存储。编排器与每个 $T_i$ 之间的传输层提供至少一次传递语义：当编排器发送一个带有逻辑操作标识符 $o \\in \\mathbb{N}$ 的消息时，接收方收到的传递次数 $X$ 满足 $X \\in \\{1,2,\\dots\\}$，传递可能被任意重复和重排序，但不会丢失。编排器试图在应用层实现精确一次语义：对于每个逻辑操作标识符 $o$，预期的状态转移只对相应的 $T_i$ 应用一次。\n\nDT 服务实现了两种机制：\n- 幂等命令：对于任何命令 $c$ 和所有 $s \\in S$，函数 $f_c$ 满足 $f_c(f_c(s)) = f_c(s)$。\n- 去重：每个 $T_i$ 维护一个已处理逻辑操作标识符的持久化集合 $D \\subset \\mathbb{N}$。在收到带有标识符 $o$ 和命令 $c$ 的消息时，$T_i$ 执行一个原子事务，检查 $o \\in D$ 是否成立。如果不成立，则将 $f_c$ 应用于当前状态 $s$，持久化写入新状态 $s' = f_c(s)$，将 $o$ 添加到 $D$，并进行确认；如果 $o \\in D$，则不重新应用 $f_c$。\n\n假设关于分布式系统有以下基本事实：\n- 至少一次传递允许重复和重排序，但保证每个发送的消息至少被传递一次。\n- 幂等性是一个函数级别的属性，定义为对于函数定义域中的所有 $x$，都有 $f(f(x))=f(x)$。\n- 应用层上的精确一次语义要求，对于每个逻辑操作标识符 $o$，尽管存在传输层的重复和重排序，与 $o$ 相关的可观察状态转移的应用次数不多于一次也不少于一次。\n- 原子性意味着去重检查、状态转移应用以及在 $D$ 中记录 $o$ 的过程作为一个不可分割的操作来执行，该操作相对于并发传递是可线性化的。\n\n哪个（些）陈述正确地解释了幂等命令和去重如何共同在分布式数字孪生编排中，在至少一次传输之上保证精确一次语义？\n\nA. 如果每个命令 $c$ 都是幂等的，并且每个 $T_i$ 都执行一个以 $o$ 为键、带有持久化去重集 $D$ 的原子“检查-应用-记录”事务，那么对于任何 $X \\in \\{1,2,\\dots\\}$ 的重复传递和任何重排序模式，与 $o$ 相关的状态转移都只应用一次。\n\nB. 即使没有去重，$f_c$ 的幂等性本身也能在至少一次传递之上保证精确一次语义，因为 $f_c(f_c(s)) = f_c(s)$ 意味着无论并发性或记录进度的失败如何，重复都是无害的。\n\nC. 只要去重窗口是有限的，并且传输层仅在该窗口内对消息进行重排序，去重本身就能为非幂等命令保证精确一次语义。\n\nD. 编排器可以仅依靠传输层的端到端确认和超时来保证精确一次语义，而无需幂等性或去重。\n\nE. 幂等命令与去重相结合无法处理重排序；因此，要实现精确一次语义，需要在传输层对所有消息施加全序，以串行化命令应用。",
            "solution": "我们从问题中陈述的基础定义和属性开始。至少一次传递意味着可能存在重复（$X \\ge 1$）和任意重排序。应用层上的精确一次语义要求，对于每个逻辑操作标识符 $o$，相应的状态转移只应用于孪生体状态一次。幂等性定义为对于所有 $s \\in S$，都有 $f_c(f_c(s))=f_c(s)$，这意味着重复应用相同的命令 $c$ 与单次应用产生相同的结果。检查-应用-记录的原子性确保了相对于并发的可线性化行为。\n\n我们将 DT 服务建模为处理针对同一逻辑操作的一系列传递 $(o,c)$（可能包含重复和重排序）。设处理前的当前状态为 $s_0 \\in S$，且 $D_0 = \\emptyset$。考虑针对标识符 $o$ 的任意传递消息序列：$(o,c)$ 出现 $X$ 次，并与其他标识符的消息任意交错。DT 服务针对标识符 $o$ 的原子逻辑如下：\n- 如果 $o \\notin D$，则计算 $s' = f_c(s)$，持久化写入 $s'$，并设置 $D \\leftarrow D \\cup \\{o\\}$。\n- 如果 $o \\in D$，则不对状态 $s$ 做任何操作。\n\n我们通过不变量和可线性化来论证在重复和重排序情况下的正确性。\n\n不变量 $I_1$：一旦 $o$ 被添加到 $D$ 中，后续带有标识符 $o$ 的传递无法改变状态。这直接源于条件分支：如果 $o \\in D$，则不会发生 $f_c$ 的应用。\n\n不变量 $I_2$：对 $o$ 的第一次成功处理（按可线性化顺序）会同时将状态更新为 $f_c(s)$ 并记录 $o \\in D$。原子性确保了不存在多个并发线程对同一个 $o$ 同时通过检查的交错情况；因此，存在一个唯一的线性化点，在该点上发生状态转移和记录。\n\n根据这些不变量，对于任何 $X \\in \\{1,2,\\dots\\}$ 和任何重排序模式，与 $o$ 相关的状态变化最多只有一次。因为至少一次传递保证了至少有一次传递发生，并且 DT 服务会处理（在线性化顺序中的）第一次这样的传递直到完成，所以与 $o$ 相关的状态变化恰好有一次。$f_c$ 的幂等性确保了在病态情况下，例如由于管道中其他地方的非原子性或跨重叠逻辑操作的部分重复而意外重试并再次应用 $f_c$ 时，重复应用会产生 $f_c(f_c(s))=f_c(s)$，使得任何意外的第二次应用都是无害的。然而，在此设计中，每个 $o$ 实现精确一次的主要保证依赖于带有原子“检查-应用-记录”的去重机制。幂等性补充了去重机制，确保即使由于瞬时故障错误分类操作导致重复应用侥幸通过，最终状态仍然保持一致。\n\n我们现在分析每个选项：\n\n选项 A：如果每个命令都是幂等的，并且 DT 执行一个带有持久化 $D$ 的原子“检查-应用-记录”操作，那么重复和重排序都能被处理。原子性确保对于标识符 $o$，$f_c$ 的成功应用恰好一次，并且 $o$ 被精确插入到 $D$ 中一次。一旦 $o \\in D$，后续对 $o$ 的传递都将被忽略，满足了至多一次。至少一次传递确保了至少一次应用。在完美的原子性和正确的去重机制下，幂等性对于精确一次的保证并非严格必要，但它加强了针对边界情况的保证，并且在多步工作流中能很好地组合。因此，关于在重复和重排序情况下状态转移只应用一次的陈述是正确的。结论：正确。\n\n选项 B：幂等性本身就能在没有去重的情况下保证精确一次语义。这是不正确的。如果同一个命令重复应用于同一个状态，幂等性确保 $f_c(f_c(s))=f_c(s)$。然而，没有去重和原子记录，并发的重复传递可能导致多次状态写入，这会破坏更高层的不变量（例如，多次发出事件、与外部非幂等接收器交互、或推进版本计数器）。此外，函数级别的幂等性不能阻止重复的副作用，如确认、外部驱动或与其他命令的非交换组合。精确一次要求控制副作用边界，这通常通过持久化去重记录和原子性来实现。因此，仅有幂等性是不够的。结论：不正确。\n\n选项 C：只要去重窗口有限且重排序有界，去重本身就能为非幂等命令保证精确一次。这由于两个原因是不正确的。首先，有限的去重窗口意味着在一段时间后或被驱逐后，带有相同 $o$ 的重复消息可能会被重新处理，从而导致非幂等函数 $f_c$ 的第二次应用，违反了至多一次语义。其次，即使重排序有界，由于网络分区或重试风暴，重复消息也可能在窗口过期后到达。非幂等命令放大了这种风险，因为任何错过的重复都会导致不同的状态转移。没有幂等性，去重间隙会转化为可观察到的重复效应。结论：不正确。\n\n选项 D：可以使用确认和超时来保证精确一次，而无需幂等性或去重。这是不正确的。确认和超时是传输层机制，它们影响传递尝试，但不能在至少一次系统中阻止重复传递。当存在重复和重排序时，它们无法确保应用层效果恰好发生一次。没有去重和幂等性，如果 $f_c$ 非幂等，重复传递会导致 $f_c$ 的重复应用和重复的副作用。结论：不正确。\n\n选项 E：幂等命令与去重相结合无法处理重排序；需要全序。这是不正确的。以 $o$ 为键的去重对重排序不敏感：无论到达顺序如何，在线性化顺序中处理的第一个传递会应用 $f_c$ 并记录 $o \\in D$，所有后续带有相同 $o$ 的传递都将被忽略。每个 $o$ 的精确一次并不要求跨不同 $o$ 值的全序。全序是一个比必要条件更强的条件，并且通常不切实际；带有原子性的按标识符去重足以在中和重排序下的重复。结论：不正确。\n\n因此，正确选项是 A。\n\n为进一步巩固推导，我们来形式化选项 A 的保证。设标识符 $o$ 的所有传递集合为 $M_o = \\{m_1,\\dots,m_X\\}$，其中 $X \\in \\{1,2,\\dots\\}$。因为 DT 服务用一个将“检查-应用-记录”线性化的原子操作来处理每个 $m_k$，所以存在一个唯一的索引 $k^\\star \\in \\{1,\\dots,X\\}$（如果 $o$ 最初就在 $D$ 中，则不存在这样的索引），使得：\n- 对于 $k = k^\\star$，在线性化点 $o \\notin D$，所以 $s \\leftarrow f_c(s)$ 并且 $D \\leftarrow D \\cup \\{o\\}$。\n- 对于所有 $k \\neq k^\\star$，在线性化点 $o \\in D$，所以 $s$ 保持不变。\n\n因此，对于 $o$ 的状态转移恰好应用一次。如果由于 DT 服务之外的瞬时违规导致病态重放意外地执行了两次 $f_c$，幂等性确保 $f_c(f_c(s)) = f_c(s)$，因此可观察状态保持一致。将原子去重和幂等转移相结合，可在至少一次传输之上产生鲁棒性和精确一次语义，而无需全序或除传递保证之外的专门传输支持。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在分布式系统中，组件故障是不可避免的。编排器的关键作用之一是促进快速恢复，以维持服务连续性。本实践将深入探讨如何使用概率方法对恢复过程进行建模，以计算平均恢复时间（$MTTR$），这是评估系统弹性并满足服务水平目标的关键指标。",
            "id": "4234447",
            "problem": "一个分布式数字孪生服务在边缘和云端协调副本，以确保微服务崩溃后的服务连续性。考虑一个微服务实例，其恢复过程经历三个顺序且不重叠的阶段：检测、故障转移和状态预热。平均恢复时间（MTTR）定义为从故障发生到服务满足连续性目标的预期总时间。对每个阶段使用以下有科学依据的模型。\n\n检测阶段：协调器订阅 $k=3$ 个独立的监视器。监视器 $i$ 的检测延迟被建模为一个速率为 $\\lambda_i$（单位：每秒）的指数随机变量，速率分别为 $\\lambda_1 = 0.8$, $\\lambda_2 = 0.4$, 和 $\\lambda_3 = 0.2$。一旦第一个监视器触发，就宣告检测完成。\n\n故障转移阶段：检测到故障后，协调器通过两阶段提交（2PC）协议，在 $n=4$ 个独立的协调者之间执行向热备副本的协调切换。每个协调者的确认延迟被建模为一个独立的指数随机变量，其共同速率为 $\\gamma = 0.9$（单位：每秒）。提交延迟等于 $n$ 个协调者中最慢的确认时间。此外，容器置备时间包括 $k_s=5$ 个顺序阶段，每个阶段都被建模为独立的指数分布，共同速率为 $\\beta=10$（单位：每秒），因此置备时间是 $k_s$ 个速率为 $\\beta$ 的指数分布之和。\n\n预热阶段：故障转移后，活动的孪生体等待来自两个独立对等孪生体中任意一个的最新状态快照的最早到达。到达时间服从指数分布，速率分别为 $\\nu_1 = 0.5$ 和 $\\nu_2 = 0.25$（单位：每秒），并使用最早到达的时间。一旦快照到达，反序列化会产生 $\\delta = 0.3$ 秒的确定性延迟。\n\n从指数分布、顺序统计量和期望线性性的基本定义和成熟结论出发，推导此协调恢复过程的平均恢复时间（MTTR），并使用上述参数计算其数值。将您的答案四舍五入到四位有效数字。最终时间以秒为单位表示。",
            "solution": "平均恢复时间（MTTR）是总恢复时间 $T_{total}$ 的期望值。恢复过程包括三个顺序且不重叠的阶段。设检测、故障转移和预热阶段的持续时间分别为随机变量 $T_{detect}$、$T_{failover}$ 和 $T_{warmup}$。总时间是它们的和：\n$$T_{total} = T_{detect} + T_{failover} + T_{warmup}$$\n根据期望的线性性，MTTR是每个阶段期望持续时间的总和：\n$$MTTR = E[T_{total}] = E[T_{detect}] + E[T_{failover}] + E[T_{warmup}]$$\n我们现在计算每个阶段的期望持续时间。\n\n**1. 期望检测时间: $E[T_{detect}]$**\n\n检测阶段在 $k=3$ 个独立监视器中的第一个触发时结束。设监视器 $i$ 的检测延迟为指数随机变量 $D_i \\sim \\text{Exp}(\\lambda_i)$。总检测时间为 $T_{detect} = \\min(D_1, D_2, D_3)$。\n独立指数随机变量的一个基本性质是，它们的最小值也是一个指数随机变量，其速率是各个速率的总和。\n因此，$T_{detect} \\sim \\text{Exp}(\\lambda_{sum})$，其中 $\\lambda_{sum} = \\lambda_1 + \\lambda_2 + \\lambda_3$。\n速率为 $\\lambda$ 的指数随机变量的期望值为 $\\frac{1}{\\lambda}$。因此：\n$$E[T_{detect}] = \\frac{1}{\\lambda_1 + \\lambda_2 + \\lambda_3}$$\n代入给定值：\n$$E[T_{detect}] = \\frac{1}{0.8 + 0.4 + 0.2} = \\frac{1}{1.4} \\text{ s}$$\n\n**2. 期望故障转移时间: $E[T_{failover}]$**\n\n故障转移阶段包括两个不同的部分：2PC提交延迟 $T_{commit}$ 和容器置备时间 $T_{provision}$。问题结构表明它们是该阶段持续时间的相加部分，因此 $T_{failover} = T_{commit} + T_{provision}$。根据期望的线性性：\n$$E[T_{failover}] = E[T_{commit}] + E[T_{provision}]$$\n\n首先，我们计算 $E[T_{commit}]$。提交延迟是来自 $n=4$ 个独立协调者的最慢确认时间。设每个协调者的延迟为 $C_i$，其中 $C_i$ 是独立同分布（i.i.d.）于 $\\text{Exp}(\\gamma)$ 的随机变量。\n那么，$T_{commit} = \\max(C_1, C_2, C_3, C_4)$。$n$ 个速率为 $\\gamma$ 的独立同分布指数随机变量的最大值的期望值是一个标准结果，由下式给出：\n$$E[\\max(C_1, \\dots, C_n)] = \\frac{1}{\\gamma} \\sum_{i=1}^{n} \\frac{1}{i} = \\frac{H_n}{\\gamma}$$\n其中 $H_n$ 是第 $n$ 个调和数。对于 $n=4$：\n$$H_4 = 1 + \\frac{1}{2} + \\frac{1}{3} + \\frac{1}{4} = \\frac{12+6+4+3}{12} = \\frac{25}{12}$$\n当 $\\gamma = 0.9$ 时：\n$$E[T_{commit}] = \\frac{H_4}{\\gamma} = \\frac{25/12}{0.9} = \\frac{25}{12 \\times 0.9} = \\frac{25}{10.8} \\text{ s}$$\n\n接下来，我们计算 $E[T_{provision}]$。置备时间是 $k_s=5$ 个顺序阶段的总和，每个阶段被建模为独立同分布的指数随机变量 $P_j \\sim \\text{Exp}(\\beta)$，其中 $\\beta=10$。\n$$T_{provision} = \\sum_{j=1}^{k_s} P_j$$\n根据期望的线性性，总的期望置备时间是各个期望时间的总和：\n$$E[T_{provision}] = \\sum_{j=1}^{k_s} E[P_j] = \\sum_{j=1}^{k_s} \\frac{1}{\\beta} = \\frac{k_s}{\\beta}$$\n当 $k_s=5$ 且 $\\beta=10$ 时：\n$$E[T_{provision}] = \\frac{5}{10} = 0.5 \\text{ s}$$\n总的期望故障转移时间是：\n$$E[T_{failover}] = E[T_{commit}] + E[T_{provision}] = \\frac{25}{10.8} + 0.5 \\text{ s}$$\n\n**3. 期望预热时间: $E[T_{warmup}]$**\n\n预热阶段包括等待最早的快照到达时间 $T_{arrival}$，然后是一个确定性的反序列化延迟 $\\delta = 0.3$ 秒。\n$$T_{warmup} = T_{arrival} + \\delta$$\n$$E[T_{warmup}] = E[T_{arrival}] + E[\\delta] = E[T_{arrival}] + \\delta$$\n到达时间 $T_{arrival}$ 是两个独立的指数随机变量 $A_1 \\sim \\text{Exp}(\\nu_1)$ 和 $A_2 \\sim \\text{Exp}(\\nu_2)$ 的最小值。与检测阶段类似，最小值是一个指数随机变量，其速率等于各速率之和。\n$$T_{arrival} \\sim \\text{Exp}(\\nu_1 + \\nu_2)$$\n其期望值为：\n$$E[T_{arrival}] = \\frac{1}{\\nu_1 + \\nu_2}$$\n当 $\\nu_1 = 0.5$ 且 $\\nu_2 = 0.25$ 时：\n$$E[T_{arrival}] = \\frac{1}{0.5 + 0.25} = \\frac{1}{0.75} = \\frac{4}{3} \\text{ s}$$\n总的期望预热时间是：\n$$E[T_{warmup}] = \\frac{4}{3} + 0.3 \\text{ s}$$\n\n**4. 总平均恢复时间 (MTTR)**\n\n我们现在将每个阶段的期望时间相加，以求得MTTR。\n$$MTTR = E[T_{detect}] + E[T_{failover}] + E[T_{warmup}]$$\n$$MTTR = \\left( \\frac{1}{1.4} \\right) + \\left( \\frac{25}{10.8} + 0.5 \\right) + \\left( \\frac{4}{3} + 0.3 \\right)$$\n让我们计算数值：\n$$E[T_{detect}] = \\frac{1}{1.4} \\approx 0.7142857 \\text{ s}$$\n$$E[T_{failover}] = \\frac{25}{10.8} + 0.5 \\approx 2.3148148 + 0.5 = 2.8148148 \\text{ s}$$\n$$E[T_{warmup}] = \\frac{4}{3} + 0.3 \\approx 1.3333333 + 0.3 = 1.6333333 \\text{ s}$$\n将这些值相加：\n$$MTTR \\approx 0.7142857 + 2.8148148 + 1.6333333 = 5.1624338 \\text{ s}$$\n问题要求答案四舍五入到四位有效数字。数值是 $5.1624338...$。第五位有效数字是 $4$，所以我们向下舍入。\n$$MTTR \\approx 5.162 \\text{ s}$$",
            "answer": "$$\\boxed{5.162}$$"
        }
    ]
}