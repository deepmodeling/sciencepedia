{
    "hands_on_practices": [
        {
            "introduction": "这第一个实践是博弈论的基础练习。我们将分析一个场景，其中信息物理系统中的多个智能体竞争资源，从而导致拥塞。通过推导纳什均衡，你将学习如何预测非合作策略互动的结果，并理解个体激励如何可能导致系统性的低效。",
            "id": "4224185",
            "problem": "考虑信息物理系统 (CPS) 中的一个协同资源共享场景，其中 $n$ 个在边缘设备上运行的相同数字孪生同时选择它们的数据更新率 $x_i \\in \\mathbb{R}_{\\ge 0}$，以最大化其各自的效用。更高更新率的好处被建模为线性新鲜度奖励，而本地能源和拥塞惩罚则分别被建模为二次项和双线性项。智能体 $i$ 的效用为\n$$\nu_i(x_i,x_{-i}) \\;=\\; a\\,x_i \\;-\\; \\frac{b}{2}\\,x_i^{2} \\;-\\; c\\,x_i \\sum_{j \\ne i} x_j,\n$$\n其中 $a > 0$ 是新鲜度的边际价值，$b > 0$ 表示计算和通信的本地二次成本，而 $c \\ge 0$ 表示由共享无线和计算资源上的拥塞所引起的单位交叉影响的市场协调价格。智能体同时且非合作地选择 $x_i$。假设参数值使得纳什均衡是内部的（即，在严格为正的选择下达到最优响应）。\n\n从纳什均衡的定义（每个智能体的行动在给定其他智能体行动的情况下最大化其自身效用）以及单决策变量凹最大化的一阶最优性条件出发，推导每个智能体的对称纳什均衡更新率 $x^{*}$。然后，通过对 $x^{*}$ 关于 $c$ 求导，对 $c$ 进行比较静态分析，并确定 $\\frac{\\partial x^{*}}{\\partial c}$ 的解析表达式和符号。\n\n将您的最终结果表示为 $x^{*}$ 和 $\\frac{\\partial x^{*}}{\\partial c}$ 的闭式解析表达式。不需要进行数值评估或四舍五入，并且最终答案中无需报告物理单位。",
            "solution": "所述问题是有效的。它提出了一个清晰、自洽且有科学依据的博弈论问题，具体是为多智能体系统中的非合作资源分配建模。效用函数是标准的二次形式，这保证了智能体自身行动的效用函数具有严格凹性，确保了使用一阶条件寻找纳什均衡的问题是适定的。所有参数都有明确的定义和必要的约束条件（$a>0$、$b>0$、$c \\ge 0$），并且目标也得到了精确陈述。该问题没有歧义、矛盾和事实错误。\n\n问题的核心是找到一个博弈的对称纳什均衡，在该博弈中，$n$ 个智能体选择其行动 $x_i$ 以最大化其各自的效用。纳什均衡是一个策略组合 $(x_1^*, x_2^*, \\ldots, x_n^*)$，使得对于每个智能体 $i$，$x_i^*$ 是对其他智能体均衡策略 $x_{-i}^*$ 的最优响应。也就是说，$x_i^*$ 最大化 $u_i(x_i, x_{-i}^*)$。\n\n智能体 $i$ 的效用函数由下式给出：\n$$\nu_i(x_i, x_{-i}) = a\\,x_i - \\frac{b}{2}\\,x_i^{2} - c\\,x_i \\sum_{j \\ne i} x_j\n$$\n为了找到智能体 $i$ 的最优响应，我们关于其自身行动 $x_i$ 最大化 $u_i$，并将所有其他智能体 $x_j$（对于 $j \\ne i$）的行动视为固定参数。由于问题假设存在内部解 ($x_i > 0$)，我们可以通过对效用函数关于 $x_i$ 求一阶偏导数并将其设为零来找到最优的 $x_i$。\n\n首先，我们计算偏导数：\n$$\n\\frac{\\partial u_i}{\\partial x_i} = \\frac{\\partial}{\\partial x_i} \\left( a\\,x_i - \\frac{b}{2}\\,x_i^{2} - c\\,x_i \\sum_{j \\ne i} x_j \\right) = a - b\\,x_i - c\\,\\sum_{j \\ne i} x_j\n$$\n为确认将此导数设为零能得到最大值，我们检查二阶条件。二阶偏导数为：\n$$\n\\frac{\\partial^2 u_i}{\\partial x_i^2} = -b\n$$\n由于 $b > 0$，二阶导数严格为负。这证实了效用函数 $u_i$ 关于 $x_i$ 是严格凹的，因此一阶条件足以确定智能体 $i$ 效用的唯一全局最大值。\n\n将一阶条件设为零，得到智能体 $i$ 的最优响应函数：\n$$\na - b\\,x_i - c\\,\\sum_{j \\ne i} x_j = 0\n$$\n$$\nb\\,x_i = a - c\\,\\sum_{j \\ne i} x_j\n$$\n$$\nx_i = \\frac{a - c\\,\\sum_{j \\ne i} x_j}{b}\n$$\n接下来，我们寻找对称纳什均衡。在对称均衡中，所有智能体选择相同的行动，我们将其表示为 $x^*$。因此，对于所有 $i \\in \\{1, 2, \\ldots, n\\}$，有 $x_i = x^*$。对于任意智能体 $i$，其他智能体行动的总和变为：\n$$\n\\sum_{j \\ne i} x_j = \\sum_{j \\ne i} x^* = (n-1)x^*\n$$\n将此代入一阶条件 ($a - b\\,x_i - c\\,\\sum_{j \\ne i} x_j = 0$)，并令 $x_i = x^*$：\n$$\na - b\\,x^* - c\\,(n-1)x^* = 0\n$$\n现在，我们求解这个关于 $x^*$ 的方程：\n$$\na = b\\,x^* + c\\,(n-1)x^*\n$$\n$$\na = x^* \\left( b + c(n-1) \\right)\n$$\n这就得到了对称纳什均衡更新率：\n$$\nx^* = \\frac{a}{b + c(n-1)}\n$$\n问题接着要求通过求 $x^*$ 关于协调价格参数 $c$ 的导数来进行比较静态分析。我们对 $x^*$ 的表达式关于 $c$ 求导，将 $a$、$b$ 和 $n$ 视为常数。使用商法则，或等价地，对 $x^* = a(b + c(n-1))^{-1}$ 使用链式法则：\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\frac{d}{dc} \\left[ (b + c(n-1))^{-1} \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\left[ -1 \\cdot (b + c(n-1))^{-2} \\cdot \\frac{d}{dc}(b + c(n-1)) \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = a \\cdot \\left[ -(b + c(n-1))^{-2} \\cdot (n-1) \\right]\n$$\n$$\n\\frac{\\partial x^*}{\\partial c} = -\\frac{a(n-1)}{\\left( b + c(n-1) \\right)^2}\n$$\n最后，我们确定该导数的符号。问题陈述 $a > 0$ 和 $b > 0$。智能体的数量 $n$ 是一个大于或等于1的整数。协调的背景意味着 $n \\ge 2$，使得项 $(n-1)$ 为正。参数 $c$ 是非负的，$c \\ge 0$。\n分子是 $a(n-1)$。对于 $n \\ge 2$，该项为正。\n分母是 $(b + c(n-1))^2$。由于 $b>0$，$c \\ge 0$ 且 $n \\ge 2$，底数 $b + c(n-1)$ 严格为正。因此其平方也严格为正。\n因此，该导数是一个负数除以一个正数：\n$$\n\\frac{\\partial x^*}{\\partial c}  0 \\quad \\text{for } n \\ge 2\n$$\n如果 $n=1$，问题退化为无交互的单智能体优化问题，项 $(n-1)$ 为零，且 $\\frac{\\partial x^*}{\\partial c} = 0$，这是合理的，因为在这种情况下 $c$ 没有影响。根据问题背景，我们假设 $n \\ge 2$。负号表示随着拥塞价格 $c$ 的增加，每个智能体的均衡更新率 $x^*$ 会降低。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{a}{b + c(n-1)}  -\\frac{a(n-1)}{(b + c(n-1))^{2}}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在均衡概念的基础上，这个实践将重点从非合作博弈转移到旨在最大化社会福利的市场化协调。你将扮演微电网中央规划者的角色，使用强大的优化技术（KKT条件）来寻找福利最大化的资源分配方案。这个练习将揭示一个源于系统边际成本的均衡价格，如何能作为一个强大的信号，引导消费者行为走向全局最优的结果。",
            "id": "4224163",
            "problem": "考虑一个通过信息物理系统 (CPS) 的数字孪生进行协调的信息物理能源微电网。一个聚合商供应总量为 $Q$ 的能源，其成本为 $C(Q) = \\frac{\\beta}{2} Q^{2}$。有 $n$ 个消费者，由 $i \\in \\{1,2,\\dots,n\\}$ 索引，每个消费者对消费量 $x_{i}$ 有一个线性估值 $v_{i}(x_{i}) = \\alpha_{i} x_{i}$，且消费量受限于 $0 \\leq x_{i} \\leq \\bar{x}_{i}$，以及市场出清约束 $Q = \\sum_{i=1}^{n} x_{i}$。聚合商公布单位能源的标量价格 $p$，该价格必须与实现的 $Q$ 处的边际成本一致，即 $p = C'(Q)$。社会计划者的问题是在耦合约束和箱式约束下最大化总福利：\n$$\n\\max_{x,Q} \\;\\; \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2}\n\\quad \\text{subject to} \\quad\nQ = \\sum_{i=1}^{n} x_{i}, \\quad 0 \\leq x_{i} \\leq \\bar{x}_{i}.\n$$\n您将通过写出并求解 Karush–Kuhn–Tucker (KKT) 系统来刻画从该社会福利最大化问题中产生的竞争均衡（Karush–Kuhn–Tucker (KKT) 条件是约束凸优化的一阶最优性条件），将均衡价格 $p^{*}$ 识别为耦合约束上的拉格朗日乘子（其必须等于边际成本），并通过箱式约束处的法锥条件推导出均衡分配。\n\n使用以下数据进行计算：\n- 消费者数量 $n = 4$。\n- 估值斜率 $\\alpha_{1} = 6$, $\\alpha_{2} = 3$, $\\alpha_{3} = 1.2$, $\\alpha_{4} = 0.9$。\n- 容量上限 $\\bar{x}_{1} = 2$, $\\bar{x}_{2} = 1$, $\\bar{x}_{3} = 0.5$, $\\bar{x}_{4} = 0.5$。\n- 成本参数 $\\beta = 1$。\n\n假设目标函数和约束条件与陈述完全一致，并且均衡是唯一的。使用 KKT 系统找到福利最大化的分配 $(x^{*}, Q^{*})$ 以及相应的均衡价格 $p^{*} = \\beta Q^{*}$。仅报告均衡价格 $p^{*}$ 作为您的最终答案。价格以“货币单位/能源单位”表示。无需四舍五入。",
            "solution": "问题是通过求解一个社会福利最大化问题来找到信息物理能源微电网中的均衡价格。这是一个约束凸优化问题，可以使用 Karush-Kuhn-Tucker (KKT) 条件来求解。\n\n首先，我们验证问题的有效性。\n- **已知条件**：\n  - 目标函数：$\\max_{x,Q} \\;\\; \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2}$\n  - 约束条件：$Q = \\sum_{i=1}^{n} x_{i}$，以及 $0 \\leq x_{i} \\leq \\bar{x}_{i}$，对于 $i \\in \\{1, \\dots, n\\}$。\n  - 数据：$n=4$，$\\alpha = (6, 3, 1.2, 0.9)$，$\\bar{x} = (2, 1, 0.5, 0.5)$，$\\beta=1$。\n- **验证**：\n  - 该问题具有科学依据，代表了经济市场中社会福利最大化的标准模型。二次成本函数和线性估值函数是常见且有效的建模选择。\n  - 目标函数是严格凹函数，约束集是一个非空、紧致的凸集。这确保了唯一解的存在，使得该问题是适定的。\n  - 所有术语都有定义，数据充分，且没有矛盾。该问题是有效的。\n\n现在我们通过构建 KKT 系统来解决这个问题。该优化问题是：\n$$\n\\max_{x_{1},\\dots,x_{n},Q} \\;\\; \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2}\n$$\n受限于：\n$$\n\\sum_{i=1}^{n} x_{i} - Q = 0 \\\\\nx_{i} - \\bar{x}_{i} \\leq 0, \\quad \\forall i \\in \\{1, \\dots, n\\} \\\\\n-x_{i} \\leq 0, \\quad \\forall i \\in \\{1, \\dots, n\\}\n$$\n令 $p$ 为耦合（等式）约束的拉格朗日乘子，$\\mu_{i}$ 为上界约束 ($x_{i} \\leq \\bar{x}_{i}$) 的乘子，$\\lambda_{i}$ 为下界约束 ($x_{i} \\geq 0$) 的乘子。该最大化问题的拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(x, Q, p, \\mu, \\lambda) = \\sum_{i=1}^{n} \\alpha_{i} x_{i} - \\frac{\\beta}{2} Q^{2} - p\\left(\\sum_{i=1}^{n} x_{i} - Q\\right) - \\sum_{i=1}^{n} \\mu_{i}(x_{i} - \\bar{x}_{i}) - \\sum_{i=1}^{n} \\lambda_{i}(-x_{i})\n$$\n最优解 $(x^{*}, Q^{*})$ 和相应乘子 $(p^{*}, \\mu^{*}, \\lambda^{*})$ 的 KKT 条件如下：\n\n1.  **平稳性条件**（拉格朗日函数的梯度为零）：\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial Q} = -\\beta Q^{*} + p^{*} = 0 \\implies p^{*} = \\beta Q^{*}\n    $$\n    这证实了问题陈述中的条件，即均衡价格 $p^{*}$ 等于边际成本 $C'(Q^{*}) = \\beta Q^{*}$。\n    $$\n    \\frac{\\partial \\mathcal{L}}{\\partial x_{i}} = \\alpha_{i} - p^{*} - \\mu_{i}^{*} + \\lambda_{i}^{*} = 0 \\implies \\alpha_{i} - p^{*} = \\mu_{i}^{*} - \\lambda_{i}^{*}, \\quad \\forall i \\in \\{1, \\dots, n\\}\n    $$\n\n2.  **原始可行性**：\n    $$\n    \\sum_{i=1}^{n} x_{i}^{*} - Q^{*} = 0\n    $$\n    $$\n    0 \\leq x_{i}^{*} \\leq \\bar{x}_{i}, \\quad \\forall i\n    $$\n\n3.  **对偶可行性**：\n    $$\n    \\mu_{i}^{*} \\geq 0, \\quad \\lambda_{i}^{*} \\geq 0, \\quad \\forall i\n    $$\n\n4.  **互补松弛性**：\n    $$\n    \\mu_{i}^{*}(x_{i}^{*} - \\bar{x}_{i}) = 0, \\quad \\forall i\n    $$\n    $$\n    \\lambda_{i}^{*} x_{i}^{*} = 0, \\quad \\forall i\n    $$\n\n根据平稳性条件和互补松弛性条件，我们可以推断出在给定价格 $p^{*}$ 下每个消费者 $i$ 的行为：\n-   如果 $0   x_{i}^{*}  \\bar{x}_{i}$，则互补松弛性要求 $\\mu_{i}^{*} = 0$ 和 $\\lambda_{i}^{*} = 0$。此时关于 $x_i$ 的平稳性条件简化为 $\\alpha_{i} - p^{*} = 0$，即 $p^{*} = \\alpha_{i}$。\n-   如果 $x_{i}^{*} = \\bar{x}_{i}$，则 $\\lambda_{i}^{*} = 0$。平稳性条件为 $\\alpha_{i} - p^{*} = \\mu_{i}^{*}$。由于 $\\mu_{i}^{*} \\geq 0$，这意味着 $\\alpha_{i} \\geq p^{*}$。\n-   如果 $x_{i}^{*} = 0$，则 $\\mu_{i}^{*} = 0$。平稳性条件为 $\\alpha_{i} - p^{*} = -\\lambda_{i}^{*}$。由于 $\\lambda_{i}^{*} \\geq 0$，这意味着 $\\alpha_{i} \\leq p^{*}$。\n\n综合以上情况，对于给定的均衡价格 $p^{*}$，最优分配 $x_{i}^{*}$ 为：\n$$\nx_{i}^{*}(p^{*}) =\n\\begin{cases}\n\\bar{x}_{i}  \\text{if } p^{*}  \\alpha_{i} \\\\\n\\text{any value in } [0, \\bar{x}_{i}]  \\text{if } p^{*} = \\alpha_{i} \\\\\n0  \\text{if } p^{*}  \\alpha_{i}\n\\end{cases}\n$$\n这定义了每个消费者的需求作为价格的函数。当总需求等于总供给时，达到均衡。总供给量为 $Q^{*}$，它通过 $p^{*} = \\beta Q^{*}$ 与价格相关，因此总供给为 $S(p^{*}) = Q^{*} = p^{*}/\\beta$。总需求为 $D(p^{*}) = \\sum_{i=1}^{n} x_{i}^{*}(p^{*})$。\n均衡价格 $p^{*}$ 必须满足市场出清条件：\n$$\n\\sum_{i=1}^{n} x_{i}^{*}(p^{*}) = \\frac{p^{*}}{\\beta}\n$$\n我们使用给定数据：$\\beta = 1$，$\\alpha = (6, 3, 1.2, 0.9)$，以及 $\\bar{x} = (2, 1, 0.5, 0.5)$。市场出清条件变为 $\\sum_{i=1}^{4} x_{i}^{*}(p^{*}) = p^{*}$。我们相对于估值参数 $\\alpha_i$（已排序为 $\\alpha_1  \\alpha_2  \\alpha_3  \\alpha_4$）测试不同的价格水平。\n\n-   **情况 1：$p^{*}  \\alpha_{1} = 6$**。对于所有 $i$，$p^{*}  \\alpha_{i}$，所以 $x_{i}^{*} = 0$。\n    总需求为 $0$。方程为 $0 = p^{*}$，这与 $p^{*}  6$ 矛盾。\n\n-   **情况 2：$p^{*} = \\alpha_{1} = 6$**。此时 $x_{1}^{*} \\in [0, 2]$ 且 $x_{2}^{*}=x_{3}^{*}=x_{4}^{*}=0$。\n    方程为 $x_{1}^{*} = 6$。这与约束条件 $x_{1}^{*} \\leq \\bar{x}_{1} = 2$ 矛盾。\n\n-   **情况 3：$\\alpha_{2}  p^{*}  \\alpha_{1}$ (即 $3  p^{*}  6$)**。此时 $p^{*}  \\alpha_{1}$，所以 $x_{1}^{*} = \\bar{x}_{1} = 2$。对于 $i=2,3,4$，$p^{*}  \\alpha_{i}$，所以 $x_{2}^{*}=x_{3}^{*}=x_{4}^{*}=0$。\n    总需求为 $2$。方程为 $2 = p^{*}$。这与假设的价格范围 $p^{*} \\in (3, 6)$ 矛盾。\n\n-   **情况 4：$p^{*} = \\alpha_{2} = 3$**。此时 $p^{*}  \\alpha_{1}$，所以 $x_{1}^{*} = \\bar{x}_{1} = 2$。对于 $p^{*} = \\alpha_{2}$，消费者 2 是无差异的，所以 $x_{2}^{*} \\in [0, \\bar{x}_{2}] = [0, 1]$。对于 $i=3,4$，$p^{*}  \\alpha_{i}$，所以 $x_{3}^{*}=x_{4}^{*}=0$。\n    总需求为 $2 + x_{2}^{*}$。市场出清方程为 $2 + x_{2}^{*} = p^{*} = 3$。\n    这得到 $x_{2}^{*} = 1$。这个值在 $x_2^*$ 的允许范围内，因为 $x_2^* \\in [0, 1]$。\n    我们找到了一个一致的解。我们来验证一下：\n    -   均衡价格：$p^{*} = 3$。\n    -   分配：$x_{1}^{*} = 2$ (因为 $3  6$), $x_{2}^{*} = 1$ (使市场出清的值), $x_{3}^{*} = 0$ (因为 $3  1.2$), $x_{4}^{*} = 0$ (因为 $3  0.9$)。\n    -   总量：$Q^{*} = \\sum x_{i}^{*} = 2 + 1 + 0 + 0 = 3$。\n    -   价格-成本一致性：$p^{*} = \\beta Q^{*} \\implies 3 = 1 \\times 3$，成立。\n    所有条件都得到满足。唯一的均衡价格是 $p^{*} = 3$。\n\n-   **情况 5：$\\alpha_3  p^*  \\alpha_2$ (即 $1.2  p^*  3$)**。此时 $x_1^*=\\bar{x}_1=2$, $x_2^*=\\bar{x}_2=1$, 且 $x_3^*=x_4^*=0$。\n    总需求为 $2+1 = 3$。方程为 $3=p^*$，这与 $p^*  3$ 矛盾。\n\n分析证实，唯一有效的解出现在 $p^{*} = 3$。\n均衡价格是 3 货币单位/能源单位。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "我们最后的实践将解决一个更复杂和现实的挑战：在具有组合偏好的智能体之间分配不可分割的任务。你将实现维克里-克拉克-格罗夫斯（VCG）机制，这是机制设计的基石。这个动手编程练习将揭示如何设计一个系统，它不仅能找到最有效的资源分配方案，还能激励智能体真实地报告其私有信息，从而解决去中心化系统中信息不对称的关键挑战。",
            "id": "4224153",
            "problem": "考虑一个信息物理系统（Cyber-Physical System, CPS）中的组合任务分配问题，其中数字孪生代表可以执行任务包的代理。存在 $N$ 个代理和 $T$ 个不可分割的任务，任务的索引标签在集合 $\\{0,1,\\dots,T-1\\}$ 中。每个代理 $i \\in \\{0,1,\\dots,N-1\\}$ 对每一个任务包 $S \\subseteq \\{0,1,\\dots,T-1\\}$ 报告一个估值函数 $v_i(S)$，其中 $v_i(\\emptyset) = 0$。一个分配方案是将任务集合在代理之间进行划分，其约束条件是每个任务最多分配给一个代理，且任务可以保持未分配状态。代理具有拟线性效用，因此对于一个分配方案 $\\{S_i\\}_{i=0}^{N-1}$ 和支付 $\\{p_i\\}_{i=0}^{N-1}$，每个代理的效用为 $u_i = v_i(S_i) - p_i$。\n\n实现 Vickrey–Clarke–Groves (VCG) 机制：选择一个在可行性约束下最大化总报告社会福利 $\\sum_{i=0}^{N-1} v_i(S_i)$ 的分配方案，并计算 Clarke 枢轴支付，其中代理 $i$ 的支付为\n$$\np_i = h_i - \\sum_{j \\ne i} v_j(S_j^*)\n$$\n其中 $h_i$ 等于移除代理 $i$ 时所有其他代理的最大总福利，$\\{S_j^*\\}$ 表示所有代理都在场时选定的福利最大化分配方案。在有多个分配方案达到相同的最大社会福利时，通过选择最小化分配向量 $(a_0,a_1,\\dots,a_{T-1})$ 字典序的分配方案来打破平局，其中 $a_t \\in \\{-1,0,1,\\dots,N-1\\}$ 表示分配给任务 $t$ 的代理索引，-1 表示任务未分配。排序定义为 $-1  0  1  \\dots  (N-1)$。\n\n请从拟线性偏好和效率机制的基本原则出发，不要假设超出这些原则的快捷结论。\n\n对于每个测试用例，你的程序必须输出一个列表，其中包含：最大社会福利（浮点数）、分配给每个代理的任务分配情况（编码为任务的整数位掩码，即每个代理 $i$ 被分配一个掩码 $m_i \\in \\{0,1,\\dots,2^T-1\\}$，当且仅当任务 $t$ 分配给代理 $i$ 时，$m_i$ 的第 $t$ 位为 1），以及每个代理的 VCG 支付（浮点数）。将所有测试用例的结果汇总到一行中，以方括号括起来的逗号分隔列表的格式打印，例如 $[result_1,result_2,\\dots]$。\n\n测试套件：\n- 用例 1：$N=2$, $T=3$。任务为 $\\{0,1,2\\}$。所有子集 $S$ 的报告估值 $v_0$ 和 $v_1$ 如下所示（每个子集由其在 $\\{0,1,\\dots,7\\}$ 中的位掩码表示，其中第 $t$ 位表示是否包含任务 $t$）：\n  - 代理 0：$v_0(\\emptyset)=0$, $v_0(1)=3$, $v_0(2)=2$, $v_0(4)=2$, $v_0(3)=6.5$, $v_0(5)=5.5$, $v_0(6)=4.5$, $v_0(7)=8.0$。\n    位掩码形式：$v_0(0)=0$, $v_0(1)=3$, $v_0(2)=2$, $v_0(4)=2$, $v_0(3)=6.5$, $v_0(5)=5.5$, $v_0(6)=4.5$, $v_0(7)=8.0$。\n  - 代理 1：$v_1(\\emptyset)=0$, $v_1(1)=4.5$, $v_1(2)=1.5$, $v_1(4)=1.0$, $v_1(3)=5.0$, $v_1(5)=5.2$, $v_1(6)=2.2$, $v_1(7)=5.3$。\n    位掩码形式：$v_1(0)=0$, $v_1(1)=4.5$, $v_1(2)=1.5$, $v_1(4)=1.0$, $v_1(3)=5.0$, $v_1(5)=5.2$, $v_1(6)=2.2$, $v_1(7)=5.3$。\n- 用例 2：$N=3$, $T=1$。任务为 $\\{0\\}$。估值是对称且单值的：对于每个代理 $i \\in \\{0,1,2\\}$，$v_i(\\emptyset)=0$ 且 $v_i(\\{0\\})=5$。\n- 用例 3：$N=2$, $T=4$。任务为 $\\{0,1,2,3\\}$。估值在任务间是可加的；即对于每个代理 $i$，$v_i(S) = \\sum_{t \\in S} a_{i,t}$。原子值为：代理 0 为 $a_{0,0}=2.0, a_{0,1}=3.0, a_{0,2}=1.0, a_{0,3}=4.0$；代理 1 为 $a_{1,0}=3.0, a_{1,1}=1.0, a_{1,2}=5.0, a_{1,3}=0.5$。\n- 用例 4：$N=2$, $T=2$。任务为 $\\{0,1\\}$。所有任务包的估值恒为零：对于每个代理 $i \\in \\{0,1\\}$ 和任何 $S \\subseteq \\{0,1\\}$，$v_i(S)=0$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,result_3,result_4]$）。每个 $result_k$ 的格式必须为 $[\\text{SW}_k,[m_{k,0},m_{k,1},\\dots,m_{k,N-1}],[p_{k,0},p_{k,1},\\dots,p_{k,N-1}]]$，其中 $\\text{SW}_k$ 是用例 $k$ 的最大社会福利，$m_{k,i}$ 是用例 $k$ 中分配给代理 $i$ 的位掩码，$p_{k,i}$ 是用例 $k$ 中代理 $i$ 的 VCG 支付。",
            "solution": "所提出的问题是一个有效、适定的优化问题，其根源于机制设计领域——博弈论和微观经济学的一个子领域，并可直接应用于信息物理系统中的资源分配。它要求为组合任务分配场景实现 Vickrey–Clarke–Groves (VCG) 机制。\n\n**1. 基本原则**\n\n该问题的基础设定包含 $N$ 个理性代理和一个中央计划者（即机制）。每个代理 $i$ 对接收特定的任务包 $S$ 有一个私有估值 $v_i(S)$。代理的偏好被假定为拟线性的，这意味着他们的总效用是他们从分配到的任务包中获得的价值减去他们所做的任何货币支付：$u_i = v_i(S_i) - p_i$。目标是设计一个能够实现期望结果的机制（一个分配规则和一个支付规则）。VCG 机制因其在实现*效率*结果的同时，又能激励代理真实报告其估值而备受推崇。\n\n一个分配方案被定义为将所有任务的集合 $T$ 划分成不相交的子集 $\\{S_0, S_1, \\dots, S_{N-1}, S_{unassigned}\\}$，其中 $S_i$ 是分配给代理 $i$ 的任务包，$S_{unassigned}$ 是剩余未分配的任务。如果一个结果能够最大化产生的总价值，即*社会福利*，那么该结果是有效率的。社会福利定义为所有代理对其分配到的任务包的估值之和：$W = \\sum_{i=0}^{N-1} v_i(S_i)$。\n\n**2. VCG 机制：分配规则**\n\nVCG 机制的第一个组成部分是其分配规则：选择能够最大化总报告社会福利的分配方案 $\\{S_i^*\\}_{i=0}^{N-1}$。这被称为赢家确定问题（Winner Determination Problem, WDP）。\n$$ \\{S_i^*\\} = \\arg\\max_{\\{S_i\\}} \\sum_{i=0}^{N-1} v_i(S_i) \\quad \\text{subject to} \\quad S_i \\cap S_j = \\emptyset \\text{ for } i \\neq j $$\n对于一般的组合分配问题，WDP 在计算上是困难的（NP-hard）。然而，对于测试用例中给出的少量任务 $T$（$T \\le 4$），我们可以通过枚举所有可能性来找到最优分配。一个分配可以由一个向量 $(a_0, a_1, \\dots, a_{T-1})$唯一表示，其中 $a_t$ 是分配给任务 $t$ 的代理的索引，如果任务未分配，则为 -1。此类分配的总数为 $(N+1)^T$。\n\n找到福利最大化分配的算法如下：\n1. 初始化最大福利 $W_{max} = -\\infty$ 和一个对应的最佳分配向量 $A^* = \\text{None}$。\n2. 遍历每个可能的分配向量 $A = (a_0, \\dots, a_{T-1})$，其中每个 $a_t \\in \\{-1, 0, \\dots, N-1\\}$。\n3. 对于每个分配 $A$：\n    a. 对于每个代理 $i$，构建其任务包 $S_i = \\{t \\mid a_t = i\\}$。\n    b. 计算当前社会福利 $W_A = \\sum_{i=0}^{N-1} v_i(S_i)$。\n    c. 如果 $W_A  W_{max}$，则更新 $W_{max} = W_A$ 和 $A^* = A$。\n    d. 如果 $W_A = W_{max}$，应用指定的平局打破规则：将当前分配向量 $A$ 与存储的最佳向量 $A^*$ 进行字典序比较。如果 $A$ 更小，则更新 $A^* = A$。问题指定了排序为 $-1  0  1  \\dots  N-1$。\n4. 最终的向量 $A^*$ 决定了最优分配 $\\{S_i^*\\}$，最大社会福利为 $W_{max}$。\n\n**3. VCG 机制：支付规则**\n\nVCG 的第二个组成部分是支付规则，它确保真实报告估值是所有代理的占优策略。代理 $i$ 的支付，被称为 Clarke 枢轴支付，其计算值等于他们对社会其他成员施加的外部性。\n代理 $i$ 的支付 $p_i$ 是：\n$$ p_i = h_i - \\sum_{j \\neq i} v_j(S_j^*) $$\n- 项 $\\sum_{j \\neq i} v_j(S_j^*)$ 表示在最优分配中（当代理 $i$ 存在时）所有其他代理的总福利。这可以计算为 $W_{max} - v_i(S_i^*)$。\n- 项 $h_i$ 表示如果代理 $i$ 没有参与该机制，*本可以实现*的假设最大社会福利。这需要为代理集合 $\\{0, \\dots, N-1\\} \\setminus \\{i\\}$ 解决一个新的 WDP。设这个假设场景中的任务分配对象为 $a_t' \\in \\{-1, 0, \\dots, i-1, i+1, \\dots, N-1\\}$。那么 $h_i = \\max \\sum_{j \\neq i} v_j(S_j')$，其中 $\\{S_j'\\}$ 是在其他 $N-1$ 个代理中的最优分配。\n\n因此，代理 $i$ 的效用是 $u_i = v_i(S_i^*) - p_i = v_i(S_i^*) - (h_i - \\sum_{j \\neq i} v_j(S_j^*)) = (\\sum_{j=0}^{N-1} v_j(S_j^*)) - h_i = W^* - h_i$。这就是代理 $i$ 的参与所创造的社会盈余。\n\n**4. 算法实现策略**\n\n对于每个测试用例，总体算法流程如下：\n1.  **解析输入**：读取代理数量 $N$、任务数量 $T$ 以及估值函数 $v_i$。将估值存储在合适的数据结构中，例如字典列表，其中 `valuations[i][mask]` 给出代理 $i$ 对由整数位掩码 `mask` 表示的任务包的价值。对于可加性估值，预先计算完整的估值表。\n2.  **求解最优分配（$S^*$ 和 $W^*$）**：实现第 2 节中描述的穷举搜索 WDP 算法，考虑所有 $N$ 个代理（以及未分配选项）。这将产生最大社会福利 $W^*$ 和最优分配（以位掩码集合 $\\{S_0^*, S_1^*, \\dots, S_{N-1}^*\\}$ 的形式）。\n3.  **计算假设福利（$h_i$）**：对于从 $0$ 到 $N-1$ 的每个代理 $i$： a. 再次运行 WDP 算法，但这次是针对代理集合 $\\{0, \\dots, N-1\\} \\setminus \\{i\\}$。每个任务可能的分配对象现在是 $\\{-1, 0, \\dots, i-1, i+1, \\dots, N-1\\}$。 b. 这个子问题的最大福利即为 $h_i$。\n4.  **计算支付（$p_i$）**：对于每个代理 $i$，使用导出的值计算支付：\n    $$ p_i = h_i - (W^* - v_i(S_i^*)) $$\n5.  **格式化输出**：将该测试用例的结果组装成所需的列表格式：`[W*, [S_0*, S_1*, ...], [p_0, p_1, ...]]`。最后，将所有测试用例的结果汇总成单行输出。",
            "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport sys\n\ndef solve():\n    \"\"\"\n    Main function to solve all test cases and print the final result.\n    \"\"\"\n\n    # Suppress scientific notation for cleaner float output\n    np.set_printoptions(suppress=True)\n    # Redirect stdout to a buffer if needed to ensure single-line output,\n    # though direct printing should be fine.\n\n    # ------------------ Test Case 1 ------------------\n    N1, T1 = 2, 3\n    v1 = [\n        {0: 0, 1: 3, 2: 2, 3: 6.5, 4: 2, 5: 5.5, 6: 4.5, 7: 8.0},\n        {0: 0, 1: 4.5, 2: 1.5, 3: 5.0, 4: 1.0, 5: 5.2, 6: 2.2, 7: 5.3}\n    ]\n    test_cases = [(N1, T1, v1)]\n    \n    # ------------------ Test Case 2 ------------------\n    N2, T2 = 3, 1\n    v2 = [\n        {0: 0, 1: 5.0},\n        {0: 0, 1: 5.0},\n        {0: 0, 1: 5.0}\n    ]\n    test_cases.append((N2, T2, v2))\n    \n    # ------------------ Test Case 3 ------------------\n    N3, T3 = 2, 4\n    atoms3 = [\n        [2.0, 3.0, 1.0, 4.0],\n        [3.0, 1.0, 5.0, 0.5]\n    ]\n    v3 = [{}, {}]\n    for m in range(1  T3):\n        v3[0][m] = sum(atoms3[0][t] for t in range(T3) if (m >> t)  1)\n        v3[1][m] = sum(atoms3[1][t] for t in range(T3) if (m >> t)  1)\n    test_cases.append((N3, T3, v3))\n\n    # ------------------ Test Case 4 ------------------\n    N4, T4 = 2, 2\n    v4 = [\n        {m: 0.0 for m in range(1  T4)},\n        {m: 0.0 for m in range(1  T4)}\n    ]\n    test_cases.append((N4, T4, v4))\n\n    all_results = []\n    for N, T, valuations in test_cases:\n        result = _solve_vcg_case(N, T, valuations)\n        all_results.append(result)\n\n    # Format output as a string of lists, as specified by the problem's boilerplate.\n    # str([..]) produces '[.., ..]' which has spaces. The prompt requires this specific format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef _find_optimal_allocation(T, N, valuations, excluded_agents):\n    \"\"\"\n    Finds the welfare-maximizing allocation for a given set of active agents.\n    \"\"\"\n    active_agents = [i for i in range(N) if i not in excluded_agents]\n    assignee_options = [-1] + active_agents\n\n    max_welfare = -1.0\n    best_assignment = None\n\n    for assignment in product(assignee_options, repeat=T):\n        bundles = {agent_idx: 0 for agent_idx in active_agents}\n        for task_idx, agent_idx in enumerate(assignment):\n            if agent_idx != -1:\n                bundles[agent_idx] |= (1  task_idx)\n        \n        current_welfare = 0.0\n        for agent_idx, bundle_mask in bundles.items():\n            current_welfare += valuations[agent_idx].get(bundle_mask, 0.0)\n\n        if best_assignment is None or current_welfare > max_welfare:\n            max_welfare = current_welfare\n            best_assignment = assignment\n        elif abs(current_welfare - max_welfare)  1e-9: # Float comparison\n            # Tie-breaking rule: lexicographically smallest assignment vector\n            if assignment  best_assignment:\n                best_assignment = assignment\n    \n    # Convert the best assignment vector to agent masks\n    final_masks = [0] * N\n    if best_assignment:\n        for task_idx, agent_idx in enumerate(best_assignment):\n            if agent_idx != -1:\n                final_masks[agent_idx] |= (1  task_idx)\n\n    return max_welfare, final_masks\n\ndef _solve_vcg_case(N, T, valuations):\n    \"\"\"\n    Solves a single VCG problem case.\n    \"\"\"\n    # 1. Find the optimal allocation and social welfare with all agents\n    max_social_welfare, optimal_masks = _find_optimal_allocation(T, N, valuations, excluded_agents=set())\n\n    # 2. Compute VCG payments\n    payments = [0.0] * N\n    for i in range(N):\n        # Find h_i: max welfare if agent i is excluded\n        h_i, _ = _find_optimal_allocation(T, N, valuations, excluded_agents={i})\n\n        # Welfare of others in the optimal allocation\n        welfare_of_others = 0\n        for j in range(N):\n            if i != j:\n                welfare_of_others += valuations[j].get(optimal_masks[j], 0.0)\n        \n        # Clarke pivot payment\n        # p_i = h_i - welfare_of_others\n        # which is equivalent to p_i = h_i - (max_social_welfare - v_i(S_i*))\n        payments[i] = h_i - welfare_of_others\n\n    return [max_social_welfare, optimal_masks, [round(p, 4) for p in payments]]\n\nsolve()\n```"
        }
    ]
}