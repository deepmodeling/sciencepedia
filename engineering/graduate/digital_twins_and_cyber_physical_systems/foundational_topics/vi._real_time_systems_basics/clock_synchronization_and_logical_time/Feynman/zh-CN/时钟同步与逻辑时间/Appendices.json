{
    "hands_on_practices": [
        {
            "introduction": "将数字孪生的时间与物理资产的时间对齐是至关重要的一步，而网络时间协议（NTP）为此提供了标准机制。本练习将深入探讨NTP的核心模型，利用双向报文交换来估计时钟偏移和往返延迟。通过从第一性原理出发推导公式并将其应用于具体示例，你将深刻理解物理时钟同步的工作原理，更重要的是，认识到网络路径不对称性带来的基本限制。",
            "id": "4208007",
            "problem": "一个信息物理数字孪生系统必须通过网络时间协议（NTP）控制的双向交换，将其逻辑时间与物理设备的墙钟时间对齐。在单次交换中，记录了四个时间戳：数字孪生（客户端）在时间 $t_1$ 发送，设备控制器（服务器）在时间 $t_2$ 接收，服务器在时间 $t_3$ 发送其回复，客户端在时间 $t_4$ 接收。这些时间是相对于一个任意的纪元测量的，给定为 $(t_1, t_2, t_3, t_4) = (0.2, 0.25, 0.4, 0.65)$ 秒。假设在交换期间两个时钟具有相等的速率，并且服务器的处理延迟由时间间隔 $t_3 - t_2$ 捕获。从具有未知单向延迟和未知时钟偏移的基本双向时间传递模型出发，根据第一性原理推导客户端和服务器之间的估计时钟偏移以及往返网络延迟的表达式，然后根据给定的时间戳计算它们的值。接下来，当路径不对称性的大小（前向和反向单向延迟的绝对差）为 $0.05$ 秒时，量化偏移估计的最坏情况绝对误差，并在为数字孪生映射物理时间到逻辑时间的背景下解释这个边界。\n\n将你的最终数值结果以行矩阵的形式给出，依次包含：估计偏移 $\\theta$、往返延迟 $\\delta$ 和最坏情况绝对偏移误差 $|\\varepsilon_{\\theta}|$。所有量均以秒为单位表示，并将每个数字四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证。\n\n### 第一步：提取已知条件\n-   **系统**：信息物理数字孪生（客户端）和物理设备控制器（服务器）。\n-   **协议**：双向时间交换，具有网络时间协议（NTP）的特征。\n-   **时间戳**：\n    -   $t_1 = 0.2$ 秒（客户端发送请求）\n    -   $t_2 = 0.25$ 秒（服务器接收请求）\n    -   $t_3 = 0.4$ 秒（服务器发送回复）\n    -   $t_4 = 0.65$ 秒（客户端接收回复）\n-   **假设**：\n    1.  在交换期间，客户端和服务器的时钟具有相等的速率。\n    2.  服务器的处理延迟由时间间隔 $t_3 - t_2$ 捕获。\n-   **用于误差分析的附加数据**：\n    -   最坏情况路径不对称性大小：前向和反向单向延迟的绝对差 $|d_1 - d_2|$ 为 $0.05$ 秒。\n-   **任务**：\n    1.  从第一性原理推导估计时钟偏移（$\\theta$）和往返网络延迟（$\\delta$）的表达式。\n    2.  根据给定的时间戳计算这些表达式的值。\n    3.  在给定路径不对称性的情况下，量化偏移估计的最坏情况绝对误差 $|\\varepsilon_{\\theta}|$。\n    4.  解释误差边界。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学依据**：该问题基于网络时间协议（NTP）中使用的时钟同步基本模型，该协议是网络工程和分布式系统的基石。涉及时间戳、单向延迟和时钟偏移的模型是标准的且科学合理的。\n-   **适定性**：该问题提供了计算所要求量（$\\theta, \\delta, |\\varepsilon_{\\theta}|$）所需的所有数值数据（$t_1, t_2, t_3, t_4$ 和路径不对称性）。问题的结构旨在导出一个唯一的数值解。\n-   **客观性**：该问题以精确、定量且无偏见的技术语言陈述。\n-   **完整性与一致性**：该问题是自洽的，没有矛盾。假设（如在短时间间隔内时钟速率相等）是此类分析的标准假设，并且已明确说明。\n-   **真实性**：时间戳值和 $50$ 毫秒的路径不对称性对于真实世界的网络交换是合理的。\n\n### 第三步：结论与行动\n该问题是有效的，因为它具有科学依据、适定、客观且完整。我们可以继续进行求解。\n\n### 从第一性原理推导\n让我们将真实但未知的物理时间表示为 $T$。设客户端的时钟时间为 $C_C(T)$，服务器的时钟时间为 $C_S(T)$。我们定义时钟偏移 $\\theta$ 为服务器时钟领先于客户端时钟的量。\n$$C_S(T) = C_C(T) + \\theta$$\n时间戳 $t_1$ 和 $t_4$ 是在客户端时钟上测量的，而 $t_2$ 和 $t_3$ 是在服务器时钟上测量的。设 $d_1$ 是数据包从客户端到服务器的单向网络延迟， $d_2$ 是数据包从服务器返回客户端的单向延迟。\n\n服务器在其本地时间 $t_2$ 接收到请求的事件可以与客户端的发送时间 $t_1$ 相关联。到达服务器的真实时间是客户端出发的真实时间加上传输时间 $d_1$。当这个时间在服务器时钟上读取时，它相对于客户端时钟有一个偏移量 $\\theta$。\n因此，服务器的时间戳 $t_2$ 等于客户端的出发时间戳 $t_1$ 加上网络延迟 $d_1$，并根据时钟偏移 $\\theta$ 进行调整。\n$$t_2 = t_1 + d_1 + \\theta \\quad \\quad (1)$$\n\n同样，客户端在其本地时间 $t_4$ 接收到回复的事件与服务器的发送时间 $t_3$ 相关联。客户端的到达时间戳 $t_4$ 等于服务器的出发时间戳 $t_3$ 加上返回网络延迟 $d_2$，并根据时钟偏移进行调整。由于我们是从服务器时钟映射回客户端时钟，因此我们减去偏移量。\n$$t_4 = t_3 + d_2 - \\theta \\quad \\quad (2)$$\n\n我们可以重新整理这两个基本方程：\n$$t_2 - t_1 = d_1 + \\theta \\quad \\quad (1')$$\n$$t_4 - t_3 = d_2 - \\theta \\quad \\quad (2')$$\n\n我们得到了一个包含三个未知数（$d_1$、$d_2$ 和 $\\theta$）的两个方程组。该系统是欠定的。然而，我们可以求解往返延迟 $\\delta = d_1 + d_2$，并找到偏移量 $\\theta$ 的一个估计值。\n\n为了求出往返网络延迟 $\\delta$，我们将方程 $(1')$ 和方程 $(2')$ 相加：\n$$(t_2 - t_1) + (t_4 - t_3) = (d_1 + \\theta) + (d_2 - \\theta)$$\n$$(t_2 + t_4) - (t_1 + t_3) = d_1 + d_2$$\n往返延迟 $\\delta$ 是传输所花费的总时间，即总观测时长 $(t_4 - t_1)$ 减去服务器处理请求所花费的时间 $(t_3 - t_2)$。\n$$\\delta = d_1 + d_2 = (t_4 - t_1) - (t_3 - t_2)$$\n\n为了求出偏移量 $\\theta$，我们将方程 $(2')$ 从方程 $(1')$ 中减去：\n$$(t_2 - t_1) - (t_4 - t_3) = (d_1 + \\theta) - (d_2 - \\theta)$$\n$$(t_2 - t_1) - (t_4 - t_3) = 2\\theta + d_1 - d_2$$\n求解 $\\theta$ 得到真实偏移量：\n$$\\theta_{\\text{true}} = \\frac{1}{2} \\left[ (t_2 - t_1) + (t_3 - t_4) - (d_1 - d_2) \\right]$$\n由于 $d_1$ 和 $d_2$ 是未知的，我们无法精确确定 $\\theta_{\\text{true}}$。标准的NTP方法是通过做出网络路径对称的简化假设（即 $d_1 = d_2$）来创建偏移量的*估计值*，我们将其表示为 $\\theta$。这个假设使得项 $(d_1 - d_2)$ 等于零。\n$$\\theta \\equiv \\theta_{\\text{estimated}} = \\frac{1}{2} \\left[ (t_2 - t_1) + (t_3 - t_4) \\right]$$\n\n### 数值计算\n我们给定的时间戳为 $(t_1, t_2, t_3, t_4) = (0.2, 0.25, 0.4, 0.65)$ 秒。\n\n首先，我们计算估计的时钟偏移 $\\theta$：\n$$\\theta = \\frac{1}{2} \\left[ (0.25 - 0.2) + (0.4 - 0.65) \\right] = \\frac{1}{2} \\left[ 0.05 + (-0.25) \\right]$$\n$$\\theta = \\frac{1}{2} (-0.2) = -0.1 \\, \\text{s}$$\n$-0.1$ 秒的负偏移意味着服务器的时钟比客户端的时钟慢 $0.1$ 秒。\n\n接下来，我们计算往返网络延迟 $\\delta$：\n$$\\delta = (t_4 - t_1) - (t_3 - t_2)$$\n$$\\delta = (0.65 - 0.2) - (0.4 - 0.25) = 0.45 - 0.15$$\n$$\\delta = 0.3 \\, \\text{s}$$\n\n### 最坏情况误差分析\n偏移估计的误差 $\\varepsilon_{\\theta}$ 是估计值 $\\theta$ 与真实值 $\\theta_{\\text{true}}$ 之间的差值。\n$$\\varepsilon_{\\theta} = \\theta - \\theta_{\\text{true}} = \\frac{1}{2} \\left[ (t_2 - t_1) + (t_3 - t_4) \\right] - \\frac{1}{2} \\left[ (t_2 - t_1) + (t_3 - t_4) - (d_1 - d_2) \\right]$$\n$$\\varepsilon_{\\theta} = \\frac{1}{2} (d_1 - d_2)$$\n误差是路径不对称性的一半。问题陈述路径不对称性的大小为 $|d_1 - d_2| = 0.05$ 秒。因此，偏移估计的最坏情况绝对误差 $|\\varepsilon_{\\theta}|$ 为：\n$$|\\varepsilon_{\\theta}| = \\left| \\frac{1}{2} (d_1 - d_2) \\right| = \\frac{1}{2} |d_1 - d_2|$$\n$$|\\varepsilon_{\\theta}| = \\frac{1}{2} (0.05) = 0.025 \\, \\text{s}$$\n\n### 解释\n此计算的目的是将数字孪生的逻辑时间与物理设备的墙钟时间对齐。估计的偏移为 $\\theta = -0.1$ 秒。数字孪生将使用此值来校正其时钟，因此它对设备时间的估计将是 $C_{\\text{twin}}(T) - 0.1$。然而，误差分析揭示了一个根本性的限制。由于未知的网络路径不对称性，这种同步并不完美。$|\\varepsilon_{\\theta}| = 0.025$ 秒的最坏情况绝对误差为时间映射的准确性设定了一个界限。这意味着即使在校正之后，数字孪生对物理设备时间的逻辑时间表示也可能在任一方向上偏差高达 $25$ 毫秒。真实的偏移量位于区间 $[\\theta - |\\varepsilon_{\\theta}|, \\theta + |\\varepsilon_{\\theta}|] = [-0.1 - 0.025, -0.1 + 0.025] = [-0.125, -0.075]$ 秒内。这个误差边界是数字孪生系统的一个关键规范。孪生系统内任何要求时间精度高于 $25$ 毫秒的仿真、控制逻辑或数据分析都不能保证其有效性，因为孪生系统对设备状态的看法可能在时间上是倾斜的。在设计控制算法和解释仿真结果时，必须考虑这种不确定性，以确保信息物理系统的安全性和稳定性。\n\n将结果四舍五入到四位有效数字：\n$\\theta = -0.1000$ s\n$\\delta = 0.3000$ s\n$|\\varepsilon_{\\theta}| = 0.02500$ s",
            "answer": "$$\\boxed{\\begin{pmatrix} -0.1000  0.3000  0.02500 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在许多分布式系统中，事件发生的绝对物理时间远不如其与其他事件的因果关系重要。本练习通过向量时钟引入逻辑时间的概念，这是一种无需依赖同步物理时钟就能捕捉“先于发生”（happened-before）关系的强大机制。通过手动追踪跨多个进程的向量时钟更新，你将学会区分因果关联事件和并发事件，这是设计和调试正确的分布式算法及数据复制协议的一项关键技能。",
            "id": "4207954",
            "problem": "一个信息物理系统 (CPS) 维护一个分布式数字孪生，该孪生在三个进程 $P_1$、$P_2$ 和 $P_3$ 之间进行复制。该系统使用向量时钟作为逻辑时间，来推断更新之间的因果关系。假设三个进程的向量时钟遵循标准语义：每个进程维护一个长度为 $3$ 的向量，初始值为 $(0,0,0)$；每当发生本地事件（包括本地更新和发送事件），进程会将其自身分量加一；发送事件会将当前向量时钟附加到消息中；接收事件会先将其本地向量替换为本地向量与消息附加向量的逐分量最大值，然后再将其自身分量加一。\n\n以下事件日志列出了每个进程的事件序列。本地更新表示为 $u_k$，发送表示为 $m_k$，接收则引用相应的 $m_k$。\n\n进程 $P_1$：\n- 事件 $e_1$：本地更新 $u_1$。\n- 事件 $e_2$：向 $P_2$ 发送消息 $m_1$。\n- 事件 $e_3$：本地更新 $u_2$。\n- 事件 $e_4$：向 $P_3$ 发送消息 $m_3$。\n\n进程 $P_2$：\n- 事件 $f_1$：本地更新 $u_3$。\n- 事件 $f_2$：从 $P_1$ 接收 $m_1$。\n- 事件 $f_3$：向 $P_3$ 发送消息 $m_2$。\n- 事件 $f_4$：本地更新 $u_4$。\n\n进程 $P_3$：\n- 事件 $g_1$：从 $P_2$ 接收 $m_2$。\n- 事件 $g_2$：本地更新 $u_5$。\n- 事件 $g_3$：从 $P_1$ 接收 $m_3$。\n- 事件 $g_4$：本地更新 $u_6$。\n\n任务：\n1. 使用给定的事件日志和标准的向量时钟语义，计算每次更新 $u_1, u_2, u_3, u_4, u_5, u_6$ 的向量时间戳。\n2. 使用由进程内顺序和消息因果关系导出的“先于”关系（happened-before relation），等价地，使用向量时间戳上的逐分量偏序，确定哪些更新对是因果有序的，哪些是并发的。\n3. 确定一个保留因果关系的确定性合并顺序。为了在并发更新之间确定唯一的顺序，请按向量时间戳在 $\\mathbb{N}^3$ 上的字典序对更新进行排序（首先比较第一个分量，如果第一个分量相同则比较第二个，如果第二个分量也相同则比较第三个）。如果比较完所有三个分量后仍然存在平局（这只可能在两个不同的更新意外共享相同向量时发生），则按进程标识符的递增顺序 ($P_1 \\prec P_2 \\prec P_3$) 打破平局，然后再按该进程内更新的本地序列号打破平局。\n\n答案规范：\n- 将你的最终答案表示为所选合并顺序下索引 $\\{1,2,3,4,5,6\\}$ 的一个排列，使用 LaTeX 的 `pmatrix` 环境格式化为行矩阵。\n- 无需单位。",
            "solution": "用户希望我解决一个关于分布式系统中向量时钟的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **系统**：一个有 $3$ 个进程的信息物理系统：$P_1$、$P_2$、$P_3$。\n*   **逻辑时间**：使用向量时钟。进程 $P_i$ 的向量为 $V_i = (v_{i1}, v_{i2}, v_{i3})$。初始状态：$V_1=V_2=V_3=(0,0,0)$。\n*   **向量时钟规则**：\n    1.  每当发生本地事件（例如，本地更新 $u_k$，发送 $m_k$），进程会将其向量时钟中自身的分量加一。\n    2.  发送事件会将当前向量时钟附加到消息中。\n    3.  接收事件会先通过取其自身向量和消息向量的逐分量最大值来更新本地向量，然后再将其自身分量加一。\n*   **事件日志**：\n    *   **进程 $P_1$**：\n        1.  $e_1$：本地更新 $u_1$。\n        2.  $e_2$：向 $P_2$ 发送消息 $m_1$。\n        3.  $e_3$：本地更新 $u_2$。\n        4.  $e_4$：向 $P_3$ 发送消息 $m_3$。\n    *   **进程 $P_2$**：\n        1.  $f_1$：本地更新 $u_3$。\n        2.  $f_2$：从 $P_1$ 接收 $m_1$。\n        3.  $f_3$：向 $P_3$ 发送消息 $m_2$。\n        4.  $f_4$：本地更新 $u_4$。\n    *   **进程 $P_3$**：\n        1.  $g_1$：从 $P_2$ 接收 $m_2$。\n        2.  $g_2$：本地更新 $u_5$。\n        3.  $g_3$：从 $P_1$ 接收 $m_3$。\n        4.  $g_4$：本地更新 $u_6$。\n*   **任务**：\n    1.  计算每次更新 $u_1, u_2, u_3, u_4, u_5, u_6$ 的向量时间戳。\n    2.  基于“先于”关系确定更新之间的因果关系对和并发对。\n    3.  通过按向量时间戳的字典序对更新进行排序来确定一个确定性的合并顺序。平局（如有）通过进程 ID ($P_1 \\prec P_2 \\prec P_3$) 和本地更新序列号来打破。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学依据**：该问题基于 Lamport 提出的著名向量时钟算法，这是分布式系统中的一个基本概念。其前提和规则在科学上是合理的。\n*   **适定性**：事件日志是完整的，时钟更新规则是明确无歧义的，排序的平局打破规则确保了唯一解。该问题是适定的。\n*   **客观性**：该问题以精确、正式的语言陈述，没有主观性或个人观点。\n*   **完整性**：所有必要信息（初始状态、事件序列、更新规则）都已提供。该问题是自包含的。\n*   **现实性**：该场景是一个用于教学和推理分布式系统的标准简化模型。在此学术背景下是现实的。\n\n**步骤 3：结论与行动**\n\n该问题是有效的。它在科学上是合理的、适定的、客观的和自包含的。我将继续提供一个完整的解决方案。\n\n### 解题过程\n\n解题过程通过追踪三个进程 $P_1$、$P_2$ 和 $P_3$ 中每一个向量时钟的演变来进行。设 $V_1$、$V_2$ 和 $V_3$ 分别表示各自进程的向量时钟。初始状态为 $V_1 = V_2 = V_3 = (0,0,0)$。一个事件的时间戳是该事件所需的一次或多次增量操作后，进程向量时钟的值。对于一个更新事件，这个值就是它的向量时间戳，记为 $C(u_k)$。\n\n**任务 1：计算向量时间戳**\n\n我们根据提供的日志追踪每个进程的事件。\n\n**进程 $P_1$**：\n初始状态：$V_1 = (0,0,0)$。\n1.  **事件 $e_1$ (本地更新 $u_1$)**：$P_1$ 将其自身时钟分量加一。\n    $V_1 \\rightarrow (0+1, 0, 0) = (1,0,0)$。\n    此更新的时间戳为 $C(u_1) = (1,0,0)$。\n2.  **事件 $e_2$ (向 $P_2$ 发送消息 $m_1$)**：这是一个发送事件，因此 $P_1$ 将其时钟分量加一。\n    $V_1 \\rightarrow (1+1, 0, 0) = (2,0,0)$。\n    消息 $m_1$ 以时间戳 $V(m_1)=(2,0,0)$ 发送。\n3.  **事件 $e_3$ (本地更新 $u_2$)**：$P_1$ 将其自身时钟分量加一。\n    $V_1 \\rightarrow (2+1, 0, 0) = (3,0,0)$。\n    此更新的时间戳为 $C(u_2) = (3,0,0)$。\n4.  **事件 $e_4$ (向 $P_3$ 发送消息 $m_3$)**：这是一个发送事件，因此 $P_1$ 将其时钟分量加一。\n    $V_1 \\rightarrow (3+1, 0, 0) = (4,0,0)$。\n    消息 $m_3$ 以时间戳 $V(m_3)=(4,0,0)$ 发送。\n\n**进程 $P_2$**：\n初始状态：$V_2 = (0,0,0)$。\n1.  **事件 $f_1$ (本地更新 $u_3$)**：$P_2$ 将其自身时钟分量加一。\n    $V_2 \\rightarrow (0, 0+1, 0) = (0,1,0)$。\n    此更新的时间戳为 $C(u_3) = (0,1,0)$。\n2.  **事件 $f_2$ (从 $P_1$ 接收 $m_1$)**：$P_2$ 接收到带有时间戳 $V(m_1)=(2,0,0)$ 的消息 $m_1$。\n    - 首先，合并：$V_2 \\leftarrow \\max(V_2, V(m_1)) = \\max((0,1,0), (2,0,0)) = (2,1,0)$。\n    - 其次，加一：$V_2 \\rightarrow (2, 1+1, 0) = (2,2,0)$。\n3.  **事件 $f_3$ (向 $P_3$ 发送消息 $m_2$)**：这是一个发送事件，因此 $P_2$ 将其时钟分量加一。\n    $V_2 \\rightarrow (2, 2+1, 0) = (2,3,0)$。\n    消息 $m_2$ 以时间戳 $V(m_2)=(2,3,0)$ 发送。\n4.  **事件 $f_4$ (本地更新 $u_4$)**：$P_2$ 将其自身时钟分量加一。\n    $V_2 \\rightarrow (2, 3+1, 0) = (2,4,0)$。\n    此更新的时间戳为 $C(u_4) = (2,4,0)$。\n\n**进程 $P_3$**：\n初始状态：$V_3 = (0,0,0)$。\n1.  **事件 $g_1$ (从 $P_2$ 接收 $m_2$)**：$P_3$ 接收到带有时间戳 $V(m_2)=(2,3,0)$ 的消息 $m_2$。\n    - 首先，合并：$V_3 \\leftarrow \\max(V_3, V(m_2)) = \\max((0,0,0), (2,3,0)) = (2,3,0)$。\n    - 其次，加一：$V_3 \\rightarrow (2, 3, 0+1) = (2,3,1)$。\n2.  **事件 $g_2$ (本地更新 $u_5$)**：$P_3$ 将其自身时钟分量加一。\n    $V_3 \\rightarrow (2, 3, 1+1) = (2,3,2)$。\n    此更新的时间戳为 $C(u_5) = (2,3,2)$。\n3.  **事件 $g_3$ (从 $P_1$ 接收 $m_3$)**：$P_3$ 接收到带有时间戳 $V(m_3)=(4,0,0)$ 的消息 $m_3$。\n    - 首先，合并：$V_3 \\leftarrow \\max(V_3, V(m_3)) = \\max((2,3,2), (4,0,0)) = (4,3,2)$。\n    - 其次，加一：$V_3 \\rightarrow (4, 3, 2+1) = (4,3,3)$。\n4.  **事件 $g_4$ (本地更新 $u_6$)**：$P_3$ 将其自身时钟分量加一。\n    $V_3 \\rightarrow (4, 3, 3+1) = (4,3,4)$。\n    此更新的时间戳为 $C(u_6) = (4,3,4)$。\n\n更新的向量时间戳如下：\n- $C(u_1) = (1,0,0)$\n- $C(u_2) = (3,0,0)$\n- $C(u_3) = (0,1,0)$\n- $C(u_4) = (2,4,0)$\n- $C(u_5) = (2,3,2)$\n- $C(u_6) = (4,3,4)$\n\n**任务 2：因果关系与并发性**\n\n“先于”关系（happened-before relation）($a \\rightarrow b$) 成立当且仅当 $a$ 的向量时钟严格小于 $b$ 的向量时钟 ($C(a)  C(b)$)。如果既不是 $C(a) \\le C(b)$ 也不是 $C(b) \\le C(a)$，则两个事件 $a$ 和 $b$ 是并发的 ($a \\parallel b$)。例如，$u_1 \\rightarrow u_2$ 因为 $C(u_1)=(1,0,0)  C(u_2)=(3,0,0)$。同样，$u_3 \\rightarrow u_5$ 因为 $C(u_3)=(0,1,0)  C(u_5)=(2,3,2)$。相比之下，$u_2$ 和 $u_5$ 是并发的 ($u_2 \\parallel u_5$)，因为 $C(u_2)=(3,0,0)$ 和 $C(u_5)=(2,3,2)$ 是不可比较的。\n\n**任务 3：确定性合并顺序**\n\n为了找到合并顺序，我们根据更新的向量时间戳使用字典序比较进行排序。顺序通过从左到右比较向量分量来确定。\n\n更新及其时间戳的列表如下：\n1.  $u_1$: $(1,0,0)$\n2.  $u_2$: $(3,0,0)$\n3.  $u_3$: $(0,1,0)$\n4.  $u_4$: $(2,4,0)$\n5.  $u_5$: $(2,3,2)$\n6.  $u_6$: $(4,3,4)$\n\n按字典序排序如下：\n1.  $(0,1,0) \\implies u_3$\n2.  $(1,0,0) \\implies u_1$\n3.  $(2,3,2) \\implies u_5$ (因为 $3  4$，所以 $(2,3,2)$ 在 $(2,4,0)$ 之前)\n4.  $(2,4,0) \\implies u_4$\n5.  $(3,0,0) \\implies u_2$\n6.  $(4,3,4) \\implies u_6$\n\n所有时间戳都是唯一的，所以不需要使用平局打破规则。确定的合并顺序是 $u_3, u_1, u_5, u_4, u_2, u_6$。\n这个顺序保证是一个全序，且与偏序的因果关系一致（即，它是“先于”关系的一个拓扑排序）。\n\n问题要求答案是索引 $\\{1,2,3,4,5,6\\}$ 的一个排列。排序后的更新序列对应的索引序列是：$3, 1, 5, 4, 2, 6$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  1  5  4  2  6\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "现实世界中的信息物理系统并非完美无缺；节点可能会发生故障或提供恶意数据，从而威胁到全系统时间的完整性。这项高级练习将挑战你超越简单的估计器，运用稳健统计学的原理来设计一个容错的时钟同步算法。你将探索样本中位数如何作为一种弹性估计器，抵御有限数量的恶意节点的干扰。通过推导该估计器并在污染模型下分析其最坏情况偏差，你将洞悉构建弹性分布式系统的理论基础，这些系统即使在出现故障时也能保持一致性。",
            "id": "4207986",
            "problem": "考虑一个信息物理系统，其中一个数字孪生聚合来自 $n$ 个对等节点的时钟偏移报告，以使其逻辑时钟与一个参考时钟对齐。设数字孪生与参考时钟之间的真实偏移为 $d \\in \\mathbb{R}$。每个诚实对等节点 $i$ 报告一个测量偏移 $x_i = d + z_i$，其中噪声 $z_i$ 是独立同分布的，其累积分布函数 $F_Z$ 是连续且严格递增的，并且关于 $0$ 对称，即对于所有 $u \\in \\mathbb{R}$ 都有 $F_Z(-u) = 1 - F_Z(u)$。最多有 $f$ 个对等节点可能是故障的。一个故障节点可以恶意地选择一个在物理约束区间 $[d - A, d + A]$ 内的报告值 $y$，其中 $A  0$ 是已知的，它源于有界的延迟和有界的硬件时钟摆率。\n\n要求您仅使用报告的偏移量 $\\{r_i\\}_{i=1}^{n}$ 来设计一个用于 $d$ 的容错估计器，其中 $r_i$ 要么是 $x_i$ (诚实的)，要么是恶意的 $y$ (故障的)。从逻辑时间、时钟偏移参数的基本定义，以及通过最小化凸损失来估计 $d$ 的原理出发，推导出使用观测数据 $\\{r_i\\}_{i=1}^{n}$ 最小化与候选 $d$ 的绝对偏差之和的估计器，并证明其在 $f  n/2$ 时的容错性。然后，在大样本极限下，通过污染分布 $H(x) = (1 - \\varepsilon) F_{X}(x) + \\varepsilon G(x)$ 对数据生成过程进行建模，其中 $F_{X}(x) = F_Z(x - d)$ 是诚实报告的分布，$G$ 是支撑集在 $[d - A, d + A]$ 上的任意恶意分布，$\\varepsilon = f/n \\in (0, 1/2)$ 是污染比例。\n\n在此污染模型和对 $G$ 的约束下，计算您的估计器的渐近上偏的上确界 (supremum) 的闭式表达式。该上确界定义为，对于所有支撑集在 $[d - A, d + A]$ 上的 $G$，$\\lim_{n \\to \\infty} \\hat{d}_n - d$ 的最大可能值，其中 $\\hat{d}_n$ 表示应用于 $n$ 个样本的估计器。最终答案需表示为关于 $A$、$F_Z^{-1}$ ($F_Z$ 的分位数函数)、$f$ 和 $n$ 的单个解析表达式。不需要四舍五入。最终答案必须是无单位的单个表达式。",
            "solution": "该问题要求推导时钟偏移 $d$ 的容錯估计器，对其进行证明，并在污染模型下计算其最大渐近上偏。\n\n首先，我们验证问题陈述的有效性。\n\n**步骤 1：提取已知条件**\n- 真实偏移: $d \\in \\mathbb{R}$。\n- 对等节点数量: $n$。\n- 故障对等节点数量: 最多 $f$ 个。\n- 诚实节点报告: $x_i = d + z_i$，其中 $z_i$ 是独立同分布的噪声样本。\n- 噪声累积分布函数(CDF): $F_Z$，连续、严格递增且对称 ($F_Z(-u) = 1 - F_Z(u)$)。\n- 故障节点报告: $y \\in [d - A, d + A]$，其中 $A  0$。\n- 观测数据: $\\{r_i\\}_{i=1}^{n}$。\n- 估计器任务: 最小化关于候选偏移 $d'$ 的绝对偏差之和 $\\sum_{i=1}^{n} |r_i - d'|$。\n- 容错条件: $f  n/2$。\n- 污染模型: $H(x) = (1 - \\varepsilon) F_{X}(x) + \\varepsilon G(x)$。\n- 诚实报告分布: $F_{X}(x) = F_Z(x - d)$。\n- 恶意分布 $G(x)$ 的支撑集在 $[d - A, d + A]$ 上。\n- 污染比例: $\\varepsilon = f/n \\in (0, 1/2)$。\n- 最终任务: 计算 $\\sup_{G} (\\lim_{n \\to \\infty} \\hat{d}_n - d)$，其中 $\\hat{d}_n$ 是该估计器。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据、良定且客观。它描述了容错分布式系统和稳健统计学中的一个标准场景。\n- **科学依据**：诚实节点报告真实值加上对称噪声，而故障节点在有界范围内报告任意值，这一模型在容错算法（例如，拜占庭容错）和稳健统计学（Huber 污染模型）的研究中是一个成熟且现实的模型。使用中位数作为稳健估计器是该领域的基石之一。\n- **良定性**：最小化绝对偏差之和的问题是一个具有良定义解（样本中位数）的凸优化问题。渐近分析依赖于 M-估计器的标准收敛结果。最大偏差的计算是在指定分布族上的一个良定义极值问题。\n- **完备性与一致性**：问题提供了所有必要的信息。$F_Z$ 的性质（连续、严格递增）确保了其逆函数 $F_Z^{-1}$ 是良定义的。$F_Z$ 的对称性意味着噪声以 0 为中心。约束条件 $f  n/2$ (或 $\\varepsilon  1/2$) 是使得稳健估计成为可能的关键条件。对恶意分布 $G$ 的约束也已明确指定。\n\n**步骤 3：结论与行动**\n问题是**有效的**。我们开始进行解答。\n\n**估计器的推导及其容错性**\n\n估计器 $\\hat{d}_n$ 被定义为最小化与观测数据 $\\{r_i\\}_{i=1}^{n}$ 的绝对偏差之和的值。设损失函数为 $L(\\theta) = \\sum_{i=1}^{n} |r_i - \\theta|$。我们寻求 $\\hat{d}_n = \\arg\\min_{\\theta \\in \\mathbb{R}} L(\\theta)$。\n函数 $L(\\theta)$ 是凸函数，其次梯度由 $\\partial L(\\theta) = \\sum_{i=1}^{n} \\text{sgn}(\\theta - r_i)$ 给出，其中当 $x  0$ 时 $\\text{sgn}(x)$ 为 $-1$，当 $x=0$ 时为 $0$，当 $x>0$ 时为 $1$。当 $0 \\in \\partial L(\\theta)$ 时，函数达到最小值。这种情况发生在大于 $\\theta$ 的数据点数量等于小于 $\\theta$ 的数据点数量时。根据定义，这正是数据 $\\{r_i\\}_{i=1}^{n}$ 的样本中位数。\n因此，该估计器是样本中位数：$\\hat{d}_n = \\text{median}\\{r_1, r_2, \\dots, r_n\\}$。\n\n样本中位数的容错性由其崩溃点来表征，崩溃点是指能将估计值推向任意大或任意小的值的最小恶意数据比例。攻击者控制着 $f$ 个报告。为了尽可能地移动中位数，他们会将这 $f$ 个报告设置在极值处。假设他们想最大化中位数，他们会用非常大的数值替换掉 $f$ 个原始报告。在排序后的报告列表中，这 $f$ 个恶意报告将占据最高的 $f$ 个位置。中位数是位于秩约为 $n/2$ 的元素。只要恶意报告的数量 $f$ 小于排在中位数之上的报告数量，中位数就将由一个誠實報告决定，并保持有界。\n\"捕获\"中位数所需的报告数量是 $\\lceil n/2 \\rceil$。条件 $f  n/2$ 等价于 $f \\le \\lfloor (n-1)/2 \\rfloor$。这确保了即使所有 $f$ 个故障节点串通，它们也无法控制中位数的值，该值将是来自诚实节点的 $n-f$ 个报告之一。这使得中位数的崩溃点约为 $50\\%$，使其成为一个高度稳健的估计器。\n\n**渐近偏差计算**\n\n当样本数量 $n \\to \\infty$ 时，样本中位数 $\\hat{d}_n$ 依概率收敛到潜在数据生成分布 $H(x)$ 的中位数。设估计器的这个渐近值为 $d^* = \\lim_{n \\to \\infty} \\hat{d}_n$。具有累积分布函数 $H$ 的分布的中位数 $d^*$由条件 $H(d^*) = 1/2$ 定义。\n代入污染模型，我们有：\n$$ (1 - \\varepsilon) F_{X}(d^*) + \\varepsilon G(d^*) = \\frac{1}{2} $$\n代入 $F_X(x) = F_Z(x-d)$ 和 $\\varepsilon = f/n$，关于 $d^*$ 的方程变为：\n$$ \\left(1 - \\frac{f}{n}\\right) F_Z(d^* - d) + \\frac{f}{n} G(d^*) = \\frac{1}{2} $$\n我们想要找到渐近上偏的上确界，即 $\\sup_{G} (d^* - d)$。设偏差为 $B = d^* - d$。偏差的方程是：\n$$ \\left(1 - \\frac{f}{n}\\right) F_Z(B) = \\frac{1}{2} - \\frac{f}{n} G(d+B) $$\n为了最大化 $B$，由于 $F_Z$ 是严格递增的，我们需要最大化方程的右边。这要求最小化 $G(d+B)$。攻击者选择支撑集在 $[d - A, d + A]$ 上的分布 $G$。\n为了使 $G(x)$ 对任何给定的 $x$ 都尽可能小，攻击者必须将 $G$ 的概率质量置于可能的最大值处。攻击者最大化上偏的最优策略是将其所有故障报告的概率质量集中在允许区间的上边界，即 $d+A$。这对应于一个在 $d+A$ 处的点质量分布 $G$。这种最坏情况分布的累积分布函数，我们称之为 $G_{worst}$，是：\n$$ G_{worst}(x) = \\begin{cases} 0  \\text{ if } x  d+A \\\\ 1  \\text{ if } x \\ge d+A \\end{cases} $$\n在这种恶意选择下，污染分布 $H(x) = (1-\\varepsilon)F_Z(x-d) + \\varepsilon G_{worst}(x)$ 的中位数 $d^*$ 给出了最大上偏。我们来求这个 $d^*$。\n总累积分布函数 $H(x)$ 在 $x = d+A$ 处发生跳跃。我们计算 $H(x)$ 在该点之前和在该点处的值：\n$H((d+A)^-) = (1-\\varepsilon)F_Z((d+A)-d) + \\varepsilon \\cdot 0 = (1-\\varepsilon)F_Z(A)$。\n$H(d+A) = (1-\\varepsilon)F_Z(A) + \\varepsilon \\cdot 1$。\n\n中位数 $d^*$ 是满足 $H(d^*) = 1/2$ 的值。我们有两种情况：\n\n情况 1：中位数在边界处饱和，$d^* = d+A$。如果累积分布函数在该点的值从 $\\le 1/2$ 跳跃到 $\\ge 1/2$，就会发生这种情况。即 $H((d+A)^-) \\le 1/2 \\le H(d+A)$。条件 $H((d+A)^-) \\le 1/2$ 意味着 $(1-\\varepsilon)F_Z(A) \\le 1/2$，也就是 $F_Z(A) \\le \\frac{1}{2(1-\\varepsilon)}$。由于 $F_Z$ 是严格递增的，这等价于 $A \\le F_Z^{-1}\\left(\\frac{1}{2(1-\\varepsilon)}\\right)$。在这种情况下，最大可能偏差为 $d^* - d = A$。\n\n情况 2：中位数未饱和，$d^*  d+A$。如果 $H((d+A)^-) > 1/2$，就会发生这种情况，这意味着 $(1-\\varepsilon)F_Z(A) > 1/2$，或等价地 $A > F_Z^{-1}\\left(\\frac{1}{2(1-\\varepsilon)}\\right)$。对于任何 $x  d+A$，我们有 $G_{worst}(x)=0$。中位数方程 $H(d^*)=1/2$ 变为：\n$$ (1-\\varepsilon)F_Z(d^*-d) + \\varepsilon \\cdot 0 = \\frac{1}{2} $$\n$$ F_Z(d^*-d) = \\frac{1}{2(1-\\varepsilon)} $$\n偏差则为 $d^*-d = F_Z^{-1}\\left(\\frac{1}{2(1-\\varepsilon)}\\right)$。这个解与情况条件 $d^*  d+A$ 一致，即 $d^*-d  A$。\n\n综合这两种情况，上偏的上确界是两个可能值中较小的一个。攻击者将中位数向上推。如果在达到统计极限之前达到了物理边界 $A$，则偏差为 $A$。否则，偏差受到诚实分布“拉回”中位数能力的限制。\n因此，最大上偏由下式给出：\n$$ \\sup_{G} (\\lim_{n \\to \\infty} \\hat{d}_n - d) = \\min\\left(A, F_Z^{-1}\\left(\\frac{1}{2(1-\\varepsilon)}\\right)\\right) $$\n最后，我们代入 $\\varepsilon = f/n$：\n$$ \\frac{1}{2(1-\\varepsilon)} = \\frac{1}{2(1-f/n)} = \\frac{1}{2\\left(\\frac{n-f}{n}\\right)} = \\frac{n}{2(n-f)} $$\n渐近上偏的上确界是：\n$$ \\min\\left(A, F_Z^{-1}\\left(\\frac{n}{2(n-f)}\\right)\\right) $$\n这个表达式是用给定的参数 $A$, $F_Z^{-1}$, $f$ 和 $n$ 来表示的。",
            "answer": "$$\n\\boxed{\\min\\left(A, F_Z^{-1}\\left(\\frac{n}{2(n-f)}\\right)\\right)}\n$$"
        }
    ]
}