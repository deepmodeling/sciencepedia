{
    "hands_on_practices": [
        {
            "introduction": "The cornerstone of highly predictable cyber-physical systems is the time-triggered (TT) architecture, prized for its verifiability and temporal determinism. This exercise provides fundamental practice in designing such a system by constructing a static schedule table for a set of periodic tasks. By calculating the hyperperiod and methodically allocating non-preemptive execution slots, you will develop the core skill of creating a deterministic schedule where all timing constraints are guaranteed to be met, a crucial requirement for safety-critical digital twins and controllers. ",
            "id": "4251650",
            "problem": "A Cyber-Physical System (CPS) with an embedded Digital Twin (DT) executes a statically time-triggered schedule on a single-core processor. The time base is a synchronous global clock with tick $\\Delta t = 0.5\\,\\text{ms}$, and all tasks are released synchronously at time $t=0$. The DT’s computational pipeline consists of three periodic tasks $\\tau_1$, $\\tau_2$, and $\\tau_3$ with harmonic periods. Each task $\\tau_k$ is characterized by period $T_k$, worst-case execution time $C_k$, release offset $O_k$, and implicit deadline $D_k = T_k$. The parameters are:\n- $\\tau_1$: $T_1 = 5\\,\\text{ms}$, $C_1 = 1\\,\\text{ms}$, $O_1 = 0\\,\\text{ms}$.\n- $\\tau_2$: $T_2 = 10\\,\\text{ms}$, $C_2 = 1.5\\,\\text{ms}$, $O_2 = 0\\,\\text{ms}$.\n- $\\tau_3$: $T_3 = 20\\,\\text{ms}$, $C_3 = 2\\,\\text{ms}$, $O_3 = 0\\,\\text{ms}$.\n\nAssume non-preemptive execution, a single processor, and that every schedule slot start and end aligns to the clock tick $\\Delta t$. All jobs must start no earlier than their release time and complete no later than their implicit deadline. Over one hyperperiod, construct a deterministic time-triggered schedule table using the following policy: at each release time, schedule all newly released ready jobs in order of strictly decreasing period $T_k$ (with ties broken by increasing task index), assigning each job the earliest start time that does not overlap any already scheduled slots and respects non-preemption. Jobs cannot be moved earlier than their release time.\n\nStarting from first principles of periodic task systems and well-tested definitions of harmonicity and hyperperiod, determine:\n1. The hyperperiod $H$.\n2. The ordered slot allocation over $[0,H)$ as triplets $(i,s,e)$ where $i \\in \\{1,2,3\\}$ is the task index and $s$ and $e$ are the slot start and end times in $\\mathrm{ms}$.\n3. The total slack time $S$ within $[0,H)$.\n\nExpress all times in $\\text{ms}$. Provide the final answer as a single row matrix containing, in order: $H$, then the sequence of all $(i,s,e)$ triplets sorted by increasing $s$, and finally $S$. No rounding is required. The matrix must contain numbers only; do not include units inside the matrix.",
            "solution": "The user-provided problem is a well-defined real-time scheduling problem. It is scientifically grounded in the principles of time-triggered systems, is self-contained with all necessary parameters, and is free of contradictions or ambiguities. The problem is therefore deemed valid and a solution can be constructed.\n\nThe solution is derived in three parts as requested: determining the hyperperiod, constructing the schedule, and calculating the total slack time.\n\n**Part 1: Hyperperiod $H$**\n\nThe hyperperiod $H$ of a set of periodic tasks is the least common multiple (LCM) of their periods. It represents the time interval after which the pattern of job releases repeats. The tasks are $\\tau_1$, $\\tau_2$, and $\\tau_3$ with periods $T_1 = 5\\,\\text{ms}$, $T_2 = 10\\,\\text{ms}$, and $T_3 = 20\\,\\text{ms}$, respectively.\n\nThe problem states that the periods are harmonic. This means that for any two tasks $\\tau_i$ and $\\tau_j$, if $T_i < T_j$, then $T_j$ is an integer multiple of $T_i$. We can verify this: $T_2 = 2 \\times T_1$ and $T_3 = 2 \\times T_2$. For a harmonic set of periods, the LCM is simply the largest period.\n\nTherefore, the hyperperiod $H$ is:\n$$H = \\mathrm{lcm}(T_1, T_2, T_3) = \\mathrm{lcm}(5, 10, 20) = 20\\,\\text{ms}$$\n\nThe schedule will be constructed over the time interval $[0, H)$, which is $[0, 20)$.\n\n**Part 2: Time-Triggered Schedule Construction**\n\nThe schedule is constructed by considering events at each distinct release time within the hyperperiod. All tasks have an offset $O_k=0$, so they are released synchronously. The release times for each task $\\tau_k$ are $n \\times T_k$ for non-negative integers $n$ such that $n \\times T_k < H$.\n- $\\tau_1$ ($T_1=5$): releases at $t=0, 5, 10, 15$.\n- $\\tau_2$ ($T_2=10$): releases at $t=0, 10$.\n- $\\tau_3$ ($T_3=20$): releases at $t=0$.\n\nThe distinct release times are $t=0, 5, 10, 15$. We build the schedule chronologically. Let the schedule be a set of occupied time intervals.\n\n**Time $t=0\\,\\text{ms}$:**\nJobs from all three tasks ($\\tau_1, \\tau_2, \\tau_3$) are released. Let's denote the $j$-th job of task $\\tau_i$ as $\\tau_{i,j}$. The released jobs are $\\tau_{1,1}$, $\\tau_{2,1}$, and $\\tau_{3,1}$.\nThe scheduling policy requires ordering them by strictly decreasing period $T_k$.\nThe order is: $\\tau_{3,1}$ ($T_3=20$), then $\\tau_{2,1}$ ($T_2=10$), then $\\tau_{1,1}$ ($T_1=5$).\n\n1.  **Schedule $\\tau_{3,1}$ ($C_3 = 2\\,\\text{ms}$):**\n    The earliest available start time $s \\ge 0$ is $s=0$. The slot is $[0, 2)$.\n    - Allocation: $(i=3, s=0, e=2)$.\n    - Deadline for $\\tau_{3,1}$ is $D_3=20$. Completion at $t=2 \\le 20$. Met.\n\n2.  **Schedule $\\tau_{2,1}$ ($C_2 = 1.5\\,\\text{ms}$):**\n    The earliest available start time $s \\ge 0$ not overlapping with $[0, 2)$ is $s=2$. The slot is $[2, 3.5)$.\n    - Allocation: $(i=2, s=2, e=3.5)$.\n    - Deadline for $\\tau_{2,1}$ is $D_2=10$. Completion at $t=3.5 \\le 10$. Met.\n\n3.  **Schedule $\\tau_{1,1}$ ($C_1 = 1\\,\\text{ms}$):**\n    The earliest available start time $s \\ge 0$ not overlapping with $[0, 2)$ or $[2, 3.5)$ is $s=3.5$. The slot is $[3.5, 4.5)$.\n    - Allocation: $(i=1, s=3.5, e=4.5)$.\n    - Deadline for $\\tau_{1,1}$ is $D_1=5$. Completion at $t=4.5 \\le 5$. Met.\n\n**Time $t=5\\,\\text{ms}$:**\nA new job $\\tau_{1,2}$ is released. It is the only new job.\n1.  **Schedule $\\tau_{1,2}$ ($C_1 = 1\\,\\text{ms}$):**\n    The earliest available start time $s \\ge 5$ not overlapping existing slots is $s=5$. The slot is $[5, 6)$.\n    - Allocation: $(i=1, s=5, e=6)$.\n    - Deadline for $\\tau_{1,2}$ is $5+D_1=10$. Completion at $t=6 \\le 10$. Met.\n\n**Time $t=10\\,\\text{ms}$:**\nNew jobs $\\tau_{1,3}$ and $\\tau_{2,2}$ are released.\nThe scheduling order (decreasing period) is $\\tau_{2,2}$ ($T_2=10$), then $\\tau_{1,3}$ ($T_1=5$).\n\n1.  **Schedule $\\tau_{2,2}$ ($C_2 = 1.5\\,\\text{ms}$):**\n    The earliest available start time $s \\ge 10$ is $s=10$. The slot is $[10, 11.5)$.\n    - Allocation: $(i=2, s=10, e=11.5)$.\n    - Deadline for $\\tau_{2,2}$ is $10+D_2=20$. Completion at $t=11.5 \\le 20$. Met.\n\n2.  **Schedule $\\tau_{1,3}$ ($C_1 = 1\\,\\text{ms}$):**\n    The earliest available start time $s \\ge 10$ not overlapping $[10, 11.5)$ is $s=11.5$. The slot is $[11.5, 12.5)$.\n    - Allocation: $(i=1, s=11.5, e=12.5)$.\n    - Deadline for $\\tau_{1,3}$ is $10+D_1=15$. Completion at $t=12.5 \\le 15$. Met.\n\n**Time $t=15\\,\\text{ms}$:**\nA new job $\\tau_{1,4}$ is released. It is the only new job.\n1.  **Schedule $\\tau_{1,4}$ ($C_1 = 1\\,\\text{ms}$):**\n    The earliest available start time $s \\ge 15$ is $s=15$. The slot is $[15, 16)$.\n    - Allocation: $(i=1, s=15, e=16)$.\n    - Deadline for $\\tau_{1,4}$ is $15+D_1=20$. Completion at $t=16 \\le 20$. Met.\n\nThis completes the scheduling for the hyperperiod $[0, 20)$. All slot start ($s$) and end ($e$) times are multiples of the clock tick $\\Delta t = 0.5\\,\\text{ms}$, as required.\n\nThe final ordered slot allocation, as a list of triplets $(i,s,e)$ sorted by increasing start time $s$, is:\n1.  $(3, 0, 2)$\n2.  $(2, 2, 3.5)$\n3.  $(1, 3.5, 4.5)$\n4.  $(1, 5, 6)$\n5.  $(2, 10, 11.5)$\n6.  $(1, 11.5, 12.5)$\n7.  $(1, 15, 16)$\n\n**Part 3: Total Slack Time $S$**\n\nThe total slack time $S$ is the total time the processor is idle within one hyperperiod. This can be calculated by subtracting the total execution time of all jobs in the hyperperiod from the hyperperiod duration $H$.\n\nFirst, we determine the number of jobs, $N_k$, for each task $\\tau_k$ within $[0, H)$:\n- $N_1 = H / T_1 = 20 / 5 = 4$\n- $N_2 = H / T_2 = 20 / 10 = 2$\n- $N_3 = H / T_3 = 20 / 20 = 1$\n\nThe total execution time, $C_{\\text{total}}$, is the sum of the execution times of all these jobs:\n$$C_{\\text{total}} = N_1 C_1 + N_2 C_2 + N_3 C_3$$\n$$C_{\\text{total}} = (4 \\times 1\\,\\text{ms}) + (2 \\times 1.5\\,\\text{ms}) + (1 \\times 2\\,\\text{ms})$$\n$$C_{\\text{total}} = 4 + 3 + 2 = 9\\,\\text{ms}$$\nThis is also equivalent to the total utilization $U$ multiplied by the hyperperiod $H$:\n$$U = \\sum_{k=1}^3 \\frac{C_k}{T_k} = \\frac{1}{5} + \\frac{1.5}{10} + \\frac{2}{20} = 0.2 + 0.15 + 0.1 = 0.45$$\n$$C_{\\text{total}} = U \\times H = 0.45 \\times 20 = 9\\,\\text{ms}$$\n\nThe total slack time $S$ is:\n$$S = H - C_{\\text{total}} = 20\\,\\text{ms} - 9\\,\\text{ms} = 11\\,\\text{ms}$$\n\nThe final answer combines $H$, the sequence of schedule triplets $(i,s,e)$, and $S$ into a single structure.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n20 & 3 & 0 & 2 & 2 & 2 & 3.5 & 1 & 3.5 & 4.5 & 1 & 5 & 6 & 2 & 10 & 11.5 & 1 & 11.5 & 12.5 & 1 & 15 & 16 & 11\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "While event-triggered (ET) architectures offer superior responsiveness and resource efficiency compared to their time-triggered counterparts, their dynamic nature can lead to complex and potentially hazardous interactions. This problem explores the critical failure mode of unbounded priority inversion, where a high-priority task is unexpectedly delayed by a low-priority task through resource contention. By dissecting a specific execution trace, you will gain a deep understanding of this classic concurrency hazard and learn to apply standard synchronization protocols to guarantee system correctness. ",
            "id": "4251617",
            "problem": "An event-triggered (ET) controller in a cyber-physical system is implemented with fixed-priority preemptive scheduling and a shared mutex protecting resource $R$. There is no resource-access protocol in the kernel (no priority inheritance or ceiling). Three periodic tasks are deployed, and releases are driven by external events at the stated times. Task parameters are as follows (deadlines are relative to release times):\n- High-priority task $\\tau_H$: period $T_H = 10\\,\\text{ms}$, deadline $D_H = 10\\,\\text{ms}$, worst-case execution time $C_H = 2\\,\\text{ms}$, with a critical section on resource $R$ of length $\\ell_H = 1\\,\\text{ms}$ inside its execution.\n- Medium-priority task $\\tau_M$: period $T_M = 15\\,\\text{ms}$, deadline $D_M = 15\\,\\text{ms}$, worst-case execution time $C_M = 6\\,\\text{ms}$, no use of $R$.\n- Low-priority task $\\tau_L$: period $T_L = 50\\,\\text{ms}$, deadline $D_L = 50\\,\\text{ms}$, worst-case execution time $C_L = 8\\,\\text{ms}$, with a critical section on $R$ of length $\\ell_L = 3\\,\\text{ms}$ that begins $1\\,\\text{ms}$ after $\\tau_L$ starts executing.\n\nAssume the first releases are at $t=0$ for $\\tau_L$, and at $t=2$ for both $\\tau_H$ and $\\tau_M$. The ET scheduler dispatches the ready task with the highest static priority, and tasks are preemptive except when a task holds a mutex (preemptions are still allowed in this kernel when holding the mutex, since no protocol is implemented).\n\nA model of this system in a timed-automata model checker encodes deadlines as clocks and verifies the safety property $A\\,\\Box(\\text{no\\_deadline\\_miss})$, meaning “on all paths, always no deadline is missed.”\n\nUsing only foundational definitions from fixed-priority schedulability theory and mutual exclusion in real-time systems, select the option that both:\n- gives a concrete counterexample execution trace in which $\\tau_H$ misses its deadline due to priority inversion, and\n- proposes a minimal fix, and justifies—by appeal to worst-case response-time reasoning and to a re-run of the same model checking—that the fix eliminates the violation under the same workload.\n\nOptions:\nA. Counterexample trace: At $t=2$, $\\tau_M$ preempts $\\tau_L$ and blocks $\\tau_H$ directly because of priority inversion on resource $R$, causing $\\tau_H$ to miss its deadline at $t=12$. Fix: switch to a non-preemptive kernel so lower-priority tasks run to completion, which removes all inversions; model checking then shows no deadline miss.\n\nB. Counterexample trace: $\\tau_L$ starts at $t=0$; it acquires $R$ at $t=1$ and would hold it for $\\ell_L = 3\\,\\text{ms}$ if uninterrupted. At $t=2$, both $\\tau_H$ and $\\tau_M$ are released. $\\tau_H$ attempts to lock $R$ and blocks behind $\\tau_L$. The kernel does not raise $\\tau_L$’s priority, so $\\tau_M$ preempts $\\tau_L$ from $t=2$ to $t=8$ for its $C_M = 6\\,\\text{ms}$. $\\tau_L$ then resumes, completes its critical section at $t=11$, and releases $R$. $\\tau_H$ acquires $R$ and completes by $t=13$, missing its deadline at $t=12$. Fix: enable priority inheritance on $R$. Then the maximum blocking for $\\tau_H$ is $B_H = \\ell_L = 3\\,\\text{ms}$, and since there are no higher-priority tasks than $\\tau_H$, its worst-case response time satisfies $R_H = C_H + B_H = 2 + 3 = 5  D_H = 10$. Re-running the same model checking with priority inheritance yields $A\\,\\Box(\\text{no\\_deadline\\_miss})$ as true, with no counterexample.\n\nC. Counterexample trace: $\\tau_L$ never overlaps with $\\tau_H$’s use of $R$, yet $\\tau_H$ still misses its deadline because it busy-waits on $R$ from $t=2$ to $t=5$. Fix: adopt the priority ceiling protocol; the new worst-case response time is $R_H = C_H + \\ell_H = 2 + 1 = 3  10$, so deadlines hold, and model checking confirms the property.\n\nD. Counterexample trace: $\\tau_H$ can miss its deadline if it releases at $t=9$ while $\\tau_L$ is executing; the system is unstable because of jitter. Fix: convert the system to a time-triggered static table with slots of $2\\,\\text{ms}$ for $\\tau_H$, $6\\,\\text{ms}$ for $\\tau_M$, and $8\\,\\text{ms}$ for $\\tau_L$; the fixed table removes interference, so deadlines hold, and model checking remains unchanged.\n\nWhich option is correct?",
            "solution": "The user wants me to validate and solve a problem concerning real-time scheduling in a cyber-physical system.\n\n### Step 1: Extract Givens\n\n- **System:** Event-triggered (ET) controller with fixed-priority preemptive scheduling.\n- **Resource Management:** A shared mutex protects resource $R$. No resource-access protocol (e.g., priority inheritance, priority ceiling) is implemented in the kernel.\n- **Preemption Rule:** Preemption is allowed even when a task holds a mutex.\n- **Task Set:**\n    - **$\\tau_H$ (High Priority):** Period $T_H = 10\\,\\text{ms}$, Deadline $D_H = 10\\,\\text{ms}$, Worst-Case Execution Time (WCET) $C_H = 2\\,\\text{ms}$. It has a critical section on $R$ of length $\\ell_H = 1\\,\\text{ms}$.\n    - **$\\tau_M$ (Medium Priority):** Period $T_M = 15\\,\\text{ms}$, Deadline $D_M = 15\\,\\text{ms}$, WCET $C_M = 6\\,\\text{ms}$. It does not use resource $R$.\n    - **$\\tau_L$ (Low Priority):** Period $T_L = 50\\,\\text{ms}$, Deadline $D_L = 50\\,\\text{ms}$, WCET $C_L = 8\\,\\text{ms}$. It has a critical section on $R$ of length $\\ell_L = 3\\,\\text{ms}$, which begins $1\\,\\text{ms}$ after $\\tau_L$ starts executing.\n- **Initial Release Times:**\n    - $\\tau_L$ is released at $t=0$ ms.\n    - $\\tau_H$ and $\\tau_M$ are released at $t=2$ ms.\n- **Verification Context:** A timed-automata model checker is used to verify the property $A\\,\\Box(\\text{no\\_deadline\\_miss})$, which asserts that no deadlines are ever missed on any execution path.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is scientifically grounded in established real-time systems theory, covering concepts like fixed-priority preemptive scheduling, mutual exclusion, and priority inversion. The parameters are well-defined and numerically consistent. The scenario described—a high-priority task blocked by a low-priority task, which is then preempted by a medium-priority task—is the classic case used to illustrate unbounded priority inversion.\n\nThe problem asks for a counterexample trace where $\\tau_H$ misses its deadline. For this to be a well-posed question, such a miss must occur under the given conditions. Let us analyze the timeline. A deadline miss can be defined strictly (completion time $T_c \\geq T_{deadline}$) or non-strictly ($T_c  T_{deadline}$). We will assume the strict definition common in safety-critical systems, where completion at the deadline instant constitutes a miss. The absolute deadline for the first instance of $\\tau_H$ is $t = 2\\,\\text{ms} + 10\\,\\text{ms} = 12\\,\\text{ms}$.\n\nAn analysis of the execution trace (derived in the next section) shows that $\\tau_H$ completes at $t=12$ ms. Under the strict deadline definition, this is a miss. Thus, the premise of the question—that a deadline miss occurs—is valid. The problem is therefore scientifically sound, objective, well-posed, and contains sufficient information for a rigorous analysis.\n\n**Verdict:** The problem is **valid**.\n\n### Step 3: Derivation of the Counterexample and Solution\n\nWe will construct an execution trace (Gantt chart) to demonstrate the deadline miss for $\\tau_H$. The priorities are $\\tau_H  \\tau_M  \\tau_L$.\n\n1.  **Interval $[0\\,\\text{ms}, 1\\,\\text{ms})$:** At $t=0$, $\\tau_L$ is released. As it is the only ready task, it begins execution. It runs for $1\\,\\text{ms}$.\n2.  **At $t=1\\,\\text{ms}$:** Having executed for $1\\,\\text{ms}$, $\\tau_L$ enters its critical section and acquires the mutex for resource $R$.\n3.  **Interval $[1\\,\\text{ms}, 2\\,\\text{ms})$:** $\\tau_L$ continues executing, now inside its critical section. It runs for another $1\\,\\text{ms}$. At $t=2\\,\\text{ms}$, it has completed $1\\,\\text{ms}$ of its $3\\,\\text{ms}$ critical section.\n4.  **At $t=2\\,\\text{ms}$:** Tasks $\\tau_H$ and $\\tau_M$ are released. The scheduler evaluates the ready tasks.\n    - $\\tau_H$ has the highest priority. We assume the worst case where it immediately requires resource $R$. Since $R$ is held by $\\tau_L$, $\\tau_H$ blocks.\n    - The scheduler then considers the next highest priority ready task, which is $\\tau_M$. Because the kernel has no resource-access protocol, $\\tau_L$'s priority is not elevated. Thus, $\\tau_M$ preempts $\\tau_L$.\n5.  **Interval $[2\\,\\text{ms}, 8\\,\\text{ms})$:** $\\tau_M$ executes for its full WCET of $C_M = 6\\,\\text{ms}$. During this entire interval, $\\tau_H$ is blocked waiting for $\\tau_L$, and $\\tau_L$ is preempted by $\\tau_M$. This is the classic **priority inversion** scenario: a medium-priority task is delaying a high-priority task.\n6.  **At $t=8\\,\\text{ms}$:** $\\tau_M$ completes. The scheduler finds that $\\tau_H$ is still blocked. The highest priority runnable task is now $\\tau_L$.\n7.  **Interval $[8\\,\\text{ms}, 10\\,\\text{ms})$:** $\\tau_L$ resumes execution. It needs to complete the remaining $\\ell_L - 1\\,\\text{ms} = 3 - 1 = 2\\,\\text{ms}$ of its critical section. It runs for these $2\\,\\text{ms}$.\n8.  **At $t=10\\,\\text{ms}$:** $\\tau_L$ completes its critical section and releases the mutex for $R$. This action unblocks $\\tau_H$.\n9.  **At $t=10\\,\\text{ms}$ (scheduler action):** $\\tau_H$ becomes ready and, as the highest priority task, immediately preempts $\\tau_L$.\n10. **Interval $[10\\,\\text{ms}, 12\\,\\text{ms})$:** $\\tau_H$ executes for its WCET of $C_H = 2\\,\\text{ms}$.\n11. **At $t=12\\,\\text{ms}$:** $\\tau_H$ completes its execution.\n\n**Deadline Analysis for $\\tau_H$:**\n- Release time: $t_{release} = 2\\,\\text{ms}$.\n- Relative deadline: $D_H = 10\\,\\text{ms}$.\n- Absolute deadline: $t_{deadline} = 2 + 10 = 12\\,\\text{ms}$.\n- Completion time: $t_{completion} = 12\\,\\text{ms}$.\n\nSince the completion time is equal to the absolute deadline, under a strict deadline definition ($t_{completion}  t_{deadline}$ for success), the deadline is missed. Even under a non-strict definition ($t_{completion} \\le t_{deadline}$), this scenario represents a critical failure with zero slack time, directly caused by priority inversion. The duration of the priority inversion blocking suffered by $\\tau_H$ was the execution time of $\\tau_M$, totaling $6\\,\\text{ms}$.\n\n### Evaluation of Options\n\nLet's evaluate each option based on this analysis.\n\n**A. Counterexample trace: At $t=2$, $\\tau_M$ preempts $\\tau_L$ and blocks $\\tau_H$ directly because of priority inversion on resource $R$, causing $\\tau_H$ to miss its deadline at $t=12$. Fix: switch to a non-preemptive kernel so lower-priority tasks run to completion, which removes all inversions; model checking then shows no deadline miss.**\n\n- **Counterexample Analysis:** The statement that \"$\\tau_M$... blocks $\\tau_H$ directly\" is imprecise. $\\tau_L$ directly blocks $\\tau_H$ by holding the mutex. $\\tau_M$ causes the inversion, prolonging the block.\n- **Fix Analysis:** Switching to a non-preemptive kernel is a drastic change, not a minimal fix. It replaces preemptive interference and priority inversion with potentially large non-preemptive blocking. While it might work for this specific scenario, the claim that it \"removes all inversions\" is false; it simply replaces one type of blocking with another. For example, $\\tau_H$ would be blocked for the entire remaining execution of $\\tau_L$ if it arrived just after $\\tau_L$ started.\n- **Verdict:** **Incorrect**. The reasoning is imprecise and the justification for the fix is flawed.\n\n**B. Counterexample trace: $\\tau_L$ starts at $t=0$; it acquires $R$ at $t=1$ and would hold it for $\\ell_L = 3\\,\\text{ms}$ if uninterrupted. At $t=2$, both $\\tau_H$ and $\\tau_M$ are released. $\\tau_H$ attempts to lock $R$ and blocks behind $\\tau_L$. The kernel does not raise $\\tau_L$’s priority, so $\\tau_M$ preempts $\\tau_L$ from $t=2$ to $t=8$ for its $C_M = 6\\,\\text{ms}$. $\\tau_L$ then resumes, completes its critical section at $t=11$, and releases $R$. $\\tau_H$ acquires $R$ and completes by $t=13$, missing its deadline at $t=12$. Fix: enable priority inheritance on $R$. Then the maximum blocking for $\\tau_H$ is $B_H = \\ell_L = 3\\,\\text{ms}$, and since there are no higher-priority tasks than $\\tau_H$, its worst-case response time satisfies $R_H = C_H + B_H = 2 + 3 = 5  D_H = 10$. Re-running the same model checking with priority inheritance yields $A\\,\\Box(\\text{no\\_deadline\\_miss})$ as true, with no counterexample.**\n\n- **Counterexample Analysis:** The description of the events leading to the priority inversion is entirely correct. However, there is a minor numerical error in the trace: my analysis shows $\\tau_L$ resumes at $t=8$ and runs for its remaining $2\\,\\text{ms}$ of critical section, releasing the lock at $t=10$. This option states it releases the lock at $t=11$. Consequently, it claims $\\tau_H$ completes at $t=13$ instead of $t=12$. Despite this arithmetic slip, the core qualitative description of the priority inversion phenomenon and the conclusion that a deadline is missed are correct.\n- **Fix Analysis:** The proposed fix, Priority Inheritance (PI), is the standard minimal solution to this problem. When $\\tau_H$ blocks on $\\tau_L$, PI would elevate $\\tau_L$'s priority to that of $\\tau_H$, preventing $\\tau_M$ from preempting it. This would bound the blocking time.\n- **Justification Analysis:** The appeal to worst-case response-time analysis (RTA) is correct. For the highest priority task $\\tau_H$, its response time is $R_H = C_H + B_H$. With PI, the maximum blocking $B_H$ is bounded by the longest critical section of any lower-priority task, which is $\\ell_L = 3\\,\\text{ms}$. Therefore, the worst-case response time becomes $R_H = 2\\,\\text{ms} + 3\\,\\text{ms} = 5\\,\\text{ms}$. Since $5\\,\\text{ms}  D_H = 10\\,\\text{ms}$, the deadline is guaranteed to be met. The conclusion about the model checker result is also logical and correct.\n- **Verdict:** **Correct**. Despite a minor numerical error in the trace timeline, this option correctly identifies the phenomenon (priority inversion), proposes the standard minimal fix (priority inheritance), and provides a sound, theoretically correct justification using response-time analysis.\n\n**C. Counterexample trace: $\\tau_L$ never overlaps with $\\tau_H$’s use of $R$, yet $\\tau_H$ still misses its deadline because it busy-waits on $R$ from $t=2$ to $t=5$. Fix: adopt the priority ceiling protocol; the new worst-case response time is $R_H = C_H + \\ell_H = 2 + 1 = 3  10$, so deadlines hold, and model checking confirms the property.**\n\n- **Counterexample Analysis:** The premise \"$\\tau_L$ never overlaps with $\\tau_H$’s use of $R$\" is factually incorrect for the given scenario. At $t=2$, $\\tau_L$ holds the lock on $R$ when $\\tau_H$ is released.\n- **Fix Analysis:** The Priority Ceiling Protocol (PCP) is indeed a valid and often superior fix.\n- **Justification Analysis:** The response time calculation is wrong. Under PCP, the blocking term $B_H$ is the duration of the longest critical section of any lower-priority task using a resource with a ceiling relevant to $\\tau_H$. Here, that would be $\\ell_L = 3\\,\\text{ms}$, not $\\ell_H = 1\\,\\text{ms}$. The correct RTA would be $R_H = C_H + \\ell_L = 2 + 3 = 5$ ms.\n- **Verdict:** **Incorrect**. The counterexample is based on a false premise, and the justification contains an incorrect formula for response-time analysis.\n\n**D. Counterexample trace: $\\tau_H$ can miss its deadline if it releases at $t=9$ while $\\tau_L$ is executing; the system is unstable because of jitter. Fix: convert the system to a time-triggered static table with slots of $2\\,\\text{ms}$ for $\\tau_H$, $6\\,\\text{ms}$ for $\\tau_M$, and $8\\,\\text{ms}$ for $\\tau_L$; the fixed table removes interference, so deadlines hold, and model checking remains unchanged.**\n\n- **Counterexample Analysis:** This option ignores the specified release times ($t=0, t=2$) and invents a new scenario. The problem asks for an analysis of the given workload, not a hypothetical one. The term \"jitter\" is introduced without basis from the problem statement.\n- **Fix Analysis:** Converting to a time-triggered (TT) architecture is a fundamental system redesign, not a \"minimal fix.\" The description of the fix is incomplete as it only gives slot sizes, not the actual schedule.\n- **Justification Analysis:** The claim that \"model checking remains unchanged\" is false. A TT system has a completely different state-space model than an event-triggered, priority-preemptive system.\n- **Verdict:** **Incorrect**. It fails to analyze the given problem, proposes a non-minimal fix, and contains flawed justifications.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Theoretical scheduling models are only as valuable as their ability to accurately represent real-world systems, where network protocols and hardware constraints add significant complexity. This practice problem grounds event-triggered theory in the widely used Controller Area Network (CAN) protocol, challenging you to compute a message's worst-case response time from the bit level up. This exercise demonstrates how to translate abstract scheduling formulas into a concrete analysis that accounts for non-preemptive arbitration, message framing, and protocol-specific overheads like bit stuffing, providing a realistic view of schedulability analysis in a networked cyber-physical system. ",
            "id": "4251633",
            "problem": "A cyber-physical system uses an event-triggered Controller Area Network (CAN) bus for sensor-to-controller communication. The system is modeled as a digital twin with bit-level timing fidelity. The CAN bus is a shared, non-preemptive medium: once a frame begins transmission, it cannot be interrupted, and non-destructive arbitration ensures that the frame with the numerically lowest identifier wins access when multiple frames are ready.\n\nAssume a Classical CAN standard data frame (eleven-bit identifier) with the following bit-field structure and bit stuffing rule:\n- Bit fields prior to the Cyclic Redundancy Check (CRC) delimiter are stuffed: after any sequence of five consecutive identical bits, one stuff bit of opposite polarity is inserted. This rule applies continuously from the Start Of Frame (SOF) through the end of the CRC sequence.\n- The unstuffed, fixed fields are: Start Of Frame ($1$ bit), Arbitration ($11$-bit identifier and $1$-bit Remote Transmission Request, $12$ bits total), Control ($6$ bits including Identifier Extension and Data Length Code), Data ($8D$ bits for $D$ bytes of payload), CRC sequence ($15$ bits), CRC delimiter ($1$ bit), Acknowledge ($2$ bits), End Of Frame ($7$ bits), and Interframe Space ($3$ bits).\n- The number of stuffed bits inserted into the stuffed region is upper bounded by $\\left\\lfloor\\frac{N_{\\mathrm{stuffable}}-1}{5}\\right\\rfloor$, where $N_{\\mathrm{stuffable}}$ is the count of unstuffed bits from SOF through the CRC sequence.\n\nThe bus nominal bit rate is $500\\,000$ bits per second. Consider one lower-priority event-triggered message $M_{0}$ and two higher-priority messages $H_{1}$ and $H_{2}$ with the following properties:\n- $M_{0}$ has payload $D_{0}=6$ bytes.\n- $H_{1}$ has payload $D_{1}=8$ bytes and minimum inter-arrival time (period) $T_{1}=1.5\\,\\text{ms}$.\n- $H_{2}$ has payload $D_{2}=3$ bytes and minimum inter-arrival time (period) $T_{2}=2.2\\,\\text{ms}$.\n\nAssume zero release jitter for all messages, that all three messages may be released simultaneously at time $t=0$, and that the bus is idle immediately before $t=0$ so there is no in-flight lower-priority blocking at the trigger instant. Frame durations include the worst-case number of stuffed bits and the Interframe Space of $3$ bits for each transmission. Ignore propagation, transceiver delays, oscillator tolerances, and error frames; model each bit as taking exactly $1/r_{b}$ seconds at the given bit rate $r_{b}$.\n\nDefine the Worst-Case Response Time (WCRT) of $M_{0}$ as the time from the release of $M_{0}$ at $t=0$ until the end of its successful transmission, accounting for all interfering transmissions of higher-priority messages that can occur within its busy window. Using first principles and the given bit-level structure and stuffing bound, compute the WCRT of $M_{0}$ under interference from $H_{1}$ and $H_{2}$.\n\nRound your final numerical answer to four significant figures and express it in microseconds.",
            "solution": "The problem statement is scientifically grounded, well-posed, and internally consistent. It provides a complete set of parameters to perform a standard Worst-Case Response Time (WCRT) analysis for a real-time system, specifically a Controller Area Network (CAN) bus. The model details, including bit field lengths and the formula for bit stuffing, are explicitly defined, allowing for a unique and verifiable solution. Thus, the problem is valid.\n\nThe Worst-Case Response Time for a message $M_i$ in a fixed-priority, non-preemptive system is given by the recursive formula:\n$$R_i^{(k+1)} = B_i + C_i + \\sum_{j \\in hp(i)} \\left\\lceil \\frac{R_i^{(k)}}{T_j} \\right\\rceil C_j$$\nwhere $R_i$ is the response time of message $M_i$, $B_i$ is the blocking time from lower-priority messages, $C_i$ is the worst-case transmission time of message $M_i$, $hp(i)$ is the set of higher-priority messages, and $T_j$ is the minimum inter-arrival time (period) of a higher-priority message $M_j$. The iteration starts with an initial guess, typically $R_i^{(0)} = C_i + B_i$, and continues until $R_i^{(k+1)} = R_i^{(k)}$.\n\nFor the message of interest, $M_0$, the higher priority set is $hp(0) = \\{H_1, H_2\\}$. The problem states the bus is idle at the critical instant $t=0$, so the blocking term $B_0=0$. The equation for the WCRT of $M_0$, denoted $R_0$, is:\n$$R_0 = C_0 + \\left\\lceil \\frac{R_0}{T_1} \\right\\rceil C_1 + \\left\\lceil \\frac{R_0}{T_2} \\right\\rceil C_2$$\n\nThe first step is to calculate the worst-case transmission time $C_i$ for each message $M_i \\in \\{M_0, H_1, H_2\\}$. The problem specifies that this duration includes the frame transmission time and the Interframe Space (IFS). The bit time, $\\tau_b$, is the reciprocal of the bit rate $r_b$:\n$$\\tau_b = \\frac{1}{r_b} = \\frac{1}{500\\,000 \\, \\text{bits/s}} = 2 \\times 10^{-6} \\, \\text{s} = 2 \\, \\mu\\text{s}$$\n\nThe worst-case transmission time $C_i$ is the total number of bits for a worst-case frame plus the IFS, multiplied by the bit time:\n$$C_i = (N_{\\text{frame}, i}^{\\text{wc}} + N_{\\text{IFS}}) \\times \\tau_b$$\nThe number of bits in a worst-case frame, $N_{\\text{frame}, i}^{\\text{wc}}$, is the sum of the unstuffed bits and the maximum number of stuffed bits, $N_{\\text{stuff}, i}$.\n$$N_{\\text{frame}, i}^{\\text{wc}} = N_{\\text{frame}, i}^{\\text{unstuffed}} + N_{\\text{stuff}, i}$$\n\nThe number of unstuffed bits in a Classical CAN data frame with a payload of $D_i$ bytes is:\n$N_{\\text{frame}, i}^{\\text{unstuffed}} = \\text{SOF}(1) + \\text{Arb}(12) + \\text{Ctrl}(6) + \\text{Data}(8D_i) + \\text{CRC}(15) + \\text{CRCdel}(1) + \\text{ACK}(2) + \\text{EOF}(7)$\n$$N_{\\text{frame}, i}^{\\text{unstuffed}} = 1 + 12 + 6 + 8D_i + 15 + 1 + 2 + 7 = 44 + 8D_i$$\n\nBit stuffing is applied from SOF to the end of the CRC sequence. The number of unstuffed bits in this region, $N_{\\text{stuffable}, i}$, is:\n$$N_{\\text{stuffable}, i} = \\text{SOF}(1) + \\text{Arb}(12) + \\text{Ctrl}(6) + \\text{Data}(8D_i) + \\text{CRC}(15) = 34 + 8D_i$$\nAccording to the problem statement, the maximum number of stuffed bits is bounded by:\n$$N_{\\text{stuff}, i} = \\left\\lfloor\\frac{N_{\\text{stuffable}, i}-1}{5}\\right\\rfloor = \\left\\lfloor\\frac{(34 + 8D_i) - 1}{5}\\right\\rfloor = \\left\\lfloor\\frac{33 + 8D_i}{5}\\right\\rfloor$$\n\nNow we compute $C_0$, $C_1$, and $C_2$. The IFS is given as $N_{\\text{IFS}} = 3$ bits.\n\nFor message $M_0$ with $D_0 = 6$ bytes:\n$N_{\\text{stuffable}, 0} = 34 + 8 \\times 6 = 34 + 48 = 82$ bits.\n$N_{\\text{stuff}, 0} = \\left\\lfloor\\frac{82-1}{5}\\right\\rfloor = \\lfloor 16.2 \\rfloor = 16$ bits.\n$N_{\\text{frame}, 0}^{\\text{unstuffed}} = 44 + 8 \\times 6 = 92$ bits.\n$N_{\\text{frame}, 0}^{\\text{wc}} = 92 + 16 = 108$ bits.\n$C_0 = (108 + 3) \\times \\tau_b = 111 \\times 2 \\, \\mu\\text{s} = 222 \\, \\mu\\text{s}$.\n\nFor message $H_1$ with $D_1 = 8$ bytes:\n$N_{\\text{stuffable}, 1} = 34 + 8 \\times 8 = 34 + 64 = 98$ bits.\n$N_{\\text{stuff}, 1} = \\left\\lfloor\\frac{98-1}{5}\\right\\rfloor = \\lfloor 19.4 \\rfloor = 19$ bits.\n$N_{\\text{frame}, 1}^{\\text{unstuffed}} = 44 + 8 \\times 8 = 108$ bits.\n$N_{\\text{frame}, 1}^{\\text{wc}} = 108 + 19 = 127$ bits.\n$C_1 = (127 + 3) \\times \\tau_b = 130 \\times 2 \\, \\mu\\text{s} = 260 \\, \\mu\\text{s}$.\n\nFor message $H_2$ with $D_2 = 3$ bytes:\n$N_{\\text{stuffable}, 2} = 34 + 8 \\times 3 = 34 + 24 = 58$ bits.\n$N_{\\text{stuff}, 2} = \\left\\lfloor\\frac{58-1}{5}\\right\\rfloor = \\lfloor 11.4 \\rfloor = 11$ bits.\n$N_{\\text{frame}, 2}^{\\text{unstuffed}} = 44 + 8 \\times 3 = 68$ bits.\n$N_{\\text{frame}, 2}^{\\text{wc}} = 68 + 11 = 79$ bits.\n$C_2 = (79 + 3) \\times \\tau_b = 82 \\times 2 \\, \\mu\\text{s} = 164 \\, \\mu\\text{s}$.\n\nWe can now solve for $R_0$ using the iterative method. The parameters are:\n$C_0 = 222 \\, \\mu\\text{s}$\n$C_1 = 260 \\, \\mu\\text{s}$, $T_1 = 1.5 \\, \\text{ms} = 1500 \\, \\mu\\text{s}$\n$C_2 = 164 \\, \\mu\\text{s}$, $T_2 = 2.2 \\, \\text{ms} = 2200 \\, \\mu\\text{s}$\n$B_0 = 0 \\, \\mu\\text{s}$\n\nThe recurrence relation is:\n$$R_0^{(k+1)} = 222 + \\left\\lceil \\frac{R_0^{(k)}}{1500} \\right\\rceil \\times 260 + \\left\\lceil \\frac{R_0^{(k)}}{2200} \\right\\rceil \\times 164$$\nLet's start the iteration with an initial guess $R_0^{(0)}$ equal to the sum of the transmission times of $M_0$ and all higher-priority messages released at the critical instant.\n$$R_0^{(0)} = C_0 + C_1 + C_2 = 222 + 260 + 164 = 646 \\, \\mu\\text{s}$$\nNow, we compute the first iteration, $R_0^{(1)}$:\n$$R_0^{(1)} = 222 + \\left\\lceil \\frac{646}{1500} \\right\\rceil \\times 260 + \\left\\lceil \\frac{646}{2200} \\right\\rceil \\times 164$$\n$$R_0^{(1)} = 222 + \\lceil 0.4306... \\rceil \\times 260 + \\lceil 0.2936... \\rceil \\times 164$$\n$$R_0^{(1)} = 222 + 1 \\times 260 + 1 \\times 164 = 222 + 260 + 164 = 646 \\, \\mu\\text{s}$$\nSince $R_0^{(1)} = R_0^{(0)} = 646 \\, \\mu\\text{s}$, the iteration converges. The Worst-Case Response Time for $M_0$ is $646 \\, \\mu\\text{s}$. This result is physically intuitive: the WCRT occurs when all messages are released simultaneously, and the busy-window length is shorter than the periods of the interfering messages, meaning they each interfere exactly once. The total time is the sum of their individual transmission times.\n\nThe problem requires the final answer rounded to four significant figures.\n$$R_0 = 646.0 \\, \\mu\\text{s}$$",
            "answer": "$$\\boxed{646.0}$$"
        }
    ]
}