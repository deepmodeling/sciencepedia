{
    "hands_on_practices": [
        {
            "introduction": "许多信息物理系统，例如那些具有周期性调度监控的数字孪生系统，表现出周期性行为，因此理解它们的长期稳定性至关重要。本练习将引导你应用Floquet理论——一个分析线性时变周期（LTP）系统的强大工具——通过为一个离散时间系统计算Floquet乘子来判断其指数稳定性 。",
            "id": "4223719",
            "problem": "考虑一个实现离散时间周期性监控调度的二自由度信息物理系统（CPS）的数字孪生。状态更新由线性时变差分方程 $x_{k+1}=A_{k}x_{k}$ 建模，其中 $A_{k}$ 是周期为 $T=3$ 的周期矩阵，即对于所有整数 $k\\geq 0$ 都有 $A_{k+3}=A_{k}$。在一个周期内，系统矩阵为\n$$\nA_{0}=\\begin{pmatrix}0.8  0.1 \\\\ 0  0.9\\end{pmatrix},\\quad\nA_{1}=\\begin{pmatrix}1.2  -0.2 \\\\ 0  0.7\\end{pmatrix},\\quad\nA_{2}=\\begin{pmatrix}0.95  0.05 \\\\ 0  0.6\\end{pmatrix}.\n$$\n从线性离散时间系统和周期性时变动力学的基础原理出发，计算与系统一个周期相关的弗洛凯乘子。然后，确定该周期性离散时间系统指数稳定性的条件。\n\n使用 $\\texttt{pmatrix}$ 环境将弗洛凯乘子表示为行矩阵，并将数值四舍五入到四位有效数字。答案不需要物理单位。",
            "solution": "该问题是有效的，因为它科学地基于线性离散时间周期系统的弗洛凯理论的既定原则，问题提法得当，信息充分，可得到唯一解，并且表述客观，没有歧义。\n\n所考虑的系统是一个具有周期性时变状态矩阵的线性离散时间系统，由以下差分方程描述：\n$$x_{k+1} = A_k x_k$$\n其中 $x_k \\in \\mathbb{R}^2$ 是在离散时间步 $k$ 的状态向量，矩阵 $A_k$ 的周期为 $T=3$。这意味着对于所有整数 $k \\geq 0$，$A_{k+3} = A_k$。\n\n分析此类周期系统的核心是研究其在一个完整周期内的行为。从初始时间 $k_0$ 到稍后时间 $k$ 的状态演化由状态转移矩阵 $\\Phi(k, k_0)$ 描述。在时间 $k$ 的状态由 $x_k = \\Phi(k, k_0) x_{k_0}$ 给出。对于此系统，从 $j$到 $j+1$ 的一个时间步内的状态转移矩阵就是 $A_j$。\n\n从时间 $k=0$ 开始的一个完整周期内的状态演化是通过组合周期内每一步的状态更新来找到的。一步之后的状态是 $x_1 = A_0 x_0$。两步之后，$x_2 = A_1 x_1 = A_1 A_0 x_0$。三步之后，完成一个周期，状态为：\n$$x_3 = A_2 x_2 = A_2 (A_1 A_0 x_0) = (A_2 A_1 A_0) x_0$$\n将状态从一个周期的开始映射到该周期结束的矩阵称为单值矩阵。对于从 $k=0$ 开始的周期，单值矩阵为 $\\Phi(3, 0)$。\n$$\\Phi(3, 0) = A_{3-1} A_{3-2} \\cdots A_0 = A_2 A_1 A_0$$\n我们已知一个周期内的矩阵：\n$$A_{0}=\\begin{pmatrix}0.8  0.1 \\\\ 0  0.9\\end{pmatrix}, \\quad A_{1}=\\begin{pmatrix}1.2  -0.2 \\\\ 0  0.7\\end{pmatrix}, \\quad A_{2}=\\begin{pmatrix}0.95  0.05 \\\\ 0  0.6\\end{pmatrix}$$\n首先，我们计算乘积 $A_1 A_0$：\n$$A_1 A_0 = \\begin{pmatrix}1.2  -0.2 \\\\ 0  0.7\\end{pmatrix} \\begin{pmatrix}0.8  0.1 \\\\ 0  0.9\\end{pmatrix} = \\begin{pmatrix}(1.2)(0.8) + (-0.2)(0)  (1.2)(0.1) + (-0.2)(0.9) \\\\ (0)(0.8) + (0.7)(0)  (0)(0.1) + (0.7)(0.9)\\end{pmatrix}$$\n$$A_1 A_0 = \\begin{pmatrix}0.96  0.12 - 0.18 \\\\ 0  0.63\\end{pmatrix} = \\begin{pmatrix}0.96  -0.06 \\\\ 0  0.63\\end{pmatrix}$$\n接下来，我们计算单值矩阵 $\\Phi(3, 0) = A_2 (A_1 A_0)$：\n$$\\Phi(3, 0) = \\begin{pmatrix}0.95  0.05 \\\\ 0  0.6\\end{pmatrix} \\begin{pmatrix}0.96  -0.06 \\\\ 0  0.63\\end{pmatrix}$$\n$$\\Phi(3, 0) = \\begin{pmatrix}(0.95)(0.96) + (0.05)(0)  (0.95)(-0.06) + (0.05)(0.63) \\\\ (0)(0.96) + (0.6)(0)  (0)(-0.06) + (0.6)(0.63)\\end{pmatrix}$$\n$$\\Phi(3, 0) = \\begin{pmatrix}0.912  -0.057 + 0.0315 \\\\ 0  0.378\\end{pmatrix} = \\begin{pmatrix}0.912  -0.0255 \\\\ 0  0.378\\end{pmatrix}$$\n这就是系统一个周期的单值矩阵。\n\n弗洛凯乘子，记作 $\\lambda_i$，是单值矩阵的特征值。为了求出 $\\Phi(3, 0)$ 的特征值，我们求解特征方程 $\\det(\\Phi(3, 0) - \\lambda I) = 0$，其中 $I$ 是单位矩阵。\n$$\\det\\begin{pmatrix}0.912 - \\lambda  -0.0255 \\\\ 0  0.378 - \\lambda\\end{pmatrix} = 0$$\n由于单值矩阵是上三角矩阵，其特征值就是其对角线上的元素。\n$$(0.912 - \\lambda)(0.378 - \\lambda) = 0$$\n因此，弗洛凯乘子为：\n$$\\lambda_1 = 0.912$$\n$$\\lambda_2 = 0.378$$\n\n根据离散时间系统的弗洛凯理论，线性周期系统 $x_{k+1}=A_k x_k$ 的原点是指数稳定的，当且仅当其所有弗洛凯乘子的模都严格小于 $1$。这个条件等价于单值矩阵的谱半径 $\\rho(\\Phi)$ 小于 $1$，即 $\\rho(\\Phi) = \\max_i |\\lambda_i|  1$。\n\n在这种情况下，我们检查计算出的弗洛凯乘子的模：\n$$|\\lambda_1| = |0.912| = 0.912  1$$\n$$|\\lambda_2| = |0.378| = 0.378  1$$\n由于两个弗洛凯乘子的模都严格小于 $1$，该特定系统满足指数稳定性的条件。\n\n问题要求将弗洛凯乘子四舍五入到四位有效数字。\n$\\lambda_1 = 0.9120$\n$\\lambda_2 = 0.3780$\n这些值将表示为一个行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.9120  0.3780\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "信息物理系统的一个核心挑战是设计控制器，使其不仅能实现性能目标（如镇定），还能保证安全性（避免进入不安全状态）。本练习将探讨一种先进的、基于优化的方法，它将用于实现稳定性的控制李雅普诺夫函数（CLF）和用于保证安全性的控制障碍函数（CBF）统一到一个二次规划（QP）问题中，该技术已广泛应用于机器人和自主系统中 。",
            "id": "4223707",
            "problem": "考虑一个信息物理设备，其模型为单输入单输出连续时间系统，状态为 $x \\in \\mathbb{R}$，控制输入为 $u \\in \\mathbb{R}$，遵循单积分器动力学 $\\dot{x} = u$。您的任务是通过二次规划（QP）将控制李雅普诺夫函数（CLF）目标与控制障碍函数（CBF）约束统一起来，并分析当CLF目标与CBF约束发生冲突时的可行性，特别是在存在执行器限制的情况下。\n\n从以下基本定义和法则开始：\n- CLF $V(x)$ 是一个连续可微的正定函数，其期望的下降速率由一个常数 $c  0$ 来量化。对于单积分器模型，使用 $V(x) = \\frac{1}{2} x^2$。CLF 条件通过沿漂移项 $f(x)$ 和输入向量场 $g(x)$ 的李导数 $L_f V(x)$ 和 $L_g V(x)$ 来表示。对于单积分器，漂移项为 $f(x) = 0$，输入向量场为 $g(x) = 1$，因此 $L_f V(x) = 0$ 且 $L_g V(x) = \\frac{\\partial V}{\\partial x} = x$。为了使调节与安全性共存，引入一个非负松弛变量 $\\delta \\ge 0$ 来放宽CLF不等式。松弛后的CLF约束为\n$$\nx u \\le -\\frac{c}{2} x^2 + \\delta.\n$$\n- CBF $h(x)$ 通过强制执行不等式 $\\dot{h}(x) + \\alpha h(x) \\ge 0$ 来定义一个前向不变安全集 $\\{x \\mid h(x) \\ge 0\\}$，其中 $\\alpha  0$（一个$\\mathcal{K}$类增益）。使用仿射障碍函数 $h(x) = x - x_{\\min}$，其中 $x_{\\min} \\in \\mathbb{R}$ 表示一个安全阈值。对于单积分器模型，这得到\n$$\nu + \\alpha (x - x_{\\min}) \\ge 0,\n$$\n或等价地\n$$\nu \\ge -\\alpha (x - x_{\\min}).\n$$\n- 为编码执行器限制，施加箱式约束 $u_{\\min} \\le u \\le u_{\\max}$，其中给定常数 $u_{\\min} \\in \\mathbb{R}$ 和 $u_{\\max} \\in \\mathbb{R}$。\n\n构建以下凸二次规划（QP），它统一了CLF目标和CBF约束：\n- 决策变量：$(u, \\delta) \\in \\mathbb{R} \\times \\mathbb{R}$，其中 $\\delta \\ge 0$。\n- 目标：最小化二次成本\n$$\nJ(u,\\delta) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\delta^2,\n$$\n其中 $p  0$ 是对CLF松弛量的惩罚权重。\n- 约束条件：\n    1. CLF下降（松弛）：$x u \\le -\\frac{c}{2} x^2 + \\delta$，\n    2. CBF安全：$u \\ge -\\alpha (x - x_{\\min})$，\n    3. 执行器限制：$u_{\\min} \\le u \\le u_{\\max}$，\n    4. 松弛量非负性：$\\delta \\ge 0$。\n\n您的程序必须：\n- 从基本原理出发实现一个算法，为给定的参数 $(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max})$ 计算最优解 $(u^\\star, \\delta^\\star)$ 和最优成本 $J^\\star$。\n- 判断可行性：返回一个布尔值，指示是否存在任何满足所有约束的 $(u, \\delta)$。根据约束来解释可行性；特别地，CLF约束可通过 $\\delta \\ge 0$ 来松弛，因此不可行性只能源于无法调和的安全和执行器限制。\n\n您必须分析并编码当CLF目标和CBF约束与执行器限制冲突时的可行性条件。具体来说，您的解决方案必须根据约束进行推理，以判定何时不存在容许的控制 $u$ 能同时满足CBF不等式和执行器边界，无论CLF松弛量 $\\delta$ 如何。\n\n测试套件：\n使用以下参数集来测试不同的情况（正常路径、边界情况和冲突情况）。每个测试用例是一个元组 $(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max})$：\n- 情况 1：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\,1.0,\\,0.0,\\,1.0,\\,1.0,\\,100.0,\\, -2.0,\\, 2.0\\,)$。\n- 情况 2：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\,0.0,\\,0.0,\\,1.0,\\,1.0,\\,10.0,\\, -1.0,\\, 1.0\\,)$。\n- 情况 3：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\,0.1,\\,0.0,\\,50.0,\\,1.0,\\,10.0,\\, -2.0,\\, 2.0\\,)$。\n- 情况 4：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\, -1.0,\\, -5.0,\\, 0.5,\\, 1.0,\\, 50.0,\\, -3.0,\\, 3.0\\,)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且必须是 $[\\text{feasible}, u^\\star, \\delta^\\star, J^\\star]$ 形式的列表，其中 $\\text{feasible}$ 是一个布尔值，$u^\\star$、$ \\delta^\\star$ 和 $J^\\star$ 是实数。例如，输出必须看起来像\n$[[\\text{True}, u_1, \\delta_1, J_1],[\\text{False}, u_2, \\delta_2, J_2],\\ldots]$\n这是为四个指定的测试用例计算的结果。",
            "solution": "所提出的问题是为单积分器系统 $\\dot{x} = u$ 寻找最优控制输入 $u$ 和控制李雅普诺夫函数（CLF）的松弛量 $\\delta$。该优化问题被构建为一个二次规划（QP），其目标是最小化一个平衡了控制力与CLF松弛的成本函数，并受到来自松弛CLF、控制障碍函数（CBF）、执行器限制和松弛量非负性的约束。\n\n该QP的构建如下：\n$$ \\min_{u, \\delta} \\quad J(u,\\delta) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\delta^2 $$\n约束条件为：\n1.  $x u \\le -\\frac{c}{2} x^2 + \\delta$ (松弛的CLF条件)\n2.  $u \\ge -\\alpha (x - x_{\\min})$ (CBF条件)\n3.  $u_{\\min} \\le u \\le u_{\\max}$ (执行器限制)\n4.  $\\delta \\ge 0$ (松弛量非负性)\n\n在这里，$x \\in \\mathbb{R}$ 是状态，$u \\in \\mathbb{R}$ 是控制输入，$\\delta \\in \\mathbb{R}$ 是松弛变量。参数 $c, p, \\alpha, x_{\\min}, u_{\\min}, u_{\\max}$ 是给定的正常数或实数值。\n\n首先，我们分析这个QP的可行性。CLF约束 $x u \\le -\\frac{c}{2} x^2 + \\delta$ 可以重写为 $\\delta \\ge x u + \\frac{c}{2} x^2$。由于我们还有约束 $\\delta \\ge 0$，对于任何给定的控制输入 $u$，我们总能通过选择 $\\delta \\ge \\max(0, x u + \\frac{c}{2} x^2)$ 来找到一个可行的 $\\delta$。这意味着整个QP的可行性仅取决于是否存在一个满足其余约束的控制输入 $u$。对 $u$ 的这些约束是CBF条件和执行器限制：\n$$ u \\ge -\\alpha (x - x_{\\min}) $$\n$$ u_{\\min} \\le u \\le u_{\\max} $$\n要使一个可行的 $u$ 存在，由这些不等式定义的集合的交集必须非空。当且仅当 $u$ 的总下界小于或等于上界时，这个条件才成立。令 $u_{cbf} = -\\alpha (x - x_{\\min})$ 为来自CBF约束的下界。$u$ 的组合下界是 $\\max(u_{\\min}, u_{cbf})$。因此，当且仅当以下条件成立时，$u$ 的可行集非空：\n$$ \\max(u_{\\min}, -\\alpha (x - x_{\\min})) \\le u_{\\max} $$\n这就是可行性条件。如果不满足，则不存在解。我们假设执行器限制是明确定义的，即 $u_{\\min} \\le u_{\\max}$。该条件随后简化为 $-\\alpha (x - x_{\\min}) \\le u_{\\max}$。\n\n如果问题是可行的，我们继续寻找最优解 $(u^\\star, \\delta^\\star)$。为了最小化目标函数 $J(u, \\delta)$，这是一个带有正权重（$p0$）的平方项之和，我们必须为 $\\delta$ 选择最小的允许值。如前所述，对 $\\delta$ 的约束是 $\\delta \\ge 0$ 和 $\\delta \\ge x u + \\frac{c}{2} x^2$。因此，对于任意给定的 $u$，$\\delta$ 的最优选择是：\n$$ \\delta(u) = \\max\\left(0, x u + \\frac{c}{2} x^2\\right) $$\n将此代入目标函数，将双变量QP转化为关于 $u$ 的一维优化问题：\n$$ \\min_{u \\in [u_{lower}, u_{upper}]} \\quad J(u) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\left( \\max\\left(0, x u + \\frac{c}{2} x^2\\right) \\right)^2 $$\n其中 $u$ 的可行区间是 $[u_{lower}, u_{upper}]$，且 $u_{lower} = \\max(u_{\\min}, -\\alpha (x - x_{\\min}))$ 和 $u_{upper} = u_{\\max}$。\n\n目标函数 $J(u)$ 是凸函数且连续可微。其无约束最小值可以通过将其导数设为零来找到。我们通过考虑基于 $C(u) = x u + \\frac{c}{2} x^2$ 符号的两种情况来分析这个问题。\n\n情况1：$C(u) \\le 0$。此时，$\\delta(u)=0$ 且 $J(u) = \\frac{1}{2} u^2$。这个二次函数的最小值在 $u=0$ 处。然而，条件 $C(0) = \\frac{c}{2}x^2 \\le 0$ 仅在 $x=0$ 时成立，我们将其作为特殊情况处理。\n\n情况2：$C(u)  0$。此时，$\\delta(u) = x u + \\frac{c}{2} x^2$ 且目标函数为 $J(u) = \\frac{1}{2} u^2 + \\frac{1}{2} p (x u + \\frac{c}{2} x^2)^2$。其导数为：\n$$ \\frac{dJ}{du} = u + p \\left(x u + \\frac{c}{2} x^2\\right) x = u(1 + px^2) + \\frac{pcx^3}{2} $$\n令 $\\frac{dJ}{du} = 0$ 可得出无约束极小值点：\n$$ u_{unc} = -\\frac{p c x^3}{2(1 + p x^2)} $$\n我们可以验证，对于 $x \\neq 0$，这个 $u_{unc}$ 的值使得 $C(u_{unc}) = x u_{unc} + \\frac{c}{2} x^2 = \\frac{c x^2}{2(1 + p x^2)}  0$，这证实了无约束最小值位于该区域内。\n\n对于有约束问题，最优解 $u^\\star$ 是无约束极小值点 $u_{unc}$ 在可行区间 $[u_{lower}, u_{upper}]$ 上的投影。\n$$ u^\\star = \\max(u_{lower}, \\min(u_{unc}, u_{upper})) $$\n\n特殊情况：$x = 0$。\n如果 $x=0$，CLF约束变为 $\\delta \\ge 0$。CBF约束为 $u \\ge \\alpha x_{\\min}$。$u$ 的可行集为 $u \\in [\\max(u_{\\min}, \\alpha x_{\\min}), u_{\\max}]$。目标函数是 $J(u, \\delta) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\delta^2$。为了最小化 $J$，我们必须选择 $\\delta^\\star=0$。最优控制 $u^\\star$ 是可行区间中最接近 $0$ 的值，这可以通过将 $0$ 投影到该区间上找到。\n\n算法如下：\n1.  计算可行性边界：$u_{cbf} = -\\alpha (x - x_{\\min})$，$u_{lower} = \\max(u_{\\min}, u_{cbf})$，以及 $u_{upper} = u_{\\max}$。\n2.  检查可行性：如果 $u_{lower} > u_{upper}$，则问题不可行。\n3.  如果可行：\n    a. 如果 $x=0$：\n       $u^\\star = \\max(u_{lower}, \\min(0, u_{upper}))$。\n       $\\delta^\\star = 0$。\n    b. 如果 $x \\neq 0$：\n       计算 $u_{unc} = - (p \\cdot c \\cdot x^3) / (2 \\cdot (1 + p \\cdot x^2))$。\n       $u^\\star = \\max(u_{lower}, \\min(u_{unc}, u_{upper}))$。\n       $\\delta^\\star = \\max(0, x \\cdot u^\\star + (c/2) \\cdot x^2)$。\n4.  计算最优成本 $J^\\star = \\frac{1}{2} (u^\\star)^2 + \\frac{1}{2} p (\\delta^\\star)^2$。\n5.  返回可行性状态和最优值 $(u^\\star, \\delta^\\star, J^\\star)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve_clf_cbf_qp(x, x_min, alpha, c, p, u_min, u_max):\n    \"\"\"\n    Solves the CLF-CBF-QP for a single-integrator system from first principles.\n\n    Args:\n        x (float): Current state.\n        x_min (float): Safety threshold for the state.\n        alpha (float): CBF class-K gain.\n        c (float): CLF decay rate constant.\n        p (float): Penalty weight on the CLF slack.\n        u_min (float): Minimum control input.\n        u_max (float): Maximum control input.\n\n    Returns:\n        list: A list containing [feasible, u_star, delta_star, J_star].\n              'feasible' is a boolean. For infeasible cases, the other\n              values are np.nan.\n    \"\"\"\n    # 1. Feasibility Analysis\n    # The set of admissible controls for u is constrained by the CBF and actuator limits.\n    # Feasibility requires this set to be non-empty.\n    \n    # Lower bound from CBF: u = -alpha * (x - x_min)\n    u_cbf = -alpha * (x - x_min)\n\n    # Combined lower bound for u\n    u_lower = max(u_min, u_cbf)\n    u_upper = u_max\n\n    is_feasible = u_lower = u_upper\n\n    if not is_feasible:\n        return [False, np.nan, np.nan, np.nan]\n\n    # 2. Solve for the optimal (u*, delta*)\n    u_star = 0.0\n    delta_star = 0.0\n\n    if x == 0.0:\n        # For x=0, CLF constraint is delta = 0.\n        # Objective is min 0.5*u^2 + 0.5*p*delta^2.\n        # To minimize, we need delta=0 and u to be as close to 0 as possible.\n        # u_star is the projection of 0 onto the feasible set [u_lower, u_upper].\n        u_star = max(u_lower, min(0.0, u_upper))\n        delta_star = 0.0\n    else:\n        # For x != 0, solve the 1D optimization problem for u.\n        # Unconstrained minimizer of the reduced objective function J(u).\n        numerator = p * c * (x**3)\n        denominator = 2 * (1 + p * (x**2))\n        u_unc = -numerator / denominator\n\n        # The optimal u* is the projection of u_unc onto the feasible interval.\n        u_star = max(u_lower, min(u_unc, u_upper))\n        \n        # The optimal delta* is the smallest value satisfying the constraints.\n        delta_star = max(0.0, x * u_star + (c / 2.0) * (x**2))\n\n    # 3. Calculate the optimal cost\n    J_star = 0.5 * (u_star**2) + 0.5 * p * (delta_star**2)\n\n    return [True, u_star, delta_star, J_star]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results in the required format.\n    \"\"\"\n    test_cases = [\n        # (x, x_min, alpha, c, p, u_min, u_max)\n        (1.0, 0.0, 1.0, 1.0, 100.0, -2.0, 2.0),\n        (0.0, 0.0, 1.0, 1.0, 10.0, -1.0, 1.0),\n        (0.1, 0.0, 50.0, 1.0, 10.0, -2.0, 2.0),\n        (-1.0, -5.0, 0.5, 1.0, 50.0, -3.0, 3.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = solve_clf_cbf_qp(*params)\n        results.append(result)\n\n    # Format the output string as specified in the problem.\n    # e.g., [[True,-0.495...,0.00495...,0.123...],[True,0.0,0.0,0.0],...]\n    formatted_results = []\n    for res in results:\n        # str() on a boolean gives 'True' or 'False' with correct capitalization.\n        # str() on np.nan gives 'nan'.\n        inner_list_str = f\"[{str(res[0])},{res[1]},{res[2]},{res[3]}]\"\n        formatted_results.append(inner_list_str)\n    \n    # Final output is a comma-separated list of these inner lists, enclosed in brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了仿真之外，形式化验证能为系统行为提供数学上的保证，这对于安全关键系统至关重要。本练习将展示如何将一个混合系统（兼具连续状态和离散模式）的复杂动态转化为一个混合整数线性规划（MILP）问题，从而严格地回答可达性问题，这是信息物理系统形式化验证的基石 。",
            "id": "4223727",
            "problem": "考虑一个具有有限个模态的离散时间分段仿射混合系统。在每个离散步长 $k \\in \\{0,1,\\dots,K-1\\}$，恰好有一个模态处于活动状态。设连续状态为 $x_k \\in \\mathbb{R}^n$。对于每个模态 $q \\in \\{0,1,\\dots,Q-1\\}$，系统强制执行一个模态不变量（当模态激活时必须保持的线性守卫条件）和一个重置仿射更新。形式上，对于模态 $q$，不变量由线性不等式 $H_q x_k \\le h_q$ 给出，重置仿射更新为 $x_{k+1} = A_q x_k + b_q$。初始集由 $E x_0 \\le e$ 给出，目标集为 $G x_K \\le g$。所有不等式均按分量解释。将使用混合整数线性规划（MILP）来编码可达性问题，其中二进制变量指示每一步的活动模态，并使用大M方法（Big-M formulation）来激活或松弛约束。\n\n您的任务是编写一个完整的程序，对每个提供的测试用例，使用大M方法构建可达性问题的MILP可行性编码，并判断目标集是否能从初始集在恰好 $K$ 步内到达。由于只有线性规划（LP）求解器可用，您的程序必须通过枚举所有序列 $(q_0,q_1,\\dots,q_{K-1}) \\in \\{0,\\dots,Q-1\\}^K$ 来实现对模态分配的完全搜索，并且对于每个序列，通过将二进制变量 $y_{k,q}$ 替换为根据每一步所选模态的固定值 $y_{k,q} \\in \\{0,1\\}$，将MILP转换为LP。必须精确地包含大M约束，就像它们在MILP中出现的那样，以便所选大M常数的效果是显而易见的。LP应被构建为一个目标函数为零的可行性问题。如果任何序列产生一个可行的LP，则该测试用例是可达的；否则是不可达的。最终输出必须汇总每个测试用例的布尔结果。\n\n推导中使用的基本原理：\n- 当模态 $q$ 激活时，离散时间状态演化为 $x_{k+1} = A_q x_k + b_q$。\n- 当模态 $q$ 激活时，模态不变量 $H_q x_k \\le h_q$ 必须成立。\n- 大M激活：当 $y=1$ 时必须成立的约束 $C \\le d$，在 $y=0$ 时通过 $C \\le d + M(1-y)$ 进行松弛。对于仿射等式 $x_{k+1} = A_q x_k + b_q$，使用两个线性不等式 $x_{k+1} - A_q x_k - b_q \\le M(1 - y_{k,q})$ 和 $-(x_{k+1} - A_q x_k - b_q) \\le M(1 - y_{k,q})$ 进行编码，并按分量应用。不变量 $H_q x_k \\le h_q$ 编码为 $H_q x_k \\le h_q + M(1 - y_{k,q})$。给定已知的变量界限，大M必须选择得足够大，以真正松弛非活动约束。\n\nMILP中的变量和约束：\n- 连续变量 $x_0, x_1, \\dots, x_K \\in \\mathbb{R}^n$。\n- 二进制模态选择变量 $y_{k,q} \\in \\{0,1\\}$，对于每个 $k$ 满足 $\\sum_{q=0}^{Q-1} y_{k,q} = 1$。\n- 初始集约束 $E x_0 \\le e$，目标集约束 $G x_K \\le g$。\n- 对于每个步长 $k$ 和模态 $q$，模态不变量约束为 $H_q x_k \\le h_q + M(1 - y_{k,q})$。\n- 对于每个步长 $k$ 和模态 $q$，以及每个维度 $i \\in \\{1,\\dots,n\\}$ 的动力学约束为：\n  $x_{k+1,i} - (A_q x_k)_i - b_{q,i} \\le M(1 - y_{k,q})$ 和 $-(x_{k+1,i} - (A_q x_k)_i - b_{q,i}) \\le M(1 - y_{k,q})$。\n- 变量界限必须是有限的，以使大M有意义。\n\n程序要求：\n- 实现所有模态序列 $(q_0,\\dots,q_{K-1})$ 的枚举。\n- 对每个序列，固定 $y_{k,q}$ 并构建包含所有模态和步长的大M约束的LP。\n- 使用LP求解器解决LP可行性问题，并记录是否可行。\n- 如果任何序列对该测试用例是可行的，则报告可达性为真。\n- 不涉及物理单位。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表（例如，“[True,False,True]”），按顺序对应各个测试用例的结果。\n\n测试套件：\n使用以下三个测试用例，它们共同探测一个一般情况、一个大M敏感性边缘情况和一个不可达边界情况。\n\n测试用例1和测试用例2的通用系统组件：\n- 维度 $n = 2$，模态数 $Q = 2$。\n- 时间范围 $K = 3$。\n- 模态 $0$（水平移动）：\n  $A_0 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，\n  $b_0 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$，\n  不变量 $H_0 x \\le h_0$，其中\n  $H_0 = \\begin{bmatrix}0  1 \\\\ 0  -1\\end{bmatrix}$，\n  $h_0 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$，\n  编码了 $-1 \\le y \\le 1$。\n- 模态 $1$（垂直移动）：\n  $A_1 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，\n  $b_1 = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$，\n  不变量 $H_1 x \\le h_1$，其中\n  $H_1 = \\begin{bmatrix}1  0 \\\\ -1  0\\end{bmatrix}$，\n  $h_1 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$，\n  编码了 $-1 \\le x \\le 1$。\n- 初始集 $E x_0 \\le e$，其中\n  $E = \\begin{bmatrix}1  0 \\\\ 0  1 \\\\ -1  0 \\\\ 0  -1\\end{bmatrix}$，\n  $e = \\begin{bmatrix}0.5 \\\\ 0.5 \\\\ 0.5 \\\\ 0.5\\end{bmatrix}$，\n  编码了 $x_0 \\in [-0.5,0.5]^2$。\n- 目标集 $G x_3 \\le g$，其中\n  $G = \\begin{bmatrix}-1  -1\\end{bmatrix}$，\n  $g = \\begin{bmatrix}-3\\end{bmatrix}$，\n  编码了 $x_3 + y_3 \\ge 3$。\n- 每个 $x_k$ 的每个分量的变量界限：下界-10，上界10。\n\n测试用例 1：\n- 大M常数 $M = 100$（足够大）。\n预期逻辑行为：由于适当的模态排序，目标可达，且大M充分松弛了非活动约束。\n\n测试用例 2：\n- 大M常数 $M = 0.2$（故意设置得太小）。\n预期逻辑行为：在此MILP编码下不可达，因为非活动模态的约束未被充分松弛，即使在正确松弛下存在路径，也会产生错误的不可行性。\n\n测试用例 3：\n- 与上述相同的模态和不变量。\n- 时间范围 $K = 2$。\n- 大M常数 $M = 100$。\n- 初始集 $E x_0 \\le e$ 同上。\n- 目标集 $G x_2 \\le g$，其中\n  $G = \\begin{bmatrix}-1  -1\\end{bmatrix}$，\n  $g = \\begin{bmatrix}-4\\end{bmatrix}$，\n  编码了 $x_2 + y_2 \\ge 4$。\n- 变量界限：下界-10，上界10。\n预期逻辑行为：不可达，因为时间范围不足以从有界的初始集在两步内累积到所需的总和。\n\n您的程序必须实现上述要求，并生成一行“[result1,result2,result3]”，其中每个结果是相应测试用例的布尔值。",
            "solution": "在尝试解决方案之前，对问题陈述进行验证。\n\n**第1步：提取已知条件**\n\n- **系统类型**：具有有限个模态的离散时间分段仿射（PWA）混合系统。\n- **状态与时间**：离散时间步长 $k \\in \\{0, 1, \\dots, K-1\\}$ 时的连续状态 $x_k \\in \\mathbb{R}^n$。\n- **模态**：$q \\in \\{0, 1, \\dots, Q-1\\}$。\n- **模态特定定义（针对模态 $q$）**：\n    - **不变量**：$H_q x_k \\le h_q$。\n    - **动力学**：$x_{k+1} = A_q x_k + b_q$。\n- **集合定义**：\n    - **初始集**：$E x_0 \\le e$。\n    - **目标集**：$G x_K \\le g$。\n- **方法论**：使用混合整数线性规划（MILP）公式进行可达性分析，然后通过枚举所有模态序列并解决相应的线性规划（LP）可行性问题来求解。\n- **MILP 编码（大M方法）**：\n    - **二进制变量**：$y_{k,q} \\in \\{0, 1\\}$，对于每个步长 $k$，满足 $\\sum_{q=0}^{Q-1} y_{k,q} = 1$。\n    - **不变量约束**：$H_q x_k \\le h_q + M(1 - y_{k,q})$。\n    - **动力学约束**：对于每个维度 $i \\in \\{1, \\dots, n\\}$，\n        $x_{k+1,i} - (A_q x_k)_i - b_{q,i} \\le M(1 - y_{k,q})$\n        和 $-(x_{k+1,i} - (A_q x_k)_i - b_{q,i}) \\le M(1 - y_{k,q})$。\n- **变量界限**：状态变量有界。\n- **任务**：对每个测试用例，通过枚举所有 $Q^K$ 个模态序列，为每个序列构建一个LP并检查其可行性，来确定目标集是否在 $K$ 步内可达。\n\n**测试用例1和2的通用数据**：\n- $n = 2$, $Q = 2$, $K = 3$。\n- 模态 0：$A_0 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$, $b_0 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$, 不变量 $H_0 = \\begin{bmatrix}0  1 \\\\ 0  -1\\end{bmatrix}$, $h_0 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$ ($-1 \\le x_{k,2} \\le 1$)。\n- 模态 1：$A_1 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$, $b_1 = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$, 不变量 $H_1 = \\begin{bmatrix}1  0 \\\\ -1  0\\end{bmatrix}$, $h_1 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$ ($-1 \\le x_{k,1} \\le 1$)。\n- 初始集：$E = \\begin{bmatrix}1  0 \\\\ 0  1 \\\\ -1  0 \\\\ 0  -1\\end{bmatrix}$, $e = \\begin{bmatrix}0.5 \\\\ 0.5 \\\\ 0.5 \\\\ 0.5\\end{bmatrix}$。\n- 目标集：$G = \\begin{bmatrix}-1  -1\\end{bmatrix}$, $g = \\begin{bmatrix}-3\\end{bmatrix}$。\n- 界限：所有状态分量均为 $[-10, 10]$。\n- **测试用例 1 特定**：$M = 100$。\n- **测试用例 2 特定**：$M = 0.2$。\n\n**测试用例 3 数据**：\n- $n = 2$, $Q = 2$, $K = 2$, $M = 100$。\n- 模态、不变量、初始集和界限同上。\n- 目标集：$G = \\begin{bmatrix}-1  -1\\end{bmatrix}$, $g = \\begin{bmatrix}-4\\end{bmatrix}$。\n\n**第2步：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n\n1.  **科学依据**：该问题在混合系统和控制理论领域有充分的理论基础，这是信息物理系统的一个子学科。通过MILP对分段仿射系统进行可达性分析是一种标准且有据可查的技术。其公式在数学上是严谨的。\n2.  **适定性**：该问题是适定的。每个测试用例所需的所有参数、矩阵和常数都已明确提供。目标清晰：确定布尔可达性。规定的方法，即对模态序列进行穷举枚举，保证了确定性的结果（真或假）。\n3.  **客观性**：该问题以精确、形式化的数学语言陈述，没有主观性或歧义。\n\n该问题的前提没有表现出任何科学上不健全、不完整、矛盾或不可行等缺陷。这是混合系统计算建模中的一个标准的、非平凡的练习。\n\n**第3步：结论与行动**\n该问题是 **有效的**。将开发一个解决方案。\n\n**基于原理的解决方案设计**\n\n问题的核心是确定一个离散时间PWA系统的目标集的可达性。系统的演化由一系列活动模态 $(q_0, q_1, \\dots, q_{K-1})$ 控制。由于禁止使用MILP求解器，任务简化为对所有可能的模态序列空间进行穷举搜索，其大小为 $Q^K$。对于每个候选序列，我们必须检查是否存在一个有效的状态轨迹，该轨迹从初始集开始，到目标集结束。这个检查被构建为一个线性规划（LP）可行性问题。\n\n设一个特定的模态序列表示为 $(\\hat{q}_0, \\hat{q}_1, \\dots, \\hat{q}_{K-1})$。我们需要找出是否存在一个状态轨迹 $(x_0, x_1, \\dots, x_K)$ 对这个序列满足所有约束。LP的决策变量是这些状态向量的分量，连接成一个单一的向量 $z \\in \\mathbb{R}^{n(K+1)}$，其中 $z = [x_0^T, x_1^T, \\dots, x_K^T]^T$。\n\n该LP是一个可行性问题，因此目标函数为空：最小化 $c^T z$，其中 $c = \\mathbf{0}$。解决方案完全在于满足一组线性不等式约束，我们将其表述为标准LP形式 $A_{ub} z \\le b_{ub}$。\n\n对于一个固定的模态序列，约束如下：\n\n1.  **变量界限**：每个状态向量 $x_k$ 的每个分量必须在给定的界限内。对于任何 $k \\in \\{0, \\dots, K\\}$ 和 $i \\in \\{1, \\dots, n\\}$，$x_{k,i} \\in [-10, 10]$。这些是对 $z$ 元素的箱形约束。\n\n2.  **初始集**：初始状态 $x_0$ 必须属于由 $E x_0 \\le e$ 定义的初始集。这些约束应用于 $z$ 的前 $n$ 个元素。\n\n3.  **目标集**：最终状态 $x_K$ 必须属于由 $G x_K \\le g$ 定义的目标集。这些约束应用于 $z$ 的最后 $n$ 个元素。\n\n4.  **混合动力学和不变量**：在每个时间步长 $k \\in \\{0, \\dots, K-1\\}$，系统的演化受到*所有*可能模态 $q \\in \\{0, \\dots, Q-1\\}$ 的动力学和不变量的约束，这些约束使用大M方法被激活或松弛。对于我们固定的序列，二进制MILP变量 $y_{k,q}$ 被一个常数替换：如果 $q = \\hat{q}_k$（步长 $k$ 的活动模态），则 $y_{k,q}=1$，否则 $y_{k,q}=0$。因此，项 $M(1 - y_{k,q})$ 对活动模态计算为 $0$，对所有非活动模态计算为 $M$。\n\n对于每个步长 $k \\in \\{0, \\dots, K-1\\}$ 和每个模态 $q \\in \\{0, \\dots, Q-1\\}$，我们添加以下约束。设 $m_{k,q} = M(1 - \\delta_{q, \\hat{q}_k})$，其中 $\\delta$ 是克罗内克δ函数。\n\n-   **不变量约束**：条件 $H_q x_k \\le h_q$ 必须对活动模态强制执行，并对非活动模态松弛。这被编码为：\n    $$H_q x_k \\le h_q + m_{k,q} \\cdot \\mathbf{1}$$\n    其中 $\\mathbf{1}$ 是一个适当维度的全1向量。这组不等式约束了 $z$ 中对应于 $x_k$ 的变量块。\n\n-   **动力学约束**：仿射更新 $x_{k+1} = A_q x_k + b_q$ 被编码为两个不等式。对于活动模态，它们强制等式成立；对于非活动模态，它们被松弛：\n    $$x_{k+1} - A_q x_k \\le b_q + m_{k,q} \\cdot \\mathbf{1}$$\n    $$-x_{k+1} + A_q x_k \\le -b_q + m_{k,q} \\cdot \\mathbf{1}$$\n    这些不等式耦合了 $z$ 中对应于 $x_k$ 和 $x_{k+1}$ 的变量。\n\n这些约束被系统地组装成一个大矩阵 $A_{ub}$ 和向量 $b_{ub}$。然后我们使用一个LP求解器（`scipy.optimize.linprog`）来检查可行性。如果求解器为 $Q^K$ 个模态序列中的任何一个找到了可行解，我们断定目标集是可达的，该测试用例的结果为 `True`。如果所有序列都导致不可行的LP，目标是不可达的，结果为 `False`。\n\n**测试用例分析**：\n- **测试用例 1 ($M=100$)**：目标 $x_{3,1} + x_{3,2} \\ge 3$ 是可达的。一个从 $x_0=(0,0)$ 开始，模态序列为 $(0,1,0)$ 的轨迹产生 $x_1=(1,0)$、$x_2=(1,1)$ 和 $x_3=(2,1)$，满足目标（$2+1=3$）。沿此路径的不变量均被满足。由于 $M=100$ 足够大（大于模态动力学之间可能的最大违规量，即 $1$），非活动约束被正确松弛。预期该序列将产生一个可行的LP。结果：`True`。\n\n- **测试用例 2 ($M=0.2$)**：与上述相同的轨迹在物理上是可能的。然而，使用 $M=0.2$ 的MILP编码将会失败。动力学之间的差异，例如 $(A_0 x_k + b_0) - (A_1 x_k + b_1) = b_0 - b_1 = [1, -1]^T$，其分量大小为 $1$。要松弛一个非活动约束，$M$ 必须至少这么大。由于 $M=0.2  1$，当模态0激活时，针对模态1的松弛约束将被违反，导致无论选择哪个序列，LP都不可行。结果：`False`。\n\n- **测试用例 3 ($M=100$)**：时间范围为 $K=2$。状态更新为 $x_{k+1} = x_k + v_k$，其中 $v_k$ 是 $[1,0]^T$ 或 $[0,1]^T$。两步之后，$x_2 = x_0 + v_0 + v_1$。目标是 $x_{2,1} + x_{2,2} \\ge 4$。这个和的最大值为 $(x_{0,1}+v_{0,1}+v_{1,1}) + (x_{0,2}+v_{0,2}+v_{1,2}) = (x_{0,1}+x_{0,2}) + (v_{0,1}+v_{0,2}) + (v_{1,1}+v_{1,2})$。任何 $v_k$ 的分量之和为 $1$。初始和 $x_{0,1}+x_{0,2}$ 的最大值为 $0.5+0.5=1$。因此，$x_2$ 的可能最大和为 $1 + 1 + 1 = 3$。达到一个 $\\ge 4$ 的总和在运动学上是不可能的。所有的LP都将是不可行的。结果：`False`。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single reachability test case by enumerating mode sequences.\n\n    For each sequence, it constructs and solves an LP feasibility problem.\n    \"\"\"\n    n = params['n']\n    Q = params['Q']\n    K = params['K']\n    M = params['M']\n    A_modes = params['A_modes']\n    b_modes = params['b_modes']\n    H_modes = params['H_modes']\n    h_modes = params['h_modes']\n    E = params['E']\n    e = params['e']\n    G = params['G']\n    g = params['g']\n    bounds_val = params['bounds']\n\n    # Generate all possible mode sequences of length K\n    mode_sequences = itertools.product(range(Q), repeat=K)\n    \n    # LP decision variables are the concatenated state vectors: z = [x_0, x_1, ..., x_K]\n    num_lp_vars = n * (K + 1)\n    \n    # Objective function is zero for a feasibility problem\n    c = np.zeros(num_lp_vars)\n    \n    # State variable bounds\n    bounds = [bounds_val] * num_lp_vars\n    \n    # Iterate through each possible mode sequence\n    for seq in mode_sequences:\n        A_ub_list = []\n        b_ub_list = []\n        \n        # 1. Initial set constraints: E x_0 = e\n        A_init = np.zeros((E.shape[0], num_lp_vars))\n        A_init[:, :n] = E\n        A_ub_list.append(A_init)\n        b_ub_list.append(e)\n        \n        # 2. Target set constraints: G x_K = g\n        A_target = np.zeros((G.shape[0], num_lp_vars))\n        A_target[:, n * K : n * (K + 1)] = G\n        A_ub_list.append(A_target)\n        b_ub_list.append(g)\n\n        # 3. Dynamics and Invariant constraints for each step k and each mode q\n        for k in range(K):\n            for q in range(Q):\n                is_active_mode = (q == seq[k])\n                \n                # The Big-M term is 0 for the active mode, M otherwise\n                m_val = 0.0 if is_active_mode else M\n                \n                # Invariant constraint: H_q x_k = h_q + M * (1-y_kq)\n                H_q, h_q = H_modes[q], h_modes[q]\n                num_inv_const = H_q.shape[0]\n                A_inv = np.zeros((num_inv_const, num_lp_vars))\n                A_inv[:, n * k : n * (k + 1)] = H_q\n                b_inv = h_q + m_val\n                A_ub_list.append(A_inv)\n                b_ub_list.append(b_inv)\n                \n                # Dynamics constraints encoded as two inequalities\n                A_q, b_q = A_modes[q], b_modes[q]\n                \n                # Inequality 1: x_{k+1} - A_q x_k = b_q + M * (1-y_kq)\n                A_dyn_1 = np.zeros((n, num_lp_vars))\n                A_dyn_1[:, n * (k + 1) : n * (k + 2)] = np.eye(n)\n                A_dyn_1[:, n * k : n * (k + 1)] = -A_q\n                b_dyn_1 = b_q + m_val\n                A_ub_list.append(A_dyn_1)\n                b_ub_list.append(b_dyn_1)\n                \n                # Inequality 2: -x_{k+1} + A_q x_k = -b_q + M * (1-y_kq)\n                A_dyn_2 = np.zeros((n, num_lp_vars))\n                A_dyn_2[:, n * (k + 1) : n * (k + 2)] = -np.eye(n)\n                A_dyn_2[:, n * k : n * (k + 1)] = A_q\n                b_dyn_2 = -b_q + m_val\n                A_ub_list.append(A_dyn_2)\n                b_ub_list.append(b_dyn_2)\n\n        # Consolidate all constraints into a single matrix and vector\n        A_ub = np.vstack(A_ub_list)\n        b_ub = np.concatenate(b_ub_list)\n        \n        # Solve the LP feasibility problem\n        # method='highs' is the default and recommended in recent SciPy versions\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        # A status of 0 indicates an optimal solution was found (i.e., it's feasible)\n        if res.success and res.status == 0:\n            return True # Target is reachable\n            \n    # If no feasible sequence was found after checking all\n    return False # Target is not reachable\n\ndef solve():\n    # Common system components\n    n = 2\n    Q = 2\n    \n    A0 = np.array([[1, 0], [0, 1]])\n    b0 = np.array([1, 0])\n    H0 = np.array([[0, 1], [0, -1]])\n    h0 = np.array([1, 1])\n\n    A1 = np.array([[1, 0], [0, 1]])\n    b1 = np.array([0, 1])\n    H1 = np.array([[1, 0], [-1, 0]])\n    h1 = np.array([1, 1])\n    \n    A_modes = [A0, A1]\n    b_modes = [b0, b1]\n    H_modes = [H0, H1]\n    h_modes = [h0, h1]\n\n    E = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])\n    e = np.array([0.5, 0.5, 0.5, 0.5])\n    bounds = (-10, 10)\n\n    # Test Case 1: Reachable, sufficient M\n    test_case_1 = {\n        'n': n, 'Q': Q, 'K': 3, 'M': 100.0,\n        'A_modes': A_modes, 'b_modes': b_modes,\n        'H_modes': H_modes, 'h_modes': h_modes,\n        'E': E, 'e': e,\n        'G': np.array([[-1, -1]]), 'g': np.array([-3]),\n        'bounds': bounds\n    }\n\n    # Test Case 2: Unreachable (by encoding), insufficient M\n    test_case_2 = {\n        'n': n, 'Q': Q, 'K': 3, 'M': 0.2,\n        'A_modes': A_modes, 'b_modes': b_modes,\n        'H_modes': H_modes, 'h_modes': h_modes,\n        'E': E, 'e': e,\n        'G': np.array([[-1, -1]]), 'g': np.array([-3]),\n        'bounds': bounds\n    }\n    \n    # Test Case 3: Unreachable (kinematically), sufficient M\n    test_case_3 = {\n        'n': n, 'Q': Q, 'K': 2, 'M': 100.0,\n        'A_modes': A_modes, 'b_modes': b_modes,\n        'H_modes': H_modes, 'h_modes': h_modes,\n        'E': E, 'e': e,\n        'G': np.array([[-1, -1]]), 'g': np.array([-4]),\n        'bounds': bounds\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3]\n    \n    results = [solve_case(case) for case in test_cases]\n\n    # Format output as specified: \"[True,False,True]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}