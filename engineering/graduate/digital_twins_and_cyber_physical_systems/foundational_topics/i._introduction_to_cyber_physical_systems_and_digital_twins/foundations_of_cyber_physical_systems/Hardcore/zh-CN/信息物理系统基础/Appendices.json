{
    "hands_on_practices": [
        {
            "introduction": "信息物理系统通常涉及在多个竞争任务之间协调共享资源。皮特里网 (Petri net) 作为一种强大的图形化和数学工具，能够对此类并发系统进行建模和分析。本练习  将指导你运用结构化分析方法（如 siphon 和 trap），诊断系统中可能出现的死锁——这是信息物理系统中的一种严重故障模式，并进一步设计一个监控控制器以保证系统的活性（liveness）。",
            "id": "4223669",
            "problem": "考虑一个资源共享的信息物理系统（CPS），该系统由一个Petri网（PN）建模，其中包含两个可重用资源和一组任务，这些任务获取资源的顺序是非确定性的（自由选择）。该PN的库所集合为 $P = \\{r_{A}, r_{B}, p^{s}, p^{A}, p^{B}, p^{AB}\\}$，变迁集合为 $T = \\{t_{A}^{\\text{start}}, t_{B}^{\\text{start}}, t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$。弧的定义如下，使用标准表示法，其中变迁 $t$ 的前集为 $\\bullet t \\subseteq P$，其后集为 $t \\bullet \\subseteq P$：\n- $t_{A}^{\\text{start}}$: $\\bullet t_{A}^{\\text{start}} = \\{p^{s}, r_{A}\\}$ 且 $t_{A}^{\\text{start}} \\bullet = \\{p^{A}\\}$，\n- $t_{B}^{\\text{start}}$: $\\bullet t_{B}^{\\text{start}} = \\{p^{s}, r_{B}\\}$ 且 $t_{B}^{\\text{start}} \\bullet = \\{p^{B}\\}$，\n- $t_{A\\to B}$: $\\bullet t_{A\\to B} = \\{p^{A}, r_{B}\\}$ 且 $t_{A\\to B} \\bullet = \\{p^{AB}\\}$，\n- $t_{B\\to A}$: $\\bullet t_{B\\to A} = \\{p^{B}, r_{A}\\}$ 且 $t_{B\\to A} \\bullet = \\{p^{AB}\\}$，\n- $t^{\\text{rel}}$: $\\bullet t^{\\text{rel}} = \\{p^{AB}\\}$ 且 $t^{\\text{rel}} \\bullet = \\{r_{A}, r_{B}, p^{s}\\}$。\n\n初始标识为 $M_{0}(r_{A}) = c_{A}$，$M_{0}(r_{B}) = c_{B}$，$M_{0}(p^{s}) = n$，以及 $M_{0}(p^{A}) = M_{0}(p^{B}) = M_{0}(p^{AB}) = 0$，其中 $c_{A}, c_{B}, n \\in \\mathbb{N}$ 且 $c_{A} \\geq 1$，$c_{B} \\geq 1$，$n \\geq 1$。此PN模型模拟了 $n$ 个任务实例在系统中循环，每个实例非确定性地开始，或者获取资源A，或者获取资源B，然后获取另一个资源，最后释放两个资源并返回就绪状态。\n\n使用以下基本定义。\n- 库所的子集 $S \\subseteq P$ 是一个虹吸，如果每个有输出弧指向 $S$ 中库所的变迁也必有输入弧来自 $S$ 中的库所，等价地，$\\bullet S \\subseteq S \\bullet$，其中 $\\bullet S = \\{t \\in T \\mid t \\bullet \\cap S \\neq \\emptyset\\}$ 且 $S \\bullet = \\{t \\in T \\mid \\bullet t \\cap S \\neq \\emptyset\\}$。\n- 库所的子集 $U \\subseteq P$ 是一个陷阱，如果每个有输入弧来自 $U$ 中库所的变迁也必有输出弧指向 $U$ 中的库所，等价地，$U \\bullet \\subseteq \\bullet U$，其中 $U \\bullet = \\{t \\in T \\mid \\bullet t \\cap U \\neq \\emptyset\\}$ 且 $\\bullet U = \\{t \\in T \\mid t \\bullet \\cap U \\neq \\emptyset\\}$。\n- 一个标识 $M$ 是活性的，如果从 $M$ 出发，在某个延续序列中 $T$ 中的每个变迁都至少可以被启用一次（无死锁）。避免死锁的一个经典必要条件是，在任何可达执行路径上，没有虹吸会变为空标识（没有令牌）。\n\n任务：\n1. 为此PN识别一个虹吸 $S$，其空状态将导致死锁。使用形式化定义证明 $S$ 是一个虹吸，并通俗地解释为什么其空状态会阻止任何变迁向 $S$ 返回令牌。\n2. 为此PN识别一个在初始标识 $M_{0}$ 下有标识的陷阱 $U$，并论证 $U \\subseteq S$ 是否成立；讨论在 $M_{0}$ 下这对死锁风险的影响。\n3. 提出一个与数字孪生监控控制一致的非侵入式监控控制操作：添加一个单一的控制库所 $u$，其弧为 $\\bullet t_{A}^{\\text{start}} \\gets u$、$\\bullet t_{B}^{\\text{start}} \\gets u$ 和 $t^{\\text{rel}} \\bullet \\to u$，使得每个启动变迁从 $u$ 消耗一个令牌，每个释放变迁向 $u$ 产生一个令牌。设控制库所的初始标识为 $M_{0}(u) = K$，其中 $K \\in \\mathbb{N}$。基于第一性原理和库所级令牌平衡，推导 $K$ 作为 $c_{A}$ 和 $c_{B}$ 函数的最小值，该值能保证任务1中识别的虹吸在任何可达执行路径上永不为空标识，从而强制实现相对于虹吸空置导致的死锁的活性。将最终答案表示为仅含 $c_{A}$ 和 $c_{B}$ 的单一闭式表达式。无需四舍五入。",
            "solution": "用户希望我分析一个资源共享信息物理系统的Petri网模型。\n\n**问题验证**\n\n**第一步：提取给定条件**\n-   Petri网（PN）结构：\n    -   库所集合：$P = \\{r_{A}, r_{B}, p^{s}, p^{A}, p^{B}, p^{AB}\\}$\n    -   变迁集合：$T = \\{t_{A}^{\\text{start}}, t_{B}^{\\text{start}}, t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$\n    -   弧（前集 $\\bullet t$ 和后集 $t \\bullet$）：\n        -   $\\bullet t_{A}^{\\text{start}} = \\{p^{s}, r_{A}\\}$, $t_{A}^{\\text{start}} \\bullet = \\{p^{A}\\}$\n        -   $\\bullet t_{B}^{\\text{start}} = \\{p^{s}, r_{B}\\}$, $t_{B}^{\\text{start}} \\bullet = \\{p^{B}\\}$\n        -   $\\bullet t_{A\\to B} = \\{p^{A}, r_{B}\\}$, $t_{A\\to B} \\bullet = \\{p^{AB}\\}$\n        -   $\\bullet t_{B\\to A} = \\{p^{B}, r_{A}\\}$, $t_{B\\to A} \\bullet = \\{p^{AB}\\}$\n        -   $\\bullet t^{\\text{rel}} = \\{p^{AB}\\}$, $t^{\\text{rel}} \\bullet = \\{r_{A}, r_{B}, p^{s}\\}$\n-   初始标识（$M_{0}$）：\n    -   $M_{0}(r_{A}) = c_{A}$\n    -   $M_{0}(r_{B}) = c_{B}$\n    -   $M_{0}(p^{s}) = n$\n    -   $M_{0}(p^{A}) = M_{0}(p^{B}) = M_{0}(p^{AB}) = 0$\n    -   约束：$c_{A}, c_{B}, n \\in \\mathbb{N}$ 且 $c_{A} \\geq 1$, $c_{B} \\geq 1$, $n \\geq 1$。\n-   定义：\n    -   虹吸 $S \\subseteq P$: $\\bullet S \\subseteq S \\bullet$，其中 $\\bullet S = \\{t \\in T \\mid t \\bullet \\cap S \\neq \\emptyset\\}$ 且 $S \\bullet = \\{t \\in T \\mid \\bullet t \\cap S \\neq \\emptyset\\}$。\n    -   陷阱 $U \\subseteq P$: $U \\bullet \\subseteq \\bullet U$，其中 $U \\bullet = \\{t \\in T \\mid \\bullet t \\cap U \\neq \\emptyset\\}$ 且 $\\bullet U = \\{t \\in T \\mid t \\bullet \\cap U \\neq \\emptyset\\}$。\n    -   活性：一个标识是活性的，如果每个变迁最终都能被启用。\n-   任务：\n    1.  识别一个与死锁相关的虹吸 $S$，证明它是一个虹吸，并解释其空状态的后果。\n    2.  识别一个初始有标识的陷阱 $U$，检查是否 $U \\subseteq S$，并讨论其影响。\n    3.  添加一个控制库所 $u$ 及其弧 $\\bullet t_{A}^{\\text{start}} \\gets u$、$\\bullet t_{B}^{\\text{start}} \\gets u$、$t^{\\text{rel}} \\bullet \\to u$，其初始标识为 $M_{0}(u) = K$。推导 $K$ 的最小值（以 $c_{A}$ 和 $c_{B}$ 表示），以保证任务1中的虹吸永不为空。\n\n**第二步：使用提取的给定条件进行验证**\n-   **科学依据：** 该问题牢固地植根于Petri网理论，这是一种用于建模和分析并发系统的标准形式化方法，尤其适用于计算机科学和信息物理系统等领域的资源分配和死锁分析。虹吸、陷阱、活性和监控控制等概念是该理论的核心。\n-   **问题良定：** Petri网的结构、初始状态和所有相关定义都完整且明确地给出。任务具体、逻辑关联，并且可以使用所提供的信息和标准的Petri网分析技术来解决。\n-   **客观性：** 该问题使用形式化的数学语言和既定的科学术语陈述，没有任何主观或含糊的内容。\n\n**第三步：结论与行动**\n该问题是有效的。它具有科学性、良定性和客观性。我将继续进行解答。\n\n**解题过程**\n\n**任务1：虹吸的识别与证明**\n\n该系统中的死锁对应于任务等待被其他等待任务所持有的资源的状态。这暗示了循环等待，通常与一个未标识的虹吸有关。在此过程中，一组关键的库所包括资源本身（$r_A, r_B$）以及任务在释放资源前持有两种资源的库所（$p^{AB}$）。我们提议集合 $S = \\{r_{A}, r_{B}, p^{AB}\\}$ 作为候选虹吸。\n\n为了证明 $S$ 是一个虹吸，我们必须证明 $\\bullet S \\subseteq S \\bullet$。我们首先计算 $S$ 的输入变迁集合 $\\bullet S$ 和输出变迁集合 $S \\bullet$。\n\n$S$ 的输入变迁集合 $\\bullet S = \\{t \\in T \\mid t \\bullet \\cap S \\neq \\emptyset\\}$，包含所有向 $S$ 中任何库所添加令牌的变迁。\n-   $t_{A}^{\\text{start}} \\bullet = \\{p^{A}\\}$。$\\{p^{A}\\} \\cap S = \\emptyset$。\n-   $t_{B}^{\\text{start}} \\bullet = \\{p^{B}\\}$。$\\{p^{B}\\} \\cap S = \\emptyset$。\n-   $t_{A\\to B} \\bullet = \\{p^{AB}\\}$。$\\{p^{AB}\\} \\cap S = \\{p^{AB}\\} \\neq \\emptyset$，因此 $t_{A\\to B} \\in \\bullet S$。\n-   $t_{B\\to A} \\bullet = \\{p^{AB}\\}$。$\\{p^{AB}\\} \\cap S = \\{p^{AB}\\} \\neq \\emptyset$，因此 $t_{B\\to A} \\in \\bullet S$。\n-   $t^{\\text{rel}} \\bullet = \\{r_{A}, r_{B}, p^{s}\\}$。$\\{r_{A}, r_{B}, p^{s}\\} \\cap S = \\{r_{A}, r_{B}\\} \\neq \\emptyset$，因此 $t^{\\text{rel}} \\in \\bullet S$。\n因此，输入变迁集合为 $\\bullet S = \\{t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$。\n\n$S$ 的输出变迁集合 $S \\bullet = \\{t \\in T \\mid \\bullet t \\cap S \\neq \\emptyset\\}$，包含所有从 $S$ 中任何库所消耗令牌的变迁。\n-   $\\bullet t_{A}^{\\text{start}} = \\{p^{s}, r_{A}\\}$。$\\{p^{s}, r_{A}\\} \\cap S = \\{r_{A}\\} \\neq \\emptyset$，因此 $t_{A}^{\\text{start}} \\in S \\bullet$。\n-   $\\bullet t_{B}^{\\text{start}} = \\{p^{s}, r_{B}\\}$。$\\{p^{s}, r_{B}\\} \\cap S = \\{r_{B}\\} \\neq \\emptyset$，因此 $t_{B}^{\\text{start}} \\in S \\bullet$。\n-   $\\bullet t_{A\\to B} = \\{p^{A}, r_{B}\\}$。$\\{p^{A}, r_{B}\\} \\cap S = \\{r_{B}\\} \\neq \\emptyset$，因此 $t_{A\\to B} \\in S \\bullet$。\n-   $\\bullet t_{B\\to A} = \\{p^{B}, r_{A}\\}$。$\\{p^{B}, r_{A}\\} \\cap S = \\{r_{A}\\} \\neq \\emptyset$，因此 $t_{B\\to A} \\in S \\bullet$。\n-   $\\bullet t^{\\text{rel}} = \\{p^{AB}\\}$。$\\{p^{AB}\\} \\cap S = \\{p^{AB}\\} \\neq \\emptyset$，因此 $t^{\\text{rel}} \\in S \\bullet$。\n因此，输出变迁集合为 $S \\bullet = \\{t_{A}^{\\text{start}}, t_{B}^{\\text{start}}, t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$。\n\n比较这两个集合，我们看到 $\\bullet S = \\{t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$ 是 $S \\bullet = \\{t_{A}^{\\text{start}}, t_{B}^{\\text{start}}, t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$ 的一个子集。因此，$\\bullet S \\subseteq S \\bullet$，且 $S = \\{r_{A}, r_{B}, p^{AB}\\}$ 是一个虹吸。\n\n如果这个虹吸 $S$ 变为空（未标识），意味着 $M(r_{A})=0$，$M(r_{B})=0$，且 $M(p^{AB})=0$。为了使虹吸再次被标识，必须有至少一个其输入变迁 $t \\in \\bullet S$ 发生。$\\bullet S$ 中的变迁是 $t_{A\\to B}$，$t_{B\\to A}$ 和 $t^{\\text{rel}}$。\n-   发生 $t_{A\\to B}$ 需要 $r_{B}$ 中有一个令牌。由于 $M(r_{B})=0$，这是不可能的。\n-   发生 $t_{B\\to A}$ 需要 $r_{A}$ 中有一个令牌。由于 $M(r_{A})=0$，这是不可能的。\n-   发生 $t^{\\text{rel}}$ 需要 $p^{AB}$ 中有一个令牌。由于 $M(p^{AB})=0$，这是不可能的。\n由于 $S$ 的所有输入变迁都无法发生，一个空的虹吸 $S$ 将永远保持为空。在这种状态下，不仅这三个变迁被禁用，所有其他变迁也同样被禁用：$t_{A}^{\\text{start}}$ 需要 $r_{A}$ 中有令牌，$t_{B}^{\\text{start}}$ 需要 $r_{B}$ 中有令牌。因此，$S$ 的空状态意味着系统的完全死锁。\n\n**任务2：陷阱的识别与分析**\n\n陷阱是一个一旦被标识就永远不会变空的库所集合。网的P-不变量通常对应于陷阱。资源A的守恒由不变量 $M(r_{A}) + M(p^{A}) + M(p^{AB}) = c_{A}$ 表示。我们来测试对应的库所集合 $U = \\{r_{A}, p^{A}, p^{AB}\\}$ 是否为一个陷阱。\n\n为了证明 $U$ 是一个陷阱，我们必须证明 $U \\bullet \\subseteq \\bullet U$。\n$U$ 的输出变迁集合 $U \\bullet = \\{t \\in T \\mid \\bullet t \\cap U \\neq \\emptyset\\}$：\n-   $\\bullet t_{A}^{\\text{start}} = \\{p^{s}, r_{A}\\}$。$\\{p^{s}, r_{A}\\} \\cap U = \\{r_{A}\\} \\neq \\emptyset$，因此 $t_{A}^{\\text{start}} \\in U \\bullet$。\n-   $\\bullet t_{B}^{\\text{start}} = \\{p^{s}, r_{B}\\}$。交集为空。\n-   $\\bullet t_{A\\to B} = \\{p^{A}, r_{B}\\}$。$\\{p^{A}, r_{B}\\} \\cap U = \\{p^{A}\\} \\neq \\emptyset$，因此 $t_{A\\to B} \\in U \\bullet$。\n-   $\\bullet t_{B\\to A} = \\{p^{B}, r_{A}\\}$。$\\{p^{B}, r_{A}\\} \\cap U = \\{r_{A}\\} \\neq \\emptyset$，因此 $t_{B\\to A} \\in U \\bullet$。\n-   $\\bullet t^{\\text{rel}} = \\{p^{AB}\\}$。$\\{p^{AB}\\} \\cap U = \\{p^{AB}\\} \\neq \\emptyset$，因此 $t^{\\text{rel}} \\in U \\bullet$。\n因此，$U \\bullet = \\{t_{A}^{\\text{start}}, t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$。\n\n$U$ 的输入变迁集合 $\\bullet U = \\{t \\in T \\mid t \\bullet \\cap U \\neq \\emptyset\\}$：\n-   $t_{A}^{\\text{start}} \\bullet = \\{p^{A}\\}$。$\\{p^{A}\\} \\cap U = \\{p^{A}\\} \\neq \\emptyset$，因此 $t_{A}^{\\text{start}} \\in \\bullet U$。\n-   $t_{B}^{\\text{start}} \\bullet = \\{p^{B}\\}$。交集为空。\n-   $t_{A\\to B} \\bullet = \\{p^{AB}\\}$。$\\{p^{AB}\\} \\cap U = \\{p^{AB}\\} \\neq \\emptyset$，因此 $t_{A\\to B} \\in \\bullet U$。\n-   $t_{B\\to A} \\bullet = \\{p^{AB}\\}$。$\\{p^{AB}\\} \\cap U = \\{p^{AB}\\} \\neq \\emptyset$，因此 $t_{B\\to A} \\in \\bullet U$。\n-   $t^{\\text{rel}} \\bullet = \\{r_{A}, r_{B}, p^{s}\\}$。$\\{r_{A}, r_{B}, p^{s}\\} \\cap U = \\{r_{A}\\} \\neq \\emptyset$，因此 $t^{\\text{rel}} \\in \\bullet U$。\n因此，$\\bullet U = \\{t_{A}^{\\text{start}}, t_{A\\to B}, t_{B\\to A}, t^{\\text{rel}}\\}$。\n\n由于 $U \\bullet = \\bullet U$，条件 $U \\bullet \\subseteq \\bullet U$ 成立。因此，$U = \\{r_{A}, p^{A}, p^{AB}\\}$ 是一个陷阱。\n此陷阱的初始标识为 $M_{0}(U) = M_{0}(r_{A}) + M_{0}(p^{A}) + M_{0}(p^{AB}) = c_{A} + 0 + 0 = c_{A}$。由于 $c_{A} \\geq 1$，陷阱 $U$ 在初始时是被标识的。\n\n现在我们检查是否 $U \\subseteq S$。\n$U = \\{r_{A}, p^{A}, p^{AB}\\}$\n$S = \\{r_{A}, r_{B}, p^{AB}\\}$\n包含关系 $U \\subseteq S$ 不成立，因为 $p^{A} \\in U$ 但 $p^{A} \\notin S$。\n\nPetri网理论中的一个基本结论是，包含一个初始被标识的陷阱的虹吸永远不会变空。在我们的案例中，危险的虹吸 $S$ 并不包含初始被标识的陷阱 $U$。这种结构上的保证（虹吸内部有一个初始被标识的陷阱）的缺失，恰恰是虹吸 $S$ *可能* 变空并导致死锁的原因。\n\n**任务3：为保证活性的监控控制**\n\n监控控制操作增加了一个控制库所 $u$，其弧线从 $u$ 指向 $t_{A}^{\\text{start}}$ 和 $t_{B}^{\\text{start}}$，以及从 $t^{\\text{rel}}$ 指向 $u$。初始标识为 $M_0(u)=K$。这个控制结构创建了一个新的库所不变量。对于每个变迁，新库所 $u$ 的标识变化为：`[-1, -1, 0, 0, 1]`。库所 $p^A$、$p^B$、$p^{AB}$ 和 $u$ 的标识之和是不变的。我们来验证一下：\n- 对于 $t_{A}^{\\text{start}}$: $p^A$ 中+1， $u$ 中-1。和为0。\n- 对于 $t_{B}^{\\text{start}}$: $p^B$ 中+1， $u$ 中-1。和为0。\n- 对于 $t_{A\\to B}$: $p^A$ 中-1， $p^{AB}$ 中+1。和为0。\n- 对于 $t_{B\\to A}$: $p^B$ 中-1， $p^{AB}$ 中+1。和为0。\n- 对于 $t^{\\text{rel}}$: $p^{AB}$ 中-1， $u$ 中+1。和为0。\n\n因此，对于任何可达标识 $M$，以下P-不变量成立：\n$M(p^{A}) + M(p^{B}) + M(p^{AB}) + M(u) = \\text{常数}$。\n该常数由初始标识 $M_0$ 决定：\n$M_{0}(p^{A}) + M_{0}(p^{B}) + M_{0}(p^{AB}) + M_{0}(u) = 0 + 0 + 0 + K = K$。\n所以，对于任何可达标识 $M$：$M(p^{A}) + M(p^{B}) + M(p^{AB}) + M(u) = K$。\n\n问题在于找到 $K$ 的值，以保证虹吸 $S = \\{r_A, r_B, p^{AB}\\}$ 永远不会变为空标识，即对于所有可达的 $M$，都有 $M(S) = M(r_{A}) + M(r_{B}) + M(p^{AB}) > 0$。\n\n我们使用系统已有的P-不变量：\n1. $M(r_{A}) + M(p^{A}) + M(p^{AB}) = c_{A} \\implies M(r_{A}) = c_{A} - M(p^{A}) - M(p^{AB})$\n2. $M(r_{B}) + M(p^{B}) + M(p^{AB}) = c_{B} \\implies M(r_{B}) = c_{B} - M(p^{B}) - M(p^{AB})$\n\n我们将这些代入虹吸 $S$ 的标识表达式中：\n$M(S) = (c_{A} - M(p^{A}) - M(p^{AB})) + (c_{B} - M(p^{B}) - M(p^{AB})) + M(p^{AB})$\n$M(S) = c_{A} + c_{B} - (M(p^{A}) + M(p^{B}) + M(p^{AB}))$\n\n我们将系统中当前活跃的任务数量（即那些已获取至少一个资源的任务）表示为 $N_{\\text{active}}(M) = M(p^{A}) + M(p^{B}) + M(p^{AB})$。虹吸标识的表达式变为：\n$M(S) = c_{A} + c_{B} - N_{\\text{active}}(M)$。\n\n为保证 $M(S) > 0$，我们必须确保对于任何可达标识 $M$，都有 $c_{A} + c_{B} - N_{\\text{active}}(M) > 0$。这等价于条件：\n$N_{\\text{active}}(M) < c_{A} + c_{B}$。\n\n控制库所 $u$ 对 $N_{\\text{active}}$ 施加了一个约束。根据新的不变量 $N_{\\text{active}}(M) + M(u) = K$，并且由于任何库所的标识必须为非负数（$M(u) \\geq 0$），我们得到：\n$N_{\\text{active}}(M) \\leq K$。\n\n为了满足活性条件 $N_{\\text{active}}(M) < c_{A} + c_{B}$ 对所有可达标识成立，我们必须选择 $K$，使得 $N_{\\text{active}}(M)$ 的上界严格小于 $c_{A} + c_{B}$。因此，我们必须设置 $K < c_{A} + c_{B}$。\n\n问题描述了一个“非侵入式”监控器，并要求 $K$ 的单个值。在监控控制理论中，非侵入式或最大许可监控器是指在强制执行所需属性的同时，尽可能少地限制系统行为的监控器。并发任务的数量受 $K$ 的限制。为了尽可能地非侵入，我们应该允许与活性相符的最大任务数。这对应于选择满足不等式 $K < c_{A} + c_{B}$ 的最大整数值 $K$。尽管问题要求“K的最小值”，但在设计最不严格的控制器背景下，这里的“最小”指的是最小的约束强度，即 $K$ 的最大值。\n\n满足 $K < c_{A} + c_{B}$ 的最大整数 $K$ 是 $K = c_{A} + c_{B} - 1$。\n这个选择保证了 $N_{\\text{active}}(M) \\leq c_{A} + c_{B} - 1$，从而确保 $N_{\\text{active}}(M) < c_{A} + c_{B}$。这反过来保证了 $M(S) = c_{A} + c_{B} - N_{\\text{active}}(M) \\ge c_{A} + c_{B} - (c_{A} + c_{B} - 1) = 1$。虹吸的标识始终至少为1，因此它永远不会变空。\n这个值也是必要的：如果 $K \\geq c_{A} + c_{B}$，那么就有可能（当任务数 $n \\geq c_{A} + c_{B}$ 时）达到一个死锁状态，其中 $N_{\\text{active}}(M) = c_{A} + c_{B}$，导致 $M(S) = 0$。\n\n因此，所需的 $K$ 值为 $c_{A} + c_{B} - 1$。",
            "answer": "$$\n\\boxed{c_{A} + c_{B} - 1}\n$$"
        },
        {
            "introduction": "在分析离散事件之后，我们面临着验证混合系统安全性的挑战，在混合系统中，连续动态与离散模式相互作用。确保系统永远不会进入不安全状态是信息物理系统安全工程的基石。本练习  展示了一种基础技术：将可达性问题编码为混合整数线性规划（MILP），从而实现对系统的形式化验证。你将学习如何将混合系统动态和约束转化为一个数学规划问题，并体会这种强大验证方法在计算上的权衡，特别是“大M”常数（Big-M）的关键作用。",
            "id": "4223727",
            "problem": "考虑一个具有有限模式集的离散时间分段仿射混合系统。在每个离散步骤 $k \\in \\{0,1,\\dots,K-1\\}$，恰好有一个模式是激活的。设连续状态为 $x_k \\in \\mathbb{R}^n$。对于每个模式 $q \\in \\{0,1,\\dots,Q-1\\}$，系统强制执行一个模式不变量（模式激活期间必须保持的线性守卫）和一个重置仿射更新。形式上，对于模式 $q$，不变量由线性不等式 $H_q x_k \\le h_q$ 给出，重置仿射更新为 $x_{k+1} = A_q x_k + b_q$。初始集由 $E x_0 \\le e$ 给出，目标集为 $G x_K \\le g$。所有不等式都按分量解释。将使用混合整数线性规划（MILP）来编码可达性，通过二元变量指示每一步激活的模式，并使用大M方法来激活或松弛约束。\n\n您的任务是编写一个完整的程序，为每个提供的测试用例，构建可达性的MILP可行性编码（使用大M方法），并判断目标集是否能在恰好 $K$ 步内从初始集到达。因为只有线性规划（LP）求解器可用，您的程序必须通过枚举所有序列 $(q_0,q_1,\\dots,q_{K-1}) \\in \\{0,\\dots,Q-1\\}^K$ 来实现对模式分配的完整搜索，并且对于每个序列，通过将二元变量 $y_{k,q}$ 替换为其根据每步选择的模式的固定值 $y_{k,q} \\in \\{0,1\\}$，将MILP转换为LP。大M约束必须与它们在MILP中出现的形式完全一样，以便所选大M常数的效果显而易见。LP应被构建为一个零目标的可行性问题。如果任何序列产生一个可行的LP，则该测试用例是可达的；否则是不可达的。最终输出必须汇总每个测试用例的布尔结果。\n\n推导中使用的基本原理：\n- 当模式 $q$ 激活时，离散时间状态演进为 $x_{k+1} = A_q x_k + b_q$。\n- 当模式 $q$ 激活时，模式不变量 $H_q x_k \\le h_q$ 必须成立。\n- 大M激活：当 $y=1$ 时必须成立的约束 $C \\le d$，在 $y=0$ 时通过 $C \\le d + M(1-y)$ 进行松弛。对于仿射等式 $x_{k+1} = A_q x_k + b_q$，使用两个线性不等式进行编码：$x_{k+1} - A_q x_k - b_q \\le M(1 - y_{k,q})$ 和 $-(x_{k+1} - A_q x_k - b_q) \\le M(1 - y_{k,q})$，按分量应用。不变量 $H_q x_k \\le h_q$ 被编码为 $H_q x_k \\le h_q + M(1 - y_{k,q})$。给定已知的变量界限，必须选择足够大的大M值，以真正松弛非激活约束。\n\nMILP中的变量和约束：\n- 连续变量 $x_0, x_1, \\dots, x_K \\in \\mathbb{R}^n$。\n- 二元模式选择变量 $y_{k,q} \\in \\{0,1\\}$，对于每个 $k$ 满足 $\\sum_{q=0}^{Q-1} y_{k,q} = 1$。\n- 初始集约束 $E x_0 \\le e$，目标集约束 $G x_K \\le g$。\n- 对每一步 $k$ 和每个模式 $q$，有模式不变量约束 $H_q x_k \\le h_q + M(1 - y_{k,q})$。\n- 对每一步 $k$ 和每个模式 $q$，有每个维度 $i \\in \\{1,\\dots,n\\}$ 的动态约束：\n  $x_{k+1,i} - (A_q x_k)_i - b_{q,i} \\le M(1 - y_{k,q})$ 和 $-(x_{k+1,i} - (A_q x_k)_i - b_{q,i}) \\le M(1 - y_{k,q})$。\n- 变量界限必须是有限的，以使大M方法有意义。\n\n程序要求：\n- 实现对所有模式序列 $(q_0,\\dots,q_{K-1})$ 的枚举。\n- 对每个序列，固定 $y_{k,q}$ 的值，并为所有模式和步骤构建包含大M约束的LP。\n- 使用LP求解器解决LP可行性问题，并记录是否可行。\n- 如果任何序列对该测试用例是可行的，则报告可达性为真。\n- 不涉及物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[True,False,True]\"），按顺序对应于各个测试用例。\n\n测试套件：\n使用以下三个测试用例，它们共同探测了一般情况、大M敏感性边界情况和不可达边界情况。\n\n测试用例1和测试用例2的通用系统组件：\n- 维度 $n = 2$，模式数 $Q = 2$。\n- 时域 $K = 3$。\n- 模式0（水平移动）：\n  $A_0 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，\n  $b_0 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$，\n  不变量 $H_0 x \\le h_0$ 具有\n  $H_0 = \\begin{bmatrix}0  1 \\\\ 0  -1\\end{bmatrix}$，\n  $h_0 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$，\n  这编码了 $-1 \\le y \\le 1$。\n- 模式1（垂直移动）：\n  $A_1 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，\n  $b_1 = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$，\n  不变量 $H_1 x \\le h_1$ 具有\n  $H_1 = \\begin{bmatrix}1  0 \\\\ -1  0\\end{bmatrix}$，\n  $h_1 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$，\n  这编码了 $-1 \\le x \\le 1$。\n- 初始集 $E x_0 \\le e$ 具有\n  $E = \\begin{bmatrix}1  0 \\\\ 0  1 \\\\ -1  0 \\\\ 0  -1\\end{bmatrix}$，\n  $e = \\begin{bmatrix}0.5 \\\\ 0.5 \\\\ 0.5 \\\\ 0.5\\end{bmatrix}$，\n  这编码了 $x_0 \\in [-0.5,0.5]^2$。\n- 目标集 $G x_3 \\le g$ 具有\n  $G = \\begin{bmatrix}-1  -1\\end{bmatrix}$，\n  $g = \\begin{bmatrix}-3\\end{bmatrix}$，\n  这编码了 $x_3 + y_3 \\ge 3$。\n- 每个 $x_k$ 的每个分量的变量界限：下界-10，上界10。\n\n测试用例1：\n- 大M常数 $M = 100$（足够大）。\n预期逻辑行为：由于适当的模式排序，目标是可达的，且大M值足够大地松弛了非激活约束。\n\n测试用例2：\n- 大M常数 $M = 0.2$（故意设置得过小）。\n预期逻辑行为：在此MILP编码下不可达，因为非激活模式的约束没有被足够松弛，即使在正确松弛下存在路径，也会产生假的不可行性。\n\n测试用例3：\n- 模式和不变量与上述相同。\n- 时域 $K = 2$。\n- 大M常数 $M = 100$。\n- 初始集 $E x_0 \\le e$ 与上述相同。\n- 目标集 $G x_2 \\le g$ 具有\n  $G = \\begin{bmatrix}-1  -1\\end{bmatrix}$，\n  $g = \\begin{bmatrix}-4\\end{bmatrix}$，\n  这编码了 $x_2 + y_2 \\ge 4$。\n- 变量界限：下界-10，上界10。\n预期逻辑行为：不可达，因为时域不足以在两个步骤内从有界的初始集累积所需的总和。\n\n您的程序必须实现上述要求，并生成单行 \"[result1,result2,result3]\"，其中每个结果是对应测试用例的布尔值。",
            "solution": "在尝试解决方案之前，对问题陈述进行验证。\n\n**第一步：提取已知条件**\n\n- **系统类型**：离散时间分段仿射（PWA）混合系统，具有有限的模式集。\n- **状态和时间**：在离散时间步 $k \\in \\{0, 1, \\dots, K-1\\}$ 的连续状态 $x_k \\in \\mathbb{R}^n$。\n- **模式**：$q \\in \\{0, 1, \\dots, Q-1\\}$。\n- **特定于模式的定义（对于模式 $q$）**：\n    - **不变量**：$H_q x_k \\le h_q$。\n    - **动态**：$x_{k+1} = A_q x_k + b_q$。\n- **集合定义**：\n    - **初始集**：$E x_0 \\le e$。\n    - **目标集**：$G x_K \\le g$。\n- **方法论**：使用混合整数线性规划（MILP）公式进行可达性分析，然后通过枚举所有模式序列并解决相应的线性规划（LP）可行性问题来求解。\n- **MILP编码（大M方法）**：\n    - **二元变量**：$y_{k,q} \\in \\{0, 1\\}$，对于每个步骤 $k$，满足 $\\sum_{q=0}^{Q-1} y_{k,q} = 1$。\n    - **不变量约束**：$H_q x_k \\le h_q + M(1 - y_{k,q})$。\n    - **动态约束**：对于每个维度 $i \\in \\{1, \\dots, n\\}$，\n        $x_{k+1,i} - (A_q x_k)_i - b_{q,i} \\le M(1 - y_{k,q})$\n        和 $-(x_{k+1,i} - (A_q x_k)_i - b_{q,i}) \\le M(1 - y_{k,q})$。\n- **变量界限**：状态变量是有界的。\n- **任务**：对每个测试用例，通过枚举所有 $Q^K$ 个模式序列，为每个序列构建一个LP并检查其可行性，来确定目标集在 $K$ 步内是否可达。\n\n**测试用例1和2的共同数据**：\n- $n = 2$，$Q = 2$，$K = 3$。\n- 模式0：$A_0 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，$b_0 = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix}$，不变量 $H_0 = \\begin{bmatrix}0  1 \\\\ 0  -1\\end{bmatrix}$，$h_0 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$ ($-1 \\le x_{k,2} \\le 1$)。\n- 模式1：$A_1 = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix}$，$b_1 = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$，不变量 $H_1 = \\begin{bmatrix}1  0 \\\\ -1  0\\end{bmatrix}$，$h_1 = \\begin{bmatrix}1 \\\\ 1\\end{bmatrix}$ ($-1 \\le x_{k,1} \\le 1$)。\n- 初始集：$E = \\begin{bmatrix}1  0 \\\\ 0  1 \\\\ -1  0 \\\\ 0  -1\\end{bmatrix}$，$e = \\begin{bmatrix}0.5 \\\\ 0.5 \\\\ 0.5 \\\\ 0.5\\end{bmatrix}$。\n- 目标集：$G = \\begin{bmatrix}-1  -1\\end{bmatrix}$，$g = \\begin{bmatrix}-3\\end{bmatrix}$。\n- 界限：所有状态分量的界限为 $[-10, 10]$。\n- **测试用例1特定**：$M = 100$。\n- **测试用例2特定**：$M = 0.2$。\n\n**测试用例3的数据**：\n- $n = 2$，$Q = 2$，$K = 2$，$M = 100$。\n- 模式、不变量、初始集和界限与上述相同。\n- 目标集：$G = \\begin{bmatrix}-1  -1\\end{bmatrix}$，$g = \\begin{bmatrix}-4\\end{bmatrix}$。\n\n**第二步：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n\n1.  **科学基础**：该问题在混合系统和控制理论领域有坚实的科学基础，这是信息物理系统的一个子学科。通过MILP对分段仿射系统进行可达性分析是一种标准且有据可查的技术。该公式在数学上是严谨的。\n2.  **适定性**：该问题是适定的。每个测试用例所需的所有参数、矩阵和常数都已明确提供。目标清晰：确定布尔可达性。规定的方法，即对模式序列进行穷举枚举，保证了确定性的结果（真或假）。\n3.  **客观性**：问题以精确、形式化的数学语言陈述，没有主观性或歧义。\n\n该问题在其前提中没有表现出任何科学上不健全、不完整、矛盾或不可行等缺陷。这是混合系统计算建模中的一个标准的、非平凡的练习。\n\n**第三步：结论与行动**\n该问题是**有效的**。将开发一个解决方案。\n\n**基于原理的解决方案设计**\n\n问题的核心是确定离散时间PWA系统的目标集的可达性。系统的演化由一系列激活的模式 $(q_0, q_1, \\dots, q_{K-1})$ 决定。由于禁止使用MILP求解器，任务简化为对所有可能的模式序列空间进行穷举搜索，其大小为 $Q^K$。对于每个候选序列，我们必须检查是否存在一个有效的状态轨迹，从初始集开始并在目标集结束。此检查被构建为一个线性规划（LP）可行性问题。\n\n设一个特定的模式序列为 $(\\hat{q}_0, \\hat{q}_1, \\dots, \\hat{q}_{K-1})$。我们需要确定是否存在一个状态轨迹 $(x_0, x_1, \\dots, x_K)$ 满足该序列的所有约束。LP的决策变量是这些状态向量的分量，连接成一个单一向量 $z \\in \\mathbb{R}^{n(K+1)}$，其中 $z = [x_0^T, x_1^T, \\dots, x_K^T]^T$。\n\nLP是一个可行性问题，所以目标函数为空：最小化 $c^T z$，其中 $c = \\mathbf{0}$。解完全在于满足一组线性不等式约束，我们将其表述为标准LP形式 $A_{ub} z \\le b_{ub}$。\n\n固定模式序列的约束如下：\n\n1.  **变量界限**：每个状态向量 $x_k$ 的每个分量必须在给定的界限内。对于任何 $k \\in \\{0, \\dots, K\\}$ 和 $i \\in \\{1, \\dots, n\\}$，$x_{k,i} \\in [-10, 10]$。这些是对 $z$ 元素的箱式约束。\n\n2.  **初始集**：初始状态 $x_0$ 必须属于初始集，由 $E x_0 \\le e$ 定义。这些约束适用于 $z$ 的前 $n$ 个元素。\n\n3.  **目标集**：最终状态 $x_K$ 必须属于目标集，由 $G x_K \\le g$ 定义。这些约束适用于 $z$ 的最后 $n$ 个元素。\n\n4.  **混合动态和不变量**：在每个时间步 $k \\in \\{0, \\dots, K-1\\}$，系统的演化受到*所有*可能模式 $q \\in \\{0, \\dots, Q-1\\}$ 的动态和不变量的约束，这些约束使用大M方法被激活或松弛。对于我们固定的序列，二元MILP变量 $y_{k,q}$ 被一个常数替换：如果 $q = \\hat{q}_k$（在步骤 $k$ 的激活模式），则 $y_{k,q}=1$，否则 $y_{k,q}=0$。因此，项 $M(1 - y_{k,q})$ 对于激活模式计算为 $0$，对于所有非激活模式计算为 $M$。\n\n对于每个步骤 $k \\in \\{0, \\dots, K-1\\}$ 和每个模式 $q \\in \\{0, \\dots, Q-1\\}$，我们添加以下约束。设 $m_{k,q} = M(1 - \\delta_{q, \\hat{q}_k})$，其中 $\\delta$ 是克罗内克δ。\n\n-   **不变量约束**：条件 $H_q x_k \\le h_q$ 必须为激活模式强制执行，并为非激活模式松弛。这被编码为：\n    $$H_q x_k \\le h_q + m_{k,q} \\cdot \\mathbf{1}$$\n    其中 $\\mathbf{1}$ 是一个适当维度的全1向量。这组不等式约束了 $z$ 中对应于 $x_k$ 的变量块。\n\n-   **动态约束**：仿射更新 $x_{k+1} = A_q x_k + b_q$ 被编码为两个不等式。对于激活模式，它们强制等式成立；对于非激活模式，它们被松弛：\n    $$x_{k+1} - A_q x_k \\le b_q + m_{k,q} \\cdot \\mathbf{1}$$\n    $$-x_{k+1} + A_q x_k \\le -b_q + m_{k,q} \\cdot \\mathbf{1}$$\n    这些不等式耦合了 $z$ 中对应于 $x_k$ 和 $x_{k+1}$ 的变量。\n\n这些约束被系统地组装成一个大矩阵 $A_{ub}$ 和向量 $b_{ub}$。然后我们使用一个LP求解器（`scipy.optimize.linprog`）来检查可行性。如果求解器为 $Q^K$ 个模式序列中的任何一个找到可行解，我们得出结论，目标集是可达的，并且该测试用例的结果是 `True`。如果所有序列都导致不可行的LP，则目标是不可达的，结果是 `False`。\n\n**测试用例分析**：\n- **测试用例1 ($M=100$)**：目标 $x_{3,1} + x_{3,2} \\ge 3$ 是可达的。一个从 $x_0=(0,0)$ 开始，模式序列为 $(0,1,0)$ 的轨迹，得到 $x_1=(1,0)$, $x_2=(1,1)$, 和 $x_3=(2,1)$，满足目标 ($2+1=3$)。不变量在此路径上得到满足。由于 $M=100$ 足够大（大于模式动态之间的最大可能违规量，即 $1$），非激活约束被正确松弛。这个序列预计会产生一个可行的LP。结果：`True`。\n\n- **测试用例2 ($M=0.2$)**：与上面相同的轨迹在物理上是可能的。然而，使用 $M=0.2$ 的MILP编码将会失败。动态之间的差异，例如 $(A_0 x_k + b_0) - (A_1 x_k + b_1) = b_0 - b_1 = [1, -1]^T$，其分量的大小为 $1$。为了松弛一个非激活约束，$M$ 必须至少这么大。由于 $M=0.2 < 1$，当模式0激活时，模式1的松弛约束将被违反，导致LP无论选择哪个序列都不可行。结果：`False`。\n\n- **测试用例3 ($M=100$)**：时域为 $K=2$。状态更新为 $x_{k+1} = x_k + v_k$，其中 $v_k$ 是 $[1,0]^T$ 或 $[0,1]^T$。两步之后，$x_2 = x_0 + v_0 + v_1$。目标是 $x_{2,1} + x_{2,2} \\ge 4$。和的最大值为 $x_{2,1}+x_{2,2} = (x_{0,1}+v_{0,1}+v_{1,1}) + (x_{0,2}+v_{0,2}+v_{1,2}) = (x_{0,1}+x_{0,2}) + (v_{0,1}+v_{0,2}) + (v_{1,1}+v_{1,2})$。任何 $v_k$ 的分量之和都是 $1$。初始和 $x_{0,1}+x_{0,2}$ 的最大值为 $0.5+0.5=1$。因此，$x_2$ 的和的最大可能值为 $1 + 1 + 1 = 3$。达到 $\\ge 4$ 的和在运动学上是不可能的。所有的LP都将是不可行的。结果：`False`。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef solve_case(params):\n    \"\"\"\n    Solves a single reachability test case by enumerating mode sequences.\n\n    For each sequence, it constructs and solves an LP feasibility problem.\n    \"\"\"\n    n = params['n']\n    Q = params['Q']\n    K = params['K']\n    M = params['M']\n    A_modes = params['A_modes']\n    b_modes = params['b_modes']\n    H_modes = params['H_modes']\n    h_modes = params['h_modes']\n    E = params['E']\n    e = params['e']\n    G = params['G']\n    g = params['g']\n    bounds_val = params['bounds']\n\n    # Generate all possible mode sequences of length K\n    mode_sequences = itertools.product(range(Q), repeat=K)\n    \n    # LP decision variables are the concatenated state vectors: z = [x_0, x_1, ..., x_K]\n    num_lp_vars = n * (K + 1)\n    \n    # Objective function is zero for a feasibility problem\n    c = np.zeros(num_lp_vars)\n    \n    # State variable bounds\n    bounds = [bounds_val] * num_lp_vars\n    \n    # Iterate through each possible mode sequence\n    for seq in mode_sequences:\n        A_ub_list = []\n        b_ub_list = []\n        \n        # 1. Initial set constraints: E x_0 = e\n        A_init = np.zeros((E.shape[0], num_lp_vars))\n        A_init[:, :n] = E\n        A_ub_list.append(A_init)\n        b_ub_list.append(e)\n        \n        # 2. Target set constraints: G x_K = g\n        A_target = np.zeros((G.shape[0], num_lp_vars))\n        A_target[:, n * K : n * (K + 1)] = G\n        A_ub_list.append(A_target)\n        b_ub_list.append(g)\n\n        # 3. Dynamics and Invariant constraints for each step k and each mode q\n        for k in range(K):\n            for q in range(Q):\n                is_active_mode = (q == seq[k])\n                \n                # The Big-M term is 0 for the active mode, M otherwise\n                m_val = 0.0 if is_active_mode else M\n                \n                # Invariant constraint: H_q x_k = h_q + M * (1-y_kq)\n                H_q, h_q = H_modes[q], h_modes[q]\n                num_inv_const = H_q.shape[0]\n                A_inv = np.zeros((num_inv_const, num_lp_vars))\n                A_inv[:, n * k : n * (k + 1)] = H_q\n                b_inv = h_q + m_val\n                A_ub_list.append(A_inv)\n                b_ub_list.append(b_inv)\n                \n                # Dynamics constraints encoded as two inequalities\n                A_q, b_q = A_modes[q], b_modes[q]\n                \n                # Inequality 1: x_{k+1} - A_q x_k = b_q + M * (1-y_kq)\n                A_dyn_1 = np.zeros((n, num_lp_vars))\n                A_dyn_1[:, n * (k + 1) : n * (k + 2)] = np.eye(n)\n                A_dyn_1[:, n * k : n * (k + 1)] = -A_q\n                b_dyn_1 = b_q + m_val\n                A_ub_list.append(A_dyn_1)\n                b_ub_list.append(b_dyn_1)\n                \n                # Inequality 2: -x_{k+1} + A_q x_k = -b_q + M * (1-y_kq)\n                A_dyn_2 = np.zeros((n, num_lp_vars))\n                A_dyn_2[:, n * (k + 1) : n * (k + 2)] = -np.eye(n)\n                A_dyn_2[:, n * k : n * (k + 1)] = A_q\n                b_dyn_2 = -b_q + m_val\n                A_ub_list.append(A_dyn_2)\n                b_ub_list.append(b_dyn_2)\n\n        # Consolidate all constraints into a single matrix and vector\n        A_ub = np.vstack(A_ub_list)\n        b_ub = np.concatenate(b_ub_list)\n        \n        # Solve the LP feasibility problem\n        # method='highs' is the default and recommended in recent SciPy versions\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        # A status of 0 indicates an optimal solution was found (i.e., it's feasible)\n        if res.success and res.status == 0:\n            return True # Target is reachable\n            \n    # If no feasible sequence was found after checking all\n    return False # Target is not reachable\n\ndef solve():\n    # Common system components\n    n = 2\n    Q = 2\n    \n    A0 = np.array([[1, 0], [0, 1]])\n    b0 = np.array([1, 0])\n    H0 = np.array([[0, 1], [0, -1]])\n    h0 = np.array([1, 1])\n\n    A1 = np.array([[1, 0], [0, 1]])\n    b1 = np.array([0, 1])\n    H1 = np.array([[1, 0], [-1, 0]])\n    h1 = np.array([1, 1])\n    \n    A_modes = [A0, A1]\n    b_modes = [b0, b1]\n    H_modes = [H0, H1]\n    h_modes = [h0, h1]\n\n    E = np.array([[1, 0], [0, 1], [-1, 0], [0, -1]])\n    e = np.array([0.5, 0.5, 0.5, 0.5])\n    bounds = (-10, 10)\n\n    # Test Case 1: Reachable, sufficient M\n    test_case_1 = {\n        'n': n, 'Q': Q, 'K': 3, 'M': 100.0,\n        'A_modes': A_modes, 'b_modes': b_modes,\n        'H_modes': H_modes, 'h_modes': h_modes,\n        'E': E, 'e': e,\n        'G': np.array([[-1, -1]]), 'g': np.array([-3]),\n        'bounds': bounds\n    }\n\n    # Test Case 2: Unreachable (by encoding), insufficient M\n    test_case_2 = {\n        'n': n, 'Q': Q, 'K': 3, 'M': 0.2,\n        'A_modes': A_modes, 'b_modes': b_modes,\n        'H_modes': H_modes, 'h_modes': h_modes,\n        'E': E, 'e': e,\n        'G': np.array([[-1, -1]]), 'g': np.array([-3]),\n        'bounds': bounds\n    }\n    \n    # Test Case 3: Unreachable (kinematically), sufficient M\n    test_case_3 = {\n        'n': n, 'Q': Q, 'K': 2, 'M': 100.0,\n        'A_modes': A_modes, 'b_modes': b_modes,\n        'H_modes': H_modes, 'h_modes': h_modes,\n        'E': E, 'e': e,\n        'G': np.array([[-1, -1]]), 'g': np.array([-4]),\n        'bounds': bounds\n    }\n\n    test_cases = [test_case_1, test_case_2, test_case_3]\n    \n    results = [solve_case(case) for case in test_cases]\n\n    # Format output as specified: \"[True,False,True]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在学会分析系统安全性之后，最后一步是综合控制器，使其在实时运行中强制执行安全约束，同时实现性能目标。本练习  将介绍一种现代控制范式，该范式将用于保证稳定性和性能的控制李雅普诺夫函数（CLF）与用于保证安全性的控制障碍函数（CBF）相结合。你将通过构建一个实时二次规划（QP）来获得实践经验，这种方法是许多现代机器人和自主系统的核心，从而在物理执行器限制下找到平衡这些通常相互冲突的目标的最优控制策略。",
            "id": "4223707",
            "problem": "考虑一个网络物理系统，其模型为一个单输入单输出的连续时间系统，状态为 $x \\in \\mathbb{R}$，控制输入为 $u \\in \\mathbb{R}$，并由单积分器动力学 $\\dot{x} = u$ 控制。你需要通过一个二次规划（QP）将一个控制李雅普诺夫函数（CLF）目标与一个控制屏障函数（CBF）约束统一起来，并分析当 CLF 目标和 CBF 约束发生冲突时（尤其是在存在执行器限制的情况下）的可行性。\n\n从以下基本定义和法则开始：\n- CLF $V(x)$ 是一个连续可微的正定函数，其期望的下降速率由一个常数 $c  0$ 来量化。对于单积分器模型，使用 $V(x) = \\frac{1}{2} x^2$。CLF 条件用沿着漂移项 $f(x)$ 和输入向量场 $g(x)$ 的李导数 $L_f V(x)$ 和 $L_g V(x)$ 来表示。对于单积分器，漂移项为 $f(x) = 0$，输入向量场为 $g(x) = 1$，因此 $L_f V(x) = 0$ 且 $L_g V(x) = \\frac{\\partial V}{\\partial x} = x$。为了让调节与安全性共存，引入一个非负的松弛变量 $\\delta \\ge 0$ 来放宽 CLF 不等式。放宽后的 CLF 约束为\n$$\nx u \\le -\\frac{c}{2} x^2 + \\delta.\n$$\n- CBF $h(x)$ 通过强制执行不等式 $\\dot{h}(x) + \\alpha h(x) \\ge 0$ 来定义一个前向不变的安全集 $\\{x \\mid h(x) \\ge 0\\}$，其中 $\\alpha  0$（一个 class-$\\mathcal{K}$ 增益）。使用仿射屏障函数 $h(x) = x - x_{\\min}$，其中 $x_{\\min} \\in \\mathbb{R}$ 表示一个安全阈值。对于单积分器模型，这得到\n$$\nu + \\alpha (x - x_{\\min}) \\ge 0,\n$$\n或等价地\n$$\nu \\ge -\\alpha (x - x_{\\min}).\n$$\n- 为了编码执行器限制，施加箱式约束 $u_{\\min} \\le u \\le u_{\\max}$，其中 $u_{\\min} \\in \\mathbb{R}$ 和 $u_{\\max} \\in \\mathbb{R}$ 是给定的常数。\n\n构建以下凸二次规划（QP），该规划将 CLF 目标与 CBF 约束统一起来：\n- 决策变量：$(u, \\delta) \\in \\mathbb{R} \\times \\mathbb{R}$，其中 $\\delta \\ge 0$。\n- 目标：最小化二次成本\n$$\nJ(u,\\delta) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\delta^2,\n$$\n其中 $p  0$ 是对 CLF 松弛量的惩罚权重。\n- 约束条件：\n    1. CLF 下降（放宽）：$x u \\le -\\frac{c}{2} x^2 + \\delta$，\n    2. CBF 安全性：$u \\ge -\\alpha (x - x_{\\min})$，\n    3. 执行器限制：$u_{\\min} \\le u \\le u_{\\max}$，\n    4. 松弛变量非负性：$\\delta \\ge 0$。\n\n你的程序必须：\n- 从第一性原理出发，实现一个算法来计算给定参数 $(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max})$ 下的最优解 $(u^\\star, \\delta^\\star)$ 和最优成本 $J^\\star$。\n- 确定可行性：返回一个布尔值，指示是否存在任何满足所有约束的 $(u, \\delta)$。根据约束来解释可行性；特别地，CLF 约束可以通过 $\\delta \\ge 0$ 放宽，因此不可行性只能源于无法调和的安全性与执行器限制。\n\n你必须分析并编码当 CLF 目标和 CBF 约束与执行器限制冲突时的可行性条件。具体来说，你的解必须能从约束出发，判断何时不存在可接受的控制 $u$ 来同时满足 CBF 不等式和执行器边界，无论 CLF 松弛量 $\\delta$ 为何值。\n\n测试套件：\n使用以下参数集来测试不同的情况（正常路径、边界情况和冲突情况）。每个测试用例是一个元组 $(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max})$：\n- 案例 1：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\,1.0,\\,0.0,\\,1.0,\\,1.0,\\,100.0,\\, -2.0,\\, 2.0\\,)$。\n- 案例 2：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\,0.0,\\,0.0,\\,1.0,\\,1.0,\\,10.0,\\, -1.0,\\, 1.0\\,)$。\n- 案例 3：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\,0.1,\\,0.0,\\,50.0,\\,1.0,\\,10.0,\\, -2.0,\\, 2.0\\,)$。\n- 案例 4：$(x, x_{\\min}, \\alpha, c, p, u_{\\min}, u_{\\max}) = (\\, -1.0,\\, -5.0,\\, 0.5,\\, 1.0,\\, 50.0,\\, -3.0,\\, 3.0\\,)$。\n\n最终输出格式：\n你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且必须是 $[\\text{feasible}, u^\\star, \\delta^\\star, J^\\star]$ 形式的列表，其中 $\\text{feasible}$ 是一个布尔值，$u^\\star$、$\\delta^\\star$ 和 $J^\\star$ 是实数。例如，输出必须看起来像\n$[[\\text{True}, u_1, \\delta_1, J_1],[\\text{False}, u_2, \\delta_2, J_2],\\ldots]$\n这是为四个指定的测试用例计算的结果。",
            "solution": "该问题旨在为单积分器系统 $\\dot{x} = u$ 寻找最优控制输入 $u$ 和控制李雅普诺夫函数（CLF）的松弛量 $\\delta$。该优化问题被构建为一个二次规划（QP），该规划在满足来自放宽的 CLF、控制屏障函数（CBF）、执行器限制和松弛量非负性的约束条件下，平衡了控制力与 CLF 的松弛。\n\n该 QP 构建如下：\n$$ \\min_{u, \\delta} \\quad J(u,\\delta) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\delta^2 $$\n约束条件为：\n1.  $x u \\le -\\frac{c}{2} x^2 + \\delta$ (放宽的 CLF 条件)\n2.  $u \\ge -\\alpha (x - x_{\\min})$ (CBF 条件)\n3.  $u_{\\min} \\le u \\le u_{\\max}$ (执行器限制)\n4.  $\\delta \\ge 0$ (松弛量非负性)\n\n在这里，$x \\in \\mathbb{R}$ 是状态，$u \\in \\mathbb{R}$ 是控制输入，而 $\\delta \\in \\mathbb{R}$ 是松弛变量。参数 $c, p, \\alpha, x_{\\min}, u_{\\min}, u_{\\max}$ 是给定的正常数或实数值。\n\n首先，我们分析此 QP 的可行性。CLF 约束 $x u \\le -\\frac{c}{2} x^2 + \\delta$ 可以重写为 $\\delta \\ge x u + \\frac{c}{2} x^2$。由于我们还有约束 $\\delta \\ge 0$，对于任意给定的控制输入 $u$，我们总能通过选择 $\\delta \\ge \\max(0, x u + \\frac{c}{2} x^2)$ 来找到一个可行的 $\\delta$。这意味着整个 QP 的可行性仅取决于是否存在一个满足其余约束的控制输入 $u$。对 $u$ 的这些约束是 CBF 条件和执行器限制：\n$$ u \\ge -\\alpha (x - x_{\\min}) $$\n$$ u_{\\min} \\le u \\le u_{\\max} $$\n为了使一个可行的 $u$ 存在，由这些不等式定义的集合的交集必须非空。这当且仅当 $u$ 的总下界小于或等于上界时成立。令 $u_{cbf} = -\\alpha (x - x_{\\min})$ 为来自 CBF 约束的下界。$u$ 的组合下界是 $\\max(u_{\\min}, u_{cbf})$。因此，当且仅当以下条件成立时，$u$ 的可行集非空：\n$$ \\max(u_{\\min}, -\\alpha (x - x_{\\min})) \\le u_{\\max} $$\n这就是可行性条件。如果不满足，则不存在解。我们假设执行器限制是良定义的，即 $u_{\\min} \\le u_{\\max}$。该条件随后简化为 $-\\alpha (x - x_{\\min}) \\le u_{\\max}$。\n\n如果问题是可行的，我们继续寻找最优解 $(u^\\star, \\delta^\\star)$。为了最小化目标函数 $J(u, \\delta)$（一个带正权重 $p0$ 的平方项之和），我们必须为 $\\delta$ 选择最小的允许值。如前所述，对 $\\delta$ 的约束是 $\\delta \\ge 0$ 和 $\\delta \\ge x u + \\frac{c}{2} x^2$。因此，对于任意给定的 $u$，$\\delta$ 的最优选择是：\n$$ \\delta(u) = \\max\\left(0, x u + \\frac{c}{2} x^2\\right) $$\n将此代入目标函数，可将双变量 QP 转化为一个关于 $u$ 的一维优化问题：\n$$ \\min_{u \\in [u_{lower}, u_{upper}]} \\quad J(u) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\left( \\max\\left(0, x u + \\frac{c}{2} x^2\\right) \\right)^2 $$\n其中 $u$ 的可行区间是 $[u_{lower}, u_{upper}]$，$u_{lower} = \\max(u_{\\min}, -\\alpha (x - x_{\\min}))$ 且 $u_{upper} = u_{\\max}$。\n\n目标函数 $J(u)$ 是凸且连续可微的。其无约束最小值可以通过将其导数设为零来找到。我们通过考虑基于 $C(u) = x u + \\frac{c}{2} x^2$ 符号的两种情况来分析此问题。\n\n情况 1：$C(u) \\le 0$。此时，$\\delta(u)=0$ 且 $J(u) = \\frac{1}{2} u^2$。此二次函数的最小值在 $u=0$ 处。然而，条件 $C(0) = \\frac{c}{2}x^2 \\le 0$ 仅在 $x=0$ 时成立，我们将其作为特例处理。\n\n情况 2：$C(u)  0$。此时，$\\delta(u) = x u + \\frac{c}{2} x^2$ 且目标函数为 $J(u) = \\frac{1}{2} u^2 + \\frac{1}{2} p (x u + \\frac{c}{2} x^2)^2$。导数为：\n$$ \\frac{dJ}{du} = u + p \\left(x u + \\frac{c}{2} x^2\\right) x = u(1 + px^2) + \\frac{pcx^3}{2} $$\n令 $\\frac{dJ}{du} = 0$ 可得到无约束最小化器：\n$$ u_{unc} = -\\frac{p c x^3}{2(1 + p x^2)} $$\n我们可以验证，对于 $x \\neq 0$，这个 $u_{unc}$ 值会得到 $C(u_{unc}) = x u_{unc} + \\frac{c}{2} x^2 = \\frac{c x^2}{2(1 + p x^2)}  0$，这证实了无约束最小值位于此区域内。\n\n约束问题的最优解 $u^\\star$ 是无约束最小化器 $u_{unc}$ 在可行区间 $[u_{lower}, u_{upper}]$ 上的投影。\n$$ u^\\star = \\max(u_{lower}, \\min(u_{unc}, u_{upper})) $$\n\n特例：$x = 0$。\n如果 $x=0$，CLF 约束变为 $\\delta \\ge 0$。CBF 约束为 $u \\ge \\alpha x_{\\min}$。$u$ 的可行集为 $u \\in [\\max(u_{\\min}, \\alpha x_{\\min}), u_{\\max}]$。目标函数为 $J(u, \\delta) = \\frac{1}{2} u^2 + \\frac{1}{2} p \\delta^2$。为最小化 $J$，我们必须选择 $\\delta^\\star=0$。最优控制 $u^\\star$ 是可行区间中最接近 0 的值，通过将 0 投影到该区间上找到。\n\n算法如下：\n1.  计算可行性边界：$u_{cbf} = -\\alpha (x - x_{\\min})$，$u_{lower} = \\max(u_{\\min}, u_{cbf})$，以及 $u_{upper} = u_{\\max}$。\n2.  检查可行性：如果 $u_{lower}  u_{upper}$，问题是不可行的。\n3.  如果可行：\n    a. 如果 $x=0$：\n       $u^\\star = \\max(u_{lower}, \\min(0, u_{upper}))$。\n       $\\delta^\\star = 0$。\n    b. 如果 $x \\neq 0$：\n       计算 $u_{unc} = - (p \\cdot c \\cdot x^3) / (2 \\cdot (1 + p \\cdot x^2))$。\n       $u^\\star = \\max(u_{lower}, \\min(u_{unc}, u_{upper}))$。\n       $\\delta^\\star = \\max(0, x \\cdot u^\\star + (c/2) \\cdot x^2)$。\n4.  计算最优成本 $J^\\star = \\frac{1}{2} (u^\\star)^2 + \\frac{1}{2} p (\\delta^\\star)^2$。\n5.  返回可行性状态和最优值 $(u^\\star, \\delta^\\star, J^\\star)$。",
            "answer": "```python\nimport numpy as np\n\ndef solve_clf_cbf_qp(x, x_min, alpha, c, p, u_min, u_max):\n    \"\"\"\n    Solves the CLF-CBF-QP for a single-integrator system from first principles.\n\n    Args:\n        x (float): Current state.\n        x_min (float): Safety threshold for the state.\n        alpha (float): CBF class-K gain.\n        c (float): CLF decay rate constant.\n        p (float): Penalty weight on the CLF slack.\n        u_min (float): Minimum control input.\n        u_max (float): Maximum control input.\n\n    Returns:\n        list: A list containing [feasible, u_star, delta_star, J_star].\n              'feasible' is a boolean. For infeasible cases, the other\n              values are np.nan.\n    \"\"\"\n    # 1. Feasibility Analysis\n    # The set of admissible controls for u is constrained by the CBF and actuator limits.\n    # Feasibility requires this set to be non-empty.\n    \n    # Lower bound from CBF\n    u_cbf = -alpha * (x - x_min)\n\n    # Combined lower bound for u\n    u_lower = max(u_min, u_cbf)\n    u_upper = u_max\n\n    is_feasible = u_lower = u_upper\n\n    if not is_feasible:\n        return [False, np.nan, np.nan, np.nan]\n\n    # 2. Solve for the optimal (u*, delta*)\n    u_star = 0.0\n    delta_star = 0.0\n\n    if x == 0.0:\n        # For x=0, CLF constraint is delta >= 0.\n        # Objective is min 0.5*u^2 + 0.5*p*delta^2.\n        # To minimize, we need delta=0 and u to be as close to 0 as possible.\n        # u_star is the projection of 0 onto the feasible set [u_lower, u_upper].\n        u_star = max(u_lower, min(0.0, u_upper))\n        delta_star = 0.0\n    else:\n        # For x != 0, solve the 1D optimization problem for u.\n        # Unconstrained minimizer of the reduced objective function J(u).\n        numerator = p * c * (x**3)\n        denominator = 2 * (1 + p * (x**2))\n        u_unc = -numerator / denominator\n\n        # The optimal u* is the projection of u_unc onto the feasible interval.\n        u_star = max(u_lower, min(u_unc, u_upper))\n        \n        # The optimal delta* is the smallest value satisfying the constraints.\n        delta_star = max(0.0, x * u_star + (c / 2.0) * (x**2))\n\n    # 3. Calculate the optimal cost\n    J_star = 0.5 * (u_star**2) + 0.5 * p * (delta_star**2)\n\n    return [True, u_star, delta_star, J_star]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results in the required format.\n    \"\"\"\n    test_cases = [\n        # (x, x_min, alpha, c, p, u_min, u_max)\n        (1.0, 0.0, 1.0, 1.0, 100.0, -2.0, 2.0),\n        (0.0, 0.0, 1.0, 1.0, 10.0, -1.0, 1.0),\n        (0.1, 0.0, 50.0, 1.0, 10.0, -2.0, 2.0),\n        (-1.0, -5.0, 0.5, 1.0, 50.0, -3.0, 3.0),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = solve_clf_cbf_qp(*params)\n        results.append(result)\n\n    # Format the output string as specified in the problem.\n    # e.g., [[True,-0.495...,0.00495...,0.123...],[True,0.0,0.0,0.0],...]\n    formatted_results = []\n    for res in results:\n        # str() on a boolean gives 'True' or 'False' with correct capitalization.\n        # str() on np.nan gives 'nan'.\n        inner_list_str = f\"[{str(res[0])},{res[1]},{res[2]},{res[3]}]\"\n        formatted_results.append(inner_list_str)\n    \n    # Final output is a comma-separated list of these inner lists, enclosed in brackets.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}