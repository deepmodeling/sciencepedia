{
    "hands_on_practices": [
        {
            "introduction": "稳定性是动态系统最基本的属性，决定了系统在受到扰动后能否恢复到平衡状态。本练习将引导你从两个关键视角评估系统稳定性：通过状态矩阵的特征值分析内部模态行为，以及通过传递函数的极点（使用劳斯-赫尔维茨判据）分析输入输出行为。这项实践不仅能巩固你的计算技能，还有助于深刻理解状态空间与传递函数这两种模型表示之间的内在联系。",
            "id": "4229657",
            "problem": "一个信息物理系统 (CPS) 的数字孪生 (DT) 是围绕一个连续时间线性时不变 (LTI) 状态空间模型构建的，该模型通过对一个耦合的驱动-传感子系统进行第一性原理线性化得到。该数字孪生使用状态矩阵 $A$ 来预测内部模态行为，并使用一个单输入单输出的执行器到传感器的传递函数 $G(s)$ 来表示一个回路通道，其分母多项式为 $a(s)$。给定：\n- 连续时间状态矩阵\n$$\nA \\;=\\; \\begin{pmatrix}\n0  1  0 \\\\\n-7  -6  0 \\\\\n0  0  -4\n\\end{pmatrix},\n$$\n该矩阵由数字孪生内部模型中的线性化质量-弹簧-阻尼器耦合产生。\n- 回路传递函数的分母多项式\n$$\na(s) \\;=\\; s^{3} + 6 s^{2} + 5 s + k,\n$$\n其中 $k$ 是一个实数正控制增益参数，它集合了网络层中执行器的增益和传感器到执行器的缩放比例。\n\n任务：\n1) 使用特征值作为特征多项式根的定义，从第一性原理出发计算 $A$ 的特征值，并根据其在复平面中的位置解释数字孪生内部模型的开环模态稳定性。\n2) 使用真有理传递函数的内部稳定性定义（即所有极点严格位于开左半复平面），应用劳斯-赫尔维茨稳定性判据于 $a(s)$，以确定最大的实数 $K$，使得对于所有满足 $0  k  K$ 的 $k$，回路都是内部稳定的。",
            "solution": "该问题提出了关于连续时间线性时不变（LTI）系统稳定性分析的两个独立任务，该系统为信息物理系统的数字孪生中的元素建模。本解答将按顺序处理每个任务，并遵循从第一性原理进行推理的特定要求。\n\n### 任务1：内部模型的特征值计算与稳定性分析\n\n第一个任务是计算状态矩阵 $A$ 的特征值，并解释其对开环内部模型的稳定性意义。状态矩阵给定为：\n$$\nA = \\begin{pmatrix}\n0  1  0 \\\\\n-7  -6  0 \\\\\n0  0  -4\n\\end{pmatrix}\n$$\n根据定义，矩阵 $A$ 的特征值是其特征多项式 $p(\\lambda) = \\det(\\lambda I - A)$ 的根，其中 $I$ 是单位矩阵，$\\lambda$ 代表特征值变量。\n\n首先，我们构造矩阵 $\\lambda I - A$：\n$$\n\\lambda I - A = \\lambda \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} - \\begin{pmatrix} 0  1  0 \\\\ -7  -6  0 \\\\ 0  0  -4 \\end{pmatrix} = \\begin{pmatrix} \\lambda  -1  0 \\\\ 7  \\lambda+6  0 \\\\ 0  0  \\lambda+4 \\end{pmatrix}\n$$\n接下来，我们计算该矩阵的行列式以求得特征多项式 $p(\\lambda)$。我们可以使用代数余子式展开。由于第三行有两个零元素，沿第三行展开最为高效：\n$$\np(\\lambda) = \\det(\\lambda I - A) = (0) \\cdot C_{31} - (0) \\cdot C_{32} + (\\lambda+4) \\cdot C_{33}\n$$\n其中 $C_{ij}$ 是代数余子式。唯一的非零项是：\n$$\np(\\lambda) = (\\lambda+4) \\det \\begin{pmatrix} \\lambda  -1 \\\\ 7  \\lambda+6 \\end{pmatrix}\n$$\n这个 $2 \\times 2$ 行列式计算如下：\n$$\n\\det \\begin{pmatrix} \\lambda  -1 \\\\ 7  \\lambda+6 \\end{pmatrix} = \\lambda(\\lambda+6) - (-1)(7) = \\lambda^{2} + 6\\lambda + 7\n$$\n因此，特征多项式为：\n$$\np(\\lambda) = (\\lambda+4)(\\lambda^{2} + 6\\lambda + 7)\n$$\n特征值是 $p(\\lambda) = 0$ 的根。这给我们两个因子需要求解：\n1. $\\lambda+4 = 0 \\implies \\lambda_1 = -4$\n2. $\\lambda^{2} + 6\\lambda + 7 = 0$\n\n为了求出二次因子的根，我们使用二次公式 $\\lambda = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$，其中 $a=1$, $b=6$, $c=7$：\n$$\n\\lambda = \\frac{-6 \\pm \\sqrt{6^2 - 4(1)(7)}}{2(1)} = \\frac{-6 \\pm \\sqrt{36 - 28}}{2} = \\frac{-6 \\pm \\sqrt{8}}{2} = \\frac{-6 \\pm 2\\sqrt{2}}{2} = -3 \\pm \\sqrt{2}\n$$\n这给出了另外两个特征值：\n$\\lambda_2 = -3 + \\sqrt{2}$\n$\\lambda_3 = -3 - \\sqrt{2}$\n\n所以，矩阵 $A$ 的三个特征值为 $\\lambda_1 = -4$、$\\lambda_2 = -3 + \\sqrt{2}$ 和 $\\lambda_3 = -3 - \\sqrt{2}$。\n\n对于稳定性解释，一个连续时间LTI系统 $\\dot{x}=Ax$ 是渐近稳定的，当且仅当矩阵 $A$ 的所有特征值都严格位于复平面的开左半平面，这意味着每个特征值的实部都必须严格为负，即对所有 $i$ 都有 $\\text{Re}(\\lambda_i)  0$。我们来检查我们的特征值是否满足这个条件：\n- $\\lambda_1 = -4$：这是一个实数，所以 $\\text{Re}(\\lambda_1) = -4  0$。\n- $\\lambda_2 = -3 + \\sqrt{2}$：这是一个实数。由于 $\\sqrt{2} \\approx 1.414$，我们有 $\\lambda_2 \\approx -3 + 1.414 = -1.586$。显然，$-3 + \\sqrt{2}  0$ 因为 $3 > \\sqrt{2}$ (或 $9 > 2$)。因此，$\\text{Re}(\\lambda_2)  0$。\n- $\\lambda_3 = -3 - \\sqrt{2}$：这是一个实数并且严格为负。因此，$\\text{Re}(\\lambda_3)  0$。\n\n由于所有三个特征值都具有严格为负的实部，由状态矩阵 $A$ 描述的开环内部模型是渐近稳定的。每个特征值对应一个系统模态，并且因为所有特征值都在左半平面，如果系统不受外力作用，系统的所有内部模态都会随时间衰减至零。\n\n### 任务2：回路传递函数的劳斯-赫尔维茨稳定性分析\n\n第二个任务是确定正增益参数 $k$ 的范围，使得由分母多项式 $a(s) = s^{3} + 6 s^{2} + 5 s + k$ 表征的闭环系统是内部稳定的。对于一个真有理传递函数，其内部稳定性要求其所有极点（即分母多项式 $a(s)$ 的根）都严格位于开左半复平面。\n\n劳斯-赫尔维茨稳定性判据提供了一种无需直接计算多项式根即可确定其所有根是否具有负实部的方法。该判据应用于多项式 $a(s) = s^{3} + 6 s^{2} + 5 s + k$。\n\n首先，一个稳定性的必要（但非充分）条件是多项式的所有系数都必须非零且同号。由于 $s^3$ 的系数是 $1 > 0$，所有其他系数都必须为正。\n- $s^2$ 的系数：$6 > 0$\n- $s^1$ 的系数：$5 > 0$\n- $s^0$ 的系数：$k$。为保证稳定性，我们必须有 $k > 0$。这与问题陈述中 $k$ 是一个正控制增益的说法一致。\n\n充分必要条件是劳斯表第一列中的所有元素都必须为正。我们为 $a(s) = 1s^{3} + 6s^{2} + 5s + k$ 构建劳斯表：\n\n前两行由多项式的系数构成：\n$$\n\\begin{array}{c|cc}\ns^3  1  5 \\\\\ns^2  6  k \\\\\n\\end{array}\n$$\n后续各行计算如下。$s^1$ 行的第一个元素，我们称之为 $b_1$，是：\n$$\nb_1 = \\frac{(6)(5) - (1)(k)}{6} = \\frac{30 - k}{6}\n$$\n$s^0$ 行的第一个元素，我们称之为 $c_1$，是：\n$$\nc_1 = \\frac{(b_1)(k) - (6)(0)}{b_1} = k\n$$\n完整的劳斯表是：\n$$\n\\begin{array}{c|cc}\ns^3  1  5 \\\\\ns^2  6  k \\\\\ns^1  \\frac{30 - k}{6}  0 \\\\\ns^0  k  0 \\\\\n\\end{array}\n$$\n为使系统稳定，第一列中的所有元素都必须为正：\n1. $1 > 0$ (成立)。\n2. $6 > 0$ (成立)。\n3. $\\frac{30 - k}{6} > 0 \\implies 30 - k > 0 \\implies k  30$。\n4. $k > 0$ (这是 $s^0$ 行的元素，与必要条件一致)。\n\n综合对 $k$ 的条件，我们发现系统稳定的充要条件是 $0  k  30$。\n\n问题要求找出最大的实数 $K$，使得对于所有满足 $0  k  K$ 的 $k$，回路都是内部稳定的。这对应于 $k$ 的稳定区间的上确界。稳定区间是 $(0, 30)$。这个区间的上确界是 $30$。\n因此，$K$ 的值是 $30$。",
            "answer": "$$ \\boxed{30} $$"
        },
        {
            "introduction": "在确认系统稳定后，我们自然会关心所建模型的有效性。一个“好”的模型不仅要准确，还应是“精简”的，不包含冗余状态。本练习将深入探讨能控性和能观性这两个核心概念，它们共同决定了一个状态空间模型是否为最小实现。掌握此分析方法是构建无冗余、计算高效的数字孪生模型的关键一步。",
            "id": "4229641",
            "problem": "一个赛博物理系统 (CPS) 的数字孪生 (DT) 用于对一个三态子系统进行建模，该子系统描述了飞行器在稳定工作点附近的线性化垂直通道。该子系统由一个连续时间线性时不变 (LTI) 模型表示，其状态向量为 $x \\in \\mathbb{R}^{3}$，输入为 $u \\in \\mathbb{R}$，输出为 $y \\in \\mathbb{R}$，由 $\\dot{x} = A x + B u$ 和 $y = C x$ 给出。矩阵如下\n$$\nA = \\begin{pmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n-4  -5  -2\n\\end{pmatrix},\\quad\nB = \\begin{pmatrix}\n0 \\\\\n1 \\\\\n1\n\\end{pmatrix},\\quad\nC = \\begin{pmatrix}\n1  0  2\n\\end{pmatrix}.\n$$\n使用 LTI 系统的能达性和输出可区分性的基本定义，计算能控性矩阵 $\\mathcal{C}$ 和能观性矩阵 $\\mathcal{O}$，验证它们的秩，并确定给定的实现是否是最小实现。最后，将最小实现的麦克米兰阶数 $n_{\\min}$ 以单个整数的形式报告。无需四舍五入，答案中也不应报告任何物理单位。",
            "solution": "问题要求分析一个连续时间线性时不变 (LTI) 系统，以确定其给定的状态空间实现是否为最小实现，并求出其麦克米兰阶数。该系统由状态空间方程 $\\dot{x} = A x + B u$ 和 $y = C x$ 描述，其状态向量为 $x \\in \\mathbb{R}^{3}$，输入为 $u \\in \\mathbb{R}$，输出为 $y \\in \\mathbb{R}$。状态空间的维数为 $n=3$。\n\n给定的矩阵如下：\n$$\nA = \\begin{pmatrix}\n0  1  0 \\\\\n0  0  1 \\\\\n-4  -5  -2\n\\end{pmatrix},\\quad\nB = \\begin{pmatrix}\n0 \\\\\n1 \\\\\n1\n\\end{pmatrix},\\quad\nC = \\begin{pmatrix}\n1  0  2\n\\end{pmatrix}.\n$$\n\n如果一个状态空间实现既是完全能控的又是完全能观的，那么它被认为是最小实现。一个系统的最小实现的阶数是一个唯一的数，称为麦克米兰阶数，记为 $n_{\\min}$。\n\n首先，我们必须验证系统的能控性。一个系统是完全能控的，当且仅当其能控性矩阵 $\\mathcal{C}$ 是满秩的，即 $\\text{rank}(\\mathcal{C}) = n$。对于一个阶数为 $n=3$ 的系统，其能控性矩阵由下式给出：\n$$\n\\mathcal{C} = \\begin{pmatrix} B  AB  A^2B \\end{pmatrix}\n$$\n我们计算必要的组成部分：\n第一列是矩阵 $B$ 本身：\n$$\nB = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}\n$$\n第二列是乘积 $AB$：\n$$\nAB = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ -4  -5  -2 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 1 \\\\ 0 \\cdot 0 + 0 \\cdot 1 + 1 \\cdot 1 \\\\ -4 \\cdot 0 - 5 \\cdot 1 - 2 \\cdot 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\\\ -7 \\end{pmatrix}\n$$\n第三列是乘积 $A^2B = A(AB)$：\n$$\nA^2B = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ -4  -5  -2 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\\\ -7 \\end{pmatrix} = \\begin{pmatrix} 0 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot (-7) \\\\ 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot (-7) \\\\ -4 \\cdot 1 - 5 \\cdot 1 - 2 \\cdot (-7) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -7 \\\\ -4 - 5 + 14 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -7 \\\\ 5 \\end{pmatrix}\n$$\n现在，我们组装能控性矩阵 $\\mathcal{C}$：\n$$\n\\mathcal{C} = \\begin{pmatrix} 0  1  1 \\\\ 1  1  -7 \\\\ 1  -7  5 \\end{pmatrix}\n$$\n为了确定 $\\mathcal{C}$ 的秩，我们计算其行列式。对于方阵，非零行列式意味着它是满秩的。\n$$\n\\det(\\mathcal{C}) = 0 \\cdot \\det\\begin{pmatrix} 1  -7 \\\\ -7  5 \\end{pmatrix} - 1 \\cdot \\det\\begin{pmatrix} 1  -7 \\\\ 1  5 \\end{pmatrix} + 1 \\cdot \\det\\begin{pmatrix} 1  1 \\\\ 1  -7 \\end{pmatrix}\n$$\n$$\n\\det(\\mathcal{C}) = 0 - 1 \\cdot (1 \\cdot 5 - (-7) \\cdot 1) + 1 \\cdot (1 \\cdot (-7) - 1 \\cdot 1)\n$$\n$$\n\\det(\\mathcal{C}) = -(5+7) + (-7-1) = -12 - 8 = -20\n$$\n由于 $\\det(\\mathcal{C}) = -20 \\neq 0$，矩阵 $\\mathcal{C}$ 是满秩的，即 $\\text{rank}(\\mathcal{C}) = 3$。因为这等于状态维数 $n=3$，所以该系统是完全能控的。\n\n接下来，我们验证系统的能观性。一个系统是完全能观的，当且仅当其能观性矩阵 $\\mathcal{O}$ 是满秩的，即 $\\text{rank}(\\mathcal{O}) = n$。对于一个阶数为 $n=3$ 的系统，其能观性矩阵由下式给出：\n$$\n\\mathcal{O} = \\begin{pmatrix} C \\\\ CA \\\\ CA^2 \\end{pmatrix}\n$$\n我们计算必要的组成部分：\n第一行是矩阵 $C$ 本身：\n$$\nC = \\begin{pmatrix} 1  0  2 \\end{pmatrix}\n$$\n第二行是乘积 $CA$：\n$$\nCA = \\begin{pmatrix} 1  0  2 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ -4  -5  -2 \\end{pmatrix} = \\begin{pmatrix} 1 \\cdot 0 + 0 \\cdot 0 + 2 \\cdot (-4)  1 \\cdot 1 + 0 \\cdot 0 + 2 \\cdot (-5)  1 \\cdot 0 + 0 \\cdot 1 + 2 \\cdot (-2) \\end{pmatrix} = \\begin{pmatrix} -8  -9  -4 \\end{pmatrix}\n$$\n第三行是乘积 $CA^2 = (CA)A$：\n$$\nCA^2 = \\begin{pmatrix} -8  -9  -4 \\end{pmatrix} \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ -4  -5  -2 \\end{pmatrix} = \\begin{pmatrix} (-8) \\cdot 0 + (-9) \\cdot 0 + (-4) \\cdot (-4)  (-8) \\cdot 1 + (-9) \\cdot 0 + (-4) \\cdot (-5)  (-8) \\cdot 0 + (-9) \\cdot 1 + (-4) \\cdot (-2) \\end{pmatrix} = \\begin{pmatrix} 16  12  -1 \\end{pmatrix}\n$$\n现在，我们组装能观性矩阵 $\\mathcal{O}$：\n$$\n\\mathcal{O} = \\begin{pmatrix} 1  0  2 \\\\ -8  -9  -4 \\\\ 16  12  -1 \\end{pmatrix}\n$$\n为了确定 $\\mathcal{O}$ 的秩，我们计算其行列式：\n$$\n\\det(\\mathcal{O}) = 1 \\cdot \\det\\begin{pmatrix} -9  -4 \\\\ 12  -1 \\end{pmatrix} - 0 \\cdot \\det\\begin{pmatrix} -8  -4 \\\\ 16  -1 \\end{pmatrix} + 2 \\cdot \\det\\begin{pmatrix} -8  -9 \\\\ 16  12 \\end{pmatrix}\n$$\n$$\n\\det(\\mathcal{O}) = 1 \\cdot ((-9)(-1) - (-4)(12)) + 2 \\cdot ((-8)(12) - (-9)(16))\n$$\n$$\n\\det(\\mathcal{O}) = (9 + 48) + 2(-96 + 144) = 57 + 2(48) = 57 + 96 = 153\n$$\n由于 $\\det(\\mathcal{O}) = 153 \\neq 0$，矩阵 $\\mathcal{O}$ 是满秩的，即 $\\text{rank}(\\mathcal{O}) = 3$。因为这等于状态维数 $n=3$，所以该系统是完全能观的。\n\n由于该系统既是完全能控的又是完全能观的，给定的状态空间实现 $(A, B, C)$ 是最小实现。\n麦克米兰阶数 $n_{\\min}$ 定义为最小实现的阶数。因为给定的实现是最小实现，所以它的阶数就是麦克米兰阶数。状态向量为 $x \\in \\mathbb{R}^3$，所以系统的阶数为 $n=3$。\n因此，麦克米兰阶数为 $n_{\\min} = 3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在信息物理系统中，许多关键的内部状态往往无法直接测量。本练习提供了一个实践性强的计算任务：设计一个龙伯格（Luenberger）观测器来估计这些“隐藏”的状态。通过编写仿真程序，你将亲手探索观测器增益的配置如何决定估计误差的动态演化，这是开发功能完备的数字孪生体的一项核心技能。",
            "id": "4229638",
            "problem": "考虑一个适用于信息物理系统及其数字孪生的离散时间线性时不变状态空间模型，其状态 $x_k \\in \\mathbb{R}^n$、输入 $u_k \\in \\mathbb{R}^m$ 和测量输出 $y_k \\in \\mathbb{R}^p$ 由法则 $x_{k+1} = A x_k + B u_k$ 和 $y_k = C x_k$ 定义，其中 $A \\in \\mathbb{R}^{n \\times n}$、$B \\in \\mathbb{R}^{n \\times m}$ 和 $C \\in \\mathbb{R}^{p \\times n}$ 是常数矩阵。一个观测器被用来生成状态估计值 $\\hat{x}_k \\in \\mathbb{R}^n$，该估计值由相同的输入和测量输出通过标准观测器更新法则驱动。由此，定义估计误差 $e_k := x_k - \\hat{x}_k$。仅以所提供的系统和观测器结构为基础，推导线性估计误差动态方程，并确定主导 $e_k$ 演化的相关转移特性。\n\n实现一个程序，对于一个固定的对象和测量模型，在 $K$ 个离散时间步长上仿真真实系统和观测器，并计算：\n1. 由系统矩阵和观测器增益导出的线性误差传播算子的谱半径（记为 $\\rho$）。\n2. 最终估计误差的二范数 $\\lVert e_K \\rVert_2$。\n3. 在仿真时间范围内，单步误差递推的最大二范数残差，定义为 $\\max_{k \\in \\{1,\\dots,K\\}} \\lVert e_k - \\text{(由 } e_{k-1}\\text{ 预测的单步误差传播)} \\rVert_2$。\n\n本问题中所有量均为无量纲，因此不需要物理单位或角度单位。\n\n对所有测试用例使用以下共享的固定对象、测量和仿真参数：\n- 状态维度 $n = 2$，输入维度 $m = 1$，输出维度 $p = 1$。\n- 系统矩阵 $A = \\begin{bmatrix} 0.8  0.1 \\\\ 0.0  0.9 \\end{bmatrix}$，$B = \\begin{bmatrix} 0.1 \\\\ 0.05 \\end{bmatrix}$，$C = \\begin{bmatrix} 1.0  0.0 \\end{bmatrix}$。\n- 仿真时间范围 $K = 20$。\n- 初始真实状态 $x_0 = \\begin{bmatrix} 1.0 \\\\ -1.0 \\end{bmatrix}$ 和初始观测器状态 $\\hat{x}_0 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$。\n- 确定性输入序列 $u_k = 0.1 k$，对于 $k \\in \\{0,1,2,\\dots,K-1\\}$。\n\n定义一个包含四个观测器增益的测试套件，以探究误差动态的不同区域：\n- 案例 1（标称稳定）：$L^{(1)} = \\begin{bmatrix} 0.3 \\\\ 0.2 \\end{bmatrix}$。\n- 案例 2（临界边界）：$L^{(2)} = \\begin{bmatrix} -0.2 \\\\ 0.0 \\end{bmatrix}$。\n- 案例 3（不稳定）：$L^{(3)} = \\begin{bmatrix} -0.5 \\\\ 0.0 \\end{bmatrix}$。\n- 案例 4（无校正）：$L^{(4)} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$。\n\n对于每个案例，在共享的时间范围内运行对象-观测器仿真，并按上述顺序计算三个量。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个包含三个浮点数的列表，顺序为 $[\\rho,\\lVert e_K \\rVert_2,\\text{max residual}]$。例如，输出格式必须是 $[[\\rho_1,\\lVert e_K \\rVert_{2,1},r^{\\max}_1],[\\rho_2,\\lVert e_K \\rVert_{2,2},r^{\\max}_2],[\\rho_3,\\lVert e_K \\rVert_{2,3},r^{\\max}_3],[\\rho_4,\\lVert e_K \\rVert_{2,4},r^{\\max}_4]]$。所有浮点数表示为四舍五入到六位小数。",
            "solution": "该问题是适定的、有科学依据的，并且包含了唯一解所需的所有信息。因此，它被认为是有效的。解决方案首先推导理论误差动态，然后通过仿真实现来计算所需的量。\n\n该系统是一个离散时间线性时不变（LTI）模型，由下式给出：\n状态演化：$x_{k+1} = A x_k + B u_k$\n测量：$y_k = C x_k$\n\n采用标准 Luenberger 观测器来估计状态 $x_k$。观测器的状态估计值 $\\hat{x}_k$ 根据以下方式演化：\n观测器演化：$\\hat{x}_{k+1} = A \\hat{x}_k + B u_k + L(y_k - \\hat{y}_k)$\n其中 $L$ 是观测器增益矩阵，$\\hat{y}_k$ 是估计的输出，定义为：\n估计的测量：$\\hat{y}_k = C \\hat{x}_k$\n\n估计误差定义为 $e_k := x_k - \\hat{x}_k$。\n\n**1. 线性估计误差动态的推导**\n\n我们旨在找到关于前一时刻误差 $e_k$ 的误差演化表达式 $e_{k+1}$。我们从 $e_{k+1}$ 的定义开始：\n$$\ne_{k+1} = x_{k+1} - \\hat{x}_{k+1}\n$$\n代入状态和观测器的演化方程：\n$$\ne_{k+1} = (A x_k + B u_k) - (A \\hat{x}_k + B u_k + L(y_k - \\hat{y}_k))\n$$\n包含输入 $B u_k$ 的项相互抵消。这是该观测器设计的一个关键特性，使得误差动态与系统输入 $u_k$ 无关。\n$$\ne_{k+1} = A x_k - A \\hat{x}_k - L(y_k - \\hat{y}_k)\n$$\n从前两项中提出矩阵 $A$：\n$$\ne_{k+1} = A(x_k - \\hat{x}_k) - L(y_k - \\hat{y}_k)\n$$\n代入测量值 $y_k$ 和估计测量值 $\\hat{y}_k$ 的定义：\n$$\ne_{k+1} = A(x_k - \\hat{x}_k) - L(C x_k - C \\hat{x}_k)\n$$\n在括号内提出矩阵 $C$：\n$$\ne_{k+1} = A(x_k - \\hat{x}_k) - L C (x_k - \\hat{x}_k)\n$$\n注意到项 $(x_k - \\hat{x}_k)$ 是误差 $e_k$ 的定义：\n$$\ne_{k+1} = A e_k - L C e_k\n$$\n最后，提出误差向量 $e_k$ 以获得线性估计误差动态：\n$$\ne_{k+1} = (A - LC) e_k\n$$\n这是一个线性齐次差分方程。矩阵 $A_e := (A - LC)$ 是**线性误差传播算子**。从任意初始条件 $e_0$ 开始的估计误差演化由 $e_k = (A_e)^k e_0$ 给出。\n\n误差的转移特性由矩阵 $A_e$ 的特征值决定。当且仅当 $A_e$ 的所有特征值的模都小于1时，误差 $e_k$ 才会在 $k \\to \\infty$ 时收敛到零。这个条件等价于陈述 $A_e$ 的谱半径（记为 $\\rho(A_e)$）必须小于1。谱半径定义为 $\\rho(A_e) = \\max_i |\\lambda_i|$，其中 $\\lambda_i$ 是 $A_e$ 的特征值。\n\n**2. 仿真和计算计划**\n\n程序将对四个指定的观测器增益 $L^{(j)}$ 中的每一个实现以下逻辑：\n\n**量1：谱半径 $\\rho$**\n对于每个增益 $L$，构建误差传播算子 $A_e = A - LC$。然后，计算其特征值 $\\lambda_i$。谱半径为 $\\rho = \\max_i |\\lambda_i|$。这个值在仿真开始前为每个案例计算一次。\n\n**量2和3：$\\lVert e_K \\rVert_2$ 和最大残差的仿真**\n进行一个 $K=20$ 个时间步长的仿真。\n- **初始化**：设置初始真实状态 $x_0 = \\begin{bmatrix} 1.0 \\\\ -1.0 \\end{bmatrix}$ 和初始观测器状态 $\\hat{x}_0 = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$。初始误差为 $e_0 = x_0 - \\hat{x}_0 = \\begin{bmatrix} 1.0 \\\\ -1.0 \\end{bmatrix}$。变量 `max_residual_norm` 初始化为 $0.0$。\n- **迭代**：一个循环从 $k=0$ 运行到 $K-1=19$。在每一步中：\n    a. 当前误差为 $e_k = x_k - \\hat{x}_k$。\n    b. 使用推导出的动态方程预测下一步误差：$e_{k+1}^{\\text{pred}} = A_e e_k$。\n    c. 使用各自的更新法则和输入 $u_k = 0.1k$ 将系统和观测器向前推进一个步长：\n       $x_{k+1} = A x_k + B u_k$\n       $\\hat{x}_{k+1} = A \\hat{x}_k + B u_k + L(C x_k - C \\hat{x}_k)$\n    d. 从仿真状态计算出实际的下一步误差：$e_{k+1}^{\\text{sim}} = x_{k+1} - \\hat{x}_{k+1}$。\n    e. 单步误差递推的残差是仿真误差和预测误差之间的差值：$\\text{residual}_k = e_{k+1}^{\\text{sim}} - e_{k+1}^{\\text{pred}}$。\n    f. 计算该残差的二范数 $\\lVert \\text{residual}_k \\rVert_2$，并与 `max_residual_norm` 比较，如果新的范数更大，则更新该值。\n- **最终确定**：循环完成后（在 $k=19$ 时），最终状态为 $x_{20}$ 和 $\\hat{x}_{20}$。\n    a. 最终估计误差为 $e_K = e_{20} = x_{20} - \\hat{x}_{20}$。计算其二范数 $\\lVert e_K \\rVert_2$。\n    b. 在整个时间范围内记录的最大残差范数 $\\max_{k \\in \\{1,\\dots,K\\}} \\lVert \\text{residual}_{k-1} \\rVert_2$ 是第三个所需量。根据推导，该值应在数值上为零（受浮点精度限制），这验证了误差动态方程 $e_{k+1} = (A-LC)e_k$ 的正确性。\n\n为四个测试用例中的每一个收集三个计算出的量——$\\rho$、$\\lVert e_K \\rVert_2$ 和最大残差。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the observer simulation problem for four different observer gains.\n    \"\"\"\n    # Fixed plant, measurement, and simulation parameters\n    n = 2  # state dimension\n    m = 1  # input dimension\n    p = 1  # output dimension\n    \n    A = np.array([[0.8, 0.1], [0.0, 0.9]])\n    B = np.array([[0.1], [0.05]])\n    C = np.array([[1.0, 0.0]])\n    \n    K = 20  # Simulation horizon\n    x0 = np.array([[1.0], [-1.0]])\n    x_hat0 = np.array([[0.0], [0.0]])\n\n    # Test suite of four observer gains\n    test_cases = [\n        # Case 1 (nominal stable)\n        np.array([[0.3], [0.2]]),\n        # Case 2 (marginal boundary)\n        np.array([[-0.2], [0.0]]),\n        # Case 3 (unstable)\n        np.array([[-0.5], [0.0]]),\n        # Case 4 (no correction)\n        np.array([[0.0], [0.0]]),\n    ]\n\n    all_results = []\n    \n    for L in test_cases:\n        # 1. Compute the spectral radius of the error-propagation operator\n        A_e = A - L @ C\n        eigenvalues = np.linalg.eigvals(A_e)\n        rho = np.max(np.abs(eigenvalues))\n        \n        # Initialize simulation variables\n        x_k = x0.copy()\n        x_hat_k = x_hat0.copy()\n        max_residual_norm = 0.0\n        \n        # 2.  3. Simulate system and observer and compute error metrics\n        for k in range(K):\n            # Current error (e_k)\n            e_k = x_k - x_hat_k\n            \n            # Predict next error using the derived dynamics\n            # e_{k+1}^{pred} = (A - LC) * e_k\n            e_k_plus_1_pred = A_e @ e_k\n            \n            # Define input for the current step\n            u_k = 0.1 * k\n            \n            # System and observer updates\n            y_k = C @ x_k\n            \n            x_k_plus_1 = A @ x_k + B * u_k\n            x_hat_k_plus_1 = A @ x_hat_k + B * u_k + L @ (y_k - C @ x_hat_k)\n            \n            # Compute the actual error at the next step from simulation\n            e_k_plus_1_sim = x_k_plus_1 - x_hat_k_plus_1\n            \n            # Compute the residual of the one-step error recursion\n            residual = e_k_plus_1_sim - e_k_plus_1_pred\n            residual_norm = np.linalg.norm(residual)\n            \n            if residual_norm > max_residual_norm:\n                max_residual_norm = residual_norm\n            \n            # Update states for the next iteration\n            x_k = x_k_plus_1\n            x_hat_k = x_hat_k_plus_1\n            \n        # After the loop, k = K-1, and states are x_K, x_hat_K\n        # Compute final estimation error norm\n        e_K = x_k - x_hat_k\n        norm_e_K = np.linalg.norm(e_K)\n        \n        # Store results for the current case\n        case_results = [rho, norm_e_K, max_residual_norm]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res in all_results:\n        rho_str = f\"{res[0]:.6f}\"\n        norm_eK_str = f\"{res[1]:.6f}\"\n        max_res_str = f\"{res[2]:.6f}\"\n        formatted_results.append(f\"[{rho_str},{norm_eK_str},{max_res_str}]\")\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}