{
    "hands_on_practices": [
        {
            "introduction": "在现代信息物理系统中，将基于模型的（例如由数字孪生提供）前馈控制与传统的反馈控制相结合是一种常见且高效的策略。本练习旨在分析这种混合控制架构下的稳态跟踪误差，这是一个关键的性能指标。通过应用终值定理 ，您将推导出模型不精确性（物理设备与数字孪生之间的差异）和前馈增益如何直接影响系统对斜坡输入信号的长期跟踪能力，从而巩固您在复杂控制系统中的框图分析和工程应用能力。",
            "id": "4250801",
            "problem": "一个信息物理系统 (CPS) 使用数字孪生 (DT) 来辅助跟踪精密机电平台的指令位置轨迹。物理设备被建模为一个线性时不变系统，其传递函数为 $G_{p}(s) = \\frac{b}{s(s+a)}$，其中 $a > 0$ 且 $b > 0$。数字孪生 (DT) 模型为 $G_{t}(s) = \\frac{b}{s(s+a_{t})}$，其中 $a_{t} > 0$。控制架构由两条路径组成：基于 DT 的前馈和比例反馈。前馈输入为 $u_{\\mathrm{ff}}(s) = \\gamma G_{t}^{-1}(s) R(s)$，其中 $0 \\le \\gamma \\leq 1$ 是一个标量设计参数，$R(s)$ 是参考信号的拉普拉斯变换；反馈输入为 $u_{\\mathrm{fb}}(s) = k_{p}(R(s) - Y(s))$，其中 $k_{p} > 0$ 是比例增益，$Y(s)$ 是测量位置的拉普拉斯变换。设备输入为 $u(s) = u_{\\mathrm{ff}}(s) + u_{\\mathrm{fb}}(s)$，输出满足 $Y(s) = G_{p}(s) u(s)$。\n\n假设初始条件为零且闭环系统内部稳定。指令参考信号为斜坡函数 $r(t) = \\alpha t$（对于 $t \\geq 0$），斜率 $\\alpha > 0$。仅使用拉普拉斯变换的基本定义、线性时不变输入输出关系、稳态误差和终值定理，推导稳态跟踪误差 $e_{\\infty} = \\lim_{t \\to \\infty} e(t)$，其中 $e(t) = r(t) - y(t)$ 且 $y(t)$ 是物理输出。然后，使用参数 $a = 4$、$a_{t} = 3.8$、$b = 2$、$k_{p} = 20$、$\\gamma = 0.85$ 和 $\\alpha = 0.05$ 计算其数值。\n\n以米为单位表示最终的稳态误差。将答案四舍五入到四位有效数字。所有数学表达式、符号、变量、函数、运算符和数字都必须用 LaTeX 书写。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 第 1 步：提取已知条件\n- 物理设备传递函数：$G_{p}(s) = \\frac{b}{s(s+a)}$\n- 设备参数：$a > 0$, $b > 0$\n- 数字孪生 (DT) 模型传递函数：$G_{t}(s) = \\frac{b}{s(s+a_{t})}$\n- DT 参数：$a_{t} > 0$\n- 前馈输入：$u_{\\mathrm{ff}}(s) = \\gamma G_{t}^{-1}(s) R(s)$\n- 前馈设计参数：$0 \\le \\gamma \\leq 1$\n- 反馈输入：$u_{\\mathrm{fb}}(s) = k_{p}(R(s) - Y(s))$\n- 比例反馈增益：$k_{p} > 0$\n- 设备总输入：$u(s) = u_{\\mathrm{ff}}(s) + u_{\\mathrm{fb}}(s)$\n- 设备输出关系：$Y(s) = G_{p}(s) u(s)$\n- 参考输入：$r(t) = \\alpha t$（对于 $t \\geq 0$），其中 $\\alpha > 0$\n- 跟踪误差：$e(t) = r(t) - y(t)$\n- 目标：求稳态跟踪误差 $e_{\\infty} = \\lim_{t \\to \\infty} e(t)$。\n- 假设：零初始条件，闭环系统内部稳定。\n- 参数数值：$a = 4$, $a_{t} = 3.8$, $b = 2$, $k_{p} = 20$, $\\gamma = 0.85$, $\\alpha = 0.05$。\n- 输出要求：以米为单位表示最终答案，并四舍五入到四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据：** 该问题使用了线性时不变 (LTI) 控制理论的标准模型和原理。该控制架构涉及基于模型（数字孪生）的前馈补偿和比例反馈，是一种行之有效且具有科学依据的工程实践。\n- **适定性：** 提供了推导唯一解所需的所有必要参数、函数和条件。闭环稳定性的假设至关重要且已明确说明，这使得终值定理的使用是合理的。\n- **客观性：** 该问题使用精确的数学和工程术语进行陈述，没有任何主观或模棱两可的语言。\n\n### 第 3 步：结论与行动\n该问题是有效的，因为它具有科学依据、适定、客观且内部一致。将提供完整的解答。\n\n目标是求稳态跟踪误差 $e_{\\infty}$。我们首先推导拉普拉斯域中的跟踪误差表达式 $E(s) = \\mathcal{L}\\{e(t)\\}$。\n根据框图，设备输出 $Y(s)$ 为：\n$$Y(s) = G_p(s) U(s) = G_p(s) [U_{ff}(s) + U_{fb}(s)]$$\n代入前馈和反馈控制律：\n$$Y(s) = G_p(s) [\\gamma G_t^{-1}(s) R(s) + k_p(R(s) - Y(s))]$$\n将含有 $Y(s)$ 的项移到左边：\n$$Y(s) + k_p G_p(s) Y(s) = G_p(s) [\\gamma G_t^{-1}(s) + k_p] R(s)$$\n$$Y(s) [1 + k_p G_p(s)] = G_p(s) [\\gamma G_t^{-1}(s) + k_p] R(s)$$\n因此，从参考 $R(s)$ 到输出 $Y(s)$ 的闭环传递函数为：\n$$T_{cl}(s) = \\frac{Y(s)}{R(s)} = \\frac{G_p(s) [\\gamma G_t^{-1}(s) + k_p]}{1 + k_p G_p(s)}$$\n跟踪误差为 $E(s) = R(s) - Y(s) = (1 - T_{cl}(s)) R(s)$。从 $R(s)$ 到 $E(s)$ 的误差传递函数为：\n$$ \\frac{E(s)}{R(s)} = 1 - \\frac{G_p(s) [\\gamma G_t^{-1}(s) + k_p]}{1 + k_p G_p(s)} = \\frac{1 + k_p G_p(s) - \\gamma G_p(s)G_t^{-1}(s) - k_p G_p(s)}{1 + k_p G_p(s)} $$\n$$ \\frac{E(s)}{R(s)} = \\frac{1 - \\gamma G_p(s)G_t^{-1}(s)}{1 + k_p G_p(s)} $$\n代入 $G_p(s) = \\frac{b}{s(s+a)}$ 和 $G_t^{-1}(s) = \\frac{s(s+a_t)}{b}$：\n$$ \\frac{E(s)}{R(s)} = \\frac{1 - \\gamma \\frac{b}{s(s+a)} \\frac{s(s+a_t)}{b}}{1 + k_p \\frac{b}{s(s+a)}} = \\frac{1 - \\gamma \\frac{s+a_t}{s+a}}{\\frac{s(s+a) + k_p b}{s(s+a)}} $$\n$$ \\frac{E(s)}{R(s)} = \\frac{\\frac{(s+a) - \\gamma(s+a_t)}{s+a}}{\\frac{s^2 + as + k_p b}{s(s+a)}} = \\frac{s(1-\\gamma) + a - \\gamma a_t}{s^2 + as + k_p b} $$\n参考输入为斜坡函数 $r(t) = \\alpha t$，其拉普拉斯变换为 $R(s) = \\frac{\\alpha}{s^2}$。因此，误差信号为：\n$$ E(s) = \\frac{s(1-\\gamma) + a - \\gamma a_t}{s^2 + as + k_p b} \\cdot \\frac{\\alpha}{s^2} $$\n注意，上面的误差传递函数在分子中没有 $s$ 的因子，所以对于斜坡输入，系统将产生一个非零的稳态误差。\n稳态误差 $e_{\\infty}$ 可通过终值定理求得，$e_{\\infty} = \\lim_{t \\to \\infty} e(t) = \\lim_{s \\to 0} sE(s)$。该定理的适用性由闭环系统稳定的假设保证。\n$$ e_{\\infty} = \\lim_{s \\to 0} s \\left[ \\frac{s(1-\\gamma) + a - \\gamma a_t}{s^2 + as + k_p b} \\frac{\\alpha}{s^2} \\right] $$\n$$ e_{\\infty} = \\lim_{s \\to 0} \\left[ \\frac{\\alpha (s(1-\\gamma) + a - \\gamma a_t)}{s(s^2 + as + k_p b)} \\right] $$\n这个表达式有一个 $s$ 在分母中，暗示误差会趋于无穷大。让我们重新检查误差传递函数的推导。\n\n啊，在从 $Y(s)$ 到 $E(s)$ 的推导中有一个代数错误。让我们重新仔细推导 $E(s) = R(s) - Y(s)$。\n$$E(s) = \\left(1 - \\frac{Y(s)}{R(s)}\\right)R(s) = \\left(1 - \\frac{\\gamma s^2 + \\gamma a_t s + bk_p}{s^2+as+bk_p}\\right) R(s)$$\n$$E(s) = \\left(\\frac{s^2+as+bk_p - (\\gamma s^2 + \\gamma a_t s + bk_p)}{s^2+as+bk_p}\\right) R(s)$$\n$$E(s) = \\frac{(1-\\gamma)s^2 + (a-\\gamma a_t)s}{s^2+as+bk_p} R(s) = \\frac{s[(1-\\gamma)s + (a-\\gamma a_t)]}{s^2+as+bk_p} R(s)$$\n这个表达式在分子中有一个 $s$ 因子。现在，代入 $R(s) = \\alpha/s^2$：\n$$E(s) = \\frac{s[(1-\\gamma)s + (a-\\gamma a_t)]}{s^2+as+bk_p} \\frac{\\alpha}{s^2} = \\frac{\\alpha [(1-\\gamma)s + (a-\\gamma a_t)]}{s(s^2+as+bk_p)}$$\n现在应用终值定理：\n$$e_{\\infty} = \\lim_{s \\to 0} s E(s) = \\lim_{s \\to 0} s \\left[ \\frac{\\alpha [(1-\\gamma)s + (a-\\gamma a_t)]}{s(s^2+as+bk_p)} \\right]$$\n$$e_{\\infty} = \\lim_{s \\to 0} \\frac{\\alpha [(1-\\gamma)s + (a-\\gamma a_t)]}{s^2+as+bk_p}$$\n将 $s=0$ 代入表达式中：\n$$e_{\\infty} = \\frac{\\alpha [(1-\\gamma)\\cdot 0 + (a - \\gamma a_t)]}{0^2 + a\\cdot 0 + bk_p} = \\frac{\\alpha (a - \\gamma a_t)}{bk_p}$$\n这个结果是正确的。现在让我们代入给定的数值：\n- $a = 4$\n- $a_{t} = 3.8$\n- $b = 2$\n- $k_{p} = 20$\n- $\\gamma = 0.85$\n- $\\alpha = 0.05$\n\n$$e_{\\infty} = \\frac{0.05 (4 - (0.85)(3.8))}{(2)(20)}$$\n首先，计算括号中的项：\n$$4 - (0.85)(3.8) = 4 - 3.23 = 0.77$$\n现在，将此代回 $e_{\\infty}$ 的表达式中：\n$$e_{\\infty} = \\frac{0.05 \\times 0.77}{40}$$\n$$e_{\\infty} = \\frac{0.0385}{40}$$\n$$e_{\\infty} = 0.0009625$$\n题目要求答案以米为单位表示，并四舍五入到四位有效数字。计算出的值 $0.0009625$ 已经有四位有效数字（$9$, $6$, $2$, $5$）。因此，无需进一步四舍五入。\n最终的稳态误差为 $0.0009625$ 米。",
            "answer": "$$\\boxed{0.0009625}$$"
        },
        {
            "introduction": "在许多高精度应用中，如机器人或精密制造，瞬态响应中的超调是必须严格控制的。本练习介绍了一种强大的技术——输入整形，它可以在不改变反馈控制器的情况下主动改善系统响应。该方法依据线性系统的叠加原理，利用精确的系统模型（如数字孪生所提供），通过精心设计输入信号来预测并抵消不希望的振荡。这项从分析到设计的实践，展示了如何利用对系统时域特性的深刻理解来主动优化其动态行为。",
            "id": "4250886",
            "problem": "一个信息物理伺服系统由一个数字孪生（DT）监控。该数字孪生已识别出，在闭环运行下，从参考输入到输出的主导动态特性可以由一个欠阻尼二阶模态很好地近似，其传递函数为\n$$\nT(s) \\;=\\; \\frac{\\omega_{n}^{2}}{s^{2} + 2\\,\\zeta\\,\\omega_{n}\\,s + \\omega_{n}^{2}},\n$$\n其中 $0 < \\zeta < 1$ 是阻尼比，$\\omega_{n} > 0$ 是自然频率。该数字孪生将用于通过对参考信号进行时域整形来预测和限制超调量。\n\n为了在限制超调量的同时保持快速收敛，我们施加以下性能指标：对于所有 $t \\ge \\tau$，输出不得超过与单位参考信号相关的稳态值（即在 $t=\\tau$ 之后零超调）。考虑一个由两个时移阶跃信号构成的整形单位参考信号\n$$\nr(t) \\;=\\; A_{1}\\,H(t) \\;+\\; A_{2}\\,H(t-\\tau),\n$$\n其中 $H(\\cdot)$ 表示亥维赛阶跃函数，$A_{1}$ 和 $A_{2}$ 是满足 $A_{1} + A_{2} = 1$ 的恒定增益（以确保单位稳态值），$\\tau > 0$ 是一个设计延迟，通过数字孪生的模态估计进行预测确定。输出为 $y(t) = (T * r)(t)$，其中 $*$ 表示卷积。\n\n仅从所述模型、线性时不变系统的基本性质以及欠阻尼二阶阶跃响应的规范时域形式出发，推导关于 $A_{1}$、$A_{2}$ 和 $\\tau$ 的条件，使得对于所有 $t \\ge \\tau$，输出是无振荡的并且不超过其单位稳态值。然后，用 $\\zeta$ 和 $\\omega_{n}$ 表示 $A_{1}$、$A_{2}$ 和 $\\tau$ 的闭式表达式。角度必须以弧度为单位。最终的时间延迟以秒为单位表示。无需进行数值四舍五入；请提供精确的解析表达式。",
            "solution": "问题要求解整形参考输入 $r(t) = A_{1}\\,H(t) + A_{2}\\,H(t-\\tau)$ 的参数 $A_1$、$A_2$ 和 $\\tau$，使得传递函数为 $T(s)$ 的二阶系统的输出 $y(t)$ 在所有时间 $t \\ge \\tau$ 上是无振荡的并且不超过其稳态值。该系统由下式描述\n$$\nT(s) = \\frac{\\omega_{n}^{2}}{s^{2} + 2\\zeta\\omega_{n}s + \\omega_{n}^{2}}\n$$\n其中 $0 < \\zeta < 1$ 且 $\\omega_{n} > 0$。输入参数必须满足 $A_1 + A_2 = 1$ 和 $\\tau > 0$。\n\n首先，我们确定系统对单位阶跃输入 $H(t)$ 的响应。单位阶跃输入的拉普拉斯变换是 $\\frac{1}{s}$。在拉普拉斯域中的输出是 $Y_{step}(s) = T(s) \\frac{1}{s}$。拉普拉斯逆变换给出时域单位阶跃响应 $y_{step}(t)$。欠阻尼二阶系统的规范形式是\n$$\ny_{step}(t) = 1 - \\frac{\\exp(-\\zeta\\omega_n t)}{\\sqrt{1-\\zeta^2}} \\sin(\\omega_d t + \\theta)\n$$\n其中 $\\omega_d = \\omega_n\\sqrt{1-\\zeta^2}$ 是阻尼自然频率，$\\theta = \\arccos(\\zeta)$ 是一个相位角。该表达式对 $t \\ge 0$ 有效。\n\n系统的输入是 $r(t) = A_1 H(t) + A_2 H(t-\\tau)$。由于系统是线性时不变的（LTI），我们可以使用叠加原理来求总输出 $y(t)$。输出是各输入分量响应的总和：\n$$\ny(t) = A_1 y_{step}(t) + A_2 y_{step}(t-\\tau) H(t-\\tau)\n$$\n\n我们关心系统在 $t \\ge \\tau$ 时的行为。在这个时间区间内，$H(t-\\tau)=1$，所以输出的表达式变为：\n$$\ny(t) = A_1 \\left(1 - \\frac{\\exp(-\\zeta\\omega_n t)}{\\sqrt{1-\\zeta^2}} \\sin(\\omega_d t + \\theta)\\right) + A_2 \\left(1 - \\frac{\\exp(-\\zeta\\omega_n (t-\\tau))}{\\sqrt{1-\\zeta^2}} \\sin(\\omega_d (t-\\tau) + \\theta)\\right)\n$$\n使用给定的约束条件 $A_1 + A_2 = 1$，我们可以简化表达式：\n$$\ny(t) = (A_1 + A_2) - \\frac{1}{\\sqrt{1-\\zeta^2}} \\left[ A_1 \\exp(-\\zeta\\omega_n t) \\sin(\\omega_d t + \\theta) + A_2 \\exp(-\\zeta\\omega_n (t-\\tau)) \\sin(\\omega_d (t-\\tau) + \\theta) \\right]\n$$\n$$\ny(t) = 1 - \\frac{\\exp(-\\zeta\\omega_n t)}{\\sqrt{1-\\zeta^2}} \\left[ A_1 \\sin(\\omega_d t + \\theta) + A_2 \\exp(\\zeta\\omega_n \\tau) \\sin(\\omega_d t - \\omega_d \\tau + \\theta) \\right]\n$$\n性能指标要求对于所有 $t \\ge \\tau$，输出是无振荡的并且不超过其单位稳态值。这意味着响应的瞬态（振荡）部分对于所有 $t \\ge \\tau$ 必须恒等于零。因此，方括号中的项对于所有 $t \\ge \\tau$ 必须为零：\n$$\nA_1 \\sin(\\omega_d t + \\theta) + A_2 \\exp(\\zeta\\omega_n \\tau) \\sin(\\omega_d t - \\omega_d \\tau + \\theta) = 0\n$$\n为了分析这个方程，我们使用两角差的正弦三角恒等式 $\\sin(a-b) = \\sin(a)\\cos(b) - \\cos(a)\\sin(b)$。令 $\\alpha = \\omega_d t + \\theta$，方程变为：\n$$\nA_1 \\sin(\\alpha) + A_2 \\exp(\\zeta\\omega_n \\tau) \\left( \\sin(\\alpha)\\cos(\\omega_d \\tau) - \\cos(\\alpha)\\sin(\\omega_d \\tau) \\right) = 0\n$$\n对含有 $\\sin(\\alpha)$ 和 $\\cos(\\alpha)$ 的项进行分组：\n$$\n\\sin(\\alpha) \\left( A_1 + A_2 \\exp(\\zeta\\omega_n \\tau) \\cos(\\omega_d \\tau) \\right) - \\cos(\\alpha) \\left( A_2 \\exp(\\zeta\\omega_n \\tau) \\sin(\\omega_d \\tau) \\right) = 0\n$$\n为了使该方程对所有 $t \\ge \\tau$（因此对一个连续的 $\\alpha$ 范围）成立，线性无关函数 $\\sin(\\alpha)$ 和 $\\cos(\\alpha)$ 的系数必须都为零。这给了我们一个由两个方程组成的方程组：\n1. $A_1 + A_2 \\exp(\\zeta\\omega_n \\tau) \\cos(\\omega_d \\tau) = 0$\n2. $A_2 \\exp(\\zeta\\omega_n \\tau) \\sin(\\omega_d \\tau) = 0$\n\n从方程（2）可知，因为我们正在构建一个两步输入，我们必须有 $A_2 \\neq 0$。另外，$\\exp(\\zeta\\omega_n \\tau)$ 总是正的。因此，我们必须有：\n$$\n\\sin(\\omega_d \\tau) = 0\n$$\n这意味着 $\\omega_d \\tau = k\\pi$，其中 k 是某个整数。由于 $\\tau > 0$ 且 $\\omega_d > 0$，k 必须是正整数。为了实现最快响应，我们选择 $\\tau$ 的最小正值，这对应于 $k=1$。\n$$\n\\omega_d \\tau = \\pi \\implies \\tau = \\frac{\\pi}{\\omega_d}\n$$\n代入 $\\omega_d = \\omega_n \\sqrt{1-\\zeta^2}$，我们得到延迟 $\\tau$ 的表达式：\n$$\n\\tau = \\frac{\\pi}{\\omega_n \\sqrt{1-\\zeta^2}}\n$$\n当 $\\omega_d \\tau = \\pi$ 时，我们有 $\\cos(\\omega_d \\tau) = \\cos(\\pi) = -1$。将此代入方程（1）：\n$$\nA_1 + A_2 \\exp(\\zeta\\omega_n \\tau) (-1) = 0 \\implies A_1 = A_2 \\exp(\\zeta\\omega_n \\tau)\n$$\n现在我们使用约束条件 $A_1+A_2=1$。代入 $A_1$ 的表达式：\n$$\nA_2 \\exp(\\zeta\\omega_n \\tau) + A_2 = 1 \\implies A_2 (1 + \\exp(\\zeta\\omega_n \\tau)) = 1\n$$\n这给出了 $A_2$ 的表达式：\n$$\nA_2 = \\frac{1}{1 + \\exp(\\zeta\\omega_n \\tau)}\n$$\n然后，从 $A_1=1-A_2$ 中求出 $A_1$：\n$$\nA_1 = 1 - \\frac{1}{1 + \\exp(\\zeta\\omega_n \\tau)} = \\frac{1 + \\exp(\\zeta\\omega_n \\tau) - 1}{1 + \\exp(\\zeta\\omega_n \\tau)} = \\frac{\\exp(\\zeta\\omega_n \\tau)}{1 + \\exp(\\zeta\\omega_n \\tau)}\n$$\n最后，我们用基本参数 $\\zeta$ 和 $\\omega_n$ 来表示指数的参数 $\\zeta\\omega_n \\tau$：\n$$\n\\zeta\\omega_n \\tau = \\zeta\\omega_n \\left( \\frac{\\pi}{\\omega_n \\sqrt{1-\\zeta^2}} \\right) = \\frac{\\zeta\\pi}{\\sqrt{1-\\zeta^2}}\n$$\n将此代回 $A_1$ 和 $A_2$ 的表达式，我们得到最终的闭式解。\n\n所需的表达式为：\n对于延迟 $\\tau$：\n$$\n\\tau = \\frac{\\pi}{\\omega_n \\sqrt{1-\\zeta^2}}\n$$\n对于增益 $A_1$：\n$$\nA_1 = \\frac{\\exp\\left(\\frac{\\zeta\\pi}{\\sqrt{1-\\zeta^2}}\\right)}{1 + \\exp\\left(\\frac{\\zeta\\pi}{\\sqrt{1-\\zeta^2}}\\right)}\n$$\n对于增益 $A_2$：\n$$\nA_2 = \\frac{1}{1 + \\exp\\left(\\frac{\\zeta\\pi}{\\sqrt{1-\\zeta^2}}\\right)}\n$$\n这些选择确保了对于 $t \\ge \\tau$，对第一个和第二个阶跃输入的响应的振荡分量完全相互抵消，从而得到 $y(t) = 1$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{\\exp\\left(\\frac{\\zeta\\pi}{\\sqrt{1-\\zeta^2}}\\right)}{1 + \\exp\\left(\\frac{\\zeta\\pi}{\\sqrt{1-\\zeta^2}}\\right)} & \\frac{1}{1 + \\exp\\left(\\frac{\\zeta\\pi}{\\sqrt{1-\\zeta^2}}\\right)} & \\frac{\\pi}{\\omega_n \\sqrt{1-\\zeta^2}} \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "理论分析与设计往往基于理想的连续时间模型，然而，现实世界的信息物理系统是在数字硬件上实现的，这必然会引入采样和量化等效应。本练习将引导您构建一个离散时间仿真，以研究测量和驱动信号的量化噪声如何影响关键的时域性能指标，如超调量、稳定时间和稳态误差。这项综合性实践  是连接理论与实现的桥梁，它提供了模拟数字控制系统并量化硬件限制所致性能退化的宝贵经验，是信息物理系统与数字孪生工程师必备的技能。",
            "id": "4250806",
            "problem": "考虑一个信息物理系统，该系统被建模为一个带有比例-微分控制器的质量-弹簧-阻尼系统，在采样传感和均匀量化驱动下运行，代表了与物理设备交互的数字孪生。目标是量化测量和驱动通道中的量化对时域性能的影响。\n\n从受控制力作用的单自由度质量-弹簧-阻尼系统的牛顿第二定律出发。对于质量为 $m$ 千克，阻尼系数为 $c$ 牛顿-秒/米，刚度为 $k$ 牛顿/米的系统，其物理定律为\n$$\nm \\ddot{x}(t) + c \\dot{x}(t) + k x(t) = u(t),\n$$\n其中 $x(t)$ 是以米为单位的位置，$u(t)$ 是以牛顿为单位的施加控制力。引入状态向量 $\\mathbf{x}_1(t) = x(t)$ 和 $\\mathbf{x}_2(t) = \\dot{x}(t)$ 以获得状态空间形式：\n$$\n\\dot{\\mathbf{x}}(t) = A \\mathbf{x}(t) + B u(t), \\quad y(t) = C \\mathbf{x}(t),\n$$\n其中\n$$\nA = \\begin{bmatrix} 0 & 1 \\\\ -\\frac{k}{m} & -\\frac{c}{m} \\end{bmatrix}, \\quad B = \\begin{bmatrix} 0 \\\\ \\frac{1}{m} \\end{bmatrix}, \\quad C = \\begin{bmatrix} 1 & 0 \\end{bmatrix}.\n$$\n参考指令是一个恒定的阶跃信号 $r(t) = A_r$ 米，适用于所有 $t \\ge 0$。该系统以采样周期 $T_s$ 秒通过零阶保持器进行采样。测量值以步长 $q_y$ 米进行量化，驱动值以步长 $q_u$ 牛顿进行量化，两者都使用由下式定义的中置型均匀量化：\n$$\nQ_q(x) = q \\cdot \\mathrm{round}\\!\\left(\\frac{x}{q}\\right),\n$$\n并约定 $Q_0(x) = x$。\n\n控制器在每个采样点 $k$ 根据量化后的测量值计算比例-微分控制输入：\n$$\ny_q[k] = Q_{q_y}\\big(y(k T_s)\\big), \\quad \\Delta y_q[k] = \\frac{y_q[k] - y_q[k-1]}{T_s},\n$$\n$$\nu[k] = K_p \\big(A_r - y_q[k]\\big) - K_d \\,\\Delta y_q[k], \\quad u_q[k] = Q_{q_u}\\big(u[k]\\big),\n$$\n并且在 $t \\in [k T_s, (k+1) T_s)$ 时间内，被控对象的输入保持恒定为 $u(t) = u_q[k]$。\n\n使用矩阵指数对零阶保持下的连续时间模型进行离散化。对于一个增广矩阵\n$$\n\\mathcal{M} = \\begin{bmatrix} A & B \\\\ 0 & 0 \\end{bmatrix},\n$$\n定义\n$$\n\\exp\\!\\big(\\mathcal{M} T_s\\big) = \\begin{bmatrix} A_d & B_d \\\\ 0 & I \\end{bmatrix},\n$$\n从而采样动态变为\n$$\n\\mathbf{x}[k+1] = A_d \\mathbf{x}[k] + B_d \\, u_q[k], \\quad y[k] = C \\mathbf{x}[k].\n$$\n\n时域性能指标必须根据在 $T_{\\mathrm{end}}$ 秒的有限时间范围内采样的输出 $\\{y[k]\\}_{k=0}^{N-1}$ 计算得出，其中 $N = \\left\\lfloor \\frac{T_{\\mathrm{end}}}{T_s} \\right\\rfloor$。设估计的终值 $y_\\infty$ 是最后 $N_{\\mathrm{tail}}$ 个样本的平均值，其中\n$$\nN_{\\mathrm{tail}} = \\max\\!\\big(5, \\lfloor 0.1 N \\rfloor \\big),\n$$\n且\n$$\ny_\\infty = \\frac{1}{N_{\\mathrm{tail}}} \\sum_{j=N-N_{\\mathrm{tail}}}^{N-1} y[j].\n$$\n定义以下性能指标：\n- 超调量（以小数形式表示）：\n$$\nM_p = \\max\\!\\left(0,\\; \\frac{\\max_{0 \\le k  N} y[k] - y_\\infty}{\\left|y_\\infty\\right| + \\delta}\\right),\n$$\n其中 $\\delta$ 是一个小的正常数正则化常数，用于避免在退化情况下出现除以零的错误。\n- 稳定时间（单位：秒），容差为 $\\epsilon$（最终答案以秒表示）：\n$$\nT_{\\mathrm{set}} = \\min\\!\\left\\{k T_s \\,\\middle|\\, \\forall j \\ge k,\\; \\left|y[j] - y_\\infty\\right| \\le \\epsilon \\left|y_\\infty\\right|\\right\\},\n$$\n如果存在这样的 $k$；否则设置 $T_{\\mathrm{set}} = T_{\\mathrm{end}}$。同时报告一个布尔标志 $\\mathrm{settled}$，如果在时间范围内满足标准则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n- 稳态误差幅值（单位：米）：\n$$\ne_{\\mathrm{ss}} = \\left|A_r - y_\\infty\\right|.\n$$\n- 绝对误差积分（单位：米-秒）：\n$$\n\\mathrm{IAE} = \\sum_{k=0}^{N-1} \\left|A_r - y[k]\\right| T_s.\n$$\n\n实现一个程序，针对下面指定的每个测试用例，使用上述定义模拟采样量化的闭环动态，并计算元组 $[M_p, T_{\\mathrm{set}}, e_{\\mathrm{ss}}, \\mathrm{IAE}, \\mathrm{settled}]$。使用以下测试套件（所有量均采用一致的国际单位制；时间单位为秒；不使用角度）：\n\n- 用例 1（理想情况，中等量化）：\n  - $m = 1.0$, $c = 4.0$, $k = 100.0$, $K_p = 80.0$, $K_d = 15.0$, $A_r = 0.1$, $T_s = 0.01$, $q_y = 0.001$, $q_u = 0.01$, $T_{\\mathrm{end}} = 4.0$。\n- 用例 2（粗量化，可能在容差内无法稳定）：\n  - $m = 1.0$, $c = 4.0$, $k = 100.0$, $K_p = 80.0$, $K_d = 15.0$, $A_r = 0.1$, $T_s = 0.02$, $q_y = 0.05$, $q_u = 0.5$, $T_{\\mathrm{end}} = 4.0$。\n- 用例 3（无量化基准，更快采样）：\n  - $m = 1.0$, $c = 4.0$, $k = 100.0$, $K_p = 80.0$, $K_d = 15.0$, $A_r = 0.1$, $T_s = 0.005$, $q_y = 0.0$, $q_u = 0.0$, $T_{\\mathrm{end}} = 3.0$。\n- 用例 4（临界阻尼，中等量化）：\n  - $m = 1.0$, $c = 20.0$, $k = 100.0$, $K_p = 120.0$, $K_d = 30.0$, $A_r = 0.1$, $T_s = 0.01$, $q_y = 0.002$, $q_u = 0.02$, $T_{\\mathrm{end}} = 4.0$。\n\n使用容差 $\\epsilon = 0.02$ 和正则化常数 $\\delta = 10^{-9}$。初始化 $\\mathbf{x}[0] = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$，并为第一个差分设置 $y_q[-1] = Q_{q_y}(0)$。所有计算出的时间都必须以秒表示，并由自然的浮点表示法进行四舍五入。所有超调量和误差都必须以小数表示（而非百分比）。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身就是一个列表，形式为 $[[m_1,t_1,e_1,i_1,s_1],[m_2,t_2,e_2,i_2,s_2],\\dots]$。",
            "solution": "该问题已经过验证，被认为是有效的。它在科学上基于经典力学和控制理论的原理，具体地，是为一个带有比例-微分（PD）控制器的二阶线性时不变（LTI）系统建模。该问题引入了信息物理系统所特有的现实世界复杂性，例如采样、零阶保持和量化，所有这些都得到了明确的定义。所有参数、初始条件和性能指标都得到了明确的规定，使得该问题是适定的和自洽的。所提供的数值是物理上现实的，任务是一个可验证和客观的直接模拟和分析。\n\n解决方案的步骤是，为每个指定的测试用例实现闭环系统的离散时间仿真，然后从得到的输出轨迹计算所需的性能指标。\n\n**1. 系统离散化**\n\n物理设备是一个由状态空间模型描述的连续时间LTI系统：\n$$\n\\dot{\\mathbf{x}}(t) = A \\mathbf{x}(t) + B u(t), \\quad y(t) = C \\mathbf{x}(t)\n$$\n其中矩阵定义为：\n$$\nA = \\begin{bmatrix} 0  1 \\\\ -k/m  -c/m \\end{bmatrix}, \\quad B = \\begin{bmatrix} 0 \\\\ 1/m \\end{bmatrix}, \\quad C = \\begin{bmatrix} 1  0 \\end{bmatrix}\n$$\n控制输入 $u(t)$ 由数字控制器生成，并通过零阶保持器（ZOH）施加，这意味着 $u(t)$ 在每个采样间隔 $T_s$ 内保持恒定。状态向量在这样一个区间内的演化由状态方程的解给出：\n$$\n\\mathbf{x}\\big((k+1)T_s\\big) = e^{A T_s} \\mathbf{x}(k T_s) + \\left(\\int_0^{T_s} e^{A\\tau} d\\tau\\right) B u(k T_s)\n$$\n其中 $u(t) = u(k T_s)$，适用于 $t \\in [k T_s, (k+1)T_s)$。使用增广矩阵的矩阵指数是寻找离散时间矩阵 $A_d$ 和 $B_d$ 的一种标准且数值稳健的方法。增广矩阵构造如下：\n$$\n\\mathcal{M} = \\begin{bmatrix} A  B \\\\ \\mathbf{0}  \\mathbf{0} \\end{bmatrix}\n$$\n其中状态维度为 $n=2$，输入维度为 $p=1$。因此，$\\mathcal{M}$ 是一个 $(n+p) \\times (n+p)$ 的矩阵。其矩阵指数为：\n$$\n\\exp(\\mathcal{M} T_s) = \\begin{bmatrix} A_d  B_d \\\\ \\mathbf{0}  I \\end{bmatrix}\n$$\n此计算得出了带有ZOH系统的精确离散时间状态空间模型：\n$$\n\\mathbf{x}[k+1] = A_d \\mathbf{x}[k] + B_d u[k]\n$$\n其中 $\\mathbf{x}[k] \\equiv \\mathbf{x}(k T_s)$ 且 $u[k]$ 是该区间内的恒定输入。在这个问题中，$u[k]$ 被指定为量化后的控制输入 $u_q[k]$。\n\n**2. 仿真循环**\n\n对于每个测试用例，运行一个 $N = \\lfloor T_{\\mathrm{end}} / T_s \\rfloor$ 步的仿真，索引从 $k=0$ 到 $N-1$。状态初始化为 $\\mathbf{x}[0] = [0, 0]^T$。对于每个步骤 $k$，仿真过程如下：\n\n1.  **输出计算**：采样时刻的连续输出是 $y(k T_s) = C \\mathbf{x}[k]$。我们将其表示为 $y[k]$。\n2.  **测量量化**：感测到的输出使用中置型均匀量化器进行量化：\n    $$\n    y_q[k] = Q_{q_y}(y[k]) = q_y \\cdot \\mathrm{round}(y[k] / q_y)\n    $$\n    对于特殊情况 $q_y=0$，$Q_0(y) = y$。\n3.  **控制器动作**：PD控制器计算所需的控制力。导数项使用量化测量值的一阶后向差分进行近似：\n    $$\n    \\Delta y_q[k] = \\frac{y_q[k] - y_q[k-1]}{T_s}\n    $$\n    导数项的初始条件通过设置 $y_q[-1] = Q_{q_y}(y(-T_s)) = Q_{q_y}(0) = 0$ 来处理。控制律为：\n    $$\n    u[k] = K_p (A_r - y_q[k]) - K_d \\Delta y_q[k]\n    $$\n4.  **驱动量化**：计算出的控制力在施加到被控对象之前被量化：\n    $$\n    u_q[k] = Q_{q_u}(u[k]) = q_u \\cdot \\mathrm{round}(u[k] / q_u)\n    $$\n    对于 $q_u=0$，$u_q[k] = u[k]$。\n5.  **状态更新**：使用离散化模型将系统状态传播到下一个采样时刻：\n    $$\n    \\mathbf{x}[k+1] = A_d \\mathbf{x}[k] + B_d u_q[k]\n    $$\n仿真存储未量化的输出序列 $\\{y[k]\\}_{k=0}^{N-1}$ 用于后处理。\n\n**3. 性能指标计算**\n\n仿真完成后，分析存储的输出序列 $\\{y[k]\\}$ 以计算性能指标。\n\n1.  **终值估计**：稳态值 $y_\\infty$ 通过对输出的最后 $N_{\\mathrm{tail}}$ 个样本求平均来估计，其中 $N_{\\mathrm{tail}} = \\max(5, \\lfloor 0.1 N \\rfloor)$。\n    $$\n    y_\\infty = \\frac{1}{N_{\\mathrm{tail}}} \\sum_{j=N-N_{\\mathrm{tail}}}^{N-1} y[j]\n    $$\n2.  **超调量 ($M_p$)**：峰值超调量是相对于估计的终值 $y_\\infty$ 计算的。一个正则化项 $\\delta = 10^{-9}$ 用于防止除以零。\n    $$\n    M_p = \\max\\!\\left(0,\\; \\frac{\\max_{0 \\le k  N} y[k] - y_\\infty}{|y_\\infty| + \\delta}\\right)\n    $$\n3.  **稳定时间 ($T_{\\mathrm{set}}$) 和稳定标志**：稳定时间是第一个时间点 $k T_s$，使得对于所有后续样本 $j \\ge k$，输出 $y[j]$ 保持在 $y_\\infty$ 周围的 $\\pm\\epsilon$ 容差带内。我们通过找到最后一个违反条件 $|y[j] - y_\\infty| \\le \\epsilon |y_\\infty|$ 的样本索引 $k_{\\mathrm{viol}}$ 来实现这一点。稳定时间则为 $T_{\\mathrm{set}} = (k_{\\mathrm{viol}} + 1)T_s$。如果没有样本违反该条件，则 $T_{\\mathrm{set}} = 0$。如果系统在仿真时间范围内没有稳定（即，如果 $k_{\\mathrm{viol}}+1 \\ge N$），则将 $T_{\\mathrm{set}}$ 设置为 $T_{\\mathrm{end}}$，并且布尔标志 $\\mathrm{settled}$ 设置为 $\\mathrm{False}$。否则，$\\mathrm{settled}$ 为 $\\mathrm{True}$。\n4.  **稳态误差 ($e_{\\mathrm{ss}}$)**：这是参考指令 $A_r$ 与估计终值 $y_\\infty$ 之间差值的幅值。\n    $$\n    e_{\\mathrm{ss}} = |A_r - y_\\infty|\n    $$\n5.  **绝对误差积分 ($\\mathrm{IAE}$)**：该指标是参考值与系统输出之间绝对误差在仿真时间范围内的离散时间积分。\n    $$\n    \\mathrm{IAE} = \\sum_{k=0}^{N-1} |A_r - y[k]| T_s\n    $$\n\n将此完整过程应用于四个测试用例中的每一个，以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the cyber-physical system simulation and performance analysis problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: happy path, moderate quantization\n        {'m': 1.0, 'c': 4.0, 'k': 100.0, 'K_p': 80.0, 'K_d': 15.0, 'A_r': 0.1, 'T_s': 0.01, 'q_y': 0.001, 'q_u': 0.01, 'T_end': 4.0},\n        # Case 2: coarse quantization, possible non-settling\n        {'m': 1.0, 'c': 4.0, 'k': 100.0, 'K_p': 80.0, 'K_d': 15.0, 'A_r': 0.1, 'T_s': 0.02, 'q_y': 0.05, 'q_u': 0.5, 'T_end': 4.0},\n        # Case 3: no quantization baseline, faster sampling\n        {'m': 1.0, 'c': 4.0, 'k': 100.0, 'K_p': 80.0, 'K_d': 15.0, 'A_r': 0.1, 'T_s': 0.005, 'q_y': 0.0, 'q_u': 0.0, 'T_end': 3.0},\n        # Case 4: critical damping, moderate quantization\n        {'m': 1.0, 'c': 20.0, 'k': 100.0, 'K_p': 120.0, 'K_d': 30.0, 'A_r': 0.1, 'T_s': 0.01, 'q_y': 0.002, 'q_u': 0.02, 'T_end': 4.0}\n    ]\n\n    epsilon = 0.02\n    delta = 1e-9\n    \n    results = []\n\n    def quantize(x, q):\n        \"\"\"Mid-tread uniform quantization.\"\"\"\n        if q == 0.0:\n            return x\n        return q * np.round(x / q)\n\n    for case in test_cases:\n        m, c, k_s, K_p, K_d = case['m'], case['c'], case['k'], case['K_p'], case['K_d']\n        A_r, T_s, q_y, q_u, T_end = case['A_r'], case['T_s'], case['q_y'], case['q_u'], case['T_end']\n\n        # 1. System Discretization\n        A_c = np.array([[0, 1], [-k_s/m, -c/m]])\n        B_c = np.array([[0], [1/m]])\n        C_c = np.array([[1, 0]])\n\n        n = A_c.shape[0]\n        p = B_c.shape[1]\n        \n        M = np.zeros((n + p, n + p))\n        M[:n, :n] = A_c\n        M[:n, n:] = B_c\n        \n        eM_Ts = expm(M * T_s)\n        \n        A_d = eM_Ts[:n, :n]\n        B_d = eM_Ts[:n, n:]\n\n        # 2. Simulation Loop\n        N = int(np.floor(T_end / T_s))\n        x = np.array([[0.0], [0.0]])\n        y_history = np.zeros(N)\n        \n        # Initial condition for derivative term\n        y_q_prev = quantize(0.0, q_y) \n\n        for k in range(N):\n            # Output calculation\n            y_k = (C_c @ x)[0, 0]\n            y_history[k] = y_k\n            \n            # Measurement quantization\n            y_q_k = quantize(y_k, q_y)\n            \n            # Controller action\n            delta_y_q_k = (y_q_k - y_q_prev) / T_s\n            u_k = K_p * (A_r - y_q_k) - K_d * delta_y_q_k\n            \n            # Actuation quantization\n            u_q_k = quantize(u_k, q_u)\n\n            # State update\n            x = A_d @ x + B_d * u_q_k\n            \n            # Update previous quantized measurement\n            y_q_prev = y_q_k\n\n        # 3. Performance Metrics Calculation\n        N_tail = max(5, int(np.floor(0.1 * N)))\n        if N  N_tail: \n            y_inf = np.mean(y_history) if N > 0 else 0.0\n        else:\n            y_inf = np.mean(y_history[-N_tail:])\n\n        # Overshoot\n        y_max = np.max(y_history) if N > 0 else 0.0\n        M_p = max(0.0, (y_max - y_inf) / (abs(y_inf) + delta))\n\n        # Settling Time\n        settled = False\n        T_set = T_end\n        if N > 0:\n            if abs(y_inf) > delta:\n              tolerance = epsilon * abs(y_inf)\n            # if y_inf is ~0, use A_r for tolerance band\n            else:\n              tolerance = epsilon * abs(A_r) if abs(A_r) > delta else epsilon\n\n            violations = np.where(np.abs(y_history - y_inf) > tolerance)[0]\n            \n            if len(violations) == 0:\n                last_violation_idx = -1\n            else:\n                last_violation_idx = violations[-1]\n            \n            settling_sample_idx = last_violation_idx + 1\n\n            if settling_sample_idx  N:\n                T_set = settling_sample_idx * T_s\n                settled = True\n\n        # Steady-state error\n        e_ss = abs(A_r - y_inf)\n\n        # Integral of Absolute Error\n        IAE = np.sum(np.abs(A_r - y_history)) * T_s\n\n        results.append([M_p, T_set, e_ss, IAE, settled])\n\n    # Format the final output string\n    # Using a custom formatter to avoid trailing zeros and ensure consistent representation\n    def format_float(f):\n        if np.isinf(f) or np.isnan(f):\n            return str(f)\n        return f\"{f:.15g}\".rstrip('0').rstrip('.') if '.' in f\"{f:.15g}\" else f\"{f:.15g}\"\n\n    def format_list(lst):\n        items = []\n        for item in lst:\n            if isinstance(item, bool):\n                items.append(str(item))\n            elif isinstance(item, (float, np.floating)):\n                items.append(format_float(item))\n            else:\n                items.append(str(item))\n        return f\"[{','.join(items)}]\"\n\n    result_str = f\"[{','.join(map(format_list, results))}]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}