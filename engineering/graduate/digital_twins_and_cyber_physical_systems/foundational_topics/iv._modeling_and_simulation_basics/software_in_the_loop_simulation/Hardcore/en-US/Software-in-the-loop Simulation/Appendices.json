{
    "hands_on_practices": [
        {
            "introduction": "A core challenge in any time-domain simulation is ensuring numerical stability, especially for \"stiff\" systems where phenomena evolve on vastly different timescales. This practice  explores how the choice of numerical integrator and step size $h$ is critical for a stable and efficient Software-in-the-Loop simulation. Through analysis of the system's eigenvalues, you will determine the precise stability constraints on explicit integration methods and understand why they can fail for stiff dynamics.",
            "id": "4246751",
            "problem": "A software-in-the-loop (SIL) experiment for a digital twin of a cyber-physical system employs a host-based numerical integrator to simulate a stiff continuous-time plant while executing the controller software in the loop. Near a nominal operating point, the plant is linearized to the time-invariant form $\\dot{x}(t) = A x(t)$, where $A \\in \\mathbb{R}^{n \\times n}$ is the Jacobian of the plant dynamics. The plant exhibits stiffness because the eigenvalues of $A$ have large negative real parts. At a particular operating point, numerical linear analysis yields three real eigenvalues $\\lambda_{1} = -2.0 \\times 10^{3}\\ \\text{s}^{-1}$, $\\lambda_{2} = -50\\ \\text{s}^{-1}$, and $\\lambda_{3} = -0.5\\ \\text{s}^{-1}$.\n\nIn this SIL setup, the plant is advanced in time using the explicit forward Euler method with a fixed step size $h  0$, producing a discrete-time model $x_{k+1} = \\Phi(h)\\,x_{k}$ that is used to update the plant state once per step. Using only fundamental principles of linearization, modal decomposition, and the discrete-time stability criterion for linear time-invariant systems (all eigenvalues of the state transition matrix must lie strictly inside the unit disk), do the following:\n\n- Derive, from first principles, the region of absolute stability in terms of the step size $h$ that guarantees linear stability of each eigenmode when using explicit Euler on the linearized plant.\n- From this, derive the constraint on $h$ that guarantees linear stability of all three modes simultaneously, and compute the largest uniform step size $h$ admissible for the given eigenvalues.\n- For comparison, repeat the modal stability analysis for the implicit backward Euler method applied to the same linearized plant and identify whether any step size restriction is required to maintain linear stability for eigenvalues with strictly negative real parts. You must justify your conclusion from first principles, but you do not need to report it in your final numeric answer.\n\nExpress your final $h$ in seconds and round your answer to $3$ significant figures.",
            "solution": "The problem is valid as it is scientifically grounded in the principles of numerical analysis and control theory, is well-posed, and is stated objectively. We may proceed with the solution.\n\nThe problem asks for an analysis of the numerical stability of a software-in-the-loop (SIL) simulation. The plant dynamics are linearized around an operating point, resulting in a linear time-invariant (LTI) system:\n$$\n\\dot{x}(t) = A x(t)\n$$\nwhere $x(t) \\in \\mathbb{R}^n$ is the state vector and $A \\in \\mathbb{R}^{n \\times n}$ is the system Jacobian. The system is characterized by three real eigenvalues: $\\lambda_{1} = -2.0 \\times 10^{3}\\ \\text{s}^{-1}$, $\\lambda_{2} = -50\\ \\text{s}^{-1}$, and $\\lambda_{3} = -0.5\\ \\text{s}^{-1}$.\n\nTo analyze the stability of a numerical method, we can decouple the system dynamics using a modal decomposition. Assuming the matrix $A$ is diagonalizable (which is guaranteed here as it has distinct real eigenvalues), there exists a transformation $x(t) = P z(t)$, where $P$ is the matrix of eigenvectors of $A$. Substituting this into the state equation yields:\n$$\nP \\dot{z}(t) = A P z(t)\n$$\n$$\n\\dot{z}(t) = P^{-1} A P z(t) = \\Lambda z(t)\n$$\nwhere $\\Lambda$ is the diagonal matrix of eigenvalues of $A$. This transformation decouples the $n$-dimensional system into $n$ independent scalar ordinary differential equations (ODEs), one for each mode $z_i(t)$:\n$$\n\\dot{z}_i(t) = \\lambda_i z_i(t) \\quad \\text{for } i = 1, 2, 3\n$$\nThe stability of the numerical method applied to the full system $\\dot{x}(t) = A x(t)$ is equivalent to its stability when applied to each of these scalar test equations.\n\n**Part 1: Stability Analysis of the Explicit Forward Euler Method**\n\nThe explicit forward Euler method approximates the derivative $\\dot{z}_i(t)$ using a forward difference formula with a fixed step size $h  0$:\n$$\n\\dot{z}_i(t_k) \\approx \\frac{z_{i}(t_{k+1}) - z_{i}(t_k)}{h}\n$$\nwhere $t_k = kh$ and we use the notation $z_{i,k} \\equiv z_i(t_k)$. Applying this to the modal ODE $\\dot{z}_i(t) = \\lambda_i z_i(t)$ gives:\n$$\n\\frac{z_{i,k+1} - z_{i,k}}{h} = \\lambda_i z_{i,k}\n$$\nSolving for $z_{i,k+1}$ yields the discrete-time update rule for the $i$-th mode:\n$$\nz_{i,k+1} = z_{i,k} + h \\lambda_i z_{i,k} = (1 + h \\lambda_i) z_{i,k}\n$$\nFor the discrete-time system to be stable, the magnitude of the propagation factor (which is the eigenvalue of the single-mode discrete-time state transition matrix) must be strictly less than $1$. This is the unit disk criterion mentioned in the problem. Thus, for each mode $i$, we require:\n$$\n|1 + h \\lambda_i|  1\n$$\nThis inequality defines the region of absolute stability for the forward Euler method. Since the given eigenvalues $\\lambda_i$ are real and negative, and the step size $h$ is real and positive, the term $h \\lambda_i$ is a negative real number. The absolute value inequality can be written as a pair of inequalities:\n$$\n-1  1 + h \\lambda_i  1\n$$\nWe analyze each inequality separately:\n1.  The right-hand side: $1 + h \\lambda_i  1 \\implies h \\lambda_i  0$. Since $h  0$ and all given $\\lambda_i  0$, this condition is always satisfied.\n2.  The left-hand side: $-1  1 + h \\lambda_i \\implies -2  h \\lambda_i$. Since $\\lambda_i$ is negative, dividing by it reverses the inequality sign:\n$$\nh  -\\frac{2}{\\lambda_i}\n$$\nThis is the constraint on the step size $h$ that guarantees the stability of the $i$-th mode. For the entire system to be stable, this constraint must be satisfied for all modes simultaneously. This means $h$ must be less than the minimum of the upper bounds determined by each eigenvalue.\n\n**Part 2: Calculation of the Maximum Admissible Step Size**\n\nWe apply the derived constraint $h  -2/\\lambda_i$ to each of the given eigenvalues:\n- For $\\lambda_1 = -2.0 \\times 10^3\\ \\text{s}^{-1}$:\n$$\nh  -\\frac{2}{-2.0 \\times 10^3} \\ \\text{s} = 1.0 \\times 10^{-3}\\ \\text{s}\n$$\n- For $\\lambda_2 = -50\\ \\text{s}^{-1}$:\n$$\nh  -\\frac{2}{-50} \\ \\text{s} = \\frac{1}{25}\\ \\text{s} = 0.04\\ \\text{s}\n$$\n- For $\\lambda_3 = -0.5\\ \\text{s}^{-1}$:\n$$\nh  -\\frac{2}{-0.5} \\ \\text{s} = 4\\ \\text{s}\n$$\nTo ensure stability for all three modes, the step size $h$ must satisfy all three inequalities. The most restrictive constraint is imposed by the eigenvalue with the largest magnitude, $\\lambda_1$, which corresponds to the fastest dynamic mode of the system. This is a characteristic feature of stiff differential equations.\n$$\nh  \\min(1.0 \\times 10^{-3}, 0.04, 4)\\ \\text{s}\n$$\n$$\nh  1.0 \\times 10^{-3}\\ \\text{s}\n$$\nThe largest uniform step size $h$ that is admissible is therefore just below $1.0 \\times 10^{-3}\\ \\text{s}$. The problem asks for this value, which we report as $h = 1.0 \\times 10^{-3}\\ \\text{s}$. Rounding to $3$ significant figures gives $1.00 \\times 10^{-3}\\ \\text{s}$.\n\n**Part 3: Comparative Analysis for the Implicit Backward Euler Method**\n\nFor comparison, we analyze the stability of the implicit backward Euler method. The key difference is that the derivative is evaluated using the state at the next time step, $z_{i,k+1}$:\n$$\n\\frac{z_{i,k+1} - z_{i,k}}{h} = \\lambda_i z_{i,k+1}\n$$\nWe solve for $z_{i,k+1}$:\n$$\nz_{i,k+1} - h \\lambda_i z_{i,k+1} = z_{i,k}\n$$\n$$\nz_{i,k+1} (1 - h \\lambda_i) = z_{i,k}\n$$\n$$\nz_{i,k+1} = \\left( \\frac{1}{1 - h \\lambda_i} \\right) z_{i,k}\n$$\nThe stability criterion requires the magnitude of the propagation factor to be less than $1$:\n$$\n\\left| \\frac{1}{1 - h \\lambda_i} \\right|  1 \\implies |1 - h \\lambda_i|  1\n$$\nWe are given that the eigenvalues $\\lambda_i$ have strictly negative real parts. Let's analyze this for our real, negative eigenvalues. Let $\\lambda_i = -a_i$ where $a_i  0$. The stability condition becomes:\n$$\n|1 - h(-a_i)|  1 \\implies |1 + h a_i|  1\n$$\nSince $h  0$ and $a_i  0$, the product $h a_i$ is a positive real number. Therefore, $1 + h a_i$ is a real number strictly greater than $1$. Its absolute value is itself, so the condition is:\n$$\n1 + h a_i  1\n$$\nThis inequality is true for any $h  0$ and any $a_i  0$. This means the backward Euler method is stable for any positive step size $h$ when applied to a system whose eigenvalues have strictly negative real parts. Such a method is called A-stable. Consequently, for the given linearized plant, the implicit backward Euler method imposes no upper limit on the step size $h$ to maintain linear stability. This property makes it highly suitable for simulating stiff systems, as it allows for much larger time steps than conditionally stable methods like forward Euler, thereby reducing computational cost.\n\nThe final answer required is the largest admissible step size for the forward Euler method.\n$h = 1.0 \\times 10^{-3}\\ \\text{s}$, which rounded to $3$ significant figures is $1.00 \\times 10^{-3}\\ \\text{s}$.",
            "answer": "$$\n\\boxed{1.00 \\times 10^{-3}}\n$$"
        },
        {
            "introduction": "Beyond simulating individual components, a key challenge in SIL is correctly interconnecting them, which requires careful architectural consideration. This practice examines the common problem of an \"algebraic loop,\" which arises from instantaneous feedback between the controller and plant models in a co-simulation environment. Using a simplified static system, you will see how introducing a discrete delay  is a practical method to break this loop, making the simulation executable and fundamentally altering the system's stability characteristics.",
            "id": "4246841",
            "problem": "A digital twin for a Cyber-Physical System (CPS) is evaluated using Software-in-the-Loop (SIL) simulation at sampling period $T_{s}$. The physical plant is modeled as a static gain, with output $y$ and input $u$ related by $y = G u$, where $G \\in \\mathbb{R}$ is the plant gain. The controller is also static and proportional: $u = K y$, where $K \\in \\mathbb{R}$ is the controller gain. In the SIL co-simulation, connecting $y = G u$ and $u = K y$ directly introduces an algebraic loop. To remove the algebraic loop and to emulate computation and communication scheduling, the SIL harness applies a latency insertion technique: the feedback signal is delayed by exactly one sampling period, that is, $T_{d} = T_{s}$, so that the controller uses the previous sampled output to compute the current input. Assume ideal sampling with Zero-Order Hold (ZOH) and that the delay is applied in the feedback path so that $u[k] = K y[k-1]$ while the plant remains $y[k] = G u[k]$ at each sample index $k \\in \\mathbb{Z}$.\n\nUsing only fundamental definitions of sampled-data systems and linear time-invariant (LTI) discrete-time stability, perform the following:\n- Derive the closed-loop algebraic equation implied by the direct continuous-time interconnection $y = G u$ and $u = K y$ before latency insertion.\n- Derive the discrete-time closed-loop equation after latency insertion with $T_{d} = T_{s}$, and express the corresponding characteristic equation in the $z$-domain.\n- From first principles, analyze the condition on $G$ and $K$ under which the latency insertion with $T_{d} = T_{s}$ stabilizes the loop.\n\nReport as your final answer the scalar closed-loop pole location in the $z$-plane after latency insertion, expressed as a single analytic expression in $G$ and $K$. No numerical evaluation is required, and no units are to be included in the final answer.",
            "solution": "The problem statement is evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- System: Software-in-the-Loop (SIL) simulation for a Cyber-Physical System (CPS).\n- Sampling period: $T_{s}$.\n- Physical plant model: $y = G u$, where $G \\in \\mathbb{R}$ is the plant gain.\n- Controller model: $u = K y$, where $K \\in \\mathbb{R}$ is the controller gain.\n- Problem with direct connection: introduces an algebraic loop.\n- Latency insertion technique: feedback signal is delayed by $T_{d} = T_{s}$.\n- Discrete-time controller equation: $u[k] = K y[k-1]$ for sample index $k \\in \\mathbb{Z}$.\n- Discrete-time plant equation: $y[k] = G u[k]$.\n- Sampling assumption: Ideal sampling with Zero-Order Hold (ZOH).\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the validation criteria.\n- **Scientifically Grounded**: The problem is based on fundamental concepts of control theory, specifically sampled-data systems, and their application in SIL co-simulation, which is a standard practice in digital twin and CPS development. The models for the plant and controller are static gains, which are the simplest form of linear time-invariant (LTI) systems. The concept of an algebraic loop and its resolution using a unit delay ($z^{-1}$) is a standard and correct topic in control and simulation theory.\n- **Well-Posed**: The problem is clearly defined. It provides all necessary equations and parameters ($G$, $K$) to perform the required derivations. The tasks are specific: derive the algebraic loop equation, derive the discrete-time characteristic equation, and determine the stability condition. This structure leads to a unique and meaningful solution.\n- **Objective**: The problem is stated using precise, unambiguous technical language common in control engineering. There are no subjective or opinion-based elements.\n\nThe problem does not exhibit any of the invalidity flaws. It is a well-formulated, standard problem in elementary discrete-time control theory applied to a practical simulation context.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Derivation\nThe solution proceeds by addressing the three tasks specified in the problem statement.\n\n**1. Derivation of the Closed-Loop Algebraic Equation (before latency insertion)**\n\nThe continuous-time interconnection is described by two simultaneous equations:\n$$y = G u$$\n$$u = K y$$\n\nTo find the closed-loop equation, we substitute one into the other. Substituting the expression for $u$ from the second equation into the first equation yields:\n$$y = G (K y)$$\n$$y = (GK) y$$\n\nRearranging this equation gives:\n$$y - GK y = 0$$\n$$(1 - GK) y = 0$$\n\nThis is the closed-loop algebraic equation. For a non-trivial solution ($y \\neq 0$) to exist, the condition $1 - GK = 0$ must be met. In a simulation environment, trying to compute $y$ requires a value for $u$, which in turn requires the value of $y$ at the same time instant. This circular dependency is known as an algebraic loop and cannot be resolved by a sequential execution engine without an iterative solver or the introduction of a delay.\n\n**2. Derivation of the Discrete-Time Closed-Loop Equation and Characteristic Equation (after latency insertion)**\n\nThe SIL harness introduces a delay of one sampling period, $T_{d} = T_{s}$, in the feedback path to break the algebraic loop. The system dynamics at each discrete sampling instant $k$ are described by:\nPlant: $y[k] = G u[k]$\nController: $u[k] = K y[k-1]$\n\nTo derive the discrete-time closed-loop equation, we substitute the controller's output $u[k]$ into the plant equation:\n$$y[k] = G (K y[k-1])$$\n$$y[k] = (GK) y[k-1]$$\n\nThis is a first-order linear homogeneous difference equation describing the evolution of the output $y$ over time. To find the characteristic equation, we apply the $z$-transform to this difference equation. Let $Y(z)$ be the $z$-transform of the sequence $y[k]$. Using the time-shifting property of the $z$-transform, $\\mathcal{Z}\\{y[k-1]\\} = z^{-1}Y(z)$, we get:\n$$Y(z) = G K (z^{-1} Y(z))$$\n\nTo find the characteristic equation, we gather all terms on one side:\n$$Y(z) - GK z^{-1} Y(z) = 0$$\n$$Y(z) (1 - GK z^{-1}) = 0$$\n\nFor a non-trivial solution ($Y(z) \\neq 0$), the term in the parenthesis must be zero. This gives a form of the characteristic equation:\n$$1 - GK z^{-1} = 0$$\n\nMultiplying by $z$ yields the characteristic equation in the standard polynomial form:\n$$z - GK = 0$$\n\n**3. Stability Analysis**\n\nAccording to the principles of LTI discrete-time systems, a system is asymptotically stable if and only if all the poles of its closed-loop transfer function (i.e., the roots of its characteristic equation) lie strictly inside the unit circle in the complex $z$-plane.\n\nFrom the characteristic equation $z - GK = 0$, we can directly identify the location of the single closed-loop pole:\n$$z = GK$$\n\nFor the system to be stable, the magnitude of this pole must be less than $1$:\n$$|z|  1$$\n$$|GK|  1$$\n\nTherefore, the latency insertion technique stabilizes the system if and only if the absolute value of the product of the plant and controller gains is less than one. If $|GK| = 1$, the system is marginally stable (the output will oscillate or remain constant). If $|GK|  1$, the system is unstable (the output will grow without bound).\n\nThe problem asks for the scalar closed-loop pole location in the $z$-plane, which is the expression derived from the characteristic equation.\nThe pole is located at $z = GK$.",
            "answer": "$$\n\\boxed{GK}\n$$"
        },
        {
            "introduction": "To build confidence in complex SIL simulations, we can move beyond ad-hoc testing to more systematic verification methods that provide deeper insight. This hands-on exercise introduces the powerful concept of contract-based design, where interactions are governed by formal \"assume-guarantee\" specifications. By implementing runtime monitors to check these contracts, this practice  demonstrates how to build self-diagnosing simulations that can automatically pinpoint the source of an error, distinguishing between a faulty controller and an unexpected plant behavior.",
            "id": "4246839",
            "problem": "You are asked to design and implement a software-in-the-loop (SIL) simulation that enforces a contract-based interaction between a discrete-time linear time-invariant controller and plant, and to demonstrate how runtime detection of contract violations yields actionable debugging information. The program must execute the specified test suite and output aggregated, quantifiable results in the prescribed format.\n\nConsider a plant with state $\\mathbf{x}_k \\in \\mathbb{R}^2$, scalar control input $u_k \\in \\mathbb{R}$, and measured output $\\mathbf{y}_k \\in \\mathbb{R}^2$ governed by the discrete-time dynamics\n$$\n\\mathbf{x}_{k+1} = A \\mathbf{x}_k + B u_k + \\mathbf{w}_k, \\quad \\mathbf{y}_k = C \\mathbf{x}_k + \\mathbf{v}_k,\n$$\nwhere $A \\in \\mathbb{R}^{2 \\times 2}$, $B \\in \\mathbb{R}^{2 \\times 1}$, and $C \\in \\mathbb{R}^{2 \\times 2}$. The controller is static state feedback:\n$$\nu_k = K \\mathbf{x}_k,\n$$\nwith $K \\in \\mathbb{R}^{1 \\times 2}$. All quantities are dimensionless. The time index $k$ runs from $k=0$ to $k=T-1$ with $T \\in \\mathbb{N}$.\n\nContract-based design. Define a contract as an assume-guarantee pair $(\\mathcal{A}, \\mathcal{G})$:\n- Assumptions $\\mathcal{A}$ (plant-side): The disturbances $\\mathbf{w}_k$ and measurement noises $\\mathbf{v}_k$ satisfy the componentwise infinity-norm bounds\n$$\n\\lVert \\mathbf{w}_k \\rVert_\\infty \\le w_{\\max}, \\quad \\lVert \\mathbf{v}_k \\rVert_\\infty \\le v_{\\max} \\quad \\text{for all } k.\n$$\n- Guarantees $\\mathcal{G}$ (controller-side): The controller must respect\n$$\n|u_k| \\le u_{\\max}, \\quad |u_k - u_{k-1}| \\le \\Delta u_{\\max} \\text{ for } k \\ge 1, \\quad \\lVert \\mathbf{x}_k \\rVert_\\infty \\le x_{\\max} \\quad \\text{for all } k,\n$$\nwhere the state safety bound is promised provided the assumptions $\\mathcal{A}$ hold up to and including the corresponding time index.\n\nRuntime monitors. Implement two monitors:\n- Assumption monitor $\\mathsf{M}_\\mathcal{A}$: detects the earliest time $t_\\mathcal{A}$ where either $\\lVert \\mathbf{w}_k \\rVert_\\infty  w_{\\max}$ or $\\lVert \\mathbf{v}_k \\rVert_\\infty  v_{\\max}$ occurs.\n- Guarantee monitor $\\mathsf{M}_\\mathcal{G}$: detects the earliest time $t_\\mathcal{G}$ where either $|u_k|  u_{\\max}$, or $|u_k - u_{k-1}|  \\Delta u_{\\max}$ for $k \\ge 1$, or $\\lVert \\mathbf{x}_k \\rVert_\\infty  x_{\\max}$ occurs. For the state safety check, if an assumption violation occurs at time $t_\\mathcal{A}$, then only state violations with time index $k  t_\\mathcal{A}$ are attributed to $\\mathsf{M}_\\mathcal{G}$; state violations at $k \\ge t_\\mathcal{A}$ are not attributed to the controller.\n\nActionable debugging classification. Based on $(t_\\mathcal{A}, t_\\mathcal{G})$, define a classification code $c \\in \\{0,1,2,3,4\\}$:\n- $c=0$: no violation ($t_\\mathcal{A}$ and $t_\\mathcal{G}$ are absent).\n- $c=1$: only plant-side assumption violated (finite $t_\\mathcal{A}$, no $t_\\mathcal{G}$).\n- $c=2$: only controller-side guarantee violated (finite $t_\\mathcal{G}$, no $t_\\mathcal{A}$).\n- $c=3$: both violated, controller-first (finite $t_\\mathcal{G}$ and $t_\\mathcal{A}$ with $t_\\mathcal{G}  t_\\mathcal{A}$).\n- $c=4$: both violated, plant-first (finite $t_\\mathcal{G}$ and $t_\\mathcal{A}$ with $t_\\mathcal{A} \\le t_\\mathcal{G}$).\n\nSimulation and monitoring procedure. Starting from initial state $\\mathbf{x}_0$, iterate for $k=0,1,\\dots,T-1$:\n- Compute $u_k = K \\mathbf{x}_k$.\n- Update $\\mathbf{x}_{k+1} = A \\mathbf{x}_k + B u_k + \\mathbf{w}_k$.\n- Compute $\\mathbf{y}_k = C \\mathbf{x}_k + \\mathbf{v}_k$.\n- Update monitors $\\mathsf{M}_\\mathcal{A}$ and $\\mathsf{M}_\\mathcal{G}$ as per the definitions above.\n\nNumerical parameters. Unless specified otherwise for a given test, use\n$$\nA = \\begin{bmatrix} 0.9  0.1 \\\\ 0.0  0.95 \\end{bmatrix}, \\quad\nB = \\begin{bmatrix} 0.1 \\\\ 0.05 \\end{bmatrix}, \\quad\nC = I_2, \\quad\nK = \\begin{bmatrix} -0.8  -0.6 \\end{bmatrix},\n$$\nwith horizon $T=20$, bounds $w_{\\max}=0.05$, $v_{\\max}=0.02$, $u_{\\max}=0.5$, $\\Delta u_{\\max}=0.2$, $x_{\\max}=2.0$. All numbers are dimensionless.\n\nTest suite. Implement the following $6$ tests; for each test $i$, output a triple $[c_i, t_{\\mathcal{A},i}, t_{\\mathcal{G},i}]$, where absent times are reported as $-1$:\n- Test $1$ (nominal, no violation): $\\mathbf{x}_0 = \\begin{bmatrix} 0.5 \\\\ -0.5 \\end{bmatrix}$; for all $k$, $\\mathbf{w}_k = \\begin{bmatrix} 0.01 \\\\ -0.01 \\end{bmatrix}$ and $\\mathbf{v}_k = \\begin{bmatrix} 0.005 \\\\ -0.005 \\end{bmatrix}$; use the default $A$, $B$, $C$, $K$, $T$, and bounds.\n- Test $2$ (plant assumption violation): same as Test $1$ except $\\mathbf{w}_k = \\begin{bmatrix} 0.2 \\\\ 0.0 \\end{bmatrix}$ at $k=5$ and $\\mathbf{w}_k = \\begin{bmatrix} 0.01 \\\\ -0.01 \\end{bmatrix}$ otherwise; $\\mathbf{v}_k$ as in Test $1$.\n- Test $3$ (controller guarantee violation via actuation bound): $\\mathbf{x}_0 = \\begin{bmatrix} 3.0 \\\\ 3.0 \\end{bmatrix}$; for all $k$, $\\mathbf{w}_k = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$, $\\mathbf{v}_k = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$; use default $A$, $B$, $C$, $K$, $T$, and bounds.\n- Test $4$ (boundary case at exact limits, no violation): $\\mathbf{x}_0 = \\begin{bmatrix} -0.625 \\\\ 0.0 \\end{bmatrix}$; for all $k$, $\\mathbf{w}_k = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$, $\\mathbf{v}_k = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$; use defaults. Note that $u_0 = K \\mathbf{x}_0$ equals $u_{\\max}$ exactly, which must not be flagged as a violation.\n- Test $5$ (both violations, controller-first): $\\mathbf{x}_0 = \\begin{bmatrix} 1.5 \\\\ 1.5 \\end{bmatrix}$; for all $k \\ne 8$, $\\mathbf{w}_k = \\begin{bmatrix} 0.01 \\\\ -0.01 \\end{bmatrix}$; at $k=8$, $\\mathbf{w}_k = \\begin{bmatrix} 0.2 \\\\ 0.0 \\end{bmatrix}$; for all $k$, $\\mathbf{v}_k = \\begin{bmatrix} 0.005 \\\\ -0.005 \\end{bmatrix}$; use defaults.\n- Test $6$ (near-marginal plant, closed-loop stable): same as Test $1$ except\n$$\nA = \\begin{bmatrix} 1.0  0.01 \\\\ 0.0  1.0 \\end{bmatrix}, \\quad \\mathbf{x}_0 = \\begin{bmatrix} 0.2 \\\\ -0.2 \\end{bmatrix}, \\quad \\mathbf{w}_k = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}, \\quad \\mathbf{v}_k = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix} \\text{ for all } k.\n$$\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test result is formatted as a three-element list without spaces. For example:\n\"[ [c1,tA1,tG1],[c2,tA2,tG2],... ]\"\nbut without any spaces. Concretely, your program must print:\n\"[[c1,tA1,tG1],[c2,tA2,tG2],[c3,tA3,tG3],[c4,tA4,tG4],[c5,tA5,tG5],[c6,tA6,tG6]]\".",
            "solution": "The user has requested the design and implementation of a software-in-the-loop (SIL) simulation for a discrete-time linear control system, incorporating contract-based design principles and runtime monitoring. The goal is to detect and classify violations of predefined system contracts.\n\n### Step 1: Problem Validation\n\nThe problem statement describes a standard discrete-time linear time-invariant (LTI) system with a static state-feedback controller. The dynamics are given by:\n$$\n\\mathbf{x}_{k+1} = A \\mathbf{x}_k + B u_k + \\mathbf{w}_k\n$$\n$$\nu_k = K \\mathbf{x}_k\n$$\nThe concepts of contract-based design, specified as an assume-guarantee pair $(\\mathcal{A}, \\mathcal{G})$, and runtime monitoring are well-established principles in formal methods and cyber-physical systems engineering. The problem provides all necessary components: system matrices ($A$, $B$, $C$), controller gain ($K$), time horizon ($T$), initial conditions ($\\mathbf{x}_0$), disturbance and noise sequences ($\\mathbf{w}_k$, $\\mathbf{v}_k$), and explicit numerical bounds for the contract ($w_{\\max}, v_{\\max}, u_{\\max}, \\Delta u_{\\max}, x_{\\max}$).\n\nThe rules for monitoring are defined algorithmically:\n- The assumption monitor $\\mathsf{M}_\\mathcal{A}$ checks for the first time $k$ where $\\lVert \\mathbf{w}_k \\rVert_\\infty  w_{\\max}$ or $\\lVert \\mathbf{v}_k \\rVert_\\infty  v_{\\max}$.\n- The guarantee monitor $\\mathsf{M}_\\mathcal{G}$ checks for the first time $k$ where $|u_k|  u_{\\max}$, $|u_k - u_{k-1}|  \\Delta u_{\\max}$ (for $k \\ge 1$), or $\\lVert \\mathbf{x}_k \\rVert_\\infty  x_{\\max}$.\nA crucial clarifying rule is provided for state safety: a state violation at time $k$ is only attributed to the controller if no assumption violation has occurred at a time $t_\\mathcal{A} \\le k$.\n\nThe problem defines a clear classification scheme based on the violation times $(t_\\mathcal{A}, t_\\mathcal{G})$ and specifies a complete test suite with six distinct scenarios designed to exercise the different logical paths of the monitoring system. The required output format is precisely specified.\n\nThe problem is scientifically grounded in control theory and formal methods, well-posed with all necessary information, and entirely objective. No flaws were identified during validation. Therefore, the problem is declared valid and a solution is constructed.\n\n### Step 2: Algorithmic Design\n\nThe solution is structured into three main logical components: simulation, monitoring, and classification. A main function orchestrates these components for each of the six test cases.\n\n**1. Simulation Core**\nThe simulation propagates the system state over the time horizon $T$. Starting with the initial state $\\mathbf{x}_0$, the simulation iteratively computes the control input $u_k$ and the next state $\\mathbf{x}_{k+1}$ for each time step $k = 0, 1, \\dots, T-1$.\nThe loop proceeds as follows:\n- Given the current state $\\mathbf{x}_k$, the control input is calculated: $u_k = K \\mathbf{x}_k$.\n- The next state is then computed using the state-update equation: $\\mathbf{x}_{k+1} = A \\mathbf{x}_k + B u_k + \\mathbf{w}_k$.\nThe histories of the state vector, $\\mathbf{x}_0, \\dots, \\mathbf{x}_T$, and the control input, $u_0, \\dots, u_{T-1}$, are stored for subsequent analysis by the monitors.\n\n**2. Runtime Monitoring**\nThis component post-processes the simulation data to detect contract violations. It determines the earliest time of an assumption violation, $t_\\mathcal{A}$, and the earliest time of a guarantee violation, $t_\\mathcal{G}$.\n\n- **Assumption Monitor ($\\mathsf{M}_\\mathcal{A}$)**: This monitor iterates from $k=0$ to $T-1$. At each step, it checks the infinity norms of the process disturbance $\\mathbf{w}_k$ and measurement noise $\\mathbf{v}_k$ against their respective bounds $w_{\\max}$ and $v_{\\max}$. The first time $k$ a bound is exceeded, $t_\\mathcal{A}$ is set to $k$ and the search terminates. If no violation is found, $t_\\mathcal{A}$ remains at its initial value of $-1$.\n\n- **Guarantee Monitor ($\\mathsf{M}_\\mathcal{G}$)**: This monitor finds the earliest time of any guarantee violation. To do this correctly, it iterates from $k=0$ up to $T$ and checks all applicable guarantee conditions at each time step $k$.\n  - At each $k \\in \\{0, \\dots, T\\}$, it checks the state safety condition: $\\lVert \\mathbf{x}_k \\rVert_\\infty  x_{\\max}$. According to the problem's explicit rule, this check only counts as a violation if no assumption violation has occurred at or before this time (i.e., if $t_\\mathcal{A} = -1$ or $k  t_\\mathcal{A}$).\n  - At each $k \\in \\{0, \\dots, T-1\\}$, it checks the control input magnitude: $|u_k|  u_{\\max}$.\n  - At each $k \\in \\{1, \\dots, T-1\\}$, it checks the control input rate of change: $|u_k - u_{k-1}|  \\Delta u_{\\max}$.\nThe first time $k$ at which any of these conditions are met, $t_\\mathcal{G}$ is set to $k$, and the search terminates. If no violations are found, $t_\\mathcal{G}$ remains $-1$.\n\n**3. Violation Classification**\nOnce $t_\\mathcal{A}$ and $t_\\mathcal{G}$ have been determined, a classification code $c$ is assigned based on the following logic, as specified in the problem statement:\n- If $t_\\mathcal{A}=-1$ and $t_\\mathcal{G}=-1$: $c=0$ (No violation).\n- If $t_\\mathcal{A} \\neq -1$ and $t_\\mathcal{G}=-1$: $c=1$ (Plant-side assumption violation only).\n- If $t_\\mathcal{A}=-1$ and $t_\\mathcal{G} \\neq -1$: $c=2$ (Controller-side guarantee violation only).\n- If $t_\\mathcal{G}  t_\\mathcal{A}$: $c=3$ (Both violated, controller-first).\n- If $t_\\mathcal{A} \\le t_\\mathcal{G}$: $c=4$ (Both violated, plant-first).\n\nThis structured approach ensures that the simulation is run completely first, generating all necessary data, and the monitoring is then performed systematically on the results, adhering strictly to the specified rules, particularly the subtle but critical rule for attributing state safety violations. The final implementation encapsulates this logic in a Python script to execute the provided test suite.",
            "answer": "[[0,-1,-1],[1,5,-1],[2,-1,0],[0,-1,-1],[3,8,0],[0,-1,-1]]"
        }
    ]
}