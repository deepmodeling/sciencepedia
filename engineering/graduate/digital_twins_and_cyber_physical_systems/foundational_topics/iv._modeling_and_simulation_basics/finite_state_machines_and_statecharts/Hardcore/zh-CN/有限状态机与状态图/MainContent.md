## 引言
在[数字孪生](@entry_id:171650)与信息物理系统（Cyber-Physical Systems, CPS）日益复杂的今天，如何精确地描述、分析和控制系统的离散行为，已成为工程领域的核心挑战。有限状态机（Finite State Machines, FSM）及其强大的扩展——状态图（Statecharts），为此提供了坚实的理论基石和实用的工程工具。它们不仅是[计算理论](@entry_id:273524)的基石，更是连接抽象规范与具体实现的桥梁，让我们能够以严谨且直观的方式驾驭复杂性。

然而，从基础理论到解决真实世界问题的应用之间，存在着一条知识鸿沟。如何将DFA/NFA的抽象概念转化为高效的控制器？如何利用状态图的层次化与并发性来避免“[状态空间爆炸](@entry_id:1132298)”？如何确保系统在面对外部事件时行为的[原子性](@entry_id:746561)和正确性？本文旨在系统性地回答这些问题，为读者构建一个从理论到实践的完整知识体系。

在接下来的内容中，我们将分三步深入探索这个领域。**“原理与机制”**章节将奠定理论基础，从最基本的[有限自动机](@entry_id:1124972)讲起，逐步引入Mealy/[Moore机](@entry_id:170836)、[状态图](@entry_id:1132299)的结构化概念，并阐明其精确的“[运行到完成](@entry_id:1131144)”操作语义。随后，**“应用与跨学科连接”**章节将展示这些模型在CPS建模与控制、形式化验证、监督控制以及系统学习等领域的强大应用，揭示理论在实践中的力量。最后，**“动手实践”**部分将提供一系列精心设计的问题，让您亲手应用所学知识，解决具体的建模与分析挑战。让我们一同开启这段探索状态驱动系统奥秘的旅程。

## 原理与机制

### 基础：作为语言识别器的[有限自动机](@entry_id:1124972)

在深入研究复杂的[状态机](@entry_id:171352)模型之前，我们必须首先建立其理论基础：**[有限自动机](@entry_id:1124972) (Finite Automata)**。作为[计算理论](@entry_id:273524)中最基本的模型之一，[有限自动机](@entry_id:1124972)为描述和识别离散事件序列中的模式提供了严格的数学框架。在[数字孪生](@entry_id:171650)和[信息物理系统 (CPS)](@entry_id:1123330) 的背景下，这些事件序列可以代表来自传感器的读数、用户命令或网络数据包。

#### 确定性[有限自动机](@entry_id:1124972) (DFA)

一个**确定性[有限自动机](@entry_id:1124972) (Deterministic Finite Automaton, DFA)** 是对系统行为的一种精确、无歧义的描述。形式上，一个 DFA 是一个五元组 $A=(Q, \Sigma, \delta, q_0, F)$，其中：

*   $Q$ 是一个有限的状态集合。
*   $\Sigma$ 是一个有限的输入符号字母表，代表系统可能遇到的所有离散事件。
*   $\delta: Q \times \Sigma \to Q$ 是**转移函数 (transition function)**。其定义域为 $Q \times \Sigma$，陪域为 $Q$。这意味着对于任何给定的当前状态 $q \in Q$ 和任何输入符号 $a \in \Sigma$，都存在一个且仅有一个确定的下一状态。这种唯一性是“确定性”的本质。
*   $q_0 \in Q$ 是唯一的**初始状态 (initial state)**。
*   $F \subseteq Q$ 是一个**接受状态 (accepting states)** 或终结状态的集合。

一个 DFA 处理一个输入字符串（或称为“词”）$w \in \Sigma^*$ 的过程，是从初始状态 $q_0$ 开始，根据字符串中的每个符号，依次通过转移函数 $\delta$ 跳转到下一个状态。这个状态序列被称为一次**运行 (run)**。由于 $\delta$ 的确定性，对于任何输入字符串 $w$，都存在唯一的运行。如果这次运行最终停止在一个接受状态 $f \in F$，我们就说该字符串 $w$ 被 DFA $A$ **接受 (accepted)**。所有能被 $A$ 接受的字符串的集合构成了该自动机所识别的**语言 (language)**，记为 $L(A)$。

在实践中，转移函数 $\delta$ 可能不是一个**全函数 (total function)**，即对于某些状态-输入对 $(q, a)$，$\delta(q, a)$ 没有定义。这被称为**部分转移函数 (partial transition function)**。这在形式上是允许的，只要每个有定义的转移都指向唯一的下一状态。为了理论上的完备性，我们可以通过引入一个非接受的“陷阱”或“汇”状态（sink state）$\bot$，将任何部分函数转化为全函数。所有未定义的转移都指向 $\bot$，并且从 $\bot$ 出发的所有转移都将回到 $\bot$。这种转换不会改变自动机所识别的语言，但简化了理论分析。

#### [非确定性有限自动机 (NFA)](@entry_id:263987)

与 DFA 的严格确定性相比，**[非确定性有限自动机](@entry_id:273744) (Nondeterministic Finite Automaton, NFA)** 提供了更大的灵活性。一个 NFA 的形式化定义与 DFA 类似，但其转移函数和初始状态的定义有所不同。一个 NFA 是一个五元组 $A'=(Q, \Sigma, \Delta, I, F)$，其中 $Q, \Sigma, F$ 的含义与 DFA 相同，但：

*   $\Delta: Q \times \Sigma \to 2^Q$ 是转移函数，其中 $2^Q$ 是 $Q$ 的**[幂集](@entry_id:137423) (power set)**。这意味着对于一个给定的状态 $q$ 和输入符号 $a$，$\Delta(q, a)$ 的结果是一个包含零个、一个或多个状态的**集合**。
*   $I \subseteq Q$ 是一个**初始状态集合**。

NFA 的[非确定性](@entry_id:273591)源于其转移函数可以指向多个可能的下一状态。因此，对于同一个输入字符串，一个 NFA 可能存在多条不同的运行路径，甚至没有路径。

NFA 的接受条件是存在性的：如果对于一个输入字符串 $w$，**至少存在一条**从某个初始状态 $i \in I$ 开始的运行路径，其最终停留在某个接受状态 $f \in F$，那么该字符串 $w$ 就被 NFA $A'$ 接受。

尽管 NFA 看起来比 DFA 更强大，但一个[计算理论](@entry_id:273524)的基石性定理指出，它们的表达能力是等价的。对于任何一个 NFA，我们总能通过一个名为**[子集构造法](@entry_id:271646) (subset construction)** 的过程，构造出一个识别相同语言的 DFA。反之亦然，因为 DFA 本身就是 NFA 的一个特例。因此，DFA 和 NFA 识别的是同一类语言，即**[正则语言](@entry_id:267831) (regular languages)**。这意味着，在选择监控模型时，无论是编译为 DFA 还是 NFA，其能够识别的事件轨迹模式的类别是相同的，尽管生成的自动机在状态数量和结构上可能存在巨大差异。

#### 最小化与 Myhill-Nerode 定理

对于任何一个[正则语言](@entry_id:267831) $L$，是否存在一个唯一的、最简洁的 DFA 来识别它？**Myhill-Nerode 定理** 为此提供了深刻的答案。该定理的核心是**不可区分性关系 (indistinguishability relation)** $\equiv_L$。对于任意两个字符串 $x, y \in \Sigma^*$，我们说它们是不可区分的，记为 $x \equiv_L y$，当且仅当对于任意的后缀字符串 $z \in \Sigma^*$，字符串 $xz$ 和 $yz$ 要么都属于语言 $L$，要么都不属于语言 $L$。

$x \equiv_L y \iff \forall z \in \Sigma^*, (xz \in L \Leftrightarrow yz \in L)$

这个关系是一个[等价关系](@entry_id:138275)，它将所有可能的输入字符串划分为若干个**[等价类](@entry_id:156032) (equivalence classes)**。直观上，如果两个字符串 $x$ 和 $y$ 是不可区分的，那么从自动机的角度看，在处理完它们之后，系统所处的“状态”应该是等效的，因为无论未来发生什么事件序列 $z$，系统最终是否会进入接受状态的行为将是完全一致的。

Myhill-Nerode 定理指出：

1.  一个语言 $L$ 是正则的，当且仅当关系 $\equiv_L$ 只有有限个[等价类](@entry_id:156032)。
2.  如果 $L$ 是正则的，那么识别 $L$ 的**最小确定性[有限自动机](@entry_id:1124972) (minimal DFA)** 的状态数量，恰好等于 $\equiv_L$ 的[等价类](@entry_id:156032)的数量。

这个定理的意义是巨大的。它不仅为[正则语言](@entry_id:267831)提供了代数上的刻画，还保证了对于任何[正则语言](@entry_id:267831)，都存在一个结构上唯一的最小 DFA。这个最小 DFA 的每一个状态都精确地对应于 $\equiv_L$ 的一个[等价类](@entry_id:156032)。我们可以构造一个**典范自动机 (canonical automaton)**，其状态就是这些[等价类](@entry_id:156032)，初始状态是包含空字符串 $\varepsilon$ 的[等价类](@entry_id:156032) $[\varepsilon]$，转移规则为 $\delta([x], a) = [xa]$。这个典范自动机就是识别 $L$ 的最小 DFA。

### 作为输出转换器的[有限自动机](@entry_id:1124972)：Moore 和 Mealy 机

虽然作为语言识别器的 DFA 和 NFA 在理论上至关重要，但在 CPS [控制器设计](@entry_id:274982)中，我们更关心系统如何根据输入生成相应的输出。**[有限自动机](@entry_id:1124972)转换器 (Finite Automata Transducer)** 正是为此而生，其中最经典的是 Mealy 机和 Moore 机。

#### Mealy 机：输出与状态和输入相关

一个 **Mealy 机**是一个六元组 $M = (Q, \Sigma, \Omega, \delta, \lambda, q_0)$，其中 $Q, \Sigma, \delta, q_0$ 的定义与 DFA 类似，新增了：

*   $\Omega$ 是一个有限的输出字母表。
*   $\lambda: Q \times \Sigma \to \Omega$ 是**输出函数 (output function)**。

Mealy 机的关键特征是，其在时刻 $t$ 的输出 $y_t$ 取决于当前状态 $q_t$ 和当前输入 $x_t$。输出是在状态转移的“边”上产生的。

让我们通过一个具体的例子来理解 Mealy 机的设计过程。考虑一个[数字孪生](@entry_id:171650)中的确定性反应式控制器，它监控一个二进制事件流 $\{x_t\}$，并需要根据规范 $y_t = x_t \oplus x_{t-1}$ 生成输出流 $\{y_t\}$，其中 $\oplus$ 代表异或运算，并约定 $x_{-1} = 0$。

要计算 $y_t$，控制器在时刻 $t$ 需要知道两样东西：当前输入 $x_t$ 和前一时刻的输入 $x_{t-1}$。$x_t$ 是即时获得的，但 $x_{t-1}$ 必须被“记住”。这正是[状态机](@entry_id:171352)中“状态”的核心作用：**状态是历史信息的[有限记忆](@entry_id:136984)**。

由于 $x_{t-1}$ 只有两种可能的值（0 或 1），我们至少需要两个状态来编码这个信息。我们定义状态集 $Q = \{S_0, S_1\}$，其中：

*   $S_0$：表示前一个输入是 0。
*   $S_1$：表示前一个输入是 1。

根据初始条件 $x_{-1} = 0$，初始状态 $q_0$ 必须是 $S_0$。

接下来，我们定义输出函数 $\lambda(q, x)$ 和转移函数 $\delta(q, x)$：

*   **输出函数 $\lambda$**:
    *   $\lambda(S_0, 0) = 0 \oplus 0 = 0$ (当前[状态表示](@entry_id:141201) $x_{t-1}=0$，当前输入 $x_t=0$)
    *   $\lambda(S_0, 1) = 1 \oplus 0 = 1$ (当前[状态表示](@entry_id:141201) $x_{t-1}=0$，当前输入 $x_t=1$)
    *   $\lambda(S_1, 0) = 0 \oplus 1 = 1$ (当前[状态表示](@entry_id:141201) $x_{t-1}=1$，当前输入 $x_t=0$)
    *   $\lambda(S_1, 1) = 1 \oplus 1 = 0$ (当前[状态表示](@entry_id:141201) $x_{t-1}=1$，当前输入 $x_t=1$)

*   **转移函数 $\delta$**: 系统的下一个状态（在时刻 $t+1$）必须记住时刻 $t$ 的输入 $x_t$。
    *   如果当前输入 $x_t=0$，那么下一个状态必须是 $S_0$。因此 $\delta(S_0, 0) = S_0$ 且 $\delta(S_1, 0) = S_0$。
    *   如果当前输入 $x_t=1$，那么下一个状态必须是 $S_1$。因此 $\delta(S_0, 1) = S_1$ 且 $\delta(S_1, 1) = S_1$。

我们已经成功构建了一个拥有 2 个状态的 Mealy 机。可以证明，任何状态数少于 2 的机器都无法实现该规范，因为单个状态无法区分 $x_{t-1}=0$ 和 $x_{t-1}=1$ 这两种必须产生不同输出的历史情境。因此，这个 Mealy 机的最小状态数为 2。

#### Moore 机：输出仅与状态相关

与 Mealy 机不同，一个 **Moore 机** 的输出只依赖于其当前所处的状态，而与当前输入无关。其形式化定义 $M=(Q, \Sigma, \delta, q_0, Y, \omega)$ 中，输出函数被定义为 $\omega: Q \to Y$。输出是在“状态”中产生的。

让我们考虑一个为 CPS 设计的心跳发生器。该发生器被建模为一个 Moore 机，它处理来自字母表 $\Sigma=\{a,b\}$ 的输入流，并且必须每隔 3 个输入符号就输出一个心跳脉冲（输出 1），其他时候输出 0。输出行为与具体输入符号无关。

这个任务要求机器对输入符号进行计数，模 3。这需要三个状态来分别代表计数器值为 0, 1, 2 的情况。我们定义状态集 $Q = \{S_0, S_1, S_2\}$。

*   $S_0$：表示已处理的符号数是 3 的倍数。
*   $S_1$：表示已处理的符号数模 3 余 1。
*   $S_2$：表示已处理的符号数模 3 余 2。

初始时，处理了 0 个符号，所以初始状态 $q_0 = S_0$。

*   **转移函数 $\delta$**: 由于输出与具体输入无关，所以从任何状态出发，接收 $a$ 或 $b$ 都应转移到相同的下一状态，以推进计数。
    *   $\delta(S_0, x) = S_1$ (for $x \in \{a,b\}$)
    *   $\delta(S_1, x) = S_2$ (for $x \in \{a,b\}$)
    *   $\delta(S_2, x) = S_0$ (for $x \in \{a,b\}$)
    这个设计确保了[状态机](@entry_id:171352)以 3 为周期循环：$S_0 \to S_1 \to S_2 \to S_0 \to \dots$。状态序列的周期长度 $L$ 为 3。

*   **输出函数 $\omega$**: Moore 机的输出是在进入一个状态后产生的。规范要求在处理完第 $k$ 个符号后，如果 $k$ 是 3 的倍数，则输出 1。
    *   处理完第 $k$ 个符号后（$k \ge 1$），机器进入状态 $q_k$。$q_k$ 的状态序列是 $S_1, S_2, S_0, S_1, \dots$。
    *   当 $k$ 是 3 的倍数时（例如 $k=3, 6, \dots$），机器进入状态 $S_0$。因此，我们必须定义 $\omega(S_0) = 1$。
    *   当 $k$ 模 3 余 1 或 2 时，机器分别进入 $S_1$ 或 $S_2$。此时应输出 0。因此，$\omega(S_1) = 0$ 和 $\omega(S_2) = 0$。

这个 Moore 机精确地实现了心跳发生器的规范。它与 Mealy 机的核心区别在于输出的时机和依赖关系：Mealy 机的输出与转移同步，而 Moore 机的输出与状态同步。

### 扩展复杂性：状态图 (Statecharts) 形式化

当系统变得复杂时，“扁平”的有限状态机模型很快会因状态数量的急剧增长而变得难以管理。**[状态图](@entry_id:1132299) (Statecharts)**，由 David Harel 提出，通过引入**层次 (hierarchy)**、**并发 (concurrency)** 和**历史 (history)** 等结构化概念，极大地增强了 FSM 的表达力和[可扩展性](@entry_id:636611)。

#### 层次（OR-状态）与并发（AND-状态）

[状态图](@entry_id:1132299)的核心是两种类型的复合状态：

*   **OR-状态 (OR-states)**：也称为分层析取状态，它将一组子状态封装起来。如果一个系统处于某个 OR-状态，那么它必须**精确地处于其一个直接子状态**中。这建立了状态的父子层次关系。

*   **AND-状态 (AND-states)**：也称为正交合取状态，它包含两个或多个并行的**正交区域 (orthogonal regions)**。如果系统处于一个 AND-状态，那么它必须**同时在每个正交区域中各处于一个子状态**。这为建模并发行为提供了强大的形式化工具。

形式上，一个状态图的**构型 (configuration)** 可以由一组当前活动的**基本状态 (basic states)**（即没有子状态的叶子状态）来定义。这个集合必须满足：对于任何活动的 OR-状态，其后代中只有一个基本状态是活动的；对于任何活动的 AND-状态，其每个正交区域的后代中都有一个基本状态是活动的。

#### 历史伪状态

在复杂的交互逻辑中，当系统离开一个复合状态后再次返回时，我们常常希望它能恢复到离开前的状态，而不是每次都从默认的初始子状态开始。**历史伪状态 (History Pseudostates)** 提供了这种记忆功能。

*   **浅历史 (Shallow History, H)**：当通过浅历史伪状态返回一个复合状态时，系统会恢复到它离开时所处的**直接子状态**。如果这个子状态本身也是复合的，那么系统将进入其**默认的初始子状态**。

*   **深历史 (Deep History, H*)**：当通过深历史伪状态返回时，系统会恢复到它离开时所处的**完整的嵌套状态构型**，直至最底层的叶子状态。

让我们通过一个例子来阐明其区别。 考虑一个顶层复合状态 $S$，它包含两个正交区域 $R^{(1)}$ 和 $R^{(2)}$。
*   $R^{(1)}$ 中有一个复合状态 $A$，其子状态为 $A_1$ (默认) 和 $A_2$。$A_2$ 又是复合的，子状态为 $a$ (默认) 和 $b$。
*   $R^{(2)}$ 中有一个复合状态 $B$，其子状态为 $B_1$ (默认) 和 $B_2$。$B_2$ 又是复合的，子状态为 $c$ (默认) 和 $d$。

系统初始构型为 $(A_1, B_1)$。经过一系列事件后，系统构型演变为 $(b, d)$。此时，一个全局事件 $x$ 使系统完全离开 $S$，随后一个返回事件 $r$ 通过 $S$ 的历史伪状态使其重新进入。

*   **在浅历史语义下**：
    *   在 $R^{(1)}$ 中，离开时 $S$ 的直接子状态是 $A_2$。返回时，系统恢复到 $A_2$。由于 $A_2$ 是复合的，系统进入其默认子状态 $a$。
    *   在 $R^{(2)}$ 中，离开时 $S$ 的直接子状态是 $B_2$。返回时，系统恢复到 $B_2$，并进入其默认子状态 $c$。
    *   因此，浅历史恢复的构型是 $(a, c)$。

*   **在深历史语义下**：
    *   系统会恢复离开前的完整叶子状态构型。
    *   因此，深历史恢复的构型是 $(b, d)$。

这两种历史机制为控制器逻辑的设计提供了不同粒度的状态保持能力，是状态图强大功能的重要体现。

### 操作语义：执行基于状态的模型

拥有了丰富的结构化模型后，下一个关键问题是：这些模型到底是如何执行的？**操作语义 (Operational Semantics)** 定义了[状态机](@entry_id:171352)响应事件、评估条件和执行动作的精确规则，这对保证系统的可预测性和正确性至关重要。

#### 扩展有限状态机：变量、守卫与动作

现代状态图通常是**扩展[有限状态机](@entry_id:174162) (Extended FSMs)**，它们在纯事件驱动模型的基础上增加了数据变量。一个转移不仅可以由事件触发，还可以受一个**守卫 (guard)** 条件的约束，并在触发时执行一个**动作 (action)**。

*   **变量 (Variables)**：[状态机](@entry_id:171352)可以维护一组变量，其取值构成了系统的**估值 (valuation)** $\nu$。
*   **守卫 (Guards)**：一个守卫 $g: \mathcal{V} \to \{\text{true}, \text{false}\}$ 是一个[布尔表达式](@entry_id:262805)，它基于当前的变量估值 $\nu$ 进行求值。只有当事件发生且守卫为真时，转移才会被启用。
*   **动作 (Actions)**：一个动作 $a: \mathcal{V} \to \mathcal{V}$ 是一个函数，它在转移执行时被调用，用以更新变量的估值。

#### [运行到完成](@entry_id:1131144) (Run-to-Completion, RTC)

**[运行到完成](@entry_id:1131144) (Run-to-Completion, RTC)** 是大多数现代状态机（如 UML 状态机）采用的核心执行模型。其基本思想是，对一个外部事件的处理是**原子的**。一旦系统开始处理一个外部事件，它会完成所有由该事件直接或间接引发的内部状态变化，直到系统达到一个**稳定 (stable)** 或**静默 (quiescent)** 的构型，然后才能处理下一个外部事件。

这个过程被分解为**宏观步 (macrostep)** 和**微观步 (microstep)**：

*   **宏观步**：处理单个外部事件的完整、原子过程。它由一系列微观步组成。
*   **微观步**：[状态机](@entry_id:171352)执行的单个、瞬时的基本步骤，通常包括：选择一个被启用的转移，执行源状态的退出动作、转移自身的动作以及目标状态的进入动作。

一个宏观步的流程如下：
1.  从外部事件队列中取出一个事件。
2.  执行一个微观步。这个步骤可能会产生**内部事件**（例如，动作生成的信号或进入新状态产生的完成事件）。这些内部事件被添加到内部事件队列中。
3.  只要内部事件队列不为空，并且有可被触发的转移，就持续执行微观步。
4.  当内部事件队列为空，或没有更多可被触发的转移时，系统达到稳定状态，宏观步结束。

在整个宏观步期间，新到达的外部事件会被放入外部事件队列中，但不会被处理，从而确保了对当前事件处理的[原子性](@entry_id:746561)，避免了竞态条件。

#### 事件处理的原子性与正确性

RTC 模型的正确性依赖于对守卫求值和动作执行的严格语义定义。为了保证可预测性和可验证性，同步/反应式模型通常遵循以下原则：

1.  **基于前一状态的守卫求值**：在一个宏观步开始时，所有待处理的转移的守卫都是基于该步骤开始前的变量估值 $\nu$ 进行求值的。这确保了在一个宏观步内，哪些转移是“候选”的是一次性确定的。
2.  **确定[性冲突](@entry_id:152298)解决**：当一个事件可能触发多个冲突的转移时（例如，从同一个状态出发的不同转移），必须有一个确定性的规则（如优先级）来选择其中一个。
3.  **动作的原子执行**：一旦一个转移被选中，其动作 $a$ 将被原子地执行，产生一个新的估值 $\nu' = a(\nu)$。在动作执行期间，其他转移不能观察到中间的、不一致的变量状态。

这种严格的“先感知，后执行”的原子模型，使得对系统行为的验证成为可能。例如，要证明一个安全不变量 $I(\nu)$ 在系统运行中始终保持，我们只需要为每个转移证明一个霍尔三元组 (Hoare triple) 形式的命题：$I(\nu) \land g(\nu) \Rightarrow I(a(\nu))$。即，如果在转移前不变量成立且守卫为真，那么在执行完原子动作后，不变量依然成立。

在实际系统中，事件通常通过**先进先出 (FIFO) 队列**进行管理。只要每个宏观步都保证在有限时间内终止（即不存在无限的内部[事件循环](@entry_id:749127)），并且外部事件的到达不是芝诺式的（即在有限时间内不会有无限个事件到达），那么 FIFO 队列策略就能确保每个外部事件最终都会被处理，从而避免**饥饿 (starvation)** 现象。

### 在 CPS 中的建模与控制应用

有限状态机及其扩展为 CPS 的建模、分析和控制提供了坚实的基础。本节将探讨几个关键应用领域。

#### 组合与[状态空间爆炸](@entry_id:1132298)

在 CPS 中，系统行为通常由多个并发运行的组件共同决定。在形式化建模中，这对应于对代表各个组件的自动机进行**同步组合 (synchronous composition)**。组合后的系统状态是各组件状态的**[笛卡尔积](@entry_id:154642) (Cartesian product)**。

例如，如果我们有三个并发的控制器，分别用状态数为 3、4 和 5 的 DFA $\mathcal{A}_1, \mathcal{A}_2, \mathcal{A}_3$ 建模，那么描述整个系统行为的组合自动机的[状态空间](@entry_id:160914)上限将是 $|Q_1| \times |Q_2| \times |Q_3| = 3 \times 4 \times 5 = 60$。 状态数量随组件数量呈指数级增长，这就是所谓的**[状态空间爆炸](@entry_id:1132298) (state-space explosion)** 问题，它对系统的形式化验证构成了巨大挑战。

状态图的结构化特性为缓解这一问题提供了有效的策略：

1.  **层次化与抽象**：通过将一个组件的逻辑封装在一个 OR-超状态中，我们可以对其行为进行**抽象 (abstraction)**。例如，可以计算该组件的**最小等价自动机**（如通过**[互模拟](@entry_id:156097)等价 (bisimulation equivalence)**），并用这个更小的抽象模型来代替原始的复杂模型进行组合验证。这种**组合式最小化 (compositional minimization)** 可以在不影响外部可见行为的前提下，显著减小验证所需的[状态空间](@entry_id:160914)。

2.  **正交性与松耦合**：AND-状态明确地划分了并发组件。[状态空间爆炸](@entry_id:1132298)的根本原因在于组件间的紧密耦合（即大量的共享事件和同步转移）。通过精心设计，最小化正交区域之间的接口（即共享事件集），可以大幅削减从初始状态可达的组合状态数量。这使得**组合式验证 (compositional verification)**（如**假设-保证推理 (assume-guarantee reasoning)**）成为可能，即独立地验证每个组件的行为，而无需构造完整的、庞大的乘积自动机。

#### 监督控制

**监督控制理论 (Supervisory Control Theory)**（主要由 Ramadge 和 Wonham 发展）提供了一个在自动机框架下设计[安全控制](@entry_id:1131181)器的系统性方法。在该框架中，被控系统被称为**被控对象 (plant)**，用一个自动机 $P$ 来建模。

事件字母表 $\Sigma$ 被划分为**可控事件集 (controllable events)** $\Sigma_c$ 和**不可控事件集 (uncontrollable events)** $\Sigma_{uc}$。可控事件是可以被控制器禁止或启用的（如启动一个泵），而不可控事件则不能被控制器阻止（如传感器报告一个故障或用户按下紧急停止按钮）。

一个**控制器 (supervisor)** $S$ 的作用是观察被控对象产生的事件序列，并通过禁用某些**可控**事件来将系统的行为约束在一个给定的**安全规范 (specification)** $K$ 之内。其核心约束是：**控制器不能禁用一个已经被被控对象启用的不可控事件**。

形式上，一个控制器是一个函数 $S: L(P) \to 2^\Sigma$，它为被控对象生成的每个字符串 $s$ 指定一个被允许的事件集合 $S(s)$。这个函数必须满足：$\Gamma_P(s) \cap \Sigma_{uc} \subseteq S(s)$，其中 $\Gamma_P(s)$ 是被控对象在执行 $s$ 后自身启用的事件集合。这精确地表达了控制器对不可控事件的[无能](@entry_id:201612)为力。闭环系统 $S/P$ 的行为语言 $L(S/P)$ 必须是安全规范的子集，即 $L(S/P) \subseteq K$。

#### 实时系统与[时间自动机](@entry_id:1133177)

经典的[有限自动机](@entry_id:1124972)处理的是事件的逻辑顺序，而不关心它们发生的时间。然而，在 CPS 中，时间约束至关重要。**[时间自动机](@entry_id:1133177) (Timed Automaton)** 是对 FSM 的一个关键扩展，它引入了对连续时间的显式建模。

一个[时间自动机](@entry_id:1133177) $A=(Q, \Sigma, C, E, Inv, q_0, F)$ 在标准 FSM 的基础上增加了：

*   $C$：一个有限的**时钟 (clocks)** 集合。这些时钟是实数值变量，随时间同步增长。
*   $E$ 中的每条边不仅有事件，还关联一个**时钟守卫 (clock guard)** 和一个**时钟重置集 (clock reset set)**。守卫是关于时钟值的布尔条件（如 $x > 5$），只有守卫为真时，离散转移才能发生。重置集指定了哪些时钟在转移发生后被重置为 0。
*   $Inv: Q \to \mathsf{Constraints}(C)$：一个**不变量 (invariant)** 函数，为每个状态（在[时间自动机](@entry_id:1133177)中称为**位置 (location)**）分配一个时钟约束。

[时间自动机](@entry_id:1133177)的语义由两种类型的转移构成：

1.  **离散转移**：当系统处于位置 $q$，且某条出边的守卫被当前的时钟估值 $\nu$ 满足时，系统可以**瞬时**地发生一次离散转移到新位置 $q'$。在转移过程中，指定的时钟被重置为 0，形成新的时钟估值 $\nu'$。这个新的估值 $\nu'$ 必须立即满足目标位置 $q'$ 的不变量。

2.  **时间流逝 (Time Elapse)**：当系统停留在位置 $q$ 时，时间可以流逝。在时间流逝 $d$ 的过程中，所有时钟的值都增加 $d$。时间流逝的条件是，在整个流逝过程中，时钟估值必须**持续满足**当前位置 $q$ 的不变量。

通过这套双重语义，[时间自动机](@entry_id:1133177)能够精确地描述和分析包含时间延迟、超时和截止时间等约束的[实时系统](@entry_id:754137)行为，是 CPS 形式化验证的关键工具。