{
    "hands_on_practices": [
        {
            "introduction": "This exercise delves into a fundamental concept in dependability: imperfect fault coverage. While redundancy is a key strategy for building fault-tolerant systems, the assumption that faults are always perfectly detected and handled is often unrealistic. This practice  challenges you to move beyond idealized models by quantifying the catastrophic failure probability of a redundant system where the recovery mechanism itself can fail, providing a more accurate and practical approach to reliability assessment.",
            "id": "4243212",
            "problem": "A safety-critical Cyber-Physical System (CPS) uses redundancy and a Digital Twin (DT) to mitigate faults. The CPS employs two identical, independent controller replicas in a one-out-of-two hot-standby configuration: the system can tolerate the failure of a single controller replica if it is correctly detected and handled, but it loses control if both replicas fail within the mission time. The Digital Twin monitors the controllers and, upon a single controller fault, attempts to transition the CPS to a safe state (e.g., controlled shutdown). The attempt succeeds with coverage probability $c \\in (0,1)$ and fails with probability $1-c$. Assume:\n- Each controller has an exponentially distributed time to failure with constant hazard rate $\\lambda > 0$, and failures of replicas are independent.\n- The mission time is $T > 0$.\n- There is no repair and no common-cause failure during $[0,T]$.\n- Coverage attempts are independent of the fault occurrence, and a single fault that is covered prevents catastrophic failure. However, a double fault (both replicas fail during $[0,T]$) causes catastrophic failure regardless of coverage because no functioning controller remains.\n\nStarting from the fundamental reliability properties of the exponential distribution and the definition of independence, derive a closed-form analytic expression for the probability of catastrophic failure during $[0,T]$ under the combination of single-fault and double-fault scenarios described above. Express your final answer symbolically in terms of $c$, $\\lambda$, and $T$.",
            "solution": "Let $T_1$ and $T_2$ denote the random variables for the time to failure of the two identical and independent controller replicas. According to the problem statement, these failure times are exponentially distributed with a constant hazard rate $\\lambda > 0$.\n\nThe reliability of a single controller, which is the probability that it survives beyond time $t$, is given by the reliability function $R(t)$:\n$$R(t) = P(T_i > t) = \\exp(-\\lambda t) \\quad \\text{for } i \\in \\{1, 2\\}$$\nThe probability of a single controller failing on or before time $t$ is given by the cumulative distribution function (CDF), $F(t)$:\n$$F(t) = P(T_i \\le t) = 1 - R(t) = 1 - \\exp(-\\lambda t)$$\n\nThe mission time is a fixed duration $T > 0$. We are interested in the probability of failure events within the interval $[0, T]$. Let's denote the probability of a single controller surviving the mission as $R_T = R(T) = \\exp(-\\lambda T)$ and the probability of it failing during the mission as $F_T = F(T) = 1 - \\exp(-\\lambda T)$.\n\nA catastrophic failure occurs under two mutually exclusive conditions:\n1.  **Event A:** Exactly one of the two controllers fails within $[0, T]$, and this single fault is *not* successfully handled by the Digital Twin. The probability of this imperfect coverage is $1-c$.\n2.  **Event B:** Both controllers fail within $[0, T]$. The problem states that a double fault leads to catastrophic failure regardless of any coverage action.\n\nWe calculate the probability of each event.\n\n**Probability of Event B: Double Fault**\nEvent B occurs if controller 1 fails by time $T$ AND controller 2 fails by time $T$. Due to the independence of controller failures, the probability of this joint event is the product of their individual failure probabilities:\n$$P(B) = P(T_1 \\le T \\text{ and } T_2 \\le T) = P(T_1 \\le T) \\cdot P(T_2 \\le T) = F_T \\cdot F_T = F_T^2$$\nSubstituting the expression for $F_T$:\n$$P(B) = (1 - \\exp(-\\lambda T))^2$$\n\n**Probability of Event A: Single Uncovered Fault**\nFirst, we must determine the probability of exactly one controller failing during the mission time $T$. This can happen in two mutually exclusive ways:\n- Controller 1 fails ($T_1 \\le T$) and controller 2 survives ($T_2 > T$).\n- Controller 2 fails ($T_2 \\le T$) and controller 1 survives ($T_1 > T$).\n\nThe probability of the first case is $P(T_1 \\le T \\text{ and } T_2 > T) = F_T \\cdot R_T$ due to independence.\nThe probability of the second case is $P(T_2 \\le T \\text{ and } T_1 > T) = F_T \\cdot R_T$ due to independence and identical distributions.\n\nThe total probability of exactly one failure, which we denote as $P_{\\text{1-fault}}$, is the sum of these probabilities:\n$$P_{\\text{1-fault}} = F_T R_T + F_T R_T = 2 F_T R_T$$\nThis result is equivalent to the binomial probability of exactly one success (failure) in two trials, $\\binom{2}{1} F_T^1 R_T^{2-1}$.\nSubstituting the expressions for $F_T$ and $R_T$:\n$$P_{\\text{1-fault}} = 2 (1 - \\exp(-\\lambda T)) \\exp(-\\lambda T)$$\nEvent A is the occurrence of a single fault that is not covered. The probability of non-coverage is given as $1-c$. Since coverage is independent of the fault occurrence, we have:\n$$P(A) = P_{\\text{1-fault}} \\times P(\\text{not covered}) = (2 F_T R_T) (1-c)$$\n$$P(A) = 2(1-c)(1 - \\exp(-\\lambda T))\\exp(-\\lambda T)$$\n\n**Total Probability of Catastrophic Failure**\nThe total probability of catastrophic failure, $P_{CF}$, is the sum of the probabilities of the mutually exclusive events A and B:\n$$P_{CF} = P(A) + P(B)$$\n$$P_{CF} = 2(1-c)(1 - \\exp(-\\lambda T))\\exp(-\\lambda T) + (1 - \\exp(-\\lambda T))^2$$\nTo obtain the final closed-form expression, we perform algebraic simplification:\n$$P_{CF} = 2(1-c)(\\exp(-\\lambda T) - \\exp(-2\\lambda T)) + (1 - 2\\exp(-\\lambda T) + \\exp(-2\\lambda T))$$\nDistribute the $2(1-c)$ term:\n$$P_{CF} = (2\\exp(-\\lambda T) - 2\\exp(-2\\lambda T)) - (2c\\exp(-\\lambda T) - 2c\\exp(-2\\lambda T)) + 1 - 2\\exp(-\\lambda T) + \\exp(-2\\lambda T)$$\nNow, we group terms by their exponential factors:\n$$P_{CF} = 1 + (2\\exp(-\\lambda T) - 2\\exp(-\\lambda T) - 2c\\exp(-\\lambda T)) + (-2\\exp(-2\\lambda T) + \\exp(-2\\lambda T) + 2c\\exp(-2\\lambda T))$$\n$$P_{CF} = 1 + (-2c\\exp(-\\lambda T)) + (-\\exp(-2\\lambda T) + 2c\\exp(-2\\lambda T))$$\n$$P_{CF} = 1 - 2c\\exp(-\\lambda T) + (2c - 1)\\exp(-2\\lambda T)$$\nThis is the final simplified, closed-form analytic expression for the probability of catastrophic failure during the mission time $T$.",
            "answer": "$$\\boxed{1 - 2c\\exp(-\\lambda T) + (2c - 1)\\exp(-2\\lambda T)}$$"
        },
        {
            "introduction": "A central challenge in using digital twins for verification is ensuring that safety guarantees derived from the model hold for the actual cyber-physical system. This exercise  provides a rigorous method for bridging this model-reality gap by quantifying the impact of abstraction error. You will use principles from control theory to derive a strict bound on the deviation between the plant and its digital twin, thereby determining the conditions under which a safety proof can be considered robust.",
            "id": "4243186",
            "problem": "Consider a cyber-physical system (plant) with state $x(t) \\in \\mathbb{R}^{n}$ and input $u(t) \\in \\mathbb{R}^{m}$ governed by the differential equation $\\dot{x}(t) = f(x(t), u(t))$, where the vector field $f$ is globally Lipschitz in the state uniformly in the input with Lipschitz constant $L > 0$, meaning $||f(x_{1}, u) - f(x_{2}, u)|| \\leq L ||x_{1} - x_{2}||$ for all $x_{1}, x_{2} \\in \\mathbb{R}^{n}$ and all admissible $u$. A digital twin model (abstraction) uses the vector field $\\hat{f}(x, u)$ and simulates the twin trajectory $\\hat{x}(t)$ via $\\dot{\\hat{x}}(t) = \\hat{f}(\\hat{x}(t), u(t))$. Assume the abstraction error in the vector field is uniformly bounded by a constant $\\varepsilon \\geq 0$, namely $||f(x, u) - \\hat{f}(x, u)|| \\leq \\varepsilon$ for all $x$ and admissible $u$, and both the plant and the twin share the same initial condition $x(0) = \\hat{x}(0)$ and the same input signal $u(t)$ on a finite horizon $[0, T]$.\n\nLet the verified safe set be $S \\subset \\mathbb{R}^{n}$ with boundary $\\partial S$. A verification procedure performed on the digital twin has established that, for all $t \\in [0, T]$, the twin reachable set $\\hat{R}(t)$ satisfies a clearance condition $d(\\hat{R}(t), \\partial S) \\geq \\Delta$, where $d(A, B) = \\inf\\{||a - b|| : a \\in A, b \\in B\\}$ denotes the Euclidean distance between sets. The plant reachable set is $R(t)$ under the same input and initial condition. The verification is considered robust to abstraction error if the Hausdorff distance $d_{H}(R(t), \\hat{R}(t))$ between reachable sets remains bounded so that $R(t) \\subset S$ for all $t \\in [0, T]$.\n\nUsing only the stated Lipschitz property, the uniform abstraction error bound, and the definitions of reachable sets and the Hausdorff distance $d_{H}$, derive a bound on $d_{H}(R(t), \\hat{R}(t))$ over $[0, T]$, and determine the largest uniform abstraction error $\\varepsilon_{\\max}$ that guarantees the safety proof remains valid on $[0, T]$, in terms of $L$, $T$, and $\\Delta$. Then evaluate $\\varepsilon_{\\max}$ for $L = 1.1$, $T = 3$, and $\\Delta = 0.2$. Express your final answer as a real number and round your result to four significant figures.",
            "solution": "Let $e(t) = x(t) - \\hat{x}(t)$ be the error between the plant state and the twin state. The initial error is $e(0) = x(0) - \\hat{x}(0) = 0$. The time derivative of the error vector is given by:\n$$\n\\dot{e}(t) = \\dot{x}(t) - \\dot{\\hat{x}}(t) = f(x(t), u(t)) - \\hat{f}(\\hat{x}(t), u(t))\n$$\nTo find a bound on the norm of the error, $||\\dot{e}(t)||$, we add and subtract the term $f(\\hat{x}(t), u(t))$ and apply the triangle inequality:\n$$\n||\\dot{e}(t)|| = ||f(x(t), u(t)) - f(\\hat{x}(t), u(t)) + f(\\hat{x}(t), u(t)) - \\hat{f}(\\hat{x}(t), u(t))||\n$$\n$$\n||\\dot{e}(t)|| \\leq ||f(x(t), u(t)) - f(\\hat{x}(t), u(t))|| + ||f(\\hat{x}(t), u(t)) - \\hat{f}(\\hat{x}(t), u(t))||\n$$\nNow, we apply the two given bounds. The first term is bounded by the Lipschitz property of $f$:\n$$\n||f(x(t), u(t)) - f(\\hat{x}(t), u(t))|| \\leq L ||x(t) - \\hat{x}(t)|| = L ||e(t)||\n$$\nThe second term is bounded by the uniform abstraction error $\\varepsilon$:\n$$\n||f(\\hat{x}(t), u(t)) - \\hat{f}(\\hat{x}(t), u(t))|| \\leq \\varepsilon\n$$\nSubstituting these bounds into the inequality for $||\\dot{e}(t)||$ yields the following differential inequality for the norm of the error:\n$$\n||\\dot{e}(t)|| \\leq L ||e(t)|| + \\varepsilon\n$$\nThe rate of change of the norm of $e(t)$ is related to the norm of its derivative by $\\frac{d}{dt}||e(t)|| \\leq ||\\dot{e}(t)||$. Thus, we have the scalar differential inequality for the function $v(t) = ||e(t)||$:\n$$\n\\frac{d v(t)}{dt} \\leq L v(t) + \\varepsilon\n$$\nwith the initial condition $v(0) = ||e(0)|| = 0$. This is a standard form to which the Grönwall-Bellman inequality can be applied. To solve it, we can rearrange the inequality as $\\frac{d v(t)}{dt} - L v(t) \\leq \\varepsilon$. Multiplying by the integrating factor $\\exp(-Lt)$ gives:\n$$\n\\exp(-Lt) \\frac{d v(t)}{dt} - L \\exp(-Lt) v(t) \\leq \\varepsilon \\exp(-Lt)\n$$\n$$\n\\frac{d}{dt} \\left(v(t) \\exp(-Lt)\\right) \\leq \\varepsilon \\exp(-Lt)\n$$\nIntegrating both sides from $\\tau=0$ to $\\tau=t$:\n$$\n\\int_{0}^{t} \\frac{d}{d\\tau} \\left(v(\\tau) \\exp(-L\\tau)\\right) d\\tau \\leq \\int_{0}^{t} \\varepsilon \\exp(-L\\tau) d\\tau\n$$\n$$\nv(t) \\exp(-Lt) - v(0) \\exp(0) \\leq \\varepsilon \\left[-\\frac{1}{L} \\exp(-L\\tau)\\right]_{0}^{t}\n$$\nSince $v(0)=0$:\n$$\nv(t) \\exp(-Lt) \\leq -\\frac{\\varepsilon}{L} (\\exp(-Lt) - \\exp(0)) = \\frac{\\varepsilon}{L} (1 - \\exp(-Lt))\n$$\nMultiplying by $\\exp(Lt)$ to isolate $v(t) = ||e(t)||$, we obtain the bound on the error:\n$$\n||x(t) - \\hat{x}(t)|| \\leq \\frac{\\varepsilon}{L} (\\exp(Lt) - 1)\n$$\nSince the initial condition $x(0) = \\hat{x}(0)$ is a single point and the input $u(t)$ is a deterministic function, the reachable sets at any time $t$ are singletons: $R(t) = \\{x(t)\\}$ and $\\hat{R}(t) = \\{\\hat{x}(t)\\}$. For singleton sets, the Hausdorff distance $d_{H}(A, B)$ simplifies to the Euclidean distance between their elements. Therefore, the bound on the Hausdorff distance is:\n$$\nd_{H}(R(t), \\hat{R}(t)) = ||x(t) - \\hat{x}(t)|| \\leq \\frac{\\varepsilon}{L} (\\exp(Lt) - 1)\n$$\nThis is the desired bound on the Hausdorff distance for any $t \\in [0, T]$.\n\nNext, we determine the condition for robust safety. The verification on the twin ensures that for any $t \\in [0, T]$, the twin trajectory point $\\hat{x}(t)$ has a distance of at least $\\Delta$ from the boundary of the safe set, $\\partial S$. That is, $d(\\hat{x}(t), \\partial S) \\geq \\Delta$. For the true plant trajectory $x(t)$ to be guaranteed to stay within the safe set $S$, i.e., $x(t) \\in S$, its deviation from the twin trajectory must not exceed this safety margin $\\Delta$. A sufficient condition for safety is $d_{H}(R(t), \\hat{R}(t)) \\leq \\Delta$ for all $t \\in [0, T]$.\nThe bound we derived, $\\frac{\\varepsilon}{L}(\\exp(Lt) - 1)$, is a monotonically increasing function of $t$ for $L > 0$. Thus, the maximum deviation over the interval $[0, T]$ occurs at $t=T$:\n$$\n\\sup_{t \\in [0, T]} d_{H}(R(t), \\hat{R}(t)) \\leq \\frac{\\varepsilon}{L} (\\exp(LT) - 1)\n$$\nTo ensure safety for all $t \\in [0, T]$, we impose the condition:\n$$\n\\frac{\\varepsilon}{L} (\\exp(LT) - 1) \\leq \\Delta\n$$\nSolving this inequality for $\\varepsilon$ gives:\n$$\n\\varepsilon \\leq \\frac{L \\Delta}{\\exp(LT) - 1}\n$$\nThe largest uniform abstraction error $\\varepsilon_{\\max}$ that guarantees safety is the upper limit of this inequality:\n$$\n\\varepsilon_{\\max} = \\frac{L \\Delta}{\\exp(LT) - 1}\n$$\n\nFinally, we evaluate $\\varepsilon_{\\max}$ for the given numerical values: $L = 1.1$, $T = 3$, and $\\Delta = 0.2$.\n$$\nLT = 1.1 \\times 3 = 3.3\n$$\n$$\n\\varepsilon_{\\max} = \\frac{1.1 \\times 0.2}{\\exp(3.3) - 1} = \\frac{0.22}{\\exp(3.3) - 1}\n$$\nNow, we compute the numerical value:\n$$\n\\exp(3.3) \\approx 27.11263897\n$$\n$$\n\\varepsilon_{\\max} \\approx \\frac{0.22}{27.11263897 - 1} = \\frac{0.22}{26.11263897} \\approx 0.00842525\n$$\nRounding the result to four significant figures gives $0.008425$.",
            "answer": "$$\n\\boxed{0.008425}\n$$"
        },
        {
            "introduction": "Many critical dependability properties, such as ensuring a system always recovers from a fault, involve complex temporal sequences of events that are difficult to analyze with traditional methods. This practice  introduces Computation Tree Logic (CTL) as a powerful formal language for precisely specifying such behavioral properties. You will implement a model checker based on fixpoint algorithms to automatically verify if a finite-state abstraction of a system adheres to a critical recovery property, gaining hands-on experience with a cornerstone of formal verification.",
            "id": "4243214",
            "problem": "A finite-state abstraction of a cyber-physical system is modeled as a Kripke structure with the tuple $K = (S, R, L)$ where $S$ is a finite set of states, $R \\subseteq S \\times S$ is a total transition relation (for every $s \\in S$ there exists at least one $t \\in S$ such that $(s,t) \\in R$), and $L : S \\rightarrow 2^{AP}$ is a labeling function associating each state with a set of atomic propositions from a fixed set $AP$. Consider the atomic propositions $\\mathsf{fault}$ and $\\mathsf{rec}$, where $\\mathsf{fault}$ denotes that a transient fault is currently active in a state and $\\mathsf{rec}$ denotes that the system is in a recovered condition. The goal is to formally express the dependability property “on all paths, the system eventually recovers from a transient fault” using Computation Tree Logic (CTL) and verify it by computing the appropriate fixpoints on finite-state abstractions.\n\nBase definitions and semantics to use:\n- Computation Tree Logic (CTL) is defined over Kripke structures and allows path quantifiers $A$ (for all paths) and $E$ (there exists a path), combined with temporal operators such as $X$ (next), $G$ (globally), $F$ (eventually), and $U$ (until).\n- The semantic satisfaction set of an atomic proposition $\\varphi$ is $$\\mathsf{Sat}(\\varphi) = \\{ s \\in S \\mid \\varphi \\in L(s) \\}.$$\n- For the all-next operator, the satisfaction set of $AX\\,\\Phi$ is $$\\mathsf{Sat}(AX\\,\\Phi) = \\{ s \\in S \\mid \\forall t \\in S,\\ (s,t) \\in R \\Rightarrow t \\in \\mathsf{Sat}(\\Phi) \\}.$$\n- The eventually operator under universal path quantification can be characterized via the least fixpoint: $$\\mathsf{Sat}(AF\\,\\Phi) = \\mu Z.\\ \\mathsf{Sat}(\\Phi) \\cup \\mathsf{Sat}(AX\\,Z),$$ where $\\mu Z.\\ F(Z)$ denotes the least fixpoint of the monotone function $F$ over $2^S$.\n- The globally operator under universal path quantification can be characterized via the greatest fixpoint: $$\\mathsf{Sat}(AG\\,\\Phi) = \\nu Z.\\ \\mathsf{Sat}(\\Phi) \\cap \\mathsf{Sat}(AX\\,Z),$$ where $\\nu Z.\\ F(Z)$ denotes the greatest fixpoint of the monotone function $F$ over $2^S$.\n\nTask:\n- Express the property “on all paths the system eventually recovers from a transient fault” using CTL in terms of the atomic propositions $\\mathsf{fault}$ and $\\mathsf{rec}$. Your derivation must rely only on the base definitions above and must not introduce shortcut formulas not justified by these definitions.\n- Implement a fixpoint-based CTL model checker for the derived property on finite-state abstractions. You must construct fixpoints using set iteration over $S$ as implied by the $\\mu$ and $\\nu$ characterizations.\n\nInput Model:\nEach test case provides:\n- A finite set of states $S$ given as explicit integers.\n- A total transition relation $R$ as a set of ordered pairs $(s,t)$ with $s,t \\in S$.\n- Labeling sets $L_{\\mathsf{fault}} \\subseteq S$ and $L_{\\mathsf{rec}} \\subseteq S$ specifying which states are labeled with $\\mathsf{fault}$ and $\\mathsf{rec}$, respectively.\n\nYou must evaluate whether the property holds globally in the Kripke structure, meaning it must be satisfied at every state in $S$.\n\nTest Suite:\nUse the following test suite, which is part of the specification you must implement:\n\n- Test case $1$ (happy path, deterministic recovery):\n  - $S = \\{0, 1, 2\\}$\n  - $R = \\{(0,1), (1,2), (2,2)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\{2\\}$\n\n- Test case $2$ (branching includes a non-recovering path, violation expected):\n  - $S = \\{0, 1, 2, 3\\}$\n  - $R = \\{(0,1), (1,2), (1,3), (2,2), (3,3)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\{2\\}$\n\n- Test case $3$ (no fault anywhere, vacuous satisfaction expected):\n  - $S = \\{0, 1\\}$\n  - $R = \\{(0,0), (0,1), (1,1)\\}$\n  - $L_{\\mathsf{fault}} = \\varnothing$\n  - $L_{\\mathsf{rec}} = \\varnothing$\n\n- Test case $4$ (immediate recovery at fault state, satisfaction expected):\n  - $S = \\{0, 1\\}$\n  - $R = \\{(0,1), (1,1)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\{0\\}$\n\n- Test case $5$ (fault cycles with no recovery, violation expected):\n  - $S = \\{0, 1\\}$\n  - $R = \\{(0,1), (1,0)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\varnothing$\n\nOutput:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathsf{result1},\\mathsf{result2},\\mathsf{result3}]$), where each entry is a boolean indicating whether the property holds globally in the corresponding test case. No physical units or angle units are involved. The answers are booleans and must be computed exactly from the specified finite-state abstractions via fixpoint computations as defined above.",
            "solution": "The task is to verify the dependability property “on all paths, the system eventually recovers from a transient fault” for a given Kripke structure $K=(S,R,L)$. This process involves two main stages: first, expressing the property as a formal CTL formula, and second, implementing a model-checking algorithm based on fixpoint computation to determine the set of states satisfying this formula.\n\n**1. CTL Formulation of the Property**\n\nThe property \"on all paths, the system eventually recovers from a transient fault\" can be interpreted as a conditional statement: for any state on any path, if that state has a fault, then it must be the case that recovery is eventually reached on that same path.\n\nThis structure corresponds to the CTL formula $AG(\\varphi \\implies \\psi)$, where:\n- The path quantifier $A$ (\"for all paths\") and the temporal operator $G$ (\"globally\") enforce the condition on all states of all possible computation paths.\n- $\\varphi$ represents the condition \"a transient fault is currently active\", which is directly given by the atomic proposition $\\mathsf{fault}$.\n- $\\psi$ represents the outcome \"the system eventually recovers\", which means a state labeled with $\\mathsf{rec}$ is eventually reached. This is expressed in CTL as $AF\\,\\mathsf{rec}$.\n\nCombining these, the property is initially formulated as $AG(\\mathsf{fault} \\implies AF\\,\\mathsf{rec})$. Using the standard logical equivalence $p \\implies q \\equiv \\neg p \\lor q$, the formula can be rewritten in a form that is more direct to process using standard CTL semantics:\n$$\n\\Phi = AG(\\neg \\mathsf{fault} \\lor AF\\,\\mathsf{rec})\n$$\nThe goal is to determine if $\\Phi$ holds for all states $s \\in S$.\n\n**2. Fixpoint Characterization of Satisfaction Sets**\n\nThe verification process involves computing the satisfaction set $\\mathsf{Sat}(\\Phi)$, which contains all states in $S$ where the formula $\\Phi$ is true. This is done by recursively computing the satisfaction sets of its subformulas, using the provided fixpoint characterizations. Let $\\Psi = \\neg \\mathsf{fault} \\lor AF\\,\\mathsf{rec}$. Then $\\Phi = AG\\,\\Psi$.\n\nThe computation proceeds from the innermost subformula outward.\n\n**Step 2a: Compute $\\mathsf{Sat}(AF\\,\\mathsf{rec})$**\nThe operator $AF$ (all paths, eventually) is characterized by a least fixpoint. Let $Y = \\mathsf{Sat}(AF\\,\\mathsf{rec})$. According to the provided definition:\n$$\nY = \\mathsf{Sat}(AF\\,\\mathsf{rec}) = \\mu Z.\\ \\mathsf{Sat}(\\mathsf{rec}) \\cup \\mathsf{Sat}(AX\\,Z)\n$$\nHere, $\\mathsf{Sat}(\\mathsf{rec}) = L_{\\mathsf{rec}}$, the set of states labeled with $\\mathsf{rec}$. The set $\\mathsf{Sat}(AX\\,Z)$ contains states from which all immediate successor states are in the set $Z$. Let's define an operator $\\mathsf{pre}_A(Z) = \\mathsf{Sat}(AX\\,Z)$.\nThe least fixpoint $\\mu Z$ is computed iteratively, starting from the smallest possible set (the empty set $\\emptyset$) and repeatedly applying the function until a fixed point is reached.\nThe iterative sequence is:\n- $Y_0 = \\emptyset$\n- $Y_{i+1} = L_{\\mathsf{rec}} \\cup \\mathsf{pre}_A(Y_i)$\nSince the state space $S$ is finite, this sequence is guaranteed to converge to the least fixpoint in a finite number of steps, i.e., when $Y_{k+1} = Y_k$ for some $k$.\n\n**Step 2b: Compute $\\mathsf{Sat}(\\Psi) = \\mathsf{Sat}(\\neg \\mathsf{fault} \\lor AF\\,\\mathsf{rec})$**\nWith the set $Y = \\mathsf{Sat}(AF\\,\\mathsf{rec})$ computed, we can find the satisfaction set for $\\Psi$. The disjunction ($\\lor$) corresponds to the union of satisfaction sets:\n$$\n\\mathsf{Sat}(\\Psi) = \\mathsf{Sat}(\\neg \\mathsf{fault}) \\cup \\mathsf{Sat}(AF\\,\\mathsf{rec})\n$$\nThe set $\\mathsf{Sat}(\\neg \\mathsf{fault})$ is simply the complement of $\\mathsf{Sat}(\\mathsf{fault}) = L_{\\mathsf{fault}}$ with respect to the total set of states $S$.\n$$\n\\mathsf{Sat}(\\neg \\mathsf{fault}) = S \\setminus L_{\\mathsf{fault}}\n$$\nTherefore, the satisfaction set for $\\Psi$, which we will call $P_{\\Psi}$, is:\n$$\nP_{\\Psi} = (S \\setminus L_{\\mathsf{fault}}) \\cup Y\n$$\nThis set $P_{\\Psi}$ contains all states that are either not faulty or from which recovery is guaranteed on all paths.\n\n**Step 2c: Compute $\\mathsf{Sat}(\\Phi) = \\mathsf{Sat}(AG\\,\\Psi)$**\nThe final step is to compute the satisfaction set of the full formula $\\Phi$. The operator $AG$ (all paths, globally) is characterized by a greatest fixpoint. Let $G = \\mathsf{Sat}(AG\\,\\Psi)$. According to the provided definition:\n$$\nG = \\nu Z.\\ \\mathsf{Sat}(\\Psi) \\cap \\mathsf{Sat}(AX\\,Z)\n$$\nSubstituting $P_{\\Psi}$ for $\\mathsf{Sat}(\\Psi)$ and using the $\\mathsf{pre}_A$ operator:\n$$\nG = \\nu Z.\\ P_{\\Psi} \\cap \\mathsf{pre}_A(Z)\n$$\nThe greatest fixpoint $\\nu Z$ is computed iteratively, starting from the largest possible set (the set of all states $S$) and repeatedly applying the function until a fixed point is reached.\nThe iterative sequence is:\n- $Z_0 = S$\n- $Z_{i+1} = P_{\\Psi} \\cap \\mathsf{pre}_A(Z_i)$\nThis sequence is guaranteed to converge to the greatest fixpoint when $Z_{k+1} = Z_k$ for some $k$.\n\n**3. Global Verification**\n\nThe problem requires verifying that the property holds globally in the Kripke structure. This means the formula $\\Phi$ must be satisfied at every state $s \\in S$. After computing the final satisfaction set $G = \\mathsf{Sat}(\\Phi)$, the global property holds if and only if every state in $S$ is included in $G$. That is, the verification check is whether $G = S$.\n\nThe overall algorithm is as follows:\n1.  Construct a map of successors for each state from the transition relation $R$ for efficient computation of $\\mathsf{pre}_A(Z)$.\n2.  Compute $Y = \\mathsf{Sat}(AF\\,\\mathsf{rec})$ using the least fixpoint iteration starting from $\\emptyset$.\n3.  Compute $P_{\\Psi} = (S \\setminus L_{\\mathsf{fault}}) \\cup Y$.\n4.  Compute $G = \\mathsf{Sat}(AG\\,\\Psi)$ using the greatest fixpoint iteration starting from $S$.\n5.  Return `True` if $G=S$, and `False` otherwise. This procedure is applied to each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CTL model checking problem for the given test suite.\n    \"\"\"\n    # Test suite as specified in the problem description.\n    test_cases = [\n        {\n            \"S\": {0, 1, 2},\n            \"R\": {(0, 1), (1, 2), (2, 2)},\n            \"L_fault\": {0},\n            \"L_rec\": {2},\n        },\n        {\n            \"S\": {0, 1, 2, 3},\n            \"R\": {(0, 1), (1, 2), (1, 3), (2, 2), (3, 3)},\n            \"L_fault\": {0},\n            \"L_rec\": {2},\n        },\n        {\n            \"S\": {0, 1},\n            \"R\": {(0, 0), (0, 1), (1, 1)},\n            \"L_fault\": set(),\n            \"L_rec\": set(),\n        },\n        {\n            \"S\": {0, 1},\n            \"R\": {(0, 1), (1, 1)},\n            \"L_fault\": {0},\n            \"L_rec\": {0},\n        },\n        {\n            \"S\": {0, 1},\n            \"R\": {(0, 1), (1, 0)},\n            \"L_fault\": {0},\n            \"L_rec\": set(),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = model_check(\n            case[\"S\"],\n            case[\"R\"],\n            case[\"L_fault\"],\n            case[\"L_rec\"]\n        )\n        results.append(result)\n\n    # Format the boolean results as strings for the final output.\n    formatted_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef model_check(S, R, L_fault, L_rec):\n    \"\"\"\n    Performs fixpoint-based CTL model checking for the formula AG(fault -> AF(rec)).\n\n    Args:\n        S: A set of states (integers).\n        R: A set of transitions, where each transition is a tuple (s, t).\n        L_fault: A set of states where the 'fault' proposition is true.\n        L_rec: A set of states where the 'rec' proposition is true.\n\n    Returns:\n        A boolean indicating whether the property holds globally (for all states in S).\n    \"\"\"\n\n    # Pre-process R into a more efficient successor map.\n    successors = {s: set() for s in S}\n    for s, t in R:\n        successors[s].add(t)\n\n    def compute_ax(Z):\n        \"\"\"Computes Sat(AX Z) = {s in S | for all t s.t. (s,t) in R, t in Z}.\"\"\"\n        ax_z = set()\n        for s in S:\n            # R is total, so successors[s] is never empty.\n            if successors[s].issubset(Z):\n                ax_z.add(s)\n        return ax_z\n\n    # Step 1: Compute Sat(AF rec) = mu Z. (L_rec U Sat(AX Z))\n    # This is a least fixpoint calculation, iterating from the empty set.\n    Y = set()\n    while True:\n        Y_prev = Y\n        ax_Y = compute_ax(Y_prev)\n        Y = L_rec.union(ax_Y)\n        if Y == Y_prev:\n            break\n    sat_af_rec = Y\n\n    # Step 2: Compute Sat(neg fault OR AF rec)\n    # Sat(neg fault) = S \\ L_fault\n    sat_not_fault = S.difference(L_fault)\n    P_psi = sat_not_fault.union(sat_af_rec)\n\n    # Step 3: Compute Sat(AG(neg fault OR AF rec)) = nu Z. (P_psi INTERSECT Sat(AX Z))\n    # This is a greatest fixpoint calculation, iterating from the set of all states S.\n    Z = S.copy()\n    while True:\n        Z_prev = Z\n        ax_Z = compute_ax(Z_prev)\n        Z = P_psi.intersection(ax_Z)\n        if Z == Z_prev:\n            break\n    sat_ag_psi = Z\n\n    # Step 4: The property holds globally if the satisfaction set includes all states.\n    return sat_ag_psi == S\n\n# As per standard execution environments for such problems, we assume solve() is the entry point.\n# To make this runnable directly:\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}