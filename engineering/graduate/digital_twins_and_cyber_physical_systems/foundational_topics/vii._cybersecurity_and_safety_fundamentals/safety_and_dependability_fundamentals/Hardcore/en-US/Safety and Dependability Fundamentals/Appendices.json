{
    "hands_on_practices": [
        {
            "introduction": "Quantitative risk assessment is a cornerstone of safety engineering, and Fault Tree Analysis (FTA) is a powerful tool for this purpose. While many introductory analyses assume that basic component failures are independent events, real-world cyber-physical systems often exhibit complex dependencies. This exercise  moves beyond the simplified independence assumption, guiding you to derive from first principles how shared components and common-cause failures affect the overall system failure probability, a crucial step toward more realistic and accurate safety assessment.",
            "id": "4243229",
            "problem": "A cyber-physical process cell is supervised by a Digital Twin that performs Fault Tree Analysis (FTA) to estimate the probability of a hazardous top event. The top event, denoted $T$, occurs within a mission window if at least one of the two minimal cut sets fails: $\\{A,B\\}$ or $\\{B,C\\}$. Here $A$ denotes failure of a sensing channel, $B$ denotes failure of a shared controller, and $C$ denotes failure of an actuator interface during the mission window. Thus the minimal cut sets are overlapping on $B$. Let the marginal basic-event failure probabilities over the mission window be $p_{A} = \\mathbb{P}(A)$, $p_{B} = \\mathbb{P}(B)$, and $p_{C} = \\mathbb{P}(C)$, with $0 \\le p_{A}, p_{B}, p_{C} \\le 1$.\n\nStarting from the axioms of probability and the inclusion-exclusion principle, first express $\\mathbb{P}(T)$ in terms of joint probabilities of the basic events. Then consider two stochastic models:\n\n1. An independence model in which $A$, $B$, and $C$ are mutually independent over the mission window.\n\n2. A dependence model that captures shared-cause dependence between pairs $\\{A,B\\}$ and $\\{B,C\\}$ and possible simultaneous triple overlap, parameterized by nonnegative multipliers $\\alpha$ and $\\beta$ satisfying probabilistic feasibility constraints. In this model,\n$\\mathbb{P}(A \\cap B) = \\alpha\\, p_{A} p_{B}$, $\\mathbb{P}(B \\cap C) = \\alpha\\, p_{B} p_{C}$, and $\\mathbb{P}(A \\cap B \\cap C) = \\beta\\, p_{A} p_{B} p_{C}$.\n\nLet $\\mathbb{P}_{\\mathrm{ind}}(T)$ denote the top-event probability under the independence model and $\\mathbb{P}_{\\mathrm{dep}}(T)$ denote the top-event probability under the dependence model. Define the dependence impact as the difference $\\Delta \\equiv \\mathbb{P}_{\\mathrm{dep}}(T) - \\mathbb{P}_{\\mathrm{ind}}(T)$.\n\nUsing only the fundamental laws of probability and the inclusion-exclusion principle, derive a closed-form analytic expression for $\\Delta$ in terms of $p_{A}$, $p_{B}$, $p_{C}$, $\\alpha$, and $\\beta$. Provide your final answer as a single simplified expression. No numerical evaluation is required.",
            "solution": "We begin from the basic axioms of probability and the inclusion-exclusion principle. The top event $T$ occurs if at least one of the overlapping minimal cut sets fails. Denote $K_{1} \\equiv A \\cap B$ and $K_{2} \\equiv B \\cap C$. Then the top event is $T = K_{1} \\cup K_{2}$. By the inclusion-exclusion principle,\n$$\n\\mathbb{P}(T) \\;=\\; \\mathbb{P}(K_{1} \\cup K_{2}) \\;=\\; \\mathbb{P}(K_{1}) + \\mathbb{P}(K_{2}) - \\mathbb{P}(K_{1} \\cap K_{2}).\n$$\nBy construction, $K_{1} \\cap K_{2} = (A \\cap B) \\cap (B \\cap C) = A \\cap B \\cap C$, hence\n$$\n\\mathbb{P}(T) \\;=\\; \\mathbb{P}(A \\cap B) + \\mathbb{P}(B \\cap C) - \\mathbb{P}(A \\cap B \\cap C).\n$$\n\nUnder the independence model, the basic events $A$, $B$, and $C$ are mutually independent, so\n$$\n\\mathbb{P}_{\\mathrm{ind}}(T) \\;=\\; \\mathbb{P}(A)\\mathbb{P}(B) + \\mathbb{P}(B)\\mathbb{P}(C) - \\mathbb{P}(A)\\mathbb{P}(B)\\mathbb{P}(C) \\;=\\; p_{A} p_{B} + p_{B} p_{C} - p_{A} p_{B} p_{C}.\n$$\n\nUnder the dependence model, we are given that\n$$\n\\mathbb{P}(A \\cap B) \\;=\\; \\alpha\\, p_{A} p_{B}, \\quad\n\\mathbb{P}(B \\cap C) \\;=\\; \\alpha\\, p_{B} p_{C}, \\quad\n\\mathbb{P}(A \\cap B \\cap C) \\;=\\; \\beta\\, p_{A} p_{B} p_{C},\n$$\nwhere $\\alpha$ parameterizes the degree of pairwise positive dependence on the overlapping pairs $\\{A,B\\}$ and $\\{B,C\\}$ relative to the independent baseline, and $\\beta$ parameterizes the degree of triple overlap relative to the independent baseline. Substituting into the inclusion-exclusion expression yields\n$$\n\\mathbb{P}_{\\mathrm{dep}}(T) \\;=\\; \\alpha\\, p_{A} p_{B} + \\alpha\\, p_{B} p_{C} - \\beta\\, p_{A} p_{B} p_{C}.\n$$\n\nThe dependence impact $\\Delta$ is the difference\n$$\n\\Delta \\equiv \\mathbb{P}_{\\mathrm{dep}}(T) - \\mathbb{P}_{\\mathrm{ind}}(T),\n$$\nso substituting the two expressions above,\n\\begin{align*}\n\\Delta\n&= \\left(\\alpha\\, p_{A} p_{B} + \\alpha\\, p_{B} p_{C} - \\beta\\, p_{A} p_{B} p_{C}\\right) - \\left(p_{A} p_{B} + p_{B} p_{C} - p_{A} p_{B} p_{C}\\right) \\\\\n&= (\\alpha - 1)\\, p_{A} p_{B} + (\\alpha - 1)\\, p_{B} p_{C} - (\\beta - 1)\\, p_{A} p_{B} p_{C}.\n\\end{align*}\nThis can be factored as\n$$\n\\Delta \\;=\\; (\\alpha - 1)\\left(p_{A} p_{B} + p_{B} p_{C}\\right) - (\\beta - 1)\\, p_{A} p_{B} p_{C}.\n$$\n\nThis expression is derived solely from the axioms of probability and the inclusion-exclusion principle. It quantifies the impact of dependence: increasing $\\alpha$ (stronger pairwise overlap) increases $\\Delta$ linearly with slope $p_{A} p_{B} + p_{B} p_{C}$, while increasing $\\beta$ (stronger triple overlap for fixed pairwise terms) decreases $\\Delta$ linearly with slope $-\\, p_{A} p_{B} p_{C}$. The net effect of dependence on the top-event probability over the independent baseline is therefore captured exactly by the closed-form expression above.",
            "answer": "$$\\boxed{(\\alpha - 1)\\left(p_{A} p_{B} + p_{B} p_{C}\\right) - (\\beta - 1)\\, p_{A} p_{B} p_{C}}$$"
        },
        {
            "introduction": "Digital twins and other high-fidelity models are increasingly used for safety verification, but a fundamental question remains: how can a proof conducted on an abstract model guarantee the safety of the real physical system? This practice  tackles this \"reality gap\" head-on. By leveraging mathematical tools like Lipschitz continuity and Grönwall's inequality, you will quantify the deviation between a system and its model, allowing you to determine the maximum tolerable abstraction error for a safety proof to remain valid.",
            "id": "4243186",
            "problem": "Consider a cyber-physical system (plant) with state $x(t) \\in \\mathbb{R}^{n}$ and input $u(t) \\in \\mathbb{R}^{m}$ governed by the differential equation $\\dot{x}(t) = f(x(t), u(t))$, where the vector field $f$ is globally Lipschitz in the state uniformly in the input with Lipschitz constant $L > 0$, meaning $||f(x_{1}, u) - f(x_{2}, u)|| \\leq L ||x_{1} - x_{2}||$ for all $x_{1}, x_{2} \\in \\mathbb{R}^{n}$ and all admissible $u$. A digital twin model (abstraction) uses the vector field $\\hat{f}(x, u)$ and simulates the twin trajectory $\\hat{x}(t)$ via $\\dot{\\hat{x}}(t) = \\hat{f}(\\hat{x}(t), u(t))$. Assume the abstraction error in the vector field is uniformly bounded by a constant $\\varepsilon \\geq 0$, namely $||f(x, u) - \\hat{f}(x, u)|| \\leq \\varepsilon$ for all $x$ and admissible $u$, and both the plant and the twin share the same initial condition $x(0) = \\hat{x}(0)$ and the same input signal $u(t)$ on a finite horizon $[0, T]$.\n\nLet the verified safe set be $S \\subset \\mathbb{R}^{n}$ with boundary $\\partial S$. A verification procedure performed on the digital twin has established that, for all $t \\in [0, T]$, the twin reachable set $\\hat{R}(t)$ satisfies a clearance condition $d(\\hat{R}(t), \\partial S) \\geq \\Delta$, where $d(A, B) = \\inf\\{||a - b|| : a \\in A, b \\in B\\}$ denotes the Euclidean distance between sets. The plant reachable set is $R(t)$ under the same input and initial condition. The verification is considered robust to abstraction error if the Hausdorff distance $d_{H}(R(t), \\hat{R}(t))$ between reachable sets remains bounded so that $R(t) \\subset S$ for all $t \\in [0, T]$.\n\nUsing only the stated Lipschitz property, the uniform abstraction error bound, and the definitions of reachable sets and the Hausdorff distance $d_{H}$, derive a bound on $d_{H}(R(t), \\hat{R}(t))$ over $[0, T]$, and determine the largest uniform abstraction error $\\varepsilon_{\\max}$ that guarantees the safety proof remains valid on $[0, T]$, in terms of $L$, $T$, and $\\Delta$. Then evaluate $\\varepsilon_{\\max}$ for $L = 1.1$, $T = 3$, and $\\Delta = 0.2$. Express your final answer as a real number and round your result to four significant figures.",
            "solution": "Let $e(t) = x(t) - \\hat{x}(t)$ be the error between the plant state and the twin state. The initial error is $e(0) = x(0) - \\hat{x}(0) = 0$. The time derivative of the error vector is given by:\n$$\n\\dot{e}(t) = \\dot{x}(t) - \\dot{\\hat{x}}(t) = f(x(t), u(t)) - \\hat{f}(\\hat{x}(t), u(t))\n$$\nTo bound the norm of the error, $||\\dot{e}(t)||$, we use the triangle inequality:\n$$\n||\\dot{e}(t)|| = ||f(x(t), u(t)) - f(\\hat{x}(t), u(t)) + f(\\hat{x}(t), u(t)) - \\hat{f}(\\hat{x}(t), u(t))|| \\leq ||f(x(t), u(t)) - f(\\hat{x}(t), u(t))|| + ||f(\\hat{x}(t), u(t)) - \\hat{f}(\\hat{x}(t), u(t))||\n$$\nApplying the Lipschitz property of $f$ to the first term and the uniform abstraction error bound $\\varepsilon$ to the second term gives:\n$$\n||\\dot{e}(t)|| \\leq L ||x(t) - \\hat{x}(t)|| + \\varepsilon = L ||e(t)|| + \\varepsilon\n$$\nSince $\\frac{d}{dt}||e(t)|| \\leq ||\\dot{e}(t)||$, we have the scalar differential inequality for $v(t) = ||e(t)||$:\n$$\n\\frac{d v(t)}{dt} \\leq L v(t) + \\varepsilon, \\quad v(0) = 0\n$$\nBy the Grönwall-Bellman inequality, the solution to this is:\n$$\nv(t) \\leq \\frac{\\varepsilon}{L} (\\exp(Lt) - 1)\n$$\nThus, the deviation between the plant and twin trajectories is bounded by $||x(t) - \\hat{x}(t)|| \\leq \\frac{\\varepsilon}{L} (\\exp(Lt) - 1)$.\nSince the reachable sets are singletons, this bound is also the bound on the Hausdorff distance, $d_{H}(R(t), \\hat{R}(t))$. This bound is monotonically increasing in $t$, so the maximum deviation on $[0, T]$ occurs at $t=T$:\n$$\n\\sup_{t \\in [0, T]} d_{H}(R(t), \\hat{R}(t)) \\leq \\frac{\\varepsilon}{L} (\\exp(LT) - 1)\n$$\nFor the safety proof to be valid, this maximum deviation must not exceed the verified clearance $\\Delta$:\n$$\n\\frac{\\varepsilon}{L} (\\exp(LT) - 1) \\leq \\Delta\n$$\nSolving for $\\varepsilon$ gives the maximum tolerable uniform abstraction error:\n$$\n\\varepsilon_{\\max} = \\frac{L \\Delta}{\\exp(LT) - 1}\n$$\nPlugging in the values $L = 1.1$, $T = 3$, and $\\Delta = 0.2$:\n$$\n\\varepsilon_{\\max} = \\frac{1.1 \\times 0.2}{\\exp(1.1 \\times 3) - 1} = \\frac{0.22}{\\exp(3.3) - 1} \\approx \\frac{0.22}{27.112639 - 1} = \\frac{0.22}{26.112639} \\approx 0.00842525\n$$\nRounding to four significant figures, the result is $0.008425$.",
            "answer": "$$\n\\boxed{0.008425}\n$$"
        },
        {
            "introduction": "While quantitative analysis addresses the likelihood of failures, formal verification aims to prove the logical correctness of system behavior. Vague requirements like 'the system must eventually recover from a fault' can lead to design flaws. This practice  introduces Computation Tree Logic (CTL) as a precise language for specifying such temporal properties and challenges you to implement a model-checking algorithm based on fixpoint computation to automatically verify these properties on a system's state-space abstraction.",
            "id": "4243214",
            "problem": "A finite-state abstraction of a cyber-physical system is modeled as a Kripke structure with the tuple $K = (S, R, L)$ where $S$ is a finite set of states, $R \\subseteq S \\times S$ is a total transition relation (for every $s \\in S$ there exists at least one $t \\in S$ such that $(s,t) \\in R$), and $L : S \\rightarrow 2^{AP}$ is a labeling function associating each state with a set of atomic propositions from a fixed set $AP$. Consider the atomic propositions $\\mathsf{fault}$ and $\\mathsf{rec}$, where $\\mathsf{fault}$ denotes that a transient fault is currently active in a state and $\\mathsf{rec}$ denotes that the system is in a recovered condition. The goal is to formally express the dependability property “on all paths, the system eventually recovers from a transient fault” using Computation Tree Logic (CTL) and verify it by computing the appropriate fixpoints on finite-state abstractions.\n\nBase definitions and semantics to use:\n- Computation Tree Logic (CTL) is defined over Kripke structures and allows path quantifiers $A$ (for all paths) and $E$ (there exists a path), combined with temporal operators such as $X$ (next), $G$ (globally), $F$ (eventually), and $U$ (until).\n- The semantic satisfaction set of an atomic proposition $\\varphi$ is $$\\mathsf{Sat}(\\varphi) = \\{ s \\in S \\mid \\varphi \\in L(s) \\}.$$\n- For the all-next operator, the satisfaction set of $AX\\,\\Phi$ is $$\\mathsf{Sat}(AX\\,\\Phi) = \\{ s \\in S \\mid \\forall t \\in S,\\ (s,t) \\in R \\Rightarrow t \\in \\mathsf{Sat}(\\Phi) \\}.$$\n- The eventually operator under universal path quantification can be characterized via the least fixpoint: $$\\mathsf{Sat}(AF\\,\\Phi) = \\mu Z.\\ \\mathsf{Sat}(\\Phi) \\cup \\mathsf{Sat}(AX\\,Z),$$ where $\\mu Z.\\ F(Z)$ denotes the least fixpoint of the monotone function $F$ over $2^S$.\n- The globally operator under universal path quantification can be characterized via the greatest fixpoint: $$\\mathsf{Sat}(AG\\,\\Phi) = \\nu Z.\\ \\mathsf{Sat}(\\Phi) \\cap \\mathsf{Sat}(AX\\,Z),$$ where $\\nu Z.\\ F(Z)$ denotes the greatest fixpoint of the monotone function $F$ over $2^S$.\n\nTask:\n- Express the property “on all paths the system eventually recovers from a transient fault” using CTL in terms of the atomic propositions $\\mathsf{fault}$ and $\\mathsf{rec}$. Your derivation must rely only on the base definitions above and must not introduce shortcut formulas not justified by these definitions.\n- Implement a fixpoint-based CTL model checker for the derived property on finite-state abstractions. You must construct fixpoints using set iteration over $S$ as implied by the $\\mu$ and $\\nu$ characterizations.\n\nInput Model:\nEach test case provides:\n- A finite set of states $S$ given as explicit integers.\n- A total transition relation $R$ as a set of ordered pairs $(s,t)$ with $s,t \\in S$.\n- Labeling sets $L_{\\mathsf{fault}} \\subseteq S$ and $L_{\\mathsf{rec}} \\subseteq S$ specifying which states are labeled with $\\mathsf{fault}$ and $\\mathsf{rec}$, respectively.\n\nYou must evaluate whether the property holds globally in the Kripke structure, meaning it must be satisfied at every state in $S$.\n\nTest Suite:\nUse the following test suite, which is part of the specification you must implement:\n\n- Test case $1$ (happy path, deterministic recovery):\n  - $S = \\{0, 1, 2\\}$\n  - $R = \\{(0,1), (1,2), (2,2)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\{2\\}$\n\n- Test case $2$ (branching includes a non-recovering path, violation expected):\n  - $S = \\{0, 1, 2, 3\\}$\n  - $R = \\{(0,1), (1,2), (1,3), (2,2), (3,3)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\{2\\}$\n\n- Test case $3$ (no fault anywhere, vacuous satisfaction expected):\n  - $S = \\{0, 1\\}$\n  - $R = \\{(0,0), (0,1), (1,1)\\}$\n  - $L_{\\mathsf{fault}} = \\varnothing$\n  - $L_{\\mathsf{rec}} = \\varnothing$\n\n- Test case $4$ (immediate recovery at fault state, satisfaction expected):\n  - $S = \\{0, 1\\}$\n  - $R = \\{(0,1), (1,1)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\{0\\}$\n\n- Test case $5$ (fault cycles with no recovery, violation expected):\n  - $S = \\{0, 1\\}$\n  - $R = \\{(0,1), (1,0)\\}$\n  - $L_{\\mathsf{fault}} = \\{0\\}$\n  - $L_{\\mathsf{rec}} = \\varnothing$\n\nOutput:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\mathsf{result1},\\mathsf{result2},\\mathsf{result3}]$), where each entry is a boolean indicating whether the property holds globally in the corresponding test case. No physical units or angle units are involved. The answers are booleans and must be computed exactly from the specified finite-state abstractions via fixpoint computations as defined above.",
            "solution": "The task is to verify the property “on all paths, the system eventually recovers from a transient fault” on a Kripke structure $K=(S,R,L)$. This involves two stages: formalizing the property in CTL and implementing a fixpoint-based model checking algorithm.\n\n**1. CTL Formulation of the Property**\n\nThe property is a conditional statement: for any state on any path, if that state has a fault, then recovery must eventually be reached on that same path. This is expressed as $AG(\\mathsf{fault} \\implies AF\\,\\mathsf{rec})$. Using the logical equivalence $p \\implies q \\equiv \\neg p \\lor q$, the formula can be rewritten into a form more direct for standard CTL model checking:\n$$\n\\Phi = AG(\\neg \\mathsf{fault} \\lor AF\\,\\mathsf{rec})\n$$\nThe goal is to determine if this formula $\\Phi$ holds for all states $s \\in S$.\n\n**2. Fixpoint-Based Model Checking Algorithm**\n\nThe verification computes the satisfaction set $\\mathsf{Sat}(\\Phi)$ by recursively computing the satisfaction sets of its subformulas using the provided fixpoint characterizations. Let $\\Psi = \\neg \\mathsf{fault} \\lor AF\\,\\mathsf{rec}$. Then $\\Phi = AG\\,\\Psi$.\n\n**Step 2a: Compute $\\mathsf{Sat}(AF\\,\\mathsf{rec})$**\nThe operator $AF$ (all paths, eventually) is characterized by a least fixpoint. Let $Y = \\mathsf{Sat}(AF\\,\\mathsf{rec})$. Based on the provided definition:\n$$\nY = \\mathsf{Sat}(AF\\,\\mathsf{rec}) = \\mu Z.\\ \\mathsf{Sat}(\\mathsf{rec}) \\cup \\mathsf{Sat}(AX\\,Z)\n$$\nHere, $\\mathsf{Sat}(\\mathsf{rec}) = L_{\\mathsf{rec}}$. The least fixpoint $\\mu Z$ is computed iteratively, starting from the empty set $\\emptyset$ and repeatedly applying the function $F(Z) = L_{\\mathsf{rec}} \\cup \\mathsf{Sat}(AX\\,Z)$ until a fixed point is reached ($Y_{i+1} = Y_i$).\n\n**Step 2b: Compute $\\mathsf{Sat}(\\Psi) = \\mathsf{Sat}(\\neg \\mathsf{fault} \\lor AF\\,\\mathsf{rec})$**\nWith the set $Y = \\mathsf{Sat}(AF\\,\\mathsf{rec})$ computed, we find the satisfaction set for $\\Psi$. Disjunction ($\\lor$) corresponds to the union of satisfaction sets:\n$$\n\\mathsf{Sat}(\\Psi) = \\mathsf{Sat}(\\neg \\mathsf{fault}) \\cup \\mathsf{Sat}(AF\\,\\mathsf{rec})\n$$\nThe set $\\mathsf{Sat}(\\neg \\mathsf{fault})$ is the complement of $\\mathsf{Sat}(\\mathsf{fault}) = L_{\\mathsf{fault}}$ with respect to $S$. Therefore, the satisfaction set for $\\Psi$, which we call $P_{\\Psi}$, is:\n$$\nP_{\\Psi} = (S \\setminus L_{\\mathsf{fault}}) \\cup Y\n$$\nThis set $P_{\\Psi}$ contains all states that are either not faulty or from which recovery is guaranteed on all paths.\n\n**Step 2c: Compute $\\mathsf{Sat}(\\Phi) = \\mathsf{Sat}(AG\\,\\Psi)$**\nThe final step computes the satisfaction set of the full formula $\\Phi$. The operator $AG$ (all paths, globally) is characterized by a greatest fixpoint. Let $G = \\mathsf{Sat}(AG\\,\\Psi)$. Based on the provided definition:\n$$\nG = \\nu Z.\\ \\mathsf{Sat}(\\Psi) \\cap \\mathsf{Sat}(AX\\,Z)\n$$\nSubstituting $P_{\\Psi}$ for $\\mathsf{Sat}(\\Psi)$:\n$$\nG = \\nu Z.\\ P_{\\Psi} \\cap \\mathsf{Sat}(AX\\,Z)\n$$\nThe greatest fixpoint $\\nu Z$ is computed iteratively, starting from the set of all states $S$ and repeatedly applying the function $F(Z) = P_{\\Psi} \\cap \\mathsf{Sat}(AX\\,Z)$ until a fixed point is reached ($Z_{i+1} = Z_i$).\n\n**3. Global Verification**\nThe property holds globally if the formula $\\Phi$ is satisfied at every state. After computing the final satisfaction set $G = \\mathsf{Sat}(\\Phi)$, the check is whether $G = S$.\n\nThe overall algorithm is:\n1.  Compute $Y = \\mathsf{Sat}(AF\\,\\mathsf{rec})$ using the least fixpoint iteration starting from $\\emptyset$.\n2.  Compute $P_{\\Psi} = (S \\setminus L_{\\mathsf{fault}}) \\cup Y$.\n3.  Compute $G = \\mathsf{Sat}(AG\\,\\Psi)$ using the greatest fixpoint iteration starting from $S$.\n4.  Return `True` if $G=S$, and `False` otherwise. This procedure is applied to each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CTL model checking problem for the given test suite.\n    \"\"\"\n    # Test suite as specified in the problem description.\n    test_cases = [\n        {\n            \"S\": {0, 1, 2},\n            \"R\": {(0, 1), (1, 2), (2, 2)},\n            \"L_fault\": {0},\n            \"L_rec\": {2},\n        },\n        {\n            \"S\": {0, 1, 2, 3},\n            \"R\": {(0, 1), (1, 2), (1, 3), (2, 2), (3, 3)},\n            \"L_fault\": {0},\n            \"L_rec\": {2},\n        },\n        {\n            \"S\": {0, 1},\n            \"R\": {(0, 0), (0, 1), (1, 1)},\n            \"L_fault\": set(),\n            \"L_rec\": set(),\n        },\n        {\n            \"S\": {0, 1},\n            \"R\": {(0, 1), (1, 1)},\n            \"L_fault\": {0},\n            \"L_rec\": {0},\n        },\n        {\n            \"S\": {0, 1},\n            \"R\": {(0, 1), (1, 0)},\n            \"L_fault\": {0},\n            \"L_rec\": set(),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = model_check(\n            case[\"S\"],\n            case[\"R\"],\n            case[\"L_fault\"],\n            case[\"L_rec\"]\n        )\n        results.append(result)\n\n    # Format the boolean results as strings for the final output.\n    formatted_results = [str(r).lower() for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef model_check(S, R, L_fault, L_rec):\n    \"\"\"\n    Performs fixpoint-based CTL model checking for the formula AG(fault -> AF(rec)).\n\n    Args:\n        S: A set of states (integers).\n        R: A set of transitions, where each transition is a tuple (s, t).\n        L_fault: A set of states where the 'fault' proposition is true.\n        L_rec: A set of states where the 'rec' proposition is true.\n\n    Returns:\n        A boolean indicating whether the property holds globally (for all states in S).\n    \"\"\"\n\n    # Pre-process R into a more efficient successor map.\n    successors = {s: set() for s in S}\n    for s, t in R:\n        successors[s].add(t)\n\n    def compute_ax(Z):\n        \"\"\"Computes Sat(AX Z) = {s in S | for all t s.t. (s,t) in R, t in Z}.\"\"\"\n        ax_z = set()\n        for s in S:\n            # R is total, so successors[s] is never empty.\n            if successors[s].issubset(Z):\n                ax_z.add(s)\n        return ax_z\n\n    # Step 1: Compute Sat(AF rec) = mu Z. (L_rec U Sat(AX Z))\n    # This is a least fixpoint calculation, iterating from the empty set.\n    Y = set()\n    while True:\n        Y_prev = Y\n        ax_Y = compute_ax(Y_prev)\n        Y = L_rec.union(ax_Y)\n        if Y == Y_prev:\n            break\n    sat_af_rec = Y\n\n    # Step 2: Compute Sat(neg fault OR AF rec)\n    # Sat(neg fault) = S \\ L_fault\n    sat_not_fault = S.difference(L_fault)\n    P_psi = sat_not_fault.union(sat_af_rec)\n\n    # Step 3: Compute Sat(AG(neg fault OR AF rec)) = nu Z. (P_psi INTERSECT Sat(AX Z))\n    # This is a greatest fixpoint calculation, iterating from the set of all states S.\n    Z = S.copy()\n    while True:\n        Z_prev = Z\n        ax_Z = compute_ax(Z_prev)\n        Z = P_psi.intersection(ax_Z)\n        if Z == Z_prev:\n            break\n    sat_ag_psi = Z\n\n    # Step 4: The property holds globally if the satisfaction set includes all states.\n    return sat_ag_psi == S\n\nsolve()\n```"
        }
    ]
}