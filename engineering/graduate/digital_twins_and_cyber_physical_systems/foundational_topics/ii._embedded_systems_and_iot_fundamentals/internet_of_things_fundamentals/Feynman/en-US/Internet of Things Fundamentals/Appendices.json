{
    "hands_on_practices": [
        {
            "introduction": "At the heart of any Internet of Things system is the sensor, the component that bridges the physical and digital worlds. This exercise explores the fundamental relationship between a physical property, temperature, and the electrical signal produced by a common sensor circuit. By deriving the output voltage from first principles, you will gain a concrete understanding of how raw physical measurements are transduced into a digital-friendly format, a critical first step in the data pipeline for any digital twin .",
            "id": "4228202",
            "problem": "An Internet of Things (IoT) edge node in a cyber-physical thermal monitoring system drives a resistive temperature sensor using a two-element series network connected between a regulated supply and ground. The fixed resistor of value $1\\,\\mathrm{k}\\Omega$ is connected from a regulated source of $5\\,\\mathrm{V}$ to a node, and the sensor is connected from that node to ground. The node voltage with respect to ground is digitized and interpreted by a digital twin of the thermal process. The resistive temperature sensor obeys the linearized temperature-resistance relation $R(T)=R_{0}\\big(1+\\alpha\\,(T-T_{0})\\big)$, where $R_{0}=1000\\,\\Omega$, $\\alpha=0.003\\,^{\\circ}\\mathrm{C}^{-1}$, and $T_{0}=25\\,^{\\circ}\\mathrm{C}$. Assume ideal wires and negligible self-heating so that the static model applies and Kirchhoff’s circuit laws hold.\n\nUsing only Ohm’s law and Kirchhoff’s laws as fundamental bases, derive the node voltage across the sensor as a function of $T$ and compute the change in this voltage when the temperature rises from $T_{0}=25\\,^{\\circ}\\mathrm{C}$ to $35\\,^{\\circ}\\mathrm{C}$. Express the final answer as the change in voltage in volts, rounded to four significant figures.",
            "solution": "The problem statement is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Circuit Configuration**: A two-element series network. A fixed resistor is connected from a regulated voltage source to a node. A resistive temperature sensor is connected from that same node to ground.\n- **Fixed Resistor Value**: $R_{f} = 1\\,\\mathrm{k}\\Omega = 1000\\,\\Omega$.\n- **Regulated Supply Voltage**: $V_{s} = 5\\,\\mathrm{V}$.\n- **Resistive Sensor Model**: $R(T)=R_{0}\\big(1+\\alpha\\,(T-T_{0})\\big)$.\n- **Sensor Parameters**:\n    - $R_{0}=1000\\,\\Omega$.\n    - $\\alpha=0.003\\,^{\\circ}\\mathrm{C}^{-1}$.\n    - $T_{0}=25\\,^{\\circ}\\mathrm{C}$.\n- **Temperature Range**: The temperature rises from $T_{1}=25\\,^{\\circ}\\mathrm{C}$ to $T_{2}=35\\,^{\\circ}\\mathrm{C}$.\n- **Assumptions**: Ideal wires, negligible self-heating, static model, Kirchhoff's circuit laws hold.\n- **Objective**:\n    1.  Derive the node voltage across the sensor as a function of temperature, $T$.\n    2.  Compute the change in this voltage, $\\Delta V$, for the specified temperature rise.\n- **Output Requirement**: The final answer for the change in voltage must be expressed in volts, rounded to four significant figures.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is grounded in fundamental principles of electrical circuit theory (Ohm's law, Kirchhoff's laws) and a standard linearized model for a resistive temperature sensor (RTD). The component values and physical setup are realistic for an IoT application.\n- **Well-Posedness**: The problem is well-posed. It provides all necessary parameters ($V_{s}$, $R_{f}$, $R_{0}$, $\\alpha$, $T_{0}$) and the temperature range to calculate a unique, deterministic voltage change.\n- **Objectivity**: The problem is stated in precise, objective language, free of ambiguity or subjective claims.\n\n**Step 3: Verdict and Action**\n- **Verdict**: The problem is valid as it is scientifically sound, well-posed, and objective.\n- **Action**: Proceed with the solution.\n\n### Derivation and Solution\n\nThe circuit described consists of a fixed resistor, which we denote as $R_{f}$, and a temperature-dependent sensor resistor, which we denote as $R(T)$, connected in series across a voltage source $V_{s}$. This configuration is a classic voltage divider. The node voltage, $V_{node}$, is the voltage across the sensor resistor $R(T)$ with respect to ground.\n\nAccording to Kirchhoff's Voltage Law (KVL), the sum of voltage drops around the closed loop is equal to the source voltage:\n$$V_{s} = V_{R_f} + V_{node}$$\nwhere $V_{R_f}$ is the voltage drop across the fixed resistor and $V_{node}$ is the voltage drop across the sensor.\n\nLet $I$ be the current flowing through the series circuit. From Ohm's law, the voltage drops are $V_{R_f} = I R_{f}$ and $V_{node} = I R(T)$. Substituting these into the KVL equation:\n$$V_{s} = I R_{f} + I R(T) = I (R_{f} + R(T))$$\n\nSolving for the current $I$:\n$$I = \\frac{V_{s}}{R_{f} + R(T)}$$\n\nThe node voltage $V_{node}$ is the voltage across the sensor $R(T)$. Applying Ohm's law to the sensor:\n$$V_{node}(T) = I \\cdot R(T)$$\n\nSubstituting the expression for the current $I$ gives the voltage divider formula:\n$$V_{node}(T) = \\left( \\frac{V_{s}}{R_{f} + R(T)} \\right) R(T) = V_{s} \\frac{R(T)}{R_{f} + R(T)}$$\n\nNow, we substitute the given expression for the sensor's resistance, $R(T)=R_{0}\\big(1+\\alpha\\,(T-T_{0})\\big)$, into this equation. This yields the explicit dependency of the node voltage on temperature:\n$$V_{node}(T) = V_{s} \\frac{R_{0}\\big(1+\\alpha\\,(T-T_{0})\\big)}{R_{f} + R_{0}\\big(1+\\alpha\\,(T-T_{0})\\big)}$$\n\nThis completes the derivation part of the problem. Next, we compute the change in voltage.\nThe given values are:\n$V_{s} = 5\\,\\mathrm{V}$\n$R_{f} = 1000\\,\\Omega$\n$R_{0} = 1000\\,\\Omega$\n$\\alpha = 0.003\\,^{\\circ}\\mathrm{C}^{-1}$\n$T_{0} = 25\\,^{\\circ}\\mathrm{C}$\n\nWe need to calculate the voltage at the initial temperature $T_{1}=25\\,^{\\circ}\\mathrm{C}$ and the final temperature $T_{2}=35\\,^{\\circ}\\mathrm{C}$.\n\nFirst, calculate the sensor resistance at $T_{1}=25\\,^{\\circ}\\mathrm{C}$:\n$$R(T_{1}) = R(25\\,^{\\circ}\\mathrm{C}) = 1000\\,\\Omega \\cdot \\big(1 + 0.003\\,^{\\circ}\\mathrm{C}^{-1} \\cdot (25\\,^{\\circ}\\mathrm{C} - 25\\,^{\\circ}\\mathrm{C})\\big)$$\n$$R(T_{1}) = 1000\\,\\Omega \\cdot (1 + 0) = 1000\\,\\Omega$$\n\nNow, calculate the node voltage at $T_{1}$:\n$$V_{node}(T_{1}) = V_{s} \\frac{R(T_{1})}{R_{f} + R(T_{1})} = 5\\,\\mathrm{V} \\cdot \\frac{1000\\,\\Omega}{1000\\,\\Omega + 1000\\,\\Omega} = 5\\,\\mathrm{V} \\cdot \\frac{1000}{2000} = 5\\,\\mathrm{V} \\cdot 0.5 = 2.5\\,\\mathrm{V}$$\n\nNext, calculate the sensor resistance at $T_{2}=35\\,^{\\circ}\\mathrm{C}$:\n$$R(T_{2}) = R(35\\,^{\\circ}\\mathrm{C}) = 1000\\,\\Omega \\cdot \\big(1 + 0.003\\,^{\\circ}\\mathrm{C}^{-1} \\cdot (35\\,^{\\circ}\\mathrm{C} - 25\\,^{\\circ}\\mathrm{C})\\big)$$\n$$R(T_{2}) = 1000\\,\\Omega \\cdot (1 + 0.003 \\cdot 10) = 1000\\,\\Omega \\cdot (1 + 0.03) = 1000\\,\\Omega \\cdot 1.03 = 1030\\,\\Omega$$\n\nNow, calculate the node voltage at $T_{2}$:\n$$V_{node}(T_{2}) = V_{s} \\frac{R(T_{2})}{R_{f} + R(T_{2})} = 5\\,\\mathrm{V} \\cdot \\frac{1030\\,\\Omega}{1000\\,\\Omega + 1030\\,\\Omega} = 5\\,\\mathrm{V} \\cdot \\frac{1030}{2030}$$\n$$V_{node}(T_{2}) = 5 \\cdot \\frac{103}{203}\\,\\mathrm{V} \\approx 2.5369458\\,\\mathrm{V}$$\n\nFinally, compute the change in voltage, $\\Delta V_{node}$:\n$$\\Delta V_{node} = V_{node}(T_{2}) - V_{node}(T_{1})$$\n$$\\Delta V_{node} \\approx 2.5369458\\,\\mathrm{V} - 2.5\\,\\mathrm{V} = 0.0369458\\,\\mathrm{V}$$\n\nThe problem requires the answer to be rounded to four significant figures. The first significant figure is $3$. The four significant figures are $3$, $6$, $9$, $4$. The next digit is $5$, so we round up the fourth digit.\n$$\\Delta V_{node} \\approx 0.03695\\,\\mathrm{V}$$",
            "answer": "$$\\boxed{0.03695}$$"
        },
        {
            "introduction": "Once an IoT device generates data, it must be transmitted to a central service, often in the cloud. As a system scales to thousands or millions of devices, the collective network traffic becomes a critical design consideration for the digital twin's ingestion infrastructure. This practice problem has you analyze the total network overhead across a typical communication stack and distinguish between average and peak traffic loads, a vital skill for capacity planning and building robust, scalable cyber-physical systems .",
            "id": "4228099",
            "problem": "A cloud-hosted digital twin service ingests telemetry from a fleet of Internet of Things (IoT) devices in a cyber-physical system. Each device publishes telemetry periodically using Message Queuing Telemetry Transport (MQTT) over Transmission Control Protocol (TCP) over Internet Protocol (IP) with Transport Layer Security (TLS). The system has the following properties and assumptions:\n\n- There are $10{,}000$ devices.\n- Each device publishes exactly one telemetry message every $30\\,\\mathrm{s}$.\n- Each telemetry payload is $200\\,\\mathrm{bytes}$ of binary data.\n- Per message, the application-layer metadata and MQTT framing contribute an additional fixed $20\\,\\mathrm{bytes}$.\n- Per message, the TLS record contributes a fixed $25\\,\\mathrm{bytes}$ of overhead.\n- Each message is carried in a single TCP segment with a $20\\,\\mathrm{byte}$ Transmission Control Protocol (TCP) header and a $20\\,\\mathrm{byte}$ Internet Protocol version $4$ (IPv4) header; there is no fragmentation.\n- Ignore link-layer overhead, acknowledgments, and retransmissions.\n- Devices are synchronized by a common time source, such that every $30\\,\\mathrm{s}$ boundary is a scheduled publish time. Due to bounded jitter, all device transmissions are confined within a $1\\,\\mathrm{s}$ guard window centered at each $30\\,\\mathrm{s}$ boundary. Define the peak message arrival rate as the maximum number of messages that can arrive within any $1\\,\\mathrm{s}$ interval at the broker.\n\nStarting only from fundamental definitions of rate and throughput (bytes to bits conversion and events per unit time), compute:\n1. The aggregate average upstream bandwidth required by the broker to ingest all device telemetry, expressed in megabits per second (Mb/s). Use decimal SI units with $1\\,\\mathrm{Mb} = 10^{6}\\,\\mathrm{bits}$.\n2. The peak message arrival rate, expressed in messages per second, as defined above.\n\nReport your answers in the order $\\bigl(\\text{aggregate bandwidth in Mb/s},\\ \\text{peak messages per second}\\bigr)$. Round both values to four significant figures.",
            "solution": "The problem statement is validated as being scientifically grounded, well-posed, and objective. It provides a complete and consistent set of parameters for a standard engineering calculation related to network traffic in an Internet of Things (IoT) system. All provided values and assumptions are plausible within the domain of cyber-physical systems. We may therefore proceed with the solution.\n\nThe problem asks for two quantities: the aggregate average upstream bandwidth and the peak message arrival rate.\n\nFirst, we compute the aggregate average upstream bandwidth.\nLet $N$ be the number of devices, given as $N = 10,000$.\nLet $T_{pub}$ be the publication period for each device, given as $T_{pub} = 30\\,\\mathrm{s}$.\nThe total size of a single message packet at the Internet Protocol (IP) layer is the sum of its constituent parts. The sizes are given in bytes:\n- Telemetry payload: $S_{payload} = 200\\,\\mathrm{bytes}$\n- Application-layer metadata and MQTT framing: $S_{mqtt} = 20\\,\\mathrm{bytes}$\n- Transport Layer Security (TLS) record overhead: $S_{tls} = 25\\,\\mathrm{bytes}$\n- Transmission Control Protocol (TCP) header: $S_{tcp} = 20\\,\\mathrm{bytes}$\n- Internet Protocol version $4$ (IPv4) header: $S_{ipv4} = 20\\,\\mathrm{bytes}$\n\nThe total size of a single packet, $S_{packet}$, is the sum of these components:\n$$S_{packet} = S_{payload} + S_{mqtt} + S_{tls} + S_{tcp} + S_{ipv4}$$\n$$S_{packet} = 200\\,\\mathrm{bytes} + 20\\,\\mathrm{bytes} + 25\\,\\mathrm{bytes} + 20\\,\\mathrm{bytes} + 20\\,\\mathrm{bytes} = 285\\,\\mathrm{bytes}$$\nTo calculate bandwidth, we must express this size in bits. Using the conversion factor of $8\\,\\mathrm{bits/byte}$:\n$$S_{bits} = S_{packet} \\times 8\\,\\mathrm{bits/byte} = 285\\,\\mathrm{bytes} \\times 8\\,\\mathrm{bits/byte} = 2280\\,\\mathrm{bits}$$\nThis is the size of a single message from one device. Each device sends one such message every $T_{pub} = 30\\,\\mathrm{s}$. The average data rate per device, $R_{device}$, is:\n$$R_{device} = \\frac{S_{bits}}{T_{pub}} = \\frac{2280\\,\\mathrm{bits}}{30\\,\\mathrm{s}} = 76\\,\\mathrm{bits/s}$$\nThe aggregate average bandwidth, $B_{agg}$, for all $N = 10,000$ devices is the product of the number of devices and the average rate per device:\n$$B_{agg} = N \\times R_{device} = 10,000 \\times 76\\,\\mathrm{bits/s} = 760,000\\,\\mathrm{bits/s}$$\nThe problem requires this value to be expressed in megabits per second (Mb/s), using the decimal SI unit definition $1\\,\\mathrm{Mb} = 10^6\\,\\mathrm{bits}$.\n$$B_{agg, Mb/s} = \\frac{760,000\\,\\mathrm{bits/s}}{10^6\\,\\mathrm{bits/Mb}} = 0.76\\,\\mathrm{Mb/s}$$\nRounding this result to four significant figures as requested gives $0.7600\\,\\mathrm{Mb/s}$.\n\nSecond, we compute the peak message arrival rate.\nThe problem defines the peak message arrival rate, $R_{peak}$, as \"the maximum number of messages that can arrive within any $1\\,\\mathrm{s}$ interval at the broker\".\nIt is given that all $N = 10,000$ devices' transmissions are confined within a $T_{window} = 1\\,\\mathrm{s}$ guard window. This means that during this specific $1\\,\\mathrm{s}$ interval, which occurs every $30\\,\\mathrm{s}$, the total number of messages arriving at the broker is $M_{peak} = N = 10,000$.\nThe peak message arrival rate is therefore calculated by dividing the total number of messages by the duration of this time interval:\n$$R_{peak} = \\frac{M_{peak}}{T_{window}} = \\frac{10,000\\,\\mathrm{messages}}{1\\,\\mathrm{s}} = 10,000\\,\\mathrm{messages/s}$$\nThe calculated value is an exact integer, $10,000$. The problem asks to round this value to four significant figures. Rounding the integer $10,000$ to four significant figures results in $10,000$.\n\nThe two computed values are the aggregate average bandwidth of $0.7600\\,\\mathrm{Mb/s}$ and the peak message arrival rate of $10,000\\,\\mathrm{messages/s}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.7600 & 10000\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The ultimate purpose of many cyber-physical systems is not merely to monitor but to actively control a physical process, creating a closed loop where the network itself becomes a dynamic component. This advanced exercise delves into networked control systems, a core discipline within CPS, to examine how network imperfections like packet loss can jeopardize system stability. By determining the maximum tolerable burst of consecutive packet losses before a system becomes unstable, you will confront a fundamental challenge in CPS design: guaranteeing safe and reliable operation over an unreliable communication medium .",
            "id": "4228241",
            "problem": "Consider a networked control loop in an Internet of Things (IoT) cyber-physical system with a linear time-invariant plant. The plant dynamics are given by the continuous-time state-space model $\\dot{x}(t) = A x(t) + B u(t)$, where $x(t) \\in \\mathbb{R}^n$ and $u(t) \\in \\mathbb{R}^m$. A state-feedback controller with gain $K \\in \\mathbb{R}^{m \\times n}$ computes $u_k = K x(t_k)$ at the sampling instants $t_k$, separated by a nominal sampling period $T_s > 0$ seconds. The actuator implements zero-order hold with hold-last behavior under packet loss: if a control packet is lost at a nominal sampling instant, the actuator continues to apply the most recently received $u$ until a new packet is successfully received. Assume independent packet losses with loss probability $p \\in [0,1)$ at each sampling instant. Let $L \\in \\mathbb{N}_0$ denote the number of consecutive lost packets between two successful receptions, so that the time between successful updates is $\\Delta = (L+1) T_s$.\n\nYour task is to determine the maximum allowable number of consecutive losses $L_{\\max}$ such that the closed-loop remains asymptotically stable for any burst of at most $L_{\\max}$ consecutive losses, under the hold-last behavior described above.\n\nUse only the following foundational bases to derive your method:\n- The solution of linear time-invariant systems with constant input over an interval: $x(t+\\Delta) = e^{A \\Delta} x(t) + \\int_{0}^{\\Delta} e^{A \\tau} B \\, d\\tau \\, u(t)$.\n- The zero-order hold property: between two successful receptions, the control input is constant and equal to the last successfully received $u$.\n- Discrete-time stability criterion: a discrete-time linear system $x_{k+1} = \\Phi x_k$ is asymptotically stable if and only if the spectral radius $\\rho(\\Phi) < 1$.\n\nDefine $L_{\\max}$ as the largest integer $L \\ge 0$ for which the discrete-time closed-loop state transition over $\\Delta = (L+1) T_s$ remains asymptotically stable in the above sense. You must:\n- Express the condition for stability of the sampled-data closed-loop under bursts of length $L$ in terms of the spectral radius of an appropriate state transition matrix derived from the above fundamentals.\n- Design an algorithm that, given $A$, $B$, $K$, and $T_s$ (in seconds), computes $L_{\\max}$ by checking this condition for increasing $L$ starting from $L=0$ and stopping at the first violation.\n- Note that the loss probability $p$ does not change the allowable $L_{\\max}$; it only affects the likelihood of violating it. Therefore, $p$ is provided for context but must not be used in the computation of $L_{\\max}$.\n\nPhysical and numerical units:\n- All sampling periods $T_s$ are provided in seconds; the internal time variable $\\Delta$ must be computed in seconds.\n- The final answers are counts of consecutive packet losses and must be returned as integers.\n\nTest suite:\nFor each case below, compute $L_{\\max}$ as an integer. The sampling period $T_s$ is given in seconds.\n\n- Case 1 (happy path, IoT-relevant nominal): $A = \\begin{bmatrix} 0 & 1 \\\\ -4 & -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $K = \\begin{bmatrix} 6 & 2 \\end{bmatrix}$, $T_s = 0.02$ (i.e., $20$ ms), $p = 0.1$.\n- Case 2 (more unstable plant, likely tighter bound): $A = \\begin{bmatrix} 0 & 1 \\\\ 5 & 0.5 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $K = \\begin{bmatrix} 10 & 3 \\end{bmatrix}$, $T_s = 0.02$, $p = 0.1$.\n- Case 3 (scalar plant, boundary behavior): $A = \\begin{bmatrix} 0.8 \\end{bmatrix}$, $B = \\begin{bmatrix} 1 \\end{bmatrix}$, $K = \\begin{bmatrix} -3 \\end{bmatrix}$, $T_s = 0.02$, $p = 0.1$.\n- Case 4 (same as Case 1 but slower nominal sampling): $A = \\begin{bmatrix} 0 & 1 \\\\ -4 & -1 \\end{bmatrix}$, $B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$, $K = \\begin{bmatrix} 6 & 2 \\end{bmatrix}$, $T_s = 0.05$ (i.e., $50$ ms), $p = 0.1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, `[r_1,r_2,r_3,r_4]`, where each $r_i$ is the computed integer $L_{\\max}$ for Case $i$.",
            "solution": "The objective is to determine the maximum number of consecutive packet losses, denoted $L_{\\max}$, that a networked control system can tolerate while maintaining asymptotic stability. The system consists of a continuous-time linear time-invariant (LTI) plant and a discrete-time state-feedback controller. The actuator employs a zero-order hold with a hold-last strategy for lost control packets.\n\nThe analysis is based on the discrete-time evolution of the system state between two consecutive successful control updates. Let $t_k$ be the time of a successful update. Due to $L$ consecutive packet losses following this update, the next successful update occurs at $t_{k+1} = t_k + (L+1)T_s$. Let the time interval between successful updates be $\\Delta = (L+1)T_s$.\n\nAccording to the hold-last policy, the control input $u(t)$ applied by the actuator remains constant over the interval $t \\in [t_k, t_{k+1})$. This constant input is the last successfully computed control value, $u_k = K x(t_k)$.\nThe continuous-time dynamics of the plant are given by $\\dot{x}(t) = A x(t) + B u(t)$. The formal solution for an LTI system with a constant input $u(t) = u_k$ over an interval of duration $\\Delta$ starting at time $t_k$ is provided in the problem statement:\n$$x(t_k+\\Delta) = e^{A \\Delta} x(t_k) + \\left( \\int_{0}^{\\Delta} e^{A \\tau} B \\, d\\tau \\right) u_k$$\n\nLet us define the state at the successful sampling instants as $x_k \\triangleq x(t_k)$. Then, the state at the next successful instant is $x_{k+1} \\triangleq x(t_k+\\Delta)$. The equation above describes the evolution from $x_k$ to $x_{k+1}$.\nWe can express this in the standard discrete-time form by defining the discretized system matrices over the interval $\\Delta$:\n$$A_d(\\Delta) = e^{A \\Delta}$$\n$$B_d(\\Delta) = \\int_{0}^{\\Delta} e^{A \\tau} B \\, d\\tau$$\nSubstituting these definitions, the state evolution becomes:\n$$x_{k+1} = A_d(\\Delta) x_k + B_d(\\Delta) u_k$$\nNow, we substitute the state-feedback control law, $u_k = K x_k$:\n$$x_{k+1} = A_d(\\Delta) x_k + B_d(\\Delta) K x_k$$\nFactoring out $x_k$, we obtain the closed-loop discrete-time system:\n$$x_{k+1} = (A_d(\\Delta) + B_d(\\Delta) K) x_k$$\nThis equation is of the form $x_{k+1} = \\Phi(L) x_k$, where the closed-loop state transition matrix $\\Phi(L)$ depends on the number of consecutive losses $L$ through $\\Delta = (L+1)T_s$:\n$$\\Phi(L) = A_d((L+1)T_s) + B_d((L+1)T_s) K$$\nFor this discrete-time LTI system to be asymptotically stable, its state transition matrix $\\Phi(L)$ must be Schur stable. The necessary and sufficient condition for this is that the spectral radius of $\\Phi(L)$ must be less than $1$:\n$$\\rho(\\Phi(L)) < 1$$\nThe spectral radius, $\\rho(\\cdot)$, is defined as the maximum of the absolute values of the eigenvalues of the matrix.\n\nTo compute the matrices $A_d(\\Delta)$ and $B_d(\\Delta)$, we can use the matrix exponential of an augmented block matrix. Let the state dimension be $n$ and the input dimension be $m$. We construct the $(n+m) \\times (n+m)$ matrix $M$:\n$$M = \\begin{bmatrix} A & B \\\\ 0 & 0 \\end{bmatrix}$$\nwhere the zero blocks have appropriate dimensions. The matrix exponential of $M\\Delta$ is given by:\n$$e^{M\\Delta} = \\begin{bmatrix} e^{A\\Delta} & \\int_0^\\Delta e^{A\\tau}B d\\tau \\\\ 0 & I \\end{bmatrix} = \\begin{bmatrix} A_d(\\Delta) & B_d(\\Delta) \\\\ 0 & I \\end{bmatrix}$$\nThis provides a standard computational method to find both $A_d(\\Delta)$ and $B_d(\\Delta)$ simultaneously.\n\nTo find the maximum allowable number of consecutive losses, $L_{\\max}$, we must find the largest integer $L \\ge 0$ that satisfies the stability condition $\\rho(\\Phi(L)) < 1$. The algorithm proceeds as follows:\n1.  Initialize the number of consecutive losses, $L$, to $0$.\n2.  Enter a loop that increments $L$ by $1$ in each iteration.\n3.  In each iteration, calculate the total hold duration $\\Delta = (L+1)T_s$.\n4.  Construct the augmented matrix $M$ from the given $A$ and $B$.\n5.  Compute the matrix exponential $E = e^{M\\Delta}$.\n6.  Extract $A_d(\\Delta)$ and $B_d(\\Delta)$ from the appropriate blocks of $E$.\n7.  Form the closed-loop state transition matrix $\\Phi(L) = A_d(\\Delta) + B_d(\\Delta) K$.\n8.  Compute the eigenvalues of $\\Phi(L)$ and find its spectral radius $\\rho(\\Phi(L))$.\n9.  Check the stability condition. If $\\rho(\\Phi(L)) \\ge 1$, the system is no longer stable for this value of $L$. The loop terminates. The maximum number of *allowed* losses is the value from the previous iteration, so $L_{\\max} = L - 1$.\n10. If $\\rho(\\Phi(L)) < 1$, the system is stable for this $L$, so the loop continues to the next integer value of $L$.\n\nThis iterative search guarantees finding the largest integer $L_{\\max} \\ge 0$ for which any burst of up to $L_{\\max}$ consecutive losses results in a stable closed-loop system. If the system is unstable even for $L=0$, the algorithm will yield $L_{\\max} = -1$, correctly indicating that no non-negative number of losses maintains stability.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the maximum allowable number of consecutive packet losses (L_max)\n    for a networked control system.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, IoT-relevant nominal)\n        {\n            \"A\": np.array([[0, 1], [-4, -1]]),\n            \"B\": np.array([[0], [1]]),\n            \"K\": np.array([[6, 2]]),\n            \"Ts\": 0.02\n        },\n        # Case 2 (more unstable plant, likely tighter bound)\n        {\n            \"A\": np.array([[0, 1], [5, 0.5]]),\n            \"B\": np.array([[0], [1]]),\n            \"K\": np.array([[10, 3]]),\n            \"Ts\": 0.02\n        },\n        # Case 3 (scalar plant, boundary behavior)\n        {\n            \"A\": np.array([[0.8]]),\n            \"B\": np.array([[1]]),\n            \"K\": np.array([[-3]]),\n            \"Ts\": 0.02\n        },\n        # Case 4 (same as Case 1 but slower nominal sampling)\n        {\n            \"A\": np.array([[0, 1], [-4, -1]]),\n            \"B\": np.array([[0], [1]]),\n            \"K\": np.array([[6, 2]]),\n            \"Ts\": 0.05\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        B = case[\"B\"]\n        K = case[\"K\"]\n        Ts = case[\"Ts\"]\n\n        n = A.shape[0]\n        m = B.shape[1]\n\n        # Construct the augmented matrix M for computing Ad and Bd\n        M = np.zeros((n + m, n + m))\n        M[:n, :n] = A\n        M[:n, n:] = B\n        \n        L = 0\n        while True:\n            # Calculate the time interval for L consecutive losses\n            delta = (L + 1) * Ts\n\n            # Compute the matrix exponential of M*delta\n            E = expm(M * delta)\n\n            # Extract the discretized matrices Ad and Bd\n            Ad = E[:n, :n]\n            Bd = E[:n, n:]\n\n            # Form the closed-loop state transition matrix Phi\n            Phi = Ad + Bd @ K\n\n            # Compute the spectral radius rho(Phi)\n            eigenvalues = np.linalg.eigvals(Phi)\n            spectral_radius = np.max(np.abs(eigenvalues))\n\n            # Check for stability. If rho >= 1, the system is unstable.\n            if spectral_radius >= 1.0:\n                L_max = L - 1\n                break\n            \n            # If the loop continues for a very long time, it's practically stable\n            # for any foreseeable number of losses. We add a safeguard.\n            if L > 10000: # Practical upper bound to prevent infinite loop\n                L_max = L\n                break\n\n            L += 1\n        \n        results.append(L_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}