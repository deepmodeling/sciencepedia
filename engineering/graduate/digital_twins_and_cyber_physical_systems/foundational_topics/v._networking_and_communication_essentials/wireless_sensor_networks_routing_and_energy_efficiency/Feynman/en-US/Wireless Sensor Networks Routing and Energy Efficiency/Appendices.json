{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of designing efficient Wireless Sensor Networks (WSNs) is understanding the nuances of radio energy consumption. This practice delves into the standard radio energy model, which features a non-linear cost function that depends on transmission distance, transitioning from a free-space ($d^2$) to a multipath ($d^4$) loss regime. By comparing a simple greedy routing algorithm with a more sophisticated two-hop lookahead strategy, you will gain hands-on experience in how routing decisions interact with this physical reality and discover why the most direct path is not always the most energy-efficient one .",
            "id": "4254469",
            "problem": "A Digital Twin (DT) of a Wireless Sensor Network (WSN) is used to evaluate energy-aware geographic routing strategies under a realistic radio-energy model. The network is embedded in a two-dimensional Euclidean plane. Each node has a known position, and a communication link between two nodes exists if and only if the Euclidean distance between them is less than or equal to a specified communication radius. The task is to compute, for given topologies and radio parameters, the energy reduction achieved by a two-hop informed geographic routing strategy compared to a one-hop greedy geographic routing strategy, when forwarding a single packet from a specified source node to a sink (base station).\n\nFundamental base:\n- The Euclidean distance between points $(x_1,y_1)$ and $(x_2,y_2)$ is $d=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$.\n- Radio energy model: transmission energy is distance-dependent with a free-space path-loss regime and a multipath path-loss regime. Let $L$ be the packet length in bits, $E_{\\mathrm{elec}}$ be the electronics energy per bit in joules per bit, $\\epsilon_{\\mathrm{fs}}$ be the free-space amplifier coefficient in joules per bit per meter squared, and $\\epsilon_{\\mathrm{mp}}$ be the multipath amplifier coefficient in joules per bit per meter to the fourth. Define the regime threshold $d_0=\\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$. Then the transmit energy for distance $d$ is\n$$\nE_{\\mathrm{tx}}(d) = \n\\begin{cases}\nL\\,E_{\\mathrm{elec}} + L\\,\\epsilon_{\\mathrm{fs}}\\,d^2, & \\text{if } d \\le d_0,\\\\\nL\\,E_{\\mathrm{elec}} + L\\,\\epsilon_{\\mathrm{mp}}\\,d^4, & \\text{if } d > d_0.\n\\end{cases}\n$$\nThe receive energy is distance-independent and given by $E_{\\mathrm{rx}}(L) = L\\,E_{\\mathrm{elec}}$.\n\nRouting strategies:\n- One-hop greedy geographic routing: At each step from the current node, choose a neighbor whose Euclidean distance to the sink is strictly less than that of the current node, and among all such neighbors choose the one with the minimal sink distance. If there is a tie, choose the neighbor that minimizes the current-to-neighbor Euclidean distance; if still tied, choose the smallest node index. Repeat until the sink is reached. The total energy for one-hop routing is the sum over all hops of $E_{\\mathrm{tx}}(d_{\\text{hop}}) + E_{\\mathrm{rx}}(L)$, including the final reception at the sink.\n- Two-hop informed geographic routing: At each step from the current node, if the sink is directly reachable (i.e., within the communication radius), transmit directly to the sink. Otherwise, construct candidate pairs $(i,j)$ such that $i$ is a neighbor of the current node with strictly smaller sink distance, and $j$ is a neighbor of $i$ with strictly smaller sink distance than the current node (the sink itself is admissible as $j$ if it is within the communication radius of $i$). For each pair, compute the two-hop segment energy $E_{\\mathrm{tx}}(d_{\\text{current},i}) + E_{\\mathrm{rx}}(L) + E_{\\mathrm{tx}}(d_{i,j}) + E_{\\mathrm{rx}}(L)$. Choose the pair with minimal two-hop segment energy; ties are broken by minimal sink distance of $j$, then minimal sink distance of $i$, then lexicographically by $(i,j)$ indices. Execute the two hops and set the current node to $j$. Repeat until the sink is reached. The total energy for two-hop routing is the sum of transmit and receive energies over all executed hops.\n\nTask:\nFor each supplied test topology and parameter set, compute the energy reduction defined as the difference between the total energy of the one-hop greedy routing path and the total energy of the two-hop informed routing path, both calculated under the specified radio model. Express energy in joules as decimal numbers rounded to six decimal places.\n\nTest suite and parameters:\n- Common radio parameters used in all test cases:\n  - Packet length $L = 4096$ bits.\n  - Electronics energy per bit $E_{\\mathrm{elec}} = 5\\times 10^{-8}$ joules per bit.\n  - Free-space amplifier coefficient $\\epsilon_{\\mathrm{fs}} = 10^{-11}$ joules per bit per meter squared.\n  - Multipath amplifier coefficient $\\epsilon_{\\mathrm{mp}} = 1.3\\times 10^{-15}$ joules per bit per meter to the fourth.\n  - Regime threshold $d_0 = \\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$ meters.\n\n- Test Case $1$ (happy path; two-hop improvement expected):\n  - Communication radius $R = 60$ meters.\n  - Nodes (index: coordinates in meters):\n    - $0$: $(200,0)$ source.\n    - $1$: $(0,0)$ sink.\n    - $2$: $(150,0)$.\n    - $3$: $(90,0)$.\n    - $4$: $(30,0)$.\n    - $5$: $(160,45)$.\n    - $6$: $(120,30)$.\n    - $7$: $(80,20)$.\n    - $8$: $(40,10)$.\n- Test Case $2$ (boundary; equal energy expected):\n  - Communication radius $R = 60$ meters.\n  - Nodes:\n    - $0$: $(200,0)$ source.\n    - $1$: $(0,0)$ sink.\n    - $2$: $(150,0)$.\n    - $3$: $(100,0)$.\n    - $4$: $(50,0)$.\n- Test Case $3$ (edge near threshold; large two-hop improvement expected):\n  - Communication radius $R = 120$ meters.\n  - Nodes:\n    - $0$: $(200,0)$ source.\n    - $1$: $(0,0)$ sink.\n    - $2$: $(100,0)$.\n    - $3$: $(160,60)$.\n    - $4$: $(120,40)$.\n    - $5$: $(80,20)$.\n    - $6$: $(40,10)$.\n\nFinal output format:\nYour program should produce a single line of output containing the energy reductions for the three test cases, as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places in joules (e.g., \"[$x_1$,$x_2$,$x_3$]\").",
            "solution": "The problem is grounded in the physical radio-energy model used widely in Wireless Sensor Network (WSN) research and in cyber-physical system Digital Twins (DTs). The model couples the electronics energy per bit with a distance-dependent amplifier energy that follows the free-space law for short ranges and the multipath law for longer ranges. The threshold $d_0=\\sqrt{\\epsilon_{\\mathrm{fs}}/\\epsilon_{\\mathrm{mp}}}$ demarcates the switch between these regimes.\n\nFundamentals:\n- The Euclidean distance between two nodes at $(x_1,y_1)$ and $(x_2,y_2)$ is $d=\\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$, ensuring physically meaningful distances in meters.\n- The transmit energy $E_{\\mathrm{tx}}(d)$ employs the free-space amplifier model $L\\,\\epsilon_{\\mathrm{fs}}\\,d^2$ for $d \\le d_0$ and the multipath amplifier model $L\\,\\epsilon_{\\mathrm{mp}}\\,d^4$ for $d>d_0$, with a constant electronics cost $L\\,E_{\\mathrm{elec}}$.\n- The receive energy $E_{\\mathrm{rx}}(L)=L\\,E_{\\mathrm{elec}}$ is independent of distance, modeling the cost of decoding and baseband processing at the receiver.\n\nAlgorithmic design:\n1. Construct the communication graph by connecting any pair of nodes whose Euclidean distance is less than or equal to the communication radius $R$. This reflects realistic physical adjacency.\n2. One-hop greedy geographic routing:\n   - From the current node $c$, enumerate neighbors $n$ with $d(n,\\mathrm{sink})<d(c,\\mathrm{sink})$ to ensure progress toward the sink.\n   - Choose the neighbor that minimizes $d(n,\\mathrm{sink})$, breaking ties by minimal $d(c,n)$ and then by smallest index, to obtain a deterministic path.\n   - Accumulate energy for each hop as $E_{\\mathrm{tx}}(d(c,n))+E_{\\mathrm{rx}}(L)$, including the final reception at the sink.\n   - Repeat until the sink is reached. This procedure is memoryless and locally optimal in terms of geometric progress.\n3. Two-hop informed geographic routing:\n   - If the sink is within $R$ of the current node, transmit directly to the sink, accumulating $E_{\\mathrm{tx}}(d(c,\\mathrm{sink}))+E_{\\mathrm{rx}}(L)$, and terminate.\n   - Otherwise, for each neighbor $i$ of the current node with $d(i,\\mathrm{sink})<d(c,\\mathrm{sink})$, enumerate neighbors $j$ of $i$ (including the sink if within $R$ of $i$) with $d(j,\\mathrm{sink})<d(c,\\mathrm{sink})$. This guarantees net progress after two hops.\n   - For each admissible pair $(i,j)$, compute the two-hop segment energy $E_{\\mathrm{tx}}(d(c,i)) + E_{\\mathrm{rx}}(L) + E_{\\mathrm{tx}}(d(i,j)) + E_{\\mathrm{rx}}(L)$.\n   - Choose the pair with minimal segment energy; break ties by minimal $d(j,\\mathrm{sink})$, minimal $d(i,\\mathrm{sink})$, and then lexicographically by indices $(i,j)$.\n   - Execute the two hops sequentially, accumulate their energies, and set the current node to $j$. Repeat until the sink is reached. This look-ahead incorporates local future costs, potentially avoiding expensive single long hops that invoke the multipath regime.\n\nEnergy reduction computation:\n- For each test case, compute the total energy $E_{\\mathrm{one}}$ for the one-hop greedy path and the total energy $E_{\\mathrm{two}}$ for the two-hop informed path. The reduction is $\\Delta E = E_{\\mathrm{one}} - E_{\\mathrm{two}}$. Values are rounded to six decimal places and expressed in joules.\n\nWhy the two-hop strategy can reduce energy:\n- When the one-hop greedy choice leads to a subsequent long hop (distance $d>d_0$), the amplifier cost $L\\,\\epsilon_{\\mathrm{mp}}\\,d^4$ can dominate, making that path energetically expensive. The two-hop strategy can prefer a first hop that is not the closest to the sink if it leads to a second hop that is significantly shorter (remaining in the free-space regime), reducing the sum of the two-hop segment costs. Over a route, repeating such decisions can substantially lower the total energy.\n\nApplication to the test suite:\n- Test Case $1$ sets two alternative corridors: a “straight” corridor composed of near-maximum-radius hops and a “diagonal” corridor composed of shorter hops. The one-hop greedy scheme selects the straight corridor initially due to closer neighbor-to-sink distance, but the two-hop informed scheme selects the diagonal corridor because the two-hop segment energy is lower.\n- Test Case $2$ places nodes collinearly at regular spacings, making the greedy and two-hop decisions coincide at every step; thus, the energy reduction is zero.\n- Test Case $3$ adjusts $R$ and geometry so the greedy path uses hops exceeding $d_0$, incurring multipath costs, whereas the two-hop path remains in the free-space regime, generating a large energy reduction.\n\nProgram output:\n- The program enumerates the routes using the defined strategies and sums transmit and receive energies using the radio model. It prints a single line of the form \"[$x_1$,$x_2$,$x_3$]\" where each $x_k$ is the reduction for test case $k$, rounded to six decimal places in joules.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef euclidean_distance(p, q):\n    return float(np.linalg.norm(np.array(p) - np.array(q)))\n\ndef build_adjacency(positions, R):\n    n = len(positions)\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            d = euclidean_distance(positions[i], positions[j])\n            if d <= R + 1e-12:  # tolerances for floating-point\n                adj[i].append(j)\n    return adj\n\ndef radio_params():\n    # Common radio parameters for all test cases\n    L = 4096  # bits\n    E_elec = 5e-8  # J/bit\n    eps_fs = 1e-11  # J/bit/m^2\n    eps_mp = 1.3e-15  # J/bit/m^4\n    d0 = np.sqrt(eps_fs / eps_mp)\n    return L, E_elec, eps_fs, eps_mp, d0\n\ndef E_tx(d, L, E_elec, eps_fs, eps_mp, d0):\n    if d <= d0:\n        return L * E_elec + L * eps_fs * (d ** 2)\n    else:\n        return L * E_elec + L * eps_mp * (d ** 4)\n\ndef E_rx(L, E_elec):\n    return L * E_elec\n\ndef one_hop_greedy_energy(positions, R, src_idx, sink_idx, L, E_elec, eps_fs, eps_mp, d0):\n    adj = build_adjacency(positions, R)\n    total_energy = 0.0\n    current = src_idx\n    sink_pos = positions[sink_idx]\n\n    # Safety cap to avoid infinite loops\n    max_steps = 10000\n    steps = 0\n\n    while current != sink_idx and steps < max_steps:\n        steps += 1\n        current_pos = positions[current]\n        current_sink_dist = euclidean_distance(current_pos, sink_pos)\n\n        # Candidate neighbors strictly closer to sink\n        candidates = []\n        for n in adj[current]:\n            n_pos = positions[n]\n            n_sink_dist = euclidean_distance(n_pos, sink_pos)\n            if n_sink_dist < current_sink_dist - 1e-12:  # strict progress\n                d_cn = euclidean_distance(current_pos, n_pos)\n                candidates.append((n, n_sink_dist, d_cn))\n\n        if not candidates:\n            # No progress possible under greedy; for this test suite it should not occur\n            raise RuntimeError(\"Greedy routing failed to find a progress neighbor.\")\n\n        # Choose neighbor minimizing sink distance, then minimizing hop distance, then index\n        candidates.sort(key=lambda x: (x[1], x[2], x[0]))\n        next_node = candidates[0][0]\n        hop_dist = candidates[0][2]\n\n        # Accumulate energy: transmit + receive at next node\n        total_energy += E_tx(hop_dist, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n\n        current = next_node\n\n    if steps >= max_steps:\n        raise RuntimeError(\"Exceeded maximum steps in greedy routing.\")\n\n    return total_energy\n\ndef two_hop_informed_energy(positions, R, src_idx, sink_idx, L, E_elec, eps_fs, eps_mp, d0):\n    adj = build_adjacency(positions, R)\n    total_energy = 0.0\n    current = src_idx\n    sink_pos = positions[sink_idx]\n\n    max_steps = 10000\n    steps = 0\n\n    while current != sink_idx and steps < max_steps:\n        steps += 1\n        current_pos = positions[current]\n        current_sink_dist = euclidean_distance(current_pos, sink_pos)\n\n        # If sink is directly reachable, do a single hop\n        if sink_idx in adj[current]:\n            d_cs = euclidean_distance(current_pos, sink_pos)\n            total_energy += E_tx(d_cs, L, E_elec, eps_fs, eps_mp, d0)\n            total_energy += E_rx(L, E_elec)\n            current = sink_idx\n            break\n\n        # Build candidate two-hop pairs (i, j)\n        pairs = []\n        for i in adj[current]:\n            i_pos = positions[i]\n            i_sink_dist = euclidean_distance(i_pos, sink_pos)\n            if i_sink_dist >= current_sink_dist - 1e-12:\n                continue  # must be closer than current to sink\n            # Neighbors of i that are closer than current\n            # Include sink if reachable from i\n            for j in adj[i]:\n                j_pos = positions[j]\n                j_sink_dist = euclidean_distance(j_pos, sink_pos)\n                if j_sink_dist < current_sink_dist - 1e-12:\n                    d_ci = euclidean_distance(current_pos, i_pos)\n                    d_ij = euclidean_distance(i_pos, j_pos)\n                    seg_energy = (\n                        E_tx(d_ci, L, E_elec, eps_fs, eps_mp, d0)\n                        + E_rx(L, E_elec)\n                        + E_tx(d_ij, L, E_elec, eps_fs, eps_mp, d0)\n                        + E_rx(L, E_elec)\n                    )\n                    pairs.append((seg_energy, j_sink_dist, i_sink_dist, i, j, d_ci, d_ij))\n\n        if not pairs:\n            # Fall back: pick a one-hop progress neighbor if no two-hop pair exists\n            candidates = []\n            for n in adj[current]:\n                n_pos = positions[n]\n                n_sink_dist = euclidean_distance(n_pos, sink_pos)\n                if n_sink_dist < current_sink_dist - 1e-12:\n                    d_cn = euclidean_distance(current_pos, n_pos)\n                    candidates.append((n, n_sink_dist, d_cn))\n            if not candidates:\n                raise RuntimeError(\"Two-hop routing failed to find progress.\")\n            candidates.sort(key=lambda x: (x[1], x[2], x[0]))\n            next_node = candidates[0][0]\n            hop_dist = candidates[0][2]\n            total_energy += E_tx(hop_dist, L, E_elec, eps_fs, eps_mp, d0)\n            total_energy += E_rx(L, E_elec)\n            current = next_node\n            continue\n\n        # Choose pair minimizing energy; tie-breakers as specified\n        pairs.sort(key=lambda x: (x[0], x[1], x[2], x[3], x[4]))\n        best = pairs[0]\n        _, _, _, i, j, d_ci, d_ij = best\n\n        # Execute the two hops sequentially\n        total_energy += E_tx(d_ci, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n        total_energy += E_tx(d_ij, L, E_elec, eps_fs, eps_mp, d0)\n        total_energy += E_rx(L, E_elec)\n\n        current = j\n\n    if steps >= max_steps:\n        raise RuntimeError(\"Exceeded maximum steps in two-hop routing.\")\n\n    return total_energy\n\ndef solve():\n    L, E_elec, eps_fs, eps_mp, d0 = radio_params()\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"R\": 60.0,\n            \"positions\": [\n                (200.0, 0.0),  # 0 source\n                (0.0, 0.0),    # 1 sink\n                (150.0, 0.0),  # 2\n                (90.0, 0.0),   # 3\n                (30.0, 0.0),   # 4\n                (160.0, 45.0), # 5\n                (120.0, 30.0), # 6\n                (80.0, 20.0),  # 7\n                (40.0, 10.0),  # 8\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n        # Test Case 2\n        {\n            \"R\": 60.0,\n            \"positions\": [\n                (200.0, 0.0),  # 0 source\n                (0.0, 0.0),    # 1 sink\n                (150.0, 0.0),  # 2\n                (100.0, 0.0),  # 3\n                (50.0, 0.0),   # 4\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n        # Test Case 3\n        {\n            \"R\": 120.0,\n            \"positions\": [\n                (200.0, 0.0),   # 0 source\n                (0.0, 0.0),     # 1 sink\n                (100.0, 0.0),   # 2\n                (160.0, 60.0),  # 3\n                (120.0, 40.0),  # 4\n                (80.0, 20.0),   # 5\n                (40.0, 10.0),   # 6\n            ],\n            \"src\": 0,\n            \"sink\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        R = case[\"R\"]\n        positions = case[\"positions\"]\n        src = case[\"src\"]\n        sink = case[\"sink\"]\n\n        e_one = one_hop_greedy_energy(positions, R, src, sink, L, E_elec, eps_fs, eps_mp, d0)\n        e_two = two_hop_informed_energy(positions, R, src, sink, L, E_elec, eps_fs, eps_mp, d0)\n        reduction = e_one - e_two\n        # Round to six decimal places\n        results.append(round(reduction, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Effective WSN design requires a deep appreciation for cross-layer interactions, where decisions at one layer of the network stack profoundly affect others. This exercise challenges you to build a model from the ground up, starting from a physical layer parameter—transmit power—and tracing its impact through signal propagation, bit error rates, and packet reception rates, all the way to network-level routing costs and connectivity . You will quantitatively analyze the fundamental trade-off between conserving energy by lowering transmit power and maintaining robust network performance, a critical consideration in any real-world cyber-physical system deployment.",
            "id": "4254534",
            "problem": "A small wireless sensor network is embedded in a Cyber-Physical System and mirrored by a Digital Twin. The network consists of $N$ sensor nodes and one sink node. The nodes are placed randomly but deterministically by a fixed seed in a square of side length $S$ meters, and the sink is at the center. Each sensor must deliver one data packet to the sink using multi-hop routing. The program must quantify how reducing transmit power affects link packet reception rate ($PRR$) and expected transmission count ($ETX$), and must compute the net energy savings versus connectivity loss over the network.\n\nThe setting uses the following well-tested base models and definitions to connect physical layer effects to network performance:\n\n- Log-distance path loss: the received power in decibel-milliwatts is $P_r(\\mathrm{dBm}) = P_t(\\mathrm{dBm}) + G_t + G_r - PL(d)$, with $PL(d) = PL(d_0) + 10 n \\log_{10}(d/d_0)$ for $d \\ge d_0$, where $n$ is the path loss exponent, $G_t$ and $G_r$ are antenna gains in decibels, $d_0$ is a reference distance, and $PL(d_0)$ is the free-space reference loss, $PL(d_0) = 20 \\log_{10}(4 \\pi d_0 / \\lambda)$ with $\\lambda = c/f$, $c$ the speed of light, and $f$ the carrier frequency.\n- Thermal noise in decibel-milliwatts: $N(\\mathrm{dBm}) = -174 + 10 \\log_{10}(B) + NF$, where $B$ is the receiver bandwidth in hertz and $NF$ is the receiver noise figure in decibels. Assume $B \\approx R_b$, where $R_b$ is the bit rate, making $E_b/N_0 \\approx \\mathrm{SNR}$.\n- Binary Phase Shift Keying (BPSK) in Additive White Gaussian Noise (AWGN): the bit error probability is $\\mathrm{BER} = Q\\!\\left(\\sqrt{2 E_b/N_0}\\right)$, where $Q(x)$ is the tail probability of the standard normal distribution, $Q(x) = \\tfrac{1}{2}\\,\\mathrm{erfc}\\!\\left(x/\\sqrt{2}\\right)$.\n- Packet reception rate for a packet of $L$ bits under independent bit errors is $PRR = (1 - \\mathrm{BER})^{L}$.\n\nAssume the acknowledgment (ACK) mechanism requires an acknowledgment packet of $L_\\mathrm{ack}$ bits to be received by the sender to confirm delivery. Let $df$ and $dr$ denote the forward and reverse $PRR$ of a link, respectively. Define the expected transmission count $ETX$ for acknowledged unicast as the expected number of data transmissions required to receive one ACK, starting from the definitions above. Similarly, derive the expected number of ACK transmissions per successful end-to-end delivery in terms of $dr$.\n\nLet the per-attempt data transmit energy be $E_\\mathrm{tx,data} = P_t \\, T_\\mathrm{data}$ with $T_\\mathrm{data} = L / R_b$, and the per-ACK transmit energy be $E_\\mathrm{tx,ack} = P_t \\, T_\\mathrm{ack}$ with $T_\\mathrm{ack} = L_\\mathrm{ack} / R_b$. Using the preceding definitions, derive the expected per-link transmit energy cost for one successful delivery over a single hop, expressed in terms of $ETX$, $E_\\mathrm{tx,data}$, and $dr$. For routing, use additive path costs equal to the sum of per-link expected transmit energy costs along the path. A link is considered unusable if $PRR < 10^{-3}$ in either direction. Treat $PRR$ as symmetric and identical in both directions, i.e., $df = dr$.\n\nNetwork geometry and physical parameters:\n- Number of sensors: $N = 12$.\n- Area side length: $S = 200$ meters.\n- Seed for random placement: $42$.\n- Sink position: center $(S/2, S/2)$ meters.\n- Data packet length: $L = 1024$ bits.\n- ACK packet length: $L_\\mathrm{ack} = 112$ bits.\n- Bit rate: $R_b = 250 \\times 10^3$ bits per second.\n- Carrier frequency: $f = 2.4 \\times 10^9$ hertz.\n- Path loss exponent: $n = 2.7$.\n- Reference distance: $d_0 = 1$ meter.\n- Antenna gains: $G_t = 0$ decibels, $G_r = 0$ decibels.\n- Noise figure: $NF = 5$ decibels.\n- Baseline transmit power: $P_{t,\\mathrm{base}} = 10$ milliwatts.\n\nFor each test case, the network topology is identical; only the transmit power changes. Compute all link $PRR$ and $ETX$, and construct the routing graph by excluding unusable links. For each sensor node, compute the minimum expected transmit energy path to the sink using additive per-link costs. Define the connectivity set for a given transmit power as the set of sensor nodes that have at least one finite-cost path to the sink.\n\nDefine the following outcome metrics per test case:\n- Total expected network transmit energy in joules to deliver one packet from each sensor in the reduced-power connectivity set to the sink, evaluated under both the baseline and the reduced-power per-link costs over the same set of nodes, to allow a fair comparison of energy. Compute the absolute energy saving in joules as the difference between the baseline total and the reduced total, and the fractional energy saving as a decimal $(E_\\mathrm{base} - E_\\mathrm{reduced})/E_\\mathrm{base}$. If $E_\\mathrm{base} = 0$, report the fractional energy saving as $0$.\n- Connectivity loss as the decimal $(|C_\\mathrm{base}| - |C_\\mathrm{reduced}|)/|C_\\mathrm{base}|$, where $C_\\mathrm{base}$ and $C_\\mathrm{reduced}$ are the baseline and reduced connectivity sets, respectively.\n- Average $PRR$ ratio as the mean of $PRR_\\mathrm{reduced}/PRR_\\mathrm{base}$ over all undirected links that are usable in both baseline and reduced-power graphs. If the intersection is empty, report $0$.\n- Average $ETX$ ratio as the mean of $ETX_\\mathrm{reduced}/ETX_\\mathrm{base}$ over the same set of links. If the intersection is empty, report $0$.\n\nAngle units are not involved. All energies must be expressed in joules, and power in watts. Distances are in meters.\n\nTest suite of transmit power reductions relative to the baseline $P_{t,\\mathrm{base}}$:\n- Case $1$: reduction $0$ decibels.\n- Case $2$: reduction $3$ decibels.\n- Case $3$: reduction $8$ decibels.\n- Case $4$: reduction $15$ decibels.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a list of five floats per test case in the order $[E_\\mathrm{saved,J}, E_\\mathrm{saved,frac}, \\mathrm{conn\\_loss}, \\mathrm{avg\\_PRR\\_ratio}, \\mathrm{avg\\_ETX\\_ratio}]$. For example, the overall structure should be $[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$.",
            "solution": "This problem requires a multi-layered analysis of a wireless sensor network, connecting physical layer parameters to network-level performance. The solution is developed by modeling the system from the physical layer up to the network layer.\n\n**1. Physical Layer: Link Quality Calculation**\nFor each link between two nodes separated by distance $d$, the Packet Reception Rate ($PRR$) is computed based on the transmit power $P_t$.\n-   **Path Loss ($PL$)**: The path loss is calculated using the log-distance model: $PL(d)[\\mathrm{dB}] = PL(d_0) + 10 n \\log_{10}(d/d_0)$, where $PL(d_0)$ is the reference loss at $d_0=1$m.\n-   **Received Power ($P_r$)**: The received power is $P_r[\\mathrm{dBm}] = P_t[\\mathrm{dBm}] - PL(d)$.\n-   **Noise Power ($N_{pwr}$)**: The thermal noise power is calculated from the standard formula: $N_{pwr}[\\mathrm{dBm}] = -174 + 10 \\log_{10}(B) + NF$.\n-   **SNR and BER**: The Signal-to-Noise Ratio is $\\mathrm{SNR} = P_r / N_{pwr}$. The problem specifies assuming $E_b/N_0 \\approx \\mathrm{SNR}$. For BPSK modulation, the Bit Error Rate is then calculated as $\\mathrm{BER} = Q(\\sqrt{2 E_b/N_0}) = \\frac{1}{2} \\mathrm{erfc}(\\sqrt{E_b/N_0})$.\n-   **Packet Reception Rate ($PRR$)**: Assuming independent bit errors, the PRR for a packet of length $L$ is $PRR = (1 - \\mathrm{BER})^L$.\n\n**2. Link Layer: ETX and Energy Cost**\n-   **Expected Transmission Count ($ETX$)**: A transmission is successful only if both the data packet and its acknowledgment are received. Given the problem's simplifying assumption of a symmetric $PRR$ for both data and ACK packets ($df=dr=PRR$), the success probability of one attempt is $PRR^2$. The number of attempts follows a geometric distribution, so the ETX is $ETX = 1/PRR^2$.\n-   **Per-Link Energy Cost ($E_{\\mathrm{link}}$)**: The expected transmit energy for one successful hop combines the sender's data packet energy and the receiver's ACK packet energy. The sender transmits an average of $ETX$ data packets. The receiver must successfully transmit one ACK. The expected number of ACK transmissions to achieve this is $1/PRR$. Thus, the total expected link cost is:\n$$ E_{\\mathrm{link}} = ETX \\cdot \\left(P_t \\frac{L}{R_b}\\right) + \\frac{1}{PRR} \\cdot \\left(P_t \\frac{L_{\\mathrm{ack}}}{R_b}\\right) $$\n\n**3. Network Layer: Graph and Routing**\nThe network is modeled as a graph where an edge exists between two nodes if their link is \"usable\" ($PRR \\ge 10^{-3}$). The weight of each edge is the calculated per-link energy cost, $E_{\\mathrm{link}}$. Dijkstra's algorithm is then used to find the minimum energy path from each sensor to the sink, as it is a single-source shortest path problem on a graph with non-negative edge weights.\n\n**4. Performance Metric Calculation**\nThe final step involves computing the specified metrics. For energy savings, the total network energy is calculated for both baseline and reduced-power scenarios, but importantly, the sum is taken over only those nodes that remain connected in the reduced-power case to ensure a fair comparison. Connectivity loss is the fractional decrease in the number of connected nodes. The PRR and ETX ratios are averaged over all links that remain usable in both scenarios.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.constants import c\nfrom scipy.sparse.csgraph import dijkstra\n\ndef solve():\n    \"\"\"\n    Solves the wireless sensor network problem by modeling the physical, link,\n    and network layers to evaluate energy and connectivity trade-offs.\n    \"\"\"\n\n    # 1. System Parameters\n    N = 12  # Number of sensors\n    S = 200.0  # meters\n    SEED = 42\n    L = 1024  # bits\n    L_ack = 112  # bits\n    R_b = 250e3  # bits per second\n    f = 2.4e9  # Hz\n    n_pl = 2.7\n    d0 = 1.0  # meters\n    G_t = 0.0  # dB\n    G_r = 0.0  # dB\n    NF = 5.0  # dB\n    P_T_BASE_W = 0.010  # 10mW in Watts\n\n    # Test suite: power reductions in dB\n    power_reductions_db = [0.0, 3.0, 8.0, 15.0]\n\n    # Derived constants\n    LAMBDA = c / f\n    T_data = L / R_b\n    T_ack = L_ack / R_b\n    \n    # Path loss at reference distance d0\n    pl_d0_db = 20 * np.log10(4 * np.pi * d0 / LAMBDA)\n    \n    # Noise power calculation\n    B = R_b\n    noise_power_dbm = -174 + 10 * np.log10(B) + NF\n    noise_power_w = 1e-3 * (10**(noise_power_dbm / 10))\n\n    # 2. Node Placement\n    rng = np.random.default_rng(SEED)\n    sensor_pos = rng.random((N, 2)) * S\n    sink_pos = np.array([[S / 2, S / 2]])\n    all_pos = np.vstack((sensor_pos, sink_pos))\n    \n    # Calculate all inter-node distances\n    dist_matrix = np.sqrt(np.sum((all_pos[:, np.newaxis, :] - all_pos[np.newaxis, :, :])**2, axis=-1))\n    np.fill_diagonal(dist_matrix, 0)\n\n    # Store results for all test cases\n    all_results = []\n    baseline_metrics = None\n\n    for reduction_db in power_reductions_db:\n        # 3. Core Physics and Link Calculation for the current power level\n        p_t_dbm = 10 * np.log10(P_T_BASE_W * 1000) - reduction_db\n        p_t_w = 1e-3 * (10**(p_t_dbm / 10))\n\n        # Vectorized calculations for all links\n        d_eff = np.maximum(dist_matrix, d0)\n        pl_db = pl_d0_db + 10 * n_pl * np.log10(d_eff / d0)\n        np.fill_diagonal(pl_db, -np.inf) # Avoid self-path loss\n\n        p_r_dbm = p_t_dbm + G_t + G_r - pl_db\n        p_r_w = 1e-3 * (10**(p_r_dbm / 10))\n\n        snr = p_r_w / noise_power_w\n        e_b_n0 = snr # As per problem statement\n        \n        # Clip to avoid math errors with very low SNR\n        e_b_n0_clipped = np.maximum(e_b_n0, 1e-20)\n\n        # BPSK BER\n        ber = 0.5 * erfc(np.sqrt(e_b_n0_clipped))\n        \n        # PRR, ETX, and Link Energy Cost\n        prr = (1 - ber)**L\n        \n        # Avoid division by zero for very small PRR\n        prr_clipped = np.maximum(prr, 1e-12)\n        etx = 1 / (prr_clipped**2)\n        \n        e_tx_data = p_t_w * T_data\n        e_tx_ack = p_t_w * T_ack\n        link_energy_cost = (etx * e_tx_data) + (1/prr_clipped) * e_tx_ack\n\n        # 4. Graph Construction and Routing\n        adjacency_matrix = link_energy_cost.copy()\n        adjacency_matrix[prr < 1e-3] = np.inf\n        np.fill_diagonal(adjacency_matrix, 0)\n        \n        # Dijkstra from sink (node N) to all sensors\n        path_costs = dijkstra(adjacency_matrix, directed=False, indices=N)\n        \n        # Current case metrics\n        current_metrics = {\n            'prr': prr,\n            'etx': etx,\n            'path_costs': path_costs[:N],\n            'graph': adjacency_matrix < np.inf\n        }\n\n        if baseline_metrics is None:\n            baseline_metrics = current_metrics\n        \n        # 5. Performance Metrics Calculation\n        # Connectivity\n        c_base = np.where(baseline_metrics['path_costs'] < np.inf)[0]\n        c_reduced = np.where(current_metrics['path_costs'] < np.inf)[0]\n        \n        if len(c_base) > 0:\n            conn_loss = (len(c_base) - len(c_reduced)) / len(c_base)\n        else:\n            conn_loss = 0.0\n\n        # Energy Savings\n        # Compare over the set of nodes connected in the reduced power graph\n        connected_in_reduced = c_reduced\n        if len(connected_in_reduced) > 0:\n            e_reduced = np.sum(current_metrics['path_costs'][connected_in_reduced])\n            # For fair comparison, calculate baseline energy for the SAME set of nodes\n            e_base_for_saving = np.sum(baseline_metrics['path_costs'][connected_in_reduced])\n            e_saved_j = e_base_for_saving - e_reduced\n            e_saved_frac = e_saved_j / e_base_for_saving if e_base_for_saving > 0 else 0.0\n        else: # No nodes connected\n            e_saved_j = 0.0\n            e_saved_frac = 0.0\n\n        # Average Ratios\n        # Identify links usable in both scenarios (upper triangle to count once)\n        common_links_mask = np.triu(baseline_metrics['graph'], 1) & np.triu(current_metrics['graph'], 1)\n        \n        if np.any(common_links_mask):\n            prr_ratio = current_metrics['prr'][common_links_mask] / baseline_metrics['prr'][common_links_mask]\n            etx_ratio = current_metrics['etx'][common_links_mask] / baseline_metrics['etx'][common_links_mask]\n            avg_prr_ratio = np.mean(prr_ratio)\n            avg_etx_ratio = np.mean(etx_ratio)\n        else:\n            avg_prr_ratio = 0.0\n            avg_etx_ratio = 0.0\n\n        # Assemble results for this case\n        case_results = [\n            e_saved_j,\n            e_saved_frac,\n            conn_loss,\n            avg_prr_ratio,\n            avg_etx_ratio\n        ]\n        all_results.append(case_results)\n\n    # 6. Final Output Formatting\n    # Convert results to a string with the required format\n    def format_list(lst):\n        return f\"[{','.join(f'{x:.7f}' for x in lst)}]\"\n\n    print(f\"[{','.join(format_list(r) for r in all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond optimizing individual transmissions, a key goal in WSNs is to maximize the entire network's operational lifetime. This often involves balancing the energy load across all nodes to prevent a critical node from depleting its battery prematurely. This advanced practice introduces you to formulating such a system-level goal as a formal optimization problem . You will learn how to model the network as a system of flows and constraints, translating the objective of maximum lifetime into a Linear Program (LP) that can be solved to find the optimal traffic distribution, a powerful technique essential for the intelligent management capabilities of a Digital Twin.",
            "id": "4254451",
            "problem": "Consider a Wireless Sensor Network (WSN) in the context of Cyber-Physical Systems (CPS), represented as a directed graph with node set $\\mathcal{N}$ and directed edge set $\\mathcal{E} \\subseteq \\mathcal{N} \\times \\mathcal{N}$. There is a unique sink node $s \\in \\mathcal{N}$. Each node $i \\in \\mathcal{N}$ (excluding $s$) generates data at a constant rate $d_i$ measured in bits per second (bit/s), with $d_s = 0$. Each directed edge $(i,j) \\in \\mathcal{E}$ has a per-unit transmission energy cost $c_{ij}$ measured in Joules per bit (J/bit). Each node $i \\in \\mathcal{N}$ has a residual energy $E_i$ measured in Joules (J). All traffic is destined for the sink $s$, and the network operates in steady state with constant flow rates $f_{ij} \\geq 0$ on each edge $(i,j) \\in \\mathcal{E}$, in bits per second.\n\nFundamental base:\n- Flow conservation holds at every node: the net outgoing flow rate minus net incoming flow rate at node $i$ equals the data generation rate $d_i$ for $i \\neq s$, and equals $-\\sum_{k \\neq s} d_k$ for $i = s$.\n- The energy depletion rate at node $i$ is given by $p_i = \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij}$ measured in Joules per second (J/s).\n- The network lifetime $T$ measured in seconds (s) is the time until the first node's residual energy is exhausted under steady-state operation, i.e., $T = \\min_{i \\in \\mathcal{N}} \\frac{E_i}{p_i}$.\n\nTask: Write a complete, runnable program that, for each of the test cases below, computes the maximum achievable network lifetime $T$ under all feasible steady-state flows that satisfy nonnegativity and flow conservation. The solution must implement a mathematically sound method that embodies the principle of balancing marginal depletion rates across nodes to maximize $T$.\n\nAssumptions:\n- Reception energy costs are negligible compared to transmission; only transmission energy costs are considered in $p_i$.\n- All generated data must be delivered to the sink $s$.\n- There are no link capacity constraints beyond nonnegativity.\n\nUnits:\n- Answer in seconds (s) as decimal floating-point numbers.\n\nTest Suite:\nProvide results for the following four test cases. Each test case supplies $(\\mathcal{N}, s, \\mathcal{E}, \\{c_{ij}\\}, \\{E_i\\}, \\{d_i\\})$.\n\n- Test Case $1$ (single path aggregation, balanced by structure):\n    - Nodes: $\\mathcal{N} = \\{1,2,3\\}$, sink $s = 3$.\n    - Edges: $\\mathcal{E} = \\{(1,2),(2,3)\\}$.\n    - Costs: $c_{12} = 5 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{23} = 4 \\times 10^{-6}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 100$ $\\mathrm{J}$, $E_2 = 120$ $\\mathrm{J}$, $E_3 = 10000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 1000$ $\\mathrm{bit/s}$, $d_2 = 500$ $\\mathrm{bit/s}$, $d_3 = 0$ $\\mathrm{bit/s}$.\n\n- Test Case $2$ (splittable source traffic with asymmetric costs and heterogeneous energies):\n    - Nodes: $\\mathcal{N} = \\{1,2,3,4\\}$, sink $s = 4$.\n    - Edges: $\\mathcal{E} = \\{(1,2),(1,3),(2,4),(3,4)\\}$.\n    - Costs: $c_{12} = 6 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{13} = 3 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{24} = 5 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{34} = 8 \\times 10^{-6}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 150$ $\\mathrm{J}$, $E_2 = 90$ $\\mathrm{J}$, $E_3 = 60$ $\\mathrm{J}$, $E_4 = 1000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 2000$ $\\mathrm{bit/s}$, $d_2 = 0$ $\\mathrm{bit/s}$, $d_3 = 0$ $\\mathrm{bit/s}$, $d_4 = 0$ $\\mathrm{bit/s}$.\n\n- Test Case $3$ (tiny energy at source dominates lifetime):\n    - Nodes: $\\mathcal{N} = \\{1,2\\}$, sink $s = 2$.\n    - Edges: $\\mathcal{E} = \\{(1,2)\\}$.\n    - Costs: $c_{12} = 1 \\times 10^{-5}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 1$ $\\mathrm{J}$, $E_2 = 1000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 1000$ $\\mathrm{bit/s}$, $d_2 = 0$ $\\mathrm{bit/s}$.\n\n- Test Case $4$ (multiple sources funnel through a single forwarding node):\n    - Nodes: $\\mathcal{N} = \\{1,2,3,4,5\\}$, sink $s = 5$.\n    - Edges: $\\mathcal{E} = \\{(1,4),(2,4),(3,4),(4,5)\\}$.\n    - Costs: $c_{14} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{24} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{34} = 2 \\times 10^{-6}$ $\\mathrm{J/bit}$, $c_{45} = 1 \\times 10^{-5}$ $\\mathrm{J/bit}$.\n    - Energies: $E_1 = 50$ $\\mathrm{J}$, $E_2 = 50$ $\\mathrm{J}$, $E_3 = 50$ $\\mathrm{J}$, $E_4 = 60$ $\\mathrm{J}$, $E_5 = 1000$ $\\mathrm{J}$.\n    - Data rates: $d_1 = 500$ $\\mathrm{bit/s}$, $d_2 = 1200$ $\\mathrm{bit/s}$, $d_3 = 300$ $\\mathrm{bit/s}$, $d_4 = 0$ $\\mathrm{bit/s}$, $d_5 = 0$ $\\mathrm{bit/s}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the lifetimes for the four test cases as a comma-separated list enclosed in square brackets, with each lifetime in seconds rounded to six decimal places (e.g., $\\texttt{[20000.000000,12750.000000,100.000000,3000.000000]}$).",
            "solution": "The problem asks for the maximum network lifetime, which is a classic bottleneck optimization problem. The key is to formulate this as a Linear Program (LP). The lifetime $T$ is defined by the first node to run out of energy:\n$$\nT = \\min_{i \\in \\mathcal{N}} \\frac{E_i}{p_i}\n$$\nwhere $E_i$ is the initial energy and $p_i = \\sum_{j} c_{ij} f_{ij}$ is the power depletion rate of node $i$ due to transmitting with flow rates $f_{ij}$.\n\nTo handle the `min` operator in the objective, we introduce a new variable, $\\gamma = 1/T$, and reformulate the problem as minimizing $\\gamma$ (which is equivalent to maximizing $T$). The lifetime definition $T \\ge 1/\\gamma$ implies that for every node $i$, its individual lifetime must be at least $T$. This gives us a set of linear constraints:\n$$\n\\frac{E_i}{p_i} \\geq \\frac{1}{\\gamma} \\implies p_i \\leq E_i \\gamma \\implies \\sum_{j : (i,j) \\in \\mathcal{E}} c_{ij} f_{ij} - E_i \\gamma \\leq 0\n$$\nThese constraints must hold for all transmitting nodes.\n\nAdditionally, the flow rates $\\{f_{ij}\\}$ must satisfy the flow conservation laws. For each non-sink node $i$, the total outgoing flow must equal the total incoming flow plus the data generated at that node:\n$$\n\\sum_{j:(i,j) \\in \\mathcal{E}} f_{ij} - \\sum_{k:(k,i) \\in \\mathcal{E}} f_{ki} = d_i\n$$\n\nThe complete LP formulation is therefore:\n\n**Variables:**\n-   $\\gamma$: The maximum normalized energy depletion rate (inverse of lifetime).\n-   $f_{ij}$: The flow rate on each edge $(i, j)$.\n\n**Objective:** Minimize $\\gamma$.\n\n**Subject to:**\n1.  **Lifetime Constraints:** $\\sum_{j} c_{ij} f_{ij} - E_i \\gamma \\leq 0$ for each transmitting node $i$.\n2.  **Flow Conservation:** $\\sum_{j} f_{ij} - \\sum_{k} f_{ki} = d_i$ for each non-sink node $i$.\n3.  **Non-negativity:** $f_{ij} \\geq 0$ for all edges and $\\gamma \\geq 0$.\n\nThis LP can be solved using a standard solver. The optimal objective value, $\\gamma^*$, gives the maximum lifetime as $T_{max} = 1/\\gamma^*$. This approach finds the optimal traffic distribution that balances the load across nodes to maximize the time until the first one fails.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves the WSN lifetime maximization problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: single path aggregation, balanced by structure\n        {\n            \"nodes\": {1, 2, 3},\n            \"sink\": 3,\n            \"edges\": {(1, 2), (2, 3)},\n            \"costs\": {(1, 2): 5e-6, (2, 3): 4e-6},\n            \"energies\": {1: 100, 2: 120, 3: 10000},\n            \"rates\": {1: 1000, 2: 500, 3: 0},\n        },\n        # Test Case 2: splittable source traffic with asymmetric costs and heterogeneous energies\n        {\n            \"nodes\": {1, 2, 3, 4},\n            \"sink\": 4,\n            \"edges\": {(1, 2), (1, 3), (2, 4), (3, 4)},\n            \"costs\": {(1, 2): 6e-6, (1, 3): 3e-6, (2, 4): 5e-6, (3, 4): 8e-6},\n            \"energies\": {1: 150, 2: 90, 3: 60, 4: 1000},\n            \"rates\": {1: 2000, 2: 0, 3: 0, 4: 0},\n        },\n        # Test Case 3: tiny energy at source dominates lifetime\n        {\n            \"nodes\": {1, 2},\n            \"sink\": 2,\n            \"edges\": {(1, 2)},\n            \"costs\": {(1, 2): 1e-5},\n            \"energies\": {1: 1, 2: 1000},\n            \"rates\": {1: 1000, 2: 0},\n        },\n        # Test Case 4: multiple sources funnel through a single forwarding node\n        {\n            \"nodes\": {1, 2, 3, 4, 5},\n            \"sink\": 5,\n            \"edges\": {(1, 4), (2, 4), (3, 4), (4, 5)},\n            \"costs\": {(1, 4): 2e-6, (2, 4): 2e-6, (3, 4): 2e-6, (4, 5): 1e-5},\n            \"energies\": {1: 50, 2: 50, 3: 50, 4: 60, 5: 1000},\n            \"rates\": {1: 500, 2: 1200, 3: 300, 4: 0, 5: 0},\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        lifetime = solve_case(case)\n        results.append(f\"{lifetime:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(case_data):\n    \"\"\"\n    Formulates and solves the LP for a single test case.\n\n    The LP is set up to minimize gamma = 1/T, where T is the network lifetime.\n    Variables are [gamma, f_1, f_2, ..., f_m], where f_i are flow variables.\n    \"\"\"\n    nodes = sorted(list(case_data[\"nodes\"]))\n    sink_node = case_data[\"sink\"]\n    edges = sorted(list(case_data[\"edges\"]))\n    costs = case_data[\"costs\"]\n    energies = case_data[\"energies\"]\n    rates = case_data[\"rates\"]\n\n    node_to_idx = {node: i for i, node in enumerate(nodes)}\n    non_sink_nodes = [n for n in nodes if n != sink_node]\n    \n    m = len(edges)\n    edge_to_idx = {edge: i for i, edge in enumerate(edges)}\n    \n    # LP variables are: [gamma, f_0, f_1, ... f_{m-1}]\n    num_vars = 1 + m\n    \n    # Objective function: minimize gamma\n    # c = [1, 0, 0, ...]\n    c = np.zeros(num_vars)\n    c[0] = 1\n\n    # Equality constraints (flow conservation)\n    # For each non-sink node i: sum(f_out) - sum(f_in) = d_i\n    num_eq_constraints = len(non_sink_nodes)\n    A_eq = np.zeros((num_eq_constraints, num_vars))\n    b_eq = np.zeros(num_eq_constraints)\n\n    for i, node in enumerate(non_sink_nodes):\n        b_eq[i] = rates.get(node, 0)\n        for edge_idx, edge in enumerate(edges):\n            u, v = edge\n            # Variable index for flow f_uv is 1 + edge_idx\n            var_idx = 1 + edge_idx\n            if u == node:\n                A_eq[i, var_idx] = 1  # Outgoing flow\n            if v == node:\n                A_eq[i, var_idx] = -1 # Incoming flow\n\n    # Inequality constraints (lifetime)\n    # For each transmitting non-sink node i: sum(c_ij * f_ij) - E_i * gamma <= 0\n    transmitting_nodes = {u for u, v in edges if u != sink_node}\n    num_ub_constraints = len(transmitting_nodes)\n    A_ub = np.zeros((num_ub_constraints, num_vars))\n    b_ub = np.zeros(num_ub_constraints)\n    \n    for i, node in enumerate(sorted(list(transmitting_nodes))):\n        # Gamma coefficient\n        A_ub[i, 0] = -energies.get(node, 0)\n        \n        # Flow coefficients\n        for edge_idx, edge in enumerate(edges):\n            u, v = edge\n            if u == node:\n                var_idx = 1 + edge_idx\n                A_ub[i, var_idx] = costs.get(edge, 0)\n\n    # Bounds: gamma >= 0, f_ij >= 0\n    bounds = (0, None)\n\n    # Solve the linear program\n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n    \n    if not res.success:\n        raise RuntimeError(\"LP solver failed to find a solution.\")\n\n    # Optimal gamma is the minimum value of the objective function\n    gamma_star = res.fun\n    \n    # Handle case of infinite lifetime\n    if gamma_star <= 1e-9: # Using a small tolerance for floating point\n        return float('inf')\n\n    # Lifetime is 1/gamma\n    max_lifetime = 1.0 / gamma_star\n    return max_lifetime\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}