## 引言
在我们的数字世界中，有些设备只对即时命令做出纯粹的反应，而另一些设备似乎拥有一种记忆形式，会根据过去的交互而表现出不同的行为。按下电视遥控器的电源按钮，既可以打开设备，也可以关闭设备——这一操作取决于设备的当前状态。这种“状态”或对过去事件的记忆的概念，是[时序逻辑](@article_id:326113)的基石，并被一个强大的计算模型正式地捕捉：[有限状态机](@article_id:323352)（FSM）。虽然这个想法很简单，但从这个抽象概念到一个功能可靠的硬件或一个复杂的生物模型，其间的鸿沟似乎是巨大的。我们如何系统地设计这些智能系统呢？

本文通过对 FSM 设计进行全面概述来弥合这一鸿沟。我们将首先探讨支配 FSM 的核心**原理与机制**。本节将深入研究两种基本的设计哲学——Moore 和 Mealy 模型，并逐步介绍从概念[状态图](@article_id:323413)到在硅片上铸就的优化逻辑方程的实现过程。随后，在**应用与跨学科联系**部分，我们将游历 FSM 不可或缺的各个领域，发现它们在数字处理器中扮演的心脏角色，在复杂数据流中担当的解释者角色，甚至作为工程和理解生命本身的蓝图。

## 原理与机制

### 机器之魂：记忆与状态

想象一个简单的袖珍计算器。你输入 $2+2$，它显示 $4$。输出*只*取决于当前的输入。它没有你之前操作的记忆。这是一种**组合**电路。现在，想想你的电视遥控器。你按一次电源按钮，电视打开。你再按一次，电视关闭。同一个按钮，同样的物理动作，产生了两种不同的结果。为什么？因为遥控器，或它控制的电视，*记住*了它当前的状态。它处于“开”状态或“关”状态。这种记住过去事件并根据该记忆采取不同行动的能力，是**时序**电路的决定性特征。

[时序电路](@article_id:346313)的核心是**状态**的概念。状态是机器为做出未来决策而需要的所有过去输入信息的快照。对于一个旨在检测特定按键序列的系统，其状态可能是“尚未看到序列的任何部分”、“已看到序列的第一部分”等等。[有限状态机](@article_id:323352)（FSM）就是一个围绕这个理念构建的[计算数学](@article_id:313928)模型：它拥有有限数量的这些状态，以及一套规则来规定它如何根据输入从一个状态转换到另一个状态。FSM 的全部历史被浓缩到其当前状态中。正是这种优雅的抽象，让我们能够设计从简单控制器到计算机处理器内部复杂逻辑的各种系统 [@problem_id:1959247]。

### 两种哲学：Moore 与 Mealy 模型

当 FSM 决定产生输出时，它可以通过两种方式之一来实现，从而产生了两种设计“哲学”或模型，这些模型以将其形式化的先驱 Edward F. Moore 和 George H. Mealy 的名字命名。

#### Moore 机：深思熟虑的规划者

**Moore 机**是一个坚定、可预测的角色。其输出*仅*由其当前状态决定。输出是对机器当前状况的声明，而不是对特定输入事件的反应。

考虑一个设计用于检查奇偶校验的简单机器：如果它在其输入流中看到奇数个 `1`，则输出 `1`，否则输出 `0`。我们只需要两个状态：`S_even`（我们已经看到了偶数个 1）和 `S_odd`（我们已经看到了奇数个 1）。在 Moore 机中，状态 `S_even` *就是*输出 `0`，而状态 `S_odd` *就是*输出 `1`。当输入一个 `0` 时，奇偶性不变，所以机器停留在当前状态。当输入一个 `1` 时，奇偶性翻转，所以机器转换到另一个状态。输出与状态本身直接且不可改变地绑定在一起 [@problem_id:1969135]。

这个原理可以用于更复杂的方式。想象一下，你想构建一个电路，将输入[信号延迟](@article_id:325229)两个[时钟周期](@article_id:345164)，使得时间 $t$ 的输出 $Z(t)$ 等于时间 $t-2$ 的输入 $X(t-2)$。一个 Moore FSM 可以通过将其状态定义为最后两个输入的历史来实现这一点。设状态为 $(S_1, S_0)$，其中 $S_1$ 存储上一个周期的输入 $X(t-1)$，$S_0$ 存储两个周期前的输入 $X(t-2)$。由于输出必须是 $X(t-2)$，输出就是状态位 $S_0$。机器的输出是其状态的一个属性，这是典型的 Moore 行为。在每个时钟滴答时，历史记录都会更新：当前输入 $X(t)$ 成为新的 $S_1$，而旧的 $S_1$ 成为新的 $S_0$，就像一个微型的两级传送带 [@problem_id:1928683]。

#### Mealy 机：快速反应者

相比之下，**Mealy 机**是一个快速反应者。其输出取决于**当前状态**和**当前输入**。输出不是一个持续的状况，而是在转换*期间*发生的一个动作。

让我们看一个设计用来检测序列 '01' 的机器。我们可能有一个状态 `S0`（复位状态）和一个状态 `S1`（我们刚刚看到了一个 '0'）。如果我们处于状态 `S1` 并且*当前输入*是 '1'，机器就检测到了该序列。Mealy 机将在那次特定的转换中将其输出置为 `1`。输出不与我们离开的状态（`S1`）或我们进入的状态（可能回到 `S0`）相关联，而是与导致转换的状态*和*输入的组合相关联。这使得 Mealy 机在某些应用中能够比它们的 Moore 对应物快一个[时钟周期](@article_id:345164)做出反应，因为它们不必等待下一个[时钟沿](@article_id:350218)来注册新状态才产生输出 [@problem_id:1976119]。

虽然它们看起来不同，但这两种模型在根本上是相关的。任何 Mealy 机都可以转换成一个等效的 Moore 机，产生相同的输出序列（尽管可能会延迟一个[时钟周期](@article_id:345164)）。诀窍在于将转换输出“吸收”到状态定义中。如果一个 Mealy 机有一个进入状态 `S` 并产生 `1` 的转换，我们可以创建一个新的 Moore 状态，比如 `S_1`，其专用输出为 `1`。所有进入 `S` 且输出为 `1` 的 Mealy 转换现在都指向我们的新状态 `S_1`。本质上，Mealy 机的*动作*变成了 Moore 机的*状况*。这揭示了一种深层的统一性：“状态”的概念足够灵活，不仅可以编码输入的历史，还可以编码导致它的事件的性质 [@problem_id:1962873]。

### 从想法到硅片：实现的艺术

我们如何将这些抽象的想法铸造成由硅和导线组成的物理电路？这是一段从高层概念到低层逻辑的迷人旅程。

#### 蓝图：[状态图](@article_id:323413)

这个过程通常从一幅图开始。我们将机器的行为描绘成**[状态图](@article_id:323413)**，即由箭头（转换）连接的气泡（状态）的集合。这是一个以人为中心的创造性阶段，我们将一套规则转化为可视化的流程图。

例如，设计一个简单的双层电梯控制器，需要定义捕捉每个重要情况的状态：`Idle_At_Floor_1`（在1楼空闲）、`Moving_Up`（向上移动）、`Door_Open_At_Floor_2`（在2楼开门）等等。箭头上标注了导致情况变化的输入，比如按下楼层请求按钮（`REQ=10`）或电梯到达目的地（`ARRIVED=1`）。在本例中，每个气泡都是一个 Moore 状态，其输出会列在内部：像 `Moving_Up` 这样的状态会将其 `MOVE_UP` 输出设置为 `1`，而所有其他输出都设置为 `0`。这个图是我们控制器逻辑的总蓝图 [@problem_id:1962029]。

#### 比特的语言：[状态分配](@article_id:351787)

物理电路不理解像 `Idle_At_Floor_1` 这样的标签。它只理解高低电压，我们用 `1` 和 `0` 来表示。下一步是**[状态分配](@article_id:351787)**：为每个[状态分配](@article_id:351787)一个唯一的二进制编码。这是一个设计选择，对于[时序电路](@article_id:346313)来说是根本性的要求，但对于其无记忆的[组合电路](@article_id:353734)同类来说则毫无意义 [@problem_id:1959247]。

对于我们有 6 个状态的电梯，我们至少需要 $\lceil \log_{2}(6) \rceil = 3$ 个比特来为每个状态提供唯一的编码。例如，`Idle_At_Floor_1` 可能变成 `000`，`Moving_Up` 变成 `001`，等等。这个选择会产生有趣的后果。用 3 个比特，我们有 $2^3 = 8$ 种可能的二进制编码，但我们只使用了 6 种。那两个未使用的编码，比如 `110` 和 `111`，怎么办呢？

#### “[无关项](@article_id:344644)”的礼物

这些未使用的状态码是工程师的礼物。由于机器在正常操作下永远不应进入这些状态，我们“不关心”如果它真的进入了，下一状态逻辑会产生什么。当我们使用像卡诺图（Karnaugh maps）这样的工具来简化我们的逻辑时，这些“[无关项](@article_id:344644)”（don't-cares）就像通配符。我们可以选择将它们视为 `0` 或 `1`——无论哪种选择[能带](@article_id:306995)来更简单、更小、更快的电路。这是一个在看似的限制中发现优势的美妙例子，将未定义的行为转化为优化的机会 [@problem_id:1961711]。

#### 机器的核心：逻辑方程

当状态被编码为比特后，FSM 就准备好进行最终的转换了。状态保存在一个由称为**[触发器](@article_id:353355)**（flip-flops）的存储元件组成的寄存器中。D 型[触发器](@article_id:353355)是最常见的；它在每个时钟滴答时简单地存储其 `D`（数据）输入上的值。因此，设计 FSM 的问题就简化为设计两个[组合逻辑](@article_id:328790)部分：
1.  **下一状态逻辑：**一个接收当前状态位和当前输入位，并计算*下一*状态二进制编码的电路。该逻辑的输出直接连接到状态[触发器](@article_id:353355)的 `D` 输入。
2.  **输出逻辑：**一个计算输出位的电路。对于 Moore 机，它仅取决于当前状态位。对于 Mealy 机，它同时取决于当前状态位和输入位。

通过分析[状态图](@article_id:323413)，我们可以构建一个完整的[真值表](@article_id:306106)，列出当前状态和输入的每一种可能组合所需的下一状态。从这个表中，我们为每个 `D` 输入推导出[布尔逻辑](@article_id:303811)方程，从而将我们的机器实现为由与门、或门和[非门](@article_id:348662)组成的网络 [@problem_id:1931290]。

### 琢玉成器：优化与可靠性

设计的初稿很少是最好的。正如作家会修改手稿一样，工程师也会为了效率和稳健性而优化电路。

#### [状态最小化](@article_id:336923)

在初始设计中，很容易创建出比必要状态更多的 FSM。例如，我们设计中的两个状态，从它们开始，对于任何可能的未来输入序列，其行为可能完全相同。这样的状态是**等效的**，保留两个是多余的。找到并合并这些等效状态的过程称为**[状态最小化](@article_id:336923)**。

这个过程的起点是识别那些明确*不等效*的状态。对于 Mealy 机来说，最基本且直观的测试是：如果两个状态 $S_i$ 和 $S_j$ 对于同一个输入产生不同的输出，那么它们不可能是等效的。这个简单的规则构成了系统地将状态划分为[等价类](@article_id:316440)的[算法](@article_id:331821)的基石，最终产生一个具有最小可能状态数的新 FSM，其行为与原始 FSM 完全相同 [@problem_id:1962533] [@problem_id:1942664]。

#### 构建自愈机器

如果我们的机器在像外太空这样的恶劣环境中运行，被宇宙射线击中，导致其[状态寄存器](@article_id:356409)中的一个比特翻转，会发生什么？一个 `0` 变成了 `1`，FSM 突然进入一个不正确、甚至可能是未使用的状态。其后果可能是灾难性的。

在这里，FSM 设计的原理与信息论完美地融合在一起。为了构建一个容错机器，我们可以用冗余来编码我们的状态位。一种简单而强大的技术是**[重复码](@article_id:330791)**。我们不将状态位 $Q_1$ 存储为单个比特，而是将其存储三次：$(C_5, C_4, C_3) = (Q_1, Q_1, Q_1)$。如果发生单个错误，比如说 $C_4$ 翻转了，存储的三元组就变成了 $(1, 0, 1)$ 而不是 $(1, 1, 1)$。在使用状态来计算下一状态之前，我们将其通过一个[纠错](@article_id:337457)电路。该电路实现了一个简单的**多数表决函数**。对于三元组 $(R_5, R_4, R_3)$，纠正后的比特 $Q_{1c}$ 由这个优雅的表达式给出：$Q_{1c} = R_5 R_4 + R_5 R_3 + R_4 R_3$。只要损坏的比特不超过一个，这个逻辑就能正确地恢复原始值。通过将此方法应用于每个状态位，我们创建了一个可以从单位比特错误中进行字面意义上“自愈”的 FSM，这证明了将简单逻辑与巧妙编码相结合以实现卓越弹性的强大力量 [@problem_id:1933127]。