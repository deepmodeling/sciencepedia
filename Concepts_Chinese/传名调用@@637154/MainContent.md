## 引言
在编程语言的领域中，函数接收其参数的方式——即其求值策略——是一个基础性决策，对性能、[表达能力](@entry_id:149863)和正确性有着深远的影响。尽管大多数程序员都熟悉[传值调用](@entry_id:753240)（即在[函数调用](@entry_id:753765)前计算参数），但还存在一种不同的[范式](@entry_id:161181)：传名调用。这种方法采用了一种计算上的“拖延症”，将参数的求值推迟到真正需要它的那一刻。本文深入探讨了这个强大但又充满风险的概念，旨在弥合日常编码实践与更深层次的[计算理论](@entry_id:273524)之间的知识鸿沟。

在第一部分“原理与机制”中，我们将剖析传名调用的核心机制，介绍“thunk”的概念，并探讨它如何在保护[词法作用域](@entry_id:637670)的同时，也带来了性能挑战以及副作用引发的意外行为。我们还将审视其精炼的后继者——[传需求调用](@entry_id:753237)，它在功能和效率之间提供了更实用的平衡。随后，在“应用与跨学科联系”部分，我们将[超越理论](@entry_id:203777)，观察这些原则在实践中的应用，从日常代码中熟悉的短路逻辑，到无限[数据结构](@entry_id:262134)的优雅构建，再到现代系统中管理并发的挑战。

## 原理与机制

在我们探索计算机如何执行指令的旅程中，很少有哪个想法像决定*何时*执行我们请求的工作这样，看似简单却又如此深刻。大多数时候，当我们调用一个函数，比如 `f(x)`，我们遵循一个直观的规则：首先，计算出 `x` 的值，然后将该值传递给 `f`。这被称为**[传值调用](@entry_id:753240)**，是大多数编程语言的主力。它简单、可预测，并且感觉就像世界本应如此运作。

但如果我们稍微“拖延”一下呢？如果我们不给 `f` `x` 的*值*，而是给它一个*承诺*——一个关于如何在以后（仅在真正需要时）计算 `x` 的配方呢？这就是**传名调用**背后的核心思想。它不仅仅是一个编程技巧，而是一种从根本上不同的计算思维方式，伴随着惊人的成本、隐藏的优雅以及对我们如何编写和推理代码的深刻影响。

### 包裹中的承诺：[Thunk](@entry_id:755964)

让我们将“承诺”这个想法具体化。计算机是如何将一个待执行的计算打包起来的呢？它使用一种巧妙的装置，称为**thunk**。你可以把 thunk 想象成一个密封的信封。信封里有两样关键物品：

1.  **表达式：** 代表我们想要传递的参数的一段代码。
2.  **环境：** 函数被调用那一刻的上下文快照——即所有相关变量的值。

这个包，即代码与其环境的配对，是**[闭包](@entry_id:148169)**的一种形式。当一个函数需要一个以传名方式传递的参数的值时，它找不到一个现成的值，而是找到了这个 thunk。为了得到这个值，它必须“强制”（force）执行这个 thunk，这意味着打开信封并在其捕获的环境中执行代码 [@problem_id:3675783]。

现在，传名调用的关键规则来了，正是这条规则让它如此有趣，有时又充满危险：每当参数被使用时，thunk 都会被再次强制执行。表达式会从头开始重新求值。它不记得上一次的结果，只是重新执行一遍指令。

### 拖延的代价：重复求值的双刃剑

你可能会想，“为什么要重新求值？那不是很浪费吗？”通常，答案是响亮的“是！”想象我们有一个计算成本高昂的函数，比如一个计算[斐波那契数](@entry_id:267966)的函数 `fib(k)`。现在，考虑一个做着简单事情的程序，比如将这个数字自身相加三次：`let x = fib(k) in x + x + x`。

在传名调用下，变量 `x` 绑定到 `fib(k)` 的一个 thunk。当表达式 `x + x + x` (求值方式为 `(x+x)+x`) 被计算时，会发生以下情况：
1.  为了得到第一个 `x`，计算机会强制执行 thunk，忠实地计算 `fib(k)`。
2.  为了得到第二个 `x`，它会*再次*强制执行 thunk，从头重新计算 `fib(k)`。
3.  为了得到第三个 `x`，它会*第三次*强制执行 thunk，再次计算 `fib(k)` [@problem_id:3649720]。

如果 `fib(k)` 是一个昂贵的操作，我们刚刚支付了三次代价，而常识告诉我们本应只支付一次。这种重复求值是传名调用的决定性性能特征 [@problem_id:3675809]。

这种代价不仅关乎性能，当涉及副作用时，它还可能导致令人费解的行为。**副作用**是任何修改其局部作用域之外状态的行为，比如写入文件、更改全局变量或在屏幕上打印。想象一个日志函数 `log("x")`，它向日志文件写入一行并返回值 `1`。

现在，考虑一个多次使用其参数的函数 `f(a,b)`，我们这样调用它：`f(log("x"), log("x"))`。在[传值调用](@entry_id:753240)下，参数在调用点被求值一次。`log("x")` 运行，我们得到一条日志条目，`a` 变成 `1`。第二个 `log("x")` 运行，我们得到第二条日志条目，`b` 变成 `1`。总日志条目：2 条。这是可预测的。

在传名调用下，`a` 和 `b` 是 `log("x")` 的 thunk。如果 `f` 的函数体使用了 `a` 三次，`b` 两次，那么 `log("x")` 函数总共将被调用五次！[@problem_id:3661444]。对 `f` 的一次看似无害的调用导致了五条独立的日志条目。这种行为可能是灾难性的。如果参数表达式不是记录一条消息，而是，比如说，发射导弹或转账，其重复、非预期的执行可能是灾难性的 [@problem_id:3661477]。这也揭示了幼稚的[编译器优化](@entry_id:747548)，比如试图对一个有副作用的参数求值一次并重用其值，会如何从根本上破坏传名调用的语义并产生错误的结果 [@problem_id:3661472]。传名调用的契约保证了重新求值，无论好坏。

### 意义的守护者：[词法作用域](@entry_id:637670)

到目前为止，传名调用看起来像是慢速和充满错误的程序的配方。那么这个想法当初为何会产生呢？它的真正目的不仅仅是[延迟计算](@entry_id:755964)，而是为了保留*意义*。它是正确实现现代编程语言最基本原则之一——**[词法作用域](@entry_id:637670)**——的强大机制。

[词法作用域](@entry_id:637670)规定，变量的含义由其在源代码中书写的位置决定，而不是由程序的执行方式决定。变量绑定到定义它的最近的封闭函数或块。

让我们看看一个幼稚的[延迟求值](@entry_id:751191)方法是如何破坏这个规则的。你可能会想，“何必用 thunk 呢？在用传名方式传递参数时，为什么不像宏一样只做一个简单的查找和替换？”让我们看看会发生什么。

考虑这个程序片段：
```
let y = 1 in (lambda x. let y = 2 in x + y) (y)
```

在这里，我们定义了一个变量 `y` 为 `1`。然后，我们用这个 `y` 作为参数调用一个匿名函数（`lambda`）。在函数内部，有另一个同名的局部变量 `y`，其值被设为 `2`。函数体将其参数 `x` 与这个局部的 `y` 相加。

如果我们使用幼稚的文本替换，我们会将函数体 `x + y` 中的 `x` 替换为参数文本 `y`。这会得到新的函数体 `y + y`。当它在函数内部求值时，两个 `y` 都会引用*局部*定义，即 `y=2`。结果将是 $2 + 2 = 4$ [@problem_id:3661456]。

这是错误的！我们传入的参数 `y` 来自*外部*作用域，其值为 `1`。它应该保留那个含义。幼稚的替换使得参数的[自由变量](@entry_id:151663) `y` 被内部的 `let y = 2` 绑定符“捕获”，从而破坏了它的含义。

这就是 thunk 成为英雄的地方。当我们传递参数 `y` 时，我们创建了一个 thunk：$\langle \text{expression: } y, \text{environment: caller's scope where } y \mapsto 1 \rangle$。在函数内部，当 `x` 被求值时，这个 thunk 被强制执行。它在其保存的环境中对表达式 `y` 求值，正确地检索到值 `1`。`x + y` 中的另一个 `y` 在函数的局部作用域中查找，正确地找到 `2`。最终结果是 $1 + 2 = 3$ [@problem_id:3675848]。

thunk 充当了一个盾牌。它封装了参数及其原始上下文，保护它不受其最终求值环境的影响。这确保了[词法作用域](@entry_id:637670)得到尊重，这是可预测、可维护代码的基石。

### 驯服野兽：从传名调用到[传需求调用](@entry_id:753237)

我们已经看到，传名调用在语义上是优雅的，但在计算上可能是残酷的。有没有一种方法可以在不付出代价的情况下获得其好处？这就是**[传需求调用](@entry_id:753237)**（也因**[惰性求值](@entry_id:751191)**而闻名）登场的地方。

[传需求调用](@entry_id:753237)是对传名调用的一个简单而绝妙的改进。它遵循使用 thunk [延迟求值](@entry_id:751191)的相同原则。然而，它增加了一条关键规则：**[记忆化](@entry_id:634518)**（memoization）。

1.  当参数第一次被需要时，它的 thunk被强制执行，并计算出结果。
2.  这个结果随后被存储，或称“[记忆化](@entry_id:634518)”，在 thunk 内部，取代了原始表达式。
3.  在之后所有对该参数的使用中，计算机只需返回存储的结果，而无需任何重新求值。

回到我们的 `x + x + x` 例子，其中 `x` 是 `fib(k)`，[传需求调用](@entry_id:753237)将只求值 `fib(k)` 一次——在第一次使用 `x` 时。结果被保存下来，接下来的两次 `x` 的使用会立即得到这个缓存的值 [@problem_id:3649720]。同样，在我们有副作用的 `log("x")` 例子中，[传需求调用](@entry_id:753237)将只在参数第一次使用时调用 `log`，从而防止了副作用的倍增 [@problem_id:3661477]。它让我们两全其美：既有传名调用的语义安全和[延迟求值](@entry_id:751191)，又有[传值调用](@entry_id:753240)的性能和可预测性。

### 实现的更深层次问题

thunk 的概念，这个简单的代码和环境的包，其影响会波及整个编译器和[运行时系统](@entry_id:754463)的架构。一个特别棘手的问题是“向上 funarg 问题”（upward funarg problem）。如果一个 thunk（它包含一个指向程序执行栈上其环境的指针）被存储在一个全局变量中会发生什么？创建该 thunk 的函数可能已经结束，其栈帧也可能被擦除。稍后，如果程序的另一部分试图强制执行这个“逃逸”的 thunk，它将跟随一个指向现已是垃圾数据的地址的指针——这是一个经典的悬空指针错误。

解决这个问题需要复杂的工程技术。编译器必须执行**[逃逸分析](@entry_id:749089)**，以检测 thunk 是否可能比其环境活得更久。如果是这样，它必须安排将环境（或至少是 thunk 需要的部分）分配在**堆**上——一个在[函数调用](@entry_id:753765)之间持久存在的内存区域——而不是短暂的栈上。这确保了 thunk 的环境始终有效，无论 thunk 存活多久或被传递到何处 [@problem_id:3675797]。

从一个简单的“稍后执行”的想法出发，传名调用带我们领略了计算成本、副作用、[词法作用域](@entry_id:637670)的神圣性以及内存管理的深层挑战。它是一个绝佳的例子，说明了语言设计中的一个单一决策如何在系统的每一层中回响，提醒我们在计算的世界里，表面之下总隐藏着引人入胜的故事。

