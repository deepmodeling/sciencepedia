## 引言
您如何能确定，从电脑开机的那一刻起，其上运行的软件就是真实可信的，并且没有被隐蔽的底层恶意软件所侵害？这个关于数字信任的根本性问题，是现代计算机安全的核心。传统的杀毒软件是不够的，因为一个老练的攻击者可以在[操作系统](@entry_id:752937)加载之前就将其攻破。解决方案是一个强大的、以硬件为锚点的程序，即[安全启动](@entry_id:754616)过程，它从芯片层面开始构建一条可验证的完整性链。

本文将对这项基础安全技术进行全面探讨。首先，在“原理和机制”一章中，我们将剖析使[安全启动](@entry_id:754616)成为可能的核心密码学概念，从不可变的[信任根](@entry_id:754420)到验证每一步的[数字签名](@entry_id:269311)链。我们将区分[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)，并探讨系统如何防御巧妙的攻击。接着，在“应用与跨学科联系”一章中，我们将了解这些原理在现实世界中如何应用于保护从个人笔记本电脑、汽车到庞大的云计算基础设施的方方面面，从而在一个零信任的世界中建立信任基础。

## 原理和机制

您如何能确定，您刚刚打开的计算机*真正*是您的计算机？不仅仅是物理的盒子，还有机器的灵魂——内部运行的软件。您如何知道没有某些微小的恶魔已经钻入其核心，从电源灯亮起的那一刻起就等着监视您的一举一动？这不是偏执的幻想，而是计算机安全领域最深刻的挑战之一。答案是一个以非凡的优雅和逻辑著称的过程，即**[安全启动](@entry_id:754616)**。这是一段信任之旅，信任的链条一环扣一环地锻造而成，始于一块因其本质而不可改变的硅片。

### 不可破坏的封印：[信任根](@entry_id:754420)

想象一下，您收到一份皇家法令。您相信它来自国王，因为它盖有他独特而复杂的蜡封。但这只有在您已经知道国王真正的印章是什么样子，并且您绝对信任这一知识的情况下才行得通。在计算世界中，我们需要一个类似的、无可指摘的起点。我们需要一个**[信任根](@entry_id:754420)**。

这个根不能是硬盘上可以被修改的普通软件。它必须是某种基础且不可变的东西。在现代芯片上，这个角色由一小段直接蚀刻在**[只读存储器](@entry_id:175074) (ROM)** 硅片上的代码扮演。这段**引导 ROM** 代码在制造过程中被“烘焙”进去。任何软件，无论是恶意的还是其他的，都无法擦除或覆盖它。它是计算机最原始的真理，是处理器从冷启动中唤醒时将执行的第一条可信指令。这个不可变的模块就是我们的数字“国王印章”，是后续一切的锚点 [@problem_id:3664845] [@problem_id:3645382]。

### 打造[信任链](@entry_id:747264)

启动计算机不是单一事件，而是一个序列。简单的引导 ROM 加载更复杂的固件（如今天常见的 UEFI 系统），固件再找到并加载[操作系统](@entry_id:752937) (OS) 内核。这是一场软件组件的接力赛。但我们如何确保没有人将合法的选手换成恶意的冒名顶替者呢？

答案是一条简单而强大的规则：**先验证，后执行**。在任何新的软件片段被赋予机器控制权之前，当前运行的可信软件必须首先为其完整性和真实性作担保。这就创建了一条**[信任链](@entry_id:747264)**。

要执行此检查，我们需要两个[密码学](@entry_id:139166)工具：

-   **加密哈希（数字指纹）：** 一个加密哈希函数，我们称之为 $H(\cdot)$，是一种数学算法，它接收任意大小的文件，并计算出一个小的、固定大小的字符串，即其“哈希”或“摘要”。这个哈希就像一个独特的指纹。如果您更改原始文件中的哪怕一个比特——将一个 0 翻转为 1——产生的哈希也会以不可预测的方式完全改变。因此，通过重新计算一个文件的哈希并将其与一个已知的良好值进行比较，我们可以以近乎完美的确定性验证其**完整性**。

-   **[数字签名](@entry_id:269311)（不可伪造的印章）：** 哈希告诉你文件是否被*更改*，但不能告诉你它*来自*谁。为此，我们使用基于**非对称密码学**的[数字签名](@entry_id:269311)。软件供应商，如 Microsoft 或 Apple，会生成一对密钥：一个**私钥**（他们会用生命来守护），以及一个**公钥**（他们会自由分发）。他们通过获取其软件的哈希值并用其私钥加密来“签名”其软件。这个签名与软件捆绑在一起。

现在，让我们把它们整合起来。不可变的引导 ROM 包含供应商的公钥 ($K_{\text{pub}}$)。当计算机开启时，ROM 代码会执行以下流程 [@problem_id:3664845]：

1.  它从存储中加载下一阶段的软件——比如说，UEFI 固件。
2.  它计算这个固件的哈希值：$h_1 = H(\text{firmware})$。
3.  它使用存储在自己 ROM 中的公钥来解密固件附带的签名。这揭示了供应商计算的原始哈希值。
4.  它比较这两个哈希值。如果它们匹配，就证明了两件事：固件没有被篡改（完整性），并且它确实来自持有私钥的供应商（真实性）。
5.  只有在检查通过后，ROM 才会将控制权移交给固件。

现在受信任的固件，对下一阶段——[操作系统](@entry_id:752937)[引导加载程序](@entry_id:746922)，重复完全相同的过程，而[引导加载程序](@entry_id:746922)又会验证操作系统内核。链中的每一环在传递接力棒之前都会以加密方式验证下一环。在某些系统上，这甚至在[微架构](@entry_id:751960)层面被强制执行。一个特殊的硬件开关，我们称之为 `fetch_en` 位，可以在物理上阻止处理器的指令提取单元在验证完成前从不受信任的内存中*读取*代码 [@problem_id:3645382]。这是一座数字吊桥，在新来者的凭证被彻底检查之前，它会一直保持升起状态。整个过程当然需要时间，而哈希引导镜像的速度通常是决定您等待计算机启动时间的瓶颈 [@problem_id:3684409]。

### 为何简单的校验还不够：奇偶校验的教训

您可能会想，所有这些[密码学](@entry_id:139166)的复杂性真的有必要吗？更简单的检查方法怎么样？几十年来，计算机一直使用**[奇偶校验位](@entry_id:170898)**来检测内存中的错误。[奇偶校验位](@entry_id:170898)是添加到一块数据中的一个额外位，指示该数据中 1 的数量是偶数还是奇数。如果一个随机的宇宙射线在传输过程中翻转了一个位，奇偶性将不再匹配，错误就会被检测到。

为什么我们不能就用这个来进行[安全启动](@entry_id:754616)呢？让我们想象一下，我们在安全 ROM 中存储了[引导加载程序](@entry_id:746922)每个块的正确奇偶校验值。在启动时，我们重新计算奇偶校验值并进行检查。这将保护我们免受随机噪声的影响。但我们对抗的不是噪声，而是一个智能的**对手**。

攻击者可以修改[引导加载程序](@entry_id:746922)代码以插入他们的恶意软件。这很可能会改变奇偶性。但攻击者随后可以简单地在同一块中的其他地方翻转*另*一个任意位。两个位的翻转恢复了原始的奇偶性！现在，这个包含偶数个错误的更改，对于[奇偶校验](@entry_id:165765)来说是完全不可见的。攻击者制造了一个恶意文件，在我们简单的检查看来是完全有效的。

这精妙地说明了**[纠错码](@entry_id:153794)**（如奇偶校验）和**加密[哈希函数](@entry_id:636237)**之间的区别。加密哈希被设计为**抗碰撞的**，这意味着对于攻击者来说，在计算上不可能有意创建一个与合法文件具有相同哈希值的恶意文件 [@problem_id:3640151]。这种稳健性不是一种奢侈品，它是软件安全的绝对基础。

### 来自过去的敌人：抵御回滚攻击

那么，我们的[信任链](@entry_id:747264)验证了每个软件组件都是真实的，并且没有被篡改。我们安全了吗？不完全是。如果攻击者不是试图伪造新软件，而是用一个旧版本替换您那崭新、打满补丁的[操作系统](@entry_id:752937)——一个多年前由供应商合法签名，但现在已知存在严重安全漏洞的版本呢？签名是完全有效的。[信任链](@entry_id:747264)会检查通过，而您将在不知不觉中启动一个易受攻击的系统。

这被称为**回滚攻击**。为了抵御它，我们的[安全启动](@entry_id:754616)过程不仅需要检查真实性，还需要检查*时效性*。这通过另外两个组件来完成：每个签名的软件都被赋予一个**版本号**，并且计算机芯片包含一个称为**单调计数器**的特殊硬件。

单调计数器就像汽车的里程表：它只能增加（或保持不变）；它永远不能回滚到更低的数字。当一个新的软件组件被验证时，引导代码会检查它的版本号 $v_i$ 是否大于或等于当前存储在单调计数器中的版本。如果检查通过，系统就会将计数器更新为 $v_i$。这确保了没有人能够欺骗系统加载一个比它所见过的最新版本更旧的软件版本 [@problem_id:3664845]。

### [安全启动](@entry_id:754616)与[度量启动](@entry_id:751820)：保镖与公证人

到目前为止我们描述的过程通常被称为**[安全启动](@entry_id:754616)**。它是一种*强制执行*的策略。如果链中的任何组件无效——签名错误、哈希值不符、版本过旧——启动过程就会停止。它就像俱乐部里的保镖，检查身份证件，拒绝任何不在名单上的人。

但还有一个相辅相成的、同样强大的概念，叫做**[度量启动](@entry_id:751820)**。与其仅仅阻止不良行为者，我们是否也可以 meticulous地、不可伪造地记录下*所有*加载的东西，无论它是好的、坏的，还是仅仅是意料之外的？

这是**[可信平台模块 (TPM)](@entry_id:756205)** 的工作，它是主板上的一个专用安全协处理器。[TPM](@entry_id:170576) 包含一组称为**平台配置寄存器 (PCR)** 的特殊寄存器。您不能简单地向 PCR 中写入一个值。您只能执行**扩展 (extend)** 操作。此操作获取 PCR 的当前值，将其与新数据（一次“度量”）连接起来，然后对结果进行哈希以生成新的 PCR 值：
$$PCR_{\text{new}} \leftarrow H(PCR_{\text{old}} \parallel \text{measurement})$$

由于加密哈希的特性，这个过程是单向的。最终的 PCR 值是扩展到其中的所有度量的精确序列的唯一签名，并且顺序也完全一致。您无法撤销一个步骤或在中间插入一个步骤而不改变最终结果 [@problem_id:3628964]。

在[度量启动](@entry_id:751820)期间，启动过程的每个阶段——从引导 ROM 开始——在执行下一个阶段之前都会对其进行度量（通过哈希），并将该度量扩展到一个 PCR 中。结果是一份可加密验证的、完整的引导链记录。

这个区别通过一个实际例子变得清晰。想象一个攻击者修改了内核的引导配置——例如，一个禁用了关键安全功能的命令行选项。[安全启动](@entry_id:754616)，在其最常见的形式下，可能不会阻止这个。内核的*代码*没有改变，所以它的签名仍然有效。配置只是传递给它的数据。[安全启动](@entry_id:754616)这个保镖会让它进来。

然而，[度量启动](@entry_id:751820)就像一个公证人。[引导加载程序](@entry_id:746922)被配置为不仅度量内核代码，还度量命令行字符串。由于命令行已更改，度量结果将会不同，最终的 PCR 值也会不同。这一变化被不可磨灭地记录下来。虽然机器启动了，但执行**[远程证明](@entry_id:754241)**的远程服务器可以向 TPM 请求 PCR 值。当服务器看到该值与安全配置系统的“黄金”值不匹配时，它就知道该机器已偏离其可信状态，并可以阻止它访问网络 [@problemid:3679609] [@problem_id:3679557]。[安全启动](@entry_id:754616)对可执行代码*强制执行*策略；[度量启动](@entry_id:751820)为系统的状态（包括代码和配置）*提供证据*。

### 从信任到操作：向[操作系统](@entry_id:752937)交接

[信任链](@entry_id:747264)已成功验证了操作系统内核。[引导加载程序](@entry_id:746922)的最后一项任务是将控制权交给它。但这是一个至关重要的时刻。整个引导过程一直运行在处理器[最高权](@entry_id:202808)限模式下，可以无限制地访问所有硬件。而[操作系统](@entry_id:752937)，尤其是用户应用程序，必须在低得多的权限下运行。

[引导加载程序](@entry_id:746922)的最后一项工作是为[操作系统](@entry_id:752937)建立一个安全和受保护的环境。它遵循**[最小权限原则](@entry_id:753740)**。在进行跳转之前，它会配置处理器的**[内存管理单元 (MMU)](@entry_id:751869)**。它创建一个[内存映射](@entry_id:175224)——[页表](@entry_id:753080)——来定义交通规则。代码区域被标记为只读和可执行。数据区域（如堆栈和堆）被标记为可读写，但关键的是，**不可执行 (NX)**。这个小小的 NX 位是一项强大的防御措施，因为它能阻止一大类涉及欺骗程序执行攻击者提供的恶意数据的攻击。

这个顺序对于避免**检查时到使用时 ([TOCTOU](@entry_id:756027))** 的竞态条件至关重要。在仍处于最高权限模式时，[引导加载程序](@entry_id:746922)必须：
1.  暂时禁用所有外部中断（如来自外围设备的中断）。
2.  设置完整、安全的[内存映射](@entry_id:175224)。
3.  启用 MMU，激活所有这些保护措施。
4.  *只有这样*，它才会降低处理器的权限级别，并跳转到操作系统内核的入口点。

这确保了内核在运行时绝不会有哪怕一微秒的时间没有其[内存保护](@entry_id:751877)盔甲完全就位 [@problem_id:3673061]。

### 信任的局限：当根基出现裂痕

[安全启动](@entry_id:754616)过程是一个宏伟的信任架构，但它并非万无一失。它的安全性完全依赖于其最早环节的完整性。如果锚点本身——固件——被攻破了会发生什么？

感染 UEFI 固件的恶意软件被称为 **bootkit**。即使您完全重装[操作系统](@entry_id:752937)或更换硬盘，这类恶意软件也能持续存在，因为它存在于主板上的一个芯片中 [@problem_id:3673354]。被攻破的固件可以破坏整个[信任链](@entry_id:747264)。它可以撒谎。它可以向 [TPM](@entry_id:170576) 呈现一个良好内核的有效度量值，但随后却将一个恶意的内核加载到内存中。如果进行度量的主体本身不可信，那么度量值本身也就毫无价值 [@problem_id:3673354] [@problem_id:3688014]。

安全永远是一条链，它的强度取决于其最薄弱的一环。[安全启动](@entry_id:754616)过程证明了，要锻造一条从第一束电流火花开始就坚固无比的链条，需要付出巨大的努力，从而创建一个信任的基础，整个复杂的现代计算世界都可以在其上构建。

