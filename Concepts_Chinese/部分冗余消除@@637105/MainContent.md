## 引言
在对更快软件的不懈追求中，[编译器优化](@entry_id:747548)是默默无闻的英雄，它们一丝不苟地优化代码，以消除浪费性能的操作。虽然简单的技术可以移除明显的重复工作，但面对复杂的程序结构时，它们往往力不从心，导致显著的性能提升空间未能被利用。部分冗余消除（Partial Redundancy Elimination, PRE）这一更复杂、更强大的策略正是为了解决这一问题。本文将深入探讨 PRE 的优雅世界，这项技术不仅能发现冗余，还会主动地重排代码，为优化创造更多机会。首先，在“原理与机制”部分，我们将剖析赋予编译器“远见”的核心[数据流](@entry_id:748201)分析——可用性分析和预期性分析。随后，在“应用与跨学科联系”部分，我们将探讨 PRE 如何统一众多其他优化，以及其基本理念如何延伸至区块链和 Web 浏览器等不同领域，揭示出一种高效[系统设计](@entry_id:755777)的普适模式。

## 原理与机制

想象你是一位一丝不苟的记账员，发现自己一遍又一遍地对同一列数字求和。你的常识会告诉你，第一次计算后就应该写下结果，然后直接复用。这个简单而强大的想法是许多[编译器优化](@entry_id:747548)的灵魂。编译器在力求让我们的程序运行得更快的过程中，总是在寻找可以不必做的工作。

### 不做功的艺术：洞见冗余

最直接的情况是**[公共子表达式消除](@entry_id:747511)（Common Subexpression Elimination, CSE）**。如果编译器看到 `$x := a + b$`，稍后又看到 `$y := a + b$`，它通常可以直接将第二条指令重写为 `$y := x$`，从而避免一次冗余计算。但如果情况更复杂呢？

考虑程序中的一个岔路，一个简单的 `if-else` 语句。在 `then` 分支，你计算了 `$a + b$`。在 `else` 分支，你也计算了 `$a + b$`。在两个分支重新汇合后，编译器可能会发现*另一次*对 `$a + b$` 的计算。我们的直觉强烈地感觉到这是浪费。无论走哪条路径，我们都在做同样的工作。为什么不在岔路之前就算好一次 `$a + b$` 呢？

这正是简单的 CSE 常常力有不逮之处。在许多经典设计中，要消除一个后来的计算，它必须被一个更早的计算所*支配*（dominate），这意味着在通往后来计算的每一条可能路径上，更早的那个计算都保证已经运行过。在我们的 `if-else` 例子中，`then` 分支中的计算并不支配 `else` 分支中的计算，反之亦然。它们位于平行的“时间线”上。

正是这类难题引导我们走向一个更深刻、更优美的思想：**部分冗余消除（Partial Redundancy Elimination, PRE）**。PRE 是一种具有远见的优化。它不仅审视*已经*做了什么，还主动地推断*将要*做什么，并且不畏于重排程序以创造更多优化机会。例如，它可以像我们的直觉所建议的那样，将 `$a + b$` 的计算提升到 `if-else` 分支之前 [@problem_id:3643953]。PRE 将一个仅*部分*冗余的计算——在某些路径上冗余，但在其他路径上不冗余——转化为一个*完全*冗余的计算，从而可以被轻易消除。

### 远见的两大支柱：可用性与预期性

编译器如何培养出这种远见？它不能仅仅“感觉”到某个计算是浪费的。它需要一种严谨的方法。这种方法就是**[数据流](@entry_id:748201)分析（data-flow analysis）**，一种优美的技术，它让编译器能够系统地推断程序的属性。对于 PRE，这种分析建立在两个优雅而对立的支柱之上。

#### 支柱一：通过前向分析回望过去（可用性）

首先，编译器审视过去。在程序的任何给定点，它会问：“在通往此点的**每一条路径**上，有哪些表达式*保证*已经被计算过，并且其操作数未曾改变？” 这被称为**[可用表达式分析](@entry_id:746601)（Available Expressions analysis）**。这是一种**前向分析（forward analysis）**，因为信息“流动”的方向与程序执行的方向相同。如果基本块 $A$ 计算了 `$a + b$`，该信息会向前流动到它的后继节点。如果来自基本块 $A$ 和基本块 $B$ 的路径汇合，只有当该表达式在*两条*路径上都可用时，才认为它在[汇合](@entry_id:148680)点之后可用 [@problem_id:3622952]。这是一个严格的“全路径”要求。

#### 支柱二：通过[后向分析](@entry_id:746642)展望未来（预期性）

第二个支柱提供了远见的关键要素。在任何给定点，编译器会展望未来并提问：“从这里开始，是否*保证*表达式 `$a + b$` 会在**每一条可能采取的路径**上，在其操作数 $a$ 或 $b$ 被改变之前，**被计算**？” 这个属性被称为**预期性（anticipatability）**（或在某些文献中称为**十分繁忙表达式 (very busy expressions)**）[@problem_id:3682371]。这是一种**[后向分析](@entry_id:746642)（backward analysis）**。对未来计算的需求向后传递信号，逆着程序执行流的方向。如果一个 `if-else` 语句的两个分支最终都会计算 `$a + b$`，那么在 `if` 语句开始之前，该表达式就被认为是可预期的。

这告诉编译器，提早进行计算是*安全*的。如果你无论如何都要做这项工作，早点做并不会改变结果（假设该工作没有副作用），但可能会让你免于多次重复。

PRE 的精妙之处在于这两种相反分析的相互作用 [@problem_id:3642734]。算法寻找程序中某个表达式**可预期**（未来需要它）但尚不**可用**（它没有在所有先前的路径上都被计算过）的点。这正是部分冗余的定义。接下来的策略异常简单：在缺失该计算的路径上插入它。这使得表达式变为完全可用，将部分冗余转化为完全冗余，然后就可以毫不犹豫地将其消除。

### 编译器如棋手：策略在行动

让我们观察这一策略的展开。在一个程序中，如果 `$a+b$` 在 `if` 的一个分支中需要，但在另一个分支中不需要，然后在它们汇合后又需要一次，那么汇合后的计算就是部分冗余的 [@problem_id:3622952]。编译器在完成分析后，看到 `$a+b$` 在缺少它的那条路径上是可预期的。就像棋手走一步准备棋一样，它将 `$a+b$` 的计算插入到那个“空”分支中。突然之间，`$a+b$` 在所有通往[汇合](@entry_id:148680)点的路径上都变得可用。曾经部分冗余的计算现在变成了完全冗余，编译器便将其移除。

但一个优秀的棋手看到的不仅是显而易见的棋步。如果冗余的表达式被伪装起来了呢？程序可能在一个地方计算 `$a + c$`，在另一个地方计算 `$b + a$`，而实际上 `$c$` 只是 `$b$` 的一个副本。简单的文本比较无法发现冗余。但更复杂的分析，如**[全局值编号](@entry_id:749934)（Global Value Numbering, GVN）**，能够看穿这种伪装 [@problem_id:3681969]。GVN 为程序中每个不同的值分配一个唯一的“[值编号](@entry_id:756409)”。它理解 `$+$` 是可交换的，并且 `$c$` 和 `$b$` 持有相同的值。因此，它能识别出 `$a+c$` 和 `$b+a$` 实际上是相同的计算。这使得 PRE 能够在一个更深的语义层面上运作，将不同形式的冗余统一到一个强大框架中 [@problem_id:3661915]。

### 驾驭现实世界：技巧与约束

到目前为止，我们的世界是纯粹的算术世界。但真实的程序是混乱的。它们有副作用，会引发异常，还包含复杂的循环。一个真正 masterful 的优化器必须小心翼翼地驾驭这个世界。

#### 异常的雷区

考虑一个看似无害的除法 `$z/w$`。如果移动它，这可能是一颗定时炸弹。如果 `$w$` 恰好为零，原始代码可能在一个 `try-catch` 块内捕获了由此产生的异常。如果我们把这个除法提升到 `try` 块之外，异常现在就会在一个没有被捕获的地方发生，从而使程序崩溃。这对编译器来说是一个根本性的错误：它改变了程序的可观察行为。

解决方案是所需谨慎操作的绝佳示范。编译器不会盲目地移动 `$z/w$`，而是可以*有条件地*移动它 [@problem_id:3661890]。在 `try` 块之前，它可以插入 `if (w != 0) t := z/w;`。这只在安全的情况下预先计算结果。然后，在 `try` 块内部，它用一个检查替换原来的除法：如果 `$w$` 不为零，就使用预先计算的值 $t$；否则，再次执行 `$z/w$`。第二次执行看似多余，但这是一个巧妙的佯动。它被放在那里，正是为了在原始程序会触发异常的精确时刻重新触发它，从而完美地保留程序的行为。

#### 副作用的束缚

对于有**副作用**的操作，也必须同样小心。考虑短路表达式 `x  y`。如果 `$x$` 有副作用（比如向屏幕打印信息）并且其值为 false，原始程序将永远不会求值 `$y$`。我们不能不考虑 `$x$` 的情况就简单地优化 `$y$`。解决方案是让隐藏的依赖关系显式化。编译器可以创建一个新的布尔“卫兵”变量 $g$，只有当 `$x$` 被求值并且结果为 true 时，$g$ 才被设为 true。现在，对 `$y$` 的计算就由 $g$ 明确地守护。这将程序的*[控制依赖](@entry_id:747830)*（执行流程）转化为了*[数据依赖](@entry_id:748197)*（对 $g$ 值的依赖）。一旦条件被捕获在一个变量中，被守护的 `$y$` 的计算就可以像任何其他表达式一样被优化 [@problem_id:3661849]。

#### 循环、[不变量](@entry_id:148850)和调试器

在循环中，PRE 必须与其他优化协同工作。它可能会发现像 `$L(A[i])$` 这样的表达式（从数组中加载）在单次迭代*内部*是冗余的。它可以消除这种冗余。但它也必须认识到 `$L(A[i])$` 不是**循环不变的**——它的值随着索引 `$i$` 的变化而变化——因此它不能被完全提升到循环之外 [@problem_id:3653165]。

最后，编译器的工作不是在真空中完成的。它编写的程序可能有一天需要人类来调试。如果 PRE 将一个计算从第 50 行移到第 20 行，那么在第 50 行设置断点的程序员会感到完全困惑。一个现代的、**支持调试（debug-aware）** 的编译器知道这一点。它将源代码行视为软性障碍，倾向于不以会违反程序员心智模型的方式移动代码。当必须这样做时，它会生成一个丰富的映射（使用像 DWARF 这样的格式），作为调试器的指南，告知：“我知道源代码说这个值是在第 50 行计算的，但在我的优化版本中，你可以在这个寄存器中找到它的结果，这个结果是在第 20 行计算的” [@problem_id:3628509]。这是一种协定，是在对机器性能不懈追求与人类对理解的基本需求之间的妥协。

从一个避免重复工作的简单想法出发，我们穿行于优雅的算法、对偶分析以及真实世界代码的 messy 现实。部分冗余消除不仅仅是一项优化；它是一种思维模式，一种洞察程序隐藏结构和潜力的方式，也是现代编译器中蕴含的宁静而优美的智能的证明。

