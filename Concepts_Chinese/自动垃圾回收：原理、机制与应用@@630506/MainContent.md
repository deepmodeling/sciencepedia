## 引言
[自动内存管理](@entry_id:746589)，或称垃圾回收（garbage collection），是现代高级编程语言的基石，它将开发者从手动分配和释放内存这一易错的任务中解放出来。虽然这种抽象简化了软件开发，但其背后隐藏着一个充满精妙工程设计和复杂权衡的世界。其根本挑战在于，系统如何能够在不干扰应用程序的情况下，自动区分有用数据与“垃圾”，并高效地回收资源。本文旨在揭开自动垃圾回收的神秘面纱，为程序员、[编译器设计](@entry_id:271989)者和系统架构师提供一个全面的概述。第一章“原理与机制”将探讨核心算法，从基础的[标记-清除](@entry_id:633975)（Mark-and-Sweep）和引用计数（Reference Counting），到高级的分代（Generational）和并发回收（Concurrent collection）技术。随后，“应用与跨学科联系”一章将审视[垃圾回收](@entry_id:637325)对软件设计模式、[编译器优化](@entry_id:747548)（如[逃逸分析](@entry_id:749089)）以及高性能系统架构的深远影响。

## 原理与机制

要理解机器如何管理自身内存，我们必须先问一个听起来很哲学化的简单问题：什么是垃圾？在计算机程序的世界里，内存中充满了“对象”——承载信息的[数据块](@entry_id:748187)。这些对象通过“指针”相互连接，如同关系之线，形成一张巨大而复杂的网络。一个对象只有在程序能找到通往它的路径时才是有用的，即**存活的**（live）。如果一个对象变成了孤岛，与程序活动数据的主大陆完全隔绝，那么它就是**垃圾**（garbage）。

因此，我们的任务与其说是寻找垃圾，不如说是寻找宝藏。垃圾就是所有剩余的东西。

### 伟大的追踪：寻找存活对象

最基础的[垃圾回收](@entry_id:637325)方法是描绘出存活对象的网络。这个发现之旅总是从一组已知的起点开始，称为**根集合**（root set）。这些根是程序可以直接访问的指针——存储在 CPU 寄存器、程序执行栈（用于追踪活跃的[函数调用](@entry_id:753765)）或作为全局变量的引用。从这些根出发，我们就可以开始伟大的追踪。

想象内存堆是一个图，其中对象是节点，指针是有向边 [@problem_id:3218436]。回收器的第一步是**标记阶段**（mark phase）：从每个根开始，它跟随每一个指针，再从那里跟随每一个指针，如此反复，在它访问的每个对象上都做一个比喻性的“标记”。它使用类似[广度优先搜索](@entry_id:156630)的方法遍历图，直到访问完所有从根可达的对象。当这个过程完成时，堆中所有存活的对象都已被标记。

接下来是**清除阶段**（sweep phase）。回收器从头到尾扫描整个堆。任何没有标记的对象都是不可达的——也就是垃圾。回收器回收这部分内存，使其可用于创建新对象。这个优雅的两步过程被称为**[标记-清除](@entry_id:633975)**（Mark-and-Sweep）。它保证了任何存活的对象都不会被错误地丢弃，但这需要付出代价。在回收器工作时，程序必须完全暂停——这是一个“stop-the-world”（全局暂停）事件。此外，清除之后，可用内存常常被分割成许多不连续的小洞，就像一片瑞士奶酪。这使得分配一个大的新对象变得困难。

### 另一种哲学：计算你的朋友

有没有办法避免这些干扰性的暂停呢？一种完全不同的哲学是**引用计数**（reference counting）。这个想法非常简单且局部化。它不进行[全局搜索](@entry_id:172339)，而是让每个对象维护一个指向它的指针数量的计数器——即它的“引用计数”。当一个指向某对象的新指针被创建时，其计数器加一。当一个指针被销毁时，计数器减一。如果一个对象的计数器降至零，就意味着再也没有指针指向它了。它没有朋友了；它是垃圾，可以被立即回收。

这种方法提供了一个美妙的优势，即它是增量式的。垃圾一经产生就能被回收，以微小、不易察觉的步骤进行，而不是在一次长时间的暂停中一次性完成。但这种简单的美背后隐藏着一个致命的缺陷：**循环引用**（cycles）。想象两个对象互相指向对方，但外界没有任何东西指向它们中的任何一个。每个对象的引用计数都是一，所以系统认为它们都是存活的。它们是一个孤立的社会，靠着相互欣赏而存活，但对程序的其余部分毫无用处。

处理这些循环引用需要更复杂的技术。一种方法是定期运行一个[循环检测](@entry_id:751473)器，对一组可疑对象执行“试验性删除” [@problem_id:3236414]。它假设性地忽略该组内部的引用，并重新计算引用计数。如果计数降至零，那么整个循环确实是垃圾，可以被回收。

### 移动的艺术：复制的力量

让我们回到追踪式回收器和碎片化的问题。一个激进且强大的解决方案是**复制回收**（copying collection）。与其清理当前的工作空间，不如把我们需要的一切都搬到一个全新的空间里去？

在这种方案中，堆被分成两个相等的部分，或称**[半空间](@entry_id:634770)**（semispaces）：一个“from-space”和一个“to-space”。新对象在 from-space 中分配。当 from-space 被填满时，回收开始。回收器像之前一样追踪存活对象，但不是标记它们，而是将它们复制到空的 to-space。在复制每个对象时，它会更新所有指向该对象的指针，以反映其新位置。

一旦所有存活对象都被疏散，一件非凡的事情发生了。所有存活数据现在都整齐地打包在 to-space 的起始位置，完全没有碎片。那么 from-space 呢？它只包含垃圾和存活对象的旧副本。整个 from-space 可以瞬间被清空。然后，两个半空间的角色互换，程序继续运行。

这种方法的真正天才之处在于其性能特征。复制回收器所做的工作量与它扫描的内存总量无关，而与它*复制的存活数据量*成正比。如果只有很少的对象在一次回收中存活下来，这个过程就会快得惊人。我们甚至可以用一个简单的公式来模拟每次分配的摊销工作量 [@problem_id:3236493]。如果堆的总大小是 $H$，存活数据的大小是 $L$，那么成本与 $\frac{2L}{H-2L}$ 成正比。这个方程揭示了一个深刻的真理：只要存活数据量 $L$ 很小，成本就很低。但当 $L$ 接近堆总大小的一半时，分母趋近于零，成本急剧上升。这告诉我们，复制是一种绝佳的策略，但它适用于对象生命周期较短的堆。

### 年轻的智慧：分代回收

我们现在有了两种强大的追踪策略：[标记-清除](@entry_id:633975)，它能优雅地处理有许多长寿对象的堆；以及复制，它在对象“朝生夕死”时表现出色。这种二元性引出了一种深刻的综合，它基于一个关于计算机程序的简单经验观察，即**分代假说**（generational hypothesis）：大多数对象都很年轻就消亡。

这一洞见是**[分代垃圾回收](@entry_id:749809)**（generational garbage collection）的基础。堆通常被划分为一个**新生代**（young generation）和一个**老年代**（old generation）。所有新对象都在新生代中诞生。因为它们中的大多数会很快消亡，我们可以使用快速的复制回收器频繁地回收新生代。这被称为**次要回收**（minor collection）。其存活率（我们可以用概率 $p$ 来建模 [@problem_id:3634289]）很低，这完美地发挥了复制算法的优势。

一个在数次次要回收中存活下来的对象被认为可能是长寿的。它获得了“终身职位”并被**晋升**（promoted）——从新生代移到老年代。老年代充满了这些顽强的幸存者，其回收频率要低得多，通常使用[标记-清除回收](@entry_id:751679)器，这种回收器可以处理高密度的存活对象，而不会产生复制它们的极端成本。

这个分层系统似乎为我们提供了两全其美的方案，但它引入了一个新的、微妙的问题。如果老年代中的一个对象指向新生代中的一个对象怎么办？在进行次要回收时，我们不能为了找到这些指针而扫描整个庞大的老年代。为了解决这个问题，系统必须采用**[写屏障](@entry_id:756777)**（write barrier）。这是由编译器插入的一小段代码，在程序每次写入指针时运行。如果这次写入创建了一个从老对象到新对象的指针，[写屏障](@entry_id:756777)会将此信息记录在一个称为**记忆集**（remembered set）的特殊列表中 [@problem_id:3644912]。在次要回收期间，回收器将这个记忆集视为其根集合的一部分，从而确保没有新生代对象仅仅因为它与外界的唯一联系来自老年代而被丢弃。

分代回收的优雅需要仔细调优。例如，如果我们过于急切地晋升对象，一个“中等寿命”的对象可能会被移到老年代，但很快就死亡，留下一个碎片空洞 [@problem_id:3644912]。解决方案是增加**晋升阈值**（tenuring threshold）——即一个对象在晋升前必须存活的回收次数——这样这些对象就会在仍然处于紧凑的新生[代时](@entry_id:173412)消亡。系统还必须能应对奇怪的极端情况，比如**对象复活**（object resurrection） [@problem_id:3643634]。如果一个对象的终结代码通过创建一个从老年代到新生代的指针而使其再次变得可达，那么该代码也必须执行[写屏障](@entry_id:756777)。[可达性](@entry_id:271693)规则必须被系统的每个部分毫无例外地遵守。

### 永不停歇的机器：精确式与并发回收

对于像实时图形、金融系统或繁忙的 Web 服务器这样的应用，即使是次要回收的短暂暂停也是不可接受的。最后的疆域是让回收器**并发**（concurrently）运行，与应用程序同时进行，且干扰最小。这就像在人们正在房间里积极工作时试图整理房间——一个极其复杂的挑战。

为了管理这种复杂性，回收器使用一个称为**三色[不变性](@entry_id:140168)**（tri-color invariant）的形式化模型 [@problem_id:3679494]。对象在概念上被着色为白色（未访问）、灰色（已访问，但其子节点尚未扫描）或黑色（已访问且其所有子节点都已扫描）。为防止回收器错过任何对象，系统必须遵守一条关键规则：永远不允许黑色对象指向白色对象。如果应用程序（即“修改器”mutator）试图创建这样一个指针，**[写屏障](@entry_id:756777)**（write barrier）必须拦截该操作 [@problem_id:3668695]。[写屏障](@entry_id:756777)会“通知”回收器，通常通过将白色的目标对象涂成灰色，以确保它不会被错过。

这些在每次指针写入时都会运行的[写屏障](@entry_id:756777)必须非常快。现代系统使用巧妙的优化。**卡片标记**（card marking）屏障不会记录每一次写入，而只是在某个较大固定大小的内存区域（一个“卡片”）内的指针被修改时，将该区域标记为脏 [@problem_id:3679494]。然后，回收器只需要重新扫描这些脏卡片。这可以进一步优化，让每个线程在其本地的**存储缓冲区**（store buffer）中批量处理其脏卡片通知，然后一次性将它们刷新给回收器，这在特定的 GC 策略下是安全的 [@problem_id:3683336]。

即使是并发回收器也需要同步的时刻。它需要在回收开始时知道程序的根在哪里。它通过要求所有应用程序线程在指定的**安全点**（safepoints）短暂暂停来实现这一点。但如果一个线程卡在一个长计算中而没有到达安全点怎么办？现代运行时有一个优美的升级策略：它们给线程一个时间限制，如果超时，运行时会使用[操作系统](@entry_id:752937)信号抢先中断该线程，强制它报告其根，然后让它恢复 [@problem_id:3668695]。

这种复杂的协作之所以可能，是因为运行时和编译器之间有深厚的契约。为了做到**精确**（precise），GC 必须知道栈上每个指针的确切位置。编译器通过每个安全点的**栈映射**（stack maps）提供此信息。精确式回收器比**保守式**（conservative）回收器更安全、更高效，后者必须猜测内存中的某个数字是否可能是一个指针。这种契约的复杂性在处理动态大小的栈帧时尤为突出，此时指针的位置可能成为一个运行时值的函数 [@problem_id:3669462]。栈映射本身必须变成一个动态公式，这证明了我们构建的机器能够在创造者的一点帮助下自我清理，是多么卓越的工程成就。

