## 引言
我们如何能确定一个计算机系统从开机那一刻起就是值得信赖的？在一个充斥着复杂恶意软件和远程云基础设施的时代，盲目信任一台机器的软件栈是一种巨大的风险。度量启动（Measured Boot）正是为了解决这个可验证完整性的根本问题，它用加密证明取代了盲目的信任。它提供的不是一个阻止攻击的盾牌，而是一个记录下究竟运行了哪些软件的、无法被腐蚀的见证者。本文将探讨这一强大的安全方法。

第一章 **“原理与机制”** 将深入探讨其核心技术，解释[可信平台模块](@entry_id:756204)（TPM）如何构建一条不可伪造的[信任链](@entry_id:747264)，并区分这种基于报告的方法与[安全启动](@entry_id:754616)（Secure Boot）的强制执行模型。第二章 **“应用与跨学科联系”** 将展示这一信任基础如何在[云计算](@entry_id:747395)安全、数字取证等关键领域得到应用，甚至会将其与科学探究中的验证原则进行类比。

## 原理与机制

你如何能确定一台计算机正在运行它声称正在运行的软件？这不是一个哲学问题。当银行的服务器处理你的交易，或者云服务提供商运行你的代码，或者你自己的笔记本电脑解锁你的加密文件时，你都对从开机那一刻起的整个软件栈的完整性寄予了巨大的信任。但在一个充斥着复杂恶意软件的世界里，这种信任除了盲目信仰之外还能是什么呢？

**度量启动（Measured Boot）** 提供了一个异常优雅的答案，它不是通过阻止坏事发生，而是通过创建一个不可伪造的记录来证明坏事确实发生了。它用加密证明取代了盲目的信任。要理解这一点，我们必须首先深入了解现代计算机核心处的一块特殊的、防篡改的芯片：**[可信平台模块](@entry_id:756204)（TPM）**。

### 一条牢不可破的链环

想象你有一个小型的、可信的保险库——[TPM](@entry_id:170576)。在这个保险库里，有一些特殊的日志簿，称为**平台配置寄存器（PCRs）**。与普通日志簿不同，一旦条目被写入，你就无法擦除或修改它。你只能以一种非常特殊的方式添加新条目，这个过程被称为**扩展（extending）**。

扩展操作是度量启动的加密核心。假设一个PCR当前持有的值为 $p_{old}$，我们想要记录一个新事件，即一次“度量” $m$。新的值 $p_{new}$ 的计算方式如下：

$$p_{new} \leftarrow H(p_{old} \parallel m)$$

在这里，$H$ 是一个加密[哈希函数](@entry_id:636237)（如 SHA-256），而 $\parallel$ 仅仅表示我们在进行哈希计算前，将旧的PCR值和新的度量值连接（或“粘合”）在一起。这个简单的公式带来了深远的影响 [@problem_id:3645437]。

首先，这是一条**单行道**。由于哈希函数 $H$ 具有抗[原像](@entry_id:150899)攻击性，因此从计算上来说，不可能通过 $p_{new}$ 推算出 $p_{old}$ 和 $m$ 是什么。你只能前进。

其次，**顺序决定一切**。度量的顺序至关重要。先度量事件A再接着度量事件B，得到 $H(H(p_{initial} \parallel A) \parallel B)$，与先度量B再接着度量A，得到 $H(H(p_{initial} \parallel B) \parallel A)$，产生的结果完全不同。因此，一个PCR的最终值是记录在案的*确切有序事件序列*的唯一、敏感的指纹。任何偏差，无论多么微小——单个度量值中的一个比特翻转——都会雪崩式地导致一个完全不同的最终PCR值。

这种机制使得计算机能够构建一条证据链，其中每个链环都以加密方式绑定下一个链环。

### 构建[信任链](@entry_id:747264)：从芯片到[操作系统](@entry_id:752937)

计算机的启动过程是一系列阶段，每个阶段加载并执行下一个阶段。度量启动将这个过程变成了一套严谨的度量仪式。

1.  **最初的火花**：当你按下电源按钮时，最先执行的代码并非位于你的硬盘上，而是蚀刻在处理器的芯片中或主板上的[只读存储器](@entry_id:175074)（ROM）芯片里。这段不可变的代码就是**可信度量根（CRTM）**。它的可信度是绝对的，因为它无法被更改。它的首要任务，在做任何其他事情之前，就是通过计算下一个启动阶段（UEFI固件）的哈希值来度量它。然后，它将这个度量值“扩展”到一个PCR中。[@problem_id:3628964]

2.  **传递接力棒**：CRTM随后将控制权交给UEFI固件。固件因已被度量而获得信任，于是它接过了责任。在从磁盘加载[操作系统](@entry_id:752937)[引导加载程序](@entry_id:746922)之前，它会度量该[引导加载程序](@entry_id:746922)，并扩展同一个PCR。

3.  **链条延续**：[引导加载程序](@entry_id:746922)继而度量[操作系统内核](@entry_id:752950)，然后再执行它，并再次扩展PCR。内核甚至可以继续这个过程，度量驱动程序和关键的配置文件。

请注意这里发挥作用的关键原则：**度量先于执行**。每个软件组件在它仅仅是磁盘上的数据时就被度量，此时它还*没有*被赋予运行和可能作恶的能力。这就创建了一条**[信任链](@entry_id:747264)**，锚定在物理上不可变的CRTM中，链上的每个环节通过度量下一个环节来为其完整性作证。PCR中的最终值是这整个链条的顶点，是一个代表整个启动历史的单一数字。

### 报告而非监管：度量启动 vs. [安全启动](@entry_id:754616)

将度量启动与其近亲**[安全启动](@entry_id:754616)（Secure Boot）**区分开来至关重要。它们服务于不同但互补的目的。

把**[安全启动](@entry_id:754616)**想象成一个有着严格访客名单的俱乐部保镖。它会检查每一段启动软件的[数字签名](@entry_id:269311)。如果签名不在名单上（即未经微软或硬件供应商等可信机构签名），它就会被拒绝进入。[安全启动](@entry_id:754616)*强制执行*一项策略；它主动阻止未授权代码运行。

而**度量启动**则像一个高分辨率的安保摄像头系统，它一丝不苟地记录下进入的每一个人及其顺序。它不会在门口阻拦任何人，但它会生成一份关于谁在何时进入的、完美的、不可伪造的记录。它*报告*发生了什么。

考虑一个简单的攻击：恶意行为者无法更改签名的内核文件，但他们设法编辑了一个配置文件以禁用一项关键的安全功能。这就像一个持有有效身份证件的客人携带了一个可疑的包裹 [@problem_id:3679609]。

-   **[安全启动](@entry_id:754616)**会检查内核的签名，发现其有效，并允许系统启动。保镖检查了身份证，看到它是有效的，但没有检查包裹。
-   **度量启动**，如果配置如此，不仅会度量内核，还会度量该配置文件。由于配置已更改，度量值也不同，最终的PCR值将会有所不同。安保摄像头记录下了该客人进入时*携带那个特定包裹*的情景。

[安全启动](@entry_id:754616)提供预防性强制执行。度量启动为检测和响应提供证据。一个真正安全的系统两者都会使用。

### 裁决：[远程证明](@entry_id:754241)与本地密封

那么，我们有了这个强有力的证据，这个PCR指纹。我们能用它做什么呢？主要有两个应用。

#### [远程证明](@entry_id:754241)

想象一个云服务，只有当它能信任你的计算机没有被攻破时，才会授予你访问敏感数据的权限。你不能只让你的计算机说：“我很好，相信我。”你需要证据。

这就是**[远程证明](@entry_id:754241)（remote attestation）**发挥作用的地方。云服务（“验证者”）向你的计算机发送一个挑战。作为回应，你的[TPM](@entry_id:170576)会生成一个**引用（quote）**：一份包含当前PCR值的、经过[数字签名](@entry_id:269311)的声明。这个签名是使用一个锁定在TPM内部且永远无法被提取的特殊密钥创建的。

验证者收到这个引用。它首先检查签名以确认其来自一个真实的[TPM](@entry_id:170576)。然后，它将引用中的PCR值与它所知的一组对应于干净、可信启动状态的“黄金”值进行比较。如果匹配，验证者就授予访问权限。如果不匹配——就像我们配置文件攻击的例子中那样[@problem_id:3679609]——它就知道出了问题，并可以拒绝访问或发出警报。

#### TPM 密封

度量启动的力量并不仅限于向他人证明其状态。它还可以用于自我保护，即使在完全离线的情况下。这是通过**TPM密封（TPM sealing）**实现的[@problem_id:3679556]。

想想你的全盘加密密钥。你希望它受到保护。通过TPM密封，你可以将这个密钥锁在一个与特定PCR值集合绑定的数字保险库中。TPM只有在当前机器中的PCR值与已知良好启动状态的PCR值完全匹配时，才会“解封”（释放）该密钥。

如果攻击者设法在你的[引导加载程序](@entry_id:746922)中安装了一个rootkit，启动过程将生成不同的PCR值。当[操作系统](@entry_id:752937)稍后请求[TPM](@entry_id:170576)解封磁盘密钥时，TPM会检查PCR，发现不匹配，并予以拒绝。攻击者最终只能得到一个加密的、无用的硬盘。系统利用了篡改的证据来保护自己。

### 附加说明：边界与盲点

与任何安全技术一样，度量启动并非万能。了解其局限性与了解其优势同样重要。

-   **信任之信问题（The Trusting Trust Problem）**：整个[信任链](@entry_id:747264)都锚定在CRTM——即运行的第一个代码片段上。如果那段代码本身被攻破了呢？一个高明的攻击者可以安装恶意固件（“bootkit”），对[TPM](@entry_id:170576)撒谎，扩展“良好”的度量值，而实际上加载恶意代码。如果信任的根基被污染，整个链条就毫无价值 [@problem_id:3673354]。

-   **检查与使用之间的间隙（[TOCTOU](@entry_id:756027)）**：度量是时间上的一个快照。攻击可能发生在组件被度量*之后*、被执行*之前*的微小[窗口期](@entry_id:196836)。例如，一个具有**直接内存访问（DMA）**能力的恶意外部设备，可以在[引导加载程序](@entry_id:746922)已经度量过合法内核之后，在内存中将其覆盖。这就是为什么TCB，即**[可信计算基](@entry_id:756201)**，有时不仅要包括[引导加载程序](@entry_id:746922)代码，还要包括管理这类强大硬件的驱动程序 [@problem_id:3679566]。当计算机从睡眠（S3挂起到内存）中恢复时，也存在类似的漏洞。PCR值与睡眠前保持不变，但具有物理访问权限的攻击者可能已经篡改了活动内存 [@problem_id:3679562]。

-   **运行时盲点**：标准的度量启动主要保护启动过程。对于系统启动并运行后发生的事情，它提供的保证很少。Web浏览器中的漏洞、恶意文档，或由JIT（即时）编译器动态生成的代码，都是启动时度量无法捕获的运行时事件。虽然像Linux的**完整性度量架构（IMA）**这样的技术将度量扩展到文件加载时，但它们仍然无法捕获一个运行中进程的动态、瞬时行为 [@problem_id:3673334]。

-   **完整性 vs. 机密性**：度量启动提供*完整性*——保证你的软件是你所期望的样子。它本身并不提供内存中数据的*机密性*。**冷启动攻击（cold boot attack）**，即攻击者物理地冷冻并提取[RAM](@entry_id:173159)芯片的内容，可以窃取像活动加密密钥这样的秘密。度量启动无法阻止这种物理上的数据窃取；它只能证明机器在*下一次*启动时是干净的 [@problem_id:3679600]。

综上所述，度量启动是一个深刻而强大的概念。它通过创建一个无法被腐蚀的现实记录，为构建可信系统提供了一个坚实的、加密安全的基础。虽然它并非万灵丹，但它是一个基本的构建模块，一个美妙的机制，使我们第一次能够从盲目地信任我们的计算机，转向可验证地了解它们。

