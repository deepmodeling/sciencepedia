## 引言
在复杂的[操作系统](@entry_id:752937)世界里，最基本的职责之一是管理像 CPU 时间和内存这样的有限资源。但是，[操作系统](@entry_id:752937)如何判断什么是“公平”的呢？这个问题并不像听起来那么简单，因为选择公平对待的对象——是单个线程还是其所属的进程——会极大地改变系统行为和稳定性。一种天真的方法很容易被利用，允许单个应用程序仅通过创建大量线程就垄断资源，导致其他行为良好的程序“饿死”。

本文深入探讨了“每进程公平性”这一关键概念，它是现代[操作系统](@entry_id:752937)设计的基石。在接下来的章节中，我们将探讨其核心困境及其优雅的解决方案。在“原则与机制”部分，我们将揭示防止系统被“钻空子”的分层资源管理的基本思想，并审视公平与性能之间不可避免的权衡。随后，在“应用与跨学科联系”部分，我们将看到这些原则在实践中的应用，从经典的 CPU 调度到其在云环境中作为安全堡垒的角色，揭示公平性不仅是一种理想，更是构建稳健高效系统的现实需求。我们的旅程将从剖析公平性的定义及其维护机制开始。

## 原则与机制

想象一下，你的任务是在一个派对上把两个大披萨分给两个家庭。第一个家庭有一个孩子，第二个家庭有十个孩子。什么才是“公平”的分配方式？如果你给每个人发一片，那么有十个孩子的家庭将消耗掉绝大部分披萨，让小家庭只剩下一点碎屑。这对于“个人”来说或许是公平的，但对于“家庭”来说却显得极不公平。一种更公平的方法是给每个家庭一个完整的披萨，让他们自己决定内部如何分配。

这个简单的类比正是[操作系统](@entry_id:752937)设计中最基本挑战之一的核心：**每进程公平性**。[操作系统](@entry_id:752937) (OS) 是资源的总管理者，负责分配 CPU 时间、内存和存储等有限的“切片”。但谁才是这些资源的合法接收者？是底层的单个执行“线程”？还是拥有它的高层“进程”或“用户”？正如我们从披萨的例子中看到的，你选择公平对待的对象改变了一切。

### 公平性困境：谁能分得一杯羹？

一个没有仔细思考过这个问题的[操作系统](@entry_id:752937)很容易被愚弄。考虑一个简单的 **Round-Robin** 调度器，它会循环遍历所有可运行实体的列表，给每个实体一个小的 CPU 时间片（**quantum**）。如果它所见的“可运行实体”是线程，那么用户只需编写一个创建数百个线程的程序，就能获得不公平的优势。一个拥有十个线程的应用程序将获得单线程应用程序十倍的 CPU 时间，就像有十个孩子的家庭获得了十倍的披萨一样。

这不仅仅是一个理论上的漏洞。如果调度器天真地将每个线程都视为平等，它就会激励程序变得“线程密集”，其目的不是为了性能，而是为了垄断系统资源。一个具体的场景完美地说明了这一点：在一台 4 核机器上，假设一个进程（$P_1$）运行 8 个线程，另外两个进程（$P_2$、$P_3$）各运行 2 个线程。如果调度器只是简单地将 4 个核心分配给总共 12 个线程，那么进程 $P_1$ 将占据机器算力的整整 $\frac{8}{12}$——相当于 $\frac{8}{3}$ 个核心——而 $P_2$ 和 $P_3$ 各只能获得 $\frac{2}{3}$ 个核心。产生最[多线程](@entry_id:752340)的进程获胜，无论用户的意图或应得份额如何 [@problem_id:3661212]。

这个问题的另一面揭示了另一个关键细节：[操作系统](@entry_id:752937)只能调度它能看到的东西。如果一个应用程序使用**多对一**[线程模型](@entry_id:755945)，即许多[用户级线程](@entry_id:756385)由一个进程内的库管理，并映射到单个[内核线程](@entry_id:751009)，那么[操作系统调度](@entry_id:753016)器对此是盲目的。它只看到一个可调度的实体。即使该进程有 100 个忙碌的用户线程，它在 CPU 轮转中也只能获得一次机会。它虽然不能成为资源“大胃王”，但也削弱了自己使用[多核处理器](@entry_id:752266)的能力，因为它一次只能在一个核心上运行，无论有多少核心可用 [@problem_id:3689552] [@problem_id:3660893]。

显然，一个稳健而公平的系统需要一种更复杂的方法。它必须理解所有权的概念。

### 会计师的解决方案：分层公平性

优雅的解决方案是停止将每个实体视为独立的对等体，而是将它们组织成一个层次结构——就像给每个家庭一个披萨一样。这个原则被称为**分层资源管理**或**公平共享调度**。

在这个模型中，[操作系统](@entry_id:752937)就像一个一丝不苟的会计师。它首先识别出重要的顶层群体：用户或进程。它根据预先分配的**权重**或权利在这些群体之间分配系统资源。例如，两个权重相同的用户，随着时间的推移，各自有权获得 50% 的 CPU。然后，也只有到那时，调度器才会审视每个群体的“内部”。分配给一个用户的 CPU 份额会再次公平地划分给该用户所属的所有线程。

这种两级分配方案非常有效。一个拥有一进程十线程的用户，与拥有十进程各一线程的用户，获得的 CPU 总份额是相同的。系统再也不能通过简单地增加实体数量来“钻空子”。这个原则普遍适用于所有主要资源：
*   **CPU：** 用户的总 CPU 消耗受其权重限制，而非线程数。[@problem_id:3664587]
*   **内存：** 对一个用户所有进程使用的总内存强制施加限制。一个进程不能通过派生子进程来分配更多内存从而绕过限制。
*   **存储：** 磁盘配额在用户级别应用，汇总该用户所有文件消耗的空间。

回到我们的[多线程](@entry_id:752340)例子，一个分层调度器会首先看到三个权重相等的进程。它会为每个进程分配总 CPU 容量的 $\frac{1}{3}$，即 $\frac{4}{3}$ 个核心。然后，进程 $P_1$ 的份额将在其 8 个线程之间分配，每个线程获得 $\frac{1}{6}$ 个核心。公平性在进程级别得到了完美的维持，正如我们所期望的 [@problem_id:3661212]。

### 抵御“游戏玩家”：票据膨胀与稳健的调度器

即使有了所有权的概念，聪明的用户可能仍然会试图寻找漏洞。这就引出了一个有趣的想法：**票据膨胀攻击**。在像**彩票调度 (Lottery Scheduling)** 这样的调度器中，每个进程被赋予一定数量的“票据”，为了选择下一个要运行的进程，[操作系统](@entry_id:752937)会进行一次抽奖。你拥有的票据越多，中奖的机会就越大。如果一个进程仅仅通过创建更多的子进程就能获得更多的票据，会发生什么？

一个有缺陷的调度器可能会给每个新进程一个默认数量的票据。一个恶意用户可以派生数千个微不足道的进程来膨胀他们的票据数量，从而霸占 CPU。然而，一个设计良好的比例份额调度器，无论是像彩票调度那样的随机化调度器，还是像**[步长调度](@entry_id:636095) (Stride Scheduling)** 那样的确定性调度器，如果它遵循分层原则，就能对此免疫。如果一个总预算为 $T$ 票据的应用程序将自己划分为 $k$ 个子进程，它也必须划分自己的票据，给每个子进程仅 $T/k$ 张票据。在每次抽奖中，该应用程序的某个子进程中奖的总概率仍然精确地与其原始预算 $T$ 成正比。它没有获得任何优势。攻击失败了 [@problem_id:3655087]。

现实世界又增加了一层复杂性：线程并非永远运行；它们会阻塞以等待 I/O 或其他事件。如果一个权重为 $w$ 的进程有 $m$ 个线程，而我们静态地为每个线程分配 $w/m$ 的权重，那么当其中一半线程被阻塞时会发生什么？该进程在调度器眼中的总“活跃”权重将减半，从而不公平地惩罚了它。真正稳健的解决方案是动态的：[操作系统](@entry_id:752937)必须持续监控哪些线程是可运行的，并动态调整它们的权重，以确保一个进程的“当前可运行”线程的权重总和始终等于其总权利 $w$。即使在不断变化的环境中，这也能保持公平性 [@problem-id:3673690]。

### 超越 CPU：有限资源世界中的公平性

公平性原则以及天真的全局策略所带来的危险，远远超出了 CPU 调度的范畴。考虑[内存管理](@entry_id:636637)。一个全局的**最不常用 (LFU)** 页面替换策略会驱逐访问次数最少的页面。这似乎很合理——为什么要将不受欢迎的[数据保留](@entry_id:174352)在宝贵的内存中呢？

然而，在多进程系统中，这可能导致一种微妙但毁灭性的“饿死”形式。想象一个“繁忙”的进程，它快速访问大量不同的页面，同时还有一个“安静”的进程，它只需要少量内存，但访问其页面的频率较低。繁忙进程将主导 LFU 计数器，用其“受欢迎”的页面填满整个内存。而安静进程的页面，尽管对其进展至关重要，却总会显得是“最不常用”的，并被系统性地驱逐。最终，安静进程可能会发现它的所有页面都无法留在内存中，导致 0% 的命中率，使其进展陷入停滞。一个看似中立的全局策略，由于进程行为的不同，造成了极度的不公平 [@problem_id:3629696]。

### 不可避免的权衡：公平性 vs. 其他一切

在理想世界中，我们可以随时拥有完美的公平性。但在现实世界中，公平性并非唯一的目标。它常常与其他关键的系统目标，如[原始性](@entry_id:145479)能和[能效](@entry_id:272127)，处于紧张关系中。这正是[操作系统](@entry_id:752937)设计的艺术所在。

**公平性 vs. 吞吐量：** 每当[操作系统](@entry_id:752937)从一个进程切换到另一个进程（**[上下文切换](@entry_id:747797)**）时，都会产生一个虽小但非零的开销 $t_{cs}$。为了提供细粒度的、响应迅速的公平性，调度器可能会使用一个非常短的时间量子 $Q$。但这意味着更频繁的上下文切换。系统用于有用工作的时​​间比例（[吞吐量](@entry_id:271802)）大约是 $\frac{Q}{Q+t_{cs}}$。当 $Q$ 变得更小以提高公平时，开销比率 $S = \frac{t_{cs}}{Q}$ 会增大，整个系统的吞吐量就会骤降 [@problem_id:3629555]。

**公平性 vs. [缓存局部性](@entry_id:637831)：** 这种权衡甚至更为显著。现代 CPU 依赖于缓存——小型、快速的内存存储，用于存放最近使用的数据。当一个进程运行一段时间后，它会用自己的数据“[预热](@entry_id:159073)”缓存，从而实现高的**[缓存局部性](@entry_id:637831)**并非常快速地运行。
*   **大时间量子：** 如果调度器使用大的时间量子，每个进程都会运行很长时间，受益于“温暖”的缓存，并获得高性能。但短期公平性很差；一个进程长时间运行，而另一个则在等待。
*   **小时间量子：** 如果调度器为了更好的公平性而使用小的时间量子，它会频繁地切换进程。每次一个新进程运行时，它都会污染缓存，驱逐前一个进程的数据。当第一个进程再次运行时，它的数据已经不见了，它会遭受大量的缓存未命中。两个进程都运行缓慢。
一个优化的实验设计可以通过跟踪诸如每[指令缓存](@entry_id:750674)未命中数 (MPKI) 和[每周期指令数 (IPC)](@entry_id:750673) 等指标，同时改变时间量子的大小，来精确地衡量这种权衡 [@problem_id:3672177]。

**公平性 vs. 能效：** 即使我们试图节省[电力](@entry_id:262356)，也可能无意中造成不公平。为了节省能源，现代[操作系统](@entry_id:752937)会尽量让 CPU 尽可能长时间地保持在低功耗睡眠状态。一种技术是**定时器合并**，即[操作系统](@entry_id:752937)将多个预定的唤醒事件稍微推迟，使它们同时触发，从而允许一次唤醒服务所有事件。但这会产生系统性偏差。想象一下，唤醒定时器被合并为每 8ms 触发一次。一个定时器设置在 `t=9ms` 的进程将持续被延迟 7ms，而一个定时器设置在 `t=15ms` 的进程将仅被延迟 1ms。如果任务周期是合并窗口的倍数，这种不公平就会持续存在，导致一些进程的[服务质量](@entry_id:753918)持续变差，而这纯粹是节能优化的副产品 [@problem_id:3689048]。

实现每进程公平性的旅程本身就是[操作系统](@entry_id:752937)设计的一个缩影。它始于一个简单、直观的原则，面临着可能被复杂性和小聪明颠覆的无数方式，并最终形成一套稳健的、分层的机制。然而，这个旅程从未真正结束，因为公平性必须始终在性能、效率以及构建不仅强大而且公正的系统的无尽追求中，寻求一种微妙的平衡。

