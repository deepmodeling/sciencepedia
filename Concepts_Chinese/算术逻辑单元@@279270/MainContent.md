## 引言
在每台计算机的中央处理器（CPU）的核心，都存在着一个[算术逻辑单元](@article_id:357121)（ALU），它是负责所有计算和逻辑决策的组件。但是，这一个硬件是如何管理从简单加法到复杂比较等如此多样化的任务的呢？本文将揭开 ALU 的神秘面纱，解答如何从基础电子原理中构建出多功能性这一根本问题。我们将开启一段从零开始构建 ALU 的旅程，从其核心原理和机制入手。你将发现[多路复用器](@article_id:351445)如何实现选择，加法和减法如何通过巧妙的数学方法统一起来，以及 ALU 如何处理不同的数字系统。接下来，我们将探讨 ALU 的关键应用和跨学科联系，揭示其在 CPU 数据通路中的角色、在执行[算法](@article_id:331821)中的重要性，以及影响现代计算性能、效率和精度的设计考量。

## 原理和机制

如果你有机会窥探计算机中央处理器的内部，你会发现一个活动的旋风，一场由电脉冲构成的风暴，指挥着一切，从视频游戏中角色的飞翔到公司薪资的计算。在这场风暴的核心，坐落着一个异常优雅而强大的设备：**[算术逻辑单元](@article_id:357121)**，即 ALU。它是处理器的计算引擎，是真正进行“思考”——即数据的相加、比较和操作——的地方。但是，一块小小的硅片如何能如此多才多艺？它如何决定是该将两个数字相加，还是检查它们是否相等？答案并非某种深不可测的魔法，而是一系列优美且出人意料的简单原理。让我们开启一段从零开始构建 ALU 的旅程，从最基本的理念——选择的力量——开始。

### 选择的力量：用多路复用器构建

想象一下，你有几台机器，每台都执行一个不同的简单任务。一台机器可以执行逻辑**与**（AND）操作（仅当其两个输入都为 1 时输出 1）。另一台执行逻辑**或**（OR）操作（只要至少有一个输入为 1 就输出 1）。第三台执行**[异或](@article_id:351251)**（XOR）操作（仅当输入不同时输出 1）。你如何能构建一个统一的机器，能够根据指令执行*任何*这些任务呢？

你可以建一个交换台。你可以在相同的输入上并行运行所有机器，然后用一组开关来选择那一刻你关心哪台机器的输出。在[数字电子学](@article_id:332781)的世界里，这个交换台被称为**多路复用器**（multiplexer），或称**MUX**。它是一个基本组件，接收多条输入线，并根据一组“选择”线，精确地选择其中一条，让其信号通过唯一的输出线。

这正是基本 ALU 的诞生方式。我们可以使用一个 4-1 [多路复用器](@article_id:351445)构建一个处理四种不同操作的简单 1 位 ALU。我们给它输入两个数据位，$A$ 和 $B$。同时，我们使用逻辑门计算 $A \text{ AND } B$、$A \text{ OR } B$、$A \text{ XOR } B$ 以及可能的 $\text{NOT } A$。这四个结果被连接到我们[多路复用器](@article_id:351445)的四个数据输入端。两个控制位，我们称之为 $S_1$ 和 $S_0$，被连接到 MUX 的选择线。现在，通过设置 $S_1$ 和 $S_0$ 的值，我们就可以选择哪个操作的结果成为我们 ALU 的最终输出 [@problem_id:1948582]。

- 如果我们将 $(S_1, S_0)$ 设置为 $(0,0)$，MUX 会选择第一个输入，得到 $A \text{ AND } B$。
- 如果我们将它们设置为 $(0,1)$，它会选择第二个输入，得到 $A \text{ OR } B$。
- 如果我们将它们设置为 $(1,0)$，它会选择第三个输入，得到 $A \text{ XOR } B$。
- 如果我们将它们设置为 $(1,1)$，它会选择第四个输入，得到 $\text{NOT } A$。

突然之间，我们创造了一个可编程单元！它还不是一台计算机，但已经有了计算机的雏形。它能够做出选择。这样一个设备对于其数据和控制输入的所有可能组合的全部行为，都可以用一张**[真值表](@article_id:306106)**完美地描述，这张表无非是其行为的详尽目录 [@problem_id:1973333]。这种简单的基于 MUX 的设计是所有 ALU 的基本原则：同时执行多个操作，并使用控制信号来选择所需的结果。

### 统一逻辑与算术

我们的小机器很符合逻辑，但它还不会做任何数学运算。它是一个逻辑单元，但还不是一个*算术*逻辑单元。要实现这一飞跃，我们需要引入所有数字算术的构建模块：**[全加器](@article_id:357718)**。

[全加器](@article_id:357718)是简约的奇迹。它是一个小电路，接收三个比特作为输入——我们称之为 $X$、$Y$ 和一个“进位输入”位 $C_{in}$——并产生两个比特的输出：一个**和**位（$S$）和一个**进位输出**位（$C_{out}$）。它执行的正是你在小学学到的逐列[二进制加法](@article_id:355751)。例如，二进制中的 $1+1+1$ 是 $11$，所以和是 1，进位输出是 1。通过将这些[全加器](@article_id:357718)链接在一起，将一个的 $C_{out}$ 连接到下一个的 $C_{in}$，我们就可以对任意长度的二进制数进行加法运算。

现在，一个有趣的问题出现了。我们是否必须构建一个独立的加法器电路，并让它与我们的[逻辑电路](@article_id:350768)分开，还是我们可以更聪明一些？我们能否创建一个单一、统一的模块，既能执行加法*又*能执行逻辑运算？

答案是响亮的肯定，而解决方案再次由我们的朋友——多路复用器——提供。考虑这样一种设计，我们使用一个[全加器](@article_id:357718)作为我们 ALU 切片的核心 [@problem_id:1938850]。我们将我们的主要数据输入 $A$ 和 $B$直接连接到加法器的 $X$ 和 $Y$ 输入。现在，我们如何处理第三个输入，即进位输入 $C_{in}$？魔法就发生在这里。我们可以使用一个由选择信号 $S$ 控制的 MUX 来决定向 $C_{in}$ 输入什么。

-   当 $S=0$ 时，我们想执行加法。完整的和是 $A+B+C_{in}$，所以我们只需让 MUX 将外部进位信号 $C_{in}$ 直接传递给加法器的 $C_{in}$ 输入。加法器的和输出就成为我们 ALU 的结果。
-   当 $S=1$ 时，我们可能想执行一个逻辑运算，比如 $A \text{ OR } B$。这时，布尔代数的一个绝妙特性就派上用场了。事实证明，逻辑表达式 $A \text{ OR } B$ 等价于 $A \oplus B \oplus (A \cdot B)$，其中 $\oplus$ 是异或，$\cdot$ 是与。根据定义，[全加器](@article_id:357718)的和输出是 $A \oplus B \oplus C_{in}$。所以，如果我们能让 $C_{in}$ 等于 $A \cdot B$，加法器本身就会为我们计算出逻辑或！我们可以配置我们的 MUX，当 $S=1$ 时，它将一个[与门](@article_id:345607)（$A \cdot B$）的结果送入加法器的 $C_{in}$ 输入。

想一想我们刚刚做了什么。我们用一个为算术设计的电路，通过一点巧思和一个多路复用器，诱使它执行了逻辑运算。这是一个深刻的洞见：逻辑和算术的硬件并非完全分离的世界。它们紧密交织，巧妙的设计可以利用这些联系来构建更高效、更优雅的机器。

### 减法的奥秘

我们已经征服了加法。但它的反面——减法呢？感觉上我们似乎需要一个全新的、复杂的电路——一个“[全减器](@article_id:345928)”。如果仅仅为此就必须构建一个完全独立的硬件模块，实在可惜。事实证明，自然界远比我们想象的要经济，优秀的工程设计也是如此。有一个绝妙的技巧，能让我们使用刚刚构建的同一个加法器电路来执行减法。这个技巧被称为**二进制[补码](@article_id:347145)**。

在我们日常的十进制系统中，要从 15 中减去 9，我们只需计算 $15 - 9 = 6$。二进制补码系统提供了一种不同的思维方式。它提供了一种在二进制中表示负数的方法，使得减法等同于加法。要计算 $A - B$，ALU 计算的是 $A + (B \text{的二进制补码})$。

求一个二进制数的二进制[补码](@article_id:347145)是一个简单的两步过程：首先，你反转所有的位（将每个 0 变为 1，每个 1 变为 0）。这被称为[反码](@article_id:351510)。然后，你再加 1。

让我们用 8 位数从 15 中减去 9 的任务来实际操作一下 [@problem_id:1914993]。
- 首先，我们将数字写成 8 位二进制：$A=15$ 是 $00001111$，$B=9$ 是 $00001001$。
- 接下来，我们求要减去的数 $B=9$ 的二进制[补码](@article_id:347145)。
    1. 反转 $00001001$ 的各位，得到 $11110110$。
    2. 加 1，得到 $11110111$。这是 $-9$ 的 8 位二进制补码表示。
- 最后，我们将这个结果与 $A$ 相加：
  $$
  \begin{array}{rr}
   & 00001111 \\
  + & 11110111 \\
  \hline
  1 & 00000110
  \end{array}
  $$
加法产生了一个 8 位的结果 $00000110$ 和一个来自最高有效位的进位输出 1。神奇之处在于：在二进制补码算术中，我们只需*丢弃*这个最终的进位位。我们的结果是 $00000110$，也就是 6 的二进制表示。完美成功！

这个系统非常健壮。它同样适用于结果为负数的情况 [@problem_id:1915006]。ALU 根本不需要“减法器”。它只需要一个加法器，以及一小块能够在需要减法时计算其一个输入值的二进制补码的逻辑电路。这是数学的优雅带来工程效率的惊人范例。一个电路——加法器——现在同时处理加法和减法，统一了看似相反的操作。

### 游走在边缘：溢出

我们的二进制[补码](@article_id:347145)系统很强大，但它不是无限的。我们使用的是固定数量的位——8、16、32 或 64 位。当计算结果太大（或太小）以至于无法用可用位数表示时会发生什么？这种情况被称为**溢出**，就像汽车里程表“翻转归零”一样。如果你有一个可以表示从 -8 到 +7 的 4 位有符号数系统，而你试图计算 $5+5$，答案是 10，这超出了可表示范围。二进制计算可能会产生一个看起来像 -6 的结果，这显然是错误的。

溢出并非随机错误；它遵循一条严格的规则。对于加法，当且仅当你将两个同号数相加，而结果的符号相反时，才会发生溢出。
- 两个正数相加得到负数？溢出。
- 两个负数相加得到正数？溢出。
- 一个正数和一个负数相加？绝不溢出。

ALU 必须能够检测到这种情况发生并置起一个标志位。我们再次可以问：我们能否设计一个*单一*、统一的[溢出检测](@article_id:342691)电路，既适用于加法也适用于减法？当然可以。关键在于观察进入最终[加法阶](@article_id:299232)段的数字的符号 [@problem_id:1950205]。

让我们用 $A_s$ 和 $B_s$ 表示输入的[符号位](@article_id:355286)（最高有效位），用 $S_s$ 表示结果的[符号位](@article_id:355286)。一个模式信号 $M$ 在加法时为 0，减法时为 1。
- 对于加法（$M=0$），相加的两个数的[符号位](@article_id:355286)是 $A_s$ 和 $B_s$。如果 $A_s$ 和 $B_s$ 相同，但 $S_s$ 不同，则发生溢出。
- 对于减法（$M=1$），我们实际上是在计算 $A + (\text{NOT } B) + 1$。第二个实际相加的数其各位被翻转，所以它的[符号位](@article_id:355286)是 $\text{NOT } B_s$。如果 $A_s$ 和 $(\text{NOT } B_s)$ 相同，但 $S_s$ 不同，则发生溢出。

通过运用一点布尔代数，我们可以将这两个条件组合成一个单一、优美的溢出标志 $V$ 的表达式：
$$V = A_{s}(B_{s} \oplus M)\bar{S}_{s} + \bar{A}_{s}\overline{(B_{s} \oplus M)}S_{s}$$
这个方程式可能看起来令人生畏，但其含义很简单。它是我门溢出规则的形式化体现，并通过模式位 $M$ 巧妙地[参数化](@article_id:336283)。这是 ALU 统一设计性质的又一证明：选择操作的同一个控制信号，也帮助正确解释其结果。

### 为人类服务的数字：BCD 和 ASCII

到目前为止，我们的 ALU 只说纯二进制语言，这是计算机的母语。但它生活在一个以十进制数为基础的世界里。对于金融计算器或数字时钟等应用，使用一种称为**[二-十进制编码](@article_id:352359)（BCD）**的格式来处理数字通常更方便。在 BCD 中，我们不是将整个十进制数转换为二进制，而是用各自的 4 位二进制码来表示每个十进制数字（0 到 9）。例如，数字 25 将被存储为 $0010$（代表 2）和 $0101$（代表 5）。

当 ALU 对两个 BCD 数进行加法时，会遇到一个问题。如果我们使用标准[二进制加法](@article_id:355751)器将 BCD '5'（$0101$）和 BCD '8'（$1000$）相加，会得到 $1101$，即 13。这是一个有效的二进制数，但它*不是*一个有效的 BCD 数字（最大只能到 9）。正确的 BCD 答案应该是单位上是 '3'（$0011$），并向下一个十进制位产生一个进位。

因此，ALU 必须包含一个“校正”逻辑。在[二进制加法](@article_id:355751)之后，它会检查结果。如果二进制和大于 9，就意味着发生了十进制进位。检测这种情况的逻辑是[布尔代数](@article_id:323168)的一个优美应用 [@problem_id:1913560]。条件“5 位结果 $(K, Z_3Z_2Z_1Z_0)$ 大于或等于 10”直接转换为[布尔表达式](@article_id:326513) $C_{out} = K \lor (Z_3 \cdot Z_2) \lor (Z_3 \cdot Z_1)$，其中 $K$ 是[二进制加法](@article_id:355751)器的进位。如果此条件为真，ALU 会输出一个十进制进位并校正和（通常通过加 6）。

这种“解码-操作-编码”模式也出现在其他情境中，例如处理以**ASCII**编码方案表示为文本字符的数字时 [@problem_id:1909413]。其原理保持不变：ALU 必须知道它正在处理的数据的*表示方式*，并相应地调整其逻辑。

### 通用机器：通过查找实现

我们从简单的逻辑门和[多路复用器](@article_id:351445)开始，一路走来，构建了一个能够加、减，甚至能说不同数值语言的复杂设备。我们设想了用一系列专用部件来构建它。但还有另一种，甚至更抽象、更强大的方式来思考如何实现 ALU。

想象一本巨大的参考书。对于你可能提供给 ALU 的每一种可能的输入组合，这本书都会告诉你输出应该是什么。要执行计算，你不需要任何门电路或加法器；你只需在书中查找输入，然后写下答案。

这本“书”在电子学中是存在的，它被称为**[可编程只读存储器](@article_id:353879)（PROM）**。PROM 是一种带有一组地址线（输入）和一组数据线（输出）的设备。对于每个可能的地址，你可以永久存储或“编程”一个特定的数据值。从那时起，每当你将该地址施加到输入端，相应的数据就会出现在输出端。它是一个硬件[查找表](@article_id:356827)。

我们可以用一个 PROM 来实现我们整个 ALU [@problem_id:1955540]。我们只需将 ALU 的所有输入——数据位 $A$ 和 $B$，以及模式选择位如 $M$——连接起来形成地址。然后，对于每一个地址，我们计算出正确的输出应该是什么，并将该值编程到 PROM 中。对于一个对应于 $A=3$，$B=1$ 和 $M=0$（加法）的地址，我们会在该位置存储值 $4$（例如，[二进制串](@article_id:325824) $100$）。对于一个对应于 $A=3$，$B=1$ 和 $M=1$（与）的地址，我们会存储值 $1$（例如，$001$）。

一旦编程完成，这个单一的 PROM *就是* ALU。没有可见的加法器或[多路复用器](@article_id:351445)，只有一个个存储单元组成的网格。然而，它完美无瑕地执行所有指定的功能。这展示了[数字设计](@article_id:351720)中抽象的终极力量。ALU 的逻辑已经从其物理形式中分离出来，被捕获在一个信息表中。从几条简单的规则和基本组件的巧妙组合，我们得到了一个通用的计算机器，准备好在数字世界的核心占据一席之地。