## 引言
所有软件开发的核心都存在一个深刻的悖论：为了创建可信的程序，我们必须依赖那些并非由我们自己从零开始创造的工具。我们用编译器构建复杂的[操作系统](@entry_id:752937)，但这些编译器又是用什么构建的呢？这种递归依赖关系产生了一个关键的漏洞，这个挑战被计算先驱 Ken Thompson 著名地阐述为“对信任的信任”攻击。该问题假定，一个足够聪明的攻击者可以攻破创造工具本身，[植入](@entry_id:177559)无法被检测到的、能够跨代软件自我延续的后门，从而使传统的源代码安全审计变得毫无用处。

本文直面网络安全中的这一根本性挑战。它将“对信任的信任”攻击拆解开来，不将其视为一个无解的谜题，而是看作是开发稳健且可验证的[信任链](@entry_id:747264)的催化剂。在接下来的章节中，我们将探讨定义此问题的核心概念，以及为解决它而设计的精妙方案。首先，在“原则与机制”中，我们将剖析攻击本身，介绍[可信计算基](@entry_id:756201)（TCB）的概念，并解释引导信任和验证工具的基本策略。随后，在“应用与跨学科联系”中，我们将看到这些原则在实践中的应用，从保护单台计算机的启动过程到保护整个全球软件供应链，甚至会发现这些思想如何在其他科学学科中产生共鸣。

## 原则与机制

想象你是一位钟表大师，以制造世界上最精准的计时器而闻名。你毕生的杰作是一座由上千个精密零件构成的宏伟时钟。但是，你如何制造那些用来塑造这些零件的工具呢？你使用你现有的工具。而*那些*工具又是如何制造的呢？是用更古老的工具。如果你追溯这个谱系足够远，你最终必然会到达一个如此简单、如此基础的工具，以至于它可能是用一块原生钢材手工打磨而成的。你最复杂、最宏伟的时钟的可靠性，完全取决于那第一个原始锉刀的完整性。如果那第一个工具有缺陷，那么后续每一代的工具，以及它们生产的每一座时钟，都可能以微妙、不可预测的方式继承那个缺陷。

这正是构建可信计算机系统所面临挑战的核心。我们最复杂的软件，如[操作系统](@entry_id:752937)，是使用另一款软件——编译器——构建的。但编译器又是用什么构建的呢？一个更旧的编译器。这种[自我参照](@entry_id:170448)、自举的特性产生了一个深刻的信任悖论，它不仅是学术性的，而且是现代[网络安全](@entry_id:262820)的核心。

### 机器中的幽灵

1984年，Unix[操作系统](@entry_id:752937)的创造者之一 Ken Thompson 在其经典的图灵奖演讲《对信任的信任的反思》（Reflections on Trusting Trust）中，将这个问题尖锐地呈现出来。他提出了一个自此以后一直困扰着计算机科学界的思想实验。

想象一个恶意的编译器。这个编译器被秘密修改以执行两个险恶的任务。首先，当它检测到自己正在编译 `login` 程序（控制用户对系统的访问）时，它会秘密地插入一个后门，允许攻击者用一个秘密密码登录。其次，也是其神来之笔，当它检测到自己正在编译编译器*本身*的源代码时，它会将*整个恶意逻辑*——包括 `login` 后门和这个自我复制的代码——注入到新的编译器二[进制](@entry_id:634389)文件中。

现在，思考一下后果。攻击者用其（现在是恶意的）源代码编译了这个被修改的编译器。结果是一个被篡改的编译器二进制文件。然后，攻击者将编译器的源代码恢复到其原始、干净的状态。从此刻起，攻击从系统上所有的源代码中消失了。如果你检查 `login` 的源代码，它是干净的。如果你检查编译器的源代码，它也是干净的。然而，当你使用被篡改的编译器二进制文件来编译干净的 `login` 源代码时，后门被插入了。而当你用它来编译干净的编译器源代码时，所产生的*新*编译器二[进制](@entry_id:634389)文件同样被篡改，准备好继续这个循环。攻击的幽灵已经从其源代码中脱离，现在活在、自我延续在已编译的机器码本身之中。作为安全审查黄金标准的源代码审计，将发现不了任何问题 [@problem_id:3634583]。你只能去信任你对工具所抱有的信任。

### [可信计算基](@entry_id:756201)：你的基石有多大？

为了推理这类问题，我们需要一个概念来定义我们被迫无条件信任的东西。这就是**[可信计算基](@entry_id:756201)（Trusted Computing Base, TCB）**。TCB是所有硬件和软件组件的集合，这些组件的正确性对于系统安全策略的成立至关重要。如果TCB的任何部分被攻破，整个系统的安全性都可能崩溃。设计一个安全系统的根本目标，是使TCB尽可能地小 [@problem_id:3629209]。一个更小的TCB意味着一个更小的“攻击面”，而且关键的是，一个足够精简的组件集合，以至于它们有可能通过详尽的检查来验证。

TCB往往比初看起来更大、更微妙。当然，它包括处理器硬件本身和一些初始的启动固件。但正如 Ken Thompson 的攻击所示，如果你使用一个外部的、未经验证的编译器来构建你的系统，那个编译器实际上就成了你TCB的一部分。你是在把它未经证实的完整性作为你系统安全的赌注 [@problem_id:3629209]。

这个问题超出了编译器的范畴。考虑一个现代[操作系统](@entry_id:752937)的启动过程。系统依赖于固件提供的数据表，称为**A[CPI](@entry_id:748135)表**，来了解存在哪些硬件以及如何管理电源。这包括名为AML的可执行代码，[操作系统内核](@entry_id:752950)会以[最高权](@entry_id:202808)限运行它。如果攻击者能够修改这些A[CPI](@entry_id:748135)表，他们就能在内核内部执行恶意代码。因此，除非它们的完整性经过密码学验证，否则A[CPI](@entry_id:748135)表本身必须被视为TCB的一部分 [@problem_id:3679577]。TCB不仅仅是运行的代码；它也是*驱动*代码的数据。

更为微妙的是，TCB必须包括那些随时间推移强制执行完整性的组件。想象一个安全[引导加载程序](@entry_id:746922)，它将[操作系统内核](@entry_id:752950)加载到内存中。然后它执行一个密码学检查来验证内核的签名。这是“检查时”（Time-of-Check）。它确认内核是真实的。然后[引导加载程序](@entry_id:746922)将控制权转移给内核，内核开始执行。这是“使用时”（Time-of-Use）。在这两个时刻之间的微小间隙里会发生什么？一个具有直接内存访问（DMA）能力的恶意存储驱动程序可能会用恶意软件覆盖内存中已被验证的内核。系统随后将执行该恶意软件，同时相信它是真实的内核。这个经典的漏洞被称为**[检查时-使用时](@entry_id:756030)（Time-of-Check-to-Time-of-Use, [TOCTOU](@entry_id:756027)）**攻击。为了防止它，TCB必须扩展到不仅包括验证者，还包括任何有能力在那个关键窗口期间颠覆验证对象的组件，比如存储驱动程序 [@problem_id:3679566]。

### 搭建通往天堂的阶梯

如果我们不能信任我们的工具，脚下的土地也不稳固，我们又该如何构建一个我们能确信的系统呢？答案是，从基岩开始，打造我们自己的土地。这就是**自举（bootstrapping）**的原则，一个从最小、可审计的锚点开始，分阶段建立信任的过程。

这个过程，在 [@problem_id:3634631] 中有精美的阐述，是一段能力不断升级的旅程：

1.  **基石**：我们从一个简单到可以通过人类直接检查来信任的组件开始。这可能是一个微小的程序，只有几百字节长，直接用[十六进制](@entry_id:176613)数写成。这个程序是我们最初的TCB。它唯一的工作就是充当一个原始的加载器和汇编器。

2.  **第一级阶梯**：使用我们信任的“[十六进制](@entry_id:176613)汇编器”，我们编写并汇编一个功能稍强一点的汇编器，一个能理解符号指令的汇编器。我们可以通过让这个新的汇编器重新汇编它自己的源代码来获得对它的信心。如果输出与它自己正在运行的二[进制](@entry_id:634389)文件完全相同，就证明了一种[自洽性](@entry_id:160889)。

3.  **向上攀登**：有了我们信任的汇编器，我们现在可以为一个完整编程语言的小型、简单[子集](@entry_id:261956)构建一个编译器。这个[子集](@entry_id:261956)编译器是我们阶梯上的下一个梯级。

4.  **登顶**：最后，使用这个简单的[子集](@entry_id:261956)编译器，我们可以编译我们最终的、功能齐全的、带优化的编译器的源代码。

在每个阶段，我们都使用一个受信任的工具来构建一个更强大但尚未受信任的工具。然后，我们使用各种测试在新工具中建立信任，之后再用它来构建下一个阶段。这个有条不紊的过程使我们能够构建一个复杂、强大的编译器，同时将信任的初始种子——TCB——保持在可管理的微小规模。整个宏伟结构的安全，都依赖于其基础可验证的简单性。这个原则不仅适用于编译器；它也是像Coreboot这样的系统背后的哲学，其中ROM中一个不可变的硬件验证器会认证一个小的、开源的引导块，该引导块随后成为度量系统其余部分的[信任根](@entry_id:754420) [@problem_id:3679593]。

### 试金石：多样化双重编译

我们已经构建了我们的编译器。我们已经爬上了阶梯。但 Ken Thompson 的幽灵依然徘徊。我们如何证明在我们的自举过程中没有引入任何微妙的颠覆，没有自我复制的漏洞？

为回答这个问题而设计的最强大的技术是**多样化双重编译（Diverse Double-Compiling, DDC）** [@problem_id:3634583]。这是对独立验证这一科学原则的深刻应用。其逻辑如下：一个攻击者可以在一个编译器中隐藏后门。但是，两个完全独立的开发团队，使用不同的设计和不同的代码，意外地创建出*完全逐比特相同的后门*的几率是微乎其微的。

DDC正是利用了这一事实。为了验证你新自举的编译器（我们称之为 `C_A`），你需要执行以下步骤：

1.  获取你的编译器的最终、干净的源代码 `S`。
2.  使用你的自举编译器 `C_A` 编译 `S`，生成一个二[进制](@entry_id:634389)文件 `B_A`。
3.  获取第二个“多样化”的编译器 `C_B`。这个编译器必须是独立开发的。
4.  使用多样化编译器 `C_B` 编译相同的源代码 `S`，生成一个二[进制](@entry_id:634389)文件 `B_B`。
5.  最后，比较 `B_A` 和 `B_B`。

如果 `B_A` 和 `B_B` 逐比特相同，那么你就有压倒性的证据表明你的编译器 `C_A` 是其源代码 `S` 的一个正确、忠实的翻译，并且不含任何隐藏的负载。如果 `C_A` 被篡改并在 `B_A` 中注入了后门，它将与由干净编译器生成的 `B_B` 不匹配。这个检查提供了一种检测“对信任的信任”攻击的方法。这个过程之所以如此有效，是因为它不试图找到缺陷；它只是寻找与可信参考的差异，任何差异。同样的原则也适用于在[交叉编译](@entry_id:748066)构建过程中验证编译器的单个组件，其中本地编译的工具的输出可以作为可信参考，用来核对[交叉编译](@entry_id:748066)版本的输出 [@problem_id:3634685]。

当然，这项强大的技术依赖于一个关键属性：**可复现构建**。构建过程必须是确定性的，这意味着在受控环境中编译相同的源代码必须总是产生完全相同的二进制文件。没有这一点，你就无法判断 `B_A` 和 `B_B` 之间的差异是攻击的迹象，还是仅仅是构建过程中的随机噪声 [@problem_id:3679593]。

### 现代战场：软件供应链

今天，“对信任的信任”问题有了一个新名字：**软件供应链攻击**。原则保持不变，但战场已经演变。现代系统拥有像**[安全启动](@entry_id:754616)（Secure Boot）**和**[度量启动](@entry_id:751820)（Measured Boot）**这样的[硬件安全](@entry_id:169931)特性，它们似乎提供了一个解决方案。[安全启动](@entry_id:754616)充当守门人，在允许代码运行前验证一个密码学签名。[度量启动](@entry_id:751820)则充当法庭记录员，将每一个运行的代码的[密码学](@entry_id:139166)哈希记录到一个位于**[可信平台模块](@entry_id:756204)（[TPM](@entry_id:170576)）**内的安全日志中。

然而，这些机制可以被经典的“对信任的信任”攻击所击败。如果攻击者攻破了软件供应商的自动化构建系统，他们可以在[操作系统内核](@entry_id:752950)被签名*之前*向其注入后门。然后，供应商的系统会尽职地在一个恶意的内核上盖上一个有效的签名。当用户的计算机启动时，[安全启动](@entry_id:754616)会检查签名并发现它是有效的。[度量启动](@entry_id:751820)会记录恶意内核的哈希，但这个哈希将与供应商（被篡改的）官方清单中的哈希相匹配。所有检查都通过了，而系统却被攻破了 [@problem_id:3679558]。

防御此种攻击的唯一方法是将[信任链](@entry_id:747264)从最终产品延伸到开发过程本身。这是安全领域的现代前沿，它依赖于我们已经讨论过的那些原则：

-   **度量工具链**：启动度量不仅应包括内核，还应包括构建它的编译器的证据。然后，一个远程服务可以证明，不仅内核是可识别的，而且它是由一个授权的编译器构建的 [@problem_id:3679558]。
-   **[可复现性](@entry_id:151299)与多样性**：供应商可以强制执行可复现构建，并使用多个独立的构建系统。他们将生成的哈希发布到一个公共账本上。只有当多个独立的构建者对其哈希达成一致时，一个内核才被认为是可信的，这实际上是在全球范围内执行DDC [@problem_id:3679558]。
-   **来源证明**：构建过程可以生成一个经过[密码学](@entry_id:139166)签名的“收据”，即**来源证明**（例如，SLSA或in-toto证明）。这张收据是一个不可伪造的记录，将最终的二进制文件与其源代码、使用的特定编译器版本以及所采取的构建步骤联系起来。这允许验证者审计一个软件的整个历史，而不仅仅是它的最终状态 [@problem_id:3679558]。

从一个自编译编译器的抽象悖论，到我们全球软件生态系统的切实安全，原则始终未变。信任不能是绝对的；它必须从一个简单、可验证的基础上，一步一步地建立起来，并通过独立的、可复现的检查不断地重新验证。机器中的幽灵永远存在，而我们最强大的防御是一条用逻辑、透明度和健康的怀疑精神锻造的[信任链](@entry_id:747264)。

