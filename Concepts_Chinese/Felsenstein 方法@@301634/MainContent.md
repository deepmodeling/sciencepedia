## 引言
要理解生命世界，就必须理解其历史，而这段历史被编码在物种之间的关系中，构成了一棵宏大的生命之树。生物学的一个根本挑战在于，物种并非独立的观测数据点；它们通过共同的祖先联系在一起，这一事实使得标准的统计比较方法失效。忽略这种系统发育的非独立性会导致关于演化过程的错误结论。本文深入探讨 [Joseph Felsenstein](@article_id:351700) 的开创性工作，他提供了在演化背景下恰当分析数据的统计学和计算框架。您将了解到他贡献的两大支柱，探索其核心逻辑及其对生物学的变革性影响。第一章“原理与机制”将详细解析这些精巧的[算法](@article_id:331821)本身：用于从分子数据[计算树](@article_id:331313)的似然值的剪枝[算法](@article_id:331821)，以及用于研究性状[协同演化](@article_id:303344)的独立[比较法](@article_id:356721)。随后的“应用与跨学科联系”一章将展示这些工具如何被用来回答深刻的问题，从重建远古生命的面貌到追踪现代流行病的传播。

## 原理与机制

要理解生命世界，就必须理解其历史。但我们如何阅读一本用 DNA 和物理性状语言写成的历史书？这本书的书页[散布](@article_id:327616)在数百万个物种之中，所有物种都通过一棵庞大而错综复杂的生命之树相互连接。根本的挑战在于，物种并非独立的观测数据点。蝙蝠和鲸鱼的前肢骨骼与我们人类的同源，这并非源于三次独立的创造行为，而是因为它们拥有一个共同的哺乳动物祖先。任何忽略这段共同历史——即这种非独立性——的[统计分析](@article_id:339436)都注定会失败。

在两篇开创性的论文中，[Joseph Felsenstein](@article_id:351700) 提供了揭开这段历史的钥匙。他提供的不是一种方法，而是一种哲学，一种看待问题的新方式，并由此催生了两种强大的计算工具。第一种工具让我们能根据分子序列计算[演化树](@article_id:355634)的似然值，第二种工具则让我们能研究跨物种性状的[相关演化](@article_id:334289)。尽管它们解决的问题不同，但却由一个共同而优美的思想统一起来：生命之树并非一个需要校正的麻烦，而是那个能让我们提出并回答演化问题的根本框架。

### 剪枝[算法](@article_id:331821)：阅读 DNA 之书

想象一下，你拥有一组物种的 DNA 序列——比如人类、黑猩猩和大猩猩。你可以将它们[排列](@article_id:296886)成一棵树，其中人类和黑猩猩的[亲缘关系](@article_id:351626)比它们任何一方与大猩猩的关系都更近。你还可以测量分支的“长度”，它代表了演化时间或遗传变化的数量。现在的问题是，在给定我们今天所见的 DNA 的情况下，这棵特定的树有多大的可能性？这就是“似然”问题。

一种朴素的方法是列出所有可能发生的情景。也许在某个位点上，共同祖先拥有一个‘A’，在通往大猩猩的分支上它突变成了‘G’，而在另一分支上则保持为‘A’。然后，在人类与黑猩猩分化的节点上，它在人类分支上保持为‘A’，但在黑猩猩分支上变成了‘T’。这是一种完整的历史。为了得到看到我们当前数据的总概率，我们必须计算出*每一种*这类历史的概率，并将它们全部相加。

这很快就演变成一场计算噩梦。对于一棵有 $n$ 个物种、遗传密码有 $k=4$ 种状态（A、C、G、T）的树来说，其内部祖先节点的状态组合有 $k^{n-1}$ 种可能。即使对于一棵只有 30 个物种的中等大小的树，这个数字也是 $4^{29}$，远远超过我们银河系中恒星的数量。直接计算不仅困难，而且在物理上是不可能的 [@problem_id:2694176]。

#### Felsenstein 的神来之笔：剪去可能性的枝桠

Felsenstein 的洞见在于，他意识到我们无需追踪从根到末端的每一条完整历史。我们可以更聪明地从末端向内计算。这种方法被称为 **Felsenstein 剪枝[算法](@article_id:331821)**，是[动态规划](@article_id:301549)的一个绝佳应用。

我们不必考虑整个祖先历史，而是只关注树中的一个内部节点。我们称其为节点 $k$。它有两个子节点，比如节点 $i$ 和 $j$。该[算法](@article_id:331821)的核心思想是，在节点 $k$ 处于特定状态的条件下，计算看到节点 $k$ *下方*所有数据的似然。我们对所有可能的状态都进行这种计算。因此，在节点 $k$ 处，我们计算一个包含四个值的向量：

1.  在节点 $k$ 状态为‘A’的情况下，其下方子树数据的[似然](@article_id:323123)。
2.  在节点 $k$ 状态为‘C’的情况下，其下方子树数据的[似然](@article_id:323123)。
3.  在节点 $k$ 状态为‘G’的情况下，其下方子树数据的似然。
4.  在节点 $k$ 状态为‘T’的情况下，其下方子树数据的[似然](@article_id:323123)。

我们来看看这是如何实现的。假设一个内部节点 $N_1$ 有两个子节点，它们都是末端分类单元：分类单元 1 的[核苷酸](@article_id:339332)为‘A’，分类单元 2 为‘G’。通向它们的支长分别为 $v_1$ 和 $v_2$。那么，$N_1$ 处的祖先是‘C’的条件似然是多少，我们记为 $L_{N_1}(C)$？由于在给定 $N_1$ 状态的情况下，从 $N_1$ 演化出的两个分支是[独立事件](@article_id:339515)，因此答案就是两次所需突变概率的乘积：

$$L_{N_1}(C) = P_{C \to A}(v_1) \times P_{C \to G}(v_2)$$

在这里，$P_{i \to j}(v)$ 是[核苷酸](@article_id:339332) $i$ 沿长度为 $v$ 的分支变为 $j$ 的概率，这个值由我们选择的 DNA [替换模型](@article_id:356723)给出 [@problem_id:1946215]。我们对节点 $N_1$ 的所有四种可能性（A、C、G、T）都进行此计算，以得到其完整的条件似然向量。

现在来看递归的魔力。如果一个节点的子节点不是末端，而是内部节点，那么我们就没有一个单一的观测[核苷酸](@article_id:339332)。取而代之的是，我们已经为它们计算好了条件[似然](@article_id:323123)向量！为了找到父节点 $v$ 在状态为 $x$ 时的[似然](@article_id:323123)，我们需要对其子节点 $c_j$ 可能处于的所有状态 $y$ 进行求和。对于一个拥有子节点 $\{c_j\}$ 的内部节点 $v$，其通用[递归公式](@article_id:321034)为：

$$\ell_v(x) = \prod_{j} \left[ \sum_{y=1}^{k} P_{xy}(t_{vc_j}) \ell_{c_j}(y) \right]$$

其中 $\ell_v(x)$ 是在节点 $v$ 处于状态 $x$ 的条件下，其下方数据的条件[似然](@article_id:323123)，而 $P_{xy}(t_{vc_j})$ 是沿通往子节点 $c_j$ 的分支从状态 $x$ 变为状态 $y$ 的转移概率 [@problem_id:2823607]。

我们重复这个过程，沿着树向上移动，根据每个节点的子节点的向量来计算该节点的似然向量。当我们最终到达树的根节点时，我们得到一个最终向量。然后，通过对这些根[似然](@article_id:323123)值进行[加权平均](@article_id:304268)（权重为每个[核苷酸](@article_id:339332)的先验概率，即其平稳频率 $\boldsymbol{\pi}$），即可计算出整棵树的总[似然](@article_id:323123)。

这种方法的力量是惊人的。通过分解问题和重用中间计算结果，剪枝[算法](@article_id:331821)将计算复杂度从指数级的、无法计算的函数（$O(m n k^{n-1})$）降低到一个可管理的线性函数（对于一个包含 $m$ 个位点的比对序列，复杂度为 $O(m n k^2)$）[@problem_id:2694176]。它将[系统发育](@article_id:298241)[似然](@article_id:323123)从一个理论上的奇思妙想，转变为一个用于推断的实用而强大的工具。

#### 框架的稳健性

Felsenstein 似然框架的真正美妙之处在于其灵活性。现实世界的生物学是复杂的，但剪枝[算法](@article_id:331821)能够优雅地处理它。

*   **处理不确定性**：如果测序仪不确定一个碱基是‘A’还是‘G’怎么办？这可以用模糊码‘R’来表示。我们不必丢弃这个数据点，只需告诉[算法](@article_id:331821)，这个末端节点的似然对于‘A’是 1，对于‘G’是 1，对于‘C’和‘T’是 0。[算法](@article_id:331821)会接收这个不确定性向量，并将其无缝地向上传播到树中。如果我们有概率权重，比如来自测序[质量分数](@article_id:298145)，我们甚至可以提供这些权重 [@problem_id:2372356]。不确定性不是障碍，它只是待整合的另一条信息。

*   **演化的步调**：假设一个基因中的所有位点都以相同的速率演化是不现实的。一些位点对功能至关重要，变化非常缓慢；而另一些位点则受到的限制较少，变化迅速。剪枝框架可以扩展以模拟这种**[速率异质性](@article_id:309996)**。我们可以定义几个速率类别（如慢、中、快）。对于一个给定位点，我们通过相应地缩放树的支长来计算每个速率类别下的[似然](@article_id:323123)。该位点的最终似然就是所有速率类别下似然值的[加权平均](@article_id:304268)值。这是通过对每个速率类别独立运行剪枝[算法](@article_id:331821)，并在最后将结果合并来实现的 [@problem_id:2747222]。

*   **时间之箭**：大多数简单的[替换模型](@article_id:356723)是**时间可逆的**。这意味着，在统计上，从状态 A 到状态 B 的演化过程看起来与从状态 B 到状态 A 的过程相同。这是一个方便的属性，因为它意味着树的似然值不取决于我们将根放在哪里。然而，Felsenstein 的[算法](@article_id:331821)本身并不要求这个假设。如果我们使用一个时间方向很重要的非可逆模型，该[算法](@article_id:331821)仍然完美适用。唯一的区别是，我们现在必须明确定义树的根，因为[似然](@article_id:323123)值会根据[演化过程](@article_id:354756)假定的起点而改变 [@problem_id:2402799]。

*   **关于计算的实践说明**：当乘以许多概率（都是小于 1 的数）时，结果可能会变得极小，迅速超出计算机的精度并导致“数值[下溢](@article_id:639467)”错误。为了解决这个问题，剪枝[算法](@article_id:331821)的实现采用了一些巧妙的技巧。一种方法是在每个节点重新缩放条件[似然](@article_id:323123)向量，并记录[缩放因子](@article_id:337434)。另一种方法是使用对数进行所有计算，将乘法变为加法，并使用“log-sum-exp”技巧来稳定地处理求和。这些技术不会改变[算法](@article_id:331821)的逻辑或其最终结果，但它们对于使其在真实计算机上运行至关重要 [@problem_id:2747211]。

最后，这整套机制的目的是为一个假说赋予一个分数——一个似然值。该假说包括树的拓扑结构、其支长以及[替换模型](@article_id:356723)的参数。通过搜索能使我们观测数据的[似然](@article_id:323123)最大化的这些元素的组合，我们可以推断出最可能的演化历史 [@problem_id:2734873]。

### 独立[比较法](@article_id:356721)：跨物种性状比较

Felsenstein 的第二大贡献解决了一个不同但相关的难题。让我们暂时忘记 DNA，思考一下生物体的性状：体型大小、代谢率、奔跑速度。生物学家们长期以来一直对这些性状如何[协同演化](@article_id:303344)着迷。例如，体型较大的动物是否总是具有与其体型相比较低的代谢率？

朴素的方法是从许多物种中收集数据，将一个性状与另一个性状作图，然后寻找相关性。但这是一个统计陷阱。想象一下，我们发现大象和犀牛都体型大、速度慢，而老鼠和鼩鼱则体型小、速度快。这并不一定告诉我们存在一个普遍的[演化权衡](@article_id:313579)。这可能仅仅是因为大象和犀牛共享一个近期的、体型大、速度慢的祖先，而老鼠和鼩鼱共享一个近期的、体型小、速度快的祖先。这些数据点并非独立的；它们被历史联系在一起。

#### Felsenstein 的解决方案：比较差异

Felsenstein 的解决方案，即**[系统发育独立比较](@article_id:353066)法 (PICs)**，在概念上异常简单：停止比较物种本身，转而比较沿树的分支发生的独立的演化*变化*。

在树的每一个分叉处，即一个祖先世系分裂为两个的地方，我们可以计算一个“比较值”(contrast)。这个比较值代表了两个新世系之间发生的分化量。为了使这些比较值在整棵树上——从发生在一亿年前的古老分化到发生于一百万年前的近期分化——都具有可比性，它们必须被[标准化](@article_id:310343)。

该[算法](@article_id:331821)从末端向根部进行，很像剪枝[算法](@article_id:331821)。对于任意两个姐妹节点 $i$ 和 $j$（可以是末端节点或内部节点），其性状值分别为 $x_i$ 和 $x_j$，它们在父节点 $k$ 处的[标准化](@article_id:310343)比较值为：

$$c_{k} = \dfrac{x_{i} - x_{j}}{\sqrt{p_{i} + p_{j}}}$$

在这里，$p_i$ 和 $p_j$ 是从父节点 $k$ 到节点 $i$ 和 $j$ 的有效支长，代表了可供分化的时间量。计算完这个比较值后，[算法](@article_id:331821)会计算出祖先节点 $k$ 的估计性状值（作为其子节点方差加权的平均值）和一个新的有效支长，然后将这个祖先节点视为树中向上一级的新的末端节点 [@problem_id:2742866]。

对于一棵有 $n$ 个物种的树，结果是一组 $n-1$ 个独立的比较值。我们已将非独立的末端数据转化为一组统计上独立的数据点，每个点代表一次独立的演化分化。

#### 零截距的魔力

现在我们可以安全地检验[相关演化](@article_id:334289)了。我们计算体型大小的比较值和代谢率的比较值。当我们对一组比较值与另一组进行线性回归时，一个关键步骤是强制回归线通过原点（即，将 y 轴截距设为零）。

这不仅仅是为了统计上的方便。它是底层[演化模型](@article_id:349789)的直接而深刻的推论。一个比较值代表演化上的*变化*。如果在某个特定节点上，自变量（比如体型大小）的[演化变化](@article_id:325501)为零，那么我们的[零假设](@article_id:329147)是，我们应该预期[因变量](@article_id:331520)（[代谢率](@article_id:301008)）的[演化变化](@article_id:325501)也为零。一个为零的比较值意味着另一个性状的预期比较值也为零。回归线*必须*通过点 $(0,0)$，因为这个点代表了没有[演化变化](@article_id:325501)的定义本身 [@problem_id:1953888]。这是一个统计程序如何完美体现生物学假说的最优雅的例子之一。

通过为我们提供恰当考虑系统发育树的工具，Felsenstein 的方法让我们最终能够看清[演化模式](@article_id:356434)的本来面目，使其摆脱共同历史这一扭曲的透镜。