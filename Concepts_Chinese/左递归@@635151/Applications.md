## 应用与跨学科联系

我们花了一些时间来了解左递归，这个在我们文法规则中看似奇特的循环，其中一个事物在其定义的最左边由其自身来定义。初看之下，它可能像一个缺陷，一个在开始任何严肃工作之前需要被解开和“消除”的逻辑疙瘩。但在科学和工程领域，我们经常发现，最初被标记为“问题”的现象，实际上是通往更深层次理解的钥匙，或者在适当的情境下，是出人意料的优雅解决方案。

左递归也是如此。现在，让我们踏上一段旅程，去看看这个所谓的缺陷在哪些地方根本不是缺陷，而是一种强大、优美且极其有用的工具，它将抽象的文法世界与具体的计算任务联系起来。

### 机器的自然语言

你如何计算 $3 * 4 * 5$？你几乎肯定会从左到右计算：首先 $3 * 4$ 得 $12$，然后 $12 * 5$ 得 $60$。这种属性，即左[结合性](@entry_id:147258)，已深深植根于我们对算术的理解中。如果一个编译器要将人类可读的代码翻译成机器可执行的指令，它必须尊重这一约定。我们如何教一台机器这种从左到右的特性呢？

一种方法是编写一个体现这种特性的文法。像 $E \to E * T$ 这样的左递归文法完美地做到了这一点。文法本身的结构反映了计算的结构。要解析像 `w * x * y * z` 这样的表达式，文法会自然地将其分组为 `(((w * x) * y) * z)`。

这不仅仅是一种美学上的匹配；它为生成代码提供了一个直接的蓝图。想象一个简单的基于栈的计算器。要计算 $A * B$，你将 $A$ 推入栈，将 $B$ 推入栈，然后执行一条 `MUL` 指令，该指令弹出它们，将它们相乘，并将结果推回栈中。左递归文法可以用来极其优雅地生成这一系列指令。规则 $E \to E_1 * T$ 转化为一个简单的配方：首先，为子表达式 $E_1$ 生成代码（这会将其结果留在栈上），然后为 $T$ 生成代码（这会将其结果放在第一个结果之上），最后，追加 `MUL` 指令。这个过程，被称为语法指导的翻译，展示了左递归最光辉的时刻：不是一个需要解决的问题，而是一个将文法结构直接、直观地转化为计算行动的指南 [@problem_id:3673805]。

### 转换的代价

正如我们所见，一些解析方法——特别是那些试图从根向下构建[解析树](@entry_id:272911)的自顶向下解析器——会在左递归上“窒息”，进入无限循环。对它们而言，我们必须进行转换，将像 $S \to S a \mid b$ 这样的规则变成一组非左递归的规则，例如 $S \to b S'$ 和 $S' \to a S' \mid \epsilon$。这巧妙地解决了自顶向下解析器的无限循环问题。

但这种转换是“免费的午餐”吗？如果我们把这个新的、“修复”过的文法交给一个自底向上解析器会发生什么？这种解析器从叶子向上构建树，通常对左递归没有问题。

为了找出答案，我们可以看看自底向上解析器的“大脑”：一个名为 LR 自动机的[状态机](@entry_id:171352)。这个机器中的每个状态代表了解析器可能正在识别的一组模式。状态的总数是解析器复杂度的粗略度量。当我们进行这个实验——为原始的左递归文法和转换后的文法构建自动机时——一个显著的结果出现了。转换后的文法，即为自顶向下解析器“修复”过的那个，通常会生成一个具有*更多*状态的自动机 [@problem_id:3624974] [@problem_id:3655661] [@problem_id:3626884]。

消除左递归的行为引入了新的规则和空（$\epsilon$）产生式，这迫使自底向上自动机需要跟踪更多的可能性，从而使其复杂度膨胀。这是一个关于权衡的深刻教训。“解决方案”在一个领域中，却在另一个领域中引起了新的复杂性。它教导我们，文法的优雅并非绝对属性，而是相对于我们用来解释它的工具而言。

### 在选择的迷宫中航行

即使对于能够适应左递归的自底向上解析器，它仍然可能带来有趣的挑战，推动我们走向更复杂的设计。考虑一个典型的算术文法：$E \to E + T \mid T$。想象一个自底向上解析器刚刚成功地将一串标记识别为一个有效的 $T$。根据文法，这个 $T$ 也可能是一个有效的 $E$（通过 $E \to T$）。所以现在解析器处于一种模棱两可的状态。假设输入中的下一个符号是 `*` 号。解析器知道它不能在一个 $E$ 后面附加一个 `*`。但也许它刚刚找到的 $T$ 是一个更大的乘法的一部分，比如 $T * F$。

这就是“移入-归约冲突”的核心。解析器是应该“归约”它找到的 $T$ 成为一个 $E$，从而完成一条规则？还是应该“移入”即将到来的 `*` 号到它的栈上，希望能构建一个更大的表达式？一个简单的 $LR(0)$ 解析器，它只看当前状态，无法做出决定。它看到了两条有效的前进路径，因而陷入瘫痪 [@problem_id:3654995]。这不是文法的失败，而是解析器的局限性。文法通过其左递归，优美地揭示了需要更强智能的必要性。解决方案是赋予解析器“前瞻”输入流中下一个标记的能力——这种能力称为前瞻。正是这种源于左递归结构的冲突，是开发更强大的解析器如 SLR、LALR 和 LR(1) 的主要动机，这些解析器是现代编译器构造的主力军 [@problem_id:3626844]。

### 从左到右的意义流

到目前为止，我们一直专注于使用文法来识别输入的结构。但解析也是通往理解其*意义*的门户。这就是属性文法的领域，我们在这里为我们的文法规则附加计算。

想象一个简单的用于逗号分隔列表的左递归文法：$L \to L, \text{id} \mid \text{id}$。现在，假设我们不仅要验证列表，还想计算每个逗号的确切字符位置。要找到第三个项目后的逗号的位置，我们需要知道前三个项目的总长度加上前面两个逗号的长度。这个信息必须在我们处理列表时从左到右流动。

在这里，左递归结构是这种计算的完美伙伴。当解析器构建向下向左生长的树时，我们可以使用“继承属性”沿着树的左侧主干向下传递信息。在每个对应于规则 $L_1 \to L_2, \text{id}$ 的节点上，我们可以继承到目前为止整个列表的起始位置。一旦子列表 $L_2$ 被完全处理，它就可以计算自己的长度，并将该信息作为“[综合属性](@entry_id:755750)”向上传递。有了起始位置和子列表的长度，计算逗号的位置就变得轻而易举。这种信息在[解析树](@entry_id:272911)上向下流动然后向上传递的优雅舞蹈，正是由文法的左递归结构所促成的 [@problem_id:3668936]。文法形式和计算流程之间的这种协同作用是语法指导设计的基石。

### 通用机与通往人类语言的桥梁

我们已经看到，左递归可以是朋友也可以是敌人，这取决于解析策略。这就引出了一个问题：我们能否发明一种强大到不在乎这些的解析器？一个能接受我们能想到的*任何*[上下文无关文法](@entry_id:266529)的解析器，无论是左递归、歧义性还是其他问题？

答案是响亮的“是”。像 Earley 解析器和 GLR（广义 LR）这样的算法正是如此。这些算法诞生于处理自然语言（NLP）这一困难而混乱的领域，人类语言以其臭名昭著的[歧义](@entry_id:276744)性和对简单语法限制的抗拒而闻名，这些解析器是解析领域的通用机器。它们使用巧妙的动态规划技术（通常称为图表解析）来同时探索所有可能的解析路径，巧妙地避开了自顶向下解析器的无限循环和确定性自底向上解析器的冲突 [@problem_id:3639833]。

一个 Earley 解析器只是从容地处理左递归规则，将适当的项目添加到其图表中，然后继续前进，其[记忆化](@entry_id:634518)方案保护它免受无限循环的影响 [@problem_id:3639815]。如果一个文法有[歧义](@entry_id:276744)，它不会失败；它会勤奋地生成所有可能[解析树](@entry_id:272911)的紧凑表示。

当然，这种巨大的能力和灵活性是有代价的：性能。对于定义大多数编程语言的那些行为良好、确定性的文法，LALR(1) 解析器生成器速度极快。而 Earley 解析器在最坏情况下的速度则较慢。在这里，我们发现了计算机科学的一个宏大、统一的原则：通用性与效率之间的权衡。

因此，左递归不仅仅是编译器构造中的一个技术细节。它是一个镜头，通过它我们可以审视这一根本性的权衡。它教导我们要明智地选择我们的工具：为可预测的、工程化的环境选择专门化的高速工具，为人类语言的狂野和不可预测的领域或新思想的快速原型设计选择稳健的通用工具。它是一座桥梁，连接着编程语言的形式世界和语言学的复杂世界，提醒我们，即使在机器的精确逻辑中，也存在着不同视角、策略和设计哲学的空间。