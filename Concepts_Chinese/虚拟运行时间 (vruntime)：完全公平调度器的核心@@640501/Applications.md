## 应用与跨学科联系

现在我们已经熟悉了[完全公平调度器](@entry_id:747559)核心那条优美而简单的规则——虚拟运行时间的原则——我们可能会倾向于认为这只是一个聪明的软件技巧，一个解决技术问题的巧妙方案。但真正的魔力始于我们追问：这个想法将我们引向何方？我们能用它构建什么？事实证明，“总是运行那个落后最多的”这一原则，不仅仅是修复单台计算机的方案；它是在我们深度互联的数字世界中组织工作和驯服复杂性的强大概念。在本章中，我们将穿越虚拟运行时间令人惊奇且影响深远的应用领域，从云计算的基石到计算本身的物理极限。

### 驯服众生：从进程到容器

想象一下，你管理的不是你笔记本电脑上的几个应用程序，而是一个为全球云服务提供商服务的庞大数据中心。成千上万的客户正在运行数百万个服务，所有这些都在争夺处理时间。你如何才能让这片混乱井然有序？你如何确保支付大额服务费用的客户比运行一个微小免费博客的人获得更多资源，同时又防止任何一个服务贪婪地独占系统？

这正是虚拟运行时间优雅之处的真正闪光点。调度器不需要一个复杂的中央计划。它只是应用相同的简单规则，但稍作调整：**权重**。不是让每个进程都平等，我们可以为每个进程分配一个权重 $w_i$。调度器更新虚拟运行时间 $v_i$ 的规则变成：对于 $\Delta t$ 的实际运行时间，虚拟运行时间增加 $\Delta v_i \propto \Delta t / w_i$。

这样做的结果是什么？调度器在不懈地追求保持所有虚拟运行时间相等的过程中，必须给予权重较高的进程更多的真实时间。如果进程 A 的权重是进程 B 的两倍，那么为了让它们的虚拟运行时间增加相同的量，它必须运行两倍于 B 的时间。美妙的结果是，在任何相当长的时间段内，任何进程 $i$ 获得的 CPU 时间比例 $f_i$ 只是从系统行为中自然涌现的：它等于其权重除以所有竞争进程的总权重，$f_i = w_i / \sum_j w_j$ [@problem_id:3665364]。不需要复杂的记账；按比例共享是局部规则的涌现属性。

这就是 Linux **[控制组](@entry_id:747837)**（**Control Groups**），或称 `[cgroups](@entry_id:747258)` 背后的原理，这项技术支撑着像 [Docker](@entry_id:262723) 和 [Kubernetes](@entry_id:751069) 这样的现代容器化技术。我们可以将成千上万个进程分组到一个 `cgroup` 中，并为其分配一个权重，将整个组视为一个可调度的实体。这使得云服务提供商只需调整一个权重参数，就能销售不同级别的服务。

但是，如果你需要的不仅仅是“软”优先级呢？如果客户支付的是一个“硬”保证——比如，每100毫秒不超过40毫秒的CPU时间——以确保可预测的计费，该怎么办？`vruntime` 系统与这种硬性限制完美配合。想象一下两个服务 A 和 B，权重相等。它们开始时以 50/50 的比例共享 CPU。但是服务 A 有一个硬性上限。一旦它达到 40ms 的配额，它就会在剩下的 100ms 周期内被强制休眠。调度器看到 A 不再可运行，就简单地将 100% 的 CPU 交给服务 B。当下一个周期开始时，A 被允许再次运行，公平的 50/50 共享恢复，直到 A 再次达到其上限[@problem_id:3630057]。这种按比例共享的公平性与硬性限制的节流相结合，提供了构建云所需的那种灵活性和控制力的完美融合。

### 世界中的世界：[虚拟化](@entry_id:756508)的挑战

当我们考虑[虚拟化](@entry_id:756508)时，情况变得更加复杂。一个虚拟机（VM）是一个完整的[操作系统](@entry_id:752937)，有自己的调度器，作为宿主机上的单个进程运行。这意味着我们有一个调度器（客户机）运行在另一个调度器（宿主机的[虚拟机](@entry_id:756518)监控程序）之上。如果客户机[操作系统](@entry_id:752937)甚至没有完[全控制](@entry_id:275827) CPU，它如何可能对其自己的进程“公平”？

让我们比较两种[虚拟机](@entry_id:756518)监控程序调度器的设计。一个简单的方法可能是“基于信用点”的系统：在一个时间周期（比如 10ms）开始时，你根据每个 VM 的权重给予其一定数量的信用点。当它运行时，它会消耗信用点。问题在于，在这 10ms 的窗口内，调度器可能不会区分有很多信用点的 VM 和只有少量信用点的 VM；它可能只是对它们进行均等的[时间分片](@entry_id:755996)。这导致了粗糙、不平滑的公平性。

使用 `vruntime` 的类 CFS 设计则要优雅得多[@problem_id:3689869]。当一个 VM 一直在休眠时（也许在等待用户输入），它的虚拟运行时间会暂停。与此同时，其他活动 VM 的 `vruntime` 会持续攀升。当第一个 VM 醒来时，它的 `vruntime` 要低得多，并立即被[虚拟机](@entry_id:756518)监控程序优先处理。这提供了即时的响应性——我们所期望的“快捷”感觉——同时自然地维持了长期的按比例共享。`vruntime` 机制不仅公平；它完美地适应了现代工作负载的突发性、交互性特点。

但还有一个更微妙的问题。从 VM 内部看，世界似乎是正常的。但从外部看，[虚拟机](@entry_id:756518)监控程序可以抢占整个 VM 去做其他事情——运行另一个 VM，处理宿主机任务等。对客户机[操作系统](@entry_id:752937)来说，这段“被窃取的时间”是完全不可见的。就好像墙上的时钟突然向前跳了一样。

想象一下客户机调度器正在运行一个进程。[虚拟机](@entry_id:756518)监控程序窃取了 10ms。当客户机重新获得控制权时，它的调度器可能认为该进程运行了整整 10ms，并尽职地增加其 `vruntime`，从而不公平地惩罚了它。这个进程实际运行时间为 0ms，却被“收取”了 10ms 的费用！这完全破坏了客户机级别的公平性。

解决方案是一种名为**[半虚拟化](@entry_id:753169)**（**paravirtualization**）的卓越工程合作。宿主机虚拟机监控程序使用一个特殊的私有通道，向客户机[操作系统](@entry_id:752937)报告被窃取的时间量 $\sigma$。一个聪明的客户机调度器随后可以使用这个信息。当它计算要添加到进程的 `vruntime` 时，它不使用流逝的墙上时钟时间；它使用实际执行时间：墙上时钟时间减去被窃取的时间[@problem_id:3673700]。通过意识到这段“丢失的时间”，客户机调度器即使在自己的小世界被一个更高权限者不断打断的情况下，也能维持完美的公平性。

### [计算的物理学](@entry_id:139172)：局部性、延迟和极限

到目前为止，我们都将 CPU 视为抽象、相同的处理单元。但现代硬件的物理现实要混乱得多，而这种混乱为我们简单的公平理想带来了深远的挑战。

一个关键的例子是**[非一致性内存访问](@entry_id:752608)（NUMA）**。在一个大型多核服务器中，并非所有内存到所有 CPU 的距离都相等。每个 CPU 都有一组“本地”内存，访问速度非常快。访问连接到另一个 CPU 的内存——“远程”内存——则要慢得多。这就产生了一个根本性的权衡。想象一个进程在 CPU 1 上运行，其所有数据都在 CPU 1 的本地内存中。现在，假设 CPU 2 变为空闲。为了系统范围的公平性，调度器可能会倾向于将该进程迁移到空闲的 CPU 2。但这样做会迫使该进程进行缓慢的远程内存访问，从而严重影响其性能。

这就是经典的**局部性与公平性**的权衡。我们是应该将进程固定在其“本地”节点以保持其速度，即使这意味着其他 CPU 处于空闲状态？还是为了公平而移动它，接受性能损失？现代调度器必须不断做出这个艰难的决定，使用复杂的启发式方法来判断迁移的成本何时值得公平性的收益。工程师使用特殊的性能计数器来测量诸如线程内存访问中本地访问的比例之类的事情，帮助他们量化和调整这种微妙的平衡[@problem_id:3663587]。

内核本身的物理实现也引入了另一个限制。在某些时刻，内核必须执行精细的操作且不能被中断。它通过暂时禁用抢占来实现这一点，实际上是挂起了一个“请勿打扰”的标志。当这个标志挂起时（可能持续一个有界时间 $B$），一个本应被停止的进程可能会继续运行，而一个刚刚唤醒的进程的调度可能会被延迟。

这个微小、有界的不完美会产生公平性的涟漪。一个超出其时间片 $B$ 的任务获得了 $+B$ 的不公平 `vruntime` 优势。同时，另一个在那段时间被饿死的任务则遭受了 $-B$ 的劣势。因此，瞬时最大公平性误差，即最优待和最劣待任务之间的差异，可能高达 $2B$ [@problem_id:3652510]。这表明，在真实世界中，公平不是一个绝对的保证，而是一个不断与物理实现不可避免的不完美作斗争的理想。

### 当公平导致僵局

有时，调度器对公平的高尚追求可能会产生意想不到的病态后果。其中最著名的例子之一是调度器与同步锁（如**[读写锁](@entry_id:754120)**）之间的相互作用。这种锁允许多个“读者”线程并发访问资源，但要求一个“写者”线程拥有独占访问权。

考虑一个单 CPU 系统，一个写者线程想要执行更新。它必须等待所有当前的读者完成。但如果有一股持续不断的新读者线程醒来怎么办？一个新唤醒的线程一直在休眠，所以它的 `vruntime` 很低。“公平的”CFS 调度器看到这个低 `vruntime`，会急切地调度新的读者，可能会抢占写者。如果读者到达得足够快，写者可能会被一连串“更应得”的读者永久抢占。写者饿死了，不是因为一个 bug，而是调度器试图做到公平的直接结果！[@problem_id:3687680]。

你如何解决这样的悖论？解决方案需要合作。你要么让锁变得“更智能”——例如，一旦有写者在等待，就阻止新读者获取锁。或者，你可以给调度器一个提示：通过改变调度权重，你可以让写者“更重”，读者“更轻”，告诉调度器写者的工作更重要。作为最后的手段，甚至可以将写者移至一个[实时调度](@entry_id:754136)类，该类在 `vruntime` 公平性的正常规则之外运作。这表明，一个调度器，无论多么聪明，都不是在真空中运作的；它是一个复杂的、相互作用的系统的一部分。

### 超越计算机：一个普适原则？

也许关于 `vruntime` 原则最令人惊讶的是它的普适性。要看到这一点，让我们从计算机转向一个类似的问题：在几个房间里安排学生演讲[@problem_id:3659890]。

想象一下，你是一所大学的教务长，有两个演讲室（$m=2$）和三个需要演讲的学生（$A$、$B$ 和 $C$）。一天开始时，$A$ 和 $B$ 已经准备好并占用了两个房间。学生 $C$ 因为排练耽搁而迟到了。公平的目标是，在一天中，每个学生都应该得到总演讲容量的均等份额——也就是说，每个学生都应该能演讲三分之二天的时间。

一个“完全公平”的教务处会如何解决这个问题？当中午学生 $C$ 终于到达时，应该怎么做？一个幼稚的调度器可能会给 $C$ 自己的房间，迫使 $A$ 和 $B$ 共享另一个房间，导致演讲时间不均。一个惩罚性的调度器可能会把 $C$ 放在“队尾”。

但一个受 CFS 启发的调度器会更微妙。它会认识到，在中午时分，学生 $A$ 和 $B$ 各自积累了 4 小时的“虚拟演讲时间”。为了公平起见，学生 $C$ 应该被视为也拥有 4 小时的[虚拟时间](@entry_id:152430)。这使他们处于平等的地位。现在，有三个学生和两个房间，调度器不断轮换哪两个在演讲，总是优先考虑最近演讲最少的那个。教务处可以维护一个每个学生总演讲时间（他们的 `vruntime`）的全局排行榜，并总是将房间分配给榜上时间最少的两个学生。在一天中，这个简单的局部规则会自动确保每个学生都得到他们公平的三分之二份额。

这个类比显示了核心思想的力量。无论是调度硅片上的线程还是学生的演讲，`vruntime` 都提供了一个强大、去中心化且优雅的机制来实现按比例的公平性。它告诉我们，也许对公平的追求，无论是在一个社会中还是在一个硅芯片中，其根本在于诚实地记录下谁在等待，并给予他们应有的机会。