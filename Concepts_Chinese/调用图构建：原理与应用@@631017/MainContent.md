## 引言
现代软件系统如同一座座蔓延扩张的城市，庞大而复杂。对于开发者、编译器和安全分析师而言，没有地图就想在这片复杂中穿行是一项艰巨的任务。[调用图](@entry_id:747097)正是这张至关重要的地图——它是一种结构化表示，描绘了程序中不同函数之间如何相互通信。构建[调用图](@entry_id:747097)是理解、优化和保障软件安全的基础。然而，构建一张精确的地图颇具挑战，尤其是对于动态语言，其函数目标在源代码中并不总是清晰可见。这一知识鸿沟——如何在一个复杂多变的程序中可靠地绘制出其关系图——是[静态分析](@entry_id:755368)领域的核心问题。本文将阐明[调用图](@entry_id:747097)的构建过程，引导您了解使其成为可能的核心概念。我们将首先深入探讨构建图的基本原理和机制，然后探索其多样化且强大的应用。

## 原理与机制

想象一下，你正试图在一座没有地图的庞大古城中穿行。你可能知道自己当前的位置和周边的街道，但对整个城市的结构却一无所知。这条路通向何方？我该如何从市集走到图书馆？北区和南区是否相连？一个计算机程序，尤其是大型程序，与这座城市非常相似。它的函数是各个区域和地标，而函数间的调用则是纵横交错的道路和小巷。**[调用图](@entry_id:747097)**就是我们的地图。它是一个简单而深刻的抽象：一个有向图，其中节点代表函数，从函数 $A$ 指向函数 $B$ 的边意味着 $A$ 可能会调用 $B$。

这张地图不可或缺。对于编译器，它揭示了优化的机会——或许一条短小的死胡同（一个小函数）可以被填平并并入主干道（内联）。对于软件工程师，它是理解和调试复杂系统的工具。对于安全分析师，它追踪信息的流动，展示一个被污染的数据进入某个函数后，可能会如何[扩散](@entry_id:141445)到整个程序。[调用图](@entry_id:747097)构建的目标就是绘制这张地图，并且要做到*稳健*（soundly）——这意味着，我们的地图必须显示出每一条可能通行的道路，即使其中包含一些很少使用的道路。遗漏任何一条道路都可能是灾难性的。

但是，你如何为一座不断变化的城市绘制地图，那里的路牌可以随时被改写？这就是我们面临的美妙挑战。我们将揭示的原理不仅关乎编译器，更关乎如何对任何复杂的动态系统进行推理。

### 简单部分：识别路牌

让我们从城市中简单明亮的部分开始。在许多情况下，[函数调用](@entry_id:753765)是完全明确的：代码写着 `call function_B()`。绘制这部分地图非常简单；我们只需从当前函数向 `function_B` 添加一条边。

当名称不唯一时，第一个转折出现了。现代编程语言允许同一个函数名（比如 `f`）指向不同的函数，这个特性被称为**重载**（overloading）。函数 `f(int)` 与 `f(double)` 是不同的。此外，语言使用**命名空间**（namespaces）来防止大型项目中的名称冲突，就像两个不同的城市都可以有“主街”一样。因此，我们可能会有 `Database::connect()` 和 `Graphics::connect()`。

编译器，我们的地图绘制者，如何知道该画哪条路呢？它像一个明智的旅行者一样行事：它会观察上下文。首先，如果提供了完整的“地址”——一个如 `Database::connect()` 的限定名称——它会将搜索范围缩小到 `Database` 命名空间。如果名称未限定，它会查看当前“开放”的命名空间以及调用的签名（参数的数量和类型）。如果只有一个函数匹配，路径就很清晰。但如果存在歧义呢？例如，如果两个不同的命名空间都处于打开状态，并且都定义了函数 `f(int)`，该怎么办？[@problem_id:3625848]

在这里，我们遇到了第一个基本原则：**为确保稳健性而采取保守策略**。当面临[歧义](@entry_id:276744)时，一个稳健的分析必须进行过近似（over-approximate）。它必须假设*任何*可能的候选项都可能是真实的目标。因此，它会向*每个*匹配的函数绘制一条边。我们的地图可能会因为潜在路径而变得有些杂乱，但我们可以确信它不会遗漏任何真实的路径。这是**可能分析**（may-analysis）的核心宗旨：我们关心的是*可能*发生什么，而不仅仅是*必然*发生什么。

### 迭代之舞：绘制未知道路

当我们遇到**间接调用**时，真正的魔法开始了。这在 C/C++ 的函数指针、面向对象语言的虚方法或函数式语言的头等函数中都会发生。代码并未指明目标；它提供了一个变量、一个指针，然后说“调用这个指针指向的任何东西”。路牌是空白的，有待在运行时填写。我们怎么可能绘制出这样的地图呢？

我们无法确切知道目标，但或许可以确定*可能的目标集合*。这就是**[指针分析](@entry_id:753541)**（points-to analysis）的目标。对于程序中的每个函数指针，我们希望计算出它*可能*指向的函数集合。我们可以将其视为一个从程序源代码中推导出的[逻辑约束](@entry_id:635151)系统：
- 如果我们看到赋值语句 `p = `，我们就知道函数 `f` 是 `p` 的一个可能目标。用集合符号表示，我们生成约束 $Pt(p) \supseteq \{f\}$。
- 如果我们看到 `q = p`，那么 `p` 能指向的任何东西，`q` 也能指向。这给了我们约束 $Pt(q) \supseteq Pt(p)$。

这些约束常常是相互纠缠和递归的。`p` 的集合依赖于 `q`，`q` 可能依赖于 `r`，而 `r` 又可能反过来依赖于 `p`。这似乎是一个先有鸡还是先有蛋的问题。解决方案是一种优雅而强大的算法，称为**[不动点迭代](@entry_id:749443)**（fixed-point iteration）。

想象一个相互连接的水箱网络，每个指针变量对应一个水箱。每个水箱将容纳可能指向的函数目标这“一池水”。约束条件就是连接它们的管道。我们从所有水箱都为空开始（$\bot$，即我们抽象世界的底元素）。然后，我们打开“水源”（即 `p = ` 赋值语句）并让系统运行。水根据规则（`q = p`）从一个水箱流向另一个水箱，将它们注满。任何水箱中的水位都只会上升，绝不会下降。这个属性被称为**[单调性](@entry_id:143760)**（monotonicity）。由于我们程序中的函数数量是有限的，“水”的总量也是有限的。水箱不可能永远填充下去。最终，水位将停止变化。系统达到了一个稳定状态，即一个**[不动点](@entry_id:156394)**（fixed point）。这个最终状态就是我们的答案：每个变量的指针指向集合。[@problem_id:3625868]

让我们来看看这个舞蹈的实际过程。考虑一个包含两个变量 $p$ 和 $q$ 以及一个函数全集 $\{a, b, c\}$ 的微型系统。程序的逻辑转化为一个[转移函数](@entry_id:273897) $F$，该函数在每一步都更新 $(p, q)$ 的指针指向集合 $(P, Q)$。假设规则如下：
1. `p` 总是获得 `a`。
2. `q` 获得 `p` 所拥有的任何东西。
3. 如果 `q` 可能是 `a`，那么 `p` 也获得 `b`。
4. 如果 `p` 可能是 `b`，那么 `q` 也获得 `c`。

我们从第0步开始，此时 $X_0 = (P^{(0)}, Q^{(0)}) = (\emptyset, \emptyset)$。
- **迭代 1**：我们将规则应用于 $X_0$。`p` 获得 `{a}`。`q` 获得 `p` 的内容，所以 `q` 获得 `{a}`。现在，由于 `a` 在 `q` 的集合中，`p` 获得 `{b}`，使其集合变为 `{a, b}`。又因为 `b` 现在在 `p` 的集合中，`q` 获得 `{c}`，使其集合变为 `{a, c}`。我们的新状态是 $X_1 = (\{a, b\}, \{a, c\})$。状态已发生变化。
- **迭代 2**：我们再次应用规则，这次是应用于 $X_1$。`p` 以 `{a, b}` 开始。`q` 以 `{a, c}` 开始，并从 `p` 获取所有内容，因此其集合变为 `{a, b, c}`。向 `p` 添加 `b` 和向 `q` 添加 `c` 的条件已经满足，因此没有新的函数被添加进来。状态变为 $X_2 = (\{a, b\}, \{a, b, c\})$。状态再次发生变化。
- **迭代 3**：我们将规则应用于 $X_2$。你可以验证，这次没有新的函数被添加。集合保持为 $(\{a, b\}, \{a, b, c\})$。状态是稳定的。我们已经达到了**最小[不动点](@entry_id:156394)**（least fixed point）。[@problem_id:3625934]

这个迭代过程保证会终止，并为给定的约束集找到最精确的可能解，因为我们的分析是**单调的**（集合只会增长），并且它在一个**有限高度的格**（lattice of finite height）上运行（只有有限数量的函数可以添加）。这就是使[静态分析](@entry_id:755368)成为可能的美妙理论基础。[@problem_id:3625868] [@problem_id:3625928]

### 永恒的权衡：精度与成本

我们的地图绘制工作可以有不同程度的精细度，这导致了一个经典的工程权衡：精度与成本。一幅快速、粗略的草图制作成本低，但可能具有误导性。一幅详尽的、勘测级别的地图高度精确，但需要付出巨大的努力。

#### 流敏感性：顺序重要吗？

一种简单快速的分析可能是**流不敏感的**（flow-insensitive），意味着它忽略语句的顺序。它将程序视为一大袋语句。如果一个变量 `p` 在第10行被赋值为 ``，在第100行被赋值为 ``，流不敏感的分析会简单地断定 `p` 在程序中的*任何地方*都可能指向 `f_a` 或 `f_c`。这会导致大量伪边（spurious edges）。

更精确的**流敏感**（flow-sensitive）分析则尊重程序的[控制流](@entry_id:273851)。它知道在第100行之后，`p` 指向 `f_c`，而它曾指向 `f_a` 这一事实对于此后进行的调用不再相关。问题在于，通过所有可能的程序路径来追踪这些信息是昂贵的。

一个名为**[静态单赋值](@entry_id:755378)（SSA）**形式的绝妙编译器技巧提供了一个折中方案。在分析之前，程序被转换，使得每个变量只被赋值一次。如果一个变量需要被重新赋值，它会得到一个新名字（例如，`p_1`，`p_2`）。这种简单的重命名使得流不敏感风格的分析能够达到流敏感的精度，因为不相关的赋值不再相互污染对方的指针指向集合。例如，一个通过指针 `p` 进行两次独立调用的程序可能会被不精确地分析。但在SSA转换后，这两个调用可能引用不同的版本，`p_2` 和 `p_3`，它们的指针指向集合要小得多，也更准确。在我们的[调用图](@entry_id:747097)中，边的数量可以急剧减少，在一个简单案例中从6条减少到3条。[@problem_id:3625938]

#### 上下文敏感性：谁在调用？

另一个精度维度是**上下文敏感性**（context-sensitivity）。一个函数 `h` 可能从两个不同的地方被调用。在一次调用中，它被赋予一个 `A` 类型的对象；在另一次调用中，被赋予一个 `B` 类型的对象。**上下文不敏感**（context-insensitive）的分析将这两种情况合并。它只分析 `h` 一次，并假设其参数可能是 `A` 或 `B`。如果 `h` 进行了一个虚调用，分析将会添加指向 `A` 和 `B` 的方法的边，即使在 `A` 的上下文中进行的调用永远不可能调用 `B` 的方法。

而**上下文敏感**（context-sensitive）的分析则更为谨慎。它会分析 `h` 两次：一次是针对 `A` 的调用，另一次是针对 `B` 的调用。在每个上下文中，它都可以精确地解析虚调用。这可以发挥惊人的威力，剪除不可能的路径，揭示真实的程序结构。在一个巧妙的例子中，上下文不敏感的分析得出结论，四个不同的调用点各自可能调用两个函数之一（总共8条边），而一个简单的[上下文敏感分析](@entry_id:747793)则能正确地确定每个调用点只调用一个特定的函数（总共4条边）。[@problem_id:3647929]

代价是什么？一个完全的[上下文敏感分析](@entry_id:747793)可能代价高昂，导致分析时间和内存呈指数级增长。分析可能需要为每个调用上下文创建函数代码或摘要的多个“克隆”。这是最赤裸裸的权衡：一个基于摘要的图可能耗费27个单位的内存，而同一个程序的完全内联（上下文敏感）版本可能耗费94.5个单位，而这一切只是为了移除一条伪边。[@problem_id:3625859] [静态分析](@entry_id:755368)的艺术在于找到正确的[平衡点](@entry_id:272705)——选择恰到好处的上下文或流敏感性，以便在不必为分析完成而永久等待的情况下完成任务。

### 绘制真实世界

真实世界的程序带来了更棘手的挑战。代码通常被分割成许多文件或库，并分开编译。要构建一个**全程序[调用图](@entry_id:747097)**（whole-program call graph），分析器不能只对单个文件运行。它必须迭代操作，一次处理一个**翻译单元**（translation unit），生成部分摘要，并将这些信息合并到一个全局图中。这个过程会重复进行，在模块间传播信息——例如，在库 `B` 中发现的一个新函数可能是程序 `A` 中某个函数指针的目标——直到达到一个全局[不动点](@entry_id:156394)。这里的[合并操作](@entry_id:636132)符，正如你可能猜到的，是集合的并集：我们总是在积累知识。[@problem_id:3625843]

那么，终极的通配符——**反射**（reflection）呢？像 Java 这样的语言允许程序在运行时通过字符串构造方法名，然后调用它。例如 `invoke("m" + "1")`。在这里，[调用图](@entry_id:747097)分析本身必须变成一名侦探，执行**字符串分析**来预测所有可能生成的字符串。为了保证稳健性，它必须采取保守策略，将任何与可能的字符串名称和签名相匹配的方法都视为潜在目标。[@problem_id:3625850]

这也迫使我们面对**开放世界问题**（open-world problem）。我们的分析只能看到我们提供给它的代码。但是，一个反射调用可能指向一个在运行时从网络动态加载的类中的方法。一个真正稳健的分析必须保持谦逊。它要么必须假设一个**封闭世界**（即不会加载其他代码），要么通过为任何不匹配已知方法的字符串添加指向代表“外部未知代码”的特殊节点的边来承认未知。[@problem_id:3625850]

最后，关键是要记住我们的地图是用来做什么的。[调用图](@entry_id:747097)是一个语义工具。它应该代表源代码中所表达的*程序员的意图*。一个聪明的编译器可能会将**尾调用**（tail call）优化成一个直接跳转，从而绕过标准的调用-返回机制。如果我们的分析工具从最终的机器代码构建图，它可能会完全错过这个语义上的调用，导致该图对于程序理解而言是不稳健的。一个鲁棒的[调用图](@entry_id:747097)构建策略必须着眼于源码级别的语义，将一个经过[尾调用优化](@entry_id:755798)的跳转视为其真正所代表的：一个函数对另一个函数的调用。[@problem_id:3625931]

从简单的名称解析到[不动点迭代](@entry_id:749443)的递归之舞，从精度与成本的权衡到反射的未知前沿，[调用图](@entry_id:747097)的构建是一段发现之旅。它是[静态分析](@entry_id:755368)这一宏大挑战的一个缩影：从程序的静态、书面形式中推断出其动态的、鲜活的行为。这是一场在充满可能性的世界中寻求确定性的探索，其武器是格、单调性和迭代这些优美而统一的原则。

