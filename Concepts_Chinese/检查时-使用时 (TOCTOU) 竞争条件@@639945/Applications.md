## 应用与跨学科联系

既然我们已经把“[检查时-使用时](@entry_id:756030)”这头野兽放在显微镜下仔细观察过了，现在就让我们看看它在野外何处出没。你可能会感到惊讶。这并非存活于[操作系统](@entry_id:752937)尘封角落里的某种深奥错误。它无处不在，是“提出问题”和“根据答案行动”之间存在时间流逝这一简单事实的直接后果。而在计算机的世界里，眨眼之间就能发生数十亿件事，那微小的时间间隙就像一道鸿沟，足以容纳任何形式的恶意行为。

### 文件系统游乐场

最常见到 [TOCTOU](@entry_id:756027) 漏洞的地方是[文件系统](@entry_id:749324)，即我们数据赖以生存的由目录和文件构成的数字景观。想象你正在编写一个程序。你想创建一个新的配置文件，但前提是该文件尚不存在。最自然、最符合常理的逻辑是先检查，如果不存在再创建 [@problem_id:3689375]。你看了看，发现一切顺利，于是你采取行动。

但计算机比你快。在你的程序“检查”和“行动”之间那微观的、纳秒级的间隙里，一个恶意的小妖精可以釜底抽薪。在你的程序看到名为 `config.txt` 的文件不存在之后，这个小妖精可以创建自己的 `config.txt`——但它不是一个文件，而是一个[符号链接](@entry_id:755709)，一种重定向，指向某个远比它敏感的东西，比如系统的密码文件。当你的程序继续“行动”，自豪地创建并写入它认为是新的、安全的 `config.txt` 时，它就大错特错了。它掉进了陷阱，在系统的皇冠瑰宝上肆意涂抹。

我们如何挫败这个小妖精？我们不按它的游戏规则来。我们不给它可供玩耍的间隙。我们不与[操作系统内核](@entry_id:752950)进行两步对话，而是发出一个单一的、原子的请求。我们说：“亲爱的内核，全能的系统管理者，请为我创建这个文件，但必须*在它绝对不存在的条件下*才这样做。顺便，请拒绝任何最后一刻的[符号链接](@entry_id:755709)。” 内核能够将这种检查与行动作为一个单一、不可分割的操作来执行，并乐于效劳。这就是使用像 `O_CREAT | O_EXCL` 和 `O_NOFOLLOW` 这样标志的现代系统调用的目的。间隙被关闭了。

当执行操作的程序拥有特殊权限时，风险会变得异常之高。一个 `[setuid](@entry_id:754715)` 程序，以系统超级用户的身份运行，试图在像 `/tmp` 这样的共享目录中创建临时文件，是典型的“被迷惑的代理人” [@problem_id:3685846]。这个特权程序被攻击者迷惑，误用了它的权力。攻击者的[符号链接](@entry_id:755709)不仅会损坏用户自己的文件，还可能导致整个系统被攻破。

这催生了攻防之间一场优美的进化之舞。一个强大的防御模式已经出现：不依赖名称，依赖句柄。一个安全的程序不会反复使用像 `/srv/shared/build.out` 这样的路径，而是会首先请求父目录 `/srv/shared` 的句柄——一个文件描述符 [@problem_id:3642422]。这个文件描述符作为一个安全的“锚点”，指向一个特定的位置。从那时起，所有操作都相对于该锚点执行。程序告诉内核：“请*在我持有句柄的这个目录内*为我创建 `build.out`。” 攻击者再也无法通过操纵通往该目录的路径组件来欺骗程序，因为程序已经“身处其中”了。

一旦你获得了文件的句柄——宝贵的文件描述符——黄金法则是：*绝不放手*。不要再回头使用文件名进行后续操作。这就像拥有了国王的私钥，却坚持在公共广场上大声呼喊他的名字来称呼他；你永远不知道谁会回应。例如，一个安全的构建服务在创建文件时会获取一个文件描述符，然后只使用像 `fchmod()` 和 `write()` 这样基于描述符的调用来进行所有后续修改，从而完全不受任何进一步的路径名诡计的影响 [@problem_id:3685829]。而攻击者方面，他们也变得更加老练，使用像 `inotify` 这样的内核通知系统来精确地安排攻击时机，这使得这些防御措施变得更加关键。

这场持续的猫鼠游戏推动了越来越具体和强大的工具的诞生。我们现在有了系统级的内核策略，可以阻止非特权用户为他们不拥有的文件创建硬链接，从而挫败一种更微妙的 [TOCTOU](@entry_id:756027) 攻击 [@problem_id:3685790]。我们有了像 `RENAME_EXCHANGE` 这样的专门[原子操作](@entry_id:746564)，可以在一步之内交换两个文件，非常适合像日志轮转这样的任务，而永远不会让文件名处于无人看管的状态 [@problem_id:3687902]。对于创建临时文件，我们甚至有一种方法可以向内核请求一个*完全没有名字*的文件 (`O_TMPFILE`)，这是一个在[文件系统](@entry_id:749324)中完全不可见的无名 [inode](@entry_id:750667)，直到你准备好将其原子地链接到某个位置 [@problem_id:3685846]。这些工具中的每一个都证明了理解检查与使用之间竞争的深刻实践重要性。

### 一个普遍原则

那么，这一切都只是关于文件吗？完全不是！这个原则要普遍得多。检查与使用的分离是一种普遍的行动模式，因此这个漏洞以许多其他形式出现，揭示了系统中看似不相关的部分之间美妙的统一性。

考虑登录你的电脑这个行为。系统验证你的密码（“检查”）。如果正确，它会继续启动你的用户会话——加载你的 shell、桌面环境、启动应用程序（“使用”）。但如果那个以最高系统权限运行的登录程序，在验证你之后、但在放弃自身权限成为你之前，才去查找你的 shell 程序的路径呢？在那微小的时间间隙里，攻击者可以操纵环境，将路径指向一个恶意程序，而不是你信任的 shell。被迷惑的特权登录进程会尽职地执行攻击者的代码。解决方案再次与[文件系统](@entry_id:749324)的情况在概念上相似：一个单一的、原子的内核原语，它使用来自成功认证的不可伪造的令牌，并以一个不可分割的步骤，用正确的用户凭证设置新进程并执行正确的程序 [@problem_id:3689463]。

让我们来看一个更微妙的例子，深入到网络编程的世界。一个程序想要等待网络活动，但在等待期间，它需要临时允许一个特定的信号来中断它。天真的方法是两步走：首先，调用内核更改进程的信号掩码；其次，再次调用内核开始等待（`select()`）。你看到了，不是吗？间隙！一个信号可能在掩码改变之后、但等待实际开始之前到达，导致无法如预期那样中断等待。这个错误的形态是完全相同的。解决方案也是如此。一个新的[系统调用](@entry_id:755772) `pselect()` 被发明出来，可以同时做这两件事。它接受要等待的 I/O *以及*要使用的临时信号掩码，内核会原子地执行整个操作 [@problem_id:3686266]。从文件到进程再到信号，底层的逻辑是相同的。

### 信任的架构

到目前为止，我们一直专注于修补有漏洞的程序。但如果我们能设计出让这类问题在很大程度上消失的系统呢？这里我们从编程技巧转向架构思维的深刻转变：从使用*名称*转向使用*能力*。

在现代[操作系统](@entry_id:752937)中，文件描述符不仅仅是一个数字。它是一种**能力**：一个不可伪造、经内核验证的授权令牌，授予持有者对特定对象的特定权利。

想象一个在你的手机或桌面上运行的应用程序。为了安全，它被密封在一个沙箱里；它什么也看不见，根本无法访问[文件系统](@entry_id:749324)。然而，你希望这个沙箱化的应用能打开你从文件选择器对话框中选的一张照片。这怎么可能实现呢？如果可信的文件选择器（它是[操作系统](@entry_id:752937)的一部分，而非应用的一部分）只是简单地将文件的*名称*发送回沙箱化的应用，我们又回到了 [TOCTOU](@entry_id:756027) 的困境。沙箱将不得不为那个名称开一个洞，创建一个例外，而我们已经看到这有多危险。

真正优雅的解决方案是：可信的文件选择器*自己打开文件*。然后它不是传递名称，而是通过一个安全通道将打开的文件句柄——文件描述符——直接传递给沙箱化的应用。该应用收到了一个能力，一根只能触及那张特定照片的魔杖。它不知道照片的名字，也不知道它在磁盘上的位置，并且它不能用这根魔杖打开甚至看到任何其他东西。与变化的名称赛跑的整个问题都消失了，因为我们已经完全停止使用名称作为权力的通货 [@problem_id:3665153]。这种架构模式——一个可信的代理授予一个纯粹的能力——是现代安全[系统设计](@entry_id:755777)（从移动应用到网页浏览器）的基石。

### 机器中的幽灵：时间本身

我们已经看到了如何在多个战线上与“[检查时-使用时](@entry_id:756030)”作斗争，从编程纪律到系统架构。但这个问题还有最后一种幽灵般的形式，潜伏在我们安全模型的基础之中。

想象一个拥有完美安全卫士的完美系统——一个内核内部的“引用监控器”，它检查每一次访问任何事物的尝试 [@problem_id:3642357]。当你请求打开一个文件时，引用监控器会检查系统的安全策略和你的权限。如果一切正常，它会说：“一切正常！”然后授予你一个文件描述符——你的能力。

但如果规则手册改变了会发生什么？在你打开文件进行写入十分钟后，系统管理员撤销了你的访问权限。然而，你仍然持有在旧策略下授予你的有效文件描述符。你还能写入文件吗？在大多数系统中，答案是肯定的。检查是在你打开文件时执行的。你后续对描述符的使用发生在现在，是在一个过时的授权之下。

这是针对策略本身的 [TOCTOU](@entry_id:756027) 竞争！“检查”是安全规则在时间 $t_0$ 的状态。“使用”是你在时间 $t_1$ 的写入操作。在这期间，宇宙——或者至少是系统管理员——改变了规则。*撤销*问题——即让已经分发出去的能力失效——是计算机安全领域最深刻、最困难的问题之一。它表明，我们这个简单的错误实际上是一个深刻挑战的体现：如何构建能够优雅、安全地适应一个不断变化的世界的系统。

于是，我们始于一个文件创建程序中简单错误的旅程，最终引向了这片宏伟的景象。事实证明，检查与使用之间的竞争，本质上是与[时间之箭](@entry_id:143779)本身的赛跑。