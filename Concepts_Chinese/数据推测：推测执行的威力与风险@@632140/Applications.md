## 应用与跨学科联系

窥见了定义[推测执行](@entry_id:755202)的预测与纠正的复杂舞蹈后，我们或许会感到一种敬畏之情。我们制造出的机器能够凝视程序的未来，执行一条尚不存在的路径，并在猜测错误时无缝地倒转时间——所有这一切都在几十亿分之一秒内完成。这种能力是工程学的胜利，是现代计算速度的引擎。但是，当这个强大的、能穿越时间的处理器大脑被欺骗时，会发生什么？它那些幽灵般的、瞬态的思想会带来什么后果？

这就是我们旅程中一个引人入胜的转折点，从性能设计的纯净领域进入计算机安全的混乱、对抗性世界，并从那里走向一个跨越计算每一层的统一努力，从硅晶片到编译器最抽象的表示。[推测执行](@entry_id:755202)应用的故事，是一个关于意外后果以及为应对这些后果而兴起的美丽、多学科科学的故事。

### 机器中的幽灵：Spectre 与 Meltdown

几十年来，硬件和软件之间的契约很简单：处理器保证，最终，它将按照书面规定，按顺序执行程序的指令。引擎盖下发生的狂野[乱序执行](@entry_id:753020)是硬件自己的事，是其[微架构](@entry_id:751960)的秘密。但事实证明，即使是短暂的、瞬态的思想——在预测错误的路径上执行并随后从架构历史中抹去的指令——也会留下微弱的足迹。它们可以 subtly 改变 CPU 缓存的状态，而一个聪明的攻击者可以测量这些改变的时间，从而读懂处理器的思想。

这一发现催生了两类漏洞，它们经常被混淆，但在方法上有着根本的不同，我们可以通过一系列典型行为来区分它们 ([@problem_id:3679338])。

第一种是 **Meltdown**，它更直接，在某些方面也更令人震惊。它利用了处理器本身的竞争条件，即读取一个禁止访问的内存地址的请求——比如用户程序试图从操作系统内核读取一个秘密——被推测性地满足了。在短暂的瞬间，数据被获取并转发给依赖的指令，*然后*处理器的特权检查电路才发出警报。处理器很快会发现自己的错误，引发一个故障，并清空非法的操作，这样秘密值就不会污染程序的架构状态，比如被写入寄存器 ([@problem_id:3620283])。但为时已晚。那些看到秘密的瞬态指令可能已经用它来访问一个特定的缓存行，在[内存层次结构](@entry_id:163622)中留下了一个攻击者可以检测到的“热点”。因此，Meltdown 是对硬件自身特权边界执行的一种攻击，是一次短暂的越狱。

**Spectre** 则是另一种完全不同的野兽。它更微妙，更普遍，在许多方面也更深刻。Spectre 不破坏规则；它诱骗处理器错误地应用规则。攻击者“训练”处理器的分支预测器犯错。例如，通过反复使用有效输入调用一个函数，攻击者教会 CPU 预测某个安全检查——比如数组索引的[边界检查](@entry_id:746954)——将会通过。然后，攻击者提供一个恶意输入，一个越界索引。CPU 遵循它的训练，推测性地冲过安全检查，执行在恶意偏移量处访问内存的代码 ([@problem_id:3670179])。这种越界访问在架构上是合法的，因为它没有像 Meltdown 那样跨越特权边界，但它访问了程序[逻辑设计](@entry_id:751449)要保护的内存部分。就像一个幽灵，CPU 瞬态地遵循了程序员禁止的路径，而它的幽灵行为可以被用来揭示秘密。Spectre 通过利用处理器的预测性来颠覆程序自身的逻辑。

### 瞬息念头的物理学

人们很容易认为这些[瞬态执行](@entry_id:756108)是无所不能的，但它们和其他事物一样，受到相同的物理和信息流定律的约束。一次攻击是一场与时间的赛跑。一个恶意瞬态代码片段的整个序列，从最初的预测错误到最终影响缓存的操作，必须在“推测窗口”——即 CPU 的引退单元发现预测错误并清空不正确路径之前的几纳秒内——完成。

考虑一个需要一系列依赖操作的攻击，比如따라一个指针找到一个地址，然后使用该地址获取另一个值。第一次加载必须完成并传递其结果，第二次加载才能开始。每一步都需要时间，无论是对于一级缓存命中 ($t_{L1}$) 的几个周期，还是对于 DRAM 访问 ($t_{DRAM}$) 的数百个周期。如果推测窗口 $W$ 比这个依赖链的延迟要短，攻击就根本无法成功。CPU 在恶意的“包袱”抖出来之前就纠正了它的路径。这意味着，要使一个复杂的[瞬态执行](@entry_id:756108)成功，它不仅要在逻辑上巧妙，而且在[微架构](@entry_id:751960)层面也必须足够快，以赢得与处理器自身[纠错](@entry_id:273762)机制的赛跑 ([@problem_id:3679404])。

### 多层次防御：凝聚的新共识

[推测执行攻击](@entry_id:755203)的发现给整个计算机科学界带来了[冲击波](@entry_id:199561)。它揭示了安全不仅仅是软件的属性，而是整个计算栈的一个涌现属性。因此，应对措施也同样是整体性的，在[硬件设计](@entry_id:170759)、[操作系统](@entry_id:752937)和编译器之间创造了一种美妙的相互作用。

#### 编译器的巧思

也许在思想上最优雅的防御来自编译器和编程语言的世界。既然 Spectre 攻击利用了*[控制依赖](@entry_id:747830)*（如 `if` 语句）的预测错误，那么我们是否可以转换代码，使其根本没有[控制依赖](@entry_id:747830)？

想象一下易受攻击的代码：`if (index  limit) { access(array[index]); }`。分支预测器可能会被欺骗。一个稳健的软件缓解措施，通常由一个具有安全意识的编译器实现，是将其转换为*数据依赖* ([@problem_id:3622102])。例如，可以编写无分支代码来钳制索引：`safe_index = min(index, limit - 1); access(array[safe_index]);` ([@problem_id:3679377])。推测性处理器无法打破真正的[数据依赖](@entry_id:748197)。它 jednostavno *必须* 等待 `min` 操作的结果，然后才能计算内存访问的地址。没有可以被愚弄的预测。通过用一个铁板钉钉的数据依赖替换一个可猜测的分支，程序员或编译器可以迫使 CPU 的推测引擎正确行事。

这种新发现的安全意识深入到[编译器设计](@entry_id:271989)的核心。[优化编译器](@entry_id:752992)建立在“as-if”规则之上：它们可以以任何方式转换程序，只要最终的可观察行为相同。但在一个有[侧信道](@entry_id:754810)的世界里，什么是“可观察的”？一个安全检查，比如防止[缓冲区溢出](@entry_id:747009)的栈金絲雀，几乎总是通过。一个激进的编译器可能会看到这一点，并“优化”掉这个检查，尤其是在推测路径上。为了防止这种情况，[编译器设计](@entry_id:271989)者现在必须将这些安全检查正式建模为神圣的、有副作用的操作，即使它们看起来是多余的，也不能被重排序或移除。这导致了编译器[中间表示](@entry_id:750746)中的[新形式](@entry_id:199611)主义，确保一个检查不仅在架构上得到尊重，而且在[瞬态执行](@entry_id:756108)中也同样如此 ([@problem_ID:3625609], [@problem_ID:3660412])。

#### 为未来设计更智能的硬件

虽然软件补丁和编译器的英雄主义至关重要，但最终的解决方案可能在于设计更智能的硬件。与其将所有数据一视同仁，不如让处理器知道哪些数据是不可信的？这就是**硬件污点跟踪**背后的思想 ([@problem_id:3657221])。

想象一下，任何从不可信来源——比如一个网络数据包——读取的数据都被标记上一滴隐喻的染料。这就是它的“污点”。硬件被设计成让这种污点[扩散](@entry_id:141445)：任何由污点值计算出的值本身也变得带有污点。关键步骤不仅是将这种污点传播到数据，还要传播到用于内存操作的*地址*。

有了这个能力，CPU 内部的[内存消歧](@entry_id:751856)逻辑可以变得更加智能。当它看到一个加载指令的地址*没有*被污染时，它知道这次访问很可能是良性的，可以使用其正常的、激进的推测。但当它看到一个加载指令的地址*被*污染了——意味着它受到了不可信输入的影响——它就知道与之前的存储发生恶意别名的风险很高。作为响应，它可以降低其激进性，等待所有先前的存储地址都已知后才发出加载指令。这是一个细粒度的、有针对性的解决方案。它只在需要谨慎的地方才谨慎行事，为绝大多数操作保留了性能，同时加固了系统以抵御攻击。这不仅仅是一个补丁；它是硬件理解其处理信息方式的一次原则性演进。

从一个让计算机更快的简单技巧开始，[推测执行](@entry_id:755202)迫使我们重新思考我们设计的最基本 fundamentos。它揭示了编译器逻辑、[操作系统](@entry_id:752937)规则和处理器瞬息念头的物理现实之间隐藏的统一性。机器中的幽灵，以其自身奇怪的方式，让我们成为了更好、更全面的工程师。