## 引言
在构建真正安全可靠的软件的探索中，传统的安全模型常常力不从心，从而产生一些微妙但灾难性的漏洞。基于能力的安全为系统内的访问和权限控制提供了一种截然不同且更为强大的[范式](@entry_id:161181)。它不再追问“是谁发出的请求？”，而是提出了一个更精确的问题：“这个请求携带了什么权限？”

与使用[访问控制](@entry_id:746212)列表（ACL）并授予程序广泛的环境权限的传统身份认证系统不同，能力模型建立在[最小权限原则](@entry_id:753740)之上。这种方法直接解决了根深蒂固的安全缺陷，如“困惑的代理人问题”，即一个特权程序被欺骗，代表恶意行为者滥用其权限。

本文将引导您了解这个强大的安全模型。我们将首先探讨其核心的“原理与机制”，通过使用像代客泊车钥匙这样的直观类比来理解能力如何工作、是什么使其不可伪造，以及在其整个生命周期中其权力如何被管理。接下来，“应用与跨学科联系”部分将展示这些原理如何应用于解决现实世界的问题，从保护您计算机的剪贴板到安全管理直接硬件访问和构建弹性[分布式系统](@entry_id:268208)。读完本文，您将领会到这一优雅的理论如何为将可信赖性工程化到我们软件和硬件的根基中提供一个统一的框架。

## 原理与机制

要真正领会基于能力的安全这一[范式](@entry_id:161181)，我们必须踏上一段旅程，就像物理学家探索新的自然法则一样。我们不会从复杂的代码或加密公式开始，而是从一个简单、直观的想法入手。我们将拆解传统的安全观念，审视其各个部分，然后以一种全新的方式将它们重新组合，这种新方式同时更优雅、更强大，并在深层次上更具美感。

### 权限与指定：代客泊车钥匙与保镖的名单

想象一下，您正把车委托给代客泊车员。您有一个选择。您可以把整个钥匙串——包括您的车钥匙、房门钥匙、办公室钥匙、保险箱钥匙——都交给泊车员。或者，您可以给他们一把专门设计的代客泊车钥匙。这把钥匙可以启动引擎、打开车门，但打不开后备箱或[手套箱](@entry_id:264554)。

代客泊车钥匙是**能力**的一个完美现实类比。它是一个物理令牌，同时*指定*了一个对象（您的车）并*授予一组特定的、有限的权利*（驾驶它，但不能访问其内部物品）。关键在于，这把钥匙并不关心代客泊车员是谁。任何持有它的人都可以使用它。它的权限是自包含的。

现在考虑另一种情况。这就是传统的、基于身份的安全世界，通常用**[访问控制](@entry_id:746212)列表（ACL）**来实现。这个模型就像一个高级俱乐部门口的保镖。保镖有一份名单。当您到达时，保镖会检查您的身份证。如果您的名字在名单上，您就被允许进入。您的身份就是凭证。这种身份是一种**环境权限**——它是属于*您*的一种属性，您随身携带。您运行的任何程序、采取的任何行动，都默认以您身份的全部权重行事。

这个区别是问题的哲学核心。基于 ACL 的安全关心的是*你是谁*。基于能力的安全关心的是*你拥有什么*。[@problem_id:3689503]

这个看似微妙的转变带来了深远的影响。当一个系统依赖环境权限时，它会产生一个典型的漏洞，称为**困惑的代理人问题**。想象一个服务器程序——我们的“代理人”——以高权限（例如，作为系统管理员）运行。您，一个普通用户，要求它执行一项任务，比如向日志文件写入内容。但如果您能欺骗这个服务器，让它转而写入一个关键的系统文件呢？这个服务器，对应该行使谁的权限感到“困惑”，可能会无意中用它自己的高权限来满足您的恶意请求。它被给予了整串钥匙，结果被骗去打开了错误的门。

能力优雅地解决了这个问题。要让服务器写入您的日志文件，您不会只给它文件名。您会传递一个针对那个特定日志文件的*能力*——一把只对那一个文件有效、且只允许追加操作的代客泊车钥匙。现在，服务器没有任何可以滥用的环境权限。它只能在您指定的那个确切对象上，做您授权它做的确切事情。权限与请求本身绑定，而不是与代理人绑定。[@problem_id:3686270]

### 能力的剖析：一个不可伪造的权力令牌

那么，这个神奇的令牌究竟是什么？从核心上讲，能力是发送给系统最终仲裁者——内核或硬件参考监视器——的一条消息。这条消息必须是**不可伪造的**。如果任何用户都可以轻易地为任何资源创建一个能力，那么整个安全模型就会崩溃。不可伪造性这个特性不是一个建议；它是构建其他一切的基石。有几种绝妙的方法可以实现它。

一种方法是通过巨大的规模和保密性。一个能力可以是一个极大的随机数，从一个巨大的可能性空间中选出（例如，一个 96 位或 128 位的字符串）。内核将这些随机数作为句柄分发出去。攻击者要想获得未经授权的访问，就必须猜中一个有效的数字。当密钥空间足够大时，即使每秒进行数百万次尝试并持续多年，成功猜中的概率也会变得无穷小，接近于硬件故障的概率。我们可以精确计算这些概率，从而将安全从一个模糊的概念转变为一个统计上的确定性。[@problem_id:3642360]

一种更稳健的方法依赖于[密码学](@entry_id:139166)。内核可以构建一个包含资源标识符、权限集和其他必要信息的令牌，然后使用只有内核拥有的密钥对这些数据计算一个**消息认证码（MAC）**。这个 MAC 会被附加到令牌上。当这个能力稍后被提交时，内核可以重新计算 MAC 并验证令牌没有被篡改。任何伪造能力或提升其权限（例如，为一个只读能力添加“写”权限）的企图都会在这次验证中失败。这种方法通过[密码学](@entry_id:139166)证明将权限与数据绑定在一起。[@problem_id:3631389]

当不可伪造性被直接[植入](@entry_id:177559)处理器硬件时，就达到了其终极形态。在像 CHERI 这样的先进架构中，能力不仅仅是[数据结构](@entry_id:262134)；它们是 CPU 能理解的一种[基本数据类型](@entry_id:636193)。特殊的“标签内存”可以防止程序直接操纵能力的比特位。硬件本身强制执行这些规则，使得能力真正不可伪造，并且其权限对于用户代码来说是不可变的。[@problem_id:3673099]

### 能力的实际应用：从名称到实体

让我们看看这如何改变打开文件这个简单的操作。在传统系统中，您使用路径名，例如 `open("/srv/app/config.yaml")`。内核会执行一系列检查：用户能否访问 `/`？然后是 `/srv`？再然后是 `/srv/app`？最后是 `config.yaml`？这种对名称的依赖是脆弱的。它会产生一种称为**[检查时-使用时](@entry_id:756030)（[TOCTOU](@entry_id:756027)）**的竞态条件。如果在内核检查路径和实际打开文件之间的微小时间差内，攻击者巧妙地将 `/srv/app` 重命名，并用一个指向系统密码文件 `/etc/shadow` 的[符号链接](@entry_id:755709)取而代之，会发生什么？检查在原始路径上成功通过，但使用操作却作用于那个恶意链接。[@problem_id:3689503]

能力系统通过从模糊的名称转向具体的实体来避免这个陷阱。一个健壮的程序不会处理路径，而是首先获取一个指向 `/srv/app` 目录本身的能力。这个能力，在现代[操作系统](@entry_id:752937)中通常表现为**文件描述符**，是对该特定目录对象的一个直接、稳定、不可伪造的引用，无论其名称如何。为了打开配置文件，程序会调用像 `openat` 这样的操作，提交其目录能力，并请求打开*相对于该目录*的 `config.yaml` 文件。整个操作——通过能力指定目录和通过名称指定文件——由内核在一个单一的原子步骤中完成。[TOCTOU](@entry_id:756027) 竞态条件的可能性被消除了。[@problem_id:3642034]

### 权力的生命周期：委托、继承与撤销

权力，即使粒度再细，也必须加以管理。能力系统为其整个生命周期提供了优雅的机制。

**委托与继承：** 一个进程可以通过安全通道将其能力之一传递给另一个进程，从而委托权限。当一个进程创建子进程时，它可能希望子进程继承其部分访问权限。然而，为防止[权限提升](@entry_id:753756)，必须遵循一个基本的安全[不变量](@entry_id:148850)：子进程的权限（$R_C$）必须是父进程权限（$R_P$）的[子集](@entry_id:261956)，即 $R_C \subseteq R_P$。这就是**[单调性](@entry_id:143760)原则**——权限在向下传递时只能减少（或保持不变）。内核必须在进程创建期间严格执行这一原则，以及其他如资源配额等约束。[@problem_id:3640338]

**撤销：** 如果您授予了一个能力，后来又需要收回它，会发生什么？这是一个众所周知 的难题。您不能简单地找出您分发出去的每一份“钥匙”副本。然而，若没有解决方案，长期存在的能力可能成为安全隐患，例如，导致[拒绝服务](@entry_id:748298)攻击，其中由资源的*前*所有者授予的能力被用来消耗*新*所有者的资源。[@problem_id:3674051] 幸运的是，有几种巧妙的解决方案可以避免暴力搜索。

- **间接引用：** 您不直接分发资源的钥匙，而是分发一个装有资源钥匙的保险箱的钥匙。要撤销访问权限，您只需更换保险箱上的锁即可。所有旧钥匙都将失效。这种方法简单，但会给每次访问增加开销。

- **[版本控制](@entry_id:264682)：** 一种更优美的方法是为每个对象关联一个版本号 $v_o$。当创建能力时，它会被盖上对象当前版本的戳记 $v_c$。访问规则很简单：仅当 $C.v_c = v_o$ 时，该能力才有效。要同时撤销一个对象的所有现有能力，内核执行一个单一的原子操作：它将对象的版本号递增，$v_o := v_o + 1$。瞬间，所有旧的能力都失效了。这是一个常数时间 $O(1)$ 的撤销机制，其效率和优雅确实非凡。[@problem_id:3619243]

- **租约：** 系统可以不授予永久的能力，而是颁发租约——即带有内置过期时间的能力。为了维持访问权限，持有者必须定期向内核续租。这样，撤销就变得像内核拒绝续租一样简单。这是一个强大的机制，可以确保权限被定期重新验证，防止过时的能力造成危害，并且对于管理复杂场景中的资源至关重要，例如安全地撤销硬件设备对内存缓冲区的访问权限。[@problem_id:3640344]

### 保护的巅峰：从软件到芯片

能力模型最深刻的实现，是当其原则被镌刻在处理器本身的芯片上时。想象一下，一个系统不再是粗粒度地划分为“[用户模式](@entry_id:756388)”和“[内核模式](@entry_id:755664)”，而是拥有无数细粒度的[保护域](@entry_id:753821)。要调用另一个域中的服务——比如一个库或[设备驱动程序](@entry_id:748349)——人们不会执行一个重量级的[系统调用](@entry_id:755772)，该调用会授予被调用者近乎全能的环境特权。

取而代之的是，人们调用一个**密封入口能力**。这是一个特殊的、不可伪造的令牌，充当一个安全的[调用门](@entry_id:747096)。执行它会触发一个由硬件介导的域穿越。处理器安全地切换上下文（例如，堆栈和寄存器），但——这是关键点——它不会翻转一个主“特权”位。被调用的域不会获得任何环境权限。它的权力严格限于它已拥有的能力，加上在调用中作为参数明确传递的能力。[@problem_id:3673099]

这就是以其最纯粹形式实现的**[最小权限原则](@entry_id:753740)**。系统中的每个组件，从最大的应用程序到最小的驱动程序，都以执行其功能所需的绝对最小权限运行。通过将我们的[焦点](@entry_id:174388)从行为者的身份转移到他们为特定行为所拥有的明确权限上，基于能力的安全为构建未来可信赖的系统提供了一个统一、稳健且优美的框架。

