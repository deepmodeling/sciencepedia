## 应用与跨学科联系

既然我们已经探讨了基于能力的安全的原理和机制，您可能会想：“这是一个优雅的理论，但它到底有什么用？”这是对任何科学思想可以提出的最重要的问题。一个伟大原则（如物理学定律）的美妙之处，不仅在于其抽象的表述，更在于其解释和塑造我们周围世界的力量。因此，让我们踏上一段旅程，看看一个不可伪造的权限令牌——即“能力”——这个简单的想法如何演变成一个强大的工具，用以解决计算领域中一些最棘手的问题，从您口袋里的设备到为我们数字世界提供动力的庞大数据中心。

### 日常物品中的陷阱

最深层次的安全挑战常常隐藏在显而易见之处，隐藏在我们不假思索使用的日常工具中。您是否曾将密码或银行账号复制到剪贴板？是什么阻止了一个在后台悄悄运行的恶意应用程序窥视它呢？

在传统系统中，您的用户帐户可能拥有“读取剪贴板”的权限。任何以您的身份运行的应用程序都会继承此权限。这是一个使用*环境权限*的典型例子——应用程序能做某事仅仅是因为*您*能做。能力系统提供了一个更精细、更安全的解决方案。当您按下“粘贴”时，[操作系统](@entry_id:752937)可以授予前台应用程序一个短暂的、一次性的能力——一张不可转让的票证，仅用于读取剪贴板的*当前*内容，且只能使用一次。后台应用程序从未收到此票证，因此无权读取剪贴板，即使它以您的身份运行。这个简单而优雅的机制将剪贴板从一个共享的、易受攻击的资源转变为一个安全的传递通道，完美地实现了[最小权限原则](@entry_id:753740) [@problem_id:3665168]。

这种灵活性是能力的核心优势之一。考虑一个共享的办公室打印机。我们可能希望有一个公共的能力，任何人都可以用它来提交打印任务。提交后，系统可以返回两个新的、更具体的能力。一个是“状态”能力，可以自由传递——您可以把它给同事，这样他们就能看到您的文档何时打印完成。另一个是“取消”能力，则有所不同。我们只希望原始提交者能够取消自己的任务。这可以通过创建一个特殊的能力来实现，该能力将提交者的身份信息融入其中并进行加密密封。要使用这个能力，您不仅必须拥有它，还必须*是*其中指定的人。这种优美的混合设计在适当的地方为我们提供了纯能力的委托自由，在必要的地方又提供了传统系统的严格身份绑定控制，所有这些都在一个统一、连贯的框架内实现 [@problem_id:3674028]。

这些例子揭示了困扰计算机安全的一个更深层次、更普遍的问题：“困惑的代理人”。这是一个拥有合法权限但被欺骗滥用权限的程序。想象一个安全日志服务，其工作是向 `/var/log/security.log` 文件追加记录。该文件上的传统[访问控制](@entry_id:746212)列表（ACL）会正确地授予日志记录器“追加”权限。但如果攻击者将真实的日志文件重命名，并在其位置创建一个新的空文件呢？日志记录器下一次尝试打开 `/var/log/security.log` 时，就成了一个困惑的代理人。它跟随名称，找到新文件，并且看到自己有权限，就愉快地向攻击者的文件追加内容。原始日志实际上已被截断。

能力系统避开了这一整类问题。日志记录器得到的不是一个需要查找的*名称*，而是一个*能力*，一个指向唯一正确的日志文件对象的直接、不可伪造的指针。日志记录器不再是一个会被受操纵的环境所迷惑的代理人。它持有它应该与之通信的对象的“真实名称”，使得这种基于路径的攻击根本不可能发生 [@problem_id:3674075]。

### 筑牢围墙：沙箱与虚拟世界

限制——即构建一个安全的“沙箱”来运行不受信任的代码——是现代计算的核心思想。然而，创建一个不会泄漏的沙箱是出了名的困难。类 Unix 系统中的一个经典例子是 `chroot` “监狱”。其思想是改变一个进程对[文件系统](@entry_id:749324)的视图，使某个目录看起来像是根目录。但如果在进入“监狱”之前，进程打开了一个指向监狱外目录的文件描述符——一种原始的、[操作系统](@entry_id:752937)级别的能力——会怎样？在许多系统中，这个文件描述符仍然有效。进程随后可以使用这个句柄逃离监狱，完全破坏了隔离。这就像一个囚犯被锁在牢房里，却保留着监狱大门的钥匙。

一个真正的能力系统可以通过使能力具备命名空间感知能力来强制执行这一点。一个文件的能力将仅在其创建的上下文（即“命名空间”）中有效。如果进程转换到一个新的监狱，其旧的能力就会失效，从而优雅地防止此类逃逸 [@problem_id:3687954]。

这个原则可以扩展到更复杂的场景中。例如，现代编译器允许在构建过程中运行插件和宏来生成代码。这是一个强大的功能，但也是一个可怕的安全风险——一个恶意的插件可以在您的机器上运行任意代码。使用能力，我们可以为这些插件构建一个沙箱。我们可以授予插件一组非常有限的能力：也许只有“构建语法树”的权利，仅此而已。它将没有访问网络或读取文件的能力。这将安全从信任问题转变为强制策略问题，从而加固了软件供应链中的一个关键部分 [@problem_id:3629633]。

澄清一个常见的混淆点也很有用。Linux [操作系统](@entry_id:752937)有一个称为“capabilities”（例如 `CAP_SYS_MODULE`）的功能，但这些不是我们一直在讨论的对象能力。它们是对无所不能的 `root` 权限的细粒度划分。为一个与主机共享内核的容器授予像 `CAP_SYS_MODULE` 这样的特权，允许它直接将代码加载到共享内核中。这是终极的越狱，相当于赋予囚犯改写监狱物理定律的能力。它彻底粉碎了隔离边界。这个教训是普遍的：无论是通过真正的对象能力还是其他机制，[最小权限原则](@entry_id:753740)都是至高无上的。你必须谨慎地授予权限，并且必须精确地理解该权限所包含的内容 [@problem_id:3665348] [@problem_id:3664515]。强大的隔离需要全面的措施，从放弃危险的特权到使用[系统调用](@entry_id:755772)过滤器和内核加固技术 [@problem_id:3665348] [@problem_id:3664515]。

### 深入裸机与跨越网络

基于能力的安全的影响力一直延伸到硬件层面，并扩展到物联网（IoT）的[分布](@entry_id:182848)式世界。

想象一下，您的智能家居里有位客人。您想让他们能使用前门和客厅的灯，但仅限于周末。在一个中心化的系统中，只要您家的控制器连接到互联网，这很容易做到。但如果网络断了呢？客人就会被锁在门外。基于能力的设计提供了一个绝妙的解决方案。中央控制器可以铸造一个数字能力——一个经过加密签名的令牌——其中包含客人的身份、他们可以访问的设备（门锁）、他们拥有的权限（“解锁”）以及一个过期时间。这个能力被发送到客人的手机上。当客人走近门时，他们的手机出示这个能力。门锁本身，由于已经被赋予了控制器的公钥，可以验证签名、检查身份和检查过期日期，所有这些都无需联系中央控制器。这是一个完全去中心化、高可用且安全的系统 [@problem_id:3674090]。

也许能力最令人惊叹的应用在于软件和硬件的交界处。为了获得最高性能，我们有时希望像网卡或存储控制器这样的设备能够直接将数据写入内存，而无需主CPU的参与。这被称为直接内存访问（DMA）。它速度极快，但也极其危险。您如何让应用程序告诉设备写入何处，而又不让它告诉设备覆盖内核呢？答案是输入输出[内存管理单元](@entry_id:751868)（IOMMU），这是一种充当DMA安全卫士的硬件。

在一个名为 Exokernel 的激进[操作系统](@entry_id:752937)设计中，目标是安全地给予应用程序尽可能多的对硬件的直接控制。通过使用能力，内核可以授予应用程序一个针对特定物理内存区域的能力。然后，应用程序可以用它来编程 [IOMMU](@entry_id:750812)，创建映射，允许设备执行 DMA——但只能写入该应用程序自己的内存中。IOMMU 在这些受能力约束的指令的指导下，在硬件层面强制执行隔离。这个过程最精细的部分是撤销。为了安全地收回这项权利，[操作系统](@entry_id:752937)必须遵循一个严格的协议：首先，停止设备开始新工作；其次，等待所有进行中的操作完成；第三，使 IOMMU 中的映射失效；最后，从 [IOMMU](@entry_id:750812) 的内部状态中刷新任何缓存的转换。只有这样，内存才能被安全地重用。这个复杂的过程防止了灾难性的[释放后使用](@entry_id:756383)（use-after-free）漏洞，并展示了能力如何为安全管理原始硬件能力提供了正确的思维模型 [@problem_id:3640389]。当然，这些检查并非没有成本；它们会给操作带来少量开销。但通过巧妙的设计，如在硬件控制器本地缓存能力，这个成本可以变得非常小 [@problem_id:3636376]。

### 统一之美：安全即语言

我们以一个揭示能力模型深邃数学优雅的视角来结束我们的旅程。想一想编程语言中的“类型系统”。它防止您做出无意义的陈述，比如试图将数字 `5` 与单词“banana”相加。一个类型良好的程序是不会发生此类错误的程序。

我们可以将一个基于能力的安全[操作系统](@entry_id:752937)看作是一种用于与资源交互的类型安全语言。一个文件的能力是一个抽象、不可伪造类型的值，比如 `Cap[File]`。获得这种类型值的唯一方法是向[操作系统](@entry_id:752937)的运行时请求，只有在您被授权时，它才会授予您。一旦您拥有了这个类型化的值，您就可以在像 `read` 和 `write` 这样的操作中使用它。如果您没有它，您甚至无法表达这个操作。因为系统是“类型安全的”，您不能通过例如强制转换一个整数来伪造一个 `Cap[File]`。因此，一个“类型良好”的程序——一个遵守能力系统的程序——可以被证明无法访问它从未被授予能力的资源。安全不再是一场无休止的打地鼠游戏；它变成了系统语言的一个基本的、可证明的属性 [@problem_id:3664515]。

从保护您的剪贴板到驯服狂野的硬件，一个不可伪造的权限令牌这一简单原则，为构建安全系统提供了一个统一而强大的框架。它鼓励我们不要从用户*是谁*的角度思考，而是从程序需要*做什么*的角度思考，从而不懈地将我们推向最小权限这一优雅而稳健的理想。