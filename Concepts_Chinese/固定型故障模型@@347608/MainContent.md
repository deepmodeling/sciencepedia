## 引言
在现代电子世界中，我们如何保证一个包含数十亿晶体管的微芯片没有制造缺陷？其巨大的复杂性使得物理检查每个组件成为一项不可能完成的任务。[数字电路](@article_id:332214)测试的这一根本挑战需要一种优雅的抽象，一种既简单又强大的方式来对潜在的故障进行建模。最终成为行业基石的解决方案就是[固定型故障模型](@article_id:348094)。该模型将混乱、不可预测的物理缺陷转化为清晰、可管理的逻辑问题。

本文探讨了[固定型故障模型](@article_id:348094)，深入介绍了其原理和实际应用。通过两大章节，您将全面了解这一数字可靠性的基石。第一章 **“原理与机制”** 将阐述核心理论，解释什么是[固定型故障](@article_id:350358)，它们如何破坏逻辑行为，以及通过激活故障和传播错误来检测它们的基本技术。第二章 **“应用与跨学科联系”** 将理论与实践相结合，展示这些概念如何扩展应用于测试复杂系统，[时序电路](@article_id:346313)带来的挑战，以及像[可测试性设计](@article_id:354865) (DFT) 和自动测试模式生成 (ATPG) 这样的巧妙工程解决方案如何使现代电子产品成为可能。

## 原理与机制

想象一下，你刚收到十亿个微型开关——晶体管——它们全部连接在一起，构成一个复杂的逻辑之城，一块全新的计算机芯片。制造商告诉你它是完美的。但真的是这样吗？在这十亿个组件中，如果只有一个微小的开关坏了怎么办？如果一根导线意外地熔合到电源线上怎么办？你该如何找到它？试图逐一检查是不可能的。你看不见它们，也摸不着它们。你所能做的就是站在城门口——输入引脚——发送信号，然后观察出口处——输出引脚——出来的是什么。这就是[数字电路](@article_id:332214)测试的巨大挑战，为了攻克它，我们需要一个聪明的策略。我们需要一个模型。

### 一个由黑箱和损坏开关组成的世界

最成功和最持久的策略是**[固定型故障模型](@article_id:348094)**。我们不再担心所有可能出现的物理问题——破裂的晶体管、微小的尘埃颗粒、金属晶须——而是以一种天才的方式简化了问题。我们问：一个缺陷的*逻辑效应*是什么？在许多情况下，物理故障会导致电路中的某条特定导线表现得好像它永久连接或“固定”到逻辑“1”状态（电源）或逻辑“0”状态（地）。

这是一种非常强大的抽象。我们不需要成为检查硅[晶体结构](@article_id:300816)的物理学家；我们可以成为检查行为的逻辑学家。让我们看看这是如何工作的。考虑一个简单的双输入与门。它的规则很简单：当且仅当输入*A*和*B*都为“1”时，输出才为“1”。现在，想象一个制造缺陷导致输出线 $Y$ 固定为1 [@problem_id:1966741]。我们的门会发生什么？就好像门的决策权被篡夺了。无论输入A和B是什么，输出都大声宣告“1”。门的真值表，也就是它的身份，被破坏了。对于输入对(0,0)、(0,1)和(1,0)，它不再产生“0”，而是对每一种组合都固执地输出“1”。这个门已经失去了它的功能。

这就是固定型模型的精髓。它将一个混乱的物理问题转化为一个清晰的逻辑问题。故障存在于特定位置，它要么是固定为0 (s-a-0)，要么是固定为1 (s-a-1)。故障不限于最终输出。电路内部的任何导线都可能成为受害者。例如，在一个多路复用器中——一个根据选择信号 $S$ 从两个输入 $I_0$ 或 $I_1$ 中选择一个的数字交通警察——选择线 $S$ 上的固定为1故障是灾难性的 [@problem_id:1934742]。MUX的功能通常是 $Y = (\neg S \land I_0) \lor (S \land I_1)$。如果 $S$ 永久固定为“1”，[逻辑简化](@article_id:339462)为 $Y = (\neg 1 \land I_0) \lor (1 \land I_1) = (0 \land I_0) \lor I_1 = I_1$。[多路复用器](@article_id:351445)坏了；它再也无法选择 $I_0$。这就像一个只能指挥一个车道通行的交通警察。

### 讯问的艺术：如何捕捉故障

知道了故障*是*什么，我们自然会问下一个关键问题：我们如何*找到*它？我们通过讯问来找到它。我们施加一组特定的输入，称为**[测试向量](@article_id:352095)**，并观察输出。一个故障被“检测到”，当且仅当该[测试向量](@article_id:352095)迫使故障电路产生一个与健康、无故障电路的输出*不同*的输出。如果输出相同，故障就隐藏起来了。

这个单一原则是故障检测的基石。考虑一个3输入[或门](@article_id:347862)，其中如果*A*或*B*或*C*为“1”，则输出为“1”。假设我们想测试输入A固定为0的情况。一位技术人员，也许是早上犯困，决定使用[测试向量](@article_id:352095) $(A, B, C) = (1, 1, 1)$ [@problem_id:1934772]。会发生什么？

*   **在正常电路中：** $F = 1 \lor 1 \lor 1 = 1$。输出为“1”。
*   **在故障电路中（A s-a-0）：** 门看到的输入是 $(0, 1, 1)$。输出是 $F_{\text{fault}} = 0 \lor 1 \lor 1 = 1$。输出也是“1”。

输出完全相同！故障被完全掩盖了。尽管故障存在，但这个特定的[测试向量](@article_id:352095)对它视而不见，因为[或门](@article_id:347862)的其他“1”输入“掩盖”了故障的“0”。这个教训很清楚：选择正确的[测试向量](@article_id:352095)至关重要。

一个成功的[测试向量](@article_id:352095)必须完成两项任务：

1.  **激活故障：** 你必须尝试将故障线路设置为其“固定”状态的相反值。要测试固定为0的故障，你必须施加在正常电路中会使该线路为“1”的输入。要测试固定为1的故障，你必须尝试使其为“0”。这在故障位置产生了最初的差异，一个小的“位翻转”。

2.  **传播错误：** 这个最初的错误还不够。它必须穿过其余的逻辑门，到达一个我们可以看到它的主输出。这个错误的路径必须被敏化。对于一个与门，要从一个输入传播一个错误，其他输入必须为“1”。对于一个[或门](@article_id:347862)，其他输入必须为“0”。

让我们用一个稍微复杂一点的电路来看看这个过程：$F = (A \land B) \oplus (B \land C)$，其中 $\oplus$ 是异或（XOR）运算。假设我们施加[测试向量](@article_id:352095) $(A, B, C) = (1, 1, 0)$ [@problem_id:1928183]。在正常电路中，中间线路 $n_1 = A \land B = 1 \land 1 = 1$，并且 $n_2 = B \land C = 1 \land 0 = 0$。最终输出是 $F = 1 \oplus 0 = 1$。

现在，我们来测试“输入C固定为1”(C s-a-1)这个故障。
1.  **激活：** [测试向量](@article_id:352095)将 $C$ 设置为0。故障是固定为1。所以，是的，故障被激活了。
2.  **传播：** 在故障电路中，门看到的输入是 $(1, 1, 1)$。中间线路 $n_2$ 现在计算 $1 \land 1 = 1$（而不是正确的“0”）。这个错误，即 $n_2$ 上的“1”，现在传播到最终的[异或门](@article_id:342323)。[异或门](@article_id:342323)现在计算 $F_{\text{fault}} = n_1 \oplus n_2 = 1 \oplus 1 = 0$。

正常电路的输出是“1”。故障电路的输出是“0”。它们是不同的！故障被检测到了。同一个[测试向量](@article_id:352095) $(1,1,0)$ 恰好也能检测到A固定为0、B固定为0以及其他几个故障，这表明一个精心挑选的向量可以成为一个强大的侦探。

### 测试的极简指南

如果一个向量可以捕捉多个故障，下一个自然的问题是，我们需要*最小*的[测试向量](@article_id:352095)集来保证我们能捕捉到*每一个可能*的单一[固定型故障](@article_id:350358)是什么？这不是一个学术难题；在制造业中，时间就是金钱。更少的[测试向量](@article_id:352095)意味着更快的测试和更便宜的芯片。目标是用**最小测试集**实现**100%的[故障覆盖率](@article_id:349648)**。

让我们为我们的双输入与门构建这样一个集合 [@problem_id:1934760]。可能的单一故障有：A s-a-0、A s-a-1、B s-a-0、B s-a-1、Y s-a-0 和 Y s-a-1。

*   要测试**Y固定为0**，我们必须尝试使输出为“1”。唯一的方法是使用向量 **(1, 1)**。这个向量也很方便地检测到A s-a-0和B s-a-0。（为什么？对于A s-a-0，门看到(0,1)并输出0，与正常的输出1不同）。

*   要测试**A固定为1**，我们必须设置A=0来激活故障。为了通过[与门](@article_id:345607)传播错误，我们必须设置B=1。所以，我们需要向量 **(0, 1)**。

*   对称地，要测试**B固定为1**，我们需要向量 **(1, 0)**。

我们完成了！这三个向量的集合 `{(0, 1), (1, 0), (1, 1)}` 足以检测所有六种可能的单一[固定型故障](@article_id:350358)。向量(0,0)是不需要的，因为它可能检测到的任何故障都已经被其他向量捕捉到了。找到最小[测试集](@article_id:641838)的过程是一个关于逻辑和效率的美妙谜题。

### 简化搜索：故障等效与冗余

随着我们深入研究，我们发现不同故障之间存在着优雅的关系，这使我们能够进一步简化搜索。

有些故障，虽然位于不同位置，但却无法区分。它们是**不可区分的**或**功能等效的**。对于一个双输入与非门，考虑“输入A固定为0”与“输入B固定为0” [@problem_id:1934740]。在[与非门](@article_id:311924)中，如果*任何*输入为0，输出就被强制为1。所以如果A固定为0，输出总是1。如果B固定为0，输出也总是1。从外部看，只看输入和输出，这两个故障产生完全相同的行为。它们是两种具有完全相同症状的不同疾病。一个更基本的例子发生在一个反相器（非门）中。输入固定为1在功能上等效于输出固定为0 [@problem_id:1934730] [@problem_id:1934751]。如果输入A固定为“1”，输出总是 $\neg 1 = 0$。如果输出Y只是固定为“0”，那么输出...嗯，就是“0”。它们的测试集是相同的。

认识到这些等效性非常有用。它允许进行**故障缩减**，即我们可以将许多故障分组为一个单一的代表。如果我们为其中一个生成了测试，我们就自动地为所有等效故障生成了测试，从而大大减小了问题的规模。

但是，终极的简化又是什么呢？如果一个故障无论我们使用什么[测试向量](@article_id:352095)都无法检测到怎么办？这样的故障被称为**不可检测的**，它的存在指向了一个有趣的事情：[电路设计](@article_id:325333)中的**[逻辑冗余](@article_id:353051)**。

想象一个为实现函数 $F = (A \cdot B) + (\overline{A} \cdot C) + (B \cdot C)$ 而构建的电路 [@problem_id:1928145]。通过布尔代数中称为一致性定理的规则，这个表达式完全等价于 $F = (A \cdot B) + (\overline{A} \cdot C)$。第三项 $(B \cdot C)$ 是完全冗余的！这就像同时戴着腰带和吊裤带；其中一个没有起到实际作用。现在，如果承载这个冗[余项](@article_id:320243) $(B \cdot C)$ 信号的导线出现固定为0的故障会怎样？其效果是逻辑变为 $F_{\text{fault}} = (A \cdot B) + (\overline{A} \cdot C) + 0$，这正是 $(A \cdot B) + (\overline{A} \cdot C)$。这与简化的、正确的函数完全相同！对于所有可能的输入，故障电路的行为*完全*像无故障电路一样。这个故障就像机器中的幽灵，虽然存在却完全不可见。这是一个深刻的发现：测试一个电路的困难可以揭示其设计本身存在的根本缺陷或低效之处。

### 当逻辑遇到物理：超越固定型模型

固定型模型是一个强大而优雅的抽象。但我们决不能忘记它*是*一个抽象。物理的真实世界总是比我们的模型更丰富，有时也更奇怪。**[固定开路故障](@article_id:351461)**完美地说明了这一点 [@problem_id:1934722]。

在现代[CMOS技术](@article_id:328984)中，[逻辑门](@article_id:302575)由成对的晶体管构成：一个由p[MOS晶体管](@article_id:337474)组成的拉高网络，用于将输出连接到“1”(VDD)；一个由n[MOS晶体管](@article_id:337474)组成的拉低网络，用于将其连接到“0”(地)。当一个晶体管永久性地无法导通，像一个打开的开关一样时，就发生了[固定开路故障](@article_id:351461)。

让我们看一个CMOS与非门，并考虑拉高网络中的一个p[MOS晶体管](@article_id:337474)出现固定开路的情况。要测试这个故障，我们需要施加一个*仅*依赖于这个故障晶体管来将输出拉高的输入。在故障电路中，这意味着拉高和拉低网络都将与输出断开。输出既不被驱动到“1”也不被驱动到“0”。它被留在一个**[高阻态](@article_id:343266)**中。

一根悬空的导线会发生什么？在这里，物理学再次发挥作用。输出导线有一个微小但不可避免的**[寄生电容](@article_id:334589)**——一种储存少量[电荷](@article_id:339187)的能力，就像一个小水桶。悬空导线上的电压，以及它的逻辑电平，现在取决于*前一次*操作留在这个桶里的[电荷](@article_id:339187)。突然之间，我们简单的组合门拥有了记忆！它的输出不仅取决于当前输入，还取决于过去。

这就是为什么[固定开路故障](@article_id:351461)需要一个双向量测试序列。
1.  **向量1（初始化）：** 首先，我们施加一个输入（如对于[与非门](@article_id:311924)的A=1, B=1），可靠地将输出连接到地，清空电容桶并将输出设置为一个已知的“0”。
2.  **向量2（测试）：** 我们立即跟随一个试图使用故障晶体管的[测试向量](@article_id:352095)。在正常电路中，这个晶体管会导通并填满水桶，将输出拉到“1”。在故障电路中，晶体管保持开路，到VDD的路径被切断，输出保持在它被初始化为的“0”状态。

最终状态的差异揭示了故障。这是一个惊人的例子，说明了更深层次的物理现实如何穿透我们整洁的逻辑模型。固定型模型帮助我们完成了90%的工作，但要理解机器的真实本质，我们需要记住一直存在的物理——电容。这是一个谦逊而美丽的提醒：我们的模型是地图，而不是领土本身，有时最有趣的发现是在我们看到地图与领土分歧的地方。