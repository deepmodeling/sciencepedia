## 引言
在一个序列中查找另一个序列是计算机科学中最基本的任务之一，从在文档中搜索一个单词到在 DNA 链中识别一个基因。虽然最直观的方法——将模式串沿着文本逐个字符地滑动——很容易理解，但它可能极其低效，尤其是在处理大量或重复性数据时。这种性能差距凸显了对一种能从自身过程中学习的[算法](@article_id:331821)的需求。本文深入探讨了 Knuth-Morris-Pratt (KMP) [算法](@article_id:331821)，这是一个卓越的解决方案，它通过在搜索开始前就理解模式串的内部结构来达到惊人的速度。在接下来的章节中，我们将首先揭示 KMP 的核心“原理与机制”，从朴素方法的缺陷到前缀函数的精妙之处。随后，我们将拓宽视野，探索该[算法](@article_id:331821)多样化的“应用与跨学科联系”，揭示这个优雅的思想如何解决远超简单文本搜索范围的问题。

## 原理与机制

要欣赏一个巧妙解决方案的精妙之处，我们必须首先面对那个简单、显而易见，但又常常慢得令人痛苦的方法。任务很简单：在一个大得多的**文本**中，找到一个小的字符串，即**模式串**。你会怎么做？

### 朴素[算法](@article_id:331821)的问题

最直接的方法，我们可称之为**朴素[算法](@article_id:331821)**，就是你可能会用手操作的方式。你将模式串与文本的开头对齐，然后逐个字符地进行比较。如果它们全部匹配，恭喜！你找到了一个匹配项。如果遇到不匹配的情况，你叹口气，将模式串在文本中向后滑动一个位置，然后从模式串的开头重新开始整个比较过程。

这个方法是可行的。它简单且正确。但它高效吗？想象一下，在一个重复的文本（比如一条 DNA 链）中搜索一个几乎同样重复但又不完全一样的模式串。考虑一个由一百万个‘A’组成的文本字符串 $T$ 和一个像 "AAAA...AAB" 这样的模式串 $P$ [@problem_id:2396165]。在第一个位置，你会逐个字符地比较并匹配，结果却在最后一个字符上发现不匹配。真糟糕。于是你将模式串滑动一个位置。现在会发生什么？你再次比较几乎整个模式串，然后再次在最后一个字符处失败。你将重复这个令人沮丧的过程近一百万次，每次都做大量的工作，却在最后一刻失败。总比较次数会激增，接近文本和模式串长度的乘积，即 $O(nm)$ 的复杂度，对于长字符串来说，这可能是灾难性的慢。

朴素方法的根本缺陷在于“遗忘”。在一次失配之后，它忘记了刚刚学到的一切。当我们从模式串中匹配了 "AAAA...AA" 到文本时，我们*知道*文本包含一个长序列的‘A’。当我们将模式串滑动一个位置时，我们假装不知道这一点，并费力地重新验证它。我们当然可以做得更好。

### 模式串中的秘密：公共前后缀 (Border)

Knuth-Morris-Pratt (KMP) [算法](@article_id:331821)的伟大洞见在于，实现“更智能”移位的关键不在于文本，而*完全在于模式串自身的结构*。让我们思考一下失配时会发生什么。假设我们在模式串 $P$ 的第 $q+1$ 个字符处失败之前，已经成功匹配了 $q$ 个字符。这意味着我们刚刚看到的文本部分与前缀 $P[0..q-1]$ 是相同的。

现在，我们不想仅仅移位一个位置，而是希望将模式串尽可能地向前滑动。如果模式串的一个较短前缀（比如说长度为 $k$）与我们刚刚成功扫描的文本段的*末尾*相匹配，那么新的对齐可能是有效的。由于那段文本与 $P[0..q-1]$ 相同，这也就等同于说，我们在寻找 $P$ 的一个前缀，这个前缀同时也是 $P[0..q-1]$ 的一个*后缀*。

这种特殊的字符串——既是自身前缀又是自身后缀的字符串——被称为**公共前后缀 (border)**。例如，在字符串 "abracadabra" 中，"abra" 是一个长度为 4 的公共前后缀。在 "ababa" 中，"aba" 是一个长度为 3 的公共前后缀，"a" 是一个长度为 1 的公共前后缀。最长的这种真公共前后缀（proper border，即不等于原串本身的公共前后缀）是我们能拥有的最有用信息 [@problem_id:3276209]。

如果子串 $P[0..q-1]$ 有一个长度为 $k$ 的最长公共前后缀，这意味着模式串的前 $k$ 个字符 ($P[0..k-1]$) 与其后 $k$ 个字符 ($P[q-k..q-1]$) 是相同的。因此，在位置 $q$ 发生失配后，我们可以将模式串向前滑动，使其长度为 $k$ 的前缀与已匹配文本的后缀对齐。我们不必重新检查这 $k$ 个字符！我们已经知道它们是匹配的。我们可以简单地从字符 $P[k]$ 开始，与导致原始失配的文本字符继续进行比较。我们利用了模式串的内部结构来跳过冗余的工作。

### 为失配构建地图：前缀函数

这个想法很强大，但我们需要一种系统化的方法来应用它。我们不能在运行时动态地重新计算最长公共前后缀。解决方案是为模式串的*每个前缀*预先计算这些信息，并将其存储在一个表中。这个表通常被称为**前缀函数**或 **π-表**，是 KMP [算法](@article_id:331821)的核心 [@problem_id:3205723]。

对于一个长度为 $m$ 的模式串 $P$，π-表是一个数组，其中 $\pi[i]$ 存储了前缀 $P[0..i]$ 的最长真公共前后缀的长度。

让我们为模式串 $P = \text{"aabaaab"}$ 构建一个 π-表。
- $\pi[0]$ ("a"): 没有真公共前后缀。长度为 0。
- $\pi[1]$ ("aa"): 最长公共前后缀是 "a"。长度为 1。
- $\pi[2]$ ("aab"): 没有真公共前后缀。长度为 0。
- $\pi[3]$ ("aaba"): 最长公共前后缀是 "a"。长度为 1。
- $\pi[4]$ ("aabaa"): 最长公共前后缀是 "aa"。长度为 2。
- $\pi[5]$ ("aabaaa"): 最长公共前后缀是 "aa"。长度为 2。
- $\pi[6]$ ("aabaaab"): 最长公共前后缀是 "aab"。长度为 3。

所以，“aabaaab” 的 π-表是 $[0, 1, 0, 1, 2, 2, 3]$。

我们如何高效地构建这个表呢？在一个美妙的自引用展示中，该[算法](@article_id:331821)使用它已经计算出的表值来寻找下一个值。为了计算 $\pi[i]$，我们查看前一个值 $\pi[i-1]$。假设这个长度是 $k$。这告诉我们前缀 $P[0..i-1]$ 有一个长度为 $k$ 的公共前后缀。然后我们问：我们能将这个公共前后缀延长一个字符吗？也就是说，下一个字符 $P[k]$ 是否与我们正在添加的新字符 $P[i]$ 相同？如果是，那么新的最长公共前后缀长度为 $k+1$，所以 $\pi[i] = k+1$。

如果不是 ($P[k] \neq P[i]$)，我们就不能延长这个公共前后缀。但也许 $P[0..i-1]$ 的一个*更短的*公共前后缀可以被延长。而 $P[0..i-1]$ 的次长公共前后缀是什么？正是它*最长公共前后缀的最长公共前后缀*！其长度由 $\pi[k-1]$ 给出。所以我们将 $k$ 更新为这个新的、更短的长度，并重复检查。这个“回退”链会一直持续，直到我们找到一个可以延长的公共前后缀，或者用尽所有选项（当 $k=0$ 时），在这种情况下，$P[0..i]$ 的最长公共前后缀长度为 0（或者如果 $P[0] = P[i]$ 则为 1）。这个巧妙的过程通过一次线性的遍历构建了整个 π-表，时间复杂度为 $O(m)$。

### 作为一次旅程的搜索：KMP 作为状态机

有了 π-表在手，搜索本身就变成了一场优雅的前进。我们可以将整个 KMP 过程想象成一个**[有限自动机](@article_id:321001)**，一个专为我们的模式串构建的简单“状态机”[@problem_id:1421380]。

想象一个有 $m+1$ 个状态的机器，标记为 $S_0, S_1, \dots, S_m$。
- 每个状态 $S_q$ 代表一个特定的成就：“我们刚刚成功匹配了模式串的前 $q$ 个字符。”
- 起始状态是 $S_0$（我们还没有匹配任何东西）。
- 唯一的接受状态是 $S_m$（我们已经匹配了整个模式串）。

现在，我们把文本逐个字符地输入这台机器。
- 如果我们处于状态 $S_q$，并且文本中的下一个字符与 $P[q]$ 匹配，我们就扩展了我们的匹配！我们转移到状态 $S_{q+1}$。
- 如果我们处于状态 $S_q$，并且文本中的下一个字符与 $P[q]$ *不*匹配，我们就遇到了失配。我们是否要回到 $S_0$？不！这就是我们的 π-表发挥作用的地方。该表告诉我们“失败转移”的目标。我们转移到状态 $S_k$，其中 $k = \pi[q-1]$。这是对应于我们刚刚匹配部分的最长公共前后缀的状态。实际上，我们已经瞬间移动了模式串，并准备好用当前的文本字符与新的模式串字符 $P[k]$ 进行比较。

KMP [搜索算法](@article_id:381964)无非就是对这个状态机的模拟 [@problem_id:3205754]。文本指针 `i` 总是向前移动，从不后退。模式串的状态 `q` 要么在匹配时前进，要么在失配时优雅地回退到一个更短的部分匹配。总工作量与文本长度加模式串长度成正比，即 $O(n+m)$，这相对于朴素的 $O(nm)$ 是一个惊人的改进。

### 超越搜索：揭示字符串的节奏

为高效搜索而创建的前缀函数， ternyata 是一个能够深入探究字符串本质的工具。它揭示了字符串的内部重复和对称性。其中一个最优雅的应用是寻找字符串的**周期** [@problem_id:3276273]。

如果一个字符串 $s$ 由其前 $p$ 个字符重复构成，那么它就具有长度为 $p$ 的周期。例如，“abcabcabc” 的周期为 3，因为它由 “abc” 重复而成。字符串 “abcabca” 不是一个完美的重复，但它是 “abc” 重复序列的一个前缀，所以它的周期也是 3。

字符串的周期与其最长公共前后缀之间存在一个优美而直接的联系。如果一个长度为 $n$ 的字符串 $s$ 的最长公共前后缀长度为 $b_{max}$，那么它的最短周期长度就是 $p = n - b_{max}$。为什么？因为一个长度为 $n-p$ 的公共前后缀意味着前 $n-p$ 个字符与后 $n-p$ 个字符相同，这强制满足了周期性条件 $s[i] = s[i+p]$ 对于所有有效的 $i$。

要找到任何字符串的最短周期，我们不再需要测试所有可能的长度。我们只需计算它的 π-表，从最后一个条目 $\pi[n-1]$ 中找到其最长公共前后缀的长度，然后计算 $p = n - \pi[n-1]$。这使我们能够立即回答诸如一个字符串是否为完美幂 $s = u^k$（其中 $k \ge 2$）的问题，这是分析 DNA 序列中串联重复时的一个常见问题 [@problem_id:1411649]。

### [算法](@article_id:331821)的普适性

也许 KMP [算法](@article_id:331821)最深刻的方面是其纯粹的通用性。我们一直在谈论“字符”和“字符串”，但[算法](@article_id:331821)实际上并不关心元素是什么。它是一个用于在一个序列中查找另一个序列的抽象过程。它唯一需要的操作是测试两个项目是否相等的方法。

这些“项目”可以是 ASCII 字符，就像我们简单的例子一样。但它们同样可以是旋律中的音符，蛋白质中的氨基酸，或者在更复杂的场景中，是整个 Unicode **字形簇** [@problem_id:3276142]。一个字形簇是一个“用户感知的字符”，它可能由多个底层的码点构成。例如，表情符号 “👩‍💻”（技术专家）通常表示为三个码点的序列：“👩”（女人）+ 一个零宽度连接符 + “💻”（笔记本电脑）。

要在文本中搜索 “👩‍💻”，一个朴素的逐字节搜索会感到困惑。但对于 KMP 来说，这很简单。我们首先将文本和模式串分词成这些字形簇的序列。然后，我们运行完全相同的 KMP [算法](@article_id:331821)，但这一次，相等性检查变成了“这个字形簇是否等于那个字形簇？” 逻辑、π-表、状态机——一切都完美运作。该[算法](@article_id:331821)的根本之美在于这种抽象，它能够在任何可以定义序列和同一性的领域中找到模式。这证明了对一个简单问题的深刻理解如何能够产生一个具有非凡力量和普适性的解决方案。

