## 引言
在多核计算的世界里，允许多个线程同时访问共享数据是提升性能的关键。然而，这种并发性带来了一个危险的挑战：如何在不冒着其他线程仍在使用数据的风险下，安全地移除数据并回收其内存？简陋的解决方案可能导致灾难性的“[释放后使用](@entry_id:756383)”错误、[数据损坏](@entry_id:269966)和安全漏洞。这个根本性问题需要比简单的锁或计数器更复杂的办法，因为它们常常引入性能瓶颈或微妙的竞争条件。

本文将探讨基于周期的回收 (Epoch-Based Reclamation, EBR)，一种为解决此问题而设计的优雅且高性能的技术。首先，在“原理与机制”部分，我们将深入探讨 EBR 的核心思想，并将其与更简单的方法进行对比，以理解其独特的设计。我们将揭示保证读者与回收者之间安全性的契约，并审视[内存屏障](@entry_id:751859)在现代硬件上实现此契约的关键作用。随后，“应用与跨学科联系”部分将展示 EBR 的广泛影响，从在数据库中实现[无锁数据结构](@entry_id:751418)，到其在[操作系统](@entry_id:752937)中的角色，再到其在持久内存领域的扩展。

## 原理与机制

想象一个繁忙而巨大的图书馆，成千上万的人同时在阅读书籍。这些书是庞大共享[数据结构](@entry_id:262134)中的节点，而读者则是多核处理器中的线程。现在，一[位图](@entry_id:746847)书管理员——我们的“写者”线程——需要从书架上移除一本陈旧过时的书。这看似简单，却充满危险。万一有个读者刚好看到了这本书，正走过去取呢？万一另一个读者正读到一半呢？如果图书管理员只是简单地把书拿走并送进焚化炉（编程中的 `free()` 函数），她就会让读者手中空无一物，或者更糟的是，这本书的内存位置被一本完全不同主题的新书所取代。当读者试图继续阅读时，他们会发现自己在读一堆乱码。这就是可怕的**[释放后使用](@entry_id:756383) (use-after-free)** 错误，一个导致程序崩溃和安全漏洞的臭名昭著的 bug。

这不是两个图书管理员试图同时在同一本账本上写字的问题，一个简单的锁就能解决。这是一个读者和写者之间远为微妙的协作。根本的挑战在于，如何确保数据在从共享结构中移除*后*能被安全回收，同时又不妨碍并发读者的流程。这正是**基于周期的回收 (Epoch-Based Reclamation, EBR)** 这个优美而优雅思想发挥作用的地方。

### 简单计数的问题

一个初步的直观想法可能是：为什么不直接计算每本书有多少读者在看呢？我们可以在每本书上附加一个**引用计数** [@problem_id:3663942]。当读者拿起一本书时，他们增加其计数值。读完后，他们减少计数值。图书管理员只在计数值降为零时才焚化书籍。

这看似合理，但有两个致命缺陷。第一个是微观层面上的[竞争条件](@entry_id:177665)。一个读者线程 $T_1$ 可能读取了指向一本书（比如 `Book X`）的指针。在 $T_1$ 拿到指针*之后*但*还未来得及*增加引用计数的极小瞬间，另一个线程 $T_2$ 可能已经读完这本书，将其计数值减为零，并让它被焚化了。当 $T_1$ 最终试图增加计数值时，它操作的是一个幽灵，一个指向已释放内存的悬空指针 [@problem_id:3687328]。

第二个缺陷更为隐蔽：**循环引用**。想象两本书 `A` 和 `B`，它们只相互引用。书 `A` 有个脚注写着“参见书 `B`”，书 `B` 也有个脚注写着“参见书 `A`”。即使外部世界再也没有人阅读它们，它们也会让彼此的引用计数保持为 1。它们实际上是垃圾，被困在书架上，但“计数值为零时回收”的简单规则意味着它们永远不会被移除，导致永久性的[内存泄漏](@entry_id:635048) [@problem_id:3663942]。我们需要一个更复杂的想法。

### 周期的洞见：时间的契约

EBR 不再追踪每一本书，而是将我们的视角转向追踪*时间*。整个系统遵循一个全局时钟，但这个时钟不是以秒为单位，而是以**周期 (epoch)** 为单位。周期只是一个定期递增的数字。EBR 的核心是读者和回收者之间一个简单而深刻的契约。

*   **读者的契约**：“每当我进入图书馆开始阅读（一个读侧临界区）时，我都会在一个共享的白板上写下当前的全局周期（比如 $E$）来公开宣告。我保证在我访问期间，只访问在周期 $E$ 开始*之前*就已存在的数据。”

*   **回收者的契约**：“当我从书架上移除一本书时，我不会立即销毁它。我会用当前的周期 $r$ 标记它，并将其放入一个‘退休箱’中。我只有在查看白板并确认**每个活跃的读者**都已宣告了一个严格大于 $r$ 的周期 $a_j$（即 $a_j \gt r$）时，才会回收标记为周期 $r$ 的书。如果一个读者不活跃（不在图书馆里），则无需关心。”

这个简单的规则是 EBR 安全保证的核心 [@problem_id:3687328]。如果每个活跃的读者都宣告了一个比 $r$ 更晚的周期，这就保证了他们中没有任何人可能拿到在周期 $r$ 期间退休的书籍的引用。他们都是在“事后”才到达的。回收者现在可以安全地清空周期 $r$ 的退休箱。这个优雅的机制绕开了对每个对象加锁或计数的需要。更妙的是，由于回收基于全局可达性和时间，而非引用计数，它能优雅地处理循环引用问题。一旦书 `A` 和 `B` 组成的整个循环从主图书馆的书架上被断开链接，这些节点就会被退休。宽限期过后，无论它们的内部引用如何，它们都会被回收 [@problem_id:3663942]。

### 实现契约：[内存屏障](@entry_id:751859)的语言

这个契约在抽象层面听起来很棒，但在现代多核处理器上，我们必须极其小心。处理器和编译器为了提高性能，喜欢对指令进行重排。一个读者可能会执行 `宣告我的周期；然后访问数据` 的代码，但硬件可能将其重排为 `访问数据；然后宣告我的周期`。这将是灾难性的，因为读者将在没有保护的情况下访问数据。

为了强制执行正确的顺序，我们必须使用**[内存屏障](@entry_id:751859) (memory fences)**，特别是**[释放-获取语义](@entry_id:754235) (release-acquire semantics)**。可以这样理解：

*   一个**存储-释放 (store-release)** 操作就像是密封并邮寄一个重要的包裹。你保证你打算放进包裹的所有东西（所有先前的内存写入）都在它被寄出（存储操作对他人可见）*之前*就已放入。
*   一个**加载-获取 (load-acquire)** 操作就像是接收并打开那个包裹。你保证在对包裹内容做任何事情（后续的内存读取）之前，你会看到所有被密封在里面的东西。

这种“同步于 (synchronizes-with)”关系至关重要。为了正确实现 EBR，几个操作必须使用这种严谨的语言 [@problem_id:3656612] [@problem_id:3645725]：

1.  **读者进入**：当读者宣告其周期时，该写入必须是 `store-release`。这确保了宣告在任何数据被实际读取之前是可见的。
2.  **读者退出**：当读者清除其宣告时，也必须是 `store-release`，确保其所有读取在其显示为不活跃之前完成。
3.  **回收者检查**：当回收者扫描读者的宣告时，其读取必须是 `load-acquire`。这确保它能获取到读者用 `store-release` 发布的最新状态。
4.  **更新者发布**：当更新者将一个新创建的节点链接到一个共享[数据结构](@entry_id:262134)中时，指针更新必须是 `store-release`，以确保节点的字段在它变得可见之前已完全初始化。反过来，读者必须使用 `load-acquire` 来读取该指针，以保证它看到的是一个完整形成的节点 [@problem_id:3625554]。

没有这些明确的排序约束，整个契约在现代 CPU 的[弱内存模型](@entry_id:756673)上就会土崩瓦解。

### 优雅的代价：性能与陷阱

EBR 是一个强大的工具，但它的优雅伴随着特定的权衡。

#### 优点：快如闪电的读侧

与**风险指针 (Hazard Pointers, HP)** 等替代方案相比（在 HP 中，读者必须保护它解引用的*每一个指针*），EBR 的读侧操作极其轻量。读者只需在操作开始时宣告一次自己的存在，在结束时清除即可。对于需要遍历许多节点的操作，这种摊销开销是一个巨大的性能胜利，为读者带来了更快的“快速路径”[@problem_id:3664164] [@problem_id:3625554]。

#### 代价：一致性流量

每个 EBR 读者的“宣告”都是对一个共享（或至少是全局可见）内存位置的写入。在采用基于失效的[缓存一致性协议](@entry_id:747051)（如 MESI）的现代 CPU 上，每次写入都可能代价高昂。当核心 1 上的读者线程写入其周期槽时，它必须使可能正在观察它的任何其他核心（例如回收者线程）上的该缓存行副本失效。在一个读操作密集的系统中，这会在处理器的互连总线上产生大量隐藏的“一致性流量”[@problem__id:3625554]。更高级的设计通过使用每核心的宣告槽来缓解这个问题，这可以防止读者之间相互竞争，但读者与回收者之间的基本通信仍然存在硬件成本 [@problem_id:3625531]。

#### 阿喀琉斯之踵：阻塞的读者

这是 EBR 最大的弱点。回收者的契约是铁板一块的：它必须等待*每个*线程都通过某个周期。如果一个读者线程宣告了它的周期，然后被[操作系统](@entry_id:752937)抢占——被置于休眠状态任意长的时间，会发生什么？[@problem_id:3663925]

这个单一的阻塞线程就像整个系统的锚。因为它从未更新其周期宣告，全局回收过程陷入停顿。写者可以继续退休节点，但没有一个可以被释放。“退休箱”溢出，内存使用量急剧上升。未回收内存的数量与阻塞持续时间 $T$ 和退休速率 $\lambda$ 呈[线性增长](@entry_id:157553)。这个积压量与 $\Theta(\lambda T)$ 成正比 [@problem_id:3245657] [@problem_id:3663917]。一个阻塞的线程就可能导致整个系统耗尽内存。

唯一真正稳健的解决方案是打破算法与系统之间的壁垒。必须让[操作系统](@entry_id:752937)的调度器意识到 EBR 的存在。当调度器抢占一个线程时，它可以检查该线程是否处于 EBR [临界区](@entry_id:172793)内。如果不是，[操作系统](@entry_id:752937)可以代表该线程报告一个“静止状态”。如果是，[操作系统](@entry_id:752937)可以给该线程一个优先级提升，以确保它能快速完成其工作，而不会拖累整个系统 [@problem_id:3663925]。这种算法、硬件和[操作系统](@entry_id:752937)之间的协同作用，证明了计算机科学的统一性——最优雅的解决方案往往是那些拥抱整个技术栈的方案。

