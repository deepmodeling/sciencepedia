## 引言
在[并发编程](@entry_id:637538)的世界里，传统锁是防止[数据损坏](@entry_id:269966)的既定方法，但其悲观的性质常常造成性能瓶颈。通过强制线程排队等待，锁可能导致 CPU 周期的浪费和全系统范围的降速，即使在实际[数据冲突](@entry_id:748203)的可能性很低时也是如此。这种低效率凸显了一个根本性的空白：需要一种在无争用的普遍情况下速度快，而在冲突发生时又足够安全的同步机制。

本文探讨了事务性锁省略（TLE），这是一种强大的[乐观并发控制](@entry_id:752985)技术，正是为了解决这个问题而生。通过利用[硬件事务内存](@entry_id:750162)（HTM），TLE 允许线程推测性地绕过锁，寄望于一次无冲突的执行来获得显著的速度提升。您将学习到这种在乐观与实用之间优雅的舞蹈是如何实现的，从硬件层面一直到软件设计模式。接下来的章节将引导您了解这一概念，从其核心机制开始，然后探索其广泛的影响。

## 原理与机制

在我们理解现代计算机如何同时处理多个任务的旅程中，我们经常会遇到不起眼的锁。它就像一个数字交通警察，确保当一个执行线程需要处理一段共享数据时，没有其他线程可以干扰。这对于正确性至关重要，但它是有代价的。让我们层层剥开，去发现一种更 audacious（大胆）且通常快得多的方式来实现同样的目标：**事务性锁省略（TLE）**。

### 锁的暴政

想象一个受欢迎的咖啡店，里面有一台非常复杂的浓缩咖啡机。为了避免混乱，规定是同一时间只有一个咖啡师能使用这台机器。第一个到达的咖啡师在上面挂一个“使用中”的牌子（获取锁），做一杯咖啡，然后取下牌子（释放锁）。其他咖啡师在等待时做什么呢？他们站在那里，不耐烦地跺着脚，反复检查牌子是否已经拿走。

这正是**[自旋锁](@entry_id:755228)**所做的事情。一个想要进入由锁保护的代码“临界区”的线程会运行一个紧凑的循环，反复执行像“[测试并设置](@entry_id:755874)”（Test-And-Set）这样的[原子指令](@entry_id:746562)，仅仅为了等待轮到自己而消耗 CPU 周期。这种“[忙等](@entry_id:747022)待”不仅浪费；在高争用（许[多线程](@entry_id:752340)想要同一个锁）的情况下，持续的[轮询](@entry_id:754431)会在处理器的核心之间产生一场通信风暴，进一步拖慢了所有人的速度 [@problem_id:3684306]。

这种方法从根本上是悲观的。它假设冲突很可能发生，所以它总是强制线程串行化——排成单行——即使它们即将执行的是快速、无干扰的任务。难道没有更好的方法吗？

### 乐观主义者的赌博：事务性锁省略

如果一个咖啡师不用排队，而是可以直接走到一台浓缩咖啡机的幻影副本前开始做咖啡，会怎么样？他们会用心记下自己接触过的所有东西。如果他们在没有其他人干扰*真实*机器的情况下完成，他们就可以神奇地将自己完美制作的咖啡与柜台上的咖啡在一个瞬时步骤中交换。然而，如果另一个咖啡师以冲突的方式开始使用真实机器，我们的英雄只能叹口气，扔掉他的幻影咖啡，然后决定下一步该怎么做。

这就是事务性锁省略背后美丽而乐观的想法。一个线程不再获取锁，而是简单地说：“我将*推测性地*执行这个[临界区](@entry_id:172793)，*就好像*我拥有锁一样。”“省略”部分意味着我们正在跳过或省略实际的锁获取操作。线程不挂上“使用中”的牌子；它直接开始工作，赌注没有其他人会妨碍它。这个赌注通常会带来丰厚的回报，尤其是在冲突很少见的情况下。

### 乐观主义的引擎：[硬件事务内存](@entry_id:750162)

这种神奇的幻影咖啡制作，得益于现代处理器中一个卓越的功能，称为**[硬件事务内存](@entry_id:750162)（HTM）**。HTM 为线程提供了一种机制，可以将一个代码块定义为一个**事务**。

可以把事务看作是与硬件签订的一份合同：“亲爱的处理器，请执行以下内存读写序列。请确保这整个序列对系统的其余部分来说，表现为一个单一、不可分割（原子）的操作。如果你能做到，就**提交**该事务，让我所有的更改一次性永久生效并可见。如果出于任何原因你无法保证这一点——比如另一个线程干扰了——那么请**中止**该事务，丢弃我所有的更改，就好像它们从未发生过一样，并通知我。”

为了履行这份合同，硬件会为事务维护一个**读集**和一个**写集**，通常是通过使用处理器自身的缓存系统来实现。当一个事务从一个内存地址读取时，该地址的缓存行被添加到读集。当它写入时，新数据被保存在缓存内的一个特殊事务性状态中，对其他核心不可见，并且该缓存行被添加到写集 [@problem_id:3645909]。

处理器的[缓存一致性协议](@entry_id:747051)（如常见的 **MESI** 协议）成为了冲突检测器。如果另一个核心试图写入我们事务读集中的一个缓存行，或者试图读取或写入我们写集中的一个缓存行，一致性协议就会发出冲突信号。*哔！* 硬件检测到干扰并自动触发中止。推测性写入会立即从缓存中清除，使系统恢复到事务开始前的状态。

通过锁省略，锁变量本身被简单地添加到事务的读集中。线程并不试图*改变*锁变量。它只是观察它。如果另一个线程非事务性地前来获取锁（通过写入它），就会产生一个冲突，从而中止推测性事务，确保了正确性 [@problem_id:3633118]。

### 当好事务变坏时：中止的分类

乐观的路径是美好的，但现实常常介入。事务可能并且确实会因为各种原因而中止。理解这些失败模式是构建稳健系统的关键。

*   **冲突中止（Conflict Aborts）：** 这是最明显的原因。另一个线程以冲突的方式访问了相同的内存。
    *   **真共享（True Sharing）：** 两个线程确实需要修改同一个计数器或更新列表中的同一个条目。这是一个合法的冲突，中止操作正确地防止了数据竞争。
    *   **[伪共享](@entry_id:634370)（False Sharing）：** 这是一个更隐蔽、更有趣的硬件产物。想象一下，16个不同的计数器恰好位于同一个64字节的缓存行上。线程1想要增加计数器#1，而线程2想要增加计数器#2。从逻辑上讲，这些是独立的操作。但由于HTM的冲突检测是在整个缓存行的粒度上工作的，硬件看到线程2正在写入线程1已置于其读/写集中的*同一行*。结果呢？一次冲突中止，尽管实际上没有数据被共享。在这种高争用的场景下，中止率可能飙升，完全违背了TLE的初衷 [@problem_id:3684648]。

*   **容量中止（Capacity Aborts）：** 硬件跟踪读集和写集的能力是有限的。事务性缓冲区或缓存空间可能会被填满。如果一个事务太长或触及了太多不同的内存位置，它可能超出此容量并被迫中止 [@problem_id:3654532]。我们咖啡师的幻影工作台空间也是有限的！

*   **显式中止和系统中止（Explicit and System Aborts）：** 有些操作从根本上是“不可撤销”的。如果一个事务包含向打印机发送数据或向磁盘写入文件的指令怎么办？硬件无法回滚这些操作。像I/O或某些系统调用这样的操作通常在事务内部是被禁止的。尝试执行一个会导致立即中止。一个安全的系统必须首先检测到此类指令，并避免在它们周围省略锁 [@problem_id:3645977]。

### 回退的艺术：一次精算的撤退

鉴于事务可能失败，我们不能无限期地重试。一个线程可能会陷入[活锁](@entry_id:751367)，即它反复尝试并中止，永远无法取得进展。一个稳健的TLE系统必须有一个B计划：一个**回退路径**。这个回退几乎总是我们试图避免的东西——传统的、悲观的锁。

何时放弃乐观主义并退回到锁的安全地带，这是一个关键的性能权衡。让我们从经济学的角度思考一下。
使用锁的预期成本是获取和释放它的开销，加上因争用而[忙等](@entry_id:747022)待的时间。我们称之为 $E_{TAS}$。
一次事务性尝试的预期成本取决于它中止的概率 $r$。一个简单的模型可能看起来像 $E_{TM} = r \cdot A + (1-r) \cdot C_t$，其中 $A$ 是中止和回滚的高昂成本，而 $C_t$ 是成功提交的低开销 [@problem_id:3684306]。

当中止率 $r$ 很低时，事务成本 $E_{TM}$ 远低于锁成本 $E_{TAS}$。但随着争用的增加和 $r$ 的攀升，$r \cdot A$ 这一项开始占主导地位。在某个中止率阈值 $r^*$ 处，反复中止的成本变得比一开始就等待锁的成本还要高。对于一个假设的系统，这个盈亏[平衡点](@entry_id:272705)可能在中止率为 $r^* = 0.36$ 时。如果观察到的中止率超过这个值，那么直接使用锁会更有效率 [@problem_id:3684306]。

一个复杂的系统不会简单地做一次性的决定。一个好的策略可能是：尝试几次事务（比如 $K=3$）。如果它持续失败，就使用**指数退避**——在每次失败后等待更长一点时间——来减少争用。如果所有尝试都失败了，那么最终回退并获取重量级锁 [@problem_id:3621951]。更好的是，一个[运行时系统](@entry_id:754463)可以监控性能计数器，如最近的中止率 $\hat{p}$ 和已提交事务吞吐量 $\hat{\lambda}$，来动态计算[切换策略](@entry_id:271486)的最佳时机 [@problem_id:3645975]。

### 编织安全网：混合世界中的正确性

将乐观的事务与悲观的[锁相](@entry_id:268892)结合，创造了一个强大的混合系统，但它也引入了一些必须小心处理的微妙挑战，以维持正确性。

首先，考虑一个线程中止了它的事务并回退到锁路径。它获取锁，非事务性地执行其写入，然后释放锁。在一个具有[弱内存模型](@entry_id:756673)的处理器上，对其数据的写入和释放锁的写入可能会以[乱序](@entry_id:147540)的方式对其他核心可见！另一个线程可能在看到更新后的数据之前就看到锁是“空闲”的，从而导致混乱。解决方案是在释放锁之前放置一个**释放栅栏**。这就像一个屏障，确保所有先前的内存写入在锁释放可见之前都全局可见，从而保留了锁的预期语义 [@problem_id:3656201]。

其次，这种混合方法可以防止死锁。在经典的死锁中，线程A持有锁 $L$ 并等待锁 $M$，而线程B持有 $M$ 并等待 $L$。如果线程A使用TLE，它不会*持有*锁 $L$。它只是在推测。当它试图访问 $M$ 并发现它被B持有时，它的事务会简单地中止。它从未进入“[持有并等待](@entry_id:750367)”状态，这是[死锁的必要条件](@entry_id:752389)之一，从而打破了[循环依赖](@entry_id:273976) [@problem_id:3633118]。

最后，即使在纯事务性的世界里，也可能出现新问题。考虑**事务性[优先级反转](@entry_id:753748)**。一个长时间运行的、低优先级的事务可能会推测性地修改一个热门的缓存行。许多需要访问此行的短时间、高优先级的事务将持续冲突并中止，实际上在长事务慢悠悠进行时被饿死。一个真正先进的硬件实现可以通过“冲突租约”来解决这个问题。当检测到某一行上的第一次冲突时，负责仲裁访问的缓存目录可以启动一个计时器。如果冲突持续了预定的一段时间 $T$，目录会向长时间运行的事务发送一个强制中止信号，让较短的事务最终能够取得进展 [@problem_id:3645909]。

因此，事务性锁省略不是一个简单的万能灵药。它是从保证的串行化到受控的乐观主义的深刻视角转变。它的美不仅在于它能解锁的原始速度，还在于硬件和软件之间错综复杂的舞蹈——推测、冲突检测、成本分析和恢复的层层机制——所有这些协同工作，构建出一个既快得令人难以置信又可证明正确的系统。

