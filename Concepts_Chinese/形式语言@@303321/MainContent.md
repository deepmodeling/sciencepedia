## 引言
为什么计算机能理解代码却难以理解诗歌？我们如何精确定义一个“问题”，以判断它是否可解？答案就在[形式语言](@article_id:328817)这个优雅的世界中，该领域为描述模式、结构和计算本身提供了一个数学框架。我们的自然语言充满了[歧义](@article_id:340434)和细微差别，而数字世界则要求绝对的精确。[形式语言理论](@article_id:327795)通过将语言定义为由明确规则支配的、定义良好的字符串集合，而非不断演变的文化产物，来弥补这一差距。本文是对计算机科学这一基础领域的介绍。第一章“原理与机制”将解析[形式语言](@article_id:328817)的核心组成部分，从简单的字母表和字符串到对其进行分类的复杂性层级。随后的“应用与跨学科联系”一章将揭示这些抽象概念如何成为强大的工具，驱动着从编程语言编译器到遗传[密码分析](@article_id:375639)等一切事物。

## 原理与机制

我们已经打开了通往形式语言世界的大门，现在让我们深入其中。这些“语言”到底是由什么构成的？又是什么赋予了它们结构和特性？你可能会认为这是一个枯燥、抽象的话题，是数学家的游乐场。但我希望向你展示，事实远非如此。我们即将探讨的原理，正是那些支配着你电脑中[逻辑电路](@article_id:350768)、运行你喜爱应用程序的代码语法，甚至触及我们认知和计算能力基本极限的原理。这是一段从看似微不足道到极致深刻的旅程。

### 语言的原子：字母表、字符串与集合

这个宇宙中的一切都始于一些简单的构建模块。对于[形式语言](@article_id:328817)而言，最基本的模块是**字母表**，我们通常用希腊字母 $\Sigma$ 表示。字母表就是一个符号的[有限集](@article_id:305951)合。它可以像 $\Sigma = \{0, 1\}$ 这样简单，这是所有[数字计算](@article_id:365713)核心的二进制字母表；也可以是 $\Sigma = \{a, b, c, \dots, z\}$，我们用于英语的字母。

基于字母表，我们通过将其符号[排列](@article_id:296886)成一个有限序列来创建**字符串**。因此，`01101`、`abba` 和 `feynman` 都是它们各自字母表上的字符串。有一个我们必须考虑的非常特殊的字符串：**空字符串**。它用 $\epsilon$ 表示，是一个包含零个符号、长度为零的字符串。可以把它想象成寂静之声，一个空无一物的序列。

现在进入正题：一个**语言**不多不少，就是一个**字符串的集合**。就是这样。它可能是一个[有限集](@article_id:305951)，比如由四个字母组成的英语单词的语言；也可能是一个无限集，比如所有由符号 'a' 构成且长度为素数的字符串的语言 [@problem_id:1444079]。

因为语言只是集合，我们可以对它们执行所有我们熟悉的[集合运算](@article_id:303746)。我们可以讨论两个语言的**并集**（$L_1 \cup L_2$，即在 $L_1$ 或 $L_2$ 中的字符串集合）或它们的**交集**（$L_1 \cap L_2$，即同时在两者中的字符串集合）。我们也可以定义一个语言的**补集** $L^c$，它是字母表上所有*不*在 $L$ 中的可能字符串的集合。这意味着我们熟悉的集合论定律同样成立。例如，一个语言补集的[补集](@article_id:306716)就是该语言本身，这个概念被称为[双重否定律](@article_id:330019)，$(L^c)^c = L$ [@problem_id:1366567]。

### 空字符串的奇特案例

这个基于集合的定义引出了一个非常微妙的要点，初学者常常在此绊倒，但它也揭示了该领域的精妙之处。**空语言** $\emptyset$ 和仅包含空字符串的语言 $\{\epsilon\}$ 之间有什么区别？

这看似吹毛求疵，但其重要性不亚于一个空钱包和一个装有价值为零的彩票的钱包之间的区别。空语言 $\emptyset$ 是一个完全不含任何字符串的集合。它是虚空。而语言 $\{\epsilon\}$ 则是一个恰好包含一个字符串的集合：空字符串 $\epsilon$。

让我们看看这为什么重要。我们可以定义一种对语言的操作，称为**串接**。如果我们有两个语言 $L_1$ 和 $L_2$，它们的串接 $L_1 L_2$ 是所有通过从 $L_1$ 取一个字符串并将其与从 $L_2$ 取的一个字符串连接而形成的字符串集合。现在，如果我们将某个语言 $L$ 与我们这两个“空无”的语言进行串接，会发生什么？

如果我们将 $L$ 与空语言 $\emptyset$ 串接，我们得到 $L\emptyset = \emptyset$。这很合理：要形成一个新字符串，你必须从 $L$ 中选一个字符串，并从 $\emptyset$ 中选一个。但你无法从 $\emptyset$ 中挑选字符串——那里一个也没有！所以你无法形成任何字符串，结果语言为空。

但是，如果我们将 $L$ 与 $\{\epsilon\}$ 串接，我们得到 $L\{\epsilon\} = L$。为什么？你从 $L$ 中挑选一个字符串 $w$，而你能从 $\{\epsilon\}$ 中挑选的唯一字符串就是 $\epsilon$ 本身。将它们串接得到 $w\epsilon$，这仍然是 $w$。所以，你得到了 $L$ 中所有原始的字符串。语言 $\{\epsilon\}$ 在串接操作中充当**单位元**，就像数字 1 对于乘法或 0 对于加法一样 [@problem_id:1375115]。

当我们考虑**[克莱尼星号](@article_id:324766)**运算 $L^*$ 时，这种区别变得更加优雅。$L^*$ 表示“零次或多次 $L$ 中字符串的串接”。根据定义，“零次串接”部分总是会给我们空字符串 $\epsilon$。那么，$\emptyset^*$ 是什么呢？它是一个包含 $\epsilon$（来自零次串接）的集合，然后是 $\emptyset$ 中一个字符串的串接、两个字符串的串接，依此类推。但所有这些都是不可能的，所以它们都产生空语言。$\{\epsilon\}$ 和 $\emptyset$ 的并集就是 $\{\epsilon\}$。因此，我们得到了这个优美而简洁的等式：$\emptyset^* = \{\epsilon\}$。一个有趣的转折是，将星号应用于包含空字符串的语言 $\{\epsilon\}^*$ 时，结果也是 $\{\epsilon\}$，因为将空字符串与自身串接任意次仍然得到空字符串 [@problem_id:1406537]。这些并非任意的规则，而是我们简单核心定义的[逻辑推论](@article_id:315479)。

### 复杂性的阶梯：机器与文法

到目前为止，一个语言可以是任何字符串的任意集合。但最有趣的语言是那些有模式的语言。字符串 `101010` 似乎遵循某种规则，而 `110101` 则可能没有。[形式语言理论](@article_id:327795)为我们提供了一种根据复杂性对这些模式进行分类的方法。这种分类就是著名的**[乔姆斯基层级](@article_id:338548)**，我们可以将其视为一个“复杂性的阶梯”。阶梯上的每一级都对应着一种更强大的机器类型，用以识别相应语言的模式。

#### 第一级：[正则语言](@article_id:331534)与有限心智

第一级也是最简单的一级是**[正则语言](@article_id:331534)**。如果一个语言的模式可以被一个具有**有限内存**的机器识别，那么这个语言就是正则的。这种机器被称为**[有限自动机](@article_id:321001)（FA）**。

想象一个小机器人在一个有向图中移动，这个图由一组节点（状态）和连接它们的箭头（转移）组成。每个箭头上都标有我们字母表中的一个符号。机器人从一个指定的起始状态开始。它一次读取一个符号来处理一个字符串。每读取一个符号，它就沿着相应的箭头移动到一个新状态。有些状态被标记为“接受”状态。如果机器人在读完整个字符串后处于一个接受状态，那么该字符串就属于这个语言；否则，就不属于。

关键在于，这台机器只有*有限*数量的状态。这意味着它只有有限的内存。它只能“记住”它当前处于其少数几个状态中的哪一个。

描述这些模式的一种更直观的方式是使用**[正则表达式](@article_id:329549)**。你很可能在文件搜索或文本编辑器中见过它们。像 `(ab|ba)^*a` 这样的表达式简洁地描述了一个语言 [@problem_id:1444103]。它表示“取 `ab` 或 `ba`，将这个选择重复零次或多次，然后以一个 `a` 结尾”。每个[正则表达式](@article_id:329549)都可以转换成一个等价的[有限自动机](@article_id:321001)，反之亦然。它们是描述同一类简单的、内存受限模式的两种不同方式。

但是，这种有限心智的极限在哪里？考虑语言 $L_1 = \{a^n b^n \mid n \ge 0\}$，它由若干个 'a' 后面跟着*相同*数量的 'b' 组成。[有限自动机](@article_id:321001)能识别它吗？要做到这一点，它必须对 'a' 进行计数。但由于 $n$ 可以是任何数字——一百万、十亿、一万亿——机器需要能够存储一个任意大的计数值。一个状态有限的机器是做不到这点的！当它看到足够多的 'a' 之后，它的内存就会“溢出”，从而陷入混乱。

这个想法在著名的**[泵引理](@article_id:339141)**中被形式化了。该引理指出，对于任何[正则语言](@article_id:331534)，足够长的字符串必定包含一个可以被“泵送”（重复任意次数）的片段，并且产生的新字符串仍然在该语言中。这是因为在有限图中一条足够长的路径必然包含一个环（循环），而你可以绕着这个环走任意多次 [@problem_id:1370413]。对于 $\{a^n b^n\}$，如果你泵送一部分 'a'，你就会改变 'a' 的数量而不改变 'b' 的数量，从而破坏了相等关系。因此该语言不可能是正则的。类似地，需要更复杂计数的语言，如 $\{a^{n^2}\}$ 或 $\{a^p \mid p \text{ is prime}\}$，也不是正则的 [@problem_id:1370413] [@problem_id:1444079]。[有限自动机](@article_id:321001)的有限心智根本不够强大。

#### 第二级：上下文无关语言与递归的力量

要攀登到下一级并识别像 $\{a^n b^n\}$ 这样的语言，我们需要给我们的机器更好的内存。我们增加一个**栈**——一种只能在顶部添加或移除项目的内存结构，就像一叠盘子。这种新机器是**[下推自动机](@article_id:338286)（PDA）**。为了识别 $\{a^n b^n\}$，PDA 每读取一个 'a' 就可以向栈中推入一个标记。然后，每读取一个 'b'，它就弹出一个标记。如果栈在字符串结束的那一刻恰好为空，那么计数就匹配了。栈提供了无限的内存，但访问仅限于顶部。

描述这些**上下文无关语言（CFL）**更直观的方式是使用**上下文无关文法（CFG）**。CFG 是一套递归的替换规则。对于 $\{a^n b^n\}$，文法非常简单：$S \to aSb \mid \epsilon$。这个规则说：“这个语言中的一个字符串可以通过取语言中的另一个字符串（$S$），并在其左边包裹一个 'a'、右边包裹一个 'b' 来形成。”或者，它也可以就是空字符串。通过递归地应用这个规则，你可以生成语言中的所有字符串：
$S \to \epsilon$
$S \to aSb \to a(\epsilon)b = ab$
$S \to aSb \to a(aSb)b \to a(a(\epsilon)b)b = aabb$
... 依此类推。

这种递归的、自引用的结构异常强大。它构成了大多数编程语言语法的基础，并在语言学中用于模拟自然语言句子的结构。例如，一个要求零的数量必须是一的两倍的语言，可以通过一套巧妙的递归规则来定义，以确保无论字符串如何构建，这种平衡始终得以维持 [@problem_id:1360008]。

即使在这一级，也存在一些微妙之处。一些上下文无关语言是“确定性的”，意味着一个PDA总能明确地决定下一步该怎么走。而另一些则是内在地“非确定性的”。一个经典结果指出，如果一个语言可以被一个确定性PDA识别，那么它必然是一个**无[歧义](@article_id:340434)**的语言 [@problem_id:1385991]。[歧义](@article_id:340434)性意味着一个字符串可以由文法以多种基本方式生成（即它有多个“[解析树](@article_id:336607)”），这对于需要知道一行代码唯一确切含义的编译器和解释器来说可能是灾难性的。机器属性（确定性）和文法属性（无[歧义](@article_id:340434)性）之间的这种联系，是贯穿该领域的深刻、统一原则的完美范例。

### 我们永远无法触及的地平线：语言的[不可数无限](@article_id:307562)

我们已经从[正则语言](@article_id:331534)攀登到上下文无关语言。我们可以继续前进，为我们的机器添加更强大的内存形式（比如赋予它们对内存带的随机访问权限，这就得到了**图灵机**，所有现代计算机的模型）。这在我们的阶梯上创造了更高的层级。但这里有一个最终的、令人费解的问题：这个阶梯会永远延伸下去吗？我们最终能为*每一种可能的语言*构建一台机器或一个文法吗？

答案令人震惊：不能。

让我们做一个思想实验，这是对 [Georg Cantor](@article_id:306419) 著名的**对角线论证**的一个变体。首先，要认识到在一个字母表如 $\{a, b\}$ 上所有可能字符串的集合是**可数无限**的。我们可以按确定的顺序将它们全部列出：$\epsilon, a, b, aa, ab, ba, bb, \dots$。我们称这个序列为 $s_1, s_2, s_3, \dots$。

现在，让我们尝试列出这个字母表上*所有可能的语言*。一个语言只是一个字符串的集合。为了论证，我们假设我们*可以*创建一个包含所有语言的、完整的、无限的列表：$L_1, L_2, L_3, \dots$。

我们可以将这个假设的列表表示为一个无限的网格。列由字符串 $s_1, s_2, s_3, \dots$ 标记，行由语言 $L_1, L_2, L_3, \dots$ 标记。如果字符串 $s_j$ 在语言 $L_i$ 中，我们就在单元格 $(i, j)$ 中放入 '1'，否则放入 '0'。

现在，我们要构造一个新的“对角线”语言，称之为 $L_D$，它将揭示我们那个“可以列出所有语言”的假设中的致命缺陷。构建 $L_D$ 的规则如下：对于每个字符串 $s_i$，我们将 $s_i$ 包含在 $L_D$ 中，当且仅当 $s_i$ *不*在语言 $L_i$ 中 [@problem_id:2289602]。我们观察无限网格的对角线——单元格 $(1,1), (2,2), (3,3)$ 等等——然后我们翻转其值。如果 $(L_i, s_i)$ 的条目是 '1'，我们确保 $s_i$ *不*在 $L_D$ 中。如果条目是 '0'，我们确保 $s_i$ *在* $L_D$ 中。

现在问问自己：这个新语言 $L_D$ 在我们那个据称完整的列表中的什么位置？它会是 $L_1$ 吗？不会，因为根据构造，$L_D$ 与 $L_1$ 在处理字符串 $s_1$ 上是不同的。它会是 $L_2$ 吗？不会，它在字符串 $s_2$ 的问题上与 $L_2$ 不同。总的来说，对于我们列表中的任何语言 $L_k$，$L_D$ 都保证与之不同，因为它们在字符串 $s_k$ 的归属问题上存在[分歧](@article_id:372077)。

这意味着 $L_D$ 是一个完全有效的语言，但它不在、也不可能在我们那个“完整”的列表中。我们最初的假设——我们可以列出所有可能的语言——必定是错误的。所有语言的集合是**[不可数无限](@article_id:307562)**的。

可能的计算机程序、文法或机器的数量，就像字符串一样，只是可数无限的。这导出了一个惊人的结论：存在的语言（即计算问题）数量，远远超过了能解决它们的程序的数量。在非常真实的数学意义上，大多数问题都是不可解的。它们的模式是如此复杂、如此任意，以至于没有任何有限的规则集、任何我们可能构建的机器，能够描述或识别它们。它们存在于计算阶梯之外，在一个我们能瞥见但永远无法触及的地平线上。