## 引言
我们如何能确定一台计算机，无论它是在遥远的数据中心，还是就放在我们自己的桌上，运行的正是它应该运行的软件？在充斥着复杂恶意软件和供应链攻击的时代，一个系统可能被悄无声息地攻破，变成一个不可信的代理。这种可验证信任的缺失是计算机安全中的一个根本问题。远程证明作为一种强大的解决方案应运而生，它提供了一种方法，让机器能向持怀疑态度的观察者提供其完整性的、可验证的[密码学](@entry_id:139166)证明。本文将深入探讨这项关键技术，解释其内部工作原理及其深远影响。

旅程始于第一章**原理与机制**，该章节解构了其核心密码学要素：用于保证完整性的[密码学](@entry_id:139166)哈希、用于保证真实性的硬件[可信平台模块 (TPM)](@entry_id:756205) 以及用于保证新鲜度的随机数 (nonce)。您将学习这些元素如何在“可信[度量启动](@entry_id:751820)”过程中结合，从头开始构建一条“[信任链](@entry_id:747264)”，并理解报告完整性与强制执行完整性之间的关键区别。第二章**应用与跨学科联系**探讨了该技术的应用领域。它阐明了远程证明如何保护现代云基础设施，如何在运行中的系统中实现动态信任，甚至如何与[分布式系统](@entry_id:268208)中的高级概念[交叉](@entry_id:147634)，最终构成现代数字信任的基石。

## 原理与机制

你如何能信任一台计算机？这不是一个哲学问题，而是一个非常实际的问题。当你连接到你的银行时，银行的服务器如何知道它正在与你的计算机而不是冒名顶替者对话？而*你*又如何知道你自己的计算机没有被悄悄地破坏，被某些恶意软件监视着你的一举一动？这台机器可能看起来一样，感觉也一样，但它的灵魂——它的软件——可能是一个奸诈的冒牌货。

为了解开这个谜题，我们需要一种方法，让计算机能够提供一份关于其自身的可信报告。这不仅仅是一个声明，而是一份如此可靠的证据，以至于一个持怀疑态度的外部观察者都可以对其进行验证。这个过程被称为**远程证明**，它建立在一些极其简单却又强大的[密码学](@entry_id:139166)思想之上。这是一段从完全不确定到可验证信任的旅程。

### 信任的秘诀：三大核心要素

想象一下，你需要验证一位在外勤的秘密特工发来的消息。要信任这条消息，你需要确定三件事：消息内容与特工所写的完全一致（完整性），消息确实来自你的特工而不是双面间谍（真实性），以及这是一条新消息，而不是敌人重放的旧消息（新鲜度）。远程证明的工作原理与此完全相同。

#### 要素一：不可伪造的指纹（完整性）

首先，我们需要一种方法来概括一段软件。你可以发送整个程序，但这太笨拙了。我们需要的是一个唯一的标识符，一个数字指纹。这就是**[密码学哈希函数](@entry_id:274006)**的工作，我们称之为 $H(\cdot)$。哈希函数接收任何数据——从单个字母到整个[操作系统](@entry_id:752937)——并将其压缩成一个短的、固定长度的数字字符串，称为**摘要**。

但这是一种非常特殊的压缩。一个好的[哈希函数](@entry_id:636237)具有一个近乎魔术的特性：如果你改变输入数据中的哪怕一个比特，输出的摘要也会完全且不可预测地改变。从计算上来说，不可能找到两个不同的程序产生相同的哈希值（这被称为**[抗碰撞性](@entry_id:637794)**）。这意味着哈希值是软件不可伪造的指纹。如果你有一个干净程序的受信任哈希值，你就可以近乎确定地判断你收到的版本是否被篡改过。

#### 要素二：秘密握手（真实性）

所以，一台计算机可以计算其自身软件的哈希值并发送给你。但你如何知道攻击者没有截获通信并发送一个伪造的“一切正常”的哈希值呢？这个指纹本身需要被放入一个防篡改的信封中，由一个可信的来源签名。

这时，一个特殊的硬件就派上用场了：**[可信平台模块 (TPM)](@entry_id:756205)**。你可以把 TPM 想象成一个住在你电脑主板上的、微小、多疑且极其可靠的保安。它有自己的内存和处理器，最重要的是，它持有绝不会向主[操作系统](@entry_id:752937)透露的密钥，无论[操作系统](@entry_id:752937)如何花言巧语地请求。

当系统想要证明其状态时，它会将其软件指纹（哈希值）列表发送给 [TPM](@entry_id:170576)。然后，TPM 使用只有它自己知道的密钥，对这些度量值创建一个[数字签名](@entry_id:269311)。在一个简单的模型中，这可以是一个**密钥哈希消息认证码 (HMAC)**，它将消息与密钥结合起来，生成一个只有知道该密钥的人才能创建的标签 [@problem_id:3631438]。一个预先获得相应公钥的验证者可以检查这个签名。由于只有那台特定设备上的唯一 TPM 才能产生该签名，验证者就知道这份报告是真实的。握手完成。

#### 要素三：“你在线吗？”挑战（新鲜度）

还剩下最后一个问题。攻击者可以在计算机健康时记录一份有效的、已签名的报告。然后，在感染机器后，他们可以简单地向验证者重放这份旧报告，而验证者将一无所知。

为了挫败这种攻击，验证者通过一个挑战来启动证明过程。它生成一个大的随机数，称为 **nonce**（意为“仅使用一次的数字”），并将其发送给设备。设备的 [TPM](@entry_id:170576) 必须将这个确切的 nonce 包含在它所签名的数据中 [@problem_id:3631438]。当验证者收到报告后，它会检查两件事：签名是否有效，以及报告中的 nonce 是否与它刚刚发送的相匹配。如果匹配，验证者就知道这份报告是新鲜的，并且是为响应其查询而直接生成的。攻击者的重放攻击被挫败了。

### 构建[信任链](@entry_id:747264)：从基石到云端

计算机不是一个单一的程序；它是一个复杂的生态系统，由固件、[引导加载程序](@entry_id:746922)、内核和应用程序一个接一个地加载而成。一次性度量所有东西会很混乱。相反，我们以增量的方式，一环扣一环地建立信任，这被称为**[信任链](@entry_id:747264)**。

这个过程被称为**可信[度量启动](@entry_id:751820)**。它始于一个因其本质而受信任的组件：计算机不可变**[只读存储器](@entry_id:175074) (ROM)** 中的一小段代码。这就是**硬件[信任根](@entry_id:754420)**。当你打开机器电源时，这段代码是第一个运行的。在执行任何其他操作之前，它会进行一次度量——计算启动序列中下一个软件（比如主固件）的哈希值。它将这个度量值记录在 TPM 中，然后才交出控制权。

然后固件被唤醒，度量*下一个*阶段（可能是[引导加载程序](@entry_id:746922)），将该度量值记录在 TPM 中，然后交出控制权。[引导加载程序](@entry_id:746922)度量操作系统内核，记录它，以此类推。链中的每个环节都负责在允许下一个环节运行之前对其进行度量 [@problem_id:3687920]。

但这些度量值是如何被记录的呢？这就涉及到 TPM 的另一个巧妙特性：它的**平台配置寄存器 (PCRs)**。PCR 不是一个可以随便写入数值的普通寄存器。你能执行的唯一操作是“扩展”。如果一个 PCR 持有值 $p_{\text{old}}$，一个新的度量值 $m$ 到来，新值将变为 $p_{\text{new}} \leftarrow H(p_{\text{old}} \Vert m)$，其中 $\Vert$ 表示[串联](@entry_id:141009)。

把它想象成混合油漆。你从一罐白漆（初始 PCR 状态）开始。启动的第一个阶段“混入”一滴红漆（它的度量值）。得到的颜色是浅粉色。下一个阶段混入一滴蓝漆。颜色变成了淡紫色。罐子里的最终颜色不仅取决于你添加了什么颜色，还取决于你添加它们的*确切顺序*。你无法将油漆分离以回到先前的颜色，如果有人偷偷加入一滴黑漆（恶意代码），最终的颜色将完全不同。这个扩展操作确保了最终的 PCR 值是整个、有序的启动事件序列的密码学摘要 [@problem_id:3645410]。

### 报告与强制执行：安全硬币的两面

至关重要的是要理解，可信[度量启动](@entry_id:751820)从根本上说是一种*报告*机制，而不是一种*强制执行*机制。这将其与它的近亲**[安全启动](@entry_id:754616)**区分开来。

**[安全启动](@entry_id:754616)**就像俱乐部里的保镖。它在每段代码运行前检查其[数字签名](@entry_id:269311)。如果签名与授权签名者列表不符，代码就会被阻止——它不在名单上，就不能进来。它*强制执行*一项策略。

另一方面，**可信[度量启动](@entry_id:751820)**就像门口一位一丝不苟的公证员。它不阻止任何人进入。它只是按顺序记下每个进入者的名字并拍张照片（哈希值）。它*报告*发生了什么。

为什么你会想要一个公证员而不是保镖呢？考虑这个场景：攻击者巧妙地修改的不是内核代码本身，而是一个告诉内核禁用某个关键安全功能的配置文件。[安全启动](@entry_id:754616)可能会放行，因为配置文件不是它需要检查签名的可执行文件。保镖耸耸肩；那不是他的工作。但是可信[度量启动](@entry_id:751820)过程，如果这样配置的话，会度量这个配置文件。公证员拍了张照片。最终的 PCR 值将与预期的“良好”值不同。远程验证者将立即发现偏差，即使[安全启动](@entry_id:754616)允许系统启动 [@problem_id:3679609]。这两种机制是互补的，提供了深度防御。

### 我们视野的局限：证明看不到什么

尽管远程证明功能强大，但它并非全视之眼。它的视野有边界，理解这些边界与理解它的优势同样重要。

首先，是**[时间问题](@entry_id:202825)**。可信[度量启动](@entry_id:751820)过程为你提供了系统状态在*加载时*的高保真快照。它本身并不保证之后会发生什么。恶意软件可能利用软件漏洞，在启动时度量完成后，将自身注入内核内存。PCR 值不会改变，基本的证明仍会报告一个健康的状态 [@problem_id:3673334]。[证明系统](@entry_id:156272)的运行时完整性是一个更难的问题，需要持续的监控。

其次，是**动态代码问题**。现代系统不是静态的；它们随时加载代码，比如库或浏览器扩展。这些新代码会逃脱度量吗？不一定。如果[操作系统](@entry_id:752937)的*加载器*——负责引入新代码的组件——本身是受信任、被度量的链条的一部分，那么就可以信任它来继续这个过程。它在将新库映射到内存之前对其进行度量，从而动态地扩展[信任链](@entry_id:747264)。信任图随着系统的运行而增长 [@problem_id:3679583]。

最后，也是最根本的，是**权限问题**。证明依赖于执行度量的代理的完整性。如果恶意软件感染了一个比试图执行度量的组件权限更高的组件怎么办？例如，某些固件组件，如在**系统管理模式 (SMM)** 中运行的那些，在一个比操作系统内核本身更强大的阴影领域中操作。[操作系统](@entry_id:752937)无法检查 SMM 使用的内存 (SMRAM)，因此 SMM rootkit 对[操作系统](@entry_id:752937)级别的证明来说是完全不可见的。更糟糕的是，如果[信任链](@entry_id:747264)的第一个环节——度量[引导加载程序](@entry_id:746922)的固件——被攻破，它完全可以撒谎。它可以在加载恶意组件的同时，向 TPM 展示一个“良好”的哈希值。整个[信任链](@entry_id:747264)就此崩溃 [@problem_id:3673354] [@problem_id:3687920]。报告的可信度取决于报告者的可信度。

### 扩展信任：从启动时到构建时

这把我们带到了一个引人入胜的前沿领域。即使一个系统的启动过程被完美地度量和证明，我们如何知道软件不是“生而为恶”的？想象一个供应链攻击，对手在软件供应商的办公室里攻破了编译器。这个恶意的编译器在它构建的内核中注入了一个后门。供应商在不知情的情况下，用他们的官方密钥签署了这个带后门的内核。

当这个内核被部署时，[安全启动](@entry_id:754616)会很乐意地批准它——签名是有效的！可信[度量启动](@entry_id:751820)会忠实地记录其哈希值，而远程证明会确认这个哈希值与供应商的官方（但已受损的）清单相符。两种机制都失败了。

解决方案是将[信任链](@entry_id:747264)*向后延伸*，从启动过程一直延伸到开发流水线。这涉及到一些新思想，比如**可复现构建**，即多个独立的方编译相同的源代码，以确保他们都得到比特级完全相同的二进制文件。它还涉及到创建可验证的**来源证明**（如软件物料清单，或 SBOM），它作为软件签了名的、密码学的出生证明，详细说明了创建它所使用的确切工具和源文件。然后，验证者不仅可以要求证明正在运行的是什么，还可以要求证明它是如何被构建的，从而堵上了信任模型中的一个重大漏洞 [@problem_id:3679558]。

### 一个没有网络的世界：自我证明

最后，如果没有“远程”验证者，这一切还有用吗？比如在一架飞机上的一台笔记本电脑？答案是肯定的。TPM 提供了一种非凡的能力，称为**密封**。你可以给 [TPM](@entry_id:170576) 一个秘密——例如，你加密硬盘的密钥——并告诉它将此秘密“密封”到一组特定的 PCR 值上。

[TPM](@entry_id:170576) 只有在其寄存器中的当前 PCR 值与它被密封时的值完全匹配时，才会“解封”并释放该秘密。这意味着笔记本电脑可以向*它自己*证明。如果一个 bootkit 或 rootkit 感染了机器，启动度量值会改变，最终的 PCR 值会不同，TPM 就会拒绝释放磁盘密钥。[操作系统](@entry_id:752937)将无法挂载驱动器，你的数据将保持加密和安全。这是一种强大的自我保护形式，一个由同样的可信度量原则所赋能的数字免疫系统 [@problem_id:3679556] [@problem_id:3679563]。

