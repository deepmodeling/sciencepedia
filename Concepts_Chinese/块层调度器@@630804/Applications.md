## 应用与跨学科联系

既然我们已经窥见了块层调度器内部精美的运作机制，这一由队列和算法构成的交响乐，我们可能会想把它放回盒子里，满足于我们对其机理的理解。但这样做就完全错过了重点。科学的真正魔力不仅在于理解事物*如何*运作，更在于看到它们*让我们能做什么*。在广阔而纷繁的计算世界里，这个数据高速公路上不起眼的“交警”能帮助我们解决哪些难题呢？

事实证明，相当多。调度器是一个关键环节，是解决各种问题的关键部分，这些问题从旋转磁盘的纯粹物理学，到云中资源共享的微妙政治，甚至到[实时系统](@entry_id:754137)的生死攸关的时机。让我们踏上这段应用的旅程，看看调度的抽象原则如何体现为切实的解决方案。

### 驯服机械巨兽

早在我们的存储器变成无声的固态芯片之前，那是一个由旋转盘片和飞驰磁头组成的世界。在这个机械世界里，物理学是王道，而最大的暴君是距离。磁盘磁头从一个磁道*寻道*到另一个磁道所花费的时间，在计算机时间里是永恒的，通常主导了 I/O 操作的总时间。

想象一个常见的场景：一个数据库正在忙于处理事务，这涉及分散在磁盘各处的小规模、随机的读写。与此同时，一个备份进程启动，想要写入一个巨大的、顺序的归档文件。没有智能调度器，结果就是一片混乱。磁盘磁头在盘片上疯狂地来回摆动，从数据库的一个随机点移动到备份的一个顺序点，然后又返回。两个任务都慢如蜗牛，彼此都成为对方干扰的受害者。

在这里，调度器与[文件系统](@entry_id:749324)协同工作，可以施展一个非常优雅的技巧。关键的洞见是，虽然备份数据可以存放在任何地方，但频繁访问的数据库数据若能紧密地放在一起，将大为受益。如果文件系统将所有“热”的数据库文件分配到磁盘上一个小的、连续的柱面带上，问题就完全改变了。现在，对于随机的数据库 I/O，最大寻道距离变得非常小。这种技术，通常被称为“短行程”(short-stroking)，极大地减少了平均[寻道时间](@entry_id:754621)。然后，调度器可以通过分批工作来放大这一好处：它可以分配一个时间片来服务来自数据库紧凑区域的一连串请求，然后切换到服务其自身独立区域中的备份。在区域之间进行一次长寻道的成本每个时间片只支付一次，这对于随机 I/O 区域内巨大的性能增益来说是微小的代价。[@problem_id:3636056] 这是软件（调度器和分配器）驯服硬件物理学的一个绝佳范例。

### 多租户世界中的公平与和平

机械巨兽已在很大程度上被无声且速度极快的[固态硬盘](@entry_id:755039) (SSD) 所取代。虽然[寻道时间](@entry_id:754621)不再是主要问题，但干扰的问题依然存在，并且在现代的云计算和容器化世界中，它呈现出一个新的维度：公平性。当多个用户、[虚拟机](@entry_id:756518)或容器共享一个物理驱动器时，谁可以使用它？我们如何防止一个“吵闹的邻居”独占资源并饿死其他所有人？

这时，调度器扮演了裁判的角色。想象两个容器 $\mathcal{C}_A$ 和 $\mathcal{C}_B$ 共享一个驱动器。我们可能决定 $\mathcal{C}_A$ 的重要性是 $\mathcal{C}_B$ 的两倍。我们可以通过为它们分配 I/O 权重来表达这一点——比如，$w_A = 2$ 和 $w_B = 1$。调度器并不会神奇地给 $\mathcal{C}_A$ 一个更快的磁盘片。相反，它执行一个简单的规则：在任何给定的时间段内，它每从 $\mathcal{C}_B$ 分派一个请求，就会从 $\mathcal{C}_A$ 分派两个请求。这种策略，一种加权公平队列的形式，确保了两个容器都能取得进展，并且它们对设备性能的份额与其配置的权重成正比。[@problem_id:3648686]

这个原则不仅仅是一个粗略的近似；它有坚实的数学基础。通过使用排队论对系统建模，我们可以预测一个容器的平均 I/O 延迟将是其保证份额的直接函数。更大的权重意味着更大的有效服务速率，从而在负载下带来更低且更可预测的延迟。[@problem_id:3648722] 调度器将一个混乱的“自由竞争”转变为一个可预测、可管理的系统。

然而，简单的带宽共享并不总是足够的。考虑一个数据库容器（$\mathcal{C}_1$）发出许多小的、紧急的 `[fsync](@entry_id:749614)` 操作，这些操作强制将数据持久化写入。与此同时，一个日志容器（$\mathcal{C}_2$）正在执行大的、非紧急的后台写入。来自 $\mathcal{C}_1$ 的 `[fsync](@entry_id:749614)` 操作可能会被卡在来自 $\mathcal{C}_2$ 的大写入请求之后的队列中，导致数据库的延迟变得非常糟糕。一个更高级的调度器，如预算公平队列 (BFQ)，可以通过不仅计算请求数量，还预算分派的总数据量来解决这个问题。它可以防止日志容器的大写入在设备队列中造成“交通堵塞”，确保数据库的小而紧急的请求能够顺利通过。[@problem_id:3665388] 这时调度器不仅是裁判，更是一个精密的交通管理者，在数据高速公路上创建出快车道和慢车道。

### 紧急事务的专制

有时，公平恰恰是错误的目标。有时，一个 I/O 请求就是比所有其他请求都重要——重要到必须*立即*得到服务，即使以延迟其他所有事情为代价。

没有比[操作系统](@entry_id:752937)为自身生存而发出的请求更紧急的了。当系统处于极端内存压力下时，它必须将内存页面移动到磁盘上的“交换”空间，以释放 RAM 供活动进程使用。这种交换 I/O 事关生死。如果它被延迟，整个系统都可能陷入[停顿](@entry_id:186882)。因此，调度器以最高优先级处理交换 I/O。一个读或写交换设备的请求会跳到队列的最前端，绕过正常的[文件系统](@entry_id:749324)路径，直接发送到块层进行立即分派。[@problem_id:3648663] 所有其他“常规” I/O 都必须等待。这是一种刻意且必要的对公平性的违背。当然，这种权力也伴随着风险：如果系统持续不断地进行交换，高优先级的交换流量可能会完全占用磁盘，导致常规应用程序根本无法获得任何 I/O 服务。[@problem_id:3648663]

这种优先级的概念可以扩展到应用程序。我们可以设计这样的系统，让应用程序可以向[操作系统](@entry_id:752937)“暗示”某个文件对延迟敏感。例如，数据库的事务日志远比一个正在被扫描进行分析的大数据文件对延迟更为关键。通过将这个暗示存储在文件的元数据（其 [inode](@entry_id:750667)）中，该信息会随文件一同传递。I/O 调度器随后可以读取这个暗示，并将该文件的请求放入高优先级队列，确保数据库提交快速完成，而分析扫描则在后台进行。[@problem_id:3643175]

优先级的终极体现是在硬实时系统中——在航空电子设备、工业机器人或医疗设备中，错失一个截止时间不是不便，而是灾难性的失败。在这里，调度器的角色从优化转变为认证。为了保证一个 I/O 操作将在其截止时间前完成，我们必须能够计算出其最坏情况[响应时间](@entry_id:271485)。这需要为 I/O 处理路径的*每一个阶段*设置一个可证明的延迟上限：系统调用、调度器队列、驱动程序、设备服务时间、[中断处理](@entry_id:750775)以及完成处理。块调度器的排队延迟成为决定整个系统安全性和正确性的关键方程中的一项。[@problem_id:3648624] 这是[操作系统](@entry_id:752937)块层与实时系统工程学科之间深刻的联系。

### 机器中的幽灵：解开复杂的相互作用

在现代计算机中，没有任何东西是孤立存在的。I/O 调度器常常处于处理那些根源完全在系统其他部分的奇异和反直觉问题的第一线。

考虑一个容器化服务，它正经历着糟糕的[尾延迟](@entry_id:755801)——它的平均响应时间很好，但偶尔会有请求耗时极长，让用户感到沮丧。罪魁祸首可能根本不是 I/O 系统。想象一个攻击者容器，它被分配的 CPU 时间很少。因为它运行得不频繁，当它有机会运行时，它会一次性发出大量长时间运行的 I/O 请求。这个爆发在设备上造成了 I/O “护航队”，而我们受害者服务的任何短小、对延迟敏感的请求如果恰好在这个爆发期间到达，就会被卡在队列的末尾。[@problem_id:3628601] 问题源于 CPU 调度器，但表现为 I/O 延迟危机。一个复杂的 I/O 调度器可以检测到这一点，注意到受害者的延迟正在飙升，并可以通过限制攻击者的 I/O 来打破“护航队”并保护受害者的[尾延迟](@entry_id:755801)。

当“设备”不再是本地硬件，而是网络另一端的存储服务器时，复杂性会进一步增加。当使用像 iSCSI 或 NBD 这样的协议时，I/O 路径延伸到了 TCP/IP 网络之上。调度器现在必须应对一个完全不同学科的怪癖：计算机网络。[@problem_id:3648683] 如果许多 I/O 请求在一个单一的 TCP 连接上复用，一个丢失的数据包就可能在 TCP 的可靠性机制努力恢复时阻塞整个[数据流](@entry_id:748201)。这造成了队头阻塞效应，即一个请求的延迟可能会阻塞其后的所有其他请求，即使它们自己的数据已经安全到达。这是一种在具有多个独立硬件队列的本地 NVMe 驱动器上根本不存在的故障模式。调度器的世界，以及它必须应对的延迟来源，已经扩展到了机箱之外。

### 智能协处理器：未来的惊鸿一瞥

这把我们带到了前沿。随着存储设备本身变得越来越复杂，块 I/O 调度器的角色正在经历深刻的转变。它正从一个仅仅重新排序请求的角色，演变为一个智能协处理器，深刻理解其所管理设备的物理特性和内部架构。

考虑一个现代 SSD。它不是一块均匀的内存。它可能包含不同类型的闪存单元，具有截然不同的特性：超快但密度低的单层单元 (SLC) 闪存、中等速度和密度的三层单元 (TLC)，以及速度较慢但密度非常高的四层单元 (QLC)。每种都有不同的编程时间和写入耐久度。一个掌握了这些知识的[操作系统调度](@entry_id:753016)器可以做出战略性决策。给定一组具有不同截止时间的写请求，它可以解决一个复杂的[优化问题](@entry_id:266749)：它可以将最紧急的请求分派到快速的 SLC 缓存，同时将不那么关键的数据路由到较慢但容量更大的 TLC 或 QLC 层，同时还要在 SLC 写入的预算内操作以管理驱动器的磨损。[@problem_id:3683898]

这不再仅仅是调度；这是主动的、智能的资源管理。调度器已经成为硬件的真正伙伴，将高级的应用程序策略（如截止时间）转化为低级的物理放置决策。正是这种持续的演变，这种软件策略与硬件现实之间的舞蹈，使得块层及其调度器成为现代[操作系统](@entry_id:752937)中最持久迷人且至关重要的组件之一。