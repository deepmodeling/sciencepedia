## 引言
算术是所有计算的基础，然而，一台由简单开关组成的机器如何执行这些操作，本身就是一项工程奇迹。本文将揭开数字加法的神秘面纱，探讨将抽象数学转化为具体逻辑电路的核心挑战。我们将从[二进制加法](@entry_id:176789)的基础原理开始，探索如何构建简单的[半加器](@entry_id:176375)和[全加器](@entry_id:178839)。然后，我们将研究更高级的架构，如[行波进位加法器](@entry_id:177994)、[超前进位加法器](@entry_id:178092)和保留进位加法器，理解速度与效率之间的关键权衡。最后，我们将拓宽视野，看看这些基本电路如何被巧妙地应用于执行减法、比较，甚至与人类可读的数字系统进行通信。本次探索始于使数字算术成为可能的基本原理和机制。

## 原理与机制

在每一台计算机的核心，从最简单的计算器到最强大的超级计算机，都存在着一个基本操作：加法。但是，一台由开关集合构成的机器，实际上是如何执行像算术这样看似抽象的任务的呢？答案是一段通往[计算逻辑](@entry_id:136251)的美妙旅程，一个从最基本的概念构建复杂性的故事。让我们开始这段旅程，从零开始构建一个加法器。

### 二[进制](@entry_id:634389)计数艺术：从半加到全加

首先，让我们考虑最简单的加法：两个单个二[进制](@entry_id:634389)数字（即比特）相加。我们称它们为 $A$ 和 $B$。可能的结果有哪些？

- 如果 $A=0$ 且 $B=0$，和为 $0$。
- 如果 $A=0$ 且 $B=1$，和为 $1$。
- 如果 $A=1$ 且 $B=0$，和为 $1$。
- 如果 $A=1$ 且 $B=1$，和是……嗯，十进制下是2，但在二[进制](@entry_id:634389)中是“10”。这意味着结果需要两位：一个值为 $0$ 的“和”位和一个值为 $1$ 的“进位”位。

这个简单的任务由我们称为**[半加器](@entry_id:176375)**的电路执行。它接收两个输入 $A$ 和 $B$，并产生两个输出：一个**和**位 $S$ 和一个**进位输出**位 $C_{out}$。其逻辑非常直接。仅当输入不同时，和位才为 $1$，这正是异或（XOR）运算的定义。仅当两个输入都为 $1$ 时，进位输出位才为 $1$，这正是与（AND）运算。

$$S = A \oplus B$$
$$C_{out} = A \land B$$

这是一个不错的开始，但这还不够。当我们手算多位数加法时，我们先将第一列的数字相加，写下和，然后向下一列进位。关键在于，对于后续的每一列，我们相加的不是两个数字，而是*三个*：数字本身的两位，加上前一列的进位。

[半加器](@entry_id:176375)无法完成此任务，因为它只有两个输入。它无法接收来自其右侧列的进位输入（carry-in）([@problem_id:1940510])。我们需要一个功能更强的模块，一个能处理三个输入的模块。这就引出了数字算术的主力：**[全加器](@entry_id:178839)**。

[全加器](@entry_id:178839)接收三个输入——$A$、$B$ 和一个**进位输入** $C_{in}$——并产生同样的两个输出：一个和 $S$ 和一个进位输出 $C_{out}$。为了真正理解[全加器](@entry_id:178839)的作用，我们可以暂时抛开逻辑门，将其看作一个简单的计数机。输入值的总和是算术和 $A + B + C_{in}$。这个和可以是0、1、2或3。我们如何用二[进制](@entry_id:634389)表示这些值？

- 和 = 0：二进制“00”。$S=0$, $C_{out}=0$。
- 和 = 1：二进制“01”。$S=1$, $C_{out}=0$。
- 和 = 2：二进制“10”。$S=0$, $C_{out}=1$。
- 和 = 3：二[进制](@entry_id:634389)“11”。$S=1$, $C_{out}=1$。

注意一个优美的模式正在显现。两位输出 $(C_{out}, S)$ 的值就是 $2 \times C_{out} + 1 \times S$。这给了我们[全加器](@entry_id:178839)的基本算术恒等式：

$$A + B + C_{in} = 2C_{out} + S$$

这个方程正是[全加器](@entry_id:178839)之所以为[全加器](@entry_id:178839)的*定义*。任何电路，若在任何输入下不满足此恒等式，根据定义，就是一个损坏的加法器 ([@problem_id:1938841])。满足此恒等式的逻辑表达式为：

$$S = A \oplus B \oplus C_{in}$$
$$C_{out} = (A \land B) \lor (A \land C_{in}) \lor (B \land C_{in})$$

和位就是所有三个输入的[异或](@entry_id:172120)——它告诉你‘1’的总数是奇数还是偶数。进位输出代表了“多数票”：如果至少有两个输入为1，它就为1。有了这个强大的构建模块，我们现在可以对任意大小的数进行相加了 ([@problem_id:3688815])。

### 进位的缓慢传递：[行波进位加法器](@entry_id:177994)

我们如何将两个32位的数相加？最直观的方法是模仿我们在纸上的做法，将我们的[全加器](@entry_id:178839)[串联](@entry_id:141009)起来。我们对第一位使用一个[半加器](@entry_id:176375)（因为没有初始进位输入），然后对剩下的31位各使用一个[全加器](@entry_id:178839)。第0位的进位输出成为第1位的进位输入，第1位的进位输出成为第2位的进位输入，以此类推。

这个优雅的链式结构被称为**[行波进位加法器](@entry_id:177994)（RCA）**。它的简洁性就是它的美。然而，这种简洁性背后隐藏着一个深刻的缺陷：它很慢。

想象一排多米诺骨牌。最终的和位 $S_{31}$ 在知道其进位输入 $C_{31}$ 之前无法计算。但 $C_{31}$ 依赖于第30级的结果，而第30级又依赖于第29级，依此类推，一直回溯到最开始。在最坏的情况下——例如，将1与一个全为1的数相加时——在第一位产生的进位必须“行波式”地穿过整个32位链。每个[全加器](@entry_id:178839)只有在其前一个完成后才能完成自己的计算。这种顺序依赖性产生了一条延迟随比特数[线性增长](@entry_id:157553)的**关键路径**。

对于一个8位加法器，最终的和位 $S_7$ 可能在输入施加后经过许多门延迟才能准备好，因为它必须等待进位信号蜿蜒穿过前面所有的七级。最终的进位输出 $C_8$ 需要的时间甚至更长 ([@problem_id:1958690])。对于一个64位加法器，这种延迟可能变得无法忍受，从而限制了整个处理器的时钟速度。

这说明了工程学中的一个重要权衡。[行波进位加法器](@entry_id:177994)小而简单（它的*面积*小），但速度慢（它的*延迟*高）。在另一个极端，可以设计一个**位串行加法器**，它仅使用一个[全加器](@entry_id:178839)和一个存储元件，一次一位地将任意长度的两个数相加。这种设计非常紧凑，但对于一个N位的加法需要N个[时钟周期](@entry_id:165839)，这在另一种意义上非常慢（*吞吐率*低） ([@problem_id:3628138])。因此，挑战在于找到一种既快速又高效的方法。

### 展望未来：[超前进位加法器](@entry_id:178092)

为了摆脱行波式传递的缓慢步伐，我们需要天才的火花。与其等待进位到达，不如我们能够*预测*它？如果每一级都能查看自己的输入 $A_i$ 和 $B_i$，并在不等待其进位输入的情况下确定其进位输出的命运，会怎么样？这就是**[超前进位加法器](@entry_id:178092)（CLA）**背后的革命性思想。

其洞见在于分解产生进位输出的条件。对于任意给定的一级 $i$，进位输出（$C_{i+1}$）可以通过两种方式发生：

1.  该级*自身*可以产生一个进位。如果它的两个输入 $A_i$ 和 $B_i$ 都为1，就会发生这种情况。此时，无论进位输入是什么，它都会**产生**一个进位。我们称这个信号为 $G_i = A_i \land B_i$。

2.  该级可以将前一级的进位传递下去。如果该级接收到一个进位输入（$C_i=1$）并且处于允许其通过的状态，就会发生这种情况。当其输入 $A_i$ 或 $B_i$ 中恰好有一个为1时，就会出现这种“传递”状态。此时，它将**传播**输入的进位。我们称这个信号为 $P_i = A_i \oplus B_i$。

现在，我们可以用一个简单而强大的方程来表示任何一级的进位输出：

$$C_{i+1} = G_i \lor (P_i \land C_i)$$

这表示，如果第 $i$ 级产生一个进位，或者它传播一个输入的进位，那么第 $i$ 级的进位输出就为1。虽然这看起来仍然是递归的，但其魔力在于我们展开它时会发生什么。让我们看看前几个进位，假设初始进位输入为 $C_0$：

$C_1 = G_0 \lor (P_0 \land C_0)$
$C_2 = G_1 \lor (P_1 \land C_1) = G_1 \lor (P_1 \land (G_0 \lor (P_0 \land C_0))) = G_1 \lor (P_1 \land G_0) \lor (P_1 \land P_0 \land C_0)$

仔细看 $C_2$ 的表达式。它只依赖于第0级和第1级的P和G信号，以及初始进位 $C_0$。它*不再*依赖于 $C_1$ 了！我们已经“向前看了”。我们可以对每个进位都这样做。所有的P和G信号可以同时为所有32位计算出来，只需一个门延迟，因为它们只依赖于主输入 $A$ 和 $B$。然后，一个称为**超前逻辑**的专门高速电路可以从这些P和G信号并行计算出所有32个进位。长长的多米诺骨牌链被一个系统所取代，其中每一级的进位都是直接从一个全局信息池中计算出来的。

一旦这个快速进位网络传递了所有的 $C_i$ 信号，最终的和位就可以在整个加法器上即时并并行地计算出来，使用的就是我们已经知道的简单关系：$S_i = P_i \oplus C_i$ ([@problem_id:1918447])。[行波](@entry_id:185008)传递的束缚被打破了。我们获得了速度。（值得注意的是，自然是巧妙的，存在一些略有不同但等效的方式来定义这些信号，例如使用 $P_i = A_i \lor B_i$，这也会得到同样辉煌的结果 [@problem_id:1918179]）。

### 另一种并行性：保留进位加法器

CLA是快速相加两个数的绝佳解决方案。但是，如果要同时相加*三个*或更多的数呢？这在乘法器中是常见的任务。我们可以使用一系列CLA，但还有一种更激进、更优雅的方法。这个想法是改变问题。与其在每一步都问“最终的和是多少？”，我们不如简单地问“我如何减少需要相加的东西的数量？”

这就是**保留进位加法器（CSA）**的原理。它的策略是一种高超的拖延术：*尽可能地推迟处理进位*。

想象一下将三个数 $A$、$B$ 和 $C$ 相加。CSA使用一组独立的[全加器](@entry_id:178839)，每个位列一个。对于每一列 $i$，[全加器](@entry_id:178839)接收三个位 $A_i, B_i, C_i$，并产生一个和位 $S_i$ 和一个进位输出位 $C_{out,i}$。这里的关键技巧是：第 $i$ 级的进位输出*不*连接到第 $i+1$ 级的输入。相反，所有的和位（$S_0, S_1, ...$）被收集到一个我们称之为“和向量”的新数中，而所有的进位位（$C_{out,0}, C_{out,1}, ...$）则被收集到一个独立的“进[位向量](@entry_id:746852)”中。

在单个[全加器](@entry_id:178839)的延迟内，完全没有任何行波传播，我们就把相加三个数的问题简化成了相加两个数（和向量和（移位的）进[位向量](@entry_id:746852)）的问题。进位被“保存”在它们自己的向量中，而不是被传播出去。

这项技术非常强大。如果你需要相加，比如说，八个数，你可以使用一个CSA树（通常称为**华莱士树**）将这八个数减少到六个，然后到四个，最后只剩下两个。整个简化过程在极小的、对数级的步骤中完成，每一步只花费单个[全加器](@entry_id:178839)的延迟 ([@problem_id:1977463])。

只有在最后，当我们只剩下最后两个向量时，我们才需要解决进位问题并计算最终答案。而对于这最后一步，我们可以使用我们快速的[超前进位加法器](@entry_id:178092)。这种用于简化的CSA和用于最终求和的CLA的组合是现代处理器中[高速乘法器](@entry_id:175230)的支柱。作为一个美妙的副作用，通过避免长长的、行波式的信号链，这种保留进位的方法还可以显著降低电路的[功耗](@entry_id:264815) ([@problem_id:1918741])。这是一种不仅更快，而且更智能、更高效的设计。

从简单的[半加器](@entry_id:176375)到保留进位和超前逻辑的复杂交织，加法器的故事本身就是计算机工程的一个缩影：在层层优美简洁而强大的思想之上，对速度和效率的不懈追求。

