## 引言
在将人类可读的源[代码转换](@entry_id:747446)为高效机器指令的过程中，编译器使用了一整套庞大的[优化技术](@entry_id:635438)。其中最直观但也最具挑战性的优化之一是消除冗余工作。如果一个程序多次计算相同的值，编译器能否足够智能，只计算一次并重用结果？困难在于确定性。一个错误的优化如果重用了过时的值，可能导致灾难性的错误。编译器需要一种方法来毫无疑问地证明，一个先前计算过的值仍然有效并且可以重用。

这就是**[可用表达式](@entry_id:746600)分析**（Available Expressions Analysis）的领域，它是一种基础性的[数据流](@entry_id:748201)分析技术，为安全优化提供了必要的严格保证。本文将深入探讨这种强大的方法。第一章**“原理与机制”**将探讨其核心理论，解释该分析如何使用 GEN/KILL 集和集合交集等概念来追踪信息在程序中的流动。第二章**“应用与跨学科联系”**将展示该分析如何促成[公共子表达式消除](@entry_id:747511)等关键优化，以及它如何与指针、对象和并发等现代编程挑战相互作用。

## 原理与机制

想象你是一位一丝不苟的面点师，正在遵循一个复杂的食谱。你量出 `1 cup of flour` 和 `1/2 cup of sugar`，将它们混合在一个碗里，然后放在一旁。几个步骤之后，食谱再次要求 `1 cup of flour` 和 `1/2 cup of sugar`。你会重新测量所有东西吗？当然不会。你已经做过这项工作了。你只需拿起之前准备好的那个碗。

这就是一种名为**[公共子表达式消除](@entry_id:747511)（Common Subexpression Elimination, CSE）**的[编译器优化](@entry_id:747548)的精髓。编译器就像一个聪明的面点师，希望避免重复工作。如果它已经计算过一个值，比如 `x + y`，它很乐意直接重用结果，而不是再次计算它。

但这是一种危险的游戏。如果在你第一次和第二次需要干混合料之间，你淘气的助手扔进了一把盐怎么办？你预先混合的碗现在被毁了，或者说被“杀死”了。如果你用了它，你将烤出一个灾难性的咸蛋糕。对于编译器来说，使用一个过时的值会导致程序产生错误答案——一个灾难性的错误。

因此，核心问题是：编译器如何能绝对肯定地知道，一个先前计算的结果仍然有效并且“可用”于重用？这就是一种名为**[可用表达式](@entry_id:746600)分析**的强大技术所做的侦探工作。

### 侦探的金科玉律：超越一切合理怀疑的证明

为了安全地重用一个已计算的表达式，编译器必须是一个一丝不苟的侦探。它不能凭直觉或概率行事。它需要超越一切合理怀疑的证明。在编译器分析的世界里，这被称为**必达分析（must analysis）**。一个表达式只有在**保证**在到达程序中某个点时具有相同的值，无论程序采取哪条执行路径到达那里，才被认为是“可用的”。

把程序的执行路径想象成一个人可以到达会面点的不同路线。如果我们想确保到达会面点的**每个人**都有一个秘密口令，那么这个口令必须在通往该点的**每一条路线上**都已分发。如果哪怕只有一条路线没有提供口令，我们就不能假设到达会面点的人会有口令。

这种“所有路径”的要求在数学上由**集合交集**运算符（$ \cap $）来体现。假设在一个交叉点，有两条路径汇合——一条来自A镇，一条来自B镇。如果来自A镇路径的[可用表达式](@entry_id:746600)集合是 `{"x+y", "a*b"}`，而来自B镇路径的集合是 `{"x+y", "c-d"}`，那么在[交叉点](@entry_id:147634)我们能确定什么是肯定可用的？只有两个集合共有的表达式：`{"x+y"}`。我们取所有进入[路径信息](@entry_id:169683)的交集，因为这是无论走哪条路径都**必定**为真的唯一信息[@problem_id:3642715]。

这种保守的、全路径方法是像 CSE 这样的优化得以安全实施的基石。我们宁愿错过一次优化的机会（成为一个效率较低的面点师），也不愿执行一次不正确的优化（烤一个咸蛋糕）。

### 信息流：GEN 与 KILL 的分类账

为了追踪哪些表达式是可用的，编译器首先创建一张程序的地图，称为**[控制流图](@entry_id:747825)（Control-Flow Graph, CFG）**。在这张地图中，直线代码的基本块是地点，而潜在的跳转和分支是连接它们的道路。然后，该分析通过计算每个代码块如何影响[可用表达式](@entry_id:746600)集合来工作。每个块可以做两件事：

*   **`GEN` (Generate, 生成):** 当一个块执行像 `t := a * b` 这样的语句时，它*生成*了表达式 `a * b`。一条新的信息变得可用。我们可以将 `a * b` 添加到该块出口处的[可用表达式](@entry_id:746600)列表中。

*   **`KILL` (杀死):** 当一个块执行改变变量的语句时，比如 `a := 10`，它可能会使任何使用 `a` 的表达式失效。`a * b` 的旧值不再可信。我们说对 `a` 的赋值*杀死*了表达式 `a * b`。我们必须将它从我们的列表中移除。

这种 `GEN` 和 `KILL` 逻辑构成了一个简单但强大的记账系统。当我们从一个程序点移动到下一个点时，我们使用一个[传递函数](@entry_id:273897)来更新我们的[可用表达式](@entry_id:746600)分类账：

$$
\mathrm{OUT} = \mathrm{GEN} \cup (\mathrm{IN} \setminus \mathrm{KILL})
$$

这个方程非常直观。在一个块的**OUT**put（出口）处可用的表达式集合，是该块新**GEN**erate（生成）的任何内容，加上在其**IN**put（入口）处可用的内容，再减去该块**KILL**s（杀死）的任何内容。

让我们通过一个小例子来追踪这个过程。考虑以下程序图中的表达式 `e = a * b` [@problem_id:3622931]：

1.  **块 $B_1$** 计算 `t1 := a * b`。它*生成* `e`。假设 `e` 现在是可用的。程序然后分支到 $B_2$ 或 $B_3$。
2.  **到 $B_2$ 的路径**：$B_2$ 包含语句 `a := a + 1`。这个赋值*杀死*了 `e`，因为它改变了 `a * b` 的一个操作数。所以，在 $B_2$ 的出口处，`e` 不再可用。
3.  **到 $B_3$ 的路径**：$B_3$ 只是再次计算 `t2 := a * b`。它也*生成*了 `e`，而 `e` 之前已经是可用的。所以在 $B_3$ 的出口处，`e` 仍然可用。
4.  **在 $B_4$ 处合并**：现在，从 $B_2$ 和 $B_3$ 的路径合并进入 $B_4$。为了找出在 $B_4$ 开始时什么是可用的，我们应用我们的金科玉律：我们取从进入路径中可用的信息的交集。
    *   从 $B_2$ 来：`e` 是*不可用*的。
    *   从 $B_3$ 来：`e` 是*可用*的。
    *   `不可用`和`可用`的交集是`不可用`。
5.  **结论**：编译器必须得出结论，`a * b` 在 $B_4$ 的开始处是*不可用*的，因为有一条路径可以到达那里（通过 $B_2$），在该路径上它的值已经失效。该优化是不安全的。

同样的逻辑也适用于子表达式。如果一条路径计算了 `x+y` 和 `(x+y)*z`，但另一条路径只计算了 `x+y`，那么在合并点，只有 `x+y` 会在交集中幸存下来，并被认为是可用的[@problem_id:3622945]。每个表达式都是一个独立的侦探案件。

#### 指针的复杂性

在现实世界的编程中，`KILL` 集可能会变得很棘手。一个简单的赋值如 `x := 5` 显然会杀死任何涉及 `x` 的表达式。但是 `*p := 5` 呢，其中 `p` 是一个指针？这个语句修改 `p` 所指向的任何内存位置。为了安全起见，编译器必须知道 `p` 可能指向的所有可能变量（其**[别名](@entry_id:146322)集**）。

如果一个独立的**别名分析**告诉编译器 `p` *可能指向* `x` 或 `z`，我们保守的侦探别无选择，只能做最坏的打算。语句 `*p := 5` 被视为可能修改 `x` *和* `z`。因此，它会杀死所有包含 `x` 的表达式和所有包含 `z` 的表达式[@problem_id:3622890]。这是一个典型的例子，说明了不同的编译器分析必须如何协作以确保安全。

### 定义分析的边界

为了确保我们的分析是可靠的，我们必须精确地定义它的边界——它从哪里开始，它看什么，以及它被允许看什么。

#### 空白笔记本：一个可靠的起点

我们的分析从哪里开始？在程序的入口点。那里有哪些表达式是可用的？绝对没有。在程序执行任何一条指令之前，没有任何东西被计算过。因此，分析必须从入口块的 `IN` 集为空集 $\emptyset$ 开始[@problem_id:3642670]。以一切都可用的乐观假设开始是不可靠的，并且可能导致灾难，就像在你还没打开烤箱之前就假设蛋糕已经烤好了。

#### 原子语句：分析所见

分析将什么视为一个单一的“步骤”？通常，它在语句或基本块*之间*的边界上操作。它将每个语句视为一个原子的、“黑箱”操作。这意味着，如果你有一个单一的语句如 `t := (x + y) + (x + y)`，分析无法看到该语句*内部*的冗余。它只记录在语句执行*之后*，表达式 `x + y` 现在可用于*后续*语句。为了发现语句内的冗余，编译器首先需要将这个复杂语句分解成更细粒度的表示，比如 `temp := x + y; t := temp + temp;`，从而在这两个计算之间创建一个程序点[@problem_id:3622938]。

#### 安全条款：仅限纯函数

最重要的是，我们到底能追踪什么样的表达式？我们能尝试消除一个向屏幕打印信息的[函数调用](@entry_id:753765)吗，比如 `printf("Hello")`？绝对不能。这个“表达式”就是[函数调用](@entry_id:753765)，它的“值”不仅仅是它返回的内容，还有它的**副作用**——那些改变计算之外世界状态的行为，比如修改全局变量或执行 I/O。

如果我们有一个计算 `e := f(g(x))`，其中 `g` 是一个**纯函数**（没有副作用，对于相同的输入总是返回相同的输出），但 `f` 有副作用，我们就不能将 `f(g(x))` 作为[公共子表达式消除](@entry_id:747511)的候选者。消除对 `f` 的第二次调用也会消除其副作用，这会从根本上错误地改变程序的行为[@problem_id:3622887]。因此，[可用表达式](@entry_id:746600)分析仅限于纯粹、无副作用的计算世界。它所促成的优化是关于节省计算工作，而不是改变程序的可观察行为。

### 扩大管辖范围：跨越函数边界

现代程序是由许多相互调用的函数构建的。我们的分析会在[函数调用](@entry_id:753765)处失效吗？不，它能很好地适应。编译器无需在每次调用 `callee()` 这样的函数时都重新分析它，而是可以分析一次并创建一个**摘要**。这个摘要优雅地捕捉了整个函数的 `GEN`/`KILL` 行为[@problem_id:3622884]：

1.  **必生成摘要**：`callee()` 在其所有内部路径上*保证*会计算哪些表达式（以其自身[参数表示](@entry_id:173803)）？
2.  **杀死摘要**：`callee()` 可能会修改哪些全局变量或有别名的调用者变量？

当主程序调用 `callee()` 时，它只需查阅这个摘要。一个表达式 `x+y` 在调用 `f(x, y)` 后可以是可用的，有两种方式：
*   **保留**：`x+y` 在调用*之前*就已经是可用的，并且 `f` 的杀死摘要显示它不修改 `x` 或 `y`。
*   **生成**：`f` 的必生成摘要保证它在其所有内部路径上都计算了等价的表达式。

这种模块化的方法使得 `GEN` 和 `KILL` 的简单、优雅原则能够从单个块扩展到整个程序，形成一个统一的信息流理论。

### 镜中之影：分析的对偶性

这些[数据流](@entry_id:748201)原则的美在于它们的对称性。[可用表达式](@entry_id:746600)分析是一种**前向分析**，它问的是：“从这个点回看，所有路径上都*已经计算*了什么？”

我们可以将整个分析颠倒过来，反向运行它。**[后向分析](@entry_id:746642)**可以问：“从这个点前瞻，所有未来路径上*将要计算*什么，在其输入被改变之前？”这被称为**预期表达式**（或十分活跃表达式）分析。它也是一种“必达”分析，也使用交集，但它从程序的出口向后传播信息。它用于不同的优化，比如将代码移出循环。

这种对偶分析的存在[@problem_id:3622909]揭示了一种更深层次的统一性。通过定义一个问题（“什么是可用的？”）、一个方向（前向）和一个证明标准（必达/交集），我们构建了一台强大的分析机器。改变问题或方向，同一台机器就能揭示关于程序的全新的、同样有价值的真相。正是这种潜在的数学优雅，将[代码优化](@entry_id:747441)的实际任务转变为一次发现之旅。

