## 引言
[Verilog](@article_id:351862) 不仅仅是一种编程语言；它是现实世界的蓝图，是描述构成我们现代世界的数字电路的工具。就像一套乐高积木，它允许设计师构建从简单的[逻辑门](@article_id:302575)到复杂的微处理器等任何东西。然而，要有效地进行构建，必须首先掌握支配这些数字结构如何被指定的基本原理。本文旨在解决新手面临的核心挑战：学会不再像软件程序员那样思考，而是像硬件设计师那样思考，即代码直接转化为物理连接和组件。

本指南将以结构化的方式引导您了解 [Verilog HDL](@article_id:346978) 的核心概念。首先，在“原理与机制”部分，我们将解构该语言的核心构建模块，探讨模块、`wire` 与 `reg` 之间的关键区别，以及阻塞赋值和[非阻塞赋值](@article_id:342356)截然不同的行为。然后，在“应用与跨学科联系”部分，我们将看到这些原理的实际应用，展示它们如何用于构建、连接和验证从简单算术单元到可扩展片上系统组件的一切，从而在抽象思维与有形硅片之间架起一座桥梁。

## 原理与机制

想象你有一盒乐高积木。你可以搭建任何你能想象的东西，从一堵简单的墙到一个完整的城堡。但要做到这一点，你必须理解基本原理：积木如何拼接在一起，不同形状的积木有何用途，以及如何将简单的结构组合成更复杂的结构。[Verilog](@article_id:351862) 很像这盒乐高积木。它不是一种用于编写软件的语言，而是用于*描述*硬件的语言——用于设计驱动我们世界的[数字电路](@article_id:332214)。要掌握它，我们必须首先领会其核心原理，这些原理既优雅又强大。

### 模块：盒子里的宇宙

每一个 [Verilog](@article_id:351862) 设计，无论多么宏大，都始于一个单一、基本的概念：**模块**（module）。模块是一个自包含的组件，一个黑盒子。它有边界，并封装了特定的功能。最简单的模块是完全不做任何事的模块。它只是一个命名的容器，用 `module` 关键字声明，并以 `endmodule` 结束。对于一个名为 `testbench_top` 的模块，它看起来异常简单 [@problem_id:1975484]：

```verilog
module testbench_top;
endmodule
```

这个空盒子本身没什么用，但它确立了最基本的构建单元。为了让我们的模块变得有趣，我们需要赋予它与外部世界交互的方式。我们需要在这个黑盒子上钻孔：用于信号输入的输入端口，以及用于信号输出的输出端口。这些被称为**端口**（ports）。

假设我们想设计一个 `data_register`，一个简单的存储元件。它需要一个数据输入、一个[时钟信号](@article_id:353494)来告诉它*何时*存储数据，以及一个数据输出。在现代 [Verilog](@article_id:351862) 中，我们直接在模块头中声明这些端口，很像 C 语言中的函数参数。我们指定它们的方向（`input` 或 `output`）和大小。对于一个 8 位寄存器，声明会是这样 [@problem_id:1975454]：

```verilog
module data_register(
    input [7:0] d,
    input clk,
    output [7:0] q
);
endmodule
```

这里，`[7:0]` 声明了一个 8 位向量，即一个由 8 条并行导线组成的“总线”。通过这种方式，我们定义了我们组件的*接口*。我们还没有说明它的功能，只说明了它如何与其他部分连接。这种定义清晰边界和接口的行为是[层次化设计](@article_id:352018)的核心，它使我们能够通过首先设计和测试其各个组件（如寄存器、加法器和控制单元）来构建复杂的微处理器。

### 两种思维方式：结构 vs. 行为

现在我们有了一个带输入和输出的盒子，我们如何描述内部发生的事情？[Verilog](@article_id:351862) 为此提供了两种截然不同的哲学，理解它们是像硬件设计师一样思考的关键。

1.  **描述结构**：这就像画一张电路图。你描述组件以及它们是如何连接在一起的。你定义的是一组连续、不变的关系。

2.  **描述行为**：这就像写一个食谱或一个脚本。你描述当特定事件发生时应该发生的一系列动作。

一个优秀的设计通常会混合使用这两种风格，为电路的每个功能部分选择最自然的表达方式。

### 线网、赋值与逻辑流

让我们首先探讨结构化方法。想象一下由导线连接的逻辑门。导线上的电压由驱动它的任何东西*持续*决定。在 [Verilog](@article_id:351862) 中，`wire` 数据类型恰好代表了这一点：一个物理连接。`wire` 不存储值；它只是传输值。

要用 `wire` 创建逻辑，我们使用 `assign` 关键字。一个连续赋值语句 `assign` 创建了一个永久的、始终处于活动状态的连接。它不是一次性的动作；它是一个真理的声明。考虑一个计算布尔函数 $f = (x + y) \cdot \overline{z}$ 的电路。我们可以使用 `assign` 语句作用于中间的 `wire`，在 [Verilog](@article_id:351862) 中直接而优雅地描述它 [@problem_id:1975240]：

```verilog
wire p, q;

assign p = x | y;  // p 是 x 和 y 的或
assign q = ~z;     // q 是 z 的非
assign f = p & q;  // f 是 p 和 q 的与
```

这种写法的妙处在于它与硬件的直接对应。你几乎可以看到 OR 门、NOT 门和 AND 门被连接起来。每当 `x`、`y` 或 `z` 改变时，结果 `f` 就会立即自动地重新计算，就像在真实电路中一样。这就是描述**组合逻辑**的精髓——其输出仅取决于当前输入的逻辑。

### 存储、行为与 `always` 块

但是需要*记忆*东西的电路呢？一个计数器需要记住它的当前值才能知道下一个值是什么。这被称为**[时序逻辑](@article_id:326113)**，它需要一种不同的思维方式——行为方法。

行为建模的主力是 `always` 块。一个 `always` 块包含一个脚本，每当其*敏感列表*中指定的事件发生时，该脚本就会执行。对于[同步电路](@article_id:351527)，这个事件通常是[时钟信号](@article_id:353494)的上升沿，写作 `always @(posedge clk)`。

现在我们面临一个新问题。如果一个信号的值是在 `always` 块内部决定的，那么在块执行的间隙它会发生什么？这里不能使用 `wire`；它需要一个持续的驱动源。我们需要一种能够在事件之间*保持*或*存储*其值的变量类型。在 [Verilog](@article_id:351862) 中，这就是 `reg` 数据类型。

这是一条至关重要的规则：**任何在过程块（如 `always`）内作为赋值目标的信号都必须声明为 `reg`** [@problem_id:1975235]。这就是为什么一个计数器的输出必须在每个[时钟沿](@article_id:350218)更新，所以被声明为 `output reg [3:0] count`。

人们很容易认为 `reg` 意味着一个物理硬件“寄存器”（如[触发器](@article_id:353355)）。这是一个常见且可以理解的错误，这个名字本身就助长了这种误解！`reg` 只是 [Verilog](@article_id:351862) 中一种可以保存值的变量类型。综合工具足够智能，能够根据*你如何使用 `reg`* 来判断*创建什么硬件*。

为了清楚地看到这一点，考虑一个 2-to-1 多路选择器，这是一个纯粹的组合逻辑电路。我们可以使用一个对*任何*输入变化都敏感的 `always` 块 (`always @(*)`) 来行为化地描述它。

```verilog
always @(*) begin
  if (s == 1) begin
    y = a;
  end else begin
    y = b;
  end
end
```

尽管这段代码描述了一组没有存储功能的[逻辑门](@article_id:302575)，但输出 `y` *必须*被声明为 `reg`，因为它在一个过程性的 `always` 块内被赋值 [@problem_id:1975239]。综合工具会查看这段代码，看到 `y` 的值总是根据当前输入被赋予，因此会创建[组合逻辑](@article_id:328790)（而不是一个[触发器](@article_id:353355)）。`reg` 类型是一条语言规则，而不是硬件指令。

### 两种赋值的故事：阻塞与非阻塞

在 `always` 块内部，我们正在编写一个脚本。但 [Verilog](@article_id:351862) 给了我们两种不同的赋值运算符，它们讲述了截然不同的故事。

-   **阻塞赋值 (`=`)**：这个运算符表示，“立即执行此操作，并且在完成之前不要进入下一行。” 赋值按顺序执行，就像在传统编程语言中一样。

    想象三个寄存器，`reg_A = 25`，`reg_B = 50`，`reg_C = 100`。如果我们执行以下代码块会发生什么？ [@problem_id:1915904]

    ```verilog
    always @(posedge clk) begin
      reg_A = reg_B;  // 1. reg_A 变为 50。
      reg_B = reg_C;  // 2. reg_B 变为 100。
      reg_C = reg_A;  // 3. reg_C 变为 50 (reg_A 的新值)。
    end
    ```

    执行是顺序的。`reg_A` 得到 `reg_B` 的值。*然后*，`reg_B` 得到 `reg_C` 的值。*然后*，`reg_C` 得到 `reg_A` 的值，而 `reg_A` 在第一步刚刚被更新。这导致最终状态为 `reg_A = 50`，`reg_B = 100`，`reg_C = 50`。这种行为对于建模多步[组合逻辑](@article_id:328790)或在单个时钟周期内创建临时变量很有用 [@problem_id:1915878]。

-   **[非阻塞赋值](@article_id:342356) (`<=`)**：这个运算符讲述了一个关于并行的故事。它表示，“在这个时间步开始时，根据*旧*值计算出所有新值。然后，在这个时间步的最后，将它们全部同时更新。”

    这是建模[同步逻辑](@article_id:355752)的关键，其中所有[触发器](@article_id:353355)在同一个[时钟沿](@article_id:350218)采样其输入，并一起更新其输出。让我们重新审视我们的寄存器交换。如果我们想执行 `A` 和 `B` 的真正并行交换，我们使用[非阻塞赋值](@article_id:342356)。

    ```verilog
    // A 和 B 是[触发器](@article_id:353355)
    always @(posedge clk) begin
      A <= B;  // 调度 A 获取 B 的旧值
      B <= A;  // 调度 B 获取 A 的旧值
    end
    ```

    在这里，所有的右侧表达式（`B` 和 `A`）首先被求值。然后，赋值被调度为“同时”发生。这正确地模拟了两个[触发器](@article_id:353355)在[时钟沿](@article_id:350218)交换它们的值。这就是为什么[同步设计](@article_id:342763)的黄金法则是：**对于由时钟驱动的 `always` 块驱动的信号，使用[非阻塞赋值](@article_id:342356) (`<=`)**。虽然混合使用阻塞和[非阻塞赋值](@article_id:342356)是可能的，并且具有明确定义的行为，但这需要仔细分析，并且常常是错误的来源 [@problem_id:1915892]。

### 构建层次与无政府状态的危险

有了这些原理，我们就可以开始构建了。我们可以拿一个像 `inverter`（反相器）这样简单、已验证的模块，并在一个更大的设计中**实例化**它，将其端口连接到我们的 `wire` 上。这就是管理复杂性的方法。我们不会一次性设计一个百万门级的芯片；我们设计小的、可管理的模块，然后将它们连接在一起 [@problem_id:1975491]。

```verilog
// 在一个更大的模块内部...
wire w1, w2;
// 实例化 'inverter' 模块，给它命名为 'u1'，
// 并连接它的端口。
inverter u1 (.a(w1), .y(w2));
```

这种层次化方法功能强大，但它依赖于一个基本准则：每个信号都应该有且仅有一个驱动源。如果我们打破这个规则会发生什么？如果两个不同的 `always` 块试图同时控制同一个 `reg` 呢？ [@problem_id:1943445]

```verilog
always @(posedge clk) begin
  q <= a;
end

always @(posedge clk) begin
  q <= b;
end
```

在时钟的上升沿，两个块都被唤醒。一个调度 `q` 接收 `a` 的值。另一个调度 `q` 接收 `b` 的值。哪一个会赢？[Verilog](@article_id:351862) 标准对此有明确规定：结果是**不确定的**。一个仿真器可能会选择 `a`，另一个可能会选择 `b`，第三个可能会选择文件中最后出现的那个。该语言没有定义并发块的执行顺序。这不是一个 bug；这是一个特性。这是该语言在发出警告，告诉你：“你的规范是模糊的！” 一个可靠的硬件设计不能有这样的**[竞争条件](@article_id:356595)**。这是一个严酷的提醒，[Verilog](@article_id:351862) 是一种用于*精确规范*的语言，在数字逻辑的王国里，无政府状态没有立足之地。