## 应用与跨学科联系

当我们初次学习一门深奥科学理论的原理时，我们可能感觉像是拿到了一把新钥匙。起初，我们可能只用它来开那把专为它设计的锁。但很快，我们开始注意到这把钥匙，或许稍加摆弄，也能打开我们从未想过要尝试的锁。[反馈控制](@entry_id:272052)的原理正是理解现代[操作系统](@entry_id:752937)的一把这样的钥匙。在掌握了测量、比较和执行的基础知识后，我们现在可以踏上一段旅程，穿越计算机系统的复杂机制，看到这种优雅的自动化之舞无处不在。事实证明，[操作系统](@entry_id:752937)是控制理论的大师，一个沉默、不知疲倦的调节者，其工作如此有效以至于变得无形。

### 驯服引擎：[CPU调度](@entry_id:636299)

让我们从最根本的资源开始：处理器自身的注意力。在任何给定的瞬间，一个处理器只能做一件事。然而，我们体验到的却是一个同时发生的世界——视频播放、消息到达、代码编译。这种幻觉是由[操作系统调度](@entry_id:753016)器精心打造的，它以惊人的速度分割CPU时间。但它应该如何划分这些时间呢？我们可能会说我们希望它是“公平的”，但这到底意味着什么？“公平性”不是一条物理定律；它是一个*目标*，一个我们希望达到的理想状态。而哪里有目标，哪里就可以有控制循环。

想象一下，我们想给两个任务，比如说任务$A$和任务$B$，分配CPU时间的$60/40$分割。我们可以给它们分配$6$和$4$的“权重”。但由于系统事件的混乱和不可预测性，仅仅以$6:4$的时间片比例运行它们并不能保证这个结果。解决方案是使用反馈。[操作系统](@entry_id:752937)可以*测量*每个任务在短时间内实际获得的CPU时间比例。然后它将这个实现的份额与目标份额（对任务$A$是$0.60$）进行*比较*。如果任务$A$获得的份额低于其目标，控制器会做出一个小的纠正性*执行*：它为下一个调度窗口略微增加任务$A$的权重。如果它获得的太多，它的权重就会被略微降低。

这个简单的想法有一个优美的精妙之处。一个天真的控制器可能会对每一个微小的波动都反应过度，就像一个新手司机在路上的每一个颠簸处都猛拉方向盘。然而，一个成熟的调度器，其行为就像一位经验丰富的飞行员。它不是对瞬时测量值做出反应（这通常是带噪声的），而是对平滑后的趋势做出反应。通过使用像指数加权移动平均（EWMA）这样的技术，控制器给予近期历史更多的权重，使其能够平稳、稳定地朝着目标前进，而不会出现剧烈[振荡](@entry_id:267781)[@problem_id:3673602]。这是我们第一次看到控制理论在实践中的应用：将一个像“公平性”这样的模糊目标，转变成一个精确、自动化且稳健的机制。

### 有限的地产：内存管理

接下来，我们转向内存。与CPU时间这种持续流动的资源不同，物理内存是一种有限的、空间性的商品。这带来了新的挑战，也随之带来了控制理论的新应用。[内存管理](@entry_id:636637)中最臭名昭著的问题是一种称为**[抖动](@entry_id:200248)**的灾难性故障模式。

[抖动](@entry_id:200248)是典型的不稳定正反馈循环的例子。它始于[操作系统](@entry_id:752937)过度承诺内存，允许如此多的进程运行，以至于它们的“[工作集](@entry_id:756753)”——它们活跃需要的页面——的总和超过了可用的物理[RAM](@entry_id:173159)。一个进程发生了[缺页](@entry_id:753072)。[操作系统](@entry_id:752937)必须从磁盘中调入所需的页面，但要做到这一点，它必须首先驱逐另一个页面。由于内存已满，被驱逐的页面很可能属于另一个进程的[工作集](@entry_id:756753)。很快，那个进程也会发生缺页，需要*它的*页面回来，导致另一次驱逐，如此循环往复。当每个进程都卡在等待磁盘时，[CPU利用率](@entry_id:748026)急剧下降。而[操作系统](@entry_id:752937)看到CPU空闲，甚至可能认为它可以接纳*更多*的进程，这无异于火上浇油。系统陷入停滞，所有时间都花在交换页面（[抖动](@entry_id:200248)）上，而没有做任何有用的工作[@problem_id:3688383]。

我们如何驯服这头野兽？用一个更智能的控制器。关键的反馈信号是**[缺页频率](@entry_id:753068)（PFF）**。我们可以建立一个控制循环：如果一个进程的PFF太高，它可能需要更多的内存帧。如果它的PFF非常低，它可能拥有的帧比它需要的多，这些帧可以给另一个进程。这导向了一个优美的、分层的控制结构。在最低层，每个进程都运行着一个局部页面替换策略。但一个更高级别的控制器监控所有进程的PFF。如果整个系统的PFF攀升到危险的高度，说明系统正在进入[抖动](@entry_id:200248)状态。控制器此时可以从“局部”模式切换到“全局”模式，主动地将帧从PFF低的进程重新分配给PFF高的进程。为了稳定地做到这一点，它再次运用了我们的技巧：它使用平滑后的PFF估计值来避免对噪声做出反应，使用滞后效应来防止在局部和全局模式之间“[抖动](@entry_id:200248)”，并采用渐进式调整以避免对系统造成冲击[@problem_id:3645299]。

但内存的数量只是故事的一半。另一半是它的布局。内存可能会变得*碎片化*——分裂成许多小的、不连续的空闲块。你可能总共有几GB的空闲RAM，但如果最大的单个连续块只有几KB，你就无法启动一个需要大块连续内存的程序。一个代价高昂的解决方案是**紧凑**，即[操作系统](@entry_id:752937)移动内存内容以合并空闲空间。它应该在什么时候执行如此昂贵的操作？一个天真的控制器可能会在碎片化超过某个阈值时立即触发紧凑。这将是极其低效的。一个真正智能的、受控制理论启发的控制器，使用更复杂的逻辑。它可能会使用滞后效应来避免重复触发紧凑。更好的是，它基于*已证明的需求*来行动：它只在一个对大块内存的请求失败时，并且整理出大块内存的预期收益超过了操作的高昂成本时，才启动紧凑[@problem_id:3644708]。这是控制理论在教导[操作系统](@entry_id:752937)不仅要正确，还要经济。

### 超越核心：控制的统一性

一旦你有了一把钥匙，你就会开始到处看到锁。那些支配CPU和内存的[反馈控制](@entry_id:272052)原理，几乎可以应用于[操作系统](@entry_id:752937)管理的所有其他资源。

考虑[内存管理](@entry_id:636637)器和I/O子系统之间的密切关系。[缺页](@entry_id:753072)，从本质上讲，是一个对磁盘I/O的请求。如果磁盘已经过载，有很长的请求队列在等待，那该怎么办？在这种情况下，要求磁盘做更多的工作——比如写出一个“脏”（被修改过的）页面来为新页面腾出空间——只会加剧瓶颈。一个具备I/O感知能力的[操作系统](@entry_id:752937)可以在这里实现一个控制循环。它监控磁盘的队列深度。如果队列长度超过某个阈值，一个反馈信号就会被发送到页面替换算法：“目前，如果可以的话，请尽量驱逐*干净*的页面。”驱逐一个干净的页面不需要磁盘写入，从而减轻了饱和磁盘的负载。这两个看似独立的[操作系统](@entry_id:752937)子系统之间的这种简单、优雅的协调，正是通过一个反馈循环成为可能[@problem_id:3639455]。

[操作系统](@entry_id:752937)也是通往网络的守门人。它如何防止一个行为不端的应用程序用数据包淹没网络？它使用一个速率限制器，通常是**[令牌桶](@entry_id:756046)**。可以把它想象成一个不断被“令牌”填充的桶，每个令牌授权发送一个数据包。要发送一个数据包，应用程序必须拿走一个令牌。如果桶是空的，它必须等待。这个机制平滑了突发流量。但令牌的正确补充速率是多少？控制理论给了我们答案。[操作系统](@entry_id:752937)可以监控网络套接字发送队列的长度。如果队列在增长，说明到达速率太高。一个[比例控制器](@entry_id:271237)就可以降低令牌的补充速率。如果队列在缩短，它可以增加速率。这个反馈循环动态地调整网络流量以匹配可用容量，并且通过仔细的[数学分析](@entry_id:139664)，我们甚至可以证明其稳定性[@problem_id:3641420]。

这种思路甚至适用于[操作系统](@entry_id:752937)对其自身内部资源的管理。操作系统内核本身需要分配小的、频繁使用的数据结构。一个常见的机制是**[slab分配器](@entry_id:635042)**，它维护着多个预初始化对象的池。[操作系统](@entry_id:752937)应该如何在其不同的slab缓存之间分配其宝贵的内核内存？一个粗暴的中央管理器会复杂而缓慢。相反，我们可以从经济学中借用一个优美的想法：**影子价格**。一个全局控制器不直接规定分配；它只是广播一个内存的“价格”。当内存充裕时，价格低。当内存稀缺时，价格高。然后，每个单独的slab缓存做出一个局部的、分散的决策：“以当前的价格，是否值得‘购买’另一个slab的内存来减少我的分配延迟？”这创建了一个动态的、自组织的系统，其中资源流向它们最有价值的地方，而这一切都由一个单一、简单的反馈信号来协调[@problem_id:3683575]。

### 更广阔的视野：[操作系统](@entry_id:752937)在更广阔的世界中

控制理论的影响力并不止于内核的边界。[操作系统](@entry_id:752937)存在于一个更大的生态系统中，而最强大的控制循环往往是那些跨越边界的。

如果[操作系统](@entry_id:752937)能够与其运行的应用程序合作，它的效率可以大大提高。想象一个程序表现出很高的[缺页率](@entry_id:753068)。[操作系统](@entry_id:752937)可以简单地给它更多内存。但它也可以向程序的[运行时系统](@entry_id:754463)发送一个*提示*。一个由编译器生成的智能运行时可以解释这个提示：“啊，[操作系统](@entry_id:752937)在告诉我我的[内存局部性](@entry_id:751865)很差。”然后它可以通过改变其数据访问模式来动态地做出反应——例如，通过重组一个循环来以更小的、对缓存友好的块来处理一个大矩阵。这创建了一个协作的、跨层的控制循环，其中[操作系统](@entry_id:752937)和应用程序共同解决问题[@problem_id:3667779]。

这个想法在**[虚拟化](@entry_id:756508)**中达到了顶峰，此时的“应用程序”是另一个完整的[操作系统](@entry_id:752937)。一个主机hypervisor必须管理其客座[虚拟机](@entry_id:756518)之间的内存。一个客座[操作系统](@entry_id:752937)，通过一个[半虚拟化](@entry_id:753169)接口，可以向主机提供高层次的信息，例如它的哪些内存页是“热”的（频繁访问），哪些是“冷”的。当内存压力很大时，主机可以利用这些信息在一个反馈循环中决定从哪个客座回收哪些页面，这是一种比盲目回收页面远为智能的方法[@problem_id:3668568]。

我们甚至可以进一步概括。CPU时间、内存和I/O带宽都只是一个更基本资源——**能量**——的代理。尤其是在移动设备上，能量是最终的货币。现代[操作系统](@entry_id:752937)可以——也应该——将能量视为一种一等、可调度的资源。这要求[操作系统](@entry_id:752937)在一个新的领域中实例化其基本角色：它必须*核算*每个进程的能量使用情况，*分配*能量预算（例如，以焦耳/秒为单位），并通过限制CPU频率、GPU活动或网络访问来*强制执行*这些预算。这是[操作系统](@entry_id:752937)作为资源管理者的终极体现，使用控制理论的语言来管理能量本身的流动[@problem-id:3664541]。

最后，让我们放大到最大可能的尺度：现代数据中心。一个拥有数千台服务器的数据中心，不就是一个单一的、巨大的、[分布](@entry_id:182848)式的[操作系统](@entry_id:752937)吗？同样的控制和资源分配问题再次出现，只是舞台更加宏大。在这里，我们看到了一个优美的层次结构。每台机器上的本地[操作系统](@entry_id:752937)继续运行其快速的、局部的控制循环，用于像CPU[时间分片](@entry_id:755996)这样的事情。但在此之上，还有一个**集群编排器**（如[Kubernetes](@entry_id:751069)），它扮演着一个全局的、速度较慢的控制器角色。它基于对集群健康和负载的全局视图，做出粗粒度的决策，比如将一个新的应用程序容器放在哪里。集中式与[分布式控制](@entry_id:167172)、延迟与全局知识、[可扩展性](@entry_id:636611)与弹性之间的根本权衡，与我们一直以来所处理的问题是相同的，只是被放大了千倍[@problem_id:3664584]。

从[CPU调度](@entry_id:636299)器的微观决策到全球数据中心的宏观编排，反馈控制的原理提供了一种统一的语言。它是为并发计算的混乱世界带来秩序、稳定和效率的隐藏逻辑。它证明了原则性设计的力量，并优美地说明了几个优雅的思想如何能创造出几乎无法想象的复杂系统，而这些系统，尽管困难重重，却能正常工作。