## 引言
您如何确定计算机启动时加载的软件是真实的，并且没有被恶意软件篡改？在您的[操作系统](@entry_id:752937)高级安全功能加载之前，一系列关键组件——固件、[引导加载程序](@entry_id:746922)、内核——必须先行执行。这个预启动环境历来是复杂攻击（如 bootkit）的主要目标，这些攻击能够在最基础的层面上夺取系统控制权，使传统杀毒软件无法察觉。这就产生了一个关键的知识鸿沟：在我们信任的[操作系统](@entry_id:752937)运行之前，我们如何建立信任？

本文旨在揭示专为解决此问题而设计的技术：UEFI [安全启动](@entry_id:754616)。它提供了一个基础防御层，确保从您按下电源按钮的那一刻起，启动过程的完整性就得到保障。在接下来的章节中，您将深入了解这一安全基石。我们将首先探讨“原则与机制”，剖析作为[安全启动](@entry_id:754616)基础的加密“[信任链](@entry_id:747264)”、密钥数据库的角色，以及其与[度量启动](@entry_id:751820)和[可信平台模块 (TPM)](@entry_id:756205) 的关键伙伴关系。随后，“应用与跨学科联系”一章将阐述这一理论基础如何在现实世界中得到应用——从保护您的个人双系统启动设置、管理企业设备群，到在广阔的云计算领域中实现可验证的信任。

## 原则与机制

想象一下，您是一个庞大王国的君主。您需要将一道关键法令从您的城堡（计算机固件）传达到都城（[操作系统](@entry_id:752937)）。您将依赖一系列信使，首先是一位皇家信使（[引导加载程序](@entry_id:746922)），他再将[消息传递](@entry_id:751915)给一位值得信赖的将领（内核）。但您如何确定最终在都城传达的消息是您的，而不是来自一个狡猾篡位者的伪造品？您如何确保没有冒名顶替者在途中取代了您的信使？

这就是 **UEFI [安全启动](@entry_id:754616)** 旨在解决的根本问题。它并非魔法，而是一个既优美简单又强大的理念：**[信任链](@entry_id:747264)**。

### 数字握手：[信任链](@entry_id:747264)

您整个王国的安全都建立在您（且只有您）拥有的东西上：皇家印章。在您的信使出发前，您将此印章盖在他的命令上。在每个检查站，持有您印章印记合法副本的守卫都可以验证其真实性。

在数字世界里，这个“印章”就是**[数字签名](@entry_id:269311)**，一种非对称加密的产物。该系统使用一对密钥：一个**私钥**，像皇家印章本身一样保密；一个**公钥**，可以像印章的印记一样广泛分发。用私钥签名的消息只能由其对应的公钥来验证。

UEFI [安全启动](@entry_id:754616)将这个“皇冠上的宝石”——公钥——嵌入到计算机固件中一个受保护的、非易失性的部分，这个地方对于攻击者来说，就像您城堡的石墙一样难以更改。启动过程随后展开为一系列数字握手：

1.  当您打开计算机电源时，首先运行的代码是 UEFI 固件。它在磁盘上找到第一个“信使”，即[操作系统](@entry_id:752937)[引导加载程序](@entry_id:746922)。
2.  在执行它之前，固件会进行一次加密检查。它使用其嵌入的公钥来验证[引导加载程序](@entry_id:746922)文件上的[数字签名](@entry_id:269311)。如果签名有效——意味着它必须由相应私钥的持有者（例如，Microsoft 或计算机制造商）签名——固件便扩展其信任并运行[引导加载程序](@entry_id:746922)。
3.  现在受信任的[引导加载程序](@entry_id:746922)拥有自己的一套公钥。它使用其中之一来验证链中下一个组件——操作系统内核本身——的签名。
4.  只有当这最后一次握手成功时，[引导加载程序](@entry_id:746922)才会移交控制权，允许内核启动。

这个序列建立了一条**[信任链](@entry_id:747264)**，其中信任从硬件固件中一个不可变的根开始，传递性地传递到完全运行的[操作系统](@entry_id:752937)。此过程的目标是**强制执行**：它主动阻止任何未经授权或被修改的组件运行，如果链中的任何环节被破坏或伪造，启动过程将立即中止 [@problem_id:3685994]。该系统的加密强度是巨大的；对于签名中使用的标准 SHA-256 哈希，攻击者创建一个恰好与合法内核具有相同哈希值的恶意内核的几率约为 $2^{256}$ 分之 $1$。即使能够尝试十亿个十亿次（$10^{18}$），成功的概率仍然小到可以忽略不计（约为 $2^{-196}$），以至于物理上不可能实现 [@problem_id:3635101]。

### 信任的剖析：密钥与数据库

虽然单个密钥的概念是一个有用的起点，但真实的机制更像一个皇家宫廷，拥有复杂的权限等级。UEFI [安全启动](@entry_id:754616)策略不是由单个密钥定义的，而是由一组存储在固件中的经认证的变量定义的：

-   **平台密钥 ($PK$)**：这是主密钥，代表平台的最终所有者（通常是硬件制造商）。$PK$ 的存在意味着系统处于 `UserMode` 并且[安全启动](@entry_id:754616)策略正在被强制执行。清除 $PK$ 会将系统转换到 `SetupMode`，这是一种安全被禁用、任何有权限的人都可以重写策略的状态。因此，保护 $PK$ 对整个安全模型至关重要 [@problem_id:3688014]。

-   **密钥交换密钥 ($KEK$)**：这是一个密钥数据库，其中的密钥被信任可以修改签名数据库。可以把它们想象成宫廷中经授权的文书，由君主授权来更新受信任和被禁止的信使名单。

-   **签名数据库 ($db$)**：这是“允许列表”。它包含允许运行的[引导加载程序](@entry_id:746922)、驱动程序和应用程序的实际证书和哈希值。[引导加载程序](@entry_id:746922)上的签名必须能追溯到此数据库中的一个证书。

-   **禁止签名数据库 ($dbx$)**：这是“拒绝列表”或撤销列表。它包含那些曾经被信任但现在已知被攻破或存在漏洞的组件的哈希值。在允许一个程序运行之前，固件不仅检查它是否在 $db$ 中，还要检查它是否*不*在 $dbx$ 中。

这种架构为在设备生命周期内管理信任提供了一个强大而灵活的系统。想象一下，一个受信任的、已签名的[引导加载程序](@entry_id:746922)后来被发现存在严重漏洞。它已经被分发到数百万台机器上。你如何阻止它运行？你无法收回签名。解决方案是将其哈希值添加到 $dbx$ 中。下次机器启动时，尽管[引导加载程序](@entry_id:746922)的签名来自 $db$ 中的一个有效密钥，固件仍会看到它在撤销列表上，并拒绝加载它。保持这个 $dbx$ 的更新是一项关键的安全功能，通常通过使用来自 $KEK$ 数据库的密钥签名的安全固件更新来处理 [@problem_id:3685769]。

### 毫不眨眼的见证者：[度量启动](@entry_id:751820)与 TPM

[安全启动](@entry_id:754616)是一名守卫；它的工作是对未经授权的代码说“你不能通过！”。但如果我们想要些别的呢？如果我们不想要守卫，而想要一个毫不眨眼、清正廉洁的宫廷记录员，他能毫无差错地记录下进入城堡的每一个人的身份，那该怎么办？这就是**[度量启动](@entry_id:751820)**背后的哲学。

这个“记录员”是主板上一个特殊的、防篡改的芯片，称为**[可信平台模块 (TPM)](@entry_id:756205)**。[度量启动](@entry_id:751820)使用 [TPM](@entry_id:170576) 为整个启动过程创建一个加密审计追踪。以下是它与[安全启动](@entry_id:754616)的不同之处：

1.  在 UEFI 固件执行[引导加载程序](@entry_id:746922)之前，它会计算[引导加载程序](@entry_id:746922)的**加密哈希**——一个独特的数字指纹。
2.  然后它将这个度量值报告给 TPM。
3.  [TPM](@entry_id:170576) 不仅仅是存储这个哈希值。它在一个名为**平台配置寄存器 (PCR)** 的特殊寄存器上执行一个独特的操作，称为 **extend**。寄存器的新值变为 $PCR_{new} \leftarrow H(PCR_{old} \parallel \text{measurement})$，其中 $H$ 是一个哈希函数，$\parallel$ 表示[串联](@entry_id:141009)。

这个 `extend` 操作是单向的。由于加密哈希的特性，一旦一个度量值被融入 PCR，你就无法反向操作来移除或更改它。这创建了一个累积的、防篡改的日志。启动链中任何组件的一个比特位的改变都会导致一个完全不同的最终 PCR 值。这个过程在每个阶段都会继续：[引导加载程序](@entry_id:746922)度量内核，内核可以度量其驱动程序，依此类推。

关键的区别在于：[安全启动](@entry_id:754616)关乎**预防**，而[度量启动](@entry_id:751820)关乎**证明**。[度量启动](@entry_id:751820)不会阻止任何东西运行；它只是忠实地记录下发生了什么。

考虑一个微妙的攻击：一个对手获得了对计算机的访问权限，并修改了[引导加载程序](@entry_id:746922)的配置，以添加一个恶意的内核命令行参数，比如一个禁用关键安全服务的参数。[引导加载程序](@entry_id:746922)和内核文件本身没有改变，所以它们的签名仍然有效。[安全启动](@entry_id:754616)会检查签名并愉快地启动系统，认为一切正常。

然而，一个正确配置的[度量启动](@entry_id:751820)系统也会根据其策略度量内核命令行。这个恶意参数，因为它与合法的参数不同，将被哈希并扩展到一个 PCR 中。尽管系统启动了，但最终的 PCR 值将与“已知良好”的值不同。之后，执行**[远程证明](@entry_id:754241)**的远程服务器可以向 [TPM](@entry_id:170576) 请求其 PCR 的签名报价。当服务器看到不匹配的值时，它就拥有了系统状态已被更改的加密证明，并可以拒绝其访问网络，尽管[安全启动](@entry_id:754616)没有发现任何问题 [@problem_id:3679609]。

### 堡垒的局限：当信任不足之时

我们已经建造了一座美丽的堡垒，有警惕的守卫（[安全启动](@entry_id:754616)）和一丝不苟的记录员（[度量启动](@entry_id:751820)）。它似乎坚不可摧。但任何优秀的物理学家或工程师都知道，最有趣的发现是在你把一个系统推向极限，看它在哪里崩溃时做出的。这种[信任链](@entry_id:747264)提供的安全性是强大的，但并非绝对。

#### 内部的敌人：已签名但存在漏洞

[数字签名](@entry_id:269311)做出了一个深刻但狭隘的声明：它断言**真实性**（谁签名的）和**完整性**（签名后未被更改）。它完全没有对**正确性**或**安全性**做出任何声明。一个组件可以完全是真实的，由可信供应商签名，但仍可能包含灾难性的错误。[@problem_id:3679560]

想象一个由供应商签名的驱动程序，它是系统[可信计算基 (TCB)](@entry_id:756202)——对安全至关重要的组件集合——的一部分。[安全启动](@entry_id:754616)验证其签名并加载它。[度量启动](@entry_id:751820)记录其合法的哈希值。但该驱动程序包含一个经典的[缓冲区溢出](@entry_id:747009)漏洞。攻击者可以向正在运行的驱动程序提供一个特制输入，触发该漏洞，从而劫持程序的执行流并接管整个系统。

[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)对此视而不见，因为攻击是一种利用代码逻辑缺陷的**运行时漏洞利用**，而不是对其磁盘上完整性的破坏。这给我们一个重要的教训：你信任的组件集合 (TCB) 并不等同于安全的组件集合。为了防御此类威胁，我们需要互补的技术，如**[控制流完整性 (CFI)](@entry_id:747827)**，它可以防止运行时劫持，以及应用**[最小权限原则](@entry_id:753740)**来隔离驱动程序，以便一个驱动程序的妥协不会危及整个系统。[@problem_id:3679560] [@problem_id:3679587]

#### 地基本身就是流沙：固件恶意软件

整个[信任链](@entry_id:747264)都锚定在固件上。我们假设城堡的墙壁是不可变的石头。但如果城堡的地基是沙子做的呢？如果攻击者能够攻破 UEFI 固件本身，那么游戏就结束了。

恶意的固件可以撒谎。它可以检查一个恶意的[引导加载程序](@entry_id:746922)，发现它未签名，然后就当没事一样继续。它可以通过向 [TPM](@entry_id:170576) 呈现一个*好*内核的哈希值，而实际上加载一个*坏*内核，从而颠覆[度量启动](@entry_id:751820)。[远程证明](@entry_id:754241)会显示一次完美的启动，因为负责进行度量的实体——固件——本身已经被攻破。这就是为什么固件及其初始度量代码——**度量可信根 (CRTM)**——的完整性至关重要。在这个层面上的恶意软件，例如在 UEFI 驱动程序或高度特权的系统管理模式 (SMM) 中的恶意软件，可以在[操作系统](@entry_id:752937)重装后依然存在，并且对于它所控制的[操作系统](@entry_id:752937)几乎是不可见的 [@problem_id:3673354]。

#### 暗夜之贼：物理攻击

最后，理解[安全启动](@entry_id:754616)*不是*什么至关重要。它是一种确保在启动过程中从磁盘加载的代码完整性的机制。它不是一种在系统运行*后*保护内存中数据机密性的机制。

考虑一个采用全盘加密的系统，其解密密钥由 TPM 保护。在[安全启动](@entry_id:754616)时，[TPM](@entry_id:170576) 解封密钥并将其交给[操作系统](@entry_id:752937)，[操作系统](@entry_id:752937)将其放入 DRAM 以访问磁盘。现在，一个拥有短暂物理访问权限的攻击者执行了一次**冷启动攻击**：他们突然断开机器电源，冷却 DRAM 芯片以使数据持续存在几秒钟，然后物理地将 RAM 移到另一台设备上读取其内容。磁盘加密密钥就这样直接从内存中被盗走了。

[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)对此[无能](@entry_id:201612)为力。这种攻击不涉及在受害者机器上启动恶意代码，所以[信任链](@entry_id:747264)是无关紧要的。这是对一个超出[安全启动](@entry_id:754616)设计所要应对的威胁模型之外的组件的直接物理攻击 [@problem_id:3679600]。

### 安全的交响曲

将 UEFI [安全启动](@entry_id:754616)视为万灵药，就错失了它的精妙之处。它真正的美在于它在宏伟的安全交响曲中扮演的角色，就像其中一种乐器。[安全启动](@entry_id:754616)是强劲的铜管乐器组，提供了一个强大的、预防性的基础，阻止了大量常见的、不复杂的攻击。[度量启动](@entry_id:751820)是严谨的打击乐器组，提供了一个持续的、不可否认的证据节奏，让外部的指挥家——远程验证者——能够确保演出忠于乐谱。像[沙盒](@entry_id:754501)和 CFI 这样的运行时防御是灵活的弦乐和木管乐器组，处理在演出过程中出现的复杂、动态的挑战。

每个部分都至关重要，也各有其局限。但它们共同创造了一个分层的、有弹性的系统，远比任何单一组件本身能达到的安全水平要高得多。信任的旅程，从一个单一的硅基锚点到一个完整的[操作系统](@entry_id:752937)，证明了像物理学家一样思考的清晰和力量：从一个简单的原则开始，在其上构建，然后，最重要的是，严格地质疑其局限以发现更深层次的真理。

