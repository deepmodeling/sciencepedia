## 应用与跨学科联系

在我们之前的讨论中，我们阐述了[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)的原则。我们看到了它们如何协同工作，建立一个“[信任链](@entry_id:747264)”，从硬件中一个不可变的根开始，一环接一环地延伸到操作系统内核。这个理论是优雅的，是[密码学](@entry_id:139166)和系统架构的一曲优美交响。但它有什么用呢？这条在我们机器的硅片和固件中铸就的链条，对我们真实、混乱的数字世界有任何影响吗？

答案是响亮的“是”。这个信任的基础不仅仅是理论上的好奇心；它是一个发射台，催生了涵盖个人计算、企业管理乃至云架构本身的各种安全能力。让我们踏上征程，看看这条[信任链](@entry_id:747264)是如何发挥作用的。

### 保护你自己的世界：个人计算机

我们从你桌上的那台机器开始。对于许多好奇的用户和开发者来说，一个[操作系统](@entry_id:752937)是不够的。你可能想用 Windows 来玩游戏，用 Linux 发行版来进行开发。这是经典的双系统启动场景，它给我们带来了第一个难题：当我们有两条独立的启动路径时，如何维持信任？

想象一下启动过程。UEFI 固件，我们可信的锚点，验证并启动一个[引导加载程序](@entry_id:746922)。在使用流行的 GRUB [引导加载程序](@entry_id:746922)的标准 Linux 设置中，会使用一个名为“shim”的特殊组件。这个 shim 由 Microsoft 签名，所以固件信任它。而 shim 则信任 GRUB，但前提是您，即机器的所有者，已经明确为其注册了一个密钥——一个机器所有者密钥 (MOK)。这创造了一种绝佳的信任委托。固件信任 Microsoft，Microsoft 信任 shim，shim 信任您，而您信任您选择的[引导加载程序](@entry_id:746922)。

但这里有个问题。GRUB 接下来做什么？如果它被配置为加载一个已经用您的 MOK 正确签名的 Linux 内核，那么[信任链](@entry_id:747264)将保持完整。但如果 GRUB 被配置为加载一个*未签名*的内核——也许是您刚为了实验而编译的一个——那么强制执行链就在那一刻被切断了。系统仍然会启动，但真实性的保证已经消失。固件和 shim 所有细致的工作都被规避了。这突显了一个深刻的观点：[安全启动](@entry_id:754616)不是一个绝对的状态，而是一条其强度取决于每一环节的链条 [@problem_id:3679547]。

这种扩展信任的原则不仅适用于内核，也适用于任何需要在特权的预启动环境中运行的东西。现代外围设备，如显卡或网络适配器，通常需要运行自己的固件，称为选项 ROM，以进行自我初始化。在旧的 BIOS 时代，这些 ROM 会直接运行，无需任何验证。现代 UEFI 系统可以被置于“兼容性支持模块”(CSM) 模式以支持这些传统设备，但这就像留了一扇侧门没锁。攻击者可以制造一个带有恶意传统选项 ROM 的恶意 PCIe 设备，而 CSM 会很乐意地执行它，在[操作系统](@entry_id:752937)开始加载之前就攻破机器。解决方案？禁用 CSM。这会强制系统进入纯粹的、现代的 UEFI 模式，在该模式下，所有选项 ROM 都必须是正规的 UEFI 驱动程序，像启动链的任何其他部分一样经过签名和验证。这种纪律，结合[度量启动](@entry_id:751820)来记录加载了什么，为我们提供了预防和检测——一种针[对流](@entry_id:141806)氓硬件的[纵深防御](@entry_id:203741) [@problem_id:3685989]。

对于开发者和高级用户，尤其是在 Linux 世界中，系统必须是可扩展的。如果您需要为您的特殊硬件加载一个自定义的、第三方的内核模块怎么办？[安全启动](@entry_id:754616)是否迫使您在安全和功能之间做出选择？完全不是。用于保护 GRUB 的同一个 MOK 机制也可以用来签署您自己的内核模块。通过注册您自己的密钥，您告诉内核，“我信任由这个密钥签名的代码。”当您加载您的模块时，内核会根据您的 MOK 验证其签名。如果匹配，模块加载；如果不匹配，则被拒绝。[信任链](@entry_id:747264)得以保留，并由您，机器的所有者，优雅地扩展了 [@problem_id:3686058]。

### 企业堡垒：管理设备群

现在让我们从一台计算机扩展到一个大学校园或一个拥有数千台机器的大型公司。在这里，[安全启动](@entry_id:754616)从一个个人安全功能转变为一个强大的、用于企业范围策略强制执行的工具。

一个组织可能需要允许技术人员从特殊的、企业批准的 USB 维护驱动器启动。但他们绝对不能允许员工从在停车场捡到的随机 U 盘启动。解决方案不是简单地打开或关闭 USB 启动。相反，IT 部门可以自定义[安全启动](@entry_id:754616)数据库。他们可以从“允许”数据库 ($db$) 中移除通用的第三方密钥，只添加企业自己的公共签名密钥。然后，他们用相应的私钥签署他们的维护介质。同时，他们必须勤勉地用已知恶意加载程序的哈希值更新“拒绝”数据库 ($dbx$)。结果是一个精确的策略：只有我们批准的工具才能启动。[最小权限原则](@entry_id:753740)被直接应用于信任的基础 [@problem_id:3679584]。

这种控制延伸到网络启动。在许多数据中心，机器是“无盘的”，使用预启动执行环境 (PXE) 通过网络启动其[操作系统](@entry_id:752937)。标准的 PXE 协议，DHCP 和 TFTP，是出了名的不安全；它们是为了在受信任网络中提供便利而设计的。同一局域网上的攻击者可以轻易地冒充启动服务器，并向客户端提供一个恶意的[操作系统](@entry_id:752937)。在这里，我们的[信任链](@entry_id:747264)再次提供了解决方案。客户端下载的第一个网络引导程序 (NBP) 必须由 UEFI [安全启动](@entry_id:754616)签名和验证。这第一步确保了立足点。这个受信任的 NBP 随后可以拒绝使用不安全的 TFTP，而是通过像 TLS 这样的安全加密通道获取[操作系统](@entry_id:752937)的其余部分，并在此过程中验证服务器的身份。所有这些活动——签名的 NBP、安全服务器的身份、[操作系统](@entry_id:752937)组件的哈希值——都被度量到 TPM 中，为安全的网络启动提供了不可辩驳的证据 [@problem_id:3679590]。

但是当发现威胁时会发生什么？假设一个广泛使用的[引导加载程序](@entry_id:746922)被发现存在严重漏洞。供应商发布了一个补丁，将被攻破的[引导加载程序](@entry_id:746922)的哈希值添加到 $dbx$ 撤销列表中。对于一个企业来说，这开启了一场与时间的赛跑。更新必须被分发到每一台机器上，然后每台机器都必须重启以使新的 $dbx$ 生效。从漏洞公布到某台机器被打上补丁并重启的这段时间是其“残余风险窗口”。通过对设备连接网络接收更新的频率和它们重启的频率进行建模，一个组织可以定量分析其安全态势。很明显，管理一个设备群是信任的加密机制与设备连接性和用户行为的操作现实之间的相互作用 [@problem_id:3679551]。

### 信任的前沿：云及其他

[安全启动](@entry_id:754616)的原则是如此基础，以至于它们甚至延伸到了[虚拟化](@entry_id:756508)和[云计算](@entry_id:747395)的抽象世界。当您在云中运行[虚拟机](@entry_id:756518) (VM) 时，“启动”到底意味着什么？[虚拟机](@entry_id:756518)管理程序 (hypervisor)，一个在主机服务器上运行的专门程序，为您的 VM 创建了一个模拟的硬件环境。

这个虚拟硬件包括一个虚拟固件，以及至关重要的一个虚拟 TPM (vTPM)。从 VM 的角度来看，过程是相同的：它的虚拟固件执行一次安全和度量的启动，将度量值记录在其 v[TPM](@entry_id:170576) 中。客户机[操作系统](@entry_id:752937)随后可以使用 vTPM 来保护其机密。但有一个关键的区别。VM 的整个存在——它的虚拟固件、虚拟 CPU、内存、vTPM——都是由 hypervisor 管理的软件构造。因此，客户机的整个[信任链](@entry_id:747264)都锚定在主机及其 hypervisor 的安全性上。这创造了信任层：客户机信任其虚拟固件，但它也必须隐式地信任提供该固件的 hypervisor。这就是为什么云提供商自身基础设施的安全性如此至关重要的原因 [@problem_id:3679569]。

这种[分层模型](@entry_id:274952)促成了[度量启动](@entry_id:751820)最强大的应用之一：**[远程证明](@entry_id:754241)**。假设您想在云 VM 中运行一个敏感的工作负载，但您只有在能够*证明*该 VM 正在运行正确、未被篡改的软件时才会这样做。您不能只问 VM，因为一个被攻破的 VM 可能会撒谎。相反，您参与了一场优美的加密舞蹈。您的验证服务向 VM 发送一个独特的、一次性的挑战（一个“nonce”）。VM 将此 nonce 传递给它的 vTPM 并请求一个“quote”——一个包含当前 PCR 值和该 nonce 的[数字签名](@entry_id:269311)声明。v[TPM](@entry_id:170576) 用一个特殊的证明密钥 (AK) 签署这个 quote，该密钥对于该 vTPM 实例是唯一的，并与主机的物理硬件有加密联系。VM 将这个签名的 quote 发回给您。您验证签名，检查 nonce 是否与您发送的匹配（证明新鲜性），并检查 PCR 值。如果它们与已知良好启动的“黄金度量值”匹配，您就拥有了 VM 完整性的加密证明。只有到那时，您才会向它释放您的机密（如磁盘加密密钥）[@problem_id:3689858]。

[信任链](@entry_id:747264)也不仅仅用于启动。它可以是一个活的实体。想象一台需要 7x24 小时运行的服务器。为了应用一个关键的安全补丁而将其停机重启是不可行的。这就是内核实时修补，或称“热修补”发挥作用的地方。运行中内核内的一个特殊机制可以将其自身的代码在内存中应用补丁。但这怎么能在不破坏启动时建立的信任的情况下完成呢？答案是扩展[信任链](@entry_id:747264)。修补机制本身必须是受信任内核的一部分。它收到的任何补丁都必须由[操作系统](@entry_id:752937)供应商进行[数字签名](@entry_id:269311)。最重要的是，当补丁被应用时，其加密哈希必须被度量并扩展到一个专用的 [TPM](@entry_id:170576) PCR 中。系统的经证明状态现在反映了其新的、已打补丁的现实。即使系统正在运行，[信任链](@entry_id:747264)也一环一环地增长了 [@problem_id:3679581]。

最后，我们必须问：这个模型有极限吗？如果攻击发生在任何一行代码被签名之前呢？考虑软件供应链。一个对手攻破了[操作系统](@entry_id:752937)供应商使用的*编译器*。被投毒的编译器秘密地向它构建的内核中注入了一个后门。供应商在不知情的情况下，用他们的官方密钥签署了这个带后门的内核。最终的软件通过了[安全启动](@entry_id:754616)。它的哈希值与官方清单匹配，所以它通过了[度量启动](@entry_id:751820)证明。整个[信任链](@entry_id:747264)似乎完好无损，但系统从一开始就从根本上被攻破了。

这是现代安全的前沿。解决方案要求将[信任链](@entry_id:747264)进一步向后延伸，进入开发过程本身。一个强大的想法是**可复现构建**，即不同的团队使用不同的编译器在不同的基础设施上构建相同的源代码。如果他们都产生了逐比特相同的二进制文件，我们就可以高度确信工具链没有被篡改。另一个是创建详细的、签名的**来源证明**（如 SLSA 或 in-toto），它们构成了整个构建过程的加密收据，包括所用编译器的哈希值。远程验证者届时不仅会要求证明正在运行的是哪个内核，还会要求证明*它是如何被构建的*。这将[可信计算基](@entry_id:756201)的概念从单个机器推向了软件创建本身的[分布](@entry_id:182848)式、协作过程 [@problem_id:3679558]。

从在您的笔记本电脑上验证一个[引导加载程序](@entry_id:746922)的简单行为，到确保全球软件供应链的完整性，[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)的原则为我们推理信任问题提供了一种统一且用途惊人广泛的语法。它证明了从一个简单、坚实的基础开始，然后一环一环地小心构建一条能够保障我们数字世界的链条的力量。