## 引言
当计算机执行程序时，它不断地做一个根本性的决定：应该按什么顺序来完成各项任务？对于大多数程序员来说，在函数运行前对所有参数进行求值的方法似乎是不言而喻的。这种“立即计算”的哲学，被称为严格求值，是许多流行语言的默认设置，并因其简单和直接而备受推崇。然而，这并非唯一的途径，其看似显而易见的逻辑背后隐藏着关乎性能、安全性和表达能力的权衡。一个悬而未决的问题是，[延迟计算](@entry_id:755964)，或者说“惰性”，是否能带来显著的优势。

本文深入探讨了严格与非严格求值策略之间的关键选择，揭示其作为计算机科学的一项核心原则。我们将探究这一项设计决策如何塑造了编程语言的本质及其能力。第一章“原理与机制”将剖析严格（及早）求值及其非严格对应物（如短路求值和完全[惰性求值](@entry_id:751191)）的内部工作方式，解释它们如何处理副作用、错误乃至无穷的概念。随后的“应用与跨学科联系”一章将理论与实践相结合，展示这些求值策略在从交互式用户界面、高性能计算到[编译器设计](@entry_id:271989)和数字信息安[全等](@entry_id:273198)领域中的关键作用。

## 原理与机制

要理解计算机如何将程序的抽象符号变为现实，我们必须首先领会一个出乎意料的深刻问题：应该按什么顺序来完成各项任务？当你看到像 $(2+3) \times (4+5)$ 这样的表达式时，你的思维很可能会遵循一条熟悉的、直接的路径。你先计算 $2+3=5$，然后计算 $4+5=9$，最后才将结果相乘得到 $45$。这种“先算出参数”的方法看起来如此自然、如此显而易见，以至于我们甚至可能不认为它是一种选择。在编程语言的世界里，这就是**严格求值**的哲学。

### 及早之路：严格求值

**严格求值**（Strict evaluation），也称为**及早求值**（eager evaluation），是 C、Java 和 Python 等大多数编程语言的主力。其原则简单而直接：在执行任何操作之前，完全求值其所有操作数。当你调用一个函数时，计算机首先会勤奋地计算你传递给它的每一个参数的最终值。只有在这些准备工作完成后，函数本身才开始执行，接收这些完成的值作为其输入。这就是为什么最常见的函数[参数传递机制](@entry_id:753160)被称为**[传值调用](@entry_id:753240)**（call-by-value）；函数接收的是参数的*值*，而不是产生该值的表达式。

这种方法具有简单和可预测的优点。事件的顺序是直截了当的，对于许多数学和逻辑任务来说，它非常高效。它反映了我们学习算术和代数的方式。但正如我们将看到的，这条直接的道路并非唯一途径，在计算这个丰富而有时充满风险的领域，它并不总是最安全或最强大的。

### 延迟之美：非严格求值

让我们考虑一个简单的[布尔表达式](@entry_id:262805)：`A  B`。我们从基本逻辑中知道，只有当 `A` 和 `B` 都为真时，该表达式才为真。如果你对 `A` 求值后发现它为假，一个念头应该会立刻出现在你的脑海里：“我完成了！”整个表达式必定为假，而 `B` 的值完全无关紧要。为什么要浪费时间或计算能量去计算它呢？

这种将工作推迟到被证明是必要时才做的冲动，是**非严格求值**的核心。你最常遇到它的地方，是在大多数现代语言中[逻辑运算符](@entry_id:142505)的**短路求值**（short-circuit evaluation）。这不仅仅是一个小的优化；它可能是保证正确性的关键特性。

想象一下，一个程序员编写一段代码来检查数字 `b` 是否大于数字 `a`，但他知道 `a` 可能为零。他可能会写：`(a != 0)  (b/a > 1)`。在严格求值下，计算机会勇往直前，在应用 `` 运算符之前，同时对 `(a != 0)` 和 `(b/a > 1)` 进行求值。如果 `a` 恰好为零，它会尝试计算 `b/0`，这个操作会导致灾难性的错误——除零异常——并使程序崩溃。

短路求值，我们对非严格性的初次体验，拯救了局面。它首先对 `(a != 0)` 求值。如果 `a` 确实为零，这部分就是假，`` 的规则允许系统立即为整个表达式返回 `false`，*而根本不会尝试危险的除法*。表达式的第二部分从未被触及。这种简单的延迟行为变成了一个强大的安全保障，让我们能够编写出优雅处理棘手条件的健壮代码 [@problem_id:3677598]。求值策略不仅仅关乎性能；它是语言语义的一个基本组成部分，影响着哪些程序可以安全地编写。

### 当世界改变时：副作用与顺序

当我们的计算不仅仅是产生值时，严格求值和非严格求值之间的差异就变得尤为明显。许多函数具有**副作用**（side effects）：它们改变系统状态、向屏幕打印信息、更新数据库或发送网络请求。事情发生的*顺序*突然变得至关重要。

考虑一个假设的程序，其中有两个函数 `f()` 和 `g()`，它们会修改一些全局变量 `c` 和 `t`。让我们在初始状态为 $x=4, y=0$ 的情况下分析表达式 `((x  y)  f()) || g()`。

对于严格（及早）求值器，过程是毫不留情的。它必须找出每个子表达式的值。它会先求值 `(x  y)`（为假），然后调用 `f()`（改变 `c` 和 `t`），再调用 `g()`（再次改变 `c` 和 `t`），最后才组合布尔结果。

而对于非严格（短路）求值器，过程则更为谨慎。
1. 它首先查看 `||`（或）运算符。为了求值 `A || B`，它首先求值 `A`，即表达式 `(x  y)  f()`。
2. 为了求值 `(x  y)  f()`，它首先求值 `x  y`。当 $x=4$ 且 $y=0$ 时，结果为假。
3. 因为 `` 的左侧为假，这个内部表达式短路求值为假。关键在于，`f()` **永远不会被调用**。
4. 现在，回到主 `||` 表达式。左侧部分结果为假，所以求值器*必须*接着求值右侧部分 `g()`。函数 `g()` 被调用。

在这两种情况下，变量 `c` 和 `t` 的最[终值](@entry_id:141018)将完全不同，因为 `f()` 在一种情况下被调用，而在另一种情况下则没有 [@problem_id:3677668]。这揭示了一个深刻的观点：改变求值策略可以改变程序的可观察行为。我们想当然的一些简单代数定律，比如或运算的交换律（$A || B$ 与 $B || A$ 相同），在 `A` 和 `B` 具有副作用时便不再成立。交换它们会改变副作用可能发生的顺序，或者哪些副作用会发生 [@problem_id:3232675]。

### 驯服无穷：[惰性求值](@entry_id:751191)的力量

到目前为止，非严格性似乎只是优化和安全方面的一个聪明技巧。但当我们将其推向逻辑极限时，它真正的力量才得以显现。如果我们想处理一个实际上是无穷的概念，该怎么办？

考虑无穷的[斐波那契数列](@entry_id:272223)：$\langle 0, 1, 1, 2, 3, 5, \dots \rangle$。我们能在计算机中表示它吗？严格求值器会束手无策。如果我们自引用地定义这个[数据流](@entry_id:748201)（每个元素是前两个元素的和），严格求值的语言会试图在开始使用这个流之前计算出*所有*的数字。它会进入一个无限循环，试图完成一个无限的任务——这是一种徒劳的努力 [@problem_id:3649646]。

这正是成熟的非严格策略——**[惰性求值](@entry_id:751191)**（lazy evaluation）——大放异彩之处。[惰性求值](@entry_id:751191)主张：“除非你绝对需要某个值，否则我不会计算任何东西。”整个无穷的[斐波那契数列](@entry_id:272223)可以作为一个“承诺”（promise）存在，或者计算机科学家所说的**悬算**（thunk）——一个等待执行的暂停计算。当你请求第一个元素时，它只计算那一个。当你请求第十个时，它只计算到达第十个所必需的元素。这使我们能够优雅地表示和操作无限或非常大的[数据结构](@entry_id:262134)，只需为我们实际使用的部分支付计算成本。

这种“按需付费”的模型可以扩展到任何参数，而不仅仅是[数据结构](@entry_id:262134)的一部分。考虑一个不使用其参数的函数，比如 `(λx. 1)`。这个函数总是返回 1，无论 `x` 是什么。如果我们用一个有问题的参数来调用它，比如 `(λx. 1)(throw exception)`，会发生什么？
- **严格**求值的语言必须先对参数求值。它运行 `throw exception`，程序因错误而停止。它永远不会运行函数本身。
- **惰性**求值的语言看到函数体 `1` 从未提及 `x`。它断定自己不需要参数的值，因此从不求值它。`throw exception` 的代码永远不会被运行，程序愉快地返回 1 [@problem_id:3649715]。

[惰性求值](@entry_id:751191)并非没有其微妙之处。最简单的非严格求值形式，称为**[传名调用](@entry_id:753236)**（call-by-name），每次使用参数时都会重新对悬算求值。如果一个参数被使用十次，它就会连同所有副作用从头开始重新计算十次。一种更精致、更实用的策略是**按需调用**（call-by-need），这是真正[惰性求值](@entry_id:751191)背后的机制。它相当于“带记忆的[传名调用](@entry_id:753236)”。当第一次需要一个参数时，它的悬算被求值，结果被存储，或者说被*[记忆化](@entry_id:634518)*（memoized）。在所有后续使用中，都会立即返回存储的结果。这避免了重复工作，同时保留了“仅在需要时求值”的原则，将一个潜在的指数级计算转变为线性计算，使[惰性求值](@entry_id:751191)成为一个实用的工具 [@problem_id:3661477]。

### 编译器的技艺：选择正确的策略

那么，严格求值和[惰性求值](@entry_id:751191)哪个更好？这就像问锤子是否比螺丝刀更好。它们是用于不同工作的不同工具。严格求值简单，其性能易于推断，对于绝大多数日常编程任务来说是正确的选择。[惰性求值](@entry_id:751191)在抽象、模块化以及处理潜在危险或无限计算方面是一个极其强大的工具，但它带来了管理悬算的开销，并可能使对性能和副作用的推理变得更加复杂。

现代计算机科学的魅力在于，我们不必总是做出全局性的选择。一个复杂的编译器可以采用多种策略的组合。它可以分析一段代码并自问：“在这里及早求值安全吗？”对于像 `A  B` 这样的表达式，如果编译器能够证明子表达式 `B` 是**纯粹的**（没有副作用）且**全量的**（不会导致错误或永远运行），它可能会选择将惰性的短路运算符转换为更高效的及早求值运算符。这种分析-综合的方法让编译器能够两全其美：在需要时获得[惰性求值](@entry_id:751191)的安全性，在可能时获得严格求值的原始速度 [@problem_id:3621439]。

及早与惰性之间的这种张力甚至出现在编译器自身的设计中。编译器是否应该一有机会就及早执行像**[常量折叠](@entry_id:747743)**（例如，用 `4` 替换 `2+2`）这样的优化？还是应该惰性一些，等到检查完错误之后再做？如果在表达式 `x / (2-2)` 中，它及早地将 `(2-2)` 折叠为 `0`，错误消息可能只会说“除以零”。而一种更惰性的方法，会首先在原始代码上检查错误，可以生成一个更有帮助的消息：“除以零，因为表达式 `(2-2)` 的值为零” [@problem_id:3641113]。

严格求值与[惰性求值](@entry_id:751191)之间的选择是一个根本性的选择，揭示了计算[系统设计](@entry_id:755777)中一个优美且反复出现的主题：立即工作与稍后工作之间的权衡。理解这种权衡不仅仅是理解编译器的技术细节；它关乎欣赏那些指导我们命令机器将逻辑变为现实的深刻而优雅的原则。

