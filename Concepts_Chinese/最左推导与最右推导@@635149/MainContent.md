## 引言
在计算机科学的世界里，机器是如何将一行代码从简单的字符串转换为一组可执行指令的呢？答案在于一个被称为**推导**的基础过程。在[形式文法](@entry_id:273416)的约束下，推导是一个从抽象概念生成结构化句子的分步过程。这个过程是计算机解析、理解和解释程序设计语言及其他[形式系统](@entry_id:634057)的核心。

然而，对于任何给定的字符串，可能存在多条路径——即多个规则应用序列——能够得到最终结果。这就引出了一个关键问题：这些不同的路径重要吗？本文将通过聚焦于两种规范且至关重要的策略来解决这个问题：**最左推导和最右推导**。

我们将首先探索这些推导的原理和机制，研究它们如何与分析树的底层结构相关联，以及不同的推导方式如何导致关键的[歧义](@entry_id:276744)性问题。随后，我们将通过研究其应用和跨学科联系来连接理论与实践，揭示这些抽象概念如何成为编译器的基石，影响程序设计语言的设计，甚至影响计算机硬件的性能。

## 原理与机制

想象你是一位剧作家。你有一套语言的“文法”——即一组关于什么构成有效句子的规则。你从一个抽象的想法，一个“句子”开始，然后一步步地用更具体的短语替换这些抽象想法，再用实际的词语替换那些短语，直到你得到最终的对话台词。这个从单一抽象概念到最终具体符号串的转换过程，就是我们所说的**推导**。

### 剧作家与剧本：文法和推导

在计算机科学和[形式语言](@entry_id:265110)的世界里，我们的“剧作家”是一个称为**分析器**的系统，而它遵循的剧本则是**[上下文无关文法](@entry_id:266529) (CFG)**。这种文法只是一套产生式规则。例如，像 $E \rightarrow E + T$ 这样的规则表示“一个表达式（$E$）可以由一个表达式（$E$）、一个加号和一个项（$T$）构成。”

像 $E$（表达式）或 $T$（项）这样的抽象概念符号被称为**非终结符**。它们是我们剧中尚未被完全定义的角色。而像 $+$、* 或 `id`（一个标识符）这样页面上最终、具体的字符，则被称为**终结符**。它们是最终说出的话语。

那么，一个推导就是从一个单一的起始非终结符（如 $E$）生成一个终结符串所经过的步骤序列。在每一步中，我们在当前正在处理的字符串（称为**句型**）中选择一个非终结符，并用其某个产生式规则的右侧来替换它。

### 一个故事，两种讲述：最左推导与最右推导

假设我们正在处理的剧本是句型 $E + T$。我们有两个非终结符。接下来我们应该展开哪一个？这个选择导致了不同的“讲述”风格，即推导策略。尽管有许多方式可以继续，但有两种因其规范性和实用性而尤为重要。

**最左推导**是一种在每一步总是展开最左侧可用非终结符的策略。这是一个有条不紊、可预测的过程，就像阅读一个句子并展开你遇到的第一个抽象概念一样。

顾名思义，**最右推导**则相反：在每一步，我们总是展开最右侧可用的非终结符。从人类阅读的角度来看，这可能感觉不太自然，但正如我们将看到的，它拥有一种对许多编译器工作方式至关重要的神秘力量。

对于一个给定的最终字符串，最左推导和最右推导将由不同的中间句型序列组成。考虑一个文法，其规则为 $S \to AB$, $A \to aA \mid \epsilon$, 以及 $B \to bB \mid \epsilon$，其中 $\epsilon$ 代表空字符串。要推导字符串 `ab`，最左推导会在开始展开 $B$ 之前，将非终结符 $A$ 完全解析为终结符。相反，最右推导将首先展开 $B$ [@problem_id:3637111]。它们是通往同一目的地的两条不同路径。

这就引出了一个绝妙的问题：如果路径不同，那么什么是不变的呢？

### 底层结构：分析树

那个[不变量](@entry_id:148850)，即最左推导、最右推导（以及许多其他推导！）共同构建的东西，就是**分析树**。分析树是文法为字符串规定的真正“建筑师蓝图”。它是一个揭示底层含义的静态层次结构。而推导，仅仅是*构建*这棵树的一个动态、线性的过程。

可以把它想象成盖房子。分析树是最终建成的房屋。推导是施工计划。你可以有一个计划，先建好整个地基，然后建一楼，再建二楼（就像“广度优先”推导）。或者，你可以有一个计划，在开始建东翼之前，就把西翼从地基到屋顶完全建好（就像“深度优先”推导）。

最左推导和最右推导是两种特定的、规范的、深度优先的施工计划。事实上，对于任何给定的分析树，你都可以通过对树进行**[前序遍历](@entry_id:263452)**（访问一个节点，然后从左到右递归地访问其子节点）来重构其唯一的最左推导。相应地，其唯一的最右推导可以通过对树进行**逆[后序遍历](@entry_id:273478)**来重构 [@problem_id:3637090]。即使施工步骤的顺序不同，最终的房屋也是一样的。一棵分析树对应着一个唯一的最左推导和一个唯一的最右推导。

### 当剧本有缺陷时：歧义性的幽灵

这就把我们带到了一个关键点。如果一个字符串能够以产生两个或多个*根本不同*的分析树的方式被构建，会怎么样？这种情况被称为**[歧义](@entry_id:276744)性**，对于一门程序设计语言来说，这是一个灾难性的缺陷。为什么？因为结构决定意义。

让我们来看一个经典的算术[歧义](@entry_id:276744)性文法：$E \rightarrow E+E \mid E*E \mid id$。字符串 `id+id*id` 是什么意思？对人类来说，由于我们学过的[运算符优先级](@entry_id:168687)规则，它可能意味着 `id + (id*id)`。但这个文法并不包含那条规则！遵循此文法的机器没有任何偏好。

我们可以为这个字符串找到两个不同的最左推导，这一事实揭示了[歧义](@entry_id:276744)性 [@problem_id:1360025]。一个推导对应于组合 `(id+id)*id` 的分析树，而另一个则对应于 `id+(id*id)` 的树。这不仅仅是讲述故事的不同方式；它们是两个结果截然不同的故事。

这个问题以多种形式出现。一个简单的列表文法 $L \rightarrow L,L \mid id$ 对于 `id,id,id` 是有[歧义](@entry_id:276744)的。它应该被组合成 `(id,id),id` 还是 `id,(id,id)`？[@problem_id:1362643] 一个更著名也更微妙的例子是许多程序设计语言中的“悬空 else”歧义 [@problem_id:1362665]。在像 `if c1 then if c2 then s1 else s2` 这样的语句中，`else` 是与第一个 `if` 配对还是第二个？一个有[歧义](@entry_id:276744)的文法允许两种解释，导致两个行为不同但看起来完全相同的程序。一个无[歧义](@entry_id:276744)的文法对于确保每条语句都有且仅有一个意义至关重要。

### 驾驭推导：工作中的分析器

计算机实际上是如何利用这些思想来理解代码的呢？它们使用称为分析器的算法，这些算法通常分为两大阵营。

#### 自顶向下分析：预测者
自顶向下分析器试图从根节点向下构建分析树，实际上是在尝试“猜测”正确的推导。这种方法的一个简单版本是**递归下降分析器**，其中每个非终结符都是一个函数，试图将其产生式规则与输入相匹配。

然而，这种直观的方法有一个明显的弱点：**[左递归](@entry_id:751232)**。再次考虑我们的表达式文法：$E \rightarrow E + T \mid \dots$。为了分析一个 $E$，第一条规则说“寻找一个 $E$”。一个简单的分析器会从自身内部调用用于 $E$ 的函数，而不消耗任何输入，从而导致无限循环 [@problem_id:3637115]。这就是为什么用于自顶向下分析器的文法通常写成右递归风格（例如，对于列表，$L \to E, L$），而不是[左递归](@entry_id:751232)风格（$L \to L, E$），尽管两者生成相同的语言并产生同样深度的分析树 [@problem_id:3637112]。

#### 自底向上分析：侦探
这正是最右推导展现其隐藏天才之处。**自底向上分析器**像侦探一样工作。它从证据——输入字符串——开始，然后向后工作，推断出导致这个结果的故事。它反复寻找与某个产生式右部相匹配的子串（称为“句柄”），并将其规约为相应的非终结符，直到最终到达开始符号。

这里存在着一种美妙的对称性：这个规约过程恰好是**最右推导的逆过程**！[@problem_id:3637102] [@problem_id:3624916] 一个为 `id+id*id` 构建分析树的自底向上分析器，实际上是在从字符串回溯到开始符号 $E$ 的过程中，逆向追溯了一个最右推导的步骤。这种强大的方法，体现在像 LR 分析这样的算法中，对[左递归](@entry_id:751232)文法毫无困难，并且是许多现代编译器的基础 [@problem_id:3637115]。

### 推导的交响曲：更深入的探讨

我们一直关注于规范的最左推导和最右推导。但还有其他推导吗？当然有。对于任何给定的分析树，只要遵守一个简单规则：父节点必须总是在其任何子节点之前被展开，那么任何产生式应用序列都是一个有效的“无限制”推导。

这开启了一个迷人的组合学视角。想象一个分析树，其根规则是 $S \to AB$。这个应用必须最先发生。推导的其余部分由 $A$ 下方的子树所需的所有应用和 $B$ 下方的子树所需的所有应用组成。假设 $A$ 子树需要 $|T_A|$ 步，$B$ 子树需要 $|T_B|$ 步。

$A$ 子树内的步骤必须保持其相对顺序，$B$ 子树内的步骤也一样。但是这两个步骤序列可以以任何方式交错！有多少种方法可以合并这两个有序序列呢？这是一个经典的组合问题。在总共 $|T_A| + |T_B|$ 个推导“槽位”中，我们需要为 $A$ 的步骤选择其中的 $|T_A|$ 个。实现这一目标的方式数量由[二项式系数](@entry_id:261706)给出：

$$ \binom{|T_A| + |T_B|}{|T_A|} = \frac{(|T_A| + |T_B|)!}{|T_A|! |T_B|!} $$

这个思想可以优美地推广。如果一个规则有多个非终结符，交错它们子推导的方式数量由[多项式系数](@entry_id:262287)给出 [@problem_id:3637105]。

这揭示了一种深刻的统一性。一个单一、静态、层次化的分析树——即一个字符串的意义——对应着一整套可以构建它的动态、线性推导的交响曲。最左推导和最右推导只是指挥这场交响乐的两份特定且非常有用的乐谱，一个深受自顶向下预测者的喜爱，另一个则为自底向上侦探所青睐。每一种都揭示了同一底层真理的不同侧面。

