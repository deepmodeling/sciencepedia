## 引言
在复杂的计算世界中，我们如何强制执行秩序并建立信任？安全的基本问题始终是：谁被允许对哪些资源做什么？即使对于一个中等复杂的系统，回答这个问题也可能令人望而生畏，但计算机科学提供了一种优雅而强大的抽象来推理此问题：**访问矩阵**。这个简单的网格将活动实体（主体）映射到受保护的资源（客体）以及特定的权限（权利），构成了数字系统中保护的通用蓝图。

尽管这个概念很简单，但真正的挑战在于将这一抽象付诸实践。我们如何高效、安全地实现这个矩阵？不同实现哲学之间的权衡是什么？本文旨在通过全面探讨访问[矩阵模型](@entry_id:148799)来弥补这一知识空白。首先，在“原理与机制”一章中，我们将剖析该模型的核心组件，比较两种主流实现策略——[访问控制](@entry_id:746212)列表和能力——并分析它们对权限委托、撤销以及对经典漏洞的易感性等关键动态的深远影响。然后，在“应用与跨学科联系”一章中，我们将看到这些原理的实际应用，揭示访问矩阵如何支撑从[操作系统内核](@entry_id:752950)和云虚拟化到智能家居和社交网络等一切事物的安全，为驯服数字复杂性提供了一种统一的语言。

## 原理与机制

### 宏伟构想：权力矩阵

我们如何推理安全性？在物理学世界中，我们常常从一个宏大、简化的思想——比如[守恒定律](@entry_id:269268)——开始，然后探索其后果。在计算机保护的世界里，我们也可以这样做。这个宏伟的构想惊人地简单：想象一个巨大的网格、一张表格，或者我们称之为**访问矩阵**。

在这个矩阵的行上，我们列出系统中的所有活动实体——“谁”。这些可以是像 Alice 和 Bob 这样的用户，甚至是代表他们运行的程序。我们称这些为**主体 (subjects)**。

在列上，我们列出所有需要保护的东西——“什么”。这些可以是文件、打印机，甚至其他程序。我们称这些为**客体 (objects)**。

矩阵的单元格里放的是什么呢？是“如何做”。每个单元格，比如在 Alice 的行和“Budget.xlsx”的列的交点处，包含一个特定操作的列表，即 Alice 被允许对该文件执行的**权限 (rights)**。她能读取它吗？写入它吗？执行它吗？矩阵持有所有答案。如果 Alice 对预算文件有 `read` 权限，那么条目 $M[\text{Alice}, \text{Budget.xlsx}]$ 将包含 $\{r\}$。如果 Bob 没有任何权限，他对应的条目将为空，即 $\varnothing$。

这个**访问矩阵**是我们的通用模型。它是一个系统完整保护状态的完美、抽象的快照。无论系统多么复杂，原则上我们都可以用这个简单、优雅的结构来描述其安全策略。然而，真正的乐趣始于我们试图将这个美丽的抽象付诸实践之时。

### 将矩阵付诸实践：两种哲学

将白板上的矩阵构建到[操作系统](@entry_id:752937)结构中是另一回事。事实证明，主要有两种“切分”矩阵的方式，这两种方法代表了两种根本不同的安全哲学。

#### 客体作为守门人：[访问控制](@entry_id:746212)列表

实现矩阵的一种方法是垂直地、逐列地切分它。对于每个客体，我们创建一个列表，其中包含所有对其拥有权限的主体。这个附加在客体自身的列表被称为**[访问控制列表 (ACL)](@entry_id:746213)**。

想象一个专属俱乐部。俱乐部本身（客体）门口有一个保镖，手里拿着一份名单（ACL）。当你（主体）试图进入时，保镖会核对名单上的你的名字，看你是否被允许进入。权力掌握在客体的守门人手中。大多数我们熟悉的[操作系统](@entry_id:752937)，如 Windows 和类 Unix 系统，都严重依赖这种哲学。当你列出文件属性时看到的权限，本质上就是一个 ACL。

#### 主体作为持钥人：能力列表

另一种方法是水平地、逐行地切分矩阵。对于每个主体，我们创建一个它能访问的所有客体的列表。但这不仅仅是一个简单的列表；它是一个特殊、不可伪造的令牌集合，称为**能力 (capabilities)**。

一个**能力 (capability)** 就像一把钥匙。它是一个单一、统一的令牌，指明了一个客体以及你对其拥有的特定权限。为了让 Alice 读取预算文件，她需要拥有一个能力，可以表示为一个元组：$(o_{\text{budget}}, \{r\})$，其中 $o_{\text{budget}}$ 是该文件的唯一、秘密的标识符。

在这种模型中，主体是持钥人。要进入俱乐部，你不用告诉保镖你的名字，你只需出示正确的钥匙。权力由主体持有。这种方法在主流桌面[操作系统](@entry_id:752937)中不太常见，但却是许多安全研究系统和微内核的基础。

乍一看，ACL（列）和能力列表（行）似乎是同一枚硬币的两面——只是存储我们主矩阵中相同信息的不同方式。对于一个静态、不变的系统，它们是等价的。但系统不是静态的。一旦权限开始变化，这两种哲学之间深刻的动态差异就变得清晰起来。

### 委托与撤销之舞

当权限被传来传去时，一个安全系统的真正特性就显现出来了。让我们来探讨一下当我们试图授予或撤销权限时会发生什么。

想象一个简单的策略：一个能读取文件的主体也可以将该读取权限授予他人。我们从只有一个主体 $s_1$ 拥有读取一个机密文件 $o^\star$ 的权限开始。随着时间的推移会发生什么？$s_1$ 可以将权限授予 $s_2$。现在 $s_1$ 和 $s_2$ 都可以授予该权限。他们又将其授予 $s_3$。很快，这个权限就像瘟疫一样蔓延，直到系统中的每个主体都能读取该文件。我们最初的保密目标完全丧失。这个简单的思想实验表明，不受控制的委托是一个严重的威胁 [@problem_id:3674064]。

我们的两种哲学如何处理这个问题呢？在 ACL 系统中，委托通常是一件受控的事情。要给朋友授予访问权限，你通常不能自己编辑 ACL。你需要一个特殊的管理权限——我们称之为“授予”或“复制”权限——来修改 ACL。如果一个策略要给非所有者一个复制特权（比如一个 $x^{\star}$ 权限，允许他们将 $x$ 授予他人），这可能会创建一个绕过所有者控制的意外委托链。一个健壮的策略会确保只有客体的所有者才持有如此强大的管理权限 [@problem_id:3674085]。

在 ACL 系统中，撤销——收回权限——非常直接。所有者只需告诉保镖把一个名字从名单上划掉。这个变更是即时且绝对的。

在能力系统中，情况则截然不同。能力的天性就像信息一样：它可以被复制。如果 Alice 有一个能力（一把钥匙），她通常可以复制一份并交给 Bob。这非常灵活和强大，但也带来了一个巨大的难题：**撤销**。如果 Alice 后来决定 Bob 不应该再有访问权限，她能做什么呢？Bob 已经有了自己的钥匙副本。更糟糕的是，Bob 可能已经为他的朋友 Carol 复制了一份。撤销访问权限意味着找到并销毁该能力的每一个副本，这在一个复杂的系统中，如果不构建复杂（且昂贵）的间接层，几乎是一项不可能完成的任务 [@problem_id:3674014]。

灵活委托和有效撤销之间的这种根本性张力，是安全[系统设计](@entry_id:755777)中的一个核心主题。

### 权力的阿喀琉斯之踵：困惑的代理人问题

最著名和最微妙的安全漏洞之一是**困惑的代理人问题 (confused deputy problem)**。想象一下[操作系统](@entry_id:752937)中的一个强大服务，比如一个备份工具。这个工具以高权限运行，允许它读取系统上的任何文件以进行备份。我们称这个服务为我们的“代理人”。现在，一个低权限用户——一个“客户端”——请求代理人备份一个文件，但他们没有提供自己文件的路径，而是提供了系统密码文件的路径。

这个代理人有点迟钝，看到了这个请求。它有权限读取任何文件，所以当它被要求读取密码文件时，系统会说：“当然，你有权限。” 代理人读取文件并尽职地将数据交还给恶意客户端。代理人被迷惑而滥用了它的权力。

这个问题是具有**环境权限 (ambient authority)** 系统的典型症状。备份服务拥有其权限仅仅是因为它*是谁*。这在基于 ACL 的系统中很典型，其中该服务的用户账户会出现在每个文件的 ACL 上 [@problem_id:3674116]。

这就是能力哲学的闪光之处。在一个设计良好的能力系统中，代理人没有环境权限。它以最小权限运行。客户端要备份一个文件，必须传递给代理人一个针对该文件的能力——一把特定的钥匙。代理人随后可以使用这把钥匙，也只能用这把钥匙，来执行备份。如果一个恶意客户端想要密码文件，他们需要提供一个针对该文件的能力。但他们没有！所以他们无法欺骗代理人。攻击被当场阻止。这种对**[最小权限原则](@entry_id:753740) (Principle of Least Privilege)**——即只给予程序完成当前任务所必需的精确权限——的完美执行，是支持基于能力的设计的最有说服力的论点之一 [@problem_id:3674116]。

构建这样一个系统的强大方法是通过**域分离 (domain separation)**。例如，一个需要读取机密配置文件并同时写入公共日志文件的守护进程，可以被拆分成两个更小的、隔离的域。一个域 $D_c$ 只持有读取配置文件的能力。另一个域 $D_l$ 自身没有任何能力，但接受来自客户端的请求，客户端必须传递给它一个针对他们想要写入的特定日志文件的能力。这样，读取配置文件的敏感权限就永远不会暴露给面向客户端的程序部分，从而大大降低了被迷惑的风险 [@problem_id:3674016]。

### 变形：域与[权限提升](@entry_id:753756)

到目前为止，我们都将主体视为静态实体。但实际上，一个程序所需的权限在其生命周期中是可能变化的。这就引出了**[保护域](@entry_id:753821) (protection domain)** 的概念，它就是一个主体在任何给定时刻所拥有的权限集合——也就是访问矩阵中该主体的当前行。

有时，一个程序需要临时获得更多权力。这被称为**域切换 (domain switching)**。这就像一个平民穿上警官的制服；在短时间内，他们可以行使随之而来的权力。在实际应用中最著名的例子是类 Unix 系统中的 **`[setuid](@entry_id:754715)`** (Set User ID) 机制。一个普通用户可以执行一个特殊程序，在该程序运行期间，进程会获得程序所有者的身份和权限，而所有者可能是拥有最高权力的 'root' 管理员。

这种临时的权力获取被称为**权限放大 (rights amplification)**。在我们的访问[矩阵模型](@entry_id:148799)中，我们可以将其表示为一个特殊规则。如果域 $D_u$ 中的一个用户执行了由用户 $v$ 拥有的 `[setuid](@entry_id:754715)` 程序 $P$，系统允许该进程从域 $D_u$ 切换到域 $D_v$。在 $D_v$ 中运行时，该进程可以做任何 $v$ 能做的事情，比如读取一个之前对 $u$ 不可访问的文件 $F$ [@problem_id:3674101]。

这个机制可以用惊人的精度来建模。POSIX 中文件的权限模式，比如八进制代码 `6750`，就是一个用于域切换的紧凑配方。这个代码指定了 `[setuid](@entry_id:754715)` 和 `setgid` 位，以及所有者和组的读/写/执行权限。当来自一个域的用户执行这个文件时，这些位精确地决定了进程将进入哪个新域——拥有新的有效用户 ID 和组 ID [@problem_id:3674088]。

当然，危险在于临时的权限放大可能被利用来创造一个永久的权限放大。一个进程在临时以 'root' 身份运行时，可以编辑访问矩阵本身——例如，通过将原始用户添加到一个特权组中。即使在 `[setuid](@entry_id:754715)` 程序退出、域切换回来之后，那个新的、永久的权限仍然存在 [@problem_id:3674101]。这就是许多现实世界中[权限提升](@entry_id:753756)攻击的本质。

### 魔鬼在细节中：实现挑战

一个漂亮的 模型是不够的。整个系统的完整性取决于其无懈可击的实现。其中有两个特别的挑战尤为突出。

#### 不可伪造性与信任问题
如果我们选择能力哲学，就必须确保我们的“钥匙”是**不可伪造的 (unforgeable)**。如果一个能力只是存储在程序内存中的一对数字 $(o, \rho)$，那么如何阻止程序更改权限部分 $\rho$呢？一个拥有 `read` 能力的程序可以简单地篡改它，创造出一个 `{read, write}` 的能力，从而立即提升自己的权限。依赖于客体标识符“不可猜测”并非一种防御手段；程序已经知道了有效的客体标识符 [@problem_id:3674067]。

对此有两个稳健的解决方案。第一种是完全不信任用户程序。内核将所有真正的能力保存在自己的受保护内存中，只给用户程序不透明的句柄——像文件描述符这样的无意义数字。当程序想要使用一个能力时，它传递这个句柄，内核会在其秘密表中查找真实的、未被篡改的能力。第二种解决方案使用[密码学](@entry_id:139166)。内核可以通过附加一个[密码学](@entry_id:139166)的**消息认证码 (MAC)** 来“封装”一个存储在用户空间的能力，该 MAC 使用只有内核知道的密钥计算。如果用户程序修改了能力，MAC 将不再匹配，内核会将其作为伪造品拒绝 [@problem_id:3674067]。

#### 原子性与[时间问题](@entry_id:202825)
第二个挑战是时间本身。访问矩阵代表一个快照，但系统是一部电影。如果在操作中途规则发生变化会怎样？这会导致一个经典的竞争条件，称为**[检查时-使用时](@entry_id:756030) (Time-Of-Check-To-Time-Of-Use, [TOCTTOU](@entry_id:756030))**。

想象一下，内核检查 Alice 是否有权限写入一个文件（“检查”）。检查通过了。但在内核实际执行写入（“使用”）之前的微秒内，管理员撤销了 Alice 的权限。如果内核继续执行写入，它就基于过时的信息采取了行动，违反了安全策略。

这在具有动态策略的系统中是一个特别棘手的问题，例如组成员身份随时可能改变。为了解决它，“检查”和“使用”必须被绑定在一个**原子 (atomic)** 操作中——一个看起来是瞬时发生、不可能被中断的操作。实现这一点的一种方法是使用[版本控制](@entry_id:264682)。内核可以为策略的每一部分（如 ACL 或用户的组列表）关联一个版本号，或称为**代数计数器 (generation counter)**。当它检查一个权限时，它会记录当前的版本号。在使用该权限之前，它会重新检查版本号。如果版本号已更改，意味着策略已被修改，操作必须被中止或重新授权 [@problem_id:3674083]。

### 终极前沿：我们能证明一个系统是安全的吗？

这就引出了最后一个深刻的问题。给定一个访问矩阵系统的完整描述及其所有更改权限的规则，我们能否编写一个程序，确切地告诉我们某个给定用户是否有可能获得某个特定的危险权限？这被称为**安全问题 (Safety Problem)**。

如果能有这样一个安全检查器来自动发现我们设计中的安全漏洞，那将是极好的。但是， Harrison, Ruzzo, 和 Ullman 在 20 世纪 70 年代的一项里程碑式成果表明，对于一个通用系统——一个可以创建新主体和新客体的系统——安全问题是**不可判定的 (undecidable)**。它等价于[可计算性理论](@entry_id:149179)中著名的[停机问题](@entry_id:265241) (Halting Problem)。不存在任何单一算法能保证解决所有可能系统中的该问题。我们预测[安全状态](@entry_id:754485)未来的能力从根本上是有限的。

但这里有一个精妙的转折。这个[不可判定性](@entry_id:145973)结果适用于*一般*情况。如果我们对系统加以约束，问题可以再次变得可判定。例如，在一个单调（权限从不被撤销）且主体和客体数量固定有限的系统中，可能状态的总数是有限的。在这种情况下，我们原则上可以遍历所有[可达状态](@entry_id:265999)，并确定其中是否存在危险状态 [@problem_id:3674069]。

这不仅仅是一个理论上的好奇。它教给我们一个关于设计的深刻教训。通过选择更简单、更受约束的保护模型，我们从一个不可判定的混乱世界走向一个具有数学确定性的世界。对安全的追求不仅仅是建造更高的围墙，而是设计出结构如此清晰和简单，以至于我们能够有效地对其进行推理——甚至可能证明它们是安全的系统。

