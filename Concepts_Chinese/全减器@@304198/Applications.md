## 应用与跨学科联系

现在我们已经拆解了[全减器](@article_id:345928)，理解了其内部构造，让我们来做一些更令人兴奋的事情。让我们把它重新组装起来，不仅仅是恢复原样，而是作为更宏伟机器的一部分。在科学中，一个简单概念的真正美妙之处往往不在于事物本身，而在于它让我们能够构建什么。[全减器](@article_id:345928)，这个由逻辑门组成的简陋装置，是催生出广阔计算机械森林的种子。它的应用从最基本的算术运算延伸到现代处理器核心中[算法](@article_id:331821)的复杂运作。

### 从一位到多位：[行波](@article_id:323698)借位减法器

第一个，也是最自然的一步是问：如果我们能做一位数的减法，我们如何做多位数的减法？答案与我们学习手算减法的方式惊人地相似。当我们从92中减去53时，我们从最右边的一列开始：2减3。我们做不到，所以我们向左边的一列“借位”，把9变成8，把2变成12。我们计算 $12 - 3 = 9$。然后我们移到下一列，计算 $8 - 5 = 3$。最终答案是39。

[数字电路](@article_id:332214)可以做完全相同的事情。通过将[全减器](@article_id:345928)级联成一个链条，我们创建了所谓的**行波借位减法器**。第一个减法器处理最低有效位（“个位”）。如果它需要借位，它的`借位输出`信号会传递给链中下一个全减法器的`借位输入`，该减法器处理下一个有效位。这个借位信号就像波纹一样，从一个阶段传播到下一个阶段，完全像一个学生在纸上认真地做一个长减法问题 [@problem_id:1964320]。这种从相同的一位模块构建多位单元的结构优雅性，是数字设计的一个基本原则。

### 对偶的艺术：创建加减法器

在这里，我们发现了整个计算机工程中最巧妙的手法之一。事实证明，我们根本不需要一个独立的减法电路！我们可以“欺骗”一个加法器来为我们做减法。其中的奥秘在于一个叫做**二进制补码**的数学概念。要计算 $A - B$，我们可以转而计算 $A + (B\text{ 的二进制补码})$。一个二进制数 $B$ 的补码是通过将其所有位取反（0变1，1变0，这个操作称为[反码](@article_id:351510)，$\bar{B}$）然后加1得到的。所以，$A - B$ 变成了 $A + \bar{B} + 1$。

我们如何构建一个能做到这一点的电路呢？我们需要一种方法，要么让 $B$ 在加法时保持不变，要么在减法时输出 $\bar{B}$。完成这个任务的完美工具是异或门。一个输入端连接到控制信号 $M$ 的异或门，可以作为一个“条件反相器”：如果 $M=0$，输出就是输入；如果 $M=1$，输出就是*反相*的输入。

现在，我们可以构建一个组合式加减法器。我们取一个标准的[并行加法器](@article_id:345613)，在每个 $B$ 输入端放置一个[异或门](@article_id:342323)，并将它们所有的控制线连接到一个单一的模式信号 $M$ 上。那么二进制补码所需的“+1”呢？我们可以将同一个模式信号 $M$ 直接输入到第一个[全加器](@article_id:357718)的进位输入端！

结果是一个具有双重特性的电路 [@problem_id:1907558] [@problem_id:1915354]：
- 当 $M=0$ 时：[异或门](@article_id:342323)让 $B$ 直接通过，初始进位为0。电路计算 $S = A + B + 0$，也就是加法。
- 当 $M=1$ 时：异或门将 $B$ 反相为 $\bar{B}$，初始进位为1。电路计算 $S = A + \bar{B} + 1$，也就是减法！

通过一根控制线，我们创造了一个能执行两种基本运算的多[功能模块](@article_id:338790)。通过一个具体的例子，比如在一个4位系统中计算 $5 - 7$，我们可以看到这个优雅机制的运作过程，观察进位如何在各个阶段传播，最终产生正确的二进制补码结果，-2 (即 $1110_2$) [@problem_id:1915331]。

### 通用工具箱：[算术逻辑单元 (ALU)](@article_id:357155)

这个多功能的加减法器模块非常有用，它构成了处理器**[算术逻辑单元](@article_id:357121)（ALU）**的核心，即CPU的计算引擎。但是ALU的功能不仅仅是加减法。通过巧妙地选择我们加减法器的输入，我们可以让它执行其他任务。

例如，我们如何制作一个简单地将数字加一的电路，计算 $S = A + 1$？我们可以在加法模式（$M=0$）下使用我们的加减法器，并将 $B$ 输入设置为二进制的1。或者，更巧妙地，我们可以在减法模式（$M=1$）下使用它，并将 $B$ 输入设置为全1。在二进制补码中，全1的值代表-1。所以，计算 $A - (-1)$ 就等同于 $A + 1$！这展示了理解底层算术原理所带来的灵活性 [@problem_id:1915319]。

我们可以进一步扩展这个想法。通过在[全加器](@article_id:357718)的输入端放置多路复用器——[数字控制](@article_id:339281)的开关——我们可以选择要计算的内容。仅用一个[全加器](@article_id:357718)和几个由信号线控制的[多路复用器](@article_id:351445)，我们就可以构建一个1位ALU，它可以被命令执行多种操作：ADD（$A+B$）、INCREMENT A（$A+1$），或者仅仅是TRANSFER A（让A直接通过）。将其扩展，我们就得到了一个功能齐全的ALU，其中控制信号决定是进行加、减、增量还是执行一系列其他逻辑操作 [@problem_id:1938861]。减法器逻辑是这个可编程工具箱中的一个关键原语。

### 与高级计算的联系

这个简陋的减法器的影响远远超出了简单的整数数学。

**浮点单元（FPU）：** 在科学和图形计算中，我们处理[浮点数](@article_id:352415)（如 $3.14 \times 10^{23}$）。在对两个这样的数进行加减之前，它们的指数必须相同。这需要一个对齐步骤：计算它们指数的差值，然后移动较小数的[尾数](@article_id:355616)（[有效数字](@article_id:304519)）。这个对齐硬件的核心是一个专门的减法器电路，用于计算指数差，从而决定需要移动多少位 [@problem_id:1914729]。因此，每当你的电脑执行[高精度计算](@article_id:639660)时，一个减法器很可能在其中扮演着关键的初步角色。

**硬件除法：** 减法也是基于硬件的[除法算法](@article_id:641501)中的基本操作。一种常见的方法，恢复余数法，其工作方式很像长除法。在每一步中，你都试图从被除数的一部分中减去除数。这次减法的借位输出信号告诉你所有需要知道的信息：如果没有借位，说明减法“成功”，相应的商位为1。如果*有*借位，结果为负，意味着除数太大了。在这种情况下，你“恢复”原始值，商位为0。该[算法](@article_id:331821)的一个硬件阶段包括一个用于执行试探性减法的全减法器和一个利用借位输出信号来决定是保留结果还是恢复旧值的多路复用器 [@problem_id:1964300]。在这里，减法成为了一种决策工具。

### 另一个维度：串行算术与状态机

到目前为止，我们一直想象我们的电路是并行操作的——一个数字的所有位同时被处理。但是还有另一种方式：串行，一次一位。一个**串行减法器**只使用一个全减法器。它首先处理最低有效位，计算出一个差值位，然后将借位输出位*保存*在一个存储元件中，通常是[D型触发器](@article_id:350885)。在下一个[时钟周期](@article_id:345164)，它处理下一对比特，使用前一个周期保存的借位作为其借位输入 [@problem_id:1908873]。这种方式速度较慢，但体积大大减小，是用[时间换空间](@article_id:638511)——一个经典的工程权衡。

这种为下一步“保存”一条信息——借位——的概念是深刻的。它意味着我们的电路具有*状态*，或者说对过去的记忆。这将[组合逻辑](@article_id:328790)（如全减法器）的世界与**[时序逻辑](@article_id:326113)**和[自动机理论](@article_id:339731)的世界联系起来。我们可以将串行减法器形式化为一个**[有限状态机](@article_id:323352)（FSM）**。该机器有两种状态：“无借位”（$B_{in}=0$）和“有借位”（$B_{in}=1$）。对于每一对输入位，机器计算一个输出位，并根据计算出的借位输出转换到其下一个状态。例如，一个[摩尔机](@article_id:323235)（Moore machine）的实现，其输出将完全由它当前所处的这两种“借位状态”中的哪一种来决定 [@problem_id:1969140]。

这个视角将减法器从一个单纯的计算器提升为一个在更复杂、动态过程中随时间演变的组件。它表明，简单的减法逻辑为[状态转换](@article_id:346822)提供了规则。从一个简单的逻辑函数，我们到达了计算中的一个基本概念：一个顺序处理信息并拥有记忆的机器。