## 引言
在现代计算中，我们理所当然地认为能够同时运行多个程序。然而，如果没有一个巧妙的方案来解决一个基本问题：程序应该存放在内存的哪个位置？那么这场复杂的进程之舞将无从谈起。早期的系统将固定的物理地址硬编码到程序中，这种僵化的方法使得移动代码或高效共享资源成为不可能。本文旨在探讨解决这一困境的优雅方案：动态重定位。它探索了允许程序在开始运行后被放置在内存中任何位置，甚至可以被移动的基础概念。第一章“原理与机制”将揭示其核心机理，从硬件在[地址转换](@entry_id:746280)中的作用到像位置无关代码这样的软件约定如何实现真正的灵活性。紧接着，“应用与跨学科联系”一章将揭示这些机制对软件架构、系统性能以及持续进行中的[网络安全](@entry_id:262820)之战的深远影响。

## 原理与机制

想象一下，你写了一个故事。在任何人阅读之前，你必须决定它将存放在一个巨大的、行星图书馆书架的什么位置。如果你把它的永久、绝对的书架位置刻在第一页——“A 区，第 3 排，第 5 架”——你就制造了一个严重的问题。如果那个位置已经有另一本书了怎么办？如果图书馆重新整理了怎么办？你的故事除非放在那个*确切*的位置，否则就无法阅读。这，在本质上，就是早期计算机程序面临的困境。

### 固定地址的暴政

在计算的早期，编译器和链接器就像那个刻板的作者。它们会接收一个程序，并生成带有硬编码的**绝对物理地址**的**机器码**。这个过程被称为**编译时**或**加载时绑定**，它基本上决定了程序将驻留在，比如说，内存地址 `0x10000`。每一条获取数据的指令和每一次跳转到代码另一部分的指令都是基于这个假设编写的 [@problem_id:3656385]。

其局限性显而易见。你无法同时运行两个这样的程序，除非它们是专门为不同的、不重叠的内存区域编译的。如果你的程序需要在运行时增长——比如加载一个新的插件——会发生什么？如果你程序旁边的内存已经被占用，你就被困住了。程序无法移动，因为它的所有内部引用都会变得无效，指向它们旧的、现在不正确的地址 [@problem_id:3656385]。如果一个指针错误地存储了一个固定的物理地址，比如 `7096`，而[操作系统](@entry_id:752937)决定将程序移动到一个新的位置，在那里该物理地址对应着完全不同的东西，那么这个指针就变得毫无意义 [@problem_id:3680488]。对于现代多任务[操作系统](@entry_id:752937)来说，这种静态方法既脆弱又极其低效。

### 神奇的弯路：[逻辑地址与物理地址](@entry_id:751447)

为了摆脱这种暴政，我们需要一种方法，将程序对其自身结构的*内部*视角与其在机器物理内存中的*外部*位置分离开来。解决方案是计算机系统中最优美和最基础的概念之一：通过硬件中介——**[内存管理单元 (MMU)](@entry_id:751869)**——进行**动态重定位**。

不要把你的程序看作一个有固定书架位置的故事，而要把它看作一本有页码的书。程序内部的一条指令不再是说“转到物理内存位置 `0x81000`”，而是说“从我的代码开始处，转到字节偏移量 `4096` 的位置”。这是一个**[逻辑地址](@entry_id:751440)**。它是一个相对位置，就像一本书的“第 50 页”。

然后，MMU 为每一次内存访问执行一个简单却神奇的转换。[操作系统](@entry_id:752937)告诉 MMU 两件事：一个**基址** ($b$)，即程序的物理起始位置；以及一个**界限** ($l$)，即程序的大小。当 CPU 请求[逻辑地址](@entry_id:751440) $a$ 时，MMU 首先检查访问是否有效 ($0 \le a  l$)。如果有效，它会以惊人的简洁方式计算出物理地址 $p$：

$$p = b + a$$

这就是**运行时绑定**。程序使用逻辑偏移量，而硬件则即时将其转换为物理现实。这种方法的美妙之处在于，[操作系统](@entry_id:752937)只需设置基址寄存器 $b$，就可以将程序放置在物理内存中的任何位置。它甚至可以停止程序，将其全部内容复制到内存中的一个新位置，更新基址寄存器为新地址，然后恢复程序。程序本身对此一无所知！它所有的内部[逻辑地址](@entry_id:751440)仍然完全有效 [@problem_id:3680488]。这解决了程序需要增长的问题；如果它用完了相邻的空间，[操作系统](@entry_id:752937)可以将其移动到内存中其他地方一个更大的连续块中 [@problem_id:3656385]。

### 教会代码“流浪”：位置无关性

为了让 MMU 的魔法生效，程序的代码必须以一种特殊的、“流浪”的风格编写。它绝不能引用绝对位置，只能引用相对位置。这就是**位置无关代码 (PIC)** 的艺术。

编译器如何生成对自己位置一无所知的代码呢？它使用了一些巧妙的技巧。为了访问数据，编译器不会硬编码像 `load from 0x20080` 这样的地址，而是生成代码，首先将数据段的基址加载到一个寄存器中，然后通过该寄存器的固定偏移量来访问数据 [@problem_id:3619034]。

对于同一代码模块内的跳转和函数调用，像 x86-64 这样的现代架构提供了一个更优雅的解决方案：**指令指针相对寻址**。一条指令可以被编码为“从*下一条*指令向前跳转 120 字节的位置”。因为代码中两点之间的距离是恒定的，所以无论整个代码块被加载到内存的哪个位置，这种相对跳转都是有效的 [@problem_id:3655234]。代码的内部几何结构得以保留。

### 地球村：与外部世界联系

只要程序是一个自给自足的孤岛，这种方法就能很好地工作。但现代软件是一个繁华的地球村。你的程序需要调用来自**[共享库](@entry_id:754739)**的函数——例如标准 C 库这样的通用代码集合，其中包含像 `printf` 这样的函数。[操作系统](@entry_id:752937)将这些库加载到内存中，供数百个正在运行的进程共享。

在这里，我们遇到了一个难题。你的代码不知道 C 库将被加载到哪里。它的位置在不同程序之间会变化，甚至每次运行*同一个*程序时都会被随机化，这是一种称为[地址空间布局随机化 (ASLR)](@entry_id:746279) 的安全特性 [@problem_id:3629072]。在编译时，你的代码到 `printf` 的距离是未知且不可预测的。

解决方案是另一个间接层，一个软件工程的杰作：**[全局偏移表 (GOT)](@entry_id:749927)** 和 **[过程链接表 (PLT)](@entry_id:753767)**。

-   **[全局偏移表 (GOT)](@entry_id:749927)**：想象一个小小的地址簿，它是你程序可写数据的一部分。对于你的程序使用的每一个外部函数或变量，链接器都会在这个地址簿中创建一个条目。最初，这个条目是空白的。当程序加载时，[操作系统](@entry_id:752937)的**动态加载器**会找到，比如说，`printf` 的*实际*运行时地址，并将该地址写入相应的 GOT 条目中 [@problem_id:3647859]。

-   **[过程链接表 (PLT)](@entry_id:753767)**：现在，当你的编译器看到对 `printf` 的调用时，它不会试图生成一个跳转到某个未知位置的指令。相反，它会生成一个位置无关的、PC 相对的跳转，跳到一个*在你程序内部的*微小代码存根 (stub)——即 PLT 中的一个条目。这个存根的唯一目的就是执行一个间接跳转，跳到存储在 `printf` 的 GOT 条目中的地址。

事件链是：`你的代码` → (PC 相对跳转) → `PLT 存根` → (使用 GOT 中的地址进行间接跳转) → `printf`。

这个链条中唯一需要绝对地址的部分是 GOT 条目，而填写它是动态加载器的工作。你程序代码段中所有已编译的代码都保持纯粹的位置无关性 [@problem_id:3655234]。

### 巨大的回报：共享的经济学

为什么要进行这套复杂的表和存根之舞？回报是巨大的：**内存共享**。

考虑一个被 100 个不同进程使用的 2 MB [共享库](@entry_id:754739)。如果没有 PIC，如果每个进程都需要将地址直接修补到其代码中，那么每个进程都需要自己私有的、修改过的副本。这将消耗 $100 \times 2 = 200$ MB 的物理内存。

有了 PIC，库的代码（其代码段）对于每个进程来说都是原始且相同的。[操作系统](@entry_id:752937)只需将 2MB 代码段的一个物理副本加载到内存中，并安全地将其映射到所有 100 个进程的[虚拟地址空间](@entry_id:756510)中。唯一需要私有的部分是包含每个进程 GOT 的数据段。当加载器将一个进程特定的地址写入一个 GOT 页面时，**[写时复制 (COW)](@entry_id:747881)** 机制会自动为该进程创建那个 4 KB 页面的私有副本 [@problem_id:3636956, @problem_id:3658285]。

因此，我们不是复制 200 MB 的代码，而只是为每个进程复制几 KB 的数据。这就是使现代[操作系统](@entry_id:752937)可行的经济奇迹。代码保持共享，而只有那些必须唯一的数据才变成私有 [@problem_id:3629072]。

### 拖延的美德：绑定的“时机”

还有一个最后的细节：动态加载器应该在*何时*解析所有这些外部符号并填充 GOT？

一种策略是**立即绑定**。程序启动时，加载器会找到程序可能使用的*所有*外部符号的地址，并在程序第一条指令运行前填充整个 GOT。这会增加启动时间，对于大型应用程序来说可能相当可观 [@problem_id:3669340]。然而，它允许一种称为“完全 RELRO”的安全增强，即在填充后可以将 GOT 设置为只读，从而防止某些类型的攻击 [@problem_id:3656387]。

更常见的策略是**[惰性绑定](@entry_id:751189)**。即非到万不得已，不做此事。最初，PLT 存根不指向 GOT 条目，而是指向动态加载器自身的一个解析器例程。当你的程序第一次调用 `printf` 时，它会被路由到解析器。解析器找到 `printf` 的地址，“修补” GOT 条目以备将来使用，然后跳转到 `printf`。之后的每次调用都很快，直接使用已填充的 GOT 条目。这种惰性方法加快了程序启动速度，代价是每次调用外部函数的第一次会有一个微小的一次性开销。这是大多数系统上的默认设置，是“即时”工作模式的胜利，并且是完全线程安全的 [@problem_id:3656387, @problem_id:3669340]。

从将程序放入内存这个简单的问题出发，我们穿越了硬件和软件抽象的层层迷雾，到达了一个极其优雅和高效的系统——一个允许无数程序共存和共享资源，并根据当下的需求动态移动和适应的系统。

