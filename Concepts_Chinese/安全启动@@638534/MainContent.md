## 引言
在[网络安全](@entry_id:262820)领域，我们通常关注的是[操作系统](@entry_id:752937)运行起来之后的保护。但是，如果攻击者能在[操作系统](@entry_id:752937)加载之前就破坏系统呢？这就是 rootkit 和 bootkit 所带来的威胁，这类恶意软件在如此基础的层面上运行，以至于传统的杀毒软件和防火墙都无能为力。为了应对这种情况，我们需要一个从通电那一刻起就开始生效的安全模型。本文将深入探讨安全启动（Secure Boot），这项旨在从硬件层面建立信任的基础技术。在接下来的章节中，我们将首先探讨其核心的“原理与机制”，剖析[信任链](@entry_id:747264)、UEFI 固件的角色以及作为补充的[度量启动](@entry_id:751820)（Measured Boot）过程。随后，我们将在“应用与跨学科联系”中拓宽视野，探索这些原则如何从个人计算机扩展到庞大的云基础设施，确保在多样化和复杂的系统中实现完整性。

## 原理与机制

想象一下，你的计算机是一座堡垒。[操作系统](@entry_id:752937)及其杀毒软件、防火墙和沙箱，就像是巡逻城墙和城门的警惕守卫。它们非常擅长处理白天试图进入的威胁。但如果一个入侵者能在早班守卫开始工作*之前*就潜入并伪装成其中一员呢？等到真正的守卫开始巡逻时，冒名顶替者早已身处内部，掌握着至高无上的权力，整个堡垒从内部被攻破。这正是安全启动旨在防止的核心威胁。在[操作系统](@entry_id:752937)之前激活的恶意软件，被称为 **bootkit** 或 **rootkit**，从最根本的层面颠覆了安全性。要击败它，我们不能依赖[操作系统](@entry_id:752937)的工具，因为它们尚未运行。我们必须建造一座从唤醒那一刻起就检查身份的堡垒。

### [信任链](@entry_id:747264)

安全启动背后的核心原则是**[信任链](@entry_id:747264)**（chain of trust）。可以把它想象成一场接力赛。第一棒选手由赛事官员指定，被认为是可信的。在交出接力棒之前，这位选手必须验证第二棒选手的身份。一旦确认无误，接力棒才被传递。第二棒选手，现在已获得信任，负责验证第三棒选手，依此类推。如果序列中的任何一位选手无法证明其身份，比赛就会停止。信任通过这种方式从一个环节传递到下一个环节。

在你的计算机中，这场比赛不是从[操作系统](@entry_id:752937)开始，而是从**统一可扩展固件接口（UEFI）**开始。这是旧式 BIOS 的现代替代品。它是你按下电源按钮时运行的第一个软件，存在于焊在主板上的一个芯片里。因为它物理上是硬件的一部分，所以它充当了我们的第一棒选手，我们不可变的**[信任根](@entry_id:754420)**（root of trust）。

固件内部嵌入了一个加密密钥数据库，就像一个授权签名列表。我们将主要的允许签名者数据库称为**允许列表数据库（$db$）**。当固件启动时，它的首要任务是加载下一阶段的**[引导加载程序](@entry_id:746922)**（bootloader）。但在交出控制权之前，它会执行一个关键检查：验证[引导加载程序](@entry_id:746922)的[数字签名](@entry_id:269311)。如果[引导加载程序](@entry_id:746922)是用与固件 $db$ 中某个公钥相对应的私钥签名的，那么签名就是有效的。固件在验证其身份后，将接力棒——即执行流——传递给[引导加载程序](@entry_id:746922)。如果签名无效，过程将中止。堡垒的大门依然紧闭。[@problem_id:3664551]

[信任链](@entry_id:747264)继续延伸。现在已获信任的[引导加载程序](@entry_id:746922)接过接力棒，并承担起验证下一位选手——操作系统内核本身的责任。[引导加载程序](@entry_id:746922)根据其自己的一组可信密钥（这些密钥本身也是作为可信过程的一部分加载的）来检查内核的签名。如果内核是真实的，它最终会被加载和执行。信任已经从硬件一直延伸到[操作系统](@entry_id:752937)的核心。固件 $\rightarrow$ [引导加载程序](@entry_id:746922) $\rightarrow$ 内核。每一个环节都铸就了下一个环节。[@problem_id:3635101] [@problem_id:3685769]

### 强制执行 vs. 证据：安全启动与[度量启动](@entry_id:751820)

安全启动，其核心是一种**强制执行**机制。它就像俱乐部门口的保安，检查身份证件，拒绝任何不在名单上的人进入。其重点在于*防止*未经授权的代码运行。但如果攻击者很聪明呢？如果他们不试图替换一个已签名的程序，而是修改该程序读取的*配置文件*呢？例如，他们可以更改内核的命令行以禁用一项关键的安全服务。安全启动本身可能不会注意到这一点。它检查的是内核*文件*的签名，但命令行只是传递*给*文件的数据。保安检查了守卫的身份证，却没有注意到他们携带了一个可疑的、未经检查的包裹。[@problem_id:3679609]

这时，一个并行且互补的概念应运而生：**[度量启动](@entry_id:751820)**（Measured Boot）。如果说安全启动是保安，那么[度量启动](@entry_id:751820)就是俱乐部里一丝不苟的公证人，坐在一张桌子旁，用一本不可磨灭的账本记录。这位公证人不会阻止任何人，但他们会按照进入的精确顺序，记录每一个进入的人员和组件的身份。

这个“公证人”是主板上一个专门的、防篡改的芯片，称为**[可信平台模块](@entry_id:756204)（[TPM](@entry_id:170576)）**。而“账本”则由 [TPM](@entry_id:170576) 内部一组特殊的寄存器组成，称为**平台配置寄存器（PCRs）**。这些 PCR 有一个独特的属性：你不能简单地向其中写入一个值。唯一的操作是 `extend`。当一个组件被“度量”时，系统会计算它的加密哈希（一个唯一的数字指纹）。然后，[TPM](@entry_id:170576) 会取一个 PCR 的当前值，将其与新的度量值拼接起来，并对结果进行哈希运算，生成新的 PCR 值。
$$
PCR_{\text{new}} \leftarrow H(PCR_{\text{old}} \Vert \text{measurement})
$$
这个过程是不可逆的。最终的 PCR 值是所有被度量到其中的内容及其顺序的完整历史的加密摘要。在任何阶段，任何组件中哪怕一个比特位的改变，都会导致一个完全不同的最终 PCR 值。[@problem_id:3673334]

因此，在我们那个内核命令行被篡改的场景中，作为可信组件的[引导加载程序](@entry_id:746922)会遵守规则。它会度量即将使用的命令行，并将该度量值扩展（extend）到一个 PCR 中。虽然安全启动允许系统启动，但 PCR 值现在已经不同于“已知良好”的基线了。公证人已经记录下了那个可疑的包裹。[@problem_id:3679609]

这份不可伪造的记录带来了两个强大的功能：

1.  **[远程证明](@entry_id:754241)（Remote Attestation）：** [TPM](@entry_id:170576) 可以使用一个唯一的、与硬件绑定的密钥来签署其 PCR 值，并将这个“证明报告（quote）”发送给远程服务器。服务器随后可以验证该机器是否以完全符合预期的组件和配置序列启动。如果 PCR 值不匹配，服务器就知道该机器已被篡改——即使是以安全启动未捕获的方式——并可以拒绝其访问网络。

2.  **密封（Sealing）：** TPM 可以加密一个秘密（如磁盘加密密钥），并将其“密封”到一组特定的 PCR 值上。只有当且仅当机器处于该精确状态时，TPM 才会解密该秘密。如果攻击者修改了[引导加载程序](@entry_id:746922)，PCRs 会改变，TPM 将拒绝解封密钥。系统虽然启动了，但无法访问其加密数据。[@problem_id:3679572]

### 当信任不足时

我们已经构建了一个卓越的系统，它能验证我们引导代码的真实性，并为其启动过程创建一份不可伪造的记录。它看起来坚不可摧。然而，这恰恰是安全领域真正精妙之处开始显现的地方。事实证明，信任并不等同于安全。

第一个精妙之处在于“交接”。安全启动的主要职责在成功验证并启动[操作系统内核](@entry_id:752950)后便告结束。但接下来会发生什么？内核本身会加载其他代码片段，比如硬件驱动程序（内核模块）。如果[操作系统](@entry_id:752937)策略配置为允许加载*未签名*的模块，那么整个精心构建的[信任链](@entry_id:747264)将立即被打破。经过验证、值得信赖的内核，刚刚自愿地将未经核实、可能包含恶意的代码加载到了系统最特权的区域。堡垒为任何人敞开了一扇后门。[@problem_id:3679582] 为了防止这种情况，[信任链](@entry_id:747264)必须得到扩展。[操作系统](@entry_id:752937)本身必须继续这个过程，例如通过使用**完整性度量架构（IMA）**来度量和验证它加载的每个应用程序和库，并将记录扩展到 [TPM](@entry_id:170576) 的 PCRs 中。[@problem_id:3673334]

第二个更深层次的精妙之处是“已签名但易受攻击”的代码问题。想象一个来自信誉良好供应商的[设备驱动程序](@entry_id:748349)。它有有效的[数字签名](@entry_id:269311)，通过了安全启动，其哈希值也被度量，并且与已知良好值匹配。根据我们所有的指标，它是“可信”的。但如果这个驱动程序有一个简单的编程错误——一个 bug，比如[缓冲区溢出](@entry_id:747009)呢？攻击者可以精心构造一个恶意输入来触发这个 bug，其目的不是改变磁盘上的驱动程序代码，而是在*运行时*劫持其执行。[@problem_id:3679560]

这揭示了一个深刻的真理：**[可信计算基](@entry_id:756201)（TCB）**——我们赖以保障安全的所有组件的集合——本身并非“安全”。真实性并不意味着正确性。签名只证明了代码是*谁*写的，而不能证明代码没有缺陷。为了防御这些威胁，我们需要互补的运行时保护措施，例如**[控制流完整性](@entry_id:747826)（CFI）**，它能防止程序的执行被非法转移；或者像**最小权限**这样的架构原则，它能隔离驱动程序，使得一个驱动程序的妥协不会导致整个系统的崩溃。[@problem_id:3679560]

### 信任的政治：密钥、撤销和所有权

这座信任的大厦完全建立在加密密钥之上。管理这些密钥是安全中一个关键且充满政治色彩的方面。UEFI 固件不仅包含允许列表（$db$），还包含一个用于撤销信任的**拒绝列表数据库（$dbx$）**。当一个签名密钥被泄露，或者一个已签名的软件被发现存在灾难性漏洞时，它的签名或哈希就会被添加到 $dbx$ 中。固件随后将拒绝运行它，即使它存在于 $db$ 中。[@problem_gpid:3673305]

但谁来决定哪些密钥可以进入这些数据库呢？这由一个更高级别的密钥——**密钥交换密钥（$KEK$）**——来管理，而它又受到最终所有者的密钥——**平台密钥（$PK$）**——的保护。如果攻击者能够控制这个策略制定机制，他们就可以编写自己的规则。一个特别危险的攻击是诱使固件清除 $PK$，这将使系统进入一个“设置模式”（Setup Mode），在该模式下所有这些保护措施都会被放宽。[@problem_id:3688014]

这就是为什么用密码保护固件设置并要求物理在场才能进行关键更改如此重要。这也是为什么[度量启动](@entry_id:751820)会扩展到审计这些策略变量本身的状态，通常将其哈希值记录到 $PCR_7$ 中。这确保了即使攻击者设法更改了规则，也会留下加密的证据痕迹，可供[远程证明](@entry_id:754241)服务检测到。[@problem_id:3688014]

因此，安全启动并非单一的功能，而是一个丰富、分层的生态系统。它是强制执行与证据收集之间的博弈，是引导时静态验证与运行时完整性这一永恒挑战之间的较量。它告诉我们，安全不是一个可以到达的目的地，而是一个持续扩展和管理信任的过程，一环扣一环，从芯片中第一丝电流的火花，直到我们日常使用的应用程序。

