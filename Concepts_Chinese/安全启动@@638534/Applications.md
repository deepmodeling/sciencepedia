## 应用与跨学科联系

在了解了安全启动的原理之后，人们可能很容易将其视为一项精巧但狭隘的工程技术——仅仅是计算机前门上的一把锁。但这样做无异于只见树木，不见森林。加密[信任链](@entry_id:747264)的概念不仅仅是一个技术技巧；它是一个深刻而通用的思想，一个在无法理所当然地假定信任的世界中建立信心的[基本模式](@entry_id:165201)。就像一条简单而强大的自然法则，它的影响力从你笔记本电脑的熟悉角落延伸到广阔的虚拟化云端，甚至在科学探究的严谨殿堂中回响。正是在这些应用中，我们才真正开始领略其优雅与力量。

### 保护日常：你的个人计算机

我们发现安全启动在起作用的最直接的地方就是我们眼前的这台机器。在运行单一[操作系统](@entry_id:752937)的最简单情况下，[信任链](@entry_id:747264)是一条直线：不可变的固件验证[引导加载程序](@entry_id:746922)，[引导加载程序](@entry_id:746922)再验证内核。链中的每个环节都由[数字签名](@entry_id:269311)铸就，如果任何一个环节被发现是伪造的，过程就会中止。机器会拒绝使用被篡改的组件启动。

但当我们引入复杂性时会发生什么呢？考虑一个常见的双启动系统场景，比如同时运行 Windows 和 Linux [@problem_id:3679547]。现在我们的[信任链](@entry_id:747264)必须[分叉](@entry_id:270606)。固件中的单一[信任根](@entry_id:754420)如何为两个不同的[操作系统](@entry_id:752937)作保，其中一个还可能是没有中央签名机构的开[源项](@entry_id:269111)目？解决方案是信任委托的一个绝佳范例。固件信任来自 Microsoft 的一个密钥，用它来验证一个名为“shim”的小型、由 Microsoft 签名的[引导加载程序](@entry_id:746922)。shim 的唯一工作就是充当一座桥梁。它携带第二组密钥，即“机器所有者密钥”（MOKs），由你——所有者——控制。shim 使用这些 MOKs 来验证下一阶段的[引导加载程序](@entry_id:746922)，如 GRUB，然后由 GRUB 继续加载 Linux 内核。当你想启动 Windows 时，GRUB 明智地不会尝试直接验证它；相反，它将控制权交还给 UEFI 固件，固件使用其原始密钥来验证 Windows 引[导管](@entry_id:274814)理器。在两种情况下，[信任链](@entry_id:747264)都得到了完美的维护，从一个共同的根安全地分支出去。

这种所有者控制信任的概念至关重要。假如你是一名开发者或系统研究员，需要加载自己定制的、“树外”（out-of-tree）的内核模块呢？安全启动会把你的机器变成一个锁死的设备吗？完全不会。它只是要求你正式地声明你的信任。通过用你自己的密钥签署你的自定义模块，并将该密钥的公共部分注册为机器所有者密钥，你就将[信任链](@entry_id:747264)扩展到了包含你自己的代码。系统现在会接受这些模块，因为你，作为所有者，为它们作了担保。或者，也可以用开发者的公钥重新编译内核，将其内置其中，达到同样的目的[@problem_id:3686058]。系统并不禁止定制；它只是迫使我们对自己所赋予的信任明确且负责。

在面临物理威胁时，这种明确的问责制至关重要。想象一下，一个攻击者暂时接触到了你的笔记本电脑——典型的“邪恶女仆”（evil maid）攻击。他们可以插入一个包含恶意[引导加载程序](@entry_id:746922)的 U 盘。如果没有安全启动，机器可能会盲目地从它启动。有了安全启动，固件会检查有效的签名。但如果攻击者很聪明，使用了一个由通用的、被广泛信任（但或许不明智）的密钥签名的[引导加载程序](@entry_id:746922)，而这个密钥恰好存在于固件的默认数据库中呢？真正的防御在于应用[最小权限原则](@entry_id:753740)。一个组织可以定制固件的签名数据库（$db$），使其*只*信任企业自己的签名密钥，移除所有其他密钥。通过缩小信任圈，他们杜绝了此类攻击，确保只有官方认可的维护介质才能用于启动机器[@problem_id:3679584]。

### 扩展信任：从笔记本电脑到云

一个强大原则的美妙之处在于其[可扩展性](@entry_id:636611)。保护单台笔记本电脑的同一条[信任链](@entry_id:747264)，可以延伸到保护广阔的[分布式系统](@entry_id:268208)。考虑一个数据中心，里面全是使用预启动执行环境（PXE）通过网络启动的“无盘”（diskless）服务器。标准的 PXE 协议，如 DHCP 和 TFTP，是出了名的不安全；它们是为了在受信任的局域网中提供便利而设计的。网络上的攻击者可以轻易地拦截请求，并提供一个恶意的[操作系统](@entry_id:752937)。

我们如何在一个不受信任的信道上建立信任呢？我们使用[信任链](@entry_id:747264)作为我们的锚点。计算机的 UEFI 固件，作为我们的[信任根](@entry_id:754420)，使用安全启动来验证从网络下载的*第一段*代码——一个增强的网络引导程序。这个程序，现在在一个可信状态下运行，拒绝使用不安全的 TFTP。相反，它会启动一个安全连接，可能使用传输层安全（TLS），连接到一个它用固定证书验证身份的服务器。然后，它通过这个安全通道下载[操作系统](@entry_id:752937)的其余部分。每一步都被度量到 [TPM](@entry_id:170576) 中，创建一个可验证的日志，不仅证明了*启动了什么*，还证明了它是从正确的服务器通过安全连接获取的，甚至能防止回滚到旧的、易受攻击的版本[@problem_id:3679590]。[信任链](@entry_id:747264)，曾经只有短短几个环节，现在已经跨越了一个不安全的网络，建立了一个安全的基础。

这种远程建立信任的能力是现代[云计算](@entry_id:747395)的基石。我们今天使用的大多数“服务器”都不是物理机器，而是运行在共享硬件上的[虚拟机](@entry_id:756518)（VMs）。租户如何信任运行在提供商硬件上的虚拟机呢？[信任链](@entry_id:747264)提供了答案，但形式上是一种奇妙的嵌套结构。宿主机有其自身的[安全启动过程](@entry_id:754617)，锚定在其物理固件和硬件 TPM 中。当它启动一个虚拟机时，虚拟机监控器（VMM）充当客户机（guest）的*虚拟固件*。客户机的[度量启动](@entry_id:751820)过程从这里开始，由虚拟固件将客户机的[引导加载程序](@entry_id:746922)和内核度量到一个*虚拟 TPM*（v[TPM](@entry_id:170576)）中[@problem_id:3679569]。

当我们将这一切联系起来进行[远程证明](@entry_id:754241)时，真正的魔力就发生了。在租户向其虚拟机发送敏感数据（如加密密钥）之前，他们的验证服务器会发出一个挑战。[虚拟机](@entry_id:756518)使用其 vTPM 生成一个“证明报告（quote）”——一份包含其引导过程度量值的签名声明，并与挑战者的唯一 nonce 进行加密绑定以防止重放。这份证明报告由一个该虚拟机独有的证明密钥签名，而该密钥自身的证书链可以一直追溯到物理硬件 TPM 的背书密钥（Endorsement Key）。通过验证这个证书链和证明报告，租户可以确信他们的[虚拟机](@entry_id:756518)正在运行正确的软件，位于一个合法的硬件平台上，并且没有被篡改或克隆。正是这条从物理硬件到虚拟客户机的可验证[信任链](@entry_id:747264)，使得公有云中的[机密计算](@entry_id:747674)（confidential computing）成为可能[@problem_id:3689858]。

### 超越引导：动态信任与更广阔的视野

安全启动的原则并不仅限于启动序列。信任是一个动态属性，必须在系统的整个运行期间得到维护。假设在服务器的内核中发现了一个严重漏洞，必须在不重启的情况下立即应用修复。这通过“内核热修复”（live kernel patching）来完成，即向正在运行的内核中注入新代码。我们如何做到这一点而不破坏引导时建立的信任呢？我们应用同样的原则。内核的补丁机制，本身就是引导时验证的可信代码的一部分，必须充当守门人。它只会接受带有[操作系统](@entry_id:752937)供应商[有效数字](@entry_id:144089)签名的补丁。此外，在应用补丁后，内核必须将该补丁度量到 TPM 中。这会更新系统的“证明状态”（attestation posture），以便任何远程验证者不仅能看到机器是安全启动的，还能看到它随后被特定的、经授权的代码打了补丁[@problem_id:3679581]。[信任链](@entry_id:747264)因此从一个静态的、引导时的保证，扩展为一个动态的、活生生的系统状态记录。

这种思维方式也迫使我们把眼光投向中央处理器及其软件之外。什么才真正构成“[可信计算基](@entry_id:756201)”（TCB）——我们必须信任的最小组件集合？对比一下现代智能手机和笔记本电脑。手机有一个蜂窝基带处理器，它本身就是一台处理[无线电通信](@entry_id:271077)的复杂计算机。如果这个处理器对主[系统内存](@entry_id:188091)有无限制的直接内存访问（DMA）权限，它就可以绕过所有[操作系统](@entry_id:752937)的保护。再多的软件安全也无法防御一个被攻破的基带。因此，基带硬件及其固件必须被包含在 TCB 中。同样，如果手机的传感器中枢（Sensor Hub）被用来做安全决策，比如根据运动来锁定屏幕，那么它也成为 TCB 的一部分。它的输入必须是可信的。相比之下，笔记本电脑可能会用一个输入输出[内存管理单元](@entry_id:751868)（IOMMU）来隔离其网卡，这个硬件充当保安，阻止网卡访问它不应该访问的内存。通过这样做，[IOMMU](@entry_id:750812) 而非网卡成为 TCB 的一部分，我们就可以安全地缩小我们的信任圈[@problem_id:3679565]。TCB 不是一个抽象的软件列表；它是一个具体的清单，包含了每一个有能力强制执行——或破坏——我们安全的组件。

这让我们得出了关于这一概念统一性的最后一个美妙的认识。让我们完全跳出计算机科学，进入一个化学实验室。一个实验正在进行，以测量一种污染物的浓度。一台连接到气相色谱仪的计算机记录数据。我们可以对计算机使用安全启动和[度量启动](@entry_id:751820)来信任软件。但这足以信任最终结果吗？当然不够。科学结果的完整性依赖于其自身的[信任链](@entry_id:747264)。这条链并非始于计算机的固件，而是始于用于称量化学标准品的**[分析天平](@entry_id:185508)**和用于溶解它的**[容量瓶](@entry_id:200949)**。这些仪器是“计量学[信任根](@entry_id:754420)”（metrological root of trust）。如果它们没有经过校准且不可信，那么后续的任何测量都没有任何意义。仪器校准、[数据采集](@entry_id:273490)、软件分析——这些都是链条中的环节。计算机的[度量启动](@entry_id:751820)日志记录了软件状态、校准证书和仪器配置，它是一位科学家精心保存的实验记录本的数字对应物。两者都服务于同一个根本目的：从一个基础的[信任根](@entry_id:754420)到一个最终的结论，建立一个可验证、可审计的证据链[@problem_id:3679604]。

从保护我们的笔记本电脑到赋能全球云，从软件的逻辑到科学的严谨，原则始终如一：信任不是假定的，而是建立的。它是一环一环地建立起来的，从一个不可动摇的基础开始，创造出一条我们可以检查、验证并最终信赖的证据链。