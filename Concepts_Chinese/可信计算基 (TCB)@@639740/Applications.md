## 应用与跨学科联系

在我们之前的讨论中，我们阐述了[可信计算基](@entry_id:756201)（TCB）的基本原则。我们视其为所有硬件、固件和软件组件的集合，这些组件的失效可能会破坏系统的安全策略。现在，是时候离开纯粹的定义世界，进入真实计算机系统那狂野、复杂而又迷人的领域了。正是在这里，TCB 从一个抽象概念转变为一个强大而实用的视角，用于理解、设计和攻击那些定义我们现代世界的机器。

TCB 的美妙之处，很像物理学中伟大的[守恒定律](@entry_id:269268)，在于其普适性。它是一种思维方式，同等适用于微处理器的最核心部分、[操作系统](@entry_id:752937)的庞大架构，甚至是我们用来编写软件的工具本身。在这次探索中，我们将看到“我们必须信任什么？”这个简单问题如何揭示计算机安全领域最深层的挑战，并展现工程师们所设计的那些优雅且时而令人惊讶的解决方案。

### [保护基](@entry_id:201163)础：启动过程

信任从何开始？它始于计算机启动的那一刻。启动过程是一系列环环相扣的精细事件，其中每个环节将控制权移交给下一个环节，从最初的固件到功能完备的[操作系统](@entry_id:752937)。TCB 为分析此链条的强度提供了一个框架。

以[引导加载程序](@entry_id:746922)（负责加载[操作系统](@entry_id:752937)的程序）的设计为例。人们可以构建一个庞大的、*[单体](@entry_id:136559)式*[引导加载程序](@entry_id:746922)来处理所有事情。这样做有其简单之处，但其整个庞大的代码库都将成为 TCB 的一部分。其数千行代码中任何一处的缺陷都可能破坏整个安全承诺。另一种方案是*链式*设计，即一系列较小的加载器各自验证并启动下一个。这种方法巧妙地将 TCB 划分为更小、更易于审计的阶段。然而，一个有趣的权衡也随之出现。虽然 TCB 的代码规模减小了，但阶段之间的“接缝”数量和配置设置的数量通常会增加。每一个新的可调参数都可能带来人为错误的机会——一个可能无意中打开安全漏洞的错误配置。因此，TCB 不仅仅关乎代码规模，还关乎其接口和配置的复杂性 [@problem_id:3679580]。

但是，如果恶意组件确实成功潜入了启动过程该怎么办？这就是 TCB 展现其另一面的地方：不仅是预防，还有*检测*。通过一种称为**[度量启动](@entry_id:751820)**的技术，我们可以使用硬件[信任根](@entry_id:754420)——[可信平台模块 (TPM)](@entry_id:756205)——来充当一种无法被篡改的法庭速记员。当每个组件加载时，其加密哈希值——一种唯一的数字指纹——会被记录在 TPM 中。这个过程被称为“扩展平台配置寄存器 (PCR)”，它是一条单行道。最终的 PCR 值是整个启动序列的加密摘要。事件发生后，调查人员可以请求 TPM 提供一份其 PCR 值的签名报告。然后，他们可以利用系统的事件日志（一份记录了*应该*加载了哪些内容的非可信列表）来重放度量过程。如果重新计算出的 PCR 值与 TPM 提供的值匹配，则日志是真实的。如果不匹配，则表示日志已被篡改。这使我们能够建立一个基于硬件信任、具有取证可靠性的启动过程时间线。关键在于，由于加密哈希的单[向性](@entry_id:144651)（抗原像攻击），攻击者无法伪造事件日志以匹配给定的 PCR 值，调查人员也无法从 PCR 值反向推导出加载了什么。TCB 提供了真理的锚点，但它无法在没有忠实记录的情况下凭空创造历史 [@problem_id:3679585]。

### 构建系统：[操作系统](@entry_id:752937)与[虚拟化](@entry_id:756508)

从启动过程向上延伸，TCB 概念成为[操作系统](@entry_id:752937)架构本身的一个指导原则。不同的[操作系统](@entry_id:752937)设计可以被理解为管理 TCB 的不同哲学。

传统的**[宏内核](@entry_id:752148)**，如许多主流系统中所使用的那样，几乎将所有系统服务——文件系统、网络栈、[设备驱动程序](@entry_id:748349)——都置于特权内核空间中。这种设计效率很高，但导致了庞大的 TCB，代码量可达数千万行。一个罕用驱动程序中的单个 bug 就可能导致整个系统被攻破。

作为回应，出现了各种替代架构，每一种都是对缩小 TCB 的大胆尝试。**微内核**将特权核心精简至最基本要素：调度、内存管理和[进程间通信](@entry_id:750772)。所有其他服务都作为非特权的用户空间进程运行。**外核 (exokernel)** 更进一步，几乎不提供任何策略，只是将硬件资源安全地导出给应用程序。最近，**unikernel** 开创了一种将定制的、专门化的[操作系统](@entry_id:752937)与单个应用程序融合的方法。通过仅包含该应用程序所需的代码，TCB 得以量身定制和最小化。这种架构上的多样性是与[可信计算基](@entry_id:756201)规模作斗争的直接结果 [@problem_id:3640406]。

这不仅仅是一个学术练习。TCB 的大小对系统安全和维护有着直接而具体的影响。更小的 TCB 意味着更小的“攻击面”——可供 bug 藏身之处更少。因此，与[宏内核](@entry_id:752148)系统相比，具有较小 TCB 的系统（如 unikernel）可以预期其安全补丁的频率会更低。抽象的架构选择直接转化为维护系统安全的现实世界运维负担 [@problem_id:3640402]。

同样的逻辑也完美地延伸到了**虚拟化**领域。一个常见的问题是：容器和虚拟机 (VM) 之间的安全性差异是什么？TCB 提供了一个清晰明了的答案。同一主机上的容器共享同一个操作系统内核。因此，对于一个容器而言，其 TCB 包括*整个主机内核*。从一个容器内部触发的内核级漏洞利用是一个“游戏结束”事件；它会立即危及主机和所有其他容器。相比之下，虚拟机运行自己的客户机内核，该内核位于[虚拟机](@entry_id:756518)管理程序 (hypervisor) 的 TCB *之外*。攻破客户机内核的攻击者仍然被困在虚拟机内部。要逃[逸出](@entry_id:141194)来，他们必须在[虚拟机](@entry_id:756518)管理程序本身——真正的 TCB 边界——中找到第二个独立的漏洞。TCB 结构上的这种根本差异，正是虚拟机能够提供比容器更强大的、针对内核级威胁的隔离边界的原因 [@problem_id:3689844]。

实际上，虚拟机管理程序的发展史就是一部 TCB 缩减史。早期的“第二类”(Type 2) [虚拟机](@entry_id:756518)管理程序运行在完整的主机[操作系统](@entry_id:752937)之上，继承了其庞大的 TCB。现代的“第一类”(Type 1)（或裸金属）虚拟机管理程序直接在硬件上运行，力求尽可能小而简单，从而缩小攻击面，提高整个[虚拟化](@entry_id:756508)环境的安全性 [@problem_id:3639736]。

### 超越 CPU：外设的风险

现代计算机不是一个单一实体，而是一个由相互作用的组件组成的社会。我们的笔记本电脑和智能手机充满了“隐藏的计算机”——例如 Wi-Fi 卡、蜂窝基带处理器和传感器集线器等外设，每个都在运行自己复杂的固件。如果这些设备能够与主[系统内存](@entry_id:188091)交互，它们将对我们的 TCB 构成严峻的挑战。

以智能手机的蜂窝基带处理器为例。如果它拥有无限制的直接内存访问 (DMA) 权限，它就有可能读取或写入[系统内存](@entry_id:188091)的任何部分。即使主[操作系统](@entry_id:752937)完美无缺，一个被攻破的基带处理器也可能窥探用户数据或禁用系统保护。在这种情况下，基带固件*必须*被包含在用于保证机密性和完整性的 TCB 中。类似地，如果传感器集线器的数据被用于做出[访问控制](@entry_id:746212)决策（如锁定手机），那么其固件就成为该特定策略 TCB 的一部分 [@problem_id:3679565]。

那么，我们如何才能在不必信任每一块芯片的情况下构建安全的系统呢？答案是增加一个新的、可信的守门员：**输入输出[内存管理单元](@entry_id:751868) ([IOMMU](@entry_id:750812))**。[IOMMU](@entry_id:750812) 位于外设和主内存之间，强制执行关于设备允许访问哪些内存区域的规则。通过配置 IOMMU，将 Wi-Fi 卡的访问权限限制在它自己的专用缓冲区内，我们可以有效地将 Wi-Fi 卡的固件从保障[系统内存](@entry_id:188091)完整性的 TCB 中移除。即使该卡的固件是恶意的，[IOMMU](@entry_id:750812) 也能将其遏制住。这是一个强有力的例子，说明了如何使用一个小的、可信的硬件组件来管理和缩小整个系统的 TCB [@problem_id:3679565]。

### 动态系统：运行时威胁与 TCB

TCB 的职责并不会在系统启动时结束。它还必须保护“活的”系统免受运行时威胁。一个引人入胜的现代例子来自 Linux 中的 eBPF 子系统，它允许沙箱化程序在内核内安全运行。

eBPF **验证器**是 TCB 的一个关键部分。它对 eBPF 字节码进行[静态分析](@entry_id:755368)，以确保其安全性——即它不会访问禁止的内存或陷入无限循环。然而，这并非全部。攻击者可以精心构造一个根据验证器来看是完全“安全”的程序，但该程序会对每一个网络数据包触发一个高成本操作（例如在数据映射中进行复杂搜索）。结果就是[拒绝服务](@entry_id:748298)攻击：CPU 因忙于处理这些“安全”程序而没有时间处理其他任何事情。

这教会我们两件事。首先，TCB 不仅要保护机密性和完整性，还要保护**可用性**。其次，加载时的[静态分析](@entry_id:755368)（验证器所做的工作）并不总能预测动态的运行时成本。因此，TCB 还包括运行时本身、将字节码转换为机器码的即时 (JIT) 编译器以及程序可以调用的辅助函数。这些可信组件中的任何一个 bug 都可能破坏沙箱并危及内核 [@problem_id:3685853]。

### 机器中的幽灵：信任我们的工具

我们现在已经从硬件出发，穿过启动过程，进入了运行中的[操作系统](@entry_id:752937)。但还有一个更深层次的问题在等待着我们。我们信任我们的[操作系统](@entry_id:752937)，因为它是由编译器构建的。我们信任编译器，因为它是由……另一个编译器构建的。这条[信任链](@entry_id:747264)究竟从何处开始？

这就是 Ken Thompson 在其著名演讲《对信任的思考》(Reflections on Trusting Trust) 中提出的核心问题。一个被攻破的编译器可以在它构建的任何程序中注入一个微妙的后门，包括新版本的编译器本身。这种“信任之信”攻击是 TCB 面临的终极挑战。编译器本身成为了它所创建的每一件软件的 TCB 的一部分。

从头开始构建一个真正值得信赖的系统的唯一方法是通过**自举 (bootstrapping)**。必须从一个“种子”开始——一个足够小且简单的程序，可以由人眼审计和验证。这可能是一个用汇编写的微型解释器，甚至是一组用于汇编器的宏。这个最小化的、可信的种子随后被用来编译一个稍微复杂一点的编译器，后者再被用来编译一个更复杂的编译器，如此循环，直到你拥有一个功能齐全、可以自我宿主的编译器。在这个漫长过程的最后，你整个软件生态系统的 TCB 归根结底取决于那个最初的、微小的种子的正确性 [@problem_id:3629209] [@problem_id:3634687]。为了获得更高的置信度，可以执行“多样化双重编译”(diverse double-compilation)，即通过两个完全独立的工具链来构建编译器，并验证最终的二[进制](@entry_id:634389)文件是否完全相同。

这就是最根本形式的 TCB。它迫使我们直面信任源于何处的问题。它揭示了我们对最复杂软件系统的信心，最终依赖于一个微小的、可由人工审计的基础。

从启动时第一丝电流的闪烁，到信任我们自己工具的哲学深度，[可信计算基](@entry_id:756201)提供了一个单一、统一的原则。它是一件锋利而多功能的工具，教导我们构建安全系统并非在于层层加码地堆砌装甲，而在于一种有纪律、不懈的艺术——决定哪些是真正必须信任的，然后用我们全部的智慧来保护那个最小化的核心。