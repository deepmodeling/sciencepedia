## 引言
在编程中，如同在任何手艺中一样，效率往往来自于避免重复工作。没有哪个面包师会为每一块饼干都预热一次烤箱，也没有哪个程序员希望自己的程序将同一个值重复计算数百万次。这便是**代码外提**背后简单而强大的思想。这是一项基础性的[编译器优化](@entry_id:747548)，它智能地重组程序，使不变的计算只执行一次。这个过程看似直接，却解决了无数应用程序中存在的关键性能瓶颈，即循环内部的冗余计算会浪费宝贵的时钟周期和能源。本文将深入探索代码外提的世界，探究其工作机制和深远影响。第一章**“原理与机制”**将剖析编译器如何识别这种不变代码，以及它们为安全移动代码所遵循的复杂规则，从而驾驭程序流、异常和指针的复杂性。随后的**“应用与跨学科联系”**一章将揭示这项优化的深远影响，展示它如何加速从[科学计算](@entry_id:143987)到动态语言的各种应用，释放隐藏的硬件能力，甚至有助于开发更节能的软件。

## 原理与机制

想象一下，你正按照食谱烘烤几批饼干。食谱指示你，对*每一*批次，都要“将烤箱[预热](@entry_id:159073)到 350°F”。一位经验丰富的面包师会觉得这种做法效率低下而发笑。你不会为每一批饼干都重新预热烤箱；你只在最开始时做一次。这个简单、符合常识的洞察，正是一系列强大的[编译器优化](@entry_id:747548)（统称为**代码外提**）的精髓所在。其核心是识别重复、不变的工作，并巧妙地重排程序，使该工作只做一次的艺术。这关乎于变得聪明，而不仅仅是盲目服从。

### 最简单的情况：在重复中寻找不变

计算机程序中最常出现重复工作的地方是**循环**。循环就是计算机一遍又一遍执行的一组指令。很多时候，循环中的某些计算在每一次迭代中都会产生完全相同的结果。这就是我们所说的**循环不变代码**。

考虑一个需要检查一列字符串是否匹配特定模式的程序——例如，在一个大文本文件中搜索电子邮件地址。程序可能会遍历每个字符串，并在每次迭代中执行两个步骤：首先，将文本模式（[正则表达式](@entry_id:265845)）编译成高效的、机器可用的格式；其次，使用这个编译好的格式来检查当前字符串。

在这里，我们找到了那个“[预热](@entry_id:159073)烤箱”的时刻。模式本身不会因下一个字符串而改变；它始终是“一个电子邮件地址模式”。因此，编译它是一个循环不变的计算。一个智能的编译器可以将这个编译步骤“外提”出循环，在循环开始前只执行一次。然而，第二步——实际的匹配——*依赖于*当前迭代中正在检查的字符串 $S[i]$。由于字符串 $S[i]$ 在循环的每一步都会变化，匹配的结果也会变化。这个计算是**循环可变**的，必须保留在循环内部。这相当于烘烤每一块单独的饼干；这件事必须一个一个来完成。[@problem_id:3654697]

这项被称为**循环不变[代码移动](@entry_id:747440) (LICM)** 的优化的基本原则是：如果循环内的一个计算仅依赖于常量或在循环外定义的值，那么它可以被安全地移动到循环前一个称为**前置首部 (preheader)** 的特殊位置。这保证了该计算只执行一次，其结果可供每一个需要它的迭代使用。

### 识别同一性的艺术

[编译器设计](@entry_id:271989)的妙处在于，即使在机会不那么明显的时候也能发现它们。有时，同一个计算被程序的结构所掩盖。

想象一段代码写着：“如果条件 C 为真，计算 $t \leftarrow f(x, v)$；否则，也计算 $t \leftarrow f(x, v)$。”在这里，完全相同的计算出现在[条件语句](@entry_id:261295)的两个不同分支中。对于人来说，很明显无论如何我们都要计算 $f(x, v)$。编译器也可以被教会看到这一点。它可以将该计算外提到 `if` 语句*之前*，无条件地执行它。[@problem_id:3638824]

为了确保安全，编译器必须确定两件事。首先，新的位置必须**支配**所有原始位置。简单来说，如果所有到位置 $B$ 的可能执行路径都必须经过位置 $A$，那么位置 $A$ 就支配位置 $B$。通过将计算移动到一个支配点，我们确保它总是在需要之前被执行。其次，如果函数 $f$ 可能会使程序崩溃怎么办？将其移动到一个无[条件执行](@entry_id:747664)的位置可能会在一条原本安全的路径上引入崩溃。我们稍后会回到这个深刻的问题。

“同一性”甚至可能更加微妙。考虑一个包含以下逻辑的循环：`if (i is even) { t = a * b; } else { t = b * a; }`。从句法上看，`a * b` 和 `b * a` 是不同的。但如果编译器知道，对于它正在处理的数字，乘法是**可交换的**，它就明白这两个表达式在代数上是等价的。一个称为**[全局值编号](@entry_id:749934) (GVN)** 的优化遍可以识别这种等价性并简化代码，有效地用一个单一的、无条件的计算替换两个分支。一旦代码被简化，我们的朋友“循环不变[代码移动](@entry_id:747440)”就能看到这个新的计算是不变的，并将其完全外提出循环。这揭示了一个更深层次的真理：优化通常协同工作，一个优化遍为另一个揭示机会，就像一组侦探分享线索以解决一个复杂的案件。[@problem_id:3654729]

### 穿越迷宫：在充满异常和跳转的世界中进行代码外提

到目前为止，我们的程序路径一直井然有序。但现实世界的代码是一个由条件分支、提前退出甚至可能导致控制流意外跳转的异常组成的迷宫。我们还能在这个混乱的世界里进行代码外提吗？答案是肯定的，但我们必须更加小心。

假设我们有一段受检查保护的代码：`if (ptr != NULL) { x = *ptr; }`。操作 `*ptr`（解引用一个指针）就像一个地雷。如果 `ptr` 是 `NULL`，程序就会崩溃。`if` 语句是一个防止我们踩到地雷的守卫。将 `x = *ptr` 外提到检查之前将是一个灾难性的错误，因为这将把地雷移到了开阔地带。`x = *ptr` 的执行**[控制依赖](@entry_id:747830)于**这个守卫；其安全性本身就取决于分支的走向。[@problem_id:3632579]

但如果另一个完全安全的计算，比如 `u = r + s`，也恰好在那个 `if` 块内呢？这个计算没有地雷；它不会使程序崩溃。一个大胆的编译器可以将*这个*计算外提到 `if` 语句之前。这被称为**[推测执行](@entry_id:755202)**。编译器[实质](@entry_id:149406)上是在赌 `if` 条件会为真。如果为真，我们就在块内节省了一些工作。如果为假，我们只是无谓地执行了一个小的、无害的计算。由于该计算是**纯粹的**（它没有可观察的副作用，如改变全局状态或打印到屏幕）和**完整的**（它不会引起错误），根据“as-if”规则，这种推测是完全安全的。该规则规定，只要程序的可观察行为不变，编译器可以做任何事情。

这种安全推测的原则是我们穿越迷宫的向导。
-   **提前退出**：如果一个循环可以通过 `break` 语句提前结束怎么办？`break` 之后的任何代码可能不会执行。如果我们将 `break` 之后的一个不变计算外提到循环之前，我们又是在进行推测。只有当该计算是纯粹且不会触发陷阱时，这才是安全的。这就是为什么像 `$u * v$` 这样的简单乘法可以被外提，而像 `$p / q$` 这样的除法（可能会因除零错误而触发陷阱）不能被推测性地外提。[@problem_id:3644387]
-   **非局部跳转**：对于 C 语言中 `setjmp` 和 `longjmp` 这种允许程序从深层嵌套的函数“传送”回更早点的疯狂世界又如何呢？即使在这里，我们的原则也成立。`longjmp` 只是提前退出的一种极端形式。在一个潜在的 `longjmp` 调用点上外提一个纯粹的、非陷阱的函数调用是有效的，因为它的[推测执行](@entry_id:755202)不会留下任何痕迹。但是，外提一个有副作用的操作，比如写入一个全局变量，是被禁止的。如果我们执行了写操作，然后 `longjmp` 把我们传送走了，程序的状态就在不应该改变的时候被可观察地改变了。[@problem_id:3654731]

在那些我们不能冒险进行推测的情况下（例如，指令可能会出错），编译器必须更加保守。它只有在能够证明该指令无论如何都会在*每一条可能的路径*上执行时，才能外提该指令。用于此目的的正式工具是**后置支配**。如果从块 $M$ 出发的所有路径最终都必须经过块 $N$，那么块 $N$ 后置支配块 $M$。为了将一个有风险的指令从 $N$ 外提到 $M$，编译器必须证明 $N$ 后置支配 $M$，以确保不会引入新的错误。[@problem_id:3644366]

### 别名的挑战：指针的世界

指针增加了另一层深刻的复杂性。指针只是一个内存地址，而编译器的宿敌是**[别名](@entry_id:146322)**——即两个不同的指针变量可能指向同一个内存位置的可能性。如果编译器看到通过指针 `*p` 进行写操作和从 `*q` 进行读操作，它通常必须假设写操作*可能*改变了 `*q` 处的值，从而使任何涉及 `*q` 的计算看起来都是循环可变的。

这正是在程序员和编译器之间可以发生美妙对话的地方。在像 C 这样的语言中，程序员可以使用 `restrict` 关键字。这是一个承诺：“亲爱的编译器，我保证这个指针以及此函数作用域内的任何其他指针永远不会指向重叠的内存。”

有了这个承诺，编译器就可以以新的信心进行推理。在一个包含通过 `restrict` 限定的指针 `*p_a` 进行写操作和从另一个 `restrict` 限定的指针 `*k` 进行读操作的循环中，编译器现在*知道*写操作不会影响 `*k` 处的值。突然之间，从 `*k` 的读取被揭示为循环不变的，并且可以被外提。[@problem_id:3644360] 这单一的信息可以解锁一连串的优化，允许编译器外提[地址计算](@entry_id:746276)，甚至通过一种称为**强度削减**的技术将昂贵的乘法替换为更廉价的加法。

### 完美的代价：何时不应进行代码外提

最后，至关重要的是要理解，优化并非对完美的盲目追求。它是一门由权衡所支配的实用艺术。仅仅因为一个转换是安全的，并不意味着它就是**有益的**。

想象一个复杂的循环，编译器为了提高性能已经对其进行了展开。这种转换可能会为循环主体创建多个入口点，每个入口点都有自己的前置首部。现在，假设循环内部有一个廉价的、循环不变的守卫，比如一个空指针检查。虽然外提这个检查是安全的，但这样做需要将它的一个副本放置在*每一个*前置首部中。这种复制增加了程序机器码的总体积。编译器可能会认为，外提一个廉价指令所带来的微不足道的性能增益，不值得代码体积增大的代价。在优化的世界里，有时最好的举动是按兵不动。[@problem_id:3654674]

从简单的循环到指针和异常的复杂交错，代码外提证明了编译器作为专家助手的角色。它体现了物理学家在复杂系统中寻找统一原理的动力，以及工程师明智地应用这些原理的实用主义，将我们简单的、人类可读的指令转化为优雅、高效的代码。

