## 引言
在人工智能时代，我们探索发现的能力受限于我们用以与机器沟通的语言。对化学而言，挑战尤为艰巨：我们如何教会计算机理解分子那错综复杂的三维世界？答案在于创造一种既具化学[表现力](@entry_id:149863)又易于计算处理的表示方法。这正是简化[分子线](@entry_id:198003)性输入规范（SMILES）所要解决的核心问题。SMILES是一种强大的语言，能将分子结构转化为简单的文本字符串。

本文全面概述了SMILES，从其基本规则到其在自动化科学发现前沿领域中的作用。通过理解这门语言，您将深入了解现代[计算化学](@entry_id:143039)和人工智能驱动的[药物发现](@entry_id:261243)是如何成为可能的。接下来的章节将首先解构分子的“语法”，探索让一维字符串得以编码复杂化学信息的原理和机制。随后，我们将探索其广阔的应用前景和跨学科联系，揭示这种简单的标记法如何助力我们组织化学数据、预测分子行为以及创造性地设计新化合物。

## 原理与机制

要指令计算机对化学世界进行推理，我们必须先教会它化学的语言。但分子的字母、语法和行文规则又是什么？毕竟，分子不是一串字母，而是一个三维物体，是原子在电子“胶水”的维系下翩然起舞的精妙结构。简化[分子线](@entry_id:198003)性输入规范，即**SMILES**，是一次卓越的尝试，旨在将这一复杂的现实转化为简单的线性文本字符串。它是一门语言，与任何语言一样，其力量在于规则，其优雅在于表现力，其局限则在于[歧义](@entry_id:276744)性。

### 分子的语法

想象一下，您正尝试通过电话向他人描述一座复杂的雕塑。您可能会从某一点开始，描述它，提及与之相连的部分，然后继续“漫步”于物体周围，直到描述完所有部分。SMILES对分子的处理方式正是如此。它沿着原子和[化学键](@entry_id:145092)组成的图进行遍历。

其字母表很简单：原子由其元素符号表示（如`C`、`N`、`O`），[化学键](@entry_id:145092)由`-`（[单键](@entry_id:188561)）、`=`（双键）和`#`（[三键](@entry_id:202498)）等符号表示。为处理分支，我们使用括号。例如，异丙醇，其中心碳原子与另外两个碳原子和一个氧原子相连，可写作`CC(O)C`。括号告诉我们，`O`是[主链](@entry_id:183224)上的一个侧支。

那环状结构呢？这里我们用了一个巧妙的技巧。当遍历遇到一个需要与之前访问过的原子成键的原子时，我们不能直接返回。取而代之的是，我们用一个匹配的数字来“标记”这两个原子。苯的六元碳环写作`c1ccccc1`。第一个`c`被标记为`1`，当我们沿着环遍历时，最后一个`c`也被标记为`1`，这告诉解析器通过在这两个原子之间画一条键来“闭合环路”[@problem_id:4570151]。

这个系统不仅仅是一种松散的约定，它是一门拥有严格语法的[形式语言](@entry_id:265110)。实际上，我们可以设计一个简单的机器——**确定性有限自动机**（DFA）——它能逐一读取SMILES字符串中的字符，并判断其是否遵守句法规则，例如确保[化学键](@entry_id:145092)连接原子以及括号正确匹配。这揭示了化学与计算机科学之间一个美妙的联系：分子的结构可以用定义编程语言的相同数学工具来捕捉 [@problem_id:2390509]。

这门语言的最终目标是创建一个计算机可以处理的数据结构。通过解析SMILES字符串，我们可以重建分子的二维连接图，即**分子图**。该图由节点（原子）和边（[化学键](@entry_id:145092)）组成。我们可以用一个**邻接矩阵**$A$（其中，如果原子$i$和$j$成键，则$A_{ij}=1$）和一个**节[点特征](@entry_id:155984)矩阵**$X$（存储每个原子的属性，如其元素类型）来数值化地表示这个图[@problem_id:1426766]。从一维字符串到二维图的这种转换为现代化学领域中基于图的人工智能奠定了基础。

### 身份危机：分子的“真名”

在这里，我们遇到了一个深刻的哲学问题，一个具有巨大实际影响的问题。当我们描述异丙醇时，我们本可以从不同的原子开始遍历，或者以不同的顺序探索分支。这意味着同一个分子可以有许多个有效的SMILES名称。乙醇可以是`CCO`或`OCC`。这是两种不同的东西吗？对化学家来说，不是。但对于一个简单地比较文本字符串的计算机程序来说，是的。

这种[歧义](@entry_id:276744)性对科学来说是一场噩梦。如果同一种化合物以几十个不同的别名出现，我们如何建立数据库？如果一个机器学习模型在[训练集](@entry_id:636396)中看到`CCO`，在[测试集](@entry_id:637546)中看到`OCC`，并认为自己发现了一个新分子，我们又如何训练它？这种“数据泄露”会让我们自欺欺人地认为我们的模型比实际更具预测能力[@problem_id:3847948]。

解决方案是为每个分子创建一个“真名”——一个单一、独特或称**规范化**的表示。**规范化SMILES**由一个确定性算法生成，该算法遵循一套严格的规则，以精确决定从何处开始遍历以及如何解决沿途的任何选择。对于一个分子的任何一个可能的SMILES字符串，规范化算法总会输出完全相同的那个。一个更严谨、更通用的标准是**国际化学标识符（InChI）**，它使用分层系统为分子的连接性、[立体化学](@entry_id:166094)和[质子化状态](@entry_id:753827)生成唯一的代码[@problem_id:4602644]。

通过在进行任何分析或模型训练*之前*，将数据集中的所有分子转换为其规范形式，我们解决了身份危机问题。我们确保一个分子只有一个名称，从而为[计算化学](@entry_id:143039)带来了可重复性和完整性。

### 将维度压缩入一行

SMILES的巧妙之处不仅在于简单的连接性。化学是一门三维科学，原子空间排布的细微差异可能意味着一种是救命良药，另一种是惰性化合物。值得注意的是，SMILES能够捕捉这种三维信息。

以[单糖](@entry_id:142751)[D-葡萄糖](@entry_id:172417)为例。它与其“表亲”D-半乳糖和D-甘露糖拥有相同的原子和[化学键](@entry_id:145092)。唯一的区别在于特定碳原子上羟基（`-OH`）的三维朝向。这些分子是**表异构体**——仅在一个立体中心上有所不同的[非对映异构体](@entry_id:154793)。SMILES使用特殊符号`@`和`@@`来编码这一信息。这些符号定义了[手性中心](@entry_id:194773)周围[化学键](@entry_id:145092)的相对朝向。例如，SMILES字符串`O=CH[C@H](O)[C@@H](O)[C@H](O)[C@H](O)CO`精确地描述了定义[D-葡萄糖](@entry_id:172417)的独特[立体中心](@entry_id:194773)序列，从而将其与所有异构体区分开来[@problem_id:2937684]。这些信息在基础的图中会丢失，但却至关重要。这就是一维字符串如何能够容纳三维物体蓝图的方式[@problem_id:4570151]。

### 对称性，物理学家的基石

物理学的一个基本原理是，自然法则不依赖于你的观察视角。分子的性质不会因为你在空间中旋转它、移动它，或者决定以不同方式编号其原子而改变。我们的计算模型应该尊重这些基本的**对称性**。

在这里，我们看到不同分[子表示](@entry_id:141094)方法之间的深刻区别[@problem_id:5173730]：
-   **三维坐标：** 每个原子的$(x, y, z)$位置列表。这种表示不是不变的；如果你旋转分子，坐标会改变。然而，它们以一种可预测的方式改变——它们对[旋转和平移](@entry_id:175994)是**等变的**。
-   **分[子图](@entry_id:273342)：** 这个抽象的连接图没有坐标，因此它天然对[旋转和平移](@entry_id:175994)是**不变的**。然而，我们写下的具体*邻接矩阵*取决于我们如何给原子编号。如果我们打乱原子标签（一种排列），矩阵就会改变。**[图神经网络](@entry_id:136853)（GNN）**是一种特殊的人工智能模型，其巧妙的设计使其对这种编号不敏感，从而学习图本身的内在属性。
-   **SMILES字符串：** 与图一样，SMILES字符串不包含坐标，因此对分子在空间中的位置和朝向是不变的。但是，正如我们所见，一个非规范化的SMILES字符串高度依赖于原子编号（即遍历路径）。这再次强调了为什么规范化如此重要。

当我们将SMILES输入给像Transformer这样基于序列的人工智能模型时，我们首先使用一个**分词器**将字符串分解成一个化学“词汇”表（例如`C`、`O`、`(`、`[C@@H]`），然后将它们转换为数值向量[@problem_id:1426767]。模型随后从这个序列中学习。表示方法的选择——序列、图或三维坐标——决定了人工智能架构的类型及其能够轻易学习的[基本对称性](@entry_id:161256)。

### 一种不会说谎的语言

尽管SMILES功能强大，但它有一个致命弱点。如果我们训练一个AI成为“分子作家”，并要求它生成新的SMILES字符串，它常常会产生无意义的结果。就像一个语言学习者会犯语法错误一样，它可能会写出像`C(=O)C)`这样括号不匹配的字符串，或者像`O=O=O`这样原子违反其基本价键规则的字符串（一个氧原子不能形成四个键！）。对于一个生成模型来说，产生有效字符串的概率$p_{\text{val}}$可能会低得令人失望。这意味着大量的计算精力都浪费在评估这些胡言乱语上[@problem_id:4567900]。

于是，**自引用嵌入串（SELFIES）**应运而生。SELFIES是一种更新的分子语言，其设计带有一个巧妙的约束：每个可能的字符串都保证在句法上和化学上是有效的。它的工作方式类似于一个[状态机](@entry_id:171352)，字符串中的每个符号代表一个操作（如“添加一个原子”、“开始一个分支”、“闭合一个环”），只有在遵守化学价键规则时才被允许执行。你根本无法用SELFIES写出一个无效的分子。

这对生成模型来说是一个巨大的优势，因为每个生成的字符串都对应一个真实的化学图，从而极大地提高了效率。然而，SELFIES并非万能药。它不保证生成的分子在物理上是稳定的或易于合成。此外，与SMILES一样，从SELFIES字符串到分子的映射是多对一的，这会引入其自身微妙的[统计偏差](@entry_id:275818)，必须谨慎处理[@problem_id:4567900] [@problem_id:4567900]。

### 分子如蜂群：真实世界中的表示法

我们的探索之旅已经走了很远，但我们一直是在一个最终的、方便的虚构前提下操作：即分子是一个单一的、静态的实体。在现实世界中，尤其是在人体的水性环境中，情况并非如此。

一个带有酸性或碱性位点的分子会以不同**[质子化状态](@entry_id:753827)**的集合形式存在，具体取决于周围的$pH$值。此外，许多分子可以在称为**[互变异构体](@entry_id:167578)**的[结构异构体](@entry_id:146226)之间快速相互转换，其中质子和双键会移动位置。溶液中的分子不是一个单一的图；它是一个动态的、按概率加权的微观状态*集群*[@problem_id:4333000]。

这就提出了终极挑战：我们如何用一个单一的向量为AI模型表示这个动态的集群？简单地选择一种状态——比如中性$pH$下最常见的状态——就是丢弃关键信息，并错误地表示分子在任何其他$pH$值下的行为。

最优雅且忠于物理现实的解决方案是拥抱这种复杂性。我们可以枚举一个分子的所有重要微观状态（[质子化状态](@entry_id:753827)和[互变异构体](@entry_id:167578)）。利用统计力学的原理，特别是玻尔兹曼分布，我们可以计算在给定$pH$下每种微观状态$\pi_i$的概率。然后，我们不选择其中一种，而是将整个[集合表示](@entry_id:636781)为每个单独[状态表示](@entry_id:141201)的加权平均值：$\mathbf{v}(pH) = \sum_i \pi_i(pH) \phi(G_i)$。这就创建了一种复杂的、依赖于上下文的表示方法，它捕捉了分子在溶液中的真实性质[@problem_id:4333000]。正是在这个前沿领域，当抽象的表示语言与具体的物理现实相遇时，下一代的化学发现将被铸就。

