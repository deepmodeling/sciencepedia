## 应用与跨学科联系

在我们之前的讨论中，我们打开了现代处理器的“黑匣子”，发现了一个惊人简单的机制：缓存。我们了解到，访问内存所需的时间并非恒定。它取决于处理器那个小而快的工作台——缓存——上已经有什么。这个简单的事实，作为[性能优化](@entry_id:753341)的基石，却有一个阴暗的孪生兄弟：它可能成为[信息泄露](@entry_id:155485)的源头。为提升计算机速度而设计的东西，也可能使其变得不安全。

现在，我们将踏上一段穿越现代计算各个层级的旅程，看看这个阴影究竟延伸多远。你或许可以把这看作一个鬼故事，故事中的鬼是一个微妙的时序变化，而这栋房子就是整个计算栈。我们将看到这个鬼魂出现在最意想不到的地方，从优雅的密码学世界到繁忙、共享的云基础设施。这不仅仅是一个关于漏洞的故事；这是一个关于硬件与软件之间深刻且往往出人意料的相互联系的故事。

### 密码学家的困境：当代码泄露秘密

在任何领域，性能与安全之间的紧张关系都没有在密码学中表现得如此尖锐。密码学家的目标是在不泄露任何关于密钥信息的情况下，对秘密密钥进行数学运算。算法的输出应该是唯一的信息来源。但如果执行*时间*也泄露了信息呢？

以高级加密标准（AES）为例，它是现代数字安全的基石。一种常见的提速 AES 实现方式是使用预计算的[查找表](@entry_id:177908)。秘密密钥帮助确定要访问表中的哪个条目。从软件角度看，这是一个简单的内存查找。但从硬件角度看，这是一个必须经过缓存的请求。如果不同的秘密密钥导致对不同内存位置的查找，它们可能会产生不同的缓存命中和未命中模式，从而导致不同的执行时间。

这种敏感性令人震惊。想象一个查找表，一个简单的数据数组，存储在内存中。程序员可能认为其确切位置是无关紧要的。然而，一个看似无害的决定，即将表错位一个字节，就可能极大地放大[信息泄露](@entry_id:155485)。如果一个 4 字节的表条目恰好被存储得跨越了一个 64 字节的缓存行边界，访问它就需要 CPU 获取*两个*缓存行而不是一个。这种“跨越”创造了一个独特且更慢的时序信号。如果这一事件的发生与秘密密钥有关，攻击者就获得了一条强有力的线索。一个简单的 1 字节[移位](@entry_id:145848)，可以将一个无声的操作变成一个关于秘密密钥值的大声宣告，从而在一个本不存在的地方创造出一个可测量的信道 [@problem_id:3676087]。

面对这种情况，一个聪明的程序员可能会想：“如果问题是缓存使用效率低下，那我们就用更高级的算法来解决它！”他们可能会采用“缓存无关”算法，这是一种来自理论计算机科学的复杂技术，旨在对任何大小的缓存都达到渐进最优，而无需知道其参数。其思想是最小化缓存未命中，从而使程序平均速度更快。但这是对安全问题的严重误解。[缓存无关算法](@entry_id:635426)的目标是*性能*，而非*恒定性*。它减少了缓存未命中的*平均*数量，但并未使该数量独立于输入数据。依赖于秘密的访问模式依然存在，泄露也依然存在 [@problem-id:3220263]。真正的解决方案不是对缓存“无关”，而是要敏锐地*意识到*它，并编写其访问模式和执行时间对所有可能的秘密密钥都相同的代码。这就是“恒定时间”编程的原则，这是应用密码学领域一个来之不易的教训。

### 编译器的负担：被泄露的秘密

假设一位[密码学](@entry_id:139166)家编写了一段完美的、恒定时间的代码。工作还没有完成。这段代码必须由编译器翻译成机器指令，而编译器是一个为了速度和大小而进行优化的复杂程序。在其追求优化的过程中，编译器可能在不经意间重新引入了程序员费尽心力消除的那些漏洞。

现代 CPU 有少量称为寄存器的超快存储位置。当一个程序需要的变量多于寄存器数量时，编译器会执行“[寄存器溢出](@entry_id:754206)”：它会暂时将一个变量从寄存器移动到主内存[中程序](@entry_id:751829)栈上一个较慢但更充裕的位置。

现在，假设这个被[溢出](@entry_id:172355)的变量是一个[密码学](@entry_id:139166)密钥。编译器不知道它的敏感性，像对待任何其他数据一样对待它。它将密钥存储到栈上的一个固定位置，稍后再加载回来。监控缓存的攻击者可以看到，每次秘密被溢出时，都会有一次对同一个缓存组的重复且可预测的访问 [@problem_id:3667878]。这个秘密，曾安全地存放在寄存器中，现在被“溢出”到了一个其访问模式可以被窥探的位置。

编译器如何防御这种情况？它可以被教导用攻击者的眼光看待世界。编译器可以不总是使用相同的栈槽，而是为每次[溢出](@entry_id:172355)使用一个不同的、随机选择的槽。或者，它可以通过向其他位置插入几个*伪*[溢出](@entry_id:172355)操作来制造“噪声”，迫使攻击者猜测哪个访问是真的。这些安全措施是有代价的——计算一个随机数或执行额外的内存操作都需要时间——因此编译器必须在一个新的、复杂的权衡中导航：安全与性能 [@problem_id:3667878]。

编译器的影响不止于此。即使是只读数据（如“常量池”中的[查找表](@entry_id:177908)）的放置也成为一个安全决策。正如我们所见，数据相对于缓存行边界的对齐方式会影响泄露。编译器可以在每次构建时，在敏感表之前添加一个随机数量的填充。这种[随机化](@entry_id:198186)意味着攻击者不能再依赖一个稳定的、长期的配置文件来确定哪些缓存行对应哪些秘密值。然而，这引入了一个悖论：对于程序的任何单次运行，一个未对齐的表可能比一个完美对齐的表泄露*更多*的信息，因为访问概率变得不均匀 [@problem_id:3629617]。这个幽灵变得更难捉摸，但它在任何特定时刻的低语实际上可能更响亮。

### [操作系统](@entry_id:752937)：守护者与共犯

[操作系统](@entry_id:752937)（OS）是管理硬件资源和调度进程的总指挥。它处于一个独特的位置，既可以阻止也可以促成[缓存攻击](@entry_id:747048)。

考虑同步[多线程](@entry_id:752340)（SMT），这是一种让单个物理 CPU 核心像两个虚[拟核](@entry_id:178267)心一样，同时执行两个线程的技术。这是一个绝妙的性能技巧，因为它能让核心的功能单元保持忙碌。但这两个线程不仅仅是邻居；它们是共享最私密资源的室友：L1 和 L2 缓存。这种共享创造了一个带宽极大的[侧信道](@entry_id:754810)。如果攻击者的线程与受害者的线程被调度在同一个物理核心上，攻击者可以高保真地观察受害者在缓存中的一举一动。受害者活动的“信号”非常强，而“噪声”很低。[操作系统调度](@entry_id:753016)器的决策，本意是提高吞吐量，却把间谍放在了目标旁边 [@problem_id:3685801]。

一个具有安全意识的[操作系统](@entry_id:752937)可以扮演守护者的角色。它可以学会将 SMT 视为一个潜在的负债。对于高度敏感的工作负载，它可以强制执行核心隔离策略：创建一片核心的“庇护所”，在上面禁用 SMT，并禁止任何不受信任的进程被调度到那里。这在敏感进程和潜在攻击者之间建立了一道坚固的墙，尽管代价是降低了系统利用率 [@problem_id:3685801]。

[操作系统](@entry_id:752937)作为共犯的角色可能更加微妙，甚至延伸到[虚拟内存](@entry_id:177532)的机制本身。当你的程序访问内存时，CPU 必须将你看到的虚拟地址翻译成 RAM 中的物理地址。这个过程，称为[页表遍历](@entry_id:753086)，涉及从内存中读取一个层次化的[页表](@entry_id:753080)。为了加速这个过程，CPU 还有另一个缓存，即[页表遍历](@entry_id:753086)缓存（PWC），它存储最近的翻译结果。而且，由于[共享库](@entry_id:754739)的[页表](@entry_id:753080)可以在进程之间共享，这个 PWC 就成了另一个可用于[侧信道攻击](@entry_id:275985)的共享资源 [@problem_id:3663681]。攻击者仅通过监控保存着指向受害者内存指针的缓存中的争用情况，就能推断出受害者正在运行哪个代码！

在这里，我们再次看到了不同系统层级上攻击与防御之间一场引人入胜的军备竞赛。[操作系统](@entry_id:752937)可以尝试通过仔细地对物理页进行着色来缓解这个问题，确保不同进程的[页表](@entry_id:753080)映射到 PWC 的不同部分。这种软件解决方案提供了灵活性。或者，硬件可以通过为每个 PWC 条目添加一个地址空间标识符（ASID）来提供更稳健的修复，使一个进程不可能命中另一个进程的条目。这种硬件修复更干净、更快，但也有其自身的成本：用于 ASID 标签的额外比特增加了缓存的物理尺寸和功耗 [@problem_id:3645426]。

### 云与虚拟世界：共享房屋中的幽灵

在任何地方，资源共享都没有比在云中更根本的了。[虚拟化](@entry_id:756508)允许多个“客户”[操作系统](@entry_id:752937)在单台物理机上运行，而无服务器平台则在共享的服务器集群上复用成千上万的租户。这整个模型都建立在共享硬件（包括缓存）的理念之上。这为我们的幽灵提供了一个完美的出没之地。

人们可能认为虚拟化层，即虚拟机监控程序，可以简单地禁止客户机使用攻击工具。例如，它可以捕获 `CLFLUSH` 指令，该指令显式地驱逐一个缓存行，从而使经典的 Flush+Reload 攻击失效。但这就像锁上了前门，而幽灵却能穿墙而过。攻击者可以简单地切换到 Prime+Probe 或 Evict+Reload 攻击，这些攻击通过暴力争用来达到同样的目标：访问足够多的自身数据来填满一个缓存组，从而驱逐受害者的数据。基于有限资源的争用这一基本原理仍然是可利用的 [@problem_id:3676132]。现代缓存的包容性属性——即从大型共享 LLC 中驱逐会强制所有私有缓存失效——甚至帮助了攻击者，提供了一种在不同 CPU 核心间同步缓存状态的强大方式 [@problem_id:3676132]。

其影响是巨大的。一个简单的云存储服务，如果缓存最近使用的[数据块](@entry_id:748187)，就可能无意中泄露哪些客户正在访问哪些数据以及访问频率，因为这种重用模式直接转化为可被同地部署的攻击者测量的缓存命中率 [@problem_id:3676125]。我们甚至可以从信号处理的角度来对此泄露进行建模。依赖于秘密的时序差异是“信号”，而随机的系统波动（网络[抖动](@entry_id:200248)、[操作系统](@entry_id:752937)任务）是“噪声”。如果由命中和未命中之间的延迟差距（$L_m - L_h$）定义的信号强度增强，或者噪声水平 $\sigma$ 减小，泄露就会被放大。相反，增加更多的噪声可以抑制或掩盖信号 [@problem_id:3676125]。

这就引出了最后一个美妙的悖论。在一个具有疯狂的、亚毫秒级调度的无服务器平台中，人们会期望由此产生的调度“[抖动](@entry_id:200248)”成为随机噪声的来源，掩盖[缓存攻击](@entry_id:747048)的微弱信号。而且通常情况下，它确实如此。如果[抖动](@entry_id:200248)与受害者的活动无关，它只是增加了[方差](@entry_id:200758)，淹没了信号。但如果调度器的行为与秘密*相关*呢？如果当受害者执行一个依赖于秘密的重计算时，调度器不仅让它运行更长时间，还同时调度了其他增加资源争用的重型工作负载呢？在这种情况下，“[抖动](@entry_id:200248)”就不再仅仅是噪声了。产生未命中的事件（受害者的活动）现在与一个使未命中*更慢*的事件（全系统争用）相关联。命中和未命中之间的平均分离度增大了，这可能增加了信噪比。曾被认为是掩盖噪声来源的调度，现在转变成了一个[信号放大](@entry_id:146538)器 [@problem_id:3676157]。

从单个密码学函数的受控世界到全球云平台的混乱、多租户环境，原理始终如一。缓存的幽灵——这个简单、可观察的事实，即访问你与他人共享的资源会改变其状态——是我们计算架构的一个基本属性。理解它的行为不仅仅是为了修补漏洞；它是为了欣赏我们构建的系统深刻、复杂且往往不那么直观的统一性。