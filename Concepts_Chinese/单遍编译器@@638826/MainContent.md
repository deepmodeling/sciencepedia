## 引言
在计算机科学领域，将人类可读的代码翻译成机器指令是编译器执行的一项基本任务。虽然许多编译器会多次读取源代码以收集信息，但一种特别优雅且高效的设计——单遍编译器——仅需一次遍历即可完成此项壮举。然而，这种方法带来了一个重大挑战：如何在无法预知未来的情况下处理“前向引用”，例如在函数定义之前调用它。本文将剖析那些使单遍编译不仅成为可能，而且功能强大的精妙策略。在第一部分“原理与机制”中，我们将探讨其核心机制，包括使用栈来管理作用域以及用于解决未来跳转的[回填](@entry_id:746635)概念。随后，“应用与跨学科联系”部分将揭示这种延迟提交的原则如何超越计算机科学，在[即时编译](@entry_id:750968)、[化学物理学](@entry_id:199585)和细胞生物学等不同领域中找到共鸣。

## 原理与机制

想象一下，你接到一个任务，要将一本英文小说翻译成法文。但有一个限制：你必须在单次遍历中完成。你读第一个英文单词，写下其法文对应词，然后处理第二个单词。你被禁止回顾已写下的内容，也不能跳到后面看即将出现的内容。这就是**单遍编译器**的世界。它只从头到尾读取一次你的源代码（一个线性的字符序列），并在此过程中生成机器可读的指令。

起初，这似乎是一个不可能的约束。无论是人类语言还是编程语言，都充满了前向引用和相互关联的思想。你怎么可能翻译一个像“正如我们将在最后一章看到的，我们英雄的命运从一开始就已注定”这样的句子，却不知道最后一章发生了什么呢？

### 单向前进箭头的束缚

这就是单遍编译器面临的核心挑战：时间单向前进的箭头带来的束缚，这在文件的顺序读取中得到了体现。许多完全合乎逻辑的编程结构似乎都需要预知未来的知识。

以调用函数为例。在许多语言中，你可能会在定义 `calculate_results()` 函数的代码出现之前，就编写一行调用该函数的代码。一个简单的翻译器在遇到这个调用时会束手无策。这个函数需要多少个参数？它们应该是什么数据类型？它返回什么？没有这些信息，它既无法检查调用是否有效，也无法生成正确的指令。**多遍编译器**有一个简单的解决方案：它作弊了。它会先通读一遍代码，仅仅为了构建一个包含所有函数及其签名的总目录，然后在第二遍中，利用这张完整的“地图”进行实际的翻译 [@problem_id:3678636]。

当涉及到像[相互递归](@entry_id:637757)的[数据结构](@entry_id:262134)这样的概念时，问题变得更加棘手。想象一下定义一个 `Person`，他有一个 `Children` 列表，而每个 `Child` 也是一个 `Person`。为了知道为 `Person` 分配多少内存，编译器需要知道 `Child` 的大小，而 `Child` 本身就是一个 `Person`。这是一个经典的先有鸡还是先有蛋的问题。在单遍编译中，当编译器首次看到 `Person` 的定义时，它完全不知道如何解决这种[循环依赖](@entry_id:273976)关系 [@problem_id:3678636]。

面对这种束缚，单遍编译器不能简单地放弃。相反，它采用了两种极其优雅的策略，将这些看似无法克服的问题转化为可管理的难题。第一种策略解决嵌套上下文的问题，第二种则解决更为困难的前向跳转问题。

### 结构化内存：栈的力量

我们首先来解决编译器如何理解嵌套上下文的问题，比如一个代码块嵌套在另一个代码块中。假设你在主程序中将一个变量 `y` 设置为 `1`。然后，你进入一个特殊的代码块，在这里，`y` 的值暂时变为 `10`。在这个块内部，你又进入一个更小、更特殊的代码块，其中 `y` 的值为 `100`。

当你在最内层的块中时，`y` 是 `100`。当你退出它时，你回到了中间的块，`y` 的值恢复为 `10`。当你再退出那个块时，你回到了主程序，`y` 再次变为 `1`。这个概念被称为**[词法作用域](@entry_id:637670)**：一个名称的含义取决于它在代码的嵌套结构中的位置 [@problem_id:3658735]。

单遍编译器能够漂亮地处理这个问题，而无需回溯。它使用一种能完美反映这种嵌套关系的[数据结构](@entry_id:262134)：**栈**。可以把它想象成一叠盘子。当编译器进入一个新的作用域（比如我们那个 `y` 为 `10` 的中间块）时，它会在栈顶放上一个新盘子。在这个盘子上，它写下该作用域的所有新定义：“y = 10”。要查找 `y` 的含义，它只需查看最上面的盘子。如果找不到，就看下面的盘子，以此类推。

当它进入最内层的块（`y = 100`）时，它会将另一个带有新规则的盘子压入栈顶。查找 `y` 时会立即在最上面的盘子上找到 `100`。当它退出该块时，它只需将顶部的盘子弹出并丢弃。现在，原来的顶层盘子（带有“y = 10”）又暴露了出来。这种推入和弹出机制与代码的单向前向读取完美同步。它提供了一个结构化的临时内存，优雅地解决了嵌套作用域内名称的含义问题，而且全部在单次遍历中完成。

### 留下线索的艺术：[回填](@entry_id:746635)

栈解决了嵌套定义的问题，但它无法帮助我们跳转到未来。编译器如何处理一个 `if-then-else` 语句呢？

`if (condition) { ... A ... } else { ... B ... }`

当编译器处理 `condition` 时，它会生成一条指令，意为：“如果条件为假，跳转到代码块 `B` 的开始处。”但问题在于：它还没有看到代码块 `B`！`B` 在后面的某个地方，编译器不知道它的地址会是什么。

这时，一个高明的技巧就派上用场了：**[回填](@entry_id:746635)**（backpatching）。这个想法如此简单而强大，感觉就像一个魔术。编译器不是去猜测未来的地址，而是生成一个目标地址为空白的[跳转指令](@entry_id:750964)。

`jump_if_false to ???`

然后，它做了一件聪明的事。它记下*这条指令本身*的地址——也就是“???”的位置——并将其写在一个小小的待办事项列表上。我们称之为 `false_list`。接着它继续翻译代码块 `A`。在代码块 `A` 的末尾，它需要跳过代码块 `B`，到达接下来的代码。同样，它不知道那个地址，所以它生成另一个占位符跳转，并将其位置添加到一个不同的待办事项列表，即 `next_list`。

现在，编译器终于到达了代码块 `B` 的开头。在这一精确时刻，它知道了 `B` 的地址！就是当前的位置。于是，它查阅它的待办事项列表 `false_list`，回到那里记录的地址，并将空白的 `???` 目标“修补”为 `B` 的地址。这条线索把它引回了家。在处理完 `B` 之后，它知道了后面代码的地址，并可以同样地修补其 `next_list` 上的跳转 [@problem_id:3623464]。

这种留下占位符“线索”并在稍后修补它们的机制是单遍控制流生成的核心。它允许编译器在不违反其单向前进规则的情况下解决前向跳转。这种“修补”是一种受到严格限制的回溯形式，只允许填充这些预先指定的空白。

这个方案真正的美在于其[可扩展性](@entry_id:636611)。一个程序可能包含嵌套循环与 `break` 语句、`goto` 跳转到[词法作用域](@entry_id:637670)内的标签，以及 `return` 语句，所有这些都交织在一起 [@problem_id:3623492] [@problem_id:3623525]。编译器只需为每种未解决的跳转维护不同的待办事项列表。内层循环中的一个 `break` 会被放在一个列表上，在该循环结束时进行修补。一个函数 `return` 会被放在另一个列表上，只有在整个函数完成后才进行修补。栈告诉编译器一个 `goto L` 指的是*哪个*标签 `L`，而[回填](@entry_id:746635)列表则跟踪*谁*需要在 `L` 的最终地址被发现后知道它。这两种机制完美和谐地协同工作。

### 统一机制：作用域、跳转与延迟之美

我们发现了一个深刻的原则，它使得单遍编译成为可能：**延迟提交原则**。

面对未知，编译器不会去猜测，也不会停止。它记录下问题，然后继续前进。符号表栈延迟了一个名称的“最终”含义，允许它根据当前的局部作用域而改变。[回填](@entry_id:746635)则延迟了跳转与其目的地的绑定，一直等到目标的地址成为一个既定事实。

这个想法可以更进一步。如果在编译期间，我们执行了像[函数内联](@entry_id:749642)这样的优化，它会插入一大块新代码并移动所有后续的地址，那该怎么办？如果我们记录了一个*预测的*地址，我们的[回填](@entry_id:746635)就会失败。稳健的解决方案是让延迟更加抽象。我们不是为预测的地址创建一个待办事项列表，而是为**符号标签**创建一个列表。编译器记录一个跳转“想要去 `L_merge`”。`L_merge` 最终在哪里并不重要；无论它最终被放在何处，编译器都会使用其最终的、真实的地址来修补所有等待它的跳转 [@problem_id:3623503]。

这就是单遍编译器内在的美和统一性。它不是一个通过反复重读文本直到理解为止的蛮力工具。它是一台优雅、高效的机器，通过结构化内存和对未来解析的承诺的巧妙结合，在代码流中穿行。它教给我们一个远超计算机科学的强大教训：在一个未来未知的世界里，最稳健的策略不是去预测未来，而是建立一个系统，能在时机成熟时优雅地填补细节。

