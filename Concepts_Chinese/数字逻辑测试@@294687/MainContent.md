## 引言
现代[数字电路](@article_id:332214)是驱动我们技术世界的引擎，它们是包含数十亿晶体管的复杂奇迹。但这种复杂性也带来了巨大的挑战：我们如何保证单个微观瑕疵不会危及整个系统？我们无法目视检查每一个组件，因此必须依赖[数字逻辑测试](@article_id:349826)这门艺术和科学来诊断那些看不见的缺陷。本文探讨了用于确保电路可靠性的方法，旨在弥合完美逻辑设计与不完美物理现实之间的关键鸿沟。读者将首先踏上“原理与机制”的基础之旅，揭示失效的抽象模型和如同侦探般的故障检测过程。随后，“应用与跨学科联系”部分将揭示这些原理如何通过[可测试性设计](@article_id:354865)和[内建自测试](@article_id:351559)等巧妙的工程解决方案付诸实践，正是这些方案使当今复杂的电子产品值得信赖。

## 原理与机制

想象一下，你负责建造有史以来最精巧、最宏伟的时钟。它有数百万个齿轮、杠杆和弹簧，所有部件都完美和谐地工作。但在组装完成后，你被告知可能存在一个微小的瑕疵——一个齿轮的齿略有弯曲，或者一个弹簧的刚度稍有偏差。你无法打开时钟来检查每个部件。你该如何确定这个工程奇迹是完美的，还是包含一个日后会导致其失灵的隐藏缺陷呢？

这正是设计驱动我们世界的[数字电路](@article_id:332214)的工程师所面临的挑战。一个现代计算机芯片就像一座拥有数十亿晶体管的城市，单个原子的错位就可能使其报废。我们无法看到这些缺陷，因此必须设计出巧妙的方法来推断它们的存在。这就是[数字逻辑测试](@article_id:349826)的艺术和科学，它始于一个简单而强大的思想：为可能出错的情况建立一个模型。

### 不完美逻辑的世界：[故障模型](@article_id:351384)

在物理学中，我们通常从一个简化的模型——如无摩擦平面或质点——开始，以抓住问题的核心。在电路测试中，我们做同样的事情。我们不可能考虑到每一种可以想象到的物理缺陷。取而代之，我们使用一种称为**[故障模型](@article_id:351384)**的抽象概念。

其中最常见且在历史上最重要的就是**单[固定型故障模型](@article_id:348094)**。它做出了一个极其简单的假设：一个缺陷将导致整个电路中恰好一条导线（或**线网**）永久地“固定”在某个逻辑值上，要么是`0`（**固定于0**故障），要么是`1`（**固定于1**故障）。

让我们看看这意味着什么。考虑一个简单的双输入[与门](@article_id:345607)。它的功能是仅当其两个输入 $A$ 和 $B$ 均为`1`时，输出`1`。但如果它有缺陷呢？假设一个制造缺陷导致其输出线 $Y$ 固定于1。无论你向 $A$ 和 $B$ 发送什么信号，输出始终是`1`。这个门的行为，它的本质特性，都被破坏了。它的[真值表](@article_id:306106)——记录其特性的文件——不再是 $Y = A \land B$，而仅仅是 $Y = 1$ [@problem_id:1966741]。

当然，这个固定型模型是一种简化。大自然在引入缺陷方面更具创造力。有时，两条相邻的导线可能会意外短路，形成**[桥接故障](@article_id:348321)**。如果这种桥接是**显性1**（或线或）类型，那么两条线上的逻辑值就变成了它们原始信号的逻辑或。如果这种情况发生在[与门](@article_id:345607)的两个输入端，就会发生一件奇怪的事。该门在两个输入端都接收到相同的信号，即 $A \lor B$。然后[与门](@article_id:345607)函数计算 $(A \lor B) \land (A \lor B)$，根据布尔代数定律，这简化为 $A \lor B$。我们有缺陷的[与门](@article_id:345607)奇迹般地转变成了一个或门！ [@problem_id:1934758]。

尽管简单，固定型模型却出奇地有效。经验表明，为寻找[固定型故障](@article_id:350358)而设计的测试，也恰好能捕捉到各种其他更复杂的物理缺陷。它为我们提供了一种系统性的方法，来着手思考一个看似无限的问题。对于任何给定的电路，我们可以列出每一条线网——每个输入、每个输出以及门之间的每个连接——并为每一条考虑两种可能的故障。即使对于一个简单的2选1多路选择器，这也可能导致需要考虑14种不同的单[固定型故障](@article_id:350358) [@problem_id:1934762]。对于一个微处理器来说，这个数字是天文级别的。

### 侦探的技艺：发现故障

那么，我们有了一份嫌疑犯名单——所有可能的[固定型故障](@article_id:350358)。我们如何抓住其中一个？我们需要设计一次“审讯”，一组特定的输入，称为**[测试向量](@article_id:352095)**，它能让有故障的电路暴露自己。当且仅当故障电路的输出与健康、无故障电路的输出不同时，一个[测试向量](@article_id:352095)才能检测到该故障。

为了实现这一点，必须满足两个条件。可以把它想象成一条证据链。

1.  **故障激活**：首先，你必须“触发”故障。你必须施加一些输入，使得在正常电路中，故障导线会呈现出*相反*的值。如果你怀疑一条线固定于0，你的[测试向量](@article_id:352095)必须试图强制该线为`1`。如果它固定于1，你必须试图强制它为`0`。如果你不这样做，故障就会潜伏不动；在故障位置，好电路和坏电路之间没有区别，也就无从检测。

2.  **故障传播**：激活故障会在故障位置产生一个“错误信号”——一个本该是`0`的地方出现了`1`，或者反之。但这个位置深埋在电路内部。为了让错误被看到，它必须通过后续的逻辑门传播，直到到达一个我们能实际测量的主输出端。

让我们用一个小电路扮演侦探，其中输出 $F$ 由 $F = (A \land B) \oplus (B \land C)$ 给出 [@problem_id:1928183]。让我们施加[测试向量](@article_id:352095) $(A, B, C) = (1, 1, 0)$。在健康电路中，$A \land B = 1$ 且 $B \land C = 0$，所以输出 $F$ 为 $1 \oplus 0 = 1$。这是我们预期的“真相”。

现在，让我们看看这个[测试向量](@article_id:352095)揭露了哪些罪犯。
-   假设输入 $C$ 固定于1 ($C/1$)。对于我们的向量，我们*[期望](@article_id:311378)* $C$ 是`0`。这种差异*激活*了故障。故障电路现在看到的是 $(A, B, C) = (1, 1, 1)$。项 $B \land C$ 变为 $1 \land 1 = 1$。输出 $F$ 变为 $(A \land B) \oplus (B \land C) = 1 \oplus 1 = 0$。我们预期的输出是`1`，但我们看到了`0`。错误已经传播到了输出端！故障被检测到了。
-   那么输入 $A$ 固定于0 ($A/0$) 呢？预期的输入是 $A=1$，所以故障被激活。电路计算出 $F = (0 \land 1) \oplus (1 \land 0) = 0 \oplus 0 = 0$。同样，输出是`0`而不是`1`。检测到了！

这个施加向量并追踪其后果的过程是数字测试的基本机制。一套好的[测试向量](@article_id:352095)是指，它们合在一起能够检测出电路中每一个可测故障。

### 机器中的幽灵：不可测故障

这引出了一个有趣的问题：所有故障都是可测的吗？直觉上似乎是，如果一个组件是电路的一部分，那么该组件的故障必然是可检测的。但逻辑的世界更为微妙。

考虑一个计算函数 $F = AB + \overline{A}C + BC$ 的电路 [@problem_id:1928138]。让我们尝试为承载 $BC$ 信号的导线上的固定于0故障寻找一个测试。
-   **激活**：要激活这个故障，我们必须尝试使 $BC$ 这条线为`1`。这需要同时设置 $B=1$ 和 $C=1$。
-   **传播**：$BC$ 信号与 $AB$ 和 $\overline{A}C$ 一同送入一个最终的或门。要传播[或门](@article_id:347862)一个输入上的变化（从好电路中的`1`变为坏电路中的`0`），所有其他输入*必须*为`0`。如果任何其他输入为`1`，它将强制或门的输出为`1`，无论我们的 $BC$ 信号如何变化，从而屏蔽了故障。

因此，在 $B=1$ 和 $C=1$ 的情况下，我们需要 $AB=0$ 且 $\overline{A}C=0$。条件 $AB=0$ 在 $B=1$ 时意味着 $A=0$。条件 $\overline{A}C=0$ 在 $C=1$ 时意味着 $\overline{A}=0$，即 $A=1$。

于是我们得到了一个悖论！为了测试这个故障，我们需要输入 $A$ 同时为`0`和`1`。这是不可能的。因此，不存在针对此故障的[测试向量](@article_id:352095)。它是**不可测**的。

这意味着什么？一个不可测故障不仅仅是测试工程师的头痛问题；它是对电路设计的一个深刻陈述。这个特定的故障之所以不可测，是因为逻辑项 $BC$ 是**[逻辑冗余](@article_id:353051)**的。函数 $AB + \overline{A}C$ 已经涵盖了所有 $BC$ 可能起关键作用的情况。这是[布尔代数](@article_id:323168)中一个著名的恒等式，称为[共识定理](@article_id:356626)：$AB + \overline{A}C + BC = AB + \overline{A}C$。电路中包含一个不做任何有效工作的部件！一个不可测故障就是这种冗余的幽灵，是一个不必要组件的逻辑回响。

### 少即是多：故障压缩的力量

正如我们所见，电路中潜在故障的列表可能极其庞大。逐一测试所有故障在计算上是不可行的。幸运的是，我们可以更聪明。关键的洞见在于，许多不同的物理故障可能产生完全相同的故障行为。如果我们能识别出这些分组，我们只需要为每组的一个代[表生](@article_id:349317)成一个测试即可。这个过程称为**故障压缩**。

最强大的压缩形式来自**故障等效**。如果两个故障以完全相同的方式改变了电路的功能，那么它们就是等效的。从外部看，它们是完全**不可区分**的。

-   一个极简的例子是反相器，其功能是 $Y = \neg A$。一个输入 $A$ 固定于1的故障会强制输出为 $\neg 1 = 0$。一个输出 $Y$ 固定于0的故障会强制输出为……嗯，`0`。这两个故障，一个在输入端，一个在输出端，产生了相同的故障函数 $Y=0$。任何能检测其中一个的[测试向量](@article_id:352095)也必然能检测另一个，因为它们的测试集是相同的 [@problem_id:1934751] [@problem_id:1934730]。它们属于同一个等效类。

-   门的结构本身也能产生等效性。在一个双输入[与非门](@article_id:311924)中，其输出在两个输入都为`1`时为`0`，输入 $A$ 上的固定于0故障会强制输出为 $\neg(0 \land B) = 1$。输入 $B$ 上的固定于0故障会强制输出为 $\neg(A \land 0) = 1$。两个故障都将该门变成一个总是输出`1`的设备。它们是不可区分的 [@problem_id:1934740]。

-   等效性也可以跨越多个门。在计算 $Z = (A \land B) \lor C$ 的电路中，我们称 $A \land B$ 的中间连线为 $w$。$w$ 上的固定于1故障使得函数变为 $Z = 1 \lor C = 1$。最终输出 $Z$ 上的固定于1故障也使得函数变为 $Z=1$。这两个故障是等效的 [@problem_id:1928165]。

通过识别和压缩这些等效故障，测试工程师可以大幅缩减故障列表，将一个棘手的问题变成一个可管理的问题。这是一个纯粹的逻辑推理如何带来巨大现实世界效率的完美例子。一个相关的概念，**故障支配**，通过识别一个故障的[测试集](@article_id:641838)是另一个故障[测试集](@article_id:641838)的超集，进一步精简了测试生成的工作 [@problem_id:1934751]。

### 案情变得复杂：当故障串通一气

我们的主要工具，单[固定型故障模型](@article_id:348094)，建立在一个脆弱的假设之上：一次只有一个地方出错。但如果两个故障同时发生呢？情况会变得出人意料地复杂，就像一个有多个罪犯的侦探故事，他们的行为相互干扰。

最反直觉的现象之一是**故障屏蔽**。当第二个故障 $f_2$ 的存在阻止了一个[测试向量](@article_id:352095)检测第一个故障 $f_1$ 时，就发生了这种情况。

让我们看一个具体的案例 [@problem_id:1928157]。考虑一个电路，有一个[测试向量](@article_id:352095) `T=(1,1,0,0)`，设计用于检测故障 $f_1$（一个内部节点 $n_1$ 固定于0）。在无故障电路中，`T` 产生输出 `1`。当只有 $f_1$ 存在时，`T` 产生输出 `0`。这个差异（`1` vs `0`）意味着故障被检测到。

现在，让我们引入第二个串通的故障 $f_2$：输入 `D` 固定于1。当 $f_1$ 和 $f_2$ 同时存在于电路中时，一件奇妙的事情发生了。由 $f_1$ 产生的错误信号开始沿着一条路径传播，但 $f_2$ 的存在产生了另一个效应，沿着另一条路径传播。这两个错误信号在一个下游的门处相遇，并且对于这个特定的[测试向量](@article_id:352095)，它们相互抵消了。双重故障电路的最终输出是 `1`——与无故障电路的输出相同！

测试失败了。$f_2$ 的存在为 $f_1$ 创造了一个完美的“不在场证明”，掩盖了它的存在。这发人深省地提醒我们模型存在局限性。虽然单故障假设让我们走得很远，但硅物理的真实世界总是带着新的、错综复杂的谜题等着我们，推动我们开发出更复杂的方法，以确保我们构建的逻辑是我们能够信任的逻辑。