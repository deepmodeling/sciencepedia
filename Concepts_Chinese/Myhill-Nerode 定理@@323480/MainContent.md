## 引言
计算的核心在于一个基本问题：解决一个问题所需的绝对最小内存量是多少？无论是扫描文本以查找关键词、验证网络数据，还是破译遗传密码，许多任务都涉及识别信息序列中的模式。我们通常使用[有限自动机](@article_id:321001)——一种根据输入在状态之间转换的简单机器——来建模这些任务。但我们如何能确定我们的机器是最高效的呢？我们又如何识别那些对于任何有限内存的机器来说都根本不可能解决的问题呢？

Myhill-Nerode 定理为这些问题提供了一个惊人优雅且明确的答案。它在一个语言的抽象属性和识别该语言所需机器的具体结构之间架起了一座桥梁。本文将揭开这个理论计算机科学基石的神秘面纱。在“原理与机制”部分，我们将深入探讨该定理的核心概念——不可区分性和等价类，展示它们如何决定最高效自动机的结构。随后，在“应用与跨学科联系”部分，我们将探索该定理深远的影响，从设计[搜索算法](@article_id:381964)和执行模运算，到理解[生物信息学](@article_id:307177)等领域的计算限制。

## 原理与机制

想象一下，你是一家高级俱乐部门口的保安。这家俱乐部有一条奇特的入场规则：只有当会员卡上的完整字母序列构成一个有效的“密码”时，持卡人才能入场。你，作为保安，必须检查这些卡片。问题是，你的记性很差。当别人一次一个字母地向你展示卡片时，你不可能记住你看到的整个序列。相反，你只能在脑海中保持一个简单的想法——一种“状态”。例如，你的状态可以是“到目前为止一切正常”、“哎呀，出问题了”，或者“看起来有希望，只需要一个‘Z’就完成了”。

问题是，对于一套给定的规则，你需要多少个绝对最小的、不同的“状态”才能正确完成工作？这正是问题的核心。你在寻找最高效的心智模型，即完成任务的最小机器。Myhill-Nerode 定理为我们提供了一种惊人优雅的方式来回答这个问题。它不仅给出一个数字，更揭示了机器试图理解的语言的本质。

### 不可区分性游戏

让我们把这个想法转换成一个游戏。假设我们有一个语言，它只是一个“有效”字符串的集合，我们称之为 $L$。现在，任选两个可能成为更长单词前缀的字符串，比如 $x$ 和 $y$。我们说 $x$ 和 $y$ 是**不可区分的**（indistinguishable），如果为了构成 $L$ 中的一个有效词，它们是完全可以互换的。无论我们在它们后面附加什么后缀 $z$，结果要么*都属于* $L$，要么*都不属于* $L$。形式上，如果对于每一个可能的字符串 $z$，$xz$ 属于 $L$ 当且仅当 $yz$ 也属于 $L$，那么 $x$ 和 $y$ 就是不可区分的。

反之，如果你能找到哪怕一个“致命”后缀 $z$ 来区分它们——例如，使得 $xz$ 是有效词而 $yz$ 不是——那么 $x$ 和 $y$ 就是**可区分的**（distinguishable）。它们让未来进入了不同的状态，一个希望识别该语言的机器必须记住这种差异。

这个游戏将所有可能的字符串划分成多个组，即**等价类**（equivalence classes）。在每个组内，所有字符串彼此都是不可区分的。从语言的角度来看，它们都完成了完全相同的工作，并以完全相同的方式为未来做好了准备。

### 有限内存，有限状态

现在，让我们回到我们的机器——**[确定性有限自动机](@article_id:325047)（DFA）**。DFA 就像我们的保安：它一次读取一个符号，并在有限数量的状态之间转换。它的当前状态就是它对过去的所有记忆。那么，这些状态必须代表什么呢？

Myhill-Nerode 定理的核心洞见在于，一个最小 DFA 的状态*就是*这些等价类。每个状态精确地对应于这些不可区分字符串组中的一个。如果两个前缀 $x$ 和 $y$ 将机器引导到同一个状态，那么机器实际上已经忘记了它们之间的区别。只有当它们确实是不可区分的时候，这样做才是允许的。如果它们是可区分的，机器就犯了一个致命的错误，因为它将不再拥有在未来某些输入上做出正确决策所需的信息。

这意味着，对于一个语言，任何有效的 DFA 的状态数必须至少等于[等价类](@article_id:316440)的数量。最小 DFA 实现了这个下限。对于任何给定的具有 $n$ 个状态的 DFA，真正的最小 DFA 将有 $m$ 个状态，其中 $m \le n$ [@problem_id:1367351]。该定理不仅给了我们构建*一个*机器的工具，更给了我们构建*最佳*机器的工具。

让我们通过一个非常简单的语言来实际看看这个过程：$L_N = \{a^N\}$，它在字母表 $\Sigma=\{a\}$ 上只包含一个字符串，即 $a$ 重复 $N$ 次 [@problem_id:1464310]。
让我们用它的前缀玩一下不可区分性游戏：
- 空字符串 $\epsilon$ 是一个前缀。要使它成为单词 $a^N$，我们需要附加后缀 $z=a^N$。
- 前缀 $a^1$ 是不同的。要使它成为 $a^N$，我们需要后缀 $z=a^{N-1}$。
- 前缀 $a^i$ 和 $a^j$（对于 $i \neq j$ 且 $i, j \le N$）是可区分的，因为它们需要不同的后缀（$a^{N-i}$ 和 $a^{N-j}$）来完成。
所以，$\epsilon, a^1, a^2, \ldots, a^N$ 都属于不同的[等价类](@article_id:316440)。这已经有 $N+1$ 个类了。

那么像 $a^{N+1}$ 这样的前缀呢？我们能给它加上任何后缀 $z=a^k$ 使之成为 $a^N$ 吗？不行，它的长度已经太长了。对于 $a^{N+2}$、$a^{N+3}$ 等也是如此。所有长度大于 $N$ 的字符串彼此都是不可区分的。无论你附加什么后缀，你都永远无法回到该语言中。它们都属于一个单一的“死胡同”等价类。

所以，总共有 $(N+1)$ 个类（对于长度不超过 $N$ 的前缀），再加上一个“死胡同”类，总共得到 $N+2$ 个[等价类](@article_id:316440)。根据 Myhill-Nerode 定理，识别该语言的最小 DFA 必须恰好有 $N+2$ 个状态。这没有猜测的成分，而是一个数学上的确定性。

### 状态的交响曲

当语言规则更加复杂时，真正的美妙之处便浮现出来。自动机的状态开始代表更抽象的属性。考虑一个在 $\{0, 1, 2\}$ 上的语言，其中一个字符串是有效的，如果其数字之和能被 4 整除 [@problem_id:1421368]。当我们的机器读取一个字符串时，它必须记住什么信息？它需要记住字符串的长度吗？还是确切的和？

都不需要。对未来唯一重要的信息是**数字之和模 4**。
- 如果一个前缀 $x$ 的数字和是 5（即 $1 \pmod 4$），另一个前缀 $y$ 的和是 13（也是 $1 \pmod 4$），那么它们是不可区分的。我们添加的任何后缀 $z$ 都会使它们的和发生相同的变化，所以 $s(x)+s(z)$ 能被 4 整除当且仅当 $s(y)+s(z)$ 也能。
- 然而，一个和为 $1 \pmod 4$ 的前缀显然与一个和为 $2 \pmod 4$ 的前缀是可区分的。我们只需附加一个数字和为 3 的字符串（比如字符串“12”）。第一个字符串的总和变为 $1+3=4$（有效），而第二个变为 $2+3=5$（无效）。

我们唯一需要保留的“记忆”是和模 4 的四种可能结果：$\{0, 1, 2, 3\}$。这些就是我们的四个[等价类](@article_id:316440)。因此，最小 DFA 恰好需要 4 个状态。类似的逻辑也适用于一个追踪 $(n_a(w) - n_b(w)) \pmod 3$ 的语言；它恰好需要 3 个状态，每个状态对应于模 3 的一种可能余数 [@problem_id:1424593]。状态不仅仅是图中的节点；它们是定义该语言的数学属性的物理体现。有时这个属性并不明显，需要巧妙的洞察力才能发现，例如意识到具有相同数量的“01”和“10”子串的条件等价于仅检查字符串是否以相同字符开头和结尾 [@problem_id:1396487]。

### 当内存耗尽：无限情况

因此，一个语言是正则的，当且仅当它的不可区分关系能导出有限个[等价类](@article_id:316440)。但如果不能呢？如果我们玩游戏时发现有无限个组呢？

这就把我们带到了 Myhill-Nerode 定理的另一面：一个证明语言**非正则**的强大工具。该定理的[逻辑推论](@article_id:315479)是，一个语言是非正则的，当且仅当可以找到一个无限的字符串集合，其中所有字符串都两两可区分 [@problem_id:1387285]。

让我们以一个经典的非[正则语言](@article_id:331534)为例，$L = \{0^n 1^n \mid n \ge 0\}$。这个语言由一些 0 后面跟着*完全相同*数量的 1 组成。让我们试着为它构建一个机器。

考虑无限前缀集合 $S = \{\epsilon, 0, 00, 000, \ldots\}$。让我们从这个集合中任意挑选两个不同的字符串，比如 $x = 0^i$ 和 $y = 0^j$，其中 $i \neq j$。它们是可区分的吗？
是的！让我们选择“致命”后缀 $z = 1^i$。
- 字符串 $xz$ 变为 $0^i1^i$。根据定义，这个字符串在 $L$ 中。它是一个有效的密码。
- 字符串 $yz$ 变为 $0^j1^i$。由于 $i \neq j$，这个字符串*不在* $L$ 中。

我们成功地区分了 $0^i$ 和 $0^j$。由于我们可以对*任何*一对 $i$ 和 $j$ 这样做，这意味着[无限集](@article_id:297614)合 $S$ 中的每一个字符串都属于它自己独特的等价类。

这对我们可怜的保安，也就是 DFA，意味着什么呢？为了识别这个语言，它需要为“我看到了一个 0”、“我看到了两个 0”、“我看到了三个 0”等等，直到无穷，都准备一个单独的状态。它需要能够无限地计数。但是一个**有限**自动机不能有无限个状态。它的内存会耗尽。

因此，没有任何 DFA 能够识别语言 $L$。这个语言不是正则的。这不仅仅是某个特定机器设计的失败；Myhill-Nerode 定理证明了，对于任何有限内存的机器来说，这项任务本身就是不可能的。它揭示了计算中的一个基本边界，将可以用有限内存解决的问题与那些不能解决的问题分开了。