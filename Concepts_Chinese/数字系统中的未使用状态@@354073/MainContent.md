## 引言
在数字设计的精确世界中，一个系统的行为由一系列状态定义——这是一场在一组预定操作中精心编排的舞蹈。然而，实现这场舞蹈的物理硬件通常包含大量其他可能的状态，这些状态本不应被访问。这些就是“未使用状态”，它们是作为二进制逻辑内在结果而存在的幻象配置。本文探讨了一个在基础设计中常被忽略的关键问题：当一个故障，如电源浪涌或随机噪声，将系统抛入这些未知状态之一时，会发生什么？其后果可能从一个小故障到整个系统的完全锁定不等。本次探索分为两个关键部分。第一章“原理与机制”深入探讨了未使用状态的基本性质，解释了它们如何产生、可能造成的锁定循环的危险，以及像“[无关项](@article_id:344644)”条件这样的设计捷径如何无意中设下这些陷阱。第二章“应用与跨学科联系”则将重点转向解决方案，详细介绍了构建鲁棒的自纠正系统的方法，并揭示了该问题在人工智能等领域中惊人的相似之处。

## 原理与机制

想象你正在建造一台机器。不是任何普通的机器，而是一台数字机器，一台由开关和线路组成的思维机器，比如一个自动灌溉系统的控制器，或是一个数字手表里的简单计数器。这台机器在任何特定时刻的“状态”就是其存储元件（我们称之为**[触发器](@article_id:353355)**）中保存的开/关值的集合——也就是1和0的集合。如果你愿意，可以把这看作是机器当前的“想法”。

数字硬件的美妙与诅咒在于其不容置疑的精确性。如果你用三个[触发器](@article_id:353355)来构建你的机器，你不仅仅是为所需的少数几个状态创造了足够的存储空间；你实际上创造了一个包含 $2^3 = 8$ 个可能状态的宇宙。这三个[触发器](@article_id:353355)上所有1和0的组合都是物理上可能的配置。你的机器*可以*存在于这八个状态中的任何一个，就像一个有三个电灯开关的房间有八种可能的照明模式一样。

### 机器中的幽灵：什么是未使用状态？

大多数情况下，一个设计只需要这些可能状态的一个特定子集来完成其工作。一个设计用来从0计数到5的计数器（一个“模6”计数器）只需要六个不同的状态。但要表示六个状态，你至少需要三个[触发器](@article_id:353355)，这总共给了你八个可能的配置。对应于0, 1, 2, 3, 4, 5的二进制模式的状态是**使用状态**。它们构成了机器正常操作的常规路径。

那么，另外两个状态，即二进制模式为6 (`110`) 和7 (`111`) 的状态呢？它们就是**未使用状态** [@problem_id:1947777]。它们就像你从未计划进入的房子里的房间。它们不是操作蓝图的一部分，但它们确实存在，被构建在硬件的结构之中。有时，使用状态的集合并非一个简单的序列。一个专门的电路可能只使用那些具有特定数量'1'的状态，即所谓的恒重码。如果你有一个包含6个[触发器](@article_id:353355)（总共有 $2^6 = 64$ 个状态）的系统，设计为只使用恰好有三个'1'的状态，那么你将得到 $\binom{6}{3} = 20$ 个使用状态，剩下多达44个状态成为机器中未使用的幽灵 [@problem_id:1965720]。

在任何非平凡的数字系统中，未使用状态的存在不是例外，而是常态。一个简单灌溉系统的控制器可能由五个操作状态定义，如 `IDLE`、`WATERING` 和 `FAULT`。如果用三个[触发器](@article_id:353355)实现，就会剩下 $8 - 5 = 3$ 个[二进制代码](@article_id:330301)，它们不对应任何定义的操作 [@problem_id:1969129]。这些就是机器的幻象。

### 幽灵去向何方？不可避免的下一步

这就引出了一个关键问题。如果机器因为某些随机事件——比如宇宙射线击中一个[触发器](@article_id:353355)，或者突然的电源浪涌——被猛地抛入这些未使用状态之一，会发生什么？它会崩溃吗？它会冻结吗？

令人惊讶的答案是：它会继续运行。决定机器*下一个*状态的[逻辑门](@article_id:302575)是无情的。它们是由AND、OR和NO[T门](@article_id:298922)组成的网络，根据当前状态计算出一个新状态。这个逻辑没有“好”状态和“坏”状态的列表。它只是将当前1和0的模式作为输入，并为下一个时钟周期产生一个新的模式。一个未使用状态只是另一种输入模式。

因此，在整个 $2^N$ 的状态宇宙中，每一个状态，无论使用与否，都有一个明确定义的到下一个状态的转换。这些幽灵不是静止的；它们在移动。

让我们看一个简单的2位计数器，其状态为 $(Q_A Q_B)$。它的“大脑”由逻辑方程 $D_A = Q_A \oplus Q_B$ 和 $D_B = \overline{Q_A}$ 定义。如果我们追踪它的行为，会发现它被设计为循环通过 $00 \to 01 \to 11 \to 00$。状态 $10$ 是未使用的。但如果我们的计数器意外地在上电时处于状态 $10$ 呢？我们可以简单地将 $Q_A=1$ 和 $Q_B=0$ 代入方程：

$D_A = 1 \oplus 0 = 1$
$D_B = \overline{1} = 0$

下一个状态是 $10$。机器卡住了！它从 $10$ 转换到 $10$，一遍又一遍。这是我们第一次瞥见一个危险的现象：**锁定状态**，一个在预期操作循环之外的固[定点](@article_id:304105) [@problem_id:1908351]。从某种意义上说，这台机器并没有坏，它的逻辑仍在完美地工作。但它被困住了，徒劳地在一个毫无用处的状态中空转。

### 陷阱触发：锁定循环与系统故障

这种“锁定”可能比单个状态更隐蔽。想象一个3位[约翰逊计数器](@article_id:349987)，它是一种[移位寄存器](@article_id:346472)。一个故障导致它在非法状态 $010$ 启动。根据其下一状态逻辑，它转换到 $101$。从 $101$，它又转换回 $010$。它现在被困在一个无休止的双状态[振荡](@article_id:331484)中，$010 \leftrightarrow 101$，这是一个与主计数序列完全断开的、微小而诡异的循环 [@problem_id:1968654]。机器还活着，但它已经失去了理智，永远在两个幻象状态之间徘徊。

这就是**[状态锁定](@article_id:354040)失效**的本质。一个系统进入一个未使用状态，并沿着一条永远不会返回到主要的、有用的循环的路径行进。这条路径可以是一个固[定点](@article_id:304105)，也可以是涉及多个未使用状态的**锁定循环**。

一个鲁棒的设计，通常被称为**自启动**或**自纠正**设计，必须考虑到这一点。一个优秀的设计师要确保从*任何*一个 $2^N$ 可能的状态出发，总有一条路径能回到主操作循环。在一个从0计数到9的[BCD计数器](@article_id:345685)中，对应10到15的状态是未使用的。一个鲁棒的设计可能会确保，如果计数器落到状态13（二进制 `1101`），下一个状态是7（二进制 `0111`），安全地将其带回正轨。然而，一个有缺陷的设计可能从状态12转换到14，再从14转换回12。这就产生了一个在12和14之间的锁定循环，一个等待触发的陷阱 [@problem_id:1962227]。

有时这些陷阱极其微妙。考虑一个电路，其逻辑包含方程 $D_2 = Q_2$。这个看似无害的规则在状态空间中创造了一堵不可逾越的墙。任何 $Q_2=0$ 的状态总是会转换到另一个 $Q_2=0$ 的状态。任何 $Q_2=1$ 的状态总是会转换到一个 $Q_2=1$ 的状态。如果主循环完全存在于 $Q_2=0$ 的半个宇宙中，而一个故障将系统撞到一个 $Q_2=1$ 的状态，它就*永远*无法返回。它被永久地锁定在预期功能之外 [@problem_id:1962209]。

情况可能更加复杂。一台机器可能仅在某些外部条件下才会被困住。想象一个带有输入 $x$ 的电路。如果它进入一个未使用状态，当 $x=1$ 时它可能会返回主循环，但如果输入保持在 $x=0$，它可能会进入一个未使用状态之间的锁定循环。陷阱只有在环境与之“合谋”时才会触发 [@problem_id:1962902]。

### 架构师的困境：[无关项](@article_id:344644)与意外后果

为什么任何理智的工程师会设计一个带有如此隐藏陷阱的系统？答案在于数字设计中一个强大而诱人的概念：**[无关项](@article_id:344644)条件**。

在为下一状态逻辑创建真值表时，设计者必须为每个可能的输入指定一个输出。输入包括当前状态。但对于一个未使用的当前状态，其下一个状态应该是什么？由于机器*理应*永远不会处于该状态，设计者可以说：“我不在乎。”这个“[无关项](@article_id:344644)”是一张万能牌。它意味着[逻辑综合](@article_id:307379)器——将抽象设计转换为具体逻辑门模式的软件——可以自由地分配*任何*能产生最简单、最小、最节能电路的下一状态 [@problem_id:1961711]。

这就是架构师的困境。通过将未使用状态声明为“[无关项](@article_id:344644)”，工程师可以构建更便宜、更快的硬件。但这样做，他们就放弃了控制权。他们让优化工具来决定机器幻象状态的行为。而工具的唯一目标是效率，不是安全。

这可能直接导致灾难。让我们以一个设计为循环通过偶数的计数器为例：$0 \to 2 \to 4 \to 6 \to 0$。奇数{1, 3, 5, 7}是未使用的。设计者将它们标记为“[无关项](@article_id:344644)”，然后让综合工具施展其魔法。该工具在其不懈的优化追求中，可能会产生一个最终电路，其中纯粹由于[布尔代数](@article_id:323168)的巧合，状态1转换到状态5，而状态5又转换回状态1。一个意想不到的锁定循环 ($1 \leftrightarrow 5$) 就这样凭空产生了，它是优化的副产品 [@problem_id:1962228]。

我们发现，机器中的幽灵并非超自然现象。它们是我们建造事物方式的逻辑必然结果。它们源于我们硬件的有限性，并由我们对效率的渴望所塑造。理解它们不仅仅是一个学术练习；它是构建能够从意外中恢复的鲁棒系统的关键，是构建即使在自身[状态空间](@article_id:323449)的幻象走廊中迷失后也能找到回家之路的系统的关键。