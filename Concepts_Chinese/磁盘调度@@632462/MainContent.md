## 引言
在[操作系统](@entry_id:752937)的世界里，很少有问题能像磁盘调度这样，将物理机械与抽象算法之间的鸿沟优雅地连接起来。尽管现代计算常常让人感觉是瞬时完成的，但许多系统的性能仍然取决于传统硬盘驱动器（HDD）的物理局限性。这些设备的机械特性——一个旋转的盘片和一个移动的读写头——造成了一个显著的瓶颈：访问数据需要耗时的物理移动。仅仅按照数据请求到达的顺序来处理它们，效率极其低下，会导致性能不佳和系统无响应。本文将深入探讨 I/O 调度的经典挑战，以克服这一限制。

在第一章“原理与机制”中，我们将探讨使得调度成为必要的物理约束，并分析一系列基础算法，从朴素的“先来先服务”到贪心的“[最短寻道时间优先](@entry_id:754801)”以及优雅的 SCAN“电梯”算法，揭示效率与公平性之间的关键权衡。随后，“应用与跨学科联系”一章将拓宽我们的视野，揭示这些相同的原理如何支配复杂的系统行为，从[虚拟内存管理](@entry_id:756522)和云计算到[外部排序](@entry_id:635055)和[机器人控制](@entry_id:275824)，从而证明理解如何调度磁盘就是理解[系统设计](@entry_id:755777)的一项基本原则。

## 原理与机制

要理解我们为什么甚至需要为磁盘“调度”请求，我们必须首先认识到，硬盘驱动器（HDD）并非某种抽象的计算机魔法。它是一个奇妙的、旋转的机械装置——一个密度惊人的微型唱机。其核心是一个涂有[磁性材料](@entry_id:137953)的盘片，每分钟[旋转数](@entry_id:264186)千次，而一个安装在移动臂上的精密读写头，悬浮在盘片表面上方几纳米处，来回飞驰以寻找正确的数据磁道。

### 运动的暴政：我们为何要调度

在 HDD 上访问一条数据就像一出三幕剧。首先，磁头臂必须将读写头移动到正确的磁道上；这是**[寻道时间](@entry_id:754621)**。其次，盘片必须旋转，直到所需的数据扇区转到读写头下方；这是**[旋转延迟](@entry_id:754428)**。只有到那时，第三步，数据才能真正被传输。对于小请求，传输时间只是一眨眼的功夫。真正的戏剧，故事中耗时的反派，是物理移动——寻道和旋转。这通常被称为**定位延迟**。

考虑一个典型的 HDD，转速为 $7200$ RPM，平均[寻道时间](@entry_id:754621)为 $8$ 毫秒。平均[旋转延迟](@entry_id:754428)（等待半圈的时间）约为 $4.17$ 毫秒。因此，在我们读取一个字节之前，平均就已经花费了超过 $12$ 毫秒仅仅为了将读写头移动到正确的位置！读取一个小的 4 KiB 文件可能只需要额外的 $0.03$ 毫秒。定位延迟占总服务时间的 $99\%$ 以上。正是这种惊人的低效率，这种物理运动的暴政，为巧妙的算法打开了大门。如果我们能以某种方式最小化读写头的移动，我们就能极大地提高速度。这就是磁盘调度的全部目的 [@problem_id:3655582]。

同样至关重要的是要认识到，这整个问题都是机器设计的结果。[固态硬盘](@entry_id:755039)（SSD）没有移动部件，因此没有[寻道时间](@entry_id:754621)或[旋转延迟](@entry_id:754428)。其访问时间主要由[数据传输](@entry_id:276754)决定，使得请求的顺序远没有那么重要。我们即将探讨的这些优美的算法，是针对一个在某种意义上正随着技术演进而逐渐消失的问题的解决方案。但它们所揭示的关于贪心、公平和预测的原则，却是永恒的。

### 朴素与贪心

处理一个请求队列最简单的方法是什么？与处理银行排队的方式相同：**先来先服务（FCFS）**。这在直觉上是公平的；没有人可以插队。但在磁盘上，这却是混乱的根源。想象一下，请求相继到达磁道 $40, 150, 10, 90, \dots$。一个 FCFS 调度器会尽职地将读写头从磁道 $75$ 飞到 $40$，然后一直飞到 $150$，再返回到 $10$，接着又移到 $90$。读写头会像一个狂乱、低效的疯子一样在磁盘上来回猛冲。总的磁头移动量将是巨大的，所有用户的平均响应时间将受到严重影响 [@problem_id:3635884]。

如果 FCFS 是朴素的公平但低效，那么它的反面是什么？纯粹的、不加掩饰的贪心。这就引出了**[最短寻道时间优先](@entry_id:754801)（SSTF）**。规则很简单：从读写头的当前位置，总是选择最近的待处理请求。如果读写头在 $75$ 号柱面，而有请求在 $60$ 和 $90$，SSTF 会选择去 $60$，因为它只有 $15$ 个柱面的距离。通过总是最小化即时寻道距离，SSTF 相较于 FCFS 极大地减少了总的磁头移动，通常能提供所有算法中最佳的平均[响应时间](@entry_id:271485) [@problem_id:3635884]。这似乎是一个绝妙的解决方案。但我们知道，贪心有其阴暗面。

### 贪心的危险与饥饿的幽灵

想象一下，我们的 SSTF 调度器正忙于处理磁盘一小块区域内的一簇请求。此时，一个针对遥远磁道的新请求到来了。接着，又一个请求到达，但这个请求离当前的簇非常近。贪心的 SSTF 调度器当然会服务那个邻近的请求。现在想象一下，源源不断的新请求持续到达当前读写头位置附近。读写头将被困住，服务于这个局部的“热点”，而那个孤零零的、遥远的请求则被忽略。无限期地。这是一个经典的计算机科学问题，称为**饥饿**，或[无限期阻塞](@entry_id:750603)。那个遥远的请求可能永远也得不到服务，无论它等待了多久 [@problem_id:3635804]。

这突显了一个更复杂的公平性定义：公平不仅仅是谁先到，还要确保每个人最终都能轮到。SSTF 无法保证这一点。它的行为也可能受到系统其他部分的微妙影响。例如，如果缓存恰好满足了最近的请求，SSTF 调度器就会出乎意料地被迫进行比原本更长的跳转。虽然这可能意外地帮助一个遥远的请求被选中，但它强调了纯粹的贪心在复杂系统中的不可预测性 [@problem_id:3635810]。

### 优雅的折衷：[电梯算法](@entry_id:748934)

我们如何能像 SSTF 那样高效，又不像它那样无情地贪心呢？解决方案出奇地简单，被称为 **SCAN** 算法，或更通俗地称为[电梯算法](@entry_id:748934)。想象一下，磁盘读写头是一座高楼里的电梯。电梯不会跳到最近的按钮按下处；它有条不紊地朝一个方向（上或下）移动，服务沿途的所有请求，直到到达顶层或底层。然后，也只有到那时，它才会反向。

SCAN 算法正是这样做的。磁盘读写头从磁盘的一端（比如 $0$ 号柱面）单调地扫向另一端（$199$ 号柱面），服务其路径上的所有请求。当到达终点时，它就反向并扫回来。这个简单的规则是革命性的，因为它保证了公平性。没有请求会被饿死。如果一个请求正在等待处理，读写头保证会在最多一次完整的磁盘往返扫描中经过其柱面并服务它 [@problem_id:3635804] [@problem_id:3649182]。它的性能是一个极好的折衷：它不如最佳情况下的 SSTF 快，但远优于 FCFS，并且带有公平性的保证 [@problem_id:3635884]。

这个核心思想有几个改进版本：
-   **LOOK**：对 SCAN 的一个常识性优化。如果最高的请求只在 10 楼，电梯为什么要一直跑到顶楼呢？LOOK 算法的行为与 SCAN 类似，但它在服务完当前方向的最后一个请求后立即反向，而不会移动到磁盘的物理末端。这节省了一些不必要的移动 [@problem_id:3635879]。
-   **循环变体（C-SCAN 和 C-LOOK）**：[电梯算法](@entry_id:748934)有一个轻微的偏见。平均而言，位于磁盘中间的请求比位于两端的请求得到服务的频率更高。为了提供更均匀的等待时间，循环变体只在一个方向上服务请求（例如，从 $0$ 到 $199$）。到达终点后，读写头迅速返回到起点，而不服务任何请求，然后重新开始扫描。这就像一部只载客上行的电梯；要下楼，你必须等待它返回底楼并开始新的行程。

### 细节中的魔鬼：没有免费的午餐

LOOK，作为 SCAN 的“更智能”版本，总是更好吗？避免不必要的移动似乎是纯粹的胜利。但算法的世界充满了微妙之处，很少有免费的午餐。想象一个场景，LOOK 在 $150$ 号柱面服务了最后一个请求，并立即反向以处理编号较小的柱面上的请求。片刻之后，一个新请求到达了 $195$ 号柱面。LOOK 已经掉头，现在正朝着远离这个新请求的方向移动，稍后将不得不进行一次漫长而昂贵的返回行程。

而一个“更笨”的 SCAN 调度器，则会按契约规定，继续从 $150$ 号柱面一直扫描到 $199$ 号柱面末端。这样做，它将处于完美的位置，以极小的额外移动来处理 $195$ 号柱面的新请求。在这种情况下，SCAN 刻板的、“浪费的”移动变成了一种绝妙的**预期性调度**，赌一个请求可能会出现在磁盘的远端。有时，不那么聪明的算法会因为在正确的时间出现在正确的位置而获胜 [@problem_id:3635730]。这种权衡在有偏斜的工作负载下更为明显。如果一个磁盘有一个“热”区域，请求模式呈现重尾、突发性，LOOK 算法可能会被困在该区域服务，可能导致较冷的外部区域的请求饥饿。而更刻板的 SCAN，由于其承诺访问磁盘的物理两端，即使在这种病态的工作负载下也能保持鲁棒和公平 [@problem_id:3649182]。

现实世界还增加了其他复杂因素，比如**截止时间**。有时，在特定时间前得到答案比系统的整体平均速度更重要。在这种情况下，SSTF 的原始效率可能成为一种负担。它的机会主义性质使得任何单个请求的完成时间都难以预测。如果更稳健、可预测的 FCFS 能够保证满足 SSTF 可能会错过的截止时间，那么它可能会被选中 [@problem_id:3635716]。这是最大化[吞吐量](@entry_id:271802)和提供可预测延迟之间的经典权衡。

### 从简单规则到智能启发式

我们讨论过的算法对所有请求一视同仁。但如果有些请求更紧急呢？我们可以设计更智能的启发式方法。例如，当一个 SCAN 调度器开始扫描时，它应该选择哪个方向？一个简单的规则可能是朝请求更多的一侧开始。一个更好的规则可能会考虑**加权计数**，优先考虑有更多“重要”请求的一侧。一个更优的策略会权衡这一点与问题的几何结构：推迟大量重要请求是不好的，但强迫读写头为了服务它们而进行一次极长的初始扫描可能更糟。一个好的[启发式方法](@entry_id:637904)会平衡这些相互竞争的成本 [@problem_id:3635796]。

我们甚至可以在这些看似不同的思想之间看到一种美妙的统一。考虑一种[启发式方法](@entry_id:637904)，它根据接下来 $k$ 个请求的密度来决定其扫描方向。
-   当 $k=1$ 时，该启发式方法只看单个最近的请求。这正是 SSTF。
-   随着 $k$ 的增加，决策基于越来越大的一批请求，迫使系统基于对请求[分布](@entry_id:182848)的更广阔视野来确定一个方向。这种行为开始模仿 SCAN/LOOK 的公平性。
这表明，贪心的 SSTF 和公平的 SCAN 并非两极对立，而是一个行为谱系上的两个点，可以通过单个“前瞻”参数 $k$ 进行调节 [@problem_id:3635713]。

磁盘调度的研究是一段从机器的物理约束到公平、贪心和预测等抽象原则的旅程。它告诉我们，“最佳”算法是一个神话；存在的只有权衡。最优选择取决于工作负载、系统的目标，甚至运行它的硬件。随着硬件的发展，旧问题变得无足轻重，我们在此过程中发现的永恒原则依然存在，随时准备应用于下一个伟大的挑战。

