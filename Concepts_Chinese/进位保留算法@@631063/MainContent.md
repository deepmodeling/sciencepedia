## 引言
在对计算速度不懈的追求中，每一纳秒都至关重要。从您口袋里的手机到模拟我们气候的超级计算机，现代处理器的性能取决于它们以惊人速度执行算术运算的能力。然而，在这种复杂性的核心，潜藏着一个我们在小学就学过的基本运算：加法。在这个简单的过程中，潜伏着一个隐藏的瓶颈——进位的涟漪式传播——几十年来一直挑战着工程师们。传统加法中进位的顺序依赖性产生了一条延迟链，从根本上限制了我们的计算速度。

本文探讨了进位保留算法（Carry-Save Arithmetic, CSA），这是一种巧妙而强大的技术，它聪明地绕过了这个瓶颈。CSA 并不与进位作斗争，而是采纳了一种智能的“拖延”原则：将困难的进位传播工作推迟到最后才做。通过这样做，它释放了大规模的并行性，并极大地加快了计算速度，尤其是在需要同时对许多数字进行相加时。

我们将首先探讨进位保留算法的基础“原理与机制”，剖析它如何利用简单的逻辑门，用许多独立的快速加法来换取一次缓慢的加法。然后，我们将历览其“应用与跨学科联系”，探索这一思想如何彻底改变从[硬件乘法器设计](@entry_id:175630)、高性能 CPU 架构到抽象理论算法实现的方方面面。

## 原理与机制

要理解进位保留算法的精妙之处，我们必须首先直面我们都被教导过的加法方法中的根本瓶颈：进位。想象一下用手计算两个大数相加。你从右到左，一列一列地进行。在每一列中，你将数字相加，写下结果数字，如果和大于等于10，你就向下一列“进”一个一。这个过程简单可靠。这也正是一个基本计算机加法器——**[行波进位加法器](@entry_id:177994)**的工作方式。

### 进位的制约

[行波进位加法器](@entry_id:177994)由一串称为**[全加器](@entry_id:178839)**的简单组件构成。每个[全加器](@entry_id:178839)都是一个微型电路，它知道如何将三个单位比特相加：两个来自待加数的输入比特，以及一个来自其右侧列的进位输入比特。它产生两个输出：一个用于其自身列的单位和比特，以及一个用于其左侧列的进位输出比特。

问题就出在这里。第二列的[全加器](@entry_id:178839)必须等到接收到第一列的进位输出后才能开始工作。第三列必须等待第二列，第四列等待第三列，依此类推。对于两个 64 位数字的加法，在第一位产生的进位可能需要一路传播，或称“[行波](@entry_id:185008)”，一直传到第 64 位。这就产生了一条依赖链，一场每一级都被前一级所牵制的等待游戏。对于每秒发生数十亿次运算的高速计算而言，这种[行波](@entry_id:185008)延迟是不可接受的制约。

### 延迟处理原则

进位保留算法提出了一个绝妙的解决方案：如果进位是问题所在，为什么不干脆……把它推迟处理呢？我们不必在每一步都立即解决进位问题，而是可以简单地把它保存起来留待后用。这是一种智能的“拖延”，打破了拖慢一切的依赖链。

让我们看看这在最基本的层面上是如何运作的。想象我们不是在加两个数，而是三个数：$X$、$Y$ 和 $Z$。在任意给定的比特列 $i$ 中，我们现在有三个比特要求和：$x_i$、$y_i$ 和 $z_i$。这个和的结果可以是 $0$ ($0+0+0$)、$1$ ($1+0+0$)、$2$ ($1+1+0$) 或 $3$ ($1+1+1$)。一个输出比特已不足以表示这个和。但一个两位二进制数就非常合适！我们可以将和表示为一个两位值 $(c's)_2$，其中 $s$ 是低位（“和”），$c'$ 是高位（“进位”）。

例如，如果我们计算 $1+1+1=3$，两位结果是 $11_2$。所以我们会输出一个为 $1$ 的和比特和一个为 $1$ 的进位比特。如果我们计算 $0+1+1=2$，结果是 $10_2$，得到一个为 $0$ 的和比特和一个为 $1$ 的进位比特 [@problem_id:1918736]。规则很简单：和比特 $s_i$ 是该列加法忽略任何进位输出的结果，而进位比特 $c'_{i}$ 是*本应*传递给下一列的比特。

### (3,2) 计数器：一个简单而强大的思想

执行这项基本任务的电路正是我们所熟悉的**[全加器](@entry_id:178839)**。它接收三个比特作为输入，并产生两个比特作为输出。其输出在数学上定义为：

-   **和比特：** $s_i = x_i \oplus y_i \oplus z_i$
-   **进位输出比特：** $c'_{i} = (x_i \land y_i) \lor (y_i \land z_i) \lor (z_i \land x_i)$

这里，$\oplus$ 是[异或](@entry_id:172120)（XOR）运算，它给出不考虑进位的和比特。进位输出由“多数”函数决定：如果输入比特中至少有两个为 1，则进位为 1。其魔力在于这两个输出完美地保留了原始的和：$x_i + y_i + z_i = s_i + 2c'_{i}$。

因为这个单一组件接收三个输入并将其计数表示为一个两比特输出，所以它通常被称为 **(3,2) 计数器**或 **(3,2) 压缩器** [@problem_id:1918705]。它将三股[比特流](@entry_id:164631)压缩成两股，而没有任何信息损失。

### 并行性与冗余性：和向量与进[位向量](@entry_id:746852)

现在，让我们来构建我们的机器。要将三个 $N$ 位数字相加，我们只需并排[排列](@entry_id:136432) $N$ 个这样的[全加器](@entry_id:178839)，每个比特列一个。关键特性是这些[全加器](@entry_id:178839)不是[串联](@entry_id:141009)的。第 $i$ 列的[全加器](@entry_id:178839)接收比特 $x_i, y_i, z_i$，其工作完全独立于任何其他列的[全加器](@entry_id:178839)。它们全部并行操作。

由于我们的 $N$ 个[全加器](@entry_id:178839)中的每一个都产生两个输出，整个装置并不产生单一的答案。相反，它产生两个 $N$ [位向量](@entry_id:746852) [@problem_id:1918707]：

1.  一个**[部分和](@entry_id:162077)向量 (S)**：该向量由收集所有和比特构成，$S = s_{N-1}s_{N-2}...s_0$。这是如果你仅使用异或（XOR）运算来加这三个数，完全忽略所有进位时会得到的结果 [@problem_id:1918731]。

2.  一个**部分进[位向量](@entry_id:746852) (C)**：该向量由收集所有进位比特构成。然而，从第 $i$ 列产生的进位 $c'_{i}$ 的权重是第 $i$ 列比特的两倍；它理应属于第 $i+1$ 列。因此，进[位向量](@entry_id:746852)实际上向左移动了一个位置。原始三个数的总和在这种新形式中被完美地保留下来：$X + Y + Z = S + (C \ll 1)$，其中 $\ll 1$ 表示向左移一位 [@problem_id:1918740] [@problem_id:1918766]。

我们用两个中间答案换取了单一的、确定的答案。这被称为**冗余表示法**，因为同一个数值可以由不同的 S 和 C 向量对来表示。这似乎是退了一步，但这正是我们速度的源泉。我们执行了加三个数的困难任务，并将其简化为加两个数的更简单的任务，而且我们只用了一个[全加器](@entry_id:178839)操作的时间就完成了，无论我们加的是 8 位还是 128 位数字。

### 速度优势：用多个快速步骤换取一个慢速步骤

单个 CSA 级的延迟是恒定的。它就是信号通过一个[全加器](@entry_id:178839)所需的时间，这与比特数 $N$ 无关 [@problem_id:1918757]。这与[行波进位加法器](@entry_id:177994)形成鲜明对比，后者的延迟与 $N$ 成正比。

当我们需要相加许多数字时，比如八个——这是数字信号处理或乘法中的常见任务——这种方法的真正威力就显现出来了。一种天真的方法是使用一串七个[行波进位加法器](@entry_id:177994)。延迟将是巨大的，因为我们必须等待进位[行波](@entry_id:185008)传播七次。

使用进位保留算法，我们构建一个 **CSA 树**。
- **第一级：** 我们取八个数中的六个，将它们输入到两个并行的 CSA 中。这将六个数减少为四个（两对 S/C）。加上等待的两个原始数，总共剩下 6 个数要加。
- **第二级：** 我们取这六个数，用另外两个 CSA 将它们减少为四个。
- **第三和第四级：** 我们重复这个过程，每三个数使用一个 CSA，直到只剩下两个数为止 [@problem_id:1918744] [@problem_id:1918732]。

这棵树中的每一级都非常快，延迟只有一个[全加器](@entry_id:178839)的时间。将八个数减少到两个的总时间仅仅是几个[全加器](@entry_id:178839)延迟的时间。我们用一个短暂的、对数级的等待替换了一个漫长的、线性的等待。

### 最终计算：进位传播加法器

当然，最终我们需要一个单一的、非冗余的数字作为我们的答案。我们有两个向量，S 和 C。现在，且仅在现在，我们才支付进位传播的代价。我们使用一个常规的加法器，称为**进位传播加法器 (CPA)**，通过将部分和向量 S 与[移位](@entry_id:145848)后的部分进[位向量](@entry_id:746852) C 相加来计算最终的和 [@problem_id:1918767]。

是的，这最后一步涉及到一次行波（或一个更复杂但更快的[超前进位](@entry_id:176602)方案），但我们只需要做*一次*。我们将所有痛苦的进位逻辑整合到了一次单一的、最终的操作中，而在此之前，大部分的求和工作已经在快得惊人的、并行的进位保留世界中完成了。

### 速度的代价：冗余性的局限

这种非凡的速度伴随着一个微妙的权衡。虽然 S 和 C 向量完美地编码了最终的和，但这个值并不是“显式”的。如果在某个中间步骤后，你需要问一个简单的问题，比如“这个部分和是正数还是负数？”或者“是否发生了[溢出](@entry_id:172355)？”，你无法仅仅通过查看 S 和 C 向量来找到答案。

在二[进制](@entry_id:634389)补码格式中，一个数的符号由其最高有效位给出。但和的真正最高有效位取决于进位一路[行波](@entry_id:185008)传播到顶端。在你执行最终的进位传播加法之前，真正的最[终值](@entry_id:141018)仍然隐藏在冗余表示中 [@problem_id:1918759]。对于许多应用，如乘法，我们只关心最终的乘积，这是一个完美的权衡。我们甘愿牺牲中间信息的明晰性，以换取整体[吞吐量](@entry_id:271802)的巨大提升。进位保留算法是工程妥协的一个美丽典范，一个绝妙的洞见，即通过策略性地延迟一项计算，我们可以使整个过程变得更快。

