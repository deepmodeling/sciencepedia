## 应用与跨学科联系

我们花了一些时间学习游戏规则——`always` 块的语法、阻塞和[非阻塞赋值](@article_id:342356)之间的关键区别，以及至关重要的敏感列表。这是一门新语言的语法。但一门语言不仅仅是其语法；它真正的力量和美丽体现在它能讲述的故事和它能构建的世界中。现在，我们将看看我们能*构建*什么。`always` 块不仅仅是一段代码；它是我们希望创造的物理现实的描述。它是我们用来在硅画布上编排电子复杂之舞的工具，用来将硬件“说”入现实。我们的旅程将从计算器简单而坚定的逻辑，到存储器和处理器复杂而有节奏的脉搏，揭示这单一的结构如何构成了整个数字世界的骨干。

### 纯逻辑的艺术：[组合电路](@article_id:353734)

我们能描述的最简单的行为是纯组合逻辑的行为——这种电路的输出完全取决于其当前输入，而没有对过去的记忆。想象一个简单的计算器：你输入 `2 + 2`，它显示 `4`。你之前是否计算过 `5 * 3` 并不重要。`always @(*)` 块是我们描述这种无状态机器的主要工具。`*` 是一个强大的简写，它告诉综合器：“注意*每一个*可能影响结果的输入。”

一个很好的例子是[数值比较器](@article_id:346643)，一个判断一个数是大于、小于还是等于另一个数的电路。我们可以用一个 `always @(*)` 块内的简单 `if-else if-else` 结构来描述其行为。如果 $A > B$，我们将 `greater_than` 输出置高。如果 $A  B$，我们将 `less_than` 输出置高。否则，我们将 `equal` 输出置高。使其工作的关键是*完整性*。在我们逻辑的每一个可能的分支中，我们都必须明确定义*所有三个*输出的状态。如果我们只在第一个分支中设置 `greater_than` 标志，而对另外两个只字不提，硬件应该做什么？它没有指令，所以它做一个合理的猜测：保持它们之前的值。这种记忆的行为，被称为[推断锁存器](@article_id:356025)，是在我们纯逻辑机器中无意中创造了存储器，一个幽灵 [@problem_id:1945508]。

然而，这个“错误”是一个深刻的意外发现。如果我们故意粗心会发生什么？考虑一个多路选择器，一个用于从多个输入中选择一个的数字开关。一个正确的组合多路选择器应该对其选择线和数据输入的变化都敏感。但如果我们写一个只对选择线 `sel` 敏感的 `always` 块呢？`always @(sel)`。现在，想象我们选择了输入 `in0`，其值为 `4'b1010`。输出变为 `4'b1010`。稍后，`in0` 处的数据变为 `4'b1111`，但选择线 `sel` *没有改变*。因为 `always` 块只被指示监听 `sel`，它从未重新求值。输出顽固地保持在 `4'b1010`，即使它所连接的输入已经改变，它也“记住”了它拥有的值 [@problem_id:1912817]。我们无意中创造了一个存储元件！这直接引出了我们的下一个主题：构建能够记忆的电路的艺术。

### 存储器的诞生：锁存器与[触发器](@article_id:353355)

在无意中偶然发现存储器之后，我们现在可以有目的地创造它。让我们来构建一个透明 D 锁存器，一个基本的存储元件。我们将使用一个组合的 `always @(*)` 块，对数据输入 `d` 和门控输入 `g` 都敏感。在内部，我们写一条简单的规则：`if (g == 1'b1) q = d;`。注意缺少了什么：没有 `else` 部分。当门控 `g` 为高电平时，锁存器是“透明的”，输出 `q` 忠实地跟随输入 `d`。但是当 `g` 变为低电平时，`if` 条件为假，该块没有为 `q` 提供任何指令。综合器正确地将这种沉默解释为一条命令：“保持你最后的值。” 我们有意地推断出了一个[锁存器](@article_id:346881)，创造了一个可以捕获和存储一位信息的电路 [@problem_id:1912833]。

虽然[锁存器](@article_id:346881)很有用，但它们对门控信号的*电平*敏感，这在大型系统中有时难以管理。一个更稳健的解决方案是让我们的存储元件只对信号*变化*的精确瞬间——一个边沿——敏感。这就引出了 D 型[触发器](@article_id:353355)，几乎所有现代数字逻辑的心脏。通过将我们的敏感列表从 `always @(g or d)` 改为 `always @(posedge clk)`，我们创造了一个只在[时钟信号](@article_id:353494)的上升沿更新其状态的设备。这一个改变规范了我们的整个系统，将所有操作同步到一个统一的心跳。

现实世界中的[触发器](@article_id:353355)甚至更复杂。我们可以轻松地添加一些功能，比如一个异步的“清除”功能，无论时钟如何，它都能立即重置状态；以及一个同步的“使能”功能，它决定[触发器](@article_id:353355)是否应该在[时钟沿](@article_id:350218)监听其输入。`always` 块以非凡的优雅处理了这一切。一个用于异步清除的 `if` 语句放在最前面，反映了其最高优先级。嵌套在 `else` 内部的是[同步逻辑](@article_id:355752)，只有在清除信号无效的[时钟沿](@article_id:350218)才会执行。代码中的这种层次结构直接映射到硬件中的优先级结构 [@problem_id:1931239]。

### 构建机器：从寄存器到系统

有了一个可靠、受时钟约束的存储单元，我们就可以开始构建更大的结构。让我们从将几个[触发器](@article_id:353355)链接在一起创建一个[移位寄存器](@article_id:346472)开始。在每个时钟节拍，数据进入第一个[触发器](@article_id:353355)，第一个[触发器](@article_id:353355)的值移动到第二个，第二个到第三个，依此类推。要描述这个过程，我们必须使用[非阻塞赋值](@article_id:342356)（`=`）。

`q1 = din;`
`q2 = q1;`
`q3 = q2;`

这可能是[非阻塞赋值](@article_id:342356)原则最关键的应用。`=` 操作符告诉仿真器，所有这些动作都在[时钟沿](@article_id:350218)*同时*发生。每个语句的右侧首先被求值，使用的是寄存器在时钟节拍前的“旧”值。然后，所有的左侧被一起更新。如果我们使用阻塞赋值（`=`），我们描述的将是一个顺序的涟漪效应：`q1` 会得到新的 `din`，然后 `q2` 会立即得到那个*新*的 `q1`，而 `q3` 会得到那个*新*的 `q2`，所有这些都在同一瞬间发生。数据会立即穿过整个寄存器，这并不是硬件的实际行为 [@problem_id:1912810]。[非阻塞赋值](@article_id:342356)完美地捕捉了硬件的并行特性。

从一行寄存器，我们可以扩展到一个网格，创建一个随机存取存储器 (RAM)。一个 `always` 块可以完美地模拟这一点。一个寄存器数组，`reg [7:0] memory [0:3];`，构成了我们的存储空间。一个时钟控制的 `always` 块处理[同步](@article_id:339180)写操作：在[时钟沿](@article_id:350218)，如果写使能有效，一个值就会被写入由地址指定的位置。同时，读操作可以是纯组合的，由块外的一个连续 `assign` 语句描述。这种同步写和异步读的分离是一种常见且高效的存储器架构 [@problem_id:1975232]。

[非阻塞赋值](@article_id:342356)的优雅甚至允许更复杂的操作。考虑一个单周期的“读-修改-写”操作。我们需要从一个存储位置读取一个值，对其进行计算，然后将结果写回*同一位置*，所有这些都在一个[时钟周期](@article_id:345164)内完成。`always` 块是：

`always @(posedge clk) begin`
`  data_out_a = ram[addr_a];`
`  ram[addr_a] = ram[addr_a] + K;`
`end`

因为两个赋值都是非阻塞的，所以两个右侧都是使用[时钟沿](@article_id:350218)*之前* `ram[addr_a]` 的值来求值的。输出端口被安排接收旧值，而存储器位置本身则被安排用新的、计算出的值来更新。这个复杂、看似顺序的操作被完美而简洁地描述出来，展示了我们所掌握的描述能力 [@problem_id:1915877]。

### 连接物理世界及更广阔的领域

`always` 块不仅仅是[抽象逻辑](@article_id:639784)的工具；它是通往物理世界以及更深层次的计算和工程原理的桥梁。

**软件与硬件的鸿沟：** 一个接触 [Verilog](@article_id:351862) 的程序员可能会写一个 `for` 循环来计算阶乘，认为这是一个需要时间的迭代过程。

`for (i = 2 to N) { result = result * i; }`

当这段代码被放入一个组合 `always` 块中时，综合器会执行一个惊人的翻译行为。它不会创建一个循环的处理器。相反，它在*空间上展开循环*。它构建了一个物理乘法器的级联：一个用于 `2!`，其结果送入另一个用于 `3!`，再送入另一个用于 `4!`，依此类推，直到可能的最大输入。最终的电路是一个庞大的并行结构，它一次性计算所有可能的阶乘，并在末端用一个多路选择器根据输入 `N` 来选择所需的结果。`for` 循环，这个在软件中表示时间的概念，在硬件中变成了面积和空间的概念 [@problem_id:1943453]。这是一个根本性的教训：我们不是在编写指令；我们是在绘制蓝图。

**处理混乱的现实：** 物理世界并不像我们的数字模型那样干净。例如，一个机械按钮不会产生一个清晰的 `0` 或 `1`。它会“[抖动](@article_id:326537)”，产生一个嘈杂、快速的跃迁序列。要使用这样的按钮，我们必须对其进行“[去抖动](@article_id:333202)”。我们可以设计一个[有限状态机 (FSM)](@article_id:355711) 来解决这个问题。FSM 等待第一次按下的迹象，然后进入一个等待状态。它启动一个计数器。只有当按钮在短暂延迟后*仍然*被按下时，FSM 才会转换到“已按下”状态，并发出一个单一、干净的输出脉冲。`always` 块是描述这个硬件[算法](@article_id:331821)的状态转换和逻辑的自然方式，它驯服了一个嘈杂的物理现象，并使其在我们的数字系统中可用 [@problem_id:1926763]。

**效率的必要性：** 在我们这个由电池供电的设备和大型数据中心组成的现代世界里，速度不是唯一的目标。功耗至关重要。考虑一个 64 位寄存器，它只是偶尔更新，由一个使能信号 `en` 控制。一个天真的实现会在每个时钟周期都对所有 64 个[触发器](@article_id:353355)进行时钟驱动，即使数据没有变化，也会浪费电力来翻转时钟网络。然而，一个智能的综合工具会看到以下代码：

`always @(posedge clk) begin`
`  if (en) { q = d; }`
`end`

它识别出这种模式，并推断出一个称为[集成时钟门控](@article_id:354101) (ICG) 单元的专门电路。这个单元位于[触发器](@article_id:353355)组之前，充当时钟本身的看门人。如果 `en` 为低，ICG 单元就会阻止时钟到达[触发器](@article_id:353355)，防止它们翻转，从而节省大量[功耗](@article_id:356275)。虽然在给定场景中的具体[功耗](@article_id:356275)数字对于练习来说可能是假设的，但这个原则是现代[低功耗设计](@article_id:345277)的基石。我们高级描述中的一个简单 `if` 语句被翻译成一个复杂、省电的物理实现，展示了抽象代码与底层电子物理学之间的美妙联系 [@problem_id:1920628]。

从最基本的逻辑到最复杂的系统，`always` 块一直是我们不变的伴侣。它证明了一个精心设计的抽象的力量——一个单一、多功能的结构，让我们能够描述物理世界的行为，创造存储器，构建机器，甚至管理能量的流动。它是将我们的意图转化为硅片现实的语言。