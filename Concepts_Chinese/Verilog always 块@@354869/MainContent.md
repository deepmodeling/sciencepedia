## 引言
`always` 块是 [Verilog](@article_id:351862) 中行为级建模的基石，是工程师描述[数字电路](@article_id:332214)动态操作的主要工具。虽然其语法看似简单，但肤浅的理解常常导致严重的设计缺陷，使得代码的仿真行为与综合后硬件的物理现实产生[分歧](@article_id:372077)。这种意图与实现之间的差距，源于对类软件的过程式代码如何转化为并行硬件结构的误解。

本文旨在弥合这一知识鸿沟，从头开始探索 `always` 块，教您不仅像程序员一样思考，更要像芯片本身一样思考。在接下来的章节中，您将掌握支配硬件描述的基本概念。首先，在“原理与机制”下，我们将剖析 `always` 块的过程性，解释阻塞和[非阻塞赋值](@article_id:342356)之间的关键区别，并建立防止[竞争条件](@article_id:356595)和意外锁存器等常见错误的综合黄金法则。随后，在“应用与跨学科联系”中，我们将应用这些原则来构建一系列硬件，从简单的[组合逻辑](@article_id:328790)到复杂的时序系统（如[移位寄存器](@article_id:346472)和存储器），展示这单一的结构如何促成整个数字世界的创建。

## 原理与机制

要真正掌握数字设计的艺术，我们必须超越仅仅了解 [Verilog](@article_id:351862) 这类语言的语法，而要开始像芯片本身一样思考。`always` 块是我们描述行为的主要工具，是我们告诉硬件做什么以及何时做的方式。但要正确使用它，我们需要理解其基本原理，即支配电子之舞的深层规则。这是一段从抽象代码到物理现实的旅程，就像任何伟大的旅程一样，它始于几个简单而强大的思想。

### `always` 块：一个关于变化的故事

想象一下，你试图描述一个系统，不是通过它*是*什么，而是通过它*如何变化*。你不会说“这盏灯连接到那个开关”，而是说“在开关拨动的那一刻，灯会亮起”。这就是过程性描述的精髓，也是 `always` 块的核心。一个 `always` 块是一组指令，它们处于休眠状态，等待一个特定的[触发器](@article_id:353355)。当那个[触发器](@article_id:353355)发生时——也许是[时钟信号](@article_id:353494)的上升沿，或是任何输入的变化——这个块就会被激活并执行其命令。

这种过程性带来了一个基本要求。如果一个信号的值要由 `always` 块内部的指令来设定，它就不能是一个简单的、被动的 `wire`。`wire` 就像一根管道；它的值由另一端持续驱动它的任何东西决定。而过程性赋值则不同；它是一个事件，一个瞬间的动作。“让 `y` 等于 `a`。” 在这个动作结束后，`y` 应该是什么？它必须*记住*刚刚被赋予的值。它需要具备存[储能](@article_id:328573)力。

在 [Verilog](@article_id:351862) 中，这种能力由 **`reg`** 数据类型提供。任何在 `always` 块内部作为赋值目标的信号都*必须*声明为 `reg`（或 System[Verilog](@article_id:351862) 中的 `logic` 等类似变量类型）。这并不是因为它必然会成为一个物理硬件寄存器——这是一个常见的混淆点——而是因为它需要在由仿真器的事件驱动引擎管理的程序性更新之间保持其值。可以把 `reg` 想象成白板上的一小块区域。`always` 块则是一个人，听到铃声后，就跑到白板前，在那块区域里写上一个新数字 [@problem_id:1975239]。这块区域本身会一直保持这个数字，直到下一次铃响。无论你是在描述一个必须在[时钟周期](@article_id:345164)之间保持其状态的存储元件（如计数器）[@problem_id:1975235]，还是一个简单的逻辑（如多路选择器），这条简单而唯一的规则都适用。这条规则关乎过程性赋值的本质，而非最终的硬件。

### 两种时间观：阻塞与非阻塞的世界

一旦我们进入 `always` 块，就会发现自己处在一个引人入胜的十字路口。[Verilog](@article_id:351862) 提供了两种不同的赋值方式，两种不同的时间流动模型：**阻塞**赋值（`=`）和**非阻塞**赋值（`<=`）。选错一个可能是新手最常犯的错误，因为它们看起来相似，却描述了截然不同的世界。

#### 阻塞世界：因果链

阻塞赋值 `=` 创建了一个像计算机程序一样运行的世界。每一行代码都顺序执行，并且在前一行完全执行完毕后才开始。一个赋值的效果对下一行立即可见。

让我们来做一个思想实验。假设我们有三个寄存器 `A`、`B` 和 `C`，初始值分别为 1、2 和 3。在一个时钟节拍上，我们使用阻塞赋值执行以下代码 [@problem_id:1915858]：

```verilog
always @(posedge clk) begin
    A = B;  // A becomes 2
    B = C;  // B becomes 3
    C = A;  // C becomes the *new* A, which is 2
end
```

让我们一步步追踪这些事件。
1.  首先，`A = B;` 执行。`A` 立即变为 2。我们这个小世界的状态现在是 `(A=2, B=2, C=3)`。
2.  接着，`B = C;` 执行。`B` 立即变为 3。状态现在是 `(A=2, B=3, C=3)`。
3.  最后，`C = A;` 执行。但 `A` 的值是什么？是它在第一步中刚刚更新到的值。所以，`C` 变为 2。

时钟节拍后的最终状态是 `(A=2, B=3, C=2)`。这是一个顺序的[链式反应](@article_id:317097)。一个事件会阻塞下一个事件，直到它完成，从而在块内部创建了明确的数据依赖关系。

#### 非阻塞世界：同时变化的瞬间

[非阻塞赋值](@article_id:342356) `<=` 描述了一个完全不同的现实——一个更贴切地反映硬件并行特性的现实。在这个世界里，没有什么是立即发生的。相反，当 `always` 块被触发时，仿真器会根据触发*前*存在的值，来计算*所有*赋值语句的右侧。它计算出一个“未来的计划”。然后，在仿真步骤的最后，所有的更新同时发生。

让我们再次进行思想实验，这次是在非阻塞的世界里。初始状态仍然是 `(A=1, B=2, C=3)`。

```verilog
always @(posedge clk) begin
    A <= B;  // Schedule A to become the *old* B (2)
    B <= C;  // Schedule B to become the *old* C (3)
    C <= A;  // Schedule C to become the *old* A (1)
end
```

当时钟节拍到来时：
1.  仿真器看到 `A <= B;`，发现 `B` 的“旧”值是 2。它记下一笔：“在此之后，`A` 将变为 2。”
2.  它看到 `B <= C;`，发现 `C` 的“旧”值是 3。记下：“`B` 将变为 3。”
3.  它看到 `C <= A;`，发现 `A` 的“旧”值是 1。记下：“`C` 将变为 1。”

只有在所有这些计算都完成后，“神奇的时刻”才会到来。所有计划好的更新被一次性应用。最终状态是 `(A=2, B=3, C=1)`。这些寄存器完美地轮换了它们的值！这种并行更新机制正是真实[同步电路](@article_id:351527)中一组[触发器](@article_id:353355)的行为方式。

### 从代码到芯片：综合的实践准则

理解这两种时间观不仅仅是一项学术练习；它是编写能够正确综合成你意[图构建](@article_id:339529)的硬件的关键。从这种理解中，可以得出一些简单而宝贵的黄金法则。

**准则 1：对[时序逻辑](@article_id:326113)使用[非阻塞赋值](@article_id:342356)（`<=`）**

当你想描述在[时钟沿](@article_id:350218)改变状态的硬件时，比如[触发器](@article_id:353355)、计数器和[移位寄存器](@article_id:346472)，你是在描述一个所有状态元件同时更新的系统。这就是[非阻塞赋值](@article_id:342356)的世界。考虑这段简单的代码 [@problem_id:1915856]：

```verilog
always @(posedge clk) begin
  q2 <= q1;
  q1 <= d;
end
```

这完美地描述了一个两级**移位寄存器**。在[时钟沿](@article_id:350218)，硬件对输入 `d` 和第一个[触发器](@article_id:353355)的当前输出 `q1` 进行采样。然后，`q1` 更新为 `d` 之前的值，而 `q2` 更新为 `q1` 之前的值。数据位看起来像是向右“移位”了一个位置。[非阻塞赋值](@article_id:342356)捕捉了物理[触发器](@article_id:353355)这种并行的“先采样后更新”的行为。同样，如果你构建一个[流水线](@article_id:346477)，其中一个阶段依赖于前一个阶段的输出，[非阻塞赋值](@article_id:342356)确保每个阶段都使用前一个阶段在*上一个*[时钟周期](@article_id:345164)中存在的结果，这正是一个硬件流水线的工作方式 [@problem_id:1915888]。

**准则 2：对组合逻辑使用阻塞赋值（`=`）**

组合逻辑——仅由与门、或门、异或门等逻辑门构成的电路——没有存储器，也没有时钟。它的输出一旦输入改变（经过微小的传播延迟后）就会改变。数据像水流过一系列管道一样流过它。阻塞赋值，凭借其顺序的数据依赖性，是描述这种流动的自然方式。

```verilog
always @(*) begin
    p = a ^ b;
    y = p & c;
end
```

在这里，`p` 的值首先被计算出来，并立即可用于 `y` 的计算。这正确地模拟了一连串的逻辑门。如果你在这里错误地使用[非阻塞赋值](@article_id:342356)，将会造成仿真-综合不匹配 [@problem_id:1915857]。仿真器会看到 `y <= p & c;` 并使用 `p` 在块被触发*之前*的旧值。它需要多个无限小的仿真“delta 周期”，才能使 `a` 或 `b` 的变化先传播到 `p`，然后最终传播到 `y`。然而，综合出的硬件只是一个单一的门网络，它以一次连续（尽管不是瞬时）的过程传播信号。仿真最终会工作，但效率低下，并且不能准确地模拟瞬态行为，这是一个微妙但危险的错误。

**准则 3：描述所有情况，否则会出现意料之外的存储器**

组合逻辑块对世界有一个契约：对于你给它的任何可能的输入组合，它都必须产生一个明确的输出。如果你未能履行这个契约，综合工具就会陷入困境。想象你写了一个 `case` 语句来描述一个译码器，但你忘记了其中一种情况 [@problem_id:1943476]：

```verilog
always @(*) begin
    case (sel)
        2'b00: data_out = 4'b0001;
        2'b01: data_out = 4'b0010;
        2'b10: data_out = 4'b0100;
        // 糟糕！sel == 2'b11 时怎么办？
    endcase
end
```

当 `sel` 为 `2'b11` 时，电路应该做什么？你没有说明。为了保持代码的行为，综合工具别无选择，只能推断输出必须保持其先前的值。为此，它必须创建一个存储元件——一个**[锁存器](@article_id:346881)**。在[同步设计](@article_id:342763)中，[锁存器](@article_id:346881)通常是不受欢迎的，因为它们可能导致时序问题，并且通常是编码错误的结果。一个好的综合工具会警告你：“警告：为信号 `data_out` 推断出锁存器。” 这是工具在告诉你，你在可能不希望有存储器的地方意外地创建了它。始终确保你的组合 `always` 块为每一种可能的情况指定一个输出，通常通过包含一个 `default` 分支或一个最后的 `else` 子句来实现。

### 一项基本罪过：多驱动源的危险

最后，我们来到一条如此基本以至于应被视为数字设计基本罪过的规则：**一个信号只能有一个驱动源**。在物理世界中，这是显而易见的。你不能将两个不同逻辑门的输出连接到同一根导线上，让一个试图将其驱动到 5 伏，而另一个试图将其驱动到 0 伏。结果是短路、冒烟和悲剧。

在 [Verilog](@article_id:351862) 中，有可能写出违反此原则的代码，从而产生**[竞争条件](@article_id:356595)**。考虑以下这个灾难性的模块 [@problem_id:1943445]：

```verilog
module RaceConditionModule( ... );
  // ...
  always @(posedge clk) begin
    q <= a;
  end

  always @(posedge clk) begin
    q <= b;
  end
endmodule
```

在这里，两个独立的 `always` 块，都由同一个[时钟沿](@article_id:350218)触发，试图驱动同一个寄存器 `q`。当时钟节拍到来时，一个进程安排 `q` 更新为 `a` 的值，而另一个进程同时安排 `q` 更新为 `b` 的值。哪一个会赢？IEEE [Verilog](@article_id:351862) 标准没有给出答案。它没有定义并发块的执行顺序。一家公司的仿真器可能最后执行第一个块的更新，导致 `q` = `a`。另一个同样符合标准的仿真器可能最后执行第二个块的更新，导致 `q` = `b`。这种行为是**不确定的**。你的电路行为取决于你用来测试它的特定软件——这对任何工程师来说都是一场噩梦。这不仅仅是坏习惯；它描述了一种物理上不可能的情况，必须不惜一切代价避免。

通过内化这些原则——`reg` 的作用、阻塞和[非阻塞赋值](@article_id:342356)的两个世界，以及综合的规则——我们提升了我们的理解。我们开始看到代码背后的硬件，凭直觉预测其行为，并编写出不仅语法正确，而且优雅、高效、忠实于数字世界美妙的并行本质的描述。