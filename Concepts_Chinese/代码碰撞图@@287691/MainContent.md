## 引言
在无数的科学和管理系统中，我们都面临着为一组不同的项目分配唯一标识符的基本任务。然而，这个过程往往并不完美，会导致“[碰撞](@article_id:357420)”——即不同的项目被赋予了相同的标签，从而产生[歧义](@article_id:340434)。这种[歧义](@article_id:340434)可能破坏从班级名册到复杂科学模型的各种事物。本文通过引入一个简单而强大的概念工具——代码[碰撞](@article_id:357420)图——来解决这个普遍存在的问题。该图为任何系统中的[歧义](@article_id:340434)提供了一个形式化的[图谱](@article_id:325219)，使我们能够分析、解决甚至利用它们。通过探索这一个单一概念，我们可以揭示一个统一的原则，它将众多学科中看似迥异的挑战联系在一起。

接下来的章节将[引导](@article_id:299286)您理解这个强大的概念。首先，在“原理与机制”中，我们将定义代码[碰撞](@article_id:357420)图，探讨其结构揭示了关于系统的哪些信息，并了解它如何阐明[化学反应网络理论](@article_id:376975)和[密码学](@article_id:299614)等领域的复杂过程。随后，在“应用与跨学科联系”中，我们将探索其在实际中的应用，见证同一框架如何帮助解决现代[基因组学](@article_id:298572)、分子鉴定和科学数据管理中的关键问题，最终确保知识本身的[完整性](@article_id:297502)和[可复现性](@article_id:311716)。

{'Model': '`，它指的是哪一个？我们遇到了**名称[碰撞](@article_id:357420)**。在这里，局部名称`"Model"`是那个有[歧义](@article_id:340434)的码字，而两个不同的语义概念是发生[碰撞](@article_id:357420)的源符号。\n\n优雅的解决方案是另一层旨在防止[碰撞](@article_id:357420)的编码：**命名空间**。在像 XML 这样的现代数据格式中，名称不仅仅是一个简单的字符串。它是一个**限定名**，如 `sbol:Model`。第一部分 `sbol:` 是一个前缀，作为全局唯一标识符的本地简写——一个长的、无[歧义](@article_id:340434)的网络地址（URI），直接指向 SBOL 词汇表。另一个名称 `sbml:Model` 会使用一个绑定到 SBML 词汇表不同 URI 的前缀。\n\n其底层机制正是我们的[碰撞](@article_id:357420)图所描述的。真正的、唯一的“源符号”是由其通用 URI 标识的概念。可能产生[歧义](@article_id:340434)的“码字”是局部名称`"Model"`。命名空间确保我们写下的限定名能够扩展为一个无[歧义](@article_id:340434)的配对 $\\langle \\text{命名空间 URI}, \\text{局部名称} \\rangle$。只有当这个配对的两个部分都相同时，两个名称才会发生[碰撞](@article_id:357420)。通过保证命名空间 URI 是不同的，我们确保了无论有多少词汇使用相同的局部术语，这些名称都永远不会[碰撞](@article_id:357420) [@problem_id:2776428]。这是通过设计实现的、没有边的[碰撞](@article_id:357420)图。\n\n从一个简单的行政失误到分子间复杂的相互作用，从计算问题的难度到全球信息系统的架构，[碰撞](@article_id:357420)图都充当了一个统一的视角。它为我们提供了一种语言和一幅图景来理解一个根本性的挑战：当不同的事物被赋予相同的名称时会发生什么。通过描绘这些[歧义](@article_id:340434)，我们不仅学会了如何解决它们，还学会了如何看清支配我们[周围](@article_id:310217)所有系统的隐藏结构。', 'applications': '## 应用与跨学科联系\n\n在我们探索了代码[碰撞](@article_id:357420)图背后的原理和机制之后，你可能会留有一种抽象优雅的感觉。但一个物理或数学思想的真正美妙之处不仅在于其抽象性，还在于其阐明我们[周围](@article_id:310217)世界的力量。我们一直称之为“代码[碰撞](@article_id:357420)图”——一个描绘不同项目如何被赋予共享的、有[歧义](@article_id:340434)的标识符的[图谱](@article_id:325219)——不仅仅是一个理论上的奇观。它是一种基本的结构，在各种令人惊讶的科学和技术领域中一次又一次地出现。它是我们一些最宏伟项目背后的隐藏脚手架，从破译生命的蓝图到确保知识本身的[完整性](@article_id:297502)。\n\n让我们踏上一段旅程，去看看这个简单的思想在工作中是如何体现的，去欣赏它在看似迥异的领域中所展现的统一性和力量。\n\n### 生物学家的困境：阅读生命之书\n\n想象一下，要从数百万张微小的、撕碎的纸片中拼凑出一本完整的书。这正是现代[基因组学](@article_id:298572)的挑战。我们的测序仪产生大量的短 DNA“读段”，而我们的任务是将它们[拼接](@article_id:297805)回完整的基因组——生命之书。完成这项艰巨任务的主要工具是 de Bruijn 图，你现在可能已经猜到，它正是代码[碰撞](@article_id:357420)图的一个壮观例子。\n\n在这种情况下，“代码”是固定长度 $k$ 的短 DNA 序列，称为`$k$-mer`。我们构建一个图，其中每个[节点](@article_id:350499)代表一个唯一的 `$k-1$`-mer，而一条有向边代表一个观察到的 `$k$-mer`，它将其前缀连接到其后缀。通过在这个图中找到一条路径，我们希望能重建原始的 DNA 序列。$k$ 的选择，即我们代码的长度，带来了一个深刻的困境。\n\n如果我们选择一个较小的 $k$，比如 $k=21$，我们的代码会很短，特异性不强。基因组中充满了重[复序列](@article_id:354070)。基因组中两个完全不同的区域可能由于偶然或[进化](@article_id:304208)设计而包含相同的短 `$k$-mer`。这是一次[碰撞](@article_id:357420)：不同的基因组“项目”被映射到相同的图形“代码”。结果是一个极其[纠缠](@article_id:307988)的图，充满了[分支](@article_id:350830)和循环，使得找到一条单一、正确的路径变得不可能。组装结果变得支离破碎，成为微小而模糊的片段 [@problem_id:2479912]。\n\n那么，为什么不选择一个非常大的 $k$，比如 $k=61$ 呢？更长的代码具有更强的特异性。两个不同区域偶然共享同一个长 `$k$-mer` 的机会变得微乎其微，与 $1/4^k$ 成正比。这有助于解决由重[复序列](@article_id:354070)引起的[纠缠](@article_id:307988)，使图变得更加清晰。但这个解决方案又带来了新问题。DNA 测序并非完美无瑕；它有一个小的错误率 $e$。一个长 `$k$-mer` 被无误读出的概率约为 $(1-e)^k$，这个数值随着 $k$ 的增长而急剧下降。读段中的一个错误会创造一个全新的、错误的 `$k$-mer`，它很可能什么也连接不上。它在我们的图中变成了一个死胡同——一个“末端”——从而中断了我们试[图追踪](@article_id:327558)的路径。此外，对于非常大的 $k$，我们可能没有足够的测[序数](@article_id:310503)据来确保基因组中每一个真实的 `$k$-mer` 都能被观察到。图因此破碎成不连通的片段，不是因为[歧义](@article_id:340434)，而是因为缺乏证据 [@problem_id:2441152]。\n\n因此，[基因组组装](@article_id:306638)的艺术，就是管理这种权衡的艺术。它关乎选择一种既足够特异以避免大多数[碰撞](@article_id:357420)，又足够稳健以承受不可避免的[测量噪声](@article_id:338931)的代码。\n\n这种分子记账的原理超出了组装单个基因组的范畴。考虑一下计算血液样本中不同[抗体产生](@article_id:349364)细胞数量的任务。每个细胞都有独特的 DNA 重排，但我们无法对每个细胞进行单独测序。取而代之的是，我们使用一个聪明的技巧：我们用[唯一分子标识符](@article_id:323939)（UMI）——一段作为条形码的短随机 DNA 序列——来标记每个分子的 DNA。在将 DNA 扩增数百万倍后，理论上我们可以通过计算唯一 UMI 的数量来统计原始分子的数量。\n\n但在这里，[碰撞](@article_id:357420)也比比皆是。UMI 条形码本身可能发生测序错误，使得来自单个分子的读段看起来像是来自两个分子。这是一个由错误引起的[碰撞](@article_id:357420)，它夸大了我们的多样性计数。为了解决这个问题，我们可以构建一个代码[碰撞](@article_id:357420)图，其中[节点](@article_id:350499)是观察到的 UMI，我们在任何[相差](@article_id:333823)一个碱基（[汉明距离](@article_id:318062)为 1）的两个 UMI 之间画一条边。我们发现，真正的亲代 UMI 往往有许多读段，而由其错误衍生的“子代”则读段很少。通过分析这个图的结构及其[节点](@article_id:350499)“权重”（读段数），我们可以自信地将错误的子代[合并](@article_id:308383)回其亲代，从而校正计数 [@problem_id:2752225] [@problem_id:2399383]。这种构建和“修剪”[碰撞](@article_id:357420)代码图的优雅技术，现已成为定量单[细胞生物学](@article_id:304050)的核心。\n\n### 化学家的指纹：这个分子是唯一的吗？\n\n让我们从生物学转向化学世界。我们能为一个分子创造一个独特的“代码”或“指纹”，用来搜索庞大的化学数据库吗？一个绝妙的想法源于分子中原子的[连通性](@article_id:328057)。我们可以将分[子表示](@article_id:301536)为一个图，并用一个[矩阵](@article_id:381267)来描述这个图，例如[量子化学](@article_id:300637)中的 Hückel [矩阵](@article_id:381267)。这个[矩阵](@article_id:381267)的[特征值](@article_id:315305)——它的“谱”——构成了一组不依赖于我们如何给原子编号的数字。这个谱是我们[分子指纹](@article_id:351652)的一个候选。\n\n它是一个完美的代码吗？令人惊讶的答案是否定的。就像基因组的不同部分可以共享一个 `$k$-mer` 一样，不同的分子也可能由于数学上的巧合而共享完全相同的谱。这些被称为“[同谱图](@article_id:340430)”。这代表了一种根本的、不可避免的[碰撞](@article_id:357420)类型。代码本身具有固有的[歧义](@article_id:340434)性。它告诉我们，虽然数学指纹可以成为分类和搜索的极其强大的工具，但我们必须始终意识到它的局限性和这些“同谱”[碰撞](@article_id:357420)的可能性，即不同的项目生成相同的代码 [@problem_id:2457264]。\n\n### 图书管理员的策略：驾驭数据洪流\n\n我们所见的挑战——模糊的重[复序列](@article_id:354070)、带噪声的条形码、同谱的分子——都是一个深层问题的表现，这个问题位于[计算机科学](@article_id:311211)和数据管理的核心。当我们的识别工具本身就不完美时，我们如何构建可靠的系统？\n\n再来考虑[基因组组装](@article_id:306638)问题。一个大基因组中所有唯一 `$k$-mer` 的集合可能非常庞大，需要大量的[计算机内存](@article_id:349293)。为了节省空间，[生物信息学](@article_id:307177)家有时会使用一种称为布隆[过滤](@article_id:330830)器的概率[数据结构](@article_id:330149)。布隆[过滤](@article_id:330830)器就像一个紧凑但有点健忘的图书管理员。它可以告诉你一本书（一个 `$k$-mer`）是否在图书馆里。如果书在，它绝不会说书不在（没有假阴性），但它偶尔可能会说一本书在而实际上不在（假阳性）。\n\n这对我们的 de Bruijn 图意味着什么？在遍历图时，我们询问布隆[过滤](@article_id:330830)器：“四种可能的下一个 `$k$-mer` 中哪个存在？”一个假阳性意味着[过滤](@article_id:330830)器创造了一条“幽灵”边，一条通往数据中从未出现过的 `$k$-mer` 的路径。我们干净、真实的图变成了一个[散布](@article_id:327616)着虚假[分支](@article_id:350830)的“[超图](@article_id:334641)”。被引入歧途的几率随着[过滤](@article_id:330830)器的内在假阳性率 $f$ 而增加。理解这一点使我们能够精确地模拟概率[数据结构](@article_id:330149)如何破坏我们的[碰撞](@article_id:357420)图，从而导致[内存](@article_id:354523)效率和组装准确性之间的权衡 [@problem_id:2405164] [@problem_id:2818161]。\n\n当我们思考科学数据本身的性质时，这个关于身份和[碰撞](@article_id:357420)的主题达到了顶峰。在我们现代的网络化世界中，[数据存储](@article_id:302100)在联邦数据库中，每个数据库都有自己的命名约定。在这里，“代码”通常是统一资源标识符（URI），即一条数据在网络上的地址。在这个领域，[碰撞](@article_id:357420)对于科学的[可复现性](@article_id:311716)可能是灾难性的。\n\n当两个不同的实验室创建了两个不同的[生物部件](@article_id:334273)，但由于错误给它们分配了完全相同的 URI 时，会发生什么？这是一次两个项目共享一个代码的[碰撞](@article_id:357420)。有原则的解决方案不是简单地选择一个，而是承认原始创建者的权威，为第二个部件[铸造](@article_id:322230)一个新的、唯一的 URI，并且至关重要的是，创建一个永久的、机器可读的溯源记录，记录[碰撞](@article_id:357420)的历史及其解决方案。我们这是在主动地管理身份图 [@problem_id:2776412]。\n\n反过来，如果一个[生物部件](@article_id:334273)以三个不同的 URI 存在于三个不同的数据库中呢？这是相反的问题：一个项目，多个代码。要解决这个问题，我们必须超越名称，关注内容本身。通过计算规范化数据的加密哈希——一个独特的签名——我们可以创建一个单一的、规范的“基于内容”的标识符。然后我们[合并](@article_id:308383)重复的记录，并使用溯源将所有旧的、模糊的 URI 链接到新的、规范的 URI 上 [@problem_id:2776456]。\n\n我们可以再迈出这最后、令人惊叹的一步。这个使用加密哈希作为不可篡改代码的想法可以应用于整个科学工作流。原始数据文件获得一个哈希值。软件获得一个哈希值。参数文件获得一个哈希值。分析的每一步——从原始读段到最终的统计判断——都是一个“计算的[有向无环图](@article_id:323024)”中的一个[节点](@article_id:350499)。每个[节点](@article_id:350499)的标识符是其输入和所执行操作的哈希值。其结果是一个完全透明且可验证的发现记录。要验证一个结果，只需重新计算哈希值。任何输入或参数的任何改变，无论多么微小，都会导致不同的最终哈希值，从而立即揭示差异。这为整个科学过程——从数十亿的原始读段到最终的显著基因表格——提供了一个紧凑的、防篡改的承诺 [@problem_id:2840556]。\n\n### 一个简单思想的统一性\n\n从[拼接](@article_id:297805) DNA 的具体挑战到确保科学知识[完整性](@article_id:297502)的抽象必要性，我们看到同一个简单的思想在发挥作用。我们给事物分配代码。这些代码可[能带](@article_id:354354)有噪声、有[歧义](@article_id:340434)，甚至天生就不是唯一的。由此产生的冲突和[歧义](@article_id:340434)可以通过构建和分析这些[碰撞](@article_id:357420)的图来理解。\n\n通过接受这一视角，我们获得了一个强大的、统一的框架来思考各种各样的问题。无论我们是选择 `$k$-mer` 大小的生物学家，是评估[分子指纹](@article_id:351652)的化学家，还是设计[分布](@article_id:338885)式账本的[数据科学](@article_id:300658)家，我们在某种意义上，都在驾驭代码[碰撞](@article_id:357420)图的复杂连接。在认识到这个共同结构的过程中，我们不仅找到了一个实用的工具，而且瞥见了支撑科学事业的深刻统一性。', '#text': '## 原理与机制\n\n想象一下，你是一所新建的、规模庞大的大学的管理员。你的首要任务是为每位学生分配一个唯一的4位数ID号。你有一份学生名单，然后开始分发号码。但在某个环节出了错：两个不同的学生，比如 Alice 和 Bob，都被分配了ID `1729`。这就是一次**[碰撞](@article_id:357420)**。这是一个简单的错误，但它会在整个系统中产生[连锁反应](@article_id:298017)，导致课程名册、成绩评定和图书馆账户的混乱。问题的核心在于，一个单一的标识符 `1729` 现在模棱两可地指向了两个不同的个体。\n\n我们如何才能可视化并分析这种情况呢？不仅仅是学生ID，而是任何将一组不同项目映射到一组标签或代码的过程？答案是一个既简单又强大的工具：**代码[碰撞](@article_id:357420)图**。这个图为任何此类映射中的[歧义](@article_id:340434)提供了一个[图谱](@article_id:325219)，通过研究其结构，我们可以揭示关于系统的深刻真理，从[化学反应](@article_id:299980)到[密码学](@article_id:299614)的基础。\n\n### [碰撞](@article_id:357420)图：[歧义](@article_id:340434)的[图谱](@article_id:325219)\n\n让我们将这个想法形式化。我们有一个源符号集合，它们可以是任何东西：我们大学里的学生、字母表中的字母，甚至是复杂的[数据结构](@article_id:330149)。我们还有一个函数，称之为 $C$，它为每个符号分配一个“码字”。在我们的例子中，学生是源符号，4位数的ID是码字。\n\n我们按如下方式构建**[碰撞](@article_id:357420)图** $G_C$。每个源符号成为我们图中的一个顶点（一个点）。然后，如果——且仅当——任意两个不同的顶点被分配了相同的码字，我们就在它们之间画一条边。因此，在我们大学的例子中，我们会在 Alice 的顶点和 Bob 的顶点之间画一条边，因为 $C(\\text{Alice}) = C(\\text{Bob}) = 1729$。如果第三个学生 Carol 也收到了ID `1729`，我们就会画边将她与 Alice 和 Bob 连接起来。\n\n这个图的结构告诉了我们什么？如果图中完全没有边，这意味着没有两个符号共享一个码字。这个映射是**非奇异的**，是一个完美的、无[歧义](@article_id:340434)的分配。这是我们通常追求的[理想](@article_id:309270)状态。例如，数学中著名的 **Prüfer 码**提供了一种为每个可能的[标记树](@article_id:338332)分配一个唯一数字序列的方法，从而创建了一个完美的、无[碰撞](@article_id:357420)的对应关系 [@problem_id:1529296]。\n\n但现实世界通常是混乱的，[碰撞](@article_id:357420)时有发生。当[碰撞](@article_id:357420)发生时，我们的图中就会出现边。请注意一个非凡的现象：任何共享相同ID的一组学生都会在图中形成一个**[连通分量](@article_id:302322)**——一个所有顶点都直接或间接连接在一起的[簇](@article_id:319991)。如果 Alice 和 Bob 共享一个ID，而 Bob 和 Carol 共享同一个ID，那么 Alice、Bob 和 Carol 必然拥有相同的ID。他们形成了一个充满[歧义](@article_id:340434)的连通小团体。\n\n这个观察导出了一个简单而深刻的恒等式。实际使用的唯一码字数量恰好等于图中的[连通分量](@article_id:302322)数量！每个[连通分量](@article_id:302322)对应一个单一的、共享的码字。这意味着我们只需[计算图](@article_id:345859)中独立[簇](@article_id:319991)的数量，就能找出唯一ID的数量。这为我们提供了图的拓扑结构与其所代表的映射基本属性之间的直接联系 [@problem_id:1643892]。学生总数与这些分量数量之差，一个被称为**[碰撞](@article_id:357420)[指数](@article_id:347402)**的量，精确地告诉我们有多少“冗余”的学生与他人共享ID。它是对[歧义](@article_id:340434)程度的直接[度量](@article_id:297065)。\n\n### 结构为何重要：超越输入与输出\n\n[碰撞](@article_id:357420)图的作用不仅仅是计算[歧义](@article_id:340434)；它帮助我们保留那些否则可能会丢失的关键信息。让我们从大学行政管理转向化学实验室，那里也存在类似的问题，但风险要高得多。\n\n考虑一个化学系统，其中物种 $A$ 正在转化为物种 $B$。这个转化可以通过两种不同的反应发生：\n1.  两个 $A$ 分子反应生成一个 $A$ 和一个 $B$：$2A \\to A + B$。\n2.  一个 $A$ 分子和一个 $B$ 分子反应生成两个 $B$：$A + B \\to 2B$。\n\n如果你只看最终净结果，两个反应做了同样的事情：它们消耗一个 $A$ 分子并产生一个 $B$ 分子。两种情况下的净变化向量都是 $(-1, +1)$。如果我们构建一个简单的图，其中[节点](@article_id:350499)是化学物种（$A$ 和 $B$），那么两个反应都会坍缩成从 $A$ 到 $B$ 的单个箭头。对于模拟该系统而言，这种简化是灾难性的，因为它隐藏了一个关键的区别。这两个反应以完全不同的速率进行。第一个反应的速率取决于 $A$ 浓度的平方 ($k_1 a(t)^2$)，而第二个反应的速率取决于 $A$ 和 $B$ 浓度的乘积 ($k_2 a(t)b(t)$)。这些是根本不同的物理机制 [@problem_id:2653388]。\n\n[碰撞](@article_id:357420)图如何帮助我们清楚地看到这一点？我们必须正确地选择顶点。让我们用反应物组合，即化学家所称的**[复合](@article_id:315605)物**，来代替物种作为[节点](@article_id:350499)。我们的源符号现在是[复合](@article_id:315605)物 $2A$ 和 $A+B$。“码字”是它们产生的净变化，即向量 $(-1, +1)$。\n\n现在我们看清楚了！两个不同的[复合](@article_id:315605)物，$2A$ 和 $A+B$，在相同的输出上“[碰撞](@article_id:357420)”。我们的[碰撞](@article_id:357420)图将有两个顶点，`2A` 和 `A+B`，由一条边连接。通过选择[复合](@article_id:315605)物作为我们的顶点，我们保留了两个独立路径的身份。该图明确地告诉我们：“警告：这两个不同的输入配置产生相同的净结果，但它们不是同一个过程！” 这个框架是[化学反应网络理论](@article_id:376975)的核心，它表明正确定义“源符号”至关重要。它使我们能够使用[碰撞](@article_id:357420)图来精确定位不同的过程在何处被[混淆](@article_id:324339)为单一的表观结果。\n\n### [碰撞](@article_id:357420)的代价：从[歧义](@article_id:340434)到计算难度\n\n到目前为止，[碰撞](@article_id:357420)似乎是一种需要被分析或设计消除的麻烦。但如果我们能够利用它们呢？如果找到[碰撞](@article_id:357420)的*难度*可以成为安全的来源呢？这就是[现代密码学](@article_id:338222)的核心思想。\n\n想象一个函数 $f$，它易于计算但极难逆转。这是一个**[单向函数](@article_id:331245)**。现在，让我们增加一个特殊属性：这个函数是**2对1**的。对于每个输出值 $y$，都恰好有两个不同的输入 $x_1$ 和 $x_2$ 会产生它：$f(x_1) = f(x_2) = y$。我们还假设该函数是**抗[碰撞](@article_id:357420)的**，这意味着对于任何强大的计算机来说，找到*任何*一对[碰撞](@article_id:357420)的输入在计算上都是不可行的。\n\n这个函数的[碰撞](@article_id:357420)图是什么样的？它是一个由数百万个不相连的边组成的巨大的[稀疏图](@article_id:325150)。每条边连接一对“同胞对”——映射到相同输出的两个唯一输入。现在，考虑这个[搜索问题](@article_id:334136)，我们可以称之为 $SIBLING_f$：我给你一个输入 $x_1$，你的任务是找到它唯一的同胞 $x_2$。在图中，这就像把你放在一个顶点上，要求你穿过连接到它的唯一一条边找到你的目的地。\n\n这看起来很简单。但想一想后果。如果你能构建一个高效的[算法](@article_id:331821)来解决 $SIBLING_f$ 问题，你就拥有了一个可以打破该函数抗[碰撞](@article_id:357420)性的工具。你可以简单地随机选择一个输入 $x_1$，运行你的同胞查找器得到 $x_2$，然后——瞧！——你已经找到了一对[碰撞](@article_id:357420) $(x_1, x_2)$。\n\n这导出了一个不可避免的结论。如果我们相信找到[碰撞](@article_id:357420)确实是困难的，那么找到同胞也必须是困难的。$SIBLING_f$ 问题必须是计算上困难的，即使对于每个输入都保证存在一个解。这个强有力的论证将[碰撞](@article_id:357420)图的结构与[计算复杂性理论](@article_id:335860)中的深层问题联系起来，展示了即使是导航图中可能最简单的组成部分——一条单独的边——的难度，也可以成为[密码学](@article_id:299614)安全的基础 [@problem_id:1433124]。\n\n### [碰撞](@article_id:357420)的宇宙：从代码到概念\n\n[碰撞](@article_id:357420)的原理远远超出了数字和[算法](@article_id:331821)；它对于我们如何组织信息乃至意义都至关重要。在[数据科学](@article_id:300658)和软件工程的世界里，我们不断地组合不同的词汇和标准。想象一个项目同时使用[合成生物学开放语言](@article_id:375607)（SBOL）来描述基因设计和[系统生物学标记语言](@article_id:334765)（SBML）来模拟细胞过程。\n\n可能会出现这样的情况：两种标准都定义了一个它们称为`"Model"`的概念。在 SBOL 中，`"Model"`可能指一个定量模拟，而在 SBML 中，整个系统的顶层容器被称为`"model"`。如果一个文档只包含标签`'}

