## 引言
在文本中搜索单个词是一个已解决的问题。但如果你需要同时查找成千上万甚至上百万个不同的词呢？这个挑战的复杂性会急剧增加，因为朴素的方法会重复扫描同一段文本，浪费时间和资源。这在许多领域都是一个关键问题，从必须扫描病毒签名的网络安全，到搜索功能性 DNA 基序的基因组学。解决方案不在于更努力地工作，而在于更智能地工作——构建一个能够同时查找所有内容的单一高效机器。

本文深入探讨了 Aho-Corasick [算法](@article_id:331821)提供的优雅解决方案，重点关注其最卓越的创新：失效链接。我们将揭示这一概念如何将简单的搜索转变为高效的单遍操作。在第一章 **原理与机制** 中，我们将解构该自动机，以理解失效链接如何创建一个隐藏的快捷方式网络，从而回收利用失败匹配中的信息。随后，在 **应用与跨学科联系** 中，我们将看到这个强大的思想如何远远超越简单的文本搜索，为在遗传学、音乐乃至战略游戏中发现结构提供了新的视角。让我们首先扮演一名侦探，看看简单的方法究竟有多么低效。

## 原理与机制

想象一下，你是一名侦探，正在一条长长的加密信息中寻找一系列代号——比如 "he"、"she"、"hers" 和 "his"。朴素的方法是乏味的。你会扫描整个信息以查找 "he"。然后，你会回退并再次从头扫描以查找 "she"，接着是 "hers"，依此类推。你可以感觉到这种低效。每当你未能找到匹配时，你都会丢弃刚刚阅读文本时学到的一切，然后重新开始。自然和优秀的计算机科学都厌恶这种浪费。一定有更好的方法。

### 作为机器的词典

第一个巧妙的步骤是，不再将我们的模式视为一个列表，而是开始将它们视为一个单一、统一的地图。我们可以将所有模式编织成一个称为**[前缀树](@article_id:638244)**（trie）的结构 [@problem_id:3205763]。可以把它想象成一个流程图。你从一个代表“无”的单一点——根节点——开始。沿着分支路径每走一步，就增加一个字母。从根节点到任意节点的路径拼出了我们某个模式的前缀。

对于我们的词典 `{"he", "she", "hers", "his"}`，[前缀树](@article_id:638244)大致是这样的：从根节点出发，一条路径是 `h` $\rightarrow$ `i` $\rightarrow$ `s`。另一条路径从 `h` 分支到 `e`。还有第三条路径从根节点出发，是 `s` $\rightarrow$ `h` $\rightarrow$ `e` $\rightarrow$ `r` $\rightarrow$ `s`。请注意 "she" 和 "hers" 是如何共享 `s` $\rightarrow$ `h` $\rightarrow$ `e` 这部分路径的。我们构建了一台能够同时识别所有单词开头的单一机器。

现在，我们可以将文本，比如 "ahishers"，逐个字母地输入这台机器。我们从根节点开始。'a' 无法通向任何地方，所以我们停留在根节点。然后是 'h'。我们沿着 `h` 的路径走。然后是 'i'，我们走 `i` 的路径。然后是 's'，bingo！我们到达了一个标记着模式 "his" 结尾的节点。我们找到了一个匹配。

但接下来会发生什么？文本继续是 'h'。从我们当前表示 "his" 的 's' 节点，没有通向 'h' 的路径。对于简单的[前缀树](@article_id:638244)来说，这是一个危机时刻。朴素的做法是回到文本中重新开始。但这正是我们想要消除的低效。

### 失败（与天才）的时刻

这正是 Aho-Corasick [算法](@article_id:331821)施展其神来之笔的地方，这个想法如此优雅，感觉就像一条自然法则。它引入了一个称为**失效链接**的秘密通道网络。当你走到死胡同时，失效链接不会把你送回起点。它会将你传送到机器的另一部分，该部分代表了你所拥有的最有用的“第二次机会”。

让我们回到搜索中。我们刚刚读了 "ahis" 并找到了模式 "his"。文本中的下一个字符是 'h'。我们为 "his" 走的[前缀树](@article_id:638244)路径没有外向的 'h' 边。我们该怎么办？Aho-Corasick 自动机会说：“你刚刚匹配的字符串 'his' 无法帮助你继续。但如果它的*一部分*可以呢？'his' 的最后一部分是 's'。's' 是其他任何模式的开头吗？” 在我们的词典中，'s' 确实是 "she" 的开头。因此，从 "his" 节点的失效链接将我们传送到 "s" 节点。现在，从这个新位置，我们可以处理我们卡住的 'h'。你猜怎么着？从 "s" 节点，确实有一条通往 'h' 的路径！我们走这条路。我们成功地处理了 "sh"，而从未在文本中回溯。

这就是核心思想。失效链接是在不匹配时采取的快捷方式，它从失败尝试的结尾处挽救信息，以找到新的开始。

那么，这个“第二次机会”到底是什么呢？从代表字符串 $s$ 的节点出发的失效链接，指向代表**字符串 $s$ 的、同时也是词典中某个模式前缀的最长真后缀**的节点 [@problem_id:3205763] [@problem_id:3205069]。这是一个极其对称的概念：它将一个字符串的*结尾*连接到另一个字符串的*开头*。这是信息的终极回收利用。

### 失效森林

这些链接不仅仅是杂乱无章的快捷方式集合。它们在自动机内部形成了一个隐藏的次级结构——一个“失效森林”。如果你把状态想象成岛屿，把失效链接想象成单向桥梁，你会发现从任何一个岛屿出发，你总能沿着桥梁路径回到主岛——根节点（代表空字符串）[@problem_id:3205069]。

你沿着失效链接所走的这条路径并非任意。它按长度递减的顺序列举了你当前字符串的每一个既是某个模式前缀又是其后缀的子串 [@problem_id:3205069]。这是你所有备用计划的完整、有序列表。

有人可能会认为，要获得一个具有长路径的深度、复杂的失效结构，你需要一个庞大而复杂的字母表。这个系统的美妙之处在于，事实并非如此。复杂性并非来自字母表，而是来自模式的自重叠性。在一个绝妙的思想实验中，我们可以看到，要创建一个长度与状态总数成正比的失效路径，所需的最小字母表大小仅为一！[@problem_id:3204992]。使用字母表 $\Sigma = \{a\}$ 和单个模式如 "aaaaa"，自动机是一条简单的状态链。从代表 $a^5$ 的状态出发的失效链接指向 $a^4$，从 $a^4$ 指向 $a^3$，依此类推，创建了一条与模式本身一样长的失效路径。这显示了结构胜于原材料的力量。

### 重叠的神谕

失效链接网络远不止是处理不匹配的机制。它是一张关于*整个*词典中所有后缀-前缀关系的完整、可查询的地图。它已经隐式地完成了将每个模式的结尾与所有其他模式的开头进行比较的艰巨工作。

为了看到这种力量的实际作用，考虑一个不那么明显的任务：在你的词典中找到共享最长公共后缀（其中该后缀也是词典中的一个有效前缀）的模式对 [@problem_id:3205016]。对于像 `{"banana", "ana", "nana", "bandana"}` 这样的词典，这将涉及许多乏味的[字符串比较](@article_id:638879)。

有了 Aho-Corasick 自动机，答案早已计算完毕，等待被发现。我们只需追踪每个模式最终状态的失效路径。我们正在寻找的公共后缀由自动机中的一个节点表示。最长的那一个将是恰好位于至少两个不同模式的失效路径上的最深节点。在我们的例子中，代表 "ana" 的节点位于 "banana" 的失效路径上，并且它本身就是一个模式。代表 "nana" 的节点也位于 "banana" 的失效路径上。通过分析这个失效结构，我们可以高效地发现这些深层联系。这个为搜索而构建的自动机，已经成为了[结构分析](@article_id:381662)的神谕。

### 精巧之网

这个错综复杂的失效链接网络创建了一个整体的、深度互联的系统。任何单个节点的失效链接不仅取决于其自身的字符串；它还取决于词典中的*整个*模式集合。

当我们考虑删除一个模式时，这一点就变得很清楚了 [@problem_id:3205059]。假设我们的词典是 `{"abc", "bc"}`。从代表 "abc" 的节点出发的失效链接将指向代表 "bc" 的节点，因为 "bc" 是 "abc" 的最长真后缀，并且也是我们词典中的一个模式（因此也是一个前缀）。

现在，如果我们删除 "bc" 会发生什么？从 "abc" 出发的失效链接不能再指向 "bc" 节点，因为来自模式 "bc" 的前缀 "bc" 不再“正式”存在。这个链接必须被重新评估。"abc" 的次长真后缀，如果它是一个前缀的话，可能是 "c"（假设存在像 "cat" 这样的模式），或者如果不存在，就是空字符串（根节点）。删除单个模式可能会在整个自动机中引发失效链接的连锁变化。这个网络编织得如此紧密，以至于移除一根线就可能迫使我们重新编织整个结构。这就是为什么处理动态删除的最直接方法通常是重新构建整个自动机。

### 线性之雅

你可能会认为，构建这样一个复杂、互联的网络，然后用它来搜索，一定是一个[计算成本](@article_id:308397)高昂的过程。这里就是这幅拼图的最后，也许是最美的一块：它的速度快得惊人。构建整个自动机（包括[前缀树](@article_id:638244)和所有失效链接）然后搜索文本的整个过程，所需时间与模式总长度加上文本长度（$L+n$）成正比 [@problem_id:3205763]。这被称为**线性时间复杂度**，是高效[算法](@article_id:331821)的圣杯。

这种卓越的效率得益于一种称为**[摊还分析](@article_id:333701)**（amortized analysis）的巧妙记账技巧 [@problem_id:3204915]。虽然单次不匹配可能会触发沿着失效链接的一长串跳转，但在整个搜索过程中，这类跳转的总数是严格受限的。我们在文本中每前进一步，都“支付”了可能需要沿着失效链接后退的成本。最终结果是，我们以单一、高效的遍数不可阻挡地在文本中前进。该[算法](@article_id:331821)的结构不仅强大；它被证明是最高效的，是[计算设计](@article_id:347223)的真正杰作。

