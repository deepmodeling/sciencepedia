## 引言
在[数字逻辑](@article_id:323520)和计算领域，[有限状态机](@article_id:323352)（FSM）是那些必须记忆过去以指导未来行动的系统的基本蓝图。虽然其基本概念涉及根据输入在一组有限的状态之间转换，但一个关键的设计问题随之出现：机器应如何产生输出？本文通过探讨带输出 FSM 的两个主要类别——Moore 型[状态机](@article_id:350510)和 Mealy 型[状态机](@article_id:350510)，来解决这一根本性的分歧。接下来的章节将首先在**原理与机制**中剖析它们的核心操作差异，审视基于状态的输出和基于转换的输出之间的选择如何决定时序、反应速度和设计复杂性。随后，**应用与跨学科联系**部分将揭示这些理论模型如何成为从数字[序列检测器](@article_id:324798)、[数据转换](@article_id:349465)器到合成生物学中的工程化基因电路等各种应用的实际主力。

## 原理与机制

在每个能够记忆、决策和行动的[数字电路](@article_id:332214)的核心，都存在一个优美而简单的概念：**[有限状态机](@article_id:323352)（FSM）**。可以把它想象成一个机器的蓝图，这个机器在任何给定时间只能处于有限数量的“状态”或情境之一。它根据接收到的输入从一个状态跳到另一个状态，就像棋盘游戏中的玩家移动一样。但一个真正有用的机器不能仅仅移动；它必须进行通信。它需要产生输出。而正是在通信的*方式*和*时机*上，出现了一个引人入胜且根本性的设计选择，将 FSM 的世界分成了两大阵营：Moore 型状态机和 Mealy 型状态机。

### 根本[性选择](@article_id:298874)：位置 vs. 路径

想象你正在探索一座奇特的魔法城堡。你进入的每个房间的墙壁都涂有一种独特、不变的颜色。“蓝色房间”永远是蓝色的，“红色房间”永远是红色的。你对颜色的体验完全取决于你当前*所在*的房间。这就是 **Moore 型[状态机](@article_id:350510)**的精髓。

在 Moore 型[状态机](@article_id:350510)中，输出仅仅是当前状态的函数。机器的“输出逻辑”就像一个传感器，它只关注自己所处的状态——比如状态 $S_2$——然后宣布：“我们在 $S_2$ 状态，所以输出必须是‘1’！” 它不关心我们是如何到达 $S_2$ 的，也不关心当前有什么输入在敲门。[@problem_id:1969121] 这赋予了 Moore 型状态机一种稳定、可预测的特性。它的输出和状态本身一样稳定，在机器保持该状态的整个期间都保持不变。

让我们具体来看。考虑一个由以下[状态表](@article_id:323531)指定的控制器，其中 `PS` 是现态（Present State），`Z` 是输出：[@problem_id:1962893]

| 现态 (PS) | 次态 (NS), X=0 | 次态 (NS), X=1 | 输出 (Z) |
| :-------: | :------------: | :------------: | :------: |
|   $S_0$   |     $S_1$      |     $S_0$      |    0     |
|   $S_1$   |     $S_2$      |     $S_0$      |    0     |
|   $S_2$   |     $S_2$      |     $S_0$      |    1     |

注意输出 `Z` 只有一个单独的列。如果机器处于 $S_0$ 状态，输出为 `0`。如果处于 $S_1$ 状态，输出为 `0`。如果处于 $S_2$ 状态，输出为 `1`。输出直接且唯一地与状态绑定。因此，如果你向这个机器输入一个长度为 $n$ 的序列，它将经过 $n+1$ 个状态（包括初始状态），从而产生一个长度为 $n+1$ 的输出字符串。[@problem_id:1386390]

现在，想象另一种魔法城堡。这里的房间本身很普通，但*门廊*被施了魔法。通过一个特定的门廊——比如，用‘a’钥匙从回声大厅到图书馆——会使一个铃铛响起。用另一把钥匙‘b’通过同一个门廊，可能会产生不同的声音，或者根本没有声音。这就是 **Mealy 型状态机**的世界。

在 Mealy 型状态机中，输出同时取决于**当前状态**和**当前输入**。它是一个与*转换*（从一个状态到另一个状态的旅程）相关联的事件。[@problem_id:1386390] 它的输出逻辑更复杂；它同时观察当前状态（“我们在哪里？”）和当前输入（“现在发生了什么？”）来做出决策。

考虑另一个控制器的[状态表](@article_id:323531)：[@problem_id:1962893]

| 现态 (PS) | 次态 (NS), X=0 | 输出 (Z), X=0 | 次态 (NS), X=1 | 输出 (Z), X=1 |
| :-------: | :------------: | :-----------: | :------------: | :-----------: |
|   $S_0$   |     $S_1$      |       0       |     $S_0$      |       0       |
|   $S_1$   |     $S_2$      |       0       |     $S_0$      |       0       |
|   $S_2$   |     $S_2$      |       0       |     $S_0$      |       1       |

仔细观察 $S_2$ 状态。如果机器在 $S_2$ 状态并接收到输入 `0`，它输出 `0`。但如果它在完全相同的 $S_2$ 状态并接收到输入 `1`，它输出 `1`。输出不是状态本身的属性，而是状态-输入对的属性。这使得 Mealy 型状态机更具动态性，反应更快。对于一个长度为 $n$ 的输入字符串，它执行 $n$ 次转换，因此恰好产生 $n$ 个输出。

### [时间问题](@article_id:381476)：固有的延迟

这个看似简单的设计选择——将输出与状态绑定，还是与转换绑定——带来了一个深刻且不可避免的后果：时序。

让我们来追踪一个同步 Moore 型[状态机](@article_id:350510)的生命周期。一切都随着主时钟的节拍进行。在每个“滴答”声中，机器按精确的顺序做三件事：
1.  它查看其当前寄存的状态 $s[k]$ 和当前输入 $x[k]$。
2.  基于这些，其组合逻辑计算出*下一个*状态 $s[k+1]$。
3.  在下一个时钟滴答时，这个下一个状态成为新的当前状态。

但输出从何而来？记住，在 Moore 型[状态机](@article_id:350510)中，输出 $y[k]$ *仅*取决于当前寄存的状态 $s[k]$。输入 $x[k]$ 可能会决定我们要进入一个输出不同的新状态，但我们要到下一个时钟滴答才能*到达*那个新状态。因此，反映输入影响的输出只能在接收到该输入整整一个[时钟周期](@article_id:345164)*之后*才出现。这是每个 Moore 型状态机中一个根本性的、内置的“延迟”。[@problem_id:1969139]

而 Mealy 型[状态机](@article_id:350510)则活在当下。它的输出逻辑*同时*查看当前状态 $s[k]$ 和当前输入 $x[k]$。如果一个特定的输入到达并要求立即产生输出，Mealy 型[状态机](@article_id:350510)可以立刻在同一个时钟周期内产生它。它的反应更快。

让我们通过一个具体的目标来观察这一点：检测输入序列 `110`。想象我们为此任务设计了一个 Moore 型状态机和一个 Mealy 型[状态机](@article_id:350510)。我们给它们输入相同的流：`01101101`。[@problem_id:1935275]
-   在周期 2、3 和 4，输入序列是 `...1, 1, 0,...`。周期 4 的 `0` 完成了该序列。
-   **Mealy 型状态机**看到它处于“已看到`11`”状态且当前输入为 `0`，于是在周期 4 立即输出 `1`。
-   **Moore 型[状态机](@article_id:350510)**在周期 4 也看到了输入 `0`，于是决定转移到其特殊的“我找到了！”状态。然而，它直到周期 5 的开始才*进入*这个状态。由于它的输出取决于*身处*该状态，所以 `1` 直到周期 5 才出现。

当我们追踪整个序列时，输出说明了一切：
-   输入: `0 1 1 0 1 1 0 1`
-   Mealy 输出 ($Z_{\text{Mealy}}$): `0 0 0 1 0 0 1 0`
-   Moore 输出 ($Z_{\text{Moore}}$): `0 0 0 0 1 0 0 1`

Mealy 型状态机的检测结果早出现一个周期。它反应更快。在从信号处理到网络协议的无数应用中，这是一个至关重要的区别。

### 设计的经济性：更快反应的代价

那么，Mealy 型[状态机](@article_id:350510)更快。它总是更好吗？如同工程学中所有伟大的事物一样，这里存在一个权衡。这种快速反应的代价通常涉及状态的复杂性。

让我们回到序列检测。为了检测一个长度为 $N$ 的序列，通常需要状态来表示已看到第一个比特、前两个比特，以此类推，直到前 $N-1$ 个比特。因此，对于序列 `0010`（长度为 4），我们需要状态来表示空匹配、已看到 `0`、已看到 `00` 和已看到 `001`。总共是 4 个状态。[@problem_id:1928658]

-   在 **Mealy 型状态机**中，当我们处于“已看到`001`”状态且输入 `0` 到达时，我们可以在该转换上直接输出 `1`。这 4 个状态就足够了。$N_{\text{Mealy}} = 4$。
-   在 **Moore 型[状态机](@article_id:350510)**中，输出 `1` 必须与一个状态本身绑定。我们不能即时产生它。因此，在看到最后的 `0` 之后，机器必须转换到一个*新的*、专用的“检测”状态，其唯一目的就是输出 `1`。这意味着我们需要 4 个状态来跟踪前缀，*外加*第五个状态用于输出。$N_{\text{Moore}} = 5$。

通常，为了检测一个长度为 $N$ 的序列，Mealy 型[状态机](@article_id:350510)通常可以用 $N$ 个状态构建，而等效的 Moore 型[状态机](@article_id:350510)则需要 $N+1$ 个状态。Moore 型[状态机](@article_id:350510)为其稳定的、基于状态的输出付出了一个额外状态的代价。

### 转换的艺术：它们说的是同一种语言吗？

如果这两个模型如此不同，我们可以在它们之间进行转换吗？答案是肯定的，而且转换的过程揭示了它们之间最深层的联系。

**Moore 到 Mealy：简单的方向**

将 Moore 型[状态机](@article_id:350510)转换为等效的 Mealy 型[状态机](@article_id:350510)非常直接。回想一下那个[奇偶校验器](@article_id:347568)，它在有偶数个 1 时输出 'E'，在有奇数个 1 时输出 'O'。在其 Moore 形式中，它有一个状态 $S_E$（输出 'E'）和一个状态 $S_O$（输出 'O'）。[@problem_id:1383550]
要获得等效的 Mealy 型，我们保留相同的状态和转换。对于任何转换的输出，我们只需向前看：我们*即将进入*的状态的输出是什么？
-   在 Moore 型[状态机](@article_id:350510)中，从 $S_E$ 到 $S_O$ 的转换会进入一个输出为 'O' 的状态。因此，相应的 Mealy 转换的输出将是 'O'。
-   一个保持在 $S_E$ 的转换会进入一个输出为 'E' 的状态。因此，Mealy 转换的输出是 'E'。

Mealy 型状态机[实质](@article_id:309825)上“预计算”了 Moore 型状态机的下一个输出。

**Mealy 到 Moore：状态拆分的艺术**

反向转换才是真正神奇之处，也更棘手一些。核心问题是：一个单一的 Mealy 状态，我们称之为 $Q_A$，可能是具有*不同*输出的多个转换的目的地。例如，从 $Q_B$ 的一个转换可能去往 $Q_A$ 并输出 `1`，而从 $Q_C$ 的一个转换也去往 $Q_A$ 但输出 `0`。[@problem_id:1962845]

如果我们试图创建一个单一的 Moore 状态 $A$，它的输出应该是什么？它不能同时是 `1` 和 `0`。解决方法很巧妙：我们**拆分状态**。我们不创建一个 Moore 状态 $A$，而是创建两个：
-   $A_1$，一个输出为 `1` 的 $A$ 的版本。
-   $A_0$，一个输出为 `0` 的 $A$ 的版本。

然后，我们重定向进入的转换。原来产生 `1` 的从 $Q_B$ 的转换现在指向我们的新状态 $A_1$。原来产生 `0` 的从 $Q_C$ 的转换现在指向 $A_0$。从外部看，输入-输出行为被保留了（尽管如预期的那样延迟了一个周期），但在内部，我们已经消除了状态输出的歧义。[@problem_id:1968913]

这种状态拆分的过程很强大，但可能是有代价的。如果一个 Mealy 状态是具有许多不同输出值的转换的目标，它就必须被拆分成许多相应的 Moore 状态。一个紧凑的 2 状态 Mealy 型[状态机](@article_id:350510)可能会爆炸成一个 5 或 6 状态的 Moore 型状态机。[@problem_id:1370711] 这种“状态爆炸”是 Moore 模型为其将输出与输入逻辑清晰分离所付出的最终代价。这是我们最初那个简单选择——魔法是在位置中，还是在路径中——所带来的优美而合乎逻辑的后果。