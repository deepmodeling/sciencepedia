## 引言
[操作系统](@entry_id:752937)是您计算机的总指挥，协调着硬件与软件之间复杂的和谐运作。然而，在这个数字交响乐团中，恶意行为者和有缺陷的程序构成了持续的威胁，将指挥家变成了安全主管。任何[操作系统](@entry_id:752937)面临的根本挑战都是如何用可能不可信的代码构建一个信任的堡垒。它如何强制程序之间的隔离、保护自身的完整性并安全地提供服务？这正是本文旨在回答的核心问题。

本次探索将引导您了解[操作系统](@entry_id:752937)安全的基本层次。在第一章“**原理与机制**”中，我们将深入探讨硬件强制的[保护基](@entry_id:201163)础，从 CPU 权限级别到建立[信任根](@entry_id:754420)的[安全启动过程](@entry_id:754617)。随后，在“**应用与跨学科联系**”中，我们将看到这些原理如何应用于防御真实世界的攻击，并发现它们与密码学和硬件物理学等领域的深层联系。我们的旅程始于最底层：处理器的芯片，我们数字堡垒的第一道墙就是在这里筑起的。

## 原理与机制

我们已经谈到，[操作系统](@entry_id:752937)就像一个指挥硬件和软件交响乐团的伟大指挥家。但这个故事也有其阴暗面。并非所有程序都是行为端正的音乐家。有些是破坏者， actively trying to wreak havoc. 于是，[操作系统](@entry_id:752937)不仅是指挥家，还是安全主管。其最深刻、最具挑战性的角色是执行保护，从一片可能不可信的代码海洋中构建一个值得信赖的系统。它究竟是如何做到这一点的？这种信任甚至从何而来？让我们踏上一段旅程，从处理器的裸机开始，看看这些安全层是如何一层层构建起来的。

### 处理器的长城

想象一下，你正在尝试建造一个安全的堡壘。你首先要建造什么？一堵又高又坚固的墙。在计算机中，这堵墙直接铸造在处理器的硅片中。它被称为**权限级别**（privilege levels）的区别。

大多数现代 CPU 至少在两种模式下运行。一种是**[用户模式](@entry_id:756388)**（user mode），你的网页浏览器、游戏和文本编辑器都生活在这里。这是一个充满市民的繁华城市。另一种是**[内核模式](@entry_id:755664)**（kernel mode）（或称**监管者模式**，supervisor mode），这是一个受限制的内部圣殿，国王——操作系统内核——居住于此。这不仅仅是一个君子协定；它是由硬件强制执行的。有一些强大的指令，即**特权指令**（privileged instructions），如果尝试在[用户模式](@entry_id:756388)下执行，CPU 会直接拒绝。例如，试图从[用户模式](@entry_id:756388)停止整个机器或重新配置核心硬件部件，将导致 CPU 立即停止当前工作并发出求助信号。这个信号是一个**陷阱**（trap），即强制转换到[内核模式](@entry_id:755664)，然后由内核处理这个行为不端的程序，通常是终止它。硬件本身保证了内核的最终权威。

但这还不够。即使用户程序不能发布皇家法令，我们仍然需要阻止它们闯入彼此的房子并阅读它们的日记。每个程序都需要自己的私密世界。这时，另一项硬件魔法就派上用场了：**[内存管理单元 (MMU)](@entry_id:751869)**。内核为每个进程提供一个原始、私密的**[虚拟地址空间](@entry_id:756510)**（virtual address space）。当一个程序试图访问地址 $A$ 处的内存时，它不是一个*物理*内存地址，而是一个虚拟地址。MMU 就像内核忠实的地图绘制师，将这个[虚拟地址转换](@entry_id:756527)为一个真实的物理地址。它使用的转换表由内核设置和管理。如果一个程序试图访问一个在其自身映射中没有有效转换的虚拟地址，MMU 会向 CPU 发出“故障！”（fault!）的信号，CPU 会再次陷入内核。

权限级别和虚拟内存的结合是所有[操作系统](@entry_id:752937)安全的基石。它在进程之间创建了硬件强制的隔离。一种语言的运行时可能会在单个进程内提供其自己更细粒度的[内存安全](@entry_id:751881)，但正是由[操作系统](@entry_id:752937)管理的 MMU 提供了不同程序之间或程序与内核本身之间最终的、不可协商的边界 [@problem_id:3664604]。

### [系统调用](@entry_id:755772)网关

现在，我们的用户程序被安全地限制在它们自己的小[沙盒](@entry_id:754501)里。但这有点*太*安全了。一个无法与外部世界互动的程序——不能读取文件、不能发送网络数据包，甚至不能在屏幕上打印——是一个无用的程序。它们需要能够请求全能的内核代表它们执行这些操作。

这是通过**[系统调用接口](@entry_id:755774)**（system call interface）完成的，这是[用户模式](@entry_id:756388)和[内核模式](@entry_id:755664)之间墙上的一小组、守卫森严的门。当一个程序需要某些东西时，它将其请求打包到特定的 CPU 寄存器中，并执行一条特殊指令（如 `SYSCALL`）。这条指令是一个*故意的*陷阱。这是敲响内核大门的官方方式。

一旦进入[内核模式](@entry_id:755664)，[操作系统](@entry_id:752937)就变成了一个引用监控器（reference monitor）。它必须实践**完全中介**（complete mediation）：在行动前检查每一个请求。这个用户有权限打开这个文件吗？这个网络地址有效吗？这种警惕的检查至关重要。一个特别敏感的例子是使用 `[setuid](@entry_id:754715)` 系统调用更改进程的身份。在 POSIX 系统中，一个进程拥有一个包含用户 ID 的凭证三元组：真实 ID ($u_r$)、有效 ID ($u_e$) 和已保存 ID ($u_s$)。内核的策略是严格的：一个普通进程只能将其有效 ID 更改为其实际 ID 或已保存 ID。但是一个以超级用户（`root`，其 $u_e = 0$）的有效 ID 运行的进程可以将其身份更改为*任何人*。内核必须原子地执行这些规则以防止任何安全漏洞。现代设计甚至正在摆脱传递像用户 ID 这样的原始数字，转而支持不可伪造的、临时的**能力令牌**（capability tokens），这些令牌授予执行单个特定操作的权利——这是一种更细粒度、更安全的方法 [@problem_id:3686203]。

### 强大代理人的危险

CPU 不是唯一可以访问内存的组件。为了达到我们期望的存储驱动器和网卡的惊人速度，它们使用一种称为**直接内存访问 (DMA)** 的技术。这使得设备可以直接向主内存写入数据或从主内存读取数据，而无需为每个字节都去打扰 CPU。

想一想这其中的安全隐患。这太可怕了！如果一个应用程序可以告诉网卡，“嘿，把你的传入数据直接 DMA 到内核代码上”，那就游戏结束了。这就是为什么允许用户空间进程直接编程一个总线主控设备是[操作系统](@entry_id:752937)安全的根本大忌之一。

[操作系统](@entry_id:752937)必须充当中间人。一个标准的、安全的模式是内核和用户进程共享一块内存，通常组织成一个高性能的**[环形缓冲区](@entry_id:634142)**（ring buffer）。用户进程将其请求（例如，“发送此[数据缓冲](@entry_id:173397)区”）写入缓冲区——这个操作不需要特殊权限。当它有一个或多个请求准备就绪时，它会进行一次单一、简单的[系统调用](@entry_id:755772)来“按门铃”。然后内核被唤醒，仔细检查用户写入的请求，并且——这是关键部分——**验证所有内容**。这个进程真的拥有它想发送的内存缓冲区吗？长度是否有效？只有在这次验证之后，内核才会亲自执行编程设备 DMA 寄存器的特权操作。这种设计通过批量处理请求来提供高性能，同时保持了完美的安全性，因为不受信任的用户代码永远不会接触硬件控制 [@problem_id:3669161]。为了增加另一层防御，现代系统还包括一个 **[IOMMU](@entry_id:750812)**，它的作用类似于设备的 MMU，确保即使是一个有 bug 或恶意的设备也只能在内核授权的特定内存区域内执行 DMA [@problem_id:3673116]。

### [信任链](@entry_id:747264)

我们已经阐明了一个正在运行的内核如何保护自身和系统。但我们如何知道启动的内核是*正确的*内核？如果病毒在计算机启动前就修改了磁盘上的内核文件怎么办？为了让系统真正值得信赖，我们需要一个在[操作系统](@entry_id:752937)加载之前就开始的**[信任根](@entry_id:754420)**（root of trust）。

这是通过**[信任链](@entry_id:747264)**（chain of trust）实现的，从硬件本身开始。第一个环节是 **UEFI [安全启动](@entry_id:754616)**（UEFI Secure Boot）。计算机的固件持有一组来自可信供应商（如 Microsoft 或硬件制造商）的加密密钥。在加载[操作系统](@entry_id:752937)[引导加载程序](@entry_id:746922)之前，固件会验证其[数字签名](@entry_id:269311)。如果签名有效，它就会执行[引导加载程序](@entry_id:746922)。[引导加载程序](@entry_id:746922)反过来在执行[操作系统内核](@entry_id:752950)之前验证其签名。如果此链中的任何签名缺失或无效，引导过程将停止。这为内核代码是真实且未经修改的提供了强有力的保证 [@problem_id:3679572]。

但是，如果我们不仅需要知道系统是干净的，还需要一份关于它*如何*启动的精确记录呢？这就是**[度量启动](@entry_id:751820)**（Measured Boot）和**[可信平台模块 (TPM)](@entry_id:756205)** 的工作。TPM 是主板上的一个小型、防篡改的芯片。在[度量启动](@entry_id:751820)期间，[信任链](@entry_id:747264)中的每个组件——固件、[引导加载程序](@entry_id:746922)、内核——在执行下一个组件之前都会“度量”（计算其加密哈希值）它。然后，它将此度量安全地记录在 TPM 的平台配置寄存器 (PCRs) 中。PCR 上的 `extend` 操作是单向的：$PCR_{new} \leftarrow \text{HASH}(PCR_{old} || \text{measurement})$。这些 PCR 值不能被软件伪造或回滾，即使是内核也不行。它们构成了整个启动过程的不可腐蚀的加密指纹。

这个指纹可以用两种强大的方式来使用。通过**[远程证明](@entry_id:754241)**（remote attestation），服务器可以要求客户端提供其 PCR 的签名“报价”，以证明它在被授予网络访问权限之前是在一个纯净状态下启动的。通过**封印**（sealing），像磁盘加密密钥这样的秘密可以被锁定到特定的 PCR 值上，这样 TPM 只有在机器启动到一个已知的良好状态时才会释放密钥。即使是在运行中的[操作系统](@entry_id:752937)上拥有完全管理员权限的攻击者也无法窃取这些被封印的秘密，因为他们无法伪造一个被篡改的启动过程所对应的受[硬件保护](@entry_id:750157)的 PCR 度量值 [@problem_id:3679572]。

### 策略无处不在

硬件和内核提供了强大的保护*机制*。但这些机制必须由定义了谁被允许做什么的*策略*来指导。一个未上锁的银行金库是无用的。

最熟悉的策略是**[自主访问控制 (DAC)](@entry_id:748518)**（Discretionary Access Control），即基于用户和用户组对文件的标准读/写/执行权限。“自主”部分意味着文件的所有者可以决定谁可以访问它。它很灵活，但并不总是足够。

对于更高安全性的环境，我们使用**[强制访问控制 (MAC)](@entry_id:751659)**（Mandatory Access Control）。在这里，系统管理员定义了一个僵化的、系统范围的策略，单个用户无法更改。最著名的例子是 **SELinux**。每个进程（一个“主体”）和每个文件或资源（一个“对象”）都会得到一个安全标签或“类型”。MAC 策略由明确的规则组成，规定了某种类型的主体可以对另一种类型的对象执行哪些操作。

这些系统提供了**[纵深防御](@entry_id:203741)**（defense in depth）。但它们的强度取决于它们的配置。考虑一个需要绑定到特权网络端口并从目录中读取图像的 Web 服务 [@problem_id:3664575]。管理员可能为了方便而违反**[最小权限原则](@entry_id:753740)**（principle of least privilege）。首先，他们授予服务过于宽泛的 POSIX 能力，例如 `CAP_DAC_OVERRIDE`，这让它能绕过所有文件读取权限。其次，他们将一个通用的、宽松的 SELinux 标签应用于一个恰好包含敏感文件（如私钥）的整个目录树。一个在 Web 服务中发现简单错误的攻击者现在可以利用其过于慷慨的权限来读取秘密文件。这次访问被 DAC 层（被能力绕过）和 MAC 层（被错误的标签允许）都“允许”了。[操作系统](@entry_id:752937)机制完美地工作了；它们执行了被赋予的（有缺陷的）策略。这是一个 humbling lesson：安全工具不是魔法。它们的有效性完全取决于一个精心设计的、最小化的策略。

### 内在的敌人

即使有所有这些保护层，一个聪明的对手也能找到方法让系统的组件反戈一击。这就是**困惑的代理人攻击**（confused deputy attack）的本质：一个有权限的程序（代理人）被攻击者欺骗，滥用其权力。

一个经典的例子涉及 **[setuid](@entry_id:754715)** 程序——以提升的权限运行的可信程序——和 `[LD_PRELOAD](@entry_id:751203)` 环境变量。攻击者可以设置 `[LD_PRELOAD](@entry_id:751203)` 指向一个恶意库，希望特权程序会加载并执行他们的代码。早期的系统对此很脆弱！修复方法是一个[可信计算基](@entry_id:756201)协同工作的优美范例。内核检测到一个程序正在 `[setuid](@entry_id:754715)` 上下文中运行（其中真实用户 ID 和有效用户 ID 不同），并向用户空间[动态链接](@entry_id:748735)器传递一个标志（`AT_SECURE`）。链接器看到这个标志后会进入一个“安全模式”，在这种模式下，它会故意忽略 `LD_PROLOAD` 和其他有潜在危险的环境变量 [@problem_id:3636923]。威胁通过系统自身的自我意识被化解了。

这导致了一个有趣的“保护悖论”。有时，增加安全性的行为会产生新的风险。想想一个杀毒软件扫描器。为了有效，它需要检查每个文件和网络数据包。这需要在[操作系统](@entry_id:752937)中有深入的钩子，以及解析数百种文件格式的复杂逻辑。如果这个扫描器作为驱动程序在内核内部运行，那么其 PDF 解析器或 ZIP 解压缩器中的任何 bug 现在都成了系统最特权部分的 bug——一个潜在的灾难 [@problem_id:3673331]。

现代的架构解决方案再次是最小权限和 compartmentalization 原则。我们不在内核中运行复杂、高风险的解析逻辑，而是在一个[沙盒](@entry_id:754501)化的、低权限的用户空间进程中运行它。内核的角色被简化为一个简单、最小的中间人：它安全地将要扫描的数据交给扫描进程，并接收一个简单的“干净”或“被感染”的裁决。这极大地缩小了内核的攻击面。我们甚至可以将用户空间程序的签名检查逻辑移到一个专门的守护进程中，从而进一步简化内核并减少[可信计算基 (TCB)](@entry_id:756202)，只要内核保留最终的、不可绕过的强制执行钩子 [@problemid:3679587]。这种模式的美妙之处在于其普遍性，同样适用于[设备驱动程序](@entry_id:748349)、恶意软件扫描器等。

### 未来是粒度的

用户和内核的双模式模型几十年来一直是计算的主力。但它很粗糙。图形驱动程序中的一个 bug 和核心调度器中的一个 bug 一样致命，因为它们都运行在[内核模式](@entry_id:755664)下。

如果我们有更多模式会怎样？有人提出了具有多个硬件权限环的假设性 CPU——比如说，$R=16$ 或 $R=64$ [@problem_id:3673116]。这为令人难以置信的 compartmentalization 提供了*机制*。但正如我们所学到的，机制不是策略。一个将几十个系统组件直接映射到几十个编号环的天真设计将造成一个策略噩梦——一个僵化的、线性的层次结构，无法表达真实系统中复杂的、偏序的信任关系。

前进的道路在于将[策略与机制](@entry_id:753556)分离。最健壮的设计使用这些额外的环，不是作为语义上的信任级别，而是作为纯粹的隔离隔间。安全策略在一个更高的抽象层次上定义，使用诸如**能力**（capabilities）——授予对特定对象的特定权利的不可伪造的令牌——之类的概念。一个进程的权限不是由它所在的环号决定的，而是由它持有的能力决定的。这种哲学是**微内核**（microkernel）设计的核心，它致力于在最特权的环中实现一个微小、可验证的内核，其唯一的工作就是管理通信和执行能力检查。所有其他服务——驱动程序、文件系统、网络栈——都作为非特权进程在它们自己的隔间中运行。这是最小权限的最终体现，一种不仅承诺安全，而且承诺一种我们可以推理和理解的安全的设计。构建一个可信赖系统的旅程仍在继续，不断深入硬件与软件之间优雅的舞蹈。

