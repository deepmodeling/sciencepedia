## 引言
在[数字电子学](@article_id:332781)的发展历程中，一个关键的转变是从创建功能固定的电路转向开发可为无数不同任务编程的硬件。在此之前，即使是实现一组简单的逻辑规则，也需要一套独特的、硬连线的逻辑门组合，这个过程对于原型设计和复杂设计而言既不灵活又效率低下。这一局限性催生了一个革命性的想法：如果一个单一的通用芯片可以作为一块“白板”，随时可以被配置成任何可以想象的[数字电路](@article_id:332214)，那会怎么样？这个概念就是[可编程逻辑器件](@article_id:357853) (PLD) 的精髓，这些器件从根本上重塑了数字设计。

本文将追溯 PLD 从基本原理到广泛应用的发展历程。我们将首先探讨支配这些器件的 **原理与机制**，揭示 PAL、PLA 以及更高级的 GAL、CPLD 和 FPGA 的核心架构。随后，在 **应用与跨学科联系** 部分，我们将考察它们的实际用途，从替代简单逻辑到在计算机系统中执行[地址译码](@article_id:344539)等复杂任务。我们首先将深入研究使这种可编程性成为可能的优雅数学基础。

## 原理与机制

想象一下，你想制造一台能做决策的机器。不是复杂的、会思考的机器，而是一个遵循一套严格规则的简单机器。例如，“如果这个按钮被按下，并且那盏灯熄灭，那么就拉响警报。”这就是数字逻辑的世界。在很长一段时间里，制造这样的机器意味着为每项新任务[焊接](@article_id:321212)一组特定的微小逻辑门——[与门](@article_id:345607)、或门、非门。这就像写一本书，每一本都必须手工单独排版。如果我们能创造一块逻辑的“白板”，一块可以被我们*编程*以执行任何我们想要的逻辑任务的通用画布，那会怎么样？这就是[可编程逻辑器件](@article_id:357853) (PLD) 背后的革命性思想。

### 逻辑的通用法则

这场革命的核心是一个极其简单而强大的数学真理：任何数字逻辑函数，无论看起来多么复杂，都可以用一种称为**“乘积和”(SOP)**的标准形式来描述。可以把它想象成一个通用法则。“积”是由与运算连接的输入信号的组合（如 `这个 AND 那个`），而“和”是组合这些乘积项的最终或运算。例如，函数“如果（按钮 A 被按下 且 按钮 B 未被按下）或（按钮 C 被按下），则拉响警报”就是一个完美的“乘积和”形式。

这意味着，如果我们能构建一个通用的硬件结构，它能够创建任何可能的与项（一个“积”），然后用一个或门将这些乘积项中的任意几个组合起来（一个“和”），我们就拥有了一个原则上可以实现*任何*逻辑函数的器件。这就是所有简单[可编程逻辑器件](@article_id:357853)的基本架构：一个与门平面连接到一个[或门](@article_id:347862)平面。“可编程性”来源于我们能够选择哪些输入进入哪些[与门](@article_id:345607)，以及哪些[与门](@article_id:345607)输出（乘积项）进入哪些[或门](@article_id:347862)。让我们看看这个绝妙的想法最初是如何形成的。

### PAL：简约大师及其局限

这个想法的第一个商业成功实践是**[可编程阵列逻辑](@article_id:351927) (Programmable Array Logic)**，简称 **PAL**。PAL 的设计哲学是一种绝妙的折衷。它为我们提供了一个可编程的**[与门](@article_id:345607)平面**，但[或门](@article_id:347862)平面是**固定的**。

这是什么意思呢？想象一个巨大的网格。垂直方向是器件每个输入信号及其逻辑反相（[补码](@article_id:347145)）的连线。对于输入 $I_1$，我们既有 $I_1$ 连线，也有 $\overline{I_1}$ 连线。水平方向是[与门](@article_id:345607)的输入端。在每条垂直连线和水平连线的[交叉](@article_id:315017)点，都有一个微小的连接，或称“熔丝”。要对[与门](@article_id:345607)平面进行编程，我们选择性地烧断不需要的熔丝，只留下我们希望包含在乘积项中的输入连接。例如，要创建乘积项 $I_1 \overline{I_2}$，我们只需保持连接 $I_1$ 连线和 $\overline{I_2}$ 连线到单个与门输入的熔丝完好，并烧断该行上的所有其他熔丝 [@problem_id:1954543]。

我们可以看看实际操作。假设我们想编程一个 PAL 来产生函数 $F(A, B, C) = A'B + AC'$。我们会编程一个[与门](@article_id:345607)，使其输入为 $A'$ 和 $B$，从而创建乘积项 $A'B$。然后我们会编程第二个[与门](@article_id:345607)，使其输入为 $A$ 和 $C'$，从而创建乘积项 $AC'$。任何未使用的与门都保持未连接状态，输出逻辑 0 [@problem_id:1954548]。

PAL 的折衷之处就在于此：**固定的[或门](@article_id:347862)平面**。在 PAL 中，每个与门的输出都永久性地连接到一个特定的或门。也许前八个[与门](@article_id:345607)连接到第一个或门（创建输出 $F_1$），接下来八个连接到第二个[或门](@article_id:347862)（创建 $F_2$），依此类推。这种结构虽然僵化，但使器件变得简单、快速且廉价。器件的名称本身通常就揭示了其结构。例如，一个 **PAL16L8** 告诉你它有 16 个输入和 8 个低电平有效（'L'）输出，清晰地描绘了其容量 [@problem_id:1954536]。

但这种优雅的简洁性是有代价的。如果一个函数，即使在化简后，需要的乘积项数量也超过了固定或门所能提供的数量，该怎么办？例如，如果一个输出的或门只能接受两个乘积项，那么在架构上就不可能实现像 $F_C = \overline{A}\overline{B}C + \overline{A}B\overline{C} + ABC$ 这样的函数，它化简后的最小和形式包含三个乘积项。即使芯片的其他部分未被使用，该器件在该输出引脚上就是缺乏资源 [@problem_id:1954567]。固定的连接是 PAL 的“阿喀琉斯之踵”。

### PLA：极致灵活性的代价

下一个自然而然的问题是：“如果我们也让[或门](@article_id:347862)平面变得可编程呢？” 这就引出了**[可编程逻辑阵列](@article_id:348093) (Programmable Logic Array)**，简称 **PLA**。PLA 同时拥有可编程的[与门](@article_id:345607)平面和可编程的[或门](@article_id:347862)平面。这意味着我们可以将[与门](@article_id:345607)平面中的*任何*乘积项连接到[或门](@article_id:347862)平面中的*任何*或门。

这种架构是两级逻辑灵活性的巅峰。单个乘积项可以被多个不同的输出函数共享，而无需重复生成。它完全克服了 PAL 的[资源分配问题](@article_id:640508)。然而，这种强大功[能带](@article_id:306995)来了高昂的代价。使每个可能的连接都可编程需要大量的熔丝。

让我们考虑一个简单的场景：有 $N=3$ 个输入，$M=2$ 个输出，需要 $P=3$ 个独特的乘积项来构建函数。一个 PAL 在其可编程与门平面中需要 $(2N)P = (2 \cdot 3) \cdot 3 = 18$ 个熔丝。而一个 PLA，除了其[与门](@article_id:345607)平面需要同样的 18 个熔丝外，其可编程或门平面还需要额外的 $PM = 3 \cdot 2 = 6$ 个熔丝，总共需要 24 个熔丝。对于同样的小任务，PLA 需要的熔丝数量是 PAL 的 $\frac{4}{3}$ 倍 [@problem_id:1954918]。这种增加的复杂性使得 PLA 体积更大、价格更贵，而且通常速度更慢。在市场上，更简单、“足够好”的 PAL 架构常常胜出。

### 浴火重生：可重用且功能多样的 GAL

早期的 PAL 和 PLA 还有一个主要缺点：它们是**一次性可编程 (OTP)**的。“熔丝”是字面意义上的金属或硅连接，会被高电流物理气化。如果你在设计中犯了错，你那价值数美元的芯片就变成了一小块无用的塑料。这对于原型设计和开发来说绝不理想。

突破来自于**[通用阵列逻辑](@article_id:343964) (Generic Array Logic)**，简称 **GAL**。GAL 没有使用物理上被破坏的熔丝，而是采用了一种从 **[EEPROM](@article_id:355199)**（[电可擦除可编程只读存储器](@article_id:355199)）借鉴的技术。每个连接都由一个**[浮栅晶体管](@article_id:351006)**控制。你可以把这个晶体管的栅极想象成一个可以储存[电荷](@article_id:339187)的微小孤岛。通过施加精确的电压，我们可以将电子强制推到这个岛上（捕获[电荷](@article_id:339187)）或将它们拉走。捕获[电荷](@article_id:339187)的存在与否决定了连接是“开”还是“关”。由于这个过程纯粹是电学的且非破坏性的，它是完全可逆的。GAL 可以被编程、测试、用电信号擦除，然后重编程数千次 [@problem_id:1939737]。

但 GAL 不仅仅是可重用的 PAL。它们在输出级通过**[输出逻辑宏单元](@article_id:356906) (OLMC)**引入了新的智能水平。命名约定也反映了这种增强的功能。一个 **GAL22V10** 最多有 22 个输入和 10 个输出，但其中的 'V' 代表**多功能 (Versatile)** [@problem_id:1939729]。这意味着 10 个 OLMC 中的每一个都是一个可配置的逻辑块。工程师不仅可以编程它来产生乘积和，还可以编程它来反转输出（高电平有效或低电平有效），甚至让它以完全不同的模式工作。

### 存储的魔力：反馈与状态机

OLMC 引入的最强大模式之一是**寄存器模式**。在这种配置下，或门的输出并不直接连接到输出引脚，而是被送入一个**D 型[触发器](@article_id:353355)**——一个简单的 1 位存储元件。在系统时钟的每个节拍，[触发器](@article_id:353355)捕获并保持来自或门的值。

这个简单的补充从根本上改变了器件的性质。到目前为止，我们的电路纯粹是**组合逻辑**电路：其输出仅取决于输入的当前状态。有了存储元件，我们就可以构建**时序**电路，其输出可以取决于过去输入的*历史*。这是计数器、控制器以及我们称之为**[状态机](@article_id:350510)**的基础。

使这一切成为可能的秘密武器是一条看似无害的连线：**反馈路径**。[触发器](@article_id:353355)的输出（代表机器的*当前状态*）被路由*回*可编程的[与门](@article_id:345607)平面，成为下一次计算的可用输入 [@problem_id:1939728]。这创造了一个优美的自引用循环。现在，逻辑可以根据外部输入和自身的当前状态来计算**下一状态**。这个简单的[反馈回路](@article_id:337231)将 GAL 从一个仅仅计算静[态函数](@article_id:301553)的计算器，提升为一个能够按序执行一系列操作的动态设备——这正是计算的灵魂所在。

### 构建帝国：通过 CPLD 和 FPGA 进行扩展

GAL 架构提供了一个强大且可重用的逻辑块。下一个合乎逻辑的步骤是将许多这样的块组合成一个更强大的单一芯片。这就催生了**[复杂可编程逻辑器件](@article_id:347345) (CPLD)**。一个 CPLD 本质上是驻留在同一块硅片上的 PAL/GAL 式逻辑块大军。

CPLD 的精妙之处不仅在于这些逻辑块本身，还在于它们的连接方式。它们都通过一个中央**[可编程互连](@article_id:351286)矩阵 (PIM)** 连接，这是一个复杂的交换台，可以将信号从任何块路由到任何其他块。这解决了一个简单 PAL 的主要低效问题。如果一个 PAL 中的两个不同输出函数需要相同的乘积项，PAL 的僵化结构会迫使你生成该项两次，浪费两个与门。而在 CPLD 中，一个逻辑块可以生成共享项，然后 PIM 可以有效地将其分配给需要它的其他块，从而节省资源 [@problem_id:1954571]。CPLD 与其祖先 GAL 一样，通常使用[非易失性存储器](@article_id:320114)，这意味着它们在通电时是“瞬时启动”的。

演进之路并未就此停止。对于更大、更复杂的系统，我们转向**[现场可编程门阵列](@article_id:352792) (FPGA)**。如果说 CPLD 是“粗粒度”的（由大的乘积和块构建），那么 FPGA 则是“细粒度”的。它的版图是成千上万个微小、相同的逻辑单元的汪洋大海。每个单元通常是一个小型的**查找表 (LUT)**——一个可以被编程以实现任何几个输入（例如 4 或 6 个）的可能逻辑函数的小型 RAM。这些 LUT 再通过一个高度灵活、分层的布线网络编织在一起。

与 CPLD 不同，大多数 FPGA 使用易失性的 **SRAM** 来存储其配置。这意味着它们在加电时是一块真正的“白板”，必须像计算机启动一样从外部存储器加载其“个性” [@problem_id:1934969]。这种权衡提供了令人难以置信的密度和灵活性，使得 FPGA 能够在单个可重构芯片上实现整个系统——处理器、信号处理[流水线](@article_id:346477)等等。

从一个可编程与或结构的简单而优雅的想法出发，我们遍览了整个器件家族，每一个都是对其前代产品局限性的巧妙回应。这是一个完美的工程演进故事，其中数学原理被转化为硅片，每一代都变得更强大、更灵活，为我们提供了构建我们周围数字世界的工具。