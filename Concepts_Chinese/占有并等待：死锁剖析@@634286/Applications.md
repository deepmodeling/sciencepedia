## 应用与跨学科联系

在解开了死锁配方的四个秘密成分之后，我们可能会倾向于认为它是一道罕见而奇特的菜肴，只在操作系统内核的深奥世界里才会烹制。但事实恰恰相反。这种冻结的动画状态，这种无声的对峙，是任何由必须共享有限资源的交互主体组成的系统中最基本、最反复出现的模式之一。我们讨论的原则不仅仅是计算机科学的琐事；它们像运动定律一样普遍。通过观察一些例子，从我们计算机的核心到广阔的互联网，我们可以开始领会这个概念的美妙统一性。

### 机器人与显微镜的故事

让我们从一个简单、直观的故事开始。想象一群小机器人，一整队，沿着一个由踏脚石构成的[圆形轨道](@entry_id:178728)移动。每块石头一次只能容纳一个机器人。游行的规则很简单：要前进，每个机器人必须预订路径上的下一块石头。现在，假设每个机器人都在同一时刻试图前进。在石头 $v_1$ 上的机器人 $R_1$ 试图预订石头 $v_2$，而 $v_2$ 正被机器人 $R_2$ 占据。机器人 $R_2$ 试图预订 $v_3$，它被 $R_3$ 占据，以此类推，环绕一圈，直到最后一个机器人 $R_m$ 试图预订石头 $v_1$——当然，它正被我们的第一个机器人 $R_1$ 占据。[@problem_id:3662779]

每个机器人都在占有一个资源（它当前的石头）并等待另一个。等待是循环的。谁也动不了。游行队伍被冻结了——一个完美、无声的死锁。

这不仅仅是机器人的困境。想象一下一所大学实验室里的两个雄心勃勃的学生，他们都需要一台高倍显微镜（$M$）和一台特殊的科学相机（$C$）来完成他们的实验。预订系统允许他们分开预订这些设备。一个决定性的下午，学生 $S_1$ 拿到了显微镜，等待相机，而学生 $S_2$ 拿到了相机，等待显微镜[@problem_id:3662814]。他们陷入了僵局，每人手持拼图的一部分，等待对方让步。这是“占有并等待”条件最具体的形式。最直接的解决方案是什么？一个“要么全有，要么全无”的策略。你必须一次性申请两台设备，只有当两者都空闲时，系统才会把它们都给你。这个简单的规则改变使得在等待一个资源的同时持有另一个资源变得不可能，通过打破占有并等待条件，巧妙地消除了死锁的可能性。

### 内核的内部纠葛

同样的对峙也困扰着我们计算机内部的无形世界。在[操作系统](@entry_id:752937)的核心，无数执行线程竞相管理内存、文件和网络连接，死锁的潜力是巨大的。

一个经典的例子发生在像跨两个不同目录重命名文件这样简单的事情上。为了安全地做到这一点，系统必须锁定源目录和目标目录。如果一个线程 $T_1$ 试图将文件从目录 $A$ 移动到 $B$，于是它锁定了 $A$ 然后等待 $B$ 呢？与此同时，线程 $T_2$ 试图将文件从 $B$ 移动到 $A$，锁定了 $B$ 并等待 $A$ 呢？[@problem_id:3662770] 我们就有了对峙。这里的解决方案纯粹而优雅：强制实施一个通用顺序。例如，总是先锁定 inode 号较小的目录。通过强制执行这个任意规则，我们打破了对称性。两个线程现在都会争夺同一个第一把锁，其中一个会获胜，从而阻止了[循环等待](@entry_id:747359)的形成。

但是我们不能总是创建这样一个简单的全局排序，特别是当一个[大系统](@entry_id:166848)的不同部分以意想不到的方式交互时。想象一个线程，在处理内存访问错误（页错误）时，需要从磁盘获取数据。为此，它必须获取磁盘通道资源 $C_{\mathrm{disk}}$。但首先，为了管理内存表，它持有了全局虚拟内存锁 $L_{\mathrm{VM}}$。现在，如果另一个线程，也许是一个[设备驱动程序](@entry_id:748349)，已经持有了磁盘通道 $C_{\mathrm{disk}}$，并且在其职责的一部分中，需要访问一个需要同一个 $L_{\mathrm{VM}}$ 的内存服务呢？[@problem_id:3662767] 第一个线程持有内存锁并等待磁盘；第二个线程持有磁盘并等待内存锁。僵局。

当我们意识到这场戏剧中的“主体”甚至不必是软件线程时，情节就变得更加复杂了。一块硅片，一个直接内存访问（DMA）引擎，也可以是一个同样固执的演员。一个驱动程序线程可能持有一个内存缓冲区，等待 DMA 硬件可用。但 DMA 硬件，在保留了自己的通道后，可能反过来在等待驱动程序线程的缓冲区对其操作变得可访问[@problem_id:3662756]。这揭示了死锁原则的美妙普适性：它无缝地跨越了软硬件的鸿沟。

有时被持有的资源不是一个设备或一个锁，而是更抽象的东西，比如一种*权限*。考虑一个复杂的“读写”锁，它允许多个“读者”线程同时访问数据，但要求“写者”线程具有独占访问权。一些系统允许读者将其共享锁“升级”为独占锁。如果一个读者进程 $P_R$ 持有共享锁并请求升级，而一个写者进程 $P_W$ 已经在等待独占锁呢？如果系统优先考虑等待的写者，它可能会阻塞 $P_R$ 的升级请求。现在，$P_R$ 被卡住，等待 $P_W$ 完成，但 $P_W$ 甚至无法开始，因为 $P_R$ 仍然持有它的共享锁！[@problem_id:3662736] 解决方案通常涉及一个小小的谦卑行为：为了打破占有并等待的循环，升级的读者必须完全释放其共享锁，并从头开始重新请求一个独占锁，与其他人一起排队。

### 超越内核：跨越边界

这些纠缠的依赖关系并不仅限于[操作系统](@entry_id:752937)的[单体内核](@entry_id:752148)。它们在我们构建抽象边界然后尝试跨越这些边界进行通信时随时都会出现。

一个绝佳的例子是“用户空间[文件系统](@entry_id:749324)”（FUSE），其中文件系统的逻辑作为一个普通程序运行，而不是在内核中。一个用户空间线程可能会获取一个用户空间锁 $U$，然后进行一个[系统调用](@entry_id:755772)，该调用要求内核获取一个内部内核锁 $K$。与此同时，内核可能正在处理一个请求，该请求迫使它*向上*调用到用户空间守护进程，这个过程需要获取同一个锁 $U$。如果一个持有 $K$ 的[内核线程](@entry_id:751009)进行向上调用并等待 $U$，而一个持有 $U$ 的用户线程进行系统调用并等待 $K$，我们又有了死锁[@problem_id:3662798]。解决方案揭示了一个深刻的架构原则：在持有自己的内部锁时，永远不要调用“外部”或更低级的代码。在进行向上调用之前释放内核锁，可以打破占有并等待条件，保持系统流畅。

同样的模式在现代云的架构中再次出现，在客户[虚拟机](@entry_id:756518)和其主机 hypervisor 的边界处。一个客户[操作系统](@entry_id:752937)可能在进行“hypercall”到主机时持有锁 $L_G$，而主机又需要一个主机锁 $L_H$。与此同时，一个主机进程可能持有 $L_H$，同时需要与客户机以一种需要 $L_G$ 的方式进行交互[@problem_id:3662774]。这是同样的死锁模式，只是演员不同。在这里，一个常见的解决方案是使用*分阶段操作*来打破占有并等待。客户机不是持有锁并进行阻塞调用，而是释放其锁并发起一个异步请求。主机完成工作后，只需通知客户机即可。没有占有，没有等待，没有[死锁](@entry_id:748237)。

### 全球等待之网

到目前为止，我们死锁的主体都生活在单台计算机上。但这些原则是普适的。当主体分散在全球网络中，仅通过发送消息进行通信时，它们同样适用。

想象一下三个[微服务](@entry_id:751978)，它们是许多现代 Web 应用的构建块。服务 $S_A$ 通过获取与其数据库 $D_A$ 的连接来处理请求，然后调用服务 $S_B$ 以获取更多信息。$S_B$ 在处理该调用时，获取其自己的数据库连接 $D_B$ 并调用 $S_C$。当 $S_C$ 持有其数据库连接 $D_C$ 并回调 $S_A$ 时，循环就完成了[@problem_id:3662809]。由于每个服务都在忙于等待响应，它们都无法应答传入的调用。这是一个[分布式死锁](@entry_id:748589)。一个常见但粗糙的解决方案是超时，它作为一种抢占形式：一段时间后，等待的服务放弃，释放其数据库连接，并返回一个错误。但一个更优雅的解决方案直接攻击占有并等待条件：设计服务，使其在进行缓慢的同步网络调用*之前*释放其宝贵的数据库连接。

也许最令人惊讶的发现死锁的地方，是它被编织在网络协议的结构中。在为现代网络大部分提供动力的 HTTP/2 中，数据以[多路复用](@entry_id:266234)流的形式发送，每个流都有[流量控制](@entry_id:261428)，以防止发送方压垮接收方。发送方消耗“窗口信用”来发送数据，而接收方只有在处理完数据后才会发放更多信用。现在，考虑一个设计不佳的应用程序，其中两个端点 $E_1$ 和 $E_2$ 正在相互通信。$E_1$ 处的应用程序逻辑规定，在完成发送自己的数据之前，它不会读取来自 $E_2$ 的传入数据。$E_2$ 也是如此。可能会出现这样一种情况：双方都发送了刚好足够耗尽对等方窗口信用的数据。$E_1$ 被卡住，无法发送更多数据，直到 $E_2$ 读取数据并发送信用更新。但 $E_2$ 不会读取，因为它正在等待完成发送自己的数据，而这需要来自 $E_1$ 的信用更新[@problem_id:3662701]。每个都在等待一个资源——发送的许可——而这个资源被对方持有。这是一个完美的、协议级别的死锁，源于[流量控制](@entry_id:261428)机制和应用程序逻辑的相互作用。打破它需要一个像 `RST_STREAM` 帧这样的激烈措施，这是一种协议级别的抢占，它中止其中一个流，让另一个继续进行。

从[轨道](@entry_id:137151)上的机器人到全球的服务，死锁的条件是一个普遍的常数。特别是，占有并等待条件是一个常见的罪魁祸首。然而，正如我们所见，击败它的策略往往会带来更健壮、更优雅、更周到的设计。“要么全有，要么全无”的资源获取原则，在进入陌生领域之前释放锁的原则，或者异步构建工作的原则，不仅仅是避免[死锁](@entry_id:748237)的技巧。它们是一个架构良好的系统的标志。这是通过率先退后一步来避免对峙的艺术。