## 引言
保证的价值是什么？当我们设计一个算法时，我们希望它能保证完成任务并给出答案。这种在计算中对确定性的基本渴望被**全函数**——一个保证对任何有效输入都会停机的过程——的概念所捕捉。虽然这看起来是一个简单的要求，但理解哪些函数是全函数以及我们如何能确信这一点的过程，揭示了计算机科学和逻辑学核心处一个深刻而令人惊讶的领域。这一探索揭示了什么是真实的与我们能形式化证明其为真之间的一道深刻鸿沟，这个鸿沟对我们理解知识本身具有重要意义。

本文深入探讨了可证全性这个迷人的世界。在第一章**“原理与机制”**中，我们将剖析不同类别的[可计算函数](@entry_id:152169)，从[原始递归](@entry_id:638015)的“安全”世界到一般递归的未开垦领域。我们将直面形式证明的局限性，发现为什么一些函数尽管是全函数，却无法在标准数学系统中被我们证明其为全函数。随后，在**“应用与跨学科联系”**中，我们将探讨这个概念巨大的实际重要性，从构建超可靠的软件，到数学的哲学基础，甚至现代监管科学的实践挑战。

我们的探索始于一个开启了[可计算性理论](@entry_id:149179)领域的问题，一个表面上看起来简单，却为我们能计算什么和我们能知道什么的极限打开了大门的问题。

## 原理与机制

想象一下你写了一个计算机程序。你给它一个输入，它便开始运转。你等待着。然后你继续等待。一个简单的问题出现了，这是整个计算机科学和逻辑学中最基本的问题之一：它会停机吗？这个看似直白的问题是通往一个关于计算、证明以及我们认知极限的深刻思想领域的入口。

### 停机问题：一个函数的宇宙

在数学中，我们可以将计算机程序看作一个**函数**。它接受一个输入（比如一个数 $x$），然后产生一个输出 $f(x)$。如果该程序保证对你可能给出的每个输入都会停机并给出答案，我们就称其函数为**全函数**。想象一下像 $f(x) = x+1$ 或 $f(x) = x^2$ 这样的函数；无论你输入什么自然数，你都肯定会得到一个自然数输出。

但是，如果程序对某些输入陷入了无限循环呢？例如，一个试图通过检查 2, 4, 6, 8,... 来寻找最大偶数的程序将会永远运行下去。对于这个“程序”，函数是未定义的。一个可能并非对所有输入都有定义的函数被称为**部分函数**。区别很简单：全函数对你问的每个问题都有答案，而部分函数可能对某些问题保持沉默。每个全函数也都是一个部分函数，只是它恰好在任何地方都有定义。[@problem_id:3049688]

### 一个发条宇宙：[原始递归函数](@entry_id:155169)

很自然地，我们可能会想，我们是否能构建一种“安全”的编程语言，使得我们写的每个程序都保证停机。答案是肯定的，你可以在这种语言中定义的函数被称为**[原始递归函数](@entry_id:155169)**。

你可以把构建这些函数想象成玩一套特殊的乐高积limù。
1.  **基本积木**：你从几个极其简单、显然是全函数的函数开始：
    *   **零函数**，它忽略输入，总是输出 0。
    *   **后继函数**，它接受一个数 $x$ 并输出 $x+1$。
    *   **投影函数**，它可以从其输入中挑选出任意一个（例如，给定 $(x, y, z)$，它可以输出 $y$）。

2.  **构建规则**：你有两种方法来组合现有的积木以制造新的积木：
    *   **复合**：这就像把函数相互插入。如果你有一个函数 $g(y)$ 和另一个函数 $h(x)$，你可以创建 $f(x) = g(h(x))$。如果 $g$ 和 $h$ 保证停机，那么 $f$ 也保证停机。
    *   **[原始递归](@entry_id:638015)**：这是这套工具中最强大的一个，但它仍然是完全安全的。它在数学上等同于编程中的 `for` 循环。它通过指定一个当 $y=0$ 时的起点，然后给出一个如何从 $y$ 处的值得到 $y+1$ 处的值的规则来定义函数 $f(x, y)$。例如，加法可以这样定义：
        *   $x + 0 = x$ （起点）
        *   $x + (y+1) = (x+y) + 1$ （从前一个值得到下一个值的规则）

为什么这总是安全的？因为要计算 $f(x, y)$，你只需要应用这个规则 $y$ 次。由于 $y$ 是一个有限数，这个过程保证会停止。你可以用这种方式构建乘法、指数运算以及大量其他各式各样的函数，并且它们中的每一个都将是全函数。它们构成了一种发条宇宙，其中每个计算都有一个可预测的、有限的终点。[@problem_id:3049688] [@problem_id:2979405]

有一段时间，数学家们想知道这个安全、可预测的宇宙是否就是*唯一*的[可计算函数](@entry_id:152169)宇宙。答案以一个“怪物”的形式出现。**[阿克曼函数](@entry_id:636397)**，$A(m,n)$，是一个定义良好且是全函数的函数——它对每一对自然数 $(m,n)$ 都会停机。但它的增长速度快得令人难以置信，以至于超过了所有可能的[原始递归函数](@entry_id:155169)。你可以证明它是全函数，但你无法用[原始递归](@entry_id:638015)的“安全”乐高积木来构建它。这是第一个暗示，表明全[可计算函数](@entry_id:152169)的世界比最初看起来的更大、更奇怪。[@problem_id:3049688] [@problem_id:3049705]

### 计算的狂野西部

为了捕捉像[阿克曼函数](@entry_id:636397)这样的函数，实际上是为了捕捉我们认为“可计算”的一切，我们需要一个更强大的工具。我们需要在我们的语言中加入等同于 `while` 循环的东西。在[可计算性理论](@entry_id:149179)中，这就是**[无界最小化](@entry_id:153993)算子**，或称**$\mu$-算子**。它表示，“搜索使某个性质为真的最小数字 $y$”。

例如，要找到一个数 $x$（大于 1）的最小因子，你可以要求 $\mu$-算子找到最小的 $y \ge 2$ 使得“$y$ 整除 $x$”。这个搜索保证会停止（它会找到一个素因子，最坏情况下是 $x$ 本身）。但如果你要求它找到最小的 $y$ 使得 $y^2 = -1$ 呢？它将永远搜索下去。

通过将这个强大且有潜在危险的工具添加到[原始递归函数](@entry_id:155169)中，我们得到了**[一般递归函数](@entry_id:634337)**类。事实证明，这个类等同于图灵机可以计算的内容。它被认为捕捉了算法上可计算的全部概念——著名的**[丘奇-图灵论题](@entry_id:138213)**。但这种能力是有代价的：我们离开了我们安全的、发条般的宇宙。我们现在身处狂野西部，在这里程序可能永远运行，它们计算的函数可能是部分的。[@problem_id:3048511]

这让我们回到了最初的问题：我们能分辨出这些一般程序中哪些是行为良好、全函数的吗？[莱斯定理](@entry_id:149389)给出了一个惊人的判决：**不能**。不存在一个通用算法，可以查看任意程序的代码并判断它是否是全函数。“全性”是一个不可判定的性质。停机问题是不可解的。我们无法仅通过计算，就将全函数从仅仅是部分函数的函数中区分出来。[@problem_id:3048511]

### 裁判：[皮亚诺算术](@entry_id:150593)与可证全性

如果我们不能写一个程序来*判定*另一个程序是否停机，或许我们可以*证明*它停机？要做到这一点，我们需要一个用于数学推理的[形式系统](@entry_id:634057)。用于关于自然数推理的黄金标准是**[皮亚诺算术](@entry_id:150593) (PA)**。PA 是一组公理（如“每个数都有一个后继”和“[数学归纳法](@entry_id:138544)有效”）和逻辑规则，允许我们构建严谨的证明。[@problem_id:2979405]

我们现在可以问一个更精确的问题。给定一个全[可计算函数](@entry_id:152169) $f$，PA 能否*证明*它是全函数？如果 PA 能产生一个有限的证明，来支持“对于每个输入 $x$，存在一个输出 $y$ 使得 $f(x)=y$”这个陈述，我们就说 $f$ 在 PA 中是**可证全函数**。[@problem_id:3050636]

作为一名裁判，PA 有多强大？它非常强大。它可以轻松证明每个[原始递归函数](@entry_id:155169)都是全函数，基本上是通过形式化我们前面讨论的 `for` 循环逻辑。[@problem_id:3042016] [@problem_id:3049705] 事实上，PA 甚至强大到可以证明非[原始递归](@entry_id:638015)的[阿克曼函数](@entry_id:636397)是全函数。起初看来，PA 似乎强大到足以证明*任何*我们已知是全函数的函数的全性。

### 真理与证明之间的鸿沟

在这里，我们来到了 20 世纪数学最深刻的发现之一。“函数 $f$ 是全函数”这个陈述是关于数字宇宙中真理的陈述。而“$f$ 在 PA 中是可证全函数”这个陈述是关于在一个特定[形式系统](@entry_id:634057)内可以被证明什么的陈述。这两者并不相同。

**存在其全性在[皮亚诺算术](@entry_id:150593)中不可证明的全[可计算函数](@entry_id:152169)。**

真理与可证性之间的这个鸿沟，最初由 Kurt Gödel 揭示，并非什么微小的裂缝；它是数学领域中一道根本性的鸿沟。它为什么存在？有几种方式可以理解这个惊人的事实。

1.  **“搅局者”函数**：想象一下，你可以列出 PA 能够证明其全性的每一个全函数的完整列表。这个列表是可计算的。现在，我们可以玩一个花招。我们可以定义一个新的“搅局者”函数 $g(n)$，它被设计成与列表中的每个函数都不同。例如，我们可以将 $g(n)$ 定义为列表中第 $n$ 个函数在输入为 $n$ 时的输出值加一。这个函数 $g$ 是完全可计算和全的。但根据其构造方式，它不可能在我们的列表中。如果它在，比如说，是第 $k$ 个函数，那么 $g(k)$ 就必须等于 $g(k)+1$，这是不可能的。因此，我们的搅局者函数 $g$ 的全性无法被 PA 证明。[@problem_id:3049705] [@problem_id:3050636]

2.  **相容性的镜子**：我们可以构造一个非常特殊的函数，称之为 $F_{Con}$。这个函数被设计成当且仅当 PA 是相容的（即没有矛盾）时为全函数。具体来说，$F_{Con}(n)$ 可以被定义为对所有输入都为 $0$，除非它发现 $n$ 是 PA 中一个矛盾证明的编码，此时它输出 $1$。如果 PA 是相容的（我们相信它是），那么 $F_{Con}$ 将总是输出 $0$。它是一个全[可计算函数](@entry_id:152169)。然而，如果 PA 能证明 $F_{Con}$ 是全函数，它实质上就是在证明它自己永远不会发现矛盾。换句话说，它将证明自己的相容性。但[哥德尔第二不完备性定理](@entry_id:149390)指出，任何像 PA 一样强大且相容的系统都不能证明其自身的相容性。因此，PA 不能证明 $F_{Con}$ 是全函数。[@problem_id:3050634]

3.  **来自非标准世界的视角**：PA 中的一个证明是一个非常稳固的论证，它必须在满足 PA 公理的*任何可能的宇宙*中都为真。事实證明，除了我们熟悉的自然数世界 $\{0, 1, 2, \dots\}$ 之外，还存在其他奇异的 PA 的“[非标准模型](@entry_id:151939)”，它们也满足所有公理。这些世界包含比任何标准数都大的“无限”数。要让 PA 证明一个函数是全函数，该函数的计算即使对于这些奇怪的、无限的输入也必须停机。许多对于所有标准数都是全的函数，在这些非标准世界中看待时，似乎会永远运行下去。由于一个证明必须在所有有效的世界中都成立，而全性的断言在这些非标准世界中失败了，因此不可能有 PA 的证明。这就是鸿沟所在：在我们*这个*世界中的真理与在*所有可能*世界中的可证性之间的差异。[@problem_id:3050645]

### 衡量不可证明性：一个增长的层级

最优雅的解释为我们提供了一种实际*衡量* PA 能力的方法。我们可以创建一个称为**快速[增长层级](@entry_id:161842)**的[函数序列](@entry_id:145607)，$F_0, F_1, F_2, \dots$，其中每个函数都比前一个增长得快得难以想象。我们甚至可以使用超限[序数](@entry_id:150084)将这个序列扩展到像 $F_\omega, F_{\omega+1}, \dots$ 这样的领域。

事实证明，在 PA 中可证全的函数集合几乎完全对应于那些被这个层级中直到某个点的某个函数所“支配”的函数。这个点是一个特定的超限[序数](@entry_id:150084)，称为 PA 的**[证明论序数](@entry_id:154023)**，记为 $\varepsilon_0$。

可以把它想象成一个证明的宇宙速度极限。只要一个[可计算函数](@entry_id:152169)的增长率低于某个 $F_\alpha$（其中[序数](@entry_id:150084) $\alpha  \varepsilon_0$），PA 就能证明其全性。但如果一个函数的增长速度与 $F_{\varepsilon_0}$ 一样快或更快，PA 的“证明引擎”就根本没有足够的能力来形式化它总是停机的论证。[@problem_id:3041999]

这正是某些在 PA 中为真但不可证明的[组合原则](@entry_id:637804)所发生的情况，例如**古德斯坦定理**或**Paris-Harrington 原理**。描述这些定理中数字“多长时间”或“多大”的函数（如古德斯坦函数 $G(n)$）是全可计算的。但它们的增长速度快得惊人——支配了所有 $\alpha  \varepsilon_0$ 的 $F_\alpha$——以至于它们直接冲破了 PA 的[证明论](@entry_id:151111)天花板。PA可以验证它们对你给出的任何特定数字会终止，但它无法做出它们对*所有*数字都会终止的宏大概括性断言。[@problem_id:3050611] [@problem_id:3050620] [@problem_id:3041999]

我们的旅程始于一个简单的问题——一个程序是否会停止，最终引领我们得出了一个深刻而优美的认识。数学真理的世界比形式证明的世界更为广阔。而它们之间的边界并非一堵随意的墙，而是一个被[函数增长](@entry_id:267648)——延伸至无穷的[函数增长](@entry_id:267648)——精确测量的疆界。

