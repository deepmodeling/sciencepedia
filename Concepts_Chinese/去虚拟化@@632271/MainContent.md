## 引言
[面向对象编程](@entry_id:752863)提供了强大的抽象能力，但其灵活性也伴随着代价。虚方法调用允许代码在运行时适应不同的对象类型，但它引入了性能开销，这种开销会阻碍编译器最有效的优化之一：内联。本文探讨了去[虚拟化](@entry_id:756508)——一系列旨在通过在执行前解析虚方法调用来拆除这一性能障碍的编译器技术。通过理解去[虚拟化](@entry_id:756508)，我们可以深入了解[静态程序分析](@entry_id:755375)、运行时动态和语言设计之间复杂的相互作用。本文将首先探索其核心的“原理与机制”，对比编译器对绝对确定性的追求与“押注概率”的实用策略。随后，本文将拓宽视角至“应用与跨学科联系”，揭示这一项优化如何对内存管理、系统架构乃至[网络安全](@entry_id:262820)产生深远影响。让我们从探究使去[虚拟化](@entry_id:756508)成为可能的机制开始。

## 原理与机制

在我们试图理解计算机如何执行我们优雅的面向对象代码时，我们常常想象一个无缝的指令流。然而，在这表面之下，隐藏着一个充满指针、表和查找的复杂机械世界。其中最基本的机制之一就是**虚方法调用**。它就像一种魔法，允许一个 `Shape` 变量在运行时正确调用 `Circle` 或 `Square` 的 `draw()` 方法。但这种魔法是有代价的。一次虚调用涉及一次间接查找：首先，获取对象的“[虚函数表](@entry_id:756585)”（或称 **vtable**），然后在该表中找到正确的函数指针，最后才跳转到代码。这种间接性不仅仅是多花几纳秒的时间；它是一堵强大的墙，阻碍了编译器最强大的优化之一：**内联**。如果编译器不知道将要调用*哪个* `draw()`，它就无法简单地将 `draw()` 的代码粘贴到调用点。

**去[虚拟化](@entry_id:756508)**（Devirtualization）正是拆除这堵墙的艺术与科学。它是编译器用来在虚调用发生*之前*确定其确切目标的一系列技术，从而用快如闪电的直接跳转替换灵活但缓慢的间接调用。理解去虚拟化，就是理解语言设计、[静态分析](@entry_id:755368)和运行时动态之间深刻的相互作用。这是一个关于两种宏大策略的故事：对绝对确定性的追求，以及押注概率的智慧。

### 对确定性的追求：[静态分析](@entry_id:755368)与封闭世界

想象你是一个编译器，你被赋予了一项超能力：你可以一次性看到整个程序——每一行代码、每一个库、每一个类。这就是**封闭世界假设**（closed-world assumption）。有了这种全局视野，你就可以构建一幅完整的类世界地图，即**类层次结构**（Class Hierarchy）。这张地图是第一种也是最直接的去[虚拟化](@entry_id:756508)形式——**类层次结构分析（CHA）**——的关键 [@problem_id:3682714]。

假设我们有一个调用 `vehicle.move()`。变量 `vehicle` 被声明为 `Vehicle` 类型。通过 CHA，编译器可以查看类层次结构并提问：在这个整个程序中，`Vehicle` 的所有具体子类有哪些？也许它们是 `Car`、`Boat` 和 `Plane`。然后编译器会检查它们各自的 `move()` 方法。如果运气好，它们每一个最终都使用了完全相同的实现（也许 `Car` 和 `Plane` 重写了它，但 `Boat` 继承了与 `Car` 相同的实现），那么编译器就能 100% 确定目标。虚调用被替换为直接调用。这堵墙倒塌了。

当程序员给编译器一点帮助时，这就变得异常简单。如果一个类被声明为 `final`，意思就是“谁都不能继承我”。如果 `vehicle` 变量的类型是一个 `final` 类，比如说 `ElectricScooter`，那么就完全没有[歧义](@entry_id:276744)了。该对象*必然*是 `ElectricScooter`，这个调用就可以被去[虚拟化](@entry_id:756508)。同样的逻辑也适用于方法本身被声明为 `final` 的情况；即使存在子类，它们也无法提供新的实现，所以所有子类都会使用同一个实现 [@problem_id:3682714]。

这揭示了语言设计者和编译器开发者之间一种美妙的合作。如果我们改变语言的默认规则会怎样？在许多语言中，类默认是“开放”的，意味着它们可以被自由地继承。这迫使开发者必须主动使用 `final` 来锁定某些东西。如果我们反过来呢？如果类默认是 `final`，而你必须显式地将它们标记为 `open` 呢？

让我们设想一个假设场景。假设在一个典型的代码库中，只有 15% 的类被显式标记为 `final`。又假设当编译器知道接收者的确切类并且该类是 final 时，一个虚调用可以被去[虚拟化](@entry_id:756508)，这种情况大约发生在 60% 的此类调用中。那么总的去[虚拟化](@entry_id:756508)率将是 $0.60 \times 0.15 = 0.09$，即 9%。现在，我们切换到一种 `final-by-default`（默认 final）的语言。在一个典型的代码库中，也许只有 25% 的类曾经被真正继承过，开发者可能会有点过于谨慎，额外将 5% 的类标记为 `open` 以防万一。这意味着 30% 的类是 `open` 的，而高达 70% 的类现在默认是 `final` 的。去[虚拟化](@entry_id:756508)率飙升至 $0.60 \times 0.70 = 0.42$，即 42%。仅仅通过改变一个默认设置，我们就使得代码的可优化性提高了近五倍 [@problem_id:3639504]。像 Swift 和 Kotlin 这样的现代语言正是因此采纳了这种 `final-by-default` 的哲学。此外，还存在一种折衷方案，即**密封类**（sealed classes）等特性，它告诉编译器：“这个类可以被继承，但只能被这里明确列出的特定类继承。” 这为类层次结构的一部分恢复了封闭世界的保证，给了编译器它所渴望的确定性 [@problem_id:3639509]。

### 一个统一的见解：去[虚拟化](@entry_id:756508)只是良好的整理工作

我们越是研究这些技术，就越可能想知道是否存在一个更简单、更基本的原则在起作用。事实证明确实如此。从本质上讲，一次虚调用只是一系列问题。一个 `x.m()` 调用会被编译器降级为类似这样的东西：

> `x` 的运行时类型是 `B` 类吗？如果是，调用 `B_m(x)`。
> 否则，`x` 的运行时类型是 `C` 类吗？如果是，调用 `C_m(x)`。
> 否则...

现在，考虑一段对同一个对象进行两次调用的代码：`x.m()` 后面跟着 `x.n()`。编译器会天真地为这两次调用生成两个这样的问题级联。但等一下。`typeof(x)` 表达式——即查找 `x` 的运行时类型——是一个**纯计算**（pure computation）。它每次都会给出相同的答案（假设对象的类型不变），并且没有副作用。我们这是在问完全相同的问题两次！

这就是经典的[编译器优化](@entry_id:747548)——**[公共子表达式消除](@entry_id:747511)（CSE）**——登场的地方。CSE 是良好整理工作的一般原则：如果可以，永远不要重复计算同一个东西。编译器可以将[代码转换](@entry_id:747446)为：

> `t = typeof(x)`
> `t` 是 `B` 类吗？如果是，调用 `B_m(x)`。
> `t` 是 `C` 类吗？如果是，调用 `C_m(x)`。
> ...
> `t` 是 `B` 类吗？如果是，调用 `B_n(x)`。
> `t` 是 `C` 类吗？如果是，调用 `C_n(x)`。
> ...

通过提升 `typeof(x)` 检查，编译器可以意识到，在“如果 `t` 是 `B`”的分支内，两个虚调用现在都被确认为是在一个 `B` 对象上进行的。两个调用一举被去虚拟化了！从这个角度看，去[虚拟化](@entry_id:756508)并不是一个特殊、神奇的技巧；它只是计算整洁性这一普适原则的一个具体应用 [@problem_id:3637424]。

这个思想还可以用更复杂的方式扩展。编译器可以执行**路径敏感分析**（path-sensitive analysis），像侦探收集线索一样。如果代码中写着 `if (x instanceof B)`，编译器就知道在那个 `if` 块内部，`x` 的类型被细化为 `B`。它可以将这个信息向前传递。如果不同的代码路径汇集到一个合并点，编译器会合并所有路径的信息——合并点处可能的类型集合是每个传入路径类型集合的*并集*。如果这个并集仍然能解析到单一的方法目标，那么该调用就可以被去[虚拟化](@entry_id:756508) [@problem_id:3637371]。

### 当确定性崩塌：动态的真实世界

对静态确定性的追求是强大的，但它建立在一个脆弱的基础之上：封闭世界假设。当世界不是封闭的时会发生什么？许多现代应用程序依赖于插件、动态库或其他形式的后期绑定。

想象一下我们的编译器，在分析了整个应用程序后，证明某个特定的调用只会接收 `A` 类的对象。它自信地用一个对 `A.m()` 的直接调用替换了虚调用。但随后，在运行时，用户加载了一个插件。这个插件包含一个新的类 `B`，它也有一个 `m()` 方法。程序接着创建了一个 `B` 的实例，并将其传递给带有去[虚拟化](@entry_id:756508)调用点的代码。程序没有调用 `B.m()`，而是错误地调用了 `A.m()`。这不仅仅是一个性能错误；它是对程序正确性的灾难性破坏 [@problem_id:3659795]。

**反射**（Reflection）是另一个给[静态分析](@entry_id:755368)带来麻烦的强大语言特性。像 `Class.forName(someString).newInstance()` 这样一行代码，可能会创建*任何*一个类名由 `someString` 提供的类的实例。如果该字符串来自用户输入或配置文件，编译器根本无法知道将创建哪个类。

一个天真的编译器可能会完全放弃，如果在任何地方使用了反射，就全面禁用去虚拟化。但现代编译器更加务实。它们将未解析的反射视为一个**保守屏障**。分析会做最坏的打算——即任何兼容的类都可能被创建——但它将这种不确定性仅局限于从反射调用流出的数据。关于不相关的、局部创建的对象的信息仍然是精确的。此外，编译器可以识别**安全的反射[子集](@entry_id:261956)**。如果代码写着 `Class.forName("B")`，使用了一个字符串字面量，编译器就可以静态地解析它，并重新获得确定性 [@problem_id:3639499]。

### 押注概率：动态与[自适应优化](@entry_id:746259)

动态世界带来的挑战催生了第二种截然不同的哲学，并由**即时（JIT）**编译器所倡导。JIT 编译器与程序一同运行，观察其执行。它不需要绝对的、静态的证明；它可以根据运行时*实际*发生的情况来做决策。这就是押注概率的策略。

JIT 编译器采用**基于性能分析的优化（PGO）**。它监控一个“热点”虚调用点——即一个被频繁执行的调用点。它可能会观察到，99% 的情况下，到达 `shape.draw()` 的对象是一个 `Circle`。虽然它无法*证明*它将永远是一个 `Circle`，但它可以下一个非常有利可图的赌注。这引出了**守护式去[虚拟化](@entry_id:756508)**（guarded devirtualization）。JIT 会重写代码为：

> `if (shape is a Circle) { call Circle.draw() directly; } else { perform the original slow virtual call; }`

这是一个绝妙的权衡。类型检查（即**守护**，guard）会有一点小成本，但当守护成功时，直接调用带来的收益是巨大的。如果猜测正确的概率足够高，那么这项优化就是有利可图的。我们甚至可以量化这一点。设守护的成本为 $g$，直接调用节省的成本为 $(v-s)$（其中 $v$ 是虚调用成本， $s$ 是直接调用成本），对象是预测类型的概率为 $p$。如果预期的节省超过了守护的成本，那么优化就是划算的。一点代数运算就能得出一个优美而简单的条件：当 $p > \frac{g}{v-s}$ 时，这项优化就是值得的 [@problem_id:3628909]。对于典型的成本，这个阈值可能低至10%，这意味着即使是一个不算太“热”的类型也值得押注。

如果一个调用点不是由一种类型主导，而是由两种或三种呢？例如，一个图形用户界面（GUI）的事件处理器可能主要看到 `MouseClick` 和 `KeyPress` 事件。JIT 可以将守护检查扩展成一个链条，这种优化被称为**[多态内联缓存](@entry_id:753568)（PIC）**。它首先检查最频繁的类型，然后是第二频繁的，以此类推，最后才回退到完整的虚调用 [@problem_id:3648496]。这种自适应策略允许 JIT 根据程序的实际运行时行为完美地定制代码。

### 最终的权衡：速度的代价

归根结底，去[虚拟化](@entry_id:756508)是一个入口。它最大的成就是它促成了**内联**——将方法体直接复制到调用处，从而完全消除调用开销。这反过来又解锁了一系列其他优化。

但是天下没有免费的午餐。每次内联一个方法，编译后代码的体积都会增长。如果一个多态调用点通过为每种可能的类型克隆代码来进行去虚拟化，代码可能会显著膨胀 [@problem_id:3659827]。这是经典的[时空权衡](@entry_id:755997)。编译器使用复杂的[启发式算法](@entry_id:176797)来决定何时值得用代码大小和[指令缓存](@entry_id:750674)压力的代价来换取内联带来的性能提升。

从[静态分析](@entry_id:755368)的刚性逻辑到 JIT 的概率性押注，去虚拟化是整个[编译器优化](@entry_id:747548)领域的缩影。它是静态与动态、确定性与概率、语言的优雅语义与底层机器的残酷现实之间的一场优美舞蹈。

