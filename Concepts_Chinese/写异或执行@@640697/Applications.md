## 应用与跨学科联系

要真正欣赏科学或工程中的一个基本原则，我们必须看到它在实践中的应用。我们必须观察它如何面对世界 messy, complicated reality，并观察它如何以巧妙、有时甚至优美的方式塑造我们的解决方案。“写异或执行”（W^X）原则——即一块内存可以是可写的或可执行的，但绝不能同时两者兼具——也不例外。表面上看，这是一条简单、僵化的规则。但在应用中，它催生了各种令人惊叹的复杂技术，这些技术贯穿整个软件栈，从构建我们程序的编译器到管理机器的[操作系统内核](@entry_id:752950)。

让我们从催生 W^X 的那个威胁——[代码注入](@entry_id:747437)的幽灵——开始我们的旅程。攻击者的梦想是找到一个漏洞，让他们能够将自己的恶意指令写入程序的數據內存——如栈或堆——然後欺騙程序跳轉並執行該代碼。多年来，这曾是无数漏洞利用的基础。W^X 对此筑起了一道简单而坚固的墙。如果[操作系统](@entry_id:752937)和硬件强制规定所有可写的数据内存都严格不可执行，那么攻击者注入的代码就只是惰性数据。当程序被欺骗跳转到它时，CPU 的[内存管理单元](@entry_id:751868)（MMU）只会说“不”。它看到该内存页的“执行”权限位被关闭，并引发一个异常，从而冷酷地阻止攻击。程序崩溃，这当然不理想，但这远比被对手劫持要好得多 [@problem_id:3657676]。

这种代码和数据的数字版“政教分离”似乎是万灵药。但如果一个程序出于完全正当的理由，需要在运行时创建代码，会发生什么？这并非罕见或深奥的需求；它正是高性能现代计算的核心。

### 动态困境：当代码必须是数据时

想想你网页浏览器中的 JavaScript 引擎，或是运行 Java、C# 和 Python 等语言的虚拟机。为了达到它们惊人的速度，它们不仅仅是解释代码；它们在程序运行时，将频繁使用的部分代码翻译成机器的本地指令。这就是即时（JIT）编译的魔力。但看看这需要什么：JIT 编译器必须首先将新机器代码的字节*写入*内存，将其视为数据。然后，它必须命令 CPU *执行*同一块内存。这就是核心冲突：W^X 策略似乎禁止了使 JIT 编译成为可能的行为本身。

那么我们如何解决这个问题呢？我们遵守规则，但我们以一种精心编排的顺序来做。基本的方法是与[操作系统](@entry_id:752937)进行一场两步舞 [@problem_id:3657661]：

1.  **写入阶段：** JIT 编译器向[操作系统](@entry_id:752937)请求一个具有`读-写`权限的内存页。关键是，`执行`权限是关闭的。现在，这块内存是一块空白画布，一个[数据缓冲](@entry_id:173397)区。JIT 将新编译的本地函数的字节写入这个页面。

2.  **执行阶段：** 一旦代码完全写入，JIT 向[操作系统](@entry_id:752937)发出另一个请求，要求更改该页面的权限。它撤销`写`权限并授予`执行`权限，将页面翻转为`读-执行`状态。

只有在权限翻转之后，才能安全地将 CPU 的[程序计数器](@entry_id:753801)指向这个页面并开始执行。W^X [不变量](@entry_id:148850)在每一刻都得到了维护。该页面从未同时可写和可执行。但这个简单的配方隐藏着一个复杂的世界，尤其是在现代多核处理器内部。更改页面权限不是免费的。它涉及一个[系统调用](@entry_id:755772)，这本身就是一个缓慢的操作。更糟糕的是，它要求[操作系统](@entry_id:752937)执行一次“TLB 击落”——这是一个形象生动的名称，指的是告知处理器中所有其他核心使其本地内存权限缓存（转译后备缓冲器，或 TLB）失效的过程。这确保了所有核心都同意该页面的新规则，但这是一个涉及跨处理器通信的、耗费性能的昂贵过程 [@problem_id:3639228]。

此外，还有处理器自身缓存的问题。代码通过[数据缓存](@entry_id:748188)写入，但通过[指令缓存](@entry_id:750674)获取执行。在许多架构上，这两个缓存不会自动保持同步。这意味着，在写入新代码之后和执行它之前，系统必须明确地将新指令从[数据缓存](@entry_id:748188)中刷新出去，并使[指令缓存](@entry_id:750674)中任何旧的、陈旧的指令失效。忘记这一步可能会导致 CPU 执行垃圾数据，其后果可想而知是灾难性的 [@problem_id:3682344]。

### 工程之美：驯服 W^X 这头猛兽

面对这些性能和正确性的障碍，工程师们开发出了一些真正优美的解决方案。一种方法是简单地接受成本但对其进行优化。JIT 编译器可以批量处理其工作，而不是编译一个函数、切换权限、然后付出代价。它可以将几十甚至几百个函数编译到一个大的、可写的缓冲区中，然后才执行一次性的、批量的权限翻转，使整个区域变为可执行。这将系统调用和 TLB 击落的高昂成本分摊到许多函数上，从而显著提高性能 [@problem_id:3657050]。

一个更优雅的解决方案，感觉像是利用系统自身规则的巧妙柔道技巧，是**双重映射**技术。JIT 不是为 JIT 代码页保留一个虚拟地址并不断更改其权限，而是请求[操作系统](@entry_id:752937)将*同一物理 RAM 页*映射到两个不同的虚拟地址。一个虚拟[别名](@entry_id:146322)被永久标记为`读-写`（且不可执行），另一个则被永久标记为`读-执行`（且不可写）。

作为系统的一个受信任组件，JIT 编译器使用可写的虚拟地址写入新代码。与此同时，程序的其余部分使用指向可执行虚拟地址的函数指针来执行代码。在任何时候，都没有任何*虚拟*页违反 W^X 规则。而且因为没有任何页面权限被更改，昂贵的系统调用和 TLB 击落被完全避免了。这项技术以几乎没有性能开销的方式提供了 W^X 的强大安全性，它是现代高性能 JIT（如网页浏览器中的 JIT）的基石 [@problem_id:3685859]。

一条平行的思路引出了另一个聪明的策略：**间接寻址**（indirection）。如果修补代码本身如此困难，为什么不修补代码*使用*的数据呢？例如，一个函数调用可以不被编译为直接跳转，而是通过存储在一个单独的、可写的数据页中的函数指针进行间接跳转。当 JIT 需要重新优化并重定向调用时，它根本不接触可执行代码。它只是简单而廉价地将一个新地址写入数据指针。代码保持不可变，W^X 被轻易满足，性能也非常好 [@problemid:3639228]。这种将可变数据与不可变代码分离的原则，对于程序最初的加载方式也是基础性的。

### 安全系统的无形机制

W^X 的影响远远超出了 JIT 编译器。它是一种塑造安全[操作系统](@entry_id:752937)及其工具链整体架构的哲学。

当编译器和链接器构建一个可执行文件时，它们正在为[操作系统](@entry_id:752937)的加载器创建一个蓝图。一个具有安全意识的工具链会拒绝构建一个请求有缺陷蓝图的程序。例如，如果开发人员错误地编写了一个链接器脚本，将可执行代码（`.text` 段）放入一个可写内存段，现代链接器会将其标记为致命错误。它会審計最终的程序布局，以确保没有任何段同时请求写和执行权限。它还会拒绝像“文本重定位”这样的过时做法，因为这会要求加载器在运行时修补代码段——这直接违反了 W^X 的精神 [@problem_id:3629668]。这种“左移”安全，即在构建时强制执行安全，是防止漏洞在创建之前就产生的一种强大方式。

这种纪律延伸到了[动态链接](@entry_id:748735)的标准机制本身。[共享库](@entry_id:754739)的代码驻留在一个只执行的段中（过程链接表，或 PLT）。它需要调用的地址存储在一个单独的数据段中（[全局偏移表](@entry_id:749926)，或 GOT）。当程序启动时，动态加载器用正确的地址填充 GOT。然后，在一个称为 RELRO（重定位只读）的最终加固步骤中，它甚至可以撤销 GOT 的写权限，使其在程序的剩余生命周期内不可变 [@problem_id:3657681]。

也许 W^X 原则最深刻的展示是，即使是操作系统内核——整个系统中最特权的代码——也遵守它。当内核需要加载一个新驱动程序时，它不会走捷径。它会一丝不苟地将驱动程序的代码映射到`读-执行`页，将其数据映射到`读-写`页。如果它需要对代码应用补丁或重定位，它会像用户空间的 JIT 编译器一样，安全地切换权限，以确保 W^X [不变量](@entry_id:148850)永远不会被破坏 [@problem_id:3658143] [@problem_id:3658156]。

从一个简单的安全规则出发，一连串的后果随之而来，迫使整个系统实现关注点的清晰分离。起初作为一种阻碍漏洞利用的屏障，后来演變成一种设计指导原则，促进了[不变性](@entry_id:140168)和清晰、可预测的状态转换。从阻止一个简单攻击到构建一个高性能、安全的 JIT 编译器或一个健壮的内核加载器，这段旅程揭示了 W^X 原则的内在美：它是一个简单的约束，却带来了 disciplined, elegant, and ultimately safer engineering 的世界。