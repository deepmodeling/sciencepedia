## 引言
“真理”的概念似乎很直观，但几个世纪以来，“这个句子是假的”之类的悖论揭示了我们理解上的深层裂痕。这个看似哲学的游戏在20世纪初成为一个严重的威胁，危及了为数学寻求一个完全一致的基础的努力。本文深入探讨了逻辑学家 Alfred Tarski 的开创性工作，他为形式语言提供了一个严格且无悖论的真理定义。我们将首先探索他革命性的[递归定义](@article_id:330317)的原理和机制，剖析它如何将语言与元语言分离以构建一个“真理机器”。然后，我们将审视这项工作的深远应用和跨学科联系，从它在计算机科学和数理逻辑中的作用，到它对集合论中实在本质的惊人启示。

## 原理与机制

### [自我指涉](@article_id:313680)的危险诱惑

语言是一个奇妙的工具。我们可以用它来描述世界、我们的感受，甚至语言本身。但最后这种能力——[自我指涉](@article_id:313680)的力量——隐藏着一个微妙的陷阱，一个困扰了思想家数千年的智力漩涡。思考下面这个简单的句子：

*这个句子是假的。*

我们称它为 $L$。那么 $L$ 是真的还是假的？如果我们假设 $L$ 是真的，那么它所说的内容必定是正确的。但它说它是假的，所以它必定是假的。这是一个矛盾。好吧，那我们假设 $L$ 是假的。那么它所说的——即它是假的——本身就是一个假话。这意味着这个句子必定是真的。又是一个矛盾！我们陷入了一个循环。这就是臭名昭著的**说谎者悖论**。

很长一段时间里，这被当作一个哲学上的 parlor trick（客厅戏法）。但在20世纪初，当数学家们试图用[形式逻辑](@article_id:326785)为所有数学建立一个完全严格的基础时，这个“戏法”成了一个可怕的威胁。如果你的[形式语言](@article_id:328817)允许你构造这样一个句子，你的整个系统可能是不一致的，从而毫无价值。

这正是伟大的逻辑学家 Alfred Tarski 接受的挑战。他的目标不是在自然语言中“解决”这个悖论，而是创造一种在形式化的数学语言中谈论真理而不会陷入矛盾的方法。他想要一个真理的定义，一方面是**[实质](@article_id:309825)上充分的**（materially adequate）——它应该与我们的常识直觉相符。也就是说，它必须抓住“雪是白的”这个句子为真，当且仅当雪事实上是白的这个思想 [@problem_id:2983771]。另一方面，这个定义必须是**形式上正确的**（formally correct）——它必须是精确的，并且可以被证明没有像说谎者悖论那样的矛盾 [@problem_id:3054362]。他带领我们踏上的旅程是清晰思维的大师课，揭示了意义的根本结构。

### 沙盒中的世界：结构与解释

在我们问一个句子是否“为真”之前，我们必须先问，“*关于什么*为真？”像“国王是秃头”这样的句子在真空中既不为真也不为假。它的真假取决于我们谈论的具体世界——哪个国王？哪个王国？

Tarski 的第一步是使这个想法变得精确。在逻辑学中，一个“世界”被称为一个**结构**（structure）或**模型**（model）。一个结构是一个自足的小宇宙，我们的符号在其中具有意义。要指定一个结构，你必须提供两样东西 [@problem_id:3042233]：

1.  一个**[论域](@article_id:329829)**（domain）或**全域**（universe），它只是一个非空的对象集合。这可以是自然数集 $\mathbb{N} = \{0, 1, 2, ...\}$，一群人，或者甚至是一个像 $\{A, B, C\}$ 这样的小集合。这是我们的语言可以谈论的“事物”的集合。

2.  对你语言中每个非逻辑符号的**解释**（interpretation）。想象你的语言中有常量符号 $c$，二元函数符号 $f^2$（一个接受两个输入的函数），以及三元关系符号 $R^3$（一个适用于三件事物的性质）。为了给这些符号赋予意义，你的结构必须提供：
    *   一个来自[论域](@article_id:329829)的实际对象，供常量 $c$ 命名。例如，$c^{\mathcal{M}} = A$。
    *   一个实际的函数 $f^{\mathcal{M}}$，它接受来自论域的两个对象并返回一个对象。例如，$f^{\mathcal{M}}(A, B) = C$。
    *   一个实际的关系 $R^{\mathcal{M}}$，它只是一个关系成立的对象有序三元组的集合。例如，$R^{\mathcal{M}} = \{(A, B, C), (A, A, B)\}$。

就是这样。一个结构只是一个对象[论域](@article_id:329829)和一本规则手册，它将我们的抽象符号与该论域内的具体事物和关系联系起来。现在，有了[形式语言](@article_id:328817)和明确定义的结构，我们准备好构建确定真理的机器了。

### 真理机器：一个[递归定义](@article_id:330317)

Tarski 的天才之处在于他意识到真理可以像计算机程序一样被定义：递归地。我们从最简单的陈述开始，给出确定它们真假的规则。然后，我们提供规则，说明复杂陈述的真假是如何由其更简单部分的真假决定的。整个定义不是在我们要研究的语言（**对象语言**）*内部*给出的，而是在一个我们用来分析它的更强大的语言（**元语言**）中给出的 [@problem_id:3054435]。

让我们看看这台宏伟机器的组成部分 [@problem_id:2983789]。

#### 第1步：解释项（名词）

在我们可以评估句子之前，我们必须知道“名词”——即**项**（terms）——指的是什么。项是变元（如 $x$）、常量（如 $c$），或应用于其他项的函数（如 $f(x, c)$）。为了在结构 $\mathcal{M}$ 中找到一个项的值，我们需要一个**赋值函数**（assignment function），通常表示为 $s$。可以把赋值看作一组临时的标签或指针。对于每个变元，比如 $x$，赋值 $s$ 指向我们论域中的一个特定对象，比如 $s(x)=B$。

-   变元 $x$ 的值是当前赋值 $s$ 所说的任何值：$s(x)$。
-   常量 $c$ 的值由结构固定：$c^{\mathcal{M}}$。
-   像 $f(t_1, t_2)$ 这样的函数项的值，是通过首先找到更简单的项 $t_1$ 和 $t_2$ 的值，然后将结构的函数 $f^{\mathcal{M}}$ 应用于这些值来找到的。

这个递归过程让我们能为任何项在[论域](@article_id:329829)中找到一个具体的对象。

#### 第2步：原子公式（基本事实）

最简单的陈述是**原子公式**（atomic formulas）。这些是诸如 $P(t_1)$（“由 $t_1$ 命名的对象具有性质 $P$”）或 $t_1 = t_2$（“由 $t_1$ 和 $t_2$ 命名的对象是同一个”）之类的主张。要检查一个原子公式在赋值 $s$ 下是否为真，我们只需计算各项的值，并对照我们的结构 $\mathcal{M}$ 的规则手册进行检查。值的元组是否在定义该关系的集合中？$t_1$ 的值是否与 $t_2$ 的值是同一个对象？这是一个直接的查找。

#### 第3步：布尔联结词（逻辑粘合剂）

这部分简单而熟悉。Tarski 的机器处理联结词的方式正如你所预期的：
-   $\lnot \varphi$ (“非 $\varphi$”) 为真当且仅当 $\varphi$ 为假。
-   $\varphi \land \psi$ (“$\varphi$ 与 $\psi$”) 为真当且仅当 $\varphi$ 和 $\psi$ 都为真。
-   $\varphi \lor \psi$ (“$\varphi$ 或 $\psi$”) 为真当且仅当 $\varphi$ 和 $\psi$ 中至少有一个为真。

#### 第4步：[量词](@article_id:319547)（机器的核心）

现在到了最精彩的部分：我们如何处理“对所有”（$\forall$）和“存在”（$\exists$）？在这里，Tarski 通过一个涉及赋值的优雅机制，避免了所有替换悖论。

假设我们想要评估 $\forall x \, \varphi(x)$。我们很想认为应该用[论域](@article_id:329829)中每个对象的名称替换 $x$ 并逐一检查。但如果我们的论域是无限的，或者如果某些对象在我们的语言中甚至没有名称呢？Tarski 的解决方案要清晰得多。

陈述 $\forall x \, \varphi(x)$ 在赋值 $s$ 下为真，当且仅当无论我们从[论域](@article_id:329829)中选择哪个对象 $a$，公式 $\varphi(x)$ 在一个*修改后*的赋值（其中 $x$ 现在指向 $a$）下都为真。我们将这个修改后的赋值写为 $s[x \mapsto a]$ [@problem_id:3042231]。

所以，规则是：
-   $\mathcal{M}, s \models \forall x \, \varphi$ 为真，当且仅当对于[论域](@article_id:329829) $M$ 中的**每一个**元素 $a$，关系 $\mathcal{M}, s[x \mapsto a] \models \varphi$ 成立。
-   $\mathcal{M}, s \models \exists x \, \varphi$ 为真，当且仅当在[论域](@article_id:329829) $M$ 中**存在**至少一个元素 $a$，使得 $\mathcal{M}, s[x \mapsto a] \models \varphi$ 成立。

这太美妙了。我们不需要去 messing with 公式的句法。我们只是机械地，在一系列系统修改的赋值下检查它的真假。至关重要的是，对象语言中的[量词](@article_id:319547) $\forall x$ 是通过使用我们元语言中一个遍及[论域](@article_id:329829)中对象的“对于每一个”来定义的。这种严格的分离是避免悖论的关键。

最后一个微妙的点：一个**句子**（sentence）是一个没有自由变元（即没有不被[量词](@article_id:319547)约束的变元）的公式。像 $\forall x \exists y \, R(x,y)$ 这样的句子的真假不依赖于任何初始赋值 $s$，因为[量词](@article_id:319547)无论如何都会系统地检查所有可能性。所以我们可以说一个句子简直就是“在 $\mathcal{M}$ 中为真”，写作 $\mathcal{M} \models \sigma$。相比之下，像 $R(x,y)$ 这样带有自由变元的公式，只有相对于一个告诉我们 $x$ 和 $y$ 是什么的特定赋值，它才为真或为假 [@problem_id:2983814]。

### 让我们看看机器如何工作

理论虽好，但眼见为实。让我们拿一个简单的结构 $\mathcal{M}$ 来评估一个公式 [@problem_id:3046864]。
-   **论域**：$D = \{0, 1, 2\}$
-   **解释**：
    -   常量 $c$：$c^{\mathcal{M}} = 1$
    -   一元关系 $P$（“是特殊的”）：$P^{\mathcal{M}} = \{0, 2\}$（所以只有 0 和 2 是特殊的）
    -   [二元关系](@article_id:334022) $R$：$R^{\mathcal{M}} = \{(0,1), (1,1), (2,1)\}$
-   **赋值**：让我们从一个赋值 $s$ 开始，其中 $s(x)=0$ 且 $s(y)=1$。

现在，让我们评估句子 $\forall y \, \exists x \, R(x,y)$。它在 $\mathcal{M}$ 中为真吗？

机器从外到内工作。要使 $\forall y$ 为真，内部部分 $\exists x \, R(x,y)$ 必须对[论域](@article_id:329829) $\{0, 1, 2\}$ 中*每一个*可能的 $y$ 值都为真。

1.  **情况 $y=0$**：我们检查 $\exists x \, R(x,0)$ 是否为真。这要求我们在 $\{0, 1, 2\}$ 中找到*至少一个* $x$ 的值，使得序对 $(x, 0)$ 在我们的关系 $R^{\mathcal{M}}$ 中。我们的关系是 $R^{\mathcal{M}} = \{(0,1), (1,1), (2,1)\}$。没有以 $0$ 作为第二个元素的序对。所以对于 $y=0$，陈述 $\exists x \, R(x,0)$ 是**假的**。

我们现在就可以停下了！因为“对所有 $y$”这一子句在 $y=0$ 时失败了，整个句子 $\forall y \, \exists x \, R(x,y)$ 必定是**假的**。机器给出了一个确定无疑的、毫不含糊的答案。

### 机器中的幽灵：Tarski 的伟大发现

我们构建了一个精美、复杂的机器，它为形式语言中的任何句子定义了真理，这都是相对于一个给定的结构而言的。它是组合的、精确的，并且通过严格区分对象语言和定义所在的元语言来避免了说谎者悖论。

但正是这一成功引出了所有洞见中最深刻的一个。如果我们有一种语言，它强大到可以谈论自己的句子呢？算术语言就是这样一种语言。通过**[哥德尔编码](@article_id:313401)**的巧妙方法，我们可以为每个公式和句子分配一个唯一的数字。然后我们可以写出*关于*这些数字的公式，这等同于写出关于公式的公式。

于是，终极问题出现了：我们能否在算术语言*内部*构建我们的“真理机器”？我们能否写出一个公式，称之为 $\mathrm{True}(x)$，它对于一个数字 $n$ 为真，当且仅当 $n$ 是一个真的算术句子的[哥德尔](@article_id:642168)数？[@problem_id:3042260]

塔斯基不可定义性定理给出了惊人的答案：**不能。**

原因的简述如下。假设你*可以*写出这样一个公式 $\mathrm{True}(x)$。算术语言足够强大，可以实现[自我指涉](@article_id:313680)。使用一个叫做[对角引理](@article_id:309708)的工具，你可以构造一个句子 $L$，我们称其[哥德尔](@article_id:642168)数为 $\ulcorner L \urcorner$，使得 $L$ 形式上等价于陈述 $\lnot \mathrm{True}(\ulcorner L \urcorner)$。

用大白话说，$L$ 是一个说“我不是真的”的句子。

我们刚刚在我们的[形式系统](@article_id:638353)内部重新创造了说谎者悖论！
-   如果 $L$ 是真的，那么根据我们假设的 $\mathrm{True}(x)$ 谓词的定义，$\mathrm{True}(\ulcorner L \urcorner)$ 必须为真。但 $L$ 本身断言 $\lnot \mathrm{True}(\ulcorner L \urcorner)$。矛盾。
-   如果 $L$ 是假的，那么 $\mathrm{True}(\ulcorner L \urcorner)$ 必须为假。但如果 $\lnot \mathrm{True}(\ulcorner L \urcorner)$ 为真，那么 $L$ 本身必须为真。矛盾。

唯一的出路是结论我们最初的假设是错误的。在算术语言中不可能存在这样的公式 $\mathrm{True}(x)$。

这不是一个失败。这是关于真理本质的一个重大发现。它揭示了，对于任何一个强大到足以描述自身结构的形式语言，该语言的真理概念必然位于其外部。真理是一个不断后退的地平线。我们可以在元语言 $L_2$ 中为语言 $L_1$ 定义真理，在元元语言 $L_3$ 中为 $L_2$ 定义真理，如此在一个无限而美丽的层级中继续下去。说谎者悖论不是一个 bug；它是逻辑的一个特性，揭示了这种深刻的、分层的意义结构。Tarski 不仅给了我们一个真理的定义；他还向我们展示了它在思想宇宙中的位置。

