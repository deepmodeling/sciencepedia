## 引言
在我们的数字世界里，我们如何才能真正信任自己的计算机？这个问题引出了一个根本性的悖论：我们信任的任何软件都依赖于其他软件，从而形成一个没有明确起点的依赖链。没有一个确定的起点，整个系统安全体系就可能土崩瓦解。本文通过介绍[可信计算基](@entry_id:756201) (TCB) 来应对这一挑战，TCB 是一个系统中对其安全至关重要的所有组件的集合。它为从头开始构建可信系统提供了理论框架。在接下来的章节中，我们将首先剖析支配 TCB 的“原则与机制”，从不可变的[信任根](@entry_id:754420)到至关重要的最小化原则。之后，在“应用与跨学科联系”部分，我们将探讨这些理论概念如何付诸实践，以保护从[操作系统](@entry_id:752937)、云服务器到构建它们的工具等一切事物。

## 原则与机制

### 信任的悖论与牢不可破的第一环

想象一下，你收到一位朋友通过信使送来的密信。你如何知道这封信是真实的？你信任信使。但你又如何知道信使没有被收买？也许他带着另一位可信伙伴的介绍信。但接着，你又如何信任*那位*伙伴？这种追问会迅速陷入无限回归，形成一个没有坚实起点的“谁为担保人担保？”的链条。

我们的计算机每次开机时都面临着完全相同的悖论。计算机仅仅是一台执行指令的机器。我们信任我们的应用程序会规矩行事，但这仅仅因为我们信任管理它们的[操作系统](@entry_id:752937)。我们信任[操作系统](@entry_id:752937)，但这仅仅因为我们信任将它加载到内存中的[引导加载程序](@entry_id:746922)。我们信任[引导加载程序](@entry_id:746922)，但这仅仅因为……好吧，这到哪里才是个头？要构建一个可信的系统，我们必须找到一个锚点。我们需要在[信任链](@entry_id:747264)中找到第一个环节，这个环节就其本质而言是毋庸置疑的。

这第一环就是**[信任根](@entry_id:754420) (Root of Trust)**。在现代计算机中，这通常是一小段不可更改的软件，直接固化在处理器的硅片中——即存储在[只读存储器](@entry_id:175074) (ROM) 中的一段程序。它就像支配电路的物理定律一样不可变。这个[信任根](@entry_id:754420)只做一件简单而完美的事情：在移交控制权之前，验证启动序列中*下一个*软件的完整性。这种从一个经过验证的组件到下一个组件的交接，创建了一条**[信任链](@entry_id:747264) (Chain of Trust)**。

这个逻辑虽然简单，但却至关重要。对于[信任链](@entry_id:747264)中的任何组件 $x$，它都必须在被执行*之前*得到验证。我们将验证步骤称为 $V(x)$，执行步骤称为 $\mathrm{Exec}(x)$。[信任链](@entry_id:747264)不可撼动的规则是，$V(x)$ 必须始终在 $\mathrm{Exec}(x)$ 之前。否则，就相当于让一个组件为自己的完整性作保，这就像让嫌疑人在自己的审判中担任法官一样毫无意义。如果一个恶意程序已经在运行，它的“验证”功能只会撒谎 [@problem_id:3664589]。这就是为什么[操作系统内核](@entry_id:752950)不能去验证加载它的[引导加载程序](@entry_id:746922)；加载并执行内核的行为必须是由*在它之前*运行的组件所建立的[信任链](@entry_id:747264)中的最后一步。这种严格的“先验证后运行，再验证再运行”的顺序，正是**[安全启动](@entry_id:754616) (Secure Boot)** 的基本原则。

### 信任圈：少即是多

当我们的系统启动时，这条[信任链](@entry_id:747264)从不可变的硬件[信任根](@entry_id:754420)开始，经过固件、[引导加载程序](@entry_id:746922)，最终延伸到操作系统内核，一环扣一环地增长。我们可以围绕所有对执行系统安全策略至关重要的组件画一个概念上的边界。这个边界定义了**[可信计算基](@entry_id:756201) (TCB)**。在这个圈内的一切都必须被信任。圈外的一切都被视为不可信，并由 TCB 来监管。

至此，我们触及了安全系统设计中最优美、最核心的思想：**最小化原则**。人们可能直觉地认为，一个更安全的系统应该有更多的守卫、更多的墙和更复杂的安全软件。但现实恰恰相反。添加到[可信计算基](@entry_id:756201)中的每一行代码都是一个负债。它为漏洞的隐藏提供了又一个场所，为攻击者提供了又一扇可能撬开的门。通往更强安全的道路不是向 TCB 添加更多东西，而是毫不留情地从中删减。

我们甚至可以给这个想法赋予一点数学色彩。想象一下，每行代码都存在一个极小的概率 $\beta$，包含可利用的安全漏洞。如果你的 TCB 有 $N$ 行代码，那么预期的漏洞数量就是 $N\beta$ [@problem_id:3639726]。要使系统更安全，你就必须减小 $N$。

这一原则是[宏内核](@entry_id:752148)与微内核之争的哲学核心。[宏内核](@entry_id:752148)是一个庞然大物；它的 TCB 不仅包括核心的调度器和内存管理器，还包括[设备驱动程序](@entry_id:748349)、[文件系统](@entry_id:749324)和网络栈——代码量高达数百万行。相比之下，微内核则极端简约。它旨在只包含管理内存、调度任务和促进通信所必需的最基本要素。其他所有东西——驱动程序、[文件系统](@entry_id:749324)、网络栈——都被推出了特权内核空间，成为权限较低的用户空间进程。

微内核的安全论证可以通过一个简单而优雅的权衡来体现。通过将一个服务移出内核，我们将内核的 TCB 大小减少了（比如说）$\Delta S$ 行代码，从而将攻击面减少了与 $\alpha \Delta S$ 成正比的数量，其中 $\alpha$ 代表与内核代码相关的高风险。然而，我们必须添加一个新的用户空间服务器以及它与内核通信所需的[进程间通信 (IPC)](@entry_id:750712) 接口。这增加了一个较小的风险 $\beta$。当且仅当移除特权代码的好处超过了添加新的、权限较低的接口的成本时，系统才会变得更安全：$\alpha \Delta S > \beta$ [@problem_id:3651685]。设计安全微内核系统的全部艺术，就是对管理这一个不等式的大师级课程。数量上的差异可能是惊人的；一个[宏内核](@entry_id:752148) TCB 的预期漏洞数量可能比微内核 TCB 高出几个[数量级](@entry_id:264888)，仅仅是因为其庞大的规模 [@problem_id:3687912]。

### 俱乐部里的隐形成员

所以，我们的 TCB 由启动链和内核组成。而且我们已经把内核做得尽可能小了。我们安全了吗？

没那么快。TCB 是一个微妙的概念。它不仅包括*做出*安全决策的代码，还包括任何*协调*这些决策的代码。思考一下[引导加载程序](@entry_id:746922)的工作：它从磁盘读取[操作系统内核](@entry_id:752950)到内存，验证其[数字签名](@entry_id:269311)，如果签名有效，就跳转到内核。TCB 显然包括[引导加载程序](@entry_id:746922)的验证逻辑。但是，[引导加载程序](@entry_id:746922)用来从磁盘读取字节的那个不起眼的存储驱动程序呢？

当然，存储驱动程序只是一个简单的工具，不是安全组件吧？这是一个危险的假设。想象一个恶意的存储驱动程序。当[引导加载程序](@entry_id:746922)请求它获取内核时，该驱动程序尽职地提供了经过正确签名的正版内核镜像。[引导加载程序](@entry_id:746922)的验证逻辑检查签名，并顺利通过。[引导加载程序](@entry_id:746922)现在准备好转移控制权。但是，在“检查时”和“使用时”之间的纳秒内，这个具有直接内存访问 (DMA) 功能的恶意驱动程序，用恶意载荷覆盖了内存中刚刚验证过的内核。系统就这样被攻破了，而验证步骤却完美无瑕。

这是一个经典的**[检查时-使用时](@entry_id:756030) (Time-of-Check to Time-of-Use, [TOCTOU](@entry_id:756027))** 攻击 [@problem_id:3679566]。它违反了安全加载的基本“等价[不变量](@entry_id:148850)”：被验证的字节必须与被执行的字节相同。这个教训是深刻的：*任何位于验证者和被验证对象之间的组件都隐含地成为 TCB 的一部分*。在这种情况下，存储驱动程序必须是可信的。这揭示了 TCB 不仅仅是一个“安全软件”列表，而是一个其完整性至关重要的整体依赖网络。这个原则超越了启动过程；任何动态引入新代码（如库）的加载器本身也必须是 TCB 的一部分，并强制执行这种“先度量后执行”的纪律，从而创建一个动态的、不断增长的信任图 [@problem_id:3679583]。

### 信任的两个方面：强制执行与报告

到目前为止，我们的信任模型，即[安全启动](@entry_id:754616)，一直是关于*强制执行*的。它*阻止*未经授权的代码运行。这就像俱乐部里检查身份证并拒绝名单外任何人进入的保镖。但如果我们需要的不只是预防呢？如果我们需要向远程方（如公司网络或银行）证明我们的计算机处于一个已知的良好状态呢？

这就需要另一种信任：*报告*。这就是**可[度量启动](@entry_id:751820) (Measured Boot)** 的作用，它与[安全启动](@entry_id:754616)并行工作。随着[信任链](@entry_id:747264)的展开，每个组件（固件、[引导加载程序](@entry_id:746922)、内核）的加密哈希值——一个唯一的数字指纹——都会被“度量”并记录在一个名为**[可信平台模块 (TPM)](@entry_id:756205)** 的特殊防篡改硬件芯片中。这些度量值以只可追加的方式顺序记录；任何改动或删除都会被检测到。

可[度量启动](@entry_id:751820)并不会阻止任何东西运行。它不是保镖，而是一位一丝不苟的公证人，为将系统带到当前状态而执行的每一段代码创建了一份不可否认的、按时间顺序[排列](@entry_id:136432)的记录。之后，这个加密日志可以用于**[远程证明](@entry_id:754241) (Remote Attestation)**。当远程服务器要求我们的机器证明其完整性时，[TPM](@entry_id:170576) 可以对其度量日志进行签名并发送以供检查。然后，服务器可以将此日志与一个已知良好组件的“黄金”清单进行比较。如果匹配，信任就建立了。如果不匹配，服务器可以拒绝访问，从而有效地隔离一台以不可信状态启动的机器 [@problem_id:3679557, @problem_id:3679587]。强制执行和报告是可信平台的两个互补支柱。

### 信任的局限性

我们已经建立了一座宏伟的大厦：一个硬件[信任根](@entry_id:754420)、一条签名强制执行链、一个最小化的内核，以及整个过程的防篡改日志。系统通过了身份验证，其完整性得到了验证和度量。那么，它最终安全了吗？

答案是“否”，这个答案令人谦卑但至关重要。原因在于，所有这些机制都是为了在加载时验证软件的*身份*和*完整性*而设计的。它们确保你正在运行你想要运行的正版组件。但它们对组件的*运行时行为*只字不提。

让我们回到我们信任的内核驱动程序。它由供应商正确签名，其哈希值在黄金清单上，并通过了所有[安全启动](@entry_id:754616)和可[度量启动](@entry_id:751820)的检查。它稳固地处于我们的 TCB 之内。但是，在无人知晓的情况下，它包含一个微妙的编程缺陷——一个[缓冲区溢出](@entry_id:747009)漏洞。攻击者无法替换该驱动程序，但他们可以精心构造一个恶意输入，当驱动程序处理该输入时，会触发这个漏洞。这可能让攻击者劫持程序的控制流，将现有代码的小片段（“gadgets”）拼接起来以执行恶意操作。这是一种**[返回导向编程 (ROP)](@entry_id:754320)** 攻击，它完全发生在运行时，远在启动时检查完成之后 [@problem_id:3679560]。

这引导我们得出一个最重要的认识：**TCB 并不意味着“安全”**。它意味着“安全关键”。一个组件存在于 TCB 中意味着我们*依赖*它，而不是说它是无懈可击的。TCB 提供了信任的基础，但它不是整座房子。安全不能在启动时就结束。它需要互补的运行时防御措施，比如用**[控制流完整性 (CFI)](@entry_id:747827)** 来挫败 ROP 攻击，以及不懈地应用[最小权限原则](@entry_id:753740)，以便在组件不可避免地被攻破时控制损害 [@problem_id:3679560]。它还需要有能力撤销信任——在发现漏洞时将组件从“允许”列表中移除并部署安全更新。

[可信计算基](@entry_id:756201)不是一个静态的堡垒。它是一个动态、永无止境的舞蹈的指导原则。它是一个严谨的过程，包括定义信任圈、最小化其攻击面、质疑其隐形成员、验证其状态，以及最重要地，理解其局限性。TCB 的美妙之处不在于它对[绝对安全](@entry_id:262916)的承诺，而在于它为我们追求安全所带来的清晰性和合理性。

