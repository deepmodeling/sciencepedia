## 应用与跨学科联系

在我们之前的讨论中，我们探讨了调用者保存和[被调用者保存寄存器](@entry_id:747091)约定的优雅原则。其核心是一个简单的契约，是两段代码——*调用者*和*被调用者*——之间的“君子协定”。调用者承诺不期望其临时值（在调用者保存寄存器中）在[函数调用](@entry_id:753765)后仍然存在，作为回报，被调用者承诺 meticulously 地保存并恢复调用者可能存储在[被调用者保存寄存器](@entry_id:747091)中的任何长期值。这种分工是效率的奇迹。

但当这个协定受到考验时会发生什么？当我们调用的伙伴不仅仅是另一个函数，而是强大的[操作系统](@entry_id:752937)本身时会发生什么？或者当我们的程序不是被一个礼貌的调用所打断，而是被来自硬件设备的紧急、异步请求所中断时会发生什么？当一个恶意行为者试图利用这个契约达到邪恶目的时又会发生什么？

正如我们将看到的，这个简单约定的真正美妙之处并非在其孤立状态下显现，而在于它与整个计算生态系统的深刻且常常令人惊讶的互动中。它是一根单一的线，却被编织进[操作系统](@entry_id:752937)、编译器、语言运行时甚至[网络安全](@entry_id:262820)的面料中。让我们踏上旅程，追溯这根线索，发现它所揭示的看不见的统一性。

### 与[操作系统](@entry_id:752937)的伟大对话

乍一看，用户程序及其[操作系统](@entry_id:752937)（OS）存在于不同的世界，被一道神圣的[特权级别](@entry_id:753757)屏障所分隔。然而，它们必须通信。当你的程序需要打开一个文件或通过网络发送数据时，它会执行一次*系统调用（system call）*，这本质上是敲响[操作系统](@entry_id:752937)的门请求帮助。这不是一个普通的[函数调用](@entry_id:753765)；它是一个同步陷阱，一种将控制权传递给内核的特殊硬件指令。

但是，你的程序状态——它的变量，它小心保存在寄存器中的计算结果——如何能在这段进入完全不同上下文并返回的旅程中幸存下来？答案是 ABI 的[调用约定](@entry_id:753766)跨越了这个特权边界。操作系统内核在接收到[系统调用](@entry_id:755772)时，扮演的是*被调用者*的角色。它受制于相同的契约。虽然它可以自由使用调用者保存寄存器来处理请求，但它绝对有义务保护[被调用者保存寄存器](@entry_id:747091)。如果内核在没有保存和恢复的情况下轻率地修改了一个[被调用者保存寄存器](@entry_id:747091)，这就好比一个图书管理员归还一本撕掉几页的借阅书籍。返回用户空间后，程序可能会崩溃或产生无意义的结果，其状态已被本应为其服务的实体所破坏。这使得 ABI 成为[稳定系统](@entry_id:180404)设计的基石，确保从用户代码到内核再返回的过程像任何其他[函数调用](@entry_id:753765)一样无缝和可预测 [@problem_id:3640447]。

现在，让我们将这种礼貌的敲门与更突然的事情进行对比：硬件中断。一次中断——来自网卡宣布新数据包到达或磁盘控制器发出数据就绪信号——不会等待一个方便的时刻。它是*异步的*。它可以在任何时刻，在任意两条指令之间发生。被中断的代码不是“调用者”；它没有进行调用，也没有机会做准备。

在这里，君子协定被暂时中止。处理该事件的[中断服务程序](@entry_id:750778)（ISR）不能假设被中断的代码保存了其易失性数据。为了保证完美恢复，ISR 必须承担保存的全部重担。它必须保存它打算使用的*每一个寄存器*，无论它是调用者保存还是被调用者保存，并在返回前恢复它们。面对这种突然的上下文切换，这种区分暂时变得无关紧要。这凸显了一个关键教训：调用者保存约定是针对同步调用这个可预测世界的一种强大优化，但计算的基本规则是，在不可预测的上下文切换中，状态必须始终被保留 [@problem_id:3653042]。

这种权衡对系统性能有着深远的影响。想象一下设计一个 ABI。如果你将[参数传递](@entry_id:753159)寄存器指定为调用者保存（一种常见的选择），ISR 就必须在每次中断时保守地保存它们，以防万一它中断了一个正在进行的函数调用。这增加了延迟。但是，如果你将参数放在[被调用者保存寄存器](@entry_id:747091)中，并设计你的 ISR 来避免使用它们，你就可以为中断创建一个“快速路径”，减少延迟，因为这些寄存器默认会被保留。这在实时和嵌入式系统中是一个微妙但关键的设计选择，在这些系统中，每一微秒都至关重要 [@problem_id:3664354]。

### 编译器：使用契约的工匠

如果说 ABI 是契约，那么编译器就是负责在生成的每一行代码中维护它的工匠大师。对编译器来说，世界是一个复杂的[函数调用](@entry_id:753765)图，它必须在导航这个图的同时确保没有数据被不当丢失。

考虑编译一个现代程序。为了安全性和灵活性，代码通常被编译成*位置无关的*（PIC），这意味着它可以被加载到内存的任何地方。一个后果是，调用一个外部函数，比如说来自一个[共享库](@entry_id:754739)，不再是单个 `call` 指令。相反，调用首先会转到一个称为过程链接表（PLT）存根的小代码片段。这个存根在[全局偏移表](@entry_id:749926)（GOT）中查找函数的真实地址，然后跳转到那里。这个 PLT 存根，尽管简单，却是一个*被调用者*！它可能会使用几个调用者保存寄存器来完成自己的任务。编译器在其智慧中必须知道这一点。在为调用生成代码时，它必须将 PLT 存根视为调用者保存寄存器的潜在破坏者，并相应地保存任何存活的数据 [@problem_id:3678270]。

这种保存的责任给编译器带来了一个持续的优化难题。想象一下，它有一个值在调用后需要使用，但目前它正位于一个调用者保存寄存器中。保护它的最廉价方式是什么？
1.  **将其[溢出](@entry_id:172355)（Spill it）：** 在调用前将值保存到栈上的内存中，调用后再加载回来。这很可靠但很慢，因为内存访问比寄存器访问慢几个[数量级](@entry_id:264888)。
2.  **移动它（Move it）：** 如果有一个空闲的[被调用者保存寄存器](@entry_id:747091)，编译器可以发出一条快速的[移动指令](@entry_id:752193)，将值放在那里，因为它知道它会是安全的。
3.  **重新实例化它（Rematerialize it）：** 如果值是一个简单的常量，为什么还要保存它呢？编译器可以干脆让它被覆盖，然后在调用后再次发出一条指令来加载这个常量。

一个复杂的编译器会在每个调用点权衡这些选项，选择成本最低的策略。一个空闲的[被调用者保存寄存器](@entry_id:747091)的可用性可能是一个福音，可以节省本应花费在内存访问上的宝贵周期 [@problem_id:3626227]。

### 新[范式](@entry_id:161181)，旧原则

调用者-被调用者契约诞生于层次化函数调用的简单模型。但现代编程涉及更多奇特的[控制流](@entry_id:273851)形式，在每一种形式中，我们都能看到该约定的原则被改编和重生。

以 Python 或 JavaScript 等语言的即时（JIT）编译世界为例。JIT 编译器在运行时将动态代码翻译成快速的机器代码。但有时，它必须“去优化”——退出优化代码，返回到较慢的解释器。为此，运行时必须能够完美地重建程序的状态。这是通过*栈图（stack maps）*实现的——由 JIT 生成的元数据，它像一张蓝图，在特定的“安全点（safepoints）”记录下每个存活变量的位置（哪个寄存器或栈槽）。在这里，调用者/被调用者保存的区别以一种新的形式重新出现。如果栈图格式对于跟踪[被调用者保存寄存器](@entry_id:747091)有特殊开销（也许是为了更容易地进行栈回溯），一个聪明的 JIT 可以通过在调用安全点之前将值移出[被调用者保存寄存器](@entry_id:747091)并移入调用者保存寄存器来减小[元数据](@entry_id:275500)的大小 [@problem_id:3626185]。

或者考虑垃圾回收（GC）。一个精确的 GC 必须暂停程序并寻找所有的“根（roots）”——那些保存在寄存器或栈上、指向堆内存的指针。[调用约定](@entry_id:753766)直接影响了这次搜寻。一个有很多[被调用者保存寄存器](@entry_id:747091)的约定意味着，根据规则，被调用者会将这些寄存器保存到栈上。从 GC 的角度来看，这将根从分散的寄存器世界移动到了更有序的栈结构中。这可以简化查找寄存器根所需的[元数据](@entry_id:275500)（“寄存器根图”），但代价是更复杂的栈扫描。约定的选择为 GC 设计者在[元数据](@entry_id:275500)大小和扫描逻辑之间提供了一个根本性的权衡 [@problem_id:3634308]。

最后，想想协程（coroutines），现代 `async/await` 语法的基础。当一个协程 `yields` 或 `awaits`时，它会暂停执行并将控制权交给调度器，调度器可能会运行其他任务。就像一个异步中断一样，协程不知道在它恢复之前会发生什么。没有可以信任的被调用者。协程本身负责保存其*全部*存活状态——它在恢复时需要的每个寄存器中的每个值，无论是调用者保存还是被调用者保存。这呼应了从中断中学到的教训：简单的调用者/被调用者保存契约是为特定的、同步的交互而设计的。在此之外，必须回归到基本原则：保存你需要生存下来的一切 [@problemid:3626247]。

### 黑暗面：安全与利用

一个为合作而设计的契约，不幸的是，也可能成为被利用的目标。调用者保存约定，以其优雅的效率，也带来了微妙的安全隐患。

当一个调用者执行一个函数时，它会留下其调用者保存寄存器中的任何数据。ABI 说被调用者可以忽略这些数据并覆盖它。但如果被调用者是恶意的，或者只是有泄漏？它可能会读取这些“过时”的数据。如果这些数据是敏感的——密码片段、加密密钥——它就可能被窃取。这导致了一些安全强化策略，即指示编译器在调用前主动插入指令以清零调用者保存寄存器。这是一个权衡：付出小的、可预测的性能成本，以消除潜在的灾难性信息泄漏风险 [@problem_id:3626250]。

现在，让我们反转一下场景。如果攻击者是试图进行调用的一方呢？在一种名为[返回导向编程](@entry_id:754319)（Return-Oriented Programming, ROP）的强大攻击技术中，攻击者通过[串联](@entry_id:141009)称为“gadgets”的现有代码小片段来劫持程序的[控制流](@entry_id:273851)，每个片段都以 `ret` 指令结尾。他们的目标是用程序自己的构建块来构建一个恶意的有效载荷。

在这里，被调用者保存约定，曾经是礼貌的规则，现在成了攻击者的障碍。假设攻击者需要将一个寄存器设置为特定值，并找到了一个可以做到这一点的 gadget。如果该寄存器是被调用者保存的，那么这个 gadget 可能是一个函数的一部分，该函数为了符合 ABI，包含了在返回前恢复该寄存器原始值的其他指令。或者，如果攻击者的 gadget 本身修改了一个[被调用者保存寄存器](@entry_id:747091)，他们必须找到*另一个* gadget 来稍后恢复其原始值，否则当一个合法的函数发现其宝贵的保存状态被破坏时，程序就会崩溃。这为构建一个稳定的 ROP 链增加了显著的复杂性。这个旨在帮助函数合作的约定，迫使攻击者做更多的工作来使其恶意代码与程序的其余部分“合作”，从而使攻击更难编写 [@problem_id:3669623]。

### 一张连接之网

从程序与其[操作系统](@entry_id:752937)之间的基础契约，到编译器的精细优化，再到现代语言运行时的复杂机制和网络安全的阴暗世界，调用者保存和[被调用者保存寄存器](@entry_id:747091)约定的影响无处不在。它是一个简单、局部规则引发复杂、全局行为的完美例子。它是一个安静的证明，证明在计算世界中，没有什么是孤立存在的。每个组件、每个契约，都是一个庞大、互联且惊人优雅的整体的一部分。