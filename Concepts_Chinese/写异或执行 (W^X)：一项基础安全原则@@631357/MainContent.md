## 引言
现代计算的强大能力源于一种简洁而优雅的设计，即“[存储程序概念](@entry_id:755488)”，其中指令（代码）和数据共享同一内存空间。这种灵活性是[冯·诺依曼架构](@entry_id:756577)的一大标志，但它也带来了一个根本性的漏洞：如果攻击者能诱使程序将恶意数据当作可执行代码来处理，他们就能夺取系统的控制权。这便是[代码注入](@entry_id:747437)攻击的本质，一个几十年来一直挑战着系统设计者的持续性威胁。我们如何在一个本身就将“行为”的主动世界与“表述”的被动世界[相混合](@entry_id:199798)的基础上，构建安全的系统呢？

本文探讨了为解决这一问题而设计的开创性安全原则：[写异或执行](@entry_id:756782)（Write XOR Execute, W^X）。它提供了一种基础性防御，深刻地重塑了系统安全。在接下来的章节中，我们将剖析这一原则及其深远影响。首先，“原理与机制”部分将解释 W^X 是什么，它如何由硬件和[操作系统](@entry_id:752937)严格执行，以及其局限性所在，这些局限性也催生了新的攻击向量。随后，“应用与跨学科联系”部分将展示 W^X 理念的普遍影响，从[操作系统](@entry_id:752937)策略和[编译器设计](@entry_id:271989)，到 JIT 编译器使用的巧妙方法，甚至物理硬件本身的安全。

## 原理与机制

要理解我们的数字世界如何保持安全，我们无需从高深莫测的术语墙开始。相反，让我们从一个简单、近乎哲学的想法说起。想象一座宏伟的图书馆，里面存放着世界上所有的知识。食谱（告诉你该做什么）与购物清单（只是一系列物品的列表）并排放在书架上。这就是现代计算机的世界，一种被称为**[存储程序概念](@entry_id:755488)**或**[冯·诺依曼架构](@entry_id:756577)**的设计。其天才之处在于这种统一性：指令（代码）和数据共同存在于同一内存中，并以相同的方式访问。正是这种灵活性使计算机如此强大。

但这种统一性也隐藏着一个微妙的危险。如果你能诱使厨师把购物清单当作食谱来阅读，会怎么样？如果你能在一张购物清单的背面潦草地写下你自己的恶意食谱，并说服厨师照做，又会怎么样？这在本质上就是一次**[代码注入](@entry_id:747437)攻击**。攻击者找到一种方法，将他们自己的数据——恰好是恶意的机器码——写入程序的内存中，然后欺骗程序将这些数据当作合法的指令来执行。我们如何在不牺牲存储程序计算机优雅性的前提下防止这种情况发生呢？答案是一个美妙而简单的原则。

### 分离法则：[写异或执行](@entry_id:756782)

解决方案不是为食谱和购物清单建造独立的图书馆，而是在我们统一的图书馆内执行一条简单而强大的规则：一块内存可以用来写入新信息，**或者**可以用来执行指令，但**绝不能同时两者兼备**。这一原则被称为**[写异或执行](@entry_id:756782)**，即 **W^X**。“XOR”（[异或](@entry_id:172120)）是关键——它意味着你可以拥有其一，或其二，但不能两者都有。

这条优雅的规则清晰地将“表述”的世界（数据，是被动的，可以被改变）与“行为”的世界（代码，是主动的，运行时应是不可变的）分离开来。程序的可执行代码驻留在标记为只可执行的内存中，而其数据——变量、用户输入和[调用栈](@entry_id:634756)——则驻留在标记为可写的内存中。如果攻击者设法将恶意代码写入数据区域，W^X 会确保它仍然是惰性数据，永远不会被执行。

### 内存的守护者：硬件与软件的交响曲

W^X 这条规则不仅仅是一个友好的建议；它是由计算机硬件及其[操作系统](@entry_id:752937)合作，以不懈的警惕来强制执行的。

硬件的核心是一个名为**[内存管理单元](@entry_id:751868)（MMU）**的组件。可以把它想象成图书馆的保安。**[操作系统](@entry_id:752937)（OS）**，作为图书管理员，维护着一个名为**页表**的主目录。对于内存的每一个“页”（一个小的、固定大小的块，通常为 $4\,\mathrm{KiB}$），[操作系统](@entry_id:752937)都会在[页表](@entry_id:753080)中设置权限标志：该页是否可读（$R$）、可写（$W$）和/或可执行（$X$）？[@problem_id:3658226]

MMU 在*每一次内存访问*时都会查阅这个目录。这里有一个至关重要的洞察：从 MMU 的角度来看，从内存中读取一个值用于计算，与从内存中提取一个值作为指令来运行，是根本不同的。

*   **数据读取**检查**读（$R$）位**。
*   **指令提取**检查**执行（$X$）位**。

仅仅因为一个页面是可读的，并不意味着它是可执行的。[@problem_id:3682326]

让我们看看这首交响曲是如何挫败一次经典攻击的。攻击者发现了一个[缓冲区溢出](@entry_id:747009)漏洞，使他们能够将数据写入程序**栈**（一个临时数据区域）上缓冲区的末尾之外。他们将恶意代码（shellcode）写入栈中，然后覆盖函数的返回地址，使其指向这个 shellcode。[@problem_id:3657594]

函数完成其工作并执行[返回指令](@entry_id:754323)。CPU 按照被篡改的返回地址的指示，试图从栈中提取下一条指令。此时，MMU 介入了。它查找该栈页的权限，发现：`Read=1`, `Write=1`, **`Execute=0`**。MMU 看到缺失的执行权限，便发出警报，触发一个硬件**保护错误**。控制权立即被强制从用户程序转移到[操作系统](@entry_id:752937)。[操作系统](@entry_id:752937)检查错误原因，识别出这是一次非法执行数据的尝试，并终止这个被入侵的程序。攻击被当场阻止。[@problem-id:3658226]

正是[操作系统](@entry_id:752937)能够将保护错误与其他类型的错误——比如仅仅意味着需要从磁盘加载页面以进行合法[虚拟内存](@entry_id:177532)操作的“缺页”错误——区分开来的能力，使得这种安全机制如此稳健。[@problem_id:3666459]

一个有趣的题外话是，一些专用系统，如微控制器，使用**[哈佛架构](@entry_id:750194)**，其中指令内存和数据内存是物理上分离的。在这样的系统中，W^X 是由物理定律和布线本身强制执行的——用于提取指令的硬件根本没有通往数据内存的路径。这提供了一种固有的、铁板一块的 W^X 形式。[@problem_id:3646933]

### JIT 编译器的动态之舞

此时，聪明的读者可能会问：那些*需要*在运行时创建新代码的程序怎么办？像 Java 和 JavaScript 这样的现代语言使用**即时（JIT）编译器**，在程序运行时将代码翻译成本地机器指令以提高性能。这似乎从根本上违反了 W^X。

解决方案不是放弃规则，而是进行一场优雅的两步舞：

1.  JIT 编译器首先向[操作系统](@entry_id:752937)请求一个具有`读`和`写`权限但`执行`权限被禁用的内存页。然后，它将新生成的机器码写入这个页面，将其当作简单的数据处理。

2.  代码写入后，JIT 会向[操作系统](@entry_id:752937)发出一个特殊的[系统调用](@entry_id:755772)（如在类 Unix 系统上的 `mprotect`），请求更改该页的权限。它请求[操作系统](@entry_id:752937)撤销`写`权限并授予`执行`权限。

只有在[操作系统](@entry_id:752937)正式将该页的状态转换为只读和可执行之后，JIT 编译器才会跳转到并运行其新代码。在任何一个瞬间，内存都不是既可写又可执行的。W^X 原则得到了完美的维护。[@problem_id:3657594] [@problem_id:3689772]

当然，这种安全性并非没有代价。当[操作系统](@entry_id:752937)更改一个页面的权限时，它必须确保系统中的每个 CPU 内核都知道这一变化。每个内核都有一个用于缓存内存权限的高速缓存，称为**转译后备缓冲器（TLB）**。为了更新所有 TLB，[操作系统](@entry_id:752937)必须执行一次 **TLB 刷新（shootdown）**，向其他内核发送中断，迫使它们使旧的、过时的权限数据无效。这种跨核通信增加了一个虽小但可观的性能成本——这是为实现安全、动态的[代码生成](@entry_id:747434)而值得付出的代价。[@problem_id:3689772]

### W^X 的局限：一种新型攻击

W^X 是安全领域的一项巨大成就，它消除了所有经典的直接[代码注入](@entry_id:747437)攻击。但猫鼠游戏仍在继续。如果攻击者不需要注入他们*自己的*代码呢？

如果他们转而扮演一个恶意的傀儡师，寻找程序*现有*合法代码中的一些小的、有用的片段（称为**“gadgets”**），并将它们链接在一起呢？通过精心覆盖栈上一系列保存的返回地址，他们可以使程序从一个 gadget 跳转到下一个，从而执行他们选择的计算，而无需执行任何一个字节的注入代码。这是一种**[代码重用攻击](@entry_id:747445)**，其最著名的变种是**[返回导向编程](@entry_id:754319)（ROP）**。[@problem-id:3657594]

W^X 对这种攻击完全[无能](@entry_id:201612)为力。攻击者使用的每个 gadget 都在一个被正确标记为可执行的内存页中。问题不在于*页面*的可执行性，而在于*控制流*——即程序从一条指令到下一条指令所走的路径——的合法性。

这就是下一层防御，**[控制流完整性](@entry_id:747826)（CFI）**，发挥作用的地方。CFI 是一大类技术，旨在确保程序的执行遵循其原始的、预期的路径。一种强大的基于硬件的 CFI 机制是**影子[调用栈](@entry_id:634756)（SCS）**。CPU 在一个非特权代码无法写入的内存区域中维护第二个受保护的栈。当一个函数被调用时，返回地址被推入*正常栈和影子栈*。当函数返回时，CPU 使用来自影子栈的原始地址，忽略正常栈上的任何值。一个篡改了正常栈上返回地址的攻击者会发现他们的努力是徒劳的；硬件会查阅受保护的副本并安全返回。[@problem_id:3680372]

W^X 和 CFI 不是竞争对手；它们是合作伙伴。W^X 锁上了门，防止入侵者带入自己的工具（[代码注入](@entry_id:747437)），而 CFI 则防止入侵者滥用内部已有的工具（代码重用）。它们共同构成了一种深度防御策略，使我们的系统具有更强的韧性。[@problem_id:3657009] 分离写入与执行这一简单原则，在硬件与软件的美妙和谐中得以实施，为这些更进一步的创新奠定了基础。

