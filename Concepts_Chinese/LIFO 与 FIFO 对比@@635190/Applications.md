## 应用与跨学科联系

现在，你可能会认为，在一叠盘子和银行排队之间——在后进先出（LIFO）和先进先出（FIFO）之间——的选择是一个相当平凡的细节，一个简单的组织问题。但在计算世界里，这个简单的选择绽放成一个充满各种后果的宇宙。它就像[守恒定律](@entry_id:269268)一样，是一个奇妙而简单的思想，其影响无处不在，从处理器最深层的电路到人工智能的宏伟战略。选择 LIFO 或 FIFO 不仅仅是关于顺序；它是关于在速度与彻底性、公平与效率之间做出选择，有时，甚至是关于一个能工作的程序和一个从根本上就坏掉的程序之间的选择。让我们踏上一段旅程，看看这个简单的[二分法](@entry_id:140816)会把我们带向何方。

### 机器之心：内存、处理器与效率

在计算机操作的核心，我们不断地管理着资源。其中最宝贵的两个是内存和处理器自身的时间。LIFO/FIFO 的选择在优化这两者方面扮演着主角。

想象一下计算机的内存是一片广阔的开放领地。当一个程序需要这片领地的一部分时，[内存分配](@entry_id:634722)器——系统的房地产经纪人——必须找到一块大小合适的空地。当程序用完后，这块地被归还。分配器应该如何记录所有空闲的地块呢？它可以维护一个列表。如果它将新释放的地块添加到列表的前端（LIFO），并且也从前端开始寻找空闲地块，就会产生一个有趣的动态。刚刚释放的一块内存立即就可用于下一个请求。这为什么好呢？因为一个叫做*[时间局部性](@entry_id:755846)*（temporal locality）的原则——程序经常为与其刚刚完成的任务相似的任务请求内存。几乎瞬间重用一块内存是极其快速的。这种 LIFO 策略是不耐烦和机会主义的，优先考虑原始速度 [@problem_id:3239140]。

但这里有个陷阱。这种快速重用可能会在各处留下小的、无法使用的[内存碎片](@entry_id:635227)。另一种方法是 FIFO 策略。当一个内存块被释放时，它被放在空闲列表的*末尾*。它在列表中“老化”，等待轮到自己。这种耐心有一个奇妙的副作用。当一个块在等待时，它的隔壁邻居也可能被释放。分配器随后可以*合并*（coalesce）这两个相邻的小地块，形成一个更大、更有用的地块。从这个意义上说，FIFO 打的是持久战，牺牲了即时的分配速度，以换取长期维护一个更健康、碎片化程度更低的内存景观 [@problem_id:3644145]。所以，这里我们有了第一个重大的权衡：LIFO 的狂[热速度](@entry_id:755900)与 FIFO 的有序、整洁天性。

当我们放大到处理器本身时，故事变得更加令人惊讶。现代处理器是幻术大师。它假装只有少量寄存器（处理器的草稿纸内存），但实际上，它内部隐藏着更多的物理寄存器。这个技巧叫做*[寄存器重命名](@entry_id:754205)*（register renaming），它允许处理器并行执行许多指令。当一个物理寄存器不再需要时，它被放在一个“空闲列表”上，准备再次使用。这个列表应该是 LIFO 栈还是 FIFO 队列呢？你可能觉得无所谓。但实际上大有关系！如果我们使用 LIFO 栈，一个被释放的寄存器几乎立即被重新投入使用。它的旧值仍然物理上存在于硅片中，像一个幽灵。现在，如果我们想写入的新值，纯属巧合，与旧值*完全相同*呢？处理器可以做一件了不起的事：它完全可以跳过这次写操作！这种“写操作省略”（write elision）节省了惊人的能量。采用 LIFO 准则，这种“偶然的值局部性”（accidental value locality）很常见，因为寄存器的重用距离（reuse distance）极小。但如果用 FIFO 队列，一个被释放的寄存器可能要等很长时间才被重用。它幽灵般的旧值变成了古老的历史，匹配的几率降至几乎为零。在这种情况下，简单地选择 LIFO，直接转化为一个更凉爽、更节能的处理器 [@problem_id:3672115]。这难道不是一个美丽而意外的联系吗？

### 游戏规则：算法的正确性与策略

到目前为止，我们已经看到 LIFO 和 FIFO 作为影响性能的选择。但有时，这个选择要根本得多——它是一个能工作的算法和一个会彻底失败的算法之间的选择。

考虑这样一个问题：探索一个复杂的迷宫，或者用计算机科学的术语来说，遍历一个有向图以找到其*[强连通分量](@entry_id:270183)*——即其中每个节点都能到达其他所有节点的节点组。解决这个问题最优雅的算法之一是 Tarjan 算法，它执行一次[深度优先搜索](@entry_id:270983)（DFS）。DFS 会尽可能深地探索一条路径，然后才回溯。为了记录路径，它使用一个 LIFO 栈。栈的“后进先出”特性完美地反映了搜索“深入，然后回溯一步”的逻辑。每当你向前走一步，你就在栈上放一个标记；当你回溯时，你取下最后一个标记。如果我们天真地用 FIFO 队列替换 LIFO 栈会怎样？整个逻辑就崩溃了。FIFO 队列记住的是你到过的*最古老*的地方，而不是*最近*的地方。试图通过不断返回起点来导航迷宫，简直是一团糟。算法将不再能正确识别分量，因为[数据结构](@entry_id:262134)与搜索的递归性质之间的根本联系被打破了 [@problem_id:3276640]。在这里，LIFO 不是建议；它是法则。

LIFO/FIFO 与搜索策略之间的这种联系非常深刻。在优化和人工智能领域，一种称为“最佳优先搜索”（best-first search）的常用技术通过扩展最“有前途”的节点来探索一个可能性之树。但如果所有可用的选择看起来都同样有前途怎么办？当[启发式](@entry_id:261307)函数松散或信息量不足时，这种情况可能发生。在这种情况下，搜索算法必须依赖于一个打破平局的规则。我们发现了什么？如果打破平局的规则是 LIFO，“最佳优先”搜索就奇迹般地转变为纯粹的[深度优先搜索](@entry_id:270983)，深入探索一个分支。如果打破平局的规则是 FIFO，它就变成[广度优先搜索](@entry_id:156630)，逐层探索树。LIFO 或 FIFO 的选择*本身就成为*了搜索策略，揭示了这些基本的搜索模式只是有序探索这一基本原则的两个不同面孔 [@problem_id:3157453]。

### 公平共享：并发、饿死与并行交响曲

当我们进入并行和并发计算的世界时，我们选择的后果变得更加戏剧化，在这个世界里，许多执行线程必须合作与竞争。在这里，LIFO 和 FIFO 具有了道德维度：它们关乎公平。

想象几个程序（或“哲学家”）竞争共享资源（如“叉子”） [@problem_id:3687539]。如果一个资源正忙，它们必须排队等待。如果这个队列是一个 LIFO 栈，一种可怕的情况可能发生：一个不幸的程序可能被更新、更具侵略性的后来者永久地推到队伍后面。它会饿死，永远得不到机会，尽管整个系统在取得进展。而 FIFO 队列，根据其定义，可以防止这种情况。如果你排队了，你保证最终会到达队首。它是公平的化身。这一原则在[读写锁](@entry_id:754120)（reader-writer locks）中至关重要，其中许[多线程](@entry_id:752340)可能想要读取一块数据，而少数线程想要写入它。一个简单的 FIFO 队列用于等待的写者，确保它们中没有一个会被无尽的读者流或其他写者饿死 [@problem_id:3675712]。

这就把我们带到了最后一个，也许是最美丽的例子。我们已经看到了 LIFO 在速度和局部性方面的优势，以及 FIFO 在有序性和公平性方面的优势。如果我们能兼得两者的优点呢？在高性能[并行计算](@entry_id:139241)中，这是通过一种名为*[工作窃取](@entry_id:635381)[双端队列](@entry_id:636107)*（work-stealing deque）的巧妙装置实现的。

想象一个工人团队，每个工人都有自己的任务列表。每个工人都将自己的列表视为一个 LIFO 栈。当他们生成一个新的、小的子任务时，他们把它放在自己栈的顶部，并立即开始处理它。这很完美，因为那个新任务在他们的脑海中（以及在他们处理器的缓存中）还是新鲜的，所以效率极高。这是 LIFO 原则在本地效率方面发挥到极致的体现。

但当一个工人任务用完了怎么办？他们就变成了一个“窃贼”。他们偷偷溜到另一个忙碌工人的列表旁，“偷”一个任务。他们应该偷哪一个呢？不是栈顶的那个——那是所有者正要处理的小而新的任务，试图抢夺它会引起冲突（竞争）。相反，窃贼从列表的*底部*偷取任务——那个最老的、等待时间最长的任务。这就是 FIFO 原则。这为什么如此聪明？因为在许多问题中，最老的任务是最大、最[实质](@entry_id:149406)性的工作块。通过偷取一个大的、旧的任务，窃贼得到了一个重要的工作，可以让他们忙碌很长时间，从而减少了再次偷窃的需要。

这个设计堪称杰作。所有者使用 LIFO 以实现对缓存友好的高速处理。窃取者使用 FIFO 来窃取大的工作区块。而且，由于它们在[双端队列](@entry_id:636107)的两端进行操作，因此很少相互干扰。这是一个将 LIFO 的不耐烦与 FIFO 的耐心融合成一个和谐且效果惊人的整体的系统 [@problem_id:3226057]。它完美地说明了在科学和工程中，最深刻的见解往往不是来自于选择[二分法](@entry_id:140816)的一方，而是来自于理解如何同时运用两者。