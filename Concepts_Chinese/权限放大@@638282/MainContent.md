## 引言
在数字领域，权限——即访问资源和执行操作的许可——是安全的基石。一个设计良好的系统遵循[最小权限原则](@entry_id:753740)，仅授予每个组件足够的功能所需的能力。然而，这种微妙的平衡常常被一个被称为权限放大的根本性漏洞所破坏，即程序或用户非法地获得了超出预期的权限。本文将直面这一关键的安全挑战。首先，在“原则与机制”一章中，我们将剖析权限放大的核心方式，从显式的域切换、环境权限的微妙威胁到阴险的糊涂的代理人问题。随后，“应用与跨学科联系”一章将展示向[基于能力的安全](@entry_id:747110)的哲学转变如何提供强大的解决方案，并展示其在从[文件系统](@entry_id:749324)到复杂协作软件等各种场景中的实现，将抽象理论转化为切实的保护。

## 原则与机制

在计算世界中，就像在人类社会一样，“权限”是一种极其重要的“货币”。程序读取文件、打开网络连接或修改系统设置的能力都是一种权限形式。一个行为良好的系统，就像一个运作良好的社会，遵循[最小权限原则](@entry_id:753740)：每个组件只应被授予完成其工作所需的恰当权限，不多也不少。但是，当一个程序或用户突然获得了超出他们预期应有的权力时，会发生什么呢？这种现象被称为**权限放大**，它不仅仅是一个错误，而是计算机安全核心的一个根本性挑战。这是一个关于更换帽子、无形权力和被巧妙迷惑的代理人的故事。

### 经典的切换：通过换帽获取权力

也许最直接的获取权力的方式是暂时成为一个更强大的人。想象一下，你是一家公司的实习生，需要从一个上锁的文件柜里取一份特定的敏感文件，以完成CEO分配的任务。你没有钥匙。但有一个特殊程序：你可以为这项任务调用CEO的名义。一名保安会陪同你，在你访问那个文件柜的短暂时刻，你是*以CEO的权限*行事的。任务完成后，你又变回了一名实习生。在片刻之间，你放大了你的权限。

这正是类Unix[操作系统](@entry_id:752937)中一个经典机制**[setuid](@entry_id:754715)**（[设置用户ID](@entry_id:754715)）背后的原理。设想一个用户，我们称她为Alice，她需要更改自己的密码。所有用户的密码都存储在一个受保护的文件中，只有系统管理员 `root` 才能修改。Alice当然不能被给予直接写入此文件的权限；她可能会更改其他所有人的密码！解决方案是一个巧妙的“换帽”操作。Alice用来更改密码的 `passwd` 程序归 `root` 所有，并设置了一个特殊的 `[setuid](@entry_id:754715)` 权限位。当Alice运行这个程序时，[操作系统](@entry_id:752937)会执行一个非凡的技巧：在程序执行期间，该进程不是以Alice的有限权限运行，而是以 `root` 的全能权限运行。

我们可以使用**[保护域](@entry_id:753821)**的概念来正式地对此建模，[保护域](@entry_id:753821)就是进程在某一时刻拥有的所有权限的集合。当Alice运行 `passwd` 程序时，她的进程经历了一次**域切换**：它从她的普通域 $D_{\text{Alice}}$ 转换到管理员域 $D_{\text{root}}$。这是一个教科书式的权限放大案例，因为 `root` 域包含的权限远多于Alice的权限。`passwd` 程序经过精心编写以防止被利用，它仅使用这种临时权力来修改密码文件中的唯一正确条目，然后终止，此时进程的权限恢复为Alice的权限。这就是**临时放大**[@problem_id:3674101]。

当然，危险在于如果这个强大的程序存在缺陷。一个有漏洞的 `[setuid](@entry_id:754715)` 程序可能被欺骗去做一些意想不到的事情，比如给Alice一个 `root` 命令提示符。如果程序利用其临时权力进行永久性更改——例如，通过将Alice添加到“管理员”组——就会导致**永久放大**，这是一个更严重得多的安全漏洞。临时的“换帽”被用来窃取永久的“王冠”[@problem_id:3674101]。

### 无形之手：环境权限的危害

并非所有的放大都像域切换那样明确。有时，程序获得权力不是通过成为别人，而是通过使用其环境中“随处可见”的强大工具。这就是**环境权限**这个微妙而普遍的问题。

想象一个高度安全的工作间，为了执行一项任务，你得到了一个上锁的工具箱，里面只有你需要的特定螺丝刀和扳手。现在，想象另一个工作间，那里所有可以想象到的工具——从微小的镊子到巨大的 sledgehammer——都挂在一个公共的钉板上。即使你的指令只是拧紧一个小螺丝，那把强大的 sledgehammer 也对你可用，诱惑着你。这是一种环境权限。你不需要请求它；它就在那里。

在软件中，一个典型的例子是系统的全局名称解析器，即域名系统（DNS）。假设你在一个应用程序中安装了一个第三方插件，例如，一个需要与 `payments.example.com` 处的支付服务通信的组件。为了遵守[最小权限原则](@entry_id:753740)，这个插件应该*只*能连接到那个特定的服务器。然而，如果该插件可以使用系统的全局DNS解析器，它就拥有了环境权限。它可以查询互联网上*任何*服务器的地址——`evil-server.com`、`corporate-secrets.net`——并试图向它们发送数据。全局互联网这个“钉板”对它完全开放[@problem_id:3674025]。

强大的解决方案不是相信插件会自己守规矩，而是拿走那个“钉板”。我们可以不让它访问[全局解](@entry_id:180992)析器，而是给插件一个特殊的、受限的**能力**：一个专用的解析器对象，该对象被硬编码为*只*回答一个问题：“`payments.example.com` 的IP地址是什么？”任何其他查询都会失败。通过使权限明确且范围狭窄——一个密封的工具箱而不是一个公共的钉板——我们消除了环境权限，并防止了这种形式的权限放大[@problem_id:3674025]。

### 糊涂的代理人：欺骗强者为你效劳

也许最阴险的权限放大形式是攻击者欺骗一个合法的、强大的程序，使其滥用权限为攻击者服务。这被称为**糊涂的代理人**问题。

这个类比是一个经典的官僚主义故事。假设一个初级职员需要一份来自高度安全档案室的文件。控制访问的档案管理员，一个强大的“代理人”，会理所当然地拒绝该职员的直接请求。然而，档案管理员有一条长期有效的指令：“处理任何来自经理办公室的文件请求表。”职员无法进入经理办公室，于是他只需填写请求表，并请经理的秘书转交。秘书把它放在经理的待发箱里，档案管理员便尽职地为职员取回了敏感文件。档案管理员被“迷惑”了；他们正确地检查了请求来自正确的地方，但他们没有检查请求真正的*受益人*是谁。

这种模式在复杂的软件系统中非常普遍。考虑一个带有嵌套容器的现代系统。一个进程 $s_0$ 在外部容器中运行，拥有很高的权限，包括挂载[文件系统](@entry_id:749324)的能力。在内部，一个嵌套的、不太受信任的容器运行一个进程 $s_1$，该进程被拒绝写入一个敏感文件 $o_f$。进程 $s_1$ 无法获取该文件，但它可以与 $s_0$ 通信。它向 $s_0$ 发送一个请求：“请将包含 $o_f$ 的卷挂载到我的环境中。”进程 $s_0$，这个糊涂的代理人，有权这样做并予以满足。突然，一条通往该文件的新路径出现在 $s_1$ 的世界里，这条路径是用 $s_0$ 的强大权限创建的，从而授予了 $s_1$ 最初被拒绝的写权限[@problem_id:3674066]。

在用户可以创建链接的[文件系统](@entry_id:749324)中也会出现类似的问题。用户可能对一个文件有权限，但没有路径可以访问它。通过欺骗系统服务在他们自己的主目录中创建指向该文件的链接（一条新路径），他们可以激活这些潜在的权限，从而有效地提升他们的权限[@problem_id:3619489]。

防御糊涂代理人的方法是让代理人变得不那么容易混淆。它所拥有的权限必须受到约束。档案管理员的规则应该是只为*经理本人*满足来自经理办公室的请求。进程 $s_0$ 持有的强大挂载能力应该被**限定范围**，禁止它在子命名空间中创建挂载。文件链接操作必须增加能够**削弱**（减少）通过新创建的链接可用的权限的机制，确保用户获得的权力不会超过管理员的意图[@problem_id:3619489] [@problem_id:3674066]。

### 一种新的哲学：为削弱而非放大而设计

我们已经看到了权限如何通过显式切换、环境权限和糊涂的代理人被放大。这就引出了一个问题：我们能否构建出在结构上就不可能发生这种放大的系统？答案是肯定的，其背后的哲学被称为**[基于能力的安全](@entry_id:747110)**。

其核心思想是用其反面来取代放大：**权限的单调削弱**。权限从一个程序传递到另一个程序时只能被减少；它们永远不能被增加。

我们的实习生，不会被允许戴上CEO的帽子，而是会从CEO那里得到一把新铸造的钥匙，这把钥匙*只*能打开他们需要的那一个特定抽屉。如果实习生需要同事的帮助，他们可以复制自己的钥匙，但可以把它锉小，使其只能*解锁*抽屉，而不能再次上锁。权力向下流动，在每一步都会减弱。

在这个模型中，一个权限就是一个**能力**，一个不可伪造的令牌，它同时命名一个资源并指定一组允许的操作。当一个程序想要委托权限时，它不是交出自己的能力；而是从它派生出一个新的、更弱的能力，拥有原始权限的一个[子集](@entry_id:261956)[@problem_id:3619231]。这个简单的规则，当由操作系统内核强制执行时，从根本上改变了安全格局。

当我们考虑像勒索软件这样的威胁时，这种方法的威力就凸显出来了。
- 在使用[访问控制](@entry_id:746212)列表（ACL）的传统系统中，默认是“环境权限”。你运行的程序继承了你所有的文件访问权限。安全是一种黑名单：我们试图识别并阻止勒索软件。但如果这个黑名单有一次失误（在某个场景中为 $2\%$ 的时间），勒索软件就会得到你的主密钥并加密所有东西。这种失败是灾难性的[@problem_id:3674071]。
- 在基于能力的系统中，默认是“零权限”。程序启动时*没有*任何能力。要加密100个文件，勒索软件必须请求100个不同的能力。即使一个糊涂的代理人批准了其中一些请求，它批准全部100个请求的概率也小到可以忽略不计（例如，$(0.05)^{100}$）。损害被自然地隔离了。灾难性的失败在[系统设计](@entry_id:755777)之初就被排除了[@problem_id:3674071]。

为了使这个优雅的委托模型稳健，系统必须强制执行另外两个属性。首先，它必须防止委托循环（A委托给B，B又委托回给A），这通常通过将委托结构化为树或[有向无环图](@entry_id:164045)来实现[@problem_id:3640385]。其次，原始授予者必须能够撤销他们分发出去的权限。通过给每个派生密钥盖上它所来源的主密钥的序列号，这个问题得到了完美的解决。通过撤销那一个序列号，内核会立即废除主密钥以及从它创建的每一个子密钥，无论它们由谁持有[@problem_id:3619231]。

从简单的 `[setuid](@entry_id:754715)` 技巧到优雅的能力系统逻辑的旅程揭示了一种深刻的统一性。控制权限的挑战是普遍的。通过理解权限放大的机制——域切换、环境权限、糊涂的代理人——我们不仅学会了如何保卫我们的系统，也欣赏了那些从第一性原理出发设计的架构之美，它们扭转了潮流，确保权力一旦被授予，只能被驯服，而不会被危险地放大。

