## 应用与跨学科联系

在深入探讨了[分布式共识](@entry_id:748588)的原理之后，我们现在可能会问：“这套优雅但抽象的机制在现实世界中究竟出现在哪里？”答案或许令人惊讶，那就是*无处不在*。防止“脑裂”——即系统产生多个相互冲突的现实观——的挑战并非一个狭隘的学术难题。它是工程师们日常需要应对的一个根本性问题，其领域涵盖了从你街角的交通信号灯到驱动互联网的庞大数据中心。为了理解这一点，让我们踏上一段旅程，从共识的视角来看世界。

### 单一现实的幻象

想象一下你在玩一个多人在线游戏。在一个房间的中央，有一把独一无二、威力巨大的剑，一次只能由一个玩家持有。你和另一个玩家冲向它。在你的视角里，你先抓住了它。但你的对手在世界的另一端，经历着不同的[网络延迟](@entry_id:752433)，看到的是*他们自己*先抓住了它。到底是谁拿到了剑？如果游戏允许你们两个都暂时拥有它，那么游戏的内部逻辑就崩溃了。这是一个微型的脑裂场景。游戏服务器必须有协议来创建事件的单一、权威的历史，即使玩家的感知因网络不可避免的延迟而产生偏差。

为了让问题更棘手，假设这把剑是一次性消耗品，只能用来击败一条龙一次。如果系统错误地允许两个玩家“消耗”它，那么第二次使用就是欺诈性的。“至多一次”的语义承诺被打破了。防止这种情况的唯一稳健方法是让龙本身——即被操作的资源——成为最终的仲裁者。仅仅锁定物品是不够的。消耗请求必须携带一个“[隔离令牌](@entry_id:749290)”，这是一种随每个新所有者而改变的秘密密码。龙只会听从拥有*当前*密码的玩家的指令，拒绝来自前任所有者的任何过时请求，无论它们何时到达 [@problem_id:3636545]。这个听起来简单的想法——让资源拒绝过时命令——是我们武器库中最强大的工具之一。

### 物理世界中看不见的编排

这个问题并不仅限于虚拟世界。思考一下我们每天依赖的关键基础设施。一个城市可能想为紧急车辆实施“绿波”通行，即由一个协调器指示一系列交通信号灯变绿。如果指定的协调交通灯控制器发生电源故障并重新启动，必须有一个新的控制器接管。但如果原来的控制器并没有死机，只是暂时断开了连接呢？像让另一个控制器在超时后接管这样的简单方法是灾难的根源。你很容易最终得到两个协调器发送冲突的命令，导致交叉路口混乱。安全的解决方案要求，只有在获得所有控制器中多数派的明确“投票”后，才能选择新的领导者。因为任意两个多数派必须有交集，这种数学上的确定性可以防止在同一时间选举出两个领导者。这个系统还必须能够跨重启记住它的投票，使用[非易失性存储器](@entry_id:191738)作为它在现实中的立足点 [@problem_id:3638419]。

同样的原则确保你的计算机可以连接到互联网。对于一个给定的网络，通常有一个路由器作为通往更广阔世界的网关。为了提供高可用性，网络通常有一对冗余路由器。如果主路由器发生故障，备用路由器必须接管。但是备用路由器如何*知道*主路由器已经发生故障，而不仅仅是响应变慢？如果它过早决定接管，两个路由器可能都会开始宣告自己是网关，导致脑裂情况，[网络流](@entry_id:268800)量变得不可靠。简单的心跳协议是不够的。一个稳健的解决方案需要一个真正的共识机制。在一个双路由器设置中，这很棘手，因为没有多数派。一个常见而优雅的解决方案是添加第三个轻量级的“见证者”节点。要成为领导者，路由器必须从见证者那里获得一票。由于见证者在任何时候只会投票给一个候选者，它起到了打破僵局的作用，确保只有一个路由器可以成为活动网关 [@problem_id:3627720]。

即使在像大学校园这样熟悉的环境中，这些挑战也会出现。想象一下多个系共享一台昂贵的 3D 打印机。Wi-Fi 不稳定，各系之间可能会相互分区。我们需要一个系统来确保一次只有一个打印任务在运行。最稳健的设计借鉴了世界上最可靠的数据库。一组客户端进程运行像 Raft 这样的[共识协议](@entry_id:177900)来选举一个领导者。领导者向一个客户端授予一个有时间限制的*租约*，给予它使用打印机的临时许可。租约附带一个单调递增的*[隔离令牌](@entry_id:749290)*。打印机本身被设计得很智能；它会记录自己见过的最高令牌，并拒绝任何用较低（过时）令牌提交的任务。这三个思想的结合——用于[领导者选举](@entry_id:751205)的多数派共识、用于处理崩溃的时间限制租约，以及用于拒绝过往领导者幽灵的[隔离令牌](@entry_id:749290)——构成了构建[容错](@entry_id:142190)系统的强大三位一体 [@problem_id:3638482]。

### 云的基石

我们探讨的这些原理是现代[云计算](@entry_id:747395)的基石。云只不过是一个庞大的[分布式系统](@entry_id:268208)，而无限、可靠资源的幻象正是用这些思想精心构建的。

当你在云中运行虚拟机（VM）并附加一个物理设备，如专用的 GPU 或 USB 驱动器时，[虚拟机](@entry_id:756518)监控程序（hypervisor）必须保证只有你的 VM 才能访问它。这再次成为一个[分布式互斥](@entry_id:748593)问题。一个跨多个物理服务器复制以实现容错的协调服务，运行一个[共识算法](@entry_id:164644)来决定哪个 VM 拥有该设备。这个决定以租约的形式记录在一个复制日志中。但正如我们所见，一个被分区的 VM 可能不知道其租约已过期。关键的最后一步是在*资源端进行隔离*。连接物理设备与 VM 的硬件[多路复用器](@entry_id:172320)被赋予一个与当前租约关联的[隔离令牌](@entry_id:749290)。它会断然拒绝任何没有提供正确、最新令牌的 VM 的 I/O 操作 [@problem_id:3627662]。

这种模式从控制硬件延伸到控制行为。许多工作流都涉及必须*恰好执行一次*的关键任务——不是零次，也不是两次。想象一个负责触发每月计费运行的[分布](@entry_id:182848)式 cron 系统。如果触发该任务的领导者在执行过程中崩溃，系统必须确保新领导者能完成该任务。但它也必须确保原来的领导者（如果它没有死机）不会回来再次运行该任务。解决方案同样是让资源成为一个主动的参与者。任务执行系统或“接收端”（sink）为每个唯一的任务 ID 维护一条记录。当一个领导者想要运行一个任务时，它会出示其[隔离令牌](@entry_id:749290)。接收端使用原子操作，如[比较并交换](@entry_id:747528)（CAS），在开始任务*之前*记录该令牌，但前提是所出示的令牌高于该任务 ID 先前见过的任何令牌。这在一个不可分割的步骤中[原子性](@entry_id:746561)地武装了隔离机制并启动了任务，优雅地解决了恰好一次的问题 [@problem_id:3627726]。

归根结底，这些[共识协议](@entry_id:177900)是大多数可靠的、复制的数据库和服务背后的引擎，从 Google 的 Spanner 到像 Zookeeper 和 etcd 这样的开源系统。无论是跨一组[微服务](@entry_id:751978)管理数据库模式迁移 [@problem_id:3638476]，还是确保一个主备文件锁服务在故障切换后绝不将同一个锁授予两个客户端，核心模式都是相同的。一次安全的故障切换不是一个单一的动作，而是一场精心编排的舞蹈：等待旧领导者的租约到期，建立一个新的纪元（一个新的统治时期，具有更高的编号），使用该纪元编号作为[隔离令牌](@entry_id:749290)来阻止过时的请求，并使用唯一的客户端请求标识符来丢弃那些不确定上一条命令是否成功的客户端的重复重试 [@problem_id:3636616]。

### 超越崩溃：恶意的幽灵

到目前为止，我们一直假设我们的系统组件是诚实但脆弱的。它们可能会崩溃或变慢，但它们会遵守协议。如果它们是恶意的呢？如果它们撒谎呢？这就是[拜占庭容错](@entry_id:747029)（Byzantine Fault Tolerance, BFT）的领域，其名称源于古代将军们试图协调一次攻击，同时知道其中一些人可能是叛徒的困境。

为了防御 $f$ 个叛徒，我们需要更多的防御措施。事实证明，总共需要 $n=3f+1$ 台服务器。做出决策的法定人数大小也增加了，从在有 $2f+1$ 台服务器的崩溃-故障世界中的简单多数（$f+1$）增加到 $2f+1$。为什么？因为在 $3f+1$ 台服务器中，一个 $2f+1$ 大小的法定人数，任意两个这样的法定人数的交集至少包含 $f+1$ 个成员。由于最多有 $f$ 个叛徒，这个交集保证了至少包含一个诚实的服务器，它作为一个可靠的见证者，防止了欺骗行为。在保护[分布式文件系统](@entry_id:748590)的元数据免受拜占庭服务器攻击时，使用的正是这个逻辑。此外，为了防止恶意领导者提出无效状态，状态本身（例如，文件系统的[目录结构](@entry_id:748458)）可以用[默克尔树](@entry_id:634974)（Merkle tree）来表示，其加密的根哈希是整个系统状态的紧凑、可验证的指纹。一个状态变更的提交证书则由对该哈希的 $2f+1$ 个[数字签名](@entry_id:269311)组成，为系统的演变提供了不可否认、不可抵赖的证明 [@problem_id:3625117]。

### 放手的艺术：何时共识是多余的？

我们在本章中花时间建立了对共识机制这台精美而严谨的机器的理解，这一切都是为了实现单一、可线性化历史的目标。但这种安全性是有代价的：通信、协调和延迟。它总是必要的吗？

这是分布式系统设计中最深刻的问题之一。答案取决于你必须保护的*[不变量](@entry_id:148850)*。考虑一个管理[操作系统](@entry_id:752937)配置的服务。
- 如果我们管理一组只能由离线节点添加（不能移除）的内核模块，我们可以使用一个简单的 CRDT（无冲突复制数据类型）。每个节点只需保留一组模块，合并规则就是取并集。这是无需协调的，最终会收敛到正确的状态 [@problem_id:3641434]。同样的逻辑也适用于一组授权的 SSH 密钥，其中一种更复杂的、称为 OR-Set 的 CRDT 可以正确处理添加和移除，而无需中央协调 [@problem_id:3641434]。
- 然而，如果我们管理一个*绝不能*低于零的资源计数器，CRDT 就不够了。两个断开连接的节点都可能看到值为 1，各自发出一个递减操作，合并后最终值将是 -1，违反了[不变量](@entry_id:148850)。强制执行这种基于状态的[不变量](@entry_id:148850)需要协调 [@problem_id:3641434]。
- 最重要的是，如果我们必须强制执行像“任何时候都只有一个领导者”这样的[不变量](@entry_id:148850)，我们就别无选择。脑裂，即使是暂时的，也违反了“任何时候”这个条件。除了使用[共识协议](@entry_id:177900)来创建关于谁是领导者的单一、线性历史之外，没有其他选择。CRDTs 是在冲突发生后解决它们；而共识是在冲突发生前就阻止它们 [@problem_id:3641434]。

因此，脑裂问题不是一个单一的问题，而是一整个家族的问题。[分布式系统](@entry_id:268208)工程的艺术在于用物理学家的眼光审视一个系统的需求，识别出那些绝对的、不可破坏的[不变量](@entry_id:148850)，并仅在真正需要时才应用共识这个优美、强大但有时代价高昂的工具。