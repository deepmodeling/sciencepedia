## 引言
在[数字电路设计](@article_id:346728)领域，组合逻辑是计算的基石，它执行瞬时计算，为从简单的计算器到复杂的处理器等一切设备提供动力。作为一种顶级的硬件描述语言 (HDL)，[Verilog](@article_id:351862) 提供了强大的结构，可将这些逻辑思想转化为物理现实。然而，该语言提供了多种描述风格，每种风格都有其独特的语法和语义上的细微差别。对于不精通其底层原理的设计者来说，这种灵活性可能是一把双刃剑，常常导致一些常见但关键的错误，例如仿真不匹配或意外创建存储器。本文旨在揭开在 [Verilog](@article_id:351862) 中编写稳健的[组合逻辑](@article_id:328790)代码的神秘面纱。首先，我们将深入探讨“原理与机制”，探索 `assign` 语句、`always` 过程块和 `function` 等核心语法，同时建立避免陷阱的黄金法则。随后，在“应用与跨学科联系”部分，我们将看到这些原理如何应用于构建各种关键数字组件，从算术单元到[数据转换](@article_id:349465)器和[纠错码](@article_id:314206)，从而揭示简单的[逻辑门](@article_id:302575)如何组合成复杂的系统。

## 原理与机制

想象一下，你想向朋友描述一台简单的机器。你可以画一张图，展示所有齿轮和杠杆如何直接连接——一张蓝图。或者，你可以写下一系列指令：“如果拉动这个杠杆，那个齿轮就会转动。”两种方法描述的是同一台机器，但它们是不同的思维方式。在硬件设计领域，[Verilog](@article_id:351862) 为我们提供了这两种强大的方式来描述电路。

### 将逻辑描述为方程

描述[组合电路](@article_id:353734)最直接的方法是将其写成一组方程式。这就是**连续赋值** (continuous assignment) 所做的，它使用 `assign` 关键字。你可以把它看作是陈述一个关于电路的简单、不可打破的真理：输出*总是*等于输入的某种组合。

假设我们有一个小黑盒，它有三个输入 $x$、$y$ 和 $z$，以及一个输出 $f$。我们想要构建一个电路，其中输出 $f$ 仅在 ($x$ 或 $y$) 为真且 $z$ 为假时才为真。在[布尔代数](@article_id:323168)的语言中，我们会写成 $f = (x + y) \cdot \overline{z}$。

在 [Verilog](@article_id:351862) 中，我们可以几乎直接地翻译这个表达式。我们声明输入、输出以及连接它们的“线”。**`wire`** 正如其名：一种承载信号的物理连接。它没有记忆功能；它的值完全由驱动它的信号决定。然后，我们只需 `assign` 这个逻辑关系 [@problem_id:1975240]：

```verilog
wire p, q;

assign p = x | y;  // p is x OR y
assign q = ~z;     // q is NOT z
assign f = p  q;  // f is p AND q
```

这段代码简洁而优美。`assign` 语句创建了一个永久的连接。每当 $x$、$y$ 或 $z$ 发生变化，这些方程式所代表的逻辑门就会立即（带着微小的物理延迟）计算出 $p$、$q$ 以及最终 $f$ 的新值。这里没有顺序，没有“先做什么，后做什么”。它是一个对连续物理现实的声明。

### 行为方法：`always` 块

虽然 `assign` 语句非常适合简单的方程式，但逻辑可能会变得复杂。有时，描述*电路应该如何行为*比逐个连接线路更容易。为此，[Verilog](@article_id:351862) 给了我们**过程块** (procedural block)，最常用的是 `always @(*)`。你可以把这个块想象成一个时刻警惕着输入的小精灵。敏感列表中的 `(*)` 是一个通配符，意思是“如果此块内部使用的*任何*输入发生变化，立即重新评估所有内容。”

让我们构建一个二选一多路选择器，这是一个根据选择信号 `s` 在输入 `a` 和输入 `b` 之间进行选择的简单开关。我们可以用 `assign` 来写，但让我们用 `always` 块来描述它的行为：

```verilog
always @(*) begin
  if (s == 1) begin
    y = a;
  end else begin
    y = b;
  end
end
```

这读起来就像一个小程序。“总是在任何输入变化时，检查 `s`。如果 `s` 是 1，`y` 变成 `a`。否则，`y` 变成 `b`。”这是一种极其直观的逻辑表达方式。

但是等等，这里有一个陷阱。如果你仔细查看这个模块的完整代码 ([@problem_id:1975239])，你会发现输出被声明为 `output reg y`。为什么是 `reg`？我们刚才说过我们正在构建没有存储功能的组合逻辑，而 `wire` 用于连接。`reg` 这个名字听起来很像“寄存器 (register)”，这意味着存储！

这是 [Verilog](@article_id:351862) 历史上最令人困惑的怪癖之一。在这种情况下，**`reg` 并不一定意味着一个物理寄存器**。语言规则很简单：**任何在过程块（如 `always`）内部被赋值的信号，都必须声明为变量类型，比如 `reg`**。可以这样理解：`wire` 必须被外部持续驱动，就像一根充满水的管道。而 `reg` 更像一个桶；在过程“程序”中，我们可以将一个值*放入*其中。那个“桶”究竟只是一个会消失的临时变量，还是会成为一个真实的硬件，完全取决于我们*如何*编写代码。这是一个语法规则，是该语言语法的一个特性，而不是关于硬件本身的深刻陈述 [@problem_id:1975239]。

### [组合逻辑](@article_id:328790) `always` 块的两条黄金法则

使用 `always` 块就像得到了一根强大的魔杖。你可以用它构建几乎任何东西，但如果你不遵守规则，你可能会意外地创造出“怪物”。对于组合逻辑，有两条黄金法则。

#### 黄金法则 1：使用阻塞赋值

在过程块内部，你有两种方式给变量赋值：

1.  **阻塞赋值 (Blocking assignment):** `y = x;`
2.  **[非阻塞赋值](@article_id:342356) (Non-blocking assignment):** `y = x;`

它们看起来相似，但含义却天差地别。**阻塞赋值 (`=`)** 是立即执行的。程序流程会阻塞，直到赋值完成。**[非阻塞赋值](@article_id:342356) (`=`)** 更像是在安排一次更新。它表示：“立即计算 `x` 的值，但在当前时间步中的所有其他计算完成之前，不要更新 `y`。”

对于 `always @(*)` 内部的[组合逻辑](@article_id:328790)，规则简单而绝对：**始终使用阻塞赋值 (`=`)** [@problem_id:1915863]。

为了理解原因，让我们想象一下我们违反了规则。思考一下这段灾难性的代码，它试图使用一个中间变量 `temp` 来计算 `z = (a + b) * (a - c)` [@problem_id:1915886]：

```verilog
// DANGEROUS CODE - DO NOT USE
always @(*) begin
    temp = a + b;       // Non-blocking
    z    = temp * (a - c); // Non-blocking
end
```

假设 `a=5`, `b=3`, `c=2`，并且由于某种原因，`temp` 在上一次运行后的旧值是 `10`。一个输入发生变化，该块开始执行。因为我们使用了[非阻塞赋值](@article_id:342356)，仿真器会执行以下操作：
1.  它评估第一行的右侧：`a + b` 是 `5 + 3 = 8`。它安排 `temp` 变为 `8`。
2.  它*立即*移动到下一行，而不会等待 `temp` 更新。它评估第二行的右侧。它使用了 **`temp` 当前的旧值**，也就是 `10`！所以它计算 `10 * (5 - 2) = 30`。它安排 `z` 变为 `30`。
3.  在仿真步结束时，更新发生。`temp` 变为 `8`，`z` 变为 `30`。

结果是 `z=30`，这完全是错误的！正确答案是 `(5+3)*(5-2) = 8*3 = 24`。综合出的硬件会产生 `24`。我们遇到了**仿真-综合不匹配 (simulation-synthesis mismatch)**：我们的仿真告诉我们一回事，而真实的芯片却做了另一回事。这是硬件设计中最致命的“原罪”。

如果我们使用了阻塞赋值 (`=`)，第一行 `temp = a + b;` 将会完全执行，将 `temp` 设为 `8`，*然后*才会评估第二行。这样就会使用正确的值，得到 `z=24`。

这不仅仅是一个怪癖。它揭示了仿真器工作方式的一个深层真理。使用[非阻塞赋值](@article_id:342356)，一个信号变化可能需要多个微小的仿真步骤（称为 **delta 周期 (delta cycles)**）才能在一个逻辑链中传播。`a` 的变化在第一个 delta 周期影响 `temp`，而新的 `temp` 在*下一个* delta 周期影响 `z` [@problem_id:1915857]。阻塞赋值模拟了逻辑在一系列门电路中预期的瞬时流动。

#### 黄金法则 2：覆盖所有情况

第二条法则是关于完整性。当你编写行为描述时，你必须告诉电路在*所有可能条件下*该做什么。如果你不这样做，电路就只能猜测。而它的猜测总是一样的：“我想我应该保持上一次的值。”一旦它决定保持一个值，它就需要存储器。于是，一个**锁存器 (latch)** 就诞生了。

锁存器是一种简单的存储元件。与只在时钟边沿变化的[触发器](@article_id:353355)不同，[锁存器](@article_id:346881)是透明的；当其使能信号有效时，输出跟随输入。当使能信号无效时，它保持最后的值。无意中创建[锁存器](@article_id:346881)是危险的，因为它们可能导致不可预测的时序问题。

你怎么会意外地创建一个[锁存器](@article_id:346881)？

*   **没有 `else` 的 `if` 语句**：思考一下这段代码片段 [@problem_id:1975224]。

    ```verilog
    always @(*) begin
        if (sel == 1'b1) begin
            q = d;
        end
        // What happens if sel is 0? The code doesn't say!
    end
    ```

    当 `sel` 为 1 时，`q` 跟随 `d`。但是当 `sel` 为 0 时会发生什么？代码没有说明。综合器别无选择，只能推断出一个存储元件来保持 `q` 的前一个值。你无意中创建了一个[锁存器](@article_id:346881)。

*   **不完整的 `case` 语句**：这是以不同形式出现的相同错误 [@problem_id:1943476]。

    ```verilog
    always @(*) begin
        case (sel) // sel is 2 bits, has 4 possible values
            2'b00: data_out = 4'b0001;
            2'b01: data_out = 4'b0010;
            2'b10: data_out = 4'b0100;
            // What happens if sel is 2'b11? The code doesn't say!
        endcase
    end
    ```

    同样，对于缺失的情况 (`2'b11`)，综合器会推断出一个[锁存器](@article_id:346881)来保持 `data_out` 的最后值。解决方法很简单：在用于组合逻辑的 `case` 语句中，始终包含一个 `default` 分支。

*   **不完整的敏感列表**：这是所有陷阱中最微妙的一个。如果你的逻辑依赖于某个信号，但你忘记将该信号放入敏感列表中，那么当该信号变化时，`always` 块将不会重新评估 [@problem_id:1912807]。输出将被卡住，保持其旧值，实际上表现得像存储器一样。这也正是现代 `always @(*)` 如此重要的原因；它能自动推断出正确的敏感列表，使你免于犯下这种危险的错误。

### 优雅与可重用性：`function`

我们已经了解了规则和陷阱。那么我们如何编写干净、安全且可重用的[组合逻辑](@article_id:328790)呢？[Verilog](@article_id:351862) 为此提供了一个优雅的工具：**`function`**。

函数是一个独立的单元，它接收输入，执行计算，并返回一个单一的值。根据定义，它们是纯[组合逻辑](@article_id:328790)的。语言本身就对它们强制执行了我们的黄金法则：
1.  函数必须在零仿真时间内执行。它不能包含延迟或等待事件。
2.  因此，函数内部只允许使用**阻塞赋值 (`=`)**。非阻塞运算符 (`=`) 在函数中是非法的 [@problem_id:1915909]。

这太棒了！`function` 结构天生就能引导我们编写正确的[组合逻辑](@article_id:328790)代码。例如，要计算[数据总线](@article_id:346716)的奇偶性（判断 1 的数量是奇数还是偶数），我们可以编写一个简洁的函数：

```verilog
function odd_parity (input [7:0] data);
    odd_parity = ^data; // XOR-reduction of all bits
endfunction
```

现在，我们可以在任何需要的地方使用这个函数。这引出了最后一点，一个清晰而优美的概念。在函数内部，返回值 (`odd_parity`) 是过程赋值的，因此其行为类似于 `reg`。但在我们的[主模](@article_id:327170)块中，我们可以用它来驱动一个 `wire` [@problem_id:1975227]：

```verilog
wire result;
assign result = odd_parity(data_in);
```

这看起来可能有些矛盾——将一个 `reg` 连接到一个 `wire`？但事实并非如此。我们不是在“连接”类型。我们是在调用一个函数，该函数执行瞬时计算并返回一个*值*。然后 `assign` 语句接收这个结果值，并用它来持续驱动 `wire`。这完美地说明了 [Verilog](@article_id:351862) 的不同概念——过程计算和连续赋值——如何在一个和谐且逻辑自洽的系统中协同工作，以描述数字电路的物理世界。