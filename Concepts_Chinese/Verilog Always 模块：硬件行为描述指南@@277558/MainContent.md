## 引言
要描述数字电子设备这个并行且快得惊人的世界，我们不能用传统软件的顺序步骤来思考。像 [Verilog](@article_id:351862) 这样的硬件描述语言 (HDL) 需要一种不同的思维模型，而 `always` 模块是将人类意图转化为电路语言的主要工具。它是一种结构，允许设计者超越简单的连续连接，定义响应特定事件的复杂、有状态的行为。然而，其强大的功能也伴随着一些可能让新设计师困惑的微妙之处，导致电路在仿真中行为不当，或在芯片中完全失效。

本文是一份掌握 `always` 模块的综合指南。我们将剖析其基本操作，解决如何正确建模瞬时逻辑和与时间相关的存储这一核心问题。在接下来的章节中，您将深入了解其核心机制和实际用途。首先，在“原理与机制”中，我们将探讨事件和存储的概念、`reg` 和 `wire` 之间的关键区别，以及阻塞赋值和[非阻塞赋值](@article_id:342356)之间至关重要的区别。然后，在“应用与跨学科联系”中，我们将看到这些原理如何应用于设计和验证现实世界的数字系统，从简单的[逻辑门](@article_id:302575)和音频推子到复杂的存储结构和验证测试平台。

## 原理与机制

要真正理解一门语言，你必须理解它试图描述的世界。对于像英语这样的语言，那个世界是人类思想和互动的复杂织锦。对于像 [Verilog](@article_id:351862) 这样的硬件描述语言 (HDL)，它所描述的世界是数字电子设备那个静默、并行且快得惊人的宇宙。描述这个世界需要一种不同的思维方式，一种从食谱的逐步指令到宏大演出的[同步](@article_id:339180)编排的转变。`always` 模块就是这场演出中导演的剧本。

### 行为的核心：事件与存储

在电路的物理世界中，一些连接是简单且永久的。连接开关和灯泡的电线是一种直接、连续的关系。如果开关闭合，灯就亮。如果断开，灯就灭。在 [Verilog](@article_id:351862) 中，我们用**连续赋值**来建模这种关系，使用 `assign` 关键字。像 `assign y = a & b;` 这样的语句是一个事实陈述，一条在任何时候都成立的物理定律：信号 `y` *永远* 是 `a` 和 `b` 的逻辑与。

但更有趣的行为呢？比如一个只在时钟脉冲到来时才计数的计数器？或者一个能保存一位信息的存储单元？这些事情不是连续发生的；它们是响应特定**事件**而发生的。这就是 `always` 模块的领域。它告诉硬件*当*某事发生时该做什么——例如，`always @(posedge clk)` 翻译过来就是“每当你看到[时钟信号](@article_id:353494)从低电平跳变到高电平时，执行以下操作”。

这立刻引出了一个有趣的问题。如果一个信号的值只在事件发生的那一刻被定义，那么在其余时间里它的值是什么？它必须在事件之间*记住*它的值。它需要一个地方来存储信息。这就是为什么任何在 `always` 模块内部被赋值的信号都必须声明为变量类型，如 `reg` [@problem_id:1975239]。可以这样想：`wire` 是一个通道，它只有在有东西主动驱动它时才有值。`reg` 是一个容器；它会一直保持最后放入的值，直到一个新的事件告诉它更新 [@problem_id:1975235]。

一个常见且可以理解的困惑点是，关键字 `reg` 必定意味着一个物理的“寄存器”或[触发器](@article_id:353355)。这是一个历史性的用词不当。`reg` 仅仅是一个变量——一个可以保持其值的数据。是你在 `always` 模块中描述的*行为*告诉综合工具，这个变量应该被实现为一根简单的导线、一个称为锁存器的存储元件，还是一个称为[触发器](@article_id:353355)的[时钟同步](@article_id:333776)存储元件。因为 `reg` 数据类型从根本上是为了在过程性更新之间保持一个值，所以它在概念上与 `assign` 语句的连续、无状态的性质不兼容。这就是为什么该语言强制执行一条严格的规则：如果一个信号是 `reg` 类型，它必须在像 `always` 这样的过程块内被驱动 [@problem_id:1975480]。这条规则并非随意的；它反映了无状态连接和有状态行为之间深刻的语义区别。

### 两种剧本：[阻塞赋值与非阻塞赋值](@article_id:348783)

现在我们来到了 `always` 模块最关键，也常常是最令人困惑的方面：两种赋值操作符。它们看起来几乎一样——`=` 和 `<=`——但它们描述了两种截然不同的行为。在这里，我们必须抛弃来自顺序软件编程的直觉，拥抱硬件的并行性。

#### 食谱：阻塞赋值 (`=`)

阻塞赋值 `=` 的行为与 Python 或 C 等语言中的赋值完全一样。它是一个循序渐进的食谱。该行被执行，值*立即*更新，下一行看到的是这个新的、已更新的值。

想象一下，你有三个寄存器 `A`、`B` 和 `C`，初始值分别为 1、2 和 3。你想要轮换它们的值，于是在一个时钟控制的 `always` 模块中编写了看似合乎逻辑的一系列步骤：

```verilog
always @(posedge clk) begin
    A = B;  // A 变成 2
    B = C;  // B 变成 3
    C = A;  // C 变成...什么？
end
```

让我们像计算机程序一样追踪它。在时钟边沿，第一行 `A = B;` 执行。`B` 是 2，所以 `A` 立即变成 2。第二行 `B = C;` 执行。`C` 是 3，所以 `B` 立即变成 3。现在是最后一行 `C = A;`。*在这一刻* `A` 的值是多少？它不是原来的 1；它在第一步中被更新了。`A` 的值现在是 2。所以，`C` 变成了 2。时钟节拍过后，最终状态是 `A=2, B=3, C=2`——而不是我们想要的轮换！[@problem_id:1915858]。这种顺序执行非常适合描述一连串的[组合逻辑](@article_id:328790)，其中一个计算结果立即流入下一个，所有这些都在一瞬间完成。这就是为什么既定的最佳实践是：在 `always @(*)` 模块中对**组合逻辑**使用**阻塞赋值** [@problem_id:1915863]。

#### 快照：[非阻塞赋值](@article_id:342356) (`<=`)

[非阻塞赋值](@article_id:342356) `<=` 是描述真正并行性的关键。它基于“快照”原则。当 `always` 模块触发时，仿真器会根据模块开始*之前*存在的值来计算*所有*[非阻塞赋值](@article_id:342356)的右侧。然后，它会安排所有左侧的信号在时间步结束时同时更新。

让我们用[非阻塞赋值](@article_id:342356)重试我们的寄存器交换逻辑。下面我们将实现一个两级[移位寄存器](@article_id:346472)，其中数据在同一个时钟边沿从输入 `d`流入 `q1`，再从 `q1` 流入 `q2`。

```verilog
always @(posedge clk) begin
  q2 <= q1;
  q1 <= d;
end
```

在时钟的上升沿，硬件拍下一张快照。它看到 `q1` 的*当前*值和 `d` 的*当前*值。它安排两个更新同时发生：`q2` 将得到 `q1` 的*旧*值，而 `q1` 将得到 `d` 的*旧*值。我们写这两行的顺序与结果完全无关。这完美地模拟了两个独立的[触发器](@article_id:353355)的物理现实，它们都连接到同一个时钟，其输入在同一瞬间被采样，其输出稍后一起改变 [@problem_id:1915856]。这就是为什么优秀设计的铁律是：在时钟控制的 `always` 模块中描述**[时序逻辑](@article_id:326113)**时，始终使用**[非阻塞赋值](@article_id:342356)**。

### 导演的陷阱：意想不到的后果

通过描述行为，我们实际上是在给综合工具下指令，它将构建一个物理电路来匹配我们的描述，无论这描述多么不合逻辑。遵循规则会产生可预测、稳健的硬件。违反规则则可能导致意想不到的、有问题的结果。

#### 思维不周的危险：[推断锁存器](@article_id:356025)

当你用 `always @(*)` 模块描述[组合逻辑](@article_id:328790)时，你是在做一个承诺：你将为*每一种可能的输入组合*指定输出值。如果你违背了这个承诺会发生什么？

考虑一个简单的译码器，其中输出 `data_out` 的值基于一个 2 位选择器 `sel` 来赋值。一个 2 位的信号可以有四种可能的值（`00`, `01`, `10`, `11`）。假设你写了一个 `case` 语句，但只指定了其中三种情况该怎么做 [@problem_id:1943476]：

```verilog
always @(*) begin
    case (sel)
        2'b00: data_out = 4'b0001;
        2'b01: data_out = 4'b0010;
        2'b10: data_out = 4'b0100;
        // 糟糕！如果 sel 是 2'b11 会发生什么？
    endcase
end
```

当 `sel` 是 `11` 时，`data_out` 应该是什么？你没有说。综合器唯一的选择是实现你所描述的行为，即“如果 `sel` 是 `11`，`data_out` 应该保持它之前的值”。为了“保持”一个值，你需要存储器。工具将推断出一个**[锁存器](@article_id:346881)**——一种电平敏感的存储元件——来保持最后的值。在许多设计中，[锁存器](@article_id:346881)可能会引发问题，导致时序问题和毛刺。工具会警告你：“警告：为信号 `data_out` 推断出[锁存器](@article_id:346881)。” 这不是一个错误；工具只是忠实地构建了你所描述的电路，而这个电路包含了非预期的存储器。

#### 冲突的混乱：[竞争条件](@article_id:356595)

最后，如果你给出了相互冲突的指令会发生什么？想象两个不同的 `always` 模块，都由同一个时钟[边沿触发](@article_id:351731)，试图驱动同一个 `reg` 变量。

```verilog
// 进程 1
always @(posedge clk) begin
    q <= a;
end

// 进程 2
always @(posedge clk) begin
    q <= b;
end
```

这在硬件上是不可能的——你不能在没有特定结构来解决冲突的情况下，将两个不同的输出连接到同一根线上。在仿真中，这会产生一个**[竞争条件](@article_id:356595)**。两个进程都想更新 `q`。哪一个会赢？[Verilog](@article_id:351862) 标准没有定义并发 `always` 模块的执行顺序。一个仿真器可能最后执行进程 1 的更新，所以 `q` 得到 `a` 的值。另一个完全合规的仿真器可能最后执行进程 2 的更新，所以 `q` 得到 `b` 的值。结果是[非确定性](@article_id:328829)的 [@problem_id:1943445]。这是一个隐蔽的错误，可能导致一个设计在某个仿真环境中工作正常，而在另一个环境中失败，或者更糟的是，在实际芯片中失败。这是 `always` 模块的终极教训：你是一个复杂并行演出的导演。你的剧本必须清晰、完整且无[歧义](@article_id:340434)，否则你的演员们会感到困惑，整个演出将陷入混乱。