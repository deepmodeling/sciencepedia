## 引言
从机械硬盘驱动器（HDD）到电子[固态硬盘](@entry_id:755039)驱动器（SSD）的转变，是现代计算领域最重要的架构变革之一。然而，简单地将SSD视为“更快的HDD”是一个会导致巨[大性](@entry_id:268856)能浪费的严重错误。诞生于驯服旋转盘片和移动磁头物理特性的古老[磁盘调度](@entry_id:748543)艺术，在静默的硅晶世界里不仅已经过时——它甚至是有害的。本文旨在弥合经典I/O调度与现代存储所需的新[范式](@entry_id:161181)之间的知识鸿沟。

在接下来的章节中，我们将探讨支配SSD性能的基本原理，并破除继承自HDD时代的假设。“原理与机制”一章将对比两种设备类型的物理特性，解释为何SSD要求关注并行性而非局部性。随后，“应用与跨学科联系”一章将追溯这一新的存储现实对软件栈上层的深远影响，揭示SSD如何影响从操作系统内核设计到应用层[数据管理](@entry_id:635035)的方方面面。

## 原理与机制

要理解[磁盘调度](@entry_id:748543)的艺术与科学，尤其是在[固态硬盘](@entry_id:755039)的现代，我们必须首先认识到，我们正在处理两种截然不同的物理世界。一个是由宏伟的旋转机械构成的世界，是[牛顿力学](@entry_id:162125)的奇迹。另一个则是由硅中电子的微妙舞蹈所支配的、静默无声、纹丝不动的世界。调度的原则并非随意的规则；它们是这两个世界物理特性的[逻辑推论](@entry_id:155068)。

### 双城记：旋转锈铁与静默硅晶

让我们从经典的**机械硬盘驱动器（HDD）**开始旅程。在其核心，HDD是一件机电工程的杰作。它将[数据存储](@entry_id:141659)在旋转的盘片上，就像一个微型但密度极高的唱机。要读取或写入一段数据，带有读写头的机械臂必须首先移动到盘片上的正确磁道——这就是**[寻道时间](@entry_id:754621)**。然后，它必须等待盘片旋转，直到所需的数据扇区正好位于磁头下方——这就是**[旋转延迟](@entry_id:754428)**。只有在这两种机械延迟（我们可以统称为“定位时间”）之后，数据才能真正被传输。

这种机械特性的后果是惊人的。想象一个转速为 $7200$ RPM 的磁盘，平均[寻道时间](@entry_id:754621)为 $8$ 毫秒。我们来做一个简单的粗略计算。旋转一周的时间约为 $8.3$ 毫秒，所以平均[旋转延迟](@entry_id:754428)（等待半圈）约为 $4.17$ 毫秒。因此，总的平均定位时间是 $8 \text{ ms} + 4.17 \text{ ms} = 12.17$ 毫秒。现在，传输一个小的 $4$ KiB 数据块需要多长时间？在传输速率为 $150$ MiB/s 的情况下，传输时间仅为 $0.026$ 毫秒！[@problem_id:3655582]

想一想。驱动器花费超过12毫秒仅仅为了到达位置，而实际移动数据的时间却不到百分之三毫秒。这就像花一个小时开车去图书馆借一本书，然后只用五秒钟读一句话。对于小规模、随机访问的数据，HDD的工作几乎完全由运动物理学主导。

现在，让我们进入另一个世界，**[固态硬盘](@entry_id:755039)驱动器（SSD）**的世界。SSD没有移动部件。它是一个巨大而静默的晶体管网格。访问任何数据，无论其“位置”如何，都是一个纯粹的电子过程。这就像拥有一个带有神奇传送器的图书馆，可以瞬间将你带到任何书架上的任何一本书。没有[寻道时间](@entry_id:754621)，也没有[旋转延迟](@entry_id:754428)。一个请求的服务时间仅仅是一个小的、固定的控制器开销加上通过电子接口传输数据所需的时间[@problem_id:3655582]。

对于在现代SSD上读取同样的 $4$ KiB数据，其传输速率为 $500$ MiB/s，传输时间仅为微不足道的 $0.008$ 毫秒。再加上一个典型的控制器开销，比如 $0.05$ 毫秒，总服务时间还不到 $0.06$ 毫秒。对于完全相同的请求，这比HDD快了200多倍！这种巨大的性能差异不仅仅是程度上的问题，更是性质上的差异，它要求一种完全不同的调度哲学。

### 电梯的艺术：驯服机械猛兽

既然HDD的性能完全由其磁头移动所花费的时间主导，那么最明显的加速方法就是减少磁头的移动。这就是经典**I/O调度器**背后简单而优美的思想。如果[操作系统](@entry_id:752937)有一个等待磁盘处理的请求队列，它不必按照请求到达的顺序来服务它们。它可以更聪明一些。

这就催生了**[电梯算法](@entry_id:748934)**（及其变体，如SCAN和LOOK）。想象这些请求是要取图书馆不同楼层的书。一个天真的图书管理员会为每个单独的请求跑上跑下。而一个聪明的图书管理员则会走进电梯，一路向上，在途中的楼层停下取书，然后再一路向下，做同样的事情。这最小化了总的行程时间。

[磁盘调度](@entry_id:748543)器对读写头也做同样的事情。它根据请求的物理位置（或其代理——逻辑块地址LBA）对请求进行排序，并来回扫描盘片，在经过时按顺序服务请求[@problem_id:3648687] [@problem_id:3635824]。这种简单的重排序行为将一系列混乱的、长距离的随机寻道转变为平滑、高效的扫描，极大地提高了吞吐量。另一个技巧是将相邻的小请求合并成一个更大的请求，这减少了支付昂贵的寻道和旋转代价的次数，通常能将吞吐量提高1.5到2倍[@problem_id:3684453]。

但这个优美的优化有一个阴暗面：饿死。如果一个请求的位置在磁盘的远端，而新的请求不断在磁头当前位置附近到达怎么办？那个遥远的请求可能会被无限期推迟，等待“电梯”最终到达它的楼层[@problem_id:3648687]。对于对延迟敏感的应用程序来说，这是不可接受的。

这就是像 `Deadline` 调度器这样更复杂的调度器发挥作用的地方。它仍然使用类似电梯的方法来最大化[吞吐量](@entry_id:271802)，但它为每个请求附加了一个截止时间。如果一个请求等待时间过长并接近其截止时间，调度器将抢占电梯扫描，服务那个紧急的请求，即使这需要一次长距离的寻道[@problem_id:3649832]。这优雅地平衡了[吞吐量](@entry_id:271802)的全局目标与公平性和有界延迟的个体需求，使其成为HDD上混合工作负载的绝佳选择[@problem_id:3651842]。

### 电梯的徒劳：SSD的新哲学

如果[电梯算法](@entry_id:748934)对HDD如此出色，为什么不用于SSD呢？答案又回到了我们的第一条原则：SSD没有[寻道时间](@entry_id:754621)需要优化。在SSD上运行[电梯算法](@entry_id:748934)，就像为一个拥有传送器的图书馆精心规划最高效的步行路线。这是白费功夫[@problem_id:3655582]。

更糟糕的是，它可能是有害的。释放SSD性能的真正关键不是局部性，而是**并行性**。一个现代SSD不是一个单一的、庞大的[闪存](@entry_id:176118)块。它是一个复杂的[并行系统](@entry_id:271105)，包含多个内存通道和许多闪存芯片，所有这些都由一个强大的板载控制器管理。把它想象成一个有几十名工人工作的仓库。为了实现高吞-吐量，你不能一次只给他们一个订单；你需要递给他们一厚叠订单，这样他们才能并行工作。

这就是**队列深度**——发送到设备的未完成请求数量——变得至关重要的地方。为了让所有这些内部“工人”保持忙碌，[操作系统](@entry_id:752937)必须维持一个足够深的命令队列[@problem_id:3626788]。现代的**非易失性内存快速（NVMe）**接口就是专为此设计的，它支持多个深度队列，可以由不同的[CPU核心](@entry_id:748005)无竞争地供给。

现在我们明白了为什么旧的电梯模型对SSD如此错误。电梯调度器接收来自所有应用程序的所有请求，并将它们汇集到一个单一的、全局排序的队列中。这种序列化主动地*隐藏*了工作负载固有的并行性，使其对设备不可见。SSD的精密控制器急于将请求分派到其众多的并行单元，看到的却是一串可怜的、单列的命令流。吞吐量直线下降，延迟反而可能增加[@problem_id:3648687]。

在现代SSD上进行调度的正确哲学是谦逊。[操作系统调度](@entry_id:753016)器的工作就是让开。这催生了 `noop`（意为“无操作”）调度器的兴起。它只做最少的工作——或许合并一些相邻的请求——然后尽快将工作负载直接传递给设备，维持一个深队列。它信任设备内部的调度器，后者对其自身的[并行架构](@entry_id:637629)有着深入的了解，能够完成繁重的工作。[操作系统](@entry_id:752937)提供“做什么”；设备的FTL决定“如何做”和“在哪里做”[@problem_id:3651842]。

### 超越位置：SSD调度的更深层次

如果位置对SSD不重要，那什么重要呢？那些强大的设备控制器在思考什么？在这里，我们揭开另一层面纱，发现为固态存储进行调度的挑战远比我们想象的更为微妙和迷人。

#### [写入放大](@entry_id:756776)问题

[NAND闪存](@entry_id:752365)（SSD的构建基块）的物理特性中包含一种奇特的不对称性。你可以在称为*页*的小单元中写入数据，但只能在称为*擦除块*的非常大的单元中擦除数据。想象一块白板，你可以在任何一行上写字，但要擦掉一行，你必须擦掉整块白板。

这导致了一个称为**垃圾回收**的过程。如果一个块中混合了有效数据（仍在使用）和无效数据（已删除或被覆盖），而SSD需要更多可用空间，它不能简单地擦除该块。它必须首先读取所有有效的页，将它们写入一个新的、空的块中，然后才能擦除旧块。这种复制有效数据的行为是额外的内部工作。总物理写入量（主机写入+复制的写入）与原始主机写入量之比，称为**[写入放大](@entry_id:756776)**[@problem_id:3683934]。

最小化[写入放大](@entry_id:756776)是SSD内部调度器——即其**[闪存转换层](@entry_id:749448)（FTL）**——的首要目标之一。[垃圾回收](@entry_id:637325)的成本完全取决于被清理块的*有效数据比例*。回收一个大部分是无效数据的块（例如，25%有效）很廉价，只需少量复制。回收一个大部分是有效数据的块（例如，75%有效）则非常昂贵[@problem_id:3683934]。因此，一个智能的FTL会尝试将“热”数据（频繁被覆盖）和“冷”数据（静态）隔离到不同的块上，并优先对“热”[数据块](@entry_id:748187)进行[垃圾回收](@entry_id:637325)。这一原则一直延伸到应用程序设计层面；执行大块顺序写入的算法远比执行小块随机写入的算法对“SSD更友好”，因为它们自然会创建可以被高效回收的块[@problem_id:3233064]。

#### [热节流](@entry_id:755899)

SSD在微小的空间内集成了惊人的性能。所有这些活动都会产[生热](@entry_id:167810)量，而热量是电子产品的敌人。如果SSD[过热](@entry_id:147261)，它必须减速以保护自己——这种现象称为**[热节流](@entry_id:755899)**。当温度超过某个阈值时，执行内部操作（如写入和擦除）所需的时间会增加，从而直接降低性能[@problem_id:3683896]。

这为调度引入了一个全新的维度：[电源管理](@entry_id:753652)。一个现代的I/O调度器可能不仅仅是在排序请求，而是在充当一个[热管理](@entry_id:146042)器。它在一个*功率预算*下运行。基于驱动器热特性的简单模型，调度器可以计算出驱动器在不[过热](@entry_id:147261)的情况下可以耗散的最大平均功率。然后，它通过小心地交错高功率活动（如写入）、低功率活动（如读取）和空闲时间来强制执行这个预算。它可能会使用[令牌桶](@entry_id:756046)机制将密集的写入突发平滑到一段时间内，确保驱动器在不触及热墙的情况下提供持续的性能。这是经典[热力学](@entry_id:141121)在尖端计算机系统中的一个漂亮应用，确保静默的硅晶不会变得太热[@problem__id:3683896]。

最终，[磁盘调度](@entry_id:748543)的历程揭示了一个深刻的教训。没有单一的“最佳”算法。[最优策略](@entry_id:138495)是设备底层物理特性的深刻而优雅的反映。对于HDD的机械世界，它是一场运动与局部性的舞蹈。对于SSD的量子力学世界，它是一场关于并行性、数据生命周期乃至热能的复杂协商。理解这些原则，不仅让我们能使用这些设备，更能以一种解锁其真正潜力的方式与它们合作。

