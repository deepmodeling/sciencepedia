## 引言
乍一看，向函数传递参数是编程中最基本的操作之一——一次简单的数据交接。然而，这一简单的行为却受一套深刻而复杂的规则所约束，这套规则被称为[应用程序二进制接口](@entry_id:746491)（ABI）。这份无形的契约是构建协作、高效和安全软件的基石，但其复杂性和后果却常常被忽视。本文旨在揭开这些关键约定的面纱，探讨它们如何运作以及为何如此重要。

我们将首先剖析参数传递的核心**原理与机制**，审视 CPU 寄存器和内存栈之间的[基本权](@entry_id:200855)衡、寄存器使用的规范以及处理复杂数据的巧妙策略。随后，本文将把[焦点](@entry_id:174388)扩展到**应用与跨学科联系**上，揭示这些底层规则如何对从软件速度、[编译器优化](@entry_id:747548)到我们编程语言的特性乃至[操作系统](@entry_id:752937)的安全架构等方方面面产生巨大影响。这段旅程将从探索最初允许函数间进行通信的“社会契约”开始。

## 原理与机制

想象一下，两位才华横溢的钟表匠在工坊里协同工作。要组装一块复杂的钟表，他们不能只是随意地把齿轮和弹簧递给对方。他们需要一个系统，一种关于如何传递零件、哪些工具是私人的、哪些可以借用的共识。如果一位钟表匠需要一颗微小的螺丝，她是直接开口要，还是另一位会把它放在指定的托盘上？如果她借用了一把特殊的扳手，她是否应该将其放回原位？

这恰恰是运行中的程序内部函数所面临的挑战。函数是一个自包含的代码单元，一个专家。任何一个非凡的程序要能工作，这些专家就必须进行沟通——它们必须相互调用，来回传递数据，并共享资源。这套支配这场错综复杂之舞的规则被称为**[应用程序二进制接口](@entry_id:746491)（ABI）**，其核心便是**参数传递**机制。ABI 并非由处理器的硅晶片所决定的物理定律；它是一份精心制定的“社会契约”，使得由不同的人在不同时间编译的软件能够完美无瑕地协作。

### 沟通的两种通货：栈和寄存器

在最基础的层面上，函数有两种方式从其调用者那里接收信息：通过主存（经由**栈**）或通过 CPU 自带的高速存储（**寄存器**）。

栈是一个简单、健壮且通用的解决方案。它是一个像一叠盘子一样组织的内存区域——你可以将新项目推到顶部，或从顶部弹出项目。为了调用一个函数，调用者可以逐个将参数推入栈中。然后被调用者就可以从那个已知位置读取它们。这就像在共享的白板上留言。它总能奏效，但速度很慢。访问内存比访问已经在 CPU 内部的数据要慢上几个[数量级](@entry_id:264888)。

一种效率高得多的方法是使用 CPU 的**寄存器**。寄存器是直接构建在处理器核心中的少量极快存储位置。在寄存器中传递参数就像一次直接对话——调用者将一个值放入寄存器，被调用者几乎可以瞬间使用它。这避免了到主存的缓慢往返，从而显著提高性能。正如一个思想实验所展示的，用基于寄存器的传递[取代基](@entry_id:183115)于栈的传递，可以消除整个内存加载和存储操作流，减少处理器[数据缓存](@entry_id:748188)内的流量，并释放关键的执行资源 [@problem_id:3654016] [@problem_id:3664370]。

很自然地，现代 ABI 严重依赖寄存器。但有一个问题：寄存器是一种稀缺资源。一个典型的 64 位架构可能只有少数几个寄存器被指定用于传递参数。这就引出了任何[调用约定](@entry_id:753766)的第一个主要原则。

### 传递的层级：当寄存器用尽时

大多数 ABI，比如 Linux 和 macOS 使用的通用 **x86_64 System V ABI**，都采用了一种简单而优雅的混合方法。它们指定一个特定的寄存器序列来传递前几个参数。对于整数和指针参数，前六个在寄存器 `RDI`、`RSI`、`RDX`、`RCX`、`R8` 和 `R9` 中传递。如果一个函数有超过六个整数参数，第七个及后续的参数就会“溢出”到栈上。

但如果参数是不同类型的呢？ABI 在这里甚至更聪明。它建立了不同的**寄存器类别**。例如，x86_64 System V ABI 有一个独立的寄存器池（`XMM0` 到 `XMM7`）用于[浮点](@entry_id:749453)（或 `double`）参数。参数从左到右处理，每个参数都被分配给*其类别中*下一个可用的寄存器。

考虑一个假设的函数 `g(double, long, double, long, ...)` [@problem_id:3669319]。第一个参数（一个 `double`）进入 `XMM0`。第二个（一个 `long`）进入 `RDI`。第三个（`double`）进入 `XMM1`，第四个（`long`）进入 `RSI`，依此类推。整数和[浮点](@entry_id:749453)参数独立地填充它们各自的寄存器池。第一个被传递到栈上的参数是那个首先耗尽其类别寄存器池的参数。在这种情况下，因为只有 6 个整数参数寄存器但有 8 个[浮点](@entry_id:749453)寄存器，所以第 7 个整数参数（总体上是第 14 个参数）将是第一个被放到栈上的。

这个系统是一个绝佳的权衡，它为最常见的情况（参数少的函数）优先考虑了寄存器的速度，同时提供了栈的无限容量作为后备方案。

### 大型对象的问题：值传递 vs. [引用传递](@entry_id:753238)

传递一个简单的整数或指针是直接简单的——它能整洁地装入单个寄存器。但是，对于一个复杂的数据结构，一个包含多个字段的 `struct`，情况又如何呢？

在这里，ABI 必须做出另一个务实的决定，通常是基于大小 [@problem_id:3678296] [@problem_id:3664358]。

-   **值传递：** 如果结构体足够小——比如说，它能装入一到两个寄存器——ABI 可能会选择将整个结构体的内容直接复制到参数寄存器中。这对于小型聚合体是高效的。“小”的定义取决于架构；一个 8 字节的结构体在 32 位 RISC-V CPU 上可能需要两个 32 位寄存器，但在 64 位 CPU 上只需要一个 64 位寄存器，这显示了 ABI 是如何根据硬件的原生字长量身定制的 [@problem_id:3664358]。

-   **[引用传递](@entry_id:753238)：** 如果结构体很大，复制它的开销会很大，并且会消耗太多宝贵的参数寄存器。在这种情况下，ABI 强制要求**通过引用**传递结构体。调用者在自己的内存中为结构体分配空间，然后传递一个简单的参数：一个指向该结构体内存位置的**指针**，而不是传递整个结构体。被调用者随后使用这个指针来访问原始数据。这就像是交出一把房间的钥匙，而不是试图把里面所有的家具都搬出来。

同样的逻辑也适用于函数需要*返回*一个大型结构体的情况。它对于像 `RAX` 这样的单个返回值寄存器来说太大了。解决方案是对[引用传递](@entry_id:753238)的巧妙反转，通常被称为**通过隐藏指针返回结构体** (`sret`) [@problem_id:3680384]。在调用之前，*调用者*在自己的栈上为返回值预留空间。然后它传递一个秘密的、隐式的第一个参数：一个指向这块空闲空间的指针。被调用者执行其工作，然后简单地将结果直接写入调用者提供的内存位置，而不是试图返回这个大型对象。

这揭示了与另一条 ABI 规则——**栈对齐**——之间一种微妙而绝佳的[交互作用](@entry_id:176776)。为了确保性能，ABI 通常要求在任何 `call` 指令之前，[栈指针](@entry_id:755333)必须对齐到 16 字节边界 [@problem_id:3664343] [@problem_id:3680384]。如果一个调用者需要为一个 24 字节的返回结构体预留空间，它不能简单地从[栈指针](@entry_id:755333)中减去 24，因为这很可能会破坏 16 字节对齐。它必须分配下一个不小于 24 的 16 的倍数，即 32 字节，这会留下 8 字节未使用的填充。这是一个完美的例子，说明了 ABI 内部不同、看似无关的规则是如何共同作用以维持一个有序高效的系统的。

### 寄存器规范：谁来清理？

我们已经确定寄存器是一种共享资源。这就提出了一个关键的规范问题：如果一个被调用者使用了某个寄存器，它是否有责任在返回前恢复该寄存器的原始值？答案将寄存器分为两个哲学阵营：**调用者保存**和**被调用者保存** [@problem_id:3644281]。

-   **调用者保存的寄存器：** 这些是“临时”或“易变”寄存器。被调用者可以自由地将它们用于任何目的，而无需保存其内容。如果*调用者*在这些寄存器中有一个重要的值，并且在调用后还需要它，那么调用者有责任在调用前将其保存（通常是到栈上），并在调用后恢复它。传递参数的寄存器（`RDI`、`RSI` 等）几乎总是调用者保存的。这个约定对于**叶函数**——即不调用任何其他函数的[简单函数](@entry_id:137521)——非常高效。叶函数可以免费获得一组临时寄存器来完成工作，而无需任何保存和恢复的开销。

-   **被调用者保存的寄存器：** 这些是“非易变”或“保留”寄存器。ABI 向调用者保证，这些寄存器中的值在[函数调用](@entry_id:753765)之后将与调用之前相同。这给**被调用者**带来了负担。如果被调用者需要使用一个被调用者保存的寄存器，它*必须*首先保存其原始值，并在返回前一丝不苟地恢复它。这对**非叶函数**来说是一大福音，特别是那些在循环内部调用其他函数的函数。它们可以将重要的、长生命周期的变量（如循环计数器或指针）保存在被调用者保存的寄存器中，并确信这些值在调用过程中会得以保留。

一个设计良好的 ABI 在两者之间达到了一个审慎的平衡。拥有太多被调用者保存的寄存器会给每个简单的叶函数带来保存/恢复的开销。拥有太多调用者保存的寄存器会迫使复杂函数在每次调用前后不断地保存和恢复其状态。典型的划分——较多的[调用者保存寄存器](@entry_id:747092)和较少的[被调用者保存寄存器](@entry_id:747091)——是一种精心调整的折衷，它针对真实世界程序的常见统计特性进行了优化 [@problem_id:3644281]。

### 契约的层次：当约定发生冲突时

ABI 的精妙之处在其规则以不那么显而易见的方式相互作用时最为明显，这揭示了其设计背后的深思熟虑。

一个引人入胜的例子是 x86_64 System V ABI 中的**红色区域 (red zone)** [@problem_id:3664335]。该规则规定，在当前[栈指针](@entry_id:755333)*下方*的 128 字节区域被保留给叶函数用作临时空间，而无需通过移动[栈指针](@entry_id:755333)来正式分配一个栈帧。这是一个为最简单的函数进行优化的“君子协定”。在[用户模式](@entry_id:756388)下，[操作系统](@entry_id:752937)遵守这个协定；如果发生硬件中断，[操作系统](@entry_id:752937)会确保它不会践踏红色区域。然而，这个协定并不延伸到操作系统内核本身。如果 CPU 已经在[内核模式](@entry_id:755664)下时发生中断，硬件可能会自动将状态信息直接推入该内存区域，从而破坏内[核函数](@entry_id:145324)存储在那里的任何内容。因此，红色区域绝佳地说明了 ABI 是一个分层契约，不同的规则和保证适用于系统的不同层面。

也许对 ABI 的终极考验是**可变参数函数**，例如 C 语言的 `printf`，它可以接受可变数量的参数 [@problem_id:3664384]。考虑一个可变参数函数 `F`，它在寄存器 `x0, x1, ...` 中接收其参数，然后需要调用另一个函数 `G`。为了调用 `G`，`F` 必须使用完全相同的寄存器（`x0, x1, ...`）来将参数传递*给* `G`。但是因为那些是调用者保存的寄存器，对 `G` 的调用将破坏传递给 `F` 的原始参数！ABI 提供了一个稳健的解决方案：在调用 `G` 之前，函数 `F` 必须将其所有潜在的传入参数寄存器保存到其自身栈上的一个连续块中。这种参数的“归位”确保了它们被保留下来并可以在以后访问，完美地展示了寄存器类别规则、调用者保存规范和栈管理是如何环环相扣，以支持函数间最复杂的会话模式。

