## 引言
在对性能不懈的追求中，最基本的原则之一是避免重复工作。编译器，作为软件优化领域的无名英雄，正是这一原则的大师。它们不知疲倦地分析我们的代码，寻找使其更快、更高效的机会。重复计算相同的表达式是常见的低效来源。但是，编译器如何能绝对确定过去计算的结果仍然有效并且可以重用呢？猜测是行不通的；一个错误的假设就可能导致灾难性的错误。

**[可用表达式分析](@entry_id:746601)**正是为了填补这一知识鸿沟而生。它是一种形式化的[数据流](@entry_id:748201)分析技术，为表达式的值何时可以安全重用提供了数学上的保证。它系统地跟踪信息在程序中的流动，以确定在任何给定点哪些表达式是“可用”的。本文将引导您深入了解这一强大的编译器方法。在第一部分**原理与机制**中，我们将剖析该分析的核心概念，包括表达式“可用”的含义、如何使用 GEN 和 KILL 集合传播信息，以及如何找到一个稳定的解。随后，**应用与跨学科联系**部分将探讨该分析如何促成[公共子表达式消除](@entry_id:747511)等关键优化，及其与更广泛的编译器生态系统乃至编程语言设计的关系。

## 原理与机制

想象你是一位才华横溢但极其刻板的助手，任务是优化一组指令。你注意到指令有时会要求你多次执行完全相同的计算，比如将 $a$ 和 $b$相加。你会想：“如果我刚做过这个计算，为什么不重用答案，而非要再算一遍呢？”这是一个极好又带点“懒惰”的聪明想法。但你刻板的本性带来了一个挑战：你如何能百分之百*确定*你保存的答案仍然有效？万一在你没注意的时候，$a$ 或 $b$ 的值变了怎么办？

这正是**[可用表达式分析](@entry_id:746601)**为编译器解答的核心问题。它是一种让优化器能够安全有效地“偷懒”的形式化方法。它从不猜测，只去证明。一个表达式在程序的某个点被认为是“可用”的，当且仅当编译器能以数学上的确定性证明，它的值已经被计算过，并且此后没有被破坏。这种分析完美地展示了简单的局部规则如何能引出关于程序行为的强大全局洞见。

### “可用”的真正含义是什么？

让我们来精确定义“可用”这个概念。我们说一个表达式，比如 $x+y$，在程序的特定点是**可用**的，当且仅当无论通过哪条执行路径到达该点，以下两个条件都得到满足：
1.  表达式 $x+y$ 在该路径上至少被计算过一次。
2.  自最近一次计算 $x+y$ 以来，$x$ 和 $y$ 均未被赋予新值。

这里的关键短语是“**每一条路径**”。这就是我们所说的**必须分析**（must-analysis）。一个表达式在*某些*路径甚至*大多数*路径上可用是不够的。只要存在一条可能的执行路径使得其值会失效，我们就必须丢弃保存的结果。保证必须是绝对的。可以把它想象成一个逻辑“与”：该属性必须在路径1上成立，并且在路径2上成立，并且在路径3上成立……

这个严格的要求解释了为什么**汇集运算符**（meet operator）——用于合并来自不同[控制流](@entry_id:273851)[路径信息](@entry_id:169683)的规则——是**集合交集**（$\cap$）。想象一下，在一个 `if-else` 块之后，两条路径汇合了。在汇合点之后保证可用的表达式集合，是在各自路径末端可用的表达式集合的*交集*。我们只保留两条路径都认可的事实 [@problem_id:3642715]。

### 记账工作：Gen、Kill 与信息流

为了自动化这一推理过程，我们将程序建模为一个**[控制流图](@entry_id:747825)（CFG）**，它是一张由基本块（直线型代码序列）和它们之间的有向边（跳转、分支）构成的地图。然后，我们跟踪信息从一个块移动到另一个块，这种技术被称为**[数据流](@entry_id:748201)分析**。因为我们是沿着程序向前跟踪过去计算的结果，所以这是一种**前向分析**（forward analysis）[@problem_id:3622909]。

对于每个基本块，我们确定两个关键的集合：

-   **$GEN[B]$**：由块 $B$ *生成*（generated）的表达式集合。如果一个表达式在块内被计算，并且其构成元素（操作数）之后在同一块内没有被改变，那么它就被生成了。例如，语句 $t := a+b$ 生成了表达式 $a+b$。

-   **$KILL[B]$**：由块 $B$ *杀死*（killed）的表达式集合。任何修改了某个变量的语句，都会杀死包含该变量的所有表达式。例如，赋值语句 $a := a+1$ 重新定义了 $a$，因此它会杀死 $a+b$、$a*c$ 以及任何其他涉及 $a$ 的表达式的可用性。

有了这些集合，我们就可以定义一个**[传递函数](@entry_id:273897)**（transfer function），它描述了当[控制流](@entry_id:273851)*穿过*一个块时，可用表达式集合是如何变化的。如果 $IN[B]$ 是在块 $B$ *入口*处可用的表达式集合，那么在其*出口*处可用的集合 $OUT[B]$ 为：

$$OUT[B] = GEN[B] \cup (IN[B] \setminus KILL[B])$$

这个逻辑简单而优雅：流出块的信息由它生成的新事实（$GEN[B]$），加上流入的旧事实（$IN[B]$）中未被它作废（$\setminus KILL[B]$）的部分组成。

考虑一个简单的程序流 [@problem_id:3622891]：$S_1: z := x+y$，后面跟着一个分支。其中一条路径上有 $S_3: x := x+1$。然后两条路径在 $S_4: w := x+y$ 之前[汇合](@entry_id:148680)。
- 在 $S_1$ 之后，$x+y$ 被生成并变为可用。
- 在经过 $S_3$ 的路径上，对 $x$ 的赋值杀死了 $x+y$。
- 在 $S_4$ 之前的[汇合](@entry_id:148680)点，表达式 $x+y$ 在一条入路径上可用，但在另一条上不可用。因为我们必须有保证，所以我们取交集：$\{\text{可用}\} \cap \{\text{不可用}\} = \{\text{不可用}\}$。编译器正确地得出结论，它不能重用旧值，必须在语句 $S_4$ 中重新计算 $x+y$。

这就引出了一个关于分析粒度的微妙但关键的点。当我们分析像 $t := (x+y) + (x+y)$ 这样的语句时，我们视该语句为原子操作。我们的程序点位于语句*之间*，而不是语句内部。因此，在源代码层面，这种分析无法得出第一个 $x+y$ 的结果可用于第二个的结论。为了发现这一点，编译器必须首先将代码降解为更细粒度的[中间表示](@entry_id:750746)，例如 `tmp := x+y; t := tmp + tmp;`，从而在两次计算之间创建一个新的程序点 [@problem_id:3622938]。

### 战争迷雾：处理指针与未知情况

现实世界的程序是复杂的。它们包含函数调用、指针操作以及其他可能隐藏副作用的结构。一个稳健的分析必须是保守的：当有疑问时，做最坏的打算。

[函数调用](@entry_id:753765)是一个黑箱。如果我们的代码计算了 $t := x+y$，然后调用了 `foo()`，那么 $x+y$ 之后还可用吗？在不知道 `foo()` 具体做什么的情况下，我们无从得知它是否会暗中改变 $x$ 或 $y$。最保守——也最安全——的方法是假设函数调用杀死了*所有*变量不是严格局部且外部无法访问的表达式的可用性 [@problem_id:3622904]。这是一个合理但略显悲观的策略。

通过更复杂的分析，我们可以做得更好。**[别名](@entry_id:146322)分析**（Alias analysis）试图确定一个指针可能指向哪些内存位置。
- 如果我们调用一个函数 `foo(p)`，其中包含像 `*p = 100;` 这样的写操作，并且我们知道在调用点，$p$ **必然别名**（must-alias）$x$（即它保证指向 $x$），那么我们就知道 $x$ 被重新定义了，$x+y$ 也被杀死了。
- 如果 $p$ **可能别名**（may-alias）$x$（它可能指向 $x$，也可能不指向），我们的“必须”分析会迫使我们采取保守策略。仅仅是 $x$ 可能被改变的可能性，就足以杀死 $x+y$ 的可用性。
- 只有当我们能证明 $p$ 与 $x$ 和 $y$ **无[别名](@entry_id:146322)**（no-alias）时，我们才能确定写操作 `*p = 100;` 不会影响我们表达式的可用性 [@problem_id:3622904]。

这种保守性原则延伸到任何编译器视野受阻的情况。对于一个通过指针 `*p` 的存储操作，如果[别名](@entry_id:146322)分析报告 $p$ 可能指向 $x$ 或 $z$，那么必须将其视为杀死了所有涉及 $x$ *和*所有涉及 $z$ 的表达式 [@problem_id:3622890]。内联汇编块也类似处理；编译器必须假设它会修改任何它被声明会接触的变量，从而杀死相关表达式的可用性 [@problem_id:3622926]。

### 宏大之舞：寻找稳定解

那么，这一切是如何协同工作的呢？尤其是在有循环的程序中，信息可能会回流。编译器会执行一个迭代分析，以找到一个**[不动点](@entry_id:156394)**（fixed point）——一种再次运行分析也不会产生任何新变化的稳定状态。

该算法的工作方式如下：
1.  **初始化**：程序入口点的可用表达式集合被初始化为[空集](@entry_id:261946) $\emptyset$，因为此时还没有任何计算发生。对于程序中的所有其他基本块，我们从一个乐观的假设开始：*所有*表达式都是可用的。这个初始状态是我们格（lattice）中的“顶”元素，即所有被追踪表达式的全集 [@problem_id:3642670]。
2.  **迭代**：我们反复访问基本块，应用[传递函数](@entry_id:273897)和汇集运算符。信息在[控制流图](@entry_id:747825)中传播。当我们发现一条路径杀死了某个表达式，我们便将其从可用集合中移除。因为我们开始时假设一切都可用，所以每次迭代后，可用表达式的集合只会缩小（或保持不变）。
3.  **收敛**：由于表达式的数量是有限的，这个从集合中移除表达式的过程最终必然会停止。系统将达到一个平衡状态，不再有变化发生。这就是[不动点](@entry_id:156394)，其结果——每个程序点的集合——代表了可证明正确的可用表达式集合 [@problem_id:3635654]。

初始化的选择至关重要。如果我们开始时假设什么都不可用（将所有集合初始化为 $\emptyset$），分析就会过于保守。因为我们的汇集运算符是交集，而对于任何集合 $S$ 都有 $S \cap \emptyset = \emptyset$，所以在[汇合](@entry_id:148680)点永远不会有任何表达式变为可用。通过从乐观的顶端开始，并向下迭代，我们允许可用性被“杀死”路径所“[证伪](@entry_id:260896)”，从而确保我们找到在所有路径上都真正、可验证地可用的最大表达式集合 [@problem_id:3657765]。

从这些简单的、局部应用的规则——$GEN$、$KILL$ 和交集——中，一个全局一致且正确的程序理解便浮现出来。这证明了形式化系统的力量：这样一个机械的、近乎乏味的记账过程，竟能使编译器执行巧妙而强大的优化，揭示出代码中信息流动的隐藏结构。

