## 引言
即时 (JIT) 编译是现代高性能软件的基石，它使得 Web 浏览器、[操作系统](@entry_id:752937)和虚拟机中的动态语言能够达到接近本机的速度。然而，这种能力也带来了深远的安全挑战。JIT 编译的核心在于必须将新代码写入内存，然后再执行它——这一系列操作直接与基本的安全原则“[写异或执行](@entry_id:756782)”(W^X) 相冲突，该原则禁止内存同时可写和可执行。这为希望理解这些复杂系统中性能与安全如何平衡的开发人员和安全专业人员造成了一个关键的知识鸿沟。

本文深入探讨了定义 JIT 安全性的精妙解决方案和错综复杂的权衡。您将深入理解让 JIT 编译器在现代[内存保护](@entry_id:751877)约束下安全运行的核心原理。讨论将从基本概念延伸至其实际后果，为这一关键的系统安全领域提供全面的概述。

第一章“原理与机制”将剖析“可写或可执行”的困境，解释安全 JIT 所执行的“权限之舞”。我们将探索 CPU 缓存的隐藏机制以及 TLB shootdown 等操作的必要性，还有减轻其性能开销的策略。随后的“应用与跨学科联系”一章将展示这些原理如何应用于不同领域，从 Web 浏览器中使用的双重映射技术，到 Linux 内核中 eBPF JIT 的严格验证，以及[虚拟化](@entry_id:756508)和[密码学](@entry_id:139166)旁道攻击带来的独特挑战。

## 原理与机制

即时 (JIT) 编译的核心在于一种优美但危险的二元性。为了做到“即时”，编译器必须动态创建新的机器码，将字节写入内存。但要让这些代码发挥作用，处理器必须能够执行这些字节。现代计算机系统的安全性取决于一个简单而有力的问题：一块内存应该是用于写入的地方，还是用于执行的地方？同时允许两者，就像把蓝图和炸药的钥匙放在同一个未上锁的抽屉里。如果攻击者找到一种方法向内存中写入数据，他们就可以简单地写入自己的恶意代码，然后欺骗系统运行它。这就是一场根本[性冲突](@entry_id:152298)的舞台，而其解决方案是现代系统安全的优雅支柱之一。

### “可写或可执行”的困境

想象一下，内存是一座由带编号的房屋组成的巨大城市。有些房屋是图书馆（只读），有些是作坊（可写），还有一些是指挥中心（可执行）。城市规划的安全基本法则是，作坊绝不能同时也是指挥中心。这个原则在计算世界中被称为**[写异或执行](@entry_id:756782)**（常写作 **W^X**），是现代[内存保护](@entry_id:751877)的基石。它由处理器硬件强制执行，硬件会为每一页内存（可以想象成一个城市街区）维护权限位：它是否可读 ($r$)、可写 ($w$) 和/或可执行 ($x$)？W^X 策略规定，对于任何给定的页面，权限 $w$ 和 $x$ 不能同时激活 [@problem_id:3658145]。

这给 JIT 编译器带来了直接的挑战。根据其本质，它需要执行两个 W^X 策略禁止共存的操作：它必须首先将新的机器码*写入*内存缓冲区（充当一个作坊），然后*执行*该代码（将作坊变成指挥中心）。我们如何才能将这一基本功能与我们不可妥协的安全规则相协调呢？答案不是打破规则，而是通过一系列精心编排的步骤来遵守它。

### 权限之舞：一种为安全设计的编排

一个安全的 JIT 编译器并不会试图鱼与熊掌兼得。相反，它与[操作系统](@entry_id:752937)进行一场两步“舞蹈”，随时间改变其内存区域的性质。这个过程是 JIT 功能安全地集成到从 Web 浏览器到操作系统内核等大型系统中的基石 [@problem_id:3658305]。

1.  **分配与写入：** JIT 首先向[操作系统](@entry_id:752937)请求一块内存。它特别要求这块内存**可写**但**不可执行**（`w=1`, `x=0`）。[操作系统](@entry_id:752937)批准这个请求，这块内存现在就是一个安全的“作坊”。然后 JIT 编译器开始工作，将字节流——即新的机器码指令——发射到这个缓冲区中。

2.  **密封与执行：** 代码完全生成后，JIT 执行关键的第二步。它向[操作系统](@entry_id:752937)发出另一个请求，使用像 `mprotect` 这样的系统调用：“请接收这个内存区域并更改其权限。使其**不可写**但**可执行**”（`w=0`, `x=1`）。[操作系统](@entry_id:752937)遵从请求，从而有效地“密封”了代码。作坊现在变成了指挥中心，其内容不可更改。

在这个序列的任何时刻，内存页面都不是同时可写和可执行的。JIT 编译器在[操作系统](@entry_id:752937)的帮助下，优雅地绕过了 W^X 限制。这个过程不仅仅是一个理论模型；它是各地高性能语言运行时所使用的标准、安全的工作流程 [@problem_id:3657050]。

但是，如果一个程序因意外或设计，试图在代码被密封*之前*跳转到它呢？作为最终执行者的 CPU 会检查页面的权限。它会看到 `x=0` 标志并拒绝获取指令。这种拒绝不是一个无声的失败；它会触发一个称为**保护错误**的警报，将控制权陷入（trap）[操作系统](@entry_id:752937)。然后，[操作系统](@entry_id:752937)处理程序可以决定该怎么做。如果这是合法的 JIT 工作流程的一部分（程序可能为此留下了标记），处理程序可以完成权限翻轉。如果不是，这将被视为安全违规， offending program is terminated [@problem_id:3666375]。

### 看不见的机制：缓存、幻影与呼喊

这场“权限之舞”看似简单，但深入其内部机制，就会发现一个惊人复杂的世界。我们到目前为止讲述的故事假设了一个单一、统一的内存视图。而现代[多核处理器](@entry_id:752266)内部的现实要复杂得多，那是一个由缓存构成的世界，其中保存着过去信息的幻影。

处理器的速度远超主内存，快到难以想象。为了弥合这种速度差距，每个处理器核心都有自己的一组小型、超快速的缓存。当[操作系统](@entry_id:752937)更改主内存中[页表](@entry_id:753080)条目（PTE）的权限位时，这仅仅是个开始。真正的挑战是确保系统中的每个核心都意识到这一变化。

其中最重要的缓存之一是**转换检测缓冲区 (Translation Lookaside Buffer, TLB)**。它是一个微小的缓存，存储了最近的虚拟地址到物理地址的转换*及其权限*。如果一个核心的 TLB 中有一个关于我们 JIT 缓冲区的条目，显示它是可写的，那么它会信任该缓存信息，即使主内存中“真实”的 PTE 已经被更改为不可写。这就造成了一个可怕的漏洞：另一个核心上的攻击者可以利用这个过时的 TLB 条目继续向 JIT 缓冲区写入，即使在代码本应已被密封之后 [@problem_id:3658183]。

为了防止这种情况，[操作系统](@entry_id:752937)必须执行 **TLB shootdown**。在更改 [PTE](@entry_id:753081) 之后，[操作系统](@entry_id:752937)会向所有其他核心发送一个**处理器间中断 (Inter-Processor Interrupt, IPI)**——一种电子“呼喊”。这个 IPI 命令它们：“使你们持有的关于此内存地址的任何 TLB 条目无效！”每个核心停止当前的工作，从其 TLB 中刷新过时的条目，然后发回确认。[操作系统](@entry_id:752937)必须等待所有确认后，才能认为权限更改是完整和安全的。这是一个重量级的操作，为修补代码的过程增加了显著的延迟 [@problem_id:3639228]。

类似的问题也存在于代码本身。JIT 使用数据写操作来写入指令，这会填充**[数据缓存](@entry_id:748188) (D-cache)**。但是当处理器去执行代码时，它是从**[指令缓存](@entry_id:750674) (I-cache)** 中获取。在许多体系结构上，这两个缓存并非由硬件保持一致。I-cache 完全有可能为一个刚刚被 JIT 写入的内存地址包含陈旧、过时的垃圾数据。在执行新代码之前，系统必须执行显式的**[指令缓存](@entry_id:750674)同步**，以确保处理器获取的是新鲜的指令，而不是过去的某些数据幻影 [@problem_id:3658145]。

### 实现高效安全 JIT 的策略

这套安全机制的开销——`mprotect` 系统调用、全局 TLB shootdown、缓存刷新——是不可忽视的。一个为它编译的每个微小函数都执行这整套舞蹈的幼稚 JIT 会慢到停滞。因此，JIT 设计的艺术在于找到聪明的策略来最小化这种开销，同时维护安全性。

最有效的策略之一是**批处理**。一个智能的 JIT 不会生成一个函数、密封它、再生成下一个、再密封它，如此往复，而是分配一个大的可写区域，用许多编译好的函数填充它，然后执行单个 `mprotect` 调用来一次性将整个区域翻转为可执行。这将一次 TLB shootdown 的高昂固定成本分摊到几十甚至几百个函数上，从而显著提高性能 [@problem_id:3657050]。

另一种方法完全避免修改代码页。JIT 不直接在调用点修补指令（一种用于像**[内联缓存](@entry_id:750659)**这样的[优化技术](@entry_id:635438)），而是可以将调用编译为一个通过指针进行的间接跳转。调用存根本身位于一个永久的、可执行的页面上。它读取的指针位于一个独立的可写数据页上。要重定向调用，JIT 只需修改数据指针。这避免了整个 `mprotect` 舞蹈，但可能会因分支预测性较差而带来其自身的性能损失 [@problem_id:3639228]。理解这些权衡是分析现实世界中动态语言运行时性能的关键，在这些运行时中，像[内联缓存](@entry_id:750659)这样的技术 sürekli olarak yamalanmaktadır [@problem_id:3646205]。

### 超越 W^X：分层防御

W^X 策略是一个强大的基础，但并非万能药。它可以防止攻击者在同一个地方*写入*和*执行*，但它不能阻止他们劫持控制流，以未经授权的方式跳转到*已存在的*、合法的可执行代码段。要构建一个真正健壮的系统，安全必须是分层的。

其中一层是**运行时代码签名**。在密封一页 JIT 编译的代码之前，运行时可以计算代码内容的加密哈希并进行[数字签名](@entry_id:269311)。稍后，在执行代码之前，可以验证此签名。这确保了正在运行的代码正是 JIT 意图生成的代码，期间没有被篡改。这增加了另一层完整性，尽管它也带来了必须在代码的生命周期内仔细分摊的计算开销 [@problem_id:3648559]。

一个更强大的防御措施是**[控制流完整性 (CFI)](@entry_id:747827)**。CFI 就像程序中每个间接跳转或调用处的保镖。它为该特定跳转维护一个有效目的地的“访客名单”。如果攻击者试图将跳转转移到不在名单上的地址，保镖就会阻止他们。对于 JIT 来说，挑战是动态的：它需要能够在运行时安全地将其新生成的函数添加到此访客名单中。这需要一个仔细的、原子的操作序列，以避免[竞争条件](@entry_id:177665)，即在函数的内存实际变为可执行之前就将其添加到列表中，这种错误可能导致程序崩溃 [@problemid:3657021]。

这些先进的防御措施与基本的 W^X 策略协同工作，创建一种深度防御策略。每一层都针对一个不同的潜在攻击向量，构建一个比任何单一防御都更具弹性的系统。这个执法机制的[光谱](@entry_id:185632)，从在程序运行前就拒绝坏程序的静态类型系统，到将运行时[代码生成](@entry_id:747434)与复杂插桩和[操作系统](@entry_id:752937)级保护相结合的 JIT 编译器，展示了现代软件安全的美丽而复杂的图景 [@problem_id:3678682]。

