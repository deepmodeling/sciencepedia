## 应用与跨学科联系

当我们初学编程时，我们认为函数调用是一种神奇的跳转。我们调用 `print("Hello, World!")`，然后计算机的机制不知何故地[合力](@entry_id:163825)让这些词出现在我们的屏幕上。我们被鼓励（有充分的理由）不必担心细节。但随着我们深入挖掘，我们发现这种“神奇的跳转”根本不是魔法。它是一场精心编排的舞蹈，由一套严格的规则所支配——一个被称为**[调用约定](@entry_id:753766)**或[应用程序二进制接口](@entry_id:746491)（ABI）的默契契约。

有人可能会认为这个契约是一个枯燥、技术性的事务，只有编写编译器的人才会感兴趣。事实远非如此。[调用约定](@entry_id:753766)是一条贯穿现代计算几乎每一层的线索。正是这一原则，使得我们的数字世界——尽管充斥着各种不同的编程语言、[操作系统](@entry_id:752937)和硬件——能够作为一个连贯的整体运作。它是一个美丽的例子，展示了一套简单、优雅的规则如何能从惊人的复杂性中创造出秩序。让我们追溯这条线索，看看它将我们引向何方。

### 编程界的巴别鱼：实现互操作

ABI 最直接、最实际的作用是解决一个与巴别塔一样古老的问题：如何让说不同语言的实体进行交流？在软件领域，这已是日常所需。一个用 Rust 编写高性能分析程序的数据科学家，可能需要使用一个用 C 语言编写的、久经考验的线性代数库。没有一个共同的契约，这是不可能的。

C ABI 充当了编程世界的*通用语*。当一个 Rust 程序员用 `extern "C"` 注解一个函数时，他们是在做出一个承诺：“在这一次对话中，我不会说 Rust 的方言；我将遵循 C 的通用约定。”这包括使用相同的寄存器传递参数，以相同的方式处理栈，以及以 C 兼容的格式布局数据结构 ([@problem_id:3678605])。有了这个协议，Rust 代码就可以无缝地调用 C 库，反之亦然，就好像它们是用同一种语言编写的一样。

然而，这个契约不仅关乎源语言，它关乎整个平台。想象一下你有两个 C++ 库。它们的源代码完全相同，但一个是在 Linux 上编译的，另一个是在 Windows 上编译的。它们能相互通信吗？令人惊讶的答案是不能。这是因为这些平台上的 C++ ABI 是不同的——Linux 上的 Itanium ABI 和 Windows 上的 Microsoft ABI 对于一些微妙但关键的事情有不同的规则，比如如何处理函数名（`name mangling`）或内存中对象的布局 ([@problem_synthesis:3678605])。它们说的是同一种 C++“语言”的不同方言。

对于像 Java 或 C# 这样的语言，这个问题变得更加突出，因为它们运行在像 Java [虚拟机](@entry_id:756518)（JVM）或公共语言运行时（CLR）这样的“托管运行时”中。这些运行时就像自成一体的宇宙，有自己内部的[内存布局](@entry_id:635809)和[函数调用](@entry_id:753765)规则。当一个 Java 程序需要调用一个本地 C 函数时，它不能直接这样做。它必须使用一个特殊的桥梁，称为[外部函数接口](@entry_id:749515)（FFI），如 Java 本地接口（JNI）或平台调用服务（P/Invoke）([@problem_id:3678605])。这个桥梁充当翻译器，一小段称为“垫片（shim）”的代码会煞费苦心地重新[排列](@entry_id:136432)数据（一个称为*封送*的过程），并将调用从运行时的内部约定适配到平台的本地 C ABI。这个适配器的存在，以及它有时带来的计算成本 ([@problem_id:3661417])，是两个世界遵循不同契约的直接后果。

### 游戏规则：约定如何塑造语言本身

ABI 不仅仅是语言必须遵守的外部约束；它还主动地塑造了语言特性的设计和实现方式。一种语言的能力往往反映了在底层[调用约定](@entry_id:753766)的框架内可以被优雅而高效地表达的内容。

考虑在多重继承场景中 C++ 虚函数调用的复杂性。当你通过一个指向次要基类的指针调用一个方法时，`this` 指针（指向对象的数据）可能需要被调整以指向完整对象的真正起始位置。ABI 精确地指定了哪个寄存器持有这个关键的 `this` 指针（例如，Windows x64 上的 `rcx`，Linux x64 上的 `rdi`）。编译器知道这个规则，会生成一些微小的、不可见的辅助函数，称为“thunk”，其唯一的工作就是在跳转到实际的方法实现之前，对寄存器执行这个算术调整 ([@problem_id:3664327])。[调用约定](@entry_id:753766)提供了编排这场复杂舞蹈的[固定点](@entry_id:156394)。

或者想一想[函数式编程](@entry_id:636331)中的一个强大特性：*[闭包](@entry_id:148169)*。闭包是一个“捕获”其环境的函数，它携带了从其创建作用域中所需的变量。为了实现这一点，编译器不仅必须[传递函数](@entry_id:273897)的显式参数，还必须传递一个指向这个被捕获环境的隐藏指针。它应该如何传递这个额外的信息呢？可以把它放在栈上传递，但这可能很慢。也可以修改每个函数签名以接受一个额外的指针，但这会破坏与 C 的兼容性。一些编译器采用了一种特别优雅的解决方案，即保留一个特定的寄存器，专门用于传递这个环境指针。这既保持了调用的速度，又不会干扰可见参数的标准 ABI，从而保留了[互操作性](@entry_id:750761)并启用了尾调用等关键优化 ([@problem_id:3627900])。

ABI 契约的严格性也是安全性的一个来源。它定义了什么是合法的，什么是不合法的。假设一个基类定义了一个接受两个参数的虚方法。然后一个程序员在派生类中重写了它，但将签名更改为*可变参数*（接受可变数量的参数）。在一个调用点，编译器看到一个指向基类的指针，并生成一个标准双参数调用的代码。但在运行时，动态派发可能会选择重写的可变参数函数。此时，被调用者期望一个带有为其命名参数准备的特殊“home slots”的[调用约定](@entry_id:753766)，而调用者从未准备过这些。这种不匹配——这种对契约的违反——可能导致被调用者从栈中读取垃圾数据，从而导致可怕的“[未定义行为](@entry_id:756299)” ([@problem_id:3639521])。

### 系统范围的契约：与内核和硬件的协定

[调用约定](@entry_id:753766)的影响远远超出了单个应用程序的边界。它是一个系统范围的契约，即使是操作系统内核也必须遵守。当你的程序需要打开一个文件或通过网络发送数据时，它会执行一个特殊的 `trap` 指令来进行“[系统调用](@entry_id:755772)”，将控制权交给内核。从用户程序的角度来看，这必须表现为一个无缝的[函数调用](@entry_id:753765)。

这意味着内核，尽管运行在更高的[特权级别](@entry_id:753757)，也必须像一个行为良好的“被调用者”一样行事。ABI 将处理器的寄存器划分为两组：`caller-saved`（调用者保存）和 `callee-saved`（被调用者保存）。被调用者可以随意涂写调用者保存的寄存器，但有义务保留[被调用者保存寄存器](@entry_id:747091)中的值。如果操作系统内核在其复杂的内部操作中，修改了一个被调用者保存的寄存器而没有先保存和恢复它，那么它在返回时就会破坏用户程序的状态 ([@problem_id:3640447])。这个契约是如此基础，以至于程序员会设计特殊的测试工具，使用底层汇编指令在寄存器中放置哨兵值，进行[系统调用](@entry_id:755772)，然后验证被调用者保存的寄存器是否保持不变，以确保内核履行了它的协定 ([@problem_id:3634643], [@problem_id:3640447], [@problem_id:3680367])。

这个与硬件的协定也在塑造移动和[高性能计算](@entry_id:169980)的未来。许多现代处理器是异构的，混合了强大的“big”核和节能的“LITTLE”核。这些核心可能实现相同的指令集，但拥有不同数量的可用寄存器。为了让一个运行中的任务能够从大核无缝迁移到小核，它们都必须同意一个统一的 ABI，该 ABI 只使用最受限核心上可用的寄存器——即它们能力的交集。在这个统一 ABI 中指定多少寄存器为 `callee-saved` 对性能有直接影响。每次任务迁移时，这些[被调用者保存寄存器](@entry_id:747091)的状态都必须保存到内存并在新核心上恢复，而迁移的成本与 ABI 契约要求保留的寄存器数量成正比 ([@problem_id:3669597])。

### 未来：作为安全基础的 ABI

也许[调用约定](@entry_id:753766)最令人兴奋的前沿在于它们有潜力构建从根本上更安全的计算机系统。几十年来，软件一直受到像[缓冲区溢出](@entry_id:747009)这样的[内存安全](@entry_id:751881)漏洞的困扰。我们一直试图在软件中修补这些问题，但如果硬件和 ABI 能够协同工作，从设计上消除它们呢？

这就是像 CHERI 这样的*基于能力（capability）的体系结构*所承诺的。在这样的系统中，原始的内存指针被“能力（capability）”所取代——这是一种不可伪造的令牌，它将内存地址与边界和权限捆绑在一起，全部由硬件强制执行。在这种世界里，[调用约定](@entry_id:753766)成为一个强大的安全工具。当调用一个只需要从一个 100 字节缓冲区读取的函数时，调用者传递的不是一个简单的指针；它派生出一个新的能力，精确地限制在那 100 字节，并且 `write` 权限位被关闭。如果被调用者有 bug 并试图读取第 101 字节或写入第 50 字节，硬件本身会立即捕获这个违规行为 ([@problem_id:3650311])。

此外，ABI 可以保护程序的[控制流](@entry_id:273851)。返回地址，在传统系统中只是栈上一个易受攻击的数字，可以被一个密封的、不透明的能力所取代。被调用者被给予这个密封的令牌，但它不能检查或修改它。只有特殊的 `return` 指令才能使用它来安全地将控制权交还给调用者。[调用约定](@entry_id:753766)中的这一单一改变，在硬件的支持下，击败了整类常见的网络攻击 ([@problem_id:3650311])。

从允许不同语言合作，到促成优雅语言特性的设计，再到强制用户程序与[操作系统内核](@entry_id:752950)之间的协定，最后到为硬件强制安全打造新的基础——[函数调用](@entry_id:753765)约定远不止是一个单纯的技术细节。它是计算机科学中伟大的统一概念之一，是一个美丽的例证，说明一个简单的局部契约，在被普遍遵守时，如何产生一个健壮、强大且可互操作的全球系统。它是我们整个数字世界随之起舞的无声而稳定的节奏。