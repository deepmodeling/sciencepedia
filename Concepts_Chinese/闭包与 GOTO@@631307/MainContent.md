## 引言
计算机如何理解语言的结构？答案不在于蛮力，而在于一种优雅的计算过程，该过程能够将抽象的语法规则映射到一台确定性机器上。这个过程的核心，也是现代[语法分析](@entry_id:267960)理论的中心，是两个基本操作：**closure** 和 **goto**。这些概念为构建自动机——即分析器的“大脑”——提供了逻辑引擎，使其能够驾驭语法的复杂性，识别有效句子，并以数学般的精确度诊断结构性缺陷。本文旨在解决如何从一组可能存在[歧义](@entry_id:276744)的规则中创建这样一个确定性分析器。

在接下来的章节中，我们将踏上一段理解这一强大机制的旅程。第一章“原理与机制”将解构 `closure` 和 `goto` 操作，展示它们如何协同作用于 `LR(0)` 项目，从而系统地构建一个完整的自动机。随后的“应用与跨学科联系”一章将揭示，这个自动机不仅是一个分析工具，更是一个供语言设计者使用的深刻诊断设备，也是一个用于理解远超计算机科学领域的结构的多功能模型。

## 原理与机制

要理解计算机如何领会一门语言——无论是编程语言还是简化的人类语言——我们必须构建一台机器。它不是由齿轮和杠杆构成，而是由逻辑和状态构成，能够遵循我们提供的语法规则。这台机器，即自动机，需要一个能够跟踪其在句子中所处位置以及预期接下来会看到什么的“大脑”。支撑这座“心智大厦”的双柱是两个优雅而强大的操作：**closure** 和 **goto**。让我们来探究这些简单的思想如何催生出一台能够真正理解结构的机器。

### 假设的剖析：LR(0) 项目

想象一下阅读一个句子。在任何时刻，你都清楚已经读了什么，以及接下来可能出现何种语法结构。计算机分析器需要一种形式化的方式来表示这种感知状态。这就是 **LR(0) 项目** 的作用。

一个 LR(0) 项目就是一个语法产生式，在右侧某处放置了一个点 `•`。对于像 $E \to E + T$ 这样的规则，我们可以有几个项目：
- `[E → • E + T]`：“我还没看到任何东西，但我希望能找到一个完整的表达式 `E + T`。”
- `[E → E • + T]`：“我刚刚成功识别了一个 `E`，现在我期望看到一个 `+` 符号，后面跟着一个 `T`。”
- `[E → E + • T]`：“我看到了一个 `E` 和一个 `+`，现在我正在寻找一个 `T`。”
- `[E → E + T •]`：“我找到了整个序列 `E + T`。我的假设完成了。”

这个点是我们语法之旅中的“你在此处”标记。这些项目的一个集合代表了分析器在某一时刻完整的“心智状态”——即它当前正在考虑的所有语法可能性的集合。

### 预期的艺术：`closure` 操作

仅有像 `[E → • E + T]` 这样的假设是不够的。如果我们期望看到一个 `E`，就必须为 `E` 实际的*样子*做好准备。**closure** 操作就是分析器程序化的预期行为。它通过添加所有由已有假设所引申出的新假设来丰富当前的心智状态。

规则很简单：如果一个状态包含一个点在非终结符之前的项目，例如 `[A → α • B β]`，那么我们必须将 `B` 的所有产生式对应的项目（点在最开始的位置）加入到该状态中。例如，如果 `B` 可以由 `γ` 或 `δ` 构成（即产生式为 $B \to \gamma$ 和 $B \to \delta$），我们就把 `[B → • γ]` 和 `[B → • δ]` 加入我们的假设集合。

这个过程是递归的，能够揭示出人意料的深层联系。考虑一个具有一连串产生式的文法，如 `A → B`、`B → C` 和 `C → ε`（其中 `ε` 是空字符串）。如果我们的分析器处于一个期望看到 `A` 的状态，`closure` 操作就会启动。期望 `A` 意味着我们可能实际上是在期望 `B`。期望 `B` 又意味着我们可能是在期望 `C`。而由于 `C` 可以是空的，我们可能无需消耗任何输入就能找到我们所寻找的东西！`closure` 操作会自动展开这整个可能性链条，将关于 `A`、`B` 和 `C` 的项目添加到一个单一、全面的状态中 [@problem_id:3655391]。这种对单一规则的简单、重复应用，使得机器无需任何特殊指令就能处理复杂、嵌套甚至不可见的语法结构。

### 进步的飞跃：`goto` 函数

如果说 `closure` 是思考的行为，那么 **goto** 就是执行的行为。`goto` 函数描述了当分析器成功识别输入中的一个符号时，其心智状态如何变化。`goto(I, X)` 回答了这样一个问题：“如果我处于状态 `I` 并且看到了符号 `X`，我的新心智状态是什么？”

其机制非常直观。
1.  首先，我们在当前状态 `I` 中找出所有正在等待符号 `X` 的假设。这些都是形如 `[A → α • X β]` 的项目。
2.  我们将这些项目收集起来，并将每个项目中的点越过 `X`，从而创建一组新的项目，如 `[A → α X • β]`。这个新集合被称为下一个状态的**核心**。它代表了我们取得的核心进展。
3.  最后，我们对这个核心取 `closure`。为什么？因为我们已经将点向前移动，到达了一个新位置 (`• β`)，所以我们必须再次预期 `β` 可能以何种方式开始。

这种 `核心 + [闭包](@entry_id:148169)` 的机制是 LR 分析的基石。从一个状态到下一个状态的转换仅由核心驱动——即那些被输入符号直接满足的项目。在原始状态中由[闭包](@entry_id:148169)添加的项目仅用于内部记账；它们不会驱动一个它们并未明确寻找的符号的 `goto` 转换。这确保了过程的高效性和逻辑性 [@problem_id:3627123]。根据其定义，对于任何状态 `I` 和任何符号 `X`，`goto(I, X)` 函数恰好产生一个唯一确定的下一状态。机器永远不会对接下来去哪里感到困惑 [@problem_id:3655311]。

如果我们处于某个状态，而分析器读入了一个其任何活动假设都*不*期望的符号，会发生什么？例如，如果状态 `I` 中没有任何项目形如 `[...→...• a...]`，那么 `goto(I, a)` 是什么？在这种情况下，下一个状态的核心是空的。空[集的闭包](@entry_id:143367)仍然是[空集](@entry_id:261946)。这个空状态是我们机器通用的“错误”信号——一个无法恢复的死胡同。这是分析器在说：“我完全不知道发生了什么。” [@problem_id:3655687]

### 组建心智：构建自动机

有了 `closure` 和 `goto`，我们现在可以组装分析器的完整“大脑”了。我们从一个单一的初始状态开始，这个状态由增广开始规则 `[S' → • S]` 的闭包生成。然后，我们对每个可能的语法符号系统地应用 `goto` 函数来发现新状态。我们对发现的每个新状态重复此过程，在它们之间创建转换。

因为可能的项目数量（以及因此可能的项目集数量）是有限的，所以这个过程保证会终止 [@problem_id:3655310]。当它完成时，我们就得到了分析器心智的完整地图：一个**确定性有限自动机 (DFA)**。每个状态都是一个 LR(0) 项目集，每个转换都是一个 `goto` 路径。

这个最终生成的地图精美地反映了文法本身的结构。对于具有像 $S \to aS$ 这样的递归规则的文法，自动机构建过程自然会产生一个循环。例如，从某个状态出发，对 `a` 的 `goto` 操作可能会导向一个新状态，而这个新状态在另一次对 `a` 的 `goto` 操作后又会回到自身，完美地捕捉了规则的重[复性](@entry_id:162752) [@problem_id:3655392] [@problem_id:3626886]。自动机成为了语言抽象规则的动态、可视化的表示。

### 神谕的启示：机器告诉我们什么

构建这个自动机不仅仅是一项机械操作；它是一种深刻的发现行为。完成的机器就像一个神谕，揭示了我们文法最深层的属性。有时，它的启示会令人不安。

考虑一个典型算术表达式文法的自动机中的一个状态。我们可能会发现这个状态包含两个有趣的项目：
- `[E → T •]`
- `[T → T • * F]`

第一个项目的点在末尾。它是一个已完成的假设。机器在说：“我刚刚看到了一个 `T`，它可能构成一个完整的 `E`。也许我应该宣布这部分分析已经完成。” 这对应于一个**规约** (reduce) 操作。

第二个项目的点在一个 `*` 前面。它是一个进行中的假设。机器在说：“我刚刚看到了一个 `T`，但如果下一个符号是 `*`，我应该消耗它并继续分析。” 这对应于一个**移入** (shift) 操作。

冲突就在于此。在这个状态下，当看到一个 `*` 时，机器应该移入还是规约？它收到了两个相互矛盾的指令。这是一个**移入-规约冲突**，我们的 `LR(0)` 机器以其优雅的简洁性，找到了文法所允许的一个歧义点 [@problem_id:3654995]。这不是机器的失败，而是它最伟大的胜利。它诊断出了一个结构性的复杂问题，这个问题需要更强大的分析策略来解决，例如向前看一个符号（就像 `LR(1)` 分析器所做的那样）。

`closure` 和 `goto` 机制的美妙之处就在于这种统一性。两个简单、确定性的规则，在穷尽应用时，会生成一个语言结构的完整地图。这张地图不仅能引导分析器穿过一个有效的句子，还能清晰地照亮歧义和复杂性存在的精确位置，将抽象的语法规则变成一个具体、可导航的景观。

