## 引言
在[数字电子学](@entry_id:269079)的世界里，对无需完全重新设计硬件即可适应新任务的电路的需求至关重要。为每个逻辑问题构建一个独特的、定制设计的电路既耗时又昂贵，在逻辑思想与其物理实现之间造成了巨大的知识鸿沟。[可编程逻辑阵列](@entry_id:168853) (PLA) 作为一种优雅的解决方案应运而生，为数字逻辑提供了一块通用、可编程的“画布”。本文深入探讨 PLA 的核心，为理解这一强大组件提供基础。首先，在“原理与机制”部分，我们将揭示支撑所有数字逻辑的通用“[积之和](@entry_id:266697)”配方，并了解 PLA 的双平面架构如何巧妙地体现了它。随后，在“应用与跨学科联系”部分，我们将探讨如何应用这一基本结构来构建从简单[算术电路](@entry_id:274364)到 CPU 和网络设备核心的复杂控制逻辑的一切。

## 原理与机制

如何制造一种芯片，可以被“教导”去执行几乎任何逻辑任务？想象一台用于[数字逻辑](@entry_id:178743)的通用机器。你无需为每个新问题从零开始构建新电路；你只需向这台机器描述问题，它就会自行配置以解决问题。这就是[可编程逻辑](@entry_id:164033)的前景，而[可编程逻辑阵列](@entry_id:168853) (PLA) 正是这一思想最优雅和最基本的体现之一。但要欣赏其设计，我们必须先问一个更基本的问题：逻辑本身是否存在一个通用的“配方”？

### 逻辑的通用配方

值得注意的是，答案是肯定的。任何逻辑陈述，无论多么复杂，都可以由一个简单的[标准化](@entry_id:637219)配方构建而成。想一想构建一个陈述，比如“如果门是开着的并且系统已布防，或者如果火灾传感器被触发，警报就应该响起。”这种句子结构——一系列用“或”连接的“与”条件——不仅仅是我们语言的一个特征；它也位于数字设计的核心。

在布尔代数的语言中，这被称为**[积之和](@entry_id:266697) (Sum-of-Products, SOP)**形式。每个“与”子句都是一个**乘积项**，我们在其中组合我们的输入（如 `door_open` 或 `system_armed`）或它们的反相。最终的“或”组合就是**和**。例如，一个简单的函数可能是 $F = (A \text{ and not } B) \text{ or } (\text{not } A \text{ and } B)$，在布尔表示法中是 $F = A\overline{B} + \overline{A}B$。事实证明，*任何*[布尔函数](@entry_id:276668)，从控制你微波炉的函数到 CPU 指令译码器的一部分，都可以用这种 SOP 形式表示。

这为我们提供了一个强大的蓝图。如果我们能构建一个设备，它能 (1) 从一组输入中创建我们想要的任何乘积项，并且 (2) 将这些乘积项的任意组合相加，那么我们就构建出了我们的通用逻辑机器。这正是 PLA 所做的。

### 逻辑阵列的剖析：双平面

PLA 的架构是“积之和”配方的直接物理体现。它由两个独特的可编程阶段组成：**“与”平面**和**“或”平面**。

想象一个网格。“与”平面的工作是创建我们的乘积项。为此，它接收所有外部输入，我们称之为 $A, B, C, \dots$，并立即生成它们的反相 $\overline{A}, \overline{B}, \overline{C}, \dots$。这些输入及其反相，统称为**字面量**，构成了我们网格的列。网格的行是“乘积项线”，每一条都在等待被定义。在每个字面量列和乘积项行的[交叉点](@entry_id:147634)上，都有一个**可编程熔丝**。要创建一个像 $\overline{A}B\overline{C}$ 这样的乘积项，我们只需编程这些熔丝，将 $\overline{A}$、$B$ 和 $\overline{C}$ 列连接到特定的乘积项行。该行上的所有其他熔丝都保持断开。通过对不同行的编程，我们可以生成一整套自定义的乘积项。

然后，这些乘积项流入第二个阶段，即**“或”平面**。这是另一个可编程网格。在这里，列是来自“与”平面的乘积项线，行对应于芯片的最终输出，比如 $F_1, F_2, \dots$。同样，可编程熔丝位于每个[交叉点](@entry_id:147634)。如果我们想创建函数 $F_1 = P_1 + P_3$，其中 $P_1$ 和 $P_3$ 是在“与”平面中生成的乘积项，我们只需编程熔丝，将 $P_1$ 和 $P_3$ 列连接到 $F_1$ 行。

这种两级结构——一个可编程的“与”平面后跟一个可编程的“或”平面——是 PLA 的决定性特征 [@problem_id:1955155]。它提供了完全的灵活性：任何输入的组合都可以形成一个乘积项，任何乘积项的组合都可以形成一个输出。

### 灵活性的代价：熔丝的海洋

这种灵活性并非抽象的；它是物理的，我们可以计算它。每一个可以建立或断开连接的点都是一个可编程熔丝。这些熔丝的总数告诉我们设备的原始容量。让我们考虑一个具有 $N$ 个输入、能生成 $P$ 个乘积项和有 $M$ 个输出的 PLA。

在“与”平面中，$P$ 个乘积项线中的每一条都必须可以选择连接到 $N$ 个输入中的任意一个*或*它们的 $N$ 个反相。对于每个乘积项，这就有 $2N$ 个可能的连接。因此，“与”平面中的熔丝总数为 $P \times 2N$。

在“或”平面中，$M$ 个最终输出中的每一个都必须可以选择连接到我们刚刚创建的 $P$ 个乘积项中的任意一个。这又给了我们 $M \times P$ 个熔丝。

所以，PLA 的总编程容量由以下总和给出：$P \times 2N + P \times M$，或者更简洁地表示为 $P(2N + M)$ [@problem_id:1955138] [@problem_id:1954881]。对于一个有 5 个输入、12 个乘积项和 4 个输出的中等设备，这相当于 $12 \times (2 \times 5 + 4) = 168$ 个熔丝 [@problem_id:1955138]。对于更复杂的设计，这个数字可以迅速增长到数千个，这片名副其实的可编程点海洋赋予了 PLA 强大的力量 [@problem_id:1955190]。

### 效率的艺术：共享乘积项

然而，PLA 架构真正的天才之处不仅在于其原始的灵活性，还在于其*效率*。因为任何乘积项都可以被路由到任何输出，所以单个乘积项可以在多个函数之间共享。这正是设计过程成为一门艺术的地方。

假设我们需要实现三个函数来控制一组执行器 [@problem_id:1955144]。经过分析，我们发现它们的最小化形式是：
$F_1 = \overline{A}\overline{C}D + ABD$
$F_2 = \overline{A}\overline{C}D + A\overline{B}D$
$F_3 = ABD + A\overline{B}D$

一种天真的方法是按出现顺序生成所有独立的乘积项：$\overline{A}\overline{C}D$（用于 $F_1$ 和 $F_2$）、$ABD$（用于 $F_1$ 和 $F_3$）以及 $A\overline{B}D$（用于 $F_2$ 和 $F_3$）。注意到重叠了吗！我们不需要生成六个乘积项。我们只需要编程“与”平面来创建三个独立的项：
$P_1 = \overline{A}\overline{C}D$
$P_2 = ABD$
$P_3 = A\overline{B}D$

然后，在“或”平面中，我们只需根据需要将它们“连接”起来：
$F_1 = P_1 + P_2$
$F_2 = P_1 + P_3$
$F_3 = P_2 + P_3$

这种优雅的共享将“与”平面所需的资源减少了一半。一个好的 PLA 设计的目标是最小化*所有*函数中独立乘积项的总数，而不仅仅是孤立地最小化每个函数 [@problem_id:1954926] [@problem_id:1954858]。这使得 PLA 成为以紧凑高效的方式实现逻辑相关函数的强大工具。

### 工程师的巧计：输出反相器

PLA 是一台 SOP 机器，但如果一个函数用另一种**[和之积](@entry_id:271134) (Product-of-Sums, POS)** 形式表示要简单得多，比如 $F = (A+B+C)(\overline{A} + \overline{C} + \overline{D})$，该怎么办？将其展开为 SOP 形式可能会很麻烦，并需要许多乘积项。在这里，设计师们利用了 PLD 中经常包含的一个特性，施展了一个巧妙的技巧：**可编程输出反相器**。

我们不必尝试实现 $F$ 的复杂 SOP 形式，而是可以实现它的补函数 $F'$，然后将结果翻转。根据德摩根定律，一个 POS 表达式的补函数会变成一个漂亮、干净的 SOP 表达式：
$F' = [(A+B+C)(\overline{A} + \overline{C} + \overline{D})]'\\
F' = (A+B+C)' + (\overline{A} + \overline{C} + \overline{D})'\\
F' = \overline{A}\overline{B}\overline{C} + ACD$

这个新函数 $F'$ 是一种简单的 SOP 形式，PLA 可以轻松生成。我们编程“与-或”平面以产生 $\overline{A}\overline{B}\overline{C} + ACD$，然后我们激活该输出上的[可编程反相器](@entry_id:176745)。最终结果是 $(F')' = F$，正是我们想要的，但实现它所用的资源要少得多 [@problem_id:1954897]。这是一个绝佳的例子，说明了一点逻辑上的“柔术”如何能让硬件为我们所用。

### 全家福：将 PLA 置于上下文中

PLA 的设计原则——可编程的“与”平面，可编程的“或”平面——是如此基本，以至于我们可以通过观察其亲缘器件在这一维度上的差异来理解它们。

*   **[只读存储器](@entry_id:175074) (ROM):** ROM 也可以实现任何逻辑函数。它可以被看作是拥有一个**固定的“与”平面**和一个**可编程的“或”平面**。它的“与”平面是一个完整的译码器，为其输入生成*每一个可能的最小项*（全部 $2^N$ 个）。然后编程“或”平面以选择每个输出需要哪些[最小项](@entry_id:178262)。这是一种暴力方法：全面，但常常效率极低，因为它会生成无数未被使用的乘积项 [@problem_id:1956870]。

*   **[可编程阵列逻辑](@entry_id:172815) (PAL):** PAL 是 PLA 最亲近的“兄弟”。它具有一个**可编程的“与”平面**，就像 PLA 一样，但有一个**固定的“或”平面**。这意味着，虽然你可以创建自定义的乘积项，但每个输出的“或”门都硬连线到一组特定的、有限的乘积项线上。你无法像在 PLA 中那样自由地共享项 [@problem_id:1955155]。

这给了我们一个可编程性的谱系：
- **ROM**: 固定的“与”平面，可编程的“或”平面
- **PAL**: 可编程的“与”平面，固定的“或”平面
- **PLA**: 可编程的“与”平面，可编程的“或”平面

因此，PLA 似乎是三者中最灵活、最复杂的。那么，为什么历史上更简单的 PAL 架构会变得远比它流行呢？答案在于物理学和经济学的残酷现实。

PLA 中两级完全可编程的互连形成了一个密集的潜在连接网络。这些“熔丝”中的每一个，无论是否使用，都会给电路增加一点微小的[寄生电容](@entry_id:270891)。当你有成千上万个这样的熔丝时，总电容就变得相当可观。迫使信号驱动这个大的容性负载，就像试图在游泳池里冲刺一样——需要时间。这使得 PLA 在本质上比它们的 PAL 对手慢 [@problem_id:1955168]。PAL 的固定“或”平面，以其简单、直接的硬连线连接，在电气上更“轻”，因此速度快得多。它的制造成本也更低。对于绝大多数实际应用来说，PAL 结合了“足够好”的灵活性、更高的速度和更低的成本，成为了制胜的法宝。

因此，PLA 的故事不仅仅是一个优雅架构的故事，也是一堂关于工程本身的课。它揭示了抽象逻辑与物理电路之间的美妙统一、优化的艺术，以及理想的灵活性与现实世界性能之间持续存在的实际权衡。

