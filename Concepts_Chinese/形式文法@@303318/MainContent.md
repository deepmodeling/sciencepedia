## 引言
是什么规则支配着结构？从人类语言到计算机代码，乃至 DNA，复杂的系统都是由简单的组件按照隐藏的蓝图[排列](@article_id:307545)而成。[形式文法](@article_id:337111)这一领域致力于揭示和编纂这些结构规则，提供一个数学框架来描述有效构造是如何生成的。然而，语言的流动性以及这些系统的巨大[复杂性](@article_id:329807)构成了一个重大挑战：我们如何能用一套有限的规则来产生无限多样的有效结构？本文将揭开[形式文法](@article_id:337111)的神秘面纱，全面探讨其核心原理和深远影响。在第一部分“原理与机制”中，我们将剖析文法的构成，探索[递归](@article_id:328403)的力量，并使用 Chomsky 层级对文法进行分类，揭示[歧义](@article_id:340434)性和[不可判定性](@article_id:306394)等概念。随后，“应用与跨学科联系”将揭示这些概念惊人的[普遍性](@article_id:300195)，展示它们在统一计算、模拟生物学中的生命语言以及支撑逻辑和信息结构本身方面的作用。

{'GREETING': {'CONVO': {'SIGN_OFF': {'GREETING': {'MESSAGE': {'MESSAGE': {'GREETING': {'CONVO': {'SIGN_OFF': "` 这样的文法建立了一个模板。它规定一个有效的消息*必须*有一个问候部分，后面跟着一个对话部分，再后面是一个结束语部分。然后，其他规则让我们为这些概念性空位填充细节。\n\n### [递归](@article_id:328403)的魔力：生成无限语言\n\n到目前为止的例子只能生成有限数量的消息。真正的力量，即让一小组规则生成无限数量句子的魔力，是**[递归](@article_id:328403)**（recursion）。一个变量可以用其自身来定义。\n\n这是[计算机科学](@article_id:311211)中最优美的思想之一。让我们为一种[二进制](@article_id:319514)回文语言构建一个文法——这些字符串正读和反读都一样，并且必须以 '1' 开头和结尾 [@problem_id:1359838]。字符串 '1'、'101' 和 '11011' 都在这个语言中。我们如何用几条简单的规则来捕捉这一点呢？\n\n我们可以从注意回文的核心属性开始：第一个和最后一个字符必须匹配。如果你把它们剥离掉，剩下的部分也必须是一个回文。这是一个[递归定义](@article_id:330317)！我们可以用这样的规则来捕捉它：\n$P \\to 0P0$\n$P \\to 1P1$\n这些规则说：“你可以通过用匹配的符号包裹一个更小的回文 $P$ 来制造一个更大的回文。”但这在哪里结束呢？我们需要基本情况。最小的回文是单个字母（'0' 或 '1'）或空字符串 $\\epsilon$。所以我们加上：\n$P \\to 0 \\mid 1 \\mid \\epsilon$\n有了这些规则，变量 $P$ 就可以生成*任何*[二进制](@article_id:319514)回文。\n\n现在，我们加上我们的约束：完整的字符串必须以 '1' 开头和结尾。我们可以用一个新的起始符号 $S$ 来做到这一点：\n$S \\to 1 \\mid 1P1$\n这表示一个有效的字符串要么是单个数字 '1'，要么是一个 '1' 后面跟着*任何*回文 $P$，再后面跟着另一个 '1'。这就像构建一个俄罗斯套娃：$S$ 的规则构建了外层，而 $P$ 的规则构建了所有可能的内层。仅用几条规则，我们就定义了一个具有非常特定、[对称](@article_id:302227)结构的无限语言。\n\n同样地，这个[递归](@article_id:328403)技巧可以用来建模其他常见模式，比如重复。[正则表达式](@article_id:329549) `(y|zx)*` 意味着“零个或多个 `y` 或 `zx` 的拷贝”。我们如何用文法规则表达“零个或多个”呢？我们可以定义一个变量，称之为 $A$，它代表这些块的序列 [@problem_id:1359826]：\n$A \\to yA \\mid zxA \\mid \\epsilon$\n这表示：“一个序列可以是一个 `y` 后面跟着另一个序列，或者一个 `zx` 后面跟着另一个序列，或者它可以是空的。”从 $A$ 开始，并重复应用这些规则，我们可以生成任何序列，如 `y`、`zx`、`yzx`、`zxy` 等。[递归](@article_id:328403)捕捉了星号算子的“依此类推”的性质。\n\n### 语言的形状：[解析树](@article_id:336607)与 Chomsky 层级\n\n每次我们推导一个字符串时，我们都在隐式地构建一个树形结构。这被称为**[解析树](@article_id:336607)**（parse tree）。起始符号是树的根，每次我们应用像 $A \\to BC$ 这样的规则时，我们就从[节点](@article_id:350499) $A$ 创建到其子[节点](@article_id:350499) $B$ 和 $C$ 的[分支](@article_id:350830)。终结符是树的叶子。\n\n这棵树的形状告诉我们很多关于文法能力的信息。考虑一种特殊的、受限的文法类型，其中每条规则的右侧*最多只有一个*变量，比如 $A \\to aB$ 或 $A \\to a$ [@problem_id:1362637]。这种文法的[解析树](@article_id:336607)会是什么样子？由于每个变量只能产生一个新变量，树的“主干”——变量的路径——永远不会分叉。它是一条从根到最后一次[变量替换](@article_id:301827)的单一、笔直的链条。所有的终结符都挂在这条中心藤蔓上。\n\n这些简单的、链状的文法被称为**正则文法**（regular grammars），它们生成**[正则语言](@article_id:331534)**（regular languages）。这些语言与[有限自动机](@article_id:330802)（finite automata）所能识别的语言相同——[有限自动机](@article_id:330802)是一种除了当前所在状态外没有其他记忆的简单机器。这很有道理：当你处理字符串时，你只是从一个状态（变量）沿着链条移动到下一个状态 [@problem_id:1359869]。\n\n但是，当我们允许规则右侧有多个变量时，比如 $S \\to SS$，一切都变了。现在，一个变量可以[分裂](@article_id:325155)成两个独立的、[递归](@article_id:328403)的子问题。[解析树](@article_id:336607)可以分叉，创造出深层嵌套的、层级化的结构。这些就是**[上下文无关文法](@article_id:330233)**（context-free grammars, CFGs），它们在本质上更为强大。它们可以处理正则文法无法处理的事情，比如匹配嵌套的括号 `((()))` 或描述回文，因为它们通过构建[解析树](@article_id:336607)的[递归](@article_id:328403)调用栈拥有一种无限的记忆形式。\n\n[正则语言](@article_id:331534)和[上下文无关语言](@article_id:335448)之间的这种区别，是被称为 **Chomsky 层级**（Chomsky Hierarchy）的更广阔计算能力图景的第一步。它根据生成语言所需的文法规则的[复杂性](@article_id:329807)，提供了一个优美、有序的语言分类。\n\n### 驯服野兽：[范式](@article_id:329204)的优雅\n\n现实世界中的文法可能很混乱。它们可能有产生空串的规则（$A \\to \\epsilon$），只重命名变量的规则（$A \\to B$），或者右侧冗长复杂的规则。为了让计算机高效地处理它们，或者为了我们证明它们的性质，拥有一个[标准化](@article_id:329128)的格式是非常有用的。\n\n其中最重要的之一是 **Chomsky [范式](@article_id:329204)**（Chomsky Normal Form, CNF）。如果一个文法的每条规则都只采用以下两种简单形式之一，那么它就处于 CNF [@problem_id:1424566]：\n1.  $A \\to BC$：一个变量产生另外两个变量。\n2.  $A \\to a$：一个变量变成一个终结符。\n\n乍一看，这似乎限制性极强！你怎么可能只用这两种移动来描述一个复杂的语言？事实证明，任何[上下文无关文法](@article_id:330233)（不生成空字符串的）都可以系统地转换成一个[等价](@article_id:328544)的 CNF 文法。\n\n想一想这些规则意味着什么。$A \\to BC$ 规则是纯粹的**结构构建**规则。它说：“概念 $A$ 由一个 $B$ 部分后跟一个 $C$ 部分组成。”这完全是关于二元分解，将一个[问题分解](@article_id:336320)成两个更小的子问题。$A \\to a$ 规则是**落地**规则。它将抽象的概念结构与语言中具体、有形的符号联系起来。\n\n这种[标准化](@article_id:329128)的美妙之处在于，它使得推导过程变得异常可预测。对于任何处于 CNF 的文法，如果你想推导一个长度为 $n$（其中 $n \\ge 1$）的字符串，它总是需要*恰好* $2n-1$ 步 [@problem_id:1402620]。\n\n为什么？让我们来推理一下。要得到一个有 $n$ 个终结符的最终字符串，你必须应用恰好 $n$ 条 $A \\to a$ 形式的规则。这些规则中的每一条都用掉一个变量。这些变量从哪里来？它们是由结构构建规则 $A \\to BC$ 创建的。每次应用这样的规则，你消耗一个变量（$A$）并产生两个（$B$ 和 $C$），净增一个变量。为了得到终结符规则所需的 $n$ 个变量（同时消耗起始符号），你必须应用结构构建规则恰好 $n-1$ 次。因此，总步数是 $(n-1) + n = 2n-1$。\n\n这是一个惊人的结果。一个看似混乱的替换过程，却受制于一个简单而精确的公式，这一切都因为我们将规则组织成了一种清晰的[范式](@article_id:329204)。它揭示了文法表面下运转的钟表般精密的机制。\n\n### [歧义](@article_id:340434)性的阴影：一个字符串，多种含义\n\n为了使文法在像编程语言这样的环境中有用，我们通常还希望它具备另一个属性：无[歧义](@article_id:340434)性。想想这个句子：“I saw a man on a hill with a telescope.”（我看到一个在山上带着望远镜的男人。）谁有望远镜？我还是那个男人？这个句子有两种可能的句法结构，两种不同的[解析树](@article_id:336607)。它是有[歧义](@article_id:340434)的。\n\n如果一个[形式文法](@article_id:337111)的语言中至少有一个字符串有多于一棵[解析树](@article_id:336607)，那么这个文法就是**[歧义](@article_id:340434)的**（ambiguous） [@problem_id:1429963]。这对于编译器来说通常是灾难性的，因为它需要知道程序的唯一真实结构才能正确地翻译它。\n\n[歧义](@article_id:340434)性可能以微妙的方式出现。考虑文法 $S \\to SS \\mid x$ [@problem_id:1403322]。它有多少种方式可以生成字符串 `xxx`？\n-   它可以从 $S \\to SS$ 开始，然后将第一个 $S$ 再次展开为 $SS$：$(SS)S \\to (xx)x$。\n-   它可以从 $S \\to SS$ 开始，但展开第二个 $S$：$S(SS) \\to x(xx)$。\n这两个推导对应于不同的[解析树](@article_id:336607)，所以该文法是[歧义](@article_id:340434)的。事实上，用这个文法生成 $x^n$ 的方式数量是著名的卡特兰数 $C_{n-1}$，这是一个在[组合数学](@article_id:331628)中随处可见的序列。\n\n有些文法甚至更加奇妙。可以构造一个文法，其作用就像一台“按需定制[歧义](@article_id:340434)度”的机器。考虑这个杰作 [@problem_id:1403322]：\n$S \\to aSb \\mid T$\n$T \\to aTb \\mid c$\n\n这个文法生成形如 $a^n c b^n$ 的字符串。但是它能以多少种方式生成一个给定的字符串，比如 $a^2cb^2$？一个推导是一条选择路径。在这里，我们在 $S \\to aSb$ 规则和 $S \\to T$ 规则之间进行选择。对于 $a^2cb^2$，我们可以：\n1.  应用 $S \\to aSb$ 两次，然后 $S \\to T$：$S \\to aSb \\to aaSbb \\to aaTbb \\to \\dots \\to aacbb$。\n2.  应用 $S \\to aSb$ 一次，然后 $S \\to T$：$S \\to aSb \\to aT b \\to \\dots \\to aacbb$。\n3.  立即应用 $S \\to T$：$S \\to T \\to \\dots \\to aacbb$。\n\n这三种初始策略中的每一种都导向一棵独特的[解析树](@article_id:336607)。总的来说，对于字符串 $a^n c b^n$，恰好有 $n+1$ 种不同的推导。这意味着对于*任何*正整数 $k$，我们都可以在这个语言中找到一个字符串（即 $a^{k-1}cb^{k-1}$），它恰好有 $k$ 棵[解析树](@article_id:336607)！该文法的[歧义](@article_id:340434)函数是到正整数集上的[满射](@article_id:307820)。这揭示了用这些简单规则可以达到的精妙控制水平。\n\n### 不可知之物：关于确定性的极限\n\n我们已经见识了[形式文法](@article_id:337111)的强大和精妙。但是，对于我们能了解它们的程度，存在着根本的限制。一些看似简单的问题是**不可判定的**（undecidable）——可以证明不存在通用[算法](@article_id:331821)来回答它们。\n\n其中一个问题是**[等价](@article_id:328544)性问题**（equivalence problem）：给定两个任意的[上下文无关文法](@article_id:330233) $G_1$ 和 $G_2$，它们是否生成完全相同的语言？[@problem_id:1359859]。答案是否定的，不存在能够解决所有可能输入的这个问题的[算法](@article_id:331821)。这是一个深刻的局限。我们可以写下规则系统，但我们不总能知道两个不同的系统是否产生相同的结果。\n\n这个证明是[理论计算机科学](@article_id:326840)中常见的一条优美的推理链。它是通过将另一个已知的[不可判定问题](@article_id:305503)归约到它来证明的。例如，我们知道判断一个 CFG 是否生成其字母表上的*所有可能字符串*是不可判定的（全称性问题）。如果我们有一个能够解决[等价](@article_id:328544)性问题的神奇黑盒，我们就可以轻易地解决全称性问题：只需问这个黑盒我们的文法 $G$ 是否[等价](@article_id:328544)于一个我们已知能生成所有字符串的简单文法 $G_{all}$。既然我们知道我们无法解决全称性问题，我们那个用于[等价](@article_id:328544)性的神奇黑盒就不可能存在。\n\n甚至[歧义](@article_id:340434)性问题本身对于任意 CFG 也是不可判定的。没有通用[算法](@article_id:331821)能够接受任何 CFG 并告诉你它是否是[歧义](@article_id:340434)的。这就是为什么设计编程语言如此困难；设计者必须竭尽全力构建那些通过其结构本身就*可证*为无[歧义](@article_id:340434)的文法，因为他们不能依赖一个通用工具来为他们检查。这也是为什么在实践中，我们有时会退回到可判定但有限的问题，比如“对于长度不超过 $k$ 的任何字符串，这个文法是否是[歧义](@article_id:340434)的？”[@problem_id:1429963]，作为对不可能解决的通用问题的实际替代。\n\n这段从简单规则到无限语言，从优雅结构到最终认识到可知范围的深刻极限的旅程，揭示了[形式文法](@article_id:337111)深刻而美丽的世界。它们不仅仅是[计算机科学](@article_id:311211)家的技术工具，更是一扇窥探结构与描述本质的窗口。", 'applications': "## 应用与跨学科联系\n\n在掌握了[形式文法](@article_id:337111)的原理与机制之后，我们可能会倾向于将它们视为理论家们的一种小众、抽象的玩物，一套用于生成符号串的枯燥规则。但如果仅止于此，就如同学会了国际象棋的规则，却从未欣赏过其千变万化、美妙绝伦的对局。[形式文法](@article_id:337111)的真正魔力不在于其定义，而在于其惊人的[普遍性](@article_id:300195)。一旦你学会了识别它们，你就会开始在各处发现它们的回响，从运行我们世界的代码到构成我们自身的密码。这段旅程不仅仅是应用一个工具，更是发现一个结构化创造的普适原则。\n\n### 计算的统一：作为机器的文法\n\n让我们从文法的故土——[计算机科学](@article_id:311211)开始。在这里，它们不仅仅是众[多工](@article_id:329938)具之一，而是一条将看似不同的概念缝合在一起的统一线索。思考一下存在于从自动售货机到读取计算机程序最初词语的词法分析器等一切事物内部的谦逊的[状态机](@article_id:350510)，或称“[有限自动机](@article_id:330802)”。它根据读取的符号在状态之间跳转。现在，思考一个简单的正则文法。它根据一条规则重写一个符号。这两种是不同的想法吗？\n\n完全不是！它们是用两种不同的语言描述同一支舞。正则文法和[有限自动机](@article_id:330802)之间存在着一种优美而直接的[等价关系](@article_id:298723)。文法中的每一条规则，如 $A \\to aB$，都对应着机器中的一个转换：“从状态 $A$，在读取一个 '$a$' 时，移动到状态 $B$。”将一个[非确定性有限自动机](@article_id:337439)（NFA）转换为[等价](@article_id:328544)的右[线性](@article_id:316778)文法是一个揭示这种深层联系的标准程序 [@problem_id:1432829]。这不仅仅是一个聪明的技巧；它是对计算统一性的一瞥。它告诉我们，文法的“生成”方法和机器的“识别”方法是同一枚硬币的两面。\n\n这种统一性延伸到整个被称为 Chomsky 层级的“[复杂性](@article_id:329807)阶梯”上。阶梯的每一级代表一类具有更强大规则的文法，能够生成更复杂的模式。而对于每一级，都有一个相应的机器类别，其能力恰好足以处理它。例如，如果我们上升到上下文相关文法，我们会发现它们的舞伴是一种叫做“[线性](@article_id:316778)有界自动机”的机器。这些文法的一个关键特征是它们的规则从不使字符串变短。这对机器有什么影响呢？这意味着机器工作所需的“带子”长度永远不需要超过原始输入字符串的长度 [@problem_id:1448406]。对文法规则的一个抽象约束（$|\\alpha| \\le |\\beta|$）对所需的计算资源（[内存](@article_id:354523)空间）施加了一个直接的、类似物理的约束。这种文法能力与机器能力之间的优雅对应关系是[复杂性理论](@article_id:296865)的基础，该理论研究什么是计算上可行的，什么不是。\n\n### 生命的语言：作为句法的生物学\n\n也许[形式文法](@article_id:337111)最令人叹为观止的应用在于一个乍看之下与[计算机科学](@article_id:311211)相去甚远的领域：生物学。事实证明，[进化](@article_id:304208)，通过数十亿年的试错，偶然发现了与文法惊人相似的结构组织原则。\n\n以 RNA 分子为例，它是细胞中的多功能主力。一条由四种碱基——A、C、G、U——组成的单链 RNA 会折叠回自身，形成复杂的三维形状，充当[酶](@article_id:303941)、信使和结构支架。这种折叠的主要驱动力是 Watson-Crick [碱基配对](@article_id:330704)：A 与 U 配对，C 与 G 配对。由于链是[线性](@article_id:316778)的，这些配对创造了嵌套结构。一个外部配对可以形成，包围一个随后独立折叠的区段，依此类推。\n\n这听起来熟悉吗？这正是[上下文无关文法](@article_id:330233)（CFGs）旨在捕捉的结构！我们可以写一个简单的文法来模拟一个[完美嵌套](@article_id:302439)的 RNA [发夹环](@article_id:381370) [@problem_id:2440496]：\n$$\nS \\rightarrow \\mathrm{A}\\,S\\,\\mathrm{U} \\mid \\mathrm{U}\\,S\\,\\mathrm{A} \\mid \\mathrm{C}\\,S\\,\\mathrm{G} \\mid \\mathrm{G}\\,S\\,\\mathrm{C} \\mid \\varepsilon\n$$\n在这里，非终结符 $S$ 代表一个潜在的折叠结构。像 $S \\rightarrow \\mathrm{A}\\,S\\,\\mathrm{U}$ 这样的规则是一条直接的生物学指令：“将一个 A 和一个 U 作为一对放在外面，然后[递归](@article_id:328403)地形成内部结构。”这个文法生成的语言由像“ACCGGU”这样的字符串组成，这是可以折叠成嵌套结构的[线性序](@article_id:307199)列。\n\n我们可以把这个强大的思想推得更远。给定一个用括号和点表示法表示的特定目标 RNA 形状，我们可以自动构建一个定制的 CFG，它能生成*所有可能*折叠成该确切形状的 RNA 序列 [@problem_id:2426816]。这将文法变成了[合成生物学](@article_id:301918)的设计工具，让我们能够提出诸如“我需要合成什么样的序列来创造一个具有这种特定功能的分子？”之类的问题。\n\n“生物学文法”的概念现在正被扩展到[基因调控](@article_id:303940)的核心。基因的控制区域，即[顺式调控模块](@article_id:356952)（CRMs），装饰着各种[蛋白质](@article_id:328709)（[转录因子](@article_id:297280)）的结合位点。这些结合位点的[排列](@article_id:307545)——它们的身份、在 DNA 链上的方向以及它们之间的间距——似乎遵循着复杂的规则。科学家们现在正在定义一种“[染色质](@article_id:336327)文法”，不是作为一套僵化的规则，而是作为一个复杂的[概率模型](@article_id:323690)，描述在基因组活跃区域找到某些结合位点配置的可能性 [@problem_id:2378275]。这显示了文法概念本身的发展，从一个简单的字符串生成器到一个用于理解基因组复杂句法的统计框架。\n\n### 意义的语法：逻辑、语言和信息\n\n从分子的物理世界，我们现在转向信息和意义的抽象世界。在这里，文法提供了构建意义的[骨架](@article_id:329113)。\n\n自然语言是 Chomsky 工作的最初灵感。虽然一个简单的 CFG 可以捕捉大量的句子结构（例如，一个句子是一个名词短语和一个动词短语），但人类语言表现出的精妙之处挑战了上下文无关描述的界限。为了处理这些问题，并处理语言固有的[歧义](@article_id:340434)性，计算语言学家使用*概率*文法。通过为每条规则分配一个概率，我们可以超越简单地问“这个句子在句法上是否正确？”而进一步问“给定这个词串，*最可能*的[解析树](@article_id:336607)是什么？”这对于机器翻译、语音识别和问答系统至关重要。概率文法甚至可以模拟更复杂的结构，比如某些语言中发现的“[交叉](@article_id:308048)依赖”，这是简单 CFG 无法做到的 [@problem_id:858359]。\n\n在[信息论](@article_id:307403)和编码领域，对无[歧义](@article_id:340434)结构的需求更为关键。当你发送一条消息时，你希望接收者以唯一的方式理解它。假设你的代码由一个集合 $C$ 中的码字组成。一条消息只是这些码字的[拼接](@article_id:297805)。一个由 0 和 1 组成的字符串是否可能被解析成两种不同的有效码字序列？如果是这样，你的代码就是有[歧义](@article_id:340434)的，坦率地说，不太有用。\n\n在这里，[形式文法](@article_id:337111)再次提供了一个惊人优雅的洞见。我们可以构建一个简单的文法，生成所有可能的[拼接](@article_id:297805)消息。事实证明，[当且仅当](@article_id:326824)生成其消息的文法是**无[歧义](@article_id:340434)的**，该代码才是**唯一可译的** [@problem_id:1610400]。一个形式系统的抽象属性——其字符串是否只有一个且仅有一个推导树——对通信渠道的[可靠性](@article_id:336714)产生了直接的、关乎成本效益的影响。\n\n最后，让我们看看最深层次的联系：推理本身的结构。在[数理逻辑](@article_id:301189)中，一个证明无非是一个有限的公式序列，其中每个公式要么是一个公理，要么是由前面的公式通过一个[推理规则](@article_id:336844)（如[肯定前件式](@article_id:331907)）推导出来的。所有可证明定理的集合可以被看作是由逻辑系统的文法生成的“语言”。整个过程是纯句法的——它关乎根据规则操纵符号。\n\n这类系统的一个基本性质是它们在替换下是封闭的。如果你证明了一个定理模板，比如 $\\varphi \\to (\\psi \\to \\varphi)$，你可以用任何有效的公式替换 $\\varphi$ 和 $\\psi$，结果仍然是一个定理。为什么这行得通？这个元定理的证明是对推导结构的[归纳](@article_id:338029)。它关键地依赖于公理是模式（由其形式定义）以及[推理规则](@article_id:336844)（如[肯定前件式](@article_id:331907)）在替换下保持其结构这一事实。该证明是一个纯粹的句法论证，一个符号游戏，不需要任何对公式“意味着”什么的理解 [@problem_id:2986368]。这揭示了一些深刻的东西：严谨论证的基础本身就建立在定义文法的同一种形式化的、基于规则的生成过程之上。\n\n从[状态机](@article_id:350510)到 DNA，从诗歌到证明，重写规则这个简单的想法给了我们一个异常强大的透镜。它揭示了世界模式中隐藏的统一性，向我们展示了计算的句法、生命的句法和逻辑的句法，在某种深刻的意义上，都是用同一种[形式语言](@article_id:328817)说出的。"}}, '#text': '->'}, '#text': '`。游戏的目标是从这个单一符号开始，通过一遍又一遍地应用产生式规则，最终得到一个完全由终结符组成的字符串。这整个过程称为**推导**（derivation）。\n\n所以，像 `'}, '#text': "-> 'hi' | 'hey'` 意味着“问候这个概念可以被具体词语 'hi' 或具体词语 'hey' 替换”。竖线 `|` 只是“或”的简写。\n\n最后，我们需要一个起点。这就是**起始符号**（start symbol），通常是我们想要生成的最普遍的概念，比如 `"}, '#text': '` 这样的概念，代表了问候的*想法*，而非任何具体的问候语。\n\n第三，我们有**产生式规则**（production rules）。这些是文法的核心；它们是我们游戏中的合法移动。一条规则告诉我们如何用其他变量和终结符的组合来替换一个变量。例如，规则 `'}, '#text': '` 和 `'}, '#text': '`、`'}, '#text': "## 原理与机制\n\n想象一下，你想教一台计算机理解英语。你该从何入手？你不能只给它一本词典；语言不仅仅是词汇的列表，它关乎结构，关乎那些让我们将词语组合成有意义句子的规则。[形式文法](@article_id:337111)正是我们尝试写下这些结构规则的努力，不仅针对人类语言，也适用于任何由简单部件组合成复杂事物的系统，从计算机程序到 DNA 链。\n\n但是，对于像语言这样流动不居的东西，你如何写下一条“规则”呢？这正是[形式文法](@article_id:337111)的天才之处。它不试图描述意义，而是创造了一种替换游戏，一个可以生成所有有效句子且不生成任何无效句子的生成过程。让我们来探究这个游戏的原理。\n\n### 文法的剖析：游戏规则\n\n每个[形式文法](@article_id:337111)都由四个关键部分定义。可以把它想象成学习一种新棋盘游戏的各个棋子。让我们看一个旨在生成简短文本消息的简单文法，以便对这些部分有个初步感受 [@problem_id:1359852]。\n\n首先，我们有**终结符**（terminals）。这些是最终会出现在我们输出中的具体符号，它们是我们语言的“词汇”。在我们的短信示例中，它们是像 `'hi'`、`'sup'` 和 `'bye'` 这样的词。它们之所以被称为终结符，是因为一旦你得到一个由它们组成的字符串，生成过程就*终止*了。\n\n其次，我们有**变量**（variables）或**非终结符**（non-terminals）。这些是不会出现在最终字符串中的抽象、高层概念，它们是我们想要构建的结构的占位符。在我们的示例中，它们是像 `"}

