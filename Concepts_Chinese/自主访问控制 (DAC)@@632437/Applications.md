## 应用与跨学科联系

自主[访问控制](@entry_id:746212)（Discretionary Access Control）的理念——即客体的所有者决定谁能使用它——感觉就像决定邀请谁来家里做客一样自然。它简单直观，构成了我们日常使用的无数系统的安全基石。但就像物理学或计算机科学中任何深刻而简单的思想一样，真正的乐趣始于我们推动它、测试其极限、看看它将引向何方。这段旅程将带我们从熟悉的个人文件世界，进入勒索软件攻击的核心、全球社交网络，以及现代云存储的加密内核。我们将看到，虽然 DAC 是一个优美且不可或缺的起点，但它在现代世界中的真正力量是在与其他安全原则的优雅共舞中实现的。

### 文件、代理人和超级用户的世界

每当你在电脑上右键单击一个文件并设置其权限时，你就是在一个小小的 DAC 世界里扮演着自主所有者的角色。你决定你“世界”中的谁（即机器上的其他用户账户）可以读取、写入或执行你的创作。这是最纯粹形式的 DAC。但这个简单的画面立刻引出了一个微妙而深刻的问题：当你授予一个*程序*访问权限时，你是否信任它会用这个权限*做什么*？

想象一个研究实验室，一个敏感的数据集必须能被所有研究人员读取以供分析，但绝不能离开实验室的网络。实验室主任作为所有者，可以使用 DAC（或许通过[访问控制](@entry_id:746212)列表 ACL）向“研究人员”组授予读取权限。到目前лиш为止一切顺利。但什么能阻止一个研究人员完全合法的数据分析程序——它已被授予读取权限——同时被诱骗悄悄地将数据复制到外部服务器呢？DAC 模型本身对此无能为力。DAC 规定了一个主体是否可以*打开*一个客体的*门*；它对其进入后的行为没有任何发言权。这就是经典的“困惑的代理人”（confused deputy）问题，即一个拥有合法权限的程序被欺骗滥用其权限。要解决这个问题，必须求助于一个更严格的上级：强制[访问控制](@entry_id:746212)（MAC）。MAC 策略可以规定，一个标记为“内部分析”的进程可以读取标记为“敏感”的数据，但禁止向任何标记为“外部网络”的客体写入。在这里，DAC 管理基本访问，而 MAC 控制信息流——这是策略组合的一个优美范例 [@problem_id:3642428]。

对主体身份的依赖带来了另一个更具戏剧性的挑战。在类 UNIX 系统中，有一个“超级用户”`root`，他本质上是万物的所有者。`root` 可以绕过所有 DAC 检查。如果一个普通用户可以暂时*成为* `root` 呢？这正是 `[setuid](@entry_id:754715) root` 程序所做的事情。它们是任何用户都可以运行的辅助工具，但它们以超级用户的全部权限执行。如果攻击者能用恶意的木马替换这样一个辅助工具，他们实际上就偷走了整个王国的钥匙。DAC 模型及其清晰的所有权划分将完全崩溃。以 `root` 身份运行的木马可以读取密码文件、安装监控软件，并抹去其存在的任何痕迹。这不是一个理论上的缺陷，而是一个经典的漏洞模式。现代的应对方法体现了[最小权限原则](@entry_id:753740)。[操作系统](@entry_id:752937)不再授予 `root` 的单一巨大权限，而是可以授予细粒度的*能力（capabilities）*。一个备份程序可能只被授予 `CAP_DAC_READ_SEARCH`，即绕过任何文件读取权限的特定能力——这正是它完成工作所需要的，仅此而已。它不能加载内核模块或重新配置网络。一次攻击造成的破坏范围被大大缩小，这显示了从粗粒度用户身份到细粒度进程能力的思维演进 [@problem_id:3673323]。

### 昔日权限的幽灵：撤销的挑战

授予权限容易，收回权限却是计算机安全中最棘手的问题之一。当你在社交网络上对朋友“取消分享”一张照片时，你期望他们的访问权限会立即消失。但如果他们已经将照片再次分享给其他人了呢？

这个场景完美地对应了带有“授予”权限的 DAC。假设你（$A$）与你的朋友（$B$）分享了一张照片，并给了他再次分享的权限。$B$ 将其分享给了 $C$。后来，你也直接将照片分享给了 $C$。现在，你与 $B$ 闹翻了并撤销了他的访问权限。应该发生什么？$C$ 是否应该失去访问权限？那么只从 $B$ 那里得到照片的 $D$ 呢？

这里有不同的哲学。*仅本地撤销（Local-only revocation）*只会切断 $B$ 的联系，留下 $C$ 和 $D$ 仍然可以访问——这可能不是你想要的。*朴素的级联撤销（Naive cascading revocation）*会切断 $B$ 以及所有 $B$ 曾分享过的人，包括 $C$——但这忽略了你曾直接分享给 $C$ 的事实！最直观的方法是*选择性级联撤销（selective cascading revocation）*：系统追溯授权路径。$D$ 失去访问权限，因为他们唯一的路径是通过 $B$。但 $C$ 保留了访问权限，因为他们仍然有一条直接来自你（所有者）的有效路径。这种尊重备用授权路径的逻辑，通常是用户所期望的，也是设计任何共享系统时的关键挑战 [@problem_id:3619205]。

这个逻辑难题在[操作系统](@entry_id:752937)内部变成了一个棘手的技术问题。想象一下，一个勒索软件开始加密你的文件。你或安全系统检测到此行为并立即撤销该程序的写入权限。问题解决了吗？在标准的 DAC 下并非如此。大多数[操作系统](@entry_id:752937)仅在文件被打开时（`open()` 系统调用）执行 DAC 检查。如果检查通过，进程会得到一个名为文件描述符的“票据”。所有后续使用该票据的写入操作都会被允许，即使磁盘上文件的权限已经被更改。撤销来得太晚了；勒索软件可以完成对其已经打开的文件的加密。这是一个“[检查时-使用时](@entry_id:756030)”（[TOCTOU](@entry_id:756027)）漏洞。要彻底阻止攻击，你需要一个在*每一次写入时*都检查权限的系统——这个原则称为“完全中介”（complete mediation），是 MAC 系统的一个标志。这鲜明地说明了撤销的动态性如何揭示不同[访问控制](@entry_id:746212)模型之间的深刻差异 [@problem_id:3619252]。在具有多层缓存的系统中，这个挑战被放大了，过时的权限可能会持续存在，为*新的*访问尝试创造一个漏洞窗口，直到缓存过期或被显式刷新 [@problem_id:3619234]。

### 现代交响曲：DAC 在[分布](@entry_id:182848)式、加密世界中的应用

DAC 远非过时的遗物，而是当今最复杂系统中一个至关重要的组成部分，常常扮演着大型交响乐团中一种乐器的角色。我们在策略组合的方式中可以看到这一点。考虑一个需要执行数据禁运的实验室。日常访问可以通过 DAC 和[基于角色的访问控制](@entry_id:754413)（[RBAC](@entry_id:754413)）灵活管理。但当禁运日期到来时，一个不可协商的全系统规则必须生效。这是 MAC 的工作。通过定义一个在特定时间应用于数据的“禁运”安全标签，系统可以自动且无误地覆盖所有自主授权。此时，访问权限仅在用户拥有“禁运解除”角色（[RBAC](@entry_id:754413)）、所有者已共享文件（DAC），*并且*系统的强制策略允许（MAC）的情况下才被允许。这种优雅的分层结构将 DAC 的灵活性与 MAC 的严格性结合起来 [@problem_id:3619211]。

当我们进入分布式系统的[世界时](@entry_id:275204)，情况变得更加复杂。想象一个点对点存储网络，文件权限（ACL）被复制到许多节点上。如果一个节点上的所有者撤销了访问权限，这个更改需要多长时间才能到达所有其他节点？如果系统为了最大化可用性而使用“最终一致性”（eventual consistency），就会有延迟。在这个[窗口期](@entry_id:196836)内，用户可以查询一个尚未收到更新的节点并获得访问权限，这违反了所有者的意图。为了保证*立即*的撤销安全性，系统必须使用“强一致性”（strong consistency）。这意味着撤销操作必须等到在必要数量的节点上确认后才能完成。其后果是？如果发生网络分区，系统可能不得不拒绝所有人的访问，以避免做出错误的决定。这揭示了安全与[分布式计算](@entry_id:264044)[基本权](@entry_id:200855)衡之间的深刻联系，这在著名的 CAP 定理中得到了体现：你不能总是同时拥有完美的Consistency（一致性/安全）和Availability（可用性）[@problem_id:3619216]。

将“用户”作为主要行动者的概念本身也在演变。在经典的多用户[操作系统](@entry_id:752937)中，DAC 是关于将 Alice 的文件与 Bob 的文件分开。在现代手机或云服务器中，主要行动者是相互隔离的*应用程序*。每个应用都生活在自己的[沙盒](@entry_id:754501)宇宙中，受严格的 MAC 策略支配，该策略规定了它能接触哪些系统资源。这是从桌面[操作系统](@entry_id:752937)的用户驱动 DAC 向的一种[范式](@entry_id:161181)转变，但概念上的传承是清晰的。目标仍然是分离主体并保护其客体，但现在的主体是应用，而保护模型已从自主转向强制，以保护用户免受其自身应用程序的侵害 [@problem_id:3689426]。

最后，我们能否为撤销构建一个更好的时间机器？我们能否强行使“昔日权限的幽灵”——那些在 DAC 权限更改后仍然存在的 文件描述符——失效？一种极其巧妙的方法将[访问控制](@entry_id:746212)与[密码学](@entry_id:139166)结合起来。想象每个文件都用自己唯一的密钥 $K$ 加密。当一个进程打开文件时，其文件描述符不仅绑定到文件，还绑定到密钥 $K$。现在，要撤销访问权限，系统不只是更改一个权限位。它生成一个全新的密钥 $K'$，用 $K'$ 重新加密整个文件，然后丢弃 $K$。任何持有旧文件描述符的进程现在都拿着一把错误的锁的钥匙。它的访问权限变得完全无效。当然，系统还必须小心地从内存中清除任何缓存的*明文*数据副本。这种加密撤销是一种强大的技术，用于在复杂的多租户环境（如具有共享块存储的云服务器）中强制执行即时和完全的撤销，有效地斩杀了 DAC 最古老的一条恶龙 [@problem_id:3619225] [@problem_id:3619251]。

自主[访问控制](@entry_id:746212)，以其优雅的简洁性，是引领我们踏上征程的问题。在试图解决它所带来的难题——困惑的代理人、超级用户、无法阻止的勒索软件、被再次分享的照片——的过程中，我们对安全有了更深的理解。我们发现了强制控制的必要性、策略组合的微妙之处、[分布](@entry_id:182848)式状态的权衡，以及[密码学](@entry_id:139166)的终极力量。DAC 不是最终答案，但它过去是，并且至今仍然是完美的开端。