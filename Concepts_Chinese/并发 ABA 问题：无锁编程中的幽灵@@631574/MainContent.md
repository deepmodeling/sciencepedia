## 引言
在追求高性能软件的过程中，开发者们越来越多地转向[无锁编程](@entry_id:751419)——一种通过消除传统、缓慢的加锁机制，从而有望释放[多核处理器](@entry_id:752266)全部潜能的[范式](@entry_id:161181)。这种方法的核心是一种强大的硬件指令：[比较并交换](@entry_id:747528)（CAS）。这是一种[原子操作](@entry_id:746564)，似乎为协调线程提供了一个完美的工具，而无需强制它们等待。然而，在并发执行的复杂交织中，一个被称为 ABA 问题的微妙而危险的缺陷可能会出现，将这个看似万无一失的工具变成无声的[数据损坏](@entry_id:269966)源。当一个共享值发生变化，然后又变回原值时，这个问题就会出现，它会欺骗 CAS 操作，让其相信系统状态未曾改变，而实际上，系统状态已经发生了关键性的改变。

本文将剖析这个机器中的幽灵。在第一部分“原理与机制”中，我们将探索导致 ABA 问题的精确事件序列，然后系统地研究一系列解决方案，从简单的锁和更智能的硬件原语，到复杂的版本化技术和安全[内存回收](@entry_id:751879)方案。之后，在“应用与跨学科联系”部分，我们将看到这个基本问题如何在真实世界的系统中显现，并追溯其在[无锁数据结构](@entry_id:751418)、操作系统内核、语言运行时乃至大规模分布式系统中的影响。通过理解这个问题及其解决方案，您将对构建健壮且高性能的并发软件的艺术有更深刻的认识。

## 原理与机制

想象一下，你身处一个图书馆，图书管理员们并行工作，管理一个书堆。这个书堆由中央桌上的一张便条表示，上面写着顶部的书是哪一本。为了让工作快速进行，他们不使用带锁和钥匙的繁琐借阅系统。相反，他们使用一个简单、闪电般快速的规则：要弹出一本书，你先读取便条上当前顶部的书名，比如《并发的艺术》，找到它下面的那本书，比如《Gödel, Escher, Bach》，然后在便条上仍然写着《并发的艺术》的前提下，原子地将便条更新为《Gödel, Escher, Bach》。这种[原子性](@entry_id:746561)的“检查后更新”操作是许多高性能并发系统的灵魂，在计算世界里，它最著名的名字是**[比较并交换](@entry_id:747528)（Compare-And-Swap）**，或称 **CAS**。

CAS 指令是硬件工程的一大奇迹。它告诉处理器：“查看这个特定的内存地址。如果它包含`expected_value`，那么并且仅当如此，才将`new_value`写入其中。将此作为一个单一、不可分割、瞬时完成的操作来执行。” 它似乎是构建“无锁”数据结构的完美工具——在这种系统中，多个线程可以同时操作，而无需等待其他线程释放锁。但在并发这个微妙的世界里，即使是看似完美的工具也可能被欺骗。

### 骗人的指针：一则关于身份混淆的故事

让我们跟随一[位图](@entry_id:746847)书管理员，线程 T1，看它如何尝试从我们的无锁书堆中弹出一本书。[@problem_id:3621933]

1.  T1 查看中央桌。便条上写着顶部的书是 `A`。T1 记下 `A` 下面的书是 `B`。它准备执行其原子更新：`CAS(top_book_note, A, B)`。
2.  突然，T1 被叫去接电话——用计算机术语来说，它被[操作系统调度](@entry_id:753016)器抢占了。
3.  在 T1 忙碌的时候，一个速度很快的图书管理员，线程 T2，到来了。T2 弹出了书 `A`。便条现在指向 `B`。然后 T2 弹出了书 `B`。便条现在指向 `C`。
4.  T2 处理完书 `A`，并将其送到图书馆的回收箱（内存被释放）。
5.  片刻之后，一本新书到达。图书馆一如既往地高效，从回收箱里拿起一个回收的书皮——恰好是原来那本 `A` 的书皮——并把它套在了新书上。我们称这个冒名顶替者为 `A'`。这本新书 `A'` 随后被压入书堆。现在，中央桌上的便条，纯属巧合，又指向了一本封面为 `A` 的书。

现在，陷阱已经设好。

6.  线程 T1 接完电话回来。它继续执行任务，尝试执行 `CAS(top_book_note, A, B)`。它检查便条。便条上写着 `A`。“啊哈！”它想，“和我离开时一模一样。” 比较成功了。CAS 操作完成，便条被更新为 `B`。

灾难发生了。T2 刚刚放到书堆上的那本 `A'` 从记录中消失了，它的存在被 T1 过时的更新抹去了。更糟糕的是，便条现在指向 `B`，这是一本 T2 已经弹出并且可能正在被送到另一个图书馆的书（其内存已被释放并完全用于其他目的）。书堆现在已经损坏。

这个场景，即一个共享值从 `A` 变为 `B`，然后又变回 `A`，从而欺骗了 CAS 操作，就是臭名昭著的 **ABA 问题**。[@problem_id:3687331] [@problem_id:3686916] [@problem_id:3647095] 它暴露的根本缺陷是深远的：CAS 检查的是*值的相等性*，但程序员通常需要的是*历史的同一性*。T1 不仅仅是在检查顶部的书封面是否为 `A`；它是在含蓄地假设，如果封面是 `A`，那么它下面的整个书堆都和它第一次看时一样。ABA 问题违反了这一假设。它打破了一个不变性，即一个特定的指针值意味着一个特定的、未改变的逻辑状态。[@problem_id:3226035] 那么，我们该如何揭穿这个冒名顶替者呢？

### 揭穿冒名顶替者：一套解决方案

修复 ABA 问题是一次深入并发系统设计核心的迷人旅程。解决方案从简单粗暴到异常优雅的机制，各有其权衡之处。

#### 暴力方法：直接使用锁

最直接的解决方案是针对这个特定操作放弃无锁方法。我们可以在书堆周围放置一个全局锁。在任何图书管理员查看便条之前，他们都必须获取该锁。他们持有该锁直到整个压入或弹出操作完成。这将访问序列化，使得 T1 和 T2 的问题性交错执行变得不可能。

像**[测试并设置](@entry_id:755874)（Test-And-Set, TAS）**这样的简单指令可以用来构建这样的锁。[@problem_id:3686916] TAS 会原子地将一个内存位置设置为 $1$ 并返回其旧值。线程可以在一个循环中自旋，重复调用 TAS，直到它返回 $0$，这表示它们已经获取了锁。

虽然有效，但加锁是一种笨拙的工具。它以消除并行性为代价来消除 ABA 问题。如果一个持有锁的线程被延迟，所有其他线程都必须等待。它解决了正确性问题，但可能造成性能瓶颈。此外，在具有[弱内存模型](@entry_id:756673)的现代处理器上，仅仅使用锁是不够的。你需要确保在加锁区域内所做的所有写操作对下一个获取锁的线程都是可见的。这需要特殊的[内存屏障](@entry_id:751859)或具有**获取和释放语义**的指令，这些指令充当屏障，防止编译器和 CPU 以有害的方式重排操作。[@problem_id:3686916]

#### 更智能的原语：[链接加载/条件存储](@entry_id:751376)

一些[处理器架构](@entry_id:753770)提供了一种更精巧的工具：**[链接加载/条件存储](@entry_id:751376)（Load-Linked/Store-Conditional, [LL/SC](@entry_id:751376)）**指令对。可以把它看作是一个“监视此地”的机制。[@problem_id:3654088]

当 T1 使用 `Load-Linked` 从便条读取值 `A` 时，处理器会在该内存位置上设置一个不可见的预留。然后 T1 继续处理其事务。当它准备好更新时，它使用 `Store-Conditional` 写入新值 `B`。只有当预留仍然有效时，该存储才会成功。在我们的故事中，当 T2 写入便条时（将其更改为 `B`，然后是 `C`，再回到 `A`），这些写操作会使 T1 的预留失效。当 T1 尝试其 `Store-Conditional` 时，它将失败，从而正确地通知 T1 世界已经发生了变化。

[LL/SC](@entry_id:751376) 不会被 ABA 问题所欺骗，因为它的成功取决于地址上*没有中间写入*，而不是*值的相等性*。[@problem_id:3664104] 它提供了 CAS 所缺乏的历史保证。然而，[LL/SC](@entry_id:751376) 并非万能药。它并非在所有流行架构上都可用（例如，主推 CAS 的 x86 架构）。此外，预留可能因多种原因而被破坏，包括对同一缓存行上的其他内存访问，甚至是[上下文切换](@entry_id:747797)，从而导致伪失败。使用 [LL/SC](@entry_id:751376) 的算法必须准备好重试，并且在重度竞争下，它们可能会遭受“[活锁](@entry_id:751367)”——即多个线程反复使彼此的预留失效而无法取得进展。[@problem_id:3664104]

#### 侦探的标签：指针版本化

如果我们只能用 CAS，我们能让它变得更聪明吗？答案是肯定的。关键在于扩展我们检查的状态。如果值 `A` 可能是个冒名顶替者，那我们就给它一个不容易被伪造的身份。这就是**带标签的指针（tagged pointers）**或**版本计数（version counting）**背后的思想。

想象一下，桌上的便条不再只包含书名，而是一个值对：`(book_name, version_number)`。每当顶部的书发生变化时，我们就增加版本号。[@problem_id:3687331]

让我们用这条新规则重演一下场景：
1.  T1 读取便条：`(A, 10)`。它准备执行 `CAS(, (A, 10), (B, 11))`。
2.  T1 被抢占。
3.  T2 执行其快速的操作序列。每次成功的弹出和压入都会增加版本号：`(A, 10) -> (B, 11) -> (C, 12)`。当冒名顶替的书 `A'` 被压入时，便条变为 `(A, 13)`。
4.  T1 恢复执行。它执行其 CAS，将当前值 `(A, 13)` 与其[期望值](@entry_id:153208) `(A, 10)` 进行比较。指针匹配，但版本不匹配！CAS 失败，冒名顶替者被抓住了。

这个优雅的解决方案非常有效，并且在现代 64 位 CPU 上得以实现，因为有指令可以对一个 128 位（16 字节）的值执行原子[比较并交换](@entry_id:747528)，从而允许将指针和版本标签作为一个单元进行操作。[@problem_id:3226035]

但这也有一个微妙之处：如果版本计数器本身回绕（wrap around）了怎么办？例如，一个 16 位的计数器在 65,536 次递增后会重置为 0。如果 T1 被延迟足够长的时间，并且期间恰好发生了 65,536 次（或其倍数）操作，版本号可能会回到其原始值，从而使 ABA 问题再次成为可能。[@problem_id:3621933]

这引出了一个有趣的设计问题：我们的标签需要多少位？答案取决于系统。如果我们知道最大更新速率（$\rho$）和线程可能被调度器停滞的最长时间（$\Delta$），我们就可以计算出最大中间更新次数：$\rho \Delta$。为安全起见，我们可能的标签值数量，对于一个 $k$ 位标签即 $2^k$，必须大于这个数字。对于一个最大[停滞时间](@entry_id:273487)为 10 毫秒、每秒有 5000 万次更新的系统，我们将需要超过 $500,000$ 个标签值，这至少需要一个 19 位的标签（$2^{19} = 524,288$）。[@problem_id:3621933] 在一个为极高正常运行时间而设计的系统中，我们可能需要保证在多年的运行中都不会发生回绕，这就需要一个更大的标签。[@problem_id:3621191]

#### 社区观察：安全[内存回收](@entry_id:751879)

ABA 问题通常是另一个问题的症状：过早的[内存回收](@entry_id:751879)。冒名顶替者 `A'` 之所以能出现，是因为原始 `A` 的内存被释放并立即被重用。如果我们能阻止这种情况发生呢？这就是安全[内存回收](@entry_id:751879)方案的目标。

**危险指针（Hazard Pointers, HP）**提供了这样一种机制。规则很简单：如果你要接触一个共享对象，你必须首先“标记”一个指向它的危险指针。可以把它想象成在对象上放一个小小的“请勿打扰”标志。每个线程都有一个小的、公开可见的危险指针列表。中央[内存回收](@entry_id:751879)器在释放任何对象之前，必须扫描所有线程的危险指针列表。如果一个对象被标记为危险，它就不能被释放。[@problem_id:3226035]

在我们的场景中，T1 会读取指针 `A`，然后将 `A` 注册为一个危险指针。现在，即使 T2 弹出了节点 `A`，回收器看到了危险标记，也无法释放其内存。因此，地址 `A` 不能被重用于新书 `A'`。值 `A` 不会重新出现在便条上，T1 随后的 CAS 将会正确地失败。[@problem_id:3647095] [@problem_id:3219143] 这种方法很强大，但它带来了线程不断更新其危险指针列表以及回收器扫描它们的开销。[@problem_id:3621240]

**基于静止状态的回收（Quiescent-State-Based Reclamation, QSBR）**是另一种方法。系统以“纪元”（epoch）为单位运作。当一个线程处于“静止状态”——意味着它不持有任何共享对象的临时引用——它会向系统宣告这一点。一个在纪元 $E$ 中被“退休”的对象，只有在系统中所有线程都宣告它们已经在晚于 $E$ 的一个纪元中经过了静止状态之后，才能被安全地释放。这保证了不可能有任何线程仍然持有对该对象的引用。[@problem_id:3621240] 这种面向批处理的方法在某些工作负载下可能比危险指针更高效，这说明了工程师在构建这些系统时面临的丰富权衡。

### 统一原则

从锁到 [LL/SC](@entry_id:751376)，从版本标签到危险指针，所有这些解决方案都针对同一个根本弱点。ABA 问题告诉我们，一个指针不仅仅是一个值；它是一个丰富、复杂状态的代理。简单的 CAS 只检查值，而程序员的逻辑则依赖于整个状态的完整性。

这些解决方案，以各自的方式，都是通过丰富检查来更忠实地反映程序员的意图。锁序列化了对状态的访问。[LL/SC](@entry_id:751376) 验证了指针位置的历史。带标签的指针为指针值本身添加了显式历史。而[内存回收](@entry_id:751879)方案则保护了指针所指向对象的历史同一性。理解这一原理——值与状态之间的差距——是掌握在我们这个大规模并行的世界中进行编程这门美丽而复杂艺术的关键一步。

