## 引言
如何高效地划分有限资源是计算机科学乃至更广领域中的一个根本问题。无论是管理内存块、磁盘空间还是时间，幼稚的分[配方法](@entry_id:265480)都可能导致一种充满不可用碎片的混乱状态——这个问题被称为碎片化。本文深入探讨一种优雅而强大的解决方案：2的幂次分配策略。它解决了在灵活划分资源的需求与维持秩序以防止浪费的必要性之间的矛盾。在接下来的章节中，我们将首先探讨这种策略（通常称为[伙伴系统](@entry_id:637828)）的“原理与机制”，剖析其简单的分割与合并规则，并分析其固有的权衡。随后，在“应用与跨学科联系”部分，我们将发现这个单一而强大的思想如何远远超越主内存的范畴，塑造着从[文件系统](@entry_id:749324)、GPU性能到[CPU调度](@entry_id:636299)和网络管理的方方面面。

## 原理与机制

想象你是一位木匠，拥有一块非常珍贵的、长为$1024$厘米的巨大木料。一天中，顾客们络绎不绝地向你索要各种长度的木块：一个需要$400$厘米，另一个需要$200$厘米，第三个则需要一小块$5$厘米的木料。你的工作就是从你的主木块上切下这些木块。你应该怎么做呢？

如果你只是为每个请求精确地切出所需尺寸，你剩下的木料很快就会变成一堆零散、尺寸不一的边角料。你可能总共还有$512$厘米的木料，但它可能分散在十个不同的碎块中，这使得你无法满足下一个需要一整块$512$厘米木板的顾客。这种混乱就是计算机科学家所说的**碎片化**。[内存管理](@entry_id:636637)的挑战，其核心正是这个木匠的困境：我们如何划分资源，才能既高效又为未来保留选择的余地？

### 对半分割的优雅：[伙伴系统](@entry_id:637828)

大自然常常在简单中找到优雅的解决方案。如果我们给木匠施加一个简单、甚至近乎死板的规则呢？你唯一的工具是一把只能将任何木块*精确地对半切割*的锯子。仅此而已。这就是著名的分配策略——**2的幂次**或**[伙伴系统](@entry_id:637828)**（buddy system）——的核心思想。

让我们看看我们的木匠如何处理从$1024$厘米的木块中切出一块$400$厘米木料的请求。这个请求小于$1024$厘米，但大于$512$厘米（$1024/2$）。所以，木匠不能简单地将它对半切。规则是，给予顾客*能够满足请求的最小可能*且属于我们“标准”尺寸之一的木块。现在，我们的标准尺寸只有2的幂次：$1024$、$512$、$256$、$128$等等。为了满足$400$厘米的请求，木匠必须选择$512$厘米的标准尺寸。

他如何得到一块$512$厘米的木料呢？很简单：他拿起$1024$厘米的木块，将其对半切开。现在他有两块$512$厘米的木料。一块交给顾客，另一块则被放入$512$厘米木料的“空闲堆”中。现在来了一个$90$厘米木料的请求。能满足该请求的最小[标准尺](@entry_id:157855)寸是$128$厘米。为了得到这个尺寸，木匠拿起那块空闲的$512$厘米木料，将其对半切，得到两块$256$厘米的木料。他把其中一块放到“256厘米空闲堆”里，拿起另一块。他又把*那一块*对半切，得到两块$128$厘米的木料。一块交给顾客，另一块则进入“128厘米空闲堆”[@problem_id:3644110]。

这个过程被称为**分割**。这是一个优美的、递归的级联过程。为满足一个请求，我们找到足够大的最小2的幂次块。如果我们没有那种尺寸的块，我们就找下一个更大的尺寸，将其分割，把它的“伙伴”添加到相应的空闲列表中，然后重复这个过程，直到我们得到所需的尺寸[@problem_id:3275207]。

但真正的魔力发生在顾客归还木块时。假设那块$128$厘米的木料被归还了。木匠把它放回空闲堆。然后他检查：它的“伙伴”——即当初与它一同被分割出来的*另一块*$128$厘米木料——是否也在空闲堆里？如果是，他就把它们“粘合”在一起，这个过程称为**合并**，以重新形成原来的$256$厘米木块。接着他会检查*这块*木料的伙伴是否空闲，依此类推，递归地向上合并。

系统如何知道一个块的伙伴在哪里？通过一个极其优雅的[计算机算术](@entry_id:165857)技巧。在[计算机内存](@entry_id:170089)中，如果一个大小为$2^k$的块起始于内存地址$a$，那么它的伙伴总是位于地址$a \oplus 2^k$处，其中$\oplus$是[按位异或](@entry_id:269594)（XOR）操作。仅凭这一个快如闪电的计算，就能在这个分割与合并的宇宙之舞中找到一个块的伴侣。整个系统是完全[自组织](@entry_id:186805)的，不断尝试恢复尽可能大的连续空闲块。

### 简单的代价：[内部碎片](@entry_id:637905)

当然，天下没有免费的午餐。2的幂次规则的刻板性是有代价的。当一个顾客请求一块$400$厘米的木料时，我们给了他们一个$512$厘米的木块。多出来的$112$厘米是他们木块的一部分；它被分配了，但未使用。这种浪费被称为**[内部碎片](@entry_id:637905)**，因为它位于已分配块的“内部”。

对于任何大小为$R$的请求，系统会分配一个大小为$B = 2^k$的块，其中$B$是大于或等于$R$的最小2的幂。这立即引出一个迷人而强大的保证。由于$B$是*最小*的此类块，下一个更小的尺寸必然太小了。也就是说，$B/2  R \le B$。

想一想这对浪费空间的分数$(B-R)/B$意味着什么。由于$R$总是大于$B$的一半，浪费的空间$B-R$必然总是*小于*$B$的一半。因此，碎片率总是严格小于$0.5$，即$50\%$。最坏的情况发生在有人请求一个刚好超过2的幂次的尺寸时，例如，请求$257$字节，这需要一个$512$字节的块，几乎浪费了一半的空间[@problem_id:3251687]。这是一个由简单规则产生的优美数学确定性。

虽然最坏情况下的浪费可以接近$50\%$，但这并非全部。如果请求的大小或多或少是随机[分布](@entry_id:182848)的，平均情况会好得多。在某些关于请求大小[分布](@entry_id:182848)的合理假设下，预期的[内部碎片](@entry_id:637905)率结果仅为$25\%$，即$\frac{1}{4}$[@problem_id:3644675]。在某些特定但有趣的场景中，碎片率可以收敛到其他值，如$\frac{1}{3}$[@problem_id:3239082]。通过理解这些边界——最坏、平均和特定情况——我们能对系统的行为及其内在权衡获得深刻的直觉[@problem_id:3628282] [@problem_id:3624858]。

### 机器中的幽灵：[外部碎片](@entry_id:634663)

[伙伴系统](@entry_id:637828)被设计用来通过勤奋地合并空闲块来对抗碎片化。但它无法消除一个更微妙的恶魔：**[外部碎片](@entry_id:634663)**。这种情况发生在你拥有足够的总空闲内存来满足一个请求，但这些内存并不在一个连续的块中。

想象一下，我们的空闲内存由两个独立的$256$ KiB块组成。我们总共有$512$ KiB的空闲内存。现在，一个$512$ KiB块的请求到来了。我们无法满足它。[伙伴系统](@entry_id:637828)会寻找一个空闲的$512$ KiB块，但找不到。然后它会寻找一对空闲的$256$ KiB伙伴块进行合并。但如果我们的两个空闲块不是伙伴呢？如果它们来自原始分割的不同分支呢？它们就无法被合并。请求失败。

这个场景被称为**伙伴被钉住问题**（pinned buddy problem），是[伙伴系统](@entry_id:637828)的阿喀琉斯之踵。一个分配可能会在内存中“钉住”一个块，阻止它的伙伴（即使已被释放）被合并。随着时间的推移，内存空间可能变成一个由小的、已分配的块组成的拼凑图，阻止了更大连续区域的形成[@problem_id:3644905]。

这不仅仅是一个理论上的担忧；这是内核开发者的噩梦。现代[操作系统](@entry_id:752937)为各种各样的任务管理内存。其中一些，如执行直接内存访问（DMA）的硬件设备，需要大块的、*物理上连续的*内存。另一些，如为文件或网络连接创建元数据，可能需要数千个微小的、持久的分配。这些小分配由另一个系统（如**[slab分配器](@entry_id:635042)**）管理，而它们所需的页面则来自底层的[伙伴系统](@entry_id:637828)。随着这些小对象的长期存在，它们散布在地址空间中，像钉子一样，使页面级的空闲列表变得碎片化。最终，系统可能会发现自己无法为一个关键的硬件操作分配一个大的连续块，即使总的空闲内存很充裕[@problem_id:3652209]。

### 单一规则的统一力量

2的幂次原则是一个优美的例子，展示了一个单一、强有力的约束如何贯穿整个系统设计，简化它并定义其特性。因为所需的分配大小总是在开始任何搜索*之前*向上取整到2的幂，所以更通用的分配策略，如“最佳适配”（找到能容纳的最小空洞）和“最差适配”（找到最大的空洞），其结果变得完全相同。它们都被迫去寻找一个相同、预定的2的幂大小的块[@problem_id:3644110]。

然而，正是这种简单性在面对现代复杂性时暴露了其局限性。在多核处理器上，一个由单一全局锁保护的简单[伙伴分配器](@entry_id:747005)会成为一个严重的瓶颈。所有$8$个、$16$个甚至$64$个处理器核心都必须排成一个队来请求内存，这摧毁了多核硬件所承诺的并行性。无论你增加多少核心，分配的最大速率都变得固定不变[@problem_id:3654547]。

这并非2的幂思想的失败，而是它在一个更大生态系统中所处位置的标志。它是管理内存块的一个杰出、基础的构建模块。但是，要为现代[操作系统](@entry_id:752937)构建一个高性能的内存管理系统，它必须与其他更专门化的机制——比如[slab分配器](@entry_id:635042)——相结合，以解决其在细粒度碎片化和[多核可扩展性](@entry_id:752268)等领域的缺点。发现之旅并非终结于一个优雅的解决方案，而是始于它。

