## 引言
排队是人类一种普遍的经历，这个看似混乱的过程支配着从我们日常通勤到互联网[信息流](@article_id:331691)的一切。要理解、预测和改善这些系统，我们需要的不仅仅是直觉，还需要一种形式化的语言。这正是肯德尔表示法的作用，它是一个强大而简洁的描述系统，是任何涉及等待和服务过程的通用蓝图。它提供了一种结构化的方法来剖析队列的复杂性，并揭示其潜在的数学特性。

本文将作为您学习这门基本语言的指南。在第一章**原理与机制**中，我们将解构该表示法本身，探索定义到达模式、服务时间和服务台数量的核心三元组 A/B/c，以及捕捉系统容量和服务规则的扩展形式。在第二章**应用与跨学科联系**中，我们将看到该表示法的实际应用，从呼叫中心和机场等经典例子，到细胞生物学微观世界中令人惊讶而深刻的应用，揭示了支配不同尺度下流动和拥塞的普适原理。

## 原理与机制

如果你想了解自然，或者一个你亲手构建的复杂系统，你必须首先学习它的语言。为了理解高速公路上[车流](@article_id:344699)的潮起潮落，物理学家写下[运动方程](@article_id:349901)。为了理解[化学反应](@article_id:307389)，化学家写下化学式。而为了理解无处不在的排队现象，我们也需要一种自己的语言。这正是伟大的 David Kendall 赋予我们的：一种极其紧凑而强大的表示法，一种[排队系统](@article_id:337647)的“化学式”。它不仅仅是一套枯燥的标签，更是一个简短的故事，描述了等待队伍的本质特征，从其到达的节奏到其服务的规则。

### 核心三元组：A/B/c

任何[排队系统](@article_id:337647)的核心都有三个基本问题：“顾客”如何到达？他们的“服务”需要多长时间？有多少“服务台”为他们服务？**肯德尔表示法**的前三个符号 A/B/c 精确地回答了这些问题。它们构成了[排队系统](@article_id:337647)的 DNA。

#### A：到达的节奏

首先，我们看入口。人、数据包或零部件是如何到达的？它们是稳定、可预测地到来，还是随机、不可预测地爆发式到来？这正是代表“到达”（Arrivals）的“A”所要告诉我们的。

在这个领域中，最重要的到达模式是一种完全由偶然性支配的模式，即过去对未来没有任何影响。想象一下，你正在等一辆随机时间到达的城市公交车。你已经等了10分钟这个事实，完全不能提供任何关于公交车在下一分钟内是否更有可能或更不可能到达的信息。这种奇特的性质被称为**[无记忆性](@article_id:331552)**，此类到达事件之间的时间间隔遵循**指数分布**。由于伟大的数学家 Andrei Markov 是研究此类过程的先驱，我们用字母 **M** 来表示**马尔可夫性**（Markovian）。一个在任何时间间隔内到达数量遵循[泊松分布](@article_id:308183)的过程，其到达事件之间的间隔时间将呈[指数分布](@article_id:337589)。

当然，生活中的并非所有事物都如此“健忘”。有时，到达是高度结构化的。考虑一条自动化装配线，每隔30秒就有一个新物品出现在传送带上。这是完全可预测的，即**确定性的**（Deterministic），我们用 **D** 来表示。

那么其他所有情况呢？如果到达模式是随机的，但并非那种特殊的无记忆方式呢？例如，在银行的ATM机前，人们可能在白天零星到达，但在办公室下班后立刻蜂拥而至 [@problem_id:1338310]。自上一个人到达以来的时间确实会影响下一个人可能何时出现。对于所有既非完全无记忆又非完全确定性的情况，我们使用一个包罗万象的符号 **G**，表示**通用**（General）分布。

这个“G”比它看起来更有趣。它不是承认无知，而是对现实世界复杂性的诚实描述。想象一下，一个医疗诊所为了有序，将预约安排在精确的15分钟间隔。你可能会认为这是一个“D”系统。但人不是机器！有些人早到，有些人迟到。一个病人走进诊所和下一个病人走进来的实际时间间隔，现在是固定预约间隔和两个随机偏差的组合。这打乱了完美的预测性，最终的[到达间隔时间](@article_id:324135)分布不再是确定性的，也不是无记忆的。它变成了一个通用过程，一个 G [@problem_id:1290555]。

有时，“G”过于模糊，我们可以更具体一些。想想流向服务器的互联网流量。传入请求的速率可能会在夜间的“低流量”状态和白天的“高流量”状态之间切换。这不是一个具有单一恒定平均速率的简单“M”过程。它是一种特殊类型的结构化过程，称为**马尔可夫[调制](@article_id:324353)泊松过程（MMPP）**，我们可以在表示法中使用这个更具描述性的标签来讲述一个更丰富的故事 [@problem_id:1290551]。

#### B：服务的故事

一旦顾客到达服务台，一个新的时钟开始计时：服务时间。我们表示法中的“B”描述了服务时间的性质，它使用的语言与[到达过程](@article_id:327141)相同。

如果服务时间也是无记忆的，那么它就是**马尔可夫的（M）**。这听起来可能很奇怪。如果你30分钟的理发已经进行了一半，你剩下的时间可不是30分钟！但对于许多事务来说，这是一个惊人地好的模型。想一想技术支持电话，问题的解决方案可能在任何时刻被找到，无论通话已经持续了多久。或者考虑一次 ATM 交易，它可能涉及一系列独立的步骤；完成剩余步骤的时间不取决于前几个步骤花了多长时间 [@problem_id:1338310]。

如果服务是一个固定时长的任务，比如45秒的自动洗车周期，那么它就是**确定性的（D）**。

与[到达过程](@article_id:327141)一样，如果服务时间遵循任何其他复杂的、非[无记忆性](@article_id:331552)的随机模式，我们将其归类为**通用的（G）**。修复错误的软件开发人员就是一个很好的例子。每个错误都可[能带](@article_id:306995)来独特的挑战，修复一个错误的时间可能很短，也可能长得令人痛苦，遵循某种复杂的[概率分布](@article_id:306824)，而这绝对不是无记忆的 [@problem_id:1290562]。

同样，我们可以深入“G”的内部寻找更多结构。考虑一台在工作时会随机发生故障的制造机器 [@problem_id:1290558]。一个零件在服务中花费的总时间不仅仅是处理时间；它是一个穿越一系列状态的旅程：“正在处理”，然后“机器故障”，然后“机器正在维修”，再回到“正在处理”。这个多阶段的历程导致了总服务时间肯定不是[指数分布](@article_id:337589)的。它属于一类更具体、高度结构化的分布，称为**相型（PH）**分布，这是 G 的一个非常强大和具体的分支。

#### c：流动的通道

我们核心三元组的第三部分“c”，是最直接的：它是并行服务台的数量。如果只有一台 ATM，$c=1$ [@problem_id:1338310]。如果一个急诊室有 $c$ 名医生值班，所有医生都能治疗任何到来的病人，那么我们就有 $c$ 个服务台 [@problem_id:1290577]。

但在这里，我们发现了一点物理学家的巧思。如果“服务”仅仅是占据一个空间呢？想一想一个小型博物馆，根据消防法规严格限制 $K$ 名参观者。每个进入的参观者都在“接受服务”，直到他们离开。这里没有传统意义上的“服务台”；博物馆中 $K$ 个可用的位置*就是*服务通道。在这种情况下，服务台的数量是 $c=K$ [@problem_id:1290560]。类似地，对于一个可以同时容纳 $C$ 名玩家的在线游戏，服务台的数量是 $c=C$ [@problem_id:1290552]。这个优雅的概念飞跃使我们能够为更广泛的[系统建模](@article_id:376040)。

### 增加现实世界约束：K 和 D

基本的 A/B/c 表示法为我们提供了坚实的基础，但现实世界充满了限制和规则。一个真正具有描述性的语言也必须能捕捉到这些。这就是为什么表示法经常扩展为 A/B/c/K/D。

#### K：还有空间吗？容量和损失

符号 **$K$** 代表系统的总容量——服务中的位置数量加上等待队列中的位置数量。默认情况下，如果未提及“K”，我们假设它是无限的。但等候室很少是无限的。

考虑一个新潮的“幽灵厨房”，只有一个厨师，没有订单等待区。在线系统只有在厨师有空时才接受订单。如果厨师正忙，新订单就会被直接拒绝 [@problem_id:1290525]。这里，有一个服务台（$c=1$）和零个等待位置。因此，系统总容量 $K$ 是 $1+0 = 1$。这是一个 `M/M/1/1` 系统。任何在系统满员时到达的顾客都会被永远失去。这是一个经典的**损失系统**。

博物馆和游戏服务器的例子是这种情况的通用版本：一个 `M/M/c/c` 系统 [@problem_id:1290560] [@problem_id:1290552]。有 $c$ 个服务通道和 $c$ 的总容量，意味着根本没有队列。这是用于设计电话网络的基本模型；如果所有线路都忙，你的电话就会被挂断。

当然，系统也可以有一个有限的等候室。一个开发人员的任务列表最多可以容纳 $K$ 个项目——一个正在处理，$K-1$ 个在缓冲区等待。这将是一个 `M/G/1/K` 系统 [@problem_id:1290562]。

#### D：下一个是谁？游戏规则

最后，从队列中选择下一个人的规则是什么？这就是排队**规则（Discipline, D）**。默认规则是**先进先出（FIFO）**，也称为先到先服务（FCFS），它如此普遍以至于我们常常不加说明。这是公平的文明规则。

但其他规则也存在，并且在某些情况下可能更有效率。程序员可能会发现最好先处理最近提交的任务，也许因为它与他们刚刚完成的工作相关。这是一种**后进先出（LIFO）**规则，就像从一叠盘子顶部取一个盘子一样 [@problem_id:1290562]。

与FIFO最截然不同的是**[优先队列](@article_id:326890)**。急诊室是完美的、直观的例子 [@problem_id:1290577]。病人不是按照他们到达的顺序接受治疗；他们被分诊，危重病人在非危重病人之前得到救治。在这里，表示法本身开始显示其局限性。我们可以添加一个像“PR”这样的符号来表示优先，但我们通常需要用几句自然语言来解释细节：这种优先是“抢占式”的（医生放下非危重病人去救治危重病人）还是“非抢占式”的（当前病人总是先完成治疗）？这表明肯德尔表示法是故事的开始，而不是结束。

### 超越基础：一个活的表示法

这种表示法的真正美妙之处在于其灵活性——它能够演化以描述更微妙和复杂的现实。

想一想一个现代电动汽车充电站 [@problem_id:1290527]。充电站的电网是共享的，所以插入充电的汽车越多，每辆车的充电速度就越慢。这是一个具有**状态依赖服务率**的系统。你可能认为这会使“B”符号复杂化，但为每辆车充电的底层物理过程可能仍然是无记忆的。任何*一*辆车完成充电的时间仍然是一个指数[随机变量](@article_id:324024)，但该指数分布的*速率*参数会根据当前充电的汽车数量而变化。因此，通过一种美妙的微妙之处，我们仍然可以将其归类为 `M/M/C` 系统，但要理解服务率 $\mu$ 不是一个常数，而是系统状态的函数。该表示法捕捉了随机性的基本性质，而这才是最重要的。

因此，肯德尔表示法不仅仅是一个分类方案，它还是一个分析工具。它是物理学家看待一个混乱、拥挤的系统，并看到其流动背后优雅、基本原理的方式。它是驯服队列的第一步——将一个棘手的问题转化为一个我们可以理解、预测并最终设计得更好的数学故事。