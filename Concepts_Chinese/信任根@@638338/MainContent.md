## 引言
在我们的数字世界中，软件本质上是易变的，可能被损坏或被恶意替换。如果计算机运行的第一个代码就遭到破坏，那么后续的任何安全措施都无法被认为是可靠的。这就产生了一个根本性问题：在一个由可变代码构建的系统中，我们如何建立一个绝对的、不可更改的信任起点？本文将通过探讨**信任根 (RoT)** 的概念来应对这一挑战，信任根在数字世界中等同于一个终极的物理标准。

以下章节将全面概述这一关键的安全基础。在“原则与机制”中，我们将深入探讨信任的硬件起源，探索不可变代码如何通过[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)等过程，启动一条加密的“[信任链](@entry_id:747264)”。我们将审视这条链是如何构建、维护和防御攻击的。随后，在“应用与跨学科联系”中，我们将看到这些原则在现实世界中的应用，它们保护着从个人计算机、云基础设施到网络通信，乃至科学研究完整性的方方面面。我们首先从构成这整个信任结构的核心机制开始。

## 原则与机制

你如何知道一把尺子是一米长？你可能会将它与另一把更可信的尺子进行比较。但那把尺子呢？再之前的那把呢？在某个点上，这条比较链必须终结。它终结于巴黎附近的国际计量局，那里有一根铂铱合金棒，根据定义，它*曾是*一米。它是终极标准，是评判所有其他“米”的基准。它是长度的信任根。

我们的数字世界迫切需要一个类似的基准。软件，就其本质而言，是易变的。它可以被更改、更新、损坏或替换为恶意软件。如果计算机执行的最初指令是不可信的，那么之后的一切都无法被信任。整个安全大厦都会崩塌。因此，要构建一个安全的系统，我们必须找到那个铂铱合金棒在数字世界的等价物：一个绝对且不可更改的信任起点。这就是**信任根**。

### 不可动摇的起点

在芯片的世界里，我们的信任基石不能用[贵金属](@entry_id:189233)锻造，而必须源于一个不可变的原则：代码存储在出厂后无法被修改的介质中。这就是我们的**硬件信任根**。通常，它以一小块直接[蚀刻](@entry_id:161929)在处理器芯片上的**[只读存储器](@entry_id:175074) (ROM)**，或一组只能烧录一次且永不改变的**一次性可编程 (OTP) 熔丝**的形式存在 [@problem_id:3628964]。

这段初始代码，通常称为引导 ROM，根据定义是可信的。然而，它的任务不是成为整个[操作系统](@entry_id:752937)——它太小、太简单了。它唯一且关键的使命是验证引导链中的下一个环节。这开启了一个称为**[安全启动](@entry_id:754616)**的过程，该过程建立在一个简单而深刻的原则之上：**先验证，后执行**。

想象一个简单的处理器启动。复位时，一个硬件开关，我们称之为 `fetch_en` [触发器](@entry_id:174305)，被强制置为零。这从物理上阻止了处理器的指令获取单元从可能存有恶意代码的外部存储器中抓取指令。处理器只被允许执行其内部 ROM 中的不可变代码。这段 ROM 代码随后充当一个守门人。它从外部存储（如闪存芯片）中读取第一阶段[引导加载程序](@entry_id:746922)，但仅将其视为数据，而非可执行指令。然后，它执行一次加密校验。当且仅当[引导加载程序](@entry_id:746922)被验证为真实可信后，ROM 代码才会将 `fetch_en` 开关翻转为一，允许处理器开始执行现在已受信任的代码 [@problem_id:3645382]。无论多么复杂，每一个[安全启动过程](@entry_id:754617)都是这一基本主题的变体。

### 铸造[信任链](@entry_id:747264)

ROM 执行的加密校验是我们所说的**[信任链](@entry_id:747264)**中的第一个环节。ROM 内部嵌入了一个**公钥**，如同一个独特的锁。软件供应商（例如，计算机或[操作系统](@entry_id:752937)的制造商）持有相应的**私钥**，这是他们最严加保管的秘密之一。当他们制作一个软件（如[引导加载程序](@entry_id:746922)）时，他们会为其创建一个独特的数字指纹，称为**加密哈希**。然后，他们用私钥“签名”这个哈希值，从而生成一个**[数字签名](@entry_id:269311)**。

签名、[引导加载程序](@entry_id:746922)及其哈希值被打包在一起。引导 ROM 的验证过程如下：
1.  它独立计算刚刚加载的[引导加载程序](@entry_id:746922)的哈希值。
2.  它使用存储在不可变存储器中的公钥来检查所提供的签名对于它刚刚计算的哈希值是否有效。

由于[公钥密码学](@entry_id:150737)的数学魔力，只有当签名是由供应商的私钥创建，并且[引导加载程序](@entry_id:746922)没有被改动过哪怕一个比特时，签名才会有效。如果校验通过，信任就建立了。引导 ROM 随即将控制权移交给[引导加载程序](@entry_id:746922)。

这个[引导加载程序](@entry_id:746922)，现在已受信任，重复完全相同的过程。它包含用于验证下一阶段（可能是主[操作系统内核](@entry_id:752950)）的公钥。内核在被验证并运行后，也对其驱动程序和关键组件执行同样的操作。每个阶段在移交控制权之前都会验证下一个阶段，从而创建一条从硬件信任根的不可变芯片一直延伸到完整运行的[操作系统](@entry_id:752937)的、不间断的加密验证链 [@problem_id:3664845]。核心设计目标是让这条链的初始环节——执行验证的组件——尽可能小而简单。这组绝对必须正确的组件被称为**[可信计算基 (TCB)](@entry_id:756202)**，最小化 TCB 是优雅安全设计的标志，因为它极大地减小了系统的“攻击面” [@problem_id:3664845] [@problem_id:3679593]。

### 信任的两大支柱：强制执行与报告

[安全启动](@entry_id:754616)，这条验证链，充当了一个强大的守门人。它*强制执行*一条策略：只有真实的、经过签名的代码才能运行。但如果代码是真实的，但被赋予了恶意的配置，该怎么办？

思考一个思想实验。攻击者获取了[引导加载程序](@entry_id:746922)配置文件的访问权限，并向内核添加了一条命令行指令，如“禁用所有安全策略”。[引导加载程序](@entry_id:746922)本身是完美签名的。内核也是完美签名的。[安全启动](@entry_id:754616)会检查两个签名，发现它们都有效，然后愉快地将系统引导到一个不安全的状态。守门人尽了职，但入侵者早已在宾客名单上 [@problem_id:3679609]。

这揭示了仅靠强制执行的局限性。我们需要信任的第二大支柱：报告。这就是**[度量启动](@entry_id:751820)**的领域。[度量启动](@entry_id:751820)的目标不是简单地阻止恶意软件，而是生成一份关于*究竟*运行了什么软件（无论好坏）的、不可伪造的记录。它不像一个保镖，更像一个一丝不苟的法庭记录员。

这个过程的主角是一个专门的硬件芯片，称为**[可信平台模块 (TPM)](@entry_id:756205)**。TPM 包含一组特殊的寄存器，称为**平台配置寄存器 (PCR)**。在[度量启动](@entry_id:751820)期间，一个组件在被执行之前，当前阶段会通过计算其加密哈希值来“度量”它。然后，它将这个哈希值发送给 TPM。[TPM](@entry_id:170576) 不仅仅是存储哈希值，它执行一个巧妙的单向操作，称为**扩展 (extend)**。它将新的度量值 ($m$) 与 PCR 的当前值结合起来，并对结果进行哈希计算，用这个新值更新 PCR：

$$
\mathrm{PCR}_{\text{new}} \leftarrow H(\mathrm{PCR}_{\text{old}} \parallel m)
$$

其中 $\parallel$ 表示[串联](@entry_id:141009) [@problem_id:3628964]。这个过程的美妙之处在于其历史被嵌入到最终值中。最终的 PCR 值是*整个度量序列*以*确切顺序*发生的加密摘要。如果任何组件的单个比特被更改，或者引导顺序被改变，最终的 PCR 值将完全不同。

两者的区别至关重要：
-   **[安全启动](@entry_id:754616)** *阻止*系统引导到未经授权的状态。它是一种预防性控制。
-   **[度量启动](@entry_id:751820)** *记录*系统引导进入的状态，以便后续检测。它是一种检测性控制 [@problem_id:3679563]。

远程服务随后可以请求 TPM “证明”其状态。TPM 使用一个独特的、受[硬件保护](@entry_id:750157)的证明密钥来签署其当前的 PCR 值，并将这个签名的报告（称为**签注 (quote)**）发送给该服务。服务可以验证该报告，并决定该计算机是否足够可信以连接到其网络。如果攻击者修改了内核命令行，[安全启动](@entry_id:754616)会毫无察觉，但[度量启动](@entry_id:751820)会记录下恶意字符串，PCR 值会改变，[远程证明](@entry_id:754241)会失败，从而暴露篡改行为 [@problem_id:3679609] [@problem_id:3688014]。

### 现实世界：更新与攻击

一个无法更新的安全系统是一个死气沉沉的安全系统。两个现实世界的挑战立即出现：漏洞和密钥泄露。

如果供应商发布了签名的 1.0 版本固件，发现了一个漏洞，并发布了修补后的 2.0 版本，会发生什么？攻击者可以简单地拿出旧的、但仍然有效签名的 1.0 版本并将其提供给设备。签名是正确的，所以[安全启动](@entry_id:754616)会接受它。这是一种**回滚攻击**。解决方案是另一件单向硬件：一个**单调计数器**，通常由 OTP 熔丝构成。每个签名的软件都带有一个版本号。设备在其单调计数器中存储它所见过的最高版本号。它将拒绝任何版本号低于其存储值的软件。当它接受一个更高的新版本时，它会永久性地增加计数器，从而防止未来任何回滚到旧版本的行为 [@problem_id:3631332] [@problem_id:3645389]。

如果发生了不可想象的事情，供应商的私有签名密钥被盗了怎么办？ROM 中公钥的[不可变性](@entry_id:634539)现在变成了一个弱点。解决方案是为敏捷性而设计。ROM 密钥可能不直接验证[操作系统](@entry_id:752937)，而是验证一个小的、可更新的[引导加载程序](@entry_id:746922)，其工作是管理一个**密钥环**。为了授权一个新的内核签名密钥，供应商发布对该密钥环的更新，该更新由原始 ROM 密钥签名。在过渡期间，软件可以被新旧密钥**双重签名**，以确保现场的所有设备都能成功更新，之后再最终撤销被泄露的密钥。这将[信任链](@entry_id:747264)从一根刚性的杆子转变为一个灵活的、有生命力的实体 [@problem_id:3631332]。

我们对这整个优雅的[密码学](@entry_id:139166)之舞所寄予的信任并非盲目信仰，而是有数学基础的。对于一个典型的 $L=128$ 位的签名或 MAC 标签长度，攻击者随机猜中有效标签的概率是 $2^{-128}$，这个数字小到在物理上毫无意义 [@problem_id:3679555]。我们的安全不依赖于攻击者运气不好，而是依赖于他们无法逾越[概率法则](@entry_id:268260)。真正的风险不在于破解[密码学](@entry_id:139166)，而在于在实现中找到缺陷——[可信计算基](@entry_id:756201)自身的裂缝。这就是为什么硬件信任根和最小化 TCB 的原则是构建所有现代平台安全的不可动摇的基石。

