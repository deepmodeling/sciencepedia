## 引言
待测器件 (DUT) 的概念几乎是所有科学和工程领域的基础。它是我们试图理解、验证或表征其行为的特定组件、电路或系统。然而，在这一追求中出现了一个重大且普遍的挑战：我们永远无法在完美隔离的环境中观察 DUT。每一次测量都会受到所用工具的影响，从而形成器件及其测试环境的复合视图。因此，测试的艺术，就是将器件本身的行为与其观测过程产生的人为现象区分开来的艺术。

本文探讨了工程师为克服这一根本问题而开发的各种复杂方法，其路径从数字仿真的虚拟世界延伸到高频[模拟电路](@entry_id:274672)的物理现实。通过理解这些技术，您将深入了解我们如何确信一个器件能按预期工作，无论它是一段代码还是一块硅片。接下来的章节将引导您完成这一旅程。“原理与机制”一章将通过剖析数字测试平台的架构、仿真时间的复杂性以及自动验证的逻辑来奠定基础。随后，“应用与跨学科联系”一章将把视野扩展到物理硬件，探索使用 JTAG 进行的[板级测试](@entry_id:167070)、模拟噪声测量的挑战，以及优雅的去嵌数学艺术——它让我们能够透过测试夹具的“幽灵”看到 DUT 的真实面目。

## 原理与机制

想象一下，您想了解一台新设计的汽车引擎是如何工作的。您不会只盯着蓝图看，而是想亲眼看它运转。您会搭建一个测试台，接上燃油管，连接传感器，然后让它经历各种工况——怠速、加速、负载运行。引擎本身是主角，但整个测试台——燃油、传感器、测功机——才是使有意义的测试成为可能的原因。

在数字逻辑的世界里，同样的原理也适用。我们想要验证的芯片或电路就是我们的“引擎”，我们称之为**待测器件 (DUT)**。但要测试它，我们必须围绕它构建一个虚拟世界。这个世界本身就是一段复杂的代码，称为**测试平台 (testbench)**。它集我们的实验室、测试台和试验场于一体。测试平台的根本目的，是创建一个受控的、可重复的环境，以便我们能驱动 DUT 并观察其行为。

### 舞台与演员：盒子里的宇宙

验证的第一步是将我们的 DUT，即“演员”，放置到测试平台的“舞台”上。在像 [Verilog](@entry_id:172746) 这样的硬件描述语言 (HDL) 中，这个过程称为**实例化 (instantiation)**。实际上，我们是在将 DUT 设计的一个实例召唤到测试平台的仿真现实中。测试平台通常是一个“顶层”模块；它是一个自包含的宇宙，不需要外部输入或输出，因为它在内部生成一切 [@problem_id:1975493]。

但这个宇宙如何与 DUT 互动？我们如何向它发送信号，又如何监听它的响应？这需要两种不同类型的连接，这是一种反映信息流动的优美二元性。

首先，要向 DUT 发送信号，我们需要一种可以保持值并根据我们的命令进行改变的东西。可以把它想象成一组我们的测试脚本可以拨动的开关或按钮。在 [Verilog](@entry_id:172746) 中，这是一种 **`reg`** (寄存器) 类型。我们在测试平台中声明 `reg` 变量，并将它们连接到 DUT 的输入端口。因为 `reg` 可以存储一个值，所以我们可以随时间程序化地为其赋值，从而创建驱动 DUT 的动态激励。

其次，要观察来自 DUT 的信号，我们需要一种不同的工具。我们需要一种像电压表探针一样的东西——它本身不产生信号，但被动地报告它所接触的任何东西的值。这就是 **`wire`**。我们声明 `wire` 变量，并将它们连接到 DUT 的输出端口。`wire` 将持续反映 DUT 输出的状态，让我们能够随时看到我们的“演员”在做什么 [@problem_id:1966485]。

因此，其基本架构是 `reg` 和 `wire` 之间的一场双人舞：我们使用 `reg` 来“对”DUT 说话，使用 `wire` 来“听”DUT 的声音。这种简单而强大的区别构成了每个测试平台的支柱。

### 编写剧本：激励的艺术

当 DUT 就位、连接建立后，就该编写脚本了——即我们将要施加的一系列输入，或称**激励 (stimulus)**。测试不是一个单一的快照，而是一个在第四维度——时间——中展开的故事。测试平台使用延迟控制来控制仿真时间的流动，通常用 `#` 后跟一个时间单位数来表示。例如，`#10` 告诉仿真器在继续之前暂停 10 个单位时间。这使我们能够创建一个精确、定时的事件序列：在时间 $t=0$ 时，将输入设置为一种状态；等待 10 个时间单位；在 $t=10$ 时，改变一个输入；再等待 10 个单位时间；依此类推 [@problem_id:1912806]。

仿真的力量在于自动化。虽然我们可以手动写下每一个输入变化，但更优雅的方法是让测试平台自动生成它们。对于输入数量较少的电路，我们可以使用一个简单的 `for` 循环来遍历每一种可能的组合。如果一个 DUT 有 4 个输入，一个从 0 到 15 的循环可以系统地施加所有 $2^4 = 16$ 种输入向量，仅用几行代码就能确保详尽的覆盖 [@problem_id:1943460] [@problem_id:1966454]。

有时输入本身需要被构建。想象一下 DUT 需要一个 8 位数，但我们的测试平台逻辑处理的是两个独立的 4 位“半字节 (nibble)”。我们可以使用**拼接 (concatenation)** 运算符来动态组装最终的输入，该运算符就像胶水一样，将较小的向量组合成一个较大的向量。像 `{upper_nibble, lower_nibble}` 这样的表达式会创建一个 8 [位向量](@entry_id:746852)，这是测试平台如何在将数据呈现给 DUT 之前对其进行操作的完美示例 [@problem_id:1975478]。

随着测试变得越来越复杂，将这些激励向量直接硬编码到测试平台中会变得很麻烦。一个更强大、更灵活的策略是将测试*数据*从测试*逻辑*中移出。我们可以将长序列的输入向量存储在一个外部文本文件中。这样，测试平台的任务就变得更简单：从文件中读取一行，将其应用于 DUT，等待，然后重复。这种**数据驱动的方法**将测试场景与测试平台代码解耦，使工程师只需编辑一个文本文件就能编写新的测试，而无需接触验证环境本身 [@problem_id:1966483]。

### 评论家：构建一个自校验的宇宙

到目前为止，我们的测试平台一直是一个尽职的舞台监督，施加激励并让我们在波形查看器上观察结果。但这是一个手动过程。工程师仍然需要看着输出的 `sum` 和 `carry_out` 信号，然后判断：“是的，这是一个加法器的正确行为。” 验证领域的真正革命是创建**自校验测试平台 (self-checking testbench)**——一个不仅充当舞台监督，还充当无所不知的评论家的测试平台。

自校验测试平台的核心是**参考模型**（有时称为“黄金模型”）。这是测试平台中的一段代码，它独立地计算任何给定输入的*预期*正确输出。对于一个简单的 2-to-1 [多路选择器](@entry_id:172320)，参考模型可以是一行优雅的代码：`expected_y = (sel == 1) ? b : a`。这个表达式完美地模仿了 DUT 的指定行为 [@problem_id:1966497]。

有了参考模型，验证过程就成了一个闭环。测试平台施加一个输入，稍等片刻让 DUT 处理并产生输出，然后将 DUT 的实际输出与参考模型的预期输出进行比较。如果它们不匹配，就会自动标记一个错误。整个仿真可以运行，最终的输出是一个简单、明确的“通过 (PASS)”或“失败 (FAIL)”。

这个强大的思想可以与我们的数据驱动方法相结合。外部文本文件不仅可以包含输入激励，还可以包含每个输入向量的预计算预期输出。然后，测试平台的逻辑对每个测试用例都遵循一个清晰、精确的序列：
1. 从文件中读取输入向量和预期输出向量。
2. 将输入向量应用于 DUT。
3. 等待一个小的、固定的[传播延迟](@entry_id:170242)，以便 DUT 的逻辑稳定下来。
4. 将 DUT 的实际输出与从文件中读取的预期输出进行比较。
5. 如果它们不同，则报告错误。

这个“施加-等待-比较”的序列是自动化验证的基本算法 [@problem_id:1943489]。

对于高度复杂的系统，其中事务 (transaction) 可能被[乱序](@entry_id:147540)处理或涉及多个并发代理 (agent)，简单的比较是不够的。在这里，我们引入一个更复杂的组件：**记分板 (scoreboard)**。记分板作为事务的中央交换中心。测试平台中的监视器 (monitor) 向记分板报告 DUT 完成的“实际”事务。同时，参考模型报告“预期”事务。记分板的工作是将它们匹配起来。它可以处理[乱序](@entry_id:147540)到达的事务并跟踪所有内容。在仿真结束时，任何预期但从未出现的事务，或任何实际发生但从未预期的事务，都代表一个错误。记分板确保 DUT 应该做的所有事情都已完成，并且它没有做任何不该做的事情 [@problem_id:1976683]。

### 深入探讨：时间的隐藏机制

我们经常用像 `din = 5;` 这样的简单指令来命令我们的测试平台。我们想象这是瞬间发生的。但在一个运行在[串行计算](@entry_id:273887)机上的仿真中，“瞬间”到底意味着什么？当我们告诉 DUT 在“同一时间”改变其输入并检查其输出时，会发生什么？这个问题揭开了仿真器事件队列的帷幕——这是协调并行硬件执行假象的隐藏机制。

在 [Verilog](@entry_id:172746) 中，考虑两种类型的命令或赋值：
*   **阻塞赋值 (`=`):** 这是一个“立即执行”命令。仿真会暂停并完全执行此赋值，然后才移至下一行代码。它是串行的，就像食谱一样。
*   **[非阻塞赋值](@entry_id:162925) (`=`):** 这是一个“安排更新”命令。仿真器计算右侧的结果，但不会立即更新左侧的变量。相反，它会安排在当前仿真时间步的最后，在所有其他“立即执行”命令完成后再进行更新。

这种区别至关重要，因为它模仿了真实的硬件。[同步电路](@entry_id:172403)中的[触发器](@entry_id:174305)不会在其输入改变的瞬间改变其输出；它们都在时钟边沿采样输入，然后，稍后，所有[触发器](@entry_id:174305)一致地改变它们的输出。[非阻塞赋值](@entry_id:162925)是模拟这种并行行为的关键。

现在，想象一个打破此规则的测试平台。它使用*阻塞*赋值来改变 DUT 的输入，并在由时钟[边沿触发](@entry_id:172611)的同一个程序块中，立即检查 DUT 的输出。而 DUT 本身，作为一个同步流水线，正确地为其内部寄存器使用*非阻塞*赋值。于是，**[竞争条件](@entry_id:177665) (race condition)** 出现了。如果仿真器碰巧在该时钟边沿处，在 DUT 的代码块*之前*执行了测试平台的代码块，就会发生一个微妙的错误。测试平台驱动新的输入 (`din = 5`)。然后 DUT 执行并看到这个新输入。然而，DUT 的输出是基于一个内部寄存器的，该寄存器计划根据*前一个*周期的值进行更新。当测试平台采样输出时，它看到的是旧的、过时的值，导致一个看起来像是偏差了一个周期的验证失败 [@problem_id:1915861]。

为了解决这些竞争问题，System[Verilog](@entry_id:172746) 引入了**时钟块 (clocking blocks)**，它们旨在正式指定测试平台和 DUT 之间围绕时钟边沿的时[序关系](@entry_id:138937)。它们允许我们说：“在时钟边沿*前* 1ns 采样输入，并在时钟边沿*后* 2ns 驱动输出。”但即使是这种强大的抽象也有其微妙之处。如果我们指定一个 `output #0ns` 的偏斜 (skew)，我们的直觉可能会认为驱动发生在时钟边沿“处”。然而，语言标准将其定义为驱动发生在仿真时间步的一个特定阶段，该阶段在 DUT 已经为同一时钟边沿采样其输入*之后*。结果呢？DUT 仍然捕获旧值，我们的数据被错过了一个周期 [@problem_id:1915868]。

这段旅程，从将 DUT 放置在舞台上的简单行为，到仿真调度深奥的复杂性，揭示了一个深刻的真理。验证不仅仅是编写测试。它是构建完整、自洽的虚拟宇宙。要成功做到这一点，我们不仅必须是优秀的架构师，还必须是这些人工世界的物理学家，理解支配其行为的基本定律，直至最小的仿真时间量子。

