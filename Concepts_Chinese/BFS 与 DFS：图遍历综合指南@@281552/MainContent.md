## 引言
在计算机科学领域，许多复杂问题——从绘制互联网地图到解魔方——都可以通过将其视为一个由相互连接的点组成的网络，即图，来进行简化。但是，如何系统地探索这样一个网络而不会迷失方向呢？答案就在于两种基石[算法](@article_id:331821)：[广度优先搜索](@article_id:317036)（BFS）和[深度优先搜索](@article_id:334681)（DFS）。这些强大而优雅的策略为导航任何基于图的结构提供了基本蓝图。本文将揭开这两种方法的神秘面纱，探讨它们简单的底层机制如何导致截然不同的探索模式和应用。我们首先将深入探讨“原理与机制”，使用直观的类比和数据结构来解释 BFS 和 DFS 的工作方式。随后，在“应用与跨学科联系”部分，我们将探索它们在现实世界中的影响，发现这些[算法](@article_id:331821)如何帮助解决从网络管理、机器人学到[计算化学](@article_id:303474)等各个领域的问题。

## 原理与机制

### 探索迷宫：两种策略

想象一下，你正站在一个巨大而复杂的迷宫入口，目标是完整地绘制出它的地图。你可以采用两种基本策略。

第一种策略是谨慎而系统地扩张。你站在入口，派遣侦察员沿着从那里开始的每一条路径前进。你告诉他们只走一分钟，然后回来报告。当他们全部返回后，你就拥有了一张距离入口一分钟路程内所有区域的完美地图。然后，你再从他们的新位置派遣他们出去，指示他们再探索一分钟。你一波又一波地重复这个过程，系统地按同心层绘制迷宫。这就是**[广度优先搜索](@article_id:317036)（BFS）**的精神。你在深入之前先进行*广泛*的探索。

第二种策略是不懈的追寻。你选择一条路径，然后执着地沿着它走下去。你不断前进，在遇到岔路时做出选择，越来越深，直到走到死胡同。只有在那时，你才会回溯到上一个还有未探索选项的[交叉](@article_id:315017)口，然后一头扎进那条新路径。你在考虑从入口出发的另一条路径之前，会先将迷宫的一个分支完全探索完毕。这就是**[深度优先搜索](@article_id:334681)（DFS）**的精髓。你在扩大范围之前先进行*深入*的探索。

这两种简单直观的策略，代表了我们探索任何网络（无论是社交网络、互联网，还是计算机服务器之间的连接）的两种最强大、最基本的方法。

### 引擎室：队列与栈

我们如何将这些直观的策略转化为计算机可以遵循的精确[算法](@article_id:331821)呢？诀窍在于我们如何管理“待办列表”，即那些我们已经发现但尚未*从其出发*进行探索的顶点。

对于广度优先策略，我们需要按照发现的顺序来探索顶点。我们发现的第一个顶点应该是我们第一个从其出发探索的顶点。这是一个“先进先出”（FIFO）的原则。实现这一点的完美[数据结构](@article_id:325845)是**队列**，就像杂货店里的队伍一样。当我们处于一个顶点 $u$ 时，我们发现它的所有邻居，并将它们添加到队列的末尾。要决定接下来去哪里，我们只需服务队列头部的顶点。这种机制保证了我们在移动到更远一步的顶点之前，已经探索了距离起点特定“距离”的所有顶点。

现在，如果我们对这个机制做一个微小的改动呢？我们不用先进先出的队列，而是使用一个“后进先出”（LIFO）的待办列表。这就是**栈**，就像一叠盘子。当我们发现新的邻居时，我们将它们堆在栈顶。要决定接下来去哪里，我们从顶部取一个——也就是我们最近添加的那一个。这个简单的改变彻底改变了搜索的特性。通过总是探索最近发现的顶点，[算法](@article_id:331821)会沿着一条路径深入下去，将新顶点推入栈中并立即从它们出发进行探索，直到遇到死胡同，被迫弹回到一个较旧的顶点。这正是深度优先策略。[@problem_id:1483530]。

这两种深刻的探索方法之间的全部差异，归结为一个简单的机制选择：广度用队列，深度用栈。

### 发现的形状：繁茂的树与线性的树

当我们在一个连通图上运行 BFS 或 DFS 时，我们不仅仅是访问了所有的顶点；我们还创建了一张地图。这张地图是一棵**[生成树](@article_id:324991)**，一个包含所有顶点且仅用足够多的边保持所有部分连通而无环的子图。对于一个有 $n$ 个顶点的图，任何[生成树](@article_id:324991)都将总是有 $n-1$ 条边，无论它是如何形成的[@problem_id:1483535]。原始图中剩余的 $m - (n-1)$ 条边被称为**非树边**。

虽然边的数量是固定的，但树的*形状*却讲述了其创建的故事。

BFS 通过其逐层探索的方式，倾向于产生矮而宽，或称“繁茂”的树。根节点连接到它的直接邻居，这些邻居又连接到*它们的*直接邻居，依此类推。从根到任何节点的路径都尽可能短。想象一个服务器网络，我们想找到“总深度”（所有节点到根的路径长度之和）。BFS 树自然会产生较低的总深度。相比之下，在同一个图上的 DFS 树可能会创建一条连接服务器的、长而“线性”的路径，导致总深度大得多[@problem_id:1401691]。

这种差异可能是巨大的。在一个“[轮图](@article_id:335583)”（一个中心枢纽连接到一个环形边缘）上，从中心枢纽开始的 BFS 会立即找到所有环上的顶点。生成的树是一个高度仅为 1 的星形。相比之下，DFS 通过始终选择环上的下一个邻居，可以在完成之前沿着整个环蜿蜒前进，生成一棵对于 $N$ 个顶点的图而言，只是一条长路径，高度为 $N-1$ 的树[@problem_id:1483546]。

### 广度的保证：始终是最短路径

BFS 树的“繁茂”形状并非偶然；这是其最著名特性的体现。对于一个[无权图](@article_id:337228)，其中每条边的“成本”相同，BFS 树中从起始顶点 $s$ 到任何其他顶点 $v$ 的路径保证是原始图中的一条**[最短路径](@article_id:317973)**[@problem_id:1483517]。

为什么呢？回想一下逐层探索的过程。BFS 首先找到所有距离为 1 的顶点。然后，从这些顶点出发，它找到所有距离为 2 的*新*顶点，依此类推。一个距离为 $k$ 的顶点 $v$ *不可能*在所有距离为 $k-1$ 的顶点被完全探索之前被发现。因此，我们第一次到达 $v$ 时，必定是通过一条长度为 $k$ 的路径。不可能有更短的路径，否则我们会在更早的层中发现 $v$。

这个性质对 DFS 不成立。DFS 可能会走一条漫长曲折的路线到达一个顶点，而这个顶点可能有一条简单的捷径可以回到起点。这个根本性的差异导致了一个强大的不等式：对于任何图和起点，BFS 树的高度总是小于或等于相应 DFS 树的高度（$h_{BFS} \le h_{DFS}$） [@problem_id:1483528]。BFS 树的高度恰好是到图中距离最远顶点的距离，而 DFS 树可能要高得多。

### 深度的标志：返祖边的踪迹

如果说 BFS 是由其最短路径性质定义的，那么 DFS 的定义特征又是什么呢？我们发现它的标志不在于树边，而在于非树边——那些生成树不需要的捷径。

在[无向图](@article_id:334603)中，DFS 遍历中的每一条非树边都有一个特殊的性质：它总是将一个顶点连接到其在 DFS 树中的一个**祖先**。这些被称为**返祖边**。想一想：当 DFS 从一个顶点 $u$ 开始探索时，所有它仍然可以访问的顶点都在其“下方”的一个子树中。如果它遇到了一个*已经*被访问过的邻居 $v$，那么 $v$ 可能在哪里呢？由于 DFS 在转向另一个分支之前会完全探索一个分支，所以 $v$ 不可能在一个独立的、已完成的分支中。它必须在当前探索路径上位于 $u$ 的“上方”——也就是说，它必须是 $u$ 的一个祖先。

DFS 树永远不会有连接两个不同分支的“[交叉](@article_id:315017)边”。这个“无[交叉](@article_id:315017)”规则是 DFS 的独特指纹。另一方面，BFS 树则经常有连接同一层或相邻层顶点的非树边，因为它探索的是一个宽广的前沿。这个结构特性是如此可靠，以至于我们可以观察一棵给定的[生成树](@article_id:324991)及其非树边，并确定它*是否可能*是由 DFS 生成的[@problem_id:1483547]。

### 路径的交汇

鉴于这些截然不同的策略和由此产生的结构，人们可能会想，BFS 和 DFS 是否会产生相同的树。答案是肯定的，但只在图的拓扑结构基本上消除了任何选择的非常特殊的情况下。

考虑一个简单的路径图：一条由顶点 $v_1, v_2, \dots, v_n$ 组成的线。从 $v_1$ 开始，BFS 和 DFS 在每一步都别无选择，只能移动到线上的下一个顶点。队列和栈的行为完全相同，因为它们在任何时候都只包含一个顶点。结果是，两种[算法](@article_id:331821)都产生完全相同的生成树——即路径本身[@problem_id:1483515]。

即使在更复杂的图上，如果结构高度对称，遍历也可能相同。在一个[星形图](@article_id:335255)（一个中心枢纽连接到多个辐条）上，从中心开始，假设有一个一致的平局决胜规则（例如，首先访问标签最小的邻居），BFS 和 DFS 都会以相同的顺序逐一发现所有的辐条顶点。两者都会得到相同的星形树[@problem_id:1496196]。

这些特殊情况突显了最后也是最关键的一点：任何一种[算法](@article_id:331821)产生的确切树形都可能取决于访问邻居的顺序。例如，在一个环形图上，从一个顶点开始 DFS，第一步有两个选择——顺时针或逆时针。每个选择都会导致一棵不同但有效的 DFS 树。同样，在环形图上进行 BFS，根据两个等距的最终顶点中哪一个最后被发现，会产生两棵不同的树[@problem_id:1483510]。这种选择性提醒我们，这些不仅仅是抽象概念，而是其实际输出依赖于具体实现的[算法](@article_id:331821)。

从队列和栈之间的简单选择中，浮现出两种对图的截然不同的看法。一种给了我们最短的路线，另一种则是一条深邃曲折的路径。它们共同构成了我们导航塑造我们世界的[复杂网络](@article_id:325406)的基础。