## 引言
现代计算机的构建旨在保护秘密，然而，它们可能在软件代码未被直接攻破的情况下遭到破解。之所以可能，是因为计算并非一个抽象过程，而是一个物理过程，会在硬件上留下微弱、可测量的痕迹。[微架构](@entry_id:751960)旁路攻击正是利用了这些痕迹，将性能增强特性转变为安全漏洞。这些攻击挑战了我们对数字安全的基本假设，揭示了那些旨在使处理器更快的机制，同时也可能导致[信息泄露](@entry_id:155485)。

本文深入探讨了一种最基本、最强大的旁路攻击类型：Prime+Probe。它解决了处理器预期的体系结构行为与其真实存在的、会泄露信息的[微架构](@entry_id:751960)现实之间的关键知识鸿沟。您将了解到这些攻击如何运作，为何如此有效，以及它们如何揭示计算机体系结构中性能与安全之间深刻而持续的紧张关系。本文将首先解释 Prime+Probe 的基本原理和机制，然后探讨其广泛的应用和跨学科联系，揭示这一幽灵般的威胁如何萦绕在现代处理器的几乎每一个组件中。

## 原理与机制

要理解计算机如何在无意中泄露秘密，我们必须首先领会一个简单而美妙的事实：计算并非虚无缥缈的抽象过程，而是一个物理过程。每一次操作，每一个决策，都会在处理器的内部状态上留下短暂的印记，就像一个人走过房间会在布满灰尘的地板上留下脚印一样。通常情况下，这些脚印会被清理并消失，对最终结果没有影响。但如果它们没有消失呢？如果有人可以稍后进来，通过检查灰尘中的图案，弄清楚你曾去过哪里呢？这就是[微架构](@entry_id:751960)旁路攻击的核心思想。

### 机器中的幽灵：时机就是一切

想象一下，你计算机的处理器是一个工作室，而它的主存 (RAM) 是旁边一个巨大、杂乱的仓库。为了完成任何工作，处理器需要工具和材料（数据和指令）。它可以为所需的每一件东西都跑到仓库去取，但这会非常慢。因此，它在自己旁边维护了一个小巧、超快的工作台。这个工作台就是**高速缓存 (cache)**。

当处理器需要一块数据时，它首先检查高速缓存。如果数据在那里——即**缓存命中 (cache hit)**——它几乎可以瞬间获取。如果数据不在那里——即**缓存未命中 (cache miss)**——它必须长途跋涉到[主存](@entry_id:751652)仓库去取，并将其放在工作台上以备将来使用。关键的洞见在于：命中是快速的，而未命中是缓慢的。这个可测量的时间差异，尽管通常只有几纳秒，却是根本的信号，是机器中幽灵的微弱低语。拥有足够精确秒表的攻击者可以分辨出一块数据是否在工作台上。

### 间谍的艺术：Prime 和 Probe

那么，攻击者如何利用这种时间差异呢？最经典的技术被称为 **Prime+Probe**。这是一个简单的三步剧：

1.  **Prime (预置)：** 攻击者知道受害者很快要使用这个工作室，于是先行进入。他们一丝不苟地用自己的工具填满工作台的某些部分。说得更具体些，高速缓存并非一个无差别的大平面；它被组织成带编号的架子，称为**缓存组 (cache sets)**。任何来自仓库的数据都只能被放置在特定的、预先确定的架子上。因此，攻击者小心地将他们的物品放在他们想要监视的架子上。

2.  **受害者的回合：** 攻击者退到一旁，让受害者工作。受害者对这个设置毫不知情，开始处理自己的事务。如果受害者需要使用一个已被攻击者预置的架子，并且那个架子已经满了，受害者就必须腾出空间，将某样东西移回仓库。移动哪个物品取决于处理器的规则。

3.  **Probe (探测)：** 攻击者返回并计时访问自己原来每个工具所需的时间。如果访问速度快（命中），说明工具还在那里；受害者没有使用那个位置。如果访问速度慢（未命中），说明工具不见了！攻击者就知道受害者必定使用了那个特定架子上的那个确切位置。

通过观察哪些自己的物品被替换掉，攻击者可以推断出受害者访问了哪些缓存组。由于内存访问是正在执行的计算的直接反映，这就泄露了关于受害者秘密操作的信息。

### 可预测与不可预测：替换策略的角色

现在，让我们更仔细地审视受害者需要在满载的架子上腾出空间的那一刻。决定哪个物品被丢弃的规则被称为**缓存替换策略 (cache replacement policy)**。事实证明，这个规则对安全性至关重要。

一种常见的策略是**[最近最少使用](@entry_id:751225) (Least Recently Used, LRU)**。它的规则简单且确定性：驱逐最长时间未被触碰的物品。对于攻击者来说，这简直是梦想成真。通过在预置阶段仔细控制访问顺序，攻击者可以确保他们的“间谍”缓存行绝对是[最近最少使用](@entry_id:751225)的。如果受害者接着访问该组，攻击者的缓存行就*保证*会被驱逐。信号完全清晰且可复现。在控制良好的实验中，攻击者在单次尝试中确定受害者行为的成功概率为 $1$ [@problem_id:3626329]。

如果规则不同会怎样？考虑一种**随机 (Random)** 替换策略，即发生冲突时驱逐一个随机物品。现在，攻击者不再确定了。如果一个缓存组有 $W$ 个槽（其**相联度 (associativity)**），受害者的访问将以仅为 $1/W$ 的概率驱逐攻击者的间谍缓存行。信号现在是带噪声的、概率性的。攻击可能仍然奏效，但需要多次重复以平均掉噪声并获得对结果的信心。对于相联度为 $W=4$ 的情况，攻击者单次尝试的成功率从 $100\%$ 降至仅 $25\%$。获得清晰信号所需的试验期望次数从 $1$ 次跃升至 $4$ 次 [@problem_id:3626329]。攻击者观察到的预期访问延迟变成了命中和未命中时间的加权平均值，模糊了曾经清晰的区别 [@problem_id:3626331]。这揭示了一个深刻的原理：[微架构](@entry_id:751960)中的确定性可以创建干净的[信息通道](@entry_id:266393)，而随机性可以扰乱它们。

### 来自未来的泄露：[推测执行](@entry_id:755202)的危险

对高速缓存的 Prime+Probe 攻击很强大，但现代处理器引入的一项特性将这些攻击提升到了一个可怕的新水平：**[推测执行](@entry_id:755202) (speculative execution)**。想象一下，现代 CPU 就像一个过于急切的学生，当遇到一个有两个可能答案的问题时，他会同时尝试解决*两条*路径以求领先。处理器不断尝试猜测即将到来的操作（如代码中的分支）的结果，并在知道猜测是否正确之前就沿着预测的路径执行指令。

如果猜测结果是正确的，那太好了！工作已经完成。如果猜测是错误的，处理器会简单地丢弃那部分推测性工作的结果。计算机最终的*体系结构*状态（寄存器和主存中的值）保持不变，就好像错误的推测从未发生过一样。

但*[微架构](@entry_id:751960)*状态呢？推测性工作仍然发生了。处理器仍然跑到仓库并将物品放在了高速缓存工作台上。这些变化通常*不会被回滚*。这个幽灵般的、从未真正发生过的执行所留下的脚印依然存在 [@problem_id:3676129]。

这就是臭名昭著的 Spectre 攻击的基础。攻击者可以诱骗受害者程序推测性地执行一小段依赖于秘密的代码——一个“gadget”。例如，想象一行代码 `access_data(array[secret_value])`。处理器可能会用一个它本不应知道的秘密值来推测性地执行这行代码。位于那个依赖于秘密的地址上的数据被取入高速缓存。几毫秒后，处理器意识到自己的错误并取消了该操作。但损害已经造成。数据仍然留在高速缓存中。攻击者随后可以使用 Prime+Probe 扫描高速缓存的 `array` 区域，查看哪一行被带入，从而直接读出 `secret_value`。这使得攻击者不仅可以泄露一位信息，还可以泄露受害者内存中的任意数据值。可以使用信息论精确量化的[信息泄露](@entry_id:155485)，变成了一股洪流 [@problem_id:3676129]。

### 幽灵议会：众多泄露结构

[数据缓存](@entry_id:748188)并不是唯一留下脚印的结构。竞争和计时的原理几乎适用于处理器内部任何共享的、有限的资源。现代 CPU 就是一个幽灵议会。

-   **[指令缓存](@entry_id:750674) (I-Cache):** 一个专门用于存放指令的独立缓存。通过探测[指令缓存](@entry_id:750674)，攻击者可以确定受害者执行了*哪些代码路径*，甚至只是推测性地获取了哪些路径。这不会泄露原始数据，但它揭示了依赖于秘密的[控制流](@entry_id:273851)，这本身就是一个严重的安全漏洞 [@problem_id:3679379]。

-   **分支目标缓冲器 (BTB):** 一个小而快的高速缓存，用于预测分支指令将跳转到哪里。如果攻击者能在 BTB 中与受害者的分支产生冲突，他们可以观察到自己的预测何时开始失败。这表明受害者正在一个特定的、冲突的地址执行分支，从而泄露了其位置。[地址空间布局随机化 (ASLR)](@entry_id:746279) 等防御措施使这变得更加困难，但如果找到冲突，底层的泄露依然存在 [@problem_id:3676155]。

-   **转译后备缓冲器 (TLB):** 用于加速[虚拟内存](@entry_id:177532)地址到物理[地址转换](@entry_id:746280)的高速缓存。探测这些缓冲器的攻击者可以了解到受害者在更大尺度上的内存访问模式，有可能使其整个[内存布局](@entry_id:635809)去匿名化 [@problem_id:3645426]。

-   **[微操作缓存](@entry_id:756362) (MOC):** 用于缓存已解码的指令以节省功耗和时间。它同样表现得像一个高速缓存，可以被 Prime+Probe 攻击利用，以揭示基于指令布局的受害者代码执行路径差异 [@problem_id:3676160]。

美妙而统一的原理是，任何其状态受计算影响且其访问时间可观测的索引存储结构，都可能成为一个旁路信道。

### 架构师的困境：性能、复杂性与安全

这些发现揭示了计算机体系结构中的一个根本性矛盾。许多为性能而设计的特性——高速缓存、分支预测、[推测执行](@entry_id:755202)——恰恰创造了使旁路攻击成为可能的条件。

一个微小的设计选择可能会产生重大的安全后果。例如，一些处理器使用**包容性 (inclusive)** 末级缓存 (LLC)，其中 LLC 必须包含所有较小的私有缓存中所有内容的超集。这意味着一次推测性获取将一个缓存行带入 L1 缓存时，也*必须*在共享的 LLC 中放置一个副本（或更新状态）。这恰好放大了使用 Prime+Probe 攻击 LLC 的攻击者的信号。而**排他性 (exclusive)** 策略，即不同级别的缓存持有不相交的数据集，则可以减弱这个信号，因为一次推测性地填充到 L1 可能会完全绕过 LLC [@problem_id:3679413]。

这引发了一场持续的猫鼠游戏。随着新攻击的发现，新的防御措施也被设计出来。一个关键的硬件缓解措施是对这些共享结构进行分区。通过在 BTB 或[页表缓存](@entry_id:756118)等结构中的每个条目上添加一个**地址空间标识符 (ASID)** 标签，处理器可以强制实施严格的分离，防止一个进程的“幽灵”被另一个进程看到 [@problem_id:3676155] [@problem_id:3645426]。当然，这在芯片面积和复杂性上都付出了代价。诸如 **retpoline** 之类的软件缓解措施被开发出来，以防止[推测执行](@entry_id:755202)跳转到攻击者控制的目标，与只执行内存等硬件权限互补，创建一种[纵深防御](@entry_id:203741)策略 [@problem_id:3646234]。

深入旁路世界之旅向我们表明，计算机不仅仅是其体系结构规范。它是一个物理系统，其回声和共振以最意想不到的方式揭示了其内部运作。理解这些幽灵般的脚印是构建一个更安全的计算世界的第一步。

