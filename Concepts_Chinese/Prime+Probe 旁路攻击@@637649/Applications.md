## 应用与跨学科联系

我们已经见识了 Prime+Probe 攻击的微妙之舞，这是一个诞生于共享资源本质的幽灵。原则上，这是一个极其简单的想法，但只有当我们将它从抽象引入到真实计算机的繁忙、复杂的世界中时，它的真正力量和重要性才得以显现。这个原理适用于哪里？事实证明，无处不在。这个幽灵不仅萦绕在机器的一个布满灰尘的角落，而且几乎出没于每一个为了性能而构建的组件。这段旅程不仅仅是为安全漏洞编目；它关乎于理解定义现代计算的速度、效率和信任之间深刻而往往相互冲突的相互作用。这是一个关于建造数字墙垣并发现它们能以何种惊人方式被攻破的故事。

### 数字墙垣的艺术：分区高速缓存

见证 Prime+Probe 攻击最直接、最直观的地方是在处理器的高速缓存中，那个共享的最近使用数据的库。想象两个程序在同一台计算机上运行，一个处理您敏感的财务数据，另一个是从互联网上下载的不受信任的应用程序。它们共享高速缓存。我们如何阻止恶意程序观察安全程序留下的“指纹”？

最直接的答案是建一堵墙。在[操作系统](@entry_id:752937)的世界里，这是一种称为**页着色 (page coloring)** 的精妙技术。把高速缓存想象成一个大型共享停车场，每个停车位对应一个缓存组。控制系统中所有物理内存的[操作系统](@entry_id:752937)可以扮演停车管理员的角色。它可以给物理内存页“涂上”不同的颜色，使得某种颜色的页只能映射到一组特定的、对应的停车位（缓存组）。通过给安全程序分配“红色”页，给攻击者分配“蓝色”页，我们可以确保它们永远不会停在相同的车位，因此永远无法知道对方何时来去。

这提出了一个引人入胜的量化问题：我们需要多少种颜色？如果颜色太少，那么根据简单的[鸽巢原理](@entry_id:268698)，这些程序将不可避免地被迫共享一些颜色，这堵墙就变得漏洞百出。我们实际上可以推导出颜[色数](@entry_id:274073)量、分配给每个程序的分区数量以及我们愿意容忍的最大[信息泄露](@entry_id:155485)量（以比特/秒为单位衡量）之间的精确关系 [@problem_id:3687993]。一个安全目标——“泄露不超过 $\epsilon$ 比特”——可以直接转化为[操作系统内存管理](@entry_id:752942)器的工程要求。这将安全性从一个模糊的愿望提升为一个严谨的、量化的学科。

当然，现实世界是复杂的。当我们的两个程序*必须*共享某些东西时会发生什么？也许它们都需要使用一个标准的系统库，为了效率，这个库只在内存中加载了一次。现在我们完美的红色和蓝色停车区有了一个共享的“紫色”区域。攻击者看不到受害者的私有红色区域，但他们可以观察共享的紫色区域的活动。隔离不再是完美的。然而，我们的理解并未失效。我们仍然可以计算残余泄露量，精确地量化有多少信息通过这个共享依赖泄露出去 [@problem_id:3666043]。这是实践安全中的一个关键教训：缓解通常是一场减少而非绝对消除的游戏。我们建造我们能建的最好的墙，并精确测量我们被迫敞开的大门的大小。

### 超越高速缓存：竞争的普遍性

Prime+Probe 原理远比仅限于[数据缓存](@entry_id:748188)更为普遍。它适用于*任何*容量有限的、有状态的共享资源。另一个潜伏在处理器核心的绝佳例子是**转译后备缓冲器 (Translation Lookaside Buffer, TLB)**。每次你的程序使用一个虚拟内存地址（一个方便的虚构概念）时，处理器都必须将其转换为一个真实的物理地址。为了快速完成这个任务，它会查询一个小型、极快的近期翻译缓存——TLB。

和主[数据缓存](@entry_id:748188)一样，TLB 是一个共享的、有限的资源。如果两个在同一核心上运行的[虚拟机](@entry_id:756518)需要转换地址，它们将争夺 TLB 中的空间。攻击者可以自己的翻译来“预置”TLB，然后“探测”以查看受害者的活动是否已将其驱逐。我们再次看到了那个幽灵。

我们可以在这里也建墙吗？可以，但工具不同。[虚拟机](@entry_id:756518)监控器（hypervisor，管理[虚拟机](@entry_id:756518)的软件）不是通过给物理内存着色，而是可以用不同的机制来划分 TLB。处理器为每个程序或[虚拟机](@entry_id:756518)分配一个唯一的**地址空间标识符 (ASID)**。一些[处理器设计](@entry_id:753772)巧妙地在 TLB 的索引函数中使用了这个 ASID，通常是将其与虚拟地址位进行[异或](@entry_id:172120) (XOR) 操作。一种天真的策略可能只是分配不同的 ASID，并希望异或操作能“去相关”这些访问。但这并不能实现隔离；它只是将竞争重新洗牌。原则上，每个程序仍然可以访问每个 TLB 组。

真正的隔离需要一种更深思熟虑的策略，一种[硬件设计](@entry_id:170759)和软件策略之间的美妙互动。正如在 [@problem_id:3645450] 的场景中所探讨的，[虚拟机](@entry_id:756518)监控器可以通过为每个安全域分配特定的*虚拟地址*范围，并结合精心分配的 ASID，来实现对 TLB 的完美分区。通过控制 TLB 索引函数的*输入*，[虚拟机](@entry_id:756518)监控器可以将 TLB 分成不同的、不重叠的区域，有效地为每个虚拟机提供其自己的私有地址翻译“备忘单”。分区的基本原理相同，但应用于具有完全不同控制旋钮和杠杆的另一种[微架构](@entry_id:751960)结构。

### 性能的双刃剑：大页

[计算机体系结构](@entry_id:747647)的历史是一场对性能的不懈追求。一个强大的优化是使用**大页 (huge pages)**。通常，[操作系统](@entry_id:752937)以小块（典型为 $4$ KB）管理内存。相比之下，一个大页可能是 $2$ MB 甚至 $1$ GB。使用它们就像通过说出一个大区域而不是一个具体的街角来指路——这对于导航大片内存区域效率高得多。对于 TLB 来说，这是一个巨大的胜利；一个条目现在可以覆盖一个巨大的区域，极大地减少了未命中的几率。

但是这个性能技巧对我们的旁路信道有什么影响呢？在这里，我们发现了一个美妙而令人惊讶的转折。通过使用大页，我们使得该大区域内的所有地址都依赖于同一个地址翻译。从基于 TLB 的 Prime+Probe 攻击的角度来看，所有这些地址都变得无法区分。攻击者再也无法分辨你访问了哪个 $4$ KB 的页面，只能知道你访问了 $2$ MB 大页内的*某个地方*的内存。攻击者的“分辨率”已经变得粗糙了 [@problem_id:3684895]。这实际上*减少了*泄露的信息量，因为攻击者可以区分的可能秘密的数量从数千个小页面骤降到只有几十个[大页面](@entry_id:750413)。

这就产生了一个有趣的权衡。我们有一个旋钮来提高性能（使用大页，这也恰好降低了泄露的粒度），另一个旋钮来提高安全性（注入随机时序[抖动](@entry_id:200248)以模糊命中和未命中的信号）。挑战变成了一个[优化问题](@entry_id:266749)：我们能否找到这些旋钮的一个设置——一定比例的时间使用大页和一定的概率添加噪声——使得我们的性能开销保持在预算内，同时也将[信息泄露](@entry_id:155485)保持在临界阈值以下？[@problem_id:3684895]。安全性和性能并不总是对立的；有时它们以微妙而复杂的方式联系在一起，管理它们是一种量化的平衡艺术。

### 最深的巢穴：翻译机制中的泄露

就在我们以为已经把系统摸透了的时候，我们发现了一个新的、更深的层次。我们已经保护了[数据缓存](@entry_id:748188)和 TLB。但是在 TLB 未命中时会发生什么呢？当处理器的“备忘单”失效时，它必须执行一次完整的**[页表遍历](@entry_id:753086) (page walk)**，手动遍历[主存](@entry_id:751652)中的[页表](@entry_id:753080)层次结构以找到正确的翻译。为了加速*这个*过程，处理器还有另一套缓存：**[页表结构](@entry_id:753084)缓存 (paging-structure caches)**，用于存储这些遍历的中间步骤。

这里潜藏着最微妙的漏洞。如果，像在一些真实设计中常见的那样，这些[页表结构](@entry_id:753084)缓存是跨安全域共享的，并且——与 TLB 不同——*没有*用 ASID 进行标记，那会怎样？我们已经建造了一座堡垒，一个[可信执行环境](@entry_id:756203) (TEE)，有一个安全的前门（带标签的 TLB），但我们却把建筑蓝图放在大厅的一张共享桌子上，任人观看 [@problem_id:3686081]。[安全飞地](@entry_id:754618)之外的攻击者可以预置这些蓝图缓存并探测它们，以查看飞地正在查阅地图的哪些部分。

现在，从这个新角度重新考虑大页。[性能优化](@entry_id:753341)变成了一场安全噩梦。当使用一个 $2$ MB 的大页时，该整个区域内的任何访问都依赖于页表层次结构中高层的同一个页目录项 (PDE)。那一个 PDE 成为了一个[信息瓶颈](@entry_id:263638)。攻击者不再需要监控数千个不同的缓存组；他们只需要观察对应于那一个 PDE 的单个缓存行，就能检测到在一个巨大的 $2$ MB 区域内的*任何*活动。[性能优化](@entry_id:753341)扮演了这个微妙的二阶旁路信道的一个巨大放大器。

这导出了一个深刻而发人深省的结论。面对像未标记的共享缓存这样的根本性硬件缺陷，任何放大其效应的特性都会成为一个负累。唯一可靠的安全策略是在[安全飞地](@entry_id:754618)内禁止使用大页，牺牲它们的性能优势，除非底层缺陷在硬件中得到修复，或者通过在每次安全转换时进行代价高昂的缓存刷新来缓解 [@problem_id:3686081]。

这段从简单的高速[缓存分区](@entry_id:747063)到[页表结构](@entry_id:753084)错综复杂之舞的旅程，揭示了[微架构](@entry_id:751960)安全的真正本质。它是一门整体性学科。一个系统的强度取决于其最薄弱的环节，一个单一、晦涩、未标记的共享资源就可能破坏最精巧的安全架构。Prime+Probe 的幽灵告诉我们，要构建真正安全的系统，我们必须全面地理解机器，认识到那些赋予其惊人速度的设计选择，也可能制造出秘密丢失的阴影。