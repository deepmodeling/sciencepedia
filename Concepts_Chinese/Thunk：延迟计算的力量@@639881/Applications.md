## 应用与跨学科关联

在我们之前的讨论中，我们剖析了 thunk 的优美而微妙的机制——这些奇妙的、处于暂停状态的计算包，让程序能够智能地“偷懒”。我们看到了它们的区别：[传名调用](@entry_id:753236)是那个永远健忘的重复计算者，而传需调用则是那个勤奋的学生，只做一次功课并永远记住答案。但这些不仅仅是供计算机科学家消遣的抽象奇谈。它们是一个深刻而实用的原则，一种贯穿于各种惊人领域的计算哲学。这个原则很简单：**永远不要做任何工作，除非你被绝对强制要求去做；如果你被强制做了，就永远不要再做第二次。**

让我们踏上一段旅程，看看这个简单的想法能带我们走多远。

### 构建不可见之物：无限结构与高效算法

想象一下，你想处理一个包含*所有*素数的列表。这或许是个奇怪的要求，因为素数有无限多个！一台“严格”的计算机，也就是立即执行所有操作的计算机，会被这个命令噎住。它会开始生成素数，永不停止，拼命地试图在有限的内存中构建一个无限的列表。这是一项徒劳的任务。

但是一台装备了 thunk 的惰性计算机只会微笑。它不会试图构建整个列表。相反，它给你一个包含第一个素数 $2$ 的节点和一个 thunk。这个 thunk 是一个承诺，一个生成列表其余部分的食谱。它说：“如果你需要下一个素数，只需强制求值我。”当你这样做时，它会计算出下一个素数 $3$，并返回该数字以及*另一个* thunk，一个对余下素数的新承诺。这个过程可以永远进行下去，列表只在你遍历它时才从以太中具象化出来 ([@problem_id:3246462])。我们可以构建和操作概念上无限的数据结构，因为我们只需为当前正在查看的小部分付费。

这种“按需计算”的能力并不仅限于无限的事物。它为表达某些算法（如动态规划）提供了一种极其优雅的方式。考虑计算一个[斐波那契数](@entry_id:267966) $F_n$。朴素的递归方法效率极低，因为它会一遍又一遍地重复计算相同的值。教科书上的解决方案是构建一个表格来存储和重用结果。

然而，一个惰性程序员会看到，传需调用本身*就是*一个动态规划表。我们可以将整个[斐波那契数列](@entry_id:272223)定义为一个惰性列表或数组，其中每个元素 $F_i$ 都根据前两个元素 $F_{i-1}$ 和 $F_{i-2}$ 来定义。当我们请求 $F_n$ 时，系统会自动强制求值 $F_{n-1}$ 和 $F_{n-2}$ 的 thunk，而这又会强制求值它们的依赖项，以此类推。由于[记忆化](@entry_id:634518)，每个 $F_i$ 只被计算一次。Thunk 的“求值并缓存”内部机制免费为我们提供了一种复杂的优化。

但这种优雅隐藏着一个微妙的陷阱。一个 thunk 在热切地记住结果的同时，也可能记住了它如何得到这个结果。$F_n$ 的 thunk 持有对 $F_{n-1}$ 和 $F_{n-2}$ 的 thunk 的引用，而后者又持有它们自己的引用，如此形成一条长长的依赖链。即使它们的值已经被计算出来，这些引用也可能保持活动状态，阻止[垃圾回收](@entry_id:637325)器回收内存。这是一个臭名昭著的问题，称为“空间泄漏”——程序使用的内存远超其表面上应有的用量 ([@problem_id:3234872])。因此，惰性编程的艺术不仅在于推迟工作，还在于知道何时放手过去，例如，通过设计 thunk，使其在完成使命后巧妙地清除其依赖指针。

### 设计智能高效的系统

拖延原则可以从算法完美地扩展到大规模的软件架构。想一想任何大型应用程序中的一个常见任务：日志记录。一个程序可能会生成详细的诊断信息。构建这些信息可能代价高昂——可能涉及读取文件、格式化复杂的数据结构等。但通常，这些详细的日志在生产环境中是关闭的。一个严格的程序会做完所有创建日志消息字符串的辛苦工作，结果日志函数却立即将其丢弃。真是浪费！

惰性系统将创建消息的逻辑包装在一个 thunk 中。它将这个 thunk——这个*潜在*的消息——传递给日志记录器。日志记录器只有在实际需要写入消息时才强制求值该 thunk ([@problem_id:3649656])。如果消息在多个地方被使用（比如，同时写入控制台和文件），传需调用确保了昂贵的创建过程只发生一次。

现在，让我们想得更大些。程序本身呢？当你启动一个大型应用程序时，它真的需要在启动时加载并初始化每一个功能、每一个库、每一个组件吗？这就是为什么一些应用程序需要很长时间才能打开的原因。一个惰性的运行时将整个模块或库视为 thunk 的集合。当一个程序模块导入另一个模块时，它不会立即运行代码。它只是获得一组针对导出函数和值的 thunk ([@problem_id:3649636])。只有当程序需要该模块中的特定函数时，相应的 thunk 才会被强制求值，这可能会触发一连串其他的初始化。这带来了显著更快的启动时间，并使系统只为它所使用的部分付费。

如果这听起来像一个巧妙的理论思想，你可能会惊讶地发现你已经使用它几十年了。Windows [操作系统](@entry_id:752937)有一个针对其[动态链接](@entry_id:748735)库（DLLs）的功能，称为“延迟加载”。当程序员以这种方式将其应用程序链接到 DLL 时，编译器不会直接[连接函数](@entry_id:636388)调用。相反，它为每个导入的函数发出一小段代码——一个 thunk！程序第一次调用，比如说，`alpha.dll` 中的函数 `B` 时，它实际上触及的是这个 thunk。Thunk 的代码调用[操作系统](@entry_id:752937)的加载程序，该程序在磁盘上找到 `alpha.dll`，将其加载到内存中，找到函数 `B` 的真实地址，并且——这是关键部分——*修补*程序的内存，使未来的调用直接指向真实函数。这是一个完美的、手工实现的传需调用，它被直接构建在[操作系统](@entry_id:752937)的结构中，以使你的程序启动得更快 ([@problem_id:3654623])。

### 打造互动与互联的体验

Thunk 的影响或许在我们日常使用的流畅、交互式的应用程序中最为明显。想象一下，在社交媒体动态或拥有数千件商品的在线商店中滚动。如果你的手机试图一次性渲染所有 1000 个项目的所有图像和文本块，它会陷入停滞。

现代用户界面（UI）框架用惰性来解决这个问题。组件列表实际上是一个 thunk 数组。每个 thunk 都是渲染单个项目的食谱。框架只强制求值当前在视口中可见的大约 20 个项目的 thunk ([@problem_id:3649665])。当你滚动时，进入视野的新项目的 thunk 被强制求值，它们的结果（渲染好的视图）便出现了。这种体验感觉即时而流畅，这是一个由成千上万个微小的拖延行为编织成的幻觉。不过，正如我们在斐波那契例子中看到的那样，这可能会有内存方面的影响。如果框架保留了曾被强制求值的每个 thunk 的结果，那么随着你不断滚动，应用程序的内存使用量将持续增长，如同你曾看过的所有东西的幽灵。

这种惰性超越了屏幕上的内容，延伸到了其背后的数据。为什么应用程序要发起网络请求来获取用户可能永远不会看的数据？一个 thunk 可以封装发起网络调用的整个过程。数据库查询或 Web API 调用的结果是一个承诺，一个 thunk，当被强制求值时，它会访问网络，获取数据，然后提供它。这可以防止不必要的网络流量风暴。此外，系统可以更智能。如果应用程序的不同部分请求相同的数据（例如，相同的 URL），运行时可以“合并”这些请求。第一个请求触发网络调用，第二个请求则只需等待该调用的结果，从而避免了冗余工作 ([@problem_id:3649644])。

### 惰性的边界：纯度、随机性与现实世界

尽管[惰性求值](@entry_id:751191)的宏伟蓝图威力无穷，但它依赖于一个关键假设：被延迟的计算是*纯*的。一个纯函数就像一个数学函数：对于相同的输入，它总是产生相同的输出，并且没有其他可观察到的影响。加法是纯的；`2 + 3` 总是 `5`。

但如果计算不纯呢？如果 thunk 的食谱涉及掷骰子呢？考虑一个 thunk，它每次运行时都使用新生成的随机盐来生成一个加密哈希。如果我们在[传名调用](@entry_id:753236)语义下使用这个 thunk 三次，它将分别运行三次，生成三个不同的随机盐，并产生三个不同的哈希。但在传需调用下，它只在*第一次*运行时运行。它生成一个随机盐，计算一个哈希，然后[记忆化](@entry_id:634518)该结果。接下来的两次，它只是返回缓存的哈希。程序的输出发生了根本性的改变！我们从一个包含三个独立哈希的三元组变成了一个哈希的三个相同副本 ([@problem_id:3675820])。在存在随机性或其他副作用的情况下，传需调用不仅仅是一种优化；它是一种语义上的改变。

这就是为什么编译器只有在能证明一个 thunk 的求值没有副作用时，才能执行某些优化，比如死代码消除。如果一个未使用的变量 `x` 绑定到一个 thunk，并且编译器知道强制求值它除了计算一个值之外什么也不做，那么如果 `x` 从未被使用，它就可以安全地删除这个绑定。但如果强制求值 thunk 可能会发射导弹或打印消息，编译器就不敢碰它 ([@problem_id:3636200])。

最后，惰性的世界有时必须与严格、不屈的物理世界接口。想象一下我们的惰性语言需要调用一个旧的 C 库中的函数。那个 C 函数没有准备好进行关于承诺的对话；它期望一个具体的、原始的数字内存块，立即就要。为了弥合这一鸿沟，我们的惰性运行时必须变得严格。它必须强制求值所有相关的 thunk，计算所有值，分配一个垃圾回收器承诺不会移动的连续内存块，并将结果复制进去。只有这样，它才能进行调用。在这个边界上，拖延结束了；所有债务都必须偿还 ([@problem_id:3649648])。

从无限到互动，从算法到[操作系统](@entry_id:752937)，thunk 这个简单的想法——一个被暂停的计算——是一条统一的线索。它向我们展示了将*做什么*与*何时做*分离开来的力量，使我们能够构建更高效、更具响应性，且在许多方面更优雅的系统。这是一个美妙的证明，证明了无所作为的力量，直到时机恰到好处。