## 应用与跨学科联系

在领略了[可信执行环境](@entry_id:756203)（TEE）的精妙机制之后，我们现在到达了一个令人振奋的制高点。从这里我们可以看到，机密计算不仅仅是安全专家工具箱中的又一个工具。它是一场[构造板块](@entry_id:755829)式的转变，是对软件与硬件之间关系的根本性反思，其影响波及整个计算机科学领域。就像一条新的物理定律，它的发现迫使我们重新审视旧的假设，并解锁了我们曾认为不可能的现象。让我们来探索这个新世界，不将其视为技术的目录，而是作为一场思想的旅程，由可验证的信任这一美妙而简单的原则统一起来。

### 追求更小的王国：重新定义信任

计算机安全的核心是一个既简单又深刻的概念：[可信计算基](@entry_id:756201)（TCB）。想象一位中世纪的国王希望保护他的王冠。TCB 就是他必须信任的所有人的集合——他的卫兵、他的顾问、他的厨师。如果其中任何一个人不忠或[无能](@entry_id:201612)，王冠就岌岌可危。一位明智的国王知道，他必须无条件信任的人越少，他就越安全。软件亦是如此。TCB 是其正确性对执行安全策略至关重要的所有硬件、固件和软件组件的总和。TCB 中的每一行代码都是一个可能因恶意或错误而背叛系统的卫兵。整个安全系统设计的历史可以被看作是一场旨在缩小这个可信“王国”规模的崇高追求。

这场追求塑造了[操作系统](@entry_id:752937)的整体架构。传统的**[单体内核](@entry_id:752148)**将几乎所有服务——驱动程序、文件系统、网络栈——都捆绑到一个单一的特权程序中，其 TCB 极其庞大。整个内核，通常是数千万行代码，都必须被信任。作为回应，设计者创造了**微内核**，它将大部分服务委托给非特权的用户空间服务器，只在可信内核中保留一小部分核心的基本功能。还有人设想了**外核（exokernel）**，通过将几乎所有的抽象都移到非特权的库中，进一步缩小 TCB，让内核只负责安全地复用原始硬件。每种设计都是为了减少国王必须信任的卫兵数量的不同策略 [@problem_id:3640406]。

这个挑战在构建编译器的问题中达到了其在智识上最纯粹的形式。你如何能信任一个将人类可读的源代码翻译成机器指令的编译器？更令人烦恼的是，你如何能信任一个编译*自身*的编译器？这正是 Ken Thompson 著名的“关于信任之反思”（Reflections on Trusting Trust）演讲的主题。一个恶意的编译器可以秘密地在它正在编译的新版自身中插入一个后门，这个后门将永远存在，在任何源代码中都不可见。唯一真正的防御是从一个“种子”编译器或解释器开始构建整个[信任链](@entry_id:747264)，这个种子必须足够小和简单，以至于可以通过形式化验证或人工审计。这个可信的种子是整个软件生态系统的最小 TCB [@problem_id:3629209]。机密计算为这个古老的追求提供了一个惊人优雅的、基于硬件的答案。它允许我们定义一个极小的 TCB：仅包含我们的应用程序代码和 CPU 本身，从而将数百万行的[操作系统](@entry_id:752937)代码从信任圈中精准地剔除出去。

### 重塑[操作系统](@entry_id:752937)：一位被降级的君主

这个新现实迫使我们重新思考[操作系统](@entry_id:752937)的角色。几十年来，[操作系统](@entry_id:752937)一直是绝对的君主，一个拥有对每个进程和每个字节内存完全权威的特权实体。有了机密计算，[操作系统](@entry_id:752937)被降级了。它仍然是领域的管理者——它调度线程、管理[页表](@entry_id:753080)、控制设备——但它再也无法窥探其臣民（即飞地）的私人城堡。

这种新的“社会契约”带来了有趣的后果。在一个令人愉快的转折中，[操作系统](@entry_id:752937)可以利用这项技术来保护自己。[操作系统](@entry_id:752937)有自己的皇冠珠宝，比如全盘加密的主密钥。传统上，这些密钥位于内核内存的某个地方，容易受到复杂攻击。通过使用 TEE，[操作系统](@entry_id:752937)可以将其密钥库放入一个飞地内，从而成为其自身[硬件安全](@entry_id:169931)能力的客户。TEE 的架构选择至关重要。一个使用像 [Intel SGX](@entry_id:750706) 这样的用户空间 TEE 的[操作系统](@entry_id:752937)，必须通过委托给用户空间中的一个辅助进程来与其密钥库通信，这会因上下文切换而产生性能成本。然而，一个在具有 ARM TrustZone 平台上运行的[操作系统](@entry_id:752937)，可以将其密钥库放置在“安全世界”中，允许内核通过一条特殊指令直接调用它，这是一种更高效、尽管仍然昂贵的转换 [@problem_id:3631337]。

这种“成本”是隐私的代价。安全保证不是免费的；它们是以性能为代价的。每当程序进入或退出飞地时，处理器都会进行一系列复杂且耗时的步骤。它必须保存和恢复状态，刷新像翻译后备缓冲器（TLB）这样的缓存，并预热[内存加密](@entry_id:751857)引擎。单次进入就可能花费数微秒，这在处理器时间里简直是天长地久 [@problem_id:3639714]。

这种性能现实给不可信的[操作系统](@entry_id:752937)带来了新的责任。考虑像 [Intel SGX](@entry_id:750706) 这样的 TEE，它使用一个称为飞地[页缓存](@entry_id:753070)（EPC）的特殊、有限的内存区域。如果[操作系统](@entry_id:752937)天真地一次性调度太多的飞地运行，它们合并的内存占用可能会超过 EPC 的容量。结果就是“颠簸”（thrashing），系统把所有时间都花在换入换出飞地内存上，导致性能急剧下降。一个“TEE 友好”的调度器必须更聪明。尽管它看不到飞地里*有什么*，但它必须知道它们的*[工作集](@entry_id:756753)有多大*。调度问题转变为一个经典的谜题：如何用最少的箱子（调度批次）将不同大小的物品（飞地[工作集](@entry_id:756753)）装入一个固定大小的箱子（EPC）。[操作系统](@entry_id:752937)必须解决这个[装箱问题](@entry_id:276828)，才能成为一个有效、尽管不可信的系统资源管家 [@problem_id:3686114]。

### 超越 CPU：构建一座堡垒

一个飞地就像城堡中心的一个加固房间。墙壁很坚固，但如果攻击者能从外部挖隧道进来怎么办？在现代计算机中，外围设备——网卡、存储控制器、GPU——是强大的实体，它们可以通过一种称为直接内存访问（DMA）的机制直接写入内存。没有适当的防御，一个恶意设备可以轻易绕过 CPU 的保护，从外部破坏飞地的内存。

为了保卫整个堡垒，TEE 需要一个守门人。这个角色由输入输出[内存管理单元](@entry_id:751868)（[IOMMU](@entry_id:750812)）扮演，它是一个硬件部件，充当所有 DMA 流量的边境管制员。在设备传输数据之前，[IOMMU](@entry_id:750812) 会检查其[页表](@entry_id:753080)，看它是否有权限访问目标内存地址。为了给飞地启用安全的 I/O，[操作系统](@entry_id:752937)或一个受信任的运行时必须用“默认拒绝”的策略来精心配置 [IOMMU](@entry_id:750812)。它会创建一个精确的列表，指明某个特定设备被允许访问哪些内存页面——通常是一个小的共享缓冲区——并拒绝其他所有访问。这种配置是一项重要的任务，需要在 IOMMU 的内存结构中设置可能数千条映射规则，其复杂性随着设备和缓冲区的数量而增加 [@problem_id:3686083] [@problem_id:3686143]。

这阐明了一个更深层次的原则：一个安全的系统是一条[信任链](@entry_id:747264)。机密计算是其中的一个环节，但它必须与其他环节相连。像 UEFI [安全启动](@entry_id:754616)这样的技术创建了一个静态[信任根](@entry_id:754420)（SRTM），从通电的那一刻起就验证每一段软件的加密签名。像 Intel TXT 或 AMD SKINIT 这样的技术创建了一个动态[信任根](@entry_id:754420)（DRTM），允许系统在启动过程的后期启动一段纯净的、经过度量的代码（如[虚拟机监视器](@entry_id:756519)），无论之前发生了什么。[可信平台模块](@entry_id:756204)（TPM）将这些度量记录在特殊的寄存器（PCRs）中。通过检查 SRTM 寄存器，远程方可以验证固件的完整性；通过检查独立的 DRTM 寄存器，他们可以验证[虚拟机监视器](@entry_id:756519)。整个技术栈，包括 TEE 和 IOMMU，必须协同工作，以提供一个整体的、可证明的、安全的平台 [@problem_id:3679553]。

### 新的前沿：云与协同计算

机密计算的影响在云和[分布式系统](@entry_id:268208)中最为深远。

在[虚拟化](@entry_id:756508)的云环境中，客户的整个虚拟机（VM）只是云提供商服务器上的一个文件。当主机提供商可以随意快照、恢复或修改[虚拟机](@entry_id:756518)的“虚拟”安全硬件，如虚拟 [TPM](@entry_id:170576)（v[TPM](@entry_id:170576)），虚拟机又如何能信任它呢？如果主机可以将 v[TPM](@entry_id:170576) 恢复到先前的状态，它就能迫使虚拟机无休止地重复一个看似有效但实际上已经危险过时的“安全”启动过程——这就是“回滚攻击”。解决方案是将虚拟信任锚定在物理现实中。一种方法是让主机的物理 TPM 发布一份包含一个非易失性、严格递增的单调计数器的证明报告。当计数器值未能增加时，任何回滚尝试都会被远程验证者发现。一种更强的方法是在主机的硬件 TEE 内部运行整个 v[TPM](@entry_id:170576) 本身，利用 CPU 自身的隔离能力来保护虚拟安全模块免受运行它的主机的侵害 [@problem_id:3679552]。

也许最令人兴奋的是，TEE 促成了一种从纯粹隔离到安全*协作*的转变。想象几个组织，比如多家医院，希望在不向彼此透露敏感数据的情况下，利用他们合并的患者数据来训练一个机器学习模型。他们可以使用机密计算。每家医院都可以在一个飞地内运行其计算部分。这些互不信任的飞地随后可以使用加密证明来建立一个安全的通信通道，并创建一个共享的加密状态。他们可以管理一个组加密密钥，并定期轮换以确保前向保密性，这样未来的妥协也不会泄露过去的数据。在这个模型中，没有任何一方——无论是医院还是云提供商——能看到原始数据，但他们都可以从集体计算中受益 [@problem_id:3686181]。

这个单一的想法——一个由硬件强制执行的小型可信环境——最初是为了保护应用程序免受其[操作系统](@entry_id:752937)的侵害。然而，正如我们所见，它的影响无处不在。它改变了系统设计的哲学，重新定义了[操作系统](@entry_id:752937)的架构，要求系统硬件进行新的协作，并最终在一个我们日益不信任的世界中为安全计算创造了全新的可能性。这是一个美妙的例子，展示了一个单一、强大的原则如何能够统一和照亮一个广阔而复杂的领域。