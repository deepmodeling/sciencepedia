## 引言
在复杂的软件世界中，管理[计算机内存](@entry_id:170089)是一项关键但通常不为人知的任务。程序不断地创建数据，如果没有一个强大的清理过程，它们会迅速耗尽可用资源。[半空间](@entry_id:634770)垃圾回收为这个[自动内存管理](@entry_id:746589)的基本问题提供了一个优雅且出人意料的简单解决方案。该技术不采用在一片混乱的内存空间中 meticulous 地跟踪和释放每一块死数据的方式，而是采取了一种截然不同的方法。但这场数据的“大迁徙”是如何运作的？其性能影响又是什么？

本文深入探讨了[半空间](@entry_id:634770)回收方法。第一章“原理与机制”解构了其核心算法，解释了复制存活对象如何实现无与伦比的分配速度，以及如何管理对象循环等挑战。随后的“应用与跨学科关联”一章展示了这一理论模型如何在现实世界的系统中应用，从分代回收器的高吞吐量引擎到实时计算和网络安全的严苛环境。读完本文，您不仅将清楚地了解这种方法的工作原理，还将明白为什么它至今仍是现代语言运行时的基石。

## 原理与机制

想象一下，你有一个大型而繁忙的工作室，你在这里制造东西。随着时间的推移，地板上堆满了完成的项目、剩余的材料和不再使用的工具，变得凌乱不堪。为了清理，你可能需要费力地四处走动，捡起每一片垃圾，并试图找到空位来放置你正在使用的工具。这个过程既繁琐，又会使你的工作空间因充满零碎、不便的小块空隙而变得支离破碎。

现在，假设隔壁就有一个一模一样、完全空置的工作室呢？与其清理那个脏乱的工作室，你可以简单地识别出你*当前*正在使用的所有工具和项目，只把这些东西搬到干净的工作室，并将它们整齐地[排列](@entry_id:136432)在一边。完成后，你只需锁上旧的、脏乱的工作室的门，然后彻底忘记它。当新的工作室变脏时，你再反向重复同样的操作。

这就是**[半空间](@entry_id:634770)垃圾回收**背后优美而简单的思想。它关乎的不是整理一个凌乱的空间，而是将重要的东西迁移到一个全新的、干净的空间。

### 大迁徙：复制如何工作

在[计算机内存](@entry_id:170089)的世界里，我们的“工作室”是两个大小相等的内存块，称为**半空间**（semi-spaces）。在任何时刻，我们运行的程序（通常称为 **mutator**，因为它会修改数据）只使用其中一个。这便是**源空间**（from-space）。另一个，即**目标空间**（to-space），则空置着，等待使用。

当程序在源空间中耗尽空间时，世界会暂停片刻。这个暂停是为了进行垃圾回收。回收器的任务是将所有“存活”对象——即我们的程序仍然可以访问到的数据——从源空间疏散到目标空间。

但它如何知道哪些对象是存活的？它从**根**（roots）开始。这些是程序可以立即访问的基本指针，比如存储在调用栈上或 CPU 寄存器中的变量。你可以把它们想象成你手中握着的工具的把手。任何被根指向的对象都是存活的。而任何被*另一个存活对象*指向的对象也是存活的。找到所有存活对象，就是从根开始，遍历这个庞大且相互连接的对象图的过程。[@problem_id:3634331]

最著名的[半空间](@entry_id:634770)回收算法——**Cheney 算法**的精妙之处正在于此。它不使用外部列表来追踪接下来要访问哪些对象，而是以一种极为巧妙的方式利用了目标空间本身。该算法在目标空间中维护两个指针：一个 `scan` 指针和一个 `free` 指针。

1.  初始时，`scan` 和 `free` 都指向空的目标空间的起始位置。
2.  回收器扫描根。对于找到的每个存活对象，它会将其复制到 `free` 指针所指向的地址，然后将 `free` 指针向前移动该对象的大小。
3.  处理完所有根之后，`scan` 和 `free` 之间的区域包含了第一波存活对象。这些对象已被复制，但它们*内部*的指针尚未处理。
4.  现在，主循环开始：当 `scan` 指针在 `free` 指针后面时，回收器检查 `scan` 指针处的对象。对于该对象中的每个指针字段，它会将所引用的对象复制到 `free` 指针的位置（如果尚未复制），并更新 `free` 指针。
5.  一旦 `scan` 指针处的对象中的所有指针都处理完毕，`scan` 指针就会越过该对象，移向下一个。

这里的奇妙之处在于，`scan` 和 `free` 指针之间的内存区域扮演了一个完美的先进先出（FIFO）队列。对象在被发现时被添加到队列的末尾（在 `free` 处），并从队列的前端（在 `scan` 处）被处理。使用 FIFO 队列的[图遍历](@entry_id:267264)，根据定义，就是**[广度优先搜索](@entry_id:156630)（BFS）**。目标空间本身成为了遍历的[数据结构](@entry_id:262134)！[@problem_id:3634277]

这种 BFS 遍历有一个极好的副作用。在图中彼此靠近的对象（例如，一个列表的头节点及其最初的几个节点）往往会在几乎同一时间被复制到内存中，最终在目标空间中物理上彼此相邻。这种被称为**空间局部性**（spatial locality）的特性可以显著加快回收后程序的运行速度，因为现代 CPU 访问连续存储的数据要快得多。[@problem_id:3634277]

### 避免迷失的艺术：转发指针

这次迁移中有一个难题。如果两个对象 A 和 B 都指向对象 C 怎么办？或者如果一个对象 D 指向自己，形成一个环怎么办？如果我们不小心，我们的遍历可能会复制 C 两次，或者在追踪 D 的自引用时陷入无限循环。

Cheney 算法用另一个同样优美简单的技巧解决了这个问题：**转发指针**（forwarding pointer）。当一个对象从源空间中的旧地址被复制到目标空间中的新地址时，回收器会在旧地址处留下一个“便条”。这个便条就是新地址，它被称为转发指针。旧对象的头部，过去包含对象类型等信息，现在被这个新地址覆盖。

现在，回收器的规则变成：“在你复制一个对象之前，检查它在源空间中的头部。如果你发现一个转发指针，这意味着该对象已经被移动了。不要再次复制它！只需从转发指针中读取新地址并更新你的引用即可。”

让我们来追踪一个自引用对象 $x$ 的情况，其中 $x.f = x$。当回收器首次发现 $x$ 时，它检查其头部，没有发现转发指针，然后继续：
1.  它将 $x$ 复制到目标空间中的一个新位置 $x'$。
2.  它*立即*用 $x'$ 的地址覆盖旧 $x$ 的头部。一个转发指针现在就位了。
3.  之后，当扫描 $x'$ 的字段时，它发现字段 $f$ 仍然包含 $x$ 的旧地址。它尝试复制这个旧地址处的对象。
4.  这一次，当它检查旧 $x$ 的头部时，它发现了指向 $x'$ 的转发指针。它使用这个地址来更新字段 $x'.f$，并且不会创建另一个副本。

这个简单的“先复制并转发，再检查”的原则，优雅而高效地处理了任何复杂的图结构，包括共享对象和环，确保每个存活对象都只被复制一次。[@problem_id:3634295]

### 回报：速度与简洁

所有存活对象迁移完毕后，它们被整齐、连续地打包在目标空间的起始位置。旧的源空间被完全废弃。然后角色互换：目标空间成为程序工作的新源空间，而旧的源空间则成为新的、空置的目标空间。

这种对存活对象的“整理”（compaction）提供了复制回收最重要的性能优势之一：快如闪电的分配。由于所有空闲内存现在都位于一个巨大的连续块中，分配一个新对象变得异常简单。运行时维护一个指向这个空闲块起始位置的指针。要分配一个大小为 $k$ 的对象，它只需做两件事：
1.  检查是否有足够的空间。
2.  将指针“碰撞”式地增加 $k$，并返回此前的地址。

这被称为**[指针碰撞分配](@entry_id:747014)**（bump-pointer allocation）。它是一种极其廉价、常数时间（$O(1)$）的操作，仅涉及一次比较和一次加法。它完全避免了在“空闲列表”（free list）中搜索碎片化的内存块以找到合适大小的块这一复杂且通常缓慢的过程。[@problem_id:3634268] [@problem_id:3634341]

此外，在这种方案中，“释放”或“回收”一个对象的成本是多少？是零。单个对象永远不会被释放。当源空间被废弃时，整代的死对象被一次性全部回收。这意味着一次回收的成本只与它必须复制的*存活*数据量成正比，而与它回收的垃圾量或堆的总大小无关。对于创建大量短生命周期对象的程序（一种非常常见的模式）来说，这是一个巨大的性能胜利。[@problem_id:3634268]

### 门票的代价：分摊成本与基本限制

这种效率并非没有代价。主要成本在于复制行为。一个程序的长生命周期数据越多，回收器在每个周期中必须做的工作就越多。我们可以通过考虑**分摊成本**（amortized cost）来分析这一点：即总 GC 成本分摊到触发它的那些分配上。

假设一个半空间的大小为 $S$，一次回收后，有 $L$ 字节的存活对象。这意味着程序有 $S - L$ 字节的空闲空间可供分配，然后才会触发下一次回收。那次回收的成本将与复制下一代存活对象（我们假设其大小也约为 $L$）成正比。因此，每分配一字节的分摊成本大致与 $\frac{L}{S - L}$ 成正比。[@problem_id:3236421]

这个简单的分数揭示了半空间回收的阿喀琉斯之踵。随着存活数据量 $L$ 越来越接近半空间大小 $S$，分母 $(S - L)$ 趋近于零，分摊成本急剧飙升。系统进入一种**颠簸**（thrashing）状态，几乎所有时间都花在垃圾回收上，而几乎没有取得任何进展。[@problem_id:3634329] 更详细的分析表明，每分配一个单位的分摊成本是 $1 + \frac{\gamma \alpha}{1 - \alpha}$，其中 $\alpha = L/S$ 是存活率，$\gamma$ 是复制一个单位数据的成本。'1' 代表分配本身的成本，而分数部分是分摊的 GC 税，当 $\alpha \to 1$ 时，这部分显然会爆炸式增长。[@problemid:3206491]

此外，还有一个硬性的物理限制。为了使回收成功，目标空间必须足够大以容纳所有存活对象。这给了我们一个基本条件：$L \le S$。如果在任何时候存活数据超过了一个[半空间](@entry_id:634770)的大小，回收将因内存不足错误而失败。根本没有空间来完成迁移。[@problem_id:3634291] [@problem_id:3634329]

### 看不见的握手：GC 与编译器

一个移动式垃圾回收器无法孤立工作。它依赖于与语言编译器之间深入而密切的合作。要移动一个对象，GC 必须能够找到并更新*每一个*指向它的指针。这需要一个**精确式 GC**（precise GC），它能绝对确定内存中的一个给定值是指针还是仅仅是数据（如整数）。

如果回收器是**保守式**的（conservative）——也就是说，如果它猜测任何*看起来像*内存地址的数字*就是*一个内存地址——那将是一场灾难。回收器可能会“更新”一个用户的账号，因为它恰巧与它移动的一个对象的地址相似，从而导致无声且灾难性的[数据损坏](@entry_id:269966)。移动式回收器必须确切知道。[@problem_id:3634331]

这种对精确性的需求意味着编译器必须为 GC 提供一张所有根的映射图。即使在寄存器或栈上漏掉一个根指针，也可能导致回收器忽略一个巨大的存活对象图，然后错误地回收它们。[@problem_id:3634331] 这种合作关系延伸到[编译器优化](@entry_id:747548)。例如，**内联**（inlining）一个函数似乎是减少调用开销的简单优化，但在内存压力高的系统（$L \approx S$）中，它可能产生深远的影响。它可能无意中延长了对象的生命周期，增加了 $L$，并将系统推向颠簸状态。相反，内联有时可以启用进一步的优化，如**标量替换**（scalar replacement），即将一个[堆分配](@entry_id:750204)对象完全替换为局部变量，从而*消除*分配并减少 $L$。一个复杂的、具有内存意识的编译器必须在这种微妙的权衡中进行导航。[@problem_id:3634329]

### 更深的水域：指针与同一性

现实世界总是比简单的模型要复杂一些。例如，一些编程语言允许**内部指针**（interior pointers）——即指向对象内部某个字段而非对象开头的指针。一个基本的 Cheney 算法会对此感到困惑，因为它不知道对象的头部在哪里，也就无法找到其大小或安装转发指针。支持此功能的实用系统通过一个“对象定位器”函数来扩展其运行时，该函数可以从对象内的任何地址找到对象的起始位置，从而允许根据对象新的基地址正确更新内部指针。[@problem_id:3634347]

最后，移动式回收器迫使我们思考一个堪称哲学的问题：如果一个对象被移动到一个新地址，它还是同一个对象吗？这是计算机科学领域的“忒修斯之船”问题。答案对语言如何定义相等性有重大影响。
-   **结构相等性**（`val_eq(x, y)`），即检查两个对象是否具有相同的内容，不受影响。副本是完美的复制品。
-   **引用同一性**（`ref_eq(x, y)`），即检查两个变量是否指向同一个对象，则存在问题。如果同一性由内存地址定义，那么在回收前 `x == y` 可能为真，回收后则为假，这使得程序行为不可预测且依赖于 GC 的时机。

为了保持理智，安全的语言必须将同一性与地址[解耦](@entry_id:637294)。一个常见的解决方案是在每个对象创建时为其分配一个不可变的、唯一的**身份令牌**（identity token）。这个令牌随对象一起移动。`ref_eq(x, y)` 操作就只是比较这些隐藏的令牌。这为程序员提供了他们所期望的稳定同一性概念，同时赋予垃圾回收器根据需要移动对象的自由——这是一个完美的折衷，既保留了语义清晰度，又保证了实现效率。[@problem_id:3634332]

