## 引言
在[数字电子学](@article_id:332781)的世界里，复杂是由简单构建而成的。任何数字功能都可以由基本的[逻辑门](@article_id:302575)构成，但单独连接这些[逻辑门](@article_id:302575)会产生笨重且不灵活的电路。这就引出了一个关键问题：我们如何以紧凑、适应性强且高效的形式创建复杂的自定义逻辑？答案在于[可编程逻辑器件](@article_id:357853)，其中最具影响力的之一就是[通用阵列逻辑](@article_id:343964)（GAL）芯片。本文深入探讨了 GAL 的架构和应用，为理解抽象逻辑如何转化为物理现实提供了蓝图。以下章节将首先剖析 GAL 的核心**原理与机制**，从其独特的可编程“与”/固定“或”结构到其革命性的可重编程性。随后，我们将探讨其现实世界的**应用与跨学科联系**，展示这个单一器件如何整合混乱的电路、构建智能状态机，并弥合人类设计与硅片执行之间的鸿沟。

## 原理与机制

想象你有一盒乐高积木。用一套有限的、简单的、[标准化](@article_id:310343)的积木块，你可以搭建出几乎无穷多样的结构，从简单的房子到精巧的星际飞船。数字逻辑世界的工作方式也惊人地相似。本质上，任何复杂的数字功能，无论多么精密，都可以由基本的逻辑运算——与、或、非——组合而成。具体来说，任何函数都可以用一种称为**[积之和](@article_id:330401)（SOP）**的标准形式来表示。这是我们的蓝图。它告诉我们，我们可以通过先生成一组“乘积”项（使用与门），然后将它们“求和”（使用或门）来创建任何[逻辑电路](@article_id:350768)。

这个简单而强大的思想是[可编程逻辑器件](@article_id:357853)的灵魂。它们本质上是一块通用的、可重新配置的[与门](@article_id:345607)和或门画布，等待设计师在上面施加特定的模式。

### 逻辑的蓝图：可编程的“与”，固定的“或”

让我们从最灵活的画布开始思考。我们可以想象一个由可编程[与门](@article_id:345607)组成的网格，后面跟着一个可编程或门组成的网格。通过对两个网格中的连接进行编程，我们可以创建任何乘积项，然后将这些项的任意组合用于我们的最终输出。这种高度灵活的器件是存在的，它被称为**[可编程逻辑阵列](@article_id:348093)（PLA）**。它提供了最大的自由度，但这种自由度是以复杂性和性能为代价的。

**[通用阵列逻辑](@article_id:343964)（GAL）**器件体现了一种非常巧妙的工程折衷。它没有让所有东西都可编程，而是简化了设计。GAL 有一个**可编程的“与”平面**，但有一个**固定的“或”平面**[@problem_id:1939699]。这就像一家餐厅，提供可定制的三明治吧台，但三明治如何组合成套餐的菜单是固定的。你可以完全自由地为每个三明治选择配料（乘积项），但最终的组合（和项）是预先确定的。例如，一个输出可能被硬连线为总是，比如说，八个特定乘积项线路的和。这种架构选择是 GAL 的决定性特征，正如我们将看到的，它的“局限性”也是它最大的优势。

### 建立连接：编程如何工作

那么，“与”平面“可编程”意味着什么呢？让我们深入内部一探究竟。想象一组垂直走线，承载着输入信号（如 $A$ 和 $B$）及其补码（$A'$ 和 $B'$）。水平走线是“乘积项线路”，每一条都通向一个与门。在每条垂直输入线和水平乘积项线的[交叉](@article_id:315017)点，都有一个可编程的开关或单元。

这个单元的状态决定了一个输入是否被包含在一个乘积项中。最初，所有单元都处于“擦除”状态，就像一个打开的开关。在这种状态下，输入线是断开的，对于一个与门来说，断开的输入行为类似于逻辑“1”——它对结果没有影响。为了将一个输入包含在我们的乘积项中，我们“编程”相应的单元，闭合开关，将输入线连接到[与门](@article_id:345607)。

让我们尝试为输入 $A$ 构建一个简单的反相器，这样我们的输出 $F$ 应该是 $F = A'$。我们的 GAL 输出固定为两个乘积项的和，即 $F = P_1 + P_2$。为了得到我们想要的函数，我们可以简单地设置 $P_1 = A'$，并确保第二个乘积项 $P_2$ 始终为“0”。

为了使 $P_1 = A'$，我们查看第一个与门所在行的单元。我们找到与输入线 $A'$ 的[交叉](@article_id:315017)点并对该单个单元进行编程。我们将 $P_1$ 的所有其他单元（连接到 $A$、$B$、$B'$ 等）保留在擦除状态。$P_1$ 的与门现在计算：

$$
P_1 = A' \cdot 1 \cdot 1 \cdot 1 \dots = A'
$$

就这样，通过编程一个单一的连接，我们已经将我们的逻辑蚀刻到了硅片上 [@problem_id:1939710]。通过编程不同的单元组合，这个相同的通用结构可以被用来实现种类繁多的函数。

### 可擦除的草图：可重编程的魔力

这就引出了 GAL 最具革命性的方面。在像**[可编程阵列逻辑](@article_id:351927)（PAL）**这样的旧式器件中，“编程”是一个相当粗暴、单向的过程。那些单元是微小的熔丝，编程过程需要通过大电流来真正烧断你想要断开的熔丝。这是永久性的。如果你犯了错误或需要更新逻辑，你唯一的选择就是丢弃芯片，重新开始。

GAL 引入了一种远为优雅的解决方案，它基于与**[电可擦除可编程只读存储器](@article_id:355199)（[EEPROM](@article_id:355199)）**相同的技术。每个[交叉](@article_id:315017)点的开关是一种特殊类型的晶体管，称为**[浮栅晶体管](@article_id:351006)**。它有一个微小的、电隔离的导电材料“岛”——浮栅。通过施加精确的电压，我们可以将电子强制推到这个岛上，它们会被困在那里。这些被困的[电荷](@article_id:339187)改变了晶体管的行为，有效地“闭合”了我们的开关。

这种机制的美妙之处在于它是可逆的。通过施加不同的电压，我们可以将电子从岛上引诱出来，“擦除”单元并重新打开开关 [@problem_id:1939737]。这种能够被电擦除和重编程（可能数千次）的能力，正是使 GAL 成为“通用”的原因。它不再是刻在石头上的永久雕刻，而是一块可擦除的画板 [@problem_id:1955198]。

这一特性彻底改变了设计和调试过程。有了 GAL，工程师可以试验一个设计，发现一个错误，然后简单地用修正后的版本重新编程芯片——所有这一切都无需将其从电路板上取下。这种能力，被称为**在系统编程（ISP）**，意味着你可以在机器仍在原位时更新它的大脑，这是一个巨大的优势，节省了无数的时间和资源 [@problem_id:1939683]。

### 瑞士军刀：[输出逻辑宏单元](@article_id:356906)（OLMC）

可编程的“与”平面为我们的逻辑功能提供了原材料，但 GAL 的真正力量和多功能性来自于接下来发生的事情。固定“或”平面的输出并不仅仅是直接连接到一个输出引脚；它会通过一个高度可配置的电路块，称为**[输出逻辑宏单元](@article_id:356906)（OLMC）**。OLMC 就像一把瑞士军刀，功能丰富，允许每个输出都能为特定任务量身定制 [@problem_id:1955142]。

让我们看看它最重要的几个工具：

*   **寄存器模式 vs. 组合模式：** OLMC 提供了一个根本性的选择。在**简单（或组合）模式**下，[或门](@article_id:347862)的输出直接传递到引脚。这用于实现“无状态”逻辑，比如一个简单的计算器，其输出仅取决于当前的输入。但如果我们需要内存呢？为此，我们有**寄存器模式**。在这种配置下，逻辑输出被送入一个**D 型[触发器](@article_id:353355)**——一个单位的存储元件。然后，[触发器](@article_id:353355)的输出被发送到引脚。这个输出只在系统时钟的节拍上更新，这使得 GAL 能够实现**[同步时序电路](@article_id:354264)**——具有状态和内存的电路，如计数器和状态机 [@problem_id:1939720]。

*   **反馈路径：** 为了构建一个状态机，电路需要知道自己当前的状态来决定下一步做什么。OLMC 通过一个巧妙的**反馈路径**实现了这一点。[触发器](@article_id:353355)的输出（当前状态）不仅被发送到输出引脚，还被路由*回*可编程的“与”平面，成为逻辑阵列可用的另一个输入 [@problem_id:1939728]。这允许设计师创建依赖于外部输入和当前内部状态的下一状态逻辑方程——这正是状态机的定义。

*   **可编程极性：** 有时，由于[布尔代数](@article_id:323168)的规则，为实际所需函数的*[反函数](@article_id:639581)*设计逻辑要简单得多。OLMC 通过在输出路径中设置一个可编程的异或门来适应这种情况。通过编程其一个输入，这个门可以被配置为要么让信号不变地通过（高电平有效），要么反转它（低电平有效），为设计师提供了宝贵的灵活性 [@problem_id:1955142]。

*   **三态控制：** 在许多系统中，多个设备需要共享一组公共导线（总线）。这就要求一个设备不仅能用“0”或“1”驱动总线，还能有效地将自己断开。OLMC 的输出驱动器可以被置于**[高阻态](@article_id:343266)（或三态）**模式，这就像一个打开的开关。这由来自“与”阵列的一个专用乘积项控制，允许 GAL 决定何时在总线上“说话”，何时“倾听”，从而实现双向 I/O 引脚 [@problem_id:1955142]。

### 可预测之美

让我们回到 GAL 的“折衷”：固定的“或”平面。虽然 PLA 的全可编程“或”平面提供了更多组合乘积项的方式，但它也引入了不确定性。传播延迟——信号穿过门所需的时间——可能会根据给定输出所求和的乘积项数量而变化。更多的项意味着更大、更复杂的[或门](@article_id:347862)，这可能会更慢。

GAL 的固定“或”平面完全避开了这个问题。因为每个输出的[或门](@article_id:347862)结构都是固定的且完全相同，所以通过这一级的[传播延迟](@article_id:323213)是**恒定且可预测的**。无论你的逻辑功能多么简单或复杂（只要它能容纳在可用的乘积项内），时序都保持不变 [@problem_id:1939722]。对于高速数字系统的设计者来说，这种可预测性不是一个限制；它是一份礼物。它简化了[时序分析](@article_id:357867)，并有助于保证电路能以[期望](@article_id:311378)的速度可靠工作。这是一个绝佳的例子，说明一个精心选择的约束如何能导向一个更稳健、更优雅的设计。

### 超越[单体](@article_id:297013)结构：一块垫脚石

GAL 架构及其单一、庞大的可编程“与”平面是一种[单体](@article_id:297013)设计。它在其功能范围内非常高效，但它有一个关键的局限性。每个 OLMC 都有固定数量的乘积项可以使用。如果你的一个输出的逻辑方程需要九个乘积项，但 OLMC 只提供八个，那么这个设计就根本无法适配——即使芯片上所有其他 OLMC 都完全未使用。没有办法从芯片的一部分借用资源给另一部分 [@problem_id:1939690]。

这个局限性为[可编程逻辑](@article_id:343432)演进的下一步铺平了道路：**[复杂可编程逻辑器件](@article_id:347345)（CPLD）**。一个 CPLD 可以被看作是由多个较小的、类似 GAL 的逻辑块组成的阵列，所有这些块都通过一个中央[可编程互连](@article_id:351286)连接在一起。这种结构克服了[单体](@article_id:297013)瓶颈。如果一个逻辑块的资源用尽，中央[交换矩阵](@article_id:371379)可以将信号路由到另一个逻辑块来完成任务。因此，GAL 代表了一块至关重要且才华横溢的垫脚石——一个在单一阵列上完善了可重编程逻辑艺术的器件，其原理为后来更强大的器件奠定了基础。