## 引言
在软件开发中，将源代码转化为功能性程序的过程——即“构建”——似乎应该是一个确定性的、机器般的过程。遵循同样的配方每次都应产生相同的结果。这一理想状态被称为**可复现构建**，即任何人都可以从其源代码重新创建出比特级完全相同的软件。然而，在这种简单的期望与现实之间存在着巨大的鸿沟。构建过程经常受到隐藏变异来源的困扰，导致相同的输入产生不同的输出，从而在软件供应链中造成了关键的漏洞。

本文旨在通过对可复现构建进行全面概述来应对这一挑战。首先，文章将深入探讨**原理与机制**，揭示那些导致非确定性的“机器中的幽灵”——即微妙的环境因素和随机性——并探索为驾驭它们而开发的强大技术。随后，文章将探讨其深远的**应用与跨学科联系**，展示可复现性不仅是一个技术细节，而且是现代安全的基石，是抵御深层次威胁的防线，也是确保科学发现完整性的革命性力量。我们将从剖析构建的内部结构开始，以理解其理想状态与现实世界中挑战它的复杂性。

## 原理与机制

### 构建的剖析：一个钟表宇宙？

想象你有一个制作蛋糕的食谱。如果你遵循指示——相同的配料、相同的份量、相同的烤箱温度、相同的烘焙时间——你期望每次都能得到相同的蛋糕。在软件世界里，将人类可读的源代码转化为可执行程序的过程被称为**构建**，而食谱就是构建脚本。乍一看，这个过程似乎应该是一台完美的、确定性的机器。

我们可以将编译器或构建系统想象成一个数学函数，一个我们放入某些东西就能得到特定产出的黑匣子。我们将这个函数称为 $T$，代表“转换”（translation）。最明显的输入是源代码，我们称之为 $S$，以及配置，我们称之为 $C$，它包括我们提供给编译器的所有设置和标志，如优化级别或目标计算机架构。在这个理想世界中，构建是一个简单的转换：$T(S, C) \to A$，其中 $A$ 是最终的产物，即我们的二[进制](@entry_id:634389)程序 [@problem_id:3678618]。

如果这个模型是真实的，我们的生活就会很简单。任何人在任何地方，只要使用相同的源代码 $S$ 和相同的配置 $C$，都会生成一个与我们比特级完全相同的二[进制](@entry_id:634389)文件 $A$。我们只需通过重新构建并比较结果的加密哈希（一种数字指纹）就可以验证任何软件的完整性。如果哈希值匹配，程序就是相同的。这就是**可复现构建**的核心承诺，一个优美而简单的原则。但当我们仔细观察时，会发现现实世界并非如此井然有序。这个钟表宇宙的齿轮中存在着幽灵。

### 机器中的幽灵：变异的来源

实际上，我们简单的函数 $T(S, C) \to A$ 是一种因省略而产生的谎言。构建过程并非与世隔绝；它对一系列不属于源代码或显式配置的隐藏输入非常敏感。为了更真实地描绘情况，我们必须扩展我们的模型以包含这些幽灵：$T(S, C, E, R) \to A$ [@problem_id:3678618]。在这里，$E$ 代表构建**环境**，$R$ 代表**随机性**。这些幽灵困扰着我们的构建过程，在我们期望一致的地方制造出令人抓狂的、细微的差异。

**环境 ($E$) 作为隐藏变量**

环境是构建过程中可以“看到”、“听到”或“感觉到”的一切周边事物。

首先，是**时间的暴政**。构建发生在何时？许多工具默认情况下会贴心地将时间戳嵌入它们创建的二进制文件中。编译器可能会定义像 `__DATE__` 和 `__TIME__` 这样的特殊宏，它们会在编译时刻被解析。甚至[文件系统](@entry_id:749324)也参与其中。如果在一个软件容器内运行的构建过程创建了一个新文件，该文件的修改时间（`mtime`）将被设置为容器的当前时钟。如果你运行两个完全相同的构建，但为每个构建设置不同的容器时钟，那么输出文件上的 `mtime` 时间戳就会不同，从而破坏可复现性 [@problem_id:3665428]。

其次，是**空间的混乱**。构建发生在哪里？编译器需要知道源文件的位置以生成调试信息。它通常会将完整的绝对路径——例如 `/home/user/project/src/main.c`——直接嵌入到二[进制](@entry_id:634389)文件中。如果另一个人在不同的目录（比如 `/var/build/project/src/main.c`）中运行相同的构建，路径就会不同，最终的二[进制](@entry_id:634389)文件也将不完全相同 [@problem_id:3634637]。

第三，是**人群的低语**。构建过程对你可能从未想过的环境设置很敏感。系统的语言和字符排序规则（区域设置，或 `LC_ALL`）、时区（`TZ`），甚至当前的用户和组 ID 都可能微妙地影响工具的输出，在这里或那里改变一个字节或一个字符串 [@problem_id:3634616]。

最后，是**无序事物的骚动**。当构建脚本需要编译一个文件列表时，它可能会从[文件系统](@entry_id:749324)中收集这些文件。但[文件系统](@entry_id:749324)能保证每次都以相同的顺序列出文件吗？不一定。这种非确定性排序会传播开来，改变文件链接到库或可执行文件中的顺序。两个构建过程可能会以不同的顺序处理同一组文件，从而产生不同的最终产物，即使每个文件的内容都完全相同 [@problem_id:3678618]。

**随机性 ($R$) 与内部混乱 ($\mathcal{N}$)**

有时，变异并非偶然，而是故意的。为了找到复杂问题的更优解，一些编译器采用[随机化算法](@entry_id:265385)。像[寄存器分配](@entry_id:754199)这样的阶段，它决定如何使用 CPU 宝贵的少量寄存器，可能会使用随机种子来探索不同的策略 [@problem_id:3678618]。编译器内部的数据结构，如[哈希表](@entry_id:266620)，可能会使用随机化种子来防御[拒绝服务](@entry_id:748298)攻击 [@problem_id:3629649]。如果这些种子不受控制，编译器的每次运行都会不同。

最糟糕的是**内部[非确定性](@entry_id:273591)**，我们可以称之为 $\mathcal{N}$。当构建工具本身存在缺陷或设计缺陷时，就会发生这种情况，例如仅在并行构建（`make -j8`）时出现的竞态条件。在这种情况下，即使在完全相同的环境和受控的随机性下，该工具也像一台有故障的机器，从相同的输入产生不同的输出 [@problem_id:3678618]。这不是一个隐藏的输入；而是机器本身确定性本质的崩溃。

### 驾驭幽灵：确定性的技艺

面对这一系列五花八门的变异，要实现一个真正可复现的构建似乎希望渺茫。但多年来，一个由数字工匠组成的社区已经开发出了一套强大的技术——一种现代驱魔术——来驾驭这些幽灵并恢复构建过程的秩序。

策略很简单：识别每一个[非确定性](@entry_id:273591)的来源，并系统地消除它或将其置于控制之下。

为了对抗**时间的暴政**，我们可以为构建设置一个通用时钟。一个名为 `SOURCE_DATE_EPOCH` 的环境变量已成为一个标准，它指示所有兼容的工具假装构建发生在一个特定的、固定的时间戳——例如，最后一次源代码提交的时间。这冻结了时间，确保所有嵌入的时间戳在任何地方的所有构建中都是相同的 [@problem_id:3634637] [@problem_id:3634616]。

为了解决**空间的混乱**，我们指示编译器重写路径。我们为它提供一个前缀映射，告诉它，例如，“无论你在哪里看到路径 `/home/user/project/`，都将其替换为一个通用标记，如 `/src/`。” 这确保了没有特定于机器的[目录结构](@entry_id:748458)会泄露到最终的二[进制](@entry_id:634389)文件中 [@problem_id:3634637]。在像容器这样提供一致文件系统布局的受控环境中运行构建，进一步帮助[标准化](@entry_id:637219)“空间”。

为了平息**人群的低语**并驾驭**无序事物的骚动**，我们强制执行一个规范化上下文。我们固定区域设置、时区和用户 ID。我们在将任何文件列表提供给编译器或归档器之前，都明确地对它进行排序。我们配置工具以使用其确定性模式，例如，告诉归档器 `ar` 对库中的文件使用稳定的排序 [@problem_id:3634616]。我们设计编译器遍（pass）管理器，使其使用带有确定性决胜规则（如按字母顺序）的稳定[拓扑排序](@entry_id:156507)，而不是依赖哈希表的任意迭代顺序 [@problem_id:3629649]。

最后，我们掌控**随机性**。对于工具链中任何使用随机种子的部分，我们提供一个从构建输入派生出来的固定的、确定性的种子 [@problem_id:3634637]。这使得“随机”选择变得可预测和可重复。

通过应用这些技术，我们将构建过程从一个混乱、不可预测的事件转变为一个纯粹的、确定性的函数。幽灵被驯服了。当我们拥有一个可复现的构建时，我们就可以满怀信心地为输出生成一个加密哈希。这个哈希成为软件的通用标识符，使得内容寻址缓存等强大应用成为可能，如果完全相同的产物已经存在，就可以避免重新构建 [@problem_id:3620723]。但最重要的应用不是关于效率，而是关于信任。

### 何必如此？安全之需

为什么要费这么多周折？答案是，可复现构建是现代[软件供应链安全](@entry_id:755014)的基石。

想象一下你从互联网上下载了一个浏览器。供应商也提供了源代码。你如何知道你下载的可执行文件确实是从那个源代码构建的？如果攻击者在供应商的构建服务器上植入了后门，并在浏览器二进制文件发布前将其插入呢？源代码保持原始状态，而供应商在不知情的情况下，用他们的官方密钥签署了恶意的二进制文件。你计算机的安全机制，如[安全启动](@entry_id:754616)（Secure Boot），会检查签名，发现它有效，然后毫无怨言地运行该程序。最终内核二进制文件的度量值也将与供应商（被篡改的）清单相匹配，甚至能挫败基本的[可信启动](@entry_id:751820)证明（Measured Boot attestations） [@problem_id:3679558]。

这就是**构建器受损攻击**，它非常有效，因为它攻击的是我们对软件来源的信任。这时，可复现构建就成了我们的试金石。如果一个构建是可复现的，你——或任何独立的第三方——可以下载源代码，按照确定性的配方执行构建，并计算结果的哈希值。然后你将你的哈希值与供应商发布的哈希值进行比较。

如果哈希值匹配，你就有了强有力的加密证明，证明你拥有的二[进制](@entry_id:634389)文件与你检查过的源代码相对应。如果哈希值*不*匹配，警报就会响起。有些东西不一样了。二进制文件被篡改了。可复现构建使我们能够独立验证供应链的完整性，并检测到这类攻击 [@problem_id:3673389]。

这个原则延伸到了[编译器安全](@entry_id:747554)中最深层、最著名的问题：“信任之信”攻击，由 Ken Thompson 在他 1984 年的图灵奖演讲中首次描述。如果你用来构建新程序的编译器本身就是恶意的，该怎么办？它可以被编程为检测到自己正在编译一个登录程序时插入一个后门，并且在检测到自己正在编译一个新版本的自身时，将这套同样的恶意逻辑注入其中。这种攻击会永远自我延续，而不会在任何源代码中留下证据。

抵御这种深层次攻击的防御方法是一种称为**多样化双重编译**（Diverse Double-Compiling，DDC）的技术。你拿来新编译器的源代码，使用两个完全独立的、多样化的现有编译器（比如 GCC 和 Clang）进行两次构建。如果其中一个被感染了，它会产生一个恶意的新编译器，而干净的那个会产生一个干净的新编译器。由于两个结果二[进制](@entry_id:634389)文件会不同，比特级的比较将揭露这次攻击 [@problem_id:3634583]。只有当构建过程是可复现的时，这种比较才可能实现。

将整个构建（可能包含数千个文件）的状态总结为单个可验证的哈希，这是一个强大的概念。先进的系统使用**[默克尔树](@entry_id:634974)**（Merkle trees）——即哈希之树——来创建一个单一的根哈希，代表所有构建产物的集体状态。这既允许高效的整体验证，又能快速定位任何被篡改的单个文件，为我们提供了一种可扩展的方式来确保即使是最复杂的软件系统的完整性 [@problem_id:3634604]。

最终，对可复现构建的追求是从一个优雅但有缺陷的理想走向一个混乱复杂现实的旅程。它要求我们成为数字侦探，追捕隐藏的变异来源。但通过掌握确定性的技艺，我们不仅能构建出更好、更可靠的软件，还能锻造出在数字世界中建立可验证信任基础所必需的工具。

