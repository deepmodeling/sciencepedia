## 应用与跨学科关联

既然我们已经掌握了分支预测的机制，我们可能会想把它当作一项巧妙但深奥的工程技术，一个深藏于处理器硅芯中的细节，束之高阁。但这样做将错失其真正的魔力！因为正是在其关联性、意想不到的后果以及这种简单机制以惊人方式波及整个计算世界的过程中，它的真实特性才得以显现。分支预测器[混叠](@entry_id:146322)不仅仅是一个硬件怪癖；它是机器中的幽灵，是过去计算的回响，它以一种既是性能难题、又是安全噩梦，同时也是计算机科学相互关联性的绝佳例证的方式，塑造着现在。

### 性能幽灵：当好程序变慢时

想象一下，你编写了一段优美的代码——一个视频游戏，一个科学模拟——并且你已将其调优至完美。它运行得平稳且可预测。然后，有一天，它开始卡顿。不是一直如此，而是间歇性的。你检查了代码，但没有任何改变。原因可能是什么？你可能正被[混叠](@entry_id:146322)的幽灵所困扰。

考虑一下你的程序与[操作系统](@entry_id:752937)（OS）之间的持续对话。[操作系统内核](@entry_id:752950)是机器的主宰，它必须频繁地中断你的程序来处理其他事务：一次鼠标点击、一个来自网络的封包、一个计时器滴答。每当这种情况发生时，处理器会停止执行你的代码，并跳转到[操作系统](@entry_id:752937)中一个称为[中断处理](@entry_id:750775)程序的特殊例程。

这个处理程序有自己的分支、自己的循环、自己的计算节奏。在它运行时，它会在共享的分支预测器上留下自己的足迹。如果处理器的全局历史寄存器（$GHR$）比如说有 16 位长，而[中断处理](@entry_id:750775)程序哪怕只执行几十个分支，它也会完全覆盖掉你的程序最近决策的历史记录。预测器关于你的代码行为的记忆被清除得一干二净，取而代之的是内核簿记操作的记忆。当[操作系统](@entry_id:752937)将控制权交还给你的程序时，预测器实际上患上了“失忆症”。它查看你的下一个分支，参考一个现在完全不相关的历史，然后胡乱猜测。十有八九，它会猜错。流水线被清空，[时钟周期](@entry_id:165839)被浪费，你的程序出现卡顿 [@problem_id:3640490]。这不是你的代码或[操作系统](@entry_id:752937)中的错误；这是两个不同程序共享相同有限预测资源而产生的一种涌现属性。中断越频繁——即所谓的“中断风暴”——预测器重新学习你的程序行为的时间就越少，性能受损就越严重。

### 安全幽灵 Spectre：将预测变为背叛

几十年来，这个“性能幽灵”一直被视为仅仅是一个麻烦，一个不可预测的性能下降来源。但通过一次深刻的智力飞跃，研究人员意识到，如果一个程序的行为能够*无意*地影响另一个程序，那么它也能够被*有意*地操纵来达到此目的。如果这个幽灵可以被训练成一个间谍呢？

这就是被称为 Spectre 的一类安全漏洞背后的基本见解。攻击者可以编写一个程序，精心“雕刻”分支预测器的状态。通过以特定的分支模式运行自己的代码，他们可以在选定的预测器条目上制造混叠，有效地将其训练成以某种特定方式进行预测。然后，当系统切换到受害者进程——也许是你的网络浏览器正在处理密码，或者服务器正在访问私钥——该受害者进程可能会使用完全相同的预测器条目。此时，已被攻击者“投毒”的预测器会做出一次惊人的错误预测。它可能会推测性地执行一段本不应执行的代码，例如使用越界索引进行有[边界检查](@entry_id:746954)的数组访问 [@problem_id:3679417]。

尽管这种[推测执行](@entry_id:755202)最终会被捕获并取消，但为时已晚。这次短暂的、幽灵般的执行在另一个[微架构](@entry_id:751960)结构（如[数据缓存](@entry_id:748188)）中留下了痕迹。攻击者随后可以测量缓存的状态，从而推断出哪些数据被推测性地访问了，进而泄露了秘密。分支预测器，这个本应是忠实仆人的设计，却变成了一个不知情的叛徒。

这并非单一的技巧。攻击者可以针对预测器的不同部分。他们可以对模式历史表（PHT）进行投毒，以欺骗一个条件 `if` 语句；或者他们可以对分支目标缓冲区（BTB）进行投毒，以欺骗一个间接[函数调用](@entry_id:753765)，使其跳转到一个被称为“gadget”的恶意代码片段 [@problem_id:3679417]。这种威胁是如此根本，以至于即使是硬件强制的“安全世界”，如[可信执行环境](@entry_id:756203)（TEEs），也无法幸免。在“普通世界”中运行的攻击者仍然可以与在被认为是坚不可摧的 TEE 内部运行的代码产生[混叠](@entry_id:146322)，从而创建一个[侧信道](@entry_id:754810)来窥探其秘密 [@problem_id:3686136]。我们甚至可以建立精确的实验装置来测量这种跨进程干扰，量化攻击者能在受害者中诱发多少额外的错误预测，从而将一个幽灵般的影响转变为一个可测量的安全风险 [@problem_id:3679375]。

### 架构师的困境：驯服幽灵

我们如何驱除这些幽灵？驯服分支预测器[混叠](@entry_id:146322)的挑战激发了一系列创新，在硬件架构师、编译器编写者和[操作系统](@entry_id:752937)设计者之间建立了一场精彩的对话。

硬件方面一个直接的方法是放弃共享。如果共享是问题所在，那么我们就建立分区。架构师可以设计一个按进程ID（[PID](@entry_id:174286)）或安全域（例如，普通世界 vs. 安全区域）进行分区的预测器。每个进程都获得预测器表的私有部分，防止其历史干扰其他进程。但这带来了经典的工程权衡。要让两个进程在分区预测器中获得与在共享预测器中相同的预测准确度，你可能需要将预测器硬件的总大小加倍，这会消耗宝贵的硅片面积和功耗 [@problem_id:3629480]。你如何分配这宝贵的资源？如果一个安全区域程序只占用了比如说 36% 的分支，它是否应该获得 36% 的预测器条目？利用[数学优化](@entry_id:165540)的工具，设计者实际上可以计算出最优的分区方案，以最小化整个系统的总错误预测数，从而为给定的工作负载找到完美的[平衡点](@entry_id:272705) [@problem_id:3686151]。

这场战斗也在软件层面进行。如果攻击者通过创建一个其地址与受害者地址冲突的调用点来对 BTB 进行投毒，或许我们可以移动这些调用点！一个聪明的编译器或链接器，如果了解 BTB 的索引函数，可以将关键的[间接分支](@entry_id:750608)放置在不太可能发生冲突的地址上，这种技术被称为代码对齐 [@problem_id:3679424]。

更微妙的是，编译器自身的优化也必须被重新评估。一种称为基于剖析的优化（PGO）的常用技术可能会观察到函数中的某个错误处理路径很少被执行，并决定将其内联以提高性能。但正是这个行为可能会在一个热点代码路径中引入一个新的条件分支。这个新分支的行为可能依赖于某个秘密，现在它可能通过分支预测器成为时序[侧信道](@entry_id:754810)泄露的来源。一个为速度而设计的优化可能无意中打开了一个安全漏洞 [@problem_id:3629602]。这催生了一个令人兴奋的新领域：*安全感知编译器*，它必须扩展其传统的成本模型。它们不能只问：“这会让代码更快吗？”它们还必须问：“这会让代码泄露更多信息吗？”有时，最安全的决策是*不*执行某项优化，例如将分支转换为[谓词指令](@entry_id:753688)，以避免污染预测器的历史 [@problem_id:3663876]。

从一个简单的性能[启发式方法](@entry_id:637904)开始，分支预测器[混叠](@entry_id:146322)带我们踏上了一段穿越系统性能、[操作系统](@entry_id:752937)设计、[硬件安全](@entry_id:169931)以及[编译器优化](@entry_id:747548)哲学的旅程。它证明了在现代计算这支错综复杂的舞蹈中，每个组件都是相互关联的。一次计算的回响总是存在，而我们作为科学家和工程师的职责就是去理解它们、控制它们，并确保它们为我们服务，而不是与我们为敌。