## 应用与跨学科联系

饿死原则，即被永久拒绝访问所需资源的概念，并非计算机科学中某个深奥的角落。它是一个深刻且反复出现的主题，是任何共享资源场景下都会出现的基本挑战。它的回响可以在经济学、社会系统中找到，而对我们而言最美妙的是，它几乎贯穿了现代[操作系统](@entry_id:752937)的每一层。要真正欣赏[操作系统](@entry_id:752937)，我们不能仅将其视为一堆机制的集合，而应视其为一位优雅的仲裁者，一位在持续不断的资源战争中不知疲倦地进行和平谈判的外交家。

让我们从一个我们自己世界的类比开始我们的旅程，一个我怀疑我们许多人都曾亲身感受过的类比。

### 显而易见的不公

想象一下，你负责一家网约车公司的[调度算法](@entry_id:262670)。你有汽车（一种资源）和城市的两个区域：一个繁忙的市中心高峰区 $S$，以及一个安静的居民区 $N$。来自市中心的请求如潮水般涌入，而来自居民区的请求则寥寥无几。最显而易见、利润最大化的策略似乎很简单：只要市中心有请求，就派最近的可用车辆过去。这是一种贪心算法，总是追逐眼前的高回报任务。只有在某个短暂的时刻，整个市中心区域的需求都得到满足时，你才会派车去那个安静的居民区。

在区域 $N$ 等待的人会怎样？他们可能永远也等不到车。即使车辆总数足以应付市中心*平均*的请求数量，一连串的坏运气——市中心新请求出现的时间点不幸地持续不断——也可能导致市中心的队列永远不会清空。区域 $N$ 的居民被饿死了。他们的请求被无限期地阻塞，不是因为车不够，而是因为调度策略对公平性视而不见 [@problem_id:3649111]。

这个简单而令人沮丧的场景，与[操作系统](@entry_id:752937)中一个天真的**严格[优先级调度](@entry_id:753749)器**所发生的情况完全相同。如果我们将“突发新闻”任务标记为高优先级，将“深度报道”任务标记为低优先级，那么一个严格的调度器只要有突发新闻要处理，就会一直处理，而将长期的深度报道工作弃置一旁 [@problem_id:3671582]。低优先级的任务被饿死了。

我们如何解决这个问题？在我们的网约车类比中，你可能会将一部分车队专门预留给那个居民区。这正是现代[操作系统](@entry_id:752937)可以做的事情。利用像 Linux 的**[控制组](@entry_id:747837)（[cgroups](@entry_id:747258)）**这样的机制，系统管理员可以像城市规划师一样，划定一条界限。他们可以声明，无论如何，一组必要的后台“内务”进程都保证获得 CPU 时间的特定份额 $\eta$。这划分出了一块受保护的资源预算，确保一个庞大的、消耗 CPU 的编译任务不会饿死维持系统平稳运行的关键服务。贪心算法被配额（quota）所制约，这是一种公平的保证 [@problem_id:3649138]。

### 超越 CPU：外围设备的风险

但是 CPU 并非城里唯一的资源。任何存在竞争的地方都可能发生饿死，而当我们与系统的外围设备交互时，其影响往往最为明显。

你是否曾经在向 U 盘复制大文件时，发现整个桌面环境变得迟缓和无响应？这是一个典型的 I/O 饿死案例。一个后台任务，向硬盘执行大量顺序写入，可能会独占该设备。为了提高效率，磁盘倾向于将这次大写入作为一个连续的块来处理。一个交互式任务——比如你的网页浏览器需要从其缓存中读取一个很小的文件——提交了它的请求，但这个请求却被卡在了那个庞大的写入操作后面排队。你的浏览器被饿死了，无法访问磁盘。这里的解决方案异常巧妙。[操作系统](@entry_id:752937)可以调整其**回写策略**（writeback policy），指示后台任务以更小、更频繁的块来写入数据。这可能会稍微降低大文件复制的整体吞吐量，但它为浏览器的紧急、小规模读取创造了机会窗口，使其能够穿插进去，从而保持了系统的响应性 [@problem_id:3690206]。

一个更直接的例子是你的鼠标移动。一个高分辨率的游戏鼠标每秒可以产生数百甚至数千个位置更新。每一个都是一个事件。与此同时，鼠标点击或按键也是一个事件。如果系统的图形事件队列以简单的先进先出方式处理，大量的“鼠标移动”事件可能会填满队列，导致一个关键的“按钮点击”事件的处理被延迟，以至于用户感觉系统被冻结了。点击事件被饿死了。[操作系统](@entry_id:752937)，作为一位明智的管理者，采用了**事件合并**（event coalescing）技术。它明白，对于一个每秒刷新 60 次的显示器来说，数千个中间的鼠标位置是无用的。它智能地将一连串快速的移动事件合并为代表*最新*位置的单个事件，从而清空队列，为那个至关重要的点击让路。它通过认识到并非所有工作都具有同等价值来防止饿死 [@problem_id:3665207]。

### 无形世界中的饿死

饿死现象最引人入胜的例子发生在[操作系统](@entry_id:752937)的隐藏机制中，在那些用户看不见的抽象领域里。

考虑虚拟内存。一个进程并不“拥有”物理内存；它只是被授予在 RAM 页面中的临时居住权。一个算法，比如 **CLOCK** 算法，在需要新页面时决定驱逐哪个页面。如果这个算法全局运行，在所有进程中寻找牺牲品，一种微妙的不公平就可能出现。一个大型、CPU 密集型的进程会不断访问其页面，使其“被引用”位保持设置状态。一个运行不频繁的小型、安静的进程，其页面的被[引用位](@entry_id:754187)可能会被调度器的周期性清扫操作清除。当大进程需要一个新页面时，清扫指针扫过，看到大进程的“正在使用”的页面，并跳过它们。然后它找到了小进程的“陈旧”页面并将其驱逐。小进程实际上被饿死了，失去了它的生存空间，被迫不断地遭受页错误（一种称为颠簸“thrashing”的状况），因为它无法与邻居的狂热活动竞争。解决方案是**隔离**（isolation）：转向本地替换策略，即一个进程的不良行为只会导致它驱逐*自己*的页面，而不是邻居的 [@problem_id:3655944]。

这个兔子洞 еще更深。在一个**虚拟化系统**中，一个完整的“客户”[操作系统](@entry_id:752937)仅仅作为“宿主”[Hypervisor](@entry_id:750489) 上的另一个进程运行。客户[操作系统](@entry_id:752937)认为它完[全控制](@entry_id:275827)着它的虚拟 CPU（vCPU），但宿主 Hypervisor 可以随时取消 vCPU 的调度，以运行另一个虚拟机。这就产生了一种叫做**被盗时间**（stolen time）的现象。客户[操作系统](@entry_id:752937)的调度器可能决定运行一个线程 10 毫秒，但如果 [Hypervisor](@entry_id:750489) 偷走了其中的 9 毫秒，该线程实际上只取得了 1 毫秒的进展。客户[操作系统](@entry_id:752937)的内部记账现在成了一派谎言。它可能会不公平地惩罚这个线程，因为它“耗时过长”，或者它可能会试图通过将任务迁移到一个在此时此刻完全处于休眠状态的 vCPU 来平衡负载。客户[操作系统](@entry_id:752937)本身被饿死了，无法获得它认为自己正在管理的资源！解决方案是一次漂亮的抽象突破：**[半虚拟化](@entry_id:753169)**（paravirtualization）。Hypervisor 向客户机打开一个特殊通道，明确地告诉它：“你被剥夺了这么多时间”，或者“不要在那个 vCPU 上调度；它目前处于休眠状态。”这使得客户机调度器能够纠正其世界观并做出公平的决策 [@problem_id:3689651]。

这种隐藏成本的主题也出现在其他现代硬件中。在一个由交互式图形和繁重的批量计算共享的**图形处理单元（GPU）**上，一个计算内核可能会被分配一个时间片。但如果它不断地被高优先级的图形任务到达而抢占，那么停止和启动的*开销*本身就可能耗尽其分配到的所有时间。它没有取得任何净进展，不是因为时间不足而被饿死，而是因为中断的成本 [@problem_id:3649156]。在其他情况下，网络应用程序中的一个错误可能导致**自我造成的饿死**（self-inflicted starvation），即一个线程错误地使用了像 `[epoll](@entry_id:749038)` 这样的机制，并进入了一个紧凑的“[忙等](@entry_id:747022)待”循环。它消耗了一个 CPU 核心 100% 的资源，却没有做任何有用的工作，饿死了所有其他进程——甚至是它自己的目标——使其无法取得进展 [@problem_id:3685802]。

### 综合：平衡系统的艺术

那么，我们能从中得到什么宏大的教训呢？那就是，设计一个健壮、公平且高效的[操作系统](@entry_id:752937)，并非要找到一个“万能”的调度器。它关乎一种整体哲学，一种认识到饿死是一个多方面的威胁，必须在每个层面上用多样化的策略工具包来对抗。

一个为交互式和批处理混合工作负载精心设计的[操作系统](@entry_id:752937)，是这种哲学的杰作。它不使用单一的简单调度器；它为 CPU 使用**多级反馈队列**（Multilevel Feedback Queue），这自然地将短小的、I/O 密集的交互式任务与长时的、CPU 密集的批处理作业分离开。它为新任务赋予高优先级以确保响应性，但会降低运行时间过长的任务的优先级。对于 I/O，它不使用简单的队列；它使用一个复杂的**截止时间或公平[队列调度](@entry_id:276911)器**（Deadline or Fair-Queuing scheduler），该调度器可以优先处理紧急的交互式读取，而不是大型的批处理写入，同时确保批处理写入不会饿死。它将配额、优先级、行为分析和智能 I/O 管理融合成一个单一、内聚的系统，其中每个组件都弥补了其他组件的弱点 [@problem_id:3664555]。

从等待网约车的简单挫败感，到[虚拟化](@entry_id:756508)中令人费解的悖论，饿死的问题是相同的。它是调解贪婪与耐心、紧急与重要之间矛盾的挑战。[操作系统](@entry_id:752937)的美妙之处在于它解决这个永恒问题时所展现的优雅与独创性，创造了一个尽管困难重重却异常公平的共享资源世界。