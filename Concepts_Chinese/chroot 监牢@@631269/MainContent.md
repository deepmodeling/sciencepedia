## 引言
`chroot` 系统调用是类 Unix [操作系统](@entry_id:752937)中的一个基础概念，它提供了一种简单而强大的方法来改变进程对文件系统的看法。它提出了一个引人入胜的问题：如果一个程序的整个世界可以被限制在一个单一的目录中，会怎么样？尽管历史悠久，`chroot` 的精确机制、安全影响和局限性常常被误解，导致其未被充分利用或实现方式不安全。本文旨在通过对 `chroot` 监牢进行全面探讨，弥合这一知识鸿沟。

第一部分“原理与机制”深入探讨了 `chroot` 如何重新定义文件系统根目录、创建安全监牢的关键步骤，以及可能允许进程逃逸的经典漏洞。随后，“应用与跨学科联系”部分考察了其在现实世界中的用例，从引导整个[操作系统](@entry_id:752937)到在网络服务中实现权限分离，最终追溯其传统，直至今日驱动云计算的现代容器技术。

## 原理与机制

要真正理解 `chroot` 监牢，我们必须首先问一个看似幼稚简单的问题：当您计算机上的程序打开一个像 `/etc/passwd` 这样的路径时，它如何*知道*该去哪里查找？正斜杠 `/` 不仅仅是一个字符；它是一个概念，是整个文件系统的通用起点。它是通往您计算机这座庞大数据图书馆的“正门”。`chroot` 机制的核心是一个非常简单而强大的想法：它允许一个进程被告知，原来的正门不再是正门。取而代之的是，一个特定的目录——比如 `/srv/jail`——现在被视为唯一的 `/`。对于那个进程来说，世界变小了。这个图书馆现在只是一个单独的房间。

### 视角之变

想象一个进程是一位被限制在庞大图书馆中一个单间里的研究员。这个房间就是它的 **chroot 监牢**。当这个进程请求一个以 `/` 开头的文件时，[操作系统](@entry_id:752937)不会从图书馆真正的正门开始搜索，而是从那个特定房间的门口开始。尝试打开 `/etc/passwd` 变成了尝试打开一个名为 `passwd` 的文件，该文件位于一个名为 `etc` 的目录内，而这个 `etc` 目录本身必须位于指定的房间内。如果*房间内*不存在这样的文件或目录，操作就会失败，即使它存在于主图书馆中 [@problem_id:3689380]。这就是限制的基本原则：`chroot` 为进程重新定义了[文件系统](@entry_id:749324)树的根。

但是后退呢？特殊路径 `..` 是“转到父目录”的命令。如果我们的研究员在他们房间内的一个小壁龛里，使用 `..` 只是将他们带回到房间的主要区域。但如果他们正站在自己房间的门口——他们的新根目录——并再次尝试使用 `..` 会发生什么？在这里，[操作系统](@entry_id:752937)强制执行了监牢的幻象。`chroot` 机制包含一条关键规则：路径解析永远不能上升到进程指定的根目录“之上”。研究员在门口被拦下；他们无法退回到主图书馆中。在监牢根目录处的这种“钳制”行为是阻止进程使用相对路径轻易走出其限制范围的关键机制 [@problem_id:3689380]。

### 构建安全监牢的艺术

这听起来足够简单，但就像任何魔术一样，其成功取决于精心的设置。如果执行不当，幻象就可能被打破。一个常见且危险的错误在于对进程的**根目录**和其**当前工作目录**（`cwd`）这两个概念的误解。

`chroot` 系统调用只改变进程的根目录——即它对 `/` 位置的*概念*。它*不会*自动改变进程的当前位置。想象一下，告诉我们的研究员：“物理学室现在是你的世界了，”而他本人正站在历史区。如果你接着让他“看看你旁边的书”，他仍然会看到一本历史书。他的 `cwd` 仍然在监牢之外。处于这种状态的程序如果尝试打开一个相对路径（如 `a/../b`），它的搜索将从监牢外的旧 `cwd` 开始，完全绕过了我们希望创建的限制 [@problem_id:3642749]。

因此，正确的程序是一个严格的两步舞。首先，你调用 `chroot` 来定义监牢的墙壁。其次，你必须立即调用 `chdir("/")` 将进程*移入*这些墙壁之内。对 `/` 的 `chdir` 调用现在是相对于*新的*根目录来解释的，有效地将进程的 `cwd` 传送到了监牢内部。只有这样，对绝对路径和相对路径的限制才算真正建立起来 [@problem_id:3642749]。

一种更现代、更稳健的技术完全避免了改变进程的全局状态。`openat` 系列的[系统调用](@entry_id:755772)允许相对于一个特定目录执行操作，该目录由一个**文件描述符**指定——这是一个指向内核对象的直接、不可伪造的句柄。通过首先打开一个指向监牢目录的文件描述符，程序可以相对于该描述符执行所有后续操作，确保每次查找都锚定在监牢内部，而无需触及进程范围的 `cwd` 或 `root` 设置。这就像给了研究员一张只在物理学室内有效的特殊地图，无论他们认为自己身在何处 [@problem_id:3642749]。

### 墙壁上的裂缝：经典的逃逸方法

即使监牢设置正确，聪明的囚犯也能找到出路。`chroot` 机制并非完美的堡垒；它是一套规则，而理解如何利用这些规则中的漏洞是构建更好防御的第一步。

最著名的逃逸方法之一依赖于一个简单的事实：`chroot` 不是一个清空内存的设备。它不影响进程在被监禁*之前*打开的文件描述符。如果我们的研究员在被锁进房间之前，私藏了一把通往图书馆档案室的万能钥匙，那么锁上的门就无关紧要了。这种“泄露的文件描述符”是一种能力，是绕过常规基于路径的安全检查而直接访问资源的授权。一个持有指向监牢外目录的文件描述符的进程可以使用像 `fchdir` 这样的调用，简单地将其工作目录改回监牢之外，瞬间使监牢变得毫无意义 [@problem_id:3687954] [@problem_id:3619492]。一个真正安全的系统必须要么确保在监禁前没有持有此类句柄，要么，如现代安全思想所建议的，拥有一个当进程改变其安全上下文时，这类能力会被自动作废的系统 [@problem_id:3687954]。

另一个微妙但致命的途径涉及从监牢内部操纵文件系统。攻击者可能无法走出大门，但也许他们可以欺骗守卫。**[符号链接](@entry_id:755709)**本质上是[文件系统](@entry_id:749324)上的一个路标，将一个路径重定向到另一个路径。监牢内的攻击者可以创建一个名为 `home` 的[符号链接](@entry_id:755709)，指向监牢外*真实的* `/root` 目录。监牢内一个天真的程序如果试图访问 `home/some_file`，它的请求将被内核重定向。内核忠实地跟随路标，可能会将路径解析到监牢外的位置。像 `O_NOFOLLOW` 标志这样的简单保护措施是不够的；该标志只阻止路径的*最后*一个组件是[符号链接](@entry_id:755709)，对于阻止内核跟随出现在路径中间的[符号链接](@entry_id:755709)毫无作用。对此唯一真正万无一失的防御措施是，费尽心思地逐个组件解析用户提供的路径，并在每一步都检查该组件是真实目录而不是[符号链接](@entry_id:755709) [@problem_id:3641743]。

### `chroot`：一个工具，而非一座堡垒

鉴于这些局限性，人们可能会想 `chroot` 到底有什么用。其真正的力量不在于成为一个坚不可摧的监狱，而在于它是一个用于**权限分离**的绝佳工具。考虑一个复杂的 Web 服务器或邮件服务器，它必须监听一个特权网络端口（低于 1024 的端口）。常见且安全的设计模式是，让一个小的、可信的主进程以完全的 root 权限启动。这个主进程执行少数必要的特权操作：它绑定到端口并准备环境。然后，它派生一个工作进程，剥夺其所有不必要的特权，并将其锁定在一个最小化的 `chroot` 监牢中，该监牢只包含其运作所必需的文件。然后，主进程将已经打开的网络套接字传递给被监禁的工作进程。

处理所有复杂且不受信任的用户输入的工作进程，现在在一个权限大大降低的状态下运行。如果攻击者在工作进程中发现漏洞，他们会发现自己身处一个微小、空荡的房间里。他们没有特殊权力，无法访问敏感的系统文件，也没有工具来造成进一步的伤害。损害得到了控制。在这种架构中，工作进程完成其工作不需要任何特殊的 Linux 能力；所有特权设置都由主进程预先完成 [@problem_id:3685810]。

然而，`chroot` 提供的隔离从根本上说是一维的：它只隔离文件系统视图。在 `chroot` 监牢内拥有 root 权限的进程，在内核看来，对于几乎所有其他事情仍然是超级用户。它共享相同的进程标识符（[PID](@entry_id:174286)）空间，这意味着它可以看见系统上的所有其他进程并向它们发送信号。它共享相同的网络堆栈，允许它嗅探主机流量或绑定到任何可用的主机 IP 地址。它共享相同的挂载表，这意味着它可以发出影响整个主机的 `mount` 命令，可能会挂载主机的硬盘并赋予自己完全的访问权限 [@problem_id:3665394]。

这一认识标志着 `chroot` 世界的极限，也是[虚拟化](@entry_id:756508)下一章的开端：**容器**。要创建真正的、多方面的隔离，需要的不仅仅是一个 `chroot`。你需要为每个主要的内核资源提供独立的、虚拟化的命名空间：一个**[PID](@entry_id:174286) 命名空间**，使容器只能看到自己的进程；一个**[网络命名空间](@entry_id:752434)**，用于拥有自己 IP 地址的私有网络堆栈；以及一个**[挂载命名空间](@entry_id:752191)**，用于获得对挂载表的私有和独立视图。最重要的是，一个**[用户命名空间](@entry_id:756390)**允许容器内的 UID 0 映射到主机上的一个非特权 UID，从而切断了与超级用户权限的联系。这些由内核强制执行的分层命名空间，构成了像 [Docker](@entry_id:262723) 这样的现代容器技术的坚固单元，远远超越了最初 `chroot` 监牢那简单、优雅但最终多孔的墙壁 [@problem_id:3665394] [@problem_id:3619492] [@problem_id:3641657]。

