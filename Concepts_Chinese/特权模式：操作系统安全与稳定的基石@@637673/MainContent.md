## 引言
现代计算机能够同时运行多个应用程序而不会崩溃，我们常常认为这是理所当然的。然而，这种稳定性并非偶然；它是[操作系统](@entry_id:752937)核心处一个基础设计原则的结果。核心挑战在于，如何授予应用程序所需的资源，同时防止任何一个有缺陷或恶意的程序破坏整个系统的稳定。一台计算机如何能在服务众多主人的同时不陷入混乱？答案在于一种被称为特权模式的严格权力分离。本文将揭开这个关键概念的神秘面纱，它是所有现代计算安全与稳定的基础。

在第一章“原理与机制”中，我们将探讨这种分离的核心，将其比作一个为公民（用户程序）和统治者（[操作系统内核](@entry_id:752950)）划分了不同领域的王国。我们将剖析处理器硬件本身如何通过特权指令和[内存保护](@entry_id:751877)来强制执行这一边界。随后的章节“应用与跨学科联系”将揭示该模型的深远影响，展示它如何促成从安全文件访问、高效网络到驱动[云计算](@entry_id:747395)的[虚拟化](@entry_id:756508)技术等一切。读完本文，你将理解，这个简单的双模式思想，正是使你的数字世界成为可能的无声守护者。

## 原理与机制

### 两个王国：用户与监督者的故事

想象一个繁华且管理良好的城市。大多数居民都是市民，过着自己的日常生活。他们住在自己的房子里，在公共道路上开车，享受城市的公园。他们的生活富有成效且基本独立。现在，想象一群特殊的人：城市规划师、运营电网的工程师以及政府官员。他们拥有特殊的钥匙。他们可以改变交通信号灯的时间，接入中央供水总管，并重新规划整个区域。

这不是一个关于统治阶级及其臣民的故事，而是一个关于功能与安全的故事。你不会希望任何市民能够因意外或恶意企图而关闭电网或逆转高速公路上的交通流。这个系统之所以能运转，是因为一个“社会契约”：市民可以自由地生活，作为交换，他们信任城市官员来管理使一切成为可能的共享基础设施。

这正是现代计算机[操作系统](@entry_id:752937)所使用的模型。在你的计算机上运行的绝大多数代码——你的网页浏览器、音乐播放器、视频游戏——都存在于一个称为**[用户模式](@entry_id:756388)**的领域。这是市民的领域。[操作系统](@entry_id:752937)的核心，即**内核**，则在一个独立且更强大的领域中运行：**特权模式**，也称为**监督模式**或**[内核模式](@entry_id:755664)**。

内核是你计算机的市政府。它管理着基本资源：谁可以使用 CPU、使用多长时间，如何分配内存，如何将数据写入硬盘，以及如何通过网络发送数据包。这两种模式之间的分离并非关乎等级制度；它是实现稳定、安全和多任务计算环境的根本设计原则。没有它，一个有缺陷的程序就可能导致整个系统崩溃，或者一个恶意程序可以读取其他所有程序的私有数据。这种分离是构建所有现代计算的基石。

### 划定界限：特权的剖析

那么，内核究竟能做什么而用户程序不能做呢？这种区别并非随意的；它由处理器本身在芯片层面强制执行。处理器指令集中的某些指令被指定为**特权指令**，如果处理器处于[用户模式](@entry_id:756388)，硬件会直接拒绝执行它们。

让我们戴上计算机架构师的帽子，思考一下哪些操作是如此强大以至于必须受到限制。如果我们从头开始设计一个处理器，我们会把哪些指令锁在监督者的工具箱里？[@problem_id:3669136]

首先，任何能够改变游戏规则的指令都必须是特权的。想象一个指令，我们称之为 `SET_STATUS`，它可以将当前模式从 `user` 更改为 `supervisor`。如果用户程序可以执行这个指令，那就像一个市民自己印了一枚“我是市长”的徽章，并且这枚徽章立即被所有人承认。这是通往绝对权力的一条捷径。同一个指令可能还控制 CPU 是否响应中断。如果一个用户程序可以禁用中断，它就可以进入一个无限循环并永远独占 CPU，使所有其他程序乃至内核本身都无法运行。这将是一场灾难性的[拒绝服务](@entry_id:748298)攻击。因此，像 `SETPSW`（Set Program Status Word）这样的指令是特权指令的典型例子。[@problem_id:3669136]

其次，我们必须保护系统的应急响应计划。当发生不寻常的事情时——比如一个程序试图除以零，或者键盘上按下一个键——处理器会停止当前的工作，并跳转到内核中一个特定的处理程序例程。所有这些处理程序的地址都存储在内存中的一个特殊表中，通常称为**中断向量表**。如果一个用户程序可以使用像 `SET[VEC](@entry_id:192529)TOR` 这样的指令修改这个表，它就可以将“[系统调用](@entry_id:755772)”处理程序重定向到它自己的恶意代码。下一次*任何*程序向[操作系统](@entry_id:752937)发出合法请求时，它都会在不知不觉中以特权模式触发攻击者的代码，从而交出王国的钥匙。[@problem_id:3669136]

最后，特权不仅涉及安全性，还包括系统稳定性和公平性。考虑一个像 `TLBFLUSH` 这样的指令，它会清除一个硬件缓存中最近的内存地址翻译。虽然这不明显是一个安全风险，但如果一个用户程序在一个紧密循环中执行此操作，将迫使处理器不断在内存中进行昂贵的查找，从而使整个系统对其他所有进程都陷入停顿。为确保公平，这也必须是一个特权操作。[@problem_id:3669136]

原则很明确：任何能够影响整个系统状态，而不仅仅是当前程序状态的操作，都有可能成为特权操作。

### 守门人：受控地进入王国

如果用户程序不能执行特权指令，它们如何执行像打开文件或发送网络数据包这样明显需要内核干预的必要任务呢？用户程序不能简单地 `JUMP` 或 `CALL` 内核内存空间中的一个函数。这就像一个市民试图踢开市长办公室的门。

相反，硬件提供了一个正式、受控的正门：**系统调用**。[系统调用](@entry_id:755772)由一个特殊的、*非特权的*指令（如现代 x86-64 处理器上的 `SYSCALL` 或传统的 `INT 0x80`）发起。执行这个指令就像在市政厅按门铃。它不会让你直接进去，但它会通知工作人员你需要帮助。这种由硬件发起的事件称为**陷阱**（trap）。

当陷阱发生时，处理器硬件会自动且原子地执行一系列关键步骤：
1.  它保存用户程序当前的位置，以便在内核完成任务后知道返回到哪里。
2.  它将处理器的模式位从 `user` 切换到 `supervisor`。
3.  它跳转到内核代码中一个单一的、预先确定的入口点。用户程序对跳转到哪里没有发言权。[@problem_id:3673126]

这种转换的一个关键部分是**栈切换**（stack switch）。程序的栈是其临时的草稿纸。内核不能信任用户的栈；它可能对于内核的需求来说太小，甚至可能是为了导致崩溃而恶意构造的。因此，在进入内核时，硬件通常会切换到一个独立的、原始的**内核栈**（kernel stack），其位置存储在一个特权寄存器中。这确保了内核有一个安全的工作空间，无论用户程序处于何种状态。[@problem_id:3680491] 这个过程非常健壮，即使内核本身被中断（例如，当它正在处理系统调用时被一个计时器滴答中断），处理器也可以优雅地处理这个嵌套事件，通常就在同一个内核栈上。[@problem_id:3640005]

但如果用户程序不按门铃，而是试图通过直接执行特权指令来撬锁呢？硬件会当场抓住它。它会触发另一种陷阱——“非法指令”错误。内核对此错误的处理程序会收到违规通知，并且在大多数情况下，其响应迅速而简单：终止违规进程。该程序被移除，其资源被回收，就好像它从未存在过一样。这是系统规则的最终执行。[@problem_id:3673077] 这种保护的粒度非常细。当一个用户程序试图非法写入一个特权寄存器时，硬件会在任何状态被改变*之前*检查模式和指令的意图。被禁止的写入操作会被抑制，然后陷阱被触发。非法的操作甚至从未发生。[@problem_id:3669130]

### 墙中之墙：[内存保护](@entry_id:751877)

世界的隔离比仅仅指令更深。内核需要自己的私有内存来存储其秘密，而每个用户进程也需要自己的私有地址空间，以防止其他进程的窥探。这些就是王国中的墙中之墙。

这是**[内存管理单元](@entry_id:751868)（MMU）**的工作，它是一块硬件，充当每一次内存访问的警惕守门人。MMU 将程序使用的“虚拟地址”转换为 [RAM](@entry_id:173159) 芯片的实际“物理地址”。这种转换的映射存储在一组称为**页表**的数据结构中，这些[页表](@entry_id:753080)由内核控制。

至关重要的是，页表中的每个条目都带有权限标志。其中最基本的是**用户/监督者（U/S）位**。如果此位将一个内存页标记为“仅监督者”，那么[用户模式](@entry_id:756388)程序任何试图从此页读取、写入或执行的操作都将被 MMU 阻止，MMU 将触发一个到内核的陷阱，称为**页错误**（page fault）。[@problem_id:3669097] 这构成了第二道强大的防线。

但事情变得更加复杂。在监督模式下运行的内核，传统上可以访问*所有*内存，包括用户空间页面。它需要这种能力来为[系统调用](@entry_id:755772)复制数据到用户程序或从用户程序复制数据。然而，这为一类危险的错误打开了大门。如果用户程序向系统调用传递一个坏指针——一个并非指向用户数据，而是欺骗性地指向内核内部某个敏感位置的指针，会怎么样？如果一个有缺陷的内核盲目地信任这个指针并向其写入，它可能会损坏自己的数据。[@problem_id:3673118]

为了防范此类威胁，这些墙变得更加智能。现代 CPU 引入了诸如 **SMEP（Supervisor Mode Execution Prevention，监督模式执行保护）**和 **SMAP（Supervisor Mode Access Prevention，监督模式访问保护）**等功能。SMEP 阻止内核意外地从标记为用户的页面*执行*代码，从而挫败那些诱骗内核运行恶意用户提供的 shellcode 的攻击。[@problem_id:3658230] 同样，SMAP 阻止内核意外地*读取或写入*标记为用户的页面上的数据。现在，当内核需要合法访问用户内存时，必须明确地、临时地禁用这些保护。这就像强迫城市规划师使用一把特殊的、有记录的钥匙才能进入市民的家，而不是让他们不小心闯进去。

### 机器中的幽灵：当架构规则不再足够

有了特权指令、受控陷阱和硬件强制的[内存保护](@entry_id:751877)，两个王国之间的界限似乎是绝对的。规则被刻在了芯片里。这就是**架构状态**（architectural state）的世界——机器的正式、有保证的状态。

但当我们深入了解底层时会发生什么？为了达到惊人的速度，现代处理器是无情的推测者。它们会猜测程序将如何分支，并可能在确认猜测正确之前，沿着预测的路径执行数百条指令。如果猜测错误，处理器会熟练地清理其混乱，撤销所有推测性工作。从架构上讲，就好像什么都没发生过一样。

但如果这种“幽灵”执行留下了一丝微弱、无形的痕迹呢？不是在寄存器或内存的架构状态中，而是在处理器的内部**[微架构](@entry_id:751960)状态**（microarchitectural state）中，比如**[数据缓存](@entry_id:748188)**。

这就是堡垒墙上的裂缝。一个聪明的[用户模式](@entry_id:756388)攻击者可以通过在自己的代码中反复执行一个分支来“训练”处理器的分支预测硬件。然后，他们发起一个系统调用。当内核遇到一个类似的分支时，处理器使用被污染的预测，可能会**推测性地执行**一段从未打算执行的代码片段。这种瞬时执行是以监督者权限发生的。这个小工具可能会读取一个内核秘密值 `S`，然后用这个秘密来访问一个内存位置，比如 `array[S]`。这一切的结果都会被丢弃。但一个副作用仍然存在：`array[S]` 的内存已经被加载到共享的[数据缓存](@entry_id:748188)中。[@problem_id:3669076]

当控制权返回到[用户模式](@entry_id:756388)的攻击者时，他们可以计时访问 `array` 的每个元素。其中一次访问会快如闪电——一次缓存命中。这就揭示了秘密值 `S`。这就是臭名昭著的 **Spectre** 攻击背后的原理。它们表明，通过观察[推测执行](@entry_id:755202)留下的[微架构](@entry_id:751960)幽灵，可以颠覆清晰、优美的特权边界。

确保这个新的、微妙的前沿安全性的斗争仍在继续。像 `retpolines` 这样的缓解措施涉及到巧妙的软件技巧，以在关键边界“隔离”[推测执行](@entry_id:755202)，但这通常以牺牲性能为代价。[@problem_id:3669076] 这种持续的演进告诉我们，两种模式这个简单而优雅的思想是一个活生生的概念，一个必须不断适应实现它的机器日益增加的复杂性的概念。两个王国的故事远未结束。

