## 引言
在任何现代计算机中，中央处理器（CPU）都是一种关键但有限的资源。在任何特定时刻，决定众多竞争程序中哪一个可以使用 CPU，是[操作系统](@entry_id:752937)面临的最基本挑战之一。一个管理不善的 CPU 会导致系统即便拥有强大的硬件，也会感觉迟缓和低效。核心问题在于，如何创建一种既对系统高效又对众多用户公平的调度策略，这项任务涉及在通常相互冲突的目标之间取得平衡。

本文将深入探讨 CPU 调度策略的世界以应对这一挑战。我们将首先探索基础的“原则与机制”，剖析抢占、优先级和公平性等核心概念，并评估从简单的“先来先服务”到优雅的“步进调度”等各种算法。随后，“应用与跨学科联系”一章将展示这些理论原则如何产生深远的现实世界影响，塑造了从智能手机的响应速度到大型数据中心的效率等方方面面，并揭示了与网络工程等其他领域的深刻联系。

## 原则与机制

想象一下，你是一家超市里唯一一位速度极快的收银员的经理。顾客们带着不同数量的商品到来。有些人只拿了一盒牛奶；另一些人则推着装满一周杂货的购物车。你的工作是决定下一个为谁服务。这本质上就是中央处理器（CPU）调度器的日常生活。CPU 是收银员，而程序或**进程**，则是顾客。调度器是经理，不断做出决策以保持一切顺利运行。但“顺利”究竟意味着什么？经理又有什么工具来执行他们的决策呢？

### 调度器的困境：机制与策略

从核心上讲，[操作系统](@entry_id:752937)（OS）提供了管理 CPU 的**机制**，但实现**策略**的却是调度器。机制是“如何做”——即原始能力。策略是“做什么”和“何时做”——即利用这些能力做出选择的战略。

操作系统内核为我们提供了基本的工具：一个可以中断正在运行进程的计时器，保存一个进程状态并加载另一个进程状态的能力（即**上下文切换**），以及保护进程互不干扰彼此内存的方法。这些就是机制。这就像给了我们超市经理一个可以暂停交易的按钮，以及一种让顾客进出队列的方法。

现在，设想两种情景 [@problem_id:3664507]。在第一种情景中，你有一个专用设备，比如一个工业机器人的控制器。它运行一个主控制循环进程，以及一个仅在主进程空闲时才运行的次要日志记录进程。在这里，没有真正的竞争。“调度”策略微不足道：让主进程在它想运行时就运行。机制是存在的，但由于没有冲突需要解决，所以不需要复杂的决策策略。

但现在想象一下，一台繁忙的大学服务器，有几十个学生登录，每人都在运行多个程序。有些在编辑文本，要求快速响应；另一些则在运行需要数小时才能完成的复杂模拟。现在，经理的工作就困难了。如果他们只是让第一个进程一直运行到完成，其他所有人都要等待。如果他们切换得太频繁，就会把所有时间都浪费在管理队列上。在这里，一个明确、智能的策略是绝对必要的。仅有机制是不够的；我们需要一个策略来决定*谁*运行、运行*多长时间*以及*以什么顺序*运行，以便为每个人创造一种公平和响应迅速的感觉。这个策略就是 CPU 调度策略。

### 游戏规则：我们在优化什么？

在我们评判一个策略之前，必须先定义我们的目标。有几个通常相互冲突的指标可以用来衡量调度器的性能：

*   **[吞吐量](@entry_id:271802)（Throughput）：** 单位时间内完成的作业数量。高[吞吐量](@entry_id:271802)就像每小时让尽可能多的顾客通过收银线。这是衡量系统整体效率的指标。对于一批计算密集型作业，一个能最小化开销和时间浪费的调度器将最大化[吞吐量](@entry_id:271802) [@problem_id:3630449]。

*   **[周转时间](@entry_id:756237)（Turnaround Time）：** 一个进程从到达系统到完成所花费的总时间。对顾客而言，这是从进入队列到带着杂货离开商店的时间。

*   **等待时间（Waiting Time）：** 进程在就绪队列中等待的时间，即准备好运行但未在 CPU 上运行的时间。这是顾客纯粹排队等候的时间。最小化等待时间通常是一个主要目标。

*   **响应时间（Response Time）：** 从进程到达系统到它从 CPU 获得*第一次*响应的时间。对于一个点击图标的交互式用户来说，这是到应用程序窗口出现的时间。这是衡量感知[响应度](@entry_id:267762)的指标。用户可能不介意一个大任务需要很长时间才能完成（[周转时间](@entry_id:756237)），但如果系统感觉迟钝，甚至不能快速确认他们的命令（[响应时间](@entry_id:271485)），他们会变得非常沮丧。

正如我们将看到的，你不可能拥有一切。一个在某个指标上表现出色的策略，通常在另一个指标上表现不佳。调度的艺术在于平衡这些权衡，以满足系统的目标。

### 中断的力量：抢占的理由

让我们从最简单的策略开始：**先来先服务（First-Come, First-Served, FCFS）**。它正如其名。进程按其到达的顺序被服务。这在幼儿园里算是公平，但在计算领域，它可能是灾难性的。

想象一下我们的大学服务器。一个学生开始了一个长达 10 小时的模拟（一个“长作业”）。片刻之后，十个其他学生到达，每人都想运行一个只需一秒钟的简单命令（一个“短作业”）。在 FCFS 策略下，这十个学生将等待 10 个小时，直到长模拟完成。这就是可怕的**[护航效应](@entry_id:747869)**（convoy effect）：一个在队首缓慢移动的进程，阻碍了其后一整队更快的进程。这不仅导致了极差的平均等待时间 [@problem_id:3670304]，而且还可能严重影响整个系统的利用率。如果短作业是交互式的并且需要做一些磁盘 I/O，CPU 将在它们被阻塞时完全空闲，而这一切都是因为它们被困在那个独占 CPU 的长作业后面 [@problem_id:3670281]。

解决方法既简单又深刻：**抢占**（preemption）。调度器被赋予强制中断正在运行的进程并将 CPU 交给其他进程的权力。最基本的抢占式策略是**[轮询](@entry_id:754431)**（Round Robin, RR）。调度器设置一个很小的时间量（time quantum），比如 10 毫秒。每个进程可以运行一个时间量。如果它在时间量结束时仍在运行，它就会被抢占，并被放置到就绪队列的末尾，队列中的下一个进程获得它的机会。

[轮询调度](@entry_id:634193)凭借一己之力就打破了[护航效应](@entry_id:747869)。长模拟运行 10 毫秒，然后被送到队尾。短作业轮流获得机会，迅速完成并离开系统。短作业的[响应时间](@entry_id:271485)非常出色，[平均等待时间](@entry_id:275427)也急剧下降。代价是，由于[上下文切换](@entry_id:747797)的开销，长作业的[周转时间](@entry_id:756237)略有增加，但整体系统性能和用户体验得到了极大的改善。抢占是现代[操作系统](@entry_id:752937)中最基本的思想之一。

### 先知的博弈：用预见进行调度

如果我们能预测未来，完美的调度策略会是什么样子？为了最小化[平均等待时间](@entry_id:275427)，答案被证明是**[最短作业优先](@entry_id:754796)（Shortest Job First, SJF）**。如果每当 CPU 空闲时，你总是从就绪队列中选择最短的作业，那么所有作业的[平均等待时间](@entry_id:275427)将是最低的。直观上看，这是有道理的：快速完成短作业可以防止它们增加后面作业的等待时间。

但这里有一个巨大的问题：我们不是先知。[操作系统](@entry_id:752937)无法预先知道一个进程下一个 CPU 区间（CPU burst）会有多长。因此，调度器必须依赖于*估算*，通常是通过使用该进程过去行为的加权平均值。那么当估算错误时会发生什么呢？想象你有一个真正的短作业和一个真正的长作业。如果由于某些坏运气，你高估了短作业的长度而低估了长作业的长度，你的 SJF 调度器可能会被欺骗，先运行长作业 [@problem_id:3630413]。在那一刻，你的“最优”调度器就退化成了最坏情况下的 FCFS 护航场景。对完美的追求被一个不完美的世界所阻碍。

然而，我们可以将 SJF 的思想与抢占的力量结合起来。这就得到了**[最短剩余时间优先](@entry_id:754800)（Shortest Remaining Time First, SRTF）**。SRTF 是 SJF 的抢占式版本。在任何时刻，它都运行剩余工作量最少的作业。神奇之处在于新作业到达时。如果新到达的作业的总运行时间小于当前正在运行作业的*剩余*时间，SRTF 将抢占正在运行的作业，并立即切换到这个新的、更短的作业。

这种行为使 SRTF 在响应时间方面表现出色。[非抢占式](@entry_id:752683)的 SJF 会迫使一个新的、微小的作业等待当前运行的较长作业完成，而 SRTF 则会立即关注这个新作业 [@problem_id:3683122]。这正是交互式系统所需要的。SRTF 优于 SJF 的充分必要条件恰恰是这种情况的发生：在一个较长作业执行期间，一个较短的作业到达。

### 玩转优先级：公平、饥饿与等级

在现实世界中，并非所有进程都是平等的。一个管理鼠标光标的系统进程远比一个在后台下载文件的任务重要。这就引出了**[优先级调度](@entry_id:753749)**（priority scheduling），即为每个进程分配一个优先级，调度器总是运行就绪队列中优先级最高的进程。

这听起来很合理，但它有其阴暗面：**饥饿**（starvation）。如果持续有高优先级进程流，低优先级进程可能永远无法运行。它会被“饿死”，得不到 CPU 时间。这是一种由优先级引起的[护航效应](@entry_id:747869)，一个长期运行的高优先级任务可以使一大批短的、低优先级的任务无限期地等待 [@problem_id:3671548]。

我们如何解决饥饿问题？一种经典的技术是**老化**（aging）。当一个进程在就绪队列中等待时，它的优先级会缓慢地、确定性地增加。最终，即使是优先级最低的进程也会[老化](@entry_id:198459)到足以达到最高优先级水平，并保证被运行。这提供了一种极好的可预测性。另一种方法可能是在每个时间步中给予进程一个随机的机会被提升到高优先级。虽然这最终也会让进程运行，但所需的时间可能会有很大差异。一项形式化分析表明，确定性的[老化](@entry_id:198459)方法在其服务时间上的[方差](@entry_id:200758)要小得多，使其成为一个更可靠、更可预测的解决饥饿问题的方案 [@problem_id:3620605]。

更结构化的方法涉及创建队列的层次结构。一个**多级队列（Multilevel Queue, MLQ）**调度器可能有一个高优先级的“交互式”队列和一个低优先级的“批处理”队列。调度器给予交互式队列严格的优先权。这确保了交互式作业的出色[响应时间](@entry_id:271485)，但如果交互式队列总是很忙，它可能会完全饿死批处理队列。一种更平衡的方法，如**加权[轮询](@entry_id:754431)（Weighted Round Robin, WRR）**，可能会为每个队列分配固定比例的 CPU 时间片（例如，3个给交互式队列，1个给批处理队列）。这保证了批处理队列能够取得进展，改善其[吞吐量](@entry_id:271802)和响应时间，代价是交互式作业的延迟略有增加。这是一个经典的**延迟-吞吐量权衡**（latency-throughput trade-off）的实际体现 [@problem_id:3660948]。一个强大的扩展是**多级反馈队列（Multilevel Feedback Queue, MLFQ）**，其中进程可以根据其行为在队列之间移动，从而允许调度器动态地学习哪些进程是交互式的，哪些是 CPU 密集型的。

### 从彩票到时钟：追求确定性的公平

如果我们想给进程精确的 CPU *份额*该怎么办？一个极其简单的想法是**彩票调度**（lottery scheduling）。你给每个进程一定数量的“彩票”，数量与你希望它拥有的份额成正比。在每个时间量，调度器进行一次抽奖，持有中奖彩票的进程得以运行。它健壮且简单，但它是概率性的。一个拥有 10% 彩票的进程并不能保证在 100 个时间量中恰好获得 10 个；它可能只得到 8 个，或者 12 个，这仅仅是出于偶然。

这种随机性引出了一个优美的问题：我们能否实现同样的比例共享，但具有时钟般的确定性精度？答案是肯定的，解决方案被称为**步进调度**（stride scheduling） [@problem_id:3630099]。

每个进程拥有的不是彩票，而是一个**步进值**（stride）。一个进程的步进值与其拥有的彩票数量成反比；拥有许多彩票的进程步进值小，而彩票少的进程步进值大。具体来说，我们选择一个大数 $L$，对于拥有 $t_i$ 张彩票的进程 $i$，其步进值为 $S_i = L/t_i$。每个进程还维护一个**通行值**（pass），初始为零。

在每一步，调度器只需选择通行值*最小*的进程。然后它运行该进程，并通过将其步进值加到通行值上来更新它：$p_i \leftarrow p_i + S_i$。

想一想。一个拥有许多彩票的进程，其步进值很小。它的通行值会缓慢增加。一个彩票很少的进程，其步进值很大，所以它的通行值在运行后会大幅跃升。通过总是选择通行值最小的进程，调度器自然会偏爱那些通行值落后的进程，而这些进程恰好是步进值较小（彩票较多）的进程。所有进程的通行值都保持紧密聚集在一起。这个简单、确定性的机制确保了在任何时间间隔内，每个进程运行的次数几乎与其彩票分配成完美比例，误差小于一个时间量。它将一场机会游戏变成了一支可预测、优雅且公平的舞蹈。这种从一个简单的概率性想法到一个确定性且更精确的想法的转变，是计算机科学原理中固有的美和统一性的完美典范。

