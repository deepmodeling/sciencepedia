## 引言
我们如何能在一本像《白鲸记》（*Moby Dick*）这样的鸿篇巨著中，高效地找出多个词，比如“whale”、“sea”和“Ahab”？对每个词单独搜索的简单方法需要为每一个模式词重读整本书——这个过程既繁琐又耗费计算资源。本文将介绍一种远为优雅和强大的解决方案，来应对这个[多模式字符串匹配](@article_id:639659)的基本问题。我们将探讨 Aho-Corasick [算法](@article_id:331821)，这是一种精密的机器，能在单次遍历中找出所有模式的所有出现位置。我们的旅程将从第一章“**原理与机制**”开始，在这里，我们将把[算法](@article_id:331821)分解为其核心组件：trie（[字典树](@article_id:638244)）、“失败链接”这一绝妙概念以及输出函数。随后，“**应用与跨学科联系**”一章将揭示该方法的非凡通用性，展示其在网络安全、生物信息学乃至二维图像识别等不同领域的应用。

## 原理与机制

想象你有一本长篇著作，比如《白鲸记》，还有一本你感兴趣的词典，里面包含“whale”、“sea”、“Ahab”和“obsession”等词。你将如何找出这些词的每一次出现？最直接的方法相当繁琐。你会先拿起第一个词“whale”，从头到尾读完整本书，标记每个位置。然后，为“sea”再重复一遍。再为“Ahab”来一遍。如果你的词典很大，你可能需要把那本巨著重读数百次。自然法则和高效[算法](@article_id:331821)都厌恶这种冗余工作。一定有更好的方法。通往更好方法的探索之旅，揭示了一段美妙的[算法](@article_id:331821)思维。

### 所有词汇的地图：Trie（[字典树](@article_id:638244)）

我们朴素方法的低效核心在于，我们无法从一次扫描中学到任何有助于下一次扫描的东西。让我们试着更聪明一些。我们的词典中的词常常共享共同的开头。例如，在一个集合 `{"he", "she", "his", "hers"}` 中，“he”和“hers”都以“he”开头。“She”以“s”开头，它是“she”自身的前缀。

与其将它们视为独立的实体，不如将它们编织成一个单一的结构。我们可以构建一种路线图，一棵[有根树](@article_id:330563)，其中从根节点出发的每条路径都拼写出我们词典中一个或多个词的前缀。这种结构被称为 **trie**，或称[前缀树](@article_id:638244)。

想象一下，从一个代表空字符串的根节点开始。从这个根出发，我们为每个词的独特首字母画一条边。从“h”边末尾的节点，我们再画出通往“e”和“i”的边。路径“h-e”通向一个节点。由于“he”在我们的词典里，我们会用一个特殊的星号标记这个节点，表示“一个词在这里结束！”。从这个“he”节点，我们可以继续走，经过一个“r”和一个“s”找到“hers”，我们也对其进行标记。这张单一而优雅的地图现在包含了我们所有的模式。构建它很简单：对于每个模式，我们只需从根节点追踪其路径，根据需要创建新的道路（节点和边）。这个构建步骤所需的时间与我们所有模式的总长度成正比，我们称之为 $L$。这是一个非常合理的成本。[@problem_id:3205763]

现在，当我们读取文本，比如“ahishers”时，我们可以尝试在这张地图上导航。我们读到“a”……从根节点没有这条路。好吧，我们迷路了。让我们从下一个字符“h”开始尝试。啊，有一条路！我们移动到“h”节点。下一个文本字符是“i”，我们沿着“i”的路径走。下一个是“s”，我们沿着“s”的路径走。我们刚刚追踪了“his”，而我们所在的节点被标记了星号。我们找到了一个匹配！我们可以继续这个过程，一边读取文本，一边在我们的 trie 上行走。

### 优雅失败的艺术：失败链接

这个 trie 是个好主意，但它有一个根本性的缺陷。当我们在一条路径上，而文本中的下一个字符不在我们的地图上时，会发生什么？假设我们的词典是 `{"abcd", "bce"}`，文本是“abce...”。我们追踪“a-b-c”。我们位于代表“abc”的节点。文本中的下一个字符是“e”。但在我们的 trie 中，代表“abc”的节点只有一个通往“d”的子节点。我们被卡住了。

我们该怎么办？我们应该回到文本中的“b”然后开始新的搜索来查找“bce”吗？那将是重复读取，正是我们一开始就想避免的！Aho-Corasick [算法](@article_id:331821)的核心、绝妙的洞见就在于此。

当我们的“abc”匹配失败时，我们刚刚处理了字符串“abc”。我们不必丢弃这些信息。是否存在“abc”的某个*真后缀*，同时也是我们词典中某个词的*前缀*？是的！后缀“bc”是模式“bce”的前缀。所以，与其放弃并后退，我们可以立即从代表“abc”的节点“传送”到代表“bc”的节点。从那里，我们可以愉快地消耗文本中的“e”，并找到“bce”的匹配。

这条传送路径被称为**失败链接**。对于 trie 中的每个节点，我们预先计算一个失败链接，它指向代表当前字符串的最长真后缀且该后缀同时也是 trie 中某个前缀的节点。如果不存在这样的后缀，失败链接就指回根节点。[@problem_id:3205763]

这些链接是我们地图上的“巧妙弯路”。它们告诉我们：“你当前匹配长模式的尝试失败了，但你已经隐含地匹配了这个较短的前缀。从那里继续。”通过添加这些失败链接，我们简单的 trie 转变成了一个真正的**[有限自动机](@article_id:321001)**。对于我们所处的任何状态和从文本中读取的任何字符，*总是*有一个明确定义的下一个状态。我们要么沿着一个正常的 trie 边前进（一次“成功”），要么沿着一个失败链接再试一次（一次“失败”）。因为我们从不在文本中后退，我们可以在与文本长度 $n$ 成正比的时间内处理整个文本。包括构建自动机在内的总复杂度达到了卓越的 $\mathcal{O}(n + L)$。

### 机器中的回响：传播输出

还有一个更微妙的层次。假设我们的词典同时包含“she”和“he”。当我们在处理文本并成功匹配“she”时，根据定义，我们也在同一位置看到了以“he”结尾。自动机必须足够聪明以报告这两个匹配。

这是通过确保一个状态的输出在“失败链接下是闭合的”来处理的。当我们构建自动机时，如果状态 $u$ 的失败链接指向状态 $v$，那么任何在 $v$ 结束的模式也必须被视为 $u$ 的一个输出。这就像一个回声：一个较长单词的匹配会产生回响，宣告其所有恰好也在词典中的后缀的匹配。[@problem_id:3204919]

因此，当我们的自动机到达代表“she”的状态时，我们报告“she”的匹配。然后我们检查它的输出，这个输出已经被增强，包含了其失败链接状态（即代表“he”的状态）的输出。于是，我们也报告了“he”。这保证了我们能找到*所有*匹配，包括这些重叠的后缀匹配，而且是在那一次优雅的单遍扫描中完成。这是在给定查询字符串中找到所有词典单词 [@problem_id:3205064] 或计算每个模式的所有出现次数 [@problem_id:3204919] 背后的核心原则。

### Aho-Corasick 自动机：三部曲的交响

所以，我们明白了。Aho-Corasick 自动机不是一个单一的想法，而是三个部分协同工作的优美交响乐：

1.  **Trie（Goto 函数）：** 乐观的路线图，描绘了逐字符成功匹配的路径。
2.  **失败链接：** 当乐观路径失败时，巧妙而高效的恢复机制，使我们永远不必重读文本。
3.  **输出函数：** 每个状态上完整的路标集合，通过失败链接的回响得到丰富，确保不会错过任何匹配。

这台机器接收一组模式，将它们编译成这张复杂的地图，然后精确地读取一次文本，捕捉到每个模式的每一次出现。

### 发现的平台：自动机的多功能性

这个自动机真正的美妙之处在于，它不仅仅是一个用于查找字符串的单一技巧。它是一个平台。一旦你拥有了这台可以在文本中追踪模式的机器，你就可以调整其输出来回答更有趣的问题。

-   **哪个是最佳匹配？** 假设在文本的某个点，“he”和“she”都是匹配项。如果你只关心*最长*的那个呢？你可以为自动机中的每个状态预先计算出，如果停在该状态，考虑到其直接输出和通过失败链接继承的所有输出，“最佳”匹配会是什么。然后，在扫描过程中，你只需在每一步进行一次查找。这使你能在每个字符的常数时间内得到答案，这是预计算的奇迹。[@problem_id:3204893]

-   **我们能实现查找并替换吗？** 自动机可以成为强大的查找替换工具的引擎。当它找到匹配时，它不只是报告它们，而是可以输出替换字符串。通过一些处理重叠匹配的严谨逻辑，你可以构建一个功能完备的**自动转换机（transducer）**——一种读取输入字符串并写入转换后输出字符串的机器。[@problem_id:3204933]

-   **连续的模式呢？** 一个巧妙的转折让我们能够找到一个模式 $p_i$ 紧跟着另一个模式 $p_j$ 的位置。我们可以使用一个自动机正向扫描文本，找到所有模式*结束*的位置。然后，我们可以在*反转*的模式上构建第二个自动机，并扫描*反转*的文本。这第二次扫描告诉我们所有原始模式*开始*的位置。通过将第一次扫描得到的“在 $k$ 处结束”的信息与第二次扫描得到的“在 $k+1$ 处开始”的信息结合起来，我们就能找到所有连续的配对。这是[算法](@article_id:331821)对称性的一个可爱展示。[@problem_id:3204940]

### 超越精确：匹配的前沿

Aho-Corasick 框架是如此基础，以至于可以扩展来解决那些乍一看远超其能力范围的问题。

-   **不区分大小写的匹配：** 如果“Whale”和“whale”应被视为相同，该怎么办？我们根本不需要改变机器的逻辑。我们只需要改变我们对“字符”的定义。我们可以在一个规范化的字母表上构建自动机（例如，所有小写字母）。然后，当我们扫描文本时，我们在将其送入机器之前动态地进行规范化。原理保持不变，展示了抽象的力量。[@problem_id:3205013]

-   **通配符：** 如果我们的模式包含通配符，比如 `h*s`，它应该匹配“his”、“has”、“hms”等，该怎么办？单个字符 `*` 现在可以匹配字母表中的任何字符。这引入了**非确定性**：从“h”状态，我们现在可以在*任何*字符[上转换](@article_id:316933)到下一个状态。我们干净、确定性的自动机无法直接处理这个问题。但我们可以求助于[自动机理论](@article_id:339731)中一个更深刻的概念。我们可以认为机器同时处于一个*状态集合*中。我们新的、更强大自动机中的一个状态，是旧自动机中状态的集合！这种技术，称为**[子集构造法](@article_id:335343)**，允许我们确定性地模拟非确定性机器，并行地追踪所有可能的匹配路径。这是抽象上的一个美丽飞跃，将我们的特定问题与[正则语言](@article_id:331534)的一般理论联系起来。[@problem_id:3204954]

-   **近似匹配：** 如果我们想找到最多有 $k$ 个拼写错误的模式（例如，在“patturn”中找到“pattern”）怎么办？这是近似匹配的领域。我们不能再依赖于“trie 中的当前节点”这个简单的状态。我们必须扩展我们对状态的定义，以包含一个错误预算。一个活跃的搜索状态变成了一个元组：`(当前节点, 已用错误数)`。当我们处理文本时，与 trie 边匹配的字符会无成本地扩展路径。不匹配的字符也可以扩展路径，但它会消耗我们错误预算的一个单位。我们同时探索 trie 中所有可能的路径，但会剪掉任何错误数超过 $k$ 的路径。这种方法是 trie 结构与[动态规划原理](@article_id:638895)深刻而优雅的融合。[@problem_id:3204900]

从一个避免重读一本书的简单愿望出发，我们穿越了 trie、[有限自动机](@article_id:321001)和失败链接，最终到达了[模式匹配](@article_id:298439)的前沿。Aho-Corasick 自动机不仅仅是一个[算法](@article_id:331821)；它是一种思维方式，证明了简单、优美的思想如何能够被组合和扩展，以强大而优雅的方式解决各种各样的问题。

