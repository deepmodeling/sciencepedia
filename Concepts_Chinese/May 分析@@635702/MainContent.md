## 引言
我们如何在不运行计算机程序的情况下预测它会做什么？这是[静态程序分析](@entry_id:755375)的核心挑战。由于程序可能因用户输入而产生数万亿条执行路径，验证其正确性或安全性似乎是一项不可能完成的任务。为了使这项任务变得可行，分析人员采用了两种基本理念之一：要么寻求在所有路径上*必然*为真的绝对确定性，要么编目在至少一条路径上*可能*发生的全部情况。本文重点讨论后一种方法，即 **may 分析**。它旨在解决我们如何在充满不确定性的情况下可靠地推理程序行为这一知识鸿沟。

本文对这一强大概念进行了全面概述。首先，在“原理与机制”部分，我们将剖析 may 分析的核心思想，包括使其成为可靠的错误查找工具的关键策略——过近似，以及导致分析不精确性的权衡。随后，“应用与跨学科联系”部分将展示这些原理在现实世界中的应用，从实现[编译器优化](@entry_id:747548)、确保系统稳定性到揭示关键安全漏洞，从而揭示推理可能性的深远影响。

## 原理与机制

### 算命先生的困境：确定性与可能性

试想，一个计算机程序不是一段静态的文本，而是一段有众多分支路径的动态旅程。一个简单的 `if` 语句就是路上的一个岔口；一个循环就是一条可以多次行进的路径。鉴于程序可能根据其输入而产生数万亿条不同的路径，我们如何在不永远运行它的情况下，对它的行为做出任何明确的论断呢？这就是**[静态程序分析](@entry_id:755375)**的根本挑战：在不实际执行程序的情况下预测其行为。

面对这无限的可能性图景，我们可以像古代的神谕一样，采取两种截然不同的理念。我们可以寻求**确定性**，也可以编目**可能性**。

第一种方法，即确定性之路，提问：“无论程序走哪条路径，什么事情*必然*为真？” 这就是 **must 分析**的世界。它寻找普遍的、不可避免的真理。例如，如果我们有一个变量 `x` 初始化为 5，并且没有任何代码可以改变它，那么 must 分析可以自信地断言：“$x$ 总是 5。”然而，如果一个 `if` 语句可能将 `x` 变为 10，分析就失去了确定性。它再也无法声称 $x$ *必然*是 5。

第二种方法，即可能性之路，提出了一个不同的问题：“在程序的某一次旅程中，什么事情*可能*发生？” 这就是 **may 分析**的精髓。它不需要保证；它感兴趣的是*可能*会发生什么。在同一个例子中，如果 `x` 的初值为 5，一个 `if` 代码块可以将其改为 10，may 分析会得出结论：“在程序结束时，`x` 可能是 5，也可能是 10。”它拥抱不确定性，并报告所有[潜在结果](@entry_id:753644)的完整范围。

这种区分不仅仅是学术上的；它是使计算机可靠和高效的基石。

### 安全过近似的艺术

让我们考虑[静态分析](@entry_id:755368)器最重要的工作之一：查找错误。一个非常常见且危险的错误是解引用**空指针**，这通常会导致程序崩溃。我们向分析器提出的问题是：“这个指针在使用时*可能*为空吗？” 这是一个经典的“may”问题。

那么，这样一个分析器要做到**可靠**或正确，意味着什么呢？对于错误查找而言，可靠性最重要的一点是：**它绝不能漏掉任何一个真正的错误**。我们可以容忍分析器偶尔“狼来了”（**[假阳性](@entry_id:197064)**），但绝不能容忍它在潜藏错误时给我们一份“健康证明”（**假阴性**）。

为了实现这一保证，may 分析采用了一种强大的策略：**过近似**。它系统性地撒下一张比程序实际行为所需范围更广的网。基本规则是，程序所有真实的、具体的行为集合，必须是分析所报告的可能性集合的一个[子集](@entry_id:261956)。如果分析称一个变量 `v` 的值可以在集合 `S` 中，那么 `v` 在执行期间所取的任何实际值都*必须*在 `S` 中。

[@problem_id:3619092] 中的一个简单程序结构很好地说明了这一原则。想象一个指针 `p`，在一个 `if` 语句的一个分支中被设置为 `null`，而在另一个分支中被设置为一个有效的内存地址。当这两条路径合并时，我们对 `p` 有什么了解呢？

-   一个旨在查找潜在空指针解引用的 **may 分析**，必须考虑两种可能性。在合并点，它的结论是 `p` *可能*为 `null`。它对 `p` 的抽象状态变为 `⊤`（读作 "top"），一个特殊值，意为“它可能是任何东西”，或者更精确地说，“它可能是空，也可能不是空。”如果程序随后尝试使用 `p`，may 分析将发出警告。它成功地识别了一个潜在的崩溃。

-   相比之下，一个 **must 分析**寻求确定性。在合并点，它看到在一条路径上 `p` 是 `null`，而在另一条路径上是 `non-null`。由于没有一个属性在*所有*路径上都成立，它得出结论，它不知道任何确定的事情。它的状态变为 `⊥`（读作 "bottom"），意为“无信息”或“不可达”。它将无法发出警告，从而漏掉一个明确的错误。

这展示了关键的权衡：may 分析以有时会标记安全代码为代价，找到了所有可能的错误；而 must 分析对于错误查找是不可靠的，因为其对确定性的追求使其对只在某些路径上出现的问题视而不见 [@problem_id:3619092]。这种收集所有可能性的原则延伸到许多领域，比如安全。在**污点分析**中，为了确定一个敏感变量是否*可能*受到不受信任的用户输入的影响，分析器必须在每个合并点使用并集（`∪`），收集在*任何*传入路径上被污染的所有变量 [@problem_id:3642674]。

### 保守的优化器：当“可能”意味着“不要碰”

当我们从查找错误转向优化代码时，角色发生了戏剧性的逆转。编译器**优化器**的目标是重写程序以使其运行得更快，但其首要指令等同于希波克拉底誓言：“首先，不造成伤害。” 一项优化只有在保证不改变程序行为的情况下才是安全的。

考虑一种名为**[无效存储消除](@entry_id:748247)（DSE）**的优化。如果我们有一条指令 `x := 42`，但 `x` 的值之后再也没有被读取过，那么这条指令就是“死的”，可以被安全地移除。为了做出这个决定，优化器必须问：“这条指令中 `x` 的值*可能*在未来的任何路径上被使用吗？” 这是一种**[活性分析](@entry_id:751368)**。

在这里，“保守”意味着只要存在任何疑问，就保留该指令。优化器必须假设最坏情况以保持正确性。May 分析正是所需。如果它报告 `x` *可能*是活跃的（未来会被使用），优化器会保守地保留该指令 [@problem_id:3635637]。

这在可以[乱序执行](@entry_id:753020)指令的现代处理器中具有深远的经济影响。考虑调度两个内存操作：一个存储 `*p = a` 和一个加载 `b = *q` [@problem_id:3647173]。处理器能否为了提高性能而在存储之前执行加载？答案取决于 `p` 和 `q` 是否可能指向同一个内存位置。处理器必须询问一个**[别名](@entry_id:146322)分析**单元：“`p` 和 `q` *可能*是别名吗？”如果答案是“是”，处理器必须保守地按原始顺序执行它们。一个能够证明它们*不是*[别名](@entry_id:146322)的精确分析可以释放更大的并行性。在一个简单场景中，一个不精确的 may-别名分析结果将有效的高性能调度数量从 40 个减少到 15 个，这是巨大的机会损失。这种压力推动了对日益精确的[静态分析](@entry_id:755368)的需求。

### 不精确性从何而来？

我们已经确定 may 分析是查找错误和实现安全优化的可靠策略，但其过近似可能导致假阳性。这种不精确性——分析报告与具体事实之间的差距——从何而来？它源于几种抽象来源。

#### 来源 1：抽象的形式

不精确性的第一个来源是我们所使用的抽象值本身的性质。想象一个程序，其中变量 `x` 在一条路径上被设为 `0`，在另一条路径上被设为 `2`。在路径合并后，`x` 的具体、可能值的集合恰好是 $\{0, 2\}$。

现在，假设我们使用一个流行的、简单的抽象域，称为**区间**。该域只能表示一个连续的数字范围，如 `[a, b]`。为了过近似集合 $\{0, 2\}$，包含这两个值的最小区间是 `[0, 2]`。分析现在认为 `x` 可能是 0、1 或 2。值 `1` 是一个“幽灵”——一个由区间域表达能力不足以表示一个带有空洞的集合而引入的假阳性 [@problem_id:3635651]。这是一个经典的权衡：区间计算成本低，但牺牲了精度。

#### 来源 2：遗忘关系

另一个关键的不精确性来源是当分析独立处理每个变量，忘记了它们之间的关系。考虑这段代码：从 `x` 和 `y` 相等开始，我们执行 `x := x + 1`，然后执行 `y := y + 1`。在最后，`x` 是否仍然等于 `y`？当然。[不变量](@entry_id:148850) $x - y = 0$ 得到了维持。

一个简单的**非关系型**分析，如区间域，会分别跟踪 `x` 和 `y`。如果它开始只知道 $x=y$，它可能会将其抽象为 $x \in [-\infty, \infty]$ 和 $y \in [-\infty, \infty]$。它们之间的关键联系立即丢失。在增量操作之后，它仍然不知道它们的关系，无法证明断言 `assert(x == y)` 是安全的 [@problem_id:3619168]。

一个更强大、也更昂贵的**关系域**，如**[凸多面体](@entry_id:170947)**或**八角形**，可以处理这个问题。它可以将初始[状态表示](@entry_id:141201)为[线性约束](@entry_id:636966) $x - y = 0$。然后它可以证明这个[不变量](@entry_id:148850)在第一次增量后变成了 $x - y = 1$，在第二次增量后又变回了 $x - y = 0$，从而证明断言是安全的 [@problem_id:3619168]。这揭示了[程序分析](@entry_id:263641)中的一个基本谱系：分析的计算**成本**与其结果的**精度**之间的深刻权衡。

#### 来源 3：合并的行为

也许最微妙的不精确性来源在于分析器所使用的算法本身。理论上“完美”的分析会分别追踪每条可能的执行路径——这种技术被称为**所有路径交汇（MOP）**解。但由于路径数量可能是无限的，这在计算上是不可能的。

实际的分析器使用一种[迭代算法](@entry_id:160288)来近似此解，称为**最大[不动点](@entry_id:156394)（MFP）**解。其关键的捷径是，每当路径合并时，它会*先*合并它们的抽象状态，然后再将下一个转换应用于合并后的状态。这个捷径是经典 may 分析不精确性的来源。

想象一个在节点 `j` 处的转换函数 `f`，只有当它*同时*看到事实 `c` 和 `d` 时才会产生一个特殊事实 `a`：$f^{\star}(S) = \{a\}$ if $\{c, d\} \subseteq S$, and $\varnothing$ otherwise。现在，假设两条路径在 `j` 处合并：一条路径带来了事实 `c`，另一条带来了 `d` [@problem_id:3642725]。

-   实际的 MFP 算法先进行合并：它计算出 `j` 的输入为 $\{c\} \cup \{d\} = \{c,d\}$。然后它应用该函数：$f^{\star}(\{c,d\}) = \{a\}$。结果是 `a`。
-   理想的 MOP 语义分别考虑每条路径：在第一条路径上，结果是 $f^{\star}(\{c\}) = \varnothing$。在第二条路径上，结果是 $f^{\star}(\{d\}) = \varnothing$。这些结果的并集是 $\varnothing \cup \varnothing = \varnothing$。

实际的算法产生了一个更大、更不精确的结果。这是因为该函数是**非分配性的**：将函数应用于输入的并集，与取函数应用于每个输入的结果的并集是不同的。这个优美的数学性质支撑了为什么我们在[静态分析](@entry_id:755368)中所做的近似既是必要的，又是根本上不完美的，但却是以一种定义明确且安全的方式进行的。May 分析以其多种形式，证明了抽象的力量，使我们能够对计算的无限复杂性进行可靠的推理。

