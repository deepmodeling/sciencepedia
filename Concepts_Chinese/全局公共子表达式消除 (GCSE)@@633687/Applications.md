## 应用与跨学科联系

我们花了一些时间来理解[全局公共子表达式消除](@entry_id:749919) (GCSE) 的机制，这是编译器用来避免重复做同样工作的一个聪明技巧。但要真正欣赏它的天才之处，我们必须看到它的实际应用。就像一位完善了某项特定技术的大师级工匠一样，编译器在各种各样的情况下应用这一原则，从平凡到极其复杂。它的应用揭示了抽象算法与现代硬件、编程语言甚至计算本质本身的具体现实之间深刻的相互作用。

让我们踏上这段应用的旅程，不把它看作一串枯燥的例子，而是一系列发现，展示这个简单的想法——不要重复自己——如何展开成一幅丰富的计算艺术画卷。

### 性能的核心：循环与协同的艺术

GCSE 最自然的用武之地是在循环内部。循环是我们程序的工厂，指令在这里执行数百万或数十亿次。这里的任何低效都会被极大地放大。想象一个循环包含一个条件检查，在条件的两边都执行了相同的计算。例如，你可能有一段代码看起来像这样：“如果满足某个条件，就用 $x+y$ 做某事；否则，用 $x+y$ 做别的事。” 一种天真的方法会在无论走哪条路径时都计算 $x+y$。但编译器，以其全知的视角，注意到无论如何都需要这个和。优雅的解决方案是在循环迭代的顶部、条件检查之前计算一次该值，并将其存储在一个临时变量中。然后，两个分支都可以简单地使用这个预先计算好的结果 [@problem_id:3644004]。计算被“提升”到一个*支配*其两个使用点的地步，确保它在需要时总能准备好，但在每次循环中只计算一次。

这本身就很美妙，但真正的魔力始于各种优化开始相互协作。考虑一个循环，你在其中访问数组元素，如 `P[i]`、`Q[i]` 和 `S[i]`。为了找到 `P[i]` 的内存位置，计算机必须计算偏移量，这通常是 `i` 乘以一个元素的大小，比如说 $i \times 4$。如果你有许多这样的数组访问散布在循环体的不同部分，一个天真的程序可能会一遍又一遍地计算 $i \times 4$。

在这里，GCSE 作为优化团队的第一个成员介入。它扫描整个循环并说：“看，大家都在计算 $i \times 4$。让我们只在顶部做一次，然后共享结果。” 它创建了一个单一、清晰的计算，我们称之为 $t \leftarrow i \times 4$。现在，循环中只有一个乘法而不是多个。

但现在，第二个称为**强度削减 (strength reduction)** 的专业优化看到了发生的一切。它注意到这个临时变量 $t$ 以一种非常简单的方式与循环索引 $i$ 绑定在一起。当 $i$ 依次为 $0, 1, 2, 3, \dots$ 时，$t$ 的值需要是 $0, 4, 8, 12, \dots$。与其每次都用昂贵的乘法从 $i$ 重新计算 $t$，为什么不直接从它自己的前一个值来更新它呢？在每次迭代结束时，当我们执行 $i \leftarrow i + 1$ 时，我们可以简单地执行 $t \leftarrow t + 4$。乘法被一个便宜得多的加法所取代。这种协同效应是深刻的：GCSE 首先整理了混乱，创造了一个单一的冗余点，然后强度削减可以攻击这个点，从而完全从循环的[热路](@entry_id:150016)径中消除乘法 [@problem_id:3643971]。

### 推测的艺术：成本、收益与危险

你可能会倾向于认为，如果一个表达式是纯粹的（意味着它没有副作用），我们应该总是尽早计算它以最大化重用。这种被称为“提升”的策略虽然强大，但带有隐藏的成本和危险。这是一种推测，而推测可能会出错。

首先，是资源管理的实际成本。当你提早计算一个值时，你必须将它保存在一个寄存器中直到需要时为止。寄存器是处理器最宝贵和有限的资源。如果你通过提升囤积了太多的值，编译器可能会用完寄存器，不得不将其中一些“溢出”到[主存](@entry_id:751652)中，这会大大降低速度。消除一次计算的好处可能会被这些额外的内存访问成本完全抵消。这是一个微妙的平衡，一个聪明的编译器必须权衡利弊 [@problem_id:3643985]。

其次，推测可能明显是无利可图的。想象一种情况，一个极其昂贵的计算，比如一个大型[矩阵乘法](@entry_id:156035)，在条件分支的一条路径上需要，但在另一条路径上很少需要。这条“罕见”的路径可能有一个提前退出的机制，完全绕过了计算。如果我们把乘法提升到条件判断之前，我们现在就强迫它在原本设计用来避免它的路径上也执行。如果那条路径被频繁采用，我们就用一个总是很慢的程序替换了一个通常很快的程序。一个真正智能的编译器会使用概率和成本模型来决定这种推测是否值得。它必须是一个精于计算的赌徒，而不是一个盲目的乐观主义者 [@problem_id:3644018]。

最后，推测可能是极其危险的。如果我们想要提升的计算，比如解析一个配置字符串，可能会失败并抛出异常怎么办？考虑程序中的一条路径，在原始代码中，它从不执行解析操作。如果我们把解析操作提升到顶部，它现在就会在这条路径上执行。如果输入字符串格式不正确，程序将在一条以前完全安全的路径上因异常而崩溃。这违反了优化的基本契约：不造成伤害。优化器必须证明推测性计算不会引入新的错误，这是一个通常难以满足的条件 [@problem_id:3644034]。

### 并行世界：时空规则弯曲之处

GCSE 成长的那个简单的、顺序的世界正在迅速消失。我们现在生活在一个并行的宇宙中，拥有多核处理器、GPU 和复杂的内存系统。在这个宇宙中，GCSE 的基本假设可能会被打破。

考虑在不同处理器核心上运行的两个线程。一个共享的原子变量 `counter` 正被一个线程递增，而另一个线程读取它两次。表达式是 `read_counter() + 1`。在一个顺序世界里，两段看起来相同的代码执行这个操作会构成一个[公共子表达式](@entry_id:747510)。但在一个并发世界里，它们不是！在第一次读取和第二次读取之间，另一个线程可能已经插入并递增了计数器。这两次读取，虽然文本上相同，却可能返回不同的值。它们不是“公共的”，因为它们存在于不同的时间点，而在并发系统中，时间是一个棘手的、相对的东西。在这里应用 GCSE 将是一个灾难性的错误，因为它会强制两次读取具有相同的值，从而消除了原始程序的一个有效行为。让 GCSE 再次安全的唯一方法是通过同步来强制顺序，例如，通过证明两次读取之间的代码受到一个排斥其他线程的锁的保护 [@problem_id:3643958]。

当我们考虑现代 CPU 的[内存模型](@entry_id:751871)时，这个想法变得更加微妙。这些模型使用“[内存栅栏](@entry_id:751859)”来控制读写的顺序。栅栏就像一个单向门；操作不能跨越它重新排序。想象你有两条程序路径。在路径一上，你有 `fence; load(q)`。在路径二上，你有 `load(q); fence`。尽管 `load(q)` 指令看起来相同，但它相对于栅栏的位置使其在语义上有所不同。来自另一个线程的并发写入可能在第二条路径上的加载之后被排序，但在第一条路径上的加载之前。栅栏改变了加载与宇宙其余部分的关系。这两个加载不是一个[公共子表达式](@entry_id:747510)，编译器必须足够聪明才能看到这一点 [@problem_id:3643979]。

然而，在其他并行世界中，GCSE 又焕发了新的生机。在图形处理单元 (GPU) 上，一个“线程束”(warp) 的线程步调一致地执行。当它们遇到一个条件时，一些线程可能走一条路，另一些走另一条路——这被称为分歧 (divergence)。硬件通过串行执行两条路径来处理这个问题，每条路径只有相关的线程处于活动状态。如果同一个计算，比如 $\sin(\theta)$，出现在分歧的两条路径上*以及*它们重新[汇合](@entry_id:148680)之后，一个天真的执行将为该线程束执行三次计算。GPU 编译器可以应用 GCSE，将 $\sin(\theta)$ 的计算提升到分歧之前。现在，线程束中的所有线程一起计算一次。结果被保存下来，所有后续的使用都从这个临时值中得到满足。GCSE 优雅地处理了这些[并行架构](@entry_id:637629)特有的[控制流](@entry_id:273851)分歧 [@problem_id:3643973]。

### 语言、逻辑与纯粹性

GCSE 的影响超出了单纯的[性能调优](@entry_id:753343)；它触及了我们设计和推理编程语言的方式。解锁许多高级优化（包括 GCSE）的关键是**纯粹性 (purity)**。一个纯函数，就像一个数学函数一样，对于相同的输入总是给出相同的输出，并且没有可观察的副作用。

当编译器知道一个函数是纯粹的时，它可以更有效地对其进行推理。考虑一个[递归函数](@entry_id:634992)，它在递归步骤之前和之后都调用了一个纯函数 `f(n)`。因为 `f(n)` 是纯粹的且其参数 `n` 没有改变，编译器可以证明第二次调用是多余的，并可以安全地消除它，重用第一次调用的结果。这需要[过程间分析](@entry_id:750770)——窥视其他函数内部——但原理是相同的 [@problem_id:3643999]。

与此相反的是一个不纯的函数。想象一个 `parse(json_string)` 函数，它除了解析之外，还会为了统计目的递增一个全局计数器。如果这个函数被调用两次，计数器就会递增两次。如果编译器应用 GCSE 并消除了第二次调用，它也会消除第二次递增，从而改变计数器的最[终值](@entry_id:141018)。如果该计数器的值在程序的其他地方是可观察的，那么这个优化就错误地改变了程序的行为。副作用使得两次调用成为根本不同的事件，即使它们返回相同的解析结果。从整体上看，它们不是一个“[公共子表达式](@entry_id:747510)”。这就是为什么鼓励或强制纯粹性的语言特性，比如[函数式编程](@entry_id:636331)中的那些，不仅仅是学术上的好奇心；它们是强大的工具，能让编译器生成效率高得多的代码 [@problem_id:3644034]。

最终，[全局公共子表达式消除](@entry_id:749919)远不止是一个简单的编译器遍。它是一个镜头，通过它我们可以看到[算法设计](@entry_id:634229)、硬件架构和语言哲学之间深刻而美丽的联系。它告诉我们，不重复我们的工作这个简单而优雅的想法是一个普遍的原则，但应用它需要对完成这项工作的上下文——时间、顺序、[状态和](@entry_id:193625)意义——有深刻的理解。