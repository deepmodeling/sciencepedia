## 引言
在计算机理解人类指令和结构化数据的核心，存在着一个极其优雅的过程：解析（parsing）。它是一门艺术，也是一门科学，旨在获取一串符号序列——无论是代码、语言，还是基因数据——并确定其潜在的语法结构。如果没有这种解读结构的能力，编程语言将无法实现，数据交换将会失败，人类意图与机器执行之间的桥梁也将坍塌。本文深入探讨为解决解析问题而发展的核心理念和精妙机制。它解决了机器如何系统地将一本规则手册（即文法）应用于文本字符串以揭示其含义这一根本性挑战。您将游历解析领域的两大思想流派，探索状态机和动态规划的优雅机制，并发现其在能力、速度和复杂性之间的权衡。接下来的章节“原理与机制”和“应用与跨学科联系”，不仅将为您提供理论上的理解，还将揭示这些抽象概念如何驱动着从您的代码编辑器到科学研究前沿的一切事物。

## 原理与机制

想象一下，你不是作为人类，而是作为一台机器，试图理解一个句子。你有一本规则手册——一部**文法**——它告诉你诸如“一个句子可以是一个名词短语后跟一个动词短语”，以及“一个名词短语可以是一个冠词后跟一个名词”之类的事情。你如何检查像“the cat sat”这样的词串是否遵循你的规则？对此有两种伟大的哲学，两种处理问题的基本方式，在它们的对比中，我们发现了解析的全部戏剧性。

### 两大哲学：自顶向下与自底向上

第一种方法是**自顶向下解析**。这是一个理论家的方法。你从一个宏大的假设开始：“我相信这整个词串是一个句子。”然后，你向下推导，试图证明它。如果一个句子是一个名词短语后跟一个动词短语，那么你接着就在字符串的开头寻找一个名词短语，在其余部分寻找一个动词短语。你递归地将你的目标分解成越来越小的子目标，直到最终触及单词本身。这是一种优美的、目标导向的策略。

然而，它有一个奇特且有时是致命的缺陷。考虑一种非常自然的规则，比如用于表达式列表的规则：`expression -> expression + term`。这被称为**[左递归](@entry_id:751232)**规则，因为我们试图定义的东西（`expression`）出现在了右侧的第一个符号位置。一个幼稚的自顶向下解析器，在被要求寻找一个 `expression` 时，会首先尝试这条规则。为此，它必须*首先*找到一个 `expression`。于是，它调用了自己。为了完成那个调用，它又必须*首先*找到一个 `expression`，于是它再次调用自己，无限循环下去，而从未查看输入的任何一个词。它迷失在纯粹思维的循环中，一个递归的死亡螺旋 [@problem_id:3637115]。

这就引出了第二种哲学：**自底向上解析**。这是一个实验主义者的方法。你不是从一个宏大的理论开始。你从数据——页面上的词——开始。你看着词和符号的序列说：“啊哈！这个小序列，‘the cat’，符合我关于名词短语的规则。”所以你替换它，有效地构建了谜题中更大的一块。你继续扫描和替换，用你的规则手册将小块组装成越来越大的块。你的希望是，到最后，你将成功地把所有碎片组装成一个单一、连贯的结构：句子。这种方法天然地免疫于[左递归](@entry_id:751232)的陷阱，因为它总是在消耗输入，总是在处理手头的数据。

### 自底向上解析的优雅机制

自底向上的策略很强大，但听起来有点神奇。机器如何知道它*何时*看到了一个规则的完整右侧？这是核心挑战，其解决方案是计算机科学中最优美的机制之一：**LR 解析器**。“L”代表从左（Left）到右扫描输入，“R”代表逆向构造一个最右（Rightmost）推导，这是一种技术性的说法，表示它是一个自底向上的解析。

LR 解析器的核心是一个[状态机](@entry_id:171352)。该机器执行一个包含两个步骤的简单舞蹈：
1.  **移入（Shift）**：从输入字符串中消耗一个符号，并将其放入一个栈上。
2.  **规约（Reduce）**：当栈顶的符号与某个文法规则的右侧完全匹配时，用该规则左侧的非终结符替换它们。

LR 解析器的天才之处在于那个确定性的表格，它在每一步都告诉解析器是应该移入还是规约，以及使用哪条规则。这个表格并非魔法；我们直接从文法本身构建它。

#### 作为理解快照的状态

要构建这个表格，我们首先需要一种方法来描述解析器在任何时刻的知识状态。我们使用一种叫做 **LR 项目**（LR item）的东西，它就是一个在右侧某处放了一个点（`.`）的文法规则。像 $A \to B \cdot C$ 这样的项目是一个简洁的陈述：“我们正在尝试寻找一个 $A$。到目前为止，我们已经成功找到了一个对应于 $B$ 的结构。如果我们接下来看到一个 $C$，我们就能完成这条规则了。”这个点分开了我们已经看到的部分和我们期望看到的部分。

我们解析器中的一个状态就是所有在解析过程中某个给定点上可能的此类项目的*集合*。

#### 推理的逻辑：闭包与Goto

我们如何找到一个状态中的所有项目？我们使用一个优美的演绎过程，称为**闭包**（closure）。假设我们的状态包含项目 $S \to \cdot A a$。这意味着我们正处于尝试寻找一个 $S$ 的最开始，而我们的文法告诉我们一个 $S$ 可以以一个 $A$ 开始。从逻辑上讲，我们现在必须留意一个 $A$ 的出现。因此，对于每一条告诉我们如何构建一个 $A$ 的规则，比如 $A \to B c$ 和 $A \to h$，我们必须向我们的状态中添加新项目：$A \to \cdot B c$ 和 $A \to \cdot h$。我们继续这个过程，添加所有从我们当前期望中得出的期望，直到没有新项目可以添加为止。

这揭示了该过程本质的深刻之处。假设我们有两条规则都需要我们寻找非终结符 $B$，比如 $A \to \cdot B c$ 和 $A \to \cdot B d$。当我们计算[闭包](@entry_id:148169)时，我们添加了 $B$ 的产生式的项目（例如，$B \to \cdot f$ 和 $B \to \cdot g$）。我们只添加一次。闭包算法操作于集合之上，而集合不关心你需要一个项目的理由有多少个——它要么在集合中，要么不在。这种构建是一个纯粹形式化的、句法上的过程，不关心频率或概率 [@problem_id:3655628]。

一旦我们有了一个完整的状态（一个“闭合的”项目集），我们就可以定义状态之间的转换。**goto** 函数回答了这个问题：“如果我们处于这个状态并且看到了符号 $X$，我们的新知识状态是什么？”我们只需取当前状态中所有点在 $X$ 之前的项目，将点移过 $X$，然后计算这个新项目[集的闭包](@entry_id:143367)。通过重复这个过程，我们生成了解析机器所有可能的[状态和](@entry_id:193625)转换。

### 预见能力的层级

这个过程很优雅，但有时机器会感到困惑。在某个给定的状态下，它可能面临一个选择。一个像 $A \to \alpha \cdot$ 这样的项目（一个**规约项目**）告诉它可以*进行*规约，而另一个像 $B \to \beta \cdot t \gamma$ 这样的项目（一个**移入项目**）告诉它可以*移入*终结符 $t$。这是一个**移入/规约冲突**。或者，它可能有两个不同的规约项目，$A \to \alpha \cdot$ 和 $B \to \beta \cdot$，从而产生一个**规约/规约冲突**。

解析器解决这些冲突的方式定义了它的能力。这催生了一个优美的 LR 解析器层级，每个都比前一个更强大。

#### 盲目的自动机：LR(0)

最简单的机器，一个 **LR(0) 解析器**，在做决定时完全没有任何预见能力。它只看它所处的状态。考虑一个简单但有歧义的文法：$S \to A \mid B$, $A \to a$, $B \to a$。在看到输入 `a` 之后，LR(0) 解析器到达一个包含两个规约项目的状态：$A \to a \cdot$ 和 $B \to a \cdot$。它不知道应该宣布找到了一个 $A$ 还是一个 $B$。这是一个规约/规约冲突，解析器失败了 [@problem_id:3655019]。文法的歧义性反映为机器中的一个冲突。事实上，这个文法是有[歧义](@entry_id:276744)的，因为字符串 `a` 有两个不同的推导，而一个基本定理指出，没有[歧义文法](@entry_id:260945)可以被确定性地解析 [@problem_id:3655019]。

#### 一线希望：SLR(1)

为了解决这个问题，我们可以给我们的机器一点点预见能力：一个单符号的**前瞻**（lookahead）。一个**简单 LR (SLR(1))** 解析器，当面临通过 $A \to \alpha$ 进行规约的选择时，会窥视下一个输入符号。它只有当该符号在 $A$ 的 **FOLLOW 集**——即在语言中任何地方可以合法地跟在 $A$ 后面的所有终结符的集合——中时，才执行规约。这是一个全局的、预先计算好的信息。

不幸的是，这种全局上下文往往过于粗糙。对于我们的[歧义文法](@entry_id:260945) $S \to A \mid B, A \to a, B \to a$，无论是 $A$ 还是 $B$ 后面都可以是输入的结尾。它们的 FOLLOW 集是相同的。所以，当 SLR(1) 解析器看到 `a` 后面跟着输入结尾时，它仍然不知道是规约成 $A$ 还是 $B$。冲突依然存在 [@problem_id:3655019]。

#### 上下文的力量：LR(1) 与 LALR(1) 的妥协

最终的解决方案是让前瞻信息变得局部和精确。一个 **LR(1) 解析器**将前瞻直接融入到项目中。一个项目现在的形式是 $[A \to B \cdot C, x]$，意思是“我们正在寻找一个 $A$，已经找到了一个 $B$，期望一个 $C$，并且在我们找到整个 $A$ 之后，我们期望看到终结符 $x$。”这种特定于上下文的前瞻能力足以解决许多困扰 SLR(1) 解析器的冲突。

然而，这种能力是有代价的：对于同一个文法，一个 LR(1) 解析器的状态数量可能是一个 SLR(1) 解析器的十倍。这导致了一个实用而聪明的妥协：**前瞻 LR (LALR(1))** 解析器。其思想是，获取完整的 LR(1) [状态机](@entry_id:171352)，并将任何具有相同核心项目（即，如果忽略前瞻符号，它们是相同的）的状态合并。然后我们将前瞻集合并。这极大地减少了状态的数量。

但是，就像在物理学和计算机科学中经常发生的那样，没有免费的午餐。通过合并状态，我们可能会无意中合并那些在 LR(1) 机器中被小心翼翼地分开的前瞻符号。这可能会重新引入冲突！存在一些文法，它们可以被 LR(1) 完美解析，但在 LALR(1) 中会产生冲突 [@problem_id:3648857] [@problem_id:3624905]。例如，一个文法可能会导致一个状态包含规约项目 $[A \to v \cdot, y]$ 和 $[B \to v \cdot, z]$，而另一个状态包含项目 $[A \to v \cdot, z]$ 和 $[B \to v \cdot, y]$。在 LR(1) 中，这些都没问题；选择是明确的。但是 LALR(1) 将它们合并成一个单一状态，包含 $[A \to v \cdot, \{y, z\}]$ 和 $[B \to v \cdot, \{y, z\}]$，从而产生了一个规约/规约冲突 [@problem_id:3648857]。我们甚至可以找到特定的字符串，比如对于某个文法的 `dc`，它能被 LALR(1) 解析器成功解析，但却会在一个精度较低的 SLR(1) 解析器中引起移入/规约冲突，这优美地说明了能力与效率之间的权衡 [@problem_id:3624891]。

### 另一个现实：作为动态规划的解析

LR 解析的[状态机](@entry_id:171352)方法并非唯一的选择。一种完全不同但又密切相关的哲学将解析视为一个填写表格的问题，这种技术被称为**动态规划**或**图表解析**。

#### CYK 的优雅

如果我们愿意将我们的文法调整成一种非常特定和简洁的格式，称为**Chomsky [范式](@entry_id:161181) (CNF)**，其中所有规则要么是 $A \to BC$ 要么是 $A \to a$ [@problem_id:1360030]，我们就可以使用一种惊人优雅的算法，称为 **Cocke-Younger-Kasami (CYK)**。

想象一个在你的输入字符串下方铺开的三角形表格。第一行对应长度为一的子串。对于每个字符，你用所有可以生成它的非终结符来填充其单元格。然后你移动到下一行，处理长度为二的子串。要为一个子串填充单元格，你需要考虑所有可能的将其一分为二的方式。对于每种分割，你查看你已经为那两个较小部分填充的单元格。如果你找到一条规则 $A \to BC$，其中 $B$ 在第一部分的单元格中，而 $C$ 在第二部分的单元格中，你就将 $A$ 添加到当前单元格。你继续这个过程，自底向上地填充表格，直到你到达代表整个字符串的顶部单元格。如果开始符号在该单元格中，那么该字符串是有效的。这个极其系统的过程所花费的时间与输入长度的立方成正比，即 $O(n^3)$ [@problem_id:3279144]。

#### 通用引擎：Earley 算法

但是，如果我们的文法不是 CNF 形式呢？我们可以使用一个更通用的图表解析器：**Earley 算法**。它适用于任何[上下文无关文法](@entry_id:266529)。它不是仅仅在其表格（或“图表”）中存储非终结符，而是存储带点的项目，这与我们在 LR 解析中看到的非常相似！一个 Earley 项目 $\langle A \to \alpha \cdot \beta, i, j \rangle$ 是一条记录，陈述：“对于从位置 $i$ 开始的子串，我们已经成功匹配了规则 $A \to \alpha \beta$ 的 $\alpha$ 部分，并且这个匹配结束于位置 $j$。”该算法逐列构建图表，使用三个操作：**预测器**（预测要尝试的新规则）、**扫描器**（匹配一个终结符）和**完成器**（当一个规则的点到达末尾时完成它）。

对于无[歧义](@entry_id:276744)的文法，Earley 算法效率惊人，运行时间为 $O(n^2)$。但对于可能存在多个[解析树](@entry_id:272911)的[歧义文法](@entry_id:260945)，项目数量会爆炸性增长，其性能会退化到 $O(n^3)$——与 CYK 相同 [@problem_id:3279144]。

#### 统一的时刻

在这里，我们发现了一个优美的统一时刻。一个“已完成”的 Earley 项目，如 $\langle A \to \gamma \cdot, i, j \rangle$，代表了从 $i$ 到 $j$ 的子串被成功识别为可以从 $A$ 推导出来。这与 CYK 表格的单元格 $V[i,j]$ 中出现条目 $A$ 所代表的信息*完全相同*。这两种算法，尽管看起来不同，却在发现关于字符串结构的相同基本真理；它们只是用略有不同的符号来记录它们的发现 [@problem_id:3639797]。

### 超越地平线：[上下文无关文法](@entry_id:266529)的局限

我们已经构建了强大的机器和优雅的算法，所有这些都基于[上下文无关文法](@entry_id:266529)的规则手册。但是，如果一种语言对于我们的规则手册来说过于复杂怎么办？考虑语言 $L = \{\mathtt{a}^n \mathtt{b}^n \mathtt{c}^n \mid n \ge 1\}$，它由一块'a'，后跟数量相等的'b'，再后跟数量相等的'c'组成。一个已被证明的事实是，没有[上下文无关文法](@entry_id:266529)可以描述这种语言。确保所有三个计数都相等所需的“记忆力”超出了一个 CFG 的处理能力。

如果我们把像 $\mathtt{a}^5 \mathtt{b}^5 \mathtt{c}^5$ 这样的字符串喂给一个配备了*任何* CFG 的 Earley 解析器，它将无法识别它（除非那个文法是一个只对 $n=5$ 有效的廉价仿制品）。这种失败不是 Earley 算法的缺陷；该算法正在完美地履行其职责。限制在于**形式体系**本身的描述能力 [@problem_id:3639845]。我们对世界的地图太简单了。

为了解析这类语言，我们必须超越[上下文无关文法](@entry_id:266529)，进入“轻度上下文相关”形式体系的领域，如**树邻接文法 (TAGs)**。这些更强大的规则手册可以描述具有[交叉](@entry_id:147634)序列依赖关系和像 $\mathtt{a}^n \mathtt{b}^n \mathtt{c}^n$ 这样模式的语言。并且，美妙的是，我们已经发展的那些思想——如图表解析和动态规划——可以被扩展，为这些更复杂的世界构建多项式时间的解析器 [@problem_id:3639845]。发现之旅仍在继续，揭示出隐藏在语言结构中更深层、更优雅的结构。

