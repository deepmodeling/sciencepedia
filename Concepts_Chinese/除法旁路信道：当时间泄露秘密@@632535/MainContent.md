## 引言
在软件的抽象世界里，我们常常将计算视为一个纯粹的逻辑过程。然而，每一行代码都运行在物理机器上，一个受物理定律支配的设备，其上的操作会消耗时间和能量。这一物理现实造成了一个微妙但深刻的漏洞：计算的物理特性可能会泄露其处理的秘密数据。程序运行所需的时间，一个我们用简单秒表就能测量的属性，可能成为一个非预期的输出信道，泄露加密密钥等关键信息。这种现象被称为旁路信道攻击，它从根本上挑战了我们构建安全系统的方式。

本文将深入探讨时间旁路信道这个迷人而危险的世界，并以看似简单的算术除法作为起点。我们将探索像除法这样基础的操作，其执行时间如何会因输入值的不同而变化，从而造成严重的[信息泄露](@entry_id:155485)。接下来的章节将引导您从单个硬件指令出发，逐步认识到一个普适性的安全原则：

-   **原理与机制** 将揭示[时间攻击](@entry_id:756012)的基础概念。我们将剖析除法为何独特地存在问题，探索程序逻辑和[次正规数](@entry_id:172783)处理等微妙的硬件特性如何制造漏洞，并引入恒定时间执行这一核心防御原则。

-   **应用与跨学科联系** 将拓宽我们的视野，展示同样的原则如何远远超出除法的范畴。我们将研究其他 CPU 组件、整个片上系统 (SoC) 中的泄露，并审视编译器和[操作系统](@entry_id:752937)的“共谋”行为，最后将这些思想与安全加密算法乃至机器人等物理系统的设计联系起来。

通过理解时间如何泄露秘密，我们就能学会编写“沉默”的代码。让我们从审视使这些攻击成为可能的核心机制开始。

## 原理与机制

### 时间即信息

想象一下，你正在和朋友玩一个游戏。“我心里想了一个数字，”她说，“只有你猜对了，我才会告诉你。”你猜“17”。她立刻回答“不对”。你猜“19”。又是一个即时的“不对”。然后你猜“8,675,309”。在她最终说出“不对”之前，有了一段很长的[停顿](@entry_id:186882)。你学到了什么？你没有猜中那个数字，但停顿本身就是一个线索。你可能会推测，对于小数，她能凭记忆知道答案，但对于一个大而不熟的数字，她必须进行一些心算。她的反应时间，一个世界的物理属性，泄露了关于她心中秘密数字的一点信息。

计算机，尽管无比抽象，仍是一台物理机器。它执行的每一条指令都是一连串在硅片中传播的电信号，这个过程在时间中展开。当我们编写软件，特别是处理加密密钥等秘密的软件时，我们常常抱有一种错觉，认为唯一的输出是我们明确定义的那个——计算的结果，屏幕上的一个字符。但是机器还有其他“输出”，其中最强大的一个就是它产生官方输出所花费的时间。

如果一个程序的执行时间取决于它正在处理的某个秘密值，那么一个拿着秒表的观察者原则上就可以从时间测量结果反向推断出关于这个秘密的一些信息。这是所有时间旁-路信道攻击的基石。为了防御它们，我们必须遵守一个严格而优美的原则：**恒定时间执行**。程序的运行时间必须与其接触的任何秘密数据无关。就像一个完美的扑克玩家，其面部表情不会泄露丝毫手中牌的信息一样，一个安全的加密程序绝不能让其执行时间暴露它所持有的秘密。

### 除法的不羁本性

在基本算术运算中，除法是害群之马。定长整数的加法、减法甚至乘法，在硬件中通常是优雅、专一的事务，以固定且可预测的[时钟周期](@entry_id:165839)数执行。除法不同。它本质上是迭代的，很像我们在小学学到的长除法。其步骤数可能取决于被除数和除数的具体值。

许多处理器为了追求速度，在其除法硬件中集成了一项名为**提前终止**的功能。如果处理器被要求计算 `100 / 10`，它会很快得到答案 `10`。如果被要求计算 `100 / 3`，它就必须花更长的时间来找出商 `33` 和余数。一个智能的硬件除法器可能会被设计成一旦结果完全确定就立即停止。例如，如果商结果是个小数，算法就可以在更少的周期内完成。虽然这是一个聪明的[性能优化](@entry_id:753341)，但它却是一个安全噩梦。如果攻击者能影响一个计算 `N / D`，其中 `D` 是一个秘密密钥，那么执行除法所需的时间就会泄露关于商的大小的信息，而这又会泄露关于 `D` 的信息 [@problem_id:3651724]。

这就是我们的第一个基本机制：**数据依赖延迟**。单个基础硬件指令的执行时间会根据其操作的值而变化。除法是一个臭名昭著的罪魁祸首，但正如我们将看到的，它远非唯一的一个。

### 当代码站队

硬件本身并非唯一的麻烦来源。我们程序的逻辑本身就能制造时间泄露。考虑一下“平方乘”算法，这是密码学中执行求幂运算的基石。要计算 $a^e \pmod n$，其中 $e$ 是一个秘密指数，一个幼稚的实现可能会遍历 $e$ 的比特位并执行以下操作：

1.  总是执行一次平方操作。
2.  如果 $e$ 的当前比特位是 1，*那么*执行一次乘法操作。

这个 `if` 语句在路上制造了一个岔口。对于一个为 0 的比特，CPU 遵循一条路径（一次平方操作）。对于一个为 1 的比特，它遵循另一条更长的路径（一次平方*然后*一次乘法）。一个拥有足够灵敏探针（例如，能够测量[功耗](@entry_id:264815)）的攻击者，可以 буквально地看到“仅平方”与“平方后乘法”的模式，并像读股票行情自动收录器一样读出秘密指数的比特位。即使只用一个简单的秒表，整个操作的总时间也将与指数中 1 的数量（其**[汉明权重](@entry_id:265886)**）成正比，从而泄露有价值的统计信息 [@problem_id:3087407]。

这揭示了我们的第二个基本机制：**秘密依赖的[控制流](@entry_id:273851)**。只要程序的执行路径——一个 `if`、`while` 或 `switch` 语句——依赖于一个秘密值，它就创造了一个潜在的时间漏洞。这两条路径几乎肯定会花费不同的时间来执行。

### 机器中的幽灵：现代处理器中的微妙泄露

现代处理器中的时间变化并不总是像可变延迟的除法指令或我们代码中的 `if` 语句那样明目张胆。它们可以隐藏在那些支配计算的标准的微妙、晦涩的角落案例中。

以浮点运算为例，它由无处不在的 [IEEE 754](@entry_id:138908) 标准所规定。对于绝大多数“正常”数字，操作是闪电般快速的，通过高度优化的硬件流水线进行。但该标准还定义了一些特殊类别的数字。其中一类是**[次正规数](@entry_id:172783)**（也称[非正规数](@entry_id:172783)）。这些是介于零和最小可表示“正常”数之间的极小值。处理它们通常需要处理器离开快速路径，转而使用特殊用途的微码或一个更慢、更通用的硬件单元。性能差异可能非常巨大——速度下降 100 倍也并非闻所未闻。

攻击者可以利用这一点。假设一个密码学函数计算 `y = s / b`，其中 `s` 是一个秘密值，`b` 是攻击者控制的公开输入。通过仔细选择 `b`，攻击者可以尝试迫使结果 `y` 落入[次正规数](@entry_id:172783)范围。如果除法突然变得非常慢，攻击者就知道了 $|s/b|$ 小于[次正规数](@entry_id:172783)的阈值。通过尝试不同的 `b` 值，他们可以有效地“逼近”秘密 `s` 的大小 [@problem_id:3258168]。

另一个特殊值，**非数值**或 **NaN**，提供了一个更强大的泄露源。一个无效操作如 `0.0 / 0.0` 会产生一个 `NaN`。像[次正规数](@entry_id:172783)一样，处理 `NaN` 可能更慢。但还有一个复合效应。[IEEE 754](@entry_id:138908) 规定，任何涉及 `NaN` 的比较（如 `NaN > 0`）必须评估为假。现在，考虑一段代码：`z = x/x; if (z > 0) { ... }`。如果攻击者能迫使 `x` 为 `0.0`，那么 `z` 就变成 `NaN`。比较 `NaN > 0` 就变成了假。现代 CPU 使用分支预测来猜测 `if` 是否会被执行。如果它猜测“执行”（也许因为它通常被执行），但实际结果是“不执行”，它就会遭受一次**分支预测错误**。这迫使 CPU 清空其流水线并重新启动，导致 10-20 个周期的严重时间惩罚。攻击者得到了双重打击：产生 `NaN` 的较慢除法*加上*一个保证的分支预测错误惩罚，创造了一个巨大且易于检测的时间信号 [@problem_id:3642880]。

### 聪明的意外后果

漏洞不仅源于硬件的怪癖；它们也可能被软件开发者甚至我们用来编写代码的工具无意中创造出来，而这往往是为了追求性能。

编译器是优化的主人。它们将我们人类可读的[代码转换](@entry_id:747446)为高效的机器指令，遵循**“as-if”规则**：只要程序的可观察行为保持不变，任何转换都是合法的。但什么是“可观察的”？对于标准编译器来说，这通常意味着 I/O 操作和程序异常的序列，而不是执行时间。编译器世界模型与物理现实之间的这种不匹配可能是危险的。像**懒惰[代码移动](@entry_id:747440)**这样的优化可能会注意到一个 `if` 块内的除法，并且为了效率，将其提升到条件判断*之前*执行。如果这个除法最初位于一条未被执行的路径上，这个优化就将其执行时间添加到了一个先前很快的路径上。如果攻击者可以观察到后续网络数据包的时间，他们就可以推断出 `if` 条件是真是假，从而泄露一个秘密 [@problem_id:3649347]。

程序员自己，尤其是在[密码学](@entry_id:139166)领域，对性能痴迷。现代[椭圆曲线](@entry_id:152409)密码学的一个核心原则是不惜一切代价避免域求逆（本质上是除法）这种缓慢的操作。取而代之，他们使用替代[坐标系](@entry_id:156346)，如**射影坐标**，它巧妙地用一系列许多更廉价的乘法来替换一次非常昂贵的求逆操作 [@problem_id:3091438]。

但这带来了一个新的挑战。在我们试图替换昂贵的除法时，我们可能会使用一种**强度削减**技术。为了计算余数 `x % p`，我们可以使用一种涉及与预计算的“魔数”相乘的更快方法，而不是慢速的 `DIV` 指令。然而，这些算法通常需要一个最后的、微小的修正步骤：`if (result >= p) { result = result - p; }`。我们刚刚重新引入了一个秘密依赖的分支！我们用一个硬件层面的漏洞换来了一个软件层面的漏洞 [@problem_id:3672244]。

解决方案与问题本身一样优雅。我们必须使用**无分支编程**来执行修正。我们可以使用[位运算](@entry_id:172125)逻辑来代替 `if` 来达到同样的结果。例如，为了有条件地减去 `p`，我们可以计算一个 `mask`，它根据条件要么全为零，要么全为一。修正操作就变成了类似 `result = result - (mask  p)` 的形式。这个算术和逻辑操作序列无论结果如何都以相同的时间执行，完美地掩盖了时间信道。

### 涟漪效应：一次减速撼动整个核心

到目前为止，我们谈论程序时，仿佛它在一个孤立的宇宙中运行。但在现代机器上，它与其他程序共享处理器。这种共享创造了新的攻击途径。许多 CPU 使用**同步[多线程](@entry_id:752340) (SMT)**，即两个或多个逻辑线程在同一个物理核心上并发运行，共享[指令流水线](@entry_id:750685)等资源。

其中一个关键资源是**[重排序缓冲](@entry_id:754246)区 (ROB)**，它跟踪所有当前正在执行的指令。想象一个受害者程序执行一个长延迟指令，比如一个除法。因为指令必须按程序顺序退役，这个慢速的除法就像 ROB 头部的堵塞物。即使后面几十条指令已经执行完毕，它们也无法被正式完成并从 ROB 中移除，直到这个除法完成。

现在，一个攻击者的线程，在同一个物理核心上运行，试图执行它自己的指令。它的每条指令都需要在流水线的开始处分配一个 ROB 条目。但是受害者停滞的指令占用了所有的条目。ROB 已满。攻击者的线程因缺乏此资源而陷入饥饿状态，运行停滞，经历了所谓的**重命名[停顿](@entry_id:186882)**。攻击者可以直接测量这些[停顿](@entry_id:186882)。通过观察自己[停顿](@entry_id:186882)计数的增加，攻击者可以推断出受害者必定正在执行一个缓慢的、堵塞 ROB 的指令——比如一个其输入依赖于秘密的除法 [@problem_id:3673174]。

这是一个深刻的认识。单个非恒定时间指令不仅仅泄露它自己的执行时间。它的效应可以通过共享的[微架构](@entry_id:751960)产生涟漪，造成可被完全独立的进程观察到的竞争和减速。

### 一个普适原则：一切皆恒定时间

恒定时间设计的原则远不止适用于除法。它适用于任何行为依赖于秘密数据的操作。考虑一次内存访问。处理器可能实现分段内存，其中[地址计算](@entry_id:746276)为 `base + offset`。一个安全检查必须确保 `offset` 在该段的有效边界内。一个幼稚的[硬件设计](@entry_id:170759)可能首先计算有效地址 `base + offset` 并推测性地用它来查找缓存或 TLB（[地址转换](@entry_id:746280)的缓存），同时检查边界。如果检查后来失败，它会引发一个故障。但损害已经造成。使用源自秘密 `base` 的地址进行的推测性查找已经发生。它的时间——缓存命中或未命中——泄露了关于秘密基地址的信息 [@problem_id:3622133]。

唯一安全的设计是强制执行一个严格、不变的顺序：**在对秘密进行操作之前验证公开输入**。硬件必须在 `offset` 与秘密 `base` 结合之前检查 `offset` 是否有效。这种恒定时间故障处理的原则是普遍的。

正如我们的旅程所显示的，构建安全的系统需要一个整体的视角，从硬件的物理学到编译器的逻辑，再到最终程序的架构。我们必须遵守一些简单但强大的规则：
-   避免依赖于秘密的[控制流](@entry_id:273851)。使用无分支逻辑。
-   避免依赖于秘密的内存访问模式。
-   仅使用具有数据无关延迟的硬件指令。
-   当这不可能时，我们必须**均衡路径**。最直接的方法是使用**填充**：确定最坏情况（最慢）的执行时间，并通过插入虚拟延迟强制所有其他路径花费完全相同的时间 [@problem_id:3632347]。这使得执行时间成为一个常数，使信道变得无用。通过这样做，我们确保了秘密与观察到的时间之间的互信息为零。

大自然不关心我们的秘密。处理器，在其核心，是一个受物理定律支配的物理机器。它完成一项任务需要多长时间就是多长时间。如果我们想让它保守一个秘密，我们必须极其小心地设计我们的问题——我们的程序——以使找到答案所需的时间完全不泄露任何信息。

