## 应用与跨学科联系

既然我们已经掌握了[拜占庭容错](@entry_id:747029)的原理，你可能会问一个完全合理的问题：“这是一个聪明的理论工具，但它在现实世界中出现在哪里？”这是一个我们应该对任何科学思想提出的问题。一个深刻原理的美妙之处不仅在于其优雅，还在于其力量和[影响范围](@entry_id:166501)。而BFT的影响范围惊人地、奇妙地广阔。它不是某个束之高阁的陈旧算法；它是一个活生生的、强大的工具，用于在一个远非可信的世界中构建可信赖的系统。

让我们从计算机的心脏——[操作系统](@entry_id:752937)开始我们的旅程，这是一个信任不是奢侈品而是绝对必需品的地方。

### 巩固数字基石：操作系统内核

[操作系统](@entry_id:752937)是所有其他软件赖以构建的基础，是总的操控者。如果[操作系统](@entry_id:752937)本身可以被欺骗，那么任何应用程序，无论其编写得多么安全，都无法真正安全。但如果[操作系统](@entry_id:752937)不是一个单一实体呢？如果它是一个集体，一个由复制的内核组成的集群，共同提供单一、统一的服务呢？这正是BFT的完美舞台。

想象一个简单但关键的任务：为一个新进程命名。如果系统的某个恶意部分可以谎报进程的名称，它就可能规避安全策略，伪装成无害的程序进行破坏活动。我们如何防止这种情况？我们可以征求一个由复制内核组成的委员会的意见。一个控制着其中少数内核的拜占庭对手可能会试图挑拨离间，告诉一些协调者一个名字，告诉另一些不同的名字。但是，如果我们要求一个超半数——比如在一个为容忍 $f$ 个说谎者而设计的 $3f+1$ 个副本的系统中，要求一个由 $2f+1$ 个签名组成的法定数量——那么我们就构建了一座逻辑的堡垒。要使任何两个相互冲突的名字被接受，签署它们的验证者集合就必须重叠。由于我们对数字的选择，这个重叠保证足够大，以至于至少包含一个*诚实*的内核。根据定义，一个诚实的内核绝不会为同一个进程签署两个不同的名字，所以这个矛盾揭示了谎言。制造混乱的企图失败了。系统保持了一致和安全 [@problem_id:3625150]。

这个“法定数量交集”的原理是秘密武器。它适用于各种基本的[操作系统](@entry_id:752937)任务。我们如何授予一个程序访问文件的权限？我们铸造一个“能力令牌”，但我们要求它由一个法定数量的权威机构签署。我们如何撤销该权限？我们发布一个撤销通知，也由一个法定数量签署。对手不可能两面讨好——说服一些人令牌有效，又说服另一些人它已被撤销——因为这两个矛盾声明所需的法定数量在数学上被强制要求在至少一个会提出异议的诚实权威上相交 [@problem_id:3625138]。

同样的逻辑防止了数字世界中相当于银行出纳员把同一张钞票给两个不同的人的情况。在[分布式文件系统](@entry_id:748590)中，这就是资源的“双重分配”，比如一个 [inode](@entry_id:750667)。通过要求任何分配都必须由足够大的分配器服务法定数量来认证，我们可以保证不可能为同一资源形成两个有效的证书而不暴露谎言。保证这一点的条件是，任意两个法定数量的交集必须大于可能说谎者的数量，这导出了美妙的不等式 $2q \gt n + f$，其中 $q$ 是法定数量的大小，$n$ 是副本总数，$f$ 是容忍的故障数 [@problem_id:3625164]。BFT 甚至提供了执行复杂的、全有或全无的原子操作的机制，比如重命名文件，这涉及到删除一个旧的目录条目和创建一个新的目录条目。通过将这两个操作捆绑成一个单一的事务，由 BFT 共识机制作为一个整体来批准或拒绝，我们防止系统陷入灾难性的中间状态 [@problem_id:3625142]。

### 一个巧妙的技巧：当[密码学](@entry_id:139166)伸出援手

在这里，我们遇到了一个特别美妙的协同效应。如果我们试图达成一致的数据能够自我证明呢？如果一段数据可以通过[密码学](@entry_id:139166)证明其自身的有效性呢？

考虑一个记录每一个重要操作的系统——一个系统调用审计日志。我们可以将这个日志构建成一个哈希链，其中每个新条目都包含前一个条目的加密哈希。现在，一个诚实副本的工作变得简单多了。要验证一个新的日志条目，它不需要问任何人；它只需要检查两件事：新条目是否正确地指向我所知道的最后一个条目，以及它自己的哈希是否计算正确？它可以完全靠自己验证这一点 [@problem_id:3625174]。

同样的想法也适用于在复杂[目录结构](@entry_id:748458)中验证文件路径。使用[默克尔树](@entry_id:634974)，我们可以创建一个小的加密“证明”，来展示一个特定路径的存在，并且这个证明可以对照一个单一的、可信的根哈希进行检查 [@problem_id:3625169]。

在这些场景下，[共识问题](@entry_id:637652)发生了巨大变化。一个拜占庭副本可以撒谎，但它无法伪造一个有效的加密证明。谎言会立刻被察觉。因此，我们不再需要找到一个对某个值*达成一致*的法定数量。我们只需要*找到一个诚实的副本*。我们的挑战不再是就真相达成一致，而只是确保我们至少能从一个说真话的一方那里听到消息。

要做到这一点，我们只需要收集响应，直到我们收到的副本数量超过可能说谎者的数量。如果我们收集了 $f+1$ 个响应，即使在最坏的情况下，前 $f$ 个都是恶意的垃圾信息，最后一个也保证来自一个诚实的来源。而且因为它的响应是自我验证的，那一个诚实的响应就足够了。达成一致的要求从 $2f+1$ 的超半数缩减到只需一个（诚实声音的）简单多数，总共只需收集 $f+1$ 条消息。这是密码学和分布式系统两个领域协同工作的一个绝佳例子，产生了一个比任何一个领域单独能实现的更简单、更高效、更优雅的结果。

### 超越内核：保障云和科学发现

BFT 的力量远远超出了单个[操作系统](@entry_id:752937)的范围。考虑一下现代云，[虚拟机](@entry_id:756518)（VM）在物理主机之间[动态迁移](@entry_id:751370)。目标主机如何相信来自源主机的传入 VM 状态没有被恶意篡改？源主机本身可能是拜占庭式的。BFT 再次提供了解决方案。我们可以使用一个由独立验证者组成的委员会在不同检查点检查 VM 的状态（其内存和 CPU 寄存器）。要提交迁移，目标主机需要一个关于 VM 状态的法定数量的签名批准。但仅仅验证一个时间点的快照是不够的。一个聪明的对手可能会呈现一个有效但非常陈旧的状态，从而有效地回滚 VM。为了防止这种情况，协议可以要求对*两个连续的检查点*达成法定数量的一致，并以密码学方式验证它们之间的转换是有效的。这不仅确保了状态的完整性，也确保了其随时间推移的进展的完整性 [@problem_id:3625205]。

也许这些思想最令人兴奋的应用在于一个你可能意想不到的领域：新一代的“区块链”技术。当人们听到“区块链”时，他们通常会想到比特币及其缓慢、耗能的“工作量证明”。但这只是一种共识类型，是为公共、匿名的世界设计的。对于私有的、协作的努力——比如一个银行联盟、一个供应链网络或一组研究机构——需要一种不同的方法。他们需要速度、确定性的最终性和隐私性。他们需要 PBFT。

让我们想象一下，一组生物学实验室想要为[基因注释](@entry_id:164186)创建一个共享的、不可变的账本。一个基因的功能是如何被识别的历史——从最初的自动预测到多轮专家修订——对于可重复的科学至关重要。任何歧义或篡改的可能性都可能破坏多年的工作。

这是一个完美的 BFT 驱动账本的用例。这些机构组成一个许可的验证者委员会。要添加或编辑一个注释，需要提出一个交易。使用像 PBFT 这样的协议，验证者可以在不到一秒的时间内就一批这样的交易达成一致。最终性是确定性的；没有概率性的等待。因为验证者是已知的，我们可以容忍他们中的一定数量是恶意的（比如 $n=10$ 个机构中有 $f=3$ 个），并且仍然保证账本的完整性。敏感的原始数据，如患者基因组，永远不会放在共享链上；只有对它的加密承诺才会被放上去，从而在保证可审计性的同时保护隐私 [@problem_id:2383772]。

在这里，$2f+1$ 法定数量和有序日志的抽象原理被转化为一种追求科学真理的工具。它为一个社区创造了一个共享的现实，一个即使其某些贡献者不可信，其历史也依然可信的数字产物。从保障计算机的启动过程到保障科学发现的过程本身，其主线是相同的。BFT 提供了一个通用的配方，用于从世界的不可预测和混乱基底中锻造秩序和确定性。它证明了纯粹逻辑在构建我们真正可以依赖的系统方面的力量。