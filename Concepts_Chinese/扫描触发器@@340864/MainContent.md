## 引言
现代集成电路是人类历史上最复杂的创造之一，在微小的硅片空间内容纳了数十亿个晶体管。但工程师如何能确保这些组件中的每一个都完美工作？当他们只能接触到少数几个外部引脚时，又如何能在这座硅基都市深处找到一个微小的缺陷？这种有限的“可控性”（设置内部状态的能力）和“[可观测性](@article_id:312476)”（查看内部状态的能力）这一根本问题，使得传统测试方法力不从心。

本文介绍[扫描设计](@article_id:356249)，这是一种革命性的工程解决方案，通过提供一个进入芯片核心的虚拟“后门”来应对这一挑战。我们将通过两个主要章节来探讨其基本概念。“原理与机制”一章将解构[扫描触发器](@article_id:347533)的巧妙设计，并解释这些特殊组件如何连接在一起形成[扫描链](@article_id:350806)，从而赋予工程师对电路状态的完全控制和可视化的超能力。在此之后，“应用与跨学科联系”一章将展示如何利用这种强大的能力进行精确的故障诊断，如何为经济效益进行优化，以及如何扩展以解决物理和系统层面的挑战，揭示[扫描设计](@article_id:356249)作为现代电子学基石的地位。

## 原理与机制

想象一下，你是一名侦探，试图在一座没有窗户的巨大摩天大楼内破案。你只能站在前门。你可以向内发送信息，也可以接收向外的信息，但你看不到第50层或地下室里发生了什么。你怎么可能弄清楚大楼深处是否出了问题？这正是工程师在测试现代计算机芯片——一个拥有数十亿晶体管的硅基都市——时所面临的挑战。你能看到的输出只是前门，而缺陷可能潜伏在任何地方。

[扫描设计](@article_id:356249)是解决这个问题的巧妙方案。它就像秘密安装了一条连接大楼里每个重要房间（存储单元）的私人地铁线路，并有自己的入口和出口。这让侦探能够完全控制局面，看清一切，并以惊人的效率破案。让我们来探讨实现这一点的原理。

### 双面[触发器](@article_id:353355)：伪装大师

扫描方法的核心是对标准数字存储单元——**D 型[触发器](@article_id:353355)**——的巧妙改造。一个普通的[触发器](@article_id:353355)工作很简单：在时钟的节拍下，它捕获其输入端 `D` 上的数据值并保持它。而经过改造的版本，称为**[扫描触发器](@article_id:347533)**，则被赋予了双重性格。它就像一个铁路道岔，可以将火车引导到两条轨道中的一条。

这是通过在[触发器](@article_id:353355)的数据输入端之前放置一个简单的 2-1 多路选择器（MUX）来实现的。MUX 只是一个数字开关。它有两个数据输入——我们称之为 `I_0` 和 `I_1`——以及一条选择线 `S`。如果 `S` 为 0，MUX 输出 `I_0` 的值；如果 `S` 为 1，它输出 `I_1` 的值。

在[扫描触发器](@article_id:347533)中，我们将来自电路逻辑的正常数据（我们称之为 `D_in`）连接到 `I_0` 输入。我们将一个新的、特殊的输入，即 `scan_in` 或 `S_in`，连接到 `I_1` 输入。MUX 的选择线是整个芯片的一个新控制信号：`scan_enable` 或 `SE`。这个 MUX 的输出随后直接送入[触发器](@article_id:353355)的 `D` 输入，我们可以称之为 `D_ff`。

这个简单的布置产生了以下行为，可以用一个简洁优美的[布尔代数](@article_id:323168)表达式来描述 [@problem_id:1958956]：

$$
D_{ff} = (\overline{SE} \cdot D_{in}) + (SE \cdot S_{in})
$$

让我们像读一个句子一样来解读它。它说，[触发器](@article_id:353355)捕获的数据 $D_{ff}$ 由两件事之一决定。当 `scan_enable` ($SE$) 为 0（关闭）时，第一项有效，第二项为零，所以 $D_{ff} = D_{in}$。[触发器](@article_id:353355)表现得完全正常，监听其周围的逻辑。这是**正常模式**。但是当我们把 `scan_enable` 设置为 1（开启）时，第一项变为零，第二项有效，所以 $D_{ff} = S_{in}$。现在，[触发器](@article_id:353355)完全忽略其正常输入，而只监听特殊的 `scan_in` 线 [@problem_id:1958944]。这是**扫描模式**。这种双重性格，编码在[触发器](@article_id:353355)的特性表中，是其根本的技巧 [@problem_id:1936748]。

### 秘密地铁系统

现在我们有了特殊的双面[触发器](@article_id:353355)，我们执行第二步：将它们全部连接起来。我们将第一个[扫描触发器](@article_id:347533)的输出 (`Q`) 连接到第二个[扫描触发器](@article_id:347533)的 `scan_in` (`S_in`) 端口。我们将第二个的输出连接到第三个的输入，依此类推，像串珍珠项链一样将它们串在一起，直到设计中的每一个[触发器](@article_id:353355)都成为一条连续链的一部分。

这就创建了我们的秘密地铁线路。第一个[触发器](@article_id:353355)的 `scan_in` 连接到芯片外部的一个引脚，即**扫描输入 (SI)** 端口——我们的地铁入口。最后一个[触发器](@article_id:353355)的输出连接到另一个外部引脚，即**扫描输出 (SO)** 端口——我们的地铁出口。当然，我们还需要一个引脚作为整个系统的主开关：**扫描使能 (SE)** 引脚 [@problem_id:1958942]。

当 `SE` 为 0 时，似乎一切都没有不同。所有[触发器](@article_id:353355)都独立工作，执行它们的计算任务。地铁处于离线状态。但当我们断言 `SE` 为 1 的那一刻，电路的整个特性都变了。成千上万个独立的、并行的[触发器](@article_id:353355)被动态地重新配置成一个巨大的串行[移位寄存器](@article_id:346472)——一条单一的、连续的传送带。现在，在每个时钟节拍，一个数据位从 `SI` 引脚进入，第一个[触发器](@article_id:353355)中的位移动到第二个，第二个到第三个，依此类推，直到最后一个[触发器](@article_id:353355)中的位从 `SO` 引脚退出。

### 完美知识的力量：[可控性与可观测性](@article_id:323345)

那么，费这么大周折是为了什么？这个隐藏的基础设施赋予了我们两个超能力，这是测试的圣杯：**[可控性](@article_id:308821)**和**[可观测性](@article_id:312476)**。

**[可控性](@article_id:308821)**是指能够将电路的任何内部节点设置为你想要的任何值。没有扫描，这几乎是不可能的。为了测试某个特定的错误，你可能需要在芯片深处的[触发器](@article_id:353355)中存储一个非常特定的 1 和 0 的模式。通过正常操作使芯片进入该状态，可能就像试图通过随机丢下拼字游戏牌来拼出一个单词一样。有了我们的[扫描链](@article_id:350806)，这就变得微不足道了。我们只需计算出所需的位模式，然后激活扫描模式 (`SE=1`)，并在每个时钟周期移入一位，将该确切的模式移入芯片。我们可以按需设置任何我们想要的场景。这被称为测试周期的**加载阶段** [@problem_id:1958954]。

**可观测性**是能够看到任何内部节点的值。同样，没有扫描，我们就是盲人。一个计算可能在芯片深处出错，但这个错误在到达输出引脚之前可能被掩盖或纠正。我们将永远不知道故障的存在。有了[扫描链](@article_id:350806)，我们获得了完美的视野。这个过程是一个优美的三步舞 [@problem_id:1958954]：
1.  **加载：** 我们移入我们[期望](@article_id:311378)的测试状态。
2.  **捕获：** 我们关闭扫描模式 (`SE=0`) *仅一个时钟周期*。在这一瞬间，电路正常运行。所有的组合逻辑都完成其工作，每个[扫描触发器](@article_id:347533)都从其正常的 `D_in` 输入捕获结果。这一个节拍就拍摄了整个芯片计算状态的快照。
3.  **卸载：** 我们立即重新开启扫描模式 (`SE=1`)，并将链的全部内容通过 `SO` 引脚移出。通过检查这个比特流，我们可以看到存储在每个[触发器](@article_id:353355)中的确切值。

如果我们想知道一个连接到 500 个[触发器](@article_id:353355)链中第 100 个[触发器](@article_id:353355) (`FF_{100}`) 的内部逻辑节点 `N` 的值，我们只需执行捕获周期。`N` 的值现在就在 `FF_{100}` 内部。然后，我们在扫描模式下施加 400 个时钟脉冲。这将捕获的值沿着链条向前推进：从 `FF_{100}` 到 `FF_{101}`，然后是 `FF_{102}`，依此类推，直到 400 次移位后，它从 `SCAN_OUT` 引脚 (`FF_{500}`) 弹出供我们查看 [@problem_id:1958943]。我们让不可见变为可见。

### 巨大回报：驯服时序猛兽

这种完美控制和完美观测的结合带来了深远的影响。它从根本上改变了测试问题的性质。测试**[时序电路](@article_id:346313)**——一个带有存储器的电路——非常困难，因为它的输出不仅取决于当前的输入，还取决于其先前状态的整个历史。

[扫描设计](@article_id:356249)出色地打破了这一障碍。通过允许我们直接设置和观测所有存储单元的状态，它在测试期间有效地消除了问题的“时序”性质。我们不再测试一个有着神秘过去的电路；我们正在测试一个夹在一组输入（我们通过[扫描链](@article_id:350806)控制）和一组输出（我们通过[扫描链](@article_id:350806)观测）之间的简单**[组合逻辑](@article_id:328790)电路**。

这种转变的力量在一个例子中看得最清楚 [@problem_id:1928147]。想象一个 16 位计数器有一个细微的缺陷：一个只有当计数器达到第 13 位和第 7 位都为 '1' 的特定状态（值为 $2^{13} + 2^7 = 8320$）时才会暴露的故障。要按顺序找到这个故障，我们必须将计数器复位到零并让它运行。需要**8,320个[时钟周期](@article_id:345164)**，故障状态才会最终出现。

有了扫描，我们无需等待。我们下达指令。我们希望计数器处于状态 8320 以便看到故障。所以，我们计算出它之前的状态：8319。使用[扫描链](@article_id:350806)，我们将 8319 的 16 位模式直接移入计数器的[触发器](@article_id:353355)中。这需要 16 个[时钟周期](@article_id:345164)。然后，我们切换到正常模式进行一次捕获周期。计数器从 8319 递增到 8320，故障被触发，我们看到了错误。总时间？**17个周期**。

比较一下：8,320 周期对 17 周期。这不仅仅是增量改进；这是一场革命。正是这一点使得测试拥有数十亿晶体管的芯片成为可能。

### 天下没有免费的午餐：可测试性的现实成本

然而，这种不可思议的力量并非没有代价。像任何强大的工程解决方案一样，[扫描设计](@article_id:356249)涉及权衡，并引入了其自身的一系列挑战。

首先是**面积开销**。每个[扫描触发器](@article_id:347533)，由于其额外的多路选择器，比标准[触发器](@article_id:353355)稍大。虽然一个[触发器](@article_id:353355)的差异很小，但当乘以现代芯片上数百万甚至数十亿个[触发器](@article_id:353355)时，硅片面积的累积增加成为实施[扫描设计](@article_id:356249)最显著的成本 [@problem_id:1958940]。更大的面积意味着更大、更昂贵的芯片。

其次是**测试时间开销**。虽然在发现单个故障方面远快于时序测试，但串行移入和移出数据的过程仍然需要时间。对一个长度为 $L$ 的[扫描链](@article_id:350806)电路施加单个[测试向量](@article_id:352095)，需要 $L$ 个周期加载，1 个周期捕获，以及 $L$ 个周期卸载，总共为 $2L+1$ 个周期 [@problem_id:1958954]。对于一个包含 10,000 个[触发器](@article_id:353355)的链，这意味着*每个向量*需要超过 20,000 个时钟周期。由于一次完整的测试可能需要数千个这样的向量，制造测试机上的总测试时间是一个重要的经济因素。

一个更微妙且危险的成本是**功耗**。在正常操作中，电路的活动通常是局部化和相关的。例如，在计数器中，每个时钟节拍只有少数几个位会翻转。但在扫描移位期间，我们可能正在输入一个高活动性的[测试向量](@article_id:352095)，如 `101010...`。在这种最坏情况下，链中几乎*每个*[触发器](@article_id:353355)都可能在*每个*时钟周期改变状态。这可能导致巨大的功率浪涌，远远超过芯片在实际应用中会经历的任何情况 [@problem_id:1958988]。这种功率尖峰可能导致芯片内部电压下降，从而导致错误的测试失败，甚至可能造成永久性损坏。管理这种“测试功耗”是当今 DFT 工程师面临的主要挑战之一。

最后，重要的是要认识到，即使是“全扫描”设计也不是保证 100% 故障检测的灵丹妙药。自动[测试向量](@article_id:352095)生成（ATPG）工具可能仍然报告无法实现完美的覆盖率。这可能由几个现实原因造成 [@problem_id:1958975]。电路可能包含对任何输出都没有影响的**[冗余逻辑](@article_id:342442)**，因此根据定义是不可测试的。它可能包括不属于[同步](@article_id:339180)[扫描链](@article_id:350806)的**异步模块**或特殊存储器。或者，很常见的是，ATPG 工具本身在面对一个计算上天文数字般的搜索空间时，可能干脆**放弃**了几个特别困难的故障。扫描是一个极其强大的工具，但它在物理、逻辑和经济约束的世界中运作。