## 应用与跨学科联系

当我们谈论安全时，我们常常想到堡垒与守卫，锁与钥匙。但在软件世界里，我们的结构不是由石头和钢铁构成，而是由纯粹的信息构成。那么，我们如何才能信任它们？我们如何知道运行在我们手机、汽车或庞大的云服务器农场中的代码，是它本该是的样子，而不是某个恶意的冒名顶替者？答案不是一把单一的锁，而是一个优美、环环相扣的构造：一条伟大的[信任链](@entry_id:747264)，从不可变的物理定律开始，一环一环地锻造，直至最抽象的应用。

这条链的起点不是可以被改变的软件，而是更为顽固的东西：硬件。

### [信任根](@entry_id:754420)：锚定于硬件

想象一下试图在流沙上建造一座堡垒。这是徒劳之举。软件安全也是如此；任何完全建立在软件中的安全系统都可能被一个足够强大的基于软件的攻击者颠覆。基础，我们链条的第一个环节，必须锚定在攻击者无法轻易改变的东西上。在计算领域，这个锚就是硬件。

思考一下计算机的核心——中央处理器（CPU）。即便是CPU的内部软件，即它的“微码”，有时也需要更新以修复错误。CPU供应商如何发布一个补丁而不为恶意更新打开大门？解决方案是直接在硅片中嵌入一个信任锚。CPU的[只读存储器](@entry_id:175074)（ROM）一旦制造就不可更改，可以永久存储供应商的公钥。更新包包含新的微码、一个版本号以及来自供应商的[数字签名](@entry_id:269311)。CPU只有在签名根据其ROM中的密钥验证有效时才会接受更新。但是什么能阻止攻击者重放一个旧的、已签名的更新来重新引入一个已知的漏洞呢？为了防止这种情况，CPU使用了另一个硬件部件：一次性可编程（OTP）熔丝。这些熔丝存储了最后一次接受更新的版本号，并被设计为单调递增的——它们的值可以增加，但绝不能降低。任何版本号低于熔丝中烧录的版本号的更新都会被拒绝，从而提供了强大的反回滚保护 ([@problem_id:3645389])。

同样的原则也延伸到我们周围无数的嵌入式设备，从智能恒温器到医疗仪器。这些设备也必须安全地更新。在这里，一个微小的、专用的安全协处理器——[可信平台模块](@entry_id:756204)（TPM）——通常扮演主角。就像OTP熔丝一样，[TPM](@entry_id:170576)包含一个硬件*单调计数器*，用于存储当前的软件版本。因为这个计数器位于硬件中，并且其接口只允许它被递增，所以它能免受被攻破的[操作系统](@entry_id:752937)的影响。一个暂时控制了设备的攻击者可能会试图安装一个旧版本的固件，但[引导加载程序](@entry_id:746922)在咨询[TPM](@entry_id:170576)不可更改的记录后，会拒绝加载它。任何试图将此版本计数器存储在闪存的简单文件中的做法都是徒劳的，因为一个拥有内核访问权限的攻击者可以轻易地用一个更低的数字覆盖该文件，从而完全破坏反回滚保证 ([@problem_id:3673310])。无论是在CPU还是在嵌入式设备中，教训都是一样的：信任始于软件影响力终结之处。

### [信任链](@entry_id:747264)的延伸：[可信启动](@entry_id:751820)与证明

一旦我们有了可信的硬件根，我们就可以开始构建我们链条的下一个环节。我们需要信任硬件加载的软件，以及*那个*软件加载的软件，以此类推。这是通过一个优美的过程——**[可信启动](@entry_id:751820)**（measured boot）——来完成的。

把它想象成一本不会被篡改的航海日志。当系统启动时，第一个受信任的代码片段（比如锚定在ROM中的[引导加载程序](@entry_id:746922)）不仅仅是加载下一个代码片段（内核）；它首先会为其创建一个密码学哈希——一个唯一的数字指纹。然后它将这个“度量值”记录在TPM内部一组特殊的寄存器中，称为平台配置寄存器（PCRs）。PCRs有一个神奇的特性：它们的值不能被任意设置。人们只能用一个新的度量值来“扩展”它们，这个过程以不可逆的方式将旧的PCR值与新的度量值结合起来。这就创建了一个可防止篡改的日志。如果攻击者改变了内核的哪怕一个比特，它的哈希值就会改变，最终的PCR值也会不同。这个日志是不可伪造的。

这个不可伪造的日志使得一个强大的能力成为可能，即**[远程证明](@entry_id:754241)**。在现代云环境中，一个编排服务如何知道它可以信任一个新启动的虚拟机来处理敏感的秘密？它会挑战该[虚拟机](@entry_id:756518)提供一个“报价”（quote）——它的PCR值，与一个新鲜的随机nonce捆绑在一起，并全部由[TPM](@entry_id:170576)内部一个唯一的、不可伪造的密钥签名。服务接收到这个签名的报告，并将PCR值与预期的“黄金镜像”的已知良好“基线”进行比较。如果它们匹配，服务就知道该[虚拟机](@entry_id:756518)从固件开始，一路都启动了完全正确的软件。它甚至可以验证任何初始配置脚本也经过了度量并且是真实的 ([@problem_id:3673393])。同样的原则也适用于高度专业化的系统，如unikernel的证明，确保不仅其代码，而且其特定的运行时配置在被信任之前也完全符合预期 ([@problem_id:3640309])。

### 保障动态世界：当信任被打破时

我们的系统不是静态的博物馆展品；它们是动态的。我们插入新设备，我们在软件运行时更新它。当世界发生变化，或者更糟的是，当它的一个基本假设被打破时，我们的[信任链](@entry_id:747264)会发生什么？

想象一个场景，一个供应商的主签名密钥被泄露了——这是一次灾难性的供应链攻击。突然之间，他们的[数字签名](@entry_id:269311)变得毫无价值；攻击者现在可以签署恶意的固件，而这些固件将被现场的设备所接受。整个链条会因此粉碎吗？不一定。我们可以转向。我们可以不再信任*签名者*，而是在*内容*本身上建立信任。系统可以维护一个包含所有已知良好固件的密码学哈希值的白名单。当一个新设备插入时，[操作系统](@entry_id:752937)首先计算其固件的哈希值。只有当这个哈希值出现在白名单上时，系统才会继续。

但我们可以做得更好。利用[TPM](@entry_id:170576)，[操作系统](@entry_id:752937)可以将固件度量到PCR中。然后它可以使用一个强大的TPM特性，称为**封存**（sealing）。一个秘密——比如说，一个授予设备访问[系统内存](@entry_id:188091)权限的密码学密钥——可以被“封存”到一组特定的PCR值上。这意味着[TPM](@entry_id:170576)只有在PCRs反映出正确、在白名单上的固件（且没有其他东西）被加载时，才会释放这个秘密。这以[密码学](@entry_id:139166)方式将策略与度量绑定在一起，确保一个恶意的或未知的固件永远不会被赋予造成伤害的能力 ([@problem_id:3687967])。

这种更深层次的验证思想正在推动软件供应链安全的前沿。当实时修补像[操作系统内核](@entry_id:752950)这样的关键软件时，仅仅检查一个签名已经不够了。我们必须确保补丁不会 subtly 地改变行为或削弱安全[不变量](@entry_id:148850)。现代流程现在采用了一系列强大的验证技术——[静态分析](@entry_id:755368)来追踪[控制流](@entry_id:273851)，符号执行来探索程序路径，以及差分模糊测试来比较补丁前后的行为——所有这些都是为了获得最高可能的保证，确保我们软件链中的新环节不仅是真实的，而且是可证明正确和安全的 ([@problem_id:3687990])。

### 来源的普适原则

也许这些原则最令人惊叹的方面是它们的普适性。保障软件供应链的逻辑就是信息完整性本身的逻辑，它出现在最意想不到的地方。

考虑一下合成生物学领域。科学家们设计新颖的[生物电路](@entry_id:272430)和生物体，并用像[合成生物学开放语言](@entry_id:196757)（SBOL）这样的数字格式来表示他们的设计。这些数字设计是生命的“源代码”。它们在存储库中共享、被修改，并用于合成实际的DNA。一个下载设计方案的科学家如何能确定这是其声称作者的原始、真实作品，而没有被一个被攻破的存储库操作者恶意篡改？

解决方案与软件的解决方案相同。首先，因为不同的软件可能会以略微不同的方式编写相同的设计（例如，XML文件中的不同间距），需要一个**规范化**函数来产生一个标准的、逐字节一致的表示。其次，对这个规范化形式计算一个**密码学哈希**，为[生物设计](@entry_id:162951)创建一个唯一的、可防止篡改的标识符。最后，创建该设计的科学家使用他们的私钥对该哈希创建一个**[数字签名](@entry_id:269311)**，通常还包括设计来源图的哈希。这将*什么*（设计）、*谁*（作者）和*如何*（派生历史）绑定到一个单一的、不可伪造的数字断言中。用于验证笔记本电脑固件更新的那些完全相同的密码学工具，也被用来保证合成微生物设计的完整性和来源 ([@problem_id:2776485])。

### [信任链](@entry_id:747264)的最深层环节

让我们拉动信任的线索，看看它能走多远。我们讨论了信任软件，但构建这些软件的工具呢？我们如何信任我们的编译器？这引出了Ken Thompson著名的“信任之信”悖论：一个恶意的编译器可以被设计成产生其他程序的特洛伊木马版本（包括它自己的新版本），这种篡改在源代码中是看不见的。

解决这个深远的自举问题的方案不是一个单一的技术修复，而是一个流程上的激进转变：**去中心化、多样化、可复现的构建**。社区不再信任一个编译器，而是让多个独立的团队从完全相同的源代码构建编译器的每个阶段。如果构建是可[复性](@entry_id:162752)的——这是一个困难但可实现的工程壮举——那么所有诚实的团队都应该产生逐比特相同的二进制文件。只有在足够多的独立构建者以密码学方式证明产生了完全相同的产物时，最终的编译器才被信任。来源通过使用[默克尔树](@entry_id:634974)来追踪，它将每个阶段的输出与前一阶段的输入联系起来。这创建了一个[分布](@entry_id:182848)式的信任网络，它对[单点故障](@entry_id:267509)具有弹性，无需诉诸中央权威就解决了自举问题 ([@problem_id:3634668])。

那么云呢？在云中，硬件本身就是一个抽象。我们如何给每个虚拟机自己的[信任根](@entry_id:754420)？解决方案是我们原则的又一次优雅分层。虚拟机监控器可以为每个[虚拟机](@entry_id:756518)提供一个基于软件的**虚拟[TPM](@entry_id:170576)（v[TPM](@entry_id:170576)）**。这个vTPM对客户[操作系统](@entry_id:752937)来说，看起来和感觉上都像一个真正的TPM。但它的状态——它的虚拟密钥和秘密——本身是被宿主机上的*物理*TPM加密或“封存”的。这意味着vTPM的秘密只有在宿主虚拟机监控器本身处于一个已知的、经过度量的良好状态时才能被解封。它优美地将硬件[信任根](@entry_id:754420)扩展到了虚拟领域，使得多租户云中的每个租户都能锻造自己的安全[信任链](@entry_id:747264) ([@problem_id:3648952])。

从一个烧录在硅片中的签名开始，我们构建了一条可以扩展、验证甚至修复的[信任链](@entry_id:747264)。它延伸到云端，跨越科学学科，并深入到我们创造数字世界的最根本基础。这条由[密码学](@entry_id:139166)哈希和签名这些简单而强大的思想构建而成的活的链条，是我们信息时代安全的支柱。