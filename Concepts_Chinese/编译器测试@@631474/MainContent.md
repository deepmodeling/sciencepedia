## 引言
编译器是迄今为止被创造出来的最复杂的软件之一，它扮演着一个精密的翻译角色，将人类可读的源[代码转换](@entry_id:747446)成机器的原生语言。但这种复杂性也带来了出错的风险。我们如何能相信编译器的翻译完美地保留了原始程序的逻辑和意图？回答这个问题极其困难，因为对于任何非平凡的程序，我们都缺少一个明确的“预言机”（oracle）来告诉我们正确的输出应该是什么。程序本身往往就是其最精确的规约。

本文深入探讨了编译器测试这一巧妙的领域，该领域已经发展出强大的技术来应对这一挑战。您将了解到测试人员是如何在世界上最先进的编译器中发现微小错误的，他们不是通过问“这个结果正确吗？”而是通过提出更易于回答的问题。我们将首先探讨使现代编译器测试成为可能的基本思想。《原理与机制》一章将介绍[差分测试](@entry_id:748403)（解决预言机问题的巧妙方案），解释[未定义行为](@entry_id:756299)带来的巨大挑战，并详细介绍模糊测试和蜕变测试等用于生成有效测试用例的自动化方法。随后，《应用与跨学科联系》一章将展示这些原理在实践中如何应用，以验证编译器是否遵守了其与硬件、语言标准以及它所帮助构建的数字世界的安全性之间的关键契约。

## 原理与机制

想象一下，您雇佣了两位专家级翻译，将一份复杂的法律文件从英文翻译成法文。您会如何检查他们的工作？您可以雇佣第三位翻译来检查前两位，但谁又来检查第三位呢？一个更实际的方法或许是直接比较这两份法文译稿。如果它们在任何有意义的方面存在差异，您就知道至少其中一位犯了错。您并没有在绝对意义上证明哪一份是“正确”的，但您成功地发现了一个错误。

这正是编译器测试的核心所在。编译器是一个翻译器，将人类可读的源[代码转换](@entry_id:747446)成机器的原生语言。询问“这个编译器的翻译是否正确？”通常是一个极其困难的问题。我们正在编译的程序本身可能就是我们想要执行任务的最精确规约！因此，我们转而提出一个更易于处理的问题：“两种不同的编译器，或同一编译器的两个不同版本，所产生的翻译在行为上是否完全相同？”这个强大的思想被称为**[差分测试](@entry_id:748403)**（differential testing）。

### 预言机问题与差分解决方案

在测试领域，**预言机**（oracle）是一种能为任何给定输入提供“正确”答案的机制。对于编译器而言，一个完美的预言机应该能对任何源程序 $P$ 和输入 $x$，准确地告诉我们一个正确编译的程序应有的可观察行为是什么。对于简单的程序，我们或许可以充当预言机，手动计算答案。但对于天气模拟或数据库引擎这样的程序，这是不可能的。程序*就是*它自身的规约。

[差分测试](@entry_id:748403)巧妙地回避了“预言机问题”。我们不使用一个编译器和一个预言机，而是使用两个编译器 $C_1$ 和 $C_2$。我们给它们相同的源程序 $P$。它们产生两个不同的可执行二进制文件 $B_1$ 和 $B_2$。然后，我们在相同的受控环境中，用相同的输入 $x$ 运行这两个二[进制](@entry_id:634389)文件，并比较它们的可观察行为——比如程序的退出码、屏幕打印内容以及写入的任何文件。如果 $B_1$ 和 $B_2$ 的行为不同，我们就发现了一个差异。假设源程序 $P$ 是行为良好的，这个差异就表明至少有一个编译器存在错误 [@problem_id:3634594]。我们已经让编译器互为对方的预言机。

这听起来很简单，但在“假设源程序是行为良好的”这句话背后，隐藏着巨大的复杂性鸿沟。

### [未定义行为](@entry_id:756299)的幽灵

像 C 和 C++ 这样的编程语言由一个标准来约束，这个标准就像程序员和编译器之间的一份合同。这份合同充满了规则，但也包含一些条款，其大意是：“如果你做了 X，那么一切后果自负。”这就是**[未定义行为](@entry_id:756299)（UB）**的领域。一个经典的例子是带符号[整数溢出](@entry_id:634412)：将两个大的正 `int` 相加，结果回绕成一个负数。当一个程序触发了 UB，标准对编译器*没有任何要求*。程序可能会崩溃，可能会产生无意义的结果，可能会格式化你的硬盘，也可能看起来工作得很好。

这对[差分测试](@entry_id:748403)来说是一个巨大的问题。假设我们找到了一个程序，编译器 $C_1$ 和 $C_2$ 对它产生了不同的输出。这是编译器错误吗？不一定。如果程序调用了 UB，那么两个编译器在技术上都符合标准。一个编译器可能产生整数 $10$，另一个可能产生 $11$；两者都是[未定义行为](@entry_id:756299)的有效结果 [@problem_id:3643046]。我们的错误报告将是一个误报。

要构建一个健壮的测试系统，我们必须首先过滤掉这些“无效的”测试程序。现代的解决方案是使用称为**清理器**（sanitizer）的工具。我们可以用一个可信的编译器来编译我们的测试程序，并启用像 AddressSanitizer (ASan) 这样的工具来检测内存错误，以及 UndefinedBehaviorSanitizer (UBSan) 来检测像[整数溢出](@entry_id:634412)这样的多种 UB。如果一个程序在启用这些清理器的情况下运行并报告了问题，我们就将其从测试套件中丢弃。只有“干净的”程序才会被传递到[差分测试](@entry_id:748403)阶段。这确保了我们发现的任何差异都更有可能是真正的编译器错误 [@problem_id:3634594] [@problem_id:3643046]。

### 打造更好的测试器

确立了我们的核心原则后，接下来的问题是：我们从哪里获得数以百万计的测试程序来发现微小的错误？手动编写它们是不切实际的。现代的方法是**模糊测试**（fuzzing），即自动生成测试输入。一个模糊测试器可能会随机组合代码片段，创造出一个庞大而混乱的测试程序“动物园”，然后用它们来轰炸我们的编译器。

但我们可以比纯粹的随机混乱更聪明。一种优美而强大的技术是**蜕变测试**（metamorphic testing）。其思想是测试数学或逻辑关系（即*蜕变关系*）的保持性，而无需知道具体的正确输出。

考虑简单的算术表达式 $(a + b) \cdot c$。另一个不同的表达式是 $a + (b \cdot c)$。我们从基础代数中知道，这两个表达式通常不相等。然而，它们在特定条件下*是*相等的：当且仅当 $a=0$ 或 $c=1$ 时。这给了我们一个微小而完美的预言机！我们可以编写一个程序，计算这两个表达式并检查其相等性。然后，我们检查 $a$ 和 $c$ 的条件。对于一个正确的编译器，程序中观察到的相等性必须与我们从代数规则中预测的相等性完全匹配。如果它们不匹配，那么编译器就违反了算术规则，例如，尽管有括号，它还是错误地重新组合了运算 [@problem_id:3637920]。

这个蜕变原则的用途极其广泛。我们可以用它来测试语言标准中无数个隐晦的角落：
- **整数提升**：C 标准规定，当您将两个 `char` 变量相加时，它们首先被提升为 `int`。我们可以测试 C 语言加法的结果是否与提升后整数值的数学加法结果相匹配 [@problem_id:3637901]。
- **除法规则**：一种语言应如何处理负数除法，比如 $-3/2$？一些语言向零取整（得到 $-1$），而另一些则向负无穷取整（得到 $-2$）。我们可以实现这两种有效的数学规则，并测试编译器是否与其中之一保持一致 [@problem_id:3637968]。
- **带符号的零**：[IEEE 754](@entry_id:138908) [浮点](@entry_id:749453)标准同时包含了 $+0$ 和 $-0$。它们比较时相等，但具有不同的符号，这会影响像除法这样的运算：$1/+0 = +\infty$ 而 $1/-0 = -\infty$。我们可以编写测试来验证这些具体且通常很棘手的规则是否被遵守 [@problem_id:3637938]。
- **严格[别名](@entry_id:146322)**：这是 C 语言中一个微妙但关键的优化规则。编译器可以假设指向不同类型的指针（如 `float*` 和 `int*`）不会指向同一内存位置。我们可以通过创建一个 `float` 变量，然后使用到 `int*` 的转换将一个整数字位模式写入其内存来测试这一点。一个假设了严格别名的编译器可能会忽略这次写入，因为它认为这不可能影响到该 `float` 变量。我们可以将这种“不安全”的方法与使用 `memcpy` 的“安全”方法进行比较，看编译器的优化是否改变了行为 [@problem_id:3637917]。这是在*单个程序内部*进行的[差分测试](@entry_id:748403)。

### 深入机器内部：测试编译器核心

编译器不是一个单一的整体。它是一条流水线。**前端**解析源代码（如 C 语言）并将其翻译成一种**[中间表示](@entry_id:750746)（IR）**。这种 IR 是一种更通用、更抽象的语言。然后，**后端**接收这个 IR，执行一系列优化，并最终为特定处理器生成二[进制](@entry_id:634389)机器码。

这种结构使我们的测试更具策略性。我们不仅可以测试从源代码到二[进制](@entry_id:634389)的完[整流](@entry_id:197363)水线，还可以创建在不同层次上操作的模糊测试器 [@problem_id:3678658]。
- 一个**源码级模糊测试器**生成 C 代码。如果它发现一个错误，问题可能出在编译器的任何地方。
- 一个**IR级模糊测试器**直接生成 IR 代码并将其提供给后端。如果这发现一个错误，我们就将问题隔离到了后端及其优化阶段。
- 一个**二[进制](@entry_id:634389)级模糊测试器**接收一个已编译的程序，并直接改变其机器码指令。

通过在这些不同阶段进行[差分测试](@entry_id:748403)，我们不仅可以发现错误，还可以确定错误*位于*编译器复杂机制中的哪个位置。这对开发者来说是无价的。这种分层方法也为更强大的技术打开了大门。在 IR 层面，程序的逻辑以更形式化的方式表示，有时可以利用形式化验证中的数学方法来*证明*优化后的 IR 与原始 IR 是等价的。像**[互模拟](@entry_id:156097)**（bisimulation）这样的技术可以构建一个形式化的见证，保证等价性，提供任何数量的测试都无法达到的确定性水平 [@problem_id:3621395]。

### 瞥见无限

我们已经构建了一个强大的工具包来寻找编译器错误。这引出了一个最终且深刻的问题：我们能否构建终极测试工具？我们能否编写一个程序，接收任意两个编译器 $C_1$ 和 $C_2$，并绝对确定地告诉我们是否*存在任何程序和输入*会导致它们产生分歧？

这是一个关于计算基本极限的问题。让我们正式地表述它。考虑所有存在分歧的程序对 $\langle p, q \rangle$ 的集合，或称“语言”。我们称这个语言为 $L_{\neq}$。
$$L_{\neq} = \{ \langle p, q \rangle \mid \exists x \text{ such that } \varphi_{p}(x) \neq \varphi_{q}(x) \}$$
我们的模糊测试和测试工具，本质上是在试图确定给定的一对已编译程序是否属于这个集合。

计算机科学告诉我们，$L_{\neq}$ 是**递归可枚举的**。这是一种花哨的说法，意思是我们可以编写一个识别器——一个程序，如果存在分歧，它最终会找到它并停机，大喊“不匹配！”这正是一个模糊测试器所做的事情：它系统地搜索无限的输入空间，如果它找到了一个导致错误的“见证”输入 $x$，它就成功了 [@problem_id:3666180]。

但这个问题是**可判定的**吗？我们的终极工具能否*总是*停机，要么找到一个错误，要么明确报告“永远不会发生[分歧](@entry_id:193119)”？答案或许令人惊讶，是否定的。确定 $L_{\neq}$ 成员资格的问题是不可判定的。可以证明，如果我们能解决这个问题，我们也能解决 [Alan Turing](@entry_id:275829) 著名的[停机问题](@entry_id:265241)，而我们知道那是不可能的。

这是一个优美而又令人谦卑的领悟。我们构建更好编译器的实际工程追求，正面撞上了支配所有计算的相同理论极限。编译器测试是在寻找一个见证。我们可以设计出越来越巧妙的方法来引导这个搜索，但我们永远无法仅通过测试来证明一个错误的不存在。这个搜索是，并且将永远是，潜在无限的。

