## 引言
在[数字电子学](@article_id:332781)的世界里，挑战始终在于如何将抽象的逻辑思想转化为物理上高效的硬件。虽然任何数字函数都可以用基本门电路构建，但这种方法通常会导致设计复杂且笨重。这就提出了一个关键问题：是否存在一种更系统、更灵活的方式来创建定制逻辑电路？本文通过探索简单[可编程逻辑器件](@article_id:357853)家族来解决这一问题。文章深入探讨了使这些组件成为可能的基础概念，从通用的乘积和结构到定义它们的架构权衡。第一章“原理与机制”将解构 PAL 和 GAL 等器件的内部工作原理，揭示它们的编程方式以及塑造其演变的内在约束。随后，“应用与跨学科联系”将展示这项技术的应用，如何将数字“[胶合逻辑](@article_id:351546)”转变为智能状态机，并揭示逻辑、存储器和工程创造力之间的深层关系。

## 原理与机制

要真正理解像[通用阵列逻辑](@article_id:343964) (GAL) 这样器件的精妙之处，我们必须首先退后一步，问一个基本问题：数字逻辑函数到底*是*什么？从本质上讲，任何复杂的逻辑陈述，无论多么复杂，都可以归结为一种标准的、通用的形式。这就是[布尔代数](@article_id:323168)的魔力，也是所有[可编程逻辑](@article_id:343432)的基石。

### 通用蓝图：乘积和

想象一下，您正在为一台工业冲压机设计一个安全系统。只有当工件就位 ($A=1$) 并且安全笼已锁定 ($B=1$) 或手动超驰已激活 ($C=1$) 时，[冲压](@article_id:373828)机才应运行 ($F=1$)。我们可以将其写成一个简洁的表达式：$F = A \cdot (B + C)$。

虽然这看起来很简单，但对于大规模生产的硬件来说，它并不是最方便的形式。这时，借助[分配律](@article_id:304514)进行一些代数变换，揭示了一个更深层的结构：

$$F = A \cdot (B + C) = (A \cdot B) + (A \cdot C)$$

仔细观察我们现在得到的结果。该函数是几个“乘积”（逻辑与）的“和”（逻辑或）。这被称为**乘积和 (SOP)** 形式。事实证明，*任何*组合逻辑函数都可以用这种方式表示。这是一个极好的统一原则！这意味着我们可以设计一个通用的硬件架构——一层与门用来创建乘积，后面跟着一层[或门](@article_id:347862)来进行求和——原则上，这个架构可以创建我们想要的任何逻辑函数。这种两级**与或**结构是整个简单[可编程逻辑器件](@article_id:357853)家族的基本蓝图 [@problem_id:1954538]。

### 逻辑器件家族：固定平面与可编程平面

“可编程性”的概念归结为我们设计人员可以改变这个与或结构的哪些部分。可以把与平面和或平面想象成两层电气连接的网格。“编程”就是在该网格的[交叉](@article_id:315017)点上建立或断开连接的行为。不同的器件在你能接触和不能接触的部分提供了不同的权衡。

*   **[可编程只读存储器](@article_id:353879) (PROM)：** 在 PROM 中，与平面是**固定**的。它在工厂设计时就生成了其输入的所有可能乘积项（这些被称为[最小项](@article_id:357164)）。这就像一本包含所有可能单词的词典。或平面是**可编程**的，允许您选择要为输出函数“求和”的[最小项](@article_id:357164)。它功能强大，但通常很浪费，因为您很少需要每个可能的乘积项。

*   **[可编程逻辑阵列](@article_id:348093) (PLA)：** PLA 是灵活性的巅峰。与平面*和*或平面都是**可编程**的。您可以精确定义要创建哪些乘积项，并且可以精确定义它们如何相加以创建您的输出。这提供了最大的自由度，但也有代价。由于有两个完全可编程的平面，可编程连接点（历史上是您会“熔断”的微小熔丝）的数量变得巨大，使得器件更复杂、更昂贵，并且可能更慢 [@problem_id:1955155]。对或平面进行编程的灵活性意味着，与实现相同逻辑的更受约束的器件相比，PLA 需要更多的可编程连接 [@problem_id:1954918]。

*   **[可编程阵列逻辑](@article_id:351927) (PAL)：** PAL 做出了一个巧妙的折中。它有一个**可编程的与平面**，就像 PLA 一样，因此您可以创建自定义的乘积项。然而，它的或平面是**固定**的 [@problem_id:1954574]。输出端的每个或门都永久连接到特定且数量有限的[与门](@article_id:345607)。您可以选择要制作*什么*乘积项，但不能选择为给定输出求和*多少*个。这种简化使得 PAL 比 PLA 更便宜、更快、更容易使用，并迅速主导了该领域。

### 网格上的生命：编程及其风险

让我们放大看一下 PAL。想象一个网格，其中垂直线承载输入信号（信号及其反相，如 $A$ 和 $\overline{A}$)，水平线引入[与门](@article_id:345607)。要创建乘积项 $A'B$，您只需对器件进行编程，在一个特定的与门上，保持 $\overline{A}$ 线和 $B$ 线[交叉](@article_id:315017)处的连接完好，同时熔断该门的所有其他输入的熔丝 [@problem_id:1954548]。这些与门的输出然后流入固定的或门。这是将布尔方程直接优雅地转换为物理电路的过程。

但这种优雅的简单性也伴随着尖锐的问题。“固定的或平面”不仅仅是一个特性；它是一个具有深远影响的基本约束。

#### 固定[或门](@article_id:347862)的制约

最明显的限制是乘积项的数量。如果一个 PAL 的数据手册上说每个输出[或门](@article_id:347862)的[扇入](@article_id:344674)为二，这意味着您最多只能为该输出求和两个乘积项。如果您的函数，即使在其最简形式下，也需要三个乘积项，那您就束手无策了。例如，函数 $F(A,B,C) = \sum m(1, 2, 7)$ 化简为 $F = \overline{A}\overline{B}C + \overline{A}B\overline{C} + ABC$。这个表达式需要三个乘积项。无论您多聪明，都无法在一个只能接受两个乘积项的 PAL 输出上实现它 [@problem_id:1954567]。硬件从根本上决定了数学能做什么和不能做什么 [@problem_id:1955188]。

一个更微妙和危险的风险涉及时间。在实际电路中，信号不是瞬间传播的。当一个输入改变时，随着变化通过不同的逻辑门传播，会有一个微小的“竞争”。考虑函数 $F = AB + \overline{A}C$。如果输入从 $(A,B,C)=(0,1,1)$ 变为 $(1,1,1)$，输出应该保持为1。但是，当 $A$ 信号翻转时，$\overline{A}C$ 项可能会在 $AB$ 项有机会开启之前关闭。在纳秒级别的时间内，输出可能会下降到0，产生一个**[静态1冒险](@article_id:324714)**——一个毛刺。标准的修复方法是在表达式中添加一个冗余的“共识项”（在本例中为 $BC$）。这个项充当安全网，在过渡期间保持输出为高电平。

但是，如果您的 PAL 的[或门](@article_id:347862)[扇入](@article_id:344674)是二呢？最小表达式 $AB + \overline{A}C$ 已经使用了两个可用的位置。您可以在可编程的与平面中生成共识项 $BC$，但没有办法将其连接到或门。固定或平面的架构约束使您无法实现一个可靠、无冒险的电路 [@problem_id:1941616]。

最后，固定的或平面是低效的。想象一下您需要生成两个输出函数，$F_1 = (\overline{X}YZ) + (A\overline{B})$ 和 $F_2 = (\overline{X}YZ) + (\overline{C}D)$。乘积项 $(\overline{X}YZ)$ 两者都需要。在 PAL 中，由于一个与门的输出是硬连线到一个单一的[或门](@article_id:347862)，您无法共享它。您必须在与平面的两个不同位置创建完全相同的乘积项，从而浪费资源 [@problem_id:1954571]。这就像有两个厨师都需要切碎的洋葱，但他们不共享一碗，而是各自坚持自己切。

### 通用革命：更智能，而非更困难

这些局限性为下一次进化步骤——**[通用阵列逻辑](@article_id:343964) (GAL)** 器件——的出现奠定了基础。

第一个，也是最明显的改进是**可重编程性**。经典的 PAL 是**一次性可编程 (OTP)** 的；它们的熔丝被物理熔断，这是一种永久性的改变。如果您犯了错误，就得把芯片扔进垃圾桶。相比之下，GAL 使用电可擦除 ([EEPROM](@article_id:355199)) 技术。它们可以被编程、擦除和重编程数千次。这将设计过程从用永久墨水书写的高风险行为转变为用铅笔书写的宽容过程，极大地提高了原型设计和调试的效率 [@problem_id:1955198]。

但 GAL 的真正革命在于[或门](@article_id:347862)*之后*发生的事情。每个或门不再连接到一个简单的输出引脚，而是馈入一个称为**[输出逻辑宏单元](@article_id:356906) (OLMC)** 的复杂结构。这才是真正使逻辑“通用”的原因。OLMC 是数字功能的瑞士军刀，赋予设计者前所未有的灵活性 [@problem_id:1955142]。其关键特性包括：

*   **可编程极性：** OLMC 可以被编程为直接通过或门的输出，或将其反相。这意味着，如果合成您[期望](@article_id:311378)函数的*[反函数](@article_id:639581)*更有效，您可以这样做，然后在最后免费地将其翻转回来。

*   **寄存器或组合输出：** OLMC 包含一个**[触发器](@article_id:353355)**（一个1位存储元件）。您可以将输出编程为纯组合输出（它随输入变化而立即变化）或**寄存器输出**（它仅在时钟节拍时变化）。这是一个巨大的飞跃。这意味着同一个器件现在不仅可以实现简单的逻辑，还可以实现**[时序电路](@article_id:346313)**，如计数器和状态机，而这些是大多数数字系统的大脑。

*   **[三态输出](@article_id:343802)控制：** 输出驱动器可以被编程为处于**[高阻态](@article_id:343266)**——与输出引脚电气断开。这允许多个设备共享一根公共[线或](@article_id:349408)总线而不会相互干扰。这对于构建任何现代计算机系统都是必不可少的。

*   **反馈路径：** OLMC 的输出（在寄存器之前或之后）可以被反馈回可编程与平面，作为一个新的输入。这种“闭环”能力是构建复杂[时序逻辑](@article_id:326113)的最后一块拼图，其中电路的下一个状态取决于其当前状态。

通过结合这些特性，一个单一的 GAL 芯片可以被配置为简单的[逻辑门](@article_id:302575)、[同步计数器](@article_id:350106)、双向数据端口或复杂的[状态机](@article_id:350510)——这是其 PAL 前辈只能梦想的通用性水平。GAL 不仅仅是一个可重编程的 PAL；它是一个从根本上更智能、更有能力的构建模块，为后来更复杂的器件铺平了道路。