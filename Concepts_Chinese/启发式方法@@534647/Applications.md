## 应用与跨学科联系

我们花了一些时间来欣赏启发式方法的形式化机制、其内在逻辑和巧妙设计。但是，作坊里的机器只是一个稀奇玩意儿；它的真正价值在于它在现实世界中所做的工作。所以现在，让我们离开纯粹的理论世界，去看看这些思想在何处大显身手。当一个问题太大、太纠结或计算上太庞大，以至于无法通过完美的、穷举的计算来解决时，会发生什么？当可能答案的数量超过宇宙中的原子数量时，会发生什么？

自然界，以及我们这些试图理解和组织世界的聪明人类，都偶然发现了一个深刻的真理：一个优秀的、及时的答案往往比一个来得太晚或根本来不了的完美答案有价值得多。这就是启发式方法的世界。它不是一个马虎思维的领域，而是一个充满深刻洞见的领域，在这里我们利用对问题结构的知识来做出精彩的、有根据的猜测。让我们来游览一下这个领域。

### 可能性的艺术：工厂与截止日期世界中的启发式方法

我们的第一站是繁忙的[运筹学](@article_id:305959)世界——高效运营的科学。想象你负责一个庞大的物[流网络](@article_id:326383)。你有生产商品的工厂和需要它们仓库。你的工作是决定哪个工厂应该向哪个仓库运送多少货物，以最小化总[运输成本](@article_id:338297)。这是经典的“[运输问题](@article_id:297185)”。事实证明，这个问题恰好是“温和”问题之一；只要有足够的计算时间，我们就可以使用[线性规划](@article_id:298637)等方法找到绝对的、唯一的最佳解。

然而，即使在这里，启发式方法也扮演着至关重要的角色。精确[算法](@article_id:331821)通常需要一个起点，一个初始的“可行”计划，然后它们会迭代地改进这个计划。一个愚蠢的起始计划可能会导致[算法](@article_id:331821)走上一条漫长曲折的道路才能达到最优。而一个聪明的起始计划可以使它瞬间到达。这就是初始化启发式方法发挥作用的地方[@problem_id:3138271]。一个简单的、“天真”的[启发式方法](@article_id:642196)可能是*[西北角法](@article_id:641968)则*，它就像听起来一样缺乏想象力：从你的运输分类账的左上角开始，一个一个地填写订单，完全不考虑成本。它很快，但由此产生的计划通常贵得离谱。

一个稍微智能一点的方法是*[最小成本法](@article_id:639165)*，它有一个简单的贪心思想：在地图上找到任何可用的最便宜的运输路线，并尽可能多地沿着这条路线发送货物。重复此过程，直到所有订单都得到满足。这要好一些。但一个更复杂的[启发式方法](@article_id:642196)，如*[Vogel近似法](@article_id:638341)*，体现了一种惊人的人性化品质：后悔。对于每个工厂，它会考察其最便宜路线和次便宜路线之间的成本差异。这个差异是一种“惩罚”或“后悔”——如果你不能使用你的最佳选择，你将招致的额外成本。该[启发式方法](@article_id:642196)优先考虑具有最高后悔值的工厂或仓库，试图用其最便宜的路线来服务它，以避免以后支付那笔大的罚金。正是这种前瞻性，这种对未来困难选择的预判，使它成为一个“更聪明”的猜测者，常常能产生一个非常接近完美解的初始计划。

但许多现实世界的问题并不那么温和。考虑一个现代工厂，有几台多功能机器和一份待完成的工作清单，每项工作都有自己的处理时间和严格的截止日期。你的目标是在这些机器上安排这些工作，以最小化任何单个工作的最差延迟。这个问题与[运输问题](@article_id:297185)不同，它在根本上是困难的。可能的时间表数量随着工作数量的增加而呈天文数字般增长。尝试每一个方案都不可行。我们*必须*使用[启发式方法](@article_id:642196)[@problem_id:3252903]。

我们应该采取什么样的策略呢？我们可以尝试一个简单的优先规则，这是单机调度有效方法的扩展：总是处理*最早到期日（EDD）*的工作。这是一个合理的贪心方法。或者我们可以更动态，使用像*最小松弛时间（LST）*这样的规则。在任何一台机器空闲的时刻，我们为每个等待的工作计算“松弛时间”：其截止日期减去当前时间再减去它需要的运行时间。松弛时间最少的工作是约束最紧的，也就是回旋余地最小的工作。我们优先处理那个。

一个完全不同的哲学是*[局部搜索](@article_id:640744)*。你从一个相当好的时间表开始（也许是根据EDD规则得出的），然后你尝试进行小的、增量的改进。“如果我只是交换队列中这两个相邻的工作会怎样？这会使结果更好吗？”你不断进行这些微小的、有益的交换，直到没有这样的交换能改善情况。你可能没有达到地球上绝对最好的可能时间表，但你已经找到了一个处于“局部最优”的时间表——没有小的改变可以使它变得更好。这相当于计算上的爬山，直到你到达一个山峰，并希望它是山脉中最高的山峰之一。

### 驯服数据洪流：[生物信息学](@article_id:307177)中的[启发式方法](@article_id:642196)

工业界的挑战源于组合选择，当我们转向下一个目的地——现代生物学世界时，这些挑战显得几乎有些古雅。在这里，困难不仅在于选择的数量，还在于数据本身惊人的、几乎不可思议的规模。

考虑在人类基因组中寻找一个特定基因的任务。从生物学上讲，这通常可以归结为一个计算问题：将一个已知的“查询”DNA序列（比如几千个字母长）与整个人类基因组“数据库”（三十亿个字母长）进行比对。寻找最佳[局部比对](@article_id:344345)的黄金标准[算法](@article_id:331821)是著名的[Smith-Waterman算法](@article_id:357875)。它保证能找到最优匹配。而且，它是一个多项式时间算法，其运行时间与两个序列长度$m$和$n$的乘积成正比，即$O(mn)$。很长一段时间里，计算机科学家认为这样的多项式时间算法是“好的”、“可处理的”。

但让我们做一个粗略的计算[@problem_id:3216003]。对于长度为$m = 10^3$的查询和长度为$n = 3 \times 10^9$的基因组，计算量大约是$3 \times 10^{12}$。一台快速计算机每秒可能执行五十亿次这样的计算，导致运行时间大约为100分钟。这很慢，但也许可以忍受。然而，真正的杀手是内存。为了重构最佳比对，该[算法](@article_id:331821)需要存储其整个计算表。在我们的例子中，这将需要大约6*太字节*的内存——远远超过即使是高端科研工作站所拥有的内存。“可处理的”[算法](@article_id:331821)在实践中是完全不可能的。

于是[启发式方法](@article_id:642196)登场了。最著名的是你可能听说过的一个工具：BLAST（基础[局部比对](@article_id:344345)搜索工具）。BLAST基于一个 brilliantly simple 的启发式原则，可以称之为“种子和扩展”。它不是比较所有东西，而是首先在查询和数据库之间寻找非常短的、相同或近乎相同的匹配。这些就是“种子”。这就像在两本巨著之间寻找一个共同的、拼写完全正确的11个字母的单词。大部分书页不会有这些匹配的单词。但当它们出现时，这是一个有希望的迹象。然后，BLAST将其所有的计算火力集中在从这些有希望的种子上向外扩展比对，而忽略基因组中广阔的、没有希望的沙漠地带。它不保证能找到[Smith-Waterman算法](@article_id:357875)会找到的数学上最优的比对，但它比后者快数千倍，需要的内存也少得多，并且在实践中，它几乎总能找到具有生物学意义的匹配。它将生物信息学从一种理论上的可能性转变为成千上万科学家的日常现实。

[启发式方法](@article_id:642196)在构建遗传图谱中也至关重要[@problem_id:2817672]。想象沿一条[染色体](@article_id:340234)有一组[遗传标记](@article_id:381124)。我们可以通过观察任意两个标记共同遗传的频率来估计它们之间的“距离”。挑战在于找出它们正确的线性顺序。这个问题恰好是计算机科学中最著名的难题之一——[旅行商问题](@article_id:332069)（TSP）的完美类比。找到正确的标记顺序就像找到一个推销员访问一组城市可以采取的最短路线。可能的路线（顺序）数量以阶乘$n!$增长，这个数字只要有几十个“城市”就会变得大得不可思议。

因此，遗传学家依赖于受数十年TSP研究启发的[启发式方法](@article_id:642196)。他们可能会贪婪地构建一个顺序（一种*最近邻*方法），或者他们可能会采用一个现有的顺序，并尝试用[局部搜索](@article_id:640744)来改进它，交换标记对以观察图谱是否变得更好。由于生物数据充满噪声，这个问题变得更加困难。基因分型错误会造成一个“崎岖的适应度景观”，有许多局部最优解——许多看起来合理但并非真实的图谱。这要求使用更复杂的启发式方法，比如*[模拟退火](@article_id:305364)*，它可以“摇动”搜索过程以跳出这些局部陷阱，探索更多的景观。而且，通过理解似然计算本身的结构，可以在提出交换时进行局部更新而不是完全重新计算，从而使过程变得更快[@problem_id:2817698]。

### 智能的前沿：逻辑学与人工智能中的启发式方法

我们的最后一站是抽象但强大的领域：人工智能。在这里，搜索的不是时间表或序列，而常常是更短暂的东西：一个计划、一个策略或一个逻辑证明。

考虑[自动定理证明](@article_id:315060)的挑战：教机器进行推理[@problem_id:2979701]。你从一组公理（假定为真的事实）和一个你希望证明的猜想开始。机器的工作是从公理出发，找到一条通向猜想的逻辑推导链。问题在于，所有可能的推[导集](@article_id:357409)合通常是无限的。如果你的逻辑语言中有函数（比如后继函数“s(x)”），你可以创造无限多的项：$x, s(x), s(s(x)), \dots$。搜索空间是无界的。

纯粹的暴力方法将是无望的。因此，证明器依赖于一套丰富的启发式方法来指导搜索。其中最基本的一种是*支持集策略*。它将初始事实分成两堆：一般的公理，假定它们是一致的；以及来自你要证明的东西的*否定*的事实（因为归结证明是一种反证法）。启发式规则很简单：不要浪费时间通过组合两个一般公理来进行推导。任何推导的父节点中至少有一个必须来自“支持集”——即猜想否定的后代。这个简单的规则极大地将搜索集中在与目标相关的推导上，剪除了大量不相关的搜索树分支。

这种利用巧妙规则在不可能大的空间中导航的思想也是现代机器学习的核心。今天的AI模型，如驱动图像识别和[自然语言处理](@article_id:333975)的[深度神经网络](@article_id:640465)，是包含数十亿参数的庞然大物。一个紧迫的问题是：我们能否在不破坏其性能的情况下使它们更小、更快、更节能？这就是*[网络剪枝](@article_id:640263)*的问题。

解决这个问题的一种方式是将其类比为另一个经典的难题：*0/1背包问题*[@problem_id:3202425]。想象你是一个准备旅行的徒步者。你有一堆物品，每件物品都有重量和价值（它有多大用处）。你的背包有有限的承重能力。你应该打包哪些物品以最大化总价值？这是NP难的。现在，思考一下修剪一个[神经网络](@article_id:305336)。你有一组可以潜在移除的构建块（层或层的一部分）。每个块都有一个“重量”（你将节省的参数数量）和一个“价值”（通过移除它你将*损失*的准确度量，所以你希望最小化这个损失，这就像最大化你保留的准确度）。你的修剪预算就是你背包的“容量”。找到要修剪的最佳构建块集合等同于解决这个巨大的[背包问题](@article_id:336113)。

虽然对于小型网络可以使用动态规划来精确解决这个问题，但对于现代AI的巨头来说，这在计算上是 prohibitive 的。那么，实践者们会怎么做呢？他们求助于[启发式方法](@article_id:642196)。他们可能会使用简单的贪心[启发式方法](@article_id:642196)：重复找到价值重量比最佳的块（每个节省的参数保留最多的准确度）并将其剪掉。或者他们可能使用逐层[启发式方法](@article_id:642196)，给网络中的每一层一个小的修剪预算，并局部解决问题。这些方法不保证数学上最优的修剪策略，但它们速度快，并能产生显著更小且准确度几乎相当的网络。

即使是最先进的优化技术也可以巧妙地结合启发式方法。在解决大规模[整数规划](@article_id:357285)问题时，例如为一个整个医院的护理人员排班，会使用像*列生成*这样的方法。在一个美妙的转折中，这些精确方法在每一步通常都必须解决一个本身就是NP难的子问题[@problem_id:3116364]。整个“精确”[算法](@article_id:331821)依赖于一个[启发式方法](@article_id:642196)来为其内部的谜题找到一个足够好、足够快的解，从而让更大的搜索得以向[前推](@article_id:319122)进。

从调度工厂到解读我们自己的DNA，从寻找逻辑真理到构建更精简的人工智能，我们看到了同样的故事在上演。世界充满了其规模和复杂性足以嘲笑我们寻求完美、暴力解决方案的尝试的问题。[启发式方法](@article_id:642196)是我们的答案。它们是引导性直觉、结构性洞察和巧妙妥协的体现。它们证明了这样一个理念：在一个复杂的宇宙中，聪明的道路往往是唯一的前进之路。