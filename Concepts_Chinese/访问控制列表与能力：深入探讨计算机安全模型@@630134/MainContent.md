## 引言
在计算机科学这个错综复杂的世界里，几乎没有哪个挑战比控制“谁能对哪些资源做什么”更为根本。这便是[访问控制](@entry_id:746212)的精髓，也是安全的基石。尽管像“权限”这样的术语在日常中被频繁使用，但实现它们的两种主要模型——[访问控制列表 (ACL)](@entry_id:746213) 和能力 (Capabilities)——代表了截然不同的哲学，对系统安全性和鲁棒性有着深远的影响。本文旨在弥合这两种模型之间的认知鸿沟，超越表层比较，揭示其核心权衡。读者将从[访问矩阵](@entry_id:746217)的理论基础出发，了解每种方法在实际应用中的影响，学习它们如何处理身份、权限和时间。第一章“原则与机制”将剖析其基本概念以及它们所造成的深刻分歧。第二章“应用与跨学科联系”将展示这些理论在我们日常使用的软件和系统中的实际运作。首先，我们必须理解这两种模型如何从同一个优雅的抽象中演化而来。

## 原则与机制

要真正理解[访问控制](@entry_id:746212)列表和能力之间的争论，我们必须首先深入问题的核心，探究一个支撑着所有计算机安全的优雅而又极其简单的抽象：**[访问矩阵](@entry_id:746217)**。

想象一个巨大的网格，其行足以映射系统中的每个用户、每个进程、每个*主体*。其列则列出了他们可能希望接触的每个文件、每个设备、每个*客体*。现在，在这个网格的每个单元格中，即主体和客体的交汇处，我们写下该主体对该客体拥有的确切权限——如 `read`、`write` 或 `execute`。这个宏伟的、无所不知的网格就是[访问矩阵](@entry_id:746217)。它是系统整个保护状态的“上帝视角”。如果我们拥有这个矩阵，那么判断 Alice 是否可以写入 Bob 的文件，就如同查找 `[Alice, Bob's file]` 的条目并查看是否存在 `write` 权限一样简单。

当然，在任何真实系统中，这个矩阵都会大到天文数字，而且大部分是空的。大多数用户与大多数文件都没有关系。直接存储它是不可能的。因此，计算机安全的实际工作始于一个实际问题：我们如何有效地表示这个稀疏的巨型矩阵？对这个问题最根本的两个答案，便引出了[访问控制](@entry_id:746212)列表和能力。

### 两种切分矩阵的方法

想象一下，你的任务是存储这个[稀疏网格](@entry_id:139655)中的信息。你可以用两种方式来处理。

#### 卫兵的名单：[访问控制列表 (ACL)](@entry_id:746213)

首先，你可以为每个客体——即我们矩阵中的每一列——制作一个列表。对于一个名为 `report.docx` 的文件，你会创建一个列表，其中包含所有对它拥有权限的主体以及这些权限是什么。这就是**[访问控制列表 (ACL)](@entry_id:746213)**。这是一种以客体为中心的视图，就像在宝藏室门口安排一个卫兵，卫兵手持一份名单，上面写着谁被允许进入以及他们被允许做什么。当一个主体 Alice 尝试打开文件时，系统扮演卫兵的角色：它走到文件的 ACL 旁，扫描 Alice 的名字，并检查请求的操作是否在她的权限列表上。

这种方法非常直观。它也对存储有实际影响。如果你的系统中少数“热门”客体有许多许多主体需要访问（比如一个公共图书馆的主页），但大多数客体只被少数人使用，那么 ACL 就非常高效。你只需要为每个活动客体创建一个列表，而活动客体的数量可能远小于活动主体的数量 [@problem_id:3674112]。

#### 用户的钥匙串：能力 (Capabilities)

或者，你可以为每个主体——我们矩阵中的每一行——提供一套个人权限集合。对于一个主体 Bob，你会创建一个列表，其中包含他有权访问的所有客体以及相应的权限。这个列表中的每一个条目都是一个**能力 (capability)**。可以把它想象成一个钥匙串。链上的每把钥匙都是一个特殊的、不可伪造的令牌，它指定了一个客体以及 Bob 对其拥有的权限。当 Bob 想要打开一个文件时，他不是出示他的身份，而是出示该文件的特定钥匙。系统不需要知道 Bob 是谁，它只需要验证这把钥匙是真的，并且能解锁所请求的操作。

这种以主体为中心的视图同样强大。与 ACL 一样，它也有存储上的权衡。在一个系统中，如果少数强大的主体（如系统管理员）需要访问大量的客体，而大多数主体只访问很少的东西，那么能力列表就更高效。你只需要为每个活动主体准备一个钥匙串，如果活动主体的数量远少于活动客体，你就能节省空间 [@problem_id:3674112]。

到目前为止，ACL 和能力似乎是同一枚硬币的两面——仅仅是存储同一个抽象矩阵的实现细节。但真正的故事从这里开始。选择卫兵的名单还是用户的钥匙串，不仅仅是关于存储，它在系统行为上造成了深刻的[分歧](@entry_id:193119)，导致了截然不同的安全属性。

### 深刻的[分歧](@entry_id:193119)：环境权限 vs. 显式委托

这两种模型最关键的区别不在于它们存储了什么，而在于一个进程在运行时*携带*了什么。

一个基于 ACL 的系统从根本上是关于**身份**的。当一个程序代表你运行时，它就是*作为你*在运行。它继承了你的身份，以及你在整个系统中拥有的所有权限。这被称为**环境权限 (ambient authority)**：权力弥散在空气中，始终存在，与运行进程的身份绑定。

一个基于能力的系统则是关于**持有**。一个程序启动时没有任何权限。它只能对那些被明确赋予了钥匙（即能力）的客体进行操作。

这个区别看似微小，但它却是最经典和危险的安全漏洞之一的根源：**困惑的代理人 (confused deputy)**。

想象一个系统备份服务。该服务需要能够读取所有用户文件以进行备份。在一个 ACL 世界里，我们会给备份服务一个强大的身份，比如 `backup_agent`，并将这个身份以 `read` 权限添加到每个文件的 ACL 中。现在，备份服务拥有了巨大的环境权限。假设一个恶意用户 Mallory 调用了备份服务。Mallory 自己无法读取一个敏感文件 `passwords.txt`。但她可以欺骗备份服务。她请求备份服务备份一个文件，但她给出的不是一个正常的路径，而是 `passwords.txt` 的路径。备份服务，作为代表 Mallory 行事的代理人，忠实地尝试打开 `passwords.txt`。系统卫兵检查文件的 ACL，看到 `backup_agent` 身份被允许读取，于是授予了访问权限。这个代理人被迷惑了，将其环境权限用于恶意目的，读取了文件，并可能将内容泄露给 Mallory [@problem_id:3674116]。

现在，在一个能力世界里思考这个问题。备份服务启动时只有一个空钥匙串——没有环境权限。要为一个用户备份文件，用户必须*传递*给备份服务该文件的特定能力（钥匙）。Mallory 想要读取 `passwords.txt`，于是调用了备份服务。服务会问：“请提供你想要备份的文件的能力。” Mallory 并没有 `passwords.txt` 的能力，所以她无法提供。攻击被当场阻止。备份服务不会被迷惑去滥用它从未拥有的权力。这种对**[最小权限原则](@entry_id:753740)**的优美强制执行，是能力系统最受赞誉的特性之一 [@problem_id:3674116]。

这种“默认拒绝”与“默认允许”的哲学对勒索软件等现代威胁有直接影响。一个基于 ACL 的系统通常会授予用户进程对其所有文件的广泛 `write` 权限。一个逃避了检测的勒索软件程序继承了这种巨大的环境权限，可以加密一切。这是一种全有或全无的失败。相比之下，一个基于能力的系统强制进程为每个需要修改的文件请求特定的写能力。即使一个困惑的中介批准了其中一些请求，损害也是被分隔开的。勒索软件只得到了它能成功欺骗中介提供的那些钥匙；它没有得到通往整栋房子的万能钥匙 [@problem_id:3674071]。

### 时间的流逝：静态检查 vs. 滞留权限

ACL 和能力之间的第二个巨大分歧在于它们如何[处理时间](@entry_id:196496)的流逝。当我们改变主意想要撤销一个权限时，会发生什么？

在 ACL 系统中，撤销是直接了当的。如果我们从一份秘密文件的 ACL 中移除 Alice，这个变更是即时的。下一次任何人尝试访问该文件时，系统的卫兵会查阅更新后的列表，Alice 将被拒绝。

但这引出了一个更微妙的问题。对于一个已经在进行中的访问该怎么办？这让我们想到了一个具体而熟悉的例子：类 Unix [操作系统](@entry_id:752937)中的**文件描述符 (file descriptor)**。当你 `open` 一个文件时，系统会执行 ACL 检查。如果成功，内核不会把文件本身交给你，而是给你一个句柄——一个称为文件描述符的小整数。这个描述符实际上就是一个能力。它是一个令牌，赋予了对底层文件执行 `read` 或 `write` 操作的权利，而无需任何进一步的 ACL 检查。检查只在 `open` 时进行一次 [@problem_id:3619294]。

现在我们可以看到问题所在。假设 Bob 打开了 Alice 的文件，获得了一个文件描述符。Alice 随后立即将 Bob 从文件的 ACL 中移除。这对 Bob 已有的描述符没有影响。他可以继续读取或写入该文件，直到他关闭那个句柄。文件描述符代表了**滞留权限 (lingering authority)**——一个来自过去某个时刻的权限快照 [@problem_id:3619294]。这可能导致严重的安全漏洞。一个进程可能打开一个敏感文件，然后 `exec`（运行）一个不受信任的程序。如果文件描述符没有被显式关闭，它会被新的、不受信任的程序继承，使其能够访问敏感文件，完全绕过了 ACL [@problem_id:3674074]。

这种“残留的漏洞窗口”是简单能力系统的一个普遍特征。一个能力一旦被颁发，除非它过期或被撤销，否则一直有效。如果一个学生的角色变为校友，他们基于 ACL 的对成绩单的访问权限会立即被切断。但在角色变更前颁发给他们的任何能力都可能滞留，使他们能够继续访问，直到这些能力被刷新或过期 [@problem_id:3674036]。

驾驭时间流逝是一个核心挑战。对于文件描述符的情况，系统开发了一个简单但至关重要的机制：`close-on-exec` 标志。这个标志告诉内核在运行新程序时自动撤销能力（关闭描述符），防止权限泄露 [@problem_id:3674074]。对于更通用的系统，解决方案通常涉及从一开始就内置撤销机制：能力可以带有较短的过期时间，需要根据主 ACL 定期刷新 [@problem_id:3674036]，或者它们可以指向一个可以被置为无效的中央记录，这种技术被称为**间接引用 (indirection)** [@problem_id:3619294]。

### 一种优美的综合：我们两者都需要

看起来我们似乎不得不在 ACL 的困惑代理人漏洞和能力的滞留权限问题之间做出选择。但真实系统的美妙之处在于它们很少是教条的。它们常常结合两种模型，各取其长。

一个典型的模式是使用 ACL 作为持久的、基准事实的策略存储。它们非常适合管理和定义静态的所有权规则。而能力则被用作会话期间授予访问权限的临时的、高性能的令牌。你查阅一次 ACL 来生成一个能力，然后在任务期间使用该能力。

然而，这种[混合模型](@entry_id:266571)也带来了其自身引人入胜的挑战，尤其是在[分布式系统](@entry_id:268208)中。考虑一个维护 ACL 但向客户端颁发加密能力的文​​件服务器。如果服务器崩溃，并且必须从一周前的备份中恢复其 ACL，会发生什么？[@problem_id:3674091]。服务器的“基准事实”刚刚在时间上倒流了。与此同时，客户端仍然持有那些可能反映了在备份之后、但在崩溃之前授予的权限的能力。根据恢复后的 ACL，其中一些能力现在可能已经无效。

简单地信任任何具有有效加密签名的能力将是一场灾难，因为它可能授予在崩溃前已被撤销的访问权限。唯一安全的途径是重新确立 ACL 作为事实的来源。一个健壮的协议会要求，在收到一个能力时，恢复后的服务器根据其当前的 ACL 重新验证所声称的权限。一个更优雅的解决方案涉及**纪元 (epochs)**：服务器用一个版本号或纪元来标记其当前的 ACL 状态。它将这个纪元嵌入到它颁发的每个能力中。崩溃后，它增加纪元号。任何带有旧纪元号的能力被呈现时，都会立即被识别为陈旧的，并且必须根据当前策略重新验证。这使得系统既能享受能力的性能和安全优势，又能锚定于 ACL 的管理清晰性，即使在面临故障时也是如此 [@problem_-id:3674091]。

归根结底，ACL 和能力不是在安全霸权之战中的对手。它们是看待同一问题的两种基本视角，是切分同一抽象矩阵的两种不同方式。从简单的网格到纪元和困惑代理人的复杂舞蹈，这段旅程揭示了一个深刻的真理：构建安全的系统不是要找到一个单一、完美的工具，而是要理解原则，认识权衡，并将这些基本思想组合成一个有弹性且优雅的整体。

