## 应用与跨学科联系

我们已经走过了[访问控制](@entry_id:746212)的抽象原则之旅，对比了[访问控制列表 (ACL)](@entry_id:746213) 的规范世界和能力 (Capabilities) 的流动的、基于持有的世界。如同任何优秀的物理定律一样，这些原则不仅仅是枯燥的抽象；当我们看到它们在周遭世界中发挥作用时，它们便活了起来。而这是一个多么精彩的世界！从我们电脑上的日常工具，到庞大的云基础设施，再到[操作系统](@entry_id:752937)的核心，这两种思想之间的张力与协同塑造了我们的数字生活。现在，让我们来游览这个世界，亲眼见证。

### 数字工坊：从源代码到数据管道

我们许多人整天在数字工坊里构建软件。那个工坊里最常见的工具之一就是[版本控制](@entry_id:264682)系统，比如 Git。你是否曾停下来想过，它是如何决定谁能做什么的？一个代码仓库的 `main` 分支是其皇冠上的明珠；我们必须保护其完整性。谁可以直接推送到 `main` 分支的规则通常是静态的，并且只为一[小群](@entry_id:198763)维护者定义。这是[访问控制](@entry_id:746212)列表的经典应用场景：在 `main` 分支客体上设置一个简单的、以客体为中心的列表，上面写着“只有维护者可以推送”。

但现代开发是协作性的。开发者通过拉取请求 (PR) 提出变更。经过审查和自动化检查后，这个变更需要被合并。我们当然不希望给每个提交 PR 的开发者永久的对 `main` 分支的 `merge` 权限。相反，系统需要授予一个临时的、单一用途的权限。这正是能力大放异彩的地方。当一个 PR 被批准时，系统可以生成一个短暂的、经过削弱的能力——一个特殊的令牌，上面写着：“持有者被授权对 `main` 分支就此特定 PR 执行且仅执行一次 `merge` 操作。”一旦合并完成，该令牌即被消耗并变得无用。这种优美的[混合方法](@entry_id:163463)让我们两全其美：用 ACL 的严格保护来实施静态策略，用能力的动态、细粒度灵活性来处理日常操作 [@problem_id:3674024]。

这种粒度的思想远远超出了源代码的范畴。考虑一个处理敏感客户记录的数据管道 [@problem_id:3674117]。一条记录可能包含姓名、电子邮件地址和社会安全号码 (SSN)。一个分析进程需要查看购买历史，但出于保密性，它决不能看到 SSN。如果我们唯一的工具是文件级别的 ACL，我们就会陷入困境。我们不能授予对该文件的访问权限，因为那会暴露 SSN。唯一的办法是创建一个全新的、经过编辑的整个数据集副本，移除 SSN 列，然后授予对该副本的访问权限。这既笨拙又昂贵。

一个基于能力的系统提供了一个优雅得多的解决方案。我们不必将文件视为客体，而是可以将每个*字段*或*列*视为一个客体。然后，分析进程被赋予一组能力：一个用于“姓名”字段，一个用于“购买金额”字段，等等。它根本不会被赋予“SSN”字段的能力。因此，该进程在物理上变得不可能访问敏感数据，这不是因为一个脆弱的应用层检查，而是因为它不拥有通往该特定数据的“钥匙”。这是对[最小权限原则](@entry_id:753740)的深刻执行，使权限的粒度与需求的粒度相匹配。

### 委托的艺术：驯服过度特权的进程

能力最强大的应用之一就是驯服强大的进程。在旧系统中，许多管理任务由一个单一的、作为“超级用户”或 `root` 运行的[单体](@entry_id:136559)进程执行——这是一个对机器拥有绝对权力的数字上帝。这个进程中的一个 bug，无论是在其网络代码还是文件解析器中，都可能导致整个系统被攻破。这就像同时雇佣一个管家来当你的厨师、司机和脑外科医生；风险极高。

现代、安全的方法是应用域分离。考虑一个软件包管理器，这个工具在系统上安装和更新软件 [@problem_id:3674054]。这个过程需要许多不同的特权：它需要通过网络获取软件包，执行加密检查以验证它们，将文件写入受保护的系统目录，以及重启服务。我们可以不让一个 `root` 进程做所有事情，而是将其分解为一个由小而专的辅助进程组成的交响乐团，每个辅助进程都生活在一个受限的域中。一个辅助进程只处理网络。另一个只处理[文件系统](@entry_id:749324)操作。

协调者，作为一个代理，使用能力来指挥这个交响乐团。它首先请求网络辅助进程获取一个软件包，并递给它一个临时能力，该能力只允许它连接到官方的仓库主机，而不能连接到其他任何地方。当下载完成后，该能力被撤销。然后，协调者将有效载荷交给一个加密辅助进程，同时附上一个读取系统可信密钥的能力。只有当签名有效时，协调者才会进行最危险的一步：它为[文件系统](@entry_id:749324)辅助进程生成一个能力，该能力只允许它写入该软件包所需的特定路径。这就是权限的[时间分离](@entry_id:174755)：危险的权限只有在安全检查通过后才被授予，并且它们的范围尽可能窄，持续时间尽可能短。

这种委托最小权限的模式出现在许多地方。想想大学评分系统中，助教 (TA) 帮助一位讲师 [@problem_id:3674086]。讲师对成绩册拥有完全的权限，这是一个由 ACL 管理的特权。但一个 TA 只需要为一项作业评分。给予 TA 对整个成绩册的广泛 `write` 权限将严重违反[最小权限原则](@entry_id:753740)。基于能力的解决方案是为 TA 生成一个临时的、不可转让的能力，该能力授予对作业 $A_k$ 的提交内容进行 `grade` 的权利。这个能力可以在评分截止日期后被撤销。它优雅地提供了恰好需要的权限，在恰好需要的时间内，而不会暴露成绩册的其余部分。从软件包管理器到助教，原理是相同的：用一个负责任的、单一目的的专家团队取代上帝般的权力。

### 构建现代世界：云、物联网与信息流

我们探讨的原则是我们现代云和物联网基础设施赖以构建的基石。例如，在一个多租户云存储服务中，租户隔离至关重要 [@problem_id:3674068]。默认情况下，租户 A 不能访问租户 B 的数据。这是通过数据客体上的 ACL 来强制执行的。但如果租户 A 想授予租户 B 的分析服务对其某个大型数据集的临时读取权限呢？

这是一个混合系统的完美用例。所有者租户 A 为该客体生成一个能力。这个能力是一个经过加密签名的令牌，它委托了一个特定的权限（例如 `read`）并在限定时间内有效。但它还可以包含更多内容！为了解决“谁为访问付费”的实际问题，该能力可以嵌入发行者的身份——租户 A。当租户 B 的服务向存储系统出示此能力时，系统不仅验证访问权限，还知道应向租户 A 收取此次交易的费用。能力变成了一份丰富的、自包含的关于委托访问和计费的合同。

这种能力延伸到蓬勃发展的物联网 (IoT)。你家里的一个物联网摄像头需要服务于不同的主宰 [@problem_id:3674082]。你，作为所有者，需要管理权限来更改其配置或更新其固件。一位访客可能只被允许查看实时视频流。一个云服务可能需要接收视频流以进行录制。这些主体中的每一个都需要一套不同的权限。

更重要的是，一些操作远比其他操作危险。固件更新是一个微妙的、高权限的操作。直接授予所有者的移动应用对原始固件[闪存](@entry_id:176118)的 `write` 能力将是危险的。一个更好的设计是使用“守门人”模式。应用被赋予一个能力，该能力只授予它对一个受保护的 `update_gate` 客体的 `execute` 权限。这个“门”是一小段精心编写的代码，其唯一的工作就是安全地执行更新。这隔离了危险操作，并且还允许系统确保*可用性*——固件更新可以在其自己的受[保护域](@entry_id:753821)中进行，而不会中断向其他授权观看者提供的视频流。

有时，即使授予 `read` 权限也太过分了。在图形用户界面中，当你从一个应用程序复制机密文本并将其粘贴到另一个应用程序时，我们如何防止恶意的（或被攻破的）目标应用立即将该数据泄露到互联网上 [@problem_id:3674120]？简单的[访问控制](@entry_id:746212)是不够的；我们需要控制信息*流*。高级能力系统可以通过在能力本身中包含一个机密性标签来解决这个问题。当数据被粘贴时，接收进程被这个高机密性标签“污染”了。然后，执行强制[访问控制策略](@entry_id:746215)的操作系统内核可以阻止这个被污染的进程写入任何低机密性的目标，比如网络套接字。这是安全领域的前沿，从“谁能访问什么？”转向“数据允许流向何处？”。

### 深入基石：内核与[分布](@entry_id:182848)式世界

现在我们深入到系统的最底层。任何计算机中最有特权和最受信任的组件是其操作系统内核。但内核本身必须信任其[设备驱动程序](@entry_id:748349)——这些复杂的软件负责与你的网卡、显卡和存储驱动器通信。内核如何保护自己免受有缺陷或恶意的驱动程序的影响？

答案在于使用一个由能力来监管的输入输出[内存管理单元](@entry_id:751868) ([IOMMU](@entry_id:750812)) [@problem_id:3674030]。当网络驱动程序需要告诉网卡将传入数据放在何处时，它必须请求内核在 [IOMMU](@entry_id:750812) 中创建一个映射。在一个基于能力的内核中，驱动程序不能只提供一个原始内存地址。这样做会产生一个“困惑的代理人”问题，即全能的内核可能被欺骗，从而授予设备访问内存任何部分的权限。相反，驱动程序必须向内核出示两个不同的能力：
1. 一个证明它是*网卡*合法管理者的能力。
2. 一个证明它对其想要使用的*内存缓冲区*拥有合法权限的能力。

内核的工作被简化为仅仅验证这两把“钥匙”是否有效。它不需要信任驱动程序。它只是检查驱动程序的权限。这个简单而强大的思想是世界上一些最安全的[操作系统](@entry_id:752937)的基础，它允许对隔离性进行数学证明。

最后，当我们离开单台机器的安全环境，进入混乱的[分布式系统](@entry_id:268208)世界时，会发生什么？不同机器上的进程通过不可靠的网络进行通信。它们会崩溃。消息会丢失。假设一个进程获取了一个[分布](@entry_id:182848)式锁然后崩溃了。在一个简单的系统中，那个锁可能被永远持有，导致死锁。

能力，再加上一点额外信息，可以优雅地解决这个问题 [@problem_id:3674104]。当服务器授予一个锁时，它颁发一个能力，其中不仅包括对锁的权利，还包括一个*租约时间*（一个到期日期）和一个*世代号*。客户端必须在租约到期前定期续约。如果客户端崩溃，租约会到期，服务器就可以自由地将锁授予其他人，从而确保可用性。如果服务器需要撤销一个锁（也许因为它认为客户端已经失败），它只需增加该锁的内部世代号。任何由缓慢或被分区的客户端出示的旧能力都会有一个陈旧的世代号，并被拒绝。这种“[隔离令牌](@entry_id:749290)”机制在一个不可靠的世界中提供了强大的完整性和活性。

### 不可伪造的钥匙

在整个游览过程中，我们一直把“不可伪造的”能力说得好像它们是魔法一样。但它们是另一个领域——密码学——的优美应用。一个能力不必是一个复杂的内核对象；它可以只是一捆数据——一个包含客体ID、权限、过期时间等的元组。为了使其不可伪造，内核只需使用一个只有它自己知道的密钥，对这些数据计算一个基于哈希的消息认证码 (HMAC) [@problem_id:3631364]。

这个 HMAC 标签被附加到能力上。当一个进程出示该能力时，内核用它的密钥重新计算标签，并检查是否匹配。由于没有其他人知道这个密钥，所以没有人能为一个修改过的能力伪造一个有效的标签。这使得能力成为一个持有者令牌。任何拥有它的人都可以使用它，从而实现了自然的委托。[密码学](@entry_id:139166)属性为我们提供了可量化的安全保证；对于一个 128 位的标签，在大量尝试下，对手猜中一个有效标签的概率小到天文数字，约为 $2^{-96}$ [@problem_id:3631364]。

这种加密实现也凸显了能力的主要挑战：撤销。如果内核不保留它所颁发的每一个能力的列表，它如何能选择性地只撤销一个呢？它做不到。它要么等待它过期（最终撤销），要么更改主密钥，这将一次性使该资源的所有能力都失效（批量撤销）。要实现即时的、选择性的撤销，需要在内核中加回状态，这是[系统设计](@entry_id:755777)者必须仔细权衡的取舍。

从一个简单的访客名单到一个经过加密签名的合同，从 ACL 到能力的旅程是一个关于日益增加的复杂性、粒度和力量的故事。它们不是敌人，而是两种基本的工具。构建安全、健壮和优雅的系统的艺术在于知道该使用哪一个，或者如何将它们编织在一起，为我们复杂的数字世界带来秩序和安全。