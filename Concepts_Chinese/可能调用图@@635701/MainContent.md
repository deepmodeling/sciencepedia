## 引言
在现代软件开发中，理解大型代码库中错综复杂的交互网络是一项艰巨的挑战。我们如何在不针对每一种可能的输入都运行程序的情况下，来推断程序的行为呢？答案在于[静态分析](@entry_id:755368)，而其基石工具之一就是[调用图](@entry_id:747097)——一份描绘函数间如何通信的蓝图。本文将揭开一个特定且强大的变体：**可能[调用图](@entry_id:747097)**的神秘面纱。它解决了程序的静态源代码与其动态运行时行为之间的关键鸿沟，揭示了一张描绘*可能*调用的地图如何能够带来深刻的洞见。我们将首先深入探讨构建这张地图背后的原理和机制，区分静态的可能性与动态的现实。随后，我们将探索这份蓝图的多种应用，从优化性能、发现缺陷到加固软件以抵御安全威胁。

## 原理与机制

想象你有一张某国完整道路网络的详细地图。这张地图显示了每一个城市以及连接它们的所有道路，从最宏伟的高速公路到最偏僻的乡间小道。这张地图是对所有可能旅程的静态、完整的描绘。现在，想一想你从一个城市到另一个城市的实际行程。这次行程是一个动态事件——你所经过的一系列特定道路。你不会走遍地图上的每一条路；你只遵循一条特定的路径。

这是我们在讨论程序结构时需要掌握的最关键的区别：**地图**与**实际疆域**之间的差异。程序的源代码就像地图，而**可能[调用图](@entry_id:747097)**是那张地图最忠实的表示。程序在给定输入下的实际执行就是一次旅程，一次穿越地图所描绘景观的动态之旅。

### 两个世界的故事：静态地图与动态旅程

一个计算机程序是函数的集合，也就是我们的“城市”。当一个函数，比如 `main`，调用另一个函数 `calculate` 时，我们可以将其视为一条从 `main` 通往 `calculate` 的道路。一个**静态[调用图](@entry_id:747097)**就是这些道路的完整地图。对于程序中的每个函数，我们画一个点；如果函数 `A` 包含*可能*调用函数 `B` 的代码，我们就画一个从 `A` 到 `B` 的有向箭头——一条单行道。

这张地图的精妙之处在于它告诉我们什么是*可能*的。但它并不能告诉我们在程序的任何单次运行中*将要*发生什么。一段简单的代码就可以在静态地图和动态旅程之间造成有趣的[分歧](@entry_id:193119)。考虑一个只做一件事的函数 `f`：调用它自己，且没有停止的方式——即无限递归 [@problem_id:3237183]。

-   **静态地图**极其简单：一个城市 `f`，带有一条环回到自身的道路。它就像一个环岛。
-   然而，**动态旅程**是一条延伸至地平线的无限高速公路。对 `f` 的第一次调用是入口匝道。这个调用实例接着再次调用 `f`，创建了第二个不同的实例，如此无限进行下去。执行轨迹是一条不重复的、无尽的路径：$f_0 \to f_1 \to f_2 \to \dots$。

这揭示了一个深刻的真理：静态[调用图](@entry_id:747097)不是一个有向无环图（DAG），因为自环是一个环路。然而，实际执行过程中发生的情况所构成的图却是*无环的*！每一次调用都是时间上一个新的、独特的事件。机器的**调用栈**（用于跟踪活动调用）随着在这条无限道路上的每一步深入而变得越来越深。这个栈的最大深度是一个动态属性，是旅程的特征，而非地图的特征 [@problem_id:3274453]。一张显示环路的地图只告诉我们，长途甚至无限的旅程是*可能*的；它并不描述旅程本身。

### 绘制地图：确定性、可能性与健全性

我们，或者更重要的是，编译器如何绘制这张地图？对于最简单的情况，这就像读取路标。如果编译器在函数 `A()` 的函数体内部看到一行 `B();`，它就会在图中添加一条边 $A \to B$。通过扫描整个程序，它可以建立起所有这些直接连接的列表 [@problem_id:3673768]。

但我们正在构建的是哪种地图呢？我们只对有保障的超级高速公路感兴趣，还是对每一条小径都感兴趣？这个选择导致了两种不同的图 [@problem_id:3625857]：

-   **必然[调用图](@entry_id:747097)**仅当从 `A` 到 `B` 的调用在 `A` *每次*执行时都*保证*会发生时，才包含一条边 $A \to B$。这是一张确定性的地图。它对于编译器衡量某项优化的“收益”很有用。如果一个调用是保证会发生的，那么优化它的好处将总是能够实现。

-   **可能[调用图](@entry_id:747097)**，即我们讨论的重点，当调用在至少一条执行路径上是*可能*的时，就包含一条边 $A \to B$。这是一张可能性的地图。其决定性特征是**健全性**，在此语境下，这意味着它是一种**过近似**。一个健全的可能[调用图](@entry_id:747097)必须包含运行时可能发生的每一个调用。它可以包含实际上不可能发生的调用的额外边，但它*绝不能*遗漏任何一个可能的调用。

为什么这如此重要？想象一个编译器试图证明一个程序是安全的。它使用可能[调用图](@entry_id:747097)来查看所有可能被调用的函数。如果地图上缺少一条道路——即它是**不健全的**——编译器可能会错误地断定一个危险操作是不可达的，而实际上它是可达的。为了安全，我们必须拥有一张所有可能性的完整地图，即使它包含一些永远无法通行的“幽灵道路”。由此，一个基本关系浮现出来：“必然”边的集合总是“可能”边的集合的[子集](@entry_id:261956)（$E_{\text{must}} \subseteq E_{\text{may}}$）[@problem_id:3625857]。

### 战争迷雾：驾驭间接调用

绘制直接调用的地图是直接了当的。真正的挑战——也是[编译器设计](@entry_id:271989)艺术真正闪光的地方——在于驾驭由**间接调用**所创造的“战争迷雾”。这种情况发生在像 C/C++ 这样有函数指针的语言中，或者在面向对象语言的虚方法中。代码没有说“调用 `B`”，而是说“调用地址存储在这个变量 `p` 中的函数”。

目的地不再写在路标上，而是写在变量 `p` 持有的一张纸条上。要绘制我们的地图，我们必须找出所有可能最终出现在那张纸条上的地址。这属于**[指向分析](@entry_id:753542)**的范畴。

可以把这种分析想象成一个侦探在绘制一个间谍网络图 [@problem_id:3625868]。侦探从一些已知的事实开始，比如“变量 `p` 最初被赋予函数 `f` 的地址”。地图以 $p \to \{f\}$ 开始。然后，侦探找到更多线索：
1.  一张纸条上写着：“变量 `q` 应该是 `p` 的一个副本。”侦探尽职地更新地图：$q \to \{f\}$。
2.  另一张纸条写着：“如果 `q` 可以指向 `f`，那么 `p` 也可能被更新以指向 `g`。”由于 `q` 的地图包含 `f`，侦探将 `g` 添加到 `p` 的集合中：$p \to \{f, g\}$。
3.  关于 `p` 的这个新事实可能会在别处解锁其他线索！

侦探必须反复审视所有线索，传播新信息，直到找不到新的连接为止。这个达到稳定状态的迭代过程被称为寻找**[不动点](@entry_id:156394)** [@problem_id:3625934]。分析从一个空的地图（格的底部）开始，并根据程序的规则不断添加边。因为所有可能函数的集合是有限的，这个过程保证会终止，留给我们一个关于每个指针可能指向何处的健全的过近似。

同样的原则也适用于面向对象的语言。像 `shape.draw()` 这样的调用是一个间接调用。哪个 `draw` 方法被调用？这取决于 `shape` 对象的实际运行时类型。一种简单的分析方法，称为**类层次[结构分析](@entry_id:153861)（CHA）**，会做出一个粗略的猜测：`shape` 可能是任何继承自其声明类型 `Shape` 的类。但更精确的[指向分析](@entry_id:753542)可以缩小 `shape` 变量在代码中特定点可能持有的实际类型集合，从而使我们能够从可能[调用图](@entry_id:747097)中剪除不可能的目标 [@problem_id:3625937]。

### 回报：更优的地图如何锐化我们的视野

构建一个精确的可能[调用图](@entry_id:747097)这项艰巨的工作仅仅是一项学术练习吗？远非如此。一张更精确的地图能让编译器以惊人的清晰度理解程序，从而实现那些原本不可能的优化。

考虑一个来自 [@problem_id:3647952] 的优美例子。一个程序有一个间接函数调用 `p(x)`。一个粗略的[调用图](@entry_id:747097)分析（如 CHA 或简单的[可达性](@entry_id:271693)分析）看到 `p` 可能指向函数 `f`（总是返回 41）或函数 `g`（返回其输入）。当编译器试图计算 `p(1)` 的结果时，它看到两种可能性：结果可能是 `f(1)=41` 或 `g(1)=1`。由于无法在两者之间做出决定，它必须放弃并将结果声明为“未知”（在分析格中表示为 $\top$）。

现在，看看使用更强大的流敏感分析会发生什么。它注意到，将 `g` 赋值给 `p` 的代码分支实际上是不可达的。它证明了这条路径是一条“幽灵道路”。其精化的可能[调用图](@entry_id:747097)只显示 `p` 的一个可能目标：函数 `f`。凭借这种锐化的视野，编译器现在可以确定地知道调用 `p(1)` 将是 `f(1)`，其计算结果为 `41`。然后它可以执行进一步的计算，推断出程序的最终结果是常量 `42`。一张更好的地图不仅仅是清理了一张图表；它将一个未知量转化为一个确凿的事实。

### 前沿与权衡：反射与现实

对完美地图的追求有其自身的前沿和实际限制。当一个程序可以动态地创造其目的地时会发生什么？一些语言支持**反射**，允许代码在运行时从字符串构造方法名，比如 `invoke("m" + "2")`。要绘制这张地图，编译器必须成为一名语言学家，分析所有可能被创建的字符串值 [@problem_id:3625850]。**动态类加载**使这变得更加复杂。如果字符串引用的方法所在的类在分析运行时甚至还不存在怎么办？为了保持健全性，分析必须要么假设一个**封闭世界**（不会加载新代码），要么保守地添加一条到通用“未知代码”节点的边，承认其知识的局限性。

最后，[静态分析](@entry_id:755368)从根本上是关于可能性的。它生成了一张所有道路的地图，但对交通状况一无所知。这正是[静态分析](@entry_id:755368)世界与**性能剖析**的动态世界美妙交汇的地方。通过在典型输入上运行程序，我们可以创建一张“[热力图](@entry_id:273656)”，用观察到的执行频率来标注我们可能[调用图](@entry_id:747097)中的每一条边 [@problem_id:3625916]。

我们不能用这张[热力图](@entry_id:273656)来证明一条冷清的道路是未被使用的——不同的输入可能会让大量的交通涌入其中。因此，对于关乎正确性的决策，我们仍必须依赖于完整的、健全的可能[调用图](@entry_id:747097)。但对于启发式决策，比如将优化精力集中在哪里，性能剖析是无价的。编译器可以使用这种混合地图，将其时间花在优化那些性能增益最显著的“热门”高速公路上。这种静态可能性与动态概率的优雅融合是现代高性能编译器的核心。可能[调用图](@entry_id:747097)不仅仅是一张地图；它是理解、优化和保护驱动我们世界软件的必要蓝图。

