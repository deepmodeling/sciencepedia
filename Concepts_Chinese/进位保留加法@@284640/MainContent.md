## 引言
在追求计算速度的过程中，几乎没有什么障碍比数字相加所需的时间更为根本。传统方法，如[行波进位加法器](@article_id:356910)，受限于一连串的依赖关系，这会造成显著的延迟，而且这个瓶颈会随着处理的数字大小而扩大。本文通过探索一种强大而优雅的解决方案来应对这一挑战：**进位保留加法**。它引入了一种方法，通过规避进位链的束缚来实现显著的加速。在接下来的章节中，您将首先深入探讨“原理与机制”，揭示该技术如何通过延迟进位传播，在单一步骤内将三个数简化为两个数。随后，“应用与跨学科联系”一章将揭示这一核心原理如何成为高速数字乘法器、[数字信号处理](@article_id:327367)和现代[计算机体系结构](@article_id:353998)的基石，实现了若非如此便无法达到的性能。

## 原理与机制

### 进位链的制约

想象一下，你在一家杂货店排着很长的队结账。出于某种原因，收银员一次只能扫描一件商品，并且每次扫描后，都必须转身问经理累计总额是否正确，然后才能扫描下一件。而经理又必须咨询*他的*经理，如此在一个长长的指挥链中层层上报。进度会慢得令人痛苦。每一步都被前一步所牵制。

这正是二进制数相加最直接方法——**[行波进位加法器](@article_id:356910)**——所处的困境。当两个数（比如 $A$ 和 $B$）相加时，每个比特位的和都取决于其右侧位置的进位输出。进位从最低有效位一直“[行波](@article_id:323698)”传播到最高有效位。对于位数很多的数字相加，例如现代计算机中的 64 位数字，这种连锁反应会产生巨大的延迟。第 64 位的最终结果必须等待前面 63 个计算的整个链条全部完成。在每秒发生数十亿次操作的高速计算世界里，这是一个不可接受的瓶颈。

因此，问题自然而然地出现：我们能找到一种更巧妙的加法方式，一种能打破这条专制链条的方式吗？

### 巧妙的规避：只保存进位

如果我们能在每个比特位上*同时*执行加法，而无需等待相邻位置，会怎么样？障碍当然是进位。当你在二进制中计算 $1+1$ 时，你会得到 $0$ 和一个 $1$ 的进位。那个进位*必须*进入下一列。但真的必须这样吗？

**进位保留加法**背后的绝妙见解就是干脆*不*立即传播进位。相反，我们在每个位置上独立进行加法，并生成两个结果而不是一个：一个“和”位和一个“进位”位。然后，我们将所有的和位收集成一个数，所有的进位位收集成另一个数。我们通过将进位保存在它们自己的独立向量中，以备后用，从而规避了[传播延迟](@article_id:323213)。

这个策略彻底改变了游戏规则。我们不再是把两个数相加得到一个数，而是把*三个*数相加并将它们简化为*两个*数。为什么是三个？因为在任何给定的位置，我们可能会有一个来自数 A 的位，一个来自数 B 的位，以及一个来自前一操作的进位输入。

### 基本构建模块：(3,2) 计数器

让我们看一下在单个比特位（比如位置 $i$）上发生了什么。我们有三个比特需要相加：$a_i$、$b_i$ 和 $c_i$。这三个比特的和可以是 0、1、2 或 3。在二进制中，这些和分别是 $00_2$、$01_2$、$10_2$ 和 $11_2$。请注意，我们永远不需要超过两个比特来表示这个和。

所以，对于每三个输入比特，我们可以生成一个两比特的输出。我们将较低的位称为**和位** $s_i$，较高的位称为**进位位** $c'_{i}$。这个操作正是一个标准的**[全加器](@article_id:357718)**电路所做的 [@problem_id:1918736]。
- 如果输入是 (1, 0, 0)，和为 1，所以 $(s_i, c'_i) = (1, 0)$。
- 如果输入是 (0, 1, 1)，和为 2，所以 $(s_i, c'_i) = (0, 1)$。
- 如果输入是 (1, 1, 1)，和为 3，所以 $(s_i, c'_i) = (1, 1)$。

逻辑很简单：和位 $s_i$ 就是三个输入的[异或](@article_id:351251)（$a_i \oplus b_i \oplus c_i$），而进位位 $c'_i$ 在至少有两个输入为真时为真。关键在于，算术值是守恒的：$a_i + b_i + c_i = s_i + 2 \cdot c'_i$。

因为这个小电路接收三个输入并将其值“压缩”为两个输出，所以它通常被称为 **(3,2) 计数器**或 **(3,2) 压缩器** [@problem_id:1918705]。它是我们高速加法机的基本乐高积木。

### 并行性的释放

现在，让我们来构建这台机器。要将三个 8 位数——$X$、$Y$ 和 $Z$——相加，我们只需并排[排列](@article_id:296886)八个这样的 (3,2) 计数器，每个比特位置（从 0 到 7）一个 [@problem_id:1918766]。第 $i$ 个计数器接收比特 $x_i$、$y_i$ 和 $z_i$ 作为其输入。所有八个计数器并行操作，完全互不相干。没有[行波](@article_id:323698)传播。延迟仅仅是单个[全加器](@article_id:357718)的延迟，无论我们是相加 8 位数还是 800 位数。

输出是什么？我们得到两个 8 位向量 [@problem_id:1918731]：
1.  一个**部分和向量 (S)**：该向量由所有和位集合而成，$S = s_7s_6...s_1s_0$。这表示每个位置上的和，忽略了进位。
2.  一个**进位向量 (C)**：该向量由所有进位位集合而成，$C = c'_7c'_6...c'_1c'_0$。

所以我们成功地将加三个数（$X, Y, Z$）的问题转化为了处理两个数（$S, C$）的问题 [@problem_id:1918707]。但这些数之间有什么关系呢？

### 延迟的清算与关键的移位

其魔力在于原始总和与我们两个新向量的关系。请记住，在位置 $i$ 生成的进位位 $c'_i$ 代表一个属于位置 $i+1$ 的值。它的位权是第 $i$ 列中各位的两倍。

因此，原始总和并不是 $S + C$。总和等于部分和向量加上进位向量*向左移动一个位置*的结果 [@problem_id:1918740] [@problem_id:1918753]。将一个二进制数左移一位等同于将其乘以 2，这给了每个进位位其应有的权重。
$$
X + Y + Z = S + (C \ll 1)
$$
我们成功地将三个数的加法简化为两个数的加法。这看起来可能不是一个巨大的胜利，但它是实现惊人速度的关键。从三个数简化为两个数的整个过程发生在一个单一的、恒定时间的步骤中。

为了得到最终的、单一数字的答案，我们确实需要使用一个传统的加法器——我们称之为**进位传播加法器 (CPA)**——来执行最后一次加法，将 $S$ 和移位后的 $C$ 相加 [@problem_id:1918767]。但是我们用一个简化步骤和一次最终加法替换了一系列缓慢的加法。

### 回报：华莱士树

当我们需要一次性相加多个数时，这种技术的真正威力就显现出来了，这是数字乘法等操作中的常见任务。将两个 8 位数相乘会产生八个必须全部相加的中间“部分积”。

如果我们试图用标准的[行波进位加法器](@article_id:356910)一个接一个地相加，那就会像地狱般的杂货店结账队伍一样。总延迟将是巨大的。

取而代之，我们可以构建一个由进位保留加法器组成的“锦标赛”，这种结构被称为**华莱士树**。
- 在第一轮中，我们将 8 个部分积进行分组，每三个一组。我们使用 CSA 将这 8 个数减少到大约 $\frac{2}{3} \times 8 \approx 6$ 个数。
- 在第二轮中，我们将这 6 个数减少到 4 个。
- 然后从 4 个到 3 个，最后从 3 个到 2 个。

这些轮次中的每一轮都只需要一个单一的、恒定时间的步骤。轮数仅随输入数量对数级增长。结果是速度的急剧提升。在一个典型场景中，华莱士树乘法器可以比使用级联[行波进位加法器](@article_id:356910)的幼稚设计快 16 倍以上 [@problem_id:1977463]。这就是能够处理实时高清视频的系统与不能处理的系统之间的区别。

### 速度的代价：与冗余共存

进位保留表示法是一个绝妙的技巧，但它也伴随着一个微妙的代价。CSA 的输出——那对和向量和进位向量——是对总和的**冗余表示**。其值是正确的，但并非标准的、可用的二进制格式。

假设你想知道一个中间和是正数还是负数。在一个标准的二进制[补码](@article_id:347145)数中，你只需查看最高有效位。但是对于来自 CSA 的和向量与进位向量，你无法做到。最终数字的符号取决于尚未发生的进位传播。一个大的正和向量可能会因为一个贯穿最终加法的[行波](@article_id:323698)进位而变为负数。

同样，你无法通过仅仅检查中间向量来轻易检测[算术溢出](@article_id:342417)。溢出是由最终传播过程中*进入*最高有效位的进位与*出自*该位的进位之间的关系定义的 [@problem_id:1918759]。在 CPA 解析该传播之前，检查溢出所需的信息是潜在的，隐藏在和位与进位位之间复杂的相互作用中。

这是进位保留加法器的根本权衡。它通过延迟进位传播的艰巨工作来获得其惊人的速度。但这样做，它产生了一个在算术上正确但尚未“完成”的中间结果。在支付最后一次进位传播加法的最终代价之前，你无法向它询问关于其大小或符号的简单问题。在硬件设计的世界里，就像在生活中一样，没有免费的午餐。但对于原始求和速度至关重要的应用来说，进位保留加法器的这顿午餐物有所值。