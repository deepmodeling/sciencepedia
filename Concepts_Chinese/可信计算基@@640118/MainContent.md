## 引言
在数字世界中，我们如何能确定一台计算机正在执行我们期望的操作，而不是攻击者的指令？这个关于信任的问题是所有计算机安全的基石。从消息的私密性到银行账户的完整性，每一项安全保障都依赖于一组核心组件的正确行为。如果这些基础部件中哪怕只有一个遭到破坏，整个安全结构就会崩溃。这个至关重要的基础被称为**可信计算基（Trusted Computing Base, TCB）**。它要解决的核心问题是：复杂性是安全之敌；每增加一行代码，都可能成为隐藏缺陷的地方。因此，安全系统设计的核心原则就是让 TCB 尽可能地小且易于验证。

本文将深入剖析可信计算基的理论与实践。在第一章**“原理与机制”**中，我们将探讨信任的基本机制。我们将定义 TCB，研究不同的[操作系统](@entry_id:752937)架构如何显著改变其规模，并剖析如[安全启动](@entry_id:754616)（Secure Boot）和[度量启动](@entry_id:751820)（Measured Boot）等加密过程，这些过程从一个不可变的硬件[信任根](@entry_id:754420)开始构建起一条“[信任链](@entry_id:747264)”。随后，在**“应用与跨学科联系”**一章中，我们将展示 TCB 并非仅仅是[操作系统](@entry_id:752937)设计者的抽象概念。我们将看到，这个单一理念如何为我们提供一个强大的视角，用以分析从智能手机、云服务器到构建软件的工具本身，乃至进行科学研究的仪器等万物的安全性。

## 原理与机制

### 究竟什么是信任？可信计算基

想象一下，你需要发送一封密信。你写好信，封入信封，然后交给一位你信任的信使。用计算机安全的语言来说，这位信使就是你的**可信计算基（TCB）**的一部分。你依赖他，且只依赖他，来确保你的信件安全送达。你整个系统的安全都压在他的肩上。如果这位信使诚实且能干，你的秘密就是安全的。但如果他被欺骗、被胁迫，或者仅仅是犯了个错，整个系统就失败了。

在计算机中，TCB 是所有硬件、固件和软件组件的集合，这些组件的正确性对于执行系统安全策略至关重要。它是我们绝对必须依赖的所有“信使”的集合。这包括[操作系统内核](@entry_id:752950)的部分、启动计算机的固件，甚至某些硬件部件。如果这个神圣圈子内的任何一个组件存在缺陷或恶意，游戏就结束了，任何安全保证都无从谈起。

这就引出了安全系统设计的第一条，也是最重要的一条戒律：**让 TCB 尽可能小。**

这不仅仅是一句含糊的口号，而是一条严酷的[概率法则](@entry_id:268260)。每一行代码都可能存在一个漏洞，而其中一些漏洞可能演变成安全缺陷。可以这样想：如果每行代码存在一个严重缺陷的微小独立概率为 $\beta$，那么你的 TCB 中预期的缺陷总数就是代码行数 $N$ 乘以 $\beta$。“预期的漏洞面”与其规模成正比 [@problem_id:3639726]。更复杂的模型可能会使用[泊松分布](@entry_id:147769)，但结论是相同的：更大的 TCB 意味着更大的攻击面，为缺陷提供了更多的藏身之处，也为攻击者提供了更多的可乘之机 [@problem_id:3687912]。一个小的 TCB 是我们有希望进行形式化验证、严格审计并最终信任的。

### 四种架构的故事

TCB 的大小不仅仅是编程纪律的问题，它也是[操作系统](@entry_id:752937)架构中基本设计选择的直接结果。让我们通过 TCB 的视角来比较四种不同的哲学 [@problem_id:3640406]。

**单核内核（monolithic kernel）**是传统的、一体化的设计。文件系统、网络协议栈、[设备驱动程序](@entry_id:748349)、[内存管理](@entry_id:636637)——几乎所有东西都存在于一个以[最高权](@entry_id:202808)限运行的庞大程序中。对于一个只需要做一件简单事情的应用程序来说，其 TCB 仍然是这个庞然大物。TCB 的规模巨大且实际上是恒定的，与应用程序的需求无关。其规模随应用程序使用的功能数量 $f$ 呈 $O(1)$ 扩展，但这个常数非常巨大。这就像为一个小小的柠檬水摊建造一座摩天大楼；无论你用一个房间还是一千个，地基都同样广阔。

为了应对这种复杂性，**微内核（microkernel）**哲学应运而生。在这里，内核被精简到最基本的要素：程序间通信的机制（[进程间通信](@entry_id:750772)或 IPC）、基本的调度和底层的内存管理。其他所有东西——驱动程序、文件系统、网络协议栈——都被 relegated 到称为服务器的用户空间进程中。内核本身的 TCB 非常小。然而，如果你的应用程序需要使用网络，它必须与网络服务器通信，该服务器现在是控制硬件的可信中介。该服务器成为你应用程序 TCB 的一部分。因此，总的 TCB 大小与你使用的功能数量成[线性增长](@entry_id:157553)，规模为 $O(f)$。这是一种更模块化的方法，就像拥有一个小型中央办公室，并根据需要租用特定的、可信的服务。

**外核（exokernel）**将这种极简主义推向了极致。内核的唯一工作就是安全地划分硬件资源，然后“让路”。它提供保护，但几乎不提供抽象。所有传统的“[操作系统](@entry_id:752937)服务”都在与应用程序直接链接的库中实现，并在该应用程序的非特[权空间](@entry_id:195741)中运行。TCB 仅仅是那个微小的外核本身，其大小再次是一个很小的常数，$O(1)$。到目前为止，这是所有架构中 TCB 最小的。这就像给开发者们各自一块围起来的土地，让他们在不侵犯他人的前提下随心所欲地建造。

最后，**单内核（unikernel）**提供了一种定制化的解决方案。应用程序代码和仅必需的库[操作系统](@entry_id:752937)组件被编译成一个单一的、专门的镜像，直接在硬件或 hypervisor 上运行。整个镜像都以内核权限运行。因此，TCB 包括了应用程序所需的所有[操作系统](@entry_id:752937)库。与微内核一样，其大小随 $f$ 呈 $O(f)$ 扩展，但由于用户空间和内核空间之间没有分离，组件可以被高度优化，并且通常更小。这是终极的定制机器，不包含任何无关的东西。

### 从零开始建立信任：[信任链](@entry_id:747264)

好了，我们设计了一个具有最小 TCB 的系统。但是，当计算机开启时，我们如何知道 TCB *内部*的组件是正确的呢？我们必须从一个无懈可击的基础之上建立信任。这个基础就是**[信任根](@entry_id:754420)（Root of Trust）**，一个天生值得信赖的组件，通常因为它具有[不可变性](@entry_id:634539)——代码被[蚀刻](@entry_id:161929)在主板上一个无法更改的[只读存储器](@entry_id:175074)（ROM）芯片中。

从这个单一的信任点，我们可以构建一条延伸至整个系统的**[信任链](@entry_id:747264)（Chain of Trust）**。它的工作方式就像一系列的交接 [@problem_id:3664845]：

1.  不可变的[信任根](@entry_id:754420)（我们称之为第 0 阶段）启动。它的第一个也是唯一的工作是验证启动过程的下一阶段，即第 1 阶段（例如，主固件）。
2.  如果第 1 阶段被验证，第 0 阶段就交出控制权。第 1 阶段现在是可信的。
3.  然后，第 1 阶段验证第 2 阶段（例如，[操作系统](@entry_id:752937)[引导加载程序](@entry_id:746922)）。如果验证通过，它就交出控制权。
4.  这个过程持续进行，[信任链](@entry_id:747264)中的每个可信环节在执行前都会验证下一个环节。

每一步的验证都不是简单的检查，而是一个包含三部分的加密仪式：
*   **真实性（Authenticity）**：验证者检查下一阶段代码的**[数字签名](@entry_id:269311)**。这确认了代码来自可信的供应商（如微软或苹果），而不是攻击者。
*   **完整性（Integrity）**：验证者计算代码的**密码学哈希**（如 SHA-256），并将其与被签名的哈希值进行比较。这证明了代码自供应商签名以来未被篡改或损坏。
*   **新鲜性（Freshness）**：验证者检查嵌入在代码中的版本号是否不低于**单调计数器**中的值。单调计数器是一种特殊的硬件存储器，其值只能增加。这可以防止攻击者诱使系统加载一个较旧的、虽有签名但已知存在漏洞的组件版本——即“回滚攻击”。

从不可变的根到完全加载的[操作系统](@entry_id:752937)，这整个强制执行过程就是我们所说的**[安全启动](@entry_id:754616)（Secure Boot）**。其目标是**强制执行**一个简单的策略：只允许运行真实的、未被篡改的、最新的代码。

### 知晓与阻止：信任的两个方面

[安全启动](@entry_id:754616)非常强大，但它的视野很窄。它只关心可执行代码的真实性。那么其他一切呢？

考虑一个简单而现实的攻击：一个对手暂时接触到一台机器，并修改了[引导加载程序](@entry_id:746922)配置文件中的内核命令行。他们可能会添加一个像 `selinux=0` 这样的参数来禁用一个关键的安全模块。当计算机重启时，[安全启动](@entry_id:754616)会检查[引导加载程序](@entry_id:746922)和内核。它会发现它们的签名都是完美的。它对命令行一无所知；那只是配置数据。于是，它允许启动 [@problem_id:3679609]。系统在一个危险的弱化状态下启动，而[安全启动](@entry_id:754616)对此毫不知情。

这揭示了对另一种机制的需求，其工作不是强制执行，而是**报告**。这就是**[度量启动](@entry_id:751820)（Measured Boot）**和**[可信平台模块](@entry_id:756204)（Trusted Platform Module, [TPM](@entry_id:170576)）**的角色。

[TPM](@entry_id:170576) 是主板上的一个小型、专门的安全芯片。它包含一组**平台配置寄存器（Platform Configuration Registers, PCRs）**。在[度量启动](@entry_id:751820)期间，当每个组件即将被加载时——无论是可执行代码、驱动程序，还是像内核命令行这样的配置文件——都会计算其[密码学](@entry_id:139166)哈希。这个哈希随后被“扩展”（extend）到一个 PCR 中。扩展操作是特殊的：$PCR_{new} = H(PCR_{old} \Vert \text{measurement})$。这是一条单行道。你不能擦除一个度量值或回退；你只能向链中添加内容。

结果是，在启动过程结束时，PCR 的值是记录下所发生每一件事情的唯一加密指纹。在我们的命令行攻击场景中，[引导加载程序](@entry_id:746922)作为 TCB 的可信部分，会尽职地度量*被修改过的*命令行，并将其扩展到 PCR 中。最终的 PCR 值现在将与正常启动时的值不同。

回报来自于**[远程证明](@entry_id:754241)（Remote Attestation）**。远程服务器可以向计算机发起质询，要求 [TPM](@entry_id:170576) 提供其当前的 PCR 值。TPM 使用一个它从不泄露的唯一秘密密钥——证明密钥（Attestation Key）——来对 PCR 值进行签名，并发送给服务器。服务器随后可以将这份签名的报告与一个安全配置系统的“已知良好” PCR 值进行比较。当它看到不匹配时，它就获得了系统偏离安全基线的加密证明。它可能不确切知道原因，但它知道不应信任该系统，并可以拒绝其访问网络或敏感数据。

因此，我们有两个互补的系统：**[安全启动](@entry_id:754616)强制执行，[度量启动](@entry_id:751820)报告。**它们共同为信任提供了坚实的基础。

### 细节中的魔鬼：[信任链](@entry_id:747264)中的微妙缺陷

即使有了这套精美的加密机制，构建一条真正安全的链条仍然充满了危险。物理硬件和并发操作的世界引入了一些微妙的方式来破坏信任。

其中最阴险的一种是**[检查时-使用时](@entry_id:756030)（Time-of-Check to Time-of-Use, [TOCTOU](@entry_id:756027)）**攻击。想象一下[引导加载程序](@entry_id:746922)的操作序列 [@problem_id:3679566]：
1.  从硬盘将操作系统内核加载到内存中。
2.  **检查**其签名和哈希。一切正常！（这是检查时）。
3.  跳转到内存中内核的入口点开始执行。（这是使用时）。

在第 2 步和第 3 步之间的微小时间间隔内会发生什么？可能会发生很多事。许多现代外围设备，如网卡和存储控制器，可以在不涉及 CPU 的情况下直接写入主内存，这一特性称为**直接内存访问（Direct Memory Access, DMA）**。如果这些设备之一上的恶意固件处于活动状态，它可能会在 CPU 跳转到完美验证过的内核之前仅几纳秒内，用恶意载荷覆盖它。系统验证了一个有效的内核，但执行了恶意软件。

这打破了“等价[不变性](@entry_id:140168)”——即你验证的就是你执行的这一关键假设。它也教会我们一个深刻的教训：我们的 TCB 不仅必须包括那些*执行*验证的组件，还必须包括任何有能力在验证结果被使用前*使其失效*的组件。在这种情况下，控制支持 DMA 设备的存储驱动程序本身必须成为 TCB 的一部分 [@problem_id:3679566]。一个更广泛的解决方案是使用一个名为**输入输出[内存管理单元](@entry_id:751868)（Input-Output Memory Management Unit, [IOMMU](@entry_id:750812)）**的硬件组件。它充当 DMA 的防火墙，系统固件应在加载任何复杂驱动程序之前，用“默认拒绝”策略对其进行配置，确保没有任何外围设备可以写入它不拥有的内存 [@problem_id:3664551]。

### 当信任还不够时：后启动世界

我们的系统现在已经启动。[信任链](@entry_id:747264)是完美的。度量值是正确的。我们正在运行真实的、由供应商提供的代码。我们终于安全了吗？

不。

这可能是可信计算中最重要的教训。一个组件是 TCB 的一部分意味着它是*可信的*，而不是说它是*值得信赖的*或无漏洞的。[数字签名](@entry_id:269311)是来源的声明，而不是完美的保证。

考虑一个由供应商签名的内核驱动程序。它经过了[安全启动](@entry_id:754616)的验证和 [TPM](@entry_id:170576) 的度量。它是 TCB 不可或缺的一部分。但它包含一个微妙的漏洞——一个[缓冲区溢出](@entry_id:747009)。一个现在作为普通用户运行的攻击者可以构造一个特殊的输入来触发这个漏洞，劫持驱动程序的执行，并获得系统的完[全控制](@entry_id:275827)权 [@problem_id:3679560]。[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)在这里无能为力；它们的任务在驱动程序被加载的那一刻就已完成。它们是启动时技术，而这是一个运行时攻击。

这表明 TCB 并非一座一旦建成便坚不可摧的堡垒。它是我们必须用额外的安全层来捍卫的关键阵地。
*   **运行时防御**：我们需要能够实时防范漏洞利用的技术。**[控制流完整性](@entry_id:747826)（Control-Flow Integrity, CFI）**就是这样一种防御措施，它可以防止攻击者将程序的执行重定向到恶意代码片段（一种称为 ROP 或 JOP 的技术） [@problem_id:3679560]。
*   **[最小权限原则](@entry_id:753740)**：限制一个受损 TCB 组件造成损害的最佳方法是削弱其权力。如果那个易受攻击的驱动程序可以被重新设计，在一个隔离的、[沙盒](@entry_id:754501)化的进程中运行，只拥有它所需要的最小能力，那么它的被攻破将不再意味着整个系统被接管 [@problem_id:3679560]。这是微内核等架构背后的动机。
*   **动态信任**：[信任链](@entry_id:747264)不能在启动时结束。它必须是一个动态的过程。当通过**热补丁（live patching）**将一个关键的安全修复应用于正在运行的内核时，该补丁本身必须被签名并度量到 TPM 中。这将[信任链](@entry_id:747264)扩展到新的代码，确保一份证明报告总是反映*实际*正在运行的代码，而不仅仅是启动时运行的代码 [@problem_id:3679581]。同样的原则也适用于[操作系统](@entry_id:752937)动态加载一个新库时；可信的[操作系统](@entry_id:752937)加载程序负责在这些新代码运行前度量它，将信任图扩展到系统的运行时生命周期中 [@problem_id:3679583]。

可信计算基不仅仅是一组组件，它是一项指导原则。它迫使我们在系统的每个层面直面“我们信任谁，以及为什么？”这个问题。建立这种信任是一个旅程，从一块不可变的硅片[信任根](@entry_id:754420)开始，经过一条加密的交接链条，进入一个运行中系统的动态、混乱的世界。这是一个永无止境的过程。

