## 引言
在并行计算的世界里，协调对共享数据的访问是一个核心挑战。几十年来，锁一直是标准的解决方案，但它们也引入了一系列自身的问题，包括性能瓶颈和可怕的死锁可能性。本文探讨了一种强大的替代方案：无锁[数据结构](@entry_id:262134)，这是一种无需使用传统锁即可实现高性能并发的[范式](@entry_id:161181)。通过采用一种乐观的方法，这些结构允许线程并行工作，通过简短的原子操作进行协调。我们将从第一性原理出发，直至探讨其在现实世界中的影响，从而对这个优雅而重要的话题提供全面的理解。第一章“原理与机制”将解构其核心概念，从[比较并交换](@entry_id:747528)（CAS）操作到臭名昭著的 ABA 问题及其解决方案。随后，“应用与跨学科联系”一章将揭示这些基础思想如何驱动从可扩展软件和[操作系统](@entry_id:752937)到硬件和[分布式计算](@entry_id:264044)的进步。

## 原理与机制

要真正理解任何思想，我们必须将其剥离至本质，并从第一性原理重新构建它。我们的话题——无锁[数据结构](@entry_id:262134)——也不例外。它代表了我们思考如何在并行世界中协调工作方式的根本性转变。我们不再要求线程在天鹅绒绳索后排成有序队列，而是邀请它们进入一个繁华开放的广场，在这里它们可以自由工作，通过简短、礼貌的握手进行协调。本章旨在探讨这个广场的规则以及支配它的优美而微妙的物理学。

### 乐观主义者的博弈：一个没有锁的世界

几十年来，并发访问问题的答案一直是**锁（lock）**，或称**[互斥锁](@entry_id:752348)（mutex）**。这是一个简单而强大的想法：一次只有一个线程可以持有通往“[临界区](@entry_id:172793)”的钥匙。这确保了秩序，防止了混乱。但是，锁尽管有其效用，却也伴随着沉重的代价。它们可能导致**[死锁](@entry_id:748237)（deadlock）**，这是一种悲剧性的情景，两个或多个线程被冻结，每个线程都在等待对方持有的锁。想象两个人各需要两把钥匙，每个人都拿着一把，并拒绝交出，直到得到另一把——这是一种数字僵局。摆脱锁就意味着摆脱这种[死锁](@entry_id:748237)，因为我们打破了死锁发生的必要条件之一“[持有并等待](@entry_id:750367)”[@problem_id:3631834]。

此外，在高强度竞争下，锁可能成为性能瓶颈。在现代多核处理器上，想象一个用 `Test-and-Set` 指令实现的简单锁。可能有数十个核心同时尝试获取这个锁。每一次失败的尝试都是一次写操作，这会告知处理器的[缓存一致性](@entry_id:747053)系统：“我修改了这个内存位置！”这导致包含该锁的缓存行在所有竞争的核心之间疯狂地来回穿梭——这种现象称为**缓存行乒乓（cache line ping-pong）**。互连总线被淹没，性能陷入停滞。这就像一个房间里所有人都同时大喊大叫；谁的声音也听不见[@problem_id:3686876]。

那么，替代方案是什么？我们拥抱乐观主义。我们乐观地假设冲突不会发生，而不是悲观地假设冲突会发生并锁定一切。一个线程就像拥有独占访问权限一样继续执行，只有在最后一刻，它才会检查其假设是否正确。这个检查并更新的步骤必须是**原子的（atomic）**——一个不可分割的操作，要么完全完成，要么根本不发生。

这个乐观主义世界的主力是一种称为**[比较并交换](@entry_id:747528)（Compare-and-Swap）**或 **CAS** 的[原子指令](@entry_id:746562)。其逻辑非常简单：

```
CAS(memory_location, expected_value, new_value)
```

它的意思是：“查看这个 `memory_location`。如果——且仅当——它的值仍然是我*期望*它应有的值时，就用这个 `new_value` 更新它。然后告诉我是否成功。”

让我们通过一个简单的共享栈来看看它的实际应用。一个基于锁的 `push` 操作会获取一个锁，更新栈的 `head` 指针，然后释放锁。而一个无锁的 `push` 则是一支舞蹈：

1.  创建一个新节点。
2.  读取当前的 `head` 指针。我们称之为 `old_head`。
3.  将新节点的 `next` 指针设置为 `old_head`。
4.  尝试 `CAS(head, old_head, new_node)`。

如果 `CAS` 成功，我们的工作就完成了！如果失败，则意味着在我们工作期间，另一个线程抢先一步改变了 `head` 指针。没问题。我们只需回到第 2 步，用新的 `head` 再试一次。我们正在创建一个新节点，但随后直接修改现有列表结构中的一个指针字段，这是一种**原地（in-place）**修改[@problem_id:3240969]。我们没有使用任何锁就实现了我们的目标。死锁已不在考虑之列。

### 乐观的代价：新型麻烦

这种新获得的自由并非没有代价。通过放弃锁的严格序列化，我们遇到了一类新的、更微妙的问题。

#### [活锁](@entry_id:751367)：西西弗斯的舞蹈

如果一个线程永远运气不佳会发生什么？它读取 `head`，准备更新，但在其 `CAS` 执行前，另一个线程成功了。它再试一次。又一次。再又一次。整个系统在取得进展——其他线程正在完成它们的工作——但我们这个可怜的不幸线程却陷入了无休止的重试循环。这被称为**饥饿（starvation）**或**[活锁](@entry_id:751367)（livelock）**。它违反了经典的“有界等待”属性，该属性保证一个线程在有限数量的其他线程先行后，最终会轮到它[@problem_id:3687382]。无锁的保证只针对系统整体，而不针对单个线程。

解决方案出奇地人性化：礼貌。当线程发生冲突（即 `CAS` 失败）时，它们应该退避片刻再重试。一个简单的固定延迟是个坏主意，因为它可能导致线程以同步的波次重试，从而引发更多冲突。一种好得多的方法是**[随机化](@entry_id:198186)指数退避（randomized exponential backoff）**。每次失败后，线程会在一个随失败次数呈[指数增长](@entry_id:141869)的区间内等待一个*随机*的时长。这可以使线程去同步化，并优雅地适应竞争的程度。

在一个有调度优先级的系统中，我们可以更聪明。我们可以实现**优先级感知的退避（priority-aware backoff）**，即低优先级线程被编程为比高优先级线程退避更长的时间。这给了高优先级工作更好的成功机会，减轻了即使没有锁也可能发生的一种[优先级反转](@entry_id:753748)形式[@problem_id:3663934]。

#### 机器中的幽灵：ABA 问题

现在我们来讨论[无锁编程](@entry_id:751419)中最著名、最微妙、也最引人入胜的问题：**ABA 问题**。这是一个鬼故事。`CAS` 操作将内存位置的*当前值*与[期望值](@entry_id:153208)进行比较。它对该位置的历史一无所知。

再想象一下我们的无锁栈。`head` 指向节点 $A$，节点 $A$ 指向节点 $B$。
1.  线程 $T_1$ 想要弹出一个节点。它读取 `head`，得到指针 $A$。它计算出新的头应该是 $B$。现在它准备执行 `CAS(head, A, B)`。
2.  但在它执行之前，调度器让 $T_1$ 进入休眠。
3.  在 $T_1$ 休眠期间，发生了一系列 whirlwind of activity。线程 $T_2$ 出现并弹出了 $A$。现在栈顶是 $B$。然后 $T_2$ 释放了节点 $A$ 的内存。
4.  接着，$T_2$（或另一个线程）想要推入一个新节点 $C$。[内存分配](@entry_id:634722)器为了效率，将最近释放的内存块——即先前属于 $A$ 的*完全相同的地址*——分配给了它。
5.  $T_2$ 推入这个新节点 $C$，它现在位于地址 $A$。栈的 `head` 指针现在再次是值 $A$。
6.  最后，$T_1$ 醒来！它继续其原计划：`CAS(head, A, B)`。它检查 `head`。它的值是 $A$ 吗？是的！`CAS` 成功，`head` 被设置为 $B$。

你看到灾难了吗？节点 $C$（在地址 $A$）本是栈的真正顶部，但它刚刚被悄无声息地断开链接并永远丢失了。[数据结构](@entry_id:262134)现在已经损坏。这就是 ABA 问题的实际表现[@problem_id:3687331]。它的发生是因为“指针相等意味着逻辑对象身份相同”这一[不变性](@entry_id:140168)被打破了[@problem_id:3226035]。地址是相同的，但节点的灵魂已经不同。

### 驱逐幽灵：回收内存与理智

我们如何与幽灵战斗？我们要么给我们的工具看到它的能力，要么确保它从一开始就无法出现。

#### 解决方案 1：[版本控制](@entry_id:264682)和标签指针

第一种方法是让我们的 `CAS` 更智能。我们不只存储一个指针，而是存储一个**标签指针（tagged pointer）**：一个由指针和版本计数器组成的对。这个对通常被打包成一个 64 位或 128 位的字，可以用一个双倍宽度的 `CAS` 进行更新。

每当 `head` 成功更新时，我们就增加版本计数器。在我们的鬼故事中，初始状态将是 `(A, version=7)`。当 $T_1$ 醒来时，它将尝试 `CAS(head, (A, version=7), (B, version=8))`。但是中间的操作会多次改变 `head`，每次改变都会增加版本计数器。当前的 `head` 可能是 `(A, version=9)`。由于 `(A, version=9)` 不等于期望的 `(A, version=7)`，`CAS` 会正确地失败，灾难得以避免[@problem_id:3687331]。我们建立了一个新的、更强的[不变性](@entry_id:140168)：标签对的相等意味着状态相同[@problem_id:3226035]。另一种硬件原语，**加载链接/条件存储（Load-Linked/Store-Conditional, [LL/SC](@entry_id:751376)）**，通过在*任何*写操作发生在该位置时（而不仅仅是值改变时）使存储失败，从而自然地解决了这个问题[@problem_id:3621240]。

#### 解决方案 2：安全[内存回收](@entry_id:751879)

第二种理念是根本不让幽灵实体化。ABA 问题的发生是因为内存被过快地释放和重用。安全[内存回收](@entry_id:751879)方案确保只要有某个线程可能仍然持有指向一个内存块的指针，该内存块就不会被释放。

*   **风险指针（Hazard Pointers, HP）：** 这是最直接的方法。每个线程维护一个小的、公开可见的“风险指针”列表。在一个线程解引用它从共享内存中读取的指针之前，它将该指针放在其风险列表中。这就像贴上一个“油漆未干”的标志。一个全局的[内存回收](@entry_id:751879)服务只会在一个节点的地址没有出现在*任何*线程的风险列表上时，才会释放该节点。一旦线程完成了对该节点的操作，它就会移除这个标志。这恢复了“指针的值在操作期间唯一标识节点”这一简单的不变性，使得简单的 `CAS` 再次变得安全[@problem_id:3226035] [@problem_id:3621240]。

*   **基于纪元的回收（Epoch-Based Reclamation, EBR）：** 这是一种更具[可扩展性](@entry_id:636611)、面向批处理的方法。想象一个全局时钟，或称**纪元（epoch）**，它会周期性地推进。当一个线程想要移除一个节点时，它并不释放它。相反，它将节点放入一个“退役”列表，并标记上当前的纪元号。一个在纪元 $E$ 退役的节点，只有当可以确定系统中每一个线程都已通过一个**静止状态（quiescent state）**（即不持有任何指向共享节点的指针的时刻）并且现在正在一个晚于 $E$ 的纪元中操作时，才能被安全地释放。这保证了不可能有任何线程持有指向那个节点的指针。EBR 对于主要操作来说效率极高，因为回收工作被推迟并分批完成，保留了面向用户的算法的无锁特性[@problem_id:3687328] [@problem_id:3621240]。

### 沟通的艺术：[内存排序](@entry_id:751873)

这个故事还有最后一个深层次。现代处理器为了不懈地追求性能，是会说谎的。它们被允许重排内存操作。一个线程可能执行 `write A` 然后 `write B`，但另一个核心可能观察到 `write B` 发生在 `write A` 之前。对于单线程代码，这种错觉被完美地维持着，但对于并发代码，这可能是灾难性的。

考虑一个单生产者、单消费者的队列。生产者将一个项目写入一个槽位，*然后*更新一个 `tail` 指针来公布该槽位已准备就绪。消费者读取 `tail` 指针，看到它已前进，于是继续从槽位中读取项目。如果消费者的核心在看到数据写入*之前*就看到了 `tail` 指针的更新，会发生什么？它将读到垃圾数据[@problem_id:3625556]。

为了防止这种情况，我们需要建立一个“先于发生”（happens-before）的关系。我们在[原子操作](@entry_id:746564)上使用特殊的[内存排序](@entry_id:751873)语义。
*   生产者对 `tail` 指针的更新必须是一个**释放（release）**操作。这充当一个屏障：“在此点之前我所做的所有内存写入，必须在此 `release` 存储操作对其他核心可见之前变得可见。”
*   消费者对 `tail` 指针的读取必须是一个**获取（acquire）**操作。这是一个匹配的屏障：“如果我看到了那个 `release` 存储的结果，我保证也能看到在它之前发生的所有内存写入。”

`release-acquire` 对形成了一个同步通道。这是确保生产者和消费者就世界状态达成一致所需的最小通信。这是一个仅使用足够同步来完成工作，而没有使用像[顺序一致性](@entry_id:754699)这样更强模型的重手法的优美例子。

[无锁编程](@entry_id:751419)是一段从一个 `CAS` 循环的欺骗性简单到[内存回收](@entry_id:751879)和 CPU [内存模型](@entry_id:751871)深水区的旅程。它并非一条比使用锁更容易的道路，但它是一条通往对并发更深刻理解的道路，并且在正确导航时，可以产生性能和优雅度都非凡的算法。它是在软件与硬件物理现实交界处编排一场优美而复杂舞蹈的艺术。

