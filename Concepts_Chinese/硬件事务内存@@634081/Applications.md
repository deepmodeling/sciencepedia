## 应用与跨学科联系

在我们之前的讨论中，我们揭示了硬件[事务内存](@entry_id:756098)的精妙机制。我们看到了硬件如何凭借其对内存的敏锐观察，有望解开锁和[互斥锁](@entry_id:752348)这个棘手的难题。但原理是一回事，实践是另一回事。我们能用这种新获得的力量*做*些什么？它将我们引向何方？在本章中，我们将踏上一段旅程，去看看 HTM 在实际应用中的表现。我们将看到它如何改变编程的艺术，重塑我们[操作系统](@entry_id:752937)和编译器的基础，并且在一个引人入胜的转折中，甚至在[网络安全](@entry_id:262820)世界开辟了一条新的战线。这不仅是一个关于应用的故事，也是一个关于硬件、软件以及[计算逻辑](@entry_id:136251)本身之间美妙而常常出人意料的相互作用的故事。

### 驯服并发这头野兽

任何与[并发编程](@entry_id:637538)搏斗过的人都知道竞争条件的恐怖和[无锁算法](@entry_id:752615)令人费解的复杂性。使用像[比较并交换](@entry_id:747528) (CAS) 这样的原语编写正确的代码就像走钢丝，常常导致复杂的循环，这些循环难以编写、更难阅读，而且几乎不可能证明其正确性。HTM 带来了一股清新的空气。它允许我们用一个简单的声明性语句来取代那些繁复的结构：“这个代码块应该是原子的。” [@problem_id:3645961] 硬件负责处理跟踪内存访问和确保原子性的复杂舞蹈。虽然一个经过精细调优的 CAS 循环在特定的低竞争场景下可能仍然能挤出更多性能，但使用 HTM 在程序员生产力和代码正确性方面的提升通常是不可估量的。它让我们能够专注于*做什么*，而不是*怎么做*。

这种优雅的一个美妙例证是一种称为[事务性锁省略](@entry_id:756097) (TLE) 的技术，它可以显著加速一种常见的同步模式：[读写锁](@entry_id:754120)。想象一个共享[数据结构](@entry_id:262134)，它被非常频繁地读取，但很少被写入。为每次读取获取锁的开销似乎很浪费，尤其是在没有写入者的情况下。通过 TLE，读取线程可以“省略”锁的获取。它们推测性地开始一个硬件事务，并直接继续读取数据，但有一个关键的补充：在事务内部，它们也读取写入者自己的锁变量。这次读取就像一个“绊网”。如果一个写入线程到达，它的第一个动作是获取锁，这涉及到对那个锁变量的写入。*铛！* 绊网被触发了。HTM 硬件检测到写-读冲突，并立即中止所有活动的读取者事务。[@problem_id:3675658] 这些被中止的读取者随后会回退到更慢、更安全的路径，即获取一个正常的读锁。结果是神奇的：在常见的、无写入者的情况下，读取者以全速进行，同步开销为零。

然而，这个故事有一个关键的后记：公平性。HTM 事务可能因多种原因中止，理论上，一个线程可能会陷入无休止的重试循环中，即[活锁](@entry_id:751367)状态。为了防止线程饿死，一个健壮的系统必须有一个后备计划。在几次事务尝试失败后，线程应该放弃推测，回退到一个传统的、*公平的*锁，该锁使用队列来保证所有等待的线程最终都能获得访问权。[@problem_id:3687724] HTM 并非包治百病的灵丹妙药，它不能免除我们进行仔细设计的需要；它是设计者工具箱中一个强大的新工具。

### 构建可扩展系统

HTM 的性能看似神奇，但它的根基牢牢地扎在内存系统的硅片中。事务的生死存亡取决于[缓存一致性协议](@entry_id:747051)的“恩典”。要编写可扩展的 HTM 代码，必须像硬件一样思考。

想象两个程序员，在不同的房间里，更新一个共享日志本中的两个不同条目。这应该没问题。但如果他们不知道，他们的两个条目在同一个物理页面上呢？每当一个人写入时，图书管理员（一致性协议）就会从另一个人手中抢走该页面，大喊“冲突！”。这就是*[伪共享](@entry_id:634370)*的本质。在 HTM 中，这表现为令人抓狂的频繁中止。如果我们有一个包含许多小计数器（比如 8 字节整数）的数组，并将它们紧密地打包在内存中，我们可能会无意中将其中八个放在一个 64 字节的缓存行上。当八个不同的线程试图更新它们各自的“私有”计数器时，硬件看到的是八个线程在争夺一个缓存行，事务便会接二连三地中止。解决方案是反直觉但深刻的：我们有时必须浪费空间来换取速度。通过对每个计数器进行填充，使其各自占据一整个缓存行，我们确保了对不同计数器的更新发生在不同的缓存行上。伪冲突就消失了。[@problem_id:3645987]

这个原则——最小化事务足迹并避免真实和虚假的竞争——是实现[可扩展性](@entry_id:636611)的关键。我们可以在大型[并发数据结构](@entry_id:634024)（如多生产者、多消费者队列）的设计中看到这一点。一个幼稚的设计可能会将整个‘入队’或‘出队’操作包装在一个大事务中。这会造成一个瓶颈，因为每个操作都会在队列的头指针和尾指针上产生竞争。一个更好的设计是将数据结构划分为更小的、独立的块，并使用短小的、局部的事务，这些事务每次只触及一个块，从而极大地降低了冲突的概率。[@problem_id:3645973]

### 宏大的共生：HTM 与系统软件

HTM 不仅适用于应用程序开发者。它深刻地影响着我们构建的最复杂的软件：[操作系统](@entry_id:752937)和编译器。

#### 在[操作系统内核](@entry_id:752950)中

对正确、高效并发的需求，在[操作系统](@entry_id:752937)的心脏地带——内核中，比任何地方都更为关键。考虑将一个正在运行的进程从一个 CPU 核心迁移到另一个核心的任务。这是一个出奇精细的操作。调度器必须更新进程的状态，将其从旧 CPU 的运行队列中移除，并添加到新 CPU 的运行队列中——所有这些操作都要确保系统的另一部分不会，例如，改变进程的 CPU 亲和性，从而使迁移变得非法。传统上，这需要会损害[可扩展性](@entry_id:636611)的粗粒度锁，或者容易引入错误的复杂细粒度锁。HTM 提供了一个惊人简单的解决方案：将整个迁移逻辑包装在一个单一的事务中。[@problem_id:3663935] 所有相关的更新——对任务结构、对两个运行队列的更新——都作为一个单一的、原子的单元提交。调度器的[不变量](@entry_id:148850)被毫不费力地保持了。当然，在一个永远不能真正阻塞的[操作系统内核](@entry_id:752950)中，这个事务路径必须与一个健壮的、非阻塞的回退路径（可能使用 CAS）配对，以保证即使在重度竞争下也能取得进展。

#### 在智能编译器中

HTM 的出现给编译器世界带来了涟漪，改变了旧规则，创造了新机会。一个经典的[编译器优化](@entry_id:747548)，如[循环不变代码外提 (LICM)](@entry_id:751466)——它将循环内恒定的计算提升到循环之前——突然变得危险。如果这个“[不变量](@entry_id:148850)”是对一个共享变量的读取，而循环体是一个事务，那么将读取操作外提意味着事务现在对该变量的并发写入是“盲目”的。编译器破坏了事务本应提供的隔离性！[@problem_id:3654735] 为了安全地执行此优化，编译器必须变得更聪明：它要么必须证明该变量是真正不可变的，要么必须在事务内部重新插入一个验证检查，以确保外提的值仍然是最新的。

同时，HTM 也使编译器能够更加激进。一个预先 (AOT) 编译器可以为一个[临界区](@entry_id:172793)生成两个版本的代码——一个使用锁，一个使用 HTM——并使用运行时的 CPUID 检查来为它所在的硬件选择最佳路径，从而允许程序根据其环境进行自我优化。[@problem_id:3620685] 在最先进的场景中，HTM 成为构建全新并行化方式的基石。考虑一个操作顺序很重要的循环（它们是非交换的）。编译器可以推测性地将所有迭代作为独立的事务并行执行，但使用一个共享的“票号计数器”来确保它们以正确的顺序*提交*。[@problem_g_id:3622680] 这允许了大规模的并行性，同时严格保持了原始程序的逻辑——这是仅使用传统锁无法想象的壮举。

### 意料之外的后果：一个新的攻击面

每项强大的技术都会投下阴影，HTM 也不例外。它确保正确性的机制——内存冲突的检测——可以被用于一个更黑暗的目的：窃取秘密。

想象一个攻击者程序在一个核心上运行，而一个受害者程序在另一个核心上处理敏感数据。攻击者可以启动一个只读事务，该事务仅仅读取与特定数据（比如一个哈希表桶）相关联的内存地址。与此同时，受害者的操作（依赖于一个密钥）可能会也可能不会访问同一个桶。如果受害者依赖于密钥的操作写入了该桶，攻击者的事务将因冲突而中止。如果没写入，攻击者的事务则很可能会成功。通过重复这个过程数千次并测量事务中止率，攻击者可以构建一个关于受害者内存访问模式的统计图像，并从中推断出密钥。[@problem_id:3676147] 中止本身变成了一个[侧信道](@entry_id:754810)，一种微妙的[信息泄露](@entry_id:155485)。硬件在勤勉地执行正确性规则时，无意中成了一个告密者。这揭示了一个深刻的真理：在计算机系统中，每一个可观察到的效应，无论多么微小，都是一个潜在的[信息通道](@entry_id:266393)。

我们对硬件[事务内存](@entry_id:756098)应用的巡礼揭示了它远不止是锁的一个简单替代品。它是程序员与处理器之间一个新的对话层。它简化了[并发编程](@entry_id:637538)的险恶地貌，但作为回报，要求我们对底层硬件有更深入、更周到的理解。我们看到它催生了更优雅的[操作系统](@entry_id:752937)和更智能的编译器，但也开启了新的安全漏洞。它没有解决并发问题，但它改变了问题的性质，推动了可能性的前沿，并提醒我们，在硬件与软件的复杂舞蹈中，每一步都有其后果，无论是预期的还是意料之外的。