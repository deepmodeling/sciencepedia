## 应用与跨学科联系

我们已经看到了[公共子表达式消除](@entry_id:747511)（CSE）的优雅原则：其本质是简单而强大的“不做重复工作”的思想。这个原则可能看起来像一个小小的会计技巧，一点计算上的簿记。但如果仅止于此，就好比把莎士比亚的戏剧描述为仅仅是词语的集合。这个思想的真正美妙之处在于它将我们引向何方。它是贯穿整个计算结构的一条金线，从最平凡的任务到最前沿的科学技术。

### 高效计算的艺术

计算机的核心是一台计算机器，而编译器的首要职责就是让这些计算变得高效。我们可以在一个许多人都熟悉的地方看到这个原则在起作用：简陋的电子表格。想象一下，你有一个单元格 `C1`，公式为 `$A1 + B1$`，另一个单元格 `C2` 在其自己的公式中使用了 `C1`，比如 `$C1 * D1$`。电子表格程序在计算 `C2` 时不会重新计算 `$A1 + B1$`；它只是从 `C1` 中获取已经计算好的结果。通过这种方式，电子表格依赖图的结构本身就是一种自然形式的[公共子表达式消除](@entry_id:747511)。`C1` 中的值就是公共子表达式，计算一次，多次使用 ([@problem_id:3665548])。

编译器则会明确地做到这一点。考虑一个在循环中重复一百万次的计算。一个像 `$p = 3c^{2} + 5c^{3} + (2c + 1)^{2} + c^{2}$` 这样的表达式，如果 `$c$` 不变，那么一遍又一遍地重新计算似乎很浪费。一个优化的编译器首先在表达式*内部*应用 CSE，注意到 `$c^2$` 是一个公共子表达式。它计算一次 `$c^2$` 并复用它。但接着，与另一种称为[循环不变代码外提](@entry_id:751465)（Loop-Invariant Code Motion, LICM）的优化协同工作，它意识到计算 `$p$` 的*整个*表达式都是循环不变的。整个计算被提升到循环之外，将数百万次冗余的乘法减少为在循环开始前仅计算一次的寥寥数次 ([@problem_id:3654653])。

这种“工作”的概念并不局限于简单的算术。在像 $ (A  B) || (A  C) $ 这样的逻辑表达式中，子表达式 $A$ 在简单的翻译中可能会被求值两次。然而，一个聪明的编译器可以应用分配律，将逻辑转换为 $ A  (B || C) $。这种转换是逻辑 CSE 的一种形式，它确保 $A$ 只被求值一次，同时小心地保留了对程序正确性至关重要的短路行为 ([@problem_id:3677622])。

但是，避免重新计算总是更好吗？在这里，我们遇到了一个奇妙的权衡，它揭示了抽象算法与物理硬件之间的深刻联系。假设我们有一个公共子表达式，但同时有太多其他计算正在进行，以至于我们用完了寄存器——CPU 的超高速本地暂存区。编译器现在面临一个选择：是应该在每次需要时重新计算子表达式，还是应该将结果保存到主内存（一次“溢出”）并在稍后加载回来？两者都不是免费的。重新计算消耗处理器周期；存储和加载消耗与内存通信的时间，而内存通常要慢得多。最优选择取决于机器的具体成本。编译器必须解决一个成本效益方程：重新计算的成本是否低于一次存储和多次加载的成本？只有回答了这个问题，它才能为给定的机器生成真正最优的代码 ([@problem_id:3646878])。这不仅仅是一种抽象的优化；这是与硬件物理极限的协商。

### 解锁更深层次的结构与隐藏的并行性

然而，CSE 的真正威力不仅在于节省工作量，还在于它*转化*问题的能力。通过简化程序的[数据流](@entry_id:748201)图，CSE 可以揭示更深层次的结构，并为更深远的优化解锁机会。

其中最令人兴奋的一个是[自动并行化](@entry_id:746590)。考虑一个计算序列，其中两个表达式恰好相同。在优化之前，一个后来的语句可能依赖于第一个表达式，而另一个语句可能依赖于第二个表达式。这些依赖关系形成了一条链，迫使操作必须一个接一个地执行。但在 CSE 识别出两个表达式相同，并用对第一个表达式的引用替换第二个表达式之后，依赖图被重新连接。突然之间，那些将操作[串联](@entry_id:141009)在一起的[数据依赖](@entry_id:748197)关系可能被打破，揭示出两个或多个操作现在是独立的，可以同时、并行地执行 ([@problem_id:3622695])。CSE 不仅仅通过减少工作量来使程序更快；它可以通过使其能够同时做更多事情来使其更快。

这种作为“促成者”的角色对于现代编译器的架构至关重要。优化器不是一个单一的工具，而是由许多遍（pass）组成的交响乐——[循环不变代码外提](@entry_id:751465)、强度削减、死代码消除等等。这些遍的运行顺序至关重要。尽早运行像[全局值编号](@entry_id:749934)（Global Value Numbering, GVN，一种复杂的 CSE 形式）这样强大的规范化遍通常是关键。它简化代码，传播常量，并建立[等价关系](@entry_id:138275)，供后续的遍利用。例如，通过识别并将不变值从循环中提升出来，GVN 和 LICM 为强度削减将昂贵的乘法转换为廉价的加法铺平了道路 ([@problem_id:3672259])。CSE 阐明了程序的本质，使其他优化更容易“见树又见林”。

这种促成能力直接延伸到利用现代硬件上。当今的 CPU 拥有 SIMD（单指令多数据）单元，可以对多个数据片段同时执行相同的操作——例如，在单个指令中将四对数字相加。要使用此功能，数据必须以规则的、并行的模式[排列](@entry_id:136432)。像 `$A[i] \cdot B[i] + A[i] \cdot B[i+1]$` 这样的表达式可能看起来不立即适用。但通过对公共项 `$A[i]$` 应用 CSE 并将表达式重组为 `$A[i] \cdot (B[i] + B[i+1])$`，我们创建了一个更适合[向量化](@entry_id:193244)的结构。编译器现在可以加载一个 `$A$` 值的向量和一个 `$B$` 值的向量，并并行执行操作，从而实现巨大的加速 ([@problem_id:3641870])。类似地，在具有[谓词执行](@entry_id:753687)（指令可以有条件地执行）的架构上，CSE 可用于合并和简化布尔谓词本身，从而减少控制流的开销 ([@problem_id:3663859])。

### 一个普适原则：从[微服务](@entry_id:751978)到深度学习

如果 CSE 仅仅是一个编译器技巧，那它很聪明。但它真正的天才之处在于其普适性。识别和复用共享计算的原则出现在远离传统编译的领域。

考虑一个基于[微服务](@entry_id:751978)的现代软件系统。一个计算可能需要调用一个 Web 服务来获取一条数据。如果系统的两个不同部分需要同一条数据，它们可能都会对同一服务进行昂贵的网络调用。认识到幂等服务调用 `$f(x)$` 是一个公共子表达式，并缓存其结果以便在第二次请求时提供，这与 CSE 的原理完全相同。在这里，“计算”是网络请求，“成本”是[网络延迟](@entry_id:752433)，但 CSE 的逻辑保持不变 ([@problem_id:3656841])。

然而，这种统一性最深刻、最美丽的展示来自一个意想不到的地方：人工智能领域。训练[深度神经网络](@entry_id:636170)的核心是一种称为[反向传播](@entry_id:199535)的算法。一个[神经网](@entry_id:276355)络本质上是一个巨大的[计算图](@entry_id:636350)。“[前向传播](@entry_id:193086)”过程涉及从输入开始，逐层计算网络的输出。如果一个层的输出在网络的多个后续分支中使用——这是现代架构中的常见模式——那么该层就是[前向传播](@entry_id:193086)中的一个共享的、公共的子表达式。

那么，在训练期间的“[反向传播](@entry_id:199535)”过程中会发生什么？为了学习，网络必须计算损失函数相对于网络中每个参数的梯度。它通过将梯度信息向后传播通过图来实现这一点，在每一步都应用微积分的[链式法则](@entry_id:190743)。奇迹就在这里：当[反向传播](@entry_id:199535)到达一个在[前向传播](@entry_id:193086)中是公共子表达式的节点时，链式法则规定，从所有使用其结果的不同路径传来的梯度必须*相加*在一起。共享计算的点变成了梯度累积的点 ([@problem_id:3108073])。

这是一种惊人的对偶性。同一个节点，在向前传播时代表了计算的复用，在向后传播时则充当了聚合信息的[焦点](@entry_id:174388)。编译器中的[公共子表达式消除](@entry_id:747511)和[反向传播](@entry_id:199535)中的梯度累积是同一枚硬币的两面——链式法则在[计算图](@entry_id:636350)上的操作体现。不做重复工作的简单思想与我们训练人工智能的机制本身紧密相连。

从电子表格到超级计算机，从 Web 服务器到[神经网](@entry_id:276355)络，[公共子表达式消除](@entry_id:747511)的原则是一种安静而持续的存在。它证明了计算本质中深刻的统一性——一个简单、优雅的规则，一旦被理解，我们便能在所到之处都看到它的印记。