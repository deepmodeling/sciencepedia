## 引言
在追求效率的过程中，有一条原则至高无上：不要重复做同样的工作。这个直观的想法是我们日常生活中无数提高效率技巧的基础，在计算世界中也同样至关重要。当我们编写代码时，我们表达的是意图，但将该意图直译为机器指令往往充满了隐藏的冗余。这就产生了一个知识鸿沟：我们如何能将人类可读的代码自动转换为其最高效的版本？答案在于精密的[编译器优化](@entry_id:747548)艺术，而其基石之一便是[公共子表达式消除](@entry_id:747511)（Common Subexpression Elimination, CSE）。

本文将深入探讨 CSE 的优雅世界，揭示编译器如何像逻辑大师一样精简我们的代码。在接下来的章节中，您将踏上一段始于编译器内部深处的旅程。第一章**“原理与机制”**将解析 CSE 的核心理论。我们将探索编译器如何使用[有向无环图](@entry_id:164045)等数据结构来“看见”冗余，确保正确性的严格数据流分析规则，以及管理硬件资源所需的精妙平衡。在此基础上，第二章**“应用与跨学科联系”**将拓宽我们的视野。我们将发现 CSE 如何促成更高级的优化（如[并行化](@entry_id:753104)），并看到其核心原理在意想不到的领域中浮现，从电子表格设计到人工智能学习的核心机制。

## 原理与机制

想象一下，你正在遵循一个复杂的食谱，其中一步要求你将两杯面粉和一杯糖混合，几步之后，又要求你为这道菜的另一部分做完全相同的事情。你会分两次量取面粉和糖吗？当然不会。你会直观地一次性量好这三杯混合物，放在一边，在需要时使用。这种不重复已完成工作的简单行为是效率的基石。在计算世界中，编译器——将人类可读代码翻译成机器可执行指令的大厨——也采用了一种类似但远为精密的策略，称为**[公共子表达式消除](@entry_id:747511)（CSE）**。它是最基本、最美妙的优化之一，揭示了编译器如何在我们编写的代码中发现更深层次、更高效的隐藏结构。

### 洞见重复：冗余的本质

CSE 的核心在于发现并消除冗余计算。思考一个简单的算术表达式：

$$
y := \frac{(a + b)}{(c + d)} + \frac{(a + b)}{(e + f)}
$$

将其简单地翻译成低级指令会是一种直接、字面的方式。它会首先计算 $a+b$，然后计算 $c+d$，执行除法，并存储结果。接着，它会重新开始，第二次计算 $a+b$，然后计算 $e+f$，执行第二次除法，最后将两个结果相加。这种方法是正确的，但很浪费。子表达式 $(a+b)$ 被计算了两次。

一个聪明的编译器会识别出这种重复。它会生成指令仅计算一次 $a+b$，将结果保存在一个临时的“暂存区”——一个称为**寄存器**的高速存储位置——然后在第二次除法时复用这个已保存的值 [@problem_id:3676959]。这个简单的复用行为减少了处理器需要执行的指令数量，使程序运行得更快。

当此原则与其他优化相互作用时，其威力会变得更加强大。如果代码中包含这样一行 $x := (y + z) - (y + z)$ 呢？应用 CSE 的编译器会首先计算 $y + z$ 并将其存储在一个临时变量中，我们称之为 $t_1$。表达式变为 $x := t_1 - t_1$。现在，另一种称为代数化简或[常量折叠](@entry_id:747743)的优化可以介入。编译器知道任何数减去其自身都等于零。因此，整个看似复杂的语句可以在编译时被替换为更简单的 $x := 0$。如果程序在此之后从未使用过 $x$ 的值，那么进一步的**死代码消除**过程可以完全移除这一行 [@problem_id:3675495]。这是[编译器优化](@entry_id:747548)中统一性的一个绝佳例子：简单的规则组合在一起，可以带来深刻的简化。

### 机制：编译器如何记忆

编译器是如何系统地找到这些公共子表达式的？它不像人类那样线性地“阅读”代码。相反，它将[代码转换](@entry_id:747446)为一种更抽象的[数据结构](@entry_id:262134)，使关系变得明确。

第一种、最直接的表示是**[解析树](@entry_id:272911)**，它反映了代码的语法结构。对于像 $x*y + x*z + y*z + x*y$ 这样的表达式，[解析树](@entry_id:272911)会是一个庞大的分支结构，其中每个操作和变量都显示为一个独立的节点。如果你画出它，你会看到用于 $x*y$ 的子树作为不同的分支出现了两次 [@problem_id:3641820]。[解析树](@entry_id:272911)忠实于文本，但对冗余视而不见。

为了获得“洞察力”，编译器构建了一个更优雅的结构：**[有向无环图](@entry_id:164045)（DAG）**。DAG 就像一棵[解析树](@entry_id:272911)，但有一个关键区别：它从不为已经见过的内容创建新节点。当它第一次遇到 $x*y$ 时，它会创建一个乘法节点，其输入来自 $x$ 和 $y$ 的节点。当它再次看到 $x*y$ 时，它不会构建一个新的分支。相反，它只是画另一个指针指向*已存在的* $x*y$ 节点。通过将原本两个相同的分支合并为一个共享节点，冗余被消除了。DAG 中最终的操作节点数量直接对应于评估该表达式所需的最小指令数。

但像 $a+b$ 和 $b+a$ 这样的表达式怎么办？它们在数学上是相同的，但在文本上是不同的。一个真正聪明的编译器知道加法和乘法等运算符的交换律。在 DAG 中创建节点之前，它首先对子表达式进行**规范化**，例如，总是按字母顺序[排列](@entry_id:136432)操作数。通过这种方式，$a+b$ 和 $b+a$ 都被转换为相同的规范表示 $+(a, b)$。然后，这个规范化的“指纹”被用来检查 DAG 中是否存在一个已有的节点 [@problem_id:3641786]。这个过程通常使用一种称为**驻留**的技术来实现，其中每个唯一的指纹映射到单个节点对象，这使得编译器能够找到超越简单文本匹配的更深层次的结构相似性 [@problem_id:3673788] [@problem_id:3665460]。

### 游戏规则：何时安全？

[公共子表达式消除](@entry_id:747511)似乎是一项普遍的好事，但它并不能盲目应用。它受到一套严格规则的约束，以确保它永远不会改变程序的含义。

#### 规则 1：可用性

你只能在先前计算的结果保证**可用**的情况下复用它。这个概念是编译器理论中一个名为**[数据流](@entry_id:748201)分析**的领域的核心。一个表达式（如 $a + b$）在程序的某个点上是可用的，前提是沿*每条可能到达该点的执行路径*，$a + b$ 都已被计算，并且关键的是，$a$ 和 $b$ 的值自那次计算后没有被改变过。

想象一个带有 `if-else` 语句的程序。一个分支计算 $t := a + b$，而另一个分支修改了 $b$ 的值。在 `if-else` 结构重新汇合后，我们能否为一个新的 $a + b$ 计算复用 $t$ 的值？不能。因为如果程序是通过 `else` 分支过来的，旧的 $a + b$ 值就不再有效了；它已经被对 $b$ 的修改“杀死”了。编译器必须对程序的[控制流图](@entry_id:747825)进行严格分析，跟踪每个基本块中哪些表达式被生成、哪些被杀死，以绝对确定一个表达式在何处保持可用 [@problem_id:3622879]。只有当一个表达式在所有进入路径上都可用时，CSE 才是一种安全有效的转换。

#### 规则 2：无隐藏副作用

第二条规则更为深刻：编译器必须尊重程序员的意图，尤其是当一个操作不仅仅是计算一个值时。考虑与硬件交互的代码，比如一个[内存映射](@entry_id:175224)的计时器。一个程序可能会连续两次读取计时器的内存地址：

`time1 = *timer_address;`
`time2 = *timer_address;`

对于编译器来说，`*timer_address` 看起来像一个公共子表达式。它可能会试图将其“优化”为：

`time1 = *timer_address;`
`time2 = time1;`

这种转换将是一场灾难。两次读取计时器的全部意义在于看它的值是否发生了变化。读取行为不仅仅是一次计算；它是一个**可观察事件**。像 C 和 C++ 这样的语言提供了 `volatile` 关键字来向编译器传达这一点。`volatile` 是程序员发出的一个指令，其本质是说：“别动！这个内存访问有副作用。你不能将其优化掉、重排序或与其他访问合并。”在整个编译器流水线中，从最初解析 `volatile` 关键字的前端到生成最终机器码的后端，都需要勤勉地维护这些语义 [@problem_id:3674610]。这是人类程序员与自动化优化器之间必要对话的一个绝佳例证。

### 更大的图景：优化的交响乐

CSE 并非在真空中运作。它的真正威力常常通过与其他优化过程协同工作而释放，每个过程都有助于形成一个更清晰、更高效的程序表示。

- **副本传播 (Copy Propagation)**：这项简单的优化用一个变量被赋予的值来替换该变量的使用。考虑代码 `t := x; ... result := f(t) + f(x);`。就其本身而言，没有明显的公共子表达式。但在副本传播将[代码转换](@entry_id:747446)为 `result := f(x) + f(x);` 之后，一个针对纯函数 `f(x)` 的新 CSE 机会立即显现出来 [@problem_id:3634035]。

- **[函数内联](@entry_id:749642) (Function Inlining)**：这是 CSE 最强大的促成因素之一。通常，优化是“过程内”的，意味着它们在单个函数的边界内操作。一个分析调用另一个函数 `H` 三次的函数 `M` 的编译器无法看到 `M` 中的代码与 `H` 内部代码之间的冗余。但如果编译器首先执行**内联**——用 `H` 的实际主体替换对 `H` 的每次调用——调用边界就被抹去了。突然之间，原本分离的作用域变成了一个大的代码块，暴露出大量新的、贯穿其中的公共子表达式，然后 GVN 和 CSE 就可以消除它们 [@problem_id:3664197]。

### 权衡的艺术：何时不应耍小聪明

在看到这套错综复杂的逻辑和规则之后，人们很容易认为只要安全就应该应用 CSE。但这里蕴含着[编译器设计](@entry_id:271989)中最后、也最微妙的智慧：有时，“优化”的方式并非最佳方式。

当 CSE 保存一个子表达式的结果时，它必须将该结果保存在一个 CPU 寄存器中，直到再次需要它。寄存器是可用的最快内存形式，但它们也是一种极其稀缺的资源。在任何给定时刻，一个程序需要保持在寄存器中的值的数量称为**[寄存器压力](@entry_id:754204)**。

如果一个表达式的结果被保留很长时间，它会延长其“[活跃范围](@entry_id:751371)”，占据一个本可以用于其他目的的寄存器。如果[寄存器压力](@entry_id:754204)过高——即程序需要的寄存器比 CPU 拥有的还多——编译器将被迫**溢出**一个值：它必须将值从快速的寄存器写出到慢速的主内存中，以便稍后在需要时再加载回来。这个存储和重新加载的周期可能非常昂贵。

在这里，编译器面临一个经济决策。如果一个子表达式重新计算的成本很低，而保存其结果会导致昂贵的[寄存器溢出](@entry_id:754206)，那么简单地重新计算它可能更高效！[@problem_id:3641800]。一个真正精密的编译器使用一个**成本模型**。它权衡 CSE 带来的计算节省与增加[寄存器压力](@entry_id:754204)可能带来的成本。

这最后的权衡揭示了优化不是僵硬地应用规则，而是一门平衡相互竞争约束的精妙艺术。[公共子表达式消除](@entry_id:747511)，一个如同不重复量两次面粉一样简单的原则，为我们打开了一扇窗，窥见现代计算核心中那令人惊叹的复杂性与优雅。

