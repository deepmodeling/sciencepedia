## 引言
安全[共享密钥](@article_id:325175)的挑战与[密码学](@article_id:299614)的历史一样悠久。几个世纪以来，信息的安全一直依赖于预共享的秘密，但在分发该秘密时不被拦截，构成了一个根本性的漏洞。如果密钥本身能够报告它正在被监视，情况会怎样？这就是[量子密钥分发](@article_id:298519)（QKD）带来的革命性前景，该领域利用量子物理学的奇特规则来创建可证明安全的通信。

本文将深入探讨开启这一切的基础协议：BB84。它通过提供一种不仅能[共享密钥](@article_id:325175)，还能验证其完整性的方法，解决了经典[密码学](@article_id:299614)中的一个关键缺陷。您将通过分两部分探索该协议来了解这是如何实现的。首先，我们将研究其核心的**原理与机制**，详细介绍信息如何编码到单个[光子](@article_id:305617)上，以及量子测量定律如何自然地揭示窃听者的存在。随后，关于**应用与跨学科联系**的章节将弥合理论与实践之间的差距，讨论锻造最终密钥所需的基本数据处理，并探索该协议与从信息论到广义[相对论](@article_id:327421)等领域的惊人联系。

## 原理与机制

想象一下，我们想发送一封秘密消息。几个世纪以来，这就像一场锁与钥匙的游戏。你把消息锁在盒子里，需要一把预先共享的密钥才能打开它。但你最初如何共享那把密钥而不被他人截获呢？这是密钥分发这一古老难题。然而，量子力学提供了一种全新的解决方案。它给我们的不是一把更好的锁，而是一把在有人试图复制它时会发出警报的钥匙。这就是 BB84 协议背后的魔力，该协议以其发明者 Charles Bennett 和 Gilles Brassard 的名字命名。

### 量子握手：在光上编码信息

让我们从基础开始。我们如何才能将信息编码到光的单个粒子——**[光子](@article_id:305617)**上呢？答案在于其**偏振**，你可以将其视为光[振荡](@article_id:331484)的方向。为了我们的目的，我们可以把偏振想象成附着在每个[光子](@article_id:305617)上的一个小箭头。

想要向 Bob 发送密钥的 Alice，决定使用两种不同的“语言”，或者用物理学术语来说，两种不同的**基**，来编码她的比特。

1.  **直线基**（+）：在这种语言中，水平偏振（$\leftrightarrow$）代表比特 '0'，[垂直偏振](@article_id:325169)（$\updownarrow$）代表比特 '1'。我们可以将这些[状态表示](@article_id:301643)为 $|0\rangle$ 和 $|1\rangle$。

2.  **对角基**（x）：在这种语言中，+45° 对角偏振（$\nearrow$）代表 '0'，而 -45° 反对角偏振（$\nwarrow$）代表 '1'。我们将这些状态称为 $|+\rangle$ 和 $|-\rangle$。

对于她密钥的每一位，Alice 都会做出两个随机选择：发送哪个比特（0 或 1），以及使用哪个基（+ 或 x）。然后，她制备一个具有相应偏振的[光子](@article_id:305617)并发送给 Bob。例如，如果她的比特是 '1' 且选择的基是 '+'，她会发送一个[垂直偏振](@article_id:325169)的[光子](@article_id:305617)。如果她的比特是 '0' 且选择的基是 'x'，她会发送一个 +45° 偏振的[光子](@article_id:305617)。

### 不确定性原理的应用：测量即选择

现在[光子](@article_id:305617)到达了 Bob 的实验室。但问题是：Bob 不知道 Alice 使用了哪个基。和 Alice 一样，他必须为每个到达的[光子](@article_id:305617)做出随机选择：他是用直线基（+）还是对角基（x）来测量其偏振？

这就是量子力学最深刻的真理之一发挥作用的地方。你可以将其视为**[海森堡不确定性原理](@article_id:323244)**的一种形式。如果你选择在某个基上测量一个属性，你就会从根本上摧毁关于它在另一个“不相容”基上本应具有的信息。

-   **如果 Bob 的基与 Alice 的基匹配：**他会以 100% 的确定性得到正确的比特。如果 Alice 发送了一个水平偏振的[光子](@article_id:305617)（在 '+' 基中代表比特 '0'），而 Bob 也在 '+' 基中测量，他将无一例外地检测到一个水平偏振的[光子](@article_id:305617)并记录 '0'。

-   **如果 Bob 的基与 Alice 的基不匹配：**他的测量结果是完全随机的。假设 Alice 发送了一个水平偏振的[光子](@article_id:305617)（$|0\rangle$，在她的 '+' 基中代表比特 '0'），但不幸的是 Bob 决定在对角 'x' 基中进行测量。量子力学规定，该[光子](@article_id:305617)被迫“选择”成为 +45° 或 -45° 偏振。每种结果的概率恰好是 50%。Bob 将有一半的时间记录 '0'（对于 +45°），另一半的时间记录 '1'（对于 -45°），完全是随机的。他无法知道自己的比特只是一个随机猜测 [@problem_id:1651388]。

在这个阶段，Alice 已经发送了一长串[光子](@article_id:305617)，而 Bob 也全部测量了它们，生成了他自己的一长串比特。由于基不匹配，Bob 的比特串大部分是无用的——它只在那些他们偶然选择了相同基的位置上与 Alice 的比特串相匹配。

### 筛选存菁：锻造[共享密钥](@article_id:325175)

那么，他们如何将两个充满噪声的数据串变成一个共享的密钥呢？他们通过交流。但关键是，他们通过一个公共[信道](@article_id:330097)——比如电话[线或](@article_id:349408)互联网——进行交流，而窃听者（我们称之为 Eve）可以监听。他们决不能透露任何关于密钥本身的信息。

这就是被称为**密钥筛选**的巧妙过程。对于她发送的每个[光子](@article_id:305617)，Alice 公开宣布她使用了哪个*基*，但**不是**她编码的比特。例如，她会说：“第一个[光子](@article_id:305617)我用了‘+’，第二个用了‘x’，第三个用了‘+’，依此类推。” Bob 也同样做，宣布他用于测量的一系列基 [@problem_id:1651391]。

然后他们比较各自的列表。对于基匹配的每个位置，他们保留自己记录的比特。对于基不匹配的每个位置，他们都完全丢弃那个比特。由于他们的基选择是随机的，他们[期望](@article_id:311378)大约有 50% 的时间基会匹配。剩下的比特序列，现在应该在他们之间是完全相同的，被称为**筛选密钥**。在理想世界中，工作到此就完成了。他们有了一个共享的密钥，而只听到使用了哪些基的 Eve 对他们保留的比特值一无所知。

当然，现实世界并非理想。[光子](@article_id:305617)探测器并非完美，一些[光子](@article_id:305617)在传输中会丢失。这些因素会减少筛选密钥的最终长度。更高级的模型可以精确计算预期的密钥长度，同时考虑诸如偏向的基选择或依赖于测量设置的探测效率等因素 [@problem_id:122686]。

### 不速之客：检测 Eve

但 Alice 和 Bob 如何确定他们是单独通信的呢？如果 Eve 一直在量子信道上秘密监听呢？让我们考虑最简单直接的攻击：**拦截-重发**。Eve 捕获 Alice 发送的每一个[光子](@article_id:305617)，进行测量，然后根据她测量到的[状态制备](@article_id:312618)一个全新的[光子](@article_id:305617)发送给 Bob。

想想 Eve 的困境。就像 Bob 一样，她不知道 Alice 的基。她也必须猜测。

-   如果 Eve 猜对了基，她就得到了正确的比特。然后她向 Bob 发送一个完美的替代[光子](@article_id:305617)。如果 Bob 恰好也用同一个基进行测量，那么对于这一个比特来说，她的存在是完全不可见的。

-   如果 Eve 猜错了基，她会得到一个随机结果，更重要的是，她会以错误的[状态制备](@article_id:312618)发送给 Bob 的[光子](@article_id:305617)。例如，如果 Alice 发送了一个水平偏振（$|0\rangle$）的[光子](@article_id:305617)，但 Eve 在对角基中测量，她可能会随机测量到 $|+\rangle$ 并向 Bob 发送一个全新的 $|+\rangle$ [光子](@article_id:305617)。现在，假设 Alice 和 Bob 恰好都为这个比特选择了直线基。当 Bob 测量这个传入的 $|+\rangle$ [光子](@article_id:305617)时，他将得到一个随机的结果——50% 的概率得到 '0'（水平），50% 的概率得到 '1'（垂直）。

这就是关键点：Eve 的窃听引入了错误！当 Bob 的基选择与 Alice 的匹配时，Eve 有一半的时间猜错基，而在这些情况下，她有 50% 的几率在 Bob 的比特中造成错误。总的来说，这种简单的攻击策略不可避免地会在筛选密钥中引入 25% 的错误率 [@problem_id:2236843]。这个错误率被称为**[量子比特错误率](@article_id:304232)（QBER）**。通过牺牲一小部分随机选择的筛选密钥并公开比较这些比特，Alice 和 Bob 可以估计这个 QBER。如果他们发现错误率显著高于其设备[固有噪声](@article_id:324909)应产生的水平，他们就知道有人在监听。然后他们可以简单地丢弃这个密钥并重新开始。间谍被抓住了。

安全性依赖于 Alice 和 Bob 的选择是真正不可预测的。如果 Alice 更多地使用某个基，一个聪明的 Eve 就可以利用这一点，总是用概率更高的那个基进行测量，从而增加她在不干扰[光子](@article_id:305617)的情况下获得正确比特的机会 [@problem_id:1651410]。这凸显了随机性与安全性之间的深刻联系。

### 为何量子安全与众不同：不可克隆保证

一个敏锐的人可能会问：“为什么 Eve 不能更隐蔽一些？与其拦截和重发，为什么不直接制作一个[光子](@article_id:305617)的完美副本，把原始[光子](@article_id:305617)不受干扰地发送给 Bob，然后悠闲地测量她的副本呢？”

物理学给出的惊人答案是：她不能。**不可克隆定理**是量子力学的一条基本定律，它指出不可能创建任意未知[量子态](@article_id:306563)的独立相同副本。这不是我们技术的限制；这是编织在现实结构本身之中的限制。

任何构建“量子复印机”的尝试都必然存在缺陷。一个最优但仍不完美的克隆机器将产生两个原始态的退化副本。当 Eve 将其中一个有缺陷的副本发送给 Bob 时，信息已经被破坏了 [@problem_id:514552]。即使 Bob 在正确的基中测量，来自不完美克隆过程的[固有噪声](@article_id:324909)也会导致他有时得到错误的比特。对于最好的通用克隆机器，这种攻击会引入约 16.7% ($1/6$) 的 QBER。再一次，Eve 获取知识的企图留下了一条可检测的证据痕迹。

### 从错误到信息：窥探的代价

QBER 不仅仅是一个防盗警报；它是对 Eve 干涉程度的定量测量。Eve 越是试图学习信息，她就必须越多地与[光子](@article_id:305617)相互作用，从而不可避免地引入更多的错误。这就是终极的**[信息-扰动权衡](@article_id:299051)**。

现代 QKD 的安全性证明提供了精确的数学关系，根据 Alice 和 Bob 观察到的 QBER，限制了 Eve 可能获得的最大信息量。这些关系就像“量子间谍定律”。例如，一个安全性分析可能会得出一个公式，将 Eve 每个比特可能获得的最大信息量 $\chi_E$ 与测得的错误率 $Q$ 联系起来 [@problem_id:171353]。Alice 和 Bob 可以测量 $Q$，然后使用这个公式计算 Eve 知识量的绝对最坏情况。

这里我们也必须区分 Eve 和现实。现实世界系统从来都不是完美的。光学元件可能未对准，即使没有窃听者，也会导致一个小的、固有的 QBER。例如，Alice 和 Bob 设备之间一个小的角度未对准 $\theta$ 会自然产生一个错误率 $Q = \sin^2(\theta)$ [@problem_id:122687]。Alice 和 Bob 必须首先表征他们系统的这个基线错误率。只有*高于*这个基线的 QBER 才表明 Eve 的存在。

此外，理想[单光子源](@article_id:303900)的简单模型在实践中也面临挑战。制造一个能按需精确发射单个[光子](@article_id:305617)的设备很困难。许多系统使用高度衰减的[激光脉冲](@article_id:325572)作为替代。然而，这些光源有很小的几率在单个脉冲中发射两个或更多[光子](@article_id:305617)。这就为**[光子](@article_id:305617)数分离（PNS）攻击**打开了一个漏洞，Eve 可以从多[光子](@article_id:305617)脉冲中剥离一个[光子](@article_id:305617)而完全不干扰其他[光子](@article_id:305617)，使得她对该脉冲的拦截完全无法被检测到 [@problem_id:2254965]。

最终，BB84 协议提供了一个安全蓝图。通过测量他们线路上的扰动（QBER），Alice 和 Bob 可以对可能已经泄露的信息量设定一个严格的上限。如果这个泄露量低到可以接受，他们就可以使用经典的[纠错](@article_id:337457)和**[隐私放大](@article_id:307584)**[算法](@article_id:331821)，提炼出一个更短但完全安全的最终密钥。如果错误率太高，他们就知道他们的安全已经受到威胁，于是他们只需丢弃密钥，除了浪费一点时间外一无所失。秘密本身从未被泄露。