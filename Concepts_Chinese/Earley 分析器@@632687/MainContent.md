## 引言
分析（Parsing），即分析一串符号以确定其语法结构的过程，是计算机科学的基石。虽然简单的文法可以由直接的方法处理，但支配人类语言和复杂软件的丰富、复杂且常常模棱两可的规则，要求一种更为稳健的方法。传统的分析器在处理这些复杂性时可能会遇到困难，因[左递归](@entry_id:751232)而陷入无限循环，或在面对歧义时被迫放弃除一种解释外的所有解释。这在我们希望描述的语言和我们用来理解它们的工具之间造成了鸿沟。

本文探讨了解决此问题的一个强大而优雅的方案：Earley 分析器。该算法由 Jay Earley 开发，为分析任何[上下文无关文法](@entry_id:266529)提供了一种通用方法。我们将通过两部分来理解其精妙之处。第一章“原理与机制”将解构该算法本身，解释其基于图表的系统和三个基本操作——预测器、扫描器和完成器——如何协同工作来分析句子。随后的“应用与跨学科联系”一章将揭示该分析器卓越的通用性，展示其在从[编译器设计](@entry_id:271989)、[生物信息学](@entry_id:146759)到人类语言和音乐分析等各个方面的影响。读完本文，您将看到这单一的算法如何为在各种序列信息中寻找结构提供了一个统一的框架。

## 原理与机制

想象一下，你是一名侦探，正试图解决一个语言学难题：根据一本规则书，一个给定的句子在语法上是否正确？计算机科学中的许多经典方法是通过派遣一名 methodical 的侦探沿着单一的推理路径来解决这个问题的。如果他们走到死胡同，可能不得不回溯；更糟的是，如果规则书中有某些令人困惑的循环，他们可能会永远卡住。这就是许多传统分析器在面对类人语言的美丽复杂性时所处的困境。

由 Jay Earley 在1970年构想的 Earley 分析器，提出了一种截然不同且更强大的策略。它不再是派遣一名侦探，而是派出一整个团队去同时探索所有可能性。它的运作方式就像一个宏大的协作努力，在句子的每一个词处，团队成员都维护着一个完整的图表，记录着当前所有可能的[语法分析](@entry_id:267960)。这种并行、详尽的探索正是其稳健性和优雅性的秘诀。

### Earley 项的生命周期：描绘分析之旅

Earley 算法中的基本信息单元是 **Earley 项**（或**状态**）。可以把它想象成我们侦探提交的一份进度报告。它有一个非常具体的结构：$[A \to \alpha \cdot \beta, i]$。让我们用物理学家看待粒子[状态向量](@entry_id:154607)的直觉来剖析它。

- $A \to \alpha \beta$ 是正在测试的语法规则。例如，如果规则是 $Sentence \to \text{NounPhrase} \ \text{VerbPhrase}$，这就是我们侦探当前所走的路径。

- 点（$\cdot$）是整个过程的主角。它是一个“你在这里”的标记。它将已经成功找到的部分（$\alpha$）与仍在寻找的部分（$\beta$）分开。像 $[\text{Sentence} \to \text{NounPhrase} \cdot \text{VerbPhrase}, 0]$ 这样的项意味着：“我们已经成功识别出一个从句子开头开始的 `NounPhrase`，现在我们正在寻找一个 `VerbPhrase` 来完成这个 `Sentence`。”

- 索引 $i$ 是其起源故事。它告诉我们构建这个特定 $A$ 的旅程是从输入字符串的哪个位置开始的。

这些项不是孤立存在的，它们被收集到集合中，称为**图表集**（chart sets），输入字符串中的每个位置都有一个。图表集 $C_k$ 包含了分析器在读取句子的前 $k$ 个词后可能处于的每一种可能的语法状态。整个分析过程就是系统地构建这些图表集，从 $C_0$ 到 $C_n$（其中 $n$ 是句子的长度）。

### 三个基本操作：预测器、扫描器和完成器

这些图表集是如何构建的？算法会遍历输入，在每个位置 $k$ 处，它会重复应用三个简单而强大的操作，直到没有新的项可以添加到图表中。这三个操作是分析器的引擎。

#### 预测器：算命先生

**预测器**（Predictor）回答了这个问题：“根据我们当前正在寻找的东西，接下来我们可能会找到什么？”

假设图表 $C_k$ 中有一个项是 $[\text{VP} \to \cdot V \ \text{NP}, k]$。点号恰好在一个非终结符 $V$（动词）之前。预测器的工作是查看我们的文法，并为每条可以产生 $V$ 的规则在图表 $C_k$ 中添加一个新项。如果我们有规则 $V \to \text{eats}$ 和 $V \to \text{sees}$，预测器会添加两个新项：$[V \to \cdot \text{eats}, k]$ 和 $[V \to \cdot \text{sees}, k]$。它正在进行自顶向下的预测：如果我们需要在这里寻找一个动词，那么就让我们将所有可能从这个位置开始的动词都添加到我们的假设列表中。

正是在这里，Earley 分析器首次展现了其处理**[左递归](@entry_id:751232)**的天才之处，[左递归](@entry_id:751232)是许多自顶向下分析器的臭名昭著的绊脚石 [@problem_id:3639832]。考虑一个算术表达式的文法：$E \to E + E \mid a$。如果一个 LL(1) 分析器试[图分析](@entry_id:750011)一个 $E$，并且它选择了规则 $E \to E + E$，它会立即去寻找另一个 $E$，从而导致无限递归循环。然而，Earley 分析器却不受影响。如果它遇到 $[E \to \cdot E+E, i]$，预测器只会将 $[E \to \cdot E+E, i]$ 重新添加回当前的图表集。由于图表集不存储重复项，所以什么都不会改变。这个循环通过使用集合这个简单而优雅的机制被打破了。它考虑了这种可能性，并在注意到之后继续前进 [@problem_id:3639829]。

#### 扫描器：食词者

**扫描器**（Scanner）是最直观的操作。它将我们的理论预测与实际的输入字符[串联](@entry_id:141009)系起来。它问：“句子中的下一个词是否与我们当前的某个假设匹配？”

如果图表 $C_k$ 中的一个项是 $[V \to \cdot \text{eats}, k]$，而我们输入的第 $k$ 个词恰好是“eats”，扫描器会消耗这个词并前移点号。它会在*下一个*图表 $C_{k+1}$ 中添加一个新项 $[V \to \text{eats} \cdot, k]$。这代表了具体的进展：我们已经成功地将文法中的一个终结符与输入中的一个词匹配。

#### 完成器：拼图者

**完成器**（Completer）是该算法力量的核心，也是自底向上综合的魔力发生的地方。它回答了这个问题：“我们刚刚成功构建了一个语法片段。谁在等待它？”

当扫描器或其他完成器创建了一个*完成项*——即点号已经到达规则末尾的项，例如图表 $C_k$ 中的 $[\text{NP} \to \text{the cat} \cdot, i]$——完成器就开始工作了。这个项是一份证书：“我们已经成功找到了一个从位置 $i$ 到位置 $k$ 的名词短语（Noun Phrase）。”然后，完成器会回到这个片段开始的图表 $C_i$，找到所有在该位置等待 `NP` 出现的项。对于每一个这样的等待项，比如 $[S \to \cdot \text{NP} \ \text{VP}, i]$，完成器会将其点号越过 `NP`，并在*当前*图表 $C_k$ 中添加一个新项 $[S \to \text{NP} \cdot \text{VP}, i]$。

这一步是一个美妙的综合时刻。一个已完成的子问题触发了所有依赖于它的更大问题的进展。这个机制也优雅地处理了**可空产生式**（或 **$\epsilon$-产生式**），即形如 $A \to \epsilon$ 的规则。当预测器添加一个像 $[A \to \cdot, k]$ 这样的项时，完成器会立即将其识别为一个完成项（一个长度为零的成分）。这可以触发一连串的进一步完成，所有这些都不消耗任何输入——这是一场纯粹的[逻辑演绎](@entry_id:267782)的 flurry [@problem_id:3639802]。

### 歧义的力量：拥抱多种真理

人类语言常常是模棱两可的。句子“I saw a man with a telescope”可以有两种不同的意思。大多数简单的分析器被迫选择一种解释或声明错误。然而，Earley 分析器优雅地拥抱了歧义。

考虑简单但有[歧义](@entry_id:276744)的文法 $S \to S\,S \mid a$ 和输入“aaa”[@problem_id:3639800]。这个字符串可以有两种分析方式：$(aa)a$ 或 $a(aa)$。Earley 分析器是如何处理这个问题的呢？在分析时，完成器最终会通过两种不同的推导路径创建最终的接受状态，每条路径对应一种分组方式。

- 一条路径是通过将“aa”的已完成 $S$（从索引0到2）与“a”的已完成 $S$（从索引2到3）结合而产生的。
- 另一条路径是通过将“a”的已完成 $S$（从索引0到1）与“aa”的已完成 $S$（从索引1到3）结合而产生的。

分析器不会为了另一个而丢弃其中一个。它会同时跟踪两者。最终的输出不是一个单一的分析树，而是对*所有*可能的分析树的紧凑表示，称为**[共享打包分析森林](@entry_id:754744)（Shared Packed Parse Forest, SPPF）**[@problem_id:3639821]。这个结构是一个分层的有向无环图，图中不同的路径对应句子不同的有效解释[@problem_id:3639792]。这种在不陷入指数级困境的情况下表示所有分析的能力，使得 Earley 算法在自然语言处理中非常有价值，因为在自然语言处理中，[歧义](@entry_id:276744)是一种特性，而不是一个缺陷。

### 统一的视角：Earley 及其同类

一个深刻的科学原理最美妙的方面之一，是看到它如何与其他看似不同的思想联系起来。Earley 算法是这种统一性的一个绝佳例子。

-   **CYK 算法：** 对于特定、受限格式（[乔姆斯基范式](@entry_id:265068)）的文法，Earley 算法的行为与另一个著名的动态规划分析器——**CYK 算法**——相呼应。在图表集 $C_j$ 中存在一个完成项 $[A \to \alpha \cdot, i]$，其概念直接等同于在 CYK 算法的表项 $V[i, j]$ 中找到非终结符 $A$ [@problem_id:3639797]。它们是同一核心思想的不同表述：通过为逐渐增大的子串构建解决方案来解决分析问题。

-   **数据流分析：** 我们可以从更宏观的视角来看，将整个分析过程视为一个**[不动点](@entry_id:156394)计算**[@problem_id:3639819]。我们从一个初始的假设集（种子项）开始，然后迭代地应用三个操作（预测器、扫描器、完成器）。每个操作都是**单调的**——它只会向图表集中添加项，从不移除。由于对于给定的文法和输入长度，可能的项的总数是有限的，这个迭代过程保证在没有新项可添加时终止。最终的图表集集合是系统的**最小[不动点](@entry_id:156394)**，即与文法和输入相一致的最小稳定状态集。这将分析与一个强大的、抽象的框架联系起来，该框架在整个计算机科学中被用于解决[编译器优化](@entry_id:747548)和[静态程序分析](@entry_id:755375)等问题。

-   **性能与实用性：** 尽管功能强大，Earley 算法的性能是众所周知且非常实用的。在高度[歧义文法](@entry_id:260945)的最坏情况下，它的运行时间为 $O(n^3)$，其中 $n$ 是输入的长度——这与限制更多的 CYK 算法相同[@problem_id:3279138]。然而，对于无[歧义](@entry_id:276744)的文法，其性能提高到 $O(n^2)$，而对于快速 LR 分析器所使用的简单、确定性文法，它能达到 $O(n)$ 的线性时间。这种“优雅降级”使其成为一个极其通用的工具，适用于从使用复杂、演化中的文法进行快速原型开发，到高效分析行为良好的文法的各种场景[@problem_id:3639833]。

### 超越地平线：知晓极限

Earley 算法是针对整个**[上下文无关语言](@entry_id:271751)**类别的通用分析器。但如果一种语言的结构从根本上更复杂呢？考虑语言 $L = \{a^n b^n c^n \mid n \ge 1\}$，它由等量'a'、'b'和'c'按序组成的字符串构成。[形式语言理论](@entry_id:264088)的一个著名结果是，没有[上下文无关文法](@entry_id:266529)可以生成这种语言。确保'c'的数量与'a'和'b'的数量相匹配所需的“记忆”超出了 CFG 的能力。

如果我们给 Earley 分析器任何一个 CFG，并让它分析像“aaabbbccc”这样的字符串，它会正确地报告失败[@problem_id:3639845]。这并非算法本身的失败，而是对输入字符串不符合给定文法规则的正确裁决。算法的工作是根据提供的地图（文法）进行分析，并且它完美地完成了这项工作。要分析这类语言，我们需要一个更强大的地图，一个来自更高类别的文法形式体系，比如**树邻接文法（Tree-Adjoining Grammar, TAG）**。美妙之处在于，Earley 算法中的核心动态规划思想可以被扩展，以创建适用于这些更强大形式体系的分析器，这展示了其基本原理的稳健性和可扩展性。

