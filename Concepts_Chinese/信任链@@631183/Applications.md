## 应用与跨学科联系

在走过信任链的原理之旅后，从其硬件根基到加密验证仪式，我们可能觉得自己对这个概念有了扎实的把握。但科学不仅仅是原理的集合；它是将这些原理应用于我们周围世界的实践。正是在应用中，一个思想的真正美丽、力量，以及有时令人惊讶的脆弱性才得以揭示。那么，现在让我们走出去，看看这条信任链出现在哪里，它如何保护我们，以及它如何塑造技术乃至科学本身的未来。

不要把信任看作一个单一、庞大的区块，而要把它看作一个关系网。密钥A签署密钥B，密钥B签署密钥C。如果我们信任A，我们是否信任C？这个问题不仅仅是一个哲学难题；它是一个精确的数学问题。我们可以把每个密钥想象成一个点，每次签署行为想象成从一个点到另一个点的有向箭头。A所信任的所有密钥的集合，就是从A出发沿着箭头可以到达的所有点。这是计算机科学中一个经典的问题，称为求图的[传递闭包](@entry_id:262879)，一个美妙的抽象，为信任如何在系统中传播奠定了逻辑基础[@problem_id:3279730]。现在，让我们看看这个抽象的图如何在日常使用的机器中成为一个可触摸的现实。

### 信任的基石：计算机的唤醒

在计算机中，信任链从何开始？它始于最开始的时刻，在你按下电源按钮后的瞬间。这个过程，被称为[安全启动](@entry_id:754616)（Secure Boot），也许是信任链最根本和最广泛的应用。在你的[操作系统](@entry_id:752937)开始加载之前，计算机的固件——[蚀刻](@entry_id:161929)在其硬件中的原始软件——被唤醒。它的首要工作是充当一长串守卫中的第一个。它包含一个受信任的“签名”列表，就像一个守卫有一份批准的徽章列表一样。只有当[引导加载程序](@entry_id:746922)出示了有效的、经过加密签名的徽章时，它才会将控制权交出。

这个[引导加载程序](@entry_id:746922)，现在已受信任，成为下一个守卫。它反过来在加载[操作系统内核](@entry_id:752950)之前检查其签名。然后内核验证自己的驱动程序，依此类推。这是一个链条，$C_0 \to C_1 \to C_2 \to \dots$，其中每个组件都拒绝启动下一个，除非其[数字签名](@entry_id:269311)无可挑剔。

这创造了一个强有力的保证：从通电的那一刻起，你的系统运行的就是硬件制造商或你授权的代码。这就是现代系统如何保护你免受试图感染启动过程的恶意软件，即所谓的“引导程序恶意软件（bootkits）”的侵害。但如果你是一个开发者，一个爱折腾的人，一个想在这个堡垒内运行自己定制代码的人呢？安全是否意味着即使对主人来说，墙壁也是不可逾越的？完全不是。这个链条被设计为可扩展的。例如，你可以将自己的密钥——一个机器所有者密钥（Machine Owner Key, MOK）——注册到固件的受信任列表中。通过用这个密钥签署你自己的定制内核模块，你就在告诉系统：“这段代码是我的。我信任它。”你已经无缝地将信任链扩展到包含你自己的创作，既保持了安全又维持了控制[@problem_id:3686058]。

然而，这条链的强度取决于其最薄弱的环节。考虑一台设置为双启动Windows和Linux的计算机。固件可能会安全地启动Windows[引导加载程序](@entry_id:746922)。它也可能会安全地启动一个Linux“垫片（shim）”和GRUB[引导加载程序](@entry_id:746922)。但如果GRUB随后被用户配置为在不检查其签名的情况下加载Linux内核，那么强制执行的链条就在那里断裂了[@problem_id:3679547]。一个守卫在没有检查徽章的情况下放了人进去。整个Linux会话的安全性现在都受到了损害，尽管启动过程开始时是安全的。这说明了一个深刻的观点：信任链不仅仅是一个需要启用的功能；它是一个在每一步都需要仔细配置的连续过程。

### 运行世界中的信任：超越启动

[安全启动](@entry_id:754616)让我们对系统*启动时*的状态有信心。但系统不是静态的；它们会改变。我们安装更新，应用补丁。那时我们的信任链会发生什么？想象一下，一台不能重启的服务器的内核中发现了一个严重的安全漏洞。我们需要执行“实时修补（live patching）”——一种对运行中的[操作系统](@entry_id:752937)进行的开膛手术。我们如何做到这一点而不使我们如此精心建立的信任失效？

这就是一个配套概念——**[度量启动](@entry_id:751820)（Measured Boot）**——登场的地方。如果说[安全启动](@entry_id:754616)是一个执行者，一个说“行”或“不行”的守卫，那么[度量启动](@entry_id:751820)就是一个一丝不苟、无法被收买的公证人。它使用主板上一个特殊的、防篡改的芯片，称为[可信平台模块](@entry_id:756204)（Trusted Platform Module, [TPM](@entry_id:170576)）。当系统启动时，[度量启动](@entry_id:751820)不仅仅是验证签名，它还会在每个组件——固件、[引导加载程序](@entry_id:746922)、内核——运行之前，获取其加密哈希（一个“度量”），并将这一系列度量记录在TPM中。TPM的寄存器，称为平台配置寄存器（PCR），被设计成度量只能被添加，在下次重启之前永远不能被删除或更改。

当我们应用一个实时内核补丁时，我们无法回到过去让[安全启动](@entry_id:754616)批准它。相反，我们使用一个在[可信启动](@entry_id:751820)过程中本身已经过验证的机制。这个机制首先验证补丁的签名以确保其真实性。然后，在应用它之前，它度量该补丁并将适当的PCR扩展到[TPM](@entry_id:170576)中。TPM的状态现在准确地反映了运行中系统的*整个*历史，包括在运行时应用的补补丁。这允许远程方对机器的状态进行“证明（attest）”，从TPM接收一份加密签名的报告，该报告不仅证明它安全地启动了，而且还证明它被一个特定的、授权的更新修补过[@problem_id:3679581]。信任链不再仅仅是在启动时锻造的[静态链](@entry_id:755372)条，而是一个可信演化的活生生的日志。

### 伟大的数字供应链：信任我们所构建的

这种追踪溯源的思想远远超出了内核的范围。现代软件很少从零开始构建。它像汽车一样，由来自全球数字供应链的成千上万个组件组装而成。当我们不知道每一颗螺母和螺栓的来源时，我们如何信任一个应用程序？

考虑一下为现代[云计算](@entry_id:747395)提供动力的容器。一个容器镜像是一层一层构建的。一个最小的基础[操作系统](@entry_id:752937)构成第一层，一个编程语言运行时是下一层，应用程序库是再下一层，最后是应用程序代码本身。攻击者可以在中间的某一层中滑入一个恶意库，而它将被深深地埋藏在最终产品中。

信任链提供了解决方案。一个安全的供应链策略可能要求每一层都必须由受信任的构建者进行加密签名。当容器运行时拉取镜像时，它不只是下载数据；它执行一次加密审计。它验证每一层的签名，确保每一层都是真实的且未被篡改。它还会对照一个允许的、最小化镜像的白名单检查基础层的哈希值。这就是应用于软件制造业的信任链[@problem_id:3673388]。

但这提出了一个极其深刻的问题。我们使用一个编译器来验证源代码并构建我们的程序。我们使用另一个编译器来构建那个编译器。但是什么构建了*第一个*编译器？我们如何能确定我们使用的第一个工具没有被篡改，以至于在它创建的每个程序（包括其他编译器）中注入后门？这就是传说中的“信任之信”（Trusting Trust）攻击，由Ken Thompson首次描述。审计源代码是无用的，因为恶意不在源代码中；它在工具里。

解决方案与问题一样优雅和深刻：**多样化双重编译（Diverse Double-Compiling）**。你拿你的新编译器的源代码，用两个完全独立的、“多样化的”现有编译器（比如，GCC和Clang）来编译它。如果其中一个有隐藏的“信任之信”攻击，它会产生一个恶意的编译器。另一个干净的编译器则会产生一个干净的。这两个产生的二进制文件不会是比特级相同的，攻击就会被揭示。如果它们*是*相同的，我们就能极大地相信没有这种诡计。这是将科学的[交叉验证](@entry_id:164650)应用于我们数字世界根基的美妙应用[@problem_id:3634583]。

### 跨越边界的信任：网络与虚拟世界

我们迄今为止的旅程主要局限在一台机器的范围内。但现代世界是网络化的。我们如何将信任链延伸到一个不安全的网络中，或者延伸到虚拟机的抽象领域？

想象一下数据中心里的一队无盘服务器。它们需要通过使用一种名为PXE的协议，从本地网络下载它们的[操作系统](@entry_id:752937)来启动。用于此目的的传统协议，如DHCP和TFTP，是出了名的不安全。网络上的攻击者可以轻易地拦截请求，并向服务器提供一个恶意的[操作系统](@entry_id:752937)镜像。为了解决这个问题，我们结合使用我们的工具。服务器的固件使用[安全启动](@entry_id:754616)来确保它只接受一个经过适当签名的初始网络引导程序（Network Bootstrap Program, NBP）。这个受信任的NBP随后会丢弃不安全的TFTP，并通过一个安全的、加密的通道（如TLS）启动其余[操作系统](@entry_id:752937)的下载，并锁定服务器的证书以确保它正在与正确的机器通话。所有这些都被度量到本地TPM中，从而允许[远程证明](@entry_id:754241)机器即使跨越敌对网络也安全地启动了[@problem_id:3679590]。

这个原则正是保障云本身安全的关键。当你启动一个虚拟机（VM）时，你是在一台不属于你的计算机上运行你的代码，由一个你看不到的管理程序管理。你如何能足够信任它，把最敏感的数据交给它？答案是一个虚拟化的信任链。云提供商的硬件使用[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)。然后，管理程序为你的VM创建一个**虚拟[TPM](@entry_id:170576)（v[TPM](@entry_id:170576)）**。这个vTPM在密码学上锚定到物理硬件TPM。

从你的VM的角度来看，它有自己私有的[TPM](@entry_id:170576)。它可以执行自己的[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)，从它的虚拟固件一直到它的内核建立起一条信任链。在你向它发送任何机密信息之前，你可以挑战它。VM使用它的v[TPM](@entry_id:170576)生成一个签名的证明引述，证明其确切的启动状态。因为v[TPM](@entry_id:170576)的身份与物理硬件和你的特定VM实例绑定，你可以确信你正在与一个运行在安全主机上的、真实的、未被篡改的VM通话。这就是实现[机密计算](@entry_id:747674)的魔力，使我们能够构建跨越所有权和管理边界的信任链[@problem_id:3689858]，并保护庞大的通信机器集群[@problem_id:3642419]。

### 超越代码：信任的普适语法

人们很容易认为信任链是计算机科学家和工程师的概念。但它的原则是普适的。它是为任何数字信息建立完整性和来源的基本模式。

考虑一下合成生物学领域。科学家设计新的生物组件和有机体，并使用标准数字格式（如[合成生物学开放语言](@entry_id:196757)，SBOL）来表示他们的设计。一个生产胰岛素的新酵母的设计可能建立在由世界各地不同实验室设计的十几个较小组件之上。科学家如何能相信他们下载的数字设计文件是来自其声称作者的真实文件，并且没有被巧妙地或恶意地更改过？

解决方案正是相同的信任链。要签署一个生物设计，我们必须首先为其创建一个规范化的、确定性的表示——一种对无关紧要的差异（如空白或元素顺序）不敏感的标准文本格式。然后我们对这个规范化文本进行加密哈希。如果设计链接到其他模型或数据，我们也对它们进行哈希，然后对合并的哈希值进行哈希。这个最终的哈希值随后使用作者的私钥进行[数字签名](@entry_id:269311)，其公钥可以通过标准的机构框架进行验证。当另一位科学家创建一个新的复合设计时，他们会包含他们所使用的父组件的加密哈希。这就创建了一个可验证的、机器可读的溯源记录——一条关于生命构件的信任链[@problem_id:2776432]。

从处理器中的第一束电火花，到云中虚拟机的复杂舞蹈，再到合成生物体的数字蓝图，信任链是一条贯穿始终的线索。它证明了一个简单而优雅思想的力量：通过逐一验证每个环节，我们可以构建一条长度和强度都惊人的链条，使我们能够在一个极其复杂的世界中建立信任。