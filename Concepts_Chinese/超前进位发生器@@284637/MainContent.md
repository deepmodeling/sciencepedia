## 引言
每个计算机处理器的核心都是加法这一基本运算，每秒执行数十亿次。然而，我们从小就熟悉的逐位相加的简单方法，却带来了一个关键的瓶颈。这个称为[行波](@article_id:323698)进位的顺序过程，创建了一个依赖链，其中每一步都必须等待前一步完成，从而极大地限制了计算速度。本文通过探索一种更优雅、更强大的解决方案——超前进位发生器，来解决这个根本性问题。

本文剖析了预测而非等待进位信号的天才构想。在第一部分 **原理与机制** 中，我们将探讨“产生”（Generate）和“传输”（Propagate）信号的核心概念，推导使超前计算成为可能的数学公式，并审视导致高效层次化结构的实际设计选择和限制。随后，在 **应用与跨学科联系** 部分，我们将拓宽视野，展示这一原理不仅是实现更快加法器的技巧，更是现代算术单元的基石、高能效设计的关键，以及一种被称为并行前缀计算的深奥计算模式的物理体现。

## 原理与机制

想象一下，您正在尝试将两个非常非常长的数字相加。也许它们各有上百位。您将它们对齐，一个在另一个上方，从最右边的一列开始。您将两个数字相加，写下和的数字，如果有进位，您就记在脑子里，然后移到下一列。您将那两个数字*加上*之前的进位相加。同样，您写下和，并将新的进位带到下一位。您一步一步地、辛苦地重复这个过程，从右到左移动。

注意到一些令人沮丧的事情了吗？在完成第九列之前，您无法确定第十列的和。在得到第八列的进位之前，您无法完成第九列，以此类推，一直回到第一列。这就是**[行波进位加法器](@article_id:356910)**的本质。进位像一排倒下的多米诺骨牌一样“行波”通过电路。这产生了一种“[长程依赖](@article_id:361092)”，这是计算中的一个根本性挑战，即最终答案可能会因第一个输入位的改变而改变 [@problem_id:1418865]。对于每秒执行数十亿次加法的计算机来说，这种等待游戏是一个关键的瓶颈。整个机器的速度都被这个缓慢、顺序的进位位行进过程所束缚。我们怎样才能做得更好呢？

### 打破链条：天才之举

为了摆脱行波的束缚，我们需要停止*等待*进位，而是尝试*预测*它。让我们站在加法中的某个位置 $i$。我们有两个输入位，$A_i$ 和 $B_i$，但我们还不知道来自前一个位置的进位 $C_i$。我们能说些什么有用的东西吗？事实证明，我们可以在不知道 $C_i$ 的情况下回答两个非常有力的问题：

1.  **“这个位置本身会*产生*一个进位吗？”**
    这当且仅当两个输入位都为1时发生。如果 $A_i=1$ 并且 $B_i=1$，它们的和是2（或二进制的10），所以我们肯定会向下一级发送一个进位，无论之前发生了什么。我们称之为**产生**信号，$G_i$。所以，$G_i = A_i \cdot B_i$（其中 $\cdot$ 是逻辑与）。

2.  **“如果一个进位到达，这个位置会将其*传输*到下一级吗？”**
    假设一个进位 $C_i=1$ 到达。为了让它继续向前，我们本地的和必须至少为1。这发生在我们的输入 $A_i$ 或 $B_i$ 中*至少有一个*为1的情况下。如果两者都为0，我们就会“吸收”输入的进位。如果至少有一个为1，输入的进位就会被传递下去。我们称之为**传输**信号，$P_i$。

这两个简单的信号，$G_i$ 和 $P_i$，是解锁并行加法的关键。一旦数字 $A$ 和 $B$ 已知，它们就可以在一步之内为每一个位位置同时计算出来。对于每个位切片 $i$，我们可以将逻辑总结如下 [@problem_id:1918190]：

| $A_i$ | $B_i$ | 条件                                     | $G_i$ | $P_i$ |
| :---: | :---: | :--------------------------------------- | :---: | :---: |
|   0   |   0   | 和为0。终止任何输入进位。                |   0   |   0   |
|   0   |   1   | 和为1。传输一个输入进位。                |   0   |   1   |
|   1   |   0   | 和为1。传输一个输入进位。                |   0   |   1   |
|   1   |   1   | 和为2。自身产生一个进位。                |   1   |   0   |

在这里，我们将传输信号定义为 $P_i = A_i \oplus B_i$（逻辑[异或](@article_id:351251)），这仅在恰好一个输入为1时为真。这个巧妙的选择将在后面带来好处。

### 预测的艺术：超前进位公式

现在我们可以用优美的清晰度来陈述从位置 $i$ 产生的进位输出 $C_{i+1}$ 的条件。一个进位将从我们的位置出现，如果：

-   我们的位置*产生*一个进位 ($G_i=1$)。
-   **或者**我们的位置*传输*一个进位 ($P_i=1$) **并且**一个进位从前一阶段到达 ($C_i=1$)。

用布尔代数的语言来说，就是：

$$
C_{i+1} = G_i + P_i C_i
$$

这个小小的方程是[超前进位加法器](@article_id:323491)的核心。它看起来仍然是递归的，但看看我们展开它时会发生什么。让我们找出进入第三位的进位 $C_2$。

使用我们对 $i=1$ 的公式，我们有 $C_2 = G_1 + P_1 C_1$。但 $C_1$ 是什么？它只是前一阶段 $i=0$ 的结果：$C_1 = G_0 + P_0 C_0$。现在，让我们把它代入 $C_2$ 的方程中：

$$
C_2 = G_1 + P_1 (G_0 + P_0 C_0)
$$

通过分配 $P_1$，我们得到：

$$
C_2 = G_1 + P_1 G_0 + P_1 P_0 C_0
$$

仔细看这个表达式 [@problem_id:1918177]。对中间进位 $C_1$ 的依赖消失了！$C_2$ 的值是*直接*用初始的传输和产生信号（$P_0, G_0, P_1, G_1$）以及整个加法器的第一个进位输入 $C_0$ 来表示的。所有这些信号几乎是立即已知的。我们不必等待任何[行波](@article_id:323698)。

### 并行超前展望

这就是魔术。我们可以对*每一个*进位位都这样做。例如，$C_3$ 的表达式变为 [@problem_id:1914731]：

$$
C_3 = G_2 + P_2 G_1 + P_2 P_1 G_0 + P_2 P_1 P_0 C_0
$$

对于 $C_4$：

$$
C_4 = G_3 + P_3 G_2 + P_3 P_2 G_1 + P_3 P_2 P_1 G_0 + P_3 P_2 P_1 P_0 C_0
$$

一个优美的模式出现了。每个进位都可以由一个专门的逻辑部分——一个**超前进位单元**——来计算，该单元将所有的 $P$ 和 $G$ 信号作为输入。由于所有这些 $P_i$ 和 $G_i$ 信号都是在一个步骤中并行计算的，一个专用的逻辑块接着也可以[并行计算](@article_id:299689)所有的进位 $C_1, C_2, \ldots, C_N$。这个逻辑结构是一个两级电路：一层与门用于形成乘积项（如 $P_2 P_1 G_0$），然后是一个或门将它们相加。这种两级门结构本质上是快速的，其延迟是固定的，与加法器的规模无关 [@problem_id:1925769]。多米诺骨牌链被打破了；我们用一个中央指挥中心取而代之，该中心同时计算所有的进位。

### 一个优雅的选择及其回报

让我们重新审视我们对传输信号的定义。我们选择了 $P_i = A_i \oplus B_i$。另一个常见的选择是“包容性传输”，定义为 $P_i'' = A_i + B_i$（逻辑或）。仅就进位逻辑而言，两种定义在功能上都是正确的 [@problem_id:1918160]。那么为什么更喜欢[异或](@article_id:351251)版本呢？

答案在于加法问题的*另一半*：计算和位本身。和位 $S_i$ 的公式是：

$$
S_i = A_i \oplus B_i \oplus C_i
$$

如果我们选择传输信号为 $P_i = A_i \oplus B_i$，我们会得到一个美妙的额外好处。和的方程变为：

$$
S_i = P_i \oplus C_i
$$

这意味着计算 $P_i$ 用于进位预测的同一块硬件可以被重用来计算最终的和！这是一个杰出工程设计的标志：一个单一组件服务于两个目的，节省了芯片面积，降低了[功耗](@article_id:356275)，并使整个加法器更有效率。通往最终和的路径包括生成 $P_i$ 和 $G_i$，在超前进位单元中使用它们来找到 $C_i$，然后组合 $P_i$ 和 $C_i$ 来得到 $S_i$。总时间，或[关键路径](@article_id:328937)，是这些顺序步骤的总和 [@problem_id:1925769]。

### 预见的局限与层次化的兴起

我们找到完美的解决方案了吗？不完全是。从 $C_4$ 的方程中可以看出，随着位数 ($N$) 的增加，表达式变得越来越长、越来越复杂。最终的进位 $C_N$ 需要一个有 $N+1$ 个输入的与门（用于计算项 $P_{N-1} \cdots P_0 C_0$）和一个有 $N+1$ 个输入的[或门](@article_id:347862)（用于将所有项相加） [@problem_id:1918182] [@problem_id:1918205]。

这带来了一个实际问题。物理逻辑门的输入数量不能任意大（这个属性称为**[扇入](@article_id:344674)**）。构建一个单级的64位CLA将需要有65个输入的门，这在大多数技术中是不切实际或不可能的。

那么，当我们的绝妙想法撞上物理墙壁时，我们该怎么办？我们再次应用同样的想法，但在一个更高的层次上！这就是**层次化[超前进位加法器](@article_id:323491)**的概念。我们可以用，比如说，八个较小的4位CLA模块来构建一个32位的CLA，而不是一个巨大的32位CLA。每个4位模块本身都很快。然后我们创建一个“第二级”超前进位单元。这个更高级别的单元不看单个的 $P_i$ 和 $G_i$ 信号。相反，它看的是来自每个4位模块的“块传输”和“块产生”信号。它快速计算模块*之间*的进位。

这种层次化方法巧妙地平衡了速度和复杂性。它保持了[扇入](@article_id:344674)要求的可管理性，同时保留了大部分的速度优势。例如，一个32位的两级CLA可以比同样大小的简单[行波进位加法器](@article_id:356910)快得多——速度提升可达8倍或更多 [@problem_id:1914735]。这正是几乎所有现代处理器核心的设计，证明了将[问题分解](@article_id:336320)并在多个抽象层次上应用巧妙思想的力量。