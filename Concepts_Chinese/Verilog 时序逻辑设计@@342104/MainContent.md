## 引言
在数字设计领域，逻辑电路通常被分为两个[基本类](@article_id:318739)别：组合逻辑和[时序逻辑](@article_id:326113)。组合逻辑根据当前输入提供即时答案，但它缺少任何复杂计算所必需的一个关键要素：存储。系统如何记住先前的操作、对事件计数或遵循一系列步骤？这正是[时序逻辑](@article_id:326113)的范畴，它是赋予数字系统状态、存储和时间感的架构支柱。本文旨在弥合存储概念与其在硬件描述语言中物理实现之间的鸿沟，为理解和正确使用 [Verilog](@article_id:351862) 建模[时序电路](@article_id:346313)提供全面的指导。

在第一章“原理与机制”中，我们将剖析[时序逻辑](@article_id:326113)的核心要素，从时钟和 D 型[触发器](@article_id:353355)的作用，到关键的 [Verilog](@article_id:351862) 编码实践，例如 `reg` 的正确使用以及阻塞与[非阻塞赋值](@article_id:342356)的重要区别。随后，在“应用与跨学科联系”中，我们将探讨这些基本原理如何组合成功能单元，如计数器、存储器和[有限状态机](@article_id:323352)，揭示它们在解决不同学科的实际工程挑战中的作用。

## 原理与机制

想象一下你正在用乐高（LEGO）积木进行搭建。你拥有组合逻辑积木——比如与门（AND）、或门（OR）和非门（NOT）。你将它们拼在一起，输出便是输入的瞬时函数。如果你改变一个输入，结果会立即贯穿整个电路。这是一个没有时间、没有记忆的世界。但如果你希望你的创造物能够*记住*一些事情呢？如果你希望它能计数、存储一个序列、拥有一个能影响其未来的过去呢？为此，你需要一种不同的积木——一块记忆积木。这就是[时序逻辑](@article_id:326113)的世界。

### 时钟的指令：存储与倾听的艺术

存储的根本挑战在于控制。如果一个电路记住了一个值，它应该在何时改变这个值？如果它持续不断地监听输入，那它就和一根简单的导线没什么两样。同步[数字设计](@article_id:351720)的精妙之处在于引入了一个指挥家，一个节拍器，它命令整个逻辑乐团同步行动：这个指挥家就是**时钟**。

最典型的存储元件是 **D 型[触发器](@article_id:353355)**。可以把它想象成一个纪律严明的守门人。它有一个数据输入 `d` 和一个输出 `q`。在绝大多数时间里，它完全忽略 `d`。无论 `d` 如何疯狂地来回翻转，都无关紧要。守门人等待的是一个特定的信号：时钟的节拍。在大多数设计中，这是[时钟信号](@article_id:353494)从低电平到高电平的跳变，即**上升沿**。只有在那个无限小的瞬间，守门人才会打开门，查看 `d` 的值，并让那个值成为 `q` 的新状态。一旦那个瞬间过去，门就会关闭，`q` 将稳定地保持该值直到下一个时钟节拍，无论 `d` 之后做什么。

问题 [@problem_id:1975217] 中的简单状态保持模块正是对这种行为的建模。`always @(posedge clk ...)` 结构是我们告诉守门人只监听时钟上升沿的方式。输出 `q` 仅在 `t = 10` ns 和 `t = 30` ns 时刻——即时钟上升沿的瞬间——发生变化，捕获 `d` 在那一精确时刻所具有的任何值。

当然，有时你也需要一个紧急停止按钮。**异步复位**就是这样的存在。通过在敏感列表中加入 `negedge rst_n`，我们赋予了复位信号凌驾于时钟之上的权力。当 `rst_n` 变为低电平时，[触发器](@article_id:353355)会立即被强制到一个已知状态（通常是 `0`），而无需等待时钟的许可。这是将复杂系统置于一个可预测的初始位置的关键机制。

### 状态的容器：`reg` 的真正含义

现在我们理解了状态保持元件的概念，那么在 [Verilog](@article_id:351862) 语言中我们该如何声明它呢？你可能会看到一个变量被声明为 `reg`，然后想：“啊，这就是我的寄存器！”这可能是整个 [Verilog](@article_id:351862) 中最常见、也最不幸的误解，一个因历史命名原因而困惑了几代工程师的怪癖。

事实是：**`reg` 并不意味着寄存器。**

`reg` 关键字指定的是一个能够在赋值之间保持值的变量。更正式地说，[Verilog](@article_id:351862) 的基本规则是：在一个**过程块**（`always` 或 `initial` 块）内作为赋值目标的信号，*必须*被声明为 `reg` 类型（或类似的可变类型如 `integer`）[@problem_id:1975235]。

可以这样想：`wire` 是一个被动的管道。它不能自己产生值；它必须被某个东西持续驱动，比如一个恒定的源或一个门的输出。它模拟的是一根物理导线。而 `reg` 则像一块白板。`always` 块提供了*何时*以及*写什么*到白板上的指令。在这些时刻之间，白板只是继续显示上次写在上面的内容。它保持着自己的状态 [@problem_id:1975480]。

因此，`reg` 只是一个数据的容器。这个容器最终是成为一个[触发器](@article_id:353355)、一个[锁存器](@article_id:346881)，还是仅仅是一个复杂[组合电路](@article_id:353734)的一部分，并非由 `reg` 本身决定，而是由我们在 `always` 块中描述的*行为*决定的。

### 打造存储：[触发器](@article_id:353355)、锁存器和意外后果

`always` 块是我们的画布，而敏感列表（`@(...)`）是我们最重要的画笔。它决定了我们的 `reg` 将响应哪些事件，并以此决定了将要综合出什么样的硬件。

-   **打造[触发器](@article_id:353355)**：要创建我们可靠的、[边沿触发](@article_id:351731)的[触发器](@article_id:353355)，我们让 `always` 块只对时钟边沿敏感，例如 `always @(posedge clk)`。这告诉综合器：“我正在描述一个硬件，它只应在 `clk` 的上升沿改变其状态。” 这是[同步](@article_id:339180)[触发器](@article_id:353355)的标志，正如问题 [@problem_id:1975224] 中的 `Module_B` 所示。它是稳健、可预测时序设计的基础。

-   **意外打造锁存器**：如果我们不够精确会发生什么？考虑一个用于描述[组合逻辑](@article_id:328790)的块，比如 `always @(*)`。这里的 `*` 是一个通配符，告诉该块在其*任何*输入改变时都重新求值。现在，想象你在这个块里写了一个 `if` 语句，但忘记了 `else` 部分，就像问题 [@problem_id:1975224] 中的 `Module_A` 那样。你告诉硬件当 `sel` 为 1 时 `q` 应该是什么，但没有说明当 `sel` 为 0 时该怎么做。综合工具看到这个，会做出一个逻辑推断：“如果条件为假，你没有告诉我改变 `q`。因此，我必须*记住* `q` 上次的值。” 这种由 `sel` 信号的*电平*（而不是其边沿）控制的记忆行为，就创建了一个**透明锁存器**。当 `sel` 为高电平时，[锁存器](@article_id:346881)是“透明的”，`q` 跟随 `d`。当 `sel` 为低电平时，[锁存器](@article_id:346881)是“关闭的”，`q` 保持其值。虽然[锁存器](@article_id:346881)可以被有意地设计 [@problem_id:1912833]，但意外地创建它们往往会导致时序问题和难以追踪的错误。

### 宏大的交响乐：使用[非阻塞赋值](@article_id:342356)进行并行更新

现在我们可以创建一个单独的[触发器](@article_id:353355)。但数字系统的强大之处在于让数百万个[触发器](@article_id:353355)协同工作。在每个时钟节拍，一场状态变化的宏大交响乐都会上演。我们如何用一种文本式的、顺序的语言来描述这场大规模的并行舞蹈呢？

这就引出了编写时序 [Verilog](@article_id:351862) 最关键的概念：**[非阻塞赋值](@article_id:342356) (`<=`)**。

让我们尝试构建一个简单的三级移位寄存器 [@problem_id:1912810]。在[时钟沿](@article_id:350218)，我们希望 `din` 流入第一个[触发器](@article_id:353355) (`q1`)，旧的 `q1` 流入第二个[触发器](@article_id:353355) (`q2`)，旧的 `q2` 流入第三个[触发器](@article_id:353355) (`q3`)。所有这一切都必须同时发生。

如果我们像软件程序员那样思考，就会遇到一个悖论。如果在 `q1 = din;` 之后写下 `q2 = q1;`，那么 `q2` 得到的是 `q1` 的*新*值还是*旧*值？这种模糊性正是[非阻塞赋值](@article_id:342356)所要解决的问题。

可以这样想：在时钟的上升沿，整个电路被拍下了一张快照。
1.  **求值阶段**：每个[触发器](@article_id:353355)*根据快照中的值*查看其输入，并确定它的下一个值应该是什么。用于 `q2` 的[触发器](@article_id:353355)看到的是时钟节拍*之前* `q1` 的值。用于 `q1` 的[触发器](@article_id:353355)看到的是 `din` 的值。它们都独立且并行地做出决定。
2.  **更新阶段**：在所有决定都做出之后，也只有在那时，所有的[触发器](@article_id:353355)才同时更新到它们的新值。

`q2 <= q1;` 的语法完美地捕捉了这一点。它的意思是，“`q2` 被赋予 `q1` 在这个时间步开始时的值。” 它不会阻塞。`always` 块中所有右侧表达式的求值在概念上是同时发生的，使用的是时钟节拍前的值。这就是为什么问题 [@problem_id:1915843] 中的 `ModuleB` 能够正确地建模一个移位寄存器，数据每个[时钟周期](@article_id:345164)前进一级。

这个原则是如此强大，以至于如果你对一个你认为是导线的中间信号使用[非阻塞赋值](@article_id:342356)，你实际上会为它创建一个寄存器！在问题 [@problem_id:1915865] 中，带时钟的块内的 `inv_data <= ~data;` 这一行并不会创建一个简单的反相器。它会创建一个反相器，后面跟着一个[触发器](@article_id:353355)，为电路增加了一整个[流水线](@article_id:346477)级。

### 混乱的故事：阻塞赋值的危险

如果说[非阻塞赋值](@article_id:342356)（`<=`）是我们故事中的英雄，那么**阻塞赋值（`=`）**就是它奸诈的双胞胎，在带时钟的 `always` 块中使用时会引发无尽的混乱。

在软件程序中，阻塞赋值是自然而然的。`x = 1; y = x;` 意味着 `y` 得到值 1。但硬件不是一个顺序执行的脚本；它是一个并行结构。当你在一个带时钟的块中使用阻塞赋值时，你是在告诉*仿真器*像脚本一样执行，在单个仿真瞬间内创建了一个[连锁反应](@article_id:298017)。

看看问题 [@problem_id:1915843] 的仿真对决中的 `ModuleA`。代码 `q1 = d; q2 = q1;` 会导致仿真器首先用 `d` 的值更新 `q1`。然后，在*同一个时钟节拍内*的下一步，它会用 `q1` 的*新*值更新 `q2`。数据瞬间从 `d` 一路冲到 `q2`。这并没有建模一个两级移位寄存器；它建模的是 `q1` 和 `q2` 并行加载 `d`。

这导致了数字设计中最可怕的弊病：**仿真-综合不匹配**。你的仿真遵循阻塞赋值的脚本式执行，显示出一种结果。而综合工具试[图构建](@article_id:339529)物理硬件，可能会推断出完全不同的结构，导致硬件的行为与你的测试不符。[@problem_id:1915894] 中令人困惑的逻辑和 [@problem_id:1915881] 中的[复位逻辑](@article_id:342377)都是典型的例子，其中仿真和综合出现了分歧，因为仿真的事件队列模型与硬件中优先逻辑的物理现实不匹配。混合使用阻塞和[非阻塞赋值](@article_id:342356)，如 [@problem_id:1915844] 中危险的计数器所示，会进一步加剧问题，产生无法映射到真实硬件的仿真竞争。

为了驾驭这片险恶的水域，有一条简单而明亮的规则可以保护你免受几乎所有这些困扰。这是 [Verilog](@article_id:351862) 的黄金法则：

-   当建模**[时序逻辑](@article_id:326113)**（`always @(posedge clk)` 块内的状态元件）时，**始终使用[非阻塞赋值](@article_id:342356) (`<=`)**。
-   当建模**[组合逻辑](@article_id:328790)**（`always @(*)` 块内的无状态逻辑）时，**使用阻塞赋值 (`=`)**。

遵守这一纪律可以确保你的代码在仿真中的行为忠实地代表你打算构建的硬件的并行、同步特性。它使你能够清晰而自信地描述那场宏大的、交响乐般的数据之舞。