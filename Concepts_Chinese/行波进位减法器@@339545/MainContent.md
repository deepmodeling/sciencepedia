## 引言
每个计算设备的核心都是执行算术运算的能力。虽然加法看似直接，但减法却带来了一个独特的挑战：我们是否必须构建一种全新的机器来处理它？本文探讨了数字逻辑中的这一基本问题，并揭示了一个对现代计算至关重要的精妙解决方案。我们将探索如何巧妙地将减法问题转化为加法问题，这一技巧极大地简化了处理器设计。在“原理与机制”一章中，我们将剖析[行波进位减法器](@article_id:355480)，理解二进制补码和简单的[逻辑门](@article_id:302575)如何动态地重新配置一个加法器。随后，“应用与跨学科联系”一章将拓宽我们的视野，展示这一核心概念如何成为 CPU [算术逻辑单元](@article_id:357121)的基石，甚至在未来主义的[量子计算](@article_id:303150)领域中也占有一席之地。

## 原理与机制

现在我们已经对[行波进位减法器](@article_id:355480)的功能有了大致了解，让我们揭开层层面纱，看看其内部精巧的机械构造。你可能会认为，要构建一台能做减法的机器，你需要一套与加法机完全不同类型的齿轮和杠杆。但自然界以及描述它的数学，往往要优雅得多。我们减法器的核心原理是一个非常巧妙的技巧：我们将使用一台只懂得做加法的机器，来构建一台能做减法的机器。

### 炼金术士的戏法：将减法变为加法

这怎么可能呢？秘密在于我们如何在计算机有限的世界里表示负数。想象一个只有三位数的汽车里程表。如果它显示`007`，然后你倒车 10 英里，它会显示什么？它会从 `000` 回滚到 `999`，然后是 `998`，最后停在 `997`。在这个只有三位数的小世界里，数字 `997` 的行为就像 `-3`（因为 `7 - 10 = -3`，并且 `7 + 997 = 1004`，在一个三位数显示器上只是 `004`，但等等……这不完全对。让我们调整一下这个比喻）。

让我们换个方式思考。在我们的二进制世界里，我们使用一种叫做**二进制[补码](@article_id:347145)**的系统。要找到一个数 $B$ 的负数，我们遵循一个简单的步骤：首先，你翻转它的每一个比特位（0 变为 1，1 变为 0），然后加 1。这个“翻转”后的版本称为**[反码](@article_id:351510)**，记作 $\bar{B}$。因此，$-B$ 的二进制补码表示就是 $\bar{B} + 1$。

为什么这样可行？我们稍后会探讨其深层的数学原因，但现在，只需将此步骤当作我们的规则。这意味着算术运算 $A - B$ 可以被重写为一个加法问题：

$A - B = A + (-B) = A + (\bar{B} + 1)$

突然间，我们的任务被改变了！我们不再需要发明减法。我们只需要构建一个电路，它能接收我们的数字 $B$，生成 $\bar{B}$，然后用一个标准加法器将 $A$、$\bar{B}$ 和 $1$ 相加。

### 通用算术引擎

这就引出了一个绝妙的工程杰作。我们如何能构建一个单一、通用的机器，它可以通过一个开关的切换来计算 $A+B$ 或 $A-B$？让我们使用我们的新方法。

对于加法，我们想计算 $A+B$。
对于减法，我们想计算 $A + \bar{B} + 1$。

让我们看看标准加法器的输入：两个数，我们称之为 $X$ 和 $Y$，以及一个初始进位 $C_{in}$，这个进位通常被忽略并设为 0。加法器计算 $X + Y + C_{in}$。

让我们将我们的数字 $A$ 直接连接到加法器的 $X$ 输入。现在，我们如何巧妙地生成 $Y$ 输入和 $C_{in}$，使其在两种情况下都有效？我们需要一个单一的控制信号，我们称之为 `SUB`。

- 当 `SUB = 0` 时（用于加法），我们需要 $Y = B$ 并且 $C_{in} = 0$。
- 当 `SUB = 1` 时（用于减法），我们需要 $Y = \bar{B}$ 并且 $C_{in} = 1$。

有没有一个单一的[逻辑门](@article_id:302575)能做到这一点？事实证明，**异或 (XOR)** 门是完美的选择。[异或门](@article_id:342323)有一个奇特但有用的特性：任何数与 0 进行[异或运算](@article_id:336514)结果保持不变（$B_i \oplus 0 = B_i$），但任何数与 1 进行[异或运算](@article_id:336514)结果都会被翻转（$B_i \oplus 1 = \overline{B_i}$）。它是一个*可编程反相器*！

因此，我们可以通过在 $B$ 的每一位上放置一个[异或门](@article_id:342323)来生成我们的 $Y$ 输入，并将 `SUB` 信号连接到所有这些异或门的另一个输入。对于每一位 $i$，加法器的输入将是 $Y_i = B_i \oplus \text{SUB}$。

那么减法所需的 `+1` 怎么办？注意到加法时我们需要 $C_{in}=0$，减法时需要 $C_{in}=1$。这恰好就是 `SUB` 信号的值！所以，我们可以将 `SUB` 信号直接连接到加法器的初始进位端口。[@problem_id:1958677]

看看这个解决方案的精妙之处！通过一根控制线 `SUB`，我们控制了整个电路的特性。[@problem_id:1973808] [@problem_id:1913354]
- 如果 `SUB = 0`：异或门充当直通导线（$Y_i = B_i \oplus 0 = B_i$），初始进位为 0。加法器计算 $A + B + 0$。
- 如果 `SUB = 1`：异或门充当反相器（$Y_i = B_i \oplus 1 = \overline{B_i}$），初始进位为 1。加法器计算 $A + \bar{B} + 1$。[@problem_id:1907558]

我们构建了一个统一的算术引擎。这是一个绝佳的例子，展示了一个简单的组件——加法器，如何通过一点巧妙的逻辑被赋予强大的新能力。

### 机器中的幽灵：为何一切行之有效

此时，你可能会觉得二进制补码这套东西有点像“黑魔法”般的技巧。它确实有效，但为什么呢？真正的原因是[计算机算术](@article_id:345181)中最基本的概念之一：**模运算**。

一个 $n$ 位的计算机寄存器不像一条无限延伸的数轴。它更像一个时钟。一个标准的挂钟是一个“模 12”系统。如果是 8 点，你加上 5 小时，你会得到 1 点，而不是 13 点。你已经“回绕”了。一个 $n$ 位的寄存器是一个“模 $2^n$”系统。对于一个 8 位数，世界从 0 到 255，然后又回绕到 0。在这个世界里，数字 $2^n$ 等价于 0。

根据定义，一个数 $B$ 的二进制[补码](@article_id:347145)是值 $2^n - B$。所以，当我们指示加法器计算 $A + (\bar{B} + 1)$ 时，我们实际上是在让它计算 $A + (2^n - B)$。

一个标准的 $n$ 位加法器自然地计算模 $2^n$ 的和。为什么？因为它只有 $n$ 位用于输出。如果“真实”的和需要更高的位，那个位就变成了最终的进位输出，而我们通常只是丢弃它。丢弃这个最终的进位在物理上等同于执行模 $2^n$ 运算。

所以，当我们把 $A$ 和 $B$ 的二进制补码输入到我们的加法器时，电路计算的是 $(A + (2^n - B)) \pmod{2^n}$。由于在模 $2^n$ 的世界里，加上 $2^n$ 就好比加上 0，这个式子可以完美地简化为：

$(A + 2^n - B) \pmod{2^n} \equiv (A - B) \pmod{2^n}$

这就是魔法所在。二进制[补码](@article_id:347145)表示法正是这样一个值，当它在一个模系统中被加上时，等效于减法。一个简单的无符号加法器能用于有符号算术，并非因为它有处理符号的特殊逻辑，而是因为它定长、回绕的算术本质与二进制补码的数学原理完美契合。[@problem_id:1914717]

### 多米诺效应：行波、延迟和隐藏才能

“行波进位”这个名字为该电路的工作方式提供了一个生动的画面。想象一排多米诺骨牌。第一位（最低有效位）的计算可能会产生一个进位，这个进位会“推倒”并成为第二位计算的输入。然后，第二位的计算可能会产生一个进位，推倒第三位，依此类推，一直延续下去。[@problem_id:1907547]

这种[行波](@article_id:323698)效应带来了有趣的后果。让我们看看最后倒下的那张多米诺骨牌——来自最高有效位的最终进位输出，我们之前说通常会丢弃它。事实证明，这个位不仅仅是废物！在执行减法 $A - B$（即 $A + \bar{B} + 1$）时，这个最终的进位输出位有特殊的含义。它充当一个反向的“借位”标志。如果最终的进位输出是 1，意味着不需要借位，这告诉我们 $A$ 的无符号值大于或等于 $B$ 的无符号值。如果进位输出是 0，意味着需要借位，并且 $A$ 小于 $B$。

想一想！在我们的减法器中，隐藏着一个**比较器**，一个告诉我们两个数哪个更大的电路。它免费附赠，是一个从底层数学中涌现出的额外功能。[@problem_id:1915337]

但是多米诺骨牌的比喻也揭示了电路最大的弱点：它很慢。在最后一张骨牌有机会倒下之前，最终正确的和是无法得到的。信号可能需要“行波”穿过每一个[全加器](@article_id:357718)级。总延迟是所有级延迟的总和。[@problem_id:1915348]

这种延迟在什么时候最严重？当我们在第一级产生一个进位，并且该进位必须一直传播到最后而不被中止时，就会发生可能的最长延迟。在我们的加减法器中，当您设置 `SUB = 1` 并提供两个相同的数字，比如 $A=B=0x000$ 时，就会出现这种情况的“完美风暴”。初始进位为 1，并且每一级的输入都恰好被设置为将这个进位逐级传递下去，从而产生可能的最大[传播延迟](@article_id:323213)。[@problem_id:1917943]

更奇怪的是，当这种[行波](@article_id:323698)发生时，减法器的输出处于变化之中。当进位传播时，它会瞬间产生不正确的中间值。例如，如果输入从 ($A=1000_2, B=0000_2$) 变为 ($A=1000_2, B=0001_2$)，减法器的输出不会立即从 $1000_2$ (8) 切换到 $0111_2$ (7)。相反，当计算的波浪在电路中传播开来时，它可能会短暂地闪烁成一个不正确的值，如 $1011_2$ (11)。[@problem_id:1915338] 这不是一个错误；这是计算需要时间完成的物理现实。

因此，[行波进位减法器](@article_id:355480)呈现了一个经典的工程权衡。它的设计非常简洁，巧妙地复用了常见的加法器。但这种简洁性是以速度为代价的，因为其性能受限于这种级联操作。然而，正是这个限制启发了一个新问题：我们能构建一个更快的加法器吗？我们能否在不等待所有多米诺骨牌倒下的情况下预测最终的进位？当然，那就是另一个故事了。