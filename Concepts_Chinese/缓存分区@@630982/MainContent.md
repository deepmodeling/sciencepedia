## 引言
在每个现代多核处理器的核心，都存在一个共享缓存——这是一种小容量、高速度的存储器，它既是关键的性能加速器，也是重大冲突的来源。当多个应用程序同时运行时，它们会争夺这一有限资源，从而产生“噪声邻居”问题，即一个程序的活动会严重降低另一个程序的性能。这种现象被称为缓存争用，它会破坏系统的可预测性，甚至可能造成安全漏洞。为了恢复秩序和控制，系统设计者采用了一种称为缓存分区的强大技术。

本文将探讨缓存分区如何将混乱的共享缓存转变为一个可管理且安全的资源。通过两章内容，您将全面理解这一基本概念。第一章“原理与机制”深入探讨了“共享缓存的悲剧”这一核心问题，并剖析了构建隔离屏障的两种主要方法：基于硬件的路分区和基于软件的[页面着色](@entry_id:753071)。随后的章节“应用与跨学科联系”揭示了这些技术的深远影响，从确保云端[服务质量](@entry_id:753918)到构建可预测的实时系统，再到防御复杂的[侧信道攻击](@entry_id:275985)。我们将从审视使这种转变成为可能的基本原理开始。

## 原理与机制

想象一个阳光明媚的下午，一个熙熙攘攘的城市公园。这个公园是一个共享资源，是供大家享用的“公地”。但当它变得过于拥挤时会发生什么？一群玩飞盘的人可能会不小心穿过一片安静的野餐区。一支声音嘈杂的乐队可能会淹没一场宁静的交谈。这种混乱，即一个群体的活动干扰了另一个群体，是一个被称为“[公地悲剧](@entry_id:192026)”的经典问题。在现代计算世界中，处理器的**共享缓存**就是那个熙熙攘攘的公园。

### 共享缓存的悲剧

[CPU缓存](@entry_id:748001)是一种小容量、速度极快的存储器，用于存储常用数据，从而使处理器不必耗时良久地访问主内存（RAM）。当多个程序或“核心”在同一芯片上运行时，它们通常会共享最大且最关键的缓存——**末级缓存（LLC）**。就像我们的公园一样，LLC是一个共享的公地，而这种共享导致了一个称为**缓存争用**或**干扰**的问题。

设想两个并排运行的应用[@problem_id:3145365]。一个是延迟敏感的Web服务，如金融交易服务器，需要即时响应。它就像野餐者，只需要一小块稳定不变的草地。另一个是带宽密集型的数据分析任务，需要处理海量数据。它就像玩飞盘的人，在公园里到处跑。这个庞大而激进的任务会不断“驱逐”（或踢出）那个敏感任务的小而重要的数据，使其离开共享缓存。

结果对敏感任务是灾难性的。其性能变得不可预测且缓慢，原因不在于其自身代码，而在于其“噪声邻居”。这就是共享缓存的悲剧：一个宝贵的资源因无控制的干扰而变得混乱和低效。为了恢复秩序，我们需要像城市规划者对待公园那样：我们需要建造围栏。这就是**缓存分区**的核心思想。

### 建造围栏：硬件与软件分区

缓存分区的目标很简单：为每个程序提供共享缓存的私有部分，将其与噪声邻居隔离开。这可以通过两种主要策略实现：一种依赖硬件特性，另一种则依赖[操作系统](@entry_id:752937)的一种巧妙技巧。

#### 硬件围栏：路分区

要理解硬件分区，我们必须先窥探一下现代缓存的内部。缓存被组织成许多“组”（sets），每个组包含少量称为“**路**”（ways）的槽位。一个典型的LLC每组可能有16路。当数据被取回时，它会根据其内存地址落入一个特定的组，并可以占据该组内的任何一路。

**路分区**是一种非常直接的方法，它为特定的[CPU核心](@entry_id:748005)或虚拟机在每个组中分配特定数量的路[@problem_id:3635192]。这就像在白板中间画一条粉笔线。采用英特尔**缓存分配技术（CAT）**等特性的现代处理器提供了实现此功能的硬件机制[@problem_id:3646225]。[虚拟机监视器](@entry_id:756519)或[操作系统](@entry_id:752937)可以对特殊寄存器进行编程，以创建“服务类别”，每个类别都有一个[位掩码](@entry_id:168029)，指定其允许使用的路。

效果是深远的。想象一下两个[虚拟机](@entry_id:756518)VM A和VM B在缓存中发生冲突。VM A有一个较小的[工作集](@entry_id:756753)，包含3个映射到同一个缓存组的数据项，而VM B有一个较大的工作集，包含6个数据项。在一个未分区的8路缓存中，它们不断相互驱逐，两者都会遭遇缓存未命中。现在，我们对其进行分区：我们给VM A恰好3路，给VM B剩下的5路。瞬间，VM A的3个数据项完美地放入了其私有分区。其性能变得完美无瑕，命中率达到100%，完全不受VM B造成的任何混乱的影响。VM B仍然会遇到困难，因为其工作集（6个项目）大于其分区（5路），但关键是，它再也无法干扰VM A。我们实现了完美的隔离。

#### 软件围栏：[页面着色](@entry_id:753071)的艺术

如果硬件不提供显式的路分区功能怎么办？[操作系统](@entry_id:752937)可以执行一种更为巧妙的操作，称为**[页面着色](@entry_id:753071)**。该技术依赖于对[虚拟内存](@entry_id:177532)与物理缓存之间关系的深刻洞察。

程序使用的是*虚拟*地址，但缓存是由*物理*地址索引的。[操作系统](@entry_id:752937)通过页表控制从程序的虚拟页面到[RAM](@entry_id:173159)中物理页帧的映射。物理页面的“颜色”由其物理地址中用于计算缓存组索引的特定位决定。通过精心选择分配给程序的物理帧，[操作系统](@entry_id:752937)可以控制程序能访问哪些“颜色”——也就是哪些缓存组。

让我们来揭开这个谜底。物理地址只是一个数字。缓存硬件使用这个数字的一部分作为索引来选择一个组。例如，在一个有2048个组的系统中，它可能会使用地址的第6到16位。同时，[操作系统](@entry_id:752937)将内存划分为页，比如每页4KB。页内地址由最低的12位定义。

诀窍就在这里：一些缓存索引位可能*高于*页内偏移位。在我们的例子中，第12到16位用于缓存索引，但它们是物理页号的一部分，而物理页号是由[操作系统](@entry_id:752937)控制的。这些就是**颜色位**。通过只给一个进程分配颜色位为（例如）`0101`的物理页，[操作系统](@entry_id:752937)确保该进程*只能*访问与该颜色相对应的缓存组[子集](@entry_id:261956)。这就像只给一个程序蓝色纸，给另一个程序红色纸；尽管它们在同一个共享板上书写，但它们的笔记会落在不同且不重叠的区域[@problem_id:3665990] [@problem_id:3668459]。

一个“颜色感知”的[操作系统](@entry_id:752937)可以为不同进程分配不相交的颜色集，从而在没有任何特殊硬件支持的情况下有效分割缓存。相反，一个颜色无知的[操作系统](@entry_id:752937)可能会意外地将相同颜色的页面分配给两个相互竞争的进程，使其活动集中，从而产生一个剧烈冲突的“热点”，这种现象称为**缓存[抖动](@entry_id:200248)**[@problem_id:3645332]。

### 成效：性能、可预测性与保护

现在我们理解了缓存分区的“是什么”和“怎么做”，我们可以探讨其深远的“为什么”。驯服共享缓存的能力不仅仅是学术上的好奇心；它是现代[系统设计](@entry_id:755777)的基石，支撑着三种关[键能](@entry_id:142761)力。

#### 性能与[服务质量](@entry_id:753918)（QoS）

在云计算和数据中心，许多“租户”（客户）在相同的物理硬件上运行应用程序。缓存分区是提供**[服务质量](@entry_id:753918)（QoS）**的重要工具——确保一个租户的批处理作业不会破坏另一个租户电子商务网站的性能。通过为敏感应用程序提供受保护的缓存分区，系统操作员可以保证其一定水平的性能，该性能以**[每指令周期数](@entry_id:748135)（[CPI](@entry_id:748135)）**等指标来衡量[@problem_id:3145365]。

然而，分区并非万能灵药。它提供的隔离保护了一个程序免受*他人*的干扰，但不能免受*自身*的干扰。如果一个程序自身的数据[工作集](@entry_id:756753)大于分配给它的分区，它将遭受自冲突，性能会下降。强行将一个需要$256\,\text{KB}$缓存的进程放入一个$128\,\text{KB}$的分区，其结果可能比将其留在一个更大、共享的缓存中更糟[@problem_id:3665977]。缓存管理的艺术在于找到恰当的平衡。

分区还能防止更微妙的干扰形式，例如由激进的**[硬件预取](@entry_id:750156)器**引起的**[缓存污染](@entry_id:747067)**。这些预取器试图猜测程序下一步需要什么数据并提前获取。虽然这通常有帮助，但邻居的预取器可能会用无用数据填满缓存，从而驱逐你的有用数据[@problem_id:3625389]。分区就像一道防火墙，将每个进程的预取活动限制在自己的空间内。

#### [实时系统的可预测性](@entry_id:754138)

在某些系统中，平均性能并非主要目标。对于控制汽车防抱死刹车或工厂机械臂的计算机而言，重要的是**可预测性**。每个操作都必须在严格的截止时间内完成，无一例外。在这里，敌人是可变性，而共享系统中最大的可变性来源就是干扰。

当一个高优先级的实时任务运行时，它可能会被一个更高优先级的任务抢占。这种抢占不仅会暂停该任务，还可能将其数据从缓存中清除，导致其恢复运行时引发一连串代价高昂的缓存未命中。这会使其**最坏情况执行时间（WCET）**膨胀，从而难以或不可能保证它能满足其截止时间。

缓存分区提供了一个强大的解决方案。通过为关键实时任务分配私有的、不重叠的缓存分区，我们可以消除任务间的缓存干扰。一个任务的WCET将不再受其邻居的影响。如一个[实时调度](@entry_id:754136)场景所示，这种分区可以显著减少由缓存[抖动](@entry_id:200248)引起的WCET膨胀——在一个例子中，任务的最坏情况[响应时间](@entry_id:271485)从危险的$16.6\,\text{ms}$改善到安全的$11.8\,\text{ms}$，恢复了近30%[@problem_id:3646407]。对于[实时系统](@entry_id:754137)而言，这关系到系统是能正常工作还是会失败。

#### 防御无形之敌

也许缓存分区最引人注目的现代应用是在安全领域。近年来，研究人员发现了一类可怕的新型漏洞，如Spectre和Meltdown，被称为**[侧信道攻击](@entry_id:275985)**。这些攻击允许恶意程序窃取同一台机器上运行的另一程序的秘密（如密码或加密密钥），不是通过直接读取其内存，而是通过观察其在共享硬件（如缓存）上执行时产生的微妙副作用。

其中最强大的技术之一是**Prime+Probe**攻击。攻击者首先通过用自己的[数据填充](@entry_id:748211)一组缓存行来“预备”（prime）缓存。然后它等待一小段时间，在此期间受害者程序运行。接着，攻击者通过计时重新读取自己数据所需的时间来“探测”（probe）。如果受害者访问了相同的缓存组，攻击者的一些缓存行将被驱逐，探测会变慢（因为发生了缓存未命中）。如果受害者没有触及那些组，探测就会很快。通过有条不紊地预备和探测不同的缓存组，攻击者可以重建受害者内存访问模式的映射，最终泄露敏感信息。

缓存分区是一种直接而有力的防御措施。如果攻击者和受害者被置于独立的、不相交的缓存分区中，受害者的执行就*永远*无法驱逐攻击者的缓存行。信道被切断了。攻击者的探测将总是很快，什么也揭示不了。这种将物理硬件转变为安全“金库”的做法，极大地降低了[侧信道攻击](@entry_id:275985)的**信道容量**，使其更难被利用。这种安全性并非没有代价；将进程限制在较小的分区中可能会使其变慢。但在一个充满无形威胁的世界里，分区提供了一面强大的盾牌，用少量性能换取了巨大的安全增益[@problem_id:3679343]。

从一个混乱的公地到一个由私家花园组成的有序景观，缓存分区将共享缓存转变为一个可管理、可预测和安全的资源。它是一项基本原则，展示了硬件架构、[操作系统](@entry_id:752937)设计与现代计算最终目标——性能、可靠性和安全性——之间美妙的相互作用。

