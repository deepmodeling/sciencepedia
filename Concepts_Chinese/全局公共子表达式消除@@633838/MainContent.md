## 引言
从本质上讲，追求效率遵循一个简单的规则：永远不要重复做同样的工作。在软件世界中，这一原则由[优化编译器](@entry_id:752992)来倡导，它是一种能将人类编写的代码精炼成高效机器指令的复杂工具。其中最强大的技术之一是全局[公共子表达式消除](@entry_id:747511) (GCSE)，这是一个在整个程序范围内系统地搜寻并消除重复计算的过程。但这种搜寻充满了风险；过于激进的优化可能会改变程序的行为，甚至导致程序崩溃。这就提出了一个关键问题：编译器如何在积极追求性能与绝对保证正确性之间取得平衡？

本文深入探讨了全局[公共子表达式消除](@entry_id:747511)的复杂世界，揭示了支配这一基本优化的逻辑和权衡。在第一章 **原理与机制** 中，我们将剖析可用性和支配性的基本规则，探索[静态单赋值](@entry_id:755378) (SSA) 和[全局值编号](@entry_id:749934) (GVN) 这些如侦探般的工具，并揭示那些可能使优化变得不安全的现实世界复杂性。随后，在 **应用与跨学科联系** 中，我们将看到这个避免冗余工作的基本原则如何超越编译器，在数据库查询优化和高性能 GPU 编程等不同领域中展现出惊人的关联性。

## 原理与机制

想象一下你正在按照食谱做饭。在第2步，食谱上写着：“计算一个5英寸圆形挞模的面积。”你 dutifully 计算出 $A = \pi r^2$。然后，在混合好馅料后的第7步，它又要求你“计算同一个5英寸挞模的面积，看看馅料是否能装下。”你可能会翻个白眼。你已经做过这个计算了！为什么还要再算一次？你只会重用你第一次得到的结果。

这种简单、直观的不重复工作的行为，正是**全局[公共子表达式消除](@entry_id:747511) (GCSE)** 的灵魂所在。编译器在追求让你的代码运行得更快的过程中，就像一个非常聪明、非常谨慎的厨师。它会扫描整个食谱（你程序的[控制流图](@entry_id:747825)），寻找可以只执行一次、并将结果保存以备后用的相同计算（[公共子表达式](@entry_id:747510)）。但编译器的厨房是一个奇特而危险的地方。如果在第2步和第7步之间，食谱告诉你把挞模拉伸一下，改变了它的半径怎么办？重用旧的面积计算结果现在将是一场灾难。

这就是 GCSE 的精妙之舞：在积极追求效率的同时，保持对正确性绝对、不可动摇的承诺。要理解这场舞蹈，我们必须首先了解它所表演的舞台的基本规则。

### 两大支柱：可用性与支配性

为了让[编译器安全](@entry_id:747554)地消除一个重复的计算，必须满足两个条件。假设我们有一个计算 $t = x + y$，之后又有另一个计算 $u = x + y$。

首先，原始表达式的值必须是**可用的** (available)。这意味着在 $t$ 被计算后，通往 $u$ 的路径上不能包含任何改变操作数 $x$ 或 $y$ 值的指令。如果在中间某个地方 $y$ 被修改了，那么第二个位置的表达式 $x + y$ 即使在文本上完全相同，其值也不再是“同一个”表达式了。这是 [@problem_id:3644008] 中场景的核心挑战，其中变量 $y$ 仅在通往一个公共点的两条路径之一上被更新。表达式 $x - y$ 在一条路径上是可用的，但在另一条路径上则不然。

其次，原始计算必须**支配** (dominate) 其重用点。在[控制流图](@entry_id:747825)的语言中，如果从程序入口到块 $B$ 的每一条可能路径都*必须*经过块 $A$，那么我们说块 $A$ 支配块 $B$。这是一种执行上的保证。如果我们在一个支配第二次计算位置的块中计算了 $x + y$，我们就能确定这个值在需要之前已经被计算出来了。[@problem_id:3644005] 中的计算就是一个完美的例子。块 `B3` 中的一个计算支配其两个后继块 `B4` 和 `B5`。因此，在 `B3` 中计算的值保证可以在 `B4` 和 `B5` 中重用，使得那里的重新计算成为冗余。

这两个原则——可用性和支配性——构成了安全的[公共子表达式消除](@entry_id:747511)的基石。

### 侦探工作：发现等价性

陈述规则是一回事，但编译器实际上是如何在一个复杂的、充满分支的程序中*找到*这些冗余的呢？它需要复杂的侦探工具。

#### [静态单赋值](@entry_id:755378) (SSA)：一个充满常量的世界

想象一个世界，在那里每个变量一旦被赋值，就永远不能改变。它变成了一个常量。这就是**[静态单赋值](@entry_id:755378) (SSA)** 形式所创造的美丽而简单的虚构世界。当编译器将程序转换为 SSA 形式时，它会重命名变量，使得每个名称只被赋值一次。

但是，当两条[控制路径](@entry_id:747840)合并，而一个变量可能来自任一路径时，会发生什么呢？SSA 用一种称为 **$\phi$ (phi) 函数** 的特殊方程来解决这个问题。如果变量 $x$ 可能来自左路径的 $x_1$ 或右路径的 $x_2$，在合并点我们定义一个新变量 $x_3$，像这样：$x_3 = \phi(x_1, x_2)$。这个方程不计算任何东西；它是一种符号表示，告诉编译器：“如果来自左路径，则 $x_3$ 的值为 $x_1$；如果来自右路径，则为 $x_2$。”

SSA 使[全局分析](@entry_id:188294)变得异常简单。通过给每个不同的值一个唯一的名称，它让冗余变得显而易见。在 [@problem_id:3644005] 中，一旦我们有了 $t_0 = u_0 + z_3$，任何后来出现的 $u_0 + z_3$ 显然都是冗余的，因为名称 $u_0$ 和 $z_3$ 指的是单一、不变的值。

#### [全局值编号](@entry_id:749934) (GVN)：值的真实名称

GVN 为我们提供了变量的唯一名称，但表达式本身呢？两个表达式可能在值上完全相同，即使它们看起来不同。这就是**[全局值编号](@entry_id:749934) (GVN)** 发挥作用的地方。GVN 就像一个通用的值哈希系统。它为程序中计算的每个不同的值分配一个唯一的“[值编号](@entry_id:756409)”。

最初，每个输入变量都会获得一个唯一的[值编号](@entry_id:756409)。然后，对于像 $t_1 \leftarrow a + b$ 这样的计算，编译器会创建一个与操作 `+` 以及 $a$ 和 $b$ 的[值编号](@entry_id:756409)相关联的新[值编号](@entry_id:756409)。如果它后来看到一个表达式 $t_2 \leftarrow c + d$，并发现 $a$ 和 $c$ 具有相同的[值编号](@entry_id:756409)，并且 $b$ 和 $d$ 也一样，它就知道 $t_1$ 和 $t_2$ 是等价的。它们会得到相同的[值编号](@entry_id:756409)。

这就是编译器如何执行像 [@problem_id:3643965] 中那样的识别壮举，其中像 $t_1 \times t_2$ 和 $t_4 \times t_2$ 这样的表达式被发现是相同的，因为 GVN 证明了 $t_1$ 和 $t_4$（两者都是 $a+b$）是相同的值。

此外，一个真正聪明的 GVN 系统懂得代数。它可以将表达式规范化。在 [@problem_id:3644012] 中，表达式 $x + (x + y)$ 和 $(x + x) + y$ 在语法上是不同的。但是，一个知道加法满足[结合律](@entry_id:151180)和[交换律](@entry_id:141214)的 GVN 算法可以将两者都表示为其原始组件的多重集——两个 $x$ 和一个 $y$——并为它们分配相同的[值编号](@entry_id:756409)，从而揭示它们隐藏的等价性。

当 SSA 和 GVN 结合使用时，它们是一对强大的组合。SSA 提供了一张清晰的值流图，而 GVN 则确定了这些值的真实身份。

### 超越基础：部分冗余的艺术

如果一个表达式在*一条*路径上计算了，但在另一条路径上没有，会发生什么？在合并点，该表达式是**部分冗余的**：如果你从一个方向来，它是冗余的；但如果你从另一个方向来，它又是必需的 [@problem_id:3643953]。

一个简单的 GCSE 算法会束手无策。但一种更先进的技术，称为**[部分冗余消除](@entry_id:753187) (PRE)**，可以玩一个聪明的把戏。它会说：“如果我把缺失的计算插入到那条‘裸’路径上会怎么样？”通过这样做，它将部分冗余转化为了完全冗余。现在，该表达式保证在所有通往合并点的路径上都是可用的，并且可以被安全地提升到一个支配块中，只计算一次 [@problem_id:3644008]。这是一种主动的优化，编译器在一个地方增加一点工作，以便在之后节省大量工作。

有时，这个技巧更加微妙。在 [@problem_id:3644059] 中，表达式 $x + y$ 是在 $x$ 在一条路径上被递增之后计算的。简单的提升将是不正确的，因为它会使用 $x$ 的*旧*值。但一个高级的优化器仍然可以找到优化的机会。它可以提升原始的 $x + y$，称之为 $t$，然后在 $x$ 被递增的那条路径上，将结果计算为 $t + 1$。这种代数补偿展示了可以编码到编译器中的非凡创造力。

### 现实世界的反噬：当优化非法时

到目前为止，我们一直生活在一个纯净的、数学的世界里。但真实的程序是混乱的。它们与[操作系统](@entry_id:752937)、硬件以及其他线程交互。这正是[编译器设计](@entry_id:271989)真正挑战和美妙之处的体现。一个好的编译器必须是一个悲观主义者，意识到所有可能出错的事情。

#### 机器中的幽灵：副作用与纯粹性

如果一个表达式不仅仅是计算一个值呢？一个函数调用可能会写入文件、更新全局变量或读取系统时钟。这样的操作具有**副作用**，它打破了一个称为**引用透明性**的关键属性。如果一个表达式对于相同的输入总是产生相同的输出，并且没有其他可观察到的效果，那么它就是引用透明的。

[@problem_id:3643998] 中的函数 `f(n)`，其内部调用了 `clock()`，是一个经典的例子。两个 `f(n) + f(n)` 的调用不是一个[公共子表达式](@entry_id:747510)！每次调用 `clock()` 都会返回一个新值。消除一个调用会改变程序的结果。同样，在 [@problem_id:3643989] 中，一个读取全局 `seed` 的 `hash(s)` 函数如果其他函数可能在两次调用之间改变那个 `seed`，就不能被自由移动。

为了应对这种情况，编译器依赖于注解。一个标记为 `pure` (纯函数) 的函数是一个承诺，保证它是引用透明的。一个标记为 `volatile` (易变) 的变量是对编译器的警告：“这个值可能随时因你看不见的原因而改变！不要优化掉对我的读写操作。”

#### 代码中的地雷：异常的危险

有些表达式是地雷。表达式 $a / b$ 是完全安全的，除非 $b$ 是零，那样它会触发一个灾难性的异常。现在考虑 [@problem_id:3643992] 中的程序。表达式 $a / b$ 是在代码已经明确检查了 $b \neq 0$ 的路径上计算的。另一条路径，为 $b = 0$ 的情况，则完全避免了这个表达式。

一个天真的 GCSE 可能会看到重复的 $a / b$ 并将其提升到一个在检查*之前*执行的支配块中。这是**不安全的[推测执行](@entry_id:755202)**。转换后的程序现在会在一条在原始程序中完全安全的路径上因除零错误而崩溃。一个正确的优化器必须证明一个可能产生异常的指令是安全的，*然后*才能将其移动到一个它会更频繁执行的位置。

#### 浮点数学的模糊世界

在纸上，$x^2$ 与 $x \times x$ 完全相同。在计算机中，使用[浮点数](@entry_id:173316)，这可能不完全为真。在 [@problem_id:3643951] 中，我们看到库函数 `pow(x, 2)` 和直接乘法 `x * x` 可能会因为四舍五入而产生微小的不同结果。更重要的是，它们可能有不同的副作用。语言标准可能要求 `pow` 函数在[溢出](@entry_id:172355)时设置一个全局错误变量 `errno`，而乘法运算符则不会。如果程序稍后检查 `errno`，一个用 `x * x` 替换 `pow(x, 2)` 的优化将改变程序的可观察行为。

这就是为什么许多编译器都有一个“`fast-math`”(快速数学)模式。这是程序员和编译器之间的一个协议。程序员说：“我保证我不在乎这些微妙的浮点规则或 `errno`。只要让我的代码快就行。”只有得到这个许可，编译器才能将 $x^2$ 和 $x \times x$ 视为相同。

#### [并发编程](@entry_id:637538)的无序状态

也许对优化最大的现代挑战是并发。如果多个线程同时运行，一个共享变量可能在任何时刻被另一个线程改变。在 [@problem_id:3644006] 中，一个线程执行了两次 `atomic_load_acquire(x)`。我们可以消除第二次加载吗？绝对不能。原子加载不仅仅是一次读取；它是与并发系统其余部分的通信。在第一次和第二次加载之间，另一个线程可能已经向 `x` 写入了一个新值。消除第二次加载将意味着该线程对这个更新视而不见，违反了[内存模型](@entry_id:751871)并导致混乱。

这揭示了一个深刻的转变。在一个并发的世界里，许多经典的优化必须被重新评估或放弃，因为一个看似冗余的操作实际上可能是一个关键的同步点。

### 编译的无名艺术

我们的旅程始于一个简单的想法：不要重复做同样的工作。我们很快发现，当这个原则应用于复杂的计算机程序[世界时](@entry_id:275204)，它远非简单。它需要一套复杂的逻辑推导工具——如 SSA 和 GVN——来发现代码背后的真正含义。它需要像 PRE 这样聪明的策略来主动创造优化机会。最重要的是，它要求对机器的现实有深刻而谦逊的尊重：尊重副作用、尊重异常、尊重浮点数学的怪癖，以及尊重并发的狂野、不可预测的本质。

[优化编译器](@entry_id:752992)的工作是一种无名的艺术形式。它是追求性能与保证正确性之间一场无声而复杂的舞蹈，是几十年计算机科学研究的结晶。下次当你的代码运行得惊人地快时，花点时间欣赏一下编译器隐藏的天才，那个分析了每一条路径、打磨了每一条指令、将你的人类逻辑转化为闪电般现实的不倦侦探。

