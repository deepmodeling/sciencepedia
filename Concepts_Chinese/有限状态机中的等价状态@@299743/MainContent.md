## 引言
[有限状态机](@article_id:323352)（FSMs）是无数数字系统的概念支柱，从简单的控制器到复杂的处理器。然而，初始设计过程常常导致状态机包含比实际需要更多的状态，从而引发效率低下、复杂性增加和实现成本提高等问题。这就提出了一个关键问题：我们如何系统地识别并消除这种冗余，以创造出最精简、最优化的设计？本文深入探讨[状态等价](@article_id:325040)的基本概念来回答这个问题。我们将首先探索其核心原理和机制，定义状态在行为上等价的含义，并介绍一种强大的[算法](@article_id:331821)来识别它们。随后，我们将考察其广泛的应用和跨学科联系，说明[状态最小化](@article_id:336923)不仅仅是一种理论练习，更是工程乃至合成生物学中的实用工具，揭示了系统的本质。

## 原理与机制

### 对简洁性的追求

想象一下，你正在设计一台复杂的机器——一个机器人的大脑、一个[网络路由](@article_id:336678)器，甚至是一台精密的咖啡机。这些设备的核心控制系统通常被建模为**[有限状态机](@article_id:323352)（FSMs）**。在初始设计的创新（有时是混乱）过程中，定义的状态数量常常超过了严格必要的数量。这就像绘制一张地图时，无意中给同一个物理位置起了几个不同的名字——“大都会”、“哥谭”和“中心城”都指向同一个地点。这种冗余使得地图杂乱、令人困惑且难以使用。

作为追求优雅的工程师和科学家，我们的目标是清理这张地图。我们希望找到并合并这些冗余状态。但为什么要这样做呢？这仅仅是为了知识上的整洁吗？完全不是。一个更简单的机器从根本上说是一个更好的机器。它更优雅，更容易分析错误，最重要的是，构建起来更高效。例如，一个有七个状态的机器在硬件实现上至少需要三位内存（使用三个“[触发器](@article_id:353355)”，因为 $2^3 = 8 \gt 7$）。然而，如果我们能证明这个机器在行为上与一个只有四个状态的机器完全相同，那么我们只需要两位内存（$2^2 = 4$）。从三个[触发器](@article_id:353355)减少到两个不仅仅是小小的节省；它可以极大地简化周围的[逻辑电路](@article_id:350768)，节省芯片上的物理空间，降低[功耗](@article_id:356275)，并减少制造成本 [@problem_id:1962524]。这就是[状态最小化](@article_id:336923)的实际魔力：削减抽象的冗余，创造一个更精简、更高效的现实。

### 黑盒测试：什么是等价？

那么，两个状态，我们称之为 $S_a$ 和 $S_b$，是“相同的”，这到底意味着什么？这与它们的名字或我们在图表上如何绘制它们无关。它们同一性的本质在于它们的*行为*。

让我们做一个思想实验。想象一下，我们的 FSM 被密封在一个黑盒子里。你看不到它内部的齿轮，只有一个输入按钮面板和一个输出指示灯显示屏。我秘密地将机器设置为从状态 $S_a$ 或状态 $S_b$ 开始，但我不会告诉你具体是哪个。你的任务是进行一次审问：你可以按动任何你能想到的按钮序列，并观察由此产生的光影秀。

如果在尝试了所有可以想象到的输入序列后，你发现完全无法判断机器是从 $S_a$ 还是 $S_b$ 开始它的旅程——因为对于每一次可能的审问，指示灯的序列都是相同的——那么从所有实际目的来看，$S_a$ 和 $S_b$ *就是*相同的。我们称它们为**等价状态**。它们在行为上是无法区分的。从外部世界的角度来看，它们之间的任何差异都只是虚构。

### 区分状态的艺术

通过测试所有无限的输入序列来[直接证明](@article_id:301614)两个状态是等价的，当然是不可能的。所以，我们反其道而行之。我们不试图证明它们相同，而是扮演侦探的角色，尽最大努力证明它们*不同*。我们将寻找任何证据，任何它们伪装上的裂痕，来揭示它们行为上的差异。任何经受住我们最严格区分尝试的状态对，通过这种排除法，必然是等价的 [@problem_id:1942697]。

#### 明显的线索：不匹配的输出

揭示两个状态不同的最直接方法，是发现它们对同一个简单问题给出相互矛盾的回答。想象你正在测试一个 **Mealy 型 FSM**，其输出取决于当前状态和当前输入。如果从状态 $S_i$ 开始并输入 '0' 会使一个输出灯亮起（输出 '1'），但从状态 $S_j$ 开始并输入相同的 '0' 却使灯保持熄灭（输出 '0'），那么——啊哈！——我们抓到罪魁祸首了。这两个状态是不同的。我们用一个长度为一的输入序列成功地将它们区分开来。

这给了我们第一个也是最基本的规则：如果存在至少一个输入，使得两个状态产生不同的输出，那么它们是**可区分的** [@problem_id:1962533]。这就是为什么，对于 Mealy 型 FSM 中的两个状态，要被考虑为等价的候选者，它们在[状态表](@article_id:323531)中对应的输出行对于所有输入都必须绝对相同 [@problem_id:1962499]。

#### 关联推断：递归的本质

如果两个状态，比如 $S_0$ 和 $S_1$，足够聪明，通过了我们的初步测试呢？对于我们尝试的每一个单一输入，它们都 dutifully 地产生完全相同的输出。它们是等价的吗？没那么快！问题可能潜伏在下一步。一个很好的例子表明，状态可以有相同的即时输出行为，但仍然存在根本差异 [@problem_id:1942658]。

我们必须看它们*接下来*去哪里。假设对于输入 '0'，$S_0$ 和 $S_1$ 都产生输出 '1'。但是，$S_0$ 转移到一个新状态 $S_a$，而 $S_1$ 转移到状态 $S_b$。如果我们*已经确定* $S_a$ 和 $S_b$ 是可区分的，那么我们就间接找到了区分 $S_0$ 和 $S_1$ 的方法！我们只需应用输入 '0'（到目前为止它们都给出相同的输出），*然后*我们应用我们已知可以区分 $S_a$ 和 $S_b$ 的输入序列。后续的输出将会出现分歧，从而揭示原始状态 $S_0$ 和 $S_1$ 确实是不同的。

这揭示了问题的精妙递归核心。两个状态是可区分的，如果：
1.  它们对于某个输入有不同的输出。
或者
2.  它们对于某个输入转移到一对可区分的状态。

这个原则就是“关联推断”。两个状态可以被证明是不同的，不仅因为它们自身的行为，也因为它们所关联的状态。

### 大分类：[划分算法](@article_id:642246)

这个[递归定义](@article_id:330317)看起来有点像一条蛇在吃自己的尾巴。我们如何系统地应用它而不在循环推理中迷失方向？答案在于一个优雅而强大的程序，称为**[划分算法](@article_id:642246)**。

想象一下，我们机器的所有状态都是被扔进一个大碗里的弹珠。我们的任务是将这些弹珠分拣到更小的碗里，最终每个碗里只包含彼此无法区分的弹珠。

*   **第 1 步：初始划分 ($P_0$)**。我们从一个粗略的分类开始。我们*仅*根据状态的即时、可观察的输出行为来划分它们。对于一个 **Moore 型 FSM**（输出仅取决于状态），我们会把所有输出 '0' 的状态放在一个碗里，所有输出 '1' 的状态放在另一个碗里。对于一个 Mealy 型 FSM，我们会把在[状态表](@article_id:323531)中具有相同输出行的状态分组。这个初始划分 $P_0$ 已经分开了那些明显不同的状态。任何起始于不同碗里的两个状态都被确认为是可区分的 [@problem_id:1962531]。

*   **第 2 步：细化划分 ($P_k \to P_{k+1}$)**。现在，我们查看当前划分 $P_k$ 中的每个碗。我们应用“关联推断”原则。对于碗中的每个状态，我们检查它在每个可能输入下的目标状态。关键在于，我们不关心目标状态的确切名称，只关心它属于 $P_k$ 的哪个碗（或*块*）。
    *   如果一个给定碗中的所有状态都有相同的“转移特征”——例如，在输入 '0' 时它们都转移到碗 X 中的状态，在输入 '1' 时它们都转移到碗 Y 中的状态——那么在这一轮中它们可以继续待在一起。它们的行为是一致的。
    *   然而，如果在同一个碗内，对于相同的输入，一些[状态转移](@article_id:346822)到碗 X，而另一些[状态转移](@article_id:346822)到碗 Y，我们就发现了它们之间一个新的、更微妙的差异！我们必须拆分这个碗。转移到 X 的状态形成一个新的、更小的碗，而转移到 Y 的状态形成另一个 [@problem_id:1962531]。

*   **第 3 步：重复直到稳定**。我们重复这个细化过程，创建一系列划分 $P_1, P_2, P_3, \ldots$，其中每一个都是前一个更精细的版本。这个过程最终必须结束，因为我们只能将状态分割这么多次。当我们完成一整轮细化并且没有新的分割发生时，我们就停止。此时划分是稳定的：$P_k = P_{k+1}$。我们的工作完成了 [@problem_id:1962490]。最终的碗就是真正的**[等价类](@article_id:316440)**。单个碗内的所有状态都是相互等价的，并且没有状态与不同碗中的任何[状态等价](@article_id:325040) [@problem_id:1962530]。在某些情况下，这个过程可能会以每个状态都在自己的碗里结束，这只是告诉我们这个机器本来就已经是最小的了 [@problem_id:1962490]。

### 构建更好的状态机

我们扮演了侦探的角色，并成功地将我们的状态分拣到它们最终的[等价类](@article_id:316440)中。现在是收获的时候了：构建我们新的、精简的 FSM。

这个过程非常直接。我们最终划分中的每个等价类都被提升为新机器中的一个单一状态。如果我们的分析显示原始状态 $(B, D, F)$ 都是等价的，它们就合并成一个单一的新状态，为方便起见，我们可以简单地将其命名为 'B' [@problem_id:1942716]。

要定义这个新状态的行为，我们只需查看其任何一个原始成员。因为它们在行为上都是相同的，所以它们都会讲述同一个故事。新状态 'B' 的输出将与原始状态 B 的输出相同。如果原始状态 B 在某个输入下转移到状态 G，并且我们知道 G 属于等价类 $(A, G)$，那么我们的新状态 'B' 在该输入下就简单地转移到新状态 'A' [@problem_id:1942716]。

最终的产物是一个新的、更小的[状态表](@article_id:323531)，它描述了一个状态更少的机器，但从外部世界的角度来看，其行为与那个更大的、未化简的原始机器完全相同。我们剥离了冗余，揭示了机器的本质核心——一个在表面的复杂性中发现简洁与统一的完美例子。

### 关于“[无关项](@article_id:344644)”的说明

在现实世界中，机器的规格并不总是完美的。有时，设计者知道对于某个特定的状态和输入，输出值是无关紧要的；它可以是 '0' 或 '1'，而更广泛的系统都能正常工作。这些情况被标记为“[无关项](@article_id:344644)”。

当一个 FSM 包含这些“[无关项](@article_id:344644)”时，我们严格的等价概念就软化成一个更灵活的概念：**相容性**。如果对于任何输入，两个状态的指定输出都不冲突（例如，一个必须是 '0'，另一个必须是 '1'），那么它们就是相容的。如果一个状态的输出是 '0'，而另一个是“[无关项](@article_id:344644)”，它们是相容的，因为我们可以简单地选择将“[无关项](@article_id:344644)”视为 '0' 来使它们匹配。

因此，在分析一个不完全指定的机器时，如果在过程结束时有一对未被标记的状态，这表示这些状态是相容的，而不一定是在最严格意义上等价。这给了设计者更大的自由度来合并状态，从而可能实现更大幅度的简化 [@problem_id:1942651]。