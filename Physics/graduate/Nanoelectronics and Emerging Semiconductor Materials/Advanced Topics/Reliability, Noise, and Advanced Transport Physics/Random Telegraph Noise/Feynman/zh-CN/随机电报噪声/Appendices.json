{
    "hands_on_practices": [
        {
            "introduction": "理解随机电报噪声（RTN）的关键一步是将其物理模型与实验中可测量的量联系起来。功率谱密度（PSD）是在频域中表征噪声的核心工具。这项练习将通过从基本的双态马尔可夫过程出发，推导出RTN的洛伦兹谱，从而连接起时域中的俘获和发射时间常数与频域中的噪声特征。通过这个推导，你将掌握RTN频谱的关键特征，例如其低频坪和特征性的$1/f^{2}$滚降，这些都是表征单个缺陷活动的重要标志。",
            "id": "3769556",
            "problem": "一个纳米级金属-氧化物-半导体场效应晶体管在固定的栅极和漏极偏置条件下工作，此时单个氧化物/界面缺陷会间歇性地俘获和发射一个载流子，从而使沟道电流在两个电平之间调制。由此产生的电流涨落是一个平稳、遍历的双态连续时间马尔可夫过程，通常称为随机电报噪声 (RTN)。设平均俘获时间为 $\\tau_{c}$，平均发射时间为 $\\tau_{e}$，因此跃迁速率为 $\\lambda_{c}=1/\\tau_{c}$ 和 $\\lambda_{e}=1/\\tau_{e}$。电流在相差 $2A$ 的两个电平之间跳变，因此围绕平均值的涨落可以建模为 $\\delta I(t)\\in\\{+A,-A\\}$。\n\n从双态马尔可夫过程的定义、此类过程的指数自相关函数、以及作为自相关函数的傅里叶变换的单边电流功率谱密度 (PSD) $S_{I}(f)$ 出发，推导出 $S_{I}(f)$ 关于 $A$、$\\lambda_{c}$ 和 $\\lambda_{e}$ 的解析表达式。将拐角频率 $f_{c}$ 定义为 $S_{I}(f)$ 等于其低频平台值 $S_{I}(0)$ 一半时的频率，并用 $\\lambda_{c}$ 和 $\\lambda_{e}$ 表示 $f_{c}$。然后，对于 $\\tau_{c}=10\\,\\mathrm{ms}$、$\\tau_{e}=5\\,\\mathrm{ms}$ 和 $2A=100\\,\\mathrm{nA}$ 的情况，计算 $f_{c}$ 和在 $f=10\\,\\mathrm{Hz}$ 时的 $S_{I}(f)$ 值。在此过程中，从你推导的表达式中明确展示低频平台和高频 $1/f^{2}$ 滚降特性。将拐角频率以 $\\mathrm{Hz}$ 为单位表示，PSD 以 $\\mathrm{A}^{2}/\\mathrm{Hz}$ 为单位表示。将你的数值结果四舍五入到三位有效数字。",
            "solution": "用户希望我解决以下问题：\n“一个纳米级金属-氧化物-半导体场效应晶体管在固定的栅极和漏极偏置条件下工作，此时单个氧化物/界面缺陷会间歇性地俘获和发射一个载流子，从而使沟道电流在两个电平之间调制。由此产生的电流涨落是一个平稳、遍历的双态连续时间马尔可夫过程，通常称为随机电报噪声 (RTN)。设平均俘获时间为 $\\tau_{c}$，平均发射时间为 $\\tau_{e}$，因此跃迁速率为 $\\lambda_{c}=1/\\tau_{c}$ 和 $\\lambda_{e}=1/\\tau_{e}$。电流在相差 $2A$ 的两个电平之间跳变，因此围绕平均值的涨落可以建模为 $\\delta I(t)\\in\\{+A,-A\\}$。\n\n从双态马尔可夫过程的定义、此类过程的指数自相关函数、以及作为自相关函数的傅里叶变换的单边电流功率谱密度 (PSD) $S_{I}(f)$ 出发，推导出 $S_{I}(f)$ 关于 $A$、$\\lambda_{c}$ 和 $\\lambda_{e}$ 的解析表达式。将拐角频率 $f_{c}$ 定义为 $S_{I}(f)$ 等于其低频平台值 $S_{I}(0)$ 一半时的频率，并用 $\\lambda_{c}$ 和 $\\lambda_{e}$ 表示 $f_{c}$。然后，对于 $\\tau_{c}=10\\,\\mathrm{ms}$、$\\tau_{e}=5\\,\\mathrm{ms}$ 和 $2A=100\\,\\mathrm{nA}$ 的情况，计算 $f_{c}$ 和在 $f=10\\,\\mathrm{Hz}$ 时的 $S_{I}(f)$ 值。在此过程中，从你推导的表达式中明确展示低频平台和高频 $1/f^{2}$ 滚降特性。将拐角频率以 $\\mathrm{Hz}$ 为单位表示，PSD 以 $\\mathrm{A}^{2}/\\mathrm{Hz}$ 为单位表示。将你的数值结果四舍五入到三位有效数字。”\n\n### 第一步：提取已知条件\n- 该过程是一个平稳、遍历、双态连续时间马尔可夫过程（随机电报噪声）。\n- 平均俘获时间：$\\tau_c$。\n- 平均发射时间：$\\tau_e$。\n- 俘获跃迁速率：$\\lambda_c = 1/\\tau_c$。\n- 发射跃迁速率：$\\lambda_e = 1/\\tau_e$。\n- 电流在相差 $2A$ 的两个电平之间跳变。\n- 围绕平均值的涨落建模为 $\\delta I(t) \\in \\{+A, -A\\}$。\n- 问题要求用 $A$、$\\lambda_c$、$\\lambda_e$ 推导单边功率谱密度 $S_I(f)$。\n- 问题要求推导拐角频率 $f_c$，其中 $S_I(f_c) = S_I(0)/2$。\n- 问题要求展示低频平台和高频 $1/f^2$ 滚降。\n- 用于计算的数值：$\\tau_c = 10\\,\\mathrm{ms}$，$\\tau_e = 5\\,\\mathrm{ms}$，$2A = 100\\,\\mathrm{nA}$。\n- 需要计算 $f_c$ 和在 $f = 10\\,\\mathrm{Hz}$ 时的 $S_I(f)$。\n- 数值结果必须四舍五入到三位有效数字。\n\n### 第二步：使用提取的已知条件进行验证\n- **科学基础**：该问题描述了半导体器件中单个陷阱引起的随机电报噪声 (RTN) 的标准模型。这是固态物理和电子器件工程领域一个成熟的课题。该模型基于随机过程理论（特别是双态马尔可夫链）及其在电子噪声中的应用，具有科学合理性。\n- **问题适定**：该问题提供了推导所求量所需的所有信息。平均时间、跃迁速率、电流电平和功率谱密度之间的关系定义明确。对解析推导和数值计算的要求也很清晰。\n- **客观性**：该问题以精确的量化术语陈述。在“围绕平均值的涨落可以建模为 $\\delta I(t)\\in\\{+A,-A\\}$”这一陈述中存在一个微小的模糊之处。对于 $\\tau_c \\neq \\tau_e$ 的一般情况，该过程是非对称的，围绕平均值的涨落幅度不等于 $\\pm A$。然而，核心物理参数是总电流阶跃高度 $\\Delta I$，其被明确地给定为 $2A$。如下所示，最终的功率谱密度 (PSD) 仅取决于此阶跃高度 $\\Delta I$ 和跃迁速率，而不取决于绝对电平或其是否以平均值为中心。因此，这种不精确性不妨碍得到唯一且正确的解。该问题可以被形式化并严格求解。\n- **所有其他验证标准均已满足**：该问题不是隐喻性的、不完整的、矛盾的或琐碎的。\n\n### 第三步：结论与行动\n该问题被判定为**有效**。将提供完整解答。\n\n该物理过程是一个双态系统。设状态为状态 $0$（低电流，陷阱被占据）和状态 $1$（高电流，陷阱为空）。从状态 $1$ 到状态 $0$ 的跃迁速率是俘获速率，$\\lambda_c = 1/\\tau_c$。从状态 $0$ 到状态 $1$ 的跃迁速率是发射速率，$\\lambda_e = 1/\\tau_e$。\n\n对于平稳过程，处于状态 $0$ 和状态 $1$ 的概率 $P_0$ 和 $P_1$ 是恒定的。它们由平衡方程 $\\lambda_c P_1 = \\lambda_e P_0$ 以及归一化条件 $P_0 + P_1 = 1$ 决定。\n求解该方程组可得稳态概率：\n$$ P_0 = \\frac{\\lambda_c}{\\lambda_c + \\lambda_e} $$\n$$ P_1 = \\frac{\\lambda_e}{\\lambda_c + \\lambda_e} $$\n\n设两种状态下的电流为 $I_0$ 和 $I_1$。问题指出电平差为 $2A$，因此我们定义电流阶跃高度为 $\\Delta I = |I_1 - I_0| = 2A$。我们感兴趣的信号是电流围绕其平均值 $\\langle I \\rangle$ 的涨落 $\\delta I(t)$。\n平均电流为 $\\langle I \\rangle = I_0 P_0 + I_1 P_1$。\n涨落信号为 $\\delta I(t) = I(t) - \\langle I \\rangle$。\n在状态 $0$ 中，涨落为 $\\delta I_0 = I_0 - \\langle I \\rangle = I_0 - (I_0 P_0 + I_1 P_1) = I_0(1-P_0) - I_1 P_1 = I_0 P_1 - I_1 P_1 = -(I_1-I_0)P_1 = -\\Delta I P_1$。\n在状态 $1$ 中，涨落为 $\\delta I_1 = I_1 - \\langle I \\rangle = I_1 - (I_0 P_0 + I_1 P_1) = I_1(1-P_1) - I_0 P_0 = I_1 P_0 - I_0 P_0 = (I_1-I_0)P_0 = \\Delta I P_0$。\n注意，平均涨落为 $\\langle \\delta I \\rangle = \\delta I_0 P_0 + \\delta I_1 P_1 = (-\\Delta I P_1)P_0 + (\\Delta I P_0)P_1 = 0$，符合预期。\n\n对于双态马尔可夫过程，涨落的自相关函数 $R_{\\delta I}(\\tau) = \\langle \\delta I(t) \\delta I(t+\\tau) \\rangle$ 已知为指数衰减：\n$$ R_{\\delta I}(\\tau) = \\sigma_{\\delta I}^{2} \\exp\\left(-\\frac{|\\tau|}{\\tau_{eff}}\\right) $$\n其中 $\\sigma_{\\delta I}^{2}$ 是涨落的方差，$\\tau_{eff}$ 是相关衰减的有效时间常数。\n方差为 $\\sigma_{\\delta I}^{2} = \\langle (\\delta I)^2 \\rangle = (\\delta I_0)^2 P_0 + (\\delta I_1)^2 P_1$。\n$$ \\sigma_{\\delta I}^{2} = (-\\Delta I P_1)^2 P_0 + (\\Delta I P_0)^2 P_1 = (\\Delta I)^2 (P_1^2 P_0 + P_0^2 P_1) = (\\Delta I)^2 P_0 P_1 (P_0+P_1) = (\\Delta I)^2 P_0 P_1 $$\n代入 $P_0$ 和 $P_1$ 的表达式：\n$$ \\sigma_{\\delta I}^{2} = (\\Delta I)^2 \\frac{\\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^2} $$\n有效时间常数 $\\tau_{eff}$ 由跃迁速率之和给出：\n$$ \\tau_{eff} = \\frac{1}{\\lambda_c + \\lambda_e} $$\n代入 $\\Delta I = 2A$，自相关函数为：\n$$ R_{\\delta I}(\\tau) = (2A)^2 \\frac{\\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^2} \\exp(-(\\lambda_c + \\lambda_e)|\\tau|) = \\frac{4A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^2} \\exp(-(\\lambda_c + \\lambda_e)|\\tau|) $$\n\n根据 Wiener-Khinchin 定理，对于 $f \\ge 0$，单边功率谱密度 (PSD) $S_I(f)$ 是自相关函数的傅里叶变换的两倍。更常见的表达式为：\n$$ S_I(f) = 4 \\int_{0}^{\\infty} R_{\\delta I}(\\tau) \\cos(2\\pi f \\tau) d\\tau $$\n代入 $R_{\\delta I}(\\tau)$ 的表达式：\n$$ S_I(f) = 4 \\left( \\frac{4A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^2} \\right) \\int_{0}^{\\infty} \\exp(-(\\lambda_c + \\lambda_e)\\tau) \\cos(2\\pi f \\tau) d\\tau $$\n该积分为标准拉普拉斯变换结果：$\\int_0^\\infty e^{-s t} \\cos(\\omega t) dt = \\frac{s}{s^2+\\omega^2}$。\n这里，$s = \\lambda_c + \\lambda_e$ 且 $\\omega = 2\\pi f$。\n$$ \\int_{0}^{\\infty} \\exp(-(\\lambda_c + \\lambda_e)\\tau) \\cos(2\\pi f \\tau) d\\tau = \\frac{\\lambda_c + \\lambda_e}{(\\lambda_c + \\lambda_e)^2 + (2\\pi f)^2} $$\n因此，PSD 为：\n$$ S_I(f) = \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^2} \\frac{\\lambda_c + \\lambda_e}{(\\lambda_c + \\lambda_e)^2 + (2\\pi f)^2} $$\n$$ S_I(f) = \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e) \\left[ (\\lambda_c + \\lambda_e)^2 + (2\\pi f)^2 \\right]} $$\n这就是单边 PSD 的解析表达式，它具有洛伦兹形式。\n\n接下来，我们求拐角频率 $f_c$。首先，我们在 $S_I(f)$ 的表达式中令 $f=0$，以确定低频平台 $S_I(0)$：\n$$ S_I(0) = \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e) [(\\lambda_c + \\lambda_e)^2 + 0]} = \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^3} $$\n拐角频率 $f_c$ 由 $S_I(f_c) = S_I(0)/2$ 定义。\n$$ \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e) \\left[ (\\lambda_c + \\lambda_e)^2 + (2\\pi f_c)^2 \\right]} = \\frac{1}{2} \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^3} $$\n消去公因子：\n$$ \\frac{1}{(\\lambda_c + \\lambda_e)^2 + (2\\pi f_c)^2} = \\frac{1}{2(\\lambda_c + \\lambda_e)^2} $$\n$$ 2(\\lambda_c + \\lambda_e)^2 = (\\lambda_c + \\lambda_e)^2 + (2\\pi f_c)^2 $$\n$$ (\\lambda_c + \\lambda_e)^2 = (2\\pi f_c)^2 $$\n由于 $f_c$ 和速率均为正值，我们取正根：\n$$ 2\\pi f_c = \\lambda_c + \\lambda_e \\implies f_c = \\frac{\\lambda_c + \\lambda_e}{2\\pi} $$\n\n现在我们可以用 $S_I(0)$ 和 $f_c$ 来表示 PSD：\n$$ S_I(f) = \\frac{S_I(0)(\\lambda_c + \\lambda_e)^2}{(\\lambda_c + \\lambda_e)^2 + (2\\pi f)^2} = S_I(0) \\frac{(2\\pi f_c)^2}{(2\\pi f_c)^2 + (2\\pi f)^2} = S_I(0) \\frac{1}{1 + (f/f_c)^2} $$\n这种形式清楚地展示了在不同频率范围内的行为。\n- **低频平台**：对于 $f \\ll f_c$，项 $(f/f_c)^2 \\to 0$，因此 $S_I(f) \\approx S_I(0)$，为一个常数。\n- **高频滚降**：对于 $f \\gg f_c$，项 $(f/f_c)^2 \\gg 1$，因此 $S_I(f) \\approx S_I(0) \\frac{1}{(f/f_c)^2} = S_I(0) \\frac{f_c^2}{f^2}$。这表明在高频下 PSD 与 $1/f^2$ 成正比。\n\n最后，我们计算数值。\n已知：\n$\\tau_c = 10\\,\\mathrm{ms} = 1 \\times 10^{-2}\\,\\mathrm{s}$\n$\\tau_e = 5\\,\\mathrm{ms} = 5 \\times 10^{-3}\\,\\mathrm{s}$\n$2A = 100\\,\\mathrm{nA} = 1 \\times 10^{-7}\\,\\mathrm{A} \\implies A = 5 \\times 10^{-8}\\,\\mathrm{A}$\n\n首先，计算跃迁速率：\n$\\lambda_c = 1/\\tau_c = 1/(1 \\times 10^{-2}\\,\\mathrm{s}) = 100\\,\\mathrm{s}^{-1}$\n$\\lambda_e = 1/\\tau_e = 1/(5 \\times 10^{-3}\\,\\mathrm{s}) = 200\\,\\mathrm{s}^{-1}$\n\n接下来，计算拐角频率 $f_c$：\n$$ f_c = \\frac{\\lambda_c + \\lambda_e}{2\\pi} = \\frac{100\\,\\mathrm{s}^{-1} + 200\\,\\mathrm{s}^{-1}}{2\\pi} = \\frac{300}{2\\pi}\\,\\mathrm{Hz} \\approx 47.746\\,\\mathrm{Hz} $$\n四舍五入到三位有效数字，$f_c = 47.7\\,\\mathrm{Hz}$。\n\n现在，我们计算在 $f=10\\,\\mathrm{Hz}$ 时的 PSD 值。我们首先计算低频平台值 $S_I(0)$：\n$$ S_I(0) = \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e)^3} = \\frac{16(5 \\times 10^{-8}\\,\\mathrm{A})^2 (100\\,\\mathrm{s}^{-1})(200\\,\\mathrm{s}^{-1})}{(100\\,\\mathrm{s}^{-1} + 200\\,\\mathrm{s}^{-1})^3} $$\n$$ S_I(0) = \\frac{16(25 \\times 10^{-16}\\,\\mathrm{A}^2) (2 \\times 10^4\\,\\mathrm{s}^{-2})}{(300\\,\\mathrm{s}^{-1})^3} = \\frac{8000 \\times 10^{-16}\\,\\mathrm{A}^2\\cdot\\mathrm{s}^{-2}}{27 \\times 10^6\\,\\mathrm{s}^{-3}} = \\frac{8 \\times 10^{-13}}{2.7 \\times 10^7}\\,\\mathrm{A}^2 \\cdot \\mathrm{s} $$\n$$ S_I(0) = \\frac{8}{27} \\times 10^{-16}\\,\\mathrm{A}^2/\\mathrm{Hz} \\approx 2.96296 \\times 10^{-17}\\,\\mathrm{A}^2/\\mathrm{Hz} $$\n现在我们使用洛伦兹形式来求 $S_I(10\\,\\mathrm{Hz})$：\n$$ S_I(10\\,\\mathrm{Hz}) = S_I(0) \\frac{1}{1 + (10\\,\\mathrm{Hz}/f_c)^2} = (2.96296 \\times 10^{-17}) \\frac{1}{1 + (10 / 47.746)^2} $$\n$$ S_I(10\\,\\mathrm{Hz}) \\approx (2.96296 \\times 10^{-17}) \\frac{1}{1 + (0.20944)^2} \\approx (2.96296 \\times 10^{-17}) \\frac{1}{1 + 0.043865} $$\n$$ S_I(10\\,\\mathrm{Hz}) \\approx \\frac{2.96296 \\times 10^{-17}}{1.043865} \\approx 2.8384 \\times 10^{-17}\\,\\mathrm{A}^2/\\mathrm{Hz} $$\n四舍五入到三位有效数字，$S_I(10\\,\\mathrm{Hz}) = 2.84 \\times 10^{-17}\\,\\mathrm{A}^2/\\mathrm{Hz}$。\n\n结果摘要：\n- 推导出的 $S_I(f)$ 表达式：$S_I(f) = \\frac{16A^2 \\lambda_c \\lambda_e}{(\\lambda_c + \\lambda_e) [(\\lambda_c + \\lambda_e)^2 + (2\\pi f)^2]}$。\n- 推导出的拐角频率：$f_c = \\frac{\\lambda_c + \\lambda_e}{2\\pi}$。\n- 计算出的拐角频率：$f_c \\approx 47.7\\,\\mathrm{Hz}$。\n- 计算出的 $10\\,\\mathrm{Hz}$ 处的 PSD：$S_I(10\\,\\mathrm{Hz}) \\approx 2.84 \\times 10^{-17}\\,\\mathrm{A}^2/\\mathrm{Hz}$。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 47.7  2.84 \\times 10^{-17} \\end{pmatrix} } $$"
        },
        {
            "introduction": "在理论推导之后，下一个挑战是如何从真实的实验数据中提取物理参数。在实践中，我们测量到的是一段离散的电流波动时间序列，我们的目标是从这些数据中反推出潜在的物理参数，例如平均俘获时间 $\\tau_{c}$ 和平均发射时间 $\\tau_{e}$。这项练习将引导你应用最大似然估计（MLE）这一强大的统计方法来解决这个逆问题。你还将学习如何利用费雪信息来构建置信区间，从而对你的估计值给出不确定性的量化，这是严谨科学研究所必需的关键技能。",
            "id": "4297496",
            "problem": "一个由二维半导体制成的纳米尺度沟道器件，由于单个主导缺陷随机俘获和发射载流子，其漏极电流表现出随机电报噪声（RTN）。假设这是一个平稳的双态连续时间马尔可夫过程，在高电流状态（缺陷为空）和低电流状态（缺陷被填充）之间具有恒定的转移速率。在此假设下，每个状态的驻留时间是独立同分布的指数随机变量，因为状态切换由一个恒定速率的泊松过程控制。设平均高状态驻留时间为 $\\tau_{c}$（因载流子俘获而结束），平均低状态驻留时间为 $\\tau_{e}$（因载流子发射而结束）。\n\n从室温下的长时间电流迹线中，使用 $\\Delta t = 1\\,\\mu \\mathrm{s}$ 的组距宽度为两种状态构建了驻留时间直方图。生成这些直方图的原始驻留时间样本如下所示。将每个状态内的样本视为独立同分布。\n\n- 高状态驻留时间 (单位 $\\mu \\mathrm{s}$): $\\{12.3,\\,8.7,\\,15.4,\\,9.9,\\,11.1,\\,13.0,\\,7.6,\\,10.5,\\,9.2,\\,14.7\\}$。\n- 低状态驻留时间 (单位 $\\mu \\mathrm{s}$): $\\{5.1,\\,6.3,\\,4.7,\\,5.5,\\,7.2,\\,6.0,\\,5.8,\\,4.9,\\,6.6,\\,5.4\\}$。\n\n从连续时间双态马尔可夫过程的第一性原理出发，并且仅使用关于指数分布和似然的核心定义及经过充分检验的事实：\n\n1. 针对给定的观测驻留时间，推导未知参数 $\\tau_{c}$ 和 $\\tau_{e}$ 的联合似然，并以解析形式求得最大似然估计量 $\\hat{\\tau}_{c}$ 和 $\\hat{\\tau}_{e}$。\n2. 使用所提供的数据对估计量进行数值计算。\n3. 使用 Fisher 信息推导 $\\hat{\\tau}_{c}$ 和 $\\hat{\\tau}_{e}$ 的渐近标准误差，并基于分位数为 $z_{0.975} = 1.96$ 的正态近似，为 $\\tau_{c}$ 和 $\\tau_{e}$ 构建双侧置信度为 0.95 的置信区间。\n\n将最终答案表示为 $[\\hat{\\tau}_{c},\\,\\hat{\\tau}_{e},\\,\\tau_{c} \\text{ 的下界},\\,\\tau_{c} \\text{ 的上界},\\,\\tau_{e} \\text{ 的下界},\\,\\tau_{e} \\text{ 的上界}]$ 顺序的单行矩阵。将答案四舍五入到 3 位有效数字，并以 $\\mu \\mathrm{s}$ 为单位表示所有条目。",
            "solution": "经分析，此问题有效。它在科学上基于随机电报噪声（RTN）的标准模型，作为一个统计估计问题，其提法恰当，并使用客观、正式的语言进行描述。所有必要信息均已提供。\n\n该问题要求计算一个双态马尔可夫过程的平均驻留时间 $\\tau_{c}$ 和 $\\tau_{e}$ 的最大似然估计量 (MLE) 和置信区间。其内在的物理原理决定了每个状态的驻留时间服从指数分布。\n\n**1. 最大似然估计量的推导**\n\n均值参数为 $\\tau > 0$ 的指数分布的概率密度函数 (PDF) 由下式给出：\n$$f(t; \\tau) = \\frac{1}{\\tau} \\exp\\left(-\\frac{t}{\\tau}\\right) \\quad \\text{for } t \\ge 0$$\n该问题提供了两组独立同分布 (i.i.d.) 样本：\n- 高状态驻留时间：$D_c = \\{t_{c,1}, t_{c,2}, ..., t_{c,n_c}\\}$，从均值为 $\\tau_c$ 的指数分布中抽取。此处，$n_c = 10$。\n- 低状态驻留时间：$D_e = \\{t_{e,1}, t_{e,2}, ..., t_{e,n_e}\\}$，从均值为 $\\tau_e$ 的指数分布中抽取。此处，$n_e = 10$。\n\n俘获和发射过程在物理上是不同的，并且在统计上被视为独立的。因此，给定数据时参数 $(\\tau_c, \\tau_e)$ 的联合似然函数 $L(\\tau_c, \\tau_e | D_c, D_e)$ 是每个数据集似然的乘积：\n$$L(\\tau_c, \\tau_e) = L_c(\\tau_c | D_c) \\cdot L_e(\\tau_e | D_e)$$\n其中\n$$L_c(\\tau_c | D_c) = \\prod_{i=1}^{n_c} f(t_{c,i}; \\tau_c) = \\prod_{i=1}^{n_c} \\frac{1}{\\tau_c} \\exp\\left(-\\frac{t_{c,i}}{\\tau_c}\\right) = \\frac{1}{\\tau_c^{n_c}} \\exp\\left(-\\frac{1}{\\tau_c} \\sum_{i=1}^{n_c} t_{c,i}\\right)$$\n$$L_e(\\tau_e | D_e) = \\prod_{j=1}^{n_e} f(t_{e,j}; \\tau_e) = \\prod_{j=1}^{n_e} \\frac{1}{\\tau_e} \\exp\\left(-\\frac{t_{e,j}}{\\tau_e}\\right) = \\frac{1}{\\tau_e^{n_e}} \\exp\\left(-\\frac{1}{\\tau_e} \\sum_{j=1}^{n_e} t_{e,j}\\right)$$\n为了找到最大似然估计量，我们最大化对数似然函数 $\\mathcal{L} = \\ln L$。由于独立性，我们可以分别最大化各个分量。\n$$\\mathcal{L}(\\tau_c, \\tau_e) = \\ln L_c(\\tau_c) + \\ln L_e(\\tau_e) = \\mathcal{L}_c(\\tau_c) + \\mathcal{L}_e(\\tau_e)$$\n高状态数据的对数似然为：\n$$\\mathcal{L}_c(\\tau_c) = -n_c \\ln(\\tau_c) - \\frac{1}{\\tau_c} \\sum_{i=1}^{n_c} t_{c,i}$$\n为了求得估计量 $\\hat{\\tau}_c$，我们计算关于 $\\tau_c$ 的偏导数并令其为零：\n$$\\frac{\\partial \\mathcal{L}_c}{\\partial \\tau_c} = -\\frac{n_c}{\\tau_c} + \\frac{1}{\\tau_c^2} \\sum_{i=1}^{n_c} t_{c,i} = 0$$\n$$\\frac{1}{\\tau_c^2} \\sum_{i=1}^{n_c} t_{c,i} = \\frac{n_c}{\\tau_c}$$\n对于 $\\tau_c \\neq 0$，这简化为：\n$$\\hat{\\tau}_c = \\frac{1}{n_c} \\sum_{i=1}^{n_c} t_{c,i}$$\n指数分布均值的最大似然估计量是样本均值。根据对称性，同样的结果也适用于 $\\tau_e$：\n$$\\hat{\\tau}_e = \\frac{1}{n_e} \\sum_{j=1}^{n_e} t_{e,j}$$\n\n**2. 估计量的数值计算**\n\n使用所提供的数据：\n- 高状态驻留时间 ($t_{c,i}$ 单位 $\\mu \\mathrm{s}$): $\\{12.3,\\,8.7,\\,15.4,\\,9.9,\\,11.1,\\,13.0,\\,7.6,\\,10.5,\\,9.2,\\,14.7\\}$。样本数量为 $n_c=10$。\n$$\\sum_{i=1}^{10} t_{c,i} = 12.3+8.7+15.4+9.9+11.1+13.0+7.6+10.5+9.2+14.7 = 112.4\\,\\mu\\mathrm{s}$$\n$$\\hat{\\tau}_c = \\frac{112.4}{10} = 11.24\\,\\mu\\mathrm{s}$$\n- 低状态驻留时间 ($t_{e,j}$ 单位 $\\mu \\mathrm{s}$): $\\{5.1,\\,6.3,\\,4.7,\\,5.5,\\,7.2,\\,6.0,\\,5.8,\\,4.9,\\,6.6,\\,5.4\\}$。样本数量为 $n_e=10$。\n$$\\sum_{j=1}^{10} t_{e,j} = 5.1+6.3+4.7+5.5+7.2+6.0+5.8+4.9+6.6+5.4 = 57.5\\,\\mu\\mathrm{s}$$\n$$\\hat{\\tau}_e = \\frac{57.5}{10} = 5.75\\,\\mu\\mathrm{s}$$\n\n**3. 渐近标准误差和置信区间**\n\n最大似然估计量的渐近方差由 Fisher 信息的逆给出。对于来自均值为 $\\tau$ 的指数分布的单个观测值 $t$，其对数似然为 $\\ln f(t;\\tau) = -\\ln(\\tau) - t/\\tau$。关于 $\\tau$ 的二阶导数为：\n$$\\frac{\\partial^2}{\\partial \\tau^2} \\ln f(t;\\tau) = \\frac{1}{\\tau^2} - \\frac{2t}{\\tau^3}$$\n单个观测值的 Fisher 信息 $I(\\tau)$ 是该量的负期望：\n$$I(\\tau) = -E\\left[\\frac{\\partial^2}{\\partial \\tau^2} \\ln f(t;\\tau)\\right] = -E\\left[\\frac{1}{\\tau^2} - \\frac{2t}{\\tau^3}\\right] = -\\left(\\frac{1}{\\tau^2} - \\frac{2E[t]}{\\tau^3}\\right)$$\n因为 $E[t] = \\tau$，这简化为：\n$$I(\\tau) = -\\left(\\frac{1}{\\tau^2} - \\frac{2\\tau}{\\tau^3}\\right) = \\frac{1}{\\tau^2}$$\n对于大小为 $n$ 的样本，总 Fisher 信息为 $I_n(\\tau) = n \\cdot I(\\tau) = n/\\tau^2$。最大似然估计量 $\\hat{\\tau}$ 的渐近方差是总 Fisher 信息的逆：\n$$\\text{Var}(\\hat{\\tau}) \\approx [I_n(\\tau)]^{-1} = \\frac{\\tau^2}{n}$$\n渐近标准误差是方差的平方根，$\\text{SE}(\\hat{\\tau}) = \\tau/\\sqrt{n}$。在实践中，我们使用估计的标准误差，即用 $\\hat{\\tau}$ 替换 $\\tau$：\n$$\\widehat{\\text{SE}}(\\hat{\\tau}) = \\frac{\\hat{\\tau}}{\\sqrt{n}}$$\n对于 $\\tau_c$：\n$$\\widehat{\\text{SE}}(\\hat{\\tau}_c) = \\frac{\\hat{\\tau}_c}{\\sqrt{n_c}} = \\frac{11.24}{\\sqrt{10}} \\approx 3.5542\\,\\mu\\mathrm{s}$$\n对于 $\\tau_e$：\n$$\\widehat{\\text{SE}}(\\hat{\\tau}_e) = \\frac{\\hat{\\tau}_e}{\\sqrt{n_e}} = \\frac{5.75}{\\sqrt{10}} \\approx 1.8183\\,\\mu\\mathrm{s}$$\n\n基于正态近似的双侧置信度为 0.95 的置信区间由 $\\hat{\\theta} \\pm z_{1-\\alpha/2} \\widehat{\\text{SE}}(\\hat{\\theta})$ 给出，其中 $1-\\alpha=0.95$，分位数给定为 $z_{0.975} = 1.96$。\n\n$\\tau_c$ 的 0.95 置信区间为：\n$$\\text{CI}_c = \\hat{\\tau}_c \\pm z_{0.975} \\widehat{\\text{SE}}(\\hat{\\tau}_c) = 11.24 \\pm 1.96 \\times 3.5542 \\approx 11.24 \\pm 6.9663$$\n$\\tau_c$ 的下界: $11.24 - 6.9663 = 4.2737\\,\\mu\\mathrm{s}$\n$\\tau_c$ 的上界: $11.24 + 6.9663 = 18.2063\\,\\mu\\mathrm{s}$\n\n$\\tau_e$ 的 0.95 置信区间为：\n$$\\text{CI}_e = \\hat{\\tau}_e \\pm z_{0.975} \\widehat{\\text{SE}}(\\hat{\\tau}_e) = 5.75 \\pm 1.96 \\times 1.8183 \\approx 5.75 \\pm 3.5639$$\n$\\tau_e$ 的下界: $5.75 - 3.5639 = 2.1861\\,\\mu\\mathrm{s}$\n$\\tau_e$ 的上界: $5.75 + 3.5639 = 9.3139\\,\\mu\\mathrm{s}$\n\n将最终结果四舍五入到 3 位有效数字：\n- $\\hat{\\tau}_c = 11.2\\,\\mu\\mathrm{s}$\n- $\\hat{\\tau}_e = 5.75\\,\\mu\\mathrm{s}$\n- $\\tau_c$ 的下界 = $4.27\\,\\mu\\mathrm{s}$\n- $\\tau_c$ 的上界 = $18.2\\,\\mu\\mathrm{s}$\n- $\\tau_e$ 的下界 = $2.19\\,\\mu\\mathrm{s}$\n- $\\tau_e$ 的上界 = $9.31\\,\\mu\\mathrm{s}$\n\n这六个值构成了最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11.2  5.75  4.27  18.2  2.19  9.31\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "真实的纳米电子器件中的噪声行为可能比理想的双态模型更为复杂，例如可能出现多级噪声或信噪比较低的情况。为了应对这些挑战，我们需要更先进的计算工具。隐马尔可夫模型（HMM）为这类复杂随机信号的建模和解码提供了一个强大的统计框架。这项编程练习将指导你实现一个基于HMM的分析流程，用于合成和解码多级RTN信号。通过亲手实现维特比算法（Viterbi algorithm），你将深入理解如何从充满噪声的观测数据中推断出缺陷的“隐藏”状态，这是现代科学研究中一个基础且广泛应用的计算思想。",
            "id": "4297514",
            "problem": "构建一个程序，用于在连续时间物理模型下，使用隐马尔可夫模型 (HMM) 合成和解码多级随机电报噪声，并通过最大后验 (MAP) 准则验证解码的隐藏状态路径与基准真相的一致性。其物理基础是，纳米电子器件中具有离散导电状态的多级随机电报噪声过程可以被建模为一个连续时间马尔可夫链，其跃迁由一个无穷小生成元（速率矩阵）控制。在均匀时间间隔采样的观测值受到加性测量噪声的干扰。解码目标是在给定观测序列和 HMM 参数的情况下，找到最可能的隐藏状态路径。推导和实现必须从基本定义开始：马尔可夫性质、连续时间马尔可夫链及其在采样间隔上的离散时间对应物的结构，以及给定状态下发射的条件独立性。\n\n使用的定义和建模假设：\n- 设隐藏状态过程为一个 $K$ 状态的连续时间马尔可夫链，其速率矩阵为 $\\Lambda \\in \\mathbb{R}^{K \\times K}$，其中当 $i \\ne j$ 时 $\\Lambda_{ij} \\ge 0$，且 $\\Lambda_{ii} = -\\sum_{j \\ne i} \\Lambda_{ij}$。对于小的采样间隔 $d t$，从状态 $i$ 到 $j$ 在 $d t$ 时间内的转移概率由矩阵指数导出，即离散时间转移矩阵为 $P = \\exp(\\Lambda \\, d t)$，该矩阵是行随机的。\n- 设发射模型为加性高斯测量噪声：如果样本索引 $n$ 处的隐藏状态是 $s_n \\in \\{0,1,\\dots,K-1\\}$，观测到的电压为 $y_n = L_{s_n} + \\varepsilon_n$，其中 $L_i$ 是状态 $i$ 的导电水平（单位为伏特），并且 $\\varepsilon_n \\sim \\mathcal{N}(0,\\sigma^2)$ 在 $n$ 上独立。给定状态 $s_n = i$ 时，$y_n$ 的似然 $p(y_n \\mid s_n = i)$ 是均值为 $L_i$、方差为 $\\sigma^2$ 的高斯分布。\n- 设 $s_0$ 的初始分布 $\\pi$ 为离散时间转移矩阵 $P$ 的平稳分布。\n\n您的程序必须：\n1. 对于每个测试用例，通过计算 $P = \\exp(\\Lambda \\, d t)$ 来构建合成的 HMM，计算 $P$ 的平稳分布 $\\pi$，通过初始状态从 $\\pi$ 中抽取且转移由 $P$ 控制的马尔可夫链来模拟一个长度为 $N$ 的隐藏状态轨迹 $\\{s_n\\}_{n=0}^{N-1}$，并使用上述高斯模型生成观测值 $\\{y_n\\}_{n=0}^{N-1}$。\n2. 在所述 HMM 下，为隐藏状态路径推导并实现一个数值稳定的最大后验解码器，使用对数域以避免数值下溢。解码器的结果是在给定观测序列和已知的 HMM 参数 $(\\pi,P,L,\\sigma)$ 的情况下最可能的状态路径 $\\{\\hat{s}_n\\}_{n=0}^{N-1}$。\n3. 对每个测试用例，计算路径准确率，即索引 $n$ 中 $\\hat{s}_n = s_n$ 的比例，表示为区间 $[0,1]$ 内的一个小数。准确率没有物理单位。将每个准确率四舍五入到小数点后六位。\n\n物理和数值单位：\n- 导电水平 $L_i$ 必须以伏特为单位指定和使用。\n- 速率矩阵条目 $\\Lambda_{ij}$ 必须以秒的倒数为单位指定和使用。\n- 采样间隔 $d t$ 必须以秒为单位指定和使用。\n- 噪声标准差 $\\sigma$ 必须以伏特为单位指定和使用。\n- 样本数 $N$ 是一个计数，没有物理单位。\n\n测试套件和参数：\n- 测试用例 1（二元随机电报噪声，低噪声，中等跃迁）：\n  - $K = 2$，\n  - $L = [\\,0\\,\\text{V},\\,20 \\times 10^{-3}\\,\\text{V}\\,]$,\n  - $\\Lambda = \\begin{bmatrix} -1500  1500 \\\\ 2000  -2000 \\end{bmatrix}$，单位为秒的倒数，\n  - $d t = 10^{-5}$ 秒，\n  - $\\sigma = 10^{-3}$ 伏特，\n  - $N = 4000$ 样本，\n  - 随机种子 $= 12345$。\n- 测试用例 2（三级随机电报噪声，中等噪声，非对称跃迁）：\n  - $K = 3$，\n  - $L = [\\,0\\,\\text{V},\\,10 \\times 10^{-3}\\,\\text{V},\\,25 \\times 10^{-3}\\,\\text{V}\\,]$,\n  - 非对角跃迁速率（单位为秒的倒数）：$r_{01} = 600$, $r_{02} = 100$, $r_{10} = 300$, $r_{12} = 400$, $r_{20} = 200$, $r_{21} = 500$；组装 $\\Lambda$ 时，对角线元素为 $\\Lambda_{ii} = -\\sum_{j \\ne i} r_{ij}$，\n  - $d t = 2 \\times 10^{-5}$ 秒，\n  - $\\sigma = 2 \\times 10^{-3}$ 伏特，\n  - $N = 5000$ 样本，\n  - 随机种子 $= 202311$。\n- 测试用例 3（三级随机电报噪声，高噪声，解码具有挑战性）：\n  - $K = 3$，\n  - $L = [\\,0\\,\\text{V},\\,10 \\times 10^{-3}\\,\\text{V},\\,25 \\times 10^{-3}\\,\\text{V}\\,]$,\n  - 使用与测试用例 2 中相同的非对角跃迁速率及相应的 $\\Lambda$，\n  - $d t = 2 \\times 10^{-5}$ 秒，\n  - $\\sigma = 12 \\times 10^{-3}$ 伏特，\n  - $N = 5000$ 样本，\n  - 随机种子 $= 777$。\n- 测试用例 4（四级随机电报噪声，具有罕见的近邻跃迁）：\n  - $K = 4$，\n  - $L = [\\,0\\,\\text{V},\\,5 \\times 10^{-3}\\,\\text{V},\\,10 \\times 10^{-3}\\,\\text{V},\\,15 \\times 10^{-3}\\,\\text{V}\\,]$,\n  - 非对角跃迁速率（单位为秒的倒数）：仅限近邻，其中 $r_{01} = r_{10} = 10$, $r_{12} = r_{21} = 10$, $r_{23} = r_{32} = 10$，所有其他 $r_{ij} = 0$；相应地组装 $\\Lambda$，\n  - $d t = 10^{-3}$ 秒，\n  - $\\sigma = 2 \\times 10^{-3}$ 伏特，\n  - $N = 6000$ 样本，\n  - 随机种子 $= 42$。\n\n答案规格和最终输出格式：\n- 对每个测试用例，计算路径准确率（浮点数）。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，$[a_1,a_2,a_3,a_4]$），其中每个 $a_i$ 都四舍五入到小数点后六位。",
            "solution": "该问题要求合成和解码多级随机电报噪声，这一过程通过连续时间隐马尔可夫模型 (HMM) 进行建模。该任务涉及几个步骤：从物理模型定义 HMM 参数，模拟状态和观测的轨迹，从观测值中解码最可能的状态路径，并评估此解码的准确性。\n\n### 从物理模型进行 HMM 参数化\n\n1.  **连续时间马尔可夫链**：隐藏状态过程是一个具有 $K$ 个状态 $\\{0, 1, \\dots, K-1\\}$ 的连续时间马尔可夫链。其动态由一个无穷小生成元矩阵（或速率矩阵）$\\Lambda \\in \\mathbb{R}^{K \\times K}$ 控制。对于 $i \\neq j$，非对角元素 $\\Lambda_{ij}$ 表示从状态 $i$ 到状态 $j$ 的跃迁速率。这些速率是非负的，即 $\\Lambda_{ij} \\ge 0$。对角元素的定义确保行和为零：$\\Lambda_{ii} = -\\sum_{j \\neq i} \\Lambda_{ij}$。\n\n2.  **离散时间转移矩阵**：观测值以持续时间为 $dt$ 的均匀间隔进行采样。这个离散时间过程的转移概率矩阵 $P \\in \\mathbb{R}^{K \\times K}$ 是通过矩阵指数从连续时间生成元 $\\Lambda$ 导出的：\n    $$ P = \\exp(\\Lambda \\, dt) $$\n    元素 $P_{ij}$ 给出了在时间间隔 $dt$ 内从状态 $i$ 跃迁到状态 $j$ 的概率，即 $P_{ij} = p(s_{n+1}=j \\mid s_n=i)$。矩阵 $P$ 是行随机的，意味着其所有元素都是非负的，并且每行之和为 1。\n\n3.  **初始状态分布**：初始状态 $s_0$ 是从一个概率分布 $\\pi \\in \\mathbb{R}^K$ 中抽取的，其中 $\\pi_i = p(s_0=i)$。问题指定 $\\pi$ 是离散时间马尔可夫链的平稳分布。平稳分布是一个行向量，满足以下特征向量方程：\n    $$ \\pi P = \\pi $$\n    并满足归一化约束 $\\sum_{i=0}^{K-1} \\pi_i = 1$。这等同于找到 $P$ 对应于特征值 $1$ 的左特征向量。\n\n4.  **发射模型**：当系统处于隐藏状态 $s_n=i$ 时，它会产生一个可观测的电压 $y_n$。该观测值受到加性高斯白噪声的干扰。模型为：\n    $$ y_n = L_i + \\varepsilon_n $$\n    其中 $L_i$ 是状态 $i$ 的平均电压水平，$\\varepsilon_n$ 是从均值为零、方差为 $\\sigma^2$ 的正态分布中抽取的噪声项，即 $\\varepsilon_n \\sim \\mathcal{N}(0, \\sigma^2)$。因此，给定状态 $s_n=i$ 时，观测值 $y_n$ 的发射概率密度为：\n    $$ p(y_n \\mid s_n=i) = \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_n - L_i)^2}{2\\sigma^2}\\right) $$\n\n### 合成数据生成\n\n对于每个测试用例，我们按如下方式合成数据集：\n1.  根据给定的速率构建速率矩阵 $\\Lambda$。\n2.  计算离散时间转移矩阵 $P = \\exp(\\Lambda \\, dt)$。\n3.  计算 $P$ 的平稳分布 $\\pi$。\n4.  为保证可复现性，设置随机数生成器种子。\n5.  生成一个长度为 $N$ 的隐藏状态序列 $\\{s_n\\}_{n=0}^{N-1}$：\n    - 从由 $\\pi$ 定义的分类分布中抽取初始状态 $s_0$。\n    - 对于 $n = 1, \\dots, N-1$，从由 $P$ 的第 $s_{n-1}$ 行定义的分类分布中抽取状态 $s_n$。\n6.  生成相应的长度为 $N$ 的观测序列 $\\{y_n\\}_{n=0}^{N-1}$：\n    - 对于每个 $n = 0, \\dots, N-1$，从高斯分布 $\\mathcal{N}(L_{s_n}, \\sigma^2)$ 中抽取观测值 $y_n$。\n\n### 最大后验 (MAP) 路径解码\n\n目标是给定观测序列 $\\{y_n\\}_{n=0}^{N-1}$ 和 HMM 参数 $(\\pi, P, L, \\sigma)$，找到最可能的隐藏状态序列 $\\{\\hat{s}_n\\}_{n=0}^{N-1}$。这被称为 MAP 解码。\n$$ \\{\\hat{s}_n\\} = \\arg\\max_{\\{s_n\\}} p(\\{s_n\\} \\mid \\{y_n\\}) $$\n根据贝叶斯定理，这等价于最大化联合概率 $p(\\{s_n\\}, \\{y_n\\})$。特定路径 $\\{s_n\\}$ 的联合概率由下式给出：\n$$ p(\\{y_n\\}, \\{s_n\\}) = p(s_0) p(y_0|s_0) \\prod_{n=1}^{N-1} p(s_n|s_{n-1}) p(y_n|s_n) = \\pi_{s_0} p(y_0|s_0=s_0) \\prod_{n=1}^{N-1} P_{s_{n-1},s_n} p(y_n|s_n=s_n) $$\n对于长序列，直接计算此乘积容易出现数值下溢。因此，我们在对数域中工作，最大化对数联合概率。这可以通过 Viterbi 算法实现。\n\n### 对数域中的 Viterbi 算法\n\n令 $\\delta_n(i)$ 为在时间 $n$ 结束于状态 $i$，并已生成观测值 $y_0, \\dots, y_n$ 的任何长度为 $n+1$ 的状态路径的最大对数概率。\n\n1.  **初始化 ($n=0$)：**\n    对于每个状态 $i \\in \\{0, \\dots, K-1\\}$：\n    $$ \\delta_0(i) = \\log(\\pi_i) + \\log p(y_0 | s_0=i) $$\n    其中对数发射概率为：\n    $$ \\log p(y_n | s_n=i) = -\\frac{(y_n - L_i)^2}{2\\sigma^2} - \\frac{1}{2}\\log(2\\pi\\sigma^2) $$\n\n2.  **递归 ($n=1, \\dots, N-1$)：**\n    对于每个状态 $j \\in \\{0, \\dots, K-1\\}$：\n    $$ \\delta_n(j) = \\max_{i=0,\\dots,K-1} \\left( \\delta_{n-1}(i) + \\log(P_{ij}) \\right) + \\log p(y_n | s_n=j) $$\n    为了重构路径，我们将回溯指针存储在数组 $\\psi_n(j)$ 中：\n    $$ \\psi_n(j) = \\arg\\max_{i=0,\\dots,K-1} \\left( \\delta_{n-1}(i) + \\log(P_{ij}) \\right) $$\n\n3.  **终止：**\n    最可能路径的对数概率为 $p^* = \\max_{i=0,\\dots,K-1} \\delta_{N-1}(i)$。\n    该路径的最终状态为 $\\hat{s}_{N-1} = \\arg\\max_{i=0,\\dots,K-1} \\delta_{N-1}(i)$。\n\n4.  **路径回溯：**\n    我们通过从最终状态回溯来恢复最可能的路径：\n    对于 $n = N-2, \\dots, 0$：\n    $$ \\hat{s}_n = \\psi_{n+1}(\\hat{s}_{n+1}) $$\n\n### 路径准确率计算\n最后一步是量化解码器的性能。路径准确率通过将解码的状态序列 $\\{\\hat{s}_n\\}$ 与基准真相（合成生成）的状态序列 $\\{s_n\\}$ 进行比较来计算。它是解码状态与真实状态匹配的时间步数的比例：\n$$ \\text{准确率} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\mathbf{1}(\\hat{s}_n = s_n) $$\n其中 $\\mathbf{1}(\\cdot)$ 是指示函数，如果其参数为真则为 $1$，否则为 $0$。结果报告为四舍五入到六位小数的十进制数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm, eig\n\ndef solve():\n    \"\"\"\n    Main function to run the HMM simulation and decoding for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"K\": 2,\n            \"L\": np.array([0.0, 20e-3]),\n            \"Lambda\": np.array([[-1500.0, 1500.0], [2000.0, -2000.0]]),\n            \"dt\": 1e-5,\n            \"sigma\": 1e-3,\n            \"N\": 4000,\n            \"seed\": 12345,\n        },\n        {\n            \"K\": 3,\n            \"L\": np.array([0.0, 10e-3, 25e-3]),\n            \"Lambda\": np.array([[-700.0, 600.0, 100.0], [300.0, -700.0, 400.0], [200.0, 500.0, -700.0]]),\n            \"dt\": 2e-5,\n            \"sigma\": 2e-3,\n            \"N\": 5000,\n            \"seed\": 202311,\n        },\n        {\n            \"K\": 3,\n            \"L\": np.array([0.0, 10e-3, 25e-3]),\n            \"Lambda\": np.array([[-700.0, 600.0, 100.0], [300.0, -700.0, 400.0], [200.0, 500.0, -700.0]]),\n            \"dt\": 2e-5,\n            \"sigma\": 12e-3,\n            \"N\": 5000,\n            \"seed\": 777,\n        },\n        {\n            \"K\": 4,\n            \"L\": np.array([0.0, 5e-3, 10e-3, 15e-3]),\n            \"Lambda\": np.array([[-10.0, 10.0, 0.0, 0.0], [10.0, -20.0, 10.0, 0.0], [0.0, 10.0, -20.0, 10.0], [0.0, 0.0, 10.0, -10.0]]),\n            \"dt\": 1e-3,\n            \"sigma\": 2e-3,\n            \"N\": 6000,\n            \"seed\": 42,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        K, L, Lambda, dt, sigma, N, seed = case.values()\n        rng = np.random.default_rng(seed)\n\n        # 1. Synthesize HMM data\n        s_true, y_obs, pi, P = synthesize_hmm_data(K, L, Lambda, dt, sigma, N, rng)\n\n        # 2. Decode using Viterbi\n        s_decoded = viterbi_decode(K, y_obs, pi, P, L, sigma)\n\n        # 3. Compute accuracy\n        accuracy = np.mean(s_true == s_decoded)\n        results.append(f\"{accuracy:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef get_stationary_distribution(P):\n    \"\"\"\n    Calculates the stationary distribution of a transition matrix P.\n    It is the normalized left eigenvector corresponding to eigenvalue 1.\n    \"\"\"\n    eigenvalues, eigenvectors = eig(P.T)\n    # Find the eigenvector corresponding to the eigenvalue closest to 1\n    idx = np.argmin(np.abs(eigenvalues - 1.0))\n    pi_unnormalized = eigenvectors[:, idx].real\n    pi = pi_unnormalized / np.sum(pi_unnormalized)\n    return pi\n\ndef synthesize_hmm_data(K, L, Lambda, dt, sigma, N, rng):\n    \"\"\"\n    Synthesizes hidden states and observations from an HMM.\n    \"\"\"\n    # Discrete-time transition matrix\n    P = expm(Lambda * dt)\n    \n    # Initial state distribution (stationary)\n    pi = get_stationary_distribution(P)\n\n    # Generate hidden states\n    states = np.zeros(N, dtype=int)\n    states[0] = rng.choice(K, p=pi)\n    for n in range(1, N):\n        states[n] = rng.choice(K, p=P[states[n-1], :])\n\n    # Generate observations\n    observations = rng.normal(loc=L[states], scale=sigma)\n    \n    return states, observations, pi, P\n\ndef viterbi_decode(K, y_obs, pi, P, L, sigma):\n    \"\"\"\n    Finds the most likely sequence of hidden states given observations\n    using the Viterbi algorithm in the log domain.\n    \"\"\"\n    N = len(y_obs)\n    \n    # Pre-compute log probabilities to avoid repeated calculations\n    # Small epsilon to avoid log(0)\n    log_pi = np.log(pi + 1e-300)\n    log_P = np.log(P + 1e-300)\n\n    # Log emission probabilities\n    log_emission_const = -0.5 * np.log(2 * np.pi * sigma**2)\n    def log_emission_prob(y, state_k):\n        return log_emission_const - ((y - L[state_k])**2) / (2 * sigma**2)\n\n    # Viterbi variables\n    delta = np.zeros((N, K))\n    psi = np.zeros((N, K), dtype=int)\n\n    # Initialization (n=0)\n    for i in range(K):\n        delta[0, i] = log_pi[i] + log_emission_prob(y_obs[0], i)\n\n    # Recursion (n=1 to N-1)\n    for n in range(1, N):\n        y_n_log_probs = np.array([log_emission_prob(y_obs[n], j) for j in range(K)])\n        for j in range(K):\n            # The transition part: delta_{n-1}(i) + log(P_ij)\n            trans_probs = delta[n-1, :] + log_P[:, j]\n            # Maximize over previous states i\n            psi[n, j] = np.argmax(trans_probs)\n            delta[n, j] = np.max(trans_probs) + y_n_log_probs[j]\n\n    # Path backtracking\n    decoded_path = np.zeros(N, dtype=int)\n    decoded_path[N-1] = np.argmax(delta[N-1, :])\n    for n in range(N-2, -1, -1):\n        decoded_path[n] = psi[n+1, decoded_path[n+1]]\n\n    return decoded_path\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}