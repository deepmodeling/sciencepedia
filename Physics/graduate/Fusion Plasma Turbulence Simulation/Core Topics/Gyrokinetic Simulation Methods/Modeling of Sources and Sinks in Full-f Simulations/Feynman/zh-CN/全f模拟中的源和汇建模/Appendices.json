{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的数值模拟之前，通过一个简化的、可解析求解的情景来理解其背后的物理原理至关重要。这个练习  探讨了在一个简单的一维输运模型中，恒定粒子源和线性汇之间的稳态平衡。通过求解这个问题，你将为分布函数在源和汇作用下的演化建立清晰的物理直觉。",
            "id": "4196643",
            "problem": "考虑一个用于磁化聚变等离子体全分布函数（full-$f$）动理学模拟的一维板模型，该模型沿着与磁场平行的直角坐标 $x \\in [0,L]$ 展开。全分布函数 $f(x)$ 表示具有固定平行速度 $v0$（单能近似）并沿 $+x$ 方向流动的导心的相空间密度。在稳态下，$f(x)$ 的演化由平行自由流动、空间均匀的粒子源以及一个模拟材料边界损失或有效碰撞吸收的线性汇之间的平衡所决定。从动理学输运-源-汇平衡方程出发\n$$\n\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} = S(x) - \\Sigma(f,x),\n$$\n假设稳态 $\\partial f/\\partial t=0$，一个恒定源 $S(x)=S_0$（其中 $S_0 \\ge 0$），以及一个线性汇 $\\Sigma(f,x) = \\alpha f$（其中 $\\alpha0$，例如，一个Bhatnagar–Gross–Krook (BGK) 类型的向零弛豫）。该区域在 $x=0$ 处有一个适用于向右传播特征线的入流边界条件，\n$$\nf(0) = f_{\\mathrm{in}},\n$$\n其中给定 $f_{\\mathrm{in}} \\ge 0$，并在 $x=L$ 处有一个自由出流（对于 $v0$，在 $x=L$ 处不施加额外的边界约束）。\n\n请从第一性原理出发，使用上述基本动理学平衡和特征线的适当边界布置，推导稳态解析解 $f(x)$。然后验证您的解满足 $x=0$ 处的入流边界条件，并且在物理上是可接受的（对于 $S_0 \\ge 0$，$\\alpha0$，$f_{\\mathrm{in}} \\ge 0$ 是有界且非负的）。请将您的最终答案表示为 $f(x)$ 的单个闭合形式解析表达式。无需四舍五入，最终表达式中不应包含单位。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n### 第1步：提取已知条件\n- **控制方程：** 含时动理学方程为 $\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} = S(x) - \\Sigma(f,x)$。\n- **定义域：** 空间域为一维板， $x \\in [0,L]$。\n- **粒子速度：** 粒子是单能的，具有固定的平行速度 $v  0$，沿 x 正方向流动。\n- **稳态：** 系统处于稳态，因此 $\\frac{\\partial f}{\\partial t} = 0$。\n- **源项：** 粒子源是空间均匀的，$S(x) = S_0$，其中 $S_0 \\ge 0$。\n- **汇项：** 粒子汇是线性的，$\\Sigma(f,x) = \\alpha f$，其中 $\\alpha  0$。\n- **入流边界条件：** 在入流边界 $x=0$ 处的分布函数被指定为 $f(0) = f_{\\mathrm{in}}$，其中 $f_{\\mathrm{in}} \\ge 0$。\n- **出流条件：** 在 $x=L$ 处假设为自由出流条件，对于 $v0$ 的粒子，这意味着在该边界上不施加任何约束。\n\n### 第2步：使用提取的已知条件进行验证\n根据已建立的有效性标准对问题进行评估。\n\n- **科学依据：** 该问题基于一维稳态动理学输运方程。这是输运理论和等离子体物理学中的一个基本方程。源项 ($S_0$) 和汇项 ($\\alpha f$) 是标准的简化模型（例如，一个向零背景弛豫的BGK类型碰撞算子），用于表示粒子源和损失。该模型在物理和数学上是合理的。\n- **适定性：** 在稳态下，控制偏微分方程简化为关于空间坐标 $x$ 的一阶常微分方程。一个一阶常微分方程需要一个边界条件才能得到唯一解。该问题恰好提供了一个边界条件，$f(0) = f_{\\mathrm{in}}$。由于方程 $v \\frac{df}{dx} = \\dots$ 的特征线沿 $x$ 增大的方向传播（因为 $v0$），边界条件必须在入流边界 $x=0$ 处指定。该问题正确地做到了这一点。因此，该问题是适定的。\n- **客观性：** 该问题以精确的数学和物理术语陈述，没有歧义或主观语言。\n\n### 第3步：结论与行动\n该问题具有科学依据、适定且客观。它没有矛盾、信息缺失或其他缺陷。因此，该问题被视为**有效的**。现在开始推导解答。\n\n出发点是给定的动理学方程：\n$$\n\\frac{\\partial f}{\\partial t} + v \\frac{\\partial f}{\\partial x} = S(x) - \\Sigma(f,x)\n$$\n应用稳态条件 $\\frac{\\partial f}{\\partial t} = 0$，并代入源 $S(x) = S_0$ 和汇 $\\Sigma(f,x) = \\alpha f$ 的给定形式，我们得到分布函数 $f(x)$ 的稳态方程：\n$$\nv \\frac{df}{dx} = S_0 - \\alpha f\n$$\n这是一个一阶线性常微分方程。为了求解它，我们将其整理成标准形式 $\\frac{dy}{dx} + P(x)y = Q(x)$:\n$$\nv \\frac{df}{dx} + \\alpha f = S_0\n$$\n两边同除以恒定速度 $v$（因为 $v0$），我们得到：\n$$\n\\frac{df}{dx} + \\frac{\\alpha}{v} f = \\frac{S_0}{v}\n$$\n这个方程可以用积分因子法求解。积分因子 $I(x)$ 由下式给出：\n$$\nI(x) = \\exp\\left(\\int \\frac{\\alpha}{v} dx\\right) = \\exp\\left(\\frac{\\alpha x}{v}\\right)\n$$\n用积分因子 $I(x)$ 乘以该微分方程，得到：\n$$\n\\exp\\left(\\frac{\\alpha x}{v}\\right) \\frac{df}{dx} + \\frac{\\alpha}{v} \\exp\\left(\\frac{\\alpha x}{v}\\right) f = \\frac{S_0}{v} \\exp\\left(\\frac{\\alpha x}{v}\\right)\n$$\n根据乘积法则，左边是乘积 $f(x)I(x)$ 的导数：\n$$\n\\frac{d}{dx}\\left[f(x) \\exp\\left(\\frac{\\alpha x}{v}\\right)\\right] = \\frac{S_0}{v} \\exp\\left(\\frac{\\alpha x}{v}\\right)\n$$\n我们对两边关于 $x$ 积分，以求得通解：\n$$\n\\int \\frac{d}{dx}\\left[f(x) \\exp\\left(\\frac{\\alpha x}{v}\\right)\\right] dx = \\int \\frac{S_0}{v} \\exp\\left(\\frac{\\alpha x}{v}\\right) dx\n$$\n$$\nf(x) \\exp\\left(\\frac{\\alpha x}{v}\\right) = \\frac{S_0}{v} \\left(\\frac{v}{\\alpha}\\right) \\exp\\left(\\frac{\\alpha x}{v}\\right) + C\n$$\n其中 $C$ 是积分常数。简化此表达式得到：\n$$\nf(x) \\exp\\left(\\frac{\\alpha x}{v}\\right) = \\frac{S_0}{\\alpha} \\exp\\left(\\frac{\\alpha x}{v}\\right) + C\n$$\n为了得到 $f(x)$，我们乘以 $\\exp\\left(-\\frac{\\alpha x}{v}\\right)$:\n$$\nf(x) = \\frac{S_0}{\\alpha} + C \\exp\\left(-\\frac{\\alpha x}{v}\\right)\n$$\n这是该常微分方程的通解。常数 $C$ 由入流边界条件 $f(0) = f_{\\mathrm{in}}$ 决定。我们将通解在 $x=0$ 处求值：\n$$\nf(0) = \\frac{S_0}{\\alpha} + C \\exp(0) = \\frac{S_0}{\\alpha} + C\n$$\n将其设为给定的边界值 $f_{\\mathrm{in}}$：\n$$\nf_{\\mathrm{in}} = \\frac{S_0}{\\alpha} + C\n$$\n解出 $C$：\n$$\nC = f_{\\mathrm{in}} - \\frac{S_0}{\\alpha}\n$$\n将 $C$ 的这个表达式代回通解中，得到 $f(x)$ 的唯一的特解：\n$$\nf(x) = \\frac{S_0}{\\alpha} + \\left(f_{\\mathrm{in}} - \\frac{S_0}{\\alpha}\\right) \\exp\\left(-\\frac{\\alpha x}{v}\\right)\n$$\n这就是最终的解析解。\n\n最后，我们验证该解在物理上是否可接受。\n首先，我们检查在 $x=0$ 处的边界条件：\n$$\nf(0) = \\frac{S_0}{\\alpha} + \\left(f_{\\mathrm{in}} - \\frac{S_0}{\\alpha}\\right) \\exp(0) = \\frac{S_0}{\\alpha} + f_{\\mathrm{in}} - \\frac{S_0}{\\alpha} = f_{\\mathrm{in}}\n$$\n入流边界条件得到满足。\n\n其次，我们检查非负性，$f(x) \\ge 0$，对于所有 $x \\in [0, L]$，在约束条件 $S_0 \\ge 0$，$f_{\\mathrm{in}} \\ge 0$，$\\alpha  0$ 和 $v  0$ 下。我们可以将解重写为：\n$$\nf(x) = \\frac{S_0}{\\alpha} \\left(1 - \\exp\\left(-\\frac{\\alpha x}{v}\\right)\\right) + f_{\\mathrm{in}} \\exp\\left(-\\frac{\\alpha x}{v}\\right)\n$$\n对于 $x \\ge 0$，我们有 $\\frac{\\alpha x}{v} \\ge 0$。因此，$0  \\exp\\left(-\\frac{\\alpha x}{v}\\right) \\le 1$。\n因此，项 $\\left(1 - \\exp\\left(-\\frac{\\alpha x}{v}\\right)\\right)$ 的值界于 $0$（在 $x=0$ 处）和 $1$（当 $x \\to \\infty$ 时）之间，所以它总为非负。\n因为 $S_0 \\ge 0$ 且 $\\alpha  0$，第一项 $\\frac{S_0}{\\alpha} \\left(1 - \\exp\\left(-\\frac{\\alpha x}{v}\\right)\\right)$ 是非负的。\n因为 $f_{\\mathrm{in}} \\ge 0$ 且 $\\exp\\left(-\\frac{\\alpha x}{v}\\right)  0$，第二项 $f_{\\mathrm{in}} \\exp\\left(-\\frac{\\alpha x}{v}\\right)$ 也是非负的。\n两个非负项之和为非负，因此对于所有 $x \\ge 0$，$f(x) \\ge 0$。该解在定义域 $[0,L]$ 上是物理上可接受且有界的。\n该解表示一种平衡：分布函数从 $f_{\\mathrm{in}}$ 开始，在长度标度 $v/\\alpha$ 上演化，趋向于一个平衡值 $S_0/\\alpha$，该值能在局部平衡源和汇（$S_0 - \\alpha f = 0$）。",
            "answer": "$$\n\\boxed{\\frac{S_0}{\\alpha} + \\left(f_{\\mathrm{in}} - \\frac{S_0}{\\alpha}\\right) \\exp\\left(-\\frac{\\alpha x}{v}\\right)}\n$$"
        },
        {
            "introduction": "当我们将连续方程离散化为数值更新格式时，必须确保其遵守基本的物理约束，例如，分布函数必须保持非负性。本练习  将直接应对这一挑战，要求你为一个源/汇更新步骤设计并实现一个“保正限制器” (positivity-preserving limiter)。这是现代模拟代码中一项至关重要的技术，它能防止在强源或强汇存在的情况下产生非物理的负粒子数。",
            "id": "4196640",
            "problem": "您正在对聚变等离子体的全分布函数 (full-f) 模拟中由源项和线性汇项引起的单步更新进行建模。考虑单个相空间点，在离散时间索引 $n$ 处其分布函数值为非负 $f^n \\ge 0$。在大小为 $\\Delta t$ 的时间步长内，源项 $S$（可正可负）和系数为 $\\alpha \\ge 0$ 的线性汇项的影响通过显式前向欧拉更新进行建模：\n$$\nf^{n+1} \\;=\\; f^n \\;+\\; \\Delta t\\,\\big(S \\;-\\; \\alpha f^n\\big)\n\\;=\\; \\big(1 - \\alpha \\Delta t\\big)\\,f^n \\;+\\; \\Delta t\\,S.\n$$\n所有量均为无量纲。在算子分裂的背景下，您将实现一个局部的、逐点的保正性限制器，该限制器仅在应用源项之前修改其幅值，从而确保当 $f^n \\ge 0$ 时有 $f^{n+1} \\ge 0$。该限制器必须基于第一性原理进行设计，且不得依赖对 $f^n$ 或 $\\alpha$ 的非物理调整。假设线性汇项的库朗数满足 $0 \\le \\alpha \\Delta t \\le 1$。\n\n您的任务是：\n1) 从第一性原理出发，推导出一个充分条件（表示为对有效源项幅值的界限），以保证在 $f^n \\ge 0$ 和 $0 \\le \\alpha \\Delta t \\le 1$ 的情况下，$f^{n+1} \\ge 0$。您的推导必须从上述显式前向欧拉公式开始，并且除了您设计的限制器外，不得对 $S$ 假设任何未强制执行的约束。解释为什么这个条件在数学上足以确保 $f^{n+1} \\ge 0$。\n2) 设计一个局部限制器，通过仅在更新 $f$ 之前修改源项幅值 $S$ 来强制执行您推导出的条件。该限制器必须是逐点作用的，如果 $S$ 已满足界限则不得增加 $S$，并且必须以满足条件的最小必要改变量来修改 $S$。证明您的限制器对于任何 $f^n \\ge 0$ 和 $0 \\le \\alpha \\Delta t \\le 1$ 都满足第 1 部分的条件。\n3) 实现一个程序，该程序：\n   - 定义一个函数，输入为 $(f^n,\\alpha,\\Delta t,S)$，并使用您的限制器返回更新后的值 $f^{n+1}$。\n   - 将此函数应用于一组测试参数集，并生成一行输出，其中包含得到的 $f^{n+1}$ 值列表，每个值都四舍五入到六位小数。\n\n使用以下测试集，它涵盖了一个代表性的“理想路径”案例、边界案例和重要的边缘案例。所有量均为无量纲且满足 $0 \\le \\alpha \\Delta t \\le 1$：\n- 测试 A: $f^n = 1.0$, $\\alpha = 0.3$, $\\Delta t = 1.0$, $S = -0.5$。\n- 测试 B: $f^n = 0.2$, $\\alpha = 0.2$, $\\Delta t = 1.0$, $S = -0.16$。\n- 测试 C: $f^n = 0.1$, $\\alpha = 0.4$, $\\Delta t = 1.0$, $S = -0.3$。\n- 测试 D: $f^n = 5.0$, $\\alpha = 1.0$, $\\Delta t = 1.0$, $S = -1.0$。\n- 测试 E: $f^n = 0.0$, $\\alpha = 0.6$, $\\Delta t = 1.0$, $S = -10.0$。\n- 测试 F: $f^n = 0.7$, $\\alpha = 0.5$, $\\Delta t = 0.5$, $S = 0.4$。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来的结果（例如，“[x,y,z]”），每个 $f^{n+1}$ 都四舍五入到六位小数。",
            "solution": "该问题要求对分布函数 $f$ 的前向欧拉更新，推导、设计并实现一个保正性限制器。该更新模拟了源项 $S$ 和线性汇项 $\\alpha$ 在时间步长 $\\Delta t$ 内的影响。\n\n更新的控制方程为：\n$$f^{n+1} = f^n + \\Delta t (S - \\alpha f^n) = (1 - \\alpha \\Delta t) f^n + \\Delta t S$$\n给定的条件如下：初始分布函数值为非负，$f^n \\ge 0$；汇项系数为非负，$\\alpha \\ge 0$；线性汇项库朗数满足 $0 \\le \\alpha \\Delta t \\le 1$。任务是通过仅修改源项幅值 $S$ 来确保更新后的值也为非负，$f^{n+1} \\ge 0$。我们将假设时间步长非零，$\\Delta t  0$，因为零时间步长意味着没有演化。\n\n首先，我们推导一个关于 $S$ 的充分条件，以保证 $f^{n+1} \\ge 0$。要求是：\n$$f^{n+1} \\ge 0$$\n代入更新公式，我们得到：\n$$(1 - \\alpha \\Delta t) f^n + \\Delta t S \\ge 0$$\n让我们分析第一项 $(1 - \\alpha \\Delta t) f^n$。问题陈述提供了两个关键约束：$f^n \\ge 0$ 和 $0 \\le \\alpha \\Delta t \\le 1$。第二个约束意味着因子 $(1 - \\alpha \\Delta t)$ 的界限在 $0$ 和 $1$ 之间：\n$$0 \\le \\alpha \\Delta t \\le 1 \\implies -1 \\le -\\alpha \\Delta t \\le 0 \\implies 0 \\le 1 - \\alpha \\Delta t \\le 1$$\n由于 $(1 - \\alpha \\Delta t)$ 和 $f^n$ 都是非负的，它们的乘积也是非负的：\n$$(1 - \\alpha \\Delta t) f^n \\ge 0$$\n为了满足 $f^{n+1}$ 的不等式，我们现在可以为源项 $S$ 建立一个界限。我们整理该不等式：\n$$\\Delta t S \\ge - (1 - \\alpha \\Delta t) f^n$$\n因为我们假设 $\\Delta t  0$，我们可以用 $\\Delta t$ 除以不等式两边而不改变不等号的方向，从而得到关于 $S$ 的充分条件：\n$$S \\ge - \\frac{(1 - \\alpha \\Delta t) f^n}{\\Delta t}$$\n如果源项幅值 $S$ 遵守这个下界，那么 $f^{n+1}$ 就保证是非负的。这可以通过反向追溯此推导的步骤直接得出。\n\n其次，我们设计一个强制执行此条件的限制器。该限制器必须将源项 $S$ 修改为一个新值 $S_{\\text{lim}}$，该值始终满足推导出的界限。我们将允许的最小源项幅值定义为 $S_{\\text{min}}$：\n$$S_{\\text{min}} = - \\frac{(1 - \\alpha \\Delta t) f^n}{\\Delta t}$$\n因此，要求的条件是 $S \\ge S_{\\text{min}}$。如果 $S$ 已经满足此条件，限制器不得改变 $S$；如果不满足，则必须以最小的调整来修改 $S$。实现这一点的唯一数学操作是最大值函数。我们将限制后的源项定义为：\n$$S_{\\text{lim}} = \\max(S, S_{\\text{min}})$$\n该限制器正确地满足了设计要求。如果 $S \\ge S_{\\text{min}}$，则 $S_{\\text{lim}} = S$，源项未被修改。如果 $S  S_{\\text{min}}$，则 $S_{\\text{lim}} = S_{\\text{min}}$，这是为了满足保正条件而对 $S$ 做出的最小可能修改。使用这个限制后的源项，更新方程变为：\n$$f^{n+1} = (1 - \\alpha \\Delta t) f^n + \\Delta t S_{\\text{lim}}$$\n根据我们限制器的定义，对于任何 $S$ 值，我们都有 $S_{\\text{lim}} \\ge S_{\\text{min}}$。将此代入更新公式可保证满足非负性条件，因此 $f^{n+1} \\ge 0$。\n\n第三，我们概述实现的算法。一个函数将以 $(f^n, \\alpha, \\Delta t, S)$ 作为输入。假设 $\\Delta t  0$，该函数将：\n1. 计算最小源项值，$S_{\\text{min}} = - \\frac{(1 - \\alpha \\Delta t) f^n}{\\Delta t}$。\n2. 计算限制后的源项，$S_{\\text{lim}} = \\max(S, S_{\\text{min}})$。\n3. 计算新的分布函数值，$f^{n+1} = (1 - \\alpha \\Delta t)f^n + \\Delta t S_{\\text{lim}}$。\n4. 返回 $f^{n+1}$。\n此过程将应用于提供的每个测试案例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of applying a positivity-preserving limiter to a\n    forward-Euler update of a distribution function.\n    \"\"\"\n    # Test cases from the problem statement.\n    # Each tuple is (f^n, alpha, Delta_t, S)\n    test_cases = [\n        (1.0, 0.3, 1.0, -0.5),   # Test A\n        (0.2, 0.2, 1.0, -0.16),  # Test B\n        (0.1, 0.4, 1.0, -0.3),   # Test C\n        (5.0, 1.0, 1.0, -1.0),   # Test D\n        (0.0, 0.6, 1.0, -10.0),  # Test E\n        (0.7, 0.5, 0.5, 0.4),    # Test F\n    ]\n\n    def update_with_limiter(f_n: float, alpha: float, dt: float, S: float) - float:\n        \"\"\"\n        Calculates the updated distribution function f^{n+1} using the\n        derived positivity-preserving limiter for the source term.\n        \n        Args:\n            f_n: Distribution function value at time n.\n            alpha: Linear sink coefficient.\n            dt: Time step size.\n            S: Source amplitude.\n            \n        Returns:\n            The updated distribution value f^{n+1}, guaranteed to be non-negative.\n        \"\"\"\n        if dt == 0.0:\n            # If time step is zero, no change occurs.\n            return f_n\n\n        alpha_dt = alpha * dt\n        \n        # Calculate the minimum allowed source term to ensure positivity.\n        # S_min = - (1 - alpha*dt) * f_n / dt\n        s_min = - (1.0 - alpha_dt) * f_n / dt\n        \n        # Apply the limiter: take the maximum of the original source and the minimum allowed value.\n        s_lim = np.maximum(S, s_min)\n        \n        # Calculate f^{n+1} using the limited source term.\n        # f^{n+1} = (1 - alpha*dt) * f_n + dt * S_lim\n        f_next = (1.0 - alpha_dt) * f_n + dt * s_lim\n        \n        return f_next\n\n    results = []\n    for case in test_cases:\n        f_n, alpha, dt, S = case\n        f_next = update_with_limiter(f_n, alpha, dt, S)\n        results.append(f_next)\n\n    # Format the results to six decimal places as specified.\n    formatted_results = [f'{r:.6f}' for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}