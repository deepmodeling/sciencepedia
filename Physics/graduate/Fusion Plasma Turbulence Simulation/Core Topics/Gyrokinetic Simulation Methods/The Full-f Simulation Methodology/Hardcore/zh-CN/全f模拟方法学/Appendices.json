{
    "hands_on_practices": [
        {
            "introduction": "开发任何模拟代码，关键的第一步是验证其实现的正确性。收敛性研究通过确认数值误差是否随着分辨率的提高而以理论预期的速率减小，从而定量地证实这一点。本练习 () 将指导您如何为一个Vlasov-Poisson求解器建立并解释一个收敛性测试，它使用一个基于朗道阻尼物理的合成误差模型，使数值精度的概念变得具体可衡量。",
            "id": "4203269",
            "problem": "本题要求您从第一性原理出发，在用于聚变等离子体湍流模拟的全分布函数 (full-f) 模拟方法的背景下，分析应用于朗道阻尼测试的离散化方案的收敛行为。考虑无量纲单位下，对于具有固定离子的电子等离子体的一维空间、一维速度（简写为 $1\\mathrm{D-1V}$）Vlasov–Poisson 动力学。控制电子分布函数 $f(x,v,t)$ 和电场 $E(x,t)$ 的方程为\n$$\\partial_t f + v \\,\\partial_x f + \\frac{q}{m}\\, E \\, \\partial_v f = 0,$$\n以及归一化形式的泊松方程\n$$\\partial_x E = \\int_{-\\infty}^{\\infty} f \\, dv - n_0,$$\n其中 $q/m$ 是荷质比，$n_0$ 是背景密度。假设采用等离子体物理学中常用的无量纲归一化，使得平衡麦克斯韦分布为 $f_0(v) = \\frac{1}{\\sqrt{\\pi}} e^{-v^2}$，德拜长度为1，电子等离子体频率为1。对于平衡态的一个波数为 $k$ 的小正弦微扰，线性化动力学表现出电场的朗道阻尼。朗缪尔波的复频率 $\\omega = \\omega_r + i \\omega_i$ 满足介电函数条件\n$$\\varepsilon(\\omega,k) = 1 + \\frac{1}{k^2}\\left(1 + \\zeta \\, Z(\\zeta)\\right) = 0,$$\n其中 $\\zeta = \\omega/k$，$Z(\\zeta)$ 是等离子体色散函数，定义为\n$$Z(\\zeta) = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} \\frac{e^{-u^2}}{u - \\zeta} \\, du,$$\n该积分使用朗道围线规定进行解释。对于足够小振幅的微扰，电场振幅近似按 $A(t) \\approx A_0 \\, e^{\\omega_i t}$ 衰减，其中 $\\omega_i < 0$。本问题中所有量均为无量纲。\n\n一个全分布函数 (full-f) 欧拉型程序通过对空间平流、速度平流和时间步进使用数值近似来离散化 Vlasov–Poisson 系统。考虑一个由三个局部截断误差阶表征的离散化方案：空间平流误差阶 $p_s$、速度平流误差阶 $p_v$ 和时间积分器误差阶 $q$。假设网格加密是协同进行的，空间网格间距 $\\Delta x$、速度网格间距 $\\Delta v$ 和时间步长 $\\Delta t$ 通过以下关系与单个加密参数 $h$ 相关联：\n$$\\Delta x = c_x h, \\quad \\Delta v = c_v h^{\\alpha}, \\quad \\Delta t = c_t h^{\\beta},$$\n其中 $c_x$、$c_v$、$c_t$ 为正常数，$\\alpha$ 和 $\\beta$ 为加密指数。在渐进行为区，像固定时间 $T$ 的电场振幅这样的可观测量中的主导误差可以建模为各项贡献之和，其标度关系如下：\n$$\\mathcal{E}(h) \\approx C_s \\, (\\Delta x)^{p_s} + C_v \\, (\\Delta v)^{p_v} + C_t \\, (\\Delta t)^{q} + \\mathcal{E}_{\\mathrm{floor}},$$\n其中 $C_s$、$C_v$、$C_t$ 为正系数，$\\mathcal{E}_{\\mathrm{floor}}$ 为可能的误差平台，表示渐进饱和，例如由舍入误差或未解析的物理过程引起。在此模型和协同加密下，只要 $\\mathcal{E}_{\\mathrm{floor}} = 0$ 且达到了渐进行为区，可观测量的预期总体精度阶表现为 $p_{\\mathrm{exp}} = \\min\\{p_s, \\alpha p_v, \\beta q\\}$。\n\n您的任务：\n\n- 基于上述基本原理，计算每个测试用例的期望阶 $p_{\\mathrm{exp}}$，基于给定的 $(p_s, p_v, q, \\alpha, \\beta)$。\n- 对每个测试用例，通过生成与全分布函数 (full-f) 方法和朗道阻尼测试一致的合成误差 $\\mathcal{E}(h)$，来模拟“测量的”收敛性。\n- 仅使用由色散关系决定的朗道阻尼频率解析解来为设置提供基准；您无需积分完整的 Vlasov–Poisson 系统，但必须生成与截断误差阶一致的误差。\n- 通过对所提供的加密级别上的 $\\log \\mathcal{E}(h)$ 与 $\\log h$ 进行最小二乘拟合，估计测量阶 $p_{\\mathrm{meas}}$。\n- 将 $p_{\\mathrm{meas}}$ 与 $p_{\\mathrm{exp}}$ 在容差 $\\tau$ 内进行比较，并生成一个布尔值，指示是否满足 $|p_{\\mathrm{meas}} - p_{\\mathrm{exp}}| \\le \\tau$。\n\n使用以下测试套件，其中 $k = 0.5$，$A_0 = 1$，$T = 10$，均为无量纲。空间域长度为 $L = 2\\pi/k$。对于每个测试用例，空间分辨率由单元数列表 $N_x \\in \\{32, 64, 128, 256\\}$ 给出，因此 $h = \\Delta x = L/N_x$。使用 $\\Delta v = c_v h^{\\alpha}$ 和 $\\Delta t = c_t h^{\\beta}$，以及指定的 $(\\alpha,\\beta)$、常数 $(c_x, c_v, c_t)$，并使用指定的系数 $(C_s, C_v, C_t)$ 和误差平台 $\\mathcal{E}_{\\mathrm{floor}}$ 生成合成误差。\n\n测试用例：\n\n- 用例 1：$(p_s, p_v, q) = (5, 3, 2)$，$(\\alpha, \\beta) = (1, 1)$，$(c_x, c_v, c_t) = (1, 1, 0.5)$，$(C_s, C_v, C_t) = (1.0, 0.2, 0.5)$，$\\mathcal{E}_{\\mathrm{floor}} = 0$。期望 $p_{\\mathrm{exp}} = \\min\\{5, 3, 2\\} = 2$。\n- 用例 2：$(p_s, p_v, q) = (3, 4, 2)$，$(\\alpha, \\beta) = (1, 2)$，$(c_x, c_v, c_t) = (1, 1, 0.2)$，$(C_s, C_v, C_t) = (0.9, 0.4, 0.5)$，$\\mathcal{E}_{\\mathrm{floor}} = 0$。期望 $p_{\\mathrm{exp}} = \\min\\{3, 4, 4\\} = 3$。\n- 用例 3：$(p_s, p_v, q) = (4, 2, 3)$，$(\\alpha, \\beta) = (1, 1)$，$(c_x, c_v, c_t) = (1, 1, 0.3)$，$(C_s, C_v, C_t) = (0.3, 1.0, 0.2)$，$\\mathcal{E}_{\\mathrm{floor}} = 0$。期望 $p_{\\mathrm{exp}} = \\min\\{4, 2, 3\\} = 2$。\n- 用例 4：$(p_s, p_v, q) = (4, 4, 4)$，$(\\alpha, \\beta) = (1, 1)$，$(c_x, c_v, c_t) = (1, 1, 0.3)$，$(C_s, C_v, C_t) = (1.0, 1.0, 1.0)$，$\\mathcal{E}_{\\mathrm{floor}} = 10^{-5}$。期望 $p_{\\mathrm{exp}} = \\min\\{4, 4, 4\\} = 4$，但误差平台可能会在精细级别上破坏渐进斜率。\n\n取容差 $\\tau = 0.2$。您的程序必须执行以下步骤：\n- 通过求解 $\\varepsilon(\\omega,k)=0$ 来计算复频率 $\\omega$，使用等离子体色散函数来确定 $\\omega_i$，并用它来锚定时间尺度，尽管合成误差模型是 $\\mathcal{E}(h)$ 的主要来源。\n- 对于每个用例，计算 $p_{\\mathrm{exp}}$，为列表中的每个 $N_x$ 生成 $\\mathcal{E}(h)$，拟合 $p_{\\mathrm{meas}}$，并使用容差计算布尔比较结果。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[b_1,b_2,b_3,b_4]$，其中每个 $b_i$ 是对应于用例 $i$ 比较结果的布尔值。\n\n所有计算和输出都是无量纲数，没有物理单位，并且本问题不涉及角度。请使用编程语言的规范布尔表示法来表示布尔值。",
            "solution": "该问题要求分析用于 $1\\mathrm{D-1V}$ Vlasov–Poisson 系统的数值格式的收敛行为，这是等离子体物理学中的一个基本模型。该分析基于一个合成误差模型。一个有效的解法需要：1) 问题的理论框架，2) 生成合成数据的方法，3) 测量收敛性的程序，以及 4) 与理论期望的比较。\n\n该物理系统由描述电子分布函数 $f(x,v,t)$ 的 Vlasov 方程和描述电场 $E(x,t)$ 的泊松方程所描述：\n$$\n\\partial_t f + v \\,\\partial_x f + \\frac{q}{m}\\, E \\, \\partial_v f = 0\n$$\n$$\n\\partial_x E = \\int_{-\\infty}^{\\infty} f \\, dv - n_0\n$$\n在给定的无量纲单位中，荷质比为 $q/m$，背景密度为 $n_0$，平衡麦克斯韦分布为 $f_0(v) = \\frac{1}{\\sqrt{\\pi}} e^{-v^2}$，德拜长度和等离子体频率均为单位1，研究了小微扰的动力学。具体来说，该问题考虑了一个波数为 $k$ 的朗缪尔波，其振幅会受到朗道阻尼的影响。波的复频率 $\\omega = \\omega_r + i\\omega_i$ 是介电函数 $\\varepsilon(\\omega, k)$ 的一个根：\n$$\n\\varepsilon(\\omega,k) = 1 + \\frac{1}{k^2}\\left(1 + \\zeta \\, Z(\\zeta)\\right) = 0\n$$\n其中 $\\zeta = \\omega/k$ 是归一化相速度，$Z(\\zeta)$ 是等离子体色散函数：\n$$\nZ(\\zeta) = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} \\frac{e^{-u^2}}{u - \\zeta} \\, du\n$$\n频率的虚部 $\\omega_i$ 给出了电场振幅的阻尼率，$A(t) \\approx A_0 e^{\\omega_i t}$。尽管这个物理背景为问题提供了基础，但核心任务是一个数值分析练习。对于给定的波数 $k=0.5$，复频率 $\\omega$ 将通过数值求解色散关系来找到，这主要是为了展示对底层物理的理解。\n\n收敛性分析依赖于一个关于在固定时间 $T$ 的可观测量中的总数值误差 $\\mathcal{E}$ 的模型。误差来源于相空间和时间的离散化。设空间平流、速度平流和时间积分格式的局部截断误差阶分别为 $p_s$、$p_v$ 和 $q$。采用协同网格加密策略，其中空间网格间距 $\\Delta x$、速度网格间距 $\\Delta v$ 和时间步长 $\\Delta t$ 都与单个加密参数 $h$ 相关：\n$$\n\\Delta x = c_x h, \\quad \\Delta v = c_v h^{\\alpha}, \\quad \\Delta t = c_t h^{\\beta}\n$$\n其中 $c_x, c_v, c_t$ 为给定常数，$\\alpha, \\beta$ 为指数。问题定义 $h = \\Delta x = L/N_x$，其中 $L=2\\pi/k$ 是域长度，$N_x$ 是空间网格点数。这意味着 $c_x=1$。总误差 $\\mathcal{E}(h)$ 被建模为各误差源贡献之和：\n$$\n\\mathcal{E}(h) \\approx C_s (\\Delta x)^{p_s} + C_v (\\Delta v)^{p_v} + C_t (\\Delta t)^{q} + \\mathcal{E}_{\\mathrm{floor}}\n$$\n代入标度关系，误差模型变为：\n$$\n\\mathcal{E}(h) \\approx (C_s c_x^{p_s}) h^{p_s} + (C_v c_v^{p_v}) h^{\\alpha p_v} + (C_t c_t^{q}) h^{\\beta q} + \\mathcal{E}_{\\mathrm{floor}}\n$$\n在 $h \\to 0$ 且误差平台 $\\mathcal{E}_{\\mathrm{floor}} = 0$ 的渐进极限下，h 的最低次幂项占主导地位。因此，总体收敛率，即期望精度阶 $p_{\\mathrm{exp}}$，是这些指数中的最小值：\n$$\np_{\\mathrm{exp}} = \\min\\{p_s, \\alpha p_v, \\beta q\\}\n$$\n\n对每个测试用例要实施的步骤如下：\n$1$. 使用提供的公式和参数 $(p_s, p_v, q, \\alpha, \\beta)$ 计算理论期望精度阶 $p_{\\mathrm{exp}}$。\n\n$2$. 生成合成误差数据。对于给定的空间分辨率列表 $N_x \\in \\{32, 64, 128, 256\\}$，我们首先计算加密参数 $h$。当 $k=0.5$ 时，域长度为 $L = 2\\pi/0.5 = 4\\pi$。每个分辨率的加密参数为 $h_i = L / (N_x)_i$。\n然后，对于每个 $h_i$，我们计算相应的步长 $\\Delta x_i = c_x h_i$，$\\Delta v_i = c_v h_i^{\\alpha}$ 和 $\\Delta t_i = c_t h_i^{\\beta}$。最后，我们使用指定的系数 $(C_s, C_v, C_t)$ 和误差平台 $\\mathcal{E}_{\\mathrm{floor}}$，通过误差模型公式计算每个分辨率的合成误差 $\\mathcal{E}(h_i)$。\n\n$3$. 估计测量的收敛阶 $p_{\\mathrm{meas}}$。如果误差行为近似为 $\\mathcal{E}(h) \\approx C h^p$（其中 $C$ 为某个有效常数），那么取对数可得 $\\log(\\mathcal{E}) \\approx \\log(C) + p \\log(h)$。这是 $\\log(\\mathcal{E})$ 和 $\\log(h)$ 之间的线性关系，其斜率即为收敛阶 $p$。我们对数据点 $(\\log(h_i), \\log(\\mathcal{E}(h_i)))$ 进行线性最小二乘拟合。所得直线的斜率就是我们测量的阶数 $p_{\\mathrm{meas}}$。\n\n$4$. 比较测量阶和期望阶。我们计算绝对差 $|p_{\\mathrm{meas}} - p_{\\mathrm{exp}}|$，并检查它是否在给定的容差 $\\tau=0.2$ 之内。结果是一个布尔值，指示测量的收敛性是否与理论预期相符。\n\n对于起始的基于物理的部分，求解 $\\varepsilon(\\omega, k)=0$ 需要一个数值求根器和一个等离子体色散函数 $Z(\\zeta)$ 的实现。函数 $Z(\\zeta)$ 与 Faddeeva 函数 $w(z) = e^{-z^2}\\text{erfc}(-iz)$ 相关，后者在标准科学计算库中可用。它们的关系是 $Z(\\zeta) = i\\sqrt{\\pi} w(\\zeta)$，通过解析延拓，此关系对复数 $\\zeta$ 成立。将对 $\\zeta = \\omega/k$ 进行求根，以求解 $k^2 + 1 + \\zeta Z(\\zeta) = 0$。\n\n最终输出将是一个布尔值列表，每个测试用例对应一个布尔值，表示比较 $|p_{\\mathrm{meas}} - p_{\\mathrm{exp}}| \\le \\tau$ 的结果。对于用例 4，存在非零误差平台 $\\mathcal{E}_{\\mathrm{floor}} = 10^{-5}$，预计会破坏收敛率的测量，因为对于足够小的 $h$，误差将在 $\\mathcal{E}_{\\mathrm{floor}}$ 处饱和，导致 $p_{\\mathrm{meas}}$ 偏离 $p_{\\mathrm{exp}}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import wofz\nfrom scipy.optimize import root\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as described.\n    It computes the complex frequency for Landau damping as a preliminary step,\n    then iterates through test cases to compare expected and measured convergence orders.\n    \"\"\"\n    \n    # ----------------------------------------------------------------------\n    # Problem-wide constants and setup\n    # ----------------------------------------------------------------------\n    k = 0.5  # Wavenumber\n    tau = 0.2  # Tolerance for comparison\n    Nx_list = np.array([32, 64, 128, 256]) # Spatial resolutions\n    \n    # ----------------------------------------------------------------------\n    # Step 1: Solve the dispersion relation (anchors the physical setup)\n    # ----------------------------------------------------------------------\n    \n    def plasma_dispersion_func_Z(zeta):\n        \"\"\"Computes the plasma dispersion function Z(zeta).\"\"\"\n        # Z(zeta) = i * sqrt(pi) * w(zeta), where w is the Faddeeva function\n        return 1j * np.sqrt(np.pi) * wofz(zeta)\n\n    def dielectric_func_root(zeta_vec, k_val):\n        \"\"\"\n        Function to find the root of the dielectric relation.\n        zeta_vec is a real vector [Re(zeta), Im(zeta)].\n        \"\"\"\n        zeta = zeta_vec[0] + 1j * zeta_vec[1]\n        # The equation to solve is k^2 + 1 + zeta * Z(zeta) = 0\n        val = k_val**2 + 1 + zeta * plasma_dispersion_func_Z(zeta)\n        return [val.real, val.imag]\n\n    # Initial guess for zeta = omega/k. For omega ~ 1.4 - 0.15j and k=0.5, zeta ~ 2.8 - 0.3j\n    zeta_initial_guess = np.array([2.8, -0.3])\n    solution = root(dielectric_func_root, zeta_initial_guess, args=(k,))\n    zeta_sol = solution.x[0] + 1j * solution.x[1]\n    omega_sol = zeta_sol * k\n    # This omega_sol value is not used further, as per problem instructions.\n    # It serves to demonstrate understanding of the underlying physics.\n    \n    # ----------------------------------------------------------------------\n    # Define test cases\n    # ----------------------------------------------------------------------\n    test_cases = [\n        {'id': 1, 'p_s': 5, 'p_v': 3, 'q': 2, 'alpha': 1, 'beta': 1, \n         'c_x': 1, 'c_v': 1, 'c_t': 0.5, 'C_s': 1.0, 'C_v': 0.2, 'C_t': 0.5, \n         'E_floor': 0.0},\n        {'id': 2, 'p_s': 3, 'p_v': 4, 'q': 2, 'alpha': 1, 'beta': 2, \n         'c_x': 1, 'c_v': 1, 'c_t': 0.2, 'C_s': 0.9, 'C_v': 0.4, 'C_t': 0.5, \n         'E_floor': 0.0},\n        {'id': 3, 'p_s': 4, 'p_v': 2, 'q': 3, 'alpha': 1, 'beta': 1, \n         'c_x': 1, 'c_v': 1, 'c_t': 0.3, 'C_s': 0.3, 'C_v': 1.0, 'C_t': 0.2, \n         'E_floor': 0.0},\n        {'id': 4, 'p_s': 4, 'p_v': 4, 'q': 4, 'alpha': 1, 'beta': 1, \n         'c_x': 1, 'c_v': 1, 'c_t': 0.3, 'C_s': 1.0, 'C_v': 1.0, 'C_t': 1.0, \n         'E_floor': 1e-5}\n    ]\n\n    results = []\n\n    # ----------------------------------------------------------------------\n    # Step 2-4: Process each test case\n    # ----------------------------------------------------------------------\n    for case in test_cases:\n        p_s, p_v, q = case['p_s'], case['p_v'], case['q']\n        alpha, beta = case['alpha'], case['beta']\n        c_x, c_v, c_t = case['c_x'], case['c_v'], case['c_t']\n        C_s, C_v, C_t = case['C_s'], case['C_v'], case['C_t']\n        E_floor = case['E_floor']\n\n        # Compute expected convergence order\n        p_exp = min(p_s, alpha * p_v, beta * q)\n\n        # Generate synthetic error data\n        L = 2 * np.pi / k\n        h = L / Nx_list\n        \n        dx = c_x * h\n        dv = c_v * h**alpha\n        dt = c_t * h**beta\n\n        error = C_s * (dx**p_s) + C_v * (dv**p_v) + C_t * (dt**q) + E_floor\n\n        # Estimate measured convergence order\n        # We fit log(error) vs log(h) to a line. The slope is the order.\n        log_h = np.log(h)\n        log_error = np.log(error)\n        \n        # polyfit returns [slope, intercept] for degree 1\n        p_meas, _ = np.polyfit(log_h, log_error, 1)\n        \n        # Compare measured and expected orders\n        is_convergent_as_expected = np.abs(p_meas - p_exp) = tau\n        results.append(is_convergent_as_expected)\n\n    # Final print statement in the exact required format.\n    # str(bool) in Python gives 'True' or 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "全f模拟演化的是整个分布函数，这给精确维持密度和温度等宏观量的正确演化带来了挑战，这是其与δf方法的一个关键区别。本练习 () 提供了一种直接的方法来检测这些矩的非物理漂移，通过将一个包含源和汇的模型的数值解与其精确的解析解进行比较，这是任何全f代码都必须进行的关键验证步骤。",
            "id": "4203284",
            "problem": "您的任务是为聚变等离子体湍流模拟中的简化全分布函数方法设计并实现一个数值测试，该测试能够检测总密度或温度的不当漂移，而这种漂移在微扰分布函数公式中是不可见的。这必须使用物理上一致的模型和量化的诊断方法来完成。该测试将离散速度分布的数值计算矩与在规定的源和汇下解析矩的演化进行比较。\n\n考虑一个单粒子种类、各向同性、零整体流的等离子体，其粒子质量为 $m$，且没有空间依赖性。速度为 $v$ 的全分布函数 $f(v,t)$ 在一个线性源汇模型下演化，\n$$\n\\frac{\\partial f}{\\partial t} = \\nu_s \\left(f_S - f\\right) - \\nu_\\ell f,\n$$\n其中 $\\nu_s$ 是源率，$\\nu_\\ell$ 是损失率，$f_S(v)$ 是一个静态源分布。初始条件是密度为 $n_0$、温度为 $T_0$ 的麦克斯韦分布 $f(v,0)=f_M(v;n_0,T_0)$。源分布也是一个密度为 $n_S$、温度为 $T_S$ 的麦克斯韦分布 $f_S(v)=f_M(v;n_S,T_S)$。零整体流的各向同性三维麦克斯韦分布函数为\n$$\nf_M(v;n,T) = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{m v^2}{2 k_B T}\\right),\n$$\n其中 $k_B$ 是玻尔兹曼常数。温度以电子伏特 (eV) 为单位提供，并且必须通过 $k_B T = e \\, T_{\\mathrm{eV}}$ 转换为能量，其中 $e$ 是基本电荷。$f$ 的密度矩和能量矩计算如下\n$$\nn(t) = \\int_0^{\\infty} 4\\pi v^2 f(v,t)\\,dv, \\quad E(t) = \\int_0^{\\infty} \\frac{1}{2} m v^2 \\, 4\\pi v^2 f(v,t)\\,dv.\n$$\n相应的温度由理想气体关系 $E(t) = \\frac{3}{2} n(t) k_B T(t)$ 定义。\n\n对于上述源汇模型，矩的精确演化为\n$$\n\\mu = \\nu_s + \\nu_\\ell, \\quad n_{\\mathrm{exact}}(t) = e^{-\\mu t} n_0 + \\frac{\\nu_s}{\\mu} \\left(1 - e^{-\\mu t}\\right) n_S,\n$$\n$$\nE_{\\mathrm{exact}}(t) = e^{-\\mu t} E_0 + \\frac{\\nu_s}{\\mu} \\left(1 - e^{-\\mu t}\\right) E_S, \\quad E_0 = \\frac{3}{2} n_0 e T_0, \\quad E_S = \\frac{3}{2} n_S e T_S,\n$$\n并且\n$$\nT_{\\mathrm{exact}}(t) = \\frac{E_{\\mathrm{exact}}(t)}{\\frac{3}{2} n_{\\mathrm{exact}}(t) k_B}.\n$$\n\n您的程序必须在有限速度域 $v \\in [0, v_{\\max}]$ 上使用 $N_v$ 个点对 $f(v,t)$ 进行数值离散化，并使用时间步长 $\\Delta t$ 和显式欧拉更新方法随时间演化，\n$$\nf^{n+1}(v) = f^{n}(v) + \\Delta t \\left[ \\nu_s \\left(f_S(v) - f^{n}(v)\\right) - \\nu_\\ell f^{n}(v)\\right],\n$$\n从 $f^0(v)=f_M(v;n_0,T_0)$ 开始，并使用 $f_S(v)=f_M(v;n_S,T_S)$。在每个时间步 $t_n = n \\Delta t$，从对 $v\\in[0,v_{\\max}]$ 的离散积分中计算 $n_{\\mathrm{num}}(t_n)$ 和 $E_{\\mathrm{num}}(t_n)$，并从 $E_{\\mathrm{num}}(t_n)=\\frac{3}{2} n_{\\mathrm{num}}(t_n) k_B T_{\\mathrm{num}}(t_n)$ 获得 $T_{\\mathrm{num}}(t_n)$。数值积分必须使用因子 $4\\pi v^2$ 来近似上述连续积分。数值单位为：$m$ 单位是千克， $n_0$ 和 $n_S$ 单位是 $\\mathrm{m}^{-3}$， $T_0$ 和 $T_S$ 单位是电子伏特 (eV)， $\\nu_s$ 和 $\\nu_\\ell$ 单位是 $\\mathrm{s}^{-1}$， $t$ 单位是秒，$v$ 单位是米/秒。所有计算出的温度必须内部以电子伏特 (eV) 报告，并与 $k_B T = e T_{\\mathrm{eV}}$ 一致，但下面指定的最终输出是无量纲的漂移度量。\n\n为检测总密度或温度的不当漂移，定义在模拟时域 $t \\in [0, t_{\\mathrm{end}}]$ 上的最大相对漂移度量，\n$$\nD_n = \\max_{0 \\le n \\le N_t} \\left| \\frac{n_{\\mathrm{num}}(t_n) - n_{\\mathrm{exact}}(t_n)}{n_{\\mathrm{exact}}(t_n)} \\right|, \\quad\nD_T = \\max_{0 \\le n \\le N_t} \\left| \\frac{T_{\\mathrm{num}}(t_n) - T_{\\mathrm{exact}}(t_n)}{T_{\\mathrm{exact}}(t_n)} \\right|,\n$$\n其中 $N_t = t_{\\mathrm{end}}/\\Delta t$ 是时间步数。每个测试案例的单一标量诊断是\n$$\nD = \\max\\left(D_n, D_T\\right).\n$$\n$D$ 的较大值表示总矩的漂移，这种漂移是微扰分布公式无法揭示的，特别是当速度空间域截断或粗分辨率导致不正确的矩捕获时。\n\n请为以下测试套件实现计算，该套件涵盖了一个精细解析的案例、无源衰减、带截断域的热源以及粗网格分辨率。在每种情况下，根据与相关温度相关的热速度 $v_{\\mathrm{th}}(T)=\\sqrt{2 e T/m}$ 选择 $v_{\\max}$，并将速度网格设置为在 $[0,v_{\\max}]$ 上的 $N_v$ 个均匀间隔点。\n\n- 案例1（精细解析，源-损失平衡）：\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$，$n_0 = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$，$T_0 = 100\\ \\mathrm{eV}$，\n  - $n_S = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$，$T_S = 100\\ \\mathrm{eV}$，\n  - $\\nu_s = 1.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$，$\\nu_\\ell = 1.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$，\n  - $v_{\\max} = 6\\, v_{\\mathrm{th}}(T_0)$，$N_v = 800$，\n  - $\\Delta t = 1.0 \\times 10^{-6}\\ \\mathrm{s}$，$t_{\\mathrm{end}} = 1.0 \\times 10^{-3}\\ \\mathrm{s}$。\n\n- 案例2（无源衰减，中等截断）：\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$，$n_0 = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$，$T_0 = 500\\ \\mathrm{eV}$，\n  - $n_S = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$，$T_S = 500\\ \\mathrm{eV}$，\n  - $\\nu_s = 0\\ \\mathrm{s}^{-1}$，$\\nu_\\ell = 5.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$，\n  - $v_{\\max} = 5\\, v_{\\mathrm{th}}(T_0)$，$N_v = 400$，\n  - $\\Delta t = 1.0 \\times 10^{-6}\\ \\mathrm{s}$，$t_{\\mathrm{end}} = 1.0 \\times 10^{-4}\\ \\mathrm{s}$。\n\n- 案例3（热源，为引发漂移而截断域）：\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$，$n_0 = 1.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$，$T_0 = 300\\ \\mathrm{eV}$，\n  - $n_S = 2.0 \\times 10^{19}\\ \\mathrm{m}^{-3}$，$T_S = 5000\\ \\mathrm{eV}$，\n  - $\\nu_s = 3.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$，$\\nu_\\ell = 1.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$，\n  - $v_{\\max} = 2\\, v_{\\mathrm{th}}(T_S)$，$N_v = 200$，\n  - $\\Delta t = 5.0 \\times 10^{-7}\\ \\mathrm{s}$，$t_{\\mathrm{end}} = 5.0 \\times 10^{-4}\\ \\mathrm{s}$。\n\n- 案例4（粗速度网格分辨率）：\n  - $m = 3.344 \\times 10^{-27}\\ \\mathrm{kg}$，$n_0 = 8.0 \\times 10^{18}\\ \\mathrm{m}^{-3}$，$T_0 = 800\\ \\mathrm{eV}$，\n  - $n_S = 8.0 \\times 10^{18}\\ \\mathrm{m}^{-3}$，$T_S = 800\\ \\mathrm{eV}$，\n  - $\\nu_s = 2.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$，$\\nu_\\ell = 2.0 \\times 10^{4}\\ \\mathrm{s}^{-1}$，\n  - $v_{\\max} = 4\\, v_{\\mathrm{th}}(T_0)$，$N_v = 50$，\n  - $\\Delta t = 5.0 \\times 10^{-7}\\ \\mathrm{s}$，$t_{\\mathrm{end}} = 5.0 \\times 10^{-4}\\ \\mathrm{s}$。\n\n您的程序必须为每个案例计算如上定义的单一标量诊断 $D$，并生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3,\\mathrm{result}_4]$）。输出是无量纲的浮点数。所有计算和常数必须在科学上合理且自洽，并且数值积分、演化和诊断必须从第一性原理实现。不允许用户输入；程序必须是自包含的。",
            "solution": "该问题陈述构成了一个针对数值求解器的有效且良态的验证测试。它在科学上基于动理学理论的原理，特别是利用了Krook型源汇模型来描述粒子分布函数的演化。所有参数、方程和数值程序都得到了明确定义，是完整且一致的。任务是实现这个测试，该测试旨在突出全分布函数（`full-f`）模拟方法中的潜在失效，例如由于数值不准确性导致的人为粒子或能量漂移。这些正是较简单的微扰（`delta-f`）方法可能掩盖的误差类型。该问题是计算等离子体物理代码验证中的一个标准练习。\n\n问题的核心在于比较从离散化数值模拟中获得的宏观矩（密度和温度）的时间演化与它们的精确解析解。依赖于速度 $v$ 和时间 $t$ 的分布函数 $f(v,t)$ 的控制方程是一个线性常微分方程：\n$$\n\\frac{\\partial f}{\\partial t} = \\nu_s \\left(f_S(v) - f(v,t)\\right) - \\nu_\\ell f(v,t)\n$$\n这里，$\\nu_s$ 是源率，$\\nu_\\ell$ 是损失率，$f_S(v)$ 是一个规定的静态源分布。初始条件 $f(v,0)$ 和源 $f_S(v)$ 均以麦克斯韦分布的形式给出：\n$$\nf_M(v;n,T) = n \\left(\\frac{m}{2\\pi k_B T}\\right)^{3/2} \\exp\\left(-\\frac{m v^2}{2 k_B T}\\right)\n$$\n其中 $n$ 是密度，$T$ 是温度，$m$ 是粒子质量，$k_B$ 是玻尔兹曼常数。请注意，此物理公式中的温度 $T$ 必须以能量单位（焦耳）或开尔文为单位。问题指定输入温度 $T_{\\mathrm{eV}}$ 以电子伏特为单位，通过关系 $k_B T = e T_{\\mathrm{eV}}$ 进行转换，其中 $e$ 是基本电荷。\n\n通过在速度空间上对动理学控制方程进行积分，可以推导出密度矩 $n(t) = \\int_0^{\\infty} 4\\pi v^2 f(v,t)\\,dv$ 和能量矩 $E(t) = \\int_0^{\\infty} \\frac{1}{2} m v^2 \\, 4\\pi v^2 f(v,t)\\,dv$ 的精确演化方程。这些演化由以下公式给出：\n$$\n\\frac{dn}{dt} = \\nu_s n_S - (\\nu_s + \\nu_\\ell) n(t)\n$$\n$$\n\\frac{dE}{dt} = \\nu_s E_S - (\\nu_s + \\nu_\\ell) E(t)\n$$\n给定初始条件 $n(0)=n_0$ 和 $E(0)=E_0 = \\frac{3}{2} n_0 e T_0$，并定义 $\\mu = \\nu_s + \\nu_\\ell$，解为：\n$$\nn_{\\mathrm{exact}}(t) = n_0 e^{-\\mu t} + \\frac{\\nu_s n_S}{\\mu} \\left(1 - e^{-\\mu t}\\right)\n$$\n$$\nE_{\\mathrm{exact}}(t) = E_0 e^{-\\mu t} + \\frac{\\nu_s E_S}{\\mu} \\left(1 - e^{-\\mu t}\\right)\n$$\n其中 $E_S = \\frac{3}{2} n_S e T_S$。然后，可以从理想气体定律 $E_{\\mathrm{exact}}(t) = \\frac{3}{2} n_{\\mathrm{exact}}(t) e T_{\\mathrm{exact}}(t)$ 中求得以电子伏特为单位的精确温度。\n\n数值程序涉及对速度和时间域进行离散化。速度域 $v \\in [0, \\infty)$ 被截断到有限区间 $[0, v_{\\max}]$，并离散为 $N_v$ 个间距为 $\\Delta v$ 的均匀间隔点 $v_i$。每个网格点上分布函数的时间演化 $f_i^n \\equiv f(v_i, t_n)$，使用时间步长为 $\\Delta t$ 的显式欧拉法计算：\n$$\nf_i^{n+1} = f_i^{n} + \\Delta t \\left[ \\nu_s \\left(f_{S,i} - f_i^{n}\\right) - \\nu_\\ell f_i^{n}\\right] = f_i^{n} (1 - \\mu \\Delta t) + \\Delta t \\nu_s f_{S,i}\n$$\n在每个时间步 $t_n = n\\Delta t$，通过在离散速度网格上使用数值求积法则（如梯形法则）近似连续积分来计算数值矩 $n_{\\mathrm{num}}(t_n)$ 和 $E_{\\mathrm{num}}(t_n)$：\n$$\nn_{\\mathrm{num}}(t_n) \\approx \\sum_{i=0}^{N_v-1} w_i \\cdot 4\\pi v_i^2 f_i^n\n$$\n$$\nE_{\\mathrm{num}}(t_n) \\approx \\sum_{i=0}^{N_v-1} w_i \\cdot \\frac{1}{2} m v_i^2 \\cdot 4\\pi v_i^2 f_i^n\n$$\n其中 $w_i$ 表示求积权重。对于梯形法则，这对应于 `numpy.trapz`。随后计算数值温度 $T_{\\mathrm{num}}(t_n)$。\n\n数值解的质量由诊断量 $D = \\max(D_n, D_T)$ 来量化，其中 $D_n$ 和 $D_T$ 是在整个模拟时间内数值矩和精确矩之间的最大相对差异：\n$$\nD_n = \\max_{t_n} \\left| \\frac{n_{\\mathrm{num}}(t_n) - n_{\\mathrm{exact}}(t_n)}{n_{\\mathrm{exact}}(t_n)} \\right|, \\quad\nD_T = \\max_{t_n} \\left| \\frac{T_{\\mathrm{num}}(t_n) - T_{\\mathrm{exact}}(t_n)}{T_{\\mathrm{exact}}(t_n)} \\right|\n$$\n一个小的 $D$ 值表示高保真度模拟，其中数值误差（例如来自速度空间截断或粗网格分辨率的误差）是最小的。所提供的测试案例旨在探测这些特定的误差来源。例如，案例3使用一个热源分布和一个严重截断的速度域，预计会产生一个大的 $D$ 值，表明未能正确捕捉来自源的能量输入。案例4使用一个粗糙的速度网格，这将导致显著的数值积分误差。案例1是一个精细解析的基线，案例2则检验一个简单的衰减情景。实现将通过对每个测试案例执行这些步骤来进行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the full-f distribution function test problem for four cases.\n    \"\"\"\n    # Physical constants\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs\n    BOLTZMANN_K = 1.380649e-23   # Boltzmann constant in J/K\n\n    test_cases = [\n        # Case 1: well-resolved, balanced source-loss\n        {\n            \"m\": 3.344e-27, \"n0\": 1.0e19, \"T0_eV\": 100.0,\n            \"nS\": 1.0e19, \"TS_eV\": 100.0,\n            \"nu_s\": 1.0e4, \"nu_l\": 1.0e4,\n            \"vmax_factor\": 6.0, \"vmax_T_ref\": \"T0\", \"Nv\": 800,\n            \"dt\": 1.0e-6, \"t_end\": 1.0e-3\n        },\n        # Case 2: source-free decay, moderate truncation\n        {\n            \"m\": 3.344e-27, \"n0\": 1.0e19, \"T0_eV\": 500.0,\n            \"nS\": 1.0e19, \"TS_eV\": 500.0,\n            \"nu_s\": 0.0, \"nu_l\": 5.0e4,\n            \"vmax_factor\": 5.0, \"vmax_T_ref\": \"T0\", \"Nv\": 400,\n            \"dt\": 1.0e-6, \"t_end\": 1.0e-4\n        },\n        # Case 3: hot source, truncated domain to induce drift\n        {\n            \"m\": 3.344e-27, \"n0\": 1.0e19, \"T0_eV\": 300.0,\n            \"nS\": 2.0e19, \"TS_eV\": 5000.0,\n            \"nu_s\": 3.0e4, \"nu_l\": 1.0e4,\n            \"vmax_factor\": 2.0, \"vmax_T_ref\": \"TS\", \"Nv\": 200,\n            \"dt\": 5.0e-7, \"t_end\": 5.0e-4\n        },\n        # Case 4: coarse velocity grid resolution\n        {\n            \"m\": 3.344e-27, \"n0\": 8.0e18, \"T0_eV\": 800.0,\n            \"nS\": 8.0e18, \"TS_eV\": 800.0,\n            \"nu_s\": 2.0e4, \"nu_l\": 2.0e4,\n            \"vmax_factor\": 4.0, \"vmax_T_ref\": \"T0\", \"Nv\": 50,\n            \"dt\": 5.0e-7, \"t_end\": 5.0e-4\n        },\n    ]\n\n    results = []\n\n    def thermal_speed(T_eV, m):\n        \"\"\"Calculates thermal speed from temperature in eV.\"\"\"\n        return np.sqrt(2 * E_CHARGE * T_eV / m)\n\n    def maxwellian_f(v, n, T_eV, m):\n        \"\"\"Calculates Maxwellian distribution.\"\"\"\n        T_J = T_eV * E_CHARGE\n        if T_J == 0: return np.zeros_like(v)\n        # Handle potential overflow in normalization factor if T is very small\n        # Although problem parameters avoid this, it is good practice.\n        norm_factor = n * (m / (2 * np.pi * T_J))**1.5\n        exponent = -m * v**2 / (2 * T_J)\n        return norm_factor * np.exp(exponent)\n\n    for case in test_cases:\n        m, n0, T0_eV = case[\"m\"], case[\"n0\"], case[\"T0_eV\"]\n        nS, TS_eV = case[\"nS\"], case[\"TS_eV\"]\n        nu_s, nu_l = case[\"nu_s\"], case[\"nu_l\"]\n        vmax_factor, vmax_T_ref, Nv = case[\"vmax_factor\"], case[\"vmax_T_ref\"], case[\"Nv\"]\n        dt, t_end = case[\"dt\"], case[\"t_end\"]\n\n        # Setup parameters\n        mu = nu_s + nu_l\n        E0 = 1.5 * n0 * E_CHARGE * T0_eV\n        ES = 1.5 * nS * E_CHARGE * TS_eV\n\n        ref_T_for_vmax = T0_eV if vmax_T_ref == \"T0\" else TS_eV\n        v_max = vmax_factor * thermal_speed(ref_T_for_vmax, m)\n        v_grid = np.linspace(0, v_max, Nv)\n\n        Nt = int(np.round(t_end / dt))\n        time_pts = np.linspace(0, t_end, Nt + 1)\n        \n        # Initialize distribution function\n        f_n = maxwellian_f(v_grid, n0, T0_eV, m)\n        f_S = maxwellian_f(v_grid, nS, TS_eV, m)\n\n        n_num_hist, T_num_hist = [], []\n        n_exact_hist, T_exact_hist = [], []\n\n        # Time evolution loop\n        for t in time_pts:\n            # --- Analytical Solution ---\n            exp_mu_t = np.exp(-mu * t)\n            \n            # Handle case where mu=0 to avoid division by zero\n            if mu == 0:\n                n_exact = n0 + nu_s * nS * t\n                E_exact = E0 + nu_s * ES * t\n            else:\n                n_exact = n0 * exp_mu_t + (nu_s * nS / mu) * (1 - exp_mu_t)\n                E_exact = E0 * exp_mu_t + (nu_s * ES / mu) * (1 - exp_mu_t)\n            \n            # T_exact is in eV\n            T_exact = E_exact / (1.5 * n_exact * E_CHARGE) if n_exact > 0 else 0.0\n\n            n_exact_hist.append(n_exact)\n            T_exact_hist.append(T_exact)\n\n            # --- Numerical Solution ---\n            integrand_n = 4 * np.pi * v_grid**2 * f_n\n            n_num = np.trapz(integrand_n, v_grid)\n            \n            integrand_E = 0.5 * m * v_grid**2 * integrand_n\n            E_num = np.trapz(integrand_E, v_grid)\n\n            # T_num is in eV\n            T_num = E_num / (1.5 * n_num * E_CHARGE) if n_num > 0 else 0.0\n\n            n_num_hist.append(n_num)\n            T_num_hist.append(T_num)\n\n            # --- Update distribution function using Explicit Euler ---\n            f_n = f_n * (1 - mu * dt) + dt * nu_s * f_S\n\n        # Calculate diagnostics\n        n_num_hist = np.array(n_num_hist)\n        T_num_hist = np.array(T_num_hist)\n        n_exact_hist = np.array(n_exact_hist)\n        T_exact_hist = np.array(T_exact_hist)\n        \n        # Avoid division by zero if exact value is zero (though not expected here)\n        # Use np.divide with a 'where' clause for robustness\n        with np.errstate(divide='ignore', invalid='ignore'):\n            rel_err_n = np.abs((n_num_hist - n_exact_hist) / n_exact_hist)\n            rel_err_T = np.abs((T_num_hist - T_exact_hist) / T_exact_hist)\n        \n        # Replace NaNs or Infs from division-by-zero with 0.0\n        rel_err_n[~np.isfinite(rel_err_n)] = 0.0\n        rel_err_T[~np.isfinite(rel_err_T)] = 0.0\n        \n        D_n = np.max(rel_err_n)\n        D_T = np.max(rel_err_T)\n\n        D = max(D_n, D_T)\n        results.append(D)\n    \n    # In problem statement, k_B T = e T_eV. The formula for maxwellian had k_B T, so I used k_B * T_K which is T_J.\n    # The temperature from energy is E = 3/2 n k_B T_K, so T_K = E / (3/2 n k_B).\n    # T_eV = T_K * k_B / e = (E / (3/2 n k_B)) * k_B / e = E / (3/2 n e).\n    # My python implementation used T_J for the Maxwellian (which is correct)\n    # and E_exact / (1.5 * n_exact * E_CHARGE) for T_exact_eV, which is correct.\n    # The original had Boltzmann constant in the temperature conversion which was wrong.\n    # I have corrected it locally in my reasoning but the code was already correct.\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "湍流模拟的最终目标是获得物理上的洞见。一个主要的诊断工具是频率-波数谱分析，它通过变换涨落数据来揭示主导的不稳定性。本练习 () 演示了如何构建这一诊断工具，从使用窗函数等恰当的数值技术处理合成的湍流信号，到解读功率谱以识别和分类如离子温度梯度模（ITG）和捕获电子模（TEM）等关键的等离子体模式。",
            "id": "4203273",
            "problem": "您的任务是为磁约束聚变等离子体湍流中由全分布函数方法（“full-f”模拟）产生的涨落设计一个频率-波数诊断。目标是从合成的 full-f 涨落数据中提取主要谱峰，并根据其在副法线波数方向上的传播方向，将它们分类为离子温度梯度（ITG）模或捕获电子模（TEM）。请将该诊断实现为一个完整的、可运行的程序，该程序根据下面所有的指令，为指定的测试套件生成所需的输出。\n\n从适用于聚变等离子体湍流的第一性原理和核心定义开始：\n\n- 全分布函数（“full-f”）方法在动理学方程下演化整个粒子分布函数，而不仅仅是其涨落。对于无碰撞静电涨落，分布函数 $f$ 的弗拉索夫方程可以写成简化形式\n  $$\\frac{\\partial f}{\\partial t} + \\mathbf{v}\\cdot \\nabla f + \\frac{q}{m}\\left(\\mathbf{E} + \\mathbf{v}\\times\\mathbf{B}\\right)\\cdot \\frac{\\partial f}{\\partial \\mathbf{v}} = 0,$$\n  其中 $q$ 是电荷，$m$ 是质量，$\\mathbf{E}$ 是电场，$\\mathbf{B}$ 是磁场。在 full-f 方法中，通常分析从 $f$ 中提取的可观测量（例如密度、电势）的涨落，该涨落是副法线坐标 $y$ 和时间 $t$ 的函数。\n- 频率-波数谱通过二维傅里叶变换定义。对于一个涨落信号 $s(y,t)$，定义其连续变换为\n  $$S(k,\\omega) = \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} s(y,t)\\,e^{-i(ky - \\omega t)}\\,dy\\,dt,$$\n  以及相应的功率谱密度\n  $$P(k,\\omega) = |S(k,\\omega)|^2.$$\n  在数值上，我们将在均匀采样的网格上使用离散傅里叶变换，并应用可分离窗函数来减少谱泄漏。\n\n连接谱与模式识别的物理诠释判据：\n\n- 离子温度梯度（ITG）模主要是由离子温度梯度驱动的漂移波，并倾向于在离子逆磁方向上传播（副法线方向传播）。捕获电子模（TEM）由电子动力学驱动，并在电子逆磁方向上传播。为了本诊断的目的，通过相速度的符号对谱峰进行分类\n  $$v_{\\mathrm{ph}} = \\frac{\\omega}{k},$$\n  该符号相对于已知的定向副法线逆磁传播方向的符号。令 $s_i \\in \\{-1,+1\\}$ 表示离子逆磁方向的符号，$s_e \\in \\{-1,+1\\}$ 表示电子逆磁方向的符号。如果 $\\mathrm{sign}(v_{\\mathrm{ph}}) = s_i$，则分类为 ITG；如果 $\\mathrm{sign}(v_{\\mathrm{ph}}) = s_e$，则分类为 TEM；否则分类为不明确。\n- 由于实值信号会在 $(k,\\omega)$ 和 $(-k,-\\omega)$ 处产生对称的谱峰，因此将谱峰搜索限制在 $k0$ 的范围内，以避免无关的对称重复。如果在 $k0$ 半平面内，有多个峰在数值容差范围内共享相同的最大功率，则将该情况标记为不明确。\n\n按如下方式构建合成的 full-f 涨落数据并实现该诊断：\n\n1. 定义一个在副法线方向上的均匀空间网格，该网格在域长度 $L_y$（单位：米）上有 $N_y$ 个点，以及一个均匀时间网格，该网格在持续时间 $T$（单位：秒）上有 $N_t$ 个点。令离散坐标为 $y_j$（$j=0,\\dots,N_y-1$）和 $t_n$（$n=0,\\dots,N_t-1$）。\n2. 对于每个测试用例，生成一个信号\n   $$s(y,t) = \\sum_{p=1}^{N_{\\mathrm{waves}}} A_p \\cos(k_p y - \\omega_p t + \\phi_p) + \\eta(y,t),$$\n   其中 $A_p$ 是振幅（无量纲），$k_p$ 是波数（单位：rad/m），$\\omega_p$ 是角频率（单位：rad/s），$\\phi_p$ 是相位（单位：弧度），$\\eta(y,t)$ 是具有指定标准差 $\\sigma$（与 $s$ 单位相同）的附加零均值高斯噪声。在进行傅里叶变换之前，使用可复现的噪声种子，并在 $y$ 和 $t$ 两个方向上应用可分离的汉宁窗函数。\n3. 计算加窗后数据的离散二维傅里叶变换，以在离散网格上获得 $S(k,\\omega)$\n   $$k_m = \\frac{2\\pi}{L_y} m,\\quad m = -\\frac{N_y}{2},\\dots,\\frac{N_y}{2}-1,$$\n   $$\\omega_\\ell = \\frac{2\\pi}{T} \\ell,\\quad \\ell = -\\frac{N_t}{2},\\dots,\\frac{N_t}{2}-1.$$\n   使用与上述连续定义一致的离散傅里叶变换定义，并计算功率谱密度 $P(k,\\omega) = |S(k,\\omega)|^2$。\n4. 将谱峰搜索限制在 $k0$。识别最大功率 $P_{\\max}$ 以及一组索引 $(k^*,\\omega^*)$，在这些索引处 $P(k^*,\\omega^*)$ 在一个小的容差范围内达到 $P_{\\max}$。如果在 $k^*0$ 的情况下存在多个这样的 $(k^*,\\omega^*)$，则将该情况分类为不明确。否则，计算 $v_{\\mathrm{ph}} = \\omega^*/k^*$ 并根据测试用例中定义的逆磁符号 $s_i$ 和 $s_e$ 对主导模式进行分类。\n5. 处理边界条件：如果 $|k^*|$ 或 $|\\omega^*|$ 低于由网格间距设定的分辨率阈值（例如，低于半个仓格），则分类为不明确。\n\n实现程序以评估以下测试套件。所有角频率单位必须是 rad/s，波数单位是 rad/m，相位单位是弧度，空间域长度单位是米，时间持续单位是秒。为了数值稳定性和可解释性，所提供的 $k_p$ 和 $\\omega_p$ 值与所选网格的精确离散频率仓重合。\n\n设 $L_y = 10.0$ 且 $T = 1.0$。设 $N_y = 256$ 且 $N_t = 512$。设 $\\sigma = 0.10$ 并使用固定的随机种子。对于所有情况，设置离子逆磁符号 $s_i = -1$ 和电子逆磁符号 $s_e = +1$。\n\n定义波数仓增量 $\\Delta k = \\frac{2\\pi}{L_y}$ 和角频率仓增量 $\\Delta \\omega = \\frac{2\\pi}{T}$。\n\n- 测试用例 1 (单个类 ITG 波):\n  - 波：一个，其 $A_1 = 1.0$，$k_1 = 5\\Delta k = 3.141592653589793$ rad/m，$\\omega_1 = -2\\Delta \\omega = -12.566370614359172$ rad/s，$\\phi_1 = 0.2$ 弧度。\n- 测试用例 2 (单个类 TEM 波):\n  - 波：一个，其 $A_1 = 0.8$，$k_1 = 4\\Delta k = 2.5132741228718345$ rad/m，$\\omega_1 = +1\\Delta \\omega = 6.283185307179586$ rad/s，$\\phi_1 = 1.0$ 弧度。\n- 测试用例 3 (在相同 $k$ 值下混合等幅反向传播导致不明确):\n  - 波：两个，一个为 $A_1 = 1.0$，$k_1 = 6\\Delta k = 3.7699111843077517$ rad/m，$\\omega_1 = +3\\Delta \\omega = 18.84955592153876$ rad/s，$\\phi_1 = 0.5$ 弧度；另一个为 $A_2 = 1.0$，$k_2 = 6\\Delta k = 3.7699111843077517$ rad/m，$\\omega_2 = -3\\Delta \\omega = -18.84955592153876$ rad/s，$\\phi_2 = -0.3$ 弧度。\n- 测试用例 4 (近奈奎斯特、高频类 TEM 波):\n  - 波：一个，其 $A_1 = 0.6$，$k_1 = 120\\Delta k = 75.39822368615503$ rad/m，$\\omega_1 = 200\\Delta \\omega = 1256.6370614359173$ rad/s，$\\phi_1 = -1.2$ 弧度。\n\n您的程序必须为每个测试用例构建信号，使用汉宁窗计算二维离散傅里叶变换，在 $k0$ 半平面中提取主导的 $(k^*,\\omega^*)$，计算相速度 $v_{\\mathrm{ph}} = \\omega^*/k^*$，并根据上述符号规则对模式进行分类。如果在 $k0$ 范围内有多个 $(k^*,\\omega^*)$ 在容差内达到相同的最大功率，或者如果 $|k^*|$ 或 $|\\omega^*|$ 低于半个仓格分辨率，则返回不明确的分类。\n\n最终输出格式要求：\n\n- 您的程序应生成一行输出，其中包含四个测试用例的结果，格式为方括号内以逗号分隔的整数列表，其中 $1$ 表示 ITG，$2$ 表示 TEM，$0$ 表示不明确（例如，\"[1,2,0,2]\"）。\n\n不允许用户输入；所有参数必须按规定进行硬编码。实现必须在物理上和数值上自洽，并且必须遵守所述的定义和判据。",
            "solution": "该问题要求设计并实现一个用于合成涨落数据的频率-波数诊断，以模拟来自全分布函数（“full-f”）等离子体湍流代码的输出。目标是识别主导谱模，并根据其传播方向将其分类为离子温度梯度（ITG）模或捕获电子模（TEM）。分析将在一系列测试用例上进行。\n\n问题陈述被验证为科学上合理、适定且完整。它基于等离子体动理学理论、傅里叶分析和数值信号处理的既定原则。唯一解所需的所有参数和条件均已提供。因此，我们可以继续进行求解。\n\n该诊断的核心在于将信号从时空域 $(y, t)$ 变换到频率-波数域 $(k, \\omega)$，在频率-波数域中，波模表现为功率谱中的明显峰值。\n\n首先，我们定义数学和物理框架。一个由实值信号 $s(y,t)$ 表示的涨落，定义在一个二维网格上。副法线空间坐标是 $y \\in [0, L_y)$，时间坐标是 $t \\in [0, T)$。该信号由相干的类波结构和随机噪声分量的叠加组成：\n$$\ns(y,t) = \\sum_{p=1}^{N_{\\mathrm{waves}}} A_p \\cos(k_p y - \\omega_p t + \\phi_p) + \\eta(y,t)\n$$\n此处，对于每个波分量 $p$，$A_p$ 是振幅，$k_p$ 是波数，$\\omega_p$ 是角频率，$\\phi_p$ 是一个恒定的相位偏移。项 $\\eta(y,t)$ 表示标准差为 $\\sigma$ 的零均值高斯噪声。\n\n主要的分析工具是二维傅里叶变换，它将信号分解为其组成频率和波数。连续傅里叶变换由以下公式给出：\n$$\nS(k,\\omega) = \\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty} s(y,t)\\,e^{-i(ky - \\omega t)}\\,dy\\,dt\n$$\n功率谱密度 $P(k,\\omega) = |S(k,\\omega)|^2$ 量化了信号功率在 $(k, \\omega)$ 平面上的分布。此谱中的峰值对应于信号中的主导波模。\n\n在数值上，信号在离散网格上采样：$y_j = j \\frac{L_y}{N_y}$，其中 $j=0, \\dots, N_y-1$；以及 $t_n = n \\frac{T}{N_t}$，其中 $n=0, \\dots, N_t-1$。连续傅里叶变换被二维离散傅里叶变换（DFT）所取代，后者通过快速傅里叶变换（FFT）算法高效计算。相应的离散波数和频率为：\n$$\nk_m = \\frac{2\\pi}{L_y} m, \\quad m \\in \\{-\\frac{N_y}{2}, \\dots, \\frac{N_y}{2}-1\\}\n$$\n$$\n\\omega_\\ell = \\frac{2\\pi}{T} \\ell, \\quad \\ell \\in \\{-\\frac{N_t}{2}, \\dots, \\frac{N_t}{2}-1\\}\n$$\n基本分辨率仓为 $\\Delta k = 2\\pi/L_y$ 和 $\\Delta \\omega = 2\\pi/T$。\n\n数值谱分析中的一个关键步骤是应用窗函数。由于 DFT 假设信号在域上是周期的，有限信号的起点和终点之间的任何不连续性都会造成谱泄漏，即单个频率的功率“泄漏”到相邻的频率仓中。为了减轻这种情况，我们将信号乘以一个在边界处平滑衰减到零的窗函数。使用可分离的二维汉宁窗：\n$$\nw(y_j, t_n) = \\left(\\frac{1}{2} - \\frac{1}{2}\\cos\\frac{2\\pi j}{N_y}\\right) \\left(\\frac{1}{2} - \\frac{1}{2}\\cos\\frac{2\\pi n}{N_t}\\right)\n$$\n然后对加窗后的信号 $s'(y_j, t_n) = s(y_j, t_n) \\cdot w(y_j, t_n)$ 执行 DFT。\n\n模式分类基于相速度 $v_{\\mathrm{ph}} = \\omega/k$。在托卡马克湍流的简化模型中，ITG 模在离子逆磁方向上传播，而 TEM 则在电子逆磁方向上传播。这些方向由符号 $s_i$ 和 $s_e$ 指定。对于本问题，$s_i = -1$ 和 $s_e = +1$，分别对应于负相速度和正相速度。\n由于信号 $s(y,t)$ 是实值的，其傅里叶谱表现出厄米对称性：$S(k, \\omega) = S^*(-k, -\\omega)$，这意味着 $P(k, \\omega) = P(-k, -\\omega)$。因此，所有唯一的信息都包含在 $k$ 平面的半边。我们将主导模式的搜索限制在 $k  0$ 的半平面。对于在 $k^*  0$ 处找到的峰 $(k^*, \\omega^*)$，其相速度的符号就是频率的符号，即 $\\mathrm{sign}(v_{\\mathrm{ph}}) = \\mathrm{sign}(\\omega^*)$。\n\n分类逻辑如下：\n1.  在功率谱中找到最大功率 $P_{\\max}$ 的位置 $(k^*, \\omega^*)$，将搜索限制在 $k  0$。\n2.  检查不明确性。在以下情况下宣布为不明确案例：\n    a. 在搜索域中有多个 $(k, \\omega)$ 对的功率在数值容差内等于 $P_{\\max}$。这可以处理像强度相等的反向传播模式这样的情况。\n    b. 主导模式位于零频率（即 $\\omega^*=0$），这对应于低于 $0.5 \\Delta \\omega$ 的频率分辨率阈值。在这种情况下，相速度是不良定义的。对 $k^*$ 的条件通过搜索 $k0$ 自然满足。\n3.  如果模式是明确的，则对其进行分类：\n    -   如果 $\\mathrm{sign}(\\omega^*) = s_i$，则为 ITG 模（分配代码 $1$）。\n    -   如果 $\\mathrm{sign}(\\omega^*) = s_e$，则为 TEM 模（分配代码 $2$）。\n    -   如果两个条件都不满足（对于非零 $\\omega^*$ 不应发生这种情况），则为不明确（代码 $0$）。\n\n实现将按以下步骤进行：为每个测试用例构建信号，应用汉宁窗，执行二维 FFT，计算功率谱，并执行上述的寻峰和分类逻辑。固定的随机种子确保了噪声分量的可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a frequency-wavenumber diagnostic for synthetic plasma\n    fluctuation data to classify dominant turbulence modes.\n    \"\"\"\n    # Global parameters as specified in the problem statement\n    Ly = 10.0  # meters\n    T = 1.0    # seconds\n    Ny = 256   # spatial grid points\n    Nt = 512   # temporal grid points\n    sigma = 0.10 # standard deviation of Gaussian noise\n    random_seed = 42 # for reproducible noise\n    \n    # Diamagnetic direction signs\n    s_i = -1  # ion diamagnetic direction sign\n    s_e = +1  # electron diamagnetic direction sign\n    \n    # Fundamental frequency and wavenumber bins\n    delta_k = 2.0 * np.pi / Ly\n    delta_omega = 2.0 * np.pi / T\n\n    # Test case definitions\n    test_cases = [\n        # Case 1: Single ITG-like wave\n        [{'A': 1.0, 'k': 5 * delta_k, 'omega': -2 * delta_omega, 'phi': 0.2}],\n        # Case 2: Single TEM-like wave\n        [{'A': 0.8, 'k': 4 * delta_k, 'omega': 1 * delta_omega, 'phi': 1.0}],\n        # Case 3: Mixed equal-amplitude counter-propagating waves\n        [\n            {'A': 1.0, 'k': 6 * delta_k, 'omega': 3 * delta_omega, 'phi': 0.5},\n            {'A': 1.0, 'k': 6 * delta_k, 'omega': -3 * delta_omega, 'phi': -0.3}\n        ],\n        # Case 4: Near-Nyquist, high-frequency TEM-like wave\n        [{'A': 0.6, 'k': 120 * delta_k, 'omega': 200 * delta_omega, 'phi': -1.2}]\n    ]\n    \n    results = []\n    \n    # Create spatial and temporal grids\n    y = np.linspace(0, Ly, Ny, endpoint=False)\n    t = np.linspace(0, T, Nt, endpoint=False)\n    yy, tt = np.meshgrid(y, t)\n\n    # Create frequency and wavenumber axes for analysis\n    k_axis = np.fft.fftshift(np.fft.fftfreq(Ny, d=Ly/Ny) * 2.0 * np.pi)\n    omega_axis = np.fft.fftshift(np.fft.fftfreq(Nt, d=T/Nt) * 2.0 * np.pi)\n\n    # Initialize random number generator\n    rng = np.random.default_rng(random_seed)\n\n    for waves in test_cases:\n        # 1. Generate signal\n        signal = np.zeros((Nt, Ny))\n        for wave in waves:\n            signal += wave['A'] * np.cos(wave['k'] * yy - wave['omega'] * tt + wave['phi'])\n        \n        # Add reproducible Gaussian noise\n        noise = rng.normal(loc=0.0, scale=sigma, size=(Nt, Ny))\n        signal += noise\n        \n        # 2. Apply separable Hann window\n        hann_y = np.hanning(Ny)\n        hann_t = np.hanning(Nt)\n        window = np.outer(hann_t, hann_y)\n        signal_windowed = signal * window\n        \n        # 3. Compute 2D FFT and Power Spectral Density\n        S = np.fft.fft2(signal_windowed)\n        # Shift the zero-frequency component to the center of the spectrum\n        S_shifted = np.fft.fftshift(S)\n        P_shifted = np.abs(S_shifted)**2\n        \n        # 4. Peak search and classification\n        \n        # Restrict search to k > 0\n        k_positive_start_idx = Ny // 2 + 1\n        search_region = P_shifted[:, k_positive_start_idx:]\n        \n        if search_region.size == 0:\n            results.append(0) # Ambiguous if no k>0 region\n            continue\n\n        P_max = np.max(search_region)\n        \n        # Ambiguity check 1: multiple peaks with the same max power\n        # Use a relative tolerance to account for floating point inaccuracies.\n        peak_indices = np.argwhere(np.isclose(search_region, P_max, rtol=1e-3))\n        \n        if len(peak_indices) > 1:\n            results.append(0) # Ambiguous\n            continue\n\n        # Single dominant peak found\n        idx_omega_shifted, idx_k_sub = peak_indices[0]\n        \n        # Convert sub-region k index to full spectrum index\n        idx_k_shifted = idx_k_sub + k_positive_start_idx\n        \n        omega_star = omega_axis[idx_omega_shifted]\n        k_star = k_axis[idx_k_shifted]\n\n        # Ambiguity check 2: peak at or below resolution threshold\n        # |k*| > 0.5*delta_k is guaranteed due to k>0 search.\n        # Check if |omega*| = 0.5*delta_omega, which means omega* = 0.\n        if np.isclose(omega_star, 0.0, atol=1e-9):\n            results.append(0) # Ambiguous\n            continue\n\n        # 5. Classify the mode\n        sign_v_ph = np.sign(omega_star) # since k_star > 0\n\n        if sign_v_ph == s_i:\n            results.append(1) # ITG\n        elif sign_v_ph == s_e:\n            results.append(2) # TEM\n        else:\n            results.append(0) # Ambiguous\n            \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}