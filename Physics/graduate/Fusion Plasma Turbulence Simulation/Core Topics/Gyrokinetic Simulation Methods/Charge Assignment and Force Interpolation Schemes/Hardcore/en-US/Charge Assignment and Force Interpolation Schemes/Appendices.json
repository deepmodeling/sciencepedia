{
    "hands_on_practices": [
        {
            "introduction": "The first step in any Particle-In-Cell simulation is to represent the collection of discrete particles as a continuous charge density field on the computational grid. This practice guides you through the fundamental mathematical derivation of this process. By starting from a microscopic density of point charges and projecting it onto a nodal basis, you will derive the general formula for charge assignment and apply it to the widely used Cloud-In-Cell (CIC) scheme .",
            "id": "4183274",
            "problem": "In a fusion plasma turbulence simulation using an advanced Particle-In-Cell (PIC) discretization, the microscopic charge density is represented by a sum of Dirac delta distributions, $ \\rho(\\mathbf{x}) = \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p}) $, where $ q_{p} $ and $ \\mathbf{x}_{p} $ are the charge and position of particle $ p $. On a uniform Cartesian mesh with spacings $ \\Delta x $ and $ \\Delta y $ in two spatial dimensions, the nodal charge density $ \\rho_{g} $ associated with a grid node at position $ \\mathbf{x}_{g} $ is defined by a projection of $ \\rho(\\mathbf{x}) $ onto a translationally invariant nodal basis $ N_{g}(\\mathbf{x}) = N(\\mathbf{x} - \\mathbf{x}_{g}) $ followed by mass-lumping normalization: $ \\rho_{g} := A^{-1} \\int_{\\Omega} \\rho(\\mathbf{x}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x} $, where $ A := \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x} $. Using only the definitions above together with properties of the Dirac delta distribution and translational invariance of $ N_{g} $, derive the functional form of $ \\rho_{g} $ in terms of a shape function evaluated on the node-particle offset.\n\nThen, specialize to the Cloud-In-Cell (CIC) choice of $ N(\\mathbf{x}) $, constructed as the tensor product of one-dimensional linear hat functions that conserve charge. Let the one-dimensional reference hat be defined by $ N_{1\\mathrm{D}}(x) = \\max\\{0,\\,1 - |x|/\\Delta x\\} $ and similarly for $ y $, so that $ N(\\mathbf{x}) = N_{1\\mathrm{D}}(x) \\, N_{1\\mathrm{D}}(y) $. Consider a single particle of charge $ q_{p} $ residing in the cell whose lower-left node is at $ (x_{i}, y_{j}) $, with position $ x_{p} = x_{i} + a \\,\\Delta x $ and $ y_{p} = y_{j} + b \\,\\Delta y $, where $ 0 \\leq a \\leq 1 $ and $ 0 \\leq b \\leq 1 $. Evaluate the discrete nodal charge density $ \\rho_{i,j} $ contributed by this particle under CIC.\n\nExpress your final answer as a single closed-form analytic expression in terms of $ q_{p} $, $ \\Delta x $, $ \\Delta y $, $ a $, and $ b $. State the final result in coulombs per square meter.",
            "solution": "We begin from the microscopic representation of charge, $ \\rho(\\mathbf{x}) = \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p}) $, which is a standard model for point charges in continuous space. The discrete nodal value $ \\rho_{g} $ is defined by projecting this field onto a nodal basis $ N_{g}(\\mathbf{x}) = N(\\mathbf{x} - \\mathbf{x}_{g}) $ and normalizing by the basis integral to produce a density:\n$$\n\\rho_{g} := A^{-1} \\int_{\\Omega} \\rho(\\mathbf{x}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}, \\quad A := \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x}.\n$$\nInserting the microscopic form into the projection yields\n$$\n\\rho_{g} = A^{-1} \\int_{\\Omega} \\left( \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p}) \\right) N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}.\n$$\nBy linearity of integration and summation, and the sifting property of the Dirac delta distribution, we obtain\n$$\n\\rho_{g} = A^{-1} \\sum_{p} q_{p} \\int_{\\Omega} \\delta(\\mathbf{x} - \\mathbf{x}_{p}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}\n= A^{-1} \\sum_{p} q_{p} \\, N_{g}(\\mathbf{x}_{p}).\n$$\nUsing translational invariance of the nodal basis, $ N_{g}(\\mathbf{x}_{p}) = N(\\mathbf{x}_{p} - \\mathbf{x}_{g}) $, we may write\n$$\n\\rho_{g} = \\sum_{p} q_{p} \\, S(\\mathbf{x}_{g} - \\mathbf{x}_{p}),\n$$\nwhere the shape function $ S(\\mathbf{u}) $ is defined as $ S(\\mathbf{u}) := A^{-1} N(-\\mathbf{u}) $. For shape functions $ N(\\mathbf{x}) $ that are even, such as the Cloud-In-Cell choice, $ N(-\\mathbf{u}) = N(\\mathbf{u}) $, and thus $ S(\\mathbf{u}) = A^{-1} N(\\mathbf{u}) $. This construction yields a consistent charge assignment in which the same shape appears in the reciprocal force interpolation, ensuring momentum conservation when the same $ S $ is used to interpolate fields back to particles.\n\nWe now specialize to the Cloud-In-Cell (CIC) nodal basis in two dimensions. The one-dimensional linear hat function is\n$$\nN_{1\\mathrm{D}}(x) = \\max\\{0,\\, 1 - |x|/\\Delta x \\},\n$$\nand the two-dimensional nodal basis is the tensor product\n$$\nN(\\mathbf{x}) = N_{1\\mathrm{D}}(x) \\, N_{1\\mathrm{D}}(y).\n$$\nThe integral of $ N $ over its support is the product of the one-dimensional integrals. In one dimension,\n$$\n\\int_{-\\Delta x}^{\\Delta x} N_{1\\mathrm{D}}(x) \\, dx = \\int_{-\\Delta x}^{\\Delta x} \\left( 1 - \\frac{|x|}{\\Delta x} \\right) dx = \\Delta x.\n$$\nSimilarly, in $ y $,\n$$\n\\int_{-\\Delta y}^{\\Delta y} N_{1\\mathrm{D}}(y) \\, dy = \\Delta y.\n$$\nHence,\n$$\nA = \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x} = \\left( \\int N_{1\\mathrm{D}}(x) \\, dx \\right) \\left( \\int N_{1\\mathrm{D}}(y) \\, dy \\right) = \\Delta x \\, \\Delta y.\n$$\nTherefore, the CIC shape function is\n$$\nS(\\mathbf{u}) = \\frac{1}{\\Delta x \\, \\Delta y} \\, N(\\mathbf{u}) = \\frac{1}{\\Delta x \\, \\Delta y} \\, N_{1\\mathrm{D}}(u_{x}) \\, N_{1\\mathrm{D}}(u_{y}).\n$$\n\nConsider now a single particle of charge $ q_{p} $ inside the cell whose lower-left node is at $ (x_{i}, y_{j}) $, positioned at $ x_{p} = x_{i} + a \\,\\Delta x $, $ y_{p} = y_{j} + b \\,\\Delta y $ with $ 0 \\leq a \\leq 1 $ and $ 0 \\leq b \\leq 1 $. We seek the nodal charge density at the lower-left node, i.e., $ \\rho_{i,j} $, which by the assignment rule is\n$$\n\\rho_{i,j} = q_{p} \\, S(\\mathbf{x}_{i,j} - \\mathbf{x}_{p}) = q_{p} \\, \\frac{1}{\\Delta x \\, \\Delta y} \\, N_{1\\mathrm{D}}(x_{i} - x_{p}) \\, N_{1\\mathrm{D}}(y_{j} - y_{p}).\n$$\nBecause $ x_{i} - x_{p} = - a \\,\\Delta x $ and $ y_{j} - y_{p} = - b \\,\\Delta y $, and $ N_{1\\mathrm{D}} $ depends on the absolute value,\n$$\nN_{1\\mathrm{D}}(x_{i} - x_{p}) = 1 - \\frac{|x_{i} - x_{p}|}{\\Delta x} = 1 - \\frac{a \\,\\Delta x}{\\Delta x} = 1 - a,\n$$\n$$\nN_{1\\mathrm{D}}(y_{j} - y_{p}) = 1 - \\frac{|y_{j} - y_{p}|}{\\Delta y} = 1 - \\frac{b \\,\\Delta y}{\\Delta y} = 1 - b.\n$$\nSubstituting these into the expression for $ \\rho_{i,j} $ gives\n$$\n\\rho_{i,j} = q_{p} \\, \\frac{1}{\\Delta x \\, \\Delta y} \\, (1 - a) \\, (1 - b).\n$$\nThis is a closed-form analytic expression in terms of $ q_{p} $, $ \\Delta x $, $ \\Delta y $, $ a $, and $ b $, with units of coulombs per square meter, as required. Notably, the other three nodes of the cell receive weights $ a(1 - b)/(\\Delta x \\Delta y) $, $ (1 - a)b/(\\Delta x \\Delta y) $, and $ ab/(\\Delta x \\Delta y) $, which together with $ (1 - a)(1 - b)/(\\Delta x \\Delta y) $ sum to $ 1/(\\Delta x \\Delta y) $, ensuring that the deposited nodal charges aggregate to the particle's charge density distribution over the cell area.",
            "answer": "$$\\boxed{\\frac{q_{p}}{\\Delta x \\,\\Delta y}\\,(1 - a)\\,(1 - b)}$$"
        },
        {
            "introduction": "A robust numerical scheme must rigorously uphold the physical conservation laws it models, with charge conservation being paramount. This practice provides both an analytical proof and a numerical verification that the 'partition of unity' property of shape functions is the key to ensuring that the total charge on the grid exactly matches the total charge of the particles. You will see how this property prevents the artificial creation or destruction of charge, a common source of catastrophic instability in simulations .",
            "id": "4183292",
            "problem": "Consider a uniform, periodic, Cartesian grid used in a Particle-In-Cell (PIC) method for fusion plasma turbulence simulation. Let the spatial domain be two-dimensional with lengths $L_x$ and $L_y$, discretized into $N_x$ and $N_y$ equally spaced nodes, respectively. The grid spacings are $h_x = L_x / N_x$ and $h_y = L_y / N_y$. A collection of $N_p$ point particles with charges $\\{q_i\\}_{i=1}^{N_p}$ and positions $\\{\\mathbf{x}_i\\}_{i=1}^{N_p}$, where $\\mathbf{x}_i = (x_i,y_i)$, is to be deposited onto the grid as a charge density field $\\rho_{j,k}$ at node indices $(j,k)$.\n\nThe PIC charge assignment uses a dimensionwise separable shape function $W(\\xi)$ with compact support and the exact partition-of-unity property, defined by the requirement that for any real $\\xi$, the infinite sum over integers satisfies $\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$. The two-dimensional shape is the product $S(\\mathbf{x}) = W(x/h_x) W(y/h_y)$ evaluated on dimensionless coordinates. The charge deposition rule is\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right),\n$$\nwith periodic boundary conditions so that all node indices are interpreted modulo $N_x$ and $N_y$. The physical units for charge are Coulombs (C), and the charge density has units of Coulombs per square meter (C/m$^2$).\n\nTask A (proof): Starting from the conservation of charge in its integral form and the above discrete deposition definition, derive from first principles that the total charge deposited on the grid,\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y,\n$$\nis exactly equal to the total particle charge $Q_{\\text{part}} = \\sum_{i=1}^{N_p} q_i$ at every time step, provided $W(\\xi)$ satisfies the exact partition-of-unity and the periodic wrap is implemented correctly. Explain why this prevents net-charge drift in the discrete system.\n\nTask B (numerical verification): Implement the one-dimensional shapes used in practice that satisfy the exact partition-of-unity and have compact support:\n- Nearest-Grid-Point (NGP), also known as the order-$0$ B-spline.\n- Cloud-In-Cell (CIC), also known as the order-$1$ B-spline.\n- Triangular-Shaped Cloud (TSC), also known as the order-$2$ B-spline with three-point support.\n\nUse these to build the two-dimensional separable shape $S(\\mathbf{x})$ and verify numerically that $Q_{\\text{grid}} - Q_{\\text{part}}$ is zero to machine precision for random particle sets. Also construct a deliberately broken variant of the CIC shape by multiplying all one-dimensional weights by a constant factor $\\alpha \\neq 1$ (creating a violation of the partition-of-unity) and empirically demonstrate the resulting net-charge drift.\n\nAll calculations must be in the International System of Units (SI). Report the numerical discrepancies in Coulombs (C). Angles are not used. Your program must produce a single line of output containing the results of all test cases as a comma-separated list enclosed in square brackets. Each element must be a floating-point number representing the absolute value of $Q_{\\text{grid}} - Q_{\\text{part}}$ in Coulombs (C).\n\nUse the following test suite to ensure coverage and reproducibility. For each test, particle positions are sampled uniformly in the domain unless otherwise specified, and random numbers use the given seed:\n\n- Test $1$ (happy path, CIC): $L_x = 1.0$ (m), $L_y = 0.5$ (m), $N_x = 64$, $N_y = 32$, $N_p = 1000$, random seed $42$, particle charges sampled from a normal distribution with zero mean and standard deviation $1.0 \\times 10^{-19}$ (C).\n- Test $2$ (boundary condition stress, NGP): $L_x = 1.0$ (m), $L_y = 1.0$ (m), $N_x = 4$, $N_y = 4$, $N_p = 10$, fixed positions clustered near the upper-right boundary at $(x_i,y_i) \\approx (L_x - \\varepsilon, L_y - \\varepsilon)$ with $\\varepsilon = 10^{-12}$ (m), random seed $7$ for charges from a normal distribution with zero mean and standard deviation $5.0 \\times 10^{-20}$ (C).\n- Test $3$ (higher-order shape, TSC): $L_x = 0.64$ (m), $L_y = 0.64$ (m), $N_x = 32$, $N_y = 32$, $N_p = 5000$, random seed $123$, particle charges sampled from a normal distribution with zero mean and standard deviation $2.0 \\times 10^{-19}$ (C).\n- Test $4$ (edge case, zero particles, CIC): $L_x = 1.0$ (m), $L_y = 1.0$ (m), $N_x = 16$, $N_y = 16$, $N_p = 0$, no randomization.\n- Test $5$ (broken partition, scaled CIC): $L_x = 1.0$ (m), $L_y = 1.0$ (m), $N_x = 32$, $N_y = 32$, $N_p = 1000$, random seed $99$ for positions, all particle charges set to $1.0 \\times 10^{-19}$ (C), and the CIC weights in each dimension multiplied by $\\alpha = 1.01$ before forming the separable two-dimensional weights.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]\"), where $r_m$ is the absolute discrepancy $|Q_{\\text{grid}} - Q_{\\text{part}}|$ in Coulombs (C) for Test $m$.",
            "solution": "The problem asks for an analytical proof of charge conservation in a Particle-In-Cell (PIC) charge deposition scheme and a numerical verification of this property.\n\n### Task A: Proof of Charge Conservation\n\nThe objective is to prove that the total charge deposited on the grid, $Q_{\\text{grid}}$, is identical to the total charge of the particles, $Q_{\\text{part}}$, under the given scheme.\n\nThe total particle charge is defined as the sum of all individual particle charges:\n$$\nQ_{\\text{part}} = \\sum_{i=1}^{N_p} q_i\n$$\n\nThe total charge on the grid is defined as the sum of the charge density at each grid node multiplied by the area element $h_x h_y$ corresponding to that node:\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y\n$$\n\nThe charge density $\\rho_{j,k}$ at grid node $(j,k)$ is given by the deposition rule:\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\nwhere $W(\\xi)$ is the one-dimensional shape function.\n\nWe begin the proof by substituting the definition of $\\rho_{j,k}$ into the expression for $Q_{\\text{grid}}$:\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\left[ \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right] h_x h_y\n$$\n\nThe area element $h_x h_y$ cancels out:\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\n\nSince all sums are finite, we can interchange the order of summation without altering the result. We move the summation over particles to the outside:\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right]\n$$\n\nThe two-dimensional shape function is separable, which allows us to factor the double summation over grid indices $(j,k)$ into a product of two independent one-dimensional summations:\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\left( \\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\right) \\left( \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right) \\right]\n$$\n\nNow, we must evaluate the sums in the parentheses. Let us focus on the sum over $j$. Let $\\xi_i = x_i/h_x$ be the normalized position of particle $i$. The sum is $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$. The problem states that the domain is periodic and that the shape function $W(\\xi)$ has compact support and satisfies the partition-of-unity property, $\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$ for any real $\\xi$.\n\nDue to the compact support of $W$, for any given $\\xi_i$, the term $W(\\xi_i - j)$ is non-zero only for a small, finite number of integer indices $j$ near $\\xi_i$. The periodicity of the grid implies that any contribution from a particle that would mathematically fall on a grid node index outside the range $[0, N_x-1]$ is wrapped back into this range. For instance, a contribution to node $j = N_x$ is mapped to node $0$, and a contribution to $j = -1$ is mapped to $N_x-1$. This \"aliasing\" effect means that the finite sum over the periodic grid, $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$, is exactly equivalent to the infinite sum over all integers, $\\sum_{n \\in \\mathbb{Z}} W(\\xi_i - n)$.\n\nTherefore, by the partition-of-unity property:\n$$\n\\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{x_i}{h_x} - n\\right) = 1\n$$\nBy the same reasoning for the $y$-dimension:\n$$\n\\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{y_i}{h_y} - n\\right) = 1\n$$\n\nSubstituting these results back into our expression for $Q_{\\text{grid}}$:\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ (1) \\cdot (1) \\right] = \\sum_{i=1}^{N_p} q_i\n$$\n\nThis final expression is precisely the definition of the total particle charge, $Q_{\\text{part}}$. Thus, we have proven that $Q_{\\text{grid}} = Q_{\\text{part}}$.\n\nThis property, known as global charge conservation, is a fundamental requirement for a stable PIC simulation. If total charge were not conserved by the discrete algorithm ($Q_{\\text{grid}} \\neq Q_{\\text{part}}$), it would imply that the numerical scheme itself is a source or sink of charge. According to Gauss's law for electricity, $\\nabla \\cdot \\mathbf{E} = \\rho / \\epsilon_0$, a net charge density acts as a source for the electric field. The artificial creation or destruction of charge would generate spurious, non-physical electric fields, which in turn would exert incorrect forces on the particles, leading to a rapid accumulation of error and numerical instability. This phenomenon is termed net-charge drift. The use of a shape function satisfying the partition-of-unity property guarantees that this drift does not occur at the level of charge deposition.\n\n### Task B: Numerical Verification and Algorithmic Design\n\nTo verify this principle numerically, we implement the charge deposition for various shape functions, which are based on B-splines. The one-dimensional shape function $W(\\xi)$ relates a particle's continuous position to weights on discrete grid nodes. The argument $\\xi$ is the normalized distance from the particle to a grid node. The 2D shape function is the product of two 1D functions: $S(x/h_x-j, y/h_y-k) = W(x/h_x-j) W(y/h_y-k)$.\n\nThe shapes used are:\n1.  **Nearest-Grid-Point (NGP, order-0 B-spline):** $W_0(\\xi) = 1$ for $|\\xi| \\le 0.5$ and $0$ otherwise. This is a rectangular or \"top-hat\" function. It has a support width of $1$ grid cell. A particle's entire charge is deposited onto the single nearest grid node.\n2.  **Cloud-In-Cell (CIC, order-1 B-spline):** $W_1(\\xi) = 1 - |\\xi|$ for $|\\xi| \\le 1$ and $0$ otherwise. This is a triangular function with a support width of $2$ grid cells. a 2D particle deposits its charge onto the $4$ grid nodes forming the cell that contains it.\n3.  **Triangular-Shaped Cloud (TSC, order-2 B-spline):** $W_2(\\xi)$ is a quadratic spline with a support of $3$ grid cells.\n    $$\n    W_2(\\xi) = \\begin{cases} \\frac{3}{4} - \\xi^2  \\text{if } |\\xi| \\le \\frac{1}{2} \\\\ \\frac{1}{2} (\\frac{3}{2} - |\\xi|)^2  \\text{if } \\frac{1}{2}  |\\xi| \\le \\frac{3}{2} \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    A 2D particle following this scheme deposits its charge onto a $3 \\times 3$ block of $9$ grid nodes.\n\nThe numerical algorithm proceeds as follows:\n1.  Initialize a 2D array `rho_grid` of size $(N_x, N_y)$ to all zeros.\n2.  For each particle $i$ with charge $q_i$ and position $(x_i, y_i)$:\n    a. Calculate its normalized position $(\\tilde{x}_i, \\tilde{y}_i) = (x_i/h_x, y_i/h_y)$.\n    b. Based on the chosen shape function (NGP, CIC, or TSC), identify the set of affected grid node indices in each dimension, $(j_1, j_2, ...)$ and $(k_1, k_2, ...)$. These indices must be wrapped periodically using the modulo operator (e.g., $j \\pmod{N_x}$).\n    c. For each affected index $j_m$, calculate the corresponding 1D weight $w_{x,m} = W(\\tilde{x}_i - j_m)$. Similarly, calculate weights $w_{y,n}$ for each affected index $k_n$.\n    d. For each pair of affected indices $(j_m, k_n)$, update the charge density on the grid:\n       $$\n       \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} \\gets \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} + \\frac{q_i}{h_x h_y} \\cdot w_{x,m} \\cdot w_{y,n}\n       $$\n3.  After iterating through all particles, calculate the total grid charge $Q_{\\text{grid}} = h_x h_y \\sum_{j,k} \\rho_{j,k}$.\n4.  Compute the discrepancy $|Q_{\\text{grid}} - Q_{\\text{part}}|$.\n\nFor Test 5, a \"broken\" scheme is used where the 1D weights derived from the CIC shape function are multiplied by a factor $\\alpha = 1.01$. This explicitly violates the partition-of-unity, as the sum of weights for a single particle will be $\\alpha^2$ instead of $1$. The implementation will demonstrate the resulting non-zero charge discrepancy, confirming the theoretical link between partition-of-unity and charge conservation. The numerical implementation performs these steps for the specified test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PIC charge deposition problem, including analytical proof and numerical verification.\n    \"\"\"\n    test_cases = [\n        # Test 1 (happy path, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 0.5, 'Nx': 64, 'Ny': 32, 'Np': 1000,\n         'seed': 42, 'charge_dist': ('normal', 0, 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 2 (boundary condition stress, NGP)\n        {'shape': 'NGP', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 4, 'Ny': 4, 'Np': 10,\n         'seed': 7, 'charge_dist': ('normal', 0, 5.0e-20),\n         'pos_dist': ('clustered', 1e-12), 'alpha': 1.0},\n        # Test 3 (higher-order shape, TSC)\n        {'shape': 'TSC', 'Lx': 0.64, 'Ly': 0.64, 'Nx': 32, 'Ny': 32, 'Np': 5000,\n         'seed': 123, 'charge_dist': ('normal', 0, 2.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 4 (edge case, zero particles, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16, 'Np': 0,\n         'seed': None, 'charge_dist': None, 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 5 (broken partition, scaled CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 32, 'Ny': 32, 'Np': 1000,\n         'seed': 99, 'charge_dist': ('fixed', 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.01}\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Unpack parameters\n        shape = params['shape']\n        Lx, Ly = params['Lx'], params['Ly']\n        Nx, Ny = params['Nx'], params['Ny']\n        Np = params['Np']\n        seed = params['seed']\n        charge_dist = params['charge_dist']\n        pos_dist = params['pos_dist']\n        alpha = params['alpha']\n\n        hx, hy = Lx / Nx, Ly / Ny\n        \n        # Handle zero particle case\n        if Np == 0:\n            results.append(0.0)\n            continue\n\n        rng = np.random.default_rng(seed)\n\n        # Generate particle charges\n        if charge_dist[0] == 'normal':\n            mean, std_dev = charge_dist[1], charge_dist[2]\n            charges = rng.normal(mean, std_dev, Np)\n        elif charge_dist[0] == 'fixed':\n            charges = np.full(Np, charge_dist[1], dtype=np.float64)\n        \n        q_total_particles = np.sum(charges)\n\n        # Generate particle positions\n        if pos_dist == 'uniform':\n            positions = rng.uniform(low=[0.0, 0.0], high=[Lx, Ly], size=(Np, 2))\n        elif pos_dist[0] == 'clustered':\n            epsilon = pos_dist[1]\n            # In Test 2, use the same seed for reproducibility of positions\n            pos_rng = np.random.default_rng(seed) if shape == 'NGP' else rng\n            positions = pos_rng.uniform(low=[Lx - 2 * epsilon, Ly - 2 * epsilon],\n                                        high=[Lx - epsilon, Ly - epsilon],\n                                        size=(Np, 2))\n\n        # Initialize charge density grid\n        rho_grid = np.zeros((Nx, Ny), dtype=np.float64)\n\n        # Deposit charges\n        for i in range(Np):\n            q_i = charges[i]\n            x_i, y_i = positions[i]\n            \n            x_norm = x_i / hx\n            y_norm = y_i / hy\n            \n            # 1D weights and indices calculation\n            if shape == 'NGP':\n                # x-dimension\n                jx = int(np.floor(x_norm + 0.5))\n                wx = [1.0]\n                jx_indices = [jx]\n                \n                # y-dimension\n                ky = int(np.floor(y_norm + 0.5))\n                wy = [1.0]\n                ky_indices = [ky]\n\n            elif shape == 'CIC':\n                # x-dimension\n                jx0 = int(np.floor(x_norm))\n                dx = x_norm - jx0\n                wx = [alpha * (1.0 - dx), alpha * dx]\n                jx_indices = [jx0, jx0 + 1]\n\n                # y-dimension\n                ky0 = int(np.floor(y_norm))\n                dy = y_norm - ky0\n                wy = [alpha * (1.0 - dy), alpha * dy]\n                ky_indices = [ky0, ky0 + 1]\n                \n            elif shape == 'TSC':\n                # x-dimension\n                jxc = int(np.floor(x_norm + 0.5))\n                dx = x_norm - jxc\n                wx = [0.5 * (0.5 - dx)**2, 0.75 - dx**2, 0.5 * (0.5 + dx)**2]\n                jx_indices = [jxc - 1, jxc, jxc + 1]\n\n                # y-dimension\n                kyc = int(np.floor(y_norm + 0.5))\n                dy = y_norm - kyc\n                wy = [0.5 * (0.5 - dy)**2, 0.75 - dy**2, 0.5 * (0.5 + dy)**2]\n                ky_indices = [kyc - 1, kyc, kyc + 1]\n\n            # 2D deposition with periodic boundary conditions\n            for idx_x, j in enumerate(jx_indices):\n                for idx_y, k in enumerate(ky_indices):\n                    # Using scatter-add logic here\n                    # Indices must be wrapped\n                    j_wrapped = j % Nx\n                    k_wrapped = k % Ny\n                    weight_2d = wx[idx_x] * wy[idx_y]\n                    rho_grid[j_wrapped, k_wrapped] += q_i * weight_2d\n\n        # Correct units for rho_grid\n        rho_grid /= (hx * hy)\n        \n        # Calculate total grid charge\n        q_total_grid = np.sum(rho_grid) * hx * hy\n        \n        discrepancy = np.abs(q_total_grid - q_total_particles)\n        results.append(discrepancy)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "While charge conservation can be satisfied exactly, momentum conservation in a standard PIC scheme is a more subtle issue. The grid-mediated interaction between particles breaks the continuous translational symmetry of the underlying physics, leading to a small violation of Newton's third law. This practice allows you to quantify this effect and numerically demonstrate how using smoother, higher-order shape functions systematically improves momentum conservation, highlighting a key trade-off between computational complexity and physical fidelity .",
            "id": "4183324",
            "problem": "In a one-dimensional, electrostatic, periodic domain, two particles interact via a mesh-based field solver as in a Particle-In-Cell (PIC) method. The goal is to quantify the spurious total momentum error induced by the charge assignment and force interpolation between particles and the grid when using different particle shape orders, and to demonstrate the reduction of this momentum error with increasing shape order. Work in dimensionless units: domain length $L=1$, vacuum permittivity $\\epsilon_0=1$, and particle charges $q_1=+1$, $q_2=-1$. No physical unit conversion is required.\n\nFundamental basis and definitions:\n- The electrostatic field satisfies the Poisson equation in one spatial dimension, $\\partial_x E(x) = \\rho(x)/\\varepsilon_0$ and $E(x) = -\\partial_x \\phi(x)$, with periodic boundary conditions on $[0,L)$.\n- The discrete mesh consists of $N_g$ uniformly spaced grid nodes at positions $x_j = j \\Delta x$ for integers $j \\in \\{0,1,\\dots,N_g-1\\}$, with $\\Delta x = L/N_g$.\n- The mesh-based field solver constructs a grid charge density $\\rho_j$ by assigning the particle charges to nearby nodes using a particle shape function of order $m \\in \\{0,1,2,3\\}$, and solves the Poisson equation in Fourier space to obtain the grid electric field $E_j$. The field at a particle position is then obtained by interpolating $E_j$ back to the particle using the same order-$m$ shape function.\n\nRequirements for the computational method:\n- Use a standard uniform discrete Fourier transform to solve the Poisson equation spectrally with periodic boundary conditions. In Fourier space, enforce zero mean potential by setting the zero wavenumber mode to zero. Compute the electric field by spectral differentiation.\n- Use the same particle shape order $m$ for both charge assignment (particle-to-grid) and force interpolation (grid-to-particle). The considered orders are $m=0$ (nearest-grid-point), $m=1$ (cloud-in-cell), $m=2$ (triangular-shaped-cloud), and $m=3$ (piecewise-cubic-spline). Each is a compactly supported, normalized one-dimensional shape with support over $m+1$ grid cells.\n- Implement periodic boundary conditions for both deposition and interpolation.\n\nDefinition of the diagnostic:\n- Let $F_i = q_i E(x_i)$ be the force on particle $i \\in \\{1,2\\}$ from the interpolated electric field at its position $x_i$. In the continuous, exact two-body electrostatic interaction in a periodic domain with zero net charge, Newtonâ€™s third law implies that the total internal force $\\sum_i F_i$ is exactly zero for all times, and thus the total momentum is conserved.\n- Define the dimensionless spurious momentum error for a single configuration as\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta},\n$$\nwhere $\\delta$ is a small positive regularization constant to avoid division by zero in pathological cases, for example $\\delta = 10^{-16}$.\n\nTask:\n- For each specified test case, compute the dimensionless spurious momentum error $\\varepsilon_m$ using the above method.\n- All computations must be carried out in dimensionless units as specified.\n\nTest suite:\nCompute $\\varepsilon_m$ for the following six test cases. Each test case is a tuple $(N_g, m, x_1, x_2)$ with $L=1$, $q_1=+1$, $q_2=-1$, and positions in the periodic interval $[0,1)$.\n1. $(N_g=\\;32, m=\\;0, x_1=\\;0.23, x_2=\\;0.77)$\n2. $(N_g=\\;32, m=\\;1, x_1=\\;0.23, x_2=\\;0.77)$\n3. $(N_g=\\;32, m=\\;2, x_1=\\;0.23, x_2=\\;0.77)$\n4. $(N_g=\\;32, m=\\;3, x_1=\\;0.23, x_2=\\;0.77)$\n5. $(N_g=\\;32, m=\\;3, x_1=\\;0.98, x_2=\\;0.12)$\n6. $(N_g=\\;64, m=\\;3, x_1=\\;0.401, x_2=\\;0.409)$\n\nExpected behavior to be revealed by the results:\n- For fixed mesh resolution $N_g=\\;32$ and fixed particle positions $(x_1,x_2)=(0.23,0.77)$, the sequence of errors for $m=\\;0,1,2,3$ should show a decreasing trend, indicating improved discrete momentum conservation with higher-order shapes.\n- The configuration with particles near the periodic boundary $(x_1=\\;0.98, x_2=\\;0.12)$ should also yield a small error for higher-order shapes if periodic wrapping in deposition and interpolation is implemented correctly.\n- The close-pair configuration at $N_g=\\;64$ and $m=\\;3$ should test the robustness when $|x_2-x_1|$ is small.\n\nFinal output format:\n- Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, for example\n$[r_1,r_2,r_3,r_4,r_5,r_6]$,\nwhere each $r_k$ is the floating-point value of $\\varepsilon_m$ for the $k$-th test case, in dimensionless units.",
            "solution": "The problem requires computing the spurious total momentum error in a one-dimensional electrostatic Particle-In-Cell (PIC) simulation with two particles. This error arises because the granular nature of the computational mesh breaks the continuous translational symmetry of the physical laws. In a continuous system, the interaction force between two particles, $\\mathbf{F}_{12}$, is equal and opposite to the force $\\mathbf{F}_{21}$, i.e., $\\mathbf{F}_{12} + \\mathbf{F}_{21} = \\mathbf{0}$, which is Newton's third law. This guarantees conservation of the total momentum of the two-particle system.\n\nIn a PIC simulation, particles do not interact directly. Instead, they interact via a grid-discretized field. The process involves three steps:\n1.  **Charge Deposition**: Each particle's charge is \"smeared\" onto a few nearby grid nodes.\n2.  **Field Solve**: The electrostatic field is calculated on the grid nodes from the deposited charge density.\n3.  **Force Interpolation**: The field is interpolated from the grid nodes back to the particle positions to calculate the force.\n\nThis grid-mediated interaction does not, in general, satisfy Newton's third law for the particles. The force on particle 1, $F_1$, is derived from the field created by particle 2's charge as it is represented on the grid, and vice versa. Due to the discretization, the force $F_1$ is not exactly equal and opposite to $F_2$, leading to a non-zero total force $F_1 + F_2 \\neq 0$ and a violation of momentum conservation. The magnitude of this violation, quantified by the error metric $\\varepsilon_m$, depends critically on the smoothness of the functions used for charge deposition and force interpolation. These functions are known as particle shape functions.\n\nHigher-order shape functions provide a smoother representation of the particle on the grid, reducing the unphysical dependencies of the force on the particle's position relative to the grid nodes. This leads to better conservation properties. The problem requires a demonstration of this principle by computing $\\varepsilon_m$ for shape functions of increasing order $m \\in \\{0, 1, 2, 3\\}$.\n\nThe computational procedure to calculate the error $\\varepsilon_m$ for a given test case $(N_g, m, x_1, x_2)$ is as follows:\n\n**1. System Setup**\nThe simulation domain is of length $L=1$ with periodic boundary conditions. The grid consists of $N_g$ nodes at positions $x_j = j \\Delta x$ for $j \\in \\{0, 1, \\dots, N_g-1\\}$, where the grid spacing is $\\Delta x = L/N_g = 1/N_g$. Two particles are present with charges $q_1=+1$ and $q_2=-1$ at positions $x_1$ and $x_2$, respectively. The vacuum permittivity is $\\varepsilon_0=1$.\n\n**2. Particle Shape Functions**\nThe interaction between particles and the grid is mediated by a basis spline (B-spline) shape function of order $m$, denoted as $S_m(u)$, where $u=(x_p - x_j)/\\Delta x$ is the normalized distance. We implement the B-splines for shape orders $m=0, 1, 2, 3$:\n-   Order $m=0$ (NGP): $S_0(u) = 1$ for $|u| \\le 1/2$ and $0$ otherwise.\n-   Order $m=1$ (CIC): $S_1(u) = 1 - |u|$ for $|u| \\le 1$ and $0$ otherwise.\n-   Order $m=2$ (TSC):\n    $$ S_2(u) = \\begin{cases} \\frac{3}{4} - u^2  \\text{if } |u| \\le \\frac{1}{2} \\\\ \\frac{1}{2}\\left(\\frac{3}{2} - |u|\\right)^2  \\text{if } \\frac{1}{2}  |u| \\le \\frac{3}{2} \\\\ 0  \\text{if } |u| > \\frac{3}{2} \\end{cases} $$\n-   Order $m=3$ (PCS):\n    $$ S_3(u) = \\begin{cases} \\frac{1}{6}(4 - 6u^2 + 3|u|^3)  \\text{if } |u| \\le 1 \\\\ \\frac{1}{6}(2 - |u|)^3  \\text{if } 1  |u| \\le 2 \\\\ 0  \\text{if } |u| > 2 \\end{cases} $$\n\n**3. Charge Deposition**\nA grid array for charge density, $\\rho_j$, is initialized to zero. For each particle $p \\in \\{1, 2\\}$ with charge $q_p$ at position $x_p$, we deposit its charge onto the grid.\nFirst, we find all grid nodes $j$ that are within the support of the shape function centered at $x_p$. For each such node, we compute a weight $W_{p,j} = S_m((x_p/\\Delta x) - j)$. The charge density at node $j$ is updated by adding the particle's contribution: $\\rho_j \\leftarrow \\rho_j + q_p W_{p,j} / \\Delta x$. The division by cell volume $\\Delta x$ correctly scales the deposited charge to a charge density. The node indices $j$ are handled periodically, i.e., computed modulo $N_g$.\n\n**4. Spectral Field Solve**\nThe Poisson equation in one dimension is $\\partial_x E = \\rho(x)/\\varepsilon_0$. We solve this equation on the grid using the Discrete Fourier Transform (DFT).\n-   First, we compute the DFT of the grid charge density: $\\hat{\\rho}_k = \\mathcal{F}\\{\\rho_j\\}$.\n-   In Fourier space, the spatial derivative $\\partial_x$ becomes multiplication by $i k$, where $k$ is the wavenumber. The equation becomes $i k \\hat{E}_k = \\hat{\\rho}_k/\\varepsilon_0$.\n-   The wavenumbers corresponding to the DFT are given by $k_n = 2\\pi n / L$ for $n \\in \\{-N_g/2, \\dots, N_g/2-1\\}$.\n-   The grid electric field in Fourier space is then $\\hat{E}_k = \\frac{\\hat{\\rho}_k}{i k \\varepsilon_0} = -i \\frac{\\hat{\\rho}_k}{k \\varepsilon_0}$ for $k \\ne 0$.\n-   For the $k=0$ mode (DC component), the net charge $\\sum q_p=0$ ensures that $\\hat{\\rho}_{k=0}=0$. The expression for $\\hat{E}_{k=0}$ is indeterminate. We set $\\hat{E}_{k=0}=0$, which corresponds to zero average electric field, consistent with periodic boundary conditions and zero net charge. This also enforces the zero mean potential condition.\n-   Finally, the electric field on the grid, $E_j$, is obtained by computing the inverse DFT of $\\hat{E}_k$: $E_j = \\mathcal{F}^{-1}\\{\\hat{E}_k\\}$.\n\n**5. Force Interpolation**\nThe electric field at each particle's position, $E(x_p)$, is found by interpolating the grid electric field $E_j$ using the same shape function $S_m$. The interpolated field is a weighted sum: $E(x_p) = \\sum_j E_j W_{p,j}$, where the weights $W_{p,j}$ are identical to those used in the charge deposition step for particle $p$. This symmetry between deposition and interpolation is crucial for momentum-conserving properties. The force on each particle is then $F_p = q_p E(x_p)$.\n\n**6. Error Calculation**\nWith the forces $F_1$ and $F_2$ computed, the dimensionless spurious momentum error is calculated using the provided formula:\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta}\n$$\nwith the regularization constant $\\delta=10^{-16}$. This procedure is repeated for each of the six test cases.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef b_spline(u_abs, m):\n    \"\"\"\n    Computes the value of the B-spline of order m+1 (degree m) at a given\n    absolute normalized distance u_abs = |u|.\n    These are the standard PIC particle shape functions Sm.\n    \"\"\"\n    if m == 0:  # NGP, B-spline order 1\n        return 1.0 if u_abs  0.5 else 0.0\n    elif m == 1:  # CIC, B-spline order 2\n        return 1.0 - u_abs if u_abs  1.0 else 0.0\n    elif m == 2:  # TSC, B-spline order 3\n        if u_abs = 0.5:\n            return 0.75 - u_abs**2\n        elif u_abs = 1.5:\n            return 0.5 * (1.5 - u_abs)**2\n        else:\n            return 0.0\n    elif m == 3:  # PCS, B-spline order 4\n        if u_abs = 1.0:\n            return (1.0/6.0) * (4.0 - 6.0*u_abs**2 + 3.0*u_abs**3)\n        elif u_abs = 2.0:\n            return (1.0/6.0) * (2.0 - u_abs)**3\n        else:\n            return 0.0\n    else:\n        raise ValueError(\"Shape order m must be 0, 1, 2, or 3.\")\n\ndef get_weights(x_p, m, Ng, dx):\n    \"\"\"\n    Calculates the weights and indices for depositing charge or interpolating fields.\n    \"\"\"\n    u_p = x_p / dx\n    support_half_width = (m + 1) / 2.0\n    \n    j_min = int(np.ceil(u_p - support_half_width))\n    j_max = int(np.floor(u_p + support_half_width))\n    \n    indices = []\n    weights = []\n    \n    for j in range(j_min, j_max + 1):\n        u_abs = abs(u_p - j)\n        weight = b_spline(u_abs, m)\n        if weight > 0:\n            indices.append(j % Ng)\n            weights.append(weight)\n            \n    return np.array(indices), np.array(weights)\n\ndef calculate_error(Ng, m, x1, x2):\n    \"\"\"\n    Performs the PIC-style calculation to find the momentum conservation error.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    q1, q2 = 1.0, -1.0\n    epsilon_0 = 1.0\n    delta = 1e-16\n    dx = L / Ng\n\n    # 1. Charge Deposition (Particle-To-Grid)\n    rho_grid = np.zeros(Ng)\n    particles = [(q1, x1), (q2, x2)]\n    \n    # Store weights for later use in interpolation\n    p1_indices, p1_weights = get_weights(particles[0][1], m, Ng, dx)\n    p2_indices, p2_weights = get_weights(particles[1][1], m, Ng, dx)\n\n    # Deposit charge for particle 1\n    rho_grid[p1_indices] += particles[0][0] * p1_weights / dx\n    \n    # Deposit charge for particle 2\n    rho_grid[p2_indices] += particles[1][0] * p2_weights / dx\n\n    # 2. Field Solve (Grid)\n    # DFT of charge density\n    rho_hat = np.fft.fft(rho_grid)\n    \n    # Wavenumbers\n    k = 2 * np.pi * np.fft.fftfreq(Ng, d=dx)\n    \n    # Solve for E-field in Fourier space: E_hat = -i * rho_hat / (epsilon_0 * k)\n    E_hat = np.zeros_like(rho_hat, dtype=complex)\n    nonzero_k_mask = k != 0\n    E_hat[nonzero_k_mask] = -1j * rho_hat[nonzero_k_mask] / (epsilon_0 * k[nonzero_k_mask])\n    \n    # Inverse DFT to get E-field on grid\n    E_grid = np.real(np.fft.ifft(E_hat))\n\n    # 3. Force Interpolation (Grid-To-Particle)\n    # Interpolate E-field at particle 1 and calculate force\n    E1 = np.sum(E_grid[p1_indices] * p1_weights)\n    F1 = q1 * E1\n    \n    # Interpolate E-field at particle 2 and calculate force\n    E2 = np.sum(E_grid[p2_indices] * p2_weights)\n    F2 = q2 * E2\n\n    # 4. Calculate Spurious Momentum Error\n    error = np.abs(F1 + F2) / (np.abs(F1) + np.abs(F2) + delta)\n    \n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 0, 0.23, 0.77),\n        (32, 1, 0.23, 0.77),\n        (32, 2, 0.23, 0.77),\n        (32, 3, 0.23, 0.77),\n        (32, 3, 0.98, 0.12),\n        (64, 3, 0.401, 0.409),\n    ]\n\n    results = []\n    for case in test_cases:\n        Ng, m, x1, x2 = case\n        result = calculate_error(Ng, m, x1, x2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}