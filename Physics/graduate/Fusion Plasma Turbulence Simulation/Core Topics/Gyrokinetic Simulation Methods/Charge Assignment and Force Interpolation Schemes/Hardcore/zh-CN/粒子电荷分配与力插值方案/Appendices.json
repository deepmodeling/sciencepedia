{
    "hands_on_practices": [
        {
            "introduction": "在粒子-网格（PIC）模拟中，最基本的操作之一是将粒子所代表的连续电荷分布转化为网格上的离散电荷密度。这个过程被称为电荷分配。本练习将指导您从第一性原理出发，推导电荷分配的一般形式，揭示其与“形函数”之间的深刻联系，并以常用的云中单元（CIC）格式为例进行具体计算 。",
            "id": "4183274",
            "problem": "在一种用于聚变等离子体湍流模拟的先进粒子-网格（PIC）离散化方法中，微观电荷密度由狄拉克$\\delta$分布的和表示，即$ \\rho(\\mathbf{x}) = \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p}) $，其中$ q_{p} $和$ \\mathbf{x}_{p} $分别是粒子$ p $的电荷和位置。在一个二维空间中，对于间距为$ \\Delta x $和$ \\Delta y $的均匀笛卡尔网格，与位于$ \\mathbf{x}_{g} $的网格节点相关联的节点电荷密度$ \\rho_{g} $的定义为：将$ \\rho(\\mathbf{x}) $投影到平移不变的节点基$ N_{g}(\\mathbf{x}) = N(\\mathbf{x} - \\mathbf{x}_{g}) $上，然后进行质量集中归一化：$ \\rho_{g} := A^{-1} \\int_{\\Omega} \\rho(\\mathbf{x}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x} $，其中$ A := \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x} $。仅使用上述定义以及狄拉克$\\delta$分布的性质和$ N_{g} $的平移不变性，推导出$ \\rho_{g} $的函数形式，该形式应以一个作用于节点-粒子偏移量上的形函数表示。\n\n然后，将问题具体化到云中单元（CIC）方法所选择的$ N(\\mathbf{x}) $，它由满足电荷守恒的一维线性帽函数的张量积构成。设一维参考帽函数定义为$ N_{1\\mathrm{D}}(x) = \\max\\{0,\\,1 - |x|/\\Delta x\\} $，$ y $方向同理，因此$ N(\\mathbf{x}) = N_{1\\mathrm{D}}(x) \\, N_{1\\mathrm{D}}(y) $。考虑一个电荷为$ q_{p} $的单个粒子，它位于左下角节点为$ (x_{i}, y_{j}) $的网格单元内，其位置为$ x_{p} = x_{i} + a \\,\\Delta x $和$ y_{p} = y_{j} + b \\,\\Delta y $，其中$ 0 \\leq a \\leq 1 $且$ 0 \\leq b \\leq 1 $。在CIC方法下，计算该粒子对节点$ (i,j) $的离散节点电荷密度$ \\rho_{i,j} $的贡献。\n\n将最终答案表示为关于$ q_{p} $、$ \\Delta x $、$ \\Delta y $、$ a $和$ b $的单个闭式解析表达式。以库仑/平方米为单位陈述最终结果。",
            "solution": "我们从电荷的微观表示开始，$ \\rho(\\mathbf{x}) = \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p}) $，这是连续空间中点电荷的标准模型。离散节点值$ \\rho_{g} $是通过将该场投影到节点基$ N_{g}(\\mathbf{x}) = N(\\mathbf{x} - \\mathbf{x}_{g}) $上，并通过基函数的积分进行归一化以产生密度来定义的：\n$$\n\\rho_{g} := A^{-1} \\int_{\\Omega} \\rho(\\mathbf{x}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}, \\quad A := \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x}.\n$$\n将微观形式代入投影中得到\n$$\n\\rho_{g} = A^{-1} \\int_{\\Omega} \\left( \\sum_{p} q_{p} \\,\\delta(\\mathbf{x} - \\mathbf{x}_{p}) \\right) N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}.\n$$\n根据积分和求和的线性性质，以及狄拉克δ分布的筛选性质，我们得到\n$$\n\\rho_{g} = A^{-1} \\sum_{p} q_{p} \\int_{\\Omega} \\delta(\\mathbf{x} - \\mathbf{x}_{p}) \\, N_{g}(\\mathbf{x}) \\, d^{2}\\mathbf{x}\n= A^{-1} \\sum_{p} q_{p} \\, N_{g}(\\mathbf{x}_{p}).\n$$\n利用节点基的平移不变性$ N_{g}(\\mathbf{x}_{p}) = N(\\mathbf{x}_{p} - \\mathbf{x}_{g}) $，我们可以写出\n$$\n\\rho_{g} = \\sum_{p} q_{p} \\, S(\\mathbf{x}_{g} - \\mathbf{x}_{p}),\n$$\n其中形函数$ S(\\mathbf{u}) $定义为$ S(\\mathbf{u}) := A^{-1} N(-\\mathbf{u}) $。对于偶函数形式的形函数$ N(\\mathbf{x}) $，例如云中单元（CIC）方法所选择的函数，$ N(-\\mathbf{u}) = N(\\mathbf{u}) $，因此$ S(\\mathbf{u}) = A^{-1} N(\\mathbf{u}) $。这种构造产生了一种自洽的电荷分配方案，其中相同的形函数也出现在相互作用力插值中，当使用相同的$ S $将场插值回粒子时，可以确保动量守恒。\n\n现在我们具体研究二维云中单元（CIC）的节点基。一维线性帽函数为\n$$\nN_{1\\mathrm{D}}(x) = \\max\\{0,\\, 1 - |x|/\\Delta x \\},\n$$\n而二维节点基是其张量积\n$$\nN(\\mathbf{x}) = N_{1\\mathrm{D}}(x) \\, N_{1\\mathrm{D}}(y).\n$$\n$ N $在其支撑集上的积分是一维积分的乘积。在一维情况下，\n$$\n\\int_{-\\Delta x}^{\\Delta x} N_{1\\mathrm{D}}(x) \\, dx = \\int_{-\\Delta x}^{\\Delta x} \\left( 1 - \\frac{|x|}{\\Delta x} \\right) dx = \\Delta x.\n$$\n类似地，在$ y $方向，\n$$\n\\int_{-\\Delta y}^{\\Delta y} N_{1\\mathrm{D}}(y) \\, dy = \\Delta y.\n$$\n因此，\n$$\nA = \\int_{\\Omega} N(\\mathbf{x}) \\, d^{2}\\mathbf{x} = \\left( \\int N_{1\\mathrm{D}}(x) \\, dx \\right) \\left( \\int N_{1\\mathrm{D}}(y) \\, dy \\right) = \\Delta x \\, \\Delta y.\n$$\n所以，CIC形函数为\n$$\nS(\\mathbf{u}) = \\frac{1}{\\Delta x \\, \\Delta y} \\, N(\\mathbf{u}) = \\frac{1}{\\Delta x \\, \\Delta y} \\, N_{1\\mathrm{D}}(u_{x}) \\, N_{1\\mathrm{D}}(u_{y}).\n$$\n\n现在考虑一个电荷为$ q_{p} $的单个粒子，位于左下角节点为$ (x_{i}, y_{j}) $的网格单元内，其位置为$ x_{p} = x_{i} + a \\,\\Delta x $，$ y_{p} = y_{j} + b \\,\\Delta y $，其中$ 0 \\leq a \\leq 1 $且$ 0 \\leq b \\leq 1 $。我们要求解左下角节点的节点电荷密度，即$ \\rho_{i,j} $，根据分配规则，它等于\n$$\n\\rho_{i,j} = q_{p} \\, S(\\mathbf{x}_{i,j} - \\mathbf{x}_{p}) = q_{p} \\, \\frac{1}{\\Delta x \\, \\Delta y} \\, N_{1\\mathrm{D}}(x_{i} - x_{p}) \\, N_{1\\mathrm{D}}(y_{j} - y_{p}).\n$$\n因为$ x_{i} - x_{p} = - a \\,\\Delta x $且$ y_{j} - y_{p} = - b \\,\\Delta y $，并且$ N_{1\\mathrm{D}} $取决于绝对值，\n$$\nN_{1\\mathrm{D}}(x_{i} - x_{p}) = 1 - \\frac{|x_{i} - x_{p}|}{\\Delta x} = 1 - \\frac{a \\,\\Delta x}{\\Delta x} = 1 - a,\n$$\n$$\nN_{1\\mathrm{D}}(y_{j} - y_{p}) = 1 - \\frac{|y_{j} - y_{p}|}{\\Delta y} = 1 - \\frac{b \\,\\Delta y}{\\Delta y} = 1 - b.\n$$\n将这些结果代入$ \\rho_{i,j} $的表达式中，得到\n$$\n\\rho_{i,j} = q_{p} \\, \\frac{1}{\\Delta x \\, \\Delta y} \\, (1 - a) \\, (1 - b).\n$$\n这是一个关于$ q_{p} $、$ \\Delta x $、$ \\Delta y $、$ a $和$ b $的闭式解析表达式，单位为库仑/平方米，符合题目要求。值得注意的是，该网格单元的其他三个节点接收的权重分别为$ a(1 - b)/(\\Delta x \\Delta y) $、$ (1 - a)b/(\\Delta x \\Delta y) $和$ ab/(\\Delta x \\Delta y) $，它们与$ (1 - a)(1 - b)/(\\Delta x \\Delta y) $一起求和得到$ 1/(\\Delta x \\Delta y) $，这确保了分配到节点的电荷总量聚合为该粒子在网格单元面积上的电荷密度分布。",
            "answer": "$$\\boxed{\\frac{q_{p}}{\\Delta x \\,\\Delta y}\\,(1 - a)\\,(1 - b)}$$"
        },
        {
            "introduction": "一个可靠的数值方案必须遵守其所模拟的物理系统的基本守恒律。对于静电系统而言，总电荷守恒是至关重要的。本练习旨在证明并数值验证，只要形函数满足“单位分解”（partition of unity）性质，电荷分配过程就能精确地保持总电荷守恒，从而避免非物理的电荷漂移 。",
            "id": "4183292",
            "problem": "考虑一个用于聚变等离子体湍流模拟的粒子-网格法 (PIC) 中的均匀、周期性笛卡尔网格。设空间域为二维，长度为 $L_x$ 和 $L_y$，并分别离散化为 $N_x$ 和 $N_y$ 个等距节点。网格间距为 $h_x = L_x / N_x$ 和 $h_y = L_y / N_y$。现有一组包含 $N_p$ 个点粒子的集合，其电荷为 $\\{q_i\\}_{i=1}^{N_p}$，位置为 $\\{\\mathbf{x}_i\\}_{i=1}^{N_p}$，其中 $\\mathbf{x}_i = (x_i,y_i)$。这些粒子将被作为电荷密度场 $\\rho_{j,k}$ 分配到节点索引为 $(j,k)$ 的网格上。\n\nPIC 电荷分配使用一个具有紧支集和精确单位分解性质的维度可分离形函数 $W(\\xi)$。该性质由以下要求定义：对于任意实数 $\\xi$，对整数的无穷求和满足 $\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$。二维形状是在无量纲坐标上求值的乘积 $S(\\mathbf{x}) = W(x/h_x) W(y/h_y)$。电荷分配规则为\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right),\n$$\n此处采用周期性边界条件，因此所有节点索引都按模 $N_x$ 和 $N_y$ 解释。电荷的物理单位是库仑 (C)，电荷密度的单位是库仑每平方米 (C/m$^2$)。\n\n任务 A (证明)：从电荷守恒的积分形式和上述离散分配定义出发，从第一性原理推导，在 $W(\\xi)$ 满足精确单位分解性质且周期性环绕被正确实现的前提下，每个时间步分配到网格上的总电荷，\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y,\n$$\n精确等于总粒子电荷 $Q_{\\text{part}} = \\sum_{i=1}^{N_p} q_i$。解释为什么这能防止离散系统中的净电荷漂移。\n\n任务 B (数值验证)：实现实践中使用的、满足精确单位分解性质并具有紧支集的一维形函数：\n- 最近网格点法 (NGP)，也称为 0 阶 B 样条。\n- 云中单元法 (CIC)，也称为 1 阶 B 样条。\n- 三角形成形云法 (TSC)，也称为具有三点支集的 2 阶 B 样条。\n\n使用这些函数构建二维可分离形函数 $S(\\mathbf{x})$，并对随机粒子集进行数值验证，证明 $Q_{\\text{grid}} - Q_{\\text{part}}$ 在机器精度内为零。此外，通过将所有一维权重乘以一个常数因子 $\\alpha \\neq 1$（从而违反单位分解性质）来构建一个故意破坏的 CIC 形函数变体，并经验性地展示由此产生的净电荷漂移。\n\n所有计算必须使用国际单位制 (SI)。以库仑 (C) 为单位报告数值差异。不使用角度。您的程序必须生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表。每个元素必须是代表 $|Q_{\\text{grid}} - Q_{\\text{part}}|$ 绝对值的浮点数，单位为库仑 (C)。\n\n使用以下测试套件以确保覆盖率和可复现性。对于每个测试，除非另有规定，粒子位置在域内均匀采样，随机数使用给定的种子：\n\n- 测试 1 (正常路径，CIC)：$L_x = 1.0$ (m)，$L_y = 0.5$ (m)，$N_x = 64$，$N_y = 32$，$N_p = 1000$，随机种子 $42$，粒子电荷从均值为零、标准差为 $1.0 \\times 10^{-19}$ (C) 的正态分布中采样。\n- 测试 2 (边界条件压力测试，NGP)：$L_x = 1.0$ (m)，$L_y = 1.0$ (m)，$N_x = 4$，$N_y = 4$，$N_p = 10$，固定位置，聚集在右上边界 $(x_i,y_i) \\approx (L_x - \\varepsilon, L_y - \\varepsilon)$ 附近，其中 $\\varepsilon = 10^{-12}$ (m)，随机种子为 $7$，电荷从均值为零、标准差为 $5.0 \\times 10^{-20}$ (C) 的正态分布中采样。\n- 测试 3 (高阶形函数，TSC)：$L_x = 0.64$ (m)，$L_y = 0.64$ (m)，$N_x = 32$，$N_y = 32$，$N_p = 5000$，随机种子 $123$，粒子电荷从均值为零、标准差为 $2.0 \\times 10^{-19}$ (C) 的正态分布中采样。\n- 测试 4 (边缘情况，零粒子，CIC)：$L_x = 1.0$ (m)，$L_y = 1.0$ (m)，$N_x = 16$，$N_y = 16$，$N_p = 0$，无随机化。\n- 测试 5 (破坏的单位分解，缩放的 CIC)：$L_x = 1.0$ (m)，$L_y = 1.0$ (m)，$N_x = 32$，$N_y = 32$，$N_p = 1000$，位置的随机种子为 $99$，所有粒子电荷均设置为 $1.0 \\times 10^{-19}$ (C)，并且在形成可分离的二维权重之前，每个维度上的 CIC 权重乘以 $\\alpha = 1.01$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表（例如，\"[$r_1$,$r_2$,$r_3$,$r_4$,$r_5$]\"），其中 $r_m$ 是测试 $m$ 的绝对差异 $|Q_{\\text{grid}} - Q_{\\text{part}}|$，单位为库仑 (C)。",
            "solution": "该问题要求对粒子-网格法 (PIC) 电荷分配方案中的电荷守恒进行解析证明，并对此性质进行数值验证。\n\n### 任务 A：电荷守恒证明\n\n目标是证明在给定方案下，分配到网格上的总电荷 $Q_{\\text{grid}}$ 与粒子的总电荷 $Q_{\\text{part}}$ 完全相同。\n\n总粒子电荷定义为所有单个粒子电荷的总和：\n$$\nQ_{\\text{part}} = \\sum_{i=1}^{N_p} q_i\n$$\n\n网格上的总电荷定义为每个网格节点上的电荷密度乘以该节点对应的面积元 $h_x h_y$ 后的总和：\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\rho_{j,k} \\, h_x h_y\n$$\n\n网格节点 $(j,k)$ 上的电荷密度 $\\rho_{j,k}$ 由分配规则给出：\n$$\n\\rho_{j,k} = \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\n其中 $W(\\xi)$ 是一维形函数。\n\n我们通过将 $\\rho_{j,k}$ 的定义代入 $Q_{\\text{grid}}$ 的表达式来开始证明：\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\left[ \\frac{1}{h_x h_y} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right] h_x h_y\n$$\n\n面积元 $h_x h_y$ 被消去：\n$$\nQ_{\\text{grid}} = \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} \\sum_{i=1}^{N_p} q_i \\, W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right)\n$$\n\n由于所有求和都是有限的，我们可以交换求和顺序而不改变结果。我们将对粒子的求和移到最外层：\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\sum_{j=0}^{N_x-1} \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\, W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right]\n$$\n\n二维形函数是可分离的，这使我们能够将对网格索引 $(j,k)$ 的双重求和分解为两个独立的一维求和的乘积：\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ \\left( \\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) \\right) \\left( \\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) \\right) \\right]\n$$\n\n现在，我们必须计算括号中的和。让我们关注对 $j$ 的求和。令 $\\xi_i = x_i/h_x$ 为粒子 $i$ 的归一化位置。该和为 $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$。问题陈述中说明，域是周期性的，并且形函数 $W(\\xi)$ 具有紧支集并满足单位分解性质，即对任意实数 $\\xi$，$\\sum_{n \\in \\mathbb{Z}} W(\\xi - n) = 1$。\n\n由于 $W$ 的紧支集特性，对于任何给定的 $\\xi_i$，项 $W(\\xi_i - j)$ 仅对靠近 $\\xi_i$ 的少数有限个整数索引 $j$ 非零。网格的周期性意味着，任何在数学上会落在 $[0, N_x-1]$ 范围之外的网格节点索引上的粒子贡献都会被环绕回此范围内。例如，对节点 $j = N_x$ 的贡献会映射到节点 $0$，对 $j = -1$ 的贡献会映射到 $N_x-1$。这种“混叠”效应意味着，周期性网格上的有限求和 $\\sum_{j=0}^{N_x-1} W(\\xi_i - j)$ 精确等价于对所有整数的无限求和 $\\sum_{n \\in \\mathbb{Z}} W(\\xi_i - n)$。\n\n因此，根据单位分解性质：\n$$\n\\sum_{j=0}^{N_x-1} W\\!\\left(\\frac{x_i}{h_x} - j\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{x_i}{h_x} - n\\right) = 1\n$$\n根据相同的推理，对于 $y$ 维度：\n$$\n\\sum_{k=0}^{N_y-1} W\\!\\left(\\frac{y_i}{h_y} - k\\right) = \\sum_{n \\in \\mathbb{Z}} W\\!\\left(\\frac{y_i}{h_y} - n\\right) = 1\n$$\n\n将这些结果代回我们对 $Q_{\\text{grid}}$ 的表达式中：\n$$\nQ_{\\text{grid}} = \\sum_{i=1}^{N_p} q_i \\left[ (1) \\cdot (1) \\right] = \\sum_{i=1}^{N_p} q_i\n$$\n\n这个最终表达式正是总粒子电荷 $Q_{\\text{part}}$ 的定义。因此，我们证明了 $Q_{\\text{grid}} = Q_{\\text{part}}$。\n\n这个性质被称为全局电荷守恒，是稳定 PIC 模拟的一个基本要求。如果离散算法不遵守总电荷守恒 ($Q_{\\text{grid}} \\neq Q_{\\text{part}}$)，则意味着数值方案本身就是电荷的源或汇。根据电场高斯定律 $\\nabla \\cdot \\mathbf{E} = \\rho / \\epsilon_0$，净电荷密度是电场的源。人为地产生或消灭电荷会生成虚假的、非物理的电场，这反过来会对粒子施加不正确的力，导致误差快速累积和数值不稳定性。这种现象被称为净电荷漂移。使用满足单位分解性质的形函数可以保证在电荷分配层面上不会发生这种漂移。\n\n### 任务 B：数值验证与算法设计\n\n为了对该原理进行数值验证，我们为基于 B 样条的各种形函数实现了电荷分配。一维形函数 $W(\\xi)$ 将粒子的连续位置与离散网格节点上的权重联系起来。自变量 $\\xi$ 是粒子到网格节点的归一化距离。二维形函数是两个一维函数的乘积：$S(x/h_x-j, y/h_y-k) = W(x/h_x-j) W(y/h_y-k)$。\n\n所使用的形函数有：\n1.  **最近网格点法 (NGP, 0 阶 B 样条)：** 当 $|\\xi| \\le 0.5$ 时，$W_0(\\xi) = 1$，否则为 $0$。这是一个矩形或“顶帽”函数。它的支集宽度为 $1$ 个网格单元。粒子的全部电荷被分配到唯一的最近网格节点上。\n2.  **云中单元法 (CIC, 1 阶 B 样条)：** 当 $|\\xi| \\le 1$ 时，$W_1(\\xi) = 1 - |\\xi|$，否则为 $0$。这是一个三角函数，支集宽度为 $2$ 个网格单元。一个二维粒子将其电荷分配到包含它的单元的 $4$ 个网格节点上。\n3.  **三角形成形云法 (TSC, 2 阶 B 样条)：** $W_2(\\xi)$ 是一个二次样条，支集宽度为 $3$ 个网格单元。\n    $$\n    W_2(\\xi) = \\begin{cases} \\frac{3}{4} - \\xi^2  \\text{if } |\\xi| \\le \\frac{1}{2} \\\\ \\frac{1}{2} (\\frac{3}{2} - |\\xi|)^2  \\text{if } \\frac{1}{2}  |\\xi| \\le \\frac{3}{2} \\\\ 0  \\text{otherwise} \\end{cases}\n    $$\n    遵循此方案的二维粒子将其电荷分配到一个 $3 \\times 3$ 的 9 个网格节点块上。\n\n数值算法流程如下：\n1.  将一个大小为 $(N_x, N_y)$ 的二维数组 `rho_grid` 初始化为全零。\n2.  对于每个电荷为 $q_i$、位置为 $(x_i, y_i)$ 的粒子 $i$：\n    a. 计算其归一化位置 $(\\tilde{x}_i, \\tilde{y}_i) = (x_i/h_x, y_i/h_y)$。\n    b. 根据所选的形函数（NGP、CIC 或 TSC），识别每个维度中受影响的网格节点索引集 $(j_1, j_2, ...)$ 和 $(k_1, k_2, ...)$。这些索引必须使用模运算符进行周期性环绕（例如，$j \\pmod{N_x}$）。\n    c. 对于每个受影响的索引 $j_m$，计算相应的一维权重 $w_{x,m} = W(\\tilde{x}_i - j_m)$。类似地，为每个受影响的索引 $k_n$ 计算权重 $w_{y,n}$。\n    d. 对于每对受影响的索引 $(j_m, k_n)$，更新网格上的电荷密度：\n       $$\n       \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} \\gets \\rho_{j_m \\pmod{N_x}, k_n \\pmod{N_y}} + \\frac{q_i}{h_x h_y} \\cdot w_{x,m} \\cdot w_{y,n}\n       $$\n3.  遍历所有粒子后，计算网格总电荷 $Q_{\\text{grid}} = h_x h_y \\sum_{j,k} \\rho_{j,k}$。\n4.  计算差异 $|Q_{\\text{grid}} - Q_{\\text{part}}|$。\n\n对于测试 5，使用一个“被破坏”的方案，其中从 CIC 形函数导出的一维权重被乘以一个因子 $\\alpha = 1.01$。这明显违反了单位分解性质，因为单个粒子的权重之和将是 $\\alpha^2$ 而不是 1。该实现将展示由此产生的非零电荷差异，从而证实单位分解性质与电荷守恒之间的理论联系。数值实现为指定的测试用例执行这些步骤。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PIC charge deposition problem, including analytical proof and numerical verification.\n    \"\"\"\n    test_cases = [\n        # Test 1 (happy path, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 0.5, 'Nx': 64, 'Ny': 32, 'Np': 1000,\n         'seed': 42, 'charge_dist': ('normal', 0, 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 2 (boundary condition stress, NGP)\n        {'shape': 'NGP', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 4, 'Ny': 4, 'Np': 10,\n         'seed': 7, 'charge_dist': ('normal', 0, 5.0e-20),\n         'pos_dist': ('clustered', 1e-12), 'alpha': 1.0},\n        # Test 3 (higher-order shape, TSC)\n        {'shape': 'TSC', 'Lx': 0.64, 'Ly': 0.64, 'Nx': 32, 'Ny': 32, 'Np': 5000,\n         'seed': 123, 'charge_dist': ('normal', 0, 2.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 4 (edge case, zero particles, CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 16, 'Ny': 16, 'Np': 0,\n         'seed': None, 'charge_dist': None, 'pos_dist': 'uniform',\n         'alpha': 1.0},\n        # Test 5 (broken partition, scaled CIC)\n        {'shape': 'CIC', 'Lx': 1.0, 'Ly': 1.0, 'Nx': 32, 'Ny': 32, 'Np': 1000,\n         'seed': 99, 'charge_dist': ('fixed', 1.0e-19), 'pos_dist': 'uniform',\n         'alpha': 1.01}\n    ]\n\n    results = []\n    \n    for params in test_cases:\n        # Unpack parameters\n        shape = params['shape']\n        Lx, Ly = params['Lx'], params['Ly']\n        Nx, Ny = params['Nx'], params['Ny']\n        Np = params['Np']\n        seed = params['seed']\n        charge_dist = params['charge_dist']\n        pos_dist = params['pos_dist']\n        alpha = params['alpha']\n\n        hx, hy = Lx / Nx, Ly / Ny\n        \n        # Handle zero particle case\n        if Np == 0:\n            results.append(0.0)\n            continue\n\n        rng = np.random.default_rng(seed)\n\n        # Generate particle charges\n        if charge_dist[0] == 'normal':\n            mean, std_dev = charge_dist[1], charge_dist[2]\n            charges = rng.normal(mean, std_dev, Np)\n        elif charge_dist[0] == 'fixed':\n            charges = np.full(Np, charge_dist[1], dtype=np.float64)\n        \n        q_total_particles = np.sum(charges)\n\n        # Generate particle positions\n        if pos_dist == 'uniform':\n            positions = rng.uniform(low=[0.0, 0.0], high=[Lx, Ly], size=(Np, 2))\n        elif pos_dist[0] == 'clustered':\n            epsilon = pos_dist[1]\n            # In Test 2, use the same seed for reproducibility of positions\n            pos_rng = np.random.default_rng(seed) if shape == 'NGP' else rng\n            positions = pos_rng.uniform(low=[Lx - 2 * epsilon, Ly - 2 * epsilon],\n                                        high=[Lx - epsilon, Ly - epsilon],\n                                        size=(Np, 2))\n\n        # Initialize charge density grid\n        rho_grid = np.zeros((Nx, Ny), dtype=np.float64)\n\n        # Deposit charges\n        for i in range(Np):\n            q_i = charges[i]\n            x_i, y_i = positions[i]\n            \n            x_norm = x_i / hx\n            y_norm = y_i / hy\n            \n            # 1D weights and indices calculation\n            if shape == 'NGP':\n                # x-dimension\n                jx = int(np.floor(x_norm + 0.5))\n                wx = [1.0]\n                jx_indices = [jx]\n                \n                # y-dimension\n                ky = int(np.floor(y_norm + 0.5))\n                wy = [1.0]\n                ky_indices = [ky]\n\n            elif shape == 'CIC':\n                # x-dimension\n                jx0 = int(np.floor(x_norm))\n                dx = x_norm - jx0\n                wx = [alpha * (1.0 - dx), alpha * dx]\n                jx_indices = [jx0, jx0 + 1]\n\n                # y-dimension\n                ky0 = int(np.floor(y_norm))\n                dy = y_norm - ky0\n                wy = [alpha * (1.0 - dy), alpha * dy]\n                ky_indices = [ky0, ky0 + 1]\n                \n            elif shape == 'TSC':\n                # x-dimension\n                jxc = int(np.floor(x_norm + 0.5))\n                dx = x_norm - jxc\n                wx = [0.5 * (0.5 - dx)**2, 0.75 - dx**2, 0.5 * (0.5 + dx)**2]\n                jx_indices = [jxc - 1, jxc, jxc + 1]\n\n                # y-dimension\n                kyc = int(np.floor(y_norm + 0.5))\n                dy = y_norm - kyc\n                wy = [0.5 * (0.5 - dy)**2, 0.75 - dy**2, 0.5 * (0.5 + dy)**2]\n                ky_indices = [kyc - 1, kyc, kyc + 1]\n\n            # 2D deposition with periodic boundary conditions\n            for idx_x, j in enumerate(jx_indices):\n                for idx_y, k in enumerate(ky_indices):\n                    # Using scatter-add logic here\n                    # Indices must be wrapped\n                    j_wrapped = j % Nx\n                    k_wrapped = k % Ny\n                    weight_2d = wx[idx_x] * wy[idx_y]\n                    rho_grid[j_wrapped, k_wrapped] += q_i * weight_2d\n\n        # Correct units for rho_grid\n        rho_grid /= (hx * hy)\n        \n        # Calculate total grid charge\n        q_total_grid = np.sum(rho_grid) * hx * hy\n        \n        discrepancy = np.abs(q_total_grid - q_total_particles)\n        results.append(discrepancy)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "尽管满足单位分解性质的形函数能保证全局电荷守恒，但粒子通过网格的相互作用通常无法完全满足牛顿第三定律，从而导致总动量不守恒。这种由离散化引入的“伪动量误差”是PIC模拟中的一个关键问题。本练习将通过一个双粒子系统的计算案例，量化该误差，并展示使用更高阶、更平滑的形函数是减小这种非物理效应的有效途径 。",
            "id": "4183324",
            "problem": "在一维静电周期性域中，两个粒子通过基于网格的场求解器相互作用，如同在粒子-网格（PIC）方法中一样。目标是量化在使用不同粒子形状函数阶数时，由粒子与网格之间的电荷分配和力插值引起的虚假总动量误差，并证明随着形状函数阶数的增加，该动量误差会减小。在无量纲单位下进行计算：域长度$L=1$，真空介电常数$\\epsilon_0=1$，粒子电荷$q_1=+1$，$q_2=-1$。无需进行物理单位转换。\n\n基本原理和定义：\n- 静电场满足一维空间中的泊松方程$\\partial_x E(x) = \\rho(x)/\\epsilon_0$和$E(x) = -\\partial_x \\phi(x)$，并在$[0,L)$上具有周期性边界条件。\n- 离散网格由$N_g$个均匀间隔的网格节点组成，节点位置为$x_j = j \\Delta x$，其中整数$j \\in \\{0,1,\\dots,N_g-1\\}$，$\\Delta x = L/N_g$。\n- 基于网格的场求解器通过使用阶数$m \\in \\{0,1,2,3\\}$的粒子形状函数将粒子电荷分配到附近节点来构建网格电荷密度$\\rho_j$，并在傅里叶空间中求解泊松方程以获得网格电场$E_j$。然后，使用相同阶数$m$的形状函数将$E_j$插值回粒子位置，从而获得粒子所在位置的场。\n\n计算方法要求：\n- 使用标准的均匀离散傅里叶变换，通过谱方法求解具有周期性边界条件的泊松方程。在傅里叶空间中，通过将零波数模式设置为零来强制零平均势。通过谱微分计算电场。\n- 对电荷分配（粒子到网格）和力插值（网格到粒子）使用相同的粒子形状函数阶数$m$。所考虑的阶数包括$m=0$（最近网格点法）、$m=1$（云中单元法）、$m=2$（三角形成形云法）和$m=3$（分段三次样条）。每种形状函数都是一种紧支集、归一化的一维形状，其支撑域覆盖$m+1$个网格单元。\n- 在电荷分配和插值中均实现周期性边界条件。\n\n诊断量的定义：\n- 设$F_i = q_i E(x_i)$为在粒子$i \\in \\{1,2\\}$位置$x_i$处由插值电场产生的作用力。在净电荷为零的周期性域中，对于连续、精确的双体静电相互作用，牛顿第三定律意味着总内力$\\sum_i F_i$在任何时候都精确为零，因此总动量守恒。\n- 将单个构型的无量纲虚假动量误差定义为\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta},\n$$\n其中$\\delta$是一个小的正常数正则化常数，用于避免在病态情况下出现除以零的错误，例如$\\delta = 10^{-16}$。\n\n任务：\n- 对于每个指定的测试用例，使用上述方法计算无量纲虚假动量误差$\\varepsilon_m$。\n- 所有计算必须按规定使用无量纲单位进行。\n\n测试套件：\n计算以下六个测试用例的$\\varepsilon_m$。每个测试用例是一个元组$(N_g, m, x_1, x_2)$，其中$L=1$，$q_1=+1$，$q_2=-1$，位置在周期性区间$[0,1)$内。\n1. $(N_g=\\;32, m=\\;0, x_1=\\;0.23, x_2=\\;0.77)$\n2. $(N_g=\\;32, m=\\;1, x_1=\\;0.23, x_2=\\;0.77)$\n3. $(N_g=\\;32, m=\\;2, x_1=\\;0.23, x_2=\\;0.77)$\n4. $(N_g=\\;32, m=\\;3, x_1=\\;0.23, x_2=\\;0.77)$\n5. $(N_g=\\;32, m=\\;3, x_1=\\;0.98, x_2=\\;0.12)$\n6. $(N_g=\\;64, m=\\;3, x_1=\\;0.401, x_2=\\;0.409)$\n\n预期结果将揭示以下行为：\n- 对于固定的网格分辨率$N_g=\\;32$和固定的粒子位置$(x_1,x_2)=(0.23,0.77)$，对于$m=0,1,2,3$的误差序列应呈现下降趋势，这表明使用更高阶的形状函数可以改善离散动量守恒性。\n- 如果在电荷分配和插值中正确实现了周期性包裹，那么对于粒子靠近周期性边界$(x_1=0.98, x_2=0.12)$的构型，使用高阶形状函数也应产生较小的误差。\n- 在$N_g=64$和$m=3$条件下的近对构型，应能在$|x_2-x_1|$很小时测试方法的鲁棒性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含六个结果，形式为方括号内的逗号分隔列表，例如$[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个$r_k$是第$k$个测试用例的$\\varepsilon_m$的浮点数值，单位为无量纲。",
            "solution": "用户提供的问题是有效的。这是一个适定的、有科学依据的计算物理问题，旨在探究粒子-网格（PIC）方法的一个基本数值特性。所有必需的数据和定义均已提供，任务是客观且可验证的。\n\n该问题要求计算一个含两个粒子的一维静电PIC模拟中的虚假总动量误差。此误差的产生是因为计算网格的颗粒性破坏了物理定律的连续平移对称性。在连续系统中，两个粒子间的相互作用力$\\vec{F}_{12}$与力$\\vec{F}_{21}$大小相等、方向相反，即$\\vec{F}_{12} + \\vec{F}_{21} = 0$，这就是牛顿第三定律。这保证了双粒子系统的总动量守恒。\n\n在PIC模拟中，粒子不直接相互作用，而是通过网格离散化的场相互作用。该过程包括三个步骤：\n$1$. **电荷分配**：每个粒子的电荷被“分摊”到几个邻近的网格节点上。\n$2$. **场求解**：根据分配的电荷密度，在网格节点上计算静电场。\n$3$. **力插值**：将场从网格节点插值回粒子位置以计算作用力。\n\n这种由网格介导的相互作用通常不满足针对粒子的牛顿第三定律。作用于粒子1的力$F_1$是由粒子2的电荷在网格上的表示所产生的场推导而来的，反之亦然。由于离散化，力$F_1$与$F_2$并不精确地大小相等、方向相反，导致总力不为零$F_1 + F_2 \\neq 0$，从而违反了动量守恒。这种违反的程度，由误差度量$\\varepsilon_m$量化，关键取决于用于电荷分配和力插值的函数的光滑度。这些函数被称为粒子形状函数。\n\n高阶形状函数在网格上提供了更光滑的粒子表示，减少了力对粒子相对于网格节点位置的非物理依赖性。这带来了更好的守恒特性。该问题要求通过计算阶数递增$m \\in \\{0, 1, 2, 3\\}$的形状函数的$\\varepsilon_m$来证明这一原理。\n\n计算给定测试用例$(N_g, m, x_1, x_2)$的误差$\\varepsilon_m$的计算步骤如下：\n\n**1. 系统设置**\n模拟域长度为$L=1$，具有周期性边界条件。网格由$N_g$个节点组成，位置为$x_j = j \\Delta x$，其中$j \\in \\{0, 1, \\dots, N_g-1\\}$，网格间距为$\\Delta x = L/N_g = 1/N_g$。存在两个粒子，电荷分别为$q_1=+1$和$q_2=-1$，位置分别为$x_1$和$x_2$。真空介电常数为$\\epsilon_0=1$。\n\n**2. 粒子形状函数**\n粒子与网格之间的相互作用由阶数为$p=m+1$的基样条（B-spline）形状函数介导，记作$S_m(u)$，其中$u=(x_p - x_j)/\\Delta x$是从粒子位置$x_p$到网格节点$x_j$的归一化距离。函数$S_m(u)$在一个有限的支撑域上非零。我们为形状函数阶数$m=0, 1, 2, 3$实现B样条$B_{m+1}(u)$：\n-   阶数$m=0$ (NGP, $B_1$): 当$|u| \\le 1/2$时为$1$，否则为$0$。\n-   阶数$m=1$ (CIC, $B_2$): 当$|u| \\le 1$时为$1 - |u|$，否则为$0$。\n-   阶数$m=2$ (TSC, $B_3$): $S_2(u) = \\begin{cases} 3/4 - u^2  |u| \\le 1/2 \\\\ 1/2(3/2 - |u|)^2  1/2  |u| \\le 3/2 \\\\ 0  |u|  3/2 \\end{cases}$。\n-   阶数$m=3$ (PCS, $B_4$): $S_3(u) = \\begin{cases} 1/6(3|u|^3 - 6u^2 + 4)  |u| \\le 1 \\\\ 1/6(2 - |u|)^3  1  |u| \\le 2 \\\\ 0  |u|  2 \\end{cases}$。\n\n**3. 电荷分配**\n一个用于电荷密度$\\rho_j$的网格数组被初始化为零。对于每个电荷为$q_p$、位置为$x_p$的粒子$p \\in \\{1, 2\\}$，我们将其电荷分配到网格上。首先，我们找到所有位于以$x_p$为中心的形状函数支撑域内的网格节点$j$。对于每个这样的节点，我们计算权重$W_{p,j} = S_m((x_p/\\Delta x) - j)$。节点$j$处的电荷密度通过加上粒子的贡献来更新：$\\rho_j \\leftarrow \\rho_j + q_p W_{p,j} / \\Delta x$。除以单元体积$\\Delta x$可将分配的电荷正确地缩放为电荷密度。节点索引$j$进行周期性处理，即对$N_g$取模。\n\n**4. 谱方法场求解**\n一维泊松方程为$\\partial_x E = \\rho(x)/\\epsilon_0$。我们使用离散傅里叶变换（DFT）在网格上求解该方程。\n-   首先，我们计算网格电荷密度的DFT：$\\hat{\\rho}_k = \\mathcal{F}\\{\\rho_j\\}$。\n-   在傅里叶空间中，空间导数$\\partial_x$变为乘以$i k$，其中$k$是波数。方程变为$i k \\hat{E}_k = \\hat{\\rho}_k/\\epsilon_0$。\n-   对应于DFT的波数由$k_n = 2\\pi n / L$给出，其中$n \\in \\{-N_g/2, \\dots, N_g/2-1\\}$。\n-   傅里叶空间中的网格电场为$\\hat{E}_k = \\frac{\\hat{\\rho}_k}{i k \\epsilon_0} = -i \\frac{\\hat{\\rho}_k}{k \\epsilon_0}$（当$k \\ne 0$时）。\n-   对于$k=0$模式（直流分量），净电荷$\\sum q_p=0$确保了$\\hat{\\rho}_{k=0}=0$。$\\hat{E}_{k=0}$的表达式是不确定的。我们设置$\\hat{E}_{k=0}=0$，这对应于零平均电场，与周期性边界条件和零净电荷一致。这也强制了零平均势条件。\n-   最后，通过计算$\\hat{E}_k$的逆DFT得到网格上的电场$E_j$：$E_j = \\mathcal{F}^{-1}\\{\\hat{E}_k\\}$。\n\n**5. 力插值**\n每个粒子位置处的电场$E(x_p)$是通过使用相同的形状函数$S_m$插值网格电场$E_j$来找到的。插值场是一个加权和：$E(x_p) = \\sum_j E_j W_{p,j}$，其中权重$W_{p,j}$与粒子$p$的电荷分配步骤中使用的权重相同。这种分配和插值之间的对称性对于动量守恒特性至关重要。每个粒子上的力则为$F_p = q_p E(x_p)$。\n\n**6. 误差计算**\n在计算出力$F_1$和$F_2$后，使用提供的公式计算无量纲虚假动量误差：\n$$\n\\varepsilon_m = \\frac{\\left| F_1 + F_2 \\right|}{\\left|F_1\\right| + \\left|F_2\\right| + \\delta}\n$$\n其中正则化常数$\\delta=10^{-16}$。对六个测试用例中的每一个重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef b_spline(u_abs, m):\n    \"\"\"\n    Computes the value of the B-spline of order m+1 (degree m) at a given\n    absolute normalized distance u_abs = |u|.\n    These are the standard PIC particle shape functions Sm.\n    \"\"\"\n    if m == 0:  # NGP, B-spline order 1\n        return 1.0 if u_abs = 0.5 else 0.0\n    elif m == 1:  # CIC, B-spline order 2\n        return 1.0 - u_abs if u_abs = 1.0 else 0.0\n    elif m == 2:  # TSC, B-spline order 3\n        if u_abs = 0.5:\n            return 0.75 - u_abs**2\n        elif u_abs = 1.5:\n            return 0.5 * (1.5 - u_abs)**2\n        else:\n            return 0.0\n    elif m == 3:  # PCS, B-spline order 4\n        if u_abs = 1.0:\n            return (1.0/6.0) * (4.0 - 6.0*u_abs**2 + 3.0*u_abs**3)\n        elif u_abs = 2.0:\n            return (1.0/6.0) * (2.0 - u_abs)**3\n        else:\n            return 0.0\n    else:\n        raise ValueError(\"Shape order m must be 0, 1, 2, or 3.\")\n\ndef get_weights(x_p, m, Ng, dx):\n    \"\"\"\n    Calculates the weights and indices for depositing charge or interpolating fields.\n    \"\"\"\n    u_p = x_p / dx\n    support_half_width = (m + 1) / 2.0\n    \n    j_min = int(np.ceil(u_p - support_half_width))\n    j_max = int(np.floor(u_p + support_half_width))\n    \n    indices = []\n    weights = []\n    \n    for j in range(j_min, j_max + 1):\n        u_abs = abs(u_p - j)\n        weight = b_spline(u_abs, m)\n        if weight > 0:\n            indices.append(j % Ng)\n            weights.append(weight)\n            \n    return np.array(indices, dtype=int), np.array(weights)\n\ndef calculate_error(Ng, m, x1, x2):\n    \"\"\"\n    Performs the PIC-style calculation to find the momentum conservation error.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    q1, q2 = 1.0, -1.0\n    epsilon_0 = 1.0\n    delta = 1e-16\n    dx = L / Ng\n\n    # 1. Charge Deposition (Particle-To-Grid)\n    rho_grid = np.zeros(Ng)\n    particles = [(q1, x1), (q2, x2)]\n    \n    # Store weights for later use in interpolation\n    p1_indices, p1_weights = get_weights(particles[0][1], m, Ng, dx)\n    p2_indices, p2_weights = get_weights(particles[1][1], m, Ng, dx)\n\n    # Deposit charge for particle 1\n    np.add.at(rho_grid, p1_indices, particles[0][0] * p1_weights / dx)\n    \n    # Deposit charge for particle 2\n    np.add.at(rho_grid, p2_indices, particles[1][0] * p2_weights / dx)\n\n    # 2. Field Solve (Grid)\n    # DFT of charge density\n    rho_hat = np.fft.fft(rho_grid)\n    \n    # Wavenumbers\n    k = 2 * np.pi * np.fft.fftfreq(Ng, d=dx)\n    \n    # Solve for E-field in Fourier space: E_hat = -i * rho_hat / (epsilon_0 * k)\n    E_hat = np.zeros_like(rho_hat, dtype=complex)\n    nonzero_k_mask = k != 0\n    E_hat[nonzero_k_mask] = -1j * rho_hat[nonzero_k_mask] / (epsilon_0 * k[nonzero_k_mask])\n    \n    # Inverse DFT to get E-field on grid\n    E_grid = np.real(np.fft.ifft(E_hat))\n\n    # 3. Force Interpolation (Grid-To-Particle)\n    # Interpolate E-field at particle 1 and calculate force\n    E1 = np.sum(E_grid[p1_indices] * p1_weights)\n    F1 = q1 * E1\n    \n    # Interpolate E-field at particle 2 and calculate force\n    E2 = np.sum(E_grid[p2_indices] * p2_weights)\n    F2 = q2 * E2\n\n    # 4. Calculate Spurious Momentum Error\n    error = np.abs(F1 + F2) / (np.abs(F1) + np.abs(F2) + delta)\n    \n    return error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 0, 0.23, 0.77),\n        (32, 1, 0.23, 0.77),\n        (32, 2, 0.23, 0.77),\n        (32, 3, 0.23, 0.77),\n        (32, 3, 0.98, 0.12),\n        (64, 3, 0.401, 0.409),\n    ]\n\n    results = []\n    for case in test_cases:\n        Ng, m, x1, x2 = case\n        result = calculate_error(Ng, m, x1, x2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}