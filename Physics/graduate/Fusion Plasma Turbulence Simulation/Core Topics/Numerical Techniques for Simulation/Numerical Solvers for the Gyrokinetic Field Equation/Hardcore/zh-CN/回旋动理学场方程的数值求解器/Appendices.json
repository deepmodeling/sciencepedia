{
    "hands_on_practices": [
        {
            "introduction": "在回旋动理学理论中，回旋平均算符 $\\Gamma_0(b)$ 和 $\\Gamma_1(b)$ 是描述粒子拉莫尔运动平均效应的基本构件。本练习旨在解决在宽参数范围（从小到大的 $b$ 值）内精确计算这些函数的数值挑战。通过比较直接数值积分与基于特殊函数的稳定算法，您将深刻理解在科学计算中数值稳定性的重要性。",
            "id": "4197698",
            "problem": "要求您设计并实现一个完整的、可运行的程序，用于计算回旋动理学场方程中使用的回旋平均算子。在磁化等离子体的回旋动理学（GK）理论中，回旋平均算子源于对粒子拉莫尔运动的回旋角进行平均。对于一个无量纲参数 $b \\ge 0$（与垂直波数的平方乘以拉莫尔半径的平方成正比），定义以下两个需要关注的量：\n- $\\,\\Gamma_0(b)$，零阶回旋平均算子，\n- $\\,\\Gamma_1(b)$，一阶回旋平均算子。\n\n您的任务是：\n1. 使用数值稳定算法计算 $\\,\\Gamma_0(b)$ 和 $\\,\\Gamma_1(b)$，这些算法在小 $b$（例如，$b \\ll 1$）、中等 $b$（例如，$b \\sim 1$）和大 $b$（例如，$b \\gg 1$）时都能保持准确性。\n2. 通过对回旋角进行直接数值积分，独立计算 $\\,\\Gamma_0(b)$ 和 $\\,\\Gamma_1(b)$。使用在一次完整回旋（回旋角以弧度为单位）上的周期积分表示：\n   - $$\\Gamma_0(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\, d\\theta,$$\n   - $$\\Gamma_1(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\,\\cos\\theta \\, d\\theta.$$\n   以上积分必须进行数值计算，角度变量以弧度表示。\n3. 通过报告绝对差 $|\\Gamma_0^{\\text{stable}} - \\Gamma_0^{\\text{integral}}|$ 和 $|\\Gamma_1^{\\text{stable}} - \\Gamma_1^{\\text{integral}}|$，比较稳定算法与直接积分计算的结果。\n\n使用以下基本原理来设计您的方法：\n- 回旋角平均源于圆形拉莫尔运动的对称性，在数学上通过对角坐标 $\\theta$ 进行平均来表示。\n- 对于在 $[0,2\\pi]$ 上的周期性光滑被积函数，均匀网格上的梯形求积法具有谱精度，可作为一种稳健的数值积分方法。\n- 在 $b$ 的整个范围内进行稳定求值需要仔细选择算法以避免上溢/下溢和相减抵消；小 $b$ 级数和指数标度的特殊函数是标准方法。\n\n为了数值稳定性：\n- 对于小 $b$，通过使用针对函数极限行为定制的低阶级数展开来避免相减抵消。\n- 对于中等和大 $b$，使用指数标度的特殊函数来抑制由指数级大的中间值引起的上溢。\n- 在数值积分中，选择一个适应 $b$ 的分辨率，以便充分解析大 $b$ 时的尖峰。\n\n为以下 $b$ 值的测试套件实现计算：\n- $b \\in \\{\\,0.0,\\; 10^{-8},\\; 0.1,\\; 1.0,\\; 10.0,\\; 100.0,\\; 10^{4}\\,\\}$。\n\n对于每个测试用例，您的程序必须生成一个六元列表，形式如下：\n$$[\\Gamma_0^{\\text{stable}},\\; \\Gamma_0^{\\text{integral}},\\; \\Gamma_1^{\\text{stable}},\\; \\Gamma_1^{\\text{integral}},\\; |\\Gamma_0^{\\text{stable}} - \\Gamma_0^{\\text{integral}}|,\\; |\\Gamma_1^{\\text{stable}} - \\Gamma_1^{\\text{integral}}|].$$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[[case1_results],[case2_results],...]\"），每个元素按上述顺序对应一个测试用例的结果。\n- 因为 $b$ 是无量纲的，所以不涉及物理量纲单位，并且所有角度必须以弧度为单位。",
            "solution": "该问题要求计算并比较两个回旋平均算子 $\\Gamma_0(b)$ 和 $\\Gamma_1(b)$，其中 $b$ 是一个非负无量纲参数。计算必须使用两种不同的方法进行：一种是利用特殊函数的数值稳定算法，另一种是基于所提供的积分定义的直接数值积分。\n\n算子的积分定义为：\n$$\n\\Gamma_0(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\, d\\theta\n$$\n$$\n\\Gamma_1(b) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} \\exp\\!\\big(-\\,b\\,(1-\\cos\\theta)\\big)\\,\\cos\\theta \\, d\\theta\n$$\n\n这些积分可以与第一类修正贝塞尔函数相关联。修正贝塞尔函数 $I_n(z)$ 的积分表示为：\n$$\nI_n(z) = \\frac{1}{2\\pi} \\int_{0}^{2\\pi} e^{z \\cos\\tau} \\cos(n\\tau) d\\tau\n$$\n通过从 $\\Gamma_0(b)$ 的被积函数中提出因子 $e^{-b}$，我们可以确定它与 $I_0(b)$ 的关系：\n$$\n\\Gamma_0(b) = e^{-b} \\left( \\frac{1}{2\\pi} \\int_{0}^{2\\pi} e^{b \\cos\\theta} d\\theta \\right) = e^{-b} I_0(b)\n$$\n同样，对于 $\\Gamma_1(b)$，我们确定它与 $I_1(b)$ 的关系：\n$$\n\\Gamma_1(b) = e^{-b} \\left( \\frac{1}{2\\pi} \\int_{0}^{2\\pi} e^{b \\cos\\theta} \\cos\\theta d\\theta \\right) = e^{-b} I_1(b)\n$$\n这些恒等式构成了数值稳定计算方法的基础。\n\n**方法1：数值稳定算法**\n\n直接计算 $I_n(b)$ 然后乘以 $e^{-b}$ 在大 $b$ 值下是数值不稳定的。函数 $I_n(b)$ 呈指数增长，大约为 $e^b/\\sqrt{2\\pi b}$，对于大 $b$ 会导致上溢。随后乘以指数级小的因子 $e^{-b}$ 是导致数值不准确的典型情况。\n\n一个稳健的解决方案是使用指数标度的修正贝塞尔函数，这些函数被设计用于直接计算 $e^{-|x|}I_n(x)$。由于参数 $b$ 是非负的（$b \\ge 0$），这些函数非常适合解决此问题。具体来说：\n- $\\Gamma_0^{\\text{stable}}(b) = e^{-b}I_0(b)$ 使用函数 `scipy.special.i0e(b)` 进行计算。\n- $\\Gamma_1^{\\text{stable}}(b) = e^{-b}I_1(b)$ 使用函数 `scipy.special.i1e(b)` 进行计算。\n\n这些库函数经过高度优化，内部使用不同的算法（对小参数使用级数展开，对大参数使用渐近展开）以确保在 $b$ 的整个范围内的准确性和稳定性。\n\n**方法2：直接数值积分**\n\n第二种方法涉及对定义的积分进行直接数值计算。两个被积函数 $f_0(\\theta) = \\exp(-b(1-\\cos\\theta))$ 和 $f_1(\\theta) = \\exp(-b(1-\\cos\\theta))\\cos\\theta$ 都是关于 $\\theta$ 的光滑且 $2\\pi$ 周期的函数。对于此类函数，在一个周期上使用均匀网格的梯形法则已知具有谱精度。\n\n对于一个周期函数在其周期 $[0, 2\\pi]$ 上的积分，使用 $N$ 个均匀区间的梯形法则可以简化。积分可以近似为步长 $h = 2\\pi/N$ 乘以在网格点 $\\theta_j = j \\cdot h$（$j=0, 1, \\dots, N-1$）处的函数值之和。\n$$\n\\int_0^{2\\pi} f(\\theta) d\\theta \\approx \\frac{2\\pi}{N} \\sum_{j=0}^{N-1} f(\\theta_j)\n$$\n将此应用于包含前置因子 $1/(2\\pi)$ 的 $\\Gamma_0(b)$ 和 $\\Gamma_1(b)$ 的定义，计算简化为取被积函数在网格点上的值的平均值：\n$$\n\\Gamma_0^{\\text{integral}}(b) \\approx \\frac{1}{N} \\sum_{j=0}^{N-1} \\exp\\big(-b(1-\\cos\\theta_j)\\big)\n$$\n$$\n\\Gamma_1^{\\text{integral}}(b) \\approx \\frac{1}{N} \\sum_{j=0}^{N-1} \\exp\\big(-b(1-\\cos\\theta_j)\\big) \\cos\\theta_j\n$$\n此方法的一个关键方面是 $N$ 的选择。对于大 $b$，被积函数 $\\exp\\big(-b(1-\\cos\\theta)\\big)$ 在 $\\theta=0$（和 $\\theta=2\\pi$）附近变得非常尖锐。对于小 $\\theta$，$1-\\cos\\theta \\approx \\theta^2/2$，因此峰的特征宽度尺度为 $\\Delta\\theta \\sim \\sqrt{2/b}$。为了准确解析此峰，网格间距 $h=2\\pi/N$ 必须显著小于 $\\Delta\\theta$，这意味着 $N$ 必须至少按 $\\sqrt{b}$ 的比例缩放。\n\n基于此分析，我们采用自适应网格分辨率策略：\n$$\nN(b) = \\max\\left( N_{\\min}, \\lceil c\\sqrt{b} \\rceil \\right)\n$$\n我们选择最小分辨率 $N_{\\min}=256$ 以确保小 $b$ 时的高精度，并使用一个缩放因子 $c=100$ 来对大 $b$ 时的峰进行过解析，从而确保该方法的光谱精度。数值实现将使用 `numpy` 进行高效的基于数组的计算。\n\n**比较**\n通过计算每个算子的绝对差来比较两种方法的结果：\n$$\n\\Delta_0 = |\\Gamma_0^{\\text{stable}} - \\Gamma_0^{\\text{integral}}|\n$$\n$$\n\\Delta_1 = |\\Gamma_1^{\\text{stable}} - \\Gamma_1^{\\text{integral}}|\n$$\n这种比较用于对照高精度的特殊函数库来验证数值积分方案的有效性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0e, i1e\nimport math\n\ndef compute_gyro_averages(b: float) - list[float]:\n    \"\"\"\n    Computes gyroaveraging operators Gamma_0(b) and Gamma_1(b) and compares\n    a stable algorithm with direct numerical integration.\n\n    Args:\n        b: A non-negative dimensionless parameter.\n\n    Returns:\n        A six-element list containing:\n        [Gamma_0_stable, Gamma_0_integral, Gamma_1_stable, Gamma_1_integral,\n         abs_diff_Gamma_0, abs_diff_Gamma_1]\n    \"\"\"\n    # Method 1: Stable algorithm using exponentially scaled Bessel functions\n    # These functions compute e^(-b) * I_0(b) and e^(-b) * I_1(b) respectively.\n    gamma_0_stable = i0e(b)\n    gamma_1_stable = i1e(b)\n\n    # Method 2: Direct numerical integration using the trapezoidal rule\n    # For a smooth, periodic function, this is equivalent to averaging function values.\n    \n    # The case b=0 is trivial and handled separately.\n    # The integrand for Gamma_0 is exp(0) = 1, so the average is 1.\n    # The integrand for Gamma_1 is exp(0)*cos(theta), average is 0.\n    if b == 0.0:\n        gamma_0_integral = 1.0\n        gamma_1_integral = 0.0\n    else:\n        # Determine the number of grid points N adaptively.\n        # For large b, the integrand is sharply peaked, requiring more points.\n        # The peak width scales as 1/sqrt(b), so N should scale as sqrt(b).\n        n_min = 256  # Minimum resolution for high accuracy at small b.\n        c_factor = 100 # Safety factor to ensure the peak is well-resolved.\n        num_points = int(max(n_min, math.ceil(c_factor * math.sqrt(b))))\n        \n        # Create a uniform grid for the gyroangle theta from 0 to 2*pi.\n        # endpoint=False ensures the grid is for a periodic interval [0, 2*pi).\n        theta = np.linspace(0, 2 * np.pi, num_points, endpoint=False)\n        cos_theta = np.cos(theta)\n        \n        # Evaluate the numerically stable form of the integrand.\n        # exp(-b * (1 - cos(theta))) varies between exp(-2b) and 1.\n        integrand_common = np.exp(-b * (1 - cos_theta))\n        \n        # For a periodic function, the integral over a period divided by the period\n        # length is just the mean of the function values on a uniform grid.\n        gamma_0_integral = np.mean(integrand_common)\n        gamma_1_integral = np.mean(integrand_common * cos_theta)\n    \n    # Compare the two methods by computing the absolute differences.\n    diff_gamma_0 = abs(gamma_0_stable - gamma_0_integral)\n    diff_gamma_1 = abs(gamma_1_stable - gamma_1_integral)\n    \n    return [\n        gamma_0_stable, gamma_0_integral,\n        gamma_1_stable, gamma_1_integral,\n        diff_gamma_0, diff_gamma_1\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run the computations for the specified test cases\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1e-8,\n        0.1,\n        1.0,\n        10.0,\n        100.0,\n        1e4\n    ]\n\n    all_results = []\n    for b_val in test_cases:\n        case_result = compute_gyro_averages(b_val)\n        all_results.append(case_result)\n\n    # Format the final output string to precisely match the required specification:\n    # \"[[case1_results],[case2_results],...]\" with no extra whitespace.\n    output_parts = []\n    for res_list in all_results:\n        # Format each number with high precision and join into a string like \"[v1,v2,...]\"\n        res_str = '[' + ','.join(f'{val:.15g}' for val in res_list) + ']'\n        output_parts.append(res_str)\n    \n    # Join all case strings and enclose in the final outer brackets.\n    final_output_string = '[' + ','.join(output_parts) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本算符的计算后，我们将在更真实的环境中应用回旋平均的概念。本练习将演示如何利用快速傅里叶变换 (FFT) 将回旋平均操作高效地应用于二维场，这是现代谱法回旋动理学模拟中的核心技术。您将通过实践卷积定理来学习构建谱场算符，从而将抽象的物理操作转化为高效的数值实现。",
            "id": "4197716",
            "problem": "给定一个长度为 $L_x$ 和 $L_y$ 的二维周期性域，离散为 $N_x \\times N_y$ 个网格点，均匀间距分别为 $\\Delta x = L_x / N_x$ 和 $\\Delta y = L_y / N_y$。对于每种粒子 $s$（考虑 $s \\in \\{i,e\\}$，分别对应离子和电子），令 $h_s(x,y)$ 表示一个已在速度空间上积分的无量纲回旋中心分布微扰。在固定导向中心处的回旋平均定义为在垂直于磁场的平面上，对半径为 $\\rho_s$ 的圆周进行的均匀平均。实空间中的回旋平均核由 $G_{\\rho_s}(\\mathbf{r}) = \\delta(|\\mathbf{r}| - \\rho_s)/(2\\pi \\rho_s)$ 给出，其连续傅里叶变换等于 $J_0(k_\\perp \\rho_s)$，其中 $J_0$ 是第一类零阶贝塞尔函数，$k_\\perp = \\sqrt{k_x^2 + k_y^2}$ 是垂直波矢的大小。\n\n从回旋平均在实空间中作为环积分的定义以及环核的傅里叶表示出发，推导出回旋平均算符的离散谱组装。所需的推导必须从基本原理开始：回旋平均的定义、Jacobi–Anger 展开以及傅里叶变换的性质。然后，实现一个数值求解器，该求解器：\n\n- 使用快速算法计算给定网格上每种粒子的 $h_s(x,y)$ 的离散傅里叶变换。\n- 在相同的离散谱格上计算 $J_0(k_\\perp \\rho_s)$，这等效于计算实空间环核的离散傅里叶变换，并且比在实空间中进行卷积更有效。\n- 通过对不同粒子种类的 $J_0(k_\\perp \\rho_s)\\,\\hat{h}_s(k_x,k_y)$ 求和来组装谱场算符。\n- 返回一个标量诊断量，等于组装后的谱算符的离散傅里叶逆变换的均方根（RMS）振幅，该值是无量纲的。\n\n使用以下物理参数和定义来计算每种粒子的热回旋半径：\n- 电子电荷大小 $e = 1.602176634 \\times 10^{-19}$ (库仑)。\n- 质子质量 $m_p = 1.67262192369 \\times 10^{-27}$ (千克)。\n- 氘核质量 $m_i = 2 m_p$ (千克)。\n- 电子质量 $m_e = 9.1093837015 \\times 10^{-31}$ (千克)。\n- 均匀背景磁场大小 $B_0$ (特斯拉)。\n- 粒子温度 $T_s$ 以电子伏特 (eV) 为单位提供，通过 $1\\,\\mathrm{eV} = e$ 焦耳转换为焦耳。\n- 热速度 $v_{\\mathrm{th},s} = \\sqrt{2 T_s / m_s}$ (米/秒)，其中 $T_s$ 单位为焦耳。\n- 回旋频率 $\\Omega_s = |q_s| B_0 / m_s$ (弧度/秒)，其中 $q_i = +e$，$q_e = -e$。\n- 热回旋半径 $\\rho_s = v_{\\mathrm{th},s} / \\Omega_s$ (米)。\n\n采用与标准快速傅里叶变换实现一致的周期性网格上的离散傅里叶变换：正变换 $\\hat{h}_s(k_{x,m},k_{y,n})$ 不进行归一化，逆变换包含归一化因子 $1/(N_x N_y)$。离散谱格通过 $k_{x,m} = 2\\pi m/L_x$ 和 $k_{y,n} = 2\\pi n/L_y$ 定义，其中整数索引 $m$ 和 $n$ 由离散频率数组提供。\n\n您的程序必须使用下面指定的测试套件实现上述内容，计算组装后的谱场算符，将其变换回实空间，并报告所得实空间场的 RMS 振幅。RMS 诊断量定义为\n$$\n\\mathrm{RMS} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{j=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\left( s(x_j,y_l) \\right)^2 },\n$$\n其中 $s(x,y)$ 是 $\\sum_s J_0(k_\\perp \\rho_s)\\,\\hat{h}_s(k_x,k_y)$ 的离散傅里叶逆变换。\n\n所有输出都是无量纲的，因此最终数字不需要物理单位。\n\n测试套件：\n对于每种情况，使用 $x_j = j \\Delta x$（其中 $j=0,\\dots,N_x-1$）和 $y_l = l \\Delta y$（其中 $l=0,\\dots,N_y-1$）在指定网格上构建 $h_s(x,y)$。输入函数被指定为具有整数模数 $m_x$ 和 $m_y$ 的可分离模式的正弦或余弦的乘积。使用以下情况：\n\n- 情况1（正常路径，混合粒子种类贡献）：\n  - $N_x = 32$，$N_y = 24$，$L_x = 0.3$ (米)，$L_y = 0.25$ (米)，$B_0 = 3.0$ (特斯拉)，$T_i = 2000$ (电子伏特)，$T_e = 1000$ (电子伏特)。\n  - $h_i(x,y) = \\cos\\left(2\\pi \\frac{x}{L_x}\\right)\\cos\\left(4\\pi \\frac{y}{L_y}\\right)$。\n  - $h_e(x,y) = 0.25\\,\\sin\\left(2\\pi \\frac{x}{L_x}\\right)\\cos\\left(2\\pi \\frac{y}{L_y}\\right)$。\n\n- 情况2（边界条件，零场）：\n  - $N_x$, $N_y$, $L_x$, $L_y$ 与情况1相同，$B_0 = 3.0$，$T_i = 2000$ (电子伏特)，$T_e = 1000$ (电子伏特)。\n  - 对于所有网格点，$h_i(x,y) = 0$，$h_e(x,y) = 0$。\n\n- 情况3（边缘情况，大离子回旋半径和更高波数成分）：\n  - $N_x = 48$，$N_y = 48$，$L_x = 0.4$ (米)，$L_y = 0.4$ (米)，$B_0 = 0.5$ (特斯拉)，$T_i = 15000$ (电子伏特)，$T_e = 500$ (电子伏特)。\n  - $h_i(x,y) = \\cos\\left(6\\pi \\frac{x}{L_x}\\right)\\cos\\left(6\\pi \\frac{y}{L_y}\\right)$。\n  - $h_e(x,y) = 0$。\n\n- 情况4（电子小回旋半径极限与重叠模式）：\n  - $N_x = 64$，$N_y = 32$，$L_x = 0.2$ (米)，$L_y = 0.3$ (米)，$B_0 = 5.0$ (特斯拉)，$T_i = 3000$ (电子伏特)，$T_e = 100$ (电子伏特)。\n  - $h_i(x,y) = 0.7\\,\\cos\\left(2\\pi \\cdot 3 \\frac{x}{L_x}\\right)\\cos\\left(2\\pi \\cdot 2 \\frac{y}{L_y}\\right)$。\n  - $h_e(x,y) = 0.3\\,\\cos\\left(2\\pi \\cdot 3 \\frac{x}{L_x}\\right)\\cos\\left(2\\pi \\cdot 2 \\frac{y}{L_y}\\right)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含四个情况的 RMS 结果，格式为用方括号括起来的逗号分隔列表，每个浮点数四舍五入到八位小数，例如，\"[r1,r2,r3,r4]\"。不应打印任何附加文本。",
            "solution": "该问题是有效的。它在科学上基于等离子体物理中的回旋动理学理论，信息充分，问题适定，可以得到唯一解，并且计算上是可行的。所有参数和定义都是标准且一致的。\n\n问题的核心是实现回旋平均算符，这在回旋动理学中至关重要，用于将带电粒子的快速回旋运动与较慢的导向中心动力学分离开来。一个量 $f(\\mathbf{r})$ 的回旋平均是其在以给定点（代表导向中心位置）为中心、半径为 $\\rho_s$（回旋半径）的圆环上的平均值。在数学上，这是一个卷积运算。\n\n在导向中心位置 $\\mathbf{R}$ 处的场 $h_s(\\mathbf{R})$ 的回旋平均定义为场在粒子所描绘的圆形路径上的平均值：\n$$\n\\langle h_s \\rangle (\\mathbf{R}) = \\frac{1}{2\\pi} \\int_0^{2\\pi} d\\alpha \\, h_s(\\mathbf{R} + \\boldsymbol{\\rho}_s(\\alpha))\n$$\n其中 $\\boldsymbol{\\rho}_s(\\alpha)$ 是长度为 $\\rho_s$、角度为 $\\alpha$ 的回旋半径矢量。这可以表示为实空间中的卷积：\n$$\n\\langle h_s \\rangle (\\mathbf{r}) = (h_s * G_{\\rho_s})(\\mathbf{r}) = \\int d^2\\mathbf{r}' \\, h_s(\\mathbf{r}') G_{\\rho_s}(\\mathbf{r} - \\mathbf{r}')\n$$\n核 $G_{\\rho_s}$ 表示在半径为 $\\rho_s$ 的圆环上的均匀分布，由下式给出：\n$$\nG_{\\rho_s}(\\mathbf{r}) = \\frac{\\delta(|\\mathbf{r}| - \\rho_s)}{2\\pi \\rho_s}\n$$\n其中 $\\delta$ 是狄拉克δ函数。\n\n虽然这个卷积可以在实空间中执行，但计算成本很高。卷积定理指出，实空间中的卷积在傅里叶空间中变为简单的乘法。令 $\\hat{f}(\\mathbf{k}) = \\mathcal{F}[f(\\mathbf{r})]$ 表示傅里叶变换。应用该定理，我们得到：\n$$\n\\mathcal{F}[\\langle h_s \\rangle](\\mathbf{k}) = \\mathcal{F}[h_s * G_{\\rho_s}](\\mathbf{k}) = \\hat{h}_s(\\mathbf{k}) \\, \\hat{G}_{\\rho_s}(\\mathbf{k})\n$$\n因此，问题简化为求环核的傅里叶变换 $\\hat{G}_{\\rho_s}(\\mathbf{k})$。我们从其定义推导：\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\int_{\\mathbb{R}^2} d^2\\mathbf{r} \\, e^{-i \\mathbf{k} \\cdot \\mathbf{r}} G_{\\rho_s}(\\mathbf{r}) = \\int_{\\mathbb{R}^2} d^2\\mathbf{r} \\, e^{-i \\mathbf{k} \\cdot \\mathbf{r}} \\frac{\\delta(|\\mathbf{r}| - \\rho_s)}{2\\pi \\rho_s}\n$$\n为了计算这个积分，我们切换到极坐标。令 $\\mathbf{r} = (r \\cos\\theta, r \\sin\\theta)$ 和 $\\mathbf{k} = (k_\\perp \\cos\\phi, k_\\perp \\sin\\phi)$，其中 $k_\\perp = \\sqrt{k_x^2 + k_y^2}$。点积为 $\\mathbf{k} \\cdot \\mathbf{r} = k_\\perp r \\cos(\\theta - \\phi)$，面积元为 $d^2\\mathbf{r} = r \\, dr \\, d\\theta$。积分变为：\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\int_0^{2\\pi} d\\theta \\int_0^\\infty dr \\, r \\, e^{-i k_\\perp r \\cos(\\theta - \\phi)} \\frac{\\delta(r - \\rho_s)}{2\\pi \\rho_s}\n$$\n狄拉克δ函数使对 $r$ 的积分塌陷，固定 $r = \\rho_s$。\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\int_0^{2\\pi} d\\theta \\, \\rho_s \\, e^{-i k_\\perp \\rho_s \\cos(\\theta - \\phi)} \\frac{1}{2\\pi \\rho_s} = \\frac{1}{2\\pi} \\int_0^{2\\pi} d\\theta \\, e^{-i k_\\perp \\rho_s \\cos(\\theta - \\phi)}\n$$\n该积分的结果与角度 $\\phi$ 无关，我们可以通过旋转坐标系将其设为零。令 $\\theta' = \\theta$，我们得到：\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = \\frac{1}{2\\pi} \\int_0^{2\\pi} d\\theta' \\, e^{-i k_\\perp \\rho_s \\cos(\\theta')}\n$$\n这是第一类零阶贝塞尔函数 $J_0(z)$ 的一个标准积分表示。这可以通过使用平面波的 Jacobi-Anger 展开来正式证明：\n$$\ne^{iz\\cos\\theta} = \\sum_{n=-\\infty}^{+\\infty} i^n J_n(z) e^{in\\theta}\n$$\n对两边关于 $\\theta$ 从 $0$ 到 $2\\pi$ 积分：\n$$\n\\int_0^{2\\pi} e^{iz\\cos\\theta} d\\theta = \\sum_{n=-\\infty}^{+\\infty} i^n J_n(z) \\int_0^{2\\pi} e^{in\\theta} d\\theta\n$$\n积分 $\\int_0^{2\\pi} e^{in\\theta} d\\theta$ 在 $n=0$ 时等于 $2\\pi$，对于任何非零整数 $n$ 等于 $0$。因此，无穷级数塌陷为 $n=0$ 的单项：\n$$\n\\int_0^{2\\pi} e^{iz\\cos\\theta} d\\theta = i^0 J_0(z) \\cdot (2\\pi) = 2\\pi J_0(z)\n$$\n因此，当 $z = -k_\\perp \\rho_s$ 并使用 $J_0(-z) = J_0(z)$ 时，我们确认：\n$$\n\\hat{G}_{\\rho_s}(\\mathbf{k}) = J_0(k_\\perp \\rho_s)\n$$\n傅里叶空间中的回旋平均算符就是乘以 $J_0(k_\\perp \\rho_s)$。\n\n对于离散网格上的数值实现，我们遵循以下步骤：\n1.  **参数计算**：首先，使用提供的物理常数和参数计算每种粒子 $s \\in \\{i, e\\}$ 的热回旋半径 $\\rho_s$。以电子伏特 (eV) 为单位的温度 $T_s$ 通过乘以基本电荷 $e$ 转换为焦耳 (J)。热速度为 $v_{\\mathrm{th},s} = \\sqrt{2 T_s / m_s}$，回旋频率为 $\\Omega_s = |q_s| B_0 / m_s$，回旋半径为 $\\rho_s = v_{\\mathrm{th},s} / \\Omega_s$。\n\n2.  **网格和场构建**：构建一个大小为 $N_x \\times N_y$ 的均匀二维网格，其点为 $(x_j, y_l) = (j \\Delta x, l \\Delta y)$，其中 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。在此网格上计算输入场 $h_s(x,y)$。\n\n3.  **傅里叶正变换**：使用快速傅里叶变换 (FFT) 算法计算每个场 $h_s(x_j, y_l)$ 的二维离散傅里叶变换，以获得谱系数 $\\hat{h}_s(k_{x,m}, k_{y,n})$。按规定，正变换是未归一化的。\n\n4.  **波数网格**：构建相应的离散波数网格。波数由 $k_{x,m} = 2\\pi m/L_x$（其中 $m \\in \\{-N_x/2, \\dots, N_x/2-1\\}$）和 $k_{y,n} = 2\\pi n/L_y$（其中 $n \\in \\{-N_y/2, \\dots, N_y/2-1\\}$）给出。对于此网格中的每个点 $(k_{x,m}, k_{y,n})$，计算垂直波数大小 $k_\\perp = \\sqrt{k_{x,m}^2 + k_{y,n}^2}$。\n\n5.  **谱组装**：每种粒子的回旋平均场的谱表示为 $\\hat{\\langle h_s \\rangle}(\\mathbf{k}) = J_0(k_\\perp \\rho_s) \\hat{h}_s(\\mathbf{k})$。总的组装谱场 $\\hat{s}(\\mathbf{k})$ 是对所有粒子种类的求和：\n    $$\n    \\hat{s}(k_{x,m}, k_{y,n}) = \\sum_s J_0(k_\\perp \\rho_s) \\hat{h}_s(k_{x,m}, k_{y,n})\n    $$\n\n6.  **傅里叶逆变换**：使用二维离散傅里叶逆变换将得到的谱场 $\\hat{s}(\\mathbf{k})$ 变换回实空间，以获得最终场 $s(x,y)$。逆变换必须用因子 $1/(N_x N_y)$ 进行归一化。\n    $$\n    s(x_j, y_l) = \\frac{1}{N_x N_y} \\sum_{m=0}^{N_x-1} \\sum_{n=0}^{N_y-1} \\hat{s}(k_{x,m}, k_{y,n}) e^{i (k_{x,m} x_j + k_{y,n} y_l)}\n    $$\n\n7.  **诊断量计算**：最后，计算实空间场 $s(x,y)$ 的均方根 (RMS) 振幅。由于输入是实数，且核 $J_0$ 是实偶函数，$s(x,y)$ 将是纯实数（在机器精度范围内）。RMS 计算如下：\n    $$\n    \\mathrm{RMS} = \\sqrt{\\frac{1}{N_x N_y} \\sum_{j=0}^{N_x-1} \\sum_{l=0}^{N_y-1} \\left( s(x_j,y_l) \\right)^2 }\n    $$\n这个过程提供了一种计算效率高且准确的方法来应用回旋平均算符，利用了快速傅里叶变换的强大功能。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import j0\n\ndef solve():\n    \"\"\"\n    Computes the RMS amplitude of a gyro-averaged field in a plasma\n    for a series of test cases.\n    \"\"\"\n\n    # Physical constants\n    e = 1.602176634e-19  # Elementary charge in Coulomb\n    m_p = 1.67262192369e-27  # Proton mass in kg\n    m_i = 2.0 * m_p         # Deuteron mass in kg\n    m_e = 9.1093837015e-31  # Electron mass in kg\n\n    # Test suite from the problem statement\n    test_cases = [\n        {\n            \"description\": \"Case 1: happy path, mixed species contributions\",\n            \"Nx\": 32, \"Ny\": 24, \"Lx\": 0.3, \"Ly\": 0.25,\n            \"B0\": 3.0, \"Ti\": 2000, \"Te\": 1000,\n            \"hi_func\": lambda x, y, Lx, Ly: np.cos(2 * np.pi * x / Lx) * np.cos(4 * np.pi * y / Ly),\n            \"he_func\": lambda x, y, Lx, Ly: 0.25 * np.sin(2 * np.pi * x / Lx) * np.cos(2 * np.pi * y / Ly)\n        },\n        {\n            \"description\": \"Case 2: boundary condition, zero field\",\n            \"Nx\": 32, \"Ny\": 24, \"Lx\": 0.3, \"Ly\": 0.25,\n            \"B0\": 3.0, \"Ti\": 2000, \"Te\": 1000,\n            \"hi_func\": lambda x, y, Lx, Ly: np.zeros_like(x),\n            \"he_func\": lambda x, y, Lx, Ly: np.zeros_like(x)\n        },\n        {\n            \"description\": \"Case 3: edge case, large ion gyroradius and higher wavenumber\",\n            \"Nx\": 48, \"Ny\": 48, \"Lx\": 0.4, \"Ly\": 0.4,\n            \"B0\": 0.5, \"Ti\": 15000, \"Te\": 500,\n            \"hi_func\": lambda x, y, Lx, Ly: np.cos(6 * np.pi * x / Lx) * np.cos(6 * np.pi * y / Ly),\n            \"he_func\": lambda x, y, Lx, Ly: np.zeros_like(x)\n        },\n        {\n            \"description\": \"Case 4: electron small gyroradius limit with overlapping modes\",\n            \"Nx\": 64, \"Ny\": 32, \"Lx\": 0.2, \"Ly\": 0.3,\n            \"B0\": 5.0, \"Ti\": 3000, \"Te\": 100,\n            \"hi_func\": lambda x, y, Lx, Ly: 0.7 * np.cos(2 * np.pi * 3 * x / Lx) * np.cos(2 * np.pi * 2 * y / Ly),\n            \"he_func\": lambda x, y, Lx, Ly: 0.3 * np.cos(2 * np.pi * 3 * x / Lx) * np.cos(2 * np.pi * 2 * y / Ly)\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        Nx, Ny = case[\"Nx\"], case[\"Ny\"]\n        Lx, Ly = case[\"Lx\"], case[\"Ly\"]\n        B0, Ti_eV, Te_eV = case[\"B0\"], case[\"Ti\"], case[\"Te\"]\n\n        # Calculate gyroradii for ions and electrons\n        species_params = {\n            'i': {'T_eV': Ti_eV, 'm': m_i, 'q': e},\n            'e': {'T_eV': Te_eV, 'm': m_e, 'q': e}\n        }\n        \n        rho_s = {}\n        for s, params in species_params.items():\n            T_J = params['T_eV'] * e  # Temperature in Joules\n            v_th = np.sqrt(2 * T_J / params['m'])\n            Omega = params['q'] * B0 / params['m']\n            rho_s[s] = v_th / Omega\n\n        # Create computational grid\n        dx, dy = Lx / Nx, Ly / Ny\n        x = np.arange(0, Lx, dx)\n        y = np.arange(0, Ly, dy)\n        xx, yy = np.meshgrid(x, y, indexing='ij')\n\n        # Generate input fields on the grid\n        h_i = case[\"hi_func\"](xx, yy, Lx, Ly)\n        h_e = case[\"he_func\"](xx, yy, Lx, Ly)\n\n        # Compute 2D FFT of input fields\n        h_hat_i = np.fft.fft2(h_i)\n        h_hat_e = np.fft.fft2(h_e)\n\n        # Create wavenumber grid\n        kx = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n        ky = 2 * np.pi * np.fft.fftfreq(Ny, d=dy)\n        kxx, kyy = np.meshgrid(kx, ky, indexing='ij')\n        k_perp = np.sqrt(kxx**2 + kyy**2)\n\n        # Evaluate gyroaveraging kernel J0(k_perp * rho_s)\n        J0_i = j0(k_perp * rho_s['i'])\n        J0_e = j0(k_perp * rho_s['e'])\n\n        # Assemble the spectral field operator\n        s_hat = J0_i * h_hat_i + J0_e * h_hat_e\n\n        # Transform back to real space\n        s_xy = np.fft.ifft2(s_hat)\n        \n        # The result must be real; take the real part to discard numerical noise\n        s_xy_real = s_xy.real\n\n        # Calculate the RMS diagnostic\n        rms = np.sqrt(np.mean(s_xy_real**2))\n        results.append(rms)\n\n    # Format and print the final results\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本节我们将注意力转向数值求解器的另一个关键方面：保持基本物理定律。本练习探讨了对磁场的无散约束，即 $\\nabla \\cdot \\mathbf{B} = 0$，这在电磁模拟中至关重要。通过在交错网格上实现一个离散格式，您将亲手验证特定的离散化选择如何能够将此恒等式维持在机器精度，这是“模拟”或“保结构”算法的一个关键特征。",
            "id": "4197736",
            "problem": "您的任务是实现并验证一个离散的、保结构的数值恒等式，该恒等式在求解聚变等离子体湍流模拟中的回旋动理学场方程时至关重要。在低频回旋动理学近似下，扰动磁场由矢量势的平行分量表示。令 $A_{\\parallel}$ 表示矢量势的平行分量，并令 $\\hat{\\mathbf{b}}_{0}$ 为与背景磁场对齐的恒定单位矢量。扰动磁场由旋度关系定义\n$$\n\\delta \\mathbf{B} = \\nabla \\times \\left( A_{\\parallel} \\, \\hat{\\mathbf{b}}_{0} \\right).\n$$\n对于 $\\hat{\\mathbf{b}}_{0} = \\hat{\\mathbf{z}}$ 均匀的系统，这可简化为二维形式\n$$\n\\delta B_x = \\frac{\\partial A_{\\parallel}}{\\partial y}, \\quad \\delta B_y = -\\frac{\\partial A_{\\parallel}}{\\partial x}, \\quad \\delta B_z = 0.\n$$\n经典矢量微积分的一个基本恒等式是\n$$\n\\nabla \\cdot (\\nabla \\times \\mathbf{F}) = 0,\n$$\n一个构造良好的数值格式必须在离散形式下保持此恒等式，以避免 $\\mathbf{B}$ 中出现非物理性的散度误差累积。\n\n在一个二维周期性、均匀、交错（Yee-型）网格上实现一个满足此恒等式的离散格式。具体来说，使用以下网格分配和操作：\n\n1. 将标量场 $A_{\\parallel}$ 放置在由 $(i,j)$ 索引的单元中心，其中 $i = 0,1,\\dots,N_x-1$ 且 $j = 0,1,\\dots,N_y-1$。设计算域为 $[0,L_x] \\times [0,L_y]$，均匀间距为 $d_x = L_x/N_x$ 和 $d_y = L_y/N_y$。单元中心的坐标为\n$$\nx_i = \\left(i + \\frac{1}{2}\\right) d_x, \\quad y_j = \\left(j + \\frac{1}{2}\\right) d_y.\n$$\n所有三角函数必须使用弧度。\n\n2. 在交错位置上定义 $A_{\\parallel}$ 的平均值：\n$$\nA^{x}_{i+1/2,j} = \\frac{A_{i+1,j} + A_{i,j}}{2}, \\quad A^{y}_{i,j+1/2} = \\frac{A_{i,j+1} + A_{i,j}}{2}.\n$$\n\n3. 在适当的交错位置上使用中心差分定义面心磁场分量：\n$$\n\\delta B_x\\big|_{i+1/2,j} = \\frac{A^{x}_{i+1/2,j+1} - A^{x}_{i+1/2,j-1}}{2 d_y}, \\quad\n\\delta B_y\\big|_{i,j+1/2} = -\\frac{A^{y}_{i+1,j+1/2} - A^{y}_{i-1,j+1/2}}{2 d_x}.\n$$\n此处，对所有越界索引使用周期性边界条件，例如，$A_{N_x,j} \\equiv A_{0,j}$ 和 $A_{i,N_y} \\equiv A_{i,0}$。\n\n4. 使用有限体积形式计算单元中心的离散散度：\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = \\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x} + \\frac{\\delta B_y\\big|_{i,j+1/2} - \\delta B_y\\big|_{i,j-1/2}}{d_y},\n$$\n索引采用周期性边界条件。\n\n您的程序必须：\n- 为以下每个测试案例构造 $A_{\\parallel}(x_i,y_j)$。\n- 使用上述定义计算 $\\delta B_x$、$\\delta B_y$，然后计算 $(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j}$。\n- 对于每个测试案例，返回一个标量，该标量等于所有单元上离散散度的最大绝对值：\n$$\n\\max_{i,j} \\left| (\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} \\right|.\n$$\n在定义所隐含的归一化下，该量是无量纲的。\n\n角度单位要求：所有空间坐标的三角函数必须使用弧度。\n\n测试套件：\n请提供以下四个测试案例的结果。在所有案例中，均按规定应用周期性边界条件，并使用 IEEE-754 双精度算术。\n\n- 案例 1（平滑、周期性）：$N_x = 8$，$N_y = 8$，$L_x = 2\\pi$，$L_y = 2\\pi$，其中\n$$\nA_{\\parallel}(x,y) = \\sin(3x) + \\cos(2y).\n$$\n\n- 案例 2（随机场、可复现）：$N_x = 64$，$N_y = 64$，$L_x = 1.0$，$L_y = 0.6$。通过在单元中心使用固定的随机种子 $s=1$ 从 $[0,1)$ 上的均匀分布中抽取独立样本来构造 $A_{\\parallel}$。\n\n- 案例 3（各向异性平滑）：$N_x = 4$，$N_y = 10$，$L_x = \\pi$，$L_y = 2\\pi$，其中\n$$\nA_{\\parallel}(x,y) = \\sin(x)\\sin(y).\n$$\n\n- 案例 4（更高波数、混合周期）：$N_x = 128$，$N_y = 63$，$L_x = 3.0$，$L_y = 1.3$，其中\n$$\nA_{\\parallel}(x,y) = \\cos(13x) + \\sin(9y).\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个结果，按上述案例顺序排列，以逗号分隔并用方括号括起。例如：\n\"[r1,r2,r3,r4]\"\n每个 $r_k$ 必须是浮点数（采用十进制表示法或科学记数法）。",
            "solution": "目标是在均匀背景方向 $\\hat{\\mathbf{b}}_{0} = \\hat{\\mathbf{z}}$ 的回旋动理学磁场表示 $\\delta \\mathbf{B} = \\nabla \\times (A_{\\parallel} \\hat{\\mathbf{b}}_{0})$ 的背景下，实现恒等式 $\\nabla \\cdot (\\nabla \\times \\mathbf{F}) = 0$ 的离散版本。在此假设下，连续关系得出 $\\delta B_x = \\partial_y A_{\\parallel}$ 和 $\\delta B_y = -\\partial_x A_{\\parallel}$。连续散度则为\n$$\n\\nabla \\cdot \\delta \\mathbf{B} = \\partial_x \\left(\\partial_y A_{\\parallel}\\right) + \\partial_y \\left(-\\partial_x A_{\\parallel}\\right) = \\partial_x \\partial_y A_{\\parallel} - \\partial_y \\partial_x A_{\\parallel} = 0,\n$$\n这里利用了在平滑性假设下混合偏导数的可交换性。\n\n为了在离散形式下保持此性质，我们选择一个模拟微分算子复形的 Yee-型交错网格。构造如下：\n\n1. $A_{\\parallel}$ 存储在间距为 $d_x$ 和 $d_y$ 的单元中心 $(i,j)$ 上，并在两个方向上施加周期性边界条件。定义 $A_{\\parallel}$ 的三角函数使用弧度，以确保空间傅里叶模式的物理一致性。\n\n2. 在半整数位置上定义 $A_{\\parallel}$ 的交错平均值：\n$$\nA^{x}_{i+1/2,j} = \\frac{A_{i+1,j} + A_{i,j}}{2}, \\quad A^{y}_{i,j+1/2} = \\frac{A_{i,j+1} + A_{i,j}}{2}.\n$$\n这些值在将要计算关于正交坐标的导数的位置上，为 $A_{\\parallel}$ 提供了相容的近似。\n\n3. 使用与平均方向正交的中心差分计算面心磁场分量：\n$$\n\\delta B_x\\big|_{i+1/2,j} = \\frac{A^{x}_{i+1/2,j+1} - A^{x}_{i+1/2,j-1}}{2 d_y}, \\quad\n\\delta B_y\\big|_{i,j+1/2} = -\\frac{A^{y}_{i+1,j+1/2} - A^{y}_{i-1,j+1/2}}{2 d_x}.\n$$\n周期性边界条件确保索引能够正确地循环。\n\n4. 离散散度通过单元中心的有限体积平衡得到：\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = \\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x} + \\frac{\\delta B_y\\big|_{i,j+1/2} - \\delta B_y\\big|_{i,j-1/2}}{d_y}.\n$$\n\n保结构恒等式的原理推导：\n所选格式的设计使得对于任何 $A_{\\parallel}$，离散旋度的离散散度在机器舍入误差范围内恒等于零。要理解这一点，请考虑 $x$ 方向的贡献：\n$$\n\\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x}\n= \\frac{1}{d_x} \\left[ \\frac{A^{x}_{i+1/2,j+1} - A^{x}_{i+1/2,j-1}}{2 d_y} - \\frac{A^{x}_{i-1/2,j+1} - A^{x}_{i-1/2,j-1}}{2 d_y} \\right]\n= \\frac{1}{2 d_x d_y} \\left[ (A^{x}_{i+1/2,j+1} - A^{x}_{i-1/2,j+1}) - (A^{x}_{i+1/2,j-1} - A^{x}_{i-1/2,j-1}) \\right].\n$$\n注意到\n$$\nA^{x}_{i+1/2,j} - A^{x}_{i-1/2,j} = \\frac{A_{i+1,j} + A_{i,j}}{2} - \\frac{A_{i,j} + A_{i-1,j}}{2} = \\frac{A_{i+1,j} - A_{i-1,j}}{2},\n$$\n我们可以将 $x$ 方向的贡献重写为一个中心 $x$ 导数的中心 $y$ 导数：\n$$\n\\frac{\\delta B_x\\big|_{i+1/2,j} - \\delta B_x\\big|_{i-1/2,j}}{d_x} = \\frac{1}{2 d_y} \\left[ \\frac{A_{i+1,j+1} - A_{i-1,j+1}}{2 d_x} - \\frac{A_{i+1,j-1} - A_{i-1,j-1}}{2 d_x} \\right] = \\partial^{h}_y \\left( \\partial^{h}_x A_{\\parallel} \\right)\\Big|_{i,j},\n$$\n其中 $\\partial^{h}_x$ 和 $\\partial^{h}_y$ 表示中心离散导数。类似地，对于 $y$ 方向的贡献，\n$$\n\\frac{\\delta B_y\\big|_{i,j+1/2} - \\delta B_y\\big|_{i,j-1/2}}{d_y} = -\\partial^{h}_x \\left( \\partial^{h}_y A_{\\parallel} \\right)\\Big|_{i,j}.\n$$\n因此，\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = \\partial^{h}_y \\left( \\partial^{h}_x A_{\\parallel} \\right)\\Big|_{i,j} - \\partial^{h}_x \\left( \\partial^{h}_y A_{\\parallel} \\right)\\Big|_{i,j}.\n$$\n在带有周期性边界条件的均匀网格上，中心离散导数是可交换的，即 $\\partial^{h}_y \\partial^{h}_x A_{\\parallel} = \\partial^{h}_x \\partial^{h}_y A_{\\parallel}$，从而得到\n$$\n(\\nabla_h \\cdot \\delta \\mathbf{B})_{i,j} = 0,\n$$\n结果在浮点舍入误差范围内成立。这是 $\\nabla \\cdot (\\nabla \\times \\mathbf{F}) = 0$ 的离散模拟，通过构成保结构格式的交错布局和平均导数实现。\n\n算法步骤：\n- 构建网格和 $A_{\\parallel}(x_i,y_j)$。\n- 通过周期性平均计算 $A^{x}_{i+1/2,j}$ 和 $A^{y}_{i,j+1/2}$。\n- 在交错位置上使用中心差分和周期性索引计算 $\\delta B_x$ 和 $\\delta B_y$。\n- 使用面通量差分计算单元中心的离散散度。\n- 为每个测试案例返回所有单元上的最大绝对散度。\n\n数值预期：\n由于浮点运算，对于双精度（约 $10^{-16}$ 到 $10^{-15}$），计算出的最大值应在机器精度量级，尽管由于函数求值和差分中的累积，可能会有微小增加。报告的值是无量纲标量。\n\n程序将按指定测试套件的顺序，以“[r1,r2,r3,r4]”的格式单行输出四个最大值。",
            "answer": "```python\nimport numpy as np\n\ndef compute_max_abs_divergence(Nx, Ny, Lx, Ly, A_builder):\n    # Grid spacings\n    dx = Lx / Nx\n    dy = Ly / Ny\n\n    # Cell-centered coordinates (radians for any trigonometric A_builder)\n    xi = (np.arange(Nx) + 0.5) * dx\n    yj = (np.arange(Ny) + 0.5) * dy\n\n    # Build A_parallel at cell centers\n    A = A_builder(xi, yj)  # shape (Nx, Ny)\n\n    # Periodic index helpers\n    ip1 = lambda i: (i + 1) % Nx\n    im1 = lambda i: (i - 1) % Nx\n    jp1 = lambda j: (j + 1) % Ny\n    jm1 = lambda j: (j - 1) % Ny\n\n    # Staggered averages: A^x at (i+1/2, j), A^y at (i, j+1/2)\n    A_xavg = 0.5 * (A + A[np.array([ip1(i) for i in range(Nx)]), :])\n    A_yavg = 0.5 * (A + A[:, np.array([jp1(j) for j in range(Ny)])])\n\n    # Compute Bx at (i+1/2, j): centered difference in y\n    Bx = np.empty((Nx, Ny), dtype=np.float64)\n    for i in range(Nx):\n        for j in range(Ny):\n            Bx[i, j] = (A_xavg[i, jp1(j)] - A_xavg[i, jm1(j)]) / (2.0 * dy)\n\n    # Compute By at (i, j+1/2): centered difference in x, with negative sign\n    By = np.empty((Nx, Ny), dtype=np.float64)\n    for i in range(Nx):\n        for j in range(Ny):\n            By[i, j] = -(A_yavg[ip1(i), j] - A_yavg[im1(i), j]) / (2.0 * dx)\n\n    # Compute divergence at cell centers\n    divB = np.empty((Nx, Ny), dtype=np.float64)\n    for i in range(Nx):\n        for j in range(Ny):\n            term_x = (Bx[i, j] - Bx[im1(i), j]) / dx\n            term_y = (By[i, j] - By[i, jm1(j)]) / dy\n            divB[i, j] = term_x + term_y\n\n    # Return maximum absolute divergence\n    return float(np.max(np.abs(divB)))\n\n\ndef solve():\n    # Define A_builder functions for each test case\n    def A_case1(xi, yj):\n        # A(x,y) = sin(3x) + cos(2y), radians\n        X, Y = np.meshgrid(xi, yj, indexing='ij')\n        return np.sin(3.0 * X) + np.cos(2.0 * Y)\n\n    def A_case2(xi, yj):\n        # Random uniform [0,1) at cell centers with fixed seed\n        rng = np.random.default_rng(seed=1)\n        return rng.random((len(xi), len(yj)), dtype=np.float64)\n\n    def A_case3(xi, yj):\n        # A(x,y) = sin(x) sin(y), radians\n        X, Y = np.meshgrid(xi, yj, indexing='ij')\n        return np.sin(X) * np.sin(Y)\n\n    def A_case4(xi, yj):\n        # A(x,y) = cos(13x) + sin(9y), radians\n        X, Y = np.meshgrid(xi, yj, indexing='ij')\n        return np.cos(13.0 * X) + np.sin(9.0 * Y)\n\n    # Test cases: (Nx, Ny, Lx, Ly, A_builder)\n    test_cases = [\n        (8, 8, 2.0 * np.pi, 2.0 * np.pi, A_case1),\n        (64, 64, 1.0, 0.6, A_case2),\n        (4, 10, np.pi, 2.0 * np.pi, A_case3),\n        (128, 63, 3.0, 1.3, A_case4),\n    ]\n\n    results = []\n    for Nx, Ny, Lx, Ly, A_builder in test_cases:\n        max_abs_div = compute_max_abs_divergence(Nx, Ny, Lx, Ly, A_builder)\n        results.append(max_abs_div)\n\n    # Print in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}