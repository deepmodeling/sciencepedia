{
    "hands_on_practices": [
        {
            "introduction": "我们的第一个实践是构建一个不变量回归测试。这个练习将通过两个简单的典范物理模型——用于能量守恒的哈密顿振子和用于电荷守恒的线性平流方程——来清晰地展示保结构积分器与非保结构积分器之间的根本差异。通过亲手实现和对比，你将直观地理解数值方法的选择如何直接影响模拟的长期保真度，并为更复杂的应用打下坚实的基础。",
            "id": "4191850",
            "problem": "您的任务是编写一个完整的程序，为与聚变等离子体湍流模拟相关的无量纲简化模型实现不变量回归测试。目标是量化隐式和保结构时间积分格式如何影响不变量的守恒，并展示此类测试对方法和容差选择的敏感性。您必须为一个小型测试套件以布尔值的形式输出通过或失败的判定。所有数学运算都必须按无量纲处理。\n\n您可以使用的基本原理是：\n\n- 单模线性系统的哈密顿力学：对于具有哈密顿量 $H(q,p)=\\tfrac{1}{2}p^2+\\tfrac{1}{2}\\omega^2 q^2$ 的正则对 $(q,p)$，其哈密顿方程为 $\\dot{q}=+\\partial H/\\partial p=p$ 和 $\\dot{p}=-\\partial H/\\partial q=-\\omega^2 q$。精确不变量是总能量 $E=\\tfrac{1}{2}p^2+\\tfrac{1}{2}\\omega^2 q^2$。\n- 在长度为 $L$ 的域上，具有恒定速度 $v$ 的一维周期性电荷密度 $\\rho(x,t)$ 的连续性方程：$\\partial_t \\rho + \\partial_x (v \\rho) = 0$。精确不变量是总电荷 $Q(t)=\\int_0^L \\rho(x,t)\\,\\mathrm{d}x$，对于周期性边界，它满足 $\\mathrm{d}Q/\\mathrm{d}t=0$。\n- 隐式中点法，对于 $\\dot{y}=f(y)$ 定义如下：给定时间步长 $\\Delta t$，求 $y_{n+1}$ 使得 $y_{n+1}=y_n+\\Delta t\\, f\\!\\left(\\tfrac{1}{2}(y_n+y_{n+1})\\right)$。此方法对于正则哈密顿系统是保辛的，并且在线性问题和相容的空间离散化下保留二次不变量。\n- 在具有 $N$ 个点和间距 $\\Delta x=L/N$ 的均匀周期网格上，标准的中心有限差分空间导数定义为 $(\\partial_x \\rho)_i \\approx (\\rho_{i+1}-\\rho_{i-1})/(2\\Delta x)$，其中指数进行周期性环绕。该离散导数在 $\\ell^2$ 内积下是斜对称的，并且列和为零，这意味着与隐式中点时间步进结合使用时，离散总电荷在求解器容差范围内是精确守恒的。\n\n您的程序必须实现两个子系统及其不变量测试：\n\n1) 线性哈密顿振子中的能量守恒。考虑系统 $\\dot{q}=p$, $\\dot{p}=-\\omega^2 q$，初始条件为 $q(0)=q_0$, $p(0)=p_0$。在大小为 $\\Delta t$ 的 $N_{\\text{steps}}$ 个均匀步长上实现两种时间步进方法：\n- 一种保结构的隐式中点法。\n- 一种非保结构的前向欧拉法。\n将 $N_{\\text{steps}}$ 步后的能量不变量误差定义为相对误差 $\\varepsilon_E = \\lvert E_{N_{\\text{steps}}}-E_0\\rvert/\\lvert E_0\\rvert$，其中 $E_n=\\tfrac{1}{2}p_n^2+\\tfrac{1}{2}\\omega^2 q_n^2$。如果 $\\varepsilon_E \\le \\text{tol}$，则测试通过，否则失败。\n\n2) 线性平流中的电荷守恒。考虑在长度为 $L$ 的周期域上的方程 $\\partial_t \\rho + v \\partial_x \\rho = 0$，该域在具有 $N$ 个点和间距 $\\Delta x=L/N$ 的均匀网格上离散化，初始条件为 $\\rho(x,0)=1+0.1\\sin(2\\pi x/L)$。在大小为 $\\Delta t$ 的 $N_{\\text{steps}}$ 个均匀步长上实现两种方法：\n- 将保结构的隐式中点法应用于带有中心有限差分导数的线方法半离散化。\n- 用于周期性平流的带线性插值的非守恒半拉格朗日方法。\n将总电荷定义为 $Q_n=\\sum_{i=0}^{N-1} \\rho_i^{(n)} \\Delta x$。将 $N_{\\text{steps}}$ 步后的电荷不变量误差定义为相对误差 $\\varepsilon_Q = \\lvert Q_{N_{\\text{steps}}}-Q_0\\rvert/\\lvert Q_0\\rvert$。如果 $\\varepsilon_Q \\le \\text{tol}$，则测试通过，否则失败。\n\n您必须实现上述内容并运行以下测试套件。对于每种情况，当且仅当相应的不变量误差不超过给定的容差时，您必须输出一个布尔值来指示通过 (true)。\n\n以下所有量均为无量纲，因此不需要物理单位。\n\n测试套件：\n- 情况1（能量，守恒）：参数 $(\\omega,\\Delta t,N_{\\text{steps}},q_0,p_0,\\text{tol})=(1.7, 0.2, 200, 1.0, 0.0, 1 \\times 10^{-10})$，使用隐式中点法。\n- 情况2（能量，非守恒）：参数 $(\\omega,\\Delta t,N_{\\text{steps}},q_0,p_0,\\text{tol})=(1.7, 0.2, 200, 1.0, 0.0, 1 \\times 10^{-3})$，使用前向欧拉法。\n- 情况3（电荷，守恒）：参数 $(N,L,v,\\Delta t,N_{\\text{steps}},\\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1 \\times 10^{-12})$，使用带中心有限差分的隐式中点法。\n- 情况4（电荷，非守恒，紧容差）：参数 $(N,L,v,\\Delta t,N_{\\text{steps}},\\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1 \\times 10^{-6})$，使用半拉格朗日线性插值。\n- 情况5（电荷，非守恒，松容差）：参数 $(N,L,v,\\Delta t,N_{\\text{steps}},\\text{tol})=(64, 1.0, 1.0, 0.1, 400, 1 \\times 10^{-1})$，使用半拉格朗日线性插值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试套件相同。例如，输出必须具有“[result1,result2,result3,result4,result5]”的形式，其中每个结果都是您编程语言标准打印约定中的布尔字面量。\n\n您的实现必须是自包含的，并且不得需要任何输入。您实现的数值算法对于所提供的参数必须是正确和稳健的。唯一可接受的输出是如上所述的布尔结果，不带任何额外的文本或格式。",
            "solution": "该问题要求为两个基本物理系统实现并验证数值时间积分格式，重点关注物理不变量的守恒。此任务是模拟代码开发中的一个标准程序，尤其是在聚变等离子体物理等领域，其中长期稳定性和保真度至关重要。我们将处理两个子系统：一个模拟线性哈密顿系统中单模的简谐振子，以及一个模拟输运的线性平流方程。对于每个子系统，我们将比较一个保结构积分器和一个非保结构积分器。\n\n对问题陈述的验证证实了其科学上的合理性、适定性，并包含了进行求解所需的所有必要信息。所有模型、数值方法和参数都是标准的且定义清晰。\n\n首先，我们考虑单模线性哈密顿系统，即一个简谐振子。其状态由正则坐标对 $(q, p)$ 描述。哈密顿量 $H$ 是系统的总能量，由 $H(q,p) = \\frac{1}{2}p^2 + \\frac{1}{2}\\omega^2 q^2$ 给出，其中 $\\omega$ 是角频率。动力学由哈密顿方程决定：\n$$ \\dot{q} = \\frac{\\partial H}{\\partial p} = p $$\n$$ \\dot{p} = -\\frac{\\partial H}{\\partial q} = -\\omega^2 q $$\n在精确解中，哈密顿量 $H$ 是一个运动常数，即一个不变量。我们将测试两种数值方法在守恒此能量方面的能力。设状态向量为 $\\mathbf{y} = [q, p]^T$。该系统可以写成一个线性常微分方程 (ODE)：$\\dot{\\mathbf{y}} = A \\mathbf{y}$，其中矩阵 $A$ 为\n$$ A = \\begin{pmatrix} 0  1 \\\\ -\\omega^2  0 \\end{pmatrix} $$\n初始条件为 $\\mathbf{y}(0) = [q_0, p_0]^T$。在时间步 $n$ 的数值解表示为 $\\mathbf{y}_n = [q_n, p_n]^T$。在步数 $n$ 的能量为 $E_n = \\frac{1}{2}p_n^2 + \\frac{1}{2}\\omega^2 q_n^2$。测试评估相对误差 $\\varepsilon_E = |E_{N_{\\text{steps}}} - E_0| / |E_0|$。\n\n第一种方法是**隐式中点法**。对于一个常微分方程 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$，单步由以下隐式方程给出：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f\\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right) $$\n对于我们的线性系统，$f(\\mathbf{y}) = A \\mathbf{y}$，因此这变为：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t A \\left(\\frac{\\mathbf{y}_n + \\mathbf{y}_{n+1}}{2}\\right) $$\n为求解 $\\mathbf{y}_{n+1}$ 进行重排，我们得到一个需要求解的线性系统：\n$$ \\left(I - \\frac{\\Delta t}{2} A\\right) \\mathbf{y}_{n+1} = \\left(I + \\frac{\\Delta t}{2} A\\right) \\mathbf{y}_n $$\n解由单步更新规则 $\\mathbf{y}_{n+1} = M_{\\text{IM}} \\mathbf{y}_n$ 给出，其中更新矩阵为 $M_{\\text{IM}} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right)$。隐式中点法是一种辛积分器，意味着它能保持哈密顿系统的几何结构。对于像这样的二次哈密顿量，已知它能精确守恒能量，直至浮点精度。因此，对于情况1，我们期望能量误差 $\\varepsilon_E$ 会非常小，远在 $1 \\times 10^{-10}$ 的容差之内。\n\n第二种方法是**前向欧拉法**。这是一种显式的、非保结构的方法。单步由以下公式给出：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, f(\\mathbf{y}_n) = (I + \\Delta t A) \\mathbf{y}_n $$\n更新矩阵 $M_{\\text{FE}} = I + \\Delta t A$ 的特征值为 $1 \\pm i\\omega\\Delta t$，二者的模都为 $\\sqrt{1 + (\\omega\\Delta t)^2} > 1$。这意味着数值解是不稳定的，$(q,p)$ 的振幅将随每一步增长。因此，能量 $E_n$ 将系统性地增加。对于情况2，当 $\\omega=1.7, \\Delta t=0.2, N_{\\text{steps}}=200$ 时，我们预计能量会有显著增加，导致误差 $\\varepsilon_E$ 远超过 $1 \\times 10^{-3}$ 的容差。\n\n其次，我们考虑在一维周期域（长度为 $L$）上，具有恒定速度 $v$ 的电荷密度 $\\rho(x,t)$ 的线性平流方程：\n$$ \\frac{\\partial \\rho}{\\partial t} + v \\frac{\\partial \\rho}{\\partial x} = 0 $$\n总电荷 $Q(t) = \\int_0^L \\rho(x,t) \\, \\mathrm{d}x$ 是一个精确不变量。我们在一个由 $N$ 个点 $x_i = i \\Delta x$（其中 $\\Delta x = L/N$）组成的均匀周期网格上离散化该系统。离散总电荷为 $Q_n = \\sum_{i=0}^{N-1} \\rho_i^{(n)} \\Delta x$，其中 $\\rho_i^{(n)}$ 是在网格点 $i$ 和时间步 $n$ 的密度。测试评估相对误差 $\\varepsilon_Q = |Q_{N_{\\text{steps}}} - Q_0| / |Q_0|$。初始条件为 $\\rho(x,0)=1+0.1\\sin(2\\pi x/L)$。对于此分布，离散初始电荷恰好为 $Q_0 = L$。\n\n第一种方法将**中心有限差分**空间离散化与**隐式中点**时间积分相结合。这是一种线方法。空间导数近似为 $(\\partial_x \\rho)_i \\approx (\\rho_{i+1} - \\rho_{i-1}) / (2\\Delta x)$。这定义了一个微分矩阵 $D$，使得半离散化系统为 $\\frac{d\\vec{\\rho}}{dt} = -vD\\vec{\\rho}$，其中 $\\vec{\\rho}$ 是网格值的向量。矩阵 $D$ 是循环且斜对称的 ($D^T = -D$)，这意味着其列和为零。应用隐式中点法可得到更新式 $\\vec{\\rho}_{n+1} = \\left(I + \\frac{v\\Delta t}{2}D\\right)^{-1} \\left(I - \\frac{v\\Delta t}{2}D\\right) \\vec{\\rho}_n$。因为 $D$ 的列和为零，可以从数学上证明，此更新矩阵完全保持 $\\vec{\\rho}$ 元素之和。因此，离散总电荷 $Q_n$ 在浮点误差范围内是守恒的。对于情况3，我们期望 $\\varepsilon_Q$ 会非常小，能够通过 $1 \\times 10^{-12}$ 的容差。\n\n第二种方法是**带线性插值的半拉格朗日格式**。平流方程的解是一个简单的平移：$\\rho(x_i, t_{n+1}) = \\rho(x_i - v\\Delta t, t_n)$。点 $x'_i = x_i - v\\Delta t$ 是出发点。它通常不落在网格点上。其值通过对时间 $t_n$ 时两个最近网格点的值进行线性插值来估计。虽然这种插值过程通常是精确和稳定的（特别是在大时间步长下），但它不能保证局部或全局守恒。插值后的值之和通常不等于原始值之和。对于情况4，在 $1 \\times 10^{-6}$ 的紧容差下，我们预计这个虽小但非零的守恒误差会在 400 步中累积，并导致测试失败。对于情况5，容差放宽到 $1 \\times 10^{-1}$。半拉格朗日格式通常非常精确，所以累积误差应该远低于这个宽松的阈值，从而导致测试通过。\n\n总而言之，该测试套件旨在展示数值积分器的关键特性：保结构方法（隐式中点法）能够高精度地守恒不变量，而非保结构方法（前向欧拉法）或非严格守恒的方法（半拉格朗日法）则不能。预期的结果是 `[True, False, True, False, True]`。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and runs a test suite for invariant conservation in numerical schemes\n    for reduced models relevant to fusion plasma simulation.\n    \"\"\"\n\n    def run_oscillator_test(omega, dt, n_steps, q0, p0, tol, method):\n        \"\"\"\n        Runs a test for energy conservation in a linear Hamiltonian oscillator.\n\n        Args:\n            omega (float): Oscillator frequency.\n            dt (float): Time step size.\n            n_steps (int): Number of time steps.\n            q0 (float): Initial position.\n            p0 (float): Initial momentum.\n            tol (float): Tolerance for the relative error test.\n            method (str): 'midpoint' for implicit midpoint or 'euler' for forward Euler.\n\n        Returns:\n            bool: True if the test passes, False otherwise.\n        \"\"\"\n        y = np.array([q0, p0], dtype=np.float64)\n        A = np.array([[0, 1], [-omega**2, 0]], dtype=np.float64)\n\n        def energy(state):\n            q, p = state\n            return 0.5 * p**2 + 0.5 * omega**2 * q**2\n\n        e0 = energy(y)\n        if e0 == 0:\n            # Handle the case of zero initial energy. If final energy is also zero,\n            # error is 0. Otherwise, any non-zero final energy gives infinite relative error.\n            # In this problem, e0 is never zero.\n            y_final = np.copy(y)\n            for _ in range(n_steps):\n                if method == 'midpoint':\n                    # No evolution if start at origin\n                    pass\n                elif method == 'euler':\n                    y_final = (np.eye(2) + dt * A) @ y_final\n            e_final = energy(y_final)\n            return e_final == 0\n        \n        if method == 'midpoint':\n            # y_n+1 = (I - dt/2 * A)^-1 * (I + dt/2 * A) * y_n\n            Id = np.eye(2)\n            M_inv = np.linalg.inv(Id - 0.5 * dt * A)\n            M_add = Id + 0.5 * dt * A\n            update_matrix = M_inv @ M_add\n            for _ in range(n_steps):\n                y = update_matrix @ y\n        elif method == 'euler':\n            # y_n+1 = (I + dt * A) * y_n\n            update_matrix = np.eye(2) + dt * A\n            for _ in range(n_steps):\n                y = update_matrix @ y\n        \n        e_final = energy(y)\n        rel_error = np.abs(e_final - e0) / np.abs(e0)\n        \n        return rel_error = tol\n\n    def run_advection_test(N, L, v, dt, n_steps, tol, method):\n        \"\"\"\n        Runs a test for charge conservation in linear advection.\n\n        Args:\n            N (int): Number of grid points.\n            L (float): Domain length.\n            v (float): Advection velocity.\n            dt (float): Time step size.\n            n_steps (int): Number of time steps.\n            tol (float): Tolerance for the relative error test.\n            method (str): 'midpoint' for implicit midpoint/centered differences\n                          or 'lagrangian' for semi-Lagrangian.\n\n        Returns:\n            bool: True if the test passes, False otherwise.\n        \"\"\"\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False, dtype=np.float64)\n        rho = 1.0 + 0.1 * np.sin(2 * np.pi * x / L)\n        \n        q0 = np.sum(rho) * dx\n        if q0 == 0:\n            rho_final = np.copy(rho)\n            for _ in range(n_steps):\n                if method == 'midpoint':\n                    rho_final = np.zeros_like(rho)\n                elif method == 'lagrangian':\n                    # ... logic for zero initial state\n                    # Not needed for this problem's IC.\n                    pass\n            q_final = np.sum(rho_final) * dx\n            return q_final == 0\n\n        if method == 'midpoint':\n            # d(rho)/dt = -v * D * rho, where D is centered difference matrix\n            # Create the circulant differentiation matrix D\n            D = (np.roll(np.eye(N), -1, axis=1) - np.roll(np.eye(N), 1, axis=1)) / (2 * dx)\n            A_adv = -v * D\n\n            # Implicit midpoint update matrix\n            Id = np.eye(N)\n            M_inv = np.linalg.inv(Id - 0.5 * dt * A_adv)\n            M_add = Id + 0.5 * dt * A_adv\n            update_matrix = M_inv @ M_add\n            \n            for _ in range(n_steps):\n                rho = update_matrix @ rho\n        \n        elif method == 'lagrangian':\n            grid_indices = np.arange(N)\n            # Courant number is uniform, so departure points can be precalculated\n            # relative to grid indices.\n            departure_idx_float = grid_indices - v * dt / dx\n            \n            for _ in range(n_steps):\n                low_indices = np.floor(departure_idx_float).astype(int)\n                weights = departure_idx_float - low_indices\n                \n                # Use modulo arithmetic for periodic boundaries\n                # Python's % operator handles negative numbers correctly for this\n                rho_interp_low = rho[low_indices % N]\n                rho_interp_high = rho[(low_indices + 1) % N]\n                \n                rho = (1 - weights) * rho_interp_low + weights * rho_interp_high\n        \n        q_final = np.sum(rho) * dx\n        rel_error = np.abs(q_final - q0) / np.abs(q0)\n        \n        return rel_error = tol\n    \n    # Test suite definition\n    test_cases = [\n        {'type': 'energy', 'method': 'midpoint', 'params': (1.7, 0.2, 200, 1.0, 0.0, 1e-10)},\n        {'type': 'energy', 'method': 'euler', 'params': (1.7, 0.2, 200, 1.0, 0.0, 1e-3)},\n        {'type': 'charge', 'method': 'midpoint', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-12)},\n        {'type': 'charge', 'method': 'lagrangian', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-6)},\n        {'type': 'charge', 'method': 'lagrangian', 'params': (64, 1.0, 1.0, 0.1, 400, 1e-1)}\n    ]\n    \n    results = []\n    for case in test_cases:\n        if case['type'] == 'energy':\n            omega, dt, n_steps, q0, p0, tol = case['params']\n            result = run_oscillator_test(omega, dt, n_steps, q0, p0, tol, case['method'])\n            results.append(result)\n        elif case['type'] == 'charge':\n            N, L, v, dt, n_steps, tol = case['params']\n            result = run_advection_test(N, L, v, dt, n_steps, tol, case['method'])\n            results.append(result)\n            \n    # Format and print the final output as a single line\n    # Python's str(True) is 'True', as required by problem for boolean literals\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "在掌握了基本原理后，我们转向一个更真实的场景。在由Hasegawa–Mima方程等描述的复杂系统中，仅仅使用辛时间积分器并不足以保证不变量的守恒。本练习将探讨时间步进格式与空间离散化方法（特别是傅里叶伪谱法）之间至关重要的相互作用，揭示诸如混淆误差（aliasing）等问题是如何破坏时间积分器旨在保持的离散结构。",
            "id": "4191868",
            "problem": "考虑一个定义在边长为 $2\\pi$ 的周期性方形区域上的二维静电 Hasegawa–Mima 方程，其空间坐标为 $(x,y)$，时间变量为 $t$。该偏微分方程为\n$$\n\\frac{\\partial}{\\partial t}\\left(\\nabla^2 \\phi - \\phi\\right) + J\\!\\left(\\phi,\\nabla^2 \\phi - \\phi\\right) = 0,\n$$\n其中 $\\phi(x,y,t)$ 是静电势，$J(a,b) \\equiv \\partial_x a\\,\\partial_y b - \\partial_y a\\,\\partial_x b$ 是雅可比算子。定义广义势涡 $q(x,y,t) \\equiv \\nabla^2 \\phi(x,y,t) - \\phi(x,y,t)$，并用帽子符号表示场的傅里叶变换，因此 $q_{\\mathbf{k}}(t)$ 和 $\\phi_{\\mathbf{k}}(t)$ 是在波矢 $\\mathbf{k} = (k_x,k_y)$ 处的傅里叶系数。傅里叶空间中的关系为 $q_{\\mathbf{k}}(t) = -\\left(|\\mathbf{k}|^2 + 1\\right)\\,\\phi_{\\mathbf{k}}(t)$，该关系对所有波矢 $\\mathbf{k}$ 都是可逆的。\n\n在一个 $N$ 为偶数的均匀 $N \\times N$ 网格上，使用傅里叶伪谱空间离散化方法，通过快速傅里叶变换 (FFT) 及其逆变换来近似导数，并通过物理空间中的乘积计算非线性雅可比项 $J(\\phi,q)$。该连续系统有一个二次能量不变量\n$$\nE(t) = \\frac{1}{2}\\int_{[0,2\\pi]^2} \\left(|\\nabla \\phi(x,y,t)|^2 + |\\phi(x,y,t)|^2\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n在傅里叶变量下，可以写成\n$$\nE(t) = \\frac{1}{2}\\sum_{\\mathbf{k}} \\left(|\\mathbf{k}|^2 + 1\\right)\\,|\\phi_{\\mathbf{k}}(t)|^2.\n$$\n在采用非酉 FFT 约定的离散设置中，确保能量的计算使用的缩放比例与离散帕塞瓦尔恒等式一致。\n\n使用隐式中点法对关于 $q$ 的半离散系统进行时间推进，这是一种辛单步格式：对于时间步长 $\\Delta t$，从 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的更新由以下隐式方程定义\n$$\nq^{n+1} = q^n - \\Delta t\\; J\\!\\left(\\phi^{\\mathrm{mid}},q^{\\mathrm{mid}}\\right),\n$$\n其中 $q^{\\mathrm{mid}} = \\frac{1}{2}\\left(q^n + q^{n+1}\\right)$，而 $\\phi^{\\mathrm{mid}}$ 通过对所有 $\\mathbf{k}$ 应用 $\\phi^{\\mathrm{mid}}_{\\mathbf{k}} = -\\,q^{\\mathrm{mid}}_{\\mathbf{k}}/\\left(|\\mathbf{k}|^2 + 1\\right)$ 从 $q^{\\mathrm{mid}}$ 获得。在每一步中使用不动点迭代来求解关于 $q^{n+1}$ 的隐式方程。\n\n当使用伪谱方法在物理空间中计算非线性乘积时，卷积混叠会破坏雅可比算子的离散反对称性，即使在使用辛时间积分器时也会导致伪能量漂移。按如下方式实现 $2/3$ 去混叠规则：在傅里叶空间中，定义一个掩码，将所有满足 $|k_x|  N/3$ 或 $|k_y|  N/3$ 的模式置零；然后，为了计算雅可比项，首先将 $\\phi$ 和 $q$ 的傅里叶系数都投影到被掩码的集合上，以谱方法计算导数，在物理空间中形成雅可比项，然后将得到的雅可比项的傅里叶变换投影回被掩码的集合上。对于去混叠的运行，同样需要将 $q$ 的初始傅里叶系数投影到被掩码的集合上。对于非去混叠的运行，执行相同的操作，但不使用任何掩码。\n\n用少数几个傅里叶模式的光滑、非平凡组合来初始化 $\\phi(x,y,0)$，以产生非线性相互作用，例如：\n$$\n\\phi(x,y,0) = 0.1\\cos(x)\\cos(2y) + 0.1\\sin(2x)\\sin(y) + 0.1\\cos(3x - 2y),\n$$\n并设置 $q_{\\mathbf{k}}(0) = -\\left(|\\mathbf{k}|^2 + 1\\right)\\,\\phi_{\\mathbf{k}}(0)$。\n\n您的任务是：\n- 实现上述使用隐式中点法进行时间积分的傅里叶伪谱求解器。\n- 通过计算定义的相对能量漂移来量化混叠效应对离散能量不变量的影响\n$$\n\\delta_E = \\left|\\frac{E(T) - E(0)}{E(0)}\\right|,\n$$\n其中 $T$ 是最终时间。所有量纲均为一；以浮点小数形式报告 $\\delta_E$。\n- 实现所描述的 $2/3$ 去混叠规则，并证明对于相同的时间积分器，该规则能将离散能量平衡恢复到数值容差范围内。\n\n使用以下参数集 $(N,\\Delta t,T,\\mathrm{dealiased})$ 测试套件：\n- 测试 $1$：$(64,0.05,1.0,\\mathrm{False})$，作为不去混叠的一般情况。\n- 测试 $2$：$(64,0.05,1.0,\\mathrm{True})$，作为进行去混叠的一般情况。\n- 测试 $3$：$(16,0.05,1.0,\\mathrm{False})$，作为不去混叠的粗糙网格边界情况。\n- 测试 $4$：$(64,0.10,1.0,\\mathrm{True})$，作为进行去混叠的较大时间步长情况。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，结果顺序与给定的测试顺序一致，例如：$[\\delta_{E,1},\\delta_{E,2},\\delta_{E,3},\\delta_{E,4}]$。输出必须是浮点小数。",
            "solution": "我们从 Hasegawa–Mima 方程开始，它在静电极限下是一个具有哈密顿结构的二维非线性偏微分方程。广义势涡为 $q = \\nabla^2 \\phi - \\phi$，其演化方程可以写成\n$$\n\\frac{\\partial q}{\\partial t} + J(\\phi,q) = 0,\n$$\n其中 $J(a,b) = \\partial_x a\\,\\partial_y b - \\partial_y a\\,\\partial_x b$ 是双线性的和反对称的，即对于足够光滑的周期函数 $a$ 和 $b$，我们有 $\\int a\\,J(a,b)\\,\\mathrm{d}x\\,\\mathrm{d}y = 0$ 和 $\\int b\\,J(a,b)\\,\\mathrm{d}x\\,\\mathrm{d}y = 0$。该系统的哈密顿量（能量）为\n$$\nE = \\frac{1}{2}\\int \\left(|\\nabla \\phi|^2 + |\\phi|^2\\right)\\,\\mathrm{d}x\\,\\mathrm{d}y,\n$$\n这也可以用傅里叶变量表示为\n$$\nE = \\frac{1}{2}\\sum_{\\mathbf{k}} \\left(|\\mathbf{k}|^2 + 1\\right)\\,|\\phi_{\\mathbf{k}}|^2,\n$$\n此式利用了傅里叶模式的标准正交性和帕塞瓦尔恒等式。因为 $q_{\\mathbf{k}} = -\\left(|\\mathbf{k}|^2 + 1\\right)\\phi_{\\mathbf{k}}$，所以可以用 $q_{\\mathbf{k}}$ 表示能量为\n$$\nE = \\frac{1}{2}\\sum_{\\mathbf{k}} \\frac{|q_{\\mathbf{k}}|^2}{|\\mathbf{k}|^2 + 1}.\n$$\n\n空间离散化是使用傅里叶伪谱方法在 $2\\pi \\times 2\\pi$ 周期域上的 $N \\times N$ 网格上进行的。令 $x_j = 2\\pi j/N$ 且 $y_\\ell = 2\\pi \\ell / N$ 对于 $j,\\ell = 0,1,\\ldots,N-1$。离散傅里叶变换及其逆变换（快速傅里叶变换 (FFT) 及其逆变换）被用来在物理空间和谱空间之间进行转换。对于可分辨的模式，谱方法微分是精确的：$\\partial_x \\phi \\leftrightarrow i k_x \\phi_{\\mathbf{k}}$ 和 $\\partial_y \\phi \\leftrightarrow i k_y \\phi_{\\mathbf{k}}$。雅可比项 $J(\\phi,q)$ 的计算方法是：将谱导数变换到物理空间，形成乘积 $\\partial_x \\phi \\cdot \\partial_y q - \\partial_y \\phi \\cdot \\partial_x q$，然后变换回谱空间。\n\n混叠的产生是因为物理空间中的逐点乘积对应于谱空间中的卷积，这可能会产生超出可分辨范围的频率。由于离散傅里叶变换的性质，这些更高的频率会“折返”到可分辨的频带中，导致伪相互作用，从而违反了非线性算子的离散反对称性。$2/3$ 去混叠规则通过在形成乘积前将场投影到一个带限子空间来避免这些伪贡献，该子空间使用一个只保留满足 $|k_x| \\le N/3$ 和 $|k_y| \\le N/3$ 模式的掩码。在这个子空间中，任意两个可分辨波矢之和都保持在可表示的范围内，从而防止了二次非线性项中的混叠。\n\n时间积分使用隐式中点法执行，该方法是辛方法，并能保持形如 $\\dot{z} = S(z)\\nabla H(z)$（其中 $S(z)$ 是反对称的，$H(z)$ 是二次的）的常微分方程的二次不变量。在我们的半离散设置中，如果离散雅可比算子相对于由 FFT 约定导出的离散内积是反自伴的，那么使用一致缩放计算的能量会被中点格式保持。具体来说，对于一个具有二次不变量 $I(\\mathbf{q}) = \\frac{1}{2}\\mathbf{q}^\\top \\mathbf{A}\\mathbf{q}$ 的有限维系统 $\\dot{\\mathbf{q}} = \\mathbf{f}(\\mathbf{q})$，若其流满足 $\\mathbf{A}\\mathbf{f}(\\mathbf{q})$ 在适当的内积下是反对称的，则隐式中点法更新\n$$\n\\mathbf{q}^{n+1} = \\mathbf{q}^n + \\Delta t\\,\\mathbf{f}\\Big(\\frac{\\mathbf{q}^n + \\mathbf{q}^{n+1}}{2}\\Big)\n$$\n能精确地在算术上保持 $I(\\mathbf{q})$（在求解器容差范围内）。在我们的伪谱离散化中，混叠破坏了反对称性，即使在使用辛格式的情况下也会导致能量漂移；因此去混叠至关重要。\n\n算法步骤：\n- 使用 FFT 频率函数构建整数波数 $k_x$ 和 $k_y$ 数组，并进行缩放，使得对于周期为 $2\\pi$ 的域，谱微分因子为 $i k_x$ 和 $i k_y$。然后形成二维数组 $K_x$、$K_y$ 和 $K^2 = K_x^2 + K_y^2$。\n- 将 $\\phi(x,y,0)$ 初始化为具有中等振幅的三角函数之和，计算其傅里叶变换 $\\phi_{\\mathbf{k}}(0)$，并设置 $q_{\\mathbf{k}}(0) = -\\left(K^2 + 1\\right)\\phi_{\\mathbf{k}}(0)$。\n- 为了去混叠，定义 $2/3$ 掩码 $M$，使得当 $|k_x| \\le N/3$ 且 $|k_y| \\le N/3$ 时 $M_{\\mathbf{k}} = 1$，否则 $M_{\\mathbf{k}} = 0$。对于去混叠的运行，将 $q_{\\mathbf{k}}(0)$ 投影为 $M \\circ q_{\\mathbf{k}}(0)$；对于非去混叠的运行，使用全谱。\n- 实现一个计算 $J(\\phi,q)$ 的函数，该函数：\n  1. 通过 $\\phi_{\\mathbf{k}} = -q_{\\mathbf{k}}/\\left(K^2+1\\right)$ 从 $q_{\\mathbf{k}}$ 构造 $\\phi_{\\mathbf{k}}$。\n  2. 如果启用去混叠，则使用掩码 $M$ 对 $\\phi_{\\mathbf{k}}$ 和 $q_{\\mathbf{k}}$ 进行投影。\n  3. 计算谱导数 $iK_x\\phi_{\\mathbf{k}}$、$iK_y\\phi_{\\mathbf{k}}$、$iK_x q_{\\mathbf{k}}$、$iK_y q_{\\mathbf{k}}$。\n  4. 通过逆 FFT 将这些导数变换到物理空间，在物理空间中形成乘积 $J$，然后通过 FFT 变换回谱空间。\n  5. 如果启用去混叠，则使用掩码 $M$ 对得到的雅可比项谱进行投影。\n- 使用不动点迭代实现隐式中点法步骤：从初始猜测 $q^{n+1,(0)}=q^n$ 开始，定义 $q^{\\mathrm{mid},(m)} = \\frac{1}{2}\\left(q^n + q^{n+1,(m)}\\right)$，计算 $J^{(m)} = J\\!\\left(\\phi^{\\mathrm{mid},(m)},q^{\\mathrm{mid},(m)}\\right)$，并更新 $q^{n+1,(m+1)} = q^n - \\Delta t\\,J^{(m)}$，直到在合适的范数下收敛。\n- 使用与 FFT 一致的帕塞瓦尔缩放来计算离散能量。对于非酉 FFT 约定（FFT 无归一化，逆 FFT 乘以 $1/N^2$），与连续表达式一致的离散能量为\n  $$\n  E_{\\mathrm{disc}} = \\frac{1}{2}\\,\\frac{1}{N^2}\\sum_{\\mathbf{k}} \\left(K^2 + 1\\right)\\,|\\phi_{\\mathbf{k}}|^2,\n  $$\n  这可由应用帕塞瓦尔恒等式并通过在 $N \\times N$ 网格上使用梯形法则近似域积分得到。\n- 报告每个测试的相对能量漂移 $\\delta_E = \\left|{E(T) - E(0)}\\right|/E(0)$。\n\n预期的定性结果：\n- 在没有去混叠的中等网格上（测试 $1$），混叠将破坏离散反对称性，并产生一个非零的 $\\delta_E$，其大小与非线性相互作用强度和时间步长相关。\n- 在相同网格和时间步长下进行去混叠（测试 $2$），离散雅可比算子在截断的内积下恢复了反对称性，隐式中点法将在求解器和舍入容差范围内保持能量，导致 $\\delta_E$ 接近机器精度。\n- 在没有去混叠的粗糙网格上（测试 $3$），混叠效应更严重，导致更大的 $\\delta_E$。\n- 使用更大的时间步长但进行去混叠（测试 $4$），能量守恒性仍然很好，尽管不动点迭代容差和时间离散化误差可能会使 $\\delta_E$ 略高于测试 $2$；但它应保持很小。\n\n最终程序实现了这些步骤，并以指定的单行格式输出四个浮点数结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_wavenumbers(N):\n    # Integer wavenumbers for 2π-periodic domain; spectral differentiation uses i*k\n    k1d = np.fft.fftfreq(N) * N  # integers: 0,1,...,N/2-1,-N/2,...,-1\n    KX, KY = np.meshgrid(k1d, k1d, indexing='ij')\n    K2 = KX**2 + KY**2\n    return KX, KY, K2\n\ndef initial_phi(x, y):\n    # Smooth initial condition to generate nonlinear interactions\n    return 0.1*np.cos(x)*np.cos(2.0*y) + 0.1*np.sin(2.0*x)*np.sin(y) + 0.1*np.cos(3.0*x - 2.0*y)\n\ndef compute_energy(q_hat, K2, N):\n    # Energy E = 0.5 * (1/N^2) * sum_{k} (K2+1) * |phi_hat|^2, phi_hat = -q_hat/(K2+1)\n    denom = (K2 + 1.0)\n    phi_hat = -q_hat / denom\n    energy = 0.5 * (1.0/(N*N)) * np.sum(denom * (np.abs(phi_hat)**2))\n    return float(np.real(energy))\n\ndef jacobian_hat(q_hat, KX, KY, K2, dealiased, mask):\n    # Build phi_hat from q_hat\n    denom = (K2 + 1.0)\n    # Avoid division by zero at k=0 if it could be an issue, though K2+1 is always >= 1.\n    phi_hat = -q_hat / denom\n\n    if dealiased:\n        # Project to dealiased subspace\n        phi_hat = phi_hat * mask\n        q_hat = q_hat * mask\n\n    # Spectral derivatives\n    dphix_hat = 1j * KX * phi_hat\n    dphiy_hat = 1j * KY * phi_hat\n    dqdx_hat  = 1j * KX * q_hat\n    dqdy_hat  = 1j * KY * q_hat\n\n    # Transform to physical space\n    dphix = np.fft.ifft2(dphix_hat).real\n    dphiy = np.fft.ifft2(dphiy_hat).real\n    dqdx  = np.fft.ifft2(dqdx_hat).real\n    dqdy  = np.fft.ifft2(dqdy_hat).real\n\n    # Jacobian in physical space\n    J_phys = dphix * dqdy - dphiy * dqdx\n\n    # Back to spectral space\n    J_hat = np.fft.fft2(J_phys)\n\n    if dealiased:\n        J_hat = J_hat * mask\n\n    return J_hat\n\ndef implicit_midpoint(q_hat0, KX, KY, K2, dt, steps, dealiased, mask, tol=1e-12, max_iter=30):\n    q_hat = q_hat0.copy()\n    for _ in range(steps):\n        q_next = q_hat.copy()\n        # Fixed-point iteration\n        for _ in range(max_iter):\n            q_mid = 0.5 * (q_hat + q_next)\n            J_mid = jacobian_hat(q_mid, KX, KY, K2, dealiased, mask)\n            q_new = q_hat - dt * J_mid\n            # Convergence check in L2 spectral norm\n            num = np.linalg.norm(q_new - q_next)\n            den = max(np.linalg.norm(q_new), 1e-15)\n            if num / den  tol:\n                q_next = q_new\n                break\n            q_next = q_new\n        else:\n            # If not converged, accept last iterate\n            pass\n        q_hat = q_next\n    return q_hat\n\ndef run_case(N, dt, T, dealiased):\n    # Build wavenumbers and mask\n    KX, KY, K2 = build_wavenumbers(N)\n    cutoff = N // 3\n    mask = ((np.abs(KX) = cutoff)  (np.abs(KY) = cutoff)).astype(float)\n\n    # Physical grid\n    x = 2.0*np.pi * (np.arange(N) / N)\n    y = 2.0*np.pi * (np.arange(N) / N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial phi and q in spectral space\n    phi0 = initial_phi(X, Y)\n    phi_hat0 = np.fft.fft2(phi0)\n    q_hat0 = -(K2 + 1.0) * phi_hat0\n\n    if dealiased:\n        q_hat0 = q_hat0 * mask\n\n    E0 = compute_energy(q_hat0, K2, N)\n\n    steps = int(np.round(T / dt))\n    q_hatT = implicit_midpoint(q_hat0, KX, KY, K2, dt, steps, dealiased, mask)\n\n    ET = compute_energy(q_hatT, K2, N)\n    drift = abs(ET - E0) / (E0 if E0 != 0.0 else 1.0)\n    return drift\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 0.05, 1.0, False),\n        (64, 0.05, 1.0, True),\n        (16, 0.05, 1.0, False),\n        (64, 0.10, 1.0, True),\n    ]\n\n    results = []\n    for N, dt, T, dealiased in test_cases:\n        # Ensure N is even for FFT symmetry\n        if N % 2 != 0:\n            raise ValueError(\"N must be even.\")\n        result = run_case(N, dt, T, dealiased)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.6e}', results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后一个实践将重点转向隐式格式的实现细节。隐式方法的核心是在每个时间步求解一个（通常是非线性的）代数方程组，这通常通过牛顿法等迭代方式完成。本练习旨在研究当这个代数系统没有被精确求解时所带来的后果，并引入一种实用的技术——基于残差的能量修正——来在控制计算成本的同时，有效缓解由此产生的守恒误差。",
            "id": "4191897",
            "problem": "您的任务是评估较低的牛顿迭代容差对一个与聚变等离子体湍流模拟相关的隐式保结构时间积分格式的离散能量守恒性的影响。使用一个编码了无碰撞静电动力学典型的基本能量和斜对称结构的有限维哈密顿模型，实现平均向量场 (AVF) 方法，并量化不精确的隐式求解如何影响守恒性。然后，设计并实现一个基于残差的能量修正，将离散能量恢复到指定的精度。\n\n其底层的动力系统是一个有限维哈密顿常微分方程，状态为 $\\mathbf{u} \\in \\mathbb{R}^n$，斜对称结构矩阵为 $\\mathbf{J} \\in \\mathbb{R}^{n \\times n}$，哈密顿量为 $H(\\mathbf{u})$。其演化遵循\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{J} \\nabla H(\\mathbf{u}),\n$$\n其中 $\\mathbf{J}^\\top = -\\mathbf{J}$ 且 $\\nabla H$ 表示关于 $\\mathbf{u}$ 的梯度。哈密顿量取为\n$$\nH(\\mathbf{u}) = \\frac{1}{2}\\,\\mathbf{u}^\\top \\mathbf{K}\\,\\mathbf{u} + \\frac{c}{4}\\,\\|\\mathbf{u}\\|^4,\n$$\n其中 $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$ 是对称正定矩阵，而 $c \\ge 0$ 是一个控制弱非线性的标量。该函数形式反映了一个二次“线性”分量和一个四次“非线性极化”分量，是简化静电回旋动理学或回旋流体模型中自由能的一个简化替代。所有量均为无量纲。\n\n平均向量场 (AVF) 方法通过以下隐式方程从 $\\mathbf{u}_n$ 推进到 $\\mathbf{u}_{n+1}$：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\Delta t \\,\\mathbf{J} \\int_0^1 \\nabla H\\!\\left(\\mathbf{u}_n + s(\\mathbf{u}_{n+1} - \\mathbf{u}_n)\\right)\\,ds,\n$$\n只要非线性方程被精确求解，该方法对于任意步长 $\\Delta t$ 都是能量守恒的。对于上述哈密顿量，记 $\\mathbf{a} = \\mathbf{u}_n$ 和 $\\mathbf{d} = \\mathbf{u}_{n+1} - \\mathbf{u}_n$。则\n$$\n\\nabla H(\\mathbf{u}) = \\mathbf{K}\\mathbf{u} + c\\,\\|\\mathbf{u}\\|^2\\,\\mathbf{u},\n$$\n且 AVF 线积分有一个闭式表达式\n$$\n\\int_0^1 \\nabla H(\\mathbf{a} + s\\mathbf{d})\\,ds = \\frac{1}{2}\\,\\mathbf{K}(\\mathbf{a} + \\mathbf{u}_{n+1}) + c\\,\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d}),\n$$\n其中\n$$\n\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d}) =\n(\\mathbf{a}\\cdot\\mathbf{a})\\,\\mathbf{a}\\,+\\,\\frac{1}{2}(\\mathbf{a}\\cdot\\mathbf{a})\\,\\mathbf{d}\\,+\\,(\\mathbf{a}\\cdot\\mathbf{d})\\,\\mathbf{a}\\,+\\,\\frac{2}{3}(\\mathbf{a}\\cdot\\mathbf{d})\\,\\mathbf{d}\\,+\\,\\frac{1}{3}(\\mathbf{d}\\cdot\\mathbf{d})\\,\\mathbf{a}\\,+\\,\\frac{1}{4}(\\mathbf{d}\\cdot\\mathbf{d})\\,\\mathbf{d}.\n$$\n\n隐式方程的单步残差为\n$$\n\\mathbf{F}(\\mathbf{x};\\mathbf{a}) = \\mathbf{x} - \\mathbf{a} - \\Delta t\\,\\mathbf{J}\\left(\\frac{1}{2}\\,\\mathbf{K}(\\mathbf{a} + \\mathbf{x}) + c\\,\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{x}-\\mathbf{a})\\right),\n$$\n目标为 $\\mathbf{x} = \\mathbf{u}_{n+1}$。牛顿法所需的雅可比矩阵 $\\mathbf{D}\\mathbf{F}(\\mathbf{x};\\mathbf{a})$ 为\n$$\n\\mathbf{D}\\mathbf{F}(\\mathbf{x};\\mathbf{a}) = \\mathbf{I} - \\Delta t\\,\\mathbf{J}\\left(\\frac{1}{2}\\,\\mathbf{K} + c\\,\\mathbf{J}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d})\\right),\n$$\n其中 $\\mathbf{d} = \\mathbf{x} - \\mathbf{a}$ 且 $\\mathbf{J}_{\\mathrm{cubic}}$ 是 $\\mathbf{I}_{\\mathrm{cubic}}$ 关于 $\\mathbf{d}$ 的雅可比矩阵，\n$$\n\\mathbf{J}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d}) = \\frac{1}{2}(\\mathbf{a}\\cdot\\mathbf{a})\\,\\mathbf{I} + \\mathbf{a}\\mathbf{a}^\\top + \\frac{2}{3}\\left(\\mathbf{d}\\mathbf{a}^\\top + (\\mathbf{a}\\cdot\\mathbf{d})\\,\\mathbf{I}\\right) + \\frac{2}{3}\\mathbf{a}\\mathbf{d}^\\top + \\frac{1}{4}\\left((\\mathbf{d}\\cdot\\mathbf{d})\\,\\mathbf{I} + 2\\,\\mathbf{d}\\mathbf{d}^\\top\\right).\n$$\n\n当牛顿法以不够小的残差容差 $\\varepsilon_{\\mathrm{Newton}}$ 提前终止时，得到的 $\\mathbf{u}_{n+1}$ 将不再高精度地满足 AVF 方程，离散能量也不再精确守恒。为将能量恢复到指定精度，引入一个基于能量残差的标量能量修正。定义能量残差为\n$$\nr_E = H(\\mathbf{u}_{n+1}) - H(\\mathbf{u}_n),\n$$\n并通过一个由下式决定的标量 $\\lambda$ 对 $\\mathbf{u}_{n+1}$ 进行重缩放来获得修正后的状态\n$$\ng(\\lambda) = H(\\lambda\\,\\mathbf{u}_{n+1}) - H(\\mathbf{u}_n) = 0.\n$$\n对于给定的 $H$，记 $A = \\mathbf{u}_{n+1}^\\top \\mathbf{K}\\,\\mathbf{u}_{n+1}$ 和 $B = \\|\\mathbf{u}_{n+1}\\|^4$。则\n$$\ng(\\lambda) = \\frac{1}{2}\\lambda^2 A + \\frac{c}{4}\\lambda^4 B - H(\\mathbf{u}_n),\\quad g'(\\lambda) = \\lambda A + c\\,\\lambda^3 B.\n$$\n在实践中，一个从 $\\lambda = 1$ 开始的单牛顿步，\n$$\n\\lambda \\leftarrow \\lambda - \\frac{g(\\lambda)}{g'(\\lambda)},\n$$\n就足以将 $|g(\\lambda)|$ 减小到期望的能量容差 $\\varepsilon_{\\mathrm{energy}}$，因为当隐式残差很小时，$r_E$ 也很小。当启用能量修正时，使用这个修正后的 $\\mathbf{u}_{n+1}^{\\mathrm{corr}} = \\lambda\\,\\mathbf{u}_{n+1}$ 进行下一步计算。\n\n实现 AVF 积分器，使用由残差容差 $\\varepsilon_{\\mathrm{Newton}}$ 控制的牛顿法，以及一个可选的、目标容差为 $\\varepsilon_{\\mathrm{energy}}$ 的能量修正。模拟固定步数 $N$，并测量最终时刻的相对能量误差，\n$$\nE_{\\mathrm{rel}} = \\frac{|H(\\mathbf{u}_N) - H(\\mathbf{u}_0)|}{\\max(1,|H(\\mathbf{u}_0)|)}.\n$$\n\n您的程序必须：\n\n- 将 $\\mathbf{J}$ 构造为块对角矩阵，包含 $3$ 个标准 $2\\times 2$ 辛块，即 $n=6$ 且每个块为 $\\begin{pmatrix}0  1\\\\ -1  0\\end{pmatrix}$。\n- 将 $\\mathbf{K}$ 构造为对角矩阵，每个标准对中的条目相同：选择频率 $\\omega_1 = 1.0$，$\\omega_2 = 1.5$，$\\omega_3 = 2.0$，并设置 $\\mathbf{K} = \\mathrm{diag}(\\omega_1^2, \\omega_1^2, \\omega_2^2, \\omega_2^2, \\omega_3^2, \\omega_3^2)$。\n- 将 $\\mathbf{u}_0$ 初始化为一个可复现的非平凡状态，方法是设置 $\\mathbf{u}_0 = \\alpha\\,\\mathbf{v}$，其中 $\\alpha = 0.1$，$\\mathbf{v}$ 为固定向量 $\\mathbf{v} = [1, -1, 0.5, -0.5, 0.25, -0.25]^\\top$。\n- 使用 AVF 方法及上述闭式表达式，通过牛顿法求解隐式步，并可选择地在每步应用标量能量重缩放修正，直到能量残差低于 $\\varepsilon_{\\mathrm{energy}}$。\n\n设计测试套件以涵盖问题的不同方面：\n\n- 情况 $\\mathrm{A}$：“理想情况”，牛顿容差很小，$N=500$, $\\Delta t = 0.02$, $c = 0.1$, $\\varepsilon_{\\mathrm{Newton}} = 10^{-10}$，禁用能量修正。\n- 情况 $\\mathrm{B}$：较低的牛顿容差，$N=500$, $\\Delta t = 0.02$, $c = 0.1$, $\\varepsilon_{\\mathrm{Newton}} = 10^{-3}$，禁用能量修正。\n- 情况 $\\mathrm{C}$：较低的牛顿容差并带修正，$N=500$, $\\Delta t = 0.02$, $c = 0.1$, $\\varepsilon_{\\mathrm{Newton}} = 10^{-3}$，启用能量修正，$\\varepsilon_{\\mathrm{energy}} = 10^{-10}$。\n- 情况 $\\mathrm{D}$：非常宽松的牛顿容差并带修正，$N=500$, $\\Delta t = 0.02$, $c = 0.1$, $\\varepsilon_{\\mathrm{Newton}} = 5\\times 10^{-2}$，启用能量修正，$\\varepsilon_{\\mathrm{energy}} = 10^{-10}$。\n- 情况 $\\mathrm{E}$：边界线性情况，$N=500$, $\\Delta t = 0.02$, $c = 0.0$, $\\varepsilon_{\\mathrm{Newton}} = 10^{-3}$，禁用能量修正。\n\n对于每个测试用例，运行两次模拟：一次不进行每步能量修正，另一次进行每步能量修正（使用相同的参数，修正运行的 $\\varepsilon_{\\mathrm{energy}} = 10^{-10}$）。按顺序 $[E_{\\mathrm{rel}}^{\\mathrm{uncorrected}}, E_{\\mathrm{rel}}^{\\mathrm{corrected}}]$ 报告每种情况下的两个最终相对能量误差（浮点数）。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素对应一个测试用例，并且本身是一个包含两个浮点数 $[E_{\\mathrm{rel}}^{\\mathrm{uncorrected}}, E_{\\mathrm{rel}}^{\\mathrm{corrected}}]$ 的列表，按情况 $\\mathrm{A}$ 到 $\\mathrm{E}$ 的顺序排列。例如，输出应类似于 $[[x_1,y_1],[x_2,y_2],[x_3,y_3],[x_4,y_4],[x_5,y_5]]$，其中每个 $x_i,y_i$ 都是一个浮点数。",
            "solution": "用户提供了一个在常微分方程数值方法领域中定义明确的计算问题，特别关注于哈密顿系统的几何积分子。对问题陈述的验证证实，其在科学上是合理的，内容自洽，并且算法上已足够详细地指定，可以进行唯一的实现。平均向量场 (AVF) 积分子的数学公式、其相关的用于牛顿法的非线性残差和雅可比矩阵，以及能量修正程序，都已得到验证并确认是正确的。该问题是实现和分析保结构数值格式的一个标准练习，这是计算物理和应用数学中的一个重要课题。\n\n解决方案通过开发一个使用 `numpy` 库的 Python 程序来实现指定的数值方法。该程序结构如下：\n\n首先，定义辅助函数来构建问题特定的矩阵 $\\mathbf{J}$ 和 $\\mathbf{K}$，并计算哈密顿函数 $H(\\mathbf{u})$。矩阵 $\\mathbf{J} \\in \\mathbb{R}^{6 \\times 6}$ 是斜对称且块对角的，由三个 $2 \\times 2$ 的标准辛块组成。矩阵 $\\mathbf{K} \\in \\mathbb{R}^{6 \\times 6}$ 是对称正定且对角的，其条目由指定的频率确定。\n$$\n\\mathbf{J} = \\begin{pmatrix} \\mathbf{J}_2  \\mathbf{0}  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{J}_2  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{0}  \\mathbf{J}_2 \\end{pmatrix}, \\quad \\mathbf{J}_2 = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}\n$$\n$$\n\\mathbf{K} = \\mathrm{diag}(\\omega_1^2, \\omega_1^2, \\omega_2^2, \\omega_2^2, \\omega_3^2, \\omega_3^2)\n$$\n\n其次，实现了 AVF 积分器的核心组件。这涉及将问题中提供的三次积分项 $\\mathbf{I}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d})$ 及其雅可比矩阵 $\\mathbf{J}_{\\mathrm{cubic}}(\\mathbf{a},\\mathbf{d})$ 的解析公式转化为向量和矩阵运算。然后，这些函数被用来构建牛顿法所需的残差函数 $\\mathbf{F}(\\mathbf{x};\\mathbf{a})$ 及其雅可比矩阵 $\\mathbf{D F}(\\mathbf{x};\\mathbf{a})$。一个名为 `avf_step` 的函数封装了牛顿迭代过程，该过程求解隐式方程 $\\mathbf{F}(\\mathbf{u}_{n+1}; \\mathbf{u}_n) = \\mathbf{0}$ 以找到下一个时间步的状态 $\\mathbf{u}_{n+1}$。迭代持续进行，直到残差 $\\mathbf{F}$ 的欧几里得范数低于指定的容差 $\\varepsilon_{\\mathrm{Newton}}$ 或达到最大迭代次数。\n\n第三，实现了可选的能量修正机制。这个过程封装在 `energy_correction` 函数中，它接收一个新计算出的状态 $\\mathbf{u}_{n+1}$，并寻找一个标量修正因子 $\\lambda$，使得重缩放后的状态 $\\lambda \\mathbf{u}_{n+1}$ 与步初状态 $\\mathbf{u}_n$ 具有完全相同的能量。求根问题 $g(\\lambda) = H(\\lambda \\mathbf{u}_{n+1}) - H(\\mathbf{u}_n) = 0$ 通过对 $\\lambda$ 进行几次牛顿步来求解，从 $\\lambda=1$ 开始，直到能量残差 $|g(\\lambda)|$ 低于目标容差 $\\varepsilon_{\\mathrm{energy}}$。\n\n最后，创建了一个主模拟驱动程序 `run_simulation`。它根据问题规范初始化系统，包括初始条件 $\\mathbf{u}_0$。然后，它迭代指定的步数 $N$，在每一步调用 `avf_step`。根据一个布尔标志，它也可能调用 `energy_correction` 来对每一步的结果进行后处理。在 $N$ 步之后，它计算最终的相对能量误差，$E_{\\mathrm{rel}} = |H(\\mathbf{u}_N) - H(\\mathbf{u}_0)| / \\max(1, |H(\\mathbf{u}_0)|)$。\n\n一个顶层的 `solve` 函数协调整个过程。它定义了五个测试用例（A-E）的参数。对于每个用例，它调用 `run_simulation` 两次：一次禁用能量修正，以测量由于不精确的牛顿求解引起的能量漂移；另一次启用能量修正，以展示其有效性。所得到的成对的能量误差被收集并格式化为问题描述中要求的精确字符串格式作为最终输出。问题陈述中的用例定义被解释为，对于每组物理和数值参数，都执行两次模拟（未修正和已修正）。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests an Average Vector Field (AVF) integrator for a Hamiltonian system,\n    analyzing the effect of inexact Newton solves and a residual-based energy correction.\n    \"\"\"\n\n    # === Physical System and Helper Functions ===\n\n    def construct_J(n):\n        \"\"\"Constructs the skew-symmetric matrix J.\"\"\"\n        if n % 2 != 0:\n            raise ValueError(\"n must be a multiple of 2\")\n        block = np.array([[0, 1], [-1, 0]], dtype=float)\n        num_blocks = n // 2\n        return np.kron(np.eye(num_blocks), block)\n\n    def construct_K(omegas):\n        \"\"\"Constructs the diagonal matrix K from frequencies.\"\"\"\n        k_vals = []\n        for w in omegas:\n            k_vals.extend([w**2, w**2])\n        return np.diag(k_vals)\n\n    def H(u, K, c):\n        \"\"\"Computes the Hamiltonian H(u).\"\"\"\n        u_norm_sq = u @ u\n        return 0.5 * u @ K @ u + (c / 4.0) * (u_norm_sq**2)\n\n    def I_cubic(a, d):\n        \"\"\"Computes the closed-form cubic integral term.\"\"\"\n        a_dot_a = a @ a\n        a_dot_d = a @ d\n        d_dot_d = d @ d\n        \n        term1 = a_dot_a * a\n        term2 = 0.5 * a_dot_a * d\n        term3 = a_dot_d * a\n        term4 = (2.0 / 3.0) * a_dot_d * d\n        term5 = (1.0 / 3.0) * d_dot_d * a\n        term6 = 0.25 * d_dot_d * d\n        \n        return term1 + term2 + term3 + term4 + term5 + term6\n\n    def J_cubic(a, d):\n        \"\"\"Computes the Jacobian of the cubic integral term w.r.t. d.\"\"\"\n        n = len(a)\n        I = np.identity(n)\n        a_dot_a = a @ a\n        a_dot_d = a @ d\n        d_dot_d = d @ d\n\n        term1 = 0.5 * a_dot_a * I\n        term2 = np.outer(a, a)\n        term3 = (2.0 / 3.0) * (np.outer(d, a) + a_dot_d * I)\n        term4 = (2.0 / 3.0) * np.outer(a, d)\n        term5 = 0.25 * (d_dot_d * I + 2.0 * np.outer(d, d))\n        \n        return term1 + term2 + term3 + term4 + term5\n\n    # === AVF Integrator with Newton's Method ===\n\n    def residual_F(x, a, dt, J, K, c):\n        \"\"\"Computes the residual F(x; a) for the AVF implicit equation.\"\"\"\n        d = x - a\n        integral_val = 0.5 * K @ (a + x)\n        if c != 0.0:\n            integral_val += c * I_cubic(a, d)\n        \n        return x - a - dt * (J @ integral_val)\n\n    def jacobian_DF(x, a, dt, J, K, c):\n        \"\"\"Computes the Jacobian DF(x; a).\"\"\"\n        n = len(a)\n        d = x - a\n        \n        J_integral = 0.5 * K\n        if c != 0.0:\n            J_integral += c * J_cubic(a, d)\n            \n        return np.identity(n) - dt * (J @ J_integral)\n\n    def avf_step(u_n, dt, J, K, c, newton_tol):\n        \"\"\"Performs one time step using the AVF method with Newton solver.\"\"\"\n        a = u_n\n        x = a.copy()  # Initial guess for u_{n+1}\n        \n        max_newton_iter = 20\n        for _ in range(max_newton_iter):\n            res = residual_F(x, a, dt, J, K, c)\n            \n            if np.linalg.norm(res)  newton_tol:\n                break\n                \n            jac = jacobian_DF(x, a, dt, J, K, c)\n            delta_x = np.linalg.solve(jac, -res)\n            x += delta_x\n        \n        return x\n\n    # === Energy Correction ===\n\n    def energy_correction(u_np1, u_n, H_n, K, c, energy_tol):\n        \"\"\"Applies a scalar rescaling to restore energy conservation.\"\"\"\n        if c == 0.0:\n            return u_np1\n\n        A = u_np1 @ K @ u_np1\n        norm_u_sq = u_np1 @ u_np1\n        B = norm_u_sq**2\n        \n        lam = 1.0\n        \n        max_lambda_iter = 5\n        for _ in range(max_lambda_iter):\n            g_lam = 0.5 * lam**2 * A + (c / 4.0) * lam**4 * B - H_n\n            \n            if abs(g_lam)  energy_tol:\n                break\n            \n            gp_lam = lam * A + c * lam**3 * B\n            if abs(gp_lam)  1e-15:\n                break\n            lam -= g_lam / gp_lam\n\n        return lam * u_np1\n\n    # === Main Simulation Loop ===\n\n    def run_simulation(params, correction_enabled):\n        \"\"\"Runs a full simulation for a given set of parameters.\"\"\"\n        N, dt, c, newton_tol, energy_tol = params\n        \n        n = 6\n        omegas = [1.0, 1.5, 2.0]\n        alpha = 0.1\n        v = np.array([1, -1, 0.5, -0.5, 0.25, -0.25])\n        \n        J = construct_J(n)\n        K = construct_K(omegas)\n        u_0 = alpha * v\n        \n        H_0 = H(u_0, K, c)\n        u = u_0.copy()\n        \n        for _ in range(N):\n            u_np1 = avf_step(u, dt, J, K, c, newton_tol)\n            \n            if correction_enabled:\n                H_n = H(u, K, c)\n                u_np1 = energy_correction(u_np1, u, H_n, K, c, energy_tol)\n            \n            u = u_np1\n            \n        H_N = H(u, K, c)\n        \n        denominator = max(1.0, abs(H_0))\n        rel_energy_error = abs(H_N - H_0) / denominator\n        \n        return rel_energy_error\n\n    # === Main Driver: Define and run test cases ===\n    \n    base_params = {\n        'N': 500,\n        'dt': 0.02,\n        'energy_tol': 1e-10\n    }\n    \n    test_cases_defs = [\n        # Case A\n        {'c': 0.1, 'newton_tol': 1e-10},\n        # Case B\n        {'c': 0.1, 'newton_tol': 1e-3},\n        # Case C\n        {'c': 0.1, 'newton_tol': 1e-3},\n        # Case D\n        {'c': 0.1, 'newton_tol': 5e-2},\n        # Case E\n        {'c': 0.0, 'newton_tol': 1e-3}\n    ]\n    \n    results = []\n    for case_def in test_cases_defs:\n        params = (\n            base_params['N'],\n            base_params['dt'],\n            case_def['c'],\n            case_def['newton_tol'],\n            base_params['energy_tol']\n        )\n        \n        E_rel_uncorrected = run_simulation(params, correction_enabled=False)\n        E_rel_corrected = run_simulation(params, correction_enabled=True)\n        \n        results.append([E_rel_uncorrected, E_rel_corrected])\n\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}