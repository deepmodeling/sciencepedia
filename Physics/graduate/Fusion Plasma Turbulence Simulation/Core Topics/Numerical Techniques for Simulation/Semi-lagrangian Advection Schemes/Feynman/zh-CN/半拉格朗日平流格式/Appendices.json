{
    "hands_on_practices": [
        {
            "introduction": "半拉格朗日方法的核心在于插值，但这不可避免地会引入误差，其中最主要的是数值扩散。本练习将通过一个简单的剪切流和平滑的正弦波廓形，来分离并量化这种扩散效应，帮助您从根本上理解插值如何影响解的精度。通过完成这个练习 ()，您将亲手计算线性插值导致的振幅衰减。",
            "id": "3911375",
            "problem": "考虑一个无源标量 $\\,\\phi(x,y,t)\\,$ 在二维周期性域（坐标 $\\,x \\in [0,L_x]\\,$ 和 $\\,y \\in [0,L_y]\\,$）中的线性平流，流场为恒定剪切流 $\\,\\boldsymbol{u}(x,y) = (S\\,y,\\,0)\\,$，其中 $\\,S\\,$ 是一个恒定的剪切率。该标量遵循平流方程 $\\,\\partial_t \\phi + \\boldsymbol{u}\\cdot\\nabla \\phi = 0\\,$。在半拉格朗日方法中，欧拉网格点 $\\,\\boldsymbol{x}_{i,j} = (x_i, y_j)\\,$ 在时间 $\\,t^{n+1} = t^n + \\Delta t\\,$ 的更新值是通过将特征线反向追溯到出发点 $\\,\\boldsymbol{x}_d = (x_d, y_d)\\,$ 来获得的，该出发点满足 $\\,\\boldsymbol{x}_d = \\boldsymbol{x}_{i,j} - \\int_{t^n}^{t^{n+1}} \\boldsymbol{u}(\\boldsymbol{x}(s),s)\\,\\mathrm{d}s\\,$，然后对出发点 $\\,\\boldsymbol{x}_d\\,$ 处的 $\\,\\phi^n\\,$ 进行插值。\n\n从基本运动学关系 $\\,\\mathrm{d}\\boldsymbol{x}/\\mathrm{d}t = \\boldsymbol{u}(\\boldsymbol{x},t)\\,$ 出发，使用 $\\,\\boldsymbol{u}(x,y) = (S y, 0)\\,$（其中 $\\,S\\,$ 不随时间变化），推导单个时间步长 $\\,\\Delta t\\,$ 的精确出发点映射。实现一个单步半拉格朗日更新，在 $\\,x\\,$ 方向使用带有周期性边界条件的分段线性插值，并量化由插值引起的扩散。\n\n所有量均为无量纲。使用 $\\,L_x = 1\\,$, $\\,L_y = 1\\,$, $\\,S = 1\\,$，一个在 $\\,x\\,$ 方向有 $\\,N_x\\,$ 个点、在 $\\,y\\,$ 方向有 $\\,N_y\\,$ 个点的均匀网格，网格间距为 $\\,\\Delta x = L_x/N_x\\,$ 和 $\\,\\Delta y = L_y/N_y\\,$。在 $\\,t^n\\,$ 时刻将标量场初始化为 $\\,\\phi^n(x,y) = \\sin(2\\pi m x)\\,$，其中 $\\,m\\,$ 为整数模。对于给定的名义库朗-弗里德里希斯-列维（CFL）数 $\\,C\\,$，其定义为 $\\,C = \\max_{(x,y)} \\left( |u_x(x,y)| \\Delta t / \\Delta x \\right) = S\\,y_{\\max}\\,\\Delta t/\\Delta x\\,$，其中 $\\,y_{\\max} = L_y\\,$，设置 $\\,\\Delta t = C\\,\\Delta x/S\\,$。\n\n对于每个指定的 $\\,C\\,$ 值，执行一个半拉格朗日时间步：\n- 计算精确的出发点 $\\,x_d = x_i - S\\,y_j\\,\\Delta t\\,$ 和 $\\,y_d = y_j\\,$。\n- 计算精确的平流场 $\\,\\phi^{\\mathrm{exact}}(x_i,y_j) = \\sin\\!\\big(2\\pi m (x_i - S\\,y_j\\,\\Delta t)\\big)\\,$。\n- 通过对每个固定的 $\\,y_j\\,$，在 $\\,x\\,$ 方向使用周期性边界条件，在 $\\,x_d\\,$ 处对 $\\,\\phi^n\\,$ 进行线性插值，计算半拉格朗日场 $\\,\\phi^{\\mathrm{SL}}(x_i,y_j)\\,$。\n- 通过振幅比 $\\,R = \\|\\phi^{\\mathrm{SL}}\\|_2 / \\|\\phi^{\\mathrm{exact}}\\|_2\\,$ 来评估插值引起的扩散，其中 $\\,\\|\\cdot\\|_2\\,$ 是网格上的离散二维欧几里得范数。\n- 同时计算最大网格单元出发距离 $\\,D = \\max_{i,j} \\big(|x_i - x_d|/\\Delta x\\big)\\,$，它以网格单元为单位度量了最大的特征位移。\n\n测试套件和参数：\n- 使用 $\\,N_x = 128\\,$, $\\,N_y = 16\\,$ 和 $\\,m = 5\\,$。\n- 评估四个名义CFL数 $\\,C \\in \\{0.8,\\,1.0,\\,3.5,\\,16.0\\}\\,$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[R(C{=}0.8),D(C{=}0.8),R(C{=}1.0),D(C{=}1.0),R(C{=}3.5),D(C{=}3.5),R(C{=}16.0),D(C{=}16.0)]$。所有输出均为无量纲浮点数。不需要物理单位，并且由于正弦初始条件的构造，角度以弧度为单位。结果必须在没有任何外部输入的情况下是可复现的。",
            "solution": "问题陈述被评估为**有效**。它以流体动力学和数值分析的原理为科学基础，特别涉及平流方程和半拉格朗日格式。该问题是适定的，提供了一套完整且一致的参数、初始条件和数值程序。所有术语都进行了客观和数学上的定义，从而可以得到唯一且可验证的解。\n\n解答过程分为两部分：首先，对基于特征线的出发点映射进行解析推导；其次，设计用于计算半拉格朗日更新和评估指定度量指标的数值算法。\n\n**1. 出发点映射的推导**\n\n半拉格朗日方法依赖于将流体质点轨迹（即特征线）在时间上向后追溯。质点的轨迹 $\\boldsymbol{x}(t)$ 由以下运动学常微分方程（ODE）组控制：\n$$\n\\frac{\\mathrm{d}\\boldsymbol{x}}{\\mathrm{d}t} = \\boldsymbol{u}(\\boldsymbol{x}, t)\n$$\n给定二维、不依赖于时间的剪切流 $\\boldsymbol{u}(x,y) = (S\\,y, 0)$，其分量形式的常微分方程为：\n$$\n\\frac{\\mathrm{d}x}{\\mathrm{d}t} = S\\,y\n$$\n$$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = 0\n$$\n我们寻求在时间 $t^n$ 的出发点 $\\boldsymbol{x}_d = (x_d, y_d)$，该点在时间 $t^{n+1}$ 到达欧拉网格点 $\\boldsymbol{x}_{i,j} = (x_i, y_j)$。这涉及到将ODE系统在一个时间步长 $\\Delta t = t^{n+1} - t^n$ 内进行反向积分。\n\n将 $y$ 分量方程从 $t^{n+1}$ 反向积分到 $t^n$：\n$$\n\\int_{y(t^{n+1})}^{y(t^n)} \\mathrm{d}y = \\int_{t^{n+1}}^{t^n} 0\\,\\mathrm{d}t \\implies y(t^n) - y(t^{n+1}) = 0\n$$\n代入到达坐标和出发坐标，我们得到 $y_d - y_j = 0$，即：\n$$\ny_d = y_j\n$$\n这个结果表明特征线是水平直线；在此流场中，流体质点的 $y$ 坐标保持不变。\n\n现在，我们积分 $x$ 分量方程。$x(t^n)$ 的形式解为：\n$$\nx(t^n) = x(t^{n+1}) - \\int_{t^n}^{t^{n+1}} u_x(\\boldsymbol{x}(s))\\,\\mathrm{d}s\n$$\n代入 $u_x = S\\,y$ 以及对于一个到达 $y_j$ 的质点，其特征路径上的 $y(s) = y_j$ 是常数这一事实：\n$$\nx_d = x_i - \\int_{t^n}^{t^{n+1}} S\\,y_j\\,\\mathrm{d}s\n$$\n由于 $S$ 和 $y_j$ 相对于积分变量 $s$ 是常数，我们可以将它们从积分中提取出来：\n$$\nx_d = x_i - S\\,y_j \\int_{t^n}^{t^{n+1}} \\mathrm{d}s = x_i - S\\,y_j (t^{n+1} - t^n)\n$$\n使用定义 $\\Delta t = t^{n+1} - t^n$，我们得到出发点的 $x$ 坐标：\n$$\nx_d = x_i - S\\,y_j\\,\\Delta t\n$$\n因此，单个时间步长的精确出发点映射为 $(\\,x_d, y_d) = (x_i - S\\,y_j\\,\\Delta t, y_j)$，这证实了问题陈述中提供的表达式。\n\n**2. 数值算法与分析**\n\n半拉格朗日更新表明，被平流的标量沿特征线是守恒的，因此 $\\phi(\\boldsymbol{x}_{i,j}, t^{n+1}) = \\phi(\\boldsymbol{x}_d, t^n)$。我们基于此原理实现一个单步更新。\n\n**网格与参数：**\n- 域: $x \\in [0, L_x]$, $y \\in [0, L_y]$，其中 $L_x = 1$, $L_y = 1$。\n- 网格: $N_x = 128$, $N_y = 16$。网格坐标为 $x_i = i \\cdot (L_x/N_x)$（对于 $i=0, \\dots, N_x-1$）和 $y_j = j \\cdot (L_y/N_y)$（对于 $j=0, \\dots, N_y-1$）。\n- 剪切率: $S=1$。\n- 初始条件: $\\phi^n(x,y) = \\sin(2\\pi m x)$，模数 $m=5$。该场与 $y$ 无关。\n- 时间步长: $\\Delta t = C\\,\\Delta x/S$，因为用于 CFL 定义的 $y_{\\max}$ 取为 $L_y = 1$。当 $S=1$ 时，$\\Delta t = C\\,\\Delta x$。\n\n**精确平流场：**\n在时间 $t^{n+1}$ 的真实解是在出发点处求值的初始条件：\n$$\n\\phi^{\\mathrm{exact}}(x_i, y_j) = \\phi^n(x_d, y_d) = \\sin(2\\pi m x_d) = \\sin\\big(2\\pi m (x_i - S\\,y_j\\,\\Delta t)\\big)\n$$\n\n**使用线性插值的半拉格朗日场：**\n数值解 $\\phi^{\\mathrm{SL}}$ 是通过在出发点坐标 $(x_d, y_d)$ 处对已知场 $\\phi^n$ 的值进行插值来计算的。由于 $\\phi^n$ 仅是 $x$ 的函数，且 $y_d = y_j$，这对于每个网格行 $j$ 都简化为在坐标 $x_d$ 处对函数 $f(x) = \\sin(2\\pi m x)$ 进行一维插值。\n\n对单个点 $(x_i, y_j)$ 的插值过程如下：\n1.  计算出发点的 $x$ 坐标：$x_d = x_i - S y_j \\Delta t$。\n2.  通过将 $x_d$ 映射到域 $[0, L_x)$ 中来应用周期性边界条件：$x'_d = x_d \\pmod{L_x}$。\n3.  将坐标归一化为以网格间距为单位：$\\xi = x'_d / \\Delta x$。\n4.  确定边界网格索引和插值权重。下索引为 $k_1 = \\lfloor \\xi \\rfloor$。上索引（考虑周期性）为 $k_2 = (k_1 + 1) \\pmod{N_x}$。小数部分为权重 $\\alpha = \\xi - k_1$。\n5.  执行线性插值：\n    $$\n    \\phi^{\\mathrm{SL}}(x_i, y_j) = (1-\\alpha)\\phi^n(x_{k_1}) + \\alpha\\phi^n(x_{k_2})\n    $$\n此过程应用于所有网格点 $(x_i, y_j)$。\n\n**数值误差的量化：**\n线性插值并不完美，会引入数值误差，主要表现为数值扩散（耗散）的形式，这会衰减波的振幅。\n-   **振幅比 ($R$):** 通过数值解和精确解的离散L2范数之比来衡量：\n    $$\n    R = \\frac{\\|\\phi^{\\mathrm{SL}}\\|_2}{\\|\\phi^{\\mathrm{exact}}\\|_2} \\quad \\text{其中} \\quad \\|\\boldsymbol{A}\\|_2 = \\sqrt{\\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} A_{i,j}^2}\n    $$\n    $R  1$ 的值表示存在耗散误差。\n-   **最大出发距离 ($D$):** 这用于衡量在一个时间步长内，以网格单元为单位的最大平流距离。\n    $$\n    D = \\max_{i,j} \\frac{|x_i - x_d|}{\\Delta x} = \\max_{i,j} \\frac{|x_i - (x_i - S y_j \\Delta t)|}{\\Delta x} = \\frac{S \\Delta t}{\\Delta x} \\max_j(y_j)\n    $$\n    代入 $\\Delta t=C\\Delta x/S$ 和 $\\max_j(y_j) = (N_y-1)\\Delta y = (N_y-1)/N_y$，我们得到 $D = C (N_y-1)/N_y$。\n\n对每个CFL数 $C \\in \\{0.8, 1.0, 3.5, 16.0\\}$ 执行该算法，并计算和报告生成的 $(R, D)$ 对。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the semi-Lagrangian advection for a sinusoidal scalar field in a\n    2D shear flow, and evaluates numerical diffusion and departure distance.\n    \"\"\"\n    # Define the test cases and parameters from the problem statement.\n    test_cases = [0.8, 1.0, 3.5, 16.0] # Nominal CFL numbers\n    \n    # Physical and numerical parameters\n    Lx = 1.0        # Domain length in x\n    Ly = 1.0        # Domain length in y\n    S = 1.0         # Shear rate\n    Nx = 128        # Number of grid points in x\n    Ny = 16         # Number of grid points in y\n    m = 5           # Wavenumber of initial condition\n\n    # Grid setup\n    dx = Lx / Nx\n    dy = Ly / Ny\n    x = np.arange(Nx) * dx\n    y = np.arange(Ny) * dy\n    xx, yy = np.meshgrid(x, y, indexing='ij') # 'ij' indexing: xx shape (Ny, Nx), yy shape (Ny, Nx)\n\n    # Initial condition at time t^n\n    # The field is independent of y, so we only need the 1D profile for interpolation.\n    phi_n_1d = np.sin(2 * np.pi * m * x)\n\n    results = []\n    for C in test_cases:\n        # Calculate time step based on the nominal CFL number\n        dt = C * dx / S\n\n        # 1. Compute exact departure points (xd, yd) for all grid points (xx, yy)\n        # For shear flow u=(S*y, 0), the mapping is (x - S*y*dt, y)\n        xd = xx - S * yy * dt\n        # yd is implicitly yy, which is not needed as the field is y-independent.\n\n        # 2. Compute the exact advected field at t^{n+1}\n        # This is simply the initial condition evaluated at the departure points.\n        phi_exact = np.sin(2 * np.pi * m * xd)\n\n        # 3. Compute the Semi-Lagrangian field at t^{n+1} via interpolation\n        \n        # Map departure x-coordinates to the periodic domain [0, Lx)\n        xd_periodic = xd % Lx\n        \n        # Convert to grid-index units\n        xi = xd_periodic / dx\n        \n        # Find the bounding integer grid indices for linear interpolation\n        k1 = np.floor(xi).astype(int)\n        k2 = (k1 + 1) % Nx  # Handle periodicity at the domain edge\n        \n        # Calculate the interpolation weight (fractional part of the index)\n        alpha = xi - k1\n        \n        # Perform 1D linear interpolation for the entire 2D grid using numpy's\n        # advanced indexing. phi_n_1d is indexed by the 2D arrays k1 and k2.\n        phi_k1_vals = phi_n_1d[k1]\n        phi_k2_vals = phi_n_1d[k2]\n        \n        phi_sl = (1.0 - alpha) * phi_k1_vals + alpha * phi_k2_vals\n\n        # 4. Evaluate the metrics R and D\n\n        # Metric R: Amplitude ratio from discrete L2 norms\n        # np.linalg.norm for a 2D array computes the Frobenius norm, which is the\n        # required discrete L2 norm sqrt(sum of squares).\n        norm_sl = np.linalg.norm(phi_sl)\n        norm_exact = np.linalg.norm(phi_exact)\n        R = norm_sl / norm_exact\n        \n        # Metric D: Maximum grid-cell departure distance in x\n        # |x_i - x_d| = |S*y_j*dt|. We want the maximum over all j, divided by dx.\n        max_departure_physical = np.max(S * yy * dt)\n        D = max_departure_physical / dx\n\n        results.extend([R, D])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然高阶插值对于平滑廓形更精确，但在急剧变化的梯度附近，它可能产生非物理的振荡（过冲和下冲）。本练习 () 使用一个“高帽”廓形来检验不同插值格式的保单调性，这是保证诸如密度或浓度等物理量不超出其物理边界的关键属性。您将通过这个实践，直观地看到不同阶数插值在处理不连续问题时的表现。",
            "id": "3911345",
            "problem": "要求您设计并实现一个一维半拉格朗日平流测试，使用方帽示踪剂评估单调性，并量化虚假下冲的振幅与 Courant–Friedrichs–Lewy (CFL) 数和插值阶数的关系。您必须使用的基本依据是一维被动示踪剂平流方程和半拉格朗日输运的定义。\n\n场景与基本原理：\n- 考虑一个长度为 $L$ 米的周期性域上的一维被动示踪剂平流方程：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0,\n$$\n其中 $c(x,t)$ 是示踪剂浓度（无量纲），$u$ 是以 $\\mathrm{m/s}$ 为单位的恒定速度，$x$ 是以米为单位的空间坐标，$t$ 是以秒为单位的时间。\n- 半拉格朗日方法基于沿轨迹线的物质导数定义，即对于纯平流，示踪剂沿轨迹线是恒定的：\n$$\n\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0.\n$$\n- 基于此基础，推导如何在网格点 $x_i$ 处，通过计算出发点处前一时刻的示踪剂值，将 $c$ 从时间层 $t^n$推进到时间层 $t^{n+1} = t^n + \\Delta t$。您的推导必须从上述方程和核心定义出发，不得使用或假设任何快捷公式。\n\n数值设置：\n- 使用一个包含 $N$ 个点的均匀周期性网格，域长度 $L = 1$ (米)，空间步长 $\\Delta x = L/N$ (米)，速度 $u = 1$ (米/秒)，以及由 Courant–Friedrichs–Lewy 数决定的单个时间步长 $\\Delta t$ (秒)：\n$$\n\\mathrm{CFL} = \\frac{u \\Delta t}{\\Delta x}.\n$$\n- 初始化一个方帽示踪剂 $c(x,0)$，在区间 $[x_0, x_0+w)$ 上的振幅为 $1$，其他地方为 $0$，其中 $x_0 = 0.33 L$ (米)，$w = 0.20 L$ (米)。该示踪剂是无量纲的，并且初始值严格在 $[0,1]$ 范围内。\n\n插值与单调性评估：\n- 为计算出发点处前一时刻的示踪剂，实现三种插值阶数：\n  1. 阶数 $p=0$：最近邻插值。\n  2. 阶数 $p=1$：线性插值。\n  3. 阶数 $p=3$：使用最近的四个网格点值的立方拉格朗日插值。\n- 经过一个半拉格朗日时间步后，计算虚假下冲的振幅，定义为\n$$\nA_{\\text{under}} = \\max\\left(0, -\\min_i c^{n+1}(x_i)\\right),\n$$\n该值衡量对下界 $0$ 的违反程度。振幅是无量纲的（与 $c$ 的单位相同）。本问题不涉及角度。\n\n算法要求：\n- 从第一性原理出发，推导并实现半拉格朗日更新：为每个网格点计算其出发点，然后使用所选的插值阶数，并遵守周期性边界条件，将前一时刻的示踪剂插值到该点。\n- 确保实现是科学上真实且自洽的。使用足够大的 $N$ 来解析方帽和插值效应。\n\n测试套件：\n- 使用 $N = 2048$ (整数)，$L = 1$ (米)，$u = 1$ (米/秒)，以及方帽参数 $x_0 = 0.33 L$ 和 $w = 0.20 L$。\n- 对于每个测试用例，通过 $\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$ (秒) 从指定的 $\\mathrm{CFL}$ 计算 $\\Delta t$，执行恰好一个半拉格朗日步骤，并返回 $A_{\\text{under}}$。\n- 测试套件包含以下 $(p, \\mathrm{CFL})$ 对：\n  1. $(0, 0.75)$，\n  2. $(1, 0.75)$，\n  3. $(3, 0.75)$，\n  4. $(3, 0.25)$，\n  5. $(3, 1.00)$，\n  6. $(3, 2.25)$，\n  7. $(3, 0.00)$，\n  8. $(1, 0.25)$，\n  9. $(0, 0.25)$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含上述测试用例的九个振幅 $A_{\\text{under}}$，以逗号分隔的列表形式包含在方括号中，顺序与测试套件相同，每个振幅四舍五入到六位小数。例如：\n$$\n\\text{[0.000000,0.000000,0.012345,\\dots]}\n$$\n不应打印任何额外文本。",
            "solution": "该问题经验证具有科学依据、适定且客观。它构成了一个用于分析半拉格朗日平流格式性质的标准数值实验。我们将继续进行推导和求解。\n\n### 基于原理的半拉格朗日方法推导\n\n一维被动示踪剂平流方程如下：\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = 0\n$$\n其中 $c(x,t)$ 是示踪剂浓度，$u$ 是恒定速度，$x$ 是空间坐标，$t$ 是时间。左侧的表达式是浓度 $c$ 沿着随流体运动的轨迹 $X(t)$ 的物质导数，定义为 $\\frac{D c}{D t} = \\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x}$。因此，控制方程简化为：\n$$\n\\frac{D c}{D t} = 0\n$$\n该方程表明，浓度 $c$ 沿着特征线是恒定的，特征线即流体质点的轨迹。特征线 $X(\\tau)$ 由以下常微分方程描述：\n$$\n\\frac{dX(\\tau)}{d\\tau} = u\n$$\n为了求出网格点 $x_i$ 和时间 $t^{n+1} = t^n + \\Delta t$ 处的浓度 $c^{n+1}(x_i)$，我们从到达点 $(x_i, t^{n+1})$ 沿特征线向后追溯，以找到其在上一时间层 $t^n$ 的出发点 $(x_{d,i}, t^n)$。由于 $u$ 是常数，对轨迹方程从 $t^n$ 到 $t^{n+1}$ 进行积分是直接的：\n$$\n\\int_{t^n}^{t^{n+1}} \\frac{dX}{d\\tau} d\\tau = \\int_{t^n}^{t^{n+1}} u d\\tau\n$$\n$$\nX(t^{n+1}) - X(t^n) = u (t^{n+1} - t^n)\n$$\n代入 $X(t^{n+1}) = x_i$ 和出发点定义 $x_{d,i} = X(t^n)$，我们得到：\n$$\nx_i - x_{d,i} = u \\Delta t\n$$\n这就得到了出发点的位置：\n$$\nx_{d,i} = x_i - u \\Delta t\n$$\n原理 $\\frac{Dc}{Dt}=0$ 意味着浓度沿此路径是守恒的：\n$$\nc(x_i, t^{n+1}) = c(x_{d,i}, t^n)\n$$\n在数值计算的背景下，$c(x, t^n)$ 仅在离散的网格点 $x_j$ 上已知。出发点 $x_{d,i}$ 通常不会与任何网格点重合。因此，为了找到 $c(x_{d,i}, t^n)$ 的值，我们必须对时间 $t^n$ 的网格化数据进行插值。用 $\\mathcal{I}$ 表示插值算子，则半拉格朗日更新法则是：\n$$\nc_i^{n+1} = \\mathcal{I}[c^n](x_{d,i}) = \\mathcal{I}[c^n](x_i - u \\Delta t)\n$$\n\n### 数值实现\n\n长度为 $L=1$ 的域被离散化为 $N$ 个网格单元，网格间距为 $\\Delta x = L/N$。网格点为 $x_i = i \\Delta x$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$。速度为 $u=1$。我们可以用 Courant–Friedrichs–Lewy (CFL) 数表示时间步长：$\\Delta t = \\mathrm{CFL} \\cdot \\Delta x / u$。将这些代入出发点方程：\n$$\nx_{d,i} = x_i - u \\left(\\frac{\\mathrm{CFL} \\cdot \\Delta x}{u}\\right) = i\\Delta x - \\mathrm{CFL} \\cdot \\Delta x = (i - \\mathrm{CFL})\\Delta x\n$$\n这表明，以网格单位衡量的出发点位于无量纲坐标 $\\alpha_i = i - \\mathrm{CFL}$ 处。由于域是周期性的，大小为 $N$ 个网格单元，我们使用此坐标对 $N$ 取模：$\\alpha_{\\text{p},i} = \\alpha_i \\pmod N$。\n\n令 $j = \\lfloor \\alpha_{\\text{p},i} \\rfloor$ 为出发点前的最后一个网格点的索引，令 $s = \\alpha_{\\text{p},i} - j$ 为进入区间 $[x_j, x_{j+1})$ 的小数部分距离，其中 $s \\in [0, 1)$。值 $c_i^{n+1}$ 通过使用索引 $j$ 周围的点模板对 $c_k^n$ 的值进行插值得到。\n\n### 插值格式与单调性\n\n初始条件是值为 $[0, 1]$ 范围内的方帽函数。如果一个数值格式不引入新的极值，则它是单调的。对于这个问题，一个单调的格式将确保 $c_i^{n+1} \\in [0, 1]$，因此下冲振幅 $A_{\\text{under}} = \\max(0, -\\min_i c_i^{n+1})$ 将为零。\n\n1.  **阶数 $p=0$ (最近邻)**：取最近网格点的值。$c_i^{n+1} = c_{j+\\text{round}(s)}^n$。由于这只从初始数据中选择现有值，因此它是单调的。我们预期 $A_{\\text{under}}=0$。\n\n2.  **阶数 $p=1$ (线性插值)**：该值是两侧网格点值的加权平均。\n    $$\n    c_i^{n+1} = (1-s)c_j^n + s c_{j+1}^n\n    $$\n    作为 $[0, 1]$ 中两个值的凸组合，结果也在 $[0, 1]$ 范围内。此格式是单调的，我们预期 $A_{\\text{under}}=0$。\n\n3.  **阶数 $p=3$ (立方拉格朗日插值)**：我们使用最近的四个网格点，形成一个模板 $\\{j-1, j, j+1, j+2\\}$ 来构建一个三次多项式。所有索引都必须进行周期性处理，例如，索引 $j-1$ 变为 $(j-1) \\pmod N$。插值值为：\n    $$\n    c_i^{n+1} = c_{j-1}^n \\mathcal{L}_{-1}(s) + c_{j}^n \\mathcal{L}_{0}(s) + c_{j+1}^n \\mathcal{L}_{1}(s) + c_{j+2}^n \\mathcal{L}_{2}(s)\n    $$\n    其中 $\\mathcal{L}_k(s)$ 是在对应于模板点 $\\{-1, 0, 1, 2\\}$ 的归一化局部坐标 $s \\in [0,1)$ 处求值的拉格朗日基多项式：\n    $$\n    \\begin{align*}\n    \\mathcal{L}_{-1}(s) = -\\frac{s(s-1)(s-2)}{6} \\\\\n    \\mathcal{L}_{0}(s) = \\frac{(s+1)(s-1)(s-2)}{2} \\\\\n    \\mathcal{L}_{1}(s) = -\\frac{(s+1)s(s-2)}{2} \\\\\n    \\mathcal{L}_{2}(s) = \\frac{(s+1)s(s-1)}{6}\n    \\end{align*}\n    $$\n    此格式通常不是单调的。基多项式可以取负值，意味着插值结果不是一个凸组合。这可能导致在陡峭梯度附近出现虚假振荡（下冲和过冲），因此对于非整数 CFL 数，我们可能预期 $A_{\\text{under}} > 0$。对于整数 CFL 值，出发点与网格点对齐，$s=0$，插值变为精确选择 ($c_i^{n+1} = c_{i-\\mathrm{CFL}}^n$)，不会产生下冲。\n\n该算法通过遍历每个测试用例 $(p, \\mathrm{CFL})$，构建初始状态 $c^0$，使用指定的插值计算新状态 $c^1$，然后计算 $A_{\\text{under}}$ 来进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D semi-Lagrangian advection test for monotonicity.\n    \"\"\"\n    \n    # ------------------\n    # Numerical Setup\n    # ------------------\n    N = 2048\n    L = 1.0\n    u = 1.0\n    x0 = 0.33 * L\n    w = 0.20 * L\n    \n    dx = L / N\n    x = np.arange(N) * dx\n    \n    # ------------------\n    # Initial Condition\n    # ------------------\n    c0 = np.zeros(N, dtype=np.float64)\n    # Define the top-hat tracer profile\n    # Use boolean indexing for clarity and efficiency\n    c0[(x = x0)  (x  (x0 + w))] = 1.0\n    \n    # ------------------\n    # Test Suite\n    # ------------------\n    test_cases = [\n        (0, 0.75),\n        (1, 0.75),\n        (3, 0.75),\n        (3, 0.25),\n        (3, 1.00),\n        (3, 2.25),\n        (3, 0.00),\n        (1, 0.25),\n        (0, 0.25),\n    ]\n    \n    results = []\n    \n    for p, cfl in test_cases:\n        # For CFL=0, there is no change, so no undershoot\n        if cfl == 0.0:\n            results.append(0.0)\n            continue\n            \n        c1 = np.zeros(N, dtype=np.float64)\n\n        for i in range(N):\n            # Calculate departure point in non-dimensional grid coordinates\n            alpha = float(i) - cfl\n            \n            # Apply periodic boundary conditions. Python's % operator handles\n            # negative numbers in a way that is suitable for this (e.g., -0.75 % N = N-0.75).\n            alpha_periodic = alpha % N\n            \n            j = int(np.floor(alpha_periodic))\n            s = alpha_periodic - j\n\n            # Perform interpolation based on order p\n            if p == 0:  # Nearest-neighbor\n                idx = (j + int(round(s))) % N\n                c1[i] = c0[idx]\n            \n            elif p == 1:  # Linear\n                j0 = j\n                j1 = (j + 1) % N\n                c1[i] = (1.0 - s) * c0[j0] + s * c0[j1]\n            \n            elif p == 3:  # Cubic Lagrange\n                # Stencil points are j-1, j, j+1, j+2\n                j_m1 = (j - 1) % N\n                j_0 = j\n                j_1 = (j + 1) % N\n                j_2 = (j + 2) % N\n                \n                # Get the concentrations at the stencil points\n                c_m1 = c0[j_m1]\n                c_0 = c0[j_0]\n                c_1 = c0[j_1]\n                c_2 = c0[j_2]\n                \n                # Evaluate the Lagrange basis polynomials at s\n                l_m1 = -s * (s - 1.0) * (s - 2.0) / 6.0\n                l_0  = (s + 1.0) * (s - 1.0) * (s - 2.0) / 2.0\n                l_1  = -(s + 1.0) * s * (s - 2.0) / 2.0\n                l_2  = (s + 1.0) * s * (s - 1.0) / 6.0\n                \n                c1[i] = l_m1 * c_m1 + l_0 * c_0 + l_1 * c_1 + l_2 * c_2\n        \n        # Calculate amplitude of spurious undershoots\n        min_c1 = np.min(c1)\n        a_under = max(0.0, -min_c1)\n        results.append(a_under)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在多维问题中，为了简化计算，平流过程常被“分裂”成一系列一维步骤。然而，对于像磁化等离子体中常见的旋转流（如 $E \\times B$ 漂移）这样的不可分离流场，这种分裂会引入一种特定的误差。这项高级练习 () 将深入剖析刚体旋转中的分裂误差，将抽象的数值概念与具体的物理现象联系起来，并量化其对解的影响。",
            "id": "4199723",
            "problem": "考虑在坐标为 $x$ 和 $y$ 的平面上的二维被动标量平流方程，该方程由速度场 $\\boldsymbol{u}(x,y,t)$ 控制，写为一阶偏微分方程 (PDE)\n$$\n\\frac{\\partial f}{\\partial t} + \\boldsymbol{u}\\cdot\\nabla f = 0,\n$$\n其中 $f(x,y,t)$ 是被平流的标量。在半拉格朗日平流格式中，标量 $f$ 在到达点 $(x,y)$ 和时间 $t+\\Delta t$ 的值，是通过沿特征线回溯到时间 $t$ 的出发点 $(x_d,y_d)$，然后对 $f(x_d,y_d,t)$ 进行采样来计算的。该方法通过追踪特征线而非执行显式通量更新，避免了欧拉 Courant–Friedrichs–Lewy 约束。\n\n本问题分析维度分裂对旋转流引入的误差，并量化在与聚变等离子体湍流模拟相关的刚体旋转测试中的虚假交叉导数效应，其中ExB旋转是一种常见模式。你必须从第一性原理出发进行推导，并实现一个程序来计算在光滑测试函数上与分裂相关的误差，然后量化误差中与混合二阶导数（交叉导数）结构对齐的分量。\n\n基本原理和设置：\n- 速度是角速度为 $\\Omega$（单位：弧度/秒）的刚体旋转，由下式给出\n$$\nu(x,y) = -\\Omega\\,y,\\qquad v(x,y) = \\Omega\\,x.\n$$\n- 对于一个时间步长 $\\Delta t$（单位：秒），将时间 $t+\\Delta t$ 的到达位置 $(x,y)$ 映射到时间 $t$ 的出发位置 $(x_d,y_d)$ 的精确特征流是沿时间向后旋转角度 $\\theta=\\Omega\\,\\Delta t$（单位：弧度）。精确的出发点映射为\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad\ny_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n- 一个使用李分裂（Lie splitting）（先沿 $x$ 平流，再沿 $y$ 平流）的维度分裂半拉格朗日方法，通过顺序的一维回溯计算出发点映射：\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega\\,y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v(x^{(1)},y^{(1)})\\,\\Delta t = y - \\Omega\\,x^{(1)}\\,\\Delta t.\n$$\n- 初始条件 $f_0(x,y)$ 是一个旋转的椭圆高斯函数，这是一个光滑的测试剖面，它打破了轴对称性以暴露交叉导数耦合。通过\n$$\nx' = x\\cos\\alpha + y\\sin\\alpha,\\qquad y' = -x\\sin\\alpha + y\\cos\\alpha,\n$$\n定义主轴坐标，并令\n$$\nf_0(x,y) = \\exp\\!\\left(-\\left[\\frac{x'^2}{\\sigma_1^2} + \\frac{y'^2}{\\sigma_2^2}\\right]\\right),\n$$\n其中 $\\alpha$ 是旋转角（单位：弧度），$\\sigma_1, \\sigma_2$ 是半轴宽度（与 $x$ 和 $y$ 的长度单位相同）。精确的半拉格朗日更新得到 $f^{\\mathrm{exact}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\right)$，而分裂更新得到 $f^{\\mathrm{split}}(x,y) = f_0\\!\\left(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}}\\right)$。\n\n误差量化：\n- 定义局部误差场\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y).\n$$\n- 将在到达网格上的初始条件 $f_0$ 的混合二阶导数（交叉导数）定义为\n$$\nD_{xy}(x,y) = \\frac{\\partial^2 f_0}{\\partial x\\,\\partial y}(x,y),\n$$\n通过网格上的周期性中心差分进行数值计算。\n- 计算误差的 $L^2$ 范数\n$$\n\\|E\\|_{2} = \\left(\\int_{\\Omega_D} E(x,y)^2\\,\\mathrm{d}x\\,\\mathrm{d}y\\right)^{1/2},\n$$\n和 $L^\\infty$ 范数 $\\|E\\|_{\\infty} = \\max_{(x,y)\\in\\Omega_D} |E(x,y)|$，其中 $\\Omega_D$ 表示计算域。\n- 通过在网格上的离散内积中将 $E$ 正交投影到 $D_{xy}$ 上，来量化虚假的交叉导数效应：\n$$\nC_{xy} = \\frac{\\langle E, D_{xy} \\rangle}{\\langle D_{xy}, D_{xy} \\rangle},\n$$\n其中 $\\langle A,B\\rangle = \\int_{\\Omega_D} A(x,y)\\,B(x,y)\\,\\mathrm{d}x\\,\\mathrm{d}y$ 通过求和乘以单元面积来近似。与交叉导数结构对齐的误差能量的分数为\n$$\nR = \\frac{|C_{xy}|\\,\\|D_{xy}\\|_{2}}{\\|E\\|_{2}},\n$$\n此值为无量纲。\n\n域、单位和数值方法：\n- 使用边长为 $L$（单位：米）的方形周期性区域，即 $x,y\\in[-L/2,L/2)$，用 $N_x\\times N_y$ 个点进行均匀离散，间距为 $\\Delta x = L/N_x$，$\\Delta y = L/N_y$。\n- 时间单位为秒，$\\Omega$ 单位为弧度/秒，角度如 $\\theta$ 和 $\\alpha$ 单位为弧度。\n- 所有报告的输出均为无量纲浮点数。在此测试中，标量 $f$ 是无单位的。\n- 初始条件和所有 $f_0(x_d,y_d)$ 的求值都必须根据旋转高斯函数的定义进行解析计算，而不是通过网格插值，以将分裂误差与插值误差分离开来。\n\n程序行为要求：\n- 实现上述映射和度量。\n- 使用周期性中心差分计算 $D_{xy}$。\n- 对于每个测试用例，按顺序计算并返回四个浮点数：$\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$。\n\n测试套件：\n- 设 $N_x=N_y=128$，$L=1$，且 $\\Omega=2\\pi$。\n- 三个测试用例，涵盖不同方面：\n    1. 正常路径：$\\Delta t = 1/64$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    2. 更大的时间步长：$\\Delta t = 1/8$，$\\alpha = \\pi/6$，$\\sigma_1 = 0.15$，$\\sigma_2 = 0.25$。\n    3. 对称性边界情况（预计交叉导数投影接近于零）：$\\Delta t = 1/8$，$\\alpha = 0$，$\\sigma_1 = 0.2$，$\\sigma_2 = 0.2$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,\\dots]$），其中的条目是测试用例1的4个浮点数，后跟测试用例2的4个浮点数，再后跟测试用例3的4个浮点数；因此，单个列表中总共有12个浮点数。",
            "solution": "我们从被动标量平流偏微分方程 $\\partial_t f + \\boldsymbol{u}\\cdot\\nabla f = 0$ 开始，该方程意味着 $f$ 沿特征线为常数。特征曲线 $(x(t),y(t))$ 满足常微分方程 (ODE)\n$$\n\\frac{dx}{dt} = u(x,y) = -\\Omega\\,y, \\qquad \\frac{dy}{dt} = v(x,y) = \\Omega\\,x,\n$$\n其中 $\\Omega$ 是旋转的角频率。这些线性常微分方程的解是匀速旋转。在一个时间步长 $\\Delta t$ 内，从时间 $t$ 的 $(x_0,y_0)$ 到时间 $t+\\Delta t$ 的 $(x_1,y_1)$ 的前向映射为\n$$\nx_1 = x_0\\cos\\theta - y_0\\sin\\theta,\\qquad y_1 = x_0\\sin\\theta + y_0\\cos\\theta,\\qquad \\theta = \\Omega\\,\\Delta t.\n$$\n半拉格朗日更新需要回溯：给定时间 $t+\\Delta t$ 的 $(x,y)$，找到时间 $t$ 的 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$，使得 $f(x,y,t+\\Delta t) = f(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}},t)$。对前向旋转求逆，得到精确的出发点映射\n$$\nx_d^{\\mathrm{exact}} = x\\cos\\theta + y\\sin\\theta,\\qquad y_d^{\\mathrm{exact}} = -x\\sin\\theta + y\\cos\\theta.\n$$\n\n维度分裂通过顺序的一维求解来近似二维平流。对于李分裂（Lie splitting）（先沿 $x$ 移动，再沿 $y$ 移动），我们定义算子 $\\mathcal{A} = u(x,y)\\,\\partial_x$ 和 $\\mathcal{B} = v(x,y)\\,\\partial_y$。一个步长先应用时长为 $\\Delta t$ 的 $x$ 方向平流，然后应用时长为 $\\Delta t$ 的 $y$ 方向平流。相应的半拉格朗日回溯使用\n$$\nx^{(1)} = x - u(x,y)\\,\\Delta t = x + \\Omega y\\,\\Delta t,\\qquad y^{(1)} = y,\n$$\n$$\nx_d^{\\mathrm{split}} = x^{(1)},\\qquad y_d^{\\mathrm{split}} = y^{(1)} - v\\big(x^{(1)},y^{(1)}\\big)\\,\\Delta t = y - \\Omega x^{(1)}\\,\\Delta t.\n$$\n对于算子对易的可分离平流，此映射是精确的，但对于旋转，算子不对易。李分裂的局部误差可以使用 Baker-Campbell-Hausdorff (BCH) 展开进行分析：对于不对易的算子 $\\mathcal{A}$ 和 $\\mathcal{B}$，一个步长会引入一个与对易子 $[\\mathcal{A},\\mathcal{B}]$ 成正比的 $O(\\Delta t^2)$ 误差。对于我们的旋转场，其中 $\\mathcal{A} = -\\Omega y\\,\\partial_x$ 且 $\\mathcal{B} = \\Omega x\\,\\partial_y$，将对易子应用于光滑函数 $f$ 得到\n$$\n[\\mathcal{A},\\mathcal{B}] f = \\mathcal{A}(\\mathcal{B}f) - \\mathcal{B}(\\mathcal{A}f) = \\Omega^2\\left(x\\,\\partial_x f - y\\,\\partial_y f\\right).\n$$\n等价地，对小 $\\Delta t$ 的精确和分裂出发点映射进行泰勒展开，可以揭示\n$$\nx_d^{\\mathrm{exact}} = x + \\Omega y\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3),\\qquad\ny_d^{\\mathrm{exact}} = y - \\Omega x\\,\\Delta t - \\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3),\n$$\n而\n$$\nx_d^{\\mathrm{split}} = x + \\Omega y\\,\\Delta t,\\qquad\ny_d^{\\mathrm{split}} = y - \\Omega x\\,\\Delta t - \\Omega^2 y\\,\\Delta t^2.\n$$\n相减得到\n$$\n\\delta x_d = x_d^{\\mathrm{split}} - x_d^{\\mathrm{exact}} = \\tfrac{1}{2}\\Omega^2 x\\,\\Delta t^2 + O(\\Delta t^3), \\qquad\n\\delta y_d = y_d^{\\mathrm{split}} - y_d^{\\mathrm{exact}} = -\\tfrac{1}{2}\\Omega^2 y\\,\\Delta t^2 + O(\\Delta t^3).\n$$\n标量的领头阶误差则为\n$$\nE(x,y) = f^{\\mathrm{split}}(x,y) - f^{\\mathrm{exact}}(x,y) \\approx \\partial_x f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta x_d + \\partial_y f_0\\big(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}}\\big)\\,\\delta y_d,\n$$\n在 $O(\\Delta t^2)$ 阶上，这与对易子的结果一致，\n$$\nE(x,y) \\approx \\tfrac{1}{2}\\Omega^2\\,\\Delta t^2\\left(x\\,\\partial_x f_0 - y\\,\\partial_y f_0\\right),\n$$\n在适当接近的点上求值。这表明主导误差是方向导数的不平衡，而不是纯粹的混合导数。然而，在旋转的各向异性高斯函数 $f_0$ 上，空间结构将这些不平衡耦合到包含混合导数 $\\partial^2 f_0/(\\partial x\\,\\partial y)$ 的基分量中，从而导致在 $D_{xy}$ 上产生可测量的投影。\n\n为量化这种虚假的交叉导数效应，我们计算：\n1. 误差场 $E(x,y)$，作为分裂和精确半拉格朗日更新之间的差值，其中更新是通过在各自的出发点解析地计算 $f_0$ 来执行的。这将分裂误差与插值误差分离开来。\n2. $E$ 的 $L^2$ 和 $L^\\infty$ 范数，即 $\\|E\\|_2$ 和 $\\|E\\|_\\infty$。\n3. 网格上对 $D_{xy}(x,y)$ 的周期性中心差分近似。\n4. 投影系数 $C_{xy} = \\langle E,D_{xy}\\rangle/\\langle D_{xy},D_{xy}\\rangle$ 和分数 $R = |C_{xy}|\\,\\|D_{xy}\\|_2/\\|E\\|_2$。\n\n算法设计：\n- 在 $x,y\\in[-L/2,L/2)$ 上构建一个包含 $N_x=N_y=128$ 个点的均匀网格，其中 $L=1$，间距为 $\\Delta x = \\Delta y = L/N_x$。\n- 定义旋转坐标 $x' = x\\cos\\alpha + y\\sin\\alpha$, $y' = -x\\sin\\alpha + y\\cos\\alpha$，以及 $f_0(x,y) = \\exp\\!\\left(-\\left[x'^2/\\sigma_1^2 + y'^2/\\sigma_2^2\\right]\\right)$。\n- 对于每个角速度为 $\\Omega=2\\pi$ 且给定 $\\Delta t$ 的测试用例，计算 $\\theta=\\Omega\\Delta t$（单位：弧度）。\n- 通过上述公式计算精确和分裂的出发点映射，以获得 $(x_d^{\\mathrm{exact}},y_d^{\\mathrm{exact}})$ 和 $(x_d^{\\mathrm{split}},y_d^{\\mathrm{split}})$。\n- 在这些出发点解析地计算 $f_0$，以在到达网格上获得 $f^{\\mathrm{exact}}$ 和 $f^{\\mathrm{split}}$；计算 $E=f^{\\mathrm{split}}-f^{\\mathrm{exact}}$。\n- 通过周期性中心差分计算 $D_{xy}$：\n$$\nD_{xy}(i,j) \\approx \\frac{f_0(i+1,j+1)-f_0(i+1,j-1)-f_0(i-1,j+1)+f_0(i-1,j-1)}{4\\,\\Delta x\\,\\Delta y}.\n$$\n- 用单元面积 $\\Delta x\\,\\Delta y$ 计算离散内积，以获得每个测试用例的 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$。\n\n测试套件覆盖范围：\n- 一个小 $\\Delta t$ 的情况（$\\Delta t=1/64$）展示了 $\\|E\\|_2$ 预期的 $O(\\Delta t^2)$ 标度性和通常较小的 $R$。\n- 一个较大 $\\Delta t$ 的情况（$\\Delta t=1/8$）放大了分裂误差和交叉导数投影，增加了 $\\|E\\|_\\infty$ 和 $R$。\n- 一个对称性边界情况，其中 $\\alpha=0$ 且 $\\sigma_1=\\sigma_2$，使得初始条件具有旋转对称性；尽管 $D_{xy}$ 不恒为零，但由于对称性，预计投影系数 $C_{xy}$ 和分数 $R$ 会相对较小。\n\n最终的程序遵循这些步骤，并按要求为每个测试用例依次报告四个浮点数 $\\|E\\|_2$、$\\|E\\|_\\infty$、$C_{xy}$ 和 $R$，汇总成一个用方括号括起来的逗号分隔列表。所有角度均以弧度处理，$\\Omega$ 的单位是弧度/秒，$\\Delta t$ 的单位是秒，输出是无量纲的浮点数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rotated_gaussian(x, y, sigma1, sigma2, alpha):\n    # Compute rotated coordinates\n    xp = x * np.cos(alpha) + y * np.sin(alpha)\n    yp = -x * np.sin(alpha) + y * np.cos(alpha)\n    return np.exp(-((xp / sigma1) ** 2 + (yp / sigma2) ** 2))\n\ndef exact_departure(x, y, theta):\n    # Backward characteristic for solid-body rotation: inverse of forward rotation\n    xd = x * np.cos(theta) + y * np.sin(theta)\n    yd = -x * np.sin(theta) + y * np.cos(theta)\n    return xd, yd\n\ndef split_departure_lie(x, y, omega, dt):\n    # Lie splitting: first x-advection then y-advection\n    x1 = x + omega * y * dt\n    y1 = y\n    yd = y1 - omega * x1 * dt\n    xd = x1\n    return xd, yd\n\ndef mixed_derivative_periodic(f, dx, dy):\n    # Central mixed derivative with periodic boundary conditions:\n    # Dxy ≈ (f(i+1,j+1) - f(i+1,j-1) - f(i-1,j+1) + f(i-1,j-1)) / (4 dx dy)\n    f_ip_jp = np.roll(np.roll(f, -1, axis=0), -1, axis=1)\n    f_ip_jm = np.roll(np.roll(f, -1, axis=0),  1, axis=1)\n    f_im_jp = np.roll(np.roll(f,  1, axis=0), -1, axis=1)\n    f_im_jm = np.roll(np.roll(f,  1, axis=0),  1, axis=1)\n    dxy = (f_ip_jp - f_ip_jm - f_im_jp + f_im_jm) / (4.0 * dx * dy)\n    return dxy\n\ndef inner_product(a, b, cell_area):\n    return np.sum(a * b) * cell_area\n\ndef l2_norm(a, cell_area):\n    return np.sqrt(np.sum(a * a) * cell_area)\n\ndef linf_norm(a):\n    return float(np.max(np.abs(a)))\n\ndef run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2):\n    # Grid\n    x = (np.arange(nx) - nx/2) * (L / nx)\n    y = (np.arange(ny) - ny/2) * (L / ny)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    dx = L / nx\n    dy = L / ny\n    cell_area = dx * dy\n\n    # Initial condition\n    f0 = rotated_gaussian(X, Y, sigma1, sigma2, alpha)\n\n    # Exact and split departures\n    theta = omega * dt\n    xd_exact, yd_exact = exact_departure(X, Y, theta)\n    xd_split, yd_split = split_departure_lie(X, Y, omega, dt)\n\n    # Evaluate f0 analytically at departure points\n    f_exact = rotated_gaussian(xd_exact, yd_exact, sigma1, sigma2, alpha)\n    f_split = rotated_gaussian(xd_split, yd_split, sigma1, sigma2, alpha)\n\n    # Error field\n    E = f_split - f_exact\n\n    # Mixed derivative of initial field at arrival grid\n    Dxy = mixed_derivative_periodic(f0, dx, dy)\n\n    # Norms and projections\n    E_l2 = l2_norm(E, cell_area)\n    E_linf = linf_norm(E)\n\n    denom = inner_product(Dxy, Dxy, cell_area)\n    if denom > 0:\n        Cxy = inner_product(E, Dxy, cell_area) / denom\n        Dxy_l2 = l2_norm(Dxy, cell_area)\n        R = (abs(Cxy) * Dxy_l2 / E_l2) if E_l2 > 0 else 0.0\n    else:\n        Cxy = 0.0\n        R = 0.0\n\n    return float(E_l2), float(E_linf), float(Cxy), float(R)\n\ndef solve():\n    # Define constants for all test cases\n    nx = 128\n    ny = 128\n    L = 1.0\n    omega = 2.0 * np.pi  # radians per second\n\n    # Test suite: (dt, alpha, sigma1, sigma2)\n    test_cases = [\n        (1.0/64.0, np.pi/6.0, 0.15, 0.25),  # Happy path\n        (1.0/8.0,  np.pi/6.0, 0.15, 0.25),  # Larger time step\n        (1.0/8.0,  0.0,       0.20, 0.20),  # Symmetry edge case\n    ]\n\n    results = []\n    for dt, alpha, sigma1, sigma2 in test_cases:\n        E_l2, E_linf, Cxy, R = run_case(nx, ny, L, omega, dt, alpha, sigma1, sigma2)\n        results.extend([E_l2, E_linf, Cxy, R])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: f'{x:.8e}', results))}]\")\n\nsolve()\n```"
        }
    ]
}