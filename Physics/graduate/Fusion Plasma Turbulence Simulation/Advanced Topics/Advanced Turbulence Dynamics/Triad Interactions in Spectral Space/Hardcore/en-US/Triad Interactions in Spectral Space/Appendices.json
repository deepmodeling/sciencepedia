{
    "hands_on_practices": [
        {
            "introduction": "Before simulating nonlinear dynamics, we must first identify all possible pathways for energy transfer. This practice translates the abstract convolution theorem into a concrete computational task: building an algorithm to enumerate every resonant triad $(\\mathbf{k}, \\mathbf{p}, \\mathbf{q})$ that satisfies $\\mathbf{k} = \\mathbf{p} + \\mathbf{q}$ within a discrete spectral grid. Mastering this is a foundational step in developing and analyzing any spectral turbulence code, as it maps the complete network of nonlinear interactions. ",
            "id": "4207745",
            "problem": "You are tasked with designing and implementing an algorithm to enumerate all spectral triads in a two-dimensional periodic domain that are relevant to nonlinear mode coupling in fusion plasma turbulence simulations. Begin from first principles and core definitions about Fourier representations of fields and the convolution property of quadratic nonlinearities. Use these principles to justify the triad condition in spectral space and to design a computational strategy and its complexity analysis.\n\nAssume a square periodic domain of side length $2\\pi$, so the Fourier wavevectors are integer pairs $\\mathbf{k} = (k_x, k_y)$ with $k_x \\in \\mathbb{Z}$ and $k_y \\in \\mathbb{Z}$. Let $k_{\\max} \\in \\mathbb{N}$ define the maximum wavenumber cutoff. Define the admissible set of nonzero modes by\n$$\n\\mathcal{S}(k_{\\max}) = \\left\\{ (k_x,k_y) \\in \\mathbb{Z}^2 \\setminus \\{(0,0)\\} \\;\\middle|\\; k_x^2 + k_y^2 \\le k_{\\max}^2 \\right\\}.\n$$\nIn spectral space, a triad is an unordered triple $\\{\\mathbf{k},\\mathbf{p},\\mathbf{q}\\} \\subset \\mathcal{S}(k_{\\max})$ that satisfies the resonance condition\n$$\n\\mathbf{k} = \\mathbf{p} + \\mathbf{q},\n$$\nwhere $\\mathbf{p}$ and $\\mathbf{q}$ are elements of $\\mathcal{S}(k_{\\max})$ and the sum is taken component-wise. The triad is considered unordered: any permutation of $(\\mathbf{k},\\mathbf{p},\\mathbf{q})$ represents the same triad. The zero mode $(0,0)$ is excluded from $\\mathcal{S}(k_{\\max})$, and degenerate pairs with $\\mathbf{p} = \\mathbf{q}$ are permitted provided $2\\mathbf{p} \\in \\mathcal{S}(k_{\\max})$.\n\nStarting from the fundamental fact that the Fourier transform maps products in real space to convolutions in spectral space, derive the triad condition and then design an algorithm that:\n- Constructs $\\mathcal{S}(k_{\\max})$.\n- Enumerates all unique unordered triads $\\{\\mathbf{k},\\mathbf{p},\\mathbf{q}\\}$ with $\\mathbf{k} = \\mathbf{p} + \\mathbf{q}$ and $\\mathbf{k},\\mathbf{p},\\mathbf{q} \\in \\mathcal{S}(k_{\\max})$.\n- Avoids double-counting the same triad under permutation of $(\\mathbf{k},\\mathbf{p},\\mathbf{q})$.\n\nAnalyze the computational complexity of your algorithm in terms of the number of admissible modes $M = |\\mathcal{S}(k_{\\max})|$ and the parameter $k_{\\max}$, and provide clear reasoning for your complexity class. Express your complexity analysis in big-$\\mathcal{O}$ notation and justify any assumptions such as constant-time set membership.\n\nYour program must implement the algorithm and, for a provided test suite of $k_{\\max}$ values, compute for each case:\n- The number of unique unordered triads $T$ found by your algorithm.\n- The number of admissible modes $M$.\n- The number of unordered pairs of modes checked $P$, where pairs include $\\mathbf{p} = \\mathbf{q}$ and are treated as unordered, so $P = M(M+1)/2$.\n\nTest Suite:\n- Case $1$: $k_{\\max} = 0$.\n- Case $2$: $k_{\\max} = 1$.\n- Case $3$: $k_{\\max} = 2$.\n- Case $4$: $k_{\\max} = 3$.\n- Case $5$: $k_{\\max} = 4$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results for the five test cases as a comma-separated list of lists, in the exact form\n$$\n\\left[ [T_1,M_1,P_1],[T_2,M_2,P_2],[T_3,M_3,P_3],[T_4,M_4,P_4],[T_5,M_5,P_5] \\right].\n$$\nNo physical units or angle units are required for this problem. All computed outputs must be integers. The program must be fully self-contained and require no user input.",
            "solution": "The task is motivated by the convolution structure of quadratic nonlinearities in spectral representations of fluid-like plasma models. Consider a scalar field $\\phi(x,y,t)$ defined on a two-dimensional periodic square of side $2\\pi$. Its Fourier series is\n$$\n\\phi(x,y,t) = \\sum_{\\mathbf{k} \\in \\mathbb{Z}^2} \\hat{\\phi}_\\mathbf{k}(t) \\, e^{i(k_x x + k_y y)}.\n$$\nFor models with quadratic nonlinearities such as the advective nonlinearity in the two-dimensional incompressible flow or the Poisson bracket nonlinearity in drift-wave turbulence, a typical nonlinear term involves products of fields (or their derivatives) in real space. By the convolution theorem, the Fourier transform of a product becomes a convolution. For two fields $\\phi$ and $\\psi$ with Fourier coefficients $\\hat{\\phi}_\\mathbf{k}$ and $\\hat{\\psi}_\\mathbf{k}$, the Fourier coefficient of their product at mode $\\mathbf{k}$ is\n$$\n\\widehat{(\\phi \\psi)}_\\mathbf{k} = \\sum_{\\mathbf{p} \\in \\mathbb{Z}^2} \\hat{\\phi}_\\mathbf{p} \\, \\hat{\\psi}_{\\mathbf{k}-\\mathbf{p}}.\n$$\nThe sum is over all integer wavevectors $\\mathbf{p}$, and $\\mathbf{q} = \\mathbf{k} - \\mathbf{p}$ is another wavevector. This shows that the spectral coefficient at $\\mathbf{k}$ couples to pairs $(\\mathbf{p},\\mathbf{q})$ that satisfy $\\mathbf{p} + \\mathbf{q} = \\mathbf{k}$. In turbulence systems, nonlinear energy transfer arises from these triad interactions. Hence, the triad condition\n$$\n\\mathbf{k} = \\mathbf{p} + \\mathbf{q}\n$$\nis fundamental, and the set of three participating wavevectors $\\{\\mathbf{k},\\mathbf{p},\\mathbf{q}\\}$ defines a triad.\n\nWe restrict the spectral domain to a finite set motivated by numerical simulations: we consider only integer wavevectors $(k_x,k_y)$ satisfying $k_x^2 + k_y^2 \\le k_{\\max}^2$, excluding the zero mode. This set is\n$$\n\\mathcal{S}(k_{\\max}) = \\left\\{ (k_x,k_y) \\in \\mathbb{Z}^2 \\setminus \\{(0,0)\\} \\;\\middle|\\; k_x^2 + k_y^2 \\le k_{\\max}^2 \\right\\}.\n$$\nThe number of admissible modes is $M = |\\mathcal{S}(k_{\\max})|$. As $k_{\\max}$ grows, $M$ scales like the number of integer lattice points inside a disk of radius $k_{\\max}$, which asymptotically satisfies\n$$\nM \\sim \\pi k_{\\max}^2 \\quad \\text{as } k_{\\max} \\to \\infty,\n$$\nup to boundary effects.\n\nAlgorithm design:\n1. Construct $\\mathcal{S}(k_{\\max})$ by iterating over integer $k_x$ and $k_y$ in the range $[-k_{\\max}, k_{\\max}]$, excluding $(0,0)$, and retaining those for which $k_x^2 + k_y^2 \\le k_{\\max}^2$. Store the set both as a list for ordered iteration and as a hash set (e.g., Python set of tuples) for $O(1)$ average-time membership queries.\n2. Enumerate unordered pairs $(\\mathbf{p},\\mathbf{q})$ from $\\mathcal{S}(k_{\\max})$, including the degenerate case $\\mathbf{p} = \\mathbf{q}$. Use indices $i$ and $j$ with $0 \\le i \\le j  M$ for the list of modes of length $M$. The total number of unordered pairs considered is\n   $$\n   P = \\frac{M(M+1)}{2}.\n   $$\n3. For each pair $(\\mathbf{p},\\mathbf{q})$, compute $\\mathbf{k} = \\mathbf{p} + \\mathbf{q}$ as component-wise addition, and check whether $\\mathbf{k} \\in \\mathcal{S}(k_{\\max})$. If true, then the triple $(\\mathbf{k},\\mathbf{p},\\mathbf{q})$ satisfies the triad condition. Because the triad is unordered, the same triple can also arise from the other pair sums. To avoid double-counting, canonicalize the triple $\\{\\mathbf{k},\\mathbf{p},\\mathbf{q}\\}$ by sorting its three vectors under a fixed lexicographic order and inserting the resulting ordered triple into a hash set of triads. This ensures each unordered triad is counted exactly once.\n4. The output for each $k_{\\max}$ is the number of unique triads $T$, the number of modes $M$, and the number of pairs checked $P$.\n\nComplexity analysis:\n- Constructing $\\mathcal{S}(k_{\\max})$ requires checking all integer pairs $(k_x,k_y)$ in the square $[-k_{\\max},k_{\\max}]^2$, which has $(2k_{\\max}+1)^2$ points. The time to build the set is $O(k_{\\max}^2)$, consistent with $M = O(k_{\\max}^2)$, and the space is $O(M)$.\n- Enumerating all unordered pairs $(\\mathbf{p},\\mathbf{q})$ is $P = M(M+1)/2 = O(M^2)$ iterations. For each pair, computing $\\mathbf{k} = \\mathbf{p} + \\mathbf{q}$ and checking membership in the hash set is $O(1)$ average time. Canonicalization and insertion in a triad set are $O(1)$ average time for hashing (sorting three items is $O(1)$ since it is constant size).\n- Therefore, the total time complexity is\n  $$\n  O(M^2),\n  $$\n  and the space complexity is\n  $$\n  O(M + T),\n  $$\n  where $T$ is the number of unique triads found, with $T \\le P$.\n- In terms of $k_{\\max}$, using $M = \\Theta(k_{\\max}^2)$ gives overall time $O(k_{\\max}^4)$.\n\nCorrectness argument:\n- The convolution property in spectral space requires that nonlinear coupling into mode $\\mathbf{k}$ comes from pairs $(\\mathbf{p},\\mathbf{q})$ satisfying $\\mathbf{p} + \\mathbf{q} = \\mathbf{k}$. Enumerating all such pairs over $\\mathcal{S}(k_{\\max})$ and collecting unordered triples ensures all triads consistent with the resonance condition are found.\n- Excluding $(0,0)$ avoids trivial couplings via the zero mode, in line with typical simulation practice. Allowing $\\mathbf{p} = \\mathbf{q}$ ensures that valid degenerate triads with $\\mathbf{k} = 2\\mathbf{p}$ are included.\n- Canonicalization via sorting removes permutation ambiguities among $(\\mathbf{k},\\mathbf{p},\\mathbf{q})$, producing a well-defined count of unordered triads.\n\nTest suite and outputs:\n- For $k_{\\max} \\in \\{0,1,2,3,4\\}$, the program constructs $\\mathcal{S}(k_{\\max})$, enumerates triads, and prints a single line\n  $$\n  \\left[ [T_1,M_1,P_1],[T_2,M_2,P_2],[T_3,M_3,P_3],[T_4,M_4,P_4],[T_5,M_5,P_5] \\right],\n  $$\n  where $T_i$ is the triad count, $M_i$ is the mode count, and $P_i = M_i(M_i+1)/2$ is the pair count for case $i$. All values are integers.\n\nThis approach is scientifically realistic and algorithmically grounded in the fundamental convolution property, producing an efficient enumeration consistent with the typical structure of spectral nonlinearities used in fusion plasma turbulence simulations such as drift-wave and gyrofluid models.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_modes(kmax: int):\n    \"\"\"\n    Generate the set of integer 2D wavevectors (kx, ky) with 0  kx^2 + ky^2 = kmax^2.\n    Returns both a list (for ordered iteration) and a set (for O(1) membership).\n    \"\"\"\n    modes_list = []\n    r2_max = kmax * kmax\n    # Iterate over square box [-kmax, kmax]^2\n    for kx in range(-kmax, kmax + 1):\n        for ky in range(-kmax, kmax + 1):\n            if kx == 0 and ky == 0:\n                continue  # exclude zero mode\n            r2 = kx * kx + ky * ky\n            if r2 = r2_max:\n                modes_list.append((kx, ky))\n    modes_set = set(modes_list)\n    return modes_list, modes_set\n\ndef enumerate_triads(kmax: int):\n    \"\"\"\n    Enumerate all unique unordered triads {k, p, q} such that k = p + q,\n    with k, p, q in the admissible set S(kmax).\n    Returns:\n      T: number of unique triads\n      M: number of admissible modes\n      P: number of unordered pairs checked (= M*(M+1)//2)\n    \"\"\"\n    modes_list, modes_set = generate_modes(kmax)\n    M = len(modes_list)\n    # Number of unordered pairs including p = q\n    P = M * (M + 1) // 2\n\n    triads_set = set()  # store canonical triads as sorted tuples of 2D tuples\n\n    # Iterate over unordered pairs (i = j)\n    for i in range(M):\n        p = modes_list[i]\n        for j in range(i, M):\n            q = modes_list[j]\n            k = (p[0] + q[0], p[1] + q[1])\n            if k in modes_set:\n                # Canonicalize unordered triad by sorting lexicographically\n                triad = tuple(sorted((k, p, q)))\n                triads_set.add(triad)\n\n    T = len(triads_set)\n    return T, M, P\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 2, 3, 4]\n\n    results = []\n    for kmax in test_cases:\n        T, M, P = enumerate_triads(kmax)\n        results.append([T, M, P])\n\n    # Final print statement in the exact required format.\n    # A single line, comma-separated lists enclosed in square brackets.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "From the static map of all possible triads, we now turn to their time evolution. This exercise isolates a single triad—the fundamental building block of nonlinear dynamics—to explore its behavior and the numerical methods required to simulate it accurately. You will implement a geometric integrator designed to respect the underlying physics, verifying that the numerical solution conserves the system's physical invariants, a critical skill in computational science. ",
            "id": "4207771",
            "problem": "Consider triad interactions in spectral space as a reduced model of quadratic nonlinear coupling among three complex Fourier amplitudes representing resonantly interacting drift-wave modes in fusion plasma turbulence. Let the complex amplitudes be $a_1(t)$, $a_2(t)$, and $a_3(t)$, with a real coupling coefficient $\\kappa \\in \\mathbb{R}$. The governing Ordinary Differential Equations (ODEs) are\n$$\n\\frac{d a_1}{dt} = i\\,\\kappa\\, a_2^*(t)\\, a_3^*(t), \\quad\n\\frac{d a_2}{dt} = i\\,\\kappa\\, a_1^*(t)\\, a_3^*(t), \\quad\n\\frac{d a_3}{dt} = i\\,\\kappa\\, a_1^*(t)\\, a_2^*(t),\n$$\nwhere $i$ is the imaginary unit and ${}^*$ denotes complex conjugation. The system possesses quadratic invariants known as the Manley–Rowe invariants, defined by\n$$\nI_{12}(t) = |a_1(t)|^2 - |a_2(t)|^2, \\quad I_{13}(t) = |a_1(t)|^2 - |a_3(t)|^2,\n$$\nand a Hamiltonian energy\n$$\nH(t) = \\kappa\\left(a_1(t)\\,a_2(t)\\,a_3(t) + a_1^*(t)\\,a_2^*(t)\\,a_3^*(t)\\right).\n$$\nFor exact integration, $I_{12}(t)$, $I_{13}(t)$, and $H(t)$ are constants in time.\n\nYou are to implement a discrete time-stepping scheme designed to conserve these invariants over long integration times. Use the implicit midpoint method with shared averages across the triad, defined by\n$$\na_j^{n+1} - a_j^n = i\\,\\kappa\\,\\Delta t\\,\\left(\\overline{a_m^{\\mathrm{avg}}}\\right)\\left(\\overline{a_n^{\\mathrm{avg}}}\\right), \\quad j \\in \\{1,2,3\\},\n$$\nwhere for each time step $n \\to n+1$,\n$$\na_j^{\\mathrm{avg}} = \\frac{1}{2}\\left(a_j^{n+1} + a_j^{n}\\right),\n$$\nand $\\{j,m,n\\} = \\{1,2,3\\}$ is a cyclic permutation so that the update for $a_1$ uses $a_2^{\\mathrm{avg}}$ and $a_3^{\\mathrm{avg}}$, and similarly for $a_2$ and $a_3$. This scheme is implicit and must be solved at each time step for $(a_1^{n+1}, a_2^{n+1}, a_3^{n+1})$, for example using fixed-point iteration with a sufficiently small time step $\\Delta t$.\n\nStarting from the definitions above and well-tested facts about quadratic invariants in Hamiltonian systems, derive the invariants and justify conservation under the midpoint scheme from first principles. Then implement the scheme and verify conservation numerically with a manufactured triad solution by tracking the maximum absolute drift in $I_{12}$, $I_{13}$, and $H$ relative to their initial values over the full integration time.\n\nYour program must perform the following for each test case:\n- Integrate from $t=0$ to $t=T$ using a uniform time step $\\Delta t$ and the implicit midpoint method described above.\n- Compute $I_{12}(t)$, $I_{13}(t)$, and $H(t)$ at every step, and track the maximum absolute drift relative to their initial values at $t=0$:\n$$\nD_{12} = \\max_{0 \\le n \\le N} \\left|I_{12}^n - I_{12}^0\\right|,\\quad\nD_{13} = \\max_{0 \\le n \\le N} \\left|I_{13}^n - I_{13}^0\\right|,\\quad\nD_H = \\max_{0 \\le n \\le N} \\left|H^n - H^0\\right|,\n$$\nwhere $N = T/\\Delta t$ is the number of time steps.\n- Declare the invariants to be numerically conserved if $D_{12} \\le \\varepsilon_I$, $D_{13} \\le \\varepsilon_I$, and $D_H \\le \\varepsilon_H$ for given tolerances $\\varepsilon_I$ and $\\varepsilon_H$.\n\nUse the following test suite, chosen to cover a general case, a stiff case, and an edge case involving a vanishing amplitude:\n1. Case A (general, long time): $\\kappa = 1.0$, $a_1(0) = 1 + 0.2i$, $a_2(0) = 0.8 - 0.4i$, $a_3(0) = -0.6 + 0.3i$, $T = 200$, $\\Delta t = 0.01$, $\\varepsilon_I = 10^{-8}$, $\\varepsilon_H = 5\\times 10^{-3}$.\n2. Case B (stiff coupling): $\\kappa = 10.0$, $a_1(0) = 0.1 + 0.0i$, $a_2(0) = 0.2 + 0.0i$, $a_3(0) = 0.3 + 0.0i$, $T = 2.0$, $\\Delta t = 10^{-3}$, $\\varepsilon_I = 10^{-8}$, $\\varepsilon_H = 5\\times 10^{-3}$.\n3. Case C (edge with zero amplitude): $\\kappa = 1.0$, $a_1(0) = 1.0 + 0.0i$, $a_2(0) = 1.0 + 0.0i$, $a_3(0) = 0.0 + 0.0i$, $T = 50$, $\\Delta t = 0.01$, $\\varepsilon_I = 10^{-8}$, $\\varepsilon_H = 5\\times 10^{-3}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one Boolean per test case indicating whether all invariants are conserved within the specified tolerances, in the order [Case A, Case B, Case C]. For example: \"[True,False,True]\".",
            "solution": "The problem requires an analysis of the conservation properties of a system describing resonant triad interactions, both for the continuous-time dynamics and a specific discrete-time numerical scheme.\n\n**1. Conservation in the Continuous System**\n\nFirst, we demonstrate that $I_{12}$, $I_{13}$, and $H$ are indeed invariants of the continuous system.\n\n**Manley-Rowe Invariants ($I_{12}, I_{13}$):**\nThe rate of change of the squared magnitude of an amplitude $a_j$ is given by $\\frac{d|a_j|^2}{dt} = \\frac{d(a_j a_j^*)}{dt} = \\frac{da_j}{dt}a_j^* + a_j\\frac{da_j^*}{dt}$. Taking the complex conjugate of the governing ODEs yields $\\frac{da_j^*}{dt} = -i\\kappa a_m(t) a_n(t)$. For $a_1$, we have:\n$$\n\\frac{d|a_1|^2}{dt} = (i\\kappa a_2^* a_3^*) a_1^* + a_1 (-i\\kappa a_2 a_3) = i\\kappa(a_1^* a_2^* a_3^* - a_1 a_2 a_3)\n$$\nDue to the symmetric structure of the governing equations, the exact same calculation applies to $a_2$ and $a_3$:\n$$\n\\frac{d|a_2|^2}{dt} = \\frac{d|a_3|^2}{dt} = i\\kappa(a_1^* a_2^* a_3^* - a_1 a_2 a_3)\n$$\nSince $\\frac{d|a_1|^2}{dt} = \\frac{d|a_2|^2}{dt} = \\frac{d|a_3|^2}{dt}$, it follows directly that the differences in these quantities are constant in time:\n$$\n\\frac{dI_{12}}{dt} = \\frac{d}{dt}(|a_1|^2 - |a_2|^2) = 0, \\quad \\frac{dI_{13}}{dt} = \\frac{d}{dt}(|a_1|^2 - |a_3|^2) = 0\n$$\n\n**Hamiltonian ($H$):**\nLet $S(t) = a_1(t)a_2(t)a_3(t)$. The Hamiltonian is $H(t) = \\kappa(S(t) + S^*(t))$. Its time derivative is $\\frac{dH}{dt} = \\kappa(\\frac{dS}{dt} + \\frac{dS^*}{dt})$. We compute $\\frac{dS}{dt}$:\n$$\n\\frac{dS}{dt} = \\frac{da_1}{dt}a_2a_3 + a_1\\frac{da_2}{dt}a_3 + a_1a_2\\frac{da_3}{dt} = i\\kappa\\left(|a_2|^2|a_3|^2+|a_1|^2|a_3|^2+|a_1|^2|a_2|^2\\right)\n$$\nThe term in the parenthesis is purely real, so its complex conjugate is itself. Thus, $\\frac{dS^*}{dt} = -i\\kappa(\\dots)$. The derivative of the Hamiltonian is therefore zero:\n$$\n\\frac{dH}{dt} = \\kappa\\left(\\frac{dS}{dt} + \\frac{dS^*}{dt}\\right) = \\kappa \\left( i\\kappa(\\dots) - i\\kappa(\\dots) \\right) = 0\n$$\n\n**2. Conservation in the Discrete Scheme**\n\nThe implicit midpoint method is a geometric integrator. We show it exactly conserves the quadratic Manley-Rowe invariants. The change in the squared magnitude of $a_1$ from step $n$ to $n+1$ is:\n$$\n|a_1^{n+1}|^2 - |a_1^n|^2 = \\mathrm{Re}\\left( (a_1^{n+1}-a_1^n)(a_1^{n+1}+a_1^n)^* \\right)\n$$\nUsing the midpoint definitions, $a_1^{n+1}-a_1^n = i\\kappa\\Delta t (a_2^{\\mathrm{avg}})^*(a_3^{\\mathrm{avg}})^*$ and $a_1^{n+1}+a_1^n = 2a_1^{\\mathrm{avg}}$, this becomes:\n$$\n|a_1^{n+1}|^2 - |a_1^n|^2 = \\mathrm{Re}\\left( i \\cdot 2\\kappa\\Delta t (a_1^{\\mathrm{avg}}a_2^{\\mathrm{avg}}a_3^{\\mathrm{avg}})^* \\right) = -2\\kappa\\Delta t \\mathrm{Im}\\left( (a_1^{\\mathrm{avg}}a_2^{\\mathrm{avg}}a_3^{\\mathrm{avg}})^* \\right)\n$$\nThe calculation for $|a_2^{n+1}|^2 - |a_2^n|^2$ and $|a_3^{n+1}|^2 - |a_3^n|^2$ is identical due to symmetry. Thus, the change in magnitude is the same for all three modes at each step, which means their differences, $I_{12}$ and $I_{13}$, are exactly conserved (up to floating-point precision). The Hamiltonian $H$ is a cubic invariant and is not exactly preserved by the midpoint rule. However, as a symmetric scheme, it exhibits excellent long-term conservation, with the error in $H$ remaining small and bounded.\n\n**3. Implementation Algorithm**\n\nThe implicit system is solved at each time step for $a_j^{\\text{avg}}$ using fixed-point iteration.\n1.  Initialize the guess: $a_j^{\\mathrm{avg},(0)} = a_j^n$.\n2.  Iterate for $k=0, 1, 2, \\dots$ until convergence:\n    $$\n    a_j^{\\mathrm{avg},(k+1)} = a_j^n + \\frac{i\\kappa\\Delta t}{2} (a_m^{\\mathrm{avg},(k)})^* (a_n^{\\mathrm{avg},(k)})^*\n    $$\n3.  Once converged, find the next state: $a_j^{n+1} = 2 a_j^{\\text{avg}} - a_j^n$.\n4.  At each step, calculate the invariants and update the maximum drifts. After the final step, compare the drifts with the given tolerances to determine conservation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the triad interaction simulation for all test cases\n    and determine if the invariants are conserved.\n    \"\"\"\n    test_cases = [\n        # Case A (general, long time)\n        {'kappa': 1.0, 'a0': [1 + 0.2j, 0.8 - 0.4j, -0.6 + 0.3j], 'T': 200, 'dt': 0.01,\n         'eps_I': 1e-8, 'eps_H': 5e-3},\n        # Case B (stiff coupling)\n        {'kappa': 10.0, 'a0': [0.1 + 0.0j, 0.2 + 0.0j, 0.3 + 0.0j], 'T': 2.0, 'dt': 1e-3,\n         'eps_I': 1e-8, 'eps_H': 5e-3},\n        # Case C (edge with zero amplitude)\n        {'kappa': 1.0, 'a0': [1.0 + 0.0j, 1.0 + 0.0j, 0.0 + 0.0j], 'T': 50, 'dt': 0.01,\n         'eps_I': 1e-8, 'eps_H': 5e-3},\n    ]\n\n    results = []\n    for case in test_cases:\n        conserved = run_simulation(**case)\n        results.append(conserved)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(kappa, a0, T, dt, eps_I, eps_H):\n    \"\"\"\n    Performs the time-stepping simulation for a single test case.\n\n    Args:\n        kappa (float): Real coupling coefficient.\n        a0 (list of complex): Initial complex amplitudes [a1(0), a2(0), a3(0)].\n        T (float): Total integration time.\n        dt (float): Time step size.\n        eps_I (float): Tolerance for Manley-Rowe invariants.\n        eps_H (float): Tolerance for Hamiltonian energy.\n\n    Returns:\n        bool: True if all invariants are conserved within tolerances, False otherwise.\n    \"\"\"\n    a_current = np.array(a0, dtype=np.complex128)\n    num_steps = int(round(T / dt))\n\n    # Calculate initial invariants\n    I12_0 = abs(a_current[0])**2 - abs(a_current[1])**2\n    I13_0 = abs(a_current[0])**2 - abs(a_current[2])**2\n    S0 = a_current[0] * a_current[1] * a_current[2]\n    H_0 = kappa * (S0 + np.conj(S0)).real\n\n    # Initialize maximum drifts\n    max_D12 = 0.0\n    max_D13 = 0.0\n    max_DH = 0.0\n\n    # Fixed-point iteration parameters\n    FP_ITERATIONS = 10\n\n    # Time-stepping loop\n    for _ in range(num_steps):\n        a_n = a_current\n\n        # --- Solve for a_avg using fixed-point iteration ---\n        # Initial guess for a_avg is a_n\n        a_avg = a_n.copy()\n        \n        # Using a Jacobi-style iteration\n        for _ in range(FP_ITERATIONS):\n            a_avg_old = a_avg.copy()\n            # Update equations for a_avg based on the implicit midpoint rule\n            a_avg[0] = a_n[0] + 0.5j * kappa * dt * np.conj(a_avg_old[1]) * np.conj(a_avg_old[2])\n            a_avg[1] = a_n[1] + 0.5j * kappa * dt * np.conj(a_avg_old[0]) * np.conj(a_avg_old[2])\n            a_avg[2] = a_n[2] + 0.5j * kappa * dt * np.conj(a_avg_old[0]) * np.conj(a_avg_old[1])\n\n        # --- Update to next time step ---\n        # a_n+1 = 2 * a_avg - a_n\n        a_current = 2.0 * a_avg - a_n\n\n        # --- Calculate invariants and update drifts ---\n        I12_n = abs(a_current[0])**2 - abs(a_current[1])**2\n        I13_n = abs(a_current[0])**2 - abs(a_current[2])**2\n        S_n = a_current[0] * a_current[1] * a_current[2]\n        H_n = kappa * (S_n + np.conj(S_n)).real\n\n        max_D12 = max(max_D12, abs(I12_n - I12_0))\n        max_D13 = max(max_D13, abs(I13_n - I13_0))\n        max_DH = max(max_DH, abs(H_n - H_0))\n    \n    # Check if all drifts are within their respective tolerances\n    is_conserved = (max_D12 = eps_I) and (max_D13 = eps_I) and (max_DH = eps_H)\n    return is_conserved\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "This final practice scales up from a single triad to a full, interacting turbulent field, synthesizing the previous concepts to investigate a key question in turbulence theory: the locality of spectral energy transfer. You will implement a complete energy transfer calculation for a synthetic turbulent state and apply a spectral filter to dissect the contributions of \"nonlocal\" triads, which couple widely separated scales. This exercise provides direct, hands-on experience with the kind of diagnostic tools used in modern turbulence research. ",
            "id": "4207766",
            "problem": "Design and implement a program that computes the fraction of nonlinear energy-transfer power mediated by spectrally nonlocal triad interactions, isolated by a wavenumber-space filter defined by the inequality $|\\mathbf{p}|/|\\mathbf{k}|\\epsilon$. Work in a periodic square domain and use a discrete, isotropic, synthetic spectrum to probe the role of nonlocality in triad interactions typical of electric cross magnetic field (E×B) advection in fusion plasma turbulence simulation.\n\nStart from the following fundamental base. For any quadratic nonlinearity expressible as a Poisson bracket in physical space, the Fourier transform yields a convolution that couples triads $(\\mathbf{k},\\mathbf{p},\\mathbf{q})$ satisfying the resonance condition $\\mathbf{k}=\\mathbf{p}+\\mathbf{q}$. A canonical, widely tested coupling for advective Poisson brackets in $2$-dimensional incompressible systems is the scalar coefficient\n$$\nC(\\mathbf{k},\\mathbf{p},\\mathbf{q}) = i\\,(k_x p_y - k_y p_x),\n$$\nwhere $i$ is the imaginary unit and $(k_x,k_y)$ denotes the Cartesian components of $\\mathbf{k}$. Given a complex field amplitude $\\hat{a}(\\mathbf{k})$, the triad-resolved modal energy-transfer contribution to mode $\\mathbf{k}$ from the interacting pair $(\\mathbf{p},\\mathbf{q})$ is\n$$\nT(\\mathbf{k};\\mathbf{p},\\mathbf{q}) = \\Re\\!\\left[\\hat{a}^*(\\mathbf{k})\\,C(\\mathbf{k},\\mathbf{p},\\mathbf{q})\\,\\hat{a}(\\mathbf{p})\\,\\hat{a}(\\mathbf{q})\\right],\n$$\nwith $\\mathbf{q}=\\mathbf{k}-\\mathbf{p}$, where $\\Re[\\cdot]$ denotes the real part and ${}^*$ denotes complex conjugation.\n\nYou must construct a discrete, isotropic spectrum on a square integer wavenumber grid defined by all integer pairs $\\mathbf{k}=(k_x,k_y)$ with $-K_{\\max}\\le k_x\\le K_{\\max}$ and $-K_{\\max}\\le k_y\\le K_{\\max}$, excluding $\\mathbf{k}=\\mathbf{0}$. The synthetic amplitudes are specified as\n$$\n\\hat{a}(\\mathbf{k}) = A_0 \\exp\\!\\left(-\\frac{|\\mathbf{k}|^2}{2 k_0^2}\\right)\\,e^{i\\theta_{\\mathbf{k}}},\n$$\nwhere $|\\mathbf{k}|=\\sqrt{k_x^2+k_y^2}$, with phases $\\theta_{\\mathbf{k}}$ sampled independently and uniformly from $[0,2\\pi)$ in radians using a fixed pseudorandom seed for reproducibility.\n\nDefine the triad-level nonlocal filter $\\mathcal{F}_\\epsilon(\\mathbf{k},\\mathbf{p},\\mathbf{q})$ that accepts a triad if and only if $|\\mathbf{k}|0$, $|\\mathbf{p}|0$, $|\\mathbf{q}|0$, $\\mathbf{k}=\\mathbf{p}+\\mathbf{q}$, and $|\\mathbf{p}|/|\\mathbf{k}|\\epsilon$. Using this filter, define the nonlocal transfer fraction as\n$$\nW(\\epsilon)=\\frac{\\sum_{\\mathbf{k}}\\;\\sum_{\\mathbf{p}}\\; \\left|T(\\mathbf{k};\\mathbf{p},\\mathbf{k}-\\mathbf{p})\\right|\\;\\mathbb{I}\\!\\left[\\mathcal{F}_\\epsilon(\\mathbf{k},\\mathbf{p},\\mathbf{k}-\\mathbf{p})\\right]}{\\sum_{\\mathbf{k}}\\;\\sum_{\\mathbf{p}}\\; \\left|T(\\mathbf{k};\\mathbf{p},\\mathbf{k}-\\mathbf{p})\\right|},\n$$\nwhere $\\mathbb{I}[\\cdot]$ is the indicator function and the sums are restricted to integer wavevectors lying within the grid and excluding any term with $\\mathbf{k}$, $\\mathbf{p}$, or $\\mathbf{q}$ equal to $\\mathbf{0}$. The absolute value ensures that the measure reflects interaction strength without cancellations due to sign.\n\nImplement an algorithm that:\n- Enumerates all grid wavevectors $\\mathbf{k}$ and $\\mathbf{p}$, forms $\\mathbf{q}=\\mathbf{k}-\\mathbf{p}$, and includes the triad only if $\\mathbf{q}$ lies in the grid and none of $\\mathbf{k}$, $\\mathbf{p}$, $\\mathbf{q}$ is $\\mathbf{0}$.\n- Computes $T(\\mathbf{k};\\mathbf{p},\\mathbf{q})$ and accumulates its absolute value to the denominator.\n- For each specified $\\epsilon$, applies the filter $|\\mathbf{p}|/|\\mathbf{k}|\\epsilon$ and accumulates to the corresponding numerator.\n- Returns $W(\\epsilon)$ for each $\\epsilon$.\n\nUse the following fixed parameters as the test suite:\n- Grid size: $K_{\\max}=6$.\n- Spectrum parameters: $A_0=1$, $k_0=3$.\n- Random phase seed: $R=7$.\n- Epsilon values: $\\epsilon\\in\\{0.0,\\,0.2,\\,0.5,\\,1.0,\\,2.0,\\,10.0\\}$.\n\nYour program must output a single line containing the results for all test $\\epsilon$ values in the order listed above, as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4,x_5,x_6]$. All outputs must be real numbers without units. No user input is required. The algorithm must be numerically stable and must complete using the specified parameters.\n\nScientific realism requirements:\n- The coupling $C(\\mathbf{k},\\mathbf{p},\\mathbf{q})$ and the construction of $T(\\mathbf{k};\\mathbf{p},\\mathbf{q})$ must be implemented exactly as defined above.\n- The random phases must be generated uniformly on $[0,2\\pi)$ in radians using the fixed seed $R$ so that results are reproducible across runs and languages that follow the same specification.\n- Treat any division by zero in $|\\mathbf{p}|/|\\mathbf{k}|$ by excluding those cases via the explicit nonzero conditions already stated; no additional regularization is permitted.",
            "solution": "The problem requires the design and implementation of an algorithm to compute the fraction of nonlinear energy transfer power, $W(\\epsilon)$, that is mediated by spectrally nonlocal triad interactions in a two-dimensional system. The measure of nonlocality is defined by the filter $|\\mathbf{p}|/|\\mathbf{k}|  \\epsilon$ for a given triad $(\\mathbf{k}, \\mathbf{p}, \\mathbf{q})$. The context is fusion plasma turbulence, modeled here using a canonical E$\\times$B-type advective nonlinearity on a discrete Fourier grid.\n\nThe solution is constructed algorithmically, following a sequence of steps grounded in the fundamental principles of Fourier-spectral analysis of nonlinear partial differential equations.\n\nFirst, we establish the discrete computational domain. The system is defined on a periodic square, whose dynamics are analyzed in Fourier space. The wavevectors $\\mathbf{k}$ are discrete, forming a grid of integer pairs $\\mathbf{k}=(k_x, k_y)$ where the components are bounded by a maximum wavenumber, $-K_{\\max} \\le k_x, k_y \\le K_{\\max}$. The origin, $\\mathbf{k}=(0,0)$, represents the spatial mean and is excluded from direct consideration in the nonlinear dynamics, as specified by the problem.\n\nSecond, we generate a synthetic complex scalar field, $\\hat{a}(\\mathbf{k})$, on this grid. The amplitude of this field is prescribed by a physically motivated isotropic spectrum, specifically a Gaussian function:\n$$\n|\\hat{a}(\\mathbf{k})| = A_0 \\exp\\left(-\\frac{|\\mathbf{k}|^2}{2 k_0^2}\\right)\n$$\nwhere $|\\mathbf{k}| = \\sqrt{k_x^2 + k_y^2}$ is the magnitude of the wavevector, $A_0$ is a normalization constant, and $k_0$ is the characteristic wavenumber defining the peak of the energy spectrum. The phases $\\theta_{\\mathbf{k}}$ of the complex amplitudes, $\\hat{a}(\\mathbf{k}) = |\\hat{a}(\\mathbf{k})| e^{i\\theta_{\\mathbf{k}}}$, are crucial for defining a specific realization of the turbulent field. They are chosen as independent random variables sampled from a uniform distribution over $[0, 2\\pi)$. To ensure reproducibility, a fixed pseudorandom number generator seed, $R$, is used. The parameters for this problem are specified as $K_{\\max}=6$, $A_0=1$, $k_0=3$, and $R=7$.\n\nThird, we model the nonlinear dynamics. The core of the problem lies in the triad interactions, which arise from the convolution sum that results from the Fourier transform of a quadratic nonlinearity. The fundamental resonance condition for these interactions is $\\mathbf{k} = \\mathbf{p} + \\mathbf{q}$, where $(\\mathbf{k}, \\mathbf{p}, \\mathbf{q})$ form a resonant triad. The strength and nature of the interaction are governed by a coupling coefficient. For the specified 2D incompressible advective nonlinearity, this coefficient is given by:\n$$\nC(\\mathbf{k},\\mathbf{p},\\mathbf{q}) = i\\,(k_x p_y - k_y p_x) = i\\,(\\mathbf{k} \\times \\mathbf{p})_z\n$$\nThis represents the $z$-component of the cross product of the vectors $\\mathbf{k}$ and $\\mathbf{p}$ in the 2D plane.\n\nFourth, we quantify the energy transfer. The rate of energy transfer into mode $\\mathbf{k}$ due to its interaction with the pair of modes $(\\mathbf{p}, \\mathbf{q})$ is given by $T(\\mathbf{k};\\mathbf{p},\\mathbf{q})$. Substituting the relation $\\mathbf{q} = \\mathbf{k} - \\mathbf{p}$, the transfer due to the $(\\mathbf{k}, \\mathbf{p})$ interaction is:\n$$\nT(\\mathbf{k};\\mathbf{p},\\mathbf{k}-\\mathbf{p}) = \\Re\\!\\left[\\hat{a}^*(\\mathbf{k})\\,C(\\mathbf{k},\\mathbf{p},\\mathbf{k}-\\mathbf{p})\\,\\hat{a}(\\mathbf{p})\\,\\hat{a}(\\mathbf{k}-\\mathbf{p})\\right]\n$$\nwhere $\\Re[\\cdot]$ denotes the real part and ${}^*$ denotes complex conjugation. The quantity of interest is the magnitude of the interaction strength, $|T(\\mathbf{k};\\mathbf{p},\\mathbf{k}-\\mathbf{p})|$, as we seek to measure the total power exchanged without considering its direction (i.e., forward or inverse cascade).\n\nThe algorithm proceeds by summing over all valid triads. A triad $(\\mathbf{k}, \\mathbf{p}, \\mathbf{q} = \\mathbf{k}-\\mathbf{p})$ is considered valid if all three wavevectors are non-zero ($\\mathbf{k} \\neq \\mathbf{0}, \\mathbf{p} \\neq \\mathbf{0}, \\mathbf{q} \\neq \\mathbf{0}$) and lie within the computational grid defined by $K_{\\max}$.\n\nThe total nonlinear interaction power is the denominator of $W(\\epsilon)$, calculated by summing the absolute transfer $|T|$ over all valid triads:\n$$\n\\text{Total Power} = \\sum_{\\mathbf{k}}\\;\\sum_{\\mathbf{p}}\\; \\left|T(\\mathbf{k};\\mathbf{p},\\mathbf{k}-\\mathbf{p})\\right|\n$$\nThe numerator measures the power contributed specifically by nonlocal interactions. This is achieved by applying the filter $\\mathcal{F}_\\epsilon(\\mathbf{k},\\mathbf{p},\\mathbf{q})$, which is true if $|\\mathbf{p}|/|\\mathbf{k}|  \\epsilon$ (in addition to the triad validity conditions). This filter isolates interactions where one of the source modes, $\\mathbf{p}$, has a wavenumber significantly smaller than the destination mode, $\\mathbf{k}$. The nonlocal power is therefore:\n$$\n\\text{Nonlocal Power}(\\epsilon) = \\sum_{\\mathbf{k}}\\;\\sum_{\\mathbf{p}}\\; \\left|T(\\mathbf{k};\\mathbf{p},\\mathbf{k}-\\mathbf{p})\\right|\\;\\mathbb{I}\\!\\left[|\\mathbf{p}|/|\\mathbf{k}|  \\epsilon\\right]\n$$\nwhere $\\mathbb{I}[\\cdot]$ is the indicator function, which is $1$ if its argument is true and $0$ otherwise.\n\nThe final quantity, the nonlocal transfer fraction $W(\\epsilon)$, is the ratio of these two sums:\n$$\nW(\\epsilon) = \\frac{\\text{Nonlocal Power}(\\epsilon)}{\\text{Total Power}}\n$$\nThis calculation is repeated for each value of $\\epsilon$ in the specified set $\\{0.0, 0.2, 0.5, 1.0, 2.0, 10.0\\}$. The algorithm involves nested loops over all valid $\\mathbf{k}$ and $\\mathbf{p}$ vectors, calculation of $\\mathbf{q}$, checking triad validity, computing $|T|$, and accumulating the results for the denominator and the various numerators corresponding to each $\\epsilon$. For $\\epsilon=0.0$, the condition $|\\mathbf{p}|/|\\mathbf{k}|  0.0$ is never met, so $W(0.0)$ must be $0$. For large $\\epsilon$ (e.g., $\\epsilon=10.0$ in this problem), the condition $|\\mathbf{p}|/|\\mathbf{k}|\\epsilon$ becomes less restrictive and should cover all possible interactions, so $W(10.0)$ should be $1.0$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the fraction of nonlinear energy-transfer power mediated by\n    spectrally nonlocal triad interactions in a 2D system.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    Kmax = 6\n    A0 = 1.0\n    k0 = 3.0\n    R_seed = 7\n    epsilons = [0.0, 0.2, 0.5, 1.0, 2.0, 10.0]\n\n    # --- Step 1: Grid setup ---\n    # Create the range of integer wavenumbers\n    k_range = np.arange(-Kmax, Kmax + 1)\n    \n    # Create a list of all non-zero wavevectors (k_x, k_y) on the grid\n    all_k_vectors = [(int(kx), int(ky)) for kx in k_range for ky in k_range]\n    k_vectors = [k for k in all_k_vectors if k != (0, 0)]\n\n    # --- Step 2: Spectrum Generation ---\n    # Use a dictionary to store complex amplitudes, mapping (kx, ky) to a_hat\n    a_hat = {}\n    rng = np.random.default_rng(R_seed)\n    \n    for kx, ky in k_vectors:\n        # Calculate magnitude of the wavevector\n        k_mag = np.sqrt(kx**2 + ky**2)\n        \n        # Calculate the magnitude of the spectral amplitude\n        amp_mag = A0 * np.exp(-k_mag**2 / (2 * k0**2))\n        \n        # Generate a random phase uniformly distributed in [0, 2*pi)\n        phase = rng.uniform(0, 2 * np.pi)\n        \n        # Store the complex amplitude\n        a_hat[(kx, ky)] = amp_mag * np.exp(1j * phase)\n    \n    # Pre-calculate magnitudes for efficiency\n    k_mags = {k: np.sqrt(k[0]**2 + k[1]**2) for k in k_vectors}\n\n    # --- Step 3: Triad Interaction Calculation ---\n    total_transfer_sum = 0.0\n    # Initialize an array for numerators, one for each epsilon\n    nonlocal_transfer_sums = np.zeros(len(epsilons))\n\n    # Iterate over all k vectors\n    for k_vec in k_vectors:\n        kx, ky = k_vec\n        k_mag = k_mags[k_vec]\n        a_k_conj = np.conj(a_hat[k_vec])\n\n        # Iterate over all p vectors\n        for p_vec in k_vectors:\n            px, py = p_vec\n            \n            # Form the third wavevector of the triad, q = k - p\n            q_vec = (kx - px, ky - py)\n            qx, qy = q_vec\n\n            # --- Check triad validity as per problem statement ---\n            # 1. q must be non-zero\n            if qx == 0 and qy == 0:\n                continue\n            \n            # 2. q must lie within the grid boundaries\n            if not (-Kmax = qx = Kmax and -Kmax = qy = Kmax):\n                continue\n            \n            # The triad (k, p, q) is valid. Proceed to compute transfer.\n            a_p = a_hat[p_vec]\n            a_q = a_hat[q_vec]\n            \n            # Interaction coefficient C(k, p, q) = i*(kx*py - ky*px)\n            C = 1j * (kx * py - ky * px)\n            \n            # Energy transfer T(k; p, q)\n            T_k_p_q = (a_k_conj * C * a_p * a_q).real\n            abs_T = np.abs(T_k_p_q)\n            \n            # Accumulate to the total sum (denominator)\n            total_transfer_sum += abs_T\n            \n            # Apply the nonlocality filter |p|/|k|  epsilon\n            p_mag = k_mags[p_vec]\n            ratio = p_mag / k_mag # k_mag is guaranteed to be non-zero\n            \n            for i, eps in enumerate(epsilons):\n                if ratio  eps:\n                    nonlocal_transfer_sums[i] += abs_T\n\n    # --- Step 4: Final Calculation and Output Formatting ---\n    # Calculate W(epsilon) for each epsilon value\n    if total_transfer_sum == 0:\n        # This case is unlikely but handled for safety\n        results = [0.0] * len(epsilons)\n    else:\n        results = nonlocal_transfer_sums / total_transfer_sum\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}