{
    "hands_on_practices": [
        {
            "introduction": "全局模拟通常需要运行很长时间以捕捉缓慢的输运过程，这使得数值积分算法的选择至关重要，因为不恰当的算法可能引入随时间累积的虚假数值误差，从而扭曲物理结果。本练习对比了一种标准的非辛算法（RK4）和一种保持系统几何结构的辛算法（Strang分裂法），直观地揭示了不同算法在长期演化中对守恒量的保持能力。此实践强调了为保证全局模拟的物理保真度而选择正确数值方法的重要性。",
            "id": "4203621",
            "problem": "考虑一个适用于聚变等离子体湍流模拟中积分器基准测试的、全局均匀的磁平衡中的导心（GC）运动。假设存在一个大小为 $B_0$ 的均匀磁场 $\\mathbf{B} = B_0 \\hat{\\mathbf{z}}$ 和一个径向约束的静电势 $\\Phi(x,y) = \\frac{1}{2}\\kappa\\left(x^2 + y^2\\right)$，其中 $\\kappa$ 是一个常数。在 $\\mathbf{E}\\times\\mathbf{B}$ 漂移下的导心动力学是哈密顿系统，其正则坐标为 $(x,y)$，哈密顿量为 $H(x,y) = -\\Phi(x,y)/B_0$，由此得到以下系统\n$$\n\\dot{x} = \\frac{\\partial H}{\\partial y}, \\quad \\dot{y} = -\\frac{\\partial H}{\\partial x}.\n$$\n利用以上关系，运动方程简化为刚性旋转，\n$$\n\\dot{x} = -\\omega y, \\quad \\dot{y} = \\omega x, \\quad \\text{with} \\quad \\omega = \\frac{\\kappa}{B_0}.\n$$\n一个闭合轨道的渡越时间为 $T = \\frac{2\\pi}{\\omega}$。哈密顿量 $H$ 是连续动力学的一个不变量，其值为 $H = -\\frac{\\omega}{2}\\left(x^2+y^2\\right)$。\n\n您的任务是在一个全局模拟域（无子域分解）上实现两个时间积分器，将 $(x,y)$ 推进多个渡越时间：\n- 一个辛二阶 Strang 分裂（也称为蛙跳分裂），基于将 $H$ 分裂为 $H_x(x) = -\\frac{\\omega}{2}x^2$ 和 $H_y(y) = -\\frac{\\omega}{2}y^2$。\n- 一个直接应用于上述系统的非辛显式四阶 Runge–Kutta (RK4) 方法。\n\n对于每个积分器，使用相对哈密顿量误差与渡越次数的最小二乘拟合得到的斜率，来量化离散动力学的长期误差增长。将时间 $t$ 的相对哈密顿量误差定义为\n$$\n\\delta(t) = \\frac{H(t) - H(0)}{H(0)}.\n$$\n对于一个产生样本 $\\{\\left(n_i,\\delta_i\\right)\\}_{i=1}^N$ 的模拟，其中 $n_i = t_i/T$ 是渡越次数（无量纲），通过在 $s$ 和 $c$ 上最小化 $\\sum_{i=1}^N\\left(\\delta_i - (s n_i + c)\\right)^2$ 来估计误差增长率 $s$（无量纲，单位为每次渡越），并报告最佳拟合斜率 $s$。\n\n物理单位：\n- 使用以 $\\mathrm{T}$（特斯拉）表示的 $B_0$，以 $\\mathrm{V/m^2}$ 表示的 $\\kappa$，以 $\\mathrm{m}$（米）表示的位置 $x,y$，以及以 $\\mathrm{s}$（秒）表示的时间 $t$。\n- 报告的误差增长斜率 $s$ 必须是无量纲的浮点数，单位为每次渡越。\n\n测试套件：\n使用以下科学上一致的参数集，其中全局域为平面，初始条件严格位于标称半径 $1\\,\\mathrm{m}$ 以内：\n1. $B_0 = 3.0\\,\\mathrm{T}$，$\\kappa = 1.5\\,\\mathrm{V/m^2}$，$(x_0,y_0) = (0.1\\,\\mathrm{m}, 0.0\\,\\mathrm{m})$，渡越次数 $M = 1000$，时间步长 $\\Delta t = T/100$。\n2. $B_0 = 3.0\\,\\mathrm{T}$，$\\kappa = 1.5\\,\\mathrm{V/m^2}$，$(x_0,y_0) = (0.1\\,\\mathrm{m}, 0.1\\,\\mathrm{m})$，渡越次数 $M = 1000$，时间步长 $\\Delta t = T/20$。\n3. $B_0 = 3.0\\,\\mathrm{T}$，$\\kappa = 1.5\\,\\mathrm{V/m^2}$，$(x_0,y_0) = (0.25\\,\\mathrm{m}, -0.05\\,\\mathrm{m})$，渡越次数 $M = 200$，时间步长 $\\Delta t = T/5$。\n\n对于每个测试用例，计算并返回一个包含两个浮点数 $[s_{\\mathrm{symp}}, s_{\\mathrm{rk4}}]$ 的列表，其中 $s_{\\mathrm{symp}}$ 是辛积分器的斜率，$s_{\\mathrm{rk4}}$ 是非辛积分器的斜率，两者均为无量纲，单位为每次渡越。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个子列表对应一个测试用例，顺序如上所示，例如 $\\left[\\left[s_{\\mathrm{symp},1},s_{\\mathrm{rk4},1}\\right],\\left[s_{\\mathrm{symp},2},s_{\\mathrm{rk4},2}\\right],\\left[s_{\\mathrm{symp},3},s_{\\mathrm{rk4},3}\\right]\\right]$。这些值必须是无量纲（每次渡越）的浮点数。",
            "solution": "问题陈述已经过验证，被认为是合理的。它具有科学依据，提法明确，并且提供了所有必要的参数。我们可以开始求解。\n\n该问题要求比较两种数值积分器，用于模拟简化静电势中的导心 $\\mathbf{E}\\times\\mathbf{B}$ 漂移运动。该动力学由一个哈密顿系统描述，这为分析数值格式的长期守恒性质提供了坚实的基础。\n\n运动方程由下式给出：\n$$\n\\dot{x} = -\\omega y\n$$\n$$\n\\dot{y} = \\omega x\n$$\n其中 $\\omega = \\kappa / B_0$。该系统描述了绕原点以角频率 $\\omega$ 进行的匀速圆周运动。轨迹为 $(x(t), y(t)) = (R\\cos(\\phi_0 - \\omega t), R\\sin(\\phi_0 - \\omega t))$ 或 $(x(t), y(t)) = (x_0 \\cos(\\omega t) + y_0 \\sin(\\omega t), y_0 \\cos(\\omega t) - x_0 \\sin(\\omega t))$，具体取决于符号约定。给定 $\\dot{x}=-\\omega y$ 和 $\\dot{y}=\\omega x$，解的形式为 $x(t) = A\\cos(\\omega t) - B\\sin(\\omega t)$ 和 $y(t) = B\\cos(\\omega t) + A\\sin(\\omega t)$。对于初始条件 $(x_0, y_0)$，我们有 $A=x_0, B=y_0$。因此，$x(t) = x_0 \\cos(\\omega t) - y_0 \\sin(\\omega t)$ 且 $y(t) = y_0 \\cos(\\omega t) + x_0 \\sin(\\omega t)$。该运动的周期，即渡越时间，为 $T = 2\\pi/|\\omega|$。问题定义了 $\\omega = \\kappa/B_0$，我们将使用该定义。\n\n该系统是哈密顿系统，其守恒量（哈密顿量）由下式给出：\n$$\nH(x,y) = -\\frac{\\Phi(x,y)}{B_0} = -\\frac{\\kappa}{2B_0}(x^2+y^2) = -\\frac{\\omega}{2}(x^2+y^2)\n$$\n此哈密顿量与半径平方 $r^2 = x^2+y^2$ 的负值成正比。精确的时间演化会保持 $H$ 不变，意味着粒子保持在恒定的半径上。我们将通过积分器保持此不变量的能力来评估它们。\n\n### 1. 辛 Strang 分裂积分器\n\n此方法基于将哈密顿量分裂为两个可积部分，$H(x,y) = H_x(x) + H_y(y)$，其中：\n$$\nH_x(x) = -\\frac{\\omega}{2}x^2 \\quad \\text{and} \\quad H_y(y) = -\\frac{\\omega}{2}y^2\n$$\n由 $H_x$ 生成的动力学由系统 $\\dot{x}=0$，$\\dot{y} = -\\frac{\\partial H_x}{\\partial x} = \\omega x$ 给出。在时间步长 $\\tau$ 内的精确解是映射 $\\phi_x^\\tau$：\n$$\nx(\\tau) = x(0)\n$$\n$$\ny(\\tau) = y(0) + \\omega x(0) \\tau\n$$\n由 $H_y$ 生成的动力学由 $\\dot{x} = \\frac{\\partial H_y}{\\partial y} = -\\omega y$，$\\dot{y}=0$ 给出。在时间步长 $\\tau$ 内的精确解是映射 $\\phi_y^\\tau$：\n$$\nx(\\tau) = x(0) - \\omega y(0) \\tau\n$$\n$$\ny(\\tau) = y(0)\n$$\n二阶 Strang 分裂格式通过组合这些精确流将系统从时间 $t_n$ 推进到 $t_{n+1}=t_n+\\Delta t$：$\\mathbf{z}_{n+1} = \\phi_x^{\\Delta t/2} \\circ \\phi_y^{\\Delta t} \\circ \\phi_x^{\\Delta t/2}(\\mathbf{z}_n)$，其中 $\\mathbf{z}=(x,y)$。\n\n一个时间步 $(x_n, y_n) \\to (x_{n+1}, y_{n+1})$ 的算法如下：\n1. 使用 $H_x$ 进行半步推进：$(x^*, y^*) = \\phi_x^{\\Delta t/2}(x_n, y_n)$\n    - $x^* = x_n$\n    - $y^* = y_n + \\omega x_n \\frac{\\Delta t}{2}$\n2. 使用 $H_y$ 进行整步推进：$(x^{**}, y^{**}) = \\phi_y^{\\Delta t}(x^*, y^*)$\n    - $x^{**} = x^* - \\omega y^* \\Delta t = x_n - \\omega(y_n + \\omega x_n \\frac{\\Delta t}{2})\\Delta t = x_n - \\omega y_n \\Delta t - \\frac{(\\omega\\Delta t)^2}{2}x_n$\n    - $y^{**} = y^*$\n3. 使用 $H_x$ 进行第二个半步推进：$(x_{n+1}, y_{n+1}) = \\phi_x^{\\Delta t/2}(x^{**}, y^{**})$\n    - $x_{n+1} = x^{**}$\n    - $y_{n+1} = y^{**} + \\omega x^{**} \\frac{\\Delta t}{2} = (y_n + \\omega x_n \\frac{\\Delta t}{2}) + \\omega(x_n - \\omega y_n \\Delta t - \\frac{(\\omega\\Delta t)^2}{2}x_n)\\frac{\\Delta t}{2}$\n\n辛积分器旨在保持辛二形式，这对于哈密顿系统而言，能导致一个接近真实哈密顿量的“影子哈密顿量”具有出色的长期守恒性。因此，真实哈密顿量的误差 $\\delta(t)$ 预期是有界且振荡的，从而通过最小二乘拟合得到的斜率 $s_{\\mathrm{symp}}$ 将接近于零。\n\n### 2. 四阶 Runge-Kutta (RK4) 积分器\n\nRK4 方法是一种通用的、显式的、单步求解器，用于求解形式为 $\\dot{\\mathbf{z}} = \\mathbf{f}(t, \\mathbf{z})$ 的常微分方程。对于我们的系统，$\\mathbf{z}=(x,y)$ 且 $\\mathbf{f}(\\mathbf{z}) = (-\\omega y, \\omega x)$。RK4 的一步计算如下：\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其各个阶段为：\n$$\n\\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{z}_n) = \\Delta t (-\\omega y_n, \\omega x_n)\n$$\n$$\n\\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{z}_n + \\mathbf{k}_1/2)\n$$\n$$\n\\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{z}_n + \\mathbf{k}_2/2)\n$$\n$$\n\\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{z}_n + \\mathbf{k}_3)\n$$\nRK4 是一种高阶方法，以其在短时间间隔内的准确性而闻名。然而，它不是辛的。当应用于哈密顿系统时，它通常不守恒哈密顿量，导致能量出现长期漂移。对于一个振荡系统，通常 $||\\mathbf{z}||$（以及 $H$）会发生漂移。在这种情况下，轨道的半径会随时间缓慢变化。这将表现为相对哈密顿量误差长期演化中的一个非零斜率 $s_{\\mathrm{rk4}}$。RK4 的误差增长率预计将显著大于辛积分器，并强烈依赖于时间步长 $\\Delta t$。\n\n### 3. 误差分析\n\n对于每个积分器和测试用例，我们模拟总共 $M$ 个渡越时间的动力学。总时间为 $t_{final} = M \\cdot T$，步数为 $N_{steps} = t_{final}/\\Delta t$。我们在每个时间步 $t_i = i\\Delta t$ 收集渡越次数 $n_i = t_i/T$ 和相对哈密顿量误差 $\\delta_i = (H_i - H_0)/H_0$ 的样本。然后，我们对收集到的数据 $\\{\\left(n_i,\\delta_i\\right)\\}$ 进行线性回归，以找到使残差平方和最小化的斜率 $s$。我们将使用 `scipy.stats.linregress` 进行此计算。\n\n实现过程将首先为每个积分器步骤定义函数，然后定义一个计算误差历史的主模拟循环，以及一个执行最小二乘拟合的例程。对测试套件中的每个参数集重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Solves the guiding center motion problem by comparing symplectic and RK4\n    integrators and calculating the long-term Hamiltonian error growth rate.\n    \"\"\"\n    \n    # Test cases from the problem statement.\n    # (B0, kappa, (x0, y0), M_transits, dt_factor)\n    # where dt = T / dt_factor\n    test_cases = [\n        (3.0, 1.5, (0.1, 0.0), 1000, 100),\n        (3.0, 1.5, (0.1, 0.1), 1000, 20),\n        (3.0, 1.5, (0.25, -0.05), 200, 5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        B0, kappa, (x0, y0), M_transits, dt_factor = case\n        \n        # Calculate derived physical parameters\n        omega = kappa / B0\n        T_period = 2.0 * np.pi / omega\n        dt = T_period / dt_factor\n        \n        # Total simulation time and number of steps\n        t_final = M_transits * T_period\n        num_steps = int(round(t_final / dt))\n\n        # Run for Symplectic Strang Splitting\n        s_symp = _run_simulation(\n            integrator='strang',\n            x0=x0, y0=y0, omega=omega,\n            num_steps=num_steps, dt=dt, T_period=T_period\n        )\n\n        # Run for RK4\n        s_rk4 = _run_simulation(\n            integrator='rk4',\n            x0=x0, y0=y0, omega=omega,\n            num_steps=num_steps, dt=dt, T_period=T_period\n        )\n        \n        results.append([s_symp, s_rk4])\n\n    # Final print statement in the exact required format.\n    # The str() on a list automatically produces the required bracketed format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _strang_step(x, y, omega, dt):\n    \"\"\"Performs one step of the Strang splitting integrator.\"\"\"\n    # First half step with H_x\n    y_half = y + omega * x * (dt / 2.0)\n    x_half = x\n    \n    # Full step with H_y\n    x_full = x_half - omega * y_half * dt\n    y_full = y_half\n    \n    # Second half step with H_x\n    y_next = y_full + omega * x_full * (dt / 2.0)\n    x_next = x_full\n    \n    return x_next, y_next\n\ndef _rk4_step(x, y, omega, dt):\n    \"\"\"Performs one step of the RK4 integrator.\"\"\"\n    def f(x_pos, y_pos):\n        return -omega * y_pos, omega * x_pos\n\n    # k1\n    k1x, k1y = f(x, y)\n    \n    # k2\n    k2x, k2y = f(x + dt * k1x / 2.0, y + dt * k1y / 2.0)\n\n    # k3\n    k3x, k3y = f(x + dt * k2x / 2.0, y + dt * k2y / 2.0)\n\n    # k4\n    k4x, k4y = f(x + dt * k3x, y + dt * k3y)\n    \n    # Combine\n    x_next = x + (dt / 6.0) * (k1x + 2*k2x + 2*k3x + k4x)\n    y_next = y + (dt / 6.0) * (k1y + 2*k2y + 2*k3y + k4y)\n    \n    return x_next, y_next\n\ndef _run_simulation(integrator, x0, y0, omega, num_steps, dt, T_period):\n    \"\"\"\n    Runs a full simulation for a given integrator and returns the error slope.\n    \"\"\"\n    x, y = float(x0), float(y0)\n    \n    def hamiltonian(x_pos, y_pos):\n        return -0.5 * omega * (x_pos**2 + y_pos**2)\n\n    H0 = hamiltonian(x, y)\n    \n    # Avoid division by zero if initial state is at the origin\n    if H0 == 0.0:\n        # The problem constraints ensure x0, y0 are not both zero,\n        # but this is a safeguard.\n        return 0.0\n\n    transit_counts = np.zeros(num_steps + 1)\n    rel_errors = np.zeros(num_steps + 1)\n    \n    transit_counts[0] = 0.0\n    rel_errors[0] = 0.0\n\n    if integrator == 'strang':\n        step_func = _strang_step\n    elif integrator == 'rk4':\n        step_func = _rk4_step\n    else:\n        raise ValueError(\"Unknown integrator\")\n\n    for i in range(1, num_steps + 1):\n        x, y = step_func(x, y, omega, dt)\n        \n        current_time = i * dt\n        H_current = hamiltonian(x, y)\n        \n        transit_counts[i] = current_time / T_period\n        rel_errors[i] = (H_current - H0) / H0\n    \n    # Perform linear regression to find the slope\n    # slope, intercept, r_value, p_value, std_err\n    result = stats.linregress(transit_counts, rel_errors)\n    \n    return result.slope\n\nsolve()\n```"
        },
        {
            "introduction": "等离子体中的湍流输运常常以间歇性的“雪崩”形式发生，这些是能量或粒子在径向上的快速爆发性输运事件。在真实的聚变装置中，等离子体的有限尺寸构成了这些雪崩传播的物理边界，从而限制了它们的规模。本练习通过一个统计模型，探索有限的模拟区域和不同的边界条件如何影响输运雪崩的尺寸分布，这是一个局域模型无法捕捉到的关键物理现象。",
            "id": "4203665",
            "problem": "考虑一个一维全局模拟域，代表环形聚变装置的径向坐标，记为 $x \\in [0,L]$，其中 $L$ 是装置尺寸。设扰动能量密度 $e(x,t)$ 遵循一个局域守恒律（连续性方程）\n$$\\partial_t e(x,t) + \\partial_x \\Gamma(x,t) = S(x,t) - \\Lambda(x,t),$$\n其中 $\\Gamma$ 是径向能量通量，$S$ 是源项，$\\Lambda$ 是汇项。雪崩事件被定义为一个局域的、向外传播的通量偏移，其形式为\n$$\\phi(x,t) = a(t) f(x - x(t)),$$\n其中 $x(t) = x_0 + v t$ 是雪崩前沿位置，$x_0 \\in [0,L]$ 是出发点，$v > 0$ 是向外传播速度，$a(t)$ 是振幅，$f(\\cdot)$ 是一个固定的形状函数，其归一化使得 $\\int_{-\\infty}^{\\infty} f(\\xi)\\, d\\xi = 1$。假设由于碰撞和退相干过程，振幅存在线性阻尼，\n$$\\frac{d a(t)}{dt} = -\\gamma a(t), \\quad a(0) = a_0,$$\n其中 $\\gamma \\ge 0$ 是阻尼率，$a_0 > 0$ 是初始振幅。定义终止阈值为 $a(T) = \\varepsilon a_0$，$0  \\varepsilon  1$，这意味着一个由阻尼限制的持续时间\n$$T_d = \\frac{1}{\\gamma}\\ln\\left(\\frac{1}{\\varepsilon}\\right) \\quad \\text{for } \\gamma > 0,$$\n且当 $\\gamma = 0$ 时 $T_d = +\\infty$。考虑在 $x=L$ 处的两种物理上不同的边界条件：\n- 吸收边界：当雪崩前沿到达 $x=L$ 时，雪崩终止，因此由边界限制的持续时间为 $T_b = \\frac{L - x_0}{v}$，实际持续时间为 $T = \\min(T_b, T_d)$。\n- 反射边界：雪崩不被边界终止，因此持续时间纯粹由阻尼限制，$T = T_d$。\n\n定义雪崩尺寸为通量偏移的时空积分，\n$$S = \\int_0^{T} \\int_0^{L} \\phi(x,t) \\, dx \\, dt.$$\n使用 $f(\\cdot)$ 的归一化和 $a(t)$ 的阻尼定律，可得\n$$S = \\int_0^T a(t)\\, dt = \\begin{cases}\n\\frac{a_0}{\\gamma}\\left(1 - e^{-\\gamma T}\\right),  \\gamma > 0,\\\\\na_0 T,  \\gamma = 0.\n\\end{cases}$$\n假设出发点 $x_0$ 在 $[0,L]$ 上均匀分布。记 $D = L - x_0$，则 $D \\sim \\mathrm{Uniform}(0,L)$ 且 $T_b = \\frac{D}{v}$。你的任务是根据所述的物理和数学假设，推导以下量的闭式表达式：\n- 在吸收和反射边界条件下，期望雪崩尺寸 $\\mathbb{E}[S]$ 作为 $L$、$v$、$\\gamma$、$\\varepsilon$ 和 $a_0$ 的函数。\n- 在吸收和反射边界条件下，雪崩尺寸的上限截止值 $S_{\\max}$，定义为在 $x_0 \\in [0,L]$ 上 $S$ 的最大可能值。\n\n然后，在一个程序中实现这些表达式，以量化有限装置尺寸和边界条件如何限制雪崩尺度，并提出相对于机器尺寸 $L$ 的标度律。特别地，对于吸收边界，确定在 $L \\ll v T_d$ 和 $L \\gg v T_d$ 区间内 $\\mathbb{E}[S]$ 和 $S_{\\max}$ 的渐近标度，并将其与反射边界的情况进行比较。将 $a_0$ 解释为单位为 $\\mathrm{W}\\,\\mathrm{m}^{-2}$ 的通量振幅，因此 $S$ 的单位为 $\\mathrm{J}\\,\\mathrm{m}^{-2}$。所有数值答案必须以实数（浮点值）形式给出。此问题不涉及角度。如果 $\\gamma = 0$，请一致地将 $T_d = +\\infty$ 处理。\n\n测试套件：\n使用以下参数值集来测试您的公式和代码。对于每种情况，计算并报告以 $\\mathrm{J}\\,\\mathrm{m}^{-2}$ 为单位的 $\\mathbb{E}[S]$ 和 $S_{\\max}$。\n- 情况 1：吸收边界，$L = 1\\,\\mathrm{m}$，$v = 100\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$\\gamma = 50\\,\\mathrm{s}^{-1}$，$\\varepsilon = 0.01$，$a_0 = 1\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$。\n- 情况 2：吸收边界，$L = 100\\,\\mathrm{m}$，$v = 100\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$\\gamma = 50\\,\\mathrm{s}^{-1}$，$\\varepsilon = 0.01$，$a_0 = 1\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$。\n- 情况 3：反射边界，$L = 1\\,\\mathrm{m}$，$v = 100\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$\\gamma = 50\\,\\mathrm{s}^{-1}$，$\\varepsilon = 0.01$，$a_0 = 1\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$。\n- 情况 4：吸收边界，$L = 10\\,\\mathrm{m}$，$v = 200\\,\\mathrm{m}\\,\\mathrm{s}^{-1}$，$\\gamma = 0\\,\\mathrm{s}^{-1}$，$\\varepsilon = 0.01$（对于 $\\gamma=0$ 不使用），$a_0 = 2\\,\\mathrm{W}\\,\\mathrm{m}^{-2}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [`$\\mathbb{E}[S]_1$`, `$S_{\\max,1}$`, `$\\mathbb{E}[S]_2$`, `$S_{\\max,2}$`, `$\\mathbb{E}[S]_3$`, `$S_{\\max,3}$`, `$\\mathbb{E}[S]_4$`, `$S_{\\max,4}$`]，其中下标表示情况编号。所有输出均为以 $\\mathrm{J}\\,\\mathrm{m}^{-2}$ 为单位的实数。",
            "solution": "问题陈述已经过仔细审查，并被确定为有效。它基于一个简化但标准的等离子体输运模型，具有科学依据，在数学上是适定的、客观的且内部一致。所有必需的参数和分布均已提供，从而可以得到唯一且有意义的解。因此，我们可以继续进行推导和实现。\n\n主要任务是推导在反射和吸收两种不同边界条件下，期望雪崩尺寸 $\\mathbb{E}[S]$ 和最大可能雪崩尺寸 $S_{\\max}$ 的闭式表达式。雪崩尺寸 $S$ 由衰减振幅 $a(t)$ 的时间积分给出：\n$$S(T) = \\int_0^T a_0 e^{-\\gamma t} \\, dt$$\n其中 $T$ 是雪崩持续时间。根据阻尼率 $\\gamma$ 的不同，该积分产生两种形式：\n$$S(T) = \\begin{cases} \\frac{a_0}{\\gamma}\\left(1 - e^{-\\gamma T}\\right),  \\text{for } \\gamma > 0 \\\\ a_0 T,  \\text{for } \\gamma = 0 \\end{cases}$$\n持续时间 $T$ 由内在阻尼和边界相互作用之间的相互影响决定。\n\n由阻尼限制的持续时间 $T_d$ 是振幅衰减到其初始值的 $\\varepsilon$ 分数所需的时间，即 $a(T_d) = \\varepsilon a_0$。对于 $\\gamma>0$，可得 $a_0 e^{-\\gamma T_d} = \\varepsilon a_0$，解得 $T_d = \\frac{1}{\\gamma}\\ln\\left(\\frac{1}{\\varepsilon}\\right)$。对于 $\\gamma=0$，振幅从不衰减，因此 $T_d = \\infty$。\n\n由边界限制的持续时间 $T_b$ 是从 $x_0$ 出发的雪崩前沿到达边界 $x=L$ 所需的时间。给定恒定速度 $v$，此时间为 $T_b = \\frac{L-x_0}{v}$。出发点 $x_0$ 是一个在 $[0,L]$ 上均匀分布的随机变量。为方便起见，我们使用传播距离 $D = L-x_0$，因此它也均匀分布在 $[0,L]$ 上，即 $D \\sim \\mathrm{Uniform}(0,L)$，其概率密度函数为 $p(D) = 1/L$（对于 $D \\in [0,L]$）。因此，$T_b = D/v$ 是一个随机变量。\n\n我们现在分别分析这两种边界条件。\n\n**1. 反射边界条件**\n\n在此条件下，雪崩不被 $x=L$ 处的边界终止。其持续时间纯粹由阻尼限制。\n对于所有雪崩，无论其出发点 $x_0$ 如何，持续时间都是恒定的：\n$$T = T_d$$\n因此，雪崩尺寸 $S$ 也是一个与 $x_0$ 无关的常数。\n\n- **情况 $\\gamma > 0$**：\n持续时间为 $T = T_d = \\frac{1}{\\gamma}\\ln(1/\\varepsilon)$。尺寸为：\n$$S = \\frac{a_0}{\\gamma}\\left(1 - e^{-\\gamma T_d}\\right) = \\frac{a_0}{\\gamma}\\left(1 - e^{-\\gamma \\frac{1}{\\gamma}\\ln(1/\\varepsilon)}\\right) = \\frac{a_0}{\\gamma}\\left(1 - e^{-\\ln(1/\\varepsilon)}\\right) = \\frac{a_0}{\\gamma}\\left(1 - \\varepsilon\\right)$$\n由于 $S$ 是一个常数，其期望值和最大值相同：\n$$\\mathbb{E}[S]_{\\text{reflect}} = S_{\\max, \\text{reflect}} = \\frac{a_0(1-\\varepsilon)}{\\gamma}$$\n\n- **情况 $\\gamma = 0$**：\n持续时间为 $T = T_d = \\infty$。尺寸为：\n$$S = a_0 T = \\infty$$\n在一个不终止雪崩的系统中，无阻尼的雪崩将具有无限大的尺寸。期望尺寸和最大尺寸均为无限大。\n\n**2. 吸收边界条件**\n\n在此条件下，雪崩因阻尼或到达边界 $x=L$ 而终止，以先发生者为准。因此，持续时间 $T$ 是一个依赖于 $x_0$ 的随机变量：\n$$T(x_0) = \\min(T_b, T_d) = \\min\\left(\\frac{L-x_0}{v}, T_d\\right)$$\n用随机变量 $D=L-x_0$ 表示，持续时间为 $T(D) = \\min(D/v, T_d)$。\n\n**2.1. 最大雪崩尺寸 $S_{\\max}$**\n\n尺寸函数 $S(T)$ 随持续时间 $T$ 单调递增。因此，$S_{\\max}$ 对应于最大可能持续时间 $T_{\\max}$。持续时间 $T(D) = \\min(D/v, T_d)$ 在 $D$ 最大化时最大化。$D$ 的最大值为 $L$（当 $x_0=0$ 时）。\n$$T_{\\max} = \\min\\left(\\frac{L}{v}, T_d\\right)$$\n- **情况 $\\gamma > 0$**：\n$$S_{\\max, \\text{absorb}} = S(T_{\\max}) = \\frac{a_0}{\\gamma}\\left(1 - e^{-\\gamma \\min(L/v, T_d)}\\right)$$\n- **情况 $\\gamma = 0$**：\n此时 $T_d=\\infty$，所以 $T_{\\max} = \\min(L/v, \\infty) = L/v$。\n$$S_{\\max, \\text{absorb}} = a_0 T_{\\max} = \\frac{a_0 L}{v}$$\n\n**2.2. 期望雪崩尺寸 $\\mathbb{E}[S]$**\n\n期望尺寸是 $S(T(D))$ 在 $D$ 的分布上的平均值：\n$$\\mathbb{E}[S]_{\\text{absorb}} = \\int_0^L S(T(D)) p(D) \\, dD = \\frac{1}{L}\\int_0^L S\\left(\\min\\left(\\frac{D}{v}, T_d\\right)\\right) \\, dD$$\n\n- **情况 $\\gamma = 0$**：\n此时 $T_d = \\infty$，所以 $T(D) = D/v$。尺寸为 $S(D) = a_0 (D/v)$。\n$$\\mathbb{E}[S] = \\frac{1}{L}\\int_0^L \\frac{a_0 D}{v} \\, dD = \\frac{a_0}{vL} \\left[ \\frac{D^2}{2} \\right]_0^L = \\frac{a_0}{vL} \\frac{L^2}{2} = \\frac{a_0 L}{2v}$$\n这恰好是最大尺寸的一半，正如对于均匀分布变量的线性函数所预期的那样。\n\n- **情况 $\\gamma > 0$**：\n令 $L_d = v T_d$ 为雪崩在因阻尼终止前传播的特征距离。$\\mathbb{E}[S]$ 积分的计算取决于系统尺寸 $L$ 与该特征距离 $L_d$ 之间的比较。积分为：\n$$\\mathbb{E}[S] = \\frac{1}{L}\\int_0^L \\frac{a_0}{\\gamma}\\left(1 - e^{-\\gamma \\min(D/v, T_d)}\\right) \\, dD$$\n\n**情况 I：$L \\le L_d$ (小装置)**\n对于任何 $D \\in [0,L]$，我们有 $D \\le L \\le L_d$，这意味着 $D/v \\le T_d$。因此，在整个积分域内 $\\min(D/v, T_d) = D/v$。\n$$\\mathbb{E}[S] = \\frac{a_0}{\\gamma L}\\int_0^L \\left(1 - e^{-\\gamma D/v}\\right) \\, dD$$\n$$\\mathbb{E}[S] = \\frac{a_0}{\\gamma L} \\left[ D - \\left(-\\frac{v}{\\gamma}\\right) e^{-\\gamma D/v} \\right]_0^L = \\frac{a_0}{\\gamma L} \\left[ \\left(L + \\frac{v}{\\gamma}e^{-\\gamma L/v}\\right) - \\left(0 + \\frac{v}{\\gamma}e^0\\right) \\right]$$\n$$\\mathbb{E}[S] = \\frac{a_0}{\\gamma L} \\left[ L - \\frac{v}{\\gamma}\\left(1 - e^{-\\gamma L/v}\\right) \\right] = \\frac{a_0}{\\gamma} \\left[ 1 - \\frac{v}{\\gamma L}\\left(1 - e^{-\\gamma L/v}\\right) \\right]$$\n\n**情况 II：$L > L_d$ (大装置)**\n积分必须在 $D = L_d$ 处分开。\n对于 $D \\in [0, L_d]$，$\\min(D/v, T_d) = D/v$。\n对于 $D \\in (L_d, L]$，$\\min(D/v, T_d) = T_d$。\n$$\\mathbb{E}[S] = \\frac{1}{L} \\left[ \\int_0^{L_d} S(D/v) \\, dD + \\int_{L_d}^L S(T_d) \\, dD \\right]$$\n第一个积分与情况 I 中的相同，只是将 $L$ 替换为 $L_d$：\n$$\\int_0^{L_d} S(D/v) \\, dD = \\frac{a_0}{\\gamma} \\left[ L_d - \\frac{v}{\\gamma}\\left(1 - e^{-\\gamma L_d/v}\\right) \\right] = \\frac{a_0}{\\gamma} \\left[ vT_d - \\frac{v}{\\gamma}\\left(1 - e^{-\\gamma T_d}\\right) \\right]$$\n第二个积分是对一个常数 $S(T_d) = \\frac{a_0}{\\gamma}(1 - \\varepsilon)$ 的积分：\n$$\\int_{L_d}^L S(T_d) \\, dD = S(T_d) \\cdot (L - L_d) = \\frac{a_0}{\\gamma}(1-\\varepsilon)(L - vT_d)$$\n将这些部分相加并除以 $L$：\n$$\\mathbb{E}[S] = \\frac{a_0}{\\gamma L} \\left[ vT_d - \\frac{v}{\\gamma}(1 - \\varepsilon) + (L - vT_d)(1 - \\varepsilon) \\right]$$\n$$\\mathbb{E}[S] = \\frac{a_0}{\\gamma L} \\left[ vT_d - \\frac{v}{\\gamma}(1-\\varepsilon) + L(1-\\varepsilon) - vT_d(1-\\varepsilon) \\right]$$\n$$\\mathbb{E}[S] = \\frac{a_0}{\\gamma L} \\left[ L(1-\\varepsilon) + vT_d\\varepsilon - \\frac{v}{\\gamma}(1-\\varepsilon) \\right]$$\n\n**渐近标度分析（吸收边界，$\\gamma>0$）**\n\n- **$L \\ll vT_d$ (小机器极限):** 大多数雪崩会撞击边界。使用情况 I 的公式，对小自变量 $x = \\gamma L/v \\ll 1$ 进行泰勒展开，得到 $\\mathbb{E}[S] \\approx \\frac{a_0 L}{2v}$ 和 $S_{\\max} \\approx \\frac{a_0 L}{v}$。标度与 $L$ 呈线性关系，结果趋近于无阻尼（$\\gamma=0$）的情况，因为阻尼几乎没有时间起作用。\n- **$L \\gg vT_d$ (大机器极限):** 大多数雪崩因阻尼而终止。使用情况 II 的公式，当 $L \\to \\infty$ 时，被 $L$ 除的项消失，$\\mathbb{E}[S] \\to \\frac{a_0(1-\\varepsilon)}{\\gamma}$。同时，$S_{\\max}$ 饱和于 $\\frac{a_0(1-\\varepsilon)}{\\gamma}$。这两个量都变得与 $L$ 无关，并收敛到反射边界的结果，因为对于大多数事件，边界变得无关紧要。\n\n下面的程序实现了这些推导出的闭式表达式，以计算测试套件所需的值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_avalanche_stats(L, v, gamma, epsilon, a0, boundary_type):\n    \"\"\"\n    Calculates the expected and maximum avalanche size based on derived formulas.\n\n    Args:\n        L (float): Device size in meters.\n        v (float): Avalanche propagation speed in m/s.\n        gamma (float): Damping rate in 1/s.\n        epsilon (float): Termination threshold fraction.\n        a0 (float): Initial flux amplitude in W/m^2.\n        boundary_type (str): 'absorbing' or 'reflecting'.\n\n    Returns:\n        tuple[float, float]: A tuple containing (E[S], S_max) in J/m^2.\n    \"\"\"\n    \n    if boundary_type == \"reflecting\":\n        if gamma > 0:\n            # For reflecting boundaries, size is constant and purely damping-limited.\n            S = a0 * (1 - epsilon) / gamma\n            return S, S\n        else: # gamma == 0\n            # Undamped, non-terminated avalanche has infinite size.\n            return np.inf, np.inf\n\n    elif boundary_type == \"absorbing\":\n        if gamma > 0:\n            # Damping-limited duration and characteristic distance\n            Td = (1 / gamma) * np.log(1 / epsilon)\n            Ld = v * Td\n\n            # Maximum size calculation\n            T_max = min(L / v, Td)\n            S_max = (a0 / gamma) * (1 - np.exp(-gamma * T_max))\n\n            # Expected size calculation depends on L vs Ld\n            if L = Ld:\n                # Small machine regime (L = v*Td)\n                term = (v / (gamma * L)) * (1 - np.exp(-gamma * L / v))\n                E_S = (a0 / gamma) * (1 - term)\n            else:\n                # Large machine regime (L > v*Td)\n                term1 = L * (1 - epsilon)\n                term2 = (v / gamma) * (1 - epsilon)\n                term3 = v * Td * epsilon\n                E_S = (a0 / (gamma * L)) * (term1 - term2 + term3)\n            \n            return E_S, S_max\n\n        else: # gamma == 0\n            # Undamped case, duration is purely boundary-limited\n            S_max = a0 * L / v\n            E_S = a0 * L / (2 * v)\n            return E_S, S_max\n            \n    else:\n        raise ValueError(\"Invalid boundary_type specified.\")\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases from the problem statement.\n    \"\"\"\n    test_cases = [\n        # (L, v, gamma, epsilon, a0, boundary_type)\n        (1.0, 100.0, 50.0, 0.01, 1.0, \"absorbing\"),\n        (100.0, 100.0, 50.0, 0.01, 1.0, \"absorbing\"),\n        (1.0, 100.0, 50.0, 0.01, 1.0, \"reflecting\"),\n        (10.0, 200.0, 0.0, 0.01, 2.0, \"absorbing\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, v, gamma, epsilon, a0, boundary_type = case\n        E_S, S_max = calculate_avalanche_stats(L, v, gamma, epsilon, a0, boundary_type)\n        results.append(E_S)\n        results.append(S_max)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.7g}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}