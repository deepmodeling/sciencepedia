{
    "hands_on_practices": [
        {
            "introduction": "Spectral methods offer a powerful and elegant approach for solving differential equations in kinetic theory. By expanding the distribution function in a basis of functions that are eigenfunctions of the collision operator, the complex differential operator is transformed into a simple diagonal matrix. This practice guides you through the analytical derivation of the eigenvalues for the linearized Lenard-Bernstein operator in a basis of Laguerre and Legendre polynomials, demonstrating how this choice simplifies the problem and reveals the operator's fundamental properties.",
            "id": "4180568",
            "problem": "You are tasked with constructing a truncated Galerkin matrix representation of a linearized collision operator used in fusion plasma turbulence simulation. The model is the Lenard-Bernstein (LB) operator for a single species, linearized about a Maxwellian equilibrium of thermal speed $v_{\\mathrm{th}}$:\n$$\n\\mathcal{C}[f](\\mathbf{v}) \\;=\\; \\nu\\, \\nabla_{\\mathbf{v}}\\cdot\\left(\\mathbf{v}\\, f \\;+\\; v_{\\mathrm{th}}^2 \\nabla_{\\mathbf{v}} f\\right),\n$$\nwhere $\\nu$ is a constant collision frequency with units $\\mathrm{s}^{-1}$, $\\mathbf{v}$ is the velocity vector, and $f(\\mathbf{v})$ is the velocity distribution perturbation. Work in spherical velocity coordinates $(v,\\xi,\\varphi)$ where $v=\\|\\mathbf{v}\\|$, $\\xi=\\cos\\theta$ is the pitch-angle cosine, and $\\varphi$ is the gyrophase. Assume axisymmetry so that there is no dependence on $\\varphi$.\n\nConsider the spectral expansion in the tensor-product basis of generalized associated Laguerre functions in the speed $v$ and Legendre polynomials in the pitch-angle cosine $\\xi$:\n- Define the dimensionless speed variable $s = v^2/(2 v_{\\mathrm{th}}^2)$.\n- For each nonnegative integer pair $(n,\\ell)$ with $n \\in \\{0,1,2,\\dots\\}$ and $\\ell \\in \\{0,1,2,\\dots\\}$, define a radial basis function $R_{n\\ell}(s)$ proportional to $e^{-s} s^{\\ell/2} L_n^{(\\ell+1/2)}(s)$, where $L_n^{(\\alpha)}$ is the associated Laguerre polynomial of degree $n$ and parameter $\\alpha=\\ell+\\tfrac{1}{2}$.\n- For the angular dependence, use the Legendre polynomial $P_\\ell(\\xi)$ of degree $\\ell$.\n\nUse the weighted $L^2$ inner product associated with the Maxwellian measure in velocity space, which in these variables factorizes into a radial factor with weight $e^{-s} s^{1/2}$ and an angular factor over $\\xi \\in [-1,1]$. You may assume suitable normalization constants exist so that the tensor-product basis functions are orthonormal under this inner product.\n\nYour goals are:\n1. Starting from the definition of the operator $\\mathcal{C}$ and the properties of the spherical Laplacian, derive the structure of the Galerkin matrix elements\n$$\nC_{(n,\\ell),(n',\\ell')} \\;=\\; \\left\\langle R_{n\\ell}(s)\\,P_\\ell(\\xi)\\,,\\, \\mathcal{C}\\left[ R_{n'\\ell'}(s)\\,P_{\\ell'}(\\xi)\\right]\\right\\rangle,\n$$\nwith respect to the orthonormal basis $\\{ R_{n\\ell}(s)P_\\ell(\\xi) \\}$, where $\\langle \\cdot,\\cdot\\rangle$ denotes the inner product defined above.\n2. Show that the matrix is block diagonal in $\\ell$ and diagonal in $(n,\\ell)$, and determine the diagonal entries explicitly in terms of $\\nu$, $n$, and $\\ell$.\n3. Implement a program that constructs the truncated Galerkin matrix for a given collision frequency $\\nu$, a radial truncation $N_v$ (meaning $n \\in \\{0,1,\\dots,N_v-1\\}$), and an angular truncation $L_{\\max}$ (meaning $\\ell \\in \\{0,1,\\dots,L_{\\max}\\}$). Your implementation should output the diagonal entries in a fixed enumeration order: loop over $\\ell$ from $0$ to $L_{\\max}$ (outer loop), and within each $\\ell$, loop over $n$ from $0$ to $N_v-1$ (inner loop). Express all diagonal entries in units of $\\mathrm{s}^{-1}$, rounded by the default floating-point conversion.\n\nTest suite and final output specification:\n- Use the following four test cases to exercise different facets of the implementation:\n    1. General case: $\\nu = 0.7\\,\\mathrm{s}^{-1}$, $N_v = 3$, $L_{\\max} = 2$.\n    2. Isotropic boundary: $\\nu = 1.0\\,\\mathrm{s}^{-1}$, $N_v = 4$, $L_{\\max} = 0$.\n    3. Zero-frequency edge: $\\nu = 0.0\\,\\mathrm{s}^{-1}$, $N_v = 5$, $L_{\\max} = 3$.\n    4. Invariance check with respect to the thermal speed $v_{\\mathrm{th}}$: demonstrate numerically that the diagonal entries do not depend on $v_{\\mathrm{th}}$ by comparing the diagonal lists produced with $v_{\\mathrm{th}}=1.0\\,\\mathrm{m/s}$ and $v_{\\mathrm{th}}=3.7\\,\\mathrm{m/s}$ for $\\nu = 0.9\\,\\mathrm{s}^{-1}$, $N_v = 2$, $L_{\\max} = 3$, and returning a boolean that is true if and only if all corresponding entries are equal within a tolerance of $10^{-12}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The first three items must be lists of floating-point numbers representing the diagonal entries (in $\\mathrm{s}^{-1}$) for test cases $1$–$3$ in the specified enumeration order. The fourth item must be a boolean for test case $4$. For example, the overall output format should look like $[ [\\dots], [\\dots], [\\dots], \\mathrm{True} ]$ where each inner list is ordered as required.\n\nAll symbols, variables, functions, operators, and numbers in this problem statement are to be interpreted mathematically, and physical quantities should be treated with their stated units.",
            "solution": "The problem is valid. It is a well-posed problem in mathematical physics, specifically in the context of kinetic theory for plasmas, and is grounded in established scientific principles. All necessary information is provided.\n\nThe primary task is to determine the matrix elements of the linearized Lenard-Bernstein collision operator, $\\mathcal{C}$, in a spectral basis composed of generalized Laguerre polynomials and Legendre polynomials. The operator is given by:\n$$\n\\mathcal{C}[f](\\mathbf{v}) \\;=\\; \\nu\\, \\nabla_{\\mathbf{v}}\\cdot\\left(\\mathbf{v}\\, f \\;+\\; v_{\\mathrm{th}}^2 \\nabla_{\\mathbf{v}} f\\right)\n$$\nwhere $\\nu$ is the collision frequency, $f$ is the perturbation to the velocity distribution function, $\\mathbf{v}$ is the velocity, and $v_{\\mathrm{th}}$ is the thermal speed. We work in spherical velocity coordinates $(v, \\xi)$ assuming axisymmetry, where $v = \\|\\mathbf{v}\\|$ and $\\xi = \\cos\\theta$. The basis functions are of the form $\\Psi_{n\\ell}(v, \\xi) = R_{n\\ell}(v) P_\\ell(\\xi)$. The problem states these basis functions are orthonormal with respect to the inner product $\\langle f, g \\rangle = \\int f(\\mathbf{v})^* g(\\mathbf{v}) d\\mu(\\mathbf{v})$, where the measure $d\\mu(\\mathbf{v})$ corresponds to a Maxwellian distribution, i.e., $d\\mu(\\mathbf{v}) \\propto e^{-v^2/(2v_{\\mathrm{th}}^2)} v^2 dv d\\xi$.\n\nThe matrix elements are defined as $C_{(n,\\ell),(n',\\ell')} = \\langle \\Psi_{n\\ell}, \\mathcal{C}[\\Psi_{n'\\ell'}] \\rangle$. We will show that the given basis functions $\\Psi_{n\\ell}$ are in fact eigenfunctions of the operator $\\mathcal{C}$. This proves that the resulting Galerkin matrix is diagonal.\n\nFirst, let's expand the divergence in the definition of $\\mathcal{C}$:\n$$\n\\nabla_{\\mathbf{v}}\\cdot\\left(\\mathbf{v}\\, f\\right) = (\\nabla_{\\mathbf{v}}\\cdot\\mathbf{v}) f + \\mathbf{v}\\cdot(\\nabla_{\\mathbf{v}}f) = 3f + \\mathbf{v}\\cdot(\\nabla_{\\mathbf{v}}f)\n$$\nwhere we used $\\nabla_{\\mathbf{v}}\\cdot\\mathbf{v} = 3$ in three dimensions. Substituting this into the operator expression gives:\n$$\n\\mathcal{C}[f] = \\nu \\left( 3f + \\mathbf{v}\\cdot\\nabla_{\\mathbf{v}}f + v_{\\mathrm{th}}^2 \\nabla_{\\mathbf{v}}^2 f \\right)\n$$\nNext, we express the differential operators in spherical coordinates $(v, \\theta, \\varphi)$. With axisymmetry, all derivatives with respect to $\\varphi$ vanish.\nThe operator $\\mathbf{v}\\cdot\\nabla_{\\mathbf{v}}$ is the directional derivative along the radial velocity direction, which is simply $v \\frac{\\partial}{\\partial v}$.\nThe Laplacian operator $\\nabla_{\\mathbf{v}}^2$ in spherical coordinates is:\n$$\n\\nabla_{\\mathbf{v}}^2 f = \\frac{1}{v^2}\\frac{\\partial}{\\partial v}\\left(v^2 \\frac{\\partial f}{\\partial v}\\right) + \\frac{1}{v^2 \\sin\\theta}\\frac{\\partial}{\\partial \\theta}\\left(\\sin\\theta \\frac{\\partial f}{\\partial \\theta}\\right)\n$$\nChanging the angular variable to the pitch-angle cosine $\\xi = \\cos\\theta$ (so $d\\xi = -\\sin\\theta d\\theta$), the angular part becomes $\\frac{1}{v^2} \\frac{\\partial}{\\partial \\xi}\\left((1-\\xi^2)\\frac{\\partial f}{\\partial \\xi}\\right)$. This is $\\frac{1}{v^2}$ times the Legendre operator. For a basis function $f = R(v)P_\\ell(\\xi)$, this term becomes $-\\frac{\\ell(\\ell+1)}{v^2} R(v) P_\\ell(\\xi)$.\n\nApplying the operator $\\mathcal{C}$ to a basis function $\\Psi_{n'\\ell'}(v, \\xi) = R_{n'\\ell'}(v) P_{\\ell'}(\\xi)$ yields:\n$$\n\\mathcal{C}[\\Psi_{n'\\ell'}] = \\nu \\left( 3\\Psi_{n'\\ell'} + v \\frac{\\partial \\Psi_{n'\\ell'}}{\\partial v} + v_{\\mathrm{th}}^2 \\left[ \\frac{1}{v^2}\\frac{\\partial}{\\partial v}\\left(v^2 \\frac{\\partial \\Psi_{n'\\ell'}}{\\partial v}\\right) - \\frac{\\ell'(\\ell'+1)}{v^2}\\Psi_{n'\\ell'} \\right] \\right)\n$$\nSince the angular dependence of $\\Psi_{n'\\ell'}$ is entirely within $P_{\\ell'}(\\xi)$, which is an eigenfunction of the angular part of the Laplacian, the operator $\\mathcal{C}$ does not mix different angular modes $\\ell'$. Thus, the matrix is block-diagonal in $\\ell$, i.e., $C_{(n,\\ell),(n',\\ell')} = 0$ if $\\ell \\neq \\ell'$.\nDue to orthonormality of the Legendre polynomials, this confirms the block-diagonal structure in $\\ell$. We now analyze the radial part for a fixed $\\ell$. Let's define a radial operator $\\mathcal{O}_{\\ell}$:\n$$\n\\mathcal{O}_{\\ell}[R] = \\nu \\left( 3R + v \\frac{dR}{dv} + v_{\\mathrm{th}}^2 \\left[ \\frac{1}{v^2}\\frac{d}{dv}\\left(v^2 \\frac{dR}{dv}\\right) \\right] - \\frac{v_{\\mathrm{th}}^2\\ell(\\ell+1)}{v^2}R \\right)\n$$\nTo analyze this operator, we switch to the dimensionless speed variable $s = v^2 / (2v_{\\mathrm{th}}^2)$. The chain rule gives the following relations for derivatives:\n$$\n\\frac{d}{dv} = \\frac{ds}{dv}\\frac{d}{ds} = \\frac{v}{v_{\\mathrm{th}}^2}\\frac{d}{ds}\n$$\n$$\nv\\frac{d}{dv} = v\\left(\\frac{v}{v_{\\mathrm{th}}^2}\\frac{d}{ds}\\right) = \\frac{v^2}{v_{\\mathrm{th}}^2}\\frac{d}{ds} = 2s\\frac{d}{ds}\n$$\nThe radial part of the Laplacian is $\\frac{1}{v^2}\\frac{d}{dv}(v^2 \\frac{d}{dv}) = \\frac{d^2}{dv^2} + \\frac{2}{v}\\frac{d}{dv}$. Let's transform these terms:\n$$\n\\frac{d^2}{dv^2} = \\frac{d}{dv}\\left(\\frac{v}{v_{\\mathrm{th}}^2}\\frac{d}{ds}\\right) = \\frac{1}{v_{\\mathrm{th}}^2}\\frac{d}{ds} + \\frac{v}{v_{\\mathrm{th}}^2}\\frac{d}{dv}\\left(\\frac{d}{ds}\\right) = \\frac{1}{v_{\\mathrm{th}}^2}\\frac{d}{ds} + \\frac{v^2}{v_{\\mathrm{th}}^4}\\frac{d^2}{ds^2} = \\frac{1}{v_{\\mathrm{th}}^2}\\left( \\frac{d}{ds} + 2s \\frac{d^2}{ds^2} \\right)\n$$\nSo the radial Laplacian term becomes:\n$$\nv_{\\mathrm{th}}^2 \\left( \\frac{d^2}{dv^2} + \\frac{2}{v}\\frac{d}{dv} \\right) R(s) = v_{\\mathrm{th}}^2 \\left[ \\frac{1}{v_{\\mathrm{th}}^2}\\left(\\frac{d}{ds} + 2s\\frac{d^2}{ds^2}\\right) + \\frac{2}{v}\\left(\\frac{v}{v_{\\mathrm{th}}^2}\\frac{d}{ds}\\right) \\right] R(s) = \\left( 3\\frac{d}{ds} + 2s\\frac{d^2}{ds^2} \\right) R(s)\n$$\nSubstituting these expressions in $s$ into the operator $\\mathcal{O}_{\\ell}$:\n$$\n\\frac{1}{\\nu} \\mathcal{O}_{\\ell}[R] = 3R + 2s\\frac{dR}{ds} + \\left(3\\frac{dR}{ds} + 2s\\frac{d^2R}{ds^2}\\right) - \\frac{\\ell(\\ell+1)}{2s}R\n$$\n$$\n\\frac{1}{\\nu} \\mathcal{O}_{\\ell}[R] = 2s\\frac{d^2R}{ds^2} + (2s+3)\\frac{dR}{ds} + \\left(3 - \\frac{\\ell(\\ell+1)}{2s}\\right)R\n$$\nThe problem states the radial basis functions are $R_{n\\ell}(s) \\propto e^{-s} s^{\\ell/2} L_n^{(\\ell+1/2)}(s)$. Let's test if these are eigenfunctions of $\\mathcal{O}_{\\ell}$. Let $R(s) = e^{-s} u(s)$.\n$R' = e^{-s}(u' - u)$ and $R'' = e^{-s}(u'' - 2u' + u)$.\nSubstituting into the operator for $R$:\n$$\n\\frac{1}{\\nu} \\mathcal{O}_{\\ell}[e^{-s}u] = e^{-s} \\left[ 2s(u''-2u'+u) + (2s+3)(u'-u) + \\left(3 - \\frac{\\ell(\\ell+1)}{2s}\\right)u \\right]\n$$\n$$\n= e^{-s} \\left[ 2su'' + (-4s + 2s+3)u' + (2s - (2s+3) + 3 - \\frac{\\ell(\\ell+1)}{2s})u \\right]\n$$\n$$\n= e^{-s} \\left[ 2su'' + (3-2s)u' - \\frac{\\ell(\\ell+1)}{2s} u \\right]\n$$\nNow, we test $u(s) = s^{\\ell/2} L_n^{(\\alpha)}(s)$ with $\\alpha = \\ell+1/2$. Let $y(s) = L_n^{(\\alpha)}(s)$. So $u=s^{\\ell/2}y$.\n$u' = \\frac{\\ell}{2}s^{\\ell/2-1}y + s^{\\ell/2}y'$\n$u'' = \\frac{\\ell}{2}(\\frac{\\ell}{2}-1)s^{\\ell/2-2}y + \\ell s^{\\ell/2-1}y' + s^{\\ell/2}y''$\nSubstituting these into the expression for $u$ and collecting terms with $y, y', y''$:\n$$\n2su'' \\rightarrow 2s\\left(\\frac{\\ell}{2}(\\frac{\\ell}{2}-1)s^{\\ell/2-2}y + \\ell s^{\\ell/2-1}y' + s^{\\ell/2}y''\\right) = \\ell(\\frac{\\ell}{2}-1)s^{\\ell/2-1}y + 2\\ell s^{\\ell/2}y' + 2s^{\\ell/2+1}y''\n$$\n$$\n(3-2s)u' \\rightarrow (3-2s)\\left(\\frac{\\ell}{2}s^{\\ell/2-1}y + s^{\\ell/2}y'\\right) = \\frac{3\\ell}{2}s^{\\ell/2-1}y - \\ell s^{\\ell/2}y + (3-2s)s^{\\ell/2}y'\n$$\n$$\n-\\frac{\\ell(\\ell+1)}{2s}u \\rightarrow -\\frac{\\ell(\\ell+1)}{2}s^{\\ell/2-1}y\n$$\nSumming coefficients for $y''$: $2s^{\\ell/2+1}y''$.\nSumming coefficients for $y'$: $(2\\ell s^{\\ell/2} + 3s^{\\ell/2} - 2s^{\\ell/2+1})y' = s^{\\ell/2}(2\\ell+3-2s)y'$.\nSumming coefficients for $y$:\n$$\n\\left[\\ell(\\frac{\\ell}{2}-1)s^{\\ell/2-1} + \\frac{3\\ell}{2}s^{\\ell/2-1} - \\ell s^{\\ell/2} - \\frac{\\ell(\\ell+1)}{2}s^{\\ell/2-1}\\right]y = s^{\\ell/2-1}y\\left[\\frac{\\ell^2}{2}-\\ell+\\frac{3\\ell}{2}-\\frac{\\ell^2}{2}-\\frac{\\ell}{2}\\right] - \\ell s^{\\ell/2}y = -\\ell s^{\\ell/2}y\n$$\nThe whole expression becomes: $e^{-s} s^{\\ell/2} \\left[2s y'' + (2\\ell+3-2s)y' -\\ell y \\right]$.\nThe generalized Laguerre polynomials $y = L_n^{(\\alpha)}(s)$ satisfy the differential equation: $s y'' + (\\alpha+1-s)y' + ny = 0$.\nWith $\\alpha = \\ell+1/2$, this is $s y'' + (\\ell+3/2-s)y' + ny = 0$.\nMultiplying by $2$ gives $2s y'' + (2\\ell+3-2s)y' + 2ny = 0$.\nWe can substitute $2s y'' + (2\\ell+3-2s)y' = -2ny$ into our result.\nThe expression becomes: $e^{-s} s^{\\ell/2} [-2ny - \\ell y] = -(2n+\\ell) e^{-s} s^{\\ell/2} y = -(2n+\\ell) R_{n\\ell}(s)$.\nSo, we have found that $R_{n\\ell}$ is an eigenfunction of the radial operator: $\\frac{1}{\\nu}\\mathcal{O}_{\\ell}[R_{n\\ell}] = -(2n+\\ell)R_{n\\ell}$.\nTherefore, the basis functions $\\Psi_{n\\ell}$ are eigenfunctions of the full operator $\\mathcal{C}$:\n$$\n\\mathcal{C}[\\Psi_{n\\ell}] = -\\nu(2n+\\ell) \\Psi_{n\\ell}\n$$\nThe eigenvalues are $\\lambda_{n\\ell} = -\\nu(2n+\\ell)$. The thermal speed $v_{\\mathrm{th}}$ has cancelled out, so the eigenvalues do not depend on it.\n\nSince the basis functions are eigenfunctions and are assumed to be orthonormal, the Galerkin matrix is diagonal:\n$$\nC_{(n,\\ell),(n',\\ell')} = \\langle \\Psi_{n\\ell}, \\mathcal{C}[\\Psi_{n'\\ell'}] \\rangle = \\langle \\Psi_{n\\ell}, \\lambda_{n'\\ell'} \\Psi_{n'\\ell'} \\rangle = \\lambda_{n'\\ell'} \\langle \\Psi_{n\\ell}, \\Psi_{n'\\ell'} \\rangle = \\lambda_{n\\ell} \\delta_{nn'} \\delta_{\\ell\\ell'}\n$$\nThe diagonal entries of the matrix are simply the eigenvalues $\\lambda_{n\\ell} = -\\nu(2n+\\ell)$.\n\nTo implement the program, we compute these values for the specified ranges of $n$ and $\\ell$. The required enumeration order is to loop over $\\ell$ from $0$ to $L_{\\max}$ (outer loop), and for each $\\ell$, loop over $n$ from $0$ to $N_v-1$ (inner loop).\nFor test case 4, we must demonstrate that the result is independent of $v_{\\mathrm{th}}$. As shown by the analytical derivation of the eigenvalues $\\lambda_{n\\ell}$, there is no dependence on $v_{\\mathrm{th}}$. A numerical computation with two different values of $v_{\\mathrm{th}}$ will therefore produce identical lists of eigenvalues, resulting in the boolean `True`.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_diagonals(nu, N_v, L_max):\n    \"\"\"\n    Calculates the diagonal entries of the truncated Galerkin matrix for the\n    linearized Lenard-Bernstein operator.\n\n    The diagonal entries correspond to the eigenvalues lambda_nl = -nu * (2n + l).\n\n    Args:\n        nu (float): The collision frequency in s^-1.\n        N_v (int): The radial truncation number (n goes from 0 to N_v-1).\n        L_max (int): The angular truncation number (l goes from 0 to L_max).\n\n    Returns:\n        list: A list of floating-point numbers representing the diagonal entries\n              in the specified enumeration order.\n    \"\"\"\n    diagonals = []\n    # Loop over l from 0 to L_max (outer loop)\n    for l_val in range(L_max + 1):\n        # Loop over n from 0 to N_v-1 (inner loop)\n        for n_val in range(N_v):\n            # Eigenvalue formula derived in the solution: lambda = -nu * (2n + l)\n            eigenvalue = -nu * (2 * n_val + l_val)\n            diagonals.append(eigenvalue)\n    return diagonals\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the formatted result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. General case\n        {'nu': 0.7, 'N_v': 3, 'L_max': 2},\n        # 2. Isotropic boundary\n        {'nu': 1.0, 'N_v': 4, 'L_max': 0},\n        # 3. Zero-frequency edge\n        {'nu': 0.0, 'N_v': 5, 'L_max': 3}\n    ]\n\n    results = []\n\n    # Process test cases 1-3\n    for case in test_cases:\n        diagonals = calculate_diagonals(case['nu'], case['N_v'], case['L_max'])\n        results.append(diagonals)\n\n    # Process test case 4: Invariance check with respect to v_th\n    # The derived eigenvalue formula does not depend on v_th, so the results\n    # for v_th=1.0 m/s and v_th=3.7 m/s will be identical.\n    case4_params = {'nu': 0.9, 'N_v': 2, 'L_max': 3}\n    # v_th is not an argument to the calculation function, demonstrating its independence.\n    list_a = calculate_diagonals(case4_params['nu'], case4_params['N_v'], case4_params['L_max'])\n    list_b = calculate_diagonals(case4_params['nu'], case4_params['N_v'], case4_params['L_max'])\n\n    # Compare the two lists for numerical equivalence within the specified tolerance.\n    # rtol=0 is important for comparing with zero values.\n    is_equal = np.allclose(list_a, list_b, atol=1e-12, rtol=0)\n    results.append(is_equal)\n\n    # The final print statement must produce a single-line string representation\n    # of the list of results.\n    # Using f-string automatically handles the conversion of lists and boolean to string.\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While spectral methods are elegant, local discretizations like finite-difference or finite-volume schemes are often favored for their flexibility in handling complex geometries and non-linear terms. However, this flexibility comes at a cost, often introducing significant numerical challenges. This exercise delves into the critical issue of numerical stiffness, where the large negative eigenvalues of the discretized collision operator impose severe stability constraints on explicit time-integration schemes, forcing impractically small time steps.",
            "id": "4180542",
            "problem": "Consider the linearized kinetic equation for a perturbed distribution $g$ in a fusion plasma turbulence simulation, written in one-dimensional parallel configuration space and velocity space,\n$$\n\\partial_t g + v_{\\parallel}\\,\\partial_z g + i\\,\\omega_*\\, g \\;=\\; L\\,g,\n$$\nwhere $v_{\\parallel}$ is the parallel velocity, $\\omega_*$ is a constant diamagnetic drive frequency, and $L$ is a linearized collision operator. Assume a simplified model in which $L$ consists of two decoupled test-particle pieces: pitch-angle scattering and energy diffusion, acting on the pitch-angle cosine $\\xi$ and the normalized speed $u = v/v_{\\mathrm{th}}$, respectively,\n$$\nL \\;=\\; \\nu\\,\\partial_{\\xi}\\!\\left[(1-\\xi^2)\\,\\partial_{\\xi}\\,\\cdot\\right] \\;+\\; \\nu\\,\\partial_{uu}\n$$\nwith constant collision frequency $\\nu$, and $v_{\\mathrm{th}}$ the thermal speed. Take a spectral representation in $\\xi$ using Legendre polynomials $P_{\\ell}(\\xi)$ (so that $\\partial_{\\xi}[(1-\\xi^2)\\partial_{\\xi}] P_{\\ell} = -\\ell(\\ell+1) P_{\\ell}$), truncated at $\\ell_{\\max}$, and a grid in $u$ with uniform spacing $\\Delta u$ and sufficient resolution such that the largest resolved wavenumber in $u$-space can be estimated as $k_{u,\\max} \\approx \\pi/\\Delta u$. For the advective streaming term, take a single parallel Fourier mode with wavenumber $k_{\\parallel}$, so that its linear frequency scale is $\\omega_s = v_{\\mathrm{th}}\\,k_{\\parallel}$. Assume all other nonlinearities and field coupling are turned off.\n\nUse the following numerically plausible parameters representative of electron-scale turbulence resolution and collision strength:\n- $\\nu = 5\\times 10^5\\ \\mathrm{s}^{-1}$,\n- $\\ell_{\\max} = 32$,\n- $\\Delta u = 0.01$,\n- $v_{\\mathrm{th}} = 6\\times 10^7\\ \\mathrm{m/s}$,\n- $k_{\\parallel} = 100\\ \\mathrm{m}^{-1}$,\n- $\\omega_* = 8\\times 10^4\\ \\mathrm{s}^{-1}$.\n\nBased on first principles of the spectral properties of the pitch-angle scattering operator and the diffusion operator in $u$-space, and the form of the streaming and drive terms, which option correctly explains why the collision operator introduces stiffness relative to the advective and drive terms, and provides a consistent estimate for the most restrictive stability-limited timestep $\\Delta t$ for a fully explicit forward Euler time integrator applied to the semi-discrete system?\n\nChoose one:\n\nA. The pitch-angle operator has eigenvalues $-\\nu\\,\\ell(\\ell+1)$ and the $u$-diffusion has eigenvalues $-\\nu\\,k_u^2$, so the largest negative real part is approximately $\\lambda_{\\max}^{(L)} \\approx -\\nu\\,\\ell_{\\max}(\\ell_{\\max}+1)$ or $-\\nu\\,(\\pi/\\Delta u)^2$, whichever is larger. With the given parameters, $|\\lambda_{\\max}^{(L)}|$ from $u$-diffusion exceeds both $|\\omega_s|$ and $|\\omega_*|$, making the system stiff; the forward Euler stability bound is $\\Delta t \\lesssim 2/|\\lambda_{\\max}^{(L)}| \\approx 4\\times 10^{-11}\\ \\mathrm{s}$.\n\nB. The collision operator contributes purely imaginary eigenvalues that only shift the phase of $g$, so stiffness does not arise from collisions. The timestep is limited by the streaming term, with $\\Delta t \\lesssim 1/|\\omega_s| \\approx 1.7\\times 10^{-10}\\ \\mathrm{s}$.\n\nC. The largest eigenvalue of the collision operator is $-\\nu$, independent of velocity-space resolution, so the timestep bound is $\\Delta t \\lesssim 2/\\nu \\approx 4\\times 10^{-6}\\ \\mathrm{s}$, which is much larger than the advective bound.\n\nD. Stiffness is dominated by pitch-angle scattering with $\\lambda_{\\max}^{(L)} \\approx -\\nu\\,\\ell_{\\max}(\\ell_{\\max}+1)$, so the timestep bound is $\\Delta t \\lesssim 2/\\left[\\nu\\,\\ell_{\\max}(\\ell_{\\max}+1)\\right] \\approx 4\\times 10^{-9}\\ \\mathrm{s}$; energy diffusion in $u$ is subdominant and can be neglected in the stiffness estimate.",
            "solution": "Begin from the linearized kinetic equation,\n$$\n\\partial_t g + v_{\\parallel}\\,\\partial_z g + i\\,\\omega_*\\, g \\;=\\; L\\,g,\n$$\nwith $L$ composed of pitch-angle scattering and energy diffusion,\n$$\nL \\;=\\; \\nu\\,\\partial_{\\xi}\\!\\left[(1-\\xi^2)\\,\\partial_{\\xi}\\,\\cdot\\right] \\;+\\; \\nu\\,\\partial_{uu}\\,.\n$$\nWe analyze the spectral properties of each term.\n\nFor the pitch-angle scattering operator, the well-known eigenfunctions are the Legendre polynomials $P_{\\ell}(\\xi)$, and\n$$\n\\partial_{\\xi}\\!\\left[(1-\\xi^2)\\,\\partial_{\\xi} P_{\\ell}\\right] \\;=\\; -\\,\\ell(\\ell+1)\\,P_{\\ell}.\n$$\nMultiplying by $\\nu$, the eigenvalues contributed by pitch-angle scattering are\n$$\n\\lambda_{\\ell}^{(\\xi)} \\;=\\; -\\,\\nu\\,\\ell(\\ell+1).\n$$\nTruncating at $\\ell_{\\max}$, the most negative eigenvalue from pitch-angle scattering is\n$$\n\\lambda_{\\max}^{(\\xi)} \\;=\\; -\\,\\nu\\,\\ell_{\\max}(\\ell_{\\max}+1).\n$$\nWith $\\nu = 5\\times 10^5\\ \\mathrm{s}^{-1}$ and $\\ell_{\\max}=32$, we have $\\ell_{\\max}(\\ell_{\\max}+1) = 32\\times 33 = 1056$, hence\n$$\n|\\lambda_{\\max}^{(\\xi)}| \\;=\\; \\nu\\,\\ell_{\\max}(\\ell_{\\max}+1) \\;=\\; (5\\times 10^5)\\times 1056 \\;\\approx\\; 5.28\\times 10^8\\ \\mathrm{s}^{-1}.\n$$\n\nFor the energy diffusion operator in the normalized speed coordinate $u = v/v_{\\mathrm{th}}$, the continuous operator is $\\nu\\,\\partial_{uu}$, whose Fourier eigenvalues are $-\\nu\\,k_u^2$. On a grid with spacing $\\Delta u$, the largest resolvable wavenumber can be estimated as $k_{u,\\max} \\approx \\pi/\\Delta u$, so the most negative eigenvalue magnitude from $u$-diffusion is\n$$\n|\\lambda_{\\max}^{(u)}| \\;\\approx\\; \\nu\\,k_{u,\\max}^2 \\;\\approx\\; \\nu\\left(\\frac{\\pi}{\\Delta u}\\right)^2.\n$$\nWith $\\nu = 5\\times 10^5\\ \\mathrm{s}^{-1}$ and $\\Delta u = 0.01$, we find\n$$\n\\left(\\frac{\\pi}{\\Delta u}\\right)^2 \\;=\\; \\left(\\frac{3.14159}{0.01}\\right)^2 \\;\\approx\\; (314.159)^2 \\;\\approx\\; 9.87\\times 10^4,\n$$\nso\n$$\n|\\lambda_{\\max}^{(u)}| \\;\\approx\\; (5\\times 10^5)\\times (9.87\\times 10^4) \\;\\approx\\; 4.94\\times 10^{10}\\ \\mathrm{s}^{-1}.\n$$\n\nNext, consider the advective streaming term. For a single parallel Fourier mode with $k_{\\parallel}$, the streaming frequency scale is\n$$\n\\omega_s \\;=\\; v_{\\mathrm{th}}\\,k_{\\parallel}.\n$$\nWith $v_{\\mathrm{th}} = 6\\times 10^7\\ \\mathrm{m/s}$ and $k_{\\parallel} = 100\\ \\mathrm{m}^{-1}$,\n$$\n|\\omega_s| \\;=\\; (6\\times 10^7)\\times 100 \\;=\\; 6\\times 10^9\\ \\mathrm{s}^{-1}.\n$$\nThe diamagnetic drive contributes a purely imaginary term $i\\omega_*$ with $|\\omega_*| = 8\\times 10^4\\ \\mathrm{s}^{-1}$.\n\nComparing scales:\n- $|\\lambda_{\\max}^{(u)}| \\approx 4.94\\times 10^{10}\\ \\mathrm{s}^{-1}$ (real, negative),\n- $|\\lambda_{\\max}^{(\\xi)}| \\approx 5.28\\times 10^{8}\\ \\mathrm{s}^{-1}$ (real, negative),\n- $|\\omega_s| \\approx 6\\times 10^{9}\\ \\mathrm{s}^{-1}$ (purely imaginary),\n- $|\\omega_*| \\approx 8\\times 10^{4}\\ \\mathrm{s}^{-1}$ (purely imaginary).\n\nThe largest magnitude eigenvalues arise from the collision operator, specifically the energy diffusion in $u$-space. Because these eigenvalues have large negative real parts, they introduce stiffness: the fastest decaying modes associated with velocity-space diffusion evolve on a timescale $O(1/|\\lambda_{\\max}^{(u)}|)$, which is much shorter than the advective or drive timescales. In an explicit forward Euler scheme applied to a linear system $\\partial_t y = A y$ with an eigenvalue $\\lambda$ having negative real part, the stability requirement along that eigenmode is $|1 + \\Delta t\\,\\lambda| \\le 1$, which for real negative $\\lambda$ reduces to\n$$\n\\Delta t \\;\\le\\; \\frac{2}{|\\lambda|}.\n$$\nHence, the most restrictive explicit timestep is controlled by the largest negative real eigenvalue of $L$, i.e.,\n$$\n\\Delta t_{\\max} \\;\\approx\\; \\frac{2}{|\\lambda_{\\max}^{(L)}|} \\;\\approx\\; \\frac{2}{|\\lambda_{\\max}^{(u)}|} \\;\\approx\\; \\frac{2}{4.94\\times 10^{10}} \\;\\approx\\; 4.05\\times 10^{-11}\\ \\mathrm{s}.\n$$\nBy contrast, advective and drive terms are purely imaginary and do not impose this forward Euler diffusion-type bound; their explicit stability in practice follows a Courant–Friedrichs–Lewy (CFL) restriction that depends on spatial discretization. Even if one estimates a naive bound $\\Delta t \\sim 1/|\\omega_s| \\approx 1.7\\times 10^{-10}\\ \\mathrm{s}$, it is still less restrictive than the collisional diffusion bound computed above. Therefore, collisions render the semi-discrete kinetic system stiff relative to the advective and drive terms under these resolution and parameter choices.\n\nOption-by-option analysis:\n- Option A correctly states the eigenvalue scalings: $-\\nu\\,\\ell(\\ell+1)$ for pitch-angle scattering and $-\\nu\\,k_u^2$ for $u$-diffusion. It identifies that the largest magnitude eigenvalue is due to $u$-diffusion at the given $\\Delta u$, and correctly compares it to $|\\omega_s|$ and $|\\omega_*|$, concluding stiffness. Its timestep estimate $\\Delta t \\lesssim 2/|\\lambda_{\\max}^{(L)}|$ and the numerical value $\\approx 4\\times 10^{-11}\\ \\mathrm{s}$ are consistent with the above derivation. Verdict: Correct.\n- Option B incorrectly claims that collisions contribute purely imaginary eigenvalues; in fact, diffusion operators produce negative real eigenvalues, which are precisely the source of stiffness in explicit schemes. The timestep limited only by streaming, $\\Delta t \\lesssim 1/|\\omega_s|$, neglects the dominant collisional stability constraint. Verdict: Incorrect.\n- Option C asserts the largest collisional eigenvalue is $-\\nu$, independent of resolution, which contradicts the spectral scaling of diffusion ($\\propto k^2$) and pitch-angle scattering ($\\propto \\ell(\\ell+1)$). The resulting timestep $\\Delta t \\approx 2/\\nu$ is orders of magnitude too large and ignores resolution-induced stiffness. Verdict: Incorrect.\n- Option D focuses exclusively on pitch-angle scattering and neglects the $u$-diffusion contribution, which is much larger under the given parameters. Its timestep estimate $\\approx 4\\times 10^{-9}\\ \\mathrm{s}$ is less restrictive than the correct bound from $u$-diffusion and thus inconsistent. Verdict: Incorrect.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "A cornerstone of any physically meaningful simulation is the strict adherence to fundamental conservation laws. Numerical discretization, whether through spectral or finite-volume methods, can introduce small errors that violate the conservation of particle number, momentum, and energy over time. This final practice provides a hands-on opportunity to implement a vital correction technique: an orthogonal projection that 'fixes' the collisional source term at each time step, ensuring the discrete conservation laws are satisfied to machine precision.",
            "id": "4180552",
            "problem": "A discrete-velocity simulation seeks to advance a distribution perturbation $h(\\mathbf{v})$ under a linearized collision operator $L$ in a fusion plasma turbulence context. In the continuum, collisional invariants imply that number, momentum, and energy exchanges vanish for the collision operator when integrated against the appropriate invariants. Numerically, a discretized $L$ may not exactly preserve these invariants at each timestep. The goal is to derive from first principles and implement a minimal correction that enforces exact discrete conservation of number, momentum, and energy by projecting $Lh$ onto the null space complement after each timestep on a finite three-dimensional velocity grid.\n\nStart from the kinetic equation with a linearized collisional source $S(\\mathbf{v}) = Lh(\\mathbf{v})$ and the discrete inner product defined on a grid of points $\\mathbf{v}_i = (v_{x,i},v_{y,i},v_{z,i})$ with positive quadrature weights $w_i$. Define the discrete inner product by\n$$\n\\langle a, b \\rangle_W = \\sum_{i=1}^{N} w_i\\, a_i\\, b_i,\n$$\nwhere $a_i = a(\\mathbf{v}_i)$ and $b_i = b(\\mathbf{v}_i)$, and $N$ is the total number of grid points. The collisional invariants are the constant function $\\phi_0(\\mathbf{v}) = 1$, the components of velocity $\\phi_1(\\mathbf{v}) = v_x$, $\\phi_2(\\mathbf{v}) = v_y$, $\\phi_3(\\mathbf{v}) = v_z$, and the kinetic energy-like function $\\phi_4(\\mathbf{v}) = \\lVert \\mathbf{v} \\rVert^2 = v_x^2+v_y^2+v_z^2$. Discrete conservation at a timestep requires that the corrected source $S_\\perp$ satisfies\n$$\n\\langle \\phi_j, S_\\perp \\rangle_W = 0\n\\quad \\text{for} \\quad j \\in \\{0,1,2,3,4\\}.\n$$\nFormulate the correction as the orthogonal projection of $S$ onto the null space complement of the span of $\\{\\phi_0,\\phi_1,\\phi_2,\\phi_3,\\phi_4\\}$ with respect to the inner product $\\langle \\cdot, \\cdot \\rangle_W$, and derive the resulting linear algebraic system that must be solved to compute $S_\\perp$. Then implement this correction and apply it at each timestep so that $h^{n+1} = h^n + \\Delta t\\, S_\\perp$ yields no change in the discrete invariants.\n\nAll quantities in this problem are dimensionless, and no physical units are required. Angles are not used. The program must be self-contained and not read any external input; it should output a single line of results in the specified format.\n\nImplement your program to construct the velocity grid, weights, a test distribution $h$, and an uncorrected source $S$ for each of the following test cases. For uniform grids, weights are equal to the uniform cell volume $\\Delta v_x\\,\\Delta v_y\\,\\Delta v_z$. For nonuniform grids, use one-dimensional arrays of node positions in each direction and approximate the local cell widths by half the distance to the next node plus half the distance to the previous node (with endpoints using half the single adjacent interval). The weight at a node is the product of the three directional cell widths.\n\nTest suite:\n\n- Case $1$ (happy path):\n  - Grid nodes in each direction: $\\{-2,-1,0,1,2\\}$, so $N = 5 \\times 5 \\times 5$.\n  - Timestep: $\\Delta t = 0.1$.\n  - Distribution: $h(\\mathbf{v}) = \\exp(-\\lVert \\mathbf{v} \\rVert^2)$.\n  - Source: $S(\\mathbf{v}) = -\\nu h(\\mathbf{v}) + \\alpha v_x + \\beta \\lVert \\mathbf{v} \\rVert^2 + \\gamma v_x v_y$ with $\\nu = 0.4$, $\\alpha = 0.3$, $\\beta = -0.1$, $\\gamma = 0.05$.\n\n- Case $2$ (boundary case: zero source):\n  - Grid nodes in each direction: $\\{-1,0,1\\}$, so $N = 3 \\times 3 \\times 3$.\n  - Timestep: $\\Delta t = 0.5$.\n  - Distribution: $h(\\mathbf{v}) = \\exp(-\\lVert \\mathbf{v} \\rVert^2)$.\n  - Source: $S(\\mathbf{v}) = 0$.\n\n- Case $3$ (edge case: nonuniform grid and large timestep):\n  - Grid nodes:\n    - $v_x$ nodes: $\\{-3,-1,0,0.5,2\\}$,\n    - $v_y$ nodes: $\\{-2.5,-0.5,0.2,1.7\\}$,\n    - $v_z$ nodes: $\\{-1.5,-0.7,-0.2,0.4,1.4,3.0\\}$,\n    leading to $N = 5 \\times 4 \\times 6$.\n  - Timestep: $\\Delta t = 10.0$.\n  - Distribution: $h(\\mathbf{v}) = \\exp(-\\lVert \\mathbf{v} \\rVert^2)$.\n  - Source: $S(\\mathbf{v}) = a_1 v_x + a_2 v_y + a_3 v_z + a_4 \\lVert \\mathbf{v} \\rVert^2 - a_5 h(\\mathbf{v}) + b_1 v_x v_y + b_2 v_y v_z + b_3 v_x v_z$ with $a_1 = 2.0$, $a_2 = -3.0$, $a_3 = 1.5$, $a_4 = 0.7$, $a_5 = 1.0$, $b_1 = 0.2$, $b_2 = -0.05$, $b_3 = 0.02$.\n\nFor each case:\n- Construct the basis vectors $\\phi_j$ evaluated at all grid points.\n- Compute the corrected source $S_\\perp$ by projecting $S$ onto the null space complement of the span of the $\\phi_j$ with respect to the weight matrix implied by $\\langle \\cdot, \\cdot \\rangle_W$.\n- Compute the invariant residuals $r_j = \\langle \\phi_j, S_\\perp \\rangle_W$ for $j \\in \\{0,1,2,3,4\\}$.\n- Report for the case the single float equal to $\\max_{j} |r_j|$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3]$, where each $r_k$ corresponds to the maximum absolute residual for Case $k$ in the order listed above.",
            "solution": "The problem requires the derivation and implementation of a numerical method to enforce discrete conservation laws for a linearized collision operator in a plasma simulation. The method involves projecting the uncorrected collisional source term, $S(\\mathbf{v})$, onto the orthogonal complement of the subspace spanned by the collisional invariants.\n\nThis problem is set in the context of kinetic theory, where the evolution of a particle distribution function is described. Here, we consider the perturbation to a background distribution, $h(\\mathbf{v})$, and its evolution due to collisions, modeled by a linearized operator $L$. The discrete form of the kinetic equation for a time step $\\Delta t$ is $h^{n+1} = h^n + \\Delta t S$, where $S=Lh$ is the collisional source term.\n\nIn the continuous case, the collision operator conserves particle number, momentum, and energy. This property mathematically translates to the source term being orthogonal to the functions representing these conserved quantities (the collisional invariants). When the problem is discretized onto a finite velocity grid, this conservation property may be lost due to approximation errors. The task is to restore it by applying a minimal correction to the source term $S$ at each step.\n\nThe mathematical framework is a finite-dimensional vector space where functions on the grid are represented as vectors. The space is equipped with a weighted inner product, defined as:\n$$\n\\langle a, b \\rangle_W = \\sum_{i=1}^{N} w_i a(\\mathbf{v}_i) b(\\mathbf{v}_i)\n$$\nwhere $\\mathbf{v}_i$ are the $N$ points of the velocity grid and $w_i > 0$ are corresponding quadrature weights.\n\nThe collisional invariants are given as a set of five functions:\n\\begin{itemize}\n    \\item $\\phi_0(\\mathbf{v}) = 1$ (related to number density)\n    \\item $\\phi_1(\\mathbf{v}) = v_x$, $\\phi_2(\\mathbf{v}) = v_y$, $\\phi_3(\\mathbf{v}) = v_z$ (related to momentum)\n    \\item $\\phi_4(\\mathbf{v}) = \\lVert \\mathbf{v} \\rVert^2 = v_x^2 + v_y^2 + v_z^2$ (related to kinetic energy)\n\\end{itemize}\nThese five functions span a subspace, let us call it $U$, within the vector space of all functions on the grid.\n$$\nU = \\text{span}\\{\\phi_0, \\phi_1, \\phi_2, \\phi_3, \\phi_4\\}\n$$\nThe discrete conservation requirement is that the corrected source term, $S_\\perp$, must be orthogonal to each of these basis functions with respect to the defined inner product:\n$$\n\\langle \\phi_j, S_\\perp \\rangle_W = 0 \\quad \\text{for } j \\in \\{0, 1, 2, 3, 4\\}\n$$\nThis condition implies that $S_\\perp$ must belong to the orthogonal complement of the subspace $U$, denoted $U^\\perp$.\n\nThe problem specifies that $S_\\perp$ should be derived from the uncorrected source $S$ via an orthogonal projection. The unique vector in $U^\\perp$ that is closest to $S$ (in the sense of the norm induced by the inner product) is the orthogonal projection of $S$ onto $U^\\perp$. Any vector $S$ can be uniquely decomposed into a component in $U$ and a component in $U^\\perp$:\n$$\nS = S_\\| + S_\\perp\n$$\nwhere $S_\\| = \\text{proj}_U(S)$ is the projection of $S$ onto $U$, and $S_\\perp = \\text{proj}_{U^\\perp}(S)$ is the projection onto $U^\\perp$. Our desired corrected source is $S_\\perp = S - S_\\|$.\n\nTo find $S_\\|$, we express it as a linear combination of the basis vectors of $U$:\n$$\nS_\\| = \\sum_{k=0}^{4} c_k \\phi_k\n$$\nThe coefficients $c_k$ are determined by the condition that the difference vector $S - S_\\|$ must be orthogonal to the subspace $U$. This is satisfied if the difference vector is orthogonal to every basis vector of $U$:\n$$\n\\langle \\phi_j, S - S_\\| \\rangle_W = 0 \\quad \\text{for } j \\in \\{0, 1, 2, 3, 4\\}\n$$\nUsing the linearity of the inner product, we get:\n$$\n\\langle \\phi_j, S \\rangle_W = \\langle \\phi_j, S_\\| \\rangle_W = \\left\\langle \\phi_j, \\sum_{k=0}^{4} c_k \\phi_k \\right\\rangle_W = \\sum_{k=0}^{4} c_k \\langle \\phi_j, \\phi_k \\rangle_W\n$$\nThis constitutes a system of $5$ linear equations for the $5$ unknown coefficients $c_k$. We can express this in matrix form, $Gc = b$, where:\n- $G$ is the $5 \\times 5$ Gram matrix with elements $G_{jk} = \\langle \\phi_j, \\phi_k \\rangle_W$.\n- $c$ is the column vector of coefficients $[c_0, c_1, c_2, c_3, c_4]^T$.\n- $b$ is a column vector with elements $b_j = \\langle \\phi_j, S \\rangle_W$.\n\nThe steps to implement the solution are:\n1.  **Construct the grid and weights.** For a point $\\mathbf{v}_i = (v_{x,p}, v_{y,q}, v_{z,r})$, the weight is $w_i = \\delta v_{x,p} \\delta v_{y,q} \\delta v_{z,r}$. The one-dimensional cell widths $\\delta v$ are computed based on the distance to adjacent nodes as specified.\n2.  **Represent functions as vectors.** Evaluate the functions $S$ and $\\phi_j$ at each of the $N$ grid points to obtain vectors in $\\mathbb{R}^N$.\n3.  **Assemble and solve the linear system.** Compute the matrix $G$ and vector $b$ using the discrete inner product. Then, solve the linear system $Gc = b$ for the coefficient vector $c$. The Gram matrix $G$ is symmetric and positive-definite (as long as the $\\phi_j$ are linearly independent on the grid), so a unique solution for $c$ exists.\n4.  **Compute the corrected source.** Calculate the projection onto the invariant subspace, $S_\\| = \\sum_{k=0}^4 c_k \\phi_k$. Then obtain the corrected source via subtraction: $S_\\perp = S - S_\\|$.\n5.  **Calculate residuals.** To verify the conservation property, compute the residuals $r_j = \\langle \\phi_j, S_\\perp \\rangle_W$. The final reported value for each case is the maximum absolute residual, $\\max_j |r_j|$. This value quantifies the numerical precision of the conservation enforcement.\nThe time step $\\Delta t$ and the distribution $h^n$ are given for context and to define $S$, but do not directly enter the calculation of the residuals of $S_\\perp$.",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Solves the conservation-fixing problem for three given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"vx_nodes\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0]),\n            \"vy_nodes\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0]),\n            \"vz_nodes\": np.array([-2.0, -1.0, 0.0, 1.0, 2.0]),\n            \"dt\": 0.1,\n            \"h_func\": lambda vx, vy, vz: np.exp(-(vx**2 + vy**2 + vz**2)),\n            \"s_func\": lambda vx, vy, vz, h: (\n                -0.4 * h + 0.3 * vx - 0.1 * (vx**2 + vy**2 + vz**2) + 0.05 * vx * vy\n            ),\n        },\n        # Case 2 (boundary case: zero source)\n        {\n            \"vx_nodes\": np.array([-1.0, 0.0, 1.0]),\n            \"vy_nodes\": np.array([-1.0, 0.0, 1.0]),\n            \"vz_nodes\": np.array([-1.0, 0.0, 1.0]),\n            \"dt\": 0.5,\n            \"h_func\": lambda vx, vy, vz: np.exp(-(vx**2 + vy**2 + vz**2)),\n            \"s_func\": lambda vx, vy, vz, h: 0.0,\n        },\n        # Case 3 (edge case: nonuniform grid and large timestep)\n        {\n            \"vx_nodes\": np.array([-3.0, -1.0, 0.0, 0.5, 2.0]),\n            \"vy_nodes\": np.array([-2.5, -0.5, 0.2, 1.7]),\n            \"vz_nodes\": np.array([-1.5, -0.7, -0.2, 0.4, 1.4, 3.0]),\n            \"dt\": 10.0,\n            \"h_func\": lambda vx, vy, vz: np.exp(-(vx**2 + vy**2 + vz**2)),\n            \"s_func\": lambda vx, vy, vz, h: (\n                2.0 * vx - 3.0 * vy + 1.5 * vz + 0.7 * (vx**2 + vy**2 + vz**2) \n                - 1.0 * h + 0.2 * vx * vy - 0.05 * vy * vz + 0.02 * vx * vz\n            ),\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        vx_nodes, vy_nodes, vz_nodes = case[\"vx_nodes\"], case[\"vy_nodes\"], case[\"vz_nodes\"]\n\n        # 1. Construct the grid and weights\n        def get_weights_1d(nodes):\n            if len(nodes)  2:\n                # For a single point, the concept of a cell width is ill-defined.\n                # However, the problem implies grids with at least 3 points.\n                # For robustness, we handle this.\n                return np.ones_like(nodes) if len(nodes) == 1 else np.array([])\n            \n            dv = np.zeros_like(nodes, dtype=float)\n            dv[0] = (nodes[1] - nodes[0]) / 2.0\n            dv[-1] = (nodes[-1] - nodes[-2]) / 2.0\n            dv[1:-1] = (nodes[2:] - nodes[:-2]) / 2.0\n            return dv\n\n        dvx = get_weights_1d(vx_nodes)\n        dvy = get_weights_1d(vy_nodes)\n        dvz = get_weights_1d(vz_nodes)\n\n        # Create 3D grid and weights\n        vx, vy, vz = np.meshgrid(vx_nodes, vy_nodes, vz_nodes, indexing='ij')\n        weights_3d = np.einsum('i,j,k->ijk', dvx, dvy, dvz)\n        \n        # Flatten all arrays\n        N = vx.size\n        vx_flat = vx.flatten()\n        vy_flat = vy.flatten()\n        vz_flat = vz.flatten()\n        w_flat = weights_3d.flatten()\n\n        # 2. Evaluate functions on the grid\n        h = case[\"h_func\"](vx_flat, vy_flat, vz_flat)\n        s_uncorrected = case[\"s_func\"](vx_flat, vy_flat, vz_flat, h)\n\n        # Define invariant basis functions\n        phi_0 = np.ones(N)\n        phi_1 = vx_flat\n        phi_2 = vy_flat\n        phi_3 = vz_flat\n        phi_4 = vx_flat**2 + vy_flat**2 + vz_flat**2\n        phis = [phi_0, phi_1, phi_2, phi_3, phi_4]\n        \n        # 3. Assemble and solve the linear system\n        num_invariants = len(phis)\n        gram_matrix = np.zeros((num_invariants, num_invariants))\n        b_vector = np.zeros(num_invariants)\n\n        w_s = w_flat * s_uncorrected\n        for j in range(num_invariants):\n            b_vector[j] = np.sum(phis[j] * w_s)\n            for k in range(j, num_invariants):\n                val = np.sum(phis[j] * w_flat * phis[k])\n                gram_matrix[j, k] = val\n                gram_matrix[k, j] = val\n\n        coeffs = linalg.solve(gram_matrix, b_vector, assume_a='sym')\n\n        # 4. Compute the corrected source\n        s_parallel = np.zeros(N)\n        for k in range(num_invariants):\n            s_parallel += coeffs[k] * phis[k]\n        \n        s_perp = s_uncorrected - s_parallel\n\n        # 5. Calculate residuals\n        residuals = []\n        w_s_perp = w_flat * s_perp\n        for j in range(num_invariants):\n            residual = np.sum(phis[j] * w_s_perp)\n            residuals.append(residual)\n        \n        max_abs_residual = np.max(np.abs(residuals))\n        results.append(max_abs_residual)\n\n    # Format the final output\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}