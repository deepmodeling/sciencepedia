{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of any valid physical model is its adherence to fundamental conservation laws. This first practice focuses on numerically verifying that the Fokker-Planck operator correctly models the exchange of momentum between two interacting particle species. By implementing a numerical scheme to compute the collisional momentum exchange rate, you will confirm that the momentum gained by one species is precisely equal and opposite to the momentum lost by the other, a manifestation of Newton's third law in a kinetic context. ",
            "id": "4202948",
            "problem": "You are asked to verify the cross-species momentum conservation property of the Fokker-Planck (FP) collision operator in a two-species plasma, by constructing a numerical approximation on a discretized three dimensional (3D) velocity space and checking, for several parameter sets, that the total momentum exchange between species is equal and opposite to numerical precision. The governing kinetic equation is the Boltzmann equation with a binary FP collision operator between species, and the test must be performed without assuming any special symmetry beyond the specified parameter values.\n\nBegin from the following foundational bases: the definition of a distribution function in velocity space, the conservation laws for mass, momentum, and energy in collisions, and the standard kinetic theory form of the FP operator as a divergence in velocity space of a friction-diffusion flux. For species $a$ and $b$, with masses $m_a$ and $m_b$, number densities $n_a$ and $n_b$, mean flows $\\mathbf{u}_a$ and $\\mathbf{u}_b$, and thermal energies per particle $\\Theta_a$ and $\\Theta_b$ (equal to Boltzmann constant times temperature), consider distributions $f_a(\\mathbf{v})$ and $f_b(\\mathbf{v})$ defined as shifted Maxwellians:\n$$\nf_s(\\mathbf{v}) = \\frac{n_s}{\\pi^{3/2} v_{\\mathrm{th},s}^3} \\exp\\!\\left(-\\frac{\\left\\|\\mathbf{v} - \\mathbf{u}_s\\right\\|^2}{v_{\\mathrm{th},s}^2}\\right), \\quad v_{\\mathrm{th},s} = \\sqrt{\\frac{2 \\Theta_s}{m_s}}, \\quad s \\in \\{a,b\\}.\n$$\nModel the binary FP collision operator $C_{ab}[f_a,f_b]$ with an isotropic drag-diffusion flux consistent with the Landau operator invariants:\n$$\nC_{ab}[f_a,f_b](\\mathbf{v}) = \\nabla_{\\mathbf{v}} \\cdot \\left( \\nu_{ab} \\left[ \\left(\\mathbf{v} - \\mathbf{u}_b \\right) f_a(\\mathbf{v}) + v_{\\mathrm{th},b}^2 \\nabla_{\\mathbf{v}} f_a(\\mathbf{v}) \\right] \\right),\n$$\nand analogously for $C_{ba}[f_b,f_a]$ with parameters interchanged and a collision frequency $\\nu_{ba}$. The above form, with appropriate symmetry between $\\nu_{ab}$ and $\\nu_{ba}$, is widely used as a reduced FP operator that preserves collisional invariants for Maxwellian backgrounds.\n\nYour task is to implement a numerical solver that:\n- Constructs a uniform Cartesian grid in velocity space with $N$ points per dimension over a cube $[-v_{\\max}, v_{\\max}]^3$ where\n$$\nv_{\\max} = \\max\\left(\\left\\|\\mathbf{u}_a\\right\\|, \\left\\|\\mathbf{u}_b\\right\\|\\right) + 6 \\cdot \\max\\left(v_{\\mathrm{th},a}, v_{\\mathrm{th},b}\\right).\n$$\n- Evaluates $f_a(\\mathbf{v})$ and $f_b(\\mathbf{v})$ on this grid.\n- Approximates $\\nabla_{\\mathbf{v}} f_s$ by finite differences, assembles the flux for $C_{ab}$ and $C_{ba}$, and computes the divergence by finite differences, imposing an effective zero-flux boundary at the edges of the velocity domain by assuming the flux vanishes outside the computational domain.\n- Numerically computes the momentum exchange vectors\n$$\n\\mathbf{R}_{ab} = \\int m_a \\mathbf{v}\\, C_{ab}[f_a,f_b](\\mathbf{v})\\, d^3v, \\quad \\mathbf{R}_{ba} = \\int m_b \\mathbf{v}\\, C_{ba}[f_b,f_a](\\mathbf{v})\\, d^3v,\n$$\nvia Riemann sums on the grid, and checks whether $\\mathbf{R}_{ab} + \\mathbf{R}_{ba}$ is sufficiently close to the zero vector.\n\nUse the symmetry condition\n$$\n\\nu_{ba} = \\nu_{ab}\\, \\frac{m_a n_a}{m_b n_b},\n$$\nwhich enforces the momentum conservation property expected from the FP operator moment equations. All quantities must be in the International System of Units (SI): masses in kilograms, number densities in $\\mathrm{m}^{-3}$, velocities in $\\mathrm{m/s}$, collision frequencies in $\\mathrm{s}^{-1}$, and thermal energies per particle $\\Theta_s$ in Joules. Angles do not appear. The program should report boolean values, one per test case, indicating whether the numerical check passes.\n\nFor numerical precision, use at least $N = 31$ points per dimension and a relative tolerance of $10^{-2}$ together with an absolute tolerance of $10^{-8}$ on the norm of $\\mathbf{R}_{ab} + \\mathbf{R}_{ba}$, normalized by the larger of $\\|\\mathbf{R}_{ab}\\|$ and $\\|\\mathbf{R}_{ba}\\|$ to guard against near-zero denominators.\n\nTest suite. Implement the following four test cases, using the above symmetry to set $\\nu_{ba}$ wherever not explicitly stated:\n- Case $1$ (electron-ion, unequal flows): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 1.0 \\times 10^{19}$, $\\Theta_a = 2000$ electronvolts, $\\mathbf{u}_a = (10^4, 0, 0)$; $m_b = 9.1093837015 \\times 10^{-31}$, $n_b = 1.0 \\times 10^{19}$, $\\Theta_b = 2000$ electronvolts, $\\mathbf{u}_b = (0, 0, 0)$; $\\nu_{ab} = 5.0 \\times 10^{5}$.\n- Case $2$ (identical species, opposite flows): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 2.0 \\times 10^{19}$, $\\Theta_a = 500$ electronvolts, $\\mathbf{u}_a = (0, 10^3, 0)$; $m_b = 1.67262192369 \\times 10^{-27}$, $n_b = 2.0 \\times 10^{19}$, $\\Theta_b = 800$ electronvolts, $\\mathbf{u}_b = (0, -10^3, 0)$; $\\nu_{ab} = 1.0 \\times 10^{4}$ and $\\nu_{ba} = \\nu_{ab}$.\n- Case $3$ (zero relative flow): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 1.0 \\times 10^{19}$, $\\Theta_a = 3000$ electronvolts, $\\mathbf{u}_a = (0, 0, 0)$; $m_b = 9.1093837015 \\times 10^{-31}$, $n_b = 1.0 \\times 10^{19}$, $\\Theta_b = 3000$ electronvolts, $\\mathbf{u}_b = (0, 0, 0)$; $\\nu_{ab} = 1.0 \\times 10^{6}$.\n- Case $4$ (weak collisions, unequal densities and flows): $m_a = 1.67262192369 \\times 10^{-27}$, $n_a = 5.0 \\times 10^{19}$, $\\Theta_a = 400$ electronvolts, $\\mathbf{u}_a = (2000, 3000, -1000)$; $m_b = 9.1093837015 \\times 10^{-31}$, $n_b = 1.0 \\times 10^{19}$, $\\Theta_b = 1000$ electronvolts, $\\mathbf{u}_b = (-500, 0, 500)$; $\\nu_{ab} = 1.0$.\n\nElectronvolts must be converted to Joules using $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$ so that $\\Theta_s$ is used in Joules. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[ \\text{True}, \\text{False}, \\dots ]$), in the exact order of the above four cases.",
            "solution": "The problem requires a numerical verification of the momentum conservation property for a simplified Fokker-Planck (FP) collision operator in a two-species plasma. The core of this task is to compute the total rate of momentum change due to collisions and check if it sums to zero, as dictated by fundamental physical principles. Momentum conservation in a closed system of two interacting species, $a$ and $b$, requires that the momentum gained by species $a$ from $b$ is equal and opposite to the momentum gained by species $b$ from $a$. This is expressed as $\\mathbf{R}_{ab} + \\mathbf{R}_{ba} = \\mathbf{0}$, where $\\mathbf{R}_{st}$ is the rate of momentum transfer to species $s$ from species $t$.\n\nThe problem provides the necessary theoretical framework. The species are described by distribution functions $f_s(\\mathbf{v})$ in $3$D velocity space, specifically as shifted Maxwellians:\n$$\nf_s(\\mathbf{v}) = \\frac{n_s}{\\pi^{3/2} v_{\\mathrm{th},s}^3} \\exp\\!\\left(-\\frac{\\left\\|\\mathbf{v} - \\mathbf{u}_s\\right\\|^2}{v_{\\mathrm{th},s}^2}\\right)\n$$\nwhere $s \\in \\{a,b\\}$, $n_s$ is the number density, $\\mathbf{u}_s$ is the mean flow velocity, and $v_{\\mathrm{th},s} = \\sqrt{2 \\Theta_s / m_s}$ is the thermal velocity associated with mass $m_s$ and thermal energy per particle $\\Theta_s$.\n\nThe interaction is modeled by a simplified FP collision operator, $C_{ab}[f_a, f_b]$, which describes the effect of collisions with species $b$ on the distribution function $f_a$. The operator is given in divergence form, $C_{ab} = \\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}$, where the flux $\\mathbf{J}_{ab}$ in velocity space is:\n$$\n\\mathbf{J}_{ab}(\\mathbf{v}) = \\nu_{ab} \\left[ \\left(\\mathbf{v} - \\mathbf{u}_b \\right) f_a(\\mathbf{v}) + v_{\\mathrm{th},b}^2 \\nabla_{\\mathbf{v}} f_a(\\mathbf{v}) \\right]\n$$\nThis form includes a drag term proportional to $(\\mathbf{v} - \\mathbf{u}_b)$ and a diffusion term proportional to $\\nabla_{\\mathbf{v}} f_a$. The term $C_{ba}$ is defined analogously by swapping the species indices.\n\nThe momentum exchange rate, $\\mathbf{R}_{ab}$, is the first velocity moment of the collision operator:\n$$\n\\mathbf{R}_{ab} = \\int m_a \\mathbf{v}\\, C_{ab}[f_a,f_b](\\mathbf{v})\\, d^3v = \\int m_a \\mathbf{v} \\left( \\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}(\\mathbf{v}) \\right) d^3v\n$$\nA direct numerical evaluation would involve computing second derivatives of $f_a$ (since $\\mathbf{J}_{ab}$ contains $\\nabla_{\\mathbf{v}} f_a$), which is numerically prone to error. A more robust and elegant method, common in kinetic theory, is to use integration by parts (or the divergence theorem in $3$D). Assuming the flux $\\mathbf{J}_{ab}$ vanishes at the boundaries of the integration domain (a condition enforced by the problem's setup and the rapid decay of the Maxwellian distributions), the integral simplifies significantly. For each component $i \\in \\{x, y, z\\}$:\n$$\n\\int v_i (\\nabla_{\\mathbf{v}} \\cdot \\mathbf{J}_{ab}) d^3v = - \\int J_{ab,i} d^3v\n$$\nThis leads to a much more stable expression for the momentum exchange rate, involving only first derivatives of $f_a$:\n$$\n\\mathbf{R}_{ab} = -m_a \\int \\mathbf{J}_{ab}(\\mathbf{v})\\, d^3v\n$$\nThis approach will be used in our numerical implementation. Analytically, using this form and properties of the Maxwellian distribution, one can show that $\\mathbf{R}_{ab} = -m_a n_a \\nu_{ab}(\\mathbf{u}_a - \\mathbf{u}_b)$. For momentum to be conserved, $\\mathbf{R}_{ab} + \\mathbf{R}_{ba} = \\mathbf{0}$, we must have $m_a n_a \\nu_{ab} = m_b n_b \\nu_{ba}$, which is precisely the symmetry condition $\\nu_{ba} = \\nu_{ab} (m_a n_a / m_b n_b)$ provided in the problem. Our task is to verify that a numerical implementation based on this framework satisfies this conservation law to a given tolerance.\n\nThe numerical procedure is as follows:\n$1$. For each test case, we first establish the physical parameters for species $a$ and $b$, converting thermal energies from electronvolts (eV) to Joules using the conversion $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$.\n$2$. A $3$D Cartesian velocity grid is constructed. The grid spans $[-v_{\\max}, v_{\\max}]^3$ with $N=31$ points along each axis. The domain size $v_{\\max}$ is chosen to be sufficiently large to contain the bulk of both distribution functions: $v_{\\max} = \\max(\\|\\mathbf{u}_a\\|, \\|\\mathbf{u}_b\\|) + 6 \\cdot \\max(v_{\\mathrm{th},a}, v_{\\mathrm{th},b})$. The grid spacing is $dv = 2 v_{\\max} / (N-1)$ and the volume element for integration is $d^3v = (dv)^3$.\n$3$. The distribution functions $f_a(\\mathbf{v})$ and $f_b(\\mathbf{v})$ are evaluated at each point on this $3$D grid.\n$4$. For each species pair $(a,b)$ and $(b,a)$, we compute the respective momentum exchange rate vectors $\\mathbf{R}_{ab}$ and $\\mathbf{R}_{ba}$. This involves:\n    a. Calculating the velocity-space gradient $\\nabla_{\\mathbf{v}} f_s$ using a second-order central finite difference scheme, provided by `numpy.gradient`.\n    b. Assembling the components of the flux vector, e.g., $\\mathbf{J}_{ab}$, using the gradients from the previous step.\n    c. Integrating the flux vector over the entire velocity domain using a Riemann sum ($\\mathbf{R}_{ab} = -m_a \\sum \\mathbf{J}_{ab} \\,d^3v$) to obtain the momentum exchange vector.\n$5$. The total momentum exchange $\\mathbf{R}_{\\text{total}} = \\mathbf{R}_{ab} + \\mathbf{R}_{ba}$ is computed.\n$6$. The validation check is performed. The property is considered numerically verified if the norm of the total momentum exchange, $\\|\\mathbf{R}_{\\text{total}}\\|$, satisfies the condition: $\\|\\mathbf{R}_{\\text{total}}\\| \\le 10^{-8}$ (absolute tolerance) OR $\\|\\mathbf{R}_{\\text{total}}\\| / \\max(\\|\\mathbf{R}_{ab}\\|, \\|\\mathbf{R}_{ba}\\|) \\le 10^{-2}$ (relative tolerance). This dual condition appropriately handles cases where the expected exchange is near zero.\n$7$. The boolean result of this check (True or False) is recorded for each of the $4$ test cases. The final output is a list of these boolean values.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Fokker-Planck momentum conservation test.\n    \"\"\"\n    \n    # Physical constants\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs, for eV to J conversion\n\n    def calculate_f(n, m, Theta, u, vx, vy, vz):\n        \"\"\"\n        Evaluates the shifted Maxwellian distribution function on the grid.\n        \"\"\"\n        if m <= 0 or Theta <= 0:\n            return np.zeros_like(vx)\n            \n        v_th = np.sqrt(2 * Theta / m)\n        norm_factor = n / (np.pi**1.5 * v_th**3)\n        v_minus_u_sq = (vx - u[0])**2 + (vy - u[1])**2 + (vz - u[2])**2\n        \n        exponent = -v_minus_u_sq / v_th**2\n        # Use a cutoff for exponent to prevent underflow issues leading to NaNs in gradients\n        f = norm_factor * np.exp(np.maximum(exponent, -100.0))\n        return f\n\n    def calculate_R(mass_A, f_A, dv, vx, vy, vz, params_B, nu_AB):\n        \"\"\"\n        Calculates the momentum exchange vector R_AB using integration by parts.\n        R_AB = -m_A * integral(J_AB d^3v)\n        \"\"\"\n        m_B, n_B, Theta_B, u_B = params_B\n        v_th_B = np.sqrt(2 * Theta_B / m_B) if m_B > 0 and Theta_B > 0 else 0.0\n        \n        # Calculate gradient of f_A using finite differences\n        grad_fA_list = np.gradient(f_A, dv, axis=(0, 1, 2))\n        grad_vx_fA, grad_vy_fA, grad_vz_fA = grad_fA_list[0], grad_fA_list[1], grad_fA_list[2]\n\n        # Assemble the flux vector J_AB\n        # J_AB = nu_AB * [ (v - u_B) * f_A + v_th_B^2 * grad_v(f_A) ]\n        Jx = nu_AB * ((vx - u_B[0]) * f_A + v_th_B**2 * grad_vx_fA)\n        Jy = nu_AB * ((vy - u_B[1]) * f_A + v_th_B**2 * grad_vy_fA)\n        Jz = nu_AB * ((vz - u_B[2]) * f_A + v_th_B**2 * grad_vz_fA)\n        \n        # Integrate flux components over the velocity domain using Riemann sum\n        d3v = dv**3\n        int_Jx = np.sum(Jx) * d3v\n        int_Jy = np.sum(Jy) * d3v\n        int_Jz = np.sum(Jz) * d3v\n        \n        # R_AB = -m_A * integral(J d3v)\n        R_vec = -mass_A * np.array([int_Jx, int_Jy, int_Jz])\n        \n        return R_vec\n\n    # Grid and tolerance parameters\n    N = 31\n    REL_TOL = 1e-2\n    ABS_TOL = 1e-8\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: electron-ion, unequal flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 1.0e19, 'Theta_eV': 2000, 'u': np.array([1e4, 0, 0])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 2000, 'u': np.array([0, 0, 0])},\n            'nu_ab': 5.0e5\n        },\n        # Case 2: identical species, opposite flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 2.0e19, 'Theta_eV': 500, 'u': np.array([0, 1e3, 0])},\n            'b': {'m': 1.67262192369e-27, 'n': 2.0e19, 'Theta_eV': 800, 'u': np.array([0, -1e3, 0])},\n            'nu_ab': 1.0e4\n        },\n        # Case 3: zero relative flow\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 1.0e19, 'Theta_eV': 3000, 'u': np.array([0, 0, 0])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 3000, 'u': np.array([0, 0, 0])},\n            'nu_ab': 1.0e6\n        },\n        # Case 4: weak collisions, unequal densities and flows\n        {\n            'a': {'m': 1.67262192369e-27, 'n': 5.0e19, 'Theta_eV': 400, 'u': np.array([2000, 3000, -1000])},\n            'b': {'m': 9.1093837015e-31, 'n': 1.0e19, 'Theta_eV': 1000, 'u': np.array([-500, 0, 500])},\n            'nu_ab': 1.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack and prepare parameters for species a and b\n        m_a, n_a, Theta_a_eV, u_a = case['a']['m'], case['a']['n'], case['a']['Theta_eV'], case['a']['u']\n        m_b, n_b, Theta_b_eV, u_b = case['b']['m'], case['b']['n'], case['b']['Theta_eV'], case['b']['u']\n        \n        Theta_a = Theta_a_eV * E_CHARGE\n        Theta_b = Theta_b_eV * E_CHARGE\n\n        params_a = (m_a, n_a, Theta_a, u_a)\n        params_b = (m_b, n_b, Theta_b, u_b)\n        \n        v_th_a = np.sqrt(2 * Theta_a / m_a)\n        v_th_b = np.sqrt(2 * Theta_b / m_b)\n        \n        nu_ab = case['nu_ab']\n        # Use symmetry condition unless m_b or n_b is zero\n        if m_b * n_b > 0:\n            nu_ba = nu_ab * (m_a * n_a) / (m_b * n_b)\n        else:\n            nu_ba = 0\n\n        # Set up velocity grid\n        v_max = max(np.linalg.norm(u_a), np.linalg.norm(u_b)) + 6 * max(v_th_a, v_th_b)\n        v_coords = np.linspace(-v_max, v_max, N)\n        dv = v_coords[1] - v_coords[0]\n        vx, vy, vz = np.meshgrid(v_coords, v_coords, v_coords, indexing='ij')\n\n        # Evaluate distribution functions on the grid\n        f_a = calculate_f(n_a, m_a, Theta_a, u_a, vx, vy, vz)\n        f_b = calculate_f(n_b, m_b, Theta_b, u_b, vx, vy, vz)\n\n        # Calculate momentum exchange vectors\n        R_ab = calculate_R(m_a, f_a, dv, vx, vy, vz, params_b, nu_ab)\n        R_ba = calculate_R(m_b, f_b, dv, vx, vy, vz, params_a, nu_ba)\n\n        # Check for momentum conservation\n        R_total = R_ab + R_ba\n        norm_total = np.linalg.norm(R_total)\n        norm_ab = np.linalg.norm(R_ab)\n        norm_ba = np.linalg.norm(R_ba)\n\n        denominator = max(norm_ab, norm_ba)\n        \n        # Check if the result is below absolute or relative tolerance\n        if denominator < 1e-15: # Effectively zero, use only absolute tolerance\n            check_passed = norm_total <= ABS_TOL\n        else:\n            check_passed = (norm_total <= ABS_TOL) or (norm_total / denominator <= REL_TOL)\n            \n        results.append(check_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The Fokker-Planck operator describes the process by which a particle distribution relaxes towards a thermal equilibrium, characterized by a Maxwellian distribution. It follows that the Maxwellian itself must be a stationary solution for the operator. This exercise challenges you to verify this fundamental 'null-space' property, demonstrating numerically that the collision operator produces zero change when acting on a Maxwellian distribution, a critical verification test for any kinetic simulation code. ",
            "id": "4202978",
            "problem": "Consider a single-species, electrostatic, homogeneous gyrokinetic verification in which the nonadiabatic distribution function is initialized as $h(\\mathbf{v}) = \\alpha M(\\mathbf{v})$, where $M(\\mathbf{v})$ is an isotropic Maxwellian, $\\alpha$ is a constant amplitude, and $\\mathbf{v}$ is the particle velocity. The goal is to test the null-space property of the Fokker-Planck collision operator acting on a Maxwellian-proportional perturbation in the gyrokinetic context. In a correct linearization around an isotropic Maxwellian, collisions must produce zero response for perturbations proportional to the Maxwellian because collisional invariants and the equilibrium structure are preserved by the operator.\n\nStart from the following foundational bases:\n- The kinetic equation is governed by the Fokker-Planck collision operator, which conserves collisional invariants (mass, momentum, and energy) and admits a Maxwellian equilibrium. In particular, any linearized operator constructed to preserve these invariants has a null space spanned by $M$, $\\mathbf{v}M$, and $v^{2}M$.\n- In the gyrokinetic formalism, the nonadiabatic part $h$ of the distribution function enters the collision term linearly; for a homogeneous, isotropic equilibrium, a perturbation $h(\\mathbf{v})$ that is proportional to $M(\\mathbf{v})$ lies in the null space of the linearized collision operator.\n\nTo make the problem numerically well-posed and testable, approximate the Fokker-Planck collision operator with an isotropic drag-diffusion operator in velocity space that exactly admits the Maxwellian $M(\\mathbf{v})$ as a stationary solution. Let the species have mass $m$ and temperature $T$; define the thermal speed as $v_{\\mathrm{th}} = \\sqrt{2T/m}$ in $\\mathrm{m/s}$, where $T$ is expressed in joules. Use the operator\n$$\nC[f] = \\nu \\, \\nabla_{\\mathbf{v}} \\cdot \\left( \\mathbf{v} f + \\frac{v_{\\mathrm{th}}^{2}}{2} \\nabla_{\\mathbf{v}} f \\right),\n$$\nwhere $\\nu$ is a constant collision frequency in $\\mathrm{s}^{-1}$. In spherical velocity coordinates with isotropy ($f=f(v)$), this reduces to\n$$\nC[f](v) = \\nu \\, \\frac{1}{v^{2}}\\frac{\\partial}{\\partial v} \\left[ v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2}\\frac{\\partial f}{\\partial v} \\right) \\right].\n$$\nBecause the flux inside the radial divergence vanishes for $f=M$, the continuous operator satisfies $C[M]=0$, and by linearity $C[\\alpha M]=0$ for any constant $\\alpha$.\n\nImplement a finite-difference discretization on a one-dimensional speed grid $v \\in [0, v_{\\max}]$ with $N_{v}$ uniformly spaced points. Use a second-order accurate stencil for $\\partial f/\\partial v$ in the interior, and consistent one-sided stencils at the boundaries. At $v=0$, impose symmetry via $\\partial f/\\partial v|_{v=0} = 0$. Construct the discrete flux\n$$\nS(v) = v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2} \\frac{\\partial f}{\\partial v} \\right),\n$$\nand the discrete operator\n$$\nC[f](v) \\approx \\nu \\, \\frac{1}{v^{2}} \\frac{\\partial S}{\\partial v}.\n$$\nInitialize $h(v) = \\alpha M(v)$ with the isotropic Maxwellian\n$$\nM(v) = \\frac{n_{0}}{\\left(\\pi v_{\\mathrm{th}}^{2}\\right)^{3/2}} \\exp\\left(-\\frac{v^{2}}{v_{\\mathrm{th}}^{2}}\\right),\n$$\nwhere $n_{0}$ is the equilibrium density in $\\mathrm{m}^{-3}$. Compute the maximum norm of the discrete $C[h]$, normalize it by $\\nu$ times the maximum norm of $h$, and compare to a prescribed tolerance $\\epsilon$:\n$$\nR = \\frac{\\max_{v} \\left| C[h](v) \\right|}{\\nu \\, \\max_{v} \\left| h(v) \\right|}.\n$$\nThe verification passes if $R < \\epsilon$, yielding a boolean result for each test case.\n\nPhysical units must be consistent: use mass $m$ in kilograms, temperature $T$ in electron-volts converted to joules via $1\\,\\mathrm{eV} = 1.602176634 \\times 10^{-19}\\,\\mathrm{J}$, velocity in meters per second, density $n_{0}$ in inverse cubic meters, collision frequency $\\nu$ in inverse seconds, and $v_{\\max}$ in meters per second. Angles do not appear explicitly in this isotropic test, so no angle unit is required.\n\nTest Suite (each tuple lists $(m, T_{\\mathrm{eV}}, n_{0}, \\nu, N_{v}, \\lambda, \\alpha, \\epsilon)$, where $v_{\\max} = \\lambda \\, v_{\\mathrm{th}}$):\n- Case $1$ (general happy path): $(3.343583719 \\times 10^{-27}\\,\\mathrm{kg}, 2.0 \\times 10^{3}\\,\\mathrm{eV}, 1.0 \\times 10^{19}\\,\\mathrm{m}^{-3}, 1.0 \\times 10^{5}\\,\\mathrm{s}^{-1}, 400, 5.0, 0.5, 1.0 \\times 10^{-3})$.\n- Case $2$ (coarse grid boundary test): $(3.343583719 \\times 10^{-27}\\,\\mathrm{kg}, 2.0 \\times 10^{3}\\,\\mathrm{eV}, 1.0 \\times 10^{19}\\,\\mathrm{m}^{-3}, 1.0 \\times 10^{5}\\,\\mathrm{s}^{-1}, 40, 6.0, 0.5, 2.0 \\times 10^{-2})$.\n- Case $3$ (zero amplitude edge case): $(3.343583719 \\times 10^{-27}\\,\\mathrm{kg}, 1.0 \\times 10^{3}\\,\\mathrm{eV}, 5.0 \\times 10^{18}\\,\\mathrm{m}^{-3}, 3.0 \\times 10^{4}\\,\\mathrm{s}^{-1}, 60, 4.0, 0.0, 1.0 \\times 10^{-10})$.\n\nYour program must:\n- Implement the described discretization in $\\mathrm{m/s}$ for velocity and compute $R$ for each case.\n- Produce booleans indicating whether $R<\\epsilon$ for each case.\n- Output a single line containing the results as a comma-separated list enclosed in square brackets, for example $[{\\mathrm{True}},{\\mathrm{False}},{\\mathrm{True}}]$.",
            "solution": "The problem poses a verification test for a numerical implementation of a Fokker-Planck-like collision operator. The fundamental principle to be verified is that the operator, by construction, has a null space that includes any function proportional to a Maxwellian distribution. This property must hold because the collision operator conserves particle number, momentum, and energy, and drives the system towards a Maxwellian equilibrium. A perturbation that is simply a rescaling of the equilibrium distribution, $h(\\mathbf{v}) = \\alpha M(\\mathbf{v})$, must therefore produce no collisional effect, i.e., $C[h] = 0$. This verification is a critical sanity check in the development of any kinetic simulation code.\n\nThe problem provides a simplified one-dimensional isotropic drag-diffusion operator acting on a distribution function $f(v)$, where $v$ is the particle speed:\n$$\nC[f](v) = \\nu \\, \\frac{1}{v^{2}}\\frac{\\partial}{\\partial v} \\left[ v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2}\\frac{\\partial f}{\\partial v} \\right) \\right]\n$$\nHere, $\\nu$ is the collision frequency and $v_{\\mathrm{th}} = \\sqrt{2T/m}$ is the thermal speed, with $m$ being the particle mass and $T$ its temperature in joules. The term in the outer brackets is the flux in velocity space, which we denote as $S(v)$:\n$$\nS(v) = v^{2} \\left( v f(v) + \\frac{v_{\\mathrm{th}}^{2}}{2}\\frac{\\partial f}{\\partial v} \\right)\n$$\nThe problem requires a numerical solution on a uniform grid in speed $v$. We will construct a discrete representation of the operator $C[h]$ and evaluate its magnitude.\n\nFirst, we establish the discrete velocity grid. For a maximum speed $v_{\\max}$ and $N_{v}$ grid points, the grid is defined as $v_i = i \\Delta v$ for $i = 0, 1, \\dots, N_{v}-1$, where the grid spacing is $\\Delta v = v_{\\max} / (N_v - 1)$. The function to be tested is $h(v_i) = \\alpha M(v_i)$, where $M(v_i)$ is the discrete Maxwellian distribution:\n$$\nM(v_i) = \\frac{n_{0}}{\\left(\\pi v_{\\mathrm{th}}^{2}\\right)^{3/2}} \\exp\\left(-\\frac{v_i^{2}}{v_{\\mathrm{th}}^{2}}\\right)\n$$\nwith $n_0$ being the particle density.\n\nThe numerical implementation of the operator $C[h]$ proceeds in steps:\n\n1.  **Discretize the derivative $\\partial h/\\partial v$**: We use finite differences to approximate the derivative of the function $h$ at each grid point $v_i$. Let $h_i = h(v_i)$ and $(\\partial h/\\partial v)_i$ be its discrete derivative.\n    -   At the boundary $v_0=0$, the symmetry condition dictates $(\\partial h/\\partial v)_0 = 0$.\n    -   For interior points $i \\in [1, N_v-2]$, a second-order central difference is employed for accuracy:\n        $$ \\left(\\frac{\\partial h}{\\partial v}\\right)_i = \\frac{h_{i+1} - h_{i-1}}{2\\Delta v} $$\n    -   At the outer boundary $v_{N_v-1}$, a second-order backward difference stencil is used to maintain accuracy:\n        $$ \\left(\\frac{\\partial h}{\\partial v}\\right)_{N_v-1} = \\frac{3h_{N_v-1} - 4h_{N_v-2} + h_{N_v-3}}{2\\Delta v} $$\n\n2.  **Compute the discrete flux $S_i$**: With the discrete function $h_i$ and its derivative $(\\partial h/\\partial v)_i$, we compute the flux $S_i = S(v_i)$ at each grid point:\n    $$ S_i = v_i^2 \\left( v_i h_i + \\frac{v_{\\mathrm{th}}^2}{2} \\left(\\frac{\\partial h}{\\partial v}\\right)_i \\right) $$\n    Note that at $i=0$, $v_0=0$, so $S_0=0$.\n\n3.  **Discretize the flux derivative $\\partial S/\\partial v$**: We apply the same finite difference scheme to the newly computed flux array $S_i$. Let $(\\partial S/\\partial v)_i$ be the discrete derivative.\n    -   At the boundary $v_0=0$, we use a second-order forward difference stencil. Since $S_0=0$, it simplifies:\n        $$ \\left(\\frac{\\partial S}{\\partial v}\\right)_0 = \\frac{-3S_0 + 4S_1 - S_2}{2\\Delta v} = \\frac{4S_1 - S_2}{2\\Delta v} $$\n    -   For interior points $i \\in [1, N_v-2]$, we again use the central difference:\n        $$ \\left(\\frac{\\partial S}{\\partial v}\\right)_i = \\frac{S_{i+1} - S_{i-1}}{2\\Delta v} $$\n    -   At the outer boundary $v_{N_v-1}$, we use the backward difference:\n        $$ \\left(\\frac{\\partial S}{\\partial v}\\right)_{N_v-1} = \\frac{3S_{N_v-1} - 4S_{N_v-2} + S_{N_v-3}}{2\\Delta v} $$\n\n4.  **Compute the discrete operator $C[h]_i$**: The final step is to assemble the operator.\n    -   For $i > 0$, the operator is computed directly from its definition:\n        $$ C[h]_i = \\nu \\frac{1}{v_i^2} \\left(\\frac{\\partial S}{\\partial v}\\right)_i $$\n    -   At $v_0=0$, the term $1/v^2$ creates a singularity. We must use the limiting form of the operator as $v \\to 0$. For a function with $\\partial h/\\partial v|_{v=0}=0$, the continuous operator has a well-defined limit: $C[h](0) = \\nu(3h(0) + \\frac{3}{2} v_{\\mathrm{th}}^2 \\frac{\\partial^2 h}{\\partial v^2}|_{v=0})$. We discretize the second derivative at $v=0$ using the symmetry property $h_{-1}=h_1$, which gives $\\frac{\\partial^2 h}{\\partial v^2}|_{0} \\approx \\frac{h_1 - 2h_0 + h_{-1}}{(\\Delta v)^2} = \\frac{2(h_1 - h_0)}{(\\Delta v)^2}$. Thus, the discrete operator at $v_0=0$ is:\n        $$ C[h]_0 = \\nu \\left( 3h_0 + 3v_{\\mathrm{th}}^2 \\frac{h_1-h_0}{(\\Delta v)^2} \\right) $$\n    This handles the singularity in a manner consistent with the underlying mathematics.\n\nWith the discrete operator $C[h]_i$ computed, we evaluate the verification metric $R$:\n$$\nR = \\frac{\\max_{i} |C[h]_i|}{\\nu \\max_{i} |h_i|}\n$$\nThe value of $R$ represents the normalized magnitude of the numerical error; in the continuous limit, it would be zero. The test passes if $R < \\epsilon$ for a given tolerance $\\epsilon$.\n\nA special case arises when the amplitude $\\alpha=0$. In this case, $h_i=0$ for all $i$. The discrete operator $C[0]$ will be identically zero. The metric $R$ becomes an indeterminate form $0/0$. However, the physical condition is perfectly satisfied with zero numerical error. Therefore, if $\\alpha=0$ (or computationally, if $\\max_i |h_i|=0$), the test is considered to have passed.\n\nEach test case is evaluated by implementing this numerical scheme for the given set of parameters $(m, T_{\\mathrm{eV}}, n_{0}, \\nu, N_{v}, \\lambda, \\alpha, \\epsilon)$ and checking if the computed $R$ is less than the specified $\\epsilon$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Fokker-Planck operator null-space verification problem.\n    \"\"\"\n    # Physical constant\n    e_charge = 1.602176634e-19  # Electron charge in Coulombs\n\n    # Test suite parameters: (m, T_eV, n0, nu, Nv, lambda, alpha, epsilon)\n    test_cases = [\n        (3.343583719e-27, 2.0e3, 1.0e19, 1.0e5, 400, 5.0, 0.5, 1.0e-3),\n        (3.343583719e-27, 2.0e3, 1.0e19, 1.0e5, 40, 6.0, 0.5, 2.0e-2),\n        (3.343583719e-27, 1.0e3, 5.0e18, 3.0e4, 60, 4.0, 0.0, 1.0e-10),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, T_ev, n0, nu, Nv, lam, alpha, eps = case\n\n        # Handle the trivial case where the perturbation is zero\n        if alpha == 0.0:\n            results.append(True)\n            continue\n\n        # Convert temperature from eV to Joules\n        T = T_ev * e_charge\n        \n        # Calculate thermal speed and set up the velocity grid\n        v_th = np.sqrt(2 * T / m)\n        v_max = lam * v_th\n        v, dv = np.linspace(0, v_max, Nv, retstep=True)\n\n        # Initialize the nonadiabatic distribution function h(v) = alpha * M(v)\n        norm_M = n0 / (np.pi * v_th**2)**1.5\n        M = norm_M * np.exp(-v**2 / v_th**2)\n        h = alpha * M\n\n        # Step 1: Compute the derivative of h(v) using finite differences\n        dh_dv = np.zeros(Nv, dtype=np.float64)\n        dh_dv[0] = 0.0  # Symmetry condition at v=0\n        # Second-order central difference for the interior\n        dh_dv[1:-1] = (h[2:] - h[:-2]) / (2 * dv)\n        # Second-order backward difference for the outer boundary\n        dh_dv[-1] = (3*h[-1] - 4*h[-2] + h[-3]) / (2 * dv)\n\n        # Step 2: Compute the flux S(v)\n        S = v**2 * (v * h + 0.5 * v_th**2 * dh_dv)\n\n        # Step 3: Compute the derivative of the flux S(v)\n        dS_dv = np.zeros(Nv, dtype=np.float64)\n        # Second-order forward difference for v=0 (using S[0]=0)\n        dS_dv[0] = (4*S[1] - S[2]) / (2 * dv)\n        # Second-order central difference for the interior\n        dS_dv[1:-1] = (S[2:] - S[:-2]) / (2 * dv)\n        # Second-order backward difference for the outer boundary\n        dS_dv[-1] = (3*S[-1] - 4*S[-2] + S[-3]) / (2 * dv)\n\n        # Step 4: Compute the discrete collision operator C[h]\n        C_h = np.zeros(Nv, dtype=np.float64)\n        # Special form for the singularity at v=0\n        d2h_dv2_0 = 2 * (h[1] - h[0]) / dv**2\n        C_h[0] = nu * (3 * h[0] + 1.5 * v_th**2 * d2h_dv2_0)\n        # Standard form for v > 0\n        C_h[1:] = nu / v[1:]**2 * dS_dv[1:]\n\n        # Step 5: Calculate the verification metric R and compare to tolerance\n        max_C_h = np.max(np.abs(C_h))\n        max_h = np.max(np.abs(h))\n\n        if max_h == 0.0:\n            # Should have been caught by alpha == 0 check, but is a safe fallback\n            is_passed = True\n        else:\n            R = max_C_h / (nu * max_h)\n            is_passed = R < eps\n        \n        results.append(is_passed)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from fundamental properties to practical implementation, we confront the numerical challenges of simulating collisions. Collisional processes often occur on timescales much faster than transport, making the Fokker-Planck equation numerically 'stiff' and prohibitive to solve with simple explicit methods. This advanced practice guides you through the implementation of an implicit, unconditionally stable scheme using the Scharfetter-Gummel flux discretization, a powerful technique that guarantees both particle conservation and the physical non-negativity of the distribution function, even when using large time steps. ",
            "id": "4202992",
            "problem": "Consider a single-species, one-dimensional velocity-space collisional relaxation in a fusion plasma turbulence simulation, described by the Fokker–Planck collision operator. Let $f(v,t)$ denote the velocity distribution function, with velocity $v$ measured in $\\mathrm{m/s}$ and time $t$ in $\\mathrm{s}$. Assume the collision operator is of drift–diffusion type, with a collision frequency $\\nu$ in $\\mathrm{s^{-1}}$ and a thermal speed $v_{\\mathrm{th}}$ in $\\mathrm{m/s}$. The governing equation can be cast in conservative form as a continuity equation in velocity space with a collisional flux:\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0,\n$$\nwhere the flux $J$ embodies both friction (drift) and diffusion effects. We restrict the velocity domain to a finite interval $v \\in [v_{\\min}, v_{\\max}]$ and impose zero-flux boundary conditions $J(v_{\\min},t)=J(v_{\\max},t)=0$ to ensure number conservation within the computational domain.\n\nStarting from fundamental principles—namely, the conservative (continuity) form above and the physical interpretation of drift and diffusion in velocity space—answer the following tasks:\n\n1. Analyze the stiffness of the collision term by identifying the explicit forward Euler time-stepping stability constraints associated with the drift and diffusion processes separately. Your analysis must start from the conservative form and the definitions of drift and diffusion, and proceed to a stability bound that can be operationalized. In your algorithmic implementation, use this bound to define a maximum explicit timestep $\\,\\Delta t_{\\mathrm{exp}}\\,$. Do not assume or cite any pre-derived formula not obtained from first principles in your derivation.\n\n2. Propose an unconditionally stable implicit time-stepping scheme that permits timesteps larger than $\\,\\Delta t_{\\mathrm{exp}}\\,$, while preserving non-negativity (positivity) of $f$ and number conservation. Implement a finite-volume discretization of the continuity equation $\\,\\partial_t f + \\partial_v J = 0\\,$ on a uniform mesh. Construct the numerical flux at cell interfaces using the Scharfetter–Gummel (SG) discretization (defined by solving the steady one-dimensional drift–diffusion balance exactly over each cell under constant-coefficient assumption), which is known to preserve positivity and yield conservative updates when coupled with zero-flux boundaries. Time-discretize implicitly with backward Euler. Your scheme must satisfy:\n   - Positivity: if $f(v,t^n)\\ge 0$ for all $v$, then $f(v,t^{n+1})\\ge 0$ for all $v$.\n   - Number conservation: $\\int_{v_{\\min}}^{v_{\\max}} f(v,t)\\,\\mathrm{d}v$ remains constant in time under zero-flux boundary conditions.\n\n3. Implement the above scheme in a complete, runnable program that constructs the discrete operator matrix from the SG flux and performs one implicit backward Euler step from a positive initial distribution $f_0(v)$. Use the following test suite. In all three cases, define the initial condition as the one-dimensional Maxwellian\n$$\nf_0(v) = \\frac{n}{\\sqrt{\\pi}\\,v_{\\mathrm{th}}}\\,\\exp\\!\\left(-\\frac{v^2}{v_{\\mathrm{th}}^2}\\right),\n$$\nwith density $n$ measured in $\\mathrm{m^{-3}}$. The domain is uniform with $N$ grid points over $[v_{\\min}, v_{\\max}]$ and zero-flux boundaries. For each case, set the implicit timestep $\\,\\Delta t = m \\,\\Delta t_{\\mathrm{exp}}\\,$ where $m$ is a multiplier. Evaluate positivity and conservation after one implicit step.\n\n- Case 1 (happy path):\n  - $N = 101$,\n  - $v_{\\min} = -5.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 5.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 5.0\\times 10^{6}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 1.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - multiplier $m = 5$.\n\n- Case 2 (strong stiffness):\n  - $N = 81$,\n  - $v_{\\min} = -7.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 7.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 2.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 7.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - multiplier $m = 50$.\n\n- Case 3 (boundary/coarse-grid edge case):\n  - $N = 21$,\n  - $v_{\\min} = -4.0\\times 10^{5}\\ \\mathrm{m/s}$, $v_{\\max} = 4.0\\times 10^{5}\\ \\mathrm{m/s}$,\n  - $\\nu = 1.0\\times 10^{7}\\ \\mathrm{s^{-1}}$,\n  - $v_{\\mathrm{th}} = 8.0\\times 10^{4}\\ \\mathrm{m/s}$,\n  - $n = 1.0\\times 10^{19}\\ \\mathrm{m^{-3}}$,\n  - multiplier $m = 200$.\n\nAlgorithmic requirements:\n- The Scharfetter–Gummel flux must be derived from the exact solution of the steady one-dimensional drift–diffusion balance on each cell with constant coefficients, and evaluated at each cell interface using the local interface velocity. The implementation must ensure consistency at $P\\to 0$ where $P$ denotes the interface cell Péclet number.\n- Use uniform grid spacing $\\,\\Delta v = (v_{\\max}-v_{\\min})/(N-1)\\,$.\n- For the explicit stability analysis, derive $\\,\\Delta t_{\\mathrm{exp}}\\,$ from the drift and diffusion constraints and take the more restrictive bound.\n\nValidation tasks to perform in code for each case after one implicit step:\n- Compute a boolean indicating positivity, defined as $\\min_i f_i^{n+1} \\ge -\\epsilon \\max_i f_i^{n+1}$ with $\\epsilon = 10^{-12}$.\n- Compute a boolean indicating number conservation, defined as $\\left|\\sum_i f_i^{n+1}\\Delta v - \\sum_i f_i^{n}\\Delta v\\right| \\le \\tau \\sum_i f_i^{n}\\Delta v$ with tolerance $\\tau = 10^{-6}$.\n- Compute and report the ratio $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$ as a floating-point number.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). The list must contain, in order, for Case 1 then Case 2 then Case 3, the positivity boolean, the conservation boolean, and the ratio $r$ for each case. No units should be included in the output; all booleans and ratios are dimensionless numbers.",
            "solution": "The problem is scientifically grounded in the principles of kinetic theory and plasma physics, well-posed, objective, and contains all necessary information for a unique solution. It presents a standard problem in computational physics related to the numerical solution of the Fokker-Planck equation.\n\nThe governing equation for the velocity distribution function $f(v, t)$ is given in conservative form:\n$$\n\\frac{\\partial f}{\\partial t} + \\frac{\\partial J}{\\partial v} = 0\n$$\nwhere $J$ is the collisional flux in velocity space. For a single species relaxing towards a thermal equilibrium, the Fokker-Planck collision operator can be modeled in a drift-diffusion form. The flux $J$ that drives the distribution towards a Maxwellian $f_M \\propto \\exp(-v^2 / v_{\\mathrm{th}}^2)$ is given by:\n$$\nJ(v,t) = -\\nu \\left( v f(v,t) + \\frac{v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v} \\right)\n$$\nHere, the term proportional to $v f$ is a drift (or friction) term, which pulls particles towards $v=0$, and the term proportional to $\\partial f / \\partial v$ is a diffusion term, which spreads the distribution. The parameters are the collision frequency $\\nu$ and the thermal speed $v_{\\mathrm{th}}$. It can be verified that $J=0$ for a Maxwellian distribution, making it the steady-state solution.\n\nThe problem asks for three tasks: a stability analysis of an explicit scheme, the design and implementation of a conservative and positivity-preserving implicit scheme, and the execution of this scheme on a suite of test cases.\n\n### 1. Explicit Time-Stepping Stability Constraints\n\nTo analyze the stiffness of the collision operator, we discretize the governing equation using a forward Euler method in time and examine the stability constraints imposed by the drift and diffusion terms separately. We consider a uniform velocity grid $v_i$ with spacing $\\Delta v$. The update from time $t^n$ to $t^{n+1} = t^n + \\Delta t$ is $f_i^{n+1} = f_i^n - \\frac{\\Delta t}{\\Delta v} (J_{i+1/2}^n - J_{i-1/2}^n)$. For stability, we require that the coefficients of $f_j^n$ in the expression for $f_i^{n+1}$ satisfy certain conditions to prevent amplification of errors.\n\n**Diffusion Constraint:**\nThe diffusion part of the equation is $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v} \\left(\\frac{\\nu v_{\\mathrm{th}}^2}{2} \\frac{\\partial f}{\\partial v}\\right)$. For a constant diffusion coefficient $D = \\frac{\\nu v_{\\mathrm{th}}^2}{2}$, this is the heat equation $\\frac{\\partial f}{\\partial t} = D \\frac{\\partial^2 f}{\\partial v^2}$. Using a standard central difference spatial discretization and forward Euler in time, we have:\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} = D \\frac{f_{i+1}^n - 2f_i^n + f_{i-1}^n}{(\\Delta v)^2}\n$$\nThe stability of this scheme (e.g., from von Neumann analysis or by requiring positivity of coefficients) is known to be bounded by:\n$$\n\\Delta t \\le \\frac{(\\Delta v)^2}{2D} \\implies \\Delta t_{\\mathrm{diff}} \\le \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\n$$\n\n**Drift Constraint:**\nThe drift part of the equation is $\\frac{\\partial f}{\\partial t} = \\frac{\\partial}{\\partial v}(\\nu v f)$. In conservative form, $\\frac{\\partial f}{\\partial t} + \\frac{\\partial J_{\\mathrm{drift}}}{\\partial v} = 0$, with flux $J_{\\mathrm{drift}} = -\\nu v f$. This is a linear advection equation with a space-dependent velocity $c(v) = -\\nu v$. Using a first-order upwind scheme for stability, the Courant-Friedrichs-Lewy (CFL) condition must be satisfied. The CFL condition for an explicit advection scheme is:\n$$\n\\Delta t \\le \\frac{\\Delta v}{\\max |c(v)|}\n$$\nIn our velocity domain $v \\in [v_{\\min}, v_{\\max}]$, the maximum advection speed is $|c(v)|_{\\max} = \\nu \\max(|v_{\\min}|, |v_{\\max}|)$. Let $v_{\\mathrm{domain\\_max}} = \\max(|v_{\\min}|, |v_{\\max}|)$. The stability constraint is then:\n$$\n\\Delta t_{\\mathrm{drift}} \\le \\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}\n$$\n\n**Maximum Explicit Timestep $\\Delta t_{\\mathrm{exp}}$:**\nFor a stable explicit scheme, both conditions must be met. Therefore, the overall explicit timestep is limited by the more restrictive of the two:\n$$\n\\Delta t_{\\mathrm{exp}} = \\min(\\Delta t_{\\mathrm{drift}}, \\Delta t_{\\mathrm{diff}}) = \\min\\left(\\frac{\\Delta v}{\\nu v_{\\mathrm{domain\\_max}}}, \\frac{(\\Delta v)^2}{\\nu v_{\\mathrm{th}}^2}\\right)\n$$\nThis bound is used to define the timestep for the implicit solver.\n\n### 2. Implicit Time-Stepping Scheme\n\nWe implement an unconditionally stable implicit scheme using a finite-volume discretization, backward Euler for time integration, and the Scharfetter-Gummel flux approximation.\n\n**Finite-Volume Discretization:**\nWe discretize on a uniform grid with $N$ points $v_i$ for $i=0, \\dots, N-1$. The $i$-th finite volume is $[v_i - \\Delta v/2, v_i + \\Delta v/2]$, centered at $v_i$. The interfaces are at $v_{i+1/2} = v_i + \\Delta v/2$. Integrating the continuity equation over the $i$-th cell gives:\n$$\n\\frac{d f_i}{d t} = -\\frac{J_{i+1/2} - J_{i-1/2}}{\\Delta v}\n$$\nApplying backward Euler discretization in time yields:\n$$\n\\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\n\n**Scharfetter-Gummel Flux:**\nThe SG flux is derived by solving the steady-state, one-dimensional drift-diffusion equation $J = \\text{constant}$ across a grid cell $[v_i, v_{i+1}]$, assuming constant coefficients. The equation to solve is:\n$$\nJ_{i+1/2} = -\\nu \\left( v_{i+1/2} f(v) + D \\frac{df}{dv} \\right)\n$$\nwhere $D = v_{\\mathrm{th}}^2/2$, and $v_{i+1/2}$ is the velocity at the interface. This is a first-order linear ODE for $f(v)$. Solving it with boundary conditions $f(v_i)=f_i$ and $f(v_{i+1})=f_{i+1}$ yields the flux $J_{i+1/2}$ in terms of the cell-edge values $f_i$ and $f_{i+1}$:\n$$\nJ_{i+1/2} = \\frac{\\nu D}{\\Delta v} \\left[ B(P_{i+1/2}) f_i - B(-P_{i+1/2}) f_{i+1} \\right]\n$$\nHere, $P_{i+1/2}$ is the local Péclet number, which measures the ratio of drift to diffusion:\n$$\nP_{i+1/2} = \\frac{v_{i+1/2} \\Delta v}{D} = \\frac{2 v_{i+1/2} \\Delta v}{v_{\\mathrm{th}}^2}\n$$\nand $B(x) = x / (e^x - 1)$ is the Bernoulli function. This flux formulation is crucial as it correctly balances drift and diffusion and ensures positivity.\n\n**Linear System and Properties:**\nSubstituting the SG flux into the backward Euler equation results in a linear system for the unknown distribution $\\vec{f}^{n+1} = [f_0^{n+1}, \\dots, f_{N-1}^{n+1}]^T$:\n$$\nM \\vec{f}^{n+1} = \\vec{f}^n\n$$\nThe matrix $M$ is tridiagonal. The zero-flux boundary conditions $J(v_{\\min})=0$ and $J(v_{\\max})=0$ are implemented by setting the fluxes at the domain boundaries to zero, i.e., $J_{-1/2} = 0$ and $J_{N-1/2} = 0$. Using the shorthand $\\alpha = \\frac{\\Delta t \\nu v_{\\mathrm{th}}^2}{2(\\Delta v)^2}$, the matrix entries for $i,j \\in \\{0, \\dots, N-1\\}$ are:\n- For $i \\in [1, N-2]$ (interior points):\n  - $M_{i,i-1} = -\\alpha B(P_{i-1/2})$\n  - $M_{i,i} = 1 + \\alpha (B(P_{i+1/2}) + B(-P_{i-1/2}))$\n  - $M_{i,i+1} = -\\alpha B(-P_{i+1/2})$\n- For $i=0$ (left boundary):\n  - $M_{0,0} = 1 + \\alpha B(P_{1/2})$\n  - $M_{0,1} = -\\alpha B(-P_{1/2})$\n- For $i=N-1$ (right boundary):\n  - $M_{N-1,N-2} = -\\alpha B(P_{N-3/2})$\n  - $M_{N-1,N-1} = 1 + \\alpha B(-P_{N-3/2})$\n\n**Positivity and Conservation:**\nThe Bernoulli function $B(x)$ is always positive. As a result, the constructed matrix $M$ has positive diagonal entries ($M_{ii} > 1$) and non-positive off-diagonal entries ($M_{ij} \\le 0$ for $i \\ne j$). Such a matrix is a diagonally dominant M-matrix, and its inverse $M^{-1}$ is guaranteed to have all non-negative entries. Therefore, if the initial state $\\vec{f}^n$ is non-negative, the updated state $\\vec{f}^{n+1} = M^{-1}\\vec{f}^n$ will also be non-negative, ensuring the scheme is positivity-preserving.\n\nNumber conservation is ensured by the finite-volume formulation with zero-flux boundaries. Summing the discrete equation over all cells $i=0, \\dots, N-1$:\n$$\n\\sum_i \\frac{f_i^{n+1} - f_i^n}{\\Delta t} + \\sum_i \\frac{J_{i+1/2}^{n+1} - J_{i-1/2}^{n+1}}{\\Delta v} = 0\n$$\nThe second sum is a telescoping series: $\\sum_i (J_{i+1/2} - J_{i-1/2}) = J_{N-1/2} - J_{-1/2}$. With boundary conditions $J_{N-1/2}=0$ and $J_{-1/2}=0$, this sum vanishes. This leads to $\\sum_i (f_i^{n+1} - f_i^n) = 0$, which implies $\\sum_i f_i^{n+1} \\Delta v = \\sum_i f_i^n \\Delta v$. The total number of particles is conserved.\n\n### 3. Algorithmic Implementation\n\nThe program implements the derived implicit scheme. For each test case, it sets up the velocity grid, calculates $\\Delta t_{\\mathrm{exp}}$ and the implicit $\\Delta t$, and defines the initial Maxwellian distribution. It then constructs the tridiagonal matrix $M$ by computing the Péclet numbers and evaluating the Bernoulli function at each interface. The resulting linear system is efficiently solved using `scipy.linalg.solve_banded`. Finally, it performs the required checks for positivity and number conservation and computes the ratio $r = \\Delta t / \\Delta t_{\\mathrm{exp}}$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef bernoulli(x):\n    \"\"\"\n    Robust implementation of the Bernoulli function B(x) = x / (e^x - 1).\n    Uses a Taylor expansion for small |x| to avoid division by zero and floating point errors.\n    \"\"\"\n    if np.abs(x) < 1e-9:\n        # Taylor series for B(x) around x=0: 1 - x/2 + x^2/12 - x^4/720 + ...\n        return 1.0 - x / 2.0 + x**2 / 12.0 - x**4 / 720.0\n    else:\n        return x / (np.exp(x) - 1.0)\n\ndef solve_case(N, v_min, v_max, nu, v_th, n, m):\n    \"\"\"\n    Solves one test case for the Fokker-Planck collision operator.\n    \"\"\"\n    # 1. Grid and Initial Condition\n    v = np.linspace(v_min, v_max, N)\n    delta_v = (v_max - v_min) / (N - 1)\n    \n    f_initial = (n / (np.sqrt(np.pi) * v_th)) * np.exp(-(v**2 / v_th**2))\n\n    # 2. Timestep Calculation (based on explicit stability)\n    v_domain_max = np.max(np.abs([v_min, v_max]))\n    # Stability from drift (CFL condition)\n    dt_drift = delta_v / (nu * v_domain_max)\n    # Stability from diffusion\n    dt_diff = delta_v**2 / (nu * v_th**2)\n    # The more restrictive of the two determines the explicit timestep limit\n    dt_exp = min(dt_drift, dt_diff)\n    \n    # Set the implicit timestep as a multiple of the explicit limit\n    delta_t = m * dt_exp\n\n    # 3. Assemble the Implicit Matrix M for M*f_next = f_initial\n    # Interface velocities (N-1 interfaces)\n    v_interfaces = v[:-1] + delta_v / 2.0\n    \n    # Péclet numbers at interfaces\n    peclet = (2.0 * v_interfaces * delta_v) / (v_th**2)\n    \n    # Constant term alpha\n    D_coeff = v_th**2 / 2.0\n    alpha = (delta_t * nu * D_coeff) / (delta_v**2)\n\n    # Scipy's solve_banded expects the matrix in `ab` format.\n    # For a tridiagonal matrix (l=1, u=1), ab has 3 rows:\n    # ab[0, 1:] = Super-diagonal\n    # ab[1, :]   = Main diagonal\n    # ab[2, :-1] = Sub-diagonal\n    ab = np.zeros((3, N))\n    \n    B_p = np.array([bernoulli(p) for p in peclet])\n    B_neg_p = np.array([bernoulli(-p) for p in peclet])\n    \n    # Main diagonal M_i,i\n    ab[1, 1:-1] = 1.0 + alpha * (B_p[1:] + B_neg_p[:-1])\n    ab[1, 0] = 1.0 + alpha * B_p[0] # Left boundary\n    ab[1, -1] = 1.0 + alpha * B_neg_p[-1] # Right boundary\n\n    # Super-diagonal M_i,i+1\n    ab[0, 1:] = -alpha * B_neg_p\n\n    # Sub-diagonal M_i,i-1\n    ab[2, :-1] = -alpha * B_p\n\n    # 4. Solve the linear system\n    f_next = solve_banded((1, 1), ab, f_initial)\n    \n    # 5. Validation Checks\n    # Positivity check\n    epsilon = 1e-12\n    # Ensure min(f_next) is not negative beyond a small tolerance relative to max(f_next)\n    positivity = bool(np.min(f_next) >= -epsilon * np.max(f_next))\n    \n    # Conservation check\n    tau = 1e-6\n    total_N_initial = np.sum(f_initial) * delta_v\n    total_N_final = np.sum(f_next) * delta_v\n    \n    if np.abs(total_N_initial) < 1e-15: # Handle case of zero initial distribution\n        conservation = bool(np.abs(total_N_final - total_N_initial) <= tau)\n    else:\n        conservation = bool(np.abs(total_N_final - total_N_initial) <= tau * np.abs(total_N_initial))\n    \n    # Ratio of implicit to explicit timestep\n    ratio = delta_t / dt_exp\n    \n    return positivity, conservation, ratio\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1 (happy path)\n        {\"N\": 101, \"v_min\": -5.0e5, \"v_max\": 5.0e5, \"nu\": 5.0e6, \"v_th\": 1.0e5, \"n\": 1.0e19, \"m\": 5},\n        # Case 2 (strong stiffness)\n        {\"N\": 81, \"v_min\": -7.0e5, \"v_max\": 7.0e5, \"nu\": 2.0e7, \"v_th\": 7.0e4, \"n\": 1.0e19, \"m\": 50},\n        # Case 3 (boundary/coarse-grid edge case)\n        {\"N\": 21, \"v_min\": -4.0e5, \"v_max\": 4.0e5, \"nu\": 1.0e7, \"v_th\": 8.0e4, \"n\": 1.0e19, \"m\": 200},\n    ]\n\n    results = []\n    for case in test_cases:\n        pos, cons, r = solve_case(\n            N=case[\"N\"],\n            v_min=case[\"v_min\"],\n            v_max=case[\"v_max\"],\n            nu=case[\"nu\"],\n            v_th=case[\"v_th\"],\n            n=case[\"n\"],\n            m=case[\"m\"]\n        )\n        # Python bools are 'True'/'False'. Format to lowercase 'true'/'false' if needed.\n        # But problem output example does not specify, so default representation is likely fine.\n        results.extend([pos, cons, r])\n\n    # Format the final output string exactly as required\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}