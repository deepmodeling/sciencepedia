{
    "hands_on_practices": [
        {
            "introduction": "Black方程是描述金属互连中电迁移失效现象的核心经验模型。本练习将指导您应用该模型，量化电流密度 $J$ 等应力条件对器件寿命的影响，这是进行加速寿命测试和设计高可靠性电路的一项基本技能。",
            "id": "3738773",
            "problem": "后段制程（back-end-of-line）金属化堆叠中的大马士革铜互连因电迁移而失效，电迁移是由电子风力作用下热激活的原子输运过程驱动的。由于动量传递增强，失效率随电流密度的增加而增加；由于原子迁移率更高，失效率也随温度的升高而增加。对于两个在其他方面完全相同的直线互连段（具有相同的线宽、长度、微观结构、界面和阻挡层条件），设其电流密度分别为 $J_1$ 和 $J_2$，有效电流指数为 $n$，速率限制过程的激活能为 $E_a$。假设两个互连段都在温度 $T$ 下进行等温应力测试，并且损伤率与电流密度呈幂律关系，且具有阿伦尼乌斯（Arrhenius）温度依赖性。\n\n利用这些基本原理，推导平均失效时间 (MTTF) 与 $J$ 和 $T$ 的标度关系，并获得两个互连段寿命比 $R \\equiv \\mathrm{MTTF}_1/\\mathrm{MTTF}_2$ 的封闭形式表达式，该表达式用 $J_1$、$J_2$、$n$、$E_a$、$T$ 和玻尔兹曼常数 $k_B$ 表示。然后，在 $J_1 = 0.8\\,\\mathrm{MA/cm}^2$、$J_2 = 1.2\\,\\mathrm{MA/cm}^2$、$n = 1.1$、$E_a = 0.9\\,\\mathrm{eV}$ 和 $T = 373\\,\\mathrm{K}$ 的条件下计算 $R$ 的值。将 $R$ 的最终数值结果报告为一个纯数字，并四舍五入到四位有效数字。",
            "solution": "该问题是有效的。它基于一个公认的半导体互连中电迁移失效的物理模型，即 Black 方程。所提供的参数在物理上是现实的，且问题是自洽且定义明确的。\n\n问题陈述了损伤率与电流密度 ($J$) 呈幂律关系，并且具有阿伦尼乌斯（Arrhenius）温度依赖性。平均失效时间 (MTTF) 与此损伤率成反比。这种关系是 Black 方程的基础。\n\n首先，我们确定 MTTF 的函数形式。损伤率 $\\mathcal{R}_D$ 可以写为：\n$$ \\mathcal{R}_D \\propto J^n \\exp\\left(-\\frac{E_a}{k_B T}\\right) $$\n其中 $J$ 是电流密度，$n$ 是电流指数，$E_a$ 是扩散过程的激活能，$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n平均失效时间与损伤率成反比，因为特定量的累积损伤会导致失效。\n$$ \\mathrm{MTTF} \\propto \\frac{1}{\\mathcal{R}_D} $$\n结合这些比例关系，我们推导出 MTTF 与 $J$ 和 $T$ 的标度关系，即 Black 方程：\n$$ \\mathrm{MTTF} = A J^{-n} \\exp\\left(\\frac{E_a}{k_B T}\\right) $$\n这里，$A$ 是一个比例常数，它取决于互连线的材料特性、几何形状和微观结构。\n\n问题描述了两个互连段，标记为 $1$ 和 $2$，它们“在其他方面完全相同”，并在相同温度 $T$ 下进行等温应力测试。这意味着比例因子 $A$、激活能 $E_a$、电流指数 $n$ 和温度 $T$ 对两个互连段都是相同的。唯一的区别是电流密度，互连段 $1$ 的电流密度为 $J_1$，互连段 $2$ 的为 $J_2$。\n\n我们可以使用 Black 方程写出每个互连段的 MTTF：\n对于互连段 $1$：\n$$ \\mathrm{MTTF}_1 = A J_1^{-n} \\exp\\left(\\frac{E_a}{k_B T}\\right) $$\n对于互连段 $2$：\n$$ \\mathrm{MTTF}_2 = A J_2^{-n} \\exp\\left(\\frac{E_a}{k_B T}\\right) $$\n\n问题要求获得寿命比 $R \\equiv \\mathrm{MTTF}_1 / \\mathrm{MTTF}_2$ 的封闭形式表达式。我们可以通过计算上述两个表达式的比值来得到：\n$$ R = \\frac{\\mathrm{MTTF}_1}{\\mathrm{MTTF}_2} = \\frac{A J_1^{-n} \\exp\\left(\\frac{E_a}{k_B T}\\right)}{A J_2^{-n} \\exp\\left(\\frac{E_a}{k_B T}\\right)} $$\n由于比例因子 $A$ 和温度 $T$ 对两个互连段都相同，因此项 $A$ 和指数项 $\\exp\\left(\\frac{E_a}{k_B T}\\right)$ 会被消掉。这是一个由等温应力条件产生的关键简化。问题给出了 $E_a$ 和 $T$ 的值，但在这些特定条件下，计算比值 $R$ 并不需要它们。\n\n$R$ 的表达式简化为：\n$$ R = \\frac{J_1^{-n}}{J_2^{-n}} = \\left(\\frac{J_1}{J_2}\\right)^{-n} = \\left(\\frac{J_2}{J_1}\\right)^n $$\n这就是所要求的寿命比 $R$ 的封闭形式表达式。\n\n现在，我们使用给定的数值来计算 $R$：\n$J_1 = 0.8\\,\\mathrm{MA/cm}^2$\n$J_2 = 1.2\\,\\mathrm{MA/cm}^2$\n$n = 1.1$\n\n在比值 $J_2/J_1$ 中，电流密度单位 ($\\mathrm{MA/cm}^2$) 会被消掉。\n$$ R = \\left(\\frac{1.2}{0.8}\\right)^{1.1} = (1.5)^{1.1} $$\n我们可以计算这个值：\n$$ R = 1.5620803... $$\n问题要求最终答案四舍五入到四位有效数字。\n$$ R \\approx 1.562 $$",
            "answer": "$$\\boxed{1.562}$$"
        },
        {
            "introduction": "器件退化会直接表现为电学特性的变化，例如阈值电压漂移和载流子迁移率下降。本练习模拟了参数提取这一关键的工程任务，旨在训练您如何将原始的电学测量数据（如跨导和电荷泵浦电流）转化为定量的物理退化指标（如界面态密度 $D_{it}$ 和迁移率衰减），从而架起理论模型与实验表征之间的桥梁。",
            "id": "3738792",
            "problem": "给定金属-氧化物-半导体场效应晶体管 (MOSFET) 在应力前后的跨导和漏极电流的测量数据，以及电荷泵测量数据。请从第一性原理出发，推导并实现一个算法，为每个器件提取界面态密度的估计值（单位：每电子伏特每单位面积）以及电应力下的迁移率退化分数。仅使用以下基本原理：(i) 饱和区 MOSFET 的强反型平方律电流模型，忽略沟道长度调制和速度饱和效应，(ii) 跨导的定义，以及 (iii) 电荷泵电流与界面态密度之间的关系。\n\n定义与基本原理：\n- 令 $I_{D}$ 表示栅源电压为 $V_{GS}$、阈值电压为 $V_{TH}$ 的 MOSFET 在饱和区的漏极电流。在长沟道、强反型、饱和区（忽略沟道长度调制和速度饱和），电流模型为 $$I_{D}=\\frac{1}{2}\\,\\mu\\,C_{ox}\\,\\frac{W}{L}\\,(V_{GS}-V_{TH})^{2},$$ 其中 $\\mu$ 是载流子迁移率，$C_{ox}$ 是单位面积的栅氧化层电容，$W$ 是沟道宽度，$L$ 是沟道长度。\n- 跨导 $g_{m}$ 定义为 $$g_{m}=\\frac{\\partial I_{D}}{\\partial V_{GS}}=\\mu\\,C_{ox}\\,\\frac{W}{L}\\,(V_{GS}-V_{TH}).$$\n- 将这些结合起来，得到与阈值电压无关的迁移率提取关系：$$\\mu=\\frac{g_{m}^{2}}{2\\,C_{ox}\\,(W/L)\\,I_{D}}.$$\n- 电荷泵 (CP) 方法将电荷泵电流 $I_{CP}$ 与界面态密度 $D_{it}(E)$ 联系起来，公式为 $$I_{CP}=q\\,f\\,A\\,\\int D_{it}(E)\\,dE,$$ 其中 $q$ 是基本电荷，$f$ 是脉冲频率，$A=W\\,L$ 是栅下沟道面积。如果栅极脉冲幅度跨越一个宽度为 $\\Delta E$ 的能量窗口，且 $D_{it}(E)$ 在该窗口内近似均匀，则 $$I_{CP}\\approx q\\,f\\,A\\,D_{it}\\,\\Delta E.$$\n- 由单位面积的界面陷阱电荷密度 $Q_{it}$ 引起的阈值电压漂移 $\\Delta V_{TH}$ 满足 $$\\Delta V_{TH}=\\frac{Q_{it}}{C_{ox}},\\quad Q_{it}=q\\,\\int D_{it}(E)\\,dE\\approx q\\,D_{it}\\,\\Delta E.$$\n\n任务：\n- 对于每个测试案例，使用上述基本原理计算界面态密度（单位：每电子伏特每单位面积）的两个独立估计值：\n  1. 来自 $I_{CP}$ 的电荷泵估计值 $\\hat{D}_{it}^{CP}$，使用公式 $\\hat{D}_{it}^{CP}=I_{CP}/(q\\,f\\,A\\,\\Delta E)$。\n  2. 来自阈值电压漂移 $\\Delta V_{TH}$ 的基于跨导的估计值 $\\hat{D}_{it}^{gm}$，使用公式 $\\hat{D}_{it}^{gm}=C_{ox}\\,\\Delta V_{TH}/(q\\,\\Delta E)$，其中 $\\Delta V_{TH}$ 通过从应力后的 $g_{m}$ 和 $\\mu$ 中提取过驱动电压 $V_{OV}=V_{GS}-V_{TH}$，计算应力后的 $V_{TH}$，然后减去给定的应力前 $V_{TH}$ 来获得。\n- 同时计算迁移率退化分数 $\\delta_{\\mu}$，其定义为小数形式 $$\\delta_{\\mu}=\\frac{\\mu_{0}-\\mu_{1}}{\\mu_{0}},$$ 其中 $\\mu_{0}$ 和 $\\mu_{1}$ 分别是应力前和应力后的迁移率，通过 $\\mu=g_{m}^{2}/(2\\,C_{ox}\\,(W/L)\\,I_{D})$ 提取。\n\n单位与输出：\n- 使用 $\\Delta E=E_{g}$，即以 $\\mathrm{eV}$ 为单位提供的半导体带隙能量。界面态密度以 $\\mathrm{m^{-2}\\,eV^{-1}}$ 表示，迁移率退化以小数形式表示（不带百分号）。\n- 不使用角度；不需要角度单位。\n- 您的程序必须为每个测试案例输出一个包含三个浮点数的列表 $[\\hat{D}_{it}^{CP},\\hat{D}_{it}^{gm},\\delta_{\\mu}]$，并将所有测试案例聚合到一行的一个列表中，格式严格要求无空格：例如，$[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}]]$。每个浮点数必须以包含 $6$ 位有效数字的科学记数法打印。\n- 使用基本电荷 $q=1.602176634\\times 10^{-19}\\,\\mathrm{C}$。\n\n测试套件：\n为以下参数集提供结果，这些参数集在科学上是一致的，并对应于饱和区。所有量均在室温下测量；频率为电荷泵脉冲的频率。\n\n- 案例 $1$ (典型应力):\n  - $W=1.0\\times 10^{-5}\\,\\mathrm{m}$, $L=2.0\\times 10^{-7}\\,\\mathrm{m}$, $C_{ox}=1.0\\times 10^{-2}\\,\\mathrm{F/m^{2}}$, $V_{GS}=1.0\\,\\mathrm{V}$, 应力前 $V_{TH,0}=0.30\\,\\mathrm{V}$。\n  - 应力前测量值: $g_{m,0}=1.75\\times 10^{-2}\\,\\mathrm{S}$, $I_{D,0}=6.125\\times 10^{-3}\\,\\mathrm{A}$。\n  - 应力后测量值: $g_{m,1}=1.38125\\times 10^{-2}\\,\\mathrm{S}$, $I_{D,1}=4.4928\\times 10^{-3}\\,\\mathrm{A}$。\n  - 电荷泵: $f=1.0\\times 10^{6}\\,\\mathrm{Hz}$, $I_{CP}=1.000\\times 10^{-9}\\,\\mathrm{A}$。\n  - 带隙: $E_{g}=1.12\\,\\mathrm{eV}$。\n\n- 案例 $2$ (低界面陷阱生成，轻度迁移率退化):\n  - $W=1.0\\times 10^{-5}\\,\\mathrm{m}$, $L=5.0\\times 10^{-7}\\,\\mathrm{m}$, $C_{ox}=1.0\\times 10^{-2}\\,\\mathrm{F/m^{2}}$, $V_{GS}=0.80\\,\\mathrm{V}$, 应力前 $V_{TH,0}=0.25\\,\\mathrm{V}$。\n  - 应力前测量值: $g_{m,0}=6.60\\times 10^{-3}\\,\\mathrm{S}$, $I_{D,0}=1.815\\times 10^{-3}\\,\\mathrm{A}$。\n  - 应力后测量值: $g_{m,1}=6.213\\times 10^{-3}\\,\\mathrm{S}$, $I_{D,1}=1.692\\times 10^{-3}\\,\\mathrm{A}$。\n  - 电荷泵: $f=2.0\\times 10^{6}\\,\\mathrm{Hz}$, $I_{CP}=5.000\\times 10^{-10}\\,\\mathrm{A}$。\n  - 带隙: $E_{g}=1.12\\,\\mathrm{eV}$。\n\n- 案例 $3$ (强应力，显著的迁移率损失和阈值漂移):\n  - $W=2.0\\times 10^{-5}\\,\\mathrm{m}$, $L=2.0\\times 10^{-7}\\,\\mathrm{m}$, $C_{ox}=1.2\\times 10^{-2}\\,\\mathrm{F/m^{2}}$, $V_{GS}=1.20\\,\\mathrm{V}$, 应力前 $V_{TH,0}=0.35\\,\\mathrm{V}$。\n  - 应力前测量值: $g_{m,0}=4.08\\times 10^{-2}\\,\\mathrm{S}$, $I_{D,0}=1.734\\times 10^{-2}\\,\\mathrm{A}$。\n  - 应力后测量值: $g_{m,1}=2.1024\\times 10^{-2}\\,\\mathrm{S}$, $I_{D,1}=7.665\\times 10^{-3}\\,\\mathrm{A}$。\n  - 电荷泵: $f=5.0\\times 10^{5}\\,\\mathrm{Hz}$, $I_{CP}=2.878\\times 10^{-9}\\,\\mathrm{A}$。\n  - 带隙: $E_{g}=1.12\\,\\mathrm{eV}$。\n\n实现要求：\n- 通过 $\\mu=g_{m}^{2}/(2\\,C_{ox}\\,(W/L)\\,I_{D})$ 计算 $\\mu_{0}$ 和 $\\mu_{1}$。\n- 计算应力后的过驱动电压 $V_{OV,1}=g_{m,1}/(\\mu_{1}\\,C_{ox}\\,(W/L))$ 和 $V_{TH,1}=V_{GS}-V_{OV,1}$，因此 $\\Delta V_{TH}=V_{TH,1}-V_{TH,0}$。\n- 计算 $\\hat{D}_{it}^{CP}=I_{CP}/(q\\,f\\,A\\,E_{g})$（其中 $A=W\\,L$）和 $\\hat{D}_{it}^{gm}=C_{ox}\\,\\Delta V_{TH}/(q\\,E_{g})$。\n- 计算 $\\delta_{\\mu}=(\\mu_{0}-\\mu_{1})/\\mu_{0}$。\n- 您的程序应生成一行输出，其中包含一个以逗号分隔的列表，该列表用方括号括起来，没有空格，其中每个测试案例贡献一个子列表 $[\\hat{D}_{it}^{CP},\\hat{D}_{it}^{gm},\\delta_{\\mu}]$。每个浮点数必须以包含 $6$ 位有效数字的科学记数法呈现。",
            "solution": "问题陈述是有效的。它在科学上基于半导体器件物理学原理，问题设定良好，数据充分，目标明确，没有任何矛盾或含糊之处。为测试案例提供的数值是物理上现实的，并且与指定的理论模型内部一致。因此，我们将着手提供一个完整的解决方案。\n\n任务是为每个被测器件计算三个量：界面态密度 ($D_{it}$) 的两个独立估计值和由电应力引起的迁移率退化分数 ($\\delta_{\\mu}$)。推导和实现将基于所提供的先验模型：MOSFET 的强反型饱和电流方程、跨导的定义以及电荷泵电流模型。\n\n我们用下标 $0$ 表示应力前参数，用下标 $1$ 表示应力后参数。基本电荷给定为 $q = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}$。\n\n**1. 计算应力前后的迁移率 ($\\mu_0$, $\\mu_1$) 和迁移率退化分数 ($\\delta_{\\mu}$)**\n\n问题提供了一个与阈值电压 $V_{TH}$ 无关的提取载流子迁移率 $\\mu$ 的关系。该关系通过组合饱和漏极电流 $I_D$ 和跨导 $g_m$ 的方程推导得出：\n$$I_{D}=\\frac{1}{2}\\,\\mu\\,C_{ox}\\,\\frac{W}{L}\\,(V_{GS}-V_{TH})^{2}$$\n$$g_{m}=\\mu\\,C_{ox}\\,\\frac{W}{L}\\,(V_{GS}-V_{TH})$$\n通过将 $g_m$ 的表达式平方，然后除以 $I_D$ 的表达式，我们消去了未知的 $(V_{GS}-V_{TH})$ 项，从而得到所提供的公式：\n$$\\mu = \\frac{g_m^2}{2 \\, C_{ox} \\, (W/L) \\, I_D}$$\n我们将此公式分别应用于应力前和应力后的测量数据。\n\n应力前迁移率 $\\mu_0$ 使用应力前测量值 $(g_{m,0}, I_{D,0})$ 计算：\n$$\\mu_0 = \\frac{g_{m,0}^2}{2 \\, C_{ox} \\, (W/L) \\, I_{D,0}}$$\n应力后迁移率 $\\mu_1$ 使用应力后测量值 $(g_{m,1}, I_{D,1})$ 计算：\n$$\\mu_1 = \\frac{g_{m,1}^2}{2 \\, C_{ox} \\, (W/L) \\, I_{D,1}}$$\n迁移率退化分数 $\\delta_{\\mu}$ 定义为迁移率的相对减少量：\n$$\\delta_{\\mu} = \\frac{\\mu_0 - \\mu_1}{\\mu_0} = 1 - \\frac{\\mu_1}{\\mu_0}$$\n\n**2. 从电荷泵计算界面态密度 ($\\hat{D}_{it}^{CP}$)**\n\n电荷泵 (CP) 技术提供了一种直接量化界面态的方法。每个周期泵浦的电荷量与栅极脉冲扫过的能量范围内的界面陷阱总数成正比。对于频率为 $f$ 的脉冲，产生的直流电流 $I_{CP}$ 由以下公式给出：\n$$I_{CP} = q \\, f \\, A \\, \\langle D_{it} \\rangle \\Delta E$$\n其中 $A = W \\cdot L$ 是沟道面积，$\\langle D_{it} \\rangle$ 是能量窗口 $\\Delta E$ 内的平均界面态密度。问题指定假设密度 $D_{it}$ 均匀，并使用半导体带隙 $E_g$ 作为能量窗口，即 $\\Delta E = E_g$。$E_g$ 的值以 $\\mathrm{eV}$ 为单位给出，公式的结构使其可以直接使用其数值。对 $D_{it}$ 进行整理，我们得到电荷泵估计值 $\\hat{D}_{it}^{CP}$：\n$$\\hat{D}_{it}^{CP} = \\frac{I_{CP}}{q \\, f \\, A \\, E_g}$$\n结果的单位将是所要求的 $\\mathrm{m^{-2}\\,eV^{-1}}$。\n\n**3. 从跨导/阈值电压漂移计算界面态密度 ($\\hat{D}_{it}^{gm}$)**\n\n界面态密度的另一种估计可以从阈值电压漂移 $\\Delta V_{TH}$ 中推导出来，该漂移是由新产生的界面态中捕获的电荷引起的。应力诱导的单位面积界面陷阱电荷 $Q_{it}$ 与阈值电压漂移的关系为：\n$$\\Delta V_{TH} = \\frac{Q_{it}}{C_{ox}}$$\n在能量范围 $\\Delta E = E_g$ 内陷阱密度 $D_{it}$ 均匀的相同模型下，捕获的电荷密度为 $Q_{it} = q \\, D_{it} \\, E_g$。将其代入前一个方程得到：\n$$\\Delta V_{TH} = \\frac{q \\, D_{it} \\, E_g}{C_{ox}}$$\n解出 $D_{it}$，得到我们的第二个估计量 $\\hat{D}_{it}^{gm}$：\n$$\\hat{D}_{it}^{gm} = \\frac{C_{ox} \\, \\Delta V_{TH}}{q \\, E_g}$$\n要使用这个公式，我们必须首先从电学测量中确定 $\\Delta V_{TH}$。$\\Delta V_{TH}$ 定义为 $\\Delta V_{TH} = V_{TH,1} - V_{TH,0}$，其中 $V_{TH,0}$ 是给定的。我们必须提取应力后的阈值电压 $V_{TH,1}$。\n\n根据应力后条件下的跨导定义：\n$$g_{m,1} = \\mu_1 \\, C_{ox} \\, \\frac{W}{L} \\, (V_{GS} - V_{TH,1})$$\n项 $(V_{GS} - V_{TH,1})$ 是应力后的过驱动电压 $V_{OV,1}$。我们可以解出它：\n$$V_{OV,1} = \\frac{g_{m,1}}{\\mu_1 \\, C_{ox} \\, (W/L)}$$\n由于我们已经计算出 $\\mu_1$，我们可以求出 $V_{OV,1}$。然后，应力后的阈值电压是：\n$$V_{TH,1} = V_{GS} - V_{OV,1}$$\n其中 $V_{GS}$ 是进行应力后测量时的栅极电压。有了 $V_{TH,1}$ 和给定的 $V_{TH,0}$，我们就可以计算 $\\Delta V_{TH}$，并随后计算 $\\hat{D}_{it}^{gm}$。\n\n将要实现的算法将对每个提供的测试案例遵循这些步骤。所有计算将使用给定的 SI 单位参数值进行，其中 $E_g$ 按规定用作电子伏特的数值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for interface trap densities and mobility degradation in MOSFETs\n    based on pre- and post-stress electrical measurements.\n    \"\"\"\n    \n    # Elementary charge in Coulombs\n    q = 1.602176634e-19\n\n    # Test cases defined in the problem statement.\n    # Each tuple contains:\n    # (W, L, Cox, Vgs, Vth0, gm0, Id0, gm1, Id1, f_cp, I_cp, Eg)\n    test_cases = [\n        (1.0e-5, 2.0e-7, 1.0e-2, 1.0, 0.30, 1.75e-2, 6.125e-3, 1.38125e-2, 4.4928e-3, 1.0e6, 1.000e-9, 1.12),\n        (1.0e-5, 5.0e-7, 1.0e-2, 0.80, 0.25, 6.60e-3, 1.815e-3, 6.213e-3, 1.692e-3, 2.0e6, 5.000e-10, 1.12),\n        (2.0e-5, 2.0e-7, 1.2e-2, 1.20, 0.35, 4.08e-2, 1.734e-2, 2.1024e-2, 7.665e-3, 5.0e5, 2.878e-9, 1.12)\n    ]\n\n    results_as_strings = []\n\n    for case in test_cases:\n        W, L, C_ox, V_gs, V_th0, g_m0, I_d0, g_m1, I_d1, f_cp, I_cp, E_g = case\n\n        # Geometric parameters\n        A = W * L\n        W_over_L = W / L\n\n        # Step 1: Calculate pre- and post-stress mobility (mu0, mu1)\n        # mu = gm^2 / (2 * Cox * (W/L) * Id)\n        mu0 = g_m0**2 / (2 * C_ox * W_over_L * I_d0)\n        mu1 = g_m1**2 / (2 * C_ox * W_over_L * I_d1)\n\n        # Step 2: Calculate fractional mobility degradation (delta_mu)\n        # delta_mu = (mu0 - mu1) / mu0\n        delta_mu = (mu0 - mu1) / mu0\n\n        # Step 3: Calculate interface trap density from charge pumping (Dit_CP)\n        # Dit_CP = I_cp / (q * f * A * Eg)\n        # Note: E_g is used as its numerical value in eV, as per problem.\n        Dit_CP = I_cp / (q * f_cp * A * E_g)\n\n        # Step 4: Calculate interface trap density from gm/Vth shift (Dit_gm)\n        # First, find post-stress threshold voltage V_th1\n        # Vov1 = gm1 / (mu1 * Cox * (W/L))\n        V_ov1 = g_m1 / (mu1 * C_ox * W_over_L)\n        # Vth1 = Vgs - Vov1\n        V_th1 = V_gs - V_ov1\n\n        # Then, find the threshold voltage shift\n        # delta_Vth = Vth1 - Vth0\n        delta_Vth = V_th1 - V_th0\n\n        # Finally, calculate Dit_gm\n        # Dit_gm = Cox * delta_Vth / (q * Eg)\n        Dit_gm = C_ox * delta_Vth / (q * E_g)\n        \n        # Format results for the current case into a string '[x,y,z]'\n        # with each float in scientific notation with 6 significant digits.\n        case_result_str = (\n            f\"[{Dit_CP:.6e},\"\n            f\"{Dit_gm:.6e},\"\n            f\"{delta_mu:.6e}]\"\n        )\n        results_as_strings.append(case_result_str)\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在对失效数据进行外推以预测器件寿命时，选择合适的统计分布模型（例如Weibull、Lognormal等）是至关重要的一步。本项高级练习将引导您超越简单的数据拟合，进入模型选择的关键领域。您将学习如何结合统计判据（如Akaike信息准则，AIC）与物理约束（如失效率函数的单调性）来评估和选择最恰当的寿命分布模型，这是做出准确可靠的寿命预测并规避模型误设风险的核心能力。",
            "id": "3738740",
            "problem": "开发一个完整的程序，该程序针对代表半导体器件在耗损机制下可靠性的多个合成加速寿命数据集，拟合三种参数化寿命模型，并通过比较它们的赤池信息准则（Akaike Information Criterion, AIC）值和一个基于物理动机的可解释性约束来评估模型误设的风险。这些模型是双参数Weibull模型、双参数对数正态模型和双参数对数逻辑斯蒂模型。使用右删失下的最大似然估计（Maximum Likelihood Estimation, MLE）。时间量必须以秒为单位处理，任何报告的数值除非明确说明，否则必须是无量纲的。所有计算出的角度（如果有）必须以弧度为单位；但本任务不涉及角度。最终程序输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中每个项目对应一个数据集，其本身是一个包含三个值的列表：作为整数的所选模型代码、作为整数的物理可解释性标志，以及所选模型与次优模型之间AIC的差异（浮点数，保留三位小数）。模型代码必须使用以下映射：$0$ 表示Weibull，$1$ 表示对数正态， $2$ 表示对数逻辑斯蒂。如果所选模型表现出与累积损伤耗损机制一致的单调递增风险率，则物理可解释性标志必须为 $1$，否则为 $0$。\n\n从可靠性物理定义开始。对于一个具有概率密度函数 $f(t)$、累积分布函数 $F(t)$、生存函数 $S(t)=1-F(t)$ 和风险函数 $h(t)=\\frac{f(t)}{S(t)}$ 的非负随机寿命 $T$，一个右删失数据集 $\\{(t_i,\\delta_i)\\}_{i=1}^{N}$ 的对数似然函数为\n$$\n\\log L(\\boldsymbol{\\theta})=\\sum_{i=1}^{N} \\left[ \\delta_i \\log f(t_i;\\boldsymbol{\\theta}) + (1-\\delta_i)\\log S(t_i;\\boldsymbol{\\theta}) \\right],\n$$\n其中 $t_i$ 是观测时间（如果未删失则为失效时间，如果删失则为删失时间），$\\delta_i \\in \\{0,1\\}$ 是事件指示符（$\\delta_i=1$ 表示观测到失效，$\\delta_i=0$ 表示右删失），$\\boldsymbol{\\theta}$ 是模型参数。最大似然估计（MLE）旨在最大化 $\\log L(\\boldsymbol{\\theta})$。赤池信息准则（AIC）定义为 $AIC=2k-2\\log L(\\widehat{\\boldsymbol{\\theta}})$，其中 $k$ 是自由参数的数量，$\\widehat{\\boldsymbol{\\theta}}$ 是MLE估计值。首次使用时定义缩写：最大似然估计（Maximum Likelihood Estimation, MLE）和赤池信息准则（Akaike Information Criterion, AIC）。\n\n使用以下参数模型：\n\n- Weibull模型，具有形状参数 $m0$ 和尺度参数 $\\eta0$，其\n$$\nf_{\\text{W}}(t;m,\\eta)=\\frac{m}{\\eta}\\left(\\frac{t}{\\eta}\\right)^{m-1}\\exp\\left[-\\left(\\frac{t}{\\eta}\\right)^m\\right], \\quad\nS_{\\text{W}}(t;m,\\eta)=\\exp\\left[-\\left(\\frac{t}{\\eta}\\right)^m\\right], \\quad\nh_{\\text{W}}(t;m,\\eta)=\\frac{m}{\\eta}\\left(\\frac{t}{\\eta}\\right)^{m-1}.\n$$\n注意，$h_{\\text{W}}(t)$ 在 $m1$ 时单调递增，在 $m=1$ 时为常数（指数分布），在 $m1$ 时单调递减。\n\n- 对数正态模型，其参数为 $\\mu \\in \\mathbb{R}$ 和 $\\sigma0$，其中 $\\ln T \\sim \\mathcal{N}(\\mu,\\sigma^2)$，其\n$$\nf_{\\text{LN}}(t;\\mu,\\sigma)=\\frac{1}{t\\sigma \\sqrt{2\\pi}}\\exp\\left[-\\frac{(\\ln t - \\mu)^2}{2\\sigma^2}\\right], \\quad\nS_{\\text{LN}}(t;\\mu,\\sigma)=1-\\Phi\\left(\\frac{\\ln t - \\mu}{\\sigma}\\right),\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数。在典型参数范围内，$h_{\\text{LN}}(t)$ 是单峰的，且不单调递增。\n\n- 对数逻辑斯蒂模型，具有尺度参数 $\\alpha0$ 和形状参数 $\\beta0$，其\n$$\nf_{\\text{LL}}(t;\\alpha,\\beta)=\\frac{\\beta}{\\alpha}\\left(\\frac{t}{\\alpha}\\right)^{\\beta-1}\\left[1+\\left(\\frac{t}{\\alpha}\\right)^{\\beta}\\right]^{-2}, \\quad\nS_{\\text{LL}}(t;\\alpha,\\beta)=\\left[1+\\left(\\frac{t}{\\alpha}\\right)^{\\beta}\\right]^{-1}.\n$$\n在典型参数范围内，$h_{\\text{LL}}(t)$ 也是单峰的，且不严格单调递增。\n\n物理可解释性约束的动机源于半导体可靠性物理学中的累积损伤和逾渗型退化现象，例如时间依赖性介质击穿（Time-Dependent Dielectric Breakdown, TDDB）和电迁移（Electromigration, EM），在这些现象中，损伤累积会产生一个以风险率随时间增加为特征的耗损阶段。在本任务中，将物理可解释性操作化为单调递增的风险率；在三种模型中，只有当 $m1$ 时的Weibull模型满足此条件。\n\n模型选择必须结合统计充分性和基于物理的可解释性，采用以下规则：\n- 计算所有三个模型的 $AIC$。\n- 令 $AIC_{\\min}$ 为三个模型中的最小 $AIC$。将所有满足 $AIC - AIC_{\\min} \\le \\Delta$ 的模型定义为候选集，其中 $\\Delta=2$ 是具有可比支持度的模型的常规容差。\n- 如果任何候选模型满足物理可解释性约束（$m1$ 的Weibull模型），则在这些模型中选择具有最小 $AIC$ 的那个。\n- 否则，选择总体上具有最小 $AIC$ 的模型。\n- 如果所选模型满足约束，则报告物理可解释性标志为 $1$，否则为 $0$。\n- 报告与次优模型之间的 $AIC$ 差异为 $AIC_{\\text{runner-up}} - AIC_{\\text{selected}}$，保留三位小数，其中 $AIC_{\\text{runner-up}}$ 是未被选中模型中的最小 $AIC$。\n\n为实现科学真实性，使用右删失下的MLE进行拟合，参数限制在其物理上有意义的域内，并通过在对数空间中对正参数进行重新参数化来支持稳定的优化。程序必须为每个模型实现对数似然函数，并使用数值优化求解MLE。\n\n测试套件定义和数据集生成：\n- 对于每个数据集，从指定的真实分布中抽取独立样本，然后在指定的删失时间应用右删失。为保证可复现性，使用指定的整数种子进行确定性伪随机生成。所有时间必须以秒为单位。\n- 数据集 $\\mathcal{D}_1$：真实分布为Weibull，形状参数 $m=2.2$，尺度参数 $\\eta=1200$ s，样本量 $N=50$，在 $1500$ s处右删失，种子 $0$。\n- 数据集 $\\mathcal{D}_2$：真实分布为对数正态，参数 $\\mu=6.5$ 和 $\\sigma=0.3$，样本量 $N=60$，在 $900$ s处右删失，种子 $1$。\n- 数据集 $\\mathcal{D}_3$：真实分布为对数逻辑斯蒂，尺度参数 $\\alpha=800$ s，形状参数 $\\beta=1.5$，样本量 $N=70$，在 $1200$ s处右删失，种子 $2$。\n- 数据集 $\\mathcal{D}_4$：真实分布为Weibull，形状参数 $m=1.0$，尺度参数 $\\eta=900$ s，样本量 $N=80$，在 $1000$ s处右删失，种子 $3$。\n- 数据集 $\\mathcal{D}_5$：真实分布为Weibull，形状参数 $m=1.2$，尺度参数 $\\eta=1000$ s，样本量 $N=25$，在 $1100$ s处右删失，种子 $4$。\n\n输出规范：\n- 对于每个数据集 $\\mathcal{D}_j$，你的程序必须生成列表 $[c_j, p_j, d_j]$，其中 $c_j$ 是所选模型的代码（$0$ 表示Weibull, $1$ 表示对数正态, $2$ 表示对数逻辑斯蒂），$p_j$ 是物理可解释性标志（$1$ 或 $0$），$d_j$ 是浮点数 $AIC_{\\text{runner-up}} - AIC_{\\text{selected}}$，保留三位小数。\n- 你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[[0,1,1.234],[1,0,0.567]]$，不含任何额外文本。\n\n科学和算法约束：\n- 在删失情况下，仅使用数值稳定的计算方法来计算对数似然。\n- 通过数值优化对数似然函数来拟合所有三个模型，并强制参数在其有效域内（对于正参数，优化其对数）。\n- 使用 $\\Delta=2$ 的候选选择规则，在统计上可比的情况下优先选择物理上可解释的模型。\n\n你的最终代码必须是一个完整的、可运行的程序，对指定的测试套件执行上述步骤，并打印所需的单行输出。不允许用户输入、文件或网络访问。",
            "solution": "问题陈述经过了仔细验证，被确定为是合理的。它在可靠性物理和统计建模方面有科学依据，问题定义清晰，指令完整，并且内部一致。所有必要的数据、模型和程序都已指定，使其成为一个可解的问题。因此，下面提供了一个完整的解决方案。\n\n该任务的核心是对三个寿命分布模型——Weibull、对数正态和对数逻辑斯蒂——在几个代表半导体器件失效的合成数据集上进行比较分析。该分析涉及三个主要阶段：数据生成、通过右删失下的最大似然估计（MLE）进行模型拟合，以及使用结合了统计拟合度（通过赤池信息准则，AIC）和物理可解释性约束的混合准则进行模型选择。\n\n首先，根据规范生成必要的数据集。为每个数据集定义一个父分布，并抽取指定大小的样本。然后应用右删失，即任何超过给定删失时间的失效时间都替换为该删失时间，并将其状态标记为已删失。此过程模拟了加速寿命测试，其中实验在所有器件失效前终止。为了可复现性，每个数据集都使用特定的伪随机数生成器种子。所有时间量均以秒（s）为单位处理。\n\n其次，对于每个数据集，我们拟合三个指定的参数化寿命模型。拟合过程基于最大化右删失数据的对数似然函数。给定一个包含 $N$ 个观测值 $\\{(t_i, \\delta_i)\\}_{i=1}^{N}$ 的数据集，其中 $t_i$ 是时间，$\\delta_i$ 是失效指示符（$1$ 表示失效，$0$ 表示删失），对数似然函数为：\n$$\n\\log L(\\boldsymbol{\\theta}) = \\sum_{i=1}^{N} \\left[ \\delta_i \\log f(t_i; \\boldsymbol{\\theta}) + (1-\\delta_i) \\log S(t_i; \\boldsymbol{\\theta}) \\right]\n$$\n这里，$f(t; \\boldsymbol{\\theta})$ 是概率密度函数（PDF），$S(t; \\boldsymbol{\\theta})$ 是生存函数（$S(t) = 1-F(t)$，其中 $F(t)$ 是累积分布函数），$\\boldsymbol{\\theta}$ 代表模型参数。最大似然估计（MLE）在于找到使该函数最大化的参数值 $\\widehat{\\boldsymbol{\\theta}}$。在计算上，这是通过使用数值优化算法最小化负对数似然来实现的。为确保模型参数保持在其有效域内（例如，形状和尺度参数必须为正），我们对其进行重新参数化。对于一个正参数 $p$，我们在实数线上优化其对数 $\\log p$。\n\n作为我们数值最小化目标函数的具体负对数似然函数如下。请注意，它们的公式是为了数值稳定性而设计的，例如通过在对数上进行操作。\n\n1.  **Weibull模型**：参数为形状 $m0$ 和尺度 $\\eta0$。我们在 $\\boldsymbol{\\phi} = [\\log m, \\log \\eta]$ 上进行优化。\n    对数PDF为 $\\log f_{\\text{W}}(t) = \\log m + (m-1)\\log t - m\\log\\eta - (t/\\eta)^m$。\n    对数生存函数为 $\\log S_{\\text{W}}(t) = -(t/\\eta)^m$。\n    总对数似然为 $\\sum_{i=1}^N \\left[ \\delta_i(\\log m + (m-1)\\log t_i - m\\log\\eta) - (t_i/\\eta)^m \\right]$。\n\n2.  **对数正态模型**：参数为 $\\mu \\in \\mathbb{R}$ 和 $\\sigma0$，对应于 $\\log T$ 的底层正态分布。我们在 $\\boldsymbol{\\phi} = [\\mu, \\log \\sigma]$ 上进行优化。\n    对数PDF为 $\\log f_{\\text{LN}}(t) = -\\log t + \\log f_{\\mathcal{N}}(\\log t; \\mu, \\sigma)$，其中 $f_{\\mathcal{N}}$ 是正态PDF。\n    对数生存函数为 $\\log S_{\\text{LN}}(t) = \\log S_{\\mathcal{N}}(\\log t; \\mu, \\sigma)$，其中 $S_{\\mathcal{N}}$ 是正态生存函数。为保证数值稳定性，最好使用库函数来计算正态分布的对数PDF和对数生存函数（logsf）。\n\n3.  **对数逻辑斯蒂模型**：参数为尺度 $\\alpha  0$ 和形状 $\\beta  0$。我们在 $\\boldsymbol{\\phi} = [\\log \\alpha, \\log \\beta]$ 上进行优化。\n    对数PDF为 $\\log f_{\\text{LL}}(t) = \\log\\beta + (\\beta-1)\\log t - \\beta\\log\\alpha - 2\\log(1 + (t/\\alpha)^\\beta)$。\n    对数生存函数为 $\\log S_{\\text{LL}}(t) = -\\log(1 + (t/\\alpha)^\\beta)$。我们使用 `np.log1p` 来计算 $\\log(1+x)$ 项以保持精度。\n\n第三，在获得每个模型的MLE参数 $\\widehat{\\boldsymbol{\\theta}}$ 和相应的最大对数似然值 $\\log L(\\widehat{\\boldsymbol{\\theta}})$ 后，我们计算赤池信息准则（AIC），它是预测误差的估计量，从而可以衡量给定数据集下统计模型的相对质量。其定义为：\n$$\nAIC = 2k - 2\\log L(\\widehat{\\boldsymbol{\\theta}})\n$$\n其中 $k$ 是模型中估计参数的数量。对于这里考虑的所有三个模型，$k=2$。\n\n最后，我们应用指定的模型选择规则。该规则将统计证据（AIC）与基于物理的约束相结合。该约束反映了半导体器件中常见的耗损失效机制应表现出单调递增的风险函数的期望。在三个模型中，只有形状参数 $m  1$ 的Weibull模型满足此条件。\n\n选择过程如下：\n1.  计算所有三个模型的AIC。令最小AIC为 $AIC_{\\min}$。\n2.  形成一个候选集，其中包含AIC值接近最小值的模型，具体为满足 $AIC - AIC_{\\min} \\le \\Delta$ 的模型，指定的容差为 $\\Delta=2$。\n3.  检查该候选集是否包含任何物理上可解释的模型（即，$\\widehat{m}  1$ 的Weibull拟合）。\n4.  如果包含，则选择的模型是这个可解释候选子集中具有最低AIC的模型。\n5.  如果不包含，则选择的模型就是总体上具有最小AIC的模型。\n\n一旦选定了最佳模型，我们确定物理可解释性标志（如果所选模型是 $\\widehat{m}1$ 的Weibull模型，则为 $1$，否则为 $0$）。我们还计算所选模型与拟合最好的未选模型（次优模型）之间的AIC差异。每个数据集的最终输出是一个列表，包含所选模型的代码（$0$: Weibull, $1$: 对数正态, $2$: 对数逻辑斯蒂）、可解释性标志和计算出的AIC差异。对五个指定的数据集中的每一个都重复此整个过程。实现使用 `scipy.optimize.minimize` 进行MLE，并使用 `numpy` 进行数值计算和数据生成。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import norm\n\n# Suppress runtime warnings from log(0) or overflow which can occur during optimization\n# The optimizer should handle these by moving away from such parameter regions.\nnp.seterr(all='ignore')\n\ndef generate_dataset(dist_name, params, N, censor_time, seed):\n    \"\"\"\n    Generates a right-censored dataset from a specified distribution.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    if dist_name == 'weibull':\n        m, eta = params\n        # numpy's weibull is shape-only, scale is applied manually.\n        failure_times = eta * rng.weibull(m, size=N)\n    elif dist_name == 'lognormal':\n        mu, sigma = params\n        failure_times = rng.lognormal(mean=mu, sigma=sigma, size=N)\n    elif dist_name == 'loglogistic':\n        alpha, beta = params\n        u = rng.uniform(size=N)\n        failure_times = alpha * (u / (1.0 - u))**(1.0 / beta)\n    else:\n        raise ValueError(\"Unknown distribution\")\n\n    observed_times = np.minimum(failure_times, censor_time)\n    delta = (failure_times = censor_time).astype(int)\n    \n    # Filter out t=0 if any, as log(t) is undefined. Lifetimes are positive.\n    valid_indices = observed_times > 0\n    return observed_times[valid_indices], delta[valid_indices]\n\ndef neg_log_likelihood_weibull(params, t, delta):\n    \"\"\"Negative log-likelihood for the Weibull distribution.\"\"\"\n    log_m, log_eta = params\n    m = np.exp(log_m)\n    eta = np.exp(log_eta)\n    \n    # Ensure t is a numpy array for vectorized operations\n    t = np.asarray(t)\n\n    # Use log-space for numerical stability\n    log_t = np.log(t)\n    log_eta_val = np.log(eta)\n    \n    # Term (t/eta)^m can be large, compute carefully\n    log_t_eta_m = m * (log_t - log_eta_val)\n    t_eta_m = np.exp(log_t_eta_m)\n\n    log_f = log_m + (m - 1.0) * log_t - m * log_eta_val - t_eta_m\n    log_S = -t_eta_m\n    \n    log_likelihood = np.sum(delta * log_f + (1 - delta) * log_S)\n    \n    if np.isnan(log_likelihood) or np.isinf(log_likelihood):\n        return np.inf\n        \n    return -log_likelihood\n\ndef neg_log_likelihood_lognormal(params, t, delta):\n    \"\"\"Negative log-likelihood for the Log-Normal distribution.\"\"\"\n    mu, log_sigma = params\n    sigma = np.exp(log_sigma)\n    \n    t = np.asarray(t)\n    log_t = np.log(t)\n    \n    log_f = norm.logpdf(log_t, loc=mu, scale=sigma) - log_t\n    log_S = norm.logsf(log_t, loc=mu, scale=sigma)\n    \n    log_likelihood = np.sum(delta * log_f + (1 - delta) * log_S)\n    \n    if np.isnan(log_likelihood) or np.isinf(log_likelihood):\n        return np.inf\n        \n    return -log_likelihood\n\ndef neg_log_likelihood_loglogistic(params, t, delta):\n    \"\"\"Negative log-likelihood for the Log-Logistic distribution.\"\"\"\n    log_alpha, log_beta = params\n    alpha = np.exp(log_alpha)\n    beta = np.exp(log_beta)\n    \n    t = np.asarray(t)\n\n    # Use log-space for numerical stability\n    log_t = np.log(t)\n    log_alpha_val = np.log(alpha)\n\n    t_alpha_beta = np.exp(beta * (log_t - log_alpha_val))\n    \n    log_f = np.log(beta) + (beta - 1.0)*log_t - beta*log_alpha_val - 2.0*np.log1p(t_alpha_beta)\n    log_S = -np.log1p(t_alpha_beta)\n    \n    log_likelihood = np.sum(delta * log_f + (1 - delta) * log_S)\n    \n    if np.isnan(log_likelihood) or np.isinf(log_likelihood):\n        return np.inf\n        \n    return -log_likelihood\n\ndef fit_and_evaluate(times, delta):\n    \"\"\"Fits all three models and returns their AIC and parameters.\"\"\"\n    models_results = []\n    \n    # Use observed failures to make smarter initial guesses\n    log_times_uncensored = np.log(times[delta == 1])\n    if len(log_times_uncensored) == 0: # handle fully censored data\n      log_times_uncensored = np.log(times)\n\n    # Initial guesses\n    x0_w = [np.log(1.5), np.log(np.mean(times))] # log_m, log_eta\n    x0_ln = [np.mean(log_times_uncensored), np.log(np.std(log_times_uncensored, ddof=1) + 1e-6)] # mu, log_sigma\n    x0_ll = [np.log(np.median(times)), np.log(1.5)] # log_alpha, log_beta\n\n    # 1. Weibull\n    res_w = minimize(neg_log_likelihood_weibull, x0=x0_w, args=(times, delta), method='Nelder-Mead')\n    if res_w.success:\n        k_w = 2\n        aic_w = 2 * k_w + 2 * res_w.fun\n        m_hat = np.exp(res_w.x[0])\n        eta_hat = np.exp(res_w.x[1])\n        models_results.append({'name': 'Weibull', 'aic': aic_w, 'params': {'m': m_hat, 'eta': eta_hat}, 'code': 0})\n\n    # 2. Log-Normal\n    res_ln = minimize(neg_log_likelihood_lognormal, x0=x0_ln, args=(times, delta), method='Nelder-Mead')\n    if res_ln.success:\n        k_ln = 2\n        aic_ln = 2 * k_ln + 2 * res_ln.fun\n        mu_hat = res_ln.x[0]\n        sigma_hat = np.exp(res_ln.x[1])\n        models_results.append({'name': 'Log-Normal', 'aic': aic_ln, 'params': {'mu': mu_hat, 'sigma': sigma_hat}, 'code': 1})\n        \n    # 3. Log-Logistic\n    res_ll = minimize(neg_log_likelihood_loglogistic, x0=x0_ll, args=(times, delta), method='Nelder-Mead')\n    if res_ll.success:\n        k_ll = 2\n        aic_ll = 2 * k_ll + 2 * res_ll.fun\n        alpha_hat = np.exp(res_ll.x[0])\n        beta_hat = np.exp(res_ll.x[1])\n        models_results.append({'name': 'Log-Logistic', 'aic': aic_ll, 'params': {'alpha': alpha_hat, 'beta': beta_hat}, 'code': 2})\n\n    return models_results\n\ndef select_model(models_results):\n    \"\"\"\n    Selects the best model based on AIC and physical interpretability.\n    \"\"\"\n    if not models_results:\n        return None\n\n    # Sort models by AIC\n    sorted_models = sorted(models_results, key=lambda x: x['aic'])\n    aic_min = sorted_models[0]['aic']\n    \n    # Identify candidate set\n    delta_aic_tolerance = 2.0\n    candidate_set = [m for m in sorted_models if m['aic'] - aic_min = delta_aic_tolerance]\n    \n    # Check for physically interpretable models in the candidate set\n    interpretable_candidates = []\n    for m in candidate_set:\n        if m['name'] == 'Weibull' and m['params']['m'] > 1.0:\n            interpretable_candidates.append(m)\n            \n    # Apply selection rule\n    if interpretable_candidates:\n        # Select the interpretable model with the lowest AIC\n        selected_model = min(interpretable_candidates, key=lambda x: x['aic'])\n    else:\n        # Select the model with the overall lowest AIC\n        selected_model = sorted_models[0]\n        \n    # Determine interpretability flag\n    is_interpretable = 1 if selected_model['name'] == 'Weibull' and selected_model['params']['m'] > 1.0 else 0\n    \n    # Find runner-up AIC\n    non_selected_models = [m for m in sorted_models if m['name'] != selected_model['name']]\n    if non_selected_models:\n        runner_up_aic = non_selected_models[0]['aic']\n        aic_diff = runner_up_aic - selected_model['aic']\n    else: # Should not happen with 3 models\n        aic_diff = 0.0\n\n    return [selected_model['code'], is_interpretable, aic_diff]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        {'name': 'D1', 'dist': 'weibull',     'params': (2.2, 1200.0), 'N': 50, 'censor_t': 1500.0, 'seed': 0},\n        {'name': 'D2', 'dist': 'lognormal',   'params': (6.5, 0.3),    'N': 60, 'censor_t': 900.0,  'seed': 1},\n        {'name': 'D3', 'dist': 'loglogistic', 'params': (800.0, 1.5),  'N': 70, 'censor_t': 1200.0, 'seed': 2},\n        {'name': 'D4', 'dist': 'weibull',     'params': (1.0, 900.0),  'N': 80, 'censor_t': 1000.0, 'seed': 3},\n        {'name': 'D5', 'dist': 'weibull',     'params': (1.2, 1000.0), 'N': 25, 'censor_t': 1100.0, 'seed': 4},\n    ]\n\n    results = []\n    for case in test_cases:\n        times, delta = generate_dataset(case['dist'], case['params'], case['N'], case['censor_t'], case['seed'])\n        \n        # Fit models and get AICs\n        fitted_models = fit_and_evaluate(times, delta)\n\n        # Select model and compute final stats\n        result_vector = select_model(fitted_models)\n        results.append(result_vector)\n    \n    # Format the final output string as per requirements\n    result_strings = [f\"[{res[0]},{res[1]},{res[2]:.3f}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}