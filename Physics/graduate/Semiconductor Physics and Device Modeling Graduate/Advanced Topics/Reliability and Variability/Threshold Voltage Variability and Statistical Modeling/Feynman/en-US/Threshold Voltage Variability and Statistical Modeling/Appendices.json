{
    "hands_on_practices": [
        {
            "introduction": "The performance and reliability of semiconductor devices are fundamentally limited by unavoidable, random variations in the manufacturing process. This exercise provides a first-principles look at how these microscopic fluctuations in physical parameters, such as oxide thickness ($t_{ox}$) and dopant concentration ($N_A$), propagate to affect a critical device parameter: the threshold voltage ($V_{th}$). By applying first-order sensitivity analysis, you will quantitatively determine how much each source of variation contributes to the total standard deviation of $V_{th}$, offering a foundational understanding of variability from the bottom up. ",
            "id": "3783379",
            "problem": "A planar long-channel n-channel Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) is fabricated on uniformly doped p-type silicon with acceptor concentration $N_A$. Threshold is defined by the onset of strong inversion when the surface potential equals twice the Fermi potential. Neglect fixed oxide charge, interface states, polysilicon depletion, and body bias. Assume temperature $T$ is constant and the oxide is an ideal dielectric.\n\nYou are given the following nominal parameters and physical constants:\n- Nominal acceptor doping $N_{A,0} = 1.0 \\times 10^{17}\\,\\text{cm}^{-3}$,\n- Nominal oxide thickness $t_{ox,0} = 1.5\\,\\text{nm}$,\n- Nominal metal–semiconductor work function difference $\\phi_{ms,0} = -0.45\\,\\text{V}$,\n- Intrinsic carrier concentration in silicon at $300\\,\\text{K}$: $n_i = 1.0 \\times 10^{10}\\,\\text{cm}^{-3}$,\n- Temperature $T = 300\\,\\text{K}$,\n- Elementary charge $q = 1.602 \\times 10^{-19}\\,\\text{C}$,\n- Boltzmann constant $k_B = 1.381 \\times 10^{-23}\\,\\text{J/K}$,\n- Vacuum permittivity $\\varepsilon_0 = 8.854 \\times 10^{-12}\\,\\text{F/m}$,\n- Silicon permittivity $\\varepsilon_{si} = 11.7\\,\\varepsilon_0$,\n- Silicon dioxide permittivity $\\varepsilon_{ox} = 3.9\\,\\varepsilon_0$.\n\nMetrology reports the following measured standard deviations for the three independent sources of variability:\n- Oxide thickness standard deviation $\\sigma_{t_{ox}} = 0.040\\,\\text{nm}$,\n- Metal–semiconductor work function difference standard deviation $\\sigma_{\\phi_{ms}} = 0.020\\,\\text{V}$,\n- Acceptor doping standard deviation $\\sigma_{N_A} = 2.5 \\times 10^{15}\\,\\text{cm}^{-3}$.\n\nUsing first-order sensitivity analysis and assuming these three sources are independent, estimate the standard deviation of the threshold voltage, $\\sigma_{V_{th}}$, by propagating the uncertainties from $t_{ox}$, $\\phi_{ms}$, and $N_A$ about the nominal operating point. Treat $n_i$ and $T$ as non-random constants. Express the final value in volts and round your answer to three significant figures.",
            "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\nThe following data and conditions are provided:\n-   **Device Type**: Planar long-channel n-channel MOSFET on uniformly doped p-type silicon.\n-   **Nominal Parameters**:\n    -   Acceptor doping: $N_{A,0} = 1.0 \\times 10^{17}\\,\\text{cm}^{-3}$\n    -   Oxide thickness: $t_{ox,0} = 1.5\\,\\text{nm}$\n    -   Metal–semiconductor work function difference: $\\phi_{ms,0} = -0.45\\,\\text{V}$\n-   **Standard Deviations of Independent Variables**:\n    -   Oxide thickness: $\\sigma_{t_{ox}} = 0.040\\,\\text{nm}$\n    -   Work function difference: $\\sigma_{\\phi_{ms}} = 0.020\\,\\text{V}$\n    -   Acceptor doping: $\\sigma_{N_A} = 2.5 \\times 10^{15}\\,\\text{cm}^{-3}$\n-   **Physical Constants and Conditions**:\n    -   Intrinsic carrier concentration: $n_i = 1.0 \\times 10^{10}\\,\\text{cm}^{-3}$\n    -   Temperature: $T = 300\\,\\text{K}$\n    -   Elementary charge: $q = 1.602 \\times 10^{-19}\\,\\text{C}$\n    -   Boltzmann constant: $k_B = 1.381 \\times 10^{-23}\\,\\text{J/K}$\n    -   Vacuum permittivity: $\\varepsilon_0 = 8.854 \\times 10^{-12}\\,\\text{F/m}$\n    -   Silicon permittivity: $\\varepsilon_{si} = 11.7\\,\\varepsilon_0$\n    -   Silicon dioxide permittivity: $\\varepsilon_{ox} = 3.9\\,\\varepsilon_0$\n-   **Definitions and Assumptions**:\n    -   Threshold condition: Strong inversion, where surface potential $\\psi_s = 2\\phi_F$ (and $\\phi_F$ is the Fermi potential).\n    -   Neglect: fixed oxide charge ($Q_f$), interface states ($Q_{it}$), polysilicon depletion, and body bias.\n    -   $n_i$ and $T$ are non-random constants.\n-   **Task**: Estimate the standard deviation of the threshold voltage, $\\sigma_{V_{th}}$, using first-order sensitivity analysis.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in standard semiconductor device physics, specifically the theory of MOSFET operation. The provided model for threshold voltage and the requested method of statistical analysis (first-order propagation of uncertainty) are standard in the field. The problem is well-posed, providing all necessary parameters and constants to arrive at a unique numerical solution. The language is objective and precise. The numerical values are physically realistic for a modern silicon device. The problem does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be provided.\n\n### Solution Derivation\nThe threshold voltage, $V_{th}$, for a long-channel n-MOSFET under the specified assumptions (no fixed or interface charge, no body bias) is given by:\n$$V_{th} = \\phi_{ms} + 2\\phi_F + \\frac{|Q_{dep}|}{C_{ox}}$$\nwhere $\\phi_{ms}$ is the metal-semiconductor work function difference, $\\phi_F$ is the bulk Fermi potential, $C_{ox}$ is the oxide capacitance per unit area, and $|Q_{dep}|$ is the magnitude of the depletion charge per unit area at the onset of strong inversion ($\\psi_s = 2\\phi_F$).\n\nThe components of this equation are expressed in terms of the variable parameters $N_A$ and $t_{ox}$:\nThe Fermi potential $\\phi_F$ for p-type silicon is:\n$$\\phi_F = \\frac{k_B T}{q} \\ln\\left(\\frac{N_A}{n_i}\\right)$$\nThe oxide capacitance per unit area $C_{ox}$ is:\n$$C_{ox} = \\frac{\\varepsilon_{ox}}{t_{ox}}$$\nThe depletion charge magnitude at $\\psi_s = 2\\phi_F$ is:\n$$|Q_{dep}| = \\sqrt{2q\\varepsilon_{si}N_A(2\\phi_F)} = \\sqrt{4q\\varepsilon_{si}N_A\\phi_F}$$\nSubstituting these into the $V_{th}$ equation gives the full expression as a function of the independent variables $t_{ox}$, $\\phi_{ms}$, and $N_A$:\n$$V_{th}(t_{ox}, \\phi_{ms}, N_A) = \\phi_{ms} + 2\\phi_F + \\frac{t_{ox}}{\\varepsilon_{ox}}\\sqrt{4q\\varepsilon_{si}N_A\\phi_F}$$\n\nThe problem requires a first-order sensitivity analysis. Since the sources of variation ($t_{ox}$, $\\phi_{ms}$, $N_A$) are independent, the variance of the threshold voltage, $\\sigma_{V_{th}}^2$, is approximated by the sum of the squared sensitivities multiplied by the variances of the respective parameters:\n$$\\sigma_{V_{th}}^2 \\approx \\left(\\frac{\\partial V_{th}}{\\partial t_{ox}}\\right)^2 \\sigma_{t_{ox}}^2 + \\left(\\frac{\\partial V_{th}}{\\partial \\phi_{ms}}\\right)^2 \\sigma_{\\phi_{ms}}^2 + \\left(\\frac{\\partial V_{th}}{\\partial N_A}\\right)^2 \\sigma_{N_A}^2$$\nThe partial derivatives (sensitivities) are evaluated at the nominal parameter values.\n\n1.  **Sensitivity to $\\phi_{ms}$**:\n    $$\\frac{\\partial V_{th}}{\\partial \\phi_{ms}} = 1$$\n\n2.  **Sensitivity to $t_{ox}$**:\n    $$\\frac{\\partial V_{th}}{\\partial t_{ox}} = \\frac{\\partial}{\\partial t_{ox}} \\left( \\frac{t_{ox}}{\\varepsilon_{ox}}\\sqrt{4q\\varepsilon_{si}N_A\\phi_F} \\right) = \\frac{\\sqrt{4q\\varepsilon_{si}N_A\\phi_F}}{\\varepsilon_{ox}}$$\n\n3.  **Sensitivity to $N_A$**:\n    Both $\\phi_F$ and the depletion charge term depend on $N_A$. We define the thermal voltage $V_T = k_B T / q$. The derivative of $\\phi_F$ with respect to $N_A$ is $\\frac{\\partial \\phi_F}{\\partial N_A} = \\frac{V_T}{N_A}$.\n    $$\\frac{\\partial V_{th}}{\\partial N_A} = \\frac{\\partial(2\\phi_F)}{\\partial N_A} + \\frac{1}{C_{ox}} \\frac{\\partial}{\\partial N_A} \\left( \\sqrt{4q\\varepsilon_{si}N_A\\phi_F} \\right)$$\n    The first term is $\\frac{\\partial(2\\phi_F)}{\\partial N_A} = \\frac{2V_T}{N_A}$.\n    For the second term, using the chain rule:\n    $$\\frac{\\partial}{\\partial N_A} \\sqrt{4q\\varepsilon_{si}N_A\\phi_F} = \\frac{4q\\varepsilon_{si}}{2\\sqrt{4q\\varepsilon_{si}N_A\\phi_F}} \\left(1 \\cdot \\phi_F + N_A \\cdot \\frac{\\partial \\phi_F}{\\partial N_A}\\right) = \\sqrt{\\frac{q\\varepsilon_{si}}{N_A\\phi_F}}(\\phi_F + V_T)$$\n    Combining the terms, the sensitivity to $N_A$ is:\n    $$\\frac{\\partial V_{th}}{\\partial N_A} = \\frac{2V_T}{N_A} + \\frac{1}{C_{ox}}\\sqrt{\\frac{q\\varepsilon_{si}}{N_A\\phi_F}}(\\phi_F + V_T)$$\n\n### Numerical Calculation\nAll parameters are converted to SI units.\n-   $\\varepsilon_{si} = 11.7 \\times (8.854 \\times 10^{-12}\\,\\text{F/m}) \\approx 1.036 \\times 10^{-10}\\,\\text{F/m}$\n-   $\\varepsilon_{ox} = 3.9 \\times (8.854 \\times 10^{-12}\\,\\text{F/m}) \\approx 3.453 \\times 10^{-11}\\,\\text{F/m}$\n-   $N_{A,0} = 1.0 \\times 10^{17}\\,\\text{cm}^{-3} = 1.0 \\times 10^{23}\\,\\text{m}^{-3}$\n-   $t_{ox,0} = 1.5\\,\\text{nm} = 1.5 \\times 10^{-9}\\,\\text{m}$\n-   $n_i = 1.0 \\times 10^{10}\\,\\text{cm}^{-3} = 1.0 \\times 10^{16}\\,\\text{m}^{-3}$\n-   $\\sigma_{t_{ox}} = 0.040\\,\\text{nm} = 4.0 \\times 10^{-11}\\,\\text{m}$\n-   $\\sigma_{N_A} = 2.5 \\times 10^{15}\\,\\text{cm}^{-3} = 2.5 \\times 10^{21}\\,\\text{m}^{-3}$\n-   $\\sigma_{\\phi_{ms}} = 0.020\\,\\text{V}$\n\nFirst, we calculate the values of intermediate quantities at the nominal point:\n-   Thermal voltage: $V_T = \\frac{k_B T}{q} = \\frac{(1.381 \\times 10^{-23}\\,\\text{J/K})(300\\,\\text{K})}{1.602 \\times 10^{-19}\\,\\text{C}} \\approx 0.02586\\,\\text{V}$\n-   Fermi potential: $\\phi_F = V_T \\ln\\left(\\frac{N_{A,0}}{n_i}\\right) = (0.02586\\,\\text{V})\\ln\\left(\\frac{1.0 \\times 10^{23}}{1.0 \\times 10^{16}}\\right) = (0.02586\\,\\text{V})\\ln(10^7) \\approx 0.4172\\,\\text{V}$\n-   Oxide capacitance: $C_{ox} = \\frac{\\varepsilon_{ox}}{t_{ox,0}} = \\frac{3.453 \\times 10^{-11}\\,\\text{F/m}}{1.5 \\times 10^{-9}\\,\\text{m}} \\approx 0.02302\\,\\text{F/m}^2$\n\nNext, we evaluate the sensitivities numerically:\n-   $\\frac{\\partial V_{th}}{\\partial \\phi_{ms}} = 1$\n-   $\\frac{\\partial V_{th}}{\\partial t_{ox}} = \\frac{\\sqrt{4(1.602 \\times 10^{-19})(1.036 \\times 10^{-10})(10^{23})(0.4172)}}{3.453 \\times 10^{-11}} \\approx 4.818 \\times 10^7\\,\\text{V/m}$\n-   $\\frac{\\partial V_{th}}{\\partial N_A} = \\frac{2(0.02586)}{10^{23}} + \\frac{1}{0.02302}\\sqrt{\\frac{1.602 \\times 10^{-19} \\cdot 1.036 \\times 10^{-10}}{10^{23} \\cdot 0.4172}}(0.4172 + 0.02586)$\n    $\\frac{\\partial V_{th}}{\\partial N_A} \\approx 5.172 \\times 10^{-25} + 3.829 \\times 10^{-25} = 9.001 \\times 10^{-25}\\,\\text{V}\\cdot\\text{m}^3$\n\nNow, we compute the contribution of each parameter to the total variance:\n-   Contribution from $\\phi_{ms}$:\n    $(\\frac{\\partial V_{th}}{\\partial \\phi_{ms}})^2 \\sigma_{\\phi_{ms}}^2 = (1)^2(0.020)^2 = 4.0 \\times 10^{-4}\\,\\text{V}^2$\n-   Contribution from $t_{ox}$:\n    $(\\frac{\\partial V_{th}}{\\partial t_{ox}})^2 \\sigma_{t_{ox}}^2 = (4.818 \\times 10^7)^2 (4.0 \\times 10^{-11})^2 \\approx 3.714 \\times 10^{-6}\\,\\text{V}^2$\n-   Contribution from $N_A$:\n    $(\\frac{\\partial V_{th}}{\\partial N_A})^2 \\sigma_{N_A}^2 = (9.001 \\times 10^{-25})^2 (2.5 \\times 10^{21})^2 \\approx 5.064 \\times 10^{-6}\\,\\text{V}^2$\n\nThe total variance is the sum of these contributions:\n$$\\sigma_{V_{th}}^2 = (4.0 \\times 10^{-4} + 3.714 \\times 10^{-6} + 5.064 \\times 10^{-6})\\,\\text{V}^2$$\n$$\\sigma_{V_{th}}^2 = (400 \\times 10^{-6} + 3.714 \\times 10^{-6} + 5.064 \\times 10^{-6})\\,\\text{V}^2 = 4.08778 \\times 10^{-4}\\,\\text{V}^2$$\n\nThe standard deviation is the square root of the variance:\n$$\\sigma_{V_{th}} = \\sqrt{4.08778 \\times 10^{-4}}\\,\\text{V} \\approx 0.020218\\,\\text{V}$$\nRounding the result to three significant figures gives $0.0202\\,\\text{V}$.",
            "answer": "$$\n\\boxed{0.0202}\n$$"
        },
        {
            "introduction": "While first-principles analysis provides physical insight, practical device modeling relies on characterizing variability from experimental data. This practice introduces the celebrated Pelgrom model, an indispensable tool in analog and mixed-signal design, which empirically describes how the random mismatch between identical transistors scales with their physical area. You will take on the role of a characterization engineer, using Ordinary Least Squares (OLS) regression to analyze hypothetical measurement data and extract the Pelgrom coefficient ($A_{V_{th}}$), a key figure of merit for any process technology. ",
            "id": "3783354",
            "problem": "You are given measured device-to-device threshold voltage mismatch data for Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) devices of varying sizes. Under the Pelgrom mismatch model, random discrete dopant fluctuation and other local effects lead to an area-scaling relation for the standard deviation of threshold voltage mismatch, denoted as $\\sigma_{\\Delta V_{th}}$, such that it increases with decreasing device area. Starting from a fundamental base, the device area is $A = W L$, where $W$ is the device width and $L$ is the device length. If the depletion charge per unit area fluctuates due to discrete dopant number fluctuations that follow Poisson statistics, then the variation of areal charge density scales as the number fluctuation divided by area. This gives $\\Delta Q \\propto \\sqrt{N}/A$, with $N \\propto A$ being the number of dopants, leading to $\\Delta Q \\propto 1/\\sqrt{A}$. Since the threshold voltage responds to charge via $\\Delta V_{th} = \\Delta Q / C_{ox}$, the standard deviation obeys\n$$\n\\sigma_{\\Delta V_{th}} \\propto \\frac{1}{\\sqrt{W L}}.\n$$\nUnder statistical modeling, the Pelgrom coefficient for threshold voltage, denoted as $A_{V_{th}}$, parameterizes this scaling via the linear relation\n$$\n\\sigma_{\\Delta V_{th}} \\approx A_{V_{th}} \\cdot \\frac{1}{\\sqrt{W L}} + B,\n$$\nwhere $B$ models size-independent residual mismatch. The objective is to estimate $A_{V_{th}}$ from measured data by linear regression of $\\sigma_{\\Delta V_{th}}$ versus $1/\\sqrt{W L}$.\n\nYour task is to write a complete, runnable program that:\n- Computes $x_i = 1/\\sqrt{W_i L_i}$ for each device size $i$, with $W_i$ and $L_i$ given in micrometers (expressed as $\\mu \\mathrm{m}$).\n- Performs an Ordinary Least Squares (OLS) regression of $y_i = \\sigma_{\\Delta V_{th},i}$ (in volts) versus $x_i$, fitting the model $y_i = A_{V_{th}} \\cdot x_i + B$ with an intercept $B$.\n- Returns three quantities for each test case: the estimated slope $A_{V_{th}}$ (in $\\mathrm{V}\\cdot\\mu \\mathrm{m}$), the estimated intercept $B$ (in $\\mathrm{V}$), and the coefficient of determination $R^2$ (unitless).\n\nThe program must implement the OLS estimator explicitly. For data $\\{(x_i, y_i)\\}_{i=1}^n$, compute the slope and intercept using\n$$\n\\hat{A}_{V_{th}} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^n (x_i - \\bar{x})^2}, \\quad \\hat{B} = \\bar{y} - \\hat{A}_{V_{th}} \\bar{x},\n$$\nand compute\n$$\nR^2 = 1 - \\frac{\\sum_{i=1}^n (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^n (y_i - \\bar{y})^2}, \\quad \\text{with} \\quad \\hat{y}_i = \\hat{A}_{V_{th}} x_i + \\hat{B}.\n$$\n\nPhysical units:\n- $W$ and $L$ are given in $\\mu \\mathrm{m}$.\n- $\\sigma_{\\Delta V_{th}}$ is given in $\\mathrm{V}$.\n- $A_{V_{th}}$ must be reported in $\\mathrm{V}\\cdot\\mu \\mathrm{m}$.\n- $B$ must be reported in $\\mathrm{V}$.\n- $R^2$ is unitless.\n\nYour program must process the following test suite. For each case, use the provided arrays as-is, without any modification:\n\n- Test case $1$ (general case, multiple sizes, small noise):\n  - $W = [0.12, 0.16, 0.24, 0.32]$ $\\mu \\mathrm{m}$\n  - $L = [0.06, 0.08, 0.10, 0.12]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.0299, 0.0216, 0.0164, 0.0125]$ $\\mathrm{V}$\n\n- Test case $2$ (boundary case with two points, exact proportionality):\n  - $W = [0.20, 0.50]$ $\\mu \\mathrm{m}$\n  - $L = [0.10, 0.10]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.021213, 0.013416]$ $\\mathrm{V}$\n\n- Test case $3$ (nonzero intercept, multiple sizes):\n  - $W = [0.10, 0.20, 0.20, 0.40, 0.60]$ $\\mu \\mathrm{m}$\n  - $L = [0.05, 0.05, 0.10, 0.10, 0.12]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.0292, 0.0205, 0.0146, 0.0103, 0.0079]$ $\\mathrm{V}$\n\n- Test case $4$ (outlier present):\n  - $W = [0.15, 0.30, 0.45, 0.60]$ $\\mu \\mathrm{m}$\n  - $L = [0.06, 0.10, 0.12, 0.15]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.0296, 0.0320, 0.0121, 0.0093]$ $\\mathrm{V}$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- For each test case, output a list of three floats $[\\hat{A}_{V_{th}}, \\hat{B}, R^2]$ in that order.\n- Express $\\hat{A}_{V_{th}}$ in $\\mathrm{V}\\cdot\\mu \\mathrm{m}$, $\\hat{B}$ in $\\mathrm{V}$, and $R^2$ unitless.\n- Round each float to six significant digits.\n- The final output must be of the form\n$$\n[[\\hat{A}_1,\\hat{B}_1,R^2_1],[\\hat{A}_2,\\hat{B}_2,R^2_2],[\\hat{A}_3,\\hat{B}_3,R^2_3],[\\hat{A}_4,\\hat{B}_4,R^2_4]].\n$$",
            "solution": "The problem statement is evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n\nThe following information is provided in the problem statement:\n- **Model Equation**: The relationship between the standard deviation of threshold voltage mismatch ($\\sigma_{\\Delta V_{th}}$), device width ($W$), and device length ($L$) is given by the Pelgrom mismatch model:\n$$\n\\sigma_{\\Delta V_{th}} \\approx A_{V_{th}} \\cdot \\frac{1}{\\sqrt{W L}} + B\n$$\nwhere $A_{V_{th}}$ is the Pelgrom coefficient and $B$ is a size-independent residual mismatch.\n\n- **Task**: Estimate the parameters $A_{V_{th}}$ (slope) and $B$ (intercept), along with the coefficient of determination $R^2$, by performing an Ordinary Least Squares (OLS) regression.\n\n- **Variables for Regression**:\n  - Independent variable: $x_i = 1/\\sqrt{W_i L_i}$\n  - Dependent variable: $y_i = \\sigma_{\\Delta V_{th},i}$\n\n- **OLS Estimator Formulas**:\n  - Slope: $\\hat{A}_{V_{th}} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^n (x_i - \\bar{x})^2}$\n  - Intercept: $\\hat{B} = \\bar{y} - \\hat{A}_{V_{th}} \\bar{x}$\n  - Coefficient of Determination: $R^2 = 1 - \\frac{\\sum_{i=1}^n (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^n (y_i - \\bar{y})^2}$, where $\\hat{y}_i = \\hat{A}_{V_{th}} x_i + \\hat{B}$.\n\n- **Physical Units**:\n  - $W, L$: $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}}$: $\\mathrm{V}$\n  - Output $A_{V_{th}}$: $\\mathrm{V}\\cdot\\mu \\mathrm{m}$\n  - Output $B$: $\\mathrm{V}$\n  - Output $R^2$: unitless\n\n- **Data Sets (Test Cases)**:\n  - **Case 1**: $W = [0.12, 0.16, 0.24, 0.32]$ $\\mu \\mathrm{m}$, $L = [0.06, 0.08, 0.10, 0.12]$ $\\mu \\mathrm{m}$, $\\sigma_{\\Delta V_{th}} = [0.0299, 0.0216, 0.0164, 0.0125]$ $\\mathrm{V}$\n  - **Case 2**: $W = [0.20, 0.50]$ $\\mu \\mathrm{m}$, $L = [0.10, 0.10]$ $\\mu \\mathrm{m}$, $\\sigma_{\\Delta V_{th}} = [0.021213, 0.013416]$ $\\mathrm{V}$\n  - **Case 3**: $W = [0.10, 0.20, 0.20, 0.40, 0.60]$ $\\mu \\mathrm{m}$, $L = [0.05, 0.05, 0.10, 0.10, 0.12]$ $\\mu \\mathrm{m}$, $\\sigma_{\\Delta V_{th}} = [0.0292, 0.0205, 0.0146, 0.0103, 0.0079]$ $\\mathrm{V}$\n  - **Case 4**: $W = [0.15, 0.30, 0.45, 0.60]$ $\\mu \\mathrm{m}$, $L = [0.06, 0.10, 0.12, 0.15]$ $\\mu \\mathrm{m}$, $\\sigma_{\\Delta V_{th}} = [0.0296, 0.0320, 0.0121, 0.0093]$ $\\mathrm{V}$\n\n### Step 2: Validate Using Extracted Givens\n\n1.  **Scientifically Grounded**: The problem is based on the Pelgrom model of threshold voltage mismatch in MOSFETs. This is a canonical, experimentally verified model in semiconductor device physics and process engineering. The derivation from Poisson statistics of discrete dopants is physically correct. The problem is firmly grounded in established scientific principles.\n2.  **Well-Posed**: The task is to perform an Ordinary Least Squares (OLS) regression, for which explicit, standard formulas are provided. A unique solution for the slope and intercept exists as long as there is variance in the independent variable (i.e., not all $x_i$ are identical). For each test case, the device areas $W_i L_i$ are different for at least two data points, ensuring that the independent variables $x_i = 1/\\sqrt{W_i L_i}$ are not all identical. Therefore, the problem is well-posed.\n3.  **Objective**: The problem is stated in precise, quantitative terms. It provides numerical data and requires a specific calculation. There are no subjective or opinion-based components.\n4.  **Complete and Consistent Setup**: All necessary data (device dimensions, mismatch values) and formulas (OLS estimators) are provided. There are no missing definitions or contradictory constraints. The unit requirements are clear and physically consistent.\n5.  **Unrealistic or Infeasible**: The provided values for device dimensions ($W$, $L$) and threshold voltage standard deviation ($\\sigma_{\\Delta V_{th}}$) are within realistic ranges for modern semiconductor technologies.\n6.  **Other Flaws**: The problem is a standard parameter extraction task, not trivial, pseudo-profound, or tautological. It is a formalizable scientific problem that is directly relevant to the topic of statistical device modeling.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, complete, and objective. It is deemed **VALID**. A solution will be provided.\n\n### Solution\n\nThe objective is to determine the Pelgrom coefficient $A_{V_{th}}$, the residual mismatch offset $B$, and the coefficient of determination $R^2$ from provided experimental data for several MOSFET devices. This is achieved by performing a linear regression on the provided data, based on the linearized Pelgrom model.\n\nThe model to be fitted is:\n$$\ny_i = A_{V_{th}} \\cdot x_i + B\n$$\nwhere the dependent variable is the measured threshold voltage standard deviation, $y_i = \\sigma_{\\Delta V_{th},i}$, and the independent variable is the inverse square root of the device area, $x_i = (W_i L_i)^{-1/2}$.\n\nThe units are handled as follows: $W_i$ and $L_i$ are in $\\mu\\mathrm{m}$, so the area $A_i = W_i L_i$ is in $\\mu\\mathrm{m}^2$. The independent variable $x_i$ thus has units of $(\\mu\\mathrm{m}^2)^{-1/2} = \\mu\\mathrm{m}^{-1}$. The dependent variable $y_i$ is in volts ($ \\mathrm{V}$). The slope of the regression, $A_{V_{th}}$, will have units of $\\mathrm{V} / (\\mu\\mathrm{m}^{-1}) = \\mathrm{V}\\cdot\\mu\\mathrm{m}$. The intercept, $B$, will have the same units as the dependent variable, which is $\\mathrm{V}$. The coefficient of determination, $R^2$, is a dimensionless ratio. These unit conventions match the problem's requirements.\n\nThe procedure for each test case is as follows, using the Ordinary Least Squares (OLS) formulas provided. Let the number of data points be $n$.\n\n1.  **Data Transformation**: For each data point $i$ from $1$ to $n$:\n    - Calculate the device area: $A_i = W_i \\cdot L_i$.\n    - Calculate the independent variable: $x_i = 1 / \\sqrt{A_i}$.\n    - The dependent variable is given: $y_i = \\sigma_{\\Delta V_{th},i}$.\n\n2.  **Calculate Means**: Compute the mean of the independent and dependent variables:\n    $$\n    \\bar{x} = \\frac{1}{n} \\sum_{i=1}^n x_i, \\quad \\bar{y} = \\frac{1}{n} \\sum_{i=1}^n y_i\n    $$\n\n3.  **Estimate Slope ($\\hat{A}_{V_{th}}$)**: The slope is calculated as the covariance of $x$ and $y$ divided by the variance of $x$:\n    $$\n    \\hat{A}_{V_{th}} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^n (x_i - \\bar{x})^2}\n    $$\n    This is the best linear unbiased estimator for the slope under the OLS assumptions.\n\n4.  **Estimate Intercept ($\\hat{B}$)**: The intercept is calculated to ensure the regression line passes through the center of mass of the data $(\\bar{x}, \\bar{y})$:\n    $$\n    \\hat{B} = \\bar{y} - \\hat{A}_{V_{th}} \\bar{x}\n    $$\n\n5.  **Calculate Coefficient of Determination ($R^2$)**: This metric quantifies the goodness of fit.\n    - First, calculate the predicted dependent variable values from the fitted model for each data point:\n      $$\n      \\hat{y}_i = \\hat{A}_{V_{th}} x_i + \\hat{B}\n      $$\n    - Next, calculate the Residual Sum of Squares (SSR), which is the sum of the squared differences between observed and predicted values:\n      $$\n      \\mathrm{SSR} = \\sum_{i=1}^n (y_i - \\hat{y}_i)^2\n      $$\n    - Then, calculate the Total Sum of Squares (SST), which is the sum of the squared differences between observed values and their mean (proportional to the variance of $y$):\n      $$\n      \\mathrm{SST} = \\sum_{i=1}^n (y_i - \\bar{y})^2\n      $$\n    - Finally, the coefficient of determination is computed as:\n      $$\n      R^2 = 1 - \\frac{\\mathrm{SSR}}{\\mathrm{SST}}\n      $$\n      An $R^2$ value of $1$ indicates a perfect fit, where all variance in $y$ is explained by the model. An $R^2$ of $0$ indicates the model is no better than simply predicting the mean $\\bar{y}$.\n\nThis full procedure will be implemented for each of the four test cases provided. The results for $A_{V_{th}}$, $B$, and $R^2$ will be reported to six significant digits.",
            "answer": "```python\nimport numpy as np\n\ndef format_to_sig_figs(value, sig_figs):\n    \"\"\"\n    Formats a floating-point number to a specified number of significant figures.\n    \"\"\"\n    return f\"{value:.{sig_figs}g}\"\n\ndef solve():\n    \"\"\"\n    Solves the Pelgrom model parameter extraction problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"W\": [0.12, 0.16, 0.24, 0.32],\n            \"L\": [0.06, 0.08, 0.10, 0.12],\n            \"sigma_vth\": [0.0299, 0.0216, 0.0164, 0.0125]\n        },\n        {\n            \"W\": [0.20, 0.50],\n            \"L\": [0.10, 0.10],\n            \"sigma_vth\": [0.021213, 0.013416]\n        },\n        {\n            \"W\": [0.10, 0.20, 0.20, 0.40, 0.60],\n            \"L\": [0.05, 0.05, 0.10, 0.10, 0.12],\n            \"sigma_vth\": [0.0292, 0.0205, 0.0146, 0.0103, 0.0079]\n        },\n        {\n            \"W\": [0.15, 0.30, 0.45, 0.60],\n            \"L\": [0.06, 0.10, 0.12, 0.15],\n            \"sigma_vth\": [0.0296, 0.0320, 0.0121, 0.0093]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        W = np.array(case[\"W\"], dtype=np.float64)\n        L = np.array(case[\"L\"], dtype=np.float64)\n        y = np.array(case[\"sigma_vth\"], dtype=np.float64)\n\n        # Step 1: Data Transformation\n        # Calculate the independent variable x = 1 / sqrt(W * L)\n        area = W * L\n        x = 1.0 / np.sqrt(area)\n\n        # Step 2: Calculate Means\n        x_bar = np.mean(x)\n        y_bar = np.mean(y)\n\n        # Step 3: Estimate Slope (A_vth)\n        # A_vth = Cov(x, y) / Var(x)\n        numerator_A = np.sum((x - x_bar) * (y - y_bar))\n        denominator_A = np.sum((x - x_bar)**2)\n        A_vth = numerator_A / denominator_A\n\n        # Step 4: Estimate Intercept (B)\n        B = y_bar - A_vth * x_bar\n\n        # Step 5: Calculate Coefficient of Determination (R^2)\n        y_hat = A_vth * x + B\n        ssr = np.sum((y - y_hat)**2)\n        sst = np.sum((y - y_bar)**2)\n        \n        # Handle the case where sst is zero to avoid division by zero,\n        # which would occur if all y values are identical.\n        if sst == 0:\n            # If all y values are the same, SSR would also be 0 for a constant model\n            # and R^2 is typically considered 1 if the model is also constant.\n            # If the model is not constant, R^2 is undefined, but for regression\n            # this case implies perfect fit to a horizontal line.\n            # In our cases, sst is non-zero.\n            r_squared = 1.0 if ssr == 0 else 0.0\n        else:\n            r_squared = 1.0 - (ssr / sst)\n        \n        # Format results to 6 significant digits\n        A_vth_str = format_to_sig_figs(A_vth, 6)\n        B_str = format_to_sig_figs(B, 6)\n        r_squared_str = format_to_sig_figs(r_squared, 6)\n\n        case_result_str = f\"[{A_vth_str},{B_str},{r_squared_str}]\"\n        all_results.append(case_result_str)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Understanding and modeling device-level variability is crucial, but its true significance is revealed at the circuit and system level. This exercise bridges that gap by simulating the impact of $V_{th}$ variability on the timing of a digital circuit. You will construct a Monte Carlo simulation for a chain of CMOS inverters, generating statistically correct threshold voltages and using a physically-based delay model to predict the distribution of the total propagation delay. This practice demonstrates how device-level randomness translates directly into performance uncertainty and is fundamental to calculating manufacturing yield. ",
            "id": "3783372",
            "problem": "You are asked to construct a statistically correlated compact model instance for Complementary Metal-Oxide-Semiconductor (CMOS) circuit-level timing under threshold-voltage variability. Threshold voltage is denoted by $V_{th}$ and modeled as a random variable with specified mean, variance, and correlation across devices of the same type. The goal is to simulate an inverter chain under variability, compute the distribution of the total propagation delay, and report the timing yield with respect to a provided specification.\n\nStarting from a physically appropriate base consistent with semiconductor physics and device modeling, implement a compact model for Metal-Oxide-Semiconductor Field-Effect Transistor (MOSFET) on-current that remains scientifically realistic in both strong inversion and weak inversion. Model $V_{th}$ variability as a statistically correlated random variable across devices of the same type (NMOS devices share correlation among themselves, and PMOS devices share correlation among themselves). Correlation between NMOS and PMOS is not assumed and may be treated as independent. Use a circuit that consists of a chain of $N$ CMOS inverters, each driving a capacitive load. Treat the propagation delay per stage as the time required to transfer charge for a voltage swing across the load capacitance under an appropriate approximation of the device current in the regime relevant to switching.\n\nYour program must:\n- Generate Monte Carlo samples of $V_{th}$ for each transistor across all stages, consistent with the specified mean, total standard deviation, and pairwise correlation among devices of the same type.\n- Compute the inverter-chain total propagation delay (in seconds) per sample by summing per-stage delays. Each stage delay must account for both pull-up and pull-down transitions through an appropriate physically consistent approximation.\n- Compute the sample mean delay (in seconds), the sample standard deviation of delay (in seconds), and the timing yield as a decimal, where timing yield is the fraction of samples with total delay less than or equal to the timing specification.\n\nFundamental base requirements:\n- Begin from well-tested semiconductor device theory appropriate for long-channel operation and low-field conditions, and from charge-transfer timing approximations based on fundamental definitions of current and charge.\n- Ensure the statistical correlation structure across devices is physically consistent and mathematically valid for Gaussian random variables.\n\nPhysical and numerical units:\n- Express all delays in seconds.\n- Express the timing yield as a decimal (not using a percentage sign).\n- Use angles measured in radians only if any angle appears, although this problem does not involve angles.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a list of three floats in the order $[$mean\\_delay\\_in\\_s, std\\_delay\\_in\\_s, yield\\_decimal$]$.\n- Use scientific notation with $6$ significant digits for each float.\n\nTest suite and parameters:\nFor each test case, you are given the tuple $\\left(N, V_{DD}, C_{L}, k_{n}, k_{p}, \\mu_{n}, \\mu_{p}, \\sigma_{n}, \\sigma_{p}, \\rho_{n}, \\rho_{p}, t_{\\text{spec}}, n_{\\text{samp}}, I_{0n}, I_{0p}, n, V_{T}\\right)$ with the following meanings:\n- $N$: number of inverter stages (integer).\n- $V_{DD}$: supply voltage in volts.\n- $C_{L}$: load capacitance per stage in farads.\n- $k_{n}$ and $k_{p}$: effective strong-inversion transconductance prefactors in amperes per volt squared ($\\mathrm{A}/\\mathrm{V}^{2}$) for NMOS and PMOS, respectively.\n- $\\mu_{n}$ and $\\mu_{p}$: mean threshold voltage magnitudes in volts for NMOS and PMOS (use magnitude for PMOS).\n- $\\sigma_{n}$ and $\\sigma_{p}$: total standard deviation of threshold voltage in volts for NMOS and PMOS.\n- $\\rho_{n}$ and $\\rho_{p}$: pairwise correlation coefficients across devices of the same type for NMOS and PMOS, respectively, where $0 \\le \\rho \\le 1$.\n- $t_{\\text{spec}}$: timing specification in seconds; a sample meets timing if the total chain delay is less than or equal to $t_{\\text{spec}}$.\n- $n_{\\text{samp}}$: number of Monte Carlo samples (integer).\n- $I_{0n}$ and $I_{0p}$: weak-inversion pre-exponential current factors in amperes for NMOS and PMOS.\n- $n$: subthreshold slope factor (dimensionless, typically $> 1$).\n- $V_{T}$: thermal voltage in volts at the operating temperature.\n\nImplement the following test suite with scientifically plausible values:\n1. Happy path case:\n   - $\\left(N, V_{DD}, C_{L}, k_{n}, k_{p}, \\mu_{n}, \\mu_{p}, \\sigma_{n}, \\sigma_{p}, \\rho_{n}, \\rho_{p}, t_{\\text{spec}}, n_{\\text{samp}}, I_{0n}, I_{0p}, n, V_{T}\\right)$\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.03,\\, 0.03,\\, 0.40,\\, 0.40,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n2. High correlation case:\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.03,\\, 0.03,\\, 0.95,\\, 0.95,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n3. Zero correlation case:\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.03,\\, 0.03,\\, 0.0,\\, 0.0,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n4. Zero variability boundary case:\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.0,\\, 0.0,\\, 0.40,\\, 0.40,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n5. Near-threshold supply edge case:\n   - $\\left(5,\\, 0.70,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.40,\\, 0.42,\\, 0.02,\\, 0.02,\\, 0.50,\\, 0.50,\\, 3.5\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n\nYour program must embed these test cases, perform the required computations, and print the single line output in the exact format:\n- A top-level bracketed list of five inner lists, one per test case, in the order given above.\n- Each inner list must be $[$mean\\_delay\\_in\\_s, std\\_delay\\_in\\_s, yield\\_decimal$]$.\n- Each float must be formatted in scientific notation with $6$ significant digits.",
            "solution": "The problem statement has been critically validated and is deemed to be valid. It is scientifically grounded in established semiconductor device physics and statistical circuit analysis principles. The problem is well-posed, providing a complete and consistent set of parameters necessary to construct a computational model. The language is objective and the goals are quantitative and unambiguous. Therefore, a solution will be formulated and implemented.\n\nThe core of the problem is to construct a Monte Carlo simulation to analyze the impact of threshold voltage ($V_{th}$) variability on the propagation delay of a CMOS inverter chain. This requires three main components: a statistical model for $V_{th}$, a physically-based model for the inverter stage delay, and a framework to aggregate results over many statistical samples.\n\nFirst, we establish the statistical model for the threshold voltage. The problem specifies that $V_{th}$ is a normally distributed random variable. For a chain of $N$ inverters, we have $N$ NMOS and $N$ PMOS transistors. The threshold voltages for devices of the same type (e.g., all NMOS) are correlated. A computationally efficient method to generate a vector of $N$ correlated Gaussian random variables, $\\mathbf{V}_{th}$, with mean $\\mu$, standard deviation $\\sigma$, and uniform pairwise correlation $\\rho$ is given by the following construction for each device $i$:\n$$\nV_{th,i} = \\mu + \\sigma \\left( \\sqrt{1-\\rho} Z_i + \\sqrt{\\rho} Z_c \\right)\n$$\nHere, $Z_c$ is a single standard normal random variable ($\\mathcal{N}(0,1)$), representing the global or common source of variation affecting all devices of that type. The $Z_i$ terms are $N$ independent standard normal random variables, representing the local or independent variations for each device. This construction correctly produces a multivariate normal distribution with the desired mean vector and a covariance matrix $\\mathbf{\\Sigma}$ where diagonal elements are $\\sigma^2$ and off-diagonal elements are $\\rho\\sigma^2$. This procedure is applied independently to generate the $N$ NMOS threshold voltages ($V_{th,n,i}$) and the $N$ PMOS threshold voltage magnitudes ($V_{th,p,i}$).\n\nSecond, we formulate a model for the propagation delay of a single inverter stage. The problem requires a model that is realistic in both strong and weak inversion, which is crucial for handling modern low-voltage operation, particularly the near-threshold case. We construct a hybrid delay model based on the dominant operating regime of the transistor during switching. The propagation delay is the time required for the output to transition across half the supply voltage swing, $\\Delta V = V_{DD}/2$. This delay can be approximated as $t_p \\approx C_L \\Delta V / I_{eff}$, where $I_{eff}$ is an effective current.\n\nFor a transistor with threshold voltage $V_{th}$ and gate-source voltage $V_{GS}$ (which is $V_{DD}$ for the \"on\" transistor in an inverter), the operating regime is determined by comparing $V_{DD}$ to $V_{th}$.\n\nIf $V_{DD} > V_{th}$, the transistor operates primarily in strong inversion. A standard first-order approximation for the delay uses the saturation current, $I_{sat} = \\frac{1}{2} k (V_{GS} - V_{th})^2$, where $k$ is the transconductance prefactor.\n- The high-to-low propagation delay ($t_{pHL}$), driven by the NMOS transistor, is:\n$$\nt_{pHL} = \\frac{C_L V_{DD}/2}{\\frac{1}{2} k_n (V_{DD} - V_{th,n})^2} = \\frac{C_L V_{DD}}{k_n (V_{DD} - V_{th,n})^2}\n$$\n- The low-to-high propagation delay ($t_{pLH}$), driven by the PMOS transistor, is similarly given, using the magnitude of the PMOS threshold voltage, $|V_{th,p}|$:\n$$\nt_{pLH} = \\frac{C_L V_{DD}/2}{\\frac{1}{2} k_p (V_{DD} - |V_{th,p}|)^2} = \\frac{C_L V_{DD}}{k_p (V_{DD} - |V_{th,p}|)^2}\n$$\n\nIf $V_{DD} \\le V_{th}$, the transistor operates in the subthreshold (weak inversion) regime. The current is dominated by diffusion and is exponentially dependent on the gate voltage. The effective current can be approximated by the subthreshold saturation current: $I_{sub} = I_0 \\exp\\left(\\frac{V_{GS} - V_{th}}{n V_T}\\right)$, where $I_0$ is the pre-exponential factor, $n$ is the subthreshold slope factor, and $V_T$ is the thermal voltage.\n- The delays in this regime are:\n$$\nt_{pHL} = \\frac{C_L V_{DD}/2}{I_{0n} \\exp\\left(\\frac{V_{DD} - V_{th,n}}{n V_T}\\right)} \\quad \\text{and} \\quad t_{pLH} = \\frac{C_L V_{DD}/2}{I_{0p} \\exp\\left(\\frac{V_{DD} - |V_{th,p}|}{n V_T}\\right)}\n$$\nThis hybrid, piecewise model captures the fundamental shift in device physics from drift-dominated current in strong inversion to diffusion-dominated current in weak inversion, satisfying the problem's requirement for physical realism across operating regimes.\n\nThe total propagation delay of the inverter chain is computed by summing the contributions from each stage. A robust definition for a single stage's delay is the average of its pull-up and pull-down times, $\\tau_i = \\frac{1}{2}(t_{pHL,i} + t_{pLH,i})$. The total chain delay, $T_{total}$, is the sum of these stage delays:\n$$\nT_{total} = \\sum_{i=1}^{N} \\tau_i = \\sum_{i=1}^{N} \\frac{1}{2} \\left( t_{pHL,i} + t_{pLH,i} \\right)\n$$\nEach $t_{pHL,i}$ and $t_{pLH,i}$ is calculated using the specific sampled threshold voltages, $V_{th,n,i}$ and $V_{th,p,i}$, for that stage.\n\nFinally, the simulation proceeds by executing a Monte Carlo loop for $n_{samp}$ iterations. In each iteration, a full set of $2N$ threshold voltages is statistically generated, and the corresponding total chain delay $T_{total}$ is computed. After collecting the $n_{samp}$ delay values, the required statistical metrics are calculated:\n1.  **Sample Mean Delay**: $\\bar{T}_{total} = \\frac{1}{n_{samp}} \\sum_{j=1}^{n_{samp}} T_{total}^{(j)}$.\n2.  **Sample Standard Deviation of Delay**: $S_{T_{total}} = \\sqrt{\\frac{1}{n_{samp}-1} \\sum_{j=1}^{n_{samp}} (T_{total}^{(j)} - \\bar{T}_{total})^2}$. The denominator $n_{samp}-1$ is used for an unbiased estimate of the variance.\n3.  **Timing Yield**: The fraction of samples for which the total delay does not exceed the specification $t_{spec}$, i.e., $Y = \\frac{\\text{Number of samples with } T_{total} \\le t_{spec}}{n_{samp}}$.\n\nThis comprehensive approach, grounded in device physics and statistical methods, is implemented in Python using the NumPy library for efficient, vectorized numerical computation. A fixed random seed is used to ensure reproducibility of the statistical results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Set a random seed for reproducibility of the Monte Carlo simulation.\n    np.random.seed(42)\n\n    # Test cases defined as tuples of parameters.\n    # (N, V_DD, C_L, k_n, k_p, mu_n, mu_p, sigma_n, sigma_p, rho_n, rho_p, t_spec, n_samp, I_0n, I_0p, n, V_T)\n    test_cases = [\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.03, 0.03, 0.40, 0.40, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.03, 0.03, 0.95, 0.95, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.03, 0.03, 0.0, 0.0, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.0, 0.0, 0.40, 0.40, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 0.70, 1e-15, 1.0e-3, 6.0e-4, 0.40, 0.42, 0.02, 0.02, 0.50, 0.50, 3.5e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2)\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _calculate_timing_stats(params)\n        results.append(result)\n\n    # Format the final output string as per requirements.\n    case_strings = []\n    for mean_delay, std_delay, yield_val in results:\n        # Format with 6 significant digits requires a precision of 5 for the 'e' specifier.\n        case_str = f\"[{mean_delay:.5e},{std_delay:.5e},{yield_val:.5e}]\"\n        case_strings.append(case_str)\n    \n    print(f\"[{','.join(case_strings)}]\")\n\ndef _calculate_timing_stats(params):\n    \"\"\"\n    Performs the Monte Carlo simulation for a single test case.\n    \"\"\"\n    (N, V_DD, C_L, k_n, k_p, mu_n, mu_p, sigma_n, sigma_p, \n     rho_n, rho_p, t_spec, n_samp, I_0n, I_0p, n_factor, V_T) = params\n\n    # Handle the deterministic case of zero variability separately for efficiency\n    # and to avoid numerical issues (e.g., sqrt of negative in correlation term if rho > 1-eps).\n    if sigma_n == 0.0 and sigma_p == 0.0:\n        vth_n = mu_n\n        vth_p = mu_p\n        \n        t_phl = _calculate_delay(V_DD, C_L, k_n, vth_n, I_0n, n_factor, V_T)\n        t_plh = _calculate_delay(V_DD, C_L, k_p, vth_p, I_0p, n_factor, V_T)\n\n        stage_delay = 0.5 * (t_phl + t_plh)\n        total_delay = N * stage_delay\n        \n        mean_delay = total_delay\n        std_delay = 0.0\n        yield_val = 1.0 if total_delay = t_spec else 0.0\n        \n        return mean_delay, std_delay, yield_val\n\n    # Generate correlated random variables for Vth\n    # For NMOS\n    z_global_n = np.random.randn(n_samp, 1)\n    z_local_n = np.random.randn(n_samp, N)\n    vth_n_samples = mu_n + sigma_n * (np.sqrt(rho_n) * z_global_n + np.sqrt(1 - rho_n) * z_local_n)\n\n    # For PMOS\n    z_global_p = np.random.randn(n_samp, 1)\n    z_local_p = np.random.randn(n_samp, N)\n    vth_p_samples = mu_p + sigma_p * (np.sqrt(rho_p) * z_global_p + np.sqrt(1 - rho_p) * z_local_p)\n\n    # Calculate delays for all samples and stages in a vectorized manner\n    t_phl_matrix = _calculate_delay_vectorized(V_DD, C_L, k_n, vth_n_samples, I_0n, n_factor, V_T)\n    t_plh_matrix = _calculate_delay_vectorized(V_DD, C_L, k_p, vth_p_samples, I_0p, n_factor, V_T)\n\n    # Calculate total delay for each sample\n    total_delay_samples = 0.5 * np.sum(t_phl_matrix + t_plh_matrix, axis=1)\n\n    # Compute final statistics\n    mean_delay = np.mean(total_delay_samples)\n    std_delay = np.std(total_delay_samples, ddof=1)\n    yield_val = np.sum(total_delay_samples = t_spec) / n_samp\n    \n    return mean_delay, std_delay, yield_val\n\ndef _calculate_delay(V_DD, C_L, k, vth, I_0, n_factor, V_T):\n    \"\"\"Calculates propagation delay for a single transistor (scalar version).\"\"\"\n    if V_DD > vth:\n        # Strong inversion\n        delay = (C_L * V_DD) / (k * (V_DD - vth)**2)\n    else:\n        # Weak inversion (subthreshold)\n        # Prevent overflow in exp by clipping argument\n        exp_arg = (V_DD - vth) / (n_factor * V_T)\n        sub_current = I_0 * np.exp(np.clip(exp_arg, -700, 700))\n        delay = (C_L * V_DD / 2.0) / sub_current\n    return delay\n\ndef _calculate_delay_vectorized(V_DD, C_L, k, vth_matrix, I_0, n_factor, V_T):\n    \"\"\"Calculates propagation delays for a matrix of Vth samples (vectorized).\"\"\"\n    strong_inv_mask = V_DD > vth_matrix\n    \n    delays = np.zeros_like(vth_matrix, dtype=float)\n\n    # --- Strong inversion calculations ---\n    vth_strong = vth_matrix[strong_inv_mask]\n    delays[strong_inv_mask] = (C_L * V_DD) / (k * (V_DD - vth_strong)**2)\n\n    # --- Weak inversion calculations ---\n    vth_weak = vth_matrix[~strong_inv_mask]\n    # Prevent overflow in exp by clipping argument\n    exp_arg = (V_DD - vth_weak) / (n_factor * V_T)\n    sub_current = I_0 * np.exp(np.clip(exp_arg, -700, 700))\n    delays[~strong_inv_mask] = (C_L * V_DD / 2.0) / sub_current\n\n    return delays\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}