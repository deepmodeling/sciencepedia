{
    "hands_on_practices": [
        {
            "introduction": "这项实践探讨了基本工艺参数（如氧化层厚度和掺杂浓度）的波动如何传播并导致阈值电压（$V_{th}$）的可变性。通过应用统计分析的基石技术——一阶灵敏度分析，您将定量地确定每个物理源对总 $V_{th}$ 方差的贡献。这个练习提供了制造变化与电学性能不确定性之间的直接联系。",
            "id": "3783379",
            "problem": "一个平面长沟道n沟道金属-氧化物-半导体场效应晶体管 (MOSFET) 制作在均匀掺杂的p型硅上，其受主浓度为 $N_A$。阈值定义为当表面电势等于两倍费米电势时强反型开始的时刻。忽略固定氧化层电荷、界面态、多晶硅耗尽和体偏压。假设温度 $T$ 恒定，且氧化层为理想电介质。\n\n给定以下标称参数和物理常数：\n- 标称受主掺杂 $N_{A,0} = 1.0 \\times 10^{17}\\,\\text{cm}^{-3}$，\n- 标称氧化层厚度 $t_{ox,0} = 1.5\\,\\text{nm}$，\n- 标称金属-半导体功函数差 $\\phi_{ms,0} = -0.45\\,\\text{V}$，\n- $300\\,\\text{K}$ 时硅的本征载流子浓度：$n_i = 1.0 \\times 10^{10}\\,\\text{cm}^{-3}$，\n- 温度 $T = 300\\,\\text{K}$，\n- 基本电荷 $q = 1.602 \\times 10^{-19}\\,\\text{C}$，\n- 玻尔兹曼常数 $k_B = 1.381 \\times 10^{-23}\\,\\text{J/K}$，\n- 真空介电常数 $\\varepsilon_0 = 8.854 \\times 10^{-12}\\,\\text{F/m}$，\n- 硅介电常数 $\\varepsilon_{si} = 11.7\\,\\varepsilon_0$，\n- 二氧化硅介电常数 $\\varepsilon_{ox} = 3.9\\,\\varepsilon_0$。\n\n计量报告了三个独立变化来源的测量标准差如下：\n- 氧化层厚度标准差 $\\sigma_{t_{ox}} = 0.040\\,\\text{nm}$，\n- 金属-半导体功函数差标准差 $\\sigma_{\\phi_{ms}} = 0.020\\,\\text{V}$，\n- 受主掺杂标准差 $\\sigma_{N_A} = 2.5 \\times 10^{15}\\,\\text{cm}^{-3}$。\n\n使用一阶灵敏度分析，并假设这三个来源是独立的，通过在标称工作点附近传播来自 $t_{ox}$、$\\phi_{ms}$ 和 $N_A$ 的不确定度，来估计阈值电压的标准差 $\\sigma_{V_{th}}$。将 $n_i$ 和 $T$ 视为非随机常数。以伏特为单位表示最终值，并将您的答案四舍五入至三位有效数字。",
            "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n提供了以下数据和条件：\n-   **器件类型**：平面长沟道n沟道MOSFET，制作在均匀掺杂的p型硅上。\n-   **标称参数**：\n    -   受主掺杂：$N_{A,0} = 1.0 \\times 10^{17}\\,\\text{cm}^{-3}$\n    -   氧化层厚度：$t_{ox,0} = 1.5\\,\\text{nm}$\n    -   金属-半导体功函数差：$\\phi_{ms,0} = -0.45\\,\\text{V}$\n-   **独立变量的标准差**：\n    -   氧化层厚度：$\\sigma_{t_{ox}} = 0.040\\,\\text{nm}$\n    -   功函数差：$\\sigma_{\\phi_{ms}} = 0.020\\,\\text{V}$\n    -   受主掺杂：$\\sigma_{N_A} = 2.5 \\times 10^{15}\\,\\text{cm}^{-3}$\n-   **物理常数和条件**：\n    -   本征载流子浓度：$n_i = 1.0 \\times 10^{10}\\,\\text{cm}^{-3}$\n    -   温度：$T = 300\\,\\text{K}$\n    -   基本电荷：$q = 1.602 \\times 10^{-19}\\,\\text{C}$\n    -   玻尔兹曼常数：$k_B = 1.381 \\times 10^{-23}\\,\\text{J/K}$\n    -   真空介电常数：$\\varepsilon_0 = 8.854 \\times 10^{-12}\\,\\text{F/m}$\n    -   硅介电常数：$\\varepsilon_{si} = 11.7\\,\\varepsilon_0$\n    -   二氧化硅介电常数：$\\varepsilon_{ox} = 3.9\\,\\varepsilon_0$\n-   **定义和假设**：\n    -   阈值条件：强反型，其中表面电势 $\\psi_s = 2\\phi_F$（$\\phi_F$ 为费米电势）。\n    -   忽略：固定氧化层电荷 ($Q_f$)、界面态 ($Q_{it}$)、多晶硅耗尽和体偏压。\n    -   $n_i$ 和 $T$ 是非随机常数。\n-   **任务**：使用一阶灵敏度分析估计阈值电压的标准差 $\\sigma_{V_{th}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在科学上基于标准的半导体器件物理，特别是MOSFET的工作原理。提供的阈值电压模型和要求的统计分析方法（一阶不确定度传播）是该领域的标准方法。该问题是适定的，提供了得出唯一数值解所需的所有参数和常数。语言客观且精确。数值对于现代硅器件来说是物理上现实的。该问题不违反任何无效标准。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将提供完整解答。\n\n### 解答推导\n在指定假设（无固定或界面电荷，无体偏压）下，长沟道n-MOSFET的阈值电压 $V_{th}$ 由下式给出：\n$$V_{th} = \\phi_{ms} + 2\\phi_F + \\frac{|Q_{dep}|}{C_{ox}}$$\n其中 $\\phi_{ms}$ 是金属-半导体功函数差，$\\phi_F$ 是体费米电势，$C_{ox}$ 是单位面积的氧化层电容，$|Q_{dep}|$ 是强反型开始时（$\\psi_s = 2\\phi_F$）单位面积的耗尽电荷量。\n\n该方程的各组成部分用可变参数 $N_A$ 和 $t_{ox}$ 表示如下：\np型硅的费米电势 $\\phi_F$ 为：\n$$\\phi_F = \\frac{k_B T}{q} \\ln\\left(\\frac{N_A}{n_i}\\right)$$\n单位面积的氧化层电容 $C_{ox}$ 为：\n$$C_{ox} = \\frac{\\varepsilon_{ox}}{t_{ox}}$$\n在 $\\psi_s = 2\\phi_F$ 时的耗尽电荷量为：\n$$|Q_{dep}| = \\sqrt{2q\\varepsilon_{si}N_A(2\\phi_F)} = \\sqrt{4q\\varepsilon_{si}N_A\\phi_F}$$\n将这些代入 $V_{th}$ 方程，得到关于自变量 $t_{ox}$、$\\phi_{ms}$ 和 $N_A$ 的完整表达式：\n$$V_{th}(t_{ox}, \\phi_{ms}, N_A) = \\phi_{ms} + 2\\phi_F + \\frac{t_{ox}}{\\varepsilon_{ox}}\\sqrt{4q\\varepsilon_{si}N_A\\phi_F}$$\n\n该问题要求进行一阶灵敏度分析。由于变化来源（$t_{ox}$、$\\phi_{ms}$、$N_A$）是独立的，阈值电压的方差 $\\sigma_{V_{th}}^2$ 可近似为各灵敏度的平方与相应参数方差的乘积之和：\n$$\\sigma_{V_{th}}^2 \\approx \\left(\\frac{\\partial V_{th}}{\\partial t_{ox}}\\right)^2 \\sigma_{t_{ox}}^2 + \\left(\\frac{\\partial V_{th}}{\\partial \\phi_{ms}}\\right)^2 \\sigma_{\\phi_{ms}}^2 + \\left(\\frac{\\partial V_{th}}{\\partial N_A}\\right)^2 \\sigma_{N_A}^2$$\n偏导数（灵敏度）在标称参数值处进行计算。\n\n1.  **对 $\\phi_{ms}$ 的灵敏度**：\n    $$\\frac{\\partial V_{th}}{\\partial \\phi_{ms}} = 1$$\n\n2.  **对 $t_{ox}$ 的灵敏度**：\n    $$\\frac{\\partial V_{th}}{\\partial t_{ox}} = \\frac{\\partial}{\\partial t_{ox}} \\left( \\frac{t_{ox}}{\\varepsilon_{ox}}\\sqrt{4q\\varepsilon_{si}N_A\\phi_F} \\right) = \\frac{\\sqrt{4q\\varepsilon_{si}N_A\\phi_F}}{\\varepsilon_{ox}}$$\n\n3.  **对 $N_A$ 的灵敏度**：\n    $\\phi_F$ 和耗尽电荷项都依赖于 $N_A$。我们定义热电压 $V_T = k_B T / q$。$\\phi_F$ 对 $N_A$ 的导数为 $\\frac{\\partial \\phi_F}{\\partial N_A} = \\frac{V_T}{N_A}$。\n    $$\\frac{\\partial V_{th}}{\\partial N_A} = \\frac{\\partial(2\\phi_F)}{\\partial N_A} + \\frac{1}{C_{ox}} \\frac{\\partial}{\\partial N_A} \\left( \\sqrt{4q\\varepsilon_{si}N_A\\phi_F} \\right)$$\n    第一项是 $\\frac{\\partial(2\\phi_F)}{\\partial N_A} = \\frac{2V_T}{N_A}$。\n    对于第二项，使用链式法则：\n    $$\\frac{\\partial}{\\partial N_A} \\sqrt{4q\\varepsilon_{si}N_A\\phi_F} = \\frac{4q\\varepsilon_{si}}{2\\sqrt{4q\\varepsilon_{si}N_A\\phi_F}} \\left(1 \\cdot \\phi_F + N_A \\cdot \\frac{\\partial \\phi_F}{\\partial N_A}\\right) = \\sqrt{\\frac{q\\varepsilon_{si}}{N_A\\phi_F}}(\\phi_F + V_T)$$\n    合并各项，对 $N_A$ 的灵敏度为：\n    $$\\frac{\\partial V_{th}}{\\partial N_A} = \\frac{2V_T}{N_A} + \\frac{1}{C_{ox}}\\sqrt{\\frac{q\\varepsilon_{si}}{N_A\\phi_F}}(\\phi_F + V_T)$$\n\n### 数值计算\n所有参数都转换为国际单位制（SI）单位。\n-   $\\varepsilon_{si} = 11.7 \\times (8.854 \\times 10^{-12}\\,\\text{F/m}) \\approx 1.036 \\times 10^{-10}\\,\\text{F/m}$\n-   $\\varepsilon_{ox} = 3.9 \\times (8.854 \\times 10^{-12}\\,\\text{F/m}) \\approx 3.453 \\times 10^{-11}\\,\\text{F/m}$\n-   $N_{A,0} = 1.0 \\times 10^{17}\\,\\text{cm}^{-3} = 1.0 \\times 10^{23}\\,\\text{m}^{-3}$\n-   $t_{ox,0} = 1.5\\,\\text{nm} = 1.5 \\times 10^{-9}\\,\\text{m}$\n-   $n_i = 1.0 \\times 10^{10}\\,\\text{cm}^{-3} = 1.0 \\times 10^{16}\\,\\text{m}^{-3}$\n-   $\\sigma_{t_{ox}} = 0.040\\,\\text{nm} = 4.0 \\times 10^{-11}\\,\\text{m}$\n-   $\\sigma_{N_A} = 2.5 \\times 10^{15}\\,\\text{cm}^{-3} = 2.5 \\times 10^{21}\\,\\text{m}^{-3}$\n-   $\\sigma_{\\phi_{ms}} = 0.020\\,\\text{V}$\n\n首先，我们计算在标称点的中间量的值：\n-   热电压：$V_T = \\frac{k_B T}{q} = \\frac{(1.381 \\times 10^{-23}\\,\\text{J/K})(300\\,\\text{K})}{1.602 \\times 10^{-19}\\,\\text{C}} \\approx 0.02586\\,\\text{V}$\n-   费米电势：$\\phi_F = V_T \\ln\\left(\\frac{N_{A,0}}{n_i}\\right) = (0.02586\\,\\text{V})\\ln\\left(\\frac{1.0 \\times 10^{23}}{1.0 \\times 10^{16}}\\right) = (0.02586\\,\\text{V})\\ln(10^7) \\approx 0.4172\\,\\text{V}$\n-   氧化层电容：$C_{ox} = \\frac{\\varepsilon_{ox}}{t_{ox,0}} = \\frac{3.453 \\times 10^{-11}\\,\\text{F/m}}{1.5 \\times 10^{-9}\\,\\text{m}} \\approx 0.02302\\,\\text{F/m}^2$\n\n接下来，我们对灵敏度进行数值计算：\n-   $\\frac{\\partial V_{th}}{\\partial \\phi_{ms}} = 1$\n-   $\\frac{\\partial V_{th}}{\\partial t_{ox}} = \\frac{\\sqrt{4(1.602 \\times 10^{-19})(1.036 \\times 10^{-10})(10^{23})(0.4172)}}{3.453 \\times 10^{-11}} \\approx 4.818 \\times 10^7\\,\\text{V/m}$\n-   $\\frac{\\partial V_{th}}{\\partial N_A} = \\frac{2(0.02586)}{10^{23}} + \\frac{1}{0.02302}\\sqrt{\\frac{1.602 \\times 10^{-19} \\cdot 1.036 \\times 10^{-10}}{10^{23} \\cdot 0.4172}}(0.4172 + 0.02586)$\n    $\\frac{\\partial V_{th}}{\\partial N_A} \\approx 5.172 \\times 10^{-25} + 3.829 \\times 10^{-25} = 9.001 \\times 10^{-25}\\,\\text{V}\\cdot\\text{m}^3$\n\n现在，我们计算每个参数对总方差的贡献：\n-   来自 $\\phi_{ms}$ 的贡献：\n    $(\\frac{\\partial V_{th}}{\\partial \\phi_{ms}})^2 \\sigma_{\\phi_{ms}}^2 = (1)^2(0.020)^2 = 4.0 \\times 10^{-4}\\,\\text{V}^2$\n-   来自 $t_{ox}$ 的贡献：\n    $(\\frac{\\partial V_{th}}{\\partial t_{ox}})^2 \\sigma_{t_{ox}}^2 = (4.818 \\times 10^7)^2 (4.0 \\times 10^{-11})^2 \\approx 3.714 \\times 10^{-6}\\,\\text{V}^2$\n-   来自 $N_A$ 的贡献：\n    $(\\frac{\\partial V_{th}}{\\partial N_A})^2 \\sigma_{N_A}^2 = (9.001 \\times 10^{-25})^2 (2.5 \\times 10^{21})^2 \\approx 5.064 \\times 10^{-6}\\,\\text{V}^2$\n\n总方差是这些贡献的总和：\n$$\\sigma_{V_{th}}^2 = (4.0 \\times 10^{-4} + 3.714 \\times 10^{-6} + 5.064 \\times 10^{-6})\\,\\text{V}^2$$\n$$\\sigma_{V_{th}}^2 = (400 \\times 10^{-6} + 3.714 \\times 10^{-6} + 5.064 \\times 10^{-6})\\,\\text{V}^2 = 4.08778 \\times 10^{-4}\\,\\text{V}^2$$\n\n标准差是方差的平方根：\n$$\\sigma_{V_{th}} = \\sqrt{4.08778 \\times 10^{-4}}\\,\\text{V} \\approx 0.020218\\,\\text{V}$$\n将结果四舍五入到三位有效数字，得到 $0.0202\\,\\text{V}$。",
            "answer": "$$\n\\boxed{0.0202}\n$$"
        },
        {
            "introduction": "虽然理解物理起源至关重要，但工程师们通常通过将测量数据拟合到经验模型来表征可变性。本练习介绍了广泛使用的 Pelgrom 失配模型，该模型优雅地捕捉了器件面积与阈值电压可变性之间的关系。您将编写一个程序，对模拟实验数据进行线性回归，以提取作为工艺技术关键品质因数的 Pelgrom 系数（$A_{V_{th}}$）。",
            "id": "3783354",
            "problem": "给定不同尺寸金属氧化物半导体场效应晶体管（MOSFET）器件的器件间阈值电压失配测量数据。根据 Pelgrom 失配模型，随机离散掺杂剂波动和其他局部效应导致阈值电压失配的标准差（表示为 $\\sigma_{\\Delta V_{th}}$）存在一种面积缩放关系，即其值随器件面积的减小而增大。从基本原理出发，器件面积为 $A = W L$，其中 $W$ 是器件宽度，$L$ 是器件长度。如果单位面积的耗尽电荷由于遵循泊松统计的离散掺杂剂数量波动而波动，那么面电荷密度的变化与数量波动除以面积成比例。这得出 $\\Delta Q \\propto \\sqrt{N}/A$，其中 $N \\propto A$ 是掺杂剂的数量，从而导致 $\\Delta Q \\propto 1/\\sqrt{A}$。由于阈值电压通过 $\\Delta V_{th} = \\Delta Q / C_{ox}$ 响应电荷，因此标准差遵循\n$$\n\\sigma_{\\Delta V_{th}} \\propto \\frac{1}{\\sqrt{W L}}.\n$$\n在统计建模中，阈值电压的 Pelgrom 系数（表示为 $A_{V_{th}}$）通过以下线性关系参数化了这种缩放关系\n$$\n\\sigma_{\\Delta V_{th}} \\approx A_{V_{th}} \\cdot \\frac{1}{\\sqrt{W L}} + B,\n$$\n其中 $B$ 模拟了与尺寸无关的残余失配。目标是通过对 $\\sigma_{\\Delta V_{th}}$ 与 $1/\\sqrt{W L}$ 进行线性回归，从测量数据中估计 $A_{V_{th}}$。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 为每个器件尺寸 $i$ 计算 $x_i = 1/\\sqrt{W_i L_i}$，其中 $W_i$ 和 $L_i$ 的单位为微米（表示为 $\\mu \\mathrm{m}$）。\n- 对 $y_i = \\sigma_{\\Delta V_{th},i}$（单位为伏特）与 $x_i$ 进行普通最小二乘法（OLS）回归，拟合包含截距 $B$ 的模型 $y_i = A_{V_{th}} \\cdot x_i + B$。\n- 为每个测试用例返回三个量：估计的斜率 $A_{V_{th}}$（单位为 $\\mathrm{V}\\cdot\\mu \\mathrm{m}$），估计的截距 $B$（单位为 $\\mathrm{V}$），以及决定系数 $R^2$（无单位）。\n\n程序必须显式实现 OLS 估计器。对于数据 $\\{(x_i, y_i)\\}_{i=1}^n$，使用以下公式计算斜率和截距\n$$\n\\hat{A}_{V_{th}} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^n (x_i - \\bar{x})^2}, \\quad \\hat{B} = \\bar{y} - \\hat{A}_{V_{th}} \\bar{x},\n$$\n并计算\n$$\nR^2 = 1 - \\frac{\\sum_{i=1}^n (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^n (y_i - \\bar{y})^2}, \\quad \\text{其中} \\quad \\hat{y}_i = \\hat{A}_{V_{th}} x_i + \\hat{B}。\n$$\n\n物理单位：\n- $W$ 和 $L$ 的单位为 $\\mu \\mathrm{m}$。\n- $\\sigma_{\\Delta V_{th}}$ 的单位为 $\\mathrm{V}$。\n- $A_{V_{th}}$ 必须以 $\\mathrm{V}\\cdot\\mu \\mathrm{m}$ 为单位报告。\n- $B$ 必须以 $\\mathrm{V}$ 为单位报告。\n- $R^2$ 是无单位的。\n\n您的程序必须处理以下测试套件。对于每个用例，请直接使用提供的数组，不要做任何修改：\n\n- 测试用例1（一般情况，多种尺寸，小噪声）：\n  - $W = [0.12, 0.16, 0.24, 0.32]$ $\\mu \\mathrm{m}$\n  - $L = [0.06, 0.08, 0.10, 0.12]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.0299, 0.0216, 0.0164, 0.0125]$ $\\mathrm{V}$\n\n- 测试用例2（边界情况，两个点，精确比例）：\n  - $W = [0.20, 0.50]$ $\\mu \\mathrm{m}$\n  - $L = [0.10, 0.10]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.021213, 0.013416]$ $\\mathrm{V}$\n\n- 测试用例3（非零截距，多种尺寸）：\n  - $W = [0.10, 0.20, 0.20, 0.40, 0.60]$ $\\mu \\mathrm{m}$\n  - $L = [0.05, 0.05, 0.10, 0.10, 0.12]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.0292, 0.0205, 0.0146, 0.0103, 0.0079]$ $\\mathrm{V}$\n\n- 测试用例4（存在异常值）：\n  - $W = [0.15, 0.30, 0.45, 0.60]$ $\\mu \\mathrm{m}$\n  - $L = [0.06, 0.10, 0.12, 0.15]$ $\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}} = [0.0296, 0.0320, 0.0121, 0.0093]$ $\\mathrm{V}$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。\n- 对于每个测试用例，按顺序输出一个包含三个浮点数的列表 $[\\hat{A}_{V_{th}}, \\hat{B}, R^2]$。\n- 将 $\\hat{A}_{V_{th}}$ 以 $\\mathrm{V}\\cdot\\mu \\mathrm{m}$ 表示，$\\hat{B}$ 以 $\\mathrm{V}$ 表示，$R^2$ 无单位。\n- 将每个浮点数四舍五入到六位有效数字。\n- 最终输出必须采用以下形式\n$$\n[[\\hat{A}_1,\\hat{B}_1,R^2_1],[\\hat{A}_2,\\hat{B}_2,R^2_2],[\\hat{A}_3,\\hat{B}_3,R^2_3],[\\hat{A}_4,\\hat{B}_4,R^2_4]].\n$$",
            "solution": "在尝试解决问题之前，首先评估问题陈述的有效性。\n\n### 步骤 1：提取已知信息\n\n问题陈述中提供了以下信息：\n- **模型方程**：阈值电压失配的标准差（$\\sigma_{\\Delta V_{th}}$）、器件宽度（$W$）和器件长度（$L$）之间的关系由 Pelgrom 失配模型给出：\n$$\n\\sigma_{\\Delta V_{th}} \\approx A_{V_{th}} \\cdot \\frac{1}{\\sqrt{W L}} + B\n$$\n其中 $A_{V_{th}}$ 是 Pelgrom 系数，$B$ 是与尺寸无关的残余失配。\n\n- **任务**：通过执行普通最小二乘法（OLS）回归，估计参数 $A_{V_{th}}$（斜率）和 $B$（截距），以及决定系数 $R^2$。\n\n- **回归变量**：\n  - 自变量：$x_i = 1/\\sqrt{W_i L_i}$\n  - 因变量：$y_i = \\sigma_{\\Delta V_{th},i}$\n\n- **OLS 估计器公式**：\n  - 斜率：$\\hat{A}_{V_{th}} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^n (x_i - \\bar{x})^2}$\n  - 截距：$\\hat{B} = \\bar{y} - \\hat{A}_{V_{th}} \\bar{x}$\n  - 决定系数：$R^2 = 1 - \\frac{\\sum_{i=1}^n (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^n (y_i - \\bar{y})^2}$，其中 $\\hat{y}_i = \\hat{A}_{V_{th}} x_i + \\hat{B}$。\n\n- **物理单位**：\n  - $W, L$：$\\mu \\mathrm{m}$\n  - $\\sigma_{\\Delta V_{th}}$：$\\mathrm{V}$\n  - 输出 $A_{V_{th}}$：$\\mathrm{V}\\cdot\\mu \\mathrm{m}$\n  - 输出 $B$：$\\mathrm{V}$\n  - 输出 $R^2$：无单位\n\n- **数据集（测试用例）**：\n  - **用例 1**：$W = [0.12, 0.16, 0.24, 0.32]$ $\\mu \\mathrm{m}$，$L = [0.06, 0.08, 0.10, 0.12]$ $\\mu \\mathrm{m}$，$\\sigma_{\\Delta V_{th}} = [0.0299, 0.0216, 0.0164, 0.0125]$ $\\mathrm{V}$\n  - **用例 2**：$W = [0.20, 0.50]$ $\\mu \\mathrm{m}$，$L = [0.10, 0.10]$ $\\mu \\mathrm{m}$，$\\sigma_{\\Delta V_{th}} = [0.021213, 0.013416]$ $\\mathrm{V}$\n  - **用例 3**：$W = [0.10, 0.20, 0.20, 0.40, 0.60]$ $\\mu \\mathrm{m}$，$L = [0.05, 0.05, 0.10, 0.10, 0.12]$ $\\mu \\mathrm{m}$，$\\sigma_{\\Delta V_{th}} = [0.0292, 0.0205, 0.0146, 0.0103, 0.0079]$ $\\mathrm{V}$\n  - **用例 4**：$W = [0.15, 0.30, 0.45, 0.60]$ $\\mu \\mathrm{m}$，$L = [0.06, 0.10, 0.12, 0.15]$ $\\mu \\mathrm{m}$，$\\sigma_{\\Delta V_{th}} = [0.0296, 0.0320, 0.0121, 0.0093]$ $\\mathrm{V}$\n\n### 步骤 2：使用提取的已知信息进行验证\n\n1.  **科学依据**：该问题基于 MOSFET 中阈值电压失配的 Pelgrom 模型。这是半导体器件物理和工艺工程中一个典型的、经过实验验证的模型。从离散掺杂剂的泊松统计推导出的过程在物理上是正确的。该问题牢固地植根于已建立的科学原理。\n2.  **问题定义明确**：任务是执行普通最小二乘法（OLS）回归，并为此提供了明确的标准公式。只要自变量存在方差（即并非所有 $x_i$ 都相同），斜率和截距就存在唯一解。对于每个测试用例，至少有两个数据点的器件面积 $W_i L_i$ 是不同的，确保了自变量 $x_i = 1/\\sqrt{W_i L_i}$ 不会完全相同。因此，该问题定义明确。\n3.  **客观性**：问题以精确、定量的术语陈述。它提供了数值数据并要求进行特定的计算。没有主观或基于意见的成分。\n4.  **设置完整且一致**：所有必要的数据（器件尺寸、失配值）和公式（OLS 估计器）都已提供。没有缺失的定义或矛盾的约束。单位要求清晰且物理上一致。\n5.  **不切实际或不可行**：提供的器件尺寸（$W$、$L$）和阈值电压标准差（$\\sigma_{\\Delta V_{th}}$）的值在现代半导体技术的实际范围内。\n6.  **其他缺陷**：该问题是一个标准的参数提取任务，并非微不足道、故作高深或同义反复。它是一个可形式化的科学问题，与统计器件建模的主题直接相关。\n\n### 步骤 3：结论与行动\n该问题具有科学依据，定义明确，完整且客观。判定为 **有效**。将提供解决方案。\n\n### 解法\n\n目标是根据提供的多个 MOSFET 器件的实验数据，确定 Pelgrom 系数 $A_{V_{th}}$、残余失配偏移量 $B$ 和决定系数 $R^2$。这通过对提供的基于线性化 Pelgrom 模型的数据执行线性回归来实现。\n\n需要拟合的模型是：\n$$\ny_i = A_{V_{th}} \\cdot x_i + B\n$$\n其中因变量是测得的阈值电压标准差 $y_i = \\sigma_{\\Delta V_{th},i}$，自变量是器件面积的平方根倒数 $x_i = (W_i L_i)^{-1/2}$。\n\n单位处理如下：$W_i$ 和 $L_i$ 的单位是 $\\mu\\mathrm{m}$，所以面积 $A_i = W_i L_i$ 的单位是 $\\mu\\mathrm{m}^2$。因此，自变量 $x_i$ 的单位是 $(\\mu\\mathrm{m}^2)^{-1/2} = \\mu\\mathrm{m}^{-1}$。因变量 $y_i$ 的单位是伏特（$\\mathrm{V}$）。回归的斜率 $A_{V_{th}}$ 的单位将是 $\\mathrm{V} / (\\mu\\mathrm{m}^{-1}) = \\mathrm{V}\\cdot\\mu\\mathrm{m}$。截距 $B$ 将与因变量具有相同的单位，即 $\\mathrm{V}$。决定系数 $R^2$ 是一个无量纲的比率。这些单位约定与问题的要求相符。\n\n每个测试用例的步骤如下，使用提供的普通最小二乘法（OLS）公式。设数据点数量为 $n$。\n\n1.  **数据转换**：对于从 $1$ 到 $n$ 的每个数据点 $i$：\n    - 计算器件面积：$A_i = W_i \\cdot L_i$。\n    - 计算自变量：$x_i = 1 / \\sqrt{A_i}$。\n    - 因变量是给定的：$y_i = \\sigma_{\\Delta V_{th},i}$。\n\n2.  **计算均值**：计算自变量和因变量的均值：\n    $$\n    \\bar{x} = \\frac{1}{n} \\sum_{i=1}^n x_i, \\quad \\bar{y} = \\frac{1}{n} \\sum_{i=1}^n y_i\n    $$\n\n3.  **估计斜率 ($\\hat{A}_{V_{th}}$)**：斜率计算为 $x$ 和 $y$ 的协方差除以 $x$ 的方差：\n    $$\n    \\hat{A}_{V_{th}} = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^n (x_i - \\bar{x})^2}\n    $$\n    这是 OLS 假设下斜率的最佳线性无偏估计。\n\n4.  **估计截距 ($\\hat{B}$)**：计算截距以确保回归线通过数据的质心 $(\\bar{x}, \\bar{y})$：\n    $$\n    \\hat{B} = \\bar{y} - \\hat{A}_{V_{th}} \\bar{x}\n    $$\n\n5.  **计算决定系数 ($R^2$)**：此指标量化了拟合优度。\n    - 首先，根据拟合模型为每个数据点计算预测的因变量值：\n      $$\n      \\hat{y}_i = \\hat{A}_{V_{th}} x_i + \\hat{B}\n      $$\n    - 接下来，计算残差平方和（SSR），即观测值与预测值之间差异的平方和：\n      $$\n      \\mathrm{SSR} = \\sum_{i=1}^n (y_i - \\hat{y}_i)^2\n      $$\n    - 然后，计算总平方和（SST），即观测值与其均值之间差异的平方和（与 $y$ 的方差成正比）：\n      $$\n      \\mathrm{SST} = \\sum_{i=1}^n (y_i - \\bar{y})^2\n      $$\n    - 最后，决定系数计算如下：\n      $$\n      R^2 = 1 - \\frac{\\mathrm{SSR}}{\\mathrm{SST}}\n      $$\n      $R^2$ 值为 $1$ 表示完美拟合，其中 $y$ 的所有方差都由模型解释。$R^2$ 为 $0$ 表示该模型不比简单地预测均值 $\\bar{y}$ 更好。\n\n将对提供的四个测试用例中的每一个执行此完整过程。$A_{V_{th}}$、$B$ 和 $R^2$ 的结果将报告至六位有效数字。",
            "answer": "```python\nimport numpy as np\n\ndef format_to_sig_figs(value, sig_figs):\n    \"\"\"\n    Formats a floating-point number to a specified number of significant figures.\n    \"\"\"\n    return f\"{value:.{sig_figs}g}\"\n\ndef solve():\n    \"\"\"\n    Solves the Pelgrom model parameter extraction problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"W\": [0.12, 0.16, 0.24, 0.32],\n            \"L\": [0.06, 0.08, 0.10, 0.12],\n            \"sigma_vth\": [0.0299, 0.0216, 0.0164, 0.0125]\n        },\n        {\n            \"W\": [0.20, 0.50],\n            \"L\": [0.10, 0.10],\n            \"sigma_vth\": [0.021213, 0.013416]\n        },\n        {\n            \"W\": [0.10, 0.20, 0.20, 0.40, 0.60],\n            \"L\": [0.05, 0.05, 0.10, 0.10, 0.12],\n            \"sigma_vth\": [0.0292, 0.0205, 0.0146, 0.0103, 0.0079]\n        },\n        {\n            \"W\": [0.15, 0.30, 0.45, 0.60],\n            \"L\": [0.06, 0.10, 0.12, 0.15],\n            \"sigma_vth\": [0.0296, 0.0320, 0.0121, 0.0093]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        W = np.array(case[\"W\"], dtype=np.float64)\n        L = np.array(case[\"L\"], dtype=np.float64)\n        y = np.array(case[\"sigma_vth\"], dtype=np.float64)\n\n        # Step 1: Data Transformation\n        # Calculate the independent variable x = 1 / sqrt(W * L)\n        area = W * L\n        x = 1.0 / np.sqrt(area)\n\n        # Step 2: Calculate Means\n        x_bar = np.mean(x)\n        y_bar = np.mean(y)\n\n        # Step 3: Estimate Slope (A_vth)\n        # A_vth = Cov(x, y) / Var(x)\n        numerator_A = np.sum((x - x_bar) * (y - y_bar))\n        denominator_A = np.sum((x - x_bar)**2)\n        A_vth = numerator_A / denominator_A\n\n        # Step 4: Estimate Intercept (B)\n        B = y_bar - A_vth * x_bar\n\n        # Step 5: Calculate Coefficient of Determination (R^2)\n        y_hat = A_vth * x + B\n        ssr = np.sum((y - y_hat)**2)\n        sst = np.sum((y - y_bar)**2)\n        \n        # Handle the case where sst is zero to avoid division by zero,\n        # which would occur if all y values are identical.\n        if sst == 0:\n            # If all y values are the same, SSR would also be 0 for a constant model\n            # and R^2 is typically considered 1 if the model is also constant.\n            # If the model is not constant, R^2 is undefined, but for regression\n            # this case implies perfect fit to a horizontal line.\n            # In our cases, sst is non-zero.\n            r_squared = 1.0 if ssr == 0 else 0.0\n        else:\n            r_squared = 1.0 - (ssr / sst)\n        \n        # Format results to 6 significant digits\n        A_vth_str = format_to_sig_figs(A_vth, 6)\n        B_str = format_to_sig_figs(B, 6)\n        r_squared_str = format_to_sig_figs(r_squared, 6)\n\n        case_result_str = f\"[{A_vth_str},{B_str},{r_squared_str}]\"\n        all_results.append(case_result_str)\n\n    # Print the final output in the required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "统计器件建模的最终目的是预测可变性对电路和系统性能的影响。这项高级实践将指导您构建一个蒙特卡洛仿真，以评估考虑了相关的 $V_{th}$ 变化的 CMOS 反相器链的时序。您将看到器件级的随机性如何转化为电路延迟的分布，从而能够根据给定的规格对时序良率进行关键的估计。",
            "id": "3783372",
            "problem": "要求您为互补金属氧化物半导体（CMOS）电路级时序在阈值电压变化下的情景，构建一个统计相关的紧凑模型实例。阈值电压用 $V_{th}$ 表示，并被建模为一个随机变量，其均值、方差以及同类型器件间的相关性均已指定。目标是模拟一个在可变性影响下的反相器链，计算总传播延迟的分布，并报告相对于给定规格的时序良率。\n\n从与半导体物理和器件建模一致的、物理上适当的基础出发，为金属氧化物半导体场效应晶体管（MOSFET）的导通电流实现一个紧凑模型，该模型在强反型和弱反型区都保持科学真实性。将 $V_{th}$ 变异性建模为同类型器件间（NMOS 器件之间共享相关性，PMOS 器件之间也共享相关性）统计相关的随机变量。不假设 NMOS 和 PMOS 之间存在相关性，可以视为独立。使用一个由 $N$ 个 CMOS 反相器链组成的电路，每个反相器驱动一个电容性负载。将每级的传播延迟视为在与开关相关的区域内，根据器件电流的适当近似，在负载电容上转移电压摆幅所需电荷的时间。\n\n您的程序必须：\n- 为所有级中的每个晶体管生成 $V_{th}$ 的蒙特卡洛样本，这些样本需与指定的均值、总标准差以及同类型器件间的成对相关性保持一致。\n- 通过对每级延迟求和，计算每个样本的反相器链总传播延迟（单位：秒）。每级延迟必须通过一个适当的、物理上一致的近似来考虑上拉和下拉转换。\n- 计算样本平均延迟（单位：秒）、样本延迟标准差（单位：秒）以及时序良率（以小数表示），其中时序良率是总延迟小于或等于时序规格的样本所占的比例。\n\n基本基础要求：\n- 从适用于长沟道操作和低电场条件的、经过充分检验的半导体器件理论，以及基于电流和电荷基本定义的电荷转移时序近似开始。\n- 确保器件间的统计相关结构在物理上一致，并且对于高斯随机变量在数学上是有效的。\n\n物理和数值单位：\n- 所有延迟均以秒表示。\n- 时序良率以小数表示（不使用百分号）。\n- 如果出现任何角度，仅使用以弧度为单位测量的角度，尽管此问题不涉及角度。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，并用方括号括起来。每个测试用例的结果必须是一个包含三个浮点数的列表，顺序为 $[$mean\\_delay\\_in\\_s, std\\_delay\\_in\\_s, yield\\_decimal$]$。\n- 对每个浮点数使用包含 $6$ 位有效数字的科学记数法。\n\n测试套件和参数：\n对于每个测试用例，您将获得一个元组 $\\left(N, V_{DD}, C_{L}, k_{n}, k_{p}, \\mu_{n}, \\mu_{p}, \\sigma_{n}, \\sigma_{p}, \\rho_{n}, \\rho_{p}, t_{\\text{spec}}, n_{\\text{samp}}, I_{0n}, I_{0p}, n, V_{T}\\right)$，其含义如下：\n- $N$: 反相器级数（整数）。\n- $V_{DD}$: 电源电压，单位为伏特。\n- $C_{L}$: 每级负载电容，单位为法拉。\n- $k_{n}$ 和 $k_{p}$: 分别为 NMOS 和 PMOS 的有效强反型跨导前因子，单位为安培/伏特平方（$\\mathrm{A}/\\mathrm{V}^{2}$）。\n- $\\mu_{n}$ 和 $\\mu_{p}$: 分别为 NMOS 和 PMOS 的平均阈值电压大小，单位为伏特（对 PMOS 使用其大小）。\n- $\\sigma_{n}$ 和 $\\sigma_{p}$: NMOS 和 PMOS 阈值电压的总标准差，单位为伏特。\n- $\\rho_{n}$ 和 $\\rho_{p}$: 分别为 NMOS 和 PMOS 同类型器件间的成对相关系数，其中 $0 \\le \\rho \\le 1$。\n- $t_{\\text{spec}}$: 时序规格，单位为秒；如果总链延迟小于或等于 $t_{\\text{spec}}$，则样本满足时序要求。\n- $n_{\\text{samp}}$: 蒙特卡洛样本数（整数）。\n- $I_{0n}$ 和 $I_{0p}$: NMOS 和 PMOS 的弱反型前指数电流因子，单位为安培。\n- $n$: 亚阈值斜率因子（无量纲，通常 $> 1$）。\n- $V_{T}$: 工作温度下的热电压，单位为伏特。\n\n实现以下具有科学合理值的测试套件：\n1. 正常路径用例：\n   - $\\left(N, V_{DD}, C_{L}, k_{n}, k_{p}, \\mu_{n}, \\mu_{p}, \\sigma_{n}, \\sigma_{p}, \\rho_{n}, \\rho_{p}, t_{\\text{spec}}, n_{\\text{samp}}, I_{0n}, I_{0p}, n, V_{T}\\right)$\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.03,\\, 0.03,\\, 0.40,\\, 0.40,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n2. 高相关性用例：\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.03,\\, 0.03,\\, 0.95,\\, 0.95,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n3. 零相关性用例：\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.03,\\, 0.03,\\, 0.0,\\, 0.0,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n4. 零变异性边界用例：\n   - $\\left(5,\\, 1.0,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.35,\\, 0.37,\\, 0.0,\\, 0.0,\\, 0.40,\\, 0.40,\\, 1.2\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n5. 近阈值电源边界用例：\n   - $\\left(5,\\, 0.70,\\, 1\\times 10^{-15},\\, 1.0\\times 10^{-3},\\, 6.0\\times 10^{-4},\\, 0.40,\\, 0.42,\\, 0.02,\\, 0.02,\\, 0.50,\\, 0.50,\\, 3.5\\times 10^{-11},\\, 20000,\\, 1.0\\times 10^{-7},\\, 1.0\\times 10^{-7},\\, 1.5,\\, 2.59\\times 10^{-2}\\right)$\n\n您的程序必须嵌入这些测试用例，执行所需的计算，并按以下确切格式打印单行输出：\n- 一个顶层方括号列表，包含五个内部列表，每个测试用例一个，顺序如上所述。\n- 每个内部列表必须是 $[$mean\\_delay\\_in\\_s, std\\_delay\\_in\\_s, yield\\_decimal$]$。\n- 每个浮点数必须格式化为包含 $6$ 位有效数字的科学记数法。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它科学地基于成熟的半导体器件物理学和统计电路分析原理。该问题提法完善，提供了一套完整且一致的参数，足以构建一个计算模型。语言客观，目标定量且明确。因此，将制定并实施一个解决方案。\n\n问题的核心是构建一个蒙特卡洛模拟，以分析阈值电压（$V_{th}$）变异性对CMOS反相器链传播延迟的影响。这需要三个主要部分：一个 $V_{th}$ 的统计模型，一个基于物理的反相器级延迟模型，以及一个用于汇总多个统计样本结果的框架。\n\n首先，我们建立阈值电压的统计模型。问题指定 $V_{th}$ 是一个正态分布的随机变量。对于一个由 $N$ 个反相器组成的链，我们有 $N$ 个 NMOS 和 $N$ 个 PMOS 晶体管。同类型器件（例如，所有 NMOS）的阈值电压是相关的。一种计算效率高的方法是为每个器件 $i$ 生成一个包含 $N$ 个相关高斯随机变量的向量 $\\mathbf{V}_{th}$，其均值为 $\\mu$，标准差为 $\\sigma$，且具有统一的成对相关性 $\\rho$，构造如下：\n$$\nV_{th,i} = \\mu + \\sigma \\left( \\sqrt{1-\\rho} Z_i + \\sqrt{\\rho} Z_c \\right)\n$$\n在这里，$Z_c$ 是一个单一的标准正态随机变量（$\\mathcal{N}(0,1)$），代表影响该类型所有器件的全局或共同变异源。$Z_i$ 项是 $N$ 个独立标准正态随机变量，代表每个器件的局部或独立变异。这种构造正确地生成了一个多元正态分布，其均值向量和协方差矩阵 $\\mathbf{\\Sigma}$ 符合要求，其中对角线元素为 $\\sigma^2$，非对角线元素为 $\\rho\\sigma^2$。此过程被独立应用于生成 $N$ 个 NMOS 阈值电压（$V_{th,n,i}$）和 $N$ 个 PMOS 阈值电压大小（$V_{th,p,i}$）。\n\n其次，我们为单个反相器级的传播延迟建立模型。问题要求模型在强反型和弱反型区都具有真实性，这对于处理现代低压操作，特别是近阈值情况至关重要。我们构建一个基于晶体管在开关期间主要工作区域的混合延迟模型。传播延迟是输出在电源电压摆幅的一半（$\\Delta V = V_{DD}/2$）上转换所需的时间。该延迟可近似为 $t_p \\approx C_L \\Delta V / I_{eff}$，其中 $I_{eff}$ 是一个有效电流。\n\n对于一个阈值电压为 $V_{th}$ 且栅源电压为 $V_{GS}$（对于反相器中的“导通”晶体管，该值为 $V_{DD}$）的晶体管，其工作区域由 $V_{DD}$ 与 $V_{th}$ 的比较确定。\n\n如果 $V_{DD} > V_{th}$，晶体管主要工作在强反型区。一个标准的一阶延迟近似使用饱和电流，$I_{sat} = \\frac{1}{2} k (V_{GS} - V_{th})^2$，其中 $k$ 是跨导前因子。\n- 由 NMOS 晶体管驱动的高到低传播延迟（$t_{pHL}$）为：\n$$\nt_{pHL} = \\frac{C_L V_{DD}/2}{\\frac{1}{2} k_n (V_{DD} - V_{th,n})^2} = \\frac{C_L V_{DD}}{k_n (V_{DD} - V_{th,n})^2}\n$$\n- 由 PMOS 晶体管驱动的低到高传播延迟（$t_{pLH}$）类似地给出，使用 PMOS 阈值电压的大小 $|V_{th,p}|$:\n$$\nt_{pLH} = \\frac{C_L V_{DD}/2}{\\frac{1}{2} k_p (V_{DD} - |V_{th,p}|)^2} = \\frac{C_L V_{DD}}{k_p (V_{DD} - |V_{th,p}|)^2}\n$$\n\n如果 $V_{DD} \\le V_{th}$，晶体管工作在亚阈值（弱反型）区。电流主要由扩散主导，并与栅极电压呈指数关系。有效电流可由亚阈值饱和电流近似：$I_{sub} = I_0 \\exp\\left(\\frac{V_{GS} - V_{th}}{n V_T}\\right)$，其中 $I_0$ 是前指数因子，$n$ 是亚阈值斜率因子，$V_T$ 是热电压。\n- 在此区域的延迟为：\n$$\nt_{pHL} = \\frac{C_L V_{DD}/2}{I_{0n} \\exp\\left(\\frac{V_{DD} - V_{th,n}}{n V_T}\\right)} \\quad \\text{和} \\quad t_{pLH} = \\frac{C_L V_{DD}/2}{I_{0p} \\exp\\left(\\frac{V_{DD} - |V_{th,p}|}{n V_T}\\right)}\n$$\n这种混合的分段模型捕捉了器件物理从强反型区的漂移主导电流到弱反型区的扩散主导电流的根本转变，满足了问题对跨工作区域的物理真实性的要求。\n\n反相器链的总传播延迟是通过对每个级的贡献求和来计算的。单个级延迟的稳健定义是其上拉和下拉时间的平均值，$\\tau_i = \\frac{1}{2}(t_{pHL,i} + t_{pLH,i})$。总链延迟 $T_{total}$ 是这些级延迟的总和：\n$$\nT_{total} = \\sum_{i=1}^{N} \\tau_i = \\sum_{i=1}^{N} \\frac{1}{2} \\left( t_{pHL,i} + t_{pLH,i} \\right)\n$$\n每个 $t_{pHL,i}$ 和 $t_{pLH,i}$ 都是使用该级的特定采样阈值电压 $V_{th,n,i}$ 和 $V_{th,p,i}$ 计算的。\n\n最后，模拟通过执行一个进行 $n_{samp}$ 次迭代的蒙特卡洛循环来进行。在每次迭代中，都会统计生成一整套 $2N$ 个阈值电压，并计算相应的总链延迟 $T_{total}$。在收集了 $n_{samp}$ 个延迟值后，计算所需的统计指标：\n1.  **样本平均延迟**: $\\bar{T}_{total} = \\frac{1}{n_{samp}} \\sum_{j=1}^{n_{samp}} T_{total}^{(j)}$。\n2.  **样本延迟标准差**: $S_{T_{total}} = \\sqrt{\\frac{1}{n_{samp}-1} \\sum_{j=1}^{n_{samp}} (T_{total}^{(j)} - \\bar{T}_{total})^2}$。分母 $n_{samp}-1$ 用于无偏估计方差。\n3.  **时序良率**: 总延迟不超过规格 $t_{spec}$ 的样本所占的比例，即 $Y = \\frac{\\text{Number of samples with } T_{total} \\le t_{spec}}{n_{samp}}$。\n\n这种基于器件物理和统计方法的综合方法，使用 Python 的 NumPy 库来实现，以进行高效的矢量化数值计算。使用固定的随机种子以确保统计结果的可复现性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Set a random seed for reproducibility of the Monte Carlo simulation.\n    np.random.seed(42)\n\n    # Test cases defined as tuples of parameters.\n    # (N, V_DD, C_L, k_n, k_p, mu_n, mu_p, sigma_n, sigma_p, rho_n, rho_p, t_spec, n_samp, I_0n, I_0p, n, V_T)\n    test_cases = [\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.03, 0.03, 0.40, 0.40, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.03, 0.03, 0.95, 0.95, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.03, 0.03, 0.0, 0.0, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 1.0, 1e-15, 1.0e-3, 6.0e-4, 0.35, 0.37, 0.0, 0.0, 0.40, 0.40, 1.2e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2),\n        (5, 0.70, 1e-15, 1.0e-3, 6.0e-4, 0.40, 0.42, 0.02, 0.02, 0.50, 0.50, 3.5e-11, 20000, 1.0e-7, 1.0e-7, 1.5, 2.59e-2)\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _calculate_timing_stats(params)\n        results.append(result)\n\n    # Format the final output string as per requirements.\n    case_strings = []\n    for mean_delay, std_delay, yield_val in results:\n        # Format with 6 significant digits requires a precision of 5 for the 'e' specifier.\n        case_str = f\"[{mean_delay:.5e},{std_delay:.5e},{yield_val:.5e}]\"\n        case_strings.append(case_str)\n    \n    print(f\"[{','.join(case_strings)}]\")\n\ndef _calculate_timing_stats(params):\n    \"\"\"\n    Performs the Monte Carlo simulation for a single test case.\n    \"\"\"\n    (N, V_DD, C_L, k_n, k_p, mu_n, mu_p, sigma_n, sigma_p, \n     rho_n, rho_p, t_spec, n_samp, I_0n, I_0p, n_factor, V_T) = params\n\n    # Handle the deterministic case of zero variability separately for efficiency\n    # and to avoid numerical issues (e.g., sqrt of negative in correlation term if rho > 1-eps).\n    if sigma_n == 0.0 and sigma_p == 0.0:\n        vth_n = mu_n\n        vth_p = mu_p\n        \n        t_phl = _calculate_delay(V_DD, C_L, k_n, vth_n, I_0n, n_factor, V_T)\n        t_plh = _calculate_delay(V_DD, C_L, k_p, vth_p, I_0p, n_factor, V_T)\n\n        stage_delay = 0.5 * (t_phl + t_plh)\n        total_delay = N * stage_delay\n        \n        mean_delay = total_delay\n        std_delay = 0.0\n        yield_val = 1.0 if total_delay = t_spec else 0.0\n        \n        return mean_delay, std_delay, yield_val\n\n    # Generate correlated random variables for Vth\n    # For NMOS\n    z_global_n = np.random.randn(n_samp, 1)\n    z_local_n = np.random.randn(n_samp, N)\n    vth_n_samples = mu_n + sigma_n * (np.sqrt(rho_n) * z_global_n + np.sqrt(1 - rho_n) * z_local_n)\n\n    # For PMOS\n    z_global_p = np.random.randn(n_samp, 1)\n    z_local_p = np.random.randn(n_samp, N)\n    vth_p_samples = mu_p + sigma_p * (np.sqrt(rho_p) * z_global_p + np.sqrt(1 - rho_p) * z_local_p)\n\n    # Calculate delays for all samples and stages in a vectorized manner\n    t_phl_matrix = _calculate_delay_vectorized(V_DD, C_L, k_n, vth_n_samples, I_0n, n_factor, V_T)\n    t_plh_matrix = _calculate_delay_vectorized(V_DD, C_L, k_p, vth_p_samples, I_0p, n_factor, V_T)\n\n    # Calculate total delay for each sample\n    total_delay_samples = 0.5 * np.sum(t_phl_matrix + t_plh_matrix, axis=1)\n\n    # Compute final statistics\n    mean_delay = np.mean(total_delay_samples)\n    std_delay = np.std(total_delay_samples, ddof=1)\n    yield_val = np.sum(total_delay_samples = t_spec) / n_samp\n    \n    return mean_delay, std_delay, yield_val\n\ndef _calculate_delay(V_DD, C_L, k, vth, I_0, n_factor, V_T):\n    \"\"\"Calculates propagation delay for a single transistor (scalar version).\"\"\"\n    if V_DD > vth:\n        # Strong inversion\n        delay = (C_L * V_DD) / (k * (V_DD - vth)**2)\n    else:\n        # Weak inversion (subthreshold)\n        # Prevent overflow in exp by clipping argument\n        exp_arg = (V_DD - vth) / (n_factor * V_T)\n        sub_current = I_0 * np.exp(np.clip(exp_arg, -700, 700))\n        delay = (C_L * V_DD / 2.0) / sub_current\n    return delay\n\ndef _calculate_delay_vectorized(V_DD, C_L, k, vth_matrix, I_0, n_factor, V_T):\n    \"\"\"Calculates propagation delays for a matrix of Vth samples (vectorized).\"\"\"\n    strong_inv_mask = V_DD > vth_matrix\n    \n    delays = np.zeros_like(vth_matrix, dtype=float)\n\n    # --- Strong inversion calculations ---\n    vth_strong = vth_matrix[strong_inv_mask]\n    delays[strong_inv_mask] = (C_L * V_DD) / (k * (V_DD - vth_strong)**2)\n\n    # --- Weak inversion calculations ---\n    vth_weak = vth_matrix[~strong_inv_mask]\n    # Prevent overflow in exp by clipping argument\n    exp_arg = (V_DD - vth_weak) / (n_factor * V_T)\n    sub_current = I_0 * np.exp(np.clip(exp_arg, -700, 700))\n    delays[~strong_inv_mask] = (C_L * V_DD / 2.0) / sub_current\n\n    return delays\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}