{
    "hands_on_practices": [
        {
            "introduction": "The mathematical core of the Scharfetter-Gummel method is the Bernoulli function, $B(\\xi) = \\xi / (\\exp(\\xi) - 1)$. A naive implementation of this function is numerically unstable, particularly for values of $\\xi$ near zero where it suffers from catastrophic cancellation. This first practice guides you through the essential task of creating a robust, piecewise implementation that ensures accuracy across all real values of $\\xi$ by leveraging Taylor series for small arguments and appropriate asymptotic forms for large ones .",
            "id": "3780761",
            "problem": "A program must be written to evaluate the Bernoulli functions used in the Scharfetter–Gummel (SG) discretization method for drift–diffusion equations in semiconductor device modeling. The Scharfetter–Gummel method relies on an exact integration of the steady one-dimensional drift–diffusion flux with a constant electric field over a mesh edge of length $\\Delta x$, using the Einstein relation and the requirement of constant flux across the edge. The resulting flux expression introduces the Bernoulli function dependent on the dimensionless potential drop, which is essential for numerical stability and physical consistency of the discretization. From a fundamental base, begin with the electron current density relation in one dimension,\n$$\nJ_n = q \\mu_n n E + q D_n \\frac{d n}{d x},\n$$\nwhere $q$ is the elementary charge, $\\mu_n$ is the electron mobility, $D_n$ is the electron diffusivity, $n$ is the electron concentration, and $E$ is the electric field; combine this with the Einstein relation $D_n = \\mu_n U_T$ where $U_T$ is the thermal voltage, and the steady-state condition requiring constant $J_n$ across an edge. The exact edge integration produces a dimensionless argument $\\xi$ defined by the potential drop, and a pair of Bernoulli function evaluations $B(\\xi)$ and $B(-\\xi)$ required by the flux formula.\n\nYour task is to construct a numerically stable algorithmic blueprint, and implement it, for evaluating $B(\\xi)$ and $B(-\\xi)$ that avoids catastrophic cancellation near $\\xi = 0$ and handles extreme values of $\\xi$ without overflow or underflow. The algorithm must be designed only from standard mathematical analysis of the Bernoulli function’s behavior (including series expansions, asymptotics, and identities), without relying on any shortcut formulas provided in the problem statement. The implementation must adhere to the following constraints:\n\n- Use a Maclaurin series expansion of $B(\\xi)$ near $\\xi = 0$ to mitigate subtractive cancellation and achieve high relative accuracy for small $|\\xi|$. Choose a truncation order that is justified from the series analysis and provides at least relative error on the order of $10^{-12}$ for $|\\xi| \\leq 10^{-4}$.\n- For moderate values of $\\xi$, evaluate expressions in a way that reduces cancellation by using numerically stable transforms, such as operations that compute $e^{\\xi} - 1$ without loss of significance. Implement both $B(\\xi)$ and $B(-\\xi)$ without directly subtracting nearly equal quantities.\n- For large positive or large negative $\\xi$, use appropriate asymptotic approximations to avoid overflow or underflow in the exponential while staying consistent with the limiting behavior of $B(\\xi)$ and $B(-\\xi)$.\n- Although the Bernoulli function has an exact symmetry, you must avoid numerically dangerous uses of identities that multiply an exponentially small quantity by an exponentially large one when $\\xi$ is large in magnitude.\n\nProduce a single program that evaluates $B(\\xi)$ and $B(-\\xi)$ for each $\\xi$ in the following test suite:\n- $\\xi = 0$\n- $\\xi = 10^{-12}$\n- $\\xi = -10^{-12}$\n- $\\xi = 10^{-8}$\n- $\\xi = -10^{-8}$\n- $\\xi = 0.1$\n- $\\xi = -0.1$\n- $\\xi = 1$\n- $\\xi = -1$\n- $\\xi = 10$\n- $\\xi = -10$\n- $\\xi = 700$\n- $\\xi = -700$\n- $\\xi = 1000$\n- $\\xi = -1000$\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result for a given $\\xi$ is itself a two-element list $[B(\\xi), B(-\\xi)]$. For example, the output should look like\n$$\n[[B(\\xi_1),B(-\\xi_1)],[B(\\xi_2),B(-\\xi_2)],\\ldots]\n$$\nNo physical units are involved because $\\xi$ is dimensionless; all outputs are floating-point numbers.",
            "solution": "The problem statement requires the development and implementation of a numerically stable algorithm to evaluate the Bernoulli functions $B(\\xi)$ and $B(-\\xi)$ as a core component of the Scharfetter-Gummel discretization method.\n\n## Problem Validation\n\n### Step 1: Extract Givens\n- **Physical Context**: Scharfetter-Gummel (SG) discretization for semiconductor drift-diffusion equations.\n- **Governing Equation**: 1D electron current density, $J_n = q \\mu_n n E + q D_n \\frac{d n}{d x}$, where $q$ is elementary charge, $\\mu_n$ is electron mobility, $D_n$ is electron diffusivity, $n$ is electron concentration, and $E$ is the electric field.\n- **Auxiliary Relations**: Einstein relation, $D_n = \\mu_n U_T$, where $U_T$ is the thermal voltage.\n- **Assumption**: Steady-state ($J_n$ is constant) and constant electric field $E$ over a mesh edge of length $\\Delta x$.\n- **Core Task**: Construct a numerically stable algorithm for evaluating the Bernoulli function $B(\\xi)$ and its counterpart $B(-\\xi)$, where $\\xi$ is the dimensionless potential drop.\n- **Algorithmic Constraints**:\n    1.  The algorithm must be derived from fundamental mathematical analysis of the function's properties.\n    2.  A Maclaurin series expansion must be used for small $|\\xi|$ to avoid catastrophic cancellation. The truncation must be justified to provide a relative error of approximately $10^{-12}$ for $|\\xi| \\leq 10^{-4}$.\n    3.  Numerically stable forms must be used for moderate values of $\\xi$.\n    4.  Asymptotic approximations must be used for large positive or negative $\\xi$ to prevent overflow/underflow.\n    5.  Numerically dangerous identities must be avoided.\n- **Test Suite**: A list of $15$ values for $\\xi$: $0, \\pm 10^{-12}, \\pm 10^{-8}, \\pm 0.1, \\pm 1, \\pm 10, \\pm 700, \\pm 1000$.\n- **Output Format**: A single line containing a list of two-element lists, e.g., `[[B(xi_1),B(-xi_1)],[B(xi_2),B(-xi_2)],...]`.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is firmly rooted in semiconductor device physics and numerical analysis. The drift-diffusion model, the Einstein relation, and the Scharfetter-Gummel method are all standard and well-established concepts. The physics is correct.\n- **Well-Posed**: The task is clearly defined: implement a specific mathematical function, $B(\\xi)$, subject to explicit numerical stability constraints. The inputs (test cases) and the required output format are precisely specified. Although the explicit form of $B(\\xi)$ is not given, its derivation from the provided physical equations is a standard part of the topic, making the problem self-contained for a knowledgeable practitioner.\n- **Objective**: The problem is stated in precise, technical language, free from subjectivity or ambiguity.\n- **Flaw Analysis**:\n    1.  *Scientific/Factual Unsoundness*: None.\n    2.  *Non-Formalizable/Irrelevant*: None. The problem is directly formalizable and highly relevant.\n    3.  *Incomplete/Contradictory Setup*: None. The non-provision of the $B(\\xi)$ formula is an intentional part of the problem, requiring its derivation or identification from the context.\n    4.  *Unrealistic/Infeasible*: None. The requirements are standard in high-quality numerical software.\n    5.  *Ill-Posed/Poorly Structured*: None. A unique, stable solution can be designed.\n    6.  *Pseudo-Profound/Trivial*: None. The problem addresses a genuine and non-trivial challenge in computational physics.\n    7.  *Outside Scientific Verifiability*: None. The results are mathematically verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A full solution will be developed.\n\n## Derivation of the Bernoulli Function in the Scharfetter-Gummel Scheme\n\nThe starting point is the one-dimensional steady-state electron current density equation:\n$$\nJ_n = q \\mu_n n E + q D_n \\frac{d n}{d x}\n$$\nUsing the Einstein relation $D_n = \\mu_n U_T$ to eliminate mobility $\\mu_n = D_n / U_T$, and relating the electric field to the electrostatic potential $\\psi$ via $E = -d\\psi/dx$, the equation becomes:\n$$\nJ_n = q \\frac{D_n}{U_T} n \\left(-\\frac{d\\psi}{dx}\\right) + q D_n \\frac{d n}{d x}\n$$\nDividing by $q D_n$ and defining the normalized potential $\\phi = \\psi / U_T$, we get:\n$$\n\\frac{J_n}{q D_n} = -n \\frac{d\\phi}{dx} + \\frac{d n}{d x}\n$$\nThis is a first-order linear ordinary differential equation for the electron density $n(x)$. Assuming $J_n$ and $D_n$ are constant over a mesh interval from $x_i$ to $x_{i+1}$, we can write:\n$$\n\\frac{d}{dx} \\left(n(x) e^{-\\phi(x)}\\right) = \\left(\\frac{d n}{d x} - n \\frac{d\\phi}{dx}\\right) e^{-\\phi(x)} = \\frac{J_n}{q D_n} e^{-\\phi(x)}\n$$\nIntegrating from $x_i$ to $x_{i+1}$:\n$$\nn_{i+1} e^{-\\phi_{i+1}} - n_i e^{-\\phi_i} = \\frac{J_n}{q D_n} \\int_{x_i}^{x_{i+1}} e^{-\\phi(x)} dx\n$$\nwhere $n_k = n(x_k)$ and $\\phi_k = \\phi(x_k)$. The key Scharfetter-Gummel assumption is that the electric field $E$ is constant between nodes, which implies that the normalized potential $\\phi(x)$ is linear. Let $\\xi = \\phi_{i+1} - \\phi_i$ be the normalized potential drop across the interval of length $\\Delta x = x_{i+1} - x_i$. The linear potential is $\\phi(x) = \\phi_i + \\xi \\frac{x-x_i}{\\Delta x}$. The integral evaluates to:\n$$\n\\int_{x_i}^{x_{i+1}} e^{-\\left(\\phi_i + \\xi \\frac{x-x_i}{\\Delta x}\\right)} dx = e^{-\\phi_i} \\Delta x \\frac{1 - e^{-\\xi}}{\\xi}\n$$\nSubstituting this back and solving for $J_n$:\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} e^{\\phi_i} (n_{i+1} e^{-\\phi_{i+1}} - n_i e^{-\\phi_i})\n$$\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} (n_{i+1} e^{\\phi_i - \\phi_{i+1}} - n_i) = \\frac{q D_n}{\\Delta x} \\frac{\\xi}{1-e^{-\\xi}} (n_{i+1} e^{-\\xi} - n_i)\n$$\nTo reveal the standard form, we distribute the prefactor:\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\left( n_{i+1} \\frac{\\xi e^{-\\xi}}{1 - e^{-\\xi}} - n_i \\frac{\\xi}{1-e^{-\\xi}} \\right)\n$$\nBy defining the Bernoulli function as $B(x) = \\frac{x}{e^x - 1}$, we can identify the terms. The first term's coefficient is $\\frac{\\xi e^{-\\xi}}{1 - e^{-\\xi}} = \\frac{\\xi}{e^{\\xi} - 1} = B(\\xi)$. The second term's coefficient is $\\frac{\\xi}{1-e^{-\\xi}} = \\frac{-\\xi}{e^{-\\xi}-1} = B(-\\xi)$. Therefore, the discretized current density is:\n$$\nJ_n = \\frac{q D_n}{\\Delta x} \\left[ n_{i+1} B(\\xi) - n_i B(-\\xi) \\right]\n$$\nThis derivation confirms that the core computational task is the stable evaluation of $B(\\xi) = \\frac{\\xi}{e^\\xi - 1}$.\n\n## Numerical Implementation Strategy\n\nThe function $B(\\xi) = \\frac{\\xi}{e^{\\xi} - 1}$ presents numerical difficulties for certain ranges of $\\xi$. A robust implementation requires a piecewise approach covering three distinct regimes for the argument $\\xi$.\n\n### Regime 1: Small $|\\xi|$\nFor $\\xi \\to 0$, both the numerator and denominator approach zero. Direct evaluation leads to a $0/0$ indeterminate form and suffers from catastrophic cancellation in floating-point arithmetic because $e^\\xi \\approx 1$. We use a Maclaurin series expansion, which is derived from the generating function of the Bernoulli numbers $b_k$:\n$$\nB(\\xi) = \\sum_{k=0}^{\\infty} b_k \\frac{\\xi^k}{k!} = b_0 + b_1 \\xi + \\frac{b_2}{2!} \\xi^2 + \\frac{b_4}{4!} \\xi^4 + \\frac{b_6}{6!} \\xi^6 + \\dots\n$$\nUsing the known values of the Bernoulli numbers ($b_0=1, b_1=-1/2, b_2=1/6, b_4=-1/30, b_6=1/42$, and $b_{2k+1}=0$ for $k\\ge1$), the series is:\n$$\nB(\\xi) = 1 - \\frac{1}{2}\\xi + \\frac{1}{12}\\xi^2 - \\frac{1}{720}\\xi^4 + \\frac{1}{30240}\\xi^6 - \\frac{1}{1209600}\\xi^8 + O(\\xi^{10})\n$$\nThe problem requires a relative error of about $10^{-12}$ for $|\\xi| \\leq 10^{-4}$. Let us truncate the series after the $\\xi^6$ term. The leading error term is $-\\frac{\\xi^8}{1209600}$. At the boundary of the region, $|\\xi| = 10^{-4}$, the absolute error is approximately $\\frac{(10^{-4})^8}{1209600} \\approx 8.3 \\times 10^{-39}$. Since $B(\\xi) \\approx 1$ in this region, this absolute error is also the relative error. This level of accuracy is far greater than required, ensuring the method's robustness. The chosen approximation is:\n$$\nB(\\xi) \\approx 1 - \\frac{\\xi}{2} + \\frac{\\xi^2}{12} - \\frac{\\xi^4}{720} + \\frac{\\xi^6}{30240}\n$$\n\n### Regime 2: Large $|\\xi|$\nFor large values of $|\\xi|$, the term $e^\\xi$ can cause overflow (large positive $\\xi$) or underflow (large negative $\\xi$). We use asymptotic approximations in these cases.\n- **For large positive $\\xi$**: As $\\xi \\to +\\infty$, $e^\\xi \\to \\infty$. The denominator $e^\\xi - 1 \\approx e^\\xi$.\n  $$ B(\\xi) = \\frac{\\xi}{e^\\xi-1} \\approx \\frac{\\xi}{e^\\xi} = \\xi e^{-\\xi} \\to 0 $$\n  For standard double-precision floating-point numbers, $e^\\xi$ overflows around $\\xi \\approx 709.7$. We select a conservative threshold, e.g., $\\xi > 37$. For $\\xi=37$, $B(37) \\approx 37 e^{-37} \\approx 3.0 \\times 10^{-15}$, which is already below machine epsilon. Thus, for $\\xi > 37$, we can safely approximate $B(\\xi) = 0$.\n- **For large negative $\\xi$**: Let $\\xi = -z$ where $z \\to +\\infty$.\n  $$ B(\\xi) = B(-z) = \\frac{-z}{e^{-z} - 1} $$\n  As $z \\to \\infty$, $e^{-z} \\to 0$. The denominator approaches $-1$.\n  $$ B(\\xi) \\approx \\frac{-z}{-1} = z = -\\xi $$\n  The error of this approximation is $B(\\xi) - (-\\xi) = \\frac{\\xi}{e^{\\xi}-1} + \\xi = \\frac{\\xi e^{\\xi}}{e^\\xi-1}$. For $\\xi < -37$, this error is on the order of $|\\xi|e^{\\xi}$, which underflows to zero. Thus, for $\\xi < -37$, we approximate $B(\\xi) = -\\xi$.\n\n### Regime 3: Moderate $|\\xi|$\nFor values of $\\xi$ that are not small enough for the series expansion and not large enough for the asymptotic approximation (i.e., $10^{-4} < |\\xi| \\leq 37$), the direct formula $B(\\xi) = \\frac{\\xi}{e^\\xi - 1}$ can be used. To maintain accuracy near the small-`|`$\\xi$`|` boundary, the denominator $e^\\xi - 1$ should be computed using a specialized library function such as `expm1(\\xi)`, which calculates the expression accurately even when $\\xi$ is close to zero.\n\n## Algorithmic Blueprint\nBased on the analysis, we can define the function $B(\\xi)$ piecewise:\n$$\nB(\\xi) =\n\\begin{cases}\n    1 - \\frac{1}{2}\\xi + \\frac{\\xi^2}{12} - \\frac{\\xi^4}{720} + \\frac{\\xi^6}{30240} & \\text{if } |\\xi| \\leq 10^{-4} \\\\\n    -\\xi & \\text{if } \\xi < -37 \\\\\n    0 & \\text{if } \\xi > 37 \\\\\n    \\frac{\\xi}{e^{\\xi}-1} & \\text{otherwise}\n\\end{cases}\n$$\nThis algorithm provides a complete, robust, and accurate method for evaluating the Bernoulli function across the entire range of real numbers, satisfying all constraints of the problem. For each test value $\\xi_k$, we will compute the pair $[B(\\xi_k), B(-\\xi_k)]$ by calling this function twice.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of evaluating the Bernoulli functions B(xi) and B(-xi)\n    for a given set of test cases using a numerically stable algorithm.\n    \"\"\"\n\n    # The test cases for xi provided in the problem statement.\n    test_cases = [\n        0,\n        1e-12,\n        -1e-12,\n        1e-8,\n        -1e-8,\n        0.1,\n        -0.1,\n        1.0,\n        -1.0,\n        10.0,\n        -10.0,\n        700.0,\n        -700.0,\n        1000.0,\n        -1000.0,\n    ]\n\n    def bernoulli(xi):\n        \"\"\"\n        Computes the Bernoulli function B(xi) = xi / (exp(xi) - 1)\n        using a numerically stable piecewise implementation.\n\n        Args:\n            xi (float): The input argument, a dimensionless potential drop.\n\n        Returns:\n            float: The value of B(xi).\n        \"\"\"\n        # Regime 1: Small |xi|. Use Maclaurin series expansion to avoid\n        # catastrophic cancellation from exp(xi) - 1 approaching 0.\n        # The threshold 1e-4 is from the problem statement.\n        if abs(xi) <= 1e-4:\n            # B(xi) = 1 - xi/2 + xi^2/12 - xi^4/720 + xi^6/30240 - ...\n            # Using Horner's method for efficient polynomial evaluation.\n            xi2 = xi * xi\n            # Coefficients from b_k / k!\n            c0 = 1.0\n            c1 = -0.5\n            c2 = 1.0/12.0\n            c4 = -1.0/720.0\n            c6 = 1.0/30240.0\n            \n            # Truncating at O(xi^6) gives more than enough precision.\n            return c0 + xi * (c1 + xi * (c2 + xi2 * (c4 + xi2 * c6)))\n\n        # Regime 2: Large negative xi.\n        # B(xi) approaches -xi as xi -> -inf.\n        # The threshold -37 is chosen as exp(xi) underflows below this value\n        # and the asymptotic approximation is highly accurate.\n        if xi < -37.0:\n            return -xi\n\n        # Regime 3: Large positive xi.\n        # B(xi) approaches 0 as xi -> +inf.\n        # The threshold +37 is chosen as exp(xi) is very large and B(xi) is\n        # smaller than machine precision.\n        if xi > 37.0:\n            return 0.0\n\n        # Regime 4: Moderate |xi|. The direct formula is stable.\n        # Use np.expm1(xi) to compute exp(xi) - 1 accurately.\n        return xi / np.expm1(xi)\n\n    results = []\n    for xi_val in test_cases:\n        # For each xi, calculate both B(xi) and B(-xi)\n        b_xi = bernoulli(xi_val)\n        b_minus_xi = bernoulli(-xi_val)\n        results.append([b_xi, b_minus_xi])\n\n    # The final print statement must produce only the specified single-line format.\n    # str(list) automatically adds the '[...]' formatting.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a stable function for $B(\\xi)$, we can now investigate why the Scharfetter-Gummel scheme is a cornerstone of device simulation. This comparative study challenges you to implement the SG method alongside simpler first-order upwind and second-order central difference schemes for a problem featuring a sharp internal potential drop. This hands-on comparison will vividly demonstrate the superior ability of the SG method's exponential fitting to handle drift-dominated transport, avoiding the non-physical oscillations and inaccuracies that plague conventional polynomial-based methods in such regimes .",
            "id": "3780759",
            "problem": "Consider the one-dimensional, steady-state electron transport in a semiconductor device under the drift-diffusion framework. Let the spatial domain be the closed interval $[0,1]$ with a uniform grid of $N$ nodes, and let the dimensionless electrostatic potential be denoted by $\\phi(x)$. Assume a sharp potential drop centered at $x_0$ with width $\\delta$ and total magnitude $\\Delta\\Phi$, so that $\\phi(x)$ is piecewise defined by a constant region on the left, a linear ramp of slope $\\Delta\\Phi/\\delta$ across the interval $[x_0-\\delta/2, x_0+\\delta/2]$, and a constant region on the right. Specifically, define\n$$\n\\phi(x) = \n\\begin{cases}\n0, & x \\le x_0 - \\delta/2, \\\\\n\\frac{\\Delta\\Phi}{\\delta}\\,\\left(x - \\left(x_0 - \\frac{\\delta}{2}\\right)\\right), & x_0 - \\delta/2 < x < x_0 + \\delta/2, \\\\\n\\Delta\\Phi, & x \\ge x_0 + \\delta/2.\n\\end{cases}\n$$\nAssume dimensionless scaling with electron diffusion coefficient equal to $1$, and use the Einstein relation between mobility and diffusion coefficient to justify this normalization. The electron flux $J_n$ in dimensionless form is given by the drift-diffusion law derived from fundamental transport principles,\n$$\nJ_n(x) = -\\left(\\frac{dn}{dx} + n(x)\\,\\frac{d\\phi}{dx}\\right),\n$$\nwhere $n(x)$ is the electron density. Consider the equilibrium zero-flux case $J_n(x) \\equiv 0$. Under this equilibrium assumption, the continuous solution satisfies the Boltzmann relation $n(x) \\propto \\exp(-\\phi(x))$. Impose the left Dirichlet boundary condition $n(0) = 1$ for all cases, so that the exact reference solution on the grid is $n_{\\text{exact}}(x_i) = \\exp(-\\phi(x_i))$.\n\nYour task is to implement three different numerical discretizations of the zero-flux equilibrium recurrence for $n$ across the grid cells, starting from $n(0)=1$:\n\n- A first-order upwind finite difference discretization of the convective term (choose the upwind state according to the sign of the local cell potential increment).\n- A second-order central finite difference discretization of the convective term.\n- The Scharfetter-Gummel (SG) discretization derived from integrating the drift-diffusion equation exactly over each cell under the assumption of locally constant field.\n\nDo not use any pre-derived discretization formulas from external sources; derive each recurrence from the governing flux law and the stated assumptions. For each cell $[x_i,x_{i+1}]$, compute the local potential increment $\\Delta\\phi_i = \\phi(x_{i+1}) - \\phi(x_i)$ and use it to propagate $n_i$ to $n_{i+1}$ according to each scheme. For the SG method, use the appropriate cell relation implied by exact integration under locally constant field.\n\nNumerical grid construction details:\n\n- Use a uniform grid of $N$ nodes with $x_i = i/(N-1)$ for $i=0,1,\\dots,N-1$.\n- Construct $\\phi(x_i)$ exactly from the piecewise definition above using the given $\\Delta\\Phi$, $\\delta$, and $x_0$.\n\nEvaluation metrics to compute for each method and each test case:\n\n- The absolute error at the right boundary, defined as $|n_{\\text{method}}(x_{N-1}) - n_{\\text{exact}}(x_{N-1})|$.\n- A positivity boolean indicating whether all computed nodal densities are strictly positive across the domain.\n- The maximum absolute nodal error, defined as $\\max_i |n_{\\text{method}}(x_i) - n_{\\text{exact}}(x_i)|$.\n\nTest suite:\n\nCompute the metrics above for the following parameter sets, which collectively exercise a moderate \"happy path\" regime and increasingly sharp boundary layers:\n\n- Case $1$: $N=100$, $\\Delta\\Phi=1$, $\\delta=0.2$, $x_0=0.5$.\n- Case $2$: $N=100$, $\\Delta\\Phi=5$, $\\delta=0.02$, $x_0=0.5$.\n- Case $3$: $N=200$, $\\Delta\\Phi=10$, $\\delta=0.01$, $x_0=0.5$.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a list of seven entries ordered as follows:\n$[$absolute right-end error for Scharfetter-Gummel, absolute right-end error for upwind, absolute right-end error for central, positivity boolean for upwind, positivity boolean for central, maximum absolute error for upwind over all nodes, maximum absolute error for central over all nodes$]$.\n\nAggregate the results for all three test cases as a list of these per-case lists. For example, the final output should look like\n$[[\\ldots],[\\ldots],[\\ldots]]$\nwith no spaces.",
            "solution": "The problem presented is a valid and well-posed exercise in the numerical analysis of semiconductor transport equations. It is scientifically grounded in the drift-diffusion model, provides a complete and consistent set of parameters, and asks for a meaningful comparison of standard numerical schemes against an analytical solution. We will proceed by first deriving the recurrence relations for each of the three specified discretization methods and then implementing them to compute the required error metrics.\n\nThe governing physical law is the one-dimensional, steady-state drift-diffusion equation for electron flux, $J_n$. Under the specified equilibrium condition ($J_n(x) \\equiv 0$), the equation simplifies to:\n$$\nJ_n(x) = -\\left(\\frac{dn}{dx} + n(x)\\,\\frac{d\\phi}{dx}\\right) = 0\n$$\nwhere $n(x)$ is the electron density and $\\phi(x)$ is the dimensionless electrostatic potential. This is a first-order ordinary differential equation (ODE) for $n(x)$:\n$$\n\\frac{dn}{dx} = -n(x)\\frac{d\\phi}{dx}\n$$\nThe problem specifies a uniform grid with $N$ nodes $x_i = i/(N-1)$ for $i=0, 1, \\dots, N-1$. Let the grid spacing be $h = x_{i+1} - x_i = 1/(N-1)$. Our task is to derive recurrence relations to compute the nodal density $n_{i+1} = n(x_{i+1})$ given the value at the previous node, $n_i = n(x_i)$. Let $\\Delta\\phi_i = \\phi(x_{i+1}) - \\phi(x_i) = \\phi_{i+1} - \\phi_i$ be the potential difference across the cell $[x_i, x_{i+1}]$.\n\nThe continuous solution to the ODE with the boundary condition $n(0)=1$ and $\\phi(0)=0$ is $n(x) = \\exp(-\\phi(x))$. This will serve as our exact reference solution on the grid: $n_{\\text{exact}}(x_i) = \\exp(-\\phi(x_i))$.\n\nThe three numerical schemes approximate the flux $J_{n, i+1/2}$ at the midpoint of the cell $[x_i, x_{i+1}]$ and set it to zero. A simple finite difference approximation of the flux is:\n$$\nJ_{n, i+1/2} \\approx -\\left(\\frac{n_{i+1} - n_i}{h} + n_{i+1/2} \\frac{\\phi_{i+1} - \\phi_i}{h}\\right) = 0\n$$\nThis leads to the core discrete relation that the three schemes interpret differently:\n$$\nn_{i+1} - n_i + n_{i+1/2} (\\phi_{i+1} - \\phi_i) = 0\n$$\nwhere $n_{i+1/2}$ is an approximation of the density at the cell interface.\n\n**1. Central Finite Difference Discretization**\n\nThis scheme approximates the interface density $n_{i+1/2}$ using a simple arithmetic mean of the nodal densities:\n$$\nn_{i+1/2} \\approx \\frac{n_i + n_{i+1}}{2}\n$$\nSubstituting this into the core relation gives:\n$$\nn_{i+1} - n_i + \\left(\\frac{n_i + n_{i+1}}{2}\\right) \\Delta\\phi_i = 0\n$$\nWe solve for $n_{i+1}$:\n$$\nn_{i+1} \\left(1 + \\frac{\\Delta\\phi_i}{2}\\right) = n_i \\left(1 - \\frac{\\Delta\\phi_i}{2}\\right)\n$$\n$$\nn_{i+1} = n_i \\frac{1 - \\Delta\\phi_i/2}{1 + \\Delta\\phi_i/2} = n_i \\frac{2 - \\Delta\\phi_i}{2 + \\Delta\\phi_i}\n$$\nThis recurrence is second-order accurate for small $\\Delta\\phi_i$. However, if $|\\Delta\\phi_i| > 2$, the calculated $n_{i+1}$ can become negative even if $n_i$ is positive, violating the physical constraint of positive carrier density.\n\n**2. First-Order Upwind Finite Difference Discretization**\n\nThe upwind scheme approximates $n_{i+1/2}$ by selecting the upstream nodal value. The direction of \"flow\" is determined by the sign of the electric field, $E_{i+1/2} \\approx \\Delta\\phi_i/h$.\n\n- If $E_{i+1/2} > 0$ (i.e., $\\Delta\\phi_i > 0$), the convective field points from $i$ to $i+1$. The upstream node is $i$, so we set $n_{i+1/2} = n_i$. The recurrence becomes:\n  $$\n  n_{i+1} - n_i + n_i \\Delta\\phi_i = 0 \\implies n_{i+1} = n_i (1 - \\Delta\\phi_i)\n  $$\n- If $E_{i+1/2} < 0$ (i.e., $\\Delta\\phi_i < 0$), the convective field points from $i+1$ to $i$. The upstream node is $i+1$, so we set $n_{i+1/2} = n_{i+1}$. The recurrence becomes:\n  $$\n  n_{i+1} - n_i + n_{i+1} \\Delta\\phi_i = 0 \\implies n_{i+1}(1+\\Delta\\phi_i) = n_i \\implies n_{i+1} = \\frac{n_i}{1 + \\Delta\\phi_i}\n  $$\n- If $\\Delta\\phi_i = 0$, both formulas correctly yield $n_{i+1}=n_i$.\n\nThis scheme is only first-order accurate but is more stable than the central difference scheme. However, it can still produce non-physical negative densities if $\\Delta\\phi_i > 1$ or if $\\Delta\\phi_i \\le -1$.\n\n**3. Scharfetter-Gummel (SG) Discretization**\n\nThe SG scheme is derived by assuming that the flux $J_n$ and the electric field $E$ are constant within each cell $[x_i, x_{i+1}]$. The constant field is $E = \\Delta\\phi_i/h$. Under these assumptions, the drift-diffusion equation becomes a first-order linear ODE with constant coefficients within the cell:\n$$\n\\frac{dn}{dx} + E n(x) = -\\frac{J_n}{D_n}\n$$\nWith the specified normalization $D_n=1$, we have:\n$$\n\\frac{dn}{dx} + E n(x) = -J_n\n$$\nThis ODE can be solved exactly over the interval $[x_i, x_{i+1}]$ using the integrating factor $e^{E(x-x_i)}$. The solution relates the nodal densities to the constant flux $J_n$:\n$$\nJ_n = -\\frac{D_n E}{e^{Eh}-1} \\left( n_{i+1}e^{Eh} - n_i \\right)\n$$\nSubstituting $D_n=1$, $E=\\Delta\\phi_i/h$, and simplifying yields the famous SG current relation:\n$$\nJ_{n, i+1/2} = -\\frac{1}{h} \\left( n_{i+1} B(-\\Delta\\phi_i) - n_i B(\\Delta\\phi_i) \\right)\n$$\nwhere $B(x) = x/(e^x - 1)$ is the Bernoulli function.\n\nFor the equilibrium case, we enforce $J_{n, i+1/2} = 0$:\n$$\nn_{i+1} B(-\\Delta\\phi_i) - n_i B(\\Delta\\phi_i) = 0\n$$\n$$\nn_{i+1} = n_i \\frac{B(\\Delta\\phi_i)}{B(-\\Delta\\phi_i)}\n$$\nSubstituting the definition of the Bernoulli function:\n$$\n\\frac{B(\\Delta\\phi_i)}{B(-\\Delta\\phi_i)} = \\frac{\\Delta\\phi_i / (e^{\\Delta\\phi_i}-1)}{-\\Delta\\phi_i / (e^{-\\Delta\\phi_i}-1)} = -\\frac{e^{-\\Delta\\phi_i}-1}{e^{\\Delta\\phi_i}-1} = -\\frac{e^{-\\Delta\\phi_i}(1-e^{\\Delta\\phi_i})}{e^{\\Delta\\phi_i}-1} = e^{-\\Delta\\phi_i}\n$$\nThus, for the zero-flux case, the SG recurrence simplifies to:\n$$\nn_{i+1} = n_i e^{-\\Delta\\phi_i}\n$$\nThis recurrence relation is identical to the relationship between adjacent points in the exact analytical solution, $n(x_i) = \\exp(-\\phi(x_i))$. Consequently, the SG method will compute the nodal densities to machine precision, and the associated errors will be practically zero. This demonstrates the power of the method, as it preserves the physical Boltzmann relation anumerically.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D drift-diffusion problem for three schemes and reports metrics.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, DeltaPhi, delta, x0)\n        (100, 1.0, 0.2, 0.5),\n        (100, 5.0, 0.02, 0.5),\n        (200, 10.0, 0.01, 0.5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, dPhi, delta, x0 = case\n        \n        # 1. Construct grid and potential profile\n        x = np.linspace(0.0, 1.0, N)\n        \n        phi = np.zeros(N)\n        left_boundary = x0 - delta / 2.0\n        right_boundary = x0 + delta / 2.0\n        \n        # Vectorized calculation of the piecewise potential\n        in_ramp = (x > left_boundary) & (x < right_boundary)\n        right_of_ramp = x >= right_boundary\n        \n        if delta > 0:\n            phi[in_ramp] = (dPhi / delta) * (x[in_ramp] - left_boundary)\n        phi[right_of_ramp] = dPhi\n        \n        # 2. Compute exact solution\n        n_exact = np.exp(-phi)\n        \n        # 3. Initialize solution arrays for the three methods\n        n_sg = np.zeros(N)\n        n_upwind = np.zeros(N)\n        n_central = np.zeros(N)\n        \n        # Apply Dirichlet boundary condition at x=0\n        n_sg[0] = 1.0\n        n_upwind[0] = 1.0\n        n_central[0] = 1.0\n        \n        # 4. March across the grid and apply recurrence relations\n        for i in range(N - 1):\n            dphi_i = phi[i+1] - phi[i]\n            \n            # Scharfetter-Gummel\n            n_sg[i+1] = n_sg[i] * np.exp(-dphi_i)\n            \n            # Upwind\n            if dphi_i > 0:\n                n_upwind[i+1] = n_upwind[i] * (1.0 - dphi_i)\n            else: # dphi_i <= 0\n                # Avoid division by zero, though not expected for these test cases\n                denom = 1.0 + dphi_i\n                if abs(denom) < 1e-15:\n                    # In this edge case, density would blow up, use large number\n                    n_upwind[i+1] = np.finfo(float).max\n                else:\n                    n_upwind[i+1] = n_upwind[i] / denom\n\n            # Central Difference\n            denom = 2.0 + dphi_i\n            if abs(denom) < 1e-15:\n                 # In this edge case, density would blow up, use large number\n                n_central[i+1] = np.finfo(float).max\n            else:\n                 n_central[i+1] = n_central[i] * (2.0 - dphi_i) / denom\n                 \n        # 5. Calculate evaluation metrics\n        err_sg_end = abs(n_sg[-1] - n_exact[-1])\n        err_up_end = abs(n_upwind[-1] - n_exact[-1])\n        err_cen_end = abs(n_central[-1] - n_exact[-1])\n        \n        pos_up = bool(np.all(n_upwind > 0))\n        pos_cen = bool(np.all(n_central > 0))\n        \n        max_err_up = np.max(np.abs(n_upwind - n_exact))\n        max_err_cen = np.max(np.abs(n_central - n_exact))\n        \n        # Assemble results for the current case in the specified order\n        case_results = [\n            err_sg_end, err_up_end, err_cen_end,\n            pos_up, pos_cen,\n            max_err_up, max_err_cen\n        ]\n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # Using str() and replace() is a robust way to get the required format\n    # with no spaces and correct boolean representation.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "A complete simulation requires assembling the contributions from all mesh edges into a single, coherent global system. This final practice addresses the crucial mechanics of constructing this system matrix within a finite-volume framework, focusing on consistent edge orientation and sign conventions to guarantee the resulting discrete system upholds the physical law of conservation. Mastering this assembly process will solidify your understanding of how the local Scharfetter-Gummel flux formula is integrated to form a well-posed global problem that can be solved numerically .",
            "id": "3780755",
            "problem": "Consider a one-dimensional discretization of a drift-diffusion semiconductor transport model assembled by the Finite Volume Method (FVM) using the Scharfetter-Gummel (SG) edge flux. All quantities are nondimensionalized by the thermal voltage so there are no physical units in this problem. The fundamental base is the steady-state electron continuity equation and drift-diffusion constitutive law: the divergence of electron current density is zero, the electron current density is the sum of drift and diffusion, and the Einstein relation holds between diffusion and mobility. Your task is to design and implement an orientation-consistent assembly of the global discrete operator that maps nodal electron density to the net oriented flux residual at each node.\n\nStarting point from first principles:\n- The steady-state electron continuity law states that the divergence of electron current density is zero, which at the discrete level is enforced by balancing the sum of outgoing and incoming edge fluxes at each control volume.\n- The drift-diffusion constitutive law for electron transport is the sum of drift proportional to electric field and density, and diffusion proportional to the density gradient, with the Einstein relation linking diffusion coefficient to mobility through the thermal voltage.\n- The Scharfetter-Gummel discretization results from assuming a constant electric field along an edge and an exponential variation of density, yielding a closed-form, monotone, and conservative edge flux formula that depends on the potential drop across the edge and the nodal densities.\n- The Bernoulli response function appears naturally in the SG edge flux under the exponential fitting, and must be evaluated in a numerically stable way, especially near zero argument.\n\nEdge orientation and global conservation requirements:\n- Each edge connecting two nodes must be assigned a consistent orientation from a source node to a target node. The choice of orientation is arbitrary but must be used consistently in the assembly.\n- The contribution of each edge flux to the residual at its two incident nodes must be signed such that the flux leaving one node enters the other node exactly, ensuring local conservation and that the global sum of all residuals is zero for interior-only meshes.\n- When the electric potential is constant (zero electric field), the assembled operator reduces to a pure diffusion operator that is symmetric for a uniform, one-dimensional grid with constant diffusion coefficient.\n\nYour program must:\n1. Implement the Bernoulli response function in a numerically stable way, denoted by $B(x)$, with the well-defined limit at $x = 0$.\n2. For a given one-dimensional mesh with nodes at coordinates $\\{x_i\\}$, an oriented set of edges $\\{(i \\rightarrow j)\\}$, nodal electric potentials $\\{\\varphi_i\\}$, and a constant diffusion coefficient $D$, assemble a global matrix $A$ and compute the residual $\\mathbf{r} = A \\mathbf{n}$ for a given nodal electron density vector $\\mathbf{n}$. The assembly must use a consistent edge orientation and sign the edge contributions so that the flux contribution added to the source node is the negative of the contribution subtracted from the target node, guaranteeing conservation.\n3. Verify, via test cases, that the assembly is conservative, orientation-invariant, and symmetric where appropriate.\n\nTest suite and parameters (all quantities are nondimensional):\n- Test case $1$ (symmetric diffusion and constant solution):\n  - Nodes: $x = [\\,0.0,\\,0.5,\\,1.0\\,]$.\n  - Oriented edges: $(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$.\n  - Potential: $\\varphi = [\\,0.0,\\,0.0,\\,0.0\\,]$.\n  - Diffusion coefficient: $D = 1.0$.\n  - Density: $\\mathbf{n} = [\\,1.0,\\,1.0,\\,1.0\\,]$.\n  - Required checks: the matrix $A$ is symmetric (to a numerical tolerance) and the residual $\\mathbf{r}$ is the zero vector (to a numerical tolerance).\n\n- Test case $2$ (conservation under nonzero field):\n  - Nodes: $x = [\\,0.0,\\,0.5,\\,1.0\\,]$.\n  - Oriented edges: $(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$.\n  - Potential: $\\varphi = [\\,0.0,\\,0.1,\\,0.2\\,]$.\n  - Diffusion coefficient: $D = 1.0$.\n  - Density: $\\mathbf{n} = [\\,0.8,\\,1.1,\\,0.9\\,]$.\n  - Required check: the global sum $\\sum_i r_i$ is numerically zero, demonstrating conservation.\n\n- Test case $3$ (orientation invariance):\n  - Nodes: $x = [\\,0.0,\\,0.5,\\,1.0\\,]$.\n  - Two oriented edge sets describing the same physical connectivity:\n    - Forward orientation: $(0 \\rightarrow 1)$, $(1 \\rightarrow 2)$.\n    - Reversed orientation: $(1 \\rightarrow 0)$, $(2 \\rightarrow 1)$.\n  - Potential: $\\varphi = [\\,0.0,\\,0.1,\\,0.2\\,]$.\n  - Diffusion coefficient: $D = 1.0$.\n  - Density: $\\mathbf{n} = [\\,0.7,\\,1.0,\\,1.2\\,]$.\n  - Required check: the assembled matrices and residuals from the two orientations are identical to within a numerical tolerance.\n\n- Test case $4$ (boundary edge and monotonicity with strong field):\n  - Nodes: $x = [\\,0.0,\\,1.0\\,]$.\n  - Oriented edge: $(0 \\rightarrow 1)$.\n  - Potential: $\\varphi = [\\,0.0,\\,5.0\\,]$.\n  - Diffusion coefficient: $D = 1.0$.\n  - Density: $\\mathbf{n} = [\\,1.0,\\,2.0\\,]$.\n  - Required checks: the off-diagonal entries of the assembled $A$ are nonpositive and the diagonal entries are positive, and the global sum $\\sum_i r_i$ is numerically zero.\n\nAlgorithmic requirements:\n- Compute each edge length $L$ as $L = |x_j - x_i|$ for an edge $(i \\rightarrow j)$.\n- Use a single, consistent orientation per edge when computing the potential drop $\\,\\Delta \\varphi = \\varphi_j - \\varphi_i\\,$ and assembling the signed contributions into $A$ and $\\mathbf{r}$.\n- Employ a numerical tolerance of $10^{-10}$ when checking equality of floating-point values.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3,result4]$), where each $result$ is a boolean indicating whether the corresponding test case passed. The booleans must be printed in the programming language’s canonical boolean form.",
            "solution": "The problem requires the design and implementation of a procedure to assemble the global discrete operator for a one-dimensional, steady-state, drift-diffusion electron transport model. The assembly must use the Scharfetter-Gummel (SG) discretization scheme within a Finite Volume Method (FVM) framework. The resulting operator, a matrix $A$, maps the vector of nodal electron densities $\\mathbf{n}$ to the vector of nodal flux residuals $\\mathbf{r}$, such that $\\mathbf{r} = A\\mathbf{n}$.\n\n### Step 1: Problem Validation\n\n**1.1. Extract Givens**\n- **Model**: One-dimensional, steady-state electron continuity equation with a drift-diffusion constitutive law. All quantities are nondimensionalized by the thermal voltage.\n- **Discretization**: Finite Volume Method with Scharfetter-Gummel edge flux.\n- **Equation (Continuity)**: $\\nabla \\cdot \\mathbf{J}_n = 0$, which discretizes to a balance of fluxes at each control volume.\n- **Equation (Constitutive)**: Electron current density $\\mathbf{J}_n$ is the sum of drift (proportional to electric field and density) and diffusion (proportional to the density gradient). The Einstein relation is assumed to hold.\n- **SG Flux**: Based on a constant electric field assumption along a mesh edge and yields a closed-form expression for the edge flux involving the Bernoulli function $B(x)$.\n- **Assembly requirements**:\n    - Use a consistent, arbitrary orientation for each edge $(i \\rightarrow j)$.\n    - The flux contribution to the source node's residual must be the negative of the contribution to the target node's residual, ensuring local and global conservation.\n- **Inputs**: Mesh node coordinates $\\{x_i\\}$, an oriented set of edges $\\{(i \\rightarrow j)\\}$, nodal electric potentials $\\{\\varphi_i\\}$, a constant diffusion coefficient $D$, and a nodal electron density vector $\\mathbf{n}$.\n- **Output**: The global matrix $A$ and the residual vector $\\mathbf{r} = A\\mathbf{n}$.\n- **Bernoulli function**: Must be implemented in a numerically stable way, denoted $B(x)$, with special care for $x \\approx 0$.\n- **Test cases**: Four specific test cases are provided with all necessary parameters and checks to verify symmetry, conservation, orientation invariance, and monotonicity properties.\n- **Numerical Tolerance**: $10^{-10}$ for floating-point comparisons.\n\n**1.2. Validate Using Extracted Givens**\n- **Scientifically Grounded (Critical)**: The problem is fundamentally based on the drift-diffusion model, a cornerstone of semiconductor device physics, and the Scharfetter-Gummel scheme, a widely used and validated numerical method in this field. The principles are well-established. (Valid)\n- **Well-Posed**: The problem is clearly defined. The inputs are specified, and the desired output (the matrix operator $A$ and residual $\\mathbf{r}$) is uniquely determined by the inputs and the specified physical and numerical model. The test cases provide concrete verification criteria. (Valid)\n- **Objective (Critical)**: The problem is stated using precise, formal mathematical and physical language. There are no subjective or opinion-based components. (Valid)\n- **Scientific or Factual Unsoundness**: No violations are present. The physics and mathematics are standard.\n- **Non-Formalizable or Irrelevant**: The problem is directly formalizable and is central to the topic of the Scharfetter-Gummel method.\n- **Incomplete or Contradictory Setup**: The setup is complete. All necessary data and conditions for the test cases are provided. The description of physical conservation and its implication on the assembly is consistent.\n- **Unrealistic or Infeasible**: The parameters are nondimensionalized and represent standard test conditions for such numerical schemes. No physical impossibilities are involved.\n- **Ill-Posed or Poorly Structured**: The problem is well-structured, leading to a unique solution.\n- **Pseudo-Profound, Trivial, or Tautological**: The problem addresses a non-trivial task in numerical modeling, requiring careful implementation of the SG scheme and assembly process. The test cases are designed to probe key properties of a correct implementation.\n- **Outside Scientific Verifiability**: The results are fully verifiable by calculation and comparison against the known theoretical properties of the SG scheme.\n\n**1.3. Verdict and Action**\nThe problem is valid. A reasoned solution will be provided.\n\n### Step 2: Derivation and Algorithmic Design\n\n**2.1. The Scharfetter-Gummel Flux**\nThe one-dimensional, steady-state drift-diffusion equation for electron particle flux $J_n$ (which the problem calls \"electron current density\") is:\n$$ J_n(x) = D \\left( \\frac{dn}{dx} - n \\frac{d\\varphi}{dx} \\right) $$\nwhere $n$ is the electron density, $\\varphi$ is the nondimensionalized electric potential, and $D$ is the diffusion coefficient. The continuity equation requires $\\frac{dJ_n}{dx}=0$, meaning $J_n$ is constant along any segment without sources or sinks.\n\nThe Scharfetter-Gummel method discretizes this equation over a mesh edge connecting nodes $i$ and $j$. It assumes the electric field, $-\\frac{d\\varphi}{dx}$, is constant along the edge. For an edge of length $L = |x_j - x_i|$ with potential drop $\\Delta\\varphi = \\varphi_j - \\varphi_i$, this gives $\\frac{d\\varphi}{dx} = \\frac{\\Delta\\varphi}{L}$. The ODE can then be solved for $n(x)$ subject to boundary conditions $n(x_i)=n_i$ and $n(x_j)=n_j$. Solving for the constant flux $J_n$ gives the celebrated SG formula. The particle flux from a source node $i$ to a target node $j$ is:\n$$ J_{i \\to j} = \\frac{D}{L_{ij}} \\left[ n_i B(\\varphi_i - \\varphi_j) - n_j B(\\varphi_j - \\varphi_i) \\right] $$\nwhere $L_{ij} = |x_j - x_i|$ is the edge length and $B(x) = \\frac{x}{e^x - 1}$ is the Bernoulli function. Using the potential difference along the oriented edge, $\\Delta\\varphi = \\varphi_j - \\varphi_i$, the flux can be written as:\n$$ J_{i \\to j} = \\frac{D}{L_{ij}} \\left[ n_i B(-\\Delta\\varphi) - n_j B(\\Delta\\varphi) \\right] $$\n\n**2.2. The Bernoulli Function**\nThe Bernoulli function $B(x)$ requires careful numerical evaluation near $x=0$, where the direct formula leads to a $0/0$ indeterminacy. The limit is $\\lim_{x\\to0} B(x) = 1$. For small $|x|$, `np.expm1(x)` provides an accurate value of $e^x - 1$. However, to robustly handle the $x=0$ case and surrounding floating-point values, we will use the Taylor series expansion for $|x|$ below a small threshold:\n$$ B(x) = 1 - \\frac{x}{2} + \\frac{x^2}{12} - O(x^4) $$\nFor $|x| < 10^{-10}$, this expansion is highly accurate. For larger $|x|$, the direct formula $x / (e^x - 1)$ using `np.expm1` is stable and efficient.\n\n**2.3. Operator Assembly**\nThe residual $r_k$ at a node $k$ is the net particle flux leaving the control volume surrounding node $k$. For an oriented edge $(i \\to j)$, the flux $J_{i \\to j}$ leaves node $i$ and enters node $j$. Therefore, its contribution to the residuals is:\n- $\\Delta r_i = +J_{i \\to j}$\n- $\\Delta r_j = -J_{i \\to j}$\n\nWe seek the matrix $A$ such that $\\mathbf{r} = A\\mathbf{n}$. Substituting the flux formula into the residual contributions:\n$$ \\Delta r_i = \\left(\\frac{D}{L_{ij}} B(-\\Delta\\varphi)\\right) n_i - \\left(\\frac{D}{L_{ij}} B(\\Delta\\varphi)\\right) n_j $$\n$$ \\Delta r_j = -\\left(\\frac{D}{L_{ij}} B(-\\Delta\\varphi)\\right) n_i + \\left(\\frac{D}{L_{ij}} B(\\Delta\\varphi)\\right) n_j $$\n\nThis directly gives the updates to the matrix $A$ for each edge $(i \\to j)$:\nLet $g_{ij} = \\frac{D}{L_{ij}} B(-\\Delta\\varphi)$ and $g_{ji} = \\frac{D}{L_{ij}} B(\\Delta\\varphi)$.\n- $A_{ii} \\mathrel{+}= g_{ij}$\n- $A_{ij} \\mathrel{+}= -g_{ji}$\n- $A_{ji} \\mathrel{+}= -g_{ij}$\n- $A_{jj} \\mathrel{+}= g_{ji}$\n\nThis assembly process ensures key properties:\n- **Conservation**: The sum of column entries for any column $k$ in $A$ is zero. This is because for each edge affecting column $k$, an equal and opposite amount is added to two different rows. This implies $\\sum_i A_{ik} = 0$ for all $k$, so $\\mathbf{1}^T A = \\mathbf{0}^T$. Consequently, the global sum of residuals $\\sum_k r_k = \\mathbf{1}^T \\mathbf{r} = (\\mathbf{1}^T A)\\mathbf{n} = 0$ for any density vector $\\mathbf{n}$.\n- **Symmetry**: If the potential is constant, $\\Delta\\varphi = 0$ for all edges. Then $B(0)=1$, so $g_{ij} = g_{ji} = D/L_{ij}$. The update rule becomes symmetric: $A_{ij}$ gets $-D/L_{ij}$ and $A_{ji}$ also gets $-D/L_{ij}$. The resulting matrix $A$ is symmetric.\n- **Orientation Invariance**: The flux $J_{j \\to i} = -J_{i \\to j}$. If we reverse the edge orientation to $(j \\to i)$, the contribution to $r_j$ becomes $+J_{j \\to i} = -J_{i \\to j}$ and to $r_i$ becomes $-J_{j \\to i} = +J_{i \\to j}$. These are the exact same updates to the residuals as for the edge $(i \\to j)$, so the final assembled matrix $A$ is independent of the chosen edge orientations.\n- **Monotonicity**: The SG scheme is designed to be monotone. This manifests as the assembled matrix $A$ (for the pure transport problem) being a non-singular M-matrix, which requires positive diagonal entries and non-positive off-diagonal entries. Since $B(x) > 0$ for all real $x$, the coefficients $g_{ij}$ and $g_{ji}$ are always positive. Thus, off-diagonal elements $A_{ij}$ and $A_{ji}$ (for $i \\neq j$) are sums of negative terms (like $-g_{ji}$), and are therefore non-positive. Diagonal elements $A_{ii}$ are sums of positive terms and are therefore positive.\n\nThe implementation will follow this algorithmic design to assemble the matrix $A$ for each test case, compute the residual $\\mathbf{r}$, and perform the specified checks.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines, runs, and evaluates the test cases\n    for the Scharfetter-Gummel discretization.\n    \"\"\"\n\n    TOL = 1e-10\n\n    def B(x):\n        \"\"\"\n        Numerically stable Bernoulli function B(x) = x / (exp(x) - 1).\n        Uses a Taylor series expansion for small |x| to avoid numerical issues.\n        \"\"\"\n        if abs(x) < TOL:\n            # Taylor series: 1 - x/2 + x^2/12 - x^4/720 + ...\n            # The first three terms are sufficient for this tolerance.\n            return 1.0 - x / 2.0 + (x**2) / 12.0\n        else:\n            return x / np.expm1(x)\n\n    def assemble(nodes, edges, potential, D, n_vec):\n        \"\"\"\n        Assembles the Scharfetter-Gummel operator matrix A and computes the\n        residual vector r = A @ n.\n        \"\"\"\n        num_nodes = len(nodes)\n        A = np.zeros((num_nodes, num_nodes))\n\n        for i_src, i_tgt in edges:\n            # 1. Compute edge properties\n            L = abs(nodes[i_tgt] - nodes[i_src])\n            d_phi = potential[i_tgt] - potential[i_src]\n\n            # 2. Compute SG coefficients\n            # Flux J_{i->j} = g_ij * n_i - g_ji * n_j\n            # g_ij corresponds to the source node i, g_ji to target node j\n            g_ij = (D / L) * B(-d_phi)\n            g_ji = (D / L) * B(d_phi)\n\n            # 3. Assemble contributions into the global matrix A\n            # Contribution to residual r_i is +J_{i->j}\n            A[i_src, i_src] += g_ij\n            A[i_src, i_tgt] -= g_ji\n\n            # Contribution to residual r_j is -J_{i->j}\n            A[i_tgt, i_src] -= g_ij\n            A[i_tgt, i_tgt] += g_ji\n\n        # 4. Compute residual\n        r = A @ n_vec\n        return A, r\n\n    # --- Test Cases ---\n\n    test_cases = [\n        {\n            \"name\": \"Test Case 1: Symmetric Diffusion\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges\": [(0, 1), (1, 2)],\n            \"potential\": np.array([0.0, 0.0, 0.0]),\n            \"D\": 1.0,\n            \"n\": np.array([1.0, 1.0, 1.0]),\n            \"check\": lambda A, r: (\n                np.allclose(A, A.T, atol=TOL, rtol=0) and\n                np.allclose(r, np.zeros_like(r), atol=TOL, rtol=0)\n            )\n        },\n        {\n            \"name\": \"Test Case 2: Conservation\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges\": [(0, 1), (1, 2)],\n            \"potential\": np.array([0.0, 0.1, 0.2]),\n            \"D\": 1.0,\n            \"n\": np.array([0.8, 1.1, 0.9]),\n            \"check\": lambda A, r: np.isclose(np.sum(r), 0.0, atol=TOL, rtol=0)\n        },\n        {\n            \"name\": \"Test Case 3: Orientation Invariance\",\n            \"nodes\": np.array([0.0, 0.5, 1.0]),\n            \"edges_fwd\": [(0, 1), (1, 2)],\n            \"edges_rev\": [(1, 0), (2, 1)],\n            \"potential\": np.array([0.0, 0.1, 0.2]),\n            \"D\": 1.0,\n            \"n\": np.array([0.7, 1.0, 1.2]),\n            \"check\": lambda A_fwd, r_fwd, A_rev, r_rev: (\n                np.allclose(A_fwd, A_rev, atol=TOL, rtol=0) and\n                np.allclose(r_fwd, r_rev, atol=TOL, rtol=0)\n            )\n        },\n        {\n            \"name\": \"Test Case 4: Monotonicity\",\n            \"nodes\": np.array([0.0, 1.0]),\n            \"edges\": [(0, 1)],\n            \"potential\": np.array([0.0, 5.0]),\n            \"D\": 1.0,\n            \"n\": np.array([1.0, 2.0]),\n            \"check\": lambda A, r: (\n                # Off-diagonals non-positive\n                (A[0, 1] <= TOL) and (A[1, 0] <= TOL) and\n                # Diagonals positive\n                (A[0, 0] > 0) and (A[1, 1] > 0) and\n                # Conservation\n                np.isclose(np.sum(r), 0.0, atol=TOL, rtol=0)\n            )\n        }\n    ]\n\n    results = []\n    \n    # Test Case 1\n    case = test_cases[0]\n    A1, r1 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A1, r1))\n\n    # Test Case 2\n    case = test_cases[1]\n    A2, r2 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A2, r2))\n\n    # Test Case 3\n    case = test_cases[2]\n    A_fwd, r_fwd = assemble(case[\"nodes\"], case[\"edges_fwd\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    A_rev, r_rev = assemble(case[\"nodes\"], case[\"edges_rev\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A_fwd, r_fwd, A_rev, r_rev))\n\n    # Test Case 4\n    case = test_cases[3]\n    A4, r4 = assemble(case[\"nodes\"], case[\"edges\"], case[\"potential\"], case[\"D\"], case[\"n\"])\n    results.append(case[\"check\"](A4, r4))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}