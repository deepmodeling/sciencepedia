{"hands_on_practices": [{"introduction": "The hydrophobic effect is a primary driving force in protein folding, causing nonpolar residues to cluster in the protein core while polar residues remain exposed to the aqueous solvent. A fundamental approach in fold recognition, therefore, is to score how well a sequence fits a template structure based on this principle. This first practice challenges you to implement a simple but powerful scoring function that quantifies this fit by rewarding the placement of hydrophilic residues on the surface and hydrophobic residues in the core, giving you a tangible feel for how biophysical principles are translated into a computational model [@problem_id:2391514].", "problem": "You are given a fixed-length threading evaluation setup that scores the placement of amino acid residues on a structural template with known solvent exposure propensities. The goal is to compute a single \"negative threading score\" for each test case such that hydrophilic residues placed on surface-exposed positions yield a more favorable (more negative) contribution, while hydrophilic residues placed in buried positions yield a penalty (positive contribution). Hydrophobic residues produce the opposite pattern. The resulting score is a sum over positions, without any gaps or insertions.\n\nDefinitions and setup:\n- Let the sequence length be $n \\in \\mathbb{N}$, indexed by positions $i \\in \\{1,\\dots,n\\}$.\n- The structural template provides a solvent exposure value $e_i \\in [0,1]$ for each position $i$, where $e_i = 1$ denotes fully surface-exposed and $e_i = 0$ denotes fully buried.\n- Let $\\mathcal{A}$ be the set of the $20$ standard amino acids. Define the hydrophilic subset $\\mathcal{H} = \\{ \\mathrm{D}, \\mathrm{E}, \\mathrm{K}, \\mathrm{R}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{H}, \\mathrm{S}, \\mathrm{T}, \\mathrm{Y} \\}$, and treat all residues in $\\mathcal{A} \\setminus \\mathcal{H}$ as hydrophobic. Any residue not in $\\mathcal{A}$ contributes zero at its position.\n- Define the hydrophilicity indicator $h(a) = 1$ if $a \\in \\mathcal{H}$ and $h(a) = 0$ if $a \\in \\mathcal{A} \\setminus \\mathcal{H}$. For $a \\notin \\mathcal{A}$, set the per-position contribution to zero.\n- Use two positive weights: $\\lambda_{h} = 2$ and $\\lambda_{hp} = 1$.\n- For residue $a_i$ at position $i$ with exposure $e_i$, the per-position score is\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;+\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(2 e_i - 1).\n$$\n- The total negative threading score is\n$$\nS = \\sum_{i=1}^{n} s_i.\n$$\nBy construction, if $h(a_i) = 1$ and $e_i$ is large, then $s_i$ is negative (favorable), while if $h(a_i) = 1$ and $e_i$ is small, then $s_i$ is positive (penalty). Conversely, if $h(a_i) = 0$ (hydrophobic) and $e_i$ is small (buried), then $s_i$ is negative (favorable), whereas if $e_i$ is large (surface), then $s_i$ is positive (penalty).\n\nTask:\nImplement a program that computes $S$ for each of the following test cases. In every case, the sequence length equals the number of exposure values. Exposure values are unitless and belong to $[0,1]$.\n\nTest suite:\n- Case $1$: sequence $=$ \"DEKR\", exposures $= [1.0, 0.8, 0.2, 0.2]$.\n- Case $2$: sequence $=$ \"VVIL\", exposures $= [0.1, 0.3, 0.8, 1.0]$.\n- Case $3$: sequence $=$ \"DKVA\", exposures $= [1.0, 0.2, 0.8, 0.2]$.\n- Case $4$: sequence $=$ \"AXZX\", exposures $= [1.0, 0.0, 1.0, 0.0]$.\n- Case $5$: sequence $=$ \"STYW\", exposures $= [0.5, 0.5, 0.5, 0.5]$.\n\nRequirements:\n- Compute the total score $S$ exactly as defined above for each case. If any residue is not in $\\mathcal{A}$, its contribution is defined to be $0$ at its position regardless of $e_i$.\n- Produce a single line of output containing a list with the $5$ total scores in the order of the cases. Each score must be a decimal (floating-point) value rounded to exactly three digits after the decimal point. The list must be enclosed in square brackets and contain comma-separated values with no spaces. For example, an output with three values must look like $[x_1,x_2,x_3]$, where each $x_j$ has exactly three digits after the decimal point.", "solution": "The problem statement has been rigorously validated and is found to be scientifically grounded, well-posed, and objective. It presents a simplified but coherent model for protein fold recognition, a valid topic in computational biology. All parameters, functions, and test cases are explicitly and consistently defined, permitting a unique and verifiable solution. We may therefore proceed with the derivation.\n\nThe objective is to compute the total negative threading score, $S$, for five given test cases. The score evaluates the fitness of a protein sequence $a_1 a_2 \\dots a_n$ for a structural template defined by a series of solvent exposure values $e_1, e_2, \\dots, e_n$.\n\nThe score is defined as the sum of per-position scores, $S = \\sum_{i=1}^{n} s_i$. The per-position score $s_i$ for a residue $a_i$ at position $i$ with exposure $e_i$ is given by:\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;+\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(2 e_i - 1)\n$$\nwhere $h(a_i)$ is the hydrophilicity indicator, $h(a_i) = 1$ if $a_i$ is hydrophilic and $h(a_i) = 0$ if $a_i$ is hydrophobic. The weights are given as $\\lambda_h = 2$ and $\\lambda_{hp} = 1$. For any residue $a_i$ not among the $20$ standard amino acids ($\\mathcal{A}$), its contribution $s_i$ is stipulated to be $0$.\n\nWe can simplify the expression for $s_i$ by noting that $(2e_i - 1) = -(1 - 2e_i)$. Substituting this into the formula gives:\n$$\ns_i = \\lambda_h \\, h(a_i)\\,(1 - 2 e_i) \\;-\\; \\lambda_{hp} \\, \\bigl(1 - h(a_i)\\bigr)\\,(1 - 2 e_i)\n$$\nFactoring out the term $(1 - 2e_i)$:\n$$\ns_i = (1 - 2e_i) \\left[ \\lambda_h h(a_i) - \\lambda_{hp}(1 - h(a_i)) \\right]\n$$\nThis expression can be evaluated for the two cases of residue type for $a_i \\in \\mathcal{A}$:\n1.  If the residue $a_i$ is hydrophilic ($a_i \\in \\mathcal{H}$), then $h(a_i) = 1$. The term in the brackets becomes $\\lambda_h \\cdot 1 - \\lambda_{hp}(1-1) = \\lambda_h$. The score is $s_i = \\lambda_h (1 - 2e_i) = 2(1 - 2e_i)$.\n2.  If the residue $a_i$ is hydrophobic ($a_i \\in \\mathcal{A} \\setminus \\mathcal{H}$), then $h(a_i) = 0$. The term in the brackets becomes $\\lambda_h \\cdot 0 - \\lambda_{hp}(1-0) = -\\lambda_{hp}$. The score is $s_i = -\\lambda_{hp}(1 - 2e_i) = \\lambda_{hp}(2e_i - 1) = 1(2e_i - 1)$.\n\nWe will now apply these simplified formulae to calculate the total score $S$ for each test case. The hydrophilic set is $\\mathcal{H} = \\{ \\mathrm{D}, \\mathrm{E}, \\mathrm{K}, \\mathrm{R}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{H}, \\mathrm{S}, \\mathrm{T}, \\mathrm{Y} \\}$.\n\n**Case 1:** sequence = \"DEKR\", exposures = $[1.0, 0.8, 0.2, 0.2]$\nAll residues are hydrophilic.\n$s_1(\\mathrm{D}, e_1=1.0) = 2(1 - 2 \\cdot 1.0) = 2(-1) = -2.0$\n$s_2(\\mathrm{E}, e_2=0.8) = 2(1 - 2 \\cdot 0.8) = 2(-0.6) = -1.2$\n$s_3(\\mathrm{K}, e_3=0.2) = 2(1 - 2 \\cdot 0.2) = 2(0.6) = 1.2$\n$s_4(\\mathrm{R}, e_4=0.2) = 2(1 - 2 \\cdot 0.2) = 2(0.6) = 1.2$\nTotal score $S_1 = -2.0 - 1.2 + 1.2 + 1.2 = -0.8$.\n\n**Case 2:** sequence = \"VVIL\", exposures = $[0.1, 0.3, 0.8, 1.0]$\nAll residues are hydrophobic.\n$s_1(\\mathrm{V}, e_1=0.1) = (2 \\cdot 0.1 - 1) = -0.8$\n$s_2(\\mathrm{V}, e_2=0.3) = (2 \\cdot 0.3 - 1) = -0.4$\n$s_3(\\mathrm{I}, e_3=0.8) = (2 \\cdot 0.8 - 1) = 0.6$\n$s_4(\\mathrm{L}, e_4=1.0) = (2 \\cdot 1.0 - 1) = 1.0$\nTotal score $S_2 = -0.8 - 0.4 + 0.6 + 1.0 = 0.4$.\n\n**Case 3:** sequence = \"DKVA\", exposures = $[1.0, 0.2, 0.8, 0.2]$\nResidues D, K are hydrophilic; V, A are hydrophobic.\n$s_1(\\mathrm{D}, e_1=1.0) = 2(1 - 2 \\cdot 1.0) = -2.0$\n$s_2(\\mathrm{K}, e_2=0.2) = 2(1 - 2 \\cdot 0.2) = 1.2$\n$s_3(\\mathrm{V}, e_3=0.8) = (2 \\cdot 0.8 - 1) = 0.6$\n$s_4(\\mathrm{A}, e_4=0.2) = (2 \\cdot 0.2 - 1) = -0.6$\nTotal score $S_3 = -2.0 + 1.2 + 0.6 - 0.6 = -0.8$.\n\n**Case 4:** sequence = \"AXZX\", exposures = $[1.0, 0.0, 1.0, 0.0]$\nResidue A is hydrophobic. Residues X and Z are not in the standard set $\\mathcal{A}$.\n$s_1(\\mathrm{A}, e_1=1.0) = (2 \\cdot 1.0 - 1) = 1.0$\n$s_2(\\mathrm{X}, e_2=0.0) = 0$ (non-standard)\n$s_3(\\mathrm{Z}, e_3=1.0) = 0$ (non-standard)\n$s_4(\\mathrm{X}, e_4=0.0) = 0$ (non-standard)\nTotal score $S_4 = 1.0 + 0 + 0 + 0 = 1.0$.\n\n**Case 5:** sequence = \"STYW\", exposures = $[0.5, 0.5, 0.5, 0.5]$\nResidues S, T, Y are hydrophilic; W is hydrophobic. The exposure for all positions is $e_i=0.5$.\n$s_1(\\mathrm{S}, e_1=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_2(\\mathrm{T}, e_2=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_3(\\mathrm{Y}, e_3=0.5) = 2(1 - 2 \\cdot 0.5) = 2(0) = 0$\n$s_4(\\mathrm{W}, e_4=0.5) = (2 \\cdot 0.5 - 1) = 0$\nTotal score $S_5 = 0 + 0 + 0 + 0 = 0.0$. This is expected, as an exposure of $e_i=0.5$ represents a neutral environment, yielding no energetic preference for either residue type.\n\nSummary of results:\n$S_1 = -0.8$\n$S_2 = 0.4$\n$S_3 = -0.8$\n$S_4 = 1.0$\n$S_5 = 0.0$\n\nThese results will be formatted to three decimal places for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the negative threading score for a set of protein sequences\n    based on a simplified solvent exposure model.\n    \"\"\"\n\n    # Define problem parameters as per the statement.\n    lambda_h = 2.0\n    lambda_hp = 1.0\n    hydrophilic_residues = {'D', 'E', 'K', 'R', 'N', 'Q', 'H', 'S', 'T', 'Y'}\n    standard_amino_acids = {\n        'A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L',\n        'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y'\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"DEKR\", [1.0, 0.8, 0.2, 0.2]),\n        (\"VVIL\", [0.1, 0.3, 0.8, 1.0]),\n        (\"DKVA\", [1.0, 0.2, 0.8, 0.2]),\n        (\"AXZX\", [1.0, 0.0, 1.0, 0.0]),\n        (\"STYW\", [0.5, 0.5, 0.5, 0.5])\n    ]\n\n    results = []\n    # Iterate through each test case to calculate its total score.\n    for sequence, exposures in test_cases:\n        total_score = 0.0\n        # Iterate through each position in the sequence.\n        for i, residue in enumerate(sequence):\n            # The contribution is zero for non-standard amino acids.\n            if residue not in standard_amino_acids:\n                s_i = 0.0\n            else:\n                e_i = exposures[i]\n                is_hydrophilic = residue in hydrophilic_residues\n                \n                # Apply the appropriate scoring formula based on hydrophilicity.\n                if is_hydrophilic:\n                    # s_i = lambda_h * (1 - 2*e_i) for hydrophilic residues.\n                    s_i = lambda_h * (1.0 - 2.0 * e_i)\n                else:  # The residue is hydrophobic.\n                    # s_i = lambda_hp * (2*e_i - 1) for hydrophobic residues.\n                    s_i = lambda_hp * (2.0 * e_i - 1.0)\n            \n            total_score += s_i\n            \n        results.append(total_score)\n\n    # Format the results to exactly three decimal places as required.\n    formatted_results = [f\"{score:.3f}\" for score in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2391514"}, {"introduction": "Beyond general principles like hydrophobicity, robust fold recognition methods incorporate specific knowledge about amino acid behaviors. Proline, with its unique cyclic side chain, is a classic example; it acts as a 'helix breaker' because its rigid structure is incompatible with the backbone geometry of an $\\alpha$-helix interior. In this exercise, you will move from a general scoring scheme to a rule-based one by implementing a penalty function that specifically targets the unfavorable placement of proline within a helical segment, a key technique in refining threading potentials [@problem_id:2391554].", "problem": "You are given a simplified threading scenario where a query amino acid sequence is aligned without gaps onto a fixed protein template annotated by predicted secondary structure states. The template is a string over the alphabet {\"H\",\"E\",\"C\"}, where \"H\" denotes an $\\alpha$-helix position, \"E\" denotes a $\\beta$-strand position, and \"C\" denotes a coil position. The query sequence is a string over the standard $20$ amino acid one-letter codes. Threading is specified by an integer offset $k$, meaning that the first residue of the query sequence is aligned to the template position with index $k$, and in general the query residue at index $j$ aligns to the template position with index $k+j$. All indices are $0$-based. You must define a scoring function that penalizes instances where a proline residue (\"P\") in the query sequence is threaded into the interior of an $\\alpha$-helix segment in the template.\n\nDefinitions:\n- A helix segment is a maximal contiguous run of \"H\" characters in the template. If such a segment spans template indices from $a$ to $b$ inclusive, its length is $L=b-a+1$.\n- Within a helix segment, define the local helix index of a template position $i$ as $j=i-a+1$ using $1$-based indexing local to the segment. A template position is called interior to the helix if it satisfies $1<j<L$.\n- Let $\\lambda>0$ be a given scalar penalty weight. The total score $S$ for a given query sequence, template, offset, and $\\lambda$ is defined as\n$$\nS \\;=\\; \\lambda \\cdot \\left|\\left\\{\\, j \\;\\middle|\\; \\text{the query residue at index } j \\text{ is \"P\", the aligned template position } k+j \\text{ is \"H\", and that \"H\" position is interior in its helix segment} \\,\\right\\}\\right|.\n$$\nThat is, the score equals $\\lambda$ multiplied by the count of aligned positions where a proline is placed into the interior of a helix segment as defined above. No other placements contribute to the score.\n\nTask:\n- Write a program that, for each of the provided test cases, computes the score $S$ exactly as defined.\n\nTest suite:\nProvide results for the following $6$ test cases. Each test case is a tuple consisting of (query sequence string, template string, offset $k$, penalty $\\lambda$):\n\n- Test case $1$:\n  - Query: \"AAPPA\"\n  - Template: \"CCCHHHHHHCCC\"\n  - $k=3$\n  - $\\lambda=5$\n- Test case $2$:\n  - Query: \"PAAAA\"\n  - Template: \"CCCHHHHHHCCC\"\n  - $k=3$\n  - $\\lambda=7$\n- Test case $3$:\n  - Query: \"PP\"\n  - Template: \"CECECECECE\"\n  - $k=2$\n  - $\\lambda=11$\n- Test case $4$:\n  - Query: \"PPP\"\n  - Template: \"HHCHHHCHHH\"\n  - $k=3$\n  - $\\lambda=9$\n- Test case $5$:\n  - Query: \"P\"\n  - Template: \"HHCCCC\"\n  - $k=0$\n  - $\\lambda=4$\n- Test case $6$:\n  - Query: \"APAPAP\"\n  - Template: \"CCCHHHHCCCC\"\n  - $k=2$\n  - $\\lambda=4$\n\nFinal output format:\nYour program should produce a single line of output containing the results for the $6$ test cases as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"). Each result must be an integer equal to the score $S$ for the corresponding test case, in the same order as listed above.", "solution": "The problem as stated is valid. It is scientifically grounded in the principles of protein stereochemistry, is mathematically well-posed, and is presented in an objective, unambiguous manner. It is a simplified but correct formulation of a component of a fold recognition (or threading) energy function. We shall proceed with a formal solution.\n\nThe problem asks for the computation of a penalty score, $S$, for a given alignment of a query amino acid sequence onto a protein template structure. The fundamental principle being modeled is the structural incompatibility of the proline residue with the interior of an $\\alpha$-helix. Proline's unique cyclic side chain, where the R-group is bonded back to the polypeptide backbone nitrogen, imposes severe conformational constraints. These constraints prevent it from satisfying the ideal backbone dihedral angles ($\\phi \\approx -57^\\circ$, $\\psi \\approx -47^\\circ$) required to maintain the hydrogen bonding pattern of a stable $\\alpha$-helix. Consequently, proline residues act as \"helix breakers\" and are preferentially located at the termini of helices, not within their stable core.\n\nThe scoring function $S$ is defined as:\n$$\nS \\;=\\; \\lambda \\cdot \\left|\\left\\{\\, j \\;\\middle|\\; \\text{the query residue at index } j \\text{ is \"P\", the aligned template position } k+j \\text{ is \"H\", and that \"H\" position is interior in its helix segment} \\,\\right\\}\\right|\n$$\nwhere $j$ is the $0$-based index in the query sequence, $k$ is the alignment offset, and $\\lambda$ is a positive penalty weight.\n\nThe solution requires a two-step algorithmic approach:\n\n1.  **Preprocessing the Template to Identify Interior Helix Positions**:\n    First, we must identify all positions in the template that qualify as being \"interior\" to an $\\alpha$-helix segment. An $\\alpha$-helix segment is a maximal contiguous run of \"H\" characters. A position $i$ within such a segment is interior if it is not at either end of the segment. This can be expressed by a simple local condition: a template position $i$ is an interior helix position if and only if the template characters at indices $i-1$, $i$, and $i+1$ are all 'H'. This condition naturally fails for any helix of length $L \\le 2$ and for the two terminal positions of any helix of length $L \\ge 3$. We can pre-compute a boolean array, let us call it $I_{interior}$, of the same length as the template string $T$. For each position $i$ in the template ($0 \\le i < |T|$), we set $I_{interior}[i]$ to true if $1 \\le i < |T|-1$ and $T[i-1] = \\text{'H'}$, $T[i] = \\text{'H'}$, and $T[i+1] = \\text{'H'}$; otherwise, $I_{interior}[i]$ is false. This preprocessing requires a single pass over the template string.\n\n2.  **Evaluating the Alignment Score**:\n    After preprocessing the template, we calculate the score for a given query sequence $Q$, offset $k$, and penalty $\\lambda$. We iterate through the query sequence, with index $j$ from $0$ to $|Q|-1$. For each residue $Q[j]$:\n    a. We check if the residue is a proline, i.e., $Q[j] = \\text{'P'}$.\n    b. If it is proline, we determine the index of the aligned position in the template, which is $t_{idx} = k + j$.\n    c. We must ensure this index is valid, i.e., $0 \\le t_{idx} < |T|$.\n    d. We then check if this aligned position corresponds to an interior helix position by consulting our pre-computed array: $I_{interior}[t_{idx}]$.\n    e. If all conditions are met, we increment a counter, $N_p$.\n\n    After iterating through the entire query sequence, the final score $S$ is the product of the accumulated count $N_p$ and the penalty weight $\\lambda$: $S = \\lambda \\cdot N_p$.\n\nWe will now apply this algorithm to each test case.\n\n- **Test case 1**: $Q$=`\"AAPPA\"`, $T$=`\"CCCHHHHHHCCC\"`, $k=3$, $\\lambda=5$.\n  - The helix segment (`\"HHHHHH\"`) spans indices $3$ to $8$. Interior positions are $4, 5, 6, 7$.\n  - `j=2`: `Q[2]` is 'P'. Aligns to template index $k+j = 3+2=5$. Position $5$ is an interior helix position. Penalty count becomes $1$.\n  - `j=3`: `Q[3]` is 'P'. Aligns to template index $k+j = 3+3=6$. Position $6$ is an interior helix position. Penalty count becomes $2$.\n  - Total count $N_p=2$. Score $S = 5 \\cdot 2 = 10$.\n\n- **Test case 2**: $Q$=`\"PAAAA\"`, $T$=`\"CCCHHHHHHCCC\"`, $k=3$, $\\lambda=7$.\n  - Interior helix positions are $4, 5, 6, 7$.\n  - `j=0`: `Q[0]` is 'P'. Aligns to template index $k+j = 3+0=3$. Position $3$ is the start of a helix, not interior.\n  - Total count $N_p=0$. Score $S = 7 \\cdot 0 = 0$.\n\n- **Test case 3**: $Q$=`\"PP\"`, $T$=`\"CECECECECE\"`, $k=2$, $\\lambda=11$.\n  - Template has no 'H' characters. No interior helix positions exist.\n  - Total count $N_p=0$. Score $S = 11 \\cdot 0 = 0$.\n\n- **Test case 4**: $Q$=`\"PPP\"`, $T$=`\"HHCHHHCHHH\"`, $k=3$, $\\lambda=9$.\n  - Template has two helix segments of length $3$ (\"HHH\"), starting at indices $3$ and $7$. The interior positions are index $4$ and index $8$.\n  - `j=0`: `Q[0]` is 'P'. Aligns to $k+j=3$. Not interior.\n  - `j=1`: `Q[1]` is 'P'. Aligns to $k+j=4$. Position $4$ is an interior helix position. Penalty count becomes $1$.\n  - `j=2`: `Q[2]` is 'P'. Aligns to $k+j=5$. Not interior.\n  - Total count $N_p=1$. Score $S = 9 \\cdot 1 = 9$.\n\n- **Test case 5**: $Q$=`\"P\"`, $T$=`\"HHCCCC\"`, $k=0$, $\\lambda=4$.\n  - The helix segment (\"HH\") has length $2$. It has no interior positions.\n  - `j=0`: `Q[0]` is 'P'. Aligns to $k+j=0$. Not interior.\n  - Total count $N_p=0$. Score $S = 4 \\cdot 0 = 0$.\n\n- **Test case 6**: $Q$=`\"APAPAP\"`, $T$=`\"CCCHHHHCCCC\"`, $k=2$, $\\lambda=4$.\n  - The helix segment (\"HHHH\") spans indices $3$ to $6$. Interior positions are $4, 5$.\n  - `j=1`: `Q[1]` is 'P'. Aligns to $k+j=2+1=3$. Not interior.\n  - `j=3`: `Q[3]` is 'P'. Aligns to $k+j=2+3=5$. Position $5$ is an interior helix position. Penalty count becomes $1$.\n  - `j=5`: `Q[5]` is 'P'. Aligns to $k+j=2+5=7$. Template position $7$ is 'C', not 'H'.\n  - Total count $N_p=1$. Score $S = 4 \\cdot 1 = 4$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_score(query: str, template: str, k: int, lambda_val: int) -> int:\n    \"\"\"\n    Computes the threading score based on penalties for proline in helix interiors.\n\n    Args:\n        query: The amino acid query sequence.\n        template: The secondary structure template string.\n        k: The alignment offset.\n        lambda_val: The penalty weight.\n\n    Returns:\n        The total score S.\n    \"\"\"\n    len_template = len(template)\n    len_query = len(query)\n\n    # Step 1: Pre-compute the interior helix positions.\n    # A position 'i' is interior to a helix if the template characters at i-1, i, and i+1 are all 'H'.\n    # This implicitly handles helices of length < 3 having no interior.\n    is_interior_helix = [False] * len_template\n    for i in range(1, len_template - 1):\n        if template[i-1] == 'H' and template[i] == 'H' and template[i+1] == 'H':\n            is_interior_helix[i] = True\n\n    # Step 2: Iterate through the alignment and count penalties.\n    penalty_count = 0\n    for j in range(len_query):\n        # The query residue at index j is aligned to the template at k+j.\n        template_idx = k + j\n\n        # We only score positions that are validly aligned within the template.\n        if 0 <= template_idx < len_template:\n            # Condition 1: The query residue is Proline ('P').\n            if query[j] == 'P':\n                # Condition 2: The aligned template position is an interior helix position.\n                if is_interior_helix[template_idx]:\n                    penalty_count += 1\n    \n    # Step 3: Calculate the final score.\n    # The score is the penalty weight multiplied by the count of penalized positions.\n    score = lambda_val * penalty_count\n    return int(score)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the entire test suite and prints the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (query sequence, template string, offset k, penalty lambda)\n        (\"AAPPA\", \"CCCHHHHHHCCC\", 3, 5),\n        (\"PAAAA\", \"CCCHHHHHHCCC\", 3, 7),\n        (\"PP\", \"CECECECECE\", 2, 11),\n        (\"PPP\", \"HHCHHHCHHH\", 3, 9),\n        (\"P\", \"HHCCCC\", 0, 4),\n        (\"APAPAP\", \"CCCHHHHCCCC\", 2, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        query, template, k, lambda_val = case\n        result = calculate_score(query, template, k, lambda_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391554"}, {"introduction": "A complete fold recognition algorithm must do more than just score aligned positions; it must find the optimal alignment between a query sequence and a structural template. This becomes particularly challenging when dealing with real-world data from the Protein Data Bank (PDB), which often contains gaps from missing residues or breaks between protein chains. This final, advanced practice asks you to build a sophisticated global alignment algorithm using dynamic programming, incorporating a custom gap penalty model that intelligently handles these structural discontinuities, bridging the gap between simplified models and the logic used in production-level bioinformatics tools [@problem_id:2391490].", "problem": "Design and implement a program that, given a query amino-acid sequence and a template derived from a Protein Data Bank (PDB) file with possible missing residues and chain breaks, computes the maximum global threading score under a precisely defined scoring model. The program must compute the result for each test case and aggregate them into a single output line as specified below.\n\nFormulation. Let the amino-acid alphabet be a finite set denoted by $\\mathcal{A}$. A query sequence is a finite string $Q = q_1 q_2 \\dots q_n$ with $q_i \\in \\mathcal{A}$. A template is given as an original string $T^{\\mathrm{orig}} = t^{\\mathrm{orig}}_1 t^{\\mathrm{orig}}_2 \\dots t^{\\mathrm{orig}}_m$ with $t^{\\mathrm{orig}}_j \\in \\mathcal{A}$, a presence mask $U = (u_1, u_2, \\dots, u_m)$ with $u_j \\in \\{0,1\\}$ indicating whether the residue at position $j$ is observed in the structure ($u_j = 1$) or missing ($u_j = 0$), and a set of chain breaks $B \\subseteq \\{1,2,\\dots,m-1\\}$, where $j \\in B$ indicates a covalent chain break between positions $j$ and $j+1$ in the original indexing.\n\nDefine the observed index set $J = \\{ j \\in \\{1,2,\\dots,m\\} : u_j = 1 \\}$ with its natural increasing order $j_1 < j_2 < \\dots < j_{m'}$. The effective template sequence to be threaded is $T = t_1 t_2 \\dots t_{m'}$ where $t_\\ell = t^{\\mathrm{orig}}_{j_\\ell}$. Define a break indicator on the effective template as follows: for each $\\ell \\in \\{1,2,\\dots,m'-1\\}$, place a break between $t_\\ell$ and $t_{\\ell+1}$ if and only if $j_{\\ell+1} = j_\\ell + 1$ and $j_\\ell \\in B$. This partitions $T$ into contiguous segments separated by breaks. Let $\\mathrm{segstart}(\\ell)$ be the indicator that position $\\ell$ is the first position of a segment in $T$; by definition, $\\mathrm{segstart}(1) = 1$, and for $\\ell \\ge 2$, $\\mathrm{segstart}(\\ell) = 1$ if there is a break between $t_{\\ell-1}$ and $t_\\ell$, otherwise $\\mathrm{segstart}(\\ell) = 0$.\n\nAn alignment between $Q$ and $T$ is a global alignment that pairs each character of $Q$ and each character of $T$ either with a character in the other string (a match or mismatch) or with a gap, preserving order. The total score of an alignment is defined as the sum of the following components:\n- Substitution score: for each aligned pair $(q_i, t_\\ell)$ add $\\sigma(q_i,t_\\ell)$, where\n  $\n  \\sigma(a,b) =\n  \\begin{cases}\n  +2, & \\text{if } a=b,\\\\\n  -1, & \\text{if } a\\ne b.\n  \\end{cases}\n  $\n- Insertion penalties (gap in the template, that is, unpaired characters in $Q$): for each maximal run of length $L \\ge 1$ of consecutive unpaired characters in $Q$, add the penalty $-(o_I + (L-1)e_I)$ with $o_I = 3$ and $e_I = 1$.\n- Deletion penalties (gap in the sequence, that is, unpaired positions in $T$): consider each maximal run of consecutive unpaired positions in $T$ within a single segment. For a run of length $K \\ge 1$ that begins at template position $\\ell$, add the penalty $-(o_D^{\\mathrm{eff}}(\\ell) + (K-1)e_D)$ with $e_D = 1$ and\n  $\n  o_D^{\\mathrm{eff}}(\\ell) =\n  \\begin{cases}\n  0, & \\text{if } \\mathrm{segstart}(\\ell) = 1,\\\\\n  3, & \\text{if } \\mathrm{segstart}(\\ell) = 0.\n  \\end{cases}\n  $\n  If a deletion spans multiple segments, it is decomposed into separate runs, one within each segment, and the above penalty rule is applied to each run independently. There is no other modification to substitution scores across chain breaks. All missing residues ($u_j = 0$) in the original template are excluded from $T$ and do not contribute to score or penalties.\n\nObjective. For each test case, compute the maximum possible total score over all global alignments between $Q$ and the effective template $T$ subject to the above rules.\n\nTest suite. Use the following six test cases. In each case the alphabet is the uppercase English letters, and the data are:\n- Case $1$: $Q = \\text{\"ACDE\"}$; $T^{\\mathrm{orig}} = \\text{\"ACDE\"}$; $U = [\\,1,1,1,1\\,]$; $B = \\varnothing$.\n- Case $2$: $Q = \\text{\"ADE\"}$; $T^{\\mathrm{orig}} = \\text{\"ACDE\"}$; $U = [\\,1,0,1,1\\,]$; $B = \\varnothing$.\n- Case $3$: $Q = \\text{\"ABD\"}$; $T^{\\mathrm{orig}} = \\text{\"ABCD\"}$; $U = [\\,1,1,1,1\\,]$; $B = \\{\\,2\\,\\}$.\n- Case $4$: $Q = \\text{\"AAA\"}$; $T^{\\mathrm{orig}} = \\text{\"TTTT\"}$; $U = [\\,0,0,0,0\\,]$; $B = \\varnothing$.\n- Case $5$: $Q = \\text{\"AD\"}$; $T^{\\mathrm{orig}} = \\text{\"ABCD\"}$; $U = [\\,1,1,1,1\\,]$; $B = \\varnothing$.\n- Case $6$: $Q = \\text{\"AD\"}$; $T^{\\mathrm{orig}} = \\text{\"ABCD\"}$; $U = [\\,1,1,1,1\\,]$; $B = \\{\\,1\\,\\}$.\n\nAnswer type. For each test case, the answer is a single integer equal to the maximum score.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $6$, with no spaces, for example $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$.", "solution": "The problem requires the computation of a maximal global threading score for a query amino-acid sequence against a structural template. The template may have missing residues and chain breaks. This is a variant of the classic global sequence alignment problem with affine gap penalties, which can be solved efficiently using dynamic programming. The specific scoring model introduces a novel rule for deletion penalties that depends on the template's segmental structure, derived from chain breaks.\n\nThe solution proceeds in two main stages: first, preprocessing the template to derive its effective sequence and segment information; second, applying a custom dynamic programming algorithm to find the optimal alignment score.\n\n**1. Template Preprocessing**\n\nLet the query sequence be $Q$ of length $n$, and the original template sequence be $T^{\\mathrm{orig}}$ of length $m$.\nFirst, we construct the effective template sequence, $T$. This sequence consists only of the residues present in the structure, as indicated by the presence mask $U=(u_1, \\dots, u_m)$.\nThe set of indices of observed residues in the original template is $J = \\{j \\in \\{1,\\dots,m\\} : u_j=1\\}$. Let these indices in increasing order be $j_1 < j_2 < \\dots < j_{m'}$.\nThe effective template $T$ is then the string $t_1 t_2 \\dots t_{m'}$ of length $m'$, where $t_\\ell = t^{\\mathrm{orig}}_{j_\\ell}$.\n\nNext, we identify segment boundaries within $T$. A chain break is defined to exist between effective template positions $t_\\ell$ and $t_{\\ell+1}$ if their corresponding original indices are adjacent ($j_{\\ell+1} = j_\\ell + 1$) and a break is specified at that original position ($j_\\ell \\in B$).\nWe define an indicator array, $\\mathrm{segstart}$, of length $m'$. For each position $\\ell \\in \\{1, \\dots, m'\\}$, $\\mathrm{segstart}(\\ell) = 1$ if $t_\\ell$ is the first residue of a segment, and $0$ otherwise. By definition, $\\mathrm{segstart}(1)=1$. For $\\ell > 1$, $\\mathrm{segstart}(\\ell)=1$ if there is a break between $t_{\\ell-1}$ and $t_\\ell$.\n\nThis segment information is critical for calculating deletion penalties. The opening penalty for a deletion starting at position $\\ell$ in $T$, denoted $o_D^{\\mathrm{eff}}(\\ell)$, is defined as:\n$$\no_D^{\\mathrm{eff}}(\\ell) =\n\\begin{cases}\n0, & \\text{if } \\mathrm{segstart}(\\ell) = 1, \\\\\n3, & \\text{if } \\mathrm{segstart}(\\ell) = 0.\n\\end{cases}\n$$\nThe extension penalty for deletions, $e_D$, is constant at $1$.\n\n**2. Dynamic Programming Formulation**\n\nThe problem can be solved using a dynamic programming approach similar to the Gotoh algorithm for affine gap penalties. We use three matrices (or tables), $M$, $I$, and $D$, of size $(n+1) \\times (m'+1)$. Each entry $(i, j)$ in these tables stores the optimal score for an alignment of the prefixes $Q[1..i]$ and $T[1..j]$ under different ending conditions:\n- $M(i,j)$: The score of an alignment where $q_i$ is aligned with $t_j$ (a match or mismatch).\n- $I(i,j)$: The score of an alignment where $q_i$ is aligned with a gap (an insertion into $T$).\n- $D(i,j)$: The score of an alignment where $t_j$ is aligned with a gap (a deletion from $T$).\n\nThe scoring constants are: substitution score $\\sigma(a,b)$ is $+2$ for a match and $-1$ for a mismatch; insertion penalties $o_I=3, e_I=1$; and deletion penalties $e_D=1$ with the position-dependent $o_D^{\\mathrm{eff}}(\\ell)$.\n\n**Initialization:**\nThe tables are initialized assuming a global alignment starting from empty prefixes.\n- $M(0,0) = 0$. All other entries in all tables are initialized to $-\\infty$.\n- The first column ($j=0$): This corresponds to aligning the prefix $Q[1..i]$ with an empty template, which is a run of $i$ insertions.\n  $$ I(i,0) = -(o_I + (i-1)e_I) \\quad \\text{for } i \\ge 1. $$\n- The first row ($i=0$): This corresponds to aligning the prefix $T[1..j]$ with an empty query, which is a sequence of deletions. The score is accumulated based on segment structure.\n  $$ D(0,j) = D(0,j-1) - \\begin{cases} o_D^{\\mathrm{eff}}(j) & \\text{if } \\mathrm{segstart}(j)=1 \\\\ e_D & \\text{if } \\mathrm{segstart}(j)=0 \\end{cases} \\quad \\text{for } j \\ge 1, $$\n  with $D(0,0)=0$ as the base.\n\n**Recurrence Relations:**\nFor $i$ from $1$ to $n$ and $j$ from $1$ to $m'$, we fill the tables:\n- **Match/Mismatch Matrix $M$**: An alignment ending with $(q_i, t_j)$ must follow an alignment of prefixes $Q[1..i-1]$ and $T[1..j-1]$.\n  $$ M(i,j) = \\sigma(q_i, t_j) + \\max\\{M(i-1,j-1), I(i-1,j-1), D(i-1,j-1)\\} $$\n- **Insertion Matrix $I$**: An alignment ending with an insertion at $q_i$ can either start a new run of insertions or extend an existing one.\n  $$ I(i,j) = \\max \\begin{cases} M(i-1,j) - o_I, \\\\ D(i-1,j) - o_I, \\\\ I(i-1,j) - e_I \\end{cases} $$\n- **Deletion Matrix $D$**: This is the custom part. A deletion of $t_j$ can start a new run or extend one, but an extension $D(i,j-1) \\to D(i,j)$ is only permitted if $t_j$ is not at the start of a segment.\n  - If $\\mathrm{segstart}(j)=1$:\n    $$ D(i,j) = \\max\\{M(i,j-1), I(i,j-1)\\} - o_D^{\\mathrm{eff}}(j) $$\n  - If $\\mathrm{segstart}(j)=0$:\n    $$ D(i,j) = \\max \\begin{cases} \\max\\{M(i,j-1), I(i,j-1)\\} - o_D^{\\mathrm{eff}}(j), \\\\ D(i,j-1) - e_D \\end{cases} $$\n\n**Final Score:**\nAfter filling all tables, the maximum global alignment score for the full sequences $Q$ and $T$ is the maximum value in the final cell $(n, m')$.\n$$ \\text{Score} = \\max\\{M(n,m'), I(n,m'), D(n,m')\\} $$\nThis systematic computation ensures that we find the maximum score over all possible global alignments according to the specified rules.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the protein threading problem for all test cases.\n    \"\"\"\n    \n    # Define constants from the problem statement.\n    SIGMA_MATCH = 2\n    SIGMA_MISMATCH = -1\n    O_I = 3\n    E_I = 1\n    O_D = 3\n    E_D = 1\n    \n    def _solve_case(Q, T_orig, U, B):\n        \"\"\"\n        Computes the maximum global threading score for a single test case.\n        \"\"\"\n        n = len(Q)\n\n        # Step 1: Construct the effective template T and associated data.\n        T_list = []\n        orig_indices = []\n        for j, char in enumerate(T_orig):\n            if U[j] == 1:\n                T_list.append(char)\n                # Store original indices (1-based) for break checking.\n                orig_indices.append(j + 1)\n        \n        T = \"\".join(T_list)\n        m_prime = len(T)\n\n        # Handle edge case of an empty effective template.\n        if m_prime == 0:\n            if n == 0:\n                return 0\n            # If the template is empty, the score is the penalty for inserting the entire query.\n            return -(O_I + (n - 1) * E_I)\n\n        # Step 2: Compute segstart and o_D_eff arrays for the effective template.\n        segstart = np.zeros(m_prime, dtype=int)\n        if m_prime > 0:\n            segstart[0] = 1\n        \n        # Convert B to a set for efficient lookup.\n        B_set = set(B)\n        for l in range(m_prime - 1):\n            j_l = orig_indices[l]\n            j_l_plus_1 = orig_indices[l+1]\n            if j_l_plus_1 == j_l + 1 and j_l in B_set:\n                segstart[l + 1] = 1\n                \n        o_D_eff = np.full(m_prime, O_D)\n        for l in range(m_prime):\n            if segstart[l] == 1:\n                o_D_eff[l] = 0\n\n        # Step 3: Initialize DP tables M, I, D.\n        M = np.full((n + 1, m_prime + 1), -np.inf)\n        I = np.full((n + 1, m_prime + 1), -np.inf)\n        D = np.full((n + 1, m_prime + 1), -np.inf)\n\n        M[0, 0] = 0\n\n        # Step 4: Initialize the first row and column of the tables.\n        \n        # First column (aligning Q prefix to gaps).\n        if n > 0:\n          I[1, 0] = -O_I\n          for i in range(2, n + 1):\n              I[i, 0] = I[i - 1, 0] - E_I\n\n        # First row (aligning T prefix to gaps).\n        if m_prime > 0:\n            D[0, 1] = -o_D_eff[0]\n            for j in range(2, m_prime + 1):\n                if segstart[j - 1] == 1: # New segment, new deletion run.\n                    D[0, j] = D[0, j - 1] - o_D_eff[j - 1]\n                else: # Extend deletion run within the same segment.\n                    D[0, j] = D[0, j - 1] - E_D\n\n        # Step 5: Fill DP tables using recurrences.\n        for i in range(1, n + 1):\n            for j in range(1, m_prime + 1):\n                # i,j in DP table correspond to Q[i-1], T[j-1].\n                \n                # M(i,j): Match/Mismatch state\n                subst_score = SIGMA_MATCH if Q[i - 1] == T[j - 1] else SIGMA_MISMATCH\n                prev_score = max(M[i - 1, j - 1], I[i - 1, j - 1], D[i - 1, j - 1])\n                if prev_score > -np.inf:\n                    M[i, j] = subst_score + prev_score\n\n                # I(i,j): Insertion state (gap in T)\n                open_ins_score = max(M[i - 1, j], D[i - 1, j]) - O_I\n                extend_ins_score = I[i - 1, j] - E_I\n                I[i, j] = max(open_ins_score, extend_ins_score)\n\n                # D(i,j): Deletion state (gap in Q)\n                open_del_penalty = o_D_eff[j-1]\n                open_del_score = max(M[i, j-1], I[i, j-1]) - open_del_penalty\n\n                if segstart[j-1] == 1: # Cannot extend deletion across a segment break.\n                    D[i,j] = open_del_score\n                else:\n                    extend_del_score = D[i, j-1] - E_D\n                    D[i,j] = max(open_del_score, extend_del_score)\n\n        # Step 6: The final score is the max of the three states at the bottom-right corner.\n        final_score = max(M[n, m_prime], I[n, m_prime], D[n, m_prime])\n        \n        return int(round(final_score))\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"Q\": \"ACDE\", \"T_orig\": \"ACDE\", \"U\": [1, 1, 1, 1], \"B\": []},\n        {\"Q\": \"ADE\", \"T_orig\": \"ACDE\", \"U\": [1, 0, 1, 1], \"B\": []},\n        {\"Q\": \"ABD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": [2]},\n        {\"Q\": \"AAA\", \"T_orig\": \"TTTT\", \"U\": [0, 0, 0, 0], \"B\": []},\n        {\"Q\": \"AD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": []},\n        {\"Q\": \"AD\", \"T_orig\": \"ABCD\", \"U\": [1, 1, 1, 1], \"B\": [1]},\n    ]\n    \n    results = []\n    for case in test_cases:\n        score = _solve_case(**case)\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391490"}]}