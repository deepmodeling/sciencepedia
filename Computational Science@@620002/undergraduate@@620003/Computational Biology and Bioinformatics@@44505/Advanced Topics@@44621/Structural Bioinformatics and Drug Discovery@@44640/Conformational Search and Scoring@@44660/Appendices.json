{"hands_on_practices": [{"introduction": "Effective scoring functions must accurately represent the covalent geometry of all amino acids, and this is especially true for proline, whose unique ring structure imposes strong constraints on the protein backbone. This practice problem focuses on this very challenge in the context of protein loop modeling. By analyzing the consequences of removing a specialized energy term that enforces proline's geometry, you will gain a quantitative understanding of how such constraints guide a Monte Carlo search and prevent the exploration of physically unrealistic conformations [@problem_id:2381419].", "problem": "In the Rosetta conformational search framework for protein loop modeling, the total energy is modeled as a weighted sum of physically motivated terms, $$E_{\\mathrm{total}} = \\sum_{i} w_i E_i,$$ and used in a Metropolis Monte Carlo (MC) scheme, where the probability of accepting a proposed move with energy change $$\\Delta E$$ at inverse thermal energy $$\\beta = 1/(k_{\\mathrm{B}} T)$$ is $$p_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right).$$ Proline has a unique five-membered ring that constrains its backbone dihedral angle $$\\phi$$ and the geometry around the backbone nitrogen. In Rosetta, the score term often referred to as the proline ring-closure term (“pro_close”) contributes an energetic penalty when the proline ring geometry deviates from ideal closure. Consider loop modeling on a benchmark set of proline-rich loops of length $$L = 12$$ residues with $$P = 5$$ prolines, using fragment insertion and Kinematic Closure (KIC) moves. All score weights are fixed to a standard all-atom set, except that you either retain the proline ring-closure term at weight $$w_{\\mathrm{pc}} = 1.25$$ or remove it by setting its weight to $$0$$. Assume a representative temperature such that $$k_{\\mathrm{B}} T = 1.0$$ Rosetta Energy Units (REU). For moves that primarily distort proline ring geometry, the typical incremental contribution of the proline ring-closure term is about $$\\Delta E_{\\mathrm{pc}} \\approx 2.0$$ REU when geometry deviates from ideal, while near-native geometries contribute $$\\approx 0.2$$ REU. All other terms remain unchanged between the two conditions.\n\nWhich of the following outcomes is most consistent with first principles for the condition where the proline ring-closure term is removed?\n\nA. The acceptance of moves that distort proline ring geometry increases by an exponential Boltzmann factor on the order of $$\\exp\\!\\left(\\beta w_{\\mathrm{pc}} \\langle \\Delta E_{\\mathrm{pc}} \\rangle\\right)$$ (e.g., roughly $$\\exp(2.5)$$), broadening the sampled proline $$\\phi$$ distributions. This increases the frequency of non-native, low-scoring false minima, degrades the correlation between energy and Root-Mean-Square Deviation (RMSD), and raises the median loop RMSD across the benchmark.\n\nB. Loop quality and ranking are largely unchanged because backbone torsion statistics and sidechain rotamer terms redundantly capture proline geometry; removing the proline ring-closure term neither alters the energy–RMSD correlation nor the median RMSD.\n\nC. Removing the proline ring-closure term improves loop accuracy by relaxing constraints, thereby making it easier to discover the native state; the median RMSD decreases even though the sampling of distorted prolines increases.\n\nD. Removing the proline ring-closure term primarily reduces steric clashes (lowering the repulsive van der Waals term) and improves energies, while leaving the RMSD distribution effectively unchanged because loop geometry is governed by global packing rather than local proline constraints.", "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n- The total energy of a protein conformation is given by the model: $E_{\\mathrm{total}} = \\sum_{i} w_i E_i$.\n- The sampling algorithm is a Metropolis Monte Carlo (MC) scheme.\n- The probability of accepting a proposed move with an energy change of $\\Delta E$ is $p_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right)$.\n- The inverse thermal energy is $\\beta = 1/(k_{\\mathrm{B}} T)$.\n- The simulation temperature is set such that $k_{\\mathrm{B}} T = 1.0$ Rosetta Energy Units (REU), which implies $\\beta = 1.0$ REU$^{-1}$.\n- The system under consideration is a benchmark set of protein loops of length $L = 12$ residues containing $P = 5$ prolines.\n- The conformational search moves include fragment insertion and Kinematic Closure (KIC).\n- A specific score term, the proline ring-closure term (\"pro_close\"), is being studied.\n- Two conditions are compared:\n    1.  Control: The weight of the proline ring-closure term is $w_{\\mathrm{pc}} = 1.25$.\n    2.  Test: The weight of the proline ring-closure term is $w_{\\mathrm{pc}} = 0$.\n- All other score term weights $w_i$ are held constant.\n- The incremental contribution of the energy term for proline closure, $E_{\\mathrm{pc}}$, is given:\n    - For geometries deviating from ideal, $\\Delta E_{\\mathrm{pc}} \\approx 2.0$ REU.\n    - For near-native geometries, the contribution is $\\approx 0.2$ REU.\n- It is assumed that \"All other terms remain unchanged between the two conditions\" for a move that primarily distorts proline ring geometry.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem statement is scientifically sound and well-posed.\n- **Scientific Grounding**: The problem accurately describes fundamental components of the Rosetta molecular modeling suite, including its energy function, the Metropolis criterion for Monte Carlo simulation, and the purpose of specific energy terms like `pro_close`. These are standard concepts and practices in computational structural biology.\n- **Well-Posedness**: The problem defines a clear, self-contained thought experiment by comparing two distinct, well-defined conditions ($w_{\\mathrm{pc}} = 1.25$ versus $w_{\\mathrm{pc}} = 0$). The provided data are sufficient to deduce the consequences based on principles of statistical mechanics.\n- **Objectivity**: The problem is stated in precise, quantitative terms, free of subjective or ambiguous language. Metrics such as RMSD and energy-RMSD correlation are standard, objective measures in the field.\n- **Conclusion of Validation**: The problem is valid as it does not violate any of the specified criteria for invalidity. It is a realistic and formalizable problem in computational biology.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived.\n\n**Derivation of Solution**\n\nThe core of the problem lies in understanding how removing the proline ring-closure penalty affects the sampling process governed by the Metropolis criterion. The total energy change, $\\Delta E_{\\mathrm{total}}$, for a move is the weighted sum of the changes in individual energy terms:\n$$\n\\Delta E_{\\mathrm{total}} = w_{\\mathrm{pc}} \\Delta E_{\\mathrm{pc}} + \\sum_{i \\neq \\mathrm{pc}} w_i \\Delta E_i\n$$\nLet us denote the sum of changes in all other energy terms as $\\Delta E_{\\mathrm{other}} = \\sum_{i \\neq \\mathrm{pc}} w_i \\Delta E_i$.\n\nConsider a Monte Carlo move that distorts a proline ring from a near-native geometry to a non-ideal one.\nThe change in the proline closure energy term itself is $\\Delta E_{\\mathrm{pc}} \\approx 2.0 \\text{ REU} - 0.2 \\text{ REU} = 1.8 \\text{ REU}$.\n\nUnder the control condition ($w_{\\mathrm{pc}} = 1.25$):\nThe change in total energy is:\n$$\n\\Delta E_{\\mathrm{total, control}} = (1.25) \\cdot \\Delta E_{\\mathrm{pc}} + \\Delta E_{\\mathrm{other}} \\approx (1.25)(1.8) + \\Delta E_{\\mathrm{other}} = 2.25 + \\Delta E_{\\mathrm{other}}\n$$\nThis move incurs a significant energetic penalty of $2.25$ REU from the proline closure term alone.\n\nUnder the test condition ($w_{\\mathrm{pc}} = 0$):\nThe change in total energy is:\n$$\n\\Delta E_{\\mathrm{total, test}} = (0) \\cdot \\Delta E_{\\mathrm{pc}} + \\Delta E_{\\mathrm{other}} = \\Delta E_{\\mathrm{other}}\n$$\nIn this case, the specific penalty for distorting the proline ring is completely removed.\n\nThe effect on the acceptance probability, $p_{\\mathrm{acc}} = \\min(1, e^{-\\beta \\Delta E_{\\mathrm{total}}})$, is substantial. Assuming the move is energetically unfavorable (i.e., $\\Delta E_{\\mathrm{total}} > 0$), the ratio of acceptance probabilities between the test and control conditions is:\n$$\n\\frac{p_{\\mathrm{acc, test}}}{p_{\\mathrm{acc, control}}} = \\frac{e^{-\\beta \\Delta E_{\\mathrm{total, test}}}}{e^{-\\beta \\Delta E_{\\mathrm{total, control}}}} = e^{-\\beta (\\Delta E_{\\mathrm{total, test}} - \\Delta E_{\\mathrm{total, control}})} = e^{-\\beta ( -2.25 )} = e^{2.25\\beta}\n$$\nGiven $\\beta = 1.0$ REU$^{-1}$, moves that distort proline rings become $e^{2.25} \\approx 9.5$ times more likely to be accepted. The problem statement in option A uses a rough value of $\\exp(2.5)$, which could arise if one considers the incremental contribution to be a direct penalty of $\\Delta E_{\\mathrm{pc}} = 2.0$ REU, leading to an energy change of $w_{\\mathrm{pc}} \\Delta E_{\\mathrm{pc}} = 1.25 \\times 2.0 = 2.5$ REU. This is a reasonable interpretation and is \"on the order of\" the calculated value.\n\nThis drastic increase in the acceptance of moves leading to chemically invalid geometries has several direct consequences:\n1.  **Broader Sampling of $\\phi$ Angle**: The simulation will explore a much wider range of the proline $\\phi$ dihedral angle, including values that correspond to strained or broken rings. This is what is meant by \"broadening the sampled proline $\\phi$ distributions.\"\n2.  **Population of False Minima**: The `pro_close` term serves to create high energy barriers that prevent the simulation from settling in conformations with incorrect local geometry, even if other energy terms (like hydrogen bonding or van der Waals) are favorable. Removing this term flattens these essential barriers, making it easy for the simulation to become trapped in these low-scoring but structurally incorrect states (\"false minima\").\n3.  **Degradation of Energy-RMSD Correlation**: A useful energy function should guide the search towards the native state, creating an \"energy funnel\" where low energy correlates with low Root-Mean-Square Deviation (RMSD) from the native structure. By allowing low-energy, high-RMSD decoys (the false minima), the correlation between energy and structural accuracy is weakened. The lowest-energy structures found are no longer guaranteed to be the most native-like.\n4.  **Increased Median RMSD**: Because the simulation is more frequently trapped in non-native conformations, the overall quality of the final ensemble of models will decrease. A statistical measure of this degradation is an increase in the median loop RMSD across a benchmark of many loops.\n\n**Option-by-Option Analysis**\n\n**A. The acceptance of moves that distort proline ring geometry increases by an exponential Boltzmann factor on the order of $\\exp\\!\\left(\\beta w_{\\mathrm{pc}} \\langle \\Delta E_{\\mathrm{pc}} \\rangle\\right)$ (e.g., roughly $\\exp(2.5)$), broadening the sampled proline $\\phi$ distributions. This increases the frequency of non-native, low-scoring false minima, degrades the correlation between energy and Root-Mean-Square Deviation (RMSD), and raises the median loop RMSD across the benchmark.**\nThis statement is a complete and accurate summary of the consequences derived from first principles. Each assertion—the increase in acceptance probability, the broadening of the sampled distribution, the trapping in false minima, the degradation of the energy-funnel, and the resulting increase in median RMSD—logically follows from removing a critical physical constraint from the energy function.\n**Verdict: Correct.**\n\n**B. Loop quality and ranking are largely unchanged because backbone torsion statistics and sidechain rotamer terms redundantly capture proline geometry; removing the proline ring-closure term neither alters the energy–RMSD correlation nor the median RMSD.**\nThis option is incorrect. It relies on the false premise of redundancy. General backbone torsion and van der Waals potentials are insufficient to enforce the specific covalent geometry of a cyclic structure like the proline ring. The `pro_close` term is a specialized, non-redundant constraint. Its removal will have a significant, detrimental effect on model quality.\n**Verdict: Incorrect.**\n\n**C. Removing the proline ring-closure term improves loop accuracy by relaxing constraints, thereby making it easier to discover the native state; the median RMSD decreases even though the sampling of distorted prolines increases.**\nThis option contains an internal contradiction. Removing a valid physical constraint does not \"make it easier to discover the native state\"; it expands the search space with a vast majority of non-physical, irrelevant conformations, thereby making the search for the native state much more difficult. Increased sampling of distorted (incorrect) structures will lead to worse, not better, final models, meaning the median RMSD would increase, not decrease.\n**Verdict: Incorrect.**\n\n**D. Removing the proline ring-closure term primarily reduces steric clashes (lowering the repulsive van der Waals term) and improves energies, while leaving the RMSD distribution effectively unchanged because loop geometry is governed by global packing rather than local proline constraints.**\nThis option is incorrect on multiple counts. First, allowing a proline ring to break would likely *increase* steric clashes, not reduce them. Second, an \"improvement\" in energy that comes from ignoring physical reality is artificial and leads to incorrect models. Third, the assertion that local constraints like proline geometry are secondary to global packing is fundamentally wrong, especially for loop modeling, where local geometry is paramount. In a proline-rich loop ($5$ out of $12$ residues), these local constraints are dominant drivers of the overall conformation.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "2381419"}, {"introduction": "Beyond the backbone, correctly arranging protein side chains is a monumental combinatorial challenge, often addressed with dedicated protocols. This exercise explores the practical trade-off between computational cost and accuracy by examining the effect of adding 'extra' rotamers to the conformational search space [@problem_id:2381401]. You will reason about how more finely sampling side-chain dihedral angles, such as $\\chi_1$ and $\\chi_2$, impacts both the runtime of the search and the ability to identify low-energy, native-like interactions in different protein environments.", "problem": "You are using the Rosetta side-chain packing protocol pack_rotamers on a fixed protein backbone to assign side-chain conformations from a discrete rotamer library. The energy function used by the packer can be written as a pairwise-decomposable sum\n$$\nE(\\{r_i\\}) \\;=\\; \\sum_{i} E_i(r_i) \\;+\\; \\sum_{(i,j)} E_{ij}(r_i, r_j),\n$$\nwhere $r_i$ denotes a chosen rotamer at position $i$, $E_i$ are one-body terms, and $E_{ij}$ are two-body interaction terms between neighboring positions. The rotamer library discretizes the side-chain dihedral angles $\\chi_1, \\chi_2, \\ldots$ into a finite set of states per residue. The Rosetta flags --ex1 and --ex2 add extra samples around the canonical rotamers for $\\chi_1$ and $\\chi_2$, respectively, thereby increasing the number of available rotamers per residue. Consider the effect of enabling these flags on both computational speed (wall-clock time) and packing accuracy (for example, recovery of native-like $\\chi_1$ or $\\chi_2$ within a small angular tolerance and the ability to realize favorable interactions) under a fixed-backbone, pairwise energy model as above.\n\nSelect all statements that are most consistent with first-principles reasoning about how enlarging the discrete search space influences runtime and how more finely sampling $\\chi_1$ or $\\chi_2$ impacts the likelihood of identifying low-energy, native-like side-chain arrangements.\n\nA. Enabling --ex1 alone generally increases runtime and tends to improve recovery of native-like $\\chi_1$ at buried sites because it reduces discretization error in the most sterically constrained dihedral; the effect on $\\chi_2$ recovery is typically smaller than the effect on $\\chi_1$.\n\nB. Enabling --ex2 alone will often reduce runtime because adding extra $\\chi_2$ rotamers allows the packer to consider fewer $\\chi_1$ states, thus shrinking the effective search space.\n\nC. Enabling both --ex1 and --ex2 expands the per-residue rotamer set multiplicatively, so the cost to form two-body interaction tables $\\sum_{(i,j)} E_{ij}(r_i, r_j)$ grows approximately with the square of the per-residue multiplication factor, leading to a more-than-linear runtime increase.\n\nD. Adding extra rotamers cannot improve the minimum energy found by the packer on a fixed backbone because the discrete minimum from the base library is already optimal; giving the optimizer more states can only worsen the energy due to overfitting.\n\nE. For surface polar residues with a flexible $\\chi_2$ that directly orients distal polar groups, enabling --ex2 can yield a larger accuracy gain for realizing correct hydrogen-bond geometries than enabling --ex1, because $\\chi_2$ more directly controls those interactions at such sites.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n-   **Protocol**: Rosetta side-chain packing protocol `pack_rotamers`.\n-   **System**: A protein with a fixed backbone.\n-   **Search Space**: A discrete rotamer library, which discretizes side-chain dihedral angles $\\chi_1, \\chi_2, \\ldots$.\n-   **Energy Function**: A pairwise-decomposable sum: $E(\\{r_i\\}) = \\sum_{i} E_i(r_i) + \\sum_{(i,j)} E_{ij}(r_i, r_j)$. Here, $r_i$ is the rotamer at position $i$, $E_i$ are one-body (self-energy) terms, and $E_{ij}$ are two-body (interaction) terms.\n-   **Perturbation**: Rosetta flags `--ex1` and `--ex2` add extra rotamer samples around the canonical values for the $\\chi_1$ and $\\chi_2$ dihedrals, respectively.\n-   **Task**: Evaluate statements about the effect of these flags on computational speed (wall-clock time) and packing accuracy (recovery of native-like conformations and favorable interactions).\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is grounded in the established field of computational protein structure prediction and design. The `pack_rotamers` protocol, the use of a discrete rotamer library, and the pairwise energy function are standard components of the Rosetta framework and similar tools. The concepts of dihedral angles ($\\chi_1, \\chi_2$), steric constraints, and hydrogen bonding energy are fundamental principles in structural biology. The problem is scientifically sound.\n-   **Well-Posedness**: The problem defines a clear computational scenario and asks for a qualitative analysis of the consequences based on established principles of computational complexity and biophysics. The question is structured to assess understanding of the trade-offs between sampling density, computational cost, and accuracy in a combinatorial optimization problem. It is a well-posed conceptual problem.\n-   **Objectivity**: The problem uses precise, technical terminology from computational biology (e.g., `pack_rotamers`, `rotamer library`, `dihedral angles`, `pairwise-decomposable`). It is free of subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem statement is scientifically sound, well-posed, objective, and self-contained. It is valid. The solution will proceed by analyzing each option based on first principles.\n\n**Principle-Based Derivation**\nThe core task of side-chain packing with a pairwise-decomposable energy function on a discrete rotamer set is a combinatorial optimization problem. The goal is to find the combination of rotamers $\\{r_i\\}$ that minimizes the total energy $E$. This problem is in the class of NP-hard problems. The total number of possible conformations is $\\prod_i N_i$, where $N_i$ is the number of discrete rotamers for residue $i$.\n\nThe `--ex1` and `--ex2` flags increase the values of $N_i$ for each residue by adding more sampling points for the $\\chi_1$ and $\\chi_2$ dihedral angles. Let the baseline number of rotamers for a residue be $N_i^{base}$. Adding extra samples increases this to $N_i^{ex} > N_i^{base}$.\n\n1.  **Impact on Computational Speed (Runtime)**: The runtime has two primary components.\n    a.  **Energy Matrix Pre-computation**: The two-body energies $E_{ij}(r_i, r_j)$ must be calculated for all pairs of rotamers for all interacting residue pairs $(i, j)$. The cost for one pair $(i, j)$ is proportional to $N_i \\times N_j$. Increasing the number of rotamers per residue by an average factor of $f$ increases this cost by a factor of approximately $f^2$.\n    b.  **Combinatorial Search**: The algorithm used to find the minimum energy conformation (e.g., simulated annealing, belief propagation) must explore a much larger search space. The complexity of this search grows with the number of rotamers per position.\n    Therefore, enabling `--ex1` or `--ex2` will unambiguously increase the total search space and thus increase the computational time required to find a solution.\n\n2.  **Impact on Accuracy**: A discrete rotamer library is an approximation of the continuous conformational space of a side chain. The true, lowest-energy conformation may not coincide with any of the discrete rotamers in the library. This gives rise to discretization error.\n    a.  **Reducing Discretization Error**: By adding more rotamers (`--ex` flags), the sampling of the conformational space becomes denser. This reduces the average distance between a library rotamer and the true minimum energy conformation. Consequently, the packer has a higher probability of finding a state that is closer in geometry and lower in energy to the true optimum. Thus, increasing sampling density can improve accuracy.\n    b.  **Biophysical Context**: The importance of sampling a particular dihedral angle depends on its environment. In the sterically crowded protein core, small changes in proximal dihedrals like $\\chi_1$ can cause large energy penalties from van der Waals clashes. On the solvent-exposed surface, side chains are more flexible, and distal dihedrals (like $\\chi_2$, $\\chi_3$, etc.) can be critical for positioning functional groups to form specific, long-range interactions like hydrogen bonds.\n\n**Option-by-Option Analysis**\n\n**A. Enabling --ex1 alone generally increases runtime and tends to improve recovery of native-like $\\chi_1$ at buried sites because it reduces discretization error in the most sterically constrained dihedral; the effect on $\\chi_2$ recovery is typically smaller than the effect on $\\chi_1$.**\n-   *Increases runtime*: Correct. As established, increasing the number of rotamers enlarges the search space, increasing computational cost.\n-   *Improves recovery of native-like $\\chi_1$ at buried sites*: Correct. Buried sites are tightly packed, making steric avoidance paramount. The $\\chi_1$ dihedral is closest to the backbone and thus most sterically constrained. Finer sampling of $\\chi_1$ allows for a better fit within the tight confines of the core, reducing discretization error and improving the accuracy of its prediction.\n-   *Effect on $\\chi_2$ recovery is smaller*: Correct. The `--ex1` flag specifically adds samples for $\\chi_1$. While a better $\\chi_1$ choice can facilitate a better choice for $\\chi_2$, the direct improvement is to $\\chi_1$. The primary benefit is realized for the degree of freedom being more finely sampled.\n**Verdict: Correct.**\n\n**B. Enabling --ex2 alone will often reduce runtime because adding extra $\\chi_2$ rotamers allows the packer to consider fewer $\\chi_1$ states, thus shrinking the effective search space.**\n-   *Reduce runtime*: Incorrect. Adding rotamers always increases the search space size ($ \\prod_i N_i $), which necessarily leads to an increase, not a decrease, in runtime.\n-   *Allows the packer to consider fewer $\\chi_1$ states*: Incorrect. This is a nonsensical assertion. The packer algorithm is given a set of rotamers for each position, where each rotamer is a full specification of dihedral angles (e.g., $(\\chi_1, \\chi_2, \\dots)$). Adding rotamers with new $\\chi_2$ values does not eliminate those with old $\\chi_1$ values; it simply expands the total list of options available.\n**Verdict: Incorrect.**\n\n**C. Enabling both --ex1 and --ex2 expands the per-residue rotamer set multiplicatively, so the cost to form two-body interaction tables $\\sum_{(i,j)} E_{ij}(r_i, r_j)$ grows approximately with the square of the per-residue multiplication factor, leading to a more-than-linear runtime increase.**\n-   *Expands the rotamer set multiplicatively*: Correct. Rotamers are combinations of dihedral angle values. If there are $k_1$ samples for $\\chi_1$ and $k_2$ for $\\chi_2$, there are $k_1 \\times k_2$ combined $(\\chi_1, \\chi_2)$ states. If `--ex1` increases $k_1$ by a factor $f_1$ and `--ex2` increases $k_2$ by a factor $f_2$, the total number of rotamers increases by a factor $f_1 f_2$.\n-   *Cost...grows approximately with the square of the...multiplication factor*: Correct. As derived above, the pre-computation of pairwise energies for two residues with $N_i$ and $N_j$ rotamers scales as $O(N_i N_j)$. If both $N_i$ and $N_j$ are increased by a factor $f$, the cost scales by $f^2$. This quadratic growth dominates this phase of the calculation.\n-   *Leading to a more-than-linear runtime increase*: Correct. A quadratic ($f^2$) increase is a type of more-than-linear increase. Since a significant portion of the total runtime is dedicated to this pre-computation, the overall runtime will also increase in a more-than-linear fashion.\n**Verdict: Correct.**\n\n**D. Adding extra rotamers cannot improve the minimum energy found by the packer on a fixed backbone because the discrete minimum from the base library is already optimal; giving the optimizer more states can only worsen the energy due to overfitting.**\n-   *Cannot improve the minimum energy*: Incorrect. The minimum energy that can possibly be found is the minimum over the entire set of provided rotamers. If we denote the base rotamer set as $S_{base}$ and the extra rotamers as $S_{extra}$, then $\\min_{r \\in S_{base} \\cup S_{extra}} E(r) \\le \\min_{r \\in S_{base}} E(r)$. The energy can only improve (decrease) or stay the same. Adding more search points provides the opportunity to find a better (lower energy) minimum.\n-   *Discrete minimum... is already optimal*: Incorrect. It is only optimal *within that discrete set*. It is not the global optimum in the continuous conformational space. The goal of adding rotamers is to find a better approximation to that true global optimum.\n-   *Overfitting*: Incorrect. This term is misused. Overfitting relates to model generalization in machine learning. It has no meaning in the context of finding the minimum of a fixed energy function over a discrete set of points.\n**Verdict: Incorrect.**\n\n**E. For surface polar residues with a flexible $\\chi_2$ that directly orients distal polar groups, enabling --ex2 can yield a larger accuracy gain for realizing correct hydrogen-bond geometries than enabling --ex1, because $\\chi_2$ more directly controls those interactions at such sites.**\n-   *Context*: This concerns polar residues on the protein surface (e.g., Lysine, Arginine, Glutamine). These residues are less constrained by local packing and more driven by specific, directional interactions like hydrogen bonds, often with solvent or other distant polar groups.\n-   *Role of $\\chi_2$*: For many long polar side chains, $\\chi_1$ governs the initial orientation near the C$_\\beta$ carbon, while subsequent dihedrals like $\\chi_2$ have a larger lever-arm effect on the final position of the terminal functional group responsible for hydrogen bonding. For example, in glutamine, the terminal amide group's position is highly sensitive to $\\chi_2$ and $\\chi_3$.\n-   *Conclusion*: It is biophysically plausible and a common observation that for such residues, accurately positioning the terminal polar group for optimal H-bonding is more sensitive to distal dihedrals than the proximal $\\chi_1$. Therefore, increasing sampling for $\\chi_2$ (`--ex2`) can provide a greater benefit for accurately modeling these interactions than increasing sampling for $\\chi_1$ (`--ex1`).\n**Verdict: Correct.**", "answer": "$$\\boxed{ACE}$$", "id": "2381401"}, {"introduction": "This final practice advances from analyzing simulations to building one, providing a true hands-on experience in computational modeling. You will implement a simplified scoring function and a grid search algorithm to predict the structural impact of phosphorylation, a critical post-translational modification [@problem_id:2381408]. By creating a 'Patch' that modifies a base residue's energy parameters, you will directly simulate how a change in chemical identity alters a protein's conformational preference, bridging the gap between theoretical energy functions and tangible biological phenomena.", "problem": "You are asked to formalize a simplified conformational search and scoring problem inspired by the Rosetta modeling framework. Your program must simulate how a residue parameter file and a phosphorylation Patch would alter a residue’s backbone conformational preference and predicted minimum-energy conformation.\n\nScientific foundation. You must start from the principle that, in knowledge-based modeling frameworks such as Rosetta, the predicted conformation is the one that minimizes a total potential energy. Specifically, if $E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$ is a scalar energy over conformation variables $\\boldsymbol{\\theta}$ with parameters $\\boldsymbol{\\lambda}$, then the predicted conformation is any $\\boldsymbol{\\theta}^{\\star}$ minimizing $E$. A change in chemical identity or post-translational state can be represented as a change in $\\boldsymbol{\\lambda}$ via a residue parameter file (the base identity) and a Patch (a modification overlay). Thus, phosphorylation by adding a phosphate group to serine can be modeled as a change in statistical torsion preferences and additional physicochemical terms that reflect steric bulk and electrostatic interactions.\n\nYou will implement a coarse-grained, self-consistent scoring function over the backbone dihedral angles at a single residue, $\\phi$ and $\\psi$, measured in degrees. The total energy is the sum of interpretable components that are abstractions of common Rosetta terms: backbone statistical preferences, steric effects from added bulk, and an environmental directional electrostatic or hydrogen-bond like interaction. Your program must construct a base “Serine params” and a “phospho-Serine Patch” in-code as data structures and apply them to compute energies.\n\nDefinitions to implement:\n- Angles are in degrees. Energies are in kilocalories per mole.\n- The backbone statistical preference is modeled as a mixture of two anisotropic Gaussian wells representing the $\\alpha$-helical and $\\beta$-strand basins. For residue type $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$,\n  $$\n  E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n  \\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right).\n  $$\n  Use centers $\\left(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha}\\right)=(-60,-45)$ and $\\left(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta}\\right)=(-120,130)$ (angles in degrees), and widths $\\sigma_{\\phi}=\\sigma_{\\psi}=25$ (degrees). The base Serine (“params”) well depths are $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ and $d_{\\beta}^{(\\mathrm{Ser})}=2.0$. The phospho-Serine (“Patch”-modified) well depths are $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ and $d_{\\beta}^{(\\mathrm{pSer})}=3.2$.\n- The phosphorylation Patch also adds a steric penalty term that penalizes adopting $\\alpha$-helical $\\phi$ due to phosphate bulk:\n  $$\n  E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right),\n  $$\n  with $\\mu_{\\phi,\\mathrm{steric}}=-60$, $\\sigma_{\\phi,\\mathrm{steric}}=15$, and $s_{0}=0.8$. For unmodified Serine this term is $0$.\n- The environment may provide a favorable directional interaction for the phosphate with a nearby positive charge that is approximately captured by a Gaussian in $\\psi$ around an environment-specified target $\\psi_{0}$:\n  $$\n  E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right),\n  $$\n  with $\\sigma_{\\psi,\\mathrm{el}}=25$. This term models an electrostatic or hydrogen-bond like directional preference in a coarse way. If no nearby positive charge exists, set $k_{\\mathrm{el}}=0$. For unmodified Serine this term is $0$.\n- The total energy is\n  $$\n  E_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right).\n  $$\n  Here $\\mathbb{1}[\\cdot]$ is $1$ if the condition is true and $0$ otherwise.\n\nComputational task:\n- Construct in-code a “params” data structure for Serine holding $d_{\\alpha}^{(\\mathrm{Ser})}$ and $d_{\\beta}^{(\\mathrm{Ser})}$ and the shared Gaussian centers and widths. Construct in-code a phosphorylation “Patch” that, when applied to the Serine params, yields pSer parameters $d_{\\alpha}^{(\\mathrm{pSer})}$ and $d_{\\beta}^{(\\mathrm{pSer})}$ and adds the two terms $E_{\\mathrm{steric}}^{(\\mathrm{pSer})}$ and $E_{\\mathrm{env}}^{(\\mathrm{pSer})}$ with the constants above. Applying the Patch must not change any other aspect of the scoring.\n- Implement a grid search over $\\phi \\in \\{-180,-175,\\ldots,180\\}$ and $\\psi \\in \\{-180,-175,\\ldots,180\\}$, both in degrees, to find the minimum-energy conformation for Ser and for pSer under the same environment parameters.\n- For each test case below, compute:\n  1. The energy-minimizing backbone dihedrals $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ and $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$, in degrees.\n  2. The signed, wrapped angular differences $\\Delta \\phi$ and $\\Delta \\psi$, each wrapped into $(-180,180]$ by the map $\\Delta \\theta \\mapsto \\left((\\Delta \\theta + 180) \\bmod 360\\right) - 180$, where $\\Delta \\theta = \\theta^{\\star}_{\\mathrm{pSer}} - \\theta^{\\star}_{\\mathrm{Ser}}$.\n  3. The energy change $\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$, in kilocalories per mole.\n\nTest suite (three environments):\n- Case $1$ (happy path): nearby positive charge aligned with $\\alpha$-like geometry. Use $k_{\\mathrm{el}}=1.5$ and $\\psi_{0}=-60$.\n- Case $2$ (no directional stabilization): no nearby positive charge. Use $k_{\\mathrm{el}}=0.0$ and $\\psi_{0}=0.0$.\n- Case $3$ (competing stabilization near $\\beta$): weaker positive charge aligned with $\\beta$-like geometry. Use $k_{\\mathrm{el}}=0.9$ and $\\psi_{0}=130.0$.\n\nRequired output format:\n- Your program must produce a single line containing a flat list with $9$ numbers: $\\left[\\Delta \\phi_{1},\\Delta \\psi_{1},\\Delta E_{1},\\Delta \\phi_{2},\\Delta \\psi_{2},\\Delta E_{2},\\Delta \\phi_{3},\\Delta \\psi_{3},\\Delta E_{3}\\right]$.\n- Angles must be rounded to one decimal place (degrees). Energies must be rounded to three decimal places (kilocalories per mole).\n\nYour final answer must be a complete, runnable Python program that constructs the Ser “params,” applies the phosphorylation “Patch,” performs the conformational grid search for each test case, and prints the results in the exact format specified above.", "solution": "The problem presented requires the formalization and implementation of a simplified, knowledge-based energy function to predict the preferred backbone conformation of a single amino acid residue, both in its standard state (Serine, Ser) and with a post-translational modification (phospho-Serine, pSer). This task is rooted in the fundamental principle of computational structural biology: that the thermodynamically favored conformation of a molecule corresponds to a minimum in its potential energy landscape. The energy function, or scoring function, $E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$, is a mathematical model that approximates this potential energy, where $\\boldsymbol{\\theta}$ represents the system's conformational degrees of freedom and $\\boldsymbol{\\lambda}$ are the parameters of the model.\n\nIn this problem, the conformational variables are the backbone dihedral angles $\\phi$ and $\\psi$. A change in the residue's chemical state, from Ser to pSer, is modeled by altering the parameters $\\boldsymbol{\\lambda}$. This is analogous to the \"parameter file\" and \"Patch\" system used in molecular modeling software like Rosetta, where a base set of parameters defines a standard residue, and a Patch applies a specific modification.\n\nOur task is to construct the energy functions for Ser and pSer, find the minimum-energy conformation $(\\phi^{\\star}, \\psi^{\\star})$ for each by performing a grid search, and then quantify the change in conformation and energy due to phosphorylation under three different environmental conditions. All angles are in degrees and energies are in kilocalories per mole.\n\nThe total energy for a residue of type $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$ is given by:\n$$\nE_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right)\n$$\nwhere $\\mathbb{1}[\\cdot]$ is the indicator function, being $1$ if its argument is true and $0$ otherwise. This means for Serine, only the $E_{\\mathrm{bb}}$ term contributes, while for phospho-Serine, two additional \"Patch\" terms are applied.\n\nThe energy components are defined as follows:\n$1$. **Backbone Statistical Preference, $E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi)$**: This term models the intrinsic conformational propensities of the peptide backbone, which are known to cluster in specific regions of the Ramachandran plot, namely the $\\alpha$-helical and $\\beta$-strand basins. It is formulated as a sum of two Gaussian wells, where the depths of the wells, $d_{\\alpha}^{(r)}$ and $d_{\\beta}^{(r)}$, depend on the residue type $r$.\n$$\nE_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n\\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n$$\nThe common parameters are the centers for the $\\alpha$-basin, $(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha})=(-60,-45)$, the $\\beta$-basin, $(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta})=(-120,130)$, and the widths $\\sigma_{\\phi}=\\sigma_{\\psi}=25$.\nFor Serine, the parameters are $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ and $d_{\\beta}^{(\\mathrm{Ser})}=2.0$, favoring the $\\alpha$-helical conformation.\nThe phosphorylation \"Patch\" changes these to $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ and $d_{\\beta}^{(\\mathrm{pSer})}=3.2$, shifting the preference toward the $\\beta$-strand conformation.\n\n$2$. **Steric Penalty, $E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi)$**: This term is added only for pSer and models the steric hindrance introduced by the bulky phosphate group, which particularly penalizes the tight turns associated with the $\\alpha$-helical region. It is a positive Gaussian function centered on the $\\alpha$-helical $\\phi$ value.\n$$\nE_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right)\n$$\nThe parameters are amplitude $s_{0}=0.8$, center $\\mu_{\\phi,\\mathrm{steric}}=-60$, and width $\\sigma_{\\phi,\\mathrm{steric}}=15$. For Serine, this term is $0$.\n\n$3$. **Environmental Interaction, $E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi)$**: This term is also added only for pSer and models a directional electrostatic or hydrogen-bonding interaction between the negatively charged phosphate group and a nearby positive charge in the protein's environment. The strength of this interaction is $k_{\\mathrm{el}}$ and it favors a particular $\\psi$ angle, $\\psi_{0}$.\n$$\nE_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right)\n$$\nThe width is $\\sigma_{\\psi,\\mathrm{el}}=25$. The parameters $k_{\\mathrm{el}}$ and $\\psi_{0}$ are specified by the test cases. For Serine, or if $k_{\\mathrm{el}}=0$, this term is $0$.\n\nTo find the minimum-energy conformation, we will perform a grid search. The search space is a discrete grid defined by $\\phi, \\psi \\in \\{-180, -175, \\ldots, 180\\}$. For each of the three test cases, we will perform two separate grid searches: one for Serine to find $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ and $E_{\\min}^{(\\mathrm{Ser})}$, and one for phospho-Serine with the specified environmental parameters $(k_{\\mathrm{el}}, \\psi_{0})$ to find $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$ and $E_{\\min}^{(\\mathrm{pSer})}$.\n\nFrom these results, we compute the required outputs for each case:\n- The change in dihedral angles, $\\Delta \\phi = \\phi^{\\star}_{\\mathrm{pSer}} - \\phi^{\\star}_{\\mathrm{Ser}}$ and $\\Delta \\psi = \\psi^{\\star}_{\\mathrm{pSer}} - \\psi^{\\star}_{\\mathrm{Ser}}$. These differences are wrapped to the interval $(-180, 180]$ using the mapping $\\Delta \\theta \\mapsto ((\\Delta \\theta + 180) \\pmod{360}) - 180$. This ensures the shortest angular distance is reported.\n- The change in minimum energy, $\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$.\n\nThis procedure is repeated for all three test cases, and the resulting $9$ values ($\\Delta\\phi, \\Delta\\psi, \\Delta E$ for each case) are collected, rounded to the specified precision (angles to $1$ decimal place, energies to $3$ decimal places), and presented in a single flat list. The implementation will use data structures to represent the base \"params\" for Serine and the \"Patch\" for phosphorylation, mimicking the logic of modular modeling frameworks.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the conformational search and scoring problem for Serine and phospho-Serine.\n    \"\"\"\n\n    # --- Data Structures for Parameters (\"Params\" and \"Patch\") ---\n    \n    # Shared parameters for backbone statistical potential\n    bb_shared_params = {\n        'mu_phi_alpha': -60.0, 'mu_psi_alpha': -45.0,\n        'mu_phi_beta': -120.0, 'mu_psi_beta': 130.0,\n        'sigma_phi': 25.0, 'sigma_psi': 25.0,\n    }\n\n    # Base \"params\" file for Serine\n    serine_params = {\n        'type': 'Ser',\n        **bb_shared_params,\n        'd_alpha': 3.0,\n        'd_beta': 2.0,\n        # Patch-related flags are off by default\n        'has_steric_penalty': False,\n        'has_env_interaction': False,\n    }\n\n    # \"Patch\" for phosphorylation\n    pser_patch = {\n        'd_alpha': 1.2,\n        'd_beta': 3.2,\n        'has_steric_penalty': True,\n        's0_steric': 0.8,\n        'mu_phi_steric': -60.0,\n        'sigma_phi_steric': 15.0,\n        'has_env_interaction': True,\n        'sigma_psi_el': 25.0,\n    }\n\n    def apply_patch(base_params, patch):\n        \"\"\"Applies a patch to base parameters to create modified parameters.\"\"\"\n        patched_params = base_params.copy()\n        patched_params['type'] = 'pSer'\n        patched_params.update(patch)\n        return patched_params\n\n    # Create phospho-Serine parameters by applying the patch\n    pser_base_params = apply_patch(serine_params, pser_patch)\n\n    # --- Energy Functions ---\n\n    def E_bb(phi, psi, params):\n        \"\"\"Calculates backbone statistical energy.\"\"\"\n        term_alpha = -params['d_alpha'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_alpha']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_alpha']) / params['sigma_psi'])**2\n        )\n        term_beta = -params['d_beta'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_beta']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_beta']) / params['sigma_psi'])**2\n        )\n        return term_alpha + term_beta\n\n    def E_steric(phi, params):\n        \"\"\"Calculates steric penalty for pSer.\"\"\"\n        if not params['has_steric_penalty']:\n            return 0.0\n        return params['s0_steric'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_steric']) / params['sigma_phi_steric'])**2\n        )\n\n    def E_env(psi, params, k_el, psi_0):\n        \"\"\"Calculates environmental interaction for pSer.\"\"\"\n        if not params['has_env_interaction'] or k_el == 0.0:\n            return 0.0\n        return -k_el * np.exp(-0.5 * ((psi - psi_0) / params['sigma_psi_el'])**2)\n\n    def total_energy(phi, psi, params, env_params):\n        \"\"\"Calculates the total energy for a given conformation.\"\"\"\n        k_el, psi_0 = env_params\n        energy = E_bb(phi, psi, params) + \\\n                 E_steric(phi, params) + \\\n                 E_env(psi, params, k_el, psi_0)\n        return energy\n        \n    # --- Grid Search and Calculation ---\n\n    def find_minimum_energy_conformation(params, env_params):\n        \"\"\"Performs a grid search to find the minimum energy conformation.\"\"\"\n        phi_grid = np.arange(-180.0, 180.1, 5.0)\n        psi_grid = np.arange(-180.0, 180.1, 5.0)\n        \n        min_energy = float('inf')\n        min_angles = (None, None)\n\n        for phi in phi_grid:\n            for psi in psi_grid:\n                E = total_energy(phi, psi, params, env_params)\n                if E  min_energy:\n                    min_energy = E\n                    min_angles = (phi, psi)\n        \n        return min_angles, min_energy\n\n    def wrap_angle(delta_theta):\n        \"\"\"Wraps an angular difference to the range (-180, 180].\"\"\"\n        return (delta_theta + 180.0) % 360.0 - 180.0\n\n    # --- Test Suite ---\n    test_cases = [\n        # (k_el, psi_0)\n        (1.5, -60.0),  # Case 1\n        (0.0, 0.0),    # Case 2\n        (0.9, 130.0),  # Case 3\n    ]\n\n    all_results = []\n    \n    # Find Serine minimum once (it's environment-independent)\n    ser_env_params = (0.0, 0.0) # k_el=0 for Serine\n    ser_min_angles, ser_min_energy = find_minimum_energy_conformation(serine_params, ser_env_params)\n    phi_star_ser, psi_star_ser = ser_min_angles\n\n    for case_env_params in test_cases:\n        # Find pSerine minimum for current environment\n        pser_min_angles, pser_min_energy = find_minimum_energy_conformation(pser_base_params, case_env_params)\n        phi_star_pser, psi_star_pser = pser_min_angles\n        \n        # Calculate differences\n        delta_phi = wrap_angle(phi_star_pser - phi_star_ser)\n        delta_psi = wrap_angle(psi_star_pser - psi_star_ser)\n        delta_E = pser_min_energy - ser_min_energy\n\n        # Round and append results\n        all_results.append(np.round(delta_phi, 1))\n        all_results.append(np.round(delta_psi, 1))\n        all_results.append(np.round(delta_E, 3))\n\n    # --- Final Output ---\n    # Convert all numbers to strings for joining, handling -0.0\n    # The format 'g' prevents scientific notation for small numbers.\n    results_str = [f\"{x:.1f}\" if i % 3 != 2 else f\"{x:.3f}\" for i, x in enumerate(all_results)]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2381408"}]}