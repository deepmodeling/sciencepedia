{"hands_on_practices": [{"introduction": "The foundation of all protein structure visualization lies in our ability to interpret raw atomic coordinates as meaningful chemical features. This first practice challenges you to do just that, by implementing the geometric definition of a peptide bond's conformation [@problem_id:2416436]. You will translate the precise mathematical definition of the $\\omega$ dihedral angle into a computational rule to distinguish the rare cis-peptide bonds from the common trans ones, a fundamental skill in structural quality assessment and analysis.", "problem": "You are given a mathematical specification for classifying peptide bonds in a protein backbone as cis or not, based on the backbone dihedral angle about the peptide bond. Consider one peptide bond that connects residue $i$ to residue $i+1$. Let the four three-dimensional points be the carbon alpha of residue $i$ ($\\mathrm{C}_\\alpha(i)$), the carbonyl carbon of residue $i$ ($\\mathrm{C}(i)$), the amide nitrogen of residue $i+1$ ($\\mathrm{N}(i+1)$), and the carbon alpha of residue $i+1$ ($\\mathrm{C}_\\alpha(i+1)$). Denote these four points as $P_1$, $P_2$, $P_3$, and $P_4$, respectively, with coordinates in $\\mathbb{R}^3$. The backbone dihedral angle about the peptide bond $\\mathrm{C}(i)-\\mathrm{N}(i+1)$ is defined as the signed angle $\\omega$ between the two planes $(P_1,P_2,P_3)$ and $(P_2,P_3,P_4)$, computed from first principles as follows.\n\nLet the bond vectors be\n$$\n\\mathbf{b}_0 = P_2 - P_1,\\quad \\mathbf{b}_1 = P_3 - P_2,\\quad \\mathbf{b}_2 = P_4 - P_3.\n$$\nLet\n$$\n\\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1,\\quad \\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2,\\quad \\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert},\\quad \\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1.\n$$\nThe signed dihedral angle $\\omega$ is then\n$$\n\\omega = \\operatorname{atan2}\\!\\left(\\mathbf{m}_1 \\cdot \\mathbf{n}_2,\\ \\mathbf{n}_1 \\cdot \\mathbf{n}_2\\right),\n$$\nwhich returns the principal value in $(-\\pi,\\pi]$ in radians.\n\nA peptide bond is classified as cis if and only if the principal value of the dihedral angle $\\omega$ satisfies $\\lvert \\omega \\rvert \\le \\tau$, where the tolerance is $\\tau = \\pi/6$ radians. Use a numerical comparison tolerance of $\\epsilon = 10^{-9}$ radians when evaluating the inequality.\n\nYour task is to write a complete, runnable program that, for each test case specified below, identifies which peptide bonds are cis and returns the list of zero-based indices for those cis bonds within that test case. Angles must be treated in radians.\n\nTo make the test cases concrete and self-contained without external files, each peptide bond in a test case is given indirectly by a pair of angles $(\\theta_1,\\theta_2)$ that parametrize a canonical four-point construction aligned to the $x$-axis. For each pair $(\\theta_1,\\theta_2)$, construct the four points\n$$\nP_1 = (-1,\\ \\cos\\theta_1,\\ \\sin\\theta_1),\\quad\nP_2 = (0,\\ 0,\\ 0),\\quad\nP_3 = (1,\\ 0,\\ 0),\\quad\nP_4 = (2,\\ \\cos\\theta_2,\\ \\sin\\theta_2),\n$$\nall coordinates expressed in units of an arbitrary length. This construction yields a peptide-bond dihedral $\\omega = \\theta_1 - \\theta_2$ whose principal value is obtained by the above $\\operatorname{atan2}$ expression.\n\nTest suite (each line is one test case; each test case is a list of $(\\theta_1,\\theta_2)$ pairs; all angles are in radians):\n\n- Test case $1$: $[(1.234,\\ 1.234)]$.\n- Test case $2$: $[(1.234,\\ 1.834)]$.\n- Test case $3$: $[(0.0,\\ \\pi - 0.01),\\ (2.5,\\ 2.5 + 2\\pi - 0.1),\\ (0.0,\\ -\\pi/6)]$.\n- Test case $4$: $[]$ (no peptide bonds).\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed list of zero-based indices of the cis bonds for the corresponding test case. For example, if the first test case had a cis bond at index $0$, the second had none, the third had cis bonds at indices $1$ and $2$, and the fourth had none, the output must be exactly\n$[[0],[],[1,2],[]]$.", "solution": "The provided problem statement is subjected to validation and is found to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a clear computational task based on established principles of structural biology and vector mathematics. I shall now provide a complete solution.\n\nThe problem requires the classification of peptide bonds as 'cis' based on the value of the backbone dihedral angle $\\omega$. A peptide bond is defined by four atomic coordinates: $P_1 = \\mathrm{C}_\\alpha(i)$, $P_2 = \\mathrm{C}(i)$, $P_3 = \\mathrm{N}(i+1)$, and $P_4 = \\mathrm{C}_\\alpha(i+1)$, where $i$ is the residue index.\n\nThe dihedral angle $\\omega$ is defined as the signed angle between the plane containing points $(P_1, P_2, P_3)$ and the plane containing points $(P_2, P_3, P_4)$. The calculation is specified using vector algebra. Let the bond vectors be defined as:\n$$\n\\mathbf{b}_0 = P_2 - P_1,\\quad \\mathbf{b}_1 = P_3 - P_2,\\quad \\mathbf{b}_2 = P_4 - P_3\n$$\nThe normal vectors to the two planes are given by the cross products of the bond vectors defining them:\n$$\n\\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1 \\\\\n\\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2\n$$\nThe unsigned angle between the planes is simply the angle between these two normal vectors. To determine the sign of the angle, a reference direction in the first plane is established. The problem defines this using the vector $\\mathbf{m}_1$:\n$$\n\\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert} \\\\\n\\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1\n$$\nThe signed angle $\\omega$ is then computed using the two-argument arctangent function, $\\operatorname{atan2}$, which correctly maps the result to the interval $(-\\pi, \\pi]$ radians:\n$$\n\\omega = \\operatorname{atan2}\\!\\left(\\mathbf{m}_1 \\cdot \\mathbf{n}_2,\\ \\mathbf{n}_1 \\cdot \\mathbf{n}_2\\right)\n$$\nA peptide bond is classified as cis if its dihedral angle $\\omega$ satisfies the condition $|\\omega| \\le \\tau$, where the angular tolerance is $\\tau = \\pi/6$ radians. Numerical computations involving floating-point numbers must account for potential precision errors, so we evaluate this inequality as $|\\omega| \\le \\tau + \\epsilon$, using the given numerical tolerance $\\epsilon = 10^{-9}$ radians.\n\nThe problem provides a specific, parametrized construction for generating test cases, avoiding the need for external data files. For a given pair of angles $(\\theta_1, \\theta_2)$, the four points are constructed as:\n$$\nP_1 = (-1,\\ \\cos\\theta_1,\\ \\sin\\theta_1) \\\\\nP_2 = (0,\\ 0,\\ 0) \\\\\nP_3 = (1,\\ 0,\\ 0) \\\\\nP_4 = (2,\\ \\cos\\theta_2,\\ \\sin\\theta_2)\n$$\nBefore implementing the solution, we must verify the problem's claim that this construction results in $\\omega$ being the principal value of $\\theta_1 - \\theta_2$. We proceed with the derivation.\n\nFirst, we compute the bond vectors from the given points:\n$$ \\mathbf{b}_0 = P_2 - P_1 = (0,0,0) - (-1, \\cos\\theta_1, \\sin\\theta_1) = (1, -\\cos\\theta_1, -\\sin\\theta_1) $$\n$$ \\mathbf{b}_1 = P_3 - P_2 = (1,0,0) - (0,0,0) = (1, 0, 0) $$\n$$ \\mathbf{b}_2 = P_4 - P_3 = (2, \\cos\\theta_2, \\sin\\theta_2) - (1,0,0) = (1, \\cos\\theta_2, \\sin\\theta_2) $$\nNext, we compute the normal vectors:\n$$ \\mathbf{n}_1 = \\mathbf{b}_0 \\times \\mathbf{b}_1 = (1, -\\cos\\theta_1, -\\sin\\theta_1) \\times (1, 0, 0) = (0, -\\sin\\theta_1, \\cos\\theta_1) $$\n$$ \\mathbf{n}_2 = \\mathbf{b}_1 \\times \\mathbf{b}_2 = (1, 0, 0) \\times (1, \\cos\\theta_2, \\sin\\theta_2) = (0, -\\sin\\theta_2, \\cos\\theta_2) $$\nWe then compute the dot product $\\mathbf{n}_1 \\cdot \\mathbf{n}_2$, which will be the second argument to $\\operatorname{atan2}$:\n$$ \\mathbf{n}_1 \\cdot \\mathbf{n}_2 = (0)(0) + (-\\sin\\theta_1)(-\\sin\\theta_2) + (\\cos\\theta_1)(\\cos\\theta_2) = \\cos\\theta_1\\cos\\theta_2 + \\sin\\theta_1\\sin\\theta_2 = \\cos(\\theta_1 - \\theta_2) $$\nFor the first argument of $\\operatorname{atan2}$, we need $\\mathbf{m}_1 \\cdot \\mathbf{n}_2$. First, we find $\\mathbf{m}_1$:\n$$ \\hat{\\mathbf{b}}_1 = \\frac{\\mathbf{b}_1}{\\lVert \\mathbf{b}_1 \\rVert} = \\frac{(1,0,0)}{\\sqrt{1^2+0^2+0^2}} = (1, 0, 0) $$\n$$ \\mathbf{m}_1 = \\mathbf{n}_1 \\times \\hat{\\mathbf{b}}_1 = (0, -\\sin\\theta_1, \\cos\\theta_1) \\times (1, 0, 0) = (0, \\cos\\theta_1, \\sin\\theta_1) $$\nNow, we compute the dot product $\\mathbf{m}_1 \\cdot \\mathbf{n}_2$:\n$$ \\mathbf{m}_1 \\cdot \\mathbf{n}_2 = (0)(0) + (\\cos\\theta_1)(-\\sin\\theta_2) + (\\sin\\theta_1)(\\cos\\theta_2) = \\sin\\theta_1\\cos\\theta_2 - \\cos\\theta_1\\sin\\theta_2 = \\sin(\\theta_1 - \\theta_2) $$\nSubstituting these results into the formula for $\\omega$:\n$$ \\omega = \\operatorname{atan2}(\\sin(\\theta_1 - \\theta_2), \\cos(\\theta_1 - \\theta_2)) $$\nThis confirms that for the provided test case construction, $\\omega$ is precisely the principal value of the angle difference $\\theta_1 - \\theta_2$, reduced to the interval $(-\\pi, \\pi]$. This elegant simplification allows us to bypass the full vector calculation for the specific test cases and proceed with a more direct computation.\n\nThe algorithm is as follows:\nFor each test case, which is a list of $(\\theta_1, \\theta_2)$ pairs:\n$1$. Initialize an empty list to store the zero-based indices of cis bonds.\n$2$. For each pair $(\\theta_1, \\theta_2)$ at index $i$ in the list:\n    a. Calculate the angle difference, $\\Delta\\theta = \\theta_1 - \\theta_2$.\n    b. Compute the principal value of this difference, $\\omega = \\operatorname{atan2}(\\sin(\\Delta\\theta), \\cos(\\Delta\\theta))$.\n    c. Check if the cis condition is met: $|\\omega| \\le \\pi/6 + 10^{-9}$.\n    d. If the condition is true, add the index $i$ to the list of cis bond indices.\n$3$. After processing all pairs, the list of indices for the current test case is complete. This process is repeated for all test cases.\n$4$. Finally, the collected results are formatted into a single string as specified by the problem.\nThis procedure is deterministic and directly implements the validated problem definition.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the peptide bond classification problem for a given suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple represents a (theta1, theta2) pair in radians.\n    test_cases = [\n        # Test case 1\n        [(1.234, 1.234)],\n        # Test case 2\n        [(1.234, 1.834)],\n        # Test case 3\n        [(0.0, np.pi - 0.01), (2.5, 2.5 + 2 * np.pi - 0.1), (0.0, -np.pi / 6)],\n        # Test case 4\n        [],\n    ]\n\n    # Define constants from the problem\n    tau = np.pi / 6.0  # Cis/trans boundary angle tolerance\n    epsilon = 1e-9      # Numerical comparison tolerance\n\n    all_results = []\n\n    for case in test_cases:\n        cis_indices = []\n        for i, (theta1, theta2) in enumerate(case):\n            # As derived, for the special case geometry, the dihedral angle omega\n            # is the principal value of (theta1 - theta2).\n            delta_theta = theta1 - theta2\n            \n            # The use of np.arctan2(np.sin(x), np.cos(x)) correctly computes the\n            # principal value of an angle x in the range (-pi, pi].\n            omega = np.arctan2(np.sin(delta_theta), np.cos(delta_theta))\n            \n            # A peptide bond is cis if |omega| <= tau.\n            # We use the numerical tolerance epsilon for the comparison.\n            if abs(omega) <= tau + epsilon:\n                cis_indices.append(i)\n        \n        all_results.append(cis_indices)\n\n    # Format the final output string precisely as required: [[...],[...],...]\n    # A list comprehension and f-strings are used to avoid spaces in the output.\n    results_str = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n\n```", "id": "2416436"}, {"introduction": "Beyond local geometry, the essence of a protein's three-dimensional fold is captured by interactions between residues that are distant in the sequence but close in space. This practice guides you through implementing a key visualization technique: drawing connections to highlight these long-range contacts [@problem_id:2416453]. You will learn to apply both sequence and spatial separation criteria to identify these crucial tertiary contacts and map their interaction distance to a visual property, semi-transparency, a fundamental method for encoding quantitative data directly onto a structure.", "problem": "You are given short three-dimensional residue coordinate sets representing backbone C-alpha positions for toy protein fragments. A \"contact map\" is defined between residue indices $i$ and $j$ by the Euclidean distance in three-dimensional space between their coordinates $\\mathbf{r}_i \\in \\mathbb{R}^3$ and $\\mathbf{r}_j \\in \\mathbb{R}^3$. Let the Euclidean distance be $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2$. A pair $(i,j)$ is considered a contact to be visualized as a line segment connecting $\\mathbf{r}_i$ and $\\mathbf{r}_j$ if and only if both of the following conditions hold: (1) the sequence separation satisfies $|i-j| \\ge s_{\\min}$, and (2) the spatial separation satisfies $d_{ij} \\le d_{\\mathrm{thr}}$. For each included contact, define a unitless semi-transparency value (alpha) by $\\alpha_{ij} = \\max\\{0, 1 - d_{ij}/d_{\\mathrm{thr}}\\}$, which maps shorter distances to higher opacity and distances equal to the threshold $d_{\\mathrm{thr}}$ to zero opacity. Coordinates are given in Ångström (Å), all distances $d_{ij}$ and $d_{\\mathrm{thr}}$ are in Ångström (Å), and $\\alpha_{ij}$ is unitless.\n\nIf a residue coordinate is missing, any pair involving that residue must be ignored. For reporting, use one-based residue indexing. For each test case below, compute the set of contact pairs, their $\\alpha_{ij}$ values, and produce the following per-test outputs:\n- the integer number of contact pairs,\n- the floating-point sum of all $\\alpha_{ij}$ values rounded to three decimals,\n- the list of included residue index pairs as a list of two-integer lists $[i,j]$ with $i<j$, sorted in ascending lexicographic order.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no whitespace. Each element corresponds to one test case and is itself a list of the three outputs described above, in the order given. For example, the overall structure must be of the form \"[[n1,sum1,[[i,j],...]], [n2,sum2,[]], [n3,sum3,[[i,j],...]]]\" but with actual computed values in place of the placeholders.\n\nTest suite:\n- Test case A (helix-like fragment): residue coordinates in Ångström (Å)\n  - $\\mathbf{r}_1 = (2.300000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (-0.399391, 2.265058, 1.500000)$\n  - $\\mathbf{r}_3 = (-2.161293, -0.786646, 3.000000)$\n  - $\\mathbf{r}_4 = (1.150000, -1.991858, 4.500000)$\n  - $\\mathbf{r}_5 = (1.761902, 1.478411, 6.000000)$\n  - $\\mathbf{r}_6 = (-1.761902, 1.478411, 7.500000)$\n  - Parameters: $d_{\\mathrm{thr}} = 8.000000$ Å, $s_{\\min} = 3$.\n- Test case B (extended fragment): residue coordinates in Ångström (Å)\n  - $\\mathbf{r}_1 = (0.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (3.800000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_3 = (7.600000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_4 = (11.400000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_5 = (15.200000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_6 = (19.000000, 0.000000, 0.000000)$\n  - Parameters: $d_{\\mathrm{thr}} = 6.000000$ Å, $s_{\\min} = 2$.\n- Test case C (missing coordinate present): residue coordinates in Ångström (Å)\n  - $\\mathbf{r}_1 = (0.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_2 = (4.000000, 0.000000, 0.000000)$\n  - $\\mathbf{r}_3$ is missing\n  - $\\mathbf{r}_4 = (0.000000, 4.000000, 0.000000)$\n  - $\\mathbf{r}_5 = (3.000000, 3.000000, 0.000000)$\n  - Parameters: $d_{\\mathrm{thr}} = 5.000000$ Å, $s_{\\min} = 2$.\n\nAngle units are not used in this task. All final numeric answers are unitless or in Ångström (Å) as specified, but your program's single-line output must contain only numbers and lists as described, with no unit symbols, no whitespace, and no additional text. Round only the per-test sum of $\\alpha_{ij}$ values to three decimals; do not round intermediate distances when deciding inclusion.", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded, well-posed, and free from contradiction, ambiguity, or factual error. The problem constitutes a well-defined computational task based on fundamental principles of structural bioinformatics. The solution, therefore, proceeds by direct implementation of the specified algorithm.\n\nThe core of the problem is to identify and characterize \"contacts\" between protein residues, represented by their C-alpha coordinates $\\mathbf{r}_i \\in \\mathbb{R}^3$. A contact between two residues with one-based indices $i$ and $j$ is established if and only if two conditions are met simultaneously.\n\nFirst, the sequence separation, defined by the absolute difference of indices, must meet a minimum threshold $s_{\\min}$. This is expressed as:\n$$|i-j| \\ge s_{\\min}$$\nThis condition excludes contacts between residues that are close to each other in the polymer chain, focusing analysis on tertiary structure interactions. By convention, we consider only pairs where $i < j$, so the condition simplifies to $j-i \\ge s_{\\min}$.\n\nSecond, the spatial separation, defined as the Euclidean distance $d_{ij}$ between their coordinates, must not exceed a specified distance threshold $d_{\\mathrm{thr}}$. The distance is calculated as:\n$$d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_2 = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2}$$\nThe condition is:\n$$d_{ij} \\le d_{\\mathrm{thr}}$$\n\nFor each pair $(i, j)$ that satisfies both conditions, a unitless semi-transparency value, $\\alpha_{ij}$, is computed. This value is designed to be inversely proportional to the distance, assigning higher opacity (lower transparency) to closer contacts. The formula is:\n$$\\alpha_{ij} = \\max\\{0, 1 - d_{ij}/d_{\\mathrm{thr}}\\}$$\nSince the contact condition $d_{ij} \\le d_{\\mathrm{thr}}$ ensures that $d_{ij}/d_{\\mathrm{thr}} \\le 1$, the expression simplifies to $\\alpha_{ij} = 1 - d_{ij}/d_{\\mathrm{thr}}$.\n\nThe algorithmic procedure to solve this problem for each test case is as follows:\n\n1.  Initialize an empty list for contact pairs and a running sum for $\\alpha$ values, initialized to $0.0$.\n2.  Iterate through all unique pairs of residue indices $(i, j)$ such that $1 \\le i < j \\le N$, where $N$ is the total number of residues.\n3.  For each pair $(i, j)$:\n    a. Verify that coordinates for both residue $i$ and residue $j$ are present. If either is missing, the pair is discarded, as per the problem specification.\n    b. Check if the sequence separation condition $j-i \\ge s_{\\min}$ is met. If not, the pair is discarded.\n    c. If the sequence separation is sufficient, compute the Euclidean distance $d_{ij}$.\n    d. Check if the spatial distance condition $d_{ij} \\le d_{\\mathrm{thr}}$ is met. If not, the pair is discarded.\n    e. If both conditions are satisfied, the pair is a contact. The value $\\alpha_{ij} = 1 - d_{ij}/d_{\\mathrm{thr}}$ is calculated and added to the running sum. The pair $[i, j]$ is added to the list of contacts.\n4.  After all pairs have been evaluated, the results are compiled:\n    a. The total number of contacts is the final count of pairs in the contact list.\n    b. The total sum of $\\alpha$ values is rounded to three decimal places.\n    c. The list of contact pairs is already sorted in ascending lexicographic order due to the nature of the nested loops ($i$ from $1$ to $N-1$, $j$ from $i+1$ to $N$).\n5.  These three aggregated results—the count, the rounded sum, and the list of pairs—are formatted into a single string according to the strict \"no whitespace\" rule specified in the problem.\n\nThis procedure is deterministic and will produce a unique, verifiable result for each test case. The implementation utilizes the `numpy` library for efficient and precise vector calculations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef format_result(result_tuple):\n    \"\"\"Formats a single test case result into the required string format.\"\"\"\n    n, s, pairs = result_tuple\n    # Round the sum of alphas to three decimal places.\n    s_rounded = round(s, 3)\n    \n    # Format pairs as a string list \"[i,j]\"\n    pairs_str_list = [f\"[{p[0]},{p[1]}]\" for p in pairs]\n    # Join pairs into a single string \"[[i,j],[k,l],...]\"\n    pairs_str = f\"[{','.join(pairs_str_list)}]\"\n    \n    # Format the final result for the test case as \"[n,s,pairs_str]\"\n    return f\"[{n},{s_rounded},{pairs_str}]\"\n\ndef process_case(coords, d_thr, s_min):\n    \"\"\"Processes a single test case.\"\"\"\n    contact_pairs = []\n    alpha_sum = 0.0\n    num_residues = len(coords)\n\n    # Iterate over all unique pairs of residues (i, j) with i < j\n    for i in range(num_residues):\n        for j in range(i + 1, num_residues):\n            # Residue indices are 1-based\n            res_idx_i = i + 1\n            res_idx_j = j + 1\n\n            # Ignore pairs involving a missing coordinate\n            if coords[i] is None or coords[j] is None:\n                continue\n\n            # 1. Check sequence separation\n            if (res_idx_j - res_idx_i) >= s_min:\n                # 2. Calculate Euclidean distance\n                dist = np.linalg.norm(coords[i] - coords[j])\n\n                # 3. Check spatial separation\n                if dist <= d_thr:\n                    # This is a contact\n                    contact_pairs.append([res_idx_i, res_idx_j])\n                    \n                    # Calculate alpha value\n                    alpha = 1.0 - (dist / d_thr)\n                    alpha_sum += alpha\n    \n    num_contacts = len(contact_pairs)\n    \n    return (num_contacts, alpha_sum, contact_pairs)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the processing, and print the final output.\n    \"\"\"\n    test_cases = [\n        # Test case A\n        {\n            \"coords\": [\n                np.array([2.300000, 0.000000, 0.000000]),\n                np.array([-0.399391, 2.265058, 1.500000]),\n                np.array([-2.161293, -0.786646, 3.000000]),\n                np.array([1.150000, -1.991858, 4.500000]),\n                np.array([1.761902, 1.478411, 6.000000]),\n                np.array([-1.761902, 1.478411, 7.500000])\n            ],\n            \"d_thr\": 8.0,\n            \"s_min\": 3\n        },\n        # Test case B\n        {\n            \"coords\": [\n                np.array([0.000000, 0.000000, 0.000000]),\n                np.array([3.800000, 0.000000, 0.000000]),\n                np.array([7.600000, 0.000000, 0.000000]),\n                np.array([11.400000, 0.000000, 0.000000]),\n                np.array([15.200000, 0.000000, 0.000000]),\n                np.array([19.000000, 0.000000, 0.000000])\n            ],\n            \"d_thr\": 6.0,\n            \"s_min\": 2\n        },\n        # Test case C\n        {\n            \"coords\": [\n                np.array([0.000000, 0.000000, 0.000000]),\n                np.array([4.000000, 0.000000, 0.000000]),\n                None,  # Missing coordinate for residue 3\n                np.array([0.000000, 4.000000, 0.000000]),\n                np.array([3.000000, 3.000000, 0.000000])\n            ],\n            \"d_thr\": 5.0,\n            \"s_min\": 2\n        }\n    ]\n\n    formatted_results = []\n    for case in test_cases:\n        result_tuple = process_case(case[\"coords\"], case[\"d_thr\"], case[\"s_min\"])\n        formatted_results.append(format_result(result_tuple))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2416453"}, {"introduction": "The most powerful structural visualizations often integrate information from other biological sources. This final practice demonstrates this principle by combining 3D structure with evolutionary data from a Multiple Sequence Alignment (MSA) [@problem_id:2416426]. You will first quantify sequence variability at each position using Shannon entropy, a concept from information theory, and then map this conservation score onto the protein's C$_\\alpha$ backbone. This powerful approach allows you to visually hypothesize which parts of the protein are critical for its function and which are less constrained, revealing the story of evolution in three dimensions.", "problem": "Write a program that formalizes the following visualization principle: to visualize only the atoms of a protein that are not conserved in a Multiple Sequence Alignment (MSA), one must compute a column-wise conservation score from the MSA, identify which aligned positions are variable, map those positions back to residue indices in a chosen reference sequence, and then select the corresponding atoms in three-dimensional space. In this problem, treat each residue as represented by its alpha-carbon atom (Cα) with given three-dimensional coordinates in Angstroms. Your task is to compute, for each provided test case, the number of selected atoms and the spatial spread of their positions measured by the radius of gyration. Report the number of selected atoms as an integer and the radius of gyration as a float in Angstroms rounded to three decimal places.\n\nFoundational definitions and rules to use:\n- Multiple Sequence Alignment (MSA): An MSA is a set of aligned protein sequences of equal aligned length, where gap characters are denoted by $-$ and letters are drawn from the $20$ standard amino acid one-letter codes. Consider the aligned reference sequence as part of the MSA.\n- Column frequencies and Shannon entropy: For each alignment column $j$, let the multiset of non-gap amino acids be $X_j$. Let $n_j$ be the number of non-gap characters in $X_j$. For each observed amino acid type $a$ in $X_j$, define the empirical frequency $p(a) = \\frac{\\text{count of }a}{n_j}$. The Shannon entropy of the column is\n$$\nH_j = -\\sum_{a \\in X_j^\\ast} p(a)\\,\\ln p(a),\n$$\nwhere $X_j^\\ast$ is the set of distinct amino acids present in column $j$, and $\\ln$ is the natural logarithm. Define the maximum possible entropy $H_{\\max} = \\ln 20$. The normalized entropy is\n$$\n\\widehat{H}_j = \\frac{H_j}{H_{\\max}}.\n$$\n- Non-conserved (variable) criterion: Given a threshold $\\tau$ with $0 \\le \\tau \\le 1$, a column $j$ is considered variable if and only if $\\widehat{H}_j \\ge \\tau$.\n- Mapping from alignment columns to reference residues: Scan the aligned reference sequence from left to right. Maintain a residue index $k$ initialized at $-1$. For each column position $j$, if the aligned reference character is a gap $-$, then this column does not map to any residue index. Otherwise, increment $k \\leftarrow k+1$ and map column $j$ to residue index $k$ of the unaligned reference sequence. The unaligned reference sequence length is $L$, and its Cα coordinates are provided as $L$ three-dimensional vectors in Angstroms.\n- Atom selection and geometry: The set of selected atoms is the set of Cα coordinates of reference residues whose aligned columns are variable according to the above criterion. If the selected set is empty, define the radius of gyration to be $0$. Otherwise, if there are $N$ selected atoms at positions $\\{\\mathbf{r}_i\\}_{i=1}^N$, define the center of mass (with equal masses) as $\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$, and the radius of gyration as\n$$\nR_g = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2},\n$$\nwhere $\\lVert \\cdot \\rVert$ denotes the Euclidean norm. Distances are in Angstroms. Report $R_g$ rounded to three decimal places.\n\nYour program must apply these steps to the following test suite. Each test case supplies: the unaligned reference sequence, its Cα coordinates, the aligned reference sequence, the remaining aligned sequences, and the threshold $\\tau$.\n\nTest case $1$ (happy-path with no variable mapping):\n- Reference sequence (unaligned): ACDEG\n- Cα coordinates (Angstroms): $\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0),(11.4,0.0,0.0),(15.2,0.0,0.0)\\big]$\n- Aligned reference: A-CDEG-\n- Other aligned sequences: AFC-EG-, A-CDE--\n- Threshold $\\tau$: $0.5$\n\nTest case $2$ (moderate variability captured by a lower threshold):\n- Reference sequence (unaligned): HIKLM\n- Cα coordinates (Angstroms): $\\big[(0.0,0.0,0.0),(3.8,0.5,0.0),(7.6,1.0,0.0),(11.4,1.5,0.0),(15.2,2.0,0.0)\\big]$\n- Aligned reference: HIKLM-\n- Other aligned sequences: HIKQM-, HFKLM-\n- Threshold $\\tau$: $0.2$\n\nTest case $3$ (four-sequence MSA with gaps and multiple variable mappings):\n- Reference sequence (unaligned): NPQR\n- Cα coordinates (Angstroms): $\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0),(11.4,0.0,0.0)\\big]$\n- Aligned reference: -NP-QR\n- Other aligned sequences: ANP-ER, -NP-QR, -NS-QR\n- Threshold $\\tau$: $0.18$\n\nTest case $4$ (single-variable-residue edge case):\n- Reference sequence (unaligned): WXY\n- Cα coordinates (Angstroms): $\\big[(0.0,0.0,0.0),(3.8,0.0,0.0),(7.6,0.0,0.0)\\big]$\n- Aligned reference: W-XY\n- Other aligned sequences: W-XY, F-XY\n- Threshold $\\tau$: $0.2$\n\nRequired output for each test case:\n- A list with two elements $[N, R_g]$ where $N$ is the integer count of selected atoms and $R_g$ is the radius of gyration in Angstroms rounded to three decimals.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, with each test case reported as $[N,R_g]$ and no spaces. For example, the format should be like $[[2,1.234],[0,0.000],[3,5.678],[1,0.000]]$ (this is only an illustration of formatting, not the correct numeric answers).\n\nAngle units do not apply. All distances must be interpreted and reported in Angstroms. The answers are pure numbers aggregated in the specified format.", "solution": "The problem presented is a well-posed and scientifically grounded exercise in computational biology, specifically in the analysis of protein structure in the context of sequence evolution. It requires the application of standard principles: quantification of sequence variability using Shannon entropy, mapping between aligned and unaligned sequence representations, and calculation of a basic structural parameter, the radius of gyration. The problem is valid as it is self-contained, logically consistent, and based on established formalisms. I will proceed with a step-by-step solution for each test case.\n\nThe core of the problem lies in executing a defined algorithm. Let us formalize the steps.\nFirst, for a given Multiple Sequence Alignment (MSA), we must analyze each column $j$. The set of non-gap characters in a column is denoted $X_j$. The size of this multiset is $n_j$. If $n_j > 0$, we determine the set of unique amino acid types $X_j^\\ast$. For each type $a \\in X_j^\\ast$, we compute its frequency $p(a)$. The Shannon entropy for the column is $H_j = -\\sum_{a \\in X_j^\\ast} p(a)\\,\\ln p(a)$. This is normalized by the maximum possible entropy for an alphabet of $20$ amino acids, $H_{\\max} = \\ln 20$, to yield $\\widehat{H}_j = H_j / H_{\\max}$. A column $j$ is deemed \"variable\" if $\\widehat{H}_j$ is greater than or equal to a given threshold $\\tau$.\n\nSecond, we map these variable columns to the residues of the unaligned reference sequence. We iterate through the aligned reference sequence. A counter for the residue index, $k$, is initialized to $-1$. For each column $j$, if the character in the aligned reference sequence is an amino acid, we increment $k$. This column $j$ corresponds to residue $k$. If the column was determined to be variable, then residue $k$ is selected.\n\nThird, we gather the three-dimensional coordinates $\\{\\mathbf{r}_i\\}_{i=1}^N$ of the $N$ selected residues. The number of selected atoms is $N$. If $N=0$, the radius of gyration $R_g$ is defined as $0$. If $N > 0$, we first compute the center of mass $\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i$. The radius of gyration is then computed as $R_g = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N \\lVert \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2}$, where $\\lVert \\cdot \\rVert$ is the Euclidean norm.\n\nThe value of the maximum entropy is $H_{\\max} = \\ln(20) \\approx 2.99573$.\n\n**Test Case 1**\n- Aligned reference: `A-CDEG-`\n- Other sequences: `AFC-EG-`, `A-CDE--`\n- Threshold $\\tau = 0.5$\nThe MSA consists of $3$ sequences. The aligned length is $7$.\n- Column $0$ (`A,A,A`): $n_0=3$, $X_0^\\ast=\\{\\text{A}\\}$, $p(A)=1$. $H_0 = 0$. $\\widehat{H}_0=0 < 0.5$.\n- Column $1$ (`-,F,-`): $n_1=1$, $X_1^\\ast=\\{\\text{F}\\}$, $p(F)=1$. $H_1 = 0$. $\\widehat{H}_1=0 < 0.5$.\n- Column $2$ (`C,C,C`): $H_2=0$. $\\widehat{H}_2=0 < 0.5$.\n- Column $3$ (`D,-,D`): $n_3=2$, $X_3^\\ast=\\{\\text{D}\\}$, $p(D)=1$. $H_3 = 0$. $\\widehat{H}_3=0 < 0.5$.\n- Column $4$ (`E,E,E`): $H_4=0$. $\\widehat{H}_4=0 < 0.5$.\n- Column $5$ (`G,G,-`): $n_5=2$, $X_5^\\ast=\\{\\text{G}\\}$, $p(G)=1$. $H_5=0$. $\\widehat{H}_5=0 < 0.5$.\n- Column $6$ (`-,-,-`): $n_6=0$. $H_6 = 0$. $\\widehat{H}_6=0 < 0.5$.\nNo column satisfies the variability criterion $\\widehat{H}_j \\ge 0.5$. Consequently, no residues are selected.\nNumber of selected atoms $N=0$. Radius of gyration $R_g=0.000$.\nResult: $[0, 0.000]$\n\n**Test Case 2**\n- Aligned reference: `HIKLM-`\n- Other sequences: `HIKQM-`, `HFKLM-`\n- Threshold $\\tau = 0.2$\n- Column $0$ (`H,H,H`): $H_0=0$. $\\widehat{H}_0 = 0 < 0.2$.\n- Column $1$ (`I,I,F`): $n_1=3$, $X_1^\\ast=\\{\\text{I},\\text{F}\\}$, $p(I)=2/3$, $p(F)=1/3$. $H_1 = -(\\frac{2}{3}\\ln\\frac{2}{3} + \\frac{1}{3}\\ln\\frac{1}{3}) \\approx 0.6365$. $\\widehat{H}_1 \\approx 0.6365/2.99573 \\approx 0.2125$. Since $0.2125 \\ge 0.2$, this column is variable.\n- Column $2$ (`K,K,K`): $H_2=0$. $\\widehat{H}_2 = 0 < 0.2$.\n- Column $3$ (`L,Q,L`): $n_3=3$, $X_3^\\ast=\\{\\text{L},\\text{Q}\\}$, $p(L)=2/3$, $p(Q)=1/3$. $H_3=H_1 \\approx 0.6365$. $\\widehat{H}_3 \\approx 0.2125 \\ge 0.2$. This column is variable.\n- Column $4$ (`M,M,M`): $H_4=0$. $\\widehat{H}_4 = 0 < 0.2$.\n- Column $5$ (`-,-,-`): $H_5=0$. $\\widehat{H}_5 = 0 < 0.2$.\nThe variable columns are $j=1$ and $j=3$.\nMapping to reference residues (`HIKLM-`):\n- Column $0$ (`H`) maps to residue $0$. Not variable.\n- Column $1$ (`I`) maps to residue $1$. Variable. Selected.\n- Column $2$ (`K`) maps to residue $2$. Not variable.\n- Column $3$ (`L`) maps to residue $3$. Variable. Selected.\n- Column $4$ (`M`) maps to residue $4$. Not variable.\nTwo residues are selected: residue $1$ and residue $3$. $N=2$. The corresponding coordinates are $\\mathbf{r}_1=(3.8, 0.5, 0.0)$ and $\\mathbf{r}_3=(11.4, 1.5, 0.0)$.\nCenter of mass: $\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{2}(\\mathbf{r}_1 + \\mathbf{r}_3) = (7.6, 1.0, 0.0)$.\nSquared distances from $\\mathbf{r}_{\\mathrm{cm}}$:\n$\\lVert \\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = \\lVert (3.8-7.6, 0.5-1.0, 0.0) \\rVert^2 = (-3.8)^2 + (-0.5)^2 = 14.44 + 0.25 = 14.69$.\n$\\lVert \\mathbf{r}_3 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = \\lVert (11.4-7.6, 1.5-1.0, 0.0) \\rVert^2 = (3.8)^2 + (0.5)^2 = 14.44 + 0.25 = 14.69$.\n$R_g = \\sqrt{\\frac{1}{2}(14.69 + 14.69)} = \\sqrt{14.69} \\approx 3.83275$. Rounded to three decimals, $R_g=3.833$.\nResult: $[2, 3.833]$\n\n**Test Case 3**\n- Aligned reference: `-NP-QR`\n- Other sequences: `ANP-ER`, `-NP-QR`, `-NS-QR`\n- Threshold $\\tau = 0.18$\nThe MSA has $4$ sequences.\n- Column $0$ (`-,A,-,-`): $H_0=0$. $\\widehat{H}_0 = 0 < 0.18$.\n- Column $1$ (`N,N,N,N`): $H_1=0$. $\\widehat{H}_1=0 < 0.18$.\n- Column $2$ (`P,P,P,S`): $n_2=4$, $X_2^\\ast=\\{\\text{P},\\text{S}\\}$, $p(P)=3/4$, $p(S)=1/4$. $H_2 = -(\\frac{3}{4}\\ln\\frac{3}{4} + \\frac{1}{4}\\ln\\frac{1}{4}) \\approx 0.5623$. $\\widehat{H}_2 \\approx 0.5623/2.99573 \\approx 0.1877$. Since $0.1877 \\ge 0.18$, this column is variable.\n- Column $3$ (`-,-,-,-`): $H_3=0$. $\\widehat{H}_3=0 < 0.18$.\n- Column $4$ (`Q,E,Q,Q`): $n_4=4$, $X_4^\\ast=\\{\\text{Q},\\text{E}\\}$, $p(Q)=3/4$, $p(E)=1/4$. $H_4=H_2 \\approx 0.5623$. $\\widehat{H}_4 \\approx 0.1877 \\ge 0.18$. This column is variable.\n- Column $5$ (`R,R,R,R`): $H_5=0$. $\\widehat{H}_5=0 < 0.18$.\nThe variable columns are $j=2$ and $j=4$.\nMapping to reference residues (`-NP-QR`):\n- Column $1$ (`N`) maps to residue $0$.\n- Column $2$ (`P`) maps to residue $1$. Variable. Selected.\n- Column $4$ (`Q`) maps to residue $2$. Variable. Selected.\n- Column $5$ (`R`) maps to residue $3$.\nTwo residues are selected: residue $1$ and residue $2$. $N=2$. The coordinates are $\\mathbf{r}_1=(3.8, 0.0, 0.0)$ and $\\mathbf{r}_2=(7.6, 0.0, 0.0)$.\n$\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{2}(\\mathbf{r}_1 + \\mathbf{r}_2) = (5.7, 0.0, 0.0)$.\n$\\lVert \\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = (3.8-5.7)^2 = (-1.9)^2 = 3.61$.\n$\\lVert \\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}} \\rVert^2 = (7.6-5.7)^2 = (1.9)^2 = 3.61$.\n$R_g = \\sqrt{\\frac{1}{2}(3.61 + 3.61)} = \\sqrt{3.61} = 1.9$. Rounded result: $1.900$.\nResult: $[2, 1.900]$\n\n**Test Case 4**\n- Aligned reference: `W-XY`\n- Other sequences: `W-XY`, `F-XY`\n- Threshold $\\tau = 0.2$\n- Column $0$ (`W,W,F`): $n_0=3$, $X_0^\\ast=\\{\\text{W},\\text{F}\\}$, $p(W)=2/3$, $p(F)=1/3$. $H_0 \\approx 0.6365$. $\\widehat{H}_0 \\approx 0.2125 \\ge 0.2$. Variable.\n- Column $1$ (`-,-,-`): $H_1=0$. $\\widehat{H}_1=0 < 0.2$.\n- Column $2$ (`X,X,X`): $H_2=0$. $\\widehat{H}_2=0 < 0.2$.\n- Column $3$ (`Y,Y,Y`): $H_3=0$. $\\widehat{H}_3=0 < 0.2$.\nOnly column $j=0$ is variable.\nMapping to reference residues (`W-XY`):\n- Column $0$ (`W`) maps to residue $0$. Variable. Selected.\n- Column $2$ (`X`) maps to residue $1$.\n- Column $3$ (`Y`) maps to residue $2$.\nOne residue is selected: residue $0$. $N=1$. The coordinate is $\\mathbf{r}_0=(0.0, 0.0, 0.0)$.\nFor $N=1$, the center of mass is the point itself, so the deviation is zero. Thus, $R_g=0$.\nResult: $[1, 0.000]$\n\nFinal summary of results:\n- Case 1: $[0, 0.000]$\n- Case 2: $[2, 3.833]$\n- Case 3: $[2, 1.900]$\n- Case 4: $[1, 0.000]$\nThese results will be formatted into the required final output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted output.\n    \"\"\"\n    # Foundational constant H_max = ln(20)\n    H_MAX = math.log(20)\n\n    test_cases = [\n        {\n            \"ref_unaligned\": \"ACDEG\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], [7.6, 0.0, 0.0],\n                [11.4, 0.0, 0.0], [15.2, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"A-CDEG-\",\n            \"other_aligned\": [\"AFC-EG-\", \"A-CDE--\"],\n            \"tau\": 0.5\n        },\n        {\n            \"ref_unaligned\": \"HIKLM\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.5, 0.0], [7.6, 1.0, 0.0],\n                [11.4, 1.5, 0.0], [15.2, 2.0, 0.0]\n            ]),\n            \"ref_aligned\": \"HIKLM-\",\n            \"other_aligned\": [\"HIKQM-\", \"HFKLM-\"],\n            \"tau\": 0.2\n        },\n        {\n            \"ref_unaligned\": \"NPQR\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], \n                [7.6, 0.0, 0.0], [11.4, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"-NP-QR\",\n            \"other_aligned\": [\"ANP-ER\", \"-NP-QR\", \"-NS-QR\"],\n            \"tau\": 0.18\n        },\n        {\n            \"ref_unaligned\": \"WXY\",\n            \"coords\": np.array([\n                [0.0, 0.0, 0.0], [3.8, 0.0, 0.0], [7.6, 0.0, 0.0]\n            ]),\n            \"ref_aligned\": \"W-XY\",\n            \"other_aligned\": [\"W-XY\", \"F-XY\"],\n            \"tau\": 0.2\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        coords = case[\"coords\"]\n        ref_aligned = case[\"ref_aligned\"]\n        other_aligned = case[\"other_aligned\"]\n        tau = case[\"tau\"]\n\n        # Step 1: Form the full MSA and analyze columns\n        msa = [ref_aligned] + other_aligned\n        aligned_len = len(ref_aligned)\n        \n        variable_columns = set()\n        for j in range(aligned_len):\n            column = [seq[j] for seq in msa]\n            non_gap_residues = [res for res in column if res != '-']\n            \n            n_j = len(non_gap_residues)\n            if n_j == 0:\n                h_j_norm = 0.0\n            else:\n                counts = Counter(non_gap_residues)\n                h_j = 0.0\n                for count in counts.values():\n                    p_a = count / n_j\n                    if p_a > 0:\n                        h_j -= p_a * math.log(p_a)\n                \n                h_j_norm = h_j / H_MAX\n            \n            if h_j_norm >= tau:\n                variable_columns.add(j)\n\n        # Step 2: Map columns to reference residues and identify variable ones\n        variable_residue_indices = []\n        residue_idx = -1\n        for j, char in enumerate(ref_aligned):\n            if char != '-':\n                residue_idx += 1\n                if j in variable_columns:\n                    variable_residue_indices.append(residue_idx)\n\n        # Step 3: Select atoms and compute geometry\n        selected_coords = coords[variable_residue_indices]\n        N = len(selected_coords)\n\n        if N == 0:\n            Rg = 0.0\n        else:\n            # Handle N=1 case; Rg is 0\n            if N == 1:\n                Rg = 0.0\n            else: # N > 1\n                center_of_mass = np.mean(selected_coords, axis=0)\n                # Correct calculation for Radius of Gyration\n                # Rg = sqrt( (1/N) * sum_i( ||r_i - r_cm||^2 ) )\n                # ||v||^2 is sum(v_j^2)\n                squared_distances = np.sum((selected_coords - center_of_mass)**2, axis=1)\n                Rg = np.sqrt(np.mean(squared_distances))\n\n        results.append(f\"[{N},{Rg:.3f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416426"}]}