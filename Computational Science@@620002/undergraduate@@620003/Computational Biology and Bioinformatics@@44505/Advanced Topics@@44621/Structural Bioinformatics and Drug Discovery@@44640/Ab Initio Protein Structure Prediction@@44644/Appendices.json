{"hands_on_practices": [{"introduction": "To truly understand *ab initio* protein folding, we must start with its core principles: the vastness of conformational space and the energy functions that guide the search. This first practice invites you to build a folding model from the ground up using a two-dimensional lattice. By extending the classic Hydrophobic-Polar (HP) model to include charged residues, you will directly implement the hydrophobic effect and electrostatic interactions—two primary driving forces of folding—and use an exhaustive search to discover how sequence determines structure in a simplified yet powerful framework.[@problem_id:2369976]", "problem": "You are asked to formalize and implement an extension of the two-dimensional (2D) Hydrophobic-Polar (HP) lattice protein model to a four-letter alphabet model that includes charged residues, denoted Hydrophobic, Polar, Negative, Cationic (HPNC). The goal is to search for a short polypeptide sequence and a self-avoiding 2D conformation on a square lattice that together achieve a minimal additive contact energy while containing at least one salt bridge. A salt bridge is defined here as a non-consecutive nearest-neighbor lattice contact between a Negative and a Cationic residue.\n\nStart from first principles that are appropriate for lattice protein models used in ab initio protein structure prediction. The fundamental base must be the following facts, without using any shortcut formulas:\n- Proteins can be abstracted as self-avoiding walks on a lattice, where each residue occupies one lattice site and consecutive residues are adjacent on the lattice. Only non-consecutive nearest-neighbor residue pairs are considered as contact interactions.\n- The hydrophobic effect motivates a favorable attraction between hydrophobic residues when they are in contact, modeled by a negative contact energy contribution for hydrophobic-hydrophobic contacts.\n- Electrostatic interactions between charged residues motivate favorable energy for opposite-charge contacts and unfavorable energy for like-charge contacts. In a coarse-grained lattice model at lattice spacing as the unit length, one can approximate this with a constant negative contribution for unlike charges and a constant positive contribution for like charges, applied only to nearest-neighbor non-consecutive contacts.\n- Additivity assumption: the total energy is the sum over pairwise contact energies across all non-consecutive contacting residue pairs.\n\nYour program must implement the following precise model and search protocol.\n- Residue types are an alphabet of size $4$: Hydrophobic ($\\mathrm{H}$), Polar ($\\mathrm{P}$), Negative ($\\mathrm{N}$), and Cationic ($\\mathrm{C}$). A sequence is a string of length $L$ over this alphabet.\n- A conformation is a self-avoiding walk of length $L$ on the $2$D square lattice with coordinates in $\\mathbb{Z}^2$, specified as a list of lattice coordinates $\\left[(x_0,y_0),(x_1,y_1),\\dots,(x_{L-1},y_{L-1})\\right]$ with unit steps and no repeated coordinates. To avoid redundant symmetries, fix $(x_0,y_0)=(0,0)$ and $(x_1,y_1)=(1,0)$.\n- Define the contact set $\\mathcal{C}$ for a conformation as all unordered index pairs $(i,j)$ with $0 \\le i < j \\le L-1$, such that $|i-j| \\ge 2$ and the Manhattan distance between $(x_i,y_i)$ and $(x_j,y_j)$ equals $1$.\n- Define the pairwise contact energy function $\\varepsilon(a,b)$ for residue types $a$ and $b$ as follows, using parameters $e_{\\mathrm{HH}}$, $e_{\\mathrm{NC}}$, and $e_{\\mathrm{like}}$ supplied per test case. Let $\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$ for encoding. Then:\n  - $\\varepsilon(\\mathrm{H},\\mathrm{H})=\\varepsilon(0,0)=e_{\\mathrm{HH}}$.\n  - $\\varepsilon(\\mathrm{N},\\mathrm{C})=\\varepsilon(2,3)=\\varepsilon(\\mathrm{C},\\mathrm{N})=\\varepsilon(3,2)=e_{\\mathrm{NC}}$.\n  - $\\varepsilon(\\mathrm{N},\\mathrm{N})=\\varepsilon(2,2)=e_{\\mathrm{like}}$ and $\\varepsilon(\\mathrm{C},\\mathrm{C})=\\varepsilon(3,3)=e_{\\mathrm{like}}$.\n  - All other residue pairs have $\\varepsilon(a,b)=0$.\n- For a sequence $\\{t_i\\}_{i=0}^{L-1}$ and a conformation with contact set $\\mathcal{C}$, the total energy is\n  $$E=\\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon\\left(t_i,t_j\\right).$$\n- The salt bridge count is\n  $$S=\\left|\\left\\{(i,j)\\in\\mathcal{C}\\;:\\;\\{t_i,t_j\\}=\\{\\mathrm{N},\\mathrm{C}\\}\\right\\}\\right|.$$\n- A solution must have at least one salt bridge, i.e., $S \\ge 1$.\n\nSearch objective and tie-breaking:\n- Among all sequences of length $L$ over the HPNC alphabet and all valid conformations as defined above, find the pair that minimizes $E$ subject to $S \\ge 1$.\n- If multiple pairs achieve the same minimal $E$, choose the one with the largest $S$.\n- If there is still a tie, choose the lexicographically smallest sequence under the encoding $\\mathrm{H}=0$, $\\mathrm{P}=1$, $\\mathrm{N}=2$, $\\mathrm{C}=3$, comparing the integer lists from left to right.\n- If there is still a tie, choose the conformation whose flattened coordinate list $\\left[x_0,y_0,x_1,y_1,\\dots,x_{L-1},y_{L-1}\\right]$ is lexicographically smallest.\n\nSequence encoding and output representation:\n- Encode a sequence as a list of $L$ integers in $\\{0,1,2,3\\}$ corresponding to $\\mathrm{H},\\mathrm{P},\\mathrm{N},\\mathrm{C}$ respectively.\n- Encode a conformation as a list of $L$ coordinate pairs, each coordinate pair being a list of two integers $\\left[x_i,y_i\\right]$.\n\nYour program must perform an exhaustive search that is guaranteed to find the exact optimum for the small test cases below by:\n- Enumerating all self-avoiding walks of length $L$ on the square lattice with the above anchoring.\n- Enumerating all sequences of length $L$ over the alphabet of size $4$.\n- Computing $E$ and $S$ exactly for each pair and applying the objective and tie-breaking rules.\n\nTest suite:\n- Case A (happy path): $L=6$, $e_{\\mathrm{HH}}=-1.0$, $e_{\\mathrm{NC}}=-2.0$, $e_{\\mathrm{like}}=+0.5$.\n- Case B (salt-bridge-dominant): $L=7$, $e_{\\mathrm{HH}}=0.0$, $e_{\\mathrm{NC}}=-2.5$, $e_{\\mathrm{like}}=+0.5$.\n- Case C (strong like-charge repulsion): $L=6$, $e_{\\mathrm{HH}}=-0.5$, $e_{\\mathrm{NC}}=-1.0$, $e_{\\mathrm{like}}=+1.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result corresponds to one test case, in the same order as listed above.\n- Each result must be a list of the form [$E_{\\min}, S_{\\mathrm{best}}$, seq, coords] where $E_{\\min}$ is the minimal energy rounded to three decimal places (as a real number), $S_{\\mathrm{best}}$ is the salt bridge count of the selected solution (as an integer), seq is the chosen sequence encoded as a list of integers in $\\{0,1,2,3\\}$, and coords is the chosen conformation encoded as a list of coordinate pairs as specified.\n- The final output must therefore be a single line containing something like [$r_A, r_B, r_C$], where each $r_X$ is a list in the above format for the corresponding case. Do not print any other text.", "solution": "The problem presented is a constrained optimization task within the framework of computational protein structure prediction. It requires the formalization and implementation of a four-letter Hydrophobic-Polar-Negative-Cationic (HPNC) lattice model. The objective is to find a polypeptide sequence and a corresponding self-avoiding conformation on a two-dimensional, 2D, square lattice that, in concert, achieve the minimum possible additive contact energy, under the constraint that the structure must contain at least one salt bridge. A salt bridge is defined as a non-covalent contact between a Negative ($\\mathrm{N}$) and a Cationic ($\\mathrm{C}$) residue.\n\nThe problem is well-posed, scientifically grounded in the principles of coarse-grained protein models, and provides all necessary definitions and parameters for a unique solution to be determined. The model is an extension of the classic Hydrophobic-Polar (HP) model, incorporating electrostatic effects, which is a standard approach in the field. Given the small sequence lengths specified ($L=6$ and $L=7$), an exhaustive search of the complete conformational and sequence space is computationally feasible and is the only method guaranteed to find the true global optimum as defined by the hierarchical objective function.\n\nThe solution is therefore designed as an exhaustive search algorithm that systematically explores all valid sequence-conformation pairs, evaluates them, and identifies the optimal pair according to the specified criteria. The algorithm proceeds as follows:\n\nFirst, we must generate the entire space of possible molecular entities. This space is the Cartesian product of the set of all unique, valid conformations and the set of all possible sequences of length $L$.\n\nA conformation is a self-avoiding walk of length $L$ on a 2D square lattice. To generate all such conformations, we employ a recursive backtracking (depth-first search) algorithm. The walk is anchored with the first two residues at coordinates $(x_0,y_0)=(0,0)$ and $(x_1,y_1)=(1,0)$ to eliminate trivial rotational and translational symmetries. The recursion extends the walk one residue at a time, exploring all four cardinal directions, ensuring that the new lattice site is not already occupied. When a walk of length $L$ is completed, it is added to our list of valid conformations.\n\nA sequence is a string of length $L$ over the alphabet $\\{\\mathrm{H}, \\mathrm{P}, \\mathrm{N}, \\mathrm{C}\\}$, which we encode as integers $\\{0, 1, 2, 3\\}$. The total number of sequences is $4^L$. These are generated systematically, ensuring every possible sequence is considered. This can be achieved by iterating through all $L$-digit numbers in base $4$.\n\nFor each pair of a conformation and a sequence, we must calculate its total energy $E$ and its salt bridge count $S$. This evaluation is performed in two steps.\n1. Given a conformation, we first determine its set of contacts, $\\mathcal{C}$. A contact is an unordered pair of residue indices $(i,j)$ such that the residues are non-adjacent in the sequence ($|i-j| \\ge 2$) but occupy adjacent sites on the lattice. The adjacency is determined by checking if the Manhattan distance between their coordinates is equal to $1$.\n2. With the contact set $\\mathcal{C}$ and the sequence $\\{t_i\\}_{i=0}^{L-1}$, we calculate the total energy $E$ and salt bridge count $S$. The total energy is the sum of pairwise interaction energies, $E = \\sum_{(i,j)\\in\\mathcal{C}}\\varepsilon(t_i, t_j)$. The energy function $\\varepsilon(a,b)$ is defined by the problem parameters $e_{\\mathrm{HH}}$, $e_{\\mathrm{NC}}$, and $e_{\\mathrm{like}}$, and is non-zero only for $\\mathrm{H}-\\mathrm{H}$, $\\mathrm{N}-\\mathrm{C}$, $\\mathrm{N}-\\mathrm{N}$, and $\\mathrm{C}-\\mathrm{C}$ contacts. The salt bridge count $S$ is the number of contacts in $\\mathcal{C}$ where the residue types are $\\{\\mathrm{N}, \\mathrm{C}\\}$.\n\nFinally, we identify the optimal solution. The search must adhere to a strict, four-level tie-breaking rule. We seek to:\n1. Minimize the total energy $E$.\n2. For a given minimal $E$, maximize the salt bridge count $S$.\n3. For a given $E$ and $S$, choose the lexicographically smallest sequence (using the integer encoding).\n4. As a final tie-breaker, choose the conformation whose flattened coordinate list is lexicographically smallest.\n\nThis hierarchical optimization is implemented by maintaining a single \"best-so-far\" solution throughout the exhaustive search. Each new valid candidate solution (i.e., where $S \\ge 1$) is compared to the current best. A candidate is deemed \"better\" if its corresponding objective tuple is lexicographically smaller than that of the current best. The objective tuple for a candidate consisting of a sequence $\\mathbf{t}$ and conformation $\\mathbf{x}$ is constructed as $(E, -S, \\mathbf{t}, \\mathbf{x}_{\\text{flat}})$, where $\\mathbf{t}$ is the tuple of integer-encoded residue types and $\\mathbf{x}_{\\text{flat}}$ is the flattened tuple of coordinates. The negation of $S$ correctly transforms the maximization of $S$ into a minimization problem, fitting the lexicographical comparison framework. By iterating through all sequence-conformation pairs and applying this comparison, the algorithm is guaranteed to converge on the unique optimal solution defined by the problem statement.", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef generate_conformations(L):\n    \"\"\"\n    Generates all self-avoiding walks of length L on a 2D square lattice,\n    anchored at (0,0) and (1,0).\n    \"\"\"\n    if L < 2:\n        return []\n\n    # Anchored start as specified\n    path = [(0, 0), (1, 0)]\n    if L == 2:\n        return [tuple(path)]\n    \n    visited = set(path)\n    conformations = []\n    \n    def extend_walk(current_path, visited_sites):\n        if len(current_path) == L:\n            conformations.append(tuple(current_path))\n            return\n            \n        last_x, last_y = current_path[-1]\n        # Possible moves: North, South, East, West\n        moves = [(last_x, last_y + 1), (last_x, last_y - 1), (last_x + 1, last_y), (last_x - 1, last_y)]\n        \n        for next_pos in moves:\n            if next_pos not in visited_sites:\n                current_path.append(next_pos)\n                visited_sites.add(next_pos)\n                extend_walk(current_path, visited_sites)\n                visited_sites.remove(next_pos) # Backtrack\n                current_path.pop()\n\n    extend_walk(path, visited)\n    return conformations\n\ndef find_contacts(conf, L):\n    \"\"\"\n    Finds all non-consecutive nearest-neighbor contacts for a given conformation.\n    \"\"\"\n    contacts = []\n    for i in range(L - 1):\n        for j in range(i + 2, L):\n            xi, yi = conf[i]\n            xj, yj = conf[j]\n            if abs(xi - xj) + abs(yi - yj) == 1:\n                contacts.append((i, j))\n    return contacts\n\ndef make_energy_matrix(e_HH, e_NC, e_like):\n    \"\"\"\n    Creates the 4x4 pairwise energy matrix.\n    Encoding: H=0, P=1, N=2, C=3\n    \"\"\"\n    energy_matrix = np.zeros((4, 4), dtype=float)\n    energy_matrix[0, 0] = e_HH\n    energy_matrix[2, 3] = e_NC\n    energy_matrix[3, 2] = e_NC\n    energy_matrix[2, 2] = e_like\n    energy_matrix[3, 3] = e_like\n    return energy_matrix\n\ndef evaluate(seq, contacts, energy_matrix):\n    \"\"\"\n    Calculates total energy E and salt bridge count S for a sequence and its contacts.\n    \"\"\"\n    E = 0.0\n    S = 0\n    N_type, C_type = 2, 3\n    \n    for i, j in contacts:\n        type1, type2 = seq[i], seq[j]\n        E += energy_matrix[type1, type2]\n        if (type1 == N_type and type2 == C_type) or (type1 == C_type and type2 == N_type):\n            S += 1\n    return E, S\n\ndef find_optimal_structure(L, e_HH, e_NC, e_like):\n    \"\"\"\n    Performs the exhaustive search for the optimal sequence and conformation.\n    \"\"\"\n    energy_matrix = make_energy_matrix(e_HH, e_NC, e_like)\n    \n    all_conformations = generate_conformations(L)\n    \n    best_result_tuple = (float('inf'),)\n    best_solution_details = None\n\n    # Pre-calculate contacts for each conformation\n    conf_contacts = {conf: find_contacts(conf, L) for conf in all_conformations}\n    \n    # Iterate through all sequences and conformations to find the optimum\n    for seq in itertools.product(range(4), repeat=L):\n        seq_tuple = tuple(seq)\n        for conf in all_conformations:\n            contacts = conf_contacts[conf]\n            E, S = evaluate(seq_tuple, contacts, energy_matrix)\n\n            if S < 1:\n                continue\n\n            conf_flat_tuple = tuple(coord for pair in conf for coord in pair)\n            current_result_tuple = (E, -S, seq_tuple, conf_flat_tuple)\n\n            if best_solution_details is None or current_result_tuple < best_result_tuple:\n                best_result_tuple = current_result_tuple\n                best_solution_details = (E, S, seq_tuple, conf)\n    \n    E, S, seq, conf = best_solution_details\n    return E, S, list(seq), [list(c) for c in conf]\n\ndef format_result_list(res_list):\n    \"\"\"\n    Formats the final result list for one test case into the required string format.\n    \"\"\"\n    E, S, seq, coords = res_list\n    E_str = f\"{E:.3f}\"\n    seq_str = str(seq).replace(\" \", \"\")\n    coords_str = str(coords).replace(\" \", \"\")\n    return f\"[{E_str},{S},{seq_str},{coords_str}]\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (L, e_HH, e_NC, e_like)\n        (6, -1.0, -2.0, 0.5),  # Case A\n        (7, 0.0, -2.5, 0.5),  # Case B\n        (6, -0.5, -1.0, 1.0),  # Case C\n    ]\n    \n    results = []\n    for L, e_HH, e_NC, e_like in test_cases:\n        E_min, S_best, seq, coords = find_optimal_structure(L, e_HH, e_NC, e_like)\n        results.append([E_min, S_best, seq, coords])\n    \n    final_output_str_parts = [format_result_list(res) for res in results]\n    final_output = f\"[{','.join(final_output_str_parts)}]\"\n    print(final_output)\n\n# Execute the solver\nsolve()\n```", "id": "2369976"}, {"introduction": "While energy functions define 'what' protein a folding algorithm is searching for—the target low-energy state—the 'how' is determined by the sampling strategy used to explore possible conformations. State-of-the-art predictors like Rosetta use knowledge-based fragment libraries to intelligently navigate the immense conformational landscape, making the search for the native structure tractable. This conceptual exercise challenges you to think critically about this sampling process by considering what happens when the knowledge provided to the algorithm is fundamentally mismatched with the problem it is trying to solve.[@problem_id:2381444]", "problem": "In fragment-based protein structure prediction within the Rosetta framework, short backbone fragments (typically $3$-mers and $9$-mers) drawn from known structures are inserted into an evolving model during a Monte Carlo (MC) search guided by a scoring function. Consider a hypothetical ab initio folding run for a target protein whose native structure is all-$\\beta$. By mistake, the fragment library was constructed exclusively from a nonredundant set of all-$\\alpha$ proteins, so that the fragment $\\phi$ and $\\psi$ torsion angle distributions predominantly occupy the $\\alpha$-helical basin. All other parameters (temperature schedule, move frequencies, and scoring functions in low-resolution and all-atom stages) are standard. Which of the following outcomes is most likely?\n\nA. The search will be strongly biased toward $\\alpha$-helical conformations; it will rarely sample extended $\\beta$-strand geometries necessary for $\\beta$-sheets; as a result, decoys will concentrate in helical topologies with relatively poor all-atom and low-resolution scores compared to the native-like $\\beta$ fold, and the run will show poor convergence to low root-mean-square deviation (RMSD) models.\n\nB. The Rosetta all-atom scoring function contains explicit $\\beta$-sheet hydrogen-bonding terms that will force fragment-inserted helices to unwind and rearrange into $\\beta$-sheets, so the search will still efficiently find the correct fold with similar convergence as with a matched library.\n\nC. Because fragments are short ($3$-mers and $9$-mers), their secondary structure content is irrelevant; given enough Monte Carlo steps, the sampling remains effectively unbiased and the correct $\\beta$ topology will be reached with unaffected efficiency.\n\nD. The move set becomes invalid because $\\phi$ and $\\psi$ torsion angle limits differ between $\\alpha$ and $\\beta$ regions, causing frequent violations that are rejected deterministically; therefore, the Markov chain cannot proceed and the simulation terminates early.", "solution": "The problem statement is critically evaluated and found to be valid. It describes a scientifically plausible scenario in computational protein structure prediction that is well-posed, objective, and self-contained. The question concerns the predictable outcome of using a conformationally biased move set in a Monte Carlo search, which is a standard topic in the field.\n\nThe problem describes an *ab initio* protein folding simulation using the Rosetta framework. In this method, the conformational space is explored using a Monte Carlo (MC) search. A key move type is the insertion of backbone torsion angle fragments, typically of length $3$ and $9$ residues ($3$-mers and $9$-mers), extracted from a library of known protein structures. The acceptance of a move is governed by a scoring function and the Metropolis criterion.\n\nThe core of the problem lies in the conflict between two components of the simulation:\n1.  **The Sampling Bias:** The fragment library is constructed exclusively from all-$\\alpha$ proteins. This means that the torsion angles ($\\phi$, $\\psi$) of the available fragments will be predominantly in the $\\alpha$-helical region of the Ramachandran plot (approximately $\\phi \\approx -60^\\circ$, $\\psi \\approx -40^\\circ$). The primary method for making significant changes to the backbone conformation is therefore heavily biased to produce and maintain $\\alpha$-helical secondary structures.\n2.  **The Target Structure:** The native structure of the target protein is all-$\\beta$. This means its constituent residues should adopt torsion angles in the $\\beta$-strand region of the Ramachandran plot (approximately $\\phi \\approx -120^\\circ$, $\\psi \\approx +135^\\circ$). The global minimum of the energy landscape, as defined by the Rosetta scoring function for this protein, corresponds to this all-$\\beta$ fold.\n\nThe simulation's outcome is determined by the interplay of this biased sampling and the energy landscape. The MC search will proceed as follows:\n- The fragment insertion moves will consistently propose local conformations with $\\alpha$-helical character. This will very effectively sample helical topologies.\n- The search will be unable to efficiently sample extended $\\beta$-strand conformations because the required $(\\phi, \\psi)$ angles are systematically absent from the move set provided by the fragment library. While other small-perturbation moves (`small` and `shear`) exist, they are insufficient to transition from a compact helical globule to an extended $\\beta$-sheet topology on a realistic simulation timescale.\n- The generated conformations (\"decoys\") will therefore be predominantly helical.\n- The Rosetta scoring function (both low-resolution and all-atom) is designed to recognize the energetic favorability of a native fold. For an all-$\\beta$ protein, the scoring function will correctly assign a much lower (better) energy to the native $\\beta$-sheet topology than to any non-native helical arrangement. The sampled helical decoys will lack the specific long-range hydrogen bonding network and tertiary packing that stabilize the native $\\beta$-sheet, resulting in high (poor) scores.\n- The simulation will fail to converge. An energy-versus-RMSD plot would not show the characteristic funnel shape where the lowest-energy structures have low root-mean-square deviation (RMSD) from the native state. Instead, the lowest-energy structures found by the search will be non-native helical compact states with high RMSD.\n\nWith this understanding, we evaluate the given options:\n\n**A. The search will be strongly biased toward $\\alpha$-helical conformations; it will rarely sample extended $\\beta$-strand geometries necessary for $\\beta$-sheets; as a result, decoys will concentrate in helical topologies with relatively poor all-atom and low-resolution scores compared to the native-like $\\beta$ fold, and the run will show poor convergence to low root-mean-square deviation (RMSD) models.**\nThis statement is a precise and accurate description of the expected outcome. The sampling is biased by the fragment library, preventing access to the correct region of conformational space. The resulting decoys are non-native and thus have poor scores. The overall prediction fails, as indicated by the lack of convergence to low-RMSD structures.\n**Verdict: Correct.**\n\n**B. The Rosetta all-atom scoring function contains explicit $\\beta$-sheet hydrogen-bonding terms that will force fragment-inserted helices to unwind and rearrange into $\\beta$-sheets, so the search will still efficiently find the correct fold with similar convergence as with a matched library.**\nThis statement is incorrect. The scoring function evaluates conformations; it does not \"force\" rearrangements across large kinetic barriers. The simulation explores conformational space via a path defined by the available moves. If the moves do not lead toward the correct fold, the scoring function alone cannot compensate. The low-resolution search will produce poor starting models for the all-atom stage, and all-atom refinement uses local perturbations, which are incapable of converting an entire protein's topology from all-$\\alpha$ to all-$\\beta$. The claim of \"efficiently\" finding the correct fold with \"similar convergence\" is false.\n**Verdict: Incorrect.**\n\n**C. Because fragments are short ($3$-mers and $9$-mers), their secondary structure content is irrelevant; given enough Monte Carlo steps, the sampling remains effectively unbiased and the correct $\\beta$ topology will be reached with unaffected efficiency.**\nThis statement is fundamentally flawed. The local secondary structure information encoded in fragments is the very reason for their use. It dramatically accelerates the search for nativelike local conformations. Claiming their content is \"irrelevant\" is contrary to the entire principle of fragment-based assembly. While theoretically an infinitely long MC run could sample any state, in practice, the strong bias makes the probability of sampling the correct fold vanishingly small within any feasible simulation time. The sampling is not \"effectively unbiased\"; it is severely biased, and the efficiency will be drastically reduced to the point of complete failure.\n**Verdict: Incorrect.**\n\n**D. The move set becomes invalid because $\\phi$ and $\\psi$ torsion angle limits differ between $\\alpha$ and $\\beta$ regions, causing frequent violations that are rejected deterministically; therefore, the Markov chain cannot proceed and the simulation terminates early.**\nThis statement misunderstands the Rosetta algorithm. There are no hard \"invalid\" limits on torsion angles that would cause deterministic rejection and simulation termination. A proposed move resulting in unfavorable torsion angles (e.g., in a disallowed region of the Ramachandran plot) receives a high energy penalty from the corresponding score term (e.g., `rama`). This makes the move's acceptance highly improbable under the Metropolis criterion, but it is a probabilistic, not deterministic, process. The Markov chain proceeds, but it is trapped in an unproductive region of the conformational space. The simulation does not terminate.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "2381444"}, {"introduction": "Having explored a simplified 2D lattice and the logic of advanced samplers, we now tackle the challenge of conformational search in a more realistic three-dimensional, off-lattice model. In this high-dimensional space, an exhaustive search is impossible, forcing us to use intelligent metaheuristics. This practice guides you through implementing Ant Colony Optimization (ACO), a powerful algorithm inspired by nature, to navigate a complex energy landscape, providing hands-on experience with a sophisticated, memory-based method for finding low-energy protein structures.[@problem_id:2369960]", "problem": "You are given a coarse-grained internal-coordinate model of a polypeptide backbone in three dimensions. Consider a chain of $N$ alpha carbon atoms connected by fixed bond length $b$ and fixed bond angle $\\theta$. The internal degrees of freedom are the backbone dihedral angles $\\{\\phi_i\\}$ for $i \\in \\{3,4,\\dots,N-1\\}$, one dihedral per newly added atom beyond the third. The chain is constructed as follows. Place the first three atoms at\n$p_0 = (0,0,0)$, $p_1 = (b,0,0)$, $p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$. For $i \\ge 3$, given $p_{i-3}, p_{i-2}, p_{i-1}$ and a dihedral angle $\\phi_i \\in [-\\pi,\\pi)$, define unit vectors $u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}$ and $v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$, the normal $n = \\frac{v \\times u}{\\|v \\times u\\|}$, and $m = u \\times n$. Then place\n$$\np_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right).\n$$\n\nDefine the total energy in reduced units for a conformation specified by dihedrals $\\Phi = (\\phi_3,\\dots,\\phi_{N-1})$ as\n$$\nE(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi),\n$$\nwhere the torsional term is\n$$\nE_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right),\n$$\nand the nonbonded term is a Lennard–Jones potential between non-adjacent atoms\n$$\nE_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right],\n$$\nwith $r_{ij} = \\|p_i - p_j\\|$. Use lengths in ångströms (Å), angles in radians, and energies in the same reduced units as $\\varepsilon$.\n\nConsider a discrete memory-based probabilistic constructive process over dihedral angles. For each dihedral index $k \\in \\{3,4,\\dots,N-1\\}$, discretize the domain $[-\\pi,\\pi)$ into $B$ equal-width bins with centers $\\{\\varphi_{k,b}\\}_{b=1}^B$. Maintain a nonnegative memory matrix (the “pheromone” memory) $T \\in \\mathbb{R}_{\\ge 0}^{(N-3)\\times B}$ with entries $T_{k,b}$, initialized uniformly to $T_{k,b} = \\tau_0$. Define a heuristic weight for each bin by\n$$\n\\eta_{k,b} = \\exp\\left(-\\frac{k_t\\left(1 + \\cos(3\\varphi_{k,b})\\right)}{T_h}\\right),\n$$\nwith temperature $T_h > 0$. For parameters $\\alpha > 0$ and $\\beta \\ge 0$, define the probability of choosing bin $b$ at dihedral index $k$ as\n$$\n\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k,b}^{\\alpha}\\,\\eta_{k,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k,b'}^{\\alpha}\\,\\eta_{k,b'}^{\\beta}}.\n$$\nAn iteration consists of generating $M$ complete angle sequences $\\Phi$ by independent sampling of one bin per dihedral according to the product distribution across indices $k$, evaluating $E(\\Phi)$ for each, selecting the single lowest-energy sample in the iteration with energy $E^\\star$, then updating the memory with evaporation rate $\\rho \\in (0,1)$ and a rank-$1$ deposition at the selected bins $\\{b_k^\\star\\}$:\n$$\nT_{k,b} \\leftarrow (1-\\rho) T_{k,b} \\quad \\text{for all } k,b,\n$$\n$$\nT_{k,b_k^\\star} \\leftarrow T_{k,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right) \\quad \\text{for all } k,\n$$\nfollowed by clamping $T_{k,b} \\leftarrow \\min\\{\\tau_{\\max}, \\max\\{\\tau_{\\min}, T_{k,b}\\}\\}$ with $\\tau_{\\min} > 0$ and $\\tau_{\\max} > \\tau_{\\min}$. Repeat for $I$ iterations, and return the lowest energy encountered across all samples and iterations.\n\nUse the following fixed physical and energetic constants for all runs:\n- Bond length $b = 3.8$ Å.\n- Bond angle $\\theta = 111.5^\\circ$ (use radians in computation; $\\theta \\approx 1.946$).\n- Lennard–Jones parameters $\\varepsilon = 0.1$ and $\\sigma = 4.0$ (in Å).\n- Torsional stiffness $k_t = 0.1$.\n- Heuristic temperature $T_h = 1.0$.\n- Deposition strength $Q = 1.0$ and deposition temperature $T_d = 1.0$.\n- Pheromone initialization $\\tau_0 = 1.0$, floor $\\tau_{\\min} = 10^{-6}$, and cap $\\tau_{\\max} = 100.0$.\n\nYour task is to implement the process above and execute it on the following test suite. For each test case, use an independent pseudorandom generator initialized with the given seed, and report the best (lowest) energy $E$ found. Express each answer as a floating-point number rounded to three decimal places.\n\nTest suite (angles in radians, lengths in Å, energies in the units of $\\varepsilon$):\n- Case A (general): $N = 8$, $M = 25$, $I = 40$, $B = 36$, $\\alpha = 1.0$, $\\beta = 2.0$, $\\rho = 0.1$, random seed $s = 1234$.\n- Case B (boundary length): $N = 4$, $M = 16$, $I = 25$, $B = 24$, $\\alpha = 1.0$, $\\beta = 1.0$, $\\rho = 0.3$, random seed $s = 202$.\n- Case C (different balance): $N = 10$, $M = 20$, $I = 30$, $B = 24$, $\\alpha = 1.5$, $\\beta = 1.0$, $\\rho = 0.2$, random seed $s = 999$.\n\nFinal output format: Your program should produce a single line of output containing the results for Cases A, B, and C as a comma-separated list enclosed in square brackets, for example, `[x_A,x_B,x_C]`. Each $x$ must be the rounded floating-point value as specified above, with no additional text.", "solution": "The problem statement is subjected to validation and is found to be valid. It is a well-posed problem in computational structural biology, specifically *ab initio* protein structure prediction using a coarse-grained model. All physical parameters, mathematical formulae, and algorithmic definitions are provided, are scientifically sound, and are internally consistent. The problem is a standard energy minimization task, for which the specified metaheuristic, a variant of Ant Colony Optimization (ACO), is a suitable approach. The library `scipy` is not required, as all necessary functionality is provided by `numpy`.\n\nThe solution is implemented by following the specified procedure. The core of the problem is to find the set of dihedral angles $\\Phi = (\\phi_3, \\dots, \\phi_{N-1})$ that minimizes a total energy function $E(\\Phi)$.\n\n**1. Chain Geometry Construction**\n\nThe three-dimensional coordinates of the $N$ atoms, denoted $\\{p_i\\}_{i=0}^{N-1}$, are generated sequentially. The first three atoms, $p_0$, $p_1$, and $p_2$, establish an initial reference frame in the $xy$-plane:\n$$p_0 = (0,0,0)$$\n$$p_1 = (b,0,0)$$\n$$p_2 = (b + b\\cos\\theta, b\\sin\\theta, 0)$$\nHere, $b$ is the fixed bond length and $\\theta$ is the fixed bond angle. For each subsequent atom $p_i$ ($i \\ge 3$), its position is determined by the positions of the preceding three atoms ($p_{i-3}, p_{i-2}, p_{i-1}$) and a single internal degree of freedom, the dihedral angle $\\phi_i$.\n\nThe construction of $p_i$ is based on defining a local coordinate system. Let $u$ be the unit vector along the bond $p_{i-2} \\to p_{i-1}$, and $v$ be the unit vector along the bond $p_{i-3} \\to p_{i-2}$.\n$$u = \\frac{p_{i-1}-p_{i-2}}{\\|p_{i-1}-p_{i-2}\\|}, \\quad v = \\frac{p_{i-2}-p_{i-3}}{\\|p_{i-2}-p_{i-3}\\|}$$\nA normal vector $n$ to the plane containing these two bonds is given by their cross product, $n = \\text{normalize}(v \\times u)$. A third vector, $m = u \\times n$, completes a right-handed orthonormal basis $\\{u, m, n\\}$. The position of the new atom $p_i$ is then placed relative to $p_{i-1}$ such that the new bond vector $p_i - p_{i-1}$ has length $b$, makes an angle of $\\pi-\\theta$ with vector $p_{i-1}-p_{i-2}$ (thus maintaining the bond angle $\\theta$), and its projection onto the plane perpendicular to $u$ is rotated by the dihedral angle $\\phi_i$. This is captured by the given formula:\n$$p_i = p_{i-1} + b\\left( \\cos\\theta\\,(-u) + \\sin\\theta\\left(\\cos\\phi_i\\, m + \\sin\\phi_i\\, n\\right)\\right)$$\nThis geometric construction is a standard method in molecular modeling, often referred to as a Natural Extension Reference Frame (NeRF) or similar internal coordinate building algorithm.\n\n**2. Energy Function**\n\nThe potential energy of a given conformation, specified by the set of dihedrals $\\Phi$, is the sum of two terms: a torsional term and a non-bonded interaction term.\n$$E(\\Phi) = E_{\\text{tors}}(\\Phi) + E_{\\text{nb}}(\\Phi)$$\nThe torsional energy, $E_{\\text{tors}}$, accounts for the energetic barrier to rotation around the backbone bonds:\n$$E_{\\text{tors}}(\\Phi) = k_t \\sum_{i=3}^{N-1} \\left(1 + \\cos(3\\phi_i)\\right)$$\nThe term $k_t$ represents the stiffness of the torsional spring. The $3\\phi_i$ dependence models the three-fold rotational symmetry common in alkane-like chains.\n\nThe non-bonded energy, $E_{\\text{nb}}$, models the van der Waals interactions between atoms that are not close neighbors in the chain. It is calculated using the Lennard-Jones $12-6$ potential:\n$$E_{\\text{nb}}(\\Phi) = \\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ j - i > 2}} 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r_{ij}}\\right)^{12} - \\left(\\frac{\\sigma}{r_{ij}}\\right)^{6}\\right]$$\nHere, $r_{ij}$ is the Euclidean distance between atoms $p_i$ and $p_j$. The parameters $\\varepsilon$ and $\\sigma$ define the depth and position of the potential well, respectively. The condition $j-i > 2$ correctly excludes bonded neighbors ($1,2$ pairs like $i, i+1$) and bond-angle neighbors ($1,3$ pairs like $i, i+2$), whose interactions are implicitly handled by the fixed bond length and angle constraints.\n\n**3. Ant Colony Optimization (ACO) Algorithm**\n\nThe high-dimensional and non-convex nature of the energy landscape makes finding the global minimum a non-trivial task. The problem specifies a stochastic optimization algorithm based on the ACO metaheuristic.\n\nFirst, the continuous domain $[-\\pi, \\pi)$ for each dihedral angle is discretized into $B$ bins. The search for the optimal conformation is then transformed into a search for the best sequence of bins.\n\nThe algorithm proceeds for $I$ iterations. In each iteration, $M$ candidate solutions (ants) are constructed. Each ant builds a complete sequence of dihedral angles, $\\Phi$, by making a probabilistic choice for each dihedral $\\phi_k$ ($k=3, \\dots, N-1$). The probability of choosing bin $b$ for dihedral $k$ is a function of two components:\n-   **Pheromone trail ($\\tau$)**: A memory matrix $T$ stores the \"desirability\" of choosing each bin for each dihedral, based on past successful solutions. The entry $T_{k,b}$ corresponds to the pheromone level for bin $b$ of dihedral $k$.\n-   **Heuristic information ($\\eta$)**: This term provides *a priori* knowledge about the quality of a choice, independent of the search history. Here, it is based on the local torsional energy of a dihedral angle: $\\eta_{k,b} = \\exp\\left(-\\frac{E_{\\text{tors}}(\\varphi_{k,b})}{T_h}\\right)$. Lower energy choices have higher heuristic value.\n\nThe probability of choosing bin $b$ for the $k$-th dihedral (corresponding to matrix row $k-3$) is given by:\n$$\\mathbb{P}(\\text{choose } b \\mid k) = \\frac{T_{k-3,b}^{\\alpha}\\,\\eta_{k-3,b}^{\\beta}}{\\sum_{b'=1}^{B} T_{k-3,b'}^{\\alpha}\\,\\eta_{k-3,b'}^{\\beta}}$$\nThe parameters $\\alpha$ and $\\beta$ control the relative influence of the pheromone trail versus the heuristic information.\n\nAfter $M$ solutions are constructed and their energies evaluated, the single best solution of the iteration, with energy $E^\\star$, is used to update the pheromone matrix. The update has two phases:\n1.  **Evaporation**: All pheromone trails are uniformly decreased by a factor of $(1-\\rho)$, where $\\rho \\in (0,1)$ is the evaporation rate. This prevents premature convergence.\n$$T_{k,b} \\leftarrow (1-\\rho) T_{k,b}$$\n2.  **Deposition**: The trails corresponding to the choices made in the iteration's best solution $\\{b_k^\\star\\}$ are reinforced. The amount of deposited pheromone is inversely related to the energy $E^\\star$.\n$$T_{k-3,b_k^\\star} \\leftarrow T_{k-3,b_k^\\star} + Q\\exp\\left(-\\frac{E^\\star}{T_d}\\right)$$\nFinally, the pheromone values are clamped between $\\tau_{\\min}$ and $\\tau_{\\max}$ to ensure stability. This entire process guides the search towards promising regions of the conformational space over successive iterations. The lowest energy found across all ants and all iterations is reported as the final result.\n\n**4. Implementation Strategy**\n\nThe described algorithm is implemented in Python using the `numpy` library for efficient numerical and vector operations. A primary function orchestrates the simulation for a given set of parameters $(N, M, I, B, \\alpha, \\beta, \\rho, s)$.\n-   A helper function `build_chain` takes a sequence of dihedral angles and generates the atomic coordinates $\\{p_i\\}$ according to the geometric construction rules.\n-   A second helper function `calculate_energy` takes the atomic coordinates and dihedral angles to compute the total energy $E(\\Phi)$. `numpy`'s vectorized operations are used to accelerate sums and potential calculations.\n-   The main ACO loop manages the state, including the pheromone matrix $T$ and the globally best-found energy. It uses a `numpy.random.Generator` instance, seeded for reproducibility, to perform the probabilistic sampling of dihedral bins.\nThe code is structured to first define all constants, then the helper functions, and finally the main simulation driver which is called for each test case as specified.", "answer": "```python\nimport numpy as np\n\n# Fixed physical and energetic constants\nBOND_LENGTH = 3.8  # b in Å\nBOND_ANGLE_DEG = 111.5\nBOND_ANGLE_RAD = np.deg2rad(BOND_ANGLE_DEG)  # theta in radians\nEPSILON = 0.1      # ε\nSIGMA = 4.0        # σ in Å\nKT = 0.1           # k_t\nT_H = 1.0          # T_h (Heuristic temperature)\nQ = 1.0            # Deposition strength\nT_D = 1.0          # Deposition temperature\nTAU_0 = 1.0        # Pheromone initialization\nTAU_MIN = 1e-6     # Pheromone floor\nTAU_MAX = 100.0    # Pheromone cap\n\ndef build_chain(dihedrals, N, b, theta):\n    \"\"\"Constructs the atomic coordinates for a given chain length and dihedrals.\"\"\"\n    if N == 0:\n        return np.array([])\n    \n    positions = np.zeros((N, 3))\n    if N > 1:\n        positions[1] = np.array([b, 0.0, 0.0])\n    if N > 2:\n        positions[2] = np.array([\n            b + b * np.cos(theta),\n            b * np.sin(theta),\n            0.0\n        ])\n\n    for i in range(3, N):\n        p_im1, p_im2, p_im3 = positions[i-1], positions[i-2], positions[i-3]\n        \n        # Define local frame vectors\n        u_vec = p_im1 - p_im2\n        u = u_vec / np.linalg.norm(u_vec)\n        \n        v_vec = p_im2 - p_im3\n        v = v_vec / np.linalg.norm(v_vec)\n        \n        cross_vu = np.cross(v, u)\n        n = cross_vu / np.linalg.norm(cross_vu)\n        \n        m = np.cross(u, n)\n        \n        phi_i = dihedrals[i - 3]\n        cos_phi = np.cos(phi_i)\n        sin_phi = np.sin(phi_i)\n\n        # Construct new atom position using the provided formula\n        new_bond_vector = -np.cos(theta) * u + np.sin(theta) * (cos_phi * m + sin_phi * n)\n        positions[i] = p_im1 + b * new_bond_vector\n        \n    return positions\n\ndef calculate_energy(positions, dihedrals, N, kt, eps, sigma):\n    \"\"\"Calculates the total energy of a conformation.\"\"\"\n    \n    # 1. Torsional energy\n    if dihedrals:\n        cos3_phi = np.cos(3 * np.array(dihedrals))\n        e_tors = kt * np.sum(1 + cos3_phi)\n    else:\n        e_tors = 0.0\n\n    # 2. Non-bonded Lennard-Jones energy\n    e_nb = 0.0\n    for i in range(N):\n        for j in range(i + 3, N):  # Condition j - i > 2\n            dist_sq = np.sum((positions[i] - positions[j])**2)\n            dist = np.sqrt(dist_sq)\n            \n            if dist > 0:\n                sigma_over_r = sigma / dist\n                sigma_over_r6 = sigma_over_r**6\n                sigma_over_r12 = sigma_over_r6**2\n                e_nb += 4 * eps * (sigma_over_r12 - sigma_over_r6)\n    \n    return e_tors + e_nb\n\ndef run_simulation(N, M, I, B, alpha, beta, rho, seed):\n    \"\"\"Runs the full ACO simulation for one test case.\"\"\"\n    \n    rng = np.random.default_rng(seed)\n    num_dihedrals = N - 3\n\n    if num_dihedrals <= 0:\n        # Fixed geometry, only possible LJ energy. \n        # For N<=3, no pair satisfies j-i>2, so energy is 0.\n        return 0.0\n    \n    # Discretize dihedral space\n    bin_width = 2 * np.pi / B\n    dihedral_bins = np.linspace(-np.pi + bin_width / 2, np.pi - bin_width / 2, B)\n\n    # Initialize pheromone matrix T\n    pheromone = np.full((num_dihedrals, B), TAU_0)\n    \n    # Pre-calculate heuristic matrix eta\n    torsional_heuristic_term = KT * (1 + np.cos(3 * dihedral_bins))\n    heuristic = np.exp(-torsional_heuristic_term / T_H)\n    \n    best_energy_global = float('inf')\n\n    for iteration in range(I):\n        iteration_samples = []\n        \n        # M ants construct solutions\n        for _ in range(M):\n            chosen_dihedrals = []\n            chosen_bin_indices = []\n            \n            for k in range(num_dihedrals):\n                probs = (pheromone[k] ** alpha) * (heuristic ** beta)\n                if np.sum(probs) > 0:\n                    probs /= np.sum(probs)\n                else: # Fallback to uniform if all probabilities are zero\n                    probs = np.ones(B) / B\n\n                chosen_bin_idx = rng.choice(B, p=probs)\n                chosen_bin_indices.append(chosen_bin_idx)\n                chosen_dihedrals.append(dihedral_bins[chosen_bin_idx])\n\n            # Evaluate the constructed conformation\n            positions = build_chain(chosen_dihedrals, N, BOND_LENGTH, BOND_ANGLE_RAD)\n            energy = calculate_energy(positions, chosen_dihedrals, N, KT, EPSILON, SIGMA)\n            \n            iteration_samples.append({'dihedrals': chosen_dihedrals, 'bins': chosen_bin_indices, 'energy': energy})\n\n        # Find best ant of the iteration\n        best_sample = min(iteration_samples, key=lambda x: x['energy'])\n        e_star = best_sample['energy']\n        \n        # Update global best energy\n        if e_star < best_energy_global:\n            best_energy_global = e_star\n\n        # Update pheromone trails\n        # 1. Evaporation\n        pheromone *= (1 - rho)\n\n        # 2. Deposition\n        deposition_amount = Q * np.exp(-e_star / T_D)\n        best_bins = best_sample['bins']\n        for k in range(num_dihedrals):\n            pheromone[k, best_bins[k]] += deposition_amount\n\n        # 3. Clamping\n        np.clip(pheromone, TAU_MIN, TAU_MAX, out=pheromone)\n\n    return best_energy_global\n\ndef solve():\n    \"\"\"Main solver function to run test cases.\"\"\"\n    \n    test_cases = [\n        # Case A: (N, M, I, B, alpha, beta, rho, seed)\n        (8, 25, 40, 36, 1.0, 2.0, 0.1, 1234),\n        # Case B\n        (4, 16, 25, 24, 1.0, 1.0, 0.3, 202),\n        # Case C\n        (10, 20, 30, 24, 1.5, 1.0, 0.2, 999),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, I, B, alpha, beta, rho, seed = case\n        best_energy = run_simulation(N, M, I, B, alpha, beta, rho, seed)\n        results.append(f\"{best_energy:.3f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2369960"}]}