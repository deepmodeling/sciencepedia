{"hands_on_practices": [{"introduction": "When a flexible ligand binds to a protein, it often adopts a conformation that is not its lowest-energy state in solution. This induced internal strain represents an energetic penalty that must be accounted for in any accurate scoring protocol. This exercise [@problem_id:2422877] delves into a classical molecular mechanics force field by guiding you through the calculation of strain energy, $E_{\\mathrm{strain}}$, from its fundamental components: bond stretches, angle bends, and torsional rotations. By implementing this calculation, you will gain a tangible understanding of how a ligand's geometry translates into an energy value, a critical component of virtually all modern docking scoring functions.", "problem": "You are tasked with writing a complete program that computes a docking score with an explicit conformational strain penalty for a ligand in a bound pose. The total score for a given bound pose is defined as the sum of a provided base score and a penalty proportional to the internal strain energy of the ligand. Let the total score be denoted by $S_{\\mathrm{total}}$, the provided base score by $S_{\\mathrm{base}}$ (in kilocalories per mole), and the nonnegative weighting factor by $\\lambda$ (dimensionless). The strain energy is defined by a classical molecular mechanics model as the sum of bond stretching, angle bending, and torsional rotation contributions. The total score is given by\n$$\nS_{\\mathrm{total}} \\;=\\; S_{\\mathrm{base}} + \\lambda \\, E_{\\mathrm{strain}},\n$$\nwhere\n$$\nE_{\\mathrm{strain}} \\;=\\; \\sum_{\\text{bonds } i} \\frac{1}{2} \\, k_{b,i} \\, \\bigl(r_i - r_{0,i}\\bigr)^2 \\;+\\; \\sum_{\\text{angles } j} \\frac{1}{2} \\, k_{\\theta,j} \\, \\bigl(\\theta_j - \\theta_{0,j}\\bigr)^2 \\;+\\; \\sum_{\\text{torsions } k} k_{\\tau,k}\\,\\bigl(1 - \\cos\\left(n_k \\, (\\phi_k - \\phi_{0,k})\\right)\\bigr).\n$$\nHere, $k_{b,i}$ are bond force constants with units of kilocalories per mole per square angstrom, $r_i$ are bond lengths in angstroms, and $r_{0,i}$ are corresponding reference bond lengths in angstroms. The $k_{\\theta,j}$ are angle force constants with units of kilocalories per mole per radian squared, $\\theta_j$ are bond angles in radians, and $\\theta_{0,j}$ are corresponding reference angles in radians. The $k_{\\tau,k}$ are torsional force constants with units of kilocalories per mole, $n_k$ are positive integers denoting torsional periodicities, $\\phi_k$ are dihedral angles in radians, and $\\phi_{0,k}$ are corresponding reference dihedral angles in radians. All energy contributions are expressed in kilocalories per mole. All input angles for this problem are specified in degrees and must be interpreted as degrees; the trigonometric function $\\cos(\\cdot)$ uses radians, and all angle differences must be converted to radians before evaluating energies. The output total scores must be reported in kilocalories per mole.\n\nYour program must evaluate the following test suite. Each test case provides $S_{\\mathrm{base}}$, $\\lambda$, and three lists: bonds, angles, and torsions. Bonds are provided as triples $(k_b, r, r_0)$; angles are provided as triples $(k_\\theta, \\theta_{\\mathrm{deg}}, \\theta_{0,\\mathrm{deg}})$; torsions are provided as quadruples $(k_\\tau, n, \\phi_{\\mathrm{deg}}, \\phi_{0,\\mathrm{deg}})$. All distances $r$ and $r_0$ are in angstroms, all provided angles are in degrees, and all force constants are in the units stated in the energy definition above.\n\nUse the following test cases (each line is one test case):\n\n- Test case $1$:\n  - $S_{\\mathrm{base}} = -7.5$, $\\lambda = 0.25$\n  - Bonds: $(300.0, 1.54, 1.52)$, $(200.0, 1.34, 1.34)$\n  - Angles: $(60.0, 112.0, 109.5)$\n  - Torsions: $(0.5, 3, 60.0, 60.0)$, $(0.8, 3, 140.0, 60.0)$\n- Test case $2$:\n  - $S_{\\mathrm{base}} = -3.2$, $\\lambda = 1.0$\n  - Bonds: $(250.0, 1.50, 1.50)$\n  - Angles: $(50.0, 120.0, 120.0)$\n  - Torsions: $(1.2, 1, 180.0, 180.0)$\n- Test case $3$:\n  - $S_{\\mathrm{base}} = -10.0$, $\\lambda = 0.5$\n  - Bonds: $(250.0, 1.58, 1.50)$, $(350.0, 1.40, 1.34)$\n  - Angles: $(50.0, 130.0, 120.0)$, $(70.0, 100.0, 109.5)$\n  - Torsions: $(1.5, 2, 90.0, 0.0)$, $(0.3, 1, -180.0, 180.0)$\n- Test case $4$:\n  - $S_{\\mathrm{base}} = -1.0$, $\\lambda = 0.0$\n  - Bonds: $(300.0, 1.60, 1.50)$\n  - Angles: $(80.0, 140.0, 120.0)$\n  - Torsions: $(2.0, 3, 90.0, 60.0)$\n- Test case $5$:\n  - $S_{\\mathrm{base}} = 0.0$, $\\lambda = 2.0$\n  - Bonds: no entries\n  - Angles: no entries\n  - Torsions: no entries\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each score rounded to six decimal places, for example, $[x_1,x_2,x_3,x_4,x_5]$. The values must be in kilocalories per mole and must be rounded to six decimal places. Angles in the input are in degrees and must be interpreted as degrees; where needed, convert to radians for use in the formulas. No user input is required; the program must run as is and output the scores for the test cases above.", "solution": "The task is to compute the total docking score, $S_{\\mathrm{total}}$, for a series of ligand poses. The score is defined by the equation:\n$$\nS_{\\mathrm{total}} = S_{\\mathrm{base}} + \\lambda E_{\\mathrm{strain}}\n$$\nwhere $S_{\\mathrm{base}}$ is a given base score, $\\lambda$ is a dimensionless weighting factor, and $E_{\\mathrm{strain}}$ is the internal conformational strain energy of the ligand. The problem provides all necessary parameters for five distinct test cases. The calculation proceeds by first determining $E_{\\mathrm{strain}}$ and then substituting it into the equation for $S_{\\mathrm{total}}$.\n\nThe strain energy $E_{\\mathrm{strain}}$ is modeled using a classical molecular mechanics potential energy function, which is a sum of three contributions: bond stretching, angle bending, and torsional rotation.\n$$\nE_{\\mathrm{strain}} = E_{\\mathrm{bond}} + E_{\\mathrm{angle}} + E_{\\mathrm{torsion}}\n$$\nWe will now detail the calculation of each component.\n\nThe bond stretching energy, $E_{\\mathrm{bond}}$, is calculated by summing the contributions from all specified bonds. Each contribution is modeled as a harmonic potential, penalizing deviations from a reference bond length $r_{0,i}$. The formula is:\n$$\nE_{\\mathrm{bond}} = \\sum_{\\text{bonds } i} \\frac{1}{2} k_{b,i} (r_i - r_{0,i})^2\n$$\nHere, $k_{b,i}$ is the bond force constant in units of kcal/mol/Å², $r_i$ is the measured bond length in angstroms (Å), and $r_{0,i}$ is the reference bond length in Å. The calculation for each test case involves iterating through the provided list of bonds and accumulating the energy for each.\n\nThe angle bending energy, $E_{\\mathrm{angle}}$, is similarly calculated by summing harmonic potential terms for all specified angles. This term penalizes deviations of bond angles from their reference values $\\theta_{0,j}$.\n$$\nE_{\\mathrm{angle}} = \\sum_{\\text{angles } j} \\frac{1}{2} k_{\\theta,j} (\\theta_j - \\theta_{0,j})^2\n$$\nA critical detail for this calculation is the handling of units. The force constant $k_{\\theta,j}$ is given in kcal/mol/rad², which requires the angle difference $(\\theta_j - \\theta_{0,j})$ to be in radians (rad). The input angles, however, are provided in degrees. Therefore, a conversion is mandatory:\n$$\n\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}} \\times \\frac{\\pi}{180}\n$$\nThe algorithm must convert both $\\theta_j$ and $\\theta_{0,j}$ from degrees to radians before calculating their difference and the corresponding energy contribution.\n\nThe torsional, or dihedral, energy, $E_{\\mathrm{torsion}}$, is described by a periodic cosine function, which models the energetic barrier to rotation around a chemical bond.\n$$\nE_{\\mathrm{torsion}} = \\sum_{\\text{torsions } k} k_{\\tau,k} \\bigl(1 - \\cos\\left(n_k (\\phi_k - \\phi_{0,k})\\right)\\bigr)\n$$\nHere, $k_{\\tau,k}$ is the torsional force constant in kcal/mol, $n_k$ is the periodicity, and $\\phi_k$ and $\\phi_{0,k}$ are the measured and reference dihedral angles, respectively. As with the angle bending term, the trigonometric function $\\cos(\\cdot)$ operates on radians. The input dihedral angles are in degrees and must be converted to radians before their difference is taken and used in the argument of the cosine function.\n\nThe overall algorithm is as follows:\n$1$. For each test case, retrieve the parameters: $S_{\\mathrm{base}}$, $\\lambda$, and the lists of bond, angle, and torsion parameters.\n$2$. Initialize the total strain energy, $E_{\\mathrm{strain}}$, to $0$.\n$3$. Loop through the list of bonds. For each bond, calculate its energy using the bond stretching formula and add it to $E_{\\mathrm{strain}}$.\n$4$. Loop through the list of angles. For each angle, convert the degree values to radians, calculate the energy using the angle bending formula, and add it to $E_{\\mathrm{strain}}$.\n$5$. Loop through the list of torsions. For each torsion, convert the degree values to radians, calculate the energy using the torsional rotation formula, and add it to $E_{\\mathrm{strain}}$.\n$6$. With the total $E_{\\mathrm{strain}}$ computed, calculate the final score $S_{\\mathrm{total}} = S_{\\mathrm{base}} + \\lambda E_{\\mathrm{strain}}$.\n$7$. The computed score is then rounded to six decimal places as required. This process is repeated for all test cases. The final output is a single line containing a comma-separated list of these scores enclosed in square brackets. For cases where $\\lambda=0$, the calculation of $E_{\\mathrm{strain}}$ is technically unnecessary as its contribution to $S_{\\mathrm{total}}$ is zero, but a robust implementation will compute it regardless. For cases with no geometric terms (empty lists), $E_{\\mathrm{strain}}$ is trivially $0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ligand docking score problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"S_base\": -7.5, \"lambda\": 0.25,\n            \"bonds\": [(300.0, 1.54, 1.52), (200.0, 1.34, 1.34)],\n            \"angles\": [(60.0, 112.0, 109.5)],\n            \"torsions\": [(0.5, 3, 60.0, 60.0), (0.8, 3, 140.0, 60.0)]\n        },\n        # Test case 2\n        {\n            \"S_base\": -3.2, \"lambda\": 1.0,\n            \"bonds\": [(250.0, 1.50, 1.50)],\n            \"angles\": [(50.0, 120.0, 120.0)],\n            \"torsions\": [(1.2, 1, 180.0, 180.0)]\n        },\n        # Test case 3\n        {\n            \"S_base\": -10.0, \"lambda\": 0.5,\n            \"bonds\": [(250.0, 1.58, 1.50), (350.0, 1.40, 1.34)],\n            \"angles\": [(50.0, 130.0, 120.0), (70.0, 100.0, 109.5)],\n            \"torsions\": [(1.5, 2, 90.0, 0.0), (0.3, 1, -180.0, 180.0)]\n        },\n        # Test case 4\n        {\n            \"S_base\": -1.0, \"lambda\": 0.0,\n            \"bonds\": [(300.0, 1.60, 1.50)],\n            \"angles\": [(80.0, 140.0, 120.0)],\n            \"torsions\": [(2.0, 3, 90.0, 60.0)]\n        },\n        # Test case 5\n        {\n            \"S_base\": 0.0, \"lambda\": 2.0,\n            \"bonds\": [],\n            \"angles\": [],\n            \"torsions\": []\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_base = case[\"S_base\"]\n        lambda_val = case[\"lambda\"]\n        bonds = case[\"bonds\"]\n        angles = case[\"angles\"]\n        torsions = case[\"torsions\"]\n\n        # Calculate strain energy\n        e_strain = 0.0\n\n        # Bond stretching energy\n        for k_b, r, r_0 in bonds:\n            e_strain += 0.5 * k_b * (r - r_0)**2\n\n        # Angle bending energy\n        for k_theta, theta_deg, theta_0_deg in angles:\n            theta_rad = np.deg2rad(theta_deg)\n            theta_0_rad = np.deg2rad(theta_0_deg)\n            e_strain += 0.5 * k_theta * (theta_rad - theta_0_rad)**2\n\n        # Torsional rotation energy\n        for k_tau, n, phi_deg, phi_0_deg in torsions:\n            phi_rad = np.deg2rad(phi_deg)\n            phi_0_rad = np.deg2rad(phi_0_deg)\n            e_strain += k_tau * (1 - np.cos(n * (phi_rad - phi_0_rad)))\n\n        # Calculate total score\n        s_total = s_base + lambda_val * e_strain\n        results.append(s_total)\n\n    # Format the final output string\n    # Round to six decimal places and format as a string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2422877"}, {"introduction": "Protein-ligand docking is rarely about a single molecule; it is a powerful tool for screening vast chemical libraries, generating large datasets of potential binders. Making sense of this data requires robust statistical analysis to distinguish meaningful trends from noise. This practice [@problem_id:2422882] introduces the concept of ligand efficiency, a size-normalized metric, and challenges you to test the statistical relationship between raw docking scores and this refined metric. This exercise develops crucial data analysis skills, teaching you how to apply hypothesis testing to interpret the outcomes of computational experiments and draw meaningful conclusions.", "problem": "You are given multiple independent datasets of ligand docking experiments. For each dataset, you have a list of docking scores and a list of the corresponding number of heavy atoms for each ligand. For each dataset, define the ligand efficiency sequence by the elementwise formula $L_i = S_i / N_i$, where $S_i$ is the docking score for ligand index $i$ and $N_i$ is the number of heavy atoms for the same ligand index $i$. Let $n$ be the number of ligands in a dataset. You must test, for each dataset, the null hypothesis $H_0: \\rho = 0$ against the two-sided alternative hypothesis $H_1: \\rho \\neq 0$, where $\\rho$ is the population Pearson correlation between the vectors $(S_i)_{i=1}^n$ and $(L_i)_{i=1}^n$. Use the following decision rule: compute the sample Pearson correlation coefficient $r$ and the corresponding two-sided $p$-value under the null using the Student $t$ distribution with $n - 2$ degrees of freedom, given by the statistic\n$$\nt = r \\sqrt{\\frac{n - 2}{1 - r^2}} \\quad \\text{for } |r| \\neq 1,\n$$\nand set the decision to reject $H_0$ if and only if $p < \\alpha$, with $\\alpha = 0.05$. If the sample standard deviation of either $(S_i)_{i=1}^n$ or $(L_i)_{i=1}^n$ is zero (hence $r$ is undefined), then the decision must be to not reject $H_0$. All computations are dimensionless; there are no physical units to report.\n\nTest suite. For each dataset $k \\in \\{1, 2, 3, 4\\}$, you are given arrays of equal length $n$ with docking scores $S^{(k)}$ and heavy atom counts $N^{(k)}$ as follows:\n- Dataset $1$: $S^{(1)} = \\{-6.0, -7.2, -5.5, -8.1, -6.8, -7.6\\}$ and $N^{(1)} = \\{20, 20, 20, 20, 20, 20\\}$.\n- Dataset $2$: $S^{(2)} = \\{-4.1, -5.8, -6.95, -8.55, -9.6, -11.3, -12.55, -14.05\\}$ and $N^{(2)} = \\{12, 16, 20, 24, 28, 32, 36, 40\\}$.\n- Dataset $3$: $S^{(3)} = \\{-8.0, -7.5, -7.0, -6.5, -6.0, -5.5, -5.2, -4.8\\}$ and $N^{(3)} = \\{20, 22, 24, 26, 28, 30, 32, 34\\}$.\n- Dataset $4$: $S^{(4)} = \\{-7.0, -7.0, -7.0, -7.0, -7.0, -7.0\\}$ and $N^{(4)} = \\{12, 14, 16, 18, 20, 22\\}$.\n\nAngle units and physical units do not apply here. All values are real numbers.\n\nYour program must compute, for each dataset $k$, the boolean decision value defined as $\\text{reject}_k = \\text{True}$ if $p_k < \\alpha$ and $\\text{reject}_k = \\text{False}$ otherwise, where $p_k$ is the two-sided $p$-value from the correlation test of $S^{(k)}$ and $L^{(k)}$. If the correlation coefficient is undefined due to zero variance in either sequence, set $\\text{reject}_k = \\text{False}$. The final output must be a single line containing the four boolean decisions in order $k = 1, 2, 3, 4$, formatted as a comma-separated list enclosed in square brackets, for example $[\\text{True},\\text{False},\\text{True},\\text{False}]$.", "solution": "The task is to perform a series of hypothesis tests on four distinct datasets from ligand docking experiments. For each dataset, we must test the null hypothesis $H_0: \\rho = 0$ against the two-sided alternative $H_1: \\rho \\neq 0$, where $\\rho$ is the population Pearson correlation coefficient between the docking scores, $(S_i)$, and the corresponding ligand efficiencies, $(L_i)$. The ligand efficiency is defined as $L_i = S_i / N_i$, where $N_i$ is the number of heavy atoms. The decision rule is to reject $H_0$ if the calculated $p$-value is less than the significance level $\\alpha = 0.05$. The $p$-value is determined from the sample Pearson correlation coefficient, $r$, using a test statistic that follows a Student's $t$-distribution with $n-2$ degrees of freedom. A special condition dictates that if the sample standard deviation of either the $(S_i)$ or $(L_i)$ sequence is zero, the correlation is undefined, and the decision is to not reject $H_0$.\n\nWe proceed by analyzing each dataset methodically.\n\n**Dataset 1:**\nThe given data are the docking scores $S^{(1)} = \\{-6.0, -7.2, -5.5, -8.1, -6.8, -7.6\\}$ and heavy atom counts $N^{(1)} = \\{20, 20, 20, 20, 20, 20\\}$. The sample size is $n_1 = 6$.\nThe ligand efficiency sequence $L^{(1)}$ is calculated by the element-wise division $L^{(1)}_i = S^{(1)}_i / N^{(1)}_i$. Since $N^{(1)}$ is a constant vector with all elements equal to $20$, $L^{(1)}_i = S^{(1)}_i / 20$.\nThis means $L^{(1)}$ is a direct positive linear transformation of $S^{(1)}$. The sample Pearson correlation coefficient $r$ between a variable and its positive linear transformation is exactly $1$. Thus, $r_1 = 1$.\nThe standard deviations of both $S^{(1)}$ and $L^{(1)}$ are non-zero.\nFor a perfect correlation, where $|r| = 1$, the evidence against the null hypothesis of zero correlation is maximal. The corresponding $p$-value, $p_1$, is therefore $0$.\nThe decision is made by comparing $p_1$ to $\\alpha = 0.05$. Since $p_1 = 0 < 0.05$, we reject the null hypothesis $H_0$. The decision is $\\text{True}$.\n\n**Dataset 2:**\nThe data are $S^{(2)} = \\{-4.1, -5.8, -6.95, -8.55, -9.6, -11.3, -12.55, -14.05\\}$ and $N^{(2)} = \\{12, 16, 20, 24, 28, 32, 36, 40\\}$. The sample size is $n_2 = 8$.\nThe ligand efficiency sequence is $L^{(2)}_i = S^{(2)}_i / N^{(2)}_i$. This gives $L^{(2)} \\approx \\{-0.3417, -0.3625, -0.3475, -0.3563, -0.3429, -0.3531, -0.3486, -0.3513\\}$.\nThe standard deviations of both $S^{(2)}$ and $L^{(2)}$ are non-zero.\nWe compute the sample Pearson correlation coefficient between $S^{(2)}$ and $L^{(2)}$, which is $r_2 \\approx 0.5256$.\nThe degrees of freedom for the $t$-test are $df_2 = n_2 - 2 = 8 - 2 = 6$.\nThe test statistic is calculated as $t_2 = r_2 \\sqrt{\\frac{n_2 - 2}{1 - r_2^2}} \\approx 0.5256 \\sqrt{\\frac{6}{1 - (0.5256)^2}} \\approx 1.516$.\nThe two-sided $p$-value, $p_2$, is the probability $P(|T_{df=6}| > |t_2|) \\approx P(|T_{df=6}| > 1.516)$, which evaluates to approximately $0.1818$.\nSince $p_2 \\approx 0.1818 > 0.05$, we fail to reject the null hypothesis $H_0$. The decision is $\\text{False}$.\n\n**Dataset 3:**\nThe data are $S^{(3)} = \\{-8.0, -7.5, -7.0, -6.5, -6.0, -5.5, -5.2, -4.8\\}$ and $N^{(3)} = \\{20, 22, 24, 26, 28, 30, 32, 34\\}$. The sample size is $n_3 = 8$.\nThe ligand efficiency sequence is $L^{(3)}_i = S^{(3)}_i / N^{(3)}_i$. This gives $L^{(3)} \\approx \\{-0.4000, -0.3409, -0.2917, -0.2500, -0.2143, -0.1833, -0.1625, -0.1412\\}$.\nThe standard deviations of both $S^{(3)}$ and $L^{(3)}$ are non-zero.\nThe sample Pearson correlation coefficient is $r_3 \\approx 0.9926$. This indicates a very strong positive linear relationship.\nThe degrees of freedom are $df_3 = n_3 - 2 = 6$.\nThe test statistic is $t_3 = r_3 \\sqrt{\\frac{n_3 - 2}{1 - r_3^2}} \\approx 0.9926 \\sqrt{\\frac{6}{1 - (0.9926)^2}} \\approx 20.08$.\nThe two-sided $p$-value, $p_3$, is $P(|T_{df=6}| > |t_3|) \\approx P(|T_{df=6}| > 20.08)$, which evaluates to approximately $1.055 \\times 10^{-5}$.\nSince $p_3 \\approx 1.055 \\times 10^{-5} < 0.05$, we reject the null hypothesis $H_0$. The decision is $\\text{True}$.\n\n**Dataset 4:**\nThe data are $S^{(4)} = \\{-7.0, -7.0, -7.0, -7.0, -7.0, -7.0\\}$ and $N^{(4)} = \\{12, 14, 16, 18, 20, 22\\}$.\nThe sequence of docking scores $S^{(4)}$ is a constant vector. Its sample standard deviation is therefore exactly zero.\nThe problem statement explicitly provides a rule for this case: \"If the sample standard deviation of either $(S_i)_{i=1}^n$ or $(L_i)_{i=1}^n$ is zero (hence $r$ is undefined), then the decision must be to not reject $H_0$\".\nFollowing this rule, we do not need to compute $L^{(4)}$ or proceed with any further statistical tests.\nThe decision is to not reject $H_0$. The decision is $\\text{False}$.\n\nIn summary, the decisions for the four datasets are: `True`, `False`, `True`, `False`.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import pearsonr\n\ndef solve():\n    \"\"\"\n    Computes for each dataset whether to reject the null hypothesis of zero correlation\n    between docking scores and ligand efficiencies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            [-6.0, -7.2, -5.5, -8.1, -6.8, -7.6],\n            [20, 20, 20, 20, 20, 20]\n        ),\n        (\n            [-4.1, -5.8, -6.95, -8.55, -9.6, -11.3, -12.55, -14.05],\n            [12, 16, 20, 24, 28, 32, 36, 40]\n        ),\n        (\n            [-8.0, -7.5, -7.0, -6.5, -6.0, -5.5, -5.2, -4.8],\n            [20, 22, 24, 26, 28, 30, 32, 34]\n        ),\n        (\n            [-7.0, -7.0, -7.0, -7.0, -7.0, -7.0],\n            [12, 14, 16, 18, 20, 22]\n        )\n    ]\n\n    alpha = 0.05\n    results = []\n\n    for s_list, n_list in test_cases:\n        s_vec = np.array(s_list, dtype=np.float64)\n        n_vec = np.array(n_list, dtype=np.float64)\n        \n        # Calculate ligand efficiency sequence L = S / N\n        l_vec = np.divide(s_vec, n_vec)\n        \n        # Per problem specification, if the standard deviation of either sequence is zero,\n        # the correlation is undefined and we do not reject H0.\n        # np.std returns exactly 0.0 for constant arrays, so direct comparison is safe.\n        if np.std(s_vec, ddof=1) == 0.0 or np.std(l_vec, ddof=1) == 0.0:\n            results.append(False)\n            continue\n            \n        # Calculate the sample Pearson correlation coefficient and the p-value.\n        # scipy.stats.pearsonr computes the r-statistic and the two-sided p-value\n        # for a hypothesis test whose null hypothesis is that two sets of data are\n        # uncorrelated. This function correctly implements the specified t-test.\n        _r, p_value = pearsonr(s_vec, l_vec)\n        \n        # Apply the decision rule: reject H0 if p < alpha\n        reject_h0 = p_value < alpha\n        results.append(reject_h0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2422882"}, {"introduction": "All computational models are simplifications of reality, and docking scoring functions are a prime example. An expert computational scientist must not only know how to use these tools but also understand their inherent limitations and potential failure modes. In this advanced exercise [@problem_id:2422880], you will think adversarially to design a \"malicious\" ligand—a molecule engineered to achieve a deceptively high score on a simple scoring function while being a poor binder according to a more physically realistic model. By actively exploiting a known vulnerability, such as the neglect of desolvation penalties, you will gain a profound appreciation for the physical principles that underpin accurate scoring and the critical importance of scrutinizing computational predictions.", "problem": "You are given a simplified but scientifically plausible setup of a protein-ligand docking situation designed to study adversarial behavior against an empirical scoring function. A receptor is described by feature points in three-dimensional space (in Angstroms) for hydrogen bonding: receptor donors and receptor acceptors. A ligand is described analogously by ligand donors and ligand acceptors. A pair contributes to a hydrogen-bond contact when one is a donor and the other is an acceptor and the Euclidean distance between the points is within a specified cutoff. No angular dependence is considered in the empirical score, and there is no size penalty in the empirical score. Distances must be treated in Angstroms. Energies must be treated in kilocalories per mole.\n\nDefine the following for any constructed ligand and fixed receptor:\n\n- Empirical score (to be exploited):\n  - The empirical hydrogen-bond contact count is the total number of donor-acceptor pairs with distance less than or equal to a cutoff $d_{\\mathrm{hb}}$.\n  - The empirical clash count is the total number of ligand feature points (donor or acceptor) that are closer than a clash distance $d_{\\mathrm{clash}}$ to any receptor feature point (donor or acceptor).\n  - The empirical score is\n  $$S = w_{\\mathrm{hb}} \\cdot N_{\\mathrm{hb}} - w_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash}}.$$\n\n- Physically motivated quality proxy (to detect poor binders):\n  - For each donor-acceptor pair across receptor and ligand, let the distance be $r$. Define a soft distance-dependent contact weight\n  $$g(r) = \\exp\\left(-\\frac{(r - r_0)^2}{2\\sigma^2}\\right).$$\n  - The physical energy proxy is\n  $$E_{\\mathrm{true}} = - e_{\\mathrm{hb}} \\cdot \\sum_{\\text{all receptor-ligand donor-acceptor pairs}} g(r) + p_{\\mathrm{polar}} \\cdot n_{\\mathrm{polar}} + p_{\\mathrm{rot}} \\cdot \\max(n_{\\mathrm{atoms}} - 1, 0) + p_{\\mathrm{clash}} \\cdot N_{\\mathrm{clash,true}},$$\n  where $n_{\\mathrm{polar}}$ is the number of ligand donors and acceptors (all counted as polar), $n_{\\mathrm{atoms}}$ is the total number of ligand donors and acceptors, and $N_{\\mathrm{clash,true}}$ is the same as $N_{\\mathrm{clash}}$ but used in the physical penalty. Lower $E_{\\mathrm{true}}$ indicates a better binder; here, a \"poor binder\" is one with $E_{\\mathrm{true}}$ exceeding a specified threshold. All energies must be expressed in kcal/mol.\n\nTask. You must construct, for each test case, a ligand that explicitly exploits the empirical score $S$ to be as high as possible, even if the physical proxy $E_{\\mathrm{true}}$ is poor. Your program must, for each test case, produce a boolean indicating whether you successfully produced a \"malicious\" ligand, defined as one satisfying both\n- $S \\ge S_{\\mathrm{target}}$ and\n- $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$,\nwhere $S_{\\mathrm{target}}$ and $E_{\\mathrm{bad}}$ are specified per test case below.\n\nFoundational bases to be used:\n- Empirical scores for docking often count contacts within a cutoff without angular terms. This is the basis for $N_{\\mathrm{hb}}$ with a hard distance cutoff $d_{\\mathrm{hb}}$.\n- Real physical favorability of hydrogen bonds is distance-sensitive around a preferred distance $r_0$ and is penalized by desolvation and conformational entropy costs proportional to the number of polar groups and flexible degrees of freedom. This is the basis for the Gaussian $g(r)$, the per-polar penalty $p_{\\mathrm{polar}}$, and the per-rotor proxy $p_{\\mathrm{rot}}$.\n\nGeometry and units:\n- All coordinates are given in Angstroms; your constructed ligand coordinates must be in Angstroms.\n- All energies must be computed in kilocalories per mole.\n- Angles are not used in this problem.\n\nFor all test cases, count distances using the standard Euclidean metric, with \"within cutoff\" defined as less than or equal to the cutoff.\n\nTest suite. For each test case, the receptor features, parameters, and thresholds are specified. Receptor donors and acceptors are given as lists of $[x,y,z]$ coordinates (Angstroms). There are no receptor hydrophobes in this simplified setup.\n\n- Test case 1 (happy path adversarial success):\n  - Receptor acceptors:\n    - $[0.0, 0.0, 0.0]$, $[4.0, 0.0, 0.0]$, $[0.0, 4.0, 0.0]$, $[0.0, 0.0, 4.0]$, $[3.0, 3.0, 0.0]$.\n  - Receptor donors: none.\n  - Empirical scoring parameters: $d_{\\mathrm{hb}} = 3.5$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$.\n  - Physical proxy parameters: $r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$.\n  - Thresholds: $S_{\\mathrm{target}} = 5$, $E_{\\mathrm{bad}} = 5.0$.\n\n- Test case 2 (boundary where exploitation should fail the \"poor binder\" criterion):\n  - Receptor acceptors:\n    - $[0.0, 0.0, 0.0]$, $[5.0, 0.0, 0.0]$.\n  - Receptor donors:\n    - $[0.0, 5.0, 0.0]$.\n  - Empirical scoring parameters: $d_{\\mathrm{hb}} = 2.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$.\n  - Physical proxy parameters: $r_0 = 2.8$, $\\sigma = 0.30$, $e_{\\mathrm{hb}} = 3.0$, $p_{\\mathrm{polar}} = 2.5$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$.\n  - Thresholds: $S_{\\mathrm{target}} = 3$, $E_{\\mathrm{bad}} = 2.0$.\n\n- Test case 3 (mixed features, larger cutoff, clear adversarial success):\n  - Receptor acceptors:\n    - $[0.0, 0.0, 0.0]$, $[2.0, 0.0, 0.0]$, $[0.0, 2.0, 0.0]$.\n  - Receptor donors:\n    - $[1.0, 1.0, 0.0]$, $[1.0, -1.0, 0.0]$, $[3.0, 1.0, 0.0]$.\n  - Empirical scoring parameters: $d_{\\mathrm{hb}} = 3.8$, $d_{\\mathrm{clash}} = 1.2$, $w_{\\mathrm{hb}} = 1.0$, $w_{\\mathrm{clash}} = 0.05$.\n  - Physical proxy parameters: $r_0 = 2.8$, $\\sigma = 0.35$, $e_{\\mathrm{hb}} = 2.8$, $p_{\\mathrm{polar}} = 2.0$, $p_{\\mathrm{rot}} = 0.4$, $p_{\\mathrm{clash}} = 10.0$.\n  - Thresholds: $S_{\\mathrm{target}} = 6$, $E_{\\mathrm{bad}} = 8.0$.\n\nYour program must, for each test case, construct a ligand (sets of donor and acceptor coordinates) intended to maximize the empirical score $S$ by placing complementary ligand features within the hydrogen-bond cutoff of as many receptor features as possible while avoiding empirical clashes if feasible, with no other constraints on the number of ligand atoms. Then compute $S$ and $E_{\\mathrm{true}}$ as defined above and return whether the malicious success criteria are met.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets (e.g., \"[True,False,True]\"). The three booleans must correspond to Test case $1$, Test case $2$, and Test case $3$, in that order. No other text must be printed.", "solution": "The objective is to construct an \"adversarial\" ligand that maximizes the simple empirical score $S$ while also having a poor (high) physical proxy energy $E_{\\mathrm{true}}$. This is achieved by exploiting the differences between the two scoring function definitions.\n\n**Adversarial Strategy**\nThe empirical score $S$ primarily rewards hydrogen bonds ($N_{\\mathrm{hb}}$) counted within a hard distance cutoff ($r \\le d_{\\mathrm{hb}}$). In contrast, the physical proxy energy $E_{\\mathrm{true}}$ has a favorable term that is optimal only at a specific distance $r_0$ and includes significant penalties for having many polar groups and a large size (proxied by $p_{\\mathrm{polar}}$ and $p_{\\mathrm{rot}}$). A successful adversarial ligand will therefore have many polar groups placed at distances that are considered \"good\" for $S$ but \"bad\" for $E_{\\mathrm{true}}$.\n\nThe specific strategy employed is as follows:\n1.  **Ligand Composition**: For each of the $N$ feature points on the receptor (donors and acceptors), the constructed ligand will have one complementary feature point. This maximizes the potential for $N_{\\mathrm{hb}}$ and simultaneously maximizes the polar penalties within $E_{\\mathrm{true}}$.\n2.  **Ligand Atom Placement**: To maximize $S$ while making $E_{\\mathrm{true}}$ as poor as possible, each ligand feature is placed at a distance $r$ from its target receptor feature that is inside the empirical cutoff ($r \\le d_{\\mathrm{hb}}$) but far from the optimal physical distance $r_0$. A strategic placement at the clash distance, $r = d_{\\mathrm{clash}}$, is ideal. This distance is close enough to count towards $N_{\\mathrm{hb}}$ for the empirical score, but it is far from the optimal physical distance $r_0$, yielding a minimal favorable energy contribution to $E_{\\mathrm{true}}$. The placement must also be chosen to avoid clashes with other non-target receptor atoms.\n\n**Implementation**\nFor each test case, a ligand is programmatically constructed using this adversarial strategy. The program then calculates both $S$ and $E_{\\mathrm{true}}$ for the generated ligand. Finally, it checks if the two conditions for a \"malicious\" ligand are met: $S \\ge S_{\\mathrm{target}}$ and $E_{\\mathrm{true}} \\ge E_{\\mathrm{bad}}$. The boolean result of this check is reported for each case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the adversarial ligand construction problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        {\n            \"rec_acceptors\": np.array([\n                [0.0, 0.0, 0.0], [4.0, 0.0, 0.0], [0.0, 4.0, 0.0],\n                [0.0, 0.0, 4.0], [3.0, 3.0, 0.0]\n            ]),\n            \"rec_donors\": np.empty((0, 3)),\n            \"params\": {\n                \"d_hb\": 3.5, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 5, \"E_bad\": 5.0}\n        },\n        # Test case 2\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0]]),\n            \"rec_donors\": np.array([[0.0, 5.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 2.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.30, \"e_hb\": 3.0, \"p_polar\": 2.5,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 3, \"E_bad\": 2.0}\n        },\n        # Test case 3\n        {\n            \"rec_acceptors\": np.array([[0.0, 0.0, 0.0], [2.0, 0.0, 0.0], [0.0, 2.0, 0.0]]),\n            \"rec_donors\": np.array([[1.0, 1.0, 0.0], [1.0, -1.0, 0.0], [3.0, 1.0, 0.0]]),\n            \"params\": {\n                \"d_hb\": 3.8, \"d_clash\": 1.2, \"w_hb\": 1.0, \"w_clash\": 0.05,\n                \"r0\": 2.8, \"sigma\": 0.35, \"e_hb\": 2.8, \"p_polar\": 2.0,\n                \"p_rot\": 0.4, \"p_clash\": 10.0\n            },\n            \"thresholds\": {\"S_target\": 6, \"E_bad\": 8.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        ligand_donors, ligand_acceptors = construct_adversarial_ligand(case)\n        S, E_true = calculate_scores(\n            ligand_donors, ligand_acceptors,\n            case[\"rec_donors\"], case[\"rec_acceptors\"],\n            case[\"params\"]\n        )\n        \n        is_malicious = (S >= case[\"thresholds\"][\"S_target\"] and \n                        E_true >= case[\"thresholds\"][\"E_bad\"])\n        results.append(str(is_malicious))\n\n    print(f\"[{','.join(results)}]\")\n\ndef construct_adversarial_ligand(case_data):\n    \"\"\"\n    Constructs a ligand by placing complementary atoms near receptor features.\n    The placement strategy is adversarial: place at a distance d_clash\n    from the target atom in a direction that does not clash with other receptor atoms.\n    \"\"\"\n    params = case_data[\"params\"]\n    d_clash = params[\"d_clash\"]\n    \n    rec_acceptors = case_data[\"rec_acceptors\"]\n    rec_donors = case_data[\"rec_donors\"]\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0] > 0:\n        all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0] > 0:\n        all_rec_pts.append(rec_donors)\n    \n    if not all_rec_pts:\n        return np.empty((0,3)), np.empty((0,3))\n\n    all_rec_pts = np.vstack(all_rec_pts)\n\n    deltas = np.array([\n        [d_clash, 0, 0], [0, d_clash, 0], [0, 0, d_clash],\n        [-d_clash, 0, 0], [0, -d_clash, 0], [0, 0, -d_clash]\n    ])\n\n    def find_non_clashing_pos(target_rec_pt, all_rec_pts, deltas):\n        for delta in deltas:\n            candidate_pos = target_rec_pt + delta\n            is_clashing = False\n            # Check candidate against all receptor points\n            distances = np.linalg.norm(all_rec_pts - candidate_pos, axis=1)\n            if np.any(distances < d_clash):\n                is_clashing = True\n            \n            if not is_clashing:\n                return candidate_pos\n        # Fallback if no non-clashing position is found (unlikely for these test cases)\n        return target_rec_pt + deltas[0]\n\n    ligand_donors = []\n    for rec_acc in rec_acceptors:\n        pos = find_non_clashing_pos(rec_acc, all_rec_pts, deltas)\n        ligand_donors.append(pos)\n\n    ligand_acceptors = []\n    for rec_don in rec_donors:\n        pos = find_non_clashing_pos(rec_don, all_rec_pts, deltas)\n        ligand_acceptors.append(pos)\n        \n    return np.array(ligand_donors), np.array(ligand_acceptors)\n\n\ndef calculate_scores(lig_donors, lig_acceptors, rec_donors, rec_acceptors, params):\n    \"\"\"\n    Calculates the empirical score (S) and physical energy proxy (E_true).\n    \"\"\"\n    # Unpack parameters\n    d_hb = params[\"d_hb\"]\n    d_clash = params[\"d_clash\"]\n    w_hb = params[\"w_hb\"]\n    w_clash = params[\"w_clash\"]\n    r0 = params[\"r0\"]\n    sigma = params[\"sigma\"]\n    e_hb = params[\"e_hb\"]\n    p_polar = params[\"p_polar\"]\n    p_rot = params[\"p_rot\"]\n    p_clash = params[\"p_clash\"]\n    \n    # Ligand properties\n    n_atoms = len(lig_donors) + len(lig_acceptors)\n    n_polar = n_atoms\n    \n    # Calculate N_hb and sum of g(r)\n    N_hb = 0\n    sum_g_r = 0.0\n\n    def g(r, r0, sigma):\n        return np.exp(-((r - r0)**2) / (2 * sigma**2))\n\n    # Receptor Acceptors vs Ligand Donors\n    if rec_acceptors.shape[0] > 0 and lig_donors.shape[0] > 0:\n        for lig_d in lig_donors:\n            for rec_a in rec_acceptors:\n                dist = np.linalg.norm(lig_d - rec_a)\n                if dist <= d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n\n    # Receptor Donors vs Ligand Acceptors\n    if rec_donors.shape[0] > 0 and lig_acceptors.shape[0] > 0:\n        for lig_a in lig_acceptors:\n            for rec_d in rec_donors:\n                dist = np.linalg.norm(lig_a - rec_d)\n                if dist <= d_hb:\n                    N_hb += 1\n                sum_g_r += g(dist, r0, sigma)\n                \n    # Calculate N_clash\n    N_clash = 0\n    \n    all_rec_pts = []\n    if rec_acceptors.shape[0] > 0: all_rec_pts.append(rec_acceptors)\n    if rec_donors.shape[0] > 0: all_rec_pts.append(rec_donors)\n    all_rec_pts = np.vstack(all_rec_pts) if all_rec_pts else np.empty((0,3))\n\n    all_lig_pts = []\n    if lig_donors.shape[0] > 0: all_lig_pts.append(lig_donors)\n    if lig_acceptors.shape[0] > 0: all_lig_pts.append(lig_acceptors)\n    all_lig_pts = np.vstack(all_lig_pts) if all_lig_pts else np.empty((0,3))\n\n    if all_rec_pts.shape[0] > 0:\n        for lig_pt in all_lig_pts:\n            min_dist = np.min(np.linalg.norm(all_rec_pts - lig_pt, axis=1))\n            if min_dist < d_clash:\n                N_clash += 1\n\n    # Final score calculations\n    S = w_hb * N_hb - w_clash * N_clash\n    \n    E_true = -e_hb * sum_g_r \\\n             + p_polar * n_polar \\\n             + p_rot * max(n_atoms - 1, 0) \\\n             + p_clash * N_clash\n             \n    return S, E_true\n\nsolve()\n```", "id": "2422880"}]}