{"hands_on_practices": [{"introduction": "Before delving into complex models, a scientist's first step is to characterize the system. In network science, this begins with the most fundamental property of a node: its degree. This exercise [@problem_id:1464939] provides a hands-on opportunity to calculate degrees from a raw list of protein interactions and compute simple, yet powerful, network statistics. By comparing the network's most connected node to the average connectivity, you will gain a direct, quantitative understanding of structural heterogeneity, a defining feature of scale-free systems.", "problem": "A systems biologist is investigating a small, newly characterized regulatory network consisting of seven proteins, which we will label P1 through P7. Experimental data from yeast two-hybrid screens have identified a set of physical interactions between these proteins. The interactions are considered undirected, meaning an interaction between protein A and protein B is a single connection shared by both. The complete list of observed interactions is as follows:\n\nP1 interacts with P2\nP1 interacts with P3\nP1 interacts with P4\nP2 interacts with P5\nP3 interacts with P4\nP3 interacts with P6\nP4 interacts with P7\nP5 interacts with P6\nP6 interacts with P7\n\nIn network analysis, a fundamental property is the degree of a node, which is the number of connections it has. To characterize the network's heterogeneity, we can compare the most connected node (the hub) to the average connectivity. Calculate the ratio of the maximum degree found in this network to the average degree of the network. Report your answer as a single number rounded to three significant figures.", "solution": "The network has seven nodes, labeled $P1$ through $P7$, and the interactions are undirected edges. From the given interactions, the degrees are determined by counting incident edges for each node:\n$$\\deg(P1)=3,\\ \\deg(P2)=2,\\ \\deg(P3)=3,\\ \\deg(P4)=3,\\ \\deg(P5)=2,\\ \\deg(P6)=3,\\ \\deg(P7)=2.$$\nThus, the maximum degree is\n$$d_{\\max}=3.$$\nThe total number of edges is $m=9$. By the handshaking lemma, the sum of degrees equals $2m$, so the average degree over $n=7$ nodes is\n$$\\bar{d}=\\frac{1}{n}\\sum_{i=1}^{n}\\deg(P_{i})=\\frac{2m}{n}=\\frac{2\\times 9}{7}=\\frac{18}{7}.$$\nThe requested ratio of the maximum degree to the average degree is therefore\n$$r=\\frac{d_{\\max}}{\\bar{d}}=\\frac{3}{18/7}=\\frac{7}{6}\\approx 1.166\\ldots$$\nRounded to three significant figures, this is $1.17$.", "answer": "$$\\boxed{1.17}$$", "id": "1464939"}, {"introduction": "Scale-free networks are not static; they grow and evolve over time. This practice [@problem_id:1705406] moves from static description to a dynamic growth mechanism by illustrating the core principle of preferential attachment, often summarized as the \"rich-get-richer\" phenomenon. By calculating the probability that a new node connects to existing ones, you will engage directly with the generative process that leads to the emergence of hubs and the characteristic power-law degree distribution.", "problem": "In the study of network theory, the growth of many real-world networks, such as citation networks or the World Wide Web, can be modeled by a process of preferential attachment. Consider a small, isolated citation network consisting of five foundational papers. The importance of each paper is quantified by its degree, which represents the number of connections it has within this network. The degrees of these five papers are $4, 3, 2, 2,$ and $1$.\n\nA new research paper is being written and will cite exactly one of these five foundational papers. The model for this citation process states that the probability of the new paper connecting to any given foundational paper is directly proportional to the degree of that foundational paper.\n\nCalculate the probability that the new paper will cite the most influential paper in the existing network, which is the one with a degree of 4. Express your answer as a simplified fraction.", "solution": "Under preferential attachment, the probability that the new paper cites a given foundational paper is proportional to that paper's degree. Let the degrees be $k_{1}=4$, $k_{2}=3$, $k_{3}=2$, $k_{4}=2$, and $k_{5}=1$. The total degree is the sum\n$$\n\\sum_{i=1}^{5} k_{i} = 4+3+2+2+1 = 12.\n$$\nThe probability of citing the paper with degree $4$ is\n$$\nP = \\frac{k_{1}}{\\sum_{i=1}^{5} k_{i}} = \\frac{4}{12} = \\frac{1}{3}.\n$$\nThus, the desired probability is the simplified fraction $\\frac{1}{3}$.", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "1705406"}, {"introduction": "The principles governing scale-free networks are not merely descriptive; they have powerful predictive applications. This final practice [@problem_id:2428013] challenges you to build a practical algorithm for \"link prediction,\" a common task in bioinformatics where experimental data is often incomplete. By using a scoring function based on the preferential attachment principle, $S(u,v) = k_u \\cdot k_v$, you will translate theory into code to identify likely but unobserved interactions in a protein network, demonstrating the real-world utility of these concepts.", "problem": "You are given an undirected, simple graph that represents an incomplete Protein-Protein Interaction (PPI) network. Assume the underlying complete network is scale-free, with degree distribution approximated by a power law. Under this assumption, use a degree-based connection likelihood model in which, for any unordered node pair $\\{u,v\\}$ not observed as an edge, a link-likelihood score is defined as $S(u,v) = k_u \\cdot k_v$, where $k_u$ and $k_v$ are the degrees computed from the observed (incomplete) graph. The graph has no self-loops and no multi-edges. Nodes are labeled by integers from $0$ to $N-1$ inclusive. For ranking non-observed pairs, first sort by decreasing $S(u,v)$; ties must be broken by ascending lexicographic order on $(u,v)$ with $u<v$.\n\nFor each test case, you are given:\n- The number of nodes $N$.\n- The observed edge set $E_{\\mathrm{obs}} \\subseteq \\{\\{u,v\\} \\mid 0 \\le u < v \\le N-1\\}$.\n- The true edge set $E_{\\mathrm{true}} \\subseteq \\{\\{u,v\\} \\mid 0 \\le u < v \\le N-1\\}$, which represents the complete underlying network consistent with the same node set. The set of ground-truth missing edges is $E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}}$.\n- An integer $L \\ge 1$.\n\nFor each test case:\n1. Compute the degree $k_u$ for each node $u$ from $E_{\\mathrm{obs}}$.\n2. Enumerate all unordered node pairs $\\{u,v\\}$ with $0 \\le u  v \\le N-1$ such that $\\{u,v\\} \\notin E_{\\mathrm{obs}}$, and compute $S(u,v) = k_u \\cdot k_v$.\n3. Rank all non-observed pairs by decreasing $S(u,v)$, breaking ties by ascending lexicographic order on $(u,v)$ where $uv$.\n4. Select the top $L$ pairs from this ranking as predicted edges.\n5. Let the result for the test case be the integer count of how many of these top $L$ predicted pairs are in $E_{\\mathrm{miss}}$.\n\nYour program must process the following test suite and output the results:\n\n- Test Case A:\n  - $N = 6$\n  - $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(0,3),(1,2),(4,5)\\}$\n  - $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(2,3),(4,5)\\}$\n  - $L = 2$\n\n- Test Case B:\n  - $N = 6$\n  - $E_{\\mathrm{obs}} = \\{(0,1),(1,2),(3,4)\\}$\n  - $E_{\\mathrm{true}} = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$\n  - $L = 3$\n\n- Test Case C:\n  - $N = 5$\n  - $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(1,2)\\}$\n  - $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(1,2),(2,3)\\}$\n  - $L = 4$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases A, B, C. The list elements must be integers. For example: `[a,b,c]` where $a$, $b$, and $c$ are the integer results for Test Case A, Test Case B, and Test Case C, respectively.", "solution": "The problem statement is subjected to validation before any solution is attempted.\n\n**Problem Validation**\n\n**Step 1: Extracted Givens**\n- An undirected, simple graph represents an incomplete Protein-Protein Interaction (PPI) network.\n- The underlying complete network is assumed to be scale-free.\n- A link-likelihood score for a non-observed unordered node pair $\\{u,v\\}$ is defined as $S(u,v) = k_u \\cdot k_v$, where $k_u$ and $k_v$ are degrees computed from the observed graph.\n- Nodes are labeled by integers from $0$ to $N-1$.\n- Ranking of non-observed pairs is by decreasing score $S(u,v)$, with ties broken by ascending lexicographic order on $(u,v)$ where $uv$.\n- Inputs for each test case: number of nodes $N$, observed edge set $E_{\\mathrm{obs}}$, true edge set $E_{\\mathrm{true}}$, and an integer $L \\ge 1$.\n- The set of missing edges is $E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}}$.\n- The task is to find the number of correctly predicted missing edges among the top $L$ ranked pairs.\n- Test Case Data:\n    - Test Case A: $N = 6$, $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(0,3),(1,2),(4,5)\\}$, $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(2,3),(4,5)\\}$, $L = 2$.\n    - Test Case B: $N = 6$, $E_{\\mathrm{obs}} = \\{(0,1),(1,2),(3,4)\\}$, $E_{\\mathrm{true}} = \\{(0,1),(1,2),(2,3),(3,4),(4,5)\\}$, $L = 3$.\n    - Test Case C: $N = 5$, $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(1,2)\\}$, $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(1,2),(2,3)\\}$, $L = 4$.\n\n**Step 2: Validation Using Extracted Givens**\n- **Scientific Grounding**: The problem is firmly grounded in network science and computational biology. The task described is known as \"link prediction.\" The assumption that PPI networks are scale-free is a mainstream hypothesis in the field. The use of a degree-based score like $S(u,v) = k_u \\cdot k_v$ directly reflects the principle of preferential attachment, a core mechanism for the growth of scale-free networks. This scoring function is a well-established heuristic (known as the Degree Product or Preferential Attachment index).\n- **Well-Posedness**: The problem is specified with mathematical precision. All inputs are defined, the scoring function is explicit, and the tie-breaking rule is unambiguous. This ensures that for each test case, a single, deterministic integer result exists.\n- **Objectivity**: The problem statement is free of subjective or ambiguous language. It is a formal, algorithmic challenge.\n- **Completeness and Consistency**: All necessary data ($N$, $E_{\\mathrm{obs}}$, $E_{\\mathrm{true}}$, $L$) are provided for each test case. There are no contradictions in the problem specification.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically sound, well-posed, and self-contained. It is therefore deemed **valid**. A solution will be provided.\n\n**Principle-Based Solution**\n\nThe problem addresses link prediction in an incomplete network under the assumption that the true, complete network is scale-free. Scale-free networks are characterized by a degree distribution $P(k)$ that follows a power law, approximately $P(k) \\sim k^{-\\gamma}$, where $k$ is the degree and $\\gamma$ is a constant. A key feature of such networks is the presence of a few highly connected nodes, or \"hubs.\" The preferential attachment model, which generates scale-free networks, posits that the probability of a new node connecting to an existing node $i$ is proportional to the degree $k_i$ of that node.\n\nThis principle is directly translated into a link prediction heuristic. For two currently unconnected nodes $u$ and $v$, the likelihood of a future or unobserved link between them is assumed to be proportional to the product of their current degrees, $k_u \\cdot k_v$. Nodes with higher degrees are more \"attractive\" and are thus more likely to form links. The problem formalizes this heuristic with the score $S(u,v) = k_u \\cdot k_v$ calculated from the observed, incomplete network $G_{\\mathrm{obs}} = (V, E_{\\mathrm{obs}})$.\n\nThe algorithm proceeds as follows:\n\n1.  **Compute Node Degrees**: For each node $u$ in the set of all nodes $V = \\{0, 1, \\dots, N-1\\}$, calculate its degree $k_u$ based on the observed edge set $E_{\\mathrm{obs}}$. The degree $k_u$ is the number of edges in $E_{\\mathrm{obs}}$ incident to $u$.\n\n2.  **Identify and Score Candidate Pairs**: Enumerate all possible unordered pairs of distinct nodes $\\{u,v\\}$ where $uv$. From this set of all possible edges, remove those that are already present in $E_{\\mathrm{obs}}$. The remaining pairs are the candidate edges for prediction. For each such candidate pair $\\{u,v\\}$, compute the link-likelihood score $S(u,v) = k_u \\cdot k_v$.\n\n3.  **Rank Candidate Pairs**: Create a ranked list of all candidate pairs. The primary sorting criterion is the score $S(u,v)$ in descending order. The secondary criterion, used to break ties, is the lexicographical order of the pair $(u,v)$ in ascending order (assuming $uv$ is maintained).\n\n4.  **Select Predictions and Evaluate**: From the top of the ranked list, select the first $L$ pairs. These are the predicted missing edges. The performance of the prediction is evaluated by counting how many of these $L$ predicted pairs are members of the ground-truth set of missing edges, $E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}}$.\n\n**Illustrative Example: Test Case A**\n\nLet us apply this procedure to Test Case A.\n- **Givens**: $N = 6$, $E_{\\mathrm{obs}} = \\{(0,1),(0,2),(0,3),(1,2),(4,5)\\}$, $E_{\\mathrm{true}} = \\{(0,1),(0,2),(0,3),(0,4),(1,2),(2,3),(4,5)\\}$, $L = 2$.\n\n1.  **Compute Degrees**: Based on $E_{\\mathrm{obs}}$:\n    - $k_0 = 3$ (connected to $1,2,3$)\n    - $k_1 = 2$ (connected to $0,2$)\n    - $k_2 = 2$ (connected to $0,1$)\n    - $k_3 = 1$ (connected to $0$)\n    - $k_4 = 1$ (connected to $5$)\n    - $k_5 = 1$ (connected to $4$)\n\n2.  **Identify and Score Candidate Pairs**: The total number of pairs is $\\binom{6}{2} = 15$. There are $|E_{\\mathrm{obs}}| = 5$ observed edges. Thus, there are $15-5=10$ non-observed pairs. We compute their scores:\n    - $S(0,4) = k_0 \\cdot k_4 = 3 \\cdot 1 = 3$\n    - $S(0,5) = k_0 \\cdot k_5 = 3 \\cdot 1 = 3$\n    - $S(1,3) = k_1 \\cdot k_3 = 2 \\cdot 1 = 2$\n    - $S(1,4) = k_1 \\cdot k_4 = 2 \\cdot 1 = 2$\n    - $S(1,5) = k_1 \\cdot k_5 = 2 \\cdot 1 = 2$\n    - $S(2,3) = k_2 \\cdot k_3 = 2 \\cdot 1 = 2$\n    - $S(2,4) = k_2 \\cdot k_4 = 2 \\cdot 1 = 2$\n    - $S(2,5) = k_2 \\cdot k_5 = 2 \\cdot 1 = 2$\n    - $S(3,4) = k_3 \\cdot k_4 = 1 \\cdot 1 = 1$\n    - $S(3,5) = k_3 \\cdot k_5 = 1 \\cdot 1 = 1$\n\n3.  **Rank Candidate Pairs**: We sort these $10$ pairs.\n    - Pairs with score $S=3$: $(0,4), (0,5)$. In lexicographical order: $(0,4)$, then $(0,5)$.\n    - Pairs with score $S=2$: $(1,3), (1,4), (1,5), (2,3), (2,4), (2,5)$. In lexicographical order.\n    - Pairs with score $S=1$: $(3,4), (3,5)$. In lexicographical order.\n    The complete ranked list starts as:\n    1. $\\{0,4\\}$ (Score $3$)\n    2. $\\{0,5\\}$ (Score $3$)\n    3. $\\{1,3\\}$ (Score $2$)\n    4. $\\{1,4\\}$ (Score $2$)\n    ... and so on.\n\n4.  **Select Predictions and Evaluate**: With $L=2$, we select the top two pairs: $\\{0,4\\}$ and $\\{0,5\\}$.\n    - We determine the set of true missing links: $E_{\\mathrm{miss}} = E_{\\mathrm{true}} \\setminus E_{\\mathrm{obs}} = \\{(0,4), (2,3)\\}$.\n    - We check our predictions against $E_{\\mathrm{miss}}$:\n        - Is $\\{0,4\\}$ in $E_{\\mathrm{miss}}$? Yes.\n        - Is $\\{0,5\\}$ in $E_{\\mathrm{miss}}$? No.\n    - The number of correct predictions is $1$.\n\nThe result for Test Case A is $1$. The same procedure is applied to all other test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the link prediction problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Edges are represented as sorted tuples (u, v) with u  v for consistency.\n    test_cases = [\n        # Test Case A\n        {\n            \"N\": 6,\n            \"E_obs\": set([(0, 1), (0, 2), (0, 3), (1, 2), (4, 5)]),\n            \"E_true\": set([(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (2, 3), (4, 5)]),\n            \"L\": 2,\n        },\n        # Test Case B\n        {\n            \"N\": 6,\n            \"E_obs\": set([(0, 1), (1, 2), (3, 4)]),\n            \"E_true\": set([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]),\n            \"L\": 3,\n        },\n        # Test Case C\n        {\n            \"N\": 5,\n            \"E_obs\": set([(0, 1), (0, 2), (1, 2)]),\n            \"E_true\": set([(0, 1), (0, 2), (0, 3), (1, 2), (2, 3)]),\n            \"L\": 4,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        E_obs = case[\"E_obs\"]\n        E_true = case[\"E_true\"]\n        L = case[\"L\"]\n\n        # 1. Compute the degree k_u for each node u from E_obs.\n        degrees = np.zeros(N, dtype=int)\n        for u, v in E_obs:\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        # 2. Enumerate all non-observed pairs and compute S(u,v).\n        non_observed_pairs = []\n        for u in range(N):\n            for v in range(u + 1, N):\n                if (u, v) not in E_obs:\n                    score = degrees[u] * degrees[v]\n                    # Store as a tuple for sorting: (score, u, v)\n                    non_observed_pairs.append((score, u, v))\n        \n        # 3. Rank all non-observed pairs.\n        # Sort by decreasing S(u,v) (score), then ascending (u,v).\n        # We achieve this by sorting on (-score, u, v).\n        non_observed_pairs.sort(key=lambda x: (-x[0], x[1], x[2]))\n        \n        # 4. Select the top L pairs as predicted edges.\n        # The number of predictions cannot exceed the number of available candidate pairs.\n        num_predictions = min(L, len(non_observed_pairs))\n        predicted_edges = set()\n        for i in range(num_predictions):\n            score, u, v = non_observed_pairs[i]\n            predicted_edges.add((u, v))\n            \n        # 5. Count how many predicted pairs are in E_miss.\n        E_miss = E_true.difference(E_obs)\n        correct_predictions = len(predicted_edges.intersection(E_miss))\n        \n        results.append(correct_predictions)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428013"}]}