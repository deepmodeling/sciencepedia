{"hands_on_practices": [{"introduction": "Standard RNA folding algorithms rely on a well-defined energy model for the canonical bases. This first practice challenges you to adapt that core logic to include a non-standard, modified base, pseudouridine ($\\Psi$), a common task when dealing with the true chemical diversity of RNA [@problem_id:2406124]. By implementing a dynamic programming algorithm with custom energy rules for pairing and stacking, you will develop the crucial skill of tailoring a general model to accommodate specific biochemical information.", "problem": "You are asked to formalize and implement a minimum free energy computation for ribonucleic acid (RNA) secondary structure folding using the nearest-neighbor principle and dynamic programming (DP), and to augment the base-pairing and energy scheme to include the modified base pseudouridine, denoted by the Greek letter Psi ($\\Psi$), which pairs with Adenine. Your implementation must explicitly account for the following scientifically grounded principles.\n\nFundamental basis. The nearest-neighbor model assumes that the total Gibbs free energy of a secondary structure is additive over local motifs. In this problem, you will use:\n- Additivity of motif energies: if a structure decomposes into non-overlapping motifs, its total Gibbs free energy is the sum of their energies.\n- Valid base pairs are constrained by biochemistry. Here, allow classical Watson–Crick and wobble pairs, and extend to modified bases as:\n  - Allowed pairs: $A\\text{-}U$, $U\\text{-}A$, $G\\text{-}C$, $C\\text{-}G$, $G\\text{-}U$, $U\\text{-}G$, $A\\text{-}\\Psi$, $\\Psi\\text{-}A$.\n  - Classify pair types into two categories used for stacking:\n    - Canonical-nonwobble: $\\{A\\text{-}U, U\\text{-}A, G\\text{-}C, C\\text{-}G, A\\text{-}\\Psi, \\Psi\\text{-}A\\}$.\n    - Wobble: $\\{G\\text{-}U, U\\text{-}G\\}$.\n- Hairpin loops. A base pair $(i,j)$ can close a hairpin loop of length $L = j - i - 1$ only if $L \\ge 3$. The hairpin loop free energy is modeled as\n  $$\\Delta G_{\\text{hp}}(L; \\text{closing pair}) = h_0 + h_1 \\ln L + \\delta_{\\text{close}}(\\text{pair type}),$$\n  where $h_0 = 2.0$ (in $\\mathrm{kcal/mol}$), $h_1 = 1.0$ (dimensionless, with the natural logarithm), and the closing pair specific offset is\n  - $\\delta_{\\text{close}}(G\\text{-}C) = \\delta_{\\text{close}}(C\\text{-}G) = -1.0$,\n  - $\\delta_{\\text{close}}(A\\text{-}U) = \\delta_{\\text{close}}(U\\text{-}A) = -0.5$,\n  - $\\delta_{\\text{close}}(A\\text{-}\\Psi) = \\delta_{\\text{close}}(\\Psi\\text{-}A) = -0.7$,\n  - $\\delta_{\\text{close}}(G\\text{-}U) = \\delta_{\\text{close}}(U\\text{-}G) = +0.5$.\n  If $L < 3$, the configuration is disallowed (assign $+\\infty$).\n- Stacking between adjacent base pairs. If $(i,j)$ stacks directly over $(i+1,j-1)$, the incremental stacking contribution is\n  $$\\Delta G_{\\text{stack}}((i,j),(i+1,j-1)) = \\begin{cases}\n  -1.8 & \\text{if both $(i,j)$ and $(i+1,j-1)$ are canonical-nonwobble},\\\\\n  -0.9 & \\text{if at least one of the two pairs is wobble}.\n  \\end{cases}$$\n- No other loop types (internal loops, bulges, multiloops) are to be modeled. Stems are thus built as sequences of stacks terminating in a hairpin loop. Unpaired nucleotides cost $0$.\n\nYour task. Design and implement a program that, given each RNA sequence over the alphabet $\\{A,C,G,U,\\Psi\\}$, computes the minimum free energy (MFE) secondary structure under the model above by minimizing the sum of allowed hairpin and stacking contributions subject to non-crossing base-pairing constraints. Use a dynamic programming decomposition that prevents bifurcations inside a paired segment while allowing concatenation of independent substructures in the overall sequence, ensuring that results reflect physically plausible nested RNA structures.\n\nUnits and output specification.\n- Report energies in $\\mathrm{kcal/mol}$.\n- Round each sequence’s MFE to two digits after the decimal point.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry a floating-point number rounded to two decimals, e.g., `[x_1,x_2,...,x_m]`.\n\nTest suite. Your program must compute the MFE for the following sequences (in the order given).\n1. `GCAUUUΨGC`\n2. `GCAUUUUGC`\n3. `GCAGC`\n4. `GUAGUUUCUGC`\n5. `GAGAUUUUCΨC`\n\nFinal output format. Your program should output a single line: a list `[E_1,E_2,E_3,E_4,E_5]` where $E_k$ is the rounded MFE (a float) for $S_k$, in $\\mathrm{kcal/mol}$, to two decimal places, as specified above.", "solution": "This problem in computational biology concerns the calculation of the minimum free energy (MFE) for RNA secondary structures. It provides a simplified but consistent nearest-neighbor energy model, including rules for canonical base pairs, wobble pairs, and a modified base, pseudouridine ($\\Psi$). The energy contributions are defined for hairpin loops and base pair stacking. The problem requires the implementation of a dynamic programming (DP) algorithm to find the MFE for several RNA sequences. We will now proceed with the formal derivation and solution.\n\nThe task is to find the minimum free energy of an RNA sequence $S = s_0s_1\\dots s_{N-1}$ of length $N$. The MFE is the minimum of the Gibbs free energy over all possible non-crossing secondary structures, including the completely unpaired structure which has an energy of $0 \\, \\mathrm{kcal/mol}$. The energy of any folded structure is the sum of energies of its constituent motifs, as per the provided simplified nearest-neighbor model.\n\nThis optimization problem can be solved using dynamic programming. The non-crossing constraint ensures that any base pair $(i, j)$ divides the sequence into independent interior ($S[i+1 \\dots j-1]$) and exterior regions. This property allows for a recursive decomposition that satisfies the principle of optimality.\n\nWe define two DP matrices:\n1.  $W[i, j]$: The minimum free energy of the subsequence $S[i \\dots j]$, with the constraint that the bases $s_i$ and $s_j$ must form a base pair.\n2.  $F[i, j]$: The minimum free energy of the subsequence $S[i \\dots j]$ over all possible secondary structures.\n\nThe final answer for the entire sequence $S$ is $F[0, N-1]$. The matrices will be filled for all $0 \\le i \\le j < N$, typically by increasing subsequence length $d = j-i$.\n\n**Recurrence for $W[i, j]$ (Energy of a Closed Substructure)**\n\nFor $W[i, j]$ to be finite, $(s_i, s_j)$ must be an allowed base pair. If they form a pair, the structure they enclose can either be a hairpin loop or a stem closed by another pair.\n\n1.  **Hairpin Loop:** The pair $(s_i, s_j)$ closes a hairpin loop. The loop consists of the unpaired bases $s_{i+1}, \\dots, s_{j-1}$. The loop length is $L = j - i - 1$. This is only permitted if $L \\ge 3$. The energy is given by:\n    $$E_{\\text{hairpin}}(i, j) = h_0 + h_1 \\ln(L) + \\delta_{\\text{close}}(s_i, s_j)$$\n    If $L < 3$, $E_{\\text{hairpin}}(i, j) = +\\infty$.\n\n2.  **Stacked Pair:** The pair $(s_i, s_j)$ stacks upon an adjacent inner pair $(s_{i+1}, s_{j-1})$. This inner pair, in turn, closes a substructure with energy $W[i+1, j-1]$. The energy for this case is the sum of the stacking energy and the energy of the inner closed structure:\n    $$E_{\\text{stack}}(i, j) = \\Delta G_{\\text{stack}}((s_i, s_j), (s_{i+1}, s_{j-1})) + W[i+1, j-1]$$\n    This case is only possible if $s_{i+1}$ and $s_{j-1}$ can form a pair, and requires $j-i \\ge 3$.\n\nCombining these, the recurrence for $W[i, j]$ is:\n$$\nW[i, j] = \\begin{cases}\n    \\min(E_{\\text{hairpin}}(i, j), E_{\\text{stack}}(i, j)) & \\text{if } (s_i, s_j) \\text{ is an allowed pair} \\\\\n    +\\infty & \\text{otherwise}\n\\end{cases}\n$$\n\n**Recurrence for $F[i, j]$ (Energy of an Unrestricted Substructure)**\n\nThe MFE for subsequence $S[i \\dots j]$ is the minimum over all possible configurations. We can classify these based on the status of the $i$-th base:\n\n1.  **Base $s_i$ is unpaired:** The base $s_i$ does not participate in any pair. Its energy contribution is $0$. The total MFE is simply the MFE of the remaining subsequence, $S[i+1 \\dots j]$. Thus, this case has energy $F[i+1, j]$.\n\n2.  **Base $s_i$ is paired:** The base $s_i$ pairs with some base $s_p$, where $i < p \\le j$. This forms a closed stem-loop structure on the subsequence $S[i \\dots p]$ with energy $W[i, p]$. Due to the non-crossing constraint, the subsequence $S[p+1 \\dots j]$ forms an independent structure with MFE $F[p+1, j]$. The total energy for a given $p$ is the sum $W[i, p] + F[p+1, j]$. We must minimize this over all possible partners $p$.\n\nThe complete recurrence for $F[i, j]$ combines these possibilities:\n$$F[i, j] = \\min \\left( F[i+1, j], \\min_{i < p \\le j, \\text{ s.t. } (s_i, s_p) \\text{ pairs}} \\{ W[i, p] + F[p+1, j] \\} \\right)$$\n\n**Base Cases and Initialization:**\n- For any $i$, $F[i, i-1] = 0$. This represents an empty sequence with zero energy.\n- For a single-base subsequence $S[i \\dots i]$, $F[i, i] = 0$. This can be derived from the recurrence: $F[i,i] = \\min(F[i+1,i], \\dots) = \\min(0, \\infty) = 0$.\n- The matrices $W$ and $F$ are initialized to $+\\infty$, except for the base cases.\n\nThe DP algorithm iterates through increasing subsequence lengths $d=j-i$ from $0$ to $N-1$. For each length $d$, it iterates through all possible start positions $i$. This ensures that when computing $F[i, j]$ and $W[i, j]$, the values for all smaller subproblems have already been computed. The final MFE for the entire sequence $S$ is given by $F[0, N-1]$.\n\nThe provided energy model is simplified and may result in positive MFE values for some sequences. If all possible folded structures have positive energy, the MFE will be the minimum of this positive value and the 0 energy of the unfolded state. The DP formulation correctly finds the global minimum across all possibilities, including the unfolded state whose energy contribution is implicitly handled by the recurrence structure.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimum free energy (MFE) for a set of RNA sequences\n    using a dynamic programming approach based on a simplified nearest-neighbor model.\n    \"\"\"\n\n    test_cases = [\n        \"GCAUUUΨGC\",\n        \"GCAUUUUGC\",\n        \"GCAGC\",\n        \"GUAGUUUCUGC\",\n        \"GAGAUUUUCΨC\",\n    ]\n\n    results = []\n    for seq in test_cases:\n        mfe = calculate_mfe(seq)\n        results.append(f\"{mfe:.2f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_mfe(S: str) -> float:\n    \"\"\"\n    Calculates the MFE of a single RNA sequence using dynamic programming.\n    \"\"\"\n    S = S.replace('Ψ', 'P')\n    N = len(S)\n    if N < 4:\n        return 0.0\n\n    # Define the energy model parameters\n    allowed_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G'), ('A', 'P'), ('P', 'A')}\n    canonical_nonwobble_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('A', 'P'), ('P', 'A')}\n    delta_close = {\n        ('G', 'C'): -1.0, ('C', 'G'): -1.0,\n        ('A', 'U'): -0.5, ('U', 'A'): -0.5,\n        ('A', 'P'): -0.7, ('P', 'A'): -0.7,\n        ('G', 'U'): 0.5, ('U', 'G'): 0.5\n    }\n    h0, h1 = 2.0, 1.0\n\n    # Initialize DP tables\n    W = np.full((N, N), np.inf, dtype=np.float64)\n    F = np.full((N, N), np.inf, dtype=np.float64)\n\n    # Base cases for F\n    for i in range(N):\n        F[i, i] = 0.0\n    for i in range(N - 1):\n        F[i, i+1] = 0.0\n\n    # Iterate over subsequence length d\n    for d in range(2, N):\n        for i in range(N - d):\n            j = i + d\n\n            # --- Compute W[i, j]: MFE of a closed subsequence ---\n            pair = (S[i], S[j])\n            if pair in allowed_pairs:\n                # Hairpin loop energy\n                loop_len = j - i - 1\n                if loop_len >= 3:\n                    e_hp = h0 + h1 * np.log(loop_len) + delta_close[pair]\n                else:\n                    e_hp = np.inf\n                \n                # Stacking energy\n                if j - 1 > i + 1:\n                    inner_pair = (S[i+1], S[j-1])\n                    if inner_pair in allowed_pairs:\n                        is_p1_wobble = pair not in canonical_nonwobble_pairs\n                        is_p2_wobble = inner_pair not in canonical_nonwobble_pairs\n                        stack_e = -0.9 if (is_p1_wobble or is_p2_wobble) else -1.8\n                        e_stack = stack_e + W[i+1, j-1]\n                    else:\n                        e_stack = np.inf\n                else:\n                    e_stack = np.inf\n                \n                W[i, j] = min(e_hp, e_stack)\n\n            # --- Compute F[i, j]: MFE of any subsequence ---\n            \n            # Case 1: Base i is unpaired\n            e_unpaired_i = F[i+1, j]\n            \n            # Case 2: Base i is paired with base p\n            min_paired_e = np.inf\n            # Minimum loop length is 3, so p must be at least i+4\n            for p in range(i + 4, j + 1):\n                if not np.isinf(W[i, p]):\n                    energy_of_rest = F[p+1, j] if p + 1 <= j else 0.0\n                    current_e = W[i, p] + energy_of_rest\n                    if current_e < min_paired_e:\n                        min_paired_e = current_e\n\n            F[i, j] = min(e_unpaired_i, min_paired_e)\n\n    # The MFE of the sequence is F[0, N-1], which may be positive.\n    # If all folded structures have energy > 0, the MFE corresponds to the\n    # unfolded state, which has energy 0.\n    final_mfe = F[0, N-1]\n    return min(0.0, final_mfe)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2406124"}, {"introduction": "Computational predictions are most powerful when integrated with experimental evidence. This practice demonstrates how to constrain a folding algorithm to enforce the formation of a specific base pair, a technique used to incorporate data that confirms a particular structural feature [@problem_id:2406104]. You will leverage the non-crossing property of RNA secondary structures to decompose the problem into independent subproblems, a fundamental principle that makes constrained folding computationally tractable.", "problem": "An RNA secondary structure is a set of non-crossing base pairs over a nucleotide string. Under a simplified thermodynamic model, the minimum free energy (MFE) structure is the secondary structure with the smallest total free energy. Consider an additive nearest-neighbor-like model in which each base pair contributes a fixed energy and unpaired nucleotides contribute $0$. Assume that only planar (non-pseudoknotted) structures are allowed and that a base pair $(l,r)$ is valid only if it forms a hairpin loop of at least $L_{\\min}$ unpaired nucleotides, i.e., $r-l-1 \\ge L_{\\min}$.\n\nYou must write a complete program that computes the MFE under the following scientifically standard and simplified assumptions:\n\n- The allowed pair types and their energies are:\n  - Watson–Crick guanine–cytosine ($\\text{G}$–$\\text{C}$ and $\\text{C}$–$\\text{G}$): $-2.0$ energy units.\n  - Watson–Crick adenine–uracil ($\\text{A}$–$\\text{U}$ and $\\text{U}$–$\\text{A}$): $-1.0$ energy units.\n  - Wobble guanine–uracil ($\\text{G}$–$\\text{U}$ and $\\text{U}$–$\\text{G}$): $-0.5$ energy units.\n- All other base pairs are disallowed and contribute $+\\infty$ if attempted.\n- A single, specific, non-canonical guanine–adenine ($\\text{G}$–$\\text{A}$) pair at specified indices $(i,j)$ must be enforced as a hard constraint. This enforced non-canonical pair contributes $-0.4$ energy units and must be present in the final structure.\n- The enforced non-canonical pair is only allowed at that one specified ordered index pair $(i,j)$ with $i<j$; guanine–adenine ($\\text{G}$–$\\text{A}$) or adenine–guanine ($\\text{A}$–$\\text{G}$) elsewhere are disallowed.\n- The minimal hairpin loop length is $L_{\\min} = 3$, i.e., a pair $(l,r)$ is only valid if $r-l-1 \\ge 3$.\n- Unpaired nucleotides have energy $0$.\n- The total free energy is the sum of energies of all base pairs in the structure.\n\nHard-constraint semantics and feasibility:\n- If the indices do not satisfy $0 \\le i < j < n$, where $n$ is the sequence length, or if the nucleotides at those indices are not $\\text{G}$ at $i$ and $\\text{A}$ at $j$, or if the loop-length condition $j-i-1 \\ge L_{\\min}$ fails, then the task is infeasible, and the MFE must be reported as $+\\infty$.\n- Otherwise, the MFE must be computed among all planar secondary structures that include the enforced $(i,j)$ pair, using the energy model above.\n\nYour program must implement a dynamic programming solution consistent with the assumptions above. It must not rely on any external input. Use zero-based indexing for positions.\n\nTest suite:\nCompute the MFE for each of the following parameter sets, in order. Each test case is a tuple $(s, i, j)$, where $s$ is the RNA sequence and $(i,j)$ is the enforced non-canonical $\\text{G}$–$\\text{A}$ pair to include.\n\n- Test case 1: `(\"GCGAAAUCGCAG\", 2, 10)`\n- Test case 2: `(\"ACGUACGA\", 1, 6)`\n- Test case 3: `(\"GAAC\", 0, 1)`\n- Test case 4: `(\"GAAAACUUUUA\", 0, 10)`\n\nOutput requirements:\n- For each test case, output the MFE as a floating-point number in the order listed above. If the hard constraint is infeasible, output $+\\infty$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, `[x_1,x_2,x_3,x_4]`), where each $x_k$ is the MFE for test case $k$ as a floating-point number. There are no physical units; energies are dimensionless model units.", "solution": "This problem in computational biology is well-posed and grounded in the established principles of thermodynamic models for RNA secondary structure prediction. It provides a clear, self-contained, and scientifically sound set of rules and parameters, making it amenable to a rigorous algorithmic solution. The problem requires the computation of the minimum free energy (MFE) of an RNA sequence under a specific hard constraint, which is a standard variant of folding problems solvable with dynamic programming.\n\nThe core of the problem is to find the MFE of a planar RNA secondary structure that is constrained to include a specific base pair $(i,j)$. The planarity (non-pseudoknotted) constraint is critical. It dictates that any base pair $(p,q)$ cannot \"cross\" the enforced pair $(i,j)$. That is, we cannot have relationships like $p < i < q < j$ or $i < p < j < q$. This non-crossing rule provides a natural decomposition of the problem.\n\nAny valid secondary structure containing the pair $(i,j)$ partitions the sequence $s$ of length $n$ into three independent regions:\n1. The enforced pair itself, connecting nucleotides $s[i]$ and $s[j]$.\n2. The internal region, comprising the subsequence $s[i+1 \\ldots j-1]$. Any pairs formed within this region must have both indices $p, q$ such that $i < p < q < j$.\n3. The external region, comprising nucleotides $s[0 \\ldots i-1]$ and $s[j+1 \\ldots n-1]$. Any pairs formed here must have both indices $p, q$ outside the range $[i, j]$. Because of the planarity constraint, the external region folds as a single continuous unit, which can be modeled by concatenating the two segments into a new linear sequence: $s_{ext} = s[0 \\ldots i-1] + s[j+1 \\ldots n-1]$.\n\nThe total free energy of the structure is the sum of the energies from these three parts. Due to their independence, the principle of optimality applies. To find the global minimum free energy, we must find the minimum free energy for the internal and external regions separately and sum them.\n\nThe total MFE is therefore given by:\n$$\n\\text{MFE}_{\\text{total}} = E(s[i], s[j]) + \\text{MFE}(s[i+1 \\ldots j-1]) + \\text{MFE}(s_{ext})\n$$\nwhere $E(s[i], s[j])$ is the energy of the enforced G–A pair ($-0.4$ units), $\\text{MFE}(s[i+1 \\ldots j-1])$ is the MFE of the internal subsequence, and $\\text{MFE}(s_{ext})$ is the MFE of the concatenated external sequence.\n\nThis strategy requires two main steps:\nFirst, a preliminary validation of the hard constraint. For a given sequence $s$ of length $n$ and indices $(i,j)$, we must verify:\n- $0 \\le i < j < n$\n- $s[i] = \\text{'G'}$ and $s[j] = \\text{'A'}$\n- The minimum hairpin loop length condition, $j - i - 1 \\ge L_{\\min}$, where $L_{\\min} = 3$.\nIf any of these conditions are not met, the problem is infeasible, and the MFE is $+\\infty$.\n\nSecond, if the constraint is feasible, we proceed to calculate the MFE of the internal and external subsequences. This requires a general algorithm to compute the MFE of an arbitrary RNA sequence, which we will formulate using dynamic programming. This general algorithm will use the standard energy model provided (G–C, A–U, G–U pairs) and must not include the special G–A pair, which is exclusively for the hard constraint.\n\nLet $M(p,q)$ be the MFE of a subsequence $s[p \\ldots q]$. We can compute $M(p,q)$ via the following recurrence relation, which considers all possible valid structures on the subsequence. A structure on $s[p \\ldots q]$ is either closed by the pair $(p,q)$ or is a composite of structures on smaller, adjacent subsequences (a bifurcation).\nThe recurrence is:\n$$\nM(p, q) = \\min \\left( E_{pair}, E_{bifurcation} \\right)\n$$\nwhere:\n1. $E_{pair}$ is the minimum energy if $s[p]$ and $s[q]$ form a pair. This is possible only if $q - p - 1 \\ge L_{\\min}$ and $(s[p], s[q])$ is an allowed pair type. The energy is the sum of the pair's energy and the MFE of the enclosed subsequence:\n$$\nE_{pair} = E(s[p], s[q]) + M(p+1, q-1)\n$$\n2. $E_{bifurcation}$ corresponds to structures where $s[p]$ and $s[q]$ are not paired with each other. The subsequence $s[p \\ldots q]$ is split into two independent, adjacent subsequences, $s[p \\ldots k]$ and $s[k+1 \\ldots q]$. We must find the split point $k$ that minimizes the total energy:\n$$\nE_{bifurcation} = \\min_{p \\le k < q} \\left( M(p, k) + M(k+1, q) \\right)\n$$\nThe base cases for the recursion are $M(p, q) = 0$ if the subsequence is too short to form a hairpin loop, i.e., $q - p - 1 < L_{\\min}$.\n\nWe will implement this DP algorithm in a function `calculate_mfe(sequence)`. This function will be called for the internal and external subsequences derived from the main problem. The final MFE is the sum of the energies from the three components, as described previously.\n\nThe energy function $E(n_1, n_2)$ for the general DP calculation is defined as:\n- $E(\\text{'G'}, \\text{'C'}) = E(\\text{'C'}, \\text{'G'}) = -2.0$\n- $E(\\text{'A'}, \\text{'U'}) = E(\\text{'U'}, \\text{'A'}) = -1.0$\n- $E(\\text{'G'}, \\text{'U'}) = E(\\text{'U'}, \\text{'G'}) = -0.5$\n- All other pairs contribute $+\\infty$.\nUnpaired nucleotides contribute $0$, an effect which is implicitly handled by the DP recurrence.\n\nThe solution will be implemented in a complete Python program that first defines a function for the general MFE calculation, then a main function to handle the constrained problem for each test case, including the preliminary feasibility check.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the RNA folding problem for the given test suite.\n    \"\"\"\n\n    # Define the base pair energy function for the general MFE calculation.\n    # Note: The special G-A pair is handled separately as a hard constraint and is not part of this generic function.\n    energy_map = {\n        ('G', 'C'): -2.0, ('C', 'G'): -2.0,\n        ('A', 'U'): -1.0, ('U', 'A'): -1.0,\n        ('G', 'U'): -0.5, ('U', 'G'): -0.5,\n    }\n\n    # Minimum hairpin loop length\n    L_min = 3\n\n    def get_energy(n1, n2):\n        \"\"\"Returns the energy of a base pair, or infinity if disallowed.\"\"\"\n        return energy_map.get((n1, n2), float('inf'))\n\n    def calculate_mfe(seq):\n        \"\"\"\n        Calculates the Minimum Free Energy (MFE) for a given RNA sequence using dynamic programming.\n        This is a generic MFE calculator based on a simplified Zuker-style recurrence.\n        \"\"\"\n        m = len(seq)\n        if m == 0:\n            return 0.0\n\n        # DP table M[i][j] stores the MFE for subsequence seq[i...j]\n        M = np.full((m, m), 0.0)\n\n        # Iterate over subsequence span (d = j - i)\n        for d in range(L_min + 1, m):\n            for i in range(m - d):\n                j = i + d\n\n                # Case 1: (i, j) form a pair.\n                # This contributes the pair's energy plus the MFE of the enclosed region.\n                pair_energy = get_energy(seq[i], seq[j])\n                mfe_pair = float('inf')\n                if pair_energy != float('inf'):\n                    # M table is 0-initialized, M[i+1][j-1] will be 0 if j-1 < i+1\n                    mfe_pair = pair_energy + M[i + 1, j - 1]\n\n                # Case 2: Bifurcation.\n                # The structure is a concatenation of two independent substructures.\n                mfe_bifurcation = float('inf')\n                for k in range(i, j):\n                    mfe_bifurcation = min(mfe_bifurcation, M[i, k] + M[k + 1, j])\n                \n                M[i, j] = min(mfe_pair, mfe_bifurcation)\n\n        return M[0, m - 1]\n\n    def solve_constrained_mfe(s, i, j):\n        \"\"\"\n        Solves the MFE problem with the enforced G-A pair at (i, j).\n        \"\"\"\n        n = len(s)\n        E_GA = -0.4\n\n        # Step 1: Validate the feasibility of the hard constraint.\n        if not (0 <= i < j < n):\n            return float('inf')\n        if s[i] != 'G' or s[j] != 'A':\n            return float('inf')\n        if not (j - i - 1 >= L_min):\n            return float('inf')\n\n        # Step 2: Decompose the problem and solve subproblems.\n        # Internal region: subsequence inside the (i, j) pair's loop.\n        s_internal = s[i + 1 : j]\n        mfe_internal = calculate_mfe(s_internal)\n\n        # External region: concatenation of sequence parts outside the (i, j) pair.\n        s_external = s[0:i] + s[j + 1:n]\n        mfe_external = calculate_mfe(s_external)\n\n        # Total MFE is the sum of energies from the three independent parts.\n        return E_GA + mfe_internal + mfe_external\n\n    # Test cases from the problem statement\n    test_cases = [\n        (\"GCGAAAUCGCAG\", 2, 10),\n        (\"ACGUACGA\", 1, 6),\n        (\"GAAC\", 0, 1),\n        (\"GAAAACUUUUA\", 0, 10),\n    ]\n\n    results = []\n    for s, i, j in test_cases:\n        result = solve_constrained_mfe(s, i, j)\n        results.append(result)\n\n    # Format the output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2406104"}, {"introduction": "In reality, an RNA molecule often exists as an ensemble of low-energy conformations, not just a single MFE structure. This advanced practice guides you to move beyond a single prediction and find the second-most-stable structure, offering a richer view of the RNA's energy landscape [@problem_id:2406117]. You will achieve this by augmenting the standard dynamic programming recurrence to maintain a \"shadow\" matrix for the second-best scores, a powerful technique for exploring suboptimal solutions.", "problem": "You are to implement a program that computes, for a given Ribonucleic Acid (RNA) sequence, both the minimum free energy (MFE) structure and the second-most-stable structure under a simplified, scientifically plausible energy model, and then report only the second-best total energy. The computation must use Dynamic Programming (DP) with an explicit maintenance of a \"shadow\" second-best score at each subproblem and a backtracking mechanism that can reconstruct the second-most-stable structure from this shadow. The output must be a single line containing the second-best energies for a provided test suite.\n\nStart from the following foundational base:\n- RNA secondary structure is a set of non-crossing base pairs $(i,j)$ on a sequence of nucleotides indexed from $0$ to $n-1$, where $i < j$, subject to the restriction that no pseudoknots occur (non-crossing means that there do not exist $(i,j)$ and $(k,\\ell)$ such that $i < k < j < \\ell$).\n- Only canonical Watson–Crick pairs and wobble pairs are allowed: Adenine–Uracil ($\\mathrm{A}$–$\\mathrm{U}$), Guanine–Cytosine ($\\mathrm{G}$–$\\mathrm{C}$), and Guanine–Uracil ($\\mathrm{G}$–$\\mathrm{U}$), symmetric in order.\n- The total free energy of a structure is the sum of pairwise contributions from each base pair, with no additional loop or stacking terms. This idealization is well tested as a baseline for algorithmic development in computational biology.\n- The minimum hairpin loop length is enforced: if positions $i$ and $j$ are paired, then $j - i - 1 \\geq L$, where $L = 3$. This reflects the empirically observed instability of hairpins shorter than $3$ nucleotides.\n- No pseudoknots are allowed.\n\nEnergy model:\n- Pair energies are in arbitrary units (a.u.): $\\mathrm{A}$–$\\mathrm{U}$ contributes $-2.0$, $\\mathrm{G}$–$\\mathrm{C}$ contributes $-3.0$, and $\\mathrm{G}$–$\\mathrm{U}$ contributes $-1.0$. Non-allowed pairs contribute nothing because they cannot form.\n- Unpaired nucleotides contribute $0.0$.\n\nDefinitions to derive your algorithm:\n- Let $F(i,j)$ denote the optimal (minimum) free energy achievable on the subsequence from index $i$ to index $j$ inclusive, for $0 \\le i \\le j \\le n-1$. If $i > j$, define $F(i,j) = 0.0$ by convention for the empty subsequence.\n- Let $S(i,j)$ denote the second-best free energy on the same subsequence, defined to be the smallest value that is strictly larger than $F(i,j)$, i.e., $S(i,j) > F(i,j)$ and for any other achievable energy $E$ on $[i,j]$, if $E > F(i,j)$ then $S(i,j) \\le E$.\n- The Dynamic Programming (DP) principle of optimality applies: any optimal decomposition of $[i,j]$ into smaller independent subintervals must be locally optimal on those subintervals given the constraints. From this, and the stated energy model and constraints, derive the decomposition cases that cover all possibilities: $i$ unpaired, $j$ unpaired, $(i,j)$ paired (if allowed), and a bifurcation (split) at some $k$ with $i \\le k < j$, combining independent solutions on $[i,k]$ and $[k+1,j]$. You must then extend this reasoning to maintain both $F(i,j)$ and $S(i,j)$ by considering, for each decomposition, candidate energies produced by combining first- and second-best subsolutions in a way that guarantees the correct $S(i,j)$ as the minimal value strictly greater than $F(i,j)$.\n\nBacktracking requirement:\n- Maintain, for each cell $(i,j)$, sufficient \"shadow\" backpointer information to reconstruct not only an $F$-optimal structure but also an $S$-optimal structure by tracing the choice that yielded $S(i,j)$. While your program’s final output will only report energies, your implementation must include a correct backtracking mechanism that could produce the dot-bracket string for the second-most-stable structure on demand.\n\nNumerical conventions:\n- Treat energy values as real numbers. Use a strict inequality to define \"second-best\" (strictly greater than the minimum). If no valid second-best energy exists on $[0,n-1]$ (for example, if no structure can be formed other than the minimum or if all achievable energies on the full interval are identical), report $+\\infty$ as a floating-point infinity. All energies must be reported in arbitrary units (a.u.) as floating-point numbers.\n\nTest suite:\nYour program must compute and aggregate the second-best energies for the following RNA sequences (each as an uppercase string over $\\{\\mathrm{A},\\mathrm{U},\\mathrm{G},\\mathrm{C}\\}$), using $L = 3$, the pair energies given above, and the stated constraints:\n- Case $1$: $\\text{\"GAAAC\"}$\n- Case $2$: $\\text{\"AUGCUA\"}$\n- Case $3$: $\\text{\"GGGAAACCC\"}$\n- Case $4$: $\\text{\"AUGCUAU\"}$\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list of floating-point numbers enclosed in square brackets, in the same order as the test cases, for example `[...]`. Use Python’s default string representation for floating-point numbers, where $+\\infty$ is represented as $\\text{\"inf\"}$.", "solution": "This problem is a well-posed exercise in computational algorithmics, grounded in the principles of computational biology. It requires the implementation of a dynamic programming algorithm to compute not only the minimum free energy (MFE) secondary structure of an RNA molecule under a simplified energy model but also the second-most-stable structure. We proceed with the formal derivation and implementation.\n\nLet the RNA sequence be denoted by $R$, a string of length $n$ indexed from $0$ to $n-1$. The energy of a secondary structure is the sum of contributions from its constituent base pairs. Allowed pairs are Adenine–Uracil ($\\mathrm{A}$–$\\mathrm{U}$) with energy $-2.0$, Guanine–Cytosine ($\\mathrm{G}$–$\\mathrm{C}$) with energy $-3.0$, and Guanine–Uracil ($\\mathrm{G}$–$\\mathrm{U}$) with energy $-1.0$. An all-unpaired structure has an energy of $0.0$. A pair $(i, j)$ is only permissible if it forms a hairpin loop of at least $L=3$ nucleotides, that is, $j - i - 1 \\ge 3$.\n\nWe define two functions to be computed for every subsequence $R[i..j]$:\n1.  $F(i,j)$: The minimum free energy (the MFE) for the subsequence from index $i$ to $j$.\n2.  $S(i,j)$: The second-best minimum free energy, defined as the smallest achievable energy on the subsequence $[i,j]$ that is strictly greater than $F(i,j)$. If no such energy exists, $S(i,j) = +\\infty$.\n\nThe structure of any non-pseudoknotted RNA secondary structure on a subsequence $[i,j]$ falls into one of two categories:\n1.  The bases $i$ and $j$ form a pair, enclosing a substructure on the interval $[i+1, j-1]$. This is the \"closed pair\" case.\n2.  The bases $i$ and $j$ do not pair with each other. The structure on $[i,j]$ is then a concatenation of two independent substructures on intervals $[i,k]$ and $[k+1,j]$ for some split point $k$ where $i \\le k < j$. This is the \"bifurcation\" case.\n\nThis decomposition leads to the standard dynamic programming recurrence for the MFE, $F(i,j)$:\n$$\nF(i,j) = \\min \\left( E_{\\text{pair}}(i,j) + F(i+1, j-1), \\quad \\min_{i \\le k < j} \\left( F(i,k) + F(k+1,j) \\right) \\right)\n$$\nThe first term corresponds to the closed pair case, where $E_{\\text{pair}}(i,j)$ is the energy of the pair $(R_i, R_j)$ if it is allowed, and $+\\infty$ otherwise. The second term covers all bifurcation possibilities. Notably, the bifurcation term implicitly includes cases where one end is unpaired; for instance, setting $k=i$ yields $F(i,i) + F(i+1,j)$, which simplifies to $F(i+1,j)$ since $F(i,i)=0$ for a single unpaired base.\n\nTo find the second-best energy $S(i,j)$, we must extend this logic. For each decomposition, we must consider not only combinations of optimal sub-solutions but also combinations involving second-best sub-solutions. This generates a set of candidate energies for the interval $[i,j]$. The two smallest distinct values in this set will be $F(i,j)$ and $S(i,j)$.\n\nThe candidate energies for the interval $[i,j]$ are generated as follows:\n1.  **From the closed pair case**: If the pair $(R_i, R_j)$ is valid (i.e., allowed pair type and $j - i - 1 \\ge L$), two candidate energies are produced:\n    -   $C_1 = E_{\\text{pair}}(i,j) + F(i+1, j-1)$ (combining with the best substructure)\n    -   $C_2 = E_{\\text{pair}}(i,j) + S(i+1, j-1)$ (combining with the second-best substructure)\n\n2.  **From the bifurcation case**: For each possible split point $k$ from $i$ to $j-1$, we can combine the energies of the two resulting sub-intervals. To find the two best energies from the bifurcation alone, we must consider combinations of best and second-best energies from the sub-intervals:\n    -   $B_{k,1} = F(i,k) + F(k+1,j)$ (best with best)\n    -   $B_{k,2} = S(i,k) + F(k+1,j)$ (second-best with best)\n    -   $B_{k,3} = F(i,k) + S(k+1,j)$ (best with second-best)\n\nThe complete set of candidate energies for the subproblem $(i,j)$ is the union of all candidates generated by the closed pair case (if applicable) and all bifurcation cases for all possible $k$. Let this set be $\\mathcal{E}_{i,j}$. Then, $F(i,j)$ is the minimum value in $\\mathcal{E}_{i,j}$, and $S(i,j)$ is the minimum value in $\\mathcal{E}_{i,j}$ that is strictly greater than $F(i,j)$.\n\nThe algorithm is implemented using a bottom-up dynamic programming approach. We populate two $n \\times n$ matrices, $\\mathbf{F}$ and $\\mathbf{S}$. The computation proceeds by increasing subsequence length, $d = j - i + 1$.\n\n**Base Cases**: For any subsequence of length $d \\le L+1$, no valid base pair can be formed according to the hairpin loop constraint. Thus, the only possible structure is all unpaired, with an energy of $0$.\n-   For $j-i \\le L$: $F(i,j) = 0.0$ and $S(i,j) = +\\infty$. This includes single nucleotides ($F(i,i)=0$) and empty subsequences ($F(i,i-1)=0$) by convention.\n\n**Main Loop**:\nWe iterate over subsequence length $d$ from $L+2$ to $n$. For each $d$, we iterate over all possible start indices $i$ from $0$ to $n-d$. The end index is $j = i+d-1$.\nFor each cell $(i,j)$:\n1.  A list of candidate energies is assembled by evaluating all possibilities described above, drawing upon the already computed values in the $\\mathbf{F}$ and $\\mathbf{S}$ matrices for smaller subproblems.\n2.  This list of candidates is filtered to contain unique, finite values and then sorted.\n3.  $F(i,j)$ is set to the first element of the sorted list.\n4.  $S(i,j)$ is set to the second element, or to $+\\infty$ if no second unique value exists.\n\nTo fulfill the requirement of a reconstructable path, a backtracking mechanism must be co-implemented. For each cell $(i,j)$, additional matrices, $\\mathbf{F}_{\\text{trace}}$ and $\\mathbf{S}_{\\text{trace}}$, store pointers indicating which decomposition case (closed pair or a specific bifurcation $k$) yielded the values for $F(i,j)$ and $S(i,j)$. This information, while not used for the final numeric output, is essential for a complete algorithm and allows for the reconstruction of the full dot-bracket notation of the corresponding structures.\n\nThe final answer for a given sequence is the value of $S(0, n-1)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the RNA second-best energy problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        \"GAAAC\",\n        \"AUGCUA\",\n        \"GGGAAACCC\",\n        \"AUGCUAU\",\n    ]\n    \n    L = 3\n    \n    energy_map = {\n        ('A', 'U'): -2.0, ('U', 'A'): -2.0,\n        ('G', 'C'): -3.0, ('C', 'G'): -3.0,\n        ('G', 'U'): -1.0, ('U', 'G'): -1.0,\n    }\n\n    results = []\n    for sequence in test_cases:\n        result = compute_second_best_energy(sequence, L, energy_map)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_second_best_energy(sequence, L, energy_map):\n    \"\"\"\n    Computes the second-best free energy for a given RNA sequence using dynamic programming.\n    The algorithm maintains both the MFE (F) and the second-best energy (S) for all subsequences.\n    A backtracking mechanism is implicitly included by storing trace information.\n    \"\"\"\n    n = len(sequence)\n    if n == 0:\n        return np.inf\n\n    F = np.full((n, n), np.inf, dtype=np.float64)\n    S = np.full((n, n), np.inf, dtype=np.float64)\n    \n    # The following trace matrices are part of the required algorithm design\n    # for backtracking, even if not used for the final energy output.\n    F_trace = np.empty((n, n), dtype=object)\n    S_trace = np.empty((n, n), dtype=object)\n\n    # Base cases for subsequences of length 0 and 1.\n    for i in range(n):\n        if i > 0:\n            F[i, i-1] = 0.0  # Empty subsequence\n        F[i, i] = 0.0      # Single unpaired nucleotide\n    \n    # Iterate over subsequence length, d\n    for d in range(2, n + 1):\n        for i in range(n - d + 1):\n            j = i + d - 1\n            \n            candidates = []\n\n            # Case 1: (i, j) form a hairpin or multi-loop (closed pair)\n            if j - i - 1 >= L:\n                pair = (sequence[i], sequence[j])\n                if pair in energy_map:\n                    pair_energy = energy_map[pair]\n                    \n                    # Contribution from the best internal structure\n                    f_sub = F[i + 1, j - 1]\n                    if np.isfinite(f_sub):\n                        candidates.append((pair_energy + f_sub, ('pair',)))\n                    \n                    # Contribution from the second-best internal structure\n                    s_sub = S[i + 1, j - 1]\n                    if np.isfinite(s_sub):\n                        candidates.append((pair_energy + s_sub, ('pair',)))\n\n            # Case 2: Bifurcation (or simple chain-like structure)\n            for k in range(i, j):\n                # F(i,k) + F(k+1,j)\n                ff_val = F[i, k] + F[k + 1, j]\n                if np.isfinite(ff_val):\n                    candidates.append((ff_val, ('bif', k)))\n                \n                # S(i,k) + F(k+1,j)\n                sf_val = S[i, k] + F[k + 1, j]\n                if np.isfinite(sf_val):\n                    candidates.append((sf_val, ('bif', k)))\n\n                # F(i,k) + S(k+1,j)\n                fs_val = F[i, k] + S[k + 1, j]\n                if np.isfinite(fs_val):\n                    candidates.append((fs_val, ('bif', k)))\n            \n            # Find F(i,j) and S(i,j) from the collected candidates\n            if not candidates:\n                 # This case is triggered for short subsequences (d <= L+1) where no pairs can form.\n                 # The all-unpaired structure has energy 0.\n                 F[i, j] = 0.0\n                 S[i, j] = np.inf\n                 continue\n\n            # Sort candidates by energy and find the two best unique values\n            candidates.sort(key=lambda x: x[0])\n            \n            unique_cands = [list(group)[0] for _, group in itertools.groupby(candidates, lambda x: x[0])]\n\n            if len(unique_cands) > 0:\n                F[i, j], F_trace[i, j] = unique_cands[0]\n            else:\n                # Fallback for all-unpaired case if no negative energies are found.\n                F[i, j] = 0.0\n\n            if len(unique_cands) > 1:\n                S[i, j], S_trace[i, j] = unique_cands[1]\n            else:\n                S[i, j] = np.inf\n\n    return S[0, n - 1]\n\nsolve()\n```", "id": "2406117"}]}