{"hands_on_practices": [{"introduction": "The foundational Nussinov algorithm provides a blueprint for predicting RNA secondary structure by maximizing the total number of base pairs. However, biophysical reality is more nuanced; for instance, the guanine-cytosine (G-C) pair, with its three hydrogen bonds, contributes more to a structure's thermal stability than an adenine-uracil (A-U) pair. This exercise challenges you to adapt the classic dynamic programming approach by modifying the objective function, tasking you with maximizing the count of G-C pairs specifically, a common proxy for structural stability [@problem_id:2426841]. This is a crucial first step in moving from purely combinatorial models to more biophysically-grounded predictions.", "problem": "You are given an idealized model of ribonucleic acid (RNA) secondary structure as a set of base pairs on a single-stranded sequence over the alphabet {A, U, G, C}. A secondary structure on a sequence of length $n$ is a set $M$ of ordered index pairs $(i,j)$ with $0 \\le i  j \\le n-1$ satisfying the following validity constraints: (1) each index appears in at most one pair, (2) only canonical pairs are allowed, where the allowed base pairs are A–U, U–A, G–C, C–G, G–U, and U–G, and (3) there are no pseudoknots, meaning that if $(i,j) \\in M$ and $(k,\\ell) \\in M$, then it is not the case that $i  k  j  \\ell$. Additionally, a minimum hairpin loop length constraint is enforced: for each pair $(i,j) \\in M$, the number of unpaired nucleotides enclosed by the pair must be at least $L$, that is $j - i - 1 \\ge L$, where $L$ is a given nonnegative integer.\n\nDefine the guanine-cytosine content objective as follows. For a given valid structure $M$, its guanine-cytosine score is\n$$\n\\operatorname{GC}(M) \\;=\\; \\sum_{(i,j)\\in M} \\mathbf{1}\\big(\\{s_i,s_j\\}=\\{\\mathrm{G},\\mathrm{C}\\}\\big),\n$$\nwhere $s_i$ is the nucleotide at position $i$, and $\\mathbf{1}(\\cdot)$ is the indicator that counts $1$ if the pair is a guanine–cytosine pair (G–C or C–G) and counts $0$ otherwise. Your task is to compute, for each test case, the maximum possible value of $\\operatorname{GC}(M)$ over all valid structures $M$ that satisfy the constraints above for the given sequence and the specified minimum hairpin loop length $L$.\n\nYour program must use the fixed test suite below. For each test case, the input is a pair consisting of a sequence and a value of $L$. For each test case, the output must be a single integer equal to the maximum achievable value of $\\operatorname{GC}(M)$ under the rules above.\n\nTest suite:\n- Sequence \"GGGCCC\", with minimum hairpin loop length $L=0$.\n- Sequence \"AAAA\", with minimum hairpin loop length $L=0$.\n- Sequence \"GCAUCG\", with minimum hairpin loop length $L=3$.\n- Sequence \"GUGU\", with minimum hairpin loop length $L=0$.\n- Sequence \"\", with minimum hairpin loop length $L=0$.\n- Sequence \"CGCG\", with minimum hairpin loop length $L=0$.\n\nFinal output format: Your program should produce a single line of output containing the results, in order, as a comma-separated list enclosed in square brackets (for example, \"[x_1,x_2,\\dots,x_6]\"), where each $x_i$ is the integer maximum $\\operatorname{GC}(M)$ for the $i$-th test case in the test suite.", "solution": "The problem presented is a constrained optimization problem centered on the prediction of RNA secondary structure, a classic subject in computational biology. The task is to find a valid secondary structure that maximizes the number of Guanine-Cytosine (G-C) pairs. The prohibition of pseudoknots is a critical constraint that renders the problem solvable by dynamic programming, as it ensures that the structure can be decomposed hierarchically.\n\nLet the given RNA sequence be $s$, with length $n$, indexed from $0$ to $n-1$. We define $E(i, j)$ as the maximum possible G-C score for the subsequence $s_i, s_{i+1}, \\dots, s_j$. The objective is to compute $E(0, n-1)$.\n\nThe solution is built upon the principle of optimality: an optimal structure for a sequence is composed of optimal structures for its sub-sequences. We construct a recurrence relation for $E(i, j)$ by considering all valid structural configurations of the subsequence $s_i \\dots s_j$. Any such structure is determined by the status of the base at index $j$.\n\nThere are two fundamental cases for the base $s_j$:\n\n1.  **The base $s_j$ is unpaired.** In this case, $s_j$ does not form a pair and contributes nothing to the G-C score. The problem of optimizing the structure on $s_i \\dots s_j$ reduces to finding the optimal structure for the shorter subsequence $s_i \\dots s_{j-1}$. The score is therefore given by $E(i, j-1)$.\n\n2.  **The base $s_j$ is paired with a base $s_k$, where $i \\le k  j$.** The formation of a pair $(k, j)$ is subject to two primary constraints defined in the problem:\n    -   **Canonical Pairing**: The pair of nucleotides $(s_k, s_j)$ must be one of the allowed canonical pairs: A–U, U–A, G–C, C–G, G–U, or U–G.\n    -   **Minimum Hairpin Loop Length**: The number of nucleotides enclosed by the pair must be at least $L$, which translates to the condition $j - k - 1 \\ge L$.\n\nIf a pair $(k, j)$ satisfies these conditions, its formation has a local and global impact. Locally, it contributes to the total score. The contribution is $1$ if $\\{s_k, s_j\\} = \\{\\text{G}, \\text{C}\\}$, and $0$ for other allowed canonical pairs (A-U, G-U, and their reverse complements). Globally, the no-pseudoknot rule dictates that the pair $(k, j)$ partitions the sequence $s_i \\dots s_j$ into two independent sub-regions that can be optimized separately: the region preceding the pair, $s_i \\dots s_{k-1}$, and the region enclosed by the pair, $s_{k+1} \\dots s_{j-1}$. The total score for this specific configuration is the sum of the optimal scores from these two independent sub-problems plus the score contribution from the pair $(k, j)$ itself.\n\nBy combining these cases and maximizing over all possibilities, we arrive at the following recurrence relation:\n$$\nE(i, j) = \\max \\left( E(i, j-1), \\quad \\max_{ \\substack{i \\le k  j \\\\ (k,j) \\text{ is valid}} } \\left\\{ E(i, k-1) + E(k+1, j-1) + \\mathbf{1}(\\{s_k,s_j\\}=\\{\\mathrm{G},\\mathrm{C}\\}) \\right\\} \\right)\n$$\nHere, $\\mathbf{1}(\\cdot)$ is the indicator function, which evaluates to $1$ if its argument is true and $0$ otherwise. The term \"valid\" for the pair $(k,j)$ encompasses both the canonical pairing rule and the minimum loop length constraint.\n\nThe base cases for the recursion are subsequences that are too short to form any valid pairs. For any $i, j$ such that the subsequence length $j-i+1$ is less than $L+2$, it is impossible to form a hairpin loop satisfying the minimum length $L$. Thus, for such subsequences, $E(i, j) = 0$. We also define $E(i, j) = 0$ for any $i  j$, corresponding to an empty subsequence.\n\nThis recurrence is implemented algorithmically by populating a two-dimensional array, let's call it $\\texttt{dp}[i][j]$, which stores the computed values of $E(i, j)$. The computation proceeds by iterating over increasing subsequence lengths $d = j-i$, from $d=1$ up to $d=n-1$. For each length $d$, we iterate through all possible starting positions $i$ from $0$ to $n-1-d$. The final solution to the problem is the value stored in $\\texttt{dp}[0][n-1]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA secondary structure problem for a fixed test suite.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"GGGCCC\", 0),\n        (\"AAAA\", 0),\n        (\"GCAUCG\", 3),\n        (\"GUGU\", 0),\n        (\"\", 0),\n        (\"CGCG\", 0),\n    ]\n\n    results = []\n    for sequence, L in test_cases:\n        result = compute_max_gc_pairs(sequence, L)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_gc_pairs(sequence: str, L: int) - int:\n    \"\"\"\n    Computes the maximum number of G-C pairs in a valid RNA secondary structure.\n\n    This function uses dynamic programming to solve the problem. The state E(i, j)\n    represents the maximum G-C score for the subsequence from index i to j.\n\n    Args:\n        sequence: The RNA sequence string.\n        L: The minimum hairpin loop length.\n\n    Returns:\n        The maximum number of G-C pairs.\n    \"\"\"\n    n = len(sequence)\n    if n  L + 2:\n        return 0\n\n    # Initialize a DP table to store the max scores for subsequences.\n    # dp[i][j] will store the max GC score for sequence[i:j+1]\n    dp = np.zeros((n, n), dtype=int)\n\n    canonical_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')}\n\n    def is_canonical(b1: str, b2: str) - bool:\n        return (b1, b2) in canonical_pairs\n\n    def gc_score(b1: str, b2: str) - int:\n        return 1 if (b1 == 'G' and b2 == 'C') or (b1 == 'C' and b2 == 'G') else 0\n\n    # Iterate over subsequence length d (from 1 to n-1)\n    for d in range(1, n):\n        # Iterate over start index i\n        for i in range(n - d):\n            j = i + d\n\n            # Case 1: j is unpaired. The score is the same as the subsequence s_i...s_{j-1}.\n            score_unpaired = dp[i, j - 1]\n\n            # Case 2: j is paired with some k. We must maximize over all possible k.\n            max_score_j_paired = 0\n            # k must satisfy i = k  j and the loop length constraint j - k - 1 = L.\n            # This implies k = j - L - 1.\n            for k in range(i, j - L):\n                if is_canonical(sequence[k], sequence[j]):\n                    # Score from the pair (k, j) itself.\n                    pair_score = gc_score(sequence[k], sequence[j])\n                    \n                    # Score from the structure on the subsequence before k.\n                    score_before = dp[i, k - 1] if k  i else 0\n                    \n                    # Score from the structure on the subsequence inside (k, j).\n                    score_inside = dp[k + 1, j - 1] if k + 1 = j - 1 else 0\n                    \n                    current_total_score = score_before + pair_score + score_inside\n                    if current_total_score  max_score_j_paired:\n                        max_score_j_paired = current_total_score\n\n            # The final score for dp[i, j] is the maximum of the unpaired and paired cases.\n            dp[i, j] = max(score_unpaired, max_score_j_paired)\n            \n    return dp[0, n - 1]\n\nsolve()\n```", "id": "2426841"}, {"introduction": "Building on the idea of a more realistic prediction, this practice moves beyond simple pair counts to consider the energetic contributions of pair arrangements. In thermodynamics, the stacking of adjacent base pairs is a primary source of stability, making isolated or \"lonely\" pairs energetically unfavorable. This exercise asks you to enforce this rule by modifying the dynamic programming logic to forbid lonely pairs [@problem_id:2426853]. Successfully solving this requires a more sophisticated recurrence that recognizes helices, or stacks of pairs, as the fundamental scoring unit, bringing your algorithm closer to state-of-the-art energy models.", "problem": "You are given finite sequences over the alphabet {A, C, G, U} representing Ribonucleic Acid (RNA). For a sequence $s = s_1 s_2 \\dots s_n$ of length $n$, a secondary structure is a set of ordered pairs of indices $\\{(i,j)\\}$ with $1 \\le i lt; j \\le n$ such that:\n- Each index appears in at most one pair.\n- The structure is pseudoknot-free (noncrossing): for any two pairs $(i,j)$ and $(k,\\ell)$ with $i lt; k$, either $j lt; k$ or $\\ell lt; j$.\n- Base pairing follows canonical rules: allowed base pairs are $\\{ \\text{A-U}, \\text{U-A}, \\text{G-C}, \\text{C-G}, \\text{G-U}, \\text{U-G} \\}$.\n- No lonely pairs are allowed: for every pair $(i,j)$ in the structure, at least one of $(i+1, j-1)$ or $(i-1, j+1)$ is also in the structure, provided the indices are within $[1,n]$. In other words, every paired nucleotide must be part of a helix of length at least $2$ (stacked with an adjacent pair on at least one side).\n\nNo minimum hairpin loop length constraint is imposed in this problem, and there are no physical units. For each input sequence, the goal is to compute the maximum possible number of base pairs (an integer) among all secondary structures satisfying the above constraints.\n\nTest suite:\n- Case $1$: $s = \\text{\"AU\"}$\n- Case $2$: $s = \\text{\"AUAU\"}$\n- Case $3$: $s = \\text{\"GGGAAACCC\"}$\n- Case $4$: $s = \\text{\"GCAU\"}$\n- Case $5$: $s = \\text{\"AUAUCCCCAUAU\"}$\n- Case $6$: $s = \\text{\"AGCU\"}$\n\nYour program must compute, for each case, the maximum number of base pairs under the stated constraints and output the results as a single line containing a comma-separated list of the six integers in order, enclosed in square brackets, with no spaces. For example, the format must be exactly like $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5,\\text{result}_6]$.", "solution": "### Solution Derivation\nThe problem is to find the maximum number of base pairs in a pseudoknot-free RNA secondary structure, with the additional constraint against lonely pairs. This class of problem is typically solved using dynamic programming. To align with standard computational practices and the provided code, we will use 0-based indexing for the sequence $s$ of length $n$, meaning indices run from $0$ to $n-1$.\n\nThe pseudoknot-free constraint implies that any structure on a subsequence $s[i \\dots j]$ can be decomposed. The structure is either formed by two independent, adjacent substructures (a bifurcation) or is enclosed by a base pair connecting some $s[k]$ to $s[l]$ where $i \\le k  l \\le j$.\n\nThe critical constraint is the \"no lonely pairs\" rule. This rule states that every base pair must be adjoined by at least one other base pair, forming a stack. The minimal such structure is a \"stacked pair\" or a \"helix of length 2\", for instance, pairs $(i, j)$ and $(i+1, j-1)$. This means that the fundamental unit of scoring is not a single base pair, but a helix of length at least $2$.\n\nWe can formulate a dynamic programming solution based on this insight. Let $M[i, j]$ be the maximum number of base pairs that can be formed within the subsequence $s[i \\dots j]$. To compute $M[i, j]$, we consider all possible valid structures for this subsequence. Due to the pseudoknot-free constraint, any such structure falls into one of two categories:\n\n1.  **Bifurcation**: The structure on $s[i \\dots j]$ consists of two independent and adjacent substructures on $s[i \\dots k]$ and $s[k+1 \\dots j]$ for some split point $k$ where $i \\le k  j$. The total number of pairs in this case is $M[i, k] + M[k+1, j]$. We must maximize over all possible $k$.\n\n2.  **Enclosing Helix**: The entire subsequence $s[i \\dots j]$ is enclosed by a helix. Due to the \"no lonely pairs\" rule, this helix must have a length $p \\ge 2$. A helix of length $p$ consists of $p$ stacked pairs: $(i, j), (i+1, j-1), \\dots, (i+p-1, j-p+1)$. This configuration contributes $p$ pairs, plus the maximum number of pairs that can be formed in the remaining inner subsequence, $s[i+p \\dots j-p]$, which is given by $M[i+p, j-p]$.\n\nTo efficiently determine the possible helix lengths, we can pre-compute a helper table, $H[i, j]$, which stores the length of the longest possible helix starting with the pair $(i, j)$ and extending inwards. This table can be computed recursively:\n$$\nH[i, j] = \\begin{cases} 1 + H[i+1, j-1]  \\text{if } (s[i], s[j]) \\text{ can form a base pair} \\\\ 0  \\text{otherwise} \\end{cases}\n$$\nThe base cases are $H[i, j] = 0$ if $j \\le i$.\n\nWith the $H$ table pre-computed, the recurrence for $M[i, j]$ combines the two structural possibilities:\n$$\nM[i, j] = \\max \\left( \\max_{i \\le k  j} (M[i, k] + M[k+1, j]), \\quad \\max_{p=2, \\dots, H[i, j]} (p + M[i+p, j-p]) \\right)\n$$\nThe first term corresponds to the bifurcation case. The second term corresponds to the enclosing helix case, where we maximize over all possible valid helix lengths $p \\ge 2$. If no such helix can form (i.e., $H[i, j]  2$), this term is effectively $0$ and does not contribute to the maximum. The base cases for the main recurrence are $M[i, j] = 0$ for all $j \\le i$.\n\nThe algorithm proceeds by iterating through increasing subsequence lengths $L$ from $1$ to $n$. For each $L$, we compute $H[i, j]$ and $M[i, j]$ for all $i$ where $j=i+L-1$. The final answer is the maximum number of pairs for the entire sequence, given by $M[0, n-1]$. This ensures that when we compute a value for a subsequence of a certain length, the values for all shorter subsequences have already been computed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA secondary structure problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        \"AU\",\n        \"AUAU\",\n        \"GGGAAACCC\",\n        \"GCAU\",\n        \"AUAUCCCCAUAU\",\n        \"AGCU\",\n    ]\n\n    results = []\n    for s in test_cases:\n        result = compute_max_pairs(s)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_max_pairs(s: str) - int:\n    \"\"\"\n    Computes the maximum number of base pairs in an RNA sequence\n    under the constraints of being pseudoknot-free and having no lonely pairs.\n\n    This is achieved using dynamic programming. Two tables are used:\n    - H[i, j]: Stores the length of the longest helix starting with a pair (i, j).\n    - M[i, j]: Stores the maximum number of pairs in the subsequence s[i...j].\n\n    The recurrence for M[i, j] considers two cases for the structure on s[i...j]:\n    1. A bifurcation into two independent adjacent substructures.\n    2. An enclosing helix of length p = 2.\n    \"\"\"\n    n = len(s)\n    if n  4:  # A helix of length 2 requires at least 4 nucleotides.\n        return 0\n\n    allowed_pairs = {('A', 'U'), ('U', 'A'), ('G', 'C'), ('C', 'G'), ('G', 'U'), ('U', 'G')}\n\n    def can_pair(i, j):\n        if i  0 or j = n or i = j:\n            return False\n        return (s[i], s[j]) in allowed_pairs\n\n    # H[i,j]: length of the longest helix starting with pair (i,j)\n    H = np.zeros((n, n), dtype=int)\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if can_pair(i, j):\n                if length == 2:\n                    H[i, j] = 1\n                else:\n                    H[i, j] = 1 + H[i + 1, j - 1]\n\n    # M[i,j]: maximum number of pairs in subsequence s[i...j]\n    M = np.zeros((n, n), dtype=int)\n    # The loop must start from a length where a valid structure can form.\n    # The smallest valid structure is a helix of length 2 which spans 4 bases.\n    for length in range(4, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n\n            # Case 1: Bifurcation. Structure on s[i...j] is a concatenation\n            # of structures on s[i...k] and s[k+1...j].\n            bifurcation_max = 0\n            for k in range(i, j):\n                bifurcation_max = max(bifurcation_max, M[i, k] + M[k + 1, j])\n\n            # Case 2: Closing helix. Structure on s[i...j] is enclosed\n            # by a helix of length p = 2.\n            helix_max = 0\n            helix_len = H[i, j]\n            if helix_len = 2:\n                for p in range(2, helix_len + 1):\n                    # Check if the helix fits within the [i,j] interval.\n                    # This is guaranteed by H, but the inner loop indices must be valid.\n                    if (i + p - 1)  (j - p + 1):\n                        current_helix_pairs = p\n                        inner_pairs = 0\n                        # Calculate pairs in the loop enclosed by the helix\n                        if i + p = j - p:\n                             inner_pairs = M[i + p, j - p]\n                        \n                        helix_max = max(helix_max, current_helix_pairs + inner_pairs)\n\n            M[i, j] = max(bifurcation_max, helix_max)\n\n    return M[0, n - 1]\n\nsolve()\n```", "id": "2426853"}, {"introduction": "While most introductory algorithms focus on linear RNA molecules with distinct $5'$ and $3'$ ends, nature often utilizes circular topologies, as seen in viroids and certain viruses. The absence of ends fundamentally changes the folding problem, as any position can be considered a \"start\" or \"end\", and a pair can span the artificial break in a linear representation. This practice guides you to adapt your algorithmic thinking for circular RNA molecules [@problem_id:2426795]. Your task is to devise a strategy that leverages the power of a linear folding algorithm by cleverly handling the circularity, demonstrating the important skill of reducing a complex problem to a series of solvable subproblems.", "problem": "Design and implement a program that, for each given circular Ribonucleic Acid (RNA) sequence, returns the maximal number of non-crossing complementary base pairs under a formally specified combinatorial model of RNA secondary structure that accounts for the absence of $5'$ and $3'$ ends.\n\nEach circular RNA is modeled as a cyclically ordered set of positions $\\{0,1,\\dots,n-1\\}$ with a label function $S:\\{0,1,\\dots,n-1\\}\\to\\{A,C,G,U\\}$, where $n$ is the sequence length. A secondary structure is a set $P$ of unordered pairs $\\{i,j\\}$ with $i\\neq j$, satisfying all of the following:\n\n- Complementarity rule (parameterized by wobble allowance): either $(S(i),S(j))\\in\\{(A,U),(U,A),(C,G),(G,C)\\}$, or if wobble pairing is allowed (parameter $W=1$), then also $(S(i),S(j))\\in\\{(G,U),(U,G)\\}$. If wobble pairing is disallowed (parameter $W=0$), only the first set of pairs is permitted.\n- Non-crossing constraint: draw the $n$ labeled positions on a circle in cyclic order and draw a chord for each $\\{i,j\\}\\in P$. Then no two chords intersect in the plane.\n- Minimal loop length constraint: fix an integer $L\\ge 0$. For any representation of the circular sequence as a linear string by cutting between two consecutive positions and indexing linearly as $0,1,\\dots,n-1$, a pair $\\{i,j\\}$ with $ij$ is permitted only if $j-i-1\\ge L$ in that linearization.\n- Circularity constraint: there are no special $5'$ or $3'$ ends. To formalize this for computation, define the circular score as\n$$\nF_{\\mathrm{circ}}(S,L,W)=\\max_{k\\in\\{0,1,\\dots,n-1\\}} F_{\\mathrm{lin}}(\\operatorname{rot}_k(S),L,W),\n$$\nwhere $\\operatorname{rot}_k(S)$ is the linear sequence obtained by starting from position $k$ and listing labels in cyclic order, and $F_{\\mathrm{lin}}$ is the maximum number of non-crossing complementary base pairs on that linear sequence subject to the same complementarity and minimal loop length constraints and additionally forbidding a pair between the first and last positions of the linearized sequence (to prevent a pair that would directly span the artificial cut). For $n\\in\\{0,1\\}$, define $F_{\\mathrm{circ}}(S,L,W)=0$.\n\nYour task is to compute $F_{\\mathrm{circ}}(S,L,W)$ for each sequence in the following test suite. Each test case is a triple $(\\text{sequence},L,W)$:\n\n- Case $1$: $\\left(\\text{\"GCAUCUAUGC\"},\\,L=1,\\,W=1\\right)$.\n- Case $2$: $\\left(\\text{\"AAAAAAA\"},\\,L=1,\\,W=1\\right)$.\n- Case $3$: $\\left(\\text{\"AU\"},\\,L=1,\\,W=1\\right)$.\n- Case $4$: $\\left(\\text{\"GUGU\"},\\,L=1,\\,W=1\\right)$.\n- Case $5$: $\\left(\\text{\"GCGC\"},\\,L=1,\\,W=0\\right)$.\n- Case $6$: $\\left(\\text{\"\"},\\,L=1,\\,W=1\\right)$.\n- Case $7$: $\\left(\\text{\"AC\"},\\,L=1,\\,W=0\\right)$.\n\nAll answers must be integers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by the cases above. For example, a valid output format with three integer results would be [$2$,$0$,$1$]. No additional text should be printed.", "solution": "The core of the problem lies in the definition of the circular score, $F_{\\mathrm{circ}}(S,L,W)$, which is formulated as the maximum score over all possible linearizations of the circular sequence:\n$$\nF_{\\mathrm{circ}}(S,L,W) = \\max_{k \\in \\{0, 1, \\dots, n-1\\}} F_{\\mathrm{lin}}(\\operatorname{rot}_k(S),L,W)\n$$\nHere, $\\operatorname{rot}_k(S)$ is the linear sequence of length $n$ obtained by cutting the circle before position $k$. The function $F_{\\mathrm{lin}}$ computes the maximum number of pairs on a linear sequence, with the crucial additional constraint that the first and last bases of this linear sequence are forbidden from pairing. This constraint is to prevent counting pairs that would span the artificial cut point.\n\nOur strategy is therefore to develop a two-level algorithm. The outer level iterates through all $n$ possible rotations of the circular sequence. For each rotation, the inner level calculates its $F_{\\mathrm{lin}}$ score.\n\nThe calculation of $F_{\\mathrm{lin}}$ for a linear sequence $S'$ of length $m$ is the most substantial part. The prohibition of a pair between the ends ($S'_0$ and $S'_{m-1}$) implies that any valid structure must be decomposable at a top level; that is, it must be a linear concatenation of one or more independent, non-crossing substructures. The score for such a structure is obtained by finding the optimal \"split point\" $k'$ that partitions the sequence into two independent subproblems, $S'[0 \\dots k']$ and $S'[k'+1 \\dots m-1]$.\n\nThis structure lends itself to dynamic programming. We first compute a table, let us call it $M$, where $M[i,j]$ stores the maximum number of pairs for any valid non-crossing structure on the subsequence $S'[i \\dots j]$. This is a standard Nussinov-type algorithm. The recurrence relation is:\n$$\nM[i,j] = \\max \\begin{cases}\nM[i, j-1]  (\\text{corresponds to base } j \\text{ being unpaired}) \\\\\n\\max_{k=i}^{j-L-1} \\left( (M[i, k-1] \\text{ if } ki \\text{ else } 0) + M[k+1, j-1] + \\delta(k, j, W) \\right)  (\\text{corresponds to base } j \\text{ pairing with base } k)\n\\end{cases}\n$$\nThe term $\\delta(k, j, W)$ is $1$ if bases $S'_k$ and $S'_j$ form a valid pair (canonical or wobble, depending on $W$), and $0$ otherwise. The condition $k \\le j-L-1$ enforces the minimum loop length constraint, as it implies $j-k-1 \\ge L$. The table $M$ is filled for increasing subsequence lengths, $d = j-i$.\n\nOnce the table $M$ is populated, we can compute $F_{\\mathrm{lin}}(S')$ by considering all possible top-level bifurcations:\n$$\nF_{\\mathrm{lin}}(S') = \\max_{k' \\in \\{0, \\dots, m-2\\}} \\left( M[0, k'] + M[k'+1, m-1] \\right)\n$$\nThis formula correctly captures the score for the best structure that does not pair the ends of $S'$.\n\nThe final algorithm is as follows:\n1. For a given circular sequence $S$, iterate through all $n$ rotations, $\\operatorname{rot}_k(S)$.\n2. For each rotation, compute the full dynamic programming table $M$.\n3. From table $M$, calculate $F_{\\mathrm{lin}}$ using the bifurcation formula.\n4. The maximum $F_{\\mathrm{lin}}$ score found across all rotations is the answer, $F_{\\mathrm{circ}}$.\n\nFor edge cases where sequence length $n$ is $0$ or $1$, the score is defined as $0$. The overall time complexity of this approach is $O(n \\cdot n^3) = O(n^4)$, which is acceptable for the problem's constraints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the RNA secondary structure problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        (\"GCAUCUAUGC\", 1, 1),\n        (\"AAAAAAA\", 1, 1),\n        (\"AU\", 1, 1),\n        (\"GUGU\", 1, 1),\n        (\"GCGC\", 1, 0),\n        (\"\", 1, 1),\n        (\"AC\", 1, 0),\n    ]\n\n    results = []\n    for seq, L, W in test_cases:\n        results.append(compute_f_circ(seq, L, W))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_complementarity_checker(W):\n    \"\"\"\n    Returns a function that checks for base complementarity based on the wobble parameter W.\n    \"\"\"\n    standard_pairs = {('A', 'U'), ('U', 'A'), ('C', 'G'), ('G', 'C')}\n    wobble_pairs = {('G', 'U'), ('U', 'G')}\n    \n    allowed_pairs = standard_pairs\n    if W == 1:\n        allowed_pairs.update(wobble_pairs)\n\n    def is_complementary(b1, b2):\n        return (b1, b2) in allowed_pairs\n\n    return is_complementary\n\ndef calculate_dp_table(seq, L, W):\n    \"\"\"\n    Calculates the Nussinov-style DP table M for a linear sequence.\n    M[i, j] = max pairs in subsequence seq[i...j].\n    \"\"\"\n    m = len(seq)\n    M = np.zeros((m, m), dtype=int)\n    is_complementary = get_complementarity_checker(W)\n\n    for d in range(L + 1, m):  # d is the distance j - i\n        for i in range(m - d):\n            j = i + d\n            \n            # Case 1: base j is unpaired\n            score_unpaired_j = M[i, j - 1]\n            \n            # Case 2: base j pairs with some base k\n            score_paired_j = 0\n            # k must be such that j-k-1 = L, so k = j-L-1\n            for k in range(i, j - L):\n                if is_complementary(seq[k], seq[j]):\n                    score_before_k = M[i, k - 1] if k  i else 0\n                    score_within_pair = M[k + 1, j - 1]\n                    current_pair_score = score_before_k + score_within_pair + 1\n                    if current_pair_score  score_paired_j:\n                        score_paired_j = current_pair_score\n            \n            M[i, j] = max(score_unpaired_j, score_paired_j)\n            \n    return M\n\ndef compute_f_lin(seq, L, W):\n    \"\"\"\n    Computes the score for a linear sequence, forbidding a pair between its ends.\n    \"\"\"\n    m = len(seq)\n    \n    # If the sequence is too short to form any pair satisfying L, score is 0.\n    if m  L + 2:\n        return 0\n        \n    M = calculate_dp_table(seq, L, W)\n    \n    # F_lin is the max score of a structure that doesn't pair the ends 0 and m-1.\n    # This is found by checking all possible bifurcation points.\n    max_score = 0\n    for k_split in range(m - 1):\n        score = M[0, k_split] + M[k_split + 1, m - 1]\n        if score  max_score:\n            max_score = score\n            \n    return max_score\n\ndef compute_f_circ(seq, L, W):\n    \"\"\"\n    Computes the maximal score for a circular RNA sequence by checking all rotations.\n    \"\"\"\n    n = len(seq)\n    if n = 1:\n        return 0\n\n    max_overall_score = 0\n    \n    # For small n, the check over all rotations is efficient.\n    # To avoid recomputing for symmetric sequences, one could track unique rotations.\n    # Hashing rotations is a simple way to do this.\n    seen_rotations = set()\n\n    for k in range(n):\n        rotated_seq = seq[k:] + seq[:k]\n        if rotated_seq in seen_rotations:\n            continue\n        seen_rotations.add(rotated_seq)\n\n        f_lin_score = compute_f_lin(rotated_seq, L, W)\n        if f_lin_score  max_overall_score:\n            max_overall_score = f_lin_score\n            \n    return max_overall_score\n\n# Execute the solution\nsolve()\n```", "id": "2426795"}]}