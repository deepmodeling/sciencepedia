{"hands_on_practices": [{"introduction": "Authenticating ancient DNA (aDNA) is the critical first step in any paleogenomic study. The most reliable signature of authentic aDNA is a characteristic pattern of chemical damage, particularly an excess of cytosine-to-thymine ($C \\to T$) substitutions near the ends of DNA fragments. This exercise guides you through the fundamental bioinformatic task of processing alignment data to quantify these damage patterns, allowing you to generate the \"misincorporation plots\" essential for verifying your sample's age and quality. [@problem_id:2372718]", "problem": "You are to implement a program that computes the raw data underlying a misincorporation plot in ancient deoxyribonucleic acid (DNA) analysis from simplified, fully aligned reads, suitable for modeling ancient DNA damage. In a typical Binary Alignment/Map (BAM) file, mismatches between reads and the reference genome are used to quantify substitution frequencies as a function of distance from the $5'$ and $3'$ ends of the read. For this problem, you are given simplified alignment records in lieu of an actual BAM file. Each alignment record consists of three fields: a read nucleotide string, a reference nucleotide string of identical length, and a strand indicator. Only matches and mismatches are represented; there are no gaps or insertions or deletions.\n\nDefinitions to use:\n- Each base is one of $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$.\n- The strand is either $\\texttt{'+'}$ or $\\texttt{'-'}$. The $5'$ end is at index $0$ for $\\texttt{'+'}$ strand and at index $L-1$ for $\\texttt{'-'}$ strand, where $L$ is the read length. The $3'$ end is at index $L-1$ for $\\texttt{'+'}$ strand and at index $0$ for $\\texttt{'-'}$ strand.\n- For an aligned position index $i$ with $0 \\le i \\le L-1$, define the distance from the $5'$ end as $d_{5} = i$ for $\\texttt{'+'}$ and $d_{5} = L-1-i$ for $\\texttt{'-'}$. Define the distance from the $3'$ end as $d_{3} = L-1-i$ for $\\texttt{'+'}$ and $d_{3} = i$ for $\\texttt{'-'}$.\n- A substitution type is an ordered pair $\\text{X}\\to\\text{Y}$ with $\\text{X},\\text{Y}\\in\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ and $\\text{X}\\ne\\text{Y}$, interpreted as the reference base $\\text{X}$ and read base $\\text{Y}$ at the same aligned position.\n- For each distance $d$ from the $5'$ end (respectively $3'$ end), let $N_{5}(d)$ (respectively $N_{3}(d)$) be the total number of aligned positions across all reads whose distance from that end equals $d$ and for which both read and reference are in $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$. For a specific substitution type $\\text{X}\\to\\text{Y}$, let $C^{\\text{X}\\to\\text{Y}}_{5}(d)$ (respectively $C^{\\text{X}\\to\\text{Y}}_{3}(d)$) be the number of such positions at distance $d$ exhibiting that substitution. Define the frequency of $\\text{X}\\to\\text{Y}$ at distance $d$ from the $5'$ end as $f^{\\text{X}\\to\\text{Y}}_{5}(d) = C^{\\text{X}\\to\\text{Y}}_{5}(d) / N_{5}(d)$, and analogously $f^{\\text{X}\\to\\text{Y}}_{3}(d) = C^{\\text{X}\\to\\text{Y}}_{3}(d) / N_{3}(d)$. If $N_{5}(d) = 0$ (respectively $N_{3}(d) = 0$), define $f^{\\text{X}\\to\\text{Y}}_{5}(d) = 0$ (respectively $f^{\\text{X}\\to\\text{Y}}_{3}(d) = 0$).\n- The total mismatch frequency at a given distance $d$ from an end is the sum of $f^{\\text{X}\\to\\text{Y}}_{\\cdot}(d)$ over all $\\text{X}\\to\\text{Y}$ with $\\text{X}\\ne\\text{Y}$, where $\\cdot$ denotes either $5$ or $3$.\n\nYour program must compute, from the provided test suite of alignment records, the misincorporation frequencies for all $12$ possible substitution types as functions of $d_{5}$ and $d_{3}$ as defined above. Then, for each test case, extract specific scalar values as described below and print all results in a single line.\n\nTest suite (three independent datasets), where each alignment record is a triple $(\\text{read}, \\text{ref}, \\text{strand})$:\n\n- Test case $1$ (general case with mismatches near ends):\n  1. $(\\text{TAGTC}, \\text{CAGTC}, \\texttt{'+'})$\n  2. $(\\text{GGCCT}, \\text{GGCCC}, \\texttt{'-'})$\n  3. $(\\text{ATCGA}, \\text{ATCGG}, \\texttt{'+'})$\n  4. $(\\text{ATTTA}, \\text{GTTTA}, \\texttt{'-'})$\n\n- Test case $2$ (boundary condition with no coverage at large distances):\n  1. $(\\text{CAGT}, \\text{CAGT}, \\texttt{'+'})$\n  2. $(\\text{TGCA}, \\text{TGCA}, \\texttt{'-'})$\n\n- Test case $3$ (edge case with no mismatches):\n  1. $(\\text{ACGT}, \\text{ACGT}, \\texttt{'+'})$\n  2. $(\\text{GGGG}, \\text{GGGG}, \\texttt{'-'})$\n\nRequired outputs to compute and report, in this exact order, as real numbers:\n- From test case $1$:\n  1. $f^{\\text{C}\\to\\text{T}}_{5}(0)$.\n  2. $f^{\\text{G}\\to\\text{A}}_{3}(0)$.\n  3. Total mismatch frequency at $5'$ distance $0$, i.e., $\\sum_{\\text{X}\\ne\\text{Y}} f^{\\text{X}\\to\\text{Y}}_{5}(0)$.\n\n- From test case $2$:\n  4. $f^{\\text{C}\\to\\text{T}}_{5}(10)$.\n\n- From test case $3$:\n  5. Total mismatch frequency at $5'$ distance $0$.\n  6. $f^{\\text{G}\\to\\text{A}}_{3}(0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_{1},\\text{result}_{2},\\dots]$). There are no physical units involved. All numeric values must be output as decimal numbers. If a denominator $N_{5}(d)$ or $N_{3}(d)$ equals $0$, the corresponding frequency must be reported as $0$ by definition.", "solution": "The problem statement has been subjected to rigorous validation and is determined to be sound. It is a well-posed, scientifically grounded problem in the field of computational biology, specifically concerning the analysis of ancient DNA damage patterns. All definitions are mathematically precise, the provided data is consistent, and the objectives are unambiguous. The task is to formalize and implement a standard algorithm for quantifying nucleotide misincorporation frequencies from simplified alignment data.\n\nThe solution is implemented through a systematic, two-stage computational procedure. The first stage involves the aggregation of counts from the raw alignment data. The second stage computes the required frequencies from these aggregated counts.\n\n**1. Data Structures for Count Aggregation**\n\nTo efficiently store the necessary counts, we employ two primary data structures, one for the $5'$ end and one for the $3'$ end. Each structure is a dictionary that maps an integer distance $d$ to an aggregate data record. This record contains two components:\n- A scalar integer, $N(d)$, representing the total number of nucleotide positions observed at distance $d$ from the respective end.\n- A $4 \\times 4$ matrix, $C(d)$, where the entry $C_{\\text{X},\\text{Y}}(d)$ stores the number of times a substitution from reference base $\\text{X}$ to read base $\\text{Y}$ has been observed at distance $d$. The bases $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ are mapped to indices $\\{0, 1, 2, 3\\}$ for this matrix representation.\n\nWe denote these structures as $\\mathcal{D}_5$ and $\\mathcal{D}_3$. Thus, for a distance $d$ from the $5'$ end, the corresponding entry is $\\mathcal{D}_5[d] = (N_5(d), C_5(d))$.\n\n**2. Algorithmic Procedure**\n\n**Stage 1: Aggregation of Counts**\nThe algorithm iterates through each provided alignment record, which is a triplet of (read sequence, reference sequence, strand). For each position $i$ (from $0$ to $L-1$, where $L$ is the read length) within an alignment, the following steps are executed:\n1. The distances from the $5'$ and $3'$ ends, $d_5$ and $d_3$, are calculated based on the position $i$ and the strand orientation.\n   - For a $\\texttt{'+'}$ strand read: $d_5 = i$ and $d_3 = L-1-i$.\n   - For a $\\texttt{'-'}$ strand read: $d_5 = L-1-i$ and $d_3 = i$.\n2. The total base count for the calculated distances are incremented: $N_5(d_5) \\mathrel{+}= 1$ and $N_3(d_3) \\mathrel{+}= 1$.\n3. The reference base $\\text{X}$ and read base $\\text{Y}$ at position $i$ are compared. If they differ ($\\text{X} \\neq \\text{Y}$), it signifies a substitution. The corresponding substitution counters in the matrices $C_5(d_5)$ and $C_3(d_3)$ are incremented. Specifically, $C_{5, \\text{X},\\text{Y}}(d_5) \\mathrel{+}= 1$ and $C_{3, \\text{X},\\text{Y}}(d_3) \\mathrel{+}= 1$.\n\nAfter iterating through all positions of all reads, the dictionaries $\\mathcal{D}_5$ and $\\mathcal{D}_3$ contain the complete aggregated counts required for frequency calculation.\n\n**Stage 2: Computation of Frequencies**\nWith the aggregated counts, any specified frequency can be computed directly from its definition.\n- The frequency of a specific substitution $\\text{X}\\to\\text{Y}$ at a distance $d$ from the $5'$ end is given by:\n  $$f^{\\text{X}\\to\\text{Y}}_{5}(d) = \\frac{C_{5, \\text{X},\\text{Y}}(d)}{N_5(d)}$$\n  An analogous formula applies for the $3'$ end. As stipulated, if $N_5(d) = 0$ (or $N_3(d)=0$), the frequency is defined to be $0$.\n- The total mismatch frequency at a distance $d$ is the sum of all individual substitution frequencies at that distance:\n  $$\\sum_{\\text{X}\\ne\\text{Y}} f^{\\text{X}\\to\\text{Y}}_{5}(d) = \\frac{\\sum_{\\text{X}\\ne\\text{Y}} C_{5, \\text{X},\\text{Y}}(d)}{N_5(d)}$$\n  This is equivalent to the total number of observed mismatches at distance $d$ divided by the total number of observed bases at that same distance.\n\n**Illustrative Calculation for Test Case 1**\nLet us compute the first required value, $f^{\\text{C}\\to\\text{T}}_{5}(0)$, from Test Case $1$.\nThe relevant distance is $d_5=0$. We must first find $N_5(0)$ and $C_{5, \\text{C},\\text{T}}(0)$. We examine each of the $4$ reads for contributions to this distance.\n- Read 1: $(\\text{TAGTC}, \\text{CAGTC}, \\texttt{'+'})$. Strand is $\\texttt{'+'}$, so $d_5=0$ corresponds to index $i=0$. At $i=0$, we have ref='C', read='T', a $\\text{C}\\to\\text{T}$ substitution.\n- Read 2: $(\\text{GGCCT}, \\text{GGCCC}, \\texttt{'-'})$. Strand is $\\texttt{'-'}$, so $d_5=0$ corresponds to index $i=L-1=4$. At $i=4$, we have ref='C', read='T', a $\\text{C}\\to\\text{T}$ substitution.\n- Read 3: $(\\text{ATCGA}, \\text{ATCGG}, \\texttt{'+'})$. Strand is $\\texttt{'+'}$, $d_5=0$ corresponds to $i=0$. At $i=0$, we have ref='A', read='A', a match.\n- Read 4: $(\\text{ATTTA}, \\text{GTTTA}, \\texttt{'-'})$. Strand is $\\texttt{'-'}$, $d_5=0$ corresponds to $i=L-1=4$. At $i=4$, we have ref='A', read='A', a match.\n\nFrom this analysis:\n- The total number of positions at distance $d_5=0$ is $N_5(0) = 4$.\n- The total number of $\\text{C}\\to\\text{T}$ substitutions at this distance is $C_{5, \\text{C},\\text{T}}(0) = 2$.\n\nTherefore, the frequency is:\n$$f^{\\text{C}\\to\\text{T}}_{5}(0) = \\frac{C_{5, \\text{C},\\text{T}}(0)}{N_5(0)} = \\frac{2}{4} = 0.5$$\n\nThe other required values are computed by applying the same rigorous procedure to the corresponding test cases and parameters. This principled approach ensures correctness and reproducibility.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the ancient DNA damage modeling problem by computing misincorporation frequencies.\n    \"\"\"\n    \n    BASE_TO_IDX = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    def compute_counts(records):\n        \"\"\"\n        Aggregates base and substitution counts from alignment records.\n\n        Args:\n            records: A list of tuples, where each tuple is (read_str, ref_str, strand_char).\n\n        Returns:\n            A tuple of two dictionaries (counts_5, counts_3).\n            Each dictionary maps distance `d` to a tuple `(N, C)`, where `N` is the\n            total base count and `C` is a 4x4 numpy array of substitution counts.\n        \"\"\"\n        counts_5 = defaultdict(lambda: [0, np.zeros((4, 4), dtype=int)])\n        counts_3 = defaultdict(lambda: [0, np.zeros((4, 4), dtype=int)])\n\n        for read, ref, strand in records:\n            read_len = len(read)\n            for i in range(read_len):\n                if strand == '+':\n                    d5 = i\n                    d3 = read_len - 1 - i\n                else:  # strand == '-'\n                    d5 = read_len - 1 - i\n                    d3 = i\n\n                ref_base = ref[i]\n                read_base = read[i]\n\n                # Update 5-prime counts\n                counts_5[d5][0] += 1\n                if ref_base != read_base:\n                    ref_idx = BASE_TO_IDX[ref_base]\n                    read_idx = BASE_TO_IDX[read_base]\n                    counts_5[d5][1][ref_idx, read_idx] += 1\n\n                # Update 3-prime counts\n                counts_3[d3][0] += 1\n                if ref_base != read_base:\n                    ref_idx = BASE_TO_IDX[ref_base]\n                    read_idx = BASE_TO_IDX[read_base]\n                    counts_3[d3][1][ref_idx, read_idx] += 1\n        \n        return dict(counts_5), dict(counts_3)\n\n    test_cases = [\n        # Test case 1\n        [\n            ('TAGTC', 'CAGTC', '+'),\n            ('GGCCT', 'GGCCC', '-'),\n            ('ATCGA', 'ATCGG', '+'),\n            ('ATTTA', 'GTTTA', '-')\n        ],\n        # Test case 2\n        [\n            ('CAGT', 'CAGT', '+'),\n            ('TGCA', 'TGCA', '-')\n        ],\n        # Test case 3\n        [\n            ('ACGT', 'ACGT', '+'),\n            ('GGGG', 'GGGG', '-')\n        ]\n    ]\n\n    results = []\n\n    # Process Test Case 1\n    counts_5_1, counts_3_1 = compute_counts(test_cases[0])\n    \n    # 1. f_C->T_5(0) for test case 1\n    n5_d0, c5_d0 = counts_5_1.get(0, (0, None))\n    if n5_d0 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['C'], BASE_TO_IDX['T']\n        res1 = c5_d0[ref_idx, read_idx] / n5_d0\n    else:\n        res1 = 0.0\n    results.append(res1)\n    \n    # 2. f_G->A_3(0) for test case 1\n    n3_d0, c3_d0 = counts_3_1.get(0, (0, None))\n    if n3_d0 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['G'], BASE_TO_IDX['A']\n        res2 = c3_d0[ref_idx, read_idx] / n3_d0\n    else:\n        res2 = 0.0\n    results.append(res2)\n\n    # 3. Total mismatch frequency at 5' distance 0 for test case 1\n    if n5_d0 > 0:\n        total_mismatches = c5_d0.sum()\n        res3 = total_mismatches / n5_d0\n    else:\n        res3 = 0.0\n    results.append(res3)\n\n    # Process Test Case 2\n    counts_5_2, _ = compute_counts(test_cases[1])\n    \n    # 4. f_C->T_5(10) for test case 2\n    n5_d10, c5_d10 = counts_5_2.get(10, (0, None))\n    if n5_d10 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['C'], BASE_TO_IDX['T']\n        res4 = c5_d10[ref_idx, read_idx] / n5_d10\n    else:\n        res4 = 0.0\n    results.append(res4)\n\n    # Process Test Case 3\n    counts_5_3, counts_3_3 = compute_counts(test_cases[2])\n    \n    # 5. Total mismatch frequency at 5' distance 0 for test case 3\n    n5_d0_3, c5_d0_3 = counts_5_3.get(0, (0, None))\n    if n5_d0_3 > 0:\n        total_mismatches_3 = c5_d0_3.sum()\n        res5 = total_mismatches_3 / n5_d0_3\n    else:\n        res5 = 0.0\n    results.append(res5)\n\n    # 6. f_G->A_3(0) for test case 3\n    n3_d0_3, c3_d0_3 = counts_3_3.get(0, (0, None))\n    if n3_d0_3 > 0:\n        ref_idx, read_idx = BASE_TO_IDX['G'], BASE_TO_IDX['A']\n        res6 = c3_d0_3[ref_idx, read_idx] / n3_d0_3\n    else:\n        res6 = 0.0\n    results.append(res6)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.1f}' for r in results)}]\")\n\nsolve()\n```", "id": "2372718"}, {"introduction": "Beyond serving as a marker of authenticity, aDNA damage can introduce systematic biases that skew biological interpretations if not properly understood. This practice explores a common artifact known as reference bias, where the interplay between $C \\to T$ damage and the read alignment process can lead to inaccurate estimates of allele frequencies. By developing a simple probabilistic model, you will gain a quantitative intuition for how damaged reads that happen to match the reference allele are preferentially retained, a crucial skill for critically evaluating population genetic inferences from ancient samples. [@problem_id:2372729]", "problem": "You are asked to formalize and implement a minimal, first-principles probabilistic model capturing reference-alignment bias at a single deoxyribonucleic acid (DNA) polymorphic site subject to ancient DNA damage. Consider a single cytosine/thymine (C/T) polymorphic site in an ancient sample. Let the true population frequency of the ancestral cytosine allele be $f_{\\mathrm{C}} \\in [0,1]$, so the thymine frequency is $1 - f_{\\mathrm{C}}$. Each sequencing read covering the site originates from a chromosome carrying $\\mathrm{C}$ with probability $f_{\\mathrm{C}}$ and from a chromosome carrying $\\mathrm{T}$ with probability $1 - f_{\\mathrm{C}}$. Damage is modeled as cytosine deamination: if the underlying allele is $\\mathrm{C}$, the observed base flips to $\\mathrm{T}$ with probability $p_{\\mathrm{d}} \\in [0,1]$, and remains $\\mathrm{C}$ with probability $1 - p_{\\mathrm{d}}$. Reads from $\\mathrm{T}$ are unaffected by this damage model. Assume no other sequencing errors. A read is retained after alignment to a reference genome according to a reference-bias retention mechanism: at this site, the reference allele $R \\in \\{\\mathrm{C},\\mathrm{T}\\}$ is given. If the read’s observed base at this site equals $R$, it is retained with probability $s_{\\mathrm{match}} \\in [0,1]$; if it does not equal $R$, it is retained with probability $s_{\\mathrm{mismatch}} \\in [0,1]$. All reads act independently under this model.\n\nYour task is, for each parameter set below, to compute two quantities based on the expectation over the generative process: (i) the expected observed fraction of $\\mathrm{C}$ among aligned reads, denoted $p_{\\mathrm{obsC}}$, and (ii) the underestimation of the true $\\mathrm{C}$ frequency induced by damage and alignment, defined as $\\Delta = p_{\\mathrm{obsC}} - f_{\\mathrm{C}}$. Report both $p_{\\mathrm{obsC}}$ and $\\Delta$ as decimals (not percentages), rounded to six decimal places.\n\nTest suite (each case is $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}})$):\n- Case A: $(0.6, 0.25, T, 0.95, 0.70)$.\n- Case B: $(0.6, 0.0, T, 0.90, 0.90)$.\n- Case C: $(0.4, 0.30, T, 0.90, 0.90)$.\n- Case D: $(0.6, 0.25, C, 0.95, 0.70)$.\n- Case E: $(0.7, 1.0, T, 0.95, 0.70)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is a two-element list $[p_{\\mathrm{obsC}}, \\Delta]$ for the corresponding test case in the order A, B, C, D, E. For example, a valid output format is $[[x_{A},y_{A}],[x_{B},y_{B}],[x_{C},y_{C}],[x_{D},y_{D}],[x_{E},y_{E}]]$ with each $x_{i},y_{i}$ rounded to six decimal places.", "solution": "The problem as stated is subjected to validation prior to any attempt at a solution.\n\nGivens are extracted verbatim:\n- True population frequency of the ancestral cytosine allele: $f_{\\mathrm{C}} \\in [0,1]$.\n- True population frequency of the thymine allele: $1 - f_{\\mathrm{C}}$.\n- Probability that a read originates from a C-carrying chromosome: $f_{\\mathrm{C}}$.\n- Probability that a read originates from a T-carrying chromosome: $1 - f_{\\mathrm{C}}$.\n- Cytosine deamination probability (C to T): $p_{\\mathrm{d}} \\in [0,1]$.\n- Reference allele at the polymorphic site: $R \\in \\{\\mathrm{C},\\mathrm{T}\\}$.\n- Retention probability for a read whose observed base matches the reference: $s_{\\mathrm{match}} \\in [0,1]$.\n- Retention probability for a read whose observed base mismatches the reference: $s_{\\mathrm{mismatch}} \\in [0,1]$.\n- All reads are independent.\n- Quantities to compute:\n    1. Expected observed fraction of C among aligned reads: $p_{\\mathrm{obsC}}$.\n    2. Underestimation of true C frequency: $\\Delta = p_{\\mathrm{obsC}} - f_{\\mathrm{C}}$.\n- Test Cases:\n    - Case A: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.6, 0.25, T, 0.95, 0.70)$.\n    - Case B: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.6, 0.0, T, 0.90, 0.90)$.\n    - Case C: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.4, 0.30, T, 0.90, 0.90)$.\n    - Case D: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.6, 0.25, C, 0.95, 0.70)$.\n    - Case E: $(f_{\\mathrm{C}}, p_{\\mathrm{d}}, R, s_{\\mathrm{match}}, s_{\\mathrm{mismatch}}) = (0.7, 1.0, T, 0.95, 0.70)$.\n\nValidation Verdict:\nThe problem is valid. It is scientifically grounded in the principles of population genetics and molecular biology, specifically modeling ancient DNA damage (cytosine deamination) and sequencing artifacts (reference bias). It is well-posed, objective, self-contained, and mathematically formalizable. All parameters are defined and provided. The problem does not violate any of the specified criteria for invalidity. We may proceed with the derivation of a solution.\n\nDerivation of the solution:\nThe quantity of interest, $p_{\\mathrm{obsC}}$, is the expected fraction of cytosine bases among all reads that are successfully aligned to the reference genome. This is a conditional probability: the probability that a read is observed as $\\mathrm{C}$, given that it has been retained after alignment.\n\nLet us define the following events for a single, randomly selected sequencing read:\n- $A_C$: The true, underlying allele is Cytosine ($\\mathrm{C}$). $P(A_C) = f_{\\mathrm{C}}$.\n- $A_T$: The true, underlying allele is Thymine ($\\mathrm{T}$). $P(A_T) = 1 - f_{\\mathrm{C}}$.\n- $O_C$: The observed base in the read is $\\mathrm{C}$.\n- $O_T$: The observed base in the read is $\\mathrm{T}$.\n- $S$: The read is retained after the alignment step (i.e., it survives).\n\nWe seek to compute $p_{\\mathrm{obsC}} = P(O_C | S)$. Using the definition of conditional probability, this is:\n$$p_{\\mathrm{obsC}} = \\frac{P(O_C \\cap S)}{P(S)}$$\nThe numerator is the joint probability that a read is observed as $\\mathrm{C}$ and is retained. The denominator is the total probability that a read is retained. We will compute both terms using the law of total probability, conditioning on the true allele.\n\nFirst, let's define a retention probability function, $s(B, R)$, where $B$ is the observed base and $R$ is the reference allele.\n$$\ns(B, R) =\n\\begin{cases}\ns_{\\mathrm{match}} & \\text{if } B = R \\\\\ns_{\\mathrm{mismatch}} & \\text{if } B \\neq R\n\\end{cases}\n$$\n\nNext, we calculate the joint probabilities of observation and survival, conditioned on the true allele:\n1.  If the true allele is $\\mathrm{C}$ (event $A_C$):\n    - The base is observed as $\\mathrm{C}$ with probability $1 - p_{\\mathrm{d}}$. The retention probability is then $s(\\mathrm{C}, R)$.\n    - The base is observed as $\\mathrm{T}$ (due to deamination) with probability $p_{\\mathrm{d}}$. The retention probability is then $s(\\mathrm{T}, R)$.\n    - Thus, $P(O_C \\cap S | A_C) = (1 - p_{\\mathrm{d}}) \\cdot s(\\mathrm{C}, R)$.\n    - The total probability of survival given true allele $\\mathrm{C}$ is $P(S | A_C) = (1 - p_{\\mathrm{d}}) \\cdot s(\\mathrm{C}, R) + p_{\\mathrm{d}} \\cdot s(\\mathrm{T}, R)$.\n\n2.  If the true allele is T (event $A_T$):\n    - The base is always observed as $\\mathrm{T}$ (probability $1$). The retention probability is $s(\\mathrm{T}, R)$.\n    - Thus, $P(O_C \\cap S | A_T) = 0$, as a true $\\mathrm{T}$ cannot be observed as a $\\mathrm{C}$ in this model.\n    - The total probability of survival given true allele $\\mathrm{T}$ is $P(S | A_T) = 1 \\cdot s(\\mathrm{T}, R) = s(\\mathrm{T}, R)$.\n\nNow we can find the unconditional probabilities $P(O_C \\cap S)$ and $P(S)$:\nThe probability of observing a $\\mathrm{C}$ and the read being retained is:\n$$P(O_C \\cap S) = P(O_C \\cap S | A_C)P(A_C) + P(O_C \\cap S | A_T)P(A_T)$$\n$$P(O_C \\cap S) = [(1 - p_{\\mathrm{d}})s(\\mathrm{C}, R)] f_{\\mathrm{C}} + [0](1 - f_{\\mathrm{C}}) = f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s(\\mathrm{C}, R)$$\n\nThe total probability of a read being retained is:\n$$P(S) = P(S | A_C)P(A_C) + P(S | A_T)P(A_T)$$\n$$P(S) = [ (1 - p_{\\mathrm{d}})s(\\mathrm{C}, R) + p_{\\mathrm{d}}s(\\mathrm{T}, R) ] f_{\\mathrm{C}} + [s(\\mathrm{T}, R)](1 - f_{\\mathrm{C}})$$\n\nCombining these, the expected observed fraction of $\\mathrm{C}$ is:\n$$p_{\\mathrm{obsC}} = \\frac{f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s(\\mathrm{C}, R)}{[ (1 - p_{\\mathrm{d}})s(\\mathrm{C}, R) + p_{\\mathrm{d}}s(\\mathrm{T}, R) ] f_{\\mathrm{C}} + s(\\mathrm{T}, R)(1 - f_{\\mathrm{C}})}$$\n\nThis general formula is now specialized for the two possible reference alleles, $R \\in \\{\\mathrm{C},\\mathrm{T}\\}$.\n\nCase 1: Reference allele is $\\mathrm{T}$ ($R=\\mathrm{T}$)\nHere, $s(\\mathrm{C}, \\mathrm{T}) = s_{\\mathrm{mismatch}}$ and $s(\\mathrm{T}, \\mathrm{T}) = s_{\\mathrm{match}}$.\n$$p_{\\mathrm{obsC}} = \\frac{f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s_{\\mathrm{mismatch}}}{[ (1 - p_{\\mathrm{d}})s_{\\mathrm{mismatch}} + p_{\\mathrm{d}}s_{\\mathrm{match}} ] f_{\\mathrm{C}} + s_{\\mathrm{match}} (1 - f_{\\mathrm{C}})}$$\n\nCase 2: Reference allele is $\\mathrm{C}$ ($R=\\mathrm{C}$)\nHere, $s(\\mathrm{C}, \\mathrm{C}) = s_{\\mathrm{match}}$ and $s(\\mathrm{T}, \\mathrm{C}) = s_{\\mathrm{mismatch}}$.\n$$p_{\\mathrm{obsC}} = \\frac{f_{\\mathrm{C}} (1 - p_{\\mathrm{d}}) s_{\\mathrm{match}}}{[ (1 - p_{\\mathrm{d}})s_{\\mathrm{match}} + p_{\\mathrm{d}}s_{\\mathrm{mismatch}} ] f_{\\mathrm{C}} + s_{\\mathrm{mismatch}} (1 - f_{\\mathrm{C}})}$$\n\nFor each test case, the appropriate formula is used to calculate $p_{\\mathrm{obsC}}$. The underestimation, $\\Delta$, is then computed as $\\Delta = p_{\\mathrm{obsC}} - f_{\\mathrm{C}}$. The results are rounded to six decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the ancient DNA damage modeling problem for a series of test cases.\n    \"\"\"\n\n    # Test suite (each case is (f_C, p_d, R, s_match, s_mismatch))\n    test_cases = [\n        # Case A\n        (0.6, 0.25, 'T', 0.95, 0.70),\n        # Case B\n        (0.6, 0.0, 'T', 0.90, 0.90),\n        # Case C\n        (0.4, 0.30, 'T', 0.90, 0.90),\n        # Case D\n        (0.6, 0.25, 'C', 0.95, 0.70),\n        # Case E\n        (0.7, 1.0, 'T', 0.95, 0.70),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        f_C, p_d, R, s_match, s_mismatch = case\n\n        # Assign retention probabilities based on the reference allele\n        if R == 'C':\n            s_C_R = s_match\n            s_T_R = s_mismatch\n        elif R == 'T':\n            s_C_R = s_mismatch\n            s_T_R = s_match\n        else:\n            # This case should not occur based on problem description\n            continue\n            \n        # Calculate the numerator of the p_obsC formula: P(O_C and S)\n        # This is the probability that a read comes from a true C, is observed as C, and is retained.\n        numerator = f_C * (1 - p_d) * s_C_R\n\n        # Calculate the denominator of the p_obsC formula: P(S)\n        # This is the total probability that any read is retained.\n        # It's the sum of probabilities of retention for reads from true C and true T chromosomes.\n        prob_S_from_C = ((1 - p_d) * s_C_R + p_d * s_T_R) * f_C\n        prob_S_from_T = s_T_R * (1 - f_C)\n        denominator = prob_S_from_C + prob_S_from_T\n\n        # Calculate the expected observed fraction of C among aligned reads\n        if denominator == 0:\n            # This would only occur if no reads can be retained, e.g., s_match=s_mismatch=0.\n            # In this scenario, p_obsC is undefined, but for computational purposes, we can set it to 0.\n            p_obsC = 0.0\n        else:\n            p_obsC = numerator / denominator\n        \n        # Calculate the underestimation of the C frequency\n        delta = p_obsC - f_C\n\n        # Round results to six decimal places\n        p_obsC_rounded = round(p_obsC, 6)\n        delta_rounded = round(delta, 6)\n\n        all_results.append([p_obsC_rounded, delta_rounded])\n\n    # Final print statement in the exact required format.\n    # The string representation of a list of lists is converted to a string,\n    # and all whitespace is removed to match the specified format.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2372729"}, {"introduction": "Since we can observe and model the patterns of aDNA damage, we can also design analytical methods to explicitly correct for them. This exercise challenges you to implement a simplified Bayesian consensus caller, moving beyond a naive majority-vote approach to a more robust statistical inference. By incorporating a parameter for the $C \\to T$ damage rate directly into your model, you will learn to calculate the posterior probability for each possible true nucleotide and make a more accurate, \"damage-aware\" call, a foundational technique in the accurate reconstruction of ancient genomes. [@problem_id:2372702]", "problem": "Implement a damage-aware consensus caller for ancient Deoxyribonucleic Acid (aDNA) based on a simple generative model. At a single genomic position, you are given the observed read counts of the four nucleotides adenine, cytosine, guanine, and thymine in this order, and two parameters: a baseline sequencing error rate and a fixed cytosine-to-thymine damage rate. Assume the following:\n\n- The true base at the position, denoted by $B \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$, is unknown and has a uniform prior probability $P(B=\\mathrm{A})=P(B=\\mathrm{C})=P(B=\\mathrm{G})=P(B=\\mathrm{T})=\\frac{1}{4}$.\n- Conditional on $B$, the observed base calls across reads are independent and identically distributed samples from a categorical distribution with base-specific emission probabilities.\n- Let the baseline sequencing error rate be $\\epsilon \\in [0,1)$ and the fixed cytosine-to-thymine damage rate be $\\delta \\in [0,1-\\epsilon]$.\n- For $B \\neq \\mathrm{C}$, the emission probabilities are: the correct base is emitted with probability $1-\\epsilon$, and each of the three incorrect bases is emitted with probability $\\epsilon/3$.\n- For $B=\\mathrm{C}$, the damage increases the probability of reporting $\\mathrm{T}$ from $\\epsilon/3$ to $\\delta+\\epsilon/3$ while reducing the probability of correctly emitting $\\mathrm{C}$ so that probabilities sum to $1$. Thus, for $B=\\mathrm{C}$: $P(\\mathrm{C}|\\mathrm{C})=1-(\\epsilon+\\delta)$, $P(\\mathrm{T}|\\mathrm{C})=\\delta+\\epsilon/3$, and $P(\\mathrm{A}|\\mathrm{C})=P(\\mathrm{G}|\\mathrm{C})=\\epsilon/3$.\n\nGiven observed counts $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$, treat the data likelihood under candidate true base $b$ as a multinomial model with parameters determined by the corresponding emission probabilities for $b$. Use the uniform prior to compute the posterior $P(B=b \\mid \\mathbf{c}, \\epsilon, \\delta)$ over $b \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ by Bayes’ rule. The consensus call is the base $b$ that maximizes this posterior. In case of an exact tie (posterior values equal within an absolute tolerance of $10^{-12}$), choose the base with the smallest index under the mapping $\\mathrm{A} \\mapsto 0$, $\\mathrm{C} \\mapsto 1$, $\\mathrm{G} \\mapsto 2$, $\\mathrm{T} \\mapsto 3$.\n\nYour program must implement this model from first principles and, for each test case, output:\n- the consensus call index as an integer using the mapping above, and\n- the posterior probability of that called base as a decimal number rounded to $6$ decimal places.\n\nIf the total read count is zero, i.e., $c_{\\mathrm{A}}+c_{\\mathrm{C}}+c_{\\mathrm{G}}+c_{\\mathrm{T}}=0$, the posterior is uniform and equals $1/4$ for each base; apply the tie-breaking rule described above.\n\nTest Suite:\nUse the following test cases, each specified as $\\left(\\mathbf{c}, \\epsilon, \\delta\\right)$ with $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$.\n\n1. $\\left((2,8,1,5),\\, 0.01,\\, 0.20\\right)$\n2. $\\left((0,0,0,0),\\, 0.01,\\, 0.20\\right)$\n3. $\\left((0,0,0,10),\\, 0.01,\\, 0.30\\right)$\n4. $\\left((0,3,0,7),\\, 0.01,\\, 0.25\\right)$\n5. $\\left((1,1,1,1),\\, 0.01,\\, 0.20\\right)$\n\nFinal Output Format:\nYour program should produce a single line of output containing a list with one entry per test case, preserving the order above. Each entry must be a two-element list of the form $\\left[\\text{call\\_index}, \\text{posterior\\_rounded}\\right]$, where $\\text{call\\_index}$ is an integer and $\\text{posterior\\_rounded}$ is a decimal number rounded to $6$ decimal places. The entire output must be a comma-separated list enclosed in square brackets, for example: $[[0,0.500000],[3,0.875000],\\dots]$.", "solution": "We translate the problem into a principled probabilistic inference task. Let the observed counts be $\\mathbf{c}=(c_{\\mathrm{A}},c_{\\mathrm{C}},c_{\\mathrm{G}},c_{\\mathrm{T}})$ with total $N=c_{\\mathrm{A}}+c_{\\mathrm{C}}+c_{\\mathrm{G}}+c_{\\mathrm{T}}$. Let the baseline sequencing error rate be $\\epsilon \\in [0,1)$ and the fixed cytosine-to-thymine damage rate be $\\delta \\in [0,1-\\epsilon]$. The true base $B$ has a uniform prior $P(B=b)=\\frac{1}{4}$ for all $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$.\n\nBy the model:\n- For $b \\in \\{\\mathrm{A},\\mathrm{G},\\mathrm{T}\\}$, the emission probabilities are\n$$\nP(\\mathrm{A}\\mid b)=\\begin{cases}\n1-\\epsilon & \\text{if } b=\\mathrm{A}\\\\\n\\epsilon/3 & \\text{if } b\\neq \\mathrm{A}\n\\end{cases},\\quad\nP(\\mathrm{C}\\mid b)=\\begin{cases}\n1-\\epsilon & \\text{if } b=\\mathrm{C}\\\\\n\\epsilon/3 & \\text{if } b\\neq \\mathrm{C}\n\\end{cases},\n$$\nand similarly for $\\mathrm{G}$ and $\\mathrm{T}$ with the correct base having probability $1-\\epsilon$ and each incorrect base having probability $\\epsilon/3$.\n- For $b=\\mathrm{C}$, the damage modifies two entries:\n$$\nP(\\mathrm{C}\\mid \\mathrm{C})=1-(\\epsilon+\\delta),\\quad\nP(\\mathrm{T}\\mid \\mathrm{C})=\\delta+\\epsilon/3,\\quad\nP(\\mathrm{A}\\mid \\mathrm{C})=\\epsilon/3,\\quad\nP(\\mathrm{G}\\mid \\mathrm{C})=\\epsilon/3.\n$$\nBy construction these probabilities are nonnegative and sum to $1$ if $\\delta \\in [0,1-\\epsilon]$.\n\nGiven $b$, the likelihood of observing $\\mathbf{c}$ is multinomial:\n$$ \\mathcal{L}(\\mathbf{c} \\mid B=b) \\propto \\prod_{x \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} P(x\\mid b)^{c_x} . $$\nThe multinomial coefficient does not depend on $b$ and cancels in posterior ratios. With the uniform prior, the unnormalized posterior is proportional to the likelihood. Thus,\n$$ P(B=b \\mid \\mathbf{c},\\epsilon,\\delta) = \\frac{\\prod_{x} P(x\\mid b)^{c_x}}{\\sum_{b' \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} \\prod_{x} P(x\\mid b')^{c_x}} . $$\nFor numerical stability and to handle very small probabilities, it is advantageous to compute in log-space using the fact that for $p>0$, $\\log\\left(\\prod_x p_x^{c_x}\\right) = \\sum_x c_x \\log p_x$. Define\n$$ \\ell(b) = \\sum_{x \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}} c_x \\log P(x\\mid b) . $$\nThen use the log-sum-exp identity to normalize:\n$$ P(B=b \\mid \\mathbf{c},\\epsilon,\\delta) = \\frac{\\exp\\left(\\ell(b) - m\\right)}{\\sum_{b'} \\exp\\left(\\ell(b') - m\\right)},\\quad \\text{where } m=\\max_{b'} \\ell(b') . $$\nSpecial case: if $N=0$, then each $\\ell(b)=0$ (empty sum), so each posterior is $1/4$. For consensus calling, select $b^\\star \\in \\arg\\max_b P(B=b \\mid \\mathbf{c},\\epsilon,\\delta)$. If multiple bases tie within an absolute tolerance of $10^{-12}$, choose the smallest index under the mapping $\\mathrm{A} \\mapsto 0$, $\\mathrm{C} \\mapsto 1$, $\\mathrm{G} \\mapsto 2$, $\\mathrm{T} \\mapsto 3$. Report the index of $b^\\star$ and the corresponding posterior probability rounded to $6$ decimal places.\n\nApplying this procedure to each test case yields a deterministic consensus index and a posterior probability consistent with the specified damage-aware generative model, with the damage specifically increasing $\\mathrm{C} \\to \\mathrm{T}$ observations relative to baseline sequencing error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Mapping: A->0, C->1, G->2, T->3\nBASES = ['A', 'C', 'G', 'T']\n\ndef emission_probs_for_base(base_index: int, eps: float, delta: float) -> np.ndarray:\n    \"\"\"\n    Construct emission probabilities P(x | B = base_index) for x in {A,C,G,T}\n    under the simplified damage model:\n      - For B != C: correct base with 1 - eps; each incorrect base eps / 3\n      - For B == C: P(C|C) = 1 - (eps + delta)\n                     P(T|C) = delta + eps/3\n                     P(A|C) = P(G|C) = eps/3\n    \"\"\"\n    p = np.full(4, eps / 3.0, dtype=float)\n    if base_index == 1:  # C\n        p[1] = 1.0 - (eps + delta)\n        p[3] = delta + eps / 3.0\n    else:\n        p[base_index] = 1.0 - eps\n    return p\n\ndef log_likelihood(counts: np.ndarray, p: np.ndarray) -> float:\n    \"\"\"\n    Compute sum_i counts[i] * log(p[i]), returning -inf if any probability is zero where count > 0.\n    \"\"\"\n    # Handle zero probabilities explicitly\n    with np.errstate(divide='ignore'):\n        logs = np.log(p)\n    # If p[i] == 0 and counts[i] > 0, the term is -inf.\n    mask_positive_counts = counts > 0\n    if np.any((p == 0.0) & mask_positive_counts):\n        return -np.inf\n    return float(np.dot(counts[mask_positive_counts], logs[mask_positive_counts]))\n\ndef posterior_and_call(counts: np.ndarray, eps: float, delta: float, tol: float = 1e-12):\n    \"\"\"\n    Compute posterior over bases and return (call_index, posterior_of_call).\n    Tie-breaks by smallest index within absolute tolerance 'tol'.\n    \"\"\"\n    lls = []\n    for b in range(4):\n        p = emission_probs_for_base(b, eps, delta)\n        ll = log_likelihood(counts, p)\n        lls.append(ll)\n    lls = np.array(lls, dtype=float)\n\n    # Normalize using log-sum-exp\n    m = np.max(lls)\n    with np.errstate(over='ignore', under='ignore'):\n        w = np.exp(lls - m)\n    Z = float(np.sum(w))\n    post = w / Z if Z > 0.0 else np.full(4, 0.25)  # Fallback shouldn't trigger unless all -inf; N=0 handled naturally\n\n    # Determine call with tie-breaking\n    max_post = float(np.max(post))\n    candidate_indices = np.where(np.abs(post - max_post) <= tol)[0]\n    call_index = int(np.min(candidate_indices))\n\n    return call_index, float(post[call_index])\n\ndef format_results_list(results):\n    \"\"\"\n    Format results as a single-line string: [[idx,posterior],...]\n    with posterior rounded to 6 decimal places.\n    \"\"\"\n    parts = []\n    for idx, post in results:\n        parts.append(f\"[{idx},{format(round(post + 0.0, 6), '.6f')}]\")\n    return \"[\" + \",\".join(parts) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (counts[A,C,G,T], epsilon, delta)\n    test_cases = [\n        ((2, 8, 1, 5), 0.01, 0.20),\n        ((0, 0, 0, 0), 0.01, 0.20),\n        ((0, 0, 0, 10), 0.01, 0.30),\n        ((0, 3, 0, 7), 0.01, 0.25),\n        ((1, 1, 1, 1), 0.01, 0.20),\n    ]\n\n    results = []\n    for counts_tuple, eps, delta in test_cases:\n        counts = np.array(counts_tuple, dtype=float)\n        call_idx, post_call = posterior_and_call(counts, eps, delta, tol=1e-12)\n        results.append((call_idx, post_call))\n\n    # Final print statement in the exact required format.\n    print(format_results_list(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2372702"}]}