{"hands_on_practices": [{"introduction": "We begin our practical journey with Maximum Parsimony, an intuitive method for Ancestral Sequence Reconstruction rooted in the principle of selecting the simplest evolutionary history. While powerful, this method can sometimes lead to ambiguity, where multiple ancestral states are equally parsimonious. This exercise [@problem_id:2099385] challenges you to identify a specific scenario on a phylogenetic tree where this ambiguity arises, providing a crucial insight into the limitations of parsimony and setting the stage for more sophisticated probabilistic approaches.", "problem": "In the field of evolutionary biology, ancestral sequence reconstruction is a computational method used to infer the protein or nucleic acid sequences of extinct ancestors. One of the simplest and most fundamental methods for this task is the principle of maximum parsimony. This principle states that the preferred evolutionary history is the one that requires the smallest number of evolutionary changes (e.g., amino acid substitutions) to explain the sequences observed in modern-day organisms.\n\nConsider a set of four homologous proteins: P1, P2, P3, and P4. Their evolutionary relationship is described by the phylogenetic tree `((P1, P2)Anc1, (P3, P4)Anc2)Anc-Root`. This notation means that P1 and P2 share a recent common ancestor, Anc1. Similarly, P3 and P4 share a recent common ancestor, Anc2. Both Anc1 and Anc2, in turn, descend from a last common ancestor for all four proteins, Anc-Root.\n\nWe are examining a single position in the alignment of these four protein sequences. For any given ancestor in the tree, a reconstruction of the amino acid at this position is considered \"unambiguous\" if a single amino acid state minimizes the total number of substitutions to its descendants. Conversely, the reconstruction is \"ambiguous\" if two or more different amino acid states are equally parsimonious, meaning they result in the same minimum number of substitutions.\n\nThe options below list the amino acids found at this specific position for the four modern proteins (P1, P2, P3, P4), using their standard single-letter codes. Which of the following scenarios results in an ambiguous reconstruction for the root ancestor, Anc-Root, while simultaneously ensuring that the reconstructions for *both* intermediate ancestors, Anc1 and Anc2, are unambiguous?\n\nA. P1: Alanine (A), P2: Alanine (A), P3: Glycine (G), P4: Glycine (G)\n\nB. P1: Cysteine (C), P2: Cysteine (C), P3: Cysteine (C), P4: Cysteine (C)\n\nC. P1: Leucine (L), P2: Leucine (L), P3: Leucine (L), P4: Valine (V)\n\nD. P1: Proline (P), P2: Serine (S), P3: Proline (P), P4: Serine (S)\n\nE. P1: Threonine (T), P2: Aspartate (D), P3: Glutamate (E), P4: Phenylalanine (F)", "solution": "We use Fitch parsimony on the rooted binary tree $((P1,P2)\\,\\text{Anc1},\\,(P3,P4)\\,\\text{Anc2})\\,\\text{Anc-Root}$. For any node with child state sets $S_{L}$ and $S_{R}$, the minimal-state set is\n$$\nS=\\begin{cases}\nS_{L}\\cap S_{R}, & \\text{if } S_{L}\\cap S_{R}\\neq \\varnothing,\\\\\nS_{L}\\cup S_{R}, & \\text{if } S_{L}\\cap S_{R}=\\varnothing.\n\\end{cases}\n$$\nA node is unambiguous if its set has size $1$ and ambiguous if its set has size at least $2$.\n\nOption A: P1=A, P2=A, P3=G, P4=G.\nAnc1: $S_{1}=\\{A\\}\\cap\\{A\\}=\\{A\\}$ (unambiguous).\nAnc2: $S_{2}=\\{G\\}\\cap\\{G\\}=\\{G\\}$ (unambiguous).\nRoot: $S_{R}=\\{A\\}\\cap\\{G\\}=\\varnothing \\Rightarrow S_{R}=\\{A,G\\}$ (ambiguous).\nThis satisfies the requirement.\n\nOption B: all C.\nAnc1: $\\{C\\}$; Anc2: $\\{C\\}$; Root: $\\{C\\}\\cap\\{C\\}=\\{C\\}$ (unambiguous). Fails.\n\nOption C: P1=L, P2=L; P3=L, P4=V.\nAnc1: $\\{L\\}$ (unambiguous).\nAnc2: $\\{L\\}\\cap\\{V\\}=\\varnothing \\Rightarrow \\{L,V\\}$ (ambiguous).\nRoot: $\\{L\\}\\cap\\{L,V\\}=\\{L\\}$ (unambiguous). Fails.\n\nOption D: P1=P, P2=S; P3=P, P4=S.\nAnc1: $\\{P,S\\}$ (ambiguous).\nAnc2: $\\{P,S\\}$ (ambiguous).\nRoot: $\\{P,S\\}\\cap\\{P,S\\}=\\{P,S\\}$ (ambiguous). Fails.\n\nOption E: P1=T, P2=D; P3=E, P4=F.\nAnc1: $\\{T,D\\}$ (ambiguous).\nAnc2: $\\{E,F\\}$ (ambiguous).\nRoot: $\\{T,D\\}\\cap\\{E,F\\}=\\varnothing \\Rightarrow \\{T,D,E,F\\}$ (ambiguous). Fails.\n\nTherefore only Option A yields an ambiguous root with both Anc1 and Anc2 unambiguous.", "answer": "$$\\boxed{A}$$", "id": "2099385"}, {"introduction": "Moving beyond parsimony, we now delve into the quantitative world of probabilistic ASR, which provides not just an ancestral state but also a measure of confidence in that inference. This practice [@problem_id:2372309] requires you to perform a hands-on calculation using a specific continuous-time Markov chain model to compute posterior probabilities. You will explore a fascinating and non-intuitive scenario where adding more data can paradoxically decrease confidence in an ancestral reconstruction, highlighting the subtle interplay between tree topology, branch lengths, and observed data.", "problem": "Consider a single homologous binary character evolving on a rooted phylogeny under the Cavender-Farris-Neyman (CFN) two-state symmetric continuous-time Markov chain (CTMC) with state space $\\{0,1\\}$. The infinitesimal generator is\n$$\nQ \\;=\\; \\begin{pmatrix} -1 & 1 \\\\ 1 & -1 \\end{pmatrix},\n$$\nand branch length $b$ is measured in expected substitutions per site, so that the transition probability matrix along an edge of length $b$ is $\\exp(Qb)$. Assume the stationary prior at the root is uniform, $\\Pr(\\text{root}=0)=\\Pr(\\text{root}=1)=\\tfrac{1}{2}$, and that observations at the leaves are conditionally independent given their parent states along edges.\n\nTwo scenarios are considered, both with all edges of length $b=\\tfrac{1}{2}\\ln 3$.\n\nScenario $(i)$: A rooted $2$-taxon tree where the root $R$ connects directly to leaves $A$ and $B$ by edges of length $b$. The observed states at the leaves are $A=0$ and $B=0$.\n\nScenario $(ii)$: A rooted $4$-taxon balanced tree where the root $R$ has two children, internal nodes $X$ and $Y$, each connected to $R$ by an edge of length $b$. Node $X$ has two children, leaves $A$ and $B$, each connected to $X$ by an edge of length $b$. Node $Y$ has two children, leaves $C$ and $D$, each connected to $Y$ by an edge of length $b$. The observed states at the leaves are $A=0$, $B=0$, $C=1$, and $D=1$.\n\nLet $\\rho$ denote the ratio of posterior probabilities of the root being in state $0$ in the two scenarios,\n$$\n\\rho \\;=\\; \\frac{\\Pr(R=0 \\mid \\text{data in scenario }(ii))}{\\Pr(R=0 \\mid \\text{data in scenario }(i))}.\n$$\nCompute $\\rho$ exactly. Express your final answer as a single real number or a single exact fraction. No rounding is required and no units are needed.", "solution": "The user has submitted a problem for validation and solution.\n\n**Step 1: Extract Givens**\n\n*   **Model:** Cavender-Farris-Neyman (CFN) two-state symmetric continuous-time Markov chain (CTMC).\n*   **State Space:** $\\{0,1\\}$.\n*   **Infinitesimal Generator:** $Q = \\begin{pmatrix} -1 & 1 \\\\ 1 & -1 \\end{pmatrix}$.\n*   **Branch Length:** $b$ is the expected number of substitutions per site.\n*   **Transition Probability Matrix:** $P(b) = \\exp(Qb)$.\n*   **Root Prior:** Uniform, $\\Pr(\\text{root}=0) = \\Pr(\\text{root}=1) = \\frac{1}{2}$.\n*   **Conditional Independence:** Observations at leaves are conditionally independent given their parent states along edges.\n*   **Branch Length Value:** All edges have length $b = \\frac{1}{2}\\ln 3$.\n*   **Scenario (i):** A rooted 2-taxon tree. Root $R$ has two children, leaves $A$ and $B$. Edges $(R,A)$ and $(R,B)$ have length $b$. Leaf states are $A=0$ and $B=0$.\n*   **Scenario (ii):** A rooted 4-taxon balanced tree. Root $R$ has children $X$ and $Y$. $X$ has children $A$ and $B$. $Y$ has children $C$ and $D$. All six edges have length $b$. Leaf states are $A=0$, $B=0$, $C=1$, $D=1$.\n*   **Target Quantity:** The ratio $\\rho = \\frac{\\Pr(R=0 \\mid \\text{data in scenario }(ii))}{\\Pr(R=0 \\mid \\text{data in scenario }(i))}$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is subjected to validation against the specified criteria.\n\n*   **Scientific Groundedness:** The problem is based on the CFN model, a cornerstone of molecular evolution and phylogenetics. All concepts, including CTMCs, the infinitesimal generator, transition probabilities, Felsenstein's pruning algorithm for likelihood calculation, and Bayesian posterior inference, are standard and well-established in computational biology and bioinformatics. The problem is scientifically sound.\n*   **Well-Posedness:** The problem specifies all necessary components: a phylogenetic model, tree topologies, branch lengths, and character states at the leaves. The objective is to compute a specific, well-defined ratio of posterior probabilities. A unique, stable, and meaningful solution can be derived from the provided information.\n*   **Objectivity:** The problem statement is formulated with precise, unambiguous mathematical and biological terminology. There are no subjective or opinion-based elements.\n*   **Completeness and Consistency:** The data provided are self-contained and sufficient for a complete solution. There are no missing parameters or contradictory constraints. The definition of branch length as expected substitutions per site is consistent with the provided generator matrix under a uniform stationary distribution.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. It is scientifically grounded, well-posed, objective, and self-consistent. I will proceed to provide a complete solution.\n\n**Solution Derivation**\n\nThe core of the problem is to compute the posterior probability of the root state in two different scenarios. For a given rooting state $s \\in \\{0, 1\\}$ and observed data $D$, Bayes' theorem gives the posterior probability as:\n$$\n\\Pr(R=s \\mid D) = \\frac{\\Pr(D \\mid R=s)\\Pr(R=s)}{\\Pr(D)}\n$$\nThe total probability of the data is $\\Pr(D) = \\sum_{s' \\in \\{0,1\\}} \\Pr(D \\mid R=s')\\Pr(R=s')$. Given the uniform prior $\\Pr(R=0) = \\Pr(R=1) = \\frac{1}{2}$, this simplifies to:\n$$\n\\Pr(R=0 \\mid D) = \\frac{\\Pr(D \\mid R=0) \\cdot \\frac{1}{2}}{\\Pr(D \\mid R=0) \\cdot \\frac{1}{2} + \\Pr(D \\mid R=1) \\cdot \\frac{1}{2}} = \\frac{L(0)}{L(0) + L(1)}\n$$\nwhere $L(s) = \\Pr(D \\mid R=s)$ is the likelihood of the data given the root is in state $s$.\n\nFirst, we must determine the transition probability matrix $P(b) = \\exp(Qb)$. The generator is $Q = \\begin{pmatrix} -1 & 1 \\\\ 1 & -1 \\end{pmatrix}$. The eigenvalues $\\lambda$ of $Q$ are given by $\\det(Q - \\lambda I) = (-1-\\lambda)^2 - 1 = \\lambda^2 + 2\\lambda = 0$, which yields $\\lambda_1 = 0$ and $\\lambda_2 = -2$. The matrix exponentiation gives the transition probabilities over a branch of length $b$:\n$$\nP(b) = \\begin{pmatrix} P_{00}(b) & P_{01}(b) \\\\ P_{10}(b) & P_{11}(b) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1+\\exp(-2b) & 1-\\exp(-2b) \\\\ 1-\\exp(-2b) & 1+\\exp(-2b) \\end{pmatrix}\n$$\nThe problem specifies $b = \\frac{1}{2}\\ln 3$. We substitute this into the exponential term:\n$$\n\\exp(-2b) = \\exp\\left(-2 \\cdot \\frac{1}{2}\\ln 3\\right) = \\exp(-\\ln 3) = 3^{-1} = \\frac{1}{3}\n$$\nThe transition probabilities are therefore:\n$P_{00}(b) = P_{11}(b) = \\frac{1}{2}(1 + \\frac{1}{3}) = \\frac{1}{2}(\\frac{4}{3}) = \\frac{2}{3}$.\n$P_{01}(b) = P_{10}(b) = \\frac{1}{2}(1 - \\frac{1}{3}) = \\frac{1}{2}(\\frac{2}{3}) = \\frac{1}{3}$.\n\n**Analysis of Scenario (i)**\nThe tree has root $R$ and leaves $A, B$. The data are $D_i = \\{A=0, B=0\\}$. The branches $(R,A)$ and $(R,B)$ both have length $b$.\nThe likelihoods are calculated as follows, using the conditional independence of the subtrees descending from $R$:\n$$\nL_i(0) = \\Pr(A=0, B=0 \\mid R=0) = \\Pr(A=0 \\mid R=0) \\Pr(B=0 \\mid R=0) = P_{00}(b) \\cdot P_{00}(b) = \\frac{2}{3} \\cdot \\frac{2}{3} = \\frac{4}{9}\n$$\n$$\nL_i(1) = \\Pr(A=0, B=0 \\mid R=1) = \\Pr(A=0 \\mid R=1) \\Pr(B=0 \\mid R=1) = P_{10}(b) \\cdot P_{10}(b) = \\frac{1}{3} \\cdot \\frac{1}{3} = \\frac{1}{9}\n$$\nThe posterior probability of the root being in state $0$ is:\n$$\n\\Pr(R=0 \\mid D_i) = \\frac{L_i(0)}{L_i(0) + L_i(1)} = \\frac{\\frac{4}{9}}{\\frac{4}{9} + \\frac{1}{9}} = \\frac{\\frac{4}{9}}{\\frac{5}{9}} = \\frac{4}{5}\n$$\n\n**Analysis of Scenario (ii)**\nThe tree has root $R$ with children $X, Y$. $X$ has children $A, B$ and $Y$ has children $C, D$. The data are $D_{ii} = \\{A=0, B=0, C=1, D=1\\}$. All branches have length $b$.\nWe use Felsenstein's pruning algorithm to compute the likelihoods. Let $L_K(s)$ be the conditional likelihood of the data in the subtree rooted at node $K$, given that $K$ is in state $s$.\nThe likelihoods at the leaves are delta functions: $L_A=(1,0)$, $L_B=(1,0)$, $L_C=(0,1)$, $L_D=(0,1)$.\n\nFirst, we compute the conditional likelihood vectors for the internal nodes $X$ and $Y$.\nFor node $X$ (with children $A=0, B=0$):\n$L_X(0) = P_{00}(b)L_A(0) \\cdot P_{00}(b)L_B(0) = \\frac{2}{3} \\cdot 1 \\cdot \\frac{2}{3} \\cdot 1 = \\frac{4}{9}$\n$L_X(1) = P_{10}(b)L_A(0) \\cdot P_{10}(b)L_B(0) = \\frac{1}{3} \\cdot 1 \\cdot \\frac{1}{3} \\cdot 1 = \\frac{1}{9}$\nSo, $L_X = (\\frac{4}{9}, \\frac{1}{9})$.\n\nFor node $Y$ (with children $C=1, D=1$):\n$L_Y(0) = P_{01}(b)L_C(1) \\cdot P_{01}(b)L_D(1) = \\frac{1}{3} \\cdot 1 \\cdot \\frac{1}{3} \\cdot 1 = \\frac{1}{9}$\n$L_Y(1) = P_{11}(b)L_C(1) \\cdot P_{11}(b)L_D(1) = \\frac{2}{3} \\cdot 1 \\cdot \\frac{2}{3} \\cdot 1 = \\frac{4}{9}$\nSo, $L_Y = (\\frac{1}{9}, \\frac{4}{9})$.\n\nNext, we compute the likelihoods at the root $R$ by propagating the likelihoods from its children $X$ and $Y$.\n$$\nL_{ii}(s) = \\left( \\sum_{s_X=0}^1 P_{s,s_X}(b) L_X(s_X) \\right) \\left( \\sum_{s_Y=0}^1 P_{s,s_Y}(b) L_Y(s_Y) \\right)\n$$\nFor $R=0$:\n$$\nL_{ii}(0) = \\left( P_{00}(b)L_X(0) + P_{01}(b)L_X(1) \\right) \\left( P_{00}(b)L_Y(0) + P_{01}(b)L_Y(1) \\right)\n$$\n$$\nL_{ii}(0) = \\left( \\frac{2}{3} \\cdot \\frac{4}{9} + \\frac{1}{3} \\cdot \\frac{1}{9} \\right) \\left( \\frac{2}{3} \\cdot \\frac{1}{9} + \\frac{1}{3} \\cdot \\frac{4}{9} \\right) = \\left( \\frac{8}{27} + \\frac{1}{27} \\right) \\left( \\frac{2}{27} + \\frac{4}{27} \\right) = \\left( \\frac{9}{27} \\right) \\left( \\frac{6}{27} \\right) = \\frac{1}{3} \\cdot \\frac{2}{9} = \\frac{2}{27}\n$$\nFor $R=1$:\n$$\nL_{ii}(1) = \\left( P_{10}(b)L_X(0) + P_{11}(b)L_X(1) \\right) \\left( P_{10}(b)L_Y(0) + P_{11}(b)L_Y(1) \\right)\n$$\n$$\nL_{ii}(1) = \\left( \\frac{1}{3} \\cdot \\frac{4}{9} + \\frac{2}{3} \\cdot \\frac{1}{9} \\right) \\left( \\frac{1}{3} \\cdot \\frac{1}{9} + \\frac{2}{3} \\cdot \\frac{4}{9} \\right) = \\left( \\frac{4}{27} + \\frac{2}{27} \\right) \\left( \\frac{1}{27} + \\frac{8}{27} \\right) = \\left( \\frac{6}{27} \\right) \\left( \\frac{9}{27} \\right) = \\frac{2}{9} \\cdot \\frac{1}{3} = \\frac{2}{27}\n$$\nThe likelihoods are equal: $L_{ii}(0) = L_{ii}(1)$. The posterior probability of the root being in state $0$ is:\n$$\n\\Pr(R=0 \\mid D_{ii}) = \\frac{L_{ii}(0)}{L_{ii}(0) + L_{ii}(1)} = \\frac{\\frac{2}{27}}{\\frac{2}{27} + \\frac{2}{27}} = \\frac{\\frac{2}{27}}{\\frac{4}{27}} = \\frac{1}{2}\n$$\nThe equality of the likelihoods indicates that the observed data under this symmetric model and tree provide no information to distinguish the root state, so the posterior distribution reverts to the prior.\n\n**Final Calculation of the ratio $\\rho$**\nThe problem asks for the ratio $\\rho$:\n$$\n\\rho = \\frac{\\Pr(R=0 \\mid D_{ii})}{\\Pr(R=0 \\mid D_i)} = \\frac{\\frac{1}{2}}{\\frac{4}{5}} = \\frac{1}{2} \\cdot \\frac{5}{4} = \\frac{5}{8}\n$$\nThe result is an exact fraction.", "answer": "$$\n\\boxed{\\frac{5}{8}}\n$$", "id": "2372309"}, {"introduction": "The ultimate test of understanding is to build a working model from first principles. This capstone exercise [@problem_id:2372378] guides you through the implementation of a full-fledged ancestral sequence reconstruction tool using the Jukes-Cantor model and the foundational pruning algorithm. A key practical skill you will develop is handling missing data, a pervasive challenge in bioinformatics, thereby bridging the gap between theoretical models and their application to real-world sequence alignments.", "problem": "You are given a fixed, rooted phylogenetic tree with branch lengths and a set of deoxyribonucleic acid (DNA) sequences at the leaves. The goal is to reconstruct the maximum a posteriori (MAP) ancestral sequence at the root under the Jukes–Cantor model of nucleotide substitution, even when one of the extant sequences contains a large contiguous block of missing data denoted by the character 'N'. Assume the Continuous-Time Markov Chain (CTMC) model known as Jukes–Cantor with rate parameter $\\mu = 1$ substitution per unit time, a stationary distribution $\\pi = (\\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4})$, and an alphabet $\\mathcal{A} = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$. Map nucleotides to integers as $\\text{A} \\mapsto 0$, $\\text{C} \\mapsto 1$, $\\text{G} \\mapsto 2$, and $\\text{T} \\mapsto 3$. Treat 'N' at a leaf as missing data that is equally compatible with any nucleotide.\n\nFundamental base: In a CTMC on $\\mathcal{A}$, the transition probability matrix is $P(t) = e^{Qt}$, where $Q$ is the rate matrix. In the Jukes–Cantor model, $Q$ has off-diagonal entries $\\tfrac{1}{3}$ and diagonal entries $-1$. Therefore, the transition probabilities satisfy $P_{ii}(t) = \\tfrac{1}{4} + \\tfrac{3}{4} e^{- \\tfrac{4}{3} t}$ and $P_{ij}(t) = \\tfrac{1}{4} - \\tfrac{1}{4} e^{- \\tfrac{4}{3} t}$ for $i \\neq j$. For a rooted tree with independent site evolution, the likelihood at the root for state $k \\in \\{0,1,2,3\\}$ is proportional to the product over children of the sum over child states of transition probabilities times the child conditional likelihood, and the posterior at the root is proportional to $\\pi_k$ times this likelihood. Missing data at a leaf is modeled as a uniform conditional likelihood over states.\n\nImplement a program that, for each test case below, computes the MAP root sequence site-by-site under this model using dynamic programming on the tree (for example, the pruning algorithm based on conditional likelihoods). When posterior probabilities tie at a site, break ties by choosing the smallest integer according to the fixed mapping order $\\text{A} < \\text{C} < \\text{G} < \\text{T}$, that is, choose the smallest $k \\in \\{0,1,2,3\\}$ among the maximizers.\n\nEach test case consists of:\n- A rooted tree specified by directed edges from parent to child with branch length $t \\ge 0$ measured in the same time units as above.\n- A dictionary of leaf sequences, all of equal length $L \\in \\mathbb{N}$, over the alphabet $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}, \\text{N}\\}$.\n\nYour program must hard-code the following test suite and produce the required outputs:\n\nTest Case $1$ (balanced tree with a large missing patch in one extant sequence):\n- Tree edges with branch lengths:\n  - $\\text{R} \\to \\text{I1}$ with $t = 0.1$, $\\text{R} \\to \\text{I2}$ with $t = 0.1$,\n  - $\\text{I1} \\to \\text{S1}$ with $t = 0.1$, $\\text{I1} \\to \\text{S2}$ with $t = 0.1$,\n  - $\\text{I2} \\to \\text{S3}$ with $t = 0.1$, $\\text{I2} \\to \\text{S4}$ with $t = 0.1$.\n- Leaf sequences of length $L = 8$:\n  - $\\text{S1}$: ACGTTGCA\n  - $\\text{S2}$: ACGTCGCA\n  - $\\text{S3}$: NNNNNNNN\n  - $\\text{S4}$: ACGTTGTA\n\nTest Case $2$ (star tree with a zero-length branch boundary condition):\n- Tree edges with branch lengths:\n  - $\\text{R} \\to \\text{S1}$ with $t = 0.0$, $\\text{R} \\to \\text{S2}$ with $t = 0.001$, $\\text{R} \\to \\text{S3}$ with $t = 0.001$.\n- Leaf sequences of length $L = 4$:\n  - $\\text{S1}$: AAAA\n  - $\\text{S2}$: AAAA\n  - $\\text{S3}$: ANNN\n\nTest Case $3$ (deep branches approaching stationarity):\n- Tree edges with branch lengths:\n  - $\\text{R} \\to \\text{S1}$ with $t = 2.0$, $\\text{R} \\to \\text{I}$ with $t = 2.0$,\n  - $\\text{I} \\to \\text{S2}$ with $t = 2.0$, $\\text{I} \\to \\text{S3}$ with $t = 2.0$.\n- Leaf sequences of length $L = 6$:\n  - $\\text{S1}$: GGGGGG\n  - $\\text{S2}$: GGGGGA\n  - $\\text{S3}$: CCCGGA\n\nTest Case $4$ (all leaves missing data, tie-breaking scenario):\n- Tree edges with branch lengths:\n  - $\\text{R} \\to \\text{S1}$ with $t = 0.5$, $\\text{R} \\to \\text{S2}$ with $t = 0.5$, $\\text{R} \\to \\text{S3}$ with $t = 0.5$.\n- Leaf sequences of length $L = 3$:\n  - $\\text{S1}$: NNN\n  - $\\text{S2}$: NNN\n  - $\\text{S3}$: NNN\n\nOutput specification:\n- For each test case, compute the MAP root sequence as a list of integers of length $L$ using the mapping $\\text{A} \\mapsto 0$, $\\text{C} \\mapsto 1$, $\\text{G} \\mapsto 2$, $\\text{T} \\mapsto 3$.\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, with each result itself a comma-separated list enclosed in square brackets. For example, the overall format must be like $[ [\\dots], [\\dots], [\\dots], [\\dots] ]$ but without spaces, that is, exactly $[[\\dots],[\\dots],[\\dots],[\\dots]]$.", "solution": "The problem requires the determination of the maximum a posteriori (MAP) ancestral sequence at the root of a given phylogenetic tree. The problem is well-posed, scientifically grounded in the principles of molecular evolution, and provides all necessary parameters for a unique solution. I will therefore proceed with a complete, reasoned solution.\n\nThe core of the problem lies in applying Felsenstein's pruning algorithm, a dynamic programming approach for computing the likelihood of sequence data on a phylogenetic tree. The evolution of nucleotides at each site of the sequence is assumed to be independent and identically distributed according to a Continuous-Time Markov Chain (CTMC).\n\nThe specified model is the Jukes–Cantor model, which assumes equal rates of substitution between any two distinct nucleotides and a uniform stationary distribution $\\pi = (\\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4})$ over the alphabet $\\mathcal{A} = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$. The nucleotides are mapped to integers $0, 1, 2, 3$ respectively. The rate matrix $Q$ has entries $Q_{ij} = \\tfrac{1}{3}$ for $i \\neq j$ and $Q_{ii} = -1$. The transition probability matrix for a branch of length $t$ is $P(t) = e^{Qt}$, with entries given by:\n$$ P_{ii}(t) = \\frac{1}{4} + \\frac{3}{4} e^{- \\frac{4}{3} t} $$\n$$ P_{ij}(t) = \\frac{1}{4} - \\frac{1}{4} e^{- \\frac{4}{3} t} \\quad (\\text{for } i \\neq j) $$\nFor a branch of length $t=0$, $P(0)$ becomes the identity matrix, correctly modeling no change.\n\nThe MAP state for a given site at the root $R$ is the state $k \\in \\mathcal{A}$ that maximizes the posterior probability $P(\\text{state}_R=k | \\text{Data})$. By Bayes' theorem, this is proportional to the product of the likelihood and the prior:\n$$ \\underset{k}{\\arg\\max} \\, P(\\text{state}_R=k | \\text{Data}) = \\underset{k}{\\arg\\max} \\, P(\\text{Data} | \\text{state}_R=k) \\cdot P(\\text{state}_R=k) $$\nThe prior probability $P(\\text{state}_R=k)$ is given by the stationary distribution $\\pi_k$. Since $\\pi_k = \\tfrac{1}{4}$ for all $k$, the prior is uniform and does not affect the maximization. Thus, the MAP estimate is equivalent to the Maximum Likelihood estimate, and we only need to compute and maximize the likelihood $L_R(k) = P(\\text{Data} | \\text{state}_R=k)$ for each state $k$.\n\nThe pruning algorithm computes these likelihoods via a post-order traversal of the tree, from the leaves to the root. For each site in the alignment, the algorithm proceeds as follows:\n\n1.  **Initialization at Leaves**: For each leaf node $u$, we define a conditional likelihood vector $L_u$ of size $4$. If the observed nucleotide at the current site is $c$, corresponding to integer $c_{int}$, the vector is $L_u(k) = \\delta_{k, c_{int}}$ (a vector of zeros with a $1$ at position $c_{int}$). If the data is missing ('N'), all states are considered equally possible, so $L_u$ is a vector of ones, $L_u(k) = 1$ for all $k \\in \\{0, 1, 2, 3\\}$.\n\n2.  **Recursion at Internal Nodes**: For an internal node $u$ with children $v_1, \\dots, v_m$, let the branch from $u$ to $v_j$ have length $t_j$. The likelihood vector $L_u$ is computed after the vectors for all its children are known. The likelihood of the data in the subtrees of its children, given state $k$ at node $u$, is the product of contributions from each child's subtree. The contribution from child $v_j$ is obtained by summing over all possible states $s$ at node $v_j$:\n    $$ L_u(k) = \\prod_{j=1}^{m} \\left( \\sum_{s=0}^{3} P_{ks}(t_j) \\cdot L_{v_j}(s) \\right) $$\n    The sum $\\sum_{s=0}^{3} P_{ks}(t_j) \\cdot L_{v_j}(s)$ is the $k$-th element of the matrix-vector product $P(t_j) L_{v_j}$. The final vector $L_u$ is the element-wise product of these resulting vectors from all children.\n\n3.  **Final Calculation at Root**: The traversal terminates at the root node $R$. The resulting vector $L_R$ contains the likelihoods $P(\\text{Data} | \\text{state}_R=k)$ for each $k \\in \\{0, 1, 2, 3\\}$.\n\n4.  **MAP State Determination**: The MAP state for the site is found by identifying the index $k$ that maximizes $L_R(k)$. If there is a tie, the smallest integer index is chosen as per the problem specification.\n\nThis entire procedure is repeated for each site in the sequence alignment to construct the full ancestral sequence. The implementation will represent the tree structure, pre-calculate the transition matrices as needed, and perform the post-order traversal for each site to find the MAP root state.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the ancestral sequence reconstruction problem for all test cases.\n    \"\"\"\n    \n    # Mapping for nucleotides to integers.\n    NUC_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # Memoization cache for the transition probability matrix P(t).\n    p_matrix_cache = {}\n\n    def get_p_matrix(t):\n        \"\"\"\n        Computes the Jukes-Cantor transition probability matrix P(t).\n        Uses a cache to avoid recomputing for the same branch length t.\n        P_ii(t) = 1/4 + 3/4 * exp(-4/3 * t)\n        P_ij(t) = 1/4 - 1/4 * exp(-4/3 * t) for i != j\n        \"\"\"\n        if t in p_matrix_cache:\n            return p_matrix_cache[t]\n        \n        if t  1e-9: # Treat very small t as 0 to avoid precision issues\n            P = np.identity(4)\n        else:\n            val = np.exp(-4.0 / 3.0 * t)\n            p_diag = 0.25 + 0.75 * val\n            p_offdiag = 0.25 - 0.25 * val\n            P = np.full((4, 4), p_offdiag)\n            np.fill_diagonal(P, p_diag)\n        \n        p_matrix_cache[t] = P\n        return P\n\n    def get_map_root_sequence(edges, leaf_seqs):\n        \"\"\"\n        Computes the MAP ancestral sequence for a single phylogenetic tree and sequence set.\n        \"\"\"\n        # Build tree representation from edge list\n        all_nodes = set()\n        children_map = defaultdict(list)\n        branch_length_map = {} # Maps a child node to the length of the branch from its parent\n\n        for parent, child, blen in edges:\n            all_nodes.add(parent)\n            all_nodes.add(child)\n            children_map[parent].append(child)\n            branch_length_map[child] = blen\n        \n        root = list(all_nodes - set(branch_length_map.keys()))[0]\n        leaves = [node for node in all_nodes if not children_map[node]]\n\n        # Generate a post-order traversal of the tree nodes.\n        # This is done by a non-recursive pre-order traversal followed by a reverse.\n        post_order_traversal = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            post_order_traversal.append(node)\n            stack.extend(children_map.get(node, []))\n        post_order_traversal.reverse()\n\n        seq_len = len(list(leaf_seqs.values())[0])\n        map_root_seq = []\n\n        # Perform site-by-site reconstruction using the pruning algorithm\n        for i in range(seq_len):\n            likelihoods = {}\n            for node in post_order_traversal:\n                if node in leaves:\n                    char = leaf_seqs[node][i]\n                    if char == 'N':\n                        L = np.ones(4)\n                    else:\n                        L = np.zeros(4)\n                        L[NUC_MAP[char]] = 1.0\n                    likelihoods[node] = L\n                else: # Internal node\n                    L_node = np.ones(4)\n                    for child in children_map[node]:\n                        blen = branch_length_map[child]\n                        P = get_p_matrix(blen)\n                        L_child = likelihoods[child]\n                        child_contribution = P @ L_child\n                        L_node *= child_contribution\n                    likelihoods[node] = L_node\n            \n            # The posterior at the root is proportional to the likelihoods\n            # because the prior (stationary distribution) is uniform.\n            root_likelihoods = likelihoods[root]\n            \n            # Find the MAP state. np.argmax breaks ties by choosing the first index,\n            # which corresponds to the problem's tie-breaking rule.\n            map_state = np.argmax(root_likelihoods)\n            map_root_seq.append(map_state)\n            \n        return map_root_seq\n\n    # Hard-coded test cases from the problem statement\n    test_cases = [\n        {\n            \"edges\": [\n                ('R', 'I1', 0.1), ('R', 'I2', 0.1),\n                ('I1', 'S1', 0.1), ('I1', 'S2', 0.1),\n                ('I2', 'S3', 0.1), ('I2', 'S4', 0.1)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"ACGTTGCA\", 'S2': \"ACGTCGCA\",\n                'S3': \"NNNNNNNN\", 'S4': \"ACGTTGTA\"\n            }\n        },\n        {\n            \"edges\": [\n                ('R', 'S1', 0.0), ('R', 'S2', 0.001), ('R', 'S3', 0.001)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"AAAA\", 'S2': \"AAAA\", 'S3': \"ANNN\"\n            }\n        },\n        {\n            \"edges\": [\n                ('R', 'S1', 2.0), ('R', 'I', 2.0),\n                ('I', 'S2', 2.0), ('I', 'S3', 2.0)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"GGGGGG\", 'S2': \"GGGGGA\", 'S3': \"CCCGGA\"\n            }\n        },\n        {\n            \"edges\": [\n                ('R', 'S1', 0.5), ('R', 'S2', 0.5), ('R', 'S3', 0.5)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"NNN\", 'S2': \"NNN\", 'S3': \"NNN\"\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = get_map_root_sequence(case[\"edges\"], case[\"leaf_seqs\"])\n        results.append(result)\n\n    # Format the final output string exactly as specified\n    inner_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2372378"}]}