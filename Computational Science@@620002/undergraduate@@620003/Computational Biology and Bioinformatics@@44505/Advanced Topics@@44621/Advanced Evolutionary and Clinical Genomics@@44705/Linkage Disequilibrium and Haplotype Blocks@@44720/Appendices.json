{"hands_on_practices": [{"introduction": "In population genetics, we often work with haplotype frequencies, but experimental data typically provides unphased genotypes. This creates a classic \"missing data\" problem for individuals who are heterozygous at multiple loci. This practice guides you through implementing the Expectation-Maximization (EM) algorithm, a fundamental statistical technique to infer the most likely haplotype frequencies from unphased genotype counts, which is a critical first step for almost any analysis of linkage disequilibrium [@problem_id:2401311].", "problem": "You are given unphased diploid genotype count data for two biallelic loci across a sample of individuals. The two loci have alleles $A/a$ and $B/b$, respectively. A haplotype is an ordered pair of alleles on the same chromosome across the two loci (e.g., $AB$, $Ab$, $aB$, $ab$). Each individual carries two haplotypes (a diplotype), and the unphased genotype at each locus records only the unordered allele counts: $AA$, $Aa$, or $aa$ at the first locus, and $BB$, $Bb$, or $bb$ at the second locus. The $3 \\times 3$ table of genotype counts $g_{ij}$ uses $i \\in \\{0,1,2\\}$ for the count of allele $A$ at the first locus ($aa$, $Aa$, $AA$) and $j \\in \\{0,1,2\\}$ for the count of allele $B$ at the second locus ($bb$, $Bb$, $BB$). The $(1,1)$ cell is the double heterozygote $(Aa,Bb)$ and is phase-ambiguous.\n\nStarting from the foundational assumptions that (i) haplotypes in a random-mating diploid population are sampled independently to form diplotypes and (ii) the sample is a collection of independent individuals, the likelihood of the observed $3 \\times 3$ genotype count table is a function of the four haplotype frequencies $p_{AB}$, $p_{Ab}$, $p_{aB}$, $p_{ab}$, which are nonnegative and sum to $1$. Implement the expectation–maximization (EM) algorithm to find the maximum-likelihood estimates of these haplotype frequencies from the unphased counts. After estimating the haplotype frequencies, compute the linkage disequilibrium (LD) summary $D = p_{AB} - p_A p_B$, where $p_A = p_{AB} + p_{Ab}$ and $p_B = p_{AB} + p_{aB}$, and then compute $r^2 = D^2 / \\left(p_A (1 - p_A) p_B (1 - p_B)\\right)$. If the denominator in $r^2$ is zero, define $r^2 = 0$.\n\nYour program must:\n- Implement EM from first principles under the assumptions above, without relying on closed-form shortcuts for ambiguous phases.\n- Use a convergence tolerance $\\epsilon$ (e.g., $\\epsilon = 10^{-10}$) on the change in haplotype frequencies between iterations, with a reasonable maximum number of iterations to guarantee termination.\n- Return, for each test case, a list of five floats in the order $[p_{AB}, p_{Ab}, p_{aB}, p_{ab}, r^2]$, each rounded to $6$ decimal places.\n\nTest suite (each case is a $3 \\times 3$ matrix of nonnegative integers $g_{ij}$, in row-major order: row $i \\in \\{0,1,2\\}$ for $aa$, $Aa$, $AA$ by column $j \\in \\{0,1,2\\}$ for $bb$, $Bb$, $BB$):\n- Case $1$ (general “happy path” with ambiguity present):\n  - Row $0$: $[7, 2, 8]$\n  - Row $1$: $[6, 20, 4]$\n  - Row $2$: $[5, 3, 10]$\n- Case $2$ (no ambiguity: zero double heterozygotes):\n  - Row $0$: $[3, 1, 1]$\n  - Row $1$: $[1, 0, 0]$\n  - Row $2$: $[1, 0, 3]$\n- Case $3$ (linkage equilibrium grid with many double heterozygotes, $N = 64$):\n  - Row $0$: $[4, 8, 4]$\n  - Row $1$: $[8, 16, 8]$\n  - Row $2$: $[4, 8, 4]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed, comma-separated list for one test case with no spaces. For example: $[[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],[x_{31},x_{32},x_{33},x_{34},x_{35}]]$, where each $x_{ij}$ is a float rounded to $6$ decimal places. All probabilities must be expressed as decimals, not percentages.", "solution": "The problem presented is a standard and well-posed task in computational population genetics: the estimation of haplotype frequencies from unphased diploid genotype counts using the expectation–maximization (EM) algorithm. The problem is scientifically grounded, internally consistent, and provides all necessary information for a unique solution to be computed. It is therefore deemed valid.\n\nThe core of the problem is to find the maximum-likelihood estimates (MLE) for the frequencies of the four haplotypes ($AB, Ab, aB, ab$), which we denote as $p_{AB}, p_{Ab}, p_{aB}, p_{ab}$, respectively. These frequencies are non-negative and sum to $1$. The input data is a $3 \\times 3$ matrix of genotype counts, $g_{ij}$, where $i \\in \\{0, 1, 2\\}$ is the count of allele $A$ at the first locus and $j \\in \\{0, 1, 2\\}$ is the count of allele $B$ at the second locus.\n\nThe likelihood of observing the genotype counts $\\mathbf{g} = \\{g_{ij}\\}$ is given by a multinomial probability distribution, where the probability of each of the nine two-locus genotypes is a function of the haplotype frequencies. Under the assumption of random mating (i.e., Hardy-Weinberg Equilibrium at the diplotype level), the expected frequency $P_{ij}$ of each genotype is determined by the haplotype frequencies. For example, the genotype $(AA,BB)$, corresponding to the cell $g_{22}$, can only arise from the diplotype $AB/AB$, which has an expected frequency of $p_{AB}^2$. Most genotype frequencies can be expressed as simple products or squared terms of the haplotype frequencies.\n\nThe nine genotype probabilities $P_{ij}(\\mathbf{p})$ are:\n$$ P_{00} = p_{ab}^2 $$\n$$ P_{01} = 2 p_{aB} p_{ab} $$\n$$ P_{02} = p_{aB}^2 $$\n$$ P_{10} = 2 p_{Ab} p_{ab} $$\n$$ P_{11} = 2 p_{AB} p_{ab} + 2 p_{Ab} p_{aB} $$\n$$ P_{12} = 2 p_{AB} p_{aB} $$\n$$ P_{20} = p_{Ab}^2 $$\n$$ P_{21} = 2 p_{AB} p_{Ab} $$\n$$ P_{22} = p_{AB}^2 $$\n\nThe log-likelihood of the observed data is then:\n$$ \\ln L(\\mathbf{p} | \\mathbf{g}) = \\text{const} + \\sum_{i=0}^{2} \\sum_{j=0}^{2} g_{ij} \\ln P_{ij}(\\mathbf{p}) $$\nDirectly maximizing this function is complicated by the sum in the term for $P_{11}$, which corresponds to the phase-ambiguous double heterozygotes $(Aa,Bb)$. This genotype can be formed from two distinct diplotypes: $AB/ab$ (coupling or cis phase) and $Ab/aB$ (repulsion or trans phase). The EM algorithm is ideally suited for such problems involving missing data, where the missing information here is the phase of the $g_{11}$ individuals.\n\nThe EM algorithm is an iterative procedure consisting of two steps:\n1.  **Initialization**: Begin with an initial estimate of the haplotype frequencies, $\\mathbf{p}^{(0)}$. A robust choice is to assume linkage equilibrium, where haplotype frequencies are products of allele frequencies. The allele frequencies $p_A$ and $p_B$ can be estimated directly by counting alleles from the genotype table:\n    $$ p_A = \\frac{2\\sum_j g_{2j} + \\sum_j g_{1j}}{2N} \\quad \\text{and} \\quad p_B = \\frac{2\\sum_i g_{i2} + \\sum_i g_{i1}}{2N} $$\n    where $N = \\sum_{i,j} g_{ij}$ is the total number of individuals. The initial haplotype frequencies are then $p_{AB}^{(0)} = p_A p_B$, $p_{Ab}^{(0)} = p_A(1-p_B)$, $p_{aB}^{(0)} = (1-p_A)p_B$, and $p_{ab}^{(0)} = (1-p_A)(1-p_B)$.\n\n2.  **Expectation (E-step)**: In iteration $t+1$, using the current haplotype frequency estimates $\\mathbf{p}^{(t)}$, we calculate the expected counts of the two unobserved diplotypes that constitute the $g_{11}$ double heterozygotes. The conditional probability that a double heterozygote has the cis phase ($AB/ab$) is:\n    $$ \\pi_{cis} = P(AB/ab | AaBb, \\mathbf{p}^{(t)}) = \\frac{2 p_{AB}^{(t)} p_{ab}^{(t)}}{2 p_{AB}^{(t)} p_{ab}^{(t)} + 2 p_{Ab}^{(t)} p_{aB}^{(t)}} = \\frac{p_{AB}^{(t)} p_{ab}^{(t)}}{p_{AB}^{(t)} p_{ab}^{(t)} + p_{Ab}^{(t)} p_{aB}^{(t)}} $$\n    The expected count of cis-phase individuals is $E[g_{11,cis}] = g_{11} \\times \\pi_{cis}$. Similarly, the expected count of trans-phase individuals ($Ab/aB$) is $E[g_{11,trans}] = g_{11} \\times (1 - \\pi_{cis})$.\n\n3.  **Maximization (M-step)**: With the expected counts from the E-step, we effectively have \"complete\" data. The new MLE for the haplotype frequencies, $\\mathbf{p}^{(t+1)}$, is obtained by simply counting the expected number of each haplotype and dividing by the total number of haplotypes, $2N$. The expected haplotype counts ($h$) are:\n    $$ h_{AB} = 2g_{22} + g_{21} + g_{12} + E[g_{11,cis}] $$\n    $$ h_{Ab} = 2g_{20} + g_{21} + g_{10} + E[g_{11,trans}] $$\n    $$ h_{aB} = 2g_{02} + g_{12} + g_{01} + E[g_{11,trans}] $$\n    $$ h_{ab} = 2g_{00} + g_{10} + g_{01} + E[g_{11,cis}] $$\n    The updated frequencies are $p_{XY}^{(t+1)} = h_{XY} / (2N)$.\n\n4.  **Convergence**: The E- and M-steps are repeated until the haplotype frequency vector converges. Convergence is achieved when the change in frequencies between successive iterations is smaller than a specified tolerance $\\epsilon$ (e.g., $\\epsilon = 10^{-10}$).\n\nAfter the EM algorithm has converged to the final MLE of haplotype frequencies $\\mathbf{p}^* = (p_{AB}, p_{Ab}, p_{aB}, p_{ab})$, the linkage disequilibrium (LD) metrics are calculated.\nThe allele frequencies are recomputed from the estimated haplotype frequencies:\n$$ p_A = p_{AB} + p_{Ab} $$\n$$ p_B = p_{AB} + p_{aB} $$\nThe LD coefficient, $D$, measures the deviation from linkage equilibrium:\n$$ D = p_{AB} - p_A p_B $$\nFinally, the squared correlation coefficient, $r^2$, a common normalized measure of LD, is computed:\n$$ r^2 = \\frac{D^2}{p_A (1-p_A) p_B (1-p_B)} $$\nIf the denominator is zero (i.e., at least one of the loci is monomorphic), $r^2$ is defined as $0$. The final output consists of the four haplotype frequencies and the value of $r^2$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_mle(g: np.ndarray, tol: float = 1e-10, max_iter: int = 10000) -> list[float]:\n    \"\"\"\n    Calculates maximum-likelihood estimates of haplotype frequencies using the EM algorithm.\n\n    Args:\n        g: A 3x3 numpy array of genotype counts.\n           Rows correspond to allele counts for locus A (0: aa, 1: Aa, 2: AA).\n           Cols correspond to allele counts for locus B (0: bb, 1: Bb, 2: BB).\n        tol: Convergence tolerance for the EM algorithm.\n        max_iter: Maximum number of iterations for the EM algorithm.\n\n    Returns:\n        A list of five floats: [p_AB, p_Ab, p_aB, p_ab, r^2].\n    \"\"\"\n    g = g.astype(np.float64)\n    N = np.sum(g)\n\n    if N == 0:\n        return [0.0, 0.0, 0.0, 0.0, 0.0]\n\n    # Step 1: Initialization\n    # Estimate allele frequencies from observed genotype counts\n    n_A = 2 * np.sum(g[2, :]) + np.sum(g[1, :])\n    n_B = 2 * np.sum(g[:, 2]) + np.sum(g[:, 1])\n\n    p_A_init = n_A / (2 * N)\n    p_B_init = n_B / (2 * N)\n\n    # Initialize haplotype frequencies assuming linkage equilibrium\n    p = np.array([\n        p_A_init * p_B_init,             # p_AB\n        p_A_init * (1 - p_B_init),       # p_Ab\n        (1 - p_A_init) * p_B_init,       # p_aB\n        (1 - p_A_init) * (1 - p_B_init)  # p_ab\n    ])\n\n    # Step 2: EM Iteration\n    for _ in range(max_iter):\n        p_old = p.copy()\n\n        # E-step: Estimate expected counts of ambiguous diplotypes\n        # Denominator for cis/trans probability\n        # p[0]=p_AB, p[1]=p_Ab, p[2]=p_aB, p[3]=p_ab\n        d = p[0] * p[3] + p[1] * p[2]\n\n        g11_cis = 0.0\n        g11_trans = 0.0\n        if d > 0:\n            g11_cis = g[1, 1] * (p[0] * p[3]) / d\n            g11_trans = g[1, 1] * (p[1] * p[2]) / d\n\n        # M-step: Update haplotype frequencies based on expected counts\n        h_AB = 2 * g[2, 2] + g[2, 1] + g[1, 2] + g11_cis\n        h_Ab = 2 * g[2, 0] + g[2, 1] + g[1, 0] + g11_trans\n        h_aB = 2 * g[0, 2] + g[1, 2] + g[0, 1] + g11_trans\n        h_ab = 2 * g[0, 0] + g[1, 0] + g[0, 1] + g11_cis\n\n        p = np.array([h_AB, h_Ab, h_aB, h_ab]) / (2 * N)\n\n        # Check for convergence\n        if np.sum(np.abs(p - p_old)) < tol:\n            break\n            \n    # Step 3: Final calculations after convergence\n    p_AB, p_Ab, p_aB, p_ab = p\n\n    p_A = p_AB + p_Ab\n    p_B = p_AB + p_aB\n\n    D = p_AB - p_A * p_B\n\n    denom_r2 = p_A * (1 - p_A) * p_B * (1 - p_B)\n    r2 = 0.0\n    if denom_r2 > 1e-12: # Use a small epsilon for floating point safety\n        r2 = D**2 / denom_r2\n\n    return [p_AB, p_Ab, p_aB, p_ab, r2]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        np.array([[7, 2, 8], [6, 20, 4], [5, 3, 10]]),\n        np.array([[3, 1, 1], [1, 0, 0], [1, 0, 3]]),\n        np.array([[4, 8, 4], [8, 16, 8], [4, 8, 4]])\n    ]\n\n    results = []\n    for g_matrix in test_cases:\n        result_floats = calculate_mle(g_matrix)\n        rounded_res = [f\"{x:.6f}\" for x in result_floats]\n        results.append(f\"[{','.join(rounded_res)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2401311"}, {"introduction": "The squared correlation coefficient, $r^2$, is the standard measure of linkage disequilibrium, but it is typically defined for two loci that each have only two alleles. This exercise challenges you to generalize this concept by deriving an equivalent metric for a multi-allelic locus from the first principle of variance decomposition. By doing so, you will gain a deeper, more flexible understanding of what $r^2$ represents and how LD can be quantified in more complex scenarios [@problem_id:2401334].", "problem": "A population sample of $n$ haploid chromosomes is typed at two linked Single Nucleotide Polymorphisms (SNPs). Locus $B$ is bi-allelic with alleles $A$ and $a$. Locus $T$ is tri-allelic with alleles $t_1$, $t_2$, and $t_3$. Linkage Disequilibrium (LD) between $B$ and $T$ is to be summarized by a generalization of the squared correlation statistic $r^2$ as follows: consider the random variable $X$ indicating the presence of allele $A$ at $B$ (so $X=1$ if the haplotype carries $A$, and $X=0$ if it carries $a$), and the categorical random variable $T \\in \\{t_1,t_2,t_3\\}$ indicating the allele at the tri-allelic locus. Define the generalized LD measure $r^2$ between $B$ and $T$ as the proportion of variance in $X$ that is attributable to $T$.\n\n1. Using only first principles (probability definitions and variance decomposition), derive a closed-form expression for this generalized $r^2$ in terms of the marginal allele frequency $p_A=\\Pr(A)$ at locus $B$, the marginal allele frequencies $q_j=\\Pr(T=t_j)$ at locus $T$, and the haplotype frequency deviations $D_j=\\Pr(A,t_j)-p_A q_j$ for $j\\in\\{1,2,3\\}$.\n\n2. In a random sample of $n=\\;1000$ haploid chromosomes, the observed haplotype counts are:\n- $A\\!-\\!t_1:\\;210$\n- $a\\!-\\!t_1:\\;90$\n- $A\\!-\\!t_2:\\;160$\n- $a\\!-\\!t_2:\\;240$\n- $A\\!-\\!t_3:\\;130$\n- $a\\!-\\!t_3:\\;170$\n\nAssuming the maximum-likelihood estimates equal the corresponding sample proportions, evaluate your derived expression numerically from these data.\n\nExpress the final result as a single decimal number (not a percentage), and round your answer to four significant figures.", "solution": "The problem requires the derivation of a generalized measure of linkage disequilibrium, $r^2$, and its subsequent numerical evaluation. The validation of the problem statement confirms that it is scientifically grounded, well-posed, and contains sufficient information for a unique solution. We shall proceed with the derivation based on first principles, as instructed.\n\nThe generalized squared correlation, $r^2$, is defined as the proportion of the variance in a random variable $X$ that is attributable to a categorical random variable $T$. Here, $X$ is an indicator variable for allele $A$ at locus $B$ (so $X=1$ for allele $A$ and $X=0$ for allele $a$), and $T$ indicates which of the three alleles ($t_1, t_2, t_3$) is present at a second locus.\n\nAccording to the law of total variance, the total variance of $X$ can be decomposed as:\n$$ \\text{Var}(X) = \\text{Var}(\\mathbb{E}[X|T]) + \\mathbb{E}[\\text{Var}(X|T)] $$\nThe term $\\text{Var}(\\mathbb{E}[X|T])$ is the variance of the conditional expectation of $X$ given $T$, which represents the variance in $X$ explained by $T$. The term $\\mathbb{E}[\\text{Var}(X|T)]$ is the expected conditional variance of $X$ given $T$, representing the unexplained or residual variance. The problem defines $r^2$ as the explained proportion of the total variance:\n$$ r^2 = \\frac{\\text{Var}(\\mathbb{E}[X|T])}{\\text{Var}(X)} $$\nWe will derive expressions for the numerator and the denominator separately.\n\nFirst, we determine the denominator, $\\text{Var}(X)$. The random variable $X$ is a Bernoulli variable, as it takes values $1$ and $0$. The probability of success, $\\Pr(X=1)$, is the marginal frequency of allele $A$, denoted by $p_A = \\Pr(A)$. The expectation of $X$ is $\\mathbb{E}[X] = p_A$. The variance of a Bernoulli variable with parameter $p_A$ is:\n$$ \\text{Var}(X) = p_A(1 - p_A) $$\n\nNext, we derive the numerator, $\\text{Var}(\\mathbb{E}[X|T])$. The conditional expectation $\\mathbb{E}[X|T]$ is itself a random variable, which takes a specific value for each possible outcome of $T$. Let the marginal frequencies of the alleles at locus $T$ be $q_j = \\Pr(T=t_j)$ for $j \\in \\{1, 2, 3\\}$. For each allele $t_j$, the conditional expectation of $X$ is:\n$$ \\mathbb{E}[X|T=t_j] = \\Pr(X=1|T=t_j) = \\frac{\\Pr(X=1, T=t_j)}{\\Pr(T=t_j)} = \\frac{\\Pr(A, t_j)}{q_j} $$\nThe random variable $\\mathbb{E}[X|T]$ thus takes values $\\frac{\\Pr(A, t_j)}{q_j}$ with corresponding probabilities $q_j$.\nTo find its variance, we use the formula $\\text{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2$, where $Y = \\mathbb{E}[X|T]$.\nThe expectation of $Y$, by the law of total expectation, is $\\mathbb{E}[Y] = \\mathbb{E}[\\mathbb{E}[X|T]] = \\mathbb{E}[X] = p_A$.\nThe expectation of $Y^2$ is:\n$$ \\mathbb{E}[Y^2] = \\sum_{j=1}^{3} (\\mathbb{E}[X|T=t_j])^2 \\Pr(T=t_j) = \\sum_{j=1}^{3} \\left(\\frac{\\Pr(A, t_j)}{q_j}\\right)^2 q_j = \\sum_{j=1}^{3} \\frac{(\\Pr(A, t_j))^2}{q_j} $$\nThus, the variance of the conditional expectation is:\n$$ \\text{Var}(\\mathbb{E}[X|T]) = \\sum_{j=1}^{3} \\frac{(\\Pr(A, t_j))^2}{q_j} - p_A^2 $$\nThe problem asks for this expression in terms of the haplotype frequency deviations $D_j = \\Pr(A, t_j) - p_A q_j$. From this definition, we have $\\Pr(A, t_j) = p_A q_j + D_j$. Substituting this into our expression for the variance:\n$$ \\text{Var}(\\mathbb{E}[X|T]) = \\sum_{j=1}^{3} \\frac{(p_A q_j + D_j)^2}{q_j} - p_A^2 = \\sum_{j=1}^{3} \\frac{p_A^2 q_j^2 + 2 p_A q_j D_j + D_j^2}{q_j} - p_A^2 $$\n$$ = \\sum_{j=1}^{3} \\left(p_A^2 q_j + 2 p_A D_j + \\frac{D_j^2}{q_j}\\right) - p_A^2 = p_A^2 \\left(\\sum_{j=1}^{3} q_j\\right) + 2 p_A \\left(\\sum_{j=1}^{3} D_j\\right) + \\sum_{j=1}^{3} \\frac{D_j^2}{q_j} - p_A^2 $$\nBy definition, $\\sum_{j=1}^{3} q_j = 1$. The sum of the deviations is $\\sum_{j=1}^{3} D_j = \\sum_{j=1}^{3}(\\Pr(A, t_j) - p_A q_j) = (\\sum_{j=1}^{3}\\Pr(A, t_j)) - p_A(\\sum_{j=1}^{3}q_j) = \\Pr(A) - p_A(1) = p_A - p_A = 0$.\nSubstituting these sums back, we simplify the expression for the numerator:\n$$ \\text{Var}(\\mathbb{E}[X|T]) = p_A^2(1) + 2 p_A(0) + \\sum_{j=1}^{3} \\frac{D_j^2}{q_j} - p_A^2 = \\sum_{j=1}^{3} \\frac{D_j^2}{q_j} $$\nCombining the numerator and denominator, we obtain the final closed-form expression for the generalized $r^2$:\n$$ r^2 = \\frac{\\sum_{j=1}^{3} \\frac{D_j^2}{q_j}}{p_A(1-p_A)} $$\nThis completes the first part of the problem.\n\nFor the second part, we evaluate this expression using the provided sample data. The total sample size is $n=1000$. The observed haplotype counts are: $N_{A,t_1}=210$, $N_{a,t_1}=90$, $N_{A,t_2}=160$, $N_{a,t_2}=240$, $N_{A,t_3}=130$, and $N_{a,t_3}=170$.\nWe use sample proportions as maximum-likelihood estimates for the population frequencies.\nThe total count for allele $A$ is $N_A = 210 + 160 + 130 = 500$.\nThe estimated marginal frequency of allele $A$ is $\\hat{p}_A = \\frac{N_A}{n} = \\frac{500}{1000} = 0.5$.\nThe estimated marginal frequencies of alleles at locus $T$ are:\n$\\hat{q}_1 = \\frac{N_{A,t_1} + N_{a,t_1}}{n} = \\frac{210 + 90}{1000} = \\frac{300}{1000} = 0.3$.\n$\\hat{q}_2 = \\frac{N_{A,t_2} + N_{a,t_2}}{n} = \\frac{160 + 240}{1000} = \\frac{400}{1000} = 0.4$.\n$\\hat{q}_3 = \\frac{N_{A,t_3} + N_{a,t_3}}{n} = \\frac{130 + 170}{1000} = \\frac{300}{1000} = 0.3$.\n\nThe estimated haplotype frequencies $\\hat{P}_{A,t_j}$ are:\n$\\hat{P}_{A,t_1} = \\frac{210}{1000} = 0.21$.\n$\\hat{P}_{A,t_2} = \\frac{160}{1000} = 0.16$.\n$\\hat{P}_{A,t_3} = \\frac{130}{1000} = 0.13$.\n\nNow we compute the estimated deviations $\\hat{D}_j = \\hat{P}_{A,t_j} - \\hat{p}_A \\hat{q}_j$:\n$\\hat{D}_1 = 0.21 - (0.5 \\times 0.3) = 0.21 - 0.15 = 0.06$.\n$\\hat{D}_2 = 0.16 - (0.5 \\times 0.4) = 0.16 - 0.20 = -0.04$.\n$\\hat{D}_3 = 0.13 - (0.5 \\times 0.3) = 0.13 - 0.15 = -0.02$.\n\nThe denominator of the $r^2$ expression is $\\hat{p}_A(1-\\hat{p}_A) = 0.5 \\times (1-0.5) = 0.25$.\nThe numerator is $\\sum_{j=1}^{3} \\frac{\\hat{D}_j^2}{\\hat{q}_j}$:\n$$ \\sum_{j=1}^{3} \\frac{\\hat{D}_j^2}{\\hat{q}_j} = \\frac{(0.06)^2}{0.3} + \\frac{(-0.04)^2}{0.4} + \\frac{(-0.02)^2}{0.3} $$\n$$ = \\frac{0.0036}{0.3} + \\frac{0.0016}{0.4} + \\frac{0.0004}{0.3} $$\n$$ = 0.012 + 0.004 + 0.001333... = 0.017333... $$\nFinally, we compute the value of $r^2$:\n$$ r^2 = \\frac{0.017333...}{0.25} = 0.069333... $$\nThe problem requires the result to be rounded to four significant figures. The first four significant figures are $6, 9, 3, 3$. The following digit is $3$, so we round down.\nThe numerical value is $0.06933$.", "answer": "$$\\boxed{0.06933}$$", "id": "2401334"}, {"introduction": "Haplotype blocks are fundamental units of genomic organization, defined by regions of low historical recombination. The Four-Gamete Rule provides a direct way to infer recombination events from haplotype data. This hands-on coding challenge asks you to implement a greedy algorithm based on this rule to partition a chromosome into maximal contiguous blocks, providing a practical link between the evolutionary process of recombination and the observable structure of the genome [@problem_id:2401326].", "problem": "Implement a program that, given phased biallelic haplotype data for a contiguous set of loci, partitions the loci into candidate haplotype blocks using the Four-Gamete Rule. The program must be written from first principles and must not rely on pre-built population genetics libraries. The algorithmic basis should start from core definitions of haplotypes, recombination, and the Four-Gamete Rule under the infinite-sites model, without shortcut formulas. The data are represented as a matrix of integers where rows are haplotypes and columns are loci. Each entry is in the set $\\{0,1\\}$ for observed alleles, with optional missing values denoted by $-1$. A block is defined as a maximal contiguous set of loci such that no pair of loci within the same block exhibits all four biallelic combinations across the observed haplotypes, ignoring rows with missing data at either locus. The task is to implement a greedy left-to-right algorithm that yields the coarsest partition into such blocks.\n\nDefinitions and constraints:\n- A haplotype matrix $H$ has shape $n \\times m$ with $n \\ge 1$ haplotypes (rows) and $m \\ge 1$ loci (columns). Entries are in $\\{0,1\\}$ or the missing symbol $-1$.\n- For two loci $i$ and $j$, enumerate observed allele pairs $(H_{r,i}, H_{r,j})$ across rows $r \\in \\{0,\\dots,n-1\\}$, ignoring any row where either value is $-1$. If the set of observed pairs equals $\\{(0,0),(0,1),(1,0),(1,1)\\}$, then loci $i$ and $j$ are said to exhibit four gametes (evidence of historical recombination or recurrent mutation under the infinite-sites model).\n- A valid block is a maximal contiguous index range $[s,e]$ with $0 \\le s \\le e \\le m-1$ such that for every pair $(i,j)$ with $s \\le i < j \\le e$, the observed pairs do not contain all four gametes.\n- The greedy partitioning algorithm must scan loci from left to right, growing the current block by attempting to add the next locus. If adding a locus $j$ would create any pair $(i,j)$ with four gametes for some $i$ already in the block, then the current block ends at $j-1$ and a new block starts at $j$. Continue until all loci are assigned to blocks. The result must be the list of blocks as index intervals $[s,e]$ using $0$-based inclusive indices.\n\nInput to be embedded in the program as a test suite:\n- Use the missing data symbol $-1$ exactly as specified.\n- All indices are $0$-based and inclusive.\n- Test matrices are listed row-wise; each inner list represents a row (haplotype).\n\nTest suite (five cases):\n1. Case T$1$ (no four-gamete evidence, single block):\n   - $H_1$ is $4 \\times 4$:\n     - Row $0$: $[0,0,0,0]$\n     - Row $1$: $[1,1,1,1]$\n     - Row $2$: $[0,0,0,0]$\n     - Row $3$: $[1,1,1,1]$\n   - Expected to produce a single block spanning indices $[0,3]$.\n\n2. Case T$2$ (one internal boundary due to four gametes when extending):\n   - $H_2$ is $6 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,0,0,1,1]$\n     - Row $2$: $[1,1,1,0,0]$\n     - Row $3$: $[1,1,1,1,1]$\n     - Row $4$: $[0,0,0,0,0]$\n     - Row $5$: $[1,1,1,1,1]$\n   - Adding locus index $3$ introduces all four gametes with earlier loci, creating a boundary between indices $2$ and $3$. The second block spans indices $[3,4]$.\n\n3. Case T$3$ (missing data prevent four-gamete detection, larger block):\n   - $H_3$ is $6 \\times 4$:\n     - Row $0$: $[0,0,0,0]$\n     - Row $1$: $[0,0,0,1]$\n     - Row $2$: $[1,1,1,0]$\n     - Row $3$: $[1,1,1,-1]$\n     - Row $4$: $[0,0,0,0]$\n     - Row $5$: $[1,1,1,-1]$\n   - Due to missing values $-1$ in the last column, not all four gametes are observed for any pair, yielding a single block $[0,3]$.\n\n4. Case T$4$ (every attempted extension triggers a boundary, single-locus blocks):\n   - $H_4$ is $4 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,1,0,1,0]$\n     - Row $2$: $[1,0,1,0,1]$\n     - Row $3$: $[1,1,1,1,1]$\n   - Alternating patterns ensure four gametes between adjacent loci when attempting to extend, producing blocks $[0,0]$, $[1,1]$, $[2,2]$, $[3,3]$, $[4,4]$.\n\n5. Case T$5$ (monomorphic locus within a block):\n   - $H_5$ is $6 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,0,0,0,0]$\n     - Row $2$: $[1,1,1,0,1]$\n     - Row $3$: $[1,1,1,0,1]$\n     - Row $4$: $[0,0,0,0,0]$\n     - Row $5$: $[1,1,1,0,1]$\n   - The fourth column is monomorphic with allele $0$, and all other columns are in perfect concordance, leading to a single block $[0,4]$.\n\nFinal output format:\n- For each test case, output the list of block intervals as a list of two-integer lists $[s,e]$.\n- Aggregate the five case results into a single top-level list in order T$1$, T$2$, T$3$, T$4$, T$5$.\n- Your program should produce a single line of output containing this aggregate as a comma-separated list enclosed in square brackets with no spaces, for example: $[[[0,3]],[[0,2],[3,4]],\\dots]$.\n- Each $s$ and $e$ must be $0$-based indices and inclusive.\n\nThe program must compute these partitions using the specified algorithm and print exactly one line matching the format above. No physical units or angle units are involved. Express any fractions or proportions as decimals if needed (not required here).", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a clear computational task based on established principles in population genetics and bioinformatics. We may therefore proceed with the solution.\n\nThe problem requires the implementation of a greedy algorithm to partition a set of genetic loci into haplotype blocks. The criterion for this partition is the Four-Gamete Rule, a fundamental concept derived from the infinite-sites model of mutation.\n\nFirst, we must formalize the underlying scientific principle. The infinite-sites model posits that every new mutation occurs at a unique site along a chromosome that has not previously experienced a mutation in the sampled population. Consider two biallelic loci, located at positions $i$ and $j$, with alleles $\\{0,1\\}$. If no recombination has occurred between these two loci in the evolutionary history of the observed haplotypes, then at most three of the four possible two-locus gametes—$(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$—can exist. The appearance of the fourth gamete can only be explained by a recombination event between the loci or by a recurrent mutation at one of the sites, the latter of which is disallowed by the infinite-sites model. Thus, the presence of all four gametes, denoted as a \"four-gamete pair,\" is strong evidence for at least one historical recombination event between the loci.\n\nThe core of the algorithm is a function to test for this condition. Let the input haplotype data be represented by a matrix $H$ of size $n \\times m$, where $n$ is the number of haplotypes and $m$ is the number of loci. An entry $H_{r,k}$ represents the allele at locus $k$ for haplotype $r$, where $k \\in \\{0, \\dots, m-1\\}$ and $r \\in \\{0, \\dots, n-1\\}$. Alleles are in $\\{0,1\\}$, with $-1$ indicating missing data.\n\nTo determine if two loci, $i$ and $j$, constitute a four-gamete pair, we perform the following check:\n1. Initialize an empty set, $S_{i,j}$, to store unique, valid allele pairs.\n2. Iterate through each haplotype $r$ from $0$ to $n-1$.\n3. For each haplotype $r$, consider the allele pair $(H_{r,i}, H_{r,j})$.\n4. If either $H_{r,i} = -1$ or $H_{r,j} = -1$, this pair contains missing data and must be ignored.\n5. If the pair is valid, add it to the set $S_{i,j}$.\n6. After iterating through all $n$ haplotypes, the test for a four-gamete pair is positive if and only if the set $S_{i,j}$ is equal to $\\{(0,0), (0,1), (1,0), (1,1)\\}$. For biallelic data, this is equivalent to checking if the cardinality of the set, $|S_{i,j}|$, is equal to $4$.\n\nWith this test established, we can construct the greedy block partitioning algorithm as specified. The algorithm proceeds from left to right across the loci, extending a block as far as possible.\n\nLet $m$ be the total number of loci, indexed from $0$ to $m-1$.\n1. Initialize an empty list, $\\mathcal{B}$, to store the resulting block partitions.\n2. Initialize the starting index of the current block, $s$, to $0$.\n3. Iterate with a prospective locus index, $j$, from $1$ to $m-1$. For each $j$, we test if locus $j$ can be included in the current block that starts at index $s$.\n4. To perform this test, we must check for a four-gamete violation between locus $j$ and every locus $i$ already in the current block, where $i$ ranges from $s$ to $j-1$.\n5. A violation occurs if the four-gamete test is positive for any pair of loci $(i,j)$ within this range.\n6. If a violation is found for some locus $i \\in [s, j-1]$:\n   a. The current block is finalized. Its interval is $[s, j-1]$. This interval is added to the list $\\mathcal{B}$.\n   b. A new block must begin at the current locus $j$. The start index $s$ is updated to $j$.\n   c. The inner check for other loci $i$ is terminated, and the algorithm proceeds to the next prospective locus, $j+1$.\n7. If the inner loop over all $i \\in [s, j-1]$ completes without finding any four-gamete violation, locus $j$ is successfully added to the current block. The algorithm then proceeds to evaluate the next locus, $j+1$, without changing the block start $s$.\n8. After the main loop over $j$ completes, the final block, which starts at the current value of $s$ and extends to the last locus $m-1$, must be finalized and added to $\\mathcal{B}$. The interval is $[s, m-1]$.\n\nThis deterministic, greedy procedure produces a unique partition of the loci into contiguous blocks for any given haplotype matrix $H$. Each block is maximal in the sense that it could not be extended further to the right without violating the Four-Gamete Rule.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the block partitioning algorithm.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case T1\n        [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]],\n        # Case T2\n        [[0, 0, 0, 0, 0], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]],\n        # Case T3\n        [[0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0], [1, 1, 1, -1], [0, 0, 0, 0], [1, 1, 1, -1]],\n        # Case T4\n        [[0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]],\n        # Case T5\n        [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1]],\n    ]\n\n    def check_four_gametes(locus1_col, locus2_col):\n        \"\"\"\n        Checks if two loci exhibit all four gametic types.\n        Missing data (-1) are ignored.\n        \n        Args:\n            locus1_col (np.ndarray): A 1D array representing allele data for the first locus.\n            locus2_col (np.ndarray): A 1D array representing allele data for the second locus.\n        \n        Returns:\n            bool: True if four gametes are observed, False otherwise.\n        \"\"\"\n        observed_pairs = set()\n        for i in range(len(locus1_col)):\n            allele1 = locus1_col[i]\n            allele2 = locus2_col[i]\n            \n            # Ignore haplotypes with missing data at either locus\n            if allele1 != -1 and allele2 != -1:\n                observed_pairs.add((allele1, allele2))\n        \n        # The condition is met if the number of unique pairs is exactly 4\n        return len(observed_pairs) == 4\n\n    def find_blocks(haplotype_matrix):\n        \"\"\"\n        Partitions loci into blocks using the greedy Four-Gamete Rule algorithm.\n        \n        Args:\n            haplotype_matrix (list of lists): The input matrix of haplotypes.\n            \n        Returns:\n            list of lists: A list of [start, end] intervals for each block.\n        \"\"\"\n        H = np.array(haplotype_matrix, dtype=np.int8)\n        _n_haplotypes, n_loci = H.shape\n\n        if n_loci == 0:\n            return []\n        if n_loci == 1:\n            return [[0, 0]]\n\n        blocks = []\n        block_start = 0\n\n        # Iterate through loci to decide where blocks end\n        for j in range(1, n_loci):\n            violation_found = False\n            # Check current locus j against all previous loci in the current block\n            for i in range(block_start, j):\n                if check_four_gametes(H[:, i], H[:, j]):\n                    # Violation found, end the current block here\n                    blocks.append([block_start, j - 1])\n                    # Start a new block at the current locus\n                    block_start = j\n                    violation_found = True\n                    break\n            if violation_found:\n                continue\n        \n        # Add the last block, which extends to the end of the loci\n        blocks.append([block_start, n_loci - 1])\n        \n        return blocks\n\n    results = []\n    for case in test_cases:\n        result = find_blocks(case)\n        results.append(result)\n\n    # Final print statement in the exact required format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2401326"}]}