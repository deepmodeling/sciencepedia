{"hands_on_practices": [{"introduction": "Before diving into complex biological questions, the first critical step in any ChIP-seq analysis is to assess the quality of the data. A successful experiment should concentrate sequencing reads in biologically meaningful regions (peaks) while avoiding non-specific or artifact-prone areas of the genome. This exercise [@problem_id:2397933] challenges you to implement a widely-used quality control metric that quantifies this signal-to-noise ratio, providing a hands-on introduction to the essential bioinformatics skill of working with genomic intervals.", "problem": "You are given a mathematical formalization of quality control for histone modification Chromatin Immunoprecipitation followed by sequencing (ChIP-seq) experiments. The genome is modeled as a one-dimensional coordinate axis of length $L$ base pairs (bp), with all coordinates as integers. Each aligned read is represented as a half-open genomic interval $[s_i, e_i)$ with $0 \\le s_i < e_i \\le L$. Candidate peaks are represented as a finite set of half-open intervals $\\{P_j\\}$, and consensus blacklisted regions are represented as a finite set of half-open intervals $\\{B_k\\}$. All intervals are in base pairs.\n\nDefine the indicator that read $i$ intersects a set of intervals $S$ as follows: read $i$ intersects $S$ if and only if the intersection of $[s_i, e_i)$ with the union of intervals in $S$ has nonzero length under half-open semantics, that is,\n$$\n\\max(s_i, a) < \\min(e_i, b)\n$$\nfor at least one interval $[a,b) \\in S$. A read is counted at most once per set (peaks or blacklist) regardless of how many intervals within the set it intersects. Reads that intersect both the peaks and the blacklist are counted in both tallies.\n\nLet $R_{\\mathrm{peaks}}$ be the number of reads that intersect at least one peak interval and $R_{\\mathrm{blacklist}}$ be the number of reads that intersect at least one blacklist interval. For a given pseudocount $\\epsilon > 0$, define the quality control metric\n$$\nQ \\;=\\; \\frac{R_{\\mathrm{peaks}} + \\epsilon}{R_{\\mathrm{blacklist}} + \\epsilon}\n$$.\nThis ratio quantifies the enrichment of reads in peaks (RiP) relative to reads in consensus blacklist regions, with pseudocount stabilization.\n\nYour task is to compute $Q$ for each of the following test cases. Use the same pseudocount $\\epsilon = 0.5$ for all cases. All coordinates are integers in base pairs, and all intervals are half-open $[x,y)$.\n\nTest Suite (each case provides $L$, the list of reads, the list of peaks, and the list of blacklist intervals):\n- Case $1$:\n  - $L = 1000$, $\\epsilon = 0.5$.\n  - Reads: $[(90,110),(140,170),(180,210),(300,320),(405,415),(495,505),(800,820),(850,870),(880,920),(0,10)]$.\n  - Peaks: $[(100,200),(400,500)]$.\n  - Blacklist: $[(150,160),(800,900)]$.\n- Case $2$:\n  - $L = 1000$, $\\epsilon = 0.5$.\n  - Reads: $[(110,115),(150,160),(90,95),(300,310)]$.\n  - Peaks: $[(100,200)]$.\n  - Blacklist: $[(600,700)]$.\n- Case $3$:\n  - $L = 1000$, $\\epsilon = 0.5$.\n  - Reads: $[(805,815),(810,830),(200,210)]$.\n  - Peaks: $[(400,450)]$.\n  - Blacklist: $[(800,820)]$.\n- Case $4$ (boundary conditions under half-open semantics):\n  - $L = 500$, $\\epsilon = 0.5$.\n  - Reads: $[(80,100),(200,220),(199,200),(250,260),(150,200)]$.\n  - Peaks: $[(100,200)]$.\n  - Blacklist: $[(200,250)]$.\n- Case $5$ (overlaps with both peaks and blacklist, including duplicate reads):\n  - $L = 1000$, $\\epsilon = 0.5$.\n  - Reads: $[(240,260),(620,630),(610,615),(660,670),(0,50),(295,305),(620,630)]$.\n  - Peaks: $[(100,300),(600,650)]$.\n  - Blacklist: $[(250,350),(620,700)]$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of the $Q$ values for Cases $1$ through $5$, in order, enclosed in square brackets. Each $Q$ value must be rounded to exactly $6$ decimal places. For example, an output with three values should look like $[0.500000,1.250000,2.000000]$.", "solution": "The problem requires the computation of a quality control metric, $Q$, for a series of Chromatin Immunoprecipitation sequencing (ChIP-seq) experiments. The metric is defined as the ratio of read counts in designated peak regions to read counts in blacklisted regions, stabilized by a pseudocount $\\epsilon$.\n\nThe fundamental geometric objects are one-dimensional half-open intervals $[s, e)$, representing genomic locations. We are given a set of reads $\\{[s_i, e_i)\\}$, a set of peak intervals $\\{P_j\\}$, and a set of blacklist intervals $\\{B_k\\}$. The problem provides a precise definition for the intersection of a read interval with a set of intervals. A read $[s_i, e_i)$ is considered to intersect a set of intervals $S$ if there exists at least one interval $[a, b) \\in S$ such that their intersection has a non-zero length. This condition is formally stated as $\\max(s_i, a) < \\min(e_i, b)$.\n\nOur objective is to calculate two quantities for each test case:\n$1$. $R_{\\mathrm{peaks}}$, the total number of reads that intersect the set of peak intervals $\\{P_j\\}$.\n$2$. $R_{\\mathrm{blacklist}}$, the total number of reads that intersect the set of blacklist intervals $\\{B_k\\}$.\n\nA read is counted if it intersects with at least one interval in a given set. It is counted only once for that set, regardless of how many intervals within the set it overlaps. If a read intersects with both an interval from the peak set and an interval from the blacklist set, it contributes to both counts, $R_{\\mathrm{peaks}}$ and $R_{\\mathrm{blacklist}}$.\n\nThe quality control metric $Q$ is then calculated using the formula:\n$$\nQ = \\frac{R_{\\mathrm{peaks}} + \\epsilon}{R_{\\mathrm{blacklist}} + \\epsilon}\n$$\nFor all test cases, the pseudocount is given as $\\epsilon = 0.5$.\n\nThe algorithmic procedure is as follows:\nFor each test case:\nInitialize counts $R_{\\mathrm{peaks}} = 0$ and $R_{\\mathrm{blacklist}} = 0$.\nIterate through each read interval $[s_i, e_i)$ provided in the list of reads.\nFor the current read, we perform two independent checks:\nFirst, we check for intersection with the peak set. We iterate through each peak interval $[p_s, p_e) \\in \\{P_j\\}$. If the condition $\\max(s_i, p_s) < \\min(e_i, p_e)$ is met for any peak interval, the read intersects the peak set. We increment $R_{\\mathrm{peaks}}$ by $1$ and cease checking against other peak intervals for this read.\nSecond, we check for intersection with the blacklist set. We iterate through each blacklist interval $[b_s, b_e) \\in \\{B_k\\}$. If the condition $\\max(s_i, b_s) < \\min(e_i, b_e)$ is met for any blacklist interval, the read intersects the blacklist set. We increment $R_{\\mathrm{blacklist}}$ by $1$ and cease checking against other blacklist intervals for this read.\nAfter iterating through all reads, we use the final counts $R_{\\mathrm{peaks}}$ and $R_{\\mathrm{blacklist}}$ to compute $Q$ using the given formula.\n\nWe apply this procedure to each test case.\n\nCase $1$: $R_{\\mathrm{peaks}} = 5$, $R_{\\mathrm{blacklist}} = 4$.\n$$Q = \\frac{5 + 0.5}{4 + 0.5} = \\frac{5.5}{4.5} \\approx 1.222222$$\n\nCase $2$: $R_{\\mathrm{peaks}} = 2$, $R_{\\mathrm{blacklist}} = 0$.\n$$Q = \\frac{2 + 0.5}{0 + 0.5} = \\frac{2.5}{0.5} = 5.0$$\n\nCase $3$: $R_{\\mathrm{peaks}} = 0$, $R_{\\mathrm{blacklist}} = 2$.\n$$Q = \\frac{0 + 0.5}{2 + 0.5} = \\frac{0.5}{2.5} = 0.2$$\n\nCase $4$: $R_{\\mathrm{peaks}} = 2$, $R_{\\mathrm{blacklist}} = 1$. The half-open interval definition is crucial here. For example, read $[80, 100)$ does not intersect peak $[100, 200)$ because $\\max(80, 100) = 100$ and $\\min(100, 200) = 100$, and the condition $100 < 100$ is false.\n$$Q = \\frac{2 + 0.5}{1 + 0.5} = \\frac{2.5}{1.5} \\approx 1.666667$$\n\nCase $5$: $R_{\\mathrm{peaks}} = 5$, $R_{\\mathrm{blacklist}} = 5$. The read list contains a duplicate entry, $(620, 630)$, which is treated as two distinct reads, both of which are processed according to the rules. Both instances of this read intersect with both the peak and blacklist sets.\n$$Q = \\frac{5 + 0.5}{5 + 0.5} = \\frac{5.5}{5.5} = 1.0$$\n\nThe final results are collected and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the ChIP-seq quality control metric Q for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 1000,\n            \"reads\": [(90, 110), (140, 170), (180, 210), (300, 320), (405, 415), (495, 505), (800, 820), (850, 870), (880, 920), (0, 10)],\n            \"peaks\": [(100, 200), (400, 500)],\n            \"blacklist\": [(150, 160), (800, 900)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(110, 115), (150, 160), (90, 95), (300, 310)],\n            \"peaks\": [(100, 200)],\n            \"blacklist\": [(600, 700)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(805, 815), (810, 830), (200, 210)],\n            \"peaks\": [(400, 450)],\n            \"blacklist\": [(800, 820)],\n        },\n        {\n            \"L\": 500,\n            \"reads\": [(80, 100), (200, 220), (199, 200), (250, 260), (150, 200)],\n            \"peaks\": [(100, 200)],\n            \"blacklist\": [(200, 250)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(240, 260), (620, 630), (610, 615), (660, 670), (0, 50), (295, 305), (620, 630)],\n            \"peaks\": [(100, 300), (600, 650)],\n            \"blacklist\": [(250, 350), (620, 700)],\n        },\n    ]\n\n    epsilon = 0.5\n    results = []\n\n    def intersects_set(read_interval, interval_set):\n        \"\"\"\n        Checks if a read interval intersects with any interval in a given set.\n        Intersection of [s, e) and [a, b) is non-empty if max(s, a) < min(e, b).\n        \"\"\"\n        s_i, e_i = read_interval\n        for a_j, b_j in interval_set:\n            if max(s_i, a_j) < min(e_i, b_j):\n                return True\n        return False\n\n    for case in test_cases:\n        reads = case[\"reads\"]\n        peaks = case[\"peaks\"]\n        blacklist = case[\"blacklist\"]\n\n        r_peaks = 0\n        r_blacklist = 0\n\n        for read in reads:\n            # Check for intersection with peaks\n            if intersects_set(read, peaks):\n                r_peaks += 1\n            \n            # Check for intersection with blacklist\n            if intersects_set(read, blacklist):\n                r_blacklist += 1\n        \n        # Calculate the quality metric Q\n        Q = (r_peaks + epsilon) / (r_blacklist + epsilon)\n        results.append(f\"{Q:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2397933"}, {"introduction": "Once we have confidence in our data's quality, the central task in ChIP-seq analysis is to identify genomic regions with a significant enrichment of reads, a process known as 'peak calling'. This practice [@problem_id:2397925] frames peak calling as a statistical hypothesis testing problem, where you will model the random background read distribution using a Poisson process. By implementing this model, calculating p-values for potential peaks, and applying a robust correction for multiple testing, you will gain fundamental insights into how raw read counts are transformed into meaningful biological signals.", "problem": "You are asked to design and implement a simple peak caller for Chromatin Immunoprecipitation followed by Deoxyribonucleic Acid sequencing (ChIP-seq) read pileups by modeling read arrivals along a genomic interval as a homogeneous Poisson point process. The scientifically grounded base is the definition of a homogeneous Poisson point process: counts of events in disjoint intervals are independent, and the count in any interval of length $w$ follows a Poisson distribution with mean $\\lambda w$, where $\\lambda$ is the constant event rate per unit length. In this context, under a null model of no enrichment, ChIP-seq reads are idealized as events of a homogeneous Poisson point process along a genome segment of length $L$ with background rate $\\lambda_0$ reads per base pair. A scanning window of width $w$ base pairs produces a read count whose null distribution is Poisson with mean $\\mu = \\lambda_0 w$. To detect enrichment, compare the observed count in each window against this null distribution using a one-sided tail probability for observing at least the measured count, and then control the False Discovery Rate (FDR) across all tested windows using the Benjamini–Hochberg step-up procedure.\n\nYour task is to write a complete program that:\n- Accepts, as internal constants in code, the following for each test case: a list of read positions (as integers in base pairs measured from $0$ to $L-1$), the genomic interval length $L$ (in base pairs), the window width $w$ (in base pairs), the scanning stride $s$ (in base pairs), the background rate $\\lambda_0$ (in reads per base pair), and the target FDR level $q$ (as a decimal, not a percentage).\n- Scans windows $[t, t+w)$ with starts $t \\in \\{0, s, 2s, \\ldots\\}$ constrained so that $t + w \\le L$.\n- Counts reads in each window, computes the one-sided tail probability under the Poisson null with mean $\\mu = \\lambda_0 w$ for the event “observed count is at least the measured count,” and applies the Benjamini–Hochberg step-up procedure at target level $q$ across all scanned windows within the test case.\n- Returns, for each test case, the list of window start coordinates (in base pairs) that are called significant after multiple-testing correction. The list must be sorted in ascending order by genomic coordinate.\n\nScientific and algorithmic constraints:\n- Use the homogeneous Poisson point process as the null model for background read arrivals with constant rate $\\lambda_0$; in a window of width $w$, the null count distribution is Poisson with mean $\\mu = \\lambda_0 w$.\n- Use a one-sided enrichment test per window that evaluates the tail probability of observing at least the measured count under the Poisson null.\n- Control the False Discovery Rate using the Benjamini–Hochberg step-up procedure at level $q$ applied to all windows in a test case.\n- Positions are measured in base pairs; report window start coordinates in base pairs as integers.\n\nTest suite to implement within your program (each is an independent test case):\n- Case A (background only; no peaks expected): $L = 1000$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.1$, read positions $[50, 250, 750]$. Expected behavior: no significant windows.\n- Case B (one clear internal peak): $L = 1000$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.1$, read positions $[20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]$. Expected behavior: the window starting at $400$ base pairs is significant.\n- Case C (boundary peak at the end): $L = 500$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.05$, read positions $[401, 402, 415, 420, 430, 440, 450, 460, 480]$. Expected behavior: the window starting at $400$ base pairs is significant.\n- Case D (multiple moderate peaks; multiple-testing interaction): $L = 800$, $w = 100$, $s = 100$, $\\lambda_0 = 0.01$ reads per base pair, $q = 0.1$, read positions $[110, 115, 120, 130, 180, 505, 510, 530, 540, 590]$. Expected behavior: the windows starting at $100$ and $500$ base pairs are significant.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all four cases as a comma-separated list enclosed in square brackets, where each element is itself a list of integers representing significant window start coordinates for the corresponding case. For example, a valid format is $[[\\dots],[\\dots],[\\dots],[\\dots]]$ with no extra text. All coordinates must be in base pairs (bp) as integers.", "solution": "We are tasked with designing a computational procedure to identify regions of signal enrichment in Chromatin Immunoprecipitation sequencing (ChIP-seq) data. This is a canonical problem in computational genomics known as \"peak calling.\" The provided problem statement is scientifically sound and algorithmically well-defined, resting on established biostatistical principles. It is therefore valid, and we proceed to construct the solution.\n\nThe fundamental premise is to model the background distribution of sequencing reads using a stochastic process. Under the null hypothesis of no specific protein-Deoxyribonucleic Acid binding, reads are assumed to be distributed randomly across the genome. A homogeneous Poisson point process provides a simple yet powerful null model for this random background.\n\nThe core of our method consists of three stages: first, partitioning the genome and quantifying read counts; second, evaluating the statistical significance of observed counts against the null model; and third, correcting for the multiplicity of tests performed across the genome.\n\nFirst, we address the task of genomic tiling and read counting. The genomic interval of length $L$ is scanned using a sliding window of width $w$ and stride $s$. The start coordinates of these windows are given by the set $\\{t_i = i \\cdot s \\mid i \\in \\mathbb{Z}_{\\ge 0}, i \\cdot s + w \\le L\\}$. The total number of windows, and thus the total number of statistical tests, is $M = \\lfloor \\frac{L-w}{s} \\rfloor + 1$. For each window $i$, which spans the genomic interval $[t_i, t_i+w)$, we count the number of observed reads, denoted $k_i$, whose positions fall within this interval.\n\nSecond, we formulate the statistical test for enrichment. The null hypothesis, $H_0$, states that read arrivals follow a homogeneous Poisson process with a constant rate of $\\lambda_0$ reads per base pair. Consequently, the number of reads $X$ in any window of width $w$ follows a Poisson distribution with mean parameter $\\mu = \\lambda_0 w$. The probability mass function is $P(X=k | H_0) = \\frac{e^{-\\mu}\\mu^k}{k!}$. To test for enrichment, we compute a one-sided p-value for each window $i$. This p-value is the probability of observing a read count of at least $k_i$ under the null distribution. This corresponds to the survival function (or complementary cumulative distribution function) of the Poisson distribution:\n$$p_i = P(X \\ge k_i) = \\sum_{j=k_i}^{\\infty} \\frac{e^{-\\mu}\\mu^j}{j!} = 1 - \\sum_{j=0}^{k_i-1} \\frac{e^{-\\mu}\\mu^j}{j!}$$\nA small p-value suggests that the observed count $k_i$ is improbably high under the assumption of a random background, providing evidence against the null hypothesis for that specific window.\n\nThird, we must address the multiple hypothesis testing problem. Since we perform $M$ independent or correlated tests, one for each window, using a naive p-value threshold (e.g., $p \\le 0.05$) would inflate the rate of false positive discoveries. To control this, we employ the Benjamini–Hochberg (BH) procedure to control the False Discovery Rate (FDR) at a specified level $q$. The FDR is the expected proportion of rejected null hypotheses that are falsely rejected. The BH procedure is as follows:\n1.  Collect the set of all $M$ p-values, $\\{p_1, p_2, \\ldots, p_M\\}$.\n2.  Sort these p-values in ascending order: $p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(M)}$.\n3.  Find the largest integer rank $k$ such that the $k$-th ordered p-value satisfies the condition:\n    $$p_{(k)} \\le \\frac{k}{M}q$$\n4.  If such a $k$ exists, we reject the null hypotheses for all windows corresponding to the p-values $p_{(1)}, p_{(2)}, \\ldots, p_{(k)}$. These windows are declared \"significant.\"\n5.  If no such $k$ exists (i.e., $p_{(1)} > \\frac{1}{M}q$), no null hypotheses are rejected, and no windows are declared significant.\n\nThis procedure guarantees that for independent tests, the expected FDR is less than or equal to $q$. The final output is the sorted list of start coordinates $t_i$ for all windows identified as significant by this procedure.\n\nThe algorithmic implementation will therefore systematically execute these steps:\n1.  Generate all window start coordinates based on $L$, $w$, and $s$.\n2.  For each window, efficiently count the reads falling within its boundaries. Sorting the read positions initially allows for rapid counting using binary search.\n3.  Calculate the Poisson parameter $\\mu = \\lambda_0 w$.\n4.  For each window count $k_i$, compute the corresponding p-value using the survival function of the Poisson($\\mu$) distribution.\n5.  Apply the Benjamini-Hochberg procedure to the set of all p-values to identify the subset of significant findings.\n6.  Return the start coordinates of the significant windows, sorted in ascending order.\nThis provides a rigorous and complete framework for the problem posed.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run the ChIP-seq peak calling analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (background only; no peaks expected)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [50, 250, 750]\n        },\n        # Case B (one clear internal peak)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]\n        },\n        # Case C (boundary peak at the end)\n        {\n            \"L\": 500, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.05,\n            \"read_positions\": [401, 402, 415, 420, 430, 440, 450, 460, 480]\n        },\n        # Case D (multiple moderate peaks; multiple-testing interaction)\n        {\n            \"L\": 800, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [110, 115, 120, 130, 180, 505, 510, 530, 540, 590]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        w = case[\"w\"]\n        s = case[\"s\"]\n        lambda_0 = case[\"lambda_0\"]\n        q = case[\"q\"]\n        read_positions = np.array(sorted(case[\"read_positions\"]))\n\n        # Step 1: Generate window starts and count reads\n        window_starts = np.arange(0, L - w + 1, s, dtype=int)\n        \n        # Efficiently count reads in each window using pre-sorted positions\n        window_counts = np.zeros_like(window_starts, dtype=int)\n        for i, start in enumerate(window_starts):\n            end = start + w\n            left_idx = np.searchsorted(read_positions, start, side='left')\n            right_idx = np.searchsorted(read_positions, end, side='left')\n            window_counts[i] = right_idx - left_idx\n        \n        # Step 2: Calculate p-values based on Poisson null model\n        mu = lambda_0 * w\n        \n        # Calculate p-value: P(X >= k) = 1 - P(X <= k-1). \n        # This is the survival function (sf).\n        # We use k-1 because sf(k, mu) calculates P(X > k). So sf(k-1, mu) is P(X >= k).\n        # For k=0, k-1=-1. scipy.stats.poisson.sf handle this correctly and return 1.0.\n        p_values = poisson.sf(window_counts - 1, mu)\n        \n        # Step 3: Apply Benjamini-Hochberg procedure\n        num_tests = len(p_values)\n        significant_windows = []\n\n        if num_tests > 0:\n            # Get original indices sorted by p-value\n            sorted_indices = np.argsort(p_values)\n            sorted_p_values = p_values[sorted_indices]\n            \n            # Calculate BH thresholds\n            ranks = np.arange(1, num_tests + 1)\n            bh_thresholds = (ranks / num_tests) * q\n            \n            # Find p-values that are below the BH threshold\n            significant_mask = sorted_p_values <= bh_thresholds\n            \n            if np.any(significant_mask):\n                # Find the largest rank k for which p_(k) <= (k/m)*q\n                max_significant_rank_idx = np.where(significant_mask)[0][-1]\n                \n                # All hypotheses up to this rank are rejected\n                significant_original_indices = sorted_indices[:max_significant_rank_idx + 1]\n                \n                # Get the window start coordinates for the significant windows\n                significant_starts = window_starts[significant_original_indices]\n                significant_windows = sorted(significant_starts.tolist())\n\n        results.append(significant_windows)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list is what's needed for the inner elements.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397925"}, {"introduction": "With high-confidence peak sets in hand, we can transition from data processing to biological discovery by integrating information across multiple experiments. Certain combinations of histone modifications define unique regulatory states; a prime example is the 'bivalent' promoter, which is co-marked by both activating $H3K4me3$ and repressive $H3K27me3$ modifications. In this exercise [@problem_id:2397930], you will apply your skills in genomic interval analysis to integrate two distinct peak datasets, simulating the process of discovering these critical regulatory elements that poise genes for future activity.", "problem": "You are given abstracted representations of Chromatin Immunoprecipitation followed by sequencing (ChIP-seq) peak calls for two histone modifications, histone H3 lysine 4 tri-methylation ($H3K4me3$) and histone H3 lysine 27 tri-methylation ($H3K27me3$), and a list of promoter intervals on a single chromosome. Each interval is represented as a half-open interval $[s,e)$ on the integer coordinate axis in base pairs, where $s$ and $e$ are integers with $s &lt; e$. The length of an interval $[s,e)$ is $e - s$ in base pairs. The overlap length between two intervals is defined as the number of integer positions they share; due to the half-open convention, if two intervals only touch at a boundary point (for example, $[100,200)$ and $[200,300)$), their overlap length is $0$.\n\nDefine a promoter to be bivalent if and only if there exists at least one $H3K4me3$ peak whose overlap length with the promoter is greater than or equal to a given threshold $t_{4}$ (in base pairs) and there exists at least one $H3K27me3$ peak whose overlap length with the promoter is greater than or equal to a given threshold $t_{27}$ (in base pairs). The overlap criterion is applied per-peak independently; do not combine or sum overlap lengths across multiple peaks for a given modification. If a peak list for a modification is empty, then no promoter can satisfy the existence condition for that modification.\n\nFor each test case below, you must compute the number of bivalent promoters. All coordinates are integers in base pairs, and all thresholds $t_{4}$ and $t_{27}$ are nonnegative integers in base pairs. Express all results as integer counts. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[a,b,c]$), where each entry corresponds to the number of bivalent promoters for the corresponding test case in the same order as listed.\n\nTest Suite:\n\n- Test case $1$ (general case):\n  - Promoters (ID, $[s,e)$): $(1,[1000,1500))$, $(2,[2000,2300))$, $(3,[3000,3300))$.\n  - H3K4me3 peaks $[s,e)$: $[1100,1400)$, $[1950,2100)$, $[3100,3120)$, $[5000,5100)$.\n  - H3K27me3 peaks $[s,e)$: $[1200,1600)$, $[2250,2350)$, $[3150,3290)$.\n  - Thresholds: $t_{4} = 100$, $t_{27} = 100$.\n- Test case $2$ (boundary-touching and minimal positive overlaps):\n  - Promoters (ID, $[s,e)$): $(1,[100,200))$, $(2,[400,500))$, $(3,[700,800))$.\n  - H3K4me3 peaks $[s,e)$: $[200,300)$, $[350,400)$, $[700,701)$.\n  - H3K27me3 peaks $[s,e)$: $[50,100)$, $[500,600)$, $[799,900)$.\n  - Thresholds: $t_{4} = 1$, $t_{27} = 1$.\n- Test case $3$ (multiple peaks per modification, per-peak thresholds not summed):\n  - Promoters (ID, $[s,e)$): $(1,[1000,1100))$, $(2,[2000,2100))$, $(3,[3000,3100))$.\n  - H3K4me3 peaks $[s,e)$: $[950,980)$, $[1070,1120)$, $[1990,2060)$, $[2900,3000)$, $[3000,3050)$.\n  - H3K27me3 peaks $[s,e)$: $[1005,1050)$, $[2090,2150)$, $[2050,2105)$, $[3050,3100)$.\n  - Thresholds: $t_{4} = 50$, $t_{27} = 50$.\n- Test case $4$ (empty peak list edge case):\n  - Promoters (ID, $[s,e)$): $(1,[100,200))$, $(2,[300,400))$.\n  - H3K4me3 peaks $[s,e)$: empty list.\n  - H3K27me3 peaks $[s,e)$: $[500,600)$.\n  - Thresholds: $t_{4} = 0$, $t_{27} = 0$.\n- Test case $5$ (zero thresholds admit non-overlaps when peaks exist):\n  - Promoters (ID, $[s,e)$): $(1,[100,200))$.\n  - H3K4me3 peaks $[s,e)$: $[0,50)$.\n  - H3K27me3 peaks $[s,e)$: $[500,600)$.\n  - Thresholds: $t_{4} = 0$, $t_{27} = 0$.\n\nYour program must deterministically compute, for each test case, the integer count of promoter IDs that satisfy the bivalency definition under the stated rules and thresholds, and then output a single line in the exact format $[a,b,c,d,e]$ corresponding to the five test cases in order.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in the principles of computational genomics, is mathematically well-posed, and is expressed with objective, unambiguous language. All necessary data and definitions for a deterministic solution are provided.\n\nThe core of the problem is to identify and count \"bivalent promoters\" based on a set of precise criteria involving the overlap of genomic intervals. A promoter is defined as bivalent if it meets two separate conditions simultaneously: one concerning the histone modification $H3K4me3$ and another concerning $H3K27me3$.\n\nLet a promoter interval be denoted by $P = [s_p, e_p)$ and a peak interval (for either modification) be denoted by $K = [s_k, e_k)$. The overlap length, $L_{overlap}$, between these two half-open intervals is the length of their intersection, which is calculated as:\n$$L_{overlap}(P, K) = \\max(0, \\min(e_p, e_k) - \\max(s_p, s_k))$$\nThis formula correctly computes the number of integer positions shared by the two intervals. The use of $\\max(0, \\dots)$ ensures that non-overlapping intervals have an overlap length of $0$.\n\nAccording to the provided definition, a promoter $P$ is bivalent if and only if both of the following logical conditions are satisfied:\n$1$. There exists at least one $H3K4me3$ peak, $K_4$, from the provided list of $H3K4me3$ peaks, such that its overlap with the promoter $P$ is greater than or equal to a specified threshold $t_4$. Formally:\n$$\\exists K_4 \\in \\{\\text{H3K4me3 peaks}\\} \\text{ such that } L_{overlap}(P, K_4) \\ge t_4$$\n$2$. There exists at least one $H3K27me3$ peak, $K_{27}$, from the provided list of $H3K27me3$ peaks, such that its overlap with the promoter $P$ is greater than or equal to a specified threshold $t_{27}$. Formally:\n$$\\exists K_{27} \\in \\{\\text{H3K27me3 peaks}\\} \\text{ such that } L_{overlap}(P, K_{27}) \\ge t_{27}$$\n\nThe problem explicitly states that these conditions are evaluated independently for each peak. The overlap lengths from multiple peaks of the same modification are not to be aggregated.\n\nThe algorithm to solve this problem is a direct implementation of this definition:\nFirst, we initialize a counter for bivalent promoters to $0$. We then iterate through each promoter in the given list. For each promoter, we must verify the two existence conditions.\n\nTo verify the $H3K4me3$ condition for a given promoter, we first check if the list of $H3K4me3$ peaks is empty. If it is empty, the existence condition cannot be satisfied, and the promoter cannot be bivalent. If the list is not empty, we iterate through each $H3K4me3$ peak, calculate its overlap length with the promoter, and compare it to the threshold $t_4$. If we find any peak that satisfies the condition $L_{overlap} \\ge t_4$, the $H3K4me3$ condition for the promoter is met, and we can immediately stop checking other $H3K4me3$ peaks for this promoter.\n\nIf the $H3K4me3$ condition is met, we proceed to verify the $H3K27me3$ condition in an analogous manner. We check if the $H3K27me3$ peak list is empty. If not, we iterate through the peaks, calculating their overlap with the promoter, until we find one that satisfies $L_{overlap} \\ge t_{27}$. If such a peak is found, the $H3K27me3$ condition is also met.\n\nA promoter is counted as bivalent if and only if both the $H3K4me3$ and $H3K27me3$ conditions are successfully verified. This process is repeated for all promoters, and the final value of the counter is the result for the test case.\n\nA special case arises when a threshold is zero, for instance $t_4 = 0$. Since the overlap length $L_{overlap}$ is, by definition, always non-negative ($L_{overlap} \\ge 0$), the condition $L_{overlap} \\ge 0$ is always true for any pair of intervals. Therefore, for a threshold of $0$, the existence condition for a modification is met if and only if its corresponding peak list is not empty.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bivalent promoter counting problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"promoters\": [(1000, 1500), (2000, 2300), (3000, 3300)],\n            \"h3k4me3_peaks\": [(1100, 1400), (1950, 2100), (3100, 3120), (5000, 5100)],\n            \"h3k27me3_peaks\": [(1200, 1600), (2250, 2350), (3150, 3290)],\n            \"t4\": 100,\n            \"t27\": 100,\n        },\n        # Test case 2 (boundary-touching and minimal positive overlaps)\n        {\n            \"promoters\": [(100, 200), (400, 500), (700, 800)],\n            \"h3k4me3_peaks\": [(200, 300), (350, 400), (700, 701)],\n            \"h3k27me3_peaks\": [(50, 100), (500, 600), (799, 900)],\n            \"t4\": 1,\n            \"t27\": 1,\n        },\n        # Test case 3 (multiple peaks per modification, per-peak thresholds not summed)\n        {\n            \"promoters\": [(1000, 1100), (2000, 2100), (3000, 3100)],\n            \"h3k4me3_peaks\": [(950, 980), (1070, 1120), (1990, 2060), (2900, 3000), (3000, 3050)],\n            \"h3k27me3_peaks\": [(1005, 1050), (2090, 2150), (2050, 2105), (3050, 3100)],\n            \"t4\": 50,\n            \"t27\": 50,\n        },\n        # Test case 4 (empty peak list edge case)\n        {\n            \"promoters\": [(100, 200), (300, 400)],\n            \"h3k4me3_peaks\": [],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n        # Test case 5 (zero thresholds admit non-overlaps when peaks exist)\n        {\n            \"promoters\": [(100, 200)],\n            \"h3k4me3_peaks\": [(0, 50)],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n    ]\n\n    def calculate_overlap(interval1, interval2):\n        \"\"\"\n        Calculates the overlap length between two half-open intervals [s, e).\n        \n        Args:\n            interval1 (tuple): A tuple (start, end) for the first interval.\n            interval2 (tuple): A tuple (start, end) for the second interval.\n            \n        Returns:\n            int: The non-negative integer overlap length.\n        \"\"\"\n        s1, e1 = interval1\n        s2, e2 = interval2\n        \n        overlap_start = max(s1, s2)\n        overlap_end = min(e1, e2)\n        \n        return max(0, overlap_end - overlap_start)\n\n    def analyze_case(promoters, h3k4me3_peaks, h3k27me3_peaks, t4, t27):\n        \"\"\"\n        Counts the number of bivalent promoters for a single test case.\n        \"\"\"\n        bivalent_promoter_count = 0\n\n        for p_interval in promoters:\n            # Check for H3K4me3 mark\n            has_h3k4me3_mark = False\n            if h3k4me3_peaks:\n                for k4_peak in h3k4me3_peaks:\n                    if calculate_overlap(p_interval, k4_peak) >= t4:\n                        has_h3k4me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n            \n            # If K4 condition fails, the promoter cannot be bivalent. Continue to next promoter.\n            if not has_h3k4me3_mark:\n                continue\n\n            # Check for H3K27me3 mark\n            has_h3k27me3_mark = False\n            if h3k27me3_peaks:\n                for k27_peak in h3k27me3_peaks:\n                    if calculate_overlap(p_interval, k27_peak) >= t27:\n                        has_h3k27me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n\n            # If both conditions are met, increment the counter\n            if has_h3k4me3_mark and has_h3k27me3_mark:\n                bivalent_promoter_count += 1\n                \n        return bivalent_promoter_count\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(\n            case[\"promoters\"],\n            case[\"h3k4me3_peaks\"],\n            case[\"h3k27me3_peaks\"],\n            case[\"t4\"],\n            case[\"t27\"]\n        )\n        results.append(result)\n\n    # Final output must be a single line in the specified format [a,b,c,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397930"}]}