{"hands_on_practices": [{"introduction": "Sequence composition, such as Guanine-Cytosine (GC) content or $k$-mer frequencies, provides a foundational signal for taxonomic binning, based on the principle that different species often have distinct molecular signatures. However, this assumption is not always valid, and its failure can lead to significant classification errors. This coding exercise challenges you to explore a critical limitation of composition-based methods by simulating a 'cryptic' organism whose GC-content mimics a mix of other species, making it difficult to distinguish [@problem_id:2433879]. By implementing the simulation and evaluating its performance, you will gain a tangible understanding of why robust binning strategies must look beyond simple sequence composition.", "problem": "You are given a simplified probabilistic model for taxonomic binning of metagenomic reads based solely on Guanine-Cytosine (GC) content. Consider a set of $n$ organisms indexed by $i \\in \\{1,\\dots,n\\}$, each with a GC probability $p_i \\in (0,1)$ and a strictly positive pre-normalization abundance weight $w_i \\in \\mathbb{R}_{0}$. Reads are independent and identically distributed of fixed length $L \\in \\mathbb{N}$. For a read from organism $i$, each base is drawn independently as either $G$ or $C$ with probability $p_i$ and as either $A$ or $T$ with probability $1 - p_i$, with within-pair choices being equiprobable.\n\nDefine the number of GC bases in a read of length $L$ by the random variable $K$, so that, under organism $i$, $K \\sim \\mathrm{Binomial}(L, p_i)$. The per-read GC fraction is $r = K / L$.\n\nIntroduce one additional organism, called the cryptic organism, with a pre-normalization abundance weight $w_c \\in \\mathbb{R}_{0}$ and a GC probability $p_c$ defined as the weighted average of the GC probabilities of the two most abundant original organisms. Let $a$ and $b$ be the indices of the two largest elements of $\\{w_1,\\dots,w_n\\}$, with ties broken in favor of the smaller index. Then\n$$\np_c \\;=\\; \\frac{w_a\\,p_a + w_b\\,p_b}{w_a + w_b}.\n$$\nAfter adding the cryptic organism, normalize all abundance weights (including $w_c$) by dividing by the total sum, so that the normalized weights sum to $1$.\n\nDefine a binning rule that assigns a read with GC fraction $r$ to the organism index\n$$\n\\hat{\\imath}(r) \\;=\\; \\arg\\min_{j \\in \\{1,\\dots,n,n+1\\}} \\big| r - p_j \\big|,\n$$\nwhere $j = n+1$ denotes the cryptic organism, and ties are broken by choosing the smallest index.\n\nLet the following quantities be defined:\n- The overall expected accuracy,\n$$\n\\mathrm{ACC} \\;=\\; \\sum_{i=1}^{n+1} \\tilde{w}_i \\cdot \\sum_{k=0}^{L} \\Pr(K=k \\mid i)\\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = i\\right),\n$$\nwhere $\\tilde{w}_i$ are the normalized weights and $\\Pr(K=k \\mid i) = \\binom{L}{k} p_i^{k} (1-p_i)^{L-k}$.\n- The positive predictive value (PPV) for the cryptic bin,\n$$\n\\mathrm{PPV}_c \\;=\\; \\begin{cases}\n\\displaystyle \\frac{\\tilde{w}_{c} \\cdot \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = c\\right)}{\\sum_{j=1}^{n+1} \\tilde{w}_{j} \\cdot \\sum_{k=0}^{L} \\Pr(K=k \\mid j) \\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = c\\right)}  \\text{if the denominator is nonzero}, \\\\[2ex]\n0  \\text{if the denominator is zero}.\n\\end{cases}\n$$\n- The misclassification probabilities of cryptic reads into each of the two most abundant original organisms $a$ and $b$,\n$$\nm_{c \\to a} \\;=\\; \\sum_{k=0}^{L} \\Pr(K=k \\mid c)\\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = a\\right), \\qquad\nm_{c \\to b} \\;=\\; \\sum_{k=0}^{L} \\Pr(K=k \\mid c)\\, \\mathbf{1}\\!\\left(\\hat{\\imath}\\!\\left(\\frac{k}{L}\\right) = b\\right).\n$$\n\nYour task is to write a complete program that, for each test case specified below, constructs the cryptic organism, normalizes the abundances, applies the binning rule using $r = k/L$ for all $k \\in \\{0,\\dots,L\\}$, and computes the four metrics $\\mathrm{ACC}$, $\\mathrm{PPV}_c$, $m_{c \\to a}$, and $m_{c \\to b}$. All floating-point results must be rounded to $6$ decimal places. There are no physical units in this problem.\n\nTest suite:\n- Test case $1$:\n  - Original GC probabilities: $[0.35,\\, 0.62,\\, 0.48]$.\n  - Original pre-normalization abundances: $[0.5,\\, 0.3,\\, 0.2]$.\n  - Cryptic pre-normalization abundance: $0.1$.\n  - Read length: $L = 100$.\n- Test case $2$:\n  - Original GC probabilities: $[0.49,\\, 0.5,\\, 0.61,\\, 0.39]$.\n  - Original pre-normalization abundances: $[0.4,\\, 0.35,\\, 0.15,\\, 0.10]$.\n  - Cryptic pre-normalization abundance: $0.2$.\n  - Read length: $L = 60$.\n- Test case $3$:\n  - Original GC probabilities: $[0.2,\\, 0.8]$.\n  - Original pre-normalization abundances: $[0.55,\\, 0.45]$.\n  - Cryptic pre-normalization abundance: $0.2$.\n  - Read length: $L = 30$.\n\nFinal output format:\n- Your program must produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of four floating-point numbers $[\\mathrm{ACC},\\, \\mathrm{PPV}_c,\\, m_{c \\to a},\\, m_{c \\to b}]$, each rounded to $6$ decimal places. For example: $[[x_{11},x_{12},x_{13},x_{14}],[x_{21},x_{22},x_{23},x_{24}],[x_{31},x_{32},x_{33},x_{34}]]$.", "solution": "The problem statement is valid. It is scientifically grounded within the domain of computational biology, mathematically well-posed, and objectively defined. All necessary data, formulae, and conditions for a unique solution are provided. The model, while simplified, is a coherent representation of a taxonomic binning problem based on GC-content, and the metrics requested are standard performance measures for classification tasks. The problem is free of contradictions, ambiguities, or pseudoscientific claims.\n\nWe will proceed with a systematic solution. The overall procedure involves three main stages for each test case: first, constructing the full set of organisms including the cryptic one; second, determining the binning rule based on GC-content; and third, calculating the specified performance metrics using this rule and the provided probabilistic model.\n\nLet us denote the set of original organisms by indices $j \\in \\{1, \\dots, n\\}$. The cryptic organism will be denoted by index $c = n+1$.\n\n**1. Construction of the Complete Organism Set**\n\nGiven is a set of $n$ original organisms with GC probabilities $\\{p_1, \\dots, p_n\\}$ and pre-normalization weights $\\{w_1, \\dots, w_n\\}$.\n\nFirst, we identify the indices $a, b \\in \\{1, \\dots, n\\}$ corresponding to the two largest weights in $\\{w_1, \\dots, w_n\\}$. As specified, ties are broken by selecting the smaller index.\n\nThe cryptic organism, indexed $c=n+1$, is introduced. Its pre-normalization abundance weight is given as $w_c = w_{n+1}$, and its GC probability $p_c = p_{n+1}$ is computed as the weighted average of the GC probabilities of the two most abundant original organisms:\n$$\np_c = \\frac{w_a p_a + w_b p_b}{w_a + w_b}\n$$\nThis results in a complete set of $n+1$ organisms. The full set of GC probabilities is $P = \\{p_1, \\dots, p_n, p_{n+1}\\}$ and the full set of pre-normalization abundance weights is $W = \\{w_1, \\dots, w_n, w_{n+1}\\}$.\n\nNext, all abundance weights are normalized to sum to $1$. The normalized abundance $\\tilde{w}_j$ for each organism $j \\in \\{1, \\dots, n+1\\}$ is:\n$$\n\\tilde{w}_j = \\frac{w_j}{\\sum_{i=1}^{n+1} w_i}\n$$\n\n**2. Probabilistic Model and Binning Rule**\n\nThe model states that for a read of length $L$ originating from organism $j$, the number of GC bases, $K$, is a random variable following a binomial distribution, $K \\sim \\mathrm{Binomial}(L, p_j)$. The probability mass function (PMF) for a specific GC count $k \\in \\{0, \\dots, L\\}$ is given by:\n$$\n\\Pr(K=k \\mid j) = \\binom{L}{k} p_j^k (1-p_j)^{L-k}\n$$\nWe will compute these probabilities for each organism $j \\in \\{1, \\dots, n+1\\}$ and for each possible GC count $k$.\n\nA read is assigned to a taxonomic bin based on its per-read GC fraction, $r = k/L$. The binning rule assigns the read to the organism whose characteristic GC probability is closest to the read's GC fraction. The assigned index, $\\hat{\\imath}(r)$, is determined by:\n$$\n\\hat{\\imath}(r) = \\arg\\min_{j \\in \\{1, \\dots, n+1\\}} |r - p_j|\n$$\nTies in this minimization are broken by choosing the smallest organism index $j$. We pre-compute this assignment, $\\hat{\\imath}(k/L)$, for all possible integer values of $k$ from $0$ to $L$.\n\n**3. Metric Computation**\n\nWith the normalized abundances $\\tilde{w}_j$, the binomial probabilities $\\Pr(K=k \\mid j)$, and the binning assignments $\\hat{\\imath}(k/L)$ established, we compute the four required metrics.\n\n**Overall Expected Accuracy (ACC):** This metric represents the probability that a randomly drawn read from the metagenome is correctly classified. It is calculated by summing the probabilities of correct classification for each organism, weighted by their normalized abundances.\n$$\n\\mathrm{ACC} = \\sum_{j=1}^{n+1} \\tilde{w}_j \\cdot P(\\text{correctly classified}|j) = \\sum_{j=1}^{n+1} \\tilde{w}_j \\left( \\sum_{k=0}^{L} \\Pr(K=k \\mid j) \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = j\\right] \\right)\n$$\nwhere $\\mathbf{1}[\\cdot]$ is the indicator function, which is $1$ if the condition is true and $0$ otherwise.\n\n**Positive Predictive Value for the Cryptic Bin (PPV$_c$):** The PPV for the cryptic bin (index $c$) is the probability that a read assigned to the cryptic bin truly originates from the cryptic organism. It is the ratio of true positives to total (true and false) positives for that bin.\n$$\n\\mathrm{PPV}_c = \\frac{\\text{Prob(is } c \\text{ AND binned as } c)}{\\text{Prob(binned as } c)} = \\frac{\\tilde{w}_{c} \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\, \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = c\\right]}{\\sum_{j=1}^{n+1} \\tilde{w}_{j} \\sum_{k=0}^{L} \\Pr(K=k \\mid j) \\, \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = c\\right]}\n$$\nIf the denominator is zero (i.e., no reads are ever binned as $c$), $\\mathrm{PPV}_c$ is defined as $0$.\n\n**Misclassification Probabilities ($m_{c \\to a}$ and $m_{c \\to b}$):** These are the total probabilities that a read originating from the cryptic organism $c$ is misclassified into the bin of organism $a$ or organism $b$, respectively (where $a$ and $b$ are the indices of the two most abundant original organisms).\n$$\nm_{c \\to a} = \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = a\\right]\n$$\n$$\nm_{c \\to b} = \\sum_{k=0}^{L} \\Pr(K=k \\mid c) \\mathbf{1}\\!\\left[\\hat{\\imath}(k/L) = b\\right]\n$$\n\nThe implementation will apply this complete procedure to each of the three test cases, with final numerical results rounded to $6$ decimal places as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import binom\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n\n    def calculate_metrics(p_orig, w_orig, w_c, L):\n        \"\"\"\n        Calculates the four specified metrics for a single test case.\n        \"\"\"\n        p_orig = np.array(p_orig)\n        w_orig = np.array(w_orig)\n        n = len(p_orig)\n\n        # 1. Identify the two most abundant original organisms\n        # Sort by weight (desc) and then index (asc) for tie-breaking\n        orig_indices = np.arange(n)\n        sorted_indices = sorted(orig_indices, key=lambda i: (-w_orig[i], i))\n        idx_a, idx_b = sorted_indices[0], sorted_indices[1]\n\n        # 2. Define the cryptic organism and the full set of organisms\n        p_a, p_b = p_orig[idx_a], p_orig[idx_b]\n        w_a, w_b = w_orig[idx_a], w_orig[idx_b]\n        p_c = (w_a * p_a + w_b * p_b) / (w_a + w_b)\n        idx_c = n\n\n        p_full = np.append(p_orig, p_c)\n        w_prenorm = np.append(w_orig, w_c)\n\n        # 3. Normalize abundance weights\n        w_norm = w_prenorm / np.sum(w_prenorm)\n        \n        # 4. Pre-compute binomial PMFs\n        # pmfs[j, k] = P(K=k | organism j)\n        k_values = np.arange(L + 1)\n        pmfs = np.zeros((n + 1, L + 1))\n        for j in range(n + 1):\n            pmfs[j, :] = binom.pmf(k_values, L, p_full[j])\n\n        # 5. Determine binning rule assignments for each possible GC count k\n        r_values = k_values / L\n        binned_to = np.zeros(L + 1, dtype=int)\n        for k_idx, r in enumerate(r_values):\n            dists = np.abs(r - p_full)\n            min_dist = np.min(dists)\n            # Use isclose for robust floating point comparison\n            tied_indices = np.where(np.isclose(dists, min_dist))[0]\n            binned_to[k_idx] = np.min(tied_indices)\n\n        # 6. Calculate the four metrics\n        \n        # ACC\n        acc = 0.0\n        # C[j] = P(correctly classified | organism j)\n        C = np.zeros(n + 1)\n        for j in range(n + 1):\n            correctly_binned_mask = (binned_to == j)\n            C[j] = np.sum(pmfs[j, correctly_binned_mask])\n            acc += w_norm[j] * C[j]\n\n        # PPV_c\n        # Numerator: Prob(is cryptic AND binned as cryptic)\n        num_ppv_c = w_norm[idx_c] * C[idx_c]\n        \n        # Denominator: Prob(binned as cryptic)\n        binned_to_c_mask = (binned_to == idx_c)\n        denom_ppv_c = 0.0\n        for j in range(n + 1):\n            denom_ppv_c += w_norm[j] * np.sum(pmfs[j, binned_to_c_mask])\n        \n        ppv_c = num_ppv_c / denom_ppv_c if denom_ppv_c  0 else 0.0\n\n        # m_c-a and m_c-b\n        binned_to_a_mask = (binned_to == idx_a)\n        m_c_to_a = np.sum(pmfs[idx_c, binned_to_a_mask])\n        \n        binned_to_b_mask = (binned_to == idx_b)\n        m_c_to_b = np.sum(pmfs[idx_c, binned_to_b_mask])\n\n        # Round all results to 6 decimal places\n        return [\n            round(acc, 6),\n            round(ppv_c, 6),\n            round(m_c_to_a, 6),\n            round(m_c_to_b, 6)\n        ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"p_orig\": [0.35, 0.62, 0.48],\n            \"w_orig\": [0.5, 0.3, 0.2],\n            \"w_c\": 0.1,\n            \"L\": 100\n        },\n        {\n            \"p_orig\": [0.49, 0.5, 0.61, 0.39],\n            \"w_orig\": [0.4, 0.35, 0.15, 0.10],\n            \"w_c\": 0.2,\n            \"L\": 60\n        },\n        {\n            \"p_orig\": [0.2, 0.8],\n            \"w_orig\": [0.55, 0.45],\n            \"w_c\": 0.2,\n            \"L\": 30\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        res = calculate_metrics(**case)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    formatted_case_results = []\n    for case_res in results:\n        res_str = f\"[{','.join(map(str, case_res))}]\"\n        formatted_case_results.append(res_str)\n    \n    final_output_str = f\"[{','.join(formatted_case_results)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2433879"}, {"introduction": "Having established the limitations of simple composition, we now turn to other powerful sources of evidence, such as the physical linkage of DNA fragments inferred from paired-end sequencing reads. This exercise introduces a quantitative approach to weigh such evidence using a probabilistic framework [@problem_id:2433913]. You will model the number of observed links between two contigs using a Poisson distribution and apply Bayesian inference to update the probability that they originate from the same genome. By calculating the change in Shannon entropy, you will directly measure the information gained from this linkage data, developing skills in applying information theory to practical bioinformatics problems.", "problem": "In taxonomic binning of metagenomic data, paired-end read information can support linking two contigs if mates from the same DNA fragment map uniquely, one to each contig, with proper orientation and insert size. Consider two contigs and the binary latent hypothesis $S$ (same taxon) versus $D$ (different taxa). Assume a prior probability $P(S) = 0.2$ and $P(D) = 1 - P(S)$. Let the number of properly mapped paired-end links $K$ observed between the two contigs be modeled as Poisson with mean $\\lambda_{S} = 8$ under $S$ and mean $\\lambda_{D} = 0.5$ under $D$. That is, for $k \\in \\{0,1,2,\\dots\\}$,\n$$\nP(K = k \\mid S) = \\exp(-\\lambda_{S}) \\frac{\\lambda_{S}^{k}}{k!}, \\quad P(K = k \\mid D) = \\exp(-\\lambda_{D}) \\frac{\\lambda_{D}^{k}}{k!}.\n$$\nYou observe $K = 5$. Define the information gain from using the paired-end data as the reduction in Shannon entropy (in bits) of the binary variable indicating whether the two contigs are from the same taxon, namely\n$$\n\\Delta I \\equiv H_{\\text{prior}} - H_{\\text{posterior}},\n$$\nwhere for a Bernoulli parameter $p \\in (0,1)$, $H(p) = -\\big[p \\log_{2}(p) + (1-p)\\log_{2}(1-p)\\big]$, $H_{\\text{prior}} = H\\big(P(S)\\big)$, and $H_{\\text{posterior}} = H\\big(P(S \\mid K=5)\\big)$. Compute $\\Delta I$ in bits. Round your answer to four significant figures. Express the final result in bits.", "solution": "The problem requires the computation of the information gain, $\\Delta I$, defined as the reduction in Shannon entropy of the state variable $S$ after observing the data $K=5$. The information gain is given by:\n$$\n\\Delta I = H_{\\text{prior}} - H_{\\text{posterior}}\n$$\nwhere $H_{\\text{prior}}$ is the entropy of the prior distribution of $S$, and $H_{\\text{posterior}}$ is the entropy of the posterior distribution of $S$ given the observation. The Shannon entropy for a Bernoulli variable with parameter $p$ is defined in bits as $H(p) = -\\left[p \\log_{2}(p) + (1-p)\\log_{2}(1-p)\\right]$.\n\nFirst, we calculate the prior entropy, $H_{\\text{prior}}$. The prior probability that the two contigs are from the same taxon is given as $P(S) = 0.2$.\nLet $p_{\\text{prior}} = P(S) = 0.2$. Then $1 - p_{\\text{prior}} = P(D) = 0.8$.\nThe prior entropy is:\n$$\nH_{\\text{prior}} = H(p_{\\text{prior}}) = H(0.2) = -\\left[0.2 \\log_{2}(0.2) + 0.8 \\log_{2}(0.8)\\right]\n$$\nUsing the change of base formula $\\log_{2}(x) = \\frac{\\ln(x)}{\\ln(2)}$, we have:\n$$\nH_{\\text{prior}} = -\\frac{1}{\\ln(2)} \\left[0.2 \\ln(0.2) + 0.8 \\ln(0.8)\\right]\n$$\nSubstituting the values $\\ln(0.2) \\approx -1.609438$ and $\\ln(0.8) \\approx -0.223144$, and $\\ln(2) \\approx 0.693147$:\n$$\nH_{\\text{prior}} \\approx -\\frac{1}{0.693147} \\left[0.2(-1.609438) + 0.8(-0.223144)\\right] \\approx -\\frac{-0.500403}{0.693147} \\approx 0.721928 \\text{ bits}\n$$\n\nNext, we must find the posterior probability $P(S \\mid K=5)$ to calculate the posterior entropy, $H_{\\text{posterior}}$. We use Bayes' theorem:\n$$\nP(S \\mid K=5) = \\frac{P(K=5 \\mid S) P(S)}{P(K=5)}\n$$\nThe marginal probability of observing $K=5$, $P(K=5)$, is given by the law of total probability:\n$$\nP(K=5) = P(K=5 \\mid S) P(S) + P(K=5 \\mid D) P(D)\n$$\nThe conditional probabilities, or likelihoods, are given by the Poisson probability mass function.\nFor hypothesis $S$, with $\\lambda_S = 8$:\n$$\nP(K=5 \\mid S) = \\frac{\\lambda_S^5 \\exp(-\\lambda_S)}{5!} = \\frac{8^5 \\exp(-8)}{120}\n$$\nFor hypothesis $D$, with $\\lambda_D = 0.5$:\n$$\nP(K=5 \\mid D) = \\frac{\\lambda_D^5 \\exp(-\\lambda_D)}{5!} = \\frac{(0.5)^5 \\exp(-0.5)}{120}\n$$\nThe posterior probability $p_{\\text{posterior}} = P(S \\mid K=5)$ is therefore:\n$$\np_{\\text{posterior}} = \\frac{P(K=5 \\mid S) P(S)}{P(K=5 \\mid S) P(S) + P(K=5 \\mid D) P(D)}\n$$\nSubstituting the expressions for the likelihoods and the prior probabilities $P(S)=0.2$ and $P(D)=0.8$:\n$$\np_{\\text{posterior}} = \\frac{\\frac{8^5 \\exp(-8)}{120} \\times 0.2}{\\frac{8^5 \\exp(-8)}{120} \\times 0.2 + \\frac{(0.5)^5 \\exp(-0.5)}{120} \\times 0.8}\n$$\nThe term $1/120$ cancels from the numerator and denominator:\n$$\np_{\\text{posterior}} = \\frac{8^5 \\exp(-8) \\times 0.2}{8^5 \\exp(-8) \\times 0.2 + (0.5)^5 \\exp(-0.5) \\times 0.8}\n$$\nLet us compute the terms:\n$8^5 \\exp(-8) = 32768 \\times \\exp(-8) \\approx 32768 \\times 0.00033546 = 10.9936$\n$(0.5)^5 \\exp(-0.5) = 0.03125 \\times \\exp(-0.5) \\approx 0.03125 \\times 0.60653 = 0.018954$\n$$\np_{\\text{posterior}} \\approx \\frac{10.9936 \\times 0.2}{10.9936 \\times 0.2 + 0.018954 \\times 0.8} = \\frac{2.19872}{2.19872 + 0.015163} = \\frac{2.19872}{2.213883} \\approx 0.9931499\n$$\nThis gives the posterior probability of the contigs being from the same taxon. Now we can compute the posterior entropy, $H_{\\text{posterior}}$:\n$$\nH_{\\text{posterior}} = H(p_{\\text{posterior}}) \\approx H(0.99315) = -\\left[0.99315 \\log_{2}(0.99315) + (1-0.99315)\\log_{2}(1-0.99315)\\right]\n$$\nLet $p_{\\text{post}} \\approx 0.99315$ and $1-p_{\\text{post}} \\approx 0.00685$.\n$$\nH_{\\text{posterior}} \\approx -\\frac{1}{\\ln(2)} \\left[0.99315 \\ln(0.99315) + 0.00685 \\ln(0.00685)\\right]\n$$\n$$\nH_{\\text{posterior}} \\approx -\\frac{1}{0.693147} \\left[0.99315(-0.00687) + 0.00685(-4.9836)\\right] \\approx -\\frac{-0.00682 - 0.03414}{0.693147} \\approx \\frac{0.04096}{0.693147} \\approx 0.059101 \\text{ bits}\n$$\nFinally, the information gain $\\Delta I$ is the difference between the prior and posterior entropies:\n$$\n\\Delta I = H_{\\text{prior}} - H_{\\text{posterior}} \\approx 0.721928 - 0.059101 = 0.662827\n$$\nRounding the result to four significant figures gives $0.6628$.", "answer": "$$\n\\boxed{0.6628}\n$$", "id": "2433913"}, {"introduction": "Real-world binning pipelines must be not only accurate but also computationally feasible for massive metagenomic datasets, creating a classic trade-off between speed and precision. A powerful strategy to resolve this is a hybrid, multi-stage approach that combines a fast, broad-stroke filter with a slow, specific validator. This hands-on coding problem guides you through implementing such a two-stage binner, mirroring a professional design pattern [@problem_id:2433908]. You will first use rapid $k$-mer based Jaccard similarity to generate candidate assignments, then apply the highly specific Smith-Waterman algorithm on protein domains to make a final, validated assignment. This practice provides direct experience in engineering a solution that navigates the fundamental trade-off between computational speed and diagnostic accuracy.", "problem": "You are given a finite set of taxa, each defined by a deoxyribonucleic acid (DNA) reference sequence and a protein domain signature sequence. You must implement a two-stage decision function that maps each input DNA read to a single taxon index or to an unassigned value. All steps are to be implemented exactly as defined below, using only the provided parameters and definitions. The alphabet for DNA is $\\{A,C,G,T\\}$, and the protein alphabet is the $20$ standard amino acids with the stop symbol $*$.\n\nStage 1 (fast set-similarity preselection): For a DNA string $s$ and a positive integer $k$, define the $k$-mer set $K(s,k)$ as the set of all length-$k$ substrings of $s$ (overlapping substrings included). For a read $r$ and a reference genome $g_i$, define the Jaccard similarity\n$$\nJ_k(r,g_i) \\coloneqq \\frac{\\lvert K(r,k)\\cap K(g_i,k)\\rvert}{\\lvert K(r,k)\\cup K(g_i,k)\\rvert}.\n$$\nGiven a threshold $\\tau_k$ and a maximum candidate count $m$, define the candidate set $C(r)$ for read $r$ as follows:\n- Compute $J_k(r,g_i)$ for every taxon index $i$.\n- Let $S_{\\ge}(r) \\coloneqq \\{ i : J_k(r,g_i) \\ge \\tau_k \\}$. If $\\lvert S_{\\ge}(r)\\rvert = 0$, then set $C(r)$ to be the set of the $m$ indices with the largest $J_k(r,g_i)$ values, breaking ties by choosing the smaller index first. Otherwise, set $C(r)$ to be the subset of $S_{\\ge}(r)$ containing up to $m$ indices with the largest $J_k(r,g_i)$ values, breaking ties by choosing the smaller index first. If $\\lvert S_{\\ge}(r)\\rvert  m$, then $\\lvert C(r)\\rvert = \\lvert S_{\\ge}(r)\\rvert$.\n\nStage 2 (slow domain-level validation by local alignment): Define the translation $\\mathcal{T}(r)$ of a DNA read $r$ as the amino acid sequence obtained by translating $r$ from its first nucleotide in the forward direction using the standard genetic code with the three-nucleotide codon length, ignoring any partial trailing codon (if the length of $r$ is not divisible by $3$). The stop codons translate to $*$, and $*$ is treated as a literal character. Let $d_i$ be the protein domain signature for taxon $i$.\n\nFor two protein strings $x$ and $y$, define the Smith–Waterman local alignment score $SW(x,y)$ with the following linear scoring:\n- Match score $s_{\\mathrm{match}} = +2$,\n- Mismatch score $s_{\\mathrm{mismatch}} = -1$,\n- Gap penalty $s_{\\mathrm{gap}} = -2$ per gap symbol,\nand the dynamic programming recurrence\n$$\nH_{a,b} \\coloneqq \\max\\Big(0,\\ H_{a-1,b-1} + \\sigma(x_a,y_b),\\ H_{a-1,b} + s_{\\mathrm{gap}},\\ H_{a,b-1} + s_{\\mathrm{gap}}\\Big),\n$$\nwith $H_{0,b} = 0$ and $H_{a,0} = 0$ for all $a,b$, where\n$$\n\\sigma(u,v) \\coloneqq\n\\begin{cases}\ns_{\\mathrm{match}}  \\text{if } u=v,\\\\\ns_{\\mathrm{mismatch}}  \\text{if } u\\ne v.\n\\end{cases}\n$$\nThe local alignment score is $\\max_{a,b} H_{a,b}$.\n\nAssignment rule: For a read $r$, compute $x=\\mathcal{T}(r)$ and for each $i\\in C(r)$ compute $SW(x,d_i)$. Let $i^\\star$ be the index in $C(r)$ with the largest $SW(x,d_i)$; break ties by choosing the smaller index. Given a domain-score threshold $\\tau_d$, if $SW(x,d_{i^\\star}) \\ge \\tau_d$, output $i^\\star$; otherwise output $-1$.\n\nAll indices are zero-based integers. The unassigned value is the integer $-1$.\n\nParameters to use for all computations:\n- $k = 3$,\n- $\\tau_k = 0.2$,\n- $m = 2$,\n- $s_{\\mathrm{match}} = +2$,\n- $s_{\\mathrm{mismatch}} = -1$,\n- $s_{\\mathrm{gap}} = -2$,\n- $\\tau_d = 4$.\n\nTaxa and sequences:\n- Taxon $0$: reference genome $g_0 = \\texttt{ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG}$, protein domain $d_0 = \\texttt{MAIVMGRKG}$.\n- Taxon $1$: reference genome $g_1 = \\texttt{ATGGCGGCTGCTGCTGAAAACCCGTTGAATGCCGCCGAA}$, protein domain $d_1 = \\texttt{MAAAAAK}$.\n- Taxon $2$: reference genome $g_2 = \\texttt{TTGAAACCCGGGTTTAAACCCGGGTTTAAAGGGCCCAA}$, protein domain $d_2 = \\texttt{MKTLLILAL}$.\n\nGenetic code: Use the standard genetic code for translation in the forward frame starting at nucleotide position $1$; ignore any trailing $1$ or $2$ nucleotides that do not form a complete codon.\n\nTest suite (reads):\n- Read $r_1 = \\texttt{ATGGCCATTGTAATGGGCCGCTG}$,\n- Read $r_2 = \\texttt{ATGGCGGCTGCTGCT}$,\n- Read $r_3 = \\texttt{TTTTTTTTTTTTTTT}$,\n- Read $r_4 = \\texttt{ATGGCC}$.\n\nYour program must process the reads in the order $(r_1,r_2,r_3,r_4)$ and produce a single line of output containing the integer assignments as a comma-separated list enclosed in square brackets (for example, $\\texttt{[0,1,-1,0]}$). The only permitted outputs for each read are $-1$, $0$, $1$, or $2$.", "solution": "The task specifies a two-stage mapping from each DNA read to either a taxon index or the unassigned value. The solution proceeds by formalizing each stage and applying it deterministically to the provided inputs.\n\nStage 1 formalization: For a fixed $k=3$, the $k$-mer set $K(s,3)$ contains all contiguous substrings of length $3$ from $s$. The Jaccard similarity is $J_3(r,g_i) = \\lvert K(r,3)\\cap K(g_i,3)\\rvert / \\lvert K(r,3)\\cup K(g_i,3)\\rvert$. For each read $r$, we compute $J_3(r,g_i)$ for $i\\in\\{0,1,2\\}$. We define the set $S_{\\ge}(r)=\\{i: J_3(r,g_i)\\ge \\tau_k\\}$ with $\\tau_k = 0.2$. If $\\lvert S_{\\ge}(r)\\rvert = 0$, then $C(r)$ contains the $m=2$ indices with largest $J_3(r,g_i)$, with ties broken by smaller index. Otherwise $C(r)$ contains up to $m$ indices from $S_{\\ge}(r)$ with the largest $J_3(r,g_i)$ values, ties broken by smaller index; if there are fewer than $m$ indices in $S_{\\ge}(r)$, all of them are included.\n\nStage 2 formalization: We translate each DNA read in the forward frame starting at the first nucleotide using the standard genetic code and ignoring any trailing incomplete codon. This yields $x=\\mathcal{T}(r)$. For each candidate $i\\in C(r)$, we compute the Smith–Waterman local alignment score $SW(x,d_i)$ using the recurrence\n$$\nH_{a,b} = \\max\\left(0,\\,H_{a-1,b-1} + \\sigma(x_a,y_b),\\,H_{a-1,b} + s_{\\mathrm{gap}},\\,H_{a,b-1} + s_{\\mathrm{gap}}\\right),\n$$\nwhere $y=d_i$, $s_{\\mathrm{match}}=+2$, $s_{\\mathrm{mismatch}}=-1$, and $s_{\\mathrm{gap}}=-2$. The scoring function $\\sigma(u,v)$ is $+2$ if $u=v$ and $-1$ otherwise. The local score is $\\max_{a,b} H_{a,b}$. We identify $i^\\star\\in C(r)$ that maximizes $SW(x,d_i)$, with ties resolved by selecting the smaller index. With $\\tau_d=4$, if $SW(x,d_{i^\\star})\\ge 4$, we assign $i^\\star$; otherwise we output $-1$.\n\nApplication to the given test suite:\n\n- Read $r_1 = \\texttt{ATGGCCATTGTAATGGGCCGCTG}$. Translation in the forward frame gives $\\mathcal{T}(r_1) = \\texttt{MAIVMGR}$ because the codons are $\\texttt{ATG}\\to \\texttt{M}$, $\\texttt{GCC}\\to \\texttt{A}$, $\\texttt{ATT}\\to \\texttt{I}$, $\\texttt{GTA}\\to \\texttt{V}$, $\\texttt{ATG}\\to \\texttt{M}$, $\\texttt{GGC}\\to \\texttt{G}$, $\\texttt{CGC}\\to \\texttt{R}$, with the trailing $\\texttt{TG}$ ignored. The $3$-mer set of $r_1$ has substantial overlap with $K(g_0,3)$ due to $r_1$ being a substring of $g_0$, so $J_3(r_1,g_0)$ is large relative to $J_3(r_1,g_1)$ and $J_3(r_1,g_2)$. Thus $0\\in C(r_1)$, and $C(r_1)$ will include at most one other index. The local alignment $SW(\\texttt{MAIVMGR}, \\texttt{MAIVMGRKG})$ yields a perfect contiguous match of length $7$, score $7\\times 2=14$. Any alignment against $d_1=\\texttt{MAAAAAK}$ or $d_2=\\texttt{MKTLLILAL}$ is at most a short prefix match; for $d_1$ the best contiguous match is $\\texttt{MA}$ with score $2\\times 2=4$, and for $d_2$ it is at most $\\texttt{M}$ with score $2$. Therefore $i^\\star=0$ and $SW\\ge 4$, so the assignment is $0$.\n\n- Read $r_2 = \\texttt{ATGGCGGCTGCTGCT}$. Translation yields $\\mathcal{T}(r_2)=\\texttt{MAAAA}$ from $\\texttt{ATG}\\to \\texttt{M}$, $\\texttt{GCG}\\to \\texttt{A}$, $\\texttt{GCT}\\to \\texttt{A}$, $\\texttt{GCT}\\to \\texttt{A}$, $\\texttt{GCT}\\to \\texttt{A}$. The $3$-mer content overlaps more strongly with $K(g_1,3)$ than with $K(g_0,3)$ or $K(g_2,3)$, so $1\\in C(r_2)$ (with possibly another index due to $m=2$). The alignment $SW(\\texttt{MAAAA}, \\texttt{MAAAAAK})$ yields a contiguous match of length $5$, score $10$. Alignments to $d_0$ or $d_2$ score at most $4$ or less due to shorter shared prefixes. Therefore $i^\\star=1$ with score $10 \\ge 4$, so the assignment is $1$.\n\n- Read $r_3 = \\texttt{TTTTTTTTTTTTTTT}$. Translation produces $\\mathcal{T}(r_3)=\\texttt{FFFFF}$ because $\\texttt{TTT}\\to \\texttt{F}$ repeatedly. The $3$-mer set $K(r_3,3)=\\{\\texttt{TTT}\\}$ has minimal overlap with $K(g_0,3)$ and $K(g_1,3)$ and some overlap with $K(g_2,3)$ if $\\texttt{TTT}$ appears, but regardless of $C(r_3)$ composition (bounded by $m=2$), the local alignment scores $SW(\\texttt{FFFFF}, d_i)$ for $i\\in C(r_3)$ are $0$ because none of $d_0=\\texttt{MAIVMGRKG}$, $d_1=\\texttt{MAAAAAK}$, or $d_2=\\texttt{MKTLLILAL}$ contains $\\texttt{F}$, and any alignment accrues mismatches and gaps that are not beneficial under the local alignment recurrence that floors at $0$. Thus the best score is $0  \\tau_d$, and the assignment is $-1$.\n\n- Read $r_4 = \\texttt{ATGGCC}$. Translation yields $\\mathcal{T}(r_4)=\\texttt{MA}$. The $3$-mers of $r_4$ are $\\{\\texttt{ATG},\\texttt{TGG},\\texttt{GGC},\\texttt{GCC}\\}$, which overlap with both $K(g_0,3)$ and $K(g_1,3)$, so $C(r_4)$ will contain indices $\\{0,1\\}$ after applying the $m=2$ cap and the $\\tau_k$ threshold. The local alignment scores $SW(\\texttt{MA}, \\texttt{MAIVMGRKG})$ and $SW(\\texttt{MA}, \\texttt{MAAAAAK})$ both attain the value $4$ via matching the prefix $\\texttt{MA}$, while $SW(\\texttt{MA}, \\texttt{MKTLLILAL})$ is smaller. Hence there is a tie at the maximum score between indices $0$ and $1$, and the tie-break rule selects the smaller index $0$. Since $4 \\ge \\tau_d$, the assignment is $0$.\n\nCollecting these results in order $(r_1,r_2,r_3,r_4)$ yields the final list $[0,1,-1,0]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Standard genetic code mapping (forward strand, frame starting at position 0)\nGENETIC_CODE = {\n    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n    'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n    'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n}\n\ndef kmer_set(seq: str, k: int):\n    return {seq[i:i+k] for i in range(len(seq) - k + 1)} if len(seq) = k else set()\n\ndef jaccard_kmer(a: str, b: str, k: int) - float:\n    ka = kmer_set(a, k)\n    kb = kmer_set(b, k)\n    if not ka and not kb:\n        return 0.0\n    inter = ka  kb\n    union = ka | kb\n    return len(inter) / len(union) if union else 0.0\n\ndef translate_frame1(dna: str) - str:\n    aa = []\n    n = len(dna) // 3\n    for i in range(n):\n        codon = dna[3*i:3*i+3]\n        aa.append(GENETIC_CODE.get(codon, 'X'))  # 'X' for any unexpected codon (should not happen)\n    return ''.join(aa)\n\ndef smith_waterman(x: str, y: str, match: int = 2, mismatch: int = -1, gap: int = -2) - int:\n    # Local alignment with linear gap penalty\n    n, m = len(x), len(y)\n    # Use a 1D rolling DP to save memory; track max\n    H = [0] * (m + 1)\n    max_score = 0\n    for i in range(1, n + 1):\n        prev_diag = 0\n        for j in range(1, m + 1):\n            temp = H[j]\n            score_sub = match if x[i-1] == y[j-1] else mismatch\n            h_diag = prev_diag + score_sub\n            h_up = H[j] + gap\n            h_left = H[j-1] + gap\n            h_ij = max(0, h_diag, h_up, h_left)\n            H[j] = h_ij\n            prev_diag = temp\n            if h_ij  max_score:\n                max_score = h_ij\n        # reset H[0] to 0 each row (already 0)\n    return max_score\n\ndef select_candidates_by_kmer(read: str, refs: list[str], k: int, tau_k: float, m: int):\n    sims = []\n    for idx, g in enumerate(refs):\n        sims.append((idx, jaccard_kmer(read, g, k)))\n    # Sort by similarity desc, then index asc\n    sims_sorted = sorted(sims, key=lambda t: (-t[1], t[0]))\n    above = [idx for idx, s in sims_sorted if s = tau_k]\n    if len(above) == 0:\n        return [idx for idx, _ in sims_sorted[:m]]\n    else:\n        return above[:m]\n\ndef assign_read(read: str, refs: list[str], domains: list[str],\n                k: int, tau_k: float, m: int, tau_d: int,\n                match: int = 2, mismatch: int = -1, gap: int = -2) - int:\n    candidates = select_candidates_by_kmer(read, refs, k, tau_k, m)\n    aa = translate_frame1(read)\n    best_idx = -1\n    best_score = -1_000_000\n    for idx in candidates:\n        score = smith_waterman(aa, domains[idx], match, mismatch, gap)\n        if score  best_score or (score == best_score and idx  best_idx):\n            best_score = score\n            best_idx = idx\n    if best_idx == -1:\n        return -1\n    return best_idx if best_score = tau_d else -1\n\ndef solve():\n    # Parameters\n    k = 3\n    tau_k = 0.2\n    m = 2\n    match, mismatch, gap = 2, -1, -2\n    tau_d = 4\n\n    # References and domains\n    refs = [\n        \"ATGGCCATTGTAATGGGCCGCTGAAAGGGTGCCCGATAG\",  # g0\n        \"ATGGCGGCTGCTGCTGAAAACCCGTTGAATGCCGCCGAA\",  # g1\n        \"TTGAAACCCGGGTTTAAACCCGGGTTTAAAGGGCCCAA\",   # g2\n    ]\n    domains = [\n        \"MAIVMGRKG\",  # d0\n        \"MAAAAAK\",    # d1\n        \"MKTLLILAL\",  # d2\n    ]\n\n    # Test cases (reads)\n    test_reads = [\n        \"ATGGCCATTGTAATGGGCCGCTG\",   # r1\n        \"ATGGCGGCTGCTGCT\",           # r2\n        \"TTTTTTTTTTTTTTT\",           # r3\n        \"ATGGCC\",                    # r4\n    ]\n\n    results = []\n    for read in test_reads:\n        assign_idx = assign_read(\n            read, refs, domains, k, tau_k, m, tau_d, match, mismatch, gap\n        )\n        results.append(assign_idx)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2433908"}]}