{"hands_on_practices": [{"introduction": "One of the most fundamental operations on a pangenome graph is to \"flatten\" it into a single linear sequence, for instance, to create a personalized reference. This task can be modeled as a search for an optimal path through the graph, guided by a support score assigned to each sequence segment. This exercise [@problem_id:2412184] challenges you to implement a dynamic programming solution to find the maximum-support path in a directed acyclic graph, a cornerstone algorithm for analyzing variation graphs.", "problem": "You are given a finite directed acyclic graph (DAG) that represents a genomic variation region. Each vertex (node) corresponds to a DNA segment labeled by a string over the alphabet $\\{A,C,G,T\\}$, and each vertex $i$ carries a non-negative real-valued support weight $w_i \\in \\mathbb{R}_{\\ge 0}$. A directed edge $(u,v)$ indicates that the DNA segment at vertex $v$ may immediately follow the DNA segment at vertex $u$ in a valid traversal. A valid path is any directed path from a designated start vertex $s$ to a designated end vertex $t$. The flattened linear reference for the region is defined as the concatenation of the DNA strings along a single $s \\to t$ path that maximizes the total support score $S$, where\n$$\nS = \\sum_{i \\in P} w_i,\n$$\nand $P$ is the set of vertices along the chosen path in order. If multiple $s \\to t$ paths attain the same maximal $S$, break ties by choosing the path whose concatenated DNA string is lexicographically smallest under the order $A \\prec C \\prec G \\prec T$. If there is still a tie, choose the path whose sequence of vertex indices is lexicographically smallest under the natural order on integers.\n\nYour task is to implement a program that, for each of the following test cases, computes the maximum-support flattened path from $s$ to $t$ according to the rule above and returns two items: the maximal total support score $S$ and the flattened DNA string encoded as integers via the mapping $A \\mapsto 0$, $C \\mapsto 1$, $G \\mapsto 2$, $T \\mapsto 3$.\n\nAll graphs are guaranteed to be directed acyclic graphs. All DNA labels consist only of characters from $\\{A,C,G,T\\}$. All weights are real numbers in $\\mathbb{R}_{\\ge 0}$. In every test case, there exists at least one valid $s \\to t$ path. There are no physical units involved in this problem.\n\nFor each test case, your program must output a single list where the first element is the maximal support score $S$ rounded to exactly three decimal places, followed by the integer-encoded flattened DNA string as specified above.\n\nYour program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets. Each test case contributes one bracketed list as described above. For example, the final format is\n$[ [S_1,\\ell_{1,1},\\ell_{1,2},\\dots], [S_2,\\ell_{2,1},\\dots], \\dots ]$,\nwith each $S_k$ rounded to exactly three decimal places and each $\\ell_{k,j} \\in \\{0,1,2,3\\}$.\n\nTest Suite:\n- Test Case $1$ (general branching case):\n  - Vertices with DNA labels and weights:\n    - $1$: label $A$, $w_1 = 1.0$\n    - $2$: label $G$, $w_2 = 2.0$\n    - $3$: label $C$, $w_3 = 1.5$\n    - $4$: label $T$, $w_4 = 3.0$\n    - $5$: label $G$, $w_5 = 2.5$\n    - $6$: label $A$, $w_6 = 0.5$\n  - Directed edges: $(1,2)$, $(1,3)$, $(2,4)$, $(3,4)$, $(4,6)$, $(2,5)$, $(5,6)$\n  - Start $s = 1$, End $t = 6$\n- Test Case $2$ (tie broken by lexicographic order of DNA string):\n  - Vertices with DNA labels and weights:\n    - $1$: label $A$, $w_1 = 1.0$\n    - $2$: label $C$, $w_2 = 2.0$\n    - $3$: label $G$, $w_3 = 2.0$\n    - $4$: label $A$, $w_4 = 0.3$\n  - Directed edges: $(1,2)$, $(2,4)$, $(1,3)$, $(3,4)$\n  - Start $s = 1$, End $t = 4$\n- Test Case $3$ (tie persists after DNA string, broken by vertex-index sequence):\n  - Vertices with DNA labels and weights:\n    - $1$: label $A$, $w_1 = 1.0$\n    - $2$: label $G$, $w_2 = 1.0$\n    - $3$: label $G$, $w_3 = 1.0$\n    - $4$: label $A$, $w_4 = 1.0$\n  - Directed edges: $(1,2)$, $(2,4)$, $(1,3)$, $(3,4)$\n  - Start $s = 1$, End $t = 4$\n- Test Case $4$ (boundary case with $s = t$):\n  - Vertices with DNA labels and weights:\n    - $1$: label $T$, $w_1 = 2.2$\n  - Directed edges: none\n  - Start $s = 1$, End $t = 1$\n\nFinal Output Format:\n- Produce exactly one line:\n  - The line must be a single bracketed list aggregating all test-case results.\n  - Each test-case result is a bracketed list whose first element is the maximal support score $S$ rounded to exactly three decimal places, followed by the integer-encoded flattened DNA string using $A \\mapsto 0$, $C \\mapsto 1$, $G \\mapsto 2$, $T \\mapsto 3$.\n  - There must be no spaces in the output.\n  - Example shape (not actual answers): $[[3.125,0,1,2],[2.000,3]]$.", "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to derive a unique solution. The problem is a variant of the longest path problem on a directed acyclic graph (DAG), with a multi-tiered objective function for tie-breaking. Such problems are fundamental in computational biology for analyzing sequence variations in pangenomes.\n\nThe problem is tractable because the graph is a DAG. The absence of cycles permits the use of dynamic programming over a topological ordering of the vertices. The principle of optimality applies: an optimal path to a vertex $v$ must be formed by extending an optimal path to one of its predecessors.\n\nThe algorithm proceeds as follows. First, we must establish a topological sort of the graph's vertices. This provides a linear ordering of vertices such that for every directed edge $(u,v)$, vertex $u$ comes before vertex $v$ in the ordering. This ordering ensures that when we compute the optimal path to a vertex $v$, the optimal paths to all its predecessors have already been computed.\n\nWe define a dynamic programming state for each vertex $v$ in the graph. This state must encapsulate all information required by the hierarchical optimization criteria. Let $dp[v]$ be a tuple $(S_v, D_v, P_v)$ representing the optimal path from the start vertex $s$ to $v$, where:\n- $S_v$ is the maximum total support score of the path.\n- $D_v$ is the concatenated DNA sequence of the path, which must be lexicographically minimal among all paths with score $S_v$.\n- $P_v$ is the sequence of vertex indices of the path, which must be lexicographically minimal among all paths with score $S_v$ and sequence $D_v$.\n\nThe algorithm is initialized by setting the state for the start vertex $s$. The path to $s$ from $s$ consists only of the vertex $s$ itself. Thus, $dp[s]$ is set to $(w_s, L_s, [s])$, where $w_s$ is the weight of vertex $s$, $L_s$ is its DNA label (encoded as a sequence of integers), and $[s]$ is the trivial vertex path. For all other vertices $v \\neq s$, the state is initialized to a value indicating unreachability, for instance, a score of $-\\infty$. Since all weights $w_i$ are non-negative, any negative score serves this purpose.\n\nThe core of the algorithm is the iterative update of the $dp$ states. We process each vertex $u$ in the pre-computed topological order. For each outgoing edge $(u,v)$, we construct a candidate path to $v$ by extending the optimal path to $u$. This candidate path has the following properties:\n- Score: $S_{u \\to v} = S_u + w_v$\n- DNA sequence: $D_{u \\to v} = D_u \\cdot L_v$ (concatenation)\n- Vertex path: $P_{u \\to v} = P_u \\cdot [v]$ (concatenation)\n\nThis candidate path tuple $(S_{u \\to v}, D_{u \\to v}, P_{u \\to v})$ is then compared against the current optimal path stored in $dp[v]$. A new path is considered superior if it has a higher score, or if the scores are equal and its DNA sequence is lexicographically smaller, or if both scores and DNA sequences are equal and its vertex path is lexicographically smaller.\n\nTo implement this comparison efficiently, we can compare tuples of the form $(-S, D, P)$. Standard lexicographical comparison of such tuples will correctly identify the optimal path, as minimizing $-S$ is equivalent to maximizing $S$, and the subsequent elements $D$ and $P$ are compared for minimization as required.\n\nAfter iterating through all vertices in topological order, the state $dp[t]$ for the designated end vertex $t$ will contain the tuple corresponding to the globally optimal $s \\to t$ path. The final result is then extracted from this tuple, with the score $S_t$ rounded to three decimal places and the DNA sequence $D_t$ presented in its integer-encoded form.\nThe entire procedure is as follows:\n1.  Parse the graph structure, vertex labels, and weights.\n2.  Perform a topological sort of the vertices. Kahn's algorithm is a standard choice.\n3.  Initialize a $dp$ table, setting the entry for the start vertex $s$ and marking all others as unvisited.\n4.  Iterate through the vertices in topological order. For each vertex $u$, iterate through its neighbors $v$ and update $dp[v]$ if a better path via $u$ is found.\n5.  After the iteration completes, the entry $dp[t]$ contains the solution. Format and return it as specified.\nThis rigorous, step-by-step process guarantees the correct, unique solution according to the problem's criteria.", "answer": "```python\nimport numpy as np\nimport scipy\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the pangenome graph pathfinding problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": {\n                1: {\"label\": \"A\", \"weight\": 1.0}, 2: {\"label\": \"G\", \"weight\": 2.0},\n                3: {\"label\": \"C\", \"weight\": 1.5}, 4: {\"label\": \"T\", \"weight\": 3.0},\n                5: {\"label\": \"G\", \"weight\": 2.5}, 6: {\"label\": \"A\", \"weight\": 0.5},\n            },\n            \"edges\": [(1, 2), (1, 3), (2, 4), (3, 4), (4, 6), (2, 5), (5, 6)],\n            \"s\": 1, \"t\": 6,\n        },\n        {\n            \"nodes\": {\n                1: {\"label\": \"A\", \"weight\": 1.0}, 2: {\"label\": \"C\", \"weight\": 2.0},\n                3: {\"label\": \"G\", \"weight\": 2.0}, 4: {\"label\": \"A\", \"weight\": 0.3},\n            },\n            \"edges\": [(1, 2), (2, 4), (1, 3), (3, 4)],\n            \"s\": 1, \"t\": 4,\n        },\n        {\n            \"nodes\": {\n                1: {\"label\": \"A\", \"weight\": 1.0}, 2: {\"label\": \"G\", \"weight\": 1.0},\n                3: {\"label\": \"G\", \"weight\": 1.0}, 4: {\"label\": \"A\", \"weight\": 1.0},\n            },\n            \"edges\": [(1, 2), (2, 4), (1, 3), (3, 4)],\n            \"s\": 1, \"t\": 4,\n        },\n        {\n            \"nodes\": {\n                1: {\"label\": \"T\", \"weight\": 2.2},\n            },\n            \"edges\": [],\n            \"s\": 1, \"t\": 1,\n        },\n    ]\n\n    dna_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    \n    final_results = []\n    \n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        edges = case[\"edges\"]\n        start_node = case[\"s\"]\n        end_node = case[\"t\"]\n        \n        adj = collections.defaultdict(list)\n        in_degree = collections.defaultdict(int)\n        \n        for u, v in edges:\n            adj[u].append(v)\n            in_degree[v] += 1\n            if u not in in_degree:\n                in_degree[u] = 0\n\n        # Topological sort (Kahn's algorithm)\n        queue = collections.deque([node for node in nodes if in_degree[node] == 0])\n        topo_order = []\n        while queue:\n            u = queue.popleft()\n            topo_order.append(u)\n            for v in adj[u]:\n                in_degree[v] -= 1\n                if in_degree[v] == 0:\n                    queue.append(v)\n\n        # Dynamic programming\n        # dp[node] = (score, dna_sequence_list, vertex_path_list)\n        dp = {node: (-1.0, [], []) for node in nodes}\n\n        # Initialization for the start node\n        start_label = nodes[start_node][\"label\"]\n        start_dna_list = [dna_map[c] for c in start_label]\n        dp[start_node] = (nodes[start_node][\"weight\"], start_dna_list, [start_node])\n        \n        for u in topo_order:\n            if dp[u][0] < 0.0:  # Node u is not reachable from start_node\n                continue\n            \n            score_u, dna_u, path_u = dp[u]\n            \n            for v in adj[u]:\n                weight_v = nodes[v][\"weight\"]\n                label_v = nodes[v][\"label\"]\n                dna_v_list = [dna_map[c] for c in label_v]\n                \n                new_score = score_u + weight_v\n                new_dna = dna_u + dna_v_list\n                new_path = path_u + [v]\n\n                # Get current best for v\n                best_score_v, best_dna_v, best_path_v = dp[v]\n\n                # We maximize score, but minimize DNA and path for ties.\n                # This is equivalent to lexicographically minimizing (-score, dna, path).\n                if best_score_v < 0.0 or \\\n                   (-new_score, new_dna, new_path) < (-best_score_v, best_dna_v, best_path_v):\n                    dp[v] = (new_score, new_dna, new_path)\n    \n        final_score, final_dna, _ = dp[end_node]\n        \n        # Format result string manually to avoid spaces\n        result_str_list = [f\"{final_score:.3f}\"] + [str(d) for d in final_dna]\n        result_str = f\"[{','.join(result_str_list)}]\"\n        final_results.append(result_str)\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "2412184"}, {"introduction": "A key application of pangenome graphs is to interpret an individual's genetic variants in the context of known population diversity. This practice [@problem_id:2412197] simulates the process of \"haplotype threading,\" where you find the single path through the variation graph that best matches a sample's observed alleles. You will develop a dynamic programming algorithm based on a biologically motivated scoring model, gaining hands-on experience in how graphs are used to reconstruct complete haplotypes from variant calls.", "problem": "You are given a directed acyclic pangenome variation graph that encodes alternative alleles across a sequence of variant sites, together with an observed haplotype summary derived from a Variant Call Format (VCF) file. Formalize the problem of choosing a single path through the graph that best matches the observed variants, and implement an algorithm to compute the optimal path and a deterministic tie-breaker where multiple paths have equal optimal scores. Your final deliverable must be a complete, runnable program that evaluates a provided test suite and prints results in the specified format.\n\nDefinitions and assumptions:\n- Consider a finite set of variant sites indexed by integers $1,2,\\dots,n$. For each site $i \\in \\{1,\\dots,n\\}$ there are two possible alleles, encoded as $0$ and $1$.\n- The graph nodes are allele-states of the form $(i,a)$ where $i \\in \\{1,\\dots,n\\}$ and $a \\in \\{0,1\\}$. There is also a distinguished source $S$ that precedes all sites and an implicit sink $T$ that follows all sites. The graph is a directed acyclic graph (DAG) with edges that always go from a node at some site $i$ to a node at a strictly larger site $j$ with $j>i$. There may also be edges from $S$ directly to certain allele-nodes $(j,b)$.\n- An observed haplotype summary is given as a length-$n$ sequence $L[1..n]$, where each $L[i] \\in \\{-1,0,1\\}$. Here $L[i] = -1$ denotes a missing or unknown call at site $i$, while $L[i] \\in \\{0,1\\}$ denotes the observed allele.\n- A path is a sequence $S \\to (i_1,a_1) \\to (i_2,a_2) \\to \\dots \\to (i_m,a_m) \\to T$ such that $1 \\le i_1 < i_2 < \\dots < i_m \\le n$, and each transition follows a directed edge in the graph. The set of visited sites is $\\{i_1,\\dots,i_m\\}$; all other sites are skipped by the path.\n\nScoring model grounded in standard likelihood approximations:\n- Assume independence of variant observations across sites, conditional on the path’s allele choices. The per-site log-likelihood ratio can be simplified to an additive score under independence. Define the per-visit emission score at visited site $i$ with chosen allele $a$,\n  $$\n  \\mathrm{emit}(i,a) \\;=\\;\n  \\begin{cases}\n  0, & \\text{if } L[i] = -1,\\\\\n  +2, & \\text{if } L[i] = a,\\\\\n  -1, & \\text{if } L[i] \\in \\{0,1\\} \\text{ and } L[i] \\neq a.\n  \\end{cases}\n  $$\n  This encodes a simple and plausible log-likelihood surrogate: match is rewarded by $+2$, mismatch is penalized by $-1$, and missing observations contribute $0$.\n- For each site $k$ that the path skips (i.e., $k \\notin \\{i_1,\\dots,i_m\\}$), charge a skip penalty\n  $$\n  \\mathrm{skip}(k) \\;=\\;\n  \\begin{cases}\n  0, & \\text{if } L[k] = -1,\\\\\n  -\\tfrac{1}{2}, & \\text{if } L[k] \\in \\{0,1\\}.\n  \\end{cases}\n  $$\n  This reflects that skipping a confident observed site is less favorable than explaining it with some allele, but is still preferable to a hard mismatch.\n- The total score of a path $P$ is the sum of all emission scores at visited sites plus the sum of skip penalties for all skipped sites:\n  $$\n  \\mathrm{score}(P) \\;=\\; \\sum_{t=1}^{m} \\mathrm{emit}(i_t,a_t) \\;+\\; \\sum_{k \\in \\{1,\\dots,n\\} \\setminus \\{i_1,\\dots,i_m\\}} \\mathrm{skip}(k).\n  $$\n\nDeterministic tie-breaking:\n- Represent any path by a sitewise code vector $c \\in \\{0,1,2\\}^n$ defined by\n  $$\n  c[i] \\;=\\;\n  \\begin{cases}\n  0, & \\text{if site } i \\text{ is visited with allele } 0,\\\\\n  1, & \\text{if site } i \\text{ is visited with allele } 1,\\\\\n  2, & \\text{if site } i \\text{ is skipped}.\n  \\end{cases}\n  $$\n- Among all paths with maximum score, select the path whose code vector $c$ is lexicographically smallest.\n\nEncoding for output:\n- To produce a compact, comparable representation of the chosen path, encode the code vector $c$ as a base-$3$ integer\n  $$\n  \\mathrm{enc}(c) \\;=\\; \\sum_{i=1}^{n} c[i] \\cdot 3^{\\,n-i}.\n  $$\n\nYour task:\n- Design and implement an algorithm that, given $(n, L)$ and a directed acyclic graph on allele-nodes with edges restricted to increasing site indices, computes:\n  $1)$ the maximum path score under the above model, and\n  $2)$ the base-$3$ encoding $\\mathrm{enc}(c)$ of the lexicographically smallest optimal code vector.\n- The algorithm must start from $S$ and may optionally choose the empty path that visits no allele-node at all, which corresponds to skipping every site.\n- You should derive a correct dynamic programming formulation from the DAG structure and the additivity of the score, and implement it efficiently.\n\nTest suite to implement and evaluate:\n- Use the following four cases; for each case, the graph is described by its permitted edges.\n\n  Case A (happy path, full connectivity without skips):\n  - $n = 5$.\n  - Graph edges: For every $i \\in \\{1,2,3,4\\}$ and every $a,b \\in \\{0,1\\}$, include an edge $(i,a) \\to (i+1,b)$. Also include edges $S \\to (1,0)$ and $S \\to (1,1)$.\n  - Observed list $L$ has entries $(0,1,0,1,0)$ in order $i=1$ through $i=5$.\n\n  Case B (missing calls, full connectivity without skips):\n  - $n = 4$.\n  - Graph edges: For every $i \\in \\{1,2,3\\}$ and every $a,b \\in \\{0,1\\}$, include an edge $(i,a) \\to (i+1,b)$. Also include edges $S \\to (1,0)$ and $S \\to (1,1)$.\n  - Observed list $L$ has entries $(0,-1,1,-1)$.\n\n  Case C (allele-stationary adjacency and skip-by-two edges):\n  - $n = 6$.\n  - Graph edges:\n    - Adjacency edges preserve allele across adjacent sites: for every $i \\in \\{1,2,3,4,5\\}$, include $(i,0) \\to (i+1,0)$ and $(i,1) \\to (i+1,1)$.\n    - Skip-by-two edges allow allele reset: for every $i \\in \\{1,2,3,4\\}$ and every $a,b \\in \\{0,1\\}$, include $(i,a) \\to (i+2,b)$.\n    - Source edges: include $S \\to (1,0)$, $S \\to (1,1)$, $S \\to (2,0)$, and $S \\to (2,1)$.\n  - Observed list $L$ has entries $(0,1,0,1,0,1)$.\n\n  Case D (boundary, single site with missing call):\n  - $n = 1$.\n  - Graph edges: include $S \\to (1,0)$ and $S \\to (1,1)$.\n  - Observed list $L$ has the single entry $(-1)$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets. Each case’s result must itself be a two-element list of the form $[\\;\\text{best\\_score},\\;\\mathrm{enc}(c)\\;]$, where $\\text{best\\_score}$ is a real number and $\\mathrm{enc}(c)$ is a nonnegative integer. For example, the overall output must look like a single Python-style list of four such two-element lists. Do not print any other text.\n\nConstraints and notes:\n- You must derive your algorithm from the additivity of the score and the optimal substructure property on directed acyclic graphs.\n- Angles are not involved. No physical units are involved.\n- The answer for each test must be quantifiable and should involve only basic types: the pair is a list containing a float and an integer.", "solution": "The user has provided a problem from computational biology concerning pathfinding in a pangenome variation graph. I shall first validate this problem statement and then, if valid, provide a rigorous solution.\n\n### Step 1: Extract Givens\n- **Sites and Alleles**: A set of $n$ variant sites, indexed $1, \\dots, n$. Each site $i$ has two alleles, $0$ and $1$.\n- **Graph**: A directed acyclic graph (DAG) with nodes representing allele-states $(i, a)$, a source $S$, and a sink $T$. Edges only connect site $i$ to site $j$ where $j > i$.\n- **Observed Data**: A sequence $L[1..n]$ where $L[i] \\in \\{-1, 0, 1\\}$. $L[i]=-1$ for missing data.\n- **Path Definition**: A sequence of nodes from $S$ through a series of allele-nodes $(i_1, a_1), \\dots, (i_m, a_m)$ with increasing site indices $i_1 < \\dots < i_m$, to $T$. Sites not in $\\{i_1, \\dots, i_m\\}$ are 'skipped'.\n- **Scoring Model**: The total score of a path $P$ is additive.\n  - **Emission Score** at a visited site $i$ with allele $a$:\n    $$ \\mathrm{emit}(i, a) =\n    \\begin{cases}\n    0, & \\text{if } L[i] = -1 \\\\\n    +2, & \\text{if } L[i] = a \\\\\n    -1, & \\text{if } L[i] \\neq a \\text{ and } L[i] \\in \\{0,1\\}\n    \\end{cases} $$\n  - **Skip Penalty** for a skipped site $k$:\n    $$ \\mathrm{skip}(k) =\n    \\begin{cases}\n    0, & \\text{if } L[k] = -1 \\\\\n    -\\frac{1}{2}, & \\text{if } L[k] \\in \\{0,1\\}\n    \\end{cases} $$\n  - **Total Score**: $\\mathrm{score}(P) = \\sum_{\\text{visited}} \\mathrm{emit}(i_t, a_t) + \\sum_{\\text{skipped}} \\mathrm{skip}(k)$.\n- **Objective**: Find a path $P$ that maximizes $\\mathrm{score}(P)$.\n- **Tie-Breaking**: Among paths with maximal score, choose the one with the lexicographically smallest code vector $c \\in \\{0, 1, 2\\}^n$, where $c[i]=a$ if site $i$ is visited with allele $a$, and $c[i]=2$ if site $i$ is skipped.\n- **Output Encoding**: The chosen path's code vector $c$ is to be encoded as a base-$3$ integer: $\\mathrm{enc}(c) = \\sum_{i=1}^{n} c[i] \\cdot 3^{n-i}$.\n- **Task**: For given test cases, compute the maximum score and the corresponding minimal encoding.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is a well-established formulation in bioinformatics for haplotype inference from pangenome graphs. The scoring model is a valid, simplified log-likelihood approach. The setup is scientifically sound. The problem is valid on this criterion.\n2.  **Well-Posed**: The problem is to find an optimal path in a DAG under a clearly defined objective function with a deterministic tie-breaker. This ensures that a unique solution exists. The problem is well-posed.\n3.  **Objective**: All definitions, rules, and data are specified with mathematical precision, leaving no room for subjective interpretation. The problem is objective.\n4.  **Completeness and Consistency**: The problem specification is self-contained. The additive nature of the score, the DAG structure, and the lexicographical tie-breaker are fully compatible with a dynamic programming solution. No contradictions are present.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be derived and implemented.\n\n### Solution Derivation\n\nThe task is to find a path that maximizes a score, and among score-optimal paths, minimizes a secondary criterion. This is a lexicographical optimization problem on a DAG, which is well-suited for dynamic programming.\n\n**1. Problem Reformulation**\nThe total score of a path $P$ is $\\mathrm{score}(P) = \\sum_{(i,a) \\in P} \\mathrm{emit}(i, a) + \\sum_{k \\notin P} \\mathrm{skip}(k)$. Let $C_{skip} = \\sum_{k=1}^n \\mathrm{skip}(k)$ be the constant sum of all possible skip penalties. The score can be rewritten as:\n$$ \\mathrm{score}(P) = \\left( \\sum_{(i,a) \\in P} \\mathrm{emit}(i, a) - \\sum_{(i,a) \\in P} \\mathrm{skip}(i) \\right) + C_{skip} $$\nMaximizing $\\mathrm{score}(P)$ is equivalent to maximizing the path-dependent term $\\sum_{(i,a) \\in P} (\\mathrm{emit}(i, a) - \\mathrm{skip}(i))$. Let us define the adjusted weight of visiting node $(i,a)$ as $w(i,a) = \\mathrm{emit}(i,a) - \\mathrm{skip}(i)$. The problem becomes maximizing $\\sum_{(i,a) \\in P} w(i,a)$.\n\nThe tie-breaking criterion requires finding the path with the lexicographically smallest code vector $c$. This is equivalent to minimizing the base-$3$ encoding $\\mathrm{enc}(c) = \\sum_{i=1}^{n} c[i] \\cdot 3^{n-i}$, as the powers of $3$ are ordered in the same way as the indices for lexicographical comparison.\n\nThus, we must find a path $P$ that lexicographically maximizes the pair $(\\mathrm{score}(P), -\\mathrm{enc}(c(P)))$.\n\n**2. Dynamic Programming Formulation**\nThe DAG structure, where edges only lead to nodes with higher site indices, guarantees the optimal substructure property. An optimal path to a node $(j,b)$ must be an extension of an optimal path to one of its predecessors. The tie-breaking rule is also compatible because the code vector prefixes are built upon, and lexicographical order is preserved under a common suffix.\n\nWe define a DP state for each node $(j, b)$ that stores a pair representing the optimal path from source $S$ ending at $(j,b)$. Since the final tie-breaking decision depends on the full path's encoding, we must carefully construct our DP state.\nLet $dp[j-1][b]$ be a pair $(s, e)$ for paths ending at node $(j,b)$, where $j \\in \\{1, \\dots, n\\}$ is the 1-indexed site.\n- $s$ is the maximum path-dependent score, $\\sum w(i,a)$, for a path from $S$ ending at $(j,b)$.\n- $e$ is the minimum partial encoding for such a path, calculated as $\\sum_{k=1}^j c[k] \\cdot 3^{n-k}$.\n\nThe nodes are processed in topological order, which is naturally given by the site indices $j=1, \\dots, n$.\n\n**3. Recurrence Relation**\nFor each node $(j,b)$, we find the best predecessor node $(i,a)$ (where $i<j$, and $S$ is treated as site $0$).\nLet $dp[i-1][a]=(s_{prev}, e_{prev})$ be the state for a predecessor $(i,a)$. For $S$, this is $(0,0)$.\nA path extended from $(i,a)$ to $(j,b)$ skips sites $k \\in \\{i+1, \\dots, j-1\\}$.\nThe new path-dependent score is $s_{new} = s_{prev} + w(j,b)$.\nThe new partial encoding is $e_{new} = e_{prev} + \\left( \\sum_{k=i+1}^{j-1} 2 \\cdot 3^{n-k} \\right) + b \\cdot 3^{n-j}$.\n\nThe state for $(j,b)$ is found by maximizing $(s_{new}, -e_{new})$ over all predecessors:\n$dp[j-1][b] = \\operatorname*{lexmax}_{u \\in \\mathrm{preds}(j,b)} \\left( s_{new}(u), -e_{new}(u) \\right)$\nThis means we first choose the predecessor that yields the highest $s_{new}$. If there's a tie, we choose the one that yields the lowest $e_{new}$.\n\n**4. Algorithm Outline**\n1.  **Initialization**:\n    - For each site $i \\in \\{1,\\dots,n\\}$ and allele $a \\in \\{0,1\\}$, compute `emit(i,a)`, `skip(i)`, and `w(i,a)`.\n    - Calculate the total skip constant $C_{skip} = \\sum_{k=1}^n \\mathrm{skip}(k)$.\n    - Build predecessor lists for all nodes based on the input edge set.\n    - Initialize the DP table $dp[j][b] = (-\\infty, \\infty)$ for all $j,b$.\n\n2.  **DP Calculation**:\n    - Iterate through sites $j=1, \\dots, n$ and alleles $b=0,1$.\n    - For each node $(j,b)$, iterate through its predecessors $(i,a)$ (including $S$ as site $0$).\n    - Calculate the `(score, encoding)` pair for the path through the predecessor and update the DP state for $(j,b)$ using the lexicographical maximization rule.\n\n3.  **Finalization**:\n    - The overall optimal path could be the empty path (all sites skipped) or a path ending at any node $(i,a)$ (with sites $i+1, \\dots, n$ subsequently skipped).\n    - Initialize a global best solution `(best_score, best_enc)` with the score and encoding of the empty path. $\\mathrm{score}_{empty} = C_{skip}$, $\\mathrm{enc}_{empty} = \\sum_{k=1}^n 2 \\cdot 3^{n-k}$.\n    - For each node $(i,a)$, calculate the total score and final encoding for a path ending there:\n      - `final_score = C_skip + dp[i-1][a].s`\n      - `final_enc = dp[i-1][a].e + \\sum_{k=i+1}^n 2 \\cdot 3^{n-k}`\n    - Compare `(final_score, -final_enc)` with the global best and update if a better path is found.\n\n4.  **Result**: The final `(best_score, best_enc)` pair is the solution.\n\nThis algorithm correctly finds the optimal path according to the specified criteria. Its time complexity is determined by the number of edges in the graph, as each edge is considered once, making it efficient for the sparse graphs typical in this application.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define and run the test suite.\n    \"\"\"\n    # Note on graph representation:\n    # A path S -> (j,b) is represented as an edge ((0,0), (j,b)).\n    # Allele nodes are (site_index, allele_code), where site_index is 1-based.\n    \n    test_cases = [\n        # Case A: Happy path, full connectivity without skips\n        {\n            \"n\": 5, \"L\": [0, 1, 0, 1, 0],\n            \"edges\": ([((i, a), (i + 1, b)) for i in range(1, 5) for a in range(2) for b in range(2)] +\n                      [((0, 0), (1, 0)), ((0, 0), (1, 1))])\n        },\n        # Case B: Missing calls, full connectivity\n        {\n            \"n\": 4, \"L\": [0, -1, 1, -1],\n            \"edges\": ([((i, a), (i + 1, b)) for i in range(1, 4) for a in range(2) for b in range(2)] +\n                      [((0, 0), (1, 0)), ((0, 0), (1, 1))])\n        },\n        # Case C: Allele-stationary adjacency and skip-by-two edges\n        {\n            \"n\": 6, \"L\": [0, 1, 0, 1, 0, 1],\n            \"edges\": ([((i, 0), (i + 1, 0)) for i in range(1, 6)] +\n                      [((i, 1), (i + 1, 1)) for i in range(1, 6)] +\n                      [((i, a), (i + 2, b)) for i in range(1, 5) for a in range(2) for b in range(2)] +\n                      [((0, 0), (1, 0)), ((0, 0), (1, 1)), ((0, 0), (2, 0)), ((0, 0), (2, 1))])\n        },\n        # Case D: Boundary, single site with missing call\n        {\n            \"n\": 1, \"L\": [-1],\n            \"edges\": [((0, 0), (1, 0)), ((0, 0), (1, 1))]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_case(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_case(n, L, edges):\n    \"\"\"\n    Solves a single instance of the pathfinding problem.\n    \"\"\"\n    # 1. Precompute scores and constants\n    # Using 0-indexing for site i: 0 to n-1\n    emit_vals = np.zeros((n, 2))\n    skip_vals = np.zeros(n)\n    w = np.zeros((n, 2))  # Adjusted weights: w(i,a) = emit(i,a) - skip(i)\n\n    for i in range(n):\n        l_val = L[i]\n        if l_val == -1:\n            skip_vals[i] = 0.0\n            emit_vals[i, 0] = 0.0\n            emit_vals[i, 1] = 0.0\n        else:\n            skip_vals[i] = -0.5\n            observed_allele = int(l_val)\n            emit_vals[i, observed_allele] = 2.0\n            emit_vals[i, 1 - observed_allele] = -1.0\n        \n        w[i, 0] = emit_vals[i, 0] - skip_vals[i]\n        w[i, 1] = emit_vals[i, 1] - skip_vals[i]\n\n    C_skip = np.sum(skip_vals)\n    pow3 = [3**k for k in range(n + 1)]\n\n    # 2. Build predecessor list\n    # S is node (0,0). Allele nodes are (site, allele) where site is 1-indexed.\n    preds = {(j, b): [] for j in range(1, n + 1) for b in range(2)}\n    for u, v in edges:\n        preds[v].append(u)\n\n    # 3. Dynamic Programming\n    # dp[i][a] stores (path_dep_score, enc_prefix) for paths ending at site i+1, allele a\n    dp = [[(-np.inf, float('inf')) for _ in range(2)] for _ in range(n)]\n\n    for j in range(1, n + 1):  # 1-indexed site\n        for b in range(2):      # Allele\n            node = (j, b)\n            if not preds[node]:\n                continue\n            \n            best_v_dp = (-np.inf, float('inf'))\n            \n            for u_site, u_allele in preds[node]:\n                if u_site == 0:  # Predecessor is Source S\n                    pred_path_dep_score = 0\n                    pred_enc_prefix = 0\n                else:\n                    pred_path_dep_score, pred_enc_prefix = dp[u_site - 1][u_allele]\n                \n                if pred_path_dep_score == -np.inf:\n                    continue\n\n                path_dep_score = pred_path_dep_score + w[j - 1, b]\n                \n                skip_enc_val = 0\n                for k in range(u_site + 1, j):\n                    skip_enc_val += 2 * pow3[n - k]\n                \n                enc_prefix = pred_enc_prefix + skip_enc_val + b * pow3[n - j]\n\n                curr_best_score, curr_best_enc = best_v_dp\n                if path_dep_score > curr_best_score + 1e-9:\n                    best_v_dp = (path_dep_score, enc_prefix)\n                elif abs(path_dep_score - curr_best_score) < 1e-9 and enc_prefix < curr_best_enc:\n                    best_v_dp = (path_dep_score, enc_prefix)\n            \n            dp[j - 1][b] = best_v_dp\n\n    # 4. Finalization: Find the best overall path\n    # Initialize with the empty path (all sites skipped)\n    empty_path_score = C_skip\n    empty_path_enc = sum(2 * pow3[n - k] for k in range(1, n + 1))\n    \n    global_best_score = empty_path_score\n    global_best_enc = empty_path_enc\n\n    # Precompute suffix encodings for skipped sites\n    tail_skip_enc = [0] * (n + 2)\n    for i in range(n, 0, -1):\n        tail_skip_enc[i] = tail_skip_enc[i + 1] + 2 * pow3[n - i]\n\n    for i in range(1, n + 1):  # 1-indexed site\n        for a in range(2):\n            path_dep_score, enc_prefix = dp[i - 1][a]\n            if path_dep_score == -np.inf:\n                continue\n            \n            total_score = C_skip + path_dep_score\n            final_enc = enc_prefix + tail_skip_enc[i + 1]\n            \n            if total_score > global_best_score + 1e-9:\n                global_best_score = total_score\n                global_best_enc = final_enc\n            elif abs(total_score - global_best_score) < 1e-9 and final_enc < global_best_enc:\n                global_best_score = total_score # Update score to maintain consistency\n                global_best_enc = final_enc\n                \n    return [global_best_score, int(global_best_enc)]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2412197"}, {"introduction": "Beyond representing sequences, pangenome graphs serve as a scaffold for quantitative analysis of sequencing data, but this requires accounting for experimental noise. This exercise [@problem_id:2412211] explores how to estimate the frequency of alleles within a variant \"bubble\" from imperfect read count data. By constructing a probabilistic model that incorporates hypothetical mapping errors ($\\epsilon$) and biases ($\\beta_i$), you will apply the principle of maximum likelihood estimation to infer the true allele frequency ($f$), a crucial technique for accurate variant quantification.", "problem": "A pangenome variation graph encodes alternative alleles as parallel paths (a bubble) between two nodes. Consider a single bubble with exactly two disjoint branches, each representing a distinct allele of a single-nucleotide polymorphism (SNP). Let the unknown sample-level allele frequency of branch $1$ be $f \\in [0,1]$, and the frequency of branch $2$ be $1-f$. Sequencing reads are generated independently and identically from the two alleles in proportion to their true frequencies. Due to alignment imperfections, a read generated from allele $i$ is assigned to its correct branch with probability $1-\\epsilon$ and to the other branch with probability $\\epsilon$, where $\\epsilon$ is known and satisfies $0 \\le \\epsilon < \\frac{1}{2}$. In addition, there is a branch-specific mapping bias: the probability that a read is ultimately assigned to branch $i$ is multiplied by a known, positive bias factor $\\beta_i$ before renormalization across the two branches to ensure probabilities sum to $1$.\n\nSuppose the following are observed or known:\n- The number of reads assigned to branch $1$ is $x_1 = 620$, and to branch $2$ is $x_2 = 380$, so the total is $N = x_1 + x_2$.\n- The misassignment probability is $\\epsilon = 0.02$.\n- The bias multipliers are $\\beta_1 = 1.10$ and $\\beta_2 = 0.90$.\n\nAssume that only reads that traverse the bubble are counted (so $N$ is the total number of informative reads for this bubble), reads are independent, and the assignment mechanism follows the description above. Under this model, the probability that any given read is assigned to branch $i \\in \\{1,2\\}$ is proportional to $\\beta_i \\left[(1-\\epsilon)\\pi_i + \\epsilon \\pi_{3-i}\\right]$, with $\\pi_1 = f$ and $\\pi_2 = 1-f$, and then normalized so that the two branch-assignment probabilities sum to $1$.\n\nUsing a maximum likelihood approach under a multinomial model for $(x_1,x_2)$ with the assignment probabilities defined above, compute the maximum likelihood estimate of $f$. Round your answer to four significant figures.", "solution": "The problem requires the computation of the maximum likelihood estimate (MLE) for the sample-level allele frequency, denoted by $f$, based on observed read counts on two branches of a variation graph bubble.\n\nFirst, we formalize the probabilistic model. The true frequencies of the two alleles (branches) are $\\pi_1 = f$ and $\\pi_2 = 1-f$. Reads are generated from these alleles in proportion to their frequencies. These reads are subject to misassignment and mapping bias.\n\nLet $U_i(f)$ be the probability that a read is assigned to branch $i$ before considering mapping bias. This probability accounts for the true allele frequency and the misassignment probability $\\epsilon$. A read generated from allele $j$ is assigned to its correct branch $j$ with probability $1-\\epsilon$ and to the other branch $3-j$ with probability $\\epsilon$. Using the law of total probability:\nThe probability of a read being assigned to branch $1$, before bias, is:\n$$U_1(f) = P(\\text{assigned to branch } 1 | \\text{from allele } 1)P(\\text{from allele } 1) + P(\\text{assigned to branch } 1 | \\text{from allele } 2)P(\\text{from allele } 2)$$\n$$U_1(f) = (1-\\epsilon)f + \\epsilon(1-f) = (1-2\\epsilon)f + \\epsilon$$\nSimilarly, the probability of a read being assigned to branch $2$, before bias, is:\n$$U_2(f) = P(\\text{assigned to branch } 2 | \\text{from allele } 1)P(\\text{from allele } 1) + P(\\text{assigned to branch } 2 | \\text{from allele } 2)P(\\text{from allele } 2)$$\n$$U_2(f) = \\epsilon f + (1-\\epsilon)(1-f) = -(1-2\\epsilon)f + (1-\\epsilon)$$\nNote that $U_1(f) + U_2(f) = 1$.\n\nNext, we incorporate the branch-specific mapping bias factors $\\beta_1$ and $\\beta_2$. The unnormalized probabilities of assignment become:\n$$p'_1(f) = \\beta_1 U_1(f) = \\beta_1 ((1-2\\epsilon)f + \\epsilon)$$\n$$p'_2(f) = \\beta_2 U_2(f) = \\beta_2 (-(1-2\\epsilon)f + (1-\\epsilon))$$\nThe final probabilities, $p_1(f)$ and $p_2(f)$, are obtained by normalizing so that they sum to $1$:\n$$p_1(f) = \\frac{p'_1(f)}{p'_1(f) + p'_2(f)}$$\n$$p_2(f) = \\frac{p'_2(f)}{p'_1(f) + p'_2(f)} = 1 - p_1(f)$$\n\nThe observed data are the read counts $x_1 = 620$ and $x_2 = 380$, with a total of $N = x_1 + x_2 = 1000$ reads. The number of reads $(x_1, x_2)$ follows a binomial (or multinomial with $k=2$ categories) distribution. The likelihood function is:\n$$L(f; x_1, x_2) = \\binom{N}{x_1} p_1(f)^{x_1} p_2(f)^{x_2} = \\binom{N}{x_1} p_1(f)^{x_1} (1-p_1(f))^{x_2}$$\nTo find the MLE of $f$, we maximize the log-likelihood function $\\ell(f) = \\ln L(f)$:\n$$\\ell(f) = \\ln\\binom{N}{x_1} + x_1 \\ln(p_1(f)) + x_2 \\ln(1-p_1(f))$$\nWe find the maximum by setting the derivative with respect to $f$ to zero:\n$$\\frac{d\\ell}{df} = \\left( \\frac{x_1}{p_1(f)} - \\frac{x_2}{1-p_1(f)} \\right) \\frac{dp_1}{df} = 0$$\nGiven that the parameters $\\beta_1, \\beta_2 > 0$ and $\\epsilon \\in [0, 1/2)$, the derivative $\\frac{dp_1}{df}$ is non-zero. Therefore, the term in the parenthesis must be zero for an interior maximum:\n$$\\frac{x_1}{p_1(f)} = \\frac{x_2}{1-p_1(f)}$$\nThis simplifies to $x_1(1-p_1(f)) = x_2 p_1(f)$, which yields the well-known result that the MLE for the probability is the observed frequency:\n$$p_1(\\hat{f}) = \\frac{x_1}{x_1 + x_2} = \\frac{x_1}{N}$$\nThis means the MLE of $f$, denoted $\\hat{f}$, must satisfy this condition. An equivalent condition is that the ratio of probabilities equals the ratio of observed counts:\n$$\\frac{p_1(\\hat{f})}{p_2(\\hat{f})} = \\frac{x_1}{x_2}$$\nSubstituting the expressions for $p_1(f)$ and $p_2(f)$:\n$$\\frac{p'_1(\\hat{f})}{p'_2(\\hat{f})} = \\frac{\\beta_1 ((1-2\\epsilon)\\hat{f} + \\epsilon)}{\\beta_2 (-(1-2\\epsilon)\\hat{f} + (1-\\epsilon))} = \\frac{x_1}{x_2}$$\nWe solve this equation for $\\hat{f}$:\n$$x_2 \\beta_1 ((1-2\\epsilon)\\hat{f} + \\epsilon) = x_1 \\beta_2 (-(1-2\\epsilon)\\hat{f} + (1-\\epsilon))$$\n$$x_2 \\beta_1 (1-2\\epsilon)\\hat{f} + x_2 \\beta_1 \\epsilon = -x_1 \\beta_2 (1-2\\epsilon)\\hat{f} + x_1 \\beta_2 (1-\\epsilon)$$\nGroup the terms containing $\\hat{f}$:\n$$\\hat{f} (1-2\\epsilon) (x_2 \\beta_1 + x_1 \\beta_2) = x_1 \\beta_2 (1-\\epsilon) - x_2 \\beta_1 \\epsilon$$\nFinally, we isolate $\\hat{f}$:\n$$\\hat{f} = \\frac{x_1 \\beta_2 (1-\\epsilon) - x_2 \\beta_1 \\epsilon}{(1-2\\epsilon)(x_1 \\beta_2 + x_2 \\beta_1)}$$\nThis formula provides the MLE for $f$, provided that the result lies within the valid range $[0, 1]$.\n\nNow, we substitute the given values:\n- $x_1 = 620$\n- $x_2 = 380$\n- $\\epsilon = 0.02$\n- $\\beta_1 = 1.10$\n- $\\beta_2 = 0.90$\n\nWe calculate the necessary components:\n- $1-\\epsilon = 1 - 0.02 = 0.98$\n- $1-2\\epsilon = 1 - 2(0.02) = 1 - 0.04 = 0.96$\n\nNumerator of the expression for $\\hat{f}$:\n$$x_1 \\beta_2 (1-\\epsilon) - x_2 \\beta_1 \\epsilon = (620)(0.90)(0.98) - (380)(1.10)(0.02)$$\n$$= (558)(0.98) - (418)(0.02) = 546.84 - 8.36 = 538.48$$\n\nDenominator of the expression for $\\hat{f}$:\n$$(1-2\\epsilon)(x_1 \\beta_2 + x_2 \\beta_1) = (0.96)((620)(0.90) + (380)(1.10))$$\n$$= (0.96)(558 + 418) = (0.96)(976) = 936.96$$\n\nThe MLE for $f$ is the ratio of these two values:\n$$\\hat{f} = \\frac{538.48}{936.96} \\approx 0.5747063...$$\nThe problem requires the answer to be rounded to four significant figures.\nThe value is $0.5747$.", "answer": "$$\\boxed{0.5747}$$", "id": "2412211"}]}