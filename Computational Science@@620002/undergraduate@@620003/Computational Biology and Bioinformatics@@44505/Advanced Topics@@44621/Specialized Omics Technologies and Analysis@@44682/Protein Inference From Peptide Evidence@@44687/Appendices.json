{"hands_on_practices": [{"introduction": "Before tackling the challenge of protein inference, it's crucial to understand its origins at the sequence level. The ambiguity at the core of this problem arises because different proteins, often from the same family, can share identical peptide sequences after enzymatic digestion. This hands-on coding practice will guide you in building an algorithm from the ground up to perform in-silico digestion, allowing you to see exactly how and why the \"shared peptide problem\" emerges from raw protein sequence data [@problem_id:2420453].", "problem": "You are given the task of computing a quantitative measure of ambiguity for protein inference based on shared theoretical peptides under a strictly defined proteolytic model. The inference ambiguity score for a query protein is defined as the fraction of its distinct theoretical peptides that are also produced by at least one other protein in a specified database, under identical digestion parameters.\n\nFormally, let the amino acid alphabet be the set of uppercase letters representing the $20$ standard amino acids: $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{K}, \\mathrm{L}, \\mathrm{M}, \\mathrm{N}, \\mathrm{P}, \\mathrm{Q}, \\mathrm{R}, \\mathrm{S}, \\mathrm{T}, \\mathrm{V}, \\mathrm{W}, \\mathrm{Y} \\}$. Each protein is a finite sequence over this alphabet. Digestion follows a fully specific tryptic rule: cleavage occurs immediately after any $\\mathrm{K}$ or $\\mathrm{R}$ residue unless that residue is followed by $\\mathrm{P}$. Let the cleavage positions partition a protein sequence into an ordered list of contiguous segments. For a nonnegative integer $m$ (the maximum number of missed cleavages), the set of theoretical peptides for a protein is the set of all concatenations of between $1$ and $m+1$ consecutive segments, filtered to those whose lengths lie within the inclusive interval $[L_{\\min}, L_{\\max}]$. Distinctness is by exact string equality.\n\nFor a query protein sequence $S$ and a database $D$ of proteins (each with a distinct identifier and sequence), define $P(S; m, L_{\\min}, L_{\\max})$ as the set of distinct theoretical peptides of $S$ under the above rule. Define $P(D; m, L_{\\min}, L_{\\max})$ as the union over all proteins in $D$ of their distinct theoretical peptides under the same parameters. A peptide from $P(S; m, L_{\\min}, L_{\\max})$ is considered shared if it is also in $P(D; m, L_{\\min}, L_{\\max})$. The inference ambiguity score is\n$$\nA(S, D; m, L_{\\min}, L_{\\max}) =\n\\begin{cases}\n0, & \\text{if } |P(S; m, L_{\\min}, L_{\\max})| = 0, \\\\\n\\dfrac{|\\{ p \\in P(S; m, L_{\\min}, L_{\\max}) \\,:\\, p \\in P(D; m, L_{\\min}, L_{\\max}) \\}|}{|P(S; m, L_{\\min}, L_{\\max})|}, & \\text{otherwise.}\n\\end{cases}\n$$\nAll ratios must be expressed as decimal numbers, not as percentages.\n\nYour program must implement this definition exactly and compute $A(S, D; m, L_{\\min}, L_{\\max})$ for each of the test cases specified below. The database $D$ for a test case does not include the query protein itself.\n\nUse the following test suite. Each test case is specified by a tuple consisting of: a query identifier, a query sequence, a list of database proteins as $(\\text{id}, \\text{sequence})$ pairs, the maximum number of missed cleavages $m$, the minimum peptide length $L_{\\min}$, and the maximum peptide length $L_{\\max}$. All identifiers are arbitrary strings; only sequences affect the computation.\n\n- Test case $1$:\n  - Query: $(\\text{\"Q1\"}, \\text{\"ACDEKFGHIKLMNRPSTVWY\"})$\n  - Database $D$: $[(\\text{\"B\"}, \\text{\"ACDEKAAAMK\"}), (\\text{\"C\"}, \\text{\"MFGHIKTTT\"}), (\\text{\"E\"}, \\text{\"KKKK\"})]$\n  - Parameters: $m = 0$, $L_{\\min} = 5$, $L_{\\max} = 30$\n\n- Test case $2$:\n  - Query: $(\\text{\"Q2\"}, \\text{\"TTTTT\"})$\n  - Database $D$: $[(\\text{\"A\"}, \\text{\"ACDEKFGHIKLMNRPSTVWY}), (\\text{\"B\"}, \\text{\"ACDEKAAAMK\"}), (\\text{\"C\"}, \\text{\"MFGHIKTTT\"})]$\n  - Parameters: $m = 0$, $L_{\\min} = 5$, $L_{\\max} = 30$\n\n- Test case $3$:\n  - Query: $(\\text{\"Q3\"}, \\text{\"LMNRPSTVWY\"})$\n  - Database $D$: $[(\\text{\"A\"}, \\text{\"ACDEKFGHIKLMNRPSTVWY\"})]$\n  - Parameters: $m = 0$, $L_{\\min} = 5$, $L_{\\max} = 30$\n\n- Test case $4$:\n  - Query: $(\\text{\"Q4\"}, \\text{\"AK\"})$\n  - Database $D$: $[(\\text{\"X\"}, \\text{\"ACACAC\"}), (\\text{\"Y\"}, \\text{\"RPRP\"})]$\n  - Parameters: $m = 0$, $L_{\\min} = 6$, $L_{\\max} = 7$\n\n- Test case $5$:\n  - Query: $(\\text{\"Q5\"}, \\text{\"PEPTKALRGLY\"})$\n  - Database $D$: $[(\\text{\"J\"}, \\text{\"PEPTKALRQQQ\"})]$\n  - Parameters: $m = 1$, $L_{\\min} = 4$, $L_{\\max} = 50$\n\nYour program should produce a single line of output containing the results for test cases $1$ through $5$ in order, as a comma-separated list of decimal numbers rounded to exactly $6$ digits after the decimal point, enclosed in square brackets. For example, the format must be exactly like $[\\text{r1},\\text{r2},\\text{r3},\\text{r4},\\text{r5}]$ where each $\\text{r}i$ is a decimal with exactly $6$ digits after the decimal point.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a simplified but standard model used in computational proteomics for the task of protein inference. The definitions are precise, the parameters are explicit, and the objective is clearly formulated. There are no logical contradictions, missing information, or pseudoscientific assumptions. Therefore, a rigorous solution is possible and will be constructed.\n\nThe task is to compute an inference ambiguity score for a query protein. This score quantifies the extent to which peptides derived from a query protein are also found in a background database of other proteins. The core of this problem lies in the precise, algorithmic generation of theoretical peptide sets from protein sequences.\n\nThe procedure is partitioned into two main components: first, the generation of theoretical peptides for a given protein sequence under specified parameters; second, the use of these peptide sets to compute the ambiguity score.\n\nFirst, let us formalize the process of in-silico digestion. A protein, represented as a sequence of characters from the amino acid alphabet, is cleaved by a proteolytic enzyme, here, trypsin. The given rule is a standard approximation: cleavage occurs at the C-terminus of a lysine ($\\mathrm{K}$) or arginine ($\\mathrm{R}$) residue, unless that residue is immediately followed by a proline ($\\mathrm{P}$). This rule partitions the protein sequence into an ordered list of fundamental segments. For a sequence $S$, let the cleavage positions be at indices $c_1, c_2, \\ldots, c_k$. Including the sequence start ($0$) and end ($|S|$), we define the set of cut points as $\\{0, c_1, c_2, \\ldots, c_k, |S|\\}$. The fundamental segments are the substrings between adjacent cut points. Let this ordered list of segments be $(s_1, s_2, \\ldots, s_{k+1})$.\n\nThe parameter $m$, the maximum number of missed cleavages, allows for incomplete digestion. A peptide with $j$ missed cleavages is formed by the concatenation of $j+1$ consecutive fundamental segments. Our model considers peptides with $0, 1, \\ldots, m$ missed cleavages. Thus, a candidate peptide is a concatenation of the form $s_i s_{i+1} \\ldots s_{i+j}$, where $1 \\le i \\le k+1$ and $0 \\le j \\le m$, such that $i+j \\le k+1$.\n\nFinally, each candidate peptide $p$ is subjected to a length filter. It is only considered a valid theoretical peptide if its length, $|p|$, falls within the inclusive interval $[L_{\\min}, L_{\\max}]$. The set of all such valid, distinct peptides for a sequence $S$ and parameters $(m, L_{\\min}, L_{\\max})$ is denoted $P(S; m, L_{\\min}, L_{\\max})$.\n\nThe algorithm for generating this set is as follows:\n1.  For a given protein sequence, identify all indices $i$ where cleavage occurs, i.e., where `sequence[i]` is $\\mathrm{K}$ or $\\mathrm{R}$, and `sequence[i+1]` is not $\\mathrm{P}$.\n2.  Use these cleavage sites to segment the protein sequence into an ordered list of fundamental peptides (segments corresponding to zero missed cleavages).\n3.  Generate all possible contiguous subsequences of this segment list, with lengths from $1$ up to $m+1$.\n4.  For each such subsequence of segments, concatenate them to form a candidate peptide string.\n5.  If the length of the candidate peptide is between $L_{\\min}$ and $L_{\\max}$ inclusive, add it to a set data structure to ensure uniqueness.\n6.  The final result is this set of unique peptides.\n\nWith the peptide generation function established, we can compute the ambiguity score $A(S, D; m, L_{\\min}, L_{\\max})$. Let $P_S = P(S; m, L_{\\min}, L_{\\max})$ be the set of peptides for the query protein $S$, and let $P_D = \\bigcup_{S' \\in D} P(S'; m, L_{\\min}, L_{\\max})$ be the set of all peptides from all proteins in the database $D$.\n\nThe set of shared peptides is the intersection of these two sets, $P_S \\cap P_D$. The ambiguity score is defined as the ratio of the number of shared peptides to the total number of query peptides:\n$$\nA(S, D; m, L_{\\min}, L_{\\max}) = \\frac{|P_S \\cap P_D|}{|P_S|}\n$$\nA special case is defined for when the query peptide set is empty: if $|P_S| = 0$, the score is $A=0$. This is a necessary condition to prevent division by zero.\n\nThe implementation will strictly follow this described logic. For each test case, the peptide sets for the query and for each database entry will be generated. The ambiguity score will then be computed based on the ratio of cardinalities of the respective sets, as per the formula, and formatted as required.", "answer": "```python\nimport numpy as np\n\ndef get_peptides(sequence: str, m: int, l_min: int, l_max: int) -> set[str]:\n    \"\"\"\n    Computes the set of theoretical peptides for a given protein sequence.\n\n    Args:\n        sequence: The amino acid sequence of the protein.\n        m: The maximum number of missed cleavages.\n        l_min: The minimum length of a valid peptide.\n        l_max: The maximum length of a valid peptide.\n\n    Returns:\n        A set of distinct theoretical peptide strings.\n    \"\"\"\n    if not sequence:\n        return set()\n\n    cut_indices = [0]\n    for i in range(len(sequence) - 1):\n        if sequence[i] in ('K', 'R') and sequence[i+1] != 'P':\n            cut_indices.append(i + 1)\n    cut_indices.append(len(sequence))\n\n    segments = []\n    for i in range(len(cut_indices) - 1):\n        start, end = cut_indices[i], cut_indices[i+1]\n        segments.append(sequence[start:end])\n\n    peptides = set()\n    num_segments_total = len(segments)\n    \n    # Iterate through number of segments to join (from 1 to m+1)\n    for k in range(1, m + 2):\n        if k > num_segments_total:\n            break\n        # Iterate through starting positions for segment groups\n        for i in range(num_segments_total - k + 1):\n            peptide_candidate = \"\".join(segments[i : i+k])\n            if l_min <= len(peptide_candidate) <= l_max:\n                peptides.add(peptide_candidate)\n                \n    return peptides\n\ndef solve():\n    \"\"\"\n    Solves the protein inference ambiguity problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        (\n            \"Q1\", \"ACDEKFGHIKLMNRPSTVWY\",\n            [(\"B\", \"ACDEKAAAMK\"), (\"C\", \"MFGHIKTTT\"), (\"E\", \"KKKK\")],\n            0, 5, 30\n        ),\n        # Test Case 2\n        (\n            \"Q2\", \"TTTTT\",\n            [(\"A\", \"ACDEKFGHIKLMNRPSTVWY\"), (\"B\", \"ACDEKAAAMK\"), (\"C\", \"MFGHIKTTT\")],\n            0, 5, 30\n        ),\n        # Test Case 3\n        (\n            \"Q3\", \"LMNRPSTVWY\",\n            [(\"A\", \"ACDEKFGHIKLMNRPSTVWY\")],\n            0, 5, 30\n        ),\n        # Test Case 4\n        (\n            \"Q4\", \"AK\",\n            [(\"X\", \"ACACAC\"), (\"Y\", \"RPRP\")],\n            0, 6, 7\n        ),\n        # Test Case 5\n        (\n            \"Q5\", \"PEPTKALRGLY\",\n            [(\"J\", \"PEPTKALRQQQ\")],\n            1, 4, 50\n        )\n    ]\n\n    results = []\n    for _, query_seq, db_proteins, m, l_min, l_max in test_cases:\n        # Generate peptides for the query protein\n        query_peptides = get_peptides(query_seq, m, l_min, l_max)\n        \n        # If no query peptides, score is 0\n        if not query_peptides:\n            results.append(0.0)\n            continue\n            \n        # Generate peptides for all proteins in the database\n        db_peptides = set()\n        for _, db_seq in db_proteins:\n            peps = get_peptides(db_seq, m, l_min, l_max)\n            db_peptides.update(peps)\n            \n        # Find shared peptides\n        shared_peptides = query_peptides.intersection(db_peptides)\n        \n        # Calculate ambiguity score\n        score = len(shared_peptides) / len(query_peptides)\n        results.append(score)\n\n    # Format and print the final output\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2420453"}, {"introduction": "Faced with a complex web of peptide-to-protein mappings, a common and intuitive approach is to apply the Principle of Parsimony: explain the observed peptides with the smallest possible set of proteins. While simple, this heuristic can sometimes lead to incorrect conclusions. This exercise challenges you to think adversarially and design a specific scenario where a greedy, parsimony-based algorithm completely fails, an undertaking that reveals the inherent complexities of protein inference and motivates the need for more sophisticated methods [@problem_id:2420457].", "problem": "You are given a formal model of protein inference from peptide evidence as a bipartite incidence structure. There are $m$ candidate proteins and $n$ observed peptides. The protein-to-peptide generative relation is represented by a binary incidence matrix $A \\in \\{0,1\\}^{m \\times n}$ where $A_{ij} = 1$ if and only if protein $i$ can generate peptide $j$. A subset $T \\subset \\{0,1,\\dots,m-1\\}$ indexes the true proteins that are actually present and generate the observed peptides. Every observed peptide must be generable by at least one true protein, meaning that for every peptide index $j \\in \\{0,1,\\dots,n-1\\}$ there exists at least one $i \\in T$ with $A_{ij} = 1$. We define a maximum degeneracy constraint $r \\in \\mathbb{N}$ such that each peptide maps to at most $r$ proteins, i.e., every column of $A$ must have a column sum between $1$ and $r$ inclusive.\n\nThe parsimony-based inference procedure to be examined is a simple greedy set cover algorithm with deterministic tie-breaking. Define the uncovered set of peptides $U$ initially as $U = \\{0,1,\\dots,n-1\\}$. While $U$ is non-empty, the algorithm selects a protein index $i^\\star$ that maximizes the number of uncovered peptides it can explain, i.e., it chooses\n$$\ni^\\star \\in \\arg\\max_{i \\in \\{0,1,\\dots,m-1\\}} \\left| \\{ j \\in U \\,:\\, A_{ij} = 1 \\} \\right| .\n$$\nIf multiple proteins tie for the maximum, the algorithm breaks ties by choosing the smallest protein index. It then adds $i^\\star$ to the inferred set $S$, and removes from $U$ all peptides $j$ with $A_{i^\\star j} = 1$. The process repeats until $U = \\varnothing$. If at some step the maximum is $0$, the instance is invalid because the observed peptides cannot be covered; such instances must be discarded.\n\nWe say this greedy parsimony algorithm is completely broken on an instance $(m,n,A,T)$ if the inferred set $S$ has empty intersection with the true set $T$, that is,\n$$\nS \\cap T = \\varnothing .\n$$\nIntuitively, this means the algorithm infers only false proteins, achieving zero recall despite covering all observed peptides.\n\nYour task is to design a program that, given bounds and constraints, searches over all valid instances $(m,n,A,T)$ satisfying:\n- $1 \\le m \\le M$,\n- $1 \\le n \\le N$,\n- each column of $A$ has between $1$ and $r$ ones,\n- $T \\subset \\{0,1,\\dots,m-1\\}$ with $|T| \\ge t_{\\min}$ and $|T| < m$,\n- for every peptide index $j$, there is at least one true protein $i \\in T$ with $A_{ij} = 1$,\n\nand finds a completely broken instance if one exists. Among all completely broken instances within the bounds, you must return one with minimal size according to the following total order:\n1. Minimize $m + n$,\n2. subject to the first criterion, minimize $m$,\n3. subject to the first two, minimize $n$.\n\nIf no completely broken instance exists under the constraints, return the pair $(-1,-1)$.\n\nThe program must implement a correct, brute-force search that is guaranteed to find the minimal solution under the stated order within the provided bounds.\n\nStarting point and foundational principles: Model the problem using the well-tested formalization of peptide-to-protein mapping as a bipartite incidence matrix, and parsimony-based inference as a greedy set cover procedure. Use deterministic tie-breaking by smallest index for reproducibility. The concept of identifiability in the presence of shared peptides is foundational in protein inference and underlies why such counterexamples exist.\n\nTest Suite. Your program must compute results for the following parameter sets, each expressed as $(M, N, r, t_{\\min})$:\n- Test $1$: $(M, N, r, t_{\\min}) = (2, 2, 2, 1)$,\n- Test $2$: $(M, N, r, t_{\\min}) = (3, 2, 1, 1)$,\n- Test $3$: $(M, N, r, t_{\\min}) = (3, 3, 2, 2)$.\n\nFor each test, the required output is a pair $[m^\\star, n^\\star]$ where $m^\\star$ and $n^\\star$ are the minimal values found according to the ordering above, or $[-1,-1]$ if no completely broken instance exists within the bounds.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a two-element list, in the exact format: \"[[m1,n1],[m2,n2],[m3,n3]]\". No additional text should be printed. No physical units are involved, and there are no angles or percentages in this problem.", "solution": "The user has presented a problem in computational biology, specifically concerning the fallibility of parsimony-based protein inference methods. The task is to find a minimal counterexample where a greedy set cover algorithm completely fails to identify any true proteins. The problem is well-defined, scientifically grounded in the context of bioinformatics, and mathematically formalized, therefore it is valid. I will proceed to design a computational solution.\n\nThe problem requires a search for a \"completely broken\" instance $(m, n, A, T)$ of a protein inference problem. An instance is defined by the number of proteins $m$, the number of peptides $n$, a protein-peptide incidence matrix $A \\in \\{0,1\\}^{m \\times n}$, and a set of true proteins $T \\subset \\{0,1,\\dots,m-1\\}$. An instance is considered completely broken if the set of inferred proteins $S$, produced by a specified greedy algorithm, has an empty intersection with the true set $T$, i.e., $S \\cap T = \\varnothing$.\n\nOur objective is to find such an instance that is minimal according to a defined lexicographical order on $(m+n, m, n)$. This necessitates a systematic, brute-force search over the space of all valid instances within the given bounds $(M, N, r, t_{\\min})$.\n\nThe algorithmic design is structured as follows:\n\n1.  **Systematic Search over Dimensions**: The search for the minimal instance $(m^\\star, n^\\star)$ must follow the specified total order. This is achieved by iterating through the sum $s = m+n$ in increasing order, starting from $s=2$. For each fixed sum $s$, we iterate through possible values of $m$ starting from $1$. The value of $n$ is then determined as $n = s-m$. We only consider pairs $(m,n)$ that are within the specified bounds, i.e., $1 \\le m \\le M$ and $1 \\le n \\le N$. The first pair $(m,n)$ for which a completely broken instance is found is guaranteed to be the minimal one according to the specified ordering.\n\n2.  **Generation of Valid Instances**: For each pair of dimensions $(m,n)$, we must generate and test all possible valid instances $(A, T)$.\n    -   **True Protein Set `T`**: The set of true proteins $T$ is a subset of $\\{0, 1, \\dots, m-1\\}$ with size constrained by $|T| \\ge t_{\\min}$ and $|T| < m$. We can generate all such sets using combinatorial iterators.\n    -   **Incidence Matrix `A`**: The binary matrix $A \\in \\{0,1\\}^{m \\times n}$ is subject to two main constraints:\n        1.  The maximum degeneracy constraint: each column sum must be between $1$ and $r$ inclusive.\n        2.  The coverage constraint: every observed peptide must be explainable by at least one true protein. This means for each column $j$ of $A$, there must exist at least one row $i \\in T$ such that $A_{ij}=1$.\n        To generate all valid matrices $A$, we first construct a set of all possible valid column vectors. A column vector is valid if its sum of elements is between $1$ and $r$, and at least one of its '1' entries corresponds to a protein in $T$. Then, we generate all possible $m \\times n$ matrices by taking the Cartesian product of these valid columns, constructing each matrix by assembling $n$ such columns.\n\n3.  **Simulation of the Greedy Algorithm**: For each generated instance $(m, n, A, T)$, we must simulate the deterministic greedy set cover algorithm to compute the inferred protein set $S$.\n    -   Initialize the set of uncovered peptides $U=\\{0, 1, \\dots, n-1\\}$ and the inferred protein set $S=\\varnothing$.\n    -   In each step, while $U$ is not empty, select the protein $i^\\star$ that covers the maximum number of peptides currently in $U$. This is calculated as $i^\\star \\in \\arg\\max_{i} |\\{ j \\in U : A_{ij}=1 \\}|$.\n    -   Ties are broken by choosing the smallest protein index $i$.\n    -   Add $i^\\star$ to $S$ and remove all peptides covered by $i^\\star$ from $U$.\n    -   The process terminates when $U$ becomes empty.\n\n4.  **Verification and Termination**: After computing the set $S$ for an instance, we check the \"completely broken\" condition: $S \\cap T = \\varnothing$.\n    -   If the condition holds, we have found a counterexample. Because our search over $(m,n)$ is ordered by the minimality criteria, this first finding represents the minimal solution $(m^\\star,n^\\star)$. The search terminates, and this pair is returned.\n    -   If the loops complete without finding any such instance, it means no completely broken instance exists within the given bounds $(M, N, r, t_{\\min})$. In this case, the pair $(-1,-1)$ is returned.\n\nThis brute-force approach guarantees correctness by exhaustively exploring the entire valid search space in the prescribed order of minimality. The implementation uses `numpy` for efficient matrix operations during the greedy algorithm simulation and `itertools` for generating combinations and products required for building the instances.", "answer": "```python\nimport numpy as np\nimport scipy  # Imported to adhere to problem specification, though not directly used.\nfrom itertools import combinations, product\n\ndef run_greedy_algorithm(m, n, A):\n    \"\"\"\n    Simulates the greedy set cover algorithm for protein inference.\n\n    Args:\n        m (int): Number of proteins.\n        n (int): Number of peptides.\n        A (np.ndarray): The m x n incidence matrix.\n\n    Returns:\n        set: The set of inferred protein indices S, or None if an error occurs.\n    \"\"\"\n    U_mask = np.ones(n, dtype=bool)\n    num_uncovered = n\n    S = set()\n\n    while num_uncovered > 0:\n        # Calculate scores for all proteins based on current uncovered peptides\n        if num_uncovered < n:\n            scores = A[:, U_mask].sum(axis=1)\n        else: # First iteration, no need to slice A\n            scores = A.sum(axis=1)\n\n        if np.max(scores) == 0:\n            # This should not happen with the problem's constraints (all peptides are coverable)\n            # and our instance generation method. It implies some uncovered peptides cannot be covered.\n            return None\n\n        # np.argmax breaks ties by returning the first index of the maximum value.\n        best_protein = np.argmax(scores)\n        S.add(best_protein)\n\n        # Update the set of uncovered peptides.\n        peptides_covered_by_best = (A[best_protein, :] == 1)\n        newly_covered_mask = U_mask & peptides_covered_by_best\n        \n        num_uncovered -= np.sum(newly_covered_mask)\n        U_mask[newly_covered_mask] = False\n\n    return S\n\ndef find_minimal_broken_instance(M, N, r, t_min):\n    \"\"\"\n    Performs a brute-force search for the minimal completely broken instance.\n    \"\"\"\n    # Iterate through dimensions (m, n) based on the specified total order.\n    # 1. Minimize m+n, 2. Minimize m, 3. Minimize n.\n    for s in range(2, M + N + 1):  # s = m + n\n        for m in range(1, s):\n            n = s - m\n            if not (1 <= m <= M and 1 <= n <= N):\n                continue\n\n            # Iterate over all possible true protein sets T\n            for t_size in range(t_min, m):\n                for T_tuple in combinations(range(m), t_size):\n                    T_set = set(T_tuple)\n                    \n                    # Generate all valid single-column vectors for matrix A\n                    valid_cols = []\n                    all_protein_indices = range(m)\n                    for num_connections in range(1, r + 1):\n                        for p_indices in combinations(all_protein_indices, num_connections):\n                            # A column is valid if it has a non-empty intersection with T\n                            if T_set.intersection(p_indices):\n                                col = np.zeros(m, dtype=np.int8)\n                                col[list(p_indices)] = 1\n                                valid_cols.append(col)\n                    \n                    if not valid_cols:\n                        continue\n\n                    # Generate all valid matrices A using the Cartesian product of valid columns\n                    for A_cols_tuple in product(valid_cols, repeat=n):\n                        A = np.column_stack(A_cols_tuple)\n                        \n                        # Simulate the greedy algorithm to get the inferred set S\n                        S = run_greedy_algorithm(m, n, A)\n                        \n                        # Check for the \"completely broken\" condition\n                        if S is not None and not S.intersection(T_set):\n                            # Found a minimal broken instance\n                            return [m, n]\n                            \n    # No broken instance found within the bounds\n    return [-1, -1]\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for the specified test cases.\n    \"\"\"\n    test_cases = [\n        (2, 2, 2, 1),\n        (3, 2, 1, 1),\n        (3, 3, 2, 2),\n    ]\n\n    results = []\n    for M, N, r, t_min in test_cases:\n        result = find_minimal_broken_instance(M, N, r, t_min)\n        results.append(result)\n\n    # Format the output string exactly as specified.\n    output_str = '[' + ','.join([f'[{r[0]},{r[1]}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2420457"}, {"introduction": "After acknowledging the limitations of simple heuristics, we turn to a more principled way of handling evidence: probabilistic modeling. Not all peptide identifications are equally certain, and a robust inference method must weigh evidence according to its credibility. This practice will guide you in deriving a protein-level score from first principles using Bayes factors, teaching you how to properly aggregate evidence from multiple unique peptides, each with its own Posterior Error Probability ($PEP$), into a single, coherent belief score [@problem_id:2420470].", "problem": "In bottom-up proteomics, protein-level inference is performed from peptide-spectrum match (PSM) evidence. Consider two competing protein-level hypotheses for a given protein $P$: $H_1$ (protein present) and $H_0$ (protein absent). For each unique peptide $i$ assigned to $P$, suppose you are given its peptide-level Posterior Error Probability (PEP), denoted $p_i$, where $p_i$ is the posterior probability that the reported PSM is incorrect given the spectral data. Define $r_i = 1 - p_i$ as the posterior probability that the PSM is correct. Assume:\n- $($i$)$ conditional independence of peptide identifications given $H_1$ or $H_0$ across unique peptides;\n- $($ii$)$ a neutral pre-experimental prior at the peptide level with equal prior odds that a reported PSM is correct or incorrect;\n- $($iii$)$ under $H_1$, the observed peptide evidence arises via correct identifications, whereas under $H_0$ it arises via incorrect identifications.\n\nUsing only these assumptions and first principles, define a protein-level score $S(P)$ that balances the number of unique peptide witnesses and their credibility by aggregating peptide evidence as the natural logarithm of the Bayes factor in favor of $H_1$ over $H_0$, expressed in closed form in terms of the set of PEPs $\\{p_i\\}$ for the unique peptides of $P$.\n\nYou are given two proteins:\n- Protein $P_1$ has $5$ unique peptides with PEPs $p_i \\in \\{0.20, 0.25, 0.15, 0.30, 0.18\\}$.\n- Protein $P_2$ has $1$ unique peptide with PEP $0.001$.\n\nCompute the single numeric quantity $S(P_1) - S(P_2)$ using your derived expression. Round your final result to four significant figures. The score is dimensionless; do not include any unit in your answer.", "solution": "The problem statement will first be subjected to rigorous validation.\n\n### Step 1: Extract Givens\n- Competing hypotheses for a protein $P$: $H_1$ (protein present) and $H_0$ (protein absent).\n- For each unique peptide $i$ of $P$, a Posterior Error Probability (PEP) is given: $p_i = P(\\text{PSM is incorrect} | \\text{Data}_i)$.\n- The posterior probability that a Peptide-Spectrum Match (PSM) is correct is $r_i = 1 - p_i$.\n- Assumption (i): Conditional independence of peptide identifications given $H_1$ or $H_0$ across unique peptides.\n- Assumption (ii): Neutral pre-experimental prior at the peptide level with equal prior odds that a reported PSM is correct or incorrect.\n- Assumption (iii): Under $H_1$, the observed peptide evidence arises via correct identifications. Under $H_0$, it arises via incorrect identifications.\n- The protein-level score to be defined is $S(P) = \\ln(K)$, where $K$ is the Bayes factor in favor of $H_1$ over $H_0$, $K = \\frac{P(\\text{Data} | H_1)}{P(\\text{Data} | H_0)}$.\n- Data for protein $P_1$: $5$ unique peptides with PEPs $\\{0.20, 0.25, 0.15, 0.30, 0.18\\}$.\n- Data for protein $P_2$: $1$ unique peptide with PEP $0.001$.\n- Required output: The numeric value of $S(P_1) - S(P_2)$, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded in the field of computational proteomics, dealing with standard concepts such as protein inference, peptide evidence, Posterior Error Probabilities, and Bayes factors. The assumptions provided, while representing a simplified model, are explicit and sufficient for deriving a well-defined mathematical expression. The problem is objective, precisely stated, and does not contain contradictions, factual errors, or pseudoscientific claims. It is a well-posed problem that can be formalized and solved using principles of probability theory.\n\n### Step 3: Verdict and Action\nThe problem is deemed valid. A complete solution will now be provided.\n\nThe objective is to derive an expression for the protein-level score $S(P)$ and then use it to compute $S(P_1) - S(P_2)$. The score is defined as the natural logarithm of the Bayes factor $K$ for hypothesis $H_1$ over $H_0$.\n\nLet $\\text{Data}$ represent the complete set of peptide evidence for protein $P$. This evidence consists of observations for each unique peptide $i$, denoted $\\text{Data}_i$. The Bayes factor is given by:\n$$\nK = \\frac{P(\\text{Data} | H_1)}{P(\\text{Data} | H_0)}\n$$\nUsing assumption (i), the conditional independence of peptide identifications allows us to write the total likelihood as the product of individual peptide likelihoods:\n$$\nP(\\text{Data} | H) = \\prod_{i} P(\\text{Data}_i | H) \\quad \\text{for } H \\in \\{H_0, H_1\\}\n$$\nThe Bayes factor thus becomes a product of peptide-level Bayes factors, $K_i$:\n$$\nK = \\frac{\\prod_{i} P(\\text{Data}_i | H_1)}{\\prod_{i} P(\\text{Data}_i | H_0)} = \\prod_{i} \\left( \\frac{P(\\text{Data}_i | H_1)}{P(\\text{Data}_i | H_0)} \\right) = \\prod_{i} K_i\n$$\nThe protein score $S(P)$ is the natural logarithm of $K$:\n$$\nS(P) = \\ln(K) = \\ln\\left(\\prod_{i} K_i\\right) = \\sum_{i} \\ln(K_i) = \\sum_{i} \\ln\\left(\\frac{P(\\text{Data}_i | H_1)}{P(\\text{Data}_i | H_0)}\\right)\n$$\nTo proceed, we must express the peptide-level likelihood ratio $\\frac{P(\\text{Data}_i | H_1)}{P(\\text{Data}_i | H_0)}$ in terms of the given PEP, $p_i$. Let $C_i$ be the event that the PSM for peptide $i$ is correct, and $I_i$ be the event that it is incorrect. The given PEP is the posterior probability $p_i = P(I_i | \\text{Data}_i)$. Consequently, $1 - p_i = P(C_i | \\text{Data}_i)$.\n\nBy Bayes' theorem, the ratio of these posterior probabilities is:\n$$\n\\frac{P(I_i | \\text{Data}_i)}{P(C_i | \\text{Data}_i)} = \\frac{p_i}{1 - p_i} = \\frac{P(\\text{Data}_i | I_i) P(I_i)}{P(\\text{Data}_i | C_i) P(C_i)}\n$$\nThis can be written as: Posterior Odds = Likelihood Ratio $\\times$ Prior Odds.\n$$\n\\frac{p_i}{1 - p_i} = \\left(\\frac{P(\\text{Data}_i | I_i)}{P(\\text{Data}_i | C_i)}\\right) \\left(\\frac{P(I_i)}{P(C_i)}\\right)\n$$\nAssumption (ii) states a neutral prior, meaning $P(C_i) = P(I_i) = 0.5$. Thus, the prior odds are $\\frac{P(I_i)}{P(C_i)} = 1$. This simplifies the relationship to:\n$$\n\\frac{p_i}{1 - p_i} = \\frac{P(\\text{Data}_i | I_i)}{P(\\text{Data}_i | C_i)}\n$$\nNow, we incorporate assumption (iii). This assumption provides the crucial link between the protein-level hypotheses ($H_1, H_0$) and the peptide-level correctness events ($C_i, I_i$).\n- Under $H_1$ (protein present), peptide evidence arises from correct identifications. We interpret this to mean $P(\\text{Data}_i | H_1) = P(\\text{Data}_i | C_i)$.\n- Under $H_0$ (protein absent), peptide evidence arises from incorrect identifications. We interpret this to mean $P(\\text{Data}_i | H_0) = P(\\text{Data}_i | I_i)$.\n\nSubstituting these into our expression for the peptide-level Bayes factor $K_i$:\n$$\nK_i = \\frac{P(\\text{Data}_i | H_1)}{P(\\text{Data}_i | H_0)} = \\frac{P(\\text{Data}_i | C_i)}{P(\\text{Data}_i | I_i)}\n$$\nFrom our previous derivation, we have $\\frac{P(\\text{Data}_i | I_i)}{P(\\text{Data}_i | C_i)} = \\frac{p_i}{1 - p_i}$. Therefore:\n$$\nK_i = \\frac{P(\\text{Data}_i | C_i)}{P(\\text{Data}_i | I_i)} = \\left(\\frac{p_i}{1 - p_i}\\right)^{-1} = \\frac{1 - p_i}{p_i}\n$$\nThe protein score $S(P)$ can now be expressed in its final closed form in terms of the set of PEPs $\\{p_i\\}$:\n$$\nS(P) = \\sum_{i} \\ln\\left(\\frac{1 - p_i}{p_i}\\right)\n$$\nWe now compute the scores for proteins $P_1$ and $P_2$.\n\nFor protein $P_1$, with PEPs $\\{0.20, 0.25, 0.15, 0.30, 0.18\\}$:\n$$\nS(P_1) = \\ln\\left(\\frac{1-0.20}{0.20}\\right) + \\ln\\left(\\frac{1-0.25}{0.25}\\right) + \\ln\\left(\\frac{1-0.15}{0.15}\\right) + \\ln\\left(\\frac{1-0.30}{0.30}\\right) + \\ln\\left(\\frac{1-0.18}{0.18}\\right)\n$$\n$$\nS(P_1) = \\ln\\left(\\frac{0.80}{0.20}\\right) + \\ln\\left(\\frac{0.75}{0.25}\\right) + \\ln\\left(\\frac{0.85}{0.15}\\right) + \\ln\\left(\\frac{0.70}{0.30}\\right) + \\ln\\left(\\frac{0.82}{0.18}\\right)\n$$\n$$\nS(P_1) = \\ln(4) + \\ln(3) + \\ln\\left(\\frac{17}{3}\\right) + \\ln\\left(\\frac{7}{3}\\right) + \\ln\\left(\\frac{41}{9}\\right)\n$$\nUsing the property $\\ln(a) + \\ln(b) = \\ln(ab)$:\n$$\nS(P_1) = \\ln\\left(4 \\times 3 \\times \\frac{17}{3} \\times \\frac{7}{3} \\times \\frac{41}{9}\\right) = \\ln\\left(\\frac{19516}{27}\\right)\n$$\nNumerically, $S(P_1) \\approx \\ln(722.8148) \\approx 6.583122$.\n\nFor protein $P_2$, with one peptide having PEP $p = 0.001$:\n$$\nS(P_2) = \\ln\\left(\\frac{1-0.001}{0.001}\\right) = \\ln\\left(\\frac{0.999}{0.001}\\right) = \\ln(999)\n$$\nNumerically, $S(P_2) \\approx 6.906755$.\n\nFinally, we compute the difference $S(P_1) - S(P_2)$:\n$$\nS(P_1) - S(P_2) = \\ln\\left(\\frac{19516}{27}\\right) - \\ln(999) = \\ln\\left(\\frac{19516}{27 \\times 999}\\right) = \\ln\\left(\\frac{19516}{26973}\\right)\n$$\n$$\nS(P_1) - S(P_2) \\approx \\ln(0.7235383) \\approx -0.323633\n$$\nRounding the result to four significant figures gives $-0.3236$.", "answer": "$$\n\\boxed{-0.3236}\n$$", "id": "2420470"}]}