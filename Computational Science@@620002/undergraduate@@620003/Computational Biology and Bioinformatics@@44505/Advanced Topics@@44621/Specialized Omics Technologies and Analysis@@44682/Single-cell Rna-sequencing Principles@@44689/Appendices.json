{"hands_on_practices": [{"introduction": "A primary goal of single-cell analysis is to uncover the biological identity of cell populations identified through clustering. This is accomplished by finding marker genes, whose expression patterns are unique to a specific cluster. This exercise will guide you through the use of a powerful statistical metric, the Area Under the Receiver Operating Characteristic curve (AUROC), to systematically evaluate and rank genes based on their ability to distinguish cells in a target cluster from all others [@problem_id:2429791]. Mastering this technique is fundamental for moving from abstract clusters to meaningful biological insights about cell types and states.", "problem": "You are given expression measurements from single-cell RNA-sequencing (scRNA-seq) for multiple genes across individual cells and a binary indicator of cluster membership for each cell. Treat each gene’s expression across cells as a numerical score used to distinguish the target cluster from all other cells. Use the Area Under the Receiver Operating Characteristic (ROC) Curve (AUROC) to evaluate how well each gene’s expression separates the target cluster from the rest. The Receiver Operating Characteristic (ROC) is defined in terms of the true positive rate and false positive rate as the discrimination threshold varies over all possible score values. The Area Under the ROC Curve (AUROC) is the probability that a uniformly drawn score from the positive class exceeds a uniformly drawn score from the negative class, with ties contributing one half. Formally, for a given gene with scores $s_i$ on cells $i \\in \\{1,\\dots,N\\}$ and binary labels $y_i \\in \\{0,1\\}$ indicating cluster membership, define\n$$\n\\mathrm{AUROC} \\;=\\; \\frac{1}{n_1\\, n_0}\\sum_{\\substack{i:\\, y_i=1}}\\sum_{\\substack{j:\\, y_j=0}}\\left(\\mathbf{1}\\{s_i > s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\}\\right),\n$$\nwhere $n_1 = \\sum_i y_i$ is the number of positive (in-cluster) cells, $n_0 = N - n_1$ is the number of negative (out-of-cluster) cells, and $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n\nFor each test case below, you are given:\n- a binary cluster label vector $y \\in \\{0,1\\}^N$ with both classes present (i.e., $0 < \\sum_i y_i < N$), and\n- a gene-by-cell score matrix $X \\in \\mathbb{R}^{N \\times G}$, where column $g$ contains the scores $s_i$ for gene index $g$ across all $N$ cells.\n\nYour task for each test case is to:\n1. Compute the AUROC for each gene $g \\in \\{0,\\dots,G-1\\}$ according to the definition above. Round each AUROC to $6$ decimal places in your final reported numbers.\n2. Produce a ranking of gene indices by descending AUROC. In the event of an exact AUROC tie between two or more genes, break ties by ascending gene index (i.e., the smaller index appears earlier).\n\nTest Suite:\n- Test case $1$:\n  - $y = [\\,1,1,1,0,0,0,0,0\\,]$.\n  - $X$ has $N=8$ rows (cells) and $G=5$ columns (genes), where each row lists scores for $[g_0,g_1,g_2,g_3,g_4]$ in that order:\n    - Row $0$: $[\\,6,1,0,2,3\\,]$\n    - Row $1$: $[\\,4,0,1,2,1\\,]$\n    - Row $2$: $[\\,5,1,0,2,2\\,]$\n    - Row $3$: $[\\,2,1,3,2,2\\,]$\n    - Row $4$: $[\\,1,0,2,2,1\\,]$\n    - Row $5$: $[\\,0,1,4,2,2\\,]$\n    - Row $6$: $[\\,1,0,1,2,0\\,]$\n    - Row $7$: $[\\,2,1,2,2,3\\,]$\n- Test case $2$:\n  - $y = [\\,0,0,1,0\\,]$.\n  - $X$ has $N=4$ rows and $G=4$ columns with rows as $[g_0,g_1,g_2,g_3]$:\n    - Row $0$: $[\\,1,5,3,2\\,]$\n    - Row $1$: $[\\,2,4,3,5\\,]$\n    - Row $2$: $[\\,5,1,3,5\\,]$\n    - Row $3$: $[\\,2,4,3,5\\,]$\n- Test case $3$:\n  - $y = [\\,1,1,1,1,1,0,0\\,]$.\n  - $X$ has $N=7$ rows and $G=3$ columns with rows as $[g_0,g_1,g_2]$:\n    - Row $0$: $[\\,3,0,0\\,]$\n    - Row $1$: $[\\,0,1,2\\,]$\n    - Row $2$: $[\\,2,0,0\\,]$\n    - Row $3$: $[\\,0,0,1\\,]$\n    - Row $4$: $[\\,1,1,1\\,]$\n    - Row $5$: $[\\,0,3,1\\,]$\n    - Row $6$: $[\\,0,2,0\\,]$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a list. For each test case, output a two-element list: the first element is the list of AUROCs for genes $[0,1,\\dots,G-1]$ rounded to $6$ decimals, and the second element is the list of ranked gene indices as specified above. The overall output should thus be a single line representing a list of three elements (corresponding to the three test cases), where each element is itself a two-element list. The elements must be aggregated into a single line of text, enclosed in square brackets. For example, the shape should be similar to $[\\,[\\,[\\dots],[\\dots]\\,],\\,[\\,[\\dots],[\\dots]\\,],\\,[\\,[\\dots],[\\dots]\\,]\\,]$. There are no physical units or angles in this problem. All numeric outputs must be real numbers or integers as required by the context, with AUROC values reported as decimals rounded to $6$ places.", "solution": "The problem presented is valid. It is scientifically grounded in the principles of bioinformatics and statistics, specifically concerning the analysis of single-cell RNA-sequencing (scRNA-seq) data. The task is to evaluate and rank genes based on their utility as markers for a specified cell cluster. The metric for this evaluation is the Area Under the Receiver Operating Characteristic curve (AUROC), a standard non-parametric measure of a scoring system's ability to distinguish between two classes. The problem provides a precise mathematical definition for the AUROC, all necessary input data ($y$, the cluster labels, and $X$, the gene expression matrix), and unambiguous instructions for the desired output, including tie-breaking rules. The problem is well-posed, with no missing information, contradictions, or ambiguities.\n\nThe core of the problem is the computation of the AUROC for each gene, which serves as a score for its discriminatory power. The provided formula is:\n$$\n\\mathrm{AUROC} \\;=\\; \\frac{1}{n_1\\, n_0}\\sum_{\\substack{i:\\, y_i=1}}\\sum_{\\substack{j:\\, y_j=0}}\\left(\\mathbf{1}\\{s_i > s_j\\} \\;+\\; \\tfrac{1}{2}\\,\\mathbf{1}\\{s_i = s_j\\}\\right)\n$$\nwhere $s_i$ are the expression scores for a given gene across all $N$ cells, and $y_i$ is the binary label indicating membership in the target cluster ($y_i=1$) versus all other cells ($y_i=0$). The terms $n_1$ and $n_0$ represent the number of cells in the target cluster and outside of it, respectively. This formula corresponds to the probability that a randomly selected cell from the positive class (the cluster) has a higher gene expression score than a randomly selected cell from the negative class (outside the cluster), with ties contributing a value of $\\frac{1}{2}$.\n\nThe solution procedure is as follows:\n1.  For each test case, we are provided with a label vector $y$ and a score matrix $X$.\n2.  We iterate through each gene $g$, which corresponds to a column in the matrix $X$. Let this column of scores be the vector $s$.\n3.  Using the label vector $y$, we partition the scores in $s$ into two sets: $S_1 = \\{s_i \\mid y_i=1\\}$, the set of scores for cells within the target cluster, and $S_0 = \\{s_j \\mid y_j=0\\}$, the set of scores for cells outside the cluster. Let their respective sizes be $n_1 = |S_1|$ and $n_0 = |S_0|$. The problem guarantees that both $n_1 > 0$ and $n_0 > 0$.\n4.  We then compute the numerator of the AUROC formula, which is the sum of pairwise comparisons. For every score $s_i \\in S_1$, we compare it with every score $s_j \\in S_0$.\n    -   If $s_i > s_j$, we add $1$ to a running sum.\n    -   If $s_i = s_j$, we add $0.5$ to the running sum.\n    -   If $s_i < s_j$, we add $0$.\n5.  After all pairs have been compared, the total sum is divided by the total number of pairs, which is the product $n_1 n_0$. This gives the AUROC for gene $g$.\n6.  This process is repeated for all $G$ genes, resulting in a list of $G$ AUROC values. Each value is rounded to $6$ decimal places as specified.\n7.  Finally, we must rank the genes. The primary ranking criterion is the AUROC value, in descending order. A higher AUROC indicates better separation, so genes with higher values are ranked first. The secondary criterion is for tie-breaking: if two or more genes have the exact same AUROC value, the gene with the smaller index is ranked higher. We implement this by sorting the gene indices based on a key that combines the negative AUROC (for descending order) and the gene index (for ascending order).\n\nThis procedure is applied to each of the test cases provided. The results are then aggregated into the specified nested list structure for the final output. The implementation will leverage the `numpy` library for efficient vectorized operations, particularly for the pairwise comparisons, which can be accomplished through broadcasting.\n\nFor example, for a given gene, if `s_pos` is the array of scores from the positive class and `s_neg` is the array from the negative class, the total score can be computed efficiently. By reshaping `s_pos` to a column vector of shape ($n_1$, $1$) and leaving `s_neg` as a row vector of shape ($1$, $n_0$), `numpy`'s broadcasting rules will create an $n_1 \\times n_0$ matrix of pairwise comparisons. The sum for scores where the positive is greater than the negative is `np.sum(s_pos[:, np.newaxis] > s_neg)`, and the sum for ties is `np.sum(s_pos[:, np.newaxis] == s_neg)`. This avoids explicit, and slower, nested loops in Python.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the AUROC gene ranking problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"y\": np.array([1, 1, 1, 0, 0, 0, 0, 0]),\n            \"X\": np.array([\n                [6, 1, 0, 2, 3],\n                [4, 0, 1, 2, 1],\n                [5, 1, 0, 2, 2],\n                [2, 1, 3, 2, 2],\n                [1, 0, 2, 2, 1],\n                [0, 1, 4, 2, 2],\n                [1, 0, 1, 2, 0],\n                [2, 1, 2, 2, 3],\n            ])\n        },\n        {\n            \"y\": np.array([0, 0, 1, 0]),\n            \"X\": np.array([\n                [1, 5, 3, 2],\n                [2, 4, 3, 5],\n                [5, 1, 3, 5],\n                [2, 4, 3, 5],\n            ])\n        },\n        {\n            \"y\": np.array([1, 1, 1, 1, 1, 0, 0]),\n            \"X\": np.array([\n                [3, 0, 0],\n                [0, 1, 2],\n                [2, 0, 0],\n                [0, 0, 1],\n                [1, 1, 1],\n                [0, 3, 1],\n                [0, 2, 0],\n            ])\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        y = case[\"y\"]\n        X = case[\"X\"]\n        \n        N, G = X.shape\n        \n        y_bool = y.astype(bool)\n        s_pos_all = X[y_bool, :]\n        s_neg_all = X[~y_bool, :]\n        \n        n1 = s_pos_all.shape[0]\n        n0 = s_neg_all.shape[0]\n        \n        if n1 == 0 or n0 == 0:\n            continue\n            \n        aurocs = []\n        for g in range(G):\n            s_pos = s_pos_all[:, g]\n            s_neg = s_neg_all[:, g]\n            \n            # Using broadcasting for efficient pairwise comparison\n            gt_sum = np.sum(s_pos[:, np.newaxis] > s_neg)\n            eq_sum = np.sum(s_pos[:, np.newaxis] == s_neg)\n            \n            comparison_sum = gt_sum + 0.5 * eq_sum\n            auroc = comparison_sum / (n1 * n0)\n            aurocs.append(auroc)\n            \n        rounded_aurocs = [round(a, 6) for a in aurocs]\n        \n        # Rank genes: descending AUROC, ascending gene index for ties\n        gene_indices = list(range(G))\n        ranked_indices = sorted(gene_indices, key=lambda i: (-rounded_aurocs[i], i))\n        \n        all_results.append([rounded_aurocs, ranked_indices])\n\n    # Format output to a compact, single-line string representation of the list\n    # with no spaces.\n    final_output_str = str(all_results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2429791"}, {"introduction": "Real-world single-cell data is affected by various technical artifacts that can confound biological interpretation. One of the most common is a \"doublet,\" which occurs when a single droplet encapsulates two cells, artificially merging their transcriptomes. This practice provides a hands-on simulation of this process, allowing you to create a synthetic doublet by combining the UMI counts of two distinct cell types and observe its confusing effect on cluster assignment [@problem_id:2429816]. This exercise illuminates why identifying and removing doublets is a critical quality control step in any scRNA-seq workflow.", "problem": "You are given two reference groups of single-cell RNA-sequencing (scRNA-seq) profiles, each represented by Unique Molecular Identifier (UMI) count vectors over a shared gene set. Treat each cell as a vector in $\\mathbb{R}_{\\ge 0}^{G}$ of raw UMI counts, where $G$ is the number of genes. The following reference cells are provided, with $G=5$ genes and counts in the fixed gene order. Group $\\mathcal{A}$ (type $\\mathcal{A}$) has two cells with raw UMI count vectors\n$$\n\\mathbf{A}_1=\\left[80,60,5,3,20\\right],\\quad\n\\mathbf{A}_2=\\left[90,55,7,2,22\\right],\n$$\nand Group $\\mathcal{B}$ (type $\\mathcal{B}$) has two cells with raw UMI count vectors\n$$\n\\mathbf{B}_1=\\left[4,3,70,65,18\\right],\\quad\n\\mathbf{B}_2=\\left[5,2,75,60,20\\right].\n$$\n\nDefine the following operations and quantities.\n\n1. Library-size normalization and transformation. For any raw count vector $\\mathbf{c}\\in\\mathbb{R}_{\\ge 0}^{G}$ with total count $s(\\mathbf{c})=\\sum_{g=1}^{G} c_g$, define the normalized vector at scale $L=10^4$ by\n$$\n\\mathbf{n}(\\mathbf{c}) = L \\cdot \\frac{\\mathbf{c}}{s(\\mathbf{c})},\n$$\nfollowed by a pointwise transformed vector\n$$\n\\mathbf{t}(\\mathbf{c}) = \\log\\!\\left(\\mathbf{1}+\\mathbf{n}(\\mathbf{c})\\right),\n$$\nwhere $\\log(\\cdot)$ is the natural logarithm and $\\mathbf{1}$ denotes the all-ones vector in $\\mathbb{R}^{G}$.\n\n2. Type centroids. Compute the type centroids in the transformed space as the componentwise arithmetic means\n$$\n\\boldsymbol{\\mu}_{\\mathcal{A}}=\\frac{1}{2}\\left(\\mathbf{t}(\\mathbf{A}_1)+\\mathbf{t}(\\mathbf{A}_2)\\right),\\quad\n\\boldsymbol{\\mu}_{\\mathcal{B}}=\\frac{1}{2}\\left(\\mathbf{t}(\\mathbf{B}_1)+\\mathbf{t}(\\mathbf{B}_2)\\right).\n$$\n\n3. Squared Euclidean distances. For any transformed vector $\\mathbf{x}\\in\\mathbb{R}^{G}$, define\n$$\nd_{\\mathcal{A}}(\\mathbf{x}) = \\left\\|\\mathbf{x}-\\boldsymbol{\\mu}_{\\mathcal{A}}\\right\\|_2^2=\\sum_{g=1}^{G}\\left(x_g-(\\mu_{\\mathcal{A}})_g\\right)^2,\\quad\nd_{\\mathcal{B}}(\\mathbf{x}) = \\left\\|\\mathbf{x}-\\boldsymbol{\\mu}_{\\mathcal{B}}\\right\\|_2^2=\\sum_{g=1}^{G}\\left(x_g-(\\mu_{\\mathcal{B}})_g\\right)^2.\n$$\n\n4. Cluster assignment rule. For any $\\mathbf{x}$, define the assignment label $L(\\mathbf{x})\\in\\{-1,0,1\\}$ by\n$$\nL(\\mathbf{x})=\n\\begin{cases}\n0 & \\text{if } d_{\\mathcal{A}}(\\mathbf{x})< d_{\\mathcal{B}}(\\mathbf{x}),\\\\\n1 & \\text{if } d_{\\mathcal{B}}(\\mathbf{x})< d_{\\mathcal{A}}(\\mathbf{x}),\\\\\n-1 & \\text{if } d_{\\mathcal{A}}(\\mathbf{x})= d_{\\mathcal{B}}(\\mathbf{x}).\n\\end{cases}\n$$\n\n5. Synthetic merge (doublet). Let the four reference cells be indexed as $\\mathbf{C}_1=\\mathbf{A}_1$, $\\mathbf{C}_2=\\mathbf{A}_2$, $\\mathbf{C}_3=\\mathbf{B}_1$, $\\mathbf{C}_4=\\mathbf{B}_2$. For indices $i,j\\in\\{1,2,3,4\\}$ and nonnegative integers $\\alpha,\\beta$, define a synthetic merged raw count vector\n$$\n\\mathbf{M}(i,j,\\alpha,\\beta)=\\alpha\\,\\mathbf{C}_i+\\beta\\,\\mathbf{C}_j.\n$$\nApply the same normalization and transformation to obtain $\\mathbf{t}\\!\\left(\\mathbf{M}(i,j,\\alpha,\\beta)\\right)$.\n\n6. Impact metrics. For the transformed merged vector $\\mathbf{x}=\\mathbf{t}\\!\\left(\\mathbf{M}(i,j,\\alpha,\\beta)\\right)$, define the signed distance difference\n$$\n\\Delta(\\mathbf{x})= d_{\\mathcal{B}}(\\mathbf{x})-d_{\\mathcal{A}}(\\mathbf{x}),\n$$\nand the ambiguity coefficient\n$$\n\\Gamma(\\mathbf{x})=\\frac{\\left|d_{\\mathcal{A}}(\\mathbf{x})-d_{\\mathcal{B}}(\\mathbf{x})\\right|}{d_{\\mathcal{A}}(\\mathbf{x})+d_{\\mathcal{B}}(\\mathbf{x})}.\n$$\n\nYour task is to implement a program that, using the definitions above, computes for each specified test case the triple\n$$\n\\left[L\\!\\left(\\mathbf{t}\\!\\left(\\mathbf{M}(i,j,\\alpha,\\beta)\\right)\\right),\\ \\Delta\\!\\left(\\mathbf{t}\\!\\left(\\mathbf{M}(i,j,\\alpha,\\beta)\\right)\\right),\\ \\Gamma\\!\\left(\\mathbf{t}\\!\\left(\\mathbf{M}(i,j,\\alpha,\\beta)\\right)\\right)\\right].\n$$\n\nTest suite (each test case is a tuple $(i,j,\\alpha,\\beta)$):\n- Case $1$: $(1,3,1,1)$,\n- Case $2$: $(1,2,1,1)$,\n- Case $3$: $(3,4,1,1)$,\n- Case $4$: $(1,3,3,1)$,\n- Case $5$: $(2,4,1,0)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each test case result itself formatted as a bracketed list with no spaces. For example, the overall structure must be\n$$\n\\left[\\,[\\ell_1,\\delta_1,\\gamma_1],\\,[\\ell_2,\\delta_2,\\gamma_2],\\,\\dots\\,\\right],\n$$\nwhere $\\ell_k$ is an integer, and $\\delta_k,\\gamma_k$ are real numbers. No additional text should be printed.", "solution": "The task models a fundamental aspect of single-cell RNA-sequencing (scRNA-seq): how Unique Molecular Identifier (UMI) count profiles from distinct cell types combine to form a synthetic doublet and how this affects type-based clustering in a normalized expression space. The solution proceeds from definitions that map directly onto steps in the program.\n\nFirst, we interpret a cell profile as a nonnegative vector $\\mathbf{c}\\in\\mathbb{R}_{\\ge 0}^{G}$. The sum $s(\\mathbf{c})=\\sum_{g=1}^{G}c_g$ represents the library size, which in scRNA-seq captures overall sequencing depth and capture efficiency. To compare cells fairly despite differing depths, we perform library-size normalization to a common scale $L=10^4$ and then stabilize the variance with a $\\log(1+\\cdot)$ transform. Concretely, define\n$$\n\\mathbf{n}(\\mathbf{c})=L\\cdot\\frac{\\mathbf{c}}{s(\\mathbf{c})},\\quad \\mathbf{t}(\\mathbf{c})=\\log\\!\\left(\\mathbf{1}+\\mathbf{n}(\\mathbf{c})\\right).\n$$\nThis transformation is applied to each reference cell to obtain a transformed dataset.\n\nSecond, type representations are summarized by centroids in the transformed space, computed as the arithmetic means:\n$$\n\\boldsymbol{\\mu}_{\\mathcal{A}}=\\frac{1}{2}\\left(\\mathbf{t}(\\mathbf{A}_1)+\\mathbf{t}(\\mathbf{A}_2)\\right),\\quad\n\\boldsymbol{\\mu}_{\\mathcal{B}}=\\frac{1}{2}\\left(\\mathbf{t}(\\mathbf{B}_1)+\\mathbf{t}(\\mathbf{B}_2)\\right).\n$$\nThese centroids represent average expression patterns for each type after controlling for depth.\n\nThird, clustering of any transformed cell $\\mathbf{x}$ relative to types $\\mathcal{A}$ and $\\mathcal{B}$ is assessed by squared Euclidean distance:\n$$\nd_{\\mathcal{A}}(\\mathbf{x})=\\sum_{g=1}^{G}\\left(x_g-(\\mu_{\\mathcal{A}})_g\\right)^2,\\quad\nd_{\\mathcal{B}}(\\mathbf{x})=\\sum_{g=1}^{G}\\left(x_g-(\\mu_{\\mathcal{B}})_g\\right)^2.\n$$\nThe assignment rule $L(\\mathbf{x})$ selects the closer centroid, breaking exact ties with the value $-1$. This rule is a direct geometric criterion in the normalized expression space and is fully determined by the definitions above.\n\nFourth, to model a synthetic merge (doublet), we treat two cells $\\mathbf{C}_i$ and $\\mathbf{C}_j$ as contributing linearly to a merged raw count vector\n$$\n\\mathbf{M}(i,j,\\alpha,\\beta)=\\alpha\\,\\mathbf{C}_i+\\beta\\,\\mathbf{C}_j,\n$$\nwith nonnegative integers $\\alpha,\\beta$ codifying relative contributions. This linearity follows from the additivity of UMI counts under the idealized assumption that molecules from two cells are pooled. We then apply the same normalization and transform, yielding $\\mathbf{x}=\\mathbf{t}\\!\\left(\\mathbf{M}(i,j,\\alpha,\\beta)\\right)$.\n\nFinally, to quantify impact on clustering, we compute two metrics:\n- The signed distance difference\n$$\n\\Delta(\\mathbf{x})= d_{\\mathcal{B}}(\\mathbf{x})-d_{\\mathcal{A}}(\\mathbf{x}),\n$$\nwhich is negative if $\\mathbf{x}$ is closer to $\\mathcal{A}$ and positive if closer to $\\mathcal{B}$; its magnitude indicates the degree of preference.\n- The ambiguity coefficient\n$$\n\\Gamma(\\mathbf{x})=\\frac{\\left|d_{\\mathcal{A}}(\\mathbf{x})-d_{\\mathcal{B}}(\\mathbf{x})\\right|}{d_{\\mathcal{A}}(\\mathbf{x})+d_{\\mathcal{B}}(\\mathbf{x})},\n$$\nwhich lies in $(0,1)$ for distinct distances and is small when the point is nearly equidistant to both centroids, indicating a potentially ambiguous clustering outcome.\n\nImplementation details mirror these definitions:\n1. Encode the four reference cells $\\mathbf{C}_1,\\dots,\\mathbf{C}_4$ with $\\mathbf{C}_1=\\mathbf{A}_1$, $\\mathbf{C}_2=\\mathbf{A}_2$, $\\mathbf{C}_3=\\mathbf{B}_1$, $\\mathbf{C}_4=\\mathbf{B}_2$.\n2. Compute $\\mathbf{t}(\\mathbf{A}_1)$, $\\mathbf{t}(\\mathbf{A}_2)$, $\\mathbf{t}(\\mathbf{B}_1)$, $\\mathbf{t}(\\mathbf{B}_2)$, then obtain $\\boldsymbol{\\mu}_{\\mathcal{A}}$ and $\\boldsymbol{\\mu}_{\\mathcal{B}}$ by averaging within types.\n3. For each test case $(i,j,\\alpha,\\beta)$, form $\\mathbf{M}(i,j,\\alpha,\\beta)$, compute $\\mathbf{x}=\\mathbf{t}\\!\\left(\\mathbf{M}(i,j,\\alpha,\\beta)\\right)$, evaluate $d_{\\mathcal{A}}(\\mathbf{x})$ and $d_{\\mathcal{B}}(\\mathbf{x})$, determine $L(\\mathbf{x})$ from the strict inequality comparisons, and then compute $\\Delta(\\mathbf{x})$ and $\\Gamma(\\mathbf{x})$.\n4. Output the list of triples $\\left[L(\\mathbf{x}),\\Delta(\\mathbf{x}),\\Gamma(\\mathbf{x})\\right]$ for the five specified test cases, formatted on a single line with brackets and commas and no spaces.\n\nBecause every step is directly specified by the mathematical definitions and constants given (gene order, $L=10^4$, natural logarithm, arithmetic means, squared Euclidean distances, and linear merging with integer weights), the program deterministically produces the required outputs for all cases, including boundary behavior when one of $\\alpha$ or $\\beta$ equals $0$ (which reduces the merge to a single contributing cell).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef normalize_log1p(counts: np.ndarray, scale: float = 1e4) -> np.ndarray:\n    \"\"\"Library-size normalize to 'scale' and apply log1p (natural log).\"\"\"\n    total = float(np.sum(counts))\n    # Assumes total > 0 for given test suite; otherwise would need guard.\n    norm = scale * counts / total\n    return np.log1p(norm)\n\ndef squared_euclidean(a: np.ndarray, b: np.ndarray) -> float:\n    diff = a - b\n    return float(np.dot(diff, diff))\n\ndef solve():\n    # Define reference cells (raw UMI counts) in fixed gene order.\n    A1 = np.array([80, 60, 5, 3, 20], dtype=float)\n    A2 = np.array([90, 55, 7, 2, 22], dtype=float)\n    B1 = np.array([4, 3, 70, 65, 18], dtype=float)\n    B2 = np.array([5, 2, 75, 60, 20], dtype=float)\n\n    # Index mapping: C1=A1, C2=A2, C3=B1, C4=B2\n    C = [None, A1, A2, B1, B2]  # 1-based indexing convenience\n\n    # Precompute transformed references and centroids\n    tA1 = normalize_log1p(A1)\n    tA2 = normalize_log1p(A2)\n    tB1 = normalize_log1p(B1)\n    tB2 = normalize_log1p(B2)\n\n    mu_A = 0.5 * (tA1 + tA2)\n    mu_B = 0.5 * (tB1 + tB2)\n\n    # Test cases: tuples (i, j, alpha, beta)\n    test_cases = [\n        (1, 3, 1, 1),  # Case 1: A1 + B1\n        (1, 2, 1, 1),  # Case 2: A1 + A2 (same-type merge edge case)\n        (3, 4, 1, 1),  # Case 3: B1 + B2 (same-type merge edge case)\n        (1, 3, 3, 1),  # Case 4: imbalanced contributions\n        (2, 4, 1, 0),  # Case 5: zero contribution from second\n    ]\n\n    results = []\n    for i, j, alpha, beta in test_cases:\n        merged = alpha * C[i] + beta * C[j]\n        tx = normalize_log1p(merged)\n\n        dA = squared_euclidean(tx, mu_A)\n        dB = squared_euclidean(tx, mu_B)\n\n        # Cluster assignment L(x): 0 if closer to A, 1 if closer to B, -1 if equal\n        if dA < dB:\n            label = 0\n        elif dB < dA:\n            label = 1\n        else:\n            label = -1\n\n        delta = dB - dA\n        denom = dA + dB\n        gamma = abs(dA - dB) / denom if denom != 0.0 else 0.0  # denom>0 in our cases\n\n        results.append((label, delta, gamma))\n\n    # Format output as a single line: list of [label,delta,gamma] with no spaces.\n    def format_number(x):\n        # Use repr for floats to avoid unnecessary spaces; ensure plain str for ints.\n        if isinstance(x, (int, np.integer)):\n            return str(int(x))\n        else:\n            return repr(float(x))\n\n    out_items = []\n    for label, delta, gamma in results:\n        out_items.append(f\"[{format_number(label)},{format_number(delta)},{format_number(gamma)}]\")\n    print(f\"[{','.join(out_items)}]\")\n\nsolve()\n```", "id": "2429816"}, {"introduction": "To increase statistical power and capture broader biological variation, scientists must often integrate data from multiple experiments, known as batches. However, technical differences between batches can obscure true biological signals, a problem known as the \"batch effect.\" This exercise introduces a computational approach to correct for a simplified, additive batch effect by realigning cluster centroids in a common space [@problem_id:2429786]. You will use a graph-based method to merge clusters that were artificially separated by batch effects, a core skill for building large, integrated cell atlases.", "problem": "You are given a formalization of how a known additive batch effect can artificially split biologically identical clusters in single-cell RNA-sequencing (scRNA-seq). After standard preprocessing such as normalization and dimensionality reduction, suppose that each observed cluster is represented by a centroid vector in a low-dimensional space, and each batch contributes an additive shift vector that is known. Specifically, let there be $B$ batches indexed by $b \\in \\{1,\\dots,B\\}$. For each batch $b$, you are given a known batch effect vector $\\mathbf{s}_b \\in \\mathbb{R}^d$. Each observed cluster $i$ is associated with a batch index $b(i)$ and an observed centroid $\\mathbf{m}_i \\in \\mathbb{R}^d$. Define the batch-corrected centroid by\n$$\n\\mathbf{c}_i \\;=\\; \\mathbf{m}_i \\;-\\; \\mathbf{s}_{b(i)} \\, .\n$$\nTwo clusters $i$ and $j$ are considered directly compatible if $b(i) \\neq b(j)$ and $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau$, where $\\tau \\in \\mathbb{R}_{\\ge 0}$ is a given tolerance. Define an undirected graph whose vertices are the clusters and whose edges connect all directly compatible pairs. The merged groups are defined as the connected components of this graph. Your task is, for each independent test case below, to compute the total number of merged groups (the number of connected components).\n\nImportant notes:\n- The distance $\\lVert \\cdot \\rVert_2$ is the standard Euclidean norm in $\\mathbb{R}^d$.\n- Edges are permitted only between clusters from different batches, that is, only if $b(i) \\neq b(j)$.\n- The tolerance $\\tau$ is applied inclusively: if $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 = \\tau$, then $i$ and $j$ are connected by an edge.\n- The final result for each test case is an integer: the number of connected components.\n\nTest suite:\n- Test case 1:\n  - Dimension $d = 2$.\n  - Batches $B = 2$ with $\\mathbf{s}_1 = [\\,1,\\,0\\,]$ and $\\mathbf{s}_2 = [\\,-1,\\,0\\,]$.\n  - Tolerance $\\tau = 0.2$.\n  - Observed clusters:\n    - Batch $1$: $\\mathbf{m}_{A} = [\\,5,\\,0\\,]$, $\\mathbf{m}_{C} = [\\,1,\\,10\\,]$.\n    - Batch $2$: $\\mathbf{m}_{B} = [\\,3,\\,0\\,]$, $\\mathbf{m}_{D} = [\\,-1,\\,10.15\\,]$.\n\n- Test case 2:\n  - Dimension $d = 2$.\n  - Batches $B = 3$ with $\\mathbf{s}_1 = [\\,0,\\,0\\,]$, $\\mathbf{s}_2 = [\\,0.5,\\,0\\,]$, $\\mathbf{s}_3 = [\\,1.0,\\,0\\,]$.\n  - Tolerance $\\tau = 1.0$.\n  - Observed clusters:\n    - Batch $1$: $\\mathbf{m}_{A} = [\\,0,\\,0\\,]$, $\\mathbf{m}_{D} = [\\,100,\\,100\\,]$.\n    - Batch $2$: $\\mathbf{m}_{B} = [\\,1.5,\\,0\\,]$, $\\mathbf{m}_{E} = [\\,-100,\\,-100\\,]$.\n    - Batch $3$: $\\mathbf{m}_{C} = [\\,3.0,\\,0\\,]$.\n\n- Test case 3:\n  - Dimension $d = 3$.\n  - Batches $B = 2$ with $\\mathbf{s}_1 = [\\,0.2,\\,-0.1,\\,0.0\\,]$, $\\mathbf{s}_2 = [\\,-0.2,\\,0.1,\\,0.0\\,]$.\n  - Tolerance $\\tau = 0.0$.\n  - Observed clusters:\n    - Batch $1$: $\\mathbf{m}_{X} = [\\,1.2,\\,0.9,\\,3.0\\,]$, $\\mathbf{m}_{Z} = [\\,10.2,\\,-4.1,\\,0.0\\,]$.\n    - Batch $2$: $\\mathbf{m}_{Y} = [\\,0.8,\\,1.1,\\,3.0\\,]$, $\\mathbf{m}_{W} = [\\,9.8,\\,-3.9,\\,0.05\\,]$.\n\nYour program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, for example, $[\\,r_1,r_2,r_3\\,]$, where each $r_k$ is the integer number of merged groups for test case $k$.", "solution": "The problem presented is a valid and well-posed exercise in computational biology, specifically concerning the principles of batch effect correction in single-cell RNA-sequencing (scRNA-seq) data analysis. The problem is scientifically grounded, mathematically precise, and algorithmically solvable. I shall, therefore, present a complete solution.\n\nThe fundamental objective is to identify and merge clusters of cells that are biologically identical but appear distinct due to technical artifacts known as batch effects. The problem formalizes this scenario and provides a clear procedure for reintegrating the data. The solution proceeds in three logical steps, based on established principles.\n\nFirst, we apply the principle of **additive batch correction**. It is assumed that the effect of an experimental batch $b$ is a uniform, additive displacement of the data points in the feature space. This is represented by a known shift vector $\\mathbf{s}_b \\in \\mathbb{R}^d$. An observed cluster $i$ from batch $b(i)$, represented by its centroid $\\mathbf{m}_i$, has its true biological position $\\mathbf{c}_i$ distorted by this effect. To correct for this, we subtract the corresponding shift vector, yielding the batch-corrected centroid:\n$$\n\\mathbf{c}_i = \\mathbf{m}_i - \\mathbf{s}_{b(i)}\n$$\nThis operation aims to align the centroids of biologically equivalent clusters from different batches into a common, corrected coordinate system.\n\nSecond, we employ a **graph-based framework to define relationships** between clusters. The clusters are treated as vertices in an undirected graph. An edge between two vertices signifies that the corresponding clusters are compatible for merging. The criteria for compatibility are rigorously defined:\n1.  The clusters must originate from different batches, i.e., $b(i) \\neq b(j)$. This is a crucial constraint, as the goal is to merge across batches, not within a batch where clusters are assumed to be biologically distinct.\n2.  The Euclidean distance between their batch-corrected centroids must be within a given tolerance $\\tau \\ge 0$. This is expressed mathematically as:\n    $$\n    \\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau\n    $$\n    This condition formalizes the notion that if two clusters are biologically the same, their corrected centroids should be located very close to each other in the feature space.\n\nThird, the final **merged groups are identified as the connected components** of this compatibility graph. A connected component is a maximal subgraph in which any two vertices are connected to each other by a path. This definition naturally groups together all clusters that are directly or indirectly compatible. The total number of such merged groups is therefore equal to the number of connected components in the graph.\n\nTo compute this number, we implement a standard graph algorithm. For each test case, we perform the following steps:\n1.  For each observed cluster $i$, calculate its corrected centroid $\\mathbf{c}_i$.\n2.  Construct an adjacency representation (e.g., an adjacency matrix or list) of the graph with $N$ vertices, where $N$ is the total number of clusters. Iterate through all unique pairs of clusters $(i, j)$.\n3.  If $b(i) \\neq b(j)$ and $\\lVert \\mathbf{c}_i - \\mathbf{c}_j \\rVert_2 \\le \\tau$, add an edge between vertices $i$ and $j$.\n4.  Utilize a graph traversal algorithm, such as Depth-First Search (DFS) or Breadth-First Search (BFS), to count the number of connected components. Alternatively, a dedicated library function, such as `scipy.sparse.csgraph.connected_components`, can be employed for this purpose.\n\nWe will now apply this procedure to each test case.\n\n**Test Case 1:**\n- Batches: $B=2$. Clusters: $A, C$ in batch $1$; $B, D$ in batch $2$. $\\tau = 0.2$.\n- Batch shifts: $\\mathbf{s}_1 = [1, 0]$, $\\mathbf{s}_2 = [-1, 0]$.\n- Observed centroids: $\\mathbf{m}_A = [5, 0]$, $\\mathbf{m}_C = [1, 10]$, $\\mathbf{m}_B = [3, 0]$, $\\mathbf{m}_D = [-1, 10.15]$.\n- Corrected centroids:\n  - $\\mathbf{c}_A = \\mathbf{m}_A - \\mathbf{s}_1 = [5, 0] - [1, 0] = [4, 0]$.\n  - $\\mathbf{c}_C = \\mathbf{m}_C - \\mathbf{s}_1 = [1, 10] - [1, 0] = [0, 10]$.\n  - $\\mathbf{c}_B = \\mathbf{m}_B - \\mathbf{s}_2 = [3, 0] - [-1, 0] = [4, 0]$.\n  - $\\mathbf{c}_D = \\mathbf{m}_D - \\mathbf{s}_2 = [-1, 10.15] - [-1, 0] = [0, 10.15]$.\n- Compatibility checks (between batch $1$ and $2$):\n  - $\\lVert \\mathbf{c}_A - \\mathbf{c}_B \\rVert_2 = \\lVert [4, 0] - [4, 0] \\rVert_2 = 0 \\le 0.2$. Edge $(A, B)$ exists.\n  - $\\lVert \\mathbf{c}_C - \\mathbf{c}_D \\rVert_2 = \\lVert [0, 10] - [0, 10.15] \\rVert_2 = 0.15 \\le 0.2$. Edge $(C, D)$ exists.\n  - All other cross-batch distances are large.\n- The graph has two components: $\\{A, B\\}$ and $\\{C, D\\}$. The number of merged groups is $2$.\n\n**Test Case 2:**\n- Batches: $B=3$. Clusters: $A, D$ in batch $1$; $B, E$ in batch $2$; $C$ in batch $3$. $\\tau = 1.0$.\n- Batch shifts: $\\mathbf{s}_1 = [0, 0]$, $\\mathbf{s}_2 = [0.5, 0]$, $\\mathbf{s}_3 = [1.0, 0]$.\n- Corrected centroids:\n  - $\\mathbf{c}_A = [0, 0] - [0, 0] = [0, 0]$.\n  - $\\mathbf{c}_D = [100, 100]$.\n  - $\\mathbf{c}_B = [1.5, 0] - [0.5, 0] = [1.0, 0]$.\n  - $\\mathbf{c}_E = [-100, -100] - [0.5, 0] = [-100.5, -100]$.\n  - $\\mathbf{c}_C = [3.0, 0] - [1.0, 0] = [2.0, 0]$.\n- Compatibility checks:\n  - $\\lVert \\mathbf{c}_A - \\mathbf{c}_B \\rVert_2 = \\lVert [0, 0] - [1.0, 0] \\rVert_2 = 1.0 \\le 1.0$. Edge $(A, B)$ exists.\n  - $\\lVert \\mathbf{c}_B - \\mathbf{c}_C \\rVert_2 = \\lVert [1.0, 0] - [2.0, 0] \\rVert_2 = 1.0 \\le 1.0$. Edge $(B, C)$ exists.\n  - Distances to/from $D$ and $E$ are large.\n- The graph has a component $\\{A, B, C\\}$ and two isolated vertices $\\{D\\}$ and $\\{E\\}$. The number of merged groups is $3$.\n\n**Test Case 3:**\n- Batches: $B=2$. Clusters: $X, Z$ in batch $1$; $Y, W$ in batch $2$. $\\tau = 0.0$.\n- Batch shifts: $\\mathbf{s}_1 = [0.2, -0.1, 0.0]$, $\\mathbf{s}_2 = [-0.2, 0.1, 0.0]$.\n- Corrected centroids:\n  - $\\mathbf{c}_X = [1.2, 0.9, 3.0] - [0.2, -0.1, 0.0] = [1.0, 1.0, 3.0]$.\n  - $\\mathbf{c}_Z = [10.2, -4.1, 0.0] - [0.2, -0.1, 0.0] = [10.0, -4.0, 0.0]$.\n  - $\\mathbf{c}_Y = [0.8, 1.1, 3.0] - [-0.2, 0.1, 0.0] = [1.0, 1.0, 3.0]$.\n  - $\\mathbf{c}_W = [9.8, -3.9, 0.05] - [-0.2, 0.1, 0.0] = [10.0, -4.0, 0.05]$.\n- Compatibility checks (with $\\tau=0.0$, distance must be exactly $0$):\n  - $\\mathbf{c}_X$ is identical to $\\mathbf{c}_Y$, so $\\lVert \\mathbf{c}_X - \\mathbf{c}_Y \\rVert_2 = 0 \\le 0.0$. Edge $(X, Y)$ exists.\n  - No other pairs have identical corrected centroids.\n- The graph has a component $\\{X, Y\\}$ and two isolated vertices $\\{Z\\}$ and $\\{W\\}$. The number of merged groups is $3$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the cluster merging problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"batch_shifts\": {1: np.array([1.0, 0.0]), 2: np.array([-1.0, 0.0])},\n            \"tau\": 0.2,\n            \"clusters\": [\n                {'m': np.array([5.0, 0.0]), 'b': 1},\n                {'m': np.array([1.0, 10.0]), 'b': 1},\n                {'m': np.array([3.0, 0.0]), 'b': 2},\n                {'m': np.array([-1.0, 10.15]), 'b': 2},\n            ],\n        },\n        # Test Case 2\n        {\n            \"batch_shifts\": {\n                1: np.array([0.0, 0.0]),\n                2: np.array([0.5, 0.0]),\n                3: np.array([1.0, 0.0]),\n            },\n            \"tau\": 1.0,\n            \"clusters\": [\n                {'m': np.array([0.0, 0.0]), 'b': 1},\n                {'m': np.array([100.0, 100.0]), 'b': 1},\n                {'m': np.array([1.5, 0.0]), 'b': 2},\n                {'m': np.array([-100.0, -100.0]), 'b': 2},\n                {'m': np.array([3.0, 0.0]), 'b': 3},\n            ],\n        },\n        # Test Case 3\n        {\n            \"batch_shifts\": {\n                1: np.array([0.2, -0.1, 0.0]),\n                2: np.array([-0.2, 0.1, 0.0]),\n            },\n            \"tau\": 0.0,\n            \"clusters\": [\n                {'m': np.array([1.2, 0.9, 3.0]), 'b': 1},\n                {'m': np.array([10.2, -4.1, 0.0]), 'b': 1},\n                {'m': np.array([0.8, 1.1, 3.0]), 'b': 2},\n                {'m': np.array([9.8, -3.9, 0.05]), 'b': 2},\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        clusters_data = case[\"clusters\"]\n        batch_shifts = case[\"batch_shifts\"]\n        tau = case[\"tau\"]\n        num_clusters = len(clusters_data)\n\n        # Step 1: Compute batch-corrected centroids\n        corrected_centroids = []\n        for i in range(num_clusters):\n            m_i = clusters_data[i]['m']\n            b_i = clusters_data[i]['b']\n            s_i = batch_shifts[b_i]\n            c_i = m_i - s_i\n            corrected_centroids.append(c_i)\n\n        # Step 2: Build the adjacency matrix for the compatibility graph\n        adjacency_matrix = np.zeros((num_clusters, num_clusters), dtype=int)\n        for i in range(num_clusters):\n            for j in range(i + 1, num_clusters):\n                # Condition 1: Must be from different batches\n                b_i = clusters_data[i]['b']\n                b_j = clusters_data[j]['b']\n                if b_i == b_j:\n                    continue\n\n                # Condition 2: Distance between corrected centroids is within tolerance\n                c_i = corrected_centroids[i]\n                c_j = corrected_centroids[j]\n                distance = np.linalg.norm(c_i - c_j)\n\n                if distance <= tau:\n                    adjacency_matrix[i, j] = 1\n                    adjacency_matrix[j, i] = 1\n\n        # Step 3: Count the number of connected components\n        n_components, _ = connected_components(\n            csgraph=adjacency_matrix, directed=False, return_labels=True\n        )\n        results.append(n_components)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2429786"}]}