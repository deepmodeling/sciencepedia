{"hands_on_practices": [{"introduction": "Modern biology is awash in data, with sequencing projects generating datasets far too large to fit into a computer's main memory. This exercise tackles this real-world constraint by applying a clever divide-and-conquer strategy to a foundational bioinformatics task: counting distinct $k$-mers. Instead of attempting to hold all unique $k$-mers in memory at once, you will learn to partition the vast space of all possible $k$-mers and solve the problem piecewise, demonstrating a powerful paradigm for creating scalable tools [@problem_id:2386106].", "problem": "You are given a multiset of deoxyribonucleic acid (DNA) strings over the alphabet $\\Sigma=\\{A,C,G,T\\}$. For an integer $k \\ge 1$, a $k$-mer is any length-$k$ contiguous substring composed only of characters in $\\Sigma$. Substrings containing any character not in $\\Sigma$ are not considered valid $k$-mers and must be ignored. For a collection of DNA strings, let $\\mathcal{K}_k$ denote the set of all valid $k$-mers that appear in at least one string from the collection. Your task is to compute $|\\mathcal{K}_k|$ exactly under a strict memory budget that models Random Access Memory (RAM). The memory budget is formalized as follows: at any instant, your program is not permitted to hold more than $B$ distinct $k$-mer keys in memory simultaneously. You may assume $B \\ge 1$ is an integer.\n\nDesign and implement a program that, given several parameter sets $(\\text{sequences}, k, B)$, returns the exact value of $|\\mathcal{K}_k|$ for each set, while ensuring that at no time does any data structure in your approach store more than $B$ distinct $k$-mers concurrently. The entire input may be larger than available RAM; your method must therefore proceed by structuring the computation so that the final exact result is obtained without exceeding the stated constraint on concurrently stored distinct keys. The input sequences should be treated as read-only strings; do not assume any specialized preprocessed index is available.\n\nUse the following test suite of parameter values inside your program. In each item below, the value $k$ and the budget $B$ are given, followed by the list of DNA strings. In all cases, ignore substrings containing characters outside $\\Sigma$.\n\n- Test case $1$: $k=3$, $B=2$, sequences = [\"ACGTACGT\",\"TACG\"].\n- Test case $2$: $k=2$, $B=4$, sequences = [\"AAAAAA\"].\n- Test case $3$: $k=2$, $B=1$, sequences = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"].\n- Test case $4$: $k=4$, $B=1$, sequences = [\"ATATATATAT\",\"TATATATATA\"].\n- Test case $5$: $k=1$, $B=1$, sequences = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"].\n- Test case $6$: $k=3$, $B=2$, sequences = [\"AC\",\"G\"].\n\nYour program must compute, for each test case, the integer $|\\mathcal{K}_k|$, where $\\mathcal{K}_k$ is defined as above. The required final output format is a single line containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases listed above, for example \"[x1,x2,x3,x4,x5,x6]\" where each $x_i$ is an integer equal to $|\\mathcal{K}_k|$ for test case $i$.", "solution": "The problem statement is subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n-   **Alphabet**: $\\Sigma=\\{A,C,G,T\\}$\n-   **$k$-mer**: A contiguous substring of length $k \\ge 1$ composed only of characters from $\\Sigma$.\n-   **Invalid substrings**: Substrings containing characters not in $\\Sigma$ are to be ignored.\n-   **Input**: A multiset of strings, denoted `sequences`.\n-   **Input Parameter $k$**: An integer, the length of the $k$-mer, where $k \\ge 1$.\n-   **Input Parameter $B$**: An integer, the memory budget, representing the maximum number of distinct $k$-mer keys that can be stored concurrently. It is given that $B \\ge 1$.\n-   **Objective**: Compute $|\\mathcal{K}_k|$, the cardinality of the set $\\mathcal{K}_k$ of all unique, valid $k$-mers present in the input `sequences`.\n-   **Constraint**: The algorithm must not store more than $B$ distinct $k$-mers in memory at any given time.\n-   **Test Cases**:\n    -   Test case $1$: $k=3$, $B=2$, sequences = [\"ACGTACGT\",\"TACG\"].\n    -   Test case $2$: $k=2$, $B=4$, sequences = [\"AAAAAA\"].\n    -   Test case $3$: $k=2$, $B=1$, sequences = [\"NNNNN\",\"ACNGT\",\"ACGTTN\"].\n    -   Test case $4$: $k=4$, $B=1$, sequences = [\"ATATATATAT\",\"TATATATATA\"].\n    -   Test case $5$: $k=1$, $B=1$, sequences = [\"ACGTACGT\",\"GGGG\",\"TTTT\",\"CCCC\",\"AAAA\"].\n    -   Test case $6$: $k=3$, $B=2$, sequences = [\"AC\",\"G\"].\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem is well-grounded in computational biology and bioinformatics. $k$-mer counting is a fundamental task for applications such as genome assembly, sequence alignment, and metagenomic analysis. The use of the alphabet $\\Sigma=\\{A,C,G,T\\}$ and the concept of ignoring non-standard characters (like 'N') are standard conventions. The problem is a variant of the \"distinct elements problem\" from streaming algorithms, applied to bioinformatics under a specific memory model. It is scientifically and computationally sound.\n-   **Well-Posedness**: The problem is well-posed. The objective is to compute the cardinality of a uniquely defined set $\\mathcal{K}_k$. The inputs and constraints are specified clearly. For any valid set of inputs, a unique integer solution exists.\n-   **Objectivity**: The problem is stated using precise, objective, and formal mathematical language. It is free from ambiguity, subjectivity, or opinion-based claims.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. It is a standard, well-defined computational problem with clear constraints and objectives. Proceeding to solution.\n\n**Principle-Based Solution**\n\nThe central challenge of this problem is the strict memory budget, $B$, which prohibits a naive approach. A direct solution, such as iterating through all sequences, extracting all $k$-mers, and inserting them into a single hash set, would fail if the total number of distinct $k$-mers, $|\\mathcal{K}_k|$, exceeds $B$. The problem therefore mandates an algorithm that can operate on data larger than the available memory, often termed an \"external memory\" or \"out-of-core\" algorithm.\n\nThe guiding principle for such a problem is **divide and conquer**. However, instead of partitioning the input data (the sequences), which is read-only, we must partition the problem space itself. The problem space is the set of all possible $4^k$ $k$-mers over the alphabet $\\Sigma$. By partitioning this space into disjoint subsets, we can count the distinct $k$-mers within each subset independently and sum the results. The disjoint nature of the partitions ensures that no $k$-mer is counted more than once.\n\nThe most effective partitioning strategy here is a recursive partitioning of the $k$-mer space based on prefixes. Let's define a function, $\\text{Count}(\\rho)$, which counts the number of distinct $k$-mers in the input sequences that start with a given prefix $\\rho$. The total number of distinct $k$-mers is then simply $\\text{Count}(\\text{\"\"})$, where $\\text{\"\"}$ is the empty prefix.\n\nThe algorithm is structured as a recursive function that attempts to solve $\\text{Count}(\\rho)$ within the memory budget $B$.\n\n$1$. **Attempt to Count**: To compute $\\text{Count}(\\rho)$, we iterate through all input sequences. For each valid $k$-mer found, we check if it begins with the prefix $\\rho$. If it does, we add it to an in-memory set, let's call it $S_{\\rho}$.\n\n$2$. **Memory Budget Check**: During this process, we continuously monitor the size of our set, $|S_{\\rho}|$.\n    - If the entire dataset is processed and $|S_{\\rho}|$ never exceeds $B$, we have successfully counted the distinct $k$-mers for this partition. The function returns $|S_{\\rho}|$. This forms the base case of our recursion.\n    - If at any point $|S_{\\rho}|$ becomes greater than $B$, it means the partition defined by prefix $\\rho$ is too large to be processed within the memory limit. We must \"spill,\" which in this context means abandoning the current count and subdividing the problem.\n\n$3$. **Recursive Subdivision (Divide Step)**: Upon a \"spill,\" we subdivide the partition corresponding to prefix $\\rho$ into four smaller, disjoint partitions based on the next character. The four new prefixes will be $\\rho+'A'$, $\\rho+'C'$, $\\rho+'G'$, and $\\rho+'T'$. The total count for prefix $\\rho$ is then the sum of the counts from these smaller partitions. This is expressed recursively:\n$$ \\text{Count}(\\rho) = \\text{Count}(\\rho+'A') + \\text{Count}(\\rho+'C') + \\text{Count}(\\rho+'G') + \\text{Count}(\\rho+'T') $$\nThis recursive call effectively initiates new passes over the data, each focused on a more specific subset of $k$-mers.\n\n$4$. **Termination**: The recursion is guaranteed to terminate. As the prefix length increases, the corresponding partition of the $k$-mer space becomes smaller. In the limiting case, the prefix length becomes $k$. A partition for a prefix of length $k$ can contain at most one unique $k$-mer (the prefix itself). Since the budget $B \\ge 1$, a spill cannot occur for a partition defined by a prefix of length $k$. Therefore, the recursion depth is at most $k$, and the base case (a successful count within budget) will always be reached.\n\nThis recursive, prefix-based divide-and-conquer strategy correctly computes the exact number of distinct $k$-mers while strictly adhering to the memory constraint at every stage of the computation. The cost of this memory-compliance is an increase in computational time, as the input sequences may need to be scanned multiple times.\n\nBefore processing, any characters not in $\\Sigma = \\{A, C, G, T\\}$ must be handled. A robust way to do this is to treat them as delimiters, splitting each input sequence into a set of contiguous substrings composed solely of valid characters. The $k$-mer extraction logic is then applied to these valid substrings only.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the k-mer counting problem for the predefined test suite.\n    \"\"\"\n    \n    test_cases = [\n        # (sequences, k, B)\n        ([\"ACGTACGT\", \"TACG\"], 3, 2),\n        ([\"AAAAAA\"], 2, 4),\n        ([\"NNNNN\", \"ACNGT\", \"ACGTTN\"], 2, 1),\n        ([\"ATATATATAT\", \"TATATATATA\"], 4, 1),\n        ([\"ACGTACGT\", \"GGGG\", \"TTTT\", \"CCCC\", \"AAAA\"], 1, 1),\n        ([\"AC\", \"G\"], 3, 2),\n    ]\n\n    results = []\n    for sequences, k, B in test_cases:\n        result = count_distinct_kmers(sequences, k, B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef count_distinct_kmers(sequences, k, B):\n    \"\"\"\n    Main entry point for the k-mer counting algorithm. It initializes\n    the recursive counting process.\n\n    Args:\n        sequences (list[str]): The list of DNA sequences.\n        k (int): The length of the k-mer.\n        B (int): The memory budget (max number of distinct k-mers).\n\n    Returns:\n        int: The total count of distinct k-mers.\n    \"\"\"\n    if k = 0:\n        return 0\n\n    valid_chars = {'A', 'C', 'G', 'T'}\n    \n    # Pre-process sequences to handle invalid characters like 'N'.\n    # This creates a list of substrings containing only valid DNA characters.\n    valid_substrings = []\n    for seq in sequences:\n        current_sub = []\n        for char in seq:\n            if char in valid_chars:\n                current_sub.append(char)\n            else:\n                if current_sub:\n                    valid_substrings.append(\"\".join(current_sub))\n                    current_sub = []\n        if current_sub:\n            valid_substrings.append(\"\".join(current_sub))\n\n    return _count_recursive(valid_substrings, k, B, \"\", np.array(list(valid_chars)))\n\ndef _count_recursive(valid_substrings, k, B, prefix, alphabet):\n    \"\"\"\n    Recursively counts distinct k-mers using a divide-and-conquer approach.\n\n    Args:\n        valid_substrings (list[str]): A list of DNA segments with no invalid characters.\n        k (int): The k-mer length.\n        B (int): The memory budget.\n        prefix (str): The current prefix defining the k-mer partition to count.\n        alphabet (np.ndarray): The characters of the DNA alphabet.\n\n    Returns:\n        int: The count of distinct k-mers for the given partition.\n    \"\"\"\n    kmers_in_partition = set()\n    has_spilled = False\n\n    for sub_seq in valid_substrings:\n        if len(sub_seq)  k:\n            continue\n        for i in range(len(sub_seq) - k + 1):\n            # Potential k-mer\n            kmer = sub_seq[i:i+k]\n            if kmer.startswith(prefix):\n                kmers_in_partition.add(kmer)\n                if len(kmers_in_partition) > B:\n                    has_spilled = True\n                    break  # from inner loop\n        if has_spilled:\n            break  # from outer loop\n    \n    if has_spilled:\n        # Memory budget exceeded. Subdivide the problem and recurse.\n        # This logical branch should not be reachable if len(prefix) == k\n        # because the set would contain at most 1 element, and B >= 1.\n        # The check is an assertion of this logic.\n        if len(prefix) >= k:\n             # This indicates a logical error or an invalid state (e.g., B=0).\n             # Given problem constraints B>=1, this is unreachable.\n             return 1\n             \n        sub_count = 0\n        for char in alphabet:\n            new_prefix = prefix + char\n            sub_count += _count_recursive(valid_substrings, k, B, new_prefix, alphabet)\n        return sub_count\n    else:\n        # Base case: Succeeded in counting k-mers for this partition within the budget.\n        return len(kmers_in_partition)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386106"}, {"introduction": "Specific DNA patterns, such as reverse-complement palindromes, often serve as functional signals recognized by cellular machinery. Identifying all such sites in a genome is a common task, but a brute-force approach is too slow for large sequences. This practice introduces an elegant and efficient solution that combines the power of two algorithmic ideas: using a rolling hash for rapid substring comparison and applying a divide-and-conquer strategy (binary search) to quickly find the maximal palindrome at every possible location [@problem_id:2386095].", "problem": "You are given the task of designing and implementing a divide and conquer (DC) algorithm to find all reverse-complement palindromic substrings in a Deoxyribonucleic Acid (DNA) chromosome. A DNA chromosome will be modeled as a finite string over the alphabet $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$. Use the canonical base-pairing rules: $\\mathrm{A}$ pairs with $\\mathrm{T}$ and $\\mathrm{C}$ pairs with $\\mathrm{G}$. For any DNA string $s$, define its complement $\\operatorname{comp}(s)$ by applying these pairings characterwise, and its reverse complement $\\operatorname{rc}(s)$ by reversing $\\operatorname{comp}(s)$. A string $w$ is a reverse-complement palindrome if $w=\\operatorname{rc}(w)$. For indices, use $0$-based indexing. For a substring $s[i:j]$ (with $i$ inclusive and $j$ exclusive), its length is $j-i$.\n\nStarting from the fundamental definitions of string substrings and the DNA complementarity rules, and the well-tested fact that binary search is a canonical divide and conquer strategy that halves the search interval on each step, design an algorithm that:\n- Preprocesses the chromosome to enable constant-time substring-equality queries under a fixed encoding.\n- For each potential palindrome center, uses a divide and conquer strategy (binary search on the radius) to find the maximum radius such that the corresponding substring equals its reverse complement.\n- Enumerates all reverse-complement palindromic substrings of length at least $k$.\n\nThe algorithm must be framed purely in mathematical and logical terms and be implementable in any modern programming language. No biological wet-lab steps are involved. All answers are unitless. You must output all substrings satisfying the criterion as pairs $[i,\\ell]$, where $i$ is the starting index and $\\ell$ is the length, with $i$ in $0$-based indexing. Sort the pairs for each chromosome in ascending order by $i$, and for equal $i$, by $\\ell$. Because under standard DNA base-pairing, no nucleotide is its own complement, only even-length reverse-complement palindromes can exist; your method should discover this from first principles via the palindromicity test and not rely on a hard-coded special case.\n\nYou must implement the algorithm as a single, complete, runnable program that produces the results for the following test suite. For each case, compute all reverse-complement palindromic substrings of length at least $k$:\n\n- Test case $1$: chromosome $s=\\text{\"ATCGAT\"}$, $k=4$.\n- Test case $2$: chromosome $s=\\text{\"AAAAAA\"}$, $k=3$.\n- Test case $3$: chromosome $s=\\text{\"CGAATTCG\"}$, $k=4$.\n- Test case $4$: chromosome $s=\\text{\"AT\"}$, $k=2$.\n- Test case $5$: chromosome $s=\\text{\"ATAT\"}$, $k=2$.\n\nFinal output format: Your program must produce a single line of output containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of $[i,\\ell]$ pairs. For example, the general structure is $[[[i_1,\\ell_1],[i_2,\\ell_2],\\dots],[],\\dots]$. There must be no spaces anywhere in the output line.", "solution": "The problem is to devise and implement a divide and conquer algorithm to identify all reverse-complement palindromic substrings within a given Deoxyribonucleic Acid (DNA) sequence, subject to a minimum length constraint. The problem is well-posed, scientifically grounded in the principles of molecular biology and computational string analysis, and contains all necessary information for a unique solution.\n\nFirst, we formalize the definitions. A DNA sequence $s$ is a string over the alphabet $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$. The complementarity rules define a function $c: \\Sigma \\to \\Sigma$ where $c(\\mathrm{A})=\\mathrm{T}$, $c(\\mathrm{T})=\\mathrm{A}$, $c(\\mathrm{C})=\\mathrm{G}$, and $c(\\mathrm{G})=\\mathrm{C}$. For a string $s = s_0s_1\\dots s_{n-1}$, its complement is $\\operatorname{comp}(s) = c(s_0)c(s_1)\\dots c(s_{n-1})$, and its reverse is $\\operatorname{rev}(s) = s_{n-1}\\dots s_1s_0$. The reverse complement is defined as $\\operatorname{rc}(s) = \\operatorname{rev}(\\operatorname{comp}(s))$. A substring $w$ is a reverse-complement palindrome if it satisfies the condition $w = \\operatorname{rc}(w)$. Our task is to find all such substrings $w$ of a given chromosome $s$ where the length of $w$, denoted $|w|$, is at least a given integer $k$.\n\nA critical observation, derived from first principles as required, concerns the possible lengths of such palindromes. A palindrome $w$ of odd length, say $|w| = 2r+1$ for some integer $r \\ge 0$, has a central character $w_r$. The palindromic condition $w = \\operatorname{rc}(w)$ implies $w_i = c(w_{2r-i})$ for all $i \\in \\{0, \\dots, 2r\\}$. For the central character at $i=r$, this gives $w_r = c(w_r)$. However, for the canonical DNA bases, no base is its own complement: $c(x) \\neq x$ for any $x \\in \\Sigma$. Consequently, no character can satisfy the central condition, and thus no reverse-complement palindrome of odd length can exist. All such palindromes must have an even length, $|w| = 2r$ for $r \\ge 1$.\n\nAn even-length palindrome is centered between two characters. For a string $s$ of length $N$, there are $N-1$ possible centers for even-length palindromes, located between indices $i-1$ and $i$ for $i \\in \\{1, \\dots, N-1\\}$. For a given center $i$, a palindrome of radius $r \\ge 1$ is the substring $s[i-r : i+r]$, which has length $2r$. The condition for this substring to be a reverse-complement palindrome is $s[i-k] = c(s[i+k-1])$ for all $k \\in \\{1, \\dots, r\\}$.\n\nThe core of the specified algorithm is a divide and conquer strategy. For each potential center, we must find the maximal radius $R_{max}$ for which the palindromic property holds. The set of all valid palindromes for that center are then those with radii $r \\in \\{1, \\dots, R_{max}\\}$. The property of being a palindrome is monotonic: if it holds for a radius $r$, it must hold for any smaller radius $r'  r$. This structure permits the use of binary search—a classic divide and conquer technique—to find $R_{max}$ efficiently. For a center $i$, the search space for the radius $r$ is the interval $[0, \\min(i, N-i)]$.\n\nTo execute the binary search efficiently, each check for the palindromic property must be performed in constant time, $O(1)$. A naive character-by-character comparison for a radius $r$ would take $O(r)$ time, leading to an overall complexity of $O(N^2)$. The problem mandates preprocessing to achieve $O(1)$ substring-equality queries. Polynomial rolling hash is a standard method for this. The palindromic condition for radius $r$ at center $i$, $s[i-k] = c(s[i+k-1])$ for $k=1, \\dots, r$, is equivalent to the string equality $s[i-r : i] = \\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$.\n\nTo implement this check using hashing, we precompute hash values for two strings: the original string $s$, and its complete reverse complement, $s_{rc} = \\operatorname{rc}(s)$. Let $|s| = N$. The substring $s[i-r:i]$ is a simple substring of $s$. The substring $\\operatorname{rev}(\\operatorname{comp}(s[i : i+r]))$ is equivalent to a specific substring of $s_{rc}$. The reverse complement of $s[i:i+r]$ corresponds to the substring of $s_{rc}$ starting at index $N-(i+r)$ with length $r$, i.e., $s_{rc}[N-i-r : N-i]$. Thus, the palindromic check for radius $r$ at center $i$ reduces to comparing the hash of $s[i-r : i]$ with the hash of $s_{rc}[N-i-r : N-i]$. With precomputed prefix hashes for both $s$ and $s_{rc}$, this comparison takes $O(1)$ time. To minimize hash collisions, a dual-hashing scheme with two independent pairs of base and modulus is employed.\n\nThe complete algorithm proceeds as follows:\n1.  **Preprocessing ($O(N)$ time)**:\n    a. Given the input string $s$ of length $N$.\n    b. Construct its reverse complement, $s_{rc}$.\n    c. For both $s$ and $s_{rc}$, precompute two sets of prefix hashes and powers of the bases, using two different (base, modulus) pairs.\n\n2.  **Palindrome Search ($O(N \\log N)$ time)**:\n    a. Initialize an empty list, `results`, to store the found palindromes.\n    b. Iterate through each potential center $i \\in \\{1, \\dots, N-1\\}$.\n    c. For each center $i$, determine the maximum possible radius, $r_{lim} = \\min(i, N-i)$.\n    d. Perform a binary search on the radius $r \\in [1, r_{lim}]$ to find the maximal radius $R_{max}$ for which $s[i-r:i]$ and $\\operatorname{rev}(\\operatorname{comp}(s[i:i+r]))$ are identical. This check is performed in $O(1)$ by comparing the dual hash values of $s[i-r:i]$ and $s_{rc}[N-i-r:N-i]$.\n    e. After finding $R_{max}$, all substrings centered at $i$ with radii from $1$ to $R_{max}$ are reverse-complement palindromes. Their lengths are $2, 4, \\dots, 2R_{max}$.\n\n3.  **Result Enumeration and Formatting**:\n    a. For each center $i$ and its found $R_{max}$, iterate through radii $r$ from $\\lceil k/2 \\rceil$ to $R_{max}$. For each such $r$, a valid palindrome is found. Its length is $\\ell = 2r$ and its starting index is $j = i-r$. Add the pair $[j, \\ell]$ to the `results` list.\n    b. After iterating through all centers, sort the `results` list in ascending order of starting index $j$, and for equal $j$, by length $\\ell$.\n    c. Format the final output as specified.\n\nThe total time complexity of this algorithm is dominated by the search step, which is $O(N \\log N)$. The space complexity is $O(N)$ for storing the strings and their hash tables. This approach conforms to all requirements of the problem statement.", "answer": "```python\nimport numpy as np\n\n# No scipy is used in this solution.\n\nclass DualStringHasher:\n    \"\"\"\n    Computes and provides rolling hashes for a string using two different\n    (base, modulus) pairs to minimize collisions.\n    \"\"\"\n    def __init__(self, s: str):\n        self.n = len(s)\n        self.p1, self.m1 = 31, 10**9 + 7\n        self.p2, self.m2 = 37, 10**9 + 9\n        \n        char_map = {'A': 1, 'C': 2, 'G': 3, 'T': 4}\n        # Using .get with a default value handles potential invalid characters\n        s_int = [char_map.get(c, 0) for c in s]\n\n        self.powers1 = [1] * (self.n + 1)\n        self.hashes1 = [0] * (self.n + 1)\n        self.powers2 = [1] * (self.n + 1)\n        self.hashes2 = [0] * (self.n + 1)\n\n        for i in range(self.n):\n            self.powers1[i+1] = (self.powers1[i] * self.p1) % self.m1\n            self.hashes1[i+1] = (self.hashes1[i] * self.p1 + s_int[i]) % self.m1\n            self.powers2[i+1] = (self.powers2[i] * self.p2) % self.m2\n            self.hashes2[i+1] = (self.hashes2[i] * self.p2 + s_int[i]) % self.m2\n\n    def get_hash_pair(self, i: int, j: int) -> tuple[int, int]:\n        \"\"\"\n        Returns the hash pair for the substring s[i:j].\n        \"\"\"\n        length = j - i\n        if length = 0:\n            return (0, 0)\n        h1 = (self.hashes1[j] - (self.hashes1[i] * self.powers1[length]) % self.m1 + self.m1) % self.m1\n        h2 = (self.hashes2[j] - (self.hashes2[i] * self.powers2[length]) % self.m2 + self.m2) % self.m2\n        return (h1, h2)\n\ndef find_palindromes(s: str, k: int) -> list[list[int]]:\n    \"\"\"\n    Finds all reverse-complement palindromic substrings of length at least k.\n    \"\"\"\n    n = len(s)\n    if n == 0:\n        return []\n\n    comp_map = str.maketrans(\"ACGT\", \"TGCA\")\n    s_comp = s.translate(comp_map)\n    s_rc = s_comp[::-1]\n\n    hasher_s = DualStringHasher(s)\n    hasher_rc = DualStringHasher(s_rc)\n    \n    results = []\n\n    # Iterate through all possible centers for even-length palindromes.\n    # Center is between index i-1 and i.\n    for i in range(1, n):\n        # Binary search for the maximum radius r.\n        low, high = 0, min(i, n - i)\n        max_r = 0\n        \n        while low = high:\n            r = (low + high) // 2\n            if r == 0:\n                low = r + 1\n                continue\n\n            # Substring s[i-r:i]\n            hash1 = hasher_s.get_hash_pair(i - r, i)\n            # The reverse complement of s[i:i+r] is found in s_rc\n            # at index n-(i+r) with length r => s_rc[n-i-r : n-i]\n            hash2 = hasher_rc.get_hash_pair(n - i - r, n - i)\n\n            if hash1 == hash2:\n                max_r = r\n                low = r + 1\n            else:\n                high = r - 1\n        \n        # Collect all valid palindromes for this center\n        if max_r > 0:\n            # We need length 2r >= k, so r >= k/2\n            min_r_for_k = (k + 1) // 2\n            for r in range(min_r_for_k, max_r + 1):\n                start_index = i - r\n                length = 2 * r\n                results.append([start_index, length])\n    \n    # Sort results by start index, then by length\n    results.sort()\n    \n    return results\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the provided test suite.\n    \"\"\"\n    test_cases = [\n        (\"ATCGAT\", 4),\n        (\"AAAAAA\", 3),\n        (\"CGAATTCG\", 4),\n        (\"AT\", 2),\n        (\"ATAT\", 2),\n    ]\n\n    all_results = []\n    for s, k in test_cases:\n        case_result = find_palindromes(s, k)\n        all_results.append(case_result)\n\n    # Format the output string exactly as required, with no spaces.\n    # str(all_results) would introduce spaces, so we build it manually.\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```", "id": "2386095"}, {"introduction": "Beyond data analysis, computational methods are essential for designing biological experiments. This hands-on problem challenges you to design an optimal strategy for covering a circular genome using a series of Polymerase Chain Reaction (PCR) amplicons, minimizing experimental redundancy. In doing so, you will discover how the divide-and-conquer mindset extends to solve optimization problems through dynamic programming, a technique that is central to many landmark algorithms in bioinformatics [@problem_id:2386122].", "problem": "You are given a circular deoxyribonucleic acid (DNA) plasmid that you may linearize at position $0$ to obtain a linear sequence $S$ of length $N$ over the alphabet $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$. You need to design a divide-and-conquer algorithm that selects a sequence of Polymerase Chain Reaction (PCR) amplicons that covers the entire linearized sequence from position $0$ to position $N-1$ with minimal total overlap, under biologically motivated primer validity constraints.\n\nA primer is a contiguous subsequence of fixed length $k\\_p$ (in nucleotides). A position $p$ is a valid primer start if the $k\\_p$-mer $S[p:p+k\\_p]$ satisfies all of the following:\n1. The guanine/cytosine (GC) fraction, defined as $(\\#\\text{G}+\\#\\text{C})/k\\_p$, lies within a closed interval $[g\\_{\\min}, g\\_{\\max}]$.\n2. The melting temperature $T\\_m$ computed by the Wallace rule, defined as $T\\_m = 2(\\#\\text{A}+\\#\\text{T}) + 4(\\#\\text{G}+\\#\\text{C})$, lies within a closed interval $[t\\_{\\min}, t\\_{\\max}]$ in degrees Celsius (express all internal temperatures in degrees Celsius).\n3. The maximum homopolymer run length in the $k\\_p$-mer (that is, the maximum count of identical consecutive nucleotides) is at most $h\\_{\\max}$.\n\nWe define two sets of valid primer starts: the set $F$ of valid forward primer starts and the set $R$ of valid reverse primer starts. For the purposes of this computational model, validity for $R$ is checked on the same sequence $S$ using the same criteria, which is scientifically sound because GC fraction, homopolymer runs, and Wallace-rule melting temperature are invariant under reverse complementation.\n\nAn amplicon is defined by a pair $(a,b)$ with $a \\in F$, $b \\in R$, and $a  b$, and it spans indices $[a, b + k\\_p - 1]$ inclusive. Its length in nucleotides is $L = (b + k\\_p) - a$. Only amplicons whose length $L$ lies in the closed interval $[A\\_{\\min}, A\\_{\\max}]$ are allowed.\n\nA covering set of amplicons is an ordered list $((a\\_1,b\\_1), \\dots, (a\\_m,b\\_m))$ such that:\n- $a\\_1 = 0$ and $b\\_m = N - k\\_p$,\n- For each $i \\in \\{1, \\dots, m-1\\}$, the next amplicon starts no later than the end of the current one, that is $a\\_{i+1} \\le b\\_i + k\\_p$, and strictly advances, that is $a\\_{i+1} \\ge a\\_i + 1$ (no stalling),\n- Each $L\\_i = (b\\_i + k\\_p) - a\\_i$ lies in $[A\\_{\\min}, A\\_{\\max}]$.\n\nThe overlap between consecutive amplicons $i$ and $i+1$ is defined as $\\max\\{0, (b\\_i + k\\_p) - a\\_{i+1}\\}$. The objective is to minimize the total overlap, which is the sum over all consecutive pairs.\n\nYour task is to implement a divide-and-conquer algorithm that, given $S$ and the parameters, computes a covering set of amplicons achieving the minimal total overlap and outputs the list of the forward primer start positions $(a\\_1, a\\_2, \\dots, a\\_m)$. If multiple optimal solutions exist, return the lexicographically smallest list of forward starts. If no valid covering exists, return the empty list.\n\nThe program must be self-contained and rely only on the given parameters and test sequences below. All internal temperature computations must be in degrees Celsius; no other physical units or angles are required in the output. The final outputs are lists of integers (forward primer start positions), one list per test case.\n\nTest suite:\n- Case $1$:\n  - $S =$ the string formed by repeating $\\text{ATGC}$ exactly $30$ times, so $N = 120$.\n  - $k\\_p = 8$.\n  - $g\\_{\\min} = 0.5$, $g\\_{\\max} = 0.5$.\n  - $t\\_{\\min} = 24$, $t\\_{\\max} = 24$.\n  - $h\\_{\\max} = 3$.\n  - $A\\_{\\min} = 40$, $A\\_{\\max} = 40$.\n- Case $2$:\n  - $S =$ the concatenation of $\\text{ATGC}$ repeated $15$ times, then $\\text{AAAAAA}$, then $\\text{ATGC}$ repeated $5$ times. This yields $N = 86$.\n  - $k\\_p = 8$.\n  - $g\\_{\\min} = 0.5$, $g\\_{\\max} = 0.5$.\n  - $t\\_{\\min} = 24$, $t\\_{\\max} = 24$.\n  - $h\\_{\\max} = 2$.\n  - $A\\_{\\min} = 28$, $A\\_{\\max} = 32$.\n- Case $3$:\n  - $S =$ a string of $\\text{A}$ repeated $26$ times, so $N = 26$.\n  - $k\\_p = 8$.\n  - $g\\_{\\min} = 0.5$, $g\\_{\\max} = 0.6$.\n  - $t\\_{\\min} = 20$, $t\\_{\\max} = 40$.\n  - $h\\_{\\max} = 2$.\n  - $A\\_{\\min} = 24$, $A\\_{\\max} = 30$.\n\nFinal output format:\nYour program should produce a single line containing the results for all cases as a comma-separated list enclosed in square brackets. Each case’s result is itself a list of integers (possibly empty) enclosed in square brackets. For example, a valid format is $[\\,[0,40,80],\\,[0,29,58],\\,[\\,]\\,]$.\n\nYour program must compute and output, in this exact single-line format, the lists of optimal forward primer starts for the three cases in the test suite. No other text should be printed.", "solution": "The user has presented a problem in computational biology requiring the design of a divide-and-conquer algorithm to find an optimal set of PCR amplicons to cover a linear DNA sequence. The optimality is defined by minimizing the total overlap between consecutive amplicons, subject to a series of biochemical and physical constraints.\n\nBefore proceeding, a critical validation of the problem statement is required.\n\n### Step 1: Extract Givens\n- **Sequence:** A linear DNA sequence $S$ of length $N$ over the alphabet $\\{\\text{A, C, G, T}\\}$.\n- **Primer Length:** A fixed integer $k_p$.\n- **Primer Validity Constraints:** A primer starting at position $p$ (the $k_p$-mer $S[p:p+k_p]$) is valid if:\n    1.  Its Guanine-Cytosine (GC) fraction is in $[g_{\\min}, g_{\\max}]$.\n    2.  Its melting temperature $T_m = 2(\\#\\text{A}+\\#\\text{T}) + 4(\\#\\text{G}+\\#\\text{C})$ is in $[t_{\\min}, t_{\\max}]$.\n    3.  Its maximum homopolymer run length is at most $h_{\\max}$.\n- **Primer Sets:** $F$ (forward primer starts) and $R$ (reverse primer starts) are sets of positions $p$ where the primer is valid. The problem states the same criteria apply to both, which is scientifically sound for the given metrics.\n- **Amplicon Definition:** An amplicon is a pair $(a, b)$ where $a \\in F$, $b \\in R$, $a  b$. It spans indices $[a, b+k_p-1]$. Its length $L = (b+k_p)-a$ must be in $[A_{\\min}, A_{\\max}]$.\n- **Covering Set:** An ordered list of amplicons $((a_1, b_1), \\dots, (a_m, b_m))$ must satisfy:\n    1.  $a_1 = 0$ and $b_m = N-k_p$.\n    2.  Successive amplicons must connect and advance: $a_{i+1} \\in [a_i+1, b_i+k_p]$.\n- **Objective:** Minimize the total overlap, defined as $\\sum_{i=1}^{m-1} \\max\\{0, (b_i+k_p) - a_{i+1}\\}$.\n- **Output:** The list of forward primer start positions $(a_1, \\dots, a_m)$.\n- **Tie-breaking:** If multiple solutions have the same minimal overlap, return the one with the lexicographically smallest list of forward starts.\n- **No Solution:** If no valid covering exists, return an empty list.\n- **Algorithmic Constraint:** The algorithm must be a \"divide-and-conquer\" strategy.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientific Grounding:** The problem is well-grounded in molecular biology concepts. PCR, primers, amplicons, GC content, melting temperature (via the Wallace rule), and homopolymer constraints are fundamental to primer design. The model is a simplification, but it is scientifically sound for a computational problem.\n2.  **Well-Posedness and Completeness:** The problem is mathematically well-defined. It specifies the input, all constraints, a clear objective function, and rules for tie-breaking and non-existence of a solution. It is a classic optimization problem that can be modeled as finding a shortest path on a Directed Acyclic Graph (DAG).\n3.  **Algorithmic Constraint Analysis:** The problem requires a \"divide-and-conquer\" (D) algorithm. This type of problem structure—finding an optimal path that minimizes a sum of costs—is canonically solved using dynamic programming (DP). Standard D algorithms, which rely on solving non-overlapping subproblems, are not a natural fit because the optimal solution for a sub-problem (e.g., covering a segment of the sequence) is dependent on the state at its boundary, which breaks subproblem independence. However, dynamic programming can be viewed as an extension of divide-and-conquer that uses memoization or tabulation to handle overlapping subproblems. A recursive, memoized implementation of a DP solution directly follows a D structure. Therefore, interpreting the directive as allowing a dynamic programming solution is a reasonable and correct approach. We will proceed with a DP solution, which adheres to the spirit of the \"divide-and-conquer\" directive.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is scientifically grounded, well-posed, and all necessary information is provided. We will proceed with a solution based on dynamic programming.\n\n### Solution Design\nThe problem can be modeled as finding the shortest path in a DAG. The nodes of the graph are the valid forward primer start positions. An edge exists from a node $u$ to a node $v$ if a valid amplicon starting at $u$ can cover the sequence up to or beyond $v$, allowing a new amplicon to start at $v$. The weight of the edge is the overlap.\n\n**1. Pre-computation of Valid Primer Sites**\nFirst, we identify all positions $p \\in [0, N-k_p]$ that can serve as valid primer starts. We define a function `is_valid_primer` that checks the GC content, melting temperature, and homopolymer run constraints for a given $k_p$-mer. We iterate through all possible start positions in $S$ and build a sorted list of these valid sites, which we denote as $P_{\\text{valid}}$. If $0 \\notin P_{\\text{valid}}$ or $N-k_p \\notin P_{\\text{valid}}$, no solution is possible.\n\n**2. Dynamic Programming Formulation**\nWe will use dynamic programming to find the path with minimum total overlap. Let $C[v]$ be the minimum total overlap required to cover the sequence with a chain of amplicons whose last forward primer starts at $v \\in P_{\\text{valid}}$. Let $\\Pi[v]$ store the corresponding list of forward primer starts $(a_1, \\dots, a_k=v)$.\n\n- **Initialization:**\n  For the starting primer at position $a_1=0$:\n  - $C[0] = 0$\n  - $\\Pi[0] = [0]$\n  For all other $v \\in P_{\\text{valid}}$, $v>0$:\n  - $C[v] = \\infty$\n  - $\\Pi[v] = []$\n\n- **Recurrence:**\n  We iterate through the valid primer sites $u \\in P_{\\text{valid}}$ in increasing order. For each $u$ for which we have found a valid path (i.e., $C[u]  \\infty$), we explore all possible next forward primers $v \\in P_{\\text{valid}}$ with $v > u$.\n  For each pair $(u, v)$, we must calculate the minimum possible overlap for a transition. This requires choosing a reverse primer $b \\in P_{\\text{valid}}$ to form an amplicon $(u, b)$ such that:\n  1. The amplicon is valid: its length $L=(b+k_p)-u$ is in $[A_{\\min}, A_{\\max}]$.\n  2. The next primer start $v$ is reachable: $u  v \\le b+k_p$.\n  To minimize overlap for the transition $u \\to v$, which is $(b+k_p)-v$, we must choose the smallest valid $b$ that satisfies all constraints.\n  \n  The constraints on $b$ for a transition from $u$ to $v$ are:\n  - $b \\in P_{\\text{valid}}$\n  - $b > u$\n  - From amplicon length: $u+A_{\\min}-k_p \\le b \\le u+A_{\\max}-k_p$\n  - From reachability of $v$: $b \\ge v-k_p$\n\n  Let $b^*$ be the smallest value in $P_{\\text{valid}}$ satisfying these conditions. If such a $b^*$ exists, the overlap is $\\text{cost}(u,v) = (b^*+k_p) - v$. The total cost to reach $v$ via $u$ is $C_{\\text{new}} = C[u] + \\text{cost}(u,v)$, and the new path is $\\Pi_{\\text{new}} = \\Pi[u] + [v]$.\n\n- **Update Step with Tie-breaking:**\n  We update the entry for $v$ if the new path is better. A path is better if it has a lower cost, or if it has the same cost but is lexicographically smaller.\n  $$ \\text{if } (C_{\\text{new}}  C[v]) \\text{ or } (C_{\\text{new}} == C[v] \\text{ and } \\Pi_{\\text{new}}  \\Pi[v]): $$\n  $$ \\quad C[v] = C_{\\text{new}} $$\n  $$ \\quad \\Pi[v] = \\Pi_{\\text{new}} $$\n\n**3. Final Solution Reconstruction**\nAfter computing the costs and paths to all reachable nodes, we must identify the complete optimal path. A valid covering must end with an amplicon $(a_m, b_m)$ where $b_m = N-k_p$. The final forward primer $a_m$ must satisfy:\n1. $a_m \\in P_{\\text{valid}}$\n2. The amplicon $(a_m, N-k_p)$ is valid. Its length must be in $[A_{\\min}, A_{\\max}]$, which implies $N-A_{\\max} \\le a_m \\le N-A_{\\min}$.\n\nWe find all such valid final positions $a_m$ for which a path exists ($C[a_m]  \\infty$). Among these candidates, we select the one that corresponds to the minimum total overlap $C[a_m]$. If there is a tie in cost, we choose the candidate whose path $\\Pi[a_m]$ is lexicographically smallest. If no such valid final position can be reached, no solution exists.\n\nThis DP approach systematically explores all valid amplicon chains and is guaranteed to find the optimal one according to the specified criteria.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"S\": \"ATGC\" * 30, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.5,\n            \"t_min\": 24, \"t_max\": 24, \"h_max\": 3, \"A_min\": 40, \"A_max\": 40\n        },\n        # Case 2\n        {\n            \"S\": \"ATGC\" * 15 + \"AAAAAA\" + \"ATGC\" * 5, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.5,\n            \"t_min\": 24, \"t_max\": 24, \"h_max\": 2, \"A_min\": 28, \"A_max\": 32\n        },\n        # Case 3\n        {\n            \"S\": \"A\" * 26, \"k_p\": 8, \"g_min\": 0.5, \"g_max\": 0.6,\n            \"t_min\": 20, \"t_max\": 40, \"h_max\": 2, \"A_min\": 24, \"A_max\": 30\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = find_optimal_covering(**params)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # e.g., [[0,40,80],[0,28,56],[]]\n    result_strs = []\n    for res in results:\n        result_strs.append('[' + ','.join(map(str, res)) + ']')\n    \n    print(f\"[{','.join(result_strs)}]\")\n\ndef get_homopolymer_run(seq):\n    \"\"\"Calculates the maximum length of a homopolymer run in a sequence.\"\"\"\n    if not seq:\n        return 0\n    max_run = 0\n    current_run = 0\n    current_char = ''\n    for char in seq:\n        if char == current_char:\n            current_run += 1\n        else:\n            max_run = max(max_run, current_run)\n            current_char = char\n            current_run = 1\n    max_run = max(max_run, current_run)\n    return max_run\n\ndef is_valid_primer(subsequence, k_p, g_min, g_max, t_min, t_max, h_max):\n    \"\"\"Checks if a given k-mer subsequence is a valid primer.\"\"\"\n    gc_count = subsequence.count('G') + subsequence.count('C')\n    gc_frac = gc_count / k_p\n    if not (g_min = gc_frac = g_max):\n        return False\n    \n    at_count = k_p - gc_count\n    tm = 2 * at_count + 4 * gc_count\n    if not (t_min = tm = t_max):\n        return False\n        \n    hp_run = get_homopolymer_run(subsequence)\n    if hp_run > h_max:\n        return False\n        \n    return True\n\ndef find_optimal_covering(S, k_p, g_min, g_max, t_min, t_max, h_max, A_min, A_max):\n    \"\"\"\n    Implements the dynamic programming algorithm to find the optimal amplicon covering.\n    \"\"\"\n    N = len(S)\n    \n    # Step 1: Pre-compute valid primer sites\n    valid_sites = []\n    for p in range(N - k_p + 1):\n        sub = S[p : p + k_p]\n        if is_valid_primer(sub, k_p, g_min, g_max, t_min, t_max, h_max):\n            valid_sites.append(p)\n    \n    valid_sites_set = set(valid_sites)\n    \n    # Check if start and end conditions are even possible\n    if 0 not in valid_sites_set or (N - k_p) not in valid_sites_set:\n        return []\n\n    # Step 2: Dynamic Programming\n    costs = {p: float('inf') for p in valid_sites}\n    paths = {p: [] for p in valid_sites}\n    \n    costs[0] = 0\n    paths[0] = [0]\n    \n    # Main DP loop\n    for u in valid_sites:\n        if costs[u] == float('inf'):\n            continue\n            \n        # Iterate over all possible next forward primers v\n        # Find start index for v > u\n        v_start_idx = np.searchsorted(valid_sites, u, side='right')\n        for v in valid_sites[v_start_idx:]:\n            # Calculate minimum overlap for transition u -> v\n            # Find the best reverse primer b*\n            b_min_req = max(u + 1, u + A_min - k_p, v - k_p)\n            b_max_req = u + A_max - k_p\n            \n            # Find smallest b in valid_sites within [b_min_req, b_max_req]\n            b_start_idx = np.searchsorted(valid_sites, b_min_req, side='left')\n            \n            if b_start_idx  len(valid_sites):\n                b_star = valid_sites[b_start_idx]\n                if b_star = b_max_req:\n                    overlap = (b_star + k_p) - v\n                    new_cost = costs[u] + overlap\n                    new_path = paths[u] + [v]\n                    \n                    # Update DP table if a better path is found (cost or lexicographical)\n                    if new_cost  costs[v] or (new_cost == costs[v] and new_path  paths[v]):\n                        costs[v] = new_cost\n                        paths[v] = new_path\n\n    # Step 3: Reconstruct final solution\n    best_final_path = []\n    min_final_cost = float('inf')\n    \n    # Find all valid candidates for the last forward primer a_m\n    b_m = N - k_p\n    a_m_min = N - A_max\n    a_m_max = N - A_min\n    \n    final_candidates = []\n    for a_m in valid_sites:\n        if a_m_min = a_m = a_m_max and a_m  b_m and costs[a_m] != float('inf'):\n            final_candidates.append(a_m)\n\n    if not final_candidates:\n        return []\n\n    # Find the minimum cost among all valid final paths\n    for a_m in final_candidates:\n        min_final_cost = min(min_final_cost, costs[a_m])\n\n    if min_final_cost == float('inf'):\n        return []\n    \n    # Among all paths with minimum cost, find the lexicographically smallest one\n    best_paths_for_min_cost = []\n    for a_m in final_candidates:\n        if costs[a_m] == min_final_cost:\n            best_paths_for_min_cost.append(paths[a_m])\n\n    return min(best_paths_for_min_cost)\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2386122"}]}