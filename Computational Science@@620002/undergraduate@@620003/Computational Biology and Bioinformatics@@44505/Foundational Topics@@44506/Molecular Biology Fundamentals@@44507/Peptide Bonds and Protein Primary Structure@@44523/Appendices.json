{"hands_on_practices": [{"introduction": "A protein's primary sequence is far more than a simple string of letters; it contains the fundamental information that dictates its structure and function. This exercise introduces the powerful concept of using computational models, or \"proxies,\" to estimate biophysical properties like stability directly from the amino acid sequence. Using the well-known Kyte-Doolittle hydropathy scale as a basis, you'll build a simplified nearest-neighbor stability model. By systematically simulating every possible single-point mutation and evaluating its effect on this stability proxy, you will gain practical experience with *in silico* mutational scanning and learn to quantify a sequence's overall \"fragility.\" [@problem_id:2412732]", "problem": "You are given a formal definition of a primary-sequence-based stability proxy for proteins and a corresponding fragility metric. Let the primary structure be a string over the standard $20$-letter amino acid alphabet $\\mathcal{A}=\\{\\text{A},\\text{R},\\text{N},\\text{D},\\text{C},\\text{Q},\\text{E},\\text{G},\\text{H},\\text{I},\\text{L},\\text{K},\\text{M},\\text{F},\\text{P},\\text{S},\\text{T},\\text{W},\\text{Y},\\text{V}\\}$. Define a hydropathy function $h:\\mathcal{A}\\to\\mathbb{R}$ using the Kyte–Doolittle hydropathy index values as follows: $h(\\text{A})=1.8$, $h(\\text{R})=-4.5$, $h(\\text{N})=-3.5$, $h(\\text{D})=-3.5$, $h(\\text{C})=2.5$, $h(\\text{Q})=-3.5$, $h(\\text{E})=-3.5$, $h(\\text{G})=-0.4$, $h(\\text{H})=-3.2$, $h(\\text{I})=4.5$, $h(\\text{L})=3.8$, $h(\\text{K})=-3.9$, $h(\\text{M})=1.9$, $h(\\text{F})=2.8$, $h(\\text{P})=-1.6$, $h(\\text{S})=-0.8$, $h(\\text{T})=-0.7$, $h(\\text{W})=-0.9$, $h(\\text{Y})=-1.3$, $h(\\text{V})=4.2$.\n\nFor a sequence $s=s_1 s_2\\cdots s_L$ of length $L$, define the stability proxy $E(s)$ by the nearest-neighbor interaction across peptide bonds:\n$$\nE(s)=\\sum_{i=1}^{L-1} h(s_i)\\,h(s_{i+1}).\n$$\nBy convention, for $L=1$ the empty sum equals $0$ so that $E(s)=0$.\n\nA single-point mutant $s^{(i\\to x)}$ is obtained by replacing exactly one position $i\\in\\{1,2,\\dots,L\\}$ with an amino acid $x\\in\\mathcal{A}\\setminus\\{s_i\\}$. For a nonnegative destabilization threshold $\\tau\\ge 0$, a single-point mutation is considered destabilizing if and only if\n$$\nE\\bigl(s^{(i\\to x)}\\bigr) < E(s)-\\tau.\n$$\n\nDefine the primary sequence fragility $F(s,\\tau)$ to be the fraction of all single-point mutants that are destabilizing:\n$$\nF(s,\\tau) = \\frac{D(s,\\tau)}{19\\,L},\n$$\nwhere $D(s,\\tau)$ is the count of destabilizing single-point mutants among the $19\\,L$ possible single substitutions. The required output for each test case is the value of $F(s,\\tau)$ as a decimal number rounded to $6$ decimal places. Do not use a percent sign; report the fraction as a decimal.\n\nYour task is to write a complete, runnable program that, for each test case below, computes $F(s,\\tau)$ according to the definitions above. The set of test cases is:\n\n- General case with moderate threshold: $s=\\text{\"MKTIIALSYIFCLVFAD\"}$, $\\tau=0.25$.\n- Boundary case with $L=1$: $s=\\text{\"G\"}$, $\\tau=0.0$.\n- Hydrophobic stretch: $s=\\text{\"VVVV\"}$, $\\tau=0.0$.\n- Alternating hydrophobic/hydrophilic pattern: $s=\\text{\"DVDVDV\"}$, $\\tau=0.0$.\n- Large threshold (should yield zero fragility): $s=\\text{\"ACDEFGHIKLMNPQRSTVWY\"}$, $\\tau=100.0$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\dots]$). The results must appear in the same order as the test cases above and each value must be rounded to $6$ decimal places.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n\n-   **Alphabet**: $\\mathcal{A}=\\{\\text{A},\\text{R},\\text{N},\\text{D},\\text{C},\\text{Q},\\text{E},\\text{G},\\text{H},\\text{I},\\text{L},\\text{K},\\text{M},\\text{F},\\text{P},\\text{S},\\text{T},\\text{W},\\text{Y},\\text{V}\\}$, a set of $20$ standard amino acids.\n-   **Hydropathy Function**: $h:\\mathcal{A}\\to\\mathbb{R}$ is defined by the Kyte–Doolittle index: $h(\\text{A})=1.8$, $h(\\text{R})=-4.5$, $h(\\text{N})=-3.5$, $h(\\text{D})=-3.5$, $h(\\text{C})=2.5$, $h(\\text{Q})=-3.5$, $h(\\text{E})=-3.5$, $h(\\text{G})=-0.4$, $h(\\text{H})=-3.2$, $h(\\text{I})=4.5$, $h(\\text{L})=3.8$, $h(\\text{K})=-3.9$, $h(\\text{M})=1.9$, $h(\\text{F})=2.8$, $h(\\text{P})=-1.6$, $h(\\text{S})=-0.8$, $h(\\text{T})=-0.7$, $h(\\text{W})=-0.9$, $h(\\text{Y})=-1.3$, $h(\\text{V})=4.2$.\n-   **Stability Proxy**: For a sequence $s=s_1 s_2\\cdots s_L$ of length $L$, the stability proxy is $E(s)=\\sum_{i=1}^{L-1} h(s_i)\\,h(s_{i+1})$. For $L=1$, $E(s)=0$.\n-   **Destabilizing Mutation**: A single-point mutant $s^{(i\\to x)}$ (residue at position $i$ changed to $x$) is destabilizing relative to a threshold $\\tau\\ge 0$ if $E\\bigl(s^{(i\\to x)}\\bigr) < E(s)-\\tau$.\n-   **Fragility Metric**: The primary sequence fragility $F(s,\\tau)$ is the fraction of all $19\\,L$ single-point mutants that are destabilizing: $F(s,\\tau) = \\frac{D(s,\\tau)}{19\\,L}$, where $D(s,\\tau)$ is the count of such destabilizing mutants.\n-   **Test Cases**:\n    1.  $s=\\text{\"MKTIIALSYIFCLVFAD\"}$, $\\tau=0.25$\n    2.  $s=\\text{\"G\"}$, $\\tau=0.0$\n    3.  $s=\\text{\"VVVV\"}$, $\\tau=0.0$\n    4.  $s=\\text{\"DVDVDV\"}$, $\\tau=0.0$\n    5.  $s=\\text{\"ACDEFGHIKLMNPQRSTVWY\"}$, $\\tau=100.0$\n-   **Output Format**: A single line with a comma-separated list of results, rounded to $6$ decimal places, enclosed in square brackets.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is evaluated against the required criteria.\n\n-   **Scientifically Grounded**: The problem utilizes the established Kyte–Doolittle hydropathy scale. The stability proxy is a simplified nearest-neighbor interaction model, a common pedagogical tool in computational biology for illustrating sequence-based properties. While not a complete physical model, it is based on sound scientific concepts and is not pseudoscientific.\n-   **Well-Posed**: All terms and functions ($h, E, F$) are defined with mathematical precision. The instructions provide a clear, deterministic procedure for calculating the fragility for any given sequence $s$ and threshold $\\tau$. A unique solution exists and can be algorithmically computed.\n-   **Objective**: The problem is stated in formal, objective language without subjective or opinion-based assertions.\n\nThe problem exhibits none of the specified flaws. It is scientifically sound within the context of a simplified model, mathematically formalizable, complete, and algorithmically solvable.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. A solution will be developed.\n\n### Solution Derivation\n\nThe task is to compute the fragility $F(s,\\tau)$ for a set of given sequences $s$ and destabilization thresholds $\\tau$. The fragility is the fraction of single-point mutations that are destabilizing. A mutation at position $i$ from residue $s_i$ to $x$ is destabilizing if the change in stability energy satisfies a specific inequality.\n\nA naive approach would be to generate every one of the $19\\,L$ mutant sequences, calculate the stability proxy $E(s')$ for each, and compare it to the stability proxy $E(s)$ of the original sequence. For a sequence of length $L$, calculating $E(s)$ takes $O(L)$ operations. This would lead to a total complexity of $O(L) \\times 19L = O(L^2)$, which is inefficient.\n\nA more computationally efficient approach is to calculate the change in stability, $\\Delta E = E(s^{(i\\to x)}) - E(s)$, directly. The sum defining $E(s)$ involves only nearest-neighbor terms. When a residue $s_i$ is mutated to $x$, only the terms involving $s_i$ are affected. Let $h_{old} = h(s_i)$ and $h_{new} = h(x)$.\n\nThe change $\\Delta E$ depends on the position $i$ of the mutation (using $1$-based indexing for this derivation):\n\n1.  **Interior position ($1 < i < L$):** The original terms involving $s_i$ are $h(s_{i-1})h(s_i) + h(s_i)h(s_{i+1})$. The new terms are $h(s_{i-1})h(x) + h(x)h(s_{i+1})$.\n    The change is:\n    $$\n    \\Delta E = \\left( h(s_{i-1})h_{new} + h_{new}h(s_{i+1}) \\right) - \\left( h(s_{i-1})h_{old} + h_{old}h(s_{i+1}) \\right) = (h_{new} - h_{old}) \\left( h(s_{i-1}) + h(s_{i+1}) \\right).\n    $$\n\n2.  **First position ($i=1, L > 1$):** The only affected term is $h(s_1)h(s_2)$.\n    $$\n    \\Delta E = h_{new}h(s_2) - h_{old}h(s_2) = (h_{new} - h_{old})h(s_2).\n    $$\n\n3.  **Last position ($i=L, L > 1$):** The only affected term is $h(s_{L-1})h(s_L)$.\n    $$\n    \\Delta E = h(s_{L-1})h_{new} - h(s_{L-1})h_{old} = (h_{new} - h_{old})h(s_{L-1}).\n    $$\n\n4.  **Sequence of length one ($L=1$):** By definition, $E(s)=0$ for any sequence of length $1$. Any single-point mutant is also a sequence of length $1$, so its stability is also $0$. Thus, $\\Delta E = 0$ for all mutations.\n\nThe condition for a destabilizing mutation is $E(s^{(i\\to x)}) < E(s) - \\tau$. This can be rewritten using $\\Delta E$ as $E(s) + \\Delta E < E(s) - \\tau$, which simplifies to:\n$$\n\\Delta E < -\\tau.\n$$\nThis allows us to check the condition for each mutation in $O(1)$ time, after an initial pass to pre-calculate hydropathy values for neighbors if needed. The overall algorithm becomes $O(L)$.\n\n### Algorithm\n\nFor each test case $(s, \\tau)$:\n1.  Initialize a counter for destabilizing mutations, $D \\leftarrow 0$.\n2.  Let $L$ be the length of sequence $s$.\n3.  If $L=1$, the problem states $E(s)=0$ for any single-residue sequence. Then $\\Delta E = 0$. The condition for destabilization is $0 < -\\tau$. Since $\\tau \\ge 0$, this is never true. Thus, $D=0$ and $F(s, \\tau)=0$.\n4.  If $L > 1$, iterate through each position $i$ from $0$ to $L-1$ (using $0$-based indexing):\n    a. Let $s_i$ be the original amino acid at position $i$.\n    b. Determine the hydropathy sum of its neighbors, `context_h`:\n       - If $i=0$: `context_h` = $h(s_1)$.\n       - If $i=L-1$: `context_h` = $h(s_{L-2})$.\n       - If $0 < i < L-1$: `context_h` = $h(s_{i-1}) + h(s_{i+1})$.\n    c. Let $h_{old} = h(s_i)$.\n    d. Iterate through each amino acid $x$ in the alphabet $\\mathcal{A}$:\n       i. If $x$ is the same as $s_i$, continue to the next amino acid.\n       ii. Let $h_{new} = h(x)$.\n       iii. Calculate $\\Delta E = (h_{new} - h_{old}) \\times \\text{context\\_h}$.\n       iv. If $\\Delta E < -\\tau$, increment the counter $D$.\n5.  After iterating through all positions and all possible substitutions, compute the fragility: $F(s, \\tau) = D / (19 \\times L)$. Handle the case $L=0$ to avoid division by zero, though not present in test cases.\n6.  The result must be rounded to $6$ decimal places.\n\nThis optimized algorithm will be implemented to solve the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the protein primary sequence fragility problem.\n    \"\"\"\n    # Define the Kyte-Doolittle hydropathy index values.\n    HYDROPATHY_MAP = {\n        'A': 1.8, 'R': -4.5, 'N': -3.5, 'D': -3.5, 'C': 2.5,\n        'Q': -3.5, 'E': -3.5, 'G': -0.4, 'H': -3.2, 'I': 4.5,\n        'L': 3.8, 'K': -3.9, 'M': 1.9, 'F': 2.8, 'P': -1.6,\n        'S': -0.8, 'T': -0.7, 'W': -0.9, 'Y': -1.3, 'V': 4.2\n    }\n    AMINO_ACIDS = sorted(HYDROPATHY_MAP.keys())\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MKTIIALSYIFCLVFAD\", 0.25),\n        (\"G\", 0.0),\n        (\"VVVV\", 0.0),\n        (\"DVDVDV\", 0.0),\n        (\"ACDEFGHIKLMNPQRSTVWY\", 100.0)\n    ]\n\n    results = []\n\n    for s, tau in test_cases:\n        L = len(s)\n        \n        # Per problem definition, for L=1, fragility is 0 as Delta E is always 0.\n        # Condition 0 < -tau is false for tau >= 0.\n        if L <= 1:\n            results.append(0.0)\n            continue\n            \n        destabilizing_mutant_count = 0\n        total_possible_mutants = 19 * L\n\n        # Iterate through each position i in the sequence s\n        for i in range(L):\n            original_aa = s[i]\n            h_old = HYDROPATHY_MAP[original_aa]\n\n            # Calculate the hydropathy sum of the neighbors (context)\n            context_h = 0.0\n            if i == 0:  # First position\n                context_h = HYDROPATHY_MAP[s[i+1]]\n            elif i == L - 1:  # Last position\n                context_h = HYDROPATHY_MAP[s[i-1]]\n            else:  # Interior position\n                context_h = HYDROPATHY_MAP[s[i-1]] + HYDROPATHY_MAP[s[i+1]]\n\n            # Iterate through all possible amino acid substitutions\n            for new_aa in AMINO_ACIDS:\n                if new_aa == original_aa:\n                    continue\n                \n                h_new = HYDROPATHY_MAP[new_aa]\n                \n                # Calculate the change in stability energy\n                delta_E = (h_new - h_old) * context_h\n                \n                # Check if the mutation is destabilizing\n                if delta_E < -tau:\n                    destabilizing_mutant_count += 1\n        \n        fragility = destabilizing_mutant_count / total_possible_mutants\n        results.append(round(fragility, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2412732"}, {"introduction": "Comparing protein sequences is a cornerstone of bioinformatics, enabling us to infer evolutionary relationships and predict functional similarities. However, a naive letter-by-letter comparison can miss deeper connections, as different amino acids often share crucial physicochemical properties. This practice challenges you to move beyond simple identity-based matching by first classifying amino acids into functional groups such as hydrophobic, polar, or charged. You will then apply the classic dynamic programming algorithm for finding the Longest Common Subsequence (LCS) to uncover the longest shared \"physicochemical\" pattern between two proteins. This exercise highlights how biological function can be conserved even as the exact primary sequence diverges over evolution. [@problem_id:2412673]", "problem": "You are given a fixed physicochemical classification function $M:\\mathcal{A}\\to\\{0,1,2,3,4,5,6\\}$ over the standard set $\\mathcal{A}$ of $20$ amino acids (single-letter codes), where two residues are considered a match if and only if they map to the same class under $M$. The mapping $M$ groups residues by coarse physicochemical properties as follows:\n- Class $0$ (aliphatic hydrophobic): A, V, L, I, M\n- Class $1$ (aromatic): F, W, Y\n- Class $2$ (polar uncharged): S, T, N, Q, C\n- Class $3$ (acidic): D, E\n- Class $4$ (basic): K, R, H\n- Class $5$ (small, glycine): G\n- Class $6$ (special conformational, proline): P\n\nFor a pair of primary sequences $X$ and $Y$ (strings over $\\mathcal{A}$), define their physicochemical class sequences $X'$ and $Y'$ by $X'[i]=M(X[i])$ and $Y'[j]=M(Y[j])$. The longest common physicochemical subsequence length $L(X,Y)$ is the maximum integer $k$ such that there exist strictly increasing index sequences $1\\le i_1&lt;i_2&lt;\\dots&lt;i_k\\le |X|$ and $1\\le j_1&lt;j_2&lt;\\dots&lt;j_k\\le |Y|$ with $X'[i_t]=Y'[j_t]$ for all $t\\in\\{1,\\dots,k\\}$. Here $|X|$ and $|Y|$ denote the lengths of $X$ and $Y$, respectively.\n\nTask: For each test case below, compute $L(X,Y)$, the length of the longest common physicochemical subsequence as defined above.\n\nTest suite (each item is an ordered pair $(X,Y)$):\n- Case $1$: $X=$ \"MTEYKLVVVGAGGVGKS\", $Y=$ \"GAGGVGKTCLLISYTTN\"\n- Case $2$: $X=$ \"DDEEEDD\", $Y=$ \"KKRHHK\"\n- Case $3$: $X=$ \"\", $Y=$ \"ACDE\"\n- Case $4$: $X=$ \"ACDEFGHIKLMNPQRSTVWY\", $Y=$ \"ACDEFGHIKLMNPQRSTVWY\"\n- Case $5$: $X=$ \"DEDE\", $Y=$ \"EEDD\"\n\nAnswer specification:\n- For each case, output the single integer $L(X,Y)$ (no other data types).\n- Aggregate the results for all cases, in order, into one list literal on a single line: a comma-separated list enclosed in square brackets, for example, \"[a,b,c,d,e]\" where $a,b,c,d,e$ are integers. No spaces should appear in the output.\n\nThere are no physical units involved. Your program must not read any input and must produce exactly one line of output in the specified format.", "solution": "The problem statement has been analyzed and is determined to be valid. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. The problem requires the computation of the length of the longest common subsequence between two protein sequences, not on the amino acid alphabet itself, but on a derived alphabet of physicochemical classes. This is a standard procedure in bioinformatics, combining a fundamental biological concept with a classic algorithm from computer science.\n\nThe solution is a two-step process: first, the transformation of the input amino acid sequences into sequences of physicochemical class indices, and second, the application of a dynamic programming algorithm to find the length of the longest common subsequence (LCS) of these transformed sequences.\n\nStep 1: Physicochemical Transformation\n\nThe problem defines a mapping function, $M$, from the alphabet of $20$ standard amino acids, $\\mathcal{A}$, to a set of integer class labels $\\{0, 1, 2, 3, 4, 5, 6\\}$. This mapping is defined as follows:\n- Class $0$ (aliphatic hydrophobic): $M(\\text{'A'}) = M(\\text{'V'}) = M(\\text{'L'}) = M(\\text{'I'}) = M(\\text{'M'}) = 0$\n- Class $1$ (aromatic): $M(\\text{'F'}) = M(\\text{'W'}) = M(\\text{'Y'}) = 1$\n- Class $2$ (polar uncharged): $M(\\text{'S'}) = M(\\text{'T'}) = M(\\text{'N'}) = M(\\text{'Q'}) = M(\\text{'C'}) = 2$\n- Class $3$ (acidic): $M(\\text{'D'}) = M(\\text{'E'}) = 3$\n- Class $4$ (basic): $M(\\text{'K'}) = M(\\text{'R'}) = M(\\text{'H'}) = 4$\n- Class $5$ (small, glycine): $M(\\text{'G'}) = 5$\n- Class $6$ (special conformational, proline): $M(\\text{'P'}) = 6$\n\nFor any given pair of input sequences, $X$ of length $m = |X|$ and $Y$ of length $n = |Y|$, we first compute their corresponding physicochemical class sequences, $X'$ and $Y'$. These are integer sequences constructed by applying the mapping $M$ to each residue:\n- $X' = [M(X_1), M(X_2), \\dots, M(X_m)]$\n- $Y' = [M(Y_1), M(Y_2), \\dots, M(Y_n)]$\n\nThe problem then reduces to finding the length of the longest common subsequence of $X'$ and $Y'$.\n\nStep 2: Longest Common Subsequence (LCS) Algorithm\n\nThe length of the LCS of sequences $X'$ and $Y'$ is computed using a standard dynamic programming approach. Let $dp[i][j]$ be the length of the longest common subsequence of the prefixes $X'[1..i]$ and $Y'[1..j]$. The value of $dp[i][j]$ can be computed using the following recurrence relation:\n\n$$\ndp[i][j] =\n\\begin{cases}\n0 & \\text{if } i=0 \\text{ or } j=0 \\\\\n1 + dp[i-1][j-1] & \\text{if } i,j > 0 \\text{ and } X'[i-1] = Y'[j-1] \\\\\n\\max(dp[i-1][j], dp[i][j-1]) & \\text{if } i,j > 0 \\text{ and } X'[i-1] \\neq Y'[j-1]\n\\end{cases}\n$$\n\nHere, the indices for the sequences $X'$ and $Y'$ are $0$-based, as is conventional in computational implementation, while the indices $i$ and $j$ for the $dp$ table range from $0$ to $m$ and $0$ to $n$, respectively. The base cases $dp[i][0] = 0$ and $dp[0][j] = 0$ for all $i, j$ establish that the LCS of any sequence with an empty sequence has length $0$. The final answer, the length of the LCS for the full sequences $X'$ and $Y'$, is given by $L(X, Y) = dp[m][n]$.\n\nThis procedure is applied to each test case provided. For example, in Case $1$:\n- $X = \\text{\"MTEYKLVVVGAGGVGKS\"}$\n- $Y = \\text{\"GAGGVGKTCLLISYTTN\"}$\n\nThe sequences are transformed into their class representations:\n- $X' = [0, 2, 3, 1, 4, 0, 0, 0, 0, 5, 0, 5, 5, 0, 5, 4, 2]$\n- $Y' = [5, 0, 5, 5, 0, 5, 4, 2, 2, 0, 0, 0, 2, 1, 2, 2, 2]$\n\nApplying the dynamic programming algorithm to $X'$ and $Y'$ (both of length $17$) yields an LCS length of $9$.\n\nThe same method gives the results for the other cases:\n- Case $2$: $X = \\text{\"DDEEEDD\"}$, $Y = \\text{\"KKRHHK\"}$. Transformed sequences are $X'=[3,3,3,3,3,3,3]$ and $Y'=[4,4,4,4,4,4]$. They share no common elements, so the LCS length is $0$.\n- Case $3$: $X = \\text{\"\"}$, $Y = \\text{\"ACDE\"}$. Since $X$ is an empty sequence, the LCS length is $0$.\n- Case $4$: $X = \\text{\"ACDEFGHIKLMNPQRSTVWY\"}$, $Y = \\text{\"ACDEFGHIKLMNPQRSTVWY\"}$. The sequences are identical, so their transformed sequences are also identical. The LCS length is the length of the sequence, which is $20$.\n- Case $5$: $X = \\text{\"DEDE\"}$, $Y = \\text{\"EEDD\"}$. Transformed sequences are $X'=[3,3,3,3]$ and $Y'=[3,3,3,3]$. They are identical, so the LCS length is $4$.\n\nThe final computed results for Cases 1 through 5 are $[9, 0, 0, 20, 4]$, respectively. The program below implements this logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the length of the longest common physicochemical subsequence for a suite of test cases.\n    \"\"\"\n\n    # Define the fixed physicochemical classification function M.\n    # A dictionary provides an efficient implementation of the mapping.\n    PHYSICOCHEMICAL_MAP = {\n        'A': 0, 'V': 0, 'L': 0, 'I': 0, 'M': 0,  # Class 0: Aliphatic hydrophobic\n        'F': 1, 'W': 1, 'Y': 1,                  # Class 1: Aromatic\n        'S': 2, 'T': 2, 'N': 2, 'Q': 2, 'C': 2,  # Class 2: Polar uncharged\n        'D': 3, 'E': 3,                          # Class 3: Acidic\n        'K': 4, 'R': 4, 'H': 4,                  # Class 4: Basic\n        'G': 5,                                  # Class 5: Glycine\n        'P': 6                                   # Class 6: Proline\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MTEYKLVVVGAGGVGKS\", \"GAGGVGKTCLLISYTTN\"), # Case 1\n        (\"DDEEEDD\", \"KKRHHK\"),                     # Case 2\n        (\"\", \"ACDE\"),                              # Case 3\n        (\"ACDEFGHIKLMNPQRSTVWY\", \"ACDEFGHIKLMNPQRSTVWY\"), # Case 4\n        (\"DEDE\", \"EEDD\"),                          # Case 5\n    ]\n    \n    def compute_lcs_length(X: str, Y: str) -> int:\n        \"\"\"\n        Calculates the length of the longest common physicochemical subsequence.\n        \n        Args:\n            X: The first protein sequence.\n            Y: The second protein sequence.\n            \n        Returns:\n            The integer length of the LCS of the transformed sequences.\n        \"\"\"\n        # Step 1: Transform amino acid sequences into physicochemical class sequences.\n        X_prime = [PHYSICOCHEMICAL_MAP[residue] for residue in X]\n        Y_prime = [PHYSICOCHEMICAL_MAP[residue] for residue in Y]\n        \n        m = len(X_prime)\n        n = len(Y_prime)\n\n        # Handle trivial case of empty sequences.\n        if m == 0 or n == 0:\n            return 0\n        \n        # Step 2: Compute LCS length using dynamic programming.\n        # Initialize a DP table of size (m+1) x (n+1) with zeros.\n        # dp[i][j] will store the LCS length of X_prime[:i] and Y_prime[:j].\n        dp = np.zeros((m + 1, n + 1), dtype=np.int32)\n        \n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # If the current elements match, extend the LCS from the previous subproblem.\n                if X_prime[i - 1] == Y_prime[j - 1]:\n                    dp[i, j] = 1 + dp[i - 1, j - 1]\n                # If they don't match, take the maximum LCS length from the two possible subproblems.\n                else:\n                    dp[i, j] = max(dp[i - 1, j], dp[i, j - 1])\n                    \n        # The final result is in the bottom-right corner of the table.\n        return int(dp[m, n])\n\n    results = []\n    for x_seq, y_seq in test_cases:\n        lcs_len = compute_lcs_length(x_seq, y_seq)\n        results.append(lcs_len)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2412673"}, {"introduction": "The central dogma describes the flow of information from DNA to protein, but computational bioinformatics allows us to reason in the reverse direction, a task crucial for gene design and evolutionary studies. This final exercise delves into \"back-translation,\" challenging you to deduce the most probable ancestral DNA sequence for a given protein sequence. The problem's complexity arises from the degeneracy of the genetic code and the biological phenomenon of \"codon usage bias\"—the preferential use of certain synonymous codons. You will implement a probabilistic model to make an optimal choice for each amino acid, bridging the gap between proteomics and genomics and offering a hands-on introduction to probabilistic modeling in molecular evolution. [@problem_id:2412742]", "problem": "You are given a protein primary structure, which is the ordered sequence of amino acid residues linked by peptide bonds. Assume translation follows the standard genetic code, and that for each amino acid there is a codon usage bias described by a probability distribution over its synonymous codons. Under the assumption that codon choices at different positions are conditionally independent given the amino acid sequence, define the probability of a deoxyribonucleic acid (DNA) coding sequence as the product of the codon probabilities chosen at each position. Your task is to compute, for each provided protein sequence, the most likely ancestral DNA coding sequence and the corresponding natural log-likelihood, given the codon usage bias table below.\n\nFormalization. Let the protein sequence have length $n$ with amino acids $a_1,a_2,\\dots,a_n$. For each amino acid $a_i$, let $\\mathcal{C}(a_i)$ denote its set of synonymous codons, and let $p(c\\mid a)$ denote the codon usage probability for codon $c\\in\\mathcal{C}(a)$ given amino acid $a$. A DNA coding sequence $c_1c_2\\dots c_n$ consistent with the protein sequence must satisfy $c_i\\in\\mathcal{C}(a_i)$ for all $i$. The probability of such a sequence is\n$$\nP(c_1c_2\\dots c_n\\mid a_1a_2\\dots a_n)=\\prod_{i=1}^{n} p(c_i\\mid a_i).\n$$\nThe most likely DNA coding sequence is any maximizer of the above product. In the event of a tie at any position (that is, multiple codons attain the same maximal probability for a given amino acid), break ties by choosing the lexicographically smallest codon under the alphabetical order $A\\lt C\\lt G\\lt T$.\n\nOutput requirements. For each protein sequence:\n- Compute the most likely DNA coding sequence $c_1c_2\\dots c_n$.\n- Compute its natural log-likelihood $\\log P(c_1c_2\\dots c_n\\mid a_1a_2\\dots a_n)=\\sum_{i=1}^{n}\\log p(c_i\\mid a_i)$.\n- Convert the DNA sequence into a single nonnegative integer using base-$4$ positional encoding with the mapping $A\\mapsto 0$, $C\\mapsto 1$, $G\\mapsto 2$, $T\\mapsto 3$. Specifically, for a DNA sequence $d_1d_2\\dots d_m$ of length $m$ (here $m=3n$), define digits $x_j\\in\\{0,1,2,3\\}$ by $x_j=0$ for $d_j=A$, $x_j=1$ for $d_j=C$, $x_j=2$ for $d_j=G$, and $x_j=3$ for $d_j=T$, and compute\n$$\nE(d_1d_2\\dots d_m)=\\sum_{j=1}^{m} x_j\\cdot 4^{m-j}.\n$$\nBy convention, for the empty sequence (that is, when $n=0$), take $E(\\,\\cdot\\,)=0$ and $\\log P(\\,\\cdot\\,)=0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces. For each test case, output first $E$ as an integer, then the natural log-likelihood rounded to $6$ decimal places, so the overall format is\n$$\n[\\;E_1,\\ell_1,E_2,\\ell_2,\\dots,E_k,\\ell_k\\;],\n$$\nwhere $\\ell_i$ denotes the rounded natural log-likelihood for test case $i$ and $k$ is the number of test cases.\n\nUse the following standard genetic code subsets and codon usage probabilities $p(c\\mid a)$, which sum to $1$ within each amino acid:\n\n- Lysine ($K$): $\\mathrm{AAA}: 0.5$, $\\mathrm{AAG}: 0.5$.\n- Phenylalanine ($F$): $\\mathrm{TTT}: 0.45$, $\\mathrm{TTC}: 0.55$.\n- Leucine ($L$): $\\mathrm{CTT}: 0.3$, $\\mathrm{CTC}: 0.1$, $\\mathrm{CTA}: 0.1$, $\\mathrm{CTG}: 0.3$, $\\mathrm{TTA}: 0.1$, $\\mathrm{TTG}: 0.1$.\n- Serine ($S$): $\\mathrm{TCT}: 0.19$, $\\mathrm{TCC}: 0.17$, $\\mathrm{TCA}: 0.15$, $\\mathrm{TCG}: 0.12$, $\\mathrm{AGC}: 0.20$, $\\mathrm{AGT}: 0.17$.\n- Glycine ($G$): $\\mathrm{GGT}: 0.16$, $\\mathrm{GGC}: 0.34$, $\\mathrm{GGA}: 0.25$, $\\mathrm{GGG}: 0.25$.\n- Methionine ($M$): $\\mathrm{ATG}: 1.0$.\n- Tryptophan ($W$): $\\mathrm{TGG}: 1.0$.\n\nTest suite. Apply your program to the following protein sequences (one-letter amino acid codes), in this order:\n- Case $1$: $\\text{\"MKW\"}$.\n- Case $2$: $\\text{\"LL\"}$.\n- Case $3$: the empty string $\\text{\"\"}$.\n- Case $4$: $\\text{\"SGS\"}$.\n- Case $5$: $\\text{\"F\"}$.\n\nAngle units are not applicable. No physical units are involved. The final output must follow the exact format described above, with the natural log-likelihoods rounded to $6$ decimal places.", "solution": "The problem requires us to determine the most likely ancestral deoxyribonucleic acid (DNA) coding sequence for a given protein primary structure, and to compute the natural log-likelihood of this sequence. This task is to be performed under a model of codon usage bias where codon choices are conditionally independent.\n\nThe problem is well-defined and requires a methodical application of probability theory and combinatorial optimization principles. The core of the problem lies in maximizing a product of probabilities. Let the protein sequence be $S_p = a_1a_2\\dots a_n$, where each $a_i$ is an amino acid. A corresponding DNA coding sequence is $S_d = c_1c_2\\dots c_n$, where each codon $c_i$ codes for the amino acid $a_i$. The probability of this DNA sequence, given the protein sequence, is defined as:\n$$\nP(S_d \\mid S_p) = P(c_1c_2\\dots c_n \\mid a_1a_2\\dots a_n) = \\prod_{i=1}^{n} p(c_i \\mid a_i)\n$$\nwhere $p(c_i \\mid a_i)$ is the conditional probability of observing codon $c_i$ given that it must encode amino acid $a_i$.\n\nOur objective is to find the DNA sequence $S_d^*$ that maximizes this probability. Since the natural logarithm function, $\\log(x)$, is monotonically increasing for $x > 0$, maximizing $P(S_d \\mid S_p)$ is equivalent to maximizing its natural logarithm, the log-likelihood $\\ell = \\log P(S_d \\mid S_p)$:\n$$\n\\ell = \\log \\left( \\prod_{i=1}^{n} p(c_i \\mid a_i) \\right) = \\sum_{i=1}^{n} \\log p(c_i \\mid a_i)\n$$\nThe assumption of conditional independence is critical: the choice of codon $c_i$ for amino acid $a_i$ does not depend on the choice of any other codon $c_j$ for $j \\neq i$. This allows us to decompose the global optimization problem into a set of $n$ independent local optimization problems. To maximize the sum, we must maximize each term independently. For each position $i$ from $1$ to $n$, we select the codon $c_i^*$ that maximizes the probability $p(c_i \\mid a_i)$:\n$$\nc_i^* = \\arg\\max_{c \\in \\mathcal{C}(a_i)} p(c \\mid a_i)\n$$\nwhere $\\mathcal{C}(a_i)$ is the set of synonymous codons for amino acid $a_i$.\n\nThe problem statement specifies a tie-breaking rule: if multiple codons for a given amino acid share the same maximal probability, the one that is lexicographically smallest (under the ordering $A < C < G < T$) must be chosen. This ensures that the most likely DNA sequence $S_d^* = c_1^*c_2^*\\dots c_n^*$ is unique.\n\nThe algorithm is as follows:\n$1$. For each amino acid $a_i$ in the input protein sequence $S_p$:\n    a. Identify the set of its synonymous codons and their corresponding probabilities from the provided codon usage table.\n    b. Determine the maximum probability, $p_{\\max, i} = \\max_{c \\in \\mathcal{C}(a_i)} p(c \\mid a_i)$.\n    c. Compile a list of all candidate codons that achieve this maximum probability.\n    d. Sort these candidate codons lexicographically and select the first one, $c_i^*$.\n$2$. Concatenate the selected codons to form the most likely DNA sequence: $S_d^* = c_1^*c_2^*\\dots c_n^*$.\n$3$. Calculate the total natural log-likelihood by summing the logarithms of the maximum probabilities found for each position:\n$$\n\\ell^* = \\sum_{i=1}^{n} \\log(p_{\\max, i})\n$$\n$4$. Convert the resulting DNA sequence $S_d^*$, which has length $m=3n$, into its base-$4$ integer representation, $E$. With the mapping $A \\mapsto 0$, $C \\mapsto 1$, $G \\mapsto 2$, $T \\mapsto 3$, the value $E$ is calculated using the formula for positional notation:\n$$\nE = \\sum_{j=1}^{m} x_j \\cdot 4^{m-j}\n$$\nwhere $x_j$ is the integer value corresponding to the $j$-th nucleotide $d_j$ in $S_d^*$. This can be computed efficiently using Horner's method: starting with $E=0$, iterate through the nucleotides of $S_d^*$, updating $E$ as $E \\leftarrow E \\cdot 4 + x_j$.\n$5$. For the special case of an empty protein sequence ($n=0$), the resulting DNA sequence is also empty. By convention, the log-likelihood $\\ell^*$ and the encoding $E$ are both $0$.\n\nThis procedure is applied to each test case to generate the required pairs of $(E, \\ell^*)$. For instance, for the amino acid Leucine ($L$), the codons with maximum probability ($0.3$) are $CTT$ and $CTG$. Lexicographically, $CTG < CTT$, so $CTG$ is chosen. For Lysine ($K$), the codons $AAA$ and $AAG$ both have probability $0.5$. Lexicographically, $AAA < AAG$, so $AAA$ is chosen. This systematic approach guarantees a correct and unique solution for any given protein sequence.", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the most likely ancestral DNA sequence and its log-likelihood for a set of protein sequences.\n    \"\"\"\n    codon_usage_table = {\n        'K': {'AAA': 0.5, 'AAG': 0.5},\n        'F': {'TTT': 0.45, 'TTC': 0.55},\n        'L': {'CTT': 0.3, 'CTC': 0.1, 'CTA': 0.1, 'CTG': 0.3, 'TTA': 0.1, 'TTG': 0.1},\n        'S': {'TCT': 0.19, 'TCC': 0.17, 'TCA': 0.15, 'TCG': 0.12, 'AGC': 0.20, 'AGT': 0.17},\n        'G': {'GGT': 0.16, 'GGC': 0.34, 'GGA': 0.25, 'GGG': 0.25},\n        'M': {'ATG': 1.0},\n        'W': {'TGG': 1.0}\n    }\n\n    base4_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    test_cases = [\n        \"MKW\",\n        \"LL\",\n        \"\",\n        \"SGS\",\n        \"F\"\n    ]\n\n    # Pre-process the table to find the best codon for each amino acid\n    best_codons = {}\n    for aa, codons in codon_usage_table.items():\n        if not codons:\n            continue\n        max_prob = -1.0\n        for prob in codons.values():\n            if prob > max_prob:\n                max_prob = prob\n        \n        candidate_codons = []\n        for codon, prob in codons.items():\n            if prob == max_prob:\n                candidate_codons.append(codon)\n        \n        # Tie-break by choosing the lexicographically smallest codon\n        best_codon = sorted(candidate_codons)[0]\n        best_codons[aa] = (best_codon, max_prob)\n\n    results = []\n    for protein_seq in test_cases:\n        if not protein_seq:\n            results.extend([0, 0.0])\n            continue\n\n        most_likely_dna_seq = \"\"\n        total_log_likelihood = 0.0\n\n        for aa in protein_seq:\n            codon, prob = best_codons[aa]\n            most_likely_dna_seq += codon\n            if prob > 0:\n                total_log_likelihood += np.log(prob)\n        \n        # Calculate base-4 encoding using Horner's method\n        encoded_val = 0\n        for nucleotide in most_likely_dna_seq:\n            encoded_val = encoded_val * 4 + base4_map[nucleotide]\n        \n        results.extend([encoded_val, total_log_likelihood])\n\n    # Format the final output string\n    output_parts = []\n    for i, res in enumerate(results):\n        if i % 2 == 1:  # Log-likelihood, format to 6 decimal places\n            output_parts.append(f\"{res:.6f}\")\n        else:  # Integer encoding\n            output_parts.append(str(res))\n    \n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2412742"}]}