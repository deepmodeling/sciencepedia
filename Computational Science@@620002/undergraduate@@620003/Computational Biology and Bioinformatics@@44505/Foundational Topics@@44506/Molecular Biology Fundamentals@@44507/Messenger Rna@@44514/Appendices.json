{"hands_on_practices": [{"introduction": "A fundamental property of any messenger RNA molecule is its stability, which directly influences the amount of protein that can be translated from it. This stability is often quantified by the mRNA's half-life ($t_{1/2}$), the time it takes for half of the initial population of that mRNA species to degrade. This practice guides you through a core technique in molecular biology: calculating the half-life from experimental data. By analyzing hypothetical data from an actinomycin D chase experiment, where transcription is halted, you will use the principles of first-order kinetics to transform raw concentration measurements into a critical biological parameter [@problem_id:1445058].", "problem": "In a systems biology experiment to characterize gene expression dynamics, researchers study the stability of a specific messenger RNA (mRNA) transcript for a gene called Glycolysis-Activating Factor (GAF). They treat a culture of cells at time $t=0$ minutes with actinomycin D, a drug that completely and instantaneously halts all transcription. Subsequently, they measure the concentration of GAF mRNA at several time points. The degradation of mRNA is known to follow first-order kinetics. The experimental data are provided in the table below.\n\n| Time, $t$ (minutes) | GAF mRNA Concentration (nanomoles/liter) |\n| :------------------ | :--------------------------------------- |\n| 0                   | 100.0                                    |\n| 10                  | 60.0                                     |\n| 20                  | 36.0                                     |\n| 30                  | 21.6                                     |\n| 40                  | 13.0                                     |\n\nUsing all the data points provided, determine the half-life of the GAF mRNA. Express your answer in minutes, rounded to three significant figures.", "solution": "Actinomycin D halts transcription at $t=0$, so the mRNA concentration $C(t)$ thereafter follows first-order decay:\n$$\\frac{dC}{dt}=-k\\,C \\quad\\Rightarrow\\quad C(t)=C_{0}\\exp(-k t).$$\nTaking natural logarithms gives a linear relation in $t$:\n$$\\ln C(t)=\\ln C_{0}-k\\,t.$$\nThus, fitting $y=\\ln C$ versus $t$ by least squares to $y=a+bt$ yields $b=-k$. Using all five data points $(t_{i},C_{i})$ with $t_{i}\\in\\{0,10,20,30,40\\}$ minutes and $C_{i}\\in\\{100.0,60.0,36.0,21.6,13.0\\}$ nanomoles/liter, define $y_{i}=\\ln C_{i}$. The standard least-squares slope is\n$$b=\\frac{n\\sum t_{i}y_{i}-\\left(\\sum t_{i}\\right)\\left(\\sum y_{i}\\right)}{n\\sum t_{i}^{2}-\\left(\\sum t_{i}\\right)^{2}},\\quad k=-b,$$\nwith $n=5$. Compute the needed sums:\n$$\\sum t_{i}=0+10+20+30+40=100,\\qquad \\sum t_{i}^{2}=0^{2}+10^{2}+20^{2}+30^{2}+40^{2}=3000.$$\nCompute $y_{i}=\\ln C_{i}$:\n$$\\ln 100=4.605170186,\\quad \\ln 60=4.094344562,\\quad \\ln 36=3.583518938,\\quad \\ln 21.6=3.072693314,\\quad \\ln 13.0=2.564949357.$$\nThus,\n$$\\sum y_{i}=4.605170186+4.094344562+3.583518938+3.072693314+2.564949357=17.920676357,$$\n$$\\sum t_{i}y_{i}=0\\cdot 4.605170186+10\\cdot 4.094344562+20\\cdot 3.583518938+30\\cdot 3.072693314+40\\cdot 2.564949357=307.39259808.$$\nTherefore,\n$$b=\\frac{5\\cdot 307.39259808-100\\cdot 17.920676357}{5\\cdot 3000-100^{2}}=\\frac{-255.1046453}{5000}=-0.05102092906,$$\nso\n$$k=0.05102092906\\ \\text{min}^{-1}.$$\nThe half-life is\n$$t_{1/2}=\\frac{\\ln 2}{k}=\\frac{0.69314718056}{0.05102092906}\\approx 13.5855\\ \\text{minutes}.$$\nRounded to three significant figures, the half-life is $13.6$ minutes.", "answer": "$$\\boxed{13.6}$$", "id": "1445058"}, {"introduction": "With key parameters like half-life determined, we can build dynamic models to predict how gene expression levels change over time. This exercise explores how a cell's mRNA population responds to an external stimulus, shifting from one steady state to another. You will apply a simple but powerful ordinary differential equation, $\\frac{dN}{dt} = k_{tx} - \\gamma N$, to model the balance between mRNA synthesis and degradation. This practice will enhance your understanding of how cells regulate their gene expression machinery to adapt to new conditions, a cornerstone of systems biology [@problem_id:1445057].", "problem": "In a simplified model of gene expression within a eukaryotic cell, the population of a specific messenger RNA (mRNA) species, transcribed from the gene *StressResp1*, is governed by a balance between its synthesis (transcription) and its degradation. The degradation process is modeled as a first-order decay. Initially, the cell is in a basal, unstressed state, where the transcription rate for *StressResp1* is constant at $k_{tx, basal} = 0.50$ molecules per minute. The half-life of the *StressResp1* mRNA is $t_{1/2} = 7.0$ minutes.\n\nAt time $t=0$, the cell is exposed to a sudden environmental stressor. This event instantaneously and permanently increases the transcription rate to a new, higher constant value of $k_{tx, new} = 10.0$ molecules per minute, while the mRNA half-life remains unchanged.\n\nCalculate the time required for the number of *StressResp1* mRNA molecules in the cell to reach 95% of its new, post-stress steady-state value. Express your answer in minutes, rounded to three significant figures.", "solution": "Let $N(t)$ denote the number of mRNA molecules. With first-order degradation, the governing equation is\n$$\n\\frac{dN}{dt}=k_{tx}-\\gamma N,\n$$\nwhere the degradation rate constant $\\gamma$ is related to the half-life $t_{1/2}$ by\n$$\nt_{1/2}=\\frac{\\ln 2}{\\gamma}\\quad\\Rightarrow\\quad \\gamma=\\frac{\\ln 2}{t_{1/2}}.\n$$\nBefore $t=0$, the system is at the basal steady state, so the initial condition at $t=0$ is\n$$\nN(0)=N_{ss,basal}=\\frac{k_{tx,basal}}{\\gamma}.\n$$\nFor $t\\ge 0$, the transcription rate is $k_{tx,new}$, giving the steady state\n$$\nN_{ss,new}=\\frac{k_{tx,new}}{\\gamma}.\n$$\nThe solution of the linear ODE for a step change in input is\n$$\nN(t)=N_{ss,new}+\\bigl(N(0)-N_{ss,new}\\bigr)\\exp(-\\gamma t).\n$$\nWe want the time $t$ when $N(t)$ reaches $0.95\\,N_{ss,new}$. Setting $N(t)=0.95\\,N_{ss,new}$ and solving for $t$,\n$$\n0.95\\,N_{ss,new}=N_{ss,new}+\\bigl(N(0)-N_{ss,new}\\bigr)\\exp(-\\gamma t),\n$$\n$$\n0.05\\,N_{ss,new}=\\bigl(N_{ss,new}-N(0)\\bigr)\\exp(-\\gamma t),\n$$\n$$\n\\exp(-\\gamma t)=\\frac{0.05\\,N_{ss,new}}{N_{ss,new}-N(0)}=\\frac{0.05\\,(k_{tx,new}/\\gamma)}{(k_{tx,new}-k_{tx,basal})/\\gamma}=\\frac{0.05\\,k_{tx,new}}{k_{tx,new}-k_{tx,basal}}.\n$$\nThus,\n$$\nt=\\frac{1}{\\gamma}\\ln\\left(\\frac{k_{tx,new}-k_{tx,basal}}{0.05\\,k_{tx,new}}\\right)=\\frac{t_{1/2}}{\\ln 2}\\,\\ln\\left(\\frac{k_{tx,new}-k_{tx,basal}}{0.05\\,k_{tx,new}}\\right).\n$$\nSubstituting the given values $t_{1/2}=7.0$, $k_{tx,basal}=0.50$, and $k_{tx,new}=10.0$,\n$$\nt=\\frac{7.0}{\\ln 2}\\,\\ln(19)\\approx 29.7.\n$$\nRounded to three significant figures, the required time in minutes is $29.7$.", "answer": "$$\\boxed{29.7}$$", "id": "1445057"}, {"introduction": "Moving beyond the dynamics of a single mRNA species, we now explore the complexity generated from a single gene through alternative splicing. This process allows for the production of multiple distinct mRNA isoforms, vastly expanding a cell's proteomic diversity. This advanced practice introduces a powerful computational abstraction used in bioinformatics: modeling splicing as a directed acyclic graph. By calculating path probabilities through this graph, you will learn how to quantify the relative abundance of different splice variants, a foundational skill for transcriptomic analysis [@problem_id:2404500].", "problem": "You are modeling messenger RNA (mRNA) splicing as a directed acyclic graph where exons are nodes in $5'$ to $3'$ order and introns correspond to edges with efficiencies. Consider a graph $G=(V,E)$ where $V=\\{1,2,\\dots,N\\}$ indexes exons from $5'$ to $3'$ and each directed edge $(i,j)\\in E$ has $i<j$ and an associated weight $w_{ij}\\in[0,1]$ representing the intron splicing efficiency for joining exon $i$ directly to exon $j$. A valid splice isoform corresponds to any directed path from exon $1$ to exon $N$. The path probability of a specific path is defined as the product of the edge weights along the path. Assume independence of intron splicing events across edges.\n\nFor each test case below, given $N$ and the weighted edge set $E$, compute the following quantities:\n\n1. The maximum path probability $P_{\\max}$ from exon $1$ to exon $N$, defined as the maximum over all directed paths $\\pi$ from $1$ to $N$ of the product $\\prod_{(u,v)\\in \\pi} w_{uv}$.\n\n2. The total path mass $M$, defined as the sum of the path probabilities over all directed paths from exon $1$ to exon $N$.\n\n3. For each exon $k\\in\\{1,\\dots,N\\}$, the inclusion probability $\\pi_k$, defined as the sum of probabilities of all directed paths from exon $1$ to exon $N$ that include exon $k$, divided by $M$.\n\nIf $M=0$, define $P_{\\max}=0$ and $\\pi_k=0$ for all $k$.\n\nYour program must produce, for each test case, a list containing the values $[P_{\\max},M,\\pi_1,\\pi_2,\\dots,\\pi_N]$ as decimal numbers rounded to exactly $6$ digits after the decimal point. The final output must be a single line containing a list of these per-test-case lists, in order, with no other text.\n\nUse the following test suite:\n\n- Test case $1$: $N=3$; edges with weights $w_{12}=0.9$, $w_{23}=0.8$, $w_{13}=0.3$.\n\n- Test case $2$: $N=4$; edges with weights $w_{12}=0.5$, $w_{23}=0.6$, $w_{34}=0.9$, $w_{13}=0.4$, $w_{24}=0.2$, $w_{14}=0.05$.\n\n- Test case $3$: $N=3$; edges with weights $w_{12}=1.0$, $w_{23}=0.0$, $w_{13}=0.7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes one list as specified above, for example: \"[[...],[...],[...]]\".", "solution": "The problem statement is valid. It presents a well-posed computational task on a directed acyclic graph (DAG), a standard model for alternative splicing in computational biology. The definitions of all quantities to be computed are mathematically precise, and the problem is free from scientific inaccuracies, ambiguities, or contradictions. The problem can be solved efficiently using dynamic programming, leveraging the topological ordering of the exons (nodes).\n\nThe solution involves three main computational steps performed on the graph $G=(V, E)$, where $V=\\{1, 2, \\dots, N\\}$ and an edge $(i, j)$ implies $i<j$. We will utilize 0-based indexing in our arrays, so node $k$ in the problem corresponds to index $k-1$.\n\n1.  **Maximum Path Probability ($P_{\\max}$)**\n\n    The maximum path probability from exon $1$ to exon $N$ can be found using a dynamic programming approach similar to finding the longest path in a DAG. Let $P_{\\max}(i)$ be the maximum path probability from the start exon $1$ to exon $i$. We seek to compute $P_{\\max}(N)$.\n\n    -   **Base Case**: The path from exon $1$ to itself has no edges, so its probability product is $1$. Thus, $P_{\\max}(1) = 1$. For any other node $i$ not reachable from $1$, $P_{\\max}(i)$ is implicitly $0$.\n\n    -   **Recurrence**: For any exon $i > 1$, a path from $1$ to $i$ must arrive from a predecessor exon $j$ via an edge $(j, i)$. The maximum path probability to $i$ is the maximum over all its predecessors $j$ of the probability of the path to $j$ extended by the edge $(j, i)$. The exons are processed in their natural order from $1$ to $N$.\n        $$ P_{\\max}(i) = \\max_{j : (j, i) \\in E} \\{ P_{\\max}(j) \\cdot w_{ji} \\} $$\n        The final result is $P_{\\max} = P_{\\max}(N)$. If no path exists from $1$ to $N$, this value will be $0$.\n\n2.  **Total Path Mass ($M$)**\n\n    The total path mass $M$ is the sum of probabilities of all distinct paths from exon $1$ to exon $N$. This can also be computed using dynamic programming. Let $M_{fwd}(i)$ be the total mass of all paths from exon $1$ to exon $i$. We want to find $M = M_{fwd}(N)$.\n\n    -   **Base Case**: As before, there is a single path of length $0$ from $1$ to $1$ with probability $1$. So, $M_{fwd}(1) = 1$.\n\n    -   **Recurrence**: For any exon $i > 1$, the total mass at $i$ is the sum of masses contributed by all its predecessors. Each predecessor $j$ contributes its own total mass $M_{fwd}(j)$ multiplied by the weight of the edge $(j, i)$.\n        $$ M_{fwd}(i) = \\sum_{j : (j, i) \\in E} M_{fwd}(j) \\cdot w_{ji} $$\n        The final result is $M = M_{fwd}(N)$.\n\n3.  **Inclusion Probability ($\\pi_k$)**\n\n    The inclusion probability for an exon $k$, $\\pi_k$, is the total probability of all paths from $1$ to $N$ that pass through $k$, normalized by the total path mass $M$.\n    A path from $1$ to $N$ through $k$ can be seen as a concatenation of a path from $1$ to $k$ and a path from $k$ to $N$. Due to the independence of splicing events, the probability of such a composite path is the product of the probabilities of its constituent sub-paths.\n\n    The total mass of paths passing through $k$ is therefore the product of two quantities:\n    - The total mass of paths from $1$ to $k$: This is precisely $M_{fwd}(k)$, which we have already calculated.\n    - The total mass of paths from $k$ to $N$. Let's call this $M_{rev}(k)$.\n\n    The term $M_{rev}(k)$ can be calculated with a \"reverse\" dynamic programming pass, computing the total path mass from each exon $k$ to the final exon $N$.\n\n    -   **Base Case**: The total mass of paths from $N$ to itself is $1$, so $M_{rev}(N) = 1$.\n\n    -   **Recurrence**: For any exon $k < N$, a path starting at $k$ must proceed to a successor exon $j$. The total mass is the sum of contributions from all successors.\n        $$ M_{rev}(k) = \\sum_{j : (k, j) \\in E} w_{kj} \\cdot M_{rev}(j) $$\n        This recurrence is solved by processing exons in reverse order, from $N-1$ down to $1$.\n\n    Finally, the inclusion probability $\\pi_k$ is given by:\n    $$ \\pi_k = \\frac{M_{fwd}(k) \\cdot M_{rev}(k)}{M} $$\n    For this formula to be valid, we must have $M > 0$. By definition, for any path from $1$ to $N$, exons $1$ and $N$ must be included. It follows that $\\pi_1 = \\frac{M_{fwd}(1) \\cdot M_{rev}(1)}{M} = \\frac{1 \\cdot M}{M} = 1$ and $\\pi_N = \\frac{M_{fwd}(N) \\cdot M_{rev}(N)}{M} = \\frac{M \\cdot 1}{M} = 1$.\n\n    If $M=0$, indicating no path from $1$ to $N$ exists, the problem statement specifies that $P_{\\max}=0$ and $\\pi_k=0$ for all $k \\in \\{1, \\dots, N\\}$. Our algorithm handles this by checking the computed value of $M$ before calculating the inclusion probabilities.", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(N, edges):\n    \"\"\"\n    Computes P_max, M, and pi_k for a single mRNA splicing graph.\n\n    Args:\n        N (int): The number of exons.\n        edges (list of tuples): A list of (u, v, w) tuples representing edges.\n\n    Returns:\n        list: A list of floats [P_max, M, pi_1, ..., pi_N].\n    \"\"\"\n    # Use 0-based indexing for nodes 0 to N-1\n    pred = [[] for _ in range(N)]\n    succ = [[] for _ in range(N)]\n    for u, v, w in edges:\n        pred[v - 1].append((u - 1, w))\n        succ[u - 1].append((v - 1, w))\n\n    # 1. Maximum path probability (P_max)\n    p_max = np.zeros(N, dtype=float)\n    if N > 0:\n        p_max[0] = 1.0\n    for i in range(1, N):\n        max_prob = 0.0\n        for j, w in pred[i]:\n            max_prob = max(max_prob, p_max[j] * w)\n        p_max[i] = max_prob\n    P_max = p_max[N - 1] if N > 0 else 0.0\n\n    # 2. Total path mass (M) and forward masses (m_fwd)\n    m_fwd = np.zeros(N, dtype=float)\n    if N > 0:\n        m_fwd[0] = 1.0\n    for i in range(1, N):\n        total_mass = 0.0\n        for j, w in pred[i]:\n            total_mass += m_fwd[j] * w\n        m_fwd[i] = total_mass\n    M = m_fwd[N - 1] if N > 0 else 0.0\n\n    # Handle case where no path exists from 1 to N\n    if M == 0:\n        return [0.0] * (2 + N)\n\n    # 3. Backward masses (m_rev)\n    m_rev = np.zeros(N, dtype=float)\n    if N > 0:\n        m_rev[N - 1] = 1.0\n    for k in range(N - 2, -1, -1):\n        total_mass = 0.0\n        for j, w in succ[k]:\n            total_mass += w * m_rev[j]\n        m_rev[k] = total_mass\n\n    # 4. Inclusion probabilities (pi_k)\n    pi = np.zeros(N, dtype=float)\n    for k in range(N):\n        pi[k] = (m_fwd[k] * m_rev[k]) / M\n\n    result = [P_max, M] + pi.tolist()\n    return result\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (3, [(1, 2, 0.9), (2, 3, 0.8), (1, 3, 0.3)]),\n        (4, [(1, 2, 0.5), (2, 3, 0.6), (3, 4, 0.9), (1, 3, 0.4), (2, 4, 0.2), (1, 4, 0.05)]),\n        (3, [(1, 2, 1.0), (2, 3, 0.0), (1, 3, 0.7)]),\n    ]\n\n    all_results = []\n    for N, edges in test_cases:\n        case_result_raw = calculate_metrics(N, edges)\n        # Format results to exactly 6 decimal places\n        formatted_case_result = [f\"{v:.6f}\" for v in case_result_raw]\n        all_results.append(f\"[{','.join(formatted_case_result)}]\")\n\n    # Print the final output in the required single-line format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2404500"}]}