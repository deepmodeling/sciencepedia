{"hands_on_practices": [{"introduction": "The thermal stability of DNA is crucial for its function, and this stability is encoded in its sequence. In this exercise, you will implement a two-state thermodynamic model to calculate the melting temperature ($T_m$) of a DNA hairpin, a common secondary structure. By modeling the contributions of base pairs, stacking interactions, and mismatches, you will gain a concrete understanding of how sequence dictates the energetic landscape of DNA folding [@problem_id:2386777].", "problem": "You are tasked with building a self-contained simulation of the thermal denaturation (melting) of a Deoxyribonucleic acid (DNA) hairpin using a two-state thermodynamic model and quantifying the effect of a single guanine–thymine (G–T) wobble pair in the stem on the melting temperature. In this model, a hairpin with a stem of length $n$ base pairs and a loop of length $L$ toggles between a fully folded state and a fully unfolded state. The folded state is stabilized by base pairing and stacking within the stem and destabilized by loop closure entropy. The unfolded state is taken as the reference with zero enthalpy and entropy.\n\nAssume the total Gibbs free energy of folding at absolute temperature $T$ is given by $\\Delta G(T) = \\Delta H_{\\mathrm{tot}} - T \\Delta S_{\\mathrm{tot}}$, where $\\Delta H_{\\mathrm{tot}}$ and $\\Delta S_{\\mathrm{tot}}$ are temperature-independent sums of contributions from base pairs, base-pair stacking, and loop entropy. The fraction folded at temperature $T$ is defined by the two-state Boltzmann equilibrium as $f_{\\mathrm{fold}}(T) = \\dfrac{1}{1+\\exp\\left(\\dfrac{\\Delta G(T)}{R T}\\right)}$, where $R$ is the Universal gas constant. The melting temperature $T_m$ is defined as the unique temperature (in Kelvin) at which $f_{\\mathrm{fold}}(T_m)=\\dfrac{1}{2}$.\n\nUse the following coarse-grained, physically grounded parameterization for the stem and loop in the folded state, with all enthalpies in $\\mathrm{cal\\cdot mol^{-1}}$ and entropies in $\\mathrm{cal\\cdot mol^{-1}\\cdot K^{-1}}$:\n- Universal gas constant: $R = 1.987\\ \\mathrm{cal\\cdot mol^{-1}\\cdot K^{-1}}$.\n- Per base-pair contributions in the stem:\n  - Watson–Crick guanine–cytosine pair: $\\Delta h_{\\mathrm{GC}} = -9800$, $\\Delta s_{\\mathrm{GC}} = -24.4$.\n  - Watson–Crick adenine–thymine pair: $\\Delta h_{\\mathrm{AT}} = -7200$, $\\Delta s_{\\mathrm{AT}} = -20.4$.\n  - G–T wobble pair: $\\Delta h_{\\mathrm{GT}} = -4000$, $\\Delta s_{\\mathrm{GT}} = -12.0$.\n- Per adjacent stacked pair within the stem (cooperativity), applied to each of the $n-1$ adjacencies in a stem of $n$ base pairs:\n  - $\\Delta h_{\\mathrm{stack}} = -800$, $\\Delta s_{\\mathrm{stack}} = -2.0$.\n- Loop entropy penalty for loop length $L$ (in nucleotides), modeled using a polymer loop-closure form with zero enthalpy and an entropy contribution $\\Delta s_{\\mathrm{loop}}(L) = R \\ln\\!\\big(A L^{-c}\\big)$, with $A = 1.0$ and $c = 1.8$. Thus, the total loop contribution is $\\Delta h_{\\mathrm{loop}}(L) = 0$ and $\\Delta s_{\\mathrm{loop}}(L) = - c R \\ln L$.\n\nGiven a hairpin with counts $n_{\\mathrm{GC}}$, $n_{\\mathrm{AT}}$, and $n_{\\mathrm{GT}}$ for the three base-pair types in the stem (so that $n = n_{\\mathrm{GC}} + n_{\\mathrm{AT}} + n_{\\mathrm{GT}}$), its total enthalpy and entropy in the folded state are:\n$$\n\\Delta H_{\\mathrm{tot}} = n_{\\mathrm{GC}}\\,\\Delta h_{\\mathrm{GC}} + n_{\\mathrm{AT}}\\,\\Delta h_{\\mathrm{AT}} + n_{\\mathrm{GT}}\\,\\Delta h_{\\mathrm{GT}} + (n-1)\\,\\Delta h_{\\mathrm{stack}},\n$$\n$$\n\\Delta S_{\\mathrm{tot}} = n_{\\mathrm{GC}}\\,\\Delta s_{\\mathrm{GC}} + n_{\\mathrm{AT}}\\,\\Delta s_{\\mathrm{AT}} + n_{\\mathrm{GT}}\\,\\Delta s_{\\mathrm{GT}} + (n-1)\\,\\Delta s_{\\mathrm{stack}} + \\Delta s_{\\mathrm{loop}}(L).\n$$\nWith the two-state model, $T_m$ satisfies $\\Delta G(T_m)=0$.\n\nTest suite and required outputs:\nFor each of the following three cases, consider two variants: a native variant with no G–T wobble ($n_{\\mathrm{GT}}=0$) and a wobble variant in which exactly one Watson–Crick pair of the specified type is replaced by a single G–T wobble pair (decrement that Watson–Crick count by $1$ and set $n_{\\mathrm{GT}}=1$). For each case, compute the change in melting temperature $\\Delta T_m = T_m^{\\mathrm{wobble}} - T_m^{\\mathrm{native}}$ in Kelvin.\n\n- Case $1$ (happy path): $n_{\\mathrm{GC}}=6$, $n_{\\mathrm{AT}}=0$, $L=4$, wobble replaces one $\\mathrm{GC}$.\n- Case $2$ (mixed content): $n_{\\mathrm{GC}}=3$, $n_{\\mathrm{AT}}=3$, $L=8$, wobble replaces one $\\mathrm{AT}$.\n- Case $3$ (boundary, minimal stem): $n_{\\mathrm{GC}}=1$, $n_{\\mathrm{AT}}=0$, $L=3$, wobble replaces one $\\mathrm{GC}$.\n\nAngle units are not applicable. All temperatures must be expressed in Kelvin, and each final numeric result must be a floating-point number.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the three cases, with each $\\Delta T_m$ rounded to three decimal places in Kelvin. For example, an output line has the form $[\\Delta T_{m,1},\\Delta T_{m,2},\\Delta T_{m,3}]$.", "solution": "The problem statement has been subjected to rigorous validation and is deemed to be valid. It is scientifically grounded in the principles of biophysical chemistry, specifically the two-state nearest-neighbor model for nucleic acid thermodynamics. The problem is well-posed, providing all necessary parameters, constants, and equations to determine a unique solution for the melting temperature, $T_m$. The provided parameters are physically reasonable for a coarse-grained model. The formulas for total enthalpy and entropy are self-consistent. The clarification regarding the loop entropy formula, $\\Delta s_{\\mathrm{loop}}(L) = - c R \\ln L$, derived from $\\Delta s_{\\mathrm{loop}}(L) = R \\ln(A L^{-c})$ with $A = 1.0$, is correct. The extraneous statement \"Angle units are not applicable\" is noted but does not affect the problem's integrity or solvability. As the problem is valid, a complete, reasoned solution is now presented.\n\nThe objective is to compute the change in melting temperature, $\\Delta T_m = T_m^{\\mathrm{wobble}} - T_m^{\\mathrm{native}}$, for a DNA hairpin when a Watson-Crick base pair is replaced by a G-T wobble pair. The solution is founded upon the provided two-state thermodynamic model.\n\nThe melting temperature, $T_m$, is defined as the temperature at which the hairpin is half-folded, i.e., $f_{\\mathrm{fold}}(T_m) = 1/2$. According to the given model for the fraction folded,\n$$f_{\\mathrm{fold}}(T) = \\dfrac{1}{1+\\exp\\left(\\dfrac{\\Delta G(T)}{R T}\\right)}$$\nthe condition $f_{\\mathrm{fold}}(T_m) = 1/2$ implies that the exponential term must be equal to $1$. This is only possible if the exponent is zero, which leads to the fundamental condition for the melting temperature:\n$$\\Delta G(T_m) = 0$$\nThe Gibbs free energy of folding is given as $\\Delta G(T) = \\Delta H_{\\mathrm{tot}} - T \\Delta S_{\\mathrm{tot}}$. Substituting this into the condition for $T_m$ yields:\n$$\\Delta H_{\\mathrm{tot}} - T_m \\Delta S_{\\mathrm{tot}} = 0$$\nSolving for $T_m$, we obtain the central equation for our calculation, which expresses the melting temperature in Kelvin as the ratio of the total enthalpy change to the total entropy change of folding:\n$$T_m = \\frac{\\Delta H_{\\mathrm{tot}}}{\\Delta S_{\\mathrm{tot}}}$$\nThis equation is valid as long as $\\Delta S_{\\mathrm{tot}} \\neq 0$, a condition which holds for any physical hairpin structure as all provided entropy contributions are non-zero and negative, ensuring a non-zero sum.\n\nTo calculate $T_m$ for any given hairpin, we must first compute its total folding enthalpy, $\\Delta H_{\\mathrm{tot}}$, and total folding entropy, $\\Delta S_{\\mathrm{tot}}$. These quantities are determined by summing the contributions from all constituent base pairs in the stem, the stacking interactions between them, and the entropic cost of loop closure. The provided formulas are:\n$$\n\\Delta H_{\\mathrm{tot}} = n_{\\mathrm{GC}}\\,\\Delta h_{\\mathrm{GC}} + n_{\\mathrm{AT}}\\,\\Delta h_{\\mathrm{AT}} + n_{\\mathrm{GT}}\\,\\Delta h_{\\mathrm{GT}} + (n-1)\\,\\Delta h_{\\mathrm{stack}}\n$$\n$$\n\\Delta S_{\\mathrm{tot}} = n_{\\mathrm{GC}}\\,\\Delta s_{\\mathrm{GC}} + n_{\\mathrm{AT}}\\,\\Delta s_{\\mathrm{AT}} + n_{\\mathrm{GT}}\\,\\Delta s_{\\mathrm{GT}} + (n-1)\\,\\Delta s_{\\mathrm{stack}} + \\Delta s_{\\mathrm{loop}}(L)\n$$\nwhere $n = n_{\\mathrm{GC}} + n_{\\mathrm{AT}} + n_{\\mathrm{GT}}$ is the total number of base pairs in the stem. The term $(n-1)$ correctly accounts for the $n-1$ adjacent stacking interactions in a stem of length $n$. For a stem with only one base pair ($n=1$), this term naturally becomes zero, which is physically correct as there are no stacking interactions.\n\nThe loop-closure entropy, $\\Delta s_{\\mathrm{loop}}(L)$, is given by the formula:\n$$\n\\Delta s_{\\mathrm{loop}}(L) = -c R \\ln L\n$$\nwith model parameters $c = 1.8$, universal gas constant $R = 1.987\\ \\mathrm{cal\\cdot mol^{-1}\\cdot K^{-1}}$, and $L$ being the loop length in nucleotides.\n\nThe algorithmic approach is as follows:\n$1$. A computational function is implemented to calculate $T_m$ based on the derived formula $T_m = \\Delta H_{\\mathrm{tot}} / \\Delta S_{\\mathrm{tot}}$. This function takes as input the number of GC, AT, and GT pairs ($n_{\\mathrm{GC}}$, $n_{\\mathrm{AT}}$, $n_{\\mathrm{GT}}$) and the loop length ($L$).\n$2$. Inside this function, $\\Delta H_{\\mathrm{tot}}$ and $\\Delta S_{\\mathrm{tot}}$ are computed by summing the specified thermodynamic contributions using the given parameters: $\\Delta h_{\\mathrm{GC}} = -9800$, $\\Delta s_{\\mathrm{GC}} = -24.4$, $\\Delta h_{\\mathrm{AT}} = -7200$, $\\Delta s_{\\mathrm{AT}} = -20.4$, $\\Delta h_{\\mathrm{GT}} = -4000$, $\\Delta s_{\\mathrm{GT}} = -12.0$, $\\Delta h_{\\mathrm{stack}} = -800$, and $\\Delta s_{\\mathrm{stack}} = -2.0$.\n$3$. The program then iterates through the three test cases specified. For each case, it defines the parameters for the 'native' hairpin and its 'wobble' counterpart.\n$4$. For each case, the $T_m$ calculation function is called twice: once for the native variant ($T_m^{\\mathrm{native}}$) and once for the wobble variant ($T_m^{\\mathrm{wobble}}$).\n$5$. The change in melting temperature, $\\Delta T_m = T_m^{\\mathrm{wobble}} - T_m^{\\mathrm{native}}$, is computed.\n$6$. The results for the three cases are collected, rounded to three decimal places as required, and formatted into a single output string.\n\nThe introduction of a G-T wobble pair, which is thermodynamically less stable than either a G-C or A-T Watson-Crick pair (i.e., its $\\Delta h$ and $\\Delta s$ values are less negative), is expected to destabilize the hairpin stem. This destabilization will lower the melting temperature, so we anticipate $\\Delta T_m$ to be negative in all cases. The magnitude of this effect will depend on the stability of the original pair being replaced and the overall stability of the hairpin.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DNA hairpin melting problem by calculating the change in melting\n    temperature upon introduction of a G-T wobble pair for three test cases.\n    \"\"\"\n\n    # --- Thermodynamic Parameters ---\n    # Universal gas constant (cal/mol/K)\n    R = 1.987\n    \n    # Per base-pair contributions (enthalpy in cal/mol, entropy in cal/mol/K)\n    # Guanine-Cytosine pair\n    DH_GC = -9800.0\n    DS_GC = -24.4\n    # Adenine-Thymine pair\n    DH_AT = -7200.0\n    DS_AT = -20.4\n    # Guanine-Thymine wobble pair\n    DH_GT = -4000.0\n    DS_GT = -12.0\n    \n    # Per adjacent stacked-pair contribution\n    DH_STACK = -800.0\n    DS_STACK = -2.0\n    \n    # Loop entropy model parameter\n    C_LOOP = 1.8\n\n    def calculate_tm(n_gc, n_at, n_gt, loop_len):\n        \"\"\"\n        Calculates the melting temperature (Tm) for a DNA hairpin.\n\n        Args:\n            n_gc (int): Number of GC pairs.\n            n_at (int): Number of AT pairs.\n            n_gt (int): Number of GT pairs.\n            loop_len (int): Length of the loop in nucleotides.\n\n        Returns:\n            float: The melting temperature in Kelvin.\n        \"\"\"\n        # Total number of base pairs in the stem\n        n = n_gc + n_at + n_gt\n\n        if n == 0:\n            # A stem of zero length has no defined melting transition\n            return np.nan\n\n        # Calculate total enthalpy of folding\n        delta_h_tot = (n_gc * DH_GC + n_at * DH_AT + n_gt * DH_GT)\n        # Stacking contribution exists only for stems with 2 or more pairs\n        if n > 1:\n            delta_h_tot += (n - 1) * DH_STACK\n\n        # Calculate total entropy of folding\n        # Loop entropy penalty (destabilizing)\n        delta_s_loop = -C_LOOP * R * np.log(loop_len)\n        \n        delta_s_tot = (n_gc * DS_GC + n_at * DS_AT + n_gt * DS_GT + delta_s_loop)\n        # Stacking contribution\n        if n > 1:\n            delta_s_tot += (n - 1) * DS_STACK\n            \n        # If entropy change is zero, Tm is not well-defined in this model\n        if delta_s_tot == 0:\n            return np.nan\n\n        # Melting temperature is the ratio of enthalpy to entropy\n        tm = delta_h_tot / delta_s_tot\n        return tm\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1: nGC=6, nAT=0, L=4. A GC pair is replaced by a GT wobble.\n        {\n            \"native\": {\"n_gc\": 6, \"n_at\": 0, \"n_gt\": 0, \"loop_len\": 4},\n            \"wobble\": {\"n_gc\": 5, \"n_at\": 0, \"n_gt\": 1, \"loop_len\": 4}\n        },\n        # Case 2: nGC=3, nAT=3, L=8. An AT pair is replaced by a GT wobble.\n        {\n            \"native\": {\"n_gc\": 3, \"n_at\": 3, \"n_gt\": 0, \"loop_len\": 8},\n            \"wobble\": {\"n_gc\": 3, \"n_at\": 2, \"n_gt\": 1, \"loop_len\": 8}\n        },\n        # Case 3: nGC=1, nAT=0, L=3. A GC pair is replaced by a GT wobble.\n        {\n            \"native\": {\"n_gc\": 1, \"n_at\": 0, \"n_gt\": 0, \"loop_len\": 3},\n            \"wobble\": {\"n_gc\": 0, \"n_at\": 0, \"n_gt\": 1, \"loop_len\": 3}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate Tm for both the native and wobble-containing variants\n        tm_native = calculate_tm(**case[\"native\"])\n        tm_wobble = calculate_tm(**case[\"wobble\"])\n\n        # Calculate the change in melting temperature\n        delta_tm = tm_wobble - tm_native\n        \n        # Format the result to three decimal places\n        results.append(f\"{delta_tm:.3f}\")\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2386777"}, {"introduction": "To function within the crowded cellular environment, the DNA molecule must bend and flex. This exercise treats DNA as an elastic polymer and introduces the worm-like chain (WLC) model, a cornerstone of polymer physics. You will connect local, sequence-dependent stiffness parameters to the persistence length ($L_p$), an emergent property that describes the molecule's global rigidity, providing a bridge from local sequence details to macroscopic physical behavior [@problem_id:2386739].", "problem": "You are asked to connect a sequence-dependent mechanical model of deoxyribonucleic acid (DNA) to a physically measurable emergent parameter: the persistence length. Model DNA as a slender, inextensible elastic rod whose centerline geometry is described by a continuous arc-length coordinate $s$ with curvature $\\kappa(s)$. Assume that bending about principal axes is isotropic, and that local bending rigidity (also called bending modulus) $A(s)$ can vary with $s$ due to sequence heterogeneity. The elastic energy of the rod under small deflections follows the standard elastic rod functional\n$$\nE[\\kappa] \\;=\\; \\tfrac{1}{2} \\int_{0}^{L} A(s)\\,\\kappa(s)^2\\,ds,\n$$\nand the statistical mechanics of conformations follows the Boltzmann distribution at absolute temperature $T$ with Boltzmann constant $k_{\\mathrm{B}}$. The worm-like chain (WLC) is the canonical continuum limit of such an elastic model.\n\nTasks:\n1) Starting from the energy functional above and the principle that the equilibrium curvature field $\\kappa(s)$ under a prescribed net bend angle is obtained by minimizing $E[\\kappa]$ subject to the geometric constraint on total bend, derive an expression for an equivalent homogeneous bending modulus $A_{\\mathrm{eff}}$ for a heterogeneous rod of total contour length $L$. Then, for a discretized rod composed of $N$ base-pair steps, each of arc length $b_i$ and local bending modulus $A_i$, translate your continuous expression into a discrete formula in terms of $\\{A_i\\}_{i=1}^{N}$ and $\\{b_i\\}_{i=1}^{N}$.\n\n2) Using fundamental results from equilibrium statistical mechanics for thermalized elastic rods and the worm-like chain model, express the persistence length $L_p$ in terms of $A_{\\mathrm{eff}}$, $k_{\\mathrm{B}}$, and $T$. You must clearly state the minimal physical assumptions that justify this relationship.\n\n3) Implement a program that, given temperature $T$ in kelvin and a list of per-step bending moduli $\\{A_i\\}$ in $\\mathrm{pN}\\cdot\\mathrm{nm}^2$ for a DNA fragment with uniform base-pair rise $b$ in nanometers, computes the persistence length $L_p$ in nanometers using your derived discrete $A_{\\mathrm{eff}}$ and your expression for $L_p$. Use the value $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$ and convert it to $\\mathrm{pN}\\cdot\\mathrm{nm/K}$ via $1\\ \\mathrm{J} = 10^{21}\\ \\mathrm{pN}\\cdot\\mathrm{nm}$.\n\n4) Physical and numerical units: input bending moduli $A_i$ are in $\\mathrm{pN}\\cdot\\mathrm{nm}^2$, base-pair rise $b$ is in $\\mathrm{nm}$, temperature $T$ is in $\\mathrm{K}$, and you must output $L_p$ in $\\mathrm{nm}$. Report each numerical result rounded to $6$ decimal places.\n\n5) Test suite: your program must compute $L_p$ for the following parameter sets. In all cases, take a uniform per-step rise $b = 0.34\\ \\mathrm{nm}$.\n- Case 1 (homogeneous, canonical DNA-like rigidity at room temperature): $T = 298.15$, $A = [\\,205.7,\\,205.7,\\,205.7,\\,205.7,\\,205.7\\,]$.\n- Case 2 (alternating soft–stiff steps): $T = 298.15$, $A = [\\,100,\\,300,\\,100,\\,300,\\,100,\\,300\\,]$.\n- Case 3 (very stiff): $T = 298.15$, $A = [\\,1000,\\,1000,\\,1000\\,]$.\n- Case 4 (one very soft step among many stiff steps): $T = 298.15$, $A = [\\,300,\\,300,\\,300,\\,10,\\,300,\\,300,\\,300,\\,300,\\,300,\\,300\\,]$.\n- Case 5 (temperature dependence at physiological temperature): $T = 310.0$, $A = [\\,205.7,\\,205.7,\\,205.7,\\,205.7\\,]$.\n- Case 6 (single-step edge case): $T = 298.15$, $A = [\\,150\\,]$.\n\n6) Final output format: your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each entry must be a floating-point number equal to $L_p$ in $\\mathrm{nm}$ rounded to $6$ decimal places, in the order of the cases listed above.\n\nImportant constraints:\n- Your derivation must begin from the energy functional and general statistical mechanics principles, not from a shortcut formula. You must justify any continuum-to-discrete translation.\n- Angles, if introduced during derivation, are to be treated as small and in radians. No angles appear in the final numeric input or output.\n- The only physical constants you may use are $k_{\\mathrm{B}}$ and the unit conversion between $\\mathrm{J}$ and $\\mathrm{pN}\\cdot\\mathrm{nm}$ as specified.", "solution": "We begin with the slender elastic rod model for deoxyribonucleic acid (DNA), adopting the small-deflection regime and isotropic bending. The elastic energy for a space curve with curvature field $\\kappa(s)$ and position-dependent bending modulus $A(s)$ is\n$$\nE[\\kappa] \\;=\\; \\frac{1}{2}\\int_{0}^{L} A(s)\\,\\kappa(s)^2\\,ds,\n$$\nwhere $s$ is the arc length and $L$ is the contour length. Consider imposing a small overall bend with net angle $\\Theta$ between the end tangents. The geometric constraint is\n$$\n\\int_{0}^{L} \\kappa(s)\\,ds \\;=\\; \\Theta,\n$$\nwith $\\Theta$ in radians. Among all admissible $\\kappa(s)$ that satisfy this constraint, the physical bending response minimizes $E[\\kappa]$. Introduce a Lagrange multiplier $\\lambda$ for the constraint and minimize\n$$\n\\mathcal{F}[\\kappa] \\;=\\; \\frac{1}{2}\\int_{0}^{L} A(s)\\,\\kappa(s)^2\\,ds \\;-\\; \\lambda\\left(\\int_{0}^{L}\\kappa(s)\\,ds - \\Theta\\right).\n$$\nStationarity with respect to variations $\\delta \\kappa(s)$ yields\n$$\n\\frac{\\delta \\mathcal{F}}{\\delta \\kappa(s)} \\;=\\; A(s)\\,\\kappa(s) \\;-\\; \\lambda \\;=\\; 0 \\quad\\Rightarrow\\quad \\kappa(s) \\;=\\; \\frac{\\lambda}{A(s)}.\n$$\nEnforcing the constraint gives\n$$\n\\Theta \\;=\\; \\int_{0}^{L}\\kappa(s)\\,ds \\;=\\; \\int_{0}^{L}\\frac{\\lambda}{A(s)}\\,ds \\;=\\; \\lambda \\int_{0}^{L}\\frac{ds}{A(s)} \\;\\Rightarrow\\; \\lambda \\;=\\; \\frac{\\Theta}{\\int_{0}^{L}\\frac{ds}{A(s)}}.\n$$\nSubstituting the minimizing curvature back into the energy yields\n$$\nE_{\\min} \\;=\\; \\frac{1}{2}\\int_{0}^{L}A(s)\\left(\\frac{\\lambda}{A(s)}\\right)^2 ds \n\\;=\\; \\frac{1}{2}\\lambda^2 \\int_{0}^{L}\\frac{ds}{A(s)}\n\\;=\\; \\frac{1}{2}\\frac{\\Theta^2}{\\int_{0}^{L}\\frac{ds}{A(s)}}.\n$$\nFor an equivalent homogeneous rod of modulus $A_{\\mathrm{eff}}$, the same imposed bend $\\Theta$ would cost\n$$\nE_{\\mathrm{hom}} \\;=\\; \\frac{1}{2}\\frac{A_{\\mathrm{eff}}}{L}\\,\\Theta^2,\n$$\nbecause the curvature is uniform, $\\kappa = \\Theta/L$, leading to $E = \\frac{1}{2}\\int_{0}^{L} A_{\\mathrm{eff}}(\\Theta/L)^2 ds = \\frac{1}{2}\\frac{A_{\\mathrm{eff}}}{L}\\Theta^2$. Equating $E_{\\min}$ and $E_{\\mathrm{hom}}$ gives\n$$\n\\frac{1}{2}\\frac{A_{\\mathrm{eff}}}{L}\\,\\Theta^2 \\;=\\; \\frac{1}{2}\\frac{\\Theta^2}{\\int_{0}^{L}\\frac{ds}{A(s)}} \\quad\\Rightarrow\\quad \\frac{1}{A_{\\mathrm{eff}}} \\;=\\; \\frac{1}{L}\\int_{0}^{L}\\frac{ds}{A(s)}.\n$$\nThus, the effective bending modulus is the harmonic mean of the local moduli weighted by arc length:\n$$\nA_{\\mathrm{eff}} \\;=\\; \\frac{L}{\\displaystyle \\int_{0}^{L}\\frac{ds}{A(s)}}.\n$$\n\nDiscrete formulation for base-pair steps. Let the rod be discretized into $N$ steps indexed by $i=1,\\dots,N$ with lengths $b_i$ (in nanometers) and moduli $A_i$ (in $\\mathrm{pN}\\cdot\\mathrm{nm}^2$). Approximating the integral by a Riemann sum yields\n$$\nL \\;=\\; \\sum_{i=1}^{N} b_i,\\qquad \\int_{0}^{L}\\frac{ds}{A(s)} \\;\\approx\\; \\sum_{i=1}^{N}\\frac{b_i}{A_i},\n$$\nso that\n$$\nA_{\\mathrm{eff}} \\;=\\; \\frac{\\displaystyle \\sum_{i=1}^{N} b_i}{\\displaystyle \\sum_{i=1}^{N}\\frac{b_i}{A_i}}.\n$$\nFor uniform step length $b_i=b$ this simplifies to the (unweighted) harmonic mean:\n$$\nA_{\\mathrm{eff}} \\;=\\; \\frac{N}{\\displaystyle \\sum_{i=1}^{N}\\frac{1}{A_i}}.\n$$\n\nPersistence length from statistical mechanics. In the worm-like chain (WLC) model, which is the thermally fluctuating counterpart of the elastic rod, the tangent–tangent correlation function decays exponentially with arc length as $\\langle \\mathbf{t}(s)\\cdot\\mathbf{t}(0)\\rangle = e^{-s/L_p}$, defining the persistence length $L_p$. A standard and well-tested relation connects the bending modulus to the persistence length via thermal energy:\n$$\nL_p \\;=\\; \\frac{A}{k_{\\mathrm{B}} T}.\n$$\nThis follows from equipartition and the quadratic bending energy density: for small thermal fluctuations each quadratic mode contributes $\\tfrac{1}{2}k_{\\mathrm{B}}T$ on average, which leads to an average curvature variance per unit length set by $k_{\\mathrm{B}}T/A$ and a correlation length $L_p$ inversely proportional to that variance in the WLC continuum limit. For a heterogeneous filament coarse-grained to an equivalent homogeneous rod, we replace $A$ by $A_{\\mathrm{eff}}$:\n$$\nL_p \\;=\\; \\frac{A_{\\mathrm{eff}}}{k_{\\mathrm{B}} T}.\n$$\n\nUnits and conversion. We are given $A_i$ in $\\mathrm{pN}\\cdot\\mathrm{nm}^2$, $b_i$ in $\\mathrm{nm}$, and $T$ in $\\mathrm{K}$. The Boltzmann constant is $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$. Using $1\\ \\mathrm{J} = 10^{21}\\ \\mathrm{pN}\\cdot\\mathrm{nm}$, we have\n$$\nk_{\\mathrm{B}} \\;=\\; 1.380649\\times 10^{-23}\\ \\mathrm{J/K} \\;=\\; 1.380649\\times 10^{-23}\\times 10^{21}\\ \\mathrm{pN}\\cdot\\mathrm{nm/K} \\;=\\; 0.01380649\\ \\mathrm{pN}\\cdot\\mathrm{nm/K}.\n$$\nThus $k_{\\mathrm{B}}T$ is in $\\mathrm{pN}\\cdot\\mathrm{nm}$ and $A_{\\mathrm{eff}}/(k_{\\mathrm{B}}T)$ yields $L_p$ in $\\mathrm{nm}$.\n\nAlgorithm:\n- For each case, build $b_i$ and $A_i$, compute $L=\\sum_i b_i$ and $S=\\sum_i b_i/A_i$.\n- Compute $A_{\\mathrm{eff}} = L/S$.\n- Compute $k_{\\mathrm{B}}T = 0.01380649 \\times T$ in $\\mathrm{pN}\\cdot\\mathrm{nm}$.\n- Compute $L_p = A_{\\mathrm{eff}}/(k_{\\mathrm{B}}T)$ in $\\mathrm{nm}$.\n- Round to $6$ decimals.\n\nNow evaluate the test suite numerically with uniform $b_i=b=0.34\\ \\mathrm{nm}$.\n\nCase $1$: $T=298.15$, $A=[205.7,205.7,205.7,205.7,205.7]$.\n- $A_{\\mathrm{eff}} = 205.7$.\n- $k_{\\mathrm{B}}T = 0.01380649\\times 298.15 = 4.1164049935$.\n- $L_p = 205.7/4.1164049935 \\approx 49.970788\\ \\mathrm{nm}$.\n\nCase $2$: $T=298.15$, $A=[100,300,100,300,100,300]$.\n- $A_{\\mathrm{eff}} = \\left(6 / (3/100+3/300)\\right) = 150$.\n- $k_{\\mathrm{B}}T = 4.1164049935$.\n- $L_p = 150/4.1164049935 \\approx 36.439563\\ \\mathrm{nm}$.\n\nCase $3$: $T=298.15$, $A=[1000,1000,1000]$.\n- $A_{\\mathrm{eff}} = 1000$.\n- $k_{\\mathrm{B}}T = 4.1164049935$.\n- $L_p = 1000/4.1164049935 \\approx 242.930420\\ \\mathrm{nm}$.\n\nCase $4$: $T=298.15$, $A=[300,300,300,10,300,300,300,300,300,300]$.\n- $A_{\\mathrm{eff}} = 10/\\left(9/300 + 1/10\\right) = 76.9230769231$.\n- $k_{\\mathrm{B}}T = 4.1164049935$.\n- $L_p \\approx 76.9230769231/4.1164049935 \\approx 18.686956\\ \\mathrm{nm}$.\n\nCase $5$: $T=310.0$, $A=[205.7,205.7,205.7,205.7]$.\n- $A_{\\mathrm{eff}} = 205.7$.\n- $k_{\\mathrm{B}}T = 0.01380649\\times 310.0 = 4.2800119$.\n- $L_p = 205.7/4.2800119 \\approx 48.052203\\ \\mathrm{nm}$.\n\nCase $6$: $T=298.15$, $A=[150]$.\n- $A_{\\mathrm{eff}} = 150$.\n- $k_{\\mathrm{B}}T = 4.1164049935$.\n- $L_p = 150/4.1164049935 \\approx 36.439563\\ \\mathrm{nm}$.\n\nFinal required output (rounded to $6$ decimals and ordered as specified) is a single line containing a list of floats:\n$[49.970788,36.439563,242.930420,18.686956,48.052203,36.439563]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef effective_bending_modulus(A_list, b_list):\n    \"\"\"\n    Compute A_eff for a heterogeneous elastic rod discretized into steps.\n    A_list: list or array of per-step bending moduli (pN*nm^2)\n    b_list: list or array of per-step lengths (nm)\n    Returns A_eff in pN*nm^2.\n    \"\"\"\n    A = np.asarray(A_list, dtype=float)\n    b = np.asarray(b_list, dtype=float)\n    L = b.sum()  # total contour length (nm)\n    compliance_sum = np.sum(b / A)  # sum of ds/A(s)\n    return L / compliance_sum\n\ndef persistence_length_nm(A_eff, T_kelvin):\n    \"\"\"\n    Compute L_p in nm given A_eff (pN*nm^2) and temperature T (K).\n    Uses k_B = 0.01380649 pN*nm/K (from 1.380649e-23 J/K with 1 J = 1e21 pN*nm).\n    \"\"\"\n    kB_pNnm_perK = 0.01380649\n    kBT = kB_pNnm_perK * T_kelvin  # pN*nm\n    return A_eff / kBT  # nm\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (T in K, b in nm, list of A_i in pN*nm^2)\n    test_cases = [\n        (298.15, 0.34, [205.7, 205.7, 205.7, 205.7, 205.7]),\n        (298.15, 0.34, [100.0, 300.0, 100.0, 300.0, 100.0, 300.0]),\n        (298.15, 0.34, [1000.0, 1000.0, 1000.0]),\n        (298.15, 0.34, [300.0, 300.0, 300.0, 10.0, 300.0, 300.0, 300.0, 300.0, 300.0, 300.0]),\n        (310.0,  0.34, [205.7, 205.7, 205.7, 205.7]),\n        (298.15, 0.34, [150.0]),\n    ]\n\n    results = []\n    for T, b, A_list in test_cases:\n        b_list = [b] * len(A_list)\n        A_eff = effective_bending_modulus(A_list, b_list)\n        Lp = persistence_length_nm(A_eff, T)\n        results.append(f\"{Lp:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386739"}, {"introduction": "Comparing biological molecules often requires looking beyond the primary sequence to their three-dimensional shape. This practice challenges you to adapt the classic dynamic programming algorithm for sequence alignment to perform a \"structural alignment\" based on DNA groove geometry. You will implement an alignment tool that scores similarity based on major and minor groove widths, learning how core bioinformatics algorithms can be generalized to compare complex structural features [@problem_id:2386718].", "problem": "You are tasked with implementing a complete, runnable program that aligns two DNA molecules based on the similarity of their groove shapes rather than their primary sequences. The structural descriptor for each molecule is modeled as a sequence of feature vectors along the base pair index, where each position has two real-valued components: major groove width and minor groove width. Use a principled objective grounded in well-established facts about deoxyribonucleic acid (DNA) double helix geometry: DNA has a repeating double helical structure with a major groove and a minor groove whose local widths vary with base pair step, and structurally similar helices will exhibit similar groove-width profiles along the helical axis.\n\nYour program must implement a global alignment between two real-valued sequences of feature vectors, allowing for insertions and deletions to account for localized structural stretching or compression. The alignment objective is defined as minimizing the total cost consisting of a weighted sum of squared Euclidean distances between aligned feature vectors and an affine gap penalty model for insertions and deletions.\n\nFormally, let one molecule be represented by a sequence of length $n$ of feature vectors $\\{\\mathbf{a}_i\\}_{i=1}^n$ with $\\mathbf{a}_i = (a_i^{\\mathrm{maj}}, a_i^{\\mathrm{min}})$, and the other molecule by a sequence of length $m$ of feature vectors $\\{\\mathbf{b}_j\\}_{j=1}^m$ with $\\mathbf{b}_j = (b_j^{\\mathrm{maj}}, b_j^{\\mathrm{min}})$. For a match between position $i$ and position $j$, the local match cost is\n$$\nc(i,j) = w_{\\mathrm{maj}} \\left(a_i^{\\mathrm{maj}} - b_j^{\\mathrm{maj}}\\right)^2 + w_{\\mathrm{min}} \\left(a_i^{\\mathrm{min}} - b_j^{\\mathrm{min}}\\right)^2,\n$$\nwhere $w_{\\mathrm{maj}} \\ge 0$ and $w_{\\mathrm{min}} \\ge 0$ are user-specified nonnegative weights reflecting the relative importance of major and minor groove similarities. For gaps, use an affine penalty consisting of a gap-opening penalty $p_o \\ge 0$ and a gap-extension penalty $p_e \\ge 0$, so that a single contiguous gap of length $\\ell$ contributes a penalty $p_o + \\ell \\, p_e$.\n\nYour program must:\n- Compute the globally optimal alignment that minimizes the total cost, defined as the sum of match costs over aligned pairs plus the sum of affine penalties for all gap segments.\n- Recover the number of aligned position pairs (match steps) and the total number of gap steps (the number of alignment columns that pair a feature vector from one sequence with a gap on the other side).\n\nAll feature values are given in arbitrary units, and there are no physical units to convert. Angles are not involved. All requested numerical outputs must be computed exactly as described.\n\nTest Suite:\nImplement your program to evaluate the following four test cases. Each test case is a tuple $(\\{\\mathbf{a}_i\\}, \\{\\mathbf{b}_j\\}, w_{\\mathrm{maj}}, w_{\\mathrm{min}}, p_o, p_e)$.\n\n- Test case $1$ (identical profiles, no gaps preferred):\n  - $\\{\\mathbf{a}_i\\}$:\n    $[(6.0, 4.8), (5.9, 4.9), (6.1, 4.7), (6.0, 4.8), (6.0, 4.8), (6.0, 4.8)]$\n  - $\\{\\mathbf{b}_j\\}$:\n    $[(6.0, 4.8), (5.9, 4.9), (6.1, 4.7), (6.0, 4.8), (6.0, 4.8), (6.0, 4.8)]$\n  - $w_{\\mathrm{maj}} = 1.0$, $w_{\\mathrm{min}} = 1.0$, $p_o = 2.0$, $p_e = 0.5$.\n\n- Test case $2$ (shifted profiles, gaps favored over mismatched alignment):\n  - $\\{\\mathbf{a}_i\\}$:\n    $[(5.5, 5.0), (5.7, 5.2), (5.9, 5.4), (6.1, 5.6), (6.3, 5.8), (6.5, 6.0)]$\n  - $\\{\\mathbf{b}_j\\}$:\n    $[(5.7, 5.2), (5.9, 5.4), (6.1, 5.6), (6.3, 5.8), (6.5, 6.0), (6.7, 6.2)]$\n  - $w_{\\mathrm{maj}} = 1.0$, $w_{\\mathrm{min}} = 1.0$, $p_o = 0.1$, $p_e = 0.1$.\n\n- Test case $3$ (amplitude and slight noise, large gap penalties discourage gaps):\n  - $\\{\\mathbf{a}_i\\}$:\n    $[(6.0, 5.0), (6.2, 5.1), (6.1, 5.0), (5.9, 4.9), (6.0, 5.1)]$\n  - $\\{\\mathbf{b}_j\\}$:\n    $[(6.1, 5.1), (6.3, 5.2), (6.0, 4.9), (5.8, 4.8), (6.2, 5.2)]$\n  - $w_{\\mathrm{maj}} = 1.0$, $w_{\\mathrm{min}} = 0.5$, $p_o = 5.0$, $p_e = 1.0$.\n\n- Test case $4$ (boundary case with empty profile on one side):\n  - $\\{\\mathbf{a}_i\\}$: $[(6.0, 5.0), (6.1, 5.1), (6.2, 5.2)]$\n  - $\\{\\mathbf{b}_j\\}$: $[]$\n  - $w_{\\mathrm{maj}} = 1.0$, $w_{\\mathrm{min}} = 1.0$, $p_o = 2.0$, $p_e = 0.3$.\n\nRequired output per test case:\n- A triple $[C, M, G]$ where $C$ is the minimal total cost as a real number rounded to exactly $6$ decimal places, $M$ is the integer number of matched position pairs, and $G$ is the integer number of gap steps.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list of the triples enclosed in square brackets, for example: $[[C_1, M_1, G_1],[C_2, M_2, G_2],[C_3, M_3, G_3],[C_4, M_4, G_4]]$.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Objective**: Globally align two sequences of feature vectors, $\\mathbf{A} = \\{\\mathbf{a}_i\\}_{i=1}^n$ and $\\mathbf{B} = \\{\\mathbf{b}_j\\}_{j=1}^m$, to minimize a total cost function.\n- **Feature Vectors**: Each position $k$ is described by a vector $\\mathbf{v}_k = (v_k^{\\mathrm{maj}}, v_k^{\\mathrm{min}})$, representing major and minor groove widths.\n- **Local Match Cost**: The cost for aligning feature vector $\\mathbf{a}_i$ with $\\mathbf{b}_j$ is a weighted squared Euclidean distance:\n$$c(i,j) = w_{\\mathrm{maj}} \\left(a_i^{\\mathrm{maj}} - b_j^{\\mathrm{maj}}\\right)^2 + w_{\\mathrm{min}} \\left(a_i^{\\mathrm{min}} - b_j^{\\mathrm{min}}\\right)^2$$\n- **Gap Penalty Model**: An affine gap penalty is used, where a contiguous gap of length $\\ell$ incurs a cost of $p_o + \\ell \\cdot p_e$. Here, $p_o$ is the gap-opening penalty and $p_e$ is the gap-extension penalty.\n- **Parameters**: Nonnegative weights $w_{\\mathrm{maj}}, w_{\\mathrm{min}}$ and penalties $p_o, p_e$ are provided for each test case.\n- **Required Outputs**: For each test case, determine a triple $[C, M, G]$, where $C$ is the minimal total alignment cost (rounded to $6$ decimal places), $M$ is the number of aligned position pairs, and $G$ is the total number of gap steps.\n- **Test Suite**: Four specific test cases are provided with input sequences and parameters.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is scientifically well-grounded. The premise of using DNA groove width profiles for structural comparison is a valid concept in biophysics and computational biology. The mathematical model—global alignment with an affine gap penalty—is a standard and powerful technique for sequence analysis.\n- **Well-Posedness**: The problem is well-posed. The objective function is clearly defined, and the task of minimizing it is a classic optimization problem for which a unique optimal cost $C$ is guaranteed to exist and can be computed by a deterministic algorithm.\n- **Objectivity**: The problem statement is in objective, mathematical language, free of subjective or ambiguous terminology.\n- **Conclusion**: The problem does not violate any of the specified invalidity criteria. It is scientifically sound, well-posed, objective, complete, and algorithmically solvable.\n\n**Step 3: Verdict and Action**\n- **Verdict**: The problem is valid.\n- **Action**: Proceed with providing a formal solution.\n\n**Solution Derivation**\nThe problem of finding the minimal cost global alignment with affine gap penalties is a canonical application of dynamic programming, representing a generalization of the Needleman-Wunsch algorithm. To handle the affine penalty, which distinguishes between opening a new gap and extending an existing one, we must maintain separate states for alignments ending in a match, a gap in sequence $\\mathbf{A}$, or a gap in sequence $\\mathbf{B}$.\n\nLet the sequences be $\\mathbf{A}$ of length $n$ and $\\mathbf{B}$ of length $m$. We define three $(n+1) \\times (m+1)$ dynamic programming tables (matrices):\n- $M(i, j)$: The minimum cost of aligning the prefix $\\mathbf{A}[1..i]$ with $\\mathbf{B}[1..j]$, given that $\\mathbf{a}_i$ is aligned with $\\mathbf{b}_j$.\n- $I_x(i, j)$: The minimum cost of aligning $\\mathbf{A}[1..i]$ with $\\mathbf{B}[1..j]$, given that $\\mathbf{a}_i$ is aligned with a gap.\n- $I_y(i, j)$: The minimum cost of aligning $\\mathbf{A}[1..i]$ with $\\mathbf{B}[1..j]$, given that $\\mathbf{b}_j$ is aligned with a gap.\n\nThe tables are filled based on the following recurrence relations for $1 \\le i \\le n$ and $1 \\le j \\le m$.\n\nThe cost to form a match $(i, j)$ is the local match cost $c(i,j)$ plus the minimum cost of any preceding alignment of prefixes $(i-1), (j-1)$:\n$$M(i, j) = c(i-1, j-1) + \\min \\begin{cases} M(i-1, j-1) \\\\ I_x(i-1, j-1) \\\\ I_y(i-1, j-1) \\end{cases}$$\nNote that indices for $c(i,j)$ are 0-based corresponding to the sequence arrays, while DP table indices are 1-based.\n\nThe cost to align $\\mathbf{a}_i$ with a gap depends on whether this is a new gap or an extension of a previous one:\n$$I_x(i, j) = \\min \\begin{cases} \\min(M(i-1, j), I_y(i-1, j)) + p_o + p_e & \\text{(open gap in B)} \\\\ I_x(i-1, j) + p_e & \\text{(extend gap in B)} \\end{cases}$$\n\nSymmetrically, for a gap opposite $\\mathbf{b}_j$:\n$$I_y(i, j) = \\min \\begin{cases} \\min(M(i, j-1), I_x(i, j-1)) + p_o + p_e & \\text{(open gap in A)} \\\\ I_y(i, j-1) + p_e & \\text{(extend gap in A)} \\end{cases}$$\n\n**Initialization:**\nThe tables are initialized to handle the boundaries of the alignment grid.\n- Base case: $M(0, 0) = 0$. All other entries $M(i,0)$ and $M(0,j)$ are $\\infty$.\n- Initial gaps: Aligning a prefix of one sequence with an empty sequence\n  - $I_x(i, 0) = p_o + i \\cdot p_e$ for $i > 0$. $I_y(i, 0) = \\infty$.\n  - $I_y(0, j) = p_o + j \\cdot p_e$ for $j > 0$. $I_x(0, j) = \\infty$.\n- All other $I_x(0,j)$ and $I_y(i,0)$ are initialized to $\\infty$.\n\n**Final Cost:**\nAfter filling the tables up to $(n, m)$, the minimal total cost $C$ for the global alignment is the minimum of the three possible final states:\n$$C = \\min(M(n, m), I_x(n, m), I_y(n, m))$$\n\n**Traceback for Match and Gap Counts:**\nTo determine the number of matches ($M$) and gaps ($G$), a traceback procedure is executed starting from the cell $(n, m)$ in the table corresponding to the minimal final cost. The path is reconstructed by reversing the decisions made during the forward DP calculation. At each step $(i, j)$, we determine the predecessor cell $(i', j')$ and the state (M, Ix, or Iy) that yielded the value in the current cell.\n- A move from $(i-1, j-1)$ to $(i, j)$ in state $M$ corresponds to a match.\n- A move from $(i-1, j)$ to $(i, j)$ in state $I_x$ corresponds to a gap.\n- A move from $(i, j-1)$ to $(i, j)$ in state $I_y$ corresponds to a gap.\nThe process continues until $(0, 0)$ is reached. The counts of match and gap steps are accumulated to find $M$ and $G$. During implementation, care must be taken with floating-point comparisons; re-computing potential predecessor costs and using a small tolerance for equality checks is a robust strategy. Tie-breaking is consistently handled by prioritizing matches over gaps, and $I_x$ gaps over $I_y$ gaps.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (\n            [(6.0, 4.8), (5.9, 4.9), (6.1, 4.7), (6.0, 4.8), (6.0, 4.8), (6.0, 4.8)],\n            [(6.0, 4.8), (5.9, 4.9), (6.1, 4.7), (6.0, 4.8), (6.0, 4.8), (6.0, 4.8)],\n            1.0, 1.0, 2.0, 0.5\n        ),\n        # Test case 2\n        (\n            [(5.5, 5.0), (5.7, 5.2), (5.9, 5.4), (6.1, 5.6), (6.3, 5.8), (6.5, 6.0)],\n            [(5.7, 5.2), (5.9, 5.4), (6.1, 5.6), (6.3, 5.8), (6.5, 6.0), (6.7, 6.2)],\n            1.0, 1.0, 0.1, 0.1\n        ),\n        # Test case 3\n        (\n            [(6.0, 5.0), (6.2, 5.1), (6.1, 5.0), (5.9, 4.9), (6.0, 5.1)],\n            [(6.1, 5.1), (6.3, 5.2), (6.0, 4.9), (5.8, 4.8), (6.2, 5.2)],\n            1.0, 0.5, 5.0, 1.0\n        ),\n        # Test case 4\n        (\n            [(6.0, 5.0), (6.1, 5.1), (6.2, 5.2)],\n            [],\n            1.0, 1.0, 2.0, 0.3\n        )\n    ]\n\n    all_results = []\n    for case in test_cases:\n        seq_a, seq_b, w_maj, w_min, p_o, p_e = case\n        cost, matches, gaps = align_grooves(seq_a, seq_b, w_maj, w_min, p_o, p_e)\n        all_results.append(f\"[{cost:.6f},{matches},{gaps}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\ndef align_grooves(seq_a, seq_b, w_maj, w_min, p_o, p_e):\n    \"\"\"\n    Performs global alignment with affine gap penalties.\n    \"\"\"\n    n = len(seq_a)\n    m = len(seq_b)\n\n    if n == 0 and m == 0:\n        return 0.0, 0, 0\n    if n == 0:\n        cost = p_o + m * p_e if m > 0 else 0\n        return cost, 0, m\n    if m == 0:\n        cost = p_o + n * p_e if n > 0 else 0\n        return cost, 0, n\n\n    a = np.array(seq_a, dtype=float)\n    b = np.array(seq_b, dtype=float)\n\n    # DP tables\n    M_dp = np.full((n + 1, m + 1), np.inf)\n    Ix_dp = np.full((n + 1, m + 1), np.inf)\n    Iy_dp = np.full((n + 1, m + 1), np.inf)\n\n    # Pre-compute match costs\n    match_costs = np.zeros((n, m))\n    for i in range(n):\n        for j in range(m):\n            diff = a[i] - b[j]\n            match_costs[i, j] = w_maj * (diff[0] ** 2) + w_min * (diff[1] ** 2)\n\n    # Initialization\n    M_dp[0, 0] = 0.0\n    for i in range(1, n + 1):\n        Ix_dp[i, 0] = p_o + i * p_e\n    for j in range(1, m + 1):\n        Iy_dp[0, j] = p_o + j * p_e\n\n    # Fill DP tables\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # M_dp state\n            prev_cost_m = min(M_dp[i - 1, j - 1], Ix_dp[i - 1, j - 1], Iy_dp[i - 1, j - 1])\n            M_dp[i, j] = match_costs[i - 1, j - 1] + prev_cost_m\n\n            # Ix_dp state (gap in seq_b)\n            open_cost_x = min(M_dp[i - 1, j], Iy_dp[i - 1, j]) + p_o + p_e\n            extend_cost_x = Ix_dp[i - 1, j] + p_e\n            Ix_dp[i, j] = min(open_cost_x, extend_cost_x)\n\n            # Iy_dp state (gap in seq_a)\n            open_cost_y = min(M_dp[i, j - 1], Ix_dp[i, j - 1]) + p_o + p_e\n            extend_cost_y = Iy_dp[i, j - 1] + p_e\n            Iy_dp[i, j] = min(open_cost_y, extend_cost_y)\n\n    # Final minimal cost\n    final_cost = min(M_dp[n, m], Ix_dp[n, m], Iy_dp[n, m])\n\n    # Traceback\n    matches, gaps = 0, 0\n    i, j = n, m\n    \n    # Determine initial state for traceback\n    final_states = [M_dp[n, m], Ix_dp[n, m], Iy_dp[n, m]]\n    state_idx = np.argmin(final_states)\n\n    while i > 0 or j > 0:\n        if state_idx == 0:  # Current state is Match\n            matches += 1\n            prev_val = M_dp[i, j] - match_costs[i - 1, j - 1]\n            i_prev, j_prev = i - 1, j - 1\n            # Tie-breaking order: M -> Ix -> Iy\n            if np.isclose(prev_val, M_dp[i_prev, j_prev]):\n                state_idx = 0\n            elif np.isclose(prev_val, Ix_dp[i_prev, j_prev]):\n                state_idx = 1\n            else:\n                state_idx = 2\n            i, j = i_prev, j_prev\n        elif state_idx == 1:  # Current state is Ix (gap in b)\n            gaps += 1\n            extend_cost = Ix_dp[i - 1, j] + p_e\n            i_prev = i - 1\n            if np.isclose(Ix_dp[i, j], extend_cost):\n                state_idx = 1\n            else: # Gap was opened\n                # Tie-break M vs Iy\n                if M_dp[i_prev, j] = Iy_dp[i_prev, j]:\n                    state_idx = 0\n                else: \n                    state_idx = 2\n            i = i_prev\n        elif state_idx == 2:  # Current state is Iy (gap in a)\n            gaps += 1\n            extend_cost = Iy_dp[i, j - 1] + p_e\n            j_prev = j - 1\n            if np.isclose(Iy_dp[i, j], extend_cost):\n                state_idx = 2\n            else: # Gap was opened\n                # Tie-break M vs Ix\n                if M_dp[i, j_prev] = Ix_dp[i, j_prev]:\n                    state_idx = 0\n                else:\n                    state_idx = 1\n            j = j_prev\n            \n    return final_cost, matches, gaps\n\nsolve()\n```", "id": "2386718"}]}