{"hands_on_practices": [{"introduction": "The stability of a double helix is not uniform but depends on its specific sequence of base pairs. The nearest-neighbor model allows us to predict the thermodynamic stability, quantified by the standard Gibbs free energy change ($\\Delta G^{\\circ}$), by summing the contributions of adjacent base-pair \"steps\". This practice [@problem_id:2440503] allows you to apply this powerful model to quantitatively compare the stability of a DNA:DNA duplex versus an RNA:DNA hybrid, translating the chemical rules of base pairing into predictive physical chemistry.", "problem": "A short duplex is modeled using the nearest-neighbor additivity of the standard Gibbs free energy of formation, where the total standard Gibbs free energy change of duplex formation, $\\Delta G^{\\circ}_{\\mathrm{form}}$, is the sum of stepwise dinucleotide contributions along the strand, ignoring initiation and terminal corrections. Consider the deoxyribonucleic acid (DNA) sequence $5'$-$\\mathrm{GCGC}$-$3'$ forming either a DNA:DNA duplex with its exact Watson–Crick complement $3'$-$\\mathrm{CGCG}$-$5'$, or a ribonucleic acid (RNA):DNA hybrid helix where the RNA strand is $5'$-$\\mathrm{GCGC}$-$3'$ paired to the DNA complement $3'$-$\\mathrm{CGCG}$-$5'$. Assume standard conditions at $T=310\\ \\mathrm{K}$ and that the energy required to separate a duplex equals the magnitude of the standard Gibbs free energy of formation of that duplex.\n\nUse the following standard Gibbs free energy contributions per nearest-neighbor step (units: $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$):\n\n- DNA:DNA steps:\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) = -9.37$\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC}) = -9.08$\n\n- RNA:DNA steps (notation $\\mathrm{rXY}/\\mathrm{dZW}$ denotes RNA step $\\mathrm{XY}$ paired with the complementary DNA step $\\mathrm{ZW}$):\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) = -11.30$\n  - $\\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC}) = -9.21$\n\nFor the sequence $5'$-$\\mathrm{GCGC}$-$3'$, the three nearest-neighbor steps encountered along the $5'\\to 3'$ direction are $\\mathrm{GC}/\\mathrm{CG}$, $\\mathrm{CG}/\\mathrm{GC}$, and $\\mathrm{GC}/\\mathrm{CG}$ for DNA:DNA, and analogously $\\mathrm{rGC}/\\mathrm{dCG}$, $\\mathrm{rCG}/\\mathrm{dGC}$, and $\\mathrm{rGC}/\\mathrm{dCG}$ for RNA:DNA.\n\nCompute the additional energy required to separate the RNA:DNA hybrid relative to the DNA:DNA duplex for this sequence, defined as\n$\\Delta E = E_{\\mathrm{sep}}(\\mathrm{RNA:DNA}) - E_{\\mathrm{sep}}(\\mathrm{DNA:DNA})$,\nand express your final answer in $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$. Round your answer to $4$ significant figures.", "solution": "The problem statement presents a well-defined question based on the established nearest-neighbor model for nucleic acid thermodynamics. All necessary data, conditions, and simplifying assumptions are explicitly provided. The problem is scientifically grounded, objective, and self-contained. It is therefore deemed valid and we proceed with the solution.\n\nThe thermodynamic stability of a nucleic acid duplex is quantified by the standard Gibbs free energy change of its formation, $\\Delta G^{\\circ}_{\\mathrm{form}}$. According to the nearest-neighbor model, this total energy is the sum of the entropic and enthalpic contributions from adjacent base-pair steps, with initiation and terminal effects being ignored as specified.\n\nFirst, we calculate the standard Gibbs free energy of formation for the DNA:DNA duplex. The sequence is $5'$-$\\mathrm{GCGC}$-$3'$, which has $4-1=3$ nearest-neighbor steps. As stated in the problem, these steps are traversed from the $5'$ to the $3'$ end, yielding the sequence of dinucleotide pairs: $\\mathrm{GC}/\\mathrm{CG}$, $\\mathrm{CG}/\\mathrm{GC}$, and $\\mathrm{GC}/\\mathrm{CG}$.\n\nThe total standard Gibbs free energy for the DNA:DNA duplex is the sum of the contributions from these steps:\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) + \\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC}) + \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG})\n$$\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = 2 \\cdot \\Delta G^{\\circ}_{37}(\\mathrm{GC}/\\mathrm{CG}) + \\Delta G^{\\circ}_{37}(\\mathrm{CG}/\\mathrm{GC})\n$$\nSubstituting the provided values in units of $\\mathrm{kJ}\\ \\mathrm{mol}^{-1}$:\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) = 2 \\cdot (-9.37) + (-9.08) = -18.74 - 9.08 = -27.82\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n\nNext, we perform the analogous calculation for the RNA:DNA hybrid duplex. The RNA strand is $5'$-$\\mathrm{GCGC}$-$3'$, and the DNA complement is $3'$-$\\mathrm{CGCG}$-$5'$. The nearest-neighbor steps are $\\mathrm{rGC}/\\mathrm{dCG}$, $\\mathrm{rCG}/\\mathrm{dGC}$, and $\\mathrm{rGC}/\\mathrm{dCG}$.\n\nThe total standard Gibbs free energy for the RNA:DNA hybrid is:\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) + \\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC}) + \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG})\n$$\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = 2 \\cdot \\Delta G^{\\circ}_{37}(\\mathrm{rGC}/\\mathrm{dCG}) + \\Delta G^{\\circ}_{37}(\\mathrm{rCG}/\\mathrm{dGC})\n$$\nSubstituting the provided values:\n$$\n\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA}) = 2 \\cdot (-11.30) + (-9.21) = -22.60 - 9.21 = -31.81\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\n\nThe problem defines the energy required to separate a duplex, $E_{\\mathrm{sep}}$, as the magnitude of its standard Gibbs free energy of formation. Since duplex formation is a spontaneous process, $\\Delta G^{\\circ}_{\\mathrm{form}}$ is negative, and thus the separation energy is positive:\n$$\nE_{\\mathrm{sep}} = |\\Delta G^{\\circ}_{\\mathrm{form}}| = -\\Delta G^{\\circ}_{\\mathrm{form}}\n$$\nThe quantity to be computed is the additional energy required to separate the RNA:DNA hybrid relative to the DNA:DNA duplex, denoted as $\\Delta E$:\n$$\n\\Delta E = E_{\\mathrm{sep}}(\\mathrm{RNA{:}DNA}) - E_{\\mathrm{sep}}(\\mathrm{DNA{:}DNA})\n$$\nSubstituting the expression for $E_{\\mathrm{sep}}$:\n$$\n\\Delta E = (-\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA})) - (-\\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}))\n$$\n$$\n\\Delta E = \\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{DNA{:}DNA}) - \\Delta G^{\\circ}_{\\mathrm{form}}(\\mathrm{RNA{:}DNA})\n$$\nWe can now substitute the calculated free energy values:\n$$\n\\Delta E = (-27.82\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}) - (-31.81\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1})\n$$\n$$\n\\Delta E = -27.82 + 31.81 = 3.99\\ \\mathrm{kJ}\\ \\mathrm{mol}^{-1}\n$$\nThe problem requires the answer to be rounded to $4$ significant figures. The calculated value is $3.99$. To express this with four significant figures, we write it as $3.990$. The positive value of $\\Delta E$ indicates that the RNA:DNA hybrid is more stable and requires more energy to separate than its DNA:DNA counterpart for this specific sequence.", "answer": "$$\n\\boxed{3.990}\n$$", "id": "2440503"}, {"introduction": "Beyond analysis, computational biology empowers us to design novel sequences with specific behaviors, a cornerstone of synthetic biology. A crucial design challenge is creating sets of DNA sequences, such as barcodes for multiplexed experiments, that will not cross-hybridize with one another. In this hands-on coding problem [@problem_id:2440493], you will translate this biophysical concept into a functional algorithm that screens for such sequences, applying your understanding of base pairing to solve a practical problem in sequence analysis.", "problem": "Write a complete program that, given deoxyribonucleic acid (DNA) sequences over the alphabet {\"A\",\"C\",\"G\",\"T\"}, detects the starting indices of all \"slippery\" windows according to a model grounded in Watson-Crick base pairing. Adenine–Thymine base pairs contribute $2$ hydrogen bonds, and Guanine–Cytosine base pairs contribute $3$ hydrogen bonds. A window is considered \"weak\" if its average hydrogen bonds per base is at most a specified threshold. A window is considered \"slippery\" if and only if it is weak and, within the same window, there exists either (i) an adenine or thymine homopolymer run of length at least a specified integer, or (ii) a contiguous tandem repeat of the dinucleotide motif \"AT\" or \"TA\" repeated at least a specified integer number of times.\n\nFormally, let a sequence be a string $s$ of length $n$ over $\\{A,C,G,T\\}$. Let $w$ be the window length with $1 \\le w \\le n$ for sliding-window evaluation; if $n < w$, there are no windows. For each starting index $i$ with $0 \\le i \\le n-w$, consider the window $s[i:i+w]$. Define $N_{AT}(i)$ as the count of characters in $\\{A,T\\}$ in the window and $N_{GC}(i)=w-N_{AT}(i)$. The average hydrogen bond count per base in the window is\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3\\,N_{GC}(i)}{w}.\n$$\nGiven a real threshold $h_{\\max}$, the window is weak if $\\bar{h}(i) \\le h_{\\max}$. Within the same window, define:\n- A homopolymer condition $H(i)$ that is true if there exist indices $j$ and an integer run length $\\ell \\ge L_{\\text{run}}$ such that $s[j]=s[j+1]=\\cdots=s[j+\\ell-1]$ and $s[j]\\in\\{A,T\\}$ and $[j, j+\\ell-1] \\subseteq [i, i+w-1]$.\n- A dinucleotide repeat condition $D(i)$ that is true if there exist an index $j$, a motif $m\\in\\{\\text{\"AT\"},\\text{\"TA\"}\\}$, and an integer $r \\ge R_{\\text{rep}}$ such that the substring $s[j:j+2r]$ equals $m$ concatenated with itself $r$ times, and $[j, j+2r-1] \\subseteq [i, i+w-1]$.\n\nA window $s[i:i+w]$ is slippery if and only if $\\bar{h}(i) \\le h_{\\max}$ and $(H(i) \\lor D(i))$ is true. Indices are $0$-based.\n\nYour program must, for each test case, output the list of all starting indices $i$ such that $s[i:i+w]$ is slippery. If $n < w$, output the empty list for that test case.\n\nTest suite. Your program must evaluate the following test cases in order and aggregate the lists of indices into a single output line as specified below:\n- Case $1$: $s=\\text{\"GAAAAAAG\"}$, $w=8$, $h_{\\max}=2.25$, $L_{\\text{run}}=6$, $R_{\\text{rep}}=3$.\n- Case $2$: $s=\\text{\"CCCCCC\"}$, $w=4$, $h_{\\max}=2.4$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=2$.\n- Case $3$: $s=\\text{\"ATATATGC\"}$, $w=6$, $h_{\\max}=2.2$, $L_{\\text{run}}=5$, $R_{\\text{rep}}=3$.\n- Case $4$: $s=\\text{\"TTTTT\"}$, $w=3$, $h_{\\max}=2.0$, $L_{\\text{run}}=3$, $R_{\\text{rep}}=2$.\n- Case $5$: $s=\\text{\"AATTAATT\"}$, $w=4$, $h_{\\max}=2.0$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=2$.\n- Case $6$: $s=\\text{\"AT\"}$, $w=3$, $h_{\\max}=2.5$, $L_{\\text{run}}=2$, $R_{\\text{rep}}=2$.\n- Case $7$: $s=\\text{\"ATATATAT\"}$, $w=6$, $h_{\\max}=2.1$, $L_{\\text{run}}=4$, $R_{\\text{rep}}=3$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list of indices for the corresponding test case, and no spaces appear anywhere in the line. For example, an output with three test cases would look like $[[i\\_1,\\dots],[\\dots],[]]$ with no spaces. Indices must be integers.", "solution": "The problem requires the identification of \"slippery\" windows within a given deoxyribonucleic acid (DNA) sequence. A window is designated as slippery if it satisfies two distinct criteria simultaneously: a biophysical criterion of \"weakness\" based on hydrogen bond content, and a structural criterion related to the presence of specific repetitive motifs. The solution necessitates a systematic evaluation of all possible windows of a specified length.\n\nThe algorithm proceeds by sliding a window of length $w$ across the input sequence $s$ of length $n$. For each possible starting index $i$, where $0 \\le i \\le n-w$, the corresponding substring $s[i:i+w]$ is analyzed. If $n < w$, no such windows exist, and the result is an empty set of indices.\n\nFor each window, we first evaluate the weakness criterion. The average hydrogen bond count per base, $\\bar{h}(i)$, is a function of the number of Adenine-Thymine bases, $N_{AT}(i)$, and Guanine-Cytosine bases, $N_{GC}(i)$, within the window. Given that Adenine-Thymine pairs are joined by $2$ hydrogen bonds and Guanine-Cytosine by $3$, the formula is:\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3\\,N_{GC}(i)}{w}\n$$\nSince $N_{AT}(i) + N_{GC}(i) = w$, we may substitute $N_{GC}(i) = w - N_{AT}(i)$ to obtain a simplified expression:\n$$\n\\bar{h}(i) \\;=\\; \\frac{2\\,N_{AT}(i) \\;+\\; 3(w - N_{AT}(i))}{w} \\;=\\; \\frac{3w - N_{AT}(i)}{w} \\;=\\; 3 - \\frac{N_{AT}(i)}{w}\n$$\nA window is defined as weak if this average does not exceed a specified threshold $h_{\\max}$. That is, the condition is $\\bar{h}(i) \\le h_{\\max}$. If a window does not satisfy this condition, it cannot be slippery, and the algorithm proceeds to the next window.\n\nIf the window is found to be weak, it is then subjected to the structural criterion. This criterion is met if either of two conditions, $H(i)$ or $D(i)$, is true for the substring $s[i:i+w]$.\n\nThe first structural condition, the homopolymer condition $H(i)$, is satisfied if the window contains a contiguous run of a single base, where the base is either Adenine ('A') or Thymine ('T'), and the length of this run $\\ell$ is at least a specified integer $L_{\\text{run}}$. This is equivalent to checking for the presence of the substring $'A' \\times L_{\\text{run}}$ or $'T' \\times L_{\\text{run}}$ within the window.\n\nThe second structural condition, the dinucleotide repeat condition $D(i)$, is satisfied if the window contains a contiguous tandem repeat of the dinucleotide motif 'AT' or 'TA'. The number of repetitions, $r$, must be at least a specified integer $R_{\\text{rep}}$. This corresponds to searching for the substring $('AT') \\times R_{\\text{rep}}$ or $('TA') \\times R_{\\text{rep}}$ within the window.\n\nA window starting at index $i$ is formally classified as slippery if and only if it is weak and also satisfies the logical disjunction $(H(i) \\lor D(i))$. The algorithm must collect all such indices $i$.\n\nThe computational procedure is as follows:\n$1$. For a given test case with parameters $s, w, h_{\\max}, L_{\\text{run}}, R_{\\text{rep}}$, determine the length of the sequence, $n$. If $n < w$, return an empty list.\n$2$. Pre-construct the motif strings for the structural checks: an A-homopolymer of length $L_{\\text{run}}$, a T-homopolymer of length $L_{\\text{run}}$, an AT-dinucleotide repeat of length $2R_{\\text{rep}}$, and a TA-dinucleotide repeat of length $2R_{\\text{rep}}$.\n$3$. Iterate with index $i$ from $0$ to $n-w$. For each $i$:\n    a. Extract the window substring $s[i:i+w]$.\n    b. Calculate $N_{AT}(i)$, the count of 'A' and 'T' bases in the window.\n    c. Check the weakness condition: $3w - N_{AT}(i) \\le h_{\\max} \\times w$. If this is false, continue to the next value of $i$.\n    d. If the window is weak, check the structural conditions: determine if any of the pre-constructed motif strings are present as substrings within the window.\n    e. If the structural condition is met, add the index $i$ to a list of results.\n$4$. After the loop completes, the final list of collected indices is the solution for the test case. This procedure is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef find_slippery_windows(s: str, w: int, h_max: float, L_run: int, R_rep: int) -> list[int]:\n    \"\"\"\n    Detects the starting indices of all \"slippery\" windows in a DNA sequence.\n\n    A window is slippery if it is \"weak\" (low average hydrogen bonds) and contains\n    either a long A/T homopolymer or a tandem AT/TA repeat.\n    \"\"\"\n    n = len(s)\n    if n < w:\n        return []\n\n    slippery_indices = []\n\n    # Pre-generate the search motifs to avoid repeated string construction.\n    # The homopolymer condition requires a run of length *at least* L_run.\n    # Searching for a substring of exactly length L_run is sufficient because if a\n    # longer run exists, it must contain a run of length L_run.\n    homopolymer_A = 'A' * L_run\n    homopolymer_T = 'T' * L_run\n    \n    # Similarly, for dinucleotide repeats of length at least R_rep.\n    repeat_AT = 'AT' * R_rep\n    repeat_TA = 'TA' * R_rep\n\n    for i in range(n - w + 1):\n        window = s[i : i + w]\n\n        # 1. Weakness criterion evaluation.\n        # The average hydrogen bond count is (2*N_AT + 3*N_GC) / w.\n        # N_GC = w - N_AT.\n        # So, h_avg = (2*N_AT + 3*(w - N_AT)) / w = (3w - N_AT) / w.\n        # Condition: h_avg <= h_max  =>  (3w - N_AT) / w <= h_max\n        # To maintain precision, we use integer/float arithmetic on the un-divided form:\n        # 3w - N_AT <= h_max * w\n        n_at = window.count('A') + window.count('T')\n        \n        is_weak = (3 * w - n_at) <= h_max * w\n        \n        if not is_weak:\n            continue\n\n        # 2. Structural motif evaluation.\n        # This condition is checked only if the window is weak.\n        # H(i): Homopolymer of 'A' or 'T' of length >= L_run.\n        homopolymer_found = (homopolymer_A in window) or (homopolymer_T in window)\n\n        # D(i): Tandem repeat of 'AT' or 'TA' with >= R_rep repetitions.\n        dinucleotide_repeat_found = (repeat_AT in window) or (repeat_TA in window)\n\n        if homopolymer_found or dinucleotide_repeat_found:\n            slippery_indices.append(i)\n            \n    return slippery_indices\n\ndef solve():\n    \"\"\"\n    Runs the validation and solution for all test cases provided in the problem.\n    \"\"\"\n    test_cases = [\n        # (s, w, h_max, L_run, R_rep)\n        (\"GAAAAAAG\", 8, 2.25, 6, 3),\n        (\"CCCCCC\", 4, 2.4, 4, 2),\n        (\"ATATATGC\", 6, 2.2, 5, 3),\n        (\"TTTTT\", 3, 2.0, 3, 2),\n        (\"AATTAATT\", 4, 2.0, 4, 2),\n        (\"AT\", 3, 2.5, 2, 2),\n        (\"ATATATAT\", 6, 2.1, 4, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        s, w, h_max, l_run, r_rep = case\n        result = find_slippery_windows(s, w, h_max, l_run, r_rep)\n        results.append(result)\n\n    # Format the final output string to be exactly as specified, with no spaces.\n    # e.g., [[0],[],[0,1,2]]\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2440493"}, {"introduction": "Moving beyond analysis, computational biology empowers us to design novel sequences with specific behaviors, a cornerstone of synthetic biology. A crucial design challenge is creating sets of DNA sequences, such as barcodes for multiplexed experiments, that will not cross-hybridize with one another. This coding exercise [@problem_id:2440515] challenges you to solve this exact problem by finding an optimal subset of sequences that maximizes pairwise dissimilarity, considering both direct and reverse-complement interactions, thereby applying Watson-Crick rules to an engineering objective.", "problem": "You are given a finite ordered set of deoxyribonucleic acid (DNA) oligonucleotide sequences over the alphabet $\\Sigma=\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$. Each oligonucleotide (oligo) has the same length $L$. Let the set be $S=\\{s_0,s_1,\\ldots,s_{n-1}\\}$, where $n$ is the number of sequences and $s_i \\in \\Sigma^L$. The Watson–Crick complement maps $\\mathrm{A}\\leftrightarrow\\mathrm{T}$ and $\\mathrm{C}\\leftrightarrow\\mathrm{G}$. For a sequence $x=x_0x_1\\ldots x_{L-1}$, define its reverse complement $\\mathrm{rc}(x)=\\overline{x_{L-1}}\\ \\overline{x_{L-2}}\\ \\ldots\\ \\overline{x_0}$, where $\\overline{\\cdot}$ denotes the Watson–Crick complement of a nucleotide. For any two sequences $x,y\\in\\Sigma^L$, define the Hamming distance $H(x,y)=|\\{i\\in\\{0,1,\\ldots,L-1\\}: x_i\\neq y_i\\}|$. For a subset $B\\subseteq S$ with $|B|=k$ where $2\\le k\\le n$, define its robustness score\n$$\nD(B)=\\min_{\\{u,v\\}\\subseteq B,\\,u\\neq v}\\ \\min\\big(H(u,v),\\ H\\big(u,\\mathrm{rc}(v)\\big)\\big).\n$$\nYour task is to select an index set $I\\subseteq\\{0,1,\\ldots,n-1\\}$ with $|I|=k$ that maximizes $D(\\{s_i: i\\in I\\})$. If multiple index sets achieve the same maximum value of $D(\\cdot)$, select the one whose sorted index tuple is lexicographically smallest with respect to the natural order on $\\mathbb{Z}$.\n\nYour program must implement this selection for each of the following test cases. In each case, the sequences are listed in the given order, which determines indices $0,1,\\ldots,n-1$. All sequences have equal length $L$ in a given case.\n\nTest suite:\n- Case $1$: $L=6$, $k=4$, with $n=8$ and\n  $s_0=\\mathrm{ACGTAC}$,\n  $s_1=\\mathrm{TGCATG}$,\n  $s_2=\\mathrm{GTACGT}$,\n  $s_3=\\mathrm{CAGTCA}$,\n  $s_4=\\mathrm{GACTGT}$,\n  $s_5=\\mathrm{ATGCAT}$,\n  $s_6=\\mathrm{CATGCA}$,\n  $s_7=\\mathrm{TATATA}$.\n- Case $2$: $L=5$, $k=2$, with $n=6$ and\n  $s_0=\\mathrm{AAAAA}$,\n  $s_1=\\mathrm{AAAAT}$,\n  $s_2=\\mathrm{AAATA}$,\n  $s_3=\\mathrm{AATAA}$,\n  $s_4=\\mathrm{ATAAA}$,\n  $s_5=\\mathrm{TAAAA}$.\n- Case $3$: $L=6$, $k=3$, with $n=6$ and\n  $s_0=\\mathrm{AACCGG}$,\n  $s_1=\\mathrm{CCGGTT}$,\n  $s_2=\\mathrm{TTGGCC}$,\n  $s_3=\\mathrm{ACACAC}$,\n  $s_4=\\mathrm{GTGTGT}$,\n  $s_5=\\mathrm{AGCTAG}$.\n- Case $4$: $L=3$, $k=2$, with $n=5$ and\n  $s_0=\\mathrm{AAA}$,\n  $s_1=\\mathrm{TTT}$,\n  $s_2=\\mathrm{CGC}$,\n  $s_3=\\mathrm{GCG}$,\n  $s_4=\\mathrm{ATG}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results for all cases as a comma-separated list enclosed in square brackets. For each case, output a list whose first element is the optimal robustness score $D^*$ (an integer) and whose subsequent $k$ elements are the selected indices in increasing order. Thus the overall output has the form\n$[[D^*,i_1,\\ldots,i_k],\\ldots]$\nwith one inner list per test case, in the same order as listed above, and with all indices using zero-based indexing. No physical units are involved, and no angles or percentages are required.", "solution": "The user has presented a problem in computational biology, specifically in the domain of DNA sequence design. The problem is to select a subset of $k$ oligonucleotide sequences from a given set of $n$ sequences, each of length $L$, such that a \"robustness score\" is maximized. This score is defined to prevent undesired hybridization, both between sequences and between a sequence and the reverse complement of another.\n\nFirst, a validation of the problem statement is required.\n\n**Step 1: Extract Givens**\n\n- **Alphabet**: $\\Sigma=\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$.\n- **Input Set**: $S=\\{s_0,s_1,\\ldots,s_{n-1}\\}$, where $s_i \\in \\Sigma^L$ and $n$ is the number of sequences.\n- **Watson–Crick Complement**: $\\overline{\\mathrm{A}}=\\mathrm{T}, \\overline{\\mathrm{T}}=\\mathrm{A}, \\overline{\\mathrm{C}}=\\mathrm{G}, \\overline{\\mathrm{G}}=\\mathrm{C}$.\n- **Reverse Complement**: For a sequence $x=x_0x_1\\ldots x_{L-1}$, its reverse complement is $\\mathrm{rc}(x)=\\overline{x_{L-1}}\\ \\overline{x_{L-2}}\\ \\ldots\\ \\overline{x_0}$.\n- **Hamming Distance**: For two sequences $x,y\\in\\Sigma^L$, $H(x,y)=|\\{i\\in\\{0,1,\\ldots,L-1\\}: x_i\\neq y_i\\}|$ is the number of positions at which the corresponding characters are different.\n- **Robustness Score**: For a subset $B\\subseteq S$ with $|B|=k$, the score is $D(B)=\\min_{\\{u,v\\}\\subseteq B,\\,u\\neq v}\\ \\min\\big(H(u,v),\\ H\\big(u,\\mathrm{rc}(v)\\big)\\big)$.\n- **Objective**: Find an index set $I\\subseteq\\{0,1,\\ldots,n-1\\}$ with $|I|=k$ that maximizes the score $D(\\{s_i: i\\in I\\})$.\n- **Tie-Breaking Rule**: If multiple index sets yield the same maximum score, the one whose sorted index tuple is lexicographically smallest is to be chosen.\n- **Test Cases**: Four specific instances of the problem are provided, with given parameters $L, k, n$ and sequences $s_i$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is analyzed against the required criteria:\n\n- **Scientifically Grounded**: The concepts employed—DNA sequences, Watson-Crick pairing, reverse complement, and Hamming distance—are fundamental and standard in molecular biology and bioinformatics. The objective of maximizing minimum pairwise dissimilarity (including reverse-complement interactions) is a canonical problem in the design of DNA barcodes, probes, and primers, where minimizing cross-hybridization is critical. Thus, the problem is scientifically sound and relevant.\n- **Well-Posed**: The problem is a well-defined combinatorial optimization task. The search space consists of all subsets of $S$ of size $k$, which is finite. The number of such subsets is $\\binom{n}{k}$. The objective function $D(B)$ is precisely defined for any such subset. The maximization of a function over a finite set is a well-posed problem. The tie-breaking rule ensures that the solution is unique.\n- **Objective**: The problem is specified using formal mathematical language and is devoid of any subjective or ambiguous terminology.\n\nThe problem exhibits none of the invalidity flaws. It is complete, consistent, realistic, and verifiable.\n\n**Verdict**: The problem is deemed valid.\n\n**Solution Design**\n\nThe task is to find a $k$-element subset of indices $I \\subseteq \\{0, 1, \\ldots, n-1\\}$ that maximizes the function $D_I = D(\\{s_i : i \\in I\\})$. This is a classic `max-min` optimization problem.\n\nThe search space is the set of all $k$-element subsets of the initial set of $n$ sequences. The size of this search space is given by the binomial coefficient $\\binom{n}{k}$. Let us evaluate this for the provided test cases:\n- Case 1: $n=8, k=4 \\implies \\binom{8}{4} = 70$.\n- Case 2: $n=6, k=2 \\implies \\binom{6}{2} = 15$.\n- Case 3: $n=6, k=3 \\implies \\binom{6}{3} = 20$.\n- Case 4: $n=5, k=2 \\implies \\binom{5}{2} = 10$.\n\nThe number of candidate subsets in all cases is exceptionally small. This observation dictates the most logical and robust algorithmic approach: a direct, exhaustive search over the entire solution space. More complex methods, such as binary searching on the score value coupled with a maximum clique algorithm, are unnecessary and would introduce needless complexity for a problem of this scale.\n\nThe algorithm proceeds as follows:\n\n1.  **Preprocessing**: For each sequence $s_i$ in the input set $S$, compute its reverse complement, $\\mathrm{rc}(s_i)$. This is done once per sequence to avoid redundant computations.\n\n2.  **Enumeration**: Generate all possible $k$-element subsets of the index set $\\{0, 1, \\ldots, n-1\\}$. It is crucial to generate these subsets in lexicographical order of their index tuples. This ordering is standard in combinatorial libraries and directly satisfies the problem's tie-breaking rule.\n\n3.  **Evaluation**: For each generated index subset $I$:\n    a. Calculate its robustness score $D_I$. This requires computing the pairwise interaction term for all distinct pairs of indices $\\{i, j\\} \\subseteq I$. The interaction term is $d_{ij} = \\min\\big(H(s_i, s_j), H(s_i, \\mathrm{rc}(s_j))\\big)$.\n    b. The score for the subset $I$ is the minimum of these $d_{ij}$ values over all $\\binom{k}{2}$ pairs: $D_I = \\min_{i,j \\in I, i \\neq j} d_{ij}$.\n\n4.  **Selection**: Maintain two variables: `max_score`, storing the maximum score found so far, and `best_indices`, storing the corresponding index set. Initialize `max_score` to a value less than any possible score (e.g., $-1$).\n    - Iterate through the generated index subsets $I$ in lexicographical order.\n    - For each subset $I$, calculate its score $D_I$.\n    - If $D_I > \\mathrm{max\\_score}$, update $\\mathrm{max\\_score} = D_I$ and $\\mathrm{best\\_indices} = I$.\n    - Because the subsets are processed in lexicographical order, the first time we identify the maximum possible score, the corresponding index set is guaranteed to be the lexicographically smallest among all sets that achieve this score. Any subsequent set achieving the same score will be lexicographically larger and correctly ignored by the strict inequality $D_I > \\mathrm{max\\_score}$.\n\n5.  **Finalization**: After iterating through all $\\binom{n}{k}$ subsets, the variables `max_score` and `best_indices` will hold the optimal score and the required index set. The result is then formatted as a list comprising the score followed by the indices.\n\nThis exhaustive search is simple, foolproof, and efficient for the given constraints. The implementation will require helper functions for calculating the reverse complement and the Hamming distance.", "answer": "```python\nimport numpy as np\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the DNA sequence subset selection problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 6, \"k\": 4, \"n\": 8,\n            \"sequences\": [\n                \"ACGTAC\", \"TGCATG\", \"GTACGT\", \"CAGTCA\",\n                \"GACTGT\", \"ATGCAT\", \"CATGCA\", \"TATATA\"\n            ]\n        },\n        {\n            \"L\": 5, \"k\": 2, \"n\": 6,\n            \"sequences\": [\n                \"AAAAA\", \"AAAAT\", \"AAATA\", \"AATAA\",\n                \"ATAAA\", \"TAAAA\"\n            ]\n        },\n        {\n            \"L\": 6, \"k\": 3, \"n\": 6,\n            \"sequences\": [\n                \"AACCGG\", \"CCGGTT\", \"TTGGCC\", \"ACACAC\",\n                \"GTGTGT\", \"AGCTAG\"\n            ]\n        },\n        {\n            \"L\": 3, \"k\": 2, \"n\": 5,\n            \"sequences\": [\n                \"AAA\", \"TTT\", \"CGC\", \"GCG\", \"ATG\"\n            ]\n        }\n    ]\n\n    complement_map = str.maketrans(\"ACGT\", \"TGCA\")\n\n    def reverse_complement(seq: str) -> str:\n        \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n        return seq.translate(complement_map)[::-1]\n\n    def hamming_distance(s1: str, s2: str) -> int:\n        \"\"\"Computes the Hamming distance between two sequences of equal length.\"\"\"\n        # Using numpy for a concise representation.\n        # This is equivalent to sum(1 for c1, c2 in zip(s1, s2) if c1 != c2).\n        return np.sum(np.array(list(s1)) != np.array(list(s2)))\n\n    results = []\n    for case in test_cases:\n        k = case[\"k\"]\n        sequences = case[\"sequences\"]\n        n = case[\"n\"]\n        L = case[\"L\"]\n        \n        # Pre-compute reverse complements for efficiency\n        rc_sequences = [reverse_complement(s) for s in sequences]\n        \n        max_score = -1\n        best_indices = ()\n\n        # itertools.combinations generates sorted tuples in lexicographical order.\n        # This naturally handles the tie-breaking rule.\n        index_combinations = itertools.combinations(range(n), k)\n\n        for indices in index_combinations:\n            current_min_dist = L + 1 # Initialize with a value larger than any possible distance\n            \n            # Get all pairs of indices within the current combination\n            pair_indices = itertools.combinations(indices, 2)\n            \n            is_score_beaten = False\n            for i, j in pair_indices:\n                # Calculate the two relevant Hamming distances\n                h_direct = hamming_distance(sequences[i], sequences[j])\n                h_rc = hamming_distance(sequences[i], rc_sequences[j])\n                \n                dist = min(h_direct, h_rc)\n                \n                # Optimization: if a pair's distance is not better than the current max_score,\n                # the whole subset cannot be better. We can stop early.\n                if dist <= max_score:\n                    is_score_beaten = True\n                    break\n                \n                if dist < current_min_dist:\n                    current_min_dist = dist\n            \n            if is_score_beaten:\n                continue\n\n            # If the score for this subset is strictly greater than the best score found so far,\n            # update the best score and indices.\n            if current_min_dist > max_score:\n                max_score = current_min_dist\n                best_indices = indices\n\n        # Format the result for this case as [D*, i_1, ..., i_k]\n        case_result = [max_score] + list(best_indices)\n        results.append(case_result)\n        \n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440515"}]}