{"hands_on_practices": [{"introduction": "The genetic code's redundancy, where multiple codons specify the same amino acid, is a key feature. This exercise challenges you to model this biological reality using a classic computer science data structure—the hash table. By analyzing metrics like collision rates and load distribution, you will gain a quantitative understanding of how the code's degeneracy translates into computational properties and explore the interplay between information storage in biology and computer science [@problem_id:2380350].", "problem": "You are given the task of modeling the canonical genetic code using a hash table and quantitatively analyzing how the degeneracy of the code (multiple codons encoding the same amino acid) interacts with hashing behavior. The biological fundamentals to be used as the base are the Central Dogma of Molecular Biology, the definition of a codon and anticodon, and the experimentally established canonical genetic code. Specifically, Ribonucleic Acid (RNA) is translated in triplets of nucleotides called codons, each codon matches an anticodon carried by transfer Ribonucleic Acid (tRNA), and the mapping from codons to amino acids is many-to-one due to degeneracy. This degeneracy means there exist synonymous codons, i.e., distinct codons that map to the same amino acid. You will represent the codon-to-amino-acid mapping as a hash table with separate chaining and evaluate collision behavior under a specified family of hash functions.\n\nImplement a program that performs the following steps, strictly using the standard canonical RNA genetic code (with nucleotides $\\{ \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\}$ and codon alphabet $\\{ \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\}^3$), where each codon maps to an amino acid or a stop signal:\n\n- Construct the complete mapping from all $64$ RNA codons to amino acids (use one-letter amino acid codes and a single character such as $\\ast$ for stop). This mapping is fixed and must be the canonical genetic code.\n\n- Define a family of hash functions as follows. Let a codon be $c = c_0 c_1 c_2$ with $c_i \\in \\{ \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\}$. Choose an ordered alphabet $\\alpha$ that is a permutation of $\\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle$. Define a digitization map $\\phi_{\\alpha} : \\{ \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\} \\to \\{0,1,2,3\\}$ by position in $\\alpha$. Let weights be fixed as $w_0 = 1$, $w_1 = 4$, $w_2 = 16$. Define the hash index for modulus $M \\in \\mathbb{N}$ by\n$$\nh(c) = \\left( w_0 \\, \\phi_{\\alpha}(c_0) + w_1 \\, \\phi_{\\alpha}(c_1) + w_2 \\, \\phi_{\\alpha}(c_2) \\right) \\bmod M.\n$$\nUse separate chaining into $M$ buckets to build the hash table by inserting all $64$ codons.\n\n- For the resulting hash table, compute the following quantitative metrics that connect hashing to biological degeneracy:\n    1. Average bucket load $\\overline{L} = \\frac{1}{M} \\sum_{i=1}^{M} L_i$, where $L_i$ is the number of codons in bucket $i$. Note that by construction $\\sum_i L_i = 64$.\n    2. Maximum bucket load $\\max_i L_i$.\n    3. Total collision pairs\n    $$\n    C_{\\mathrm{tot}} = \\sum_{i=1}^{M} \\binom{L_i}{2},\n    $$\n    which counts unordered codon pairs that hash to the same bucket.\n    4. Synonymous collision pairs\n    $$\n    C_{\\mathrm{syn}} = \\sum_{i=1}^{M} \\sum_{a} \\binom{L_{i,a}}{2},\n    $$\n    where $L_{i,a}$ is the number of codons in bucket $i$ that map to amino acid $a$. This counts unordered colliding pairs within buckets that encode the same amino acid.\n    5. Non-synonymous collision pairs $C_{\\mathrm{non}} = C_{\\mathrm{tot}} - C_{\\mathrm{syn}}$.\n    6. Synonymous collision fraction\n    $$\n    f_{\\mathrm{syn}} = \n    \\begin{cases}\n    \\dfrac{C_{\\mathrm{syn}}}{C_{\\mathrm{tot}}}, & \\text{if } C_{\\mathrm{tot}} > 0,\\\\\n    0, & \\text{if } C_{\\mathrm{tot}} = 0,\n    \\end{cases}\n    $$\n    which is the proportion of colliding pairs that are synonymous.\n    7. Load variance\n    $$\n    \\sigma_L^2 = \\frac{1}{M} \\sum_{i=1}^{M} \\left(L_i - \\overline{L}\\right)^2,\n    $$\n    a distributional measure of load imbalance.\n    8. Shannon entropy (base $2$) of the bucket occupancy distribution\n    $$\n    H = - \\sum_{i=1}^{M} p_i \\log_2 p_i,\n    $$\n    where $p_i = \\frac{L_i}{64}$ for buckets with $L_i > 0$ and $p_i \\log_2 p_i$ is treated as $0$ when $L_i = 0$.\n\n- Your implementation must be general for any $M$ and any valid $\\alpha$ (a permutation of $\\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle$). Use separate chaining. No randomization is allowed.\n\nTest suite and required output:\n- Run your program on the following test cases $(M, \\alpha)$:\n    - $(64,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(61,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(32,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(16,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(23,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$,\n    - $(32,\\ \\langle \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U} \\rangle)$,\n    - $(1,\\ \\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle)$.\n- For each test, produce a result list in the following order:\n    - $\\overline{L}$,\n    - $\\max_i L_i$,\n    - $C_{\\mathrm{tot}}$,\n    - $C_{\\mathrm{syn}}$,\n    - $C_{\\mathrm{non}}$,\n    - $f_{\\mathrm{syn}}$,\n    - $\\sigma_L^2$,\n    - $H$.\n- The final output of the program must be a single line containing a list of these result lists, with no spaces, all floats rounded to $6$ decimal digits, for example:\n    - $\\text{\"[[1.000000,1,0,0,0,0.000000,0.000000,6.000000],[\\dots],\\dots]\"}$.\n\nNo physical units are involved. Do not print any additional text. Your program must be completely deterministic and self-contained, using the canonical genetic code only. The final output format is a single line with a comma-separated list enclosed in square brackets, where each per-testcase result itself is a bracketed comma-separated list in the exact order above.", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of molecular biology, specifically the canonical genetic code, and presents a well-posed computational task. The definitions, constraints, and objectives are specified with sufficient clarity and precision to permit a unique and deterministic solution. We will therefore proceed with the derivation and implementation of the solution.\n\nThe problem requires a quantitative analysis of a hashing model applied to the set of $64$ canonical RNA codons. The analysis connects the properties of a defined hash function family to the biological phenomenon of degeneracy in the genetic code.\n\nFirst, we establish the fundamental data. The set of RNA nucleotides is $\\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\}$. The set of codons is the Cartesian product $\\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\}^3$, yielding $4^3 = 64$ distinct codons. We implement the canonical genetic code as a mapping from each of these $64$ codons to one of the $20$ standard amino acids (represented by single-letter codes) or a stop signal (represented by $\\ast$). This mapping is fixed and empirically determined.\n\nThe core of the problem is to construct and analyze a hash table for these $64$ codons. The hash table has $M$ buckets and uses separate chaining for collision resolution. For a given test case specified by the parameters $(M, \\alpha)$, where $M \\in \\mathbb{N}$ is the number of buckets and $\\alpha$ is an ordered permutation of $\\langle \\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G} \\rangle$, the procedure is as follows:\n\nStep 1: Hash Table Construction\nWe first define the digitization map $\\phi_{\\alpha}: \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}, \\mathrm{G}\\} \\to \\{0, 1, 2, 3\\}$, which maps each nucleotide to its zero-based index in the ordered alphabet $\\alpha$. For a codon $c = c_0 c_1 c_2$, the hash function is given by:\n$$\nh(c) = \\left( w_0 \\, \\phi_{\\alpha}(c_0) + w_1 \\, \\phi_{\\alpha}(c_1) + w_2 \\, \\phi_{\\alpha}(c_2) \\right) \\bmod M\n$$\nwith fixed integer weights $w_0 = 1$, $w_1 = 4$, and $w_2 = 16$. The sum $\\sum_{i=0}^{2} w_i \\phi_{\\alpha}(c_i)$ provides a unique integer value from $0$ to $63$ for each codon, effectively treating the codon as a number in a base-$4$ positional system. We iterate through all $64$ codons, compute their hash index $h(c)$, and place them into the corresponding bucket, which is a list of codons that map to that index.\n\nStep 2: Calculation of Metrics\nAfter all $64$ codons are distributed among the $M$ buckets, we compute the following eight metrics. Let $L_i$ be the load (number of codons) in bucket $i$, for $i \\in \\{0, 1, \\dots, M-1\\}$.\n\n1.  Average bucket load, $\\overline{L}$: This is the total number of items ($64$) divided by the number of buckets ($M$).\n    $$\n    \\overline{L} = \\frac{64}{M}\n    $$\n2.  Maximum bucket load, $\\max_i L_i$: This is the maximum value among all bucket loads $L_i$.\n3.  Total collision pairs, $C_{\\mathrm{tot}}$: For a bucket with load $L_i$, there are $\\binom{L_i}{2}$ unordered pairs of codons that collide. The total is the sum over all buckets.\n    $$\n    C_{\\mathrm{tot}} = \\sum_{i=0}^{M-1} \\binom{L_i}{2} = \\sum_{i=0}^{M-1} \\frac{L_i (L_i - 1)}{2}\n    $$\n4.  Synonymous collision pairs, $C_{\\mathrm{syn}}$: This metric refines the total collisions by considering the biological meaning. We count only colliding pairs of codons that are synonymous (i.e., encode the same amino acid). For each bucket $i$, we group the codons by the amino acid $a$ they encode. Let $L_{i,a}$ be the number of codons in bucket $i$ for amino acid $a$. The number of synonymous pairs is the sum of $\\binom{L_{i,a}}{2}$ over all amino acids $a$ and all buckets $i$.\n    $$\n    C_{\\mathrm{syn}} = \\sum_{i=0}^{M-1} \\sum_{a} \\binom{L_{i,a}}{2}\n    $$\n5.  Non-synonymous collision pairs, $C_{\\mathrm{non}}$: This is simply the difference between total and synonymous collision pairs. These are pairs of codons that hash to the same bucket but encode different amino acids.\n    $$\n    C_{\\mathrm{non}} = C_{\\mathrm{tot}} - C_{\\mathrm{syn}}\n    $$\n6.  Synonymous collision fraction, $f_{\\mathrm{syn}}$: This is the ratio of synonymous collisions to total collisions, indicating the proportion of hash collisions that correspond to degenerate encodings.\n    $$\n    f_{\\mathrm{syn}} = \\begin{cases} \\dfrac{C_{\\mathrm{syn}}}{C_{\\mathrm{tot}}}, & \\text{if } C_{\\mathrm{tot}} > 0 \\\\ 0, & \\text{if } C_{\\mathrm{tot}} = 0 \\end{cases}\n    $$\n7.  Load variance, $\\sigma_L^2$: This measures the spread of the bucket load distribution around the mean load $\\overline{L}$. A lower variance indicates a more uniform distribution of codons.\n    $$\n    \\sigma_L^2 = \\frac{1}{M} \\sum_{i=0}^{M-1} (L_i - \\overline{L})^2\n    $$\n8.  Shannon entropy, $H$: This measures the uncertainty or \"disorder\" of the codon distribution across buckets. Let $p_i = L_i / 64$ be the probability that a randomly chosen codon falls into bucket $i$. The entropy is given in bits (base $2$).\n    $$\n    H = - \\sum_{i=0}^{M-1} p_i \\log_2 p_i\n    $$\n    where the term $p_i \\log_2 p_i$ is treated as $0$ if $p_i = 0$. A higher entropy corresponds to a more even distribution. For a perfect hash function with $M=64$, each $L_i=1$, so each $p_i = 1/64$, and $H = \\log_2(64) = 6$ bits, the maximum possible value.\n\nThe implementation will process each test case by executing these steps and formatting the eight resulting floating-point numbers to six decimal places, as specified.", "answer": "```python\nimport numpy as np\nfrom scipy.stats import entropy\n\ndef solve():\n    \"\"\"\n    Solves the computational biology problem by modeling the genetic code with a hash table\n    and analyzing its properties for a given set of test cases.\n    \"\"\"\n\n    # The canonical RNA genetic code mapping from codon to amino acid (1-letter) or stop (*).\n    CANONICAL_GENETIC_CODE = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': '*', 'UAG': '*',\n        'UGU': 'C', 'UGC': 'C', 'UGA': '*', 'UGG': 'W',\n\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n\n    # All 64 codons, derived from the keys of the genetic code map.\n    ALL_CODONS = list(CANONICAL_GENETIC_CODE.keys())\n    \n    # Weights for the hash function.\n    WEIGHTS = [1, 4, 16]\n\n    test_cases = [\n        (64, ('U', 'C', 'A', 'G')),\n        (61, ('U', 'C', 'A', 'G')),\n        (32, ('U', 'C', 'A', 'G')),\n        (16, ('U', 'C', 'A', 'G')),\n        (23, ('U', 'C', 'A', 'G')),\n        (32, ('A', 'C', 'G', 'U')),\n        (1, ('U', 'C', 'A', 'G')),\n    ]\n\n    all_results = []\n\n    for m_val, alpha in test_cases:\n        # Step 1: Build the hash table for the given test case (M, alpha)\n\n        # Create the digitization map phi_alpha\n        phi_alpha = {nucleotide: i for i, nucleotide in enumerate(alpha)}\n\n        # Initialize M buckets for separate chaining\n        buckets = [[] for _ in range(m_val)]\n\n        # Hash each of the 64 codons and place them in the appropriate bucket\n        for codon in ALL_CODONS:\n            h_val_unmod = (WEIGHTS[0] * phi_alpha[codon[0]] +\n                           WEIGHTS[1] * phi_alpha[codon[1]] +\n                           WEIGHTS[2] * phi_alpha[codon[2]])\n            h_index = h_val_unmod % m_val\n            buckets[h_index].append(codon)\n\n        # Step 2: Compute the quantitative metrics\n\n        # Get bucket loads Li\n        bucket_loads = [len(b) for b in buckets]\n\n        # 1. Average bucket load\n        avg_load = 64.0 / m_val\n\n        # 2. Maximum bucket load\n        max_load = 0\n        if bucket_loads:\n            max_load = max(bucket_loads)\n\n        # Helper function for combinations nC2\n        def n_choose_2(n):\n            return n * (n - 1) // 2\n\n        # 3. Total collision pairs\n        c_tot = sum(n_choose_2(load) for load in bucket_loads)\n\n        # 4. Synonymous collision pairs\n        c_syn = 0\n        for bucket in buckets:\n            if len(bucket) > 1:\n                aa_counts = {}\n                for codon in bucket:\n                    aa = CANONICAL_GENETIC_CODE[codon]\n                    aa_counts[aa] = aa_counts.get(aa, 0) + 1\n                \n                for count in aa_counts.values():\n                    c_syn += n_choose_2(count)\n        \n        # 5. Non-synonymous collision pairs\n        c_non = c_tot - c_syn\n\n        # 6. Synonymous collision fraction\n        f_syn = 0.0 if c_tot == 0 else c_syn / c_tot\n        \n        # 7. Load variance\n        load_variance = np.var(bucket_loads)\n        \n        # 8. Shannon entropy\n        # Probability distribution p_i = L_i / 64\n        probabilities = np.array(bucket_loads) / 64.0\n        shannon_entropy = entropy(probabilities, base=2)\n\n        # Collect and format results for the current test case\n        case_results = [\n            f\"{avg_load:.6f}\",\n            str(max_load),\n            str(c_tot),\n            str(c_syn),\n            str(c_non),\n            f\"{f_syn:.6f}\",\n            f\"{load_variance:.6f}\",\n            f\"{shannon_entropy:.6f}\",\n        ]\n        all_results.append(f\"[{','.join(case_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2380350"}, {"introduction": "Natural selection can act on sequences at the nucleotide level, potentially to minimize the impact of mutations. This practice simulates a real bioinformatics investigation by asking you to test a hypothesis: are codons that are one mutation away from a stop codon less frequent in essential genes? You will develop skills in sequence parsing, statistical analysis using contingency tables, and hypothesis testing, which are central to discovering evolutionary signals in genomic data [@problem_id:2380355].", "problem": "You are given the task of programmatically quantifying whether messenger ribonucleic acid (mRNA) codons that are exactly one point mutation away from a stop codon are underrepresented in a set of essential genes compared to a matched set of nonessential genes. The analysis must be founded on the Central Dogma of molecular biology (deoxyribonucleic acid to ribonucleic acid to protein), the definition of codons as length-$3$ triplets over the alphabet $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$, the existence of three stop codons $\\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$, and the base-pairing rules that define anticodons for transfer ribonucleic acid (tRNA). A codon is “near-stop” if its Hamming distance (the number of positions at which two strings of equal length differ) to any stop codon is exactly $1$, and the codon itself is not a stop codon. Only sense codons (non-stop codons) contribute to usage totals. Assume coding sequences are already spliced and provided in-frame in the $5'$ to $3'$ direction as strings over $\\Sigma$, with lengths that are multiples of $3$.\n\nStarting from these fundamentals:\n- The set of stop codons is $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$.\n- The set of all codons is $\\Sigma^3$, size $|\\Sigma^3| = 4^3 = 64$.\n- The set of sense codons is $\\Sigma^3 \\setminus S$.\n- A “near-stop” codon $c$ satisfies $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$ and $c \\notin S$.\n- Anticodons are the reverse-complements of codons under Watson–Crick pairing ($\\mathrm{A}\\leftrightarrow \\mathrm{U}$, $\\mathrm{C}\\leftrightarrow \\mathrm{G}$), but anticodons are used here only to justify the codon framework; the computation operates entirely at the codon level.\n\nYou must design an algorithm that:\n- Parses each gene sequence into non-overlapping codons in the given reading frame.\n- Excludes any stop codon encountered from usage counting.\n- Counts, for each gene set (essential versus nonessential), the total number of near-stop sense codons and the total number of non-near-stop sense codons.\n- Forms a $2\\times 2$ contingency table with entries:\n  - $a$: near-stop counts in essential genes,\n  - $b$: non-near-stop counts in essential genes,\n  - $c$: near-stop counts in nonessential genes,\n  - $d$: non-near-stop counts in nonessential genes.\n- Computes a smoothed log-odds ratio with Laplace smoothing parameter $\\alpha > 0$:\n  $$\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right).$$\n- Computes a two-sided Fisher’s exact test $p$-value for the table\n  $$\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}.$$\n  If any row or any column sum equals $0$ (that is, $a+b=0$ or $c+d=0$ or $a+c=0$ or $b+d=0$), define the two-sided $p$-value to be $1.0$ for the purpose of this program.\n- Declares “underrepresentation” in essential genes if and only if $\\mathrm{LOR}_\\alpha &lt; 0$ and the two-sided $p$-value is less than a specified significance threshold $\\tau$.\n\nImplementation requirements:\n- Work purely from the given sequences and definitions.\n- Treat all inputs as mRNA codons over $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$.\n- Ignore any trailing nucleotides that cannot form a full codon triplet (the provided sequences will be multiples of $3$).\n\nTest suite:\nImplement your program to run the following three independent test cases. Each test case specifies a set of essential gene sequences, a set of nonessential gene sequences, a smoothing parameter $\\alpha$, and a significance threshold $\\tau$. All sequences are valid mRNA coding sequences, each string’s length is a multiple of $3$, and no internal stop codons are included.\n\n- Test case $1$ (balanced usage; expect no underrepresentation):\n  - Essential genes:\n    - $\\mathrm{E1} = \\text{\"AAGGCUAAAGCUUUU\"}$ which parses as $(\\mathrm{AAG}, \\mathrm{GCU}, \\mathrm{AAA}, \\mathrm{GCU}, \\mathrm{UUU})$,\n    - $\\mathrm{E2} = \\text{\"GCCUGGUGGUUCGCA\"}$ which parses as $(\\mathrm{GCC}, \\mathrm{UGG}, \\mathrm{UGG}, \\mathrm{UUC}, \\mathrm{GCA})$.\n  - Nonessential genes:\n    - $\\mathrm{N1} = \\text{\"CAAGCUUAUGCGUUC\"}$ which parses as $(\\mathrm{CAA}, \\mathrm{GCU}, \\mathrm{UAU}, \\mathrm{GCG}, \\mathrm{UUC})$,\n    - $\\mathrm{N2} = \\text{\"AAAGCCUUGGCAUUU\"}$ which parses as $(\\mathrm{AAA}, \\mathrm{GCC}, \\mathrm{UUG}, \\mathrm{GCA}, \\mathrm{UUU})$.\n  - Parameters: $\\alpha = 1.0$, $\\tau = 0.05$.\n\n- Test case $2$ (strong underrepresentation in essential genes):\n  - Essential genes:\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUC\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUC})$,\n    - $\\mathrm{E2} = \\text{\"GCUGCGUUUUUCGCC\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$.\n  - Nonessential genes:\n    - $\\mathrm{N1} = \\text{\"AAAAAGCAAGAAUUA\"}$ which parses as $(\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{CAA}, \\mathrm{GAA}, \\mathrm{UUA})$,\n    - $\\mathrm{N2} = \\text{\"UGGUCGUAUUACAGA\"}$ which parses as $(\\mathrm{UGG}, \\mathrm{UCG}, \\mathrm{UAU}, \\mathrm{UAC}, \\mathrm{AGA})$.\n  - Parameters: $\\alpha = 0.5$, $\\tau = 0.01$.\n\n- Test case $3$ (edge case with zero near-stop counts in both groups):\n  - Essential genes:\n    - $\\mathrm{E1} = \\text{\"GCUGCCGCAGCGUUU\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG}, \\mathrm{UUU})$,\n    - $\\mathrm{E2} = \\text{\"UUCGCUGCCGCAGCG\"}$ which parses as $(\\mathrm{UUC}, \\mathrm{GCU}, \\mathrm{GCC}, \\mathrm{GCA}, \\mathrm{GCG})$.\n  - Nonessential genes:\n    - $\\mathrm{N1} = \\text{\"GCUGCGUUUUUCGCC\"}$ which parses as $(\\mathrm{GCU}, \\mathrm{GCG}, \\mathrm{UUU}, \\mathrm{UUC}, \\mathrm{GCC})$,\n    - $\\mathrm{N2} = \\text{\"GCAGCUUUCUUUGCG\"}$ which parses as $(\\mathrm{GCA}, \\mathrm{GCU}, \\mathrm{UUC}, \\mathrm{UUU}, \\mathrm{GCG})$.\n  - Parameters: $\\alpha = 1.0$, $\\tau = 0.05$.\n\nFinal output specification:\n- For each test case, your program must produce a triplet $[\\mathrm{LOR}_\\alpha, p, \\mathrm{underrep}]$, where $\\mathrm{LOR}_\\alpha$ is the smoothed log-odds ratio as defined above, $p$ is the two-sided Fisher exact $p$-value, and $\\mathrm{underrep}$ is a boolean indicating whether essential genes show statistically significant underrepresentation. Round all floating-point outputs to $6$ decimal places.\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, with each test case result itself rendered as a bracketed, comma-separated list. For example: \"[[x1,y1,True],[x2,y2,False],[x3,y3,True]]\".\n- There are no physical units, angles, or percentages required in this problem; all reported quantities are dimensionless real numbers or booleans.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded in molecular biology, mathematically well-posed, and provides a complete, unambiguous specification for the required algorithm and its parameters. We will therefore proceed with a complete solution.\n\nThe core of the problem is to quantify and test for the underrepresentation of a specific class of codons, termed \"near-stop\" codons, in essential genes compared to nonessential genes. The solution is executed in four logical stages.\n\n**Step 1: Formalization and Identification of Near-Stop Codons**\n\nThe problem defines a codon $c$ as \"near-stop\" if two conditions are met:\n1.  $c$ must be a sense codon, meaning it is not a member of the stop codon set $S = \\{\\mathrm{UAA}, \\mathrm{UAG}, \\mathrm{UGA}\\}$.\n2.  The Hamming distance from $c$ to its closest stop codon must be exactly $1$. This is expressed formally as $\\min_{s \\in S} \\mathrm{Hamming}(c, s) = 1$. The Hamming distance between two strings of equal length is the number of positions at which the corresponding symbols are different.\n\nTo implement this, we systematically generate all $4^3 = 64$ possible codons from the alphabet $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$. For each codon $c$, we first check if $c \\in S$. If it is, it is discarded. If $c \\notin S$, we then compute its Hamming distance to each of the three stop codons in $S$. If the minimum of these three distances is $1$, the codon $c$ is classified as near-stop.\n\nThis procedure yields the following set of $18$ near-stop codons, which will be pre-computed and used for all subsequent analysis:\n$\\{\\mathrm{AAA}, \\mathrm{AAG}, \\mathrm{AGA}, \\mathrm{CAA}, \\mathrm{CAG}, \\mathrm{CGA}, \\mathrm{GAA}, \\mathrm{GAG}, \\mathrm{GGA}, \\mathrm{UAC}, \\mathrm{UAU}, \\mathrm{UCA}, \\mathrm{UCG}, \\mathrm{UGC}, \\mathrm{UGU}, \\mathrm{UGG}, \\mathrm{UUA}, \\mathrm{UUG}\\}$.\n\n**Step 2: Sequence Processing and Contingency Table Construction**\n\nThe provided gene sequences are strings of mRNA bases. The algorithm processes each set of genes (essential and nonessential) as follows:\n1.  For each gene sequence, which is guaranteed to have a length that is a multiple of $3$, we parse it into a list of non-overlapping, in-frame codons of length $3$.\n2.  For each codon, we determine if it belongs to the pre-computed set of near-stop codons.\n3.  The problem states that input sequences do not contain stop codons, so every codon is a sense codon. A codon is either \"near-stop\" or \"non-near-stop\".\n4.  We accumulate counts across all genes within a set (essential or nonessential) to populate a $2 \\times 2$ contingency table of the form $\\begin{pmatrix} a & b \\\\ c & d \\end{pmatrix}$, where:\n    - $a$: Total count of near-stop codons in essential genes.\n    - $b$: Total count of non-near-stop sense codons in essential genes.\n    - $c$: Total count of near-stop codons in nonessential genes.\n    - $d$: Total count of non-near-stop sense codons in nonessential genes.\n\n**Step 3: Statistical Analysis**\n\nWith the contingency table constructed, two statistical measures are computed.\n\nFirst, the smoothed log-odds ratio ($\\mathrm{LOR}_\\alpha$) is calculated to estimate the magnitude and direction of the effect. The formula uses Laplace smoothing with a parameter $\\alpha > 0$ to handle potential zero counts:\n$$\n\\mathrm{LOR}_\\alpha = \\log\\left(\\frac{a+\\alpha}{b+\\alpha}\\right) - \\log\\left(\\frac{c+\\alpha}{d+\\alpha}\\right)\n$$\nA negative $\\mathrm{LOR}_\\alpha$ indicates that the odds of a codon being near-stop are lower in the essential gene set than in the nonessential gene set, suggesting underrepresentation. The natural logarithm is used.\n\nSecond, a two-sided Fisher's Exact Test is performed on the contingency table to assess the statistical significance of the association between gene type (essential vs. nonessential) and codon type (near-stop vs. non-near-stop). The test calculates a $p$-value, which represents the probability of observing a table at least as extreme as the one constructed, assuming the null hypothesis of no association. A small $p$-value provides evidence against the null hypothesis.\n\nA special condition is mandated for the $p$-value calculation: if any row sum ($a+b$ or $c+d$) or column sum ($a+c$ or $b+d$) of the contingency table is zero, the $p$-value is defined to be $1.0$. This handles cases where one category is entirely absent from the data, making the test trivial.\n\n**Step 4: Declaration of Underrepresentation**\n\nThe final verdict of \"underrepresentation\" is based on two criteria, which must both be met:\n1.  The direction of the effect must indicate underrepresentation in essential genes: $\\mathrm{LOR}_\\alpha < 0$.\n2.  The result must be statistically significant: the $p$-value must be less than a specified significance threshold $\\tau$.\n\nIf both $\\mathrm{LOR}_\\alpha < 0$ and $p < \\tau$ are true, the result is `True`; otherwise, it is `False`. The algorithm computes these values for each test case and formats the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import fisher_exact\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"essential_genes\": [\"AAGGCUAAAGCUUUU\", \"GCCUGGUGGUUCGCA\"],\n            \"nonessential_genes\": [\"CAAGCUUAUGCGUUC\", \"AAAGCCUUGGCAUUU\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUC\", \"GCUGCGUUUUUCGCC\"],\n            \"nonessential_genes\": [\"AAAAAGCAAGAAUUA\", \"UGGUCGUAUUACAGA\"],\n            \"alpha\": 0.5,\n            \"tau\": 0.01\n        },\n        {\n            \"essential_genes\": [\"GCUGCCGCAGCGUUU\", \"UUCGCUGCCGCAGCG\"],\n            \"nonessential_genes\": [\"GCUGCGUUUUUCGCC\", \"GCAGCUUUCUUUGCG\"],\n            \"alpha\": 1.0,\n            \"tau\": 0.05\n        }\n    ]\n\n    results = []\n    \n    # Pre-compute the set of near-stop codons once.\n    near_stop_codons = _get_near_stop_codons()\n\n    for case in test_cases:\n        # Extract parameters for the current test case.\n        essential_genes = case[\"essential_genes\"]\n        nonessential_genes = case[\"nonessential_genes\"]\n        alpha = case[\"alpha\"]\n        tau = case[\"tau\"]\n\n        # Step 1: Count codon types in essential genes.\n        a, b = _count_codon_types(essential_genes, near_stop_codons)\n        \n        # Step 2: Count codon types in nonessential genes.\n        c, d = _count_codon_types(nonessential_genes, near_stop_codons)\n        \n        # Step 3: Compute the smoothed log-odds ratio.\n        # LOR = log((a+alpha)/(b+alpha)) - log((c+alpha)/(d+alpha))\n        term_essential = (a + alpha) / (b + alpha)\n        term_nonessential = (c + alpha) / (d + alpha)\n        lor = np.log(term_essential) - np.log(term_nonessential)\n        \n        # Step 4: Compute the two-sided Fisher's exact test p-value.\n        table = np.array([[a, b], [c, d]])\n        \n        # Check for zero row or column sums as per the problem specification.\n        if (a + b == 0) or (c + d == 0) or (a + c == 0) or (b + d == 0):\n            p_value = 1.0\n        else:\n            _, p_value = fisher_exact(table, alternative='two-sided')\n            \n        # Step 5: Determine if there is underrepresentation.\n        # Condition: LOR < 0 and p-value < significance threshold tau.\n        is_underrepresented = lor < 0 and p_value < tau\n        \n        # Append the formatted result triplet to the list.\n        results.append([lor, p_value, is_underrepresented])\n\n    # Format the final output string as specified.\n    formatted_results = [\n        f\"[{lor:.6f},{p_val:.6f},{str(underrep).lower()}]\" \n        for lor, p_val, underrep in results\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _get_near_stop_codons():\n    \"\"\"\n    Generates the set of \"near-stop\" codons based on the problem definition.\n    A codon is near-stop if its Hamming distance to any stop codon is 1\n    and it is not itself a stop codon.\n    \"\"\"\n    bases = ['A', 'C', 'G', 'U']\n    stop_codons = {'UAA', 'UAG', 'UGA'}\n    \n    all_codons = {b1 + b2 + b3 for b1 in bases for b2 in bases for b3 in bases}\n    sense_codons = all_codons - stop_codons\n    \n    near_stop_set = set()\n    for codon in sense_codons:\n        min_dist = 3  # The maximum possible Hamming distance for length 3 strings.\n        for stop_codon in stop_codons:\n            dist = sum(1 for i in range(3) if codon[i] != stop_codon[i])\n            if dist < min_dist:\n                min_dist = dist\n        \n        if min_dist == 1:\n            near_stop_set.add(codon)\n            \n    return near_stop_set\n\ndef _count_codon_types(gene_sequences, near_stop_set):\n    \"\"\"\n    Parses gene sequences into codons and counts near-stop vs. non-near-stop codons.\n    \n    Args:\n        gene_sequences (list[str]): A list of mRNA sequences.\n        near_stop_set (set[str]): The pre-computed set of near-stop codons.\n\n    Returns:\n        tuple[int, int]: A tuple containing (near_stop_count, non_near_stop_count).\n    \"\"\"\n    near_stop_count = 0\n    non_near_stop_count = 0\n    \n    for seq in gene_sequences:\n        # Parse sequence into non-overlapping codons of length 3.\n        for i in range(0, len(seq), 3):\n            codon = seq[i:i+3]\n            \n            # According to problem, input sequences do not contain stop codons.\n            if codon in near_stop_set:\n                near_stop_count += 1\n            else:\n                non_near_stop_count += 1\n                \n    return near_stop_count, non_near_stop_count\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2380355"}, {"introduction": "Efficient translation is vital for all life, yet cells must balance the cost of producing a diverse set of tRNA molecules with the need to decode all necessary codons. This advanced practice models this biological optimization problem as a formal computer science challenge known as the 'set cover problem'. By determining the minimal number of tRNA species required to translate a genome under various wobble pairing rules, you will apply algorithmic thinking to understand the logic and economy of the cell's translation machinery [@problem_id:2380386].", "problem": "You are given the task of computing the minimal number of transfer ribonucleic acid (tRNA) species, denoted by $N_{\\min}$, required to translate a given ribonucleic acid (RNA) genome under specified non-standard wobble-pairing rules. The Central Dogma of molecular biology states that deoxyribonucleic acid (DNA) is transcribed to RNA, which is translated into protein. Translation decodes RNA codons (triplets over the alphabet $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$) into amino acids via base pairing with tRNA anticodons. Standard Watson–Crick base pairing applies at codon positions $1$ and $2$ (anticodon positions $3$ and $2$), while the wobble position (codon position $3$ and anticodon position $1$) allows expanded pairing governed by modification-dependent rules. Each tRNA species is assumed to be specific to a single amino acid, and is characterized here by its anticodon wobble base at position $1$ only; anticodon positions $2$ and $3$ are assumed to be strict Watson–Crick complements of the codon’s first two positions. Stop codons are not translated and must be ignored.\n\nFundamental base and constraints:\n- Codons are length-$3$ words on $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$. The canonical nuclear genetic code (standard genetic code) maps $64$ codons to $20$ amino acids and $3$ stops (the three stop codons are $\\mathrm{UAA}$, $\\mathrm{UAG}$, and $\\mathrm{UGA}$). Only sense codons (non-stop) require tRNAs.\n- For any fixed amino acid and fixed first-two bases $XY \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}^2$, the set of its synonymous codons in that “family box” is $XY\\{b \\mid b \\in \\mathcal{B}_{aa,XY}\\}$, where $\\mathcal{B}_{aa,XY} \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ depends on the standard genetic code assignment. A tRNA species for that box has anticodon positions $2$ and $3$ complementary to $X$ and $Y$, and its anticodon wobble base determines which third-base letters it can decode in that box. A tRNA cannot serve codons that translate to a different amino acid, even if its anticodon would base-pair, because aminoacylation is amino-acid specific.\n- The wobble pairing rules are provided as a mapping from the anticodon wobble base symbol to the set of codon-third-base letters it decodes. For a given amino acid and $XY$ family box, if the set of third bases observed in the genome for that box is $S \\subseteq \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$, then the minimal number of tRNAs required for that box equals the minimal number of wobble-base types whose decoded-letter sets cover $S$. This is a minimal set cover on a ground set of size at most $4$.\n\nNon-standard wobble rule sets to be used:\n- Rule set $\\mathcal{R}_{\\mathrm{NS1}}$ (mitochondria-like superwobble permitted): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{W}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$.\n- Rule set $\\mathcal{R}_{\\mathrm{NS2}}$ (no inosine; expanded but not superwobble): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$, $\\mathrm{M}\\to\\{\\mathrm{A},\\mathrm{G}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$.\n- Rule set $\\mathcal{R}_{\\mathrm{NS3}}$ (restrictive wobble; suppressed $\\mathrm{G}\\text{-}\\mathrm{U}$ pairing): \n  $\\mathrm{A}\\to\\{\\mathrm{U}\\}$, $\\mathrm{C}\\to\\{\\mathrm{G}\\}$, $\\mathrm{G}\\to\\{\\mathrm{C}\\}$, $\\mathrm{U}\\to\\{\\mathrm{A}\\}$, $\\mathrm{I}\\to\\{\\mathrm{A},\\mathrm{C},\\mathrm{U}\\}$, $\\mathrm{K}\\to\\{\\mathrm{A}\\}$, $\\mathrm{Q}\\to\\{\\mathrm{U},\\mathrm{C}\\}$.\n\nTask:\n- Implement a program that, for each test case, computes $N_{\\min}$ as follows. For each amino acid, partition the codons present in the genome that encode that amino acid by their first two bases $XY$. For each partition, let $S$ be the set of third-base letters actually observed in the genome for that amino acid and $XY$. Using the specified wobble rule set, find the minimal number of anticodon wobble base types whose decoded-letter sets cover $S$. Sum this minimal count over all amino acids and all $XY$ partitions to obtain $N_{\\min}$ for the genome under that rule set. Ignore stop codons entirely. All counts are integers and should be reported as such.\n\nTest suite:\n- Case $1$: Genome $\\mathcal{G}_1$ with codons \n  $\\{\\mathrm{AUG},\\mathrm{GCU},\\mathrm{GCC},\\mathrm{GCA},\\mathrm{GCG},\\mathrm{GGU},\\mathrm{GGC},\\mathrm{GGA},\\mathrm{AUU},\\mathrm{AUC},\\mathrm{AUA},\\mathrm{UUU},\\mathrm{UUC},\\mathrm{CCU},\\mathrm{CCA},\\mathrm{UCU},\\mathrm{UCC},\\mathrm{UCA},\\mathrm{UCG},\\mathrm{AGU},\\mathrm{CUA},\\mathrm{CUG},\\mathrm{UUA},\\mathrm{GUU},\\mathrm{UAU},\\mathrm{UAC},\\mathrm{UAA},\\mathrm{UGA},\\mathrm{UAG}\\}$ evaluated under $\\mathcal{R}_{\\mathrm{NS1}}$.\n- Case $2$: Same genome $\\mathcal{G}_1$ under $\\mathcal{R}_{\\mathrm{NS2}}$.\n- Case $3$: Same genome $\\mathcal{G}_1$ under $\\mathcal{R}_{\\mathrm{NS3}}$.\n- Case $4$: Genome $\\mathcal{G}_2$ with codons consisting of $\\mathrm{UUU}$ repeated $10$ times plus one stop $\\mathrm{UAA}$, evaluated under $\\mathcal{R}_{\\mathrm{NS3}}$.\n- Case $5$: Genome $\\mathcal{G}_{\\mathrm{all}}$ containing each of the $61$ sense codons exactly once (all standard genetic code sense codons), evaluated under $\\mathcal{R}_{\\mathrm{NS3}}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$), where each $\\text{result}_i$ is the integer $N_{\\min}$ for the corresponding case in the order listed above. No user input should be read; all data must be embedded in the program. No physical units or angles are involved. All outputs are integers. The implementation language and environment are specified in the final answer instructions.", "solution": "The problem statement is valid. It is scientifically grounded, well-posed, and objective. It presents a clear computational task based on established principles of molecular biology, specifically the translation of messenger RNA into protein. The problem asks for the calculation of the minimal number of transfer RNA (tRNA) species, $N_{\\min}$, required to translate a given set of RNA codons under specified non-standard wobble pairing rules. This is a well-defined optimization problem that can be decomposed into a series of minimum set cover problems.\n\nThe fundamental principle is that protein synthesis relies on the recognition of three-base codons on an mRNA molecule by the corresponding three-base anticodons of tRNA molecules. Each tRNA is charged with a specific amino acid. While base pairing at the first two codon positions with the third and second anticodon positions, respectively, follows standard Watson-Crick rules ($\\mathrm{A}$-$\\mathrm{U}$, $\\mathrm{G}$-$\\mathrm{C}$), the pairing at the \"wobble\" position (codon position $3$, anticodon position $1$) is more flexible. This flexibility is often governed by chemical modifications to the anticodon's first base. The problem provides three hypothetical sets of such wobble pairing rules, $\\mathcal{R}_{\\mathrm{NS1}}$, $\\mathcal{R}_{\\mathrm{NS2}}$, and $\\mathcal{R}_{\\mathrm{NS3}}$, mapping anticodon wobble bases to the set of codon third bases they can recognize.\n\nThe core constraint is that a single tRNA species, defined by its anticodon and amino acid specificity, cannot service codons that translate to different amino acids. This leads to the central algorithmic step: partitioning the problem. The total tRNA count, $N_{\\min}$, is the sum of the minimum tRNAs required for distinct groups of codons. These groups are defined by a unique pair of (amino acid, codon prefix $XY$), where $XY$ are the first two bases of the codons in that group.\n\nThe solution proceeds as follows:\n\nStep $1$: Data Structuring.\nFirst, we encode the necessary biological and problem-specific data.\n- The standard nuclear genetic code is represented as a mapping from each of the $64$ codons to its corresponding amino acid or a stop signal. For example, $\\mathrm{UUU} \\to \\mathrm{Phenylalanine}$ and $\\mathrm{UAA} \\to \\mathrm{Stop}$.\n- The non-standard wobble pairing rules ($\\mathcal{R}_{\\mathrm{NS1}}$, $\\mathcal{R}_{\\mathrm{NS2}}$, and $\\mathcal{R}_{\\mathrm{NS3}}$) are stored as mappings. Each mapping associates an anticodon wobble base (e.g., `I` for inosine) with the set of codon third bases it can pair with (e.g., $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$).\n- The input genomes for each test case are provided as sets of unique codons. Stop codons ($\\mathrm{UAA}$, $\\mathrm{UAG}$, $\\mathrm{UGA}$) are excluded from any analysis.\n\nStep $2$: Codon Partitioning.\nFor a given genome and rule set, we iterate through all unique, non-stop codons present. Each codon is categorized based on the amino acid it codes for and its first two nucleotides ($XY$). This creates a set of disjoint partitions. For each partition, identified by a key (amino acid, $XY$), we collect the set of all observed third-position bases. For a partition corresponding to (amino acid$_{i}$, $XY_{j}$), let this set of observed third bases be $S_{i,j}$.\n\nFor example, if the genome contains codons $\\mathrm{GCU}$, $\\mathrm{GCC}$, and $\\mathrm{GCA}$, all of which code for Alanine, they all share the prefix $\\mathrm{GC}$. This forms a single partition with key $(\\mathrm{Alanine}, \\mathrm{GC})$ and the set of required third bases is $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$.\n\nStep $3$: Solving the Minimum Set Cover Problem.\nFor each partition $(i, j)$ with its corresponding required third-base set $S_{i,j}$, we must find the minimum number of tRNA wobble bases (from the specified rule set) whose recognized-base sets collectively \"cover\" $S_{i,j}$. This is a classic minimum set cover problem. The universe of elements to be covered is $S_{i,j}$, which is a subset of $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{U}\\}$. The collection of available sets to form the cover is given by the values in the chosen wobble rule map (e.g., for $\\mathcal{R}_{\\mathrm{NS1}}$, the available sets are $\\{\\mathrm{U}\\}, \\{\\mathrm{G}\\}, \\{\\mathrm{C}, \\mathrm{U}\\}, \\dots$).\n\nSince the universe size is at most $4$, this problem can be solved efficiently by exhaustive search. We check if a cover of size $k=1$ exists. If not, we check for a cover of size $k=2$, and so on. The first $k$ for which a cover is found is the minimum size.\nLet $c_{i,j}$ be the minimum number of tRNAs for partition $(i, j)$.\n\nFor instance, to cover the set $S = \\{\\mathrm{U}, \\mathrm{C}, \\mathrm{A}\\}$ for $(\\mathrm{Alanine}, \\mathrm{GC})$ under rule set $\\mathcal{R}_{\\mathrm{NS1}}$, we inspect the available wobble pairings. The anticodon wobble base `I` recognizes $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$. Since $S \\subseteq \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{U}\\}$, a single tRNA with anticodon `I` is sufficient. Thus, the cost for this partition is $c = 1$. If no single tRNA could cover $S$, we would check all pairs of tRNAs, and so on.\n\nStep $4$: Final Calculation.\nThe total minimum number of tRNA species, $N_{\\min}$, is the sum of the minimums calculated for each partition:\n$$ N_{\\min} = \\sum_{i,j} c_{i,j} $$\nThis process is repeated for each of the five test cases specified in the problem, using the appropriate genome and wobble rule set for each. The final output is an ordered list of the integer values of $N_{\\min}$ for each case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Solves the tRNA minimization problem for all test cases.\n    \"\"\"\n\n    # --- Data Definitions ---\n\n    # Standard Nuclear Genetic Code\n    genetic_code = {\n        'UUU': 'F', 'UUC': 'F', 'UUA': 'L', 'UUG': 'L',\n        'UCU': 'S', 'UCC': 'S', 'UCA': 'S', 'UCG': 'S',\n        'UAU': 'Y', 'UAC': 'Y', 'UAA': 'Stop', 'UAG': 'Stop',\n        'UGU': 'C', 'UGC': 'C', 'UGA': 'Stop', 'UGG': 'W',\n\n        'CUU': 'L', 'CUC': 'L', 'CUA': 'L', 'CUG': 'L',\n        'CCU': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAU': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGU': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n\n        'AUU': 'I', 'AUC': 'I', 'AUA': 'I', 'AUG': 'M',\n        'ACU': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAU': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGU': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n\n        'GUU': 'V', 'GUC': 'V', 'GUA': 'V', 'GUG': 'V',\n        'GCU': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAU': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGU': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G'\n    }\n\n    # Non-standard Wobble Rule Sets\n    wobble_rules = {\n        'R_NS1': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'I': frozenset({'A', 'C', 'U'}), 'W': frozenset({'A', 'C', 'G', 'U'}),\n            'K': frozenset({'A'}), 'Q': frozenset({'U', 'C'})\n        },\n        'R_NS2': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C', 'U'}), 'U': frozenset({'A', 'G'}),\n            'Q': frozenset({'U', 'C'}), 'M': frozenset({'A', 'G'}),\n            'K': frozenset({'A'})\n        },\n        'R_NS3': {\n            'A': frozenset({'U'}), 'C': frozenset({'G'}),\n            'G': frozenset({'C'}), 'U': frozenset({'A'}),\n            'I': frozenset({'A', 'C', 'U'}), 'K': frozenset({'A'}),\n            'Q': frozenset({'U', 'C'})\n        }\n    }\n\n    # Test Suite\n    genome_g1 = {\n        \"AUG\", \"GCU\", \"GCC\", \"GCA\", \"GCG\", \"GGU\", \"GGC\", \"GGA\", \"AUU\", \"AUC\", \"AUA\",\n        \"UUU\", \"UUC\", \"CCU\", \"CCA\", \"UCU\", \"UCC\", \"UCA\", \"UCG\", \"AGU\", \"CUA\",\n        \"CUG\", \"UUA\", \"GUU\", \"UAU\", \"UAC\", \"UAA\", \"UGA\", \"UAG\"\n    }\n\n    genome_g2 = {\"UUU\"} # 10 times does not change the set, stop codon UAA is ignored\n\n    all_sense_codons = {codon for codon, aa in genetic_code.items() if aa != 'Stop'}\n\n    test_cases = [\n        (genome_g1, wobble_rules['R_NS1']),\n        (genome_g1, wobble_rules['R_NS2']),\n        (genome_g1, wobble_rules['R_NS3']),\n        (genome_g2, wobble_rules['R_NS3']),\n        (all_sense_codons, wobble_rules['R_NS3']),\n    ]\n\n    # --- Helper Functions ---\n    def solve_min_set_cover(target_set, covering_sets):\n        \"\"\"\n        Solves the minimum set cover problem for a small universe.\n        The target_set must be covered by the union of sets from covering_sets.\n        \"\"\"\n        if not target_set:\n            return 0\n        \n        # Check covers of increasing size\n        for k in range(1, len(covering_sets) + 1):\n            for combo in combinations(covering_sets, k):\n                # An arbitrary iterable of a collection of sets can be passed to union()\n                union_of_combo = frozenset.union(*combo)\n                if target_set.issubset(union_of_combo):\n                    return k\n        # This part should be unreachable if all bases can be covered.\n        # Fallback in case of an un-coverable base, though problem setup prevents this.\n        return len(target_set)\n\n    def compute_n_min(genome_codons, rules):\n        \"\"\"\n        Computes N_min for a given genome and rule set.\n        \"\"\"\n        codons_by_group = {}\n        for codon in genome_codons:\n            aa = genetic_code.get(codon)\n            if aa and aa != 'Stop':\n                prefix = codon[:2]\n                third_base = codon[2]\n                key = (aa, prefix)\n                if key not in codons_by_group:\n                    codons_by_group[key] = set()\n                codons_by_group[key].add(third_base)\n\n        total_trna_count = 0\n        available_covers = list(rules.values())\n        \n        for group_key, third_bases_needed in codons_by_group.items():\n            min_cover_size = solve_min_set_cover(frozenset(third_bases_needed), available_covers)\n            total_trna_count += min_cover_size\n            \n        return total_trna_count\n\n    # --- Main Logic ---\n    results = []\n    for genome, rules in test_cases:\n        result = compute_n_min(genome, rules)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2380386"}]}