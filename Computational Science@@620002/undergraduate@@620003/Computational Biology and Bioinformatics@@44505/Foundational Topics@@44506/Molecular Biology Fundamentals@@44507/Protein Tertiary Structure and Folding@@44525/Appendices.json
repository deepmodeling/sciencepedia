{"hands_on_practices": [{"introduction": "One of the key principles governing protein folding is the formation of a dense hydrophobic core, which minimizes the unfavorable interaction of nonpolar side chains with water. This exercise provides a quantitative way to explore this principle by calculating the packing density of a hypothetical protein core. By comparing the calculated density to the theoretical maximum for closely packed spheres ([@problem_id:2422553]), you will develop a tangible understanding of how efficiently nature packs these complex molecular shapes to achieve a stable tertiary structure.", "problem": "A globular protein’s hydrophobic core is approximated as a sphere of radius $12~\\text{\\AA}$. The core contains the following buried side chains, whose van der Waals volumes (assumed additive for this model) are given in cubic ångströms ($\\text{\\AA}^3$):\n\n- Phenylalanine (Phe): $3$ residues, each with volume $189$\n- Leucine (Leu): $6$ residues, each with volume $166$\n- Isoleucine (Ile): $3$ residues, each with volume $166$\n- Valine (Val): $5$ residues, each with volume $140$\n- Methionine (Met): $2$ residues, each with volume $166$\n- Tyrosine (Tyr): $1$ residue, volume $193$\n- Tryptophan (Trp): $1$ residue, volume $227$\n- Alanine (Ala): $4$ residues, each with volume $88$\n- Threonine (Thr): $2$ residues, each with volume $116$\n- Cysteine (Cys): $2$ residues, each with volume $108$\n- Proline (Pro): $2$ residues, each with volume $112$\n\nUnder this simplified model, the side-chain packing density of the core is defined as the fraction of the core’s volume occupied by the buried side chains. The theoretical maximum packing density for uniform spheres (Kepler close packing) is $0.74048$.\n\nCompute the ratio of the core’s side-chain packing density to $0.74048$. Express your final answer as a dimensionless decimal number rounded to four significant figures. Do not include units in your final answer.", "solution": "The problem statement is subjected to validation and is found to be scientifically grounded, well-posed, and objective. It is based on a standard, albeit simplified, model used in structural bioinformatics for analyzing protein packing. All necessary data are provided, and the definitions are unambiguous. The problem is valid and a solution will be provided.\n\nThe primary task is to compute the ratio of the calculated side-chain packing density, $\\rho_{\\text{packing}}$, to the theoretical maximum packing density for uniform spheres, $\\rho_{\\text{max}}$. The packing density is defined as the fraction of the core's volume occupied by the constituent side chains.\n\nFirst, we must calculate the total van der Waals volume of all the buried side chains, denoted as $V_{\\text{sc}}$. This is the sum of the volumes of each individual side chain. The problem provides the counts and volumes for each residue type.\n\nThe sum is calculated as follows:\n$V_{\\text{sc}} = (3 \\times 189) + (6 \\times 166) + (3 \\times 166) + (5 \\times 140) + (2 \\times 166) + (1 \\times 193) + (1 \\times 227) + (4 \\times 88) + (2 \\times 116) + (2 \\times 108) + (2 \\times 112)~\\text{\\AA}^3$.\n\nPerforming the multiplication for each term:\n$V_{\\text{Phe}} = 3 \\times 189 = 567~\\text{\\AA}^3$\n$V_{\\text{Leu}} = 6 \\times 166 = 996~\\text{\\AA}^3$\n$V_{\\text{Ile}} = 3 \\times 166 = 498~\\text{\\AA}^3$\n$V_{\\text{Val}} = 5 \\times 140 = 700~\\text{\\AA}^3$\n$V_{\\text{Met}} = 2 \\times 166 = 332~\\text{\\AA}^3$\n$V_{\\text{Tyr}} = 1 \\times 193 = 193~\\text{\\AA}^3$\n$V_{\\text{Trp}} = 1 \\times 227 = 227~\\text{\\AA}^3$\n$V_{\\text{Ala}} = 4 \\times 88 = 352~\\text{\\AA}^3$\n$V_{\\text{Thr}} = 2 \\times 116 = 232~\\text{\\AA}^3$\n$V_{\\text{Cys}} = 2 \\times 108 = 216~\\text{\\AA}^3$\n$V_{\\text{Pro}} = 2 \\times 112 = 224~\\text{\\AA}^3$\n\nSumming these values gives the total side-chain volume:\n$$V_{\\text{sc}} = 567 + 996 + 498 + 700 + 332 + 193 + 227 + 352 + 232 + 216 + 224 = 4537~\\text{\\AA}^3$$\n\nNext, we calculate the volume of the hydrophobic core, $V_{\\text{core}}$, which is approximated as a sphere with radius $R = 12~\\text{\\AA}$. The volume of a sphere is given by the formula:\n$$V_{\\text{core}} = \\frac{4}{3}\\pi R^3$$\nSubstituting the given radius:\n$$V_{\\text{core}} = \\frac{4}{3}\\pi (12~\\text{\\AA})^3 = \\frac{4}{3}\\pi (1728)~\\text{\\AA}^3 = 2304\\pi~\\text{\\AA}^3$$\n\nThe side-chain packing density, $\\rho_{\\text{packing}}$, is the ratio of the total side-chain volume to the core volume:\n$$\\rho_{\\text{packing}} = \\frac{V_{\\text{sc}}}{V_{\\text{core}}} = \\frac{4537}{2304\\pi}$$\n\nThe problem requires computing the ratio of this packing density to the theoretical maximum packing density, $\\rho_{\\text{max}} = 0.74048$. Let this required ratio be $\\mathcal{R}$.\n$$\\mathcal{R} = \\frac{\\rho_{\\text{packing}}}{\\rho_{\\text{max}}} = \\frac{\\frac{4537}{2304\\pi}}{0.74048} = \\frac{4537}{2304 \\times 0.74048 \\times \\pi}$$\n\nNow, we perform the numerical evaluation:\n$$V_{\\text{core}} = 2304\\pi \\approx 2304 \\times 3.14159265 \\approx 7238.229~\\text{\\AA}^3$$\n$$\\rho_{\\text{packing}} = \\frac{4537}{7238.229} \\approx 0.626815$$\n$$\\mathcal{R} = \\frac{0.626815}{0.74048} \\approx 0.846490$$\n\nThe problem requires the answer to be rounded to four significant figures. The fifth significant figure is $9$, which is greater than or equal to $5$, so we round up the fourth digit.\n$$\\mathcal{R} \\approx 0.8465$$\nThis dimensionless value represents the packing efficiency of the protein core relative to the ideal close-packing of uniform spheres.", "answer": "$$\\boxed{0.8465}$$", "id": "2422553"}, {"introduction": "While analyzing static structures is insightful, understanding the *process* of folding requires dynamic models. The Hydrophobic-Polar (HP) lattice model is a classic simplification that captures the dominant role of hydrophobicity in driving protein collapse. This hands-on coding challenge ([@problem_id:2422555]) guides you through implementing this model from first principles, including the logic for conformational changes (pivot moves) and a stochastic Monte Carlo search algorithm to find low-energy states. This is a fundamental exercise in computational biophysics that builds core skills in algorithm design and simulation.", "problem": "You are to implement a complete, runnable program that models protein folding on a two-dimensional square lattice under the Hydrophobic–Polar (HP) model and evaluates two folding strategies on the same initial conformation of a given amino acid sequence: a deterministic manual sequence of pivot moves and a stochastic dynamics defined as a discrete-time Markov chain. All computations must be grounded in first principles of the HP-lattice model, and all mathematical symbols, variables, operators, and numbers must be written using LaTeX.\n\nA protein of length $N$ with residues indexed $0,1,\\dots,N-1$ is represented by a sequence $S$ over the alphabet $\\{\\mathrm{H},\\mathrm{P}\\}$, where $\\mathrm{H}$ denotes hydrophobic and $\\mathrm{P}$ denotes polar. A conformation of $S$ is a mapping of indices to coordinates $\\mathbf{r}_i \\in \\mathbb{Z}^2$ such that for all $i \\in \\{0,\\dots,N-2\\}$, the Manhattan distance between consecutive residues is unity, that is $\\|\\mathbf{r}_{i+1}-\\mathbf{r}_i\\|_1=1$, and $\\mathbf{r}_i \\neq \\mathbf{r}_j$ for all $i \\neq j$ (self-avoiding walk). For all test cases, the initial conformation is the straight line along the $x$-axis:\n$$\n\\mathbf{r}_i^{(0)} = (i,0) \\quad \\text{for } i \\in \\{0,1,\\dots,N-1\\}.\n$$\n\nThe HP energy $E$ of a conformation $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ for sequence $S$ is defined as\n$$\nE = -\\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ |i-j| > 1}} \\left[ S_i=\\mathrm{H} \\wedge S_j=\\mathrm{H} \\wedge \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = 1 \\right],\n$$\nwhere $[\\cdot]$ denotes the indicator that evaluates to $1$ if the condition is true and $0$ otherwise. Each non-consecutive hydrophobic–hydrophobic contact contributes $-1$ to $E$. The energy is dimensionless.\n\nAn elementary pivot move is parameterized by an index $k \\in \\{1,2,\\dots,N-2\\}$ and a rotation angle $a \\in \\{+90,-90,180\\}$ (angles in degrees). The move acts by rotating, about the fixed pivot position $\\mathbf{r}_k$, the suffix coordinates $\\{\\mathbf{r}_{k+1},\\dots,\\mathbf{r}_{N-1}\\}$ by the specified angle in the plane. If the resulting configuration violates self-avoidance, the move is invalid and has no effect (the conformation remains unchanged). Otherwise, the move is valid and updates the conformation. All rotations must be exact lattice rotations:\n- For $a=+90$, apply the counterclockwise rotation matrix $\\begin{pmatrix}0 & -1 \\\\ 1 & 0\\end{pmatrix}$.\n- For $a=-90$, apply the clockwise rotation matrix $\\begin{pmatrix}0 & 1 \\\\ -1 & 0\\end{pmatrix}$.\n- For $a=180$, apply the rotation matrix $\\begin{pmatrix}-1 & 0 \\\\ 0 & -1\\end{pmatrix}$.\n\nTwo folding strategies must be evaluated for each test case:\n\n1. Manual guidance: Given an ordered list of pivot moves $\\{(k_m,a_m)\\}_{m=1}^M$ with each $k_m \\in \\{1,\\dots,N-2\\}$ and $a_m \\in \\{+90,-90,180\\}$ (angles in degrees), apply them sequentially to the initial conformation. Any invalid move leaves the conformation unchanged for that step. After all moves have been attempted, compute the energy $E_{\\mathrm{manual}}$ of the resulting conformation.\n\n2. Automated stochastic dynamics: Starting from the initial conformation, consider a discrete-time Markov chain with the following transition at each step $t=1,2,\\dots,T_{\\max}$:\n   - Draw $k$ uniformly from $\\{1,2,\\dots,N-2\\}$ and $a$ uniformly from $\\{+90,-90,180\\}$ (angles in degrees). Propose the corresponding pivot move.\n   - If the proposed move is invalid, the conformation remains unchanged at step $t$.\n   - If the move is valid, compute $\\Delta E = E_{\\text{proposed}} - E_{\\text{current}}$ and accept the move with probability $p_{\\text{acc}} = \\min\\{1, \\exp(-\\Delta E / T)\\}$, where $T$ is the temperature and the Boltzmann constant is set to unity so that $T$ is dimensionless. If accepted, update the conformation to the proposed one; otherwise, retain the current conformation.\n   - Let $E_{\\mathrm{best}}$ denote the lowest energy observed up to and including step $t$ (including the initial conformation at step $0$).\nThe stochastic process must be initialized with a specified integer pseudorandom seed for reproducibility. The output of this strategy is $E_{\\mathrm{auto}} = E_{\\mathrm{best}}$ after $T_{\\max}$ steps.\n\nYour program must implement the above definitions exactly and produce results for the following test suite. In all cases, angles are in degrees, energies are dimensionless integers, and indices are zero-based with pivot indices constrained to $k \\in \\{1,2,\\dots,N-2\\}$.\n\nTest suite:\n- Case A:\n  - Sequence $S = \\text{\"HHHH\"}$ with length $N=4$.\n  - Manual moves: $\\big[(1,+90),(2,+90)\\big]$.\n  - Temperature $T = 1$.\n  - Stochastic steps $T_{\\max} = 0$.\n  - Seed $= 1$.\n- Case B:\n  - Sequence $S = \\text{\"HPHPHPHP\"}$ with length $N=8$.\n  - Manual moves: empty list $\\big[\\ \\big]$.\n  - Temperature $T = 1$.\n  - Stochastic steps $T_{\\max} = 0$.\n  - Seed $= 2$.\n- Case C:\n  - Sequence $S = \\text{\"HHHHHH\"}$ with length $N=6$.\n  - Manual moves: $\\big[(1,+90),(2,+90),(4,-90)\\big]$.\n  - Temperature $T = 1$.\n  - Stochastic steps $T_{\\max} = 0$.\n  - Seed $= 3$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a two-element list $[E_{\\mathrm{manual}}, E_{\\mathrm{auto}}]$. For example, an output with three test cases should look like\n$$\n\\big[ [e_1^{\\mathrm{man}}, e_1^{\\mathrm{auto}}], [e_2^{\\mathrm{man}}, e_2^{\\mathrm{auto}}], [e_3^{\\mathrm{man}}, e_3^{\\mathrm{auto}}] \\big].\n$$", "solution": "The problem statement is valid. It is scientifically grounded in the well-established Hydrophobic-Polar (HP) lattice model, a cornerstone of simplified protein folding studies. The problem is well-posed, providing all necessary definitions, initial conditions, and parameters to derive a unique solution. The language is objective and mathematically precise. I will now proceed with a complete solution.\n\nThe solution requires the implementation of a simulation of protein folding on a two-dimensional square lattice, governed by the HP model. A protein is abstracted as a sequence $S$ of length $N$ over the alphabet $\\{\\mathrm{H}, \\mathrm{P}\\}$, representing hydrophobic and polar residues, respectively. The conformation of this chain is a self-avoiding walk on the integer grid $\\mathbb{Z}^2$, represented by a series of coordinates $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$ where $\\mathbf{r}_i = (x_i, y_i)$. For all test cases, the chain starts in a fully extended linear conformation along the x-axis, i.e., $\\mathbf{r}_i^{(0)} = (i,0)$.\n\nThe core of the HP model is its energy function, which posits that the hydrophobic effect is the dominant force in protein folding. The energy $E$ of a given conformation is calculated by counting the number of topological contacts between non-adjacent hydrophobic residues. A contact is formed if two such residues occupy adjacent lattice sites. The energy is given by:\n$$\nE = -\\sum_{\\substack{0 \\le i < j \\le N-1 \\\\ |i-j| > 1}} \\left[ S_i=\\mathrm{H} \\wedge S_j=\\mathrm{H} \\wedge \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = 1 \\right]\n$$\nwhere $[\\cdot]$ is the Iverson bracket. Each such H-H contact contributes $-1$ to the total energy, so conformations with lower (more negative) energy are more stable. To implement this, we identify all indices corresponding to $\\mathrm{H}$ residues. We then iterate through all pairs of these indices $(i, j)$ such that $j > i+1$ and compute the Manhattan distance $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_1 = |x_i - x_j| + |y_i - y_j|$. If the distance is $1$, we decrement the energy counter. The initial linear conformation has an energy of $E=0$ as no non-adjacent residues are in contact.\n\nConformational changes are modeled by pivot moves. A pivot move is defined by an index $k \\in \\{1, 2, \\dots, N-2\\}$ and a rotation angle $a \\in \\{+90, -90, 180\\}$ degrees. The residue at $\\mathbf{r}_k$ acts as a pivot, and the subchain from residue $k+1$ to $N-1$ is rotated rigidly around it. The coordinates of the prefix, $\\{\\mathbf{r}_0, \\dots, \\mathbf{r}_k\\}$, remain fixed. For each point $\\mathbf{r}_i$ in the suffix ($i > k$), its new position $\\mathbf{r}'_i$ is found by rotating the vector $\\mathbf{v}_i = \\mathbf{r}_i - \\mathbf{r}_k$ about the origin and adding it back to the pivot coordinate: $\\mathbf{r}'_i = \\mathbf{r}_k + R_a \\mathbf{v}_i$. The rotation matrices $R_a$ for the plane are:\n$$\nR_{+90} = \\begin{pmatrix}0 & -1 \\\\ 1 & 0\\end{pmatrix}, \\quad R_{-90} = \\begin{pmatrix}0 & 1 \\\\ -1 & 0\\end{pmatrix}, \\quad R_{180} = \\begin{pmatrix}-1 & 0 \\\\ 0 & -1\\end{pmatrix}\n$$\nA move is valid only if the resulting conformation is self-avoiding, meaning all coordinates $\\mathbf{r}'_i$ are unique. This is verified by checking if the set of coordinate tuples has size $N$. If a move is invalid, the conformation does not change.\n\nTwo strategies for folding are evaluated:\n\n1.  **Manual Guidance:** A predetermined sequence of pivot moves is applied serially. Starting from the initial linear conformation, each move $(k_m, a_m)$ is attempted. If valid, the conformation is updated. If invalid, it is discarded, and the next move is attempted on the unchanged conformation. After all moves are processed, the final energy $E_{\\mathrm{manual}}$ is computed.\n\n2.  **Automated Stochastic Dynamics:** This strategy employs a Metropolis-Hastings Monte Carlo simulation, a discrete-time Markov chain process, to explore the conformational space. Starting from the initial conformation, the simulation proceeds for $T_{\\max}$ steps. At each step $t$:\n    - A random pivot move is proposed by selecting $k$ uniformly from $\\{1, \\dots, N-2\\}$ and $a$ uniformly from $\\{+90, -90, 180\\}$.\n    - The validity of the move is checked. If invalid, the conformation remains unchanged for this step.\n    - If the move is valid, a new conformation is proposed. The change in energy, $\\Delta E = E_{\\text{proposed}} - E_{\\text{current}}$, is calculated.\n    - The proposed move is accepted with probability $p_{\\text{acc}} = \\min\\{1, \\exp(-\\Delta E / T)\\}$, where $T$ is a dimensionless temperature parameter. Moves that lower the energy ($\\Delta E < 0$) are always accepted. Moves that increase the energy are accepted with a probability that decreases exponentially with the energy increase, allowing the system to escape local minima. If a move is rejected, the conformation remains unchanged.\n    - Throughout the simulation, the lowest energy encountered, $E_{\\mathrm{best}}$, is tracked. The process is initialized with the energy of the starting conformation. The final output for this strategy is $E_{\\mathrm{auto}} = E_{\\mathrm{best}}$ after $T_{\\max}$ steps. For the given test cases, $T_{\\max}=0$, meaning no stochastic steps are performed. Therefore, $E_{\\mathrm{auto}}$ will simply be the energy of the initial linear conformation.\n\nThe implementation will utilize `numpy` arrays for efficient handling of coordinate vectors and matrix operations. The overall logic is encapsulated in a main function that processes each test case, calls the appropriate functions for manual and automated strategies, and formats the output as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_energy(coords, sequence):\n    \"\"\"\n    Calculates the HP energy of a given conformation.\n    Energy E = -1 for each non-adjacent H-H contact.\n    \"\"\"\n    n = len(sequence)\n    energy = 0\n    h_indices = [i for i, res in enumerate(sequence) if res == 'H']\n\n    if len(h_indices) < 2:\n        return 0\n\n    for i_idx in range(len(h_indices)):\n        for j_idx in range(i_idx + 1, len(h_indices)):\n            i = h_indices[i_idx]\n            j = h_indices[j_idx]\n\n            # Condition for non-adjacent residues\n            if abs(i - j) > 1:\n                # Manhattan distance\n                dist = np.sum(np.abs(coords[i] - coords[j]))\n                if dist == 1:\n                    energy -= 1\n    return energy\n\n\ndef get_proposed_coords(coords, n, k, angle):\n    \"\"\"\n    Generates a new conformation by applying a pivot move.\n    Returns the new coordinate array if the move is valid (self-avoiding),\n    otherwise returns None.\n    \"\"\"\n    # Pivot index k must be in {1, ..., N-2}\n    if not (1 <= k < n - 1):\n        return None\n\n    if angle == 90:\n        rot_matrix = np.array([[0, -1], [1, 0]], dtype=int)\n    elif angle == -90:\n        rot_matrix = np.array([[0, 1], [-1, 0]], dtype=int)\n    elif angle == 180:\n        rot_matrix = np.array([[-1, 0], [0, -1]], dtype=int)\n    else:\n        # Invalid angle\n        return None\n\n    new_coords = coords.copy()\n    pivot_coord = coords[k]\n    \n    # Suffix coordinates relative to the pivot\n    suffix_relative = coords[k+1:] - pivot_coord\n    \n    # Rotate the suffix vectors\n    rotated_suffix_relative = (rot_matrix @ suffix_relative.T).T\n    \n    # New absolute coordinates for the suffix\n    new_suffix_absolute = rotated_suffix_relative + pivot_coord\n    \n    new_coords[k+1:] = new_suffix_absolute\n    \n    # Check for self-avoidance. Using a set is efficient.\n    # The number of unique coordinates must be equal to the chain length.\n    if len(set(map(tuple, new_coords))) == n:\n        return new_coords\n    else:\n        return None\n\n\ndef solve():\n    \"\"\"\n    Main function to run the folding simulations for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"S\": \"HHHH\",\n            \"manual_moves\": [(1, 90), (2, 90)],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 1\n        },\n        {\n            \"S\": \"HPHPHPHP\",\n            \"manual_moves\": [],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 2\n        },\n        {\n            \"S\": \"HHHHHH\",\n            \"manual_moves\": [(1, 90), (2, 90), (4, -90)],\n            \"T\": 1.0, \"T_max\": 0, \"seed\": 3\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        sequence = case[\"S\"]\n        manual_moves = case[\"manual_moves\"]\n        T = case[\"T\"]\n        T_max = case[\"T_max\"]\n        seed = case[\"seed\"]\n\n        n = len(sequence)\n        \n        # --- Strategy 1: Manual Guidance ---\n        manual_coords = np.array([[i, 0] for i in range(n)], dtype=int)\n        \n        for k, angle in manual_moves:\n            proposed = get_proposed_coords(manual_coords, n, k, angle)\n            if proposed is not None:\n                manual_coords = proposed\n        \n        e_manual = calculate_energy(manual_coords, sequence)\n\n        # --- Strategy 2: Automated Stochastic Dynamics ---\n        rng = np.random.default_rng(seed)\n        \n        # Start with the initial linear conformation\n        current_coords = np.array([[i, 0] for i in range(n)], dtype=int)\n        current_energy = calculate_energy(current_coords, sequence)\n        best_energy = current_energy\n\n        # Perform T_max steps of Monte Carlo simulation\n        if T_max > 0 and n >= 3:\n            possible_k = list(range(1, n - 1))\n            possible_angles = [90, -90, 180]\n\n            for _ in range(T_max):\n                k_rand = rng.choice(possible_k)\n                angle_rand = rng.choice(possible_angles)\n                \n                proposed = get_proposed_coords(current_coords, n, k_rand, angle_rand)\n                \n                if proposed is not None:\n                    # Move is valid, evaluate for acceptance\n                    proposed_energy = calculate_energy(proposed, sequence)\n                    delta_E = proposed_energy - current_energy\n                    \n                    if delta_E < 0 or rng.random() < np.exp(-delta_E / T):\n                        # Accept the move\n                        current_coords = proposed\n                        current_energy = proposed_energy\n                \n                # If move is invalid, conformation and energy remain unchanged.\n                best_energy = min(best_energy, current_energy)\n\n        e_auto = best_energy\n        \n        results.append([e_manual, e_auto])\n\n    # Final print statement in the exact required format\n    output_str = \",\".join([f\"[{r[0]},{r[1]}]\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2422555"}, {"introduction": "Moving from simplified models to real-world data, we often find that a protein's environment is as important as the chain itself. Water molecules are not always a passive solvent; some become integral, \"structural\" components that stabilize the folded state. This practical data analysis problem ([@problem_id:2422534]) simulates the task of sifting through molecular dynamics trajectory data to identify these key water molecules based on their positional stability and proximity to the protein. This exercise bridges the gap between abstract models and the practical analysis of complex simulation output, a common task in modern structural bioinformatics.", "problem": "You are given a simplified abstraction of a Molecular Dynamics (MD) simulation of a protein with water molecules, suitable for analyzing water molecules that are potentially \"structural\" in the sense of stabilizing the protein’s tertiary structure. The system represents a single protein with fixed heavy atom positions taken from a Protein Data Bank (PDB) structure and a set of water oxygen positions observed across a short MD trajectory. Protein atomic coordinates and water positions are given in angstroms (Å). Your task is to write a complete program that, using first-principles definitions of positional variance and proximity, classifies water molecules as structural or non-structural.\n\nDefinitions:\n- Let there be $T$ frames, indexed by $t\\in\\{1,\\dots,T\\}$, and $N$ water molecules indexed by $i\\in\\{0,\\dots,N-1\\}$. The protein’s heavy atom coordinates are $\\{\\mathbf{R}_j\\in\\mathbb{R}^3\\}_{j=1}^{M}$.\n- For water $i$, let $\\mathbf{r}_{i,t}\\in\\mathbb{R}^3$ denote its oxygen position in frame $t$. If water $i$ is not present in frame $t$, then $\\mathbf{r}_{i,t}$ is considered missing and excluded from any averages or sums over $t$. Missing frames count as not observed for occupancy but still count toward the denominator $T$ for occupancy fraction.\n- For each water $i$, define the set of observed frames $S_i=\\{t\\in\\{1,\\dots,T\\}:\\mathbf{r}_{i,t}\\text{ is observed}\\}$ and let $n_i=|S_i|$. The occupancy fraction is $f_{\\mathrm{occ}}(i)=n_i/T$.\n- The time-averaged position over observed frames is $\\boldsymbol{\\mu}_i=\\frac{1}{n_i}\\sum_{t\\in S_i}\\mathbf{r}_{i,t}$, and the positional variance is $\\sigma_i^2=\\frac{1}{n_i}\\sum_{t\\in S_i}\\|\\mathbf{r}_{i,t}-\\boldsymbol{\\mu}_i\\|_2^2$.\n- For proximity to the protein, define the per-frame minimum heavy-atom distance $d_{i,t}=\\min_{1\\le j\\le M}\\|\\mathbf{r}_{i,t}-\\mathbf{R}_j\\|_2$. Given a distance cutoff $d_{\\max}>0$, define the binding-contact fraction $f_{\\mathrm{bind}}(i)=\\frac{1}{n_i}\\sum_{t\\in S_i}\\mathbf{1}\\big[d_{i,t}\\le d_{\\max}\\big]$, where $\\mathbf{1}[\\cdot]$ is the indicator function that equals $1$ when the condition is true and $0$ otherwise.\n- A water molecule $i$ is classified as structural if and only if all of the following hold simultaneously: $f_{\\mathrm{occ}}(i)\\ge f_{\\min}$, $\\sigma_i^2\\le \\sigma^2_{\\max}$, and $f_{\\mathrm{bind}}(i)\\ge f_{\\mathrm{bind}}^{\\min}$.\n\nDataset (fixed for all test cases):\n- Number of frames: $T=6$.\n- Number of protein heavy atoms: $M=3$, with coordinates (in Å):\n  - $\\mathbf{R}_1=\\left(0.0,0.0,0.0\\right)$,\n  - $\\mathbf{R}_2=\\left(3.0,0.0,0.0\\right)$,\n  - $\\mathbf{R}_3=\\left(0.0,3.0,0.0\\right)$.\n- Number of waters: $N=5$. For each water $i\\in\\{0,1,2,3,4\\}$ and frame $t\\in\\{1,\\dots,6\\}$, the oxygen positions (in Å) are as follows. Frames not listed for a given water are to be treated as missing observations for that water.\n  - Water $i=0$ (all frames observed): mean near $\\left(1.0,0.0,0.0\\right)$ with small symmetric deviations:\n    - $t=1$: $\\left(1.05,0.0,0.0\\right)$,\n    - $t=2$: $\\left(0.95,0.0,0.0\\right)$,\n    - $t=3$: $\\left(1.0,0.05,0.0\\right)$,\n    - $t=4$: $\\left(1.0,-0.05,0.0\\right)$,\n    - $t=5$: $\\left(1.0,0.0,0.05\\right)$,\n    - $t=6$: $\\left(1.0,0.0,-0.05\\right)$.\n  - Water $i=1$ (all frames observed): mobile solvent, far from protein:\n    - $t=1$: $\\left(5.0,5.0,5.0\\right)$,\n    - $t=2$: $\\left(6.0,5.0,5.0\\right)$,\n    - $t=3$: $\\left(5.0,6.0,5.0\\right)$,\n    - $t=4$: $\\left(7.0,5.0,5.0\\right)$,\n    - $t=5$: $\\left(5.0,7.0,6.0\\right)$,\n    - $t=6$: $\\left(4.0,4.0,4.0\\right)$.\n  - Water $i=2$ (intermittent; only first three frames observed, the rest missing):\n    - $t=1$: $\\left(1.22,0.0,0.0\\right)$,\n    - $t=2$: $\\left(1.18,0.0,0.0\\right)$,\n    - $t=3$: $\\left(1.20,0.02,0.0\\right)$.\n  - Water $i=3$ (all frames observed): mean near $\\left(1.0,1.8,0.0\\right)$ with symmetric deviations of magnitude $0.1$ Å along axes:\n    - $t=1$: $\\left(1.1,1.8,0.0\\right)$,\n    - $t=2$: $\\left(0.9,1.8,0.0\\right)$,\n    - $t=3$: $\\left(1.0,1.9,0.0\\right)$,\n    - $t=4$: $\\left(1.0,1.7,0.0\\right)$,\n    - $t=5$: $\\left(1.0,1.8,0.1\\right)$,\n    - $t=6$: $\\left(1.0,1.8,-0.1\\right)$.\n  - Water $i=4$ (all frames observed): far from protein with low variance:\n    - $t=1$: $\\left(10.02,10.0,10.0\\right)$,\n    - $t=2$: $\\left(9.98,10.0,10.0\\right)$,\n    - $t=3$: $\\left(10.0,10.02,10.0\\right)$,\n    - $t=4$: $\\left(10.0,9.98,10.0\\right)$,\n    - $t=5$: $\\left(10.0,10.0,10.02\\right)$,\n    - $t=6$: $\\left(10.0,10.0,9.98\\right)$.\n\nTest suite of parameter sets:\n- Case A (baseline thresholds):\n  - Variance threshold: $\\sigma^2_{\\max}=0.005$ $\\left(\\text{\\AA}^2\\right)$,\n  - Minimum occupancy fraction: $f_{\\min}=0.8$,\n  - Proximity distance cutoff: $d_{\\max}=3.5$ $\\left(\\text{\\AA}\\right)$,\n  - Minimum binding-contact fraction: $f_{\\mathrm{bind}}^{\\min}=0.8$.\n- Case B (variance boundary inclusive):\n  - $\\sigma^2_{\\max}=0.01$ $\\left(\\text{\\AA}^2\\right)$,\n  - $f_{\\min}=0.8$,\n  - $d_{\\max}=3.5$ $\\left(\\text{\\AA}\\right)$,\n  - $f_{\\mathrm{bind}}^{\\min}=0.8$.\n- Case C (occupancy boundary inclusive):\n  - $\\sigma^2_{\\max}=0.005$ $\\left(\\text{\\AA}^2\\right)$,\n  - $f_{\\min}=0.5$,\n  - $d_{\\max}=3.5$ $\\left(\\text{\\AA}\\right)$,\n  - $f_{\\mathrm{bind}}^{\\min}=0.8$.\n- Case D (strict proximity, likely empty set):\n  - $\\sigma^2_{\\max}=1.0$ $\\left(\\text{\\AA}^2\\right)$,\n  - $f_{\\min}=0.8$,\n  - $d_{\\max}=1.0$ $\\left(\\text{\\AA}\\right)$,\n  - $f_{\\mathrm{bind}}^{\\min}=0.5$.\n\nComputational requirements:\n- Implement the definitions above exactly, using Euclidean norms for distances and ignoring missing frames for means, variances, and proximity fractions (but counting them as not observed for occupancy fraction).\n- Equality at thresholds must be inclusive: use $\\ge$ for $f_{\\mathrm{occ}}$ and $f_{\\mathrm{bind}}$, and $\\le$ for $\\sigma^2$.\n- For each of the four parameter cases, output the list of water indices that are classified as structural, sorted in ascending order.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, where each case’s result is itself a list of water indices. For example, an output could look like $\\left[\\left[0\\right],\\left[0,3\\right],\\left[0,2\\right],\\left[\\right]\\right]$ (this is only an example of formatting, not necessarily the correct answer). No additional text should be printed.", "solution": "The problem presented is a well-defined computational task in structural bioinformatics. It requires the classification of water molecules as \"structural\" based on three quantitative metrics derived from a simplified molecular dynamics trajectory: occupancy, positional variance, and proximity to a protein. All data, definitions, and thresholds are provided unambiguously. The problem is scientifically grounded, logically consistent, and computationally tractable. Therefore, a rigorous solution can be derived by a direct application of the given formulae.\n\nThe methodology is as follows. For each of the $N=5$ water molecules, we first compute its intrinsic properties based on its observed positions over the $T=6$ trajectory frames. These properties are the occupancy fraction $f_{\\mathrm{occ}}(i)$, the time-averaged position $\\boldsymbol{\\mu}_i$, and the positional variance $\\sigma_i^2$. Subsequently, for the different proximity cutoffs $d_{\\max}$ specified in the test cases, we calculate the corresponding binding-contact fraction $f_{\\mathrm{bind}}(i)$. With these quantities computed, we then evaluate each water molecule against the criteria of each test case to determine its classification.\n\nThe protein is represented by $M=3$ heavy atoms with coordinates:\n- $\\mathbf{R}_1 = \\left(0.0, 0.0, 0.0\\right)$\n- $\\mathbf{R}_2 = \\left(3.0, 0.0, 0.0\\right)$\n- $\\mathbf{R}_3 = \\left(0.0, 3.0, 0.0\\right)$\n\nLet us systematically compute the necessary statistics for each water molecule $i \\in \\{0, 1, 2, 3, 4\\}$.\n\n**Water Molecule $i=0$**\n- Observed frames: $S_0=\\{1,2,3,4,5,6\\}$, so $n_0 = 6$.\n- Occupancy: $f_{\\mathrm{occ}}(0) = n_0/T = 6/6 = 1.0$.\n- Mean position $\\boldsymbol{\\mu}_0$: The provided coordinates are symmetric around $\\left(1.0, 0.0, 0.0\\right)$. The average is $\\boldsymbol{\\mu}_0 = \\frac{1}{6}\\sum_{t=1}^6 \\mathbf{r}_{0,t} = \\left(1.0, 0.0, 0.0\\right)$ Å.\n- Positional variance $\\sigma_0^2$: The deviation vectors are of the form $(\\pm 0.05, 0, 0)$, $(0, \\pm 0.05, 0)$, and $(0, 0, \\pm 0.05)$. Each has a squared Euclidean norm of $0.05^2 = 0.0025$ Å$^2$.\n$$ \\sigma_0^2 = \\frac{1}{n_0}\\sum_{t\\in S_0}\\|\\mathbf{r}_{0,t}-\\boldsymbol{\\mu}_0\\|_2^2 = \\frac{1}{6}\\left(6 \\times 0.0025\\right) = 0.0025 \\text{ Å}^2 $$\n- Proximity: The water is located near $\\mathbf{R}_1$. All per-frame distances $d_{0,t}$ are approximately $1.0$ Å. Specifically, the distances are $1.05, 0.95, \\sqrt{1.0025}, \\sqrt{1.0025}, \\sqrt{1.0025}, \\sqrt{1.0025}$.\n    - For $d_{\\max}=3.5$ Å, all six frames satisfy $d_{0,t} \\le 3.5$. Thus, $f_{\\mathrm{bind}}(0) = 6/6 = 1.0$.\n    - For $d_{\\max}=1.0$ Å, only the frame at $t=2$ has a distance $d_{0,2}=0.95 \\le 1.0$. Thus, $f_{\\mathrm{bind}}(0) = 1/6 \\approx 0.167$.\n\n**Water Molecule $i=1$**\n- Observed frames: $S_1=\\{1,2,3,4,5,6\\}$, so $n_1 = 6$.\n- Occupancy: $f_{\\mathrm{occ}}(1) = 6/6 = 1.0$.\n- Mean position $\\boldsymbol{\\mu}_1$: $\\boldsymbol{\\mu}_1 = \\frac{1}{6}\\sum_{t=1}^6 \\mathbf{r}_{1,t} = \\left(\\frac{32}{6}, \\frac{32}{6}, \\frac{30}{6}\\right) = \\left(\\frac{16}{3}, \\frac{16}{3}, 5.0\\right)$ Å.\n- Positional variance $\\sigma_1^2$:\n$$ \\sigma_1^2 = \\frac{1}{6}\\sum_{t=1}^6 \\|\\mathbf{r}_{1,t}-\\boldsymbol{\\mu}_1\\|_2^2 = \\frac{1}{6}\\left(\\frac{2}{9} + \\frac{5}{9} + \\frac{5}{9} + \\frac{26}{9} + \\frac{35}{9} + \\frac{41}{9}\\right) = \\frac{1}{6} \\frac{114}{9} = \\frac{19}{9} \\approx 2.111 \\text{ Å}^2 $$\n- Proximity: All coordinates are far from the protein atoms. The minimum distance for any frame is $\\|\\left(4.0, 4.0, 4.0\\right) - \\left(3.0, 3.0, 0.0\\right)\\| = \\sqrt{1^2+1^2+4^2} = \\sqrt{18} \\approx 4.24$ Å, which is to a point not even in the protein set. The smallest distance to an actual protein atom is $\\|\\left(4,4,4\\right)-\\left(3,0,0\\right)\\| = \\sqrt{1^2+4^2+4^2}=\\sqrt{33} \\approx 5.74$ Å. For both $d_{\\max}=3.5$ Å and $d_{\\max}=1.0$ Å, no frames are in contact. Thus, $f_{\\mathrm{bind}}(1) = 0.0$.\n\n**Water Molecule $i=2$**\n- Observed frames: $S_2=\\{1,2,3\\}$, so $n_2 = 3$.\n- Occupancy: $f_{\\mathrm{occ}}(2) = n_2/T = 3/6 = 0.5$.\n- Mean position $\\boldsymbol{\\mu}_2$: $\\boldsymbol{\\mu}_2 = \\frac{1}{3}\\left((1.22,0,0) + (1.18,0,0) + (1.20,0.02,0)\\right) = \\left(1.2, \\frac{0.02}{3}, 0\\right)$ Å.\n- Positional variance $\\sigma_2^2$:\n$$ \\sigma_2^2 = \\frac{1}{3}\\left( \\|(0.02, -\\frac{0.02}{3}, 0)\\|^2 + \\|(-0.02, -\\frac{0.02}{3}, 0)\\|^2 + \\|(0, \\frac{0.04}{3}, 0)\\|^2 \\right) \\approx 0.00028 \\text{ Å}^2 $$\n- Proximity: The water is near $\\mathbf{R}_1$. The distances $d_{2,t}$ are $1.22, 1.18, 1.20017$.\n    - For $d_{\\max}=3.5$ Å, all three frames satisfy $d_{2,t} \\le 3.5$. Thus, $f_{\\mathrm{bind}}(2) = 3/3 = 1.0$.\n    - For $d_{\\max}=1.0$ Å, no frames satisfy the condition. Thus, $f_{\\mathrm{bind}}(2) = 0.0$.\n\n**Water Molecule $i=3$**\n- Observed frames: $S_3=\\{1,2,3,4,5,6\\}$, so $n_3 = 6$.\n- Occupancy: $f_{\\mathrm{occ}}(3) = 6/6 = 1.0$.\n- Mean position $\\boldsymbol{\\mu}_3$: The coordinates are symmetric about $(1.0, 1.8, 0.0)$. Thus, $\\boldsymbol{\\mu}_3 = \\left(1.0, 1.8, 0.0\\right)$ Å.\n- Positional variance $\\sigma_3^2$: The deviations are of magnitude $0.1$ along each axis.\n$$ \\sigma_3^2 = \\frac{1}{6}\\left(6 \\times 0.1^2\\right) = 0.01 \\text{ Å}^2 $$\n- Proximity: The water is located between the three protein atoms, closest to $\\mathbf{R}_3=(0,3,0)$. The distances $d_{3,t}$ are approximately $1.5-1.6$ Å.\n    - For $d_{\\max}=3.5$ Å, all six frames satisfy $d_{3,t} \\le 3.5$. Thus, $f_{\\mathrm{bind}}(3) = 6/6 = 1.0$.\n    - For $d_{\\max}=1.0$ Å, no frames satisfy the condition. Thus, $f_{\\mathrm{bind}}(3) = 0.0$.\n\n**Water Molecule $i=4$**\n- Observed frames: $S_4=\\{1,2,3,4,5,6\\}$, so $n_4 = 6$.\n- Occupancy: $f_{\\mathrm{occ}}(4) = 6/6 = 1.0$.\n- Mean position $\\boldsymbol{\\mu}_4$: The coordinates are symmetric about $(10,10,10)$. Thus, $\\boldsymbol{\\mu}_4 = \\left(10.0, 10.0, 10.0\\right)$ Å.\n- Positional variance $\\sigma_4^2$: The deviations are of magnitude $0.02$ along each axis.\n$$ \\sigma_4^2 = \\frac{1}{6}\\left(6 \\times 0.02^2\\right) = 0.0004 \\text{ Å}^2 $$\n- Proximity: All coordinates are far from the protein. The minimum distance to a protein atom is approximately $15.78$ Å. For both $d_{\\max}=3.5$ Å and $d_{\\max}=1.0$ Å, no frames are in contact. Thus, $f_{\\mathrm{bind}}(4) = 0.0$.\n\nThe computed properties are summarized in the table below.\n\n| Water $i$ | $f_{\\mathrm{occ}}(i)$ | $\\sigma_i^2$ (Å$^2$) | $f_{\\mathrm{bind}}(i)$ for $d_{\\max}=3.5$ | $f_{\\mathrm{bind}}(i)$ for $d_{\\max}=1.0$ |\n|:---:|:---:|:---:|:---:|:---:|\n| $0$ | $1.0$ | $0.0025$ | $1.0$ | $\\approx 0.167$ |\n| $1$ | $1.0$ | $\\approx 2.111$ | $0.0$ | $0.0$ |\n| $2$ | $0.5$ | $\\approx 0.00028$ | $1.0$ | $0.0$ |\n| $3$ | $1.0$ | $0.01$ | $1.0$ | $0.0$ |\n| $4$ | $1.0$ | $0.0004$ | $0.0$ | $0.0$ |\n\nNow, we apply the classification criteria for each test case.\n\n**Case A:** $\\sigma^2_{\\max}=0.005$, $f_{\\min}=0.8$, $d_{\\max}=3.5$, $f_{\\mathrm{bind}}^{\\min}=0.8$.\n- Water 0: $1.0\\ge0.8$ (T), $0.0025\\le0.005$ (T), $1.0\\ge0.8$ (T) $\\implies$ structural.\n- Water 1: $1.0\\ge0.8$ (T), $2.111\\le0.005$ (F) $\\implies$ not structural.\n- Water 2: $0.5\\ge0.8$ (F) $\\implies$ not structural.\n- Water 3: $1.0\\ge0.8$ (T), $0.01\\le0.005$ (F) $\\implies$ not structural.\n- Water 4: $1.0\\ge0.8$ (T), $0.0004\\le0.005$ (T), $0.0\\ge0.8$ (F) $\\implies$ not structural.\nResult for Case A: $[0]$.\n\n**Case B:** $\\sigma^2_{\\max}=0.01$, $f_{\\min}=0.8$, $d_{\\max}=3.5$, $f_{\\mathrm{bind}}^{\\min}=0.8$.\n- Water 0: $1.0\\ge0.8$ (T), $0.0025\\le0.01$ (T), $1.0\\ge0.8$ (T) $\\implies$ structural.\n- Water 1: $1.0\\ge0.8$ (T), $2.111\\le0.01$ (F) $\\implies$ not structural.\n- Water 2: $0.5\\ge0.8$ (F) $\\implies$ not structural.\n- Water 3: $1.0\\ge0.8$ (T), $0.01\\le0.01$ (T), $1.0\\ge0.8$ (T) $\\implies$ structural.\n- Water 4: $1.0\\ge0.8$ (T), $0.0004\\le0.01$ (T), $0.0\\ge0.8$ (F) $\\implies$ not structural.\nResult for Case B: $[0, 3]$.\n\n**Case C:** $\\sigma^2_{\\max}=0.005$, $f_{\\min}=0.5$, $d_{\\max}=3.5$, $f_{\\mathrm{bind}}^{\\min}=0.8$.\n- Water 0: $1.0\\ge0.5$ (T), $0.0025\\le0.005$ (T), $1.0\\ge0.8$ (T) $\\implies$ structural.\n- Water 1: $1.0\\ge0.5$ (T), $2.111\\le0.005$ (F) $\\implies$ not structural.\n- Water 2: $0.5\\ge0.5$ (T), $0.00028\\le0.005$ (T), $1.0\\ge0.8$ (T) $\\implies$ structural.\n- Water 3: $1.0\\ge0.5$ (T), $0.01\\le0.005$ (F) $\\implies$ not structural.\n- Water 4: $1.0\\ge0.5$ (T), $0.0004\\le0.005$ (T), $0.0\\ge0.8$ (F) $\\implies$ not structural.\nResult for Case C: $[0, 2]$.\n\n**Case D:** $\\sigma^2_{\\max}=1.0$, $f_{\\min}=0.8$, $d_{\\max}=1.0$, $f_{\\mathrm{bind}}^{\\min}=0.5$.\n- Water 0: $1.0\\ge0.8$ (T), $0.0025\\le1.0$ (T), $0.167\\ge0.5$ (F) $\\implies$ not structural.\n- Water 1: $1.0\\ge0.8$ (T), $2.111\\le1.0$ (F) $\\implies$ not structural.\n- Water 2: $0.5\\ge0.8$ (F) $\\implies$ not structural.\n- Water 3: $1.0\\ge0.8$ (T), $0.01\\le1.0$ (T), $0.0\\ge0.5$ (F) $\\implies$ not structural.\n- Water 4: $1.0\\ge0.8$ (T), $0.0004\\le1.0$ (T), $0.0\\ge0.5$ (F) $\\implies$ not structural.\nResult for Case D: [].\n\nThe calculations are complete and the results for all four test cases have been determined. The implementation will follow this exact logic.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the structural water classification problem based on the provided dataset and definitions.\n    \"\"\"\n    # ====== DATA SETUP ======\n    \n    # Total number of frames in the trajectory.\n    T = 6\n\n    # Protein heavy atom coordinates.\n    protein_atoms = np.array([\n        [0.0, 0.0, 0.0],\n        [3.0, 0.0, 0.0],\n        [0.0, 3.0, 0.0]\n    ])\n\n    # Water oxygen coordinates. A dictionary is used to handle missing frames naturally.\n    # Key: water index, Value: dictionary of {frame_index: coordinates}. Frame indices are 1-based.\n    all_water_coords = {\n        0: {\n            1: [1.05, 0.0, 0.0], 2: [0.95, 0.0, 0.0], 3: [1.0, 0.05, 0.0],\n            4: [1.0, -0.05, 0.0], 5: [1.0, 0.0, 0.05], 6: [1.0, 0.0, -0.05]\n        },\n        1: {\n            1: [5.0, 5.0, 5.0], 2: [6.0, 5.0, 5.0], 3: [5.0, 6.0, 5.0],\n            4: [7.0, 5.0, 5.0], 5: [5.0, 7.0, 6.0], 6: [4.0, 4.0, 4.0]\n        },\n        2: {\n            1: [1.22, 0.0, 0.0], 2: [1.18, 0.0, 0.0], 3: [1.20, 0.02, 0.0]\n        },\n        3: {\n            1: [1.1, 1.8, 0.0], 2: [0.9, 1.8, 0.0], 3: [1.0, 1.9, 0.0],\n            4: [1.0, 1.7, 0.0], 5: [1.0, 1.8, 0.1], 6: [1.0, 1.8, -0.1]\n        },\n        4: {\n            1: [10.02, 10.0, 10.0], 2: [9.98, 10.0, 10.0], 3: [10.0, 10.02, 10.0],\n            4: [10.0, 9.98, 10.0], 5: [10.0, 10.0, 10.02], 6: [10.0, 10.0, 9.98]\n        }\n    }\n    \n    # Test suite of parameter sets.\n    # format: (sigma_sq_max, f_min, d_max, f_bind_min)\n    test_cases = [\n        (0.005, 0.8, 3.5, 0.8),  # Case A\n        (0.01, 0.8, 3.5, 0.8),   # Case B\n        (0.005, 0.5, 3.5, 0.8),   # Case C\n        (1.0, 0.8, 1.0, 0.5),     # Case D\n    ]\n    \n    # ====== CALCULATION ======\n    \n    num_waters = 5\n    water_properties = []\n\n    for i in range(num_waters):\n        water_frames = all_water_coords.get(i, {})\n        if not water_frames:\n            # Handle case of a water with no observations.\n            water_properties.append({\n                'f_occ': 0.0, 'sigma_sq': float('inf'), 'frames': [], 'n_i': 0\n            })\n            continue\n\n        observed_coords = np.array(list(water_frames.values()))\n        n_i = len(observed_coords)\n        \n        # Calculate occupancy fraction\n        f_occ = n_i / T\n        \n        # Calculate mean position and positional variance\n        mu_i = np.mean(observed_coords, axis=0)\n        # Variance is the mean of the squared Euclidean distances from the mean\n        sigma_sq = np.mean(np.sum((observed_coords - mu_i)**2, axis=1))\n\n        water_properties.append({\n            'f_occ': f_occ, 'sigma_sq': sigma_sq, 'frames': observed_coords, 'n_i': n_i\n        })\n        \n    final_results = []\n    \n    for case_params in test_cases:\n        sigma_sq_max, f_min, d_max, f_bind_min = case_params\n        structural_waters = []\n        \n        for i in range(num_waters):\n            props = water_properties[i]\n            \n            # Condition 1: Occupancy\n            if not (props['f_occ'] >= f_min):\n                continue\n            \n            # Condition 2: Positional variance\n            if not (props['sigma_sq'] <= sigma_sq_max):\n                continue\n                \n            # Condition 3: Binding-contact fraction\n            observed_coords = props['frames']\n            n_i = props['n_i']\n            \n            if n_i == 0:\n                # If there are no frames, binding fraction is undefined or 0. Fails condition.\n                continue\n\n            contact_frames = 0\n            for r_it in observed_coords:\n                # Calculate distances from this water position to all protein atoms\n                distances = np.linalg.norm(r_it - protein_atoms, axis=1)\n                min_dist = np.min(distances)\n                if min_dist <= d_max:\n                    contact_frames += 1\n            \n            f_bind = contact_frames / n_i\n            \n            if f_bind >= f_bind_min:\n                structural_waters.append(i)\n                \n        final_results.append(structural_waters)\n\n    # ====== FORMAT OUTPUT ======\n    \n    # Generate the output string in the exact format \"[[i,...],[j,...],...]\"\n    output_str_parts = []\n    for res in final_results:\n        # str(list) produces spaces, which must be removed.\n        output_str_parts.append(str(res).replace(\" \", \"\"))\n        \n    print(f\"[{','.join(output_str_parts)}]\")\n\n\nsolve()\n```", "id": "2422534"}]}