{"hands_on_practices": [{"introduction": "Our journey into the computational analysis of ribosomal RNA begins with a foundational tool: the multiple sequence alignment (MSA). This practice will guide you in applying Shannon entropy, a powerful concept from information theory, to measure the conservation at each position within an rRNA alignment. By calculating entropy, you will learn to quantitatively identify functionally or structurally constrained sites, a critical skill for pinpointing the most important regions in any set of biological sequences. [@problem_id:2426486]", "problem": "You are given a fixed multiple sequence alignment of fragments from the small subunit ribosomal RNA (rRNA), specifically $16\\mathrm{S}$ rRNA. The alignment consists of $M=8$ sequences, each of length $L=12$, over the character set $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U},\\mathrm{T},\\mathrm{N},-\\}$. The sequences are:\n\n- $S_1$: \"AAAAANGACAAG\"\n- $S_2$: \"AAC-UNGACAAT\"\n- $S_3$: \"AAG-T-GACAAU\"\n- $S_4$: \"AAU-C-GAGAAC\"\n- $S_5$: \"AGA-ANGA-UAN\"\n- $S_6$: \"AGC-U-GA-UA-\"\n- $S_7$: \"AGGAT-G--UAA\"\n- $S_8$: \"AGU-CN---AAA\"\n\nFor each alignment column $j \\in \\{1,\\dots,L\\}$, interpret characters as follows:\n- Treat $\\mathrm{T}$ as $\\mathrm{U}$.\n- Treat the symbols $\\mathrm{N}$ and $-$ as non-informative and exclude them from all frequency and probability calculations in that column.\n- Only the four canonical ribonucleotides $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ contribute to probabilities.\n\nLet $n(j)$ be the count of informative characters in column $j$ after the above interpretation, and let $n_b(j)$ be the count of base $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ in column $j$. Define the empirical base probabilities for column $j$ by\n$$\np_b(j) = \\frac{n_b(j)}{n(j)}\n$$\nfor those $b$ with $n_b(j) > 0$. Define the Shannon entropy (in bits) for column $j$ by\n$$\nH_j = -\\sum_{\\substack{b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\} \\\\ p_b(j) > 0}} p_b(j)\\,\\log_2 p_b(j),\n$$\nwith the convention that if $n(j)=0$, then $H_j = 0$. Define the coverage of column $j$ by\n$$\nc_j = \\frac{n(j)}{M}.\n$$\n\nA column is considered functionally constrained if and only if it satisfies both $H_j \\le \\tau$ and $c_j \\ge \\gamma$ for specified thresholds $\\tau$ and $\\gamma$.\n\nYour task is to write a program that, for the alignment above, computes $H_j$ and $c_j$ for each column $j \\in \\{1,\\dots,12\\}$ precisely as defined and, for each of the following parameter pairs $(\\tau,\\gamma)$, returns the list of all $j$ that are functionally constrained, using $1$-based indexing:\n\nTest suite (three parameter pairs):\n- Case $1$: $(\\tau,\\gamma) = (0.0, 0.5)$\n- Case $2$: $(\\tau,\\gamma) = (1.0, 0.5)$\n- Case $3$: $(\\tau,\\gamma) = (2.0, 0.75)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all three cases as a comma-separated list enclosed in square brackets, with no spaces. Each caseâ€™s result must itself be a bracketed, comma-separated list of the selected column indices in increasing order. For example, a valid output with three cases would look like \"[[1,2],[3],[4,5,6]]\".", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded in the principles of bioinformatics, specifically the analysis of multiple sequence alignments to infer functional constraints. The problem is well-posed, with all necessary data and mathematical definitions provided to ensure a unique and meaningful solution. All terms are objective and precisely defined.\n\nThe task is to identify functionally constrained columns in a given multiple sequence alignment of $M=8$ sequences, each of length $L=12$. A column $j$ is deemed functionally constrained if its Shannon entropy $H_j$ and coverage $c_j$ satisfy the conditions $H_j \\le \\tau$ and $c_j \\ge \\gamma$ for given thresholds $(\\tau, \\gamma)$.\n\nThe solution proceeds systematically for each column $j \\in \\{1, \\dots, 12\\}$.\n\nFirst, a pre-processing step is applied to each column's characters. The base $\\mathrm{T}$ is treated as $\\mathrm{U}$, and non-informative characters ($\\mathrm{N}$, $-$) are discarded. Only the canonical ribonucleotides $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ are considered for subsequent calculations.\n\nLet the set of sequences be $\\{S_i\\}_{i=1}^M$. The character at column $j$ of sequence $i$ is $S_i[j]$.\nFor each column $j$:\n1.  The number of informative characters, $n(j)$, is determined by counting the characters in $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$ after the $\\mathrm{T} \\to \\mathrm{U}$ conversion.\n2.  The coverage, $c_j$, is calculated as the fraction of informative characters:\n    $$\n    c_j = \\frac{n(j)}{M} = \\frac{n(j)}{8}\n    $$\n3.  The count of each base, $n_b(j)$ for $b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\}$, is tallied from the informative characters.\n4.  The empirical probability of each base is calculated:\n    $$\n    p_b(j) = \\frac{n_b(j)}{n(j)}\n    $$\n    This is defined only if $n(j) > 0$.\n5.  The Shannon entropy, $H_j$, is calculated in bits using the formula:\n    $$\n    H_j = -\\sum_{\\substack{b \\in \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{U}\\} \\\\ n_b(j) > 0}} p_b(j)\\,\\log_2 p_b(j)\n    $$\n    If $n(j)=0$, we take $H_j=0$ as per the problem definition.\n\nThe alignment is given as:\n- $S_1$: \"AAAAANGACAAG\"\n- $S_2$: \"AAC-UNGACAAT\"\n- $S_3$: \"AAG-T-GACAAU\"\n- $S_4$: \"AAU-C-GAGAAC\"\n- $S_5$: \"AGA-ANGA-UAN\"\n- $S_6$: \"AGC-U-GA-UA-\"\n- $S_7$: \"AGGAT-G--UAA\"\n- $S_8$: \"AGU-CN---AAA\"\n\nThe calculated values for $H_j$ and $c_j$ for each column are summarized in the following table.\n\n| Column ($j$) | Processed Characters | $n(j)$ | Base Counts ($n_b(j)$)        | $c_j$   | Shannon Entropy $H_j$ (bits) |\n|--------------|----------------------|--------|------------------------------|---------|------------------------------|\n| $1$          | `AAAAAAAA`           | $8$    | A:$8$                        | $1.0$   | $0.0$                        |\n| $2$          | `AAAAGGGG`           | $8$    | A:$4$, G:$4$                 | $1.0$   | $1.0$                        |\n| $3$          | `ACGUACGU`           | $8$    | A:$2$, C:$2$, G:$2$, U:$2$    | $1.0$   | $2.0$                        |\n| $4$          | `AAAA`               | $4$    | A:$4$                        | $0.5$   | $0.0$                        |\n| $5$          | `AUUCAUUC` (T$\\to$U) | $8$    | A:$2$, C:$2$, U:$4$           | $1.0$   | $1.5$                        |\n| $6$          |                      | $0$    | -                            | $0.0$   | $0.0$                        |\n| $7$          | `GGGGGGG`            | $7$    | G:$7$                        | $0.875$ | $0.0$                        |\n| $8$          | `AAAAAA`             | $6$    | A:$6$                        | $0.75$  | $0.0$                        |\n| $9$          | `CCCG`               | $4$    | C:$3$, G:$1$                 | $0.5$   | $\\approx 0.8113$             |\n| $10$         | `AAAAUUUA`           | $8$    | A:$5$, U:$3$                 | $1.0$   | $\\approx 0.9544$             |\n| $11$         | `AAAAAAAA`           | $8$    | A:$8$                        | $1.0$   | $0.0$                        |\n| $12$         | `GUUCAA` (T$\\to$U)   | $6$    | A:$2$, C:$1$, G:$1$, U:$2$    | $0.75$  | $\\approx 1.9183$             |\n\nWith these values, we evaluate the constraint condition $H_j \\le \\tau$ and $c_j \\ge \\gamma$ for each test case.\n\n**Case 1: $(\\tau, \\gamma) = (0.0, 0.5)$**\nWe require $H_j = 0.0$ and $c_j \\ge 0.5$.\n- Column $1$: $H_1=0.0$, $c_1=1.0$. Condition met.\n- Column $4$: $H_4=0.0$, $c_4=0.5$. Condition met.\n- Column $6$: $H_6=0.0$, but $c_6=0.0 < 0.5$. Condition not met.\n- Column $7$: $H_7=0.0$, $c_7=0.875$. Condition met.\n- Column $8$: $H_8=0.0$, $c_8=0.75$. Condition met.\n- Column $11$: $H_{11}=0.0$, $c_{11}=1.0$. Condition met.\nThe set of constrained columns for this case is $\\{1, 4, 7, 8, 11\\}$.\n\n**Case 2: $(\\tau, \\gamma) = (1.0, 0.5)$**\nWe require $H_j \\le 1.0$ and $c_j \\ge 0.5$.\n- Columns from Case 1 meet this: $\\{1, 4, 7, 8, 11\\}$.\n- Column $2$: $H_2=1.0 \\le 1.0$, $c_2=1.0 \\ge 0.5$. Met.\n- Column $3$: $H_3=2.0 > 1.0$. Not met.\n- Column $5$: $H_5=1.5 > 1.0$. Not met.\n- Column $6$: $c_6=0.0 < 0.5$. Not met.\n- Column $9$: $H_9 \\approx 0.8113 \\le 1.0$, $c_9=0.5 \\ge 0.5$. Met.\n- Column $10$: $H_{10} \\approx 0.9544 \\le 1.0$, $c_{10}=1.0 \\ge 0.5$. Met.\n- Column $12$: $H_{12} \\approx 1.9183 > 1.0$. Not met.\nThe set of constrained columns for this case is $\\{1, 2, 4, 7, 8, 9, 10, 11\\}$.\n\n**Case 3: $(\\tau, \\gamma) = (2.0, 0.75)$**\nWe require $H_j \\le 2.0$ and $c_j \\ge 0.75$.\n- Column $1$: $H_1=0.0 \\le 2.0$, $c_1=1.0 \\ge 0.75$. Met.\n- Column $2$: $H_2=1.0 \\le 2.0$, $c_2=1.0 \\ge 0.75$. Met.\n- Column $3$: $H_3=2.0 \\le 2.0$, $c_3=1.0 \\ge 0.75$. Met.\n- Column $4$: $c_4=0.5 < 0.75$. Not met.\n- Column $5$: $H_5=1.5 \\le 2.0$, $c_5=1.0 \\ge 0.75$. Met.\n- Column $6$: $c_6=0.0 < 0.75$. Not met.\n- Column $7$: $H_7 = 0.0 \\le 2.0$, $c_7=0.875 \\ge 0.75$. Met.\n- Column $8$: $H_8 = 0.0 \\le 2.0$, $c_8=0.75 \\ge 0.75$. Met.\n- Column $9$: $c_9=0.5 < 0.75$. Not met.\n- Column $10$: $H_{10} \\approx 0.9544 \\le 2.0$, $c_{10}=1.0 \\ge 0.75$. Met.\n- Column $11$: $H_{11}=0.0 \\le 2.0$, $c_{11}=1.0 \\ge 0.75$. Met.\n- Column $12$: $H_{12} \\approx 1.9183 \\le 2.0$, $c_{12}=0.75 \\ge 0.75$. Met.\nThe set of constrained columns for this case is $\\{1, 2, 3, 5, 7, 8, 10, 11, 12\\}$.\n\nThe final results are compiled into the required output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Computes functionally constrained columns in an rRNA alignment for three test cases.\n    \"\"\"\n    # Define the alignment and problem constants.\n    sequences = [\n        \"AAAAANGACAAG\",\n        \"AAC-UNGACAAT\",\n        \"AAG-T-GACAAU\",\n        \"AAU-C-GAGAAC\",\n        \"AGA-ANGA-UAN\",\n        \"AGC-U-GA-UA-\",\n        \"AGGAT-G--UAA\",\n        \"AGU-CN---AAA\",\n    ]\n    M = 8  # Number of sequences\n    L = 12 # Length of sequences\n\n    # Test suite parameters (tau, gamma).\n    test_cases = [\n        (0.0, 0.5),\n        (1.0, 0.5),\n        (2.0, 0.75),\n    ]\n\n    # Transpose the alignment to get columns.\n    columns = list(zip(*sequences))\n    \n    # Calculate entropy and coverage for each column.\n    column_metrics = []\n    for j in range(L):\n        column_chars = columns[j]\n        \n        # Pre-process characters: T -> U, filter for informative bases.\n        informative_chars = []\n        for char in column_chars:\n            if char == 'T':\n                informative_chars.append('U')\n            elif char in 'ACGU':\n                informative_chars.append(char)\n        \n        n_j = len(informative_chars)\n        \n        # Calculate coverage (c_j).\n        c_j = n_j / M\n        \n        # Calculate Shannon entropy (H_j).\n        H_j = 0.0\n        if n_j > 0:\n            # Count occurrences of each base in the column.\n            counts = collections.Counter(informative_chars)\n            for base in counts:\n                p_b_j = counts[base] / n_j\n                H_j -= p_b_j * np.log2(p_b_j)\n        \n        column_metrics.append({'H': H_j, 'c': c_j})\n\n    # Apply the constraint criteria for each test case.\n    all_results = []\n    for tau, gamma in test_cases:\n        constrained_columns = []\n        for j in range(L):\n            metrics = column_metrics[j]\n            if metrics['H'] <= tau and metrics['c'] >= gamma:\n                # Append 1-based index.\n                constrained_columns.append(j + 1)\n        all_results.append(constrained_columns)\n\n    # Format the final output string.\n    # e.g., [[1,2],[3],[4,5,6]]\n    result_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    \n    # Final print statement in the exact required format.\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2426486"}, {"introduction": "Having explored sequence conservation, we now address a central question in molecular biology: how does a linear RNA sequence fold into a functional three-dimensional structure? This exercise challenges you to implement a recursive algorithm to enumerate all possible secondary structures for a small rRNA fragment and rank them based on a simplified thermodynamic model. By calculating the Gibbs free energy ($\\Delta G_f$) for each fold, you'll gain hands-on experience with the core principles of RNA structure prediction and the computational search for the most stable conformation. [@problem_id:2426514]", "problem": "You are given a small fragment of ribosomal RNA (rRNA) and asked to explore its possible pseudoknot-free secondary structures under a simplified and scientifically plausible thermodynamic model. The goal is to enumerate all possible secondary structures for each provided sequence segment that satisfy canonical base-pairing rules, compute the Gibbs free energy of folding ($\\Delta G_f$) for each structure, and then rank the structures by thermodynamic stability (most negative $\\Delta G_f$ is most stable).\n\nUse the following fundamental biological and physical bases:\n- Complementary base pairing in ribonucleic acid (RNA): canonical Watsonâ€“Crick pairs ($\\mathrm{A}$-$\\mathrm{U}$ and $\\mathrm{G}$-$\\mathrm{C}$) and wobble pairs ($\\mathrm{G}$-$\\mathrm{U}$). These pairings are rooted in hydrogen bonding and steric compatibility.\n- Gibbs free energy of folding ($\\Delta G_f$) as an additive model of stabilizing and destabilizing contributions, where more negative values indicate more stable structures.\n\nSecondary structure model and constraints:\n- Allowed base pairs are exactly $\\{\\mathrm{A}\\text{-}\\mathrm{U},\\mathrm{U}\\text{-}\\mathrm{A},\\mathrm{G}\\text{-}\\mathrm{C},\\mathrm{C}\\text{-}\\mathrm{G},\\mathrm{G}\\text{-}\\mathrm{U},\\mathrm{U}\\text{-}\\mathrm{G}\\}$.\n- A nucleotide may participate in at most one base pair.\n- Pseudoknots are forbidden (non-crossing constraint): if positions $i$ and $j$ form a pair with $i&lt;j$, and positions $k$ and $\\ell$ form a pair with $k&lt;\\ell$, then it must not be that $i&lt;k&lt;j&lt;\\ell$.\n- Minimum hairpin loop length is $m=3$: if $i$ pairs with $j$ then $j-i-1\\ge m$ must hold.\n\nThermodynamic scoring (simplified additive model, all energies in $\\mathrm{kcal/mol}$):\n- Per base-pair stabilization energy $e(x_i,x_j)$:\n  - $e(\\mathrm{G},\\mathrm{C})=e(\\mathrm{C},\\mathrm{G})=-3.0$,\n  - $e(\\mathrm{A},\\mathrm{U})=e(\\mathrm{U},\\mathrm{A})=-2.0$,\n  - $e(\\mathrm{G},\\mathrm{U})=e(\\mathrm{U},\\mathrm{G})=-1.0$.\n- Hairpin loop penalty $h(L)$ applied only to pairs that close a hairpin (i.e., pairs $(i,j)$ with no other pairs nested strictly between $i$ and $j$), where $L=j-i-1$:\n  - $h(L)=3.0+0.4\\cdot(L-3)$ for $L\\ge 3$.\n- Stacking bonus $s_{\\text{stack}}=-0.5$ applied once for each adjacent stacked pair, i.e., add $s_{\\text{stack}}$ for every pair $(i,j)$ such that $(i+1,j-1)$ is also a pair in the structure.\n- No additional penalties or bonuses are applied (no explicit interior, bulge, or multiloop terms beyond the above).\n\nFor a structure $S$ on a sequence $x_1x_2\\ldots x_n$, with set of base pairs $\\mathcal{P}(S)$, set of hairpin-closing pairs $\\mathcal{H}(S)\\subseteq \\mathcal{P}(S)$, and set of stacked adjacencies $\\mathcal{T}(S)=\\{(i,j)\\in \\mathcal{P}(S)\\,:\\,(i+1,j-1)\\in \\mathcal{P}(S)\\}$, the simplified Gibbs free energy of folding is\n$$\n\\Delta G_f(S)\n=\n\\sum_{(i,j)\\in \\mathcal{P}(S)} e(x_i,x_j)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{H}(S)} h(j-i-1)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{T}(S)} s_{\\text{stack}}.\n$$\n\nComputational requirements:\n- Enumerate every pseudoknot-free secondary structure consistent with the above rules for each test sequence.\n- Compute $\\Delta G_f$ for each structure.\n- Rank structures by $\\Delta G_f$ in ascending order (more negative first). If multiple structures have indistinguishable energies within numerical rounding, they are considered ties.\n\nUnits and numerical formatting:\n- Report energies in $\\mathrm{kcal/mol}$.\n- Round each reported energy to three decimal places.\n- For ranking and deduplication, you may treat two energies $E_1$ and $E_2$ as identical if $\\left|E_1-E_2\\right| &lt; 10^{-6}$, which is equivalent here to deduplicating by rounding to three decimals.\n\nTest suite:\nUse the following four sequences (each sequence is a standalone test case). Indices are $1$-based in the mathematical description but you must implement with $0$-based indices in code.\n1. $x^{(1)}=$ \"GGAUCCAUUGCC\"\n2. $x^{(2)}=$ \"AAAAAGAAAAAA\"\n3. $x^{(3)}=$ \"GGGAAUUCCCUU\"\n4. $x^{(4)}=$ \"AUGCUAGCUA\"\n\nAnswer specification:\n- For each test case, output the list of the top $K=3$ unique energies (after rounding to three decimals) in ascending order. If there are fewer than $K$ unique energies, output all available unique energies.\n- The final output must be a single line containing a list of lists, one inner list per test case, in the same order as given above. The line must be formatted as a Python-style nested list of floats with exactly three decimal places and no units, for example, \"[[-7.200,-6.800,-6.400],[0.000],[-5.300,-5.000,-4.600],[-2.000,-1.600,-1.500]]\".", "solution": "The problem as stated is scientifically sound, mathematically well-posed, and objective. It provides a simplified but consistent thermodynamic model for the folding of ribosomal RNA (rRNA) fragments. All parameters, constraints, and objectives are specified with sufficient rigor to permit a unique and verifiable solution. Thus, the problem is deemed valid and a computational solution is warranted.\n\nThe central task is to enumerate all possible pseudoknot-free secondary structures for a given RNA sequence, calculate the Gibbs free energy ($\\Delta G_f$) for each, and identify the most stable configurations. Given the small length of the provided sequences (at most $n=12$ nucleotides), a direct approach of recursive enumeration with memoization is computationally feasible and more straightforward to implement correctly than a complex dynamic programming formulation tailored to this specific, simplified energy model.\n\nThe algorithm proceeds as follows:\n\nFirst, we define a recursive function, let us denote it $\\Phi(i, j)$, which generates the set of all valid secondary structures for the subsequence $x_i, \\dots, x_j$. A structure is mathematically a set of pairs $(p, q)$ representing base pairings, where $i \\le p < q \\le j$. To adhere to the non-crossing (pseudoknot-free) constraint, this function operates on the principle of decomposition:\n\n1.  A structure on $x_i, \\dots, x_j$ either leaves the nucleotide $x_j$ unpaired, or it pairs $x_j$ with some nucleotide $x_k$ where $i \\le k < j$.\n2.  If $x_j$ is unpaired, the set of possible structures is identical to that for the subsequence $x_i, \\dots, x_{j-1}$, which is given by $\\Phi(i, j-1)$.\n3.  If $x_j$ is paired with $x_k$ (where $(x_k, x_j)$ is an allowed pair and $j-k-1 \\ge m=3$), the non-crossing constraint dictates that the overall structure is a combination of a structure on the subsequence \"to the left\" of the pair, $x_i, \\dots, x_{k-1}$, and a structure on the subsequence \"inside\" the pair, $x_{k+1}, \\dots, x_{j-1}$. All combinations of valid substructures from these two regions, obtained from $\\Phi(i, k-1)$ and $\\Phi(k+1, j-1)$ respectively, are generated and combined with the new pair $(k, j)$.\n\nThe recursion's base case is a subsequence too short to form a hairpin loop ($j-i-1 < m$), for which the only valid structure is the empty one with no pairs. The results of $\\Phi(i, j)$ are memoized to avoid redundant computations for overlapping subproblems.\n\nSecond, for each enumerated structure $S$, we compute its Gibbs free energy of folding, $\\Delta G_f(S)$, strictly following the provided formula:\n$$\n\\Delta G_f(S)\n=\n\\sum_{(i,j)\\in \\mathcal{P}(S)} e(x_i,x_j)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{H}(S)} h(j-i-1)\n\\;+\\;\n\\sum_{(i,j)\\in \\mathcal{T}(S)} s_{\\text{stack}}.\n$$\nThe calculation for a given structure $S$, represented as a set of pairs $\\mathcal{P}(S)$, is performed by iterating through each pair $(i, j) \\in \\mathcal{P}(S)$ and applying the following logic:\n- The base-pair stabilization energy $e(x_i, x_j)$ is always added.\n- The stacking bonus $s_{\\text{stack}} = -0.5$ is added if the adjacent inner pair $(i+1, j-1)$ is also a member of $\\mathcal{P}(S)$.\n- The hairpin loop penalty $h(j-i-1)$ is added if and only if the pair $(i, j)$ is a hairpin-closing pair, meaning there exists no other pair $(p, q) \\in \\mathcal{P}(S)$ such that $i < p < q < j$. This condition is checked for each pair.\n\nThe structure with no pairs, $\\mathcal{P}(S) = \\emptyset$, is always a possibility, and its energy is $\\Delta G_f = 0.0$.\n\nFinally, for each input sequence, the computed energies from all possible structures are collected. These energies are deduplicated by treating values $E_1, E_2$ as identical if $|E_1 - E_2| < 10^{-6}$, which is achieved by rounding to a high precision (e.g., $9$ decimal places) before identifying unique values. The resulting unique energies are sorted in ascending order, and the top $K=3$ (or fewer, if not enough unique energies exist) are selected. These values are then formatted to three decimal places for the final output as specified.", "answer": "```python\nimport numpy as np\n\n# Global constants and memoization table, reset for each sequence.\nBASE_PAIR_ENERGIES = {\n    ('G', 'C'): -3.0, ('C', 'G'): -3.0,\n    ('A', 'U'): -2.0, ('U', 'A'): -2.0,\n    ('G', 'U'): -1.0, ('U', 'G'): -1.0,\n}\nALLOWED_PAIRS = set(BASE_PAIR_ENERGIES.keys())\nSTACKING_BONUS = -0.5\nMIN_HAIRPIN_LOOP_LENGTH = 3\n\nmemo_structures = {}\nsequence_str = \"\"\n\ndef hairpin_penalty(length):\n    \"\"\"Calculates the hairpin loop penalty based on its length.\"\"\"\n    return 3.0 + 0.4 * (length - MIN_HAIRPIN_LOOP_LENGTH)\n\ndef generate_structures(i, j):\n    \"\"\"\n    Recursively generates all possible pseudoknot-free secondary structures\n    for the subsequence sequence_str[i:j+1].\n    Uses memoization to store results.\n    A structure is represented as a frozenset of pairs (tuples) for hashability.\n    \"\"\"\n    if (i, j) in memo_structures:\n        return memo_structures[(i, j)]\n\n    # Base case: subsequence is too short to form any pair according to the minimum hairpin loop rule.\n    if j < i + MIN_HAIRPIN_LOOP_LENGTH + 1:\n        # The only possible structure is the one with no pairs.\n        return {frozenset()}\n\n    # Recursive step\n    # Case 1: Nucleotide j is unpaired. Structures are the same as for the subsequence [i, j-1].\n    # A copy is made to prevent modification of the memoized set.\n    res_structures = set(generate_structures(i, j - 1))\n\n    # Case 2: Nucleotide j pairs with some k, where i <= k < j.\n    # The minimum loop length constraint implies j-k-1 >= m=3, so k <= j-4.\n    for k in range(i, j - MIN_HAIRPIN_LOOP_LENGTH):\n        if (sequence_str[k], sequence_str[j]) in ALLOWED_PAIRS:\n            # The pair (k, j) partitions the structure into an 'inner' part (subsequence k+1 to j-1)\n            # and a 'left' part (subsequence i to k-1). We find all structures for both.\n            left_structures = generate_structures(i, k - 1)\n            inner_structures = generate_structures(k + 1, j - 1)\n\n            # Combine all possibilities from the subproblems.\n            for s_left in left_structures:\n                for s_inner in inner_structures:\n                    new_structure = s_left.union(s_inner, {(k, j)})\n                    res_structures.add(new_structure)\n    \n    memo_structures[(i, j)] = res_structures\n    return res_structures\n\ndef calculate_energy(structure, sequence):\n    \"\"\"Calculates the Gibbs free energy of a given secondary structure.\"\"\"\n    if not structure:\n        return 0.0\n\n    total_energy = 0.0\n    \n    # Pre-compute which pairs are hairpin-closing to avoid repeated checks.\n    hairpin_closing_pairs = set()\n    for i, j in structure:\n        is_hairpin = True\n        for p, q in structure:\n            if i < p and q < j:\n                is_hairpin = False\n                break\n        if is_hairpin:\n            hairpin_closing_pairs.add((i, j))\n\n    for i, j in structure:\n        # 1. Add base-pair stabilization energy\n        total_energy += BASE_PAIR_ENERGIES[(sequence[i], sequence[j])]\n        \n        # 2. Add stacking bonus if an adjacent inner pair exists\n        if (i + 1, j - 1) in structure:\n            total_energy += STACKING_BONUS\n            \n        # 3. Add hairpin loop penalty if the pair closes a hairpin\n        if (i, j) in hairpin_closing_pairs:\n            loop_length = j - i - 1\n            total_energy += hairpin_penalty(loop_length)\n            \n    return total_energy\n\ndef solve_for_sequence(seq):\n    \"\"\"Orchestrates the full process for a single RNA sequence.\"\"\"\n    global memo_structures, sequence_str\n    memo_structures = {}\n    sequence_str = seq\n    n = len(seq)\n    \n    if n == 0:\n        return [0.0]\n\n    all_structures = generate_structures(0, n - 1)\n    \n    energies = [calculate_energy(s, seq) for s in all_structures]\n\n    # Deduplicate energies using high precision, then sort.\n    # A precision of 9 decimal places is sufficient for the 1e-6 tie condition.\n    unique_energies = sorted(list(set(np.round(energies, 9))))\n    \n    # Return top K=3 or fewer if not enough unique energies are found.\n    return unique_energies[:3]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the solution for all test cases and print\n    the final output in the required format.\n    \"\"\"\n    test_cases = [\n        \"GGAUCCAUUGCC\",\n        \"AAAAAGAAAAAA\",\n        \"GGGAAUUCCCUU\",\n        \"AUGCUAGCUA\",\n    ]\n\n    final_results = []\n    for seq in test_cases:\n        top_energies = solve_for_sequence(seq)\n        final_results.append(top_energies)\n\n    # Format the final list of lists of floats into the specified string format.\n    # example: \"[[-7.200,-6.800,-6.400],[0.000],[-5.300,-5.000,-4.600],[-2.000,-1.600,-1.500]]\"\n    outer_list_parts = []\n    for result_list in final_results:\n        inner_list_parts = [f\"{e:.3f}\" for e in result_list]\n        outer_list_parts.append(f\"[{','.join(inner_list_parts)}]\")\n    \n    print(f\"[{','.join(outer_list_parts)}]\")\n\nsolve()\n```", "id": "2426514"}, {"introduction": "Structure prediction models, while powerful, generate hypotheses that require validation. This final practice provides a powerful method for doing so by harnessing evolutionary information from a multiple sequence alignment. You will develop an algorithm to detect Compensatory Base-pair Changes (CBCs), which are strong indicators of conserved RNA base pairs, to score and validate predicted helices. This exercise bridges the gap between sequence analysis and structural biology, demonstrating how comparative data provides robust evidence for RNA structure. [@problem_id:2426467]", "problem": "Write a complete program that, given a fixed multiple sequence alignment of ribosomal RNA (rRNA) and a fixed set of predicted helices, evaluates compensatory base-pair change (CBC) support for each helix and reports, for several threshold values, how many helices are validated.\n\nA multiple sequence alignment (MSA) of ribosomal RNA (rRNA) is provided as $S$ aligned sequences of equal length $L$. All sequences are strings over the alphabet {A, C, G, U, -}, where the dash character denotes a gap. Consider a predicted helix to be a set of one or more base-paired alignment column index pairs $(i,j)$ with $1 \\le i < j \\le L$, using $1$-based indexing.\n\nDefine the set of canonical base pairs $P$ as $P = \\{(A,U),(U,A),(G,C),(C,G),(G,U),(U,G)\\}$. For a given pair of alignment columns $(i,j)$ and a given sequence $k \\in \\{1,\\dots,S\\}$, let $x_k$ be the nucleotide at column $i$ and $y_k$ be the nucleotide at column $j$. A sequence $k$ contributes a canonical pairing state at $(i,j)$ if $(x_k,y_k) \\in P$; otherwise, it is ignored for $(i,j)$.\n\nFor a given pair of columns $(i,j)$, define the number of compensatory base-pair changes (CBCs) as the number of unordered pairs of sequences $\\{k,\\ell\\}$ with $1 \\le k < \\ell \\le S$ such that:\n- both $(x_k,y_k) \\in P$ and $(x_{\\ell},y_{\\ell}) \\in P$, and\n- $x_k \\ne x_{\\ell}$ and $y_k \\ne y_{\\ell}$.\n\nFor a helix consisting of pairs $(i_m,j_m)$ for $m \\in \\{1,\\dots,H_{\\text{pairs}}\\}$, define its total CBC count as the sum of CBC counts over its constituent base-pair column pairs:\n$$\n\\mathrm{CBC\\_total} = \\sum_{m=1}^{H_{\\text{pairs}}} \\mathrm{CBC}(i_m,j_m).\n$$\nA helix is considered validated at threshold $t$ if $\\mathrm{CBC\\_total} \\ge t$.\n\nUse the following fixed MSA (with $S=6$ sequences and $L=12$ columns), written as $6$ equal-length strings:\n\n- $s_1 =$ \"AAGGG--UCCUU\"\n- $s_2 =$ \"GGAGG-ACCUCC\"\n- $s_3 =$ \"-UUGGC-UCAA-\"\n- $s_4 =$ \"-GGGG--GCUU-\"\n- $s_5 =$ \"-CCGGAUCCGG-\"\n- $s_6 =$ \"-AGGG--UCCU-\"\n\nUse the following set of $5$ predicted helices, each specified as a list of $1$-based index pairs $(i,j)$:\n- Helix $1$: $(2,11)$ and $(3,10)$\n- Helix $2$: $(4,9)$\n- Helix $3$: $(5,8)$\n- Helix $4$: $(6,7)$\n- Helix $5$: $(1,12)$\n\nTest suite (four threshold values $t$ to be evaluated independently on the same MSA and helix set):\n- Case $1$: $t = 5$\n- Case $2$: $t = 0$\n- Case $3$: $t = 1$\n- Case $4$: $t = 100$\n\nYour program must compute, for each case, the number of helices that are validated at the given threshold $t$. The final output must be a single line containing a comma-separated list of the $4$ integer results in the order of the cases, enclosed in square brackets (for example, \"[a,b,c,d]\"), with no additional text. No user input is required or permitted. Angles and physical units are not applicable in this problem; all reported quantities are dimensionless integers.", "solution": "The problem requires the validation of predicted ribosomal RNA (rRNA) secondary structure helices based on evolutionary evidence from a multiple sequence alignment (MSA). Specifically, we must quantify the support for each predicted helix by counting Compensatory Base-pair Changes (CBCs) and then determine, for several given thresholds, how many helices meet the validation criterion.\n\nThe provided input consists of an MSA of $S=6$ rRNA sequences, each of length $L=12$, a set of $5$ predicted helices defined by pairs of alignment columns, and a set of $4$ integer thresholds for validation. All column indices are 1-based, which must be converted to $0$-based for computation.\n\nA fundamental concept is the set of canonical base pairs, defined as $P = \\{(A,U),(U,A),(G,C),(C,G),(G,U),(U,G)\\}$. For a given pair of alignment columns $(i,j)$ and a sequence $k$, the nucleotides $(x_k, y_k)$ at these columns form a canonical pairing state if $(x_k, y_k) \\in P$.\n\nThe core of the analysis lies in the definition of a Compensatory Base-pair Change (CBC). According to the problem statement, the CBC count for a column pair $(i,j)$ is the number of unordered pairs of sequences $\\{k,\\ell\\}$ from the MSA that satisfy two strict conditions:\n$1$. Both sequences must form a canonical pair at columns $(i,j)$: $(x_k, y_k) \\in P$ and $(x_{\\ell}, y_{\\ell}) \\in P$.\n$2$. The nucleotides at both positions must be different: $x_k \\ne x_{\\ell}$ and $y_k \\ne y_{\\ell}$. This requires a coordinated change at both sites, for example, from $(G,C)$ to $(A,U)$ or from $(G,C)$ to $(C,G)$, but not from $(G,C)$ to $(G,U)$ as the first base is unchanged.\n\nThe total support for a helix, $\\mathrm{CBC\\_total}$, is the sum of the CBC counts for all column pairs $(i_m, j_m)$ that constitute the helix: $\\mathrm{CBC\\_total} = \\sum_{m=1}^{H_{\\text{pairs}}} \\mathrm{CBC}(i_m,j_m)$. Finally, a helix is considered validated at a threshold $t$ if its total support meets or exceeds this value, i.e., $\\mathrm{CBC\\_total} \\ge t$.\n\nThe solution follows a systematic, multi-step algorithm:\n\nFirst, we process the input data. The MSA is stored as an array of strings. The set of helices is stored as a list of lists of 1-based index pairs. The set of canonical pairs $P$ is stored in a hash set for efficient $O(1)$ lookups.\n\nSecond, for each relevant pair of alignment columns $(i,j)$ defined in the helices, we compute its CBC count. A computationally efficient method is employed:\n$1$. For a given column pair $(i,j)$, iterate through all $S$ sequences in the MSA.\n$2$. For each sequence $k$, extract the nucleotide pair $(x_k, y_k)$. If this pair belongs to the set $P$, it is retained.\n$3$. A frequency map (a multiset) is constructed for all retained canonical pairs. This map, let us call it $M$, stores each unique canonical pair type found and the number of sequences in which it occurs.\n$4. $The CBC count is calculated by iterating over all unordered pairs of distinct canonical pair types $\\{p_a, p_b\\}$ present as keys in the map $M$. Let $p_a = (x_a, y_a)$ and $p_b = (x_b, y_b)$. If the strict compensatory condition ($x_a \\ne x_b$ and $y_a \\ne y_b$) is satisfied, then these two types contribute to the CBC count. The number of CBCs formed between sequences of type $p_a$ and sequences of type $p_b$ is the product of their frequencies, $M[p_a] \\times M[p_b]$. The total CBC count for the column pair $(i,j)$ is the sum of these products over all qualifying pairs of pair types.\n\nThird, for each of the $5$ predicted helices, we calculate its total support, $\\mathrm{CBC\\_total}$, by summing the CBC counts computed in the previous step for all of its constituent column pairs.\n\nFourth, we evaluate the helices against the specified thresholds. For each threshold $t$ in the set $\\{5, 0, 1, 100\\}$, we iterate through the $5$ helices and count how many have a $\\mathrm{CBC\\_total}$ value greater than or equal to $t$.\n\nThis procedure yields a list of $4$ integer counts, corresponding to the number of validated helices for each threshold, which constitutes the final result.", "answer": "```python\nimport collections\n\n# There is no need for numpy or scipy for this problem, but the template requires this formatting.\n# import numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the rRNA helix validation problem based on Compensatory Base-pair Changes (CBCs).\n    \"\"\"\n\n    # --- Step 1: Define Givens from the problem statement ---\n\n    # Multiple Sequence Alignment (S=6, L=12)\n    msa = [\n        \"AAGGG--UCCUU\",\n        \"GGAGG-ACCUCC\",\n        \"-UUGGC-UCAA-\",\n        \"-GGGG--GCUU-\",\n        \"-CCGGAUCCGG-\",\n        \"-AGGG--UCCU-\",\n    ]\n\n    # Predicted Helices (1-based indexing)\n    helices_1_based = {\n        1: [(2, 11), (3, 10)],\n        2: [(4, 9)],\n        3: [(5, 8)],\n        4: [(6, 7)],\n        5: [(1, 12)],\n    }\n    \n    # Convert helices to 0-based indexing for programming convenience\n    helices = {\n        name: [(i - 1, j - 1) for i, j in pairs]\n        for name, pairs in helices_1_based.items()\n    }\n\n    # Canonical Base Pairs\n    canonical_pairs = {\n        ('A', 'U'), ('U', 'A'),\n        ('G', 'C'), ('C', 'G'),\n        ('G', 'U'), ('U', 'G'),\n    }\n\n    # Test cases: Threshold values\n    thresholds = [5, 0, 1, 100]\n    \n    # --- Step 2: Implement the CBC calculation logic ---\n\n    def calculate_cbc_for_pair(col_i, col_j):\n        \"\"\"\n        Calculates the CBC count for a single pair of alignment columns.\n        \"\"\"\n        # Extract pairs from the specified columns for all sequences\n        sequence_pairs = []\n        for seq in msa:\n            pair = (seq[col_i], seq[col_j])\n            if pair in canonical_pairs:\n                sequence_pairs.append(pair)\n\n        # If fewer than 2 sequences have canonical pairs, no CBC is possible.\n        if len(sequence_pairs) < 2:\n            return 0\n        \n        # Create a frequency map of the canonical pairs found\n        pair_counts = collections.Counter(sequence_pairs)\n        \n        cbc_count = 0\n        \n        # Get the unique pair types\n        unique_pair_types = list(pair_counts.keys())\n        \n        # Iterate over all unordered pairs of distinct pair types\n        for i in range(len(unique_pair_types)):\n            for j in range(i + 1, len(unique_pair_types)):\n                p_a = unique_pair_types[i]\n                p_b = unique_pair_types[j]\n                \n                x_a, y_a = p_a\n                x_b, y_b = p_b\n                \n                # Check for the strict CBC condition: x_k != x_l AND y_k != y_l\n                if x_a != x_b and y_a != y_b:\n                    # The number of CBCs between these two types is the product of their frequencies\n                    cbc_count += pair_counts[p_a] * pair_counts[p_b]\n                    \n        return cbc_count\n\n    # --- Step 3: Calculate total CBC support for each helix ---\n    \n    helix_total_cbcs = {}\n    for helix_name, column_pairs in helices.items():\n        total_cbc_for_helix = 0\n        for i, j in column_pairs:\n            total_cbc_for_helix += calculate_cbc_for_pair(i, j)\n        helix_total_cbcs[helix_name] = total_cbc_for_helix\n\n    # --- Step 4: Evaluate helices against thresholds and collect results ---\n\n    results = []\n    for t in thresholds:\n        validated_helices_count = 0\n        for helix_name in helices:\n            if helix_total_cbcs[helix_name] >= t:\n                validated_helices_count += 1\n        results.append(validated_helices_count)\n\n    # --- Final Output ---\n    # The final print statement must match the required format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\nsolve()\n```", "id": "2426467"}]}