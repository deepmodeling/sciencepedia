{"hands_on_practices": [{"introduction": "The relationship between a protein sequence and its underlying gene is not one-to-one. This exercise explores the \"back-translation problem,\" which stems from the genetic code's degeneracy—the fact that most amino acids are encoded by multiple codons. By calculating the total number of distinct DNA sequences that could produce a given peptide, you will gain a direct, quantitative appreciation for the immense combinatorial space that degeneracy opens up [@problem_id:2800939]. This is a foundational skill for fields like synthetic biology and evolutionary analysis, where understanding this sequence diversity is crucial.", "problem": "A core challenge in sequence design and annotation is the inverse-mapping from protein to nucleic acid, often called the back-translation problem. Using only fundamental tenets of the Central Dogma of Molecular Biology (Deoxyribonucleic Acid (DNA) to Ribonucleic Acid (RNA) to protein), the triplet, non-overlapping nature of the ribosomal reading frame, and the canonical standard genetic code, do the following: first, precisely define the back-translation problem; second, compute the exact size of the set of distinct coding-strand DNA sequences that can encode a specified peptide when only genetic code degeneracy is considered.\n\nAssumptions to use:\n- Translation reads contiguous, non-overlapping codons of length $3$, in a fixed reading frame from $5'$ to $3'$.\n- The standard genetic code maps $64$ codons to $20$ amino acids and $3$ stops; no recoding, no programmed frameshifts, and no alternative genetic codes occur.\n- The peptide is encoded by a single, intronless open reading frame; a terminal stop codon is not included in the count, and initiation is assumed to occur at the first codon of the peptide if it is methionine.\n- Codon choices at different positions are independent; codon usage bias, mRNA structure, regulatory motifs, and other constraints are ignored.\n- Degeneracy in the standard code is as follows: degeneracy $1$ for methionine (M) and tryptophan (W); degeneracy $2$ for phenylalanine (F), tyrosine (Y), histidine (H), glutamine (Q), asparagine (N), lysine (K), aspartate (D), glutamate (E), and cysteine (C); degeneracy $3$ for isoleucine (I); degeneracy $4$ for alanine (A), glycine (G), proline (P), threonine (T), and valine (V); degeneracy $6$ for leucine (L), arginine (R), and serine (S).\n\nTasks:\n1. Define the back-translation problem in precise terms grounded in the above assumptions.\n2. For the peptide sequence of length $20$, $\\text{MWSRLIYNQKDGTACFPVEH}$, compute the exact number of distinct $5' \\to 3'$ coding-strand DNA sequences (of length $3 \\times 20$ nucleotides, excluding any stop codon) that can encode it under the standard genetic code degeneracy given above. Provide your final answer as an exact integer with no rounding.", "solution": "The problem as stated is scientifically grounded, well-posed, and contains sufficient information for a unique and meaningful solution. It is therefore deemed valid. The solution is presented in two parts as requested.\n\nPart 1: Definition of the Back-Translation Problem\n\nThe Central Dogma of Molecular Biology describes the flow of genetic information from Deoxyribonucleic Acid (DNA) to Ribonucleic Acid (RNA) to protein. The process of translation converts a sequence of messenger RNA (mRNA) into a peptide sequence. This conversion is governed by the genetic code, which maps codons (nucleotide triplets) to amino acids.\n\nLet $\\mathcal{A}$ be the set of $20$ standard amino acids and $\\mathcal{C}$ be the set of $4^3 = 64$ possible codons. The genetic code is a function $g: \\mathcal{C} \\to \\mathcal{A} \\cup \\{\\text{Stop}\\}$, where $\\{\\text{Stop}\\}$ represents the set of three termination signals. This function is not injective; multiple codons can map to the same amino acid. This property is known as the degeneracy of the genetic code.\n\nFor any given amino acid $a \\in \\mathcal{A}$, we can define the set of codons that encode it as $C_a = \\{c \\in \\mathcal{C} \\mid g(c) = a\\}$. The size of this set, $D(a) = |C_a|$, is the degeneracy of amino acid $a$.\n\nThe back-translation problem is the inverse of translation. It seeks to determine the set of all possible nucleic acid sequences that could encode a given peptide sequence.\n\nFormally, given a peptide $P$ of length $n$, represented as a sequence of amino acids $P = p_1 p_2 \\dots p_n$ where each $p_i \\in \\mathcal{A}$, the back-translation problem is to find the set $S_{P}$ of all possible coding-strand DNA sequences (or their corresponding mRNA sequences) that encode $P$.\n\nUnder the assumption that codon choices for each amino acid position are independent, the total set of possible mRNA sequences is the Cartesian product of the codon sets for each amino acid in the peptide:\n$$ S_{mRNA} = C_{p_1} \\times C_{p_2} \\times \\dots \\times C_{p_n} $$\nThe total number of such unique mRNA sequences, $N_{mRNA}$, is the product of the degeneracies of the individual amino acids:\n$$ N_{mRNA} = |S_{mRNA}| = \\prod_{i=1}^{n} |C_{p_i}| = \\prod_{i=1}^{n} D(p_i) $$\nSince the transcription from the coding strand of DNA to mRNA is a one-to-one mapping (where thymine, T, is replaced by uracil, U), the number of distinct coding-strand DNA sequences, $N_{DNA}$, that encode the peptide $P$ is equal to the number of mRNA sequences. Therefore, $N_{DNA} = N_{mRNA}$. The problem is thus reduced to a combinatorial calculation based on the known degeneracies of the standard genetic code.\n\nPart 2: Computation for the Peptide $\\text{MWSRLIYNQKDGTACFPVEH}$\n\nThe specified peptide is $P = \\text{MWSRLIYNQKDGTACFPVEH}$, with a length of $n=20$ amino acids. The problem requires the calculation of the total number of distinct $5' \\to 3'$ coding-strand DNA sequences that can encode this peptide, excluding any stop codon.\n\nWe proceed by determining the degeneracy for each amino acid in the sequence, using the provided data:\n- $D(\\text{M, Met}) = 1$\n- $D(\\text{W, Trp}) = 1$\n- $D(\\text{S, Ser}) = 6$\n- $D(\\text{R, Arg}) = 6$\n- $D(\\text{L, Leu}) = 6$\n- $D(\\text{I, Ile}) = 3$\n- $D(\\text{Y, Tyr}) = 2$\n- $D(\\text{N, Asn}) = 2$\n- $D(\\text{Q, Gln}) = 2$\n- $D(\\text{K, Lys}) = 2$\n- $D(\\text{D, Asp}) = 2$\n- $D(\\text{G, Gly}) = 4$\n- $D(\\text{T, Thr}) = 4$\n- $D(\\text{A, Ala}) = 4$\n- $D(\\text{C, Cys}) = 2$\n- $D(\\text{F, Phe}) = 2$\n- $D(\\text{P, Pro}) = 4$\n- $D(\\text{V, Val}) = 4$\n- $D(\\text{E, Glu}) = 2$\n- $D(\\text{H, His}) = 2$\n\nThe total number of sequences, $N$, is the product of these degeneracy values:\n$$ N = D(\\text{M}) \\times D(\\text{W}) \\times D(\\text{S}) \\times D(\\text{R}) \\times D(\\text{L}) \\times D(\\text{I}) \\times D(\\text{Y}) \\times D(\\text{N}) \\times D(\\text{Q}) \\times D(\\text{K}) \\times D(\\text{D}) \\times D(\\text{G}) \\times D(\\text{T}) \\times D(\\text{A}) \\times D(\\text{C}) \\times D(\\text{F}) \\times D(\\text{P}) \\times D(\\text{V}) \\times D(\\text{E}) \\times D(\\text{H}) $$\nTo simplify calculation, we group the terms by their degeneracy values. We count the occurrences of each amino acid type in the peptide:\n- Degeneracy $1$: M, W ($2$ occurrences)\n- Degeneracy $2$: Y, N, Q, K, D, C, F, E, H ($9$ occurrences)\n- Degeneracy $3$: I ($1$ occurrence)\n- Degeneracy $4$: G, T, A, P, V ($5$ occurrences)\n- Degeneracy $6$: S, R, L ($3$ occurrences)\n\nThe total number of sequences is the product of these degeneracies raised to the power of their frequencies:\n$$ N = (1^2) \\times (2^9) \\times (3^1) \\times (4^5) \\times (6^3) $$\nWe can simplify this expression using prime factorization:\n$$ N = 1 \\times 2^9 \\times 3^1 \\times (2^2)^5 \\times (2 \\times 3)^3 $$\n$$ N = 2^9 \\times 3^1 \\times 2^{10} \\times 2^3 \\times 3^3 $$\nCombining the powers of the prime bases:\n$$ N = 2^{(9+10+3)} \\times 3^{(1+3)} $$\n$$ N = 2^{22} \\times 3^4 $$\nNow, we compute the final integer value:\n$2^{10} = 1024$\n$2^{20} = (2^{10})^2 = 1024^2 = 1048576$\n$2^{22} = 2^{20} \\times 2^2 = 1048576 \\times 4 = 4194304$\n$3^4 = 81$\nFinally, we compute the product:\n$$ N = 4194304 \\times 81 = 339738624 $$\nThis is the exact number of distinct coding-strand DNA sequences that can encode the specified peptide.", "answer": "$$\n\\boxed{339738624}\n$$", "id": "2800939"}, {"introduction": "Degeneracy is not merely a redundancy; it serves a vital biological function by providing a buffer against mutations. Many single-nucleotide changes in a gene are \"silent\" or \"synonymous\" because they result in a codon that still codes for the same amino acid, thus preserving the protein's function. This practice challenges you to think probabilistically about this error-tolerance, asking you to derive a general formula for the likelihood that a random mutation causes an amino acid change, based on that amino acid's level of degeneracy, $N$ [@problem_id:2384867].", "problem": "In a simplified model of messenger Ribonucleic Acid (mRNA) translation, a codon is a sequence of length $3$ over an alphabet of $4$ nucleotides, yielding $64$ possible codons. Consider an amino acid that is encoded by exactly $N$ distinct codons (degeneracy $N$). A single random point mutation is defined as choosing one of the $3$ codon positions uniformly at random and replacing its nucleotide by one of the other $3$ nucleotides uniformly at random; equivalently, each of the $9$ possible single-nucleotide mutant codons is equally likely.\n\nDefine the following averaging protocol. First, choose a codon uniformly at random from the $N$ codons encoding the amino acid. Second, apply the random point mutation as defined above. Third, classify the outcome as a “switch to a different amino acid” if and only if the resulting codon is not among the original $N$ codons (any non-synonymous sense or stop meaning counts as “different”). To avoid dependence on the specific arrangement of synonymous codons in codon space, assume a mean-field assignment: conditional on the chosen codon being one of the $N$ synonymous codons, the remaining $N-1$ synonymous codons are equally likely to be any subset of size $N-1$ drawn uniformly from the other $63$ codons.\n\nUnder this model, compute the expected probability that a single random point mutation to a codon encoding this amino acid produces a codon that encodes a different amino acid. Give your answer as a closed-form expression in terms of $N$. Do not round your answer.", "solution": "The problem statement is subjected to validation.\n\nStep 1: Extracted Givens\n- A codon is a sequence of length $3$ over an alphabet of $4$ nucleotides.\n- Total possible codons: $4^3 = 64$.\n- An amino acid is encoded by exactly $N$ distinct codons.\n- A single random point mutation is defined as choosing one of $3$ codon positions uniformly at random and replacing its nucleotide with one of the other $3$ nucleotides uniformly at random.\n- This is equivalent to stating that each of the $9$ possible single-nucleotide mutant codons is equally likely.\n- Averaging protocol:\n  1. Choose a codon uniformly at random from the $N$ codons encoding the amino acid.\n  2. Apply the random point mutation.\n  3. The outcome is a \"switch to a different amino acid\" if the resulting codon is not among the original $N$ codons.\n- Mean-field assumption: Conditional on the chosen codon being one of the $N$ synonymous codons, the remaining $N-1$ synonymous codons are a uniformly random subset of size $N-1$ from the other $63$ codons.\n\nStep 2: Validation\nThe problem is a well-defined mathematical modeling exercise in computational biology. It is scientifically grounded in the concepts of the genetic code, codons, mutations, and degeneracy, even though it employs a simplified \"mean-field\" model. Such models are standard tools in theoretical sciences to make complex combinatorial problems tractable. The problem is objective, self-contained, and logically consistent. There are no violations of scientific principles, no ambiguities, and it is formally solvable.\n\nStep 3: Verdict\nThe problem is valid. A complete solution will be provided.\n\nThe problem asks for the expected probability that a random point mutation in a codon for a specific amino acid results in a codon that does not code for the same amino acid. This is the probability of a non-synonymous mutation, averaged over the choices specified in the protocol.\n\nLet $\\Omega$ be the set of all $64$ possible codons. Let $S \\subset \\Omega$ be the set of $N$ codons that encode the amino acid in question, so $|S| = N$.\n\nThe mutation process is defined as follows: for any codon $C$, there is a set of $9$ possible single-nucleotide mutant codons, which we denote as $M(C)$. Any mutation transforms $C$ into a codon $C' \\in M(C)$ with a uniform probability of $1/9$.\n\nThe averaging protocol requires us to first select a codon, let's call it $C_0$, uniformly at random from the set $S$. Then, we must calculate the probability of a switch, which means the resulting mutant codon, $C_1$, is not in $S$. This probability is then to be averaged under the mean-field assumption.\n\nLet's fix a starting codon $C_0 \\in S$. A mutation results in a codon $C_1 \\in M(C_0)$. A switch occurs if $C_1 \\notin S$. The probability of this event, given $C_0$ and the set $S$, is:\n$$ P(\\text{switch} | C_0, S) = P(C_1 \\notin S) = \\frac{|\\{C' \\in M(C_0) \\mid C' \\notin S\\}|}{9} $$\nNote that $C_0 \\notin M(C_0)$. We can express the number of non-switching outcomes in terms of the intersection of the set of mutants $M(C_0)$ and the set of synonymous codons $S$. A non-switch (synonymous mutation) occurs if $C_1 \\in S$. The number of such outcomes is $|M(C_0) \\cap S|$. The probability of a switch is therefore:\n$$ P(\\text{switch} | C_0, S) = \\frac{9 - |M(C_0) \\cap S|}{9} = 1 - \\frac{|M(C_0) \\cap S|}{9} $$\nThe problem's mean-field assumption provides a way to average this quantity without knowing the specific arrangement of codons in $S$. The assumption states: \"conditional on the chosen codon being one of the $N$ synonymous codons [we chose $C_0$], the remaining $N-1$ synonymous codons are equally likely to be any subset of size $N-1$ drawn uniformly from the other $63$ codons.\"\n\nLet $S' = S \\setminus \\{C_0\\}$, so $|S'| = N-1$. The set $S'$ is chosen uniformly at random from all subsets of size $N-1$ of the set $\\Omega \\setminus \\{C_0\\}$, which has size $63$.\nThe set of neighbors of $C_0$ is $M(C_0)$, which is a subset of $\\Omega \\setminus \\{C_0\\}$ of size $9$.\nThe term $|M(C_0) \\cap S|$ in our probability expression is $|M(C_0) \\cap (S' \\cup \\{C_0\\})|$. Since $C_0 \\notin M(C_0)$, this simplifies to $|M(C_0) \\cap S'|$.\n\nWe must now compute the expectation of $P(\\text{switch} | C_0, S)$ over the random choice of the set $S'$. Let $P_{avg}$ be the desired expected probability.\n$$ P_{avg} = E_{S'} \\left[ 1 - \\frac{|M(C_0) \\cap S'|}{9} \\right] $$\nUsing the linearity of expectation:\n$$ P_{avg} = 1 - \\frac{E[|M(C_0) \\cap S'|]}{9} $$\nThe term $E[|M(C_0) \\cap S'|]$ is the expected number of elements in the intersection of a fixed set $M(C_0)$ of size $9$ and a randomly chosen set $S'$ of size $N-1$. The random set $S'$ is drawn from a population of size $63$.\nThis is a classic problem of sampling without replacement, and the number of \"successes\" (elements from $M(C_0)$) in our sample $S'$ follows a hypergeometric distribution. The expectation is given by the sample size multiplied by the proportion of successes in the population.\n\n- Population size: $|\\Omega \\setminus \\{C_0\\}| = 63$.\n- Number of successes in population: $|M(C_0)| = 9$.\n- Sample size: $|S'| = N-1$.\n\nThe expected number of successes is:\n$$ E[|M(C_0) \\cap S'|] = (N-1) \\times \\frac{9}{63} = \\frac{N-1}{7} $$\nThis expected value is independent of the specific choice of $C_0$. Therefore, the first step of the protocol, choosing $C_0$ uniformly from $S$, does not alter the result; the expected probability is the same for any choice of $C_0$.\n\nSubstituting this expected value back into our expression for $P_{avg}$:\n$$ P_{avg} = 1 - \\frac{\\frac{N-1}{7}}{9} = 1 - \\frac{N-1}{63} $$\nThis expression can be simplified by combining the terms:\n$$ P_{avg} = \\frac{63}{63} - \\frac{N-1}{63} = \\frac{63 - (N-1)}{63} = \\frac{63 - N + 1}{63} = \\frac{64 - N}{63} $$\nThis is the required closed-form expression for the expected probability of a switch.", "answer": "$$\\boxed{\\frac{64-N}{63}}$$", "id": "2384867"}, {"introduction": "Beyond providing robustness, the flexibility afforded by degeneracy can be exploited for sophisticated biological engineering and elegant evolutionary solutions, such as overlapping genes. This advanced practice invites you to solve a fascinating bioinformatics puzzle: constructing a single DNA strand that encodes two entirely different proteins—one on the forward strand and another on the reverse-complement strand. Successfully solving this problem [@problem_id:2384918] requires applying your understanding of degeneracy, codon tables, and Watson-Crick pairing to develop an algorithm that navigates these complex, layered constraints.", "problem": "You are asked to write a complete, runnable program that, given two amino acid sequences of equal length, constructs a deoxyribonucleic acid (DNA) sequence over the alphabet $\\Sigma = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ such that reading the DNA as codons in the $5^{\\prime} \\rightarrow 3^{\\prime}$ direction on the forward strand yields the first protein, and reading the reverse-complement strand in the $5^{\\prime} \\rightarrow 3^{\\prime}$ direction yields the second, different protein. This construction must exploit the degeneracy of the genetic code. If such a DNA sequence does not exist under the constraints below, your program must indicate impossibility for that test case.\n\nFundamental bases and constraints to use:\n- The Central Dogma of Molecular Biology states that information flows from DNA to ribonucleic acid (RNA) to protein. Translation maps each codon (a triplet of nucleotides) to one amino acid; the standard nuclear genetic code is a well-tested mapping from codons to amino acids.\n- Watson–Crick base pairing defines the complement function on nucleotides: $\\text{A}\\leftrightarrow \\text{T}$ and $\\text{C}\\leftrightarrow \\text{G}$. The reverse complement of a DNA string is obtained by reversing the string and replacing each nucleotide by its complement.\n- Let $\\mathcal{A}$ denote the set of $20$ standard amino acids, each represented by its standard one-letter code (e.g., $\\text{A}$ for Alanine, $\\text{R}$ for Arginine, …, $\\text{W}$ for Tryptophan, $\\text{Y}$ for Tyrosine, $\\text{M}$ for Methionine, etc.). Stop codons are not part of $\\mathcal{A}$ and must not appear inside the coding sequence.\n- Let $g : \\Sigma^3 \\rightarrow \\mathcal{A}\\cup\\{\\text{Stop}\\}$ be the standard nuclear genetic code mapping from codons to amino acids (or Stop). Use the Standard Genetic Code (also known as NCBI Translation Table $1$), in which the three Stop codons are $\\text{TAA}$, $\\text{TAG}$, and $\\text{TGA}$.\n- Let $\\mathrm{RC} : \\Sigma^3 \\rightarrow \\Sigma^3$ denote the reverse-complement operator on codons, defined by reversing the codon and complementing each nucleotide according to Watson–Crick pairing.\n\nFormal problem:\n- You are given two amino acid sequences $S_f$ and $S_r$ of equal length $L \\geq 1$, where $S_f[i] \\in \\mathcal{A}$ and $S_r[i] \\in \\mathcal{A}$ for all indices $i \\in \\{0,1,\\dots,L-1\\}$.\n- You must determine a DNA sequence $D \\in \\Sigma^{3L}$, partitioned as contiguous codons $(c_0,c_1,\\dots,c_{L-1})$ with $c_i \\in \\Sigma^3$, such that:\n  1. $g(c_i) = S_f[i]$ for all $i \\in \\{0,1,\\dots,L-1\\}$, and\n  2. $g(\\mathrm{RC}(c_i)) = S_r[L-1-i]$ for all $i \\in \\{0,1,\\dots,L-1\\}$.\n- If there exists more than one valid $D$, you must choose the unique $D$ obtained by, for each position $i$, selecting the lexicographically smallest codon $c_i$ (with lexicographic order defined on $\\Sigma$ by $\\text{A} < \\text{C} < \\text{G} < \\text{T}$ and extended to $\\Sigma^3$ in the standard way). This per-position choice yields a unique deterministic $D$ if a solution exists.\n- If no such $D$ exists, you must output an explicit empty result for that test case as specified below.\n- If the two given sequences have different lengths, no solution exists by definition.\n\nOutput encoding:\n- For each test case, you must output the entire DNA sequence $D$ as a list of integers by encoding nucleotides with the mapping $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$ and listing the $3L$ integers in order. If no solution exists, output the empty list $[\\ ]$ for that test case.\n- Your program must produce a single line of output containing the results for all test cases aggregated as a list of lists, with no spaces, for example $[[0,1,2],[\\ ],[2,2,3]]$.\n\nTest suite:\nYour program must hard-code and solve exactly the following test cases. Each test case is a pair $(S_f,S_r)$:\n- Case $1$ (happy path): $S_f=\\text{\"MALG\"}$, $S_r=\\text{\"TQGH\"}$.\n- Case $2$ (impossible single-codon): $S_f=\\text{\"W\"}$, $S_r=\\text{\"A\"}$.\n- Case $3$ (single-codon feasible): $S_f=\\text{\"M\"}$, $S_r=\\text{\"H\"}$.\n- Case $4$ (length mismatch): $S_f=\\text{\"ACD\"}$, $S_r=\\text{\"GG\"}$.\n- Case $5$ (odd length feasible): $S_f=\\text{\"AKR\"}$, $S_r=\\text{\"TFS\"}$.\n\nFinal output format:\n- Your program must print a single line containing a list with $5$ elements, one per test case, where each element is either an empty list $[\\ ]$ for impossible or a list of $3L$ integers representing the DNA sequence using the nucleotide-to-integer encoding $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$. There must be no spaces anywhere in the printed line.", "solution": "We derive a constructive algorithm from first principles using the Central Dogma and Watson–Crick complementarity, formalized in terms of codon mapping and reverse complement operations.\n\nDefinitions:\n- Let $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ and $\\mathcal{A}$ be the set of $20$ standard amino acids.\n- Let $g:\\Sigma^3\\to \\mathcal{A}\\cup\\{\\text{Stop}\\}$ be the standard genetic code mapping, with Stop codons $\\text{TAA}$, $\\text{TAG}$, $\\text{TGA}$.\n- Let $\\mathrm{comp}:\\Sigma\\to\\Sigma$ be $\\mathrm{comp}(\\text{A})=\\text{T}$, $\\mathrm{comp}(\\text{T})=\\text{A}$, $\\mathrm{comp}(\\text{C})=\\text{G}$, $\\mathrm{comp}(\\text{G})=\\text{C}$, extended to strings by character-wise application.\n- Let $\\mathrm{RC}:\\Sigma^k\\to \\Sigma^k$ be the reverse complement, defined by $\\mathrm{RC}(x_0x_1\\cdots x_{k-1})=\\mathrm{comp}(x_{k-1})\\cdots \\mathrm{comp}(x_1)\\mathrm{comp}(x_0)$. It is a fundamental property that for any strings $x,y$ over $\\Sigma$, $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$.\n\nWe are given two amino acid sequences $S_f$ and $S_r$ of equal length $L$ (if lengths differ, no solution exists). We seek a DNA sequence $D=c_0c_1\\cdots c_{L-1}$ with $c_i\\in\\Sigma^3$ such that:\n- $g(c_i)=S_f[i]$ for all indices $i\\in\\{0,\\dots,L-1\\}$.\n- Reading the reverse-complement strand in frame $0$ gives $S_r$. Because of the property $\\mathrm{RC}(xy)=\\mathrm{RC}(y)\\mathrm{RC}(x)$, the reverse complement of the concatenation of codons is the concatenation, in reverse order, of the reverse complements of each codon. Therefore, if we define $d_i=\\mathrm{RC}(c_i)$, the reverse-complement strand codon at position $j$ (counting from $0$ at the $5^{\\prime}$ end) is $d_{L-1-j}$. For the reverse strand to translate to $S_r$, we must have $g(d_{L-1-j})=S_r[j]$ for all $j$, equivalently $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$ for all $i$.\n\nCrucially, this decomposition shows independence across positions: each forward codon $c_i$ affects only the corresponding reversed position on the reverse strand, and there are no cross-codon constraints when both strands are read in frame $0$. Hence the global constraint reduces to $L$ independent local constraints. For each $i\\in\\{0,\\dots,L-1\\}$ we must choose $c_i\\in\\Sigma^3$ satisfying the pairwise condition $g(c_i)=S_f[i]$ and $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$. If any position $i$ has no such $c_i$, then no solution exists; otherwise any choice per position yields a valid global solution because $\\mathrm{RC}$ distributes over concatenation as described.\n\nTo exploit degeneracy, we compute the set of synonymous codons for any amino acid $a\\in\\mathcal{A}$:\n$$\n\\mathrm{Codons}(a)=\\{c\\in\\Sigma^3 \\mid g(c)=a\\}.\n$$\nFor each position $i$, we form the set of feasible forward codons\n$$\n\\mathcal{C}_i=\\{c\\in \\mathrm{Codons}(S_f[i]) \\mid \\mathrm{RC}(c)\\in \\mathrm{Codons}(S_r[L-1-i])\\}.\n$$\nIf $\\mathcal{C}_i=\\varnothing$ for any $i$, return impossibility. Otherwise, for determinism we apply the lexicographic tie-break rule. Define an order on $\\Sigma$ by $\\text{A}<\\text{C}<\\text{G}<\\text{T}$, and extend it to $\\Sigma^3$ by standard lexicographic comparison. Select\n$$\nc_i=\\min\\nolimits_{\\text{lex}} \\mathcal{C}_i.\n$$\nConcatenating these $c_i$ yields the unique deterministic solution $D=c_0c_1\\cdots c_{L-1}$.\n\nCorrectness argument:\n- Soundness: By construction, $g(c_i)=S_f[i]$ and $g(\\mathrm{RC}(c_i))=S_r[L-1-i]$ for all $i$. Therefore, $D$ translates to $S_f$ on the forward strand and $\\mathrm{RC}(D)$ translates to $S_r$ on the reverse strand in frame $0$.\n- Completeness: If there exists any $D^{\\star}$ satisfying the constraints, then for each $i$ its codon $c_i^{\\star}$ must be in $\\mathcal{C}_i$. Hence $\\mathcal{C}_i\\neq\\varnothing$ for all $i$. Our algorithm selects some $c_i\\in\\mathcal{C}_i$ and thus constructs a valid $D$. Determinism follows from the lexicographic minimization per position.\n\nComplexity:\n- Preprocessing constructs $\\mathrm{Codons}(a)$ for all $a\\in\\mathcal{A}$ in $O(1)$ time with constant table size.\n- For each test case, for each position $i$ we scan at most $6$ codons for highly degenerate amino acids (e.g., Leucine, Serine, Arginine). Therefore time is $O(L)$ with a small constant, and space is $O(L)$ to store the result.\n\nOutput encoding:\n- Map nucleotides by $\\text{A}\\mapsto 0$, $\\text{C}\\mapsto 1$, $\\text{G}\\mapsto 2$, $\\text{T}\\mapsto 3$. Encode $D$ as a list of $3L$ integers in order. If no solution, output the empty list. Aggregate outputs for the $5$ required test cases into a single bracketed list with no spaces.\n\nApplication to the test suite:\n- Case $1$ with $S_f=\\text{\"MALG\"}$, $S_r=\\text{\"TQGH\"}$ is feasible; one valid deterministic $D$ is obtained by the per-position lexicographic choice.\n- Case $2$ with $S_f=\\text{\"W\"}$, $S_r=\\text{\"A\"}$ is impossible because the only Tryptophan codon $\\text{TGG}$ reverse-complements to $\\text{CCA}$ (Proline), which does not encode Alanine.\n- Case $3$ with $S_f=\\text{\"M\"}$, $S_r=\\text{\"H\"}$ is feasible because $\\text{ATG}$ reverse-complements to $\\text{CAT}$ (Histidine).\n- Case $4$ has mismatched lengths and is immediately impossible.\n- Case $5$ with $S_f=\\text{\"AKR\"}$, $S_r=\\text{\"TFS\"}$ is feasible via appropriate codon choices, uniquely determined by lexicographic minimization under the constraints.\n\nThe accompanying program implements this algorithm, includes the Standard Genetic Code, constructs the feasible codon sets, enforces the lexicographic rule, converts the result to the specified integer encoding, and prints the outputs for the five test cases as a single line with no spaces.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Mapping for nucleotide complements (Watson–Crick base pairing)\nCOMP = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n\n# Standard Genetic Code (NCBI Translation Table 1): DNA codons to amino acids (one-letter code)\nCODON_TO_AA = {\n    # Phenylalanine, Leucine\n    'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n    # Serine, Proline, Threonine, Alanine\n    'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n    'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n    'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n    'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n    # Tyrosine, Histidine, Glutamine, Asparagine, Lysine, Aspartic acid, Glutamic acid, Cysteine, Tryptophan\n    'TAT': 'Y', 'TAC': 'Y', 'TAA': 'Stop', 'TAG': 'Stop',\n    'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n    'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n    'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n    'TGT': 'C', 'TGC': 'C', 'TGA': 'Stop', 'TGG': 'W',\n    # Leucine, Arginine, Isoleucine, Methionine, Valine, Serine, Arginine, Glycine\n    'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n    'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n    'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n    'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n    'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n    'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n}\n\n# Build amino acid to codons mapping (excluding Stops)\nAA_TO_CODONS = {}\nfor codon, aa in CODON_TO_AA.items():\n    if aa == 'Stop':\n        continue\n    AA_TO_CODONS.setdefault(aa, []).append(codon)\n\n# Define nucleotide order for lexicographic sorting: A < C < G < T\nNUC_ORDER = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\ndef lex_key(codon: str):\n    return (NUC_ORDER[codon[0]], NUC_ORDER[codon[1]], NUC_ORDER[codon[2]])\n\n# Sort codon lists for deterministic lexicographic selection\nfor aa in AA_TO_CODONS:\n    AA_TO_CODONS[aa].sort(key=lex_key)\n\ndef reverse_complement(codon: str) -> str:\n    # Reverse the codon and complement each nucleotide\n    return ''.join(COMP[n] for n in reversed(codon))\n\ndef dna_to_ints(dna: str):\n    # Map nucleotides to integers A->0, C->1, G->2, T->3\n    mapping = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    return [mapping[n] for n in dna]\n\ndef find_dual_encoding_dna(Sf: str, Sr: str):\n    # If lengths differ, impossible\n    if len(Sf) != len(Sr):\n        return []\n    L = len(Sf)\n    codons_forward = []\n\n    for i in range(L):\n        a_f = Sf[i]\n        a_r = Sr[L - 1 - i]\n        # Validate amino acids\n        if a_f not in AA_TO_CODONS or a_r not in AA_TO_CODONS:\n            return []\n        feasible = None\n        for codon in AA_TO_CODONS[a_f]:\n            rc = reverse_complement(codon)\n            # Ensure reverse complement codon encodes the required reverse amino acid\n            if rc in AA_TO_CODONS[a_r]:\n                feasible = codon\n                break  # lexicographically smallest due to prior sorting\n        if feasible is None:\n            return []\n        codons_forward.append(feasible)\n\n    dna = ''.join(codons_forward)\n    return dna_to_ints(dna)\n\ndef format_result_list(list_of_lists):\n    # Format as a single-line string with no spaces, nested lists\n    def format_one(lst):\n        return '[' + ','.join(str(x) for x in lst) + ']'\n    return '[' + ','.join(format_one(lst) for lst in list_of_lists) + ']'\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"MALG\", \"TQGH\"),  # Case 1\n        (\"W\", \"A\"),        # Case 2\n        (\"M\", \"H\"),        # Case 3\n        (\"ACD\", \"GG\"),     # Case 4\n        (\"AKR\", \"TFS\"),    # Case 5\n    ]\n\n    results = []\n    for Sf, Sr in test_cases:\n        res = find_dual_encoding_dna(Sf, Sr)\n        results.append(res)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    print(format_result_list(results))\n\nsolve()\n```", "id": "2384918"}]}