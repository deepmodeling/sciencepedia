{"hands_on_practices": [{"introduction": "The CIGAR string is a cornerstone of the SAM/BAM format, offering a compact language to describe how a read aligns to a reference genome. Each operation in the string, such as $M$ (match/mismatch), $I$ (insertion), or $D$ (deletion), has a specific meaning regarding which sequence—the read or the reference—it consumes. This first practice challenges you to apply these definitions to determine the length of a read sequence from its CIGAR string, a key skill for parsing and quality-controlling alignment data [@problem_id:2370597].", "problem": "In the Sequence Alignment/Map (SAM) format and its binary equivalent, Binary Alignment/Map (BAM), each alignment includes a Compact Idiosyncratic Gapped Alignment Report (CIGAR) string that encodes the lengths and types of alignment operations. Consider the CIGAR string $15\\text{M}5\\text{I}10\\text{M}5\\text{D}15\\text{M}$. An $M$ operation denotes an alignment match-or-mismatch and consumes nucleotides from both the read and the reference; an $I$ operation denotes an insertion with respect to the reference and consumes nucleotides from the read only; a $D$ operation denotes a deletion from the read with respect to the reference and consumes nucleotides from the reference only. The integer preceding each operation gives the count of nucleotides to which the operation applies. Assume no soft clipping ($S$) or hard clipping ($H$) operations are present.\n\nWhat is the minimal possible length, in nucleotides, of a DNA read (query) sequence that could produce this CIGAR string when aligned to some reference? Express your answer as an integer.", "solution": "The problem requires the determination of the length of a DNA read, or query sequence, from its given CIGAR string. The CIGAR string, an acronym for Compact Idiosyncratic Gapped Alignment Report, provides a concise representation of an alignment. The total length of the query sequence is found by summing the lengths of all CIGAR operations that consume bases from the query itself.\n\nThe problem provides definitions for three types of operations:\n- Operation $M$ (alignment match-or-mismatch) consumes bases from both the query and the reference sequence.\n- Operation $I$ (insertion with respect to the reference) consumes bases from the query sequence only.\n- Operation $D$ (deletion from the query with respect to the reference) consumes bases from the reference sequence only.\n\nThe problem statement explicitly rules out the presence of clipping operations ($S$ and $H$). This is a critical simplification, as it means the length of the sequence described by the CIGAR string is unambiguous. The phrase \"minimal possible length\" is therefore equivalent to the single, determined length of the sequence segment participating in the alignment.\n\nThe CIGAR string provided is $15\\text{M}5\\text{I}10\\text{M}5\\text{D}15\\text{M}$. Let $L_{\\text{read}}$ be the length of the read sequence in nucleotides. We must calculate $L_{\\text{read}}$ by dissecting the CIGAR string and summing the contributions of each component that consumes the read.\n\nThe contributions are as follows:\n- The component $15\\text{M}$ corresponds to $15$ bases consumed from the read.\n- The component $5\\text{I}$ corresponds to $5$ bases consumed from the read.\n- The component $10\\text{M}$ corresponds to $10$ bases consumed from the read.\n- The component $5\\text{D}$ corresponds to a deletion from the read. It consumes bases from the reference, thus it contributes $0$ bases to the read's length.\n- The component $15\\text{M}$ corresponds to $15$ bases consumed from the read.\n\nTo find the total length $L_{\\text{read}}$, we sum these values:\n$$L_{\\text{read}} = 15 + 5 + 10 + 0 + 15$$\nPerforming the summation:\n$$L_{\\text{read}} = 20 + 10 + 15$$\n$$L_{\\text{read}} = 30 + 15$$\n$$L_{\\text{read}} = 45$$\nThus, the length of the DNA read that produces the given CIGAR string is $45$ nucleotides.", "answer": "$$\\boxed{45}$$", "id": "2370597"}, {"introduction": "Beyond the alignment's structure, the SAM bitwise FLAG provides a rich summary of an alignment's properties, from pairing status to strand orientation. This is a simple integer, but it tells a complex story. This exercise is a thought experiment designed to test your understanding of the FLAG's profound impact on biological interpretation. By analyzing how a single bit-flip can transform a 'normal' alignment into a signature for a major genomic rearrangement, you will gain a deeper appreciation for why precision in bioinformatics is paramount [@problem_id:2370643].", "problem": "A paired-end whole-genome sequencing dataset was aligned with a standard inward-facing library configuration, where a properly paired fragment has read $1$ mapping to the forward strand and read $2$ mapping to the reverse strand on the reference genome (often described as an \"FR\" library). The aligner outputs Sequence Alignment/Map (SAM) flags, and the Binary Alignment/Map (BAM) format encodes the same flags. The SAM flag is a bitwise-encoded integer: each property is represented by a bit with a fixed value, and the total flag is the sum of the values of all bits that apply. Consider the following core definitions used by most aligners and downstream tools:\n- Bit value $1$: template is paired.\n- Bit value $2$: each segment in the template is properly aligned according to the aligner.\n- Bit value $4$: this segment (read) is unmapped.\n- Bit value $8$: the mate is unmapped.\n- Bit value $16$: this segment is mapped to the reverse complement strand.\n- Bit value $32$: the mate is mapped to the reverse complement strand.\n- Bit value $64$: this is the first segment (read $1$) in the template.\n- Bit value $128$: this is the second segment (read $2$) in the template.\n\nYou examine a read pair whose SAM flags are $99$ for read $1$ and $147$ for read $2$. The mapping coordinates and insert size are typical of a proper pair. Now suppose a single-bit error flips the state of the bit indicating \"this segment is reverse complemented\" for read $1$ while leaving all other bits and the alignment coordinates unchanged.\n\nWhich of the following best captures the most consequential change in biological interpretation that could result from this one-bit flip in read $1$'s flag?\n\nA. The pair would likely be reinterpreted as a discordant \"inversion-like\" orientation (both reads on the reverse strand) and could produce a false positive structural variant signal near this locus.\n\nB. The pair would still be considered a proper pair for all downstream tools because mapping positions and insert size are unchanged; orientation bits are ignored in practice.\n\nC. The change would only affect duplicate marking without influencing biological interpretation, since duplicate marking relies solely on mapping start positions and the CIGAR string.\n\nD. The read would be treated as unmapped and removed from analysis, eliminating any possibility of biological misinterpretation from this pair.", "solution": "The problem statement must first be validated for scientific soundness, clarity, and completeness.\n\nStep 1: Extract Givens\n- **Sequencing Library:** Paired-end, standard inward-facing configuration ($\\text{FR}$ type: read $1$ on the forward strand, read $2$ on the reverse strand defines a proper pair).\n- **SAM/BAM Flag Definitions (Bitwise):**\n    - $1$: template is paired.\n    - $2$: each segment in the template is properly aligned.\n    - $4$: this segment (read) is unmapped.\n    - $8$: the mate is unmapped.\n    - $16$: this segment is mapped to the reverse complement strand.\n    - $32$: the mate is mapped to the reverse complement strand.\n    - $64$: this is the first segment (read $1$).\n    - $128$: this is the second segment (read $2$).\n- **Initial State:**\n    - Read $1$ SAM flag: $99$.\n    - Read $2$ SAM flag: $147$.\n    - Mapping coordinates and insert size are typical of a proper pair.\n- **Perturbation:**\n    - A single-bit error flips the state of the bit indicating \"this segment is reverse complemented\" (bit value $16$) for read $1$.\n    - All other bits and alignment coordinates remain unchanged.\n\nStep 2: Validate Using Extracted Givens\nThe problem describes a scenario within the domain of computational biology, specifically relating to the Sequence Alignment/Map (SAM) and Binary Alignment/Map (BAM) formats, which are standard in genomics.\n\n- **Scientifically Grounded:** The definitions of the SAM flags are correct and follow the official specification. The concept of library configurations ($\\text{FR}$), proper pairs, and discordant pairs representing structural variants is fundamental to sequence alignment analysis. The scenario is scientifically plausible.\n- **Well-Posed:** The problem provides a clear initial state (flags $99$ and $147$), a precise modification (a specific bit flip), and asks for the most significant consequence. All necessary information is provided to deduce the new state and evaluate its implications.\n- **Objective:** The language is technical and precise. The question asks for the \"most consequential change,\" which, in the context of biological data analysis, refers to the change with the largest impact on downstream interpretation, such as variant calling. This is an objective assessment.\n\nThe problem is self-contained, consistent, and grounded in established bioinformatics principles. The hypothetical bit flip is a well-defined operation leading to a predictable change in the data representation, whose consequences can be rigorously analyzed.\n\nStep 3: Verdict and Action\nThe problem statement is valid. I will proceed with the solution derivation.\n\n**Analysis of the Initial State**\n\nFirst, we must decompose the initial SAM flags to understand the state of the read pair as described by the aligner. The flag is the sum of the bit values for all true properties.\n\nFor read $1$, the flag is $99$:\n$99 = 64 + 32 + 2 + 1$.\nThis decodes as:\n- $64$: This is the first segment (read $1$).\n- $32$: The mate (read $2$) is mapped to the reverse complement strand.\n- $2$: The pair is properly aligned.\n- $1$: The template is paired.\nThe bit $16$ (this segment is reverse complemented) is not set, so read $1$ is on the forward strand. This describes a read $1$ on the forward strand whose mate is on the reverse strand.\n\nFor read $2$, the flag is $147$:\n$147 = 128 + 16 + 2 + 1$.\nThis decodes as:\n- $128$: This is the second segment (read $2$).\n- $16$: This segment is mapped to the reverse complement strand.\n- $2$: The pair is properly aligned.\n- $1$: The template is paired.\nThe bit $32$ (the mate is reverse complemented) is not set, so the mate (read $1$) is on the forward strand. This describes a read $2$ on the reverse strand whose mate is on the forward strand.\n\nThe combination of these flags ($99$ and $147$) consistently describes a \"proper pair\" from a standard $\\text{FR}$ library: read $1$ is forward, read $2$ is reverse, and they are oriented towards each other. The presence of the \"properly aligned\" bit ($2$) in both flags confirms this interpretation by the aligner.\n\n**Analysis of the Perturbation**\n\nThe problem states that the bit for \"this segment is reverse complemented\" (value $16$) is flipped for read $1$.\nThe initial flag for read $1$ is $99$. The bit with value $16$ is not set. A \"flip\" in this case means setting the bit to true. Therefore, the new flag for read $1$ is the original flag plus the value of the flipped bit:\nNew flag for read $1 = 99 + 16 = 115$.\n\n**Analysis of the New State**\n\nThe read pair is now described by the flags $115$ for read $1$ and $147$ for read $2$. Let us analyze the meaning of this new state for downstream tools, particularly for structural variant (SV) calling.\n\nNew flag for read $1$ is $115$:\n$115 = 64 + 32 + 16 + 2 + 1$.\nThe critical changes are due to the new presence of bit $16$:\n- $64$: This is read $1$.\n- $16$: This segment (read $1$) is mapped to the reverse complement strand.\n- $32$: The mate (read $2$) is mapped to the reverse complement strand.\n- (Other bits `1`, `2` are unchanged).\n\nThe flag for read $2$ remains $147$, which indicates it is on the reverse strand.\nSo, the new interpretation based on the individual orientation flags is:\n- Read $1$ is on the reverse strand (due to bit $16$ in flag $115$).\n- Read $2$ is on the reverse strand (due to bit $16$ in flag $147$).\n\nThe pair's orientation has changed from $\\text{FR}$ (forward-reverse, `-> ... <-`) to $\\text{RR}$ (reverse-reverse, `<- ... <-`). This is a discordant read pair orientation. In the context of a standard library, an $\\text{RR}$ orientation, where both reads map to the same strand and point in the same direction, is a classic signature for a genomic inversion. The reads flank one of the inversion's breakpoints.\n\nBecause the problem states that this change arose from a technical error (a bit flip) and not a true biological rearrangement, any tool that identifies this $\\text{RR}$ pattern will report a structural variant that does not exist. This is a false positive call, a serious form of biological misinterpretation.\n\nThe bit `2` (\"properly paired\") remains set in the flag, as per the problem statement. A naive tool might filter out this read pair from a discordant analysis if it only selects pairs where bit `2` is *not* set. However, robust SV callers do not rely solely on the \"proper pair\" flag. They re-evaluate the pairing geometry (orientation, insert size) based on the fundamental flags (like $16$ and $32$) and mapping positions. Such a tool would identify this pair as discordant despite the presence of bit `2`, and flag it as evidence for an inversion.\n\n**Evaluation of Options**\n\n**A. The pair would likely be reinterpreted as a discordant \"inversion-like\" orientation (both reads on the reverse strand) and could produce a false positive structural variant signal near this locus.**\nThis statement is consistent with our derivation. The bit flip changes the orientation of read $1$ to reverse, resulting in an $\\text{RR}$ pair. This orientation is a canonical signature for an inversion. As the pair was originally normal, this leads to a false positive SV signal. This is a highly consequential change in biological interpretation. **Correct**.\n\n**B. The pair would still be considered a proper pair for all downstream tools because mapping positions and insert size are unchanged; orientation bits are ignored in practice.**\nThis statement is fundamentally incorrect. The orientation bits ($16$ and $32$) are critical for interpreting paired-end data and are absolutely not ignored by downstream tools. They are the primary indicators of read pair geometry, which is essential for SV detection, RNA-seq analysis, and other applications. An $\\text{RR}$ orientation is, by definition, not a proper pair for an $\\text{FR}$ library. **Incorrect**.\n\n**C. The change would only affect duplicate marking without influencing biological interpretation, since duplicate marking relies solely on mapping start positions and the CIGAR string.**\nThis statement is incorrect on two counts. First, duplicate marking algorithms (like Picard's) do use strand information to determine the correct 5' mapping coordinate for comparison, so the bit flip would affect it. More importantly, the claim that this *only* affects duplicate marking and has no influence on biological interpretation is patently false. As shown, the change creates a strong but spurious signal for a structural variant, which is a major influence on biological interpretation. **Incorrect**.\n\n**D. The read would be treated as unmapped and removed from analysis, eliminating any possibility of biological misinterpretation from this pair.**\nThis statement is incorrect. The bit flag for \"unmapped\" is bit $4$. The problem explicitly states that only bit $16$ was flipped. The bit $4$ was not set in the original flag ($99$) and is not set in the new flag ($115$). The read remains mapped. Therefore, it will be included in downstream analyses and is subject to misinterpretation. **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "2370643"}, {"introduction": "Having explored the CIGAR string and FLAG field individually, this final practice challenges you to synthesize them into a coherent whole. You will step into the role of a bioinformatics tool developer, converting a raw, gapped alignment into a valid SAM record. This requires generating not only the correct FLAG and CIGAR string but also calculating the precise starting position (POS), a value that cleverly depends on both the alignment strand and the CIGAR's structure. This capstone exercise integrates all the core concepts, solidifying your ability to work with and create genomic alignment data from first principles [@problem_id:2370602].", "problem": "You are given a set of alignments originating from the Basic Local Alignment Search Tool (BLAST) in a tabular form that includes explicit, gapped pairwise alignment strings for the query and the reference, along with reference coordinates and strand. Your task is to convert each alignment into the fields of a Sequence Alignment/Map (SAM) record that are necessary to validate the alignment geometry: the bitwise FLAG, the leftmost reference position POS, and a compact CIGAR string. Because sequences and base qualities are not provided, they are not required in the output. The Binary Alignment/Map (BAM) uses a canonical integer coding for CIGAR operators; you must encode the generated CIGAR as a list of length–operator-code pairs using these codes.\n\nFormally, for each alignment record, you are given:\n- A query name string $qname$ and a reference name string $rname$.\n- A strand indicator $strand \\in \\{\"+\",\"-\"\\}$ for the query-to-reference orientation.\n- Reference start and end coordinates $r_{start}$ and $r_{end}$ that are $1$-based inclusive coordinates spanning exactly the number of reference symbols in the gapped alignment (that is, the number of non-gap characters in the reference alignment string), with $r_{start} \\le r_{end}$ when $strand = \"+\"$ and $r_{start} \\ge r_{end}$ when $strand = \"-\"$.\n- Two equal-length strings $aln\\_q$ and $aln\\_r$, composed only of the characters $\\{\"A\",\"C\",\"G\",\"T\",\"-\"\\}$, that describe the aligned query and reference with gap characters $\"-\"$ for insertions or deletions.\n\nYou must generate, for each alignment, the following SAM components:\n- The bitwise FLAG as an integer: use $0$ if $strand = \"+\"$, and $16$ if $strand = \"-\"$. All other bits are unset because the alignments are single-end and mapped.\n- The POS field as the $1$-based leftmost reference coordinate of the alignment of the read to the reference. Define $L = \\min(r_{start}, r_{end})$. Construct the raw CIGAR by scanning $aln\\_q$ and $aln\\_r$ left-to-right and coalescing consecutive operations using only the operators $M$, $I$, and $D$ under the following rules:\n  - If $aln\\_q[i] \\neq \"-\"$ and $aln\\_r[i] \\neq \"-\"$, emit an $M$ of length $1$ (alignment match or mismatch; do not distinguish between match and mismatch).\n  - If $aln\\_q[i] = \"-\"$ and $aln\\_r[i] \\neq \"-\"$, emit a $D$ of length $1$ (deletion with respect to the query, consuming reference).\n  - If $aln\\_q[i] \\neq \"-\"$ and $aln\\_r[i] = \"-\"$, emit an $I$ of length $1$ (insertion with respect to the reference, consuming query).\n  - The case $aln\\_q[i] = \"-\"$ and $aln\\_r[i] = \"-\"$ does not occur.\n  - Coalesce adjacent identical operations into single runs with summed lengths.\n  After constructing this raw CIGAR run list, remove all leading and trailing $D$ runs, because valid SAM alignments must not start or end with a deletion. Let $d\\_{low}$ be the number of reference bases consumed by deletions adjacent to the leftmost genomic coordinate of the alignment before the first aligned query base. Compute $d\\_{low}$ as follows:\n  - If $strand = \"+\"$, then $d\\_{low}$ is the length of the leading $D$ run removed from the start (or $0$ if there was none).\n  - If $strand = \"-\"$, then $d\\_{low}$ is the length of the trailing $D$ run removed from the end (or $0$ if there was none).\n  Finally, set $POS = L + d\\_{low}$.\n- The CIGAR in run-length form, using only $M$, $I$, and $D$ after the above trimming. For output, encode this CIGAR using BAM operator codes: $M \\mapsto 0$, $I \\mapsto 1$, $D \\mapsto 2$. Represent the CIGAR as a list of pairs $[len,op]$ where $len$ is a positive integer and $op \\in \\{0,1,2\\}$.\n\nAssume the mapping quality is unavailable and would be reported in SAM as $MAPQ = 255$ if it were required. Because sequences and base qualities are not provided, $SEQ$ and $QUAL$ are not part of the required output. For mate fields, assume single-end data so that $RNEXT = \"*\"$, $PNEXT = 0$, $TLEN = 0$ in a full SAM line; these do not appear in the required output.\n\nYou must implement a program that, given the fixed test suite below embedded in the program, produces for each test case a list containing three elements: the integer FLAG, the integer POS, and the encoded CIGAR as a list of $[len,op]$ pairs using the above operator codes. Aggregate the results for all test cases into a single list and print it on one line as a comma-separated list enclosed in square brackets, with nested lists using the same bracketed format. No other text should be printed.\n\nTest suite (each test case is a tuple of fields in the order $(qname, rname, strand, r_{start}, r_{end}, aln\\_q, aln\\_r)$):\n- Case $1$ (forward strand with an insertion relative to the reference):\n  - $qname = \\text{\"read1\"}$, $rname = \\text{\"chr1\"}$, $strand = \\text{\"+\"}$, $r_{start} = 7$, $r_{end} = 11$, $aln\\_q = \\text{\"ACTGAC\"}$, $aln\\_r = \\text{\"ACT-AC\"}$.\n- Case $2$ (reverse strand with a deletion relative to the query):\n  - $qname = \\text{\"read2\"}$, $rname = \\text{\"chr2\"}$, $strand = \\text{\"-\"}$, $r_{start} = 100$, $r_{end} = 96$, $aln\\_q = \\text{\"A-CCT\"}$, $aln\\_r = \\text{\"AGCCT\"}$.\n- Case $3$ (forward strand with leading deletions and a trailing insertion):\n  - $qname = \\text{\"read3\"}$, $rname = \\text{\"chr3\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1000$, $r_{end} = 1004$, $aln\\_q = \\text{\"--ACGT\"}$, $aln\\_r = \\text{\"TTACG-\"}$.\n- Case $4$ (reverse strand with trailing deletions at the low-coordinate end):\n  - $qname = \\text{\"read4\"}$, $rname = \\text{\"chr4\"}$, $strand = \\text{\"-\"}$, $r_{start} = 500$, $r_{end} = 495$, $aln\\_q = \\text{\"AC-T--\"}$, $aln\\_r = \\text{\"ACCTGG\"}$.\n- Case $5$ (forward strand with mismatches only, no gaps):\n  - $qname = \\text{\"read5\"}$, $rname = \\text{\"chr5\"}$, $strand = \\text{\"+\"}$, $r_{start} = 1$, $r_{end} = 3$, $aln\\_q = \\text{\"AGT\"}$, $aln\\_r = \\text{\"ACT\"}$.\n\nAngle units do not apply. No physical units are involved. All outputs are integers or lists of integers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\,[flag\\_1,POS\\_1,CIGAR\\_1],\\,[flag\\_2,POS\\_2,CIGAR\\_2],\\,\\dots\\,]$, where each $CIGAR\\_i$ is itself a list of $[len,op]$ pairs using the BAM operator codes $M \\mapsto 0$, $I \\mapsto 1$, $D \\mapsto 2$.", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It presents a clearly defined algorithmic task of converting a specific tabular alignment format into standard Sequence Alignment/Map (SAM) fields. The provided inputs, rules, and test cases are self-contained and consistent with established principles in bioinformatics. The problem is therefore valid and a solution will be provided.\n\nThe procedure to convert each given alignment record into the required SAM fields—the bitwise $FLAG$, the position $POS$, and the encoded $CIGAR$ string—is executed in three sequential stages.\n\nFirst, the bitwise $FLAG$ is determined. The SAM format specification uses bit flags to encode properties of an alignment. The bit representing strand is $0x10$, or $16$ in decimal. As per the problem description, if the alignment is to the forward strand ($strand = \\text{\"+\"}$), the $FLAG$ is set to $0$. If the alignment is to the reverse-complement strand ($strand = \\text{\"-\"}$), the $FLAG$ is set to $16$. Other flags related to pairing, quality, or supplementary status are not considered, consistent with the provided information.\n\nSecond, the $CIGAR$ string is constructed and encoded. The $CIGAR$ string provides a compact representation of the alignment structure. The process is as follows:\n$1$. The alignment strings $aln\\_q$ (query) and $aln\\_r$ (reference) are scanned character by character from left to right.\n$2$. For each position $i$, an operation is determined: an alignment match/mismatch ($M$) if $aln\\_q[i]$ and $aln\\_r[i]$ are both bases; a deletion from the reference ($D$) if $aln\\_q[i]$ is a gap ($\"-\"$); or an insertion into the reference ($I$) if $aln\\_r[i]$ is a gap ($\"-\"$). The case where both are gaps is proscribed.\n$3$. This sequence of single-character operations is then coalesced. Consecutive identical operations are merged into a single operation with a summed length. For example, a sequence of $M, M, M$ becomes $3M$. This results in a raw run-length encoded $CIGAR$.\n$4$. According to the problem specification, valid SAM alignments must not begin or end with a deletion ($D$). Therefore, any leading or trailing runs of $D$ operations are removed from the raw $CIGAR$. The lengths of these removed runs are recorded for the subsequent calculation of the $POS$ field.\n$5$. Finally, the trimmed $CIGAR$ string is converted into its binary representation as used in the BAM format. The operators $M$, $I$, and $D$ are mapped to the integer codes $0$, $1$, and $2$, respectively. The final $CIGAR$ is a list of pairs, each containing a length and an operator code, e.g., $[len, op]$.\n\nThird, the $POS$ field is calculated. The $POS$ field in SAM format specifies the $1$-based leftmost mapping position of the primary alignment. The calculation is critically dependent on the strand and any trimmed deletions.\n$1$. The leftmost genomic coordinate of the alignment span, $L$, is identified as $L = \\min(r_{start}, r_{end})$. Note that for a forward strand alignment, $L = r_{start}$, and for a reverse strand alignment, $L = r_{end}$.\n$2$. A crucial adjustment factor, $d_{low}$, must be computed. This factor accounts for reference bases that are part of the original alignment block but are trimmed from the final $CIGAR$ because they correspond to deletions at the start or end of the query sequence. The definition of $d_{low}$ depends on the strand:\n   - For a forward strand ($strand = \\text{\"+\"}$) alignment, the alignment's \"left\" side corresponds to the start of the CIGAR string and the low genomic coordinates. Thus, $d_{low}$ is the length of the leading $D$ run that was removed.\n   - For a reverse strand ($strand = \\text{\"-\"}$) alignment, the alignment's \"left\" side (in genomic coordinates) corresponds to the end of the query and thus the end of the CIGAR string. Therefore, $d_{low}$ is the length of the trailing $D$ run that was removed.\n$3$. The final $POS$ value is calculated as $POS = L + d_{low}$. This adjusts the starting position to account for the reference bases that were consumed by the trimmed deletions adjacent to the first aligned base of the query.\n\nAs a demonstrative example, let us apply this procedure to Test Case $3$:\n- Inputs: $strand = \\text{\"+\"}$, $r_{start} = 1000$, $r_{end} = 1004$, $aln\\_q = \\text{\"--ACGT\"}$, $aln\\_r = \\text{\"TTACG-\"}$.\n- $FLAG$: Since $strand = \\text{\"+\"}$, $FLAG = 0$.\n- CIGAR Generation:\n  - Scanning $aln\\_q$ and $aln\\_r$ yields the operation sequence $[D, D, M, M, M, I]$.\n  - Coalescing results in the raw $CIGAR$: $2D3M1I$.\n  - Trimming leading/trailing $D$ operations: The leading $2D$ is removed. The resulting $CIGAR$ is $3M1I$.\n  - The length of the removed leading $D$ run is $2$.\n  - Encoding $3M1I$ with codes $M \\mapsto 0, I \\mapsto 1$ gives $[[3, 0], [1, 1]]$.\n- POS Calculation:\n  - $L = \\min(1000, 1004) = 1000$.\n  - $strand$ is $\\text{\"+\"}$, so $d_{low}$ is the length of the leading $D$ run removed, which is $2$.\n  - $POS = L + d_{low} = 1000 + 2 = 1002$.\n- Final result for Case $3$: $[0, 1002, [[3, 0], [1, 1]]]$.\n\nThis rigorous, step-by-step process is applied to each test case to generate the final required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Solves the problem of converting BLAST-like alignments to SAM fields.\n    \"\"\"\n    \n    # Test suite provided in the problem statement.\n    test_cases = [\n        # Case 1 (forward strand with an insertion relative to the reference):\n        (\"read1\", \"chr1\", \"+\", 7, 11, \"ACTGAC\", \"ACT-AC\"),\n        # Case 2 (reverse strand with a deletion relative to the query):\n        (\"read2\", \"chr2\", \"-\", 100, 96, \"A-CCT\", \"AGCCT\"),\n        # Case 3 (forward strand with leading deletions and a trailing insertion):\n        (\"read3\", \"chr3\", \"+\", 1000, 1004, \"--ACGT\", \"TTACG-\"),\n        # Case 4 (reverse strand with trailing deletions at the low-coordinate end):\n        (\"read4\", \"chr4\", \"-\", 500, 495, \"AC-T--\", \"ACCTGG\"),\n        # Case 5 (forward strand with mismatches only, no gaps):\n        (\"read5\", \"chr5\", \"+\", 1, 3, \"AGT\", \"ACT\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the test case tuple for clarity.\n        qname, rname, strand, r_start, r_end, aln_q, aln_r = case\n\n        # 1. Determine the bitwise FLAG\n        flag = 16 if strand == \"-\" else 0\n\n        # 2. Generate the raw CIGAR string\n        op_map = {'M': 0, 'I': 1, 'D': 2}\n        raw_ops = []\n        for q_char, r_char in zip(aln_q, aln_r):\n            if q_char != '-' and r_char != '-':\n                raw_ops.append('M')  # Match or Mismatch\n            elif q_char != '-' and r_char == '-':\n                raw_ops.append('I')  # Insertion to reference\n            elif q_char == '-' and r_char != '-':\n                raw_ops.append('D')  # Deletion from reference\n        \n        # Coalesce adjacent identical operations\n        if not raw_ops:\n            raw_cigar_list = []\n        else:\n            raw_cigar_list = []\n            current_op = raw_ops[0]\n            current_len = 1\n            for op in raw_ops[1:]:\n                if op == current_op:\n                    current_len += 1\n                else:\n                    raw_cigar_list.append([current_len, current_op])\n                    current_op = op\n                    current_len = 1\n            raw_cigar_list.append([current_len, current_op])\n        \n        # 3. Trim CIGAR and calculate POS\n        \n        # Record lengths of leading/trailing deletions before trimming\n        d_leading = 0\n        if raw_cigar_list and raw_cigar_list[0][1] == 'D':\n            d_leading = raw_cigar_list[0][0]\n        \n        d_trailing = 0\n        if raw_cigar_list and raw_cigar_list[-1][1] == 'D':\n            d_trailing = raw_cigar_list[-1][0]\n            \n        # Trim leading 'D'\n        trimmed_cigar = list(raw_cigar_list) # Make a copy\n        if trimmed_cigar and trimmed_cigar[0][1] == 'D':\n            trimmed_cigar.pop(0)\n            \n        # Trim trailing 'D'\n        if trimmed_cigar and trimmed_cigar[-1][1] == 'D':\n            trimmed_cigar.pop(-1)\n\n        # Calculate d_low based on strand\n        d_low = 0\n        if strand == '+':\n            d_low = d_leading\n        elif strand == '-':\n            # For reverse strand, trailing deletions in the alignment string\n            # correspond to the low-coordinate end of the reference alignment.\n            d_low = d_trailing\n            \n        # Calculate the leftmost genomic coordinate L\n        L = min(r_start, r_end)\n        \n        # Final POS calculation\n        pos = L + d_low\n        \n        # 4. Encode the final CIGAR using BAM operator codes\n        encoded_cigar = [[length, op_map[op]] for length, op in trimmed_cigar]\n        \n        results.append([flag, pos, encoded_cigar])\n\n    # Final print statement in the exact required format.\n    # The default str() representation of lists includes spaces, which is\n    # consistent with the example format in the problem description.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2370602"}]}