{"hands_on_practices": [{"introduction": "A crucial first step in any bioinformatics pipeline is data validation and parsing. Since data often aggregates from diverse sources like GenBank, RefSeq, and UniProt, you must be able to handle a variety of accession number formats. This exercise challenges you to use regular expressions, a fundamental tool in computational biology, to simultaneously validate and extract information from a mixed stream of identifiers [@problem_id:2428411]. Mastering this skill will enable you to build robust and reliable data-processing workflows capable of handling the heterogeneity of real-world biological data.", "problem": "A bioinformatics pipeline must validate a mixed stream of putative sequence identifiers and extract two fields from each valid identifier: a leading alphabetical prefix and the immediately following numeric part. The stream may contain identifiers from any of the following databases, and an identifier is considered valid if and only if it conforms exactly to one of these forms.\n\n- GenBank primary nucleotide accessions: either one uppercase letter followed by exactly five digits, or two uppercase letters followed by exactly six digits. No version suffixes or other decorations are allowed.\n- National Center for Biotechnology Information (NCBI) Reference Sequence (RefSeq) accessions: a two-letter prefix from the set {NM, NR, NP, NC, NG, NT, NW, XM, XR, XP, YP}, followed by an underscore, followed by one or more digits (the accession number), with an optional version suffix consisting of a dot and one or more digits. Only the two-letter code before the underscore is the prefix, and the numeric part is the digit sequence immediately after the underscore, not including the optional version.\n- Universal Protein Resource (UniProt) primary accessions (isoform suffixes excluded): either a six-character string consisting of one uppercase letter, one digit, three uppercase letters or digits, and one final digit, or a ten-character string consisting of one uppercase letter, one digit, and eight uppercase letters or digits. For this problem, the prefix is defined as the consecutive uppercase letters from the start up to (but not including) the first digit, and the numeric part is the maximal contiguous run of digits immediately following that prefix.\n- Protein Data Bank (PDB) identifiers: exactly four characters consisting of one digit followed by three uppercase letters or digits. For this problem, define the prefix as the empty string and the numeric part as the first digit.\n\nYou are to construct a single pattern using Perl Compatible Regular Expressions (PCRE) that, when applied to a candidate string, validates it against the four classes simultaneously and captures the two fields into consistently named capturing groups across all alternatives: the group named “prefix” must capture the prefix as defined above, and the group named “num” must capture the numeric part as defined above.\n\nAfter designing such a single regular expression, apply it conceptually (no code execution is required) to the following list of strings. For each string that matches, determine the length (in characters) of the captured numeric part and add these lengths. Let the resulting total be denoted by $S$. Report the value of $S$ as a plain integer.\n\n- M12345\n- AF123456\n- CP000001\n- AB12345\n- J012345\n- NM_000059.3\n- NP_123456\n- XR_98765.1\n- ZZ_123456\n- P12345\n- Q8N158\n- A0A023GPI8\n- B2R5Z7\n- 1ABC\n- 2C7A\n- A1BC\n- XP_1234\n- Q8N158-2\n- NR_001\n- YP_009724390.1\n\nAnswer form: Provide only the numerical value of $S$. No units are required. Do not round; $S$ is an integer by definition.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded, well-posed, and objective. It provides a clear, self-contained set of rules for identifying and parsing four specific classes of bioinformatics sequence identifiers. The definitions, while idiosyncratic for some classes, are unambiguous and facilitate the construction of a formal solution.\n\nThe task is to construct a single Perl Compatible Regular Expression (PCRE) to validate strings against the given formats and extract two named fields: `prefix` and `num`. Subsequently, this process is to be conceptually applied to a provided list of candidate strings to calculate a sum, $S$, which is the total length of all captured `num` fields from the valid strings.\n\nFirst, we design the regular expression. The overall pattern must match the entire string from beginning (`^`) to end (`$`) and will consist of four main alternatives, one for each database, combined with the `|` operator. We will use named capture groups `(?<prefix>...)` and `(?<num>...)`.\n\n1.  **GenBank Accessions**: The format is one uppercase letter and five digits (`[A-Z]\\d{5}`) or two uppercase letters and six digits (`[A-Z]{2}\\d{6}`). The prefix is the alphabetical part and the numeric part is the digit sequence. This translates to the following two-part alternative:\n    `(?<prefix>[A-Z])(?<num>\\d{5})` and `(?<prefix>[A-Z]{2})(?<num>\\d{6})`.\n    The combined sub-pattern for GenBank is:\n    `(?:(?<prefix>[A-Z])(?<num>\\d{5})|(?<prefix>[A-Z]{2})(?<num>\\d{6}))`\n\n2.  **NCBI RefSeq Accessions**: The format is a specific two-letter prefix, an underscore, one or more digits, and an optional version suffix. The prefix is the two-letter code, and the numeric part is the sequence of digits after the underscore. The allowed prefixes are `{NM, NR, NP, NC, NG, NT, NW, XM, XR, XP, YP}`.\n    The sub-pattern for RefSeq is:\n    `(?<prefix>NM|NR|NP|NC|NG|NT|NW|XM|XR|XP|YP)_(?<num>\\d+)(?:\\.\\d+)?`\n\n3.  **UniProt Accessions**: The format is either a six-character string `[A-Z]\\d[A-Z0-9]{3}\\d` or a ten-character string `[A-Z]\\d[A-Z0-9]{8}`. The prefix is defined as the leading alphabetical character, and the numeric part is the single digit immediately following it.\n    The sub-pattern for UniProt is:\n    `(?<prefix>[A-Z])(?<num>\\d)(?:[A-Z0-9]{3}\\d|[A-Z0-9]{8})`\n\n4.  **PDB Identifiers**: The format is a four-character string `\\d[A-Z0-9]{3}`. The prefix is defined as the empty string, and the numeric part is the leading digit.\n    The sub-pattern for PDB, capturing an empty prefix, is:\n    `(?<prefix>)(?<num>\\d)[A-Z0-9]{3}`\n\nCombining these four sub-patterns into a single, anchored PCRE gives the final expression:\n`^(?:(?:(?<prefix>[A-Z])(?<num>\\d{5})|(?<prefix>[A-Z]{2})(?<num>\\d{6}))|(?<prefix>NM|NR|NP|NC|NG|NT|NW|XM|XR|XP|YP)_(?<num>\\d+)(?:\\.\\d+)?|(?<prefix>[A-Z])(?<num>\\d)(?:[A-Z0-9]{3}\\d|[A-Z0-9]{8})|(?<prefix>)(?<num>\\d)[A-Z0-9]{3})$`\n\nNext, we apply these rules to the provided list of strings and calculate the sum $S$. For each string, we determine its validity and, if valid, the length of the captured `num` part.\n\n1.  `M12345`: Valid GenBank (`[A-Z]\\d{5}`). `num` = `12345`. Length = $5$.\n2.  `AF123456`: Valid GenBank (`[A-Z]{2}\\d{6}`). `num` = `123456`. Length = $6$.\n3.  `CP000001`: Valid GenBank (`[A-Z]{2}\\d{6}`). `num` = `000001`. Length = $6$.\n4.  `AB12345`: Invalid. Format `[A-Z]{2}\\d{5}` does not match any rule. Length = $0$.\n5.  `J012345`: Invalid. Format `[A-Z]\\d{6}` does not match any rule. Length = $0$.\n6.  `NM_000059.3`: Valid RefSeq. `num` = `000059`. Length = $6$.\n7.  `NP_123456`: Valid RefSeq. `num` = `123456`. Length = $6$.\n8.  `XR_98765.1`: Valid RefSeq. `num` = `98765`. Length = $5$.\n9.  `ZZ_123456`: Invalid. `ZZ` is not a permitted RefSeq prefix. Length = $0$.\n10. `P12345`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`). `num` = `1`. Length = $1$.\n11. `Q8N158`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`). `num` = `8`. Length = $1$.\n12. `A0A023GPI8`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{8}`). `num` = `0`. Length = $1$.\n13. `B2R5Z7`: Valid UniProt (`[A-Z]\\d[A-Z0-9]{3}\\d`). `num` = `2`. Length = $1$.\n14. `1ABC`: Valid PDB (`\\d[A-Z0-9]{3}`). `num` = `1`. Length = $1$.\n15. `2C7A`: Valid PDB (`\\d[A-Z0-9]{3}`). `num` = `2`. Length = $1$.\n16. `A1BC`: Invalid. Does not match any rule. Length = $0$.\n17. `XP_1234`: Valid RefSeq. `num` = `1234`. Length = $4$.\n18. `Q8N158-2`: Invalid. The string contains a suffix `-2` not accounted for in any rule, and the pattern is anchored. Length = $0$.\n19. `NR_001`: Valid RefSeq. `num` = `001`. Length = $3$.\n20. `YP_009724390.1`: Valid RefSeq. `num` = `009724390`. Length = $9$.\n\nThe total sum $S$ is the sum of these lengths:\n$S = 5 + 6 + 6 + 0 + 0 + 6 + 6 + 5 + 0 + 1 + 1 + 1 + 1 + 1 + 1 + 0 + 4 + 0 + 3 + 9$\n$S = (5+5) + (6+6+6+6) + (1+1+1+1+1+1) + 4 + 3 + 9$\n$S = 10 + 24 + 6 + 4 + 3 + 9$\n$S = 34 + 6 + 4 + 3 + 9$\n$S = 40 + 4 + 3 + 9$\n$S = 44 + 3 + 9$\n$S = 47 + 9 = 56$\n\nThe final calculated value for $S$ is $56$.", "answer": "$$\\boxed{56}$$", "id": "2428411"}, {"introduction": "Accession numbers are not always perfect; they can suffer from typos and transcription errors, especially when sourced from publications or manual notes. A simple exact match would fail in these cases, preventing you from retrieving the correct data. This practice introduces the powerful concept of \"fuzzy matching\" by having you implement a custom edit distance algorithm, a method to quantify string similarity that is a cornerstone of bioinformatics [@problem_id:2428373]. By assigning lower costs to common visual mix-ups (like 'O' and '0'), you will create a practical tool that can find the correct identifier even when it contains errors.", "problem": "Create a program that selects the most plausible canonical sequence accession identifier from a fixed candidate set for each of several query strings that may contain transcription errors. In this setting, an accession identifier is a finite string over an alphabet of uppercase letters, digits, and the symbols underscore and period. Let the ordered candidate set be denoted by $S = (s_0, s_1, \\dots, s_{n-1})$ and let the query set be denoted by $Q = (q_0, q_1, \\dots, q_{m-1})$.\n\nDefine a symmetric set of visually confusable character pairs $H$ by\n$$\nH = \\{(O,0),(I,1),(l,1),(S,5),(Z,2),(B,8),(G,6)\\},\n$$\ninterpreted as unordered pairs, so that $(a,b) \\in H$ if and only if $(b,a) \\in H$.\n\nDefine the substitution cost function $c: \\Sigma \\times \\Sigma \\to \\mathbb{R}_{\\ge 0}$ by\n$$\nc(x,y) = \\begin{cases}\n0 & \\text{if } x=y,\\\\\n\\frac{1}{2} & \\text{if } \\{x,y\\} \\in H,\\\\\n1 & \\text{otherwise.}\n\\end{cases}\n$$\nDefine the dissimilarity $d(q,s)$ between two strings $q$ and $s$ as the minimum total cost over all sequences of single-character insertions, deletions, and substitutions that transform $q$ into $s$, where each insertion has cost $1$, each deletion has cost $1$, and each substitution of character $x$ by $y$ has cost $c(x,y)$. For any $q$, define the selected index $\\operatorname{idx}(q)$ as follows. Compute $d(q,s_i)$ for all $i \\in \\{0,1,\\dots,n-1\\}$, find the minimal value $d_{\\min}(q) = \\min_i d(q,s_i)$, and let $I(q)$ be the set of indices attaining this minimum,\n$$\nI(q) = \\{\\, i \\mid d(q,s_i) = d_{\\min}(q) \\,\\}.\n$$\nFix a tolerance threshold $T=2$. If $d_{\\min}(q) \\le T$, set $\\operatorname{idx}(q)$ to the smallest index in $I(q)$ (that is, the unique $i \\in I(q)$ with no smaller index), and otherwise set $\\operatorname{idx}(q) = -1$.\n\nUse the following ordered candidate set $S$ of length $n=10$ (indices are $0$-based):\n- $s_0 = \\text{NM\\_000546.6}$\n- $s_1 = \\text{NP\\_000537.3}$\n- $s_2 = \\text{NC\\_000001.11}$\n- $s_3 = \\text{AY123456}$\n- $s_4 = \\text{ABO123456}$\n- $s_5 = \\text{GCF\\_000001405.39}$\n- $s_6 = \\text{ENST00000335137.4}$\n- $s_7 = \\text{XM\\_021893495.1}$\n- $s_8 = \\text{LRG\\_199}$\n- $s_9 = \\text{ENST00000335137.5}$\n\nEvaluate your program on the following $m=9$ query strings:\n- $q_0 = \\text{AY123456}$\n- $q_1 = \\text{AB0123456}$\n- $q_2 = \\text{NM\\_000546.7}$\n- $q_3 = \\text{NC\\_00001.11}$\n- $q_4 = \\text{XM021893495.1}$\n- $q_5 = \\text{ENST00000335137.6}$\n- $q_6 = \\text{XYZ123}$\n- $q_7 = \\text{LRG\\_I99}$\n- $q_8 = \\text{NM0005466}$\n\nYour program must compute $\\operatorname{idx}(q_j)$ for each $j \\in \\{0,1,\\dots,8\\}$ and produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets (for example, $[\\dots]$). The final output for the entire test suite is the list\n$$\n\\bigl[\\operatorname{idx}(q_0),\\operatorname{idx}(q_1),\\dots,\\operatorname{idx}(q_8)\\bigr].\n$$\nNo physical units are involved. Angles are not involved. All ratios, if any, must be expressed as real numbers and not as percentages. The only allowed outputs for each test case are integers as specified above.", "solution": "The problem as presented is scientifically sound, well-posed, and contains all necessary information for a deterministic solution. It is a problem in applied stringology, a subfield of computer science, with direct application to bioinformatics. We may therefore proceed directly to the formulation of a solution.\n\nThe core task is to identify, for each query string $q$, the most plausible canonical accession identifier $s_i$ from a given candidate set $S$. The selection is based on a dissimilarity score $d(q,s)$ and a threshold criterion.\n\nThe dissimilarity $d(q,s)$ is defined as a generalized edit distance, specifically the Levenshtein distance with custom costs for substitution. The cost of transforming a string $q$ into a string $s$ is the minimum sum of costs for a sequence of elemental operations: insertion, deletion, and substitution.\nThe costs are defined as:\n-   Deletion of a single character: cost of $1$.\n-   Insertion of a single character: cost of $1$.\n-   Substitution of a character $x$ with a character $y$: cost given by the function $c(x,y)$.\n\nThe substitution cost function $c(x,y)$ is specified as:\n$$\nc(x,y) = \\begin{cases}\n0 & \\text{if } x=y,\\\\\n\\frac{1}{2} & \\text{if } \\{x,y\\} \\in H,\\\\\n1 & \\text{otherwise.}\n\\end{cases}\n$$\nThe set of visually confusable character pairs $H$ is given by $H = \\{(O,0),(I,1),(l,1),(S,5),(Z,2),(B,8),(G,6)\\}$. It is noted that the problem defines the alphabet for canonical identifiers to consist of uppercase letters, digits, and symbols `_` and `.`. The inclusion of the pair $(l,1)$, containing a lowercase letter, is a formal extension of the substitution cost function's domain. As the provided query strings do not contain lowercase letters, this specific pair does not affect the outcome for the given data, but a robust implementation must correctly parse this definition.\n\nThe calculation of the dissimilarity $d(q, s)$ is a classic dynamic programming problem, solvable efficiently using the Wagner-Fischer algorithm. Let $q$ be a string of length $m$ and $s$ be a string of length $n$. We construct a matrix $D$ of size $(m+1) \\times (n+1)$, where $D_{i,j}$ stores the minimum cost to transform the prefix $q[1\\dots i]$ into the prefix $s[1\\dots j]$. The matrix is populated according to the following recurrence relation:\n\nInitialization:\n-   $D_{i,0} = i$ for $i \\in [0, m]$ (cost of deleting $i$ characters from $q$).\n-   $D_{0,j} = j$ for $j \\in [0, n]$ (cost of inserting $j$ characters to form $s$).\n\nRecurrence for $i > 0$ and $j > 0$:\n$$\nD_{i,j} = \\min \\begin{cases}\nD_{i-1,j} + 1 & \\text{(deletion of } q_i\\text{)}\\\\\nD_{i,j-1} + 1 & \\text{(insertion of } s_j\\text{)}\\\\\nD_{i-1,j-1} + c(q_i, s_j) & \\text{(substitution of } q_i \\text{ with } s_j\\text{)}\n\\end{cases}\n$$\nThe final dissimilarity $d(q,s)$ is given by the value $D_{m,n}$.\n\nFor each query string $q_j \\in Q$, the selection procedure is as follows:\n$1$. Compute the dissimilarity $d(q_j, s_i)$ for all candidate strings $s_i \\in S$, where $i \\in \\{0, 1, \\dots, n-1\\}$.\n$2$. Determine the minimum dissimilarity, $d_{\\min}(q_j) = \\min_{i} d(q_j, s_i)$.\n$3$. Identify the set of indices that achieve this minimum: $I(q_j) = \\{\\, k \\mid d(q_j, s_k) = d_{\\min}(q_j) \\,\\}$.\n$4$. Apply the thresholding and tie-breaking rule. Given the threshold $T=2$:\n    - If $d_{\\min}(q_j) \\le T$, the selected index is $\\operatorname{idx}(q_j) = \\min(I(q_j))$. The tie is broken by choosing the smallest index among those that yield the minimum distance.\n    - If $d_{\\min}(q_j) > T$, no suitable candidate is found, and the index is set to $\\operatorname{idx}(q_j) = -1$.\n\nThis complete, unambiguous procedure is implemented for each query string. The resulting indices are collected into a list to form the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the sequence identifier matching problem.\n    \"\"\"\n    \n    # Define the candidate set S as specified in the problem statement.\n    s_candidates = [\n        \"NM_000546.6\",       # s0\n        \"NP_000537.3\",       # s1\n        \"NC_000001.11\",      # s2\n        \"AY123456\",          # s3\n        \"ABO123456\",         # s4\n        \"GCF_000001405.39\",  # s5\n        \"ENST00000335137.4\", # s6\n        \"XM_021893495.1\",    # s7\n        \"LRG_199\",           # s8\n        \"ENST00000335137.5\"  # s9\n    ]\n\n    # Define the query set Q as specified in the problem statement.\n    q_queries = [\n        \"AY123456\",          # q0\n        \"AB0123456\",         # q1\n        \"NM_000546.7\",       # q2\n        \"NC_00001.11\",       # q3\n        \"XM021893495.1\",     # q4\n        \"ENST00000335137.6\", # q5\n        \"XYZ123\",            # q6\n        \"LRG_I99\",           # q7\n        \"NM0005466\"          # q8\n    ]\n\n    # Define the set H of visually confusable character pairs.\n    # We use a set of frozensets for efficient, order-independent lookup.\n    H = {\n        frozenset({'O', '0'}), frozenset({'I', '1'}), frozenset({'l', '1'}),\n        frozenset({'S', '5'}), frozenset({'Z', '2'}), frozenset({'B', '8'}),\n        frozenset({'G', '6'})\n    }\n\n    # Define the tolerance threshold T.\n    T = 2.0\n\n    def substitution_cost(c1, c2):\n        \"\"\"\n        Calculates the substitution cost c(x, y) based on the problem definition.\n        \"\"\"\n        if c1 == c2:\n            return 0.0\n        if frozenset({c1, c2}) in H:\n            return 0.5\n        return 1.0\n\n    def dissimilarity(q_str, s_str):\n        \"\"\"\n        Calculates the dissimilarity d(q, s) using the Wagner-Fischer algorithm\n        with custom substitution costs.\n        \"\"\"\n        m, n = len(q_str), len(s_str)\n        \n        # Initialize the DP matrix using numpy for efficiency.\n        dp = np.zeros((m + 1, n + 1))\n\n        # Initialize first row and column (insertion/deletion costs).\n        for i in range(m + 1):\n            dp[i, 0] = i\n        for j in range(n + 1):\n            dp[0, j] = j\n\n        # Fill the DP matrix using the recurrence relation.\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                cost = substitution_cost(q_str[i-1], s_str[j-1])\n                dp[i, j] = min(dp[i-1, j] + 1,        # Deletion\n                               dp[i, j-1] + 1,        # Insertion\n                               dp[i-1, j-1] + cost)   # Substitution/Match\n        \n        return dp[m, n]\n\n    results = []\n    for q_str in q_queries:\n        distances = [dissimilarity(q_str, s_str) for s_str in s_candidates]\n        \n        d_min = min(distances)\n        \n        if d_min <= T:\n            # Find the smallest index i where d(q, s_i) == d_min.\n            # The problem guarantees I(q) is non-empty here.\n            # We iterate to find the first such index, which is the minimum.\n            best_idx = -1\n            for i, dist in enumerate(distances):\n                if dist == d_min:\n                    best_idx = i\n                    break\n            results.append(best_idx)\n        else:\n            results.append(-1)\n            \n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2428373"}, {"introduction": "Beyond just their format, accession numbers exist within a complex and evolving ecosystem of biological knowledge. Identifiers can be updated, superseded by newer versions, or retired, while genes may be known by several different names. This final exercise moves from the syntax of identifiers to their semantics, challenging you to build a resolution engine that navigates this web of relationships [@problem_id:2428399]. By mapping legacy codes, gene synonyms, and secondary accessions to a single, canonical protein sequence, you will grapple with the critical concepts of data provenance and integration, which are essential for ensuring scientific reproducibility.", "problem": "You are given a finite, self-contained registry that models how legacy biological identifiers map to modern canonical protein sequences under realistic conventions used by major sequence databases. Your task is to implement a program that, for each input token, resolves it to the modern canonical protein sequence and then reports a quantifiable result for verification.\n\nFoundational base and definitions:\n- The Central Dogma of molecular biology states that deoxyribonucleic acid (DNA) is transcribed to ribonucleic acid (RNA), which is translated to protein. In curated databases, proteins are represented as amino-acid sequences over a fixed alphabet (the standard twenty amino acids), which can be treated as strings over a finite set.\n- Accession identifiers serve as stable references. In the Reference Sequence (RefSeq) system, an accession such as NP_abcdef is paired with a version number $v \\in \\mathbb{N}$, written as NP_abcdef.$v$. The invariant is that the root portion NP_abcdef is stable for the record, while the version number $v$ increments when the underlying sequence changes; thus, the mapping from a root accession to a protein concept is version-independent.\n- GenInfo Identifier (GI) numbers from the National Center for Biotechnology Information (NCBI) are deprecated legacy identifiers that map deterministically to specific RefSeq accessions with versions. A GI number thus induces a mapping to a RefSeq root by stripping the version.\n- The Universal Protein Resource (UniProt) accessions include a primary accession and possibly one or more secondary accessions. Secondary accessions map bijectively to a single primary accession and are retained for backward compatibility.\n- Isoforms in UniProt are denoted by suffixes of the form “-i” for $i \\in \\mathbb{N}$. The canonical isoform convention we adopt is: if isoform “-1” exists for a primary accession, it is the canonical isoform; otherwise, the canonical isoform is the one with the smallest isoform index present in the registry.\n\nYour program must implement these rules to resolve each query to a unique, canonical protein sequence in the provided registry, without any external resources. To produce numerically verifiable outputs, compute for each resolved sequence its length $L \\in \\mathbb{N}$ and its unsigned $64$-bit FNV-1a hash $H \\in \\{0,1,\\dots,2^{64}-1\\}$ of the sequence encoded as American Standard Code for Information Interchange (ASCII) bytes, using the offset basis $1469598103934665603$ and the prime $1099511628211$. The FNV-1a recurrence is:\n- Initialize $h \\leftarrow 1469598103934665603$.\n- For each byte $b$ of the sequence: $h \\leftarrow (h \\oplus b) \\times 1099511628211 \\pmod{2^{64}}$.\n- The final $h$ is $H$.\n\nRegistry:\n- Primary UniProt accessions and isoform sequences (keys are “ACC-isoformIndex”):\n  - P04637-1: MEEPQSDPSVEPPLSQETFSDLWKLL\n  - P04637-2: MEEPQSDPSVEPPLSQETFSDLWKL\n  - P38398-1: MDLSALRVEEVQNVINAMQKILECPICLE\n  - P01106-1: MPLNVSFTNRNYDLDYDSVQPY\n  - P01106-2: MPLNVSFTNRNYDLDYDSVQP\n  - Q9Y243-1: MSSILPFTPPVKRLLGWKHPGKQL\n- Secondary UniProt to primary mappings:\n  - Q13616 → P04637\n  - Q65484 → P38398\n  - P12524 → P01106\n  - O15162 → Q9Y243\n- RefSeq root to primary UniProt mappings:\n  - NP_000537 → P04637\n  - NP_009225 → P38398\n  - NP_002458 → P01106\n  - NP_123456 → Q9Y243\n- GenInfo Identifier (GI) to RefSeq accession with version:\n  - gi|4557321 → NP_000537.2\n  - gi|8404561 → NP_009225.1\n  - gi|3154298 → NP_002458.1\n  - gi|15726711 → NP_123456.1\n- Gene symbol and synonym to primary UniProt mappings (case-insensitive):\n  - TP53, P53, TRP53 → P04637\n  - BRCA1, BRCC1 → P38398\n  - MYC, C-MYC → P01106\n  - SMAD7, MADH7 → Q9Y243\n\nResolution logic to implement:\n- Let the input token be a string $t$. Normalize $t$ by trimming whitespace.\n- Identify the token type in the following precedence:\n  1. If $t$ matches the GI pattern “gi|d” where $d$ is a nonempty sequence of digits, map to the RefSeq accession with version via the GI table, then drop the version to obtain the RefSeq root, then map the root to a primary UniProt accession.\n  2. Else if $t$ matches a RefSeq pattern of the form “NP_digits.version”, map the RefSeq root (the part before the dot) to a primary UniProt accession.\n  3. Else if $t$ matches a UniProt-like pattern with an isoform suffix “-i”: map the base accession to a primary (if it is secondary, first map secondary to primary), then select the canonical isoform for that primary as defined above.\n  4. Else if $t$ matches a UniProt-like accession without an isoform suffix: if it is secondary, map to the primary; if it is already primary, use it as-is.\n  5. Else treat $t$ as a gene symbol or synonym; map case-insensitively to the primary.\n- After obtaining a primary accession, select the canonical isoform for that primary as: if “ACC-1” exists, choose it; otherwise choose the isoform “ACC-i” with the smallest $i$ present in the registry keys.\n- If at any stage a mapping fails (missing key), the result for that test case is “not found”.\n\nQuantifiable outputs:\n- For each input token, output either:\n  - A two-element list $[L,H]$ where $L$ is the integer sequence length and $H$ is the unsigned $64$-bit FNV-1a hash in base-$10$, or\n  - The two-element list $[-1,-1]$ if the token cannot be resolved to any registry entry.\n\nTest suite:\n- Use the following input tokens, in order:\n  - \"TP53\"\n  - \"Q65484\"\n  - \"NP_002458.1\"\n  - \"gi|15726711\"\n  - \"P04637-2\"\n  - \"p53\"\n  - \"gi|99999999\"\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of two-element lists enclosed in square brackets (for example, \"[[L1,H1],[L2,H2],...]\" where each $L_i$ and $H_i$ are base-$10$ integers). No extra whitespace or text should be printed.", "solution": "The provided problem statement has been rigorously evaluated and is deemed valid. It is scientifically grounded in the principles of bioinformatics and molecular biology, well-posed with a deterministic resolution logic, and expressed with objective, unambiguous language. The task is to implement a resolution algorithm for biological identifiers based on a defined, self-contained registry and a set of explicit rules. We will now proceed with the formal solution.\n\nThe solution is structured into three primary components: data structure organization, implementation of the FNV-1a hash function, and the identifier resolution algorithm.\n\nFirst, we must represent the provided registry data in a computationally accessible format. Dictionaries, or associative arrays, are the appropriate data structure for these key-value mappings. We will define the following structures:\n\n1.  `ISOFORM_SEQUENCES`: Maps a composite key of the form \"ACC-isoformIndex\" (e.g., `P04637-1`) to its amino acid sequence string.\n2.  `UNIPROT_SECONDARY_TO_PRIMARY`: Maps a secondary UniProt accession to its corresponding primary accession.\n3.  `REFSEQ_TO_UNIPROT`: Maps a RefSeq root accession to a primary UniProt accession.\n4.  `GI_TO_REFSEQ`: Maps a GenInfo (GI) identifier to its full RefSeq accession, including the version.\n5.  `GENE_TO_UNIPROT`: Maps gene symbols and their synonyms to a primary UniProt accession. To accommodate the case-insensitivity requirement, all keys in this structure must be normalized, for instance, to uppercase, and lookup operations must be performed on the uppercase version of the input token.\n\nSecond, the FNV-1a hash function for an unsigned $64$-bit integer space must be implemented. The FNV-1a algorithm is defined by the following recurrence relation for a hash value $h$ and a sequence of bytes $b_1, b_2, \\dots, b_L$:\n- Initialization: $h_0 = \\text{offset\\_basis} = 1469598103934665603$\n- Recurrence: $h_i = (h_{i-1} \\oplus b_i) \\times \\text{prime} \\pmod{2^{64}}$ for $i=1, \\dots, L$.\n\nThe constants are the $64$-bit FNV prime, $p = 1099511628211$, and the $64$-bit FNV offset basis. The operations (XOR $\\oplus$, multiplication $\\times$) are performed using unsigned $64$-bit arithmetic, where overflow wraps around modulo $2^{64}$. This is a standard and deterministic procedure. The final hash value is $H = h_L$.\n\nThird, the core of the problem is the identifier resolution logic. This is an algorithm that processes an input token $t$ according to a strict hierarchy of rules to find a canonical protein sequence. Let us formalize the procedure.\n\n1.  **Normalization**: The input token $t$ is stripped of any leading or trailing whitespace.\n\n2.  **Type Identification and Resolution to Primary Accession**: A primary UniProt accession is derived by checking the token against patterns in a fixed order of precedence.\n    -   **Type 1 (GI)**: If $t$ matches the pattern `gi|d`, where $d$ is a sequence of digits, we look up `t` in the `GI_TO_REFSEQ` mapping. If successful, this yields a RefSeq accession with a version (e.g., `NP_000537.2`). We then extract the root part (e.g., `NP_000537`) by removing the `.version` suffix. This root is then used as a key in the `REFSEQ_TO_UNIPROT` map to obtain the primary UniProt accession. If any lookup fails, the resolution for this token terminates.\n    -   **Type 2 (RefSeq)**: If $t$ is not a GI number but matches the pattern `NP_digits.version`, we extract the root and proceed as in the latter part of the previous step, mapping the RefSeq root to a primary UniProt accession via `REFSEQ_TO_UNIPROT`.\n    -   **Type 3 (UniProt with Isoform)**: If $t$ matches the pattern `ACC-i`, we extract the base accession `ACC`. We must resolve `ACC` to a primary accession. If `ACC` is a secondary accession (i.e., a key in `UNIPROT_SECONDARY_TO_PRIMARY`), we map it to its primary accession. Otherwise, we assume `ACC` is itself the primary accession.\n    -   **Type 4 (UniProt without Isoform)**: If $t$ is a string that does not match the previous patterns, we check if it is a UniProt accession. If $t$ is found as a key in `UNIPROT_SECONDARY_TO_PRIMARY`, we map it to its primary accession. Otherwise, we assume $t$ is the primary accession.\n    -   **Type 5 (Gene Symbol)**: If all previous checks fail, we treat $t$ as a gene symbol. We convert $t$ to uppercase and look it up in the `GENE_TO_UNIPROT` map to find the primary UniProt accession.\n\n3.  **Canonical Isoform Selection**: After a primary UniProt accession, let us call it $P$, is successfully identified, we must select the corresponding canonical isoform sequence from the `ISOFORM_SEQUENCES` registry. The rule is as follows:\n    -   If an entry for the key `$P$-1` exists in the registry, its sequence is the canonical one.\n    -   Otherwise, we identify all existing isoforms for $P$ (i.e., all keys starting with `$P$-`). From this set, we select the one with the smallest isoform index $i$.\n    -   If no isoforms for $P$ are found in the registry, the resolution fails.\n\n4.  **Final Calculation and Output**: If a canonical sequence is successfully resolved, its length $L$ and its FNV-1a hash $H$ are calculated. The result is the pair $[L, H]$. If at any point the resolution fails (e.g., a key is not found in a map), the result is defined as $[-1, -1]$.\n\nFor example, consider the input token `\"P04637-2\"`.\n- It matches Type 3. The base accession is `P04637`. This is a primary accession.\n- The next step is to find the canonical isoform for `P04637`.\n- The registry contains `P04637-1`. According to the rule, since isoform `-1` exists, it is the canonical one.\n- The resolved sequence is thus the one associated with `P04637-1`, which is `MEEPQSDPSVEPPLSQETFSDLWKLL`.\n- The length is $L=26$, and its FNV-1a hash $H$ would be computed. The input's specified isoform `-2` is superseded by the rule to select the canonical isoform.\n\nThis procedure is deterministic and guarantees a unique result for every input token, given the provided registry. The implementation must follow these steps precisely.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport re\n\ndef solve():\n    # Registry data defined as per the problem statement\n    ISOFORM_SEQUENCES = {\n        \"P04637-1\": \"MEEPQSDPSVEPPLSQETFSDLWKLL\",\n        \"P04637-2\": \"MEEPQSDPSVEPPLSQETFSDLWKL\",\n        \"P38398-1\": \"MDLSALRVEEVQNVINAMQKILECPICLE\",\n        \"P01106-1\": \"MPLNVSFTNRNYDLDYDSVQPY\",\n        \"P01106-2\": \"MPLNVSFTNRNYDLDYDSVQP\",\n        \"Q9Y243-1\": \"MSSILPFTPPVKRLLGWKHPGKQL\",\n    }\n    \n    UNIPROT_SECONDARY_TO_PRIMARY = {\n        \"Q13616\": \"P04637\", \"Q65484\": \"P38398\", \"P12524\": \"P01106\", \"O15162\": \"Q9Y243\",\n    }\n    \n    REFSEQ_TO_UNIPROT = {\n        \"NP_000537\": \"P04637\", \"NP_009225\": \"P38398\", \"NP_002458\": \"P01106\", \"NP_123456\": \"Q9Y243\",\n    }\n    \n    GI_TO_REFSEQ = {\n        \"gi|4557321\": \"NP_000537.2\", \"gi|8404561\": \"NP_009225.1\", \"gi|3154298\": \"NP_002458.1\", \"gi|15726711\": \"NP_123456.1\",\n    }\n\n    # Gene symbol mapping is case-insensitive. We store keys in uppercase.\n    GENE_TO_UNIPROT = {\n        \"TP53\": \"P04637\", \"P53\": \"P04637\", \"TRP53\": \"P04637\",\n        \"BRCA1\": \"P38398\", \"BRCC1\": \"P38398\",\n        \"MYC\": \"P01106\", \"C-MYC\": \"P01106\",\n        \"SMAD7\": \"Q9Y243\", \"MADH7\": \"Q9Y243\",\n    }\n\n    # FNV-1a hash parameters\n    FNV_PRIME = np.uint64(1099511628211)\n    FNV_OFFSET_BASIS = np.uint64(1469598103934665603)\n\n    def fnv1a_hash(sequence_str):\n        \"\"\"Computes the 64-bit FNV-1a hash of a string.\"\"\"\n        h = FNV_OFFSET_BASIS\n        for byte in sequence_str.encode('ascii'):\n            h ^= np.uint64(byte)\n            h *= FNV_PRIME\n        return int(h)\n\n    def get_canonical_isoform_key(primary_acc):\n        \"\"\"Finds the canonical isoform for a given primary UniProt accession.\"\"\"\n        key_iso1 = f\"{primary_acc}-1\"\n        if key_iso1 in ISOFORM_SEQUENCES:\n            return key_iso1\n        \n        isoform_indices = []\n        for key in ISOFORM_SEQUENCES:\n            if key.startswith(f\"{primary_acc}-\"):\n                try:\n                    index_part = key.split('-')[1]\n                    isoform_indices.append(int(index_part))\n                except (ValueError, IndexError):\n                    continue\n        \n        if not isoform_indices:\n            return None\n        \n        min_index = min(isoform_indices)\n        return f\"{primary_acc}-{min_index}\"\n\n    def resolve_token(token):\n        \"\"\"Resolves an input token to a primary UniProt accession.\"\"\"\n        token = token.strip()\n        \n        # Rule 1: GI pattern\n        if token.startswith(\"gi|\") and token.split('|')[1].isdigit():\n            refseq_ver = GI_TO_REFSEQ.get(token)\n            if refseq_ver:\n                refseq_root = refseq_ver.split('.')[0]\n                return REFSEQ_TO_UNIPROT.get(refseq_root)\n            return None\n\n        # Rule 2: RefSeq pattern\n        if re.match(r\"^NP_\\d+\\.\\d+$\", token):\n            refseq_root = token.split('.')[0]\n            return REFSEQ_TO_UNIPROT.get(refseq_root)\n\n        # Rule 3: UniProt with isoform pattern\n        match = re.match(r\"^([A-Z0-9]+)-(\\d+)$\", token)\n        if match:\n            base_acc = match.group(1)\n            return UNIPROT_SECONDARY_TO_PRIMARY.get(base_acc, base_acc)\n\n        # Rule 4: UniProt without isoform\n        # A simple heuristic: if it's alphanumeric and in one of the relevant DBs\n        if re.match(r\"^[A-Z0-9]+$\", token):\n             # Check if it's secondary\n            if token in UNIPROT_SECONDARY_TO_PRIMARY:\n                return UNIPROT_SECONDARY_TO_PRIMARY[token]\n            # Check if it's a known primary through its isoforms\n            for key in ISOFORM_SEQUENCES:\n                if key.startswith(token + '-'):\n                    return token\n\n        # Rule 5: Gene symbol\n        primary_acc = GENE_TO_UNIPROT.get(token.upper())\n        if primary_acc:\n            return primary_acc\n\n        return None\n\n    def get_result(token):\n        \"\"\"Main logic to process one token and return the result.\"\"\"\n        primary_acc = resolve_token(token)\n        if not primary_acc:\n            return [-1, -1]\n        \n        canonical_key = get_canonical_isoform_key(primary_acc)\n        if not canonical_key:\n            return [-1, -1]\n            \n        sequence = ISOFORM_SEQUENCES.get(canonical_key)\n        if not sequence:\n            return [-1, -1]\n            \n        length = len(sequence)\n        hash_val = fnv1a_hash(sequence)\n        \n        return [length, hash_val]\n\n    # Test suite from the problem description\n    test_cases = [\n        \"TP53\",\n        \"Q65484\",\n        \"NP_002458.1\",\n        \"gi|15726711\",\n        \"P04637-2\",\n        \"p53\",\n        \"gi|99999999\"\n    ]\n\n    results = []\n    for case in test_cases:\n        result = get_result(case)\n        results.append(str(result))\n    \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2428399"}]}