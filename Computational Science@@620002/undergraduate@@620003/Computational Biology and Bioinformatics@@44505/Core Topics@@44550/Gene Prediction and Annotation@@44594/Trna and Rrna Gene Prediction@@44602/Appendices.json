{"hands_on_practices": [{"introduction": "The cornerstone of bioinformatics is translating biological knowledge into computational algorithms. This first exercise challenges you to do just that by building a simple, rule-based tRNA gene finder from first principles. By codifying features of the tRNA cloverleaf structure—such as the acceptor stem and anticodon loop—you will gain hands-on experience in pattern matching and develop an appreciation for the trade-offs involved in heuristic-based gene prediction [@problem_id:2438434].", "problem": "You are asked to implement a complete, runnable program that, given a fixed small test suite of synthetic deoxyribonucleic acid (DNA) sequences, performs rule-based transfer RNA (tRNA) gene prediction and compares its performance to a provided baseline from tRNAscan-SE (transfer RNA scan - Search Engine). The program must report precision and recall for both methods on each test case, in a single, specified output format.\n\nThe solution must be grounded in the following fundamentals and widely accepted biological facts:\n- The Central Dogma of molecular biology states that genetic information flows from DNA to ribonucleic acid (RNA) to protein. Transfer RNA (tRNA) genes encode structured RNA molecules that fold into a cloverleaf with conserved features, including an acceptor stem that base-pairs between the $5^{\\prime}$ and $3^{\\prime}$ ends, an anticodon arm with a loop of approximately fixed size, and a $T\\Psi C$ loop motif where the DNA-level motif commonly appears as the trinucleotide \"TTC\".\n- Canonical Watson–Crick base pairing is $A$–$T$ and $C$–$G$ in DNA, and wobble pairing in RNA often involves $G$–$U$; to accommodate heuristic detection in DNA, we will allow $G$–$T$ as an additional tolerated pairing during structural checks.\n\nYour program must implement a simple, rule-based tRNA gene finder that scans a DNA string and proposes candidate gene intervals based on the following three heuristic features:\n1) Anticodon hairpin: detect a hairpin with a stem length $s = 5$ nucleotides flanking a loop of length $\\ell = 7$ nucleotides. The two stems must be reverse-complementary under pairing $\\{A\\text{–}T, T\\text{–}A, C\\text{–}G, G\\text{–}C, G\\text{–}T, T\\text{–}G\\}$ with at most $m_s = 1$ mismatch.\n2) $T\\Psi C$-loop DNA motif: require that the motif \"TTC\" occurs within the final $d = 20$ nucleotides of the candidate window (that is, upstream of the window end).\n3) Acceptor stem: within the candidate window, require that the first $a = 7$ nucleotides and the last $a = 7$ nucleotides (or the $7$ nucleotides immediately preceding a terminal \"CCA\" if \"CCA\" occurs at the very end of the window) are reverse-complementary under the same pairing set, with at most $m_a = 1$ mismatch.\n\nCandidate windows must be formed as follows from each detected hairpin: if the left stem starts at index $i_{\\ell}$ and the right stem ends at index $i_{r}$ (end-exclusive), then define a window $[i_{\\ell} - w,\\, i_{r} + w)$ clipped to the sequence bounds, with $w = 25$. Discard candidate windows whose length falls outside $[60, 100]$ nucleotides. If multiple candidate windows overlap substantially, deduplicate them by merging any pair with Jaccard overlap greater than $0.8$ into their union interval.\n\nFor evaluation, treat each predicted interval as a set of indices and use the Jaccard overlap\n$$\nJ(I_p, I_t) \\;=\\; \\frac{|I_p \\cap I_t|}{|I_p \\cup I_t|}\n$$\nto match predicted intervals $I_p$ to true intervals $I_t$. A prediction counts as a true positive if it matches any not-yet-matched true interval with $J \\ge \\tau$, where $\\tau = 0.5$. Otherwise it is a false positive. Any true interval not matched by any prediction is a false negative. Define the standard counts True Positives ($\\mathrm{TP}$), False Positives ($\\mathrm{FP}$), and False Negatives ($\\mathrm{FN}$). Precision and recall are then\n$$\n\\text{precision} \\;=\\; \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}, \\qquad\n\\text{recall} \\;=\\; \\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}.\n$$\nUse the convention that if $\\mathrm{TP} + \\mathrm{FP} = 0$ then precision is defined as $1.0$, and if $\\mathrm{TP} + \\mathrm{FN} = 0$ then recall is defined as $1.0$.\n\nCoordinates are zero-based, half-open intervals $[s,e)$ where $s$ is the start index and $e$ is one past the last index, consistent with standard programming string slicing.\n\nYour program must compute, for each test case, the precision and recall of your rule-based finder and the precision and recall of the given baseline predictions attributed to tRNAscan-SE. All string operations are over the DNA alphabet $\\{A, C, G, T\\}$. There are no physical units involved.\n\nTest suite (three sequences), each provided as:\n- The DNA sequence string.\n- The ground-truth tRNA gene intervals as a list of $[s,e)$.\n- The baseline intervals (attributed to tRNAscan-SE) as a list of $[s,e)$.\n\nUse exactly these sequences and annotations:\n\nCase $1$ (general happy path):\n- Sequence:\n\"TTGACCGTTTGACCGTTTGACCGTTTGACCGTTTGACCGTGCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGTTCGAATGCTAAGCCCAGATCGATCGAGATCGATCGAGATCGATCGA\"\n- Ground truth: $[[40, 116))$.\n- Baseline (tRNAscan-SE): $[[40, 116))$.\n\nCase $2$ (boundary condition: gene at the start, no encoded CCA, challenging T-loop motif absent):\n- Sequence:\n\"GCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGAAAGAATGCTAAGC\" + \"GCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGT\"\n- Ground truth: $[[0, 73))$.\n- Baseline (tRNAscan-SE): $[[0, 73))$.\n\nCase $3$ (edge case: no true tRNA, presence of a tRNA-like decoy motif):\n- Sequence:\n\"AACCGGTTAACCGGTTAACC\" + \"ATGCCGAAAGGGGATCGACCGTATGAATTTTACGGATCGAATCGAAAGCAGTAGGTTCGAATTCGGCATCCAGATCGATCGATCGATCGATC\"\n- Ground truth: $[]$.\n- Baseline (tRNAscan-SE): $[]$.\n\nProgram output specification:\n- For each case in order $1, 2, 3$, compute four floating-point numbers rounded to exactly three decimal places: your method’s precision, your method’s recall, the baseline precision, and the baseline recall.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{P}_{1}, \\text{R}_{1}, \\text{P}^{\\mathrm{base}}_{1}, \\text{R}^{\\mathrm{base}}_{1}, \\text{P}_{2}, \\text{R}_{2}, \\text{P}^{\\mathrm{base}}_{2}, \\text{R}^{\\mathrm{base}}_{2}, \\text{P}_{3}, \\text{R}_{3}, \\text{P}^{\\mathrm{base}}_{3}, \\text{R}^{\\mathrm{base}}_{3}]$.\n\nAll numbers in the output are unitless real numbers represented as decimal strings rounded to three digits after the decimal point. No additional text may be printed.", "solution": "The problem proposed is a well-defined task in bioinformatics, specifically in the domain of rule-based gene prediction for transfer RNA (tRNA). The objective is to implement a specific, simplified algorithm for identifying tRNA genes in synthetic DNA sequences and to evaluate its performance against a given ground truth and a baseline prediction set.\n\n### Problem Validation\n\nThe problem statement has been validated and is deemed **valid**. A detailed breakdown of the validation process follows.\n\n**Step 1: Extraction of Givens**\nAll parameters, definitions, and data have been extracted verbatim from the problem statement:\n- **Heuristic Features**:\n    1.  Anticodon hairpin: stem length $s=5$, loop length $\\ell=7$, with at most $m_s=1$ mismatch in the stem.\n    2.  $T\\Psi C$-loop motif: DNA sequence \"TTC\" must be present within the last $d=20$ nucleotides of a candidate window.\n    3.  Acceptor stem: consists of the first and last $a=7$ nucleotides of the window, allowing at most $m_a=1$ mismatch. A special condition applies if the window ends in \"CCA\".\n- **Pairing Rules**: Watson-Crick pairs ($A$–$T$, $C$–$G$) plus wobble-like pairs ($G$–$T$).\n- **Candidate Generation**: A window of $[i_{\\ell} - w, i_{r} + w)$ (where $w=25$) is formed around a hairpin, filtered for length in $[60, 100]$, and deduplicated if Jaccard overlap exceeds $0.8$.\n- **Evaluation**: Performance is measured by precision and recall, where matches are determined by a Jaccard overlap threshold of $\\tau = 0.5$. Precision and recall are defined as $1.0$ if their respective denominators are zero.\n- **Data**: Three test cases are provided, each with a DNA sequence, ground truth intervals, and baseline prediction intervals.\n\n**Step 2: Validation Using Extracted Givens**\nThe problem is evaluated against the required criteria:\n- **Scientifically Grounded**: Yes. The problem uses a simplified but biologically plausible model of tRNA secondary structure (cloverleaf) and its conserved features. The algorithmic approach, based on pattern matching and heuristics, is a standard technique in bioinformatics.\n- **Well-Posed**: Yes. The algorithmic rules are specified with complete, unambiguous parameters. The inputs are provided, and the desired output format is precise. A unique solution is derivable.\n- **Objective**: Yes. The problem is stated in precise, quantitative terms, free from subjectivity.\n\n**Analysis of Potential Contradictions**:\nA close inspection reveals that the provided ground truth annotations in some test cases do not satisfy the search rules to be implemented. For instance:\n- In Case 1, the ground truth gene $[40, 116)$ fails the acceptor stem complementarity rule as specified (it has 4 mismatches where at most $m_a=1$ is allowed).\n- In Case 2, the ground truth gene $[0, 73)$ fails the $T\\Psi C$-loop motif rule, as it lacks a \"TTC\" sequence in the required region.\n\nThis is not a flaw that invalidates the problem. Instead, it is interpreted as a deliberate feature of the problem design. The task is not to create an algorithm that perfectly rediscovers the \"true\" annotations, but rather to implement the specified set of rules exactly and to then evaluate its performance. The discrepancy highlights the limitations of simple heuristic models against a more complex reality (or a more sophisticated prediction tool like tRNAscan-SE), which is a valuable scientific lesson. The problem remains a consistent, solvable challenge.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. The solution will proceed with the implementation of the algorithm as specified.\n\n### Algorithmic Solution Design\n\nThe solution is implemented as a systematic pipeline, translating the provided rules into distinct computational steps.\n\n1.  **Fundamental Data Structures and Rules**:\n    - The nucleotide pairing rules, $\\{A\\text{–}T, T\\text{–}A, C\\text{–}G, G\\text{–}C, G\\text{–}T, T\\text{–}G\\}$, are encoded into a look-up structure for efficient access.\n    - A helper function, `count_mismatches(seq1, seq2_rev)`, is defined to quantify the complementarity between two stem sequences according to these pairing rules.\n\n2.  **Step 1: Anticodon Hairpin Detection**:\n    The program scans the entire DNA sequence for potential anticodon hairpins. A hairpin is defined as a structure of length $s+\\ell+s = 5+7+5 = 17$ nucleotides. For each subsequence of this length, the first $5$ nucleotides (left stem) are compared to the reverse of the last $5$ nucleotides (right stem). If the number of mismatches is less than or equal to $m_s=1$, the start and end positions of the hairpin are recorded.\n\n3.  **Step 2: Candidate Window Generation and Initial Filtering**:\n    For each valid hairpin detected, a wider candidate window is proposed. If the hairpin is located at $[i_{\\ell}, i_{r})$, the initial window is defined as $[i_{\\ell} - w, i_{r} + w)$, with $w=25$. These coordinates are clipped to the boundaries of the DNA sequence. Each resulting window's length is checked, and only those with lengths in the range $[60, 100]$ are retained for further processing.\n\n4.  **Step 3: Candidate Deduplication**:\n    To handle redundant, overlapping candidates, a deduplication step is performed. This is modeled as a graph problem. Each candidate window is a node, and an edge is drawn between any two nodes if their Jaccard overlap is greater than $0.8$. The connected components of this graph are then identified. All candidate windows within a single component are merged into one super-interval, defined by the minimum start and maximum end coordinates of the intervals in that component. This yields a set of non-redundant candidate regions.\n\n5.  **Step 4: Final Feature-Based Filtering**:\n    The merged candidate windows are subjected to the final two heuristic checks:\n    - **$T\\Psi C$-loop Motif**: The last $d=20$ nucleotides of each candidate's sequence are searched for the presence of the \"TTC\" motif. If the motif is absent, the candidate is discarded.\n    - **Acceptor Stem**: The first $a=7$ nucleotides are compared to the last $a=7$ nucleotides for reverse complementarity. A special case handles windows ending in \"CCA\", where the $3^{\\prime}$ stem is taken from the $7$ nucleotides immediately preceding the \"CCA\". If the number of mismatches, $m_a$, exceeds $1$, the candidate is discarded.\n\n6.  **Step 5: Performance Evaluation**:\n    The final set of predicted intervals from the rule-based finder and the provided baseline intervals are each evaluated against the ground truth.\n    - True Positives ($\\mathrm{TP}$), False Positives ($\\mathrm{FP}$), and False Negatives ($\\mathrm{FN}$) are calculated. A prediction is matched to a true interval if their Jaccard overlap is at least $\\tau=0.5$. To ensure an optimal one-to-one mapping, a greedy matching strategy is employed, where pairs of predicted and true intervals are matched in descending order of their Jaccard score.\n    - Precision ($\\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$) and recall ($\\frac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FN}}$) are computed. The problem specifies a convention where a metric is $1.0$ if its denominator is $0$.\n\nThe entire process is applied to each of the three test cases, and the resulting four performance metrics (precision and recall for both the implemented finder and the baseline) per case are collected and formatted for the final output.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a rule-based tRNA gene finder and evaluates its performance\n    against a baseline on a fixed test suite.\n    \"\"\"\n\n    # -- Constants from problem statement --\n    S_STEM = 5\n    L_LOOP = 7\n    M_S_MISMATCH = 1\n    D_TLOOP = 20\n    A_STEM = 7\n    M_A_MISMATCH = 1\n    W_EXTEND = 25\n    MIN_LEN = 60\n    MAX_LEN = 100\n    JACCARD_MERGE_THRESH = 0.8\n    JACCARD_EVAL_THRESH = 0.5\n    \n    # -- Base pairing rules as specified --\n    PAIRS = {\n        ('A', 'T'), ('T', 'A'),\n        ('C', 'G'), ('G', 'C'),\n        ('G', 'T'), ('T', 'G')\n    }\n\n    def is_complementary(n1, n2):\n        \"\"\"Checks if two nucleotides are complementary.\"\"\"\n        return (n1, n2) in PAIRS\n\n    def count_mismatches(seq1, seq2_rev):\n        \"\"\"Counts mismatches between a sequence and a reversed sequence.\"\"\"\n        mismatches = 0\n        for n1, n2 in zip(seq1, seq2_rev):\n            if not is_complementary(n1, n2):\n                mismatches += 1\n        return mismatches\n\n    def jaccard_overlap(interval1, interval2):\n        \"\"\"Calculates Jaccard overlap between two [start, end) intervals.\"\"\"\n        s1, e1 = interval1\n        s2, e2 = interval2\n        \n        intersection_start = max(s1, s2)\n        intersection_end = min(e1, e2)\n        \n        intersection_size = max(0, intersection_end - intersection_start)\n            \n        union_size = (e1 - s1) + (e2 - s2) - intersection_size\n        \n        if union_size == 0:\n            return 1.0 if intersection_size > 0 else 0.0\n        \n        return intersection_size / union_size\n\n    def evaluate_predictions(predicted, true_intervals):\n        \"\"\"Calculates precision and recall.\"\"\"\n        # Handle cases with empty sets as per problem definition\n        if not true_intervals:\n            # TP=0, FN=0 -> Recall = 1.0\n            # If nothing predicted, FP=0 -> Precision = 1.0\n            # If something predicted, FP > 0 -> Precision = 0.0\n            return 1.0 if not predicted else 0.0, 1.0\n        if not predicted: # True intervals exist, but no predictions\n            # TP=0, FP=0 -> Precision = 1.0\n            # TP=0, FN>0 -> Recall = 0.0\n            return 1.0, 0.0\n\n        n_pred = len(predicted)\n        n_true = len(true_intervals)\n        \n        # Greedily find best matches to solve assignment problem\n        potential_matches = []\n        for i, p_interval in enumerate(predicted):\n            for j, t_interval in enumerate(true_intervals):\n                j_score = jaccard_overlap(p_interval, t_interval)\n                if j_score >= JACCARD_EVAL_THRESH:\n                    potential_matches.append((j_score, i, j))\n        \n        potential_matches.sort(key=lambda x: x[0], reverse=True)\n        \n        matched_preds = set()\n        matched_trues = set()\n        tp = 0\n        \n        for _, p_idx, t_idx in potential_matches:\n            if p_idx not in matched_preds and t_idx not in matched_trues:\n                tp += 1\n                matched_preds.add(p_idx)\n                matched_trues.add(t_idx)\n\n        fp = n_pred - tp\n        fn = n_true - tp\n        \n        precision = 1.0 if (tp + fp) == 0 else tp / (tp + fp)\n        recall = 1.0 if (tp + fn) == 0 else tp / (tp + fn)\n        \n        return precision, recall\n\n    def run_finder(sequence):\n        \"\"\"Executes the full tRNA finding algorithm.\"\"\"\n        seq_len = len(sequence)\n        \n        # 1. Anticodon hairpin detection\n        hairpins = []\n        hairpin_len = S_STEM + L_LOOP + S_STEM\n        for i in range(seq_len - hairpin_len + 1):\n            left_stem = sequence[i : i + S_STEM]\n            right_stem_rev = sequence[i + S_STEM + L_LOOP : i + hairpin_len][::-1]\n            \n            if count_mismatches(left_stem, right_stem_rev) <= M_S_MISMATCH:\n                hairpins.append((i, i + hairpin_len))\n\n        # 2. Candidate window formation and length filtering\n        candidates = []\n        for start_pos, end_pos in hairpins:\n            win_start = max(0, start_pos - W_EXTEND)\n            win_end = min(seq_len, end_pos + W_EXTEND)\n            \n            if MIN_LEN <= (win_end - win_start) <= MAX_LEN:\n                candidates.append([win_start, win_end])\n        \n        if not candidates:\n            return []\n        \n        # 3. Deduplication via connected components\n        num_candidates = len(candidates)\n        adj = [[] for _ in range(num_candidates)]\n        for i in range(num_candidates):\n            for j in range(i + 1, num_candidates):\n                if jaccard_overlap(candidates[i], candidates[j]) > JACCARD_MERGE_THRESH:\n                    adj[i].append(j)\n                    adj[j].append(i)\n        \n        visited = [False] * num_candidates\n        dedup_candidates = []\n        for i in range(num_candidates):\n            if not visited[i]:\n                component_indices = []\n                q = [i]\n                visited[i] = True\n                head = 0\n                while head < len(q):\n                    u = q[head]; head += 1\n                    component_indices.append(u)\n                    for v in adj[u]:\n                        if not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                \n                min_start = min(candidates[k][0] for k in component_indices)\n                max_end = max(candidates[k][1] for k in component_indices)\n                dedup_candidates.append([min_start, max_end])\n\n        # 4. Final filtering based on features\n        final_predictions = []\n        for start, end in dedup_candidates:\n            # T-loop motif filter\n            t_loop_search_region = sequence[max(start, end - D_TLOOP):end]\n            if \"TTC\" not in t_loop_search_region:\n                continue\n            \n            # Acceptor stem filter\n            window_slice = sequence[start:end]\n            if len(window_slice) < A_STEM * 2:\n                continue\n\n            stem5_prime = window_slice[:A_STEM]\n            \n            if window_slice.endswith(\"CCA\"):\n                stem3_prime_start_in_slice = len(window_slice) - 3 - A_STEM\n                stem3_prime_end_in_slice = len(window_slice) - 3\n                if stem3_prime_start_in_slice < 0: continue\n                stem3_prime = window_slice[stem3_prime_start_in_slice:stem3_prime_end_in_slice]\n            else:\n                stem3_prime = window_slice[-A_STEM:]\n            \n            stem3_prime_rev = stem3_prime[::-1]\n            if len(stem5_prime) != len(stem3_prime_rev): continue\n\n            if count_mismatches(stem5_prime, stem3_prime_rev) <= M_A_MISMATCH:\n                final_predictions.append([start, end])\n                \n        return final_predictions\n\n    # -- Test Suite Definition --\n    test_cases = [\n        {\n            \"seq\": \"TTGACCGTTTGACCGTTTGACCGTTTGACCGTTTGACCGTGCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGTTCGAATGCTAAGCCCAGATCGATCGAGATCGATCGAGATCGATCGA\",\n            \"true\": [[40, 116]],\n            \"base\": [[40, 116]]\n        },\n        {\n            \"seq\": \"GCTTAGCGAGGGTATCGATCGTGCGTATGAATTTTACGCATCGATCGAAAAGCAGTAGGAAAGAATGCTAAGCGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGTGCGT\",\n            \"true\": [[0, 73]],\n            \"base\": [[0, 73]]\n        },\n        {\n            \"seq\": \"AACCGGTTAACCGGTTAACCATGCCGAAAGGGGATCGACCGTATGAATTTTACGGATCGAATCGAAAGCAGTAGGTTCGAATTCGGCATCCAGATCGATCGATCGATCGATC\",\n            \"true\": [],\n            \"base\": []\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        my_predictions = run_finder(case[\"seq\"])\n        \n        my_prec, my_rec = evaluate_predictions(my_predictions, case[\"true\"])\n        base_prec, base_rec = evaluate_predictions(case[\"base\"], case[\"true\"])\n        \n        all_results.extend([my_prec, my_rec, base_prec, base_rec])\n\n    formatted_results = [f\"{x:.3f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2438434"}, {"introduction": "Why do tRNA molecules fold into such specific shapes? The answer lies in thermodynamics. This practice moves beyond simple pattern recognition to explore the biophysical principles governing RNA stability [@problem_id:2438407]. Using a simplified energy model, you will calculate the change in folding free energy, $\\Delta E$, caused by a single nucleotide polymorphism (SNP), providing a quantitative understanding of how genetic variations can impact molecular structure and function.", "problem": "You are given a simplified, self-contained thermodynamic model to approximate the folding free energy of the D-stem and D-loop substructure of a transfer ribonucleic acid (tRNA) hairpin, inspired by energy functions used in folding predictors such as RNAfold. Consider a hairpin composed of a left arm, a loop, and a right arm. Let the left arm be a string of nucleotides of length $k$, the loop be a string of nucleotides of length $L \\geq 3$, and the right arm be a string of nucleotides of length $k$. The base pairing occurs positionally as $(\\text{left}[i], \\text{right}[k+1-i])$ for $i \\in \\{1,\\dots,k\\}$, where indices are $1$-based. A single nucleotide polymorphism (SNP) is an alteration of exactly one nucleotide in the loop at a specified $1$-based position.\n\nDefine the total folding free energy $E$ in kilocalories per mole as\n$$\nE = \\sum_{i=1}^{k} e_{\\text{pair}}\\big(\\text{left}[i], \\text{right}[k+1-i]\\big) + e_{\\text{loop}}(\\text{loop}) + e_{\\text{terminal}}\\big(\\text{left}[k], \\text{right}[1]\\big),\n$$\nwhere:\n- $e_{\\text{pair}}(x,y)$ is the base pair contribution with the following values (all in kilocalories per mole):\n  - $e_{\\text{pair}}(\\text{G},\\text{C}) = -3.0$, $e_{\\text{pair}}(\\text{C},\\text{G}) = -3.0$,\n  - $e_{\\text{pair}}(\\text{A},\\text{U}) = -2.0$, $e_{\\text{pair}}(\\text{U},\\text{A}) = -2.0$,\n  - $e_{\\text{pair}}(\\text{G},\\text{U}) = -1.0$, $e_{\\text{pair}}(\\text{U},\\text{G}) = -1.0$,\n  - for any other pair $e_{\\text{pair}}(x,y) = +5.0$.\n- $e_{\\text{loop}}(\\text{loop})$ is the loop initiation penalty plus any sequence-dependent bonus for a stable tetraloop motif:\n  $$\n  e_{\\text{loop}}(\\text{loop}) = a + b \\cdot L + c_{\\text{motif}}(\\text{loop}),\n  $$\n  with $a = 3.0$ and $b = 0.4$ (both in kilocalories per mole), and where\n  $$\n  c_{\\text{motif}}(\\text{loop}) =\n  \\begin{cases}\n  -2.0, & \\text{if } L = 4 \\text{ and loop matches a GNRA motif (}\\text{G}\\ \\text{N}\\ \\text{R}\\ \\text{A}\\text{) or a UNCG motif (}\\text{U}\\ \\text{N}\\ \\text{C}\\ \\text{G}\\text{)}, \\\\\n  0.0, & \\text{otherwise}.\n  \\end{cases}\n  $$\n  Here, $\\text{N}$ denotes any nucleotide in $\\{\\text{A}, \\text{C}, \\text{G}, \\text{U}\\}$ and $\\text{R}$ denotes any purine in $\\{\\text{A}, \\text{G}\\}$.\n- $e_{\\text{terminal}}(x,y)$ is a terminal closing penalty applied based on the closing pair $(\\text{left}[k], \\text{right}[1])$:\n  $$\n  e_{\\text{terminal}}(x,y) =\n  \\begin{cases}\n  +0.5, & \\text{if } (x,y) \\in \\{(\\text{A},\\text{U}),(\\text{U},\\text{A}),(\\text{G},\\text{U}),(\\text{U},\\text{G})\\}, \\\\\n  0.0, & \\text{otherwise}.\n  \\end{cases}\n  $$\n\nFor each case, let the wild-type sequence be defined by $(\\text{left}, \\text{loop}, \\text{right})$, and the mutant sequence be identical except for a single nucleotide change in the loop at the specified position. For each case, compute the change in folding free energy\n$$\n\\Delta E = E_{\\text{mut}} - E_{\\text{wt}},\n$$\nin kilocalories per mole. Report $\\Delta E$ rounded to exactly $3$ decimal places. Answer in kilocalories per mole.\n\nYour program must hard-code the following test suite and compute the results in the specified order:\n\n- Case $1$ (happy path; disruption of a stable tetraloop):\n  - left $=$ \"GGG\", loop $=$ \"GAAA\", right $=$ \"CCC\", SNP position $=$ $3$, mutant nucleotide $=$ \"C\".\n- Case $2$ (creation of a stable tetraloop):\n  - left $=$ \"GCG\", loop $=$ \"GAUA\", right $=$ \"CGC\", SNP position $=$ $3$, mutant nucleotide $=$ \"A\".\n- Case $3$ (boundary loop length and no change):\n  - left $=$ \"GCGC\", loop $=$ \"AUG\", right $=$ \"GCGC\", SNP position $=$ $2$, mutant nucleotide $=$ \"U\".\n- Case $4$ (terminal AU penalty present; no motif change):\n  - left $=$ \"GCA\", loop $=$ \"CCAUUG\", right $=$ \"UGC\", SNP position $=$ $4$, mutant nucleotide $=$ \"G\".\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above, for example: \"[x1,x2,x3,x4]\". Each $x_i$ must be a float formatted to exactly $3$ decimal places. No additional output is permitted.", "solution": "The problem requires the computation of the change in folding free energy, $\\Delta E$, of a model RNA hairpin due to a single nucleotide polymorphism (SNP) in its loop region. The total free energy, $E$, is given by the sum of three distinct contributions:\n$$\nE = E_{\\text{stem}} + E_{\\text{loop}} + E_{\\text{terminal}}\n$$\nwhere\n$$\nE_{\\text{stem}} = \\sum_{i=1}^{k} e_{\\text{pair}}\\big(\\text{left}[i], \\text{right}[k+1-i]\\big)\n$$\n$$\nE_{\\text{loop}} = e_{\\text{loop}}(\\text{loop}) = a + b \\cdot L + c_{\\text{motif}}(\\text{loop})\n$$\n$$\nE_{\\text{terminal}} = e_{\\text{terminal}}\\big(\\text{left}[k], \\text{right}[1]\\big)\n$$\nThe change in free energy, $\\Delta E$, is defined as the difference between the mutant and wild-type energies:\n$$\n\\Delta E = E_{\\text{mut}} - E_{\\text{wt}}\n$$\nWe can express this as:\n$$\n\\Delta E = (E_{\\text{stem,mut}} + E_{\\text{loop,mut}} + E_{\\text{terminal,mut}}) - (E_{\\text{stem,wt}} + E_{\\text{loop,wt}} + E_{\\text{terminal,wt}})\n$$\nA critical observation must be made first. The problem states that the SNP is an \"alteration of exactly one nucleotide in the loop\". This implies that the sequences of the left and right arms of the stem are identical for both the wild-type and mutant structures. This has profound consequences for the calculation.\n\n1.  The stem energy term, $E_{\\text{stem}}$, is a function solely of the `left` and `right` arm sequences. Since these are unchanged, $E_{\\text{stem,mut}} = E_{\\text{stem,wt}}$.\n2.  The terminal penalty, $E_{\\text{terminal}}$, is a function of the closing base pair, $(\\text{left}[k], \\text{right}[1])$, which is part of the unchanged stem. Therefore, $E_{\\text{terminal,mut}} = E_{\\text{terminal,wt}}$.\n\nBy substituting these equalities, the expression for $\\Delta E$ simplifies significantly:\n$$\n\\Delta E = (E_{\\text{stem,wt}} + E_{\\text{loop,mut}} + E_{\\text{terminal,wt}}) - (E_{\\text{stem,wt}} + E_{\\text{loop,wt}} + E_{\\text{terminal,wt}})\n$$\n$$\n\\Delta E = E_{\\text{loop,mut}} - E_{\\text{loop,wt}}\n$$\nNow, let us examine the loop energy term, $e_{\\text{loop}}(\\text{loop}) = a + b \\cdot L + c_{\\text{motif}}(\\text{loop})$. The SNP is a substitution, which does not alter the length, $L$, of the loop. Thus, $L_{\\text{mut}} = L_{\\text{wt}} = L$. The parameters $a=3.0$ and $b=0.4$ are constants. This leads to a further simplification:\n$$\n\\Delta E = (a + b \\cdot L + c_{\\text{motif}}(\\text{loop}_{\\text{mut}})) - (a + b \\cdot L + c_{\\text{motif}}(\\text{loop}_{\\text{wt}}))\n$$\nThe terms $a$ and $b \\cdot L$ cancel, leaving only the difference in the motif-dependent contribution:\n$$\n\\Delta E = c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) - c_{\\text{motif}}(\\text{loop}_{\\text{wt}})\n$$\nThe calculation is thus reduced to evaluating the $c_{\\text{motif}}$ term for the wild-type and mutant loops. The value of $c_{\\text{motif}}$ is $-2.0 \\text{ kcal/mol}$ if the loop has length $L=4$ and matches a GNRA or UNCG motif, and $0.0 \\text{ kcal/mol}$ otherwise. We now proceed to analyze each case using this simplified formula.\n\n**Case 1:**\n- Wild-type loop: $\\text{loop}_{\\text{wt}} = \\text{\"GAAA\"}$. The length is $L=4$. This sequence matches the GNRA motif, where $\\text{N} = \\text{A}$ and $\\text{R} = \\text{A}$. Therefore, $c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = -2.0$.\n- Mutant loop: The SNP at position $3$ changes the loop to $\\text{loop}_{\\text{mut}} = \\text{\"GACA\"}$. The length is still $L=4$. This sequence does not match the GNRA motif, because the third base, 'C', is not a purine ($\\text{R} \\in \\{\\text{A}, \\text{G}\\}$). It also does not match the UNCG motif. Thus, $c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = 0.0$.\n- Change in energy: $\\Delta E = 0.0 - (-2.0) = +2.0 \\text{ kcal/mol}$.\n\n**Case 2:**\n- Wild-type loop: $\\text{loop}_{\\text{wt}} = \\text{\"GAUA\"}$. The length is $L=4$. This does not match the GNRA motif, because the third base, 'U', is not a purine. It does not match the UNCG motif. Thus, $c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = 0.0$.\n- Mutant loop: The SNP at position $3$ changes the loop to $\\text{loop}_{\\text{mut}} = \\text{\"GAAA\"}$. As established in Case 1, this is a valid GNRA motif. Thus, $c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = -2.0$.\n- Change in energy: $\\Delta E = -2.0 - 0.0 = -2.0 \\text{ kcal/mol}$.\n\n**Case 3:**\n- Wild-type loop: $\\text{loop}_{\\text{wt}} = \\text{\"AUG\"}$. The length is $L=3$. The special motif contribution applies only for $L=4$. Thus, $c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = 0.0$.\n- Mutant loop: The SNP at position $2$ changes the loop to $\\text{loop}_{\\text{mut}} = \\text{\"UUG\"}$. The length remains $L=3$. Thus, $c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = 0.0$.\n- Change in energy: $\\Delta E = 0.0 - 0.0 = 0.0 \\text{ kcal/mol}$.\n\n**Case 4:**\n- Wild-type loop: $\\text{loop}_{\\text{wt}} = \\text{\"CCAUUG\"}$. The length is $L=6$. The special motif contribution applies only for $L=4$. Thus, $c_{\\text{motif}}(\\text{loop}_{\\text{wt}}) = 0.0$.\n- Mutant loop: The SNP at position $4$ changes the loop to $\\text{loop}_{\\text{mut}} = \\text{\"CCAGUG\"}$. The length remains $L=6$. Thus, $c_{\\text{motif}}(\\text{loop}_{\\text{mut}}) = 0.0$.\n- Change in energy: $\\Delta E = 0.0 - 0.0 = 0.0 \\text{ kcal/mol}$.\n\nThis completes the analysis for all specified test cases. The results are derived directly from the fundamental structure of the provided energy model.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the change in folding free energy (Delta E) for a series of\n    RNA hairpin mutants based on a simplified thermodynamic model.\n    \"\"\"\n\n    def calculate_c_motif(loop: str) -> float:\n        \"\"\"\n        Calculates the motif-dependent energy contribution (c_motif).\n        \n        Args:\n            loop: The nucleotide sequence of the loop.\n        \n        Returns:\n            The energy contribution in kcal/mol, which is -2.0 for stable\n            tetraloops (GNRA, UNCG) and 0.0 otherwise.\n        \"\"\"\n        L = len(loop)\n        if L != 4:\n            return 0.0\n        \n        # Check for GNRA motif: G-N-R-A, where N is any base and R is a purine (A or G).\n        if loop[0] == 'G' and loop[2] in ('A', 'G') and loop[3] == 'A':\n            return -2.0\n            \n        # Check for UNCG motif: U-N-C-G, where N is any base.\n        if loop[0] == 'U' and loop[2] == 'C' and loop[3] == 'G':\n            return -2.0\n            \n        return 0.0\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (left_arm, loop, right_arm, snp_position_1_based, mutant_nucleotide)\n    test_cases = [\n        (\"GGG\", \"GAAA\", \"CCC\", 3, \"C\"),      # Case 1\n        (\"GCG\", \"GAUA\", \"CGC\", 3, \"A\"),      # Case 2\n        (\"GCGC\", \"AUG\", \"GCGC\", 2, \"U\"),     # Case 3\n        (\"GCA\", \"CCAUUG\", \"UGC\", 4, \"G\"),    # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current test case.\n        # The left and right arms are not needed due to the analytical simplification.\n        _, wt_loop, _, snp_pos, mut_nuc = case\n        \n        # The change in energy simplifies to the difference in the c_motif term,\n        # as the stem and basic loop penalty terms cancel out.\n        # Delta E = c_motif(mutant) - c_motif(wild-type)\n        \n        # Calculate c_motif for the wild-type loop.\n        c_motif_wt = calculate_c_motif(wt_loop)\n\n        # Generate the mutant loop sequence by applying the SNP.\n        # Convert 1-based SNP position to 0-based index for Python string manipulation.\n        mut_pos_0_based = snp_pos - 1\n        mut_loop_list = list(wt_loop)\n        mut_loop_list[mut_pos_0_based] = mut_nuc\n        mut_loop = \"\".join(mut_loop_list)\n        \n        # Calculate c_motif for the mutant loop.\n        c_motif_mut = calculate_c_motif(mut_loop)\n        \n        # Calculate the final change in free energy.\n        delta_e = c_motif_mut - c_motif_wt\n        \n        # Format the result to exactly 3 decimal places and append to the list.\n        results.append(f\"{delta_e:.3f}\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2438407"}, {"introduction": "Genomes often contain fascinating exceptions to the rules, and permuted tRNA genes are a prime example. This advanced exercise challenges you to think beyond the textbook linear gene model and develop an algorithm to detect these non-canonical structures, where the gene's halves are swapped in the DNA sequence [@problem_id:2438454]. By searching for a circular permutation that restores the canonical tRNA fold, you will apply algorithmic problem-solving to uncover hidden biological complexity.", "problem": "You are asked to formalize and implement a detector for permuted transfer RNA (tRNA) genes using only sequence-level information. In some Archaea and a few Bacteria, permuted tRNA genes are encoded such that the $3^{\\prime}$ half precedes the $5^{\\prime}$ half in the genome, with a short linker separating the halves. After transcription and processing, the halves are re-ordered to yield a standard tRNA folding into the characteristic cloverleaf secondary structure. You must design a method that, given a DNA sequence, decides whether it is more consistent with a permuted tRNA gene than with a canonical (non-permuted) tRNA gene, under a simplified and principled model.\n\nStart from the following fundamentals and well-tested facts:\n- The Central Dogma of Molecular Biology states that DNA is transcribed into RNA, which can fold via base pairing to form functional structures; tRNA is a structured RNA with conserved stems and loops.\n- Watson–Crick base pairing in nucleic acids pairs adenine with thymine in DNA (adenine with uracil in RNA) and cytosine with guanine. We restrict to DNA here with the canonical pairs: A–T and C–G.\n- In standard tRNA, the acceptor stem is formed by base pairing between the $5^{\\prime}$ and $3^{\\prime}$ termini, typically with approximately $7$ contiguous canonical base pairs. The anticodon stem typically comprises approximately $5$ base pairs flanking the anticodon loop.\n\nYou will use these facts to construct a detection algorithm grounded in the following simplified mathematical model:\n- A DNA sequence $s$ of length $n$ over the alphabet $\\{A,C,G,T\\}$ is called tRNA-like if and only if two conditions hold simultaneously.\n  1. Acceptor-stem condition: There exist nonnegative integers $t$ and $u$ with $0 \\le t \\le g$, $0 \\le u \\le g$, and an integer $k_{\\mathrm{acc}}$ such that the $k_{\\mathrm{acc}}$-mer prefix $s[t \\dots t + k_{\\mathrm{acc}} - 1]$ and the $k_{\\mathrm{acc}}$-mer suffix $s[n - u - k_{\\mathrm{acc}} \\dots n - u - 1]$ can form at least $k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$ Watson–Crick pairs when aligned in antiparallel orientation. Formally, letting $\\operatorname{wc}(x,y)$ be $1$ if $x$ and $y$ are Watson–Crick complements and $0$ otherwise, the score\n  $$ S_{\\mathrm{acc}}(s,t,u) = \\sum_{i=0}^{k_{\\mathrm{acc}}-1} \\operatorname{wc}\\!\\Big(s[t+i],\\, s[n - u - 1 - i]\\Big) $$\n  must satisfy $S_{\\mathrm{acc}}(s,t,u) \\ge k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$ for some choice of $t$ and $u$ within bounds.\n  2. Anticodon-stem condition: There exist integers $i$ and $\\ell$ such that $0 \\le i$, $\\, \\ell_{\\min} \\le \\ell \\le \\ell_{\\max}$, and $i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} \\le n$, for which the two $k_{\\mathrm{anti}}$-mers $s[i \\dots i + k_{\\mathrm{anti}} - 1]$ and $s[i + k_{\\mathrm{anti}} + \\ell \\dots i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} - 1]$ form at least $k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$ Watson–Crick pairs in antiparallel orientation. The corresponding score is\n  $$ S_{\\mathrm{anti}}(s,i,\\ell) = \\sum_{j=0}^{k_{\\mathrm{anti}}-1} \\operatorname{wc}\\!\\Big(s[i+j],\\, s[i + k_{\\mathrm{anti}} + \\ell + k_{\\mathrm{anti}} - 1 - j]\\Big), $$\n  which must satisfy $S_{\\mathrm{anti}}(s,i,\\ell) \\ge k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$ for some $i$ and $\\ell$ within bounds.\n- A rotation of $s$ by $p$ positions, denoted $R_p(s)$, is the sequence $s[p] s[p+1] \\dots s[n-1] s[0] s[1] \\dots s[p-1]$ for any integer $p$ with $0 \\le p < n$.\n- A DNA sequence $s$ is declared a permuted tRNA gene if and only if there exists a rotation $R_p(s)$ with $1 \\le p \\le n-1$ that is tRNA-like under the above model, while the unrotated sequence $R_0(s)=s$ is not tRNA-like. This encodes the notion that a circularly permuted ordering reveals a standard tRNA-like organization, whereas the given order does not.\n\nUse the fixed parameter values\n- $k_{\\mathrm{acc}} = 7$, $m_{\\mathrm{acc}} = 1$, and trimming bound $g = 2$,\n- $k_{\\mathrm{anti}} = 5$, $m_{\\mathrm{anti}} = 1$, with anticodon loop bounds $\\ell_{\\min} = 5$ and $\\ell_{\\max} = 9$.\nAdditionally, only consider sequences with length $n$ satisfying $35 \\le n \\le 100$ as eligible for tRNA-like evaluation; sequences outside this range should be classified as not permuted.\n\nYour task\n- Implement a program that, for each provided test sequence, outputs a boolean indicating whether the sequence is a permuted tRNA gene according to the above model and parameters.\n- The Watson–Crick complement rule for DNA must be used with the canonical pairs A–T and C–G only.\n- The algorithm must be general and must not rely on any hard-coded coordinates particular to any one test sequence.\n\nTest suite\nEvaluate your program on the following $5$ DNA sequences (strings composed of A, C, G, T). They are intentionally constructed to exercise the decision logic.\n\n1. S1: GCGATTCTTTAGCAAGGTGTCATGAACCTTCCGTTTGAATCGC\n2. S2: CATGAACCTTCCGTTTGAATCGCATGCGATTCTTTAGCAAGGTGT\n3. S3: ACGTCGATGACAGTCAGTACGATCGATCGTACGAGTCTAAGCTAGTC\n4. S4: ACGTACGTACGT\n5. S5: CATGAACCTTCCGTTTGAATCGTATGCGATTCTTTAGCAAGGTGT\n\nInterpretation notes\n- S1 is a canonical tRNA-like construct under this model.\n- S2 and S5 are circularly permuted variants of a tRNA-like construct, separated by a short linker of length $2$, with S5 also containing exactly one mismatch in the acceptor-stem pairing relative to the ideal.\n- S3 is a generic non-tRNA-like sequence.\n- S4 is too short to be considered.\n\nFinal output format\nYour program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets. For example, an output for three cases could look like [True,False,True]. Apply this exact format to the five sequences above, in order, yielding a list of length $5$.", "solution": "The problem statement has been rigorously validated. It is scientifically grounded in the principles of molecular biology, specifically transfer RNA (tRNA) structure and gene organization. The model provided is a simplified but mathematically precise and well-posed abstraction, suitable for algorithmic implementation. All parameters and constraints are explicitly defined, rendering the problem self-contained and free of contradiction or ambiguity. Therefore, a formal solution is not only possible but required.\n\nThe task is to implement a classifier that determines if a given DNA sequence $s$ represents a permuted tRNA gene. According to the provided model, a sequence $s$ is classified as a permuted tRNA if and only if:\n$1$. Its length $n$ is within the inclusive range $[35, 100]$.\n$2$. The original sequence $s = R_0(s)$ is not \"tRNA-like\".\n$3$. There exists at least one non-trivial circular permutation $R_p(s)$ for $p \\in \\{1, \\dots, n-1\\}$ that is \"tRNA-like\".\n\nThe core of the problem is thus to construct a function that can test if an arbitrary sequence is \"tRNA-like\". A sequence is defined as tRNA-like if it simultaneously satisfies two structural conditions: the acceptor-stem condition and the anticodon-stem condition. The solution is therefore designed in a modular, hierarchical fashion.\n\nFirst, we define a boolean function, $\\operatorname{wc}(b_1, b_2)$, which returns $1$ if the bases $b_1, b_2 \\in \\{ \\text{A, C, G, T} \\}$ form a canonical Watson-Crick pair (A-T or C-G), and $0$ otherwise.\n\nNext, we formalize the algorithm for the acceptor-stem condition. A sequence $s$ of length $n$ satisfies this condition if there exist integers $t$ and $u$ such that $0 \\le t \\le g$ and $0 \\le u \\le g$, for which the score $S_{\\mathrm{acc}}(s,t,u) \\ge k_{\\mathrm{acc}} - m_{\\mathrm{acc}}$. The parameters are fixed: acceptor stem length $k_{\\mathrm{acc}}=7$, maximum mismatches $m_{\\mathrm{acc}}=1$, and maximum end-trimming $g=2$. The required score threshold is thus $7-1=6$. The algorithm must systematically check all possible pairs of $(t,u)$ in the search space $\\{0, 1, 2\\} \\times \\{0, 1, 2\\}$. For each pair, it computes the score:\n$$ S_{\\mathrm{acc}}(s,t,u) = \\sum_{i=0}^{k_{\\mathrm{acc}}-1} \\operatorname{wc}\\!\\Big(s[t+i],\\, s[n - u - 1 - i]\\Big) $$\nIf any pair $(t,u)$ yields a score of at least $6$, the condition is met.\n\nThen, we formalize the algorithm for the anticodon-stem condition. A sequence $s$ satisfies this if there exist integers $i$ and $\\ell$ satisfying $0 \\le i$, $\\ell_{\\min} \\le \\ell \\le \\ell_{\\max}$, and $i + 2k_{\\mathrm{anti}} + \\ell \\le n$, for which the score $S_{\\mathrm{anti}}(s,i,\\ell) \\ge k_{\\mathrm{anti}} - m_{\\mathrm{anti}}$. The parameters are fixed: anticodon stem length $k_{\\mathrm{anti}}=5$, maximum mismatches $m_{\\mathrm{anti}}=1$, and loop length bounds $\\ell_{\\min}=5, \\ell_{\\max}=9$. The required score threshold is $5-1=4$. The algorithm must perform a nested search. The outer loop iterates through possible loop lengths $\\ell \\in \\{5, 6, 7, 8, 9\\}$. The inner loop iterates through all possible start positions $i$ for the stem-loop structure, from $i=0$ up to the maximum possible value $n - (2k_{\\mathrm{anti}} + \\ell)$. For each pair $(i, \\ell)$, the score is computed:\n$$ S_{\\mathrm{anti}}(s,i,\\ell) = \\sum_{j=0}^{k_{\\mathrm{anti}}-1} \\operatorname{wc}\\!\\Big(s[i+j],\\, s[i + 2k_{\\mathrm{anti}} + \\ell - 1 - j]\\Big) $$\nIf any pair $(i, \\ell)$ yields a score of at least $4$, the condition is met.\n\nWith these two component functions, we define a function `is_tRNA_like(seq)`. This function returns true if and only if `seq` satisfies both the acceptor-stem and the anticodon-stem conditions.\n\nFinally, the main classification algorithm for a given sequence $s$ of length $n$ is as follows:\n$1$. Check if $35 \\le n \\le 100$. If not, the sequence is immediately classified as not being a permuted tRNA, and the result is false.\n$2$. Evaluate `is_tRNA_like(s)`. If it is true, the sequence is a canonical tRNA-like structure, not a permuted one by definition. The result is false.\n$3$. Iterate through all non-trivial circular permutations by creating $R_p(s) = s[p:]s[:p]$ for each $p$ from $1$ to $n-1$. For each permuted sequence $R_p(s)$, evaluate `is_tRNA_like(R_p(s))`.\n$4$. If this evaluation is true for any $p$, it means a tRNA-like structure is revealed upon permutation. The sequence $s$ is classified as a permuted tRNA gene, and the result is true. The search can terminate.\n$5$. If the loop completes without finding any such permutation, the sequence is not a permuted tRNA gene, and the result is false.\n\nThis systematic application of the formal model provides a deterministic and scientifically principled solution to the stated problem. The implementation will consist of a set of functions that directly mirror this logical structure.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the permuted tRNA gene detection problem based on the provided formal model.\n    \"\"\"\n\n    def wc_pair(b1, b2):\n        \"\"\"Checks for Watson-Crick base pairing (A-T, C-G).\"\"\"\n        pairs = {('A', 'T'), ('T', 'A'), ('C', 'G'), ('G', 'C')}\n        return (b1, b2) in pairs\n\n    def has_acceptor_stem(seq, k_acc, m_acc, g):\n        \"\"\"\n        Checks for the presence of a valid acceptor stem according to the model.\n        A score of at least k_acc - m_acc is required for some t, u in [0, g].\n        \"\"\"\n        n = len(seq)\n        threshold = k_acc - m_acc\n        if n < k_acc: \n            return False\n\n        for t in range(g + 1):\n            for u in range(g + 1):\n                # Ensure substrings are within bounds\n                if t + k_acc > n or n - u - k_acc < 0:\n                    continue\n                \n                score = 0\n                for i in range(k_acc):\n                    base1 = seq[t + i]\n                    base2 = seq[n - u - 1 - i]\n                    if wc_pair(base1, base2):\n                        score += 1\n                \n                if score >= threshold:\n                    return True\n        return False\n\n    def has_anticodon_stem(seq, k_anti, m_anti, l_min, l_max):\n        \"\"\"\n        Checks for the presence of a valid anticodon stem according to the model.\n        A score of at least k_anti - m_anti is required for some i and l.\n        \"\"\"\n        n = len(seq)\n        threshold = k_anti - m_anti\n\n        for l in range(l_min, l_max + 1):\n            structure_len = 2 * k_anti + l\n            if n < structure_len:\n                continue\n            \n            max_i = n - structure_len\n            for i in range(max_i + 1):\n                score = 0\n                for j in range(k_anti):\n                    base1 = seq[i + j]\n                    base2 = seq[i + structure_len - 1 - j]\n                    if wc_pair(base1, base2):\n                        score += 1\n                \n                if score >= threshold:\n                    return True\n        return False\n\n    def is_tRNA_like(seq, params):\n        \"\"\"\n        Checks if a sequence is tRNA-like, meaning it satisfies both the\n        acceptor stem and anticodon stem conditions.\n        \"\"\"\n        # Unpack parameters from the dictionary\n        k_acc, m_acc, g = params['acceptor']\n        k_anti, m_anti, l_min, l_max = params['anticodon']\n\n        # Both conditions must hold simultaneously\n        return (has_acceptor_stem(seq, k_acc, m_acc, g) and\n                has_anticodon_stem(seq, k_anti, m_anti, l_min, l_max))\n\n    def is_permuted_tRNA(s, params):\n        \"\"\"\n        Determines if a sequence 's' is a permuted tRNA gene. This is true iff\n        's' is not tRNA-like, but at least one of its circular permutations is.\n        \"\"\"\n        n = len(s)\n        min_len, max_len = params['length_bounds']\n\n        if not (min_len <= n <= max_len):\n            return False\n\n        # The unrotated sequence must NOT be tRNA-like\n        if is_tRNA_like(s, params):\n            return False\n\n        # At least one non-trivial rotation must be tRNA-like\n        for p in range(1, n):\n            rotated_s = s[p:] + s[:p]\n            if is_tRNA_like(rotated_s, params):\n                return True\n        \n        return False\n\n    # Define all model parameters from the problem statement in a dictionary\n    params = {\n        'acceptor': (7, 1, 2),          # (k_acc, m_acc, g)\n        'anticodon': (5, 1, 5, 9),      # (k_anti, m_anti, l_min, l_max)\n        'length_bounds': (35, 100)\n    }\n\n    # The test suite provided in the problem statement\n    test_cases = [\n        \"GCGATTCTTTAGCAAGGTGTCATGAACCTTCCGTTTGAATCGC\",      # S1\n        \"CATGAACCTTCCGTTTGAATCGCATGCGATTCTTTAGCAAGGTGT\",      # S2\n        \"ACGTCGATGACAGTCAGTACGATCGATCGTACGAGTCTAAGCTAGTC\",  # S3\n        \"ACGTACGTACGT\",                                     # S4\n        \"CATGAACCTTCCGTTTGAATCGTATGCGATTCTTTAGCAAGGTGT\"       # S5\n    ]\n\n    results = []\n    for s in test_cases:\n        # Apply the classification logic to each test case\n        result = is_permuted_tRNA(s, params)\n        results.append(result)\n\n    # Format the final output as a single-line string: `[bool1,bool2,...]`\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2438454"}]}