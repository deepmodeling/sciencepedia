{"hands_on_practices": [{"introduction": "Before searching for real genes, it is essential to understand the statistical background of a genome. This exercise challenges you to calculate how often apparent gene structures, or Open Reading Frames (ORFs), appear purely by chance in a random sequence of DNA. By mastering the probabilistic principles that govern these \"false positives,\" you will gain a crucial baseline for appreciating why more sophisticated gene prediction methods are necessary [@problem_id:2419180].", "problem": "You are given a formal model of Open Reading Frame (ORF) prediction applied to Deoxyribonucleic Acid (DNA) sequences from prokaryotes. Assume a genome is generated as an independent and identically distributed sequence over the alphabet $\\{A,C,G,T\\}$ with base probabilities $p_A$, $p_C$, $p_G$, and $p_T$ that sum to $1$. An Open Reading Frame (ORF) is defined on a chosen strand and reading frame as follows: starting at a position aligned to the reading frame, if the triplet equals one of the canonical start codons $\\{ATG,TTG,GTG\\}$, translation proceeds codon by codon in the same frame until the first encountered in-frame stop codon from the set $\\{TAA,TAG,TGA\\}$. The ORF is the sequence from the start codon up to but not including the stop codon. The ORF length (in codons) is defined as the number of codons from and including the start codon up to but not including the stop codon.\n\nA predicted ORF is any such ORF whose length is at least a specified minimum length $L_{\\min}$ (in codons, as defined above). A standard ORF finder is assumed to scan all codon-aligned positions in a specified number of reading frames $F \\in \\{3,6\\}$, where $F=3$ means the three forward frames and $F=6$ means the three forward frames and the three reverse-complement frames. At each frame, it evaluates all possible codon-aligned start positions independently of other frames.\n\nDefine the False Positive Rate (FPR) in this setting to mean the expected number of predicted ORFs per megabase (that is, per $1000000$ nucleotides) in a genome that contains no true genes (so every reported ORF is spurious). Under the independent and identically distributed base model specified by $(p_A,p_T,p_G,p_C)$, you must compute this expectation exactly from first principles, assuming a very long genome so that boundary effects are negligible. For conversion to a per-megabase quantity, use a genome length of $N=1000000$ nucleotides and count only complete codon starts per frame, i.e., use $\\left\\lfloor N/3 \\right\\rfloor$ codon-aligned start positions per frame.\n\nYour task is to write a complete program that, for the following test suite of parameter sets, returns the expected number of spurious predicted ORFs per megabase as a real number for each case. Each test case is specified as $(p_A,p_T,p_G,p_C,L_{\\min},F)$:\n\n- Test case $1$: $(0.45,\\,0.40,\\,0.10,\\,0.05,\\,100,\\,6)$.\n- Test case $2$: $(0.49,\\,0.41,\\,0.06,\\,0.04,\\,50,\\,6)$.\n- Test case $3$: $(0.40,\\,0.40,\\,0.10,\\,0.10,\\,75,\\,6)$.\n- Test case $4$: $(0.25,\\,0.25,\\,0.25,\\,0.25,\\,50,\\,6)$.\n- Test case $5$: $(0.50,\\,0.35,\\,0.10,\\,0.05,\\,30,\\,3)$.\n- Test case $6$: $(0.50,\\,0.35,\\,0.10,\\,0.05,\\,300,\\,6)$.\n\nRequirements and conventions:\n\n- The base probabilities must satisfy $p_A+p_T+p_G+p_C=1$ in each test case; all given cases already satisfy this.\n- Start codon set is exactly $\\{ATG,TTG,GTG\\}$ and stop codon set is exactly $\\{TAA,TAG,TGA\\}$.\n- Report the expected number of spurious predicted ORFs per $1000000$ nucleotides for each test case as a real number.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[x_1,x_2,\\dots,x_6]$), in the same order as the test cases above. No additional text or whitespace is allowed in the output line.", "solution": "The problem statement has been validated and is deemed valid. It is a well-posed, scientifically grounded problem in computational biology requiring the application of first principles of probability theory.\n\nThe objective is to compute the expected number of spurious predicted Open Reading Frames (ORFs) per megabase of random Deoxyribonucleic Acid (DNA). This quantity is defined as the False Positive Rate (FPR). The genomic model is an independent and identically distributed (IID) sequence of nucleotides from the alphabet $\\{A, C, G, T\\}$ with given probabilities $p_A$, $p_C$, $p_G$, and $p_T$.\n\nLet $E[N_{\\text{ORF}}]$ be the expected number of predicted ORFs in a sequence of length $N = 1000000$ nucleotides. A predicted ORF is an ORF with a length of at least $L_{\\min}$ codons. The search for ORFs is conducted over $F$ reading frames.\n\nBy the linearity of expectation, the total expected number of predicted ORFs is the sum of the expectations of finding a predicted ORF starting at each possible position. Due to the IID nature of the sequence, the probability of a predicted ORF starting at any given codon-aligned position is constant.\n\nThe total number of codon-aligned positions to be tested is the product of the number of frames, $F$, and the number of start positions per frame. For a sequence of length $N$, there are $\\lfloor N/3 \\rfloor$ non-overlapping codon positions in a single frame.\nThe number of test sites is $F \\times \\lfloor N/3 \\rfloor$.\nGiven $N = 1000000$, the number of positions per frame is $\\lfloor 1000000/3 \\rfloor = 333333$.\n\nThe total expectation is therefore:\n$$ E[N_{\\text{ORF}}] = F \\times \\left\\lfloor \\frac{N}{3} \\right\\rfloor \\times P(\\text{predicted ORF}) $$\nwhere $P(\\text{predicted ORF})$ is the probability that a predicted ORF starts at an arbitrary codon-aligned position.\n\nFor a predicted ORF to start at a given position, two conditions must be met independently:\n$1$. The codon at that position must be a start codon.\n$2$. The length of the resulting ORF must be at least $L_{\\min}$ codons.\n\nLet us calculate the probabilities of these events.\nThe set of start codons is $\\mathcal{S} = \\{ATG, TTG, GTG\\}$. The probability of a start codon, $P(\\text{start})$, is the sum of the probabilities of each start codon, calculated from the base probabilities $p_A, p_T, p_G, p_C$:\n$$ P(\\text{start}) = P(ATG) + P(TTG) + P(GTG) $$\n$$ P(\\text{start}) = (p_A \\cdot p_T \\cdot p_G) + (p_T \\cdot p_T \\cdot p_G) + (p_G \\cdot p_T \\cdot p_G) $$\n\nThe set of stop codons is $\\mathcal{T} = \\{TAA, TAG, TGA\\}$. The probability of a random codon being a stop codon, $P(\\text{stop})$, is:\n$$ P(\\text{stop}) = P(TAA) + P(TAG) + P(TGA) $$\n$$ P(\\text{stop}) = (p_T \\cdot p_A \\cdot p_A) + (p_T \\cdot p_A \\cdot p_G) + (p_T \\cdot p_G \\cdot p_A) $$\nThe probability of a random codon being a non-stop codon is $P(\\text{non-stop}) = 1 - P(\\text{stop})$.\n\nAn ORF is defined as the sequence from a start codon up to, but not including, the first in-frame stop codon. The length of the ORF is the number of codons it contains. For an ORF to have a length of at least $L_{\\min}$, the first $L_{\\min}-1$ codons following the start codon must all be non-stop codons.\nThe sequence of codons following the start position is a series of independent trials. The probability that an ORF has a length of at least $L_{\\min}$ is the probability that a sequence of $L_{\\min}-1$ codons contains no stop codons.\n$$ P(\\text{length} \\ge L_{\\min}) = (P(\\text{non-stop}))^{L_{\\min}-1} = (1 - P(\\text{stop}))^{L_{\\min}-1} $$\n\nThe probability of a predicted ORF starting at a specific site is the product of the probability of a start codon and the probability of the subsequent ORF being long enough:\n$$ P(\\text{predicted ORF}) = P(\\text{start}) \\times P(\\text{length} \\ge L_{\\min}) $$\n$$ P(\\text{predicted ORF}) = P(\\text{start}) \\times (1 - P(\\text{stop}))^{L_{\\min}-1} $$\n\nFinally, we substitute this back into the expression for the total expected number of predicted ORFs:\n$$ E[N_{\\text{ORF}}] = F \\times \\left\\lfloor \\frac{N}{3} \\right\\rfloor \\times P(\\text{start}) \\times (1 - P(\\text{stop}))^{L_{\\min}-1} $$\n\nSubstituting the explicit probability formulas and the value of $N=1000000$:\n$$ E[N_{\\text{ORF}}] = F \\times 333333 \\times (p_A p_T p_G + p_T^2 p_G + p_G p_T p_G) \\times (1 - (p_T p_A^2 + p_T p_A p_G + p_T p_G p_A))^{L_{\\min}-1} $$\n\nThis formula is implemented for each provided test case to compute the required values.", "answer": "```python\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the expected number of spurious predicted ORFs per megabase.\n    \"\"\"\n    test_cases = [\n        # (p_A, p_T, p_G, p_C, L_min, F)\n        (0.45, 0.40, 0.10, 0.05, 100, 6),\n        (0.49, 0.41, 0.06, 0.04, 50, 6),\n        (0.40, 0.40, 0.10, 0.10, 75, 6),\n        (0.25, 0.25, 0.25, 0.25, 50, 6),\n        (0.50, 0.35, 0.10, 0.05, 30, 3),\n        (0.50, 0.35, 0.10, 0.05, 300, 6),\n    ]\n\n    results = []\n    \n    # Genome length for calculation (per megabase)\n    N = 1000000\n    \n    # Number of codon-aligned start positions per frame\n    num_positions_per_frame = N // 3\n\n    for case in test_cases:\n        p_A, p_T, p_G, p_C, L_min, F = case\n\n        # Calculate the probability of encountering a start codon {ATG, TTG, GTG}\n        # P(start) = P(ATG) + P(TTG) + P(GTG) = pA*pT*pG + pT*pT*pG + pG*pT*pG\n        p_start = (p_A * p_T * p_G) + (p_T * p_T * p_G) + (p_G * p_T * p_G)\n\n        # Calculate the probability of encountering a stop codon {TAA, TAG, TGA}\n        # P(stop) = P(TAA) + P(TAG) + P(TGA) = pT*pA*pA + pT*pA*pG + pT*pG*pA\n        p_stop = (p_T * p_A * p_A) + (p_T * p_A * p_G) + (p_T * p_G * p_A)\n\n        # The probability of a codon not being a stop codon\n        p_non_stop = 1.0 - p_stop\n\n        # An ORF is predicted if its length is >= L_min. This means the first L_min-1\n        # codons after the start codon must be non-stop codons.\n        # The probability of this event for an ORF is P(non_stop)^(L_min - 1).\n        if L_min > 1:\n            prob_long_enough = p_non_stop ** (L_min - 1)\n        else: # L_min=1 means any start codon is a predicted ORF of sufficient length.\n            prob_long_enough = 1.0\n\n        # The probability of a predicted ORF at a single codon-aligned site\n        # is P(start) * P(length >= L_min).\n        prob_predicted_orf_at_site = p_start * prob_long_enough\n\n        # The total number of sites to check is F * num_positions_per_frame.\n        total_sites = F * num_positions_per_frame\n\n        # By linearity of expectation, the total expected number is num_sites * probability_per_site.\n        expected_orfs = total_sites * prob_predicted_orf_at_site\n        results.append(expected_orfs)\n\n    # Format the final output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419180"}, {"introduction": "The fundamental task of gene prediction is to algorithmically scan a genome for signals that define a gene. This exercise strengthens your algorithmic thinking by asking you to implement an ORF detector for a hypothetical organism that uses a quadruplet-based genetic code. By adapting the core logic of reading frames, start codons, and stop codons to a novel system, you will develop a deeper, more flexible understanding of how gene-finding algorithms work in practice [@problem_id:2419182].", "problem": "You are asked to formalize and implement an Open Reading Frame (ORF) detector for a hypothetical prokaryotic-like organism that uses a quadruplet-based genetic code. In this hypothetical organism, translation proceeds over quadruplets of nucleotides rather than triplets. An Open Reading Frame (ORF) is defined as a contiguous segment of a deoxyribonucleic acid (DNA) sequence that starts with a designated start quadruplet, ends with a designated stop quadruplet in the same reading frame, and contains no stop quadruplet between its start and stop in that frame. The alphabet is the set of nucleotides $\\{ \\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T} \\}$. All indexing must use $0$-based positions on the given sequence, and all indices refer to nucleotide positions.\n\nYou must implement logic that considers all $4$ reading frames. For frame $f \\in \\{0,1,2,3\\}$, scanning positions are those indices $p$ such that $p \\bmod 4 = f$, and only substrings of length $4$ that begin at such positions are considered as candidate quadruplets. A start quadruplet at position $i$ begins an ORF in its frame. The ORF then extends in steps of $4$ nucleotides until the first in-frame stop quadruplet is encountered at some position $j$ with $j \\equiv i \\pmod{4}$, at which point the ORF spans from start index $i$ to end index $j+3$, inclusive. An ORF is included in the output only if its nucleotide length $\\ell = (j+3) - i + 1$ satisfies $\\ell \\ge L_{\\min}$ for a specified minimum length $L_{\\min}$. Within any single frame, ORFs must be reported as non-overlapping by proceeding from left to right; after an ORF ends at its stop, scanning resumes at the next quadruplet in that frame. Overlaps across different frames are allowed. Substrings shorter than length $4$ at the end of the sequence must be ignored. Only ORFs that terminate with a designated stop quadruplet are to be reported; incomplete runs reaching the end without a stop must be discarded.\n\nUse the following fixed parameters for all test cases:\n- Start quadruplet set $S = \\{\\mathrm{ATGG}, \\mathrm{TTGG}\\}$.\n- Stop quadruplet set $T = \\{\\mathrm{TAAG}, \\mathrm{TGAG}\\}$.\n- Minimum nucleotide length $L_{\\min} = 8$.\n\nFor each ORF you detect, output the quadruple of integers $[f, s, e, \\ell]$, where $f$ is the frame, $s$ is the start index, $e$ is the inclusive end index, and $\\ell$ is the nucleotide length as defined above. For a given sequence, output a list of these quadruples in ascending order of $s$ within each frame and ascending by frame $f$ when comparing across frames.\n\nYour program must process the following test suite. Each test case consists of a DNA sequence over $\\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$:\n\n- Test case $1$: $\\mathrm{ATGGCCCCGGGGTAAGAAAA}$\n- Test case $2$: $\\mathrm{TTGGAAAAATGGCCCCTGAG}$\n- Test case $3$: $\\mathrm{AATGGCCCCGGGGTAAGC}$\n- Test case $4$: $\\mathrm{CCATGGCCCCAAAA}$\n- Test case $5$: $\\mathrm{GGATGGTAAGT}$\n- Test case $6$: $\\mathrm{TTGGCCCCTAAGAAAAATGGGGGGTGAG}$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case in order and is itself a list of the detected ORFs for that sequence. The representation must use only integers and lists; for example, a possible overall output format is $[[[f,s,e,\\ell]],[],[[f,s,e,\\ell],[f,s,e,\\ell]],\\dots]$ with no characters other than brackets, commas, and digits. There are no physical units involved, and all reported indices and lengths are unitless integers. The final output must be exactly one line in this format.", "solution": "The problem as stated is valid. It presents a well-defined computational biology task that, while based on a hypothetical quadruplet-based genetic code, is grounded in the established principles of gene finding, specifically the identification of Open Reading Frames (ORFs). All terms, parameters, and constraints are specified with sufficient precision to permit a unique and verifiable algorithmic solution. The problem is a formal exercise in sequence analysis and is free from scientific contradictions or logical fallacies.\n\nThe objective is to devise an algorithm for detecting ORFs in a given deoxyribonucleic acid (DNA) sequence. The organism in question is hypothetical, utilizing a quadruplet code. An ORF is a segment of DNA that is translated into a protein. Its structure is defined by a start signal, a stop signal, and a reading frame.\n\nThe algorithm must consider all $4$ possible reading frames, which we denote by an index $f \\in \\{0, 1, 2, 3\\}$. For a given DNA sequence of length $N$, a reading frame $f$ comprises all nucleotide positions $p$ such that $p \\equiv f \\pmod{4}$. The algorithm proceeds by scanning each frame independently.\n\nFor each frame $f$, the scan begins at the first valid position, $p_0=f$, and advances through subsequent valid positions $p_k = f + 4k$, as long as $p_k + 4 \\le N$. At each position $p_k$, the substring of length $4$ (a quadruplet) is extracted.\n\nThe core logic for ORF identification is as follows:\n$1$. At a given scan position $s$, the quadruplet is checked against the set of start quadruplets, $S = \\{\\mathrm{ATGG}, \\mathrm{TTGG}\\}$.\n\n$2$. If the quadruplet is not a start signal, the scan advances to the next position in the frame, $s+4$.\n\n$3$. If the quadruplet at position $s$ is a start signal, a search for a corresponding stop signal is initiated. This search begins at position $j = s+4$ and continues in increments of $4$, checking each subsequent in-frame quadruplet.\n\n$4$. The search for a stop signal continues until the first quadruplet matching an element of the stop set, $T = \\{\\mathrm{TAAG}, \\mathrm{TGAG}\\}$, is found at some position $j$.\n\n$5$. Upon finding such a stop signal at position $j$, a complete ORF has been identified. This ORF spans from index $s$ to index $e = j+3$, inclusive. Its total nucleotide length is calculated as $\\ell = e - s + 1$.\n\n$6$. A validity check is performed on this ORF. It is accepted and recorded only if its length $\\ell$ meets or exceeds the specified minimum length, $L_{\\min} = 8$. An accepted ORF is stored as a quadruple $[f, s, e, \\ell]$.\n\n$7$. According to the problem's non-overlapping rule for a single frame, after an ORF ending at index $e=j+3$ is found, the main scan for frame $f$ must resume at the next quadruplet position, which is $j+4$. This ensures that any subsequent reported ORFs in the same frame do not overlap with the one just found.\n\n$8$. If the search for a stop signal initiated at start position $s$ reaches the end of the sequence without finding a stop signal, the potential ORF is incomplete and must be discarded. The main scan then simply continues from the position $s+4$.\n\nThis entire procedure is systematically applied to each of the $4$ frames, from $f=0$ to $f=3$. The resulting list of all found ORFs is collected. The problem requires the output to be sorted first by frame index $f$ in ascending order, and then by the start position $s$ within each frame. The described left-to-right scanning process within each frame, combined with iterating through frames $f=0,1,2,3$ in order, naturally produces results in the required sorted arrangement.\n\nFinally, the results from all test cases are aggregated into a list of lists, which is then serialized into a compact string format containing only digits, commas, and brackets, as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport json\n\ndef solve():\n    \"\"\"\n    Solves the ORF detection problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        \"ATGGCCCCGGGGTAAGAAAA\",\n        \"TTGGAAAAATGGCCCCTGAG\",\n        \"AATGGCCCCGGGGTAAGC\",\n        \"CCATGGCCCCAAAA\",\n        \"GGATGGTAAGT\",\n        \"TTGGCCCCTAAGAAAAATGGGGGGTGAG\",\n    ]\n\n    # Fixed parameters for the hypothetical organism\n    START_QUADS = {\"ATGG\", \"TTGG\"}\n    STOP_QUADS = {\"TAAG\", \"TGAG\"}\n    MIN_LENGTH = 8\n    NUM_FRAMES = 4\n\n    all_results = []\n\n    for dna_sequence in test_cases:\n        orfs_for_sequence = []\n        seq_len = len(dna_sequence)\n\n        for f in range(NUM_FRAMES):\n            scan_pos = f\n            while scan_pos + 4 = seq_len:\n                # Default next position to check is the next quadruplet in frame\n                next_scan_pos = scan_pos + 4\n                \n                quadruplet = dna_sequence[scan_pos : scan_pos + 4]\n\n                if quadruplet in START_QUADS:\n                    s = scan_pos\n                    \n                    # Search for the first in-frame stop quadruplet\n                    j = s + 4\n                    while j + 4 = seq_len:\n                        inner_quadruplet = dna_sequence[j : j + 4]\n                        \n                        if inner_quadruplet in STOP_QUADS:\n                            # Found a stop quadruplet, an ORF is formed.\n                            e = j + 3\n                            length = e - s + 1\n                            \n                            if length >= MIN_LENGTH:\n                                orfs_for_sequence.append([f, s, e, length])\n                            \n                            # Resume scanning after this ORF\n                            next_scan_pos = j + 4\n                            break # Exit inner search loop\n                        \n                        j += 4\n                \n                # Advance the main scanner to the determined next position\n                scan_pos = next_scan_pos\n        \n        all_results.append(orfs_for_sequence)\n    \n    # Final print statement in the exact required format.\n    # The output is a JSON-like string representation of a list of lists,\n    # with no whitespace. json.dumps is a standard and robust way to achieve this.\n    print(json.dumps(all_results, separators=(',', ':')))\n\nsolve()\n```", "id": "2419182"}, {"introduction": "Identifying potential ORFs is only the first step; the next critical challenge is to determine which of these candidates are truly functional genes. This practice introduces you to a powerful technique for this task by having you build a Naive Bayes classifier, a probabilistic framework that combines diverse sources of evidence such as sequence composition and regulatory motifs. Through this exercise, you will learn to apply Bayes' theorem to calculate a posterior probability, or confidence score, for each gene prediction, a skill central to modern genome annotation [@problem_id:2419184].", "problem": "You are given a probabilistic model to assign a posterior probability that a gene predicted by a Hidden Markov Model (HMM) is a true protein-coding gene in a prokaryotic genome. For each predicted gene, you observe a feature vector consisting of five components: an HMM log-odds score $s$, a coding hexamer log-likelihood ratio $h$, a ribosome binding site motif score $r$, the gene’s guanine-cytosine (GC) fraction $x \\in (0,1)$, and the start codon category $c \\in \\{\\text{ATG},\\text{GTG},\\text{TTG},\\text{OTHER}\\}$. Let the latent class variable be $G \\in \\{T,F\\}$, where $T$ denotes a true protein-coding gene and $F$ denotes a false prediction. Assume conditional independence of the features given $G$.\n\nLet the prior be $P(G=T) = p_0$ and $P(G=F) = 1 - p_0$, with $p_0 = 0.7$. The conditional distributions of the features given $G$ are specified as follows.\n\n- For the HMM log-odds score $s$:\n  - $s \\mid G=T \\sim \\mathcal{N}(\\mu_s^T,\\ (\\sigma_s^T)^2)$ with $\\mu_s^T = 5$ and $\\sigma_s^T = 2$.\n  - $s \\mid G=F \\sim \\mathcal{N}(\\mu_s^F,\\ (\\sigma_s^F)^2)$ with $\\mu_s^F = 0$ and $\\sigma_s^F = 2$.\n\n- For the coding hexamer log-likelihood ratio $h$:\n  - $h \\mid G=T \\sim \\mathcal{N}(\\mu_h^T,\\ (\\sigma_h^T)^2)$ with $\\mu_h^T = 2$ and $\\sigma_h^T = 1.5$.\n  - $h \\mid G=F \\sim \\mathcal{N}(\\mu_h^F,\\ (\\sigma_h^F)^2)$ with $\\mu_h^F = -1$ and $\\sigma_h^F = 1.5$.\n\n- For the ribosome binding site motif score $r$:\n  - $r \\mid G=T \\sim \\mathcal{N}(\\mu_r^T,\\ (\\sigma_r^T)^2)$ with $\\mu_r^T = 3$ and $\\sigma_r^T = 1$.\n  - $r \\mid G=F \\sim \\mathcal{N}(\\mu_r^F,\\ (\\sigma_r^F)^2)$ with $\\mu_r^F = 0$ and $\\sigma_r^F = 1.5$.\n\n- For the GC fraction $x$:\n  - $x \\mid G=T \\sim \\mathrm{Beta}(\\alpha_T,\\ \\beta_T)$ with $\\alpha_T = 55$ and $\\beta_T = 45$.\n  - $x \\mid G=F \\sim \\mathrm{Beta}(\\alpha_F,\\ \\beta_F)$ with $\\alpha_F = 35$ and $\\beta_F = 65$.\n\n- For the start codon category $c$ (categorical):\n  - $P(c=\\text{ATG} \\mid G=T)=0.83$, $P(c=\\text{GTG} \\mid G=T)=0.12$, $P(c=\\text{TTG} \\mid G=T)=0.04$, $P(c=\\text{OTHER} \\mid G=T)=0.01$.\n  - $P(c=\\text{ATG} \\mid G=F)=0.25$, $P(c=\\text{GTG} \\mid G=F)=0.25$, $P(c=\\text{TTG} \\mid G=F)=0.25$, $P(c=\\text{OTHER} \\mid G=F)=0.25$.\n\nUse the following density and mass functions.\n\n- For a normal distribution, the probability density function of $X \\sim \\mathcal{N}(\\mu,\\ \\sigma^2)$ is\n  $$ f_{\\mathcal{N}}(x \\mid \\mu,\\ \\sigma) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\exp\\!\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right). $$\n\n- For a beta distribution, the probability density function of $X \\sim \\mathrm{Beta}(\\alpha,\\ \\beta)$ is\n  $$ f_{\\mathrm{Beta}}(x \\mid \\alpha,\\ \\beta) = \\frac{x^{\\alpha-1}(1-x)^{\\beta-1}}{B(\\alpha,\\ \\beta)}, \\quad \\text{for } x \\in (0,1), $$\n  where $B(\\alpha,\\ \\beta) = \\dfrac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha+\\beta)}$ and $\\Gamma(\\cdot)$ is the gamma function.\n\n- For a categorical variable, the probability mass function is $P(c=k \\mid G)=q_k$ for category $k$ with specified probability $q_k$.\n\nFor an observed feature vector $e=(s,h,r,x,c)$, define the class-conditional likelihoods\n$$ \\ell_T(e) = f_{\\mathcal{N}}(s \\mid \\mu_s^T,\\ \\sigma_s^T) \\cdot f_{\\mathcal{N}}(h \\mid \\mu_h^T,\\ \\sigma_h^T) \\cdot f_{\\mathcal{N}}(r \\mid \\mu_r^T,\\ \\sigma_r^T) \\cdot f_{\\mathrm{Beta}}(x \\mid \\alpha_T,\\ \\beta_T) \\cdot P(c \\mid G=T), $$\n$$ \\ell_F(e) = f_{\\mathcal{N}}(s \\mid \\mu_s^F,\\ \\sigma_s^F) \\cdot f_{\\mathcal{N}}(h \\mid \\mu_h^F,\\ \\sigma_h^F) \\cdot f_{\\mathcal{N}}(r \\mid \\mu_r^F,\\ \\sigma_r^F) \\cdot f_{\\mathrm{Beta}}(x \\mid \\alpha_F,\\ \\beta_F) \\cdot P(c \\mid G=F). $$\n\nUsing Bayes’ theorem, the posterior probability of a true gene given $e$ is\n$$ P(G=T \\mid e) = \\frac{p_0 \\cdot \\ell_T(e)}{p_0 \\cdot \\ell_T(e) + (1-p_0) \\cdot \\ell_F(e)}. $$\n\nYour task is to write a program that, for each test case listed below, computes $P(G=T \\mid e)$ using the model and definitions above.\n\nTest suite of observed feature vectors $(s,h,r,x,c)$ to evaluate, in the stated order:\n- Case Alpha: $(6.0,\\,2.5,\\,3.2,\\,0.56,\\,\\text{ATG})$.\n- Case Beta: $(3.0,\\,1.0,\\,2.0,\\,0.50,\\,\\text{GTG})$.\n- Case Gamma: $(1.0,\\,0.0,\\,0.5,\\,0.45,\\,\\text{TTG})$.\n- Case Delta: $(-1.0,\\,-1.5,\\,-0.5,\\,0.20,\\,\\text{OTHER})$.\n- Case Epsilon: $(12.0,\\,6.0,\\,6.0,\\,0.58,\\,\\text{ATG})$.\n- Case Zeta: $(-5.0,\\,-4.0,\\,-3.0,\\,0.10,\\,\\text{OTHER})$.\n\nFinal output format: Your program should produce a single line of output containing the posterior probabilities for the cases in the exact order above, as a comma-separated list of decimals enclosed in square brackets, with each value rounded to six decimal places (for example, [$0.123456$,$0.654321$,$0.500000$,$0.000001$,$0.999999$,$0.250000$]). No additional text should be printed.", "solution": "The problem requires the calculation of the posterior probability that a predicted gene is a true protein-coding gene, given a set of observed features. This is a classic application of Bayesian inference, specifically using a Naive Bayes classifier. The model assumes that the features are conditionally independent given the class label $G \\in \\{T, F\\}$, where $T$ denotes a true gene and $F$ denotes a false prediction.\n\nThe core of the solution is the application of Bayes' theorem. The posterior probability of a gene being true ($G=T$) given the evidence (the feature vector $e=(s,h,r,x,c)$) is given by:\n$$ P(G=T \\mid e) = \\frac{P(e \\mid G=T) P(G=T)}{P(e)} $$\nThe prior probability $P(G=T)$ is given as $p_0 = 0.7$. The term $P(e \\mid G=T)$ is the class-conditional likelihood of observing the evidence $e$ if the gene is true. The denominator $P(e)$ is the total probability of the evidence, which can be expanded using the law of total probability:\n$$ P(e) = P(e \\mid G=T)P(G=T) + P(e \\mid G=F)P(G=F) $$\nSubstituting this into the Bayes' formula, and using the problem's notation $\\ell_G(e) = P(e \\mid G)$ for the likelihood and $P(G=F) = 1-p_0$, we obtain the expression provided in the problem statement:\n$$ P(G=T \\mid e) = \\frac{p_0 \\cdot \\ell_T(e)}{p_0 \\cdot \\ell_T(e) + (1-p_0) \\cdot \\ell_F(e)} $$\nDue to the conditional independence assumption, the class-conditional likelihood $\\ell_G(e)$ is the product of the individual probability density or mass functions for each feature:\n$$ \\ell_G(e) = P(s \\mid G) \\cdot P(h \\mid G) \\cdot P(r \\mid G) \\cdot P(x \\mid G) \\cdot P(c \\mid G) $$\nThe distributions for each feature are specified: continuous features $s, h, r$ follow Normal distributions ($\\mathcal{N}$), feature $x$ follows a Beta distribution ($\\mathrm{Beta}$), and the discrete feature $c$ follows a Categorical distribution.\n\nA direct computation of the likelihoods $\\ell_T(e)$ and $\\ell_F(e)$ by multiplying probability densities may lead to numerical underflow, as these values can be very small. A standard and robust technique is to perform calculations in logarithmic space. The log-likelihood, $L_G(e) = \\ln(\\ell_G(e))$, is the sum of the individual log-probabilities:\n$$ L_G(e) = \\ln(P(s \\mid G)) + \\ln(P(h \\mid G)) + \\ln(P(r \\mid G)) + \\ln(P(x \\mid G)) + \\ln(P(c \\mid G)) $$\nThe log-probability density for a Normal distribution $\\mathcal{N}(\\mu, \\sigma^2)$ is:\n$$ \\ln(f_{\\mathcal{N}}(z \\mid \\mu, \\sigma)) = -\\ln(\\sigma) - \\frac{1}{2}\\ln(2\\pi) - \\frac{(z-\\mu)^2}{2\\sigma^2} $$\nThe log-probability density for a Beta distribution $\\mathrm{Beta}(\\alpha, \\beta)$ is:\n$$ \\ln(f_{\\mathrm{Beta}}(z \\mid \\alpha, \\beta)) = (\\alpha-1)\\ln(z) + (\\beta-1)\\ln(1-z) - \\ln(B(\\alpha, \\beta)) $$\nwhere $\\ln(B(\\alpha, \\beta)) = \\ln(\\Gamma(\\alpha)) + \\ln(\\Gamma(\\beta)) - \\ln(\\Gamma(\\alpha+\\beta))$. These calculations are best performed using specialized functions like `scipy.stats.norm.logpdf`, `scipy.stats.beta.logpdf`, and `scipy.special.gammaln` to maintain numerical precision. The log-probability for the categorical variable is simply the logarithm of its given probability mass.\n\nTo compute the posterior probability using log-likelihoods, we can algebraically manipulate the formula:\n$$ P(G=T \\mid e) = \\frac{p_0 \\ell_T(e)}{p_0 \\ell_T(e) + (1-p_0) \\ell_F(e)} = \\frac{1}{1 + \\frac{(1-p_0) \\ell_F(e)}{p_0 \\ell_T(e)}} $$\nThe ratio term in the denominator can be expressed using an exponential of the difference of log-quantities:\n$$ \\frac{(1-p_0) \\ell_F(e)}{p_0 \\ell_T(e)} = \\exp\\left( \\ln\\left( \\frac{(1-p_0) \\ell_F(e)}{p_0 \\ell_T(e)} \\right) \\right) = \\exp\\left( (\\ln(1-p_0) + L_F(e)) - (\\ln(p_0) + L_T(e)) \\right) $$\nThis transformed expression involves a logistic (sigmoid) function, which is numerically stable and mitigates the risk of overflow or underflow.\n\nThe computational procedure is as follows:\nFor each test case vector $e = (s, h, r, x, c)$:\n1.  Calculate the log-likelihood $L_T(e)$ by summing the log-probabilities of each observed feature value, using a set of parameters for the \"True\" class ($G=T$).\n2.  Calculate the log-likelihood $L_F(e)$ similarly, using parameters for the \"False\" class ($G=F$).\n3.  Compute the log of the prior odds, $\\ln(1-p_0) - \\ln(p_0)$.\n4.  Combine these terms to find the log of the posterior odds ratio: $Z = (\\ln(1-p_0) + L_F(e)) - (\\ln(p_0) + L_T(e))$.\n5.  Calculate the final posterior probability as $P(G=T \\mid e) = \\frac{1}{1 + \\exp(Z)}$.\n6.  The results for all test cases are collected and formatted to six decimal places, presented in a comma-separated list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, beta\n\ndef solve():\n    \"\"\"\n    Computes the posterior probability that a predicted gene is a true\n    protein-coding gene based on a Naive Bayes model.\n    \"\"\"\n    # Define the model parameters for true (T) and false (F) gene classes.\n    # The parameters are for features: s, h, r, x, c.\n    params = {\n        'T': {\n            's': {'mu': 5.0, 'sigma': 2.0},\n            'h': {'mu': 2.0, 'sigma': 1.5},\n            'r': {'mu': 3.0, 'sigma': 1.0},\n            'x': {'alpha': 55.0, 'beta': 45.0},\n            'c': {'ATG': 0.83, 'GTG': 0.12, 'TTG': 0.04, 'OTHER': 0.01}\n        },\n        'F': {\n            's': {'mu': 0.0, 'sigma': 2.0},\n            'h': {'mu': -1.0, 'sigma': 1.5},\n            'r': {'mu': 0.0, 'sigma': 1.5},\n            'x': {'alpha': 35.0, 'beta': 65.0},\n            'c': {'ATG': 0.25, 'GTG': 0.25, 'TTG': 0.25, 'OTHER': 0.25}\n        }\n    }\n    \n    # Prior probability of being a true gene.\n    prior_p0 = 0.7\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (s, h, r, x, c)\n        (6.0, 2.5, 3.2, 0.56, 'ATG'),     # Case Alpha\n        (3.0, 1.0, 2.0, 0.50, 'GTG'),     # Case Beta\n        (1.0, 0.0, 0.5, 0.45, 'TTG'),     # Case Gamma\n        (-1.0, -1.5, -0.5, 0.20, 'OTHER'), # Case Delta\n        (12.0, 6.0, 6.0, 0.58, 'ATG'),    # Case Epsilon\n        (-5.0, -4.0, -3.0, 0.10, 'OTHER')  # Case Zeta\n    ]\n\n    results = []\n    \n    # Pre-compute log of priors for efficiency.\n    log_p0 = np.log(prior_p0)\n    log_1_minus_p0 = np.log(1.0 - prior_p0)\n\n    for s_obs, h_obs, r_obs, x_obs, c_obs in test_cases:\n        # Calculate log-likelihood for the \"True\" class (G=T).\n        # This is the sum of the log-probabilities of each feature given G=T.\n        log_L_T = (\n            norm.logpdf(s_obs, loc=params['T']['s']['mu'], scale=params['T']['s']['sigma']) +\n            norm.logpdf(h_obs, loc=params['T']['h']['mu'], scale=params['T']['h']['sigma']) +\n            norm.logpdf(r_obs, loc=params['T']['r']['mu'], scale=params['T']['r']['sigma']) +\n            beta.logpdf(x_obs, a=params['T']['x']['alpha'], b=params['T']['x']['beta']) +\n            np.log(params['T']['c'][c_obs])\n        )\n\n        # Calculate log-likelihood for the \"False\" class (G=F).\n        # This is the sum of the log-probabilities of each feature given G=F.\n        log_L_F = (\n            norm.logpdf(s_obs, loc=params['F']['s']['mu'], scale=params['F']['s']['sigma']) +\n            norm.logpdf(h_obs, loc=params['F']['h']['mu'], scale=params['F']['h']['sigma']) +\n            norm.logpdf(r_obs, loc=params['F']['r']['mu'], scale=params['F']['r']['sigma']) +\n            beta.logpdf(x_obs, a=params['F']['x']['alpha'], b=params['F']['x']['beta']) +\n            np.log(params['F']['c'][c_obs])\n        )\n\n        # Calculate the posterior probability P(G=T|e) using a numerically stable\n        # formula based on log-likelihoods.\n        # P(T|e) = 1 / (1 + exp(log( (1-p0)l_F / (p0 * l_T) )))\n        # log_ratio = log(1-p0) + log_L_F - (log(p0) + log_L_T)\n        \n        log_joint_T = log_p0 + log_L_T\n        log_joint_F = log_1_minus_p0 + log_L_F\n        \n        # This term is log( P(e, F) / P(e, T) )\n        log_odds_ratio = log_joint_F - log_joint_T\n        \n        posterior_T = 1.0 / (1.0 + np.exp(log_odds_ratio))\n        \n        results.append(posterior_T)\n\n    # Format the final output as a comma-separated list of values rounded to\n    # six decimal places, enclosed in square brackets.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2419184"}]}