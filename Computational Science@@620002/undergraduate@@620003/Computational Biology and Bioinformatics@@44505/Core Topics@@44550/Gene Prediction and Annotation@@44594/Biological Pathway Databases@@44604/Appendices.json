{"hands_on_practices": [{"introduction": "Before we can use a pathway database for analysis, we must trust its contents. A fundamental check is ensuring that each reaction conserves mass, meaning the number of atoms of each element is the same for reactants and products. This exercise [@problem_id:2375368] will guide you through writing a program to automatically verify the stoichiometric balance of reactions, a crucial quality control step in curating and using metabolic models.", "problem": "You are given a self-contained abstract of a pathway fragment inspired by entries in the Kyoto Encyclopedia of Genes and Genomes (KEGG) and Reactome pathway databases. Each metabolite is assigned a molecular composition restricted to the elements carbon, nitrogen, and phosphorus, represented as a triple $\\left(C,N,P\\right)$ of nonnegative integers giving the counts of atoms of each element per molecule. Each reaction is represented by a multiset of reactants and a multiset of products, with integer stoichiometric coefficients. A reaction is said to be atom-balanced for $\\left(C,N,P\\right)$ if, for each of $C$, $N$, and $P$, the total number of atoms on the reactant side equals the total number of atoms on the product side, when summing the metabolite counts multiplied by their stoichiometric coefficients.\n\nFormally, for a reaction $r$, let the reactant multiset be $\\{(a_i, m_i)\\}_{i=1}^{I}$ and the product multiset be $\\{(b_j, n_j)\\}_{j=1}^{J}$, where $a_i$ and $b_j$ are positive integers, and each metabolite $x$ has composition $\\left(C_x,N_x,P_x\\right)$. Define the reactant sum vector\n$$\n\\mathbf{R}=\\left(\\sum_{i=1}^{I} a_i C_{m_i},\\ \\sum_{i=1}^{I} a_i N_{m_i},\\ \\sum_{i=1}^{I} a_i P_{m_i}\\right),\n$$\nand the product sum vector\n$$\n\\mathbf{P}=\\left(\\sum_{j=1}^{J} b_j C_{n_j},\\ \\sum_{j=1}^{J} b_j N_{n_j},\\ \\sum_{j=1}^{J} b_j P_{n_j}\\right).\n$$\nThe reaction is atom-balanced for $\\left(C,N,P\\right)$ if and only if $\\mathbf{R}=\\mathbf{P}$ componentwise.\n\nYour program must determine, for each pathway test case, which reactions are imbalanced with respect to $\\left(C,N,P\\right)$ and return their $0$-based indices.\n\nMetabolite composition map (restricted to $\\left(C,N,P\\right)$, counts per molecule):\n- ATP: $\\left(10,5,3\\right)$\n- ADP: $\\left(10,5,2\\right)$\n- AMP: $\\left(10,5,1\\right)$\n- Pi: $\\left(0,0,1\\right)$\n- PPi: $\\left(0,0,2\\right)$\n- Glucose: $\\left(6,0,0\\right)$\n- Glucose-6-phosphate: $\\left(6,0,1\\right)$\n- Ribose-5-phosphate: $\\left(5,0,1\\right)$\n- PRPP: $\\left(5,0,3\\right)$\n- Glutamine: $\\left(5,2,0\\right)$\n- Glutamate: $\\left(5,1,0\\right)$\n- NH3: $\\left(0,1,0\\right)$\n- CO2: $\\left(1,0,0\\right)$\n- Carbamoyl phosphate: $\\left(1,1,1\\right)$\n- PRA: $\\left(5,1,1\\right)$\n- H2O: $\\left(0,0,0\\right)$\n\nTest suite of pathway fragments. Each reaction is specified as an ordered pair of reactant and product multisets. A multiset is a list of pairs $\\left(k,\\text{name}\\right)$, where $k$ is the stoichiometric coefficient (an integer $\\geq 1$) and $\\text{name}$ is the metabolite string. Reactions are listed in order, and indices start at $0$ for each test case.\n\n- Test Case $1$:\n  - $r_0$: Reactants $\\left[(1,\\text{'Glucose'}),(1,\\text{'ATP'})\\right]$, Products $\\left[(1,\\text{'Glucose-6-phosphate'}),(1,\\text{'ADP'})\\right]$.\n  - $r_1$: Reactants $\\left[(1,\\text{'Ribose-5-phosphate'}),(1,\\text{'ATP'})\\right]$, Products $\\left[(1,\\text{'PRPP'}),(1,\\text{'AMP'})\\right]$.\n  - $r_2$: Reactants $\\left[(1,\\text{'Glutamine'}),(1,\\text{'H2O'})\\right]$, Products $\\left[(1,\\text{'Glutamate'}),(1,\\text{'NH3'})\\right]$.\n\n- Test Case $2$:\n  - $r_0$: Reactants $\\left[(1,\\text{'ATP'}),(1,\\text{'Ribose-5-phosphate'})\\right]$, Products $\\left[(1,\\text{'PRPP'}),(1,\\text{'ADP'})\\right]$.\n  - $r_1$: Reactants $\\left[(1,\\text{'CO2'}),(1,\\text{'NH3'}),(2,\\text{'ATP'})\\right]$, Products $\\left[(1,\\text{'Carbamoyl phosphate'}),(2,\\text{'ADP'}),(1,\\text{'Pi'})\\right]$.\n  - $r_2$: Reactants $\\left[(1,\\text{'Glutamine'}),(1,\\text{'PRPP'})\\right]$, Products $\\left[(1,\\text{'PRA'}),(1,\\text{'Glutamate'}),(1,\\text{'PPi'})\\right]$.\n\n- Test Case $3$:\n  - $r_0$: Reactants $\\left[(1,\\text{'ATP'}),(1,\\text{'AMP'})\\right]$, Products $\\left[(2,\\text{'ADP'})\\right]$.\n  - $r_1$: Reactants $\\left[(1,\\text{'Glucose'}),(1,\\text{'Pi'})\\right]$, Products $\\left[(1,\\text{'Glucose-6-phosphate'})\\right]$.\n  - $r_2$: Reactants $\\left[(1,\\text{'Glutamine'})\\right]$, Products $\\left[(1,\\text{'Glutamate'})\\right]$.\n\nRequired output for each test case: the list of indices (using $0$-based indexing) of reactions that are imbalanced with respect to $\\left(C,N,P\\right)$, in ascending order. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself the list for a test case, with no spaces. For example, the format should be $\\left[\\left[\\cdot\\right],\\left[\\cdot\\right],\\left[\\cdot\\right]\\right]$ such as $[[],[0],[2]]$.", "solution": "The provided problem is an exercise in computational stoichiometry, a fundamental component of metabolic pathway analysis. The task is to verify the atom balance for a given set of biochemical reactions with respect to the elements Carbon ($C$), Nitrogen ($N$), and Phosphorus ($P$). The problem is well-posed, scientifically grounded, and contains all necessary information for a unique and verifiable solution.\n\nThe core principle is the law of conservation of mass, which dictates that in a closed system, the total mass of the reactants must equal the total mass of the products. For a chemical reaction, this implies that the number of atoms of each element must be conserved.\n\nThe problem formalizes this principle using vector algebra. Each metabolite, denoted by a string name, is associated with a composition vector of the form $\\mathbf{v} = (C, N, P)$, where $C$, $N$, and $P$ are non-negative integer counts of the respective atoms.\n\nA reaction is defined by a multiset of reactants, $\\{(a_i, m_i)\\}_{i=1}^{I}$, and a multiset of products, $\\{(b_j, n_j)\\}_{j=1}^{J}$. Here, $m_i$ and $n_j$ are metabolite identifiers, and $a_i$ and $b_j$ are their corresponding positive integer stoichiometric coefficients.\n\nTo check for balance, we compute a total atom count vector for the reactants, $\\mathbf{R}$, and one for the products, $\\mathbf{P}$. These are defined as follows:\n$$\n\\mathbf{R} = \\sum_{i=1}^{I} a_i \\mathbf{v}_{m_i}\n$$\n$$\n\\mathbf{P} = \\sum_{j=1}^{J} b_j \\mathbf{v}_{n_j}\n$$\nwhere $\\mathbf{v}_{m_i}$ and $\\mathbf{v}_{n_j}$ are the composition vectors for metabolites $m_i$ and $n_j$, respectively. The vector addition and scalar multiplication are performed component-wise. A reaction is considered atom-balanced if and only if the reactant sum vector equals the product sum vector, i.e., $\\mathbf{R} = \\mathbf{P}$.\n\nThe algorithm to solve this problem is a direct implementation of this verification procedure.\n\n$1$. **Data Storage**: First, we must create a data structure, such as a dictionary or a hash map, to store the given mapping from metabolite names to their $(C, N, P)$ composition vectors. For computational efficiency, these vectors can be represented as NumPy arrays. The test cases, each containing a list of reactions, are also stored in a suitable data structure, like a list of lists.\n\n$2$. **Iterative Processing**: The algorithm must process each test case independently. A main loop iterates through the provided test suite. For each test case, an empty list is initialized to collect the indices of any imbalanced reactions found.\n\n$3$. **Reaction Verification**: Inside the main loop, a nested loop iterates through each reaction of the current test case, keeping track of its $0$-based index, let's call it $k$. For each reaction:\n    a. Two $3$-element vectors, $\\mathbf{R}_{\\text{sum}}$ and $\\mathbf{P}_{\\text{sum}}$, are initialized to the zero vector $(0, 0, 0)$.\n    b. The algorithm iterates through the reactant multiset. For each reactant pair $(a_i, m_i)$, it retrieves the composition vector $\\mathbf{v}_{m_i}$ from the data map. This vector is multiplied by its stoichiometric coefficient $a_i$, and the result is added to $\\mathbf{R}_{\\text{sum}}$.\n    c. A similar process is performed for the product multiset. For each product pair $(b_j, n_j)$, the vector $b_j \\mathbf{v}_{n_j}$ is calculated and added to $\\mathbf{P}_{\\text{sum}}$.\n    d. After processing all reactants and products, the two sum vectors, $\\mathbf{R}_{\\text{sum}}$ and $\\mathbf{P}_{\\text{sum}}$, are compared. If they are not component-wise equal, the reaction is imbalanced. In this case, its index $k$ is added to the list of imbalanced indices for the current test case.\n\n$4$. **Output Formulation**: After all reactions in all test cases have been analyzed, the result is a list of lists, where each inner list contains the indices of imbalanced reactions for the corresponding test case. This final data structure is then formatted into a single string according to the strict output specification, ensuring no spaces are present, and printed. Using `numpy` arrays for vector operations simplifies the implementation of the summation and comparison steps, ensuring both correctness and clarity.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates the atom balance for a set of biochemical reactions with respect to (C, N, P).\n    \"\"\"\n\n    # Metabolite composition map for (Carbon, Nitrogen, Phosphorus)\n    COMPOSITIONS = {\n        'ATP': np.array([10, 5, 3]),\n        'ADP': np.array([10, 5, 2]),\n        'AMP': np.array([10, 5, 1]),\n        'Pi': np.array([0, 0, 1]),\n        'PPi': np.array([0, 0, 2]),\n        'Glucose': np.array([6, 0, 0]),\n        'Glucose-6-phosphate': np.array([6, 0, 1]),\n        'Ribose-5-phosphate': np.array([5, 0, 1]),\n        'PRPP': np.array([5, 0, 3]),\n        'Glutamine': np.array([5, 2, 0]),\n        'Glutamate': np.array([5, 1, 0]),\n        'NH3': np.array([0, 1, 0]),\n        'CO2': np.array([1, 0, 0]),\n        'Carbamoyl phosphate': np.array([1, 1, 1]),\n        'PRA': np.array([5, 1, 1]),\n        'H2O': np.array([0, 0, 0]),\n    }\n\n    # Test suite of pathway fragments\n    TEST_CASES = [\n        # Test Case 1\n        [\n            {'reactants': [(1, 'Glucose'), (1, 'ATP')], 'products': [(1, 'Glucose-6-phosphate'), (1, 'ADP')]},\n            {'reactants': [(1, 'Ribose-5-phosphate'), (1, 'ATP')], 'products': [(1, 'PRPP'), (1, 'AMP')]},\n            {'reactants': [(1, 'Glutamine'), (1, 'H2O')], 'products': [(1, 'Glutamate'), (1, 'NH3')]},\n        ],\n        # Test Case 2\n        [\n            {'reactants': [(1, 'ATP'), (1, 'Ribose-5-phosphate')], 'products': [(1, 'PRPP'), (1, 'ADP')]},\n            {'reactants': [(1, 'CO2'), (1, 'NH3'), (2, 'ATP')], 'products': [(1, 'Carbamoyl phosphate'), (2, 'ADP'), (1, 'Pi')]},\n            {'reactants': [(1, 'Glutamine'), (1, 'PRPP')], 'products': [(1, 'PRA'), (1, 'Glutamate'), (1, 'PPi')]},\n        ],\n        # Test Case 3\n        [\n            {'reactants': [(1, 'ATP'), (1, 'AMP')], 'products': [(2, 'ADP')]},\n            {'reactants': [(1, 'Glucose'), (1, 'Pi')], 'products': [(1, 'Glucose-6-phosphate')]},\n            {'reactants': [(1, 'Glutamine',)], 'products': [(1, 'Glutamate')]},\n        ]\n    ]\n\n    all_results = []\n    \n    for test_case in TEST_CASES:\n        imbalanced_indices = []\n        for i, reaction in enumerate(test_case):\n            # Initialize sum vectors for reactants and products\n            reactant_sum = np.array([0, 0, 0])\n            product_sum = np.array([0, 0, 0])\n\n            # Calculate sum vector for reactants\n            for coeff, name in reaction['reactants']:\n                reactant_sum += coeff * COMPOSITIONS[name]\n            \n            # Calculate sum vector for products\n            for coeff, name in reaction['products']:\n                product_sum += coeff * COMPOSITIONS[name]\n            \n            # Compare vectors; if not equal, the reaction is imbalanced\n            if not np.array_equal(reactant_sum, product_sum):\n                imbalanced_indices.append(i)\n        \n        all_results.append(imbalanced_indices)\n    \n    # Format the final output string as specified: [[...],[...]], with no spaces\n    output_str = f\"[{','.join(map(str, all_results))}]\"\n    output_str = output_str.replace(' ', '')\n    \n    print(output_str)\n\nsolve()\n```", "id": "2375368"}, {"introduction": "Pathway databases are not just static maps; they encode the dynamic process of molecular transformation. A powerful way to understand this is through atom tracing, where we follow the journey of a single atom through a series of reactions. This practice [@problem_id:2375342] involves implementing an algorithm to trace a labeled carbon atom through the glycolysis pathway, translating the biochemical logic of enzymatic steps into computational rules to predict its final destination.", "problem": "You are asked to implement a complete, runnable program that performs single-atom tracing through the core reactions of the glycolysis pathway as curated in the Kyoto Encyclopedia of Genes and Genomes (KEGG). The goal is to follow a single labeled carbon atom from glucose to pyruvate using first-principles atom conservation and well-established reaction-specific atom mappings, and to compute the final carbon index of the labeled atom in pyruvate.\n\nFundamental base:\n- Conservation of atoms in biochemical reactions states that atoms are neither created nor destroyed; their identities can be tracked through reactions.\n- Glycolysis converts one glucose molecule with $6$ carbons into two pyruvate molecules with $3$ carbons each.\n- The early phosphorylation and isomerization steps (glucose to glucose-$6$-phosphate to fructose-$6$-phosphate to fructose-$1,6$-bisphosphate) do not break the carbon backbone; therefore, a backbone index that moves with each carbon atom is preserved across these steps.\n- Aldolase cleaves fructose-$1,6$-bisphosphate between carbons $3$ and $4$ to form two trioses: dihydroxyacetone phosphate (DHAP) receiving the fragment corresponding to backbone positions $1$ through $3$, and glyceraldehyde-$3$-phosphate (GAP) receiving the fragment corresponding to backbone positions $4$ through $6$.\n- Triose Phosphate Isomerase (TPI) converts DHAP to GAP by exchanging the terminal carbons while leaving the central carbon unchanged, i.e., the carbon mapping within the three-carbon fragment is $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$.\n- The lower part of glycolysis (GAP to $1,3$-bisphosphoglycerate to $3$-phosphoglycerate to $2$-phosphoglycerate to phosphoenolpyruvate to pyruvate) preserves the order of the three-carbon backbone, so the mapping from GAP carbon indices to pyruvate carbon indices is the identity: $1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$.\n\nRepresentation:\n- Represent the glucose carbon backbone by ordered indices $1$ through $6$ that move with each carbon atom through the pathway.\n- For aldolase cleavage, represent the two trioses as separate ordered fragments: DHAP receives indices $1,2,3$ (from glucose positions $1,2,3$) and GAP receives indices $1,2,3$ (from glucose positions $4,5,6$).\n- Apply the TPI mapping $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$ on the DHAP fragment to convert it to GAP coordinates.\n- Apply the identity mapping from GAP to pyruvate: $1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$.\n\nComputational task:\n- Implement a function that takes an integer $g$ representing the labeled carbon index in glucose ($g \\in \\{1,2,3,4,5,6\\}$) and returns the final integer carbon index $p \\in \\{1,2,3\\}$ of the labeled atom in pyruvate produced from its triose branch. If $g$ is not in the valid range, return $-1$.\n- The mapping must be computed by composing the stepwise mappings described above; do not hard-code the final pairing without demonstrating the intermediate logic in code.\n- No physical units are involved in the output of this problem.\n- Angles are not involved in this problem.\n- Percentages are not involved in this problem.\n\nTest suite:\nYour program must evaluate the function on the following labeled-glucose positions:\n- Happy path covering all valid positions: $[1,2,3,4,5,6]$.\n- Edge cases: invalid labels $0$ and $7$.\n\nAnswer specification:\n- For each input label $g$, output a single integer result: $p \\in \\{1,2,3\\}$, or $-1$ if invalid.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result}_1,\\text{result}_2,\\dots\\right]$) in the input order for the full test suite $[1,2,3,4,5,6,0,7]$.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extraction of Givens\n- **Goal**: Implement a program for single-atom tracing through core glycolysis reactions (glucose to pyruvate) as curated in KEGG.\n- **Fundamental Principles**:\n    - Conservation of atoms.\n    - Glycolysis converts one $6$-carbon glucose to two $3$-carbon pyruvate molecules.\n    - The glucose backbone is preserved through fructose-$1,6$-bisphosphate (FBP).\n    - Aldolase cleaves FBP between carbons $3$ and $4$.\n    - Dihydroxyacetone phosphate (DHAP) is formed from carbons $1, 2, 3$ of FBP.\n    - Glyceraldehyde-$3$-phosphate (GAP) is formed from carbons $4, 5, 6$ of FBP.\n    - Triose Phosphate Isomerase (TPI) converts DHAP to GAP with a specific carbon mapping: $1 \\mapsto 3$, $2 \\mapsto 2$, $3 \\mapsto 1$ within the triose fragment.\n    - The lower part of glycolysis (GAP to pyruvate) preserves the carbon backbone order, with an identity mapping: $1 \\mapsto 1$, $2 \\mapsto 2$, $3 \\mapsto 3$.\n- **Representation**:\n    - Glucose carbons are indexed $1$ through $6$.\n    - DHAP fragment receives local indices $1, 2, 3$ from glucose positions $1, 2, 3$.\n    - GAP fragment receives local indices $1, 2, 3$ from glucose positions $4, 5, 6$.\n    - The TPI mapping is applied to the DHAP-derived fragment.\n    - The GAP to pyruvate mapping is identity.\n- **Computational Task**:\n    - Write a function that takes a glucose carbon index $g \\in \\{1, 2, 3, 4, 5, 6\\}$ and returns the corresponding pyruvate carbon index $p \\in \\{1, 2, 3\\}$.\n    - Return $-1$ if $g$ is outside the valid range.\n    - The implementation must compose the stepwise mappings.\n- **Test Suite**:\n    - Input labels: $[1, 2, 3, 4, 5, 6, 0, 7]$.\n- **Output Format**:\n    - A single line containing a comma-separated list of integer results enclosed in square brackets.\n\nStep 2: Validation Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem describes a simplified but correct model of carbon atom fate in glycolysis. The aldolase cleavage site and the action of triose phosphate isomerase are standard concepts in biochemistry. The atom mappings provided are a well-established textbook representation for this metabolic pathway. The problem is firmly based on scientific principles.\n- **Well-Posed**: The problem is well-posed. It has a clearly defined input set ($g \\in \\mathbb{Z}$), a specified transformation logic, and a precisely defined output format ($p \\in \\{1, 2, 3\\}$ or $-1$). For every valid input $g$, the described sequence of transformations produces a unique, meaningful result.\n- **Objective**: The problem is expressed using objective, technical language. There are no subjective or opinion-based statements. The rules for atom mapping are explicit and unambiguous.\n\nThe problem does not exhibit any of the invalidity flaws. It is scientifically sound, formalizable, complete, feasible, and well-structured.\n\nStep 3: Verdict and Action\nThe problem is **valid**. A solution will be constructed.\n\nSolution Derivation\nThe task is to implement a function, let us call it $f(g)$, which maps an initial glucose carbon index $g$ to a final pyruvate carbon index $p$. The domain of valid inputs is $g \\in \\{1, 2, 3, 4, 5, 6\\}$. For any $g$ outside this set, the function must return $-1$.\n\nThe pathway is composed of distinct stages, each corresponding to a mathematical mapping. We will compose these mappings to find the final result.\n\n1.  **Input Validation**: The first step is to check if the input $g$ is valid.\n    $$\n    f(g) = -1 \\quad \\text{if } g \\notin \\{1, 2, 3, 4, 5, 6\\}\n    $$\n\n2.  **Aldolase Cleavage**: The glucose ($6$C) derivative, fructose-$1,6$-bisphosphate, is cleaved into two triose phosphates ($3$C). The fate of the labeled carbon depends on its initial position.\n    - If $g \\in \\{1, 2, 3\\}$, the atom becomes part of the dihydroxyacetone phosphate (DHAP) molecule. The local index within this $3$-carbon fragment is preserved. Let us denote the local index as $i_{local}$.\n      $$\n      i_{local} = g \\quad \\text{for } g \\in \\{1, 2, 3\\}\n      $$\n    - If $g \\in \\{4, 5, 6\\}$, the atom becomes part of the glyceraldehyde-$3$-phosphate (GAP) molecule. The local index is relative to the start of this fragment (carbon $4$ of glucose).\n      $$\n      i_{local} = g - 3 \\quad \\text{for } g \\in \\{4, 5, 6\\}\n      $$\n\n3.  **Triose Phosphate Isomerase (TPI) Action**: All carbon that enters the lower part of glycolysis must be in the form of GAP. The DHAP formed from carbons $1,2,3$ of glucose is isomerized to GAP. This step involves a re-ordering of carbons. The GAP formed directly from carbons $4,5,6$ of glucose proceeds without isomerization. Let us define the index in the unified GAP pool as $i_{GAP}$.\n    - For the atom originating from DHAP ($g \\in \\{1, 2, 3\\}$), we apply the TPI mapping $M_{TPI}$ to its local index $i_{local}$:\n      $$\n      M_{TPI}(i) =\n      \\begin{cases}\n        3 & \\text{if } i = 1 \\\\\n        2 & \\text{if } i = 2 \\\\\n        1 & \\text{if } i = 3\n      \\end{cases}\n      $$\n      So, for $g \\in \\{1, 2, 3\\}$, the index in the resulting GAP molecule is:\n      $$\n      i_{GAP} = M_{TPI}(i_{local}) = M_{TPI}(g)\n      $$\n    - For the atom originating from the first GAP molecule ($g \\in \\{4, 5, 6\\}$), there is no isomerization. The index is unchanged.\n      $$\n      i_{GAP} = i_{local} = g - 3\n      $$\n\n4.  **Lower Glycolysis (GAP to Pyruvate)**: The final sequence of reactions from GAP to pyruvate preserves the carbon backbone order. This corresponds to an identity mapping, $M_{final}(i) = i$. The final pyruvate carbon index $p$ is therefore equal to the index $i_{GAP}$.\n    $$\n    p = i_{GAP}\n    $$\n\nBy combining these steps, we can construct the complete function $f(g)$:\n- **Case 1**: $g \\in \\{1, 2, 3\\}$ (DHAP branch)\n  $p = f(g) = M_{TPI}(g)$. This yields:\n  - $f(1) = M_{TPI}(1) = 3$\n  - $f(2) = M_{TPI}(2) = 2$\n  - $f(3) = M_{TPI}(3) = 1$\n- **Case 2**: $g \\in \\{4, 5, 6\\}$ (GAP branch)\n  $p = f(g) = g - 3$. This yields:\n  - $f(4) = 4 - 3 = 1$\n  - $f(5) = 5 - 3 = 2$\n  - $f(6) = 6 - 3 = 3$\n\nThe implementation will follow this case-based logic, which directly reflects the branching nature of the biochemical pathway as described.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed or permitted.\n\ndef solve():\n    \"\"\"\n    Solves the glycolysis carbon tracing problem for a given test suite.\n    \"\"\"\n\n    def trace_carbon_atom(g: int) -> int:\n        \"\"\"\n        Traces a labeled carbon atom from glucose to pyruvate.\n\n        This function implements the stepwise atom mapping for the core glycolysis pathway\n        as described in the problem statement. The logic explicitly follows the fate\n        of the carbon atom through the key reaction steps.\n\n        Args:\n            g: The initial 1-based index of the labeled carbon atom in glucose.\n\n        Returns:\n            The final 1-based index of the labeled atom in a pyruvate molecule,\n            or -1 if the input glucose index is invalid.\n        \"\"\"\n        # Step 1: Input validation. Glucose has 6 carbons, indexed 1 through 6.\n        if not (1 <= g <= 6):\n            return -1\n\n        # Step 2: Aldolase cleavage of Fructose-1,6-bisphosphate.\n        # This step determines which triose phosphate receives the labeled carbon.\n        if 1 <= g <= 3:\n            # Carbons 1, 2, 3 of glucose form Dihydroxyacetone Phosphate (DHAP).\n            # The local index within the 3-carbon DHAP fragment is the same as g.\n            # E.g., glucose carbon 1 becomes DHAP carbon 1.\n            dhap_local_index = g\n\n            # Step 3: Triose Phosphate Isomerase (TPI) action on DHAP.\n            # DHAP is isomerized to Glyceraldehyde-3-Phosphate (GAP).\n            # The problem defines a specific atom mapping for this conversion:\n            # 1 -> 3, 2 -> 2, 3 -> 1.\n            tpi_map = {1: 3, 2: 2, 3: 1}\n            gap_index = tpi_map[dhap_local_index]\n\n        else:  # This branch handles g in {4, 5, 6}\n            # Carbons 4, 5, 6 of glucose form Glyceraldehyde-3-Phosphate (GAP) directly.\n            # The local index is relative to the start of this fragment (glucose carbon 4).\n            # E.g., glucose carbon 4 becomes GAP carbon 1.\n            gap_local_index = g - 3\n            gap_index = gap_local_index\n\n        # Step 4: Lower Glycolysis (GAP to Pyruvate).\n        # The carbon backbone is preserved from GAP to pyruvate.\n        # This is an identity mapping: 1 -> 1, 2 -> 2, 3 -> 3.\n        pyruvate_index = gap_index\n\n        return pyruvate_index\n\n    # Define the test cases from the problem statement.\n    # Happy path: [1, 2, 3, 4, 5, 6]\n    # Edge cases: [0, 7]\n    test_cases = [1, 2, 3, 4, 5, 6, 0, 7]\n\n    # Calculate the results for all test cases.\n    results = []\n    for glucose_label in test_cases:\n        result = trace_carbon_atom(glucose_label)\n        results.append(result)\n\n    # Format the results into the required single-line string format.\n    # Example: [3,2,1,1,2,3,-1,-1]\n    # np.array is used to satisfy the problem's library requirements, although a list would suffice.\n    result_array = np.array(results, dtype=int)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, result_array))}]\")\n\nsolve()\n```", "id": "2375342"}, {"introduction": "Beyond individual reactions, pathway databases allow us to see the \"big picture\" of metabolism as an interconnected network. From a systems biology perspective, we can analyze the network's structure to find points of vulnerability. This exercise [@problem_id:2375339] introduces the concept of \"chokepoint\" enzymes, whose removal would fragment the metabolic network, and tasks you with implementing a graph-based algorithm to identify them, a technique often used in drug target discovery.", "problem": "You are given a formal abstraction of a metabolic super-pathway that is consistent with how pathways are captured in the Kyoto Encyclopedia of Genes and Genomes (KEGG) and the Reactome Pathway Database (Reactome). Let the network be a directed, enzyme-labeled reaction graph $G = (V,R)$ where $V = \\{1,2,\\dots,N\\}$ is a finite set of metabolites and $R \\subseteq V \\times V \\times \\mathbb{Z}$ is a finite set of directed reactions. Each reaction is a triple $(u,v,e)$ indicating a directed conversion from metabolite $u$ to metabolite $v$ catalyzed by an enzyme identifier $e \\in \\mathbb{Z}$. For connectivity, consider the underlying undirected simple graph $G^\\ast = (V,E^\\ast)$ defined as follows: for any unordered pair $\\{u,v\\} \\subseteq V$ with $u \\ne v$, the undirected edge $\\{u,v\\}$ is in $E^\\ast$ if and only if there exists at least one reaction $(u,v,e) \\in R$ or $(v,u,e) \\in R$. Multiple reactions and directions between the same metabolites are collapsed to a single undirected edge in $E^\\ast$; however, each undirected edge $\\{u,v\\}$ carries the multiset of enzyme identifiers that appear on any directed reaction between $u$ and $v$ in $R$.\n\nFor any single enzyme identifier $x \\in \\mathbb{Z}$, define the enzyme-removed reaction set $R^{(-x)} = \\{(u,v,e) \\in R \\mid e \\ne x\\}$ and the corresponding underlying undirected simple graph $G^{\\ast(-x)} = (V,E^{\\ast(-x)})$, where $\\{u,v\\} \\in E^{\\ast(-x)}$ if and only if there exists at least one reaction between $u$ and $v$ in $R^{(-x)}$. Let $C(H)$ denote the number of connected components of an undirected graph $H$. An enzyme identifier $x$ is called a chokepoint if $C(G^{\\ast(-x)}) > C(G^\\ast)$.\n\nTask: For each test case below, compute the set of chokepoint enzymes and output them as a list of integers in strictly increasing order. Your program must aggregate the results for all provided test cases into a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[ [a_1,a_2], [\\,], [b_1] ]$). There are no physical units in this problem.\n\nTest suite (each reaction is a triple $(u,v,e)$ with $u,v \\in \\{1,\\dots,N\\}$ and enzyme identifier $e \\in \\mathbb{Z}$):\n\n- Test case $1$:\n  - $N = 5$.\n  - $R = \\{(1,2,10), (2,3,20), (3,2,21), (3,4,30), (4,5,40)\\}$.\n\n- Test case $2$:\n  - $N = 4$.\n  - $R = \\{(1,2,1), (3,4,2)\\}$.\n\n- Test case $3$:\n  - $N = 4$.\n  - $R = \\{(1,2,5), (2,3,6), (3,1,7), (1,4,8)\\}$.\n\n- Test case $4$:\n  - $N = 6$.\n  - $R = \\{(1,2,11), (2,3,12), (3,1,13), (3,4,99), (4,5,99), (5,6,14)\\}$.\n\nRequired final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the $i$-th element is the list of chokepoint enzyme identifiers for test case $i$, sorted in strictly increasing order. For example, a valid output might look like $[[x_1,x_2],[y_1],[\\,],[z_1,z_2]]$.", "solution": "The problem presented is a well-posed exercise in computational network analysis, grounded in the formalisms of graph theory as applied to bioinformatics. It is scientifically sound, objective, and contains all necessary information for a unique solution. We shall proceed with its resolution.\n\nThe central task is to identify \"chokepoint\" enzymes within a given metabolic network. The definition provided is formal and precise: an enzyme $x$ is a chokepoint if its removal from the network increases the number of connected components in the underlying undirected graph representation of the metabolism. This is fundamentally a problem of identifying critical edges, or sets of edges, that act as bridges connecting otherwise disjoint parts of the network. An edge $\\{u,v\\}$ in the underlying graph is sustained by the multiset of all enzymes catalyzing reactions between metabolites $u$ and $v$. The removal of a single enzyme $x$ will only sever the connection between $u$ and $v$ if $x$ is the *sole* enzyme responsible for all reactions between them.\n\nThe algorithm to solve this problem is deductive and systematic. It comprises the following steps:\n\n1.  **Establish Baseline Connectivity**: First, we must characterize the initial state of the network. We construct the full underlying undirected graph, denoted as $G^\\ast = (V, E^\\ast)$. The set of vertices $V$ is given as $\\{1, 2, \\dots, N\\}$. An undirected edge $\\{u,v\\}$ exists in $E^\\ast$ if there is at least one reaction in the set $R$ connecting metabolites $u$ and $v$ in either direction. After constructing $G^\\ast$, we compute its number of connected components, $C(G^\\ast)$. This value serves as our baseline reference for connectivity. The computation of connected components is a standard procedure in graph theory, typically performed using a graph traversal algorithm such as a Depth-First Search (DFS) or Breadth-First Search (BFS).\n\n2.  **Iterative Perturbation and Evaluation**: We must test the criticality of each enzyme individually. We begin by identifying the complete set of unique enzyme identifiers present in the given reaction set $R$. Let this set be $\\mathcal{E}$. For each unique enzyme $x \\in \\mathcal{E}$, we perform a simulation of its removal.\n\n    a.  **Construct the Perturbed Graph**: We define a new reaction set, $R^{(-x)}$, which includes all reactions from $R$ except those catalyzed by enzyme $x$. From this reduced set of reactions, we construct a new underlying undirected graph, $G^{\\ast(-x)} = (V, E^{\\ast(-x)})$. An edge $\\{u,v\\}$ exists in $E^{\\ast(-x)}$ if and only if there remains at least one reaction between $u$ and $v$ in $R^{(-x)}$.\n\n    b.  **Compute Perturbed Connectivity**: Using the same component-counting algorithm, we calculate the number of connected components in the perturbed graph, $C(G^{\\ast(-x)})$.\n\n    c.  **Identify Chokepoints**: The defining condition for a chokepoint is applied. If the number of components in the perturbed graph is strictly greater than in the original graph, i.e., if $C(G^{\\ast(-x)}) > C(G^\\ast)$, then the enzyme $x$ is classified as a chokepoint.\n\n3.  **Aggregate and Report Results**: The enzymes identified as chokepoints in the previous step are collected for each test case. As per the problem specification, this set of enzyme identifiers must be presented as a list sorted in strictly increasing order.\n\nFor the implementation, a graph can be represented using an adjacency list. However, given the specified computational environment, it is more direct to construct a sparse matrix representation of the graph and utilize the `scipy.sparse.csgraph.connected_components` function. This function efficiently determines the number of connected components in a graph represented by its adjacency matrix, thereby streamlining the implementation of steps $1$ and $2b$. The overall logic remains identical. For each test case, we first compute the number of components for the full graph, then iterate through each unique enzyme, re-compute the components for the graph lacking that enzyme's reactions, and compare the counts to identify chokepoints.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import csr_matrix\nfrom scipy.sparse.csgraph import connected_components\n\ndef solve():\n    \"\"\"\n    Solves the chokepoint enzyme identification problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 5,\n            \"R\": [(1, 2, 10), (2, 3, 20), (3, 2, 21), (3, 4, 30), (4, 5, 40)]\n        },\n        # Test case 2\n        {\n            \"N\": 4,\n            \"R\": [(1, 2, 1), (3, 4, 2)]\n        },\n        # Test case 3\n        {\n            \"N\": 4,\n            \"R\": [(1, 2, 5), (2, 3, 6), (3, 1, 7), (1, 4, 8)]\n        },\n        # Test case 4\n        {\n            \"N\": 6,\n            \"R\": [(1, 2, 11), (2, 3, 12), (3, 1, 13), (3, 4, 99), (4, 5, 99), (5, 6, 14)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        R = case[\"R\"]\n        chokepoints = find_chokepoints(N, R)\n        results.append(chokepoints)\n\n    # The final print statement must follow the specified format exactly.\n    # The str() representation of a list in Python matches the required format\n    # for the inner lists, including spaces, e.g., '[10, 30, 40]'.\n    # The join function concatenates these string representations with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef count_components(num_nodes, reactions):\n    \"\"\"\n    Counts the number of connected components in the undirected graph\n    derived from a set of reactions.\n    \n    Args:\n        num_nodes (int): The number of metabolites (nodes) in the graph, N.\n        reactions (list): A list of reaction triples (u, v, e).\n\n    Returns:\n        int: The number of connected components.\n    \"\"\"\n    if not reactions:\n        return num_nodes\n\n    row_indices = []\n    col_indices = []\n\n    for u, v, _ in reactions:\n        # Using 0-based indexing for matrix\n        row_indices.append(u - 1)\n        col_indices.append(v - 1)\n\n    # An undirected graph's adjacency matrix is symmetric.\n    # We add edges in both directions.\n    full_row = row_indices + col_indices\n    full_col = col_indices + row_indices\n    data = np.ones(len(full_row), dtype=int)\n\n    # Create a compressed sparse row (CSR) matrix representation of the graph.\n    graph_matrix = csr_matrix((data, (full_row, full_col)), shape=(num_nodes, num_nodes))\n    \n    # Use SciPy to find connected components.\n    n_components, _ = connected_components(csgraph=graph_matrix, directed=False, return_labels=True)\n    \n    return n_components\n\ndef find_chokepoints(N, R):\n    \"\"\"\n    Identifies chokepoint enzymes for a given metabolic network.\n    \n    Args:\n        N (int): The number of metabolites.\n        R (list): The list of reactions.\n\n    Returns:\n        list: A sorted list of chokepoint enzyme identifiers.\n    \"\"\"\n    if not R:\n        return []\n\n    # Find the set of all unique enzyme identifiers\n    unique_enzymes = sorted(list(set(e for _, _, e in R)))\n\n    # Calculate the number of connected components in the original graph G*\n    base_components = count_components(N, R)\n\n    chokepoints = []\n    for enzyme_to_remove in unique_enzymes:\n        # Construct the enzyme-removed reaction set R^(-x)\n        r_removed = [(u, v, e) for u, v, e in R if e != enzyme_to_remove]\n        \n        # Calculate components in the perturbed graph G*(-x)\n        num_components_removed = count_components(N, r_removed)\n        \n        # Check the chokepoint condition\n        if num_components_removed > base_components:\n            chokepoints.append(enzyme_to_remove)\n            \n    return chokepoints\n\n# Execute the main function\nsolve()\n```", "id": "2375339"}]}