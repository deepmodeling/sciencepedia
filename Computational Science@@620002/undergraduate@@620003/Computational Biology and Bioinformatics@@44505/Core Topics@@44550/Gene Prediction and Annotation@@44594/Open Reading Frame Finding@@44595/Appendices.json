{"hands_on_practices": [{"introduction": "The first step in analyzing a newly sequenced genome is to identify potential protein-coding genes. This exercise [@problem_id:2435536] guides you through the fundamental task of building an Open Reading Frame (ORF) finder from scratch. By translating the rules of the genetic code—start codons, stop codons, and reading frames—into a computational algorithm, you will develop a core skill for any bioinformatician and gain a practical understanding of how genomic information is structured.", "problem": "You are given the task of writing a complete program that, for a set of deoxyribonucleic acid (DNA) contigs, identifies all Open Reading Frames (ORFs) longer than a given threshold measured in codons. An ORF is defined here using the Standard Genetic Code as a maximal in-frame interval that begins with a canonical start codon and ends at the first in-frame stop codon downstream on the same strand. The program must search all six reading frames ($+1$, $+2$, $+3$, $-1$, $-2$, $-3$) for each contig.\n\nFundamental bases and definitions to use:\n- The Central Dogma of molecular biology: DNA is transcribed to ribonucleic acid (RNA) and translated to protein; translation operates on codons, which are contiguous triplets of nucleotides.\n- Under the Standard Genetic Code, there are three stop codons: `TAA`, `TAG`, and `TGA`. The canonical start codon is `ATG`.\n- A reading frame is defined by a phase offset modulo $3$ on a strand. There are three frames per strand, hence six total when considering both forward and reverse-complement strands.\n- The reverse complement of a DNA string is obtained by reversing the string and complementing each nucleotide ($A \\leftrightarrow T, C \\leftrightarrow G$), reflecting antiparallel, complementary base pairing.\n\nYou must derive the algorithm from these principles:\n- On each strand, scan each frame in steps of $3$ nucleotides. Whenever you encounter a start codon `ATG`, find the first in-frame stop codon (`TAA`, `TAG`, or `TGA`) downstream in the same frame. If no in-frame stop codon exists before the end of the contig, this start does not produce a reportable ORF.\n- Let the contig length be $L$. For an ORF found on the forward strand at nucleotide start index $s$ (index of the A in `ATG`) and stop codon start index $t$ (index of the first base of the stop codon), the nucleotide interval for the ORF is $[s, t+3)$ (a half-open interval). The ORF length in codons, excluding the terminal stop codon, is $(t - s)/3 - 1$.\n- For an ORF found on the reverse-complement strand at reverse-complement coordinates $[s_{\\mathrm{rc}}, t_{\\mathrm{rc}}+3)$, map it to the original contig coordinates using $s_{\\mathrm{orig}} = L - (t_{\\mathrm{rc}}+3)$ and $t_{\\mathrm{orig}} = L - s_{\\mathrm{rc}}$. Report coordinates on the original contig in all cases.\n- An ORF is included in the output if and only if its length in codons strictly exceeds a given threshold $N$ (that is, length $> N$). The reported length excludes the terminal stop codon.\n\nRepresent each ORF as a list of four integers $[f, s, e, \\ell]$ where:\n- $f$ is the frame identifier: $+1$, $+2$, $+3$ for forward frames with offsets $0$, $1$, $2$ respectively; and $-1$, $-2$, $-3$ for reverse-complement frames with offsets $0$, $1$, $2$ respectively on the reverse-complement string.\n- $s$ is the $0$-based start index on the original contig (inclusive).\n- $e$ is the $0$-based end index on the original contig (exclusive), i.e., the index immediately after the stop codon.\n- $\\ell$ is the ORF length in codons excluding the terminal stop codon.\n\nSorting rule: For each contig, sort the ORFs by ascending $s$, then ascending $e$, then ascending $f$.\n\nAssumptions and constraints:\n- All contigs are uppercase strings over the alphabet {A, C, G, T}. No ambiguous symbols occur.\n- Use only the Standard Genetic Code with `ATG` as the sole start codon and `TAA`, `TAG`, `TGA` as stop codons.\n- Coordinates must be reported in $0$-based half-open intervals $[s,e)$ on the original contig.\n\nTest suite:\nYour program must compute results for the following four test cases. Each test case is a pair $(\\text{contig}, N)$.\n\n- Test case $1$ (happy path with forward and reverse frames):\n  - Contig: \"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\"\n  - Threshold $N = 2$\n- Test case $2$ (boundary condition where an ORF has length exactly $N$ and must be excluded, alongside a longer ORF):\n  - Contig: \"GGGATGAAATAGGGATGCCACCCTAA\"\n  - Threshold $N = 1$\n- Test case $3$ (edge case with no start codon anywhere):\n  - Contig: \"CCCTTTGGGCCCTAGTAA\"\n  - Threshold $N = 0$\n- Test case $4$ (edge case with a start codon but no in-frame stop before the end; do not report incomplete ORFs):\n  - Contig: \"GGGATGCCCCCCCCGGG\"\n  - Threshold $N = 0$\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets.\n- Each test case’s result must be a list of ORF records $[f,s,e,\\ell]$, sorted as specified. The top-level output is a list of these per-test-case lists.\n- The output must contain no whitespace characters at all. For example, a valid shape is \"[[...],[...],[],[]]\".\n\nYour program must be self-contained and must not read any input. It must compute the results for the four test cases above and print the single required line.", "solution": "The problem presented is a standard exercise in bioinformatics, specifically in the domain of sequence analysis. It requires the identification of Open Reading Frames (ORFs) within given deoxyribonucleic acid (DNA) contigs. The problem is scientifically grounded, well-posed, and provides a complete set of unambiguous definitions and constraints. Therefore, it is deemed valid and a solution can be constructed.\n\nThe fundamental principle is the translation of a nucleotide sequence into an amino acid sequence, which is governed by the genetic code. Translation occurs in a specific reading frame, which is a division of the sequence into contiguous, non-overlapping triplets of nucleotides called codons. An ORF represents a potential protein-coding gene, defined as a sequence starting with a start codon and ending with a stop codon in the same reading frame. As DNA is a double-stranded molecule with antiparallel strands, we must analyze six reading frames in total: three on the forward strand and three on the reverse-complement strand.\n\nThe algorithm is designed to systematically inspect each of the six reading frames for every given contig.\n\n**Step 1: Strand and Frame Iteration**\nThe procedure must be applied to both the forward strand and its reverse complement. The reverse complement is generated by first reversing the DNA sequence and then replacing each nucleotide with its complementary base ($A \\leftrightarrow T$, $C \\leftrightarrow G$). For each strand, there are three reading frames, determined by the starting position of the first codon. These frames begin at indices $0$, $1$, and $2$ of the sequence, respectively. We shall denote these by frame identifiers $+1, +2, +3$ for the forward strand and $-1, -2, -3$ for the reverse-complement strand.\n\n**Step 2: ORF Identification on a Single Strand**\nFor a given strand (either forward or reverse-complement) and a specific frame (offset $i \\in \\{0, 1, 2\\}$), the algorithm scans the sequence for ORFs. The scan proceeds codon by codon, i.e., in steps of $3$ nucleotides, starting from the frame's offset.\n\nThe process for a single frame is as follows:\n1.  Iterate through the sequence with a starting index $s$ such that $s \\equiv i \\pmod 3$.\n2.  At each position $s$, check if the codon `dna[s:s+3]` is the canonical start codon, `ATG`.\n3.  If a start codon is found at index $s$, a subsequent search is initiated from position $s+3$ to find the first in-frame stop codon (`TAA`, `TAG`, or `TGA`). This search also proceeds in steps of $3$.\n4.  If a stop codon is found at index $t$, this defines an ORF. The problem statement defines the length of this ORF in codons, excluding the stop codon, as $\\ell = (t-s)/3 - 1$. An integer division can be used as $(t-s)$ is guaranteed to be a multiple of $3$ for an in-frame stop.\n5.  This ORF is considered valid for reporting only if its length $\\ell$ is strictly greater than the given threshold $N$.\n6.  If no in-frame stop codon is found before the end of the sequence, the start codon at $s$ does not initiate a complete ORF, and nothing is reported for it.\n7.  The scan for the next start codon resumes from the position immediately following the current start codon, i.e., $s+3$, to ensure all potential ORFs are found. The problem defines an ORF as a \"maximal in-frame interval\", which we interpret as the interval from a given start codon to the very first stop codon encountered in that frame.\n\n**Step 3: Coordinate Transformation for Reverse-Complement Strand**\nORFs found on the reverse-complement strand must have their coordinates mapped back to the coordinate system of the original forward strand. Let the original contig have length $L$. If an ORF is found on the reverse-complement strand with a start index $s_{rc}$ and a stop codon beginning at index $t_{rc}$, its nucleotide interval is $[s_{rc}, t_{rc}+3)$. The corresponding interval on the original contig is derived from the antiparallel nature of the strands. The start coordinate on the original contig is $s_{orig} = L - (t_{rc}+3)$, and the exclusive end coordinate is $e_{orig} = L - s_{rc}$.\n\n**Step 4: Record Formulation and Sorting**\nEach valid ORF is recorded as a list of four integers: $[f, s, e, \\ell]$. Here, $f$ is the frame identifier ($+1, +2, +3, -1, -2, -3$), $s$ is the $0$-based start index on the original contig, $e$ is the $0$-based exclusive end index, and $\\ell$ is the calculated length in codons. After all ORFs for a contig are identified, the resulting list is sorted. The specified sorting criteria are: primarily by ascending start position $s$, secondarily by ascending end position $e$, and tertiarily by ascending frame identifier $f$.\n\nThis structured approach ensures that all six reading frames are exhaustively searched, and any identified ORFs are correctly filtered, formatted, and sorted according to the problem's strict requirements, thereby yielding a determinate and correct solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the ORF finding problem for the predefined test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"AAAATGAAACCCGGGTTTTAAAATGGCCGAACCTTAGTCAGGGTTTTTTCAT\", 2),\n        (\"GGGATGAAATAGGGATGCCACCCTAA\", 1),\n        (\"CCCTTTGGGCCCTAGTAA\", 0),\n        (\"GGGATGCCCCCCCCGGG\", 0),\n    ]\n\n    results = []\n    for contig, n_threshold in test_cases:\n        results.append(find_all_orfs(contig, n_threshold))\n\n    # Final print statement in the exact required format.\n    # The string representation of a list includes spaces, which must be removed.\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\ndef find_all_orfs(contig, n_threshold):\n    \"\"\"\n    Finds all ORFs in a given contig that are longer than a specified threshold.\n    Searches all six reading frames.\n\n    Args:\n        contig (str): The DNA sequence.\n        n_threshold (int): The minimum number of codons (exclusive of stop)\n                           for an ORF to be reported. Length must be > threshold.\n    \n    Returns:\n        list: A sorted list of ORF records. Each record is [frame, start, end, length].\n    \"\"\"\n    stop_codons = {\"TAA\", \"TAG\", \"TGA\"}\n    start_codon = \"ATG\"\n    all_orfs = []\n    L = len(contig)\n\n    # Process forward strand (+1, +2, +3 frames)\n    for offset in range(3):\n        frame_id = offset + 1\n        # Iterate through the sequence in steps of 3 for the current frame\n        for s in range(offset, L - 5, 3):\n            if contig[s:s+3] == start_codon:\n                # Found a start codon, now search for the first in-frame stop codon\n                for t in range(s + 3, L - 2, 3):\n                    if contig[t:t+3] in stop_codons:\n                        # ORF found, calculate length and check against threshold\n                        length = (t - s) // 3 - 1\n                        if length > n_threshold:\n                            e = t + 3\n                            all_orfs.append([frame_id, s, e, length])\n                        # Break inner loop as we only care about the first stop\n                        break\n\n    # Process reverse-complement strand (-1, -2, -3 frames)\n    # The translation map for complementing DNA\n    complement_map = str.maketrans(\"ATCG\", \"TAGC\")\n    rc_contig = contig.translate(complement_map)[::-1]\n    \n    for offset in range(3):\n        frame_id = -(offset + 1)\n        for s_rc in range(offset, L - 5, 3):\n            if rc_contig[s_rc:s_rc+3] == start_codon:\n                for t_rc in range(s_rc + 3, L - 2, 3):\n                    if rc_contig[t_rc:t_rc+3] in stop_codons:\n                        length = (t_rc - s_rc) // 3 - 1\n                        if length > n_threshold:\n                            # Map coordinates from reverse-complement to original\n                            s_orig = L - (t_rc + 3)\n                            e_orig = L - s_rc\n                            all_orfs.append([frame_id, s_orig, e_orig, length])\n                        break\n\n    # Sort the collected ORFs according to the specified rule: s, then e, then f\n    # In the list [f, s, e, l], these correspond to indices 0, 1, 2\n    all_orfs.sort(key=lambda orf: (orf[1], orf[2], orf[0]))\n\n    return all_orfs\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2435536"}, {"introduction": "An ORF finder will often identify numerous short candidates, but how can we distinguish a meaningful biological signal from random statistical noise? This practice [@problem_id:2410641] challenges you to think like a statistical bioinformatician by deriving a significance threshold from first principles. You will calculate the minimum ORF length $L$ required to be confident that it is not a chance occurrence in a random sequence, a crucial step in filtering genomic data for genuine biological features.", "problem": "A bacterial genome has length $N = 5 \\times 10^{6}$ nucleotides and background nucleotide frequencies $p_{A} = 0.3$, $p_{T} = 0.3$, $p_{G} = 0.2$, and $p_{C} = 0.2$. Assume an independent and identically distributed (i.i.d.) nucleotide model and independence between successive codons. An open reading frame (ORF) is defined as a sequence that begins with the canonical start codon ATG and continues in-frame without encountering any in-frame stop codon for at least $L$ codons downstream of the start codon. Consider the three standard stop codons TAA, TAG, and TGA. The genome is scanned on both strands and in all three reading frames per strand.\n\nYou want a statistical decision rule that robustly distinguishes true, but very short, ORFs from stochastically generated ones by controlling the expected number of false-positive ORFs genome-wide to be at most $\\alpha = 0.05$ under the null random-sequence model described above. Here, a false-positive ORF is any ORF that meets the definition above purely by chance in random sequence.\n\nDetermine the minimal integer $L$ (in codons) such that the expected number of false-positive ORFs across the entire genome, over both strands and all reading frames, is at most $\\alpha$. Report your answer as the minimal integer number of codons. No rounding is required beyond choosing the minimal integer that satisfies the criterion.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Genome length: $N = 5 \\times 10^{6}$ nucleotides\n- Nucleotide frequencies: $p_{A} = 0.3$, $p_{T} = 0.3$, $p_{G} = 0.2$, $p_{C} = 0.2$\n- Sequence model: independent and identically distributed (i.i.d.) nucleotides\n- Codon model: independence between successive codons\n- ORF definition: starts with ATG, followed by at least $L$ in-frame non-stop codons\n- Start codon: ATG\n- Stop codons: TAA, TAG, TGA\n- Scanning parameters: both strands, three reading frames per strand\n- Statistical threshold: expected number of false-positive ORFs genome-wide is at most $\\alpha = 0.05$\n- Objective: Find the minimal integer $L$ (in codons) satisfying the criterion.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the required criteria.\n- **Scientifically Grounded**: The problem is based on fundamental principles of computational biology and statistics. The use of an i.i.d. random sequence model to estimate the number of chance occurrences of a feature (an ORF) is a standard technique in bioinformatics for setting significance thresholds.\n- **Well-Posed**: The problem is clearly defined. It provides all necessary parameters ($N$, nucleotide frequencies, $\\alpha$) to construct a mathematical inequality and solve for the single unknown variable, $L$. A unique integer solution is expected.\n- **Objective**: The problem is stated in precise, quantitative terms, free from any subjective or ambiguous language.\n\n**Step 3: Verdict and Action**\nThe problem is scientifically sound, well-posed, and objective. It contains no contradictions, missing information, or logical flaws. Therefore, it is deemed **valid**. A solution will be derived.\n\nThe objective is to find the minimal integer $L$ such that the expected number of false-positive Open Reading Frames, denoted $E[N_{FP}]$, is no greater than $\\alpha$. This is expressed by the inequality:\n$$\nE[N_{FP}] \\leq \\alpha\n$$\nThe expected number of false positives is the product of the number of locations at which an ORF can potentially start and the probability that a random ORF of the required length occurs at any such location.\n\nFirst, we calculate the necessary probabilities based on the provided i.i.d. nucleotide model. The probability of any codon is the product of the probabilities of its constituent nucleotides.\n\nThe probability of the start codon, ATG, is:\n$$\nP_{\\text{start}} = P(\\text{ATG}) = p_{A} \\times p_{T} \\times p_{G} = 0.3 \\times 0.3 \\times 0.2 = 0.018\n$$\n\nNext, we calculate the probability of encountering one of the three stop codons: TAA, TAG, TGA.\n$$\nP(\\text{TAA}) = p_{T} \\times p_{A} \\times p_{A} = 0.3 \\times 0.3 \\times 0.3 = 0.027\n$$\n$$\nP(\\text{TAG}) = p_{T} \\times p_{A} \\times p_{G} = 0.3 \\times 0.3 \\times 0.2 = 0.018\n$$\n$$\nP(\\text{TGA}) = p_{T} \\times p_{G} \\times p_{A} = 0.3 \\times 0.2 \\times 0.3 = 0.018\n$$\nSince these are mutually exclusive events, the total probability of a randomly chosen codon being a stop codon is their sum:\n$$\nP_{\\text{stop}} = P(\\text{TAA}) + P(\\text{TAG}) + P(\\text{TGA}) = 0.027 + 0.018 + 0.018 = 0.063\n$$\nThe probability of a codon *not* being a stop codon is therefore:\n$$\nP_{\\text{non-stop}} = 1 - P_{\\text{stop}} = 1 - 0.063 = 0.937\n$$\n\nA false-positive ORF is defined as a sequence that begins with a start codon (ATG) and is followed by at least $L$ in-frame non-stop codons. Assuming independence between successive codons, the probability of such an event, $p_{FP}$, starting at a specific codon position is:\n$$\np_{FP} = P_{\\text{start}} \\times (P_{\\text{non-stop}})^{L}\n$$\n\nNext, we must determine the total number of positions, $N_{\\text{trials}}$, where we test for the start of an ORF. The genome is scanned on both strands, and in all three reading frames on each strand. For a long genome of length $N$, we can approximate the number of possible starting positions for a codon in one reading frame as $N/3$. Since there are three reading frames on the forward strand and three on the reverse strand, the total number of distinct, non-overlapping codon positions is $6 \\times (N/3) = 2N$. A more direct view is that every nucleotide position on both strands (total $2N$ positions) can be considered the start of a triplet in one specific reading frame. Therefore, the total number of trials is effectively $2N$.\n$$\nN_{\\text{trials}} = 2N = 2 \\times (5 \\times 10^{6}) = 10^{7}\n$$\nThe expected number of false-positive ORFs is the product of the number of trials and the probability of a false positive at each trial:\n$$\nE[N_{FP}] = N_{\\text{trials}} \\times p_{FP} = 2N \\times P_{\\text{start}} \\times (P_{\\text{non-stop}})^{L}\n$$\nWe must find the minimal integer $L$ that satisfies $E[N_{FP}] \\leq \\alpha$. We substitute the known values into the inequality:\n$$\n2 \\times (5 \\times 10^{6}) \\times (0.018) \\times (0.937)^{L} \\leq 0.05\n$$\n$$\n10^{7} \\times 0.018 \\times (0.937)^{L} \\leq 0.05\n$$\n$$\n180000 \\times (0.937)^{L} \\leq 0.05\n$$\nWe isolate the term containing $L$:\n$$\n(0.937)^{L} \\leq \\frac{0.05}{180000} = \\frac{1}{3600000}\n$$\nTo solve for $L$, we take the natural logarithm of both sides:\n$$\n\\ln((0.937)^{L}) \\leq \\ln\\left(\\frac{1}{3600000}\\right)\n$$\n$$\nL \\ln(0.937) \\leq -\\ln(3600000)\n$$\nSince $\\ln(0.937)$ is a negative number, dividing by it reverses the direction of the inequality:\n$$\nL \\geq \\frac{-\\ln(3600000)}{\\ln(0.937)} = \\frac{\\ln(3600000)}{-\\ln(0.937)}\n$$\nNow, we compute the value:\n$$\n\\ln(3600000) \\approx 15.09659\n$$\n$$\n\\ln(0.937) \\approx -0.065056\n$$\n$$\nL \\geq \\frac{15.09659}{-(-0.065056)} \\approx \\frac{15.09659}{0.065056} \\approx 232.054\n$$\nSince $L$ must be an integer and satisfy $L \\geq 232.054$, the minimal integer value for $L$ is $233$. This is the minimal number of codons required downstream of the start codon to ensure the expected number of false positives genome-wide is at most $0.05$.", "answer": "$$\n\\boxed{233}\n$$", "id": "2410641"}, {"introduction": "Beyond simple length cutoffs, modern bioinformatics leverages multiple lines of evidence to identify genes. This exercise [@problem_id:2410602] introduces a machine learning approach, where candidate ORFs are evaluated based on a set of features like length, GC content, and codon usage bias. By analyzing labeled training data, you will develop a deterministic classifier, learning the core principle of how data-driven models can distinguish true genes from non-coding sequences with high accuracy.", "problem": "You are given labeled data for candidate Open Reading Frames (ORFs) to decide whether each ORF is a real protein-coding gene. Each candidate ORF is represented by a feature vector $x \\in \\mathbb{R}^3$ with coordinates ordered as $x = (L, G, C)$, where $L$ is the ORF length expressed in nucleotides (unit: nucleotides), $G$ is the Guanine-Cytosine (GC) content expressed as a decimal fraction in $[0,1]$ (unitless), and $C$ is a codon usage bias score expressed as a decimal fraction in $[0,1]$ (unitless), such as a Codon Adaptation Index (CAI). The target label $y \\in \\{0,1\\}$ indicates whether the ORF is considered to be a real gene ($y=1$) or not ($y=0$).\n\nYour task is to use the training set below to learn a deterministic binary classifier that maps any feature vector $x$ to a predicted label $\\hat{y} \\in \\{0,1\\}$ based only on the training data and the mathematical structure of the problem. You must then apply your learned classifier to the provided test suite and output the predicted labels for all test cases in the exact format specified.\n\nTraining set of $16$ labeled examples $(x_i, y_i)$:\n- $((900,\\,0.50,\\,0.82),\\,1)$\n- $((1200,\\,0.55,\\,0.88),\\,1)$\n- $((1500,\\,0.60,\\,0.92),\\,1)$\n- $((750,\\,0.48,\\,0.75),\\,1)$\n- $((1000,\\,0.40,\\,0.80),\\,1)$\n- $((1800,\\,0.65,\\,0.85),\\,1)$\n- $((600,\\,0.52,\\,0.86),\\,1)$\n- $((90,\\,0.45,\\,0.30),\\,0)$\n- $((150,\\,0.70,\\,0.28),\\,0)$\n- $((210,\\,0.35,\\,0.33),\\,0)$\n- $((300,\\,0.50,\\,0.40),\\,0)$\n- $((240,\\,0.62,\\,0.36),\\,0)$\n- $((420,\\,0.55,\\,0.38),\\,0)$\n- $((900,\\,0.55,\\,0.34),\\,0)$\n- $((360,\\,0.42,\\,0.45),\\,0)$\n- $((120,\\,0.60,\\,0.60),\\,0)$\n\nTest suite of $8$ unlabeled examples $x_j$ to classify:\n- $(1200,\\,0.65,\\,0.90)$\n- $(90,\\,0.45,\\,0.31)$\n- $(1500,\\,0.42,\\,0.35)$\n- $(300,\\,0.50,\\,0.50)$\n- $(1800,\\,0.30,\\,0.70)$\n- $(450,\\,0.60,\\,0.62)$\n- $(720,\\,0.50,\\,0.80)$\n- $(960,\\,0.58,\\,0.55)$\n\nAll GC content and codon usage bias values must be treated as decimal fractions (for example, $0.50$ for $50$ percent). ORF lengths must be treated in nucleotides. No additional inputs are provided.\n\nFinal output format:\n- Your program should produce a single line of output containing the predicted labels for the $8$ test cases as a comma-separated list of integers enclosed in square brackets, with no spaces. For example, an output with eight predictions must have the exact form $[a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8]$ where each $a_j \\in \\{0,1\\}$.\n\nDesign requirements:\n- The learned classifier must be fully determined by the given training data and must be deterministic.\n- The solution must be universally implementable based on the mathematical specification, independent of any particular programming language.\n- There are no physical units to convert besides treating length in nucleotides and the other two features as unitless fractions.\n- The answer for each test case is an integer in $\\{0,1\\}$, and the final output aggregates these into a single list as described above.", "solution": "The supplied problem will first be validated for scientific and logical integrity.\n\nStep 1: Extract Givens\nThe problem provides the following information:\n- Feature vector: $x \\in \\mathbb{R}^3$ with coordinates $x = (L, G, C)$.\n- $L$: ORF length in nucleotides.\n- $G$: Guanine-Cytosine (GC) content, a unitless fraction in $[0,1]$.\n- $C$: Codon usage bias score, a unitless fraction in $[0,1]$.\n- Target label: $y \\in \\{0,1\\}$, where $y=1$ for a real gene and $y=0$ otherwise.\n- A training set of $16$ labeled examples $(x_i, y_i)$:\n  - For $y=1$: $((900,0.50,0.82),1)$, $((1200,0.55,0.88),1)$, $((1500,0.60,0.92),1)$, $((750,0.48,0.75),1)$, $((1000,0.40,0.80),1)$, $((1800,0.65,0.85),1)$, $((600,0.52,0.86),1)$.\n  - For $y=0$: $((90,0.45,0.30),0)$, $((150,0.70,0.28),0)$, $((210,0.35,0.33),0)$, $((300,0.50,0.40),0)$, $((240,0.62,0.36),0)$, $((420,0.55,0.38),0)$, $((900,0.55,0.34),0)$, $((360,0.42,0.45),0)$, $((120,0.60,0.60),0)$.\n- A test suite of $8$ unlabeled examples $x_j$ for classification: $(1200,0.65,0.90)$, $(90,0.45,0.31)$, $(1500,0.42,0.35)$, $(300,0.50,0.50)$, $(1800,0.30,0.70)$, $(450,0.60,0.62)$, $(720,0.50,0.80)$, $(960,0.58,0.55)$.\n- Design requirement: The classifier must be deterministic and fully determined by the provided training data and the mathematical structure of the problem.\n\nStep 2: Validate Using Extracted Givens\nThe problem is assessed against the required criteria.\n- **Scientifically Grounded**: The problem describes a standard binary classification task in bioinformatics—distinguishing protein-coding Open Reading Frames (ORFs) from non-coding ones. The features used—length ($L$), GC content ($G$), and codon usage bias ($C$)—are canonical and widely employed for this purpose. The numerical values provided for these features are within realistic biological ranges. The problem is scientifically sound.\n- **Well-Posed**: The problem provides a complete training dataset and a test dataset, with a clear objective. The constraint that the classifier must be \"fully determined by the given training data and the mathematical structure\" directs the choice of model. It implies that a simple, canonical model whose parameters are uniquely derivable from the data should be used, rather than arbitrarily selecting a complex model with tunable hyperparameters. This structure steers the problem towards a unique solution, such as one based on linear separability.\n- **Objective**: The problem is stated using precise numerical data and clear, unambiguous definitions for features and labels. It is free of subjective language.\n\nThe problem does not violate any of the invalidity criteria. It is a well-defined, self-contained, and scientifically relevant classification problem.\n\nStep 3: Verdict and Action\nThe problem is **valid**. A solution will be constructed.\n\nSolution:\nThe task is to construct a deterministic binary classifier $\\hat{y} = f(x)$ for ORF classification based on the provided training data. The feature space is three-dimensional, spanned by length ($L$), GC-content ($G$), and codon usage bias ($C$). The most fundamental approach for classification in a continuous feature space is to find a separating hyperplane. A linear classifier takes the form $\\text{sign}(w \\cdot x + b)$, where $w$ is a weight vector and $b$ is a bias term.\n\nThe mandate for a classifier \"fully determined by the... mathematical structure\" suggests we should seek the simplest possible decision rule that is consistent with the training data. We begin by inspecting the distribution of each feature for the two classes.\n\nLet $S_1$ be the set of training examples with label $y=1$ and $S_0$ be the set with label $y=0$.\n\n$1$. Analysis of ORF Length ($L$):\n- For $y=1$: $L \\in \\{600, 750, 900, 1000, 1200, 1500, 1800\\}$. Range is $[600, 1800]$.\n- For $y=0$: $L \\in \\{90, 120, 150, 210, 240, 300, 360, 420, 900\\}$. Range is $[90, 900]$.\nThe ranges for $L$ overlap. For instance, the value $L=900$ appears in both classes. Therefore, a simple threshold on $L$ cannot perfectly separate the classes.\n\n$2$. Analysis of GC-Content ($G$):\n- For $y=1$: $G \\in \\{0.40, 0.48, 0.50, 0.52, 0.55, 0.60, 0.65\\}$. Range is $[0.40, 0.65]$.\n- For $y=0$: $G \\in \\{0.35, 0.42, 0.45, 0.50, 0.55, 0.60, 0.62, 0.70\\}$. Range is $[0.35, 0.70]$.\nThe ranges for $G$ also show significant overlap. A simple threshold on $G$ is insufficient.\n\n$3$. Analysis of Codon Usage Bias ($C$):\n- For $y=1$: $C \\in \\{0.75, 0.80, 0.82, 0.85, 0.86, 0.88, 0.92\\}$. Range is $[0.75, 0.92]$.\n- For $y=0$: $C \\in \\{0.28, 0.30, 0.33, 0.34, 0.36, 0.38, 0.40, 0.45, 0.60\\}$. Range is $[0.28, 0.60]$.\nThe ranges for the feature $C$ are disjoint. All examples with $y=1$ have $C \\ge 0.75$, while all examples with $y=0$ have $C \\le 0.60$. This means the training data are linearly separable along the $C$ axis alone.\n\nA separating gap exists for the $C$ feature on the interval $(0.60, 0.75)$. This observation allows for the construction of a simple, yet powerful, deterministic classifier. The most robust single-feature classifier places the decision boundary at the midpoint of the separating gap. This choice is equivalent to the solution produced by a hard-margin Support Vector Machine (SVM) for data that is separable along a single coordinate axis. The support vectors would be the instance from $S_0$ with the maximum $C$ value and the instance from $S_1$ with the minimum $C$ value.\n- Maximum $C$ for $y=0$: $C_{\\max,0} = 0.60$.\n- Minimum $C$ for $y=1$: $C_{\\min,1} = 0.75$.\n\nThe decision threshold $T$ is therefore uniquely determined as the midpoint of this gap:\n$$T = \\frac{C_{\\max,0} + C_{\\min,1}}{2} = \\frac{0.60 + 0.75}{2} = \\frac{1.35}{2} = 0.675$$\n\nThe resulting classification rule is:\nFor a given feature vector $x=(L, G, C)$, the predicted label $\\hat{y}$ is:\n$$ \\hat{y} = \\begin{cases} 1 & \\text{if } C > 0.675 \\\\ 0 & \\text{if } C \\le 0.675 \\end{cases} $$\nThis classifier is deterministic, uses only the training data for its construction, and is based on the fundamental mathematical principle of finding a maximum-margin separator for a linearly separable problem.\n\nWe now apply this learned classifier to the provided test suite.\n\n1.  $x_1 = (1200, 0.65, 0.90)$: $C = 0.90$. Since $0.90 > 0.675$, $\\hat{y}_1 = 1$.\n2.  $x_2 = (90, 0.45, 0.31)$: $C = 0.31$. Since $0.31 \\le 0.675$, $\\hat{y}_2 = 0$.\n3.  $x_3 = (1500, 0.42, 0.35)$: $C = 0.35$. Since $0.35 \\le 0.675$, $\\hat{y}_3 = 0$.\n4.  $x_4 = (300, 0.50, 0.50)$: $C = 0.50$. Since $0.50 \\le 0.675$, $\\hat{y}_4 = 0$.\n5.  $x_5 = (1800, 0.30, 0.70)$: $C = 0.70$. Since $0.70 > 0.675$, $\\hat{y}_5 = 1$.\n6.  $x_6 = (450, 0.60, 0.62)$: $C = 0.62$. Since $0.62 \\le 0.675$, $\\hat{y}_6 = 0$.\n7.  $x_7 = (720, 0.50, 0.80)$: $C = 0.80$. Since $0.80 > 0.675$, $\\hat{y}_7 = 1$.\n8.  $x_8 = (960, 0.58, 0.55)$: $C = 0.55$. Since $0.55 \\le 0.675$, $\\hat{y}_8 = 0$.\n\nThe final sequence of predicted labels is $[1, 0, 0, 0, 1, 0, 1, 0]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the ORF classification problem by applying a deterministic classifier\n    derived from the training data.\n    \"\"\"\n    \n    # The test suite consists of 8 feature vectors, each with components\n    # (L, G, C) representing ORF length, GC content, and codon usage bias.\n    test_cases = [\n        (1200, 0.65, 0.90),\n        (90, 0.45, 0.31),\n        (1500, 0.42, 0.35),\n        (300, 0.50, 0.50),\n        (1800, 0.30, 0.70),\n        (450, 0.60, 0.62),\n        (720, 0.50, 0.80),\n        (960, 0.58, 0.55),\n    ]\n\n    # From the analysis of the training data, the codon usage bias feature 'C'\n    # provides a perfect linear separation between the two classes (y=0 and y=1).\n    #\n    # Max 'C' for class 0: 0.60\n    # Min 'C' for class 1: 0.75\n    #\n    # The deterministic decision boundary is set at the midpoint of the gap,\n    # which corresponds to the maximum-margin separating hyperplane.\n    threshold = (0.60 + 0.75) / 2.0  # This equals 0.675\n\n    results = []\n    for case in test_cases:\n        # The feature vector is (L, G, C). We only need C for classification.\n        # The third element in the tuple (index 2) is the C value.\n        codon_usage_bias = case[2]\n        \n        # Apply the classification rule:\n        # Predict 1 (real gene) if C > threshold, otherwise predict 0.\n        prediction = 1 if codon_usage_bias > threshold else 0\n        results.append(prediction)\n\n    # Format the final output as a comma-separated list of integers\n    # enclosed in square brackets, with no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2410602"}]}