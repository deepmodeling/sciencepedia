{"hands_on_practices": [{"introduction": "The immense speed of BLAST is due to its nature as a heuristic, a clever shortcut that sacrifices guaranteed optimality for practical efficiency. This practice challenges you to think critically about this trade-off by comparing BLASTP to the exhaustive Smith-Waterman algorithm. By identifying scenarios where the heuristic fails [@problem_id:2376082], you will develop a deep intuition for the core mechanics of seed-and-extend algorithms and learn to anticipate when their results might not tell the whole story.", "problem": "You are asked to reason about circumstances under which an exact dynamic programming local alignment can substantially outperform a seeding heuristic when comparing proteins. Use only the following fundamental bases: (i) the Central Dogma of Molecular Biology (deoxyribonucleic acid to ribonucleic acid to protein), implying that protein sequences are amino acid strings derived from coding sequences; (ii) the definition of a local alignment as an optimization over all substrings that maximizes a sum of substitution scores minus gap penalties; and (iii) the design of the Basic Local Alignment Search Tool (BLAST) family as a seed-and-extend heuristic that identifies short high-scoring words and extends them, often with filters for low-complexity regions and composition-based score adjustments.\n\nConsider default protein–protein searches, where Smith–Waterman local alignment computes the optimal score under a fixed substitution matrix and affine gap penalty, while BLASTP (protein–protein BLAST) uses short-word seeding of length $w$ with a neighborhood threshold $T$, optional low-complexity masking of the query, composition-based score adjustment, and an $X$-drop criterion during extension. You seek a realistic protein pair where the optimal Smith–Waterman alignment score is significantly higher than the score reported by BLASTP, and you must explain why the BLASTP heuristic failed for this case. Assume a conventional protein substitution matrix (for example, a BLOSUM family matrix) and standard affine gap costs.\n\nWhich option(s) most plausibly identify such a protein pair and correctly explain the failure mechanism of the BLASTP heuristic?\n\nA. Two proteins share a long coiled-coil segment that is the only conserved region. The segment is low-complexity and compositionally biased (enriched in a few hydrophobic residues), so default low-complexity masking removes it from the BLASTP query before seeding. Smith–Waterman, run without masking, aligns the coiled-coil and accrues many positive hydrophobic–hydrophobic matches, yielding a high score; BLASTP reports little or nothing because there are effectively no seeds to extend.\n\nB. Two proteins each contain many proline-rich repeats of the form “PxxP” dispersed throughout, causing numerous identical short words. BLASTP produces multiple high-scoring seeds that extend into strong local alignments, so its score matches or exceeds Smith–Waterman; therefore Smith–Waterman will not substantially outperform BLASTP here.\n\nC. A protein is compared to a nucleotide coding sequence using BLASTP with default parameters. The dynamic program on the protein space should still find the optimal alignment, but BLASTP underperforms because a translated search would be more appropriate. Therefore, the Smith–Waterman score is much higher.\n\nD. Two homologous proteins share a conserved domain in which similarity is interrupted by frequent short insertions and deletions: in the true alignment, gaps occur every few residues, preventing long contiguous matches. Under affine gap penalties, Smith–Waterman pays gap opening once per gap and accumulates many positive conservative substitutions across the domain, producing a high local score. BLASTP requires at least one above-threshold seed of length $w$ aligned without gaps and early rapid score gain during extension; frequent interruptions cause the extension to fail the $X$-drop criterion, so the reported BLASTP score is low.\n\nE. Two proteins are homologous but have extreme compositional bias (for example, lysine/arginine-rich regions). BLASTP applies composition-based score matrix adjustment that down-weights matches consistent with the biased background, reducing seed scores and high-scoring segment pair growth below reporting thresholds. Smith–Waterman using a fixed substitution matrix without composition-based adjustment accumulates many positive scores, yielding a substantially higher optimal local alignment score.\n\nChoose all that apply.", "solution": "The problem asks to identify scenarios where an exact dynamic programming local alignment, specifically the Smith-Waterman algorithm, would produce a significantly higher score than the BLASTP heuristic for a pair of proteins. The analysis must be based on the fundamental mechanisms of these algorithms.\n\nThe Smith-Waterman algorithm guarantees finding the optimal local alignment score for a given pair of sequences under a specific scoring system (substitution matrix and gap penalties). It is an exhaustive, optimal method based on dynamic programming.\n\nThe BLASTP algorithm is a heuristic designed for speed. Its core strategy is \"seed-and-extend\".\n$1$. **Seeding**: It first identifies short, high-scoring, gapless word pairs of length $w$ (typically $w=3$ for proteins) that meet a score threshold $T$. Query sequences are often pre-processed to mask low-complexity regions.\n$2$. **Extension**: These seeds are then extended in both directions, also without gaps initially. The extension accumulates a score. If the score drops by more than a value $X$ from the maximum score seen so far for that extension (the $X$-drop criterion), the extension is terminated. Gapped alignments are only attempted for high-scoring initial results.\n$3$. **Adjustments**: Modern BLAST versions incorporate composition-based statistics to adjust substitution scores, mitigating spuriously high scores between sequences with similar but non-homologous compositional bias.\n\nA failure of BLASTP to find a high-scoring alignment that Smith-Waterman can find must stem from a failure in one of these heuristic steps. We will now evaluate each option.\n\n**A. Two proteins share a long coiled-coil segment that is the only conserved region. The segment is low-complexity and compositionally biased (enriched in a few hydrophobic residues), so default low-complexity masking removes it from the BLASTP query before seeding. Smith–Waterman, run without masking, aligns the coiled-coil and accrues many positive hydrophobic–hydrophobic matches, yielding a high score; BLASTP reports little or nothing because there are effectively no seeds to extend.**\n\nThis option describes a failure at the pre-processing stage of BLASTP.\n- **BLASTP Mechanism**: Low-complexity regions (LCRs), such as coiled-coils rich in a few residue types (e.g., Leucine), are often filtered by default in BLASTP (e.g., using the SEG program). This means the letters in these regions of the query sequence are replaced by a placeholder (like 'X') and are not used for generating seeds. If the only region of true similarity is an LCR, then after masking, no seeds corresponding to this region can be found.\n- **Smith-Waterman Mechanism**: The Smith-Waterman algorithm, as specified, is run without masking. It will evaluate the alignment of the coiled-coil regions. Given that these are conserved, the alignment will consist of many matches of identical or similar hydrophobic residues. In a standard substitution matrix like BLOSUM62, these matches (e.g., L-L, I-I, V-V) have high positive scores. The sum of these scores will result in a high optimal local alignment score.\n- **Conclusion**: The score from Smith-Waterman would be high, while the score from BLASTP would be near zero, because the heuristic effectively ignored the only region of similarity. This scenario is realistic and the explanation of the failure mechanism is correct.\n- **Verdict**: **Correct**.\n\n**B. Two proteins each contain many proline-rich repeats of the form “PxxP” dispersed throughout, causing numerous identical short words. BLASTP produces multiple high-scoring seeds that extend into strong local alignments, so its score matches or exceeds Smith–Waterman; therefore Smith–Waterman will not substantially outperform BLASTP here.**\n\nThis option describes a scenario of repetitive sequences.\n- **BLASTP Mechanism**: The presence of numerous identical short words (e.g., from the 'PxxP' repeats) would lead to the generation of many seeds. BLASTP is highly effective at finding and extending such seeds. The option correctly states that this would lead to strong local alignments found by BLASTP.\n- **Comparison**: The statement \"its score matches or exceeds Smith–Waterman\" contains a logical error. The score of a heuristic cannot exceed the optimal score found by an exact algorithm like Smith-Waterman using an equivalent scoring system. However, the main point of the option is that BLASTP *performs well* in this case. The problem asks for a scenario where Smith-Waterman *outperforms* BLASTP. This option describes the opposite.\n- **Conclusion**: This option describes a success case for the BLASTP heuristic, not a failure case.\n- **Verdict**: **Incorrect**.\n\n**C. A protein is compared to a nucleotide coding sequence using BLASTP with default parameters. The dynamic program on the protein space should still find the optimal alignment, but BLASTP underperforms because a translated search would be more appropriate. Therefore, the Smith–Waterman score is much higher.**\n\nThis option describes a misuse of the specified bioinformatics tool.\n- **Scientific Validity**: BLASTP is designed for protein-protein comparison. It uses a protein substitution matrix (e.g., BLOSUM62) to score alignments. A nucleotide sequence database consists of the alphabet {A, C, G, T}. It is fundamentally incompatible with a protein query {A, C, D, ..., Y} and a protein scoring matrix. Attempting to run BLASTP this way is a user error and would produce meaningless results. The appropriate tool would be TBLASTN, which translates the nucleotide database in all $6$ reading frames and then performs a protein-protein comparison.\n- **The premise is invalid**: The problem assumes a comparison between a \"protein pair\". A protein and a nucleotide sequence do not constitute a protein pair. The failure is not an algorithmic limitation of the heuristic in a valid context, but rather an incorrect application of the tool.\n- **Conclusion**: The option is based on a nonsensical premise and does not describe a valid comparison scenario from which to judge the algorithms' relative performance.\n- **Verdict**: **Incorrect**.\n\n**D. Two homologous proteins share a conserved domain in which similarity is interrupted by frequent short insertions and deletions: in the true alignment, gaps occur every few residues, preventing long contiguous matches. Under affine gap penalties, Smith–Waterman pays gap opening once per gap and accumulates many positive conservative substitutions across the domain, producing a high local score. BLASTP requires at least one above-threshold seed of length $w$ aligned without gaps and early rapid score gain during extension; frequent interruptions cause the extension to fail the $X$-drop criterion, so the reported BLASTP score is low.**\n\nThis option describes a failure due to fragmented similarity.\n- **BLASTP Mechanism**: This scenario presents two challenges for BLASTP.\n    $1$. **Seeding**: BLASTP requires a contiguous, gapless seed of length $w$ (e.g., $w=3$). If similarity is punctuated by gaps every few residues, it is possible that no high-scoring word pair of length $w$ exists, thus preventing any seeds from being found.\n    $2$. **Extension**: Even if a short seed is found, the extension process will immediately encounter regions requiring gaps. Introducing a gap incurs a penalty, causing the alignment score to drop. With frequent gaps, the score will repeatedly struggle to increase and is very likely to fall by more than the $X$-dropoff value from its running maximum, leading to premature termination of the extension.\n- **Smith-Waterman Mechanism**: The Smith-Waterman algorithm with an affine gap penalty ($G_{open} + L \\times G_{extend}$) is well-suited to this problem. It will systematically find the optimal path through the dynamic programming matrix. If the positive scores from matching residues between the gaps are sufficient to outweigh the sum of the gap opening penalties, it will correctly identify the entire conserved domain and report a high score.\n- **Conclusion**: This is a classic example of where seed-and-extend heuristics fail. The true alignment exists but is too fragmented to be detected by BLAST's requirements for contiguous seeds and sustained score increase during extension.\n- **Verdict**: **Correct**.\n\n**E. Two proteins are homologous but have extreme compositional bias (for example, lysine/arginine-rich regions). BLASTP applies composition-based score matrix adjustment that down-weights matches consistent with the biased background, reducing seed scores and high-scoring segment pair growth below reporting thresholds. Smith–Waterman using a fixed substitution matrix without composition-based adjustment accumulates many positive scores, yielding a substantially higher optimal local alignment score.**\n\nThis option describes a failure due to a specific corrective feature of BLASTP.\n- **BLASTP Mechanism**: Composition-based statistics were introduced to BLAST to increase specificity. For sequences with biased composition (e.g., many charged residues), standard matrices can produce high scores for non-homologous alignments simply by chance. The adjustment procedure re-scales the substitution matrix scores to be more appropriate for the observed residue frequencies. This systematically lowers the scores of matches that are common in the biased context (e.g., a K-K match in a lysine-rich sequence). This can cause potential seeds to have their scores reduced below the threshold $T$ and can slow or halt the score accumulation during extension.\n- **Smith-Waterman Mechanism**: The problem specifies that Smith-Waterman is run with a fixed substitution matrix (e.g., standard BLOSUM62) without this adjustment. In this case, it will align the lysine/arginine-rich regions and sum the high positive scores for K-K, R-R, and K-R matches from the matrix, resulting in a high total score.\n- **Conclusion**: This describes a valid scenario. BLASTP is intentionally designed to be conservative in such cases to avoid false positives, but this same mechanism can cause it to miss a true homology that would otherwise receive a high score. The comparison as stated (BLASTP with adjustments vs. SW without) will lead to a large score discrepancy.\n- **Verdict**: **Correct**.\n\nIn summary, options A, D, and E describe plausible, realistic scenarios based on well-understood mechanisms where the BLASTP heuristic would fail to find a high-scoring alignment that the optimal Smith-Waterman algorithm would identify.", "answer": "$$\\boxed{ADE}$$", "id": "2376082"}, {"introduction": "Genomic sequences are often littered with repetitive elements, which can create a storm of spurious alignments and obscure true signals of homology. This exercise explores masking, the primary technique for navigating this challenge [@problem_id:2376028]. By comparing the effects of 'soft' versus 'hard' masking on a BLASTN search, you will gain the practical knowledge needed to filter noise effectively while preserving important biological context.", "problem": "A researcher uses the Basic Local Alignment Search Tool nucleotide search (BLASTN) to align a genomic query sequence against a large vertebrate genome database. The query contains a single internal segment that is a common primate short interspersed nuclear element (Alu). Two searches are performed that differ only in how this Alu segment is treated in the query: in search $\\mathrm{S}_{\\mathrm{soft}}$, the Alu is soft masked (letters converted to lower case); in search $\\mathrm{S}_{\\mathrm{hard}}$, the Alu is hard masked (letters replaced by ambiguity codes so that they are not aligned). The flanking regions on both sides of the Alu are unique, alignable sequence present once in the database. Consider how BLASTN constructs local alignments using short exact or near-exact words of length $w$ for seeding, followed by ungapped and then gapped extension to form high-scoring segment pairs (HSPs), and how masking interacts with these stages. Which option best describes the expected differences between $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ in terms of (i) where seeds can originate, (ii) whether extensions can traverse the repeat to yield a single spanning HSP, (iii) the prevalence of spurious repeat-only hits, and (iv) the typical impact on the expect value (E-value) of the true alignment spanning the Alu?\n\nA. In $\\mathrm{S}_{\\mathrm{soft}}$, seeds are not generated from the Alu, but once a seed is found in a unique flank, gapped extension can pass through the Alu so a single HSP spanning the repeat can be reported; spurious repeat-only hits are suppressed. In $\\mathrm{S}_{\\mathrm{hard}}$, the Alu is effectively removed from both seeding and extension, so extensions cannot cross it and HSPs that would have spanned the repeat become truncated or split; both approaches reduce spurious repeat-only hits, but hard masking often shortens true alignments and can raise their E-values relative to soft masking.\n\nB. In $\\mathrm{S}_{\\mathrm{soft}}$, both seeding and extension are prohibited in the Alu, preventing any HSP from spanning the repeat; in $\\mathrm{S}_{\\mathrm{hard}}$, seeds are not generated in the Alu but extension can traverse it, so HSPs spanning the repeat are still reported; spurious repeat-only hits are unaffected.\n\nC. Hard masking in $\\mathrm{S}_{\\mathrm{hard}}$ increases spurious hits to Alu instances because the masked letters act as wildcards that seed many locations, whereas soft masking in $\\mathrm{S}_{\\mathrm{soft}}$ only modestly reduces such spurious hits; both approaches preserve the length and E-value of true alignments spanning the repeat.\n\nD. In BLASTN, soft-masked letters are down-weighted during scoring, so any HSP that crosses a soft-masked Alu has a lower score and a higher E-value than if unmasked; hard masking leaves scoring unchanged but blocks seeding in the Alu, with no effect on whether extension can cross the repeat.\n\nE. Both $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ allow seeds to originate within the Alu but rely on a post-alignment low-complexity filter to discard repeat-only hits; consequently, both produce similar spanning HSPs and E-values for the true alignment and similar numbers of spurious repeat-only matches.", "solution": "The user has provided a problem in computational biology concerning the operation of the Basic Local Alignment Search Tool (BLAST). I will now proceed with the validation of the problem statement.\n\n### Step 1: Extract Givens\n- **Tool**: Basic Local Alignment Search Tool nucleotide search (BLASTN).\n- **Query Sequence**: A genomic sequence containing a single internal segment that is a common primate short interspersed nuclear element (Alu).\n- **Database**: A large vertebrate genome database.\n- **Flanking Regions**: The regions on both sides of the Alu element in the query are unique and alignable, present once in the database.\n- **Search $\\mathrm{S}_{\\mathrm{soft}}$**: The Alu segment is soft masked (letters converted to lower case).\n- **Search $\\mathrm{S}_{\\mathrm{hard}}$**: The Alu segment is hard masked (letters replaced by ambiguity codes so that they are not aligned).\n- **BLASTN Mechanism**: The tool uses short exact or near-exact words of length $w$ for seeding, followed by ungapped and then gapped extension to form high-scoring segment pairs (HSPs).\n- **Question**: Compare searches $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ regarding (i) seed origination, (ii) extension traversal of the repeat, (iii) prevalence of spurious repeat-only hits, and (iv) impact on the expect value (E-value) of the true alignment.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is well-grounded in the principles of bioinformatics and computational biology. BLAST, Alu elements, soft masking, hard masking, seeding, extension, HSPs, and E-values are all standard, well-defined concepts. The scenario described is a common and practical task in sequence analysis.\n2.  **Well-Posed**: The problem is well-posed. It asks for a qualitative comparison between two clearly defined methods ($\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$) based on four specific, answerable criteria. A unique, correct description based on the known mechanics of the BLAST algorithm exists.\n3.  **Objective**: The language used is technical, precise, and objective. \"Soft masked\", \"hard masked\", \"seeding\", and \"extension\" have concrete, unambiguous meanings in the context of BLAST.\n4.  **No Flaws**: The problem statement does not violate any scientific principles, is not metaphorical, is complete, is realistic, and is not ill-posed. The description of hard masking as replacing letters with ambiguity codes \"so that they are not aligned\" accurately captures the functional outcome, which is the inability of the extension algorithm to proceed through such regions due to high mismatch penalties.\n\n### Step 3: Verdict and Action\nThe problem statement is declared **valid**. I will proceed with the derivation of the solution and evaluation of the options.\n\n### Solution Derivation\n\nThe problem requires an analysis of how soft masking and hard masking affect the BLASTN algorithm's results. The algorithm can be understood in two main stages: seeding and extension.\n\n1.  **Seeding**: BLASTN first identifies short, perfectly or nearly-perfectly matching \"words\" of a defined length $w$ between the query and the database. These words serve as seeds for potential alignments. Repetitive elements like Alu are present in high copy numbers in the database. If a query containing an unmasked Alu is used, it will generate a very large number of seeds by matching countless Alu elements in the database, leading to a large number of spurious alignments and a computationally expensive search. Masking is the primary strategy to mitigate this.\n\n2.  **Soft Masking ($\\mathrm{S}_{\\mathrm{soft}}$)**: In soft masking, the nucleotide bases in the repetitive Alu region are converted to lower-case (e.g., `atgc...` instead of `ATGC...`).\n    - **Effect on Seeding**: By default, BLAST programs are configured to ignore soft-masked (lower-case) regions of the query sequence during the seeding stage. Therefore, no seeds will originate from the Alu segment in search $\\mathrm{S}_{\\mathrm{soft}}$. Seeds can only be generated from the unmasked, unique flanking regions.\n    - **Effect on Extension**: Once a seed is found in a unique flanking region, the alignment extension process begins. During this gapped extension phase, soft-masked letters are treated as regular nucleotides and are scored using the standard scoring matrix. This allows the alignment to extend *through* the soft-masked Alu region, connecting the two unique flanks. The result is a single, long high-scoring segment pair (HSP) that spans the entire query region, including the Alu.\n    - **Effect on Spurious Hits**: Since seeding from the query's Alu is disabled, BLASTN will not initiate alignments with the multitude of other Alu elements in the database. This effectively suppresses the reporting of spurious, repeat-only hits.\n    - **Effect on E-value**: A single, long HSP is generated. The alignment score ($S$) will be high due to its length. The Expect value (E-value), which measures the number of hits one can \"expect\" to see by chance, is related to the score by $E = Kmn e^{-\\lambda S}$, where $K$ and $\\lambda$ are statistical parameters, and $m$ and $n$ are the lengths of the query and database. A higher score $S$ leads to an exponentially lower (more significant) E-value.\n\n3.  **Hard Masking ($\\mathrm{S}_{\\mathrm{hard}}$)**: In hard masking, the bases in the repetitive Alu region are replaced by an ambiguity character, typically 'N'. The problem states this is done so the letters \"are not aligned.\"\n    - **Effect on Seeding**: Similar to soft masking, regions with 'N's are not used to generate seeds. Thus, no seeds will originate from the hard-masked Alu segment.\n    - **Effect on Extension**: During the extension phase, an 'N' in the sequence represents a complete unknown. Aligning an 'N' to any standard base (A, C, G, T) or even to another 'N' typically incurs a significant penalty in BLASTN's scoring system. This penalty is usually large enough to terminate the extension process. Therefore, an alignment initiated in one flanking region cannot extend across the hard-masked Alu to the other flank.\n    - **Effect on Spurious Hits**: Like soft masking, hard masking prevents seeding from the query's Alu region and thus suppresses spurious repeat-only hits.\n    - **Effect on E-value**: Because the extension is halted at the boundary of the hard-masked region, the original single true alignment is fragmented. Instead of one long HSP spanning the entire locus, the result will be two shorter HSPs (one for each flank) or a single truncated HSP (if only one flank finds a seed and extends). These shorter HSPs will have lower scores ($S$) compared to the single long HSP from $\\mathrm{S}_{\\mathrm{soft}}$. A lower score results in a higher (less significant) E-value.\n\n### Option-by-Option Analysis\n\n**A. In $\\mathrm{S}_{\\mathrm{soft}}$, seeds are not generated from the Alu, but once a seed is found in a unique flank, gapped extension can pass through the Alu so a single HSP spanning the repeat can be reported; spurious repeat-only hits are suppressed. In $\\mathrm{S}_{\\mathrm{hard}}$, the Alu is effectively removed from both seeding and extension, so extensions cannot cross it and HSPs that would have spanned the repeat become truncated or split; both approaches reduce spurious repeat-only hits, but hard masking often shortens true alignments and can raise their E-values relative to soft masking.**\n- This option accurately describes all four points of comparison for both $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$. It correctly states that soft masking prevents seeding in the Alu but allows extension through it, yielding a single spanning HSP and suppressing spurious hits. It also correctly states that hard masking prevents both seeding and extension in the Alu, leading to truncated/split HSPs. Finally, it correctly concludes that hard masking's shortening of the alignment leads to higher (worse) E-values compared to soft masking.\n- **Verdict: Correct.**\n\n**B. In $\\mathrm{S}_{\\mathrm{soft}}$, both seeding and extension are prohibited in the Alu, preventing any HSP from spanning the repeat; in $\\mathrm{S}_{\\mathrm{hard}}$, seeds are not generated in the Alu but extension can traverse it, so HSPs spanning the repeat are still reported; spurious repeat-only hits are unaffected.**\n- The statement about $\\mathrm{S}_{\\mathrm{soft}}$ is incorrect; extension is *not* prohibited in soft-masked regions. The statement about $\\mathrm{S}_{\\mathrm{hard}}$ is also incorrect; extension *cannot* traverse hard-masked regions. This option reverses the effects of the two masking types on the extension phase. The claim that spurious hits are unaffected is also incorrect.\n- **Verdict: Incorrect.**\n\n**C. Hard masking in $\\mathrm{S}_{\\mathrm{hard}}$ increases spurious hits to Alu instances because the masked letters act as wildcards that seed many locations, whereas soft masking in $\\mathrm{S}_{\\mathrm{soft}}$ only modestly reduces such spurious hits; both approaches preserve the length and E-value of true alignments spanning the repeat.**\n- This is fundamentally wrong. The purpose and effect of masking (both types) is to *prevent* seeding in repetitive regions and thus *reduce* spurious hits. 'N's do not act as wildcards for seeding. Furthermore, hard masking does *not* preserve the length and E-value of the true alignment; it shortens it and worsens the E-value.\n- **Verdict: Incorrect.**\n\n**D. In BLASTN, soft-masked letters are down-weighted during scoring, so any HSP that crosses a soft-masked Alu has a lower score and a higher E-value than if unmasked; hard masking leaves scoring unchanged but blocks seeding in the Alu, with no effect on whether extension can cross the repeat.**\n- The first part is not standard behavior. Soft-masked letters are typically scored normally during extension, they are only ignored for seeding. The claim that this leads to a higher E-value is illogical in the context of filtering repeats. The section on hard masking is incorrect; it has a decisive effect on extension, blocking it.\n- **Verdict: Incorrect.**\n\n**E. Both $\\mathrm{S}_{\\mathrm{soft}}$ and $\\mathrm{S}_{\\mathrm{hard}}$ allow seeds to originate within the Alu but rely on a post-alignment low-complexity filter to discard repeat-only hits; consequently, both produce similar spanning HSPs and E-values for the true alignment and similar numbers of spurious repeat-only matches.**\n- This statement is incorrect from the beginning. The primary function of masking is to *prevent* seeds from originating within the masked regions. Consequently, the downstream conclusions that they produce similar spanning HSPs and E-values are also false. $\\mathrm{S}_{\\mathrm{hard}}$ does not produce spanning HSPs.\n- **Verdict: Incorrect.**", "answer": "$$\\boxed{A}$$", "id": "2376028"}, {"introduction": "Detecting ancient evolutionary relationships often means searching for similarity in the 'twilight zone' where sequence identity drops below $0.25$. This advanced challenge [@problem_id:2376047] moves beyond using BLAST to understanding its engine, tasking you with implementing and parameterizing a search for these faint signals. By manipulating scoring matrices, word sizes ($w$), and gap penalties ($g_o, g_e$) to achieve a statistically significant E-value, you will gain an unparalleled mastery of how these components work in concert to uncover deep homology.", "problem": "You will implement a complete, runnable program that models a simplified version of the Basic Local Alignment Search Tool for proteins (BLASTP). The goal is to automatically select a non-default parameter configuration that reveals homology between amino acid sequences in the so-called \"twilight zone\" of sequence identity (approximately $0.25$ as a fraction). The program must use a principled, first-principles design rooted in the Central Dogma of Molecular Biology and in well-tested formulas for local alignment statistics. Your program must not read any input; it must run as-is and produce a single-line output.\n\nYou are to implement a detector that uses a seed-and-extend heuristic combined with local alignment scoring and statistical significance estimation, following these foundational rules:\n\n1. Central Dogma and homology. Protein sequences arise by translation of coding DNA, and homology implies common ancestry evidenced by conserved positions. Your algorithm should rely on local alignments to detect conserved regions indicative of homology without assuming global similarity.\n\n2. Log-odds scoring and substitution families. Proteins are scored with substitution matrices derived from log-odds principles. You will implement three substitution families that mimic BLOSUM behavior qualitatively:\n   - A reduced chemical-group model on the canonical $20$ amino acid alphabet $\\mathcal{A}$ partitions $\\mathcal{A}$ into the following five groups:\n     - Hydrophobic: $\\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{W}, \\mathrm{Y} \\}$\n     - Polar uncharged: $\\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$\n     - Acidic: $\\{ \\mathrm{D}, \\mathrm{E} \\}$\n     - Basic: $\\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$\n     - Special: $\\{ \\mathrm{G}, \\mathrm{P} \\}$\n   - Define three matrices by a scoring function $s_{\\mathrm{family}}(x,y)$, for $x,y \\in \\mathcal{A}$:\n     - LOOSE: exact match scores $+5$, same-group non-identical scores $+2$, different-group scores $-2$.\n     - MEDIUM: exact match scores $+4$, same-group non-identical scores $+1$, different-group scores $-3$.\n     - STRICT: exact match scores $+6$, same-group non-identical scores $0$, different-group scores $-4$.\n\n3. Seeding (word hits). Use the protein seed-and-extend heuristic:\n   - Word size $w \\in \\{2,3\\}$.\n   - For every pair of positions $(i,j)$ in the query and subject, compute the seed score for the $w$-mer as $\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$, provided indices are in range.\n   - A seed is declared if the seed score is at least a family- and $w$-dependent cutoff $T(\\mathrm{family},w)$:\n     - For LOOSE: $T(\\mathrm{LOOSE},2)=6$, $T(\\mathrm{LOOSE},3)=10$.\n     - For MEDIUM: $T(\\mathrm{MEDIUM},2)=8$, $T(\\mathrm{MEDIUM},3)=12$.\n     - For STRICT: $T(\\mathrm{STRICT},2)=10$, $T(\\mathrm{STRICT},3)=15$.\n   - If no seed exists, declare “no hit” and skip extension.\n\n4. Extension by local alignment with affine gaps. If at least one seed exists, compute the optimal local alignment score $S$ using the Smith–Waterman algorithm with affine gap costs:\n   - Gap open penalty $g_o \\in \\{9,11\\}$.\n   - Gap extension penalty $g_e \\in \\{1,2\\}$.\n   - Use the same $s_{\\mathrm{family}}$ as above for matches/mismatches.\n\n5. Statistical significance (Karlin–Altschul statistics). For protein BLAST, use the Karlin–Altschul well-tested result for local alignment scores. Given query length $m$, database effective length $n$, and the maximum local alignment score $S$, compute the bit score $S'$ and the expected count $E$:\n   - Use family-specific constants $(\\lambda, K)$:\n     - LOOSE: $\\lambda=0.27$, $K=0.07$.\n     - MEDIUM: $\\lambda=0.318$, $K=0.13$.\n     - STRICT: $\\lambda=0.35$, $K=0.16$.\n   - Convert raw score to bit score by $S' = (\\lambda S - \\ln K)/\\ln 2$.\n   - Expected count is $E = mn\\, 2^{-S'}$. Equivalently $E = K\\, m n \\, e^{-\\lambda S}$.\n   - A hit is declared significant if $E \\le \\tau$, where $\\tau=0.01$ (a pure number; no units).\n\n6. Composition-based statistics flag. Include a boolean parameter $c \\in \\{0,1\\}$ representing composition-based statistics (off/on). For this simplified model, $c$ does not alter the scoring or statistics directly; it is tracked as part of the parameter tuple to enforce “non-default” selection.\n\n7. Parameter enumeration and default. Enumerate parameter tuples in lexicographic order as\n   - family $\\in [\\mathrm{LOOSE}, \\mathrm{MEDIUM}, \\mathrm{STRICT}]$,\n   - $w \\in [2,3]$,\n   - $g_o \\in [9,11]$,\n   - $g_e \\in [1,2]$,\n   - $c \\in [0,1]$.\n   Let the default BLASTP-like tuple be $(\\mathrm{MEDIUM},3,11,1,1)$, corresponding to family MEDIUM, word size $w=3$, $g_o=11$, $g_e=1$, $c=1$. The default is included in the enumeration but must never be chosen as the answer.\n\n8. Selection rule. For a given query–subject pair and database effective length $n$, among all non-default parameter tuples that declare at least one seed and yield $E \\le \\tau$, select the tuple that differs from the default in the fewest fields (count each field equally). Among ties, choose the lexicographically smallest tuple under the enumeration in item $7$. If no non-default tuple yields a significant hit, return no solution.\n\nYour program must implement the above detector and apply it to the following test suite. Each test case provides a query, a subject, and a database effective length. All amino acid sequences are uppercase strings over $\\mathcal{A}$. There are no physical units.\n\nTest suite (four cases):\n- Case A (twilight-zone homologs, approximately $0.25$ identity): \n  - Query $q_A$: \"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\"\n  - Subject $t_A$: \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\"\n  - Database effective length $n_A = 10^6$.\n- Case B (unrelated sequences; should not be significant): \n  - Query $q_B$: \"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\"\n  - Subject $t_B$: \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\"\n  - Database effective length $n_B = 10^6$.\n- Case C (moderate similarity; above twilight zone): \n  - Query $q_C$: \"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\"\n  - Subject $t_C$: \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\"\n  - Database effective length $n_C = 10^6$.\n- Case D (short proteins; boundary where $w=3$ may be too strict): \n  - Query $q_D$: \"GPWKVVVVAGHGISDLGKTKAVAI\"\n  - Subject $t_D$: \"GSWKIIVVAGHGITDLGKSRAIAL\"\n  - Database effective length $n_D = 10^6$.\n\nOutput specification:\n- For each case, compute the zero-based index of the selected parameter tuple within the full enumeration order described in item $7$ (that is, including the default in the count), or output $-1$ if no non-default tuple yields a significant hit.\n- Your program should produce a single line of output containing the four results as a comma-separated list enclosed in square brackets, for example, \"[i_A,i_B,i_C,i_D]\".\n- All values must be integers.\n\nNotes:\n- There are no physical units; the expected count $E$ is a pure number. The fraction $0.01$ is a threshold and must be applied exactly as given.\n- Angles are not involved.\n- Percentages must be handled as fractions, which is why the twilight zone is described using $0.25$.", "solution": "The problem as stated is subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n\n- **Amino Acid Alphabet ($\\mathcal{A}$):** The canonical $20$ amino acids.\n- **Amino Acid Groups:**\n  - Hydrophobic: $\\{ \\mathrm{A}, \\mathrm{V}, \\mathrm{I}, \\mathrm{L}, \\mathrm{M}, \\mathrm{F}, \\mathrm{W}, \\mathrm{Y} \\}$\n  - Polar uncharged: $\\{ \\mathrm{S}, \\mathrm{T}, \\mathrm{N}, \\mathrm{Q}, \\mathrm{C} \\}$\n  - Acidic: $\\{ \\mathrm{D}, \\mathrm{E} \\}$\n  - Basic: $\\{ \\mathrm{K}, \\mathrm{R}, \\mathrm{H} \\}$\n  - Special: $\\{ \\mathrm{G}, \\mathrm{P} \\}$\n- **Scoring Families ($s_{\\mathrm{family}}(x,y)$):**\n  - LOOSE: exact match $+5$, same-group non-identical $+2$, different-group $-2$.\n  - MEDIUM: exact match $+4$, same-group non-identical $+1$, different-group $-3$.\n  - STRICT: exact match $+6$, same-group non-identical $0$, different-group $-4$.\n- **Seeding:**\n  - Word size $w \\in \\{2, 3\\}$.\n  - Seed score: $\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$.\n  - Seed thresholds $T$: $T(\\mathrm{LOOSE},2)=6$, $T(\\mathrm{LOOSE},3)=10$; $T(\\mathrm{MEDIUM},2)=8$, $T(\\mathrm{MEDIUM},3)=12$; $T(\\mathrm{STRICT},2)=10$, $T(\\mathrm{STRICT},3)=15$.\n- **Extension (Local Alignment with Affine Gaps):**\n  - Gap open penalty $g_o \\in \\{9, 11\\}$.\n  - Gap extension penalty $g_e \\in \\{1, 2\\}$.\n- **Statistical Significance (Karlin-Altschul):**\n  - Query length $m$, database effective length $n$.\n  - Statistics constants $(\\lambda, K)$: LOOSE ($\\lambda=0.27, K=0.07$), MEDIUM ($\\lambda=0.318, K=0.13$), STRICT ($\\lambda=0.35, K=0.16$).\n  - Bit score $S' = (\\lambda S - \\ln K)/\\ln 2$.\n  - Expected count $E = mn\\, 2^{-S'} = Kmn \\, e^{-\\lambda S}$.\n  - Significance threshold $\\tau=0.01$. A hit is significant if $E \\le \\tau$.\n- **Composition-Based Statistics Flag:** $c \\in \\{0, 1\\}$.\n- **Parameter Enumeration (Lexicographic):** family $\\in [\\mathrm{LOOSE}, \\mathrm{MEDIUM}, \\mathrm{STRICT}]$, $w \\in [2,3]$, $g_o \\in [9,11]$, $g_e \\in [1,2]$, $c \\in [0,1]$.\n- **Default Parameter Tuple:** $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$.\n- **Selection Rule:** For a given query/subject pair, from all non-default parameter tuples that find a seed and yield $E \\le \\tau$, select the one with the minimum number of differing fields from the default. Tie-break using the smallest lexicographical index. If no such tuple exists, the result is \"no solution\".\n- **Test Suite:**\n  - Case A: $q_A=$ \"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\", $t_A=$ \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\", $n_A = 10^6$.\n  - Case B: $q_B=$ \"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\", $t_B=$ \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\", $n_B = 10^6$.\n  - Case C: $q_C=$ \"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\", $t_C=$ \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\", $n_C = 10^6$.\n  - Case D: $q_D=$ \"GPWKVVVVAGHGISDLGKTKAVAI\", $t_D=$ \"GSWKIIVVAGHGITDLGKSRAIAL\", $n_D = 10^6$.\n- **Output:** A single-line list of four zero-based integer indices, e.g., `[i_A,i_B,i_C,i_D]`. An index of $-1$ indicates no solution found.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is scientifically grounded, well-posed, and objective. It provides a simplified but correct model of the BLASTP algorithm, rooted in established principles of bioinformatics such as log-odds scoring matrices, seed-and-extend heuristics, local alignment via dynamic programming (Smith-Waterman), and Karlin-Altschul statistics for significance estimation. All required data, parameters, and algorithms are specified without ambiguity or contradiction. The selection rule is deterministic, ensuring a unique solution. The computational task is intensive but feasible for the given sequence lengths. The problem does not violate any of the invalidity criteria.\n\n**Step 3: Verdict and Action**\n\nThe problem is valid. A solution will be constructed.\n\n**Principle-Based Design**\n\nThe task is to implement a simplified BLASTP-like homology search tool and use it to find an optimal, non-default parameter configuration for detecting homology in several test cases. The solution will proceed by systematically evaluating a discrete parameter space, applying a full seed-and-extend alignment procedure for each parameter set, and selecting the best set based on a clearly defined rule.\n\nFirst, we establish the parameter space. There are $3$ scoring families, $2$ word sizes, $2$ gap open penalties, $2$ gap extension penalties, and $2$ composition-based statistics flags. This yields a total of $3 \\times 2 \\times 2 \\times 2 \\times 2 = 48$ parameter tuples. These are enumerated in lexicographical order: (family, $w$, $g_o$, $g_e$, $c$). The default tuple is specified as $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$.\n\nFor each test case (a query sequence $q$, a subject sequence $t$, and an effective database size $n$), we iterate through all $48$ parameter tuples. Let $m$ be the length of the query sequence. For each non-default tuple, the following procedure is executed:\n\n**1. Seeding:**\nThe algorithm first searches for \"word hits\" or seeds. A word of size $w$ is a short substring of the sequence. We consider all $w$-mers from the query and all $w$-mers from the subject. For each pair of $w$-mers, one from the query ($q_{i...i+w-1}$) and one from the subject ($t_{j...j+w-1}$), a seed score is computed as the sum of substitution scores for the aligned amino acids: $\\sum_{k=0}^{w-1} s_{\\mathrm{family}}(q_{i+k}, t_{j+k})$. The substitution score $s_{\\mathrm{family}}(x, y)$ is determined by the active scoring family (LOOSE, MEDIUM, or STRICT). If this seed score meets or exceeds the specified threshold $T(\\mathrm{family}, w)$, a seed is found. If no seed is found across the entire pair of sequences, this parameter tuple is discarded, and we proceed to the next.\n\n**2. Extension using Smith-Waterman with Affine Gaps:**\nIf at least one seed is found, we proceed to find the optimal local alignment score, $S$, between the full query and subject sequences. This is achieved using the Smith-Waterman dynamic programming algorithm, modified for affine gap penalties. An affine gap penalty model uses a higher cost for opening a gap ($g_o$) and a lower cost for extending it ($g_e$). This is implemented using three dynamic programming matrices: $H(i,j)$ for the best score ending at $(i,j)$ (either a match/mismatch or closing a gap), $E(i,j)$ for the best score ending with a gap in the query, and $F(i,j)$ for the best score ending with a gap in the subject.\nLet $q_i$ and $t_j$ be the amino acids at positions $i$ and $j$ of the query and subject sequences, respectively. The recurrences are, for $i=1...m$ and $j=1...|t|$:\n$$F(i,j) = \\max \\left\\{ H(i-1, j) - g_o, F(i-1, j) - g_e \\right\\}$$\n$$E(i,j) = \\max \\left\\{ H(i, j-1) - g_o, E(i, j-1) - g_e \\right\\}$$\n$$H(i,j) = \\max \\left\\{ H(i-1, j-1) + s(q_i, t_j), E(i,j), F(i,j), 0 \\right\\}$$\nThe base cases are $H(0,j) = H(i,0) = 0$ for all $i,j$. The final local alignment score $S$ is the maximum value found anywhere in the $H$ matrix: $S = \\max_{i,j} H(i,j)$.\n\n**3. Statistical Significance:**\nThe raw score $S$ is evaluated for statistical significance using the Karlin-Altschul E-value formula:\n$$E = K m n e^{-\\lambda S}$$\nHere, $m$ is the query length, $n$ is the effective database length, and $\\lambda$ and $K$ are statistical parameters specific to the scoring system. A result is deemed statistically significant if its E-value $E$ is less than or equal to a threshold $\\tau$, given as $0.01$.\n\n**4. Parameter Selection:**\nAll non-default parameter tuples that pass the seeding stage and produce a significant E-value ($E \\le 0.01$) are collected. Among these successful tuples, we apply the selection rule:\n- First, calculate the \"difference\" for each successful tuple, defined as the number of fields that differ from the default tuple $(\\mathrm{MEDIUM}, 3, 11, 1, 1)$.\n- Identify the minimum difference found among all successful tuples.\n- The final chosen tuple is the one that achieves this minimum difference and has the lowest lexicographical index among all ties. If no non-default tuple yields a significant hit, the result for the test case is $-1$.\n\nThis entire process is repeated for each of the four test cases provided, and the zero-based index of the chosen parameter tuple is recorded as the final result for that case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Implements a simplified BLASTP model to find optimal parameters for homology detection.\n    \"\"\"\n\n    # --- Problem Definition  Constants ---\n\n    AA_GROUPS = {\n        'A': 'Hydrophobic', 'V': 'Hydrophobic', 'I': 'Hydrophobic', 'L': 'Hydrophobic',\n        'M': 'Hydrophobic', 'F': 'Hydrophobic', 'W': 'Hydrophobic', 'Y': 'Hydrophobic',\n        'S': 'Polar uncharged', 'T': 'Polar uncharged', 'N': 'Polar uncharged',\n        'Q': 'Polar uncharged', 'C': 'Polar uncharged',\n        'D': 'Acidic', 'E': 'Acidic',\n        'K': 'Basic', 'R': 'Basic', 'H': 'Basic',\n        'G': 'Special', 'P': 'Special'\n    }\n\n    # Parameter space definition\n    FAMILIES = ['LOOSE', 'MEDIUM', 'STRICT']\n    WORD_SIZES = [2, 3]\n    GAP_OPENS = [9, 11]\n    GAP_EXTENDS = [1, 2]\n    COMP_STATS = [0, 1]\n\n    # Generate parameter space in lexicographic order\n    param_space = []\n    for family in FAMILIES:\n        for w in WORD_SIZES:\n            for g_o in GAP_OPENS:\n                for g_e in GAP_EXTENDS:\n                    for c in COMP_STATS:\n                        param_space.append((family, w, g_o, g_e, c))\n\n    DEFAULT_PARAMS = ('MEDIUM', 3, 11, 1, 1)\n\n    SCORING_RULES = {\n        'LOOSE': {'match': 5, 'same_group': 2, 'diff_group': -2},\n        'MEDIUM': {'match': 4, 'same_group': 1, 'diff_group': -3},\n        'STRICT': {'match': 6, 'same_group': 0, 'diff_group': -4},\n    }\n\n    SEED_THRESHOLDS = {\n        ('LOOSE', 2): 6, ('LOOSE', 3): 10,\n        ('MEDIUM', 2): 8, ('MEDIUM', 3): 12,\n        ('STRICT', 2): 10, ('STRICT', 3): 15,\n    }\n\n    STAT_CONSTANTS = {\n        'LOOSE': {'lambda': 0.27, 'K': 0.07},\n        'MEDIUM': {'lambda': 0.318, 'K': 0.13},\n        'STRICT': {'lambda': 0.35, 'K': 0.16},\n    }\n\n    E_VALUE_THRESHOLD = 0.01\n\n    test_cases = [\n        (\"MAVKDLGATYVAGLSERAGADVVVVNTDAGKSTLLNQLAGLDKTTELWAVDAGHNTMPNVIAGLKMKDGKKLSALDAGADLLSVTNPADKVIAGLEGA\",\n         \"LVIRDLGCTFIAGLTERTGVDIIVVNKDAGKSALLSQLSGIDETTELYAVDSGHNTLPNVVSGIKMREGKKLTALDAGKDLLTITNPKDKILAGMEGS\",\n         10**6),\n        (\"WQFPCHMNRTYGPADKSVYHCRWTQGPNTRHACDYKMPLWQHTRNYGACDPKTYRH\",\n         \"IVLVMAGTALLLVALGLTGATAAAVVLVALGLTVAIVGLALVVVVLAIVVVLVVV\",\n         10**6),\n        (\"ADKQLVQKAKLAEQAERYDDMAAAMKAVTEQGHELSNEERNLLSVAYKNVVGARRSSWR\",\n         \"AEKQLVQRAKLAEQAERYDEMAEALKKVTEQGHELSNDEKDLLSVAYKNVVNARRATWR\",\n         10**6),\n        (\"GPWKVVVVAGHGISDLGKTKAVAI\",\n         \"GSWKIIVVAGHGITDLGKSRAIAL\",\n         10**6),\n    ]\n\n    # --- Helper Functions ---\n\n    memoized_score_funcs = {}\n    def get_score_func(family):\n        if family in memoized_score_funcs:\n            return memoized_score_funcs[family]\n\n        rules = SCORING_RULES[family]\n        \n        memoized_scores = {}\n        all_aas = list(AA_GROUPS.keys())\n        for i in range(len(all_aas)):\n            for j in range(i, len(all_aas)):\n                aa1, aa2 = all_aas[i], all_aas[j]\n                if aa1 == aa2:\n                    score = rules['match']\n                elif AA_GROUPS[aa1] == AA_GROUPS[aa2]:\n                    score = rules['same_group']\n                else:\n                    score = rules['diff_group']\n                memoized_scores[(aa1, aa2)] = score\n                memoized_scores[(aa2, aa1)] = score\n        \n        def score_func(aa1, aa2):\n            return memoized_scores[(aa1, aa2)]\n            \n        memoized_score_funcs[family] = score_func\n        return score_func\n\n    def check_seeding(query, subject, w, score_func, T):\n        len_q, len_s = len(query), len(subject)\n        for i in range(len_q - w + 1):\n            for j in range(len_s - w + 1):\n                seed_score = sum(score_func(query[i + k], subject[j + k]) for k in range(w))\n                if seed_score >= T:\n                    return True\n        return False\n\n    def smith_waterman_affine(query, subject, score_func, g_o, g_e):\n        m, n = len(query), len(subject)\n        H = np.zeros((m + 1, n + 1), dtype=np.int32)\n        E = np.zeros((m + 1, n + 1), dtype=np.int32)\n        F = np.zeros((m + 1, n + 1), dtype=np.int32)\n        \n        max_score = 0\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # Gap in subject (deletion in query)\n                F[i, j] = max(H[i - 1, j] - g_o, F[i - 1, j] - g_e)\n                # Gap in query (insertion in subject)\n                E[i, j] = max(H[i, j - 1] - g_o, E[i, j - 1] - g_e)\n                \n                match_score = H[i - 1, j - 1] + score_func(query[i - 1], subject[j - 1])\n                H[i, j] = max(0, match_score, E[i, j], F[i, j])\n                \n                if H[i, j] > max_score:\n                    max_score = H[i, j]\n        \n        return int(max_score)\n\n    def calculate_diff_from_default(params):\n        diff = 0\n        for i in range(len(params)):\n            if params[i] != DEFAULT_PARAMS[i]:\n                diff += 1\n        return diff\n\n    # --- Main Logic ---\n\n    final_results = []\n    for query, subject, n_eff in test_cases:\n        m = len(query)\n        successful_params = []\n\n        for i, params in enumerate(param_space):\n            if params == DEFAULT_PARAMS:\n                continue\n\n            family, w, g_o, g_e, c = params\n            \n            score_func = get_score_func(family)\n            T = SEED_THRESHOLDS[(family, w)]\n\n            has_seed = check_seeding(query, subject, w, score_func, T)\n            if not has_seed:\n                continue\n            \n            S = smith_waterman_affine(query, subject, score_func, g_o, g_e)\n            \n            if S == 0:\n                continue\n\n            stat_p = STAT_CONSTANTS[family]\n            lambda_val, K_val = stat_p['lambda'], stat_p['K']\n            \n            # E = K * m * n * e^(-lambda * S)\n            try:\n                # Use high precision for intermediate exponent calculation\n                exponent = -lambda_val * float(S)\n                if exponent  -700: # Avoid underflow with math.exp\n                    e_value = 0.0\n                else:\n                    e_value = K_val * m * n_eff * math.exp(exponent)\n            except OverflowError:\n                continue\n\n            if e_value = E_VALUE_THRESHOLD:\n                diff = calculate_diff_from_default(params)\n                successful_params.append({'index': i, 'diff': diff})\n\n        if not successful_params:\n            final_results.append(-1)\n        else:\n            min_diff = min(p['diff'] for p in successful_params)\n            \n            # Find the first one (lexicographically smallest index) with min_diff\n            best_param = next(p for p in successful_params if p['diff'] == min_diff)\n            final_results.append(best_param['index'])\n            \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2376047"}]}