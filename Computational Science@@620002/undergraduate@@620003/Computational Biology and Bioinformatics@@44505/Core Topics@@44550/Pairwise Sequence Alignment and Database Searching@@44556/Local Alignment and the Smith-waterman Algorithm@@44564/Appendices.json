{"hands_on_practices": [{"introduction": "While a linear gap penalty provides a simple model, biological reality is more nuanced. It is often less costly for a single mutational event to extend an existing gap than to create a new one. This exercise [@problem_id:2401701] challenges you to implement the Smith-Waterman algorithm with a more sophisticated affine gap penalty, defined by a gap-open penalty ($g_o$) and a gap-extension penalty ($g_e$). You will build this more realistic model from first principles, using three interconnected dynamic programming matrices—$M$, $I_x$, and $I_y$—to master a powerful technique central to modern sequence analysis.", "problem": "You are to implement a local sequence alignment algorithm following the Smith–Waterman dynamic programming paradigm with an affine gap penalty model realized through three dynamic programming state matrices. The states are defined as follows for two input strings over a finite alphabet: $M_{i,j}$ represents the score of an optimal local alignment ending at positions $i$ in the first string and $j$ in the second string with the characters $x_i$ and $y_j$ aligned to each other (a match or mismatch), $I_{x,i,j}$ represents the score of an optimal local alignment ending at positions $i$ and $j$ with a gap extending in the first string (that is, the position $x_i$ aligned to a gap, corresponding to an insertion in the second string), and $I_{y,i,j}$ represents the score of an optimal local alignment ending at positions $i$ and $j$ with a gap extending in the second string (that is, the position $y_j$ aligned to a gap, corresponding to an insertion in the first string).\n\nThe algorithm must be designed from the following foundational base:\n- The principle of optimality for Dynamic Programming (DP): an optimal solution to a problem instance can be composed from optimal solutions of its subproblems when the problem exhibits optimal substructure.\n- The definition of local alignment: the score of the best-scoring pair of substrings, where alignment scoring cannot decrease below $0$ at any position, thereby allowing the alignment to restart locally.\n- The affine gap model: the penalty of a consecutive gap of length $L$ is $g_o + L \\cdot g_e$, where $g_o$ is the gap opening penalty and $g_e$ is the per-symbol gap extension penalty. Both $g_o$ and $g_e$ are nonnegative and subtracted from the alignment score when a gap is opened or extended.\n\nImplement a program that, given pairs of sequences and scalar scoring parameters, computes the optimal Smith–Waterman local alignment score using the three-state affine gap model described above. Your implementation must explicitly maintain the three state matrices $M$, $I_x$, and $I_y$, and must enforce the local alignment property by allowing any state to be reset to $0$ whenever all incoming transitions have nonpositive value. Assume a simple character substitution scoring function $s(a,b)$ defined by $s(a,b) = s_{\\text{match}}$ if $a=b$ and $s(a,b) = s_{\\text{mismatch}}$ if $a \\neq b$.\n\nYour program should process the following test suite of five cases. Each case is specified by a pair of strings along with the parameters $s_{\\text{match}}$, $s_{\\text{mismatch}}$, $g_o$, and $g_e$:\n- Case $1$: $x = \\text{\"GATTACA\"}$, $y = \\text{\"GCATGCU\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$.\n- Case $2$: $x = \\text{\"\"}$, $y = \\text{\"\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$.\n- Case $3$: $x = \\text{\"\"}$, $y = \\text{\"ACGT\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$.\n- Case $4$: $x = \\text{\"AAAA\"}$, $y = \\text{\"TTTT\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$.\n- Case $5$: $x = \\text{\"AAAACCCCGGGG\"}$, $y = \\text{\"AAAAGGGG\"}$, $s_{\\text{match}} = 2$, $s_{\\text{mismatch}} = -1$, $g_o = 3$, $g_e = 1$.\n\nFor each case, the required output is the single optimal local alignment score (an integer) under the specified model and parameters. Your program should produce a single line of output containing the results for the five cases as a comma-separated list enclosed in square brackets, for example $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$. There are no physical units involved in this problem.\n\nConstraints and clarifications:\n- Let the lengths of the strings be $n$ and $m$, respectively, with $n \\ge 0$ and $m \\ge 0$.\n- Your DP must run in $\\mathcal{O}(n \\cdot m)$ time and $\\mathcal{O}(n \\cdot m)$ space.\n- All matrix indices and intermediate values are integers; return the maximum value over all positions and over the three states.\n- Ensure the affine gap penalty is accumulated as $g_o + L \\cdot g_e$ for a gap of length $L$, consistent with the state-transition semantics you derive.", "solution": "The problem requires the implementation of the Smith-Waterman local sequence alignment algorithm utilizing an affine gap penalty model. This problem is scientifically sound, well-posed, and grounded in the fundamental principles of computational biology. I shall proceed by first deriving the necessary dynamic programming recurrence relations from the stated principles.\n\nLet the two sequences be $x = x_1x_2...x_n$ of length $n$ and $y = y_1y_2...y_m$ of length $m$. The scoring parameters are $s_{\\text{match}}$ for a character match, $s_{\\text{mismatch}}$ for a mismatch, $g_o$ for opening a gap, and $g_e$ for extending a gap. The penalty for a gap of length $L$ is $g_o + L \\cdot g_e$. Note that penalties are subtracted from the score.\n\nThe core of the algorithm rests on the principle of optimality. The optimal score for an alignment ending at positions $i$ and $j$ is computed from the optimal scores of smaller subproblems. The affine gap model necessitates three states at each position $(i,j)$ in the dynamic programming grid, corresponding to the three possible ways an alignment can end:\n\n1.  $M_{i,j}$: The score of the best local alignment ending with $x_i$ aligned to $y_j$.\n2.  $I_{x,i,j}$: The score of the best local alignment ending with $x_i$ aligned to a gap character ('-').\n3.  $I_{y,i,j}$: The score of the best local alignment ending with a gap character ('-') aligned to $y_j$.\n\nThe local nature of the alignment, a key feature of the Smith-Waterman algorithm, is enforced by allowing a new alignment to begin at any position. This is achieved by ensuring that scores in the DP matrices never fall below $0$. If all possible ways to extend an alignment to a given cell result in a non-positive score, the cell's score is set to $0$, signifying the start of a new potential local alignment.\n\nWe will construct three $(n+1) \\times (m+1)$ matrices, one for each state. The indices $i$ range from $0$ to $n$, and $j$ range from $0$ to $m$.\n\n**Initialization**\nFor a local alignment, any alignment can start anywhere. Thus, the DP matrices are initialized such that starting a new alignment costs nothing. This corresponds to setting the first row and first column of all three matrices to $0$.\n$$ M_{i,0} = I_{x,i,0} = I_{y,i,0} = 0 \\quad \\text{for } i \\in [0, n] $$\n$$ M_{0,j} = I_{x,0,j} = I_{y,0,j} = 0 \\quad \\text{for } j \\in [0, m] $$\n\n**Recurrence Relations**\nFor $i$ from $1$ to $n$ and $j$ from $1$ to $m$, the matrix cells are filled as follows. Let $s(x_i, y_j)$ be the substitution score, which is $s_{\\text{match}}$ if $x_i = y_j$ and $s_{\\text{mismatch}}$ otherwise.\n\n1.  **State $M_{i,j}$ (Match/Mismatch State):**\n    An alignment ending with $x_i$ matched to $y_j$ must follow an alignment ending at $(i-1, j-1)$. The previous state could have been a match/mismatch ($M_{i-1,j-1}$), a gap in $y$ ($I_{x,i-1,j-1}$), or a gap in $x$ ($I_{y,i-1,j-1}$). We take the maximum of these possibilities, add the substitution score $s(x_i, y_j)$, and apply the local alignment condition.\n    $$ M_{i,j} = \\max\\left(0, \\ s(x_i, y_j) + \\max\\left(M_{i-1,j-1}, I_{x,i-1,j-1}, I_{y,i-1,j-1}\\right)\\right) $$\n\n2.  **State $I_{x,i,j}$ (Gap in $y$ / Insertion in $x$):**\n    An alignment ending with $x_i$ against a gap must extend a previous alignment ending at $(i-1, j)$. This can occur in two ways:\n    a) Opening a new gap: The alignment up to $(i-1, j)$ ended in a match/mismatch ($M_{i-1,j}$). The penalty for opening a gap of length $1$ is $g_o + 1 \\cdot g_e$.\n    b) Extending an existing gap: The alignment up to $(i-1, j)$ already ended with $x_{i-1}$ against a gap ($I_{x,i-1,j}$). The penalty for extending the gap is $g_e$.\n    The recurrence combines these possibilities, again with the local alignment reset-to-zero condition.\n    $$ I_{x,i,j} = \\max\\left(0, \\max\\left(M_{i-1,j} - (g_o + g_e), \\ I_{x,i-1,j} - g_e\\right)\\right) $$\n\n3.  **State $I_{y,i,j}$ (Gap in $x$ / Insertion in $y$):**\n    Symmetrically, an alignment ending with $y_j$ against a gap must extend a previous alignment that ended at $(i, j-1)$.\n    a) Opening a new gap: from state $M_{i,j-1}$ with penalty $g_o + g_e$.\n    b) Extending an existing gap: from state $I_{y,i,j-1}$ with penalty $g_e$.\n    The recurrence is:\n    $$ I_{y,i,j} = \\max\\left(0, \\max\\left(M_{i,j-1} - (g_o + g_e), \\ I_{y,i,j-1} - g_e\\right)\\right) $$\n\n**Final Score**\nThe score of the optimal local alignment is the maximum value found anywhere in the three matrices over all positions $(i,j)$.\n$$ \\text{Score} = \\max_{0 \\le i \\le n, \\ 0 \\le j \\le m} \\{M_{i,j}, I_{x,i,j}, I_{y,i,j}\\} $$\n\nThis procedure takes $\\mathcal{O}(n \\cdot m)$ time as it requires filling three matrices of size $(n+1) \\times (m+1)$, with each cell calculation being a constant time operation. The space complexity is also $\\mathcal{O}(n \\cdot m)$ to store the three matrices. The implementation will now follow this formal derivation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    This program computes the optimal local alignment score for pairs of sequences\n    using the Smith-Waterman algorithm with an affine gap penalty.\n    \"\"\"\n\n    def smith_waterman_affine(x: str, y: str, s_match: int, s_mismatch: int, g_o: int, g_e: int) - int:\n        \"\"\"\n        Computes the Smith-Waterman local alignment score with an affine gap penalty.\n\n        Args:\n            x (str): The first sequence.\n            y (str): The second sequence.\n            s_match (int): The score for a character match.\n            s_mismatch (int): The score for a character mismatch (a penalty, so usually negative).\n            g_o (int): The gap opening penalty (non-negative).\n            g_e (int): The gap extension penalty (non-negative).\n\n        Returns:\n            int: The optimal local alignment score.\n        \"\"\"\n        n = len(x)\n        m = len(y)\n\n        # The three dynamic programming matrices for the states\n        # M: score ending in a match/mismatch\n        # Ix: score ending in a gap in y (insertion relative to x)\n        # Iy: score ending in a gap in x (insertion relative to y)\n        m_matrix = np.zeros((n + 1, m + 1), dtype=int)\n        ix_matrix = np.zeros((n + 1, m + 1), dtype=int)\n        iy_matrix = np.zeros((n + 1, m + 1), dtype=int)\n\n        max_score = 0\n        \n        # Penalty for opening a gap, combining g_o and the first g_e\n        gap_open_penalty = g_o + g_e\n        gap_extend_penalty = g_e\n\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                # Calculate substitution score for x[i-1] and y[j-1]\n                sub_score = s_match if x[i-1] == y[j-1] else s_mismatch\n\n                # Recurrence for M_i,j\n                prev_score_m = max(m_matrix[i-1, j-1], ix_matrix[i-1, j-1], iy_matrix[i-1, j-1])\n                m_matrix[i, j] = max(0, prev_score_m + sub_score)\n\n                # Recurrence for Ix_i,j (gap in y)\n                score_open_x = m_matrix[i-1, j] - gap_open_penalty\n                score_extend_x = ix_matrix[i-1, j] - gap_extend_penalty\n                ix_matrix[i, j] = max(0, score_open_x, score_extend_x)\n\n                # Recurrence for Iy_i,j (gap in x)\n                score_open_y = m_matrix[i, j-1] - gap_open_penalty\n                score_extend_y = iy_matrix[i, j-1] - gap_extend_penalty\n                iy_matrix[i, j] = max(0, score_open_y, score_extend_y)\n\n                # The optimal local score is the maximum found anywhere in the matrices\n                current_max = max(m_matrix[i, j], ix_matrix[i, j], iy_matrix[i, j])\n                if current_max  max_score:\n                    max_score = current_max\n        \n        return max_score\n\n    test_cases = [\n        # Case 1\n        {\"x\": \"GATTACA\", \"y\": \"GCATGCU\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 2\n        {\"x\": \"\", \"y\": \"\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 3\n        {\"x\": \"\", \"y\": \"ACGT\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 4\n        {\"x\": \"AAAA\", \"y\": \"TTTT\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n        # Case 5\n        {\"x\": \"AAAACCCCGGGG\", \"y\": \"AAAAGGGG\", \"s_match\": 2, \"s_mismatch\": -1, \"g_o\": 3, \"g_e\": 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        score = smith_waterman_affine(\n            case[\"x\"],\n            case[\"y\"],\n            case[\"s_match\"],\n            case[\"s_mismatch\"],\n            case[\"g_o\"],\n            case[\"g_e\"]\n        )\n        results.append(score)\n\n    # Format the final output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2401701"}, {"introduction": "A single optimal score can sometimes mask a more complex truth: several different alignments may achieve this same maximum score, each representing an equally plausible evolutionary scenario. This practice [@problem_id:2401709] takes you beyond merely finding the best score by challenging you to enumerate *all* distinct, equally optimal alignments. By modifying the standard traceback procedure to account for ties and systematically count all resulting paths, you will gain a deeper appreciation for the rich solution space encoded within the dynamic programming matrix.", "problem": "Consider two sequences over the deoxyribonucleic acid (DNA) alphabet and a local alignment scoring scheme. The goal is to reason from the principle of optimality to design a dynamic programming procedure that both computes the optimal local alignment score and, crucially, modifies the traceback to enumerate all equally optimal local alignments by branching on ties. Your program must implement this procedure and, for each provided test case, return two integers: the optimal local alignment score and the number of equally optimal local alignments as defined below. Aggregate all results into a single line as specified.\n\nFundamental base. Use the following starting point. A local alignment between two sequences $A$ and $B$ is any alignment of a contiguous substring of $A$ with a contiguous substring of $B$, scored by a substitution function and gap penalties, where alignment scores are not allowed to drop below $0$; the optimal local alignment score is the maximum over all such alignments. By the principle of optimality for Dynamic Programming (DP), the score of an optimal alignment ending at a cell depends only on optimal sub-alignments ending at predecessor cells and the immediate operation used to extend them. You must derive a recurrence from this base, without assuming any shortcut formula.\n\nScoring model. Let $A$ and $B$ be sequences of lengths $n$ and $m$, respectively, over the alphabet $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$. Define a substitution score function $\\sigma(x,y)$ by $\\sigma(x,y)=s_{\\mathrm{match}}$ if $x=y$ and $\\sigma(x,y)=s_{\\mathrm{mismatch}}$ otherwise. Use a linear gap penalty $g$ for inserting a single gap symbol. All three parameters are fixed to $s_{\\mathrm{match}}=+2$, $s_{\\mathrm{mismatch}}=-1$, and $g=-1$.\n\nTie-aware traceback and enumeration. In the local alignment DP table $H$, for each cell $(i,j)$ you must, in addition to its score, record the set of predecessor directions that achieve the cell’s value according to your derived recurrence. When multiple predecessors are tied for the maximum, all such directions must be recorded. A local alignment traceback starts at any cell $(i,j)$ with value equal to the global maximum in $H$ and proceeds by repeatedly moving to a recorded predecessor direction. A traceback terminates upon reaching a cell with value $0$, which marks the start of a local alignment; do not proceed beyond a cell with value $0$. Distinct tracebacks are considered distinct alignments. If the global maximum is $0$, define the number of equally optimal local alignments to be $0$ (that is, ignore empty alignments of score $0$).\n\nRequired outputs. For each test case, compute:\n- the optimal local alignment score (a nonnegative integer), and\n- the number of distinct, equally optimal local alignments obtained by fully branching on all tied predecessor directions during traceback, summed over all end cells with the global maximum.\n\nYour program must produce a single line of output containing all results for the test suite as a comma-separated list enclosed in square brackets, ordered as $[\\text{score}_1,\\text{count}_1,\\text{score}_2,\\text{count}_2,\\dots]$.\n\nTest suite. Use the following five test cases; all use $s_{\\mathrm{match}}=+2$, $s_{\\mathrm{mismatch}}=-1$, and $g=-1$:\n- Case $1$: $A=\\text{\"AA\"}$, $B=\\text{\"AA\"}$.\n- Case $2$: $A=\\text{\"AG\"}$, $B=\\text{\"GA\"}$.\n- Case $3$: $A=\\text{\"ACA\"}$, $B=\\text{\"AAA\"}$.\n- Case $4$: $A=\\text{\"C\"}$, $B=\\text{\"A\"}$.\n- Case $5$: $A=\\text{\"AAA\"}$, $B=\\text{\"AA\"}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$). No physical units are involved. All outputs must be integers.", "solution": "The problem requires the design and implementation of a dynamic programming procedure to compute the optimal local alignment score for two DNA sequences and to enumerate all distinct, equally optimal alignments. The derivation must proceed from the principle of optimality.\n\nLet the two sequences be $A = a_1a_2...a_n$ and $B = b_1b_2...b_m$ of lengths $n$ and $m$ respectively. The scoring scheme is defined by a match score $s_{\\mathrm{match}}=+2$, a mismatch score $s_{\\mathrm{mismatch}}=-1$, and a linear gap penalty $g=-1$.\n\nThe foundation of the solution is the Smith-Waterman algorithm, which is a direct application of dynamic programming to local sequence alignment. The principle of optimality dictates that an optimal solution can be constructed from optimal solutions to its subproblems. Let $H(i,j)$ be the score of the highest-scoring local alignment ending at position $i$ of sequence $A$ and position $j$ of sequence $B$. An alignment ending at $(i,j)$ can be formed in one of three ways:\n$1.$ By aligning characters $a_i$ and $b_j$. The score is the sum of the score of an optimal alignment ending at $(i-1, j-1)$ and the substitution score $\\sigma(a_i, b_j)$. This gives $H(i-1, j-1) + \\sigma(a_i, b_j)$.\n$2.$ By aligning character $a_i$ with a gap. The score is the sum of the score of an optimal alignment ending at $(i-1, j)$ and the gap penalty $g$. This gives $H(i-1, j) + g$.\n$3.$ By aligning character $b_j$ with a gap. The score is the sum of the score of an optimal alignment ending at $(i, j-1)$ and the gap penalty $g$. This gives $H(i, j-1) + g$.\n\nSince the alignment is local, it can begin at any position. This is handled by allowing a score of $0$ if all other possibilities result in a negative score, effectively starting a new alignment. Combining these cases, the recurrence relation for $H(i,j)$ is:\n$$\nH(i,j) = \\max \\left\\{\n    0, \\\\\n    H(i-1, j-1) + \\sigma(a_i, b_j), \\\\\n    H(i-1, j) + g, \\\\\n    H(i, j-1) + g\n\\right\\}\n$$\nfor $1 \\leq i \\leq n$ and $1 \\leq j \\leq m$. The DP matrix $H$ has dimensions $(n+1) \\times (m+1)$. The boundary conditions are $H(i,0) = 0$ for all $i$ from $0$ to $n$, and $H(0,j) = 0$ for all $j$ from $0$ to $m$. These initializations ensure that an alignment can start at any position without penalty from terminal gaps.\n\nThe optimal local alignment score, $\\text{score}_{\\text{opt}}$, is the maximum value found anywhere in the matrix $H$:\n$$\n\\text{score}_{\\text{opt}} = \\max_{0 \\le i \\le n, 0 \\le j \\le m} H(i,j)\n$$\n\nTo enumerate all equally optimal alignments, we must augment the procedure. First, we need to record the origin of the score for each cell. We define a pointer structure, $P$, of the same dimensions as $H$. Each element $P(i,j)$ will store a set of directions corresponding to the predecessors that yield the score $H(i,j)$.\n- If $H(i,j) = H(i-1, j-1) + \\sigma(a_i, b_j)$, the direction `DIAGONAL` is added to $P(i,j)$.\n- If $H(i,j) = H(i-1, j) + g$, the direction `UP` is added to $P(i,j)$.\n- If $H(i,j) = H(i, j-1) + g$, the direction `LEFT` is added to $P(i,j)$.\nIf multiple cases yield the same maximum value for $H(i,j)$, all corresponding directions are recorded. The case $H(i,j)=0$ corresponds to the start of an alignment and has no predecessors.\n\nThe enumeration process proceeds as follows:\n$1.$ Identify all cells $(i_{end}, j_{end})$ in the matrix $H$ where $H(i_{end}, j_{end}) = \\text{score}_{\\text{opt}}$. These are the termination points of all optimal local alignments.\n$2.$ If $\\text{score}_{\\text{opt}} = 0$, the problem defines the count of alignments to be $0$.\n$3.$ For each identified end cell, we must count the number of distinct traceback paths to a cell with a score of $0$. A path is a sequence of moves from cell to cell, following the directions stored in $P$. The total number of alignments is the sum of paths originating from all such maximal-scoring cells.\n\nTo count these paths without exponential complexity from re-exploring shared subpaths, we employ another dynamic programming technique: memoization. We define a recursive function, $\\text{count\\_paths}(i, j)$, that calculates the number of distinct paths ending at cell $(i, j)$.\nLet $C(i,j)$ be the number of paths from a cell with score $0$ to cell $(i,j)$ that constitute an optimal sub-alignment.\nThe recurrence for $C(i,j)$ is:\n- **Base Case:** If $H(i,j) = 0$, then $C(i,j) = 1$. This represents a single path starting from this point.\n- **Recursive Step:** For $H(i,j)  0$, the number of paths is the sum of the paths from all its predecessors recorded in $P(i,j)$:\n  $$\n  C(i,j) = \\sum_{(i', j') \\in \\text{predecessors}(i,j)} C(i',j')\n  $$\nThis can be implemented as a recursive function with a memoization table to store the results of $C(i,j)$ and avoid redundant computations.\n\nThe overall algorithm is:\n$1.$ Initialize an $(n+1) \\times (m+1)$ score matrix $H$ to zeros, and a pointer structure $P$ of the same size with empty sets/lists.\n$2.$ Fill $H$ and $P$ by iterating from $i=1...n$ and $j=1...m$, applying the recurrence relation and recording all maximizing predecessor directions.\n$3.$ Find $\\text{score}_{\\text{opt}} = \\max(H)$.\n$4.$ If $\\text{score}_{\\text{opt}} = 0$, return $(0, 0)$.\n$5.$ Otherwise, find all cells $(i_{end}, j_{end})$ where $H(i_{end}, j_{end}) = \\text{score}_{\\text{opt}}$.\n$6.$ Initialize an $(n+1) \\times (m+1)$ memoization table for path counting.\n$7.$ Initialize a total alignment count to $0$. For each $(i_{end}, j_{end})$, compute $\\text{count\\_paths}(i_{end}, j_{end})$ using the recursive, memoized function, and add the result to the total count.\n$8.$ Return the pair $(\\text{score}_{\\text{opt}}, \\text{total count})$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to solve the alignment problem for all test cases.\n    \"\"\"\n    \n    # scoring model is fixed for all test cases\n    s_match = 2\n    s_mismatch = -1\n    g = -1\n    \n    # Test suite from the problem statement\n    test_cases = [\n        (\"AA\", \"AA\"),        # Case 1\n        (\"AG\", \"GA\"),        # Case 2\n        (\"ACA\", \"AAA\"),      # Case 3\n        (\"C\", \"A\"),          # Case 4\n        (\"AAA\", \"AA\"),       # Case 5\n    ]\n    \n    all_results = []\n    for seq_a, seq_b in test_cases:\n        score, count = smith_waterman_enumerator(seq_a, seq_b, s_match, s_mismatch, g)\n        all_results.extend([score, count])\n        \n    # Format the final output string exactly as specified.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef smith_waterman_enumerator(seq_a, seq_b, s_match, s_mismatch, g):\n    \"\"\"\n    Computes the optimal local alignment score and enumerates all equally optimal alignments.\n\n    Args:\n        seq_a (str): The first sequence.\n        seq_b (str): The second sequence.\n        s_match (int): The score for a match.\n        s_mismatch (int): The score for a mismatch.\n        g (int): The linear gap penalty.\n\n    Returns:\n        tuple[int, int]: A tuple containing the optimal score and the number of optimal alignments.\n    \"\"\"\n    n = len(seq_a)\n    m = len(seq_b)\n\n    # DP score matrix H\n    H = np.zeros((n + 1, m + 1), dtype=int)\n    \n    # Pointer matrix P to store traceback directions for tied scores\n    P = [[[] for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Substitution score function\n    def sigma(char_a, char_b):\n        return s_match if char_a == char_b else s_mismatch\n\n    # Fill the DP matrices H and P\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            score_diag = H[i-1, j-1] + sigma(seq_a[i-1], seq_b[j-1])\n            score_up = H[i-1, j] + g\n            score_left = H[i, j-1] + g\n            \n            max_score = max(0, score_diag, score_up, score_left)\n            H[i, j] = max_score\n            \n            if max_score  0:\n                if max_score == score_diag:\n                    P[i][j].append('D') # Diagonal\n                if max_score == score_up:\n                    P[i][j].append('U') # Up\n                if max_score == score_left:\n                    P[i][j].append('L') # Left\n\n    # Find the optimal score and its location(s)\n    optimal_score = np.max(H)\n    \n    # Per problem statement, if max score is 0, count is 0\n    if optimal_score == 0:\n        return 0, 0\n    \n    max_indices = np.argwhere(H == optimal_score)\n    \n    # Memoization table for path counting, initialized with -1 (unvisited)\n    counts_memo = np.full((n + 1, m + 1), -1, dtype=int)\n\n    def count_paths(i, j):\n        \"\"\"Recursively count paths with memoization.\"\"\"\n        if counts_memo[i, j] != -1:\n            return counts_memo[i, j]\n        \n        # Base case: traceback terminates at a cell with score 0\n        if H[i, j] == 0:\n            return 1\n            \n        current_count = 0\n        for direction in P[i][j]:\n            if direction == 'D':\n                current_count += count_paths(i - 1, j - 1)\n            elif direction == 'U':\n                current_count += count_paths(i - 1, j)\n            elif direction == 'L':\n                current_count += count_paths(i, j - 1)\n        \n        counts_memo[i, j] = current_count\n        return current_count\n\n    total_alignments = 0\n    for idx_pair in max_indices:\n        i_end, j_end = idx_pair\n        total_alignments += count_paths(i_end, j_end)\n        \n    return int(optimal_score), total_alignments\n\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2401709"}, {"introduction": "Biological data often breaks the simple mold of linear sequences. Important genetic elements like plasmids and mitochondrial DNA have a circular topology, which poses a unique challenge for standard alignment algorithms. This hands-on exercise [@problem_id:2401715] will guide you in adapting the Smith-Waterman algorithm for circular sequences. You will learn to reframe the problem by understanding that any alignment spanning the conceptual \"ends\" of a circular molecule can be represented as a standard linear alignment on one of its rotations, a key insight for applying fundamental algorithms to novel biological contexts.", "problem": "You are asked to design and implement a program that computes local alignment scores for nucleotide sequences that may reside on a circular topology. The design must begin strictly from the core definition of local alignment as an optimization over alignments of substrings, and the Dynamic Programming (DP) principle. The goal is to compute, for each provided test case, the maximum local alignment score under a scoring system with a positive match score, a negative mismatch score, and a negative gap score (linear gap penalty). Your program must generalize the standard local alignment formulation to circular sequences by logically reducing circular topology to a finite collection of linear cases without loss of optimality.\n\nFundamental base to use:\n- Local alignment of two sequences is defined as the maximum, over all pairs of contiguous substrings and all alignments of those substrings, of the sum of per-position scores, with matches rewarded and mismatches and gaps penalized.\n- The DP principle states that an optimal solution to a problem can be built from optimal solutions of its subproblems when the problem exhibits optimal substructure and overlapping subproblems.\n\nRequirements and precise interpretation:\n- For a linear sequence, the local alignment score between two sequences is the maximum over all alignments of any pair of contiguous substrings of the two given sequences, with the score computed as the sum of per-position contributions: a match contributes $s_{\\text{match}}$, a mismatch contributes $s_{\\text{mismatch}}$, and each gap (insertion or deletion) contributes $s_{\\text{gap}}$. The local alignment score is never negative; if all alignments would yield a negative score, the correct score is $0$.\n- For a circular sequence, all rotations of that sequence represent the same molecule. A rotation is defined as moving a prefix to the end, preserving order. Any local alignment that spans the circular boundary can be represented as a local alignment between appropriate rotations of the sequences without spanning any end. Therefore, to evaluate the circular local alignment score, it suffices to consider all rotations of every sequence declared circular and take the maximum local alignment score over all such rotation pairs.\n- Scoring uses a linear gap penalty: each gap contributes exactly $s_{\\text{gap}}$ to the score, independent of its length. Matches and mismatches contribute $s_{\\text{match}}$ and $s_{\\text{mismatch}}$, respectively.\n- You must compute only the optimal local alignment score (an integer) for each test case. No traceback or alignment string is required.\n\nTest suite:\nCompute the maximum local alignment score for each of the following cases. In each tuple, the fields are (sequence $1$, sequence $2$, is\\_circular\\_1, is\\_circular\\_2, $s_{\\text{match}}$, $s_{\\text{mismatch}}$, $s_{\\text{gap}}$). The boolean flags indicate whether the sequence is to be treated as circular (True) or linear (False). All scores are integers.\n\n- Case A: (\"ATGCAT\", \"CATATG\", True, False, $2$, $-1$, $-2$).\n- Case B: (\"GATTACA\", \"TTACAGA\", True, True, $2$, $-1$, $-2$).\n- Case C: (\"AAAA\", \"TTTT\", True, False, $2$, $-1$, $-2$).\n- Case D: (\"ACGT\", \"AGT\", True, False, $3$, $-2$, $-2$).\n- Case E: (\"AAAA\", \"AAAA\", True, True, $2$, $-1$, $-3$).\n- Case F: (\"GCGT\", \"GCT\", False, False, $2$, $-1$, $-2$).\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the cases above. For example, a valid output line has the form \"[rA,rB,rC,rD,rE,rF]\" where each $r\\_$ is an integer score.\n\nScientific realism and derivation constraints:\n- Begin from the definition of local alignment as an optimization over substring alignments and the DP principle. Do not assume any special formula for circular sequences; instead, justify why rotation enumeration covers all necessary cases for circular topology.\n- Ensure all computations are integer-valued. No physical units are involved.", "solution": "The problem requires the computation of the maximum local alignment score between two nucleotide sequences, which may be linear or circular. This is a problem in optimization that can be rigorously solved using the principle of dynamic programming. The solution is developed in two stages: first, the formulation for linear sequences, known as the Smith-Waterman algorithm, and second, the logical extension of this formulation to circular sequences.\n\nThe local alignment of two sequences, $S_1$ and $S_2$, is defined as the alignment of any pair of their substrings that yields the maximum possible score. Let $S_1$ have length $m$ and $S_2$ have length $n$. A local alignment is an alignment between a substring $S_1[i..j]$ and $S_2[k..l]$ for some $1 \\le i \\le j \\le m$ and $1 \\le k \\le l \\le n$. The overall local alignment score is the maximum score found over all possible choices of substrings.\n\nThis problem possesses optimal substructure and overlapping subproblems, making it amenable to a dynamic programming solution. We define a matrix $H$, where the entry $H(i, j)$ represents the maximum score of an alignment ending at position $i$ of sequence $S_1$ and position $j$ of sequence $S_2$. The recurrence relation for $H(i, j)$ for $i  0$ and $j  0$ considers three possibilities for extending an existing alignment to include $S_1[i]$ and $S_2[j]$:\n$1$. Aligning $S_1[i]$ with $S_2[j]$. The score is the score of the optimal alignment ending at $H(i-1, j-1)$ plus the score for the new pair, $s(S_1[i], S_2[j])$. This term is given by $H(i-1, j-1) + s(S_1[i], S_2[j])$, where $s(a, b)$ is $s_{\\text{match}}$ if characters $a$ and $b$ are identical, and $s_{\\text{mismatch}}$ otherwise.\n$2$. Aligning $S_1[i]$ with a gap. The score is the score of the optimal alignment ending at $H(i-1, j)$ plus the gap penalty, $s_{\\text{gap}}$. This term is $H(i-1, j) + s_{\\text{gap}}$.\n$3$. Aligning $S_2[j]$ with a gap. The score is the score of the optimal alignment ending at $H(i, j-1)$ plus the gap penalty, $s_{\\text{gap}}$. This term is $H(i, j-1) + s_{\\text{gap}}$.\n\nA crucial feature of local alignment is that an alignment can begin at any position. This is achieved by allowing the score to be reset to zero if all alignment extensions from a given point result in a negative score. This \"fresh start\" possibility is incorporated by taking the maximum of the three cases above and zero.\nThe complete recurrence relation for the Smith-Waterman algorithm is therefore:\n$$\nH(i, j) = \\max\n\\begin{cases}\n0 \\\\\nH(i-1, j-1) + s(S_1[i], S_2[j]) \\\\\nH(i-1, j) + s_{\\text{gap}} \\\\\nH(i, j-1) + s_{\\text{gap}}\n\\end{cases}\n$$\nThe base conditions for the dynamic programming matrix are $H(i, 0) = 0$ for all $i \\in [0, m]$ and $H(0, j) = 0$ for all $j \\in [0, n]$. These conditions reflect that an alignment with an empty string has a score of zero.\n\nThe final local alignment score for the linear sequences $S_1$ and $S_2$ is not found at a fixed position but is the maximum value across the entire matrix $H$:\n$$\n\\text{Score}(S_1, S_2) = \\max_{0 \\le i \\le m, 0 \\le j \\le n} H(i, j)\n$$\n\nThe extension to circular sequences is based on the provided directive that \"any local alignment that spans the circular boundary can be represented as a local alignment between appropriate rotations of the sequences without spanning any end.\" This assertion is fundamentally correct. A local alignment involves finding optimal substrings. For a circular sequence, a \"substring\" can wrap around the conventionally defined ends of its linear string representation. For any such \"wrap-around\" substring, there exists a rotation of the original circular sequence in which this substring appears as a standard, contiguous, linear segment. For example, in the sequence $S = \\text{\"ABCDE\"}$, the wrap-around substring `DEAB` is a linear substring of the rotated sequence $S' = \\text{\"DEABC\"}$.\n\nConsequently, to find the maximal local alignment score involving one or two circular sequences, it is sufficient to consider all possible linear local alignments between all possible rotations of the sequences.\nLet $\\text{rot}(S)$ be the set of all unique rotations of a sequence $S$. If a sequence $S$ is linear, its set of rotations contains only itself, i.e., $\\text{rot}(S) = \\{S\\}$.\n\nThe algorithm proceeds as follows for a given test case $(S_1, S_2, \\text{is\\_circular}_1, \\text{is\\_circular}_2, s_{\\text{match}}, s_{\\text{mismatch}}, s_{\\text{gap}})$:\n$1$. Define the sequence sets $R_1$ and $R_2$. If $\\text{is\\_circular}_1$ is true, $R_1 = \\text{rot}(S_1)$; otherwise, $R_1 = \\{S_1\\}$. Similarly for $S_2$.\n$2$. Initialize a variable for the maximum score, $\\text{score}_{\\text{max}}$, to $0$.\n$3$. Iterate through every sequence $S'_1 \\in R_1$ and every sequence $S'_2 \\in R_2$.\n$4$. For each pair $(S'_1, S'_2)$, compute the standard linear local alignment score using the Smith-Waterman algorithm as described above.\n$5$. Update $\\text{score}_{\\text{max}}$ with the maximum score found so far: $\\text{score}_{\\text{max}} = \\max(\\text{score}_{\\text{max}}, \\text{Score}(S'_1, S'_2))$.\n$6$. The final result for the test case is the value of $\\text{score}_{\\text{max}}$ after all pairs have been evaluated.\n\nThis exhaustive enumeration over rotations guarantees that all possible local alignments, including those that span the circular boundary, are considered, leading to the globally optimal score. All calculations are performed with integer arithmetic as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the circular local alignment problem for a suite of test cases.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    # Each tuple: (seq1, seq2, is_circular_1, is_circular_2, s_match, s_mismatch, s_gap)\n    test_cases = [\n        (\"ATGCAT\", \"CATATG\", True, False, 2, -1, -2), # Case A\n        (\"GATTACA\", \"TTACAGA\", True, True, 2, -1, -2), # Case B\n        (\"AAAA\", \"TTTT\", True, False, 2, -1, -2),     # Case C\n        (\"ACGT\", \"AGT\", True, False, 3, -2, -2),      # Case D\n        (\"AAAA\", \"AAAA\", True, True, 2, -1, -3),     # Case E\n        (\"GCGT\", \"GCT\", False, False, 2, -1, -2),     # Case F\n    ]\n\n    results = []\n    for case in test_cases:\n        seq1, seq2, is_circ1, is_circ2, s_match, s_mismatch, s_gap = case\n        \n        # This function computes the local alignment score for two linear sequences\n        # using the Smith-Waterman algorithm.\n        def smith_waterman(s1, s2, match, mismatch, gap):\n            m, n = len(s1), len(s2)\n            # DP matrix H. H[i][j] is the score of the optimal alignment of a\n            # suffix of s1[0...i-1] and a suffix of s2[0...j-1].\n            H = np.zeros((m + 1, n + 1), dtype=int)\n            max_score = 0\n            \n            for i in range(1, m + 1):\n                for j in range(1, n + 1):\n                    # Score for matching or mismatching s1[i-1] and s2[j-1].\n                    similarity_score = match if s1[i-1] == s2[j-1] else mismatch\n                    match_mismatch_score = H[i-1, j-1] + similarity_score\n                    \n                    # Score for a gap in s1 (deletion)\n                    delete_score = H[i-1, j] + gap\n                    \n                    # Score for a gap in s2 (insertion)\n                    insert_score = H[i, j-1] + gap\n                    \n                    # The value of H[i,j] is the maximum of these possibilities,\n                    # or 0 if all are negative (starting a new local alignment).\n                    H[i, j] = max(0, match_mismatch_score, delete_score, insert_score)\n                    \n                    # Update the overall maximum score found so far.\n                    if H[i, j]  max_score:\n                        max_score = H[i, j]\n            \n            return int(max_score)\n\n        # Helper to generate all unique rotations of a sequence.\n        def get_rotations(seq):\n            if not seq:\n                return [\"\"]\n            return [seq[i:] + seq[:i] for i in range(len(seq))]\n\n        # Generate the sets of sequences to be compared, based on circularity.\n        rotations1 = get_rotations(seq1) if is_circ1 else [seq1]\n        rotations2 = get_rotations(seq2) if is_circ2 else [seq2]\n        \n        overall_max_score = 0\n        \n        # Iterate through all pairs of (rotated) sequences and find the max score.\n        for r1 in rotations1:\n            for r2 in rotations2:\n                current_score = smith_waterman(r1, r2, s_match, s_mismatch, s_gap)\n                if current_score  overall_max_score:\n                    overall_max_score = current_score\n        \n        results.append(overall_max_score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2401715"}]}