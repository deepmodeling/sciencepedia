{"hands_on_practices": [{"introduction": "To truly appreciate the difference between sequence identity and similarity, we must move beyond a simple match-or-mismatch viewpoint. This first exercise provides a quantitative feel for how similarity scores, like those from the BLOSUM62 matrix, capture the nuanced biochemical relationships between amino acids. By calculating the minimum number of conservative substitutions needed to achieve a target score increase, you will develop a practical understanding of how specific, evolutionarily plausible changes contribute to the overall similarity of two protein sequences. [@problem_id:2428699]", "problem": "Two protein sequences are aligned without gaps over length $L=200$. The alignment has sequence identity $0.70$, meaning that exactly $0.70L$ aligned positions contain identical amino acids and the remaining positions are non-identical. Similarity is quantified using the BLOSUM62 substitution matrix, and the total similarity score is defined as the sum of position-wise BLOSUM62 scores across the alignment. A conservative substitution is defined here as a non-identical amino-acid pair whose BLOSUM62 score is positive. You are allowed to introduce amino-acid changes at non-identical positions only; identical positions must remain unchanged.\n\nAssume the following for the non-identical positions:\n- A subset of the non-identical positions (assume there are enough such positions) currently contributes a BLOSUM62 score of $-1$ per position.\n- At each such position, you may perform exactly one amino-acid change in one sequence so that the resulting aligned pair becomes one of the following conservative pairs with the indicated BLOSUM62 score: R–K ($2$), D–E ($2$), N–D ($1$), S–T ($1$), F–Y ($3$), I–L ($2$), V–I ($3$), A–S ($1$).\n- No position may be changed into an identical pair; only the conservative non-identical pairs listed above are allowed outcomes of a change.\n\nIgnoring any gap penalties (since there are no gaps), what is the minimum number of such conservative substitutions required to increase the total BLOSUM62 similarity score of the alignment by $50$ points? Provide your answer as a single integer with no units. Do not round.", "solution": "The problem requires determining the minimum number of conservative substitutions needed to increase the total BLOSUM62 similarity score of a protein alignment by a specified amount. We begin by formalizing the parameters provided.\n\nThe alignment has a total length of $L=200$ amino acid positions. The sequence identity is given as $I=0.70$. The number of positions with identical amino acids is $N_{id} = I \\times L = 0.70 \\times 200 = 140$. Consequently, the number of non-identical positions is $N_{non-id} = L - N_{id} = 200 - 140 = 60$.\n\nSubstitutions are performed at a subset of these non-identical positions. It is specified that these particular positions initially contribute a BLOSUM62 score of $S_{initial} = -1$ each. A substitution at one such position changes the amino acid pair, resulting in a new, positive BLOSUM62 score, $S_{final}$. The increase in the total score from a single substitution, denoted as $\\Delta S$, is the difference between the final and initial scores:\n$$\n\\Delta S = S_{final} - S_{initial}\n$$\nThe problem provides a list of allowed conservative substitutions and their corresponding final BLOSUM62 scores. We must calculate the score increase, $\\Delta S$, for each type of allowed change.\nThe initial score for each position being modified is $S_{initial} = -1$.\nThe possible final scores, $S_{final}$, are:\n\\begin{enumerate}\n    \\item $S_{final} = 3$ for pairs F–Y or V–I. The score increase is $\\Delta S_1 = 3 - (-1) = 4$.\n    \\item $S_{final} = 2$ for pairs R–K, D–E, or I–L. The score increase is $\\Delta S_2 = 2 - (-1) = 3$.\n    \\item $S_{final} = 1$ for pairs N–D, S–T, or A–S. The score increase is $\\Delta S_3 = 1 - (-1) = 2$.\n\\end{enumerate}\nSo, the set of possible score increases per substitution is $\\{4, 3, 2\\}$.\n\nThe objective is to find the minimum number of substitutions, let us call it $n_{min}$, required to achieve a total score increase of $\\Delta S_{total} = 50$. To minimize the number of substitutions, we must employ a greedy strategy. This means for each substitution we make, we should choose the one that yields the maximum possible score increase. The maximum score increase available from a single substitution is $\\max(\\Delta S) = 4$.\n\nLet $n$ be the number of substitutions performed. If we exclusively use the most effective substitution (yielding $\\Delta S = 4$), the total score increase would be $4n$. To achieve the target increase of $50$, we must satisfy the inequality:\n$$\n4n \\ge 50\n$$\nSolving for $n$:\n$$\nn \\ge \\frac{50}{4}\n$$\n$$\nn \\ge 12.5\n$$\nSince the number of substitutions $n$ must be an integer, the minimum number of substitutions is the smallest integer that is greater than or equal to $12.5$. This is found by taking the ceiling of the value:\n$$\nn_{min} = \\lceil 12.5 \\rceil = 13\n$$\nThus, a minimum of $13$ substitutions are required. We must verify that a total score increase of exactly $50$ is achievable with $13$ substitutions, as the available score increments are discrete. Let $n_4$, $n_3$, and $n_2$ be the number of substitutions with score increases of $4$, $3$, and $2$, respectively. We need to find non-negative integers $n_4, n_3, n_2$ such that:\n$$\nn_4 + n_3 + n_2 = 13\n$$\nand\n$$\n4n_4 + 3n_3 + 2n_2 = 50\n$$\nThis is a system of linear Diophantine equations. A simple solution can be found by maximizing the use of the highest-value substitution, $n_4$. If we make $12$ substitutions with $\\Delta S = 4$, the score increase is $12 \\times 4 = 48$. We need an additional score increase of $50 - 48 = 2$. This can be achieved with one substitution of the type that yields $\\Delta S = 2$.\nThis corresponds to a solution: $n_4 = 12$, $n_3 = 0$, and $n_2 = 1$.\nThe total number of substitutions is $12 + 0 + 1 = 13$.\nThe total score increase is $(12 \\times 4) + (0 \\times 3) + (1 \\times 2) = 48 + 2 = 50$.\nThis confirms that it is possible to achieve the exact target score increase of $50$ with $13$ substitutions. The problem states \"assume there are enough such positions,\" which means we have at least $13$ non-identical positions with an initial score of $-1$ available for modification. This condition is satisfied by assumption.\n\nTherefore, the minimum number of substitutions required is $13$.", "answer": "$$\\boxed{13}$$", "id": "2428699"}, {"introduction": "A common misconception is that high similarity requires high identity. This hands-on coding practice directly confronts that idea by asking you to demonstrate that a local alignment can have a strictly positive similarity score while exhibiting zero identity. By implementing the foundational Smith-Waterman algorithm yourself, you will explore how different scoring models can identify biologically relevant similarities based on conservative substitutions alone, providing a powerful, memorable lesson on the decoupling of these two fundamental concepts. [@problem_id:2428720]", "problem": "You must write a complete program that, from first principles, constructs pairs of protein sequences over the uppercase English alphabet used for amino acids and evaluates whether the following property can be satisfied under specified local alignment scoring models: a Smith–Waterman (SW) local alignment between the two sequences has a strictly positive optimal score while the identity within the aligned region is equal to the decimal $0$. Your program must implement the Smith–Waterman dynamic programming recurrence with a linear gap penalty. The definitions and evaluation rules below must be followed exactly.\n\nDefinitions. Let $X = x_1 x_2 \\dots x_n$ and $Y = y_1 y_2 \\dots y_m$ be two sequences over a specified finite alphabet. A scoring function $s(\\cdot,\\cdot)$ assigns an integer similarity score to any aligned pair of letters. A linear gap penalty of magnitude $d \\ge 0$ subtracts $d$ for each gap character introduced. The Smith–Waterman dynamic programming matrix $H \\in \\mathbb{Z}^{(n+1)\\times(m+1)}$ is defined by the base conditions $H_{0,j} = 0$ for all $j \\in \\{0,1,\\dots,m\\}$ and $H_{i,0} = 0$ for all $i \\in \\{0,1,\\dots,n\\}$, and by the recurrence for all $i \\in \\{1,\\dots,n\\}$ and $j \\in \\{1,\\dots,m\\}$:\n$$\nH_{i,j} \\;=\\; \\max\\Big\\{\\, 0,\\; H_{i-1,j-1} + s(x_i,y_j),\\; H_{i-1,j} - d,\\; H_{i,j-1} - d \\,\\Big\\}.\n$$\nThe optimal Smith–Waterman local alignment score is $S^\\star(X,Y) = \\max_{0 \\le i \\le n,\\; 0 \\le j \\le m} H_{i,j}$. One optimal aligned region is any alignment recovered by a valid traceback path that starts at a cell $(i^\\star,j^\\star)$ attaining the maximum $S^\\star(X,Y)$ and proceeds by choosing at each step one predecessor that realizes the $\\max$ until a cell with value $0$ is reached. Define the aligned columns as the positions on the traceback path that correspond to diagonal steps; each diagonal step aligns one letter from $X$ to one letter from $Y$. Let $L$ be the total number of aligned columns (that is, the number of diagonal steps). Define the identity in the aligned region to be\n$$\n\\mathrm{Id}(X,Y) \\;=\\; \n\\begin{cases}\n\\frac{M}{L}, & \\text{if } L > 0,\\\\\n0, & \\text{if } L = 0,\n\\end{cases}\n$$\nwhere $M$ is the number of aligned columns among the $L$ diagonal steps for which the two letters are identical. The identity must be expressed as a decimal in the interval $[0,1]$ and for this task must equal the decimal $0$.\n\nScoring models. Your program must handle the following scoring models, each constituting one test case. For each test case, you may construct any sequences that satisfy the stated alphabet constraints and any additional length constraints. Your output for each test case must be a boolean that is true if and only if you construct sequences $X$ and $Y$ such that $S^\\star(X,Y) > 0$ and $\\mathrm{Id}(X,Y) = 0$, and false otherwise.\n\n- Test case 1 (happy path, hydrophobic similarity). Alphabet restricted to the amino acids $\\{ \\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M} \\}$. Use the Blocks Substitution Matrix 62 (BLOSUM62) scores for this $4 \\times 4$ subset, with $s(a,b)$ specified as:\n  $s(\\mathrm{I},\\mathrm{I}) = 4$, $s(\\mathrm{I},\\mathrm{L}) = 2$, $s(\\mathrm{I},\\mathrm{V}) = 3$, $s(\\mathrm{I},\\mathrm{M}) = 1$;\n  $s(\\mathrm{L},\\mathrm{I}) = 2$, $s(\\mathrm{L},\\mathrm{L}) = 4$, $s(\\mathrm{L},\\mathrm{V}) = 1$, $s(\\mathrm{L},\\mathrm{M}) = 2$;\n  $s(\\mathrm{V},\\mathrm{I}) = 3$, $s(\\mathrm{V},\\mathrm{L}) = 1$, $s(\\mathrm{V},\\mathrm{V}) = 4$, $s(\\mathrm{V},\\mathrm{M}) = 1$;\n  $s(\\mathrm{M},\\mathrm{I}) = 1$, $s(\\mathrm{M},\\mathrm{L}) = 2$, $s(\\mathrm{M},\\mathrm{V}) = 1$, $s(\\mathrm{M},\\mathrm{M}) = 5$.\n  Use a linear gap penalty $d = 5$. There is no length constraint beyond $n \\ge 1$ and $m \\ge 1$.\n\n- Test case 2 (boundary length, zero gap penalty). Same BLOSUM62 subset and alphabet as in test case $1$, but use a linear gap penalty $d = 0$. Enforce the boundary condition that $n = 1$ and $m = 1$.\n\n- Test case 3 (impossible regime under identity-only scoring). Use the full uppercase amino acid alphabet. Use a match/mismatch scoring model defined by $s(a,b) = 2$ if $a=b$ and $s(a,b) = -1$ if $a \\ne b$. Use a linear gap penalty $d = 2$. There is no length constraint beyond $n \\ge 1$ and $m \\ge 1$.\n\nYour task. For each test case $t \\in \\{1,2,3\\}$, construct any pair of sequences $(X_t,Y_t)$ that complies with the stated alphabet and length constraints for that test case and evaluate $S^\\star(X_t,Y_t)$ and $\\mathrm{Id}(X_t,Y_t)$ using the definitions above. Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets of length $3$, where the $t$-th element is a boolean that is true if and only if both $S^\\star(X_t,Y_t) > 0$ and $\\mathrm{Id}(X_t,Y_t) = 0$ hold, and false otherwise. For example, your program must print a line of the form $[\\text{result}_1,\\text{result}_2,\\text{result}_3]$.\n\nTest suite summary that you must implement and evaluate:\n- Test $1$: BLOSUM62 subset on $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V},\\mathrm{M}\\}$ with $d=5$.\n- Test $2$: BLOSUM62 subset on $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V},\\mathrm{M}\\}$ with $d=0$ and $n=m=1$.\n- Test $3$: Match $+2$ and mismatch $-1$ with $d=2$ on the amino acid alphabet.\n\nAll answers are unitless. Identity must be handled as a decimal in $[0,1]$. Your single-line output must be exactly the boolean list as specified, with no additional characters or lines.", "solution": "### Principle-Based Solution Design\n\nThe core task is to determine, for each of the three scoring models, if it is possible to construct two sequences $X$ and $Y$ that satisfy two conditions simultaneously:\n$1$. The optimal local alignment score $S^\\star(X,Y)$ is strictly positive.\n$2$. The identity of the optimal local alignment, $\\mathrm{Id}(X,Y)$, is exactly $0$.\n\nThe condition $\\mathrm{Id}(X,Y) = 0$ implies that within the region of optimal local alignment, there are no matching characters. For this to be non-trivial, the alignment length $L$ (number of diagonal steps in traceback) must be greater than $0$, which in turn means the number of matches $M$ must be $0$. If $L=0$, the alignment is empty, its score is $0$, and the condition $S^\\star > 0$ is violated. Therefore, we seek an alignment path with at least one diagonal step ($L \\ge 1$), where all such steps are mismatches.\n\nThe score of a local alignment is determined by the sum of scores of its constituent operations (matches, mismatches, and gaps). For $S^\\star > 0$, there must exist an alignment path starting from a score of $0$ that accumulates a positive total score.\n\n**Test Case 1: BLOSUM62 subset, $d=5$**\n\nThe alphabet is $\\{\\mathrm{I}, \\mathrm{L}, \\mathrm{V}, \\mathrm{M}\\}$. The scoring matrix provided assigns positive scores to substitutions between these similar hydrophobic amino acids. For instance, the score for aligning Isoleucine (I) with Valine (V) is $s(\\mathrm{I},\\mathrm{V}) = 3$. Let us construct the simplest possible non-trivial sequences: $X = \\text{\"I\"}$ and $Y = \\text{\"V\"}$. Here, $n=1, m=1$.\n\nThe Smith-Waterman matrix $H$ is of size $2 \\times 2$. The only non-trivial entry to compute is $H_{1,1}$:\n$$H_{1,1} = \\max\\{0, H_{0,0} + s(\\text{'I'},\\text{'V'}), H_{0,1} - 5, H_{1,0} - 5\\}$$\n$$H_{1,1} = \\max\\{0, 0 + 3, 0 - 5, 0 - 5\\} = \\max\\{0, 3, -5, -5\\} = 3$$\nThe optimal score is $S^\\star = 3$, which is greater than $0$.\nTo find the identity, we trace back from the cell $(1,1)$. The score $3$ was obtained from the diagonal predecessor $H_{0,0}$. This constitutes one diagonal step, so $L=1$. The alignment is $\\text{'I'}$ with $\\text{'V'}$. Since these are different, the number of matches $M=0$.\nThe identity is $\\mathrm{Id} = M/L = 0/1 = 0$.\nBoth conditions ($S^\\star > 0$ and $\\mathrm{Id}=0$) are satisfied. Thus, the property is satisfiable for this case. The answer is `True`.\n\n**Test Case 2: BLOSUM62 subset, $d=0, n=m=1$**\n\nThis case uses the same scoring as Case 1, but with a zero gap penalty and a strict length constraint of $n=1$ and $m=1$. The logic from Case $1$ is directly applicable. Let us again choose $X = \\text{\"I\"}$ and $Y = \\text{\"V\"}$.\nThe score calculation is:\n$$H_{1,1} = \\max\\{0, H_{0,0} + s(\\text{'I'},\\text{'V'}), H_{0,1} - 0, H_{1,0} - 0\\}$$\n$$H_{1,1} = \\max\\{0, 0 + 3, 0 - 0, 0 - 0\\} = \\max\\{0, 3, 0, 0\\} = 3$$\nThe optimal score is $S^\\star = 3 > 0$. The alignment consists of one mismatch, so $L=1, M=0$, and $\\mathrm{Id}=0$. Both conditions are satisfied. The answer is `True`.\n\n**Test Case 3: Identity-only scoring, $d=2$**\n\nThe scoring model is $s(a,a) = 2$ (match) and $s(a,b) = -1$ for $a \\ne b$ (mismatch). The gap penalty is $d=2$.\nTo achieve $\\mathrm{Id}=0$, an alignment path must be composed entirely of mismatches and gaps.\nLet's analyze the score contribution of each possible step in such an alignment:\n-   A mismatch contributes a score of $-1$.\n-   A gap (insertion or deletion) contributes a score of $-d = -2$.\n\nAny alignment path starting from a score of $0$ and consisting of a sequence of these operations will accumulate a total score. Let the path have $k_d$ mismatches and $k_g$ gaps. For the identity to be defined as specified and the alignment to be non-empty, we require $L = k_d > 0$. The total score of this alignment path is:\n$$\\text{Score} = k_d \\times (-1) + k_g \\times (-2) = -k_d - 2k_g$$\nSince $k_d \\ge 1$ and $k_g \\ge 0$, this score is always strictly negative (e.g., $\\le -1$).\nThe Smith-Waterman recurrence is $H_{i,j} = \\max\\{0, \\dots\\}$. This means that if the score of extending any existing alignment or starting a new one is negative, the resulting cell value $H_{i,j}$ will be set to $0$. An alignment consisting solely of mismatches and gaps will always produce a non-positive score path. Consequently, the maximum score in the entire matrix, $S^\\star$, can never be strictly positive. It will be $0$.\nTherefore, it is impossible to satisfy $S^\\star > 0$ and $\\mathrm{Id}=0$ simultaneously under this scoring model. The property is not satisfiable. The answer is `False`.\n\n**Algorithmic Implementation**\n\nThe solution is implemented in Python. A function, `run_sw_and_evaluate`, encapsulates the logic for a single test case. It constructs the specified sequences, scoring function, and gap penalty. It then calls a `smith_waterman` function which implements the algorithm from first principles using `numpy` for the dynamic programming matrix. This function calculates the optimal score $S^\\star$ and, if $S^\\star > 0$, performs a traceback to compute the alignment identity $\\mathrm{Id}$. The main `solve` function iterates through the three test cases, calls `run_sw_and_evaluate` for each, and appends the resulting boolean to a list. Finally, it prints the list in the specified format. The chosen sequences for test cases $1$ and $2$ are simple pairs demonstrating positive mismatch scores, as reasoned above. For test case $3$, a simple mismatch pair is used, which correctly yields a score of $0$, leading to a `False` result, consistent with the proof of impossibility.", "answer": "```python\nimport numpy as np\n\ndef smith_waterman(X: str, Y: str, score_func, d: int):\n    \"\"\"\n    Implements the Smith-Waterman algorithm from first principles.\n\n    Args:\n        X: The first sequence.\n        Y: The second sequence.\n        score_func: A function s(a, b) that returns the score of aligning characters a and b.\n        d: The linear gap penalty (a positive integer).\n\n    Returns:\n        A tuple (max_score, identity) where max_score is the optimal local\n        alignment score and identity is the fraction of matches in the\n        optimal alignment.\n    \"\"\"\n    n = len(X)\n    m = len(Y)\n    H = np.zeros((n + 1, m + 1), dtype=int)\n    \n    max_score = 0\n    max_pos = (0, 0)\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            match_score = H[i - 1, j - 1] + score_func(X[i - 1], Y[j - 1])\n            delete_score = H[i - 1, j] - d\n            insert_score = H[i, j - 1] - d\n            \n            H[i, j] = max(0, match_score, delete_score, insert_score)\n\n            if H[i, j] > max_score:\n                max_score = H[i, j]\n                max_pos = (i, j)\n\n    if max_score == 0:\n        return 0, 0.0\n\n    # Traceback to calculate identity\n    i, j = max_pos\n    L, M = 0, 0\n    \n    while H[i, j] > 0:\n        current_score = H[i, j]\n        \n        # Check diagonal predecessor\n        if i > 0 and j > 0 and current_score == H[i - 1, j - 1] + score_func(X[i - 1], Y[j - 1]):\n            L += 1\n            if X[i - 1] == Y[j - 1]:\n                M += 1\n            i, j = i - 1, j - 1\n        # Check up predecessor (gap in Y)\n        elif i > 0 and current_score == H[i - 1, j] - d:\n            i -= 1\n        # Check left predecessor (gap in X)\n        elif j > 0 and current_score == H[i, j - 1] - d:\n            j -= 1\n        else:\n            # Should not be reached if traceback starts from a cell > 0.\n            # This indicates the alignment started at this cell.\n            break\n            \n    identity = M / L if L > 0 else 0.0\n    return max_score, identity\n\ndef solve():\n    \"\"\"\n    Defines and runs the three test cases specified in the problem.\n    \"\"\"\n    \n    # Test Case 1: BLOSUM62 subset, d=5\n    blosum62_subset = {\n        'I': {'I': 4, 'L': 2, 'V': 3, 'M': 1},\n        'L': {'I': 2, 'L': 4, 'V': 1, 'M': 2},\n        'V': {'I': 3, 'V': 4, 'L': 1, 'M': 1},\n        'M': {'I': 1, 'L': 2, 'V': 1, 'M': 5}\n    }\n    score_func_1 = lambda a, b: blosum62_subset[a][b]\n    # We choose two different amino acids with a positive substitution score.\n    X1, Y1 = \"I\", \"V\" \n    d1 = 5\n    \n    # Test Case 2: BLOSUM62 subset, d=0, n=m=1\n    score_func_2 = score_func_1\n    X2, Y2 = \"I\", \"V\"\n    d2 = 0\n\n    # Test Case 3: Match/mismatch, d=2\n    score_func_3 = lambda a, b: 2 if a == b else -1\n    # We choose any two different amino acids to form a mismatch.\n    X3, Y3 = \"A\", \"R\"\n    d3 = 2\n    \n    test_cases = [\n        (X1, Y1, score_func_1, d1),\n        (X2, Y2, score_func_2, d2),\n        (X3, Y3, score_func_3, d3),\n    ]\n\n    results = []\n    for X, Y, score_func, d in test_cases:\n        s_star, identity = smith_waterman(X, Y, score_func, d)\n        condition_met = (s_star > 0 and identity == 0.0)\n        results.append(condition_met)\n    \n    # Python's str(bool) produces \"True\" and \"False\".\n    # The problem asks for a boolean, and this is the standard representation.\n    # The example [result_1, ...] suggests a comma-separated list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2428720"}, {"introduction": "This final practice elevates your understanding from analysis to design, challenging you to apply your knowledge in a constrained optimization problem. You will develop a greedy algorithm to create a new sequence that maximizes its BLOSUM62 similarity score relative to a reference, while being constrained to a precise level of sequence identity. This task requires a deeper, strategic engagement with the substitution matrix, highlighting how it can be used not just to score alignments, but to guide the rational design of sequences with desired properties. [@problem_id:2428729]", "problem": "You are given a reference protein sequence over the standard $20$ amino acids $\\{ \\mathrm{A}, \\mathrm{R}, \\mathrm{N}, \\mathrm{D}, \\mathrm{C}, \\mathrm{Q}, \\mathrm{E}, \\mathrm{G}, \\mathrm{H}, \\mathrm{I}, \\mathrm{L}, \\mathrm{K}, \\mathrm{M}, \\mathrm{F}, \\mathrm{P}, \\mathrm{S}, \\mathrm{T}, \\mathrm{W}, \\mathrm{Y}, \\mathrm{V} \\}$. Let the reference sequence be denoted by $S = (a_1, a_2, \\dots, a_n)$ of length $n$, where $n$ is even. Consider constructing a new protein sequence $T = (b_1, b_2, \\dots, b_n)$ of the same length such that exactly one half of the positions are identical to the reference, that is, exactly $n/2$ indices $i$ satisfy $b_i = a_i$. There are no insertions or deletions. The BLOcks SUbstitution Matrix (BLOSUM62) defines a substitution score $s(x,y)$ for any pair of amino acids $x$ and $y$. The total sequence-to-sequence similarity score is the sum of per-position scores:\n$$\n\\text{Score}(S,T) = \\sum_{i=1}^{n} s(a_i, b_i).\n$$\nYour task is to compute, for each provided reference sequence $S$, the maximum possible value of $\\text{Score}(S,T)$ over all sequences $T$ with exactly $n/2$ positions identical to $S$, using the canonical BLOSUM62 substitution scores and allowing any amino acid choice at non-identical positions. All sequences are over the $20$ standard amino acids and contain no ambiguous letters. No gaps are permitted, and all comparisons are position-wise.\n\nTest suite:\n- Case $1$ (general repeated residue): $S = \\text{\"AAAAAA\"}$.\n- Case $2$ (general repeated residue with high diagonal): $S = \\text{\"WWWWWW\"}$.\n- Case $3$ (general repeated residue with neutral off-diagonal): $S = \\text{\"GGGG\"}$.\n- Case $4$ (alternating residues probing per-position tradeoffs): $S = \\text{\"ACACACAC\"}$.\n- Case $5$ (boundary length): $S = \\text{\"AA\"}$.\n\nFor each case, compute a single integer: the maximal value of $\\text{Score}(S,T)$ achievable by any $T$ with exactly $n/2$ identities. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[x1,x2,x3,x4,x5]\"), in the same order as the test suite above. There are no physical units involved in this problem. The fraction of identical positions must be expressed as exactly one half, i.e., $n/2$ or $0.5$ of the positions, not a percentage.", "solution": "The problem as stated is a constrained optimization problem within the domain of computational biology. We are asked to find the maximum similarity score between a given reference protein sequence $S$ and a target sequence $T$ of the same length, under the specific constraint that exactly half of the positions in $T$ are identical to those in $S$.\n\nLet the reference sequence be $S = (a_1, a_2, \\dots, a_n)$ of even length $n$ over the alphabet of $20$ standard amino acids. We seek to construct a sequence $T = (b_1, b_2, \\dots, b_n)$ that maximizes the total similarity score, defined as:\n$$\n\\text{Score}(S,T) = \\sum_{i=1}^{n} s(a_i, b_i)\n$$\nwhere $s(x,y)$ is the substitution score given by the BLOSUM62 matrix.\n\nThe construction of $T$ is subject to a critical constraint: the number of positions $i$ where $b_i = a_i$ must be exactly $n/2$. Let us partition the set of sequence indices $\\{1, 2, \\dots, n\\}$ into two disjoint subsets:\n1.  The set of identical positions, $I = \\{i \\mid b_i = a_i\\}$, with cardinality $|I| = n/2$.\n2.  The set of mutated positions, $M = \\{i \\mid b_i \\neq a_i\\}$, with cardinality $|M| = n/2$.\n\nThe total score can be decomposed into sums over these two sets:\n$$\n\\text{Score}(S,T) = \\sum_{i \\in I} s(a_i, a_i) + \\sum_{i \\in M} s(a_i, b_i)\n$$\n\nTo maximize this total score, we must make optimal choices for both the partition $(I, M)$ and the specific amino acids $b_i$ for all $i \\in M$. The choices of $b_i$ for $i \\in M$ are independent of each other and of the partition. For any given position $i$ that is designated as a mutation site (i.e., $i \\in M$), the score contribution $s(a_i, b_i)$ is maximized by choosing the amino acid $b_i$ (where $b_i \\neq a_i$) that has the highest substitution score with $a_i$.\n\nLet us define two quantities for each position $i$ in the reference sequence $S$:\n1.  The **identity score**, $\\delta_{id}(i)$, is the score contribution if position $i$ is chosen to be identical. This is simply the diagonal element of the BLOSUM62 matrix for the amino acid $a_i$:\n    $$\n    \\delta_{id}(i) = s(a_i, a_i)\n    $$\n2.  The **maximum mutation score**, $\\delta_{mut}(i)$, is the maximum possible score contribution if position $i$ is chosen to be a mutation site. This is found by taking the maximum non-diagonal score in the BLOSUM62 matrix for the amino acid $a_i$:\n    $$\n    \\delta_{mut}(i) = \\max_{x \\in \\mathcal{A}, x \\neq a_i} s(a_i, x)\n    $$\n    where $\\mathcal{A}$ is the set of the $20$ standard amino acids.\n\nWith these definitions, the maximum achievable score for a fixed partition $(I, M)$ is:\n$$\n\\text{Score}_{max}(I, M) = \\sum_{i \\in I} \\delta_{id}(i) + \\sum_{i \\in M} \\delta_{mut}(i)\n$$\n\nOur task is now reduced to finding the optimal partition $(I, M)$ that maximizes this sum. We can reformulate the expression to isolate the terms dependent on the choice of partition. Since $I \\cup M = \\{1, \\dots, n\\}$ and $I \\cap M = \\emptyset$, we can write $\\sum_{i \\in M} \\delta_{mut}(i) = \\sum_{j=1}^{n} \\delta_{mut}(j) - \\sum_{j \\in I} \\delta_{mut}(j)$. Substituting this into the score equation gives:\n$$\n\\text{Score}_{max}(I) = \\sum_{i \\in I} \\delta_{id}(i) + \\left( \\sum_{j=1}^{n} \\delta_{mut}(j) - \\sum_{j \\in I} \\delta_{mut}(j) \\right)\n$$\n$$\n\\text{Score}_{max}(I) = \\left( \\sum_{j=1}^{n} \\delta_{mut}(j) \\right) + \\sum_{i \\in I} (\\delta_{id}(i) - \\delta_{mut}(i))\n$$\n\nThe first term, $\\sum_{j=1}^{n} \\delta_{mut}(j)$, is a constant for a given reference sequence $S$; it does not depend on the choice of the set $I$. Therefore, to maximize the total score, we must maximize the second term. Let us define the **identity advantage** for each position $i$ as:\n$$\n\\Delta_i = \\delta_{id}(i) - \\delta_{mut}(i)\n$$\nThis quantity, $\\Delta_i$, represents the net gain in score obtained by choosing position $i$ to be an identity site ($i \\in I$) rather than an optimal mutation site ($i \\in M$).\n\nThe problem is now to choose a set $I$ of size $n/2$ that maximizes $\\sum_{i \\in I} \\Delta_i$. This is a classic selection problem. The optimal strategy is a greedy one: compute the advantage $\\Delta_i$ for all positions $i=1, \\dots, n$, and then select the $n/2$ positions that have the largest advantage values to form the set $I$.\n\nThe algorithm is as follows:\n1.  For the given reference sequence $S = (a_1, \\dots, a_n)$, pre-compute and store the values of $\\delta_{id}(a)$ and $\\delta_{mut}(a)$ for each of the $20$ standard amino acids $a$, using the canonical BLOSUM62 matrix.\n2.  For each position $i \\in \\{1, \\dots, n\\}$, determine the amino acid $a_i$ and retrieve its corresponding values, $\\delta_{id}(a_i)$ and $\\delta_{mut}(a_i)$.\n3.  Calculate the list of mutation scores $M_{scores} = [\\delta_{mut}(a_1), \\dots, \\delta_{mut}(a_n)]$ and the list of advantages $\\text{Advantages} = [\\Delta_1, \\dots, \\Delta_n]$, where $\\Delta_i = \\delta_{id}(a_i) - \\delta_{mut}(a_i)$.\n4.  Sort the `Advantages` list in descending order.\n5.  The maximum total score is the sum of all maximum mutation scores plus the sum of the top $n/2$ advantages:\n    $$\n    \\text{Score}_{max} = \\left( \\sum_{i=1}^{n} \\delta_{mut}(a_i) \\right) + \\left( \\sum_{j=1}^{n/2} \\text{sorted\\_Advantages}_j \\right)\n    $$\nThis method yields the exact maximum score because the score contributions of individual positions are additive and their optimization is decoupled, allowing a greedy selection of the set of identities $I$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the protein sequence scoring problem based on a greedy optimization strategy.\n    \n    The problem is to maximize the BLOSUM62 score of a sequence T against a \n    reference sequence S, where T has exactly n/2 identical residues to S.\n\n    The logic is as follows:\n    1. For each position in S, we can either keep it identical or mutate it.\n    2. The score for an identical position `i` is `s(a_i, a_i)`.\n    3. The best possible score for a mutated position `i` is `max(s(a_i, x))` for all `x != a_i`.\n    4. The \"advantage\" of keeping a position identical is the difference: \n       `s(a_i, a_i) - max(s(a_i, x))`.\n    5. To maximize the total score, we should choose the `n/2` positions with the highest\n       \"advantage\" to be identical. The rest will be optimally mutated.\n    6. The final score is the sum of scores from the chosen identical positions and the\n       optimally mutated positions. This is equivalent to summing all optimal mutation\n       scores and adding the sum of the top `n/2` advantages.\n    \"\"\"\n\n    # The canonical 20 amino acids as per the problem.\n    # The order must match the BLOSUM62 matrix below.\n    AA_ORDER = 'ARNDCQEGHILKMFPSTWYV'\n    \n    # Standard BLOSUM62 substitution matrix for the 20 amino acids.\n    # Source: NCBI\n    BLOSUM62 = np.array([\n        # A, R, N, D, C, Q, E, G, H, I, L, K, M, F, P, S, T, W, Y, V\n        [ 4,-1,-2,-2, 0,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0], # A\n        [-1, 5, 0,-2,-3, 1, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3], # R\n        [-2, 0, 6, 1,-3, 0, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3], # N\n        [-2,-2, 1, 6,-3, 0, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3], # D\n        [ 0,-3,-3,-3, 9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1], # C\n        [-1, 1, 0, 0,-3, 5, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2], # Q\n        [-1, 0, 0, 2,-4, 2, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2], # E\n        [ 0,-2, 0,-1,-3,-2,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3], # G\n        [-2, 0, 1,-1,-3, 0, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3], # H\n        [-1,-3,-3,-3,-1,-3,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3], # I\n        [-1,-2,-3,-4,-1,-2,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1], # L\n        [-1, 2, 0,-1,-3, 1, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2], # K\n        [-1,-1,-2,-3,-1, 0,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1], # M\n        [-2,-3,-3,-3,-2,-3,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1], # F\n        [-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2], # P\n        [ 1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2], # S\n        [ 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0], # T\n        [-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3], # W\n        [-2,-2,-2,-3,-2,-1,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1], # Y\n        [ 0,-3,-3,-3,-1,-2,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4]  # V\n    ])\n    \n    # Map amino acid characters to their index in the matrix\n    AA_MAP = {aa: i for i, aa in enumerate(AA_ORDER)}\n\n    # Pre-calculate identity scores and max mutation scores for each amino acid\n    delta_cache = {}\n    for aa, idx in AA_MAP.items():\n        row = BLOSUM62[idx]\n        delta_id = row[idx]\n        # Max mutation score is the max of the row excluding the identity score\n        delta_mut = np.max(np.delete(row, idx))\n        delta_cache[aa] = (delta_id, delta_mut)\n\n    test_cases = [\n        \"AAAAAA\",     # Case 1\n        \"WWWWWW\",     # Case 2\n        \"GGGG\",       # Case 3\n        \"ACACACAC\",   # Case 4\n        \"AA\"          # Case 5\n    ]\n\n    results = []\n    for seq in test_cases:\n        n = len(seq)\n        num_identities = n // 2\n        \n        advantages = []\n        mut_scores_sum = 0\n        \n        for aa_char in seq:\n            delta_id, delta_mut = delta_cache[aa_char]\n            advantage = delta_id - delta_mut\n            advantages.append(advantage)\n            mut_scores_sum += delta_mut\n            \n        # Sort advantages in descending order to find the top n/2\n        advantages.sort(reverse=True)\n        \n        # The total score is the sum of all optimal mutation scores plus the sum of the\n        # advantages for the positions we choose to keep identical.\n        top_advantages_sum = sum(advantages[:num_identities])\n        \n        max_score = mut_scores_sum + top_advantages_sum\n        results.append(max_score)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428729"}]}