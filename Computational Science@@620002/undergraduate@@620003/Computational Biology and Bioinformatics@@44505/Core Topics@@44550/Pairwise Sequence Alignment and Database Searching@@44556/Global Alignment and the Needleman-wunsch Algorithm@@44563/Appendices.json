{"hands_on_practices": [{"introduction": "An alignment algorithm is a powerful tool, but its effectiveness hinges on how we define \"similarity\" through scoring parameters. This exercise demonstrates the profound impact of your choice of substitution matrix and gap penalties. By comparing a simple identity matrix with a more complex BLOSUM-like scheme, you will see how different parameters can produce vastly different alignments for the same pair of sequences, revealing that the selection of a scoring system is a critical interpretive step in any bioinformatics analysis [@problem_id:2395031].", "problem": "A central principle in sequence analysis is that the biological relevance of a global alignment depends on what is under selection: some features are conserved only if the exact residues align, while other regions may tolerate conservative substitutions. Consider two peptide sequences $X$ and $Y$ that both contain the integrin-binding tripeptide motif RGD, which is often under strong functional constraint to be exactly conserved. The sequences are:\n\n- $X$: I L V I L V R G D I L\n- $Y$: I I L V I L V A R G D\n\nAssume we will compute a global alignment using the Needleman–Wunsch algorithm with a linear gap model. Two alternative scoring systems are given:\n\n- Identity scoring: $s(a,b)=+1$ if $a=b$, $s(a,b)=-1$ if $a\\neq b$, with a linear gap penalty $g=-1$ per gap symbol.\n- A BLOSUM-like complex substitution scheme $s'(a,b)$ with a linear gap penalty $g'=-6$, defined on the subset of residues that appear here as follows:\n  - $s'(a,a)=+4$ (exact matches).\n  - Conservative hydrophobic substitutions among $\\{\\mathrm{I},\\mathrm{L},\\mathrm{V}\\}$ score $+3$: $s'(\\mathrm{I},\\mathrm{L})=s'(\\mathrm{L},\\mathrm{I})=s'(\\mathrm{I},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{I})=s'(\\mathrm{L},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{L})=+3$.\n  - Specific nonconservative pairs: $s'(\\mathrm{R},\\mathrm{V})=s'(\\mathrm{V},\\mathrm{R})=-3$, $s'(\\mathrm{D},\\mathrm{R})=s'(\\mathrm{R},\\mathrm{D})=-2$, $s'(\\mathrm{L},\\mathrm{D})=s'(\\mathrm{D},\\mathrm{L})=-3$.\n  - Neutral pairs: $s'(\\mathrm{G},\\mathrm{A})=s'(\\mathrm{A},\\mathrm{G})=0$, $s'(\\mathrm{I},\\mathrm{G})=s'(\\mathrm{G},\\mathrm{I})=0$.\n  - Any other unspecified mismatch scores $-1$.\n\nBiological context. For these two proteins it is known that the RGD motif must be aligned exactly (R on R, G on G, D on D) to preserve integrin binding; conservative substitutions in the hydrophobic background are frequently tolerated but not functionally decisive. A biologically relevant global alignment, therefore, is one that aligns the RGD tripeptide exactly, even if it must introduce gaps in a nearby low-complexity hydrophobic region.\n\nFundamental base. The global alignment score for an alignment of prefixes $X[1..i]$ and $Y[1..j]$ under a linear gap model obeys the Needleman–Wunsch dynamic programming recurrence\n$$\nF(i,j) \\;=\\; \\max\\big\\{\\, F(i-1,j-1) + s(x_i,y_j),\\;\\; F(i-1,j)+g,\\;\\; F(i,j-1)+g \\,\\big\\}\n$$\nwith appropriate initialization, where $s$ is the substitution score and $g$ the gap penalty (and analogously with $s'$ and $g'$ for the BLOSUM-like scheme). An optimal global alignment corresponds to an optimal path in this dynamic program.\n\nTask. Without constructing the full dynamic programming tables, reason from the recurrence and the scoring definitions to identify which alignment structure each scoring scheme will prefer between these two natural competitors:\n- A “no-gap” alignment that keeps the long hydrophobic block aligned on the diagonal and does not realign the RGD motif (it becomes offset and largely mismatched).\n- A “motif-aligned” alignment that introduces gaps inside the hydrophobic block to slide the sequences so that RGD aligns exactly.\n\nWhich statement is correct?\n\nA. Under the identity scoring, the optimal alignment introduces $2$ gaps to align RGD exactly and achieves a higher score than the best no-gap alignment; under the BLOSUM-like scheme with $g'=-6$, the optimal alignment avoids gaps, keeps the hydrophobic block aligned, and leaves RGD misaligned because this yields a higher score. Thus, the identity-scored alignment is more biologically relevant.\n\nB. Both scoring schemes choose the same optimal alignment that aligns RGD exactly; neither scheme offers an advantage.\n\nC. Under the identity scoring, the optimal alignment avoids gaps and misaligns RGD; under the BLOSUM-like scheme, the optimal alignment aligns RGD exactly even if it must introduce gaps. Thus, the BLOSUM-like scheme is more biologically relevant.\n\nD. Neither scheme can distinguish between RGD-aligned and RGD-misaligned alternatives because their scores tie under both schemes.", "solution": "The problem statement will first be subjected to rigorous validation.\n\n### Step 1: Extract Givens\n\nThe provided information is as follows:\n- **Sequence $X$**: $\\text{I L V I L V R G D I L}$ (length $N_X = 11$)\n- **Sequence $Y$**: $\\text{I I L V I L V A R G D}$ (length $N_Y = 11$)\n- **Algorithm**: Needleman–Wunsch global alignment with a linear gap model.\n- **Recurrence Relation**: $F(i,j) = \\max\\{ F(i-1,j-1) + s(x_i,y_j), F(i-1,j)+g, F(i,j-1)+g \\}$.\n- **Scoring System 1 (Identity)**:\n  - Substitution score: $s(a,b)=+1$ if $a=b$, $s(a,b)=-1$ if $a\\neq b$.\n  - Gap penalty: $g=-1$.\n- **Scoring System 2 (BLOSUM-like)**:\n  - Substitution score $s'(a,b)$:\n    - $s'(a,a)=+4$ (matches).\n    - $s'(\\mathrm{I},\\mathrm{L})=s'(\\mathrm{I},\\mathrm{V})=s'(\\mathrm{L},\\mathrm{V})=+3$ (and symmetric pairs).\n    - $s'(\\mathrm{R},\\mathrm{V})=-3$ (and symmetric).\n    - $s'(\\mathrm{D},\\mathrm{R})=-2$ (and symmetric).\n    - $s'(\\mathrm{L},\\mathrm{D})=-3$ (and symmetric).\n    - $s'(\\mathrm{G},\\mathrm{A})=0$ (and symmetric).\n    - $s'(\\mathrm{I},\\mathrm{G})=0$ (and symmetric).\n    - $s'(a,b)=-1$ for all other unspecified mismatches.\n  - Gap penalty: $g'=-6$.\n- **Alignment Competitors**:\n  1. **\"No-gap\" alignment**: A perfectly diagonal alignment without gaps.\n  2. **\"Motif-aligned\" alignment**: An alignment that introduces gaps to align the $\\text{RGD}$ motif of $X$ with the $\\text{RGD}$ motif of $Y$.\n- **Biological Context**: An alignment is considered \"biologically relevant\" if the $\\text{RGD}$ tripeptide is exactly conserved.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to validation against established principles.\n- **Scientifically Grounded**: The problem is a standard exercise in bioinformatics, concerning the fundamental Needleman-Wunsch algorithm for global sequence alignment. The scoring schemes, including a simplified identity matrix and a BLOSUM-like matrix, are standard tools. The $\\text{RGD}$ motif is a classic, well-documented example of a functionally constrained short linear motif. The problem is firmly based in established computational biology.\n- **Well-Posed**: The problem provides two specific sequences, two distinct and fully defined scoring systems, and two clearly described competing alignment structures. The task is to calculate and compare the scores for these alignments, which is a deterministic and well-defined mathematical procedure. A unique, meaningful answer can be derived.\n- **Objective**: The problem is stated using precise, objective language and quantitative data (sequences, scores). It does not contain subjective or opinion-based claims.\n\nThe problem exhibits no flaws such as scientific unsoundness, incompleteness, contradiction, or ambiguity. The sequences have the same length ($11$), which simplifies the \"no-gap\" case but requires careful construction of the \"motif-aligned\" case, as a shift must be accomplished by an equal number of insertions and deletions. This is a standard feature of global alignment problems.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. The solution will now proceed by calculating and comparing the scores of the two specified alignment structures under both scoring systems.\n\n### Solution Derivation\n\nThe task is to determine which of two alignment structures is preferred by each of the two scoring systems. We must first explicitly construct these two alignments.\n\n**Alignment 1: The \"No-gap\" Alignment**\nSince both sequences $X$ and $Y$ have length $11$, the no-gap global alignment is a direct, column-wise pairing of residues:\n$$\n\\begin{array}{lllllllllll}\nX: & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & \\text{R} & \\text{G} & \\text{D} & \\text{I} & \\text{L} \\\\\nY: & \\text{I} & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & \\text{A} & \\text{R} & \\text{G} & \\text{D}\n\\end{array}\n$$\n\n**Alignment 2: The \"Motif-aligned\" Alignment**\nThe motif $\\text{RGD}$ appears at indices $7-9$ in $X$ and $9-11$ in $Y$. To align them, a shift of $2$ positions is required. For a global alignment of two sequences of equal length, any insertions in one sequence must be balanced by an equal number of insertions in the other to maintain the global nature. The most straightforward way to achieve this shift is:\n$$\n\\begin{array}{lllllllllllll}\nX: & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & - & - & \\text{R} & \\text{G} & \\text{D} & \\text{I} & \\text{L} \\\\\nY: & \\text{I} & \\text{I} & \\text{L} & \\text{V} & \\text{I} & \\text{L} & \\text{V} & \\text{A} & \\text{R} & \\text{G} & \\text{D} & - & -\n\\end{array}\n$$\n\nWe now calculate the score for each alignment under both scoring systems.\n\n**Analysis with Identity Scoring ($s(a,b)=\\pm1, g=-1$)**\n\n- **Score for Alignment 1 (No-gap)**:\n  We count matches and mismatches. There is 1 match (I/I at position 1) and 10 mismatches.\n  - Score $= 1 \\times (+1) + 10 \\times (-1) = 1 - 10 = -9$.\n\n- **Score for Alignment 2 (Motif-aligned)**:\n  This alignment has 13 columns. We count matches, mismatches, and gaps.\n  - Matches: 4 pairs (I/I, R/R, G/G, D/D). Score contribution: $4 \\times (+1) = +4$.\n  - Mismatches: 5 pairs (L/I, V/L, I/V, L/I, V/L). Score contribution: $5 \\times (-1) = -5$.\n  - Gaps: 4 columns. Score contribution: $4 \\times (-1) = -4$.\n  - Total Score $= (+4) + (-5) + (-4) = -5$.\n\n- **Comparison**: Score(No-gap) = $-9$. Score(Motif-aligned) = $-5$.\n  Since $-5 > -9$, the identity scoring scheme prefers the motif-aligned structure.\n\n**Analysis with BLOSUM-like Scoring ($s'(a,b)$, $g'=-6$)**\n\n- **Score for Alignment 1 (No-gap)**:\n  We sum the scores for each aligned pair:\n  $s'(\\text{I},\\text{I})=+4$, $s'(\\text{L},\\text{I})=+3$, $s'(\\text{V},\\text{L})=+3$, $s'(\\text{I},\\text{V})=+3$, $s'(\\text{L},\\text{I})=+3$, $s'(\\text{V},\\text{L})=+3$, $s'(\\text{R},\\text{V})=-3$, $s'(\\text{G},\\text{A})=0$, $s'(\\text{D},\\text{R})=-2$, $s'(\\text{I},\\text{G})=0$, $s'(\\text{L},\\text{D})=-3$.\n  - Total Score $= (4+3+3+3+3+3) - 3 + 0 - 2 + 0 - 3 = 19 - 8 = +11$.\n\n- **Score for Alignment 2 (Motif-aligned)**:\n  This alignment contains substitution pairs and 4 gaps, with a severe gap penalty $g'=-6$.\n  - Substitution pairs score:\n    - Prefix: $s'(\\text{I},\\text{I}) + s'(\\text{L},\\text{I}) + s'(\\text{V},\\text{L}) + s'(\\text{I},\\text{V}) + s'(\\text{L},\\text{I}) + s'(\\text{V},\\text{L}) = 4+3+3+3+3+3 = +19$.\n    - Motif: $s'(\\text{R},\\text{R}) + s'(\\text{G},\\text{G}) + s'(\\text{D},\\text{D}) = 4+4+4 = +12$.\n    - Total from substitutions = $19 + 12 = +31$.\n  - Gap penalty for 4 gaps: $4 \\times g' = 4 \\times (-6) = -24$.\n  - Total Score = $31 - 24 = +7$.\n\n- **Comparison**: Score(No-gap) $=+11$. Score(Motif-aligned) $=+7$.\n  Since $+11 > +7$, the BLOSUM-like scheme prefers the no-gap alignment. The high penalty for gaps ($g'=-6$) makes it prohibitively expensive to introduce them, even to align the high-scoring RGD matches.\n\n### Conclusions and Option Evaluation\n\n- **Identity Scoring**: The motif-aligned structure (score $-5$) is preferred over the no-gap structure (score $-9$).\n- **BLOSUM-like Scoring**: The no-gap structure (score $+11$) is preferred over the motif-aligned structure (score $+7$).\n- **Biological Relevance**: The problem states that biological relevance requires the $\\text{RGD}$ motif to be aligned. Therefore, the identity scoring system produces the more biologically relevant alignment in this specific case, whereas the BLOSUM-like scheme with its high gap penalty fails to do so.\n\nWe now evaluate the given options based on this analysis.\n\n- **A.** \"Under the identity scoring, the optimal alignment introduces gaps to align RGD exactly and achieves a higher score than the best no-gap alignment; under the BLOSUM-like scheme with $g'=-6$, the optimal alignment avoids gaps, keeps the hydrophobic block aligned, and leaves RGD misaligned because this yields a higher score. Thus, the identity-scored alignment is more biologically relevant.\"\n  This statement is entirely consistent with our findings. The first part is correct (motif-aligned preferred by identity scoring). The second part is correct (no-gap preferred by BLOSUM-like scoring). The conclusion about biological relevance is also correct based on the problem's definition. This option is **Correct**.\n\n- **B.** \"Both scoring schemes choose the same optimal alignment that aligns RGD exactly; neither scheme offers an advantage.\"\n  This is false. The two schemes prefer different alignment structures. This option is **Incorrect**.\n\n- **C.** \"Under the identity scoring, the optimal alignment avoids gaps and misaligns RGD; under the BLOSUM-like scheme, the optimal alignment aligns RGD exactly even if it must introduce gaps. Thus, the BLOSUM-like scheme is more biologically relevant.\"\n  This statement is the exact opposite of our findings for both scoring systems. This option is **Incorrect**.\n\n- **D.** \"Neither scheme can distinguish between RGD-aligned and RGD-misaligned alternatives because their scores tie under both schemes.\"\n  The scores are not tied in either case ($-5 \\neq -9$ and $+7 \\neq +11$). This option is **Incorrect**.\n\nThe only correct statement is A.", "answer": "$$\\boxed{A}$$", "id": "2395031"}, {"introduction": "Moving from theory to practice, this exercise guides you through a full implementation of the global alignment algorithm with an affine gap penalty, a model that more realistically penalizes the creation of new gaps versus extending existing ones. Beyond just finding the highest score, you will learn a fundamental method for evaluating its biological relevance. By comparing your alignment score to a background distribution of scores from shuffled sequences, you will compute a Z-score to determine if the alignment is statistically significant or merely a result of random chance [@problem_id:2395091].", "problem": "You are given two finite strings $s$ and $t$ over the deoxyribonucleic acid (DNA) alphabet $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$. An alignment of $s$ and $t$ is obtained by inserting the gap symbol $-$ into $s$ and $t$ (without reordering the original symbols) so that the resulting strings $\\hat{s}$ and $\\hat{t}$ have equal length $L$, and for each $k\\in\\{1,\\dots,L\\}$ at least one of $\\hat{s}_k$ or $\\hat{t}_k$ is in $\\Sigma$. The score of an alignment is defined as the sum of a substitution score and an affine gap penalty. The substitution score is given by a function $\\sigma:\\Sigma\\times\\Sigma\\to\\mathbb{R}$ defined by $\\sigma(x,y)=m$ if $x=y$ and $\\sigma(x,y)=u$ if $x\\neq y$. The affine gap penalty is defined so that each maximal contiguous run of $l\\in\\mathbb{N}$ gaps in either $\\hat{s}$ or $\\hat{t}$ contributes a penalty $g_{\\text{open}}+g_{\\text{extend}}\\cdot l$. The total alignment score is the sum of the substitution scores over all positions where both $\\hat{s}_k,\\hat{t}_k\\in\\Sigma$ plus the sum of the penalties over all gap runs. The optimal global alignment score $S^\\star(s,t)$ is the maximum of the alignment score over all alignments of $s$ and $t$.\n\nFor a fixed pair $(s,t)$, define the following randomized analysis. Fix a positive integer $K$ and a nonnegative integer seed $z$. Consider $K$ independent random strings $t^{(1)},\\dots,t^{(K)}$ obtained by applying a uniformly random permutation to the multiset of characters of $t$ for each replicate, using a pseudorandom generator initialized deterministically by $z$ to ensure reproducibility. For each $k\\in\\{1,\\dots,K\\}$, compute the optimal global alignment score $S^\\star\\!\\left(s,t^{(k)}\\right)$. Let $\\mu$ denote the arithmetic mean\n$$\n\\mu=\\frac{1}{K}\\sum_{k=1}^{K} S^\\star\\!\\left(s,t^{(k)}\\right),\n$$\nand let the population standard deviation be\n$$\n\\sigma_{\\text{pop}}=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\left(S^\\star\\!\\left(s,t^{(k)}\\right)-\\mu\\right)^2}.\n$$\nDefine the Z-score of the original pair as\n$$\nZ=\\begin{cases}\n\\dfrac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}, & \\text{if }\\sigma_{\\text{pop}}>0,\\\\\n0, & \\text{if }\\sigma_{\\text{pop}}=0.\n\\end{cases}\n$$\n\nYour task is to write a complete program that, for each specified test case below, computes the quadruple $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$ according to the definitions above, using the exact parameters provided. For every test, use the same scoring scheme with $m=2$, $u=-1$, $g_{\\text{open}}=-2$, and $g_{\\text{extend}}=-1$. For each test, use the specified $K$ and seed $z$ to generate the $K$ shuffled replicas of $t$.\n\nTest suite:\n- Case $1$: $s=\\text{\"ACGTCG\"}$, $t=\\text{\"ACTCG\"}$, $K=200$, $z=314159$.\n- Case $2$: $s=\\text{\"AAAAAA\"}$, $t=\\text{\"AAA\"}$, $K=200$, $z=271828$.\n- Case $3$: $s=\\text{\"GATTACA\"}$, $t=\\text{\"GATTACA\"}$, $K=200$, $z=161803$.\n- Case $4$: $s=\\text{\"\"}$ (the empty string), $t=\\text{\"ACGT\"}$, $K=200$, $z=42$.\n\nAnswer specification:\n- For each case, compute $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$ as real numbers.\n- Round each real number to $6$ decimal places using standard rounding.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list of lists, one sublist per test case, each sublist in the order $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$, enclosed in square brackets. For example, a valid output format is $\\left[[a_1,a_2,a_3,a_4],[b_1,b_2,b_3,b_4],\\dots\\right]$ with no extra text.", "solution": "The problem statement is subjected to validation.\n\n### Step 1: Extract Givens\n\n- **Strings**: Two finite strings, $s$ and $t$, over the alphabet $\\Sigma=\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$.\n- **Alignment Definition**: Insertion of gap symbols ($-$) into $s$ and $t$ to form $\\hat{s}$ and $\\hat{t}$ of equal length $L$, such that for any position $k$, at least one of $\\hat{s}_k$ or $\\hat{t}_k$ is not a gap.\n- **Scoring Scheme**:\n    - **Substitution Score**: $\\sigma(x,y)=m$ if $x=y$ and $\\sigma(x,y)=u$ if $x \\neq y$.\n    - **Affine Gap Penalty**: A maximal run of $l$ gaps incurs a penalty of $g_{\\text{open}}+g_{\\text{extend}}\\cdot l$.\n    - **Total Score**: Sum of substitution scores and gap penalties.\n- **Optimal Score**: $S^\\star(s,t)$ is the maximum possible alignment score.\n- **Randomized Analysis**:\n    - A fixed positive integer $K$ and a non-negative integer seed $z$.\n    - $K$ random strings $t^{(k)}$ are generated by applying a uniformly random permutation to the characters of $t$.\n    - **Mean Score**: $\\mu=\\frac{1}{K}\\sum_{k=1}^{K} S^\\star\\!\\left(s,t^{(k)}\\right)$.\n    - **Population Standard Deviation**: $\\sigma_{\\text{pop}}=\\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}\\left(S^\\star\\!\\left(s,t^{(k)}\\right)-\\mu\\right)^2}$.\n    - **Z-score**: $Z=\\frac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}$ if $\\sigma_{\\text{pop}}>0$, and $Z=0$ if $\\sigma_{\\text{pop}}=0$.\n- **Task Parameters**:\n    - **Scoring Constants**: $m=2$, $u=-1$, $g_{\\text{open}}=-2$, $g_{\\text{extend}}=-1$.\n- **Test Suite**:\n    - Case $1$: $s=\\text{\"ACGTCG\"}$, $t=\\text{\"ACTCG\"}$, $K=200$, $z=314159$.\n    - Case $2$: $s=\\text{\"AAAAAA\"}$, $t=\\text{\"AAA\"}$, $K=200$, $z=271828$.\n    - Case $3$: $s=\\text{\"GATTACA\"}$, $t=\\text{\"GATTACA\"}$, $K=200$, $z=161803$.\n    - Case $4$: $s=\\text{\"\"}$, $t=\\text{\"ACGT\"}$, $K=200$, $z=42$.\n- **Output Specification**: For each test case, compute the quadruple $\\left[S^\\star(s,t),\\mu,\\sigma_{\\text{pop}},Z\\right]$, with each value rounded to $6$ decimal places.\n\n### Step 2: Validate Using Extracted Givens\n\n- **Scientifically Grounded**: The problem describes the computation of an optimal global alignment score using an affine gap penalty model. This is a standard and fundamental problem in bioinformatics, solved using a well-established dynamic programming algorithm, a variant of the Needleman-Wunsch algorithm. The subsequent statistical analysis using a Z-score calculated against a background distribution of shuffled sequences is a standard method for assessing the biological significance of an alignment. The problem is scientifically sound.\n- **Well-Posed**: The problem is well-posed. The dynamic programming algorithm for affine gap penalties provides a unique optimal score. The use of a deterministic pseudorandom generator initialized with a specific seed ensures that the generation of shuffled sequences is reproducible, leading to a unique set of values for $\\mu$, $\\sigma_{\\text{pop}}$, and $Z$.\n- **Objective**: The problem is defined with mathematical and algorithmic precision. All terms are clearly defined, and all parameters are provided. There is no subjectivity or ambiguity.\n- **Completeness and Consistency**: The problem is self-contained. All necessary data, including the strings, scoring parameters ($m, u, g_{\\text{open}}, g_{\\text{extend}}$), and statistical parameters ($K, z$), are provided for each test case. There are no contradictions.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is scientifically grounded, well-posed, objective, and complete. A definitive solution can be computed.\n\n---\n\n### Solution\n\nThe solution to this problem requires two components: firstly, an algorithm to compute the optimal global alignment score between two sequences with an affine gap penalty, and secondly, a statistical framework to assess the significance of this score.\n\n**1. Optimal Global Alignment with Affine Gap Penalty**\n\nThe calculation of the optimal alignment score $S^\\star(s,t)$ is a classic dynamic programming problem. An affine gap penalty, which distinguishes between opening a gap ($g_{\\text{open}}$) and extending one ($g_{\\text{extend}}$), requires a more complex state space than the simpler linear gap penalty model. We use three dynamic programming matrices, $M$, $I_x$, and $I_y$, of size $(|s|+1) \\times (|t|+1)$. Let $s_i$ be the $i$-th character of $s$ and $t_j$ be the $j$-th character of $t$.\n\nThe matrices are defined as follows for $i \\in \\{1,\\dots,|s|\\}$ and $j \\in \\{1,\\dots,|t|\\}$:\n- $M(i,j)$: The score of the best alignment of the prefixes $s[1..i]$ and $t[1..j]$ where $s_i$ is aligned with $t_j$.\n- $I_x(i,j)$: The score of the best alignment of $s[1..i]$ and $t[1..j]$ where $s_i$ is aligned with a gap.\n- $I_y(i,j)$: The score of the best alignment of $s[1..i]$ and $t[1..j]$ where $t_j$ is aligned with a gap.\n\nThese matrices are populated using the following recurrence relations:\n\n$$\nM(i,j) = \\sigma(s_i, t_j) + \\max \\begin{cases} M(i-1, j-1) \\\\ I_x(i-1, j-1) \\\\ I_y(i-1, j-1) \\end{cases}\n$$\nThis recurrence states that aligning characters $s_i$ and $t_j$ (with score $\\sigma(s_i, t_j)$) can follow an alignment ending in a match/mismatch ($M$), a gap in $t$ ($I_x$), or a gap in $s$ ($I_y$).\n\n$$\nI_x(i,j) = \\max \\begin{cases} M(i-1, j) + g_{\\text{open}} + g_{\\text{extend}} & \\text{(open gap in } t \\text{)} \\\\ I_x(i-1, j) + g_{\\text{extend}} & \\text{(extend gap in } t \\text{)} \\end{cases}\n$$\nThis captures the score of aligning $s_i$ with a gap. This state can be reached either by opening a new gap in $t$ (from an alignment ending in a match/mismatch) or by extending an existing gap in $t$.\n\n$$\nI_y(i,j) = \\max \\begin{cases} M(i, j-1) + g_{\\text{open}} + g_{\\text{extend}} & \\text{(open gap in } s \\text{)} \\\\ I_y(i, j-1) + g_{\\text{extend}} & \\text{(extend gap in } s \\text{)} \\end{cases}\n$$\nThis is symmetric to $I_x(i,j)$ and represents the score of aligning $t_j$ with a gap.\n\nThe initialization conditions for the matrices are crucial:\n- Base case: $M(0,0)=0$. All other entries in the $0$-th row and $0$-th column of $M$ are set to $-\\infty$ to forbid alignments starting with a match/mismatch.\n- Initial gaps: Aligning a prefix of a string with an empty string.\n  - $I_x(i,0) = g_{\\text{open}} + i \\cdot g_{\\text{extend}}$ for $i > 0$. Other $I_x(i,j)$ for $i=0$ or $j=0$ are $-\\infty$.\n  - $I_y(0,j) = g_{\\text{open}} + j \\cdot g_{\\text{extend}}$ for $j > 0$. Other $I_y(i,j)$ for $i=0$ or $j=0$ are $-\\infty$.\n\nAfter filling the matrices, the optimal global alignment score for strings $s$ and $t$ of lengths $n = |s|$ and $m = |t|$ is the maximum of the three possible final states:\n\n$$\nS^\\star(s,t) = \\max \\{ M(n,m), I_x(n,m), I_y(n,m) \\}\n$$\n\nThe provided parameters are $m=2$, $u=-1$, $g_{\\text{open}}=-2$, and $g_{\\text{extend}}=-1$.\n\n**2. Statistical Significance Analysis**\n\nTo assess if the score $S^\\star(s,t)$ is significantly high, it is compared against a background distribution of scores from alignments of $s$ with random sequences. The random sequences, $t^{(k)}$ for $k=1,\\dots,K$, are generated by randomly permuting the characters of the original string $t$. This preserves the length and character composition of $t$, which are important determinants of alignment scores. Using a fixed seed $z$ for the pseudorandom number generator ensures that this process is deterministic and reproducible.\n\nFor each of the $K$ shuffled strings $t^{(k)}$, we compute the optimal alignment score $S^\\star(s,t^{(k)})$ using the same algorithm described above. From this collection of $K$ scores, we calculate two statistics:\n\n- The arithmetic mean: $\\mu = \\frac{1}{K}\\sum_{k=1}^{K} S^\\star(s,t^{(k)})$.\n- The population standard deviation: $\\sigma_{\\text{pop}} = \\sqrt{\\frac{1}{K}\\sum_{k=1}^{K}(S^\\star(s,t^{(k)}) - \\mu)^2}$.\n\nFinally, the Z-score $Z$ is computed. It measures how many standard deviations the original score $S^\\star(s,t)$ is from the mean of the scores of the shuffled sequences.\n\n$$\nZ=\\begin{cases}\n\\dfrac{S^\\star(s,t)-\\mu}{\\sigma_{\\text{pop}}}, & \\text{if }\\sigma_{\\text{pop}} > 0, \\\\\n0, & \\text{if }\\sigma_{\\text{pop}} = 0.\n\\end{cases}\n$$\nThe case $\\sigma_{\\text{pop}}=0$ occurs when all shuffled sequences produce the exact same alignment score, making a standard deviation-based comparison trivial.\n\nThe program will implement the dynamic programming algorithm in a function. This function will be called once for the original pair $(s,t)$ and then $K$ times for the pairs $(s, t^{(k)})$. The results will be collected to compute the final quadruple $[\\![S^\\star(s,t), \\mu, \\sigma_{\\text{pop}}, Z]\\!]$, with each element rounded to $6$ decimal places.", "answer": "```python\nimport numpy as np\n\ndef compute_optimal_score(s: str, t: str, match: float, mismatch: float, gap_open: float, gap_extend: float) -> float:\n    \"\"\"\n    Computes the optimal global alignment score with affine gap penalties.\n    \"\"\"\n    n = len(s)\n    m = len(t)\n    \n    if n == 0 and m == 0:\n        return 0.0\n    if n == 0:\n        return gap_open + m * gap_extend\n    if m == 0:\n        return gap_open + n * gap_extend\n\n    neg_inf = -np.inf\n\n    # Initialization of DP matrices\n    M = np.full((n + 1, m + 1), neg_inf, dtype=float)\n    Ix = np.full((n + 1, m + 1), neg_inf, dtype=float)\n    Iy = np.full((n + 1, m + 1), neg_inf, dtype=float)\n\n    M[0, 0] = 0.0\n\n    for i in range(1, n + 1):\n        Ix[i, 0] = gap_open + i * gap_extend\n    for j in range(1, m + 1):\n        Iy[0, j] = gap_open + j * gap_extend\n\n    # Fill DP matrices\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            # Substitution score\n            sub_score = match if s[i-1] == t[j-1] else mismatch\n            \n            # M(i,j) - alignment ends with s[i-1] vs t[j-1]\n            prev_m = M[i-1, j-1]\n            prev_ix = Ix[i-1, j-1]\n            prev_iy = Iy[i-1, j-1]\n            M[i, j] = sub_score + max(prev_m, prev_ix, prev_iy)\n\n            # Ix(i,j) - alignment ends with s[i-1] vs gap\n            open_gap_x = M[i-1, j] + gap_open + gap_extend\n            extend_gap_x = Ix[i-1, j] + gap_extend\n            Ix[i, j] = max(open_gap_x, extend_gap_x)\n            \n            # Iy(i,j) - alignment ends with gap vs t[j-1]\n            open_gap_y = M[i, j-1] + gap_open + gap_extend\n            extend_gap_y = Iy[i, j-1] + gap_extend\n            Iy[i, j] = max(open_gap_y, extend_gap_y)\n\n    # Final score is the max of the three states at the bottom-right corner\n    final_score = max(M[n, m], Ix[n, m], Iy[n, m])\n    return final_score\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\"s\": \"ACGTCG\", \"t\": \"ACTCG\", \"K\": 200, \"z\": 314159},\n        {\"s\": \"AAAAAA\", \"t\": \"AAA\", \"K\": 200, \"z\": 271828},\n        {\"s\": \"GATTACA\", \"t\": \"GATTACA\", \"K\": 200, \"z\": 161803},\n        {\"s\": \"\", \"t\": \"ACGT\", \"K\": 200, \"z\": 42},\n    ]\n\n    # Scoring parameters\n    m_score = 2.0\n    u_score = -1.0\n    g_open = -2.0\n    g_extend = -1.0\n    \n    all_results = []\n\n    for case in test_cases:\n        s, t, K, z = case[\"s\"], case[\"t\"], case[\"K\"], case[\"z\"]\n\n        # 1. Compute score for the original pair (s, t)\n        original_score = compute_optimal_score(s, t, m_score, u_score, g_open, g_extend)\n\n        # 2. Generate K shuffled sequences and compute their scores\n        rng = np.random.default_rng(z)\n        t_chars = list(t)\n        shuffled_scores = []\n        if len(t_chars) > 0:\n            for _ in range(K):\n                shuffled_t_chars = rng.permutation(t_chars)\n                shuffled_t = \"\".join(shuffled_t_chars)\n                score = compute_optimal_score(s, shuffled_t, m_score, u_score, g_open, g_extend)\n                shuffled_scores.append(score)\n        else: # If t is empty, all \"shuffled\" versions are also empty\n             shuffled_scores = [original_score] * K\n\n\n        shuffled_scores = np.array(shuffled_scores)\n\n        # 3. Compute statistics\n        mu = np.mean(shuffled_scores)\n        sigma_pop = np.std(shuffled_scores, ddof=0) # Population standard deviation\n\n        # 4. Compute Z-score\n        if sigma_pop > 0:\n            z_score = (original_score - mu) / sigma_pop\n        else:\n            z_score = 0.0\n\n        # 5. Round results and append\n        rounded_results = [\n            round(original_score, 6),\n            round(mu, 6),\n            round(sigma_pop, 6),\n            round(z_score, 6)\n        ]\n        all_results.append(rounded_results)\n\n    # Format and print the final output\n    # e.g., [[-1.23, 2.34, 3.45, 4.56],[...]]\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2395091"}, {"introduction": "While the classic Needleman–Wunsch algorithm guarantees an optimal solution, its quadratic memory requirement, $O(nm)$, can be prohibitive for aligning long genomic sequences. This final practice tackles this real-world computational challenge. You will implement a space-efficient version of the algorithm that calculates the optimal alignment score using only linear memory, $O(n+m)$, highlighting a key principle in algorithm design for large-scale data analysis [@problem_id:2395082].", "problem": "You are given pairs of finite sequences over a finite alphabet and integer scoring parameters for global alignment. For two sequences $X = x_1 x_2 \\dots x_n$ and $Y = y_1 y_2 \\dots y_m$, an alignment is any pair of sequences $(A,B)$ obtained by inserting gap symbols $-$ into $X$ and $Y$ (possibly zero insertions) so that $A$ and $B$ have equal length $L \\ge \\max(n,m)$, the relative order of the non-gap symbols is preserved, and every symbol of $X$ and $Y$ appears exactly once in $A$ and $B$ respectively. The score of an alignment $(A,B)$, given a match reward $a \\in \\mathbb{Z}$, a mismatch penalty $b \\in \\mathbb{Z}$, and a gap penalty $g \\in \\mathbb{Z}$, is defined as\n$$\n\\sum_{k=1}^{L} s(A_k, B_k),\n$$\nwhere\n$$\ns(u,v) =\n\\begin{cases}\na & \\text{if } u = v \\text{ and } u \\neq -, \\\\\nb & \\text{if } u \\neq v \\text{ and } u \\neq - \\text{ and } v \\neq -, \\\\\ng & \\text{if } u = - \\text{ or } v = -.\n\\end{cases}\n$$\nThe optimal global alignment score is the maximum of this sum over all valid alignments $(A,B)$ of $X$ and $Y$.\n\nFor each test instance below, determine two quantities: $S_{\\text{quad}}$, the optimal global alignment score computed by a method that stores all subproblem values, and $S_{\\text{lin}}$, the score of an optimal alignment that can be constructed while using memory proportional to $n + m$. Your program must compute both quantities for each instance and verify that $S_{\\text{quad}} = S_{\\text{lin}}$.\n\nTest suite:\n- Instance $1$: $X = \\text{\"GATTACA\"}$, $Y = \\text{\"GCATGCU\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $2$: $X = \\text{\"\"}$, $Y = \\text{\"ACGT\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $3$: $X = \\text{\"\"}$, $Y = \\text{\"\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $4$: $X = \\text{\"AAAA\"}$, $Y = \\text{\"TTTT\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $5$: $X = \\text{\"AGT\"}$, $Y = \\text{\"GTT\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $6$: $X = \\text{\"AGCT\"}$, $Y = \\text{\"AGTT\"}$, $a = +3$, $b = -2$, $g = -4$.\n- Instance $7$: $X = \\text{\"AAAAAA\"}$, $Y = \\text{\"AAA\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $8$: $X = \\text{\"C\"}$, $Y = \\text{\"C\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $9$: $X = \\text{\"C\"}$, $Y = \\text{\"A\"}$, $a = +2$, $b = -1$, $g = -2$.\n- Instance $10$: $X = \\text{\"ACGT\"}$, $Y = \\text{\"ACGT\"}$, $a = +1$, $b = -1$, $g = -1$.\n\nAnswer specification:\n- For each instance $i$, output a boolean $B_i$ that is $\\text{True}$ if and only if $S_{\\text{quad}} = S_{\\text{lin}}$, and $\\text{False}$ otherwise.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the instances above, for example: \"[True,False,True]\".\n- No physical quantities are present; therefore, no physical units are required. All outputs must be booleans as specified.\n\nThe program must be self-contained and must not read any input. It must compute $S_{\\text{quad}}$ and $S_{\\text{lin}}$ from first principles for the instances listed above and produce the specified output format on a single line.", "solution": "The problem presented is a standard exercise in computational biology, specifically in sequence alignment. It requires the computation of the optimal global alignment score for given pairs of sequences using specified scoring parameters. The core of the task is to compute this score via two distinct algorithmic approaches: one that uses memory quadratic in the lengths of the sequences, and another that uses memory linear in their lengths. Finally, it requires a verification that the scores produced by both methods are identical.\n\nThe problem is well-defined, scientifically sound, and computationally feasible. All necessary data and parameters are provided. It does not violate any principles of mathematics or computer science. Therefore, the problem is valid, and we shall proceed with a formal solution.\n\nThe fundamental principle underlying the calculation of the optimal alignment score is dynamic programming. Let the two sequences be $X = x_1 x_2 \\dots x_n$ of length $n$ and $Y = y_1 y_2 \\dots y_m$ of length $m$. Let the scoring parameters be $a$ for a match, $b$ for a mismatch, and $g$ for a gap. We define $F(i, j)$ as the optimal score for the global alignment of the prefixes $X[1 \\dots i]$ and $Y[1 \\dots j]$.\n\nThe score $F(i,j)$ can be computed by considering the three possible ways the alignment of these prefixes can end:\n$1$. $x_i$ is aligned with $y_j$. The score is $F(i-1, j-1) + s(x_i, y_j)$, where $s(x_i, y_j) = a$ if $x_i = y_j$ and $s(x_i, y_j) = b$ if $x_i \\neq y_j$.\n$2$. $x_i$ is aligned with a gap. The score is $F(i-1, j) + g$.\n$3$. $y_j$ is aligned with a gap. The score is $F(i, j-1) + g$.\n\nThe optimal score $F(i,j)$ is the maximum of these three possibilities. This gives the following recurrence relation:\n$$\nF(i, j) = \\max \\begin{cases} F(i-1, j-1) + s(x_i, y_j) \\\\ F(i, j-1) + g \\\\ F(i-1, j) + g \\end{cases}\n$$\nThe base cases for the recurrence are derived from aligning a prefix with an empty sequence, which consists entirely of gaps:\n$$\nF(i, 0) = i \\cdot g \\quad \\text{for } i \\in [0, n]\n$$\n$$\nF(0, j) = j \\cdot g \\quad \\text{for } j \\in [0, m]\n$$\nNote that $F(0,0) = 0$.\n\nThe problem asks for two quantities, $S_{\\text{quad}}$ and $S_{\\text{lin}}$, which we will now address.\n\n**1. The Quadratic-Space Score, $S_{\\text{quad}}$**\n\nThis score is computed using the standard Needleman–Wunsch algorithm, which directly implements the dynamic programming recurrence described above. It requires the construction of a two-dimensional matrix, or table, of size $(n+1) \\times (m+1)$ to store all subproblem solutions $F(i, j)$ for $i \\in [0, n]$ and $j \\in [0, m]$.\n\nThe algorithm proceeds by filling this table, typically row by row or column by column, starting from the base cases at $F(0,0)$. The final optimal score for the alignment of the complete sequences $X$ and $Y$ is found in the last cell of the table, $F(n,m)$.\n$$\nS_{\\text{quad}} = F(n,m)\n$$\nThe space complexity of this method is determined by the size of the storage matrix, which is $O(nm)$. This is quadratic in the lengths of the sequences.\n\n**2. The Linear-Space Score, $S_{\\text{lin}}$**\n\nThe problem asks for $S_{\\text{lin}}$, the score of an optimal alignment constructed using memory proportional to $n+m$. This refers to space-efficient variants of the dynamic programming algorithm. Inspection of the recurrence relation reveals that the computation of any cell $F(i, j)$ only depends on values in the same row, $F(i, j-1)$, and the preceding row, $F(i-1, \\cdot)$. Specifically, it depends on $F(i-1, j)$ and $F(i-1, j-1)$.\n\nThis dependency structure means that to compute row $i$ of the dynamic programming table, one only needs to have access to row $i-1$. It is not necessary to store all $O(nm)$ subproblem solutions simultaneously. We can maintain two arrays of size $O(m)$ (or $O(\\min(n,m))$ if we orient the computation along the shorter sequence length): one for the previous row's scores and one for the current row's scores being computed.\n\nLet `prev_row` store the scores $F(i-1, j)$ for $j \\in [0, m]$ and `curr_row` store the scores $F(i, j)$ for $j \\in [0, m]$. The computation for `curr_row[j]` uses `prev_row[j-1]`, `prev_row[j]`, and `curr_row[j-1]`. After `curr_row` is fully computed for a given $i$, it becomes the `prev_row` for the next iteration, $i+1$.\n\nThis procedure computes exactly the same values for the final row of the table as the quadratic-space method, but the memory requirement is reduced to $O(m) + O(m)$, which is $O(m)$. Since the input sequences of length $n$ and $m$ must also be stored, the total memory is proportional to $n+m$. The final score, $S_{\\text{lin}}$, is the last value computed for the last row, which corresponds to $F(n,m)$.\n\n**3. Equivalence**\n\nThe linear-space algorithm for finding the score is a direct optimization of the quadratic-space algorithm. It solves the identical recurrence relation and arrives at the same numerical result for $F(n,m)$. It merely discards intermediate values that are no longer needed, to save space. Full alignment reconstruction in linear space is more complex (requiring a divide-and-conquer approach, as in Hirschberg's algorithm), but the optimal *score* is the same. Therefore, it is a mathematical necessity that $S_{\\text{quad}} = S_{\\text{lin}}$. The programmatic task is to implement both methods correctly and verify this identity for the given test cases. Any result of `False` would indicate a flawed implementation, not a theoretical difference.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the global alignment problem for a suite of test cases.\n    For each case, it computes the optimal score using both a quadratic-space\n    and a linear-space dynamic programming algorithm, then verifies that\n    the scores are identical.\n    \"\"\"\n    \n    test_cases = [\n        # Instance 1\n        {\"X\": \"GATTACA\", \"Y\": \"GCATGCU\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 2\n        {\"X\": \"\", \"Y\": \"ACGT\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 3\n        {\"X\": \"\", \"Y\": \"\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 4\n        {\"X\": \"AAAA\", \"Y\": \"TTTT\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 5\n        {\"X\": \"AGT\", \"Y\": \"GTT\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 6\n        {\"X\": \"AGCT\", \"Y\": \"AGTT\", \"a\": 3, \"b\": -2, \"g\": -4},\n        # Instance 7\n        {\"X\": \"AAAAAA\", \"Y\": \"AAA\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 8\n        {\"X\": \"C\", \"Y\": \"C\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 9\n        {\"X\": \"C\", \"Y\": \"A\", \"a\": 2, \"b\": -1, \"g\": -2},\n        # Instance 10\n        {\"X\": \"ACGT\", \"Y\": \"ACGT\", \"a\": 1, \"b\": -1, \"g\": -1}\n    ]\n\n    def get_s_quad(X, Y, a, b, g):\n        \"\"\"\n        Computes the optimal global alignment score using O(nm) space.\n        \"\"\"\n        n = len(X)\n        m = len(Y)\n        \n        # F is the dynamic programming table\n        F = np.zeros((n + 1, m + 1), dtype=int)\n        \n        # Initialize base cases\n        for i in range(n + 1):\n            F[i, 0] = i * g\n        for j in range(m + 1):\n            F[0, j] = j * g\n            \n        # Fill the table using the recurrence relation\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                match_mismatch_score = a if X[i-1] == Y[j-1] else b\n                \n                score_diag = F[i-1, j-1] + match_mismatch_score\n                score_up = F[i-1, j] + g\n                score_left = F[i, j-1] + g\n                \n                F[i, j] = max(score_diag, score_up, score_left)\n                \n        return F[n, m]\n\n    def get_s_lin(X, Y, a, b, g):\n        \"\"\"\n        Computes the optimal global alignment score using O(min(n, m)) space.\n        \"\"\"\n        # Ensure Y is the shorter sequence to optimize space\n        if len(X) < len(Y):\n            X, Y = Y, X\n            \n        n = len(X)\n        m = len(Y)\n        \n        if m == 0:\n            return n * g\n        \n        # prev_row stores scores from row i-1, curr_row stores scores for row i\n        prev_row = np.zeros(m + 1, dtype=int)\n        curr_row = np.zeros(m + 1, dtype=int)\n        \n        # Initialize first row (corresponds to i=0)\n        for j in range(m + 1):\n            prev_row[j] = j * g\n            \n        # Iterate through rows of the conceptual DP table\n        for i in range(1, n + 1):\n            # Base case for the current row (j=0)\n            curr_row[0] = i * g\n            \n            # Fill the rest of the current row\n            for j in range(1, m + 1):\n                match_mismatch_score = a if X[i-1] == Y[j-1] else b\n                \n                score_diag = prev_row[j-1] + match_mismatch_score\n                score_up = prev_row[j] + g\n                score_left = curr_row[j-1] + g\n                \n                curr_row[j] = max(score_diag, score_up, score_left)\n            \n            # Current row becomes previous row for the next iteration\n            prev_row[:] = curr_row\n            \n        return curr_row[m]\n\n    results = []\n    for case in test_cases:\n        s_quad = get_s_quad(case[\"X\"], case[\"Y\"], case[\"a\"], case[\"b\"], case[\"g\"])\n        s_lin = get_s_lin(case[\"X\"], case[\"Y\"], case[\"a\"], case[\"b\"], case[\"g\"])\n        \n        # Verification: both methods must yield the same optimal score.\n        results.append(s_quad == s_lin)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2395082"}]}