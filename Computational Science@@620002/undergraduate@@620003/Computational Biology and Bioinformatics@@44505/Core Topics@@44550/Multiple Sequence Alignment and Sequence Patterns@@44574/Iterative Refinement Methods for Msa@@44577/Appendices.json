{"hands_on_practices": [{"introduction": "Iterative refinement algorithms work by making changes to a multiple sequence alignment (MSA) and only keeping changes that \"improve\" it. This requires a quantitative objective function to measure alignment quality. While Sum-of-Pairs (SP) scores are common, this exercise explores an alternative based on information theory, using Shannon entropy to measure the conservation of an alignment column [@problem_id:2400615]. By calculating the change in this entropy-based score, you will gain hands-on practice with the fundamental concept of an objective function, which is the compass that guides the entire refinement process.", "problem": "A refinement step in Multiple Sequence Alignment (MSA) iterative refinement replaces the usual substitution-matrix column score with a column-wise Shannon entropy objective. For a column $c$, let the empirical distribution of symbols be $\\{p_{x}(c)\\}_{x \\in \\{A,C,G,T\\}}$, computed from counts in that column divided by the number of sequences. Define the column entropy by\n$$H(c) = -\\sum_{x \\in \\{A,C,G,T\\}} p_{x}(c)\\,\\log_{2}\\!\\big(p_{x}(c)\\big),$$\nwith the convention that terms with $p_{x}(c)=0$ contribute $0$ (i.e., $\\lim_{p \\to 0^{+}} p \\log_{2} p = 0$). The global objective for an alignment is the sum of column entropies,\n$$J = \\sum_{c} H(c),$$\nmeasured in bits.\n\nConsider an alignment of $10$ sequences across $3$ columns before and after a single refinement move. The symbol counts in each column are:\n\nBefore refinement:\n- Column $1$: $(A{:}\\,7,\\;C{:}\\,3,\\;G{:}\\,0,\\;T{:}\\,0)$\n- Column $2$: $(A{:}\\,4,\\;C{:}\\,4,\\;G{:}\\,2,\\;T{:}\\,0)$\n- Column $3$: $(A{:}\\,5,\\;C{:}\\,0,\\;G{:}\\,5,\\;T{:}\\,0)$\n\nAfter refinement:\n- Column $1'$: $(A{:}\\,10,\\;C{:}\\,0,\\;G{:}\\,0,\\;T{:}\\,0)$\n- Column $2'$: $(A{:}\\,3,\\;C{:}\\,3,\\;G{:}\\,4,\\;T{:}\\,0)$\n- Column $3'$: $(A{:}\\,3,\\;C{:}\\,2,\\;G{:}\\,5,\\;T{:}\\,0)$\n\nCompute the net change in the entropy-based objective,\n$$\\Delta J \\equiv J_{\\text{after}} - J_{\\text{before}},$$\nand express your final numerical answer in bits. Round your answer to four significant figures.", "solution": "The problem requires the computation of the net change in the Shannon entropy-based objective function for a Multiple Sequence Alignment (MSA) after a single refinement move. The objective function, $J$, is the sum of the entropies of each column in the alignment.\n\nThe Shannon entropy for a column $c$ is defined as:\n$$H(c) = -\\sum_{x \\in \\{A,C,G,T\\}} p_{x}(c)\\,\\log_{2}\\!\\left(p_{x}(c)\\right)$$\nwhere $p_{x}(c)$ is the empirical frequency of symbol $x$ in column $c$. The frequencies are calculated from the given symbol counts and the total number of sequences, which is $N=10$. For a symbol with count $n_x$ in a column, the frequency is $p_x(c) = \\frac{n_x}{N}$. The convention $0 \\log_2 0 = 0$ is applied.\n\nThe total objective function is the sum over all columns:\n$$J = \\sum_{c} H(c)$$\nWe must compute the objectives before and after the refinement, denoted $J_{\\text{before}}$ and $J_{\\text{after}}$, respectively, and then find their difference, $\\Delta J = J_{\\text{after}} - J_{\\text{before}}$.\n\nFirst, we calculate the objective function before refinement, $J_{\\text{before}}$.\nThe alignment consists of $3$ columns.\n\nFor Column $1$ with counts $(A{:}\\,7,\\;C{:}\\,3,\\;G{:}\\,0,\\;T{:}\\,0)$:\nThe frequencies are $p_A(1) = \\frac{7}{10} = 0.7$ and $p_C(1) = \\frac{3}{10} = 0.3$.\n$$H(C_1) = -\\left(0.7 \\log_{2}(0.7) + 0.3 \\log_{2}(0.3)\\right) \\approx - (0.7 \\times (-0.51457)) - (0.3 \\times (-1.73697)) \\approx 0.36020 + 0.52109 \\approx 0.88129 \\text{ bits}$$\n\nFor Column $2$ with counts $(A{:}\\,4,\\;C{:}\\,4,\\;G{:}\\,2,\\;T{:}\\,0)$:\nThe frequencies are $p_A(2) = \\frac{4}{10} = 0.4$, $p_C(2) = \\frac{4}{10} = 0.4$, and $p_G(2) = \\frac{2}{10} = 0.2$.\n$$H(C_2) = -\\left(2 \\times 0.4 \\log_{2}(0.4) + 0.2 \\log_{2}(0.2)\\right) \\approx - (0.8 \\times (-1.32193)) - (0.2 \\times (-2.32193)) \\approx 1.05754 + 0.46439 \\approx 1.52193 \\text{ bits}$$\n\nFor Column $3$ with counts $(A{:}\\,5,\\;C{:}\\,0,\\;G{:}\\,5,\\;T{:}\\,0)$:\nThe frequencies are $p_A(3) = \\frac{5}{10} = 0.5$ and $p_G(3) = \\frac{5}{10} = 0.5$.\n$$H(C_3) = -\\left(2 \\times 0.5 \\log_{2}(0.5)\\right) = - (1 \\times (-1)) = 1 \\text{ bit}$$\n\nThe total objective before refinement is:\n$$J_{\\text{before}} = H(C_1) + H(C_2) + H(C_3) \\approx 0.88129 + 1.52193 + 1.0 = 3.40322 \\text{ bits}$$\n\nNext, we calculate the objective function after refinement, $J_{\\text{after}}$.\n\nFor Column $1'$ with counts $(A{:}\\,10,\\;C{:}\\,0,\\;G{:}\\,0,\\;T{:}\\,0)$:\nThe frequency is $p_A(1') = \\frac{10}{10} = 1$. This is a fully conserved column.\n$$H(C'_1) = -(1 \\log_{2}(1)) = 0 \\text{ bits}$$\n\nFor Column $2'$ with counts $(A{:}\\,3,\\;C{:}\\,3,\\;G{:}\\,4,\\;T{:}\\,0)$:\nThe frequencies are $p_A(2') = \\frac{3}{10} = 0.3$, $p_C(2') = \\frac{3}{10} = 0.3$, and $p_G(2') = \\frac{4}{10} = 0.4$.\n$$H(C'_2) = -\\left(2 \\times 0.3 \\log_{2}(0.3) + 0.4 \\log_{2}(0.4)\\right) \\approx - (0.6 \\times (-1.73697)) - (0.4 \\times (-1.32193)) \\approx 1.04218 + 0.52877 \\approx 1.57095 \\text{ bits}$$\n\nFor Column $3'$ with counts $(A{:}\\,3,\\;C{:}\\,2,\\;G{:}\\,5,\\;T{:}\\,0)$:\nThe frequencies are $p_A(3') = \\frac{3}{10} = 0.3$, $p_C(3') = \\frac{2}{10} = 0.2$, and $p_G(3') = \\frac{5}{10} = 0.5$.\n$$H(C'_3) = -\\left(0.3 \\log_{2}(0.3) + 0.2 \\log_{2}(0.2) + 0.5 \\log_{2}(0.5)\\right) \\approx - (0.3 \\times (-1.73697)) - (0.2 \\times (-2.32193)) - (0.5 \\times (-1)) \\approx 0.52109 + 0.46439 + 0.5 \\approx 1.48548 \\text{ bits}$$\n\nThe total objective after refinement is:\n$$J_{\\text{after}} = H(C'_1) + H(C'_2) + H(C'_3) \\approx 0 + 1.57095 + 1.48548 = 3.05643 \\text{ bits}$$\n\nFinally, the net change in the objective is computed:\n$$\\Delta J = J_{\\text{after}} - J_{\\text{before}} \\approx 3.05643 - 3.40322 = -0.34679 \\text{ bits}$$\nThe negative value indicates that the total entropy of the alignment has decreased, which corresponds to an improvement of the alignment according to this specific objective function (as lower entropy implies less disorder or higher conservation).\n\nThe problem requires the answer to be rounded to four significant figures.\n$$\\Delta J \\approx -0.3468$$", "answer": "$$\\boxed{-0.3468}$$", "id": "2400615"}, {"introduction": "After understanding how to score an alignment, the next step is to build the engine that iteratively improves it. This comprehensive exercise guides you through the implementation of a complete (though simplified) iterative refinement pipeline, from an initial progressive alignment to the refinement loop itself [@problem_id:2400635]. By implementing the \"leave-one-out\" strategy and realigning sequences against a profile, you will develop a deep and practical understanding of the core logic that powers sophisticated MSA tools and see firsthand how they seek to optimize an alignment score.", "problem": "You are asked to design and implement a simplified multiple sequence alignment (MSA) procedure that includes an iterative refinement stage, and to use it to quantify how low-complexity regions are treated by the refinement: do they remain correctly aligned or do they spuriously expand or contract in the final alignment. Your program must compute, for each test case, an integer index that measures expansion or contraction of a designated low-complexity block after iterative refinement relative to a robust target length.\n\nFundamental base and core definitions to be used:\n- The objective is the sum-of-pairs (SP) alignment score. Given an MSA of $N$ sequences each realized as a string over a finite alphabet and gaps, the SP score is the sum over all $\\binom{N}{2}$ unordered pairs of sequences of the pairwise global alignment score induced by the alignment columns.\n- Pairwise global alignment score with an affine gap penalty is defined by a substitution score $s(a,b)$ for aligned letters $a$ and $b$ and a penalty model that assigns cost $g_o$ to opening a new gap run and $g_e$ to extending an existing gap run by one column. The score for a letter-letter alignment is $s(a,b)$. The score cost for a gap run of length $\\ell$ between a pair of sequences is $g_o + (\\ell - 1)\\,g_e$.\n- A low-complexity region is a contiguous interval of indices in each original sequence that is enriched for repeats (e.g., homopolymers). For each sequence $i$, you will be given an interval $[L_i, R_i]$ of $0$-based indices, inclusive, that specifies this region in the original unaligned sequence.\n\nAlgorithmic tasks to implement (principle-based design, not merely a recipe):\n1. Use dynamic programming to compute progressive MSA:\n   - Start with the first sequence as the initial profile.\n   - Sequentially add each remaining sequence by aligning it globally to the current profile with a dynamic programming recurrence derived from the affine gap model and the SP objective. Represent the profile as an ordered list of columns.\n   - For aligning a residue $r$ to a profile column $C$, use the SP contribution $\\sum_{x \\in C, x \\neq \\text{gap}} s(r,x)$.\n   - For aligning a gap in the incoming sequence against a profile column $C$, the affine gap penalties are scaled by the number of non-gap residues in $C$: opening cost $|C^\\ast|\\,g_o$ and extension cost $|C^\\ast|\\,g_e$, where $|C^\\ast|$ denotes the number of residues in $C$ that are not gaps.\n   - For aligning a residue $r$ against a gap-column inserted into the profile (i.e., a new column with gaps in all existing profile sequences), use affine gap penalties scaled by the current profile size $P$: opening cost $P\\,g_o$ and extension cost $P\\,g_e$.\n   - The recurrence must use three affine-gap states to model match/mismatch, gap in the sequence, and gap in the profile, and must be set up to produce a global alignment.\n2. Implement iterative refinement:\n   - Given an initial MSA of $N$ sequences, define the SP score as the sum over all $\\binom{N}{2}$ sequence pairs computed directly from the alignment columns using the affine gap model with per-pair gap opening ($g_o$) and extension ($g_e$) penalties.\n   - Perform leave-one-out refinement cycles: for each sequence in turn, remove it from the MSA, collapse any columns that become all gaps, realign the removed sequence globally to the profile of the remaining $N-1$ sequences using the dynamic programming rule above, and compute the new SP score of the full MSA. Accept the realignment if and only if it strictly increases the SP score. Repeat passes until a full pass yields no improvement or a fixed maximum number of iterations is reached.\n3. Quantify low-complexity span distortion:\n   - After iterative refinement, for each sequence $i$, track which MSA columns correspond to original positions within its low-complexity interval $[L_i, R_i]$.\n   - Let $C_i$ be the set of MSA column indices containing characters drawn from the interval $[L_i, R_i]$ of sequence $i$. Let $C = \\bigcup_{i=1}^N C_i$. Define the aligned span length as $\\operatorname{span}(C) = \\max(C) - \\min(C) + 1$.\n   - Define the target length as the median of the true region lengths $\\ell_i = R_i - L_i + 1$ across the $N$ sequences in the test case. Because $N$ in the test suite is odd, the median is an integer. Define the expansion index as\n     $$E = \\operatorname{span}(C) - \\operatorname{median}(\\{\\ell_i\\}).$$\n     A positive $E$ indicates expansion, a negative $E$ indicates contraction, and $E=0$ indicates no net distortion.\n\nScoring model to use throughout:\n- Alphabet scoring is $s(a,b) = +1$ if $a=b$ and $s(a,b) = -1$ otherwise, for letters only.\n- Affine gap penalties are $g_o = -2$ for a gap open and $g_e = -1$ for a gap extend.\n\nStopping rule and parameters:\n- Use a maximum of $10$ refinement passes (each pass attempts to realign every sequence once), and also stop early if a full pass yields no SP score improvement.\n\nInput specification for the test suite you must embed in your program:\n- There is no external input. Hard-code the following three test cases. Each case is a tuple consisting of a list of sequences and a list of low-complexity intervals $[L_i, R_i]$ (inclusive, $0$-based per original unaligned sequence, and lengths are consistent with the strings shown).\n\nTest suite:\n- Case $1$ (happy path; identical low-complexity length):\n  - Sequences: [\"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\"]\n  - Low-complexity intervals: $[(4,8),(4,8),(4,8)]$.\n- Case $2$ (single-sequence insertion within low-complexity region):\n  - Sequences: [\"CCCCAAAAAGGGG\", \"CCCCAAAAAAGGGG\", \"CCCCAAAAAGGGG\"]\n  - Low-complexity intervals: $[(4,8),(4,9),(4,8)]$.\n- Case $3$ (boundary condition; region at sequence start):\n  - Sequences: [\"AAAAACCCC\", \"AAAAACCCC\", \"AAAAACCCC\"]\n  - Low-complexity intervals: $[(0,4),(0,4),(0,4)]$.\n\nRequired output:\n- For each of the three cases, compute the expansion index $E$ as defined above, after iterative refinement stops.\n- Your program should produce a single line of output containing the three integers in order as a comma-separated list enclosed in square brackets (for example, \"[0,1,0]\").\n\nAngle units and physical units do not apply. All numerical answers must be integers. The final printout must be exactly one line in the specified list format, with no spaces.", "solution": "The provided problem statement is a well-defined task in computational biology, specifically in the domain of multiple sequence alignment (MSA). It requests the design and implementation of a simplified MSA algorithm based on progressive alignment followed by iterative refinement, and the use of this algorithm to measure alignment distortion in low-complexity regions.\n\nThe problem is validated as follows:\n- **Scientific Grounding**: The concepts presented are fundamental to bioinformatics. The sum-of-pairs (SP) score is a standard objective function for MSA. Progressive alignment using dynamic programming to align sequences to profiles is the basis of classic tools like Clustal. Iterative refinement is a widely used heuristic to improve upon initial alignments, employed by modern aligners like MAFFT and Muscle. The affine gap penalty model is a standard in sequence alignment. The problem is scientifically sound.\n- **Well-Posedness**: All algorithmic steps, parameters, and objective functions are explicitly and unambiguously defined. The scoring parameters ($s(a,b)$, $g_o$, $g_e$), dynamic programming recurrence relations for profile alignment, the iterative refinement procedure (leave-one-out, strict score increase for acceptance, stopping criteria), and the final expansion index metric ($E$) are all specified precisely. The input data is self-contained and consistent.\n- **Objectivity**: The language is technical and devoid of subjective or speculative claims.\n\nThe problem is therefore deemed **valid**, and a solution is provided below. The solution is designed following the specified algorithmic principles.\n\n### Principle-Based Design of the MSA Procedure\n\nThe solution involves three primary components, each designed based on established principles in sequence analysis.\n\n**1. Progressive Alignment via Profile-Sequence Dynamic Programming**\n\nThe initial multiple sequence alignment is constructed progressively. This is a heuristic approach that builds the MSA by sequentially adding sequences. The core of this method is the alignment of an incoming sequence to a \"profile\" representing the alignment of all previously added sequences.\n\nLet a sequence $S$ of length $m$ be aligned to a profile $P$ of $N_P$ sequences and length (number of columns) $n$. We use a dynamic programming approach based on an affine gap penalty model. The cost of a gap of length $\\ell$ is given as $g_o + (\\ell-1)g_e$, which implies a cost of $g_o$ for opening a gap (a gap of length 1) and $g_e$ for extending it by one position. Three matrices are used to store the scores, representing the three possible states for aligning column $j$ of the profile with position $i$ of the sequence:\n- $M(i,j)$: Score of aligning residue $S[i-1]$ with profile column $P_{j-1}$.\n- $I_S(i,j)$: Score of aligning residue $S[i-1]$ with a gap inserted into the profile.\n- $I_P(i,j)$: Score of aligning a gap in sequence $S$ with profile column $P_{j-1}$.\n\nThe score for aligning a residue $r$ to a profile column $C$ is the sum-of-pairs score: $s_{prof}(r, C) = \\sum_{x \\in C, x \\neq \\text{gap}} s(r,x)$. The gap penalties are scaled by the number of sequences in the profile or the number of residues in a column, reflecting the SP objective. Let $|C^*|$ be the number of non-gap characters in a column $C$, and let $N_P$ be the number of sequences in the profile.\n\nThe recurrence relations are:\n$$\nM(i,j) = s_{prof}(S[i-1], P_{j-1}) + \\max \\begin{cases} M(i-1, j-1) \\\\ I_S(i-1, j-1) \\\\ I_P(i-1, j-1) \\end{cases}\n$$\n$$\nI_S(i,j) = \\max \\begin{cases} M(i-1, j) + N_P \\cdot g_o \\\\ I_S(i-1, j) + N_P \\cdot g_e \\end{cases}\n$$\n$$\nI_P(i,j) = \\max \\begin{cases} M(i, j-1) + |P_{j-1}^*| \\cdot g_o \\\\ I_P(i, j-1) + |P_{j-1}^*| \\cdot g_e \\end{cases}\n$$\nThe global alignment score is the maximum of $M(m,n)$, $I_S(m,n)$, and $I_P(m,n)$. The alignment itself is reconstructed by backtracking from this final cell.\n\n**2. Iterative Refinement**\n\nProgressive alignment is greedy and can lead to suboptimal solutions. Iterative refinement attempts to improve this initial alignment by repeatedly realigning subsets of sequences. The \"leave-one-out\" strategy specified is a common approach.\n\nFor each sequence $S_k$ in the current MSA:\na. $S_k$ is removed.\nb. The remaining $N-1$ sequences form a sub-alignment. Any columns that now contain only gaps are removed.\nc. This sub-alignment is treated as a fixed profile, and $S_k$ is realigned to it using the profile-sequence DP algorithm described above.\nd. A new full MSA is formed. Its total SP score is calculated. The SP score of an MSA is the sum of pairwise alignment scores over all $\\binom{N}{2}$ pairs of sequences. The pairwise score is computed from the columns of the MSA, applying the affine gap penalties $g_o$ and $g_e$ for each detected gap run.\ne. If the new SP score is strictly greater than the score of the previous MSA, the new alignment is accepted.\n\nThis process is repeated for all sequences in a \"pass\". The procedure terminates if a full pass results in no score improvement or a maximum of $10$ passes is reached. This is a form of hill-climbing on the landscape of SP scores.\n\n**3. Low-Complexity Region Span Analysis**\n\nThe final step quantifies how the alignment process affects the span of a designated low-complexity region (LCR).\na. For each sequence $S_i$, its original LCR is defined by an interval $[L_i, R_i]$. After the final MSA is obtained, we identify the set of alignment columns, $C_i$, that contain residues from this original interval.\nb. The union of these sets, $C = \\bigcup_i C_i$, represents all columns in the final MSA that are occupied by any part of any LCR.\nc. The span of this union, $\\operatorname{span}(C) = \\max(C) - \\min(C) + 1$, gives the total width of the LCRs in the alignment space.\nd. This span is compared to a reference length, defined as the median of the original LCR lengths, $\\ell_i = R_i - L_i + 1$. The expansion index is $E = \\operatorname{span}(C) - \\operatorname{median}(\\{\\ell_i\\})$.\ne. A positive $E$ signifies that the alignment process has expanded the region, likely by inserting gaps. A negative $E$ indicates contraction. $E=0$ indicates the aligned span matches the median original length.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the MSA and refinement pipeline on specified test cases.\n    \"\"\"\n    \n    # --- Scoring Parameters ---\n    s_match = 1\n    s_mismatch = -1\n    g_o = -2\n    g_e = -1\n    \n    # --- Refinement Parameters ---\n    max_refinement_passes = 10\n\n    def s(a, b):\n        \"\"\"Substitution score.\"\"\"\n        if a == '-' or b == '-':\n            return 0 # Gaps vs gaps not scored in substitution matrix\n        return s_match if a == b else s_mismatch\n\n    def calculate_sp_score(msa):\n        \"\"\"\n        Calculates the Sum-of-Pairs score for a given MSA using an affine gap model.\n        The score for a gap run of length l is g_o + (l-1)*g_e.\n        \"\"\"\n        if not msa or len(msa)  2:\n            return 0\n        \n        num_seqs = len(msa)\n        alignment_len = len(msa[0])\n        total_sp_score = 0\n\n        for i in range(num_seqs):\n            for j in range(i + 1, num_seqs):\n                seq1 = msa[i]\n                seq2 = msa[j]\n                pair_score = 0\n                \n                # Substitution scores\n                for k in range(alignment_len):\n                    pair_score += s(seq1[k], seq2[k])\n\n                # Gap penalties\n                in_gap1, in_gap2 = False, False\n                for k in range(alignment_len):\n                    c1, c2 = seq1[k], seq2[k]\n                    is_gap1 = c1 == '-' and c2 != '-'\n                    is_gap2 = c2 == '-' and c1 != '-'\n                    \n                    if is_gap1:\n                        pair_score += g_e if in_gap1 else g_o\n                    if is_gap2:\n                        pair_score += g_e if in_gap2 else g_o\n\n                    in_gap1 = is_gap1\n                    in_gap2 = is_gap2\n                \n                total_sp_score += pair_score\n                \n        return total_sp_score\n\n    def align_sequence_to_profile(seq_to_add, profile_msa, insertion_idx=None):\n        \"\"\"\n        Aligns a sequence to a profile represented by an MSA using dynamic programming.\n        Returns the new MSA.\n        \"\"\"\n        if not profile_msa:\n            return [seq_to_add]\n\n        N_P = len(profile_msa)\n        m, n = len(seq_to_add), len(profile_msa[0])\n\n        # --- DP tables initialization ---\n        neg_inf = -np.inf\n        M = np.full((m + 1, n + 1), neg_inf)\n        I_S = np.full((m + 1, n + 1), neg_inf) # Gap in profile\n        I_P = np.full((m + 1, n + 1), neg_inf) # Gap in sequence\n        \n        # Pointers for backtracking\n        ptr_M = np.zeros((m + 1, n + 1), dtype=int)\n        ptr_I_S = np.zeros((m + 1, n + 1), dtype=int)\n        ptr_I_P = np.zeros((m + 1, n + 1), dtype=int)\n        \n        M[0, 0] = 0\n\n        # Precompute profile stats\n        profile_cols = list(zip(*profile_msa))\n        col_non_gap_counts = [sum(1 for char in col if char != '-') for col in profile_cols]\n\n        # --- Initialization of first row/column ---\n        for i in range(1, m + 1):\n            I_S[i, 0] = N_P * g_o + (i - 1) * N_P * g_e\n        for j in range(1, n + 1):\n            cost_open = col_non_gap_counts[j - 1] * g_o\n            cost_extend = col_non_gap_counts[j - 1] * g_e\n            I_P[0, j] = I_P[0, j - 1] + cost_extend if j > 1 else cost_open\n\n        # --- DP Fill ---\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                # State M (match)\n                s_prof = sum(s(seq_to_add[i - 1], char) for char in profile_cols[j - 1] if char != '-')\n                scores_to_M = [M[i - 1, j - 1], I_S[i - 1, j - 1], I_P[i - 1, j - 1]]\n                best_prev_M_idx = np.argmax(scores_to_M)\n                M[i, j] = s_prof + scores_to_M[best_prev_M_idx]\n                ptr_M[i, j] = best_prev_M_idx # 0:M, 1:I_S, 2:I_P\n\n                # State I_S (gap in profile)\n                open_cost_S = N_P * g_o\n                extend_cost_S = N_P * g_e\n                scores_to_I_S = [M[i - 1, j] + open_cost_S, I_S[i - 1, j] + extend_cost_S]\n                best_prev_I_S_idx = np.argmax(scores_to_I_S)\n                I_S[i, j] = scores_to_I_S[best_prev_I_S_idx]\n                ptr_I_S[i, j] = best_prev_I_S_idx # 0:M, 1:I_S\n\n                # State I_P (gap in sequence)\n                open_cost_P = col_non_gap_counts[j - 1] * g_o\n                extend_cost_P = col_non_gap_counts[j - 1] * g_e\n                scores_to_I_P = [M[i, j-1] + open_cost_P, I_P[i, j - 1] + extend_cost_P]\n                best_prev_I_P_idx = np.argmax(scores_to_I_P)\n                I_P[i, j] = scores_to_I_P[best_prev_I_P_idx]\n                ptr_I_P[i, j] = best_prev_I_P_idx # 0:M, 1:I_P\n\n        # --- Backtracking ---\n        aligned_seq = []\n        aligned_profile = []\n        i, j = m, n\n        \n        final_scores = [M[m, n], I_S[m, n], I_P[m, n]]\n        state = np.argmax(final_scores)\n\n        while i > 0 or j > 0:\n            if state == 0: # M\n                aligned_seq.append(seq_to_add[i - 1])\n                aligned_profile.append(profile_cols[j - 1])\n                prev_state = ptr_M[i, j]\n                i -= 1\n                j -= 1\n                state = prev_state\n            elif state == 1: # I_S (gap in profile)\n                aligned_seq.append(seq_to_add[i - 1])\n                aligned_profile.append(['-'] * N_P)\n                prev_state = ptr_I_S[i, j]\n                i -= 1\n                state = 0 if prev_state == 0 else 1\n            else: # I_P (gap in sequence)\n                aligned_seq.append('-')\n                aligned_profile.append(profile_cols[j-1])\n                prev_state = ptr_I_P[i, j]\n                j -= 1\n                state = 0 if prev_state == 0 else 2\n        \n        aligned_seq.reverse()\n        aligned_profile.reverse()\n\n        new_msa = [''.join(row) for row in zip(*aligned_profile)]\n        new_msa.append(''.join(aligned_seq))\n        \n        if insertion_idx is not None:\n             # Reorder to original position for refinement\n            reordered_msa = [None] * (len(new_msa))\n            current = 0\n            for k in range(len(new_msa)):\n                if k == insertion_idx:\n                    reordered_msa[k] = new_msa[-1]\n                else:\n                    reordered_msa[k] = new_msa[current]\n                    current += 1\n            return reordered_msa\n\n        return new_msa\n\n    def run_case(sequences, lcr_intervals):\n        \"\"\"Runs the full pipeline for a single test case.\"\"\"\n        \n        # 1. Initial Progressive Alignment\n        current_msa = [sequences[0]]\n        for i in range(1, len(sequences)):\n            current_msa = align_sequence_to_profile(sequences[i], current_msa)\n        \n        current_score = calculate_sp_score(current_msa)\n\n        # 2. Iterative Refinement\n        for _ in range(max_refinement_passes):\n            improved_in_pass = False\n            for i in range(len(sequences)):\n                seq_to_realign = sequences[i]\n                \n                # Create sub-MSA for profile\n                sub_msa_rows = [row for k, row in enumerate(current_msa) if k != i]\n                \n                # Collapse all-gap columns\n                if sub_msa_rows:\n                    cols_to_keep = [\n                        idx for idx, col in enumerate(zip(*sub_msa_rows))\n                        if any(char != '-' for char in col)\n                    ]\n                    sub_msa = [''.join(c for i, c in enumerate(row) if i in cols_to_keep) for row in sub_msa_rows]\n                else:\n                    sub_msa = []\n\n                candidate_msa = align_sequence_to_profile(seq_to_realign, sub_msa, insertion_idx=i)\n                candidate_score = calculate_sp_score(candidate_msa)\n                \n                if candidate_score > current_score:\n                    current_msa = candidate_msa\n                    current_score = candidate_score\n                    improved_in_pass = True\n            \n            if not improved_in_pass:\n                break\n        \n        final_msa = current_msa\n        \n        # 3. Quantify Span Distortion\n        lcr_columns = set()\n        num_seqs = len(sequences)\n\n        for i in range(num_seqs):\n            l_i, r_i = lcr_intervals[i]\n            orig_idx = -1\n            for j, char in enumerate(final_msa[i]):\n                if char != '-':\n                    orig_idx += 1\n                    if l_i = orig_idx = r_i:\n                        lcr_columns.add(j)\n        \n        if not lcr_columns:\n            span_c = 0\n        else:\n            span_c = max(lcr_columns) - min(lcr_columns) + 1\n            \n        region_lengths = [r - l + 1 for l, r in lcr_intervals]\n        median_length = int(np.median(region_lengths)) # N is odd, so median is integer\n        \n        expansion_index = span_c - median_length\n        return expansion_index\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case 1\n        (\n            [\"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\", \"CCCCAAAAAGGGG\"],\n            [(4, 8), (4, 8), (4, 8)]\n        ),\n        # Case 2\n        (\n            [\"CCCCAAAAAGGGG\", \"CCCCAAAAAAGGGG\", \"CCCCAAAAAGGGG\"],\n            [(4, 8), (4, 9), (4, 8)]\n        ),\n        # Case 3\n        (\n            [\"AAAAACCCC\", \"AAAAACCCC\", \"AAAAACCCC\"],\n            [(0, 4), (0, 4), (0, 4)]\n        )\n    ]\n\n    results = []\n    for case_sequences, case_intervals in test_cases:\n        result = run_case(case_sequences, case_intervals)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400635"}, {"introduction": "An iterative refiner will diligently optimize the objective function it's given, but is that function always a reliable proxy for biological truth? This practice provides a critical perspective by creating a \"deceptive\" benchmark where an alignment's sequence-based Sum-of-Pairs (SP) score improves, while its structural accuracy, measured by a Root Mean Square Deviation (RMSD) criterion, actually gets worse [@problem_id:2400632]. This exercise will sharpen your critical thinking, demonstrating the crucial difference between sequence similarity and structural or functional conservation, a key limitation to keep in mind when using any MSA tool.", "problem": "You are asked to design and evaluate a deceptively favorable benchmark for Multiple Sequence Alignment (MSA) iterative refinement. The point is to show that optimizing the sum-of-pairs (SP) sequence score can produce alignments that look better numerically on the SP objective but are worse in a structural sense when measured by a Root Mean Square Deviation (RMSD)-like criterion computed from coordinates in a shared embedding space. You must implement a complete program that takes a fixed test suite (provided below), computes the SP score and the RMSD-like score for a “baseline” alignment and a “refined” alignment for each test case, and then reports whether the test case demonstrates a deceptive improvement (defined precisely below). The program must output the results for all test cases aggregated as a single list on one line in the specified format.\n\nFundamental base:\n- Multiple Sequence Alignment (MSA) arranges $m$ sequences into a matrix of columns with possible gaps so that residues that are evolutionarily or functionally corresponding are co-aligned.\n- The sum-of-pairs (SP) score is a commonly used objective in MSA optimization: it is the sum over columns of a pairwise scoring function applied to all unordered pairs of sequences that have residues (not gaps) in that column.\n- Euclidean distance in $\\mathbb{R}^d$ for coordinates $\\mathbf{x},\\mathbf{y}\\in\\mathbb{R}^d$ is $\\lVert \\mathbf{x}-\\mathbf{y}\\rVert_2=\\sqrt{\\sum_{k=1}^{d}(x_k-y_k)^2}$.\n- The Root Mean Square Deviation (RMSD) between two coordinate sets is a standard measure of structural similarity and can be formulated as the square root of the mean of squared Euclidean distances between paired points.\n\nYour tasks:\n1) Implement an SP score with identity-based scoring. Let $m$ be the number of sequences, let the alignment have $L$ columns, and let $A_{j,p}$ denote the residue character of sequence $p\\in\\{1,\\dots,m\\}$ in column $j\\in\\{1,\\dots,L\\}$ if it is not a gap, or a gap otherwise. Define a pairwise identity scoring function $s(a,b)$ by $s(a,b)=1$ if $a=b$ and both are non-gap characters, and $s(a,b)=0$ otherwise. The SP score is\n$$\n\\mathrm{SP}=\\sum_{j=1}^{L}\\sum_{1\\le pq\\le m} s\\!\\left(A_{j,p},A_{j,q}\\right).\n$$\n\n2) Implement an RMSD-like evaluation that uses provided per-residue coordinates in a shared frame. For a given alignment, for each column $j$ and each unordered pair of sequences $(p,q)$ such that both entries in column $j$ are residues (not gaps) originating from residue indices $i_p$ and $i_q$ in sequences $p$ and $q$ respectively, take their coordinates $\\mathbf{x}^{(p)}_{i_p}\\in\\mathbb{R}^d$ and $\\mathbf{x}^{(q)}_{i_q}\\in\\mathbb{R}^d$ and accumulate the squared distance $\\lVert \\mathbf{x}^{(p)}_{i_p}-\\mathbf{x}^{(q)}_{i_q}\\rVert_2^2$. Let $N_{\\text{pairs}}$ be the total number of such residue-residue pairs across the entire alignment. Define\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{N_{\\text{pairs}}}\\sum \\lVert \\mathbf{x}^{(p)}_{i_p}-\\mathbf{x}^{(q)}_{i_q}\\rVert_2^2},\n$$\nwhere the sum is over all columns and all unordered residue-residue pairs within each column. You may assume $N_{\\text{pairs}}0$ for all provided test cases.\n\n3) Deceptive improvement predicate. Given a baseline alignment with $(\\mathrm{SP}_{\\mathrm{base}}, \\mathrm{RMSD}_{\\mathrm{base}})$ and a refined alignment with $(\\mathrm{SP}_{\\mathrm{ref}}, \\mathrm{RMSD}_{\\mathrm{ref}})$ for the same test case, declare the test case deceptive if and only if both\n$$\n\\mathrm{SP}_{\\mathrm{ref}}  \\mathrm{SP}_{\\mathrm{base}}\n\\quad\\text{and}\\quad\n\\mathrm{RMSD}_{\\mathrm{ref}}  \\mathrm{RMSD}_{\\mathrm{base}}.\n$$\nOtherwise, the test case is not deceptive.\n\nRepresentation details your program must implement:\n- Each test case provides $m$ sequences as strings and corresponding coordinate arrays $\\left(\\mathbf{x}^{(p)}_0,\\dots,\\mathbf{x}^{(p)}_{n_p-1}\\right)$ for each sequence $p$, where $n_p$ is the sequence length. All coordinates lie in a shared Euclidean space $\\mathbb{R}^d$. In the provided tests, $d=1$ with coordinates as one-dimensional positions.\n- Each alignment (baseline and refined) is represented as a list of columns. A column is a list of length $m$, where entry $p$ is either the residue index $i_p\\in\\{0,\\dots,n_p-1\\}$ of the residue of sequence $p$ present in that column, or the special value $-1$ indicating a gap for sequence $p$ in that column.\n- Your implementation must enforce that in computing the SP and RMSD, only non-gap entries contribute, and in particular, a gap never contributes a pair.\n\nTest suite you must hard-code and evaluate:\n- Test case $1$ (deceptive by design):\n  - Sequences ($m=3$):\n    - $S_1=$ \"AXAXAX\" with coordinates $[\\,0,1,2,3,4,5\\,]$ in $\\mathbb{R}^1$.\n    - $S_2=$ \"XAXAXA\" with coordinates $[\\,0,1,2,3,4,5\\,]$ in $\\mathbb{R}^1$.\n    - $S_3=$ \"XXXXXX\" with coordinates $[\\,0,1,2,3,4,5\\,]$ in $\\mathbb{R}^1$.\n  - Baseline alignment (index-wise; $6$ columns):\n    - $[\\, [\\,0,0,0\\,], [\\,1,1,1\\,], [\\,2,2,2\\,], [\\,3,3,3\\,], [\\,4,4,4\\,], [\\,5,5,5\\,] \\,]$.\n  - Refined alignment (SP-seeking; $9$ columns):\n    - $[\\, [\\,0,1,-1\\,], [\\,2,3,-1\\,], [\\,4,5,-1\\,], [\\,1,0,0\\,], [\\,3,2,1\\,], [\\,5,4,2\\,], [\\, -1,-1,3\\,], [\\, -1,-1,4\\,], [\\, -1,-1,5\\,] \\,]$.\n\n- Test case $2$ (non-deceptive improvement):\n  - Sequences ($m=3$):\n    - $S_1=$ \"ABCD\" with coordinates $[\\,0,1,2,3\\,]$.\n    - $S_2=$ \"ABXD\" with coordinates $[\\,0,1,2,3\\,]$.\n    - $S_3=$ \"ABCD\" with coordinates $[\\,0,1,2,3\\,]$.\n  - Baseline alignment ($4$ columns; misaligned middle):\n    - $[\\, [\\,0,0,0\\,], [\\,1,1,1\\,], [\\,2,3,2\\,], [\\,3,2,3\\,] \\,]$.\n  - Refined alignment (index-wise; $4$ columns):\n    - $[\\, [\\,0,0,0\\,], [\\,1,1,1\\,], [\\,2,2,2\\,], [\\,3,3,3\\,] \\,]$.\n\n- Test case $3$ (no change):\n  - Sequences ($m=3$):\n    - $S_1=$ \"ABC\" with coordinates $[\\,0,1,2\\,]$.\n    - $S_2=$ \"ABC\" with coordinates $[\\,0,1,2\\,]$.\n    - $S_3=$ \"ABC\" with coordinates $[\\,0,1,2\\,]$.\n  - Baseline alignment ($3$ columns):\n    - $[\\, [\\,0,0,0\\,], [\\,1,1,1\\,], [\\,2,2,2\\,] \\,]$.\n  - Refined alignment (identical to baseline):\n    - $[\\, [\\,0,0,0\\,], [\\,1,1,1\\,], [\\,2,2,2\\,] \\,]$.\n\n- Test case $4$ (SP decreases but RMSD improves; not deceptive):\n  - Sequences ($m=3$):\n    - $S_1=$ \"AX\" with coordinates $[\\,0,1\\,]$.\n    - $S_2=$ \"XA\" with coordinates $[\\,0,1\\,]$.\n    - $S_3=$ \"XX\" with coordinates $[\\,0,1\\,]$.\n  - Baseline alignment (SP-seeking; $3$ columns):\n    - $[\\, [\\,0,1,-1\\,], [\\,1,0,0\\,], [\\, -1,-1,1\\,] \\,]$.\n  - Refined alignment (index-wise; $2$ columns):\n    - $[\\, [\\,0,0,0\\,], [\\,1,1,1\\,] \\,]$.\n\nWhat to output:\n- For each test case $t\\in\\{1,2,3,4\\}$, compute $\\mathrm{SP}_{\\mathrm{base}}^{(t)}$, $\\mathrm{RMSD}_{\\mathrm{base}}^{(t)}$, $\\mathrm{SP}_{\\mathrm{ref}}^{(t)}$, and $\\mathrm{RMSD}_{\\mathrm{ref}}^{(t)}$, and then compute a boolean $B^{(t)}$ that is true if and only if $\\mathrm{SP}_{\\mathrm{ref}}^{(t)}  \\mathrm{SP}_{\\mathrm{base}}^{(t)}$ and $\\mathrm{RMSD}_{\\mathrm{ref}}^{(t)}  \\mathrm{RMSD}_{\\mathrm{base}}^{(t)}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[\\,\\text{True},\\text{False},\\text{True},\\text{False}\\,]$.\n\nAngle units and physical units do not apply here. All outputs are booleans.", "solution": "The problem as stated is valid. It is scientifically grounded in the established principles of computational biology, specifically Multiple Sequence Alignment (MSA). The definitions for the sum-of-pairs ($\\mathrm{SP}$) score and the Root Mean Square Deviation ($\\mathrm{RMSD}$) are mathematically precise and internally consistent. The problem is well-posed, providing all necessary data, including sequences, coordinates, and alignment structures, to compute a unique and verifiable result for each test case. The objective is to implement these defined metrics and a specified \"deceptive improvement\" predicate, which is a clear and formalizable computational task. There are no contradictions, ambiguities, or claims that violate scientific facts.\n\nThe core of the problem is to implement two evaluation functions for a given multiple sequence alignment: one based on sequence identity ($\\mathrm{SP}$ score) and another based on spatial proximity of residues in a given embedding ($\\mathrm{RMSD}$-like score).\n\nFirst, we formalize the calculation of the $\\mathrm{SP}$ score. Let there be $m$ sequences, and let the alignment consist of $L$ columns. An entry in the alignment matrix, $A_{j,p}$, represents the character from sequence $p \\in \\{1, \\ldots, m\\}$ in column $j \\in \\{1, \\ldots, L\\}$. This entry can be a residue or a gap. The scoring function $s(a, b)$ is defined as $1$ if the characters $a$ and $b$ are identical and are not gaps, and $0$ otherwise. The total $\\mathrm{SP}$ score is the summation over all columns of the scores of all unique pairs of sequences in that column:\n$$\n\\mathrm{SP} = \\sum_{j=1}^{L} \\sum_{1 \\le p  q \\le m} s(A_{j,p}, A_{j,q})\n$$\n\nSecond, we formalize the $\\mathrm{RMSD}$-like score. For each sequence $p$, we are given a set of coordinates $\\{\\mathbf{x}_i^{(p)}\\}$ for each residue $i$. The alignment is provided as a mapping: for each column $j$ and sequence $p$, we have an index $i_p$ of the residue from sequence $p$ placed in that column, or a special value (e.g., $-1$) indicating a gap. For each column $j$, we identify all pairs of sequences $(p,q)$ that both have a residue (non-gap) in that column. For each such pair, we find their original residue indices $i_p$ and $i_q$ and their corresponding coordinates $\\mathbf{x}_{i_p}^{(p)}$ and $\\mathbf{x}_{i_q}^{(q)}$. The squared Euclidean distance between these coordinates, $\\lVert \\mathbf{x}_{i_p}^{(p)} - \\mathbf{x}_{i_q}^{(q)} \\rVert_2^2$, is calculated. The total sum of these squared distances is computed over all such pairs in all columns. This sum is then normalized by the total number of pairs, $N_{\\text{pairs}}$, and the square root is taken:\n$$\n\\mathrm{RMSD} = \\sqrt{\\frac{1}{N_{\\text{pairs}}} \\sum_{\\text{all pairs}} \\lVert \\mathbf{x}_{i_p}^{(p)} - \\mathbf{x}_{i_q}^{(q)} \\rVert_2^2}\n$$\nThe summation is over all columns and all unique pairs of non-gap residues within each column. For the given problems, the coordinates are in $\\mathbb{R}^1$, so the squared Euclidean distance simplifies to $(x_{i_p}^{(p)} - x_{i_q}^{(q)})^2$.\n\nFinally, a \"deceptive improvement\" is declared for a given test case if, upon moving from a baseline alignment to a refined alignment, the $\\mathrm{SP}$ score increases while the $\\mathrm{RMSD}$ score also increases. That is, for a baseline alignment with scores $(\\mathrm{SP}_{\\mathrm{base}}, \\mathrm{RMSD}_{\\mathrm{base}})$ and a refined alignment with scores $(\\mathrm{SP}_{\\mathrm{ref}}, \\mathrm{RMSD}_{\\mathrm{ref}})$, the condition for deception is:\n$$\n\\mathrm{SP}_{\\mathrm{ref}}  \\mathrm{SP}_{\\mathrm{base}} \\quad \\text{and} \\quad \\mathrm{RMSD}_{\\mathrm{ref}}  \\mathrm{RMSD}_{\\mathrm{base}}\n$$\n\nThe procedure to solve the problem is as follows:\n$1$. For each of the $4$ test cases provided, there are two alignments: a baseline and a refined one.\n$2$. For each alignment, we implement a function that iterates through each column. Inside the column, it iterates through all unique pairs of sequences.\n$3$. If both sequences in a pair have a residue (not a gap) in the current column, we proceed.\n$4$. For the $\\mathrm{SP}$ score, we retrieve the residue characters using the given indices and check if they are identical. If so, the $\\mathrm{SP}$ accumulator is incremented by $1$.\n$5$. For the $\\mathrm{RMSD}$ score, we retrieve the coordinates corresponding to the residue indices. The squared distance between these coordinates is added to a running sum of squared distances. A counter for the number of such pairs, $N_{\\text{pairs}}$, is also incremented.\n$6$. After processing all columns, the final $\\mathrm{SP}$ score is the total accumulated value. The final $\\mathrm{RMSD}$ is calculated by dividing the total sum of squared distances by $N_{\\text{pairs}}$ and taking the square root. These two values, $(\\mathrm{SP}, \\mathrm{RMSD})$, are computed for both the baseline and refined alignments of a test case.\n$7$. The two pairs of scores, $(\\mathrm{SP}_{\\mathrm{base}}, \\mathrm{RMSD}_{\\mathrm{base}})$ and $(\\mathrm{SP}_{\\mathrm{ref}}, \\mathrm{RMSD}_{\\mathrm{ref}})$, are compared using the deceptive improvement predicate. The resulting boolean value is stored.\n$8$. This process is repeated for all test cases, and the final list of boolean values is reported.\n\nLet us illustrate with Test Case $1$.\nSequences: $S_1=$ \"AXAXAX\", $S_2=$ \"XAXAXA\", $S_3=$ \"XXXXXX\". Coordinates for all are $[\\,0,1,2,3,4,5\\,]$.\nBaseline alignment: $[\\,[\\,0,0,0\\,], \\dots, [\\,5,5,5\\,]\\,]$. This is an ungapped alignment.\nIn any column $j$, the residues are $S_1[j]$, $S_2[j]$, and $S_3[j]$. The coordinates are all $j$.\nFor $j=0$: residues 'A', 'X', 'X'. Pairs are ('A','X'), ('A','X'), ('X','X'). Only the last pair matches. $\\mathrm{SP}$ contribution is $1$. Coordinates are all $0$, so squared distances are $0$.\nFor $j=1$: residues 'X', 'A', 'X'. Pairs are ('X','A'), ('X', 'X'), ('A', 'X'). Only the middle pair matches. $\\mathrm{SP}$ contribution is $1$. Coordinates are all $1$, so squared distances are $0$.\nThis pattern repeats for all $6$ columns.\nThus, $\\mathrm{SP}_{\\mathrm{base}} = 6 \\times 1 = 6$.\nTotal sum of squared distances is $0$, so $\\mathrm{RMSD}_{\\mathrm{base}} = 0$.\n\nRefined alignment: $[\\,[\\,0,1,-1\\,], [\\,2,3,-1\\,], \\dots, [\\, -1,-1,5\\,]\\,]$.\nCol $0$: $S_1[0]=$'A', $S_2[1]=$'A'. One pair, they match. $\\mathrm{SP}$ contribution is $1$. Coords are $0$ and $1$. Squared distance is $(0-1)^2=1$. $N_{\\text{pairs}}$ contribution is $1$.\nCol $3$: $S_1[1]=$'X', $S_2[0]=$'X', $S_3[0]=$'X'. Three pairs, all match. $\\mathrm{SP}$ contribution is $3$. Coords are $1, 0, 0$. Squared distances: $(1-0)^2 + (1-0)^2 + (0-0)^2 = 2$. $N_{\\text{pairs}}$ contribution is $3$.\nAggregating over all columns, we find $\\mathrm{SP}_{\\mathrm{ref}} = 12$ and $\\mathrm{RMSD}_{\\mathrm{ref}} = \\sqrt{25/12} \\approx 1.443$.\nComparing scores: $\\mathrm{SP}_{\\mathrm{ref}}=12  \\mathrm{SP}_{\\mathrm{base}}=6$ (True) and $\\mathrm{RMSD}_{\\mathrm{ref}} \\approx 1.443  \\mathrm{RMSD}_{\\mathrm{base}}=0$ (True). Both conditions hold, so the result for Test Case $1$ is True.\n\nExecuting this logic for all four cases gives the final results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the deceptive MSA benchmark problem by calculating SP and RMSD-like scores\n    for baseline and refined alignments for a fixed suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"sequences\": [\"AXAXAX\", \"XAXAXA\", \"XXXXXX\"],\n            \"coords\": [[0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5]],\n            \"baseline_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3], [4, 4, 4], [5, 5, 5]],\n            \"refined_align\": [[0, 1, -1], [2, 3, -1], [4, 5, -1], [1, 0, 0], [3, 2, 1], [5, 4, 2], [-1, -1, 3], [-1, -1, 4], [-1, -1, 5]],\n        },\n        {\n            \"sequences\": [\"ABCD\", \"ABXD\", \"ABCD\"],\n            \"coords\": [[0, 1, 2, 3], [0, 1, 2, 3], [0, 1, 2, 3]],\n            \"baseline_align\": [[0, 0, 0], [1, 1, 1], [2, 3, 2], [3, 2, 3]],\n            \"refined_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]],\n        },\n        {\n            \"sequences\": [\"ABC\", \"ABC\", \"ABC\"],\n            \"coords\": [[0, 1, 2], [0, 1, 2], [0, 1, 2]],\n            \"baseline_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2]],\n            \"refined_align\": [[0, 0, 0], [1, 1, 1], [2, 2, 2]],\n        },\n        {\n            \"sequences\": [\"AX\", \"XA\", \"XX\"],\n            \"coords\": [[0, 1], [0, 1], [0, 1]],\n            \"baseline_align\": [[0, 1, -1], [1, 0, 0], [-1, -1, 1]],\n            \"refined_align\": [[0, 0, 0], [1, 1, 1]],\n        },\n    ]\n\n    def evaluate_alignment(sequences, coords, alignment):\n        \"\"\"\n        Computes the SP score and RMSD-like score for a given alignment.\n        \"\"\"\n        num_seqs = len(sequences)\n        total_sp_score = 0\n        total_sq_dist = 0.0\n        num_pairs = 0\n\n        for column in alignment:\n            # Collect active residues in the current column\n            active_residues = []\n            for seq_idx in range(num_seqs):\n                res_idx = column[seq_idx]\n                if res_idx != -1:\n                    char = sequences[seq_idx][res_idx]\n                    coord = coords[seq_idx][res_idx]\n                    active_residues.append({'char': char, 'coord': coord})\n            \n            # Process all unique pairs of active residues\n            num_active = len(active_residues)\n            if num_active > 1:\n                for i in range(num_active):\n                    for j in range(i + 1, num_active):\n                        res1 = active_residues[i]\n                        res2 = active_residues[j]\n\n                        # SP score contribution\n                        if res1['char'] == res2['char']:\n                            total_sp_score += 1\n                        \n                        # RMSD-like score contribution\n                        # Since coordinates are 1D, squared Euclidean distance is (c1-c2)^2\n                        dist_sq = (res1['coord'] - res2['coord'])**2\n                        total_sq_dist += dist_sq\n                        num_pairs += 1\n\n        if num_pairs == 0:\n            # As per problem, guaranteed N_pairs > 0, but handle defensively.\n            rmsd_score = 0.0\n        else:\n            rmsd_score = np.sqrt(total_sq_dist / num_pairs)\n            \n        return total_sp_score, rmsd_score\n\n    results = []\n    for case in test_cases:\n        sp_base, rmsd_base = evaluate_alignment(case[\"sequences\"], case[\"coords\"], case[\"baseline_align\"])\n        sp_ref, rmsd_ref = evaluate_alignment(case[\"sequences\"], case[\"coords\"], case[\"refined_align\"])\n\n        is_deceptive = (sp_ref > sp_base) and (rmsd_ref > rmsd_base)\n        results.append(is_deceptive)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400632"}]}