{"hands_on_practices": [{"introduction": "This first exercise provides a direct entry point into the mechanics of consistency-based alignment. By working through a simple calculation, you will see precisely how the T-Coffee algorithm uses a \"mediator\" sequence to strengthen the alignment score between two residues, even when their initial direct alignment score is zero. This practice solidifies your understanding of the core transitive scoring formula [@problem_id:2381688].", "problem": "In the Tree-based Consistency Objective Function For Alignment Evaluation (T-Coffee) method of consistency-based multiple sequence alignment, a library of pairwise alignment scores is extended by enforcing transitive consistency across triples of sequences. Consider three sequences denoted by $A$, $B$, and $C$, and let $S(X_{i},Y_{j})$ denote the initial library weight (pairwise alignment score) between residue position $i$ in sequence $X$ and residue position $j$ in sequence $Y$. The consistency-based library extension defines an updated score $S'(A_{i},C_{k})$ by accumulating support through mediating positions in sequence $B$ according to\n$$\nS'(A_{i},C_{k}) \\equiv S(A_{i},C_{k}) + \\sum_{j} \\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big).\n$$\nAssume there is exactly one mediator $B_{j}$ with nonzero contributions, and that the given initial scores are $S(A_{i},B_{j})=10$ and $S(B_{j},C_{k})=10$, while the original direct score is $S(A_{i},C_{k})=0$. Compute the updated consistency score $S'(A_{i},C_{k})$ under these assumptions. Provide your answer as a single real number with no units. No rounding is required.", "solution": "The problem requires the computation of an updated consistency score, denoted $S'(A_{i},C_{k})$, within the framework of the T-Coffee algorithm. This method refines multiple sequence alignments by incorporating information from a library of pairwise alignments and enforcing transitive consistency.\n\nThe governing equation for the consistency-based library extension is provided as:\n$$ S'(A_{i},C_{k}) \\equiv S(A_{i},C_{k}) + \\sum_{j} \\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big) $$\nIn this expression, $S(X_{i}, Y_{j})$ is the initial library weight, or score, for the alignment of residue $i$ in sequence $X$ with residue $j$ in sequence $Y$. The updated score $S'(A_{i},C_{k})$ is calculated by augmenting the direct alignment score $S(A_{i},C_{k})$ with a sum of consistency contributions. Each term in the sum represents the support for the alignment of $A_i$ and $C_k$ that is mediated through a residue $B_j$ from a third sequence $B$. The support is quantified as the minimum of the two pairwise scores forming the path, $S(A_{i},B_{j})$ and $S(B_{j},C_{k})$.\n\nThe problem is defined with specific constraints and initial values:\n1.  The initial direct alignment score is given as $S(A_{i},C_{k}) = 0$.\n2.  There is \"exactly one mediator $B_{j}$ with nonzero contributions\". This is a critical simplification. Let us denote the index of this unique mediating residue as $j_0$. This implies that for any other residue index $j \\neq j_0$, the term $\\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big)$ is equal to $0$.\n3.  The scores for the paths involving the single active mediator $B_{j_0}$ are given as $S(A_{i},B_{j_0}) = 10$ and $S(B_{j_0},C_{k}) = 10$.\n\nGiven these conditions, the summation over all possible mediating positions $j$ in sequence $B$ reduces to a single, non-zero term for the index $j_0$:\n$$ \\sum_{j} \\min\\!\\big(S(A_{i},B_{j}),\\, S(B_{j},C_{k})\\big) = \\min\\!\\big(S(A_{i},B_{j_0}),\\, S(B_{j_0},C_{k})\\big) + \\sum_{j \\neq j_0} 0 $$\n$$ = \\min\\!\\big(S(A_{i},B_{j_0}),\\, S(B_{j_0},C_{k})\\big) $$\nSubstituting this simplified sum into the original equation for the updated score, we obtain:\n$$ S'(A_{i},C_{k}) = S(A_{i},C_{k}) + \\min\\!\\big(S(A_{i},B_{j_0}),\\, S(B_{j_0},C_{k})\\big) $$\nNow, we can substitute the provided numerical values into this expression. We are given $S(A_{i},C_{k}) = 0$, $S(A_{i},B_{j_0}) = 10$, and $S(B_{j_0},C_{k}) = 10$.\n\nFirst, we evaluate the minimum of the two mediating scores:\n$$ \\min(10, 10) = 10 $$\nThis value represents the strength of the consistent path from $A_i$ to $C_k$ through $B_{j_0}$.\n\nFinally, we add this consistency contribution to the initial direct score to find the updated score $S'(A_{i},C_{k})$:\n$$ S'(A_{i},C_{k}) = 0 + 10 $$\nTherefore, the updated consistency score is:\n$$ S'(A_{i},C_{k}) = 10 $$\nThis calculation exemplifies how the T-Coffee method can establish or strengthen an alignment score between two residues based on their strong, consistent alignment to a third, mediating residue, even when their initial direct alignment score is zero.", "answer": "$$ \\boxed{10} $$", "id": "2381688"}, {"introduction": "Beyond mere calculation, it is crucial to understand *why* consistency is a powerful concept in multiple sequence alignment. This thought experiment challenges you to reason about the algorithm's behavior in the presence of noisy dataâ€”a common real-world scenario. By analyzing how T-Coffee treats a sequence with no true homology to the rest of the set, you will appreciate its inherent robustness and its ability to filter out spurious, inconsistent alignment signals [@problem_id:2381633].", "problem": "You are given a set of protein sequences denoted by $S_1, S_2, \\dots, S_{N}$ with $N \\geq 3$. The sequences $S_1, \\dots, S_{N-1}$ are evolutionarily related homologs. The sequence $S_N$ is constructed by taking $S_1$ and applying a random permutation of its residues so that all residues of $S_1$ appear exactly once in $S_N$, but in a randomized order; therefore, $S_N$ preserves amino acid composition but destroys positional homology.\n\nConsider running T-Coffee on these sequences. T-Coffee first constructs a primary library $L$ of residue-residue pair constraints by aligning all pairs of sequences and collecting aligned residue pairs with initial weights that reflect their support in the pairwise alignments. It then performs a consistency extension step: for any pair of residues $x$ and $y$ from two sequences, if there exist residues $z$ in third sequences that support $x \\sim z$ and $z \\sim y$, the weight of $x \\sim y$ is increased accordingly. The final multiple sequence alignment is then produced by favoring residue-residue pairs with higher library weights and penalizing conflicts.\n\nWhich statement best describes the expected effect on the final multiple sequence alignment and the treatment of spurious residue-residue pairs introduced by the permuted sequence?\n\nA. The permuted sequence $S_N$ generates many incorrect residue-residue pairs that receive strong reinforcement during consistency extension because they can be chained through multiple sequences, thereby propagating errors and substantially degrading the alignment of $S_1, \\dots, S_{N-1}$.\n\nB. The incorrect residue-residue pairs involving $S_N$ lack transitive support from the other homologous sequences and therefore receive low weights after consistency extension; as a result, the alignment of $S_1, \\dots, S_{N-1}$ remains largely stable, and $S_N$ is placed with many gaps or weakly supported columns.\n\nC. Because $S_N$ preserves residue composition, it is globally aligned almost perfectly to $S_1$, and consistency extension amplifies these matches so that $S_N$ ends up aligned nearly identically to $S_1$ and to the rest of the set.\n\nD. T-Coffee deterministically identifies that $S_N$ is a permutation of $S_1$ and removes $S_N$ from the analysis before library construction, so the final alignment is identical to the alignment produced from $S_1, \\dots, S_{N-1}$.\n\nE. The consistency extension assigns uniformly high weights to all residue-residue pairs to avoid bias, so the effect of including $S_N$ depends only on the guide tree and not on the library.", "solution": "The problem statement must first be validated for scientific and logical integrity.\n\n**Step 1: Extract Givens**\n- A set of protein sequences is given, denoted by $S_1, S_2, \\dots, S_{N}$, where $N \\geq 3$.\n- The sequences $S_1, \\dots, S_{N-1}$ are evolutionarily related homologs.\n- The sequence $S_N$ is a random permutation of the residues of $S_1$.\n- Properties of $S_N$: preserves amino acid composition of $S_1$ but has no positional homology with $S_1$ or other sequences.\n- T-Coffee Algorithm Description:\n    1. A primary library $L$ of residue-residue pair constraints is built from all pairwise alignments. Initial weights reflect support in these alignments.\n    2. A consistency extension step is performed: for a pair of residues $x$ and $y$, if there exists another residue $z$ such that $x \\sim z$ and $z \\sim y$ are supported, the weight of the pair $x \\sim y$ is increased.\n    3. The final multiple sequence alignment (MSA) is constructed by favoring pairs with high library weights.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem describes the core logic of the T-Coffee (Tree-based Consistency Objective Function for alignment Evaluation) algorithm, a widely used and well-established method in computational biology for multiple sequence alignment. The concepts of homology, sequence permutation, pairwise alignment, and consistency-based library extension are all standard and accurately portrayed. The scenario is a well-conceived test of understanding the algorithm's robustness to noise. The problem is scientifically sound.\n- **Well-Posedness**: The problem is clearly stated. It provides a specific set of inputs and describes the algorithm's mechanism, asking for the expected outcome. This structure allows for a unique, logical conclusion to be derived.\n- **Objectivity**: The problem is stated in precise, technical language, free from subjectivity or ambiguity.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. It is scientifically grounded, well-posed, and objective. A solution will be derived based on the principles of the T-Coffee algorithm.\n\n**Solution Derivation**\nThe T-Coffee algorithm operates in distinct phases, which we will analyze in the context of the given set of sequences.\n\n1.  **Primary Library Construction**: T-Coffee begins by performing all possible pairwise alignments among the input sequences $\\{S_1, S_2, \\dots, S_N\\}$.\n    -   **Alignments among homologs ($S_i$ vs $S_j$, for $i, j < N$)**: Since these sequences are evolutionarily related, their pairwise alignments (e.g., using a dynamic programming algorithm like Needleman-Wunsch or Smith-Waterman) will be of high quality. They will correctly identify a large number of orthologous residue pairs. These pairs will be added to the primary library $L$ with relatively high initial weights, reflecting the high scores of these pairwise alignments.\n    -   **Alignments involving the permuted sequence ($S_i$ vs $S_N$, for $i \\leq N-1$)**: The sequence $S_N$ is a random permutation of $S_1$. It shares amino acid composition with $S_1$ but has no positional homology. The pairwise alignment of $S_N$ against any other sequence $S_i$ (including $S_1$) will be of very poor quality. An alignment algorithm will find some mathematically optimal alignment, but it will be based on chance matches and local compositional biases rather than true evolutionary correspondence. The resulting alignment score will be low, and the residue-residue pairs generated will be spurious (i.e., incorrect from a biological perspective). These spurious pairs will be added to the library $L$, but with very low initial weights.\n\n2.  **Consistency Extension**: This is the critical step that distinguishes T-Coffee. The algorithm assesses the consistency of every pair in the library. For a given pair of residues, $(x \\in S_i, y \\in S_j)$, its weight is updated based on transitive evidence from other sequences. The new weight is a sum over all possible intermediate residues $z \\in S_k$ (where $k \\neq i, j$) of the weights of the constituent pairs $(x, z)$ and $(z, y)$.\n    -   **For a correct pair $(x \\in S_i, y \\in S_j)$ with $i, j < N$**: Because the sequences $S_1, \\dots, S_{N-1}$ are homologs, for most such correct pairs, there will exist a corresponding residue $z \\in S_k$ (for $k < N, k \\neq i, j$) that is also homologous. The pairs $(x, z)$ and $(z, y)$ will therefore exist in the primary library with high initial weights. The sum over all such intermediate homologous sequences will lead to a significant reinforcement of the weight for the original pair $(x, y)$. True homologous relationships are mutually reinforcing across the set of homologs.\n    -   **For a spurious pair $(x \\in S_i, w \\in S_N)$ with $i < N$**: For this pair's weight to be increased, there must be transitive support through some intermediate residue $z \\in S_k$. Let's consider the required supporting pairs: $(x, z)$ and $(z, w)$.\n        - If $k < N$, the pair $(x, z)$ might be a valid, high-weight homologous pair. However, the pair $(z, w)$ involves the permuted sequence $S_N$. As established, pairs involving $S_N$ are spurious and have low initial weights.\n        - The probability of finding a residue $z$ that, by pure chance, aligns strongly with both $x$ and $w$ across different, unrelated pairwise alignments is exceedingly low.\n        - Therefore, the transitive support for any spurious pair involving $S_N$ will be minimal or nonexistent. The consistency extension step will fail to find a strong network of evidence for these pairs. Their weights will remain low.\n\n3.  **Final MSA Construction**: T-Coffee uses the final, extended library of weighted pairs to guide the construction of the multiple sequence alignment, typically through a progressive alignment strategy. The objective is to build an MSA that maximizes the sum of weights of the included residue pairs.\n    -   The pairs corresponding to the true homologous relationships among $S_1, \\dots, S_{N-1}$ have been assigned very high weights. The algorithm will strongly prioritize satisfying these constraints. This means the alignment of the homologous subset $S_1, \\dots, S_{N-1}$ will be high-quality and largely unaffected by the presence of $S_N$.\n    -   The spurious pairs involving $S_N$ have very low weights. Forcing $S_N$ to align with the core homologous block would require breaking many high-weight pairs within that block. The algorithm will avoid this. Instead, it will find that the highest-scoring alignment is one that effectively isolates $S_N$, placing it with many gaps against the well-aligned columns of the homologous sequences. The alignment of $S_N$ will reflect its lack of consistent support in the library.\n\n**Option-by-Option Analysis**\n\n**A. The permuted sequence $S_N$ generates many incorrect residue-residue pairs that receive strong reinforcement during consistency extension because they can be chained through multiple sequences, thereby propagating errors and substantially degrading the alignment of $S_1, \\dots, S_{N-1}$.**\nThis statement is incorrect. The core principle of consistency extension is to filter out exactly this type of noise. Spurious pairs lack the transitive support from a network of related sequences required for strong reinforcement. Thus, they are down-weighted, not amplified.\n\n**B. The incorrect residue-residue pairs involving $S_N$ lack transitive support from the other homologous sequences and therefore receive low weights after consistency extension; as a result, the alignment of $S_1, \\dots, S_{N-1}$ remains largely stable, and $S_N$ is placed with many gaps or weakly supported columns.**\nThis statement is correct. It accurately describes the entire process. The lack of transitive support for spurious pairs involving $S_N$ is the key mechanism. This leads to low final weights for these pairs. Consequently, the high-weight pairs among the true homologs $S_1, \\dots, S_{N-1}$ dominate the final alignment construction, preserving their alignment quality. $S_N$ cannot be integrated without penalty and is therefore marginalized in the final MSA, typically through the introduction of many gaps.\n\n**C. Because $S_N$ preserves residue composition, it is globally aligned almost perfectly to $S_1$, and consistency extension amplifies these matches so that $S_N$ ends up aligned nearly identically to $S_1$ and to the rest of the set.**\nThis statement is incorrect. Sequence alignment relies on positional conservation, not merely residue composition. A random permutation will result in a very low-quality pairwise alignment with the original sequence. There will be no strong initial matches to amplify.\n\n**D. T-Coffee deterministically identifies that $S_N$ is a permutation of $S_1$ and removes $S_N$ from the analysis before library construction, so the final alignment is identical to the alignment produced from $S_1, \\dots, S_{N-1}$.**\nThis statement is incorrect. T-Coffee is an algorithm that operates on the general problem of multiple sequence alignment based on pairwise information. It does not include a specific, heuristic pre-processing step to detect permutations or other special-case relationships between sequences. It processes all sequences provided as input through its standard workflow.\n\n**E. The consistency extension assigns uniformly high weights to all residue-residue pairs to avoid bias, so the effect of including $S_N$ depends only on the guide tree and not on the library.**\nThis statement is incorrect. It fundamentally misrepresents the consistency extension step. The purpose of this step is precisely to assign differential weights based on the degree of support within the library. The library of weights is central to the entire T-Coffee method, including the final alignment phase. Uniform weighting is the antithesis of the T-Coffee philosophy.", "answer": "$$\\boxed{B}$$", "id": "2381633"}, {"introduction": "This final challenge moves from theory to practice, asking you to implement a simplified consistency-based predictor from the ground up. You will combine the classic Needleman-Wunsch algorithm with the consistency logic to predict motif placement and, more importantly, explore a scenario where this logic can be intentionally misled. This hands-on implementation not only demystifies the algorithm but also deepens your understanding of its assumptions and potential pitfalls [@problem_id:2381655].", "problem": "Design and implement, from first principles, a minimal consistency-based multiple alignment predictor for a triplet of sequences based on the core ideas underlying the T-Coffee (Tree-based Consistency Objective Function For alignment Evaluation) approach. Your program will use pairwise global alignments to build a residue-residue library and then apply a single-step consistency projection through an intermediate sequence to predict the placement of a conserved motif between two target sequences.\n\nYou must proceed using the following foundations and definitions:\n\n- Pairwise global alignment is computed using the Needlemanâ€“Wunsch dynamic programming recurrence with linear gap penalty. For two sequences $X = x_1 x_2 \\dots x_{L_X}$ and $Y = y_1 y_2 \\dots y_{L_Y}$, define the dynamic programming matrix $F$ by\n$$\nF(0,0)=0,\\quad F(i,0)=i \\cdot g,\\quad F(0,j)=j \\cdot g,\n$$\nand for $i \\ge 1$, $j \\ge 1$,\n$$\nF(i,j) = \\max\\left\\{\n\\begin{array}{l}\nF(i-1,j-1) + s(x_i,y_j),\\\\\nF(i-1,j) + g,\\\\\nF(i,j-1) + g\n\\end{array}\n\\right.\n$$\nwith scoring $s(a,b)=+2$ if $a=b$, otherwise $s(a,b)=-1$, and linear gap penalty $g=-2$. In case of ties when selecting the maximizing predecessor during traceback, you must break ties deterministically in the order: diagonal, then up, then left.\n\n- From an optimal global alignment of $X$ and $Y$, construct a binary residue-residue weight matrix $w_{XY}$ of shape $L_X \\times L_Y$ where $w_{XY}(i,j)=1$ if and only if residues $x_i$ and $y_j$ are aligned to each other in the chosen optimal alignment (i.e., a diagonal traceback step aligns them), and $w_{XY}(i,j)=0$ otherwise.\n\n- Given three sequences $A$, $B$, $C$, define the single-step consistency projection score from $A$ to $C$ via $B$ as the matrix $S$ with\n$$\nS(i,j) = \\sum_{k=1}^{L_B} w_{AB}(i,k)\\cdot w_{BC}(k,j).\n$$\n\n- Let a conserved motif $M$ of length $m$ appear exactly once in $A$ and exactly once in $C$. Let $i_0$ be the $1$-based start index of $M$ in $A$ and $j^\\star$ be the $1$-based start index of $M$ in $C$. Define the block projection score for placing the motif starting at position $j$ in $C$ as\n$$\nF_{\\text{block}}(j) = \\sum_{t=0}^{m-1} S(i_0+t,\\; j+t),\n$$\nfor all valid $j$ such that $1 \\le j \\le L_C - m + 1$. The predicted start $\\hat{j}$ is the $j$ that maximizes $F_{\\text{block}}(j)$; in case of ties, choose the smallest $j$.\n\n- Define an incorrect placement indicator as $1$ if $\\hat{j} \\ne j^\\star$, and $0$ otherwise.\n\nAll sequences in this problem have length $L_A=L_B=L_C=10$ (ten residues). Angles and physical units do not apply. All outputs are unitless integers.\n\nImplement the above and evaluate the following test suite. Each test case provides sequences $A$, $B$, $C$ of length $10$ and a motif string $M$ of length $m=3$ to be projected from $A$ to $C$ via $B$. For each case, compute the incorrect placement indicator defined above.\n\n- Case $1$ (intended misleading consistency through $B$):\n  - $A=$ \"KKKWGYLLLQ\"\n  - $B=$ \"KKKRRRLLLQ\"\n  - $C=$ \"AAAWGYRRRR\"\n  - $M=$ \"WGY\"\n  - Rationale: $A$ and $C$ share the exact motif $M$ at their true locations, but $B$ introduces a high-scoring alternative path that can project the motif to a wrong region in $C$.\n\n- Case $2$ (happy path where consistency agrees with the true motif placement):\n  - $A=$ \"KKKWGYLLLQ\"\n  - $B=$ \"KKKWGYLLLQ\"\n  - $C=$ \"AAAWGYRRRR\"\n  - $M=$ \"WGY\"\n\n- Case $3$ (boundary condition with motif at the start):\n  - $A=$ \"WGYLLLLLLL\"\n  - $B=$ \"WGYLLLLLLL\"\n  - $C=$ \"WGYRRRRRRR\"\n  - $M=$ \"WGY\"\n\nYour program should produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets, in the order of the cases above; for example, an output of the form \"[r1,r2,r3]\" where each $r_i \\in \\{0,1\\}$ is the incorrect placement indicator for case $i$.", "solution": "The problem is valid as it is scientifically grounded in the principles of computational biology, well-posed with all necessary parameters and tie-breaking rules defined, and objective in its formulation. It requests the implementation of a simplified consistency-based alignment method inspired by the T-Coffee algorithm.\n\nThe core of the solution lies in a multi-step process for each test case, involving three sequences denoted as $A$, $B$, and $C$.\n\nFirst, we must establish a library of pairwise residue alignments. This is achieved by performing a global alignment for the pairs $(A, B)$ and $(B, C)$ using the Needleman-Wunsch dynamic programming algorithm. For two sequences $X = x_1 x_2 \\dots x_{L_X}$ and $Y = y_1 y_2 \\dots y_{L_Y}$, the algorithm computes a score matrix $F$ of size $(L_X+1) \\times (L_Y+1)$. The matrix is initialized as $F(0,0)=0$, $F(i,0)=i \\cdot g$ for $i>0$, and $F(0,j)=j \\cdot g$ for $j>0$, where $g=-2$ is the linear gap penalty. The recurrence relation for $i \\ge 1, j \\ge 1$ is:\n$$\nF(i,j) = \\max\\left\\{\n\\begin{array}{l}\nF(i-1,j-1) + s(x_i,y_j)\\\\\nF(i-1,j) + g\\\\\nF(i,j-1) + g\n\\end{array}\n\\right.\n$$\nThe scoring function $s(a,b)$ is defined as $+2$ for a match ($a=b$) and $-1$ for a mismatch ($a \\ne b$). During the computation, we also store pointers to determine the origin of the maximum score for each cell, which is used for the traceback phase. The specified tie-breaking rule (diagonal, then up, then left) ensures a unique optimal alignment.\n\nSecond, from the optimal alignment path obtained by tracing back from $F(L_X, L_Y)$, we construct a binary residue-residue weight matrix $w_{XY}$. This matrix, of shape $L_X \\times L_Y$, serves as a concise representation of the alignment. An entry $w_{XY}(i,j)$ is set to $1$ if residue $x_i$ is aligned with residue $y_j$ in the optimal alignment (corresponding to a diagonal move in the traceback); otherwise, $w_{XY}(i,j)=0$. These matrices are generated for both pairs, yielding $w_{AB}$ and $w_{BC}$.\n\nThird, we apply the principle of single-step consistency. The T-Coffee approach leverages information from multiple pairwise alignments to inform a multiple alignment. In this simplified model, we project alignment information from the pair $(A, B)$ and $(B, C)$ to infer a relationship between $A$ and $C$. The consistency projection score matrix $S$ is calculated as the product of the two weight matrices:\n$$\nS(i,j) = \\sum_{k=1}^{L_B} w_{AB}(i,k) \\cdot w_{BC}(k,j)\n$$\nThe value $S(i,j)$ represents the number of residues in sequence $B$ that are aligned to both residue $A_i$ and residue $C_j$ in their respective pairwise alignments. A non-zero score implies that there is a consistent alignment path from $A_i$ to $C_j$ through sequence $B$.\n\nFourth, we use the consistency matrix $S$ to predict the location of a conserved motif $M$ of length $m$. Given the known starting position $i_0$ of the motif in sequence $A$, we evaluate the likelihood of the motif starting at each possible position $j$ in sequence $C$. This is done by calculating a block projection score, $F_{\\text{block}}(j)$, which sums the consistency scores over the length of the motif:\n$$\nF_{\\text{block}}(j) = \\sum_{t=0}^{m-1} S(i_0+t, j+t)\n$$\nThis is calculated for all valid starting positions $j$ in $C$, from $1$ to $L_C - m + 1$. A higher $F_{\\text{block}}(j)$ indicates stronger consistent evidence for placing the motif starting at position $j$.\n\nFinally, the predicted starting position of the motif in $C$, denoted $\\hat{j}$, is the position $j$ that maximizes $F_{\\text{block}}(j)$. In case of a tie, the smallest $j$ is chosen. This prediction $\\hat{j}$ is then compared with the true starting position of the motif, $j^\\star$. An incorrect placement indicator is set to $1$ if $\\hat{j} \\ne j^\\star$, and to $0$ if they are equal. This procedure is repeated for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It implements a simplified T-Coffee consistency-based prediction.\n    \"\"\"\n\n    # --- Algorithm Parameters ---\n    MATCH_SCORE = 2\n    MISMATCH_SCORE = -1\n    GAP_PENALTY = -2\n\n    def get_score(res1, res2):\n        \"\"\"Calculates match/mismatch score.\"\"\"\n        return MATCH_SCORE if res1 == res2 else MISMATCH_SCORE\n\n    def needleman_wunsch_traceback(seq1, seq2):\n        \"\"\"\n        Performs global alignment using Needleman-Wunsch and returns a list of\n        1-based index pairs for aligned residues.\n        \"\"\"\n        L1, L2 = len(seq1), len(seq2)\n        F = np.zeros((L1 + 1, L2 + 1))\n        # Pointer matrix: 0=diagonal, 1=up, 2=left\n        P = np.zeros((L1 + 1, L2 + 1), dtype=int)\n\n        # Initialize DP matrix\n        for i in range(L1 + 1):\n            F[i, 0] = i * GAP_PENALTY\n        for j in range(L2 + 1):\n            F[0, j] = j * GAP_PENALTY\n            \n        # Fill DP and Pointer matrices\n        for i in range(1, L1 + 1):\n            for j in range(1, L2 + 1):\n                s_val = get_score(seq1[i - 1], seq2[j - 1])\n                diag_score = F[i - 1, j - 1] + s_val\n                up_score = F[i - 1, j] + GAP_PENALTY\n                left_score = F[i, j - 1] + GAP_PENALTY\n                \n                max_score = max(diag_score, up_score, left_score)\n                F[i, j] = max_score\n                \n                # Tie-breaking rule: diagonal > up > left\n                if diag_score == max_score:\n                    P[i, j] = 0\n                elif up_score == max_score:\n                    P[i, j] = 1\n                else:\n                    P[i, j] = 2\n        \n        # Traceback to find aligned pairs\n        aligned_pairs = []\n        i, j = L1, L2\n        while i > 0 and j > 0:\n            ptr = P[i, j]\n            if ptr == 0:  # Diagonal move\n                aligned_pairs.append((i, j))\n                i -= 1\n                j -= 1\n            elif ptr == 1:  # Up move\n                i -= 1\n            else:  # Left move\n                j -= 1\n        \n        return aligned_pairs\n\n    def build_weight_matrix(seq1_len, seq2_len, aligned_pairs):\n        \"\"\"Builds the binary residue-residue weight matrix from aligned pairs.\"\"\"\n        w = np.zeros((seq1_len, seq2_len), dtype=int)\n        for i_1based, j_1based in aligned_pairs:\n            # Convert 1-based alignment indices to 0-based matrix indices\n            w[i_1based - 1, j_1based - 1] = 1\n        return w\n\n    def solve_case(A, B, C, M):\n        \"\"\"\n        Solves for a single test case and returns the incorrect placement indicator.\n        \"\"\"\n        L_A, L_B, L_C = len(A), len(B), len(C)\n        m = len(M)\n\n        # 1. Compute pairwise alignments and corresponding weight matrices\n        aligned_pairs_AB = needleman_wunsch_traceback(A, B)\n        w_AB = build_weight_matrix(L_A, L_B, aligned_pairs_AB)\n        \n        aligned_pairs_BC = needleman_wunsch_traceback(B, C)\n        w_BC = build_weight_matrix(L_B, L_C, aligned_pairs_BC)\n\n        # 2. Compute the consistency projection score matrix S\n        S = np.dot(w_AB, w_BC)\n\n        # 3. Find true motif locations (1-based)\n        i_0 = A.find(M) + 1\n        j_star = C.find(M) + 1\n\n        # 4. Compute block projection scores F_block(j) for all possible starts in C\n        f_block_scores = []\n        # j is the 1-based start position in C. Loop from 1 to L_C - m + 1\n        possible_j_starts = range(1, L_C - m + 2)\n        \n        for j_1based in possible_j_starts:\n            score = 0\n            for t in range(m):\n                # Convert 1-based formula indices to 0-based matrix indices\n                idx_A = (i_0 + t) - 1\n                idx_C = (j_1based + t) - 1\n                score += S[idx_A, idx_C]\n            f_block_scores.append(score)\n\n        # 5. Find predicted start j_hat\n        # list.index finds the first occurrence of max, fulfilling the tie-breaking rule\n        max_score = max(f_block_scores) if f_block_scores else -1\n        predicted_idx = f_block_scores.index(max_score)\n        # The index in the scores list corresponds to a 1-based j\n        # Index 0 -> j=1, Index 1 -> j=2, etc.\n        j_hat = predicted_idx + 1\n\n        # 6. Compute and return the incorrect placement indicator\n        indicator = 1 if j_hat != j_star else 0\n        return indicator\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"KKKWGYLLLQ\", \"KKKRRRLLLQ\", \"AAAWGYRRRR\", \"WGY\"),\n        (\"KKKWGYLLLQ\", \"KKKWGYLLLQ\", \"AAAWGYRRRR\", \"WGY\"),\n        (\"WGYLLLLLLL\", \"WGYLLLLLLL\", \"WGYRRRRRRR\", \"WGY\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B, C, M = case\n        result = solve_case(A, B, C, M)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2381655"}]}