{"hands_on_practices": [{"introduction": "This practice demystifies why bioinformaticians prefer Position-Specific Scoring Matrices (PSSMs) over simpler Position Weight Matrices (PWMs). By working through a concrete example [@problem_id:2415079], you will see how incorporating background nucleotide frequencies can alter the scoring landscape, sometimes even reversing the ranking of sequences. This exercise highlights the foundational role of the log-odds score in distinguishing true signals from background noise.", "problem": "Consider a DNA motif of length $2$ represented by the following Position Weight Matrix (PWM; probabilities) over the alphabet $\\{A,C,G,T\\}$:\n\nPosition $1$: $P(A)=0.5$, $P(C)=0.2$, $P(G)=0.2$, $P(T)=0.1$.\n\nPosition $2$: $P(A)=0.4$, $P(C)=0.3$, $P(G)=0.2$, $P(T)=0.1$.\n\nAssume the background nucleotide frequencies are $b(A)=0.7$, $b(C)=0.1$, $b(G)=0.1$, $b(T)=0.1$.\n\nLet sequence $\\mathcal{A}$ be the dinucleotide with letters $A$ at both positions (i.e., $A$-$A$), and let sequence $\\mathcal{B}$ be the dinucleotide with letters $C$ at both positions (i.e., $C$-$C$).\n\nUsing the standard definition of a Position-Specific Scoring Matrix (PSSM; log-odds), the log-odds score of a sequence $s=s_1s_2$ is\n$$\nS(s)=\\sum_{i=1}^{2}\\ln\\!\\left(\\frac{P_i(s_i)}{b(s_i)}\\right),\n$$\nwhere $P_i(x)$ is the PWM probability of letter $x$ at position $i$, $b(x)$ is the background frequency of $x$, and $\\ln$ denotes the natural logarithm.\n\nCompute the difference $\\Delta=S(\\mathcal{B})-S(\\mathcal{A})$. Round your answer to $4$ significant figures.", "solution": "First, we extract the givens from the problem statement.\nThe motif length is $2$.\nThe alphabet is $\\{A, C, G, T\\}$.\nThe Position Weight Matrix (PWM) probabilities are:\nFor position $i=1$: $P_1(A)=0.5$, $P_1(C)=0.2$, $P_1(G)=0.2$, $P_1(T)=0.1$.\nFor position $i=2$: $P_2(A)=0.4$, $P_2(C)=0.3$, $P_2(G)=0.2$, $P_2(T)=0.1$.\nThe background nucleotide frequencies are: $b(A)=0.7$, $b(C)=0.1$, $b(G)=0.1$, $b(T)=0.1$.\nSequence $\\mathcal{A}$ is defined as the dinucleotide $AA$.\nSequence $\\mathcal{B}$ is defined as the dinucleotide $CC$.\nThe log-odds score for a sequence $s=s_1s_2$ is defined by the formula:\n$$S(s)=\\sum_{i=1}^{2}\\ln\\!\\left(\\frac{P_i(s_i)}{b(s_i)}\\right)$$\nThe task is to compute the difference $\\Delta=S(\\mathcal{B})-S(\\mathcal{A})$ and round the answer to $4$ significant figures.\n\nNext, we validate the problem statement.\nThe problem is scientifically grounded. It utilizes standard concepts from bioinformatics, namely Position Weight Matrices (PWMs) and Position-Specific Scoring Matrices (PSSMs), and the correct log-odds scoring function. All probabilities and background frequencies are non-negative and sum to $1$ where appropriate ($0.5+0.2+0.2+0.1=1.0$, $0.4+0.3+0.2+0.1=1.0$, $0.7+0.1+0.1+0.1=1.0$). The problem is well-posed, as all necessary information for a unique numerical solution is provided. The language is objective and precise. There are no contradictions, missing data, or ambiguities. The problem is therefore deemed valid. We proceed with the solution.\n\nThe log-odds score $S(s)$ for a sequence $s = s_1s_2$ is given by the sum of scores at each position:\n$$S(s) = \\ln\\left(\\frac{P_1(s_1)}{b(s_1)}\\right) + \\ln\\left(\\frac{P_2(s_2)}{b(s_2)}\\right)$$\n\nFirst, we calculate the score for sequence $\\mathcal{A} = AA$. For this sequence, $s_1 = A$ and $s_2 = A$.\nThe score $S(\\mathcal{A})$ is:\n$$S(\\mathcal{A}) = \\ln\\left(\\frac{P_1(A)}{b(A)}\\right) + \\ln\\left(\\frac{P_2(A)}{b(A)}\\right)$$\nSubstituting the given values:\n$$S(\\mathcal{A}) = \\ln\\left(\\frac{0.5}{0.7}\\right) + \\ln\\left(\\frac{0.4}{0.7}\\right)$$\nUsing the property of logarithms $\\ln(x) + \\ln(y) = \\ln(xy)$:\n$$S(\\mathcal{A}) = \\ln\\left(\\frac{0.5}{0.7} \\times \\frac{0.4}{0.7}\\right) = \\ln\\left(\\frac{0.2}{0.49}\\right)$$\n\nNext, we calculate the score for sequence $\\mathcal{B} = CC$. For this sequence, $s_1 = C$ and $s_2 = C$.\nThe score $S(\\mathcal{B})$ is:\n$$S(\\mathcal{B}) = \\ln\\left(\\frac{P_1(C)}{b(C)}\\right) + \\ln\\left(\\frac{P_2(C)}{b(C)}\\right)$$\nSubstituting the given values:\n$$S(\\mathcal{B}) = \\ln\\left(\\frac{0.2}{0.1}\\right) + \\ln\\left(\\frac{0.3}{0.1}\\right) = \\ln(2) + \\ln(3)$$\nUsing the property of logarithms again:\n$$S(\\mathcal{B}) = \\ln(2 \\times 3) = \\ln(6)$$\n\nWe are required to compute the difference $\\Delta = S(\\mathcal{B}) - S(\\mathcal{A})$.\n$$\\Delta = \\ln(6) - \\ln\\left(\\frac{0.2}{0.49}\\right)$$\nUsing the property of logarithms $\\ln(x) - \\ln(y) = \\ln(x/y)$:\n$$\\Delta = \\ln\\left(\\frac{6}{0.2/0.49}\\right) = \\ln\\left(\\frac{6 \\times 0.49}{0.2}\\right)$$\nCalculation of the argument of the logarithm:\n$$\\frac{6 \\times 0.49}{0.2} = \\frac{2.94}{0.2} = 14.7$$\nSo, the exact value of the difference is:\n$$\\Delta = \\ln(14.7)$$\nNow, we compute the numerical value and round it to $4$ significant figures.\n$$\\Delta \\approx 2.687847387...$$\nRounding to $4$ significant figures gives $2.688$.\nThis is the final result.", "answer": "$$\\boxed{2.688}$$", "id": "2415079"}, {"introduction": "Applying a PSSM to scan a genome requires awareness of a common statistical trap: biased nucleotide composition. This practice [@problem_id:2415063] simulates scanning a low-complexity, AT-rich region to demonstrate how background bias can artificially inflate scores and generate false positives. Mastering this concept is key to interpreting search results correctly and a crucial step towards robust bioinformatic analyses.", "problem": "You are scanning deoxyribonucleic acid (DNA) for a transcription factor binding motif using a Position-Specific Scoring Matrix (PSSM). The PSSM is defined by position-specific nucleotide probabilities for motif length $4$ as follows (rows are positions $1$ through $4$; columns list probabilities for A, C, G, T in that order):\n\n- Position $1$: $(0.70,\\;0.10,\\;0.05,\\;0.15)$\n- Position $2$: $(0.25,\\;0.10,\\;0.05,\\;0.60)$\n- Position $3$: $(0.65,\\;0.10,\\;0.05,\\;0.20)$\n- Position $4$: $(0.15,\\;0.10,\\;0.05,\\;0.70)$\n\nAssume a genome-wide background where each nucleotide has probability $0.25$, and assume log-likelihood ratio scoring uses the natural logarithm (units: nats). Consider scanning the following two genomic segments with a sliding window of length $4$:\n\n- AT-rich segment $S_{\\mathrm{AT}}$: 5'- TTTATATATTTAAAATAT -3' (length $18$)\n- Compositionally balanced control $S_{\\mathrm{ctrl}}$: 5'- CGTACGCGTACG -3' (length $12$)\n\nWhich of the following statements are correct?\n\nA. Masking low-complexity or simple-repeat regions prior to PSSM scanning reduces false positives because local compositional bias causes many windows to obtain elevated scores under the log-odds model even without true motif instances.\n\nB. Among the windows “ATAT”, “TATA”, “TTAA”, and “ACGT” that occur in the sequences above, “ATAT” achieves the largest log-odds score under the given PSSM and background, providing an example of a high-scoring but potentially spurious hit in the AT-rich segment.\n\nC. The main purpose of masking low-complexity regions is to speed up scanning; masking has negligible impact on the expected number of false positives at any fixed score threshold.\n\nD. If low-complexity regions are not masked, the null distribution of PSSM scores is biased by local base composition, and reported $P$-values or $E$-values for A/T-rich matches tend to be too small (anti-conservative).\n\nE. PSSMs inherently correct for local base composition at each genomic locus, so repeats and low-complexity segments neither inflate scores nor bias statistical significance.", "solution": "We begin with a critical validation of the problem statement.\n\n### Step 1: Extract Givens\n\n-   **Motif Model**: A Position-Specific Scoring Matrix (PSSM) for a motif of length $L=4$. The probabilities of observing nucleotide $N \\in \\{A, C, G, T\\}$ at each position $i \\in \\{1, 2, 3, 4\\}$ are as follows:\n    -   Position $1$: $P(N_1) = (0.70, 0.10, 0.05, 0.15)$ for $(A, C, G, T)$.\n    -   Position $2$: $P(N_2) = (0.25, 0.10, 0.05, 0.60)$ for $(A, C, G, T)$.\n    -   Position $3$: $P(N_3) = (0.65, 0.10, 0.05, 0.20)$ for $(A, C, G, T)$.\n    -   Position $4$: $P(N_4) = (0.15, 0.10, 0.05, 0.70)$ for $(A, C, G, T)$.\n\n-   **Background Model**: A uniform background where the probability of each nucleotide is $P_{bg}(N) = 0.25$.\n\n-   **Scoring Scheme**: Log-likelihood ratio scoring using the natural logarithm ($\\ln$), with scores in units of nats. The score for a sequence $S = s_1s_2s_3s_4$ is $Score(S) = \\sum_{i=1}^{4} \\ln\\left(\\frac{P(s_i \\text{ at position } i)}{P_{bg}(s_i)}\\right)$.\n\n-   **Sequences for Scanning**:\n    -   $S_{\\mathrm{AT}}$: 5'- TTTATATATTTAAAATAT -3', with length 18.\n    -   $S_{\\mathrm{ctrl}}$: 5'- CGTACGCGTACG -3', with length $12$.\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientific Grounding**: The problem is firmly grounded in computational biology and bioinformatics. PSSMs, log-odds scoring, background models, compositional bias, and masking low-complexity regions are all standard and fundamental concepts in motif finding.\n-   **Well-Posed**: The problem is well-posed. It provides all necessary data (PSSM probabilities, background model) to calculate scores and evaluate the conceptual statements.\n-   **Objective**: The problem is stated using precise, objective, and technical language.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It does not contain any inconsistencies and its scientific and logical integrity are sound. We may proceed to a full solution.\n\n### Solution Derivation\n\nThe score for a sequence $S = s_1s_2s_3s_4$ is calculated as the sum of log-odds scores for each position:\n$$Score(S) = \\sum_{i=1}^{4} \\ln\\left(\\frac{P_M(s_i, i)}{P_{bg}(s_i)}\\right)$$\nwhere $P_M(s_i, i)$ is the probability of nucleotide $s_i$ at position $i$ from the motif model, and $P_{bg}(s_i) = 0.25$ is the background probability.\n\nLet us pre-calculate the log-odds scoring matrix, which we denote as $M$. The entry $M_{i,N}$ is the score for nucleotide $N$ at position $i$.\n\n-   **Position $1$**:\n    -   $M_{1,A} = \\ln(0.70/0.25) = \\ln(2.8) \\approx 1.0296$\n    -   $M_{1,C} = \\ln(0.10/0.25) = \\ln(0.4) \\approx -0.9163$\n    -   $M_{1,G} = \\ln(0.05/0.25) = \\ln(0.2) \\approx -1.6094$\n    -   $M_{1,T} = \\ln(0.15/0.25) = \\ln(0.6) \\approx -0.5108$\n\n-   **Position $2$**:\n    -   $M_{2,A} = \\ln(0.25/0.25) = \\ln(1) = 0$\n    -   $M_{2,C} = \\ln(0.10/0.25) = \\ln(0.4) \\approx -0.9163$\n    -   $M_{2,G} = \\ln(0.05/0.25) = \\ln(0.2) \\approx -1.6094$\n    -   $M_{2,T} = \\ln(0.60/0.25) = \\ln(2.4) \\approx 0.8755$\n\n-   **Position $3$**:\n    -   $M_{3,A} = \\ln(0.65/0.25) = \\ln(2.6) \\approx 0.9555$\n    -   $M_{3,C} = \\ln(0.10/0.25) = \\ln(0.4) \\approx -0.9163$\n    -   $M_{3,G} = \\ln(0.05/0.25) = \\ln(0.2) \\approx -1.6094$\n    -   $M_{3,T} = \\ln(0.20/0.25) = \\ln(0.8) \\approx -0.2231$\n\n-   **Position $4$**:\n    -   $M_{4,A} = \\ln(0.15/0.25) = \\ln(0.6) \\approx -0.5108$\n    -   $M_{4,C} = \\ln(0.10/0.25) = \\ln(0.4) \\approx -0.9163$\n    -   $M_{4,G} = \\ln(0.05/0.25) = \\ln(0.2) \\approx -1.6094$\n    -   $M_{4,T} = \\ln(0.70/0.25) = \\ln(2.8) \\approx 1.0296$\n\nNow, we evaluate each statement.\n\n**A. Masking low-complexity or simple-repeat regions prior to PSSM scanning reduces false positives because local compositional bias causes many windows to obtain elevated scores under the log-odds model even without true motif instances.**\n\nThe log-odds score is predicated on a null model of a uniform, random background. Genomic regions with low complexity (e.g., AT-rich regions, homopolymer runs) violate this assumption; their local nucleotide composition is highly skewed. The provided PSSM is biased towards `A` and `T`. When scanning an AT-rich region, windows are more likely to contain `A`s and `T`s simply due to the local composition. Since the PSSM assigns high scores to `A` and `T` at most positions, random windows from this region will achieve systematically higher scores than random windows from a compositionally balanced region. This leads to an increased rate of high-scoring hits that do not represent true functional binding sites, i.e., an increase in false positives. Masking these regions—excluding them from the scan—is a standard and necessary procedure to mitigate this statistical artifact and reduce the false positive rate. The statement is a correct description of a fundamental issue in sequence analysis.\n**Verdict: Correct**\n\n**B. Among the windows “ATAT”, “TATA”, “TTAA”, and “ACGT” that occur in the sequences above, “ATAT” achieves the largest log-odds score under the given PSSM and background, providing an example of a high-scoring but potentially spurious hit in the AT-rich segment.**\n\nWe must calculate the score for each specified $4$-mer.\n-   $Score(\\text{ATAT}) = M_{1,A} + M_{2,T} + M_{3,A} + M_{4,T} = \\ln(2.8) + \\ln(2.4) + \\ln(2.6) + \\ln(2.8) \\approx 1.0296 + 0.8755 + 0.9555 + 1.0296 = 3.8902$\n-   $Score(\\text{TATA}) = M_{1,T} + M_{2,A} + M_{3,T} + M_{4,A} = \\ln(0.6) + \\ln(1) + \\ln(0.8) + \\ln(0.6) \\approx -0.5108 + 0 - 0.2231 - 0.5108 = -1.2447$\n-   $Score(\\text{TTAA}) = M_{1,T} + M_{2,T} + M_{3,A} + M_{4,A} = \\ln(0.6) + \\ln(2.4) + \\ln(2.6) + \\ln(0.6) \\approx -0.5108 + 0.8755 + 0.9555 - 0.5108 = 0.8094$\n-   $Score(\\text{ACGT}) = M_{1,A} + M_{2,C} + M_{3,G} + M_{4,T} = \\ln(2.8) + \\ln(0.4) + \\ln(0.2) + \\ln(2.8) \\approx 1.0296 - 0.9163 - 1.6094 + 1.0296 = -0.4665$\n\nComparing the scores, $3.8902 > 0.8094 > -0.4665 > -1.2447$. The sequence `ATAT` indeed has the largest score. This sequence occurs in the AT-rich segment $S_{\\mathrm{AT}}$. As explained for option A, such a high score in a compositionally biased region that matches the bias of the PSSM is a classic example of a potentially spurious hit. The high score arises from the confluence of the motif's preference and the background's composition, not necessarily from a specific, biologically functional sequence pattern.\n**Verdict: Correct**\n\n**C. The main purpose of masking low-complexity regions is to speed up scanning; masking has negligible impact on the expected number of false positives at any fixed score threshold.**\n\nThis statement is factually incorrect. While masking does reduce the total length of sequence to be scanned and thus offers a computational speedup, this is a secondary benefit. The primary, and scientifically critical, purpose is to improve the statistical validity of the search by removing regions where the background model is grossly violated, thereby preventing a flood of false positives. The impact on the number of false positives is far from negligible; for PSSMs that are themselves compositionally biased (like the one given), the effect can be dramatic, reducing false positives by orders of magnitude.\n**Verdict: Incorrect**\n\n**D. If low-complexity regions are not masked, the null distribution of PSSM scores is biased by local base composition, and reported $P$-values or $E$-values for A/T-rich matches tend to be too small (anti-conservative).**\n\nThe null distribution of scores, from which $P$-values and $E$-values are calculated, is theoretically derived assuming the background model is correct (i.e., uniform i.i.d. nucleotides with $P=0.25$). In a compositionally biased region (e.g., AT-rich), the empirical distribution of scores will be shifted relative to this theoretical null. Specifically, for an AT-biased PSSM in an AT-rich region, scores will be systematically inflated. A high score observed in such a region might seem highly significant (have a very small $P$-value) when compared to the theoretical null distribution. However, the probability of observing such a score by chance *given the local AT-rich composition* is much higher. Thus, the $P$-value calculated using the global, uniform background model is artificially small (an underestimate of the true local significance), which is the definition of an anti-conservative statistical test. It leads to an overestimation of significance. This statement is a precise and correct description of the statistical problem.\n**Verdict: Correct**\n\n**E. PSSMs inherently correct for local base composition at each genomic locus, so repeats and low-complexity segments neither inflate scores nor bias statistical significance.**\n\nThis statement is fundamentally false. A standard PSSM, as defined in this problem, uses a single, fixed background model ($P_{bg}$) for the entire scan. It does not dynamically adjust $P_{bg}$ to reflect the local nucleotide composition at each position being scanned. Because the PSSM formalism is \"unaware\" of local compositional changes, it does not and cannot \"inherently correct\" for them. It is precisely this lack of correction that leads to the score inflation and biased statistics described in options A and D. While advanced methods exist to address this (e.g., using adaptive background models), this is not an inherent feature of the basic PSSM itself.\n**Verdict: Incorrect**", "answer": "$$\\boxed{ABD}$$", "id": "2415063"}, {"introduction": "This final practice moves beyond scoring existing sequences to the creative challenge of designing a sequence to meet a specific criterion. You are tasked with constructing a DNA sequence that produces a precise target score when evaluated by a given PSSM [@problem_id:2415071]. This algorithmic puzzle requires a deeper understanding of the PSSM's additive structure and provides an excellent opportunity to apply dynamic programming to a non-trivial bioinformatics problem.", "problem": "You are given a position-specific scoring matrix (PSSM) for deoxyribonucleic acid (DNA) of length $L$, represented as a $4 \\times L$ integer matrix $W$, where rows correspond to nucleotides in the fixed order adenine (A), cytosine (C), guanine (G), thymine (T). For an integer-encoded DNA sequence $x = (x_0, x_1, \\dots, x_{L-1})$ with $x_i \\in \\{0,1,2,3\\}$ corresponding respectively to A, C, G, T, the PSSM score is defined by\n$$\n\\mathrm{Score}(x; W) \\equiv \\sum_{i=0}^{L-1} W[x_i, i].\n$$\nGiven an integer target score $S$, the task is to produce one integer-encoded DNA sequence $x$ of length $L$ such that $\\mathrm{Score}(x; W) = S$. If there are multiple such sequences, you must return the lexicographically smallest sequence under the usual lexicographic order on integer tuples induced by $0 < 1 < 2 < 3$. If no sequence achieves $\\mathrm{Score}(x; W) = S$, you must output the sentinel list $[-1]$. The empty sequence of length $0$ is allowed when $L=0$, in which case the only achievable score is $0$; if $L=0$ and $S=0$, return the empty list $[]$, and if $L=0$ and $S \\neq 0$, return $[-1]$.\n\nEncoding requirement: represent a DNA sequence as a list of integers using A $\\mapsto$ $0$, C $\\mapsto$ $1$, G $\\mapsto$ $2$, T $\\mapsto$ $3$.\n\nUse the following test suite. Each test case provides $L$, the PSSM $W$ by listing its column vectors in the nucleotide row order (A, C, G, T), and the target score $S$.\n\n- Test Case $1$:\n  - Length $L = 3$.\n  - Columns of $W$:\n    - Column $0$: $[2, 1, 0, -1]$.\n    - Column $1$: $[0, 3, -2, 1]$.\n    - Column $2$: $[1, -1, 2, 0]$.\n  - Target $S = 3$.\n\n- Test Case $2$:\n  - Length $L = 3$.\n  - Same $W$ as in Test Case $1$.\n  - Target $S = -4$.\n\n- Test Case $3$:\n  - Length $L = 3$.\n  - Same $W$ as in Test Case $1$.\n  - Target $S = 7$.\n\n- Test Case $4$:\n  - Length $L = 3$.\n  - Same $W$ as in Test Case $1$.\n  - Target $S = 8$.\n\n- Test Case $5$:\n  - Length $L = 0$.\n  - PSSM $W$ is the $4 \\times 0$ matrix (no columns).\n  - Target $S = 0$.\n\nYour program must produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, where each result is either a list of integers encoding the lexicographically smallest sequence with exact score $S$, the empty list $[]$ when $L=0$ and $S=0$, or the sentinel list $[-1]$ if no sequence exists. For example, the overall output should have the form $[\\;\\text{case}_1,\\text{case}_2,\\text{case}_3,\\text{case}_4,\\text{case}_5\\;]$ with each $\\text{case}_k$ rendered as a bracketed comma-separated list of integers without additional text.", "solution": "The problem statement has been rigorously validated. It is found to be scientifically grounded, well-posed, objective, and self-contained, thus admitting a formal solution. The task is to find the lexicographically smallest integer-encoded DNA sequence $x = (x_0, x_1, \\dots, x_{L-1})$ of a given length $L$ that achieves a target score $S$ based on a Position-Specific Scoring Matrix (PSSM), $W$.\n\nThe score is defined as an additive function over the sequence positions: $\\mathrm{Score}(x; W) = \\sum_{i=0}^{L-1} W[x_i, i]$. The requirement to find the lexicographically smallest sequence suggests a constructive approach, building the sequence from position $i=0$ to $i=L-1$. At each position $i$, we must choose the smallest possible nucleotide code $x_i \\in \\{0, 1, 2, 3\\}$ that still allows for the possibility of achieving the target score $S$ with the remaining suffix of the sequence.\n\nA naive brute-force search of all $4^L$ possible sequences is computationally intractable for any non-trivial length $L$. A simple greedy approach, such as choosing the nucleotide at each position that brings the cumulative score closest to the target, will not guarantee a solution exists or that it is lexicographically minimal. A more robust method is required. The problem's structure, involving sequential decisions and an additive objective function, is characteristic of problems solvable with dynamic programming.\n\nWe can formulate a solution using dynamic programming by first determining the set of all achievable scores for every possible suffix of the sequence. Let $A_i$ be the set of all possible scores that can be obtained from the PSSM columns from position $i$ to $L-1$. We can compute these sets using a backward recurrence relation.\nThe base case is for the empty suffix at position $L$, which has a length of $0$. The only possible score is $0$. Thus, $A_L = \\{0\\}$.\nFor any position $i < L$, the set of achievable scores $A_i$ is formed by taking every score $s \\in A_{i+1}$ (achievable from position $i+1$ onwards) and adding the score contribution from each possible nucleotide $k \\in \\{0, 1, 2, 3\\}$ at position $i$. The recurrence relation is:\n$$\nA_i = \\bigcup_{k=0}^{3} \\{ s + W[k, i] \\mid s \\in A_{i+1} \\}\n$$\nThis computation proceeds backwards from $i=L-1$ down to $i=0$. The set $A_0$ contains all possible scores for a complete sequence of length $L$. If the target score $S$ is not in $A_0$, no solution exists.\n\nOnce these sets of achievable suffix scores are pre-computed, we can construct the lexicographically smallest sequence $x$ in a forward pass, from $i=0$ to $L-1$. Let $S_{rem}$ be the remaining score that must be achieved by the suffix starting at position $i$. Initially, $S_{rem} = S$. At each position $i$, we iterate through the nucleotide choices $k = 0, 1, 2, 3$ in increasing order. For each $k$, we check if a solution is still possible. A choice of nucleotide $k$ at position $i$ is valid if the new remaining target score, $S_{rem} - W[k, i]$, is present in the set of achievable scores for the next suffix, $A_{i+1}$. That is, we check if:\n$$\n(S_{rem} - W[k, i]) \\in A_{i+1}\n$$\nThe first value of $k$ that satisfies this condition is chosen as $x_i$. This greedy choice is guaranteed to yield the lexicographically smallest sequence because we always select the smallest possible nucleotide code at each position that preserves the existence of a valid complete sequence. We then update the remaining target score, $S_{rem} \\leftarrow S_{rem} - W[k, i]$, and proceed to the next position $i+1$. This process continues until the full sequence is constructed.\n\nThe overall algorithm is as follows:\n1. Handle the special case of $L=0$. If $S=0$, return the empty sequence. Otherwise, no solution is possible.\n2. Initialize an array of sets, `achievable_scores`, of size $L+1$. Set `achievable_scores[L] = {0}\\}$.\n3. Compute the sets of achievable suffix scores by iterating $i$ from $L-1$ down to $0$, applying the recurrence relation for $A_i$.\n4. Check if the target score $S$ is in `achievable_scores[0]`. If not, no sequence can produce this score, so we terminate and indicate no solution exists.\n5. If a solution is possible, construct the sequence $x$. Initialize an empty list for $x$ and set the remaining target score to $S$.\n6. Iterate $i$ from $0$ to $L-1$. In an inner loop, iterate $k$ from $0$ to $3$. Find the first $k$ for which $(S_{rem} - W[k, i]) \\in \\text{achievable\\_scores}[i+1]$. Append this $k$ to $x$, update $S_{rem}$, and break the inner loop to proceed to the next position.\n7. Return the constructed sequence $x$.\nThis method correctly and efficiently determines the required sequence.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the PSSM score matching problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"L\": 3,\n            \"W_cols\": [[2, 1, 0, -1], [0, 3, -2, 1], [1, -1, 2, 0]],\n            \"S\": 3\n        },\n        {\n            \"L\": 3,\n            \"W_cols\": [[2, 1, 0, -1], [0, 3, -2, 1], [1, -1, 2, 0]],\n            \"S\": -4\n        },\n        {\n            \"L\": 3,\n            \"W_cols\": [[2, 1, 0, -1], [0, 3, -2, 1], [1, -1, 2, 0]],\n            \"S\": 7\n        },\n        {\n            \"L\": 3,\n            \"W_cols\": [[2, 1, 0, -1], [0, 3, -2, 1], [1, -1, 2, 0]],\n            \"S\": 8\n        },\n        {\n            \"L\": 0,\n            \"W_cols\": [],\n            \"S\": 0\n        }\n    ]\n\n    def find_sequence(L, W_cols, S):\n        \"\"\"\n        Finds the lexicographically smallest sequence with a target PSSM score.\n\n        Args:\n            L (int): The length of the DNA sequence.\n            W_cols (list): The PSSM represented as a list of column vectors.\n            S (int): The target score.\n\n        Returns:\n            list: The integer-encoded sequence, [-1] if no solution, or [] for L=0, S=0.\n        \"\"\"\n        # Handle the edge case of a zero-length sequence.\n        if L == 0:\n            return [] if S == 0 else [-1]\n\n        # The PSSM W, where W[k, i] is the score for nucleotide k at position i.\n        # W_cols is a list of L columns, each of length 4.\n        # np.array(W_cols).T creates a 4xL matrix.\n        W = np.array(W_cols).T\n\n        # Dynamic Programming: Compute sets of achievable scores for all suffixes.\n        # achievable_scores[i] will store the set of scores for the suffix starting at i.\n        achievable_scores = [set() for _ in range(L + 1)]\n        achievable_scores[L] = {0}\n\n        for i in range(L - 1, -1, -1):\n            for s_next in achievable_scores[i + 1]:\n                for k in range(4):  # For nucleotides A, C, G, T\n                    current_score = s_next + W[k, i]\n                    achievable_scores[i].add(current_score)\n\n        # If the target score S is not achievable, no solution exists.\n        if S not in achievable_scores[0]:\n            return [-1]\n\n        # Reconstruct the lexicographically smallest sequence.\n        result_sequence = []\n        remaining_target = S\n        for i in range(L):\n            # Iterate through nucleotides in lexicographical order (0, 1, 2, 3)\n            for k in range(4):\n                score_contribution = W[k, i]\n                next_remaining_target = remaining_target - score_contribution\n                \n                # Check if this choice allows a valid completion of the sequence.\n                if next_remaining_target in achievable_scores[i + 1]:\n                    result_sequence.append(k)\n                    remaining_target = next_remaining_target\n                    break  # Commit to this choice and move to the next position.\n        \n        return result_sequence\n\n    results = []\n    for case in test_cases:\n        result = find_sequence(case[\"L\"], case[\"W_cols\"], case[\"S\"])\n        results.append(result)\n\n    # Format the final output string as specified.\n    # The string representation of a list in Python includes spaces,\n    # which we remove to match the required dense format, e.g., `[0,1,2]`.\n    string_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n```", "id": "2415071"}]}