{"hands_on_practices": [{"introduction": "Standard sequence alignment algorithms, like Needleman-Wunsch, are designed for linear sequences with defined start and end points. However, many organisms, such as bacteria, have circular genomes where the choice of a \"starting point\" is arbitrary and can lead to misleading alignment results. This exercise [@problem_id:2440877] challenges you to extend a fundamental alignment algorithm to correctly handle circular genomes, a common and practical task in microbial comparative genomics.", "problem": "You are given two deoxyribonucleic acid (DNA) sequences representing circular bacterial genomes. Each sequence is a finite string over the alphabet $\\Sigma=\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$. A circular genome has no distinguished starting position, so any rotation of the string represents the same circular molecule. For a string $X$ of length $|X|=n$, define the rotation by $k$ positions as $R_k(X)=X[k\\,..\\,n-1] \\,\\Vert\\, X[0\\,..\\,k-1]$ for any integer $k$ with $0 \\le k < n$, where $\\Vert$ denotes concatenation and indexing uses 0-based half-open intervals.\n\nDefine the global alignment score $F(U,V)$ between two strings $U$ and $V$ as the optimal score under an additive scoring scheme with the following parameters: a match contributes $+2$, a mismatch contributes $-1$, and each gap character contributes $-2$ (linear gap cost). The alignment must consume all characters of both strings (global alignment). Formally, let $g=-2$ be the gap score, and let\n$$\ns(a,b)=\n\\begin{cases}\n+2 & \\text{if } a=b,\\\\\n-1 & \\text{if } a\\ne b.\n\\end{cases}\n$$\nThen $F(U,V)$ is the maximum, over all global alignments of $U$ and $V$, of the sum of $s(\\cdot,\\cdot)$ over aligned letter-letter pairs plus $g$ for each gap character.\n\nTo avoid artifacts from an arbitrary linearization point, define the circular-global alignment score\n$$\nC(X,Y)=\\max_{0 \\le k < |X|} F\\big(R_k(X),\\,Y\\big),\n$$\nwhich optimizes over all rotations of $X$ while aligning $Y$ linearly. Assume $|X|\\ge 1$ and $|Y|\\ge 1$.\n\nYour task is to write a program that, for each test case below, computes the integer $C(X,Y)$ under the scoring scheme specified above. No other interpretation (such as reverse-complement orientation) is to be considered; only rotations in the forward orientation are allowed.\n\nTest suite (each test case is an ordered pair $(X,Y)$):\n- Test $1$: $X=\\text{\"ATGC\"}$, $Y=\\text{\"GCAT\"}$.\n- Test $2$: $X=\\text{\"AAAAC\"}$, $Y=\\text{\"AAAA\"}$.\n- Test $3$: $X=\\text{\"TTTTCCCC\"}$, $Y=\\text{\"CCCCTTTT\"}$.\n- Test $4$: $X=\\text{\"AAAA\"}$, $Y=\\text{\"TTTT\"}$.\n- Test $5$: $X=\\text{\"G\"}$, $Y=\\text{\"GG\"}$.\n\nFinal output format: Your program should produce a single line of output containing the results for Tests $1$ through $5$ in order, as a comma-separated list enclosed in square brackets, for example, $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$. Each $\\text{result}_i$ must be an integer.", "solution": "The problem as stated is valid. It is scientifically grounded in the established principles of bioinformatics, specifically global sequence alignment. It is also well-posed, with all necessary parameters and definitions provided unambiguously. There are no logical contradictions, factual errors, or subjective elements. The task is to compute a circular-global alignment score, which is a straightforward, albeit computationally intensive, extension of the standard global alignment problem.\n\nThe problem requires the computation of the circular-global alignment score $C(X,Y)$, defined as $C(X,Y)=\\max_{0 \\le k < |X|} F\\big(R_k(X),\\,Y\\big)$. This calculation is composed of two main parts: first, computing the global alignment score $F(U,V)$ between two linear sequences $U$ and $V$, and second, maximizing this score over all possible rotations of sequence $X$.\n\nThe global alignment score $F(U,V)$ is determined using the Needleman-Wunsch algorithm, a dynamic programming method. Let the two sequences be $U$ of length $m$ and $V$ of length $n$. We construct a dynamic programming matrix, $M$, of size $(m+1) \\times (n+1)$. The entry $M_{i,j}$ stores the optimal alignment score for the prefixes $U[0..i-1]$ and $V[0..j-1]$.\n\nThe scoring parameters are provided: match score $s_{\\text{match}} = +2$, mismatch score $s_{\\text{mismatch}} = -1$, and a linear gap penalty of $g = -2$ per gap character. The score for aligning two characters $a$ and $b$ is denoted by $s(a,b)$.\n\nThe matrix $M$ is filled as follows:\n\n1.  **Initialization**: The first row and column are initialized to account for alignments of a prefix against gaps.\n    $$M_{0,0} = 0$$\n    $$M_{i,0} = i \\cdot g \\quad \\text{for } 1 \\le i \\le m$$\n    $$M_{0,j} = j \\cdot g \\quad \\text{for } 1 \\le j \\le n$$\n\n2.  **Recurrence Relation**: For $i$ from $1$ to $m$ and $j$ from $1$ to $n$, the value of $M_{i,j}$ is computed by taking the maximum of three possibilities:\n    -   Aligning characters $U[i-1]$ and $V[j-1]$: the score is $M_{i-1,j-1} + s(U[i-1], V[j-1])$.\n    -   Aligning $U[i-1]$ with a gap: the score is $M_{i-1,j} + g$.\n    -   Aligning $V[j-1]$ with a gap: the score is $M_{i,j-1} + g$.\n\n    Formally, the recurrence is:\n    $$M_{i,j} = \\max \\begin{cases} M_{i-1,j-1} + s(U[i-1], V[j-1]) \\\\ M_{i-1,j} + g \\\\ M_{i,j-1} + g \\end{cases}$$\n\nThe global alignment score $F(U,V)$ is the value in the bottom-right corner of the matrix, $M_{m,n}$.\n\nTo find the circular-global alignment score $C(X,Y)$, we must perform this calculation for every rotation of $X$. Let $|X| = n_x$. A rotation of $X$ by $k$ positions, where $0 \\le k < n_x$, is the string $R_k(X) = X[k\\,..\\,n_x-1] \\Vert X[0\\,..\\,k-1]$. We compute the global alignment score $F(R_k(X), Y)$ for each $k$. The final score $C(X,Y)$ is the maximum value obtained from this set of scores.\n\n$$C(X,Y) = \\max \\left\\{ F(R_0(X), Y), F(R_1(X), Y), \\dots, F(R_{n_x-1}(X), Y) \\right\\}$$\n\nAs an example, consider Test $1$: $X=\\text{\"ATGC\"}$ and $Y=\\text{\"GCAT\"}$. Here, $|X|=4$. We must check $4$ rotations.\n-   For $k=0$, $R_0(X) = \\text{\"ATGC\"}$. We compute $F(\\text{\"ATGC\"}, \\text{\"GCAT\"})$. This alignment will have a low score as no characters match at the same positions.\n-   For $k=1$, $R_1(X) = \\text{\"TGCA\"}$. We compute $F(\\text{\"TGCA\"}, \\text{\"GCAT\"})$. This also results in a low score.\n-   For $k=2$, $R_2(X) = \\text{\"GCAT\"}$. We compute $F(\\text{\"GCAT\"}, \\text{\"GCAT\"})$. This is a perfect match. The alignment is:\n    ```\n    GCAT\n    GCAT\n    ```\n    The score is the sum of $4$ matches: $4 \\times (+2) = 8$.\n-   For $k=3$, $R_3(X) = \\text{\"CATG\"}$. We compute $F(\\text{\"CATG\"}, \\text{\"GCAT\"})$, again resulting in a low score.\n\nThe maximum score found across all rotations is $8$. Therefore, $C(\\text{\"ATGC\"}, \\text{\"GCAT\"}) = 8$.\n\nThis procedure is systematically applied to all provided test cases to derive their respective solutions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef global_alignment_score(seq1: str, seq2: str, match_score: int, mismatch_score: int, gap_score: int) -> int:\n    \"\"\"\n    Computes the global alignment score of two sequences using the Needleman-Wunsch algorithm.\n\n    Args:\n        seq1: The first sequence.\n        seq2: The second sequence.\n        match_score: The score for a match.\n        mismatch_score: The score for a mismatch.\n        gap_score: The score for a gap (linear).\n\n    Returns:\n        The optimal global alignment score as an integer.\n    \"\"\"\n    m = len(seq1)\n    n = len(seq2)\n\n    # Initialize the dynamic programming table\n    dp_table = np.zeros((m + 1, n + 1), dtype=int)\n\n    # Initialize the first row and column\n    for i in range(1, m + 1):\n        dp_table[i, 0] = i * gap_score\n    for j in range(1, n + 1):\n        dp_table[0, j] = j * gap_score\n\n    # Fill the rest of the table using the recurrence relation\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            # Score for aligning seq1[i-1] and seq2[j-1]\n            if seq1[i-1] == seq2[j-1]:\n                match_mismatch = match_score\n            else:\n                match_mismatch = mismatch_score\n            \n            score_diag = dp_table[i-1, j-1] + match_mismatch\n            score_up = dp_table[i-1, j] + gap_score\n            score_left = dp_table[i, j-1] + gap_score\n            \n            dp_table[i, j] = max(score_diag, score_up, score_left)\n\n    return dp_table[m, n]\n\ndef solve():\n    \"\"\"\n    Solves the circular-global alignment problem for a suite of test cases.\n    \"\"\"\n    # Define the scoring scheme from the problem statement.\n    MATCH = 2\n    MISMATCH = -1\n    GAP = -2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"ATGC\", \"GCAT\"),        # Test 1\n        (\"AAAAC\", \"AAAA\"),       # Test 2\n        (\"TTTTCCCC\", \"CCCCTTTT\"),# Test 3\n        (\"AAAA\", \"TTTT\"),        # Test 4\n        (\"G\", \"GG\"),             # Test 5\n    ]\n\n    results = []\n    for x_seq, y_seq in test_cases:\n        len_x = len(x_seq)\n        \n        # Problem statement guarantees |X| >= 1\n        if len_x == 0:\n            # This case is not expected based on problem constraints but is handled for robustness.\n            score = len(y_seq) * GAP\n            results.append(score)\n            continue\n            \n        max_score = -float('inf')\n\n        # Iterate through all rotations of the circular genome X\n        for k in range(len_x):\n            rotated_x = x_seq[k:] + x_seq[:k]\n            \n            # Compute global alignment score for the current rotation against Y\n            current_score = global_alignment_score(rotated_x, y_seq, MATCH, MISMATCH, GAP)\n            \n            # Update the maximum score\n            if current_score > max_score:\n                max_score = current_score\n        \n        results.append(int(max_score))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2440877"}, {"introduction": "While simple models often assume haploid genomes, real-world genomics frequently involves complex diploid organisms. Aligning a haploid genome to a diploid one presents unique challenges, as the natural variation between two parental haplotypes (alleles) can be easily mistaken for gene duplications (paralogs). This conceptual problem [@problem_id:2440880] will test your ability to design a robust bioinformatic strategy for a realistic research scenario, forcing you to think critically about how to handle heterozygosity, repeats, and haplotype information.", "problem": "You are given a high-quality assembly of a haploid fungal pathogen genome with total size $S_{\\mathrm{fungus}} = 42\\,\\text{Mb}$ and a high-quality assembly of its plant host genome. The plant assembly represents a diploid ($2n$) individual and consists of two sets of contigs: a primary haplotype set $P_1$ and an alternate haplotype set $P_2$, each spanning nearly the full genome. The plant genome has estimated heterozygosity $h \\approx 1.0\\%$ and interspersed repeat content $r \\approx 55\\%$, with segmental duplications accounting for less than $5\\%$ of the assembly length. You are tasked with producing genome-wide synteny blocks between the fungus and the plant that will be used to quantify conservation of gene order and to identify lineage-specific duplications and rearrangements. Specifically, the deliverables must (i) avoid counting allelic copies in $P_1$ and $P_2$ as paralogous duplications, (ii) be robust to repeats, and (iii) provide $1$-to-$1$ collinear anchors wherever appropriate between the haploid and the diploid genomes.\n\nWhich of the following strategies is the most appropriate for constructing these synteny blocks under the stated constraints?\n\nA. Soft- or hard-mask transposable elements and simple repeats in the plant genome, perform whole-genome alignment of the fungal assembly against $P_1$ and $P_2$ separately with parameters tolerant of divergence up to approximately $h$, compute collinear chains of local alignments on each haplotype, and then, for each fungal locus $x$, select a single best-scoring chain across $\\{P_1,P_2\\}$ (using a reciprocal best or score-dominance criterion) to collapse allelic matches; finally, build $1$-to-$1$ synteny blocks from the retained chains and treat residual $1$-to-$k$ mappings ($k \\ge 2$) as candidate paralogous duplications.\n\nB. Merge $P_1$ and $P_2$ into a single mosaic consensus sequence (e.g., by majority voting across aligned contigs) to reduce redundancy, align the fungal genome once to this collapsed plant reference, and interpret any secondary alignments of a fungal locus within the plant as paralogy.\n\nC. Map fungal short reads to the diploid plant assembly with a short-read aligner, call Single Nucleotide Polymorphisms (SNPs), and infer synteny by identifying long intervals with low SNP density between the two species as syntenic and intervals with high SNP density as rearranged.\n\nD. Duplicate the fungal genome in silico to create a pseudo-diploid reference of size $2 \\times S_{\\mathrm{fungus}}$, align this duplicated fungal reference to the primary haplotype $P_1$ only, and interpret the two fungal copies that best align to each plant locus as representing the two plant haplotypes; use these alignments to define synteny.\n\nE. Restrict the analysis to predicted coding sequences only: align the fungal proteome to the plant proteome, define orthologs by reciprocal best hits, and infer synteny exclusively from the order of orthologous genes, ignoring noncoding and intergenic regions as well as collinearity constraints on genomic coordinates.", "solution": "The goal is to derive a strategy from first principles of whole-genome alignment and synteny under diploidy. Synteny is defined as conservation of gene order or collinearity of orthologous loci between genomes. Whole-genome alignment between a haploid and a diploid assembly introduces a characteristic complication: for each true orthologous locus in the diploid plant, there may be two allelic copies, one on haplotype $P_1$ and one on $P_2$, whose sequences differ by approximately the heterozygosity rate $h \\approx 1.0\\%$. If we align a haploid query to both haplotypes, each fungal locus $x$ can produce two high-quality alignments, with identities $I_1(x)$ to $P_1$ and $I_2(x)$ to $P_2$, respectively. These matches are allelic, not paralogous. A principled synteny construction must (i) prevent repeats from generating spurious local alignments and chains, typically by masking repeats or using repeat-aware seeding; (ii) allow for sequence divergence up to approximately $h$ so that both alleles are alignable; and (iii) collapse allelic redundancy by selecting at most one plant haplotype target per fungal locus before building $1$-to-$1$ collinear synteny blocks.\n\nFormally, let $\\mathcal{A}_1$ and $\\mathcal{A}_2$ be sets of local alignments between the fungal genome and $P_1$ and $P_2$, respectively, after repeat masking. Let $\\mathcal{C}_1$ and $\\mathcal{C}_2$ be collinear chains computed on each haplotype by maximizing an additive score $S = \\sum_{i} w_i$ over consistent local alignments with weights $w_i$ derived from match length and identity. For each fungal locus $x$, define the top chain across haplotypes as $C^\\ast(x) = \\arg\\max\\{S(C) : C \\in \\mathcal{C}_1 \\cup \\mathcal{C}_2 \\text{ covering } x\\}$. Retain only $C^\\ast(x)$ to collapse the two allelic targets into a single representative mapping, optionally enforcing reciprocity so that the chosen plant interval is not better explained by a different fungal locus. After this collapse, chains can be netted to remove overlaps and converted into $1$-to-$1$ synteny blocks. Any fungal locus that still has $1$-to-$k$ mappings with $k \\ge 2$ after the across-haplotype collapse is a candidate paralog due to true duplication rather than allelism.\n\nWith this framework, we can evaluate the options:\n\nA. This option explicitly incorporates the three required principles. First, it controls repeat-driven noise by masking transposable elements, which is essential when repeat content is $r \\approx 55\\%$. Second, it performs whole-genome alignment separately to $P_1$ and $P_2$ with parameters tolerant of divergence on the order of $h \\approx 1.0\\%$, ensuring both alleles can be matched. Third, it collapses allelic redundancy by selecting a single best-scoring chain $C^\\ast(x)$ per fungal locus across haplotypes, using a reciprocal best or dominance criterion so that allelic copies in $P_1$ and $P_2$ are not double-counted. Finally, it builds $1$-to-$1$ synteny blocks from the retained chains and flags residual $1$-to-$k$ mappings ($k \\ge 2$) as candidate paralogies. This directly satisfies (i), (ii), and (iii) and is the appropriate strategy. Verdict — Correct.\n\nB. Collapsing $P_1$ and $P_2$ into a single mosaic consensus by majority voting destroys haplotype-specific phase and creates chimeric sequences that can introduce artifactual breakpoints and mismatches. Aligning to such a mosaic can merge divergent alleles into a single track and would cause secondary alignments of the fungus to be misinterpreted as paralogy, violating the requirement to avoid counting alleles as paralogs. It also risks obscuring structural heterozygosity. Verdict — Incorrect.\n\nC. Mapping fungal short reads to the plant genome and using Single Nucleotide Polymorphism (SNP) density to define synteny confuses intra-species variation (within-plant heterozygosity) with inter-species divergence. SNP density between species is not a principled proxy for collinearity, and short-read mapping is not a suitable substitute for whole-genome alignment across species with different genome organizations. This does not produce $1$-to-$1$ collinear anchors and ignores the allelic collapse requirement. Verdict — Incorrect.\n\nD. Duplicating the fungal genome in silico does not model plant allelism. Aligning a duplicated fungal reference only to $P_1$ cannot capture the allelic variation on $P_2$. Moreover, interpreting two fungal copies aligning to a single plant locus as representing plant haplotypes inverts the true biological relationship and conflates duplication in the query with allelism in the target. This fails to address repeats and does not produce a valid $1$-to-$1$ synteny framework. Verdict — Incorrect.\n\nE. Restricting to coding sequences and reciprocal best protein hits can recover orthologs but discards noncoding and intergenic collinearity, which is important for robust synteny, and is highly sensitive to annotation quality and gene movement. It also does not explicitly address allelic collapse across $P_1$ and $P_2$. Consequently, it cannot meet the requirement to produce genome-wide $1$-to-$1$ collinear anchors and to robustly distinguish allelism from paralogy in repetitive contexts. Verdict — Incorrect.\n\nTherefore, the most appropriate strategy under the stated constraints is the haplotype-aware whole-genome alignment with repeat control and across-haplotype allelic collapse described in option A.", "answer": "$$\\boxed{A}$$", "id": "2440880"}, {"introduction": "Identifying a region of similarity between two genomes is often just the beginning of an analysis; the crucial next step is to determine if this finding is statistically significant. How can we be confident that an observed syntenic block represents true evolutionary conservation, rather than a coincidental match that occurred by random chance? This practice [@problem_id:2440822] guides you through the statistical reasoning required to answer this question by deriving a *p*-value, providing a quantitative framework for evaluating the significance of alignment results.", "problem": "Two genomes of equal length $N$ nucleotides are generated under the following null model: at each position, each genome independently draws a nucleotide uniformly from the alphabet $\\{A, C, G, T\\}$. Consider only the forward orientation (ignore reverse complements and inversions). For any pair of starting indices $(i, j)$ with $1 \\leq i \\leq N - L + 1$ and $1 \\leq j \\leq N - L + 1$, form a pair of contiguous substrings (one from each genome) of length $L$ and compute their Hamming distance, defined as the number of positions at which the nucleotides differ. Define a “syntenic block” of length $L$ to be any such pair of substrings in forward orientation. Let $k$ be an integer satisfying $0 \\leq k \\leq L$.\n\nUnder the null model described, and additionally assuming that the events associated with different start-index pairs $(i, j)$ are independent, derive a closed-form analytic expression for the probability value (p-value) of observing at least one syntenic block of length $L$ whose Hamming distance is at most $k$ somewhere between the two genomes. Your final answer must be a single expression in terms of $N$, $L$, and $k$. Do not substitute numerical values. Express the final answer as a closed-form analytic expression. No units are required.", "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n- Two genomes of equal length $N$ nucleotides.\n- Null model: each position, each genome independently draws a nucleotide uniformly from the alphabet $\\{A, C, G, T\\}$.\n- Only forward orientation is considered.\n- A pair of contiguous substrings of length $L$ is formed from starting indices $(i, j)$ where $1 \\leq i \\leq N - L + 1$ and $1 \\leq j \\leq N - L + 1$.\n- The Hamming distance between two substrings is the number of positions at which the nucleotides differ.\n- A “syntenic block” is a pair of substrings of length $L$ in forward orientation.\n- An integer $k$ is given, satisfying $0 \\leq k \\leq L$.\n- The events associated with different start-index pairs $(i, j)$ are assumed to be independent.\n- The objective is to derive a closed-form analytic expression for the p-value of observing at least one syntenic block of length $L$ with Hamming distance at most $k$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is a well-posed and standard exercise in bioinformatics and computational statistics. It is scientifically grounded in the principles of sequence alignment and statistical significance testing under a null model. The null model, while a simplification of biological reality, is clearly defined and mathematically tractable. The concepts of Hamming distance, uniform nucleotide distribution, and p-value are all standard. The problem statement provides all necessary information and definitions. The crucial assumption that events for different block pairs are independent, while biologically unrealistic for overlapping blocks, is explicitly stated, which makes the problem solvable and internally consistent. There are no contradictions, ambiguities, or factual errors. The problem is formalizable and directly relevant to its specified field.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be derived.\n\nThe problem asks for the probability of observing at least one syntenic block pair of length $L$ with a Hamming distance of at most $k$. This is a classic \"at least one success\" problem, which is most efficiently solved by calculating the probability of the complementary event—that is, that *no* such block pair exists—and subtracting this from $1$.\n\nLet $P_{hit}$ be the probability that a single, randomly chosen pair of syntenic blocks of length $L$ has a Hamming distance $H \\leq k$. Let $M$ be the total number of such block pairs that can be formed between the two genomes. The problem states that the events for each pair are independent. Therefore, the probability that all $M$ pairs fail to meet the criterion (i.e., all have $H > k$) is $(1 - P_{hit})^M$. The p-value we seek is the probability of at least one hit, which is:\n$$ p\\text{-value} = 1 - (1 - P_{hit})^M $$\n\nWe must now determine expressions for $P_{hit}$ and $M$.\n\nFirst, let us determine $M$, the total number of syntenic block pairs. The first genome has length $N$. The possible starting positions for a block of length $L$ are $i=1, 2, \\dots, N-L+1$. The number of such starting positions is $N-L+1$. Similarly, the number of starting positions for a block of length $L$ in the second genome is also $N-L+1$. Since any block from the first genome can be paired with any block from the second, the total number of pairs is:\n$$ M = (N-L+1) \\times (N-L+1) = (N-L+1)^2 $$\nThis assumes $N \\geq L$, which is required for a block of length $L$ to exist.\n\nNext, we determine $P_{hit}$. This is the probability that for a single pair of blocks, the Hamming distance $H$ is less than or equal to $k$. The Hamming distance is the number of mismatches. We can model this with a binomial distribution. Let us first find the probability of a mismatch at a single position.\n\nThe alphabet is $\\Sigma = \\{A, C, G, T\\}$, so its size is $|\\Sigma| = 4$. Under the null model, each nucleotide at each position is drawn independently and uniformly. The probability of any specific nucleotide (e.g., 'A') is $p_A = p_C = p_G = p_T = \\frac{1}{4}$.\nThe probability of a match at a given position is the probability that both sequences have the same nucleotide. Due to independence:\n$$ P(\\text{match}) = \\sum_{n \\in \\Sigma} P(\\text{nuc}_1 = n \\text{ and } \\text{nuc}_2 = n) = \\sum_{n \\in \\Sigma} P(\\text{nuc}_1 = n) P(\\text{nuc}_2 = n) $$\n$$ P(\\text{match}) = 4 \\times \\left(\\frac{1}{4} \\times \\frac{1}{4}\\right) = 4 \\times \\frac{1}{16} = \\frac{1}{4} $$\nLet $p_m = P(\\text{match}) = \\frac{1}{4}$. The probability of a mismatch, $p_{mm}$, is therefore:\n$$ p_{mm} = 1 - p_m = 1 - \\frac{1}{4} = \\frac{3}{4} $$\nA pair of blocks has length $L$. Each of the $L$ positions can be considered an independent Bernoulli trial, where \"success\" is a mismatch. The Hamming distance $H$ is the total number of mismatches in these $L$ trials. Thus, $H$ follows a binomial distribution with parameters $L$ and $p_{mm}$:\n$$ H \\sim \\text{Binomial}(L, p_{mm}) $$\nThe probability of observing exactly $d$ mismatches is given by the probability mass function of the binomial distribution:\n$$ P(H=d) = \\binom{L}{d} (p_{mm})^d (1-p_{mm})^{L-d} = \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} $$\nThe probability $P_{hit}$ is the probability that the Hamming distance is at most $k$, which is the cumulative probability $P(H \\leq k)$. This is found by summing the probabilities for $d=0, 1, \\dots, k$:\n$$ P_{hit} = P(H \\leq k) = \\sum_{d=0}^{k} P(H=d) = \\sum_{d=0}^{k} \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} $$\n\nNow, we substitute the expressions for $M$ and $P_{hit}$ back into our original formula for the p-value.\n$$ p\\text{-value} = 1 - (1 - P_{hit})^M = 1 - \\left(1 - \\sum_{d=0}^{k} \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} \\right)^{(N-L+1)^2} $$\nThis expression is the closed-form solution in terms of the given parameters $N$, $L$, and $k$. Note that the sum is a standard representation for the cumulative distribution function of a binomial random variable and is considered a closed form in this context.", "answer": "$$\n\\boxed{1 - \\left(1 - \\sum_{d=0}^{k} \\binom{L}{d} \\left(\\frac{3}{4}\\right)^d \\left(\\frac{1}{4}\\right)^{L-d} \\right)^{(N-L+1)^2}}\n$$", "id": "2440822"}]}