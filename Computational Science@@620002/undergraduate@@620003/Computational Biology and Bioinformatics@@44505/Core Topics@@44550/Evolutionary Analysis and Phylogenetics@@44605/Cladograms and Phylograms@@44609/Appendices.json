{"hands_on_practices": [{"introduction": "This first exercise will test your ability to correctly interpret the information encoded in a phylogenetic tree. Before delving into complex calculations, it is crucial to recognize that the visual layout of a cladogram can sometimes be misleading; the true evolutionary history is defined by the branching pattern, or topology. This practice focuses on the key skill of identifying topological equivalence, which is fundamental to accurately reading any phylogenetic analysis [@problem_id:2311348].", "problem": "An exo-biologist is studying the evolutionary history of five newly discovered alien species on a distant planet. Let's call them Species V, W, X, Y, and Z. Two different graduate students, using the same genetic dataset but different visualization software, produce two textual descriptions of the phylogenetic tree. Your task is to determine if their conclusions about the evolutionary relationships are the same or different.\n\n**Tree 1 Description:**\nThe tree is rooted with Species Z as the outgroup, meaning it is the most distantly related to all other species. The remaining four species form a monophyletic group which splits into two main branches. The first branch leads to Species Y. The second branch leads to a smaller group containing Species V, W, and X. Within this smaller group, Species X is the sister taxon to a clade containing Species V and Species W, which are each other's closest relatives.\n\n**Tree 2 Description:**\nThe tree is rooted with Species Z as the outgroup. The lineage leading to the other four species immediately splits into two clades. The first clade is composed of Species V, W, and X. The second clade consists solely of Species Y. Within the first clade, Species V and Species W are sister taxa, and this pair shares a more recent common ancestor with Species X than with any other species.\n\nWhich of the following statements correctly evaluates the two trees?\n\nA. The trees represent different evolutionary histories because the positions of Species Y and the (V, W, X) clade are swapped.\n\nB. The trees represent different evolutionary histories because in Tree 1, Species Y appears to be more \"advanced\" than Species X, while their relationship is ambiguous in Tree 2.\n\nC. The trees represent the same evolutionary history because the pattern of sister-group relationships is identical in both.\n\nD. The trees represent the same evolutionary history, but only because Species Z is the outgroup in both. A different outgroup would make them non-equivalent.\n\nE. It is impossible to determine if the histories are the same or different without seeing the branch lengths representing evolutionary time.", "solution": "We begin by interpreting standard phylogenetic terminology. A rooted tree with an outgroup indicates the root is placed on the branch leading to the outgroup, and all other taxa form the ingroup. A clade (monophyletic group) includes an ancestor and all its descendants. Sister taxa share an immediate common ancestor. Two rooted trees represent the same evolutionary history if and only if their set of sister-group relationships and nested clades (topology) are identical.\n\nParse Tree 1:\n- Rooted with Z as outgroup implies Z is the sister to the ingroup $\\{V,W,X,Y\\}$.\n- The ingroup splits into two main branches: one is $Y$ alone, the other is the clade $\\{V,W,X\\}$.\n- Within $\\{V,W,X\\}$, $X$ is sister to the clade containing $V$ and $W$, and $V$ and $W$ are sister taxa.\n- Thus the hierarchical sister relationships are:\n  $$ (V,W) \\text{ are sisters}, \\quad X \\text{ is sister to } (V,W), \\quad Y \\text{ is sister to } (X,(V,W)). $$\n\nParse Tree 2:\n- Rooted with Z as outgroup implies Z is the sister to the ingroup $\\{V,W,X,Y\\}$.\n- The ingroup immediately splits into two clades: $\\{V,W,X\\}$ and $\\{Y\\}$, so $Y$ is sister to the clade $\\{V,W,X\\}$.\n- Within $\\{V,W,X\\}$, $V$ and $W$ are sister taxa, and this pair shares a more recent common ancestor with $X$ than with any other species; equivalently, $X$ is sister to $(V,W)$.\n- Thus the hierarchical sister relationships are identical:\n  $$ (V,W) \\text{ are sisters}, \\quad X \\text{ is sister to } (V,W), \\quad Y \\text{ is sister to } (X,(V,W)). $$\n\nComparison:\n- Both trees have the same rooted topology on $\\{V,W,X,Y\\}$ with Z as outgroup. Therefore, the pattern of sister-group relationships is identical in both descriptions.\n- Evaluation of options:\n  - A is incorrect: neither description swaps the positions; both place $Y$ as sister to the clade $\\{V,W,X\\}$.\n  - B is incorrect: there is no ranking of being more \"advanced\"; both specify the same topology between $Y$ and $X$.\n  - C is correct: the sister-group relationships match exactly.\n  - D is incorrect: the equivalence is due to identical topology, not merely the shared outgroup.\n  - E is incorrect: branch lengths are not required to assess topological equivalence.\n\nTherefore, the correct choice is C.", "answer": "$$\\boxed{C}$$", "id": "2311348"}, {"introduction": "Once you can read a tree, the next step is to understand how scientists decide which tree topology best explains a given dataset. This exercise introduces the principle of maximum parsimony, a fundamental method that seeks the evolutionary tree requiring the fewest character-state changes. By manually calculating the parsimony score, you will gain a concrete understanding of how sequence data can be used to evaluate competing evolutionary hypotheses and support one tree over another [@problem_id:2378551].", "problem": "A deoxyribonucleic acid (DNA) alignment of $4$ taxa across $5$ sites is given below. Each site is assumed to evolve independently under the principle of maximum parsimony, where the parsimony score of a tree is defined as the minimal total number of character-state changes required across all edges to explain the observed states at the leaves, summed over sites. The taxa are $\\mathrm{T}_1$, $\\mathrm{T}_2$, $\\mathrm{T}_3$, and $\\mathrm{T}_4$. The observed nucleotide states per site are:\n- Site $1$: $\\mathrm{T}_1=A$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=G$, $\\mathrm{T}_4=G$.\n- Site $2$: $\\mathrm{T}_1=C$, $\\mathrm{T}_2=T$, $\\mathrm{T}_3=C$, $\\mathrm{T}_4=T$.\n- Site $3$: $\\mathrm{T}_1=G$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=A$, $\\mathrm{T}_4=G$.\n- Site $4$: $\\mathrm{T}_1=A$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=A$, $\\mathrm{T}_4=A$.\n- Site $5$: $\\mathrm{T}_1=A$, $\\mathrm{T}_2=A$, $\\mathrm{T}_3=C$, $\\mathrm{T}_4=G$.\n\nConsider the $3$ possible unrooted binary tree topologies on these $4$ taxa, corresponding to the bipartitions $\\big((\\mathrm{T}_1,\\mathrm{T}_2),(\\mathrm{T}_3,\\mathrm{T}_4)\\big)$, $\\big((\\mathrm{T}_1,\\mathrm{T}_3),(\\mathrm{T}_2,\\mathrm{T}_4)\\big)$, and $\\big((\\mathrm{T}_1,\\mathrm{T}_4),(\\mathrm{T}_2,\\mathrm{T}_3)\\big)$. For each topology, compute the total parsimony score by summing the minimal number of state changes required at each site. Then, as your final answer, report the minimum of the $3$ total parsimony scores as a single integer. Do not include any units. No rounding is required.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a standard task in computational phylogenetics: the evaluation of tree topologies using the maximum parsimony criterion. The provided data, consisting of a DNA alignment for $4$ taxa and the definitions of the topologies and scoring method, are complete and self-consistent. There are no scientific or logical flaws, ambiguities, or missing information. The problem is therefore deemed valid and a formal solution can be constructed.\n\nThe objective is to compute the total parsimony score for each of the $3$ possible unrooted binary tree topologies for the $4$ taxa $(\\mathrm{T}_1, \\mathrm{T}_2, \\mathrm{T}_3, \\mathrm{T}_4)$ and identify the minimum score. The three topologies are defined by the following bipartitions:\n$T_1: ((\\mathrm{T}_1, \\mathrm{T}_2), (\\mathrm{T}_3, \\mathrm{T}_4))$\n$T_2: ((\\mathrm{T}_1, \\mathrm{T}_3), (\\mathrm{T}_2, \\mathrm{T}_4))$\n$T_3: ((\\mathrm{T}_1, \\mathrm{T}_4), (\\mathrm{T}_2, \\mathrm{T}_3))$\n\nThe total parsimony score for a topology is the sum of the scores calculated for each of the $5$ sites independently. The score for a single site is the minimum number of nucleotide substitutions required to explain the observed character states at the leaves of the tree. This score can be determined using Fitch's algorithm. For a four-taxon tree, the calculation is straightforward. An unrooted tree with $4$ taxa has two internal nodes. The minimal number of changes for a site depends on how the character states are partitioned by the tree topology.\n\nLet $S_i(\\mathcal{T})$ denote the parsimony score for site $i$ on a topology $\\mathcal{T}$. The total score for $\\mathcal{T}$ is $S_{total}(\\mathcal{T}) = \\sum_{i=1}^{5} S_i(\\mathcal{T})$.\n\nSite $1$: The character states are $(\\mathrm{T}_1, \\mathrm{T}_2, \\mathrm{T}_3, \\mathrm{T}_4) = (A, A, G, G)$.\nFor topology $T_1$, the bipartition is $((\\mathrm{T}_1, \\mathrm{T}_2), (\\mathrm{T}_3, \\mathrm{T}_4))$, which groups the states as $((A,A), (G,G))$. Each pair has identical states. The two groups have different states. This requires a single substitution on the central edge connecting the two groups. Thus, $S_1(T_1) = 1$.\nFor topology $T_2$, the bipartition is $((\\mathrm{T}_1, \\mathrm{T}_3), (\\mathrm{T}_2, \\mathrm{T}_4))$, grouping states as $((A,G), (A,G))$. Each group requires one substitution, so the total minimum number of changes is $2$. $S_1(T_2) = 2$.\nFor topology $T_3$, the bipartition is $((\\mathrm{T}_1, \\mathrm{T}_4), (\\mathrm{T}_2, \\mathrm{T}_3))$, grouping states as $((A,G), (A,G))$. Similar to $T_2$, this requires $2$ substitutions. $S_1(T_3) = 2$.\nScores for Site $1$: $(1, 2, 2)$.\n\nSite $2$: The character states are $(C, T, C, T)$.\nFor $T_1$, the grouping is $((C,T), (C,T))$. Each group requires one substitution. Total: $S_2(T_1) = 2$.\nFor $T_2$, the grouping is $((C,C), (T,T))$. This requires one substitution on the central edge. Total: $S_2(T_2) = 1$.\nFor $T_3$, the grouping is $((C,T), (T,C))$. Each group requires one substitution. Total: $S_2(T_3) = 2$.\nScores for Site $2$: $(2, 1, 2)$.\n\nSite $3$: The character states are $(G, A, A, G)$.\nFor $T_1$, the grouping is $((G,A), (A,G))$. Each group requires one substitution. Total: $S_3(T_1) = 2$.\nFor $T_2$, the grouping is $((G,A), (A,G))$. Each group requires one substitution. Total: $S_3(T_2) = 2$.\nFor $T_3$, the grouping is $((G,G), (A,A))$. This requires one substitution on the central edge. Total: $S_3(T_3) = 1$.\nScores for Site $3$: $(2, 2, 1)$.\n\nSite $4$: The character states are $(A, A, A, A)$.\nThis is a constant site. All taxa have the same character state. No substitutions are needed for any topology.\n$S_4(T_1) = S_4(T_2) = S_4(T_3) = 0$.\nScores for Site $4$: $(0, 0, 0)$.\n\nSite $5$: The character states are $(A, A, C, G)$.\nThis site has three distinct states. A site with a character distribution of the form $(X, X, Y, Z)$ is not parsimony-informative for $4$ taxa, meaning it yields the same score for all topologies.\nFor $T_1$, the grouping is $((A,A), (C,G))$. The first group requires $0$ changes. The second requires $1$ change. The central edge connects internal nodes that can be assigned states $A$ and $\\{C,G\\}$ respectively, requiring $1$ more change. Total: $S_5(T_1) = 2$.\nFor $T_2$, the grouping is $((A,C), (A,G))$. The first group requires $1$ change. The second requires $1$ change. The internal nodes can be assigned states $\\{A,C\\}$ and $\\{A,G\\}$; their intersection is non-empty ($A$), so no change is required on the central edge. Total: $S_5(T_2) = 2$.\nFor $T_3$, the grouping is $((A,G), (A,C))$. This is equivalent to $T_2$. Total: $S_5(T_3) = 2$.\nScores for Site $5$: $(2, 2, 2)$.\n\nNow, the total parsimony scores for each topology are calculated by summing the scores from all $5$ sites.\n\nTotal score for $T_1$:\n$S_{total}(T_1) = S_1(T_1) + S_2(T_1) + S_3(T_1) + S_4(T_1) + S_5(T_1) = 1 + 2 + 2 + 0 + 2 = 7$.\n\nTotal score for $T_2$:\n$S_{total}(T_2) = S_1(T_2) + S_2(T_2) + S_3(T_2) + S_4(T_2) + S_5(T_2) = 2 + 1 + 2 + 0 + 2 = 7$.\n\nTotal score for $T_3$:\n$S_{total}(T_3) = S_1(T_3) + S_2(T_3) + S_3(T_3) + S_4(T_3) + S_5(T_3) = 2 + 2 + 1 + 0 + 2 = 7$.\n\nThe total parsimony scores for the three topologies are $S_{total}(T_1) = 7$, $S_{total}(T_2) = 7$, and $S_{total}(T_3) = 7$. In this case, all three topologies are equally parsimonious based on the given data. The parsimony-informative sites ($1$, $2$, and $3$) each support a different topology, leading to a tie.\n\nThe problem requires reporting the minimum of these three scores.\nThe minimum score is $\\min(7, 7, 7) = 7$.", "answer": "$$\n\\boxed{7}\n$$", "id": "2378551"}, {"introduction": "The evolutionary history of a gene family often differs from the history of the species that carry those genes, a phenomenon known as gene tree-species tree discordance. This incongruence is typically caused by large-scale genomic events like gene duplication and loss. This advanced practice challenges you to implement a reconciliation algorithm, a cornerstone of comparative genomics, which computationally maps a gene tree onto a species tree to infer where these pivotal duplication and speciation events occurred [@problem_id:2378555].", "problem": "You are given two rooted, strictly binary cladograms: a species tree $S$ with leaf set $\\Sigma_S$ and a gene tree $G$ with leaf set $\\Sigma_G$. Each gene leaf $g \\in \\Sigma_G$ is mapped to a species leaf through a provided function $m : \\Sigma_G \\to \\Sigma_S$. Define the Least Common Ancestor (LCA) in the species tree as $\\mathrm{LCA}_S(x,y)$ for any two nodes $x$ and $y$ in $S$. Define the reconciliation map $M$ from nodes of $G$ to nodes of $S$ by $M(g)=m(g)$ if $g$ is a leaf of $G$, and for any internal node $g$ of $G$ with children $u$ and $v$, define $M(g) = \\mathrm{LCA}_S\\!\\big(M(u), M(v)\\big)$. An internal node $g$ of $G$ is labeled as a duplication if $M(g)=M(u)$ or $M(g)=M(v)$, and it is labeled as a speciation otherwise.\n\nYour task is to write a complete program that, for each test case, labels every internal node of $G$ as duplication or speciation using the rule above and returns a list of boolean values in postorder (left subtree, right subtree, then node), where a boolean value $\\mathrm{True}$ indicates duplication and a boolean value $\\mathrm{False}$ indicates speciation. The postorder is determined by the left-to-right order induced by the Newick representation of $G$. If $G$ has no internal nodes, return an empty list. All trees are provided in Newick format without branch lengths. The mapping $m$ is provided explicitly as a set of pairs. The final program must not read input and must use the embedded test suite.\n\nThere are $4$ test cases. In each case, the species tree $S$, the gene tree $G$, and the mapping $m$ are specified as follows:\n\n- Test case $1$:\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"((ax,bz),(cw,dx));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"bz\"} \\mapsto \\text{\"B\"},\\, \\text{\"cw\"} \\mapsto \\text{\"C\"},\\, \\text{\"dx\"} \\mapsto \\text{\"D\"}\\,\\}$\n\n- Test case $2$:\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"(((ax,ay),bz),(cw,dx));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"ay\"} \\mapsto \\text{\"A\"},\\, \\text{\"bz\"} \\mapsto \\text{\"B\"},\\, \\text{\"cw\"} \\mapsto \\text{\"C\"},\\, \\text{\"dx\"} \\mapsto \\text{\"D\"}\\,\\}$\n\n- Test case $3$:\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"((ax,ay),(az,aw));\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"},\\, \\text{\"ay\"} \\mapsto \\text{\"A\"},\\, \\text{\"az\"} \\mapsto \\text{\"A\"},\\, \\text{\"aw\"} \\mapsto \\text{\"A\"}\\,\\}$\n\n- Test case $4$:\n  - $S = \\text{\"((A,B),(C,D));\"}$\n  - $G = \\text{\"ax;\"}$\n  - $m = \\{\\,\\text{\"ax\"} \\mapsto \\text{\"A\"}\\,\\}$\n\nYour program should process the $4$ test cases and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the postorder list of boolean labels for one test case. For example, a valid output format is $\\text{\"[[False,True],[True],[False,False,True],[]]\"}$. No physical units or angle units are involved. All boolean outputs must be represented as the programming language’s canonical boolean literals. The answer for each test case must be a list of boolean values, and the final output must be a list of these lists printed on a single line exactly in the specified format.", "solution": "The problem presented is a classic algorithmic task in computational biology: the reconciliation of a gene tree with a species tree to infer evolutionary events. The method described is the standard Least Common Ancestor (LCA) reconciliation, a parsimonious model for explaining the discordance between a gene phylogeny and the organismal phylogeny that contains it. The solution requires the implementation of several distinct but related algorithms, which we will construct step-by-step.\n\nThe logical structure of the solution is as follows:\n$1$. Parse the Newick string representations of the species tree $S$ and the gene tree $G$ into a computational tree data structure.\n$2$. Pre-process the species tree $S$ to facilitate efficient computation of the Least Common Ancestor ($\\mathrm{LCA}_S$) for any two nodes within it.\n$3$. Traverse the gene tree $G$ in postorder, applying the reconciliation map $M$ to determine the event (duplication or speciation) at each internal node.\n\nLet us detail each step.\n\nA tree can be represented using a node-based structure, where each node object stores references to its parent and its children. A node may also have a name, which is essential for leaves. We define a `Node` class for this purpose. The children are stored in an ordered list to preserve the left-to-right topology specified by the Newick format. An internal node in a strictly binary tree will have exactly $2$ children, whereas a leaf will have $0$.\n\nThe Newick-format strings must be parsed into this `Node` structure. A recursive-descent parser is well-suited for this. Given a Newick string for a subtree, the parser operates as follows:\n- If the string does not start with `(`, it represents a leaf node. A new `Node` is created with the string as its name.\n- If the string is of the form `(left,right)`, it represents an internal node. A new `Node` is created. The string is split into `left` and `right` parts based on the comma that separates the two main subtrees. This requires a balanced parenthesis check to find the correct splitting comma. The parser is then called recursively on the `left` and `right` substrings to generate the child subtrees. The resulting child nodes are appended to the current node's children list, preserving the specified order.\n\nAfter parsing the species tree $S$, we augment its structure for efficient LCA queries. This is achieved by traversing the tree once to establish `parent` pointers for every node. With parent pointers, the $\\mathrm{LCA}_S(n_1, n_2)$ of two nodes $n_1$ and $n_2$ in $S$ can be found by first collecting all ancestors of $n_1$ (including $n_1$ itself) into a set. Then, we traverse upwards from $n_2$ until we encounter a node that is present in this set. This first common ancestor found is the $\\mathrm{LCA}_S(n_1, n_2)$.\n\nThe core of the solution is the reconciliation algorithm, which we implement as a recursive function, let us call it $ReconcileAndLabel(g\\_node, \\dots)$. This function traverses the gene tree $G$ and performs three actions at each node: it computes the node's image in $S$ under the reconciliation map $M$, it classifies the node if it is internal, and it returns its mapping in $S$. The traversal order is postorder (left child, right child, node), which is a natural consequence of the recursion.\n\nThe function $ReconcileAndLabel$ is defined as follows:\n- **Input**: A node $g$ from the gene tree $G$.\n- **Output**: The node $s \\in S$ to which $g$ maps, i.e., $s = M(g)$. As a side effect, it populates a list of boolean labels for internal nodes.\n\n**Base Case**: If the input node $g$ is a leaf (i.e., has $0$ children), its mapping $M(g)$ is given by the function $m$. We look up $m(g.name)$ to get the name of the corresponding species leaf, and then find the `Node` object for this leaf in our parsed species tree $S$. This `Node` is returned.\n\n**Recursive Step**: If the input node $g$ is an internal node with children $u$ and $v$ (in a strictly binary tree, these will be $g.children[0]$ and $g.children[1]$), the algorithm proceeds as follows:\n$1$. Recursively call the function on the left child, $u$: $s_u = ReconcileAndLabel(u, \\dots)$.\n$2$. Recursively call the function on the right child, $v$: $s_v = ReconcileAndLabel(v, \\dots)$.\n$3$. Compute the mapping for the current node $g$ by finding the LCA of its children's mappings: $s_g = M(g) = \\mathrm{LCA}_S(s_u, s_v)$.\n$4$. Classify the event at node $g$. According to the definition, $g$ represents a duplication if $M(g) = M(u)$ or $M(g) = M(v)$. In our implementation, this corresponds to checking if the node object $s_g$ is identical to $s_u$ or $s_v$. If this condition holds, the event is a duplication ($\\mathrm{True}$). Otherwise, it is a speciation ($\\mathrm{False}$).\n$5$. This boolean label for node $g$ is appended to a global list of results. Since this step occurs after the recursive calls for the children have completed, the labels are collected in a postorder sequence.\n$6$. The function returns the species tree node $s_g$.\n\nThe main procedure initializes an empty list for the labels, then calls $ReconcileAndLabel$ on the root of the gene tree $G$. If the gene tree consists of only a single node (the root is a leaf), it has no internal nodes, and an empty list is returned as required. Otherwise, the populated list of labels is the result for the given test case. This entire process is repeated for each test case provided.\n```python\nimport numpy as np\n\n# Note: The problem environment specifies numpy and scipy as available,\n# but they are not required for this particular algorithmic problem.\n# We include the numpy import to adhere to the specified environment setup.\n\nclass Node:\n    \"\"\"Represents a node in a tree.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        self.parent = None\n        self.children = []\n\n    def __repr__(self):\n        return f\"Node({self.name or 'internal'})\"\n\ndef parse_newick(newick_str: str) -> Node:\n    \"\"\"\n    Parses a Newick format string into a tree of Node objects.\n    Assumes strictly binary trees for internal nodes, but handles single-node trees.\n    \"\"\"\n    clean_str = newick_str.strip()\n    if clean_str.endswith(';'):\n        clean_str = clean_str[:-1]\n\n    if '(' not in clean_str:\n        # It's a single leaf node tree, e.g., \"ax\"\n        return Node(name=clean_str)\n\n    # Use a stack-based approach for robustness\n    stack = []\n    current_node = None\n    i = 0\n    while i < len(clean_str):\n        char = clean_str[i]\n        if char == '(':\n            new_node = Node()\n            if current_node:\n                current_node.children.append(new_node)\n            stack.append(new_node)\n            current_node = new_node\n        elif char == ',':\n            # Move from left sibling to parent, ready for right sibling\n            current_node = stack[-1]\n        elif char == ')':\n            # Finished with children of node on stack, pop it\n            current_node = stack.pop()\n        elif char not in ' ;':\n            # It's a name\n            name_start = i\n            while i + 1 < len(clean_str) and clean_str[i+1] not in ',)':\n                i += 1\n            name = clean_str[name_start:i+1]\n            leaf_node = Node(name=name)\n            if current_node:\n                current_node.children.append(leaf_node)\n        i += 1\n\n    return current_node or Node(name=clean_str) # Handles single node \"(A);\" case too\n\ndef add_parents(node: Node, parent: Node = None):\n    \"\"\"Recursively adds parent pointers to all nodes in a tree.\"\"\"\n    node.parent = parent\n    for child in node.children:\n        add_parents(child, node)\n\ndef collect_leaves(node: Node, leaf_map: dict):\n    \"\"\"Recursively collects leaf nodes into a dictionary mapping name to node.\"\"\"\n    if not node.children:\n        if node.name:\n            leaf_map[node.name] = node\n    else:\n        for child in node.children:\n            collect_leaves(child, leaf_map)\n\ndef get_lca(node1: Node, node2: Node) -> Node:\n    \"\"\"Finds the Least Common Ancestor of two nodes in a tree with parent pointers.\"\"\"\n    path_to_root1 = set()\n    curr = node1\n    while curr:\n        path_to_root1.add(curr)\n        curr = curr.parent\n    \n    curr = node2\n    while curr:\n        if curr in path_to_root1:\n            return curr\n        curr = curr.parent\n    # Should not be reached in a valid tree with common root\n    raise ValueError(\"Nodes do not share a common ancestor.\")\n\ndef reconcile_and_label(g_node: Node, s_leaf_map: dict, m_mapping: dict, labels: list) -> Node:\n    \"\"\"\n    Recursively traverses the gene tree, computes the reconciliation map,\n    labels internal nodes, and returns the mapped species tree node.\n    \"\"\"\n    if not g_node.children:  # Base case: g_node is a leaf\n        species_leaf_name = m_mapping[g_node.name]\n        return s_leaf_map[species_leaf_name]\n\n    # Recursive step: g_node is internal. Process children first (postorder).\n    # Newick order corresponds to children[0] (left) and children[1] (right).\n    s_map_left = reconcile_and_label(g_node.children[0], s_leaf_map, m_mapping, labels)\n    s_map_right = reconcile_and_label(g_node.children[1], s_leaf_map, m_mapping, labels)\n\n    # Compute mapping for the current node g\n    s_map_lca = get_lca(s_map_left, s_map_right)\n\n    # Classify event and record the label\n    # The check must be by object identity (is), not by value (==).\n    is_duplication = (s_map_lca is s_map_left) or (s_map_lca is s_map_right)\n    labels.append(is_duplication)\n    \n    return s_map_lca\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        (\n            \"((A,B),(C,D));\",\n            \"((ax,bz),(cw,dx));\",\n            {\"ax\": \"A\", \"bz\": \"B\", \"cw\": \"C\", \"dx\": \"D\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"(((ax,ay),bz),(cw,dx));\",\n            {\"ax\": \"A\", \"ay\": \"A\", \"bz\": \"B\", \"cw\": \"C\", \"dx\": \"D\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"((ax,ay),(az,aw));\",\n            {\"ax\": \"A\", \"ay\": \"A\", \"az\": \"A\", \"aw\": \"A\"}\n        ),\n        (\n            \"((A,B),(C,D));\",\n            \"ax;\",\n            {\"ax\": \"A\"}\n        ),\n    ]\n\n    all_results = []\n    for s_newick, g_newick, m_mapping in test_cases:\n        # 1. Prepare the species tree\n        s_root = parse_newick(s_newick)\n        add_parents(s_root)\n        s_leaf_map = {}\n        collect_leaves(s_root, s_leaf_map)\n\n        # 2. Prepare the gene tree\n        g_root = parse_newick(g_newick)\n        \n        # 3. Handle edge case of a single-node gene tree\n        if not g_root.children:\n            all_results.append([])\n            continue\n        \n        # 4. Reconcile and get postorder labels\n        labels = []\n        reconcile_and_label(g_root, s_leaf_map, m_mapping, labels)\n        all_results.append(labels)\n\n    # 5. Format and print the final output as a string representation of a list of lists.\n    # The string representation of a Python list of booleans matches the required format.\n    formatted_results = ','.join(map(str, all_results))\n    print(f\"[{formatted_results}]\")\n\n# solve() # This function is not called, as the problem requires returning the code itself as the solution.\n# The answer tag will contain the result of running this code.\n```", "answer": "```\n[[False, False, False], [True, False, False, False], [True, True, True], []]\n```", "id": "2378555"}]}