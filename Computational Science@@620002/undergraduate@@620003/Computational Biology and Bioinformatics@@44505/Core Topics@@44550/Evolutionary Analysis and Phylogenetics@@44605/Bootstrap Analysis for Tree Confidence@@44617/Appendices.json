{"hands_on_practices": [{"introduction": "Bootstrap support values are fundamental to assessing confidence in phylogenetic trees, but how are they actually generated? This practice problem strips away the complexity of typical tree-building software to reveal the core probabilistic mechanism at play. By calculating the exact change in support when a single informative site is altered [@problem_id:2377065], you will gain a firsthand understanding of how the composition of your alignment directly translates into statistical confidence.", "problem": "You are given a phylogenetic scenario with Deoxyribonucleic Acid (DNA) alignments of $4$ taxa, labeled $A$, $B$, $C$, and $D$. The goal is to precisely quantify how replacing a single, highly informative site with an ambiguous character $N$ (meaning \"unknown nucleotide\") alters the non-parametric bootstrap support for the clade $\\{A,B\\}$. Your program must compute the support for $\\{A,B\\}$ both before and after the $N$ replacement and report the drop in support. The computation must be based on first principles of bootstrap resampling and quartet inference, and results must be expressed as decimals (not as percentages).\n\nFundamental base and definitions:\n- A DNA alignment is a matrix with $4$ rows (taxa) and $L$ columns (sites). Each entry is one of $\\{A,C,G,T,N\\}$.\n- A bootstrap replicate is formed by sampling $L$ columns with replacement from the original alignment. This sampling is independent and identically distributed across positions, each original column having probability $1/L$ of being chosen on any draw.\n- For any replicate alignment, define the pairwise $p$-distance $d(X,Y)$ between taxa $X$ and $Y$ as the fraction of sites (over the $L$ sampled columns) where $X$ and $Y$ differ, ignoring any site where either $X$ or $Y$ has $N$. If a pair has zero valid sites after ignoring $N$, set $d(X,Y)=0$.\n- For the quartet $\\{A,B,C,D\\}$ in any replicate, infer the unrooted split by the strict four-point condition: select the split $\\{A,B\\}|\\{C,D\\}$ if and only if\n$$\nd(A,B) + d(C,D) \\lt \\min\\big(d(A,C)+d(B,D),\\ d(A,D)+d(B,C)\\big).\n$$\nIf the minimum is not achieved strictly (i.e., any tie), treat the replicate as providing no support for $\\{A,B\\}$.\n- The bootstrap support for $\\{A,B\\}$ is the fraction of bootstrap replicates whose inferred split is $\\{A,B\\}|\\{C,D\\}$. In this problem you must compute the exact value implied by the resampling scheme for the alignments provided, not an asymptotic confidence or a heuristic score.\n\nSite manipulation rule:\n- “Replacing a site with $N$” means: choose one specified column index and replace the character in that column with $N$ for all $4$ taxa. All other columns remain unchanged.\n\nTask requirements:\n- For each test case, compute two supports for the clade $\\{A,B\\}$: before and after replacing the specified column(s) with $N$ (the replacement set can be one or more columns, as specified in the test case). Then compute the drop as\n$$\n\\Delta = \\text{support}_{\\text{before}} - \\text{support}_{\\text{after}},\n$$\nexpressed as a decimal in $[0,1]$. Report each $\\Delta$ rounded to exactly $3$ decimal places.\n- Important constraint: All test cases below are constructed so that every site is either constant across all taxa or is a parsimony-informative site of the form $A/A$ versus $G/G$ on $\\{A,B\\}$ versus $\\{C,D\\}$ (no other informative patterns appear), and there are no $N$ symbols initially. Under these conditions, a bootstrap replicate supports $\\{A,B\\}$ if and only if at least one such informative site is sampled at least once in that replicate. Your program must use correct logic that is universally consistent with the definitions above.\n\nTest suite:\n- Test case $1$ (happy path with one decisive site):\n  - Taxa: $A,B,C,D$.\n  - Alignment length $L=20$.\n  - Alignment: all sites are $A$ for all taxa except at column index $3$ (zero-based), where $A$ and $B$ have $A$ and $C$ and $D$ have $G$.\n  - Replacement: replace column index $3$ with $N$ for all taxa.\n- Test case $2$ (robust signal with many decisive sites):\n  - Taxa: $A,B,C,D$.\n  - Alignment length $L=40$.\n  - Alignment: all sites are $A$ for all taxa except at the $10$ column indices $\\{1,5,9,13,17,21,25,29,33,37\\}$ (zero-based), where $A$ and $B$ have $A$ and $C$ and $D$ have $G$.\n  - Replacement: replace only column index $1$ with $N$ for all taxa.\n- Test case $3$ (boundary case with a single site):\n  - Taxa: $A,B,C,D$.\n  - Alignment length $L=1$.\n  - Alignment: at column index $0$, $A$ and $B$ have $A$ and $C$ and $D$ have $G$.\n  - Replacement: replace column index $0$ with $N$ for all taxa.\n\nFinal output format:\n- Your program should produce a single line of output containing the three drops $\\Delta$ for the test cases in order, as a comma-separated list enclosed in square brackets. Each value must be rounded to exactly $3$ decimal places. For example, an acceptable format is\n\"[0.123,0.456,0.789]\".", "solution": "The problem statement has been rigorously validated and found to be scientifically grounded, well-posed, and objective. It presents a standard, albeit simplified, scenario in phylogenetic inference, providing all necessary definitions and data to derive a unique, verifiable solution. The problem is valid and will be solved as stated.\n\nThe core of the problem is to compute the bootstrap support for a clade, which is the probability that a bootstrap replicate will satisfy a given topological condition. The analysis requires a derivation from first principles.\n\nFirst, let us formalize the condition for a replicate to support the split $\\{A,B\\}|\\{C,D\\}$. The problem specifies that this support exists if, and only if, the strict four-point condition is met:\n$$\nd(A,B) + d(C,D)  \\min\\big(d(A,C)+d(B,D),\\ d(A,D)+d(B,C)\\big)\n$$\nwhere $d(X,Y)$ is the pairwise $p$-distance. The problem is constrained such that all sites in the original alignment are either constant across all four taxa or parsimony-informative for the split $\\{A,B\\}|\\{C,D\\}$.\n\nLet us analyze the contribution of each site type to the pairwise distances in a bootstrap replicate of length $L$.\nA bootstrap replicate is formed by sampling $L$ columns, with replacement, from the original alignment. Let a given replicate contain $k_I$ informative sites, $k_C$ constant sites, and $k_N$ sites where all characters are $N$. The total number of sampled sites is $L=k_I + k_C + k_N$.\n\nThe $p$-distance $d(X,Y)$ is defined as the fraction of differing sites, ignoring any site where either taxon has an 'N'.\nFor any site of type $(c,c,c,c)$ (constant) or $(X,X,Y,Y)$ (informative for $\\{A,B\\}|\\{C,D\\}$), all characters are from $\\{A,C,G,T\\}$. For a site of type $(N,N,N,N)$, it is ignored for all distance calculations.\nThus, the number of valid sites for computing any pairwise distance $d(X,Y)$ is $L_{\\text{valid}} = k_I + k_C$.\n\nIf $L_{\\text{valid}} = 0$, which occurs if and only if a replicate consists solely of columns where all taxa are $N$, then all pairwise distances are defined to be $0$. The support condition becomes $0  \\min(0,0)$, which is false. Such a replicate provides no support.\n\nIf $L_{\\text{valid}}  0$:\n- For taxa $A$ and $B$, their sequences are identical at all informative and constant sites. The number of differences is $0$. Thus, $d(A,B) = 0/L_{\\text{valid}} = 0$.\n- Similarly, for taxa $C$ and $D$, their sequences are identical. Thus, $d(C,D) = 0$.\n- The left-hand side of the inequality is $d(A,B) + d(C,D) = 0$.\n\n- For taxa $A$ and $C$, their sequences are identical at constant sites but differ at all $k_I$ informative sites. The number of differences is $k_I$. Thus, $d(A,C) = k_I / L_{\\text{valid}}$.\n- By symmetry of the informative pattern, $d(B,D) = d(A,D) = d(B,C) = k_I / L_{\\text{valid}}$.\n- The right-hand side of the inequality is $\\min(d(A,C)+d(B,D), d(A,D)+d(B,C)) = \\min(2k_I/L_{\\text{valid}}, 2k_I/L_{\\text{valid}}) = 2k_I/L_{\\text{valid}}$.\n\nThe four-point condition for support becomes $0  2k_I/L_{\\text{valid}}$. This inequality holds if and only if $k_I  0$. Therefore, a bootstrap replicate supports the clade $\\{A,B\\}$ if and only if it contains at least one informative site. This verifies the assertion made in the problem statement.\n\nThe task now reduces to a probability calculation. Let $L$ be the total number of sites in the alignment and $I$ be the number of informative sites. The remaining $L-I$ sites are non-informative (constant or all-$N$).\nThe probability of selecting a non-informative site in a single draw is $p_{\\text{non-I}} = (L-I)/L$.\nSince a bootstrap replicate consists of $L$ independent draws, the probability that all $L$ sites sampled are non-informative is:\n$$\nP(\\text{no support}) = \\left(\\frac{L-I}{L}\\right)^L\n$$\nThe bootstrap support is the probability of the complementary event, i.e., at least one informative site is sampled:\n$$\n\\text{Support}(L, I) = 1 - P(\\text{no support}) = 1 - \\left(\\frac{L-I}{L}\\right)^L\n$$\nThis formula provides the exact support value. We apply this to each test case.\n\nTest Case 1:\n- Alignment length $L=20$.\n- Before replacement: There is one informative site at column index $3$. Thus, $I_{\\text{before}} = 1$.\n  $\\text{Support}_{\\text{before}} = 1 - \\left(\\frac{20-1}{20}\\right)^{20} = 1 - (0.95)^{20}$.\n- After replacement: The informative site is replaced with $N$s, becoming non-informative. Thus, $I_{\\text{after}} = 0$.\n  $\\text{Support}_{\\text{after}} = 1 - \\left(\\frac{20-0}{20}\\right)^{20} = 1 - 1^{20} = 0$.\n- Drop in support: $\\Delta_1 = \\text{Support}_{\\text{before}} - \\text{Support}_{\\text{after}} = 1 - (0.95)^{20} \\approx 0.641514$.\n\nTest Case 2:\n- Alignment length $L=40$.\n- Before replacement: There are $10$ informative sites. Thus, $I_{\\text{before}} = 10$.\n  $\\text{Support}_{\\text{before}} = 1 - \\left(\\frac{40-10}{40}\\right)^{40} = 1 - (0.75)^{40}$.\n- After replacement: One of the informative sites is replaced with $N$s. $9$ informative sites remain. Thus, $I_{\\text{after}} = 9$.\n  $\\text{Support}_{\\text{after}} = 1 - \\left(\\frac{40-9}{40}\\right)^{40} = 1 - (0.775)^{40}$.\n- Drop in support: $\\Delta_2 = \\left(1 - (0.75)^{40}\\right) - \\left(1 - (0.775)^{40}\\right) = (0.775)^{40} - (0.75)^{40} \\approx 0.0000119$.\n\nTest Case 3:\n- Alignment length $L=1$.\n- Before replacement: The single site is informative. Thus, $I_{\\text{before}} = 1$.\n  $\\text{Support}_{\\text{before}} = 1 - \\left(\\frac{1-1}{1}\\right)^1 = 1 - 0^1 = 1$.\n- After replacement: The single informative site is removed. Thus, $I_{\\text{after}} = 0$.\n  $\\text{Support}_{\\text{after}} = 1 - \\left(\\frac{1-0}{1}\\right)^1 = 1 - 1^1 = 0$.\n- Drop in support: $\\Delta_3 = 1 - 0 = 1$.\n\nThe final results are these $\\Delta$ values, rounded to $3$ decimal places.\n$\\Delta_1 \\approx 0.642$\n$\\Delta_2 \\approx 0.000$\n$\\Delta_3 = 1.000$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the drop in bootstrap support for the clade {A,B} for three test cases.\n    The support is calculated based on the exact probability of sampling at least one \n    informative site in a bootstrap replicate.\n    \"\"\"\n\n    def calculate_support(L, I):\n        \"\"\"\n        Calculates the exact bootstrap support.\n\n        Args:\n            L (int): The total number of sites in the alignment.\n            I (int): The number of informative sites for the clade of interest.\n\n        Returns:\n            float: The bootstrap support value, a probability in [0, 1].\n        \"\"\"\n        if L = 0:\n            return 0.0\n        if I = 0:\n            return 0.0\n\n        # The probability of not sampling an informative site in a single draw.\n        prob_non_informative_draw = (L - I) / L\n        \n        # The probability of not sampling any informative site in L draws.\n        prob_no_support = np.power(prob_non_informative_draw, L)\n        \n        # The support is the complementary probability.\n        return 1.0 - prob_no_support\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (L, I_before, I_after)\n    test_cases = [\n        # Test Case 1: L=20, 1 informative site, which is then removed.\n        (20, 1, 0),\n        # Test Case 2: L=40, 10 informative sites, 1 of which is removed.\n        (40, 10, 9),\n        # Test Case 3: L=1, 1 informative site, which is then removed.\n        (1, 1, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, I_before, I_after = case\n        \n        support_before = calculate_support(L, I_before)\n        support_after = calculate_support(L, I_after)\n        \n        delta = support_before - support_after\n        results.append(delta)\n\n    # Format the results as specified: a list of strings rounded to 3 decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2377065"}, {"introduction": "A common assumption is that high bootstrap support, for example, a value greater than $0.95$, indicates strong and reliable evidence for a clade, but this is not always true. Here, you will explore a classic artifact known as the \"bootstrap paradise,\" where a small number of consistent characters in a dataset with very little conflicting signal can produce deceptively high support values [@problem_id:2377030]. This simulation-based exercise will help you cultivate a critical eye for interpreting bootstrap results and understand the difference between statistical consistency and the true weight of evidence.", "problem": "You are asked to investigate the phenomenon sometimes called the \"bootstrap paradise\" in phylogenetic inference, where extremely low noise but very few informative sites can yield misleadingly high bootstrap support. Work in the setting of four taxa labeled $A$, $B$, $C$, and $D$ and use the maximum parsimony criterion on a per-site basis. The fundamental base for this problem is as follows:\n\n- A site is parsimony-informative (for four taxa) if and only if it exhibits a 2-2 split of identical states across the taxa. Such a site supports exactly one of the three possible unrooted splits: $A B \\mid C D$, $A C \\mid B D$, or $A D \\mid B C$.\n- In maximum parsimony for four taxa, for an alignment with $N$ sites, if all parsimony-informative sites are of the 2-2 type, the total parsimony score for a topology differs only by how many such sites support that topology. Non-informative sites (invariant or singleton patterns) contribute equally across topologies and therefore do not affect which topology minimizes the total score.\n\nBootstrap resampling is defined as follows:\n\n- A nonparametric bootstrap replicate is obtained by sampling $N$ alignment columns with replacement from the original $N$ columns.\n- For each replicate, compute which of the three unrooted topologies minimizes the parsimony score. If there is a unique minimizer, record the chosen topology; if there is a tie (including the case where no parsimony-informative sites are drawn), treat the replicate as unresolved and do not count it as supporting any specific topology.\n\nYou will simulate alignments at the level of site categories rather than explicit nucleotides. Each alignment of length $N$ is composed of:\n- $m_{\\text{corr}}$ parsimony-informative columns that support the focal split $A B \\mid C D$,\n- $m_{\\text{conf}}$ parsimony-informative columns that support the conflicting split $A C \\mid B D$,\n- $m_{\\text{oth}}$ parsimony-informative columns that support the remaining split $A D \\mid B C$,\n- and $N - m_{\\text{corr}} - m_{\\text{conf}} - m_{\\text{oth}}$ non-informative columns.\n\nIn a bootstrap replicate of size $N$, the vector of sampled counts across these four site categories is multinomial with parameters $N$ and category probabilities $\\left(\\frac{m_{\\text{corr}}}{N}, \\frac{m_{\\text{conf}}}{N}, \\frac{m_{\\text{oth}}}{N}, 1 - \\frac{m_{\\text{corr}} + m_{\\text{conf}} + m_{\\text{oth}}}{N}\\right)$. Let $X_{\\text{corr}}$, $X_{\\text{conf}}$, and $X_{\\text{oth}}$ be the sampled counts for the three informative categories. Under maximum parsimony, the chosen topology is the one whose count is strictly the largest among $\\left\\{X_{\\text{corr}}, X_{\\text{conf}}, X_{\\text{oth}}\\right\\}$. If the maximum is not unique, the replicate is unresolved.\n\nYour task is to write a complete, runnable program that:\n- Implements the described bootstrap procedure using the multinomial distribution for efficiency.\n- Uses an identical number $B$ of bootstrap replicates per test case (resample size $N$ for each replicate).\n- Computes the bootstrap support for the focal split $A B \\mid C D$ as the fraction of bootstrap replicates for which $X_{\\text{corr}}$ is strictly greater than both $X_{\\text{conf}}$ and $X_{\\text{oth}}$.\n\nImportant details and constraints:\n- Express support as a decimal proportion (not a percentage), rounded to exactly $6$ digits after the decimal point.\n- Use a fixed pseudorandom seed per test case to ensure deterministic results.\n- The resample size per bootstrap replicate must be exactly $N$.\n- If $m_{\\text{corr}} + m_{\\text{conf}} + m_{\\text{oth}} = 0$, no replicate can support any topology; the support must be $0.0$.\n\nTest suite:\n- Use $B = 20000$ bootstrap replicates for each of the following four parameter sets, and the specified seeds:\n    1. $N = 100$, $m_{\\text{corr}} = 4$, $m_{\\text{conf}} = 0$, $m_{\\text{oth}} = 0$, seed $= 1$.\n    2. $N = 100$, $m_{\\text{corr}} = 0$, $m_{\\text{conf}} = 0$, $m_{\\text{oth}} = 0$, seed $= 2$.\n    3. $N = 100$, $m_{\\text{corr}} = 5$, $m_{\\text{conf}} = 1$, $m_{\\text{oth}} = 0$, seed $= 3$.\n    4. $N = 100$, $m_{\\text{corr}} = 3$, $m_{\\text{conf}} = 3$, $m_{\\text{oth}} = 0$, seed $= 4$.\n\nFinal output format:\n- Your program should produce a single line of output containing the four bootstrap supports, in order, as a comma-separated list enclosed in square brackets. Each support must be printed as a decimal proportion rounded to exactly $6$ digits after the decimal point. For example: $[0.981684,0.000000,0.951000,0.487000]$ (illustrative only; do not hard-code values).\n\nYour implementation must be self-contained and must not read input or write any files. It must use a fixed pseudorandom seed per test case exactly as specified above. The only permitted libraries are the Python standard library and the specified numerical libraries.", "solution": "We formalize the \"bootstrap paradise\" mechanism from first principles and derive an algorithm consistent with maximum parsimony on four taxa and nonparametric bootstrapping.\n\nFoundational definitions and facts:\n- A parsimony-informative site for four taxa is one that exhibits a 2-2 pattern of identical states; such a site supports exactly one of the three unrooted splits: $A B \\mid C D$, $A C \\mid B D$, or $A D \\mid B C$.\n- For four taxa, when all informative sites are of the 2-2 type, maximum parsimony selects the topology that is supported by the largest number of 2-2 sites across the alignment. Non-informative sites (invariant or singleton) do not affect which topology has the minimal total number of changes because they contribute equally to all topologies.\n- In nonparametric bootstrapping, we sample $N$ columns with replacement from an alignment of length $N$ to form a replicate, and infer the optimal topology on this replicate using the same criterion. Repeating this $B$ times yields a distribution of inferred topologies.\n\nModeling the resampling at the level of categories:\n- Let the alignment have $N$ columns composed of $m_{\\text{corr}}$ columns supporting $A B \\mid C D$, $m_{\\text{conf}}$ columns supporting $A C \\mid B D$, $m_{\\text{oth}}$ columns supporting $A D \\mid B C$, and $N - m_{\\text{corr}} - m_{\\text{conf}} - m_{\\text{oth}}$ non-informative columns.\n- In a single bootstrap replicate (size $N$), the vector of counts across the four categories follows a multinomial distribution:\n$$\n(X_{\\text{corr}}, X_{\\text{conf}}, X_{\\text{oth}}, X_{\\text{non}}) \\sim \\mathrm{Multinomial}\\!\\left(N;\\ \\frac{m_{\\text{corr}}}{N},\\ \\frac{m_{\\text{conf}}}{N},\\ \\frac{m_{\\text{oth}}}{N},\\ 1 - \\frac{m_{\\text{corr}} + m_{\\text{conf}} + m_{\\text{oth}}}{N}\\right).\n$$\n- Under maximum parsimony, the inferred topology is determined by the strict maximum among $\\{X_{\\text{corr}}, X_{\\text{conf}}, X_{\\text{oth}}\\}$. If the maximum is attained by more than one of these counts (including the case where they are all zero), the replicate is unresolved and does not support any single topology.\n\nBootstrapped support for the focal split $A B \\mid C D$ is therefore\n$$\n\\hat{s} \\;=\\; \\frac{1}{B} \\sum_{b=1}^{B} \\mathbf{1}\\!\\left( X_{\\text{corr}}^{(b)}  \\max\\{X_{\\text{conf}}^{(b)}, X_{\\text{oth}}^{(b)}\\} \\right),\n$$\nwhere $\\mathbf{1}(\\cdot)$ is the indicator function and the superscript $(b)$ indexes the bootstrap replicate.\n\nWhy \"bootstrap paradise\" can occur:\n- Consider the case $m_{\\text{conf}} = 0$ and $m_{\\text{oth}} = 0$. Then the only way a replicate fails to support $A B \\mid C D$ is if no $A B \\mid C D$ informative column is sampled, i.e., $X_{\\text{corr}} = 0$. Because each of the $N$ draws has probability $m_{\\text{corr}}/N$ of being one of the $m_{\\text{corr}}$ informative columns, the probability that a single particular informative column is not drawn is $(1 - 1/N)^{N} \\approx e^{-1}$, and the probability that none of the $m_{\\text{corr}}$ informative columns are drawn is approximately $(1 - m_{\\text{corr}}/N)^{N} \\approx e^{-m_{\\text{corr}}}$. Thus,\n$$\n\\mathbb{E}[\\hat{s}] \\approx 1 - e^{-m_{\\text{corr}}}.\n$$\nEven for very small $m_{\\text{corr}}$, this can be deceptively close to $1$: for $m_{\\text{corr}} = 4$, $1 - e^{-4} \\approx 0.981684$, for $m_{\\text{corr}} = 5$, $1 - e^{-5} \\approx 0.993262$. This illustrates how very few consistent informative sites with essentially no noise can yield very high bootstrap support, despite the inherently weak amount of information in the data.\n\nAlgorithmic design:\n- For each test case $(N, m_{\\text{corr}}, m_{\\text{conf}}, m_{\\text{oth}}, B, \\text{seed})$:\n    1. Set the pseudorandom generator with the specified seed to ensure reproducibility.\n    2. Define category probabilities $p_{\\text{corr}} = m_{\\text{corr}}/N$, $p_{\\text{conf}} = m_{\\text{conf}}/N$, $p_{\\text{oth}} = m_{\\text{oth}}/N$, $p_{\\text{non}} = 1 - p_{\\text{corr}} - p_{\\text{conf}} - p_{\\text{oth}}$.\n    3. Draw $B$ independent replicates from the multinomial distribution $\\mathrm{Multinomial}(N, [p_{\\text{corr}}, p_{\\text{conf}}, p_{\\text{oth}}, p_{\\text{non}}])$.\n    4. For each replicate, compute whether $X_{\\text{corr}}$ is strictly larger than both $X_{\\text{conf}}$ and $X_{\\text{oth}}$; if yes, count it as support for $A B \\mid C D$.\n    5. Compute the proportion of supporting replicates as the bootstrap support $\\hat{s}$.\n    6. Round $\\hat{s}$ to exactly $6$ digits after the decimal point.\n\nComputational considerations:\n- The multinomial draws can be vectorized using numerical libraries, making the simulation efficient even for $B = 20000$ and $N = 100$.\n- Time complexity per test case is $O(B)$ with small constant factors due to vectorized operations; memory is $O(B)$ for storing the draws temporarily, which is moderate for the given sizes.\n\nTest suite interpretation and expectations:\n- Case $1$ ($N = 100$, $m_{\\text{corr}} = 4$, no conflict): By the approximation above, the expected support is close to $1 - e^{-4} \\approx 0.981684$, demonstrating \"bootstrap paradise.\"\n- Case $2$ ($N = 100$, no informative sites): There is no possibility of support; the support must be $0.000000$.\n- Case $3$ ($N = 100$, $m_{\\text{corr}} = 5$, $m_{\\text{conf}} = 1$): Noise is extremely low; most replicates will have $X_{\\text{corr}}  X_{\\text{conf}}$, and the support will be high (close to, but slightly below, the no-conflict approximation).\n- Case $4$ ($N = 100$, $m_{\\text{corr}} = 3$, $m_{\\text{conf}} = 3$): The counts for the two competing splits are balanced on average; the support will be near $0.5$ but reduced by the probability of ties where $X_{\\text{corr}} = X_{\\text{conf}}$, which are treated as unresolved.\n\nThe final program implements this algorithm exactly, uses the specified seeds, and prints the four supports in a single line as a bracketed, comma-separated list, each rounded to $6$ decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef bootstrap_support(N: int, m_corr: int, m_conf: int, m_oth: int, B: int, seed: int) - float:\n    \"\"\"\n    Compute bootstrap support for the AB|CD split under maximum parsimony\n    given counts of site categories, using multinomial resampling.\n\n    Parameters:\n        N      : alignment length (number of columns)\n        m_corr : number of AB|CD-informative columns (supports focal split)\n        m_conf : number of AC|BD-informative columns (conflicting split)\n        m_oth  : number of AD|BC-informative columns (other split)\n        B      : number of bootstrap replicates\n        seed   : RNG seed for reproducibility\n\n    Returns:\n        support proportion as a float (not percentage)\n    \"\"\"\n    # Category probabilities for multinomial sampling\n    p_corr = m_corr / N\n    p_conf = m_conf / N\n    p_oth = m_oth / N\n    p_non = 1.0 - (p_corr + p_conf + p_oth)\n    # Guard for numerical drift\n    if p_non  0:\n        raise ValueError(\"Sum of informative sites exceeds N.\")\n    pvals = np.array([p_corr, p_conf, p_oth, p_non], dtype=float)\n\n    rng = np.random.default_rng(seed)\n    # Draw B multinomial samples: shape (B, 4)\n    counts = rng.multinomial(n=N, pvals=pvals, size=B)\n    # Extract counts for the three informative categories\n    X_corr = counts[:, 0]\n    X_conf = counts[:, 1]\n    X_oth = counts[:, 2]\n\n    # Determine unique maximum among the three categories\n    # Compute maximum and count how many attain it\n    max_vals = np.maximum.reduce([X_corr, X_conf, X_oth])\n    is_max_corr = (X_corr == max_vals)\n    is_max_conf = (X_conf == max_vals)\n    is_max_oth = (X_oth == max_vals)\n    # Count of categories attaining the maximum per replicate\n    max_ties = (is_max_corr.astype(int) +\n                is_max_conf.astype(int) +\n                is_max_oth.astype(int))\n\n    # Unique winner mask (no ties)\n    unique_winner = (max_ties == 1)\n    # Among unique winners, check if AB|CD (corr) is the winner\n    support_mask = unique_winner  is_max_corr\n\n    support = support_mask.mean()\n    return float(support)\n\ndef solve():\n    # Define the test cases from the problem statement: (N, m_corr, m_conf, m_oth, B, seed)\n    B = 20000\n    test_cases = [\n        (100, 4, 0, 0, B, 1),  # Bootstrap paradise: few informative, no noise\n        (100, 0, 0, 0, B, 2),  # Boundary: no informative sites\n        (100, 5, 1, 0, B, 3),  # Very low noise\n        (100, 3, 3, 0, B, 4),  # Balanced conflicting signal\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m_corr, m_conf, m_oth, B_rep, seed = case\n        val = bootstrap_support(N, m_corr, m_conf, m_oth, B_rep, seed)\n        results.append(f\"{val:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2377030"}, {"introduction": "When performing a bootstrap analysis, one of the first practical questions is \"How many replicates should I run?\". While common rules of thumb exist, a rigorous answer lies in the principles of statistical sampling theory. This exercise challenges you to move beyond heuristics by deriving and applying formulas to calculate the minimum number of replicates, $B$, needed to ensure your support estimates are precise and reliable, controlling for error across all branches in the tree simultaneously [@problem_id:2377053].", "problem": "You are given a phylogenetic dataset with $50$ taxa and $1000$ aligned sites. In nonparametric bootstrap analysis for tree confidence, each bootstrap replicate resamples the $1000$ sites with replacement, reconstructs a tree, and records whether each internal clade (branch) in a reference tree is recovered. Treat each replicate, for a fixed clade, as generating an independent Bernoulli indicator with success probability $p$ that the clade is recovered. The bootstrap support estimate for a clade after $B$ replicates is the sample mean of these indicators over $B$ independent replicates.\n\nAssume an unrooted, fully resolved reference tree on $n$ taxa. The number of internal branches is $m = n - 3$. For $n = 50$, use $m = 47$. You are to determine the minimal number of bootstrap replicates $B$ required so that, simultaneously for all $m$ internal clades, the absolute error between the true support probability $p_i$ and its bootstrap estimate $\\hat{p}_i$ is at most a user-specified tolerance $\\varepsilon$, with a specified family-wise confidence level $1 - \\alpha$. Here the family-wise confidence level means that the probability that any internal clade’s estimate deviates by more than $\\varepsilon$ is at most $\\alpha$.\n\nFundamental base:\n- The bootstrap indicator for a fixed clade across replicates is a sequence of independent and identically distributed Bernoulli random variables with success probability $p$.\n- The sample mean of independent Bernoulli random variables is the estimator $\\hat{p}$ for $p$.\n- A distribution-free concentration inequality for bounded independent random variables provides an exponential tail bound for deviations of the sample mean from its expectation.\n- The Normal distribution approximation to the Binomial distribution provides an approximate two-sided confidence interval for a proportion with a user-specified coverage, and a Bonferroni correction can be used to control the family-wise error rate (FWER) across $m$ clades.\n\nTask:\n- Using the concentration-inequality approach that guarantees family-wise control without distributional assumptions beyond independence and boundedness, derive an explicit formula for the minimal integer $B$ that ensures the family-wise deviation bound $\\max_{1 \\le i \\le m} |\\hat{p}_i - p_i| \\le \\varepsilon$ with probability at least $1 - \\alpha$. Implement this as $B_{\\text{Ineq}}$, taking the minimal integer $B$ that satisfies the bound.\n- Using the Normal approximation to the Binomial distribution for a two-sided confidence interval and a Bonferroni correction across the $m$ clades, derive an explicit formula for the minimal integer $B$ that ensures the same family-wise deviation bound. Implement this as $B_{\\text{Norm}}$. For this approximation, use either:\n  - a worst-case variance assumption $p(1-p) \\le \\tfrac{1}{4}$ when no pilot support is given, or\n  - a user-provided pilot support $p_0 \\in (0,1)$ to substitute $p(1-p)$ with $p_0(1-p_0)$ when provided.\n- Always report $B$ as the smallest integer $B$ that satisfies the required guarantee (i.e., apply the ceiling operation).\n- Explain why the number of aligned sites ($1000$) does not directly enter into the calculation of $B$ under these assumptions.\n\nAngle units are not applicable. There are no physical units. All tolerance and confidence inputs are expressed as decimals, not as percentages.\n\nTest suite:\nFor all test cases below, use $n = 50$ taxa (so $m = 47$ internal clades for an unrooted, fully resolved tree). For each case, compute and report the pair $[B_{\\text{Ineq}}, B_{\\text{Norm}}]$.\n\n- Case $1$: $\\varepsilon = 0.02$, $\\alpha = 0.05$, no pilot support (use worst-case variance for the Normal approximation).\n- Case $2$: $\\varepsilon = 0.01$, $\\alpha = 0.05$, pilot support $p_0 = 0.8$.\n- Case $3$: $\\varepsilon = 0.03$, $\\alpha = 0.01$, no pilot support.\n- Case $4$: $\\varepsilon = 0.05$, $\\alpha = 0.10$, pilot support $p_0 = 0.7$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the pair $[B_{\\text{Ineq}},B_{\\text{Norm}}]$ for the corresponding test case, in the order listed above. For example, the program must print a line of the form\n[[B1_Ineq,B1_Norm],[B2_Ineq,B2_Norm],[B3_Ineq,B3_Norm],[B4_Ineq,B4_Norm]]\nwith no extra text.", "solution": "The problem statement is scientifically sound, well-posed, and contains all necessary information for a unique solution. It is based on established principles of statistical inference, specifically bootstrap theory, concentration inequalities, and hypothesis testing with family-wise error rate control. The problem is formalizable and objective. Therefore, I will proceed with the derivation and solution.\n\nThe objective is to find the minimum number of bootstrap replicates, $B$, required to ensure that for all $m$ internal clades of an unrooted phylogenetic tree, the absolute error between the true support probability $p_i$ and its bootstrap estimate $\\hat{p}_i$ is no more than a specified tolerance $\\varepsilon$, with a family-wise confidence level of $1 - \\alpha$. The number of taxa is $n=50$, which for a fully resolved unrooted tree implies $m = n - 3 = 47$ internal clades.\n\nThe core probabilistic statement to satisfy is:\n$$P\\left( \\max_{1 \\le i \\le m} |\\hat{p}_i - p_i| \\le \\varepsilon \\right) \\ge 1 - \\alpha$$\nThis is equivalent to controlling the family-wise error rate (FWER) such that the probability of at least one estimate having an error greater than $\\varepsilon$ is bounded by $\\alpha$:\n$$P\\left( \\bigcup_{i=1}^{m} \\{|\\hat{p}_i - p_i|  \\varepsilon\\} \\right) \\le \\alpha$$\nWe will use the union bound (also known as Boole's inequality) to control this FWER. The union bound states that for any set of events $A_1, A_2, \\ldots, A_m$:\n$$P\\left(\\bigcup_{i=1}^{m} A_i\\right) \\le \\sum_{i=1}^{m} P(A_i)$$\nIn our context, let $A_i$ be the event $\\{|\\hat{p}_i - p_i|  \\varepsilon\\}$. The condition becomes $\\sum_{i=1}^{m} P(|\\hat{p}_i - p_i|  \\varepsilon) \\le \\alpha$.\n\nThe estimate $\\hat{p}_i$ is the sample mean of $B$ independent Bernoulli random variables, each with expectation $p_i$. We now derive the formulas for $B$ using two different approaches.\n\n**1. Concentration Inequality Approach ($B_{\\text{Ineq}}$)**\n\nThis method uses a distribution-free bound. Hoeffding's inequality is appropriate here. For a sum of $B$ independent random variables bounded within an interval of width $W$, the sample mean $\\bar{X}$ deviates from the true mean $\\mu$ by at least $\\varepsilon$ with probability:\n$$P(|\\bar{X} - \\mu|  \\varepsilon) \\le 2 \\exp\\left(-\\frac{2 B \\varepsilon^2}{W^2}\\right)$$\nFor our Bernoulli indicators, the variables are in $\\{0, 1\\}$, so the width of the interval is $W = 1 - 0 = 1$. Thus, for a single clade $i$:\n$$P(|\\hat{p}_i - p_i|  \\varepsilon) \\le 2 \\exp(-2 B \\varepsilon^2)$$\nApplying the union bound across all $m$ clades:\n$$\\sum_{i=1}^{m} P(|\\hat{p}_i - p_i|  \\varepsilon) \\le \\sum_{i=1}^{m} 2 \\exp(-2 B \\varepsilon^2) = 2m \\exp(-2 B \\varepsilon^2)$$\nTo satisfy the family-wise confidence requirement, we set this upper bound to be less than or equal to $\\alpha$:\n$$2m \\exp(-2 B \\varepsilon^2) \\le \\alpha$$\nWe solve for $B$:\n$$\\exp(-2 B \\varepsilon^2) \\le \\frac{\\alpha}{2m}$$\n$$-2 B \\varepsilon^2 \\le \\ln\\left(\\frac{\\alpha}{2m}\\right)$$\n$$2 B \\varepsilon^2 \\ge -\\ln\\left(\\frac{\\alpha}{2m}\\right) = \\ln\\left(\\frac{2m}{\\alpha}\\right)$$\n$$B \\ge \\frac{\\ln\\left(\\frac{2m}{\\alpha}\\right)}{2 \\varepsilon^2}$$\nThe minimal integer number of replicates, $B_{\\text{Ineq}}$, is therefore the ceiling of this expression:\n$$B_{\\text{Ineq}} = \\left\\lceil \\frac{\\ln(2m / \\alpha)}{2 \\varepsilon^2} \\right\\rceil$$\n\n**2. Normal Approximation with Bonferroni Correction ($B_{\\text{Norm}}$)**\n\nThis method relies on the Central Limit Theorem, which states that for large $B$, the sample proportion $\\hat{p}_i$ is approximately normally distributed:\n$$\\hat{p}_i \\approx \\mathcal{N}\\left(p_i, \\frac{p_i(1 - p_i)}{B}\\right)$$\nThe standardized variable $Z_i = \\frac{\\hat{p}_i - p_i}{\\sqrt{p_i(1-p_i)/B}}$ follows a standard normal distribution, $\\mathcal{N}(0, 1)$.\nTo control the FWER at level $\\alpha$ across $m$ clades, we use the Bonferroni correction, which requires the error probability for each individual clade to be bounded by $\\alpha/m$.\n$$P(|\\hat{p}_i - p_i|  \\varepsilon) \\le \\frac{\\alpha}{m}$$\nIn terms of the standard normal variable $Z_i$, this becomes:\n$$P\\left(|Z_i|  \\frac{\\varepsilon}{\\sqrt{p_i(1 - p_i)/B}}\\right) \\le \\frac{\\alpha}{m}$$\nLet $z_{\\alpha/(2m)}$ be the critical value from the standard normal distribution such that the upper tail probability is $\\alpha/(2m)$, i.e., $P(Z  z_{\\alpha/(2m)}) = \\alpha/(2m)$. This corresponds to an inverse cumulative distribution function value of $\\Phi^{-1}(1 - \\alpha/(2m))$. For the two-sided inequality to hold, we require:\n$$\\frac{\\varepsilon}{\\sqrt{p_i(1 - p_i)/B}} \\ge z_{\\alpha/(2m)}$$\nSolving for $B$:\n$$\\frac{B \\varepsilon^2}{p_i(1-p_i)} \\ge (z_{\\alpha/(2m)})^2$$\n$$B \\ge \\frac{p_i(1-p_i) (z_{\\alpha/(2m)})^2}{\\varepsilon^2}$$\nThe term $p_i(1-p_i)$ is the variance of a single Bernoulli trial, which depends on the unknown true support $p_i$. The problem specifies two scenarios:\na) **No pilot support**: We use the worst-case variance. The function $f(p) = p(1-p)$ is maximized at $p=0.5$, giving $p(1-p) \\le 0.5(1-0.5) = 0.25$.\nb) **Pilot support $p_0$**: We use the variance estimate $p_0(1-p_0)$.\n\nThe final formula for $B_{\\text{Norm}}$ is the ceiling of the derived expression, substituting the appropriate variance term:\n$$B_{\\text{Norm}} = \\left\\lceil \\frac{\\sigma_{p}^2 (z_{\\alpha/(2m)})^2}{\\varepsilon^2} \\right\\rceil, \\quad \\text{where} \\quad z_{\\alpha/(2m)} = \\Phi^{-1}\\left(1 - \\frac{\\alpha}{2m}\\right)$$\nand $\\sigma_{p}^2$ is either $0.25$ or $p_0(1-p_0)$.\n\n**Explanation for the Number of Aligned Sites**\n\nThe number of aligned sites, given as $1000$, does not appear in the formulas for $B_{\\text{Ineq}}$ or $B_{\\text{Norm}}$. This is because the problem is formulated at a higher level of abstraction. The analysis treats each bootstrap replicate as a single, independent Bernoulli trial that either succeeds (recovers a specific clade) or fails. The probability of success, $p_i$, is the parameter we wish to estimate.\n\nThe value of $p_i$ is indeed a function of the underlying biological data (including the number and nature of the $1000$ sites), the evolutionary model, and the tree-building algorithm. A dataset with more informative sites would likely lead to higher values of $p_i$ for the true clades. However, the task presented is not to determine $p_i$, but to determine the number of bootstrap replicates $B$ needed to estimate $p_i$ (whatever its value may be) to a given precision $\\varepsilon$ and confidence $1-\\alpha$.\n\nThe calculation of $B$ is therefore a problem in statistical sampling theory: how large must a sample be to estimate a proportion with a specified error margin and confidence? This depends only on the desired precision ($\\varepsilon$), the confidence level ($\\alpha$), the number of simultaneous estimates being made ($m$), and assumptions about the variance of the proportion (handled by the worst-case or pilot estimates). The characteristics of the original dataset that determine the value of $p_i$ are encapsulated within the parameter $p_i$ itself and are not directly part of the sample size calculation for its estimation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the minimal number of bootstrap replicates B for four test cases\n    using two different methods: a concentration inequality and a Normal approximation.\n    \"\"\"\n\n    def calculate_b(epsilon, alpha, n, pilot_p0=None):\n        \"\"\"\n        Calculates the minimal number of bootstrap replicates B.\n\n        Args:\n            epsilon (float): The maximum tolerated absolute error.\n            alpha (float): The family-wise error rate.\n            n (int): The number of taxa.\n            pilot_p0 (float, optional): Pilot support probability. Defaults to None.\n\n        Returns:\n            list[int, int]: A list containing [B_Ineq, B_Norm].\n        \"\"\"\n        # The number of internal clades for an unrooted, fully resolved tree\n        m = n - 3\n\n        # 1. Concentration Inequality Approach (Hoeffding's Inequality)\n        # B = ln(2*m/alpha) / (2 * epsilon^2)\n        b_ineq_numerator = np.log(2.0 * m / alpha)\n        b_ineq_denominator = 2.0 * epsilon**2\n        b_ineq = np.ceil(b_ineq_numerator / b_ineq_denominator)\n\n        # 2. Normal Approximation with Bonferroni Correction\n        # B = variance * (z_crit^2) / (epsilon^2)\n        \n        # Determine the variance term\n        if pilot_p0 is not None:\n            # Use variance based on pilot support p0\n            variance = pilot_p0 * (1.0 - pilot_p0)\n        else:\n            # Use worst-case variance, where p(1-p) is maximized at p=0.5\n            variance = 0.25\n\n        # Calculate the critical z-value with Bonferroni correction\n        # The probability for each tail in a two-sided test is alpha / (2 * m)\n        quantile = 1.0 - alpha / (2.0 * m)\n        z_crit = norm.ppf(quantile)\n\n        b_norm_numerator = variance * (z_crit**2)\n        b_norm_denominator = epsilon**2\n        b_norm = np.ceil(b_norm_numerator / b_norm_denominator)\n\n        return [int(b_ineq), int(b_norm)]\n\n    # Common parameter for all test cases\n    n_taxa = 50\n\n    # Define the test cases from the problem statement.\n    # Format: (epsilon, alpha, pilot_p0 or None)\n    test_cases = [\n        # Case 1: eps = 0.02, alpha = 0.05, no pilot support\n        {'epsilon': 0.02, 'alpha': 0.05, 'pilot_p0': None},\n        # Case 2: eps = 0.01, alpha = 0.05, pilot support p0 = 0.8\n        {'epsilon': 0.01, 'alpha': 0.05, 'pilot_p0': 0.8},\n        # Case 3: eps = 0.03, alpha = 0.01, no pilot support\n        {'epsilon': 0.03, 'alpha': 0.01, 'pilot_p0': None},\n        # Case 4: eps = 0.05, alpha = 0.10, pilot support p0 = 0.7\n        {'epsilon': 0.05, 'alpha': 0.10, 'pilot_p0': 0.7},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_b(case['epsilon'], case['alpha'], n_taxa, case['pilot_p0'])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [[B1_Ineq,B1_Norm],[B2_Ineq,B2_Norm],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2377053"}]}