{"hands_on_practices": [{"introduction": "The most direct method for handling long-range interactions in a finite simulation is to simply ignore them beyond a certain cutoff distance, $r_c$. While computationally appealing, this sharp truncation of the potential introduces a significant physical artifact. This exercise guides you through a simple coding-based thought experiment to discover this flaw firsthand by calculating the force between two charges as one crosses the cutoff boundary, demonstrating a non-physical jump in the force that violates energy conservation in molecular dynamics simulations [@problem_id:2457367].", "problem": "Consider two point charges interacting via the Coulomb potential under periodic boundary conditions (PBC) in one spatial dimension with box length $L$ in reduced (dimensionless) units. The charges are $q_1 = +1$ and $q_2 = +1$ placed at positions $x_1 = 0$ and $x_2$, respectively. Use the minimum image convention: define the displacement $\\Delta x = x_2 - x_1$ and then map it to the interval $[-L/2,\\,L/2)$ by replacing $\\Delta x$ with $\\Delta x' = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x/L)$, where $\\mathrm{round}(\\cdot)$ returns the nearest integer. Let $r = |\\Delta x'|$ denote the scalar separation under this convention.\n\nUse a naive spherical cutoff at separation $r_c$: the $x$-component of the force on particle $2$ due to particle $1$ is defined as\n$$\nF_x =\n\\begin{cases}\n\\dfrac{q_1 q_2 \\, \\Delta x'}{r^3}, & \\text{if } r < r_c, \\\\\n0, & \\text{if } r \\ge r_c,\n\\end{cases}\n$$\nwith all quantities dimensionless. This definition is equivalent to truncating the Coulomb force sharply at $r = r_c$ without any shifting or smoothing.\n\nYour task is to demonstrate the discontinuity of $F_x$ as $x_2$ crosses the cutoff boundary by computing, for each test case, the jump\n$$\nJ = F_x(x_a) - F_x(x_b),\n$$\nwhere $x_a$ and $x_b$ are two specified positions of particle $2$ that lie on opposite sides of the cutoff boundary (or at the boundary as explicitly given). The origin $x_1 = 0$ is fixed for all cases. Treat $r = r_c$ as belonging to the $r \\ge r_c$ branch in the definition above.\n\nAll answers are to be expressed as dimensionless real numbers.\n\nTest suite (each case is independent; use the parameters as given):\n- Case $1$: $L = 10$, $r_c = 3$, $x_a = 2.999999$, $x_b = 3.000001$.\n- Case $2$: $L = 10$, $r_c = 3$, $x_a = 7.000001$, $x_b = 6.999999$.\n- Case $3$ (boundary case): $L = 10$, $r_c = 3$, $x_a = 2.999999999$, $x_b = 3.0$.\n- Case $4$: $L = 12$, $r_c = 4$, $x_a = 3.9999$, $x_b = 4.0001$.\n\nFor each case, compute the scalar jump $J$ as defined above.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\") in the order of Cases $1$ through $4$.", "solution": "The problem statement is scientifically sound and well-posed. It presents a standard exercise in computational physics to demonstrate the pathological behavior of a truncated potential, namely the discontinuity in the force at the cutoff radius. This is a known artifact that violates energy conservation in molecular dynamics simulations, and its analysis is instructive. The problem provides all necessary parameters and definitions for a unique solution.\n\nWe are tasked with calculating the jump in the force, $J = F_x(x_a) - F_x(x_b)$, for two neighboring points $x_a$ and $x_b$ across a force cutoff boundary. The force $F_x$ on particle $2$ located at position $x_2$ due to particle $1$ at $x_1=0$ is given by a specific functional form involving the minimum image convention.\n\nThe calculation proceeds in several steps for a given position $x_2$:\n1.  Calculate the raw displacement: $\\Delta x = x_2 - x_1$. Since $x_1=0$, this simplifies to $\\Delta x = x_2$.\n2.  Apply the minimum image convention to find the shortest periodic distance. The mapped displacement $\\Delta x'$ is calculated as:\n    $$ \\Delta x' = \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L) $$\n    This operation maps $\\Delta x$ into the interval $[-L/2, L/2)$.\n3.  Calculate the scalar separation, $r$, which is the magnitude of the mapped displacement:\n    $$ r = |\\Delta x'| $$\n4.  Apply the cutoff condition to determine the force. The force $F_x$ is defined as:\n    $$\n    F_x(x_2) =\n    \\begin{cases}\n    \\dfrac{q_1 q_2 \\, \\Delta x'}{r^3}, & \\text{if } r < r_c, \\\\\n    0, & \\text{if } r \\ge r_c.\n    \\end{cases}\n    $$\n    Given $q_1=+1$ and $q_2=+1$, and noting that $r^3 = |\\Delta x'|^3$, this simplifies to $F_x = \\Delta x' / |\\Delta x'|^3$ for $r < r_c$.\n\nWe will now apply this procedure to each test case.\n\n**Case 1:** $L = 10$, $r_c = 3$, $q_1=1$, $q_2=1$.\n- For $x_2 = x_a = 2.999999$:\n  - $\\Delta x = 2.999999$.\n  - $\\Delta x / L = 0.2999999$, so $\\mathrm{round}(\\Delta x / L) = 0$.\n  - $\\Delta x' = 2.999999 - 10 \\cdot 0 = 2.999999$.\n  - $r = |\\Delta x'| = 2.999999$.\n  - Since $r < r_c$ ($2.999999 < 3$), the force is non-zero:\n    $$ F_x(x_a) = \\frac{(1)(1)(2.999999)}{(2.999999)^3} = \\frac{1}{(2.999999)^2} $$\n- For $x_2 = x_b = 3.000001$:\n  - $\\Delta x = 3.000001$.\n  - $\\Delta x / L = 0.3000001$, so $\\mathrm{round}(\\Delta x / L) = 0$.\n  - $\\Delta x' = 3.000001 - 10 \\cdot 0 = 3.000001$.\n  - $r = |\\Delta x'| = 3.000001$.\n  - Since $r > r_c$ ($3.000001 > 3$), the force is zero: $F_x(x_b) = 0$.\n- The jump is $J_1 = F_x(x_a) - F_x(x_b) = 1 / (2.999999)^2 \\approx 0.1111111975$.\n\n**Case 2:** $L = 10$, $r_c = 3$, $q_1=1$, $q_2=1$.\n- For $x_2 = x_a = 7.000001$:\n  - $\\Delta x = 7.000001$.\n  - $\\Delta x / L = 0.7000001$, so $\\mathrm{round}(\\Delta x / L) = 1$.\n  - $\\Delta x' = 7.000001 - 10 \\cdot 1 = -2.999999$.\n  - $r = |\\Delta x'| = 2.999999$.\n  - Since $r < r_c$ ($2.999999 < 3$), the force is non-zero:\n    $$ F_x(x_a) = \\frac{(1)(1)(-2.999999)}{(2.999999)^3} = -\\frac{1}{(2.999999)^2} $$\n- For $x_2 = x_b = 6.999999$:\n  - $\\Delta x = 6.999999$.\n  - $\\Delta x / L = 0.6999999$, so $\\mathrm{round}(\\Delta x / L) = 1$.\n  - $\\Delta x' = 6.999999 - 10 \\cdot 1 = -3.000001$.\n  - $r = |\\Delta x'| = 3.000001$.\n  - Since $r > r_c$ ($3.000001 > 3$), the force is zero: $F_x(x_b) = 0$.\n- The jump is $J_2 = F_x(x_a) - F_x(x_b) = -1 / (2.999999)^2 \\approx -0.1111111975$.\n\n**Case 3:** $L = 10$, $r_c = 3$, $q_1=1$, $q_2=1$.\n- For $x_2 = x_a = 2.999999999$:\n  - $\\Delta x = 2.999999999$, so $\\Delta x' = 2.999999999$ and $r = 2.999999999$.\n  - Since $r < r_c$, the force is:\n    $$ F_x(x_a) = \\frac{1}{(2.999999999)^2} $$\n- For $x_2 = x_b = 3.0$:\n  - $\\Delta x = 3.0$, so $\\Delta x' = 3.0$ and $r = 3.0$.\n  - As per the problem definition, $r = r_c$ belongs to the $r \\ge r_c$ branch. Thus, $F_x(x_b) = 0$.\n- The jump is $J_3 = F_x(x_a) - F_x(x_b) = 1 / (2.999999999)^2 \\approx 0.111111111$.\n\n**Case 4:** $L = 12$, $r_c = 4$, $q_1=1$, $q_2=1$.\n- For $x_2 = x_a = 3.9999$:\n  - $\\Delta x = 3.9999$.\n  - $\\Delta x / L = 3.9999 / 12 = 0.333325$, so $\\mathrm{round}(\\Delta x / L) = 0$.\n  - $\\Delta x' = 3.9999 - 12 \\cdot 0 = 3.9999$.\n  - $r = |\\Delta x'| = 3.9999$.\n  - Since $r < r_c$ ($3.9999 < 4$), the force is non-zero:\n    $$ F_x(x_a) = \\frac{1}{(3.9999)^2} $$\n- For $x_2 = x_b = 4.0001$:\n  - $\\Delta x = 4.0001$.\n  - $\\Delta x / L = 4.0001 / 12 \\approx 0.333341$, so $\\mathrm{round}(\\Delta x / L) = 0$.\n  - $\\Delta x' = 4.0001 - 12 \\cdot 0 = 4.0001$.\n  - $r = |\\Delta x'| = 4.0001$.\n  - Since $r > r_c$ ($4.0001 > 4$), the force is zero: $F_x(x_b) = 0$.\n- The jump is $J_4 = F_x(x_a) - F_x(x_b) = 1 / (3.9999)^2 \\approx 0.062503125$.\n\nThe magnitude of the force jump at the cutoff $r_c$ approaches the limit $\\frac{q_1 q_2}{r_c^2}$. The sign of the jump is determined by the sign of the minimum image displacement $\\Delta x'$. The final numerical answers are computed programmatically to maintain precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_force(x2, L, rc, q1, q2, x1=0.0):\n    \"\"\"\n    Computes the x-component of the force on particle 2 due to particle 1\n    according to the problem specification.\n    \"\"\"\n    # Step 1: Calculate the raw displacement.\n    delta_x = x2 - x1\n\n    # Step 2: Apply the minimum image convention.\n    # The problem specifies round(x/L), which corresponds to numpy.round().\n    delta_x_prime = delta_x - L * np.round(delta_x / L)\n\n    # Step 3: Calculate the scalar separation.\n    r = np.abs(delta_x_prime)\n\n    # Step 4: Apply the cutoff condition to determine the force.\n    # The problem states that r = rc belongs to the r >= rc branch,\n    # resulting in zero force.\n    if r >= rc:\n        force_x = 0.0\n    else:\n        # The case r=0 is not encountered in the test suite but is handled\n        # for completeness (force would be singular). Force is defined\n        # piecewise, so the else branch assumes r > 0.\n        force_x = (q1 * q2 * delta_x_prime) / (r**3)\n\n    return force_x\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite and prints the results.\n    \"\"\"\n    # Define the constants given in the problem.\n    q1 = 1.0\n    q2 = 1.0\n    x1 = 0.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'L': 10.0, 'rc': 3.0, 'xa': 2.999999, 'xb': 3.000001},      # Case 1\n        {'L': 10.0, 'rc': 3.0, 'xa': 7.000001, 'xb': 6.999999},      # Case 2\n        {'L': 10.0, 'rc': 3.0, 'xa': 2.999999999, 'xb': 3.0},       # Case 3\n        {'L': 12.0, 'rc': 4.0, 'xa': 3.9999, 'xb': 4.0001},         # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case['L']\n        rc = case['rc']\n        xa = case['xa']\n        xb = case['xb']\n\n        # Calculate the force at positions xa and xb.\n        force_a = compute_force(xa, L, rc, q1, q2, x1)\n        force_b = compute_force(xb, L, rc, q1, q2, x1)\n\n        # Calculate the jump J = F_x(xa) - F_x(xb).\n        jump = force_a - force_b\n        results.append(jump)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2457367"}, {"introduction": "Having seen the failures of simple truncation, we now turn to the Ewald summation method, a robust solution for handling long-range electrostatics in periodic systems. This practice moves from identifying a problem to applying the solution to calculate a macroscopic property: the system pressure via the Clausius virial. You will implement the core reciprocal-space component of the Ewald sum to compute forces and the virial, allowing you to explore how the choice of Ewald parameters $(\\alpha, r_{cut}, k_{cut})$ directly impacts the final calculated pressure [@problem_id:2457343].", "problem": "You are given a three-dimensional, electrically neutral system of point charges under Periodic Boundary Conditions (PBC) in a cubic simulation cell of edge length $L$ and volume $V=L^3$. Electrostatics are to be treated by the Ewald summation method with Gaussian screening parameter $\\alpha$ (real positive scalar), a real-space cutoff $r_{cut}$ (nonnegative scalar), and a reciprocal-space cutoff $k_{cut}$ (nonnegative scalar). Assume conducting (tin-foil) boundary conditions at infinity so that surface terms vanish. Work in a reduced unit system where $4\\pi \\epsilon_0=1$ and the Boltzmann constant $k_B=1$. The temperature is fixed at $T>0$.\n\nThe configurational virial $W$ is defined by the Clausius relation $W=\\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{F}_i$, where $\\mathbf{r}_i$ are the Cartesian position vectors in the simulation cell, $\\mathbf{F}_i$ are the total forces on particle $i$ arising from the electrostatic interactions computed with the specified Ewald summation parameters $(\\alpha,r_{cut},k_{cut})$, and $N$ is the number of particles. The pressure is then given by the mechanical expression\n$$\nP=\\frac{N T}{V}+\\frac{1}{3V} W,\n$$\nwith $P$ expressed in reduced units of energy per volume.\n\nConsider the following fixed system data:\n- Number of particles $N=2$.\n- Cubic box length $L=10.0$, hence volume $V=1000.0$.\n- Temperature $T=1.0$.\n- Charges $\\{q_i\\}_{i=1}^2$ with $q_1=+1.0$ and $q_2=-1.0$.\n- Positions (in the primary cell, Cartesian coordinates in the same length unit as $L$):\n  - $\\mathbf{r}_1=(2.3,3.7,1.1)$,\n  - $\\mathbf{r}_2=(7.6,9.1,8.2)$.\n\nCompute the total forces $\\mathbf{F}_i$ using the Ewald decomposition into a short-ranged real-space sum truncated at $r_{cut}$ and a reciprocal-space sum truncated to wavevectors $\\mathbf{k}$ satisfying $\\lVert \\mathbf{k} \\rVert \\le k_{cut}$. The self-interaction does not contribute to forces. The real-space sum must include all periodic images within the sphere of radius $r_{cut}$ centered at each pairwise separation; the reciprocal-space sum must include all nonzero reciprocal lattice vectors within the sphere of radius $k_{cut}$. Use the primitive reciprocal lattice of the cubic cell, i.e., reciprocal vectors $\\mathbf{k} = \\frac{2\\pi}{L}(n_x,n_y,n_z)$ for integers $n_x,n_y,n_z$, excluding $\\mathbf{k}=\\mathbf{0}$.\n\nYour task is to write a complete, runnable program that, for the fixed system above, evaluates the pressure $P$ in reduced units for the following test suite of Ewald parameter sets $(\\alpha,r_{cut},k_{cut})$:\n1. $(\\alpha,r_{cut},k_{cut})=(0.25,6.0,10.0)$,\n2. $(\\alpha,r_{cut},k_{cut})=(0.10,6.0,10.0)$,\n3. $(\\alpha,r_{cut},k_{cut})=(0.25,3.0,12.0)$,\n4. $(\\alpha,r_{cut},k_{cut})=(0.25,6.0,6.0)$.\n\nFor each parameter set, calculate $P$ from first principles based on the definitions above. Express the final pressure values as plain real numbers (floats) in reduced units.\n\nFinal output format requirement:\nYour program should produce a single line of output containing the four results, in the order of the test suite, as a comma-separated list enclosed in square brackets, e.g., \"[p1,p2,p3,p4]\". There must be no extra whitespace or text. All angles, if any, are in radians; all quantities are dimensionless or in the reduced units specified. The output must be a single line.", "solution": "The problem posed is a standard exercise in computational statistical mechanics, specifically the calculation of pressure in a periodic system via the Ewald summation method. Before proceeding to a solution, a rigorous validation is required.\n\n**Problem Validation**\n\nThe problem provides a complete and self-contained description of a physical system and a computational task.\nGivens are:\n-   System type: Three-dimensional, electrically neutral system of $N=2$ point charges ($q_1=+1.0, q_2=-1.0$) in a cubic cell.\n-   Periodic Boundary Conditions (PBC) with cell length $L=10.0$ and volume $V=L^3=1000.0$.\n-   Particle positions: $\\mathbf{r}_1=(2.3,3.7,1.1)$ and $\\mathbf{r}_2=(7.6,9.1,8.2)$.\n-   Temperature $T=1.0$ in reduced units where $k_B=1$.\n-   Electrostatics method: Ewald summation with parameters $(\\alpha, r_{cut}, k_{cut})$ and conducting boundary conditions.\n-   Reduced units: $4\\pi \\epsilon_0=1$.\n-   Pressure definition: $P=\\frac{N T}{V}+\\frac{1}{3V} W$, where $W=\\sum_{i=1}^{N} \\mathbf{r}_i \\cdot \\mathbf{F}_i$ is the configurational virial.\n-   Task: Compute $P$ for four specified parameter sets.\n\nThe problem is scientifically grounded, relying on the fundamental principles of electrostatics and statistical mechanics. The Ewald summation method is a cornerstone of molecular simulation. All terms are defined unambiguously, and all required data are provided. There are no internal contradictions, logical flaws, or pseudoscientific elements. The problem is well-posed and objective.\n\nVerdict: The problem is valid. We proceed with the solution.\n\n**Theoretical Formulation**\n\nThe total force $\\mathbf{F}_i$ on a particle $i$ is decomposed into a real-space contribution $\\mathbf{F}_{i, \\text{real}}$ and a reciprocal-space contribution $\\mathbf{F}_{i, \\text{recip}}$. The total configurational virial is likewise decomposed: $W = W_{\\text{real}} + W_{\\text{recip}}$.\n\n1.  **Real-Space Contribution**\n\nThe real-space force on particle $i$ is calculated by summing over the interactions with all other particles $j$ and their periodic images $\\mathbf{n}$ within a cutoff radius $r_{cut}$. The force exerted on particle $i$ by particle $j$ at a separation vector $\\mathbf{r}'$ is given by:\n$$\n\\mathbf{F}(\\mathbf{r}') = -q_i q_j \\nabla_{\\mathbf{r}'} \\frac{\\text{erfc}(\\alpha r')}{r'} = q_i q_j \\left[ \\frac{2\\alpha}{\\sqrt{\\pi}} \\frac{e^{-\\alpha^2 r'^2}}{r'} + \\frac{\\text{erfc}(\\alpha r')}{r'^2} \\right] \\frac{\\mathbf{r}'}{r'}\n$$\nwhere $r' = |\\mathbf{r}'|$. The total real-space force on particle $i$ is the sum over all $j \\neq i$ and all lattice vectors $\\mathbf{n}=(n_x L, n_y L, n_z L)$ such that the distance vector $\\mathbf{r}_{ij\\mathbf{n}} = \\mathbf{r}_i - (\\mathbf{r}_j + \\mathbf{n}L)$ satisfies $|\\mathbf{r}_{ij\\mathbf{n}}| \\le r_{cut}$.\n\nFor the given system with only two particles, we only need to consider the separation between particle $1$ and particle $2$. The separation vector in the primary cell is $\\mathbf{r}_{12} = \\mathbf{r}_1 - \\mathbf{r}_2 = (2.3-7.6, 3.7-9.1, 1.1-8.2) = (-5.3, -5.4, -7.1)$. The set of all relevant separation vectors is $\\mathbf{r}_{12,\\mathbf{n}} = \\mathbf{r}_{12} - \\mathbf{n}L$. We must find the minimum distance between any image of particle $1$ and particle $2$. This corresponds to the minimum value of $|\\mathbf{r}_{12,\\mathbf{n}}|$ over all integer vectors $\\mathbf{n}=(n_x, n_y, n_z)$. This is achieved using the minimum image convention. The minimum image separation vector is:\n$$\n\\mathbf{r}_{12, \\text{mic}} = \\mathbf{r}_{12} - L \\cdot \\text{round}(\\mathbf{r}_{12} / L)\n$$\nWith $L=10.0$, we have $\\mathbf{r}_{12}/L = (-0.53, -0.54, -0.71)$. Rounding to the nearest integer gives the vector $(-1, -1, -1)$.\nThus, $\\mathbf{r}_{12, \\text{mic}} = (-5.3, -5.4, -7.1) - 10.0(-1, -1, -1) = (4.7, 4.6, 2.9)$.\nThe minimum distance is $r_{\\text{min}} = |\\mathbf{r}_{12, \\text{mic}}| = \\sqrt{4.7^2 + 4.6^2 + 2.9^2} = \\sqrt{22.09 + 21.16 + 8.41} = \\sqrt{51.66} \\approx 7.187$.\n\nThe test suite specifies real-space cutoffs $r_{cut} = 6.0$ and $r_{cut} = 3.0$. Since the smallest distance between any image of particle $1$ and any image of particle $2$ is $r_{\\text{min}} \\approx 7.187$, and all specified $r_{cut}$ values are smaller than this minimum distance, there are no pairs of particles (including images) within the real-space cutoff.\nConsequently, for all four test cases, the real-space sum is empty.\n$$\n\\mathbf{F}_{i, \\text{real}} = \\mathbf{0} \\quad \\text{and} \\quad W_{\\text{real}} = 0\n$$\n\n2.  **Reciprocal-Space Contribution**\n\nThe calculation thus reduces to the reciprocal-space contribution. The force on particle $i$ is derived from the reciprocal-space energy $U_{\\text{recip}}$:\n$$\nU_{\\text{recip}} = \\frac{2\\pi}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} |S(\\mathbf{k})|^2\n$$\nwhere $\\mathbf{k} = \\frac{2\\pi}{L}(n_x,n_y,n_z)$ are the reciprocal lattice vectors for integers $(n_x, n_y, n_z)$, and $S(\\mathbf{k}) = \\sum_{j=1}^N q_j e^{i\\mathbf{k}\\cdot\\mathbf{r}_j}$ is the structure factor.\nThe gradient of the squared structure factor is $\\nabla_{\\mathbf{r}_i} |S(\\mathbf{k})|^2 = -2 q_i \\mathbf{k} \\sum_j q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij})$, where $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$.\nThis gives the force on particle $i$:\n$$\n\\mathbf{F}_{i, \\text{recip}} = \\frac{4\\pi q_i}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\sum_{j=1}^N q_j \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{ij})\n$$\nThe total force on particle $i$ is $\\mathbf{F}_i = \\mathbf{F}_{i, \\text{recip}}$. The total virial is $W = W_{\\text{recip}} = \\sum_{i=1}^N \\mathbf{r}_i \\cdot \\mathbf{F}_{i, \\text{recip}}$.\nFor a two-particle system $(i,j \\in \\{1,2\\})$, this simplifies. The virial is $W = \\mathbf{r}_1 \\cdot \\mathbf{F}_1 + \\mathbf{r}_2 \\cdot \\mathbf{F}_2$. Since $\\mathbf{F}_2 = -\\mathbf{F}_1$ by Newton's third law, $W = (\\mathbf{r}_1 - \\mathbf{r}_2) \\cdot \\mathbf{F}_1 = \\mathbf{r}_{12} \\cdot \\mathbf{F}_1$.\nThe force on particle $1$ is:\n$$\n\\mathbf{F}_1 = \\frac{4\\pi q_1}{V} \\sum_{\\mathbf{k}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\left( q_1 \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{11}) + q_2 \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12}) \\right) = \\frac{4\\pi q_1 q_2}{V} \\sum_{\\mathbf{k}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} \\mathbf{k} \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12})\n$$\nThe virial is therefore:\n$$\nW = \\frac{4\\pi q_1 q_2}{V} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} (\\mathbf{k} \\cdot \\mathbf{r}_{12}) \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12})\n$$\n\n3.  **Final Pressure Calculation**\n\nThe total pressure is computed using the provided formula with $W=W_{\\text{recip}}$:\n$$\nP = \\frac{NT}{V} + \\frac{W}{3V} = \\frac{NT}{V} + \\frac{4\\pi q_1 q_2}{3V^2} \\sum_{\\mathbf{k} \\ne \\mathbf{0}, |\\mathbf{k}|\\le k_{cut}} \\frac{e^{-k^2/(4\\alpha^2)}}{k^2} (\\mathbf{k} \\cdot \\mathbf{r}_{12}) \\sin(\\mathbf{k} \\cdot \\mathbf{r}_{12})\n$$\nThe computational procedure involves iterating through all integer vectors $(n_x, n_y, n_z)$ within a range determined by $k_{cut}$, constructing the corresponding $\\mathbf{k}$ vectors, and accumulating the sum for the virial. The range for each integer component $n_i$ is bounded by $|n_i| \\le \\lfloor k_{cut} L / (2\\pi) \\rfloor$. A further spherical check, $k^2 \\le k_{cut}^2$, is applied inside the loop.", "answer": "```python\nimport numpy as np\n# The problem statement allows for scipy, but it is not strictly needed for the final algorithm.\n# from scipy.special import erfc could be used if the real-space term were non-zero.\n\ndef solve():\n    \"\"\"\n    Computes the pressure of a two-particle system with periodic boundary\n    conditions using the Ewald summation method for specified parameters.\n    \"\"\"\n    # Fixed system parameters in reduced units\n    N = 2.0\n    L = 10.0\n    V = L**3\n    T = 1.0\n\n    # Particle data\n    q1 = 1.0\n    q2 = -1.0\n    r1 = np.array([2.3, 3.7, 1.1])\n    r2 = np.array([7.6, 9.1, 8.2])\n    \n    # Separation vector in the primary cell\n    r12 = r1 - r2\n\n    # Test suite of Ewald parameters (alpha, r_cut, k_cut)\n    test_cases = [\n        (0.25, 6.0, 10.0),\n        (0.10, 6.0, 10.0),\n        (0.25, 3.0, 12.0),\n        (0.25, 6.0, 6.0),\n    ]\n\n    results = []\n    \n    for alpha, r_cut, k_cut in test_cases:\n        # --- Real-space contribution ---\n        # The minimum distance between any image of particle 1 and 2 is calculated\n        # via the minimum image convention:\n        # r12_mic = r12 - L * np.round(r12 / L)\n        # r12_mic = [-5.3, -5.4, -7.1] - 10.0 * [-1., -1., -1.] = [4.7, 4.6, 2.9]\n        # min_dist = np.linalg.norm(r12_mic) = sqrt(51.66) approx 7.187\n        # Since r_cut for all test cases (6.0, 3.0) is less than min_dist,\n        # the real-space sum is empty. The real-space force and virial are zero.\n        W_real = 0.0\n\n        # --- Reciprocal-space contribution ---\n        W_recip = 0.0\n        k_cut_sq = k_cut**2\n        k_sq_factor = (2.0 * np.pi / L)**2\n\n        # Determine the search space for reciprocal lattice vectors n\n        n_max = int(np.floor(k_cut * L / (2.0 * np.pi)))\n        \n        for nx in range(-n_max, n_max + 1):\n            for ny in range(-n_max, n_max + 1):\n                for nz in range(-n_max, n_max + 1):\n                    if nx == 0 and ny == 0 and nz == 0:\n                        continue\n\n                    n_vec = np.array([float(nx), float(ny), float(nz)])\n                    n_sq = np.dot(n_vec, n_vec)\n                    k_sq = k_sq_factor * n_sq\n\n                    if k_sq > k_cut_sq:\n                        continue\n\n                    k_vec = (2.0 * np.pi / L) * n_vec\n                    \n                    k_dot_r12 = np.dot(k_vec, r12)\n                    \n                    term = (np.exp(-k_sq / (4.0 * alpha**2)) / k_sq) * k_dot_r12 * np.sin(k_dot_r12)\n                    W_recip += term\n\n        W_recip *= 4.0 * np.pi * q1 * q2 / V\n        \n        # --- Total virial and pressure ---\n        W = W_real + W_recip\n        P = (N * T / V) + W / (3.0 * V)\n        results.append(P)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{p:.10f}' for p in results)}]\")\n\nsolve()\n```", "id": "2457343"}, {"introduction": "The most common and efficient implementation of the Ewald method is the Particle-Mesh Ewald (PME) algorithm, which uses the Fast Fourier Transform (FFT) on a grid. A crucial step in PME is assigning the continuous particle charges to this discrete grid, a process that introduces a controllable approximation. This final practice takes you 'under the hood' of PME to quantify the accuracy of different charge assignment schemes, comparing the simple Nearest-Grid-Point (NGP) method to the more accurate linear interpolation (CIC) scheme [@problem_id:2457387].", "problem": "Consider a three-dimensional cubic periodic cell of edge length $L = 1$ and volume $V = L^3 = 1$. A system of point charges $\\{q_j\\}_{j=1}^N$ at positions $\\{\\mathbf{r}_j\\}_{j=1}^N$ with overall charge neutrality $\\sum_{j=1}^N q_j = 0$ is given. Define the Ewald parameter $\\alpha > 0$. For a reciprocal lattice vector $\\mathbf{k} = 2\\pi \\left(m_x, m_y, m_z\\right)$ with integers $m_x, m_y, m_z \\in \\mathbb{Z}$ and $\\mathbf{k} \\neq \\mathbf{0}$, the reciprocal-space Ewald energy component is\n$$\nU_k = \\frac{2\\pi}{V} \\sum_{\\mathbf{k} \\neq \\mathbf{0}} \\frac{e^{-|\\mathbf{k}|^2/(4\\alpha^2)}}{|\\mathbf{k}|^2} \\left| S(\\mathbf{k}) \\right|^2,\n$$\nwhere the structure factor is\n$$\nS(\\mathbf{k}) = \\sum_{j=1}^N q_j \\, e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}.\n$$\nIn the Particle-Mesh Ewald (PME) approach, the structure factor on a regular mesh of size $M \\times M \\times M$ with spacing $h = L/M$ is approximated by assigning charges to mesh points and then deconvolving a window function in reciprocal space. Consider two assignment schemes:\n\n- Nearest-Grid-Point (NGP), also known as zero-order interpolation.\n- Linear interpolation, also known as Cloud-In-Cell (CIC), which is first-order.\n\nFor a one-dimensional wavenumber component $k_d$ with $d \\in \\{x,y,z\\}$, define the one-dimensional window amplitude\n$$\nW_1(k_d) = \\mathrm{sinc}\\left(\\frac{k_d h}{2}\\right)^p,\n$$\nwhere $p = 1$ for NGP and $p = 2$ for CIC, and $\\mathrm{sinc}(x) = \\frac{\\sin x}{x}$ with the convention $\\mathrm{sinc}(0) = 1$. The three-dimensional window amplitude is\n$$\nW(\\mathbf{k}) = W_1(k_x) \\, W_1(k_y) \\, W_1(k_z).\n$$\nLet $\\rho(\\mathbf{r}_g)$ denote the mesh of assigned charges at grid points $\\mathbf{r}_g$, and let $\\rho(\\mathbf{k})$ be its discrete Fourier transform evaluated at the mesh-supported $\\mathbf{k}$ values. The PME approximation to the structure factor on the reciprocal mesh is defined by deconvolution as\n$$\nS_{\\mathrm{PME}}(\\mathbf{k}) = \\frac{\\rho(\\mathbf{k})}{W(\\mathbf{k})},\n$$\nfor those $\\mathbf{k}$ where $W(\\mathbf{k}) \\neq 0$. For modes where $W(\\mathbf{k}) = 0$, omit those modes from all reciprocal-space sums. Define the PME reciprocal-space energy on the mesh by\n$$\nU_k^{\\mathrm{PME}} = \\frac{2\\pi}{V} \\sum_{\\substack{\\mathbf{k} \\neq \\mathbf{0} \\\\ W(\\mathbf{k}) \\neq 0}} \\frac{e^{-|\\mathbf{k}|^2/(4\\alpha^2)}}{|\\mathbf{k}|^2} \\left| S_{\\mathrm{PME}}(\\mathbf{k}) \\right|^2.\n$$\nDefine the mesh-restricted reference energy by evaluating the exact structure factor $S(\\mathbf{k})$ at the same set of mesh $\\mathbf{k}$ vectors and omitting the same modes:\n$$\nU_k^{\\mathrm{ref}} = \\frac{2\\pi}{V} \\sum_{\\substack{\\mathbf{k} \\neq \\mathbf{0} \\\\ W(\\mathbf{k}) \\neq 0}} \\frac{e^{-|\\mathbf{k}|^2/(4\\alpha^2)}}{|\\mathbf{k}|^2} \\left| S(\\mathbf{k}) \\right|^2.\n$$\nFor a given configuration, grid size $M$, and assignment scheme, define the relative error\n$$\n\\varepsilon = \\frac{\\left| U_k^{\\mathrm{PME}} - U_k^{\\mathrm{ref}} \\right|}{\\left| U_k^{\\mathrm{ref}} \\right|}.\n$$\n\nYour task is to write a program that, for each test case below, computes the relative error $\\varepsilon$ as a floating-point number.\n\nAll computations must use the reciprocal vectors supported by the chosen mesh, i.e., $\\mathbf{k} = 2\\pi \\left(m_x, m_y, m_z\\right)$ with $m_x, m_y, m_z \\in \\{-\\lfloor M/2 \\rfloor, \\ldots, \\lfloor (M-1)/2 \\rfloor\\}$ as given by the standard discrete Fourier transform frequencies on a domain of length $L = 1$. Omit the $\\mathbf{k} = \\mathbf{0}$ mode and any modes with $W(\\mathbf{k}) = 0$ from both $U_k^{\\mathrm{PME}}$ and $U_k^{\\mathrm{ref}}$. Use $\\alpha = 3.5$.\n\nTest suite (each test case is independent):\n\n- Test $1$: $M = 16$, assignment scheme NGP ($p = 1$), charges $[+1, -1]$, positions $\\big[(0.15, 0.20, 0.30), (0.65, 0.70, 0.85)\\big]$.\n- Test $2$: $M = 16$, assignment scheme CIC ($p = 2$), charges $[+1, -1]$, positions $\\big[(0.15, 0.20, 0.30), (0.65, 0.70, 0.85)\\big]$.\n- Test $3$: $M = 8$, assignment scheme NGP ($p = 1$), charges $[+1, -1]$, positions $\\big[(0.01, 0.99, 0.50), (0.49, 0.02, 0.25)\\big]$.\n- Test $4$: $M = 8$, assignment scheme CIC ($p = 2$), charges $[+1, -1]$, positions $\\big[(0.01, 0.99, 0.50), (0.49, 0.02, 0.25)\\big]$.\n- Test $5$: $M = 32$, assignment scheme NGP ($p = 1$), charges $[+1, -1, +1, -1]$, positions $\\big[(0.25, 0.25, 0.25), (0.30, 0.25, 0.25), (0.75, 0.75, 0.75), (0.80, 0.75, 0.75)\\big]$.\n- Test $6$: $M = 32$, assignment scheme CIC ($p = 2$), charges $[+1, -1, +1, -1]$, positions $\\big[(0.25, 0.25, 0.25), (0.30, 0.25, 0.25), (0.75, 0.75, 0.75), (0.80, 0.75, 0.75)\\big]$.\n\nAngle units are not involved. There are no physical units; all quantities are nondimensionalized by $L = 1$.\n\nYour program should produce a single line of output containing the six relative errors, in order from Test $1$ through Test $6$, formatted as a comma-separated list enclosed in square brackets, with each floating-point number written in scientific notation with exactly eight significant digits (for example, `[1.23400000e-03,5.67890000e-04,...]`).", "solution": "The problem requires the computation of the relative error in the reciprocal-space energy calculated using the Particle-Mesh Ewald (PME) method compared to a reference energy. This analysis must be performed for several test cases involving different system configurations, grid sizes, and charge assignment schemes. The problem is well-posed and scientifically sound, providing a complete description of the PME algorithm's reciprocal-space component.\n\nThe core task is to evaluate the quantities $U_k^{\\mathrm{PME}}$ and $U_k^{\\mathrm{ref}}$ and from them, the relative error $\\varepsilon$. The calculation proceeds in several distinct steps.\n\nFirst, we establish the computational environment. The system is a cubic cell of side length $L=1$, so the volume is $V=1$. The reciprocal lattice vectors are determined by the grid size $M$. For a discrete Fourier transform on a grid of size $M$, the corresponding integer wavevectors in each dimension are $m_d \\in \\{0, 1, \\dots, M-1\\}$. These are conventionally mapped to the range $\\{-\\lfloor M/2 \\rfloor, \\dots, \\lfloor (M-1)/2 \\rfloor\\}$ to represent both positive and negative frequencies. The reciprocal vectors are then given by $\\mathbf{k} = 2\\pi (m_x, m_y, m_z)/L = 2\\pi (m_x, m_y, m_z)$. These vectors will be generated for a $M \\times M \\times M$ grid.\n\nThe reference energy, $U_k^{\\mathrm{ref}}$, is calculated using the exact structure factor, $S(\\mathbf{k})$, evaluated on this discrete set of reciprocal vectors. The structure factor for a collection of $N$ point charges $\\{q_j\\}$ at positions $\\{\\mathbf{r}_j\\}$ is defined as:\n$$\nS(\\mathbf{k}) = \\sum_{j=1}^N q_j \\, e^{-i \\mathbf{k} \\cdot \\mathbf{r}_j}\n$$\nwhere $i$ is the imaginary unit. This complex quantity is computed for each $\\mathbf{k}$ vector on our grid. The reference energy is then the sum over the allowed reciprocal vectors:\n$$\nU_k^{\\mathrm{ref}} = \\frac{2\\pi}{V} \\sum_{\\substack{\\mathbf{k} \\neq \\mathbf{0} \\\\ W(\\mathbf{k}) \\neq 0}} \\frac{e^{-|\\mathbf{k}|^2/(4\\alpha^2)}}{|\\mathbf{k}|^2} \\left| S(\\mathbf{k}) \\right|^2\n$$\nThe sum excludes the $\\mathbf{k}=\\mathbf{0}$ mode, which is handled by the overall charge neutrality condition $\\sum_j q_j=0$, and any modes where the PME window function $W(\\mathbf{k})$ is zero. The Ewald parameter is given as $\\alpha=3.5$.\n\nThe PME approximate energy, $U_k^{\\mathrm{PME}}$, is calculated through a multi-step process that replaces the direct summation for $S(\\mathbf{k})$ with a more efficient grid-based calculation.\n1.  **Charge Assignment**: The continuous particle charges are assigned to a discrete $M \\times M \\times M$ real-space grid, creating a gridded charge density $\\rho(\\mathbf{r}_g)$. The particle positions $\\mathbf{r}_j$, given in fractional coordinates, are scaled by $M$ to get grid coordinates $\\mathbf{u}_j = M\\mathbf{r}_j$.\n    -   For the Nearest-Grid-Point (NGP) scheme ($p=1$), the entire charge $q_j$ is assigned to the single closest grid point. The index of this grid point $(n_x, n_y, n_z)$ is found by rounding the grid coordinates, i.e., $n_d = \\mathrm{round}(u_{jd})$, with indices taken modulo $M$.\n    -   For the Cloud-In-Cell (CIC) or linear interpolation scheme ($p=2$), the charge $q_j$ is distributed among the $8$ grid points forming the cell that contains the particle. This is a trilinear interpolation. If the particle's grid coordinates are $\\mathbf{u}_j$, we find the base integer index $\\mathbf{n}_{\\mathrm{base}} = \\lfloor \\mathbf{u}_j \\rfloor$ and the fractional displacement $\\mathbf{\\delta} = \\mathbf{u}_j - \\mathbf{n}_{\\mathrm{base}}$. The charge is distributed to the $8$ corners of the grid cell at $(\\mathbf{n}_{\\mathrm{base}, d} + i_d) \\pmod M$ for $i_d \\in \\{0, 1\\}$, with weights proportional to $(1-\\delta_d)$ for $i_d=0$ and $\\delta_d$ for $i_d=1$. For example, the charge apportioned to grid point $\\mathbf{n}_{\\mathrm{base}}$ is $q_j(1-\\delta_x)(1-\\delta_y)(1-\\delta_z)$.\n\n2.  **Fourier Transform**: The DFT of the charge grid, $\\rho(\\mathbf{r}_g)$, is computed using a 3D Fast Fourier Transform (FFT) algorithm. This yields the discrete Fourier coefficients $\\rho(\\mathbf{k})$ for each reciprocal vector $\\mathbf{k}$ on the grid.\n    $$\n    \\rho(\\mathbf{k}) = \\sum_{\\mathbf{r}_g} \\rho(\\mathbf{r}_g) e^{-i \\mathbf{k} \\cdot \\mathbf{r}_g}\n    $$\n\n3.  **Deconvolution**: The charge assignment process acts as a convolution in real space, which corresponds to a multiplication by a window function in reciprocal space. To obtain the PME approximation of the structure factor, $S_{\\mathrm{PME}}(\\mathbf{k})$, we must divide $\\rho(\\mathbf{k})$ by this window function, $W(\\mathbf{k})$.\n    $$\n    S_{\\mathrm{PME}}(\\mathbf{k}) = \\frac{\\rho(\\mathbf{k})}{W(\\mathbf{k})}\n    $$\n    The 3D window function $W(\\mathbf{k})$ is the product of 1D window functions: $W(\\mathbf{k}) = W_1(k_x) W_1(k_y) W_1(k_z)$. The 1D function is given as $W_1(k_d) = \\mathrm{sinc}(\\frac{k_d h}{2})^p$, where $h=L/M=1/M$, and the exponent $p$ is the order of the scheme ($1$ for NGP, $2$ for CIC). The argument of the sinc function simplifies to $\\frac{\\pi m_d}{M}$. With the problem's definition $\\mathrm{sinc}(x) = \\sin(x)/x$, and noting that `numpy.sinc(x)` computes $\\sin(\\pi x)/(\\pi x)$, we can express the 1D window as $\\big( \\mathrm{numpy.sinc}(m_d/M) \\big)^p$.\n\n4.  **Energy Summation**: Finally, the PME reciprocal energy is computed by summing over the same set of valid $\\mathbf{k}$ vectors:\n    $$\n    U_k^{\\mathrm{PME}} = \\frac{2\\pi}{V} \\sum_{\\substack{\\mathbf{k} \\neq \\mathbf{0} \\\\ W(\\mathbf{k}) \\neq 0}} \\frac{e^{-|\\mathbf{k}|^2/(4\\alpha^2)}}{|\\mathbf{k}|^2} \\left| S_{\\mathrm{PME}}(\\mathbf{k}) \\right|^2\n    $$\n\nAfter computing both $U_k^{\\mathrm{ref}}$ and $U_k^{\\mathrm{PME}}$, the relative error $\\varepsilon$ is calculated as specified:\n$$\n\\varepsilon = \\frac{\\left| U_k^{\\mathrm{PME}} - U_k^{\\mathrm{ref}} \\right|}{\\left| U_k^{\\mathrm{ref}} \\right|}\n$$\nThe implementation will use `numpy` for efficient array manipulation and FFT calculations. The generation of reciprocal vectors and their corresponding integer indices $m_d$ will align with the output of `numpy.fft.fftn` and `numpy.fft.fftfreq` to ensure consistency between all grid-based quantities. For each test case, this entire procedure is executed to find the corresponding relative error.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error of the PME reciprocal energy for a series of test cases.\n    \"\"\"\n\n    def calculate_relative_error(M, p, particles, alpha, L=1.0):\n        \"\"\"\n        Calculates the relative error for a single test case.\n\n        Args:\n            M (int): Grid size in each dimension.\n            p (int): Order of the assignment scheme (1 for NGP, 2 for CIC).\n            particles (list): List of tuples (charge, [x, y, z]).\n            alpha (float): Ewald parameter.\n            L (float): Box length.\n        \"\"\"\n        V = L**3\n        h = L / M\n        charges = np.array([part[0] for part in particles])\n        positions = np.array([part[1] for part in particles])\n\n        # 1. Create reciprocal space grid\n        m_vals_1d = np.fft.fftfreq(M) * M\n        mx, my, mz = np.meshgrid(m_vals_1d, m_vals_1d, m_vals_1d, indexing='ij')\n\n        kx = 2 * np.pi * mx / L\n        ky = 2 * np.pi * my / L\n        kz = 2 * np.pi * mz / L\n        k_squared = kx**2 + ky**2 + kz**2\n\n        # 2. Calculate reference energy U_k^ref\n        # 2a. Calculate exact structure factor S(k)\n        S_k = np.zeros((M, M, M), dtype=np.complex128)\n        for i in range(len(charges)):\n            qj = charges[i]\n            rj = positions[i]\n            S_k += qj * np.exp(-1j * (kx * rj[0] + ky * rj[1] + kz * rj[2]))\n\n        # 2b. Identify valid k-modes to sum over.\n        # W(k) is never zero for k != 0 for the given schemes,\n        # but the check is included for correctness. np.sinc(m/M) is zero\n        # only if m/M is a non-zero integer, which is not possible for\n        # DFT frequencies m in [-M/2, M/2-1].\n        k_is_zero = (k_squared == 0)\n        \n        # Calculate W(k) to determine if it's zero anywhere\n        w1x = np.sinc(mx / M)**p\n        w1y = np.sinc(my / M)**p\n        w1z = np.sinc(mz / M)**p\n        W_k = w1x * w1y * w1z\n        \n        W_is_zero = np.isclose(W_k, 0)\n        invalid_mask = k_is_zero | W_is_zero\n\n        # 2c. Sum for U_k^ref\n        energy_kernel = np.zeros_like(k_squared)\n        valid_k = ~k_is_zero\n        energy_kernel[valid_k] = (2 * np.pi / V) * \\\n            np.exp(-k_squared[valid_k] / (4 * alpha**2)) / k_squared[valid_k]\n\n        U_ref = np.sum(energy_kernel[~invalid_mask] * np.abs(S_k[~invalid_mask])**2)\n\n        # 3. Calculate PME energy U_k^PME\n        # 3a. Assign charges to grid\n        rho_grid = np.zeros((M, M, M), dtype=np.float64)\n        if p == 1:  # NGP\n            for i in range(len(charges)):\n                qj = charges[i]\n                u = positions[i] * M / L\n                grid_idx = np.rint(u).astype(int) % M\n                rho_grid[grid_idx[0], grid_idx[1], grid_idx[2]] += qj\n        elif p == 2:  # CIC\n            for i in range(len(charges)):\n                qj = charges[i]\n                u = positions[i] * M / L\n                base_idx = np.floor(u).astype(int)\n                delta = u - base_idx\n                for i_x in range(2):\n                    for i_y in range(2):\n                        for i_z in range(2):\n                            weight = (delta[0] if i_x == 1 else 1 - delta[0]) * \\\n                                     (delta[1] if i_y == 1 else 1 - delta[1]) * \\\n                                     (delta[2] if i_z == 1 else 1 - delta[2])\n                            idx_x = (base_idx[0] + i_x) % M\n                            idx_y = (base_idx[1] + i_y) % M\n                            idx_z = (base_idx[2] + i_z) % M\n                            rho_grid[idx_x, idx_y, idx_z] += qj * weight\n        \n        # 3b. FFT the charge grid\n        rho_k = np.fft.fftn(rho_grid)\n\n        # 3c. Deconvolve to get S_PME(k)\n        S_pme_k = np.zeros_like(rho_k)\n        valid_W = ~W_is_zero\n        S_pme_k[valid_W] = rho_k[valid_W] / W_k[valid_W]\n\n        # 3d. Sum for U_k^PME\n        U_pme = np.sum(energy_kernel[~invalid_mask] * np.abs(S_pme_k[~invalid_mask])**2)\n        \n        # 4. Calculate relative error\n        if np.abs(U_ref) == 0:\n            return 0.0 if np.abs(U_pme) == 0 else np.inf\n        \n        relative_error = np.abs(U_pme - U_ref) / np.abs(U_ref)\n        return relative_error\n\n    # Define test cases from the problem statement\n    test_cases = [\n        # M, p, particles\n        (16, 1, [(+1.0, [0.15, 0.20, 0.30]), (-1.0, [0.65, 0.70, 0.85])]),\n        (16, 2, [(+1.0, [0.15, 0.20, 0.30]), (-1.0, [0.65, 0.70, 0.85])]),\n        (8,  1, [(+1.0, [0.01, 0.99, 0.50]), (-1.0, [0.49, 0.02, 0.25])]),\n        (8,  2, [(+1.0, [0.01, 0.99, 0.50]), (-1.0, [0.49, 0.02, 0.25])]),\n        (32, 1, [(+1.0, [0.25, 0.25, 0.25]), (-1.0, [0.30, 0.25, 0.25]),\n                 (+1.0, [0.75, 0.75, 0.75]), (-1.0, [0.80, 0.75, 0.75])]),\n        (32, 2, [(+1.0, [0.25, 0.25, 0.25]), (-1.0, [0.30, 0.25, 0.25]),\n                 (+1.0, [0.75, 0.75, 0.75]), (-1.0, [0.80, 0.75, 0.75])])\n    ]\n    \n    alpha = 3.5\n    results = []\n    \n    for M, p, particles in test_cases:\n        error = calculate_relative_error(M, p, particles, alpha)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.7e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2457387"}]}