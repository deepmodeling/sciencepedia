{"hands_on_practices": [{"introduction": "Verlet integrators are celebrated for their stability in simulating oscillatory systems, but how do they perform when the underlying physics is inherently unstable? This practice explores the numerical stability of the basic Verlet algorithm when applied to an inverted harmonic potential, a classic example of an unstable system. By deriving the per-step amplification factor, you will gain a quantitative understanding of how the integrator's behavior is linked to both the physical potential and the chosen time step, $\\Delta t$ [@problem_id:2466811].", "problem": "A single particle of mass $m$ moves in one spatial dimension under the inverted harmonic potential $V(x) = -\\frac{1}{2} k x^{2}$ with $k>0$. The motion is integrated using the basic position-Verlet algorithm with constant time step $\\Delta t>0$, defined by the update rule\n$$\nx_{n+1} \\;=\\; 2\\,x_{n} \\;-\\; x_{n-1} \\;+\\; (\\Delta t)^{2}\\,a(x_{n}),\n$$\nwhere $a(x) = -\\frac{1}{m}\\,\\frac{dV}{dx}(x)$ is the acceleration. Let $\\omega = \\sqrt{\\frac{k}{m}}$.\n\nDetermine, in closed form, the dominant per-step amplification factor $\\lambda_{\\max}(\\Delta t)$ of this discrete update (that is, the larger root in magnitude of the characteristic equation associated with the linear recurrence for $x_{n}$), expressed explicitly as a function of $\\omega$ and $\\Delta t$. Provide your final answer as a single simplified analytic expression with no units and do not perform any numerical rounding.", "solution": "The problem statement has been validated and is deemed sound, well-posed, and complete. A solution will now be derived.\n\nThe particle's motion is governed by the potential $V(x) = -\\frac{1}{2} k x^{2}$. The force on the particle is given by $F(x) = -\\frac{dV}{dx}$.\n$$\nF(x) = -\\frac{d}{dx}\\left(-\\frac{1}{2} k x^{2}\\right) = kx\n$$\nAccording to Newton's second law, the acceleration $a(x)$ is $a(x) = \\frac{F(x)}{m}$, where $m$ is the mass of the particle.\n$$\na(x) = \\frac{kx}{m}\n$$\nThe problem defines $\\omega = \\sqrt{\\frac{k}{m}}$, which implies $\\omega^{2} = \\frac{k}{m}$. We can therefore express the acceleration as:\n$$\na(x) = \\omega^{2} x\n$$\nThe position-Verlet algorithm provides a discrete-time update rule for the position $x_{n}$ at time step $n$:\n$$\nx_{n+1} = 2x_{n} - x_{n-1} + (\\Delta t)^{2} a(x_{n})\n$$\nSubstituting the expression for acceleration $a(x_{n}) = \\omega^{2} x_{n}$ into the update rule gives:\n$$\nx_{n+1} = 2x_{n} - x_{n-1} + (\\Delta t)^{2} (\\omega^{2} x_{n})\n$$\nWe can rearrange this equation into the form of a homogeneous linear recurrence relation with constant coefficients:\n$$\nx_{n+1} - (2 + (\\omega \\Delta t)^{2}) x_{n} + x_{n-1} = 0\n$$\nTo find the amplification factors, we seek solutions of the form $x_{n} = \\lambda^{n}$. Substituting this ansatz into the recurrence relation yields:\n$$\n\\lambda^{n+1} - (2 + (\\omega \\Delta t)^{2}) \\lambda^{n} + \\lambda^{n-1} = 0\n$$\nFor non-trivial solutions ($\\lambda \\neq 0$), we can divide the entire equation by $\\lambda^{n-1}$ to obtain the characteristic equation, which is a quadratic equation in $\\lambda$:\n$$\n\\lambda^{2} - (2 + (\\omega \\Delta t)^{2}) \\lambda + 1 = 0\n$$\nThe roots of this quadratic equation are the amplification factors. We solve for $\\lambda$ using the quadratic formula, $\\lambda = \\frac{-b \\pm \\sqrt{b^{2} - 4ac}}{2a}$, with coefficients $a=1$, $b = -(2 + (\\omega \\Delta t)^{2})$, and $c=1$.\n$$\n\\lambda = \\frac{(2 + (\\omega \\Delta t)^{2}) \\pm \\sqrt{(-(2 + (\\omega \\Delta t)^{2}))^{2} - 4(1)(1)}}{2(1)}\n$$\n$$\n\\lambda = \\frac{2 + (\\omega \\Delta t)^{2} \\pm \\sqrt{(2 + (\\omega \\Delta t)^{2})^{2} - 4}}{2}\n$$\nLet us simplify the discriminant (the term under the square root):\n$$\n(2 + (\\omega \\Delta t)^{2})^{2} - 4 = (4 + 4(\\omega \\Delta t)^{2} + (\\omega \\Delta t)^{4}) - 4 = 4(\\omega \\Delta t)^{2} + (\\omega \\Delta t)^{4} = (\\omega \\Delta t)^{2} (4 + (\\omega \\Delta t)^{2})\n$$\nTaking the square root of the discriminant, and noting that $\\omega > 0$ and $\\Delta t > 0$:\n$$\n\\sqrt{(\\omega \\Delta t)^{2} (4 + (\\omega \\Delta t)^{2})} = \\omega \\Delta t \\sqrt{4 + (\\omega \\Delta t)^{2}}\n$$\nSubstituting this back into the expression for the roots $\\lambda$:\n$$\n\\lambda = \\frac{2 + (\\omega \\Delta t)^{2} \\pm \\omega \\Delta t \\sqrt{4 + (\\omega \\Delta t)^{2}}}{2}\n$$\nThis gives two real roots, $\\lambda_1$ and $\\lambda_2$.\n$$\n\\lambda_1 = \\frac{2 + (\\omega \\Delta t)^{2} + \\omega \\Delta t \\sqrt{4 + (\\omega \\Delta t)^{2}}}{2}\n$$\n$$\n\\lambda_2 = \\frac{2 + (\\omega \\Delta t)^{2} - \\omega \\Delta t \\sqrt{4 + (\\omega \\Delta t)^{2}}}{2}\n$$\nThe dominant amplification factor, $\\lambda_{\\max}$, is the root with the larger magnitude. Since $\\omega \\Delta t \\sqrt{4 + (\\omega \\Delta t)^{2}} > 0$, it is clear that $\\lambda_1 > \\lambda_2$. The product of the roots of the characteristic equation is $\\lambda_1 \\lambda_2 = \\frac{c}{a} = \\frac{1}{1} = 1$. Since $\\lambda_1$ is a sum of positive terms and is greater than $1$, its reciprocal $\\lambda_2$ must be between $0$ and $1$. Therefore, $|\\lambda_1| > |\\lambda_2|$, and the dominant amplification factor is $\\lambda_{\\max} = \\lambda_1$.\n$$\n\\lambda_{\\max} = \\frac{2 + (\\omega \\Delta t)^{2} + \\omega \\Delta t \\sqrt{4 + (\\omega \\Delta t)^{2}}}{2}\n$$\nTo obtain a more simplified form, we can rewrite the expression. Let us factor out a $2$ from the square root:\n$$\n\\sqrt{4 + (\\omega \\Delta t)^{2}} = \\sqrt{4 \\left(1 + \\frac{(\\omega \\Delta t)^{2}}{4}\\right)} = 2 \\sqrt{1 + \\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}}\n$$\nSubstituting this into the expression for $\\lambda_{\\max}$:\n$$\n\\lambda_{\\max} = \\frac{2 + (\\omega \\Delta t)^{2} + \\omega \\Delta t \\left(2 \\sqrt{1 + \\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}}\\right)}{2}\n$$\n$$\n\\lambda_{\\max} = 1 + \\frac{(\\omega \\Delta t)^{2}}{2} + \\omega \\Delta t \\sqrt{1 + \\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}}\n$$\nLet the dimensionless parameter be $u = \\frac{\\omega \\Delta t}{2}$. The expression becomes:\n$$\n\\lambda_{\\max} = 1 + 2u^{2} + 2u \\sqrt{1 + u^{2}}\n$$\nThis is recognizable as the expansion of a perfect square:\n$$\n\\lambda_{\\max} = \\left(u + \\sqrt{1 + u^{2}}\\right)^{2}\n$$\nSubstituting $u = \\frac{\\omega \\Delta t}{2}$ back gives the final simplified expression for the dominant amplification factor:\n$$\n\\lambda_{\\max}(\\Delta t) = \\left(\\frac{\\omega \\Delta t}{2} + \\sqrt{1 + \\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}}\\right)^{2}\n$$", "answer": "$$\n\\boxed{\\left(\\frac{\\omega \\Delta t}{2} + \\sqrt{1 + \\left(\\frac{\\omega \\Delta t}{2}\\right)^{2}}\\right)^{2}}\n$$", "id": "2466811"}, {"introduction": "The remarkable long-term energy conservation of the velocity Verlet algorithm is not an accident; it arises from its specific, symmetric structure which makes it a geometric integrator. This exercise challenges you to analyze a modified, non-symmetric integration scheme to discover how seemingly small changes can have dramatic consequences for energy conservation [@problem_id:2466845]. By investigating this \"broken\" integrator, you will uncover the origin of secular energy drift and appreciate why the careful construction of Verlet methods is crucial for reliable long-time molecular simulations.", "problem": "Consider a one-dimensional particle of mass $m$ moving in a smooth, conservative potential $V(x)$ with force $F(x)=-\\frac{dV}{dx}$. The total energy is $H(x,v)=\\frac{1}{2} m v^{2}+V(x)$. In a standard velocity Verlet integrator with time step $\\Delta t$, the updates are made in a symmetric sequence of a half-step velocity update, a full-step position update, and a second half-step velocity update, all using forces consistent with the same potential evaluation at the corresponding positions.\n\nSuppose instead that you implement the following scheme in which the forces used in the position and velocity updates are not used in a symmetric, consistent way:\n- Update the position using the force at the beginning of the step:\n$$x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n}).$$\n- Update the velocity using only the force at the end of the step (no half-step splitting):\n$$v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1}).$$\n\nAssume $V(x)$ is smooth and the step size $\\Delta t$ is chosen small enough that the scheme is numerically stable over many steps for the system under study. Compared to the standard velocity Verlet method, which maintains near-constant energy with bounded oscillations over long times, which statement best describes the long-time behavior of the total energy $H(x,v)$ under the above inconsistent-force update?\n\nA. The total energy remains nearly constant with small, bounded oscillations of order $O(\\Delta t^{2})$ for arbitrarily long simulation times, as in a symplectic, time-reversible scheme.\n\nB. The total energy exhibits a secular drift over long times, typically monotonic on average (either increasing or decreasing depending on the system and $\\Delta t$), because the scheme is neither symplectic nor time-reversible.\n\nC. The total energy is exactly conserved step-by-step for any $\\Delta t$ whenever $F(x)$ is conservative, because the force derives from a potential.\n\nD. The total energy performs an unbiased random walk about the exact value with no systematic drift; its mean stays constant while its variance grows like $O(t)$ solely due to time-discretization noise.", "solution": "The problem statement must be validated before a solution is attempted.\n\n### Step 1: Extract Givens\n- A one-dimensional particle of mass $m$ moves in a smooth, conservative potential $V(x)$.\n- Force: $F(x) = -\\frac{dV}{dx}$.\n- Total energy: $H(x,v)=\\frac{1}{2} m v^{2}+V(x)$.\n- A proposed numerical integration scheme with time step $\\Delta t$:\n  1. Position update: $x_{n+1}=x_{n}+\\Delta t\\, v_{n}+\\frac{\\Delta t^{2}}{2 m}\\,F(x_{n})$.\n  2. Velocity update: $v_{n+1}=v_{n}+\\frac{\\Delta t}{m}\\,F(x_{n+1})$.\n- Assumptions: $V(x)$ is smooth, and $\\Delta t$ is small enough for numerical stability.\n- Question: Describe the long-time behavior of the total energy $H(x,v)$ under this scheme.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is set in the context of classical mechanics and numerical integration methods (specifically, for molecular dynamics), which is a standard topic in computational physics and chemistry. The equations are well-defined. The problem is scientifically sound.\n- **Well-Posed:** The integration scheme is explicitly defined. The question asks for the long-term behavior of a specific quantity (energy), which can be analyzed using the theory of numerical methods for differential equations. The problem is well-posed.\n- **Objective:** The problem is stated using precise mathematical language, free from subjectivity or ambiguity.\n\n### Step 3: Verdict and Action\nThe problem statement is scientifically sound, well-posed, and objective. It is **valid**. A solution will be derived.\n\nThe core of the problem is to determine the long-term energy conservation properties of the given numerical scheme. The excellent long-term energy stability of methods like the standard velocity Verlet algorithm stems from their geometric properties, namely being **symplectic** and **time-reversible**. We must investigate whether the proposed scheme possesses these properties.\n\nThe mapping from the state at time $t_n$, $(x_n, v_n)$, to the state at time $t_{n+1}$, $(x_{n+1}, v_{n+1})$, is given by:\n$$x_{n+1} = x_n + \\Delta t \\, v_n + \\frac{\\Delta t^2}{2m} F(x_n)$$\n$$v_{n+1} = v_n + \\frac{\\Delta t}{m} F(x_{n+1})$$\n\n**1. Analysis of Time-Reversibility**\nA scheme is time-reversible if, starting from $(x_{n+1}, v_{n+1})$ and evolving backward in time with a step $-\\Delta t$, we recover $(x_n, v_n)$. The backward step equations would be:\n$$x'_{n} = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{(-\\Delta t)^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t\\, v_{n+1} + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$v'_{n} = v_{n+1} + \\frac{-\\Delta t}{m} F(x'_{n})$$\nWe check if $x'_n = x_n$. Substitute the forward expression for $v_{n+1}$:\n$$x'_{n} = x_{n+1} - \\Delta t \\left( v_n + \\frac{\\Delta t}{m} F(x_{n+1}) \\right) + \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{m} F(x_{n+1}) + \\frac{\\Delta t^2}{2m} F(x_{n+1}) = x_{n+1} - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\nNow substitute the forward expression for $x_{n+1}$:\n$$x'_{n} = \\left( x_n + \\Delta t v_n + \\frac{\\Delta t^2}{2m} F(x_n) \\right) - \\Delta t v_n - \\frac{\\Delta t^2}{2m} F(x_{n+1})$$\n$$x'_{n} = x_n + \\frac{\\Delta t^2}{2m} \\left( F(x_n) - F(x_{n+1}) \\right)$$\nSince $F(x_n) \\neq F(x_{n+1})$ in general, we have $x'_n \\neq x_n$. The scheme is **not time-reversible**.\n\n**2. Analysis of Symplecticity**\nA one-step numerical method for a Hamiltonian system is symplectic if the Jacobian of the map $(x_n, v_n) \\to (x_{n+1}, v_{n+1})$ has a determinant of exactly $1$. The Jacobian matrix is $J = \\begin{pmatrix} \\frac{\\partial x_{n+1}}{\\partial x_n} & \\frac{\\partial x_{n+1}}{\\partial v_n} \\\\ \\frac{\\partial v_{n+1}}{\\partial x_n} & \\frac{\\partial v_{n+1}}{\\partial v_n} \\end{pmatrix}$. Let $F'(x) = dF/dx$.\nThe partial derivatives are:\n$$\\frac{\\partial x_{n+1}}{\\partial x_n} = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\n$$\\frac{\\partial x_{n+1}}{\\partial v_n} = \\Delta t$$\nFor the derivatives of $v_{n+1}$, we must use the chain rule, as $v_{n+1}$ depends on $x_{n+1}$, which in turn depends on $(x_n, v_n)$.\n$$\\frac{\\partial v_{n+1}}{\\partial x_n} = \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial x_n} = \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)$$\n$$\\frac{\\partial v_{n+1}}{\\partial v_n} = 1 + \\frac{\\partial v_{n+1}}{\\partial x_{n+1}} \\frac{\\partial x_{n+1}}{\\partial v_n} = 1 + \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) (\\Delta t) = 1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})$$\nThe determinant is:\n$$\\det(J) = \\left(\\frac{\\partial x_{n+1}}{\\partial x_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial v_n}\\right) - \\left(\\frac{\\partial x_{n+1}}{\\partial v_n}\\right)\\left(\\frac{\\partial v_{n+1}}{\\partial x_n}\\right)$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right)\\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - (\\Delta t) \\left[ \\left(\\frac{\\Delta t}{m} F'(x_{n+1})\\right) \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\right]$$\nFactoring out the common term $(1 + \\frac{\\Delta t^2}{2m} F'(x_n))$:\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) \\left[ \\left(1 + \\frac{\\Delta t^2}{m} F'(x_{n+1})\\right) - \\frac{\\Delta t^2}{m} F'(x_{n+1}) \\right]$$\n$$\\det(J) = \\left(1 + \\frac{\\Delta t^2}{2m} F'(x_n)\\right) [1] = 1 + \\frac{\\Delta t^2}{2m} F'(x_n)$$\nFor the scheme to be symplectic, $\\det(J)$ must be identically $1$. This is only true if $F'(x_n)=0$ (e.g., constant force) or $\\Delta t=0$, neither of which holds in general. Therefore, the scheme is **not symplectic**.\n\n**3. Consequence for Energy Conservation**\nSymplectic, time-reversible integrators like velocity Verlet conserve a \"shadow Hamiltonian\" that is very close to the true Hamiltonian. This property ensures that the total energy error remains bounded over arbitrarily long simulation times, exhibiting small oscillations.\nNon-symplectic integrators, such as the one given, do not conserve a nearby shadow Hamiltonian. The fact that $\\det(J) \\neq 1$ means the algorithm does not preserve phase-space volume. This violation of the geometric structure of Hamiltonian dynamics leads to a systematic, accumulating error in the total energy. This long-term, non-oscillatory trend is known as a **secular drift**. The energy will typically drift monotically away from its initial value. The direction of the drift (increasing or decreasing) depends on the sign of the term $\\frac{\\Delta t^2}{2m}F'(x)$, which in turn depends on the potential. For example, in a simple harmonic oscillator, $V(x) = \\frac{1}{2}kx^2$, so $F(x) = -kx$ and $F'(x) = -k < 0$. In this case, $\\det(J) < 1$, leading to a systematic decrease in energy.\n\nThe conclusion is that the proposed scheme, being neither symplectic nor time-reversible, will exhibit poor long-term energy conservation characterized by a secular drift.\n\n### Option-by-Option Analysis\n\n**A. The total energy remains nearly constant with small, bounded oscillations of order $O(\\Delta t^{2})$ for arbitrarily long simulation times, as in a symplectic, time-reversible scheme.**\nThis describes the behavior of a symplectic integrator like velocity Verlet. As demonstrated above, the given scheme is not symplectic or time-reversible. Thus, it will not exhibit this favorable energy behavior.\nVerdict: **Incorrect**.\n\n**B. The total energy exhibits a secular drift over long times, typically monotonic on average (either increasing or decreasing depending on the system and $\\Delta t$), because the scheme is neither symplectic nor time-reversible.**\nThis statement accurately describes the consequence of a numerical integrator lacking symplecticity and time-reversibility when applied to a conservative system. Our analysis has confirmed that the scheme lacks these properties. Therefore, a secular drift in energy is the expected behavior.\nVerdict: **Correct**.\n\n**C. The total energy is exactly conserved step-by-step for any $\\Delta t$ whenever $F(x)$ is conservative, because the force derives from a potential.**\nThis is fundamentally incorrect. The conservative nature of the force guarantees energy conservation for the *continuous* physical system, not for its discrete numerical approximation. Most numerical integrators, including this one, introduce a discretization error at each step, causing the numerical energy to change. An explicit calculation of the energy change over one step, $\\Delta H = H_{n+1} - H_n$, shows it is non-zero and of order $O(\\Delta t^2)$.\nVerdict: **Incorrect**.\n\n**D. The total energy performs an unbiased random walk about the exact value with no systematic drift; its mean stays constant while its variance grows like $O(t)$ solely due to time-discretization noise.**\nThis is incorrect. The error introduced at each step is not random but systematic. The energy change per step, $\\Delta H_n$, has a non-zero average value for a typical trajectory. The accumulation of these systematic, one-directional errors leads to a secular drift, not an unbiased random walk. The mean of the energy error does not stay constant but drifts over time.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{B}$$", "id": "2466845"}, {"introduction": "Beyond simple particle motion, real-world molecular dynamics requires modeling the complex rotation of rigid bodies. This advanced practice guides you through implementing a Verlet-family integrator to simulate the rotational dynamics of a diatomic molecule, adapting the core principles of the algorithm to the mathematical framework of quaternions [@problem_id:2466818]. This hands-on coding exercise bridges theory and application, demonstrating how to handle rotational degrees of freedom while preserving the excellent energy conservation properties that make Verlet methods so powerful.", "problem": "Implement a program that advances the orientation of a rigid diatomic molecule modeled as a linear rigid rotor using a symplectic method from the Verlet family, representing orientation by unit quaternions. The diatomic is modeled as two point masses, with the bond axis fixed in the body frame along the body’s third principal axis. Let the body-frame unit vector of the bond be $\\mathbf{e}_3 = (0,0,1)$, and let the body-to-space orientation be represented by a unit quaternion $q = (q_0,q_1,q_2,q_3)$ in scalar-first convention. The body-frame angular velocity is $\\boldsymbol{\\omega}_{\\mathrm{b}} = (\\omega_1,\\omega_2,\\omega_3)$, constrained at all times to satisfy $\\omega_3 = 0$ (no spin about the bond axis). The space-frame bond direction is $\\mathbf{n}(t) = \\mathcal{R}(q(t))\\,\\mathbf{e}_3$, where $\\mathcal{R}(q)$ is the rotation corresponding to $q$. All quantities must be expressed in the International System of Units (SI).\n\nThe diatomic consists of two point masses $m_1$ and $m_2$ separated by a fixed bond length $L$. The reduced mass is $\\mu = \\dfrac{m_1 m_2}{m_1 + m_2}$, and the nonzero principal moments of inertia are equal and given by $I_\\perp = \\mu L^2$ about any axis perpendicular to the bond axis. The principal moment about the bond axis is zero; consequently, the allowed angular velocity must remain perpendicular to the bond axis, i.e., $\\omega_3 = 0$ for all times. The rotational kinetic energy is\n$$\nK(t) = \\tfrac{1}{2} I_\\perp \\left(\\omega_1(t)^2 + \\omega_2(t)^2\\right).\n$$\n\nIn the presence of a uniform, static electric field $\\mathbf{E}$, suppose the molecule has a permanent electric dipole of magnitude $p$ rigidly aligned with the bond axis, so that the space-frame dipole vector is $\\mathbf{p}(t) = p\\,\\mathbf{n}(t)$. The space-frame torque is then\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}}(t) = \\mathbf{p}(t) \\times \\mathbf{E} = p\\,\\mathbf{n}(t)\\times \\mathbf{E}.\n$$\nThe corresponding body-frame torque is $\\boldsymbol{\\tau}_{\\mathrm{b}}(t) = \\mathcal{R}(q(t))^\\top \\boldsymbol{\\tau}_{\\mathrm{s}}(t)$. The rotational equations of motion in the body frame are Euler’s equations\n$$\n\\mathbf{I}\\,\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\boldsymbol{\\tau}_{\\mathrm{b}} - \\boldsymbol{\\omega}_{\\mathrm{b}} \\times (\\mathbf{I}\\,\\boldsymbol{\\omega}_{\\mathrm{b}}),\n$$\nwith $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$. Under the constraint $\\omega_3 = 0$ and when the torque has no component along the bond when expressed in the body frame, the third component of the angular acceleration vanishes, and the first two components satisfy\n$$\n\\dot{\\omega}_1 = \\dfrac{\\tau_{\\mathrm{b},1}}{I_\\perp},\\quad \\dot{\\omega}_2 = \\dfrac{\\tau_{\\mathrm{b},2}}{I_\\perp},\\quad \\dot{\\omega}_3 = 0.\n$$\n\nThe quaternion kinematics are given by\n$$\n\\dot{q} = \\tfrac{1}{2} \\, q \\otimes \\omega^\\flat,\n$$\nwhere $\\otimes$ denotes quaternion multiplication and $\\omega^\\flat = (0,\\omega_1,\\omega_2,\\omega_3)$ is the pure-imaginary quaternion associated with the body-frame angular velocity. The orientation quaternion must remain normalized at all times.\n\nYour program must:\n1. Implement a time integrator from the Verlet family for the rotational dynamics using quaternions, advancing $(q,\\boldsymbol{\\omega}_{\\mathrm{b}})$ with a fixed time step $\\Delta t$ over a specified number of steps $N$. The angular velocity must obey $\\omega_3=0$ at all times. The quaternion must be re-normalized to unit length after each update. The torque must be computed from the current orientation using the above expressions.\n2. For cases where $\\mathbf{E} \\neq \\mathbf{0}$ and $p \\neq 0$, treat the potential energy as $U(t) = -\\mathbf{p}(t)\\cdot\\mathbf{E} = -p\\,\\mathbf{n}(t)\\cdot \\mathbf{E}$.\n3. Compute the requested quantitative outputs for each test case below.\n\nUse the following test suite of three parameter sets. For each, initialize the orientation and angular velocity as specified, integrate for the given number of steps and time step, and compute the requested single scalar result.\n\nTest case A (torque-free, energy conservation “happy path”):\n- Parameters: $m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-10}\\ \\mathrm{m}$, $\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$, $p = 0\\ \\mathrm{C\\cdot m}$, $\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$, $N = 2000$.\n- Initial conditions: $q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ (so that $\\mathbf{n}(0)$ is along the space-frame $x$-axis), and $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$.\n- Required output: the relative kinetic energy error at final time,\n$$\n\\varepsilon_K = \\dfrac{K(N\\Delta t) - K(0)}{K(0)},\n$$\nas a dimensionless float.\n\nTest case B (alignment under a field, general behavior):\n- Parameters: $m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-10}\\ \\mathrm{m}$, $\\mathbf{E} = (0,0,1.0\\times 10^{7})\\ \\mathrm{V/m}$, $p = 3.33564\\times 10^{-30}\\ \\mathrm{C\\cdot m}$, $\\Delta t = 1.0\\times 10^{-15}\\ \\mathrm{s}$, $N = 10000$.\n- Initial conditions: $q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ and $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,0,\\,0)\\ \\mathrm{rad/s}$.\n- Required output: the final polar angle in radians between the bond direction and the space-frame $z$-axis,\n$$\n\\theta_{\\mathrm{f}} = \\arccos\\!\\big(n_z(N\\Delta t)\\big),\n$$\nexpressed in radians as a float.\n\nTest case C (boundary condition: larger time step, torque-free, energy conservation under coarser resolution):\n- Parameters: $m_1 = m_2 = 3.0\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-10}\\ \\mathrm{m}$, $\\mathbf{E} = (0,0,0)\\ \\mathrm{V/m}$, $p = 0\\ \\mathrm{C\\cdot m}$, $\\Delta t = 5.0\\times 10^{-15}\\ \\mathrm{s}$, $N = 400$.\n- Initial conditions: $q(0) = \\left(\\tfrac{\\sqrt{2}}{2},\\,0,\\,-\\tfrac{\\sqrt{2}}{2},\\,0\\right)$ and $\\boldsymbol{\\omega}_{\\mathrm{b}}(0) = (0,\\,1.0\\times 10^{12},\\,0)\\ \\mathrm{rad/s}$.\n- Required output: the relative kinetic energy error $\\varepsilon_K$ as defined above.\n\nFinal output format: Your program should produce a single line of output containing the three results in the order of Test case A, then Test case B, then Test case C, as a comma-separated list enclosed in square brackets. Each float must be rendered in scientific notation with $10$ significant digits. For example, an output with placeholders would look like\n$[a\\_1,a\\_2,a\\_3]$,\nwhere each $a_i$ is formatted like $x.xxxxxxxxx\\times 10^{y}$ (e.g., $1.2345678900\\mathrm{e}{-03}$). No other text should be printed.", "solution": "The problem statement has been rigorously analyzed and is deemed valid. It constitutes a well-posed initial value problem in classical rotational dynamics, is scientifically sound, and provides all necessary data and constraints for a unique solution. All parameters are physically consistent.\n\nThe task is to simulate the rotational dynamics of a linear rigid rotor using a time-reversible, symplectic integrator from the Verlet family. The state of the system is described by its orientation, represented by a unit quaternion $q(t)$, and its angular velocity in the body-fixed frame, $\\boldsymbol{\\omega}_{\\mathrm{b}}(t)$. We will implement a \"velocity Verlet\" algorithm adapted for rotational motion. This class of algorithms is known for excellent long-term energy conservation, which is a critical feature for molecular simulations.\n\nThe state variables at discrete time steps $t_n = n\\Delta t$ are the quaternion $q_n = q(t_n)$ and the body-frame angular velocity $\\boldsymbol{\\omega}_{\\mathrm{b},n} = \\boldsymbol{\\omega}_{\\mathrm{b}}(t_n)$. The body-frame angular acceleration is $\\boldsymbol{\\alpha}_{\\mathrm{b},n} = \\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}}(t_n)$.\n\nThe equations of motion are given as:\n1. Rotational dynamics (Euler's equations, simplified for a linear rotor):\n$$\n\\dot{\\boldsymbol{\\omega}}_{\\mathrm{b}} = \\mathbf{I}^{-1} \\boldsymbol{\\tau}_{\\mathrm{b}}(q) \\equiv \\boldsymbol{\\alpha}_{\\mathrm{b}}(q)\n$$\nwhere $\\mathbf{I} = \\mathrm{diag}(I_\\perp, I_\\perp, 0)$ is the diagonal inertia tensor in the body frame, and the body-frame torque $\\boldsymbol{\\tau}_{\\mathrm{b}}$ depends on the orientation $q$. Specifically, for the components perpendicular to the bond axis, we have $\\dot{\\omega}_1 = \\tau_{\\mathrm{b},1}/I_\\perp$ and $\\dot{\\omega}_2 = \\tau_{\\mathrm{b},2}/I_\\perp$. We enforce the constraint $\\omega_3 = 0$ at all times.\n\n2. Kinematics of orientation:\n$$\n\\dot{q} = \\frac{1}{2} q \\otimes \\omega^\\flat_{\\mathrm{b}}\n$$\nwhere $\\otimes$ denotes quaternion multiplication and $\\omega^\\flat_{\\mathrm{b}} = (0, \\omega_1, \\omega_2, \\omega_3)$ is the pure quaternion representation of the angular velocity vector $\\boldsymbol{\\omega}_{\\mathrm{b}}$.\n\nThe velocity Verlet algorithm proceeds in the following steps to advance the state from time $t_n$ to $t_{n+1} = t_n + \\Delta t$:\n\nStep 1: Half-step update of angular velocity.\nThe angular velocity is advanced by a half time step using the current angular acceleration.\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} = \\boldsymbol{\\omega}_{\\mathrm{b}, n} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n} \\frac{\\Delta t}{2}\n$$\n\nStep 2: Full-step update of orientation.\nThe orientation quaternion is updated over the full time step $\\Delta t$ using the half-step angular velocity $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$. For a constant angular velocity $\\boldsymbol{\\omega}$, the solution to the kinematic equation is $q(t) = q(0) \\otimes \\exp(\\frac{t}{2}\\omega^\\flat)$. We approximate the evolution from $t_n$ to $t_{n+1}$ by assuming the constant angular velocity is $\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}$. The update is performed by multiplication with an incremental rotation quaternion $\\Delta q_n$:\n$$\nq_{n+1} = q_n \\otimes \\Delta q_n\n$$\nThe incremental quaternion $\\Delta q_n$ corresponds to a rotation by an angle $\\theta = ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}|| \\Delta t$ around the axis $\\hat{\\mathbf{u}} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} / ||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$. It is given by:\n$$\n\\Delta q_n = \\left(\\cos\\left(\\frac{\\theta}{2}\\right), \\sin\\left(\\frac{\\theta}{2}\\right)\\hat{\\mathbf{u}}\\right)\n$$\nIf $||\\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2}||$ is close to zero, this expression is replaced by its Taylor expansion to avoid numerical instability. After the update, $q_{n+1}$ is re-normalized to unity, $q_{n+1} \\leftarrow q_{n+1} / ||q_{n+1}||$, to counteract floating-point error accumulation.\n\nStep 3: Compute new torque and acceleration.\nWith the new orientation $q_{n+1}$, we compute the new physical state.\nFirst, the space-frame bond direction vector $\\mathbf{n}_{n+1}$:\n$$\n\\mathbf{n}_{n+1} = \\mathcal{R}(q_{n+1}) \\mathbf{e}_3\n$$\nwhere $\\mathbf{e}_3 = (0,0,1)$ and $\\mathcal{R}(q)$ is the rotation matrix corresponding to $q=(q_0, q_1, q_2, q_3)$:\n$$\n\\mathcal{R}(q) = \\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2) & 2(q_1 q_2 - q_0 q_3) & 2(q_1 q_3 + q_0 q_2) \\\\\n2(q_1 q_2 + q_0 q_3) & 1 - 2(q_1^2 + q_3^2) & 2(q_2 q_3 - q_0 q_1) \\\\\n2(q_1 q_3 - q_0 q_2) & 2(q_2 q_3 + q_0 q_1) & 1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}\n$$\nNext, the space-frame torque $\\boldsymbol{\\tau}_{\\mathrm{s}, n+1}$:\n$$\n\\boldsymbol{\\tau}_{\\mathrm{s}, n+1} = p \\, \\mathbf{n}_{n+1} \\times \\mathbf{E}\n$$\nThis is transformed to the body frame:\n$$\n\\boldsymbol{\\tau}_{\\mathrm{b}, n+1} = \\mathcal{R}(q_{n+1})^\\top \\boldsymbol{\\tau}_{\\mathrm{s}, n+1}\n$$\nFinally, the new body-frame angular acceleration $\\boldsymbol{\\alpha}_{\\mathrm{b}, n+1}$:\n$$\n\\alpha_{\\mathrm{b},1,n+1} = \\frac{\\tau_{\\mathrm{b},1,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},2,n+1} = \\frac{\\tau_{\\mathrm{b},2,n+1}}{I_\\perp}, \\quad \\alpha_{\\mathrm{b},3,n+1} = 0\n$$\n\nStep 4: Second half-step update of angular velocity.\nThe angular velocity is updated for the remaining half-step using the new acceleration, completing the step from $t_n$ to $t_{n+1}$:\n$$\n\\boldsymbol{\\omega}_{\\mathrm{b}, n+1} = \\boldsymbol{\\omega}_{\\mathrm{b}, n+1/2} + \\boldsymbol{\\alpha}_{\\mathrm{b}, n+1} \\frac{\\Delta t}{2}\n$$\nThe constraint $\\omega_3 = 0$ is enforced at each step.\n\nThis algorithm is implemented for each test case.\nFor cases A and C (torque-free), $\\mathbf{E} = \\mathbf{0}$, which implies the torque $\\boldsymbol{\\tau}$ and angular acceleration $\\boldsymbol{\\alpha}_{\\mathrm{b}}$ are always zero. The algorithm correctly predicts that $\\boldsymbol{\\omega}_{\\mathrm{b}}$ remains constant, leading to perfect conservation of kinetic energy, with any deviation resulting only from floating-point arithmetic limitations. The relative energy error $\\varepsilon_K$ is thus expected to be near machine precision.\n\nFor case B, the non-zero electric field $\\mathbf{E}$ and dipole moment $p$ produce a torque that realigns the molecule. The simulation tracks this motion, and the final polar angle $\\theta_{\\mathrm{f}}$ is computed from the $z$-component of the final bond vector $\\mathbf{n}(N\\Delta t)$, which is given by $n_z = 1 - 2(q_1^2 + q_2^2)$.\nThe required output is $\\theta_{\\mathrm{f}} = \\arccos(n_z)$.\nThe implementation will follow these steps to generate the specified outputs.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a Verlet integrator for rigid diatomic molecule rotation\n    and calculates results for the specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case A\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 1.0e-15, \"N\": 2000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        },\n        # Test case B\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 1.0e7]), \"p\": 3.33564e-30,\n            \"dt\": 1.0e-15, \"N\": 10000,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 0.0, 0.0]),\n            \"output_type\": \"final_angle\"\n        },\n        # Test case C\n        {\n            \"m1\": 3.0e-26, \"m2\": 3.0e-26, \"L\": 1.0e-10,\n            \"E\": np.array([0.0, 0.0, 0.0]), \"p\": 0.0,\n            \"dt\": 5.0e-15, \"N\": 400,\n            \"q0\": np.array([np.sqrt(2)/2, 0.0, -np.sqrt(2)/2, 0.0]),\n            \"omega_b0\": np.array([0.0, 1.0e12, 0.0]),\n            \"output_type\": \"energy_error\"\n        }\n    ]\n\n    results = []\n    \n    # Helper functions\n    def q_mult(q1, q2):\n        \"\"\"Quaternion multiplication q1*q2, scalar-first.\"\"\"\n        w1, x1, y1, z1 = q1\n        w2, x2, y2, z2 = q2\n        w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2\n        x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2\n        y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2\n        z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2\n        return np.array([w, x, y, z])\n\n    def q_to_rot_matrix(q):\n        \"\"\"Rotation matrix from scalar-first quaternion.\"\"\"\n        q0, q1, q2, q3 = q\n        # Explicit form to match the one in the explanation\n        R = np.array([\n            [1 - 2*(q2**2 + q3**2), 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],\n            [2*(q1*q2 + q0*q3), 1 - 2*(q1**2 + q3**2), 2*(q2*q3 - q0*q1)],\n            [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), 1 - 2*(q1**2 + q2**2)]\n        ])\n        return R\n\n    for case in test_cases:\n        # Unpack parameters\n        m1, m2, L = case[\"m1\"], case[\"m2\"], case[\"L\"]\n        E, p = case[\"E\"], case[\"p\"]\n        dt, N = case[\"dt\"], case[\"N\"]\n        \n        # Calculate derived constants\n        mu = (m1 * m2) / (m1 + m2)\n        I_perp = mu * L**2\n        inv_I_perp = 1.0 / I_perp if I_perp != 0 else 0.0\n\n        # Initialize state variables\n        q = np.copy(case[\"q0\"])\n        omega_b = np.copy(case[\"omega_b0\"])\n\n        def compute_accel(current_q):\n            if p == 0.0:\n                return np.array([0.0, 0.0, 0.0])\n            \n            # Rotation matrix from quaternion\n            R = q_to_rot_matrix(current_q)\n            \n            # Space-frame bond vector n (third column of R)\n            n_s = R[:, 2]\n            \n            # Space-frame torque\n            tau_s = p * np.cross(n_s, E)\n            \n            # Body-frame torque\n            tau_b = R.T @ tau_s\n            \n            # Body-frame angular acceleration\n            alpha_b = np.zeros(3)\n            alpha_b[0] = tau_b[0] * inv_I_perp\n            alpha_b[1] = tau_b[1] * inv_I_perp\n            return alpha_b\n\n        # Initial kinetic energy for energy error calculation\n        if case[\"output_type\"] == \"energy_error\":\n            K0 = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n\n        # Initial acceleration\n        alpha_b = compute_accel(q)\n\n        # Main integration loop (Velocity Verlet)\n        for _ in range(N):\n            # 1. Half-step velocity update\n            omega_b_half = omega_b + 0.5 * dt * alpha_b\n\n            # 2. Full-step position (orientation) update\n            omega_norm = np.linalg.norm(omega_b_half)\n            if omega_norm > 1e-16: # Avoid division by zero\n                theta = omega_norm * dt\n                axis = omega_b_half / omega_norm\n                \n                delta_q_w = np.cos(theta / 2.0)\n                delta_q_v = np.sin(theta / 2.0) * axis\n                \n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n            else: # Small angle approximation\n                delta_q_v = 0.5 * dt * omega_b_half\n                delta_q_w = np.sqrt(1.0 - np.dot(delta_q_v, delta_q_v))\n                delta_q = np.array([delta_q_w, delta_q_v[0], delta_q_v[1], delta_q_v[2]])\n\n            q = q_mult(q, delta_q)\n            q /= np.linalg.norm(q) # Renormalize\n\n            # 3. Compute new acceleration\n            alpha_b_new = compute_accel(q)\n            \n            # 4. Second half-step velocity update\n            omega_b = omega_b_half + 0.5 * dt * alpha_b_new\n            \n            # Update acceleration for next iteration\n            alpha_b = alpha_b_new\n\n        # Compute required output\n        if case[\"output_type\"] == \"energy_error\":\n            Kf = 0.5 * I_perp * (omega_b[0]**2 + omega_b[1]**2)\n            if K0 == 0.0:\n                result = 0.0 if Kf == 0.0 else np.inf\n            else:\n                result = (Kf - K0) / K0\n        elif case[\"output_type\"] == \"final_angle\":\n            # n_z = 1 - 2*(q1^2 + q2^2)\n            n_z = 1.0 - 2.0 * (q[1]**2 + q[2]**2)\n            # Clip to handle potential floating point errors outside [-1, 1]\n            n_z = np.clip(n_z, -1.0, 1.0)\n            result = np.arccos(n_z)\n            \n        results.append(result)\n\n    # Format and print the final output\n    formatted_results = [f\"{r:.10e}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2466818"}]}