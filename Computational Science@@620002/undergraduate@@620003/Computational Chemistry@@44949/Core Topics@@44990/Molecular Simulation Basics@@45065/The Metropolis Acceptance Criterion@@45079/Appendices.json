{"hands_on_practices": [{"introduction": "The Metropolis acceptance criterion is the heart of many simulation methods, determining whether a proposed change in a system's configuration is accepted based on the energy change $\\Delta U$. This first practice exercise provides a direct, analytical application of the acceptance formula, $A(x'|x) = \\min(1, \\exp(-\\beta \\Delta U))$. By working with a one-dimensional potential, you will calculate this probability for a specific move, reinforcing the fundamental connection between the potential energy landscape and simulation dynamics. [@problem_id:857524]", "id": "857524", "problem": "A one-dimensional classical particle is confined by a potential energy landscape described by the function:\n$$\nU(x) = \\frac{1}{2} \\alpha x^2 - \\gamma x\n$$\nwhere $\\alpha > 0$ and $\\gamma > 0$ are real constants. The system is in thermal equilibrium with a heat bath at a constant inverse temperature $\\beta = 1/(k_B T)$, where $k_B$ is the Boltzmann constant and $T$ is the temperature.\n\nThe equilibrium probability distribution of the particle's position $x$ is given by the canonical distribution, $\\pi(x) \\propto \\exp(-\\beta U(x))$. To simulate the particle's motion and sample from this distribution, the Metropolis algorithm is used. For a symmetric proposal distribution, the probability of accepting a proposed move from state $x$ to state $x'$ is given by:\n$$\nA(x'|x) = \\min\\left(1, \\exp\\left(-\\beta [U(x') - U(x)]\\right)\\right)\n$$\n\nSuppose the particle is initially located at the position corresponding to the minimum of the potential energy, $x_{min}$. A move is then proposed to the non-zero position, $x_0$, where the potential energy $U(x_0)$ is exactly zero.\n\nDerive the analytical expression for the Metropolis acceptance probability, $A(x_0|x_{min})$, for this specific move.\n\n", "solution": "1. The potential is \n$$\nU(x)=\\tfrac12\\alpha x^2-\\gamma x\\,. \n$$\n2. Find the minimum: \n$$\n\\frac{dU}{dx}=\\alpha x-\\gamma=0\\quad\\Rightarrow\\quad x_{\\min}=\\frac{\\gamma}{\\alpha}\\,. \n$$\n3. Evaluate $U$ at $x_{\\min}$:\n$$\nU(x_{\\min})\n=\\tfrac12\\alpha\\Bigl(\\frac{\\gamma}{\\alpha}\\Bigr)^2\n-\\gamma\\Bigl(\\frac{\\gamma}{\\alpha}\\Bigr)\n=\\frac{\\gamma^2}{2\\alpha}-\\frac{\\gamma^2}{\\alpha}\n=-\\frac{\\gamma^2}{2\\alpha}\\,. \n$$\n4. Solve $U(x_0)=0$ for nonzero $x_0$:\n$$\n\\tfrac12\\alpha x_0^2-\\gamma x_0=0\n\\;\\Rightarrow\\;\nx_0\\bigl(\\tfrac12\\alpha x_0-\\gamma\\bigr)=0\n\\;\\Rightarrow\\;\nx_0=\\frac{2\\gamma}{\\alpha}\\,. \n$$\n5. The Metropolis acceptance probability is\n$$\nA(x_0\\!\\mid x_{\\min})\n=\\min\\Bigl(1,\\exp\\bigl[-\\beta\\,(U(x_0)-U(x_{\\min}))\\bigr]\\Bigr)\\,. \n$$\n6. Compute the energy difference:\n$$\nU(x_0)-U(x_{\\min})\n=0-\\Bigl(-\\frac{\\gamma^2}{2\\alpha}\\Bigr)\n=\\frac{\\gamma^2}{2\\alpha}\\,. \n$$\n7. Hence \n$$\nA(x_0\\!\\mid x_{\\min})\n=\\exp\\!\\Bigl(-\\beta\\,\\frac{\\gamma^2}{2\\alpha}\\Bigr)\\,,\n$$\nsince this is less than 1 for $\\beta,\\gamma,\\alpha>0$.", "answer": "$$\\boxed{\\exp\\!\\bigl(-\\beta\\tfrac{\\gamma^2}{2\\alpha}\\bigr)}$$"}, {"introduction": "Moving from a single calculation to a full simulation bridges the gap between theory and practice. This exercise challenges you to implement the Metropolis algorithm in code for a simplified model with potential energy $U(r) = -1/r$. By programming the simulation loop of proposing moves, evaluating the acceptance criterion, and collecting statistics, you will gain first-hand experience in how these rules generate a trajectory that explores the system's state space at a given temperature $T$. [@problem_id:2465276]", "id": "2465276", "problem": "Consider a single-particle radial model in reduced, dimensionless units where the potential energy is given by $U(r)=-\\dfrac{1}{r}$ for $r&gt;0$. Let the absolute temperature be $T&gt;0$, with Boltzmann constant set to $k_{\\mathrm{B}}=1$, so that $\\beta=\\dfrac{1}{T}$. A proposed move from a current radius $r$ to a new radius $r^{\\prime}$ is accepted according to the Metropolis acceptance criterion with probability\n$$\nA\\left(r\\to r^{\\prime}\\right)=\\min\\left(1,\\exp\\left[-\\beta\\left(U(r^{\\prime})-U(r)\\right)\\right]\\right).\n$$\nYou will generate a sequence of radii by attempting outward-only proposals. At each attempt, draw an independent displacement $s$ from the uniform distribution on $[0,\\Delta]$ and set the proposal to $r^{\\prime}=r+s$. If the proposal is accepted, update $r\\leftarrow r^{\\prime}$; otherwise keep $r$ unchanged. Starting from an initial radius $r_{0}&gt;0$, perform exactly $N$ proposal attempts and report the acceptance rate defined as the total number of accepted proposals divided by $N$. All quantities are dimensionless, and no physical units are required.\n\nImplement this protocol for the following test suite of parameter tuples $(T,\\Delta,r_{0},N,\\text{seed})$, where “seed” specifies the integer seed for the pseudorandom number generator to ensure reproducibility. For each tuple, return the acceptance rate as a floating-point number.\n\n- Test $1$: $(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.5,\\,0.2,\\,0.5,\\,100000,\\,12345\\right)$.\n- Test $2$: $(T,\\Delta,r_{0},N,\\text{seed})=\\left(2.0,\\,0.5,\\,1.0,\\,100000,\\,54321\\right)$.\n- Test $3$: $(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.05,\\,0.2,\\,1.0,\\,100000,\\,202311\\right)$.\n- Test $4$: $(T,\\Delta,r_{0},N,\\text{seed})=\\left(0.5,\\,0.05,\\,10.0,\\,100000,\\,8080\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_{1},x_{2},x_{3},x_{4}]$), where each $x_{i}$ is the acceptance rate for test $i$ rounded to exactly six decimal places.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extracted Givens**\n- **System Model:** A single particle in a one-dimensional radial coordinate system with dimensionless units.\n- **Potential Energy Function:** $U(r) = -\\dfrac{1}{r}$ for a radius $r > 0$.\n- **Thermodynamic Parameters:** Absolute temperature $T > 0$ and Boltzmann constant $k_{\\mathrm{B}} = 1$. The inverse temperature is $\\beta = \\dfrac{1}{T}$.\n- **Metropolis Acceptance Criterion:** The probability of accepting a move from a state with radius $r$ to a state with radius $r^{\\prime}$ is given by $A\\left(r \\to r^{\\prime}\\right) = \\min\\left(1, \\exp\\left[-\\beta\\left(U(r^{\\prime}) - U(r)\\right)\\right]\\right)$.\n- **Proposal Generation:** A new radius $r^{\\prime}$ is proposed from a current radius $r$ by the rule $r^{\\prime} = r + s$, where the displacement $s$ is an independent random variable drawn from the uniform distribution on the interval $[0, \\Delta]$. This specifies an \"outward-only\" move.\n- **State Update Rule:** If a proposed move is accepted, the system's state is updated, $r \\leftarrow r^{\\prime}$. If rejected, the state remains unchanged.\n- **Simulation Protocol:** Starting from an initial radius $r_0 > 0$, exactly $N$ proposal attempts are performed.\n- **Output Metric:** The acceptance rate, defined as the total number of accepted proposals divided by the total number of proposal attempts, $N$.\n- **Specific Test Cases:** A set of four parameter tuples $(T, \\Delta, r_0, N, \\text{seed})$ are provided for testing:\n    - Test $1$: $(0.5, 0.2, 0.5, 100000, 12345)$\n    - Test $2$: $(2.0, 0.5, 1.0, 100000, 54321)$\n    - Test $3$: $(0.05, 0.2, 1.0, 100000, 202311)$\n    - Test $4$: $(0.5, 0.05, 10.0, 100000, 8080)$\n\n**Step 2: Validation Using Extracted Givens**\n- **Scientific Grounding:** The problem is firmly grounded in the principles of statistical mechanics and computational physics. The potential $U(r) = -1/r$ is a standard form (e.g., Coulomb or gravitational potential in suitable units). The Metropolis algorithm is a canonical method for Markov Chain Monte Carlo (MCMC) simulation and is a fundamental technique in the field. The setup is scientifically rigorous and conventional.\n- **Well-Posedness:** The problem is unambiguously defined. All parameters, initial conditions, and the algorithm for state propagation are explicitly specified. The use of a fixed seed for the pseudorandom number generator ensures that the simulation is deterministic and yields a single, unique result for each test case. The desired output metric is also clearly defined.\n- **Objectivity:** The problem is stated using precise mathematical and algorithmic language, free of any subjective or opinion-based content.\n\n**Step 3: Verdict and Action**\nThe problem is found to be scientifically grounded, well-posed, objective, and internally consistent. It is therefore **valid**. A solution will be constructed based on direct simulation as described.\n\nThe task is to compute the acceptance rate of a specific Metropolis Monte Carlo simulation protocol. This is a direct application of the algorithm described. The simulation generates a sequence of states (radii) for a particle in a given potential field, forming a Markov chain.\n\nThe core of the algorithm is the Metropolis acceptance criterion. A move from a configuration with radius $r$ to a proposed configuration with radius $r^{\\prime}$ incurs a change in potential energy, $\\Delta U = U(r^{\\prime}) - U(r)$. The move is accepted with probability $A(r \\to r^{\\prime})$.\n\nThe algorithmic procedure for each test case is as follows:\n$1$. Initialize the system. Set the current radius $r_{current} \\leftarrow r_0$, the number of accepted moves $N_{accept} \\leftarrow 0$, and the inverse temperature $\\beta \\leftarrow 1/T$. Seed a pseudorandom number generator with the given integer seed.\n\n$2$. Perform a loop for $N$ iterations, representing the total number of proposal attempts. In each iteration $i$ from $1$ to $N$:\n    a. **Propose a new state:** Generate a random displacement $s$ from the uniform distribution $U(0, \\Delta)$. Calculate the proposed new radius $r_{proposal} = r_{current} + s$. Since $s \\ge 0$, this is always an outward move, so $r_{proposal} \\ge r_{current}$.\n    \n    b. **Calculate the energy change:** The change in potential energy is $\\Delta U = U(r_{proposal}) - U(r_{current})$. Substituting the given potential function $U(r) = -1/r$, we obtain:\n    $$\n    \\Delta U = \\left(-\\frac{1}{r_{proposal}}\\right) - \\left(-\\frac{1}{r_{current}}\\right) = \\frac{1}{r_{current}} - \\frac{1}{r_{proposal}}\n    $$\n    Since $r_{proposal} \\ge r_{current} > 0$, it follows that $1/r_{current} \\ge 1/r_{proposal}$, which ensures that $\\Delta U \\ge 0$.\n\n    c. **Calculate the acceptance probability:** The probability is given by the Metropolis function:\n    $$\n    A = \\min\\left(1, \\exp(-\\beta \\Delta U)\\right)\n    $$\n    Because $\\beta = 1/T > 0$ and we have established that $\\Delta U \\ge 0$ for this specific proposal scheme, the argument of the exponential, $-\\beta \\Delta U$, is always non-positive. Consequently, $\\exp(-\\beta \\Delta U)$ is always in the range $(0, 1]$, and the acceptance probability simplifies to $A = \\exp(-\\beta \\Delta U)$. However, for full generality and strict adherence to the problem's formula, the `min` function will be retained in the implementation.\n\n    d. **Accept or reject the move:** Generate a random number $u$ from the uniform distribution $U(0, 1)$. If $u < A$, the move is accepted. In this case, update the system's state by setting $r_{current} \\leftarrow r_{proposal}$ and increment the acceptance counter, $N_{accept} \\leftarrow N_{accept} + 1$. If $u \\ge A$, the move is rejected, and the system state $r_{current}$ remains unchanged.\n\n$3$. After $N$ iterations are complete, the final acceptance rate is computed as the ratio of the total number of accepted moves to the total number of attempts:\n$$\n\\text{Acceptance Rate} = \\frac{N_{accept}}{N}\n$$\n\nThis procedure is deterministic for a given set of parameters $(T, \\Delta, r_0, N, \\text{seed})$. It will be implemented for each of the four specified test cases to produce the required results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the Metropolis acceptance rate for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (T, Delta, r_0, N, seed).\n    test_cases = [\n        (0.5, 0.2, 0.5, 100000, 12345),\n        (2.0, 0.5, 1.0, 100000, 54321),\n        (0.05, 0.2, 1.0, 100000, 202311),\n        (0.5, 0.05, 10.0, 100000, 8080),\n    ]\n\n    results = []\n    \n    # The potential energy function U(r) = -1/r\n    def U(r):\n        return -1.0 / r\n\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        T, Delta, r0, N, seed = case\n        \n        # Initialize simulation variables\n        beta = 1.0 / T\n        r_current = float(r0)\n        accepted_count = 0\n        \n        # Initialize the random number generator with the specified seed for reproducibility\n        rng = np.random.default_rng(seed)\n        \n        # Perform N proposal attempts\n        for _ in range(N):\n            # 1. Propose a new state (outward-only move)\n            s = rng.uniform(0.0, Delta)\n            r_proposal = r_current + s\n            \n            # 2. Calculate the change in potential energy\n            delta_U = U(r_proposal) - U(r_current)\n            \n            # 3. Calculate the acceptance probability according to the Metropolis criterion.\n            # Since delta_U is always >= 0 for this proposal scheme, exp(-beta * delta_U) <= 1.\n            # The min(1, ...) is technically redundant but included for strict adherence to the formula.\n            acceptance_prob = min(1.0, np.exp(-beta * delta_U))\n            \n            # 4. Accept or reject the move\n            if rng.random() < acceptance_prob:\n                # Accept the move\n                r_current = r_proposal\n                accepted_count += 1\n            # Else, reject the move (r_current remains unchanged)\n            \n        # Calculate the final acceptance rate for this test case\n        acceptance_rate = accepted_count / N\n        results.append(acceptance_rate)\n\n    # Format the results as a comma-separated list of numbers rounded to 6 decimal places,\n    # enclosed in square brackets.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"}, {"introduction": "A robust simulation requires not only a correct algorithm but also a numerically stable implementation, especially when quantities like the energy change $\\Delta E$ are very small. This final exercise delves into the advanced, practical challenges that arise from the limitations of finite-precision computer arithmetic. You will investigate how subtle effects like rounding errors can impact the acceptance decision $u \\lt \\exp(-\\Delta E / (k_B T))$, highlighting the importance of careful implementation for achieving accurate simulation results. [@problem_id:2465269]", "id": "2465269", "problem": "In a canonical-ensemble Metropolis Monte Carlo simulation in computational chemistry, the acceptance probability for a proposed move with energy change $\\Delta E$ at temperature $T$ is\n$$\np_{\\mathrm{acc}}=\\min\\!\\left(1,\\,\\exp\\!\\left[-\\frac{\\Delta E}{k_B T}\\right]\\right),\n$$\nwhere $k_B$ is the Boltzmann constant. Consider an implementation that uses binary64 floating-point arithmetic as standardized by the Institute of Electrical and Electronics Engineers (IEEE) 754, with rounding to nearest, ties-to-even. Let the machine epsilon $\\varepsilon_{\\mathrm{mach}}$ be the distance between $1$ and the next larger representable number in this format, so that $\\varepsilon_{\\mathrm{mach}}=2^{-52}$. A pseudorandom uniform variate $u$ is drawn in $(0,1)$ in the same precision to decide acceptance via the comparison $u<p_{\\mathrm{acc}}$.\n\nFocus on the regime where $x=\\Delta E/(k_B T)$ is very close to zero. Which of the following statements about the consequences of floating-point precision limitations on the acceptance decision, and possible mitigations, are correct?\n\nA. For $0<x\\lesssim \\varepsilon_{\\mathrm{mach}}$, evaluating $\\exp(-x)$ in binary64 can round to $1$ so that $p_{\\mathrm{acc}}$ is computed as exactly $1$, yielding unconditional acceptance and a slight upward bias of acceptance relative to the exact Metropolis rule.\n\nB. Replacing the test $u<\\exp(-x)$ with the logarithmic test $\\ln u<-x$ avoids saturation of the threshold at $1$ for small positive $x$ in binary64, thereby preventing the unconditional-acceptance artifact caused by rounding $\\exp(-x)$ to $1$.\n\nC. Switching from binary64 to binary32 arithmetic (single precision) reduces the frequency of erroneous unconditional acceptances near $x\\approx 0$ because numbers near $1$ are represented more coarsely.\n\nD. If $\\Delta E$ is computed as a difference of two large potential energies, roundoff can flip the sign of $\\Delta E$ when $|\\Delta E|$ is below about one Unit in the Last Place (ULP) of the underlying energies, causing moves that are slightly unfavorable ($x>0$) to be treated as favorable ($x<0$) and thus accepted with probability $1$.\n\nE. Despite such rounding effects, detailed balance with respect to the Boltzmann distribution is exactly preserved because the Metropolis rule is symmetric in floating-point arithmetic.\n\nF. A robust mitigation for errors in $\\Delta E$ near $x\\approx 0$ is to compute $\\Delta E$ via energy-difference formulations that avoid subtracting nearly equal large numbers (for example, incremental or localized updates and compensated summation), thereby reducing catastrophic cancellation and sign errors in $\\Delta E$.\n\nSelect all that apply.", "solution": "The problem statement describes a common scenario in computational statistical mechanics where the theoretical Metropolis acceptance criterion must be implemented using finite-precision floating-point arithmetic. The analysis requires understanding the properties of the IEEE 754 standard and its interaction with the mathematical functions involved.\n\nThe problem statement is validated as follows:\n- **Givens**:\n  - Algorithm: Canonical-ensemble Metropolis Monte Carlo.\n  - Acceptance probability: $p_{\\mathrm{acc}}=\\min\\!\\left(1,\\,\\exp\\!\\left[-\\frac{\\Delta E}{k_B T}\\right]\\right)$.\n  - Arithmetic: IEEE 754 binary64, round-to-nearest, ties-to-even.\n  - Machine epsilon: $\\varepsilon_{\\mathrm{mach}}=2^{-52}$.\n  - Acceptance test: $u < p_{\\mathrm{acc}}$ for $u \\in (0,1)$ in binary64.\n  - Regime of interest: $x = \\Delta E/(k_B T)$ is very close to zero.\n- **Validation**: The problem is scientifically grounded, well-posed, and objective. It describes a real and significant issue in scientific computing, rooted in the established principles of statistical mechanics and numerical analysis. The terms are well-defined and the premises are factually correct. The problem setup is self-contained and free of contradictions or ambiguities that would preclude a rigorous analysis.\n- **Verdict**: The problem is valid. We proceed to a detailed analysis of each statement.\n\nThe analysis is based on the properties of binary64 floating-point arithmetic. The machine epsilon, $\\varepsilon_{\\mathrm{mach}} = 2^{-52}$, is the distance between $1$ and the next larger representable floating-point number. The rounding mode is to the nearest representable number. A value $y$ will be rounded to $1$ if it falls in the interval $(1 - \\frac{1}{2}\\varepsilon_{\\mathrm{mach}}, 1 + \\frac{1}{2}\\varepsilon_{\\mathrm{mach}})$. The next number below $1$ is $1 - \\varepsilon_{\\mathrm{mach}}$. The midpoint is thus $1 - \\varepsilon_{\\mathrm{mach}}/2 = 1 - 2^{-53}$.\n\nLet us examine each statement in detail.\n\n**A. For $0<x\\lesssim \\varepsilon_{\\mathrm{mach}}$, evaluating $\\exp(-x)$ in binary64 can round to $1$ so that $p_{\\mathrm{acc}}$ is computed as exactly $1$, yielding unconditional acceptance and a slight upward bias of acceptance relative to the exact Metropolis rule.**\n\nFor small positive $x$, the Taylor series expansion of $\\exp(-x)$ is $\\exp(-x) = 1 - x + \\frac{x^2}{2} - O(x^3)$. The function value is slightly less than $1$. In binary64 arithmetic, for $\\exp(-x)$ to be rounded to $1$, its value must be greater than the midpoint between $1$ and the next smaller representable number, which is $1 - \\varepsilon_{\\mathrm{mach}}$. This midpoint is $1 - \\varepsilon_{\\mathrm{mach}}/2 = 1 - 2^{-53}$.\nSo, we must have $\\exp(-x) > 1 - 2^{-53}$.\nApproximating $\\exp(-x) \\approx 1 - x$ for small $x$, the condition becomes $1 - x > 1 - 2^{-53}$ which simplifies to $x < 2^{-53}$.\nThus, for any $x$ in the range $0 < x < \\varepsilon_{\\mathrm{mach}}/2$, the computed value of $\\exp(-x)$, let us denote it $\\mathrm{fl}(\\exp(-x))$, will be exactly $1$.\nThe acceptance probability is then computed as $p_{\\mathrm{acc}} = \\min(1, 1) = 1$. The test $u < 1$ becomes true for any random variate $u$ drawn from $(0,1)$. This means any move with such an energy change, which should be accepted with probability $\\exp(-x) < 1$, is instead accepted with probability $1$. This introduces a systematic upward bias in the acceptance rate for slightly unfavorable moves. The statement is a correct description of this numerical artifact. The notation $x \\lesssim \\varepsilon_{\\mathrm{mach}}$ is a qualitative but acceptable description for the range $0 < x < \\varepsilon_{\\mathrm{mach}}/2$.\n\nVerdict: **Correct**.\n\n**B. Replacing the test $u<\\exp(-x)$ with the logarithmic test $\\ln u<-x$ avoids saturation of the threshold at $1$ for small positive $x$ in binary64, thereby preventing the unconditional-acceptance artifact caused by rounding $\\exp(-x)$ to $1$.**\n\nThe original test is $u < p_{\\mathrm{acc}}$. For an unfavorable move ($x>0$), this is $u < \\exp(-x)$. This test is mathematically equivalent to $\\ln u < -x$ for exact arithmetic, as $\\ln$ is a strictly increasing function.\nThe numerical issue identified in A is that $\\mathrm{fl}(\\exp(-x))$ becomes $1$ for small positive $x$.\nThe proposed new test, $\\ln u < -x$, avoids the computation of $\\exp(-x)$. Instead, it compares two numbers: $\\ln u$ and $-x$.\nWhen $x$ is a small positive number (e.g., $x \\approx 10^{-17}$), $-x$ is a small negative number that is well-represented in binary64.\nThe random variate $u$ is in $(0,1)$. If $u$ is close to $1$, say $u=1-\\delta$ for small $\\delta>0$, then $\\ln u = \\ln(1-\\delta) \\approx -\\delta$. This is also a small negative number. The comparison $\\ln u < -x$ is then a comparison between two small, non-zero numbers, which is numerically robust.\nFor example, if the true $x = 2^{-60}$ (which is in the problematic range for the original test), the test becomes $\\ln u < -2^{-60}$. The value $\\ln u$ will be a random negative number. The comparison is now meaningful and is not saturated. A specialized function like `log1p(u-1)` is often used to compute $\\ln u$ accurately for $u$ near $1$. This technique effectively circumvents the saturation of the exponential function.\n\nVerdict: **Correct**.\n\n**C. Switching from binary64 to binary32 arithmetic (single precision) reduces the frequency of erroneous unconditional acceptances near $x\\approx 0$ because numbers near $1$ are represented more coarsely.**\n\nFor binary32 (single precision), the machine epsilon is $\\varepsilon_{\\mathrm{mach},32} = 2^{-23}$. Following the same logic as in A, the unconditional acceptance artifact occurs when $0 < x < \\varepsilon_{\\mathrm{mach},32}/2 = 2^{-24}$.\nFor binary64, the range is $0 < x < \\varepsilon_{\\mathrm{mach},64}/2 = 2^{-53}$.\nThe interval of $x$ values causing the error is $[0, 2^{-24})$ for binary32, and $[0, 2^{-53})$ for binary64. Since $2^{-24}$ is vastly larger than $2^{-53}$, the range of problematic $x$ values is much wider in single precision.\nTherefore, switching from binary64 to binary32 would *increase*, not reduce, the frequency of these erroneous acceptances, assuming the energy changes $\\Delta E$ can fall into this range. The coarser representation of numbers near $1$ makes the problem worse, as a larger range of values rounds to $1$.\n\nVerdict: **Incorrect**.\n\n**D. If $\\Delta E$ is computed as a difference of two large potential energies, roundoff can flip the sign of $\\Delta E$ when $|\\Delta E|$ is below about one Unit in the Last Place (ULP) of the underlying energies, causing moves that are slightly unfavorable ($x>0$) to be treated as favorable ($x<0$) and thus accepted with probability $1$.**\n\nThis describes the phenomenon of catastrophic cancellation. Let the two large potential energies be $E_{\\text{old}}$ and $E_{\\text{new}}$. Suppose $E_{\\text{old}} \\approx E_{\\text{new}} \\approx M$, where $M$ is a large number. The floating-point representations are $\\mathrm{fl}(E_{\\text{old}})$ and $\\mathrm{fl}(E_{\\text{new}})$. The absolute error in these representations is on the order of the ULP of $M$, which is approximately $M \\cdot \\varepsilon_{\\mathrm{mach}}$.\nWhen we compute the difference, $\\Delta E_{\\text{comp}} = \\mathrm{fl}(\\mathrm{fl}(E_{\\text{new}}) - \\mathrm{fl}(E_{\\text{old}}))$, the computed result has an absolute error that can be as large as $\\sim M \\cdot \\varepsilon_{\\mathrm{mach}}$. The relative error of $\\Delta E_{\\text{comp}}$ is this absolute error divided by the true value $|\\Delta E|$. If $|\\Delta E|$ is on the same order of magnitude as the absolute error, the relative error can be enormous, leading to a loss of most or all significant digits.\nIf the true $\\Delta E$ is positive but smaller than the numerical noise, the computed $\\Delta E_{\\text{comp}}$ may randomly be positive or negative. If $\\Delta E_{\\text{comp}}$ happens to be negative, then the computed $x_{\\text{comp}} = \\Delta E_{\\text{comp}} / (k_B T)$ is also negative.\nFor a negative $x_{\\text{comp}}$, the acceptance probability is $p_{\\mathrm{acc}} = \\min(1, \\exp(-x_{\\text{comp}}))$. Since $-x_{\\text{comp}} > 0$, $\\exp(-x_{\\text{comp}}) > 1$, and thus $p_{\\mathrm{acc}} = 1$. A slightly unfavorable move (which should be accepted with probability $<1$) is mistaken for a favorable move and is accepted with probability $1$. The statement accurately describes this critical numerical pitfall.\n\nVerdict: **Correct**.\n\n**E. Despite such rounding effects, detailed balance with respect to the Boltzmann distribution is exactly preserved because the Metropolis rule is symmetric in floating-point arithmetic.**\n\nThe detailed balance condition, assuming a symmetric proposal distribution, is $\\pi(i) P(i \\to j) = \\pi(j) P(j \\to i)$, which requires the ratio of acceptance probabilities to satisfy $A(i \\to j)/A(j \\to i) = \\exp(-(E_j - E_i)/k_B T)$.\nIn floating-point arithmetic, the computed energy differences are $\\Delta E_{ij}^{\\text{comp}} = \\mathrm{fl}(\\mathrm{fl}(E_j) - \\mathrm{fl}(E_i))$ and $\\Delta E_{ji}^{\\text{comp}} = \\mathrm{fl}(\\mathrm{fl}(E_i) - \\mathrm{fl}(E_j))$. It is not guaranteed that $\\Delta E_{ij}^{\\text{comp}} = - \\Delta E_{ji}^{\\text{comp}}$. Due to rounding, subtraction is not perfectly antisymmetric.\nMore importantly, the errors described in A and D directly lead to violations of detailed balance. For instance, if a move $i \\to j$ has a small positive energy change $\\Delta E_{ij}$ such that $\\exp(-\\Delta E_{ij}/k_B T)$ rounds to $1$, then $A(i \\to j)=1$. The reverse move $j \\to i$ has energy change $\\Delta E_{ji} = -\\Delta E_{ij} < 0$, so it is a favorable move, and $A(j \\to i)=1$. The ratio of acceptance probabilities is $1/1=1$. The required ratio is $\\exp(-\\Delta E_{ij}/k_B T)$, which is less than $1$. Detailed balance is broken. A system subjected to such an algorithm will not sample from the correct Boltzmann distribution. The premise that the Metropolis rule is symmetric in floating-point arithmetic is false, and therefore the conclusion that detailed balance is preserved is also false.\n\nVerdict: **Incorrect**.\n\n**F. A robust mitigation for errors in $\\Delta E$ near $x\\approx 0$ is to compute $\\Delta E$ via energy-difference formulations that avoid subtracting nearly equal large numbers (for example, incremental or localized updates and compensated summation), thereby reducing catastrophic cancellation and sign errors in $\\Delta E$.**\n\nThis statement proposes a solution to the catastrophic cancellation problem described in D. In many physical models, a Monte Carlo move involves a local change to the system (e.g., moving a single particle). The change in the total potential energy, $\\Delta E$, can often be computed directly by summing only the energy terms that are affected by the move. For example, in a system with pairwise potentials, moving particle $k$ only changes its interaction energy with other particles. So $\\Delta E$ is the difference between the new and old interaction energies of particle $k$ with the rest of the system. This avoids the subtraction of the very large, nearly equal total energies $E_{\\text{new}}$ and $E_{\\text{old}}$. This \"incremental update\" strategy directly computes the small quantity $\\Delta E$ and is a standard, essential technique in simulation software for maintaining numerical accuracy. Compensated summation (like Kahan summation) is another general-purpose technique for improving the accuracy of sums, which can be applied to summing the energy components, although direct calculation of the difference is usually superior when applicable. The statement correctly identifies these methods as robust mitigations.\n\nVerdict: **Correct**.", "answer": "$$\\boxed{ABDF}$$"}]}