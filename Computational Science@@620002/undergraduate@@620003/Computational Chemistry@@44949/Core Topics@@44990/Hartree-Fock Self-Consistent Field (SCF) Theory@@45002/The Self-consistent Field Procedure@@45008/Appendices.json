{"hands_on_practices": [{"introduction": "The \"self-consistent field\" procedure is not just a theoretical concept; it is a practical algorithm at the heart of modern quantum chemistry. This first exercise [@problem_id:2465550] provides a hands-on opportunity to build a minimal, working Restricted Hartree-Fock (RHF) SCF program from the ground up for the HeH$^+$ cation. By manually implementing the key steps—constructing the Fock matrix, solving the generalized eigenvalue problem, and iterating the density matrix—you will gain a deep, operational understanding of how the SCF loop achieves self-consistency.", "problem": "Implement a program that computes the evolution of the molecular orbital coefficients for the diatomic cation helium hydride, denoted HeH$^+$, under a closed-shell restricted Hartree–Fock self-consistent field (SCF) procedure in a minimal basis of two atom-centered basis functions. The atomic orbital basis consists of two functions: index $0$ on helium and index $1$ on hydrogen. The molecular orbitals are expanded as column vectors of coefficients $\\mathbf{c}$ in this atomic orbital basis. All quantities are in atomic units.\n\nGiven the overlap matrix $\\mathbf{S}$, the one-electron core Hamiltonian matrix $\\mathbf{h}$, and the nonzero two-electron repulsion integrals $(\\mu \\nu \\lvert \\lambda \\sigma)$ listed below, the closed-shell Fock matrix $\\mathbf{F}$ for a density matrix $\\mathbf{P}$ is defined by\n$$\nF_{\\mu \\nu} \\;=\\; h_{\\mu \\nu} \\;+\\; \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big].\n$$\nThe occupied molecular orbital coefficient vector $\\mathbf{c}$ (for the lowest-energy orbital) solves the generalized eigenvalue problem\n$$\n\\mathbf{F}\\,\\mathbf{c} \\;=\\; \\epsilon\\,\\mathbf{S}\\,\\mathbf{c}, \\quad \\text{with normalization } \\mathbf{c}^{\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c} \\;=\\; 1,\n$$\nand the closed-shell density matrix is\n$$\n\\mathbf{P} \\;=\\; 2\\,\\mathbf{c}\\,\\mathbf{c}^{\\mathsf{T}}.\n$$\n\nUse the following data, which defines a consistent minimal-basis model for HeH$^+$:\n- Overlap matrix\n$$\n\\mathbf{S} \\;=\\; \\begin{bmatrix} 1 & 0.2 \\\\ 0.2 & 1 \\end{bmatrix}.\n$$\n- One-electron core Hamiltonian\n$$\n\\mathbf{h} \\;=\\; \\begin{bmatrix} -2.0 & -0.2 \\\\ -0.2 & -1.0 \\end{bmatrix}.\n$$\n- Nonzero two-electron repulsion integrals, using chemists’ notation $(\\mu \\nu \\lvert \\lambda \\sigma)$, are:\n$$\n(0\\,0 \\lvert 0\\,0) \\,=\\, 1.0,\\quad\n(1\\,1 \\lvert 1\\,1) \\,=\\, 0.7,\\quad\n(0\\,0 \\lvert 1\\,1) \\,=\\, (1\\,1 \\lvert 0\\,0) \\,=\\, 0.6,\\quad\n(0\\,1 \\lvert 0\\,1) \\,=\\, (0\\,1 \\lvert 1\\,0) \\,=\\, (1\\,0 \\lvert 0\\,1) \\,=\\, (1\\,0 \\lvert 1\\,0) \\,=\\, 0.2,\n$$\nand any integral not obtainable by permuting indices of the above is zero.\n\nFor a given initial occupied-orbital coefficient guess $\\mathbf{c}^{(0)}$ (not necessarily normalized), define the initial density as\n$$\n\\mathbf{P}^{(0)} \\;=\\; 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}},\n$$\nwhere $\\tilde{\\mathbf{c}}^{(0)}$ is $\\mathbf{c}^{(0)}$ normalized to satisfy $\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}} \\mathbf{S}\\,\\tilde{\\mathbf{c}}^{(0)} = 1$. At each subsequent SCF iteration $k \\to k+1$, obtain the new occupied-orbital $\\mathbf{c}^{(k+1)}$ as the normalized lowest-eigenvalue solution of the generalized eigenproblem for $\\mathbf{F}[\\mathbf{P}^{(k)}]$. Impose the phase convention\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} \\;\\leftarrow\\; \\operatorname{sign}\\!\\big( \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\tilde{\\mathbf{c}}^{(k+1)},\n$$\nto ensure continuity of the coefficients, where $\\tilde{\\mathbf{c}}^{(k)}$ denotes the $\\mathbf{S}$-normalized occupied-orbital at iteration $k$. Form the raw updated density $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$. Apply linear mixing with parameter $\\alpha \\in [0,1)$ to define\n$$\n\\mathbf{P}^{(k+1)} \\;=\\; (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} \\;+\\; \\alpha\\,\\mathbf{P}^{(k)}.\n$$\nConvergence is achieved when the elementwise infinity norm satisfies\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} \\;<\\; \\tau,\n$$\nwith threshold $\\tau = 10^{-10}$, or when a hard limit of $200$ iterations is reached.\n\nTask. For each test case below, starting from the given initial guess and mixing parameter, compute and record the sequence of the helium-basis coefficient values $c_0^{(k)}$ of the occupied molecular orbital at iteration $k$, including the initial normalized guess $c_0^{(0)}$ and one value per subsequent iteration until convergence (or until the cap of $200$ iterations is reached). Use the phase convention above at every step. Round each recorded $c_0^{(k)}$ to $6$ decimal places.\n\nTest Suite. Use the following four test cases, each specified by a mixing parameter $\\alpha$ and an initial guess vector $\\mathbf{c}^{(0)}$:\n- Case A (happy path): $\\alpha = 0.0$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 1.0 \\\\ 0.0 \\end{bmatrix}$.\n- Case B (alternative start): $\\alpha = 0.0$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.0 \\\\ 1.0 \\end{bmatrix}$.\n- Case C (damped mixing): $\\alpha = 0.5$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} 0.6 \\\\ 0.8 \\end{bmatrix}$.\n- Case D (edge case, heavy damping): $\\alpha = 0.9$, $\\mathbf{c}^{(0)} = \\begin{bmatrix} -0.7 \\\\ 0.3 \\end{bmatrix}$.\n\nFinal Output Format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a bracketed comma-separated list of the rounded $c_0^{(k)}$ values for that test case, in order A, B, C, D. For example, an output with two hypothetical cases would look like [[0.123456,0.234567],[0.345678,0.456789]]. Your actual program must print the lists for all four cases exactly in this nested format.", "solution": "The problem statement submitted for analysis is a request to implement the closed-shell restricted Hartree-Fock (RHF) self-consistent field (SCF) procedure for the diatomic cation HeH$^+$. A validation of the problem is mandatory.\n\n### Step 1: Extraction of Givens\nThe problem provides the following quantities and definitions in atomic units:\n- Basis set: Minimal, with function $0$ on Helium and function $1$ on Hydrogen.\n- Overlap matrix: $\\mathbf{S} = \\begin{bmatrix} 1 & 0.2 \\\\ 0.2 & 1 \\end{bmatrix}$.\n- Core Hamiltonian matrix: $\\mathbf{h} = \\begin{bmatrix} -2.0 & -0.2 \\\\ -0.2 & -1.0 \\end{bmatrix}$.\n- Nonzero two-electron repulsion integrals (ERIs) in chemists' notation:\n  $(0\\,0 \\lvert 0\\,0) = 1.0$,\n  $(1\\,1 \\lvert 1\\,1) = 0.7$,\n  $(0\\,0 \\lvert 1\\,1) = (1\\,1 \\lvert 0\\,0) = 0.6$,\n  $(0\\,1 \\lvert 0\\,1) = (0\\,1 \\lvert 1\\,0) = (1\\,0 \\lvert 0\\,1) = (1\\,0 \\lvert 1\\,0) = 0.2$.\n- Fock matrix: $F_{\\mu \\nu} = h_{\\mu \\nu} + \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big]$.\n- Density matrix: $\\mathbf{P} = 2\\,\\mathbf{c}\\,\\mathbf{c}^{\\mathsf{T}}$ for a single occupied orbital.\n- Roothaan-Hall equations: $\\mathbf{F}\\,\\mathbf{c} = \\epsilon\\,\\mathbf{S}\\,\\mathbf{c}$, with normalization $\\mathbf{c}^{\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c} = 1$.\n- SCF iterative procedure:\n  1. Initial guess $\\mathbf{c}^{(0)}$ is $\\mathbf{S}$-normalized to $\\tilde{\\mathbf{c}}^{(0)}$ to form $\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$.\n  2. For $k \\ge 0$, solve for the lowest-energy eigenvector of $\\mathbf{F}[\\mathbf{P}^{(k)}]$, denoted $\\tilde{\\mathbf{c}}^{(k+1)}$.\n  3. Apply phase convention: $\\tilde{\\mathbf{c}}^{(k+1)} \\leftarrow \\operatorname{sign}(\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)})\\,\\tilde{\\mathbf{c}}^{(k+1)}$.\n  4. Form raw density: $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)} \\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$.\n  5. Apply linear mixing: $\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}$.\n- Convergence criterion: $\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} < \\tau = 10^{-10}$.\n- Iteration limit: $200$.\n- Test cases: Four pairs of $(\\alpha, \\mathbf{c}^{(0)})$ are provided.\n- Required output: A sequence of the coefficient $c_0$ for the occupied orbital at each iteration, rounded to $6$ decimal places.\n\n### Step 2: Validation of Givens\nThe problem is evaluated against the required criteria.\n1.  **Scientific Grounding**: The problem describes the standard RHF-SCF method, a cornerstone of computational quantum chemistry. The equations for the Fock matrix, density matrix, and the Roothaan-Hall system are correct representations of this theory for a closed-shell two-electron system.\n2.  **Well-Posedness**: The problem defines a complete iterative algorithm, including initial conditions, a precise update rule for each step, a clear phase convention to ensure uniqueness of eigenvectors, and a well-defined convergence criterion. The use of linear mixing (damping) is a standard technique for ensuring or accelerating convergence.\n3.  **Objectivity**: The problem is stated in precise mathematical and algorithmic terms, free from any subjectivity.\n4.  **Consistency**: All provided data and equations are self-contained and consistent. The definition of the Fock matrix, while using a slightly uncommon notation for the exchange term $(\\mu \\sigma \\lvert \\lambda \\nu)$, proves to be equivalent to the standard form $(\\mu \\lambda \\lvert \\nu \\sigma)$ for the given set of integrals and ensures the Fock matrix remains symmetric, which is a physical requirement. Thus, the formulation is internally consistent and physically sound.\n5.  **Completeness**: The problem provides all necessary numerical data ($\\mathbf{S}$, $\\mathbf{h}$, ERI values), algorithmic parameters ($\\alpha$, $\\tau$, iteration limit), and initial states to perform the calculation for all test cases.\n\n### Step 3: Verdict\nThe problem is **valid**. It is a well-defined, scientifically sound, and self-contained computational task. Proceeding with the solution is justified.\n\n### Solution\nThe objective is to solve the Roothaan-Hall equations for the HeH$^+$ cation within the specified minimal basis set using the self-consistent field method. HeH$^+$ is a two-electron system, so in a ground state, these two electrons occupy the molecular orbital (MO) with the lowest energy.\n\nThe molecular orbitals $\\psi_i$ are expressed as a linear combination of atomic orbitals (LCAO) $\\phi_\\mu$, $\\psi_i = \\sum_{\\mu} c_{\\mu i} \\phi_\\mu$. For our two-basis-function system ($\\mu \\in \\{0, 1\\}$), the occupied orbital coefficients form a vector $\\mathbf{c} = \\begin{bmatrix} c_0 \\\\ c_1 \\end{bmatrix}$. The SCF procedure iteratively refines these coefficients until the electronic field they produce is consistent with the field that generates them.\n\nThe algorithm proceeds as follows:\n\n**1. Initialization**\nFirst, we construct the four-dimensional tensor of two-electron repulsion integrals, $\\text{ERI}_{\\mu\\nu\\lambda\\sigma} = (\\mu \\nu \\lvert \\lambda \\sigma)$. This tensor is populated using the provided non-zero values and their inherent permutational symmetries: $(\\mu\\nu|\\lambda\\sigma) = (\\nu\\mu|\\lambda\\sigma) = (\\mu\\nu|\\sigma\\lambda) = (\\lambda\\sigma|\\mu\\nu)$. All other elements are zero.\n\nFor a given test case, starting with an initial guess vector $\\mathbf{c}^{(0)}$, we compute its $\\mathbf{S}$-norm: $N = \\sqrt{\\mathbf{c}^{(0)\\mathsf{T}} \\mathbf{S}\\, \\mathbf{c}^{(0)}}$. The normalized initial coefficient vector is $\\tilde{\\mathbf{c}}^{(0)} = \\mathbf{c}^{(0)} / N$. The initial helium-basis coefficient, $c_0^{(0)} = \\tilde{c}_0^{(0)}$, is the first value recorded. From this, the initial density matrix is formed: $\\mathbf{P}^{(0)} = 2\\,\\tilde{\\mathbf{c}}^{(0)}\\,\\tilde{\\mathbf{c}}^{(0)\\mathsf{T}}$. The factor of $2$ accounts for the two electrons in the single occupied spatial orbital.\n\n**2. SCF Iteration Cycle**\nThe iterative process begins, indexed by $k=0, 1, 2, \\dots$. At each iteration $k$, we have the density matrix $\\mathbf{P}^{(k)}$ and the coefficient vector from the previous step, $\\tilde{\\mathbf{c}}^{(k)}$.\n\n_a. Fock Matrix Construction_\nThe Fock matrix $\\mathbf{F}^{(k)}$ is constructed as the sum of the one-electron core Hamiltonian $\\mathbf{h}$ and the two-electron term $\\mathbf{G}^{(k)}$: $\\mathbf{F}^{(k)} = \\mathbf{h} + \\mathbf{G}^{(k)}$. The matrix $\\mathbf{G}^{(k)}$ accounts for the average electron-electron repulsion and is computed using the density matrix $\\mathbf{P}^{(k)}$ and the ERI tensor:\n$$\nG_{\\mu \\nu}^{(k)} \\;=\\; \\sum_{\\lambda,\\sigma} P^{(k)}_{\\lambda \\sigma}\\,\\Big[\\,(\\mu \\nu \\lvert \\lambda \\sigma)\\;-\\;\\tfrac{1}{2}\\,(\\mu \\sigma \\lvert \\lambda \\nu)\\,\\Big]\n$$\nThis operation can be efficiently implemented using tensor contractions, for instance, with `numpy.einsum`.\n\n_b. Solving the Roothaan-Hall Equations_\nThe core of the SCF iteration is solving the generalized eigenvalue problem $\\mathbf{F}^{(k)}\\mathbf{c} = \\epsilon \\mathbf{S} \\mathbf{c}$. Since both $\\mathbf{F}^{(k)}$ and $\\mathbf{S}$ are symmetric matrices, and $\\mathbf{S}$ is positive-definite, this can be reliably solved using numerical libraries (e.g., `scipy.linalg.eigh`). The solution yields a set of eigenvalues (orbital energies) $\\epsilon_i$ and corresponding eigenvectors (MO coefficients) $\\mathbf{c}_i$. We select the eigenvector corresponding to the lowest eigenvalue, which represents the occupied molecular orbital. Let us call this eigenvector $\\mathbf{c}^{(k+1)}_{\\text{raw}}$. The `scipy.linalg.eigh` function conveniently returns eigenvectors that are already normalized such that $\\mathbf{c}^{\\mathsf{T}}\\mathbf{S}\\mathbf{c} = 1$.\n\n_c. Phase Correction_\nEigenvectors are unique only up to a sign. To ensure a continuous evolution of the coefficients, we enforce a consistent phase relative to the previous iteration's vector $\\tilde{\\mathbf{c}}^{(k)}$:\n$$\n\\tilde{\\mathbf{c}}^{(k+1)} = \\operatorname{sign}\\big( (\\mathbf{c}^{(k+1)}_{\\text{raw}})^{\\mathsf{T}} \\mathbf{S}\\, \\tilde{\\mathbf{c}}^{(k)} \\big)\\,\\mathbf{c}^{(k+1)}_{\\text{raw}}\n$$\nIf the overlap of the new vector with the old one (in the $\\mathbf{S}$ metric) is negative, the sign of the new vector is flipped. The helium-basis component of this phase-corrected vector, $c_0^{(k+1)} = \\tilde{c}_0^{(k+1)}$, is recorded.\n\n_d. Density Matrix Update and Mixing_\nA new \"raw\" density matrix is computed from the updated coefficients: $\\mathbf{P}^{(k+1),\\mathrm{raw}} = 2\\,\\tilde{\\mathbf{c}}^{(k+1)}\\,\\tilde{\\mathbf{c}}^{(k+1)\\mathsf{T}}$. To improve convergence stability, this raw density is mixed with the density from the previous iteration using the mixing parameter $\\alpha$:\n$$\n\\mathbf{P}^{(k+1)} = (1-\\alpha)\\,\\mathbf{P}^{(k+1),\\mathrm{raw}} + \\alpha\\,\\mathbf{P}^{(k)}\n$$\n\n**3. Convergence Check**\nThe iteration is deemed converged if the maximum absolute element-wise difference between the new and old density matrices falls below a threshold $\\tau=10^{-10}$:\n$$\n\\|\\mathbf{P}^{(k+1)} - \\mathbf{P}^{(k)}\\|_{\\infty} = \\max_{i,j} |P_{ij}^{(k+1)} - P_{ij}^{(k)}| < \\tau\n$$\nIf this condition is met, the SCF loop terminates. Otherwise, the process repeats from step 2a with the new density matrix $\\mathbf{P}^{(k+1)}$. If convergence is not achieved within $200$ iterations, the process is halted.\n\nThis entire procedure is applied to each of the four test cases specified in the problem statement to generate the required sequences of the coefficient $c_0$.", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Implements the RHF-SCF procedure for HeH+ in a minimal basis\n    and computes the evolution of the MO coefficients for four test cases.\n    \"\"\"\n    \n    # --- Problem Data ---\n    S = np.array([[1.0, 0.2],\n                  [0.2, 1.0]], dtype=np.float64)\n    \n    h = np.array([[-2.0, -0.2],\n                  [-0.2, -1.0]], dtype=np.float64)\n\n    # Two-electron repulsion integral (ERI) tensor in chemists' notation\n    # ERI[mu, nu, lam, sig] = (mu nu | lam sig)\n    ERI = np.zeros((2, 2, 2, 2), dtype=np.float64)\n    ERI[0, 0, 0, 0] = 1.0\n    ERI[1, 1, 1, 1] = 0.7\n    ERI[0, 0, 1, 1] = 0.6\n    ERI[1, 1, 0, 0] = 0.6\n    # From (01|01) = (01|10) = (10|01) = (10|10) = 0.2\n    ERI[0, 1, 0, 1] = 0.2\n    ERI[1, 0, 0, 1] = 0.2\n    ERI[0, 1, 1, 0] = 0.2\n    ERI[1, 0, 1, 0] = 0.2\n    \n    # SCF parameters\n    convergence_threshold = 1e-10\n    max_iterations = 200\n\n    # Test suite\n    test_cases = [\n        {'alpha': 0.0, 'c_initial': np.array([1.0, 0.0])},  # Case A\n        {'alpha': 0.0, 'c_initial': np.array([0.0, 1.0])},  # Case B\n        {'alpha': 0.5, 'c_initial': np.array([0.6, 0.8])},  # Case C\n        {'alpha': 0.9, 'c_initial': np.array([-0.7, 0.3])}, # Case D\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha = case['alpha']\n        c_unnorm = case['c_initial']\n        c0_sequence = []\n\n        # --- Step 0: Initialization ---\n        # S-normalize the initial guess vector\n        norm_sq = c_unnorm.T @ S @ c_unnorm\n        c_k = c_unnorm / np.sqrt(norm_sq)\n        \n        # Record the initial c0 value (rounded)\n        c0_sequence.append(c_k[0])\n\n        # Form initial density matrix\n        P_k = 2.0 * np.outer(c_k, c_k)\n\n        # --- SCF Iteration Loop ---\n        for i in range(max_iterations):\n            # Store old density for convergence check and mixing\n            P_old = P_k\n\n            # --- Step 1: Build Fock Matrix ---\n            # G_munu = sum_ls P_ls * [(munu|ls) - 0.5 * (mus|ln)]\n            # J[mu,nu] = sum_ls P_ls * (munu|ls)\n            J = np.einsum('ls,mnls->mn', P_old, ERI)\n            # K[mu,nu] = sum_ls P_ls * (mus|ln)\n            K = np.einsum('ls,msln->mn', P_old, ERI)\n            \n            G = J - 0.5 * K\n            F = h + G\n\n            # --- Step 2: Solve Generalized Eigenvalue Problem ---\n            # F c = e S c\n            # eigh returns S-normalized eigenvectors sorted by eigenvalue\n            eigvals, eigvecs = scipy.linalg.eigh(F, S)\n            \n            # Select eigenvector for the lowest energy orbital\n            c_k_plus_1 = eigvecs[:, 0]\n\n            # --- Step 3: Phase Convention ---\n            # Enforce sign consistency with the previous iteration's coefficients\n            overlap = c_k_plus_1.T @ S @ c_k\n            if overlap < 0.0:\n                c_k_plus_1 *= -1.0\n            \n            # Record new c0 value\n            c0_sequence.append(c_k_plus_1[0])\n\n            # Update orbital coefficients for next phase check\n            c_k = c_k_plus_1\n\n            # --- Step 4: Update Density Matrix with Mixing ---\n            P_raw = 2.0 * np.outer(c_k, c_k)\n            P_k = (1.0 - alpha) * P_raw + alpha * P_old\n\n            # --- Step 5: Check for Convergence ---\n            max_diff = np.max(np.abs(P_k - P_old))\n            if max_diff < convergence_threshold:\n                break\n        \n        # Round all collected coefficients to 6 decimal places for final output\n        all_results.append([round(val, 6) for val in c0_sequence])\n\n    # Format the final output string as specified\n    formatted_cases = []\n    for case_results in all_results:\n        # Format each number to 6 decimal places.\n        formatted_nums = [f\"{val:.6f}\" for val in case_results]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    final_output = f\"[{','.join(formatted_cases)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2465550"}, {"introduction": "With a converged SCF solution, we gain access to the molecular orbitals (MOs) that describe electron behavior within the molecule. This practice [@problem_id:2465579] moves from implementation to interpretation, using a linear chain of hydrogen atoms as a model system to connect quantitative results with qualitative chemical concepts. You will analyze the nodal patterns of the converged MOs, reinforcing the link between orbital energy, kinetic energy, and symmetry, and observe how these patterns respond to changes in the underlying molecular structure.", "problem": "Consider a linear chain of four hydrogen atoms modeled in a minimal, orthonormal atomic orbital basis $\\{|\\chi_1\\rangle,|\\chi_2\\rangle,|\\chi_3\\rangle,|\\chi_4\\rangle\\}$, where $|\\chi_i\\rangle$ is centered on atom $i$ arranged in order along the chain. Assume one spatial orbital per site, two spin states per spatial orbital, and a total of $4$ electrons (closed-shell, spin-restricted). Use a one-band Hubbard-type electronic structure model with the following components:\n\n- One-electron terms given by site energies $\\varepsilon_i$ (diagonal) and nearest-neighbor hopping $t_{i,i+1}$ (off-diagonal between $i$ and $i+1$), with all energies expressed in electronvolts (eV).\n- On-site electron repulsion parameters $U_i$ (in eV).\n- The Self-Consistent Field (SCF) problem is defined by the restricted Hartree–Fock mean-field fixed point in this basis. Let $D$ denote the spin-summed one-particle density matrix in the site basis, and $F(D)$ the corresponding Fock matrix. In the restricted Hartree–Fock approximation for the on-site-interaction Hubbard model, the Fock matrix is tridiagonal with\n  - $F_{ii}(D)=\\varepsilon_i + U_i\\,\\frac{n_i}{2}$ where $n_i=D_{ii}$ is the total site population,\n  - $F_{i,i+1}=F_{i+1,i}=t_{i,i+1}$ for nearest neighbors,\n  - all other matrix elements equal to $0$.\nThe spin-summed density matrix at self-consistency is $D = 2\\sum_{p\\in\\text{occ}} \\mathbf{c}_p \\mathbf{c}_p^\\top$, where $\\mathbf{c}_p$ are the orthonormal eigenvectors of $F(D)$ associated with the $2$ lowest eigenvalues (each doubly occupied), and the superscript $\\top$ denotes transpose.\n\nAfter convergence, the four canonical molecular orbitals are the four real normalized eigenvectors $\\mathbf{c}_1,\\mathbf{c}_2,\\mathbf{c}_3,\\mathbf{c}_4$ of the converged $F$, ordered by increasing orbital energy. For each molecular orbital, define the node count as the number of sign changes between consecutive coefficients along the chain:\nGiven $\\mathbf{c}=(c_1,c_2,c_3,c_4)$, its node count is the number of indices $i\\in\\{1,2,3\\}$ such that $c_i c_{i+1}\\le 0$. The overall phase of $\\mathbf{c}$ is arbitrary and does not affect the node count.\n\nTask: For each of the parameter sets below, compute the converged restricted Hartree–Fock solution as defined above and report, for the four canonical molecular orbitals in order of increasing orbital energy, the list of their node counts.\n\nAll energies must be taken in electronvolts (eV). The required outputs are integers (node counts), which are unitless.\n\nTest suite (each case specifies $(\\varepsilon_1,\\varepsilon_2,\\varepsilon_3,\\varepsilon_4)$, $(t_{12},t_{23},t_{34})$, and $(U_1,U_2,U_3,U_4)$):\n- Case A (symmetric interacting chain): $(0,0,0,0)$, $(-1.0,-1.0,-1.0)$, $(2.0,2.0,2.0,2.0)$.\n- Case B (symmetric non-interacting chain): $(0,0,0,0)$, $(-1.0,-1.0,-1.0)$, $(0.0,0.0,0.0,0.0)$.\n- Case C (asymmetric site energy at one end): $(0.5,0,0,0)$, $(-1.0,-1.0,-1.0)$, $(2.0,2.0,2.0,2.0)$.\n- Case D (non-uniform bonding): $(0,0,0,0)$, $(-1.5,-0.5,-1.0)$, $(2.0,2.0,2.0,2.0)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to one test case and is itself a list of four integers giving the node counts for the four converged canonical molecular orbitals in order of increasing orbital energy. For example, an output with two hypothetical cases would look like [[0,1,2,3],[0,1,1,2]].", "solution": "The problem presented is a valid and well-posed application of the self-consistent field (SCF) method within the restricted Hartree-Fock (RHF) approximation. It concerns a simplified but scientifically sound model of a linear chain of four hydrogen atoms, described by a one-band Hubbard-type Hamiltonian. All parameters, definitions, and objectives are clearly and objectively defined, allowing for a direct numerical solution.\n\nThe task is to solve the RHF equations for a $4$-site system with $4$ electrons (a closed-shell case). This involves finding a self-consistent solution for the one-particle density matrix, $D$, and the corresponding Fock matrix, $F(D)$. The solution will be obtained by implementing an iterative SCF procedure.\n\nLet the orthonormal atomic orbital basis be $\\{|\\chi_1\\rangle, |\\chi_2\\rangle, |\\chi_3\\rangle, |\\chi_4\\rangle\\}$. In this basis, the Fock matrix, $F$, and the density matrix, $D$, are represented as $4 \\times 4$ matrices.\n\nThe Fock matrix, $F$, is defined by its elements:\n$$\nF_{ij} = H^{\\text{core}}_{ij} + G_{ij}(D)\n$$\nwhere $H^{\\text{core}}$ contains the one-electron terms (site energies and hopping) and $G(D)$ contains the two-electron terms (electron-electron repulsion) in a mean-field sense.\n\nAccording to the problem statement:\n- The diagonal elements of the Fock matrix are given by $F_{ii}(D) = \\varepsilon_i + U_i \\frac{n_i}{2}$, where $\\varepsilon_i$ is the site energy, $U_i$ is the on-site repulsion parameter, and $n_i = D_{ii}$ is the electron population on site $i$.\n- The off-diagonal elements for nearest neighbors are $F_{i,i+1} = F_{i+1,i} = t_{i,i+1}$, where $t_{i,i+1}$ is the hopping integral.\n- All other off-diagonal elements are zero.\n\nThis defines a tridiagonal Fock matrix:\n$$\nF(D) = \\begin{pmatrix}\n\\varepsilon_1 + \\frac{U_1}{2}D_{11} & t_{12} & 0 & 0 \\\\\nt_{12} & \\varepsilon_2 + \\frac{U_2}{2}D_{22} & t_{23} & 0 \\\\\n0 & t_{23} & \\varepsilon_3 + \\frac{U_3}{2}D_{33} & t_{34} \\\\\n0 & 0 & t_{34} & \\varepsilon_4 + \\frac{U_4}{2}D_{44}\n\\end{pmatrix}\n$$\n\nThe SCF procedure is an iterative process to find a density matrix $D$ such that it is consistent with the Fock matrix it generates. The steps are as follows:\n\n1.  **Initialization**: An initial guess for the density matrix $D^{(0)}$ is required. A common and effective choice is to start from the solution of the non-interacting problem, which is equivalent to using the core Hamiltonian $H^{\\text{core}}$ (the Fock matrix with all $U_i = 0$) as the initial Fock matrix, $F^{(0)}$.\n\n2.  **Iterative Cycle**: For each iteration $k = 0, 1, 2, \\dots$:\n    a.  **Solve the Roothaan-Hall Equations**: Solve the eigenvalue problem for the current Fock matrix $F^{(k)}$:\n        $$\n        F^{(k)} \\mathbf{c}_p = \\epsilon_p \\mathbf{c}_p\n        $$\n        Since the basis is orthonormal, this is a standard matrix diagonalization. This yields four real eigenvalues $\\epsilon_p$ (the orbital energies) and four corresponding orthonormal eigenvectors $\\mathbf{c}_p$ (the molecular orbital coefficients). The eigenvectors are sorted in order of increasing eigenvalue: $\\epsilon_1 \\le \\epsilon_2 \\le \\epsilon_3 \\le \\epsilon_4$.\n\n    b.  **Construct New Density Matrix**: With $4$ electrons, the two lowest-energy spatial orbitals, $\\mathbf{c}_1$ and $\\mathbf{c}_2$, are doubly occupied. The new spin-summed density matrix, $D^{(\\text{new})}$, is constructed from these occupied orbitals:\n        $$\n        D^{(\\text{new})} = 2 \\sum_{p=1}^{2} \\mathbf{c}_p \\mathbf{c}_p^\\top\n        $$\n        In matrix form, if $C_{\\text{occ}}$ is the $4 \\times 2$ matrix whose columns are $\\mathbf{c}_1$ and $\\mathbf{c}_2$, then $D^{(\\text{new})} = 2 C_{\\text{occ}} C_{\\text{occ}}^\\top$.\n\n    c.  **Check for Convergence**: The process is converged when the density matrix no longer changes significantly between iterations. A convergence criterion is applied, such as checking if the maximum absolute difference between elements of the new and old density matrices is below a small tolerance, $\\delta$:\n        $$\n        \\max_{i,j} |D^{(\\text{new})}_{ij} - D^{(k)}_{ij}| < \\delta\n        $$\n        If converged, the loop terminates.\n\n    d.  **Prepare for Next Iteration**: If not converged, a new density matrix $D^{(k+1)}$ is formed. To prevent oscillations and improve convergence, simple mixing is often employed:\n        $$\n        D^{(k+1)} = \\alpha D^{(\\text{new})} + (1-\\alpha) D^{(k)}\n        $$\n        where $\\alpha$ is a mixing parameter ($0 < \\alpha \\le 1$). A new Fock matrix $F^{(k+1)}$ is then constructed using the diagonal elements of $D^{(k+1)}$:\n        $$\n        F^{(k+1)}_{ii} = \\varepsilon_i + \\frac{U_i}{2} D^{(k+1)}_{ii}\n        $$\n\n3.  **Post-SCF Calculation**: Once the SCF procedure has converged to a final density matrix $D_{\\text{conv}}$ and Fock matrix $F_{\\text{conv}}$, the final canonical molecular orbitals $\\mathbf{c}_1, \\mathbf{c}_2, \\mathbf{c}_3, \\mathbf{c}_4$ are the eigenvectors of $F_{\\text{conv}}$, ordered by their corresponding energy eigenvalues. For each eigenvector $\\mathbf{c}_p = (c_{1p}, c_{2p}, c_{3p}, c_{4p})^\\top$, the node count is calculated. The node count is the number of sign changes between consecutive coefficients, defined as the number of indices $i \\in \\{1, 2, 3\\}$ for which the condition $c_{ip} c_{i+1,p} \\le 0$ holds. This procedure is applied to each of the four test cases.\n\nFor the non-interacting case (Case B, where all $U_i=0$), the Fock matrix is simply the core Hamiltonian and does not depend on the density. The SCF procedure converges in a single step. For the interacting cases (A, C, D), multiple iterations are generally required to reach self-consistency. The following implementation carries out this algorithm for each specified parameter set.", "answer": "```python\nimport numpy as np\n\ndef compute_node_count(vector: np.ndarray) -> int:\n    \"\"\"\n    Computes the node count of a vector representing a molecular orbital.\n    A node is a sign change between consecutive coefficients.\n    The condition c_i * c_{i+1} <= 0 includes cases where a coefficient is zero.\n    \"\"\"\n    count = 0\n    for i in range(len(vector) - 1):\n        if vector[i] * vector[i + 1] <= 0:\n            count += 1\n    return count\n\ndef run_scf_procedure(eps: np.ndarray, t: np.ndarray, U: np.ndarray) -> list[int]:\n    \"\"\"\n    Performs the self-consistent field (SCF) calculation for a 4-site Hubbard model.\n\n    Args:\n        eps: Array of site energies (4 elements).\n        t: Array of nearest-neighbor hopping integrals (3 elements).\n        U: Array of on-site repulsion parameters (4 elements).\n\n    Returns:\n        A list of four integers representing the node counts of the converged\n        canonical molecular orbitals, ordered by increasing energy.\n    \"\"\"\n    num_sites = 4\n    num_electrons = 4\n    num_occupied_orbitals = num_electrons // 2\n    \n    # Convergence parameters\n    tolerance = 1e-9\n    max_iterations = 200\n    mixing_alpha = 0.7  # Damping factor to aid convergence\n\n    # 1. Initialization: Build the core Hamiltonian (U=0 Fock matrix)\n    fock_matrix = np.diag(eps)\n    for i in range(num_sites - 1):\n        fock_matrix[i, i + 1] = fock_matrix[i + 1, i] = t[i]\n    \n    density_matrix = np.zeros((num_sites, num_sites))\n\n    for i in range(max_iterations):\n        # 2a. Solve eigenvalue problem for the current Fock matrix\n        # np.linalg.eigh returns eigenvalues in ascending order and corresponding eigenvectors\n        # as columns of the matrix.\n        orbital_energies, orbital_coeffs = np.linalg.eigh(fock_matrix)\n\n        # 2b. Construct new density matrix from occupied orbitals\n        occupied_coeffs = orbital_coeffs[:, :num_occupied_orbitals]\n        new_density_matrix = 2.0 * (occupied_coeffs @ occupied_coeffs.T)\n\n        # 2c. Check for convergence\n        error = np.max(np.abs(new_density_matrix - density_matrix))\n        if error < tolerance:\n            break\n\n        # 2d. Prepare for next iteration: mix density matrices\n        density_matrix = mixing_alpha * new_density_matrix + (1.0 - mixing_alpha) * density_matrix\n        \n        # Update Fock matrix with the new density\n        fock_diag = eps + (U * np.diag(density_matrix)) / 2.0\n        np.fill_diagonal(fock_matrix, fock_diag)\n    \n    # 3. Post-SCF: Calculate node counts from the converged orbitals\n    # Re-diagonalize the final Fock matrix to get final canonical orbitals\n    final_energies, final_orbitals = np.linalg.eigh(fock_matrix)\n\n    node_counts = []\n    for i in range(num_sites):\n        orbital_vector = final_orbitals[:, i]\n        nodes = compute_node_count(orbital_vector)\n        node_counts.append(nodes)\n        \n    return node_counts\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the solution for each, printing the final result.\n    \"\"\"\n    # Test cases: (eps_array, t_array, U_array)\n    test_cases = [\n        # Case A: symmetric interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case B: symmetric non-interacting chain\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([0.0, 0.0, 0.0, 0.0])),\n        # Case C: asymmetric site energy at one end\n        (np.array([0.5, 0.0, 0.0, 0.0]), np.array([-1.0, -1.0, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n        # Case D: non-uniform bonding\n        (np.array([0.0, 0.0, 0.0, 0.0]), np.array([-1.5, -0.5, -1.0]), np.array([2.0, 2.0, 2.0, 2.0])),\n    ]\n\n    results = []\n    for case_params in test_cases:\n        eps_vals, t_vals, U_vals = case_params\n        result = run_scf_procedure(eps_vals, t_vals, U_vals)\n        results.append(str(result))\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2465579"}, {"introduction": "The non-linear nature of the Roothaan-Hall equations means that the SCF procedure is not guaranteed to find the global energy minimum; multiple self-consistent solutions can exist. This practice [@problem_id:2465576] explores this crucial feature using a simplified model of the Beryllium atom, which exhibits bistability between its ground ($1s^2 2s^2$) and an excited ($1s^2 2p^2$) electronic configuration. You will investigate how the choice of the initial guess determines which of these stable fixed points the iteration converges to, highlighting the importance of a chemically reasonable starting point for any SCF calculation.", "problem": "Consider a minimal, spherically symmetric, restricted Hartree–Fock (HF) model of the valence shell of a beryllium atom, in which the $1s$ core ($1s^2$) is frozen and its effect is absorbed into effective one-electron matrix elements. The basis set consists of two orthonormal atomic orbitals: $2s$ and a single $2p$ function (e.g., $2p_z$). Let the Self-Consistent Field (SCF) Fock matrix in this atomic-orbital basis be denoted by $F_{\\mu \\nu}$ with $\\mu,\\nu \\in \\{s,p\\}$, and let the one-electron Hamiltonian be $h_{\\mu \\nu}$. The closed-shell density matrix in this basis is $P_{\\lambda \\sigma}$, with occupations $n_s$ and $n_p$ for $2s$ and $2p$, respectively, constrained by $n_s + n_p = 2$ and $0 \\le n_s, n_p \\le 2$. Assume $h_{sp} = h_{ps} = 0$ and all two-electron integrals are given in the “chemist’s” notation $(\\mu \\nu | \\lambda \\sigma)$. The restricted Hartree–Fock Fock matrix is defined by\n$$\nF_{\\mu \\nu} \\;=\\; h_{\\mu \\nu} \\;+\\; \\sum_{\\lambda,\\sigma} P_{\\lambda \\sigma} \\,\\Big[(\\mu \\nu \\mid \\lambda \\sigma) \\;-\\; \\tfrac{1}{2}(\\mu \\lambda \\mid \\nu \\sigma)\\Big] \\, .\n$$\n\nIn this atomic model with diagonal density $P_{ss} = n_s$, $P_{pp} = n_p$, $P_{sp}=P_{ps}=0$, and by symmetry of the chosen basis, take $F_{sp}=F_{ps}=0$ for all admissible $(n_s,n_p)$. The diagonal Fock elements then reduce to\n$$\nF_{ss} \\;=\\; h_{ss} \\;+\\; n_s\\Big[\\tfrac{1}{2}(ss\\mid ss)\\Big] \\;+\\; n_p\\Big[(ss\\mid pp) \\;-\\; \\tfrac{1}{2}(sp\\mid ps)\\Big],\n$$\n$$\nF_{pp} \\;=\\; h_{pp} \\;+\\; n_s\\Big[(ss\\mid pp) \\;-\\; \\tfrac{1}{2}(sp\\mid ps)\\Big] \\;+\\; n_p\\Big[\\tfrac{1}{2}(pp\\mid pp)\\Big].\n$$\n\nAll quantities are in atomic units (Hartree). Use the following fixed parameters:\n- $h_{ss} = -0.85$, $h_{pp} = -0.75$,\n- $(ss\\mid ss) = 0.70$, $(pp\\mid pp) = 0.60$,\n- $(ss\\mid pp) = 0.65$, $(sp\\mid ps) = 0.20$.\n\nA state $(n_s,n_p)$ is a fixed point if, when the two electrons are placed in the lower of $F_{ss}$ and $F_{pp}$ (closed shell), the implied occupations are unchanged. In the event $F_{ss} = F_{pp}$ exactly, adopt the tie-break convention that the electrons occupy $2s$ (i.e., set $n_s = 2$, $n_p = 0$).\n\nYour task is to determine, for each initial guess $(n_s^{(0)}, n_p^{(0)})$ in the test suite below, which fixed point is reached under repeated reapplication of the occupation rule implied by comparing $F_{ss}$ and $F_{pp}$. Report the final state as an integer: output $0$ if the fixed point corresponds to $1s^2 2s^2$ (i.e., $n_s = 2$, $n_p = 0$) and output $1$ if it corresponds to $1s^2 2p^2$ (i.e., $n_s = 0$, $n_p = 2$).\n\nTest suite (each pair satisfies $n_s^{(0)} + n_p^{(0)} = 2$):\n- Case A: $(n_s^{(0)}, n_p^{(0)}) = (2.0, 0.0)$,\n- Case B: $(n_s^{(0)}, n_p^{(0)}) = (0.0, 2.0)$,\n- Case C: $(n_s^{(0)}, n_p^{(0)}) = (1.0, 1.0)$,\n- Case D (near-boundary): $(n_s^{(0)}, n_p^{(0)}) = (1.999, 0.001)$.\n\nFinal output format: Your program should produce a single line of output containing the four integer results for Cases A–D, in order, as a comma-separated list enclosed in square brackets (e.g., [0,1,0,0]).", "solution": "The problem statement is a valid exercise in computational chemistry concerning the Self-Consistent Field (SCF) procedure. It is scientifically grounded, well-posed, and objective. It describes a simplified, discrete iterative process for determining electron occupations in a minimal basis set model of the beryllium atom. We may therefore proceed with a rigorous solution.\n\nThe problem asks for the determination of fixed points of an iterative occupation rule. The state of the system is defined by the occupation numbers $(n_s, n_p)$ of the $2s$ and $2p$ orbitals, subject to the constraint $n_s + n_p = 2$. An iteration begins with a state $(n_s^{(k)}, n_p^{(k)})$, where the superscript $k$ denotes the iteration number. Using these occupations, the diagonal elements of the Fock matrix, $F_{ss}$ and $F_{pp}$, are computed. A new state $(n_s^{(k+1)}, n_p^{(k+1)})$ is then determined by applying the Aufbau principle to these orbital energies: the two valence electrons are placed in the orbital with the lower energy.\n\nThe equations for the Fock matrix elements are given as:\n$$F_{ss} \\;=\\; h_{ss} \\;+\\; n_s\\Big[\\tfrac{1}{2}(ss\\mid ss)\\Big] \\;+\\; n_p\\Big[(ss\\mid pp) \\;-\\; \\tfrac{1}{2}(sp\\mid ps)\\Big]$$\n$$F_{pp} \\;=\\; h_{pp} \\;+\\; n_s\\Big[(ss\\mid pp) \\;-\\; \\tfrac{1}{2}(sp\\mid ps)\\Big] \\;+\\; n_p\\Big[\\tfrac{1}{2}(pp\\mid pp)\\Big]$$\nGiven the constraint $n_p = 2 - n_s$, we can express $F_{ss}$ and $F_{pp}$ as functions of $n_s$ alone. Let us substitute the provided parameters: $h_{ss} = -0.85$, $h_{pp} = -0.75$, $(ss\\mid ss) = 0.70$, $(pp\\mid pp) = 0.60$, $(ss\\mid pp) = 0.65$, and $(sp\\mid ps) = 0.20$. All quantities are in atomic units.\n\nFirst, we compute the constant coefficients for the two-electron terms:\n$$ \\tfrac{1}{2}(ss\\mid ss) = \\tfrac{1}{2}(0.70) = 0.35 $$\n$$ \\tfrac{1}{2}(pp\\mid pp) = \\tfrac{1}{2}(0.60) = 0.30 $$\n$$ (ss\\mid pp) - \\tfrac{1}{2}(sp\\mid ps) = 0.65 - \\tfrac{1}{2}(0.20) = 0.65 - 0.10 = 0.55 $$\n\nSubstituting these values and $n_p = 2 - n_s$ into the Fock matrix expressions yields:\n$$ F_{ss}(n_s) = -0.85 + 0.35 n_s + 0.55 (2 - n_s) = -0.85 + 0.35 n_s + 1.10 - 0.55 n_s $$\n$$ F_{ss}(n_s) = 0.25 - 0.20 n_s $$\n\n$$ F_{pp}(n_s) = -0.75 + 0.55 n_s + 0.30 (2 - n_s) = -0.75 + 0.55 n_s + 0.60 - 0.30 n_s $$\n$$ F_{pp}(n_s) = -0.15 + 0.25 n_s $$\n\nThe iterative update rule is based on comparing $F_{ss}$ and $F_{pp}$:\n- If $F_{ss} < F_{pp}$, the next state is $(n_s, n_p) = (2, 0)$.\n- If $F_{pp} < F_{ss}$, the next state is $(n_s, n_p) = (0, 2)$.\n- If $F_{ss} = F_{pp}$, the tie-break rule specifies the next state as $(n_s, n_p) = (2, 0)$.\n\nThis entire decision logic can be summarized by analyzing the sign of the difference $\\Delta(n_s) = F_{ss}(n_s) - F_{pp}(n_s)$:\n$$ \\Delta(n_s) = (0.25 - 0.20 n_s) - (-0.15 + 0.25 n_s) = 0.40 - 0.45 n_s $$\nThe update rule in terms of $\\Delta(n_s)$ from an initial guess $n_s^{(0)}$ is:\n- If $\\Delta(n_s^{(0)}) \\le 0$, the next state has $n_s^{(1)} = 2$.\n- If $\\Delta(n_s^{(0)}) > 0$, the next state has $n_s^{(1)} = 0$.\n\nSince the next state occupation $n_s^{(1)}$ is always an integer ($0$ or $2$), the SCF procedure converges in a single step. We need only determine which fixed point is reached from a given starting occupation $n_s^{(0)}$. A fixed point $n_s^*$ must satisfy the condition that the update rule maps it to itself.\n\nLet us check the two candidate fixed points:\n1.  State $(n_s, n_p) = (2, 0)$, corresponding to code $0$:\n    For this to be a fixed point, starting with $n_s = 2$ must result in $n_s = 2$. This requires $\\Delta(2) \\le 0$.\n    $$ \\Delta(2) = 0.40 - 0.45(2) = 0.40 - 0.90 = -0.50 $$\n    Since $-0.50 \\le 0$, the condition is met. Thus, $(n_s, n_p) = (2, 0)$ is a stable fixed point.\n\n2.  State $(n_s, n_p) = (0, 2)$, corresponding to code $1$:\n    For this to be a fixed point, starting with $n_s = 0$ must result in $n_s = 0$. This requires $\\Delta(0) > 0$.\n    $$ \\Delta(0) = 0.40 - 0.45(0) = 0.40 $$\n    Since $0.40 > 0$, this condition is also met. Thus, $(n_s, n_p) = (0, 2)$ is also a stable fixed point.\n\nThe existence of two stable fixed points indicates bistability. The final converged state depends on the initial guess $n_s^{(0)}$. The boundary between the basins of attraction for these two fixed points is where $\\Delta(n_s) = 0$.\n$$ 0.40 - 0.45 n_s = 0 \\implies 0.45 n_s = 0.40 \\implies n_s = \\frac{0.40}{0.45} = \\frac{40}{45} = \\frac{8}{9} $$\nThe critical occupation number is $n_s^* = 8/9 \\approx 0.888...$.\n\nThe convergence rule for any initial guess $n_s^{(0)}$ is:\n- If $n_s^{(0)} \\ge 8/9$, then $\\Delta(n_s^{(0)}) \\le 0$, and the system converges to the fixed point $(n_s, n_p) = (2, 0)$. The output is $0$.\n- If $n_s^{(0)} < 8/9$, then $\\Delta(n_s^{(0)}) > 0$, and the system converges to the fixed point $(n_s, n_p) = (0, 2)$. The output is $1$.\n\nWe now apply this rule to the specified test cases:\n- Case A: $(n_s^{(0)}, n_p^{(0)}) = (2.0, 0.0) \\implies n_s^{(0)} = 2.0$.\n  Since $2.0 \\ge 8/9$, the system converges to $(2, 0)$. Result: $0$.\n\n- Case B: $(n_s^{(0)}, n_p^{(0)}) = (0.0, 2.0) \\implies n_s^{(0)} = 0.0$.\n  Since $0.0 < 8/9$, the system converges to $(0, 2)$. Result: $1$.\n\n- Case C: $(n_s^{(0)}, n_p^{(0)}) = (1.0, 1.0) \\implies n_s^{(0)} = 1.0$.\n  Since $1.0 \\ge 8/9$, the system converges to $(2, 0)$. Result: $0$.\n\n- Case D: $(n_s^{(0)}, n_p^{(0)}) = (1.999, 0.001) \\implies n_s^{(0)} = 1.999$.\n  Since $1.999 \\ge 8/9$, the system converges to $(2, 0)$. Result: $0$.\n\nThe final list of results for Cases A, B, C, and D is $[0, 1, 0, 0]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the fixed point of a simplified Restricted Hartree-Fock (RHF)\n    procedure for the Be atom valence shell.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (n_s^(0), n_p^(0)).\n    test_cases = [\n        (2.0, 0.0),      # Case A\n        (0.0, 2.0),      # Case B\n        (1.0, 1.0),      # Case C\n        (1.999, 0.001),  # Case D\n    ]\n\n    results = []\n    \n    # The analytical solution identified a critical boundary for the initial\n    # occupation number n_s. The condition for convergence to the (ns=2, np=0)\n    # fixed point (output 0) is n_s >= 8/9. Otherwise, it converges to the\n    # (ns=0, np=2) fixed point (output 1).\n    n_s_boundary = 8.0 / 9.0\n\n    for case in test_cases:\n        # The initial occupation of the 2s orbital.\n        n_s_initial = case[0]\n\n        # Determine the fixed point based on the initial guess.\n        # The problem states that if F_ss = F_pp, the electrons occupy 2s.\n        # This corresponds to the condition delta <= 0, which is n_s >= 8/9.\n        # If n_s_initial >= n_s_boundary, the next state is (ns=2, np=0),\n        # which is a fixed point. This corresponds to output 0.\n        # If n_s_initial < n_s_boundary, the next state is (ns=0, np=2),\n        # which is the other fixed point. This corresponds to output 1.\n\n        if n_s_initial >= n_s_boundary:\n            # Converges to the 1s^2 2s^2 state (n_s=2, n_p=0).\n            final_state_code = 0\n        else:\n            # Converges to the 1s^2 2p^2 state (n_s=0, n_p=2).\n            final_state_code = 1\n            \n        results.append(final_state_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2465576"}]}