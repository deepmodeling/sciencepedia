{"hands_on_practices": [{"introduction": "The best way to understand an algorithm is to build it yourself. This first practice challenges you to implement the complete Fewest Switches Surface Hopping (FSSH) algorithm for a simple, one-dimensional two-state system. You will code the coupled equations of motion, integrating classical nuclear dynamics on a potential energy surface with the quantum evolution of electronic state amplitudes. This exercise is foundational, providing a concrete understanding of how FSSH simulates nonadiabatic events by combining deterministic evolution with stochastic 'hops' between surfaces.", "problem": "You are to implement a one-dimensional two-state Fewest Switches Surface Hopping (FSSH) simulation in dimensionless atomic units (a.u.) with angles in radians. The system has two adiabatic potential energy surfaces (PES) defined by the functions $V_1(x) = \\sin(x)$ and $V_2(x) = \\cos(2x)$. The nuclear coordinate is $x(t)$ and the nuclear velocity is $v(t)$. The nuclear mass is $m$. The dynamics evolve under the following principles.\n\n- Classical nuclear motion on the currently active adiabatic surface follows Newton’s second law: $m \\dfrac{d^2 x}{dt^2} = -\\dfrac{d V_s(x)}{d x}$, where $s \\in \\{1,2\\}$ is the index of the active surface.\n\n- Electronic amplitudes $c_1(t)$ and $c_2(t)$ obey the time-dependent Schrödinger equation in the adiabatic representation with a nonadiabatic coupling (NAC) function $d_{12}(x)$, using dimensionless atomic units where the reduced Planck constant is $1$. Let $E(x) = \\mathrm{diag}\\big(V_1(x), V_2(x)\\big)$ and the NAC matrix be $d(x)$ with entries $d_{12}(x)$, $d_{21}(x) = -d_{12}(x)$, and $d_{11}(x)=d_{22}(x)=0$. Then the amplitude dynamics satisfy\n$$\n\\frac{d}{dt}\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}\n= -\\mathrm{i}\\,E(x)\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}\n- v \\, d(x)\\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}.\n$$\n\n- The nonadiabatic coupling function is prescribed as\n$$\nd_{12}(x) = \\kappa \\exp\\!\\left(-\\frac{(x-x_c)^2}{2\\sigma^2}\\right),\n$$\nwith parameters $\\kappa$, $x_c$, and $\\sigma > 0$. All quantities are in atomic units; angles are interpreted in radians.\n\n- The Fewest Switches Surface Hopping (FSSH) rule specifies a stochastic hopping probability from the active state $i$ to the other state $j \\neq i$ over a time step of duration $\\Delta t$ as\n$$\ng_{i\\to j} = \\max\\!\\left(0,\\; \\frac{2\\Delta t\\Re\\!\\left[c_i^*(t)c_j(t)v(t)d_{ij}(x(t))\\right]}{|c_i(t)|^2}\\right),\n$$\nwith $d_{ij}(x)$ equal to $d_{12}(x)$ for $(i,j)=(1,2)$ and $d_{21}(x)=-d_{12}(x)$ for $(i,j)=(2,1)$. When a hop $i\\to j$ is accepted, adjust the nuclear velocity to conserve total energy along the single nuclear degree of freedom,\n$$\n\\frac{1}{2} mv'(t)^2 + V_j\\!\\big(x(t)\\big) \\;=\\; \\frac{1}{2} mv(t)^2 + V_i\\!\\big(x(t)\\big),\n$$\nthat is,\n$$\nv'(t) = \\mathrm{sign}\\!\\big(v(t)\\big)\\sqrt{v(t)^2 + \\frac{2}{m}\\big(V_i(x(t)) - V_j(x(t))\\big)}.\n$$\nIf the argument of the square root is negative, the hop is rejected as a frustrated hop and the active state remains $i$ with unchanged velocity. The complex amplitudes must be normalized at all times so that $|c_1|^2+|c_2|^2=1$. The initial amplitudes satisfy $c_s(0)=1$ on the initially active surface $s$ and $c_{3-s}(0)=0$ on the other surface.\n\n- Initial conditions: $x(0)=x_0$, $v(0)=v_0$, mass $m$, time step $\\Delta t$, and total simulation time $T$. The total number of discrete steps is $N=\\lfloor T/\\Delta t \\rceil$ so that the simulated final time is $N\\Delta t$. Use a pseudorandom number generator seeded with a provided integer $r$ to decide hops for reproducibility.\n\nFor each test case below, simulate from $t=0$ to $t=T$ and output the final position $x(T)$, the final velocity $v(T)$, the final active surface index $s(T)\\in\\{1,2\\}$, and the total number of accepted hops (an integer count). Express $x(T)$ and $v(T)$ in atomic units (a.u.) rounded to six decimal places. Angles must be treated in radians.\n\nTest suite (all quantities in atomic units, angles in radians):\n\n- Case A (general crossing): $m=1$, $x_0=-2.0$, $v_0=1.2$, $\\kappa=0.5$, $x_c=0.0$, $\\sigma=0.6$, $\\Delta t=0.002$, $T=10.0$, initial surface $s=1$, random seed $r=1337$.\n\n- Case B (no coupling): $m=1$, $x_0=-1.0$, $v_0=0.8$, $\\kappa=0.0$, $x_c=0.0$, $\\sigma=0.6$, $\\Delta t=0.002$, $T=4.0$, initial surface $s=1$, random seed $r=42$.\n\n- Case C (start on second surface): $m=1$, $x_0=-3.0$, $v_0=2.0$, $\\kappa=0.7$, $x_c=-1.0$, $\\sigma=0.4$, $\\Delta t=0.0015$, $T=6.0$, initial surface $s=2$, random seed $r=2023$.\n\n- Case D (strong coupling, slow passage): $m=1$, $x_0=0.0$, $v_0=0.3$, $\\kappa=1.0$, $x_c=0.0$, $\\sigma=0.2$, $\\Delta t=0.001$, $T=8.0$, initial surface $s=1$, random seed $r=7$.\n\nYour program should produce a single line of output containing the results as a comma-separated list of per-case results, where each per-case result is a list in the form $[x(T),v(T),s(T),\\text{hops}]$ with $x(T)$ and $v(T)$ rounded to six decimal places and $s(T)$ and $\\text{hops}$ as integers. The four case results must be enclosed in an outer list and printed in the order A, B, C, D. For example, a valid output format is $[[x_A,v_A,s_A,h_A],[x_B,v_B,s_B,h_B],[x_C,v_C,s_C,h_C],[x_D,v_D,s_D,h_D]]$ with the specified rounding and types.", "solution": "The problem requires the implementation of a one-dimensional, two-state Fewest Switches Surface Hopping (FSSH) simulation. The problem is a valid, well-posed computational physics problem based on established semiclassical methods. A complete solution requires numerically integrating the coupled classical-quantum equations of motion for the given potential energy surfaces and parameters.\n\nFirst, we define the components of the physical system. The two adiabatic potential energy surfaces (PES) are given by $V_1(x) = \\sin(x)$ and $V_2(x) = \\cos(2x)$. The corresponding forces on the nucleus of mass $m$ are $F_1(x) = -\\frac{d V_1(x)}{dx} = -\\cos(x)$ and $F_2(x) = -\\frac{d V_2(x)}{dx} = 2\\sin(2x)$. The nonadiabatic coupling (NAC) between the two states is given by the function $d_{12}(x) = \\kappa \\exp\\left(-\\frac{(x-x_c)^2}{2\\sigma^2}\\right)$, with the property $d_{21}(x) = -d_{12}(x)$.\n\nThe simulation involves a time-stepping procedure to propagate the system's state, which consists of the nuclear position $x(t)$, velocity $v(t)$, the active electronic surface index $s(t) \\in \\{1, 2\\}$, and the complex electronic amplitudes $c_1(t)$ and $c_2(t)$. The total number of steps is $N = \\lfloor T/\\Delta t \\rceil$, which is interpreted as rounding $T/\\Delta t$ to the nearest integer.\n\nThe core of the solution is the numerical integration algorithm. While the problem does not specify an integrator, a standard and robust choice for this type of simulation is a symmetric split-operator approach combined with the Velocity Verlet algorithm for nuclear motion. This method ensures stability and proper synchronization between the classical and quantum subsystems. The procedure for a single time step from $t_n$ to $t_{n+1} = t_n + \\Delta t$ is as follows:\n\nLet the state at time $t_n$ be $(x_n, v_n, \\mathbf{c}_n, s_n)$, where $\\mathbf{c}_n = [c_{1,n}, c_{2,n}]^T$ and $s_n$ is the active surface index.\n\n1.  **Nuclear Propagation**: The nuclear coordinates are propagated from $t_n$ to $t_{n+1}$ using the Velocity Verlet algorithm on the currently active surface $s_n$. This yields a tentative final position and velocity.\n    - First, the force on the active surface $s_n$ at position $x_n$ is computed: $F_n = - \\frac{d V_{s_n}}{dx}(x_n)$.\n    - The velocity is advanced by a half-step: $v_{n+1/2} = v_n + \\frac{F_n}{2m} \\Delta t$.\n    - The position is advanced by a full step: $x_{n+1} = x_n + v_{n+1/2} \\Delta t$.\n    - A tentative force at the new position on the same surface is computed: $F_{n+1}^{(s_n)} = - \\frac{d V_{s_n}}{dx}(x_{n+1})$.\n    - A tentative final velocity is computed: $v_{n+1}^{(s_n)} = v_{n+1/2} + \\frac{F_{n+1}^{(s_n)}}{2m} \\Delta t$.\n\n2.  **Electronic Propagation**: The electronic amplitudes $\\mathbf{c}_n$ are propagated to $\\mathbf{c}_{n+1}$ by solving the Time-Dependent Schrödinger Equation, $\\frac{d\\mathbf{c}}{dt} = -i \\mathbf{H}_{el} \\mathbf{c}$. The electronic Hamiltonian in the adiabatic basis is:\n    $$\n    \\mathbf{H}_{el}(x, v) = \\begin{bmatrix} V_1(x) & -i v d_{12}(x) \\\\ i v d_{12}(x) & V_2(x) \\end{bmatrix}\n    $$\n    The formal solution over a time step $\\Delta t$ is $\\mathbf{c}_{n+1} = \\exp(-i \\mathbf{H}_{el} \\Delta t) \\mathbf{c}_n$. To achieve better accuracy, the Hamiltonian $\\mathbf{H}_{el}$ is evaluated using representative values for position and velocity over the interval, such as the midpoint values $x_{\\text{mid}} = (x_n+x_{n+1})/2$ and $v_{\\text{mid}} = v_{n+1/2}$. The matrix exponential is computed numerically. After propagation, the amplitude vector is renormalized, $\\mathbf{c}_{n+1} \\leftarrow \\mathbf{c}_{n+1} / \\|\\mathbf{c}_{n+1}\\|$, to correct for any numerical drift and ensure conservation of probability, $|c_1|^2 + |c_2|^2 = 1$.\n\n3.  **Surface Hopping Decision**: A stochastic decision is made whether to switch electronic surfaces. Let the active surface be $i=s_n$ and the other surface be $j=3-i$. The probability for a hop is calculated using the system state at the end of the time step:\n    $$\n    g_{i\\to j} = \\max\\!\\left(0,\\; \\frac{2\\Delta t\\Re\\!\\left[c_{i, n+1}^*(t)c_{j, n+1}(t)v_{n+1}^{(i)}d_{ij}(x_{n+1})\\right]}{|c_{i, n+1}(t)|^2}\\right)\n    $$\n    A uniform random number $\\zeta \\in [0, 1]$ is generated. If $\\zeta < g_{i \\to j}$, a hop is attempted.\n\n4.  **Velocity Adjustment and Hop Finalization**: If a hop from surface $i$ to $j$ is attempted, energy conservation must be checked. The new kinetic energy must be non-negative.\n    - We test if the condition $ (v_{n+1}^{(i)})^2 + \\frac{2}{m}(V_i(x_{n+1}) - V_j(x_{n+1})) \\ge 0$ is met.\n    - If true (hop is accepted), the active surface is updated to $s_{n+1} = j$, the hop counter is incremented, and the velocity is rescaled to conserve total energy:\n      $$\n      v_{n+1} = \\mathrm{sign}(v_{n+1}^{(i)})\\sqrt{ (v_{n+1}^{(i)})^2 + \\frac{2}{m}(V_i(x_{n+1}) - V_j(x_{n+1})) }\n      $$\n    - If false (hop is frustrated), the system remains on the original surface, $s_{n+1} = i$, and the velocity is unchanged, $v_{n+1} = v_{n+1}^{(i)}$.\n    - If no hop was attempted, the system also remains on the original surface with the unadjusted velocity, $s_{n+1}=i$ and $v_{n+1}=v_{n+1}^{(i)}$.\n\nThis four-step process is repeated for $N$ time steps. For each test case, the simulation is initialized with the provided parameters, including the random seed $r$ for reproducibility of the stochastic hopping decisions. The final position $x(T)$, velocity $v(T)$, active surface index $s(T)$, and total number of accepted hops are recorded.\n\nThe implementation utilizes Python with the `numpy` library for numerical operations and `scipy.linalg.expm` for computing the matrix exponential, as is standard practice for such scientific computations.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Implements a one-dimensional, two-state Fewest Switches Surface Hopping (FSSH) simulation.\n    \"\"\"\n\n    # --- Define physical system functions ---\n    def V1(x):\n        return np.sin(x)\n\n    def dV1dx(x):\n        return np.cos(x)\n\n    def V2(x):\n        return np.cos(2 * x)\n\n    def dV2dx(x):\n        return -2 * np.sin(2 * x)\n\n    def d12(x, kappa, xc, sigma):\n        return kappa * np.exp(-((x - xc)**2) / (2 * sigma**2))\n\n    # --- Test suite from the problem statement ---\n    test_cases = [\n        # Case A: m, x0, v0, kappa, xc, sigma, dt, T, s_initial, seed\n        (1.0, -2.0, 1.2, 0.5, 0.0, 0.6, 0.002, 10.0, 1, 1337),\n        # Case B:\n        (1.0, -1.0, 0.8, 0.0, 0.0, 0.6, 0.002, 4.0, 1, 42),\n        # Case C:\n        (1.0, -3.0, 2.0, 0.7, -1.0, 0.4, 0.0015, 6.0, 2, 2023),\n        # Case D:\n        (1.0, 0.0, 0.3, 1.0, 0.0, 0.2, 0.001, 8.0, 1, 7),\n    ]\n\n    results = []\n    \n    # Store potentials and forces in lists for easy indexing (0-indexed)\n    potentials = [V1, V2]\n    forces_func = [lambda x: -dV1dx(x), lambda x: -dV2dx(x)]\n\n    # --- Main simulation loop for each test case ---\n    for case in test_cases:\n        m, x0, v0, kappa, xc, sigma, dt, T, s_initial, seed = case\n        \n        # Initialize state\n        x = x0\n        v = v0\n        s = s_initial  # Active surface index (1 or 2)\n        \n        c = np.zeros(2, dtype=np.complex128)\n        c[s - 1] = 1.0 + 0.0j\n        \n        hops = 0\n        rng = np.random.default_rng(seed)\n        \n        num_steps = int(round(T / dt))\n\n        for _ in range(num_steps):\n            # i is 0-indexed surface, j is the other surface\n            i = s - 1\n            j = 1 - i\n\n            # --- 1. Nuclear Propagation (Velocity Verlet) ---\n            # Propagate on the current active surface 'i'\n            force_current = forces_func[i](x)\n            v_half = v + 0.5 * force_current / m * dt\n            x_new = x + v_half * dt\n            \n            force_new_i = forces_func[i](x_new)\n            v_new_i = v_half + 0.5 * force_new_i / m * dt\n\n            # --- 2. Electronic Propagation ---\n            # Use midpoint values for better accuracy\n            x_mid = (x + x_new) / 2\n            v_mid = v_half\n            \n            d12_val = d12(x_mid, kappa, xc, sigma)\n            H_el = np.array([\n                [potentials[0](x_mid), -1j * v_mid * d12_val],\n                [1j * v_mid * d12_val,  potentials[1](x_mid)]\n            ], dtype=np.complex128)\n            \n            # Propagate electronic coefficients using matrix exponential\n            c_new = expm(-1j * H_el * dt) @ c\n            \n            # Renormalize to conserve probability\n            c_new /= np.linalg.norm(c_new)\n\n            # --- 3. Surface Hopping Decision ---\n            # Use state at the end of the step\n            d12_new = d12(x_new, kappa, xc, sigma)\n            \n            # d_ij term depends on direction of hop\n            # From i to j: use d_ji. In our notation, d_{01} = d12, d_{10} = -d12\n            d_ij = d12_new if i == 0 else -d12_new \n            \n            # Hopping probability from surface i to j\n            c_i_sq = np.abs(c_new[i])**2\n            if c_i_sq > 1e-12: # Avoid division by zero\n                # Note: c_i^* c_j v d_ij\n                # c_new[i].conj() * c_new[j] gives c_0^* c_1 or c_1^* c_0\n                # v_new_i is used as the velocity for the step\n                # d_ij is d_{01} or d_{10}\n                numerator = 2.0 * dt * np.real(c_new[i].conj() * c_new[j] * v_new_i * d_ij)\n                g_ij = max(0.0, numerator / c_i_sq)\n            else:\n                g_ij = 0.0\n\n            s_new = s\n            v_new = v_new_i\n            \n            if rng.random()  g_ij:\n                # --- 4. Velocity Adjustment (Hop Attempted) ---\n                v_sq_current = v_new_i**2\n                delta_V = potentials[i](x_new) - potentials[j](x_new)\n                \n                v_sq_new = v_sq_current + 2.0 / m * delta_V\n                \n                if v_sq_new >= 0: # Hop accepted\n                    s_new = j + 1\n                    hops += 1\n                    v_new = np.sign(v_new_i) * np.sqrt(v_sq_new)\n                # Else: Frustrated hop, state remains unchanged (s_new=s, v_new=v_new_i)\n\n            # Update state for the next step\n            x, v, s, c = x_new, v_new, s_new, c_new\n\n        # Format results for this case\n        results.append(f\"[{x:.6f},{v:.6f},{s},{hops}]\")\n        \n    # --- Final Output ---\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2463158"}, {"introduction": "Building on the one-dimensional foundation, this next exercise advances the simulation to a two-dimensional space. Here, you will see how the core FSSH principles extend to handle vector quantities for position, momentum, and nonadiabatic coupling. A crucial concept explored in this practice is the vector-based momentum adjustment after a hop, which is essential for conserving energy in multi-dimensional systems and is a more realistic representation of molecular dynamics. This exercise deepens your problem-solving skills by requiring you to manage a more complex, yet more physically relevant, simulation environment.", "problem": "You are to implement a complete, runnable program that simulates a two-dimensional Fewest Switches Surface Hopping (FSSH) trajectory of a single classical nucleus coupled to two adiabatic electronic states. The simulation shall be formulated in atomic units. The potential energy surfaces and the nonadiabatic coupling (NAC) vector field are parametrized in a way that mimics a user-sketched landscape, but you must use the precise mathematical definitions provided below, together with the specified test suite. Your program must compute the final active electronic state index for each test case and output all results in a single line as a comma-separated list enclosed in square brackets.\n\nMathematical model to implement (atomic units, where Planck’s constant is $1$):\n\n- Geometry and kinematics:\n  - Nuclear position is $\\mathbf{R}(t) = (x(t), y(t))$ and nuclear momentum is $\\mathbf{P}(t) = (p_x(t), p_y(t))$.\n  - Mass is $M$ (scalar, identical for $x$ and $y$), so nuclear velocity is $\\dot{\\mathbf{R}}(t) = \\mathbf{P}(t)/M$.\n\n- Potential energy surfaces:\n  - Two adiabatic surfaces $E_1(\\mathbf{R})$ and $E_2(\\mathbf{R})$ are defined as Gaussian bumps centered at $( -x_c, 0 )$ and $( +x_c, 0 )$, respectively, with equal height and width:\n    $$E_1(x,y) = A \\exp\\!\\left(-\\frac{(x + x_c)^2 + y^2}{\\sigma^2}\\right), \\quad E_2(x,y) = A \\exp\\!\\left(-\\frac{(x - x_c)^2 + y^2}{\\sigma^2}\\right).$$\n  - The corresponding gradients are\n    $$\\nabla E_1(x,y) = -\\frac{2A}{\\sigma^2}\\exp\\!\\left(-\\frac{(x + x_c)^2 + y^2}{\\sigma^2}\\right)\\begin{bmatrix}x + x_c \\\\ y\\end{bmatrix}, \\quad \\nabla E_2(x,y) = -\\frac{2A}{\\sigma^2}\\exp\\!\\left(-\\frac{(x - x_c)^2 + y^2}{\\sigma^2}\\right)\\begin{bmatrix}x - x_c \\\\ y\\end{bmatrix}.$$\n\n- Nonadiabatic coupling (NAC) vector field:\n  - The only nonzero NAC vector is $\\mathbf{d}_{12}(\\mathbf{R})$, and $\\mathbf{d}_{21}(\\mathbf{R}) = -\\mathbf{d}_{12}(\\mathbf{R})$, with $\\mathbf{d}_{11}(\\mathbf{R}) = \\mathbf{d}_{22}(\\mathbf{R}) = \\mathbf{0}$.\n  - The NAC vector field is a localized Gaussian with a specified constant direction $\\hat{\\mathbf{u}} = (u_x, u_y)$, $\\|\\hat{\\mathbf{u}}\\| = 1$, centered at $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}})$, with amplitude $C$ and width parameter $\\lambda$:\n    $$\\mathbf{d}_{12}(x,y) = \\frac{C}{\\lambda}\\exp\\!\\left(-\\frac{(x - x_{\\mathrm{NAC}})^2 + (y - y_{\\mathrm{NAC}})^2}{\\lambda^2}\\right)\\hat{\\mathbf{u}}.$$\n\n- Electronic amplitudes:\n  - In the adiabatic representation, the electronic state vector is $\\mathbf{c}(t) = \\big(c_1(t), c_2(t)\\big)$ with $\\|\\mathbf{c}(t)\\|^2 = |c_1(t)|^2 + |c_2(t)|^2 = 1$.\n  - The time-dependent Schrödinger equation for the amplitudes is\n    $$i\\frac{d c_k}{dt} = E_k(\\mathbf{R})c_k - i\\sum_{\\ell=1}^{2} \\big(\\dot{\\mathbf{R}}\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R})\\big)c_\\ell, \\quad k \\in \\{1,2\\}.$$\n\n- Nuclear equations of motion on the active surface:\n  - Let the active surface index be $s(t)\\in\\{1,2\\}$. The nuclei follow classical dynamics on the active surface:\n    $$\\dot{\\mathbf{R}} = \\frac{\\mathbf{P}}{M}, \\quad \\dot{\\mathbf{P}} = -\\nabla E_{s(t)}(\\mathbf{R}).$$\n\n- Hopping probability and decision:\n  - The instantaneous probability to hop from the current active state $k$ to the other state $\\ell\\neq k$ during time step $\\Delta t$ is\n    $$g_{k\\to \\ell} = \\max\\left(0, \\frac{2\\Delta t\\mathrm{Re}\\!\\left[c_k^*(t)c_\\ell(t)\\big(\\dot{\\mathbf{R}}(t)\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R}(t))\\big)\\right]}{|c_k(t)|^2}\\right).$$\n  - Use a uniform random number generator over $[0,1)$ seeded with the integer $12345$ at the start of each test case. A hop $k\\to \\ell$ occurs if the random variate $r$ satisfies $r  g_{k\\to \\ell}$, otherwise no hop occurs in that step.\n\n- Momentum rescaling upon a successful hop:\n  - Let $\\Delta E = E_\\ell(\\mathbf{R}) - E_k(\\mathbf{R})$ at the hop location.\n  - Let $\\hat{\\mathbf{n}} = \\mathbf{d}_{k\\ell}(\\mathbf{R})/\\|\\mathbf{d}_{k\\ell}(\\mathbf{R})\\|$ be the unit vector along the NAC direction. Rescale momentum only along $\\hat{\\mathbf{n}}$ to conserve total energy:\n    $$\\mathbf{P}' = \\mathbf{P} + \\alpha\\hat{\\mathbf{n}}, \\quad \\text{with } \\alpha \\text{ chosen so that } \\frac{\\|\\mathbf{P}'\\|^2}{2M} + E_\\ell(\\mathbf{R}) = \\frac{\\|\\mathbf{P}\\|^2}{2M} + E_k(\\mathbf{R}).$$\n  - The scalar $\\alpha$ must satisfy the quadratic equation\n    $$\\alpha^2 + 2\\alpha(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}) + 2M\\Delta E = 0.$$\n    If the discriminant is negative or $\\|\\mathbf{d}_{k\\ell}(\\mathbf{R})\\|=0$, declare a frustrated hop and keep the current state (no change to $\\mathbf{P}$). If admissible, choose\n    $$\\alpha = -(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}) + \\mathrm{sign}\\!\\big(\\mathbf{P}\\cdot \\hat{\\mathbf{n}}\\big)\\sqrt{(\\mathbf{P}\\cdot \\hat{\\mathbf{n}})^2 - 2M\\Delta E}.$$\n\nNumerical parameters that are common to all cases:\n- Use $A = 0.02$, $\\sigma = 1.0$, $x_c = 1.0$.\n- Use $M = 10.0$.\n- Use time step $\\Delta t = 0.01$ and total simulation time $T = 40.0$, i.e., $N = 4000$ equal steps.\n- Normalize the electronic amplitudes $\\mathbf{c}(t)$ after each time step to enforce $\\|\\mathbf{c}(t)\\|=1$.\n- All quantities are in atomic units.\n\nTest suite (four independent simulations). In each case, initialize the random number generator with seed $12345$.\n\n- Case $1$ (happy path, strong coupling centered on the trajectory):\n  - Initial nuclear position $(x_0, y_0) = (-4.0, 0.0)$.\n  - Initial nuclear momentum $(p_{x,0}, p_{y,0}) = (5.0, 0.0)$.\n  - Initial electronic state: active surface $s(0) = 1$ with amplitudes $\\mathbf{c}(0) = (1+0i,0+0i)$.\n  - NAC parameters: $C = 4.0$, $\\lambda = 1.0$, $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 0.0)$, $\\hat{\\mathbf{u}} = (1.0, 0.0)$.\n\n- Case $2$ (boundary, zero coupling):\n  - Same as Case $1$, except NAC amplitude $C = 0.0$.\n\n- Case $3$ (reverse direction and initial state):\n  - Initial nuclear position $(x_0, y_0) = (4.0, 0.0)$.\n  - Initial nuclear momentum $(p_{x,0}, p_{y,0}) = (-5.0, 0.0)$.\n  - Initial electronic state: active surface $s(0) = 2$ with amplitudes $\\mathbf{c}(0) = (0+0i,1+0i)$.\n  - NAC parameters: $C = 4.0$, $\\lambda = 1.0$, $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 0.0)$, $\\hat{\\mathbf{u}} = (1.0, 0.0)$.\n\n- Case $4$ (edge case, displaced NAC center away from the path):\n  - Same as Case $1$, except NAC center $(x_{\\mathrm{NAC}}, y_{\\mathrm{NAC}}) = (0.0, 3.0)$ with $C = 4.0$ and $\\lambda = 1.0$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, report the final active surface index at time $T$ as an integer $1$ or $2$ in the order of the cases $1$ through $4$. For example, a valid output line has the form “[1,2,1,2]” (without quotes).\n\nThere is no user input. All constants and initial conditions have been provided. All computations and the final output must be performed in atomic units, and angles are not used in this problem.", "solution": "The problem statement is subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of nonadiabatic quantum dynamics, specifically the Fewest Switches Surface Hopping (FSSH) algorithm, which is a standard semi-classical method in computational chemistry. The problem is well-posed, providing a complete and consistent set of mathematical definitions, physical constants, initial conditions for four distinct test cases, and a precise numerical integration recipe. All terms are objectively and unambiguously defined. The problem is a formal request for a numerical simulation based on established physical theory and is therefore solvable.\n\nThe task is to simulate the trajectory of a classical nucleus with mass $M$ moving in two dimensions, $\\mathbf{R}(t) = (x(t), y(t))$, while coupled to two quantum electronic states. The dynamics are governed by the FSSH algorithm. At any given time $t$, the system is characterized by the nuclear position $\\mathbf{R}(t)$ and momentum $\\mathbf{P}(t)$, the electronic wave function coefficients $\\mathbf{c}(t) = (c_1(t), c_2(t))$, and the active electronic surface index $s(t) \\in \\{1, 2\\}$.\n\nThe simulation proceeds by numerically integrating the equations of motion over a total time $T$ with a discrete time step $\\Delta t$. The workflow within each time step from $t$ to $t+\\Delta t$ is as follows:\n\n1.  **Nuclear Propagation**: The nuclei move classically on the currently active potential energy surface (PES), $E_{s(t)}(\\mathbf{R})$. The equations of motion are Newton's second law, $\\dot{\\mathbf{P}} = -\\nabla E_{s(t)}(\\mathbf{R})$, and $\\dot{\\mathbf{R}} = \\mathbf{P}/M$. We employ the Velocity Verlet algorithm for stable and accurate integration. Given the state $(\\mathbf{R}(t), \\mathbf{P}(t))$ and the active surface $s(t)$:\n    -   First, compute the force at the current position: $\\mathbf{F}(t) = -\\nabla E_{s(t)}(\\mathbf{R}(t))$.\n    -   Update the momentum to a half-step: $\\mathbf{P}(t+\\Delta t/2) = \\mathbf{P}(t) + \\mathbf{F}(t) \\frac{\\Delta t}{2}$.\n    -   Update the position for a full step: $\\mathbf{R}(t+\\Delta t) = \\mathbf{R}(t) + \\frac{\\mathbf{P}(t+\\Delta t/2)}{M} \\Delta t$.\n    -   Determine the new force at the new position, still on the same surface $s(t)$: $\\mathbf{F}(t+\\Delta t) = -\\nabla E_{s(t)}(\\mathbf{R}(t+\\Delta t))$.\n    -   Update the momentum for the second half-step to obtain a temporary momentum at the end of the step: $\\mathbf{P}_{\\text{temp}}(t+\\Delta t) = \\mathbf{P}(t+\\Delta t/2) + \\mathbf{F}(t+\\Delta t) \\frac{\\Delta t}{2}$. This momentum will be used as the basis for the hopping decision.\n\n2.  **Electronic Propagation**: The electronic coefficients $c_k(t)$ evolve according to the time-dependent Schrödinger equation (TDSE) in the adiabatic representation:\n    $$i\\frac{d c_k}{dt} = E_k(\\mathbf{R})c_k - i\\sum_{\\ell=1}^{2} \\big(\\dot{\\mathbf{R}}\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R})\\big)c_\\ell$$\n    We integrate this equation using a first-order forward Euler method, which is sufficient for the small time step $\\Delta t$ given. The derivatives $\\dot{c}_k(t)$ are calculated using the state $(\\mathbf{R}(t), \\mathbf{P}(t), \\mathbf{c}(t))$ at the beginning of the time step. The updated coefficients are then normalized to preserve the total probability, i.e., $\\|\\mathbf{c}(t+\\Delta t)\\|^2=1$.\n\n3.  **Hopping Probability Calculation**: After propagating the nuclei and electrons, a stochastic decision is made whether to switch the active electronic surface. The probability of hopping from the current active state $k$ to another state $\\ell$ is calculated as:\n    $$g_{k\\to \\ell} = \\max\\left(0, \\frac{2\\Delta t\\mathrm{Re}\\!\\left[c_k^*(t)c_\\ell(t)\\big(\\dot{\\mathbf{R}}(t)\\cdot \\mathbf{d}_{k\\ell}(\\mathbf{R}(t))\\big)\\right]}{|c_k(t)|^2}\\right)$$\n    This probability is computed using the state variables $(\\mathbf{R}(t), \\mathbf{P}(t), \\mathbf{c}(t))$ at the start of the time interval. A uniformly generated random number $r \\in [0,1)$ is compared to $g_{k\\to \\ell}$. If $r  g_{k\\to \\ell}$, a hop is attempted.\n\n4.  **Hop Decision and Momentum Rescaling**: If a hop from state $k$ to state $\\ell$ is attempted, energy conservation must be enforced. The change in potential energy at the hopping position $\\mathbf{R}(t+\\Delta t)$ is $\\Delta E = E_\\ell(\\mathbf{R}(t+\\Delta t)) - E_k(\\mathbf{R}(t+\\Delta t))$. This must be compensated by a change in nuclear kinetic energy. The momentum is rescaled along the direction of the nonadiabatic coupling vector, $\\hat{\\mathbf{n}} = \\mathbf{d}_{k\\ell}(\\mathbf{R}(t+\\Delta t))/\\|\\mathbf{d}_{k\\ell}(\\mathbf{R}(t+\\Delta t))\\|$. The adjustment $\\alpha$ to the momentum, $\\mathbf{P}' = \\mathbf{P}_{\\text{temp}}(t+\\Delta t) + \\alpha\\hat{\\mathbf{n}}$, is found by solving the quadratic equation arising from energy conservation:\n    $$\\alpha^2 + 2\\alpha\\big(\\mathbf{P}_{\\text{temp}}(t+\\Delta t)\\cdot \\hat{\\mathbf{n}}\\big) + 2M\\Delta E = 0$$\n    A real solution for $\\alpha$ exists only if the discriminant is non-negative: $\\big(\\mathbf{P}_{\\text{temp}}(t+\\Delta t)\\cdot \\hat{\\mathbf{n}}\\big)^2 - 2M\\Delta E \\geq 0$. If this condition holds and the coupling vector is non-zero, the hop is successful. We choose the solution for $\\alpha$ that minimizes the change to the momentum. The active state is updated to $s(t+\\Delta t) = \\ell$, and the final momentum for the step is $\\mathbf{P}(t+\\Delta t) = \\mathbf{P}'$. If the discriminant is negative or $\\|\\mathbf{d}_{k\\ell}\\|=0$, the hop is \"frustrated\" and rejected. The system remains on the original surface, so $s(t+\\Delta t) = k$, and the momentum is not adjusted, $\\mathbf{P}(t+\\Delta t) = \\mathbf{P}_{\\text{temp}}(t+\\Delta t)$. If no hop was attempted, the state and momentum are similarly finalized without change.\n\nThis four-step process is repeated for the total number of steps, $N = T/\\Delta t$. For each test case, the simulation is initialized with the specified parameters, and the final active surface index $s(T)$ is recorded.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the FSSH simulation for all test cases and print results.\n    \"\"\"\n    \n    # Global constants defined in the problem\n    A = 0.02\n    SIGMA = 1.0\n    XC = 1.0\n    M = 10.0\n    DT = 0.01\n    T_TOTAL = 40.0\n    N_STEPS = int(T_TOTAL / DT)\n\n    # --- Mathematical Model Implementation ---\n\n    def E1(R):\n        \"\"\"Potential energy of surface 1.\"\"\"\n        x, y = R\n        return A * np.exp(-((x + XC)**2 + y**2) / SIGMA**2)\n\n    def E2(R):\n        \"\"\"Potential energy of surface 2.\"\"\"\n        x, y = R\n        return A * np.exp(-((x - XC)**2 + y**2) / SIGMA**2)\n\n    def grad_E1(R):\n        \"\"\"Gradient of potential energy surface 1.\"\"\"\n        x, y = R\n        prefactor = - (2.0 * A / SIGMA**2) * np.exp(-((x + XC)**2 + y**2) / SIGMA**2)\n        return prefactor * np.array([x + XC, y])\n\n    def grad_E2(R):\n        \"\"\"Gradient of potential energy surface 2.\"\"\"\n        x, y = R\n        prefactor = - (2.0 * A / SIGMA**2) * np.exp(-((x - XC)**2 + y**2) / SIGMA**2)\n        return prefactor * np.array([x - XC, y])\n\n    def d12(R, C, lam, R_nac, u_hat):\n        \"\"\"Nonadiabatic coupling vector d_12.\"\"\"\n        x, y = R\n        x_nac, y_nac = R_nac\n        prefactor = (C / lam) * np.exp(-((x - x_nac)**2 + (y - y_nac)**2) / lam**2)\n        return prefactor * u_hat\n\n    def simulate(R0, P0, s0, c0, nac_params):\n        \"\"\"\n        Performs a single FSSH trajectory simulation for one test case.\n        \"\"\"\n        rng = np.random.default_rng(12345)\n\n        R = np.array(R0, dtype=float)\n        P = np.array(P0, dtype=float)\n        s = s0\n        c = np.array(c0, dtype=complex)\n\n        energies_funcs = [E1, E2]\n        gradients_funcs = [grad_E1, grad_E2]\n\n        for _ in range(N_STEPS):\n            # --- 1. Propagate nuclei using Velocity Verlet ---\n            active_idx = s - 1\n            \n            # F = -grad(E), so P_dot = -grad(E)\n            F_t = -gradients_funcs[active_idx](R)\n            \n            P_half = P + F_t * DT / 2.0\n            R_new = R + P_half / M * DT\n            \n            # Force at new position, still on the same surface 's'\n            F_t_plus_dt = -gradients_funcs[active_idx](R_new)\n            P_pre_hop = P_half + F_t_plus_dt * DT / 2.0\n\n            # --- 2. Propagate electronic coefficients using Forward Euler ---\n            E_k = np.array([E1(R), E2(R)])\n            V = P / M\n            d12_vec_t = d12(R, **nac_params)\n            V_dot_d12 = np.dot(V, d12_vec_t)\n\n            c_dot = np.zeros(2, dtype=complex)\n            c_dot[0] = -1j * E_k[0] * c[0] - V_dot_d12 * c[1]\n            c_dot[1] = -1j * E_k[1] * c[1] + V_dot_d12 * c[0]\n            \n            c_new = c + c_dot * DT\n            c_new /= np.linalg.norm(c_new)\n\n            # --- 3. Calculate hopping probability ---\n            k, l = s, 3 - s\n            k_idx, l_idx = k - 1, l - 1\n\n            d_kl_vec_t = d12_vec_t if k == 1 else -d12_vec_t\n            V_dot_dkl = np.dot(V, d_kl_vec_t)\n\n            numerator = 2.0 * DT * np.real(c[k_idx].conj() * c[l_idx]) * V_dot_dkl\n            denominator = np.abs(c[k_idx])**2\n            \n            g_kl = 0.0\n            if denominator > 1e-12:\n                g_kl = max(0.0, numerator / denominator)\n\n            # --- 4. Hopping decision and momentum resale ---\n            P_final = P_pre_hop\n            s_new = s\n\n            if rng.random()  g_kl: # Attempt hop\n                delta_E = energies_funcs[l_idx](R_new) - energies_funcs[k_idx](R_new)\n                d_kl_vec_new = d12(R_new, **nac_params) if k == 1 else -d12(R_new, **nac_params)\n                d_kl_norm = np.linalg.norm(d_kl_vec_new)\n\n                if d_kl_norm > 1e-12:\n                    n_hat = d_kl_vec_new / d_kl_norm\n                    P_dot_n = np.dot(P_pre_hop, n_hat)\n                    discriminant = P_dot_n**2 - 2.0 * M * delta_E\n\n                    if discriminant >= 0:\n                        # Successful hop\n                        alpha = -P_dot_n + np.sign(P_dot_n) * np.sqrt(discriminant)\n                        P_final = P_pre_hop + alpha * n_hat\n                        s_new = l\n                # If d_kl_norm is too small or discriminant is negative, it's a frustrated hop.\n                # In that case, s and P remain unchanged from their pre-hop values.\n            \n            # --- 5. Update state variables for the next step ---\n            R, P, s, c = R_new, P_final, s_new, c_new\n\n        return s\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 2\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 0.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 3\n        {\n            \"R0\": [4.0, 0.0], \"P0\": [-5.0, 0.0], \"s0\": 2, \"c0\": [0.0 + 0.0j, 1.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 0.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n        # Case 4\n        {\n            \"R0\": [-4.0, 0.0], \"P0\": [5.0, 0.0], \"s0\": 1, \"c0\": [1.0 + 0.0j, 0.0 + 0.0j],\n            \"nac_params\": {\"C\": 4.0, \"lam\": 1.0, \"R_nac\": [0.0, 3.0], \"u_hat\": np.array([1.0, 0.0])}\n        },\n    ]\n\n    results = [simulate(**case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2463200"}, {"introduction": "A key skill for any computational scientist is the ability to critically evaluate simulation results and identify potential artifacts. The FSSH algorithm, for all its power, can sometimes produce unphysical 'recrossing' events where a trajectory hops to another surface and immediately hops back. This post-processing exercise tasks you with implementing a deterministic algorithm to detect and correct these spurious hops based on a clear set of physical criteria. This practice moves beyond basic simulation to the crucial stage of data analysis and refinement, highlighting the importance of understanding and mitigating the known limitations of a computational model.", "problem": "Consider a trajectory generated by Fewest Switches Surface Hopping (FSSH). Let there be a time-ordered sequence of length $N$ with strictly increasing times $t_0  t_1  \\dots  t_{N-1}$, an \"active electronic state\" index sequence $s_0, s_1, \\dots, s_{N-1}$ with each $s_i$ an integer label, and a nonnegative \"nuclear kinetic energy\" sequence $K_0, K_1, \\dots, K_{N-1}$. Define a \"hop event\" at index $i$ for any $i \\in \\{1,\\dots,N-1\\}$ such that $s_i \\neq s_{i-1}$. For a hop event at index $i$, define the \"pre-hop state\" $p_i = s_{i-1}$, the \"post-hop state\" $q_i = s_i$, the \"hop time\" $\\tau_i = t_i$, and the \"hop energy\" $\\kappa_i = K_i$.\n\nA \"recrossing pair\" of hop events is a pair of adjacent hop events $(i, j)$ in the hop-event sequence with $j = i + 1$ that satisfy all of the following three conditions:\n- State return condition: $p_i = q_j$ and $q_i = p_j$.\n- Temporal proximity condition: $\\tau_j - \\tau_i \\le \\tau_{\\mathrm{tol}}$, where $\\tau_{\\mathrm{tol}}  0$ is a given time threshold.\n- Energetic proximity condition: $|\\kappa_j - \\kappa_i| \\le \\Delta K_{\\mathrm{tol}}$, where $\\Delta K_{\\mathrm{tol}} \\ge 0$ is a given energy threshold.\n\nA \"correction\" of a recrossing pair $(i, j)$ is defined as replacing the active state over the closed index interval from the first hop index to the second hop index by the pre-hop state of the first hop, that is, setting $s_k \\leftarrow p_i$ for all integer indices $k$ with $i \\le k \\le j$. After any correction is applied, the hop-event sequence is implicitly updated by the new state sequence. The process of detecting and correcting recrossing pairs is to be applied iteratively until no recrossing pairs remain.\n\nYour task is to implement this recrossing detection-and-correction rule and to report, for each trajectory, the total number of recrossing pairs corrected by this iterative procedure. Times and energies may be treated as dimensionless quantities; the final answers are integers and carry no physical units.\n\nTest suite. For each test case below, you are given the sequences $(t_i)_{i=0}^{N-1}$, $(s_i)_{i=0}^{N-1}$, $(K_i)_{i=0}^{N-1}$, and thresholds $\\tau_{\\mathrm{tol}}$ and $\\Delta K_{\\mathrm{tol}}$.\n\n- Test case $1$:\n  - $t = [0.0,0.05,0.10,0.15]$\n  - $s = [0,1,0,0]$\n  - $K = [1.000,0.990,1.005,1.006]$\n  - $\\tau_{\\mathrm{tol}} = 0.06$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n- Test case $2$ (boundary equality should qualify as a recrossing):\n  - $t = [0.0,0.10,0.15,0.20]$\n  - $s = [0,1,1,0]$\n  - $K = [1.00,0.95,0.96,0.90]$\n  - $\\tau_{\\mathrm{tol}} = 0.10$, $\\Delta K_{\\mathrm{tol}} = 0.05$\n\n- Test case $3$ (fails energetic proximity, so not a recrossing):\n  - $t = [0.0,0.05,0.08]$\n  - $s = [0,1,0]$\n  - $K = [1.0,0.2,0.9]$\n  - $\\tau_{\\mathrm{tol}} = 0.05$, $\\Delta K_{\\mathrm{tol}} = 0.20$\n\n- Test case $4$ (two separated recrossings involving different states):\n  - $t = [0.0,0.02,0.04,0.06,0.08,0.10]$\n  - $s = [0,1,0,0,2,0]$\n  - $K = [0.50,0.49,0.51,0.52,0.50,0.49]$\n  - $\\tau_{\\mathrm{tol}} = 0.03$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\n- Test case $5$ (overlapping sequence of alternating recrossings):\n  - $t = [0.0,0.02,0.04,0.06,0.08]$\n  - $s = [0,1,0,1,0]$\n  - $K = [1.00,0.98,1.01,0.99,1.02]$\n  - $\\tau_{\\mathrm{tol}} = 0.03$, $\\Delta K_{\\mathrm{tol}} = 0.03$\n\nFinal output format. Your program should produce a single line of output containing a comma-separated list enclosed in square brackets with the total number of corrections for each test case in the order given, for example $[x_1,x_2,\\dots,x_5]$, where each $x_i$ is an integer.", "solution": "The problem is subjected to validation and is found to be valid. It is scientifically grounded within the field of computational chemistry, specifically concerning the post-processing of nonadiabatic molecular dynamics trajectories from methods such as Fewest Switches Surface Hopping (FSSH). The definitions are precise, objective, and mathematically well-posed, forming a complete and consistent algorithmic problem. There are no contradictions, ambiguities, or factual inaccuracies.\n\nThe task is to implement an iterative algorithm that identifies and corrects \"recrossing pairs\" of hop events in a trajectory until no such pairs remain. A trajectory is described by a time sequence $(t_i)_{i=0}^{N-1}$, an active electronic state index sequence $(s_i)_{i=0}^{N-1}$, and a nuclear kinetic energy sequence $(K_i)_{i=0}^{N-1}$.\n\nFirst, we must formalize the concept of a \"hop event.\" A hop event occurs at a time step with index $i \\in \\{1, \\dots, N-1\\}$ if the active state changes, i.e., $s_i \\neq s_{i-1}$. For each such event, we define its properties: the pre-hop state $p_i = s_{i-1}$, the post-hop state $q_i = s_i$, the hop time $\\tau_i = t_i$, and the hop energy $\\kappa_i = K_i$. We can represent a hop event as an ordered tuple of its properties, for example, $H_k = (i_k, p_{i_k}, q_{i_k}, \\tau_{i_k}, \\kappa_{i_k})$, where $k$ is the index in the sequence of hop events.\n\nNext, a \"recrossing pair\" is defined for two *adjacent* hop events in the time-ordered sequence of all hop events. Let these adjacent hops be $H_k$ and $H_{k+1}$, occurring at original trajectory indices $i_k$ and $i_{k+1}$, respectively. This pair constitutes a recrossing if it satisfies three specific conditions:\n$1.$ State return: The system must return to the initial state of the first hop. Formally, $p_{i_k} = q_{i_{k+1}}$ and $q_{i_k} = p_{i_{k+1}}$.\n$2.$ Temporal proximity: The time elapsed between the two hops must not exceed a given threshold $\\tau_{\\mathrm{tol}}  0$. Formally, $\\tau_{i_{k+1}} - \\tau_{i_k} \\le \\tau_{\\mathrm{tol}}$.\n$3.$ Energetic proximity: The absolute difference in the post-hop nuclear kinetic energies must not exceed a given threshold $\\Delta K_{\\mathrm{tol}} \\ge 0$. Formally, $|\\kappa_{i_{k+1}} - \\kappa_{i_k}| \\le \\Delta K_{\\mathrm{tol}}$.\n\nThe core of the problem is the iterative correction procedure. The process must continue until no recrossing pairs can be found in the trajectory. This implies a loop that terminates upon convergence. A deterministic algorithm is designed as follows:\n\nLet the count of corrections be $C$, initialized to $C=0$. The state sequence $s$ is treated as a mutable object.\n\n$1.$ Begin an iterative loop. This loop continues as long as a correction is made in a pass.\n$2.$ In each iteration, first generate the complete, time-ordered sequence of all hop events based on the *current* state sequence $s$. If fewer than two hops exist, no recrossing is possible, and the process terminates.\n$3.$ Scan through the sequence of adjacent hop event pairs $(H_k, H_{k+1})$.\n$4.$ For the *first* pair that satisfies all three recrossing conditions:\n    a. Apply the \"correction.\" Let the original trajectory indices of the two hops be $i_k$ and $i_{k+1}$. The state sequence is modified by setting $s_l \\leftarrow p_{i_k}$ for all indices $l$ in the closed interval $[i_k, i_{k+1}]$. This effectively erases the pair of hops and reverts the trajectory segment to the state it was in before the first hop.\n    b. Increment the total correction counter: $C \\leftarrow C + 1$.\n    c. Since the state sequence $s$ has been modified, the current list of hop events is now invalid. The scan for other recrossing pairs is halted, and the algorithm must return to step $2$ to re-evaluate the trajectory from the beginning of the iterative loop.\n$5.$ If the scan of all adjacent hop pairs completes and no recrossing pair is found, it means the trajectory is \"clean\" according to the given criteria. The iterative loop terminates.\n\nThe final value of $C$ is the result for the given trajectory. This procedure is guaranteed to terminate because each correction removes at least two hop events from the trajectory, and the initial number of possible hops is finite. By always correcting the first recrossing pair found in a sequential scan, the algorithm is deterministic and yields a unique final state and correction count.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the recrossing correction algorithm on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"t\": [0.0, 0.05, 0.10, 0.15],\n            \"s\": [0, 1, 0, 0],\n            \"K\": [1.000, 0.990, 1.005, 1.006],\n            \"tau_tol\": 0.06,\n            \"dK_tol\": 0.03,\n        },\n        {\n            \"t\": [0.0, 0.10, 0.15, 0.20],\n            \"s\": [0, 1, 1, 0],\n            \"K\": [1.00, 0.95, 0.96, 0.90],\n            \"tau_tol\": 0.10,\n            \"dK_tol\": 0.05,\n        },\n        {\n            \"t\": [0.0, 0.05, 0.08],\n            \"s\": [0, 1, 0],\n            \"K\": [1.0, 0.2, 0.9],\n            \"tau_tol\": 0.05,\n            \"dK_tol\": 0.20,\n        },\n        {\n            \"t\": [0.0, 0.02, 0.04, 0.06, 0.08, 0.10],\n            \"s\": [0, 1, 0, 0, 2, 0],\n            \"K\": [0.50, 0.49, 0.51, 0.52, 0.50, 0.49],\n            \"tau_tol\": 0.03,\n            \"dK_tol\": 0.03,\n        },\n        {\n            \"t\": [0.0, 0.02, 0.04, 0.06, 0.08],\n            \"s\": [0, 1, 0, 1, 0],\n            \"K\": [1.00, 0.98, 1.01, 0.99, 1.02],\n            \"tau_tol\": 0.03,\n            \"dK_tol\": 0.03,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_trajectory(\n            case[\"t\"], case[\"s\"], case[\"K\"], case[\"tau_tol\"], case[\"dK_tol\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_trajectory(t_sequence, s_sequence, k_sequence, tau_tol, dK_tol):\n    \"\"\"\n    Applies the iterative recrossing detection and correction algorithm.\n\n    Args:\n        t_sequence (list): Time sequence.\n        s_sequence (list): Active electronic state sequence.\n        k_sequence (list): Nuclear kinetic energy sequence.\n        tau_tol (float): Temporal proximity threshold.\n        dK_tol (float): Energetic proximity threshold.\n\n    Returns:\n        int: The total number of corrections made.\n    \"\"\"\n    s_current = list(s_sequence)  # Use a mutable copy\n    total_corrections = 0\n\n    while True:\n        # Step 1: Find all hop events in the current state sequence.\n        # A hop event is represented by a dictionary containing its properties.\n        hops = []\n        for i in range(1, len(s_current)):\n            if s_current[i] != s_current[i - 1]:\n                hop_info = {\n                    \"index\": i,  # original index in the full sequence\n                    \"p\": s_current[i - 1],  # pre-hop state\n                    \"q\": s_current[i],  # post-hop state\n                    \"tau\": t_sequence[i],  # hop time\n                    \"kappa\": k_sequence[i],  # hop energy\n                }\n                hops.append(hop_info)\n\n        # If there are fewer than 2 hops, no recrossing pairs are possible.\n        if len(hops)  2:\n            break\n\n        # Step 2: Scan for the first recrossing pair among adjacent hop events.\n        corrected_this_pass = False\n        for hop_list_index in range(len(hops) - 1):\n            hop1 = hops[hop_list_index]\n            hop2 = hops[hop_list_index + 1]\n\n            # Condition 1: State return\n            state_return_ok = hop1[\"p\"] == hop2[\"q\"] and hop1[\"q\"] == hop2[\"p\"]\n\n            # Condition 2: Temporal proximity\n            temporal_prox_ok = hop2[\"tau\"] - hop1[\"tau\"] = tau_tol\n\n            # Condition 3: Energetic proximity\n            energetic_prox_ok = np.abs(hop2[\"kappa\"] - hop1[\"kappa\"]) = dK_tol\n\n            if state_return_ok and temporal_prox_ok and energetic_prox_ok:\n                # A recrossing pair is found.\n                total_corrections += 1\n                corrected_this_pass = True\n                \n                # Retrieve the original indices for the state sequence modification.\n                start_index = hop1[\"index\"]\n                end_index = hop2[\"index\"]\n                \n                # The state to revert to is the pre-hop state of the first hop.\n                correction_state = hop1[\"p\"]\n                \n                # Apply the correction to the state sequence over the closed interval.\n                # A list slice assignment is used for efficient replacement.\n                num_elements_to_replace = end_index - start_index + 1\n                s_current[start_index : end_index + 1] = [\n                    correction_state\n                ] * num_elements_to_replace\n                \n                # As the state sequence has changed, the 'hops' list is now invalid.\n                # Break the inner loop to restart the process and regenerate the hops list.\n                break\n        \n        # If no corrections were made after checking all hop pairs, the process has converged.\n        if not corrected_this_pass:\n            break\n            \n    return total_corrections\n\nsolve()\n```", "id": "2463206"}]}