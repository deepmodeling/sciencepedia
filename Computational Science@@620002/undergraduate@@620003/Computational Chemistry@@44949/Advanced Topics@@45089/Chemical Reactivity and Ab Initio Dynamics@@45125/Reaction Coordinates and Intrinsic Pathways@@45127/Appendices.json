{"hands_on_practices": [{"introduction": "In computational chemistry, the concept of a \"path of steepest descent\" is only physically meaningful on a potential energy surface expressed in mass-weighted coordinates. This exercise confronts a common conceptual hurdle by asking you to compare the true, mass-weighted Intrinsic Reaction Coordinate (IRC) with a faulty path derived from unweighted Cartesian coordinates [@problem_id:2461314]. By implementing both and observing their trajectories, you will gain a crucial, first-hand understanding of why proper mass-weighting is not just a theoretical subtlety, but a practical necessity for correctly predicting reaction outcomes.", "problem": "You are given a two-dimensional Potential Energy Surface (PES) defined on coordinates $\\mathbf{r}=(x,y)$ by the scalar field\n$$\nV(x,y) \\;=\\; A\\,x^4 \\;-\\; B\\,x^2 \\;+\\; C\\,y^2 \\;+\\; D\\,x\\,y,\n$$\nwith positive parameters $A>0$, $B>0$, $C>0$, and real coupling parameter $D$. Consider a system of two degrees of freedom with a diagonal mass matrix $\\mathbf{M}=\\mathrm{diag}(m_1,m_2)$, where $m_1>0$ and $m_2>0$.\n\nFor the Intrinsic Reaction Coordinate (IRC), use the first-principles definition: the correct IRC is the steepest-descent flow of $V$ in mass-weighted coordinates $\\mathbf{R}=\\mathbf{M}^{1/2}\\mathbf{r}$, that is,\n$$\n\\frac{d\\mathbf{R}}{ds} \\;=\\; - \\nabla_{\\mathbf{R}} V(\\mathbf{R}),\n$$\nwith $s$ an arclength-like path parameter. Equivalently, in Cartesian coordinates this flow is\n$$\n\\frac{d\\mathbf{r}}{ds} \\;=\\; - \\mathbf{M}^{-1}\\,\\nabla_{\\mathbf{r}} V(\\mathbf{r}).\n$$\nA faulty algorithm ignores mass-weighting and instead follows the non-mass-weighted Cartesian steepest-descent flow\n$$\n\\frac{d\\mathbf{r}}{ds} \\;=\\; - \\nabla_{\\mathbf{r}} V(\\mathbf{r}).\n$$\n\nAt the saddle point $(x,y)=(0,0)$, define the Hessian in Cartesian coordinates $\\mathbf{H}=\\nabla^2_{\\mathbf{r}} V\\big|_{(0,0)}$ and the mass-weighted Hessian $\\mathbf{H}_{\\mathrm{mw}}=\\mathbf{M}^{-1/2}\\,\\mathbf{H}\\,\\mathbf{M}^{-1/2}$. For an initial condition, displace from $(0,0)$ by a small amount $\\varepsilon>0$ along the unstable normal mode (the eigenvector associated with the unique negative eigenvalue) of the corresponding Hessian, using the following orientation conventions:\n- For the correct IRC flow, orient the mass-weighted unstable mode so that its $x$-component in Cartesian coordinates is positive.\n- For the faulty flow, orient the unweighted unstable mode so that its $y$-component is positive.\n\nLet the trajectory evolve under each flow from its respective initial condition toward its terminal attractor (stable critical point). Classify the terminal attractor by which analytic minimum it approaches. The two symmetry-related minima for the given PES occur at\n$$\nx_{\\min}^\\star \\;=\\; \\pm \\sqrt{\\frac{2B + \\frac{D^2}{2C}}{4A}}, \n\\qquad\ny_{\\min}^\\star \\;=\\; -\\frac{D}{2C}\\,x_{\\min}^\\star,\n$$\nprovided $2B + \\frac{D^2}{2C} > 0$ (which is guaranteed by the test parameters below). Define the label of a minimum to be $+1$ if it is closer (in Euclidean distance) to the minimum with $x_{\\min}^\\star>0$, and $-1$ if it is closer to the minimum with $x_{\\min}^\\star<0$.\n\nFor each test case below, determine whether the faulty flow connects to the same labeled minimum as the correct IRC flow. For each test case, output a boolean value equal to $\\mathrm{True}$ if the faulty flow fails to connect to the same labeled minimum as the correct IRC flow, and $\\mathrm{False}$ otherwise.\n\nUse the following test suite of parameter sets $(A,B,C,D,m_1,m_2)$:\n- Test 1: $(A,B,C,D,m_1,m_2) = (1.0, 1.0, 1.0, 0.5, 1.0, 1.0)$.\n- Test 2: $(A,B,C,D,m_1,m_2) = (1.0, 1.0, 0.5, -1.0, 1.0, 50.0)$.\n- Test 3: $(A,B,C,D,m_1,m_2) = (1.0, 1.0, 2.0, 0.2, 5.0, 0.5)$.\n\nConventions and requirements:\n- Use the same small displacement magnitude $\\varepsilon = 10^{-3}$ for both flows.\n- The initial point for each flow is $(x,y)=\\varepsilon\\,\\mathbf{v}$, where $\\mathbf{v}$ is the appropriately oriented unstable mode expressed in Cartesian coordinates, normalized to unit length before scaling by $\\varepsilon$.\n- The output for the entire program should be a single line containing a list of three boolean values in the order of the tests, formatted as a Python-style list with no spaces, for example: \"[False,True,False]\".\n\nYour program should produce exactly one line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, in the order given: $[\\mathrm{result\\_1},\\mathrm{result\\_2},\\mathrm{result\\_3}]$.", "solution": "The problem requires a comparison between two dynamical pathways on a two-dimensional Potential Energy Surface (PES), $V(x,y)$. The first path is the true Intrinsic Reaction Coordinate (IRC), defined as the steepest-descent path in mass-weighted coordinates. The second is a faulty approximation that follows the steepest-descent path in non-mass-weighted Cartesian coordinates. We must determine if these two paths, starting from the vicinity of the saddle point at $(0,0)$, terminate at the same symmetry-related potential minimum.\n\nThe potential energy surface is given by\n$$ V(x,y) = A\\,x^4 - B\\,x^2 + C\\,y^2 + D\\,x\\,y $$\nwith positive parameters $A, B, C$. The system has two degrees of freedom with coordinates $\\mathbf{r} = (x,y)$ and a diagonal mass matrix $\\mathbf{M} = \\mathrm{diag}(m_1, m_2)$.\n\nFirst, we establish the equations of motion for the two flows. The gradient of the potential in Cartesian coordinates is\n$$ \\nabla_{\\mathbf{r}} V(\\mathbf{r}) = \\begin{pmatrix} \\frac{\\partial V}{\\partial x} \\\\ \\frac{\\partial V}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 4Ax^3 - 2Bx + Dy \\\\ 2Cy + Dx \\end{pmatrix}. $$\nThe correct IRC flow is governed by the differential equation\n$$ \\frac{d\\mathbf{r}}{ds} = - \\mathbf{M}^{-1} \\nabla_{\\mathbf{r}} V(\\mathbf{r}), $$\nwhere $s$ is a path parameter and $\\mathbf{M}^{-1} = \\mathrm{diag}(1/m_1, 1/m_2)$.\nThe faulty flow follows the simpler equation\n$$ \\frac{d\\mathbf{r}}{ds} = - \\nabla_{\\mathbf{r}} V(\\mathbf{r}). $$\n\nThe initial conditions for these flows are defined by infinitesimal displacements from the saddle point at $\\mathbf{r}_0 = (0,0)$ along the unstable normal modes of the relevant Hessian matrices.\n\nThe Cartesian Hessian matrix $\\mathbf{H}$ at the saddle point is\n$$ \\mathbf{H} = \\nabla^2_{\\mathbf{r}} V\\big|_{(0,0)} = \\begin{pmatrix} \\frac{\\partial^2 V}{\\partial x^2} & \\frac{\\partial^2 V}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 V}{\\partial y \\partial x} & \\frac{\\partial^2 V}{\\partial y^2} \\end{pmatrix}_{\\mathbf{r}=(0,0)} = \\begin{pmatrix} -2B & D \\\\ D & 2C \\end{pmatrix}. $$\nThe determinant of $\\mathbf{H}$ is $-4BC - D^2$, which is strictly negative for $B, C > 0$. This guarantees one negative and one positive eigenvalue, corresponding to one unstable and one stable mode. The faulty-flow initial condition is determined by the eigenvector of $\\mathbf{H}$ corresponding to its negative eigenvalue. Let this eigenvector be $\\mathbf{v}_{\\mathrm{faulty}}$. It is normalized to unit length, oriented such that its $y$-component is positive, and scaled by $\\varepsilon = 10^{-3}$ to give the initial position $\\mathbf{r}_{0, \\mathrm{faulty}} = \\varepsilon \\mathbf{v}_{\\mathrm{faulty}}$.\n\nThe mass-weighted Hessian $\\mathbf{H}_{\\mathrm{mw}}$ is defined as\n$$ \\mathbf{H}_{\\mathrm{mw}} = \\mathbf{M}^{-1/2} \\mathbf{H} \\mathbf{M}^{-1/2} = \\begin{pmatrix} \\frac{-2B}{m_1} & \\frac{D}{\\sqrt{m_1 m_2}} \\\\ \\frac{D}{\\sqrt{m_1 m_2}} & \\frac{2C}{m_2} \\end{pmatrix}, $$\nwhere $\\mathbf{M}^{-1/2} = \\mathrm{diag}(1/\\sqrt{m_1}, 1/\\sqrt{m_2})$. The determinant of $\\mathbf{H}_{\\mathrm{mw}}$ is $(-4BC - D^2)/(m_1 m_2)$, which is also always negative, guaranteeing a unique unstable mode. The correct-flow initial condition is determined by the eigenvector of $\\mathbf{H}_{\\mathrm{mw}}$ corresponding to its negative eigenvalue. Let this eigenvector (in mass-weighted coordinates) be $\\mathbf{u}_{\\mathrm{correct}}$. It must be converted back to Cartesian coordinates via $\\mathbf{v}_{\\mathrm{correct}} = \\mathbf{M}^{-1/2} \\mathbf{u}_{\\mathrm{correct}}$. This Cartesian vector is then normalized, oriented such that its $x$-component is positive, and scaled by $\\varepsilon$ to give the initial position $\\mathbf{r}_{0, \\mathrm{correct}} = \\varepsilon \\mathbf{v}_{\\mathrm{correct}}$.\n\nWith the ODEs and initial conditions defined, we numerically integrate both systems forward in the path parameter $s$ until they converge to a stable critical point of the PES, i.e., a point where $\\nabla_{\\mathbf{r}} V = \\mathbf{0}$. These are the potential energy minima. For this task, a robust numerical ODE solver, `scipy.integrate.solve_ivp`, is employed.\n\nThe potential $V(x,y)$ has two minima, located at positions $(\\pm x_{\\min}^\\star, y_{\\min, \\pm}^\\star)$ where\n$$ x_{\\min}^\\star = \\sqrt{\\frac{2B + D^2/(2C)}{4A}}, \\quad y_{\\min}^\\star = -\\frac{D}{2C} x_{\\min}^\\star. $$\nLet us denote the minimum with a positive $x$-coordinate as $\\mathbf{r}_{\\min, +1}$ and the one with a negative $x$-coordinate as $\\mathbf{r}_{\\min, -1}$. The terminal point of each flow, $\\mathbf{r}_{\\mathrm{final}}$, is classified by assigning it a label of $+1$ if it is closer in Euclidean distance to $\\mathbf{r}_{\\min, +1}$, and $-1$ if it is closer to $\\mathbf{r}_{\\min, -1}$.\n\nFor each set of parameters $(A, B, C, D, m_1, m_2)$, we perform the following procedure:\n1.  Compute $\\mathbf{H}$ and $\\mathbf{H}_{\\mathrm{mw}}$.\n2.  Find the unstable eigenvectors $\\mathbf{v}_{\\mathrm{faulty}}$ and $\\mathbf{v}_{\\mathrm{correct}}$ in Cartesian coordinates, applying the specified orientation rules.\n3.  Determine the initial positions $\\mathbf{r}_{0, \\mathrm{faulty}}$ and $\\mathbf{r}_{0, \\mathrm{correct}}$.\n4.  Numerically solve the ODEs for both flows to find the terminal points $\\mathbf{r}_{\\mathrm{final, faulty}}$ and $\\mathbf{r}_{\\mathrm{final, correct}}$.\n5.  Compute the locations of the two minima, $\\mathbf{r}_{\\min, +1}$ and $\\mathbf{r}_{\\min, -1}$.\n6.  Assign labels $L_{\\mathrm{faulty}}$ and $L_{\\mathrm{correct}}$ by comparing the distances of the terminal points to the two minima.\n7.  The result for the test case is the boolean value of the expression $L_{\\mathrm{faulty}} \\neq L_{\\mathrm{correct}}$.\n\nThis entire logic is implemented in a Python script, which iterates through the provided test cases and generates the final list of boolean values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (A,   B,   C,   D,   m1,  m2)\n        (1.0, 1.0, 1.0,  0.5, 1.0,  1.0),\n        (1.0, 1.0, 0.5, -1.0, 1.0, 50.0),\n        (1.0, 1.0, 2.0,  0.2, 5.0,  0.5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_case(params)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_case(params):\n    \"\"\"\n    Solves a single test case.\n    \n    For each test case, determines whether the faulty flow fails to connect to the\n    same labeled minimum as the correct IRC flow. Returns True if they fail\n    (connect to different minima), False otherwise.\n    \"\"\"\n    A, B, C, D, m1, m2 = params\n    epsilon = 1e-3\n\n    # =========================================================================\n    # Step 1: Define PES, gradient, and analytical minima locations\n    # =========================================================================\n    def grad_V(r):\n        x, y = r\n        gx = 4 * A * x**3 - 2 * B * x + D * y\n        gy = 2 * C * y + D * x\n        return np.array([gx, gy])\n\n    x_min_sq_val = (2 * B + D**2 / (2 * C)) / (4 * A)\n    x_min_pos = np.sqrt(x_min_sq_val)\n    y_min_pos = -D / (2 * C) * x_min_pos\n    min_p1 = np.array([x_min_pos, y_min_pos])\n    min_m1 = -min_p1\n\n    # =========================================================================\n    # Step 2: Determine initial conditions for both flows\n    # =========================================================================\n    H = np.array([[-2 * B, D], [D, 2 * C]])\n    \n    # --- Faulty (unweighted) flow initial condition ---\n    eigvals_faulty, eigvecs_faulty = np.linalg.eig(H)\n    unstable_idx_faulty = np.argmin(eigvals_faulty)\n    v_faulty = eigvecs_faulty[:, unstable_idx_faulty].real\n\n    v_faulty /= np.linalg.norm(v_faulty)\n    if v_faulty[1] < 0:\n        v_faulty = -v_faulty\n    \n    r0_faulty = epsilon * v_faulty\n\n    # --- Correct (mass-weighted) IRC flow initial condition ---\n    M_inv_sqrt = np.diag([1/np.sqrt(m1), 1/np.sqrt(m2)])\n    H_mw = M_inv_sqrt @ H @ M_inv_sqrt\n    \n    eigvals_mw, eigvecs_mw = np.linalg.eig(H_mw)\n    unstable_idx_mw = np.argmin(eigvals_mw)\n    u_correct = eigvecs_mw[:, unstable_idx_mw].real # Eigenvector in mass-weighted coords\n\n    v_correct = M_inv_sqrt @ u_correct # Convert to Cartesian coords\n    \n    v_correct /= np.linalg.norm(v_correct)\n    if v_correct[0] < 0:\n        v_correct = -v_correct\n    \n    r0_correct = epsilon * v_correct\n\n    # =========================================================================\n    # Step 3: Simulate the flows using an ODE solver\n    # =========================================================================\n    def ode_faulty(t, r):\n        return -grad_V(r)\n    \n    M_inv = np.diag([1/m1, 1/m2])\n    def ode_correct(t, r):\n        return -M_inv @ grad_V(r)\n    \n    t_span = [0, 500]\n    t_eval = [t_span[1]]\n    \n    # We only care about the final state, so we evaluate only there.\n    # High tolerance is used for accuracy near the minimum.\n    sol_faulty = solve_ivp(ode_faulty, t_span, r0_faulty, method='RK45', \n                           t_eval=t_eval, atol=1e-9, rtol=1e-9)\n    r_final_faulty = sol_faulty.y[:, -1]\n\n    sol_correct = solve_ivp(ode_correct, t_span, r0_correct, method='RK45', \n                            t_eval=t_eval, atol=1e-9, rtol=1e-9)\n    r_final_correct = sol_correct.y[:, -1]\n\n    # =========================================================================\n    # Step 4: Classify the terminal attractors\n    # =========================================================================\n    def get_label(r_final):\n        \"\"\"Assigns label +1 or -1 based on proximity to analytical minima.\"\"\"\n        dist_to_p1 = np.linalg.norm(r_final - min_p1)\n        dist_to_m1 = np.linalg.norm(r_final - min_m1)\n        return 1 if dist_to_p1 < dist_to_m1 else -1\n\n    label_faulty = get_label(r_final_faulty)\n    label_correct = get_label(r_final_correct)\n\n    # =========================================================================\n    # Step 5: Compare labels and return the boolean result\n    # =========================================================================\n    return label_faulty != label_correct\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2461314"}, {"introduction": "Having established the importance of mass-weighting, we now turn to the practical implementation of an IRC calculation. This exercise guides you in building an algorithm to trace the minimum energy path for a model of the ammonia umbrella inversion, a classic example of a chemical transformation [@problem_id:2461292]. You will apply the fundamental principles of IRC theory—from analyzing the mass-weighted Hessian at the transition state to iteratively following the steepest-descent path—to explore how the reaction path's geometry arises from the interplay between potential energy and atomic masses.", "problem": "You will implement a program to compute an approximation of the Intrinsic Reaction Coordinate (IRC) for the umbrella inversion of ammonia using a reduced two-mode model and to classify whether the IRC is straight or curved in mass-weighted coordinates. The IRC is defined as the steepest-descent path on the potential energy surface when expressed in mass-weighted Cartesian coordinates. You must base your implementation on first principles and well-tested definitions, as specified below, and produce a single-line output summarizing classification results for a small test suite.\n\nFundamental base and definitions to use:\n- In the reduced model, use two generalized coordinates: $x$ for the inversion (umbrella) coordinate and $y$ for a coupled totally symmetric stretch coordinate. The potential energy surface is specified as\n$$\nV(x,y) = A\\,(x^2 - x_0^2)^2 + \\tfrac{1}{2}k\\,y^2 + \\alpha\\,x^2\\,y,\n$$\nwith $A$, $x_0$, $k$, and $\\alpha$ being real constants.\n- Let the mass matrix be diagonal with entries $m_x$ and $m_y$ for $x$ and $y$, respectively. Define mass-weighted coordinates $\\mathbf{Q} = (Q_x,Q_y)$ by $Q_x = \\sqrt{m_x}\\,x$ and $Q_y = \\sqrt{m_y}\\,y$.\n- The mass-weighted gradient is defined by the chain rule as $\\nabla_{\\mathbf{Q}} V = \\left(\\frac{\\partial V}{\\partial Q_x}, \\frac{\\partial V}{\\partial Q_y}\\right) = \\left(\\frac{1}{\\sqrt{m_x}}\\frac{\\partial V}{\\partial x}, \\frac{1}{\\sqrt{m_y}}\\frac{\\partial V}{\\partial y}\\right)$.\n- The IRC is the steepest-descent path in $\\mathbf{Q}$-space parameterized by the mass-weighted arc length $s$, satisfying unit-speed descent:\n$$\n\\frac{d\\mathbf{Q}}{ds} = -\\frac{\\nabla_{\\mathbf{Q}} V(\\mathbf{Q})}{\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q})\\rVert}.\n$$\n- The transition state (TS) for this model is at $(x,y)=(0,0)$. The initial IRC direction is given by the eigenvector corresponding to the negative eigenvalue of the mass-weighted Hessian at the TS. The mass-weighted Hessian is $H_{\\mathbf{Q}} = M^{-1/2}\\,H\\,M^{-1/2}$, where $H$ is the Hessian with respect to $(x,y)$ and $M=\\mathrm{diag}(m_x,m_y)$.\n- The curvature $\\kappa(s)$ of a unit-speed curve $\\mathbf{Q}(s)$ is the norm of the derivative of the unit tangent $\\mathbf{T}(s)$ with respect to arc length:\n$$\n\\kappa(s) = \\left\\lVert \\frac{d\\mathbf{T}}{ds}\\right\\rVert,\\quad \\text{where } \\mathbf{T}(s) = \\frac{d\\mathbf{Q}}{ds}.\n$$\nNumerically, with a discrete step $\\Delta s$, you may approximate $\\kappa$ at step $n$ by $\\kappa_n \\approx \\lVert \\mathbf{T}_{n+1}-\\mathbf{T}_n\\rVert / \\Delta s$.\n\nComputational task:\n- For each parameter set in the test suite, construct the IRC branches on both sides of the TS starting from $\\mathbf{Q}_0=(0,0)$ by taking an initial displacement of length $\\Delta s$ along $\\pm \\hat{\\mathbf{v}}_{\\mathrm{TS}}$, where $\\hat{\\mathbf{v}}_{\\mathrm{TS}}$ is the unit unstable eigenvector of $H_{\\mathbf{Q}}$ at the TS. Then iteratively step according to the unit-speed steepest-descent direction until the mass-weighted gradient norm falls below a specified threshold $\\varepsilon$ or a maximum number of steps is reached.\n- Along each branch, compute the discrete curvature sequence and take the maximum curvature $\\kappa_{\\max}$ observed on that branch. Combine the two branches by taking the overall maximum curvature across both branches.\n- Classify the IRC for that parameter set as straight if $\\kappa_{\\max} \\le \\tau$ and curved if $\\kappa_{\\max} > \\tau$, where $\\tau$ is a given curvature tolerance.\n- You must implement all quantities strictly from the definitions above. No external data files are allowed.\n\nNumerical details:\n- Use $x$ and $y$ in ångström ($\\mathrm{\\AA}$), $m_x$ and $m_y$ in atomic mass units (amu), and energy in consistent arbitrary units. The curvature threshold $\\tau$ is in inverse mass-weighted length units, that is $\\mathrm{\\AA}^{-1}\\,\\mathrm{amu}^{-1/2}$. The program’s final answers are booleans and therefore do not carry units.\n\nTest suite:\nFor all cases, use step length $\\Delta s = 0.002$, gradient norm threshold $\\varepsilon = 10^{-8}$, and maximum steps $N_{\\max} = 5000$. The parameters $(A,x_0,k,\\alpha,m_x,m_y)$ are:\n- Case 1: $A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.0$, $m_x=1.0$, $m_y=1.0$, curvature threshold $\\tau=10^{-3}$.\n- Case 2: $A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.5$, $m_x=1.0$, $m_y=1.0$, curvature threshold $\\tau=10^{-3}$.\n- Case 3: $A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=0.5$, $m_x=1.0$, $m_y=9.0$, curvature threshold $\\tau=10^{-3}$.\n- Case 4: $A=10.0$, $x_0=0.5$, $k=5.0$, $\\alpha=2.0$, $m_x=1.0$, $m_y=1.0$, curvature threshold $\\tau=10^{-3}$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the classification results for the four cases as a comma-separated list of booleans enclosed in square brackets (e.g., `[False,True,...]`), but with no whitespace, that is exactly of the form `[result1,result2,result3,result4]` where each `result` is either `True` or `False`.\n\nNo user input should be read by the program. The program must be fully deterministic and self-contained. The final printed line must strictly match the specified format.", "solution": "The problem presented is valid. It is a well-posed, scientifically grounded exercise in computational chemistry concerning the calculation of an Intrinsic Reaction Coordinate (IRC) and its geometric properties. All necessary parameters, definitions, and algorithmic procedures are provided, allowing for a unique and verifiable solution. We shall proceed with the derivation and implementation.\n\nThe objective is to compute an approximation of the IRC for a two-dimensional model potential energy surface (PES) and classify its path as either straight or curved based on its maximum curvature in mass-weighted coordinates.\n\nThe PES is given by the function $V(x,y)$:\n$$\nV(x,y) = A(x^2 - x_0^2)^2 + \\frac{1}{2}ky^2 + \\alpha x^2 y\n$$\nwhere $x$ and $y$ are generalized coordinates. To follow the IRC, which is a steepest-descent path, we require the gradient of the potential. The components of the gradient $\\nabla V = \\left(\\frac{\\partial V}{\\partial x}, \\frac{\\partial V}{\\partial y}\\right)$ are:\n$$\n\\frac{\\partial V}{\\partial x} = 4A(x^2 - x_0^2)(2x) + 2\\alpha xy = 4A(x^3 - x_0^2 x) + 2\\alpha xy\n$$\n$$\n\\frac{\\partial V}{\\partial y} = ky + \\alpha x^2\n$$\nThe IRC is defined in mass-weighted coordinates $\\mathbf{Q} = (Q_x, Q_y)$, where $Q_x = \\sqrt{m_x} x$ and $Q_y = \\sqrt{m_y} y$. The mass matrix is $M = \\text{diag}(m_x, m_y)$. The gradient in these coordinates, $\\nabla_{\\mathbf{Q}} V$, is obtained through the chain rule:\n$$\n\\nabla_{\\mathbf{Q}} V = \\left(\\frac{\\partial V}{\\partial Q_x}, \\frac{\\partial V}{\\partial Q_y}\\right) = \\left(\\frac{1}{\\sqrt{m_x}}\\frac{\\partial V}{\\partial x}, \\frac{1}{\\sqrt{m_y}}\\frac{\\partial V}{\\partial y}\\right)\n$$\nThe IRC path $\\mathbf{Q}(s)$, parameterized by the mass-weighted arc length $s$, is governed by the differential equation for unit-speed steepest descent:\n$$\n\\frac{d\\mathbf{Q}}{ds} = -\\frac{\\nabla_{\\mathbf{Q}} V(\\mathbf{Q})}{\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q})\\rVert} \\equiv \\mathbf{T}(\\mathbf{Q})\n$$\nwhere $\\mathbf{T}(\\mathbf{Q})$ is the unit tangent vector to the path.\n\nThe path begins at the transition state (TS), which is a first-order saddle point on the PES. The problem states the TS is at $(x,y)=(0,0)$. At this point, the gradient components are $\\frac{\\partial V}{\\partial x}|_{(0,0)} = 0$ and $\\frac{\\partial V}{\\partial y}|_{(0,0)} = 0$, confirming it is a stationary point.\n\nTo determine the character of this stationary point and the initial direction of the IRC, we must analyze the Hessian matrix of second derivatives. The Hessian in $(x,y)$ coordinates is:\n$$\nH = \\begin{pmatrix} \\frac{\\partial^2 V}{\\partial x^2} & \\frac{\\partial^2 V}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 V}{\\partial y \\partial x} & \\frac{\\partial^2 V}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} 12Ax^2 - 4Ax_0^2 + 2\\alpha y & 2\\alpha x \\\\ 2\\alpha x & k \\end{pmatrix}\n$$\nAt the TS $(x,y)=(0,0)$, the Hessian simplifies to:\n$$\nH(0,0) = \\begin{pmatrix} -4Ax_0^2 & 0 \\\\ 0 & k \\end{pmatrix}\n$$\nThe corresponding mass-weighted Hessian is $H_{\\mathbf{Q}} = M^{-1/2}HM^{-1/2}$. At the TS, this is:\n$$\nH_{\\mathbf{Q}}(0,0) = \\begin{pmatrix} 1/\\sqrt{m_x} & 0 \\\\ 0 & 1/\\sqrt{m_y} \\end{pmatrix} \\begin{pmatrix} -4Ax_0^2 & 0 \\\\ 0 & k \\end{pmatrix} \\begin{pmatrix} 1/\\sqrt{m_x} & 0 \\\\ 0 & 1/\\sqrt{m_y} \\end{pmatrix} = \\begin{pmatrix} -4Ax_0^2/m_x & 0 \\\\ 0 & k/m_y \\end{pmatrix}\n$$\nFor the given parameters, $A > 0$ and $k > 0$, hence $H_{\\mathbf{Q}}(0,0)$ has one negative eigenvalue, $\\lambda_1 = -4Ax_0^2/m_x$, and one positive eigenvalue, $\\lambda_2 = k/m_y$. This confirms the TS is a first-order saddle point. The eigenvector corresponding to the negative eigenvalue, the unstable mode, defines the initial direction of the IRC. For this diagonal Hessian, the normalized eigenvector is simply $\\hat{\\mathbf{v}}_{\\mathrm{TS}} = (1, 0)^T$.\n\nThe IRC is traced numerically using a forward Euler integration scheme. Two branches are generated, starting with an initial displacement of $\\Delta s$ from the TS along the directions $\\pm \\hat{\\mathbf{v}}_{\\mathrm{TS}}$. The first points on the two branches are $\\mathbf{Q}_1^{\\pm} = (0,0) \\pm \\Delta s \\cdot \\hat{\\mathbf{v}}_{\\mathrm{TS}} = (\\pm \\Delta s, 0)^T$. From each of these starting points, the path is propagated iteratively:\n$$\n\\mathbf{Q}_{n+1} = \\mathbf{Q}_n + \\Delta s \\cdot \\mathbf{T}(\\mathbf{Q}_n)\n$$\nThe iteration continues until the norm of the mass-weighted gradient $\\lVert \\nabla_{\\mathbf{Q}} V(\\mathbf{Q}_n)\\rVert$ falls below a threshold $\\varepsilon$, or a maximum number of steps $N_{\\max}$ is reached.\n\nThe curvature $\\kappa$ of the path measures its deviation from a straight line. It is defined as the magnitude of the rate of change of the unit tangent vector with respect to arc length: $\\kappa(s) = \\lVert d\\mathbf{T}/ds \\rVert$. Numerically, for a sequence of tangent vectors $\\mathbf{T}_n$ computed at each step, the curvature is approximated using a finite difference:\n$$\n\\kappa_n \\approx \\frac{\\lVert \\mathbf{T}_{n+1} - \\mathbf{T}_n \\rVert}{\\Delta s}\n$$\nwhere $\\mathbf{T}_n$ is the tangent vector at point $\\mathbf{Q}_n$. The maximum curvature $\\kappa_{\\max}$ is found by taking the maximum value of $\\kappa_n$ over the entire path, comprising both branches.\n\nFinally, the IRC is classified as \"curved\" if $\\kappa_{\\max} > \\tau$ and \"straight\" if $\\kappa_{\\max} \\le \\tau$, where $\\tau$ is a given tolerance. For the special case where the coupling constant $\\alpha = 0$, the potential is separable in $x$ and $y$. The initial displacement is along the $Q_x$ axis, and since the gradient component along $Q_y$ will always be zero if $y=0$, the path remains confined to the $Q_x$ axis. The tangent vector does not change direction, resulting in zero curvature. For $\\alpha \\neq 0$, the $x$ and $y$ motions are coupled. The gradient at a point with $y=0$ but $x \\neq 0$ has a non-zero $y$-component, causing the path to curve into the $Q_y$ dimension. The extent of this curvature depends on the parameters $\\alpha$, $m_x$, and $m_y$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes an approximation of the Intrinsic Reaction Coordinate (IRC) for a\n    model system, calculates its maximum curvature, and classifies it as\n    'straight' or 'curved' based on a threshold.\n    \"\"\"\n\n    # Test suite: (A, x0, k, alpha, mx, my, tau)\n    test_cases = [\n        (10.0, 0.5, 5.0, 0.0, 1.0, 1.0, 1e-3),\n        (10.0, 0.5, 5.0, 0.5, 1.0, 1.0, 1e-3),\n        (10.0, 0.5, 5.0, 0.5, 1.0, 9.0, 1e-3),\n        (10.0, 0.5, 5.0, 2.0, 1.0, 1.0, 1e-3),\n    ]\n\n    # Numerical parameters\n    delta_s = 0.002\n    epsilon = 1e-8\n    N_max = 5000\n\n    results = []\n\n    for A, x0, k, alpha, mx, my, tau in test_cases:\n        \n        sqrt_mx = np.sqrt(mx)\n        sqrt_my = np.sqrt(my)\n\n        def to_xy(Q):\n            \"\"\"Converts mass-weighted coordinates Q to standard coordinates (x, y).\"\"\"\n            return Q[0] / sqrt_mx, Q[1] / sqrt_my\n\n        def grad_V(x, y):\n            \"\"\"Computes the gradient of V(x, y) in standard coordinates.\"\"\"\n            dv_dx = 4.0 * A * (x**3 - x0**2 * x) + 2.0 * alpha * x * y\n            dv_dy = k * y + alpha * x**2\n            return np.array([dv_dx, dv_dy])\n\n        def mass_weighted_grad_V(Q):\n            \"\"\"Computes the gradient of V in mass-weighted coordinates.\"\"\"\n            x, y = to_xy(Q)\n            grad_xy = grad_V(x, y)\n            return np.array([grad_xy[0] / sqrt_mx, grad_xy[1] / sqrt_my])\n\n        def get_max_kappa_for_branch(initial_direction):\n            \"\"\"\n            Follows one branch of the IRC and computes its maximum curvature.\n            initial_direction is +1.0 for the forward branch, -1.0 for backward.\n            \"\"\"\n            # Initial point displaced from TS along the unstable mode\n            q = np.array([initial_direction * delta_s, 0.0])\n            \n            tangents = []\n            \n            for _ in range(N_max):\n                grad_q = mass_weighted_grad_V(q)\n                grad_norm = np.linalg.norm(grad_q)\n\n                # Check for convergence to a minimum\n                if grad_norm < epsilon:\n                    break\n                \n                # Calculate unit tangent vector\n                t = -grad_q / grad_norm\n                tangents.append(t)\n                \n                # Take Euler step\n                q = q + delta_s * t\n\n            # If the path is too short to compute curvature, curvature is 0\n            if len(tangents) < 2:\n                return 0.0\n            \n            # Compute discrete curvature along the path\n            kappas = []\n            for i in range(len(tangents) - 1):\n                # kappa_n = ||T_{n+1} - T_n|| / delta_s\n                kappa = np.linalg.norm(tangents[i+1] - tangents[i]) / delta_s\n                kappas.append(kappa)\n\n            return max(kappas) if kappas else 0.0\n\n        # Compute max curvature for both branches\n        kappa_max_fwd = get_max_kappa_for_branch(1.0)\n        kappa_max_bwd = get_max_kappa_for_branch(-1.0)\n        \n        # The overall maximum curvature is the max of the two branches\n        kappa_max = max(kappa_max_fwd, kappa_max_bwd)\n        \n        # Classify based on the threshold tau\n        # True for curved, False for straight\n        is_curved = kappa_max > tau\n        results.append(is_curved)\n\n    # Final print statement in the exact required format.\n    # e.g., [True,False,False,True]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2461292"}, {"introduction": "After learning to compute an IRC path, the final step is to interpret what it means chemically. This practice tackles that challenge by analyzing the IRC vector for HCN isomerization, where you will learn to dissect the complex, multi-atom motion of the reaction coordinate by projecting it onto a simple, intuitive internal coordinate [@problem_id:2461347]. This skill is essential for analyzing computational results and describing the mechanism of a chemical reaction in familiar physical terms, such as the contribution from a specific bond stretch.", "problem": "Consider the isomerization of hydrogen cyanide (HCN) to hydrogen isocyanide (HNC) as a reaction on a potential energy surface with a first-order saddle point (transition state). The intrinsic reaction coordinate (IRC) tangent at the transition state is defined to be the normalized eigenvector associated with the single negative eigenvalue of the mass-weighted Hessian. Let the molecule consist of three atoms hydrogen (H), carbon (C), and nitrogen (N), labeled in that order. For any Cartesian displacement vector $x \\in \\mathbb{R}^{9}$ (ordered as $[x_{\\mathrm{H}x},x_{\\mathrm{H}y},x_{\\mathrm{H}z},x_{\\mathrm{C}x},x_{\\mathrm{C}y},x_{\\mathrm{C}z},x_{\\mathrm{N}x},x_{\\mathrm{N}y},x_{\\mathrm{N}z}]$), define the mass-weighted coordinates $q$ by $q = M^{1/2} x$, where $M^{1/2}$ is the diagonal matrix with entries $\\sqrt{m_i}$ duplicated for each of the three Cartesian components of atom $i$, and $m_i$ are the atomic masses. All lengths must be expressed in angstroms and all masses in unified atomic mass units.\n\nLet the Cartesian coordinates (in angstroms) of the three atoms at the transition state be fixed as:\n- $R_{\\mathrm{H}} = (-0.200, 0.000, 0.900)$,\n- $R_{\\mathrm{C}} = (0.000, 0.000, 0.000)$,\n- $R_{\\mathrm{N}} = (1.160, 0.000, 0.000)$.\nThe atomic masses (in unified atomic mass units) are:\n- $m_{\\mathrm{H}} = 1.008$,\n- $m_{\\mathrm{C}} = 12.000$,\n- $m_{\\mathrm{N}} = 14.000$.\n\nDefine the unit vector along the carbon–nitrogen (C–N) bond as\n$$\n\\hat{u}_{\\mathrm{CN}} = \\frac{R_{\\mathrm{N}} - R_{\\mathrm{C}}}{\\lVert R_{\\mathrm{N}} - R_{\\mathrm{C}} \\rVert}.\n$$\nDefine the normalized Cartesian bond-stretch displacement direction for the C–N bond as a $9$-vector\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}\\left(0,0,0,\\,-\\hat{u}_{\\mathrm{CN},x},-\\hat{u}_{\\mathrm{CN},y},-\\hat{u}_{\\mathrm{CN},z},\\,\\hat{u}_{\\mathrm{CN},x},\\hat{u}_{\\mathrm{CN},y},\\hat{u}_{\\mathrm{CN},z}\\right),\n$$\nwhich corresponds to a pure, unit-norm C–N stretch in Cartesian space with hydrogen fixed.\n\nFor a given IRC tangent expressed as a unit vector in mass-weighted coordinates, $v^{(\\mathrm{mw})} \\in \\mathbb{R}^{9}$ with $\\lVert v^{(\\mathrm{mw})} \\rVert = 1$, define its corresponding normalized Cartesian displacement direction $\\hat{u}_x$ by\n$$\nu_x = M^{-1/2} v^{(\\mathrm{mw})}, \\quad \\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert}.\n$$\nQuantify the fractional contribution of the C–N bond length to the IRC vector by the squared projection\n$$\nf = \\left(\\hat{d} \\cdot \\hat{u}_x \\right)^2,\n$$\na dimensionless number in $[0,1]$. Decide that the C–N bond length is a significant component of the IRC vector if $f \\ge \\tau$ for a given threshold $\\tau$.\n\nYour task is to write a program that, for each test case below, computes $f$ and returns a boolean indicating significance using the threshold $\\tau = 0.5$.\n\nTest suite. Each test case supplies a Cartesian displacement pattern $v^{(\\mathrm{cart})}$; the corresponding mass-weighted IRC tangent is the normalized mass-weighted vector\n$$\nv^{(\\mathrm{mw})} = \\frac{M^{1/2} v^{(\\mathrm{cart})}}{\\lVert M^{1/2} v^{(\\mathrm{cart})} \\rVert}.\n$$\nUse the same fixed geometry and masses above for all cases.\n\n- Case 1 (dominant C–N stretch):\n  $v^{(\\mathrm{cart})}$ has components\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (0,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = (-1,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = (+1,0,0).\n  $$\n\n- Case 2 (hydrogen transfer-like, minimal C–N stretch):\n  $v^{(\\mathrm{cart})}$ has components\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (1,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = (0.2,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = (0.2,0,0).\n  $$\n\n- Case 3 (mixed C–N stretch and in-plane bend, boundary case):\n  Let $\\hat{e}_x = (1,0,0)$ and $\\hat{e}_y = (0,1,0)$. With $\\hat{u}_{\\mathrm{CN}} = \\hat{e}_x$ for the given geometry, define\n  $$\n  v^{(\\mathrm{cart})}_{\\mathrm{H}} = (0,0,0),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{C}} = \\left(-\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}},\\,0\\right),\\quad\n  v^{(\\mathrm{cart})}_{\\mathrm{N}} = \\left(+\\frac{1}{\\sqrt{2}},\\,\\frac{1}{\\sqrt{2}},\\,0\\right).\n  $$\n\nFinal Output Format. Your program should produce a single line of output containing the boolean results for the three cases, in order, as a comma-separated list enclosed in square brackets with no spaces, for example, \"[True,False,True]\". No other text should be printed.", "solution": "The problem requires the validation of a given chemical reaction coordinate against a specific internal coordinate, namely the carbon-nitrogen bond stretch. This is a standard procedure in computational chemistry for analyzing the nature of vibrational normal modes or, as in this case, the intrinsic reaction coordinate (IRC). The IRC at a transition state describes the path of steepest descent from a first-order saddle point on the potential energy surface down to the reactants and products. Its tangent vector indicates the primary atomic motions involved in traversing the transition state barrier. We are tasked to compute the fractional contribution of the C-N bond stretch to this tangent vector for three given cases.\n\nThe problem is scientifically and computationally well-posed. All necessary data, including atomic masses, Cartesian coordinates for the transition state geometry, and definitions for all relevant vectors and metrics, are provided unambiguously. The underlying principles—mass-weighting of coordinates, vector normalization, and projection—are fundamental concepts in classical mechanics and linear algebra, correctly applied to a chemical physics context. The problem is therefore valid.\n\nWe will proceed with a systematic, step-by-step calculation for each test case.\n\nFirst, we establish the constant parameters and vectors derived from the provided geometry and masses.\nThe atomic masses are given as $m_{\\mathrm{H}} = 1.008$ u, $m_{\\mathrm{C}} = 12.000$ u, and $m_{\\mathrm{N}} = 14.000$ u. These are used to construct the diagonal mass-weighting matrix $M^{1/2}$ and its inverse $M^{-1/2}$. For a $9$-dimensional Cartesian displacement vector $x \\in \\mathbb{R}^{9}$, the corresponding mass-weighted vector is $q = M^{1/2} x$. The diagonal elements of $M^{1/2}$ are $(\\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{H}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{C}}}, \\sqrt{m_{\\mathrm{N}}}, \\sqrt{m_{\\mathrm{N}}}, \\sqrt{m_{\\mathrm{N}}})$.\n\nThe transition state coordinates are $R_{\\mathrm{H}} = (-0.200, 0.000, 0.900)$ Å, $R_{\\mathrm{C}} = (0.000, 0.000, 0.000)$ Å, and $R_{\\mathrm{N}} = (1.160, 0.000, 0.000)$ Å.\n\nThe unit vector along the carbon–nitrogen bond, $\\hat{u}_{\\mathrm{CN}}$, is calculated as:\n$$\nR_{\\mathrm{N}} - R_{\\mathrm{C}} = (1.160, 0.000, 0.000) - (0.000, 0.000, 0.000) = (1.160, 0.000, 0.000)\n$$\n$$\n\\lVert R_{\\mathrm{N}} - R_{\\mathrm{C}} \\rVert = \\sqrt{1.160^2 + 0^2 + 0^2} = 1.160\n$$\n$$\n\\hat{u}_{\\mathrm{CN}} = \\frac{(1.160, 0.000, 0.000)}{1.160} = (1, 0, 0)\n$$\nThis vector $\\hat{u}_{\\mathrm{CN}}$ is used to define the normalized Cartesian C–N bond-stretch displacement direction, $\\hat{d}$, which serves as our reference vector for the C-N stretch motion.\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}\\left(0,0,0,\\,-\\hat{u}_{\\mathrm{CN},x},-\\hat{u}_{\\mathrm{CN},y},-\\hat{u}_{\\mathrm{CN},z},\\,\\hat{u}_{\\mathrm{CN},x},\\hat{u}_{\\mathrm{CN},y},\\hat{u}_{\\mathrm{CN},z}\\right)\n$$\nSubstituting $\\hat{u}_{\\mathrm{CN}} = (1, 0, 0)$, we get:\n$$\n\\hat{d} = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)\n$$\nThis vector is normalized in Cartesian space, i.e., $\\lVert \\hat{d} \\rVert = 1$.\n\nFor each test case, we are given a Cartesian displacement pattern $v^{(\\mathrm{cart})}$ and must perform the following sequence of operations:\n$1$. Compute the mass-weighted vector $v' = M^{1/2} v^{(\\mathrm{cart})}$.\n$2$. Normalize it to obtain the IRC tangent in mass-weighted coordinates: $v^{(\\mathrm{mw})} = v' / \\lVert v' \\rVert$.\n$3$. Transform $v^{(\\mathrm{mw})}$ back to a Cartesian displacement vector: $u_x = M^{-1/2} v^{(\\mathrm{mw})}$.\n$4$. Normalize this Cartesian vector to get the unit direction: $\\hat{u}_x = u_x / \\lVert u_x \\rVert$.\n$5$. Calculate the fractional contribution of the C-N stretch as the squared projection: $f = (\\hat{d} \\cdot \\hat{u}_x)^2$.\n$6$. Compare $f$ with the threshold $\\tau = 0.5$ to determine significance.\n\nLet us now apply this procedure to each case.\n\nCase 1: Dominant C–N stretch\n$v^{(\\mathrm{cart})} = (0, 0, 0, -1, 0, 0, 1, 0, 0)$.\n$1$. Mass-weighting: $v' = (0, 0, 0, -1\\sqrt{m_{\\mathrm{C}}}, 0, 0, 1\\sqrt{m_{\\mathrm{N}}}, 0, 0) = (0, 0, 0, -\\sqrt{12.000}, 0, 0, \\sqrt{14.000}, 0, 0)$.\n$2$. Normalization: $\\lVert v' \\rVert = \\sqrt{(-\\sqrt{12.000})^2 + (\\sqrt{14.000})^2} = \\sqrt{12.000 + 14.000} = \\sqrt{26.000}$.\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -\\sqrt{12.000}, 0, 0, \\sqrt{14.000}, 0, 0)$.\n$3$. Conversion to Cartesian: $u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$.\n$4$. Normalization: $\\lVert u_x \\rVert = \\frac{1}{\\sqrt{26.000}}\\sqrt{(-1)^2 + 1^2} = \\frac{\\sqrt{2}}{\\sqrt{26.000}} = \\frac{1}{\\sqrt{13.000}}$.\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\sqrt{13.000} \\cdot \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1, 0, 0, 1, 0, 0) = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$.\n$5$. Projection: We observe that $\\hat{u}_x = \\hat{d}$. Therefore, $\\hat{d} \\cdot \\hat{u}_x = \\hat{d} \\cdot \\hat{d} = \\lVert \\hat{d} \\rVert^2 = 1$.\n$f = 1^2 = 1$.\n$6$. Significance: $f = 1 \\ge 0.5$. The result is True.\n\nCase 2: Hydrogen transfer-like\n$v^{(\\mathrm{cart})} = (1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$.\n$1$. Mass-weighting: $v' = (1\\sqrt{m_{\\mathrm{H}}}, 0, 0, 0.2\\sqrt{m_{\\mathrm{C}}}, 0, 0, 0.2\\sqrt{m_{\\mathrm{N}}}, 0, 0) = (\\sqrt{1.008}, 0, 0, 0.2\\sqrt{12.000}, 0, 0, 0.2\\sqrt{14.000}, 0, 0)$.\n$2$. Normalization: $\\lVert v' \\rVert^2 = 1.008 + (0.2)^2(12.000) + (0.2)^2(14.000) = 1.008 + 0.04(12.000) + 0.04(14.000) = 1.008 + 0.480 + 0.560 = 2.048$.\n$\\lVert v' \\rVert = \\sqrt{2.048}$.\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{2.048}}(\\sqrt{1.008}, 0, 0, 0.2\\sqrt{12.000}, 0, 0, 0.2\\sqrt{14.000}, 0, 0)$.\n$3$. Conversion to Cartesian: $u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{2.048}}(1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$.\n$4$. Normalization: $\\lVert u_x \\rVert^2 = \\frac{1}{2.048}(1^2 + 0.2^2 + 0.2^2) = \\frac{1.08}{2.048}$.\n$\\lVert u_x \\rVert = \\sqrt{\\frac{1.08}{2.048}}$.\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\frac{1}{\\sqrt{1.08}}(1, 0, 0, 0.2, 0, 0, 0.2, 0, 0)$.\n$5$. Projection: $\\hat{d} \\cdot \\hat{u}_x = \\frac{1}{\\sqrt{2}} \\cdot \\frac{1}{\\sqrt{1.08}} \\left[ (-1)(0.2) + (1)(0.2) \\right] = 0$.\n$f = 0^2 = 0$.\n$6$. Significance: $f = 0 < 0.5$. The result is False.\n\nCase 3: Mixed stretch and bend\n$v^{(\\mathrm{cart})} = (0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$.\n$1$. Mass-weighting: $v'_C = (-\\frac{\\sqrt{m_{\\mathrm{C}}}}{\\sqrt{2}}, \\frac{\\sqrt{m_{\\mathrm{C}}}}{\\sqrt{2}}, 0)$, $v'_N = (\\frac{\\sqrt{m_{\\mathrm{N}}}}{\\sqrt{2}}, \\frac{\\sqrt{m_{\\mathrm{N}}}}{\\sqrt{2}}, 0)$.\n$2$. Normalization: $\\lVert v' \\rVert^2 = \\frac{1}{2}(m_{\\mathrm{C}} + m_{\\mathrm{C}} + m_{\\mathrm{N}} + m_{\\mathrm{N}}) = m_{\\mathrm{C}} + m_{\\mathrm{N}} = 12.000 + 14.000 = 26.000$.\n$\\lVert v' \\rVert = \\sqrt{26.000}$.\n$v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -\\frac{\\sqrt{12}}{\\sqrt{2}}, \\frac{\\sqrt{12}}{\\sqrt{2}}, 0, \\frac{\\sqrt{14}}{\\sqrt{2}}, \\frac{\\sqrt{14}}{\\sqrt{2}}, 0)$.\n$3$. Conversion to Cartesian: $u_x = M^{-1/2} v^{(\\mathrm{mw})} = \\frac{1}{\\sqrt{26.000}}(0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$.\n$4$. Normalization: $\\lVert u_x \\rVert^2 = \\frac{1}{26.000} \\left( (-\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 + (\\frac{1}{\\sqrt{2}})^2 \\right) = \\frac{1}{26.000}(\\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2} + \\frac{1}{2}) = \\frac{2}{26.000} = \\frac{1}{13.000}$.\n$\\lVert u_x \\rVert = \\frac{1}{\\sqrt{13.000}}$.\n$\\hat{u}_x = \\frac{u_x}{\\lVert u_x \\rVert} = \\sqrt{13.000} \\cdot \\frac{v^{(\\mathrm{cart})}}{\\sqrt{26.000}} = \\frac{1}{\\sqrt{2}} v^{(\\mathrm{cart})}$.\n$\\hat{u}_x = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1/\\sqrt{2}, 1/\\sqrt{2}, 0, 1/\\sqrt{2}, 1/\\sqrt{2}, 0)$.\n$5$. Projection: $\\hat{d} = \\frac{1}{\\sqrt{2}}(0, 0, 0, -1, 0, 0, 1, 0, 0)$.\n$\\hat{d} \\cdot \\hat{u}_x = \\frac{1}{\\sqrt{2}} \\cdot \\frac{1}{\\sqrt{2}} \\left[ (-1)(-\\frac{1}{\\sqrt{2}}) + (1)(\\frac{1}{\\sqrt{2}}) \\right] = \\frac{1}{2}\\left[\\frac{1}{\\sqrt{2}} + \\frac{1}{\\sqrt{2}}\\right] = \\frac{1}{2}\\left[\\frac{2}{\\sqrt{2}}\\right] = \\frac{1}{\\sqrt{2}}$.\n$f = (\\frac{1}{\\sqrt{2}})^2 = \\frac{1}{2} = 0.5$.\n$6$. Significance: $f = 0.5 \\ge 0.5$. The result is True.\n\nThe final boolean results for the three cases are [True, False, True]. The following program implements this logic to generate the required output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining the significance of the C-N bond stretch\n    in a given reaction coordinate for the isomerization of HCN to HNC.\n    \"\"\"\n    \n    # Define constants and fixed geometry from the problem statement.\n    # Atomic masses in unified atomic mass units (u).\n    masses = {\n        'H': 1.008,\n        'C': 12.000,\n        'N': 14.000\n    }\n    \n    # Transition state coordinates in angstroms.\n    # Not explicitly needed for the calculation of d_hat as u_cn is simple.\n    # R_H = np.array([-0.200, 0.000, 0.900])\n    # R_C = np.array([0.000, 0.000, 0.000])\n    # R_N = np.array([1.160, 0.000, 0.000])\n\n    # Threshold for significance.\n    tau = 0.5\n\n    # Define the normalized C-N bond-stretch displacement direction, d_hat.\n    # From the problem, R_N - R_C is along the x-axis.\n    # So, u_cn = [1, 0, 0].\n    u_cn = np.array([1.0, 0.0, 0.0])\n    \n    # d_hat is a 9-vector in Cartesian space.\n    # [H_x, H_y, H_z, C_x, C_y, C_z, N_x, N_y, N_z]\n    d_hat = np.zeros(9)\n    d_hat[3:6] = -u_cn  # Displacement for Carbon atom\n    d_hat[6:9] = u_cn   # Displacement for Nitrogen atom\n    d_hat /= np.linalg.norm(d_hat) # Normalize to unit length\n\n    # Define the test cases.\n    v_cart_cases = [\n        # Case 1: dominant C-N stretch\n        np.array([0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.0]),\n\n        # Case 2: hydrogen transfer-like, minimal C-N stretch\n        np.array([1.0, 0.0, 0.0, 0.2, 0.0, 0.0, 0.2, 0.0, 0.0]),\n\n        # Case 3: mixed C-N stretch and in-plane bend\n        np.array([0.0, 0.0, 0.0, -1.0/np.sqrt(2), 1.0/np.sqrt(2), 0.0, 1.0/np.sqrt(2), 1.0/np.sqrt(2), 0.0])\n    ]\n\n    # Create the 9D mass vector for mass-weighting operations.\n    # Order: [m_H, m_H, m_H, m_C, m_C, m_C, m_N, m_N, m_N]\n    mass_vec_9d = np.repeat([masses['H'], masses['C'], masses['N']], 3)\n    \n    M_sqrt_diag = np.sqrt(mass_vec_9d)\n    M_inv_sqrt_diag = 1.0 / M_sqrt_diag\n\n    results = []\n    for v_cart in v_cart_cases:\n        # Step 1: Compute the mass-weighted vector v_prime.\n        v_prime = v_cart * M_sqrt_diag\n        \n        # Step 2: Normalize to get the IRC tangent in mass-weighted coordinates (v_mw).\n        v_prime_norm = np.linalg.norm(v_prime)\n        if v_prime_norm == 0:\n            # Handle the case of a zero vector, though not expected here.\n            results.append(False)\n            continue\n        v_mw = v_prime / v_prime_norm\n        \n        # Step 3: Transform v_mw back to a Cartesian displacement vector (u_x).\n        u_x = v_mw * M_inv_sqrt_diag\n        \n        # Step 4: Normalize this Cartesian vector to get the unit direction (u_x_hat).\n        u_x_norm = np.linalg.norm(u_x)\n        if u_x_norm == 0:\n            results.append(False)\n            continue\n        u_x_hat = u_x / u_x_norm\n        \n        # Step 5: Calculate the fractional contribution f.\n        f = (np.dot(d_hat, u_x_hat))**2\n        \n        # Step 6: Compare f with the threshold tau.\n        is_significant = f >= tau\n        results.append(is_significant)\n\n    # Format and print the final output as specified.\n    # Example: [True,False,True]\n    result_str = \",\".join(map(str, results))\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2461347"}]}