{"hands_on_practices": [{"introduction": "We begin our hands-on exploration by tackling the fundamental challenge of numerically solving the time-dependent Schrödinger equation. This first practice uses the conceptually simple forward Euler method to propagate a quantum state in a two-level system. By tracking the system's total energy—a quantity that must be strictly conserved in exact dynamics—you will directly observe the critical concept of numerical instability and understand why the choice of integrator and time step, $\\Delta t$, is paramount for a physically meaningful simulation [@problem_id:2461384].", "problem": "You are to model the real-time propagation of a single occupied Kohn-Sham orbital in a two-level basis using the time-dependent Kohn-Sham equation in atomic units, which reduces to the time-dependent Schrödinger equation $i \\, \\partial_t |\\psi(t)\\rangle = \\hat{H} |\\psi(t)\\rangle$ with a time-independent $2 \\times 2$ Hermitian Hamiltonian. Consider the Hamiltonian (in Hartree) given by\n$$\n\\hat{H} \\equiv H =\n\\begin{pmatrix}\n\\varepsilon_1 & V \\\\\nV & \\varepsilon_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0.0 & 0.1 \\\\\n0.1 & 0.5\n\\end{pmatrix},\n$$\nwith $\\hbar = 1$ (atomic units). The initial state at $t = 0$ is the normalized vector\n$$\n|\\psi(0)\\rangle = \\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}.\n$$\nLet the total propagation time be $T = 20.0$ (in atomic units of time). Use the explicit forward Euler update to approximate the evolution,\n$$\n|\\psi_{n+1}\\rangle = |\\psi_n\\rangle - i \\, \\Delta t \\, H |\\psi_n\\rangle,\n$$\nfor $n = 0,1,\\dots,N-1$ with $N = T / \\Delta t$, and do not renormalize during propagation. Define the instantaneous energy expectation at discrete time $t_n = n \\, \\Delta t$ by the Rayleigh quotient\n$$\nE_n = \\frac{\\langle \\psi_n | H | \\psi_n \\rangle}{\\langle \\psi_n | \\psi_n \\rangle}.\n$$\nFor each specified time step $\\Delta t$, compute the energy drift $\\Delta E = E_N - E_0$.\n\nYour program must implement the above model exactly as stated and produce the energy drift for each of the following test cases (these constitute the required test suite), using the same Hamiltonian, initial state, and total time $T$ given above:\n- $\\Delta t = 0.01$,\n- $\\Delta t = 0.05$,\n- $\\Delta t = 0.20$,\n- $\\Delta t = 0.50$.\n\nAll time quantities are in atomic units, and energies must be expressed in Hartree. Report each energy drift $\\Delta E$ in Hartree as a float rounded to six decimal places.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases (e.g., $[x_1,x_2,x_3,x_4]$), where each $x_k$ is the rounded energy drift for the corresponding $\\Delta t$ specified above.", "solution": "The problem requires the simulation of the quantum dynamics of a single occupied orbital in a two-level system. This is governed by the time-dependent Schrödinger equation (TDSE), which is the specified form of the time-dependent Kohn-Sham equation for this model system. The governing equation in atomic units ($\\hbar=1$) is:\n$$\ni \\frac{\\partial}{\\partial t} |\\psi(t)\\rangle = \\hat{H} |\\psi(t)\\rangle\n$$\nThe system is defined by a time-independent $2 \\times 2$ Hermitian Hamiltonian, given in units of Hartree as:\n$$\nH =\n\\begin{pmatrix}\n0.0 & 0.1 \\\\\n0.1 & 0.5\n\\end{pmatrix}\n$$\nThe initial state of the system at time $t=0$ is a normalized superposition of the two basis states:\n$$\n|\\psi(0)\\rangle = \\frac{1}{\\sqrt{2}}\n\\begin{pmatrix}\n1 \\\\\n1\n\\end{pmatrix}\n$$\nThe propagation is to be carried out for a total time of $T = 20.0$ atomic units.\n\nThe numerical integration of the TDSE is prescribed to use the explicit forward Euler method. Discretizing time into steps of size $\\Delta t$, with $t_n = n \\Delta t$, the state vector at step $n+1$ is approximated from the state at step $n$ by:\n$$\n|\\psi_{n+1}\\rangle = |\\psi_n\\rangle - i \\Delta t H |\\psi_n\\rangle = (I - i \\Delta t H) |\\psi_n\\rangle\n$$\nwhere $I$ is the $2 \\times 2$ identity matrix. This defines the propagation algorithm.\n\nA critical property of the exact evolution operator, $U(t, t_0) = e^{-iH(t-t_0)}$, is that it is unitary, which guarantees the conservation of the norm of the state vector, i.e., $\\langle \\psi(t) | \\psi(t) \\rangle = \\text{constant}$. The forward Euler propagation operator, $\\hat{P}_{\\text{Euler}} = (I - i \\Delta t H)$, is not unitary. Its adjoint is $\\hat{P}_{\\text{Euler}}^\\dagger = (I + i \\Delta t H^\\dagger)$. Since $H$ is Hermitian ($H=H^\\dagger$), we have:\n$$\n\\hat{P}_{\\text{Euler}}^\\dagger \\hat{P}_{\\text{Euler}} = (I + i \\Delta t H)(I - i \\Delta t H) = I - i \\Delta t H + i \\Delta t H + (\\Delta t)^2 H^2 = I + (\\Delta t)^2 H^2\n$$\nThe norm at step $n+1$ is thus related to the norm at step $n$ by:\n$$\n\\langle \\psi_{n+1} | \\psi_{n+1} \\rangle = \\langle \\psi_n | \\hat{P}_{\\text{Euler}}^\\dagger \\hat{P}_{\\text{Euler}} | \\psi_n \\rangle = \\langle \\psi_n | (I + (\\Delta t)^2 H^2) | \\psi_n \\rangle = \\langle \\psi_n | \\psi_n \\rangle + (\\Delta t)^2 \\langle \\psi_n | H^2 | \\psi_n \\rangle\n$$\nSince $\\langle \\psi_n | H^2 | \\psi_n \\rangle \\ge 0$, the norm of the state vector will monotonically increase at every step, a hallmark of the unconditional instability of the forward Euler method for the TDSE. The problem correctly instructs not to renormalize the state vector during propagation.\n\nFor a time-independent Hamiltonian, the exact energy of the system is a conserved quantity. The numerical energy at step $n$, however, will deviate due to the approximations in the integrator. As the state vector is not normalized, the energy expectation value must be calculated using the Rayleigh quotient:\n$$\nE_n = \\frac{\\langle \\psi_n | H | \\psi_n \\rangle}{\\langle \\psi_n | \\psi_n \\rangle}\n$$\nThe objective is to compute the total energy drift, $\\Delta E = E_N - E_0$, where $N = T/\\Delta t$ is the total number of steps. This quantity serves as a measure of the numerical error in energy conservation for the specified integrator and time step $\\Delta t$.\n\nFirst, we calculate the initial energy $E_0$ at $t_0=0$. Given that $|\\psi_0\\rangle = |\\psi(0)\\rangle$ is normalized, $\\langle \\psi_0 | \\psi_0 \\rangle = 1$. The calculation is:\n$$\nH |\\psi_0\\rangle = \\begin{pmatrix} 0.0 & 0.1 \\\\ 0.1 & 0.5 \\end{pmatrix} \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0.1 \\\\ 0.6 \\end{pmatrix}\n$$\n$$\nE_0 = \\frac{\\langle \\psi_0 | H | \\psi_0 \\rangle}{\\langle \\psi_0 | \\psi_0 \\rangle} = \\langle \\psi_0 | H | \\psi_0 \\rangle = \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & 1 \\end{pmatrix} \\right) \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0.1 \\\\ 0.6 \\end{pmatrix} \\right) = \\frac{1}{2}(0.1 + 0.6) = 0.35 \\text{ Hartree}\n$$\nThe value of $E_0$ is constant for all test cases.\n\nThe algorithm proceeds as follows for each given time step $\\Delta t$:\n1.  Initialize the state vector $|\\psi\\rangle \\leftarrow |\\psi_0\\rangle$.\n2.  Calculate the number of propagation steps $N = \\text{int}(T / \\Delta t)$.\n3.  Loop $N$ times, from $n=0$ to $N-1$:\n    a. Update the state vector: $|\\psi\\rangle \\leftarrow (I - i \\Delta t H) |\\psi\\rangle$.\n4.  After the loop, the final state is $|\\psi_N\\rangle$. Calculate the final energy $E_N$ using the Rayleigh quotient:\n    $$\n    E_N = \\frac{\\langle \\psi_N | H | \\psi_N \\rangle}{\\langle \\psi_N | \\psi_N \\rangle}\n    $$\n5.  Compute the energy drift $\\Delta E = E_N - E_0$.\n6.  Round the result to six decimal places as required.\n\nThis procedure will be implemented for each specified value of $\\Delta t \\in \\{0.01, 0.05, 0.20, 0.50\\}$, and the resulting energy drifts will be reported.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the energy drift in a real-time propagation of a two-level\n    quantum system using the forward Euler method.\n    \"\"\"\n    # Define the Hamiltonian matrix (in Hartree)\n    H = np.array([\n        [0.0, 0.1],\n        [0.1, 0.5]\n    ], dtype=np.float64)\n\n    # Define the initial state vector at t=0 (normalized)\n    psi0 = np.array([1.0, 1.0], dtype=np.complex128) / np.sqrt(2)\n\n    # Define the total propagation time T (in atomic units)\n    T = 20.0\n\n    # Define the test cases for the time step dt\n    test_cases_dt = [0.01, 0.05, 0.20, 0.50]\n\n    # Calculate the initial energy E_0\n    # Since psi0 is normalized, the denominator <psi0|psi0> is 1.\n    # np.vdot(a, b) computes a.conj().T @ b which is <a|b>.\n    E0 = np.vdot(psi0, H @ psi0).real\n\n    results = []\n    \n    # Iterate through each test case\n    for dt in test_cases_dt:\n        # Determine the number of steps\n        # Given T/dt are all integers for the test cases\n        N = int(T / dt)\n\n        # Initialize the state vector for the current propagation\n        psi = np.copy(psi0)\n\n        # Pre-compute the forward Euler update operator for efficiency\n        I = np.identity(2, dtype=np.complex128)\n        update_operator = I - 1j * dt * H\n\n        # Propagate the state vector for N steps\n        for _ in range(N):\n            psi = update_operator @ psi\n        \n        # After propagation, psi is the final state psi_N.\n        # Calculate the final energy E_N using the Rayleigh quotient.\n        # The state is not normalized, so the full quotient is required.\n        numerator_EN = np.vdot(psi, H @ psi).real\n        denominator_EN = np.vdot(psi, psi).real\n        EN = numerator_EN / denominator_EN\n\n        # Calculate the energy drift\n        delta_E = EN - E0\n\n        # Round the result to six decimal places and store it\n        results.append(round(delta_E, 6))\n\n    # Print the final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2461384"}, {"introduction": "Having witnessed how a naive integrator can fail, we now investigate more robust propagation techniques. This exercise compares the popular fourth-order Runge-Kutta (RK4) method against a Magnus expansion-based propagator, which is tailored for quantum mechanics. Using the familiar classical harmonic oscillator as an insightful analogue, you will analyze a more subtle yet crucial type of numerical error: the drift in the quantum phase over long simulations, highlighting why preserving the geometric structure of the dynamics is essential for accurate real-time TD-DFT [@problem_id:2461402].", "problem": "Consider the real-time propagation of a single Kohn-Sham orbital in Time-Dependent Density Functional Theory (TD-DFT), which reduces to a unitary evolution under a one-body Hamiltonian. As a surrogate model for probing phase accuracy of propagators, use the classical simple harmonic oscillator with angular frequency $\\omega$ and mass $m$, whose state vector $\\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$ obeys the linear, time-independent first-order system\n$$\n\\frac{d}{dt}\\mathbf{y}(t) = A(\\omega)\\,\\mathbf{y}(t), \\quad A(\\omega) = \\begin{bmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{bmatrix}.\n$$\nAssume the initial condition $\\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$, corresponding to unit displacement and zero velocity. Let the number of time steps be $N = 1000$, with a constant time step $\\Delta t > 0$, so that the final time is $T = N\\,\\Delta t$. Angles must be treated in radians, and times in seconds.\n\nDefine the numerical phase at time $t$ by first forming the scaled state $\\mathbf{z}(t) = \\begin{bmatrix} x(t) \\\\ v(t)/\\omega \\end{bmatrix}$, and then computing\n$$\n\\theta_{\\mathrm{num}}(t) = \\operatorname{atan2}\\!\\left(\\frac{v(t)}{\\omega},\\,x(t)\\right),\n$$\nwhich is the geometric angle of $\\mathbf{z}(t)$ in the phase plane. The exact phase at time $t$ is $\\theta_{\\mathrm{exact}}(t) = \\omega t$ modulo $2\\pi$. Define the principal phase error at time $T$ as the absolute value of the wrapped difference\n$$\n\\varepsilon = \\left| \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\theta_{\\mathrm{num}}(T) - \\big(\\omega T \\bmod 2\\pi\\big)\\right) \\right|,\n$$\nwhere $\\operatorname{wrap}_{(-\\pi,\\pi]}(\\cdot)$ maps any angle to the interval $(-\\pi,\\pi]$ by adding or subtracting integer multiples of $2\\pi$.\n\nYour task is to write a complete, runnable program that, for each test case specified below, propagates $\\mathbf{y}(t)$ from $t=0$ to $t=T$ using both:\n- a classical fourth-order Runge-Kutta method (order $4$), and\n- a Magnus expansion-based propagator that applies, at each time step, the matrix exponential $\\exp(\\Delta t\\,A(\\omega))$ to the state.\n\nFor each test case, compute the magnitude of the principal phase error $\\varepsilon$ at $t=T$ for both propagators. Express each phase error in radians and round to $8$ decimal places.\n\nTest suite (each test case is a pair $(\\omega,\\Delta t)$ with $\\omega$ in radians per second and $\\Delta t$ in seconds; $N = 1000$ in all cases):\n- Test $1$: $(\\omega,\\Delta t) = (\\,1.0,\\,0.01\\,)$.\n- Test $2$: $(\\omega,\\Delta t) = (\\,1.0,\\,0.1\\,)$.\n- Test $3$: $(\\omega,\\Delta t) = (\\,2.5,\\,0.5\\,)$.\n- Test $4$: $(\\omega,\\Delta t) = (\\,2.8,\\,1.0\\,)$.\n\nThe required final output format is a single line containing a list of length $4$, where each element is a two-element list $[\\varepsilon_{\\mathrm{RK4}}, \\varepsilon_{\\mathrm{Magnus}}]$ corresponding to one test case, in the order given above. The list must contain numeric literals rounded as specified and have no spaces. For example, the abstract format is\n$$\n\\big[\\,[e_{1,1},e_{1,2}],[e_{2,1},e_{2,2}],[e_{3,1},e_{3,2}],[e_{4,1},e_{4,2}]\\,\\big],\n$$\nwhere $e_{i,j}$ are floats in radians rounded to $8$ decimal places.", "solution": "The problem presented is a request to analyze the phase accuracy of two numerical propagators for the simple harmonic oscillator, which serves as a simplified model for the time evolution of a Kohn-Sham orbital in Time-Dependent Density Functional Theory.\n\nFirst, a validation of the problem statement is in order.\n\n**Step 1: Extracted Givens**\nThe physical system is a simple harmonic oscillator with mass $m$ and angular frequency $\\omega$. Its state is described by the vector $\\mathbf{y}(t) = \\begin{bmatrix} x(t) \\\\ v(t) \\end{bmatrix}$, representing position and velocity. The equation of motion is given as a first-order linear system:\n$$\n\\frac{d}{dt}\\mathbf{y}(t) = A(\\omega)\\,\\mathbf{y}(t), \\quad \\text{where} \\quad A(\\omega) = \\begin{bmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{bmatrix}.\n$$\nThe initial condition is specified as $\\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$. The system is to be propagated for $N = 1000$ steps with a constant time step $\\Delta t$, up to a final time of $T = N\\,\\Delta t$.\n\nThe numerical phase $\\theta_{\\mathrm{num}}(t)$ is defined via a scaled state vector $\\mathbf{z}(t) = \\begin{bmatrix} x(t) \\\\ v(t)/\\omega \\end{bmatrix}$ as its angle in the phase plane:\n$$\n\\theta_{\\mathrm{num}}(t) = \\operatorname{atan2}\\!\\left(\\frac{v(t)}{\\omega},\\,x(t)\\right).\n$$\nThe exact phase is defined as $\\theta_{\\mathrm{exact}}(t) = \\omega t \\pmod{2\\pi}$.\n\nThe principal phase error at the final time $T$ is defined as:\n$$\n\\varepsilon = \\left| \\operatorname{wrap}_{(-\\pi,\\pi]}\\!\\left(\\theta_{\\mathrm{num}}(T) - \\big(\\omega T \\bmod 2\\pi\\big)\\right) \\right|,\n$$\nwhere $\\operatorname{wrap}_{(-\\pi,\\pi]}(\\cdot)$ maps an angle to the interval $(-\\pi, \\pi]$.\n\nTwo propagators must be implemented and compared:\n1.  The classical fourth-order Runge-Kutta method (RK$4$).\n2.  A Magnus expansion-based propagator, which at each step applies the exact matrix exponential propagator $U(\\Delta t) = \\exp(\\Delta t\\,A(\\omega))$.\n\nThe task is to compute $\\varepsilon$ for both methods for a given set of test cases:\n- Test $1$: $(\\omega,\\Delta t) = (\\,1.0,\\,0.01\\,)$\n- Test $2$: $(\\omega,\\Delta t) = (\\,1.0,\\,0.1\\,)$\n- Test $3$: $(\\omega,\\Delta t) = (\\,2.5,\\,0.5\\,)$\n- Test $4$: $(\\omega,\\Delta t) = (\\,2.8,\\,1.0\\,)$\n\nThe results must be rounded to $8$ decimal places.\n\n**Step 2: Validation**\nThe problem is scientifically grounded, using the harmonic oscillator as a standard test case for numerical ordinary differential equation solvers. It is well-posed, with a linear time-independent system and a specified initial condition, guaranteeing a unique solution. The language is objective and mathematically precise. All necessary information is provided, and there are no internal contradictions. The problem is a standard exercise in numerical analysis and is therefore valid.\n\n**Step 3: Action**\nThe problem is valid. I will proceed with the solution.\n\n**Algorithmic Design and Principles**\n\nThe core of the problem is to simulate the time evolution of the state vector $\\mathbf{y}(t)$ using two distinct numerical schemes and then to evaluate their phase accuracy.\n\n**Analytical Solution**\nBefore detailing the numerical methods, it is instructive to consider the analytical solution. The equation $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$ with initial condition $\\mathbf{y}(0)$ has the exact solution $\\mathbf{y}(t) = \\exp(tA)\\mathbf{y}(0)$. The matrix $A$ has the property that $A^2 = -\\omega^2 I$, where $I$ is the $2 \\times 2$ identity matrix. This allows for a closed-form expression for the matrix exponential, derived from its Taylor series expansion:\n$$\n\\exp(tA) = I \\cos(\\omega t) + \\frac{A}{\\omega} \\sin(\\omega t) = \\begin{bmatrix} \\cos(\\omega t) & \\frac{1}{\\omega}\\sin(\\omega t) \\\\ -\\omega\\sin(\\omega t) & \\cos(\\omega t) \\end{bmatrix}.\n$$\nApplying this to the initial condition $\\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ yields the exact trajectory:\n$$\n\\mathbf{y}(t) = \\begin{bmatrix} \\cos(\\omega t) \\\\ -\\omega\\sin(\\omega t) \\end{bmatrix}.\n$$\nThus, $x(t) = \\cos(\\omega t)$ and $v(t) = -\\omega\\sin(\\omega t)$. The scaled state vector is $\\mathbf{z}(t) = \\begin{bmatrix} \\cos(\\omega t) \\\\ -\\sin(\\omega t) \\end{bmatrix}$. The angle of this vector, which corresponds to the true physical phase, is $\\operatorname{atan2}(-\\sin(\\omega t), \\cos(\\omega t)) = -\\omega t$ (modulo $2\\pi$).\n\n**Phase Error Calculation**\nThe problem defines the \"exact phase\" as $\\theta_{\\mathrm{exact}}(t) = \\omega t$. This is a crucial definition. It sets a reference of a counter-clockwise rotating phase, whereas the physical system evolves with a clockwise rotating phase. The phase error calculation pits the numerically computed phase $\\theta_{\\mathrm{num}}(T)$ against this defined reference. For an exact numerical method, we would find $\\theta_{\\mathrm{num}}(T) \\approx -\\omega T \\pmod{2\\pi}$. The difference for error calculation would be $\\theta_{\\mathrm{num}}(T) - \\theta_{\\mathrm{exact}}(T) \\approx (-\\omega T) - (\\omega T) = -2\\omega T \\pmod{2\\pi}$. This non-zero result for an exact method is a direct consequence of the problem's specific definitions and must be strictly followed.\n\nThe function $\\operatorname{wrap}_{(-\\pi,\\pi]}(x)$ maps an angle $x$ to the interval $(-\\pi, \\pi]$. This can be implemented by noting that `(x + np.pi) % (2 * np.pi) - np.pi` maps to $[-\\pi, \\pi)$. A small adjustment is required to map the endpoint $-\\pi$ to $\\pi$.\n\n**Method 1: Fourth-Order Runge-Kutta (RK4)**\nThe RK$4$ method is a general-purpose, explicit, single-step solver. For an autonomous system $\\frac{d\\mathbf{y}}{dt} = f(\\mathbf{y})$, the update rule from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= f(\\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= f(\\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= f(\\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= f(\\mathbf{y}_n + \\Delta t\\,\\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\nIn our case, $f(\\mathbf{y}) = A(\\omega)\\mathbf{y}$. The simulation proceeds by iteratively applying this update rule $N=1000$ times, starting from $\\mathbf{y}_0 = \\mathbf{y}(0)$. RK$4$ is not a symplectic integrator, so it is expected to introduce both amplitude and phase errors. The total energy (or norm of the scaled state) is not conserved.\n\n**Method 2: Magnus Propagator**\nThe problem statement describes this propagator as applying the matrix exponential $\\exp(\\Delta t\\,A(\\omega))$ at each step. For a time-independent matrix $A$, the Magnus expansion truncates exactly at the first order, and the resulting propagator is the exact solution operator over the interval $\\Delta t$.\n$$\n\\mathbf{y}_{n+1} = \\exp(\\Delta t\\,A(\\omega)) \\, \\mathbf{y}_n\n$$\nThe matrix $U = \\exp(\\Delta t\\,A(\\omega))$ is calculated once:\n$$\nU = \\begin{bmatrix} \\cos(\\omega \\Delta t) & \\frac{1}{\\omega}\\sin(\\omega \\Delta t) \\\\ -\\omega\\sin(\\omega \\Delta t) & \\cos(\\omega \\Delta t) \\end{bmatrix}.\n$$\nThe propagation consists of $N=1000$ sequential matrix-vector multiplications: $\\mathbf{y}_N = U \\mathbf{y}_{N-1} = \\dots = U^N \\mathbf{y}_0$. Since this method is mathematically equivalent to the exact analytical solution at each discrete time step, any computed error will be due only to floating-point arithmetic limitations and the particular choice of phase definition, not from any intrinsic error of the algorithm itself. This method is unitary and preserves the norm of the scaled state $\\mathbf{z}(t)$, which is a key property in quantum dynamics and makes such propagators desirable.\n\nThe implementation will proceed by writing two functions, one for each propagator, that take the initial state and problem parameters, and return the final state. From the final state, the phase error $\\varepsilon$ is computed for each case as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the simple harmonic oscillator problem to find phase errors for\n    RK4 and Magnus propagators for a given set of test cases.\n    \"\"\"\n\n    test_cases = [\n        (1.0, 0.01),\n        (1.0, 0.1),\n        (2.5, 0.5),\n        (2.8, 1.0),\n    ]\n\n    N_STEPS = 1000\n\n    def wrap_to_pi(angle: float) -> float:\n        \"\"\"\n        Wraps an angle in radians to the interval (-pi, pi].\n        \"\"\"\n        # Python's % operator maps to [a, b) for a%b if b>0.\n        # So this maps to [-pi, pi).\n        wrapped = (angle + np.pi) % (2 * np.pi) - np.pi\n        # The problem requires the interval (-pi, pi].\n        # If the result is exactly -pi, it should be mapped to pi.\n        if wrapped == -np.pi:\n            return np.pi\n        return wrapped\n\n    def rk4_propagator(omega: float, dt: float, y0: np.ndarray, n_steps: int) -> np.ndarray:\n        \"\"\"\n        Propagates the state vector using the classical 4th-order Runge-Kutta method.\n        \"\"\"\n        A = np.array([[0.0, 1.0], [-omega**2, 0.0]])\n        y = y0.copy()\n        for _ in range(n_steps):\n            k1 = A @ y\n            k2 = A @ (y + dt / 2.0 * k1)\n            k3 = A @ (y + dt / 2.0 * k2)\n            k4 = A @ (y + dt * k3)\n            y += (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        return y\n\n    def magnus_propagator(omega: float, dt: float, y0: np.ndarray, n_steps: int) -> np.ndarray:\n        \"\"\"\n        Propagates the state vector using the exact exponential propagator (Magnus).\n        \"\"\"\n        c = np.cos(omega * dt)\n        s = np.sin(omega * dt)\n        U = np.array([[c, s / omega], [-omega * s, c]])\n        \n        y = y0.copy()\n        for _ in range(n_steps):\n            y = U @ y\n        return y\n        \n    results = []\n    y0 = np.array([1.0, 0.0])\n\n    for omega, dt in test_cases:\n        T = N_STEPS * dt\n\n        # RK4 calculation\n        y_final_rk4 = rk4_propagator(omega, dt, y0, N_STEPS)\n        x_rk4, v_rk4 = y_final_rk4\n        theta_num_rk4 = np.arctan2(v_rk4 / omega, x_rk4)\n        \n        # Magnus calculation\n        y_final_magnus = magnus_propagator(omega, dt, y0, N_STEPS)\n        x_magnus, v_magnus = y_final_magnus\n        theta_num_magnus = np.arctan2(v_magnus / omega, x_magnus)\n\n        # Phase error calculation\n        theta_exact_raw = omega * T\n        \n        diff_rk4 = theta_num_rk4 - theta_exact_raw\n        error_rk4 = abs(wrap_to_pi(diff_rk4))\n\n        diff_magnus = theta_num_magnus - theta_exact_raw\n        error_magnus = abs(wrap_to_pi(diff_magnus))\n\n        results.append([error_rk4, error_magnus])\n\n    # Format the final output string exactly as required.\n    result_strings = [\n        f\"[{r[0]:.8f},{r[1]:.8f}]\" for r in results\n    ]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```", "id": "2461402"}, {"introduction": "In our final practice, we will apply our understanding of propagators to a task central to computational spectroscopy: calculating a response spectrum from time-domain data. You will simulate the response of a quantum system to an instantaneous \"quadrupole kick,\" a perturbation that excites it into a superposition of states. By tracking the system's subsequent evolution and applying a Fourier transform to its time-dependent quadrupole moment, you will discover how the system's excitation energies emerge as distinct peaks in the frequency spectrum, providing a powerful link between real-time propagation and observable properties [@problem_id:2461370].", "problem": "A single-electron, one-dimensional model for Time-Dependent Density Functional Theory (TD-DFT) real-time propagation is considered in atomic units. The Kohn-Sham Hamiltonian is taken to be the one-dimensional harmonic oscillator with an optional quartic anharmonicity, given by\n$$\n\\hat{H} = \\frac{\\hat{p}^2}{2} + \\frac{1}{2}\\,\\omega^2 \\hat{x}^2 + \\alpha \\hat{x}^4,\n$$\nwhere $\\omega \\gt 0$ is the oscillator frequency and $\\alpha \\ge 0$ controls the anharmonicity. At time $t=0$, the system is prepared in the ground state of the harmonic part (i.e., the exact ground state of $\\frac{\\hat{p}^2}{2} + \\frac{1}{2}\\,\\omega^2 \\hat{x}^2$), and an instantaneous quadrupole kick is applied via the unitary operator\n$$\n\\hat{U}_{\\mathrm{kick}} = \\exp\\!\\left(-i\\,\\kappa\\,\\hat{Q}\\right), \\quad \\hat{Q} \\equiv \\hat{x}^2,\n$$\nwith a small real kick strength $\\kappa$. After the kick, the state evolves under $\\hat{H}$ for times $t \\in [0,T]$. Let $\\langle \\hat{Q} \\rangle(t)$ denote the time-dependent expectation value of $\\hat{Q}$ during the field-free evolution. Define the windowed quadrupole response signal\n$$\ns(t) = \\left(\\langle \\hat{Q} \\rangle(t) - \\langle \\hat{Q} \\rangle(0)\\right)\\,e^{-\\gamma t},\n$$\nwhere $\\gamma \\gt 0$ is a small damping constant. The quadrupole response spectrum is the magnitude of the Fourier transform\n$$\nS(\\Omega) = \\left|\\int_0^T s(t)\\,e^{i \\Omega t}\\,dt\\right|,\n$$\nas a function of angular frequency $\\Omega$ (in atomic units). For each specified parameter set below, determine the dominant peak position\n$$\n\\Omega_{\\mathrm{peak}} = \\underset{\\Omega \\gt 0}{\\arg\\max}\\, S(\\Omega),\n$$\nexpressed in atomic units and rounded to three decimals.\n\nTime-Dependent Density Functional Theory (TD-DFT) is here modeled by a single Kohn-Sham orbital in an external potential; no exchange-correlation field is included. The quadrupole operator is taken as the one-dimensional component $\\hat{Q} = \\hat{x}^2$, corresponding to the $xx$-component of the quadrupole tensor in a one-dimensional reduction.\n\nYour task is to write a complete, runnable program that computes $\\Omega_{\\mathrm{peak}}$ for each of the following test cases. The program must implement first-principles real-time propagation consistent with the definitions above and produce the required spectral analysis. All physical quantities, including $\\omega$, $\\alpha$, $\\kappa$, $T$, $dt$, and $\\gamma$, are given in atomic units. Angles and frequencies must be treated in radians per unit time (atomic units). The final outputs must be in atomic units.\n\nTest Suite (each case specifies $(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma)$, where $N$ is a truncation parameter for any chosen finite basis representation):\n- Case 1 (happy path): $(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (0.70,\\,0.00,\\,1.0\\times 10^{-3},\\,24,\\,800.0,\\,0.02,\\,0.002)$.\n- Case 2 (contrast frequency): $(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (1.10,\\,0.00,\\,1.0\\times 10^{-3},\\,24,\\,800.0,\\,0.02,\\,0.002)$.\n- Case 3 (anharmonic shift): $(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (0.70,\\,0.02,\\,1.0\\times 10^{-3},\\,36,\\,800.0,\\,0.02,\\,0.002)$.\n- Case 4 (weak-kick boundary): $(\\omega,\\alpha,\\kappa,N,T,dt,\\gamma) = (0.20,\\,0.00,\\,1.0\\times 10^{-6},\\,24,\\,800.0,\\,0.02,\\,0.002)$.\n\nRequirements:\n- Implement the field-free evolution after the kick exactly as defined. The initial state is the ground state of the harmonic part at frequency $\\omega$.\n- Compute the time series $\\langle \\hat{Q} \\rangle(t)$ on the uniform time grid $t = 0, dt, 2\\,dt, \\dots, T-dt$.\n- Use the definition of $S(\\Omega)$ above with the exponential window $e^{-\\gamma t}$.\n- Determine $\\Omega_{\\mathrm{peak}}$ as the maximizer of $S(\\Omega)$ over positive $\\Omega$ on the discrete frequency grid consistent with the chosen time discretization.\n- Express $\\Omega_{\\mathrm{peak}}$ for each case in atomic units, rounded to three decimals.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases, for example, $[x_1,x_2,x_3,x_4]$, where each $x_j$ is $\\Omega_{\\mathrm{peak}}$ rounded to three decimals (in atomic units).", "solution": "The problem statement is scientifically grounded, well-posed, and objective. It presents a standard problem in computational quantum dynamics, modeling the optical response of a single-electron system. All parameters and conditions are clearly defined, permitting a unique numerical solution. I will therefore proceed with a detailed solution based on first principles.\n\nThe task is to determine the dominant peak frequency, $\\Omega_{\\mathrm{peak}}$, in the quadrupole response spectrum of a one-dimensional quantum system. The solution requires simulating the system's time evolution according to the Schrödinger equation. A robust and accurate methodology involves representing the quantum state and operators within a suitable finite basis.\n\n**1. Basis Set Representation**\n\nThe full Hamiltonian is $\\hat{H} = \\hat{H}_0 + \\alpha \\hat{x}^4$, where $\\hat{H}_0 = \\frac{\\hat{p}^2}{2} + \\frac{1}{2}\\,\\omega^2 \\hat{x}^2$ is the harmonic oscillator Hamiltonian. The eigenstates of $\\hat{H}_0$, denoted as $|n\\rangle$ for $n=0, 1, 2, \\dots$, form a convenient and complete basis for this problem. They are the eigenfunctions of the quantum harmonic oscillator. We will work within a truncated basis of size $N$, $\\{|n\\rangle\\}_{n=0}^{N-1}$. Any state vector $|\\psi\\rangle$ is then represented by a column vector of coefficients $C$, where $C_n = \\langle n | \\psi \\rangle$.\n\n**2. Operator Matrices**\n\nTo perform calculations, we must construct the matrix representations of the relevant operators in this basis. The key operator is the position operator $\\hat{x}$. In atomic units ($m=1, \\hbar=1$), its matrix elements are given by:\n$$\n\\langle m | \\hat{x} | n \\rangle = \\sqrt{\\frac{1}{2\\omega}} \\left( \\sqrt{n+1} \\delta_{m, n+1} + \\sqrt{n} \\delta_{m, n-1} \\right)\n$$\nFrom this, we construct the matrix for the quadrupole operator $\\hat{Q} = \\hat{x}^2$. Its elements are:\n$$\nQ_{mn} = \\langle m | \\hat{x}^2 | n \\rangle = \\frac{1}{2\\omega} \\left[ \\sqrt{(n+1)(n+2)}\\delta_{m,n+2} + (2n+1)\\delta_{m,n} + \\sqrt{n(n-1)}\\delta_{m,n-2} \\right]\n$$\nThis results in a real, symmetric matrix, which we denote as $Q$. The matrix for the anharmonic potential term, $\\hat{x}^4$, is found by matrix multiplication: $X_4 = Q^2$.\n\nThe Hamiltonian matrix, $H$, is the sum of the harmonic part and the anharmonic part:\n$$\nH_{mn} = \\langle m | \\hat{H} | n \\rangle = \\langle m | \\hat{H}_0 | n \\rangle + \\alpha \\langle m | \\hat{x}^4 | n \\rangle\n$$\nThe harmonic part is diagonal in this basis, with elements $\\langle n | \\hat{H}_0 | n \\rangle = E_n = \\omega(n + 1/2)$. Thus, the full Hamiltonian matrix is:\n$$\nH = D_0 + \\alpha Q^2\n$$\nwhere $D_0$ is a diagonal matrix with entries $(D_0)_{nn} = \\omega(n + 1/2)$.\n\n**3. Initial State and Time Evolution**\n\nThe system starts in the ground state of the harmonic part, $|\\psi_{\\text{GS}}\\rangle = |0\\rangle$. In our truncated basis, this state is represented by the vector $C_{\\text{GS}} = [1, 0, \\dots, 0]^T$.\n\nAn instantaneous kick is applied, transforming the state to $|\\psi(0)\\rangle = \\hat{U}_{\\text{kick}} |\\psi_{\\text{GS}}\\rangle$. The initial state vector for the subsequent evolution is:\n$$\nC(0) = \\exp(-i\\kappa Q) C_{\\text{GS}}\n$$\nwhere $\\exp(\\cdot)$ denotes the matrix exponential.\n\nFor a time-independent Hamiltonian $\\hat{H}$, the state at time $t$ is $|\\psi(t)\\rangle = \\exp(-i\\hat{H}t)|\\psi(0)\\rangle$. The most accurate way to compute this evolution is by diagonalizing the Hamiltonian matrix $H$. Since $H$ is real and symmetric (Hermitian), it can be diagonalized by a unitary matrix $U$:\n$$\nH = UDU^\\dagger\n$$\nwhere $D$ is a diagonal matrix of eigenvalues $E'_k$ (the eigenenergies of $\\hat{H}$), and $U$ is the matrix whose columns are the corresponding eigenvectors $|k'\\rangle$. The time evolution operator is then $\\exp(-iHt) = U\\exp(-iDt)U^\\dagger$. The state vector at time $t$ is:\n$$\nC(t) = U e^{-iDt} U^\\dagger C(0)\n$$\n\n**4. Signal Calculation**\n\nThe time-dependent expectation value of the quadrupole operator is $\\langle \\hat{Q} \\rangle(t) = \\langle \\psi(t) | \\hat{Q} | \\psi(t) \\rangle = C(t)^\\dagger Q C(t)$. This calculation can be efficiently vectorized for all time steps $t_m = m \\cdot dt$. First, we transform the initial state into the eigenbasis of $H$: $\\tilde{C}(0) = U^\\dagger C(0)$. The coefficients at time $t$ in this basis are $\\tilde{C}_k(t) = e^{-iE'_k t} \\tilde{C}_k(0)$. Transforming back to the original basis gives the state vector $C(t)$ at each time step, from which the time series $\\langle \\hat{Q} \\rangle(t)$ is computed.\n\nThe response signal is then constructed as:\n$$\ns(t) = \\left(\\langle \\hat{Q} \\rangle(t) - \\langle \\hat{Q} \\rangle(0)\\right)\\,e^{-\\gamma t}\n$$\nThe subtraction of $\\langle \\hat{Q} \\rangle(0)$ removes the static component, and the exponential windowing function $e^{-\\gamma t}$ serves to apodize the signal, which is necessary for a finite-time simulation to avoid spectral artifacts.\n\n**5. Spectral Analysis**\n\nThe final step is to compute the quadrupole response spectrum $S(\\Omega)$ via the Fourier transform of the signal $s(t)$:\n$$\nS(\\Omega) = \\left|\\int_0^T s(t)\\,e^{i \\Omega t}\\,dt\\right|\n$$\nNumerically, this integral is approximated by a sum, which can be computed rapidly using the Fast Fourier Transform (FFT) algorithm on the discretized signal $s(t_m)$. The problem definition requires a Fourier transform with a positive sign in the exponent, which corresponds to the convention of an inverse FFT. However, since only the magnitude $|S(\\Omega)|$ is required, a standard forward FFT suffices, as its magnitude is identical to that of the inverse FFT.\n\nThe output of the FFT gives the spectrum at a discrete set of angular frequencies $\\Omega_k$. We are interested in the physically meaningful positive frequencies, $\\Omega_k > 0$. The dominant peak position, $\\Omega_{\\mathrm{peak}}$, is found by identifying the frequency that maximizes $|S(\\Omega_k)|$ in this positive range.\n$$\n\\Omega_{\\mathrm{peak}} = \\underset{\\Omega_k > 0}{\\arg\\max}\\, |S(\\Omega_k)|\n$$\nThis procedure is applied to each parameter set provided in the test suite.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef compute_peak_frequency(omega, alpha, kappa, N, T, dt, gamma):\n    \"\"\"\n    Computes the dominant peak frequency in the quadrupole response spectrum for a 1D\n    quantum oscillator with an optional anharmonic term.\n\n    The method involves:\n    1. Setting up the problem in the harmonic oscillator eigenbasis.\n    2. Constructing matrix representations of operators (x^2, H).\n    3. Preparing the initial state by applying a quadrupole kick.\n    4. Evolving the state in time by diagonalizing the Hamiltonian.\n    5. Calculating the time-dependent expectation value of x^2.\n    6. Performing a Fourier transform on the windowed signal to get the spectrum.\n    7. Finding the frequency of the spectrum's maximum peak.\n    \"\"\"\n    # 1. Grid and Basis Setup\n    num_steps = int(T / dt)\n    times = np.arange(num_steps) * dt\n\n    # 2. Operator Matrices in the Harmonic Oscillator Basis\n    # Matrix for the quadrupole operator Q = x^2\n    X2_mat = np.zeros((N, N), dtype=float)\n    diag_indices = np.arange(N)\n    # Diagonal elements <n|x^2|n>\n    X2_mat[diag_indices, diag_indices] = (2 * diag_indices + 1) / (2 * omega)\n    # Off-diagonal elements <n|x^2|n+2> and <n+2|x^2|n>\n    if N > 2:\n        off_diag_indices = np.arange(N - 2)\n        vals = np.sqrt((off_diag_indices + 1) * (off_diag_indices + 2)) / (2 * omega)\n        X2_mat[off_diag_indices, off_diag_indices + 2] = vals\n        X2_mat[off_diag_indices + 2, off_diag_indices] = vals\n\n    # Matrix for the x^4 term via matrix multiplication\n    X4_mat = X2_mat @ X2_mat\n\n    # Full Hamiltonian Matrix H = H_harmonic + alpha * x^4\n    H_mat = np.diag(omega * (np.arange(N) + 0.5)) + alpha * X4_mat\n\n    # 3. Initial State Preparation\n    # The system starts in the ground state of the harmonic part, |0>\n    C_gs = np.zeros(N, dtype=complex)\n    C_gs[0] = 1.0\n    \n    # Apply the kick operator U_kick = exp(-i*kappa*x^2) to the ground state\n    U_kick_mat = expm(-1j * kappa * X2_mat)\n    C0 = U_kick_mat @ C_gs\n\n    # 4. Diagonalize the Hamiltonian for Time Evolution\n    eigvals, eigvecs = np.linalg.eigh(H_mat)\n    U = eigvecs\n\n    # 5. Time Evolution and Signal Calculation (Vectorized)\n    # Transform initial state to the eigenbasis of H\n    C0_tilde = U.T.conj() @ C0\n    \n    # Evolve the state coefficients in the H eigenbasis over all time steps\n    # C_t_tilde will have shape (N, num_steps)\n    C_t_tilde = C0_tilde[:, np.newaxis] * np.exp(-1j * eigvals[:, np.newaxis] * times[np.newaxis, :])\n    \n    # Transform the state vectors back to the original harmonic oscillator basis\n    # C_t will have shape (N, num_steps)\n    C_t = U @ C_t_tilde\n    \n    # Calculate the expectation value <Q>(t) = <psi(t)|x^2|psi(t)> for all t.\n    # We use np.einsum for an efficient, vectorized computation.\n    q_exp_t = np.einsum('it,ij,jt->t', C_t.conj(), X2_mat, C_t).real\n\n    # 6. Spectral Analysis\n    # Get the initial expectation value and form the signal s(t)\n    q0 = q_exp_t[0]\n    s_t = (q_exp_t - q0) * np.exp(-gamma * times)\n    \n    # Compute the Fourier transform to get the spectrum S(Omega)\n    S_omega = np.fft.fft(s_t)\n    \n    # Get the corresponding angular frequencies\n    freqs = np.fft.fftfreq(num_steps, d=dt)\n    omega_freqs = 2 * np.pi * freqs\n\n    # 7. Peak Identification\n    # Find the peak in the positive frequency domain (Omega > 0)\n    positive_freq_mask = freqs > 0\n    \n    # Isolate frequencies and spectrum absolute values for Omega > 0\n    positive_omegas = omega_freqs[positive_freq_mask]\n    positive_spectrum_abs = np.abs(S_omega[positive_freq_mask])\n    \n    # Find the index corresponding to the maximum value of the spectrum\n    peak_idx = np.argmax(positive_spectrum_abs)\n    \n    # Identify the dominant peak frequency\n    omega_peak = positive_omegas[peak_idx]\n    \n    return omega_peak\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (omega, alpha, kappa, N, T, dt, gamma)\n    test_cases = [\n        (0.70, 0.00, 1.0e-3, 24, 800.0, 0.02, 0.002),\n        (1.10, 0.00, 1.0e-3, 24, 800.0, 0.02, 0.002),\n        (0.70, 0.02, 1.0e-3, 36, 800.0, 0.02, 0.002),\n        (0.20, 0.00, 1.0e-6, 24, 800.0, 0.02, 0.002),\n    ]\n\n    results = []\n    for params in test_cases:\n        peak_freq = compute_peak_frequency(*params)\n        results.append(peak_freq)\n\n    # Final print statement in the exact required format \"[x1,x2,x3,x4]\"\n    # with each result rounded to three decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2461370"}]}