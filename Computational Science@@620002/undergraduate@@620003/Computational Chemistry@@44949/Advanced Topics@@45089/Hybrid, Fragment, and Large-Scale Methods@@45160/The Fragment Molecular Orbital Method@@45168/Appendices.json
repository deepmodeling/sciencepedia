{"hands_on_practices": [{"introduction": "In the Fragment Molecular Orbital (FMO) method, the electrostatic environment created by distant fragments is crucial for accurate calculations, but modeling it exactly is computationally expensive. This exercise explores how this long-range potential is efficiently approximated using multipole expansions. By implementing and comparing approximations of different orders (monopole, dipole, and quadrupole) against the exact potential, you will gain a hands-on understanding of the fundamental trade-off between accuracy and computational cost in modeling electrostatic interactions [@problem_id:2464495].", "problem": "You are implementing a quantitative analysis relevant to the Fragment Molecular Orbital (FMO) method in computational chemistry. The task is to assess the error introduced when modeling the electrostatic potential of a distant fragment using either a point-charge (monopole) approximation or higher-order multipole expansions. Begin from the fundamental Coulomb potential of discrete charges and formal definitions of multipole moments. Work entirely in atomic units, where the Coulomb constant equals $1$, electric charge is measured in units of the elementary charge, length in bohr, and electrostatic potential in Hartree per elementary charge. All reported potentials and errors must be in Hartree per elementary charge.\n\nYour program must:\n\n- Use the electrostatic potential due to a set of discrete point charges defined by positions and charges. The exact potential at a field point $\\mathbf{r}$ is given by the sum over all charges via Coulomb’s law. All calculations must be performed using a multipole expansion about a well-defined origin chosen as the geometric centroid (arithmetic mean of the fragment’s site positions). Define the multipole moments (monopole, dipole, and quadrupole) of the fragment about this centroid.\n\n- Define the multipole approximation at order $L \\in \\{0,1,2\\}$ as follows: order $L=0$ uses the monopole term only (point-charge model), order $L=1$ uses monopole and dipole terms, and order $L=2$ uses monopole, dipole, and quadrupole terms. The multipole expansion must be derived from the Taylor expansion of the Green’s function $|\\mathbf{r}-\\mathbf{R}|^{-1}$ about the origin and expressed in terms of the fragment’s multipole moments about the geometric centroid. The quadrupole tensor must use the standard traceless definition based on the second moments of the charge distribution.\n\n- For each test case, evaluate the exact electrostatic potential and its multipole approximations on the surface of a sphere of radius $R$ centered at the geometric centroid of the fragment. Use $N$ uniformly distributed directions on the sphere generated by the Fibonacci spherical grid defined by the golden angle $\\alpha = \\pi \\left(3 - \\sqrt{5}\\right)$. For $k \\in \\{0,1,\\dots,N-1\\}$, define\n  - $z_k = 1 - \\dfrac{2(k+0.5)}{N}$,\n  - $\\rho_k = \\sqrt{1 - z_k^2}$,\n  - $\\phi_k = k \\, \\alpha$,\n  - $\\hat{\\mathbf{u}}_k = \\left(\\rho_k \\cos \\phi_k,\\ \\rho_k \\sin \\phi_k,\\ z_k\\right)$,\n  - $\\mathbf{r}_k = R \\, \\hat{\\mathbf{u}}_k$.\n  Use these $\\mathbf{r}_k$ as the $N$ field points.\n\n- Compute, for each order $L \\in \\{0,1,2\\}$, the root-mean-square (RMS) absolute error between the exact potential $V_{\\text{exact}}(\\mathbf{r}_k)$ and the order-$L$ multipole approximation $V_L(\\mathbf{r}_k)$ over the $N$ directions:\n  $$\\mathrm{RMS}_L = \\sqrt{\\dfrac{1}{N} \\sum_{k=0}^{N-1} \\left( V_{\\text{exact}}(\\mathbf{r}_k) - V_L(\\mathbf{r}_k) \\right)^2 }.$$\n  Report $\\mathrm{RMS}_L$ in Hartree per elementary charge.\n\nFundamental base you may use:\n- Coulomb’s law for point charges and linear superposition.\n- Taylor expansion of $|\\mathbf{r}-\\mathbf{R}|^{-1}$ about the origin for $|\\mathbf{r}| \\gg |\\mathbf{R}|$.\n- Definitions of multipole moments (monopole, dipole vector, and traceless quadrupole tensor) about a specified origin.\n\nImplement the following test suite. Each test case specifies a fragment as a list of tuples $(q_i, x_i, y_i, z_i)$, the observation radius $R$, and the number of directions $N$:\n\n- Test case A (charged, well-separated):\n  - Fragment: $\\left[(+1.0, 0.0, 0.0, 0.0),\\ (+0.5, 1.0, 0.0, 0.0)\\right]$.\n  - Radius: $R = 25.0$.\n  - Directions: $N = 64$.\n\n- Test case B (neutral dipole, well-separated):\n  - Fragment: $\\left[(+1.0, 0.0, 0.0, -1.0),\\ (-1.0, 0.0, 0.0, +1.0)\\right]$.\n  - Radius: $R = 30.0$.\n  - Directions: $N = 64$.\n\n- Test case C (neutral, dipole-free, quadrupole-dominated, well-separated):\n  - Fragment: $\\left[(+1.0, +1.0, 0.0, 0.0),\\ (+1.0, -1.0, 0.0, 0.0),\\ (-1.0, 0.0, +1.0, 0.0),\\ (-1.0, 0.0, -1.0, 0.0)\\right]$.\n  - Radius: $R = 40.0$.\n  - Directions: $N = 64$.\n\n- Test case D (neutral dipole, borderline separation):\n  - Fragment: $\\left[(+1.0, 0.0, 0.0, -5.0),\\ (-1.0, 0.0, 0.0, +5.0)\\right]$.\n  - Radius: $R = 10.0$.\n  - Directions: $N = 64$.\n\nAll coordinates $(x_i, y_i, z_i)$ and the radius $R$ are in bohr. All charges $q_i$ are in units of the elementary charge. The geometric centroid (arithmetic mean of the site positions) must be used as the expansion origin and as the center of the observation sphere.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- Each test case result must be a list of three floating-point numbers $[\\mathrm{RMS}_0, \\mathrm{RMS}_1, \\mathrm{RMS}_2]$, corresponding to the RMS absolute errors for orders $L=0,1,2$, respectively.\n- The overall output must therefore be a list of four lists, in the order of the test cases A, B, C, D.\n- Each floating-point number must be rounded to exactly $8$ decimal places.\n- For example, a syntactically correct output with placeholder values would look like: $[[0.12345678,0.01234567,0.00123456],[\\dots],[\\dots],[\\dots]]$.\n\nYour program must implement all steps and print only the required single-line output in the exact format described.", "solution": "The problem requires a quantitative analysis of the error introduced by multipole approximations to the electrostatic potential of a discrete charge distribution, which is a foundational concept in methods such as the Fragment Molecular Orbital (FMO) method. The analysis must be performed in atomic units.\n\nThe first step is to establish the rigorous mathematical framework. For a collection of $n$ point charges $\\{q_i\\}$ located at positions $\\{\\mathbf{R}_i\\}$, the exact electrostatic potential at a field point $\\mathbf{r}$ is given by the principle of linear superposition and Coulomb's law:\n$$\nV_{\\text{exact}}(\\mathbf{r}) = \\sum_{i=1}^{n} \\frac{q_i}{|\\mathbf{r} - \\mathbf{R}_i|}\n$$\nThis exact potential serves as the reference against which all approximations are measured.\n\nThe multipole expansion provides an approximation for this potential at points $\\mathbf{r}$ that are distant from the charge distribution. The expansion is formulated as a Taylor series of the Green's function, $1/|\\mathbf{r}-\\mathbf{R}|$, around a chosen origin. As specified, the origin for the expansion, $\\mathbf{R}_{\\text{orig}}$, is the geometric centroid of the charge sites:\n$$\n\\mathbf{R}_{\\text{orig}} = \\frac{1}{n} \\sum_{i=1}^{n} \\mathbf{R}_i\n$$\nThis choice of origin is standard in many FMO implementations. We define coordinates relative to this centroid: the positions of the charges are $\\mathbf{R'}_i = \\mathbf{R}_i - \\mathbf{R}_{\\text{orig}}$, and the field point is $\\mathbf{r'} = \\mathbf{r} - \\mathbf{R}_{\\text{orig}}$. The expansion is valid when $|\\mathbf{r'}| \\gg |\\mathbf{R'}_i|$ for all $i$.\n\nThe electrostatic potential can then be expressed as a series in terms of the multipole moments of the charge distribution. The moments are defined with respect to the centroid.\nThe monopole moment is the total charge of the fragment:\n$$\nq = \\sum_{i=1}^{n} q_i\n$$\nThe dipole moment is a vector quantity:\n$$\n\\mathbf{p} = \\sum_{i=1}^{n} q_i \\mathbf{R'}_i\n$$\nThe traceless quadrupole moment is a second-rank tensor with components $Q_{\\alpha\\beta}$ (where $\\alpha, \\beta \\in \\{x, y, z\\}$):\n$$\nQ_{\\alpha\\beta} = \\sum_{i=1}^{n} q_i (3 R'_{i\\alpha} R'_{i\\beta} - |\\mathbf{R'}_i|^2 \\delta_{\\alpha\\beta})\n$$\nwhere $\\delta_{\\alpha\\beta}$ is the Kronecker delta.\n\nUsing these moments, the potential at a field point $\\mathbf{r'}$ can be approximated to different orders, $L$.\nThe order $L=0$ approximation includes only the monopole term:\n$$\nV_{0}(\\mathbf{r'}) = \\frac{q}{|\\mathbf{r'}|}\n$$\nThis is the point-charge approximation.\nThe order $L=1$ approximation includes monopole and dipole terms:\n$$\nV_{1}(\\mathbf{r'}) = \\frac{q}{|\\mathbf{r'}|} + \\frac{\\mathbf{p} \\cdot \\mathbf{r'}}{|\\mathbf{r'}|^{3}}\n$$\nThe order $L=2$ approximation adds the quadrupole term:\n$$\nV_{2}(\\mathbf{r'}) = \\frac{q}{|\\mathbf{r'}|} + \\frac{\\mathbf{p} \\cdot \\mathbf{r'}}{|\\mathbf{r'}|^{3}} + \\frac{1}{2} \\sum_{\\alpha, \\beta} Q_{\\alpha\\beta} \\frac{r'_{\\alpha} r'_{\\beta}}{|\\mathbf{r'}|^{5}}\n$$\n\nTo assess the accuracy of these approximations, we evaluate the potentials at a set of $N$ field points distributed uniformly on the surface of a sphere of radius $R$, centered at the fragment's geometric centroid. The positions of these field points are generated using the Fibonacci spherical grid algorithm. For $k \\in \\{0, 1, ..., N-1\\}$, the position vector of the $k$-th field point, relative to the centroid, is $\\mathbf{r'}_k = R \\hat{\\mathbf{u}}_k$, where $\\hat{\\mathbf{u}}_k$ is a unit vector. The absolute position is $\\mathbf{r}_k = \\mathbf{R}_{\\text{orig}} + \\mathbf{r'}_k$.\n\nThe error of each approximation is quantified by the root-mean-square (RMS) absolute error over the $N$ field points:\n$$\n\\mathrm{RMS}_L = \\sqrt{\\frac{1}{N} \\sum_{k=0}^{N-1} \\left( V_{\\text{exact}}(\\mathbf{r}_k) - V_L(\\mathbf{r'}_k) \\right)^2 }\n$$\nfor $L \\in \\{0, 1, 2\\}$.\n\nThe algorithm for each test case is as follows:\n1.  Given the fragment's charges $\\{q_i\\}$ and positions $\\{\\mathbf{R}_i\\}$, compute the geometric centroid $\\mathbf{R}_{\\text{orig}}$.\n2.  Calculate the relative positions $\\mathbf{R'}_i = \\mathbf{R}_i - \\mathbf{R}_{\\text{orig}}$.\n3.  Compute the monopole moment $q$, dipole moment vector $\\mathbf{p}$, and traceless quadrupole tensor $\\mathbf{Q}$.\n4.  Generate $N$ field points $\\{\\mathbf{r}_k\\}$ on the sphere of radius $R$ centered at $\\mathbf{R}_{\\text{orig}}$. The relative positions are $\\{\\mathbf{r'}_k\\}$.\n5.  For each point $k$, calculate the exact potential $V_{\\text{exact}}(\\mathbf{r}_k)$ using the original charge positions.\n6.  For each point $k$, calculate the approximate potentials $V_0(\\mathbf{r'}_k)$, $V_1(\\mathbf{r'}_k)$, and $V_2(\\mathbf{r'}_k)$ using the multipole moments.\n7.  Compute the RMS errors $\\mathrm{RMS}_0$, $\\mathrm{RMS}_1$, and $\\mathrm{RMS}_2$ according to the formula above.\nThis procedure is systematically applied to all provided test cases to yield the required numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import linalg # Not required for this implementation\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It calculates the RMS errors for multipole expansions of the electrostatic potential.\n    \"\"\"\n\n    def compute_errors_for_case(fragment_data, R, N):\n        \"\"\"\n        Computes the RMS errors [RMS_0, RMS_1, RMS_2] for a single test case.\n\n        Args:\n            fragment_data (np.ndarray): Array of shape (num_atoms, 4) with [q, x, y, z].\n            R (float): Radius of the observation sphere in bohr.\n            N (int): Number of field points on the sphere.\n\n        Returns:\n            list: A list of three floats [rms0, rms1, rms2].\n        \"\"\"\n        # 1. Parse Input Data from fragment\n        charges = fragment_data[:, 0]\n        positions = fragment_data[:, 1:]\n\n        # 2. Calculate Geometric Centroid\n        centroid = np.mean(positions, axis=0)\n\n        # 3. Shift Coordinates to be relative to the centroid\n        rel_positions = positions - centroid\n\n        # 4. Calculate Multipole Moments\n        # Monopole (L=0)\n        monopole_q = np.sum(charges)\n\n        # Dipole (L=1)\n        dipole_p = np.sum(charges[:, np.newaxis] * rel_positions, axis=0)\n\n        # Traceless Quadrupole Tensor (L=2)\n        # Q_{\\alpha\\beta} = \\sum_i q_i (3 R'_{i\\alpha} R'_{i\\beta} - |\\mathbf{R'}_i|^2 \\delta_{\\alpha\\beta})\n        term1_matrix = 3 * np.einsum('i,ia,ib->ab', charges, rel_positions, rel_positions)\n        rel_pos_sq_mag = np.sum(rel_positions**2, axis=1)\n        trace_I = np.sum(charges * rel_pos_sq_mag)\n        term2_matrix = -trace_I * np.identity(3)\n        quadrupole_Q = term1_matrix + term2_matrix\n\n        # 5. Generate Field Points using Fibonacci spherical grid\n        k = np.arange(N)\n        golden_angle = np.pi * (3 - np.sqrt(5))\n        \n        z_k = 1 - (2 * (k + 0.5)) / N\n        rho_k = np.sqrt(1 - z_k**2)\n        phi_k = k * golden_angle\n        \n        x_k = rho_k * np.cos(phi_k)\n        y_k = rho_k * np.sin(phi_k)\n        \n        unit_vectors = np.stack([x_k, y_k, z_k], axis=1)  # Shape (N, 3)\n        \n        # Relative and absolute positions of field points\n        field_points_rel = R * unit_vectors\n        field_points_abs = field_points_rel + centroid\n\n        # 6. Calculate Potentials\n        # Exact Potential V_exact(r_k)\n        # Broadcasting is used for an efficient calculation over all field points.\n        # dist_matrix[k, i] = |r_k - R_i|\n        dist_matrix = np.linalg.norm(field_points_abs[:, np.newaxis, :] - positions[np.newaxis, :, :], axis=2)\n        # V_exact[k] = sum_i q_i / |r_k - R_i|\n        V_exact = np.sum(charges / dist_matrix, axis=1)  # Shape (N,)\n        \n        # Multipole Potentials V_L(r'_k)\n        # Order L=0 (Monopole)\n        V0 = np.full(N, monopole_q / R if R != 0 else np.inf)\n        \n        # Order L=1 (Monopole + Dipole)\n        # V_dipole_term = (p . r') / |r'|^3\n        V_dipole_term = np.dot(field_points_rel, dipole_p) / (R**3)\n        V1 = V0 + V_dipole_term\n        \n        # Order L=2 (Monopole + Dipole + Quadrupole)\n        # V_quad_term = 1/2 \\sum Q_ab r'_a r'_b / |r'|^5\n        quad_form = np.einsum('ki,ij,kj->k', field_points_rel, quadrupole_Q, field_points_rel)\n        V_quad_term = 0.5 * quad_form / (R**5)\n        V2 = V1 + V_quad_term\n        \n        # 7. Calculate RMS Errors\n        rms0 = np.sqrt(np.mean((V_exact - V0)**2))\n        rms1 = np.sqrt(np.mean((V_exact - V1)**2))\n        rms2 = np.sqrt(np.mean((V_exact - V2)**2))\n        \n        return [rms0, rms1, rms2]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {'fragment': np.array([[+1.0, 0.0, 0.0, 0.0], [+0.5, 1.0, 0.0, 0.0]]),\n         'R': 25.0, 'N': 64},\n        # Test case B\n        {'fragment': np.array([[+1.0, 0.0, 0.0, -1.0], [-1.0, 0.0, 0.0, +1.0]]),\n         'R': 30.0, 'N': 64},\n        # Test case C\n        {'fragment': np.array([[+1.0, +1.0, 0.0, 0.0], [+1.0, -1.0, 0.0, 0.0],\n                               [-1.0, 0.0, +1.0, 0.0], [-1.0, 0.0, -1.0, 0.0]]),\n         'R': 40.0, 'N': 64},\n        # Test case D\n        {'fragment': np.array([[+1.0, 0.0, 0.0, -5.0], [-1.0, 0.0, 0.0, +5.0]]),\n         'R': 10.0, 'N': 64},\n    ]\n\n    results = []\n    for case in test_cases:\n        rms_errors = compute_errors_for_case(case['fragment'], case['R'], case['N'])\n        results.append(rms_errors)\n\n    # Format final output string as per requirements\n    result_strings = []\n    for res in results:\n        # Each floating-point number must be rounded to exactly 8 decimal places.\n        formatted_res = [f\"{x:.8f}\" for x in res]\n        result_strings.append(f\"[{','.join(formatted_res)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2464495"}, {"introduction": "The total energy in FMO is constructed from the energies of individual fragments and the interactions between pairs of fragments, quantified as Pair Interaction Energies (PIEs). This practice problem allows you to dissect the PIE into its fundamental physical components: classical Coulombic attraction/repulsion and quantum-mechanical induction (polarization). By modeling the interaction between a water molecule and different ions, you will see how the unique chemical features of each fragment dictate the strength and nature of their pairwise interactions [@problem_id:2464489].", "problem": "You will implement a complete program that computes and compares an approximate Pair Interaction Energy (PIE) between a single water molecule and a monatomic ion, using a simplified, first-principles electrostatics-plus-induction model inspired by the Fragment Molecular Orbital (FMO) method. In the Fragment Molecular Orbital (FMO) method, the Pair Interaction Energy (PIE) between two fragments is defined as the energy change upon associating the fragments, using the same Hamiltonian as the total system. In this problem, you will compute a classical approximation to the PIE as the sum of two physically motivated terms: the direct Coulomb interaction between the ion and fixed water partial charges, and the induction energy due to the ion’s electric field polarizing the water molecule. All quantities and units needed are specified below.\n\nGeometric and charge model for the water molecule:\n- Place the oxygen atom at the origin. The molecule lies in the $xz$-plane with the bisector of the H–O–H angle aligned along the $+z$ axis.\n- The O–H bond length is $0.9572~\\mathrm{\\AA}$. The H–O–H bond angle is $104.52^\\circ$.\n- Let $\\theta = 104.52^\\circ/2 = 52.26^\\circ$. The hydrogen atom positions are\n  $$\n  \\mathbf{r}_{\\mathrm{H}_1} = \\bigl( \\, 0.9572\\sin\\theta,\\, 0,\\, 0.9572\\cos\\theta \\, \\bigr)~\\mathrm{\\AA}, \\quad\n  \\mathbf{r}_{\\mathrm{H}_2} = \\bigl( \\, -0.9572\\sin\\theta,\\, 0,\\, 0.9572\\cos\\theta \\, \\bigr)~\\mathrm{\\AA}.\n  $$\n- Fixed partial charges on water (units of elementary charge $e$): $q_{\\mathrm{O}}=-0.834\\,e$ on oxygen, $q_{\\mathrm{H}}=+0.417\\,e$ on each hydrogen.\n\nIon model and placement:\n- Consider a monatomic ion of charge $q_{\\mathrm{ion}}=\\pm 1\\,e$ located on the $+z$ axis at position $\\mathbf{r}_{\\mathrm{ion}}=(0,0,R)$ with $R$ specified in $\\mathrm{\\AA}$. Use $q_{\\mathrm{ion}}=+1\\,e$ for lithium cation $\\mathrm{Li}^+$ and $q_{\\mathrm{ion}}=-1\\,e$ for fluoride anion $\\mathrm{F}^-$.\n\nEnergy model:\n- The total interaction energy is modeled as\n  $$\n  E_{\\mathrm{tot}}(R;q_{\\mathrm{ion}})=E_{\\mathrm{coul}}(R;q_{\\mathrm{ion}})+E_{\\mathrm{ind}}(R;q_{\\mathrm{ion}}),\n  $$\n  where the Coulomb term sums pairwise ion–site interactions and the induction term models isotropic polarization of water by the ion’s field.\n- Coulomb term:\n  $$\n  E_{\\mathrm{coul}}(R;q_{\\mathrm{ion}})=k_e \\sum_{a\\in\\{\\mathrm{O},\\mathrm{H}_1,\\mathrm{H}_2\\}} \\frac{q_{\\mathrm{ion}}\\, q_a}{\\|\\mathbf{r}_{\\mathrm{ion}}-\\mathbf{r}_a\\|},\n  $$\n  with $k_e=\\dfrac{1}{4\\pi\\varepsilon_0}=8.9875517923\\times 10^9~\\mathrm{N\\,m^2\\,C^{-2}}$. Use the elementary charge magnitude $e=1.602176634\\times 10^{-19}~\\mathrm{C}$ for converting the charges $q_{\\mathrm{ion}}$ and $q_a$ into Coulombs, and convert all distances from $\\mathrm{\\AA}$ to meters using $1~\\mathrm{\\AA}=1.0\\times 10^{-10}~\\mathrm{m}$ before evaluating $E_{\\mathrm{coul}}$ in Joules.\n- Induction term (isotropic, linear response, centered at oxygen):\n  $$\n  E_{\\mathrm{ind}}(R;q_{\\mathrm{ion}})=-\\frac{1}{2}\\,\\alpha\\, \\|\\mathbf{E}_{\\mathrm{ion}\\to \\mathrm{O}}\\|^2,\n  $$\n  where $\\alpha$ is the isotropic molecular polarizability of water and $\\mathbf{E}_{\\mathrm{ion}\\to \\mathrm{O}}$ is the electric field at the oxygen due solely to the ion. Treat water as polarizable only at oxygen. The electric field magnitude at oxygen from a point charge $q_{\\mathrm{ion}}$ at distance $R$ is\n  $$\n  \\|\\mathbf{E}_{\\mathrm{ion}\\to \\mathrm{O}}\\|=\\frac{k_e\\,|q_{\\mathrm{ion}}|}{R^2},\n  $$\n  with $R$ in meters and $q_{\\mathrm{ion}}$ in Coulombs. Use an isotropic polarizability $\\alpha=1.45~\\mathrm{\\AA^3}$ converted to SI via $1~\\mathrm{\\AA^3}=1.64877727436\\times 10^{-41}~\\mathrm{C\\,m^2\\,V^{-1}}$.\n- Convert the final energy from Joules per molecule to $\\mathrm{kJ/mol}$ using the Avogadro constant $N_{\\mathrm{A}}=6.02214076\\times 10^{23}~\\mathrm{mol^{-1}}$ and $1~\\mathrm{kJ}=10^3~\\mathrm{J}$.\n\nAngle unit specification:\n- Trigonometric functions use radians. The bond angle given in degrees must be converted to radians where needed. The electric field and Coulomb expressions require distances in meters.\n\nTest suite:\n- Evaluate the model for the following ion–oxygen separations $R$ (in $\\mathrm{\\AA}$): $[\\,2.0,\\, 2.5,\\, 3.5,\\, 10.0\\,]$. For each $R$, compute three quantities in $\\mathrm{kJ/mol}$:\n  1. $E_{\\mathrm{tot}}(R;+1\\,e)$ for $\\mathrm{Li}^+$,\n  2. $E_{\\mathrm{tot}}(R;-1\\,e)$ for $\\mathrm{F}^-$,\n  3. $\\Delta E(R)=E_{\\mathrm{tot}}(R;+1\\,e)-E_{\\mathrm{tot}}(R;-1\\,e)$.\n- All reported energies must be rounded to exactly $6$ decimal places and expressed in $\\mathrm{kJ/mol}$.\n\nFinal output format:\n- Your program should produce a single line of output containing a JSON-like Python list of lists, one inner list per test case in the same order as the test suite. Each inner list must be ordered as $[E_{\\mathrm{tot}}(R;+1\\,e),\\,E_{\\mathrm{tot}}(R;-1\\,e),\\,\\Delta E(R)]$, with each float rounded to exactly $6$ decimal places. For example: $[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],\\dots]$.", "solution": "The problem presented is a valid exercise in computational physics and chemistry. It is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It requires the application of fundamental principles of electrostatics to model a simplified ion-molecule interaction, a common practice in the development and understanding of molecular mechanics force fields and quantum-chemical fragmentation methods. We shall proceed with a rigorous derivation of the solution.\n\nThe total interaction energy, $E_{\\mathrm{tot}}$, between the ion and the water molecule is given as the sum of a Coulombic term, $E_{\\mathrm{coul}}$, and an induction term, $E_{\\mathrm{ind}}$. We will analyze each component separately, ensuring all quantities are expressed in SI units for calculation, and then convert the final energy to the required units of $\\mathrm{kJ/mol}$.\n\nFirst, we establish the fundamental constants and conversion factors in their SI form:\n- Coulomb's constant: $k_e = 8.9875517923 \\times 10^9~\\mathrm{N\\,m^2\\,C^{-2}}$\n- Elementary charge: $e = 1.602176634 \\times 10^{-19}~\\mathrm{C}$\n- Avogadro constant: $N_{\\mathrm{A}} = 6.02214076 \\times 10^{23}~\\mathrm{mol^{-1}}$\n- Angstrom to meter conversion: $1~\\mathrm{\\AA} = 1.0 \\times 10^{-10}~\\mathrm{m}$\n- Polarizability volume conversion ($\\mathrm{\\AA^3}$ to SI): $1~\\mathrm{\\AA^3} = 1.64877727436 \\times 10^{-41}~\\mathrm{C\\,m^2\\,V^{-1}}$\n\nNext, we establish the geometry of the water molecule. The oxygen atom is at the origin, $\\mathbf{r}_{\\mathrm{O}} = (0, 0, 0)$. The O-H bond length is $d_{\\mathrm{OH}} = 0.9572~\\mathrm{\\AA}$ and the H-O-H angle is $\\phi = 104.52^\\circ$. The half-angle, $\\theta = \\phi/2 = 52.26^\\circ$, must be converted to radians for use in trigonometric functions: $\\theta_{\\mathrm{rad}} = 52.26 \\cdot (\\pi / 180)$. The coordinates of the hydrogen atoms are then:\n$z_{\\mathrm{H}} = d_{\\mathrm{OH}} \\cos(\\theta_{\\mathrm{rad}})$\n$x_{\\mathrm{H}} = d_{\\mathrm{OH}} \\sin(\\theta_{\\mathrm{rad}})$\nSo, $\\mathbf{r}_{\\mathrm{H}_1} = (x_{\\mathrm{H}}, 0, z_{\\mathrm{H}})$ and $\\mathbf{r}_{\\mathrm{H}_2} = (-x_{\\mathrm{H}}, 0, z_{\\mathrm{H}})$.\nThe ion is located at $\\mathbf{r}_{\\mathrm{ion}} = (0, 0, R)$. All coordinates are initially in Angstroms.\n\n**1. Coulomb Interaction Energy, $E_{\\mathrm{coul}}$**\n\nThe Coulomb energy is the sum of pairwise interactions between the ion and the partial charges on the water molecule:\n$$\nE_{\\mathrm{coul}}(R; q_{\\mathrm{ion}}) = k_e \\sum_{a \\in \\{\\mathrm{O}, \\mathrm{H}_1, \\mathrm{H}_2\\}} \\frac{q_{\\mathrm{ion}} q_a}{\\|\\mathbf{r}_{\\mathrm{ion}} - \\mathbf{r}_a\\|}\n$$\nThe charges $q_{\\mathrm{ion}}$ and $q_a$ are given as multiples of $e$. Let the dimensionless charge values be $q'_{\\mathrm{ion}}$ and $q'_a$. The actual charges are $q'_{\\mathrm{ion}}e$ and $q'_a e$. The distances must be in meters.\nThe distances between the ion and the water atoms are:\n- Ion-Oxygen distance: $d_{\\mathrm{ion-O}} = \\|\\mathbf{r}_{\\mathrm{ion}} - \\mathbf{r}_{\\mathrm{O}}\\| = \\|(0,0,R) - (0,0,0)\\| = R$.\n- Ion-Hydrogen distance: By symmetry, the distance is the same for both hydrogen atoms.\n$$\nd_{\\mathrm{ion-H}} = \\|\\mathbf{r}_{\\mathrm{ion}} - \\mathbf{r}_{\\mathrm{H}_1}\\| = \\sqrt{(0 - x_{\\mathrm{H}})^2 + (0 - 0)^2 + (R - z_{\\mathrm{H}})^2} = \\sqrt{x_{\\mathrm{H}}^2 + (R - z_{\\mathrm{H}})^2}\n$$\nSubstituting these into the energy expression, with distances in $\\mathrm{\\AA}$ and a conversion factor $10^{-10}~\\mathrm{m/\\AA}$:\n$$\nE_{\\mathrm{coul}} [\\mathrm{J}] = k_e \\frac{(q'_{\\mathrm{ion}}e)(q'_{\\mathrm{O}}e)}{R \\times 10^{-10}} + 2 \\cdot k_e \\frac{(q'_{\\mathrm{ion}}e)(q'_{\\mathrm{H}}e)}{d_{\\mathrm{ion-H}} \\times 10^{-10}}\n$$\n$$\nE_{\\mathrm{coul}} [\\mathrm{J}] = \\frac{k_e e^2}{10^{-10}} q'_{\\mathrm{ion}} \\left( \\frac{q'_{\\mathrm{O}}}{R} + \\frac{2q'_{\\mathrm{H}}}{d_{\\mathrm{ion-H}}} \\right)\n$$\nTo convert this to $\\mathrm{kJ/mol}$, we multiply by $N_{\\mathrm{A}}/1000$. The prefactor becomes:\n$$\nC_{\\mathrm{coul}} = \\frac{k_e e^2 N_{\\mathrm{A}}}{10^{-10} \\times 1000} \\approx 1389.3546~\\mathrm{kJ \\cdot \\AA \\cdot mol^{-1}}\n$$\nSo, the practical formula for the Coulomb energy, with $q'_{\\mathrm{ion}}=+1$, is:\n$$\nE_{\\mathrm{coul}}(R; +1e) [\\mathrm{kJ/mol}] = C_{\\mathrm{coul}} \\left( \\frac{-0.834}{R} + \\frac{2 \\times 0.417}{\\sqrt{x_{\\mathrm{H}}^2 + (R - z_{\\mathrm{H}})^2}} \\right)\n$$\nNote that $E_{\\mathrm{coul}}(R; -1e) = -E_{\\mathrm{coul}}(R; +1e)$.\n\n**2. Induction Energy, $E_{\\mathrm{ind}}$**\n\nThe induction energy arises from the polarization of the water molecule by the ion's electric field. It is given by:\n$$\nE_{\\mathrm{ind}}(R; q_{\\mathrm{ion}}) = -\\frac{1}{2} \\alpha \\|\\mathbf{E}_{\\mathrm{ion}\\to\\mathrm{O}}\\|^2\n$$\nThe magnitude of the electric field at the oxygen nucleus (origin) due to the ion at distance $R$ is:\n$$\n\\|\\mathbf{E}_{\\mathrm{ion}\\to\\mathrm{O}}\\| = \\frac{k_e |q_{\\mathrm{ion}}|}{(R \\times 10^{-10})^2} = \\frac{k_e |q'_{\\mathrm{ion}}| e}{(R \\times 10^{-10})^2}\n$$\nThe polarizability $\\alpha = 1.45~\\mathrm{\\AA^3}$ must be converted to SI units: $\\alpha_{\\mathrm{SI}} = 1.45 \\times (1.64877727436 \\times 10^{-41})~\\mathrm{C\\,m^2\\,V^{-1}}$.\nSubstituting these into the induction energy formula (with $|q'_{\\mathrm{ion}}|=1$):\n$$\nE_{\\mathrm{ind}} [\\mathrm{J}] = -\\frac{1}{2} \\alpha_{\\mathrm{SI}} \\left( \\frac{k_e e}{R^2 \\times (10^{-10})^2} \\right)^2 = -\\frac{1}{2} \\frac{\\alpha_{\\mathrm{SI}} (k_e e)^2}{(10^{-10})^4} \\frac{1}{R^4}\n$$\nwhere $R$ is in Angstroms. To convert to $\\mathrm{kJ/mol}$, we again multiply by $N_{\\mathrm{A}}/1000$:\n$$\nC_{\\mathrm{ind}} = \\frac{1}{2} \\frac{\\alpha_{\\mathrm{SI}} (k_e e)^2 N_{\\mathrm{A}}}{(10^{-10})^4 \\times 1000} = \\frac{1}{2} \\frac{(1.45 \\times 1.648... \\times 10^{-41}) (k_e e)^2 N_{\\mathrm{A}}}{10^{-40} \\times 1000} \\approx 149.2868~\\mathrm{kJ \\cdot \\AA^4 \\cdot mol^{-1}}\n$$\nThus, the practical formula for induction energy is:\n$$\nE_{\\mathrm{ind}} [\\mathrm{kJ/mol}] = - \\frac{C_{\\mathrm{ind}}}{R^4}\n$$\nThis term is independent of the sign of the ion's charge, as it depends on $|q_{\\mathrm{ion}}|^2$.\n\n**3. Total Energy and Difference Term**\n\nFor each distance $R$ in the test suite, we compute the required quantities:\n1.  For $\\mathrm{Li}^+$ ($q'_{\\mathrm{ion}}=+1$):\n    $E_{\\mathrm{tot}}(R;+1e) = E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R)$\n2.  For $\\mathrm{F}^-$ ($q'_{\\mathrm{ion}}=-1$):\n    $E_{\\mathrm{tot}}(R;-1e) = E_{\\mathrm{coul}}(R;-1e) + E_{\\mathrm{ind}}(R) = -E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R)$\n3.  The difference term:\n    $\\Delta E(R) = E_{\\mathrm{tot}}(R;+1e) - E_{\\mathrm{tot}}(R;-1e)$\n    $\\Delta E(R) = (E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R)) - (-E_{\\mathrm{coul}}(R;+1e) + E_{\\mathrm{ind}}(R))$\n    $\\Delta E(R) = 2 \\cdot E_{\\mathrm{coul}}(R;+1e)$\n\nThis demonstrates that the asymmetry in interaction energy is entirely due to the fixed, asymmetric charge distribution of the water molecule, as the induction term is symmetric with respect to the sign of the ion charge.\n\nThe computational procedure is as follows:\n- Define all constants and conversion factors.\n- Pre-calculate the water geometry parameters ($x_H, z_H$).\n- Iterate through each specified distance $R$.\n- For each $R$, calculate $E_{\\mathrm{coul}}(R;+1e)$ and $E_{\\mathrm{ind}}(R)$ in $\\mathrm{kJ/mol}$ using the derived practical formulas.\n- Combine these to find $E_{\\mathrm{tot}}(R;+1e)$, $E_{\\mathrm{tot}}(R;-1e)$, and $\\Delta E(R)$.\n- Round each of these three values to six decimal places.\n- Store the results and format the final output as specified.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares an approximate Pair Interaction Energy (PIE)\n    between a water molecule and a monatomic ion (Li+ or F-).\n    \"\"\"\n\n    # --- Constants and Conversion Factors (SI units) ---\n    K_E = 8.9875517923e9  # Coulomb's constant (N m^2 C^-2)\n    E_CHARGE = 1.602176634e-19  # Elementary charge (C)\n    N_A = 6.02214076e23  # Avogadro constant (mol^-1)\n    \n    # Conversion factors\n    ANGSTROM_TO_METER = 1.0e-10\n    ANGSTROM3_TO_SI_POL = 1.64877727436e-41 # (C m^2 V^-1) / A^3\n    JOULE_TO_KJ_MOL = N_A / 1000.0\n\n    # --- Problem-Specific Parameters ---\n    # Water geometry\n    D_OH = 0.9572  # O-H bond length (Angstrom)\n    THETA_HOH_DEG = 104.52  # H-O-H bond angle (degrees)\n\n    # Water partial charges (in units of elementary charge e)\n    Q_O = -0.834\n    Q_H = 0.417\n\n    # Water polarizability\n    ALPHA_WATER_A3 = 1.45 # (Angstrom^3)\n\n    # Ion charges (in units of elementary charge e)\n    Q_ION_LI = 1.0\n    Q_ION_F = -1.0\n    \n    # Test suite of ion-oxygen separations (Angstrom)\n    R_VALUES = [2.0, 2.5, 3.5, 10.0]\n\n    # --- Pre-calculations ---\n    \n    # Water atom coordinates (Angstroms)\n    theta_rad = np.deg2rad(THETA_HOH_DEG / 2.0)\n    z_h = D_OH * np.cos(theta_rad)\n    x_h = D_OH * np.sin(theta_rad)\n\n    # Prefactor for Coulomb energy calculation, converting from (e^2/Angstrom) to (kJ/mol)\n    # C_coul = (k_e * e^2) / (angstrom_to_meter) * (N_A / 1000)\n    coulomb_prefactor = (K_E * E_CHARGE**2 / ANGSTROM_TO_METER) * JOULE_TO_KJ_MOL\n\n    # Prefactor for induction energy, converting from (A^3 / A^4) to (kJ/mol)\n    # C_ind = 0.5 * (alpha_A3*conv_pol) * (k_e*e)^2 / (angstrom_to_meter)^4 * (N_A/1000)\n    # C_ind = 0.5 * alpha_A3 * [conv_pol * (k_e*e)^2 * N_A / (angstrom^4 * 1000)]\n    induction_prefactor = (0.5 * ALPHA_WATER_A3 * ANGSTROM3_TO_SI_POL * \n                           (K_E * E_CHARGE)**2 / (ANGSTROM_TO_METER**4) * \n                           JOULE_TO_KJ_MOL)\n                           \n    results = []\n    \n    # --- Main Calculation Loop ---\n    for R in R_VALUES:\n        # Distance between ion and hydrogen atoms (Angstrom)\n        d_ion_h = np.sqrt(x_h**2 + (R - z_h)**2)\n        \n        # --- 1. Coulomb Energy Calculation ---\n        # Calculate for a +1e charge (Li+)\n        # E_coul = C_coul * q_ion * (q_O/d_O + 2*q_H/d_H)\n        e_coul_pos_kjmol = coulomb_prefactor * Q_ION_LI * (\n            Q_O / R + 2 * Q_H / d_ion_h\n        )\n\n        # --- 2. Induction Energy Calculation ---\n        # The induction energy is proportional to q_ion^2, so it's the same\n        # for Li+ and F- (|q_ion|=1). The formula is E_ind = -C_ind / R^4.\n        e_ind_kjmol = -induction_prefactor / (R**4)\n\n        # --- 3. Total Energies and Difference ---\n        # Energy for Li+ (q_ion = +1)\n        e_tot_li = e_coul_pos_kjmol + e_ind_kjmol\n        \n        # Energy for F- (q_ion = -1)\n        # E_coul for -1 charge is -E_coul for +1 charge.\n        e_tot_f = -e_coul_pos_kjmol + e_ind_kjmol\n\n        # Difference E(Li+) - E(F-)\n        delta_e = e_tot_li - e_tot_f\n        # An equivalent and more direct calculation: delta_e = 2 * e_coul_pos_kjmol\n        \n        # Round results to 6 decimal places and store\n        results.append([\n            round(e_tot_li, 6),\n            round(e_tot_f, 6),\n            round(delta_e, 6)\n        ])\n\n    # --- Final Output Formatting ---\n    # Manually format the list of lists to match the required output string\n    # e.g., \"[[x1,y1,z1],[x2,y2,z2]]\"\n    output_str = '[' + ','.join(map(str, results)) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2464489"}, {"introduction": "Once fragment and pair energies are determined, the FMO method combines them to approximate the total energy of the entire molecular system, with the accuracy depending on the level of the many-body expansion. Using a simplified Hückel model for benzene, this exercise challenges you to apply the two-body FMO (FMO2) energy expression and directly evaluate its accuracy for different molecular partitions. You will discover firsthand how the choice of fragmentation critically determines the final error, a key practical consideration when applying the FMO method to real-world systems [@problem_id:2464440].", "problem": "You are given a benzene ring modeled as a cyclic graph of six carbon atoms labeled $1,2,3,4,5,6$, where each atom contributes one $\\pi$ electron. Consider the Fragment Molecular Orbital (FMO) method at the two-body expansion level (FMO2) applied to this system under a simplified Hückel Molecular Orbital (HMO) model with zero overlap. The Hückel Hamiltonian for any set of atoms $S$ is defined as a real symmetric matrix $H(S)$ with elements\n$$\nH_{ij}(S) =\n\\begin{cases}\n\\alpha, & \\text{if } i=j \\in S, \\\\\n\\beta, & \\text{if } i\\neq j,\\ i\\in S,\\ j\\in S,\\ \\text{and } i \\text{ and } j \\text{ are bonded in benzene}, \\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $\\alpha$ is the Coulomb parameter (on-site energy) and $\\beta$ is the resonance integral (nearest-neighbor interaction). The benzene bonding pattern is that of a $6$-cycle: atom $i$ is bonded to atoms $i-1$ and $i+1$ modulo $6$. Assume zero orbital overlap and no nuclear repulsion contribution. For any subsystem $S$, the total electronic energy $E(S)$ is defined by solving the eigenvalue problem $H(S)\\mathbf{c}_k=\\varepsilon_k\\mathbf{c}_k$, sorting the eigenvalues $\\varepsilon_k$ in ascending order, and then filling electrons according to the aufbau principle: each molecular orbital can accommodate at most $2$ electrons of opposite spin. If the electron count $N(S)$ is odd, the highest occupied molecular orbital has single occupancy. Since there is one $\\pi$ electron per carbon atom, use $N(S)=|S|$.\n\nDefine the FMO2 total energy for a fragmentation $\\mathcal{F}=\\{F_1,\\dots,F_M\\}$ as\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}) \\;=\\; \\sum_{I=1}^{M} E(F_I) \\;+\\; \\sum_{1\\le I < J \\le M} \\left[ E(F_I \\cup F_J) - E(F_I) - E(F_J) \\right].\n$$\nThe exact total energy $E_{\\mathrm{exact}}$ is $E(\\{1,2,3,4,5,6\\})$.\n\nConsider two fragmentations of benzene:\n- Fragmentation $\\mathcal{F}_{2+2+2}$ into three ethyne-like units (each with two adjacent carbons): $F_1=\\{1,2\\}$, $F_2=\\{3,4\\}$, $F_3=\\{5,6\\}$.\n- Fragmentation $\\mathcal{F}_{3+3}$ into two allyl-like units (each with three adjacent carbons): $G_1=\\{1,2,3\\}$, $G_2=\\{4,5,6\\}$.\n\nFor each set of parameters $(\\alpha,\\beta)$ in the test suite below, compute the FMO2 total energy error for both fragmentations, defined as\n$$\n\\Delta E_{\\mathcal{F}} \\;=\\; E_{\\mathrm{FMO2}}(\\mathcal{F}) - E_{\\mathrm{exact}}.\n$$\nReport energies in electronvolts (eV), rounded to six decimal places.\n\nTest suite (each pair $(\\alpha,\\beta)$ is in eV):\n- Case A (general): $(\\alpha,\\beta) = (\\,0.0,\\,-2.5\\,)$.\n- Case B (boundary, no coupling): $(\\alpha,\\beta) = (\\,1.0,\\,0.0\\,)$.\n- Case C (sign-inverted coupling): $(\\alpha,\\beta) = (\\,0.5,\\,2.0\\,)$.\n\nYour program must output a single line containing a list of results, one per test case, where each result is the list $[\\Delta E_{\\mathcal{F}_{2+2+2}},\\, \\Delta E_{\\mathcal{F}_{3+3}}]$ for that case, in the same order as the test suite. The final output must be a single line in the exact format of a comma-separated list enclosed in square brackets, for example $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$, where each $x_i$ and $y_i$ is a float rounded to six decimal places in eV.", "solution": "The problem is well-posed and scientifically sound, based on established principles of computational chemistry, specifically the Hückel Molecular Orbital (HMO) model and the Fragment Molecular Orbital (FMO) method. All required definitions, parameters, and constraints are provided. I will proceed with a solution.\n\nThe core of the problem is to compute the error of the two-body FMO approximation (FMO2) for two different fragmentations of a benzene ring. The error, $\\Delta E_{\\mathcal{F}}$, is defined as the difference between the FMO2 energy and the exact energy of the full system:\n$$\n\\Delta E_{\\mathcal{F}} = E_{\\mathrm{FMO2}}(\\mathcal{F}) - E_{\\mathrm{exact}}\n$$\nThe system is a benzene ring with six carbon atoms, each contributing one $\\pi$ electron. The total number of electrons in any subsystem $S$ is equal to its number of atoms, $|S|$.\n\nFirst, a general procedure for calculating the total electronic energy $E(S)$ for a subsystem $S$ under the HMO model must be established.\n1.  **Construct the Hückel Hamiltonian Matrix $H(S)$**: For a subsystem consisting of a set of atoms $S$, the Hamiltonian $H(S)$ is an $|S| \\times |S|$ matrix. Its elements are defined as $H_{ii}(S) = \\alpha$ for an atom $i \\in S$, and $H_{ij}(S) = \\beta$ if atoms $i, j \\in S$ are bonded in the original benzene molecule. All other elements are $0$. The bonding in benzene is cyclic: atom $i \\in \\{1, \\dots, 6\\}$ is bonded to $i-1$ and $i+1$ (with indices taken modulo $6$, mapping $0$ to $6$).\n2.  **Solve the Eigenvalue Problem**: The molecular orbital energies, $\\varepsilon_k$, are the eigenvalues of $H(S)$. We find these by solving the secular equation $H(S)\\mathbf{c}_k = \\varepsilon_k \\mathbf{c}_k$. The eigenvalues must be sorted in ascending order.\n3.  **Calculate Total Energy**: The total electronic energy $E(S)$ is obtained by filling the molecular orbitals with the available electrons, $N(S) = |S|$, according to the aufbau principle. With $N_{\\text{pairs}} = \\lfloor N(S)/2 \\rfloor$ doubly-occupied orbitals and $N_{\\text{unpaired}} = N(S) \\pmod 2$ singly-occupied orbitals, the energy is:\n    $$\n    E(S) = \\sum_{k=1}^{N_{\\text{pairs}}} 2\\varepsilon_k + \\sum_{k=N_{\\text{pairs}}+1}^{N_{\\text{pairs}}+N_{\\text{unpaired}}} \\varepsilon_k\n    $$\n\nThe exact energy, $E_{\\mathrm{exact}}$, is the energy of the entire benzene molecule, $E(\\{1,2,3,4,5,6\\})$.\n\nNext, we evaluate the FMO2 energy for each fragmentation. The general FMO2 formula is:\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}) = \\sum_{I=1}^{M} E(F_I) + \\sum_{1\\le I < J \\le M} \\left[ E(F_I \\cup F_J) - E(F_I) - E(F_J) \\right]\n$$\n\n**Fragmentation $\\mathcal{F}_{3+3}$:**\nThis fragmentation consists of two fragments, $G_1=\\{1,2,3\\}$ and $G_2=\\{4,5,6\\}$. In this case, $M=2$. The FMO2 formula simplifies significantly:\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{3+3}) = E(G_1) + E(G_2) + \\left[ E(G_1 \\cup G_2) - E(G_1) - E(G_2) \\right] = E(G_1 \\cup G_2)\n$$\nSince $G_1 \\cup G_2 = \\{1,2,3,4,5,6\\}$ is the entire benzene molecule, the FMO2 energy is exactly the energy of the full system:\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{3+3}) = E(\\{1,2,3,4,5,6\\}) = E_{\\mathrm{exact}}\n$$\nTherefore, the error for this fragmentation is always zero, regardless of the parameters $\\alpha$ and $\\beta$:\n$$\n\\Delta E_{\\mathcal{F}_{3+3}} = E_{\\mathrm{FMO2}}(\\mathcal{F}_{3+3}) - E_{\\mathrm{exact}} = 0\n$$\n\n**Fragmentation $\\mathcal{F}_{2+2+2}$:**\nThis fragmentation consists of three fragments: $F_1=\\{1,2\\}$, $F_2=\\{3,4\\}$, and $F_3=\\{5,6\\}$. Here $M=3$. The FMO2 energy is:\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = \\sum_{I=1}^{3} E(F_I) + \\sum_{1\\le I < J \\le 3} \\left[ E(F_I \\cup F_J) - E(F_I) - E(F_J) \\right]\n$$\nThis expression can be rearranged to:\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = E(F_1 \\cup F_2) + E(F_1 \\cup F_3) + E(F_2 \\cup F_3) - E(F_1) - E(F_2) - E(F_3)\n$$\nBy symmetry of the benzene ring and the fragmentation pattern:\n- The fragments $F_1, F_2, F_3$ are equivalent (two adjacent atoms), so $E(F_1) = E(F_2) = E(F_3)$.\n- The fragment pairs $F_1 \\cup F_2 = \\{1,2,3,4\\}$ and $F_2 \\cup F_3 = \\{3,4,5,6\\}$ are equivalent (linear chain of four atoms), so $E(F_1 \\cup F_2) = E(F_2 \\cup F_3)$.\n- The fragment pair $F_1 \\cup F_3 = \\{1,2,5,6\\}$ is different, as atoms $1$ and $6$ are bonded, forming a non-linear structure.\n\nThe simplified formula for the FMO2 energy is:\n$$\nE_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = 2E(F_1 \\cup F_2) + E(F_1 \\cup F_3) - 3E(F_1)\n$$\nTo find the error $\\Delta E_{\\mathcal{F}_{2+2+2}}$, we must compute the energies for four subsystems:\n1.  $S_1 = \\{1,2,3,4,5,6\\}$ to get $E_{\\mathrm{exact}}$.\n2.  $S_2 = F_1 = \\{1,2\\}$ to get $E(F_1)$.\n3.  $S_3 = F_1 \\cup F_2 = \\{1,2,3,4\\}$ to get $E(F_1 \\cup F_2)$.\n4.  $S_4 = F_1 \\cup F_3 = \\{1,2,5,6\\}$ to get $E(F_1 \\cup F_3)$.\n\nFor each test case $(\\alpha, \\beta)$, we will numerically construct the Hamiltonian matrix for each of these subsystems, compute their eigenvalues, determine the total electronic energy by filling orbitals, and finally calculate the error $\\Delta E_{\\mathcal{F}_{2+2+2}}$.\n\nThe algorithm is as follows:\n1.  For each pair $(\\alpha, \\beta)$ from the test suite:\n2.  Define the set of bonds in benzene: $\\{(1,2), (2,3), (3,4), (4,5), (5,6), (6,1)\\}$.\n3.  Calculate $E_{\\mathrm{exact}} = E(\\{1,2,3,4,5,6\\})$.\n4.  Calculate $E(F_1) = E(\\{1,2\\})$.\n5.  Calculate $E(F_1 \\cup F_2) = E(\\{1,2,3,4\\})$.\n6.  Calculate $E(F_1 \\cup F_3) = E(\\{1,2,5,6\\})$.\n7.  Compute $E_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) = 2E(F_1 \\cup F_2) + E(F_1 \\cup F_3) - 3E(F_1)$.\n8.  Compute the error $\\Delta E_{\\mathcal{F}_{2+2+2}} = E_{\\mathrm{FMO2}}(\\mathcal{F}_{2+2+2}) - E_{\\mathrm{exact}}$.\n9.  The error $\\Delta E_{\\mathcal{F}_{3+3}}$ is $0.0$.\n10. Store the pair of errors, rounded to six decimal places.\n11. After processing all test cases, format the collected results into the specified output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_huckel_energy(atoms, alpha, beta):\n    \"\"\"\n    Calculates the Hückel molecular orbital energy for a given subsystem of benzene.\n\n    Args:\n        atoms (tuple): A tuple of 1-based atom indices in the subsystem.\n        alpha (float): The Coulomb parameter (on-site energy).\n        beta (float): The resonance integral (hopping parameter).\n\n    Returns:\n        float: The total electronic energy of the subsystem.\n    \"\"\"\n    n = len(atoms)\n    if n == 0:\n        return 0.0\n\n    # Define benzene bonds (1-based indexing)\n    bonds = {frozenset({1, 2}), frozenset({2, 3}), frozenset({3, 4}), \n             frozenset({4, 5}), frozenset({5, 6}), frozenset({6, 1})}\n\n    # Map 1-based atom indices to 0-based matrix indices\n    atom_map = {atom_idx: i for i, atom_idx in enumerate(atoms)}\n\n    # Build the Hückel Hamiltonian matrix\n    H = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i, n):\n            atom1 = atoms[i]\n            atom2 = atoms[j]\n            if i == j:\n                H[i, j] = alpha\n            elif frozenset({atom1, atom2}) in bonds:\n                H[i, j] = H[j, i] = beta\n\n    # Calculate eigenvalues (molecular orbital energies)\n    # np.linalg.eigh returns sorted eigenvalues for Hermitian matrices\n    eigenvalues = np.linalg.eigh(H)[0]\n\n    # Fill orbitals with electrons (N_electrons = N_atoms)\n    num_electrons = n\n    num_pairs = num_electrons // 2\n    num_unpaired = num_electrons % 2\n    \n    total_energy = 0.0\n    # Add energy from doubly-occupied orbitals\n    total_energy += 2.0 * np.sum(eigenvalues[:num_pairs])\n    # Add energy from singly-occupied orbitals (if any)\n    if num_unpaired > 0:\n        total_energy += eigenvalues[num_pairs]\n\n    return total_energy\n\ndef solve():\n    \"\"\"\n    Solves the FMO problem for the given test cases.\n    \"\"\"\n    # Test suite: (alpha, beta) pairs in eV\n    test_cases = [\n        (0.0, -2.5),  # Case A\n        (1.0, 0.0),   # Case B\n        (0.5, 2.0),   # Case C\n    ]\n\n    all_results = []\n\n    # Define atom sets for required subsystems\n    all_atoms = tuple(range(1, 7))\n    F1_atoms = (1, 2)\n    F1F2_atoms = (1, 2, 3, 4)\n    F1F3_atoms = (1, 2, 5, 6)\n    \n    for alpha, beta in test_cases:\n        # 1. Calculate the exact energy of the full system\n        e_exact = calculate_huckel_energy(all_atoms, alpha, beta)\n\n        # 2. Calculate error for fragmentation F_2+2+2\n        # F_2+2+2 = {F1, F2, F3} where F1={1,2}, F2={3,4}, F3={5,6}\n        # E_fmo2 = E(F1 U F2) + E(F1 U F3) + E(F2 U F3) - E(F1) - E(F2) - E(F3)\n        # By symmetry: E(F1)=E(F2)=E(F3), E(F1 U F2) = E(F2 U F3)\n        # E_fmo2 = 2*E(F1 U F2) + E(F1 U F3) - 3*E(F1)\n        \n        e_f1 = calculate_huckel_energy(F1_atoms, alpha, beta)\n        e_f1f2 = calculate_huckel_energy(F1F2_atoms, alpha, beta)\n        e_f1f3 = calculate_huckel_energy(F1F3_atoms, alpha, beta)\n        \n        e_fmo2_222 = 2 * e_f1f2 + e_f1f3 - 3 * e_f1\n        delta_e_222 = e_fmo2_222 - e_exact\n\n        # 3. Calculate error for fragmentation F_3+3\n        # F_3+3 = {G1, G2} where G1={1,2,3}, G2={4,5,6}\n        # For M=2 fragments, E_fmo2 = E(G1 U G2) = E_exact.\n        # Thus, the error is always zero.\n        delta_e_333 = 0.0\n\n        all_results.append([delta_e_222, delta_e_333])\n\n    # Format the final output string exactly as specified.\n    inner_parts = [f\"[{res[0]:.6f},{res[1]:.6f}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_parts)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2464440"}]}