{"hands_on_practices": [{"introduction": "This first practice grounds our understanding in a classic theoretical problem: deriving the rotational heat capacity of a diatomic molecule. It demonstrates the direct and powerful link between the microscopic world of quantum energy levels and the macroscopic, measurable world of thermodynamics. By working through the low-temperature limit, you will see firsthand how quantum features—specifically, the discrete energy spacing and degeneracy of rotational states—govern the behavior of the heat capacity, a key thermodynamic property [@problem_id:2463582].", "problem": "A homonuclear diatomic molecule can be modeled as a linear rigid quantum rotor with moment of inertia $I$. Its rotational energy levels are $E_{J} = \\dfrac{\\hbar^{2}}{2 I} J(J+1)$ with state degeneracy $g_{J} = 2J + 1$ for $J = 0, 1, 2, \\dots$, where $\\hbar$ is the reduced Planck constant. Define the rotational temperature $\\Theta_{\\mathrm{r}} = \\dfrac{\\hbar^{2}}{2 I k_{B}}$, where $k_{B}$ is the Boltzmann constant.\n\nUsing only the canonical definition of the partition function and the Boltzmann distribution, determine the leading low-temperature asymptotic expression of the constant-volume rotational heat capacity per molecule, $C_{V,\\mathrm{rot}}(T)$, in the limit $T \\ll \\Theta_{\\mathrm{r}}$. Your expression must make explicit how the degeneracy of the first excited level enters. Then specialize your result to the actual linear rotor for which the first excited level ($J=1$) has degeneracy $g_{1} = 3$ and the ground state has degeneracy $g_{0} = 1$.\n\nExpress your final answer per molecule with an explicit factor of $k_{B}$, as a closed-form function of $T$ and $\\Theta_{\\mathrm{r}}$. No numerical rounding is required.", "solution": "The problem requires the derivation of the low-temperature asymptotic expression for the constant-volume rotational heat capacity, $C_{V,\\mathrm{rot}}(T)$, of a homonuclear diatomic molecule modeled as a rigid rotor.\n\nFirst, we validate the problem statement.\nThe givens are:\n- A model for a homonuclear diatomic molecule: a linear rigid quantum rotor.\n- Moment of inertia: $I$.\n- Rotational energy levels: $E_{J} = \\dfrac{\\hbar^{2}}{2 I} J(J+1)$ for $J = 0, 1, 2, \\dots$.\n- State degeneracy: $g_{J} = 2J + 1$.\n- Rotational temperature definition: $\\Theta_{\\mathrm{r}} = \\dfrac{\\hbar^{2}}{2 I k_{B}}$.\n- Limit condition: $T \\ll \\Theta_{\\mathrm{r}}$.\n- Specific degeneracies for specialization: $g_{0} = 1$, $g_{1} = 3$.\n\nThe problem is scientifically grounded, using the standard rigid rotor model from quantum mechanics. It is well-posed, providing all necessary information to derive a unique result within the specified low-temperature limit. The language is objective and precise. Therefore, the problem is valid and we may proceed with the solution.\n\nThe fundamental starting point is the canonical partition function for the rotational degrees of freedom, $q_{\\mathrm{rot}}$. This is defined as the sum over all quantum states, weighted by the Boltzmann factor:\n$$q_{\\mathrm{rot}} = \\sum_{J=0}^{\\infty} g_{J} \\exp\\left(-\\frac{E_{J}}{k_{B} T}\\right)$$\nUsing the provided definitions, we can express the energy levels in terms of the rotational temperature, $\\Theta_{\\mathrm{r}}$:\n$$E_{J} = \\frac{\\hbar^{2}}{2I} J(J+1) = \\left(\\frac{\\hbar^{2}}{2Ik_{B}}\\right) k_{B} J(J+1) = k_{B} \\Theta_{\\mathrm{r}} J(J+1)$$\nSubstituting this and the degeneracy $g_{J} = 2J+1$ into the partition function yields:\n$$q_{\\mathrm{rot}} = \\sum_{J=0}^{\\infty} (2J+1) \\exp\\left(-\\frac{\\Theta_{\\mathrm{r}}}{T} J(J+1)\\right)$$\nThe problem specifies the low-temperature limit, $T \\ll \\Theta_{\\mathrm{r}}$. In this regime, the ratio $\\frac{\\Theta_{\\mathrm{r}}}{T} \\gg 1$. As a consequence, the exponential terms in the sum decrease extremely rapidly with increasing $J$. The sum is therefore dominated by the first few terms. We can obtain the leading asymptotic behavior by truncating the series, keeping only the ground state ($J=0$) and the first excited state ($J=1$).\n\nFor $J=0$: $E_{0} = 0$, and the problem states the degeneracy is $g_{0}$. The term is $g_{0} \\exp(0) = g_{0}$.\nFor $J=1$: $E_{1} = k_{B} \\Theta_{\\mathrm{r}} (1)(1+1) = 2k_{B} \\Theta_{\\mathrm{r}}$, and the degeneracy is $g_{1}$. The term is $g_{1} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$.\n\nThe contribution from $J=2$ involves $\\exp\\left(-\\frac{6\\Theta_{\\mathrm{r}}}{T}\\right)$, which is negligible compared to the $J=1$ term. Thus, the low-temperature approximation for the partition function is:\n$$q_{\\mathrm{rot}}(T) \\approx g_{0} + g_{1} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$$\nThe average rotational energy per molecule, $U_{\\mathrm{rot}}$, is related to the partition function by:\n$$U_{\\mathrm{rot}} = k_{B} T^{2} \\frac{\\partial \\ln q_{\\mathrm{rot}}}{\\partial T}$$\nTo find the leading term for $U_{\\mathrm{rot}}$, we first evaluate $\\ln q_{\\mathrm{rot}}$. Let $x = g_{1} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$. Since $T \\ll \\Theta_{\\mathrm{r}}$, $x$ is a very small quantity.\n$$\\ln q_{\\mathrm{rot}} \\approx \\ln(g_{0} + x) = \\ln\\left(g_{0} \\left(1 + \\frac{x}{g_{0}}\\right)\\right) = \\ln(g_{0}) + \\ln\\left(1 + \\frac{x}{g_{0}}\\right)$$\nUsing the Taylor expansion $\\ln(1+y) \\approx y$ for small $y$, we get:\n$$\\ln q_{\\mathrm{rot}} \\approx \\ln(g_{0}) + \\frac{x}{g_{0}} = \\ln(g_{0}) + \\frac{g_{1}}{g_{0}} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$$\nNow we differentiate with respect to temperature $T$:\n$$\\frac{\\partial \\ln q_{\\mathrm{rot}}}{\\partial T} \\approx \\frac{\\partial}{\\partial T} \\left[ \\ln(g_{0}) + \\frac{g_{1}}{g_{0}} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right) \\right] = \\frac{g_{1}}{g_{0}} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right) \\left(\\frac{2 \\Theta_{\\mathrm{r}}}{T^{2}}\\right)$$\nThe average rotational energy is then:\n$$U_{\\mathrm{rot}} \\approx k_{B} T^{2} \\left[ \\frac{g_{1}}{g_{0}} \\frac{2 \\Theta_{\\mathrm{r}}}{T^{2}} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right) \\right] = \\frac{g_{1}}{g_{0}} (2 k_{B} \\Theta_{\\mathrm{r}}) \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$$\nThe constant-volume rotational heat capacity per molecule is the derivative of the average energy with respect to temperature:\n$$C_{V,\\mathrm{rot}}(T) = \\left(\\frac{\\partial U_{\\mathrm{rot}}}{\\partial T}\\right)_{V}$$\nDifferentiating the expression for $U_{\\mathrm{rot}}$:\n$$C_{V,\\mathrm{rot}}(T) \\approx \\frac{\\partial}{\\partial T} \\left[ \\frac{g_{1}}{g_{0}} (2 k_{B} \\Theta_{\\mathrm{r}}) \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right) \\right] = \\frac{g_{1}}{g_{0}} (2 k_{B} \\Theta_{\\mathrm{r}}) \\frac{\\partial}{\\partial T} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$$\n$$C_{V,\\mathrm{rot}}(T) \\approx \\frac{g_{1}}{g_{0}} (2 k_{B} \\Theta_{\\mathrm{r}}) \\left[ \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right) \\left(\\frac{2 \\Theta_{\\mathrm{r}}}{T^{2}}\\right) \\right]$$\n$$C_{V,\\mathrm{rot}}(T) \\approx k_{B} \\frac{g_{1}}{g_{0}} \\left(\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)^{2} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$$\nThis expression fulfills the requirement to make explicit the dependence on the degeneracies of the ground ($g_{0}$) and first excited ($g_{1}$) levels.\n\nFinally, we specialize this result for the given linear rotor, where the ground state has degeneracy $g_{0}=1$ and the first excited state has degeneracy $g_{1}=3$. These values correspond to the general formula $g_{J} = 2J+1$ for $J=0$ and $J=1$.\nSubstituting these values into our expression for $C_{V,\\mathrm{rot}}(T)$:\n$$C_{V,\\mathrm{rot}}(T) = k_{B} \\frac{3}{1} \\left(\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)^{2} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$$\n$$C_{V,\\mathrm{rot}}(T) = 3 k_{B} \\left(\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)^{2} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)$$\nThis is the final expression for the leading low-temperature asymptotic behavior of the rotational heat capacity per molecule.", "answer": "$$\\boxed{3 k_{B} \\left(\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)^{2} \\exp\\left(-\\frac{2 \\Theta_{\\mathrm{r}}}{T}\\right)}$$", "id": "2463582"}, {"introduction": "Having established the theoretical role of the partition function, our next practice bridges the gap between the quantum and classical descriptions of a system. You will computationally explore the correspondence principle for a simple but fundamental model: a particle in a one-dimensional box. This exercise involves writing a program to calculate the partition function from two different perspectives—as a sum over discrete quantum states and as a continuous integral over classical phase space—to see how the quantum description converges to the classical one in the high-temperature limit [@problem_id:2463653].", "problem": "Consider a single non-interacting quantum particle confined to a one-dimensional (1D) infinite potential well of length $L$ with perfectly rigid walls. In the canonical ensemble at temperature $T$, the microscopic states have energies labeled by a positive integer $n$. Your task is to connect the microscopic energy spectrum to macroscopic thermodynamic behavior by computing the canonical partition function and comparing the exact quantum result to its classical (high-temperature) limit.\n\nRequirements and foundational base:\n- Use the Boltzmann distribution in the canonical ensemble, where the canonical partition function is defined as $Z = \\sum_{i} e^{-\\beta E_{i}}$ with $\\beta = 1/(k_{\\mathrm{B}} T)$, and $k_{\\mathrm{B}}$ is the Boltzmann constant.\n- For a particle in a one-dimensional infinite potential well of length $L$, the energy eigenvalues are a well-tested result: $E_{n} = \\dfrac{n^{2} h^{2}}{8 m L^{2}}$ for $n = 1, 2, 3, \\dots$, where $h$ is Planck’s constant and $m$ is the particle mass.\n- Derive the classical counterpart of the partition function from first principles by starting from the phase-space integral over position and momentum with the standard quantum of phase-space cell volume $h$, i.e., $$Z_{\\mathrm{cl}} = \\dfrac{1}{h} \\int_{0}^{L} \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p \\, \\mathrm{d}x.$$ Do not approximate the quantum spectrum when setting up this integral; only apply continuum methods appropriate for the classical limit.\n\nAlgorithmic tasks your program must perform:\n1. Implement a numerically stable computation of the quantum partition function\n   $$Z_{\\mathrm{q}}(m,L,T) = \\sum_{n=1}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{n^{2} h^{2}}{8 m L^{2}}\\right).$$\n   Use an adaptive truncation of the infinite sum by adding terms until the next term is smaller than a prescribed tolerance. Ensure your truncation logic is justified by monotonic decay of the positive summands and that it prevents unnecessary computation for small or large $T$.\n2. From the classical phase-space integral stated above, carry out the derivation symbolically to obtain a closed-form expression for the classical partition function $Z_{\\mathrm{cl}}(m,L,T)$ that your program will evaluate numerically. Use the International System of Units (SI) consistently: $m$ in $\\mathrm{kg}$, $L$ in $\\mathrm{m}$, $T$ in $\\mathrm{K}$, $h$ in $\\mathrm{J\\,s}$, and $k_{\\mathrm{B}}$ in $\\mathrm{J/K}$. The partition functions are dimensionless.\n3. For each test case, compute the relative deviation\n   $$\\delta = \\dfrac{Z_{\\mathrm{q}} - Z_{\\mathrm{cl}}}{Z_{\\mathrm{cl}}}.$$\n   Report $\\delta$ as a floating-point number rounded to $6$ decimal places.\n\nConstants:\n- Use $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$ and $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J\\,s}$.\n\nTest suite (use exactly these values):\n- Case $1$ (happy path, moderate quantization): $m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-9}\\ \\mathrm{m}$, $T = 300\\ \\mathrm{K}$.\n- Case $2$ (high-temperature classical limit): $m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-9}\\ \\mathrm{m}$, $T = 1.0\\times 10^{7}\\ \\mathrm{K}$.\n- Case $3$ (heavier particle, closer to classical at ambient conditions): $m = 6.6335209\\times 10^{-26}\\ \\mathrm{kg}$, $L = 1.0\\times 10^{-9}\\ \\mathrm{m}$, $T = 300\\ \\mathrm{K}$.\n- Case $4$ (smaller box, stronger quantization at elevated temperature): $m = 9.1093837015\\times 10^{-31}\\ \\mathrm{kg}$, $L = 2.0\\times 10^{-10}\\ \\mathrm{m}$, $T = 1000\\ \\mathrm{K}$.\n\nAdditional numerical requirements:\n- Implement an absolute tolerance for truncating the quantum sum; take the summation cutoff so that the first neglected term is strictly less than $10^{-12}$.\n- Guard against numerical underflow by recognizing that terms with exponent less than $-700$ in the natural exponential are effectively zero in double precision.\n- All computations must be performed in SI units as stated above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each entry being the value of $\\delta$ for the corresponding test case, rounded to $6$ decimal places. For example, the format must be $[x_{1},x_{2},x_{3},x_{4}]$ with each $x_{i}$ a decimal number with $6$ digits after the decimal point.", "solution": "We begin from the canonical ensemble within statistical mechanics, which is foundational in computational chemistry for connecting microscopic energy levels to macroscopic thermodynamic properties. The Boltzmann distribution assigns probability $p_{i} = e^{-\\beta E_{i}}/Z$ to microstate $i$, with the canonical partition function defined by\n$$\nZ = \\sum_{i} e^{-\\beta E_{i}}, \\quad \\beta = \\dfrac{1}{k_{\\mathrm{B}} T}.\n$$\nThe partition function is dimensionless and provides the central link to macroscopic quantities such as the Helmholtz free energy $A = -k_{\\mathrm{B}} T \\ln Z$.\n\nMicroscopic model: a one-dimensional (1D) infinite potential well of length $L$ with perfectly rigid walls has stationary energy eigenvalues\n$$\nE_{n} = \\dfrac{n^{2} h^{2}}{8 m L^{2}}, \\quad n = 1, 2, 3, \\dots,\n$$\na standard result from solving the time-independent Schrödinger equation with Dirichlet boundary conditions. The quantum canonical partition function is therefore\n$$\nZ_{\\mathrm{q}}(m,L,T) = \\sum_{n=1}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{n^{2} h^{2}}{8 m L^{2}}\\right).\n$$\nDefine $a = \\beta h^{2}/(8 m L^{2})$. The summand is $e^{-a n^{2}}$, which is strictly positive and strictly decreasing in $n$ for $a > 0$. This monotonicity justifies truncating the infinite sum when the first neglected term is below a specified tolerance $\\varepsilon$, because the tail sum is then bounded by an integral test:\n$$\n\\sum_{n=N+1}^{\\infty} e^{-a n^{2}} \\le \\int_{N}^{\\infty} e^{-a x^{2}} \\, \\mathrm{d}x = \\dfrac{1}{2}\\sqrt{\\dfrac{\\pi}{a}}\\, \\mathrm{erfc}\\!\\big(\\sqrt{a}\\, N\\big),\n$$\nso choosing $N$ such that $e^{-a N^{2}}  \\varepsilon$ ensures a small tail. An efficient practical cutoff is\n$$\nN = \\left\\lceil \\sqrt{\\dfrac{\\ln(1/\\varepsilon)}{a}} \\right\\rceil,\n$$\nwhich guarantees $e^{-a N^{2}} \\le \\varepsilon$. In floating point arithmetic, terms with exponent less than $-700$ are effectively zero in double precision, so we also treat those as vanishing.\n\nClassical limit: In the high-temperature limit, the discrete quantum levels become densely populated and the classical partition function emerges from the phase-space integral with the Liouville measure and the quantum of phase-space cell volume $h$:\n$$\nZ_{\\mathrm{cl}} = \\dfrac{1}{h} \\int_{0}^{L} \\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p \\, \\mathrm{d}x.\n$$\nThe position integral yields $\\int_{0}^{L} \\mathrm{d}x = L$. The momentum integral is a standard Gaussian integral:\n$$\n\\int_{-\\infty}^{\\infty} \\exp\\!\\left(-\\beta \\dfrac{p^{2}}{2m}\\right) \\, \\mathrm{d}p = \\sqrt{\\dfrac{2 \\pi m}{\\beta}} = \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n$$\nTherefore the classical translational partition function in one dimension is\n$$\nZ_{\\mathrm{cl}}(m,L,T) = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n$$\nThis result is valid in the regime where quantum level spacing is negligible compared to $k_{\\mathrm{B}} T$. The microscopic-to-macroscopic connection is explicit: $Z_{\\mathrm{q}}$ is a sum over microscopic energy levels, while $Z_{\\mathrm{cl}}$ is a continuum phase-space measure that approximates the sum when $T$ is large or when $m$ and $L$ make the level spacing small.\n\nAsymptotic consistency: The sum $\\sum_{n=1}^{\\infty} e^{-a n^{2}}$ is related to the Jacobi theta function. Using the Poisson summation formula or the modular property of the theta function, one finds the high-temperature (small $a$) asymptotic expansion\n$$\n\\sum_{n=1}^{\\infty} e^{-a n^{2}} = \\dfrac{1}{2} \\sqrt{\\dfrac{\\pi}{a}} - \\dfrac{1}{2} + \\mathcal{O}\\!\\left(e^{-\\pi^{2}/a}\\right).\n$$\nWith $a = \\beta h^{2}/(8 m L^{2})$, the leading term gives\n$$\n\\sum_{n=1}^{\\infty} e^{-a n^{2}} \\sim \\dfrac{1}{2} \\sqrt{\\dfrac{\\pi}{a}} = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T} = Z_{\\mathrm{cl}}(m,L,T),\n$$\nso $Z_{\\mathrm{q}} \\to Z_{\\mathrm{cl}}$ as $T \\to \\infty$, validating the microscopic-to-macroscopic transition.\n\nNumerical algorithm design:\n- Inputs per case: $(m, L, T)$ in SI units. Constants: $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\ \\mathrm{J/K}$, $h = 6.62607015\\times 10^{-34}\\ \\mathrm{J\\,s}$.\n- Compute $\\beta = 1/(k_{\\mathrm{B}} T)$ and $a = \\beta h^{2}/(8 m L^{2})$.\n- Choose tolerance $\\varepsilon = 10^{-12}$. Set\n  $$\n  N = \\max\\!\\left(1,\\ \\left\\lceil \\sqrt{\\dfrac{\\ln(1/\\varepsilon)}{a}} \\right\\rceil \\right),\n  $$\n  which ensures the first neglected term is below tolerance. Optionally cap $N$ if needed; for the provided test suite, $N$ remains modest (on the order of hundreds).\n- Compute\n  $$\n  Z_{\\mathrm{q}} = \\sum_{n=1}^{N} e^{-a n^{2}},\n  $$\n  skipping terms with exponent below $-700$ to avoid underflow.\n- Compute\n  $$\n  Z_{\\mathrm{cl}} = \\dfrac{L}{h} \\sqrt{2 \\pi m k_{\\mathrm{B}} T}.\n  $$\n- Compute the relative deviation\n  $$\n  \\delta = \\dfrac{Z_{\\mathrm{q}} - Z_{\\mathrm{cl}}}{Z_{\\mathrm{cl}}}.\n  $$\n- Round $\\delta$ to $6$ decimal places.\n- Repeat for the four test cases given.\n\nTest suite rationale:\n- Case $1$ tests a moderately quantum regime at ambient temperature for an electron in a nanometer box.\n- Case $2$ probes the high-temperature limit to confirm $Z_{\\mathrm{q}} \\approx Z_{\\mathrm{cl}}$.\n- Case $3$ uses a heavier particle (argon atom) where classical behavior emerges more readily at the same $L$ and $T$.\n- Case $4$ employs a smaller box and elevated temperature to test strong quantization and numerical stability of the summation.\n\nThe final program will compute and print a single line in the format $[\\delta_{1},\\delta_{2},\\delta_{3},\\delta_{4}]$, each rounded to $6$ decimals, where each $\\delta_{i}$ is the relative deviation for the $i$th test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Physical constants (SI)\nk_B = 1.380649e-23      # Boltzmann constant in J/K\nh = 6.62607015e-34      # Planck constant in J*s\n\ndef quantum_partition_1d_box(m, L, T, tol=1e-12):\n    \"\"\"\n    Compute the quantum canonical partition function for a particle in a 1D infinite well:\n        Z_q = sum_{n=1}^\\infty exp(-beta * n^2 * h^2 / (8 m L^2))\n    using an adaptive truncation where the first neglected term is  tol.\n\n    Parameters:\n        m : mass in kg\n        L : length in m\n        T : temperature in K\n        tol : absolute tolerance for truncation\n\n    Returns:\n        Z_q : float\n    \"\"\"\n    if T = 0.0:\n        # Physically undefined; here return 0 to avoid division by zero in beta\n        return 0.0\n\n    beta = 1.0 / (k_B * T)\n    a = beta * h * h / (8.0 * m * L * L)\n\n    if a = 0.0:\n        # Degenerate case; treat as zero spacing - diverging sum; not expected in test suite\n        return np.inf\n\n    # Determine cutoff N such that exp(-a * N^2)  tol\n    # If ln(1/tol)/a is very small, ensure N at least 1\n    target = np.log(1.0 / tol) / a\n    if target = 1.0:\n        N = 1\n    else:\n        N = int(np.ceil(np.sqrt(target)))\n\n    # Safety cap to prevent accidental huge loops (not expected to trigger for given cases)\n    N = min(N, 2_000_000)\n\n    # Sum terms, skipping those that underflow in double precision (exp(-x) ~ 0 for x  ~ 700)\n    Z_q = 0.0\n    # For efficiency, sum in blocks using vectorization when N is moderate\n    # But also handle underflow to avoid unnecessary exponent evaluations\n    n_values = np.arange(1, N + 1, dtype=np.float64)\n    exponents = -a * n_values * n_values\n    # Mask out underflow-prone terms\n    mask = exponents  -700.0\n    if np.any(mask):\n        Z_q = float(np.exp(exponents[mask]).sum())\n    else:\n        Z_q = 0.0\n\n    return Z_q\n\ndef classical_partition_1d(m, L, T):\n    \"\"\"\n    Classical 1D translational partition function:\n        Z_cl = (L/h) * sqrt(2 * pi * m * k_B * T)\n    \"\"\"\n    if T = 0.0:\n        return 0.0\n    return (L / h) * np.sqrt(2.0 * np.pi * m * k_B * T)\n\ndef relative_deviation(m, L, T, tol=1e-12):\n    Z_q = quantum_partition_1d_box(m, L, T, tol=tol)\n    Z_cl = classical_partition_1d(m, L, T)\n    if Z_cl == 0.0:\n        # Avoid division by zero; define deviation as 0 if both zero else +/-inf\n        if Z_q == 0.0:\n            return 0.0\n        else:\n            return float('inf') if Z_q  0.0 else float('-inf')\n    return (Z_q - Z_cl) / Z_cl\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m [kg], L [m], T [K])\n    test_cases = [\n        (9.1093837015e-31, 1.0e-9, 300.0),        # Case 1\n        (9.1093837015e-31, 1.0e-9, 1.0e7),        # Case 2\n        (6.6335209e-26,   1.0e-9, 300.0),         # Case 3\n        (9.1093837015e-31, 2.0e-10, 1000.0),      # Case 4\n    ]\n\n    results = []\n    for m, L, T in test_cases:\n        delta = relative_deviation(m, L, T, tol=1e-12)\n        # Round to 6 decimal places as required\n        if np.isfinite(delta):\n            results.append(f\"{delta:.6f}\")\n        else:\n            # Represent infinities explicitly if they occur (not expected here)\n            results.append(\"inf\" if delta  0 else \"-inf\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2463653"}, {"introduction": "Our final practice takes you into the heart of modern molecular simulation: generating a trajectory that correctly samples the canonical ensemble. Here, you will implement a Nosé-Hoover thermostat, a clever deterministic algorithm designed to maintain a constant average temperature in a simulation. By integrating the equations of motion and analyzing the resulting positions and velocities, you will validate that the thermostat successfully produces configurations consistent with the Boltzmann distribution, providing a deep, practical understanding of how computational chemistry connects dynamics to statistical mechanics [@problem_id:2463631].", "problem": "You are asked to write a complete program that simulates a one-dimensional harmonic oscillator coupled to a single-variable Nosé–Hoover thermostat and demonstrates that the generated configurations are consistent with the canonical ensemble at temperature $T$ in reduced units. All quantities are in reduced units with particle mass $m=1$ and Boltzmann constant $k_{\\mathrm{B}}=1$, so that temperature $T$ has the same units as energy. No physical units beyond these reduced units are required.\n\nThe system has coordinate $x$, velocity $v$, and thermostat friction variable $\\zeta$. The potential energy is $U(x) = \\tfrac{1}{2} k x^2$ with spring constant $k$. The equations of motion for a single Nosé–Hoover thermostat with thermostat mass parameter $Q$ in these reduced units are:\n- $\\dot{x} = v$,\n- $\\dot{v} = -k x - \\zeta v$,\n- $\\dot{\\zeta} = \\dfrac{v^2 - T}{Q}$.\n\nStarting from an out-of-equilibrium initial condition $x(0)=5$, $v(0)=0$, $\\zeta(0)=0$, you must integrate these equations numerically using a fixed time step $dt$ and a $4$th-order Runge–Kutta method. Discard the first $20\\%$ of steps as burn-in. From the remaining trajectory, sample every $10$th step to form arrays of sampled positions and velocities. Denote the sampled arrays by $\\{x_i\\}$ and $\\{v_i\\}$.\n\nYour program must, for each parameter set in the test suite below, compute the following diagnostics that connect microscopic sampling to macroscopic ensemble properties expected for a canonical distribution:\n- The sample variance of positions, $\\mathrm{Var}(x)$, and the sample variance of velocities, $\\mathrm{Var}(v)$. From the canonical ensemble for a harmonic oscillator in these reduced units, the theoretical variances implied by the Boltzmann distribution are $\\sigma_x^2 = T/k$ and $\\sigma_v^2 = T$. Define the relative errors $e_x = \\left|\\mathrm{Var}(x)-\\sigma_x^2\\right|/\\sigma_x^2$ and $e_v = \\left|\\mathrm{Var}(v)-\\sigma_v^2\\right|/\\sigma_v^2$.\n- The empirical Pearson correlation coefficient between $x$ and $v$, which should be close to $0$ under the canonical factorization of position and velocity.\n- A one-sample Kolmogorov–Smirnov statistic for positions: normalize positions by the theoretical standard deviation, $z_i = x_i/\\sqrt{T/k}$, and compute the Kolmogorov–Smirnov statistic\n$$\nD = \\max\\left\\{\\max_{1\\le i\\le n}\\left(\\frac{i}{n} - \\Phi(z_{(i)})\\right),\\ \\max_{1\\le i\\le n}\\left(\\Phi(z_{(i)}) - \\frac{i-1}{n}\\right)\\right\\},\n$$\nwhere $z_{(i)}$ are the sorted normalized positions and $\\Phi$ is the cumulative distribution function of the standard normal distribution. This tests consistency of the sampled $x$-marginal with the Gaussian predicted by the canonical ensemble.\n\nFor each parameter set, return a boolean indicating whether all three conditions hold simultaneously:\n- $e_x  0.15$ and $e_v  0.15$,\n- $|{\\rm Corr}(x,v)|  0.10$,\n- $D  0.12$.\n\nImplement the $4$th-order Runge–Kutta method explicitly and do not use any stochastic thermostat or velocity-rescaling; only the deterministic Nosé–Hoover equations above.\n\nTest Suite:\nProvide results for the following parameter sets $(T, k, Q, dt, \\text{steps})$:\n- Case $1$: $(1.0, 1.0, 1.0, 0.005, 60000)$,\n- Case $2$: $(0.5, 2.0, 1.0, 0.005, 60000)$,\n- Case $3$: $(1.5, 0.7, 1.0, 0.004, 60000)$.\n\nNumerical details and conventions to follow:\n- Use initial conditions $x(0)=5$, $v(0)=0$, $\\zeta(0)=0$ for all cases.\n- Burn-in fraction is $0.20$ of the total number of steps; sample every $10$th step thereafter.\n- Compute sample means and variances using the unbiased definitions based on the data arrays after burn-in and downsampling.\n- Angles are not used in this problem.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and with no spaces, in the order of the test suite cases. For example, if all three cases pass, the output must be exactly\n[True,True,True]\nwith the appropriate boolean values for your results.", "solution": "The problem requires the validation of a Nosé–Hoover thermostat as a method for generating configurations consistent with the canonical ensemble for a one-dimensional harmonic oscillator. This is a fundamental exercise in computational statistical mechanics. The procedure involves numerically integrating the equations of motion for an extended system and then calculating specific statistical diagnostics from the resulting trajectory to compare against theoretical predictions from the Boltzmann distribution.\n\nThe state of the extended system is described by the vector $\\mathbf{y}(t) = [x(t), v(t), \\zeta(t)]^T$, where $x$ is the position, $v$ is the velocity, and $\\zeta$ is the thermostat's friction parameter. The dynamics are governed by a system of first-order ordinary differential equations (ODEs). In the specified reduced units ($m=1$, $k_{\\mathrm{B}}=1$), these equations are:\n$$\n\\begin{cases}\n\\dot{x} = v \\\\\n\\dot{v} = -k x - \\zeta v \\\\\n\\dot{\\zeta} = \\dfrac{v^2 - T}{Q}\n\\end{cases}\n$$\nHere, $k$ is the spring constant of the harmonic potential $U(x) = \\frac{1}{2} k x^2$, $T$ is the target temperature, and $Q$ is the thermostat mass parameter, which controls the timescale of the thermostat's response.\n\nTo solve this system numerically, we employ the $4$th-order Runge–Kutta (RK4) method, a robust and widely-used numerical integrator. For a generic ODE system $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y}, t)$, the update from a state $\\mathbf{y}_n$ at time $t_n$ to $\\mathbf{y}_{n+1}$ at time $t_{n+1} = t_n + dt$ is given by:\n$$\n\\begin{align*}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n, t_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{dt}{2} \\mathbf{k}_1, t_n + \\frac{dt}{2}) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{dt}{2} \\mathbf{k}_2, t_n + \\frac{dt}{2}) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + dt \\mathbf{k}_3, t_n + dt) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{dt}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{align*}\n$$\nIn our specific case, the function $\\mathbf{f}$ does not depend explicitly on time $t$. The simulation starts from a specified out-of-equilibrium state: $x(0)=5$, $v(0)=0$, $\\zeta(0)=0$.\n\nThe simulation is run for a total number of steps. The initial $20\\%$ of the trajectory constitutes the \"burn-in\" or equilibration phase, during which the system evolves from its initial state to the target canonical distribution. These initial steps are discarded. From the remaining $80\\%$ of the trajectory, we sample the state every $10$ steps to reduce serial correlation between data points, yielding sample sets $\\{x_i\\}$ and $\\{v_i\\}$.\n\nTo verify that the sampled data conform to the canonical ensemble at temperature $T$, we compute three diagnostics:\n\n1.  **Variances and the Equipartition Theorem**: For a classical system in thermal equilibrium, the equipartition theorem states that each quadratic degree of freedom in the Hamiltonian contributes $\\frac{1}{2}k_{\\mathrm{B}}T$ to the average internal energy. For our harmonic oscillator, the kinetic energy is $\\frac{1}{2}mv^2$ and the potential energy is $\\frac{1}{2}kx^2$. In reduced units ($m=1, k_{\\mathrm{B}}=1$), this implies $\\langle \\frac{1}{2}v^2 \\rangle = \\frac{1}{2}T$ and $\\langle \\frac{1}{2}kx^2 \\rangle = \\frac{1}{2}T$. Since the mean position and velocity must be zero, $\\langle x \\rangle = 0$ and $\\langle v \\rangle = 0$, the theoretical variances are $\\sigma_x^2 = \\langle x^2 \\rangle = T/k$ and $\\sigma_v^2 = \\langle v^2 \\rangle = T$. We compute the unbiased sample variances, $\\mathrm{Var}(x)$ and $\\mathrm{Var}(v)$, and their relative errors, $e_x = |\\mathrm{Var}(x) - \\sigma_x^2| / \\sigma_x^2$ and $e_v = |\\mathrm{Var}(v) - \\sigma_v^2| / \\sigma_v^2$. Successful thermalization requires these errors to be small.\n\n2.  **Position-Velocity Correlation**: The canonical probability density function for a Hamiltonian of the form $H(x,v) = U(x) + K(v)$ is $p(x,v) \\propto e^{-\\beta U(x)} e^{-\\beta K(v)}$, where $\\beta = 1/(k_{\\mathrm{B}}T)$. The distribution function factorizes, implying that position and velocity are statistically independent variables. Consequently, their theoretical correlation coefficient is zero. We compute the empirical Pearson correlation coefficient $\\mathrm{Corr}(x,v)$ from the samples; its magnitude should be close to zero.\n\n3.  **Position Distribution**: The marginal probability distribution for the position $x$ is a Gaussian (normal) distribution with mean $0$ and variance $\\sigma_x^2 = T/k$. To test this hypothesis, we normalize the sampled positions to create a new variable $z_i = x_i / \\sigma_x$, which should follow a standard normal distribution, $\\mathcal{N}(0, 1)$. We use the Kolmogorov–Smirnov (KS) test to compare the empirical cumulative distribution function (CDF) of the $\\{z_i\\}$ data against the CDF of the standard normal distribution, $\\Phi(z)$. The KS statistic $D$ is the maximum absolute difference between these two CDFs. The specific computational formula provided is:\n    $$\n    D = \\max\\left\\{\\max_{1\\le i\\le n}\\left(\\frac{i}{n} - \\Phi(z_{(i)})\\right),\\ \\max_{1\\le i\\le n}\\left(\\Phi(z_{(i)}) - \\frac{i-1}{n}\\right)\\right\\}\n    $$\n    where $z_{(i)}$ are the sorted normalized positions and $n$ is the number of samples. A small value of $D$ indicates good agreement.\n\nThe program will iterate through the provided test cases. For each case, it will perform the simulation, sampling, and diagnostic calculations. A final boolean result is produced based on whether all three specified numerical thresholds are met simultaneously: $e_x, e_v  0.15$, $|\\mathrm{Corr}(x,v)|  0.10$, and $D  0.12$. The implementation will use `numpy` for numerical arrays and operations and `scipy.stats.norm.cdf` for the standard normal CDF, $\\Phi$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (T, k, Q, dt, steps)\n        (1.0, 1.0, 1.0, 0.005, 60000),\n        (0.5, 2.0, 1.0, 0.005, 60000),\n        (1.5, 0.7, 1.0, 0.004, 60000),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation_and_analyze(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef derivatives(state, k, T, Q):\n    \"\"\"\n    Computes the time derivatives for the Nosé–Hoover system.\n    state: numpy array [x, v, zeta]\n    k: spring constant\n    T: target temperature\n    Q: thermostat mass parameter\n    Returns: numpy array [dx/dt, dv/dt, dzeta/dt]\n    \"\"\"\n    x, v, zeta = state\n    dxdt = v\n    dvdt = -k * x - zeta * v\n    dzetadt = (v**2 - T) / Q\n    return np.array([dxdt, dvdt, dzetadt])\n\ndef rk4_step(state, dt, k, T, Q):\n    \"\"\"\n    Performs a single 4th-order Runge–Kutta step.\n    state: current state vector [x, v, zeta]\n    dt: time step\n    k, T, Q: system parameters\n    Returns: new state vector\n    \"\"\"\n    k1 = derivatives(state, k, T, Q)\n    k2 = derivatives(state + 0.5 * dt * k1, k, T, Q)\n    k3 = derivatives(state + 0.5 * dt * k2, k, T, Q)\n    k4 = derivatives(state + dt * k3, k, T, Q)\n    new_state = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n    return new_state\n\ndef run_simulation_and_analyze(params):\n    \"\"\"\n    Runs a full simulation for one parameter set and computes diagnostics.\n    params: tuple (T, k, Q, dt, steps)\n    Returns: boolean indicating if all conditions are met.\n    \"\"\"\n    T, k, Q, dt, total_steps = params\n    \n    # Initial conditions\n    x0, v0, z0 = 5.0, 0.0, 0.0\n    state = np.array([x0, v0, z0])\n    \n    # Store trajectory history\n    x_history = np.zeros(total_steps)\n    v_history = np.zeros(total_steps)\n    \n    # Simulation loop\n    for i in range(total_steps):\n        x_history[i] = state[0]\n        v_history[i] = state[1]\n        state = rk4_step(state, dt, k, T, Q)\n        \n    # Apply burn-in and sampling\n    burn_in_steps = int(0.20 * total_steps)\n    sample_stride = 10\n    \n    x_samples = x_history[burn_in_steps::sample_stride]\n    v_samples = v_history[burn_in_steps::sample_stride]\n    \n    # --- Diagnostic Calculations ---\n    \n    # 1. Sample Variances and Relative Errors\n    var_x = np.var(x_samples, ddof=1)  # Unbiased sample variance\n    var_v = np.var(v_samples, ddof=1)\n    \n    theory_var_x = T / k\n    theory_var_v = T\n    \n    e_x = np.abs(var_x - theory_var_x) / theory_var_x\n    e_v = np.abs(var_v - theory_var_v) / theory_var_v\n    \n    # 2. Pearson Correlation Coefficient\n    corr_xv = np.corrcoef(x_samples, v_samples)[0, 1]\n    \n    # 3. Kolmogorov–Smirnov Statistic\n    n_samples = len(x_samples)\n    sigma_x_theory = np.sqrt(theory_var_x)\n    z_scores = x_samples / sigma_x_theory\n    z_sorted = np.sort(z_scores)\n    \n    cdf_empirical_upper = np.arange(1, n_samples + 1) / n_samples\n    cdf_empirical_lower = np.arange(0, n_samples) / n_samples\n    cdf_theoretical = norm.cdf(z_sorted)\n    \n    d_plus = np.max(cdf_empirical_upper - cdf_theoretical)\n    d_minus = np.max(cdf_theoretical - cdf_empirical_lower)\n    D_ks = np.max([d_plus, d_minus])\n\n    # --- Validation Check ---\n    \n    cond1 = (e_x  0.15) and (e_v  0.15)\n    cond2 = np.abs(corr_xv)  0.10\n    cond3 = D_ks  0.12\n    \n    return cond1 and cond2 and cond3\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2463631"}]}