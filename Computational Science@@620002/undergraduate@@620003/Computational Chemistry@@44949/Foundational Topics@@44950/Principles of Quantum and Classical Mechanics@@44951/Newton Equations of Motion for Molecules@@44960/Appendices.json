{"hands_on_practices": [{"introduction": "The journey into molecular motion begins with the simplest case: a diatomic molecule. This foundational exercise [@problem_id:2686820] challenges you to derive the molecule's vibrational frequency directly from Newton's second law, modeling the chemical bond as a simple spring. By transforming the coupled motion of two masses into the motion of a single effective particle with a 'reduced mass' $\\mu$, you will uncover the principles of simple harmonic motion that govern molecular vibrations.", "problem": "A linear diatomic molecule is modeled as two point masses, $m_1$ and $m_2$, constrained to move along the internuclear axis and interacting via a harmonic potential around the equilibrium separation $r_e$. Assume the small-amplitude (harmonic) approximation, so that the restoring force is governed by Hooke’s law with force constant $k$. Starting only from Newton’s second law and Hooke’s law, write down the coupled equations of motion for the displacements of the two nuclei from equilibrium, eliminate the center-of-mass motion to obtain a single ordinary differential equation for the internal (bond-stretch) coordinate, and from that determine the vibrational angular frequency in terms of $m_1$, $m_2$, and $k$.\n\nExpress your final result as a single closed-form analytic expression for the angular frequency. Do not provide intermediate steps in the final answer. No units are required, and no rounding is necessary.", "solution": "The problem statement is a standard and well-posed exercise in classical mechanics applied to molecular vibrations. It is scientifically grounded, internally consistent, and contains all necessary information for its resolution. We will proceed with the derivation.\n\nLet the positions of the two point masses, $m_1$ and $m_2$, along the internuclear axis be denoted by $x_1(t)$ and $x_2(t)$, respectively. The equilibrium positions are $x_{1,e}$ and $x_{2,e}$. The equilibrium separation is a constant, $r_e = x_{2,e} - x_{1,e}$. We define the displacements of each mass from its respective equilibrium position as $\\delta_1(t) = x_1(t) - x_{1,e}$ and $\\delta_2(t) = x_2(t) - x_{2,e}$.\n\nThe instantaneous internuclear separation is $r(t) = x_2(t) - x_1(t)$. The internal coordinate, which represents the stretching of the bond from its equilibrium length, is defined as $q(t) = r(t) - r_e$. This can be expressed in terms of the individual displacements:\n$$q(t) = (x_2(t) - x_1(t)) - (x_{2,e} - x_{1,e}) = (x_2(t) - x_{2,e}) - (x_1(t) - x_{1,e}) = \\delta_2(t) - \\delta_1(t)$$\n\nThe restoring force is governed by Hooke's law, $F = -k'x'$, where $x'$ is the displacement from equilibrium. In our case, the displacement is the internal coordinate $q$. The potential energy of the system is $V = \\frac{1}{2} k q^2$. The force acting on each mass is found from the negative gradient of the potential energy.\nThe force on mass $m_1$ is:\n$$F_1 = -\\frac{\\partial V}{\\partial x_1} = -\\frac{\\partial}{\\partial x_1} \\left( \\frac{1}{2} k (x_2 - x_1 - r_e)^2 \\right) = -k(x_2 - x_1 - r_e) \\cdot (-1) = k(x_2 - x_1 - r_e) = k q$$\nThe force on mass $m_2$ is:\n$$F_2 = -\\frac{\\partial V}{\\partial x_2} = -\\frac{\\partial}{\\partial x_2} \\left( \\frac{1}{2} k (x_2 - x_1 - r_e)^2 \\right) = -k(x_2 - x_1 - r_e) \\cdot (1) = -k(x_2 - x_1 - r_e) = -k q$$\nThe total external force on the system is $F_{total} = F_1 + F_2 = k q - k q = 0$, which confirms that the center-of-mass motion is uncoupled from the internal motion.\n\nWe apply Newton's second law, $F=ma$, to each mass. The acceleration is the second time derivative of the position, $\\ddot{x}$. Since the equilibrium positions are constant, $\\ddot{x}_1 = \\ddot{\\delta}_1$ and $\\ddot{x}_2 = \\ddot{\\delta}_2$.\nThe resulting coupled equations of motion for the displacements are:\n$$m_1 \\ddot{\\delta}_1 = F_1 = k q$$\n$$m_2 \\ddot{\\delta}_2 = F_2 = -k q$$\nSubstituting $q = \\delta_2 - \\delta_1$, we have:\n$$m_1 \\ddot{\\delta}_1 = k (\\delta_2 - \\delta_1)$$\n$$m_2 \\ddot{\\delta}_2 = -k (\\delta_2 - \\delta_1)$$\n\nTo obtain a single differential equation for the internal coordinate $q$, we take its second time derivative:\n$$\\ddot{q} = \\ddot{\\delta}_2 - \\ddot{\\delta}_1$$\nFrom the equations of motion, we isolate the accelerations:\n$$\\ddot{\\delta}_1 = \\frac{k}{m_1} q$$\n$$\\ddot{\\delta}_2 = -\\frac{k}{m_2} q$$\nSubstituting these expressions into the equation for $\\ddot{q}$:\n$$\\ddot{q} = \\left(-\\frac{k}{m_2} q\\right) - \\left(\\frac{k}{m_1} q\\right) = -k \\left( \\frac{1}{m_1} + \\frac{1}{m_2} \\right) q$$\nThis is the single ordinary differential equation for the internal coordinate $q$. It is common to define the reduced mass, $\\mu$, as $\\frac{1}{\\mu} = \\frac{1}{m_1} + \\frac{1}{m_2}$, which simplifies the equation to:\n$$\\ddot{q} = -\\frac{k}{\\mu} q$$\nThis can be rearranged into the standard form for a simple harmonic oscillator:\n$$\\ddot{q} + \\frac{k}{\\mu} q = 0$$\nThe general equation for a simple harmonic oscillator is $\\ddot{x} + \\omega^2 x = 0$, where $\\omega$ is the angular frequency. By direct comparison of our equation for $q$ with the general form, we identify the square of the angular frequency:\n$$\\omega^2 = \\frac{k}{\\mu}$$\nTherefore, the vibrational angular frequency is:\n$$\\omega = \\sqrt{\\frac{k}{\\mu}}$$\nTo express this solely in terms of the given parameters $k$, $m_1$, and $m_2$, we substitute the definition of the reduced mass:\n$$\\frac{1}{\\mu} = \\frac{1}{m_1} + \\frac{1}{m_2} = \\frac{m_2 + m_1}{m_1 m_2}$$\nThus, the final expression for the angular frequency is:\n$$\\omega = \\sqrt{k \\left(\\frac{1}{m_1} + \\frac{1}{m_2}\\right)} = \\sqrt{\\frac{k(m_1 + m_2)}{m_1 m_2}}$$\nThis result is the fundamental frequency of vibration for a diatomic molecule within the harmonic approximation.", "answer": "$$\\boxed{\\sqrt{\\frac{k(m_1 + m_2)}{m_1 m_2}}}$$", "id": "2686820"}, {"introduction": "While analytical solutions are powerful, most molecular systems are too complex and require numerical methods. This computational practice [@problem_id:2459291] puts you in the driver's seat of a molecular dynamics simulation, where you will implement the velocity-Verlet algorithm to integrate Newton's equations. By comparing a trajectory from a correct harmonic force with one from a hypothetical, incorrect force law, you will gain first-hand insight into how the mathematical form of the potential dictates the physical outcome and why numerical stability is paramount.", "problem": "Consider a single molecule constrained to one spatial dimension. Let the coordinate be $r(t)$, velocity be $v(t) = \\frac{dr}{dt}$, and mass be $m$. The fundamental dynamical statement is Newton’s second law, $m \\frac{d^2 r}{dt^2} = F(r)$, where $F(r)$ is the force along the coordinate. In a typical harmonic approximation near an equilibrium position $r_0$, one would use a restoring force proportional to displacement. Suppose, however, that the force is erroneously computed as a square of the displacement instead of a linear term. Your task is to formalize the resulting equations of motion, explain the qualitative differences in trajectories, and quantify these differences by numerical integration.\n\nStarting from Newton’s second law and core kinematic definitions, do the following in reduced (dimensionless) units where $m = 1$, $k = 1$, and $r_0 = 0$:\n\n1. For the correct harmonic model, the force is $F_{\\text{harm}}(r) = -k (r - r_0)$.\n2. For the incorrect model, the force is $F_{\\text{sq}}(r) = -k (r - r_0)^2$.\n\nImplement a time-reversible symplectic integrator suitable for second-order ordinary differential equations (for example, a velocity-Verlet scheme) to integrate $m \\frac{d^2 r}{dt^2} = F(r)$ for both force models from identical initial conditions. Use a fixed time step $\\Delta t$ and a fixed number of steps $N$ per test. For numerical safety, if during the integration of the incorrect model the magnitude of the position exceeds a divergence threshold $R_{\\max}$, terminate the integration for that model early and treat the final position as the capped value at the threshold (that is, if $r$ would exceed $R_{\\max}$ in magnitude, set $r$ to $\\pm R_{\\max}$ with the appropriate sign and stop integrating that trajectory).\n\nYour program must compute, for each test case, the scalar quantity\n$$D = r_{\\text{sq}}(T) - r_{\\text{harm}}(T),$$\nwhere $r_{\\text{sq}}(T)$ and $r_{\\text{harm}}(T)$ are the final positions at $t = T = N \\Delta t$ for the incorrect and correct models, respectively.\n\nUse the following test suite (all in reduced, dimensionless units):\n- Test A (happy path, displaced at rest): $m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0.5$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$ (so $T \\approx 2\\pi$), $R_{\\max} = 10^6$.\n- Test B (boundary equilibrium): $m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$.\n- Test C (initial velocity through equilibrium): $m = 1$, $k = 1$, $r_0 = 0$, $r(0) = 0$, $v(0) = 1$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$.\n\nScientific realism: In molecular simulations, nondimensionalization (reduced units) is widely used to analyze dynamics without committing to specific unit scales. The above choices correspond to a representative problem where $r_0$ is the equilibrium bond length, and $k$ encodes stiffness in reduced form.\n\nAngle units are not applicable. No physical unit conversion is required because all quantities are dimensionless by construction.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[D_A, D_B, D_C]$, where each $D$ is a floating-point number rounded to exactly six decimal places (for example, $[1.234567,0.000000,-2.500000]$).", "solution": "The problem statement submitted for consideration has been rigorously validated.\n\n**Step 1: Extracted Givens**\n- Equation of motion: $m \\frac{d^2 r}{dt^2} = F(r)$\n- Reduced units: $m = 1$, $k = 1$, $r_0 = 0$\n- Harmonic force model: $F_{\\text{harm}}(r) = -k (r - r_0)$\n- Squared force model: $F_{\\text{sq}}(r) = -k (r - r_0)^2$\n- Numerical integration: Time-reversible symplectic integrator (e.g., velocity-Verlet) with time step $\\Delta t$ and $N$ steps.\n- Divergence handling for squared model: If $|r| > R_{\\max}$, integration stops and $r$ is capped at $\\pm R_{\\max}$.\n- Output quantity: $D = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$ at final time $T = N \\Delta t$.\n- Test cases:\n  - Test A: $r(0) = 0.5$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$.\n  - Test B: $r(0) = 0$, $v(0) = 0$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$.\n  - Test C: $r(0) = 0$, $v(0) = 1$, $\\Delta t = 10^{-3}$, $N = 6283$, $R_{\\max} = 10^6$.\n\n**Step 2: Validation Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective. It presents a standard exercise in computational physics, comparing the dynamics of a canonical system (harmonic oscillator) with a non-standard, illustrative counterpart. All parameters, initial conditions, and procedural requirements are specified completely and without contradiction. The problem does not violate any fundamental principles of mechanics or mathematics; rather, it uses them as the basis for a comparative numerical study.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be furnished.\n\nThe solution proceeds by first formalizing the equations of motion and analyzing the qualitative behavior they imply. Subsequently, the specified numerical integration algorithm, the velocity-Verlet method, is detailed. Finally, this algorithm is applied to the provided test cases to compute the required quantity $D$.\n\nIn the specified reduced units where $m=1$, $k=1$, and $r_0=0$, the two equations of motion are:\n1.  **Harmonic Model:**\n    $$\n    \\frac{d^2 r}{dt^2} = F_{\\text{harm}}(r) = -r\n    $$\n    This is the defining equation for simple harmonic motion. The force is always directed towards the equilibrium position $r=0$, and its magnitude is proportional to the displacement. The potential energy is $V_{\\text{harm}}(r) = \\frac{1}{2}r^2$, a symmetric parabola. For any total energy $E > 0$, the motion is bounded and periodic with angular frequency $\\omega = \\sqrt{k/m} = 1$. Trajectories are sinusoidal.\n\n2.  **Squared Model:**\n    $$\n    \\frac{d^2 r}{dt^2} = F_{\\text{sq}}(r) = -r^2\n    $$\n    This model presents a starkly different physical picture. The force is always non-positive, $F_{\\text{sq}}(r) \\le 0$, regardless of the sign of $r$.\n    - For $r > 0$, the force is negative (restoring), pulling the particle towards $r=0$.\n    - For $r < 0$, the force is *also* negative (anti-restoring), pushing the particle further towards $r = -\\infty$.\n    The potential energy is $V_{\\text{sq}}(r) = \\int_0^r -F_{\\text{sq}}(x) dx = \\int_0^r x^2 dx = \\frac{1}{3}r^3$. This potential has a local minimum at $r=0$ but is unbounded below as $r \\to -\\infty$. Consequently, any particle that enters the region $r < 0$ with non-zero energy will accelerate without limit towards negative infinity. This is not a model for stable oscillatory motion.\n\nTo integrate these second-order ordinary differential equations, the velocity-Verlet algorithm is an appropriate choice due to its time-reversibility and symplectic nature, which grants it excellent long-term energy conservation properties for Hamiltonian systems. For a given position $r(t)$, velocity $v(t)$, and acceleration $a(t) = F(r(t))/m$, one step of the algorithm to find the state at $t+\\Delta t$ is as follows:\n1.  Update the position:\n    $$\n    r(t+\\Delta t) = r(t) + v(t)\\Delta t + \\frac{1}{2}a(t)\\Delta t^2\n    $$\n2.  Compute the acceleration at the new position:\n    $$\n    a(t+\\Delta t) = \\frac{F(r(t+\\Delta t))}{m}\n    $$\n3.  Update the velocity using an average of the old and new accelerations:\n    $$\n    v(t+\\Delta t) = v(t) + \\frac{1}{2}[a(t) + a(t+\\Delta t)]\\Delta t\n    $$\nThis sequence of operations is iterated $N$ times, starting from the initial conditions $r(0)$ and $v(0)$, to obtain the trajectory up to the final time $T=N\\Delta t$. For the squared model, a check is performed after each position update. If $|r_{\\text{sq}}|$ exceeds $R_{\\max}$, the position is capped, and integration for that trajectory is halted.\n\nApplying this to the test cases:\n- **Test A: $r(0) = 0.5, v(0) = 0$.**\n  - $r_{\\text{harm}}(t) = 0.5 \\cos(t)$. At $T = 6.283 \\approx 2\\pi$, $r_{\\text{harm}}(T)$ will be very close to $r(0) = 0.5$.\n  - For the squared model, the particle starts at $r>0$, is pulled to $r=0$, overshoots into the $r<0$ region, and then accelerates unboundedly. It will hit the divergence threshold, so $r_{\\text{sq}}(T) = -R_{\\max} = -10^6$.\n  - $D_A = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$ will be approximately $-10^6 - 0.5$.\n\n- **Test B: $r(0) = 0, v(0) = 0$.**\n  - For both models, the initial force and velocity are zero. The particle is at a stable (for harmonic) or metastable (for squared) equilibrium. It will not move.\n  - $r_{\\text{harm}}(T)=0$ and $r_{\\text{sq}}(T)=0$.\n  - $D_B = 0 - 0 = 0$.\n\n- **Test C: $r(0) = 0, v(0) = 1$.**\n  - $r_{\\text{harm}}(t) = \\sin(t)$. At $T = 6.283 \\approx 2\\pi$, $r_{\\text{harm}}(T)$ will be very close to $\\sin(2\\pi) = 0$.\n  - For the squared model, the initial velocity carries the particle into the $r>0$ region. The force $-r^2$ slows it, turns it around, and it passes back through $r=0$ into the region $r<0$, where it diverges. It will hit the threshold, so $r_{\\text{sq}}(T) = -R_{\\max} = -10^6$.\n  - $D_C = r_{\\text{sq}}(T) - r_{\\text{harm}}(T)$ will be approximately $-10^6 - 0$.\n\nThe following program implements this logic to provide precise numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing harmonic vs. squared force models\n    using a velocity-Verlet integrator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test A (happy path, displaced at rest)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.5, 'v_init': 0.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6},\n        # Test B (boundary equilibrium)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.0, 'v_init': 0.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6},\n        # Test C (initial velocity through equilibrium)\n        {'m': 1.0, 'k': 1.0, 'r0_val': 0.0, 'r_init': 0.0, 'v_init': 1.0, \n         'dt': 1e-3, 'N': 6283, 'R_max': 1e6}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, k, r0_val = case['m'], case['k'], case['r0_val']\n        r_init, v_init = case['r_init'], case['v_init']\n        dt, N, R_max = case['dt'], case['N'], case['R_max']\n        \n        # Force functions for the two models\n        def force_harm(r):\n            return -k * (r - r0_val)\n        \n        def force_sq(r):\n            return -k * (r - r0_val)**2\n\n        # Initialize positions, velocities, and accelerations for both models\n        r_harm, v_harm = r_init, v_init\n        a_harm = force_harm(r_harm) / m\n        \n        r_sq, v_sq = r_init, v_init\n        a_sq = force_sq(r_sq) / m\n        \n        # Flag to indicate if the squared model has diverged and integration stopped\n        sq_diverged = False\n\n        # Main integration loop\n        for _ in range(N):\n            # --- Velocity-Verlet step for Harmonic model ---\n            # 1. Update position\n            r_harm = r_harm + v_harm * dt + 0.5 * a_harm * dt**2\n            # 2. Calculate new acceleration\n            a_harm_new = force_harm(r_harm) / m\n            # 3. Update velocity\n            v_harm = v_harm + 0.5 * (a_harm + a_harm_new) * dt\n            # 4. Store new acceleration for the next step\n            a_harm = a_harm_new\n\n            # --- Velocity-Verlet step for Squared model ---\n            if not sq_diverged:\n                # 1. Update position\n                r_sq_new = r_sq + v_sq * dt + 0.5 * a_sq * dt**2\n                \n                # Check for divergence\n                if abs(r_sq_new) > R_max:\n                    r_sq = R_max * np.sign(r_sq_new)\n                    sq_diverged = True\n                    # Do not update velocity or acceleration further\n                else:\n                    r_sq = r_sq_new\n                    # 2. Calculate new acceleration\n                    a_sq_new = force_sq(r_sq) / m\n                    # 3. Update velocity\n                    v_sq = v_sq + 0.5 * (a_sq + a_sq_new) * dt\n                    # 4. Store new acceleration for the next step\n                    a_sq = a_sq_new\n        \n        # Calculate the final difference D\n        D = r_sq - r_harm\n        results.append(D)\n\n    # Format the final output as a string with exactly 6 decimal places per value\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2459291"}, {"introduction": "Real molecules are more than just pairs of atoms; their geometry is defined by angles, requiring multi-body potentials. This advanced exercise [@problem_id:2459282] is a deep dive into the engine of modern force fields, teaching you how to derive and implement the forces arising from an angle-bending potential, $V = k(\\theta - \\theta_0)^2$. By mastering the necessary vector calculus and seeing how principles like translational invariance are preserved, you will gain a fundamental understanding of how simulations model molecular flexibility.", "problem": "Consider three point particles labeled $i$, $j$, and $k$, with positions $\\mathbf{r}_i$, $\\mathbf{r}_j$, and $\\mathbf{r}_k$ in three-dimensional space. In reduced units (mass $m = 1$, energy $= 1$, length $= 1$, time $= 1$), they interact through a purely three-body angle potential that depends on the angle at particle $j$ formed by the vectors $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$. The potential energy for a triplet $(i,j,k)$ is\n$$\nV_{ijk} = k \\left(\\theta_{ijk} - \\theta_0\\right)^2,\n$$\nwhere $\\theta_{ijk}$ is the angle at $j$ between $\\mathbf{a}$ and $\\mathbf{b}$, the force constant $k$ is a positive scalar, and the reference angle is $\\theta_0 = \\pi/2$. All angles must be expressed in radians. The system is otherwise non-interacting. The dynamics obey Newton's Second Law, $m \\, d^2 \\mathbf{r}_\\alpha/dt^2 = \\mathbf{F}_\\alpha$ for each particle $\\alpha \\in \\{i,j,k\\}$, with $\\mathbf{F}_\\alpha = -\\nabla_{\\mathbf{r}_\\alpha} V_{ijk}$.\n\nTask A. Starting only from the following fundamental base:\n- Newton's Second Law, $m \\, d^2 \\mathbf{r}/dt^2 = \\mathbf{F}$,\n- The definition of velocity $d\\mathbf{r}/dt$ and acceleration $d^2\\mathbf{r}/dt^2$,\n- The definition of the angle $\\theta$ between two nonzero vectors $\\mathbf{a}$ and $\\mathbf{b}$ via $\\cos \\theta = \\dfrac{\\mathbf{a} \\cdot \\mathbf{b}}{\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert}$ and $\\theta = \\arccos(\\cos \\theta)$,\nderive an explicit analytic expression for the forces $\\mathbf{F}_i$, $\\mathbf{F}_j$, and $\\mathbf{F}_k$ arising from $V_{ijk}$ in terms of $\\mathbf{a}$, $\\mathbf{b}$, and their norms. Your derivation must proceed from the chain rule and vector calculus identities, without assuming any pre-tabulated force formulas.\n\nTask B. Implement a program that computes, for a single triplet $(i,j,k)$, the potential energy $V_{ijk}$ and the force vectors $\\mathbf{F}_i$, $\\mathbf{F}_j$, and $\\mathbf{F}_k$ implied by your result in Task A. Numerically, use the following algorithmic guidance to ensure stability:\n- Compute $\\theta$ as $\\theta = \\operatorname{atan2}\\!\\left(\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert, \\mathbf{a} \\cdot \\mathbf{b}\\right)$ in radians.\n- Guard all denominators by replacing any occurrence of $\\lVert \\mathbf{a} \\rVert$, $\\lVert \\mathbf{b} \\rVert$, or $\\sin \\theta$ smaller than $\\varepsilon$ by $\\varepsilon$, where $\\varepsilon = 10^{-12}$, to avoid division by zero in the nearly-collinear limit.\n\nTask C. Validate your implementation on the following test suite. In each case, use the given positions and parameter values, and compute three floats:\n- the potential energy $V_{ijk}$,\n- the Euclidean norm of the total force $\\lVert \\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k \\rVert$,\n- the angle $\\theta$ in radians.\nReport these three floats, rounded to $10$ decimal places.\n\nUse the following test suite (all coordinates in reduced units, angles in radians):\n- Case $1$ (happy path, right angle): $\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (0, 1, 0)$, $k = 10$.\n- Case $2$ (acute angle): $\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (1, 1, 0)$, $k = 10$.\n- Case $3$ (obtuse angle): $\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (-1, 1, 0)$, $k = 10$.\n- Case $4$ (near-collinear edge): $\\mathbf{r}_i = (1, 0, 0)$, $\\mathbf{r}_j = (0, 0, 0)$, $\\mathbf{r}_k = (10, 0.01, 0)$, $k = 10$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list corresponding to one case and containing the three floats in the order specified above, rounded to $10$ decimal places, for example, $[\\,[v_1, f_1, \\theta_1],[v_2, f_2, \\theta_2],\\ldots\\,]$. All angles must be in radians. Energies are reported in reduced (dimensionless) units. The angle unit is radians. Each float must be rounded to exactly $10$ decimal places.", "solution": "The problem is assessed to be valid. It is a well-posed, scientifically-grounded exercise in classical mechanics and vector calculus, common in the field of computational chemistry. We proceed with the derivation and subsequent implementation.\n\nThe task is to derive the forces on three particles $i$, $j$, and $k$ interacting via a three-body potential $V_{ijk} = k(\\theta_{ijk} - \\theta_0)^2$. The force on a particle $\\alpha$ is given by the negative gradient of the potential with respect to its position coordinate $\\mathbf{r}_\\alpha$:\n$$\n\\mathbf{F}_\\alpha = -\\nabla_{\\mathbf{r}_\\alpha} V_{ijk}\n$$\nThe potential $V_{ijk}$ is a function of the angle $\\theta_{ijk}$, which in turn depends on the particle positions. We apply the chain rule:\n$$\n\\mathbf{F}_\\alpha = - \\frac{dV_{ijk}}{d\\theta_{ijk}} \\nabla_{\\mathbf{r}_\\alpha} \\theta_{ijk}\n$$\nFirst, we compute the derivative of the potential with respect to the angle $\\theta \\equiv \\theta_{ijk}$:\n$$\n\\frac{dV}{d\\theta} = \\frac{d}{d\\theta} \\left[ k(\\theta - \\theta_0)^2 \\right] = 2k(\\theta - \\theta_0)\n$$\nNext, we derive the gradient of the angle $\\theta$ with respect to the particle positions. The angle $\\theta$ is defined by the vectors $\\mathbf{a} = \\mathbf{r}_i - \\mathbf{r}_j$ and $\\mathbf{b} = \\mathbf{r}_k - \\mathbf{r}_j$ via the dot product:\n$$\n\\cos\\theta = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{\\lVert \\mathbf{a} \\rVert \\lVert \\mathbf{b} \\rVert} = \\frac{\\mathbf{a} \\cdot \\mathbf{b}}{ab}\n$$\nwhere $a = \\lVert \\mathbf{a} \\rVert$ and $b = \\lVert \\mathbf{b} \\rVert$. It is more convenient to work with unit vectors $\\hat{\\mathbf{a}} = \\mathbf{a}/a$ and $\\hat{\\mathbf{b}} = \\mathbf{b}/b$, so $\\cos\\theta = \\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}$.\n\nTo find $\\nabla_{\\mathbf{r}_\\alpha} \\theta$, we first find $\\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta$ and use the relation $\\frac{d(\\arccos u)}{du} = -1/\\sqrt{1-u^2}$.\n$$\n\\nabla_{\\mathbf{r}_\\alpha} \\theta = \\nabla_{\\mathbf{r}_\\alpha} \\arccos(\\cos\\theta) = \\frac{d(\\arccos(\\cos\\theta))}{d(\\cos\\theta)} \\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta = -\\frac{1}{\\sin\\theta} \\nabla_{\\mathbf{r}_\\alpha} \\cos\\theta\n$$\nThis holds for $\\theta \\in (0, \\pi)$, where $\\sin\\theta \\neq 0$. The case of collinear atoms will be handled numerically.\n\nThe gradients of the vectors $\\mathbf{a}$ and $\\mathbf{b}$ with respect to the particle positions are:\n$$\n\\nabla_{\\mathbf{r}_i} \\mathbf{a} = \\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_j} \\mathbf{a} = -\\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_k} \\mathbf{a} = \\mathbf{0}\n$$\n$$\n\\nabla_{\\mathbf{r}_i} \\mathbf{b} = \\mathbf{0}, \\quad \\nabla_{\\mathbf{r}_j} \\mathbf{b} = -\\mathbf{I}, \\quad \\nabla_{\\mathbf{r}_k} \\mathbf{b} = \\mathbf{I}\n$$\nwhere $\\mathbf{I}$ is the rank-$2$ identity tensor.\n\nThe gradient of a unit vector $\\hat{\\mathbf{u}} = \\mathbf{u}/u$ ($u = \\lVert \\mathbf{u} \\rVert$) with respect to a vector $\\mathbf{x}$ is:\n$$\n\\nabla_{\\mathbf{x}} \\hat{\\mathbf{u}} = \\frac{1}{u}\\nabla_{\\mathbf{x}}\\mathbf{u} - \\frac{\\mathbf{u}}{u^2} (\\nabla_{\\mathbf{x}} u)^T = \\frac{1}{u}(\\mathbf{I} - \\hat{\\mathbf{u}}\\hat{\\mathbf{u}}^T)\\nabla_{\\mathbf{x}}\\mathbf{u}\n$$\n\nNow we compute the force for each particle.\n\n**Force on particle $i$ ($\\mathbf{F}_i$):**\nWe require $\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\nabla_{\\mathbf{r}_i} (\\hat{\\mathbf{a}} \\cdot \\hat{\\mathbf{b}}) = (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{a}}) \\cdot \\hat{\\mathbf{b}} + (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{b}}) \\cdot \\hat{\\mathbf{a}}$.\nSince $\\mathbf{b}$ does not depend on $\\mathbf{r}_i$, $\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{b}} = \\mathbf{0}$.\n$$\n\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{a}} = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)(\\nabla_{\\mathbf{r}_i}\\mathbf{a}) = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\n$$\nTherefore,\n$$\n\\nabla_{\\mathbf{r}_i} \\cos\\theta = \\frac{1}{a}(\\mathbf{I} - \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\\hat{\\mathbf{b}} = \\frac{1}{a}(\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}(\\hat{\\mathbf{a}}\\cdot\\hat{\\mathbf{b}})) = \\frac{\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}}{a}\n$$\nThe gradient of the angle is:\n$$\n\\nabla_{\\mathbf{r}_i} \\theta = -\\frac{1}{\\sin\\theta} \\left( \\frac{\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}}{a} \\right) = \\frac{\\cos\\theta\\,\\hat{\\mathbf{a}} - \\hat{\\mathbf{b}}}{a\\sin\\theta}\n$$\nAnd the force is:\n$$\n\\mathbf{F}_i = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_i} \\theta = -2k(\\theta - \\theta_0) \\left(\\frac{\\cos\\theta\\,\\hat{\\mathbf{a}} - \\hat{\\mathbf{b}}}{a\\sin\\theta}\\right) = \\frac{2k(\\theta - \\theta_0)}{a\\sin\\theta}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}})\n$$\n\n**Force on particle $k$ ($\\mathbf{F}_k$):**\nThe derivation is symmetric to that of $\\mathbf{F}_i$ with the interchange of particles $i \\leftrightarrow k$ and vectors $\\mathbf{a} \\leftrightarrow \\mathbf{b}$.\n$$\n\\nabla_{\\mathbf{r}_k} \\cos\\theta = \\frac{\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}}}{b}\n$$\n$$\n\\nabla_{\\mathbf{r}_k} \\theta = \\frac{\\cos\\theta\\,\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}}{b\\sin\\theta}\n$$\n$$\n\\mathbf{F}_k = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_k} \\theta = -2k(\\theta - \\theta_0) \\left(\\frac{\\cos\\theta\\,\\hat{\\mathbf{b}} - \\hat{\\mathbf{a}}}{b\\sin\\theta}\\right) = \\frac{2k(\\theta-\\theta_0)}{b\\sin\\theta}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}})\n$$\n\n**Force on particle $j$ ($\\mathbf{F}_j$):**\nThe position $\\mathbf{r}_j$ affects both $\\mathbf{a}$ and $\\mathbf{b}$.\n$$\n\\begin{aligned}\n\\nabla_{\\mathbf{r}_j} \\cos\\theta &= (\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{a}})\\cdot\\hat{\\mathbf{b}} + (\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{b}})\\cdot\\hat{\\mathbf{a}} \\\\\n\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{a}} &= \\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)(\\nabla_{\\mathbf{r}_j}\\mathbf{a}) = -\\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T) \\\\\n\\nabla_{\\mathbf{r}_j}\\hat{\\mathbf{b}} &= \\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)(\\nabla_{\\mathbf{r}_j}\\mathbf{b}) = -\\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)\n\\end{aligned}\n$$\nSubstituting these into the gradient of $\\cos\\theta$:\n$$\n\\begin{aligned}\n\\nabla_{\\mathbf{r}_j} \\cos\\theta &= -\\frac{1}{a}(\\mathbf{I}-\\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^T)\\hat{\\mathbf{b}} - \\frac{1}{b}(\\mathbf{I}-\\hat{\\mathbf{b}}\\hat{\\mathbf{b}}^T)\\hat{\\mathbf{a}} \\\\\n&= -\\frac{1}{a}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}}) - \\frac{1}{b}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}}) \\\\\n&= -(\\nabla_{\\mathbf{r}_i}\\cos\\theta + \\nabla_{\\mathbf{r}_k}\\cos\\theta)\n\\end{aligned}\n$$\nThis implies $\\nabla_{\\mathbf{r}_j} \\theta = -(\\nabla_{\\mathbf{r}_i} \\theta + \\nabla_{\\mathbf{r}_k} \\theta)$.\nThe potential $V_{ijk}$ is invariant under uniform translation of the whole system ($\\mathbf{r}_\\alpha \\to \\mathbf{r}_\\alpha + \\mathbf{c}$ for all $\\alpha$), thus the sum of the forces must be zero.\n$$\n\\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k = -\\nabla_{\\mathbf{r}_i}V - \\nabla_{\\mathbf{r}_j}V - \\nabla_{\\mathbf{r}_k}V = \\mathbf{0}\n$$\nFrom this, we deduce $\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)$. This is consistent with our gradient calculation, as:\n$$\n\\mathbf{F}_j = -\\frac{dV}{d\\theta} \\nabla_{\\mathbf{r}_j}\\theta = -\\frac{dV}{d\\theta} [-(\\nabla_{\\mathbf{r}_i}\\theta + \\nabla_{\\mathbf{r}_k}\\theta)] = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\n\n**Final expressions for implementation:**\nLet $C = 2k(\\theta - \\theta_0)$.\n$$\n\\mathbf{F}_i = \\frac{C}{a\\sin\\theta}(\\hat{\\mathbf{b}} - \\cos\\theta\\,\\hat{\\mathbf{a}})\n$$\n$$\n\\mathbf{F}_k = \\frac{C}{b\\sin\\theta}(\\hat{\\mathbf{a}} - \\cos\\theta\\,\\hat{\\mathbf{b}})\n$$\n$$\n\\mathbf{F}_j = -(\\mathbf{F}_i + \\mathbf{F}_k)\n$$\nThese expressions will be implemented. For numerical stability, as per the problem statement, the denominators $a$, $b$, and $\\sin\\theta$ will be guarded against being smaller than a small positive constant $\\varepsilon = 10^{-12}$. The angle $\\theta$ is computed robustly using $\\theta = \\operatorname{atan2}(\\lVert \\mathbf{a} \\times \\mathbf{b} \\rVert, \\mathbf{a} \\cdot \\mathbf{b})$.\n\nThe implementation will compute the potential energy $V_{ijk}$, the angle $\\theta$, and the Euclidean norm of the total force $\\lVert \\mathbf{F}_i + \\mathbf{F}_j + \\mathbf{F}_k \\rVert$. Due to the use of finite-precision arithmetic, this norm is expected to be a very small number close to zero, rather than exactly zero.", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes potential energy, total force norm, and angle for a three-body system.\n    \"\"\"\n    test_cases = [\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([0.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([-1.0, 1.0, 0.0]), 'k': 10.0},\n        {'r_i': np.array([1.0, 0.0, 0.0]), 'r_j': np.array([0.0, 0.0, 0.0]), 'r_k': np.array([10.0, 0.01, 0.0]), 'k': 10.0}\n    ]\n\n    all_results = []\n    \n    # Constants\n    theta_0 = math.pi / 2.0\n    epsilon = 1.e-12\n\n    for case in test_cases:\n        r_i = case['r_i']\n        r_j = case['r_j']\n        r_k = case['r_k']\n        k = case['k']\n\n        # 1. Define vectors\n        a_vec = r_i - r_j\n        b_vec = r_k - r_j\n\n        # 2. Compute norms and guarded norms\n        a_norm = np.linalg.norm(a_vec)\n        b_norm = np.linalg.norm(b_vec)\n        a_norm_g = max(a_norm, epsilon)\n        b_norm_g = max(b_norm, epsilon)\n\n        # 3. Compute angle theta\n        dot_product = np.dot(a_vec, b_vec)\n        cross_product_norm = np.linalg.norm(np.cross(a_vec, b_vec))\n        theta = np.arctan2(cross_product_norm, dot_product)\n\n        # 4. Compute potential energy\n        V = k * (theta - theta_0)**2\n\n        # 5. Compute forces\n        cos_theta = dot_product / (a_norm_g * b_norm_g)\n        sin_theta = math.sin(theta)\n        sin_theta_g = max(abs(sin_theta), epsilon) # Use abs for safety near pi\n\n        # Prefactor for forces\n        C = 2.0 * k * (theta - theta_0)\n\n        # Unit vectors\n        a_hat = a_vec / a_norm_g\n        b_hat = b_vec / b_norm_g\n        \n        # Calculate forces using the derived expressions\n        F_i = (C / (a_norm_g * sin_theta_g)) * (b_hat - cos_theta * a_hat)\n        F_k = (C / (b_norm_g * sin_theta_g)) * (a_hat - cos_theta * b_hat)\n        F_j = -(F_i + F_k)\n\n        # 6. Compute total force and its norm\n        F_total = F_i + F_j + F_k\n        F_total_norm = np.linalg.norm(F_total)\n        \n        # 7. Collect results for the case\n        results_per_case = [V, F_total_norm, theta]\n        all_results.append(results_per_case)\n\n    # Format the final output string\n    sublist_strings = []\n    for sublist in all_results:\n        formatted_numbers = [f\"{num:.10f}\" for num in sublist]\n        sublist_strings.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    print(f\"[{','.join(sublist_strings)}]\")\n\nsolve()\n```", "id": "2459282"}]}