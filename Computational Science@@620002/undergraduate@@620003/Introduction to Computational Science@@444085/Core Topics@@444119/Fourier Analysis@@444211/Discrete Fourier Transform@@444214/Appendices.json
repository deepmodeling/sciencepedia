{"hands_on_practices": [{"introduction": "To build a strong intuition for the Discrete Fourier Transform (DFT), we begin by examining how it responds to its own fundamental building blocks. This practice involves calculating the DFT of a single complex exponential, which represents a pure, idealized tone perfectly aligned with the DFT's frequency grid. By working through this foundational example [@problem_id:1759639], you will discover the DFT's role as a precise frequency analyzer, revealing how it isolates a signal's energy into a single frequency bin.", "problem": "In digital signal processing, the Discrete Fourier Transform (DFT) is a fundamental tool for analyzing the frequency content of a finite-length signal. Consider a simplified model of a pure tone signal after sampling. This signal, denoted as $x[n]$, is represented by a single complex exponential.\n\nThe signal is a sequence of length $N$ defined as:\n$$x[n] = \\exp\\left(j \\frac{2\\pi k_0 n}{N}\\right)$$\nfor the time index $n = 0, 1, \\ldots, N-1$. Here, $k_0$ is an integer constant representing the normalized frequency of the tone, and it satisfies $0 \\le k_0 < N$.\n\nYour task is to compute the $N$-point DFT of this signal. The DFT, denoted by $X[k]$, is defined by the analysis equation:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right)$$\nwhere $k$ is the frequency index, taking integer values from $k = 0, 1, \\ldots, N-1$.\n\nFind a single, closed-form analytic expression for $X[k]$ in terms of $N$, $k$, and $k_0$.", "solution": "We start from the DFT analysis equation and substitute the given signal. By definition,\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right).\n$$\nWith $x[n] = \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)$, this becomes\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-j \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\nDefine the ratio\n$$\nr \\triangleq \\exp\\left(j \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\nThen\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\nThis is a finite geometric series. Using the geometric series sum,\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r}, & r \\neq 1, \\\\\nN, & r = 1,\n\\end{cases}\n$$\nand noting that\n$$\nr^{N} = \\exp\\left(j \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(j 2\\pi (k_{0}-k)\\right) = 1,\n$$\nwe have:\n- If $r \\neq 1$ (equivalently $k \\neq k_{0}$ for $k,k_{0}\\in\\{0,\\ldots,N-1\\}$), then $1 - r^{N} = 0$ while $1 - r \\neq 0$, so $X[k] = 0$.\n- If $r = 1$ (equivalently $k = k_{0}$), then every term of the sum equals $1$, so $X[k] = N$.\n\nCombining these cases gives the closed-form expression\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\nwhere $\\delta_{k,k_{0}}$ is the Kronecker delta, equal to $1$ if $k=k_{0}$ and $0$ otherwise.", "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$", "id": "1759639"}, {"introduction": "Beyond analyzing individual frequencies, the DFT possesses profound properties that apply to all signals. This practice explores one of the most important: Parseval's theorem, which describes the conservation of energy between the time domain and the frequency domain. You will first derive this crucial relationship and then implement a numerical experiment to verify it across a variety of signal types [@problem_id:3222975], reinforcing the connection between mathematical theory and computational practice.", "problem": "You are asked to design and implement a program that numerically verifies the energy-preservation property between the discrete-time sequence domain and the discrete-frequency domain under the Discrete Fourier Transform (DFT). Begin only from the following fundamental base: the definition of the Discrete Fourier Transform (DFT) and its inverse under the unnormalized forward transform convention, namely\n- Forward DFT: for a length-$N$ sequence $x[n]$, the transform $X[k]$ is defined by $X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi kn/N}$ for $k \\in \\{0,1,\\dots,N-1\\}$.\n- Inverse DFT: $x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi kn/N}$ for $n \\in \\{0,1,\\dots,N-1\\}$.\n\nYour task is to:\n1) Derive, from the stated base, the relation between the time-domain squared $\\ell_2$-norm of $x[n]$ and the corresponding frequency-domain squared $\\ell_2$-norm of $X[k]$ under the above convention.\n2) Design a numerical experiment to verify this relation for multiple sequences. For each test sequence, compute the time-domain energy $E_{\\mathrm{time}} = \\sum_{n=0}^{N-1} |x[n]|^2$ and the frequency-domain energy $E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2$. Compute, for each test case, the dimensionless relative discrepancy\n$$\nr \\;=\\; \\begin{cases}\n\\displaystyle \\frac{\\big| E_{\\mathrm{time}} - E_{\\mathrm{freq}} \\big|}{\\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}}, & \\text{if } \\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\} > 0,\\\\\n0, & \\text{if } E_{\\mathrm{time}} = E_{\\mathrm{freq}} = 0,\n\\end{cases}\n$$\nusing angles in radians.\n\nTest suite. Your program must evaluate exactly the following six sequences, each fully specified below. In all cases, $n$ and $k$ are integer indices and angles are in radians:\n- Case A (random complex, happy path): length $N=128$. Let $x[n]$ be complex-valued with independent real and imaginary parts drawn from a standard normal distribution using a fixed seed $12345$ for reproducibility.\n- Case B (single-bin complex exponential): length $N=64$. Let $x[n] = c \\, e^{j 2\\pi m n / N}$ with $m=7$ and $c = 1.2 \\, e^{j\\,0.4}$.\n- Case C (spectral leakage real sinusoid): length $N=36$. Let $x[n] = A \\sin\\!\\big(2\\pi f n / N + \\varphi\\big)$ with $A=1.0$, $f=\\sqrt{2}$, and $\\varphi=0.3$.\n- Case D (impulse): length $N=50$. Let $x[n] = A$ at index $n_0=17$ and $x[n]=0$ otherwise, with $A=3.0$.\n- Case E (ramp, centered): length $N=32$. Let $x[n] = n - \\frac{N-1}{2}$ for $n \\in \\{0,1,\\dots,N-1\\}$.\n- Case F (all zeros, edge case): length $N=10$. Let $x[n]=0$ for all $n$.\n\nImplementation requirements:\n- Use the unnormalized forward DFT convention as stated above.\n- Compute $X[k]$ using either a correct implementation from first principles or a library function consistent with the stated convention.\n- For each case, compute $E_{\\mathrm{time}}$, $E_{\\mathrm{freq}}$, and the relative discrepancy $r$ as defined.\n- Numerical precision: floating-point arithmetic will introduce rounding error; the relative discrepancy $r$ should be close to $0$. No additional scaling besides what is defined above may be applied.\n\nFinal output format:\n- Your program should produce a single line of output containing the six relative discrepancies as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D, Case E, Case F]. For example: \"[rA,rB,rC,rD,rE,rF]\".\n- Each $r$ must be a floating-point number. No units are involved.", "solution": "The problem requires the derivation and subsequent numerical verification of the energy conservation property of the Discrete Fourier Transform (DFT), commonly known as Parseval's theorem. The specific DFT convention to be used is the unnormalized forward transform.\n\nThe analysis proceeds in two stages: first, a formal mathematical derivation of the expected energy relationship from the given DFT definitions; second, the design and implementation of a numerical experiment to verify this relationship for a suite of test signals, quantifying any discrepancy with a relative error metric.\n\n**1. Mathematical Derivation of Parseval's Theorem**\n\nWe are given the following definitions for a finite, discrete-time sequence $x[n]$ of length $N$, where $n \\in \\{0, 1, \\dots, N-1\\}$:\n\n- Forward DFT: $X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi kn/N}$\n- Inverse DFT: $x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j 2\\pi kn/N}$\n\nThe objective is to establish a relationship between the time-domain energy, defined as the squared $\\ell_2$-norm of the sequence $x[n]$,\n$$E_{\\mathrm{time}} = \\sum_{n=0}^{N-1} |x[n]|^2$$\nand the frequency-domain energy, defined with a specific scaling factor as\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2$$\n\nWe begin the derivation from the expression for the frequency-domain energy, $E_{\\mathrm{freq}}$.\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |X[k]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] X^*[k]$$\nwhere $X^*[k]$ denotes the complex conjugate of $X[k]$.\n\nSubstitute the definition of the forward DFT for $X[k]$ and its conjugate for $X^*[k]$. For clarity, we use a distinct summation index $m$ for the conjugate term.\n$$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$$\n$$X^*[k] = \\left( \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi km/N} \\right)^* = \\sum_{m=0}^{N-1} x^*[m] e^{j 2\\pi km/N}$$\n\nSubstituting these into the expression for $E_{\\mathrm{freq}}$ yields:\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{k=0}^{N-1} \\left( \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N} \\right) \\left( \\sum_{m=0}^{N-1} x^*[m] e^{j 2\\pi km/N} \\right)$$\n\nWe can rearrange the order of summation, as the sums are finite:\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] \\left( \\sum_{k=0}^{N-1} e^{-j 2\\pi kn/N} e^{j 2\\pi km/N} \\right)$$\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] \\left( \\sum_{k=0}^{N-1} e^{j 2\\pi k(m-n)/N} \\right)$$\n\nThe innermost sum, over the index $k$, is a geometric series of complex exponentials. It exhibits a fundamental orthogonality property:\n$$ \\sum_{k=0}^{N-1} e^{j 2\\pi k(m-n)/N} = \\begin{cases} N & \\text{if } m = n \\\\ 0 & \\text{if } m \\neq n \\end{cases} $$\nThis can be written compactly using the Kronecker delta, $\\delta_{m,n}$, as $N \\delta_{m,n}$.\n\nSubstituting this result back into our expression for $E_{\\mathrm{freq}}$:\n$$E_{\\mathrm{freq}} = \\frac{1}{N} \\sum_{n=0}^{N-1} \\sum_{m=0}^{N-1} x[n] x^*[m] (N \\delta_{m,n})$$\n\nThe factor of $N$ cancels. The Kronecker delta $\\delta_{m,n}$ causes the inner sum over $m$ to be non-zero only when $m=n$. This collapses the double summation into a single summation:\n$$E_{\\mathrm{freq}} = \\sum_{n=0}^{N-1} x[n] x^*[n]$$\n\nSince $z z^* = |z|^2$ for any complex number $z$, we arrive at the final result:\n$$E_{\\mathrm{freq}} = \\sum_{n=0}^{N-1} |x[n]|^2$$\n\nThis proves that, for the given DFT convention, the defined time-domain and frequency-domain energies are identical:\n$$E_{\\mathrm{time}} = E_{\\mathrm{freq}}$$\n\n**2. Numerical Verification Design**\n\nThe second part of the task is to numerically verify this identity. Due to the finite precision of floating-point arithmetic, a direct equality check $E_{\\mathrm{time}} == E_{\\mathrm{freq}}$ is ill-advised. Instead, we compute the dimensionless relative discrepancy, $r$, defined as:\n$$\nr \\;=\\; \\begin{cases}\n\\displaystyle \\frac{\\big| E_{\\mathrm{time}} - E_{\\mathrm{freq}} \\big|}{\\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\}}, & \\text{if } \\max\\{E_{\\mathrm{time}}, E_{\\mathrm{freq}}\\} > 0,\\\\\n0, & \\text{if } E_{\\mathrm{time}} = E_{\\mathrm{freq}} = 0,\n\\end{cases}\n$$\nTheoretically, $r$ should be exactly $0$. In practice, we expect $r$ to be a small number on the order of machine epsilon, reflecting the accumulation of floating-point rounding errors.\n\nThe numerical implementation will use Python with the NumPy library. The function `numpy.fft.fft` computes the forward DFT according to the definition $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$, which exactly matches the unnormalized convention specified in the problem.\n\nThe verification will be performed on six distinct test cases, each designed to probe different aspects of the DFT:\n- **Case A**: A sequence of random complex numbers of length $N=128$, representing a general, aperiodic signal. The real and imaginary parts are drawn from a standard normal distribution with a fixed seed for reproducibility.\n- **Case B**: A single-frequency complex exponential of length $N=64$, $x[n] = 1.2 e^{j0.4} \\, e^{j 2\\pi (7) n / 64}$. Its DFT is non-zero at only a single frequency bin, representing a spectrally pure signal.\n- **Case C**: A real-valued sinusoid of length $N=36$ whose frequency $f=\\sqrt{2}$ is not an integer multiple of the bin resolution $1/N$. This tests the case of spectral leakage, where energy is distributed across all frequency bins.\n- **Case D**: A discrete impulse of length $N=50$, $x[n] = 3.0$ at $n=17$ and $0$ otherwise. Its transform has a constant magnitude across all frequencies.\n- **Case E**: A real-valued linear ramp sequence of length $N=32$, centered to have zero mean.\n- **Case F**: The trivial case of a zero sequence of length $N=10$, for which both energies are analytically zero.\n\nFor each case, the program will generate the sequence $x[n]$, compute $X[k]$ via `numpy.fft.fft`, then calculate $E_{\\mathrm{time}}$, $E_{\\mathrm{freq}}$, and the relative discrepancy $r$. The final output will be a collection of the computed $r$ values for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically verifies Parseval's theorem for the DFT.\n    \"\"\"\n    \n    def calculate_discrepancy(x: np.ndarray) -> float:\n        \"\"\"\n        Computes the relative discrepancy between time and frequency domain energies.\n\n        Args:\n            x: A 1D numpy array representing the time-domain sequence x[n].\n\n        Returns:\n            The dimensionless relative discrepancy r.\n        \"\"\"\n        N = len(x)\n        if N == 0:\n            return 0.0\n\n        # Compute time-domain energy: E_time = sum(|x[n]|^2)\n        # Using np.vdot is numerically robust and efficient for sum of squares of a complex vector.\n        E_time = np.vdot(x, x).real\n\n        # Compute frequency-domain signal X[k] using the unnormalized forward DFT\n        X = np.fft.fft(x)\n\n        # Compute frequency-domain energy: E_freq = (1/N) * sum(|X[k]|^2)\n        E_freq = (1 / N) * np.vdot(X, X).real\n\n        # Compute the dimensionless relative discrepancy r\n        max_E = max(E_time, E_freq)\n        \n        if max_E > 0:\n            r = np.abs(E_time - E_freq) / max_E\n        else:\n            # This case handles E_time = E_freq = 0, e.g., for an all-zero signal.\n            r = 0.0\n            \n        return r\n\n    results = []\n\n    # Case A: Random complex, happy path\n    N_A = 128\n    seed_A = 12345\n    rng = np.random.default_rng(seed_A)\n    real_part_A = rng.standard_normal(N_A)\n    imag_part_A = rng.standard_normal(N_A)\n    x_A = real_part_A + 1j * imag_part_A\n    results.append(calculate_discrepancy(x_A))\n\n    # Case B: Single-bin complex exponential\n    N_B = 64\n    m_B = 7\n    c_B = 1.2 * np.exp(1j * 0.4)\n    n_B = np.arange(N_B)\n    x_B = c_B * np.exp(1j * 2 * np.pi * m_B * n_B / N_B)\n    results.append(calculate_discrepancy(x_B))\n\n    # Case C: Spectral leakage real sinusoid\n    N_C = 36\n    A_C = 1.0\n    f_C = np.sqrt(2)\n    phi_C = 0.3\n    n_C = np.arange(N_C)\n    x_C = A_C * np.sin(2 * np.pi * f_C * n_C / N_C + phi_C)\n    results.append(calculate_discrepancy(x_C))\n\n    # Case D: Impulse\n    N_D = 50\n    A_D = 3.0\n    n0_D = 17\n    x_D = np.zeros(N_D)\n    x_D[n0_D] = A_D\n    results.append(calculate_discrepancy(x_D))\n\n    # Case E: Ramp, centered\n    N_E = 32\n    n_E = np.arange(N_E)\n    x_E = n_E - (N_E - 1) / 2.0\n    results.append(calculate_discrepancy(x_E))\n\n    # Case F: All zeros, edge case\n    N_F = 10\n    x_F = np.zeros(N_F)\n    results.append(calculate_discrepancy(x_F))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3222975"}, {"introduction": "The power of the DFT extends beyond one-dimensional signals into applications like image processing. In this exercise, you will apply the two-dimensional DFT to implement an ideal low-pass filter on a synthetic image, a common technique for noise reduction or feature separation. This hands-on task [@problem_id:3222771] not only demonstrates the practical utility of the convolution theorem but also provides a striking visual illustration of the Gibbs phenomenon, a critical artifact that highlights the trade-offs inherent in signal filtering.", "problem": "You are given the task of designing and evaluating an ideal two-dimensional low-pass filter implemented via the Discrete Fourier Transform (DFT). Starting from the definition of the two-dimensional Discrete Fourier Transform (DFT) and its inverse, and using the convolution-multiplication duality between the spatial and frequency domains, implement a circular \"brick-wall\" low-pass filter. Then, quantify the ringing artifacts (Gibbs phenomenon) introduced by this filtering when applied to a synthetic image with a single sharp edge.\n\nWork from the following fundamental bases:\n- The two-dimensional Discrete Fourier Transform (DFT) of an array $x[n,m]$ of size $N \\times N$ is defined by\n$$\nX[u,v] = \\sum_{n=0}^{N-1}\\sum_{m=0}^{N-1} x[n,m] \\, \\exp\\!\\left(-2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right),\n$$\nand the inverse two-dimensional Discrete Fourier Transform (IDFT) is\n$$\nx[n,m] = \\frac{1}{N^2}\\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} X[u,v] \\, \\exp\\!\\left(2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right).\n$$\n- Multiplication in the frequency domain corresponds to convolution in the spatial domain, which implies that an ideal low-pass mask in frequency space corresponds to convolving with a spatial point-spread function that is not compactly supported. Truncating or sharply cutting off frequency content thus introduces oscillatory artifacts near discontinuities in the spatial domain (Gibbs phenomenon).\n\nImplement the following steps:\n1. Construct a synthetic binary step image $I \\in \\mathbb{R}^{N \\times N}$ with a vertical edge at the center column. Specifically, for each row index $i \\in \\{0,\\dots,N-1\\}$ and column index $j \\in \\{0,\\dots,N-1\\}$,\n$$\nI[i,j] = \\begin{cases}\n0, & j < \\frac{N}{2},\\\\\n1, & j \\ge \\frac{N}{2}.\n\\end{cases}\n$$\n2. Compute the two-dimensional DFT of $I$ to obtain $F$. Design a circular brick-wall low-pass mask $H$ parameterized by a cutoff radius $r_c$ measured in integer frequency-bin radii after centering the zero-frequency component, that is, after a frequency shift so that the zero frequency is at the array center. The mask is defined by\n$$\nH[u,v] = \\begin{cases}\n1, & \\sqrt{u^2 + v^2} \\le r_c,\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\nwhere $u,v \\in \\{-\\frac{N}{2}, -\\frac{N}{2}+1,\\dots,\\frac{N}{2}-1\\}$ denote centered frequency-bin indices produced by the shift.\n3. Form the filtered spectrum $G = F \\cdot H$ (pointwise multiplication), then compute the inverse two-dimensional DFT to obtain the reconstructed image $\\widehat{I}$ in the spatial domain. Retain the real part of $\\widehat{I}$.\n4. Quantify ringing near the edge using the center row. Let $c_0 = \\frac{N}{2}$ be the center column index, and let $W$ be a small positive integer window half-width. Define the center-row profile $p[j] = \\widehat{I}\\!\\left[\\frac{N}{2}, j\\right]$ for $j \\in \\{0,\\dots,N-1\\}$. Compute:\n   - The peak overshoot above the bright-side asymptote,\n   $$\n   \\Delta^+ = \\max\\left(0, \\max_{j \\in \\{c_0,\\dots,\\min(N-1,c_0+W)\\}} \\big(p[j] - 1\\big)\\right).\n   $$\n   - The peak undershoot below the dark-side asymptote,\n   $$\n   \\Delta^- = \\max\\left(0, \\max_{j \\in \\{\\max(0,c_0-W),\\dots,c_0-1\\}} \\big(0 - p[j]\\big)\\right).\n   $$\n   - The mean-squared error (MSE) over the entire image,\n   $$\n   \\mathrm{MSE} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\big(\\widehat{I}[i,j] - I[i,j]\\big)^2.\n   $$\n5. For each test case, report the triple $\\left[\\Delta^+, \\Delta^-, \\mathrm{MSE}\\right]$, each rounded to $6$ decimal places.\n\nTest suite:\n- Use $N = 128$ and $W = 32$ for all cases. Evaluate the filter for cutoff radii (in centered frequency-bin units) $r_c \\in \\{0, 8, 16, 128\\}$. The case $r_c = 0$ passes only the zero-frequency component. The case $r_c = 128$ is large enough to pass all available frequency bins for $N = 128$.\n- Angles are not used in this problem. There are no physical units.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case contributes a list of three floats in the order $\\left[\\Delta^+, \\Delta^-, \\mathrm{MSE}\\right]$, rounded to $6$ decimals. For example, a valid format with two cases would be $[[0.000000,0.000000,0.250000],[0.012345,0.012345,0.123456]]$.\n- For this problem with four test cases, your program must output a single line in the exact aggregate list format $[\\,[\\Delta^+_1,\\Delta^-_1,\\mathrm{MSE}_1],\\,[\\Delta^+_2,\\Delta^-_2,\\mathrm{MSE}_2],\\,[\\Delta^+_3,\\Delta^-_3,\\mathrm{MSE}_3],\\,[\\Delta^+_4,\\Delta^-_4,\\mathrm{MSE}_4]\\,]$ with each float rounded to $6$ decimal places.", "solution": "The problem requires the design and evaluation of a two-dimensional ideal low-pass filter implemented using the Discrete Fourier Transform (DFT). The a priori validation confirms the problem is scientifically sound, well-posed, and objective. It constitutes a standard exercise in digital signal processing, exploring the consequences of the convolution theorem, specifically the manifestation of the Gibbs phenomenon (ringing artifacts) when applying a \"brick-wall\" filter in the frequency domain. We shall proceed with a step-by-step implementation and analysis.\n\nThe core principle is the duality between multiplication in the frequency domain and convolution in the spatial domain. Filtering an image $x[n,m]$ with a filter whose impulse response is $h[n,m]$ is a convolution operation: $y[n,m] = (x * h)[n,m]$. According to the convolution theorem, this is equivalent to pointwise multiplication of their respective DFTs: $Y[u,v] = X[u,v] \\cdot H[u,v]$, where $X = \\mathcal{F}\\{x\\}$ and $H = \\mathcal{F}\\{h\\}$. An ideal low-pass filter is defined by a sharp cutoff in the frequency domain, which corresponds to a filter mask $H[u,v]$ that is unity inside a certain frequency radius and zero outside.\n\nThe algorithm proceeds as follows:\n\n**Step 1: Construct the Synthetic Image**\nA synthetic test image $I \\in \\mathbb{R}^{N \\times N}$ is constructed to have a single, sharp vertical edge. This provides a strong, localized discontinuity, ideal for observing ringing artifacts. As specified, for $N=128$, the image is defined as:\n$$\nI[i,j] = \\begin{cases}\n0, & \\text{for } 0 \\le j < 64 \\\\\n1, & \\text{for } 64 \\le j < 128\n\\end{cases}\n$$\nThis is created for all rows $i \\in \\{0, \\dots, 127\\}$. The value of the image is constant along the vertical direction.\n\n**Step 2: Transformation to the Frequency Domain and Filter Design**\nFirst, the two-dimensional DFT of the image $I[i,j]$ is computed to obtain its frequency-domain representation, $F[u,v] = \\mathcal{F}\\{I\\}$.\n$$\nF[u,v] = \\sum_{n=0}^{N-1}\\sum_{m=0}^{N-1} I[n,m] \\, \\exp\\!\\left(-2\\pi i \\left(\\frac{un}{N} + \\frac{vm}{N}\\right)\\right)\n$$\nNext, a circular low-pass filter mask $H[u,v]$ is constructed. This mask is designed in a \"shifted\" frequency space, where the zero-frequency component $(u=0, v=0)$ is at the center of the $N \\times N$ grid. The centered frequency indices $u,v$ range from $-N/2$ to $N/2-1$. For each frequency coordinate $(u,v)$, the Euclidean distance from the origin is calculated as $d = \\sqrt{u^2 + v^2}$. The \"brick-wall\" mask $H$ is then defined based on a cutoff radius $r_c$:\n$$\nH[u,v] = \\begin{cases}\n1, & \\text{if } \\sqrt{u^2 + v^2} \\le r_c \\\\\n0, & \\text{if } \\sqrt{u^2 + v^2} > r_c\n\\end{cases}\n$$\nThis mask will be applied to the frequency spectrum of the image, also arranged in this centered configuration.\n\n**Step 3: Filtering and Inverse Transformation**\nThe filtering operation is a pointwise multiplication of the centered image spectrum, $F_{\\text{shifted}}$, with the filter mask $H$.\n$$\nG_{\\text{shifted}}[u,v] = F_{\\text{shifted}}[u,v] \\cdot H[u,v]\n$$\nTo correctly compute the inverse DFT, the resulting filtered spectrum $G_{\\text{shifted}}$ must be shifted back to the standard DFT layout where the zero-frequency component is at the origin (index $(0,0)$). Let this be $G$. The filtered image in the spatial domain, $\\widehat{I}[i,j]$, is then obtained by applying the inverse two-dimensional DFT to $G[u,v]$.\n$$\n\\widehat{I}_{\\text{complex}}[i,j] = \\mathcal{F}^{-1}\\{G\\} = \\frac{1}{N^2}\\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} G[u,v] \\, \\exp\\!\\left(2\\pi i \\left(\\frac{ui}{N} + \\frac{vj}{N}\\right)\\right)\n$$\nSince the original image $I$ is real-valued and the filter mask $H$ has conjugate symmetry ($H[u,v] = H[-u,-v]$), the filtered spectrum $G$ will also possess conjugate symmetry. Consequently, its inverse DFT, $\\widehat{I}_{\\text{complex}}$, should be purely real, up to numerical precision errors. We retain only the real part: $\\widehat{I}[i,j] = \\text{real}(\\widehat{I}_{\\text{complex}}[i,j])$.\n\n**Step 4: Quantification of Artifacts**\nThe Gibbs phenomenon manifests as oscillations, or \"ringing,\" near the discontinuity. We quantify this effect on the center row of the image, $p[j] = \\widehat{I}[N/2, j]$, where $N=128$. The edge is at column index $c_0 = N/2 = 64$.\n- The peak overshoot, $\\Delta^+$, measures the maximum value of the profile $p[j]$ above the high-level asymptote (which is $1$) on the bright side of the edge, within a window of half-width $W=32$.\n$$\n\\Delta^+ = \\max\\left(0, \\max_{j \\in \\{64,\\dots,96\\}} \\big(p[j] - 1\\big)\\right)\n$$\n- The peak undershoot, $\\Delta^-$, measures the maximum deviation of $p[j]$ below the low-level asymptote (which is $0$) on the dark side of the edge, within the window.\n$$\n\\Delta^- = \\max\\left(0, \\max_{j \\in \\{32,\\dots,63\\}} \\big(0 - p[j]\\big)\\right)\n$$\n- The overall reconstruction quality is measured by the Mean-Squared Error (MSE) between the filtered image $\\widehat{I}$ and the original image $I$.\n$$\n\\mathrm{MSE} = \\frac{1}{N^2} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\big(\\widehat{I}[i,j] - I[i,j]\\big)^2\n$$\n\n**Step 5: Execution for Test Cases**\nThe above procedure is executed for each specified cutoff radius $r_c \\in \\{0, 8, 16, 128\\}$, with $N=128$ and $W=32$. The resulting triplet $[\\Delta^+, \\Delta^-, \\mathrm{MSE}]$ for each $r_c$ is calculated and formatted.\n\n- For $r_c=0$, only the DC component ($u=0,v=0$) is passed. The reconstructed image $\\widehat{I}$ is uniform with a value equal to the average intensity of the original image, which is $0.5$. This results in $\\Delta^+=0$, $\\Delta^-=0$, and $\\mathrm{MSE}=0.25$.\n- For $r_c=128$, the radius is large enough to pass all frequency components of the $128 \\times 128$ grid. Thus, $H$ is an all-pass filter, and $\\widehat{I}$ should be nearly identical to $I$, resulting in minimal artifacts and error.\n- The intermediate cases $r_c=8$ and $r_c=16$ will exhibit the characteristic ringing artifacts.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 2D ideal low-pass filter and quantifies ringing artifacts.\n    \"\"\"\n    # Define the parameters from the problem statement.\n    N = 128\n    W = 32\n    test_rcs = [0, 8, 16, 128]\n    c0 = N // 2\n\n    # Step 1: Construct the synthetic binary step image I.\n    I = np.zeros((N, N), dtype=float)\n    I[:, c0:] = 1.0\n\n    # Step 2: Compute the 2D DFT of I.\n    F = np.fft.fft2(I)\n    \n    # Pre-calculate frequency grid for mask generation.\n    # The grid is created in the \"shifted\" or centered representation.\n    freqs_1d = np.fft.fftshift(np.fft.fftfreq(N) * N)\n    u, v = np.meshgrid(freqs_1d, freqs_1d, indexing='ij')\n    radius_grid = np.sqrt(u**2 + v**2)\n    \n    # Store the shifted spectrum of the image.\n    F_shifted = np.fft.fftshift(F)\n\n    results_data = []\n    \n    for r_c in test_rcs:\n        # Step 2 (cont.): Design the circular brick-wall low-pass mask H.\n        H = (radius_grid <= r_c).astype(float)\n\n        # Step 3: Form the filtered spectrum and compute the inverse DFT.\n        # Apply the mask via pointwise multiplication in the frequency domain.\n        G_shifted = F_shifted * H\n        \n        # Shift the filtered spectrum back to the standard DFT layout.\n        G = np.fft.ifftshift(G_shifted)\n        \n        # Compute the inverse 2D DFT.\n        I_hat_complex = np.fft.ifft2(G)\n        \n        # Retain the real part of the reconstructed image.\n        I_hat = np.real(I_hat_complex)\n\n        # Step 4: Quantify ringing artifacts and MSE.\n        # Extract the center-row profile.\n        p = I_hat[N // 2, :]\n\n        # Calculate peak overshoot (Delta+).\n        # Interval: j from c0 to c0+W. Slice is [c0:c0+W+1].\n        bright_region_slice = p[c0 : c0 + W + 1]\n        overshoot = np.max(bright_region_slice - 1.0)\n        delta_plus = max(0.0, overshoot)\n\n        # Calculate peak undershoot (Delta-).\n        # Interval: j from c0-W to c0-1. Slice is [c0-W:c0].\n        dark_region_slice = p[c0 - W : c0]\n        undershoot = np.max(0.0 - dark_region_slice)\n        delta_minus = max(0.0, undershoot)\n\n        # Calculate Mean-Squared Error (MSE).\n        mse = np.mean((I_hat - I)**2)\n        \n        # Store the triplet of results for this test case.\n        results_data.append([delta_plus, delta_minus, mse])\n\n    # Step 5: Format the final output string exactly as specified.\n    outer_parts = []\n    for res_triple in results_data:\n        inner_parts = [f\"{val:.6f}\" for val in res_triple]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output_string = f\"[{','.join(outer_parts)}]\"\n    \n    # The final print statement produces a single line in the required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "3222771"}]}