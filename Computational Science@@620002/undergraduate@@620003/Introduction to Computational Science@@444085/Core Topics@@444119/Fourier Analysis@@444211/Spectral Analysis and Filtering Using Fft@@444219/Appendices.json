{"hands_on_practices": [{"introduction": "The Fast Fourier Transform (FFT) is a powerful tool for representing signals as a sum of sinusoids, but this representation can have surprising behavior near sharp jumps. This exercise delves into the Gibbs phenomenon, where approximating a function with a truncated Fourier series leads to persistent overshoots at discontinuities. You will numerically investigate this effect for a square wave and then implement a spectral filter, demonstrating how targeted modifications in the frequency domain can significantly suppress these artifacts in the time domain [@problem_id:3282429].", "problem": "Consider the $2\\pi$-periodic function $f(\\theta)$ defined by $f(\\theta)=1$ for $0 \\le \\theta < \\pi$ and $f(\\theta)=-1$ for $\\pi \\le \\theta < 2\\pi$, extended periodically. The task is to analyze the Gibbs phenomenon using Fourier partial sums $S_N(\\theta)$ computed via the Fast Fourier Transform (FFT) algorithm, and to apply a spectral exponential filter to reduce overshoot near the discontinuity. Work entirely in radians.\n\nUse the following fundamental base and constraints:\n\n- The Fourier series of a $2\\pi$-periodic function $f(\\theta)$ is built from complex Fourier coefficients, and the truncated partial sum $S_N(\\theta)$ keeps modes with frequency index magnitude at most $N$.\n- The discrete Fourier transform (DFT) of sampled data provides a consistent numerical approximation to Fourier coefficients on an equispaced grid, and the Fast Fourier Transform (FFT) algorithm computes the DFT in $\\mathcal{O}(M \\log M)$ time for $M$ samples.\n- The spectral exponential filter is defined by multiplying each retained complex Fourier coefficient corresponding to frequency index $k$ (with $1 \\le |k| \\le N$) by the factor $\\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right)$, and leaving the zero mode unchanged. Use $\\alpha=36$ and $p=8$.\n\nImplement the following steps:\n\n1. Sample $f(\\theta)$ on a uniform grid of $M$ points with $M=4096$, at $\\theta_j = \\frac{2\\pi j}{M}$ for $j=0,1,2,\\dots,M-1$.\n2. Use the Fast Fourier Transform (FFT) to compute the discrete spectrum from the samples. Construct $S_N(\\theta)$ by zeroing out all DFT coefficients except those with indices corresponding to frequency magnitudes $\\le N$ (keep both positive and negative frequencies symmetrically, and include the zero-frequency mode). Reconstruct $S_N(\\theta)$ via the inverse transform on the same grid.\n3. Construct the filtered partial sum $S_N^{\\mathrm{filt}}(\\theta)$ by applying the exponential filter with parameters $\\alpha=36$ and $p=8$ to the retained coefficients before the inverse transform, leaving the zero-frequency mode unchanged.\n4. Quantify, for each $N$, both:\n   - The overshoot amplitude defined as $\\max_{\\theta} S_N(\\theta) - 1$, clipped below by $0$ to ensure the reported amplitude is nonnegative.\n   - The root-mean-square (RMS) error defined as $\\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S_N(\\theta_j) - f(\\theta_j)\\right)^2}$.\n   Perform the same two measurements for $S_N^{\\mathrm{filt}}(\\theta)$.\n5. Use the test suite $N \\in \\{0,1,8,32,128,512\\}$ and report, for each $N$ in the suite, the unfiltered overshoot amplitude, the filtered overshoot amplitude, the unfiltered RMS error, and the filtered RMS error.\n\nYour program should produce a single line of output containing a comma-separated list of five lists, with no spaces, in the exact order: the list of $N$ values, the list of unfiltered overshoot amplitudes, the list of filtered overshoot amplitudes, the list of unfiltered RMS errors, and the list of filtered RMS errors. For example, the required format is $[[N\\_list],[unfiltered\\_overshoots],[filtered\\_overshoots],[unfiltered\\_rms],[filtered\\_rms]]$, where each bracketed item is a list of numbers. All angles are in radians, and all reported numerical values are unitless floats.", "solution": "The problem requires a numerical investigation of the Gibbs phenomenon for a $2\\pi$-periodic square wave and its mitigation using a spectral exponential filter. The analysis is to be performed using the Fast Fourier Transform (FFT) algorithm to compute truncated Fourier series approximations.\n\nThe function under consideration is a $2\\pi$-periodic square wave defined on the interval $[0, 2\\pi)$ as:\n$$\nf(\\theta) = \\begin{cases}\n    1 & \\text{for } 0 \\le \\theta < \\pi \\\\\n    -1 & \\text{for } \\pi \\le \\theta < 2\\pi\n\\end{cases}\n$$\nThis function has jump discontinuities at $\\theta = n\\pi$ for any integer $n$. When approximated by a truncated Fourier series, these discontinuities lead to the Gibbs phenomenon, characterized by persistent overshoots near the jumps.\n\nThe core of the analysis relies on the discrete Fourier transform (DFT), computed efficiently by the FFT. The procedure is as follows:\n\nFirst, we discretize the domain $[0, 2\\pi)$. The function $f(\\theta)$ is sampled on a uniform grid of $M=4096$ points, given by $\\theta_j = \\frac{2\\pi j}{M}$ for $j=0, 1, \\dots, M-1$. This yields a vector of samples $f_j = f(\\theta_j)$. According to the function's definition, this results in $f_j = 1$ for $j=0, \\dots, M/2-1$ and $f_j = -1$ for $j=M/2, \\dots, M-1$.\n\nSecond, we compute the DFT of the sampled signal $\\{f_j\\}$ to obtain its spectrum $\\{\\hat{f}_k\\}$. The DFT is defined as $\\hat{f}_k = \\sum_{j=0}^{M-1} f_j \\exp(-i 2\\pi jk/M)$. The corresponding integer frequency modes (wavenumbers) $k$ are obtained for the output array of the FFT algorithm. For an input of length $M$, the frequencies correspond to the sequence $k = 0, 1, \\dots, M/2-1, -M/2, \\dots, -1$.\n\nThird, for each truncation parameter $N$ from the test suite $\\{0, 1, 8, 32, 128, 512\\}$, we construct two different approximations to $f(\\theta)$.\n\nThe unfiltered Fourier partial sum, $S_N(\\theta)$, is constructed from a truncated spectrum $\\hat{S}_{N}$. This spectrum is obtained by setting to zero all coefficients $\\hat{f}_k$ for which the absolute frequency index $|k|$ exceeds the truncation limit $N$:\n$$\n\\hat{S}_{N,k} = \\begin{cases}\n    \\hat{f}_k & \\text{if } |k| \\le N \\\\\n    0 & \\text{if } |k| > N\n\\end{cases}\n$$\nThe spatial representation $S_N(\\theta_j)$ is then recovered by applying the inverse DFT (IDFT) to the spectral coefficients $\\{\\hat{S}_{N,k}\\}$. The IDFT is given by $S_N(\\theta_j) = \\frac{1}{M} \\sum_{k=0}^{M-1} \\hat{S}_{N,k} \\exp(i 2\\pi jk/M)$.\n\nThe filtered partial sum, $S_N^{\\mathrm{filt}}(\\theta)$, is constructed to reduce the Gibbs oscillations. This is achieved by applying a spectral filter to the truncated spectrum before the inverse transform. The filtered spectrum, $\\hat{S}_{N,k}^{\\mathrm{filt}}$, is defined by multiplying the retained coefficients by a filter factor $\\sigma_k$:\n$$\n\\hat{S}_{N,k}^{\\mathrm{filt}} = \\sigma_k \\hat{S}_{N,k} \\quad \\text{where} \\quad \\sigma_k = \\begin{cases}\n    1 & \\text{if } k=0 \\\\\n    \\exp\\!\\left(-\\alpha \\left(\\frac{|k|}{N}\\right)^{p}\\right) & \\text{if } 1 \\le |k| \\le N \\\\\n    1 & \\text{if } |k| > N \\text{ (but } \\hat{S}_{N,k}=0 \\text{ anyway)}\n\\end{cases}\n$$\nThe filter parameters are given as $\\alpha=36$ and $p=8$. The spatial representation $S_N^{\\mathrm{filt}}(\\theta_j)$ is then recovered by applying the IDFT to $\\{\\hat{S}_{N,k}^{\\mathrm{filt}}\\}$. For the special case $N=0$, the filtering condition $1 \\le |k| \\le N$ is never met, so no modes are modified by the filter factor.\n\nFourth, we quantify the performance of both approximations. Two metrics are computed for each value of $N$:\n1. The overshoot amplitude, defined as the maximum value of the reconstructed signal minus the true maximum of the function ($1$), clipped below at zero to ensure a non-negative result:\n   $$ \\text{Overshoot} = \\max\\left(0, \\left(\\max_j S(\\theta_j)\\right) - 1\\right) $$\n2. The root-mean-square (RMS) error, which measures the average deviation from the true function across the grid:\n   $$ \\text{RMS Error} = \\sqrt{\\frac{1}{M}\\sum_{j=0}^{M-1} \\left(S(\\theta_j) - f(\\theta_j)\\right)^2} $$\nThese two metrics are calculated for both the unfiltered sum $S_N(\\theta_j)$ and the filtered sum $S_N^{\\mathrm{filt}}(\\theta_j)$.\n\nThe algorithm proceeds by iterating through the specified values of $N$, performing these calculations, and collecting the results for the final formatted output. The data will demonstrate that while the unfiltered sum exhibits a significant and persistent overshoot (the Gibbs phenomenon), the spectral filter effectively suppresses these oscillations, leading to a much smaller overshoot amplitude. This improvement in reducing local error, however, may come at the cost of a slight increase in global error, as measured by the RMS value.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes unfiltered and filtered Fourier partial sums for a square wave\n    to analyze the Gibbs phenomenon and the effect of a spectral filter.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    M = 4096\n    alpha = 36\n    p = 8\n    test_cases = [0, 1, 8, 32, 128, 512] # These are the values for N\n\n    # --- Main Logic ---\n\n    # Step 1: Sample the function f(theta)\n    # The function is f(theta) = 1 for 0 <= theta < pi and f(theta) = -1 for pi <= theta < 2pi.\n    # On a grid of M points theta_j = 2*pi*j/M, this corresponds to\n    # f_j = 1 for j=0..M/2-1 and f_j = -1 for j=M/2..M-1.\n    f_samples = np.ones(M)\n    f_samples[M // 2:] = -1.0\n\n    # Step 2: Compute the DFT of the sampled signal\n    f_hat = np.fft.fft(f_samples)\n    # Get the corresponding integer frequency modes k for the DFT output array.\n    # np.fft.fftfreq(M) * M gives [0, 1, ..., M/2-1, -M/2, ..., -1]\n    k_freqs = np.fft.fftfreq(M) * M\n\n    # Store results for each N\n    results_unfiltered_overshoot = []\n    results_filtered_overshoot = []\n    results_unfiltered_rms = []\n    results_filtered_rms = []\n\n    for N in test_cases:\n        # Construct unfiltered partial sum S_N by truncating the spectrum\n        S_N_hat = f_hat.copy()\n        # Zero out coefficients for frequencies with magnitude > N\n        S_N_hat[np.abs(k_freqs) > N] = 0.0\n        \n        # Reconstruct S_N via inverse FFT\n        # The result should be real-valued; .real discards negligible imaginary parts from numerical error.\n        S_N = np.fft.ifft(S_N_hat).real\n\n        # Construct filtered partial sum S_N_filt\n        S_N_filt_hat = S_N_hat.copy() # Start with the same truncated spectrum\n        if N > 0:\n            # Create a mask for modes to be filtered (1 <= |k| <= N)\n            filter_mask = (np.abs(k_freqs) > 0) & (np.abs(k_freqs) <= N)\n            \n            # Get the k values of the modes to be filtered\n            k_vals_to_filter = np.abs(k_freqs[filter_mask])\n            \n            # Calculate the exponential filter factors\n            sigma_k = np.exp(-alpha * (k_vals_to_filter / N)**p)\n            \n            # Apply the filter by element-wise multiplication\n            S_N_filt_hat[filter_mask] *= sigma_k\n        \n        # Reconstruct S_N_filt via inverse FFT\n        S_N_filt = np.fft.ifft(S_N_filt_hat).real\n\n        # Quantify overshoot and RMS error for both cases\n        # For S_N (unfiltered)\n        overshoot_unfiltered = np.maximum(0.0, np.max(S_N) - 1.0)\n        rms_unfiltered = np.sqrt(np.mean((S_N - f_samples)**2))\n        \n        # For S_N_filt (filtered)\n        overshoot_filtered = np.maximum(0.0, np.max(S_N_filt) - 1.0)\n        rms_filtered = np.sqrt(np.mean((S_N_filt - f_samples)**2))\n\n        # Append results to lists\n        results_unfiltered_overshoot.append(overshoot_unfiltered)\n        results_filtered_overshoot.append(overshoot_filtered)\n        results_unfiltered_rms.append(rms_unfiltered)\n        results_filtered_rms.append(rms_filtered)\n\n    # Final print statement in the exact required format.\n    all_results = [\n        test_cases,\n        results_unfiltered_overshoot,\n        results_filtered_overshoot,\n        results_unfiltered_rms,\n        results_filtered_rms\n    ]\n    \n    # Convert each inner list of numbers into a comma-separated string, enclosed in brackets.\n    stringified_lists = [f\"[{','.join(map(str, lst))}]\" for lst in all_results]\n    \n    # Join these stringified lists into the final output format: [[list1],[list2],...]\n    print(f\"[{','.join(stringified_lists)}]\")\n\nsolve()\n```", "id": "3282429"}, {"introduction": "In many practical applications, from audio processing to telecommunications, it is necessary to reduce a signal's sampling rate to save storage or bandwidth, a process known as downsampling. This practice explores the critical role of anti-aliasing filters in this process, grounded in the Nyquist-Shannon sampling theorem. By implementing a low-pass filter in the frequency domain, you will learn to quantitatively verify whether a signal is safe to downsample without introducing aliasing distortion, a fundamental skill in digital signal processing [@problem_id:3195872].", "problem": "You are given a one-dimensional, real-valued discrete-time signal sampled at sampling frequency $F_{s}$ in hertz (Hz). The signal has $N$ samples taken uniformly in time with sampling interval $\\Delta t = 1 / F_{s}$ seconds, and its time samples are $x[n]$ for $n \\in \\{0,1,\\dots,N-1\\}$. The Discrete Fourier Transform (DFT) of $x[n]$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j 2\\pi nk/N},\n$$\nwith discrete frequency bin $f_{k} = k \\, F_{s}/N$ for $k \\in \\{0,1,\\dots,N-1\\}$, and the Fast Fourier Transform (FFT) is an efficient algorithm to compute the DFT. The Nyquist-Shannon sampling theorem states that for a sampling frequency $F_{s}$, the Nyquist frequency is $F_{s}/2$.\n\nThe task is to combine frequency-domain filtering using the Fast Fourier Transform (FFT) with downsampling (decimation). Specifically, you must:\n- Apply an ideal low-pass filter implemented in the frequency domain that zeroes out all spectral components with $|f| > F_{s}/4$.\n- Downsample the filtered time-domain signal by a factor of $4$ (i.e., keep every fourth sample) to obtain a new signal with sampling frequency $F_{s}' = F_{s}/4$.\n- Verify, using the spectrum of the filtered signal before downsampling, that the spectral content that remains after filtering lies entirely within the new Nyquist band $|f| \\leq F_{s}'/2 = F_{s}/8$. The verification must be based on a quantitative criterion:\n  - Compute the ratio $R$ defined as\n    $$\n    R = \\frac{\\sum_{k \\, : \\, |f_{k}| > F_{s}/8} |X_{\\text{filt}}[k]|}{\\sum_{k=0}^{N-1} |X_{\\text{filt}}[k]|},\n    $$\n    where $X_{\\text{filt}}[k]$ is the DFT of the filtered signal. Declare the verification boolean as $\\text{True}$ if $R \\leq 10^{-6}$ and $\\text{False}$ otherwise. This criterion ensures that any residual energy outside the new Nyquist band is negligible. The ratio $R$ is dimensionless.\n\nUse radians for all angle computations. All frequencies must be specified in hertz (Hz). Assume zero phase for all sinusoidal components.\n\nImplement the above using the following test suite of signals, all sampled with $F_{s} = 1024$ Hz and $N = 2048$ samples:\n- Test case $1$ (happy path): A sum of sinusoids with frequencies $50$ Hz and $100$ Hz and amplitudes $1.0$ and $0.5$ respectively. This case has content strictly below $F_{s}/8 = 128$ Hz.\n- Test case $2$ (failure case): A single sinusoid at $200$ Hz with amplitude $1.0$. This content lies between $F_{s}/8 = 128$ Hz and $F_{s}/4 = 256$ Hz and will pass the filter but should not satisfy the verification criterion.\n- Test case $3$ (boundary case): A single sinusoid at exactly $F_{s}/8 = 128$ Hz with amplitude $1.0$. Treat $|f| \\leq F_{s}/8$ as acceptable; this case should satisfy the verification criterion.\n- Test case $4$ (mixed content): A sum of sinusoids at $60$ Hz, $140$ Hz, and $220$ Hz, all with amplitude $0.8$. Only the $60$ Hz component is strictly below $F_{s}/8$; the others will pass the $F_{s}/4$ filter and should cause the verification to fail.\n\nYour program must:\n- Construct the specified signals $x[n] = \\sum_{m} A_{m} \\sin(2\\pi f_{m} n / F_{s})$ for each test case, where $A_{m}$ are the amplitudes and $f_{m}$ are the frequencies.\n- Compute the FFT, apply the ideal frequency-domain low-pass filter with cutoff at $F_{s}/4$, invert the FFT back to the time domain, and then decimate by $4$.\n- Compute the verification ratio $R$ from the filtered spectrum $X_{\\text{filt}}[k]$ and return the boolean described above for each test case.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[$\\text{result1}$,$\\text{result2}$,$\\text{result3}$,$\\text{result4}$]\"), where each result is the boolean $\\text{True}$ or $\\text{False}$ corresponding to the verification for the respective test case.", "solution": "The user-provided problem is assessed as **valid**. It is scientifically sound, well-posed, and all necessary information is provided for a unique solution.\n\n### Introduction to the Physical Principles\n\nThis problem explores a fundamental concept in digital signal processing (DSP): **decimation**, or downsampling, and its relationship with the **Nyquist-Shannon sampling theorem**. When a discrete-time signal $x[n]$ sampled at a frequency $F_s$ is downsampled by an integer factor $M$, the new sampling rate becomes $F_s' = F_s/M$. According to the sampling theorem, to avoid **aliasing**—the misrepresentation of high frequencies as lower frequencies—the signal must be free of any frequency content above the new Nyquist frequency, which is $F_s'/2 = F_s/(2M)$.\n\nTherefore, a critical prerequisite for decimation is the application of an **anti-aliasing filter**, which is a low-pass filter designed to remove all frequencies $|f| > F_s/(2M)$ before the downsampling operation takes place.\n\nThis problem sets up a scenario to test this principle. A signal is to be downsampled by a factor of $M=4$. The required anti-aliasing filter should thus have a cutoff frequency of $F_s/(2 \\times 4) = F_s/8$. However, the problem specifies the use of an ideal low-pass filter with a higher cutoff frequency of $F_s/4$. This filter is insufficient to guarantee protection against aliasing. The task is to *verify* whether the signal's content, *after* passing through this suboptimal filter, happens to lie within the acceptable band for aliasing-free decimation, i.e., $|f| \\leq F_s/8$.\n\nA minor ambiguity exists in the problem statement, which specifies \"zero phase\" but provides the signal generation formula using $\\sin(x)$, which corresponds to a phase of $-\\pi/2$ relative to $\\cos(x)$. This is a negligible inconsistency, as the provided formula $x[n] = \\sum_{m} A_{m} \\sin(2\\pi f_{m} n / F_{s})$ is explicit and takes precedence. Furthermore, the analysis relies solely on the magnitude spectrum $|X[k]|$, which is unaffected by this constant phase shift.\n\n### Algorithmic Solution\n\nThe solution proceeds by implementing the specified signal processing chain and verification test for a suite of four test cases. The common parameters are a sampling frequency of $F_s = 1024$ Hz and a signal length of $N = 2048$ samples.\n\n1.  **Signal Generation**: For each test case, the discrete-time signal $x[n]$ for $n \\in \\{0, 1, \\dots, N-1\\}$ is synthesized according to the formula:\n    $$\n    x[n] = \\sum_{m} A_{m} \\sin(2\\pi f_{m} n / F_{s})\n    $$\n    where $\\{A_m, f_m\\}$ are the given amplitudes and frequencies.\n\n2.  **Spectral Analysis (FFT)**: The Discrete Fourier Transform (DFT) of the signal, $X[k]$, is computed using the Fast Fourier Transform (FFT) algorithm. This transforms the signal into the frequency domain. The corresponding frequency for each bin $k$ is given by $f_k$. These frequencies are arranged such that they represent both positive and negative spectral components, typically handled by a function like `numpy.fft.fftfreq`.\n\n3.  **Frequency-Domain Filtering**: An ideal low-pass filter is applied directly in the frequency domain. This is achieved by creating a spectral mask that is zero for all frequencies $|f_k|$ that exceed the filter's cutoff frequency, $F_{c} = F_s/4 = 256$ Hz, and one otherwise. The filtered spectrum, $X_{\\text{filt}}[k]$, is obtained by element-wise multiplication of the original spectrum $X[k]$ with this mask:\n    $$\n    X_{\\text{filt}}[k] = \\begin{cases} X[k] & \\text{if } |f_k| \\leq F_s/4 \\\\ 0 & \\text{if } |f_k| > F_s/4 \\end{cases}\n    $$\n\n4.  **Spectral Verification**: The core of the problem is to verify if the filtered signal is suitable for downsampling by a factor of $M=4$. This requires its spectral content to be confined within the new Nyquist band, $|f| \\leq F_s' / 2 = F_s/8 = 128$ Hz. The verification is performed by calculating the ratio $R$:\n    $$\n    R = \\frac{\\sum_{k \\, : \\, |f_{k}| > F_{s}/8} |X_{\\text{filt}}[k]|}{\\sum_{k=0}^{N-1} |X_{\\text{filt}}[k]|}\n    $$\n    This ratio measures the proportion of the filtered signal's spectral magnitude that lies outside the target band ($|f| > 128$ Hz).\n\n5.  **Decision**: The verification is declared successful ($\\text{True}$) if $R$ is smaller than or equal to a numerical tolerance of $10^{-6}$, indicating that any out-of-band energy is negligible. Otherwise, it is declared a failure ($\\text{False}$). Note that the problem's conceptual steps include an inverse FFT and decimation, but these are not required for computing the value of $R$, which is derived entirely from the filtered spectrum $X_{\\text{filt}}[k]$.\n\n### Analysis of Test Cases\n\n-   **Test Case 1 (Happy Path)**: Frequencies are $50$ Hz and $100$ Hz. Both are less than the verification cutoff of $128$ Hz and the filter cutoff of $256$ Hz. The filter passes these components, and since they are within the target band, the numerator of $R$ will be approximately zero (barring numerical precision errors). The verification is expected to pass ($\\text{True}$).\n\n-   **Test Case 2 (Failure Case)**: Frequency is $200$ Hz. This is greater than $128$ Hz but less than $256$ Hz. The component will pass through the filter. However, it lies outside the target verification band. The numerator of $R$ will contain the magnitude of this component, making $R$ significant (close to $1$). The verification is expected to fail ($\\text{False}$).\n\n-   **Test Case 3 (Boundary Case)**: Frequency is exactly $128$ Hz. This is equal to the verification cutoff $F_s/8$ and less than the filter cutoff $F_s/4$. The component passes the filter. The verification condition for the numerator is a strict inequality, $|f_k| > 128$ Hz. Since the signal energy is at exactly $128$ Hz, it is not included in the numerator sum. Thus, $R$ will be near zero. The verification is expected to pass ($\\text{True}$).\n\n-   **Test Case 4 (Mixed Content)**: Frequencies are $60$ Hz, $140$ Hz, and $220$ Hz. All are below the filter cutoff of $256$ Hz and will be present in $X_{\\text{filt}}[k]$. For the verification, the $60$ Hz component is inside the target band ($|f| \\leq 128$ Hz), but the $140$ Hz and $220$ Hz components are outside. These out-of-band components will contribute to the numerator of $R$, making it a substantial fraction of the total magnitude (approximately $2/3$). The verification is expected to fail ($\\text{False}$).\n\nThe implementation will follow this logic for each case to produce the final boolean results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs frequency-domain filtering and spectral verification for a set of test signals.\n    \"\"\"\n    # Define the global parameters from the problem statement.\n    Fs = 1024.0  # Sampling frequency in Hz\n    N = 2048     # Number of samples\n\n    # Define the test cases. Each case is a list of tuples, where each tuple\n    # contains the amplitude (A_m) and frequency (f_m) of a sinusoidal component.\n    test_cases_params = [\n        # Test case 1 (happy path): Content below Fs/8\n        [(1.0, 50.0), (0.5, 100.0)],\n        # Test case 2 (failure case): Content between Fs/8 and Fs/4\n        [(1.0, 200.0)],\n        # Test case 3 (boundary case): Content at exactly Fs/8\n        [(1.0, 128.0)],\n        # Test case 4 (mixed content): Components both inside and outside the Fs/8 band\n        [(0.8, 60.0), (0.8, 140.0), (0.8, 220.0)]\n    ]\n\n    results = []\n\n    # Pre-calculate constants and arrays used in the loop.\n    n = np.arange(N)\n    freqs = np.fft.fftfreq(N, d=1/Fs)\n    \n    filter_cutoff = Fs / 4.0\n    verification_cutoff = Fs / 8.0\n    verification_threshold = 1e-6\n\n    # Process each test case.\n    for params in test_cases_params:\n        # 1. Construct the signal x[n]\n        x = np.zeros(N, dtype=np.float64)\n        for A, f in params:\n            x += A * np.sin(2 * np.pi * f * n / Fs)\n\n        # 2. Compute the FFT of the signal.\n        X = np.fft.fft(x)\n\n        # 3. Apply the ideal low-pass filter in the frequency domain.\n        # Create a copy to store the filtered spectrum.\n        X_filt = X.copy()\n        # Create a boolean mask for frequencies to be zeroed out.\n        filter_mask = np.abs(freqs) > filter_cutoff\n        # Apply the filter by setting the corresponding spectral components to zero.\n        X_filt[filter_mask] = 0.0\n\n        # 4. Perform the verification step.\n        # This step checks if the filtered signal is suitable for downsampling by 4.\n        \n        # Calculate the sum of magnitudes of components outside the new Nyquist band (|f| > Fs/8).\n        indices_outside = np.abs(freqs) > verification_cutoff\n        sum_outside = np.sum(np.abs(X_filt[indices_outside]))\n\n        # Calculate the total sum of magnitudes of all components in the filtered signal.\n        sum_total = np.sum(np.abs(X_filt))\n\n        # Calculate the ratio R. Handle the case of a zero-energy signal.\n        if sum_total == 0.0:\n            R = 0.0\n        else:\n            R = sum_outside / sum_total\n\n        # 5. Compare R to the threshold to get the boolean result.\n        verification_passed = (R <= verification_threshold)\n        results.append(verification_passed)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean True/False to strings 'True'/'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3195872"}, {"introduction": "Real-world datasets are often incomplete, containing gaps from sensor failures or packet loss. This advanced practice moves beyond simple filtering to signal reconstruction, tackling the problem of \"inpainting\" these missing samples. You will implement an iterative algorithm that leverages a powerful assumption: that the signal is sparse in the frequency domain (i.e., composed of a few dominant sinusoids). This hands-on problem demonstrates how the FFT can be used not just for analysis, but as a core component in solving modern inverse problems inspired by the field of compressed sensing [@problem_id:3195883].", "problem": "You are given the task of analyzing the spectral effects of missing samples in a discrete-time signal, and then mitigating these effects using an inpainting method based on the Fast Fourier Transform (FFT). Work entirely in the discrete-time domain and express all steps using well-defined mathematical constructs. Use the Discrete Fourier Transform (DFT) definition as your fundamental base.\n\nStart from the fundamental definition of the Discrete Fourier Transform (DFT): for a signal $x[n]$ of length $N$, the DFT is\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}, \\quad k = 0,1,\\dots,N-1.\n$$\nLet $m[n]$ be a binary sampling mask taking values in $\\{0,1\\}$, where $m[n]=1$ indicates an observed sample and $m[n]=0$ indicates a missing sample. The observed signal is $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$. The convolution property of the DFT implies that multiplication in the time domain corresponds to circular convolution in the frequency domain: if $M[k]$ is the DFT of $m[n]$, then the spectrum of $x_{\\mathrm{mask}}[n]$ is $X_{\\mathrm{mask}}[k] = (X * M)[k]$, which redistributes energy across frequencies, potentially creating spectral artifacts.\n\nDesign and implement a program that, for each test case specified below, performs the following steps:\n\n1. Construct a synthetic real-valued signal $x[n]$ of length $N$ as a sum of cosines with integer-bin frequencies:\n   $$\n   x[n] = \\sum_{i=1}^{K} A_i \\cos\\!\\left( \\frac{2\\pi f_i n}{N} \\right), \\quad n = 0,1,\\dots,N-1,\n   $$\n   where $K$ is the number of tones, $A_i$ are the amplitudes, and $f_i$ are distinct integer frequency bins with $0 < f_i < \\frac{N}{2}$.\n\n2. Randomly select a fraction $p_{\\mathrm{miss}}$ of indices to set as missing ($m[n]=0$), using a specified random seed for reproducibility. Form $x_{\\mathrm{mask}}[n]$ by zero-filling the missing samples, i.e., $x_{\\mathrm{mask}}[n] = x[n]$ if $m[n]=1$, and $x_{\\mathrm{mask}}[n]=0$ if $m[n]=0$.\n\n3. Compute the DFT $X_{\\mathrm{mask}}[k]$ of $x_{\\mathrm{mask}}[n]$ using the Fast Fourier Transform (FFT). Define the true spectral support $\\mathcal{S}$ as the set of bins corresponding to the known tone frequencies and their symmetric counterparts for a real signal:\n   $$\n   \\mathcal{S} = \\{ f_1, f_2, \\dots, f_K \\} \\cup \\{ (-f_1) \\bmod N, \\dots, (-f_K) \\bmod N \\}.\n   $$\n   Compute the artifact energy ratio before inpainting as\n   $$\n   r_{\\mathrm{zero}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{mask}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{mask}}[k]|^2},\n   $$\n   with the convention that the ratio is $0$ if the denominator is $0$.\n\n4. Perform spectral inpainting via iterative FFT thresholding:\n   - Initialize $y^{(0)}[n] = x_{\\mathrm{mask}}[n]$.\n   - At each iteration $t = 0,1,2,\\dots$:\n     - Compute $Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$.\n     - Hard-threshold in the frequency domain by keeping the $K_{\\mathrm{keep}}$ largest-magnitude coefficients and zeroing the rest, producing $\\tilde{Y}^{(t)}[k]$.\n     - Compute the inverse DFT $\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$, take the real part, and enforce data consistency on observed samples:\n       $$\n       y^{(t+1)}[n] = \\begin{cases}\n       x[n] & \\text{if } m[n]=1, \\\\\n       \\tilde{y}^{(t)}[n] & \\text{if } m[n]=0.\n       \\end{cases}\n       $$\n     - Stop when the relative change $\\frac{\\|y^{(t+1)} - y^{(t)}\\|_2}{\\|y^{(t)}\\|_2}$ is less than the tolerance $\\varepsilon$, or when the maximum number of iterations $T_{\\max}$ is reached.\n\n5. Compute the DFT $X_{\\mathrm{rec}}[k]$ of the final inpainted signal $y^{(\\ast)}[n]$ and the corresponding artifact energy ratio\n   $$\n   r_{\\mathrm{inpaint}} = \\frac{\\sum_{k \\notin \\mathcal{S}} |X_{\\mathrm{rec}}[k]|^2}{\\sum_{k=0}^{N-1} |X_{\\mathrm{rec}}[k]|^2},\n   $$\n   with the same convention as above. Also compute the normalized reconstruction error\n   $$\n   e = \\frac{\\|y^{(\\ast)} - x\\|_2}{\\|x\\|_2}.\n   $$\n\nYour implementation must use the test suite specified below. For each test case, return a list of three floats $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$ rounded to $6$ decimal places. The final program output must be a single line containing the results for all test cases as a comma-separated list enclosed in square brackets, where each element is itself the three-float list for the corresponding test case, for example, $[[a_1,b_1,c_1],[a_2,b_2,c_2]]$.\n\nTest Suite:\n- Case $1$ (Happy path): $N=1024$, $K=3$, frequencies $[50, 123, 300]$, amplitudes $[1.0, 0.8, 0.6]$, missing fraction $p_{\\mathrm{miss}}=0.2$, $K_{\\mathrm{keep}}=6$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=200$, random seed $1$.\n- Case $2$ (Boundary, no missing samples): $N=1024$, $K=3$, frequencies $[50, 123, 300]$, amplitudes $[1.0, 0.8, 0.6]$, missing fraction $p_{\\mathrm{miss}}=0.0$, $K_{\\mathrm{keep}}=6$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=200$, random seed $2$.\n- Case $3$ (Edge, heavy missing): $N=2048$, $K=5$, frequencies $[15, 77, 221, 400, 650]$, amplitudes $[1.0, 0.5, 0.7, 0.9, 0.4]$, missing fraction $p_{\\mathrm{miss}}=0.5$, $K_{\\mathrm{keep}}=10$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=300$, random seed $3$.\n- Case $4$ (Edge, single tone and severe missing): $N=512$, $K=1$, frequency $[64]$, amplitude $[1.0]$, missing fraction $p_{\\mathrm{miss}}=0.7$, $K_{\\mathrm{keep}}=2$, tolerance $\\varepsilon=10^{-8}$, maximum iterations $T_{\\max}=300$, random seed $42$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is the list $[r_{\\mathrm{zero}}, r_{\\mathrm{inpaint}}, e]$ for one test case, with each float rounded to $6$ decimal places, for example:\n$[[0.123456,0.000789,0.012345],[\\dots],[\\dots],[\\dots]]$.", "solution": "The user-provided problem statement has been meticulously validated and is determined to be sound, well-posed, and scientifically grounded. It presents a clear task in computational signal processing, specifically the recovery of a sparse signal from incomplete measurements using an iterative spectral method. All parameters, definitions, and procedures are specified with sufficient rigor to permit a unique and verifiable solution.\n\nThe solution proceeds by implementing the described algorithm. The core of the problem lies in recognizing that a signal composed of a few sinusoids has a sparse representation in the frequency domain. The Discrete Fourier Transform (DFT), efficiently computed via the Fast Fourier Transform (FFT), is the tool to move between the time and frequency domains.\n\nThe initial signal, $x[n]$, is constructed as a sum of $K$ cosine functions whose frequencies $f_i$ are integer multiples of the fundamental frequency $1/N$. This ensures that the signal's energy in the frequency domain is concentrated perfectly at the DFT bins corresponding to $\\pm f_i$. The DFT of this real-valued signal, $X[k]$, will have $2K$ non-zero coefficients due to the conjugate symmetry property $X[k] = X[N-k]^*$. The set of these non-zero frequency bins is denoted by $\\mathcal{S}$.\n\nWhen samples are missing, which is modeled by multiplying the signal $x[n]$ with a binary mask $m[n]$, the resulting signal is $x_{\\mathrm{mask}}[n] = x[n] \\cdot m[n]$. According to the convolution theorem of the DFT, this multiplication in the time domain corresponds to a circular convolution in the frequency domain: $X_{\\mathrm{mask}}[k] = (X * M)[k]$, where $M[k]$ is the DFT of the mask. The spectrum of the mask, $M[k]$, is generally not sparse and has significant energy across all frequencies. The convolution spreads the sparse energy of $X[k]$ across the entire spectrum, creating artifacts. The initial artifact energy ratio, $r_{\\mathrm{zero}}$, quantifies this spectral leakage.\n\nThe core of the solution is the iterative inpainting algorithm, a variant of Iterative Hard Thresholding (IHT). This algorithm leverages the prior knowledge that the original signal is sparse in the frequency domain. The procedure is as follows:\n\n1.  **Initialization**: The algorithm starts with the zero-filled signal, $y^{(0)}[n] = x_{\\mathrm{mask}}[n]$.\n\n2.  **Iteration**: For each step $t$:\n    a.  **Transform to Frequency Domain**: Compute the DFT of the current estimate, $Y^{(t)}[k] = \\mathrm{FFT}(y^{(t)}[n])$. At this stage, $Y^{(t)}[k]$ will generally not be sparse due to the missing data.\n    b.  **Hard Thresholding**: The algorithm enforces the sparsity assumption by keeping only the $K_{\\mathrm{keep}}$ coefficients with the largest magnitudes and setting all others to zero. $K_{\\mathrm{keep}}$ is set to $2K$, the known number of non-zero spectral components in the original signal. This step, $\\tilde{Y}^{(t)}[k] = \\mathrm{Threshold}(Y^{(t)}[k])$, is a projection onto the set of sparse signals in the frequency domain.\n    c.  **Return to Time Domain**: An inverse FFT is applied to the thresholded spectrum, $\\tilde{y}^{(t)}[n] = \\mathrm{IFFT}(\\tilde{Y}^{(t)}[k])$. Since numerical errors might introduce a small imaginary part, we take the real part of the result.\n    d.  **Enforce Data Consistency**: This is a critical step. The solution must be consistent with the known measurements. The values of the next iterate, $y^{(t+1)}[n]$, are updated by re-inserting the original known samples from $x[n]$ where the mask $m[n]$ is $1$. For the missing samples (where $m[n]=0$), we use the values from our sparse estimate $\\tilde{y}^{(t)}[n]$.\n        $$\n        y^{(t+1)}[n] = m[n] \\cdot x[n] + (1 - m[n]) \\cdot \\tilde{y}^{(t)}[n]\n        $$\n\n3.  **Termination**: The process is repeated until the solution stabilizes, measured by the relative change between successive iterates falling below a tolerance $\\varepsilon = 10^{-8}$, or until a maximum number of iterations $T_{\\max}$ is reached.\n\nFinally, the quality of the reconstruction is assessed. The artifact energy ratio after inpainting, $r_{\\mathrm{inpaint}}$, measures how successfully the algorithm has concentrated the spectral energy back into the true support set $\\mathcal{S}$. The normalized reconstruction error, $e$, measures the Euclidean distance between the reconstructed signal $y^{(\\ast)}[n]$ and the original signal $x[n]$, providing a direct measure of time-domain accuracy. The implementation uses `NumPy` for efficient array operations, FFT computations, and linear algebra norms.", "answer": "```python\nimport numpy as np\n\ndef run_case(N, K, freqs, amps, p_miss, K_keep, epsilon, T_max, seed):\n    \"\"\"\n    Runs a single test case for spectral inpainting.\n    \"\"\"\n    # Step 1: Construct the synthetic signal x[n]\n    n_space = np.arange(N)\n    x = np.zeros(N, dtype=np.float64)\n    for i in range(K):\n        x += amps[i] * np.cos(2 * np.pi * freqs[i] * n_space / N)\n\n    # Step 2: Create the masked signal x_mask[n]\n    rng = np.random.default_rng(seed)\n    num_missing = int(np.round(p_miss * N))\n    if num_missing > 0:\n        missing_indices = rng.choice(N, size=num_missing, replace=False)\n    else:\n        missing_indices = np.array([], dtype=int)\n        \n    m = np.ones(N)\n    m[missing_indices] = 0\n    x_mask = x * m\n\n    # Step 3: Compute artifact energy ratio before inpainting (r_zero)\n    X_mask = np.fft.fft(x_mask)\n    \n    # Define the true spectral support S\n    S = set(freqs) | set((N - f) % N for f in freqs)\n    \n    is_in_S = np.zeros(N, dtype=bool)\n    is_in_S[list(S)] = True\n    \n    total_energy_mask = np.sum(np.abs(X_mask)**2)\n    if total_energy_mask == 0:\n        r_zero = 0.0\n    else:\n        artifact_energy_mask = np.sum(np.abs(X_mask[~is_in_S])**2)\n        r_zero = artifact_energy_mask / total_energy_mask\n\n    # Step 4: Perform spectral inpainting via iterative FFT thresholding\n    y_current = x_mask.copy()\n    y_rec = y_current\n    \n    for _ in range(T_max):\n        Y_current = np.fft.fft(y_current)\n        \n        # Hard-threshold in the frequency domain\n        largest_indices = np.argsort(np.abs(Y_current))[-K_keep:]\n        Y_tilde = np.zeros_like(Y_current, dtype=complex)\n        Y_tilde[largest_indices] = Y_current[largest_indices]\n        \n        # Inverse transform and take real part\n        y_tilde_real = np.real(np.fft.ifft(Y_tilde))\n        \n        # Create next iterate\n        y_next = y_tilde_real.copy()\n        # Enforce data consistency on observed samples\n        y_next[m == 1] = x[m == 1]\n        \n        # Check for convergence\n        norm_y_current = np.linalg.norm(y_current)\n        if norm_y_current > 0:\n            relative_change = np.linalg.norm(y_next - y_current) / norm_y_current\n            if relative_change < epsilon:\n                y_rec = y_next\n                break\n        elif np.linalg.norm(y_next) == 0: # y_current is zero, check if y_next is also zero\n            y_rec = y_next\n            break\n        \n        y_current = y_next\n    else: # Loop finished without break\n        y_rec = y_current\n\n    # Step 5: Compute metrics for the inpainted signal (r_inpaint, e)\n    X_rec = np.fft.fft(y_rec)\n    \n    total_energy_rec = np.sum(np.abs(X_rec)**2)\n    if total_energy_rec == 0:\n        r_inpaint = 0.0\n    else:\n        artifact_energy_rec = np.sum(np.abs(X_rec[~is_in_S])**2)\n        r_inpaint = artifact_energy_rec / total_energy_rec\n        \n    norm_x = np.linalg.norm(x)\n    if norm_x == 0:\n        e = 0.0 if np.linalg.norm(y_rec) == 0 else np.inf\n    else:\n        e = np.linalg.norm(y_rec - x) / norm_x\n        \n    return [r_zero, r_inpaint, e]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.2, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 1},\n        {'N': 1024, 'K': 3, 'freqs': [50, 123, 300], 'amps': [1.0, 0.8, 0.6], 'p_miss': 0.0, 'K_keep': 6, 'epsilon': 1e-8, 'T_max': 200, 'seed': 2},\n        {'N': 2048, 'K': 5, 'freqs': [15, 77, 221, 400, 650], 'amps': [1.0, 0.5, 0.7, 0.9, 0.4], 'p_miss': 0.5, 'K_keep': 10, 'epsilon': 1e-8, 'T_max': 300, 'seed': 3},\n        {'N': 512, 'K': 1, 'freqs': [64], 'amps': [1.0], 'p_miss': 0.7, 'K_keep': 2, 'epsilon': 1e-8, 'T_max': 300, 'seed': 42},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(\n            N=case['N'],\n            K=case['K'],\n            freqs=case['freqs'],\n            amps=case['amps'],\n            p_miss=case['p_miss'],\n            K_keep=case['K_keep'],\n            epsilon=case['epsilon'],\n            T_max=case['T_max'],\n            seed=case['seed']\n        )\n        results.append(result)\n\n    # Format the final output string as specified.\n    inner_strs = []\n    for res_list in results:\n        formatted_nums = [f'{v:.6f}' for v in res_list]\n        inner_strs.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(inner_strs)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3195883"}]}