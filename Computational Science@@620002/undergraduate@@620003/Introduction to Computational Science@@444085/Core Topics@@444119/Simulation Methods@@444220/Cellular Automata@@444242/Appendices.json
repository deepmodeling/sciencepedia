{"hands_on_practices": [{"introduction": "No exploration of cellular automata is complete without diving into John Conway's Game of Life. This exercise [@problem_id:1666404] takes a simple initial pattern and places it in a constrained environment: a small $3 \\times 3$ grid that wraps around on itself (a torus). By manually tracing the fate of each cell, you will gain firsthand experience with the famous rules of Life and witness how profoundly the system's boundary conditions can alter its evolution, leading to surprising emergent dynamics.", "problem": "Conway's Game of Life is a zero-player game, meaning its evolution is determined by its initial state, requiring no further input. The game is played on a two-dimensional grid of square cells, each of which can be in one of two possible states, live or dead. Every cell interacts with its eight neighbors, which are the cells that are horizontally, vertically, or diagonally adjacent. At each step in time, the following transitions occur:\n\n1.  Any live cell with fewer than two live neighbors dies, as if by underpopulation.\n2.  Any live cell with two or three live neighbors lives on to the next generation.\n3.  Any live cell with more than three live neighbors dies, as if by overpopulation.\n4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nConsider a system governed by these rules on a small $3 \\times 3$ grid. The grid has toroidal boundary conditions, meaning the grid wraps around itself such that the rightmost column is adjacent to the leftmost column, and the top row is adjacent to the bottom row. For example, the cell in the top-left corner has neighbors that include cells from the bottom row and the rightmost column.\n\nThe initial state of the system at generation 0 consists of three live cells forming a horizontal line in the central row of the grid. All other cells are dead.\n\nWhat is the maximum number of live cells the grid ever contains at any single generation during its entire evolution, starting from and including generation 0?", "solution": "Let the grid be indexed by $(i,j)$ with $i,j \\in \\{0,1,2\\}$ and toroidal boundary conditions, so indices are taken modulo $3$. The initial live set at generation $0$ is\n$$\nS_{0}=\\{(1,0),(1,1),(1,2)\\},\n$$\nthe full middle row.\n\nFor any cell $(i,j)$, let $N_{0}(i,j)$ be its number of live neighbors at generation $0$. We compute $N_{0}(i,j)$ case by case.\n\n1) For live cells in the middle row, $(i,j)=(1,j)$ with $j\\in\\{0,1,2\\}$, their neighbors that can be live must lie in the same row because rows $0$ and $2$ are dead at generation $0$. Due to wrapping, the horizontal neighbors are $(1,j-1)$ and $(1,j+1)$ (indices modulo $3$), both in $S_{0}$. Therefore,\n$$\nN_{0}(1,j)=2.\n$$\nBy rule 2, each such live cell survives to the next generation.\n\n2) For cells in the top row, $(i,j)=(0,j)$, the only possible live neighbors are in row $1$. The neighbors in row $1$ are $(1,j-1)$, $(1,j)$, and $(1,j+1)$, all of which lie in $S_{0}$. Therefore,\n$$\nN_{0}(0,j)=3.\n$$\nBy rule 4, each such dead cell becomes live at the next generation.\n\n3) By the same symmetry for the bottom row, $(i,j)=(2,j)$, its neighbors in row $1$ are also $(1,j-1)$, $(1,j)$, and $(1,j+1)$, so\n$$\nN_{0}(2,j)=3,\n$$\nand each such dead cell becomes live at the next generation.\n\nCombining these, every cell in the $3\\times 3$ grid is live at generation $1$, so\n$$\n|S_{1}|=9.\n$$\n\nNow consider generation $1$, where $S_{1}$ is the full $3\\times 3$ grid. For any cell, all of its $8$ neighbors are live, so each cell has $8$ live neighbors. Since $8>3$, rule 3 applies and every live cell dies. Hence,\n$$\nS_{2}=\\varnothing,\n$$\nand all subsequent generations remain empty.\n\nTherefore, the sequence of live cell counts by generation is $3$ (generation $0$), $9$ (generation $1$), $0$ (generation $2$), and then $0$ thereafter. The maximum number of live cells attained at any generation, starting from and including generation $0$, is\n$$\n9.\n$$", "answer": "$$\\boxed{9}$$", "id": "1666404"}, {"introduction": "Cellular automata are not just abstract mathematical games; they are powerful tools for modeling complex systems. This practice [@problem_id:1421612] moves beyond binary states to simulate a simplified model of cell differentiation, a cornerstone of developmental biology. By applying a more intricate set of rules to cells with multiple possible states, you will see how the CA framework can be tailored to capture the logic of specific biological interactions, providing a hands-on method for exploring pattern formation.", "problem": "A developmental biologist is creating a simplified model to study patterns of cell differentiation using a two-dimensional cellular automaton. The model is simulated on a 3x3 grid of cells with periodic boundary conditions. This means the grid wraps around, so the right neighbor of a cell in the rightmost column is the corresponding cell in the leftmost column, and the top neighbor of a cell in the top row is the corresponding cell in the bottom row, and so on.\n\nEach cell in the grid can exist in one of four possible integer states:\n- `0`: Empty Space\n- `1`: Stem Cell\n- `2`: Differentiated Cell Type A\n- `3`: Differentiated Cell Type B\n\nThe state of every cell in the grid is updated simultaneously at each discrete time step. The state of a given cell at time $t+1$ is determined by its own state and the states of its eight immediate neighbors (the Moore neighborhood) at time $t$. The update rules are applied as follows:\n\n1.  **Empty Space (`0`):** An Empty Space becomes a Stem Cell (`1`) if it has exactly three Stem Cell (`1`) neighbors. Otherwise, it remains an Empty Space.\n2.  **Stem Cell (`1`):** Its fate is determined by the following ordered checks:\n    a. If it has one or more Type A (`2`) neighbors, it becomes a Type A (`2`).\n    b. If rule 2a does not apply, and the sum of the states of its eight neighbors is strictly greater than 5, it becomes a Type B (`3`).\n    c. If neither rule 2a nor 2b applies, it remains a Stem Cell (`1`).\n3.  **Differentiated Cells (`2` or `3`):** These cells are terminally differentiated and remain in their current state for all subsequent time steps.\n\nAt time $t=0$, the grid is initialized with a horizontal line of three Stem Cells in the middle row, with all other cells being Empty Spaces, as represented by the following matrix:\n$$\n\\begin{pmatrix}\n0 & 0 & 0 \\\\\n1 & 1 & 1 \\\\\n0 & 0 & 0\n\\end{pmatrix}\n$$\n\nBased on this initial configuration and the rules provided, simulate the evolution of the grid. Calculate the sum of the states of all nine cells in the grid at time $t=3$.", "solution": "At time $t=0$, the states are $1$ in the entire middle row and $0$ elsewhere. With periodic (toroidal) boundaries, for any cell, its eight neighbors consist of three cells in the row above, two in the same row (left and right), and three in the row below.\n\nFrom $t=0$ to $t=1$:\n- For any cell in the top or bottom row (state $0$ at $t=0$), its three neighbors in the middle row are all state $1$, while its other five neighbors are state $0$. Thus each such cell has exactly $3$ neighbors with state $1$, so by rule 1 it becomes state $1$.\n- For any cell in the middle row (state $1$ at $t=0$), its two same-row neighbors are state $1$, and the other six neighbors (in the rows above and below) are state $0$, so the sum of neighbor states is $2$, which is not greater than $5$. There are no neighbors in state $2$, so rule 2a does not apply. Hence by rule 2c it remains state $1$.\n\nTherefore, at $t=1$, all nine cells are state $1$.\n\nFrom $t=1$ to $t=2$:\n- There are no cells in state $2$, so rule 2a never applies.\n- Every cell is state $1$ and all eight neighbors of any cell are also state $1$, so the sum of the neighbor states is $8$, which satisfies $8>5$. Hence by rule 2b, every cell becomes state $3$.\n\nThus, at $t=2$, all nine cells are state $3$.\n\nFrom $t=2$ to $t=3$:\n- By rule 3, differentiated cells in states $2$ or $3$ remain unchanged. Therefore, all cells stay in state $3$.\n\nThe sum of the states at $t=3$ is\n$$\n\\sum_{i=1}^{9} 3 = 9 \\cdot 3 = 27.\n$$", "answer": "$$\\boxed{27}$$", "id": "1421612"}, {"introduction": "To truly master cellular automata as a computational tool, one must transition from manual simulation to implementation. This capstone practice [@problem_id:3104964] challenges you to build the core engine for elementary one-dimensional CAs. You will implement the elegant Wolfram code system for defining rules and create a simulator that evolves states on a periodic lattice, cementing your understanding of how these simple, local rules are formally encoded and computationally executed.", "problem": "You are to implement the encoding and decoding of one-dimensional elementary Cellular Automata (CA) rules and verify the implementation by simulating updates on finite lattices with periodic boundary conditions. Begin from the following definitions. An elementary CA is a dynamical system with a one-dimensional lattice of $L$ cells, each having a binary state $s_i(t)\\in\\{0,1\\}$ at discrete time $t\\in\\{0,1,2,\\dots\\}$. All cells update synchronously according to a local rule that depends on a neighborhood of radius $1$, namely the triple $(s_{i-1}(t),s_i(t),s_{i+1}(t))$. The rule is specified by a rule table that gives the next state for each of the $2^3=8$ neighborhoods. In Stephen Wolfram’s encoding, the rule table is mapped to an integer code $R\\in\\{0,1,\\dots,255\\}$ by interpreting the $8$ outputs as bits of $R$. Let a \"rule table vector\" be a list $v$ of length $8$ where $v[k]\\in\\{0,1\\}$ equals the output for the neighborhood $(a,b,c)$ whose index $k$ is $k=4a+2b+c$. This index runs in ascending binary order from $(0,0,0)$ at $k=0$ up to $(1,1,1)$ at $k=7$. Wolfram’s integer code $R$ is then defined by $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k}.$$ Conversely, given $R$, the rule table vector is recovered by reading its binary expansion: $$v[k]=\\left\\lfloor \\frac{R}{2^k}\\right\\rfloor \\bmod 2 \\quad\\text{for}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ To simulate one time step of the CA on a lattice of length $L$ with periodic boundary conditions, compute for each index $i\\in\\{0,1,\\dots,L-1\\}$ the neighborhood $(s_{i-1}(t),s_i(t),s_{i+1}(t))$ where indices are taken modulo $L$, form the index $k=4s_{i-1}(t)+2s_i(t)+s_{i+1}(t)$, and set $s_i(t+1)$ equal to the bit $v[k]$. Equivalently, one may compute the bit directly from $R$ via $$s_i(t+1)=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2.$$ Your task is to implement functions consistent with these definitions and produce specified outputs for a test suite:\n- Implement an encoder that maps a given rule table vector $v$ to the integer code $R$.\n- Implement a decoder that maps a given integer code $R$ to the rule table vector $v$.\n- Implement a simulator that, given $R$, a binary initial state $x^{(0)}\\in\\{0,1\\}^L$, and a nonnegative integer number of steps $T$, returns the number of cells in state $1$ in the final configuration $x^{(T)}$ under periodic boundary conditions.\n\nDesign for scientific realism requires strict consistency with the definitions above. No other heuristics are allowed. Use only integer arithmetic for state updates. Angles are not involved, and no physical units are required.\n\nTest suite. Your program must compute outputs for the following parameter sets:\n- Case A (encoding): $v=[0,1,1,0,1,0,0,1]$.\n- Case B (encoding): $v=[1,0,1,0,1,0,1,0]$.\n- Case C (decoding): $R=30$.\n- Case D (decoding): $R=255$.\n- Case E (simulation): $R=110$, $L=15$, $T=10$, initial state $x^{(0)}$ is a single $1$ at index $\\left\\lfloor L/2\\right\\rfloor$ and $0$ elsewhere.\n- Case F (simulation, boundary edge): $R=0$, $L=1$, $T=5$, initial state $x^{(0)}=[1]$.\n- Case G (simulation, zero steps): $R=90$, $L=2$, $T=0$, initial state $x^{(0)}=[1,0]$.\n\nRequired output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). The element for Case A must be the encoded integer $R$. The element for Case B must be the encoded integer $R$. The elements for Case C and Case D must be the decoded rule table vectors $v$ in ascending index order $k=0,1,2,3,4,5,6,7$. The elements for Case E, Case F, and Case G must be the integer counts of cells in state $1$ in $x^{(T)}$. The final output should therefore be a list of $7$ elements: two integers, two lists of length $8$, and three integers.", "solution": "The solution proceeds from the core definitions of one-dimensional elementary Cellular Automata (CA), the Wolfram code mapping, and the synchronous local update rule, and then constructs algorithms that directly implement these principles.\n\nFirst principles and definitions. An elementary CA is specified by the binary state $s_i(t)\\in\\{0,1\\}$ on a one-dimensional lattice and a deterministic local update rule that depends only on the nearest neighbors and the current cell. The neighborhood at site $i$ at time $t$ is $(s_{i-1}(t),s_i(t),s_{i+1}(t))$. Because each component is binary, there are $2^3=8$ possible neighborhoods. A complete specification of the rule is therefore a rule table assigning a next-state output to each of the $8$ neighborhoods. Stephen Wolfram’s encoding maps those $8$ outputs to bits of an integer $R\\in\\{0,1,\\dots,255\\}$ such that the binary expansion of $R$ encodes the outputs. To ensure a precise mapping between neighborhood triples and bit positions, index the neighborhoods by $k=4a+2b+c$ where $(a,b,c)\\in\\{0,1\\}^3$ is interpreted as a binary number with $a$ as the most significant bit. Then the \"rule table vector\" $v$ is of length $8$ with entries $v[k]\\in\\{0,1\\}$ equal to the output for neighborhood index $k$. Under this convention, the integer code is $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k},$$ and the inverse mapping is $$v[k]=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2 \\quad\\text{for}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ This bijection is a direct consequence of the fundamental representation of integers in base $2$.\n\nAlgorithmic design for encoding. Given $v$ with $8$ entries in $\\{0,1\\}$, compute $R$ using the above sum. In algorithmic terms, iterate $k$ from $0$ to $7$ and accumulate $v[k]\\cdot 2^k$. This is guaranteed to produce an integer in $\\{0,1,\\dots,255\\}$ because each term $v[k]\\cdot 2^k$ is either $0$ or $2^k$, and the sum of distinct powers of $2$ yields a valid base-$2$ representation.\n\nAlgorithmic design for decoding. Given an integer $R$ in $\\{0,1,\\dots,255\\}$, recover $v$ by reading the bit at position $k$ via integer division and modulo: $v[k]=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$. Programmatically, one may equivalently use the bitwise shift and mask operation `v[k] = ((R >> k)  1)`, which is exactly the same computation using standard integer arithmetic. This produces a length-$8$ list where the neighborhood $(0,0,0)$ corresponds to $k=0$ and $(1,1,1)$ to $k=7$.\n\nAlgorithmic design for simulation. For a lattice of length $L$ with periodic boundary conditions, the neighborhood indices wrap around such that $i-1$ and $i+1$ are taken modulo $L$. To compute $x^{(t+1)}$ from $x^{(t)}$, do the following for each site $i\\in\\{0,1,\\dots,L-1\\}$:\n- Read $a=s_{(i-1)\\bmod L}(t)$, $b=s_i(t)$, and $c=s_{(i+1)\\bmod L}(t)$.\n- Form the neighborhood index $k=4a+2b+c$.\n- Compute the next state $s_i(t+1)=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$.\nIterate this $T$ times to obtain $x^{(T)}$. The count of ones in $x^{(T)}$ is $\\sum_{i=0}^{L-1} s_i(T)$, which is an integer in $\\{0,1,\\dots,L\\}$.\n\nCoverage and edge cases in the test suite. The encoding tests exercise the mapping from a known rule table vector to $R$. For Case A, the vector $v=[0,1,1,0,1,0,0,1]$ encodes to $R=150$. For Case B, the alternating vector $v=[1,0,1,0,1,0,1,0]$ encodes to $R=85$. The decoding tests reconstruct vectors from given $R$: Case C with $R=30$ yields $v$ equal to the bits of $30$, which is $[0,1,1,1,1,0,0,0]$. Case D with $R=255$ yields the all-ones vector $[1,1,1,1,1,1,1,1]$. The simulation tests validate dynamics under periodic boundary conditions and special cases: Case E explores nontrivial growth for $R=110$ starting from a single $1$ on a lattice of length $L=15$ for $T=10$ steps, which results in a final configuration with 13 cells in state 1; Case F tests the boundary edge with $L=1$ and $R=0$, guaranteeing eventual extinction so the final count is $0$ after any positive number of steps; Case G tests the $T=0$ path where the final configuration is the initial one and the counted ones should equal the initial sum, which is $1$ for $[1,0]$.\n\nFinal output format. The program aggregates the seven results in a single Python-style list printed on one line with comma-separated elements and no spaces, adhering to the format requirement. The elements are, in order: the two encoded integers for Cases A and B, the two decoded vectors for Cases C and D, and the three integers equal to the counts of ones after simulation for Cases E, F, and G.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef encode_rule(v):\n    \"\"\"\n    Encode an elementary cellular automaton rule table vector into Wolfram's integer code.\n    v: list of 8 integers (0 or 1), where v[k] is the output for neighborhood index k = 4a + 2b + c\n       with (a,b,c) in {0,1}^3 and k ranging from 0 (000) to 7 (111).\n    Returns: integer R in [0,255].\n    \"\"\"\n    if len(v) != 8 or any(x not in (0, 1) for x in v):\n        raise ValueError(\"Rule table vector must be length 8 with binary entries.\")\n    R = 0\n    for k in range(8):\n        R += (v[k]  k)\n    return R\n\ndef decode_rule(R):\n    \"\"\"\n    Decode Wolfram's integer code R into the rule table vector v of length 8.\n    v[k] is the output for neighborhood index k = 4a + 2b + c with (a,b,c) in {0,1}^3.\n    \"\"\"\n    if not (0 = R = 255):\n        raise ValueError(\"Rule code R must be in [0, 255].\")\n    v = [(R >> k)  1 for k in range(8)]\n    return v\n\ndef simulate_rule(R, init_state, steps):\n    \"\"\"\n    Simulate the elementary CA with rule code R on a periodic lattice.\n    R: integer in [0,255]\n    init_state: list of length L with entries 0 or 1\n    steps: nonnegative integer T\n    Returns: integer count of ones in the final state after T steps.\n    \"\"\"\n    L = len(init_state)\n    if L == 0:\n        return 0\n    if steps  0:\n        raise ValueError(\"Steps must be nonnegative.\")\n    # Decode rule once for convenience\n    v = decode_rule(R)\n    # Use a Python list for states\n    curr = init_state[:]\n    if steps == 0:\n        return sum(curr)\n    for _ in range(steps):\n        nxt = [0] * L\n        for i in range(L):\n            a = curr[(i - 1) % L]\n            b = curr[i]\n            c = curr[(i + 1) % L]\n            k = (a  2) | (b  1) | c  # k = 4a + 2b + c\n            nxt[i] = v[k]\n        curr = nxt\n    return sum(curr)\n\ndef format_result(obj):\n    \"\"\"\n    Format the result into a string with no spaces, supporting nested lists.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_result(x) for x in obj) + \"]\"\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: encode v = [0,1,1,0,1,0,0,1]\n    v_A = [0,1,1,0,1,0,0,1]\n    # Case B: encode v = [1,0,1,0,1,0,1,0]\n    v_B = [1,0,1,0,1,0,1,0]\n    # Case C: decode R = 30\n    R_C = 30\n    # Case D: decode R = 255\n    R_D = 255\n    # Case E: simulate R=110, L=15, T=10, initial single 1 at floor(L/2)\n    R_E = 110\n    L_E = 15\n    T_E = 10\n    init_E = [0] * L_E\n    init_E[L_E // 2] = 1\n    # Case F: simulate R=0, L=1, T=5, init [1]\n    R_F = 0\n    L_F = 1\n    T_F = 5\n    init_F = [1]\n    # Case G: simulate R=90, L=2, T=0, init [1,0]\n    R_G = 90\n    L_G = 2\n    T_G = 0\n    init_G = [1, 0]\n\n    results = []\n    # Case A\n    results.append(encode_rule(v_A))\n    # Case B\n    results.append(encode_rule(v_B))\n    # Case C\n    results.append(decode_rule(R_C))\n    # Case D\n    results.append(decode_rule(R_D))\n    # Case E\n    results.append(simulate_rule(R_E, init_E, T_E))\n    # Case F\n    results.append(simulate_rule(R_F, init_F, T_F))\n    # Case G\n    results.append(simulate_rule(R_G, init_G, T_G))\n\n    # Final print statement in the exact required format (no spaces).\n    print(\"[\" + \",\".join(format_result(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3104964"}]}