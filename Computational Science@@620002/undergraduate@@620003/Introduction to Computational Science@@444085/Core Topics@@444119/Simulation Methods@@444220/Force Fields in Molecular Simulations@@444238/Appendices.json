{"hands_on_practices": [{"introduction": "Before we can trust the results of a simulation, we must ensure our implementation of the force field is fundamentally correct. A core principle of physics is that the laws of nature do not depend on the observer's absolute position, orientation, or how we label identical particles. This practice challenges you to translate these physical principles of translation, rotation, and permutation invariance into a concrete set of numerical tests to validate a force field implementation. By programming these checks [@problem_id:3131635], you will build confidence in the correctness of your simulation code, a critical first step in computational science.", "problem": "A developer is asked to validate a classical molecular force field implementation by constructing computational tests of invariance for the potential energy $U(\\mathbf{R})$ and the force field $\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} U(\\mathbf{R})$ of a system of $N$ identical particles, where $\\mathbf{R} \\in \\mathbb{R}^{N \\times 3}$ collects all particle coordinates in three-dimensional space. The system is modeled by a pairwise interaction that depends only on interparticle distances, which guarantees physical invariance of $U$ and $\\mathbf{F}$ under rigid translations, rigid rotations, and permutations of identical particles. The goal is to produce a runnable program that checks these invariance properties numerically on a defined test suite. All quantities are expressed in reduced Lennard-Jones (LJ) units, with length unit $\\sigma$, energy unit $\\epsilon$, and force unit $\\epsilon/\\sigma$, and angles are to be interpreted in radians.\n\nStarting from fundamental laws and definitions (Newton’s laws, the gradient of a scalar field, and the property that pairwise potentials depend only on interparticle distances), implement a potential energy $U(\\mathbf{R})$ and force field $\\mathbf{F}(\\mathbf{R})$ for $N$ identical particles interacting via a distance-dependent pair potential. Use the well-tested Lennard-Jones pair potential in reduced units: it depends only on distance $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ between particles $i$ and $j$, with parameters $\\sigma = 1$ and $\\epsilon = 1$. The force must be obtained by applying the definition $\\mathbf{F}(\\mathbf{R}) = -\\nabla_{\\mathbf{R}} U(\\mathbf{R})$ to the pairwise energy function.\n\nDesign and implement numerical tests for the following invariances:\n- Translation invariance: for a translation vector $\\mathbf{t} \\in \\mathbb{R}^3$, $U(\\mathbf{R} + \\mathbf{t})$ equals $U(\\mathbf{R})$ and $\\mathbf{F}(\\mathbf{R} + \\mathbf{t})$ equals $\\mathbf{F}(\\mathbf{R})$.\n- Rotation invariance: for a proper rotation matrix $\\mathbf{Q} \\in \\mathrm{SO}(3)$ (Special Orthogonal Group, satisfying $\\mathbf{Q}^\\top \\mathbf{Q} = \\mathbf{I}$ and $\\det(\\mathbf{Q}) = 1$), $U(\\mathbf{Q}\\mathbf{R})$ equals $U(\\mathbf{R})$ and $\\mathbf{F}(\\mathbf{Q}\\mathbf{R})$ equals $\\mathbf{Q}\\mathbf{F}(\\mathbf{R})$.\n- Permutation invariance: for a permutation $\\pi$ of particle indices, $U(\\pi(\\mathbf{R}))$ equals $U(\\mathbf{R})$ and $\\mathbf{F}(\\pi(\\mathbf{R}))$ equals $\\pi(\\mathbf{F}(\\mathbf{R}))$ under reindexing.\n\nYour program must implement the following fixed test suite of parameter values, covering a general case, symmetry edge cases, and boundary-like configurations. In each case, the translation vector $\\mathbf{t}$, rotation axis $\\hat{\\mathbf{a}}$ (unit vector), rotation angle $\\theta$ (in radians), and permutation $\\pi$ are provided. The LJ parameters are fixed as $\\sigma = 1$ and $\\epsilon = 1$.\n\nTest case $\\#1$ (general scalene triangle):\n- $N = 3$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 1.05 & 0.2 & -0.1 \\\\ -0.6 & 1.1 & 0.3 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} 0.3 \\\\ -0.2 \\\\ 0.1 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 0.2 \\\\ 0.7 \\\\ 0.3 \\end{bmatrix}$ normalized to unit length,\n- $\\theta = 0.75$,\n- $\\pi = [2, 0, 1]$.\n\nTest case $\\#2$ (equilateral triangle at the LJ minimum distance):\n- $N = 3$,\n- Let $s = 2^{1/6}$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ s & 0 & 0 \\\\ s/2 & s\\sqrt{3}/2 & 0 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} 1.0 \\\\ -1.0 \\\\ 0.5 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$,\n- $\\theta = \\pi/3$,\n- $\\pi = [1, 0, 2]$.\n\nTest case $\\#3$ (colinear along $x$-axis):\n- $N = 3$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 1.2 & 0 & 0 \\\\ 2.7 & 0 & 0 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} 0.5 \\\\ -0.1 \\\\ 0.3 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$,\n- $\\theta = \\pi$,\n- $\\pi = [0, 2, 1]$.\n\nTest case $\\#4$ (weakly interacting square of side length $5$):\n- $N = 4$,\n- $\\mathbf{R} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 5 & 0 & 0 \\\\ 5 & 5 & 0 \\\\ 0 & 5 & 0 \\end{bmatrix}$,\n- $\\mathbf{t} = \\begin{bmatrix} -3 \\\\ 2 \\\\ 1 \\end{bmatrix}$,\n- $\\hat{\\mathbf{a}} = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1 \\end{bmatrix}$ normalized to unit length,\n- $\\theta = 0.1$,\n- $\\pi = [2, 3, 1, 0]$.\n\nNumerical verification criteria must compare scalar energies and vector forces with absolute tolerances:\n- Energy tolerance $\\tau_U = 10^{-10}$,\n- Force tolerance $\\tau_F = 10^{-10}$, applied to the maximum absolute difference across all components.\n\nFor each test case $i$, compute six boolean results in the following order:\n- $T_i^U$: translation invariance of energy,\n- $T_i^{\\mathbf{F}}$: translation invariance of forces,\n- $R_i^U$: rotation invariance of energy,\n- $R_i^{\\mathbf{F}}$: rotation invariance of forces (comparing $\\mathbf{F}(\\mathbf{Q}\\mathbf{R})$ to $\\mathbf{Q}\\mathbf{F}(\\mathbf{R})$),\n- $P_i^U$: permutation invariance of energy,\n- $P_i^{\\mathbf{F}}$: permutation invariance of forces.\n\nYour program should produce a single line of output containing all results for test cases $\\#1$ to $\\#4$, flattened in order as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\dots]$). Since these are boolean checks, the final values must be the literal boolean values. No external input is allowed, and the program must be self-contained.\n\nAngles must be in radians. No other units need to be output because the program outputs only booleans and uses reduced Lennard-Jones units internally.", "solution": "The problem statement is a valid exercise in computational science, requiring the implementation and verification of fundamental symmetries in a classical molecular force field. It is scientifically grounded, well-posed, objective, and contains all necessary information to produce a unique, verifiable solution.\n\nThe core of the problem is to compute the potential energy $U(\\mathbf{R})$ and the corresponding force field $\\mathbf{F}(\\mathbf{R})$ for a system of $N$ identical particles interacting via a pairwise potential, and then to numerically verify their invariance properties under translation, rotation, and permutation.\n\nThe total potential energy $U(\\mathbf{R})$ of the system is the sum of pair potentials over all unique pairs of particles $(i, j)$:\n$$\nU(\\mathbf{R}) = \\sum_{i=1}^{N-1} \\sum_{j=i+1}^{N} u(r_{ij})\n$$\nwhere $\\mathbf{R} \\in \\mathbb{R}^{N \\times 3}$ is the matrix of all particle coordinates $\\mathbf{r}_i$, and $r_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|$ is the scalar distance between particles $i$ and $j$. The problem specifies the Lennard-Jones (LJ) potential in reduced units, where the characteristic energy $\\epsilon=1$ and length $\\sigma=1$. The LJ pair potential $u(r)$ is thus:\n$$\nu(r) = 4 \\left( \\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6} \\right) = 4(r^{-12} - r^{-6})\n$$\n\nThe force $\\mathbf{F}_k$ acting on a particle $k$ is given by the negative gradient of the total potential energy with respect to its coordinates $\\mathbf{r}_k$:\n$$\n\\mathbf{F}_k(\\mathbf{R}) = -\\nabla_{\\mathbf{r}_k} U(\\mathbf{R}) = -\\nabla_{\\mathbf{r}_k} \\sum_{i<j} u(r_{ij})\n$$\nSince the gradient operator $\\nabla_{\\mathbf{r}_k}$ only acts on terms involving particle $k$, the sum reduces to pairs including $k$:\n$$\n\\mathbf{F}_k(\\mathbf{R}) = - \\sum_{j \\neq k} \\nabla_{\\mathbf{r}_k} u(r_{kj})\n$$\nUsing the chain rule, $\\nabla_{\\mathbf{r}_k} u(r_{kj}) = \\frac{du}{dr_{kj}} \\nabla_{\\mathbf{r}_k} r_{kj}$. The gradient of the distance function is $\\nabla_{\\mathbf{r}_k} r_{kj} = \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = \\hat{\\mathbf{r}}_{kj}$, a unit vector pointing from $j$ to $k$. The derivative of the LJ potential is $\\frac{du}{dr} = 4(-12r^{-13} - (-6)r^{-7}) = -24(2r^{-13} - r^{-7})$.\nCombining these gives the force on particle $k$:\n$$\n\\mathbf{F}_k(\\mathbf{R}) = \\sum_{j \\neq k} \\left[ - \\frac{du}{dr_{kj}} \\right] \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}} = \\sum_{j \\neq k} 24(2r_{kj}^{-13} - r_{kj}^{-7}) \\frac{\\mathbf{r}_k - \\mathbf{r}_j}{r_{kj}}\n$$\nThis can be computed efficiently by iterating over pairs $(i, j)$ with $i<j$, calculating the force vector $\\mathbf{f}_{ij}$ exerted on $i$ by $j$, and adding $\\mathbf{f}_{ij}$ to $\\mathbf{F}_i$ and $-\\mathbf{f}_{ij}$ to $\\mathbf{F}_j$, in accordance with Newton's third law.\n\nThe numerical tests verify the following invariances within a given tolerance:\n\n1.  **Translation Invariance**: The system is translated by a vector $\\mathbf{t}$. The new coordinates are $\\mathbf{R'} = \\mathbf{R} + \\mathbf{t}$, which means each $\\mathbf{r}_i' = \\mathbf{r}_i + \\mathbf{t}$. The interparticle distance $r_{ij}' = \\|\\mathbf{r}_i' - \\mathbf{r}_j'\\| = \\|(\\mathbf{r}_i + \\mathbf{t}) - (\\mathbf{r}_j + \\mathbf{t})\\| = \\|\\mathbf{r}_i - \\mathbf{r}_j\\| = r_{ij}$ is unchanged.\n    - Energy: Since $U$ depends only on $r_{ij}$, it must be invariant: $U(\\mathbf{R'}) = U(\\mathbf{R})$. We test if $|U(\\mathbf{R'}) - U(\\mathbf{R})| < \\tau_U$.\n    - Force: The force expression depends on $r_{ij}$ and the difference vectors $\\mathbf{r}_i - \\mathbf{r}_j$, which are also translationally invariant. Thus, the force field must be invariant: $\\mathbf{F}(\\mathbf{R'}) = \\mathbf{F}(\\mathbf{R})$. We test if $\\max|\\mathbf{F}(\\mathbf{R'}) - \\mathbf{F}(\\mathbf{R})| < \\tau_F$.\n\n2.  **Rotation Invariance**: The system is rotated by a proper rotation matrix $\\mathbf{Q} \\in \\mathrm{SO}(3)$, constructed from the provided axis $\\hat{\\mathbf{a}}$ and angle $\\theta$ via Rodrigues' rotation formula. The new coordinates are $\\mathbf{R}' = \\mathbf{Q}\\mathbf{R}$, meaning each vector coordinate is transformed as $\\mathbf{r}_i' = \\mathbf{Q}\\mathbf{r}_i$. The interparticle distance is invariant because rotations are isometries: $r_{ij}' = \\|\\mathbf{Q}\\mathbf{r}_i - \\mathbf{Q}\\mathbf{r}_j\\| = \\|\\mathbf{Q}(\\mathbf{r}_i - \\mathbf{r}_j)\\| = \\|\\mathbf{r}_i - \\mathbf{r}_j\\| = r_{ij}$.\n    - Energy: As with translation, the invariance of $r_{ij}$ implies the invariance of energy: $U(\\mathbf{Q}\\mathbf{R}) = U(\\mathbf{R})$. We test if $|U(\\mathbf{Q}\\mathbf{R}) - U(\\mathbf{R})| < \\tau_U$.\n    - Force: The force vector transforms covariantly with the rotation. The gradient operator transforms as $\\nabla_{\\mathbf{r}'} = \\mathbf{Q}\\nabla_{\\mathbf{r}}$, so the force transforms as $\\mathbf{F}_k(\\mathbf{Q}\\mathbf{R}) = -\\nabla_{\\mathbf{r}_k'} U(\\mathbf{Q}\\mathbf{R}) = -(\\mathbf{Q}\\nabla_{\\mathbf{r}_k}) U(\\mathbf{R}) = \\mathbf{Q}(-\\nabla_{\\mathbf{r}_k}U(\\mathbf{R})) = \\mathbf{Q}\\mathbf{F}_k(\\mathbf{R})$. We test the relation $\\mathbf{F}(\\mathbf{Q}\\mathbf{R}) = \\mathbf{Q}\\mathbf{F}(\\mathbf{R})$ by checking if $\\max|\\mathbf{F}(\\mathbf{Q}\\mathbf{R}) - \\mathbf{Q}\\mathbf{F}(\\mathbf{R})| < \\tau_F$.\n\n3.  **Permutation Invariance**: The labels of the identical particles are permuted according to a permutation $\\pi$. The new coordinate matrix $\\mathbf{R}' = \\pi(\\mathbf{R})$ is obtained by reordering the rows of $\\mathbf{R}$ such that the $i$-th row of $\\mathbf{R}'$ is the $\\pi(i)$-th row of $\\mathbf{R}$.\n    - Energy: The total potential energy is a sum over all pairs. Permuting the particle indices merely reorders the terms in this sum, leaving the total value unchanged. Thus, $U(\\pi(\\mathbf{R})) = U(\\mathbf{R})$. We test if $|U(\\pi(\\mathbf{R})) - U(\\mathbf{R})| < \\tau_U$.\n    - Force: The force on the \"new\" particle $i$ (which was the \"old\" particle $\\pi(i)$) is simply the force that was acting on particle $\\pi(i)$ in the original configuration. This means the force vectors are permuted in the same way as the particle coordinates: $\\mathbf{F_i}(\\pi(\\mathbf{R})) = \\mathbf{F_{\\pi(i)}}(\\mathbf{R})$. In matrix form, $\\mathbf{F}(\\pi(\\mathbf{R})) = \\pi(\\mathbf{F}(\\mathbf{R}))$. We test if $\\max|\\mathbf{F}(\\pi(\\mathbf{R})) - \\pi(\\mathbf{F}(\\mathbf{R}))| < \\tau_F$.\n\nThe implementation will proceed by defining functions to calculate $U$ and $\\mathbf{F}$ for a given $\\mathbf{R}$. Then, for each test case, it will compute the baseline values, apply each transformation, recompute the physical quantities, and compare them against the expected transformed values using the specified numerical tolerances $\\tau_U = 10^{-10}$ and $\\tau_F = 10^{-10}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.transform import Rotation\n\ndef calculate_energy_and_forces(coords: np.ndarray):\n    \"\"\"\n    Calculates the total potential energy and forces for a system of particles\n    interacting via the Lennard-Jones potential in reduced units (sigma=1, epsilon=1).\n\n    Args:\n        coords (np.ndarray): An (N, 3) array of particle coordinates.\n\n    Returns:\n        tuple[float, np.ndarray]: A tuple containing:\n            - The total potential energy (float).\n            - An (N, 3) array of the force on each particle (np.ndarray).\n    \"\"\"\n    n_particles = coords.shape[0]\n    potential_energy = 0.0\n    forces = np.zeros_like(coords)\n\n    for i in range(n_particles):\n        for j in range(i + 1, n_particles):\n            rij_vec = coords[i] - coords[j]\n            rij_sq = np.dot(rij_vec, rij_vec)\n\n            # Avoid division by zero, although test cases do not feature it.\n            if rij_sq == 0.0:\n                continue\n\n            # Calculate pairwise LJ potential and force using squared distances\n            # for efficiency.\n            # In reduced units, sigma = 1 and epsilon = 1.\n            inv_rij_sq = 1.0 / rij_sq\n            inv_rij_6 = inv_rij_sq**3\n            inv_rij_12 = inv_rij_6**2\n\n            # U_pair = 4 * (r^-12 - r^-6)\n            potential_energy += 4.0 * (inv_rij_12 - inv_rij_6)\n\n            # F_vec = -dU/dr * (rij_vec / |rij|)\n            # -dU/dr = 24 * (2*r^-13 - r^-7)\n            # F_vec = 24 * (2*r^-14 - r^-8) * rij_vec\n            # F_vec = (48*r^-14 - 24*r^-8) * rij_vec\n            # F_vec = (48*inv_rij_sq^7 - 24*inv_rij_sq^4) * rij_vec\n            # F_vec = (48*inv_rij_12 - 24*inv_rij_6) * inv_rij_sq * rij_vec\n            force_scalar_over_rij_sq = 24.0 * inv_rij_sq * (2.0 * inv_rij_12 - inv_rij_6)\n            force_vec = force_scalar_over_rij_sq * rij_vec\n\n            forces[i] += force_vec\n            forces[j] -= force_vec\n\n    return potential_energy, forces\n\ndef solve():\n    \"\"\"\n    Main function to run the force field invariance tests.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    s_tc2 = 2**(1/6)\n    test_cases = [\n        {\n            \"N\": 3,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.05, 0.2, -0.1], [-0.6, 1.1, 0.3]]),\n            \"t\": np.array([0.3, -0.2, 0.1]),\n            \"a_hat\": np.array([0.2, 0.7, 0.3]),\n            \"theta\": 0.75,\n            \"pi\": [2, 0, 1]\n        },\n        {\n            \"N\": 3,\n            \"R\": np.array([[0.0, 0.0, 0.0], [s_tc2, 0.0, 0.0], [s_tc2/2.0, s_tc2*np.sqrt(3)/2.0, 0.0]]),\n            \"t\": np.array([1.0, -1.0, 0.5]),\n            \"a_hat\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": np.pi/3.0,\n            \"pi\": [1, 0, 2]\n        },\n        {\n            \"N\": 3,\n            \"R\": np.array([[0.0, 0.0, 0.0], [1.2, 0.0, 0.0], [2.7, 0.0, 0.0]]),\n            \"t\": np.array([0.5, -0.1, 0.3]),\n            \"a_hat\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": np.pi,\n            \"pi\": [0, 2, 1]\n        },\n        {\n            \"N\": 4,\n            \"R\": np.array([[0.0, 0.0, 0.0], [5.0, 0.0, 0.0], [5.0, 5.0, 0.0], [0.0, 5.0, 0.0]]),\n            \"t\": np.array([-3.0, 2.0, 1.0]),\n            \"a_hat\": np.array([1.0, 1.0, 1.0]),\n            \"theta\": 0.1,\n            \"pi\": [2, 3, 1, 0]\n        }\n    ]\n\n    tol_U = 1e-10\n    tol_F = 1e-10\n    all_results = []\n\n    for case in test_cases:\n        R, t_vec, a_hat, theta, pi = case[\"R\"], case[\"t\"], case[\"a_hat\"], case[\"theta\"], case[\"pi\"]\n\n        # 1. Baseline calculation\n        U_0, F_0 = calculate_energy_and_forces(R)\n\n        # 2. Translation Invariance Test\n        R_trans = R + t_vec  # Broadcasting t_vec to each row of R\n        U_trans, F_trans = calculate_energy_and_forces(R_trans)\n        check_U_trans = np.abs(U_trans - U_0) < tol_U\n        check_F_trans = np.max(np.abs(F_trans - F_0)) < tol_F\n        all_results.extend([check_U_trans, check_F_trans])\n\n        # 3. Rotation Invariance Test\n        a_hat_norm = a_hat / np.linalg.norm(a_hat)\n        rot = Rotation.from_rotvec(theta * a_hat_norm)\n        Q = rot.as_matrix()\n        # Apply rotation to each coordinate vector (row)\n        R_rot = R @ Q.T\n        U_rot, F_rot = calculate_energy_and_forces(R_rot)\n        F_0_rot_expected = F_0 @ Q.T # Covariant transformation of force vectors\n        check_U_rot = np.abs(U_rot - U_0) < tol_U\n        check_F_rot = np.max(np.abs(F_rot - F_0_rot_expected)) < tol_F\n        all_results.extend([check_U_rot, check_F_rot])\n        \n        # 4. Permutation Invariance Test\n        R_perm = R[pi, :] # Permute rows (particles)\n        U_perm, F_perm = calculate_energy_and_forces(R_perm)\n        F_0_perm_expected = F_0[pi, :] # Permute force vectors accordingly\n        check_U_perm = np.abs(U_perm - U_0) < tol_U\n        check_F_perm = np.max(np.abs(F_perm - F_0_perm_expected)) < tol_F\n        all_results.extend([check_U_perm, check_F_perm])\n\n    # Final print statement in the exact required format.\n    # Python's str(True) -> 'True', str(False) -> 'False'\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```", "id": "3131635"}, {"introduction": "Real-world simulations are a balance between physical accuracy and computational feasibility, often requiring the use of approximations. However, it's crucial to understand and quantify the systematic errors these approximations introduce. This practice focuses on long-range electrostatic forces, comparing a common truncation scheme—the Reaction Field method—against a more accurate baseline to measure its effect on a key physical observable: the ion pairing constant [@problem_id:3131560]. This exercise provides hands-on experience in analyzing the trade-offs inherent in choosing a computational model.", "problem": "You are modeling the equilibrium “inner-sphere” ion pairing of two monovalent ions in a dielectric solvent using pairwise additive nonbonded interactions. The radial potential energy between the ions is modeled as the sum of a Lennard–Jones term and an electrostatic term. At infinite dilution, the radial distribution function equals the Boltzmann factor. You will quantify how truncating electrostatics with a Reaction Field (RF) approximation biases the computed ion pairing constant relative to a Particle Mesh Ewald (PME) baseline, and then extrapolate the RF results to the infinite cutoff limit for comparison to the PME baseline.\n\nStart from the following foundational facts and definitions:\n- At infinite dilution, the pair radial distribution function is given by $g(r)=\\exp\\left(-\\beta U(r)\\right)$, where $\\beta = 1/(R T)$, $R$ is the ideal gas constant, $T$ is the absolute temperature, and $U(r)$ is the pair potential energy.\n- The “inner-sphere” association constant proxy (hereafter called the pairing constant) over a bound-state domain $[0,r_b]$ is proportional to the configuration integral\n$$\nK = 4\\pi \\int_{0}^{r_b} r^2 \\exp\\left(-\\beta U(r)\\right)\\,dr,\n$$\nwhich has the dimension of a volume. Because we will compare methods on the same footing, this $K$ can be used directly for relative bias analysis without introducing an additional standard-state factor.\n- The pair potential is the sum $U(r)=U_{\\mathrm{LJ}}(r)+U_{\\mathrm{elec}}(r)$, with the Lennard–Jones term\n$$\nU_{\\mathrm{LJ}}(r)=4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right].\n$$\n- The electrostatic contribution for the PME baseline is the unscreened Coulomb interaction in dielectric medium of relative permittivity $\\varepsilon_r$,\n$$\nU_{\\mathrm{elec}}^{\\mathrm{PME}}(r)=\\frac{k_c\\,q_1 q_2}{\\varepsilon_r\\, r},\n$$\nwith $k_c$ the Coulomb constant expressed in energy–distance units per squared elementary charge, $q_1$ and $q_2$ the charges in units of the elementary charge, and the reference chosen such that $U_{\\mathrm{elec}}^{\\mathrm{PME}}(r)\\to 0$ as $r\\to\\infty$.\n- With a spherical cutoff of radius $r_c$ and a conducting boundary Reaction Field (RF), the electrostatic term for $r<r_c$ is\n$$\nU_{\\mathrm{elec}}^{\\mathrm{RF}}(r;r_c)=\\frac{k_c\\,q_1 q_2}{\\varepsilon_r}\\left[\\frac{1}{r}+\\frac{1}{2}\\frac{r^2}{r_c^3}-\\frac{3}{2}\\frac{1}{r_c}\\right],\n$$\nand $U_{\\mathrm{elec}}^{\\mathrm{RF}}(r;r_c)=0$ for $r\\ge r_c$. This choice makes the potential continuous and the force vanish at $r=r_c$ for a conducting exterior.\n\nYour task is to implement a program that:\n1) Computes the PME baseline pairing constant $K_{\\mathrm{PME}}$ using $U(r)=U_{\\mathrm{LJ}}(r)+U_{\\mathrm{elec}}^{\\mathrm{PME}}(r)$.\n2) Computes the RF pairing constant $K_{\\mathrm{RF}}(r_c)$ for each cutoff $r_c$ in a specified test suite using $U(r)=U_{\\mathrm{LJ}}(r)+U_{\\mathrm{elec}}^{\\mathrm{RF}}(r;r_c)$.\n3) Performs an extrapolation of $\\ln K_{\\mathrm{RF}}(r_c)$ versus $1/r_c$ and $1/r_c^3$ to estimate the infinite-cutoff limit $K_{\\infty}$ by fitting\n$$\n\\ln K_{\\mathrm{RF}}(r_c) \\approx a + b \\left(\\frac{1}{r_c}\\right) + c \\left(\\frac{1}{r_c^3}\\right),\n$$\nand setting $K_{\\infty}=\\exp(a)$.\n4) Compares $K_{\\infty}$ to the PME baseline by computing the relative deviation\n$$\n\\delta = \\frac{K_{\\infty}-K_{\\mathrm{PME}}}{K_{\\mathrm{PME}}}.\n$$\n\nUse the following scientifically sound parameters and units:\n- Charges: $q_1=+1$, $q_2=-1$ (elementary charge units).\n- Relative permittivity (water at ambient conditions): $\\varepsilon_r=78.37$ (dimensionless).\n- Coulomb constant in molecular simulation units: $k_c=138.935456$ $\\mathrm{kJ}\\,\\mathrm{nm}\\, \\mathrm{mol}^{-1}\\,e^{-2}$.\n- Lennard–Jones parameters: $\\sigma=0.32$ $\\mathrm{nm}$, $\\varepsilon=0.50$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$.\n- Temperature: $T=298.15$ $\\mathrm{K}$.\n- Gas constant: $R=0.008314462618$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$.\n- Bound-state cutoff: $r_b=0.40$ $\\mathrm{nm}$.\n- Cutoff test suite (all in nanometers): $[0.45,0.90,1.20,1.50,2.00,3.00]$.\n\nImplementation requirements:\n- Evaluate the integral for $K$ by numerical quadrature over $r\\in[0,r_b]$ using the provided potential models. Ensure numerical stability near $r=0$, where $U_{\\mathrm{LJ}}(r)\\to +\\infty$, by relying on the fact that $\\exp(-\\beta U(r))\\to 0$.\n- Express all computed pairing constants $K$ in $\\mathrm{nm}^3$.\n- The final outputs are floating-point numbers rounded to six decimal places.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in this exact order:\n$$\n\\left[ K_{\\mathrm{PME}},\\; K_{\\mathrm{RF}}(0.45),\\; K_{\\mathrm{RF}}(0.90),\\; K_{\\mathrm{RF}}(1.20),\\; K_{\\mathrm{RF}}(1.50),\\; K_{\\mathrm{RF}}(2.00),\\; K_{\\mathrm{RF}}(3.00),\\; K_{\\infty},\\; \\delta \\right],\n$$\nwhere each $K$ is in $\\mathrm{nm}^3$ and $\\delta$ is a dimensionless decimal fraction. Round all values to six decimal places.\n\nTest suite coverage rationale:\n- $r_c=0.45$ $\\mathrm{nm}$ probes a near-boundary case with $r_c\\approx r_b$.\n- $r_c=0.90$ $\\mathrm{nm}$ and $r_c=1.20$ $\\mathrm{nm}$ probe common moderate cutoffs.\n- $r_c=1.50$ $\\mathrm{nm}$ and $r_c=2.00$ $\\mathrm{nm}$ approach long-range conditions.\n- $r_c=3.00$ $\\mathrm{nm}$ approximates the asymptotic regime to stabilize the extrapolation.", "solution": "The problem statement has been critically validated and is determined to be sound. It is scientifically grounded in established principles of statistical mechanics and computational chemistry, well-posed with a complete and consistent set of parameters, and formally structured to admit a unique, verifiable solution. The task is to quantify the error introduced by a common electrostatic cutoff method (Reaction Field) in molecular simulations by comparing it to a more accurate baseline (unscreened Coulomb, representing Particle Mesh Ewald at infinite dilution) and then extrapolating the cutoff-dependent results to an infinite cutoff limit.\n\nWe will proceed with a step-by-step solution based on the provided models and parameters.\n\nFirst, we define the constants and parameters in a consistent set of units ($\\mathrm{nm}$, $\\mathrm{kJ}$, $\\mathrm{mol}$, $\\mathrm{K}$, $e$).\n-   Charges (elementary units): $q_1 = +1$, $q_2 = -1$\n-   Relative permittivity of the medium: $\\varepsilon_r = 78.37$\n-   Coulomb constant: $k_c = 138.935456\\,\\mathrm{kJ}\\,\\mathrm{nm}\\,\\mathrm{mol}^{-1}\\,e^{-2}$\n-   Lennard-Jones parameters: $\\sigma = 0.32\\,\\mathrm{nm}$, $\\varepsilon = 0.50\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$\n-   Absolute temperature: $T = 298.15\\,\\mathrm{K}$\n-   Ideal gas constant: $R = 0.008314462618\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$\n-   Bound-state integration limit: $r_b = 0.40\\,\\mathrm{nm}$\n-   Reaction Field cutoff radii for the test suite: $r_{c,\\mathrm{suite}} = [0.45, 0.90, 1.20, 1.50, 2.00, 3.00]\\,\\mathrm{nm}$\n\nThe Boltzmann factor requires the inverse thermal energy, $\\beta$:\n$$ \\beta = \\frac{1}{RT} = \\frac{1}{(0.008314462618\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1})(298.15\\,\\mathrm{K})} \\approx 0.4033955\\,\\mathrm{mol}\\,\\mathrm{kJ}^{-1} $$\n\nThe total pair potential, $U(r)$, is the sum of a Lennard–Jones term, $U_{\\mathrm{LJ}}(r)$, and an electrostatic term, $U_{\\mathrm{elec}}(r)$.\nThe Lennard–Jones potential is given by:\n$$ U_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12}-\\left(\\frac{\\sigma}{r}\\right)^{6}\\right] = 4(0.50)\\left[\\left(\\frac{0.32}{r}\\right)^{12}-\\left(\\frac{0.32}{r}\\right)^{6}\\right] $$\nThis term models the short-range Pauli repulsion ($r^{-12}$) and van der Waals dispersion attraction ($r^{-6}$).\n\nThe electrostatic potential has two variants. For the PME baseline, it is the unscreened Coulomb potential:\n$$ U_{\\mathrm{elec}}^{\\mathrm{PME}}(r) = \\frac{k_c\\,q_1 q_2}{\\varepsilon_r r} = \\frac{(138.935456)(+1)(-1)}{78.37\\,r} = -\\frac{1.772861}{r} $$\nThe total potential for the PME baseline is $U_{\\mathrm{PME}}(r) = U_{\\mathrm{LJ}}(r) + U_{\\mathrm{elec}}^{\\mathrm{PME}}(r)$.\n\nFor the Reaction Field method with cutoff $r_c$, the potential for $r < r_c$ is:\n$$ U_{\\mathrm{elec}}^{\\mathrm{RF}}(r;r_c) = \\frac{k_c\\,q_1 q_2}{\\varepsilon_r}\\left[\\frac{1}{r}+\\frac{1}{2}\\frac{r^2}{r_c^3}-\\frac{3}{2}\\frac{1}{r_c}\\right] = -\\frac{1.772861}{1}\\left[\\frac{1}{r}+\\frac{r^2}{2r_c^3}-\\frac{3}{2r_c}\\right] $$\nThe integration limit $r_b=0.40\\,\\mathrm{nm}$ is smaller than all specified $r_c$ values, so the potential is always evaluated using this formula over the entire integration domain. The total potential for the RF method is $U_{\\mathrm{RF}}(r;r_c) = U_{\\mathrm{LJ}}(r) + U_{\\mathrm{elec}}^{\\mathrm{RF}}(r;r_c)$.\n\nThe pairing constant, $K$, is computed by numerically integrating the following expression from $r=0$ to $r=r_b$:\n$$ K = \\int_{0}^{r_b} 4\\pi r^2 \\exp\\left(-\\beta U(r)\\right)\\,dr $$\nThe term $4\\pi r^2$ is the spherical shell volume element, and $\\exp(-\\beta U(r))$ is the Boltzmann factor representing the relative probability of finding the ion pair at separation $r$. The integrand correctly approaches $0$ as $r \\to 0$ because the strongly repulsive $r^{-12}$ term in $U_{\\mathrm{LJ}}(r)$ causes the exponential to decay faster than $r^2$ grows.\n\nThe calculation proceeds in four stages:\n1.  **Compute $K_{\\mathrm{PME}}$**: We evaluate the integral for $K$ using the potential $U_{\\mathrm{PME}}(r)$.\n    $$ K_{\\mathrm{PME}} = \\int_{0}^{0.40} 4\\pi r^2 \\exp\\left(-\\beta U_{\\mathrm{PME}}(r)\\right)\\,dr $$\n\n2.  **Compute $K_{\\mathrm{RF}}(r_c)$**: For each $r_c$ in the test suite, we evaluate the integral using the corresponding potential $U_{\\mathrm{RF}}(r;r_c)$.\n    $$ K_{\\mathrm{RF}}(r_c) = \\int_{0}^{0.40} 4\\pi r^2 \\exp\\left(-\\beta U_{\\mathrm{RF}}(r;r_c)\\right)\\,dr $$\n\n3.  **Extrapolate to find $K_{\\infty}$**: We perform a linear least-squares fit to the model:\n    $$ \\ln K_{\\mathrm{RF}}(r_c) = a + b \\left(\\frac{1}{r_c}\\right) + c \\left(\\frac{1}{r_c^3}\\right) $$\n    This is equivalent to solving the linear system $A\\mathbf{p} = \\mathbf{y}$ for the parameter vector $\\mathbf{p}=[a, b, c]^T$, where $\\mathbf{y}$ is the vector of computed $\\ln K_{\\mathrm{RF}}(r_c)$ values and $A$ is the design matrix whose rows are $[1, 1/r_c, 1/r_c^3]$ for each $r_c$. The intercept $a$ from the fit represents the extrapolated value of $\\ln K$ at infinite cutoff ($1/r_c \\to 0$). Therefore, the extrapolated pairing constant is $K_{\\infty} = \\exp(a)$.\n\n4.  **Compute relative deviation $\\delta$**: Finally, we compute the relative deviation of the extrapolated value from the PME baseline, which serves as a measure of the systematic bias of the RF method in the infinite cutoff limit.\n    $$ \\delta = \\frac{K_{\\infty}-K_{\\mathrm{PME}}}{K_{\\mathrm{PME}}} $$\n\nAll integrals will be computed using numerical quadrature, and the least-squares fit will be performed using standard numerical linear algebra routines. The final results will be rounded to six decimal places as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes and compares ion pairing constants for PME and Reaction Field models.\n    \"\"\"\n    \n    # Define physical and model parameters\n    q1 = 1.0  # Elementary charge units\n    q2 = -1.0 # Elementary charge units\n    eps_r = 78.37  # Dimensionless relative permittivity\n    k_c = 138.935456  # kJ nm mol^-1 e^-2\n    sigma = 0.32  # nm\n    epsilon = 0.50  # kJ mol^-1\n    T = 298.15  # K\n    R = 0.008314462618  # kJ mol^-1 K^-1\n    r_b = 0.40  # nm\n    rc_suite = [0.45, 0.90, 1.20, 1.50, 2.00, 3.00] # nm\n\n    # Calculate inverse thermal energy\n    beta = 1.0 / (R * T)\n\n    # Pre-calculate electrostatic constant factor\n    k_elec = k_c * q1 * q2 / eps_r\n\n    # Define potential energy functions\n    def u_lj(r):\n        \"\"\"Lennard-Jones potential.\"\"\"\n        # Handle r=0 case to avoid division by zero\n        if r == 0:\n            return np.inf\n        sr6 = (sigma / r)**6\n        return 4.0 * epsilon * (sr6**2 - sr6)\n\n    def u_elec_pme(r):\n        \"\"\"PME (unscreened Coulomb) electrostatic potential.\"\"\"\n        if r == 0:\n            return -np.inf # Attractive potential\n        return k_elec / r\n\n    def u_elec_rf(r, rc):\n        \"\"\"Reaction Field electrostatic potential for r < rc.\"\"\"\n        if r == 0:\n            return -np.inf\n        return k_elec * (1.0/r + 0.5 * r**2 / rc**3 - 1.5 / rc)\n\n    # Define total potential energy functions\n    def u_pme(r):\n        return u_lj(r) + u_elec_pme(r)\n\n    def u_rf(r, rc):\n        return u_lj(r) + u_elec_rf(r, rc)\n\n    # Define integrands for the pairing constant K\n    def integrand_pme(r):\n        potential = u_pme(r)\n        # The exp(-beta*U) will be zero for large U, avoiding overflow\n        boltzmann_factor = np.exp(-beta * potential) if potential < 700 else 0.0\n        return 4.0 * np.pi * r**2 * boltzmann_factor\n\n    def integrand_rf(r, rc):\n        potential = u_rf(r, rc)\n        boltzmann_factor = np.exp(-beta * potential) if potential < 700 else 0.0\n        return 4.0 * np.pi * r**2 * boltzmann_factor\n\n    # 1. Compute PME baseline pairing constant K_PME\n    k_pme, _ = integrate.quad(integrand_pme, 0, r_b)\n\n    # 2. Compute RF pairing constants for the test suite\n    k_rf_values = []\n    for rc in rc_suite:\n        # Pass rc to the integrand using the args parameter\n        k_rf, _ = integrate.quad(integrand_rf, 0, r_b, args=(rc,))\n        k_rf_values.append(k_rf)\n    \n    # 3. Perform extrapolation to find K_infinity\n    k_rf_array = np.array(k_rf_values)\n    rc_array = np.array(rc_suite)\n    \n    # Dependent variable y = ln(K_RF)\n    y = np.log(k_rf_array)\n    \n    # Independent variables: 1/rc and 1/rc^3\n    rc_inv = 1.0 / rc_array\n    rc_inv3 = rc_inv**3\n    \n    # Construct the design matrix A for least-squares fitting\n    # A has columns for the constant term (a), 1/rc term (b), and 1/rc^3 term (c)\n    A = np.vstack([np.ones(len(rc_array)), rc_inv, rc_inv3]).T\n    \n    # Solve the linear least-squares problem A*p = y for p = [a, b, c]\n    p, _, _, _ = np.linalg.lstsq(A, y, rcond=None)\n    a = p[0]\n    \n    # Calculate K_infinity from the intercept 'a'\n    k_infinity = np.exp(a)\n\n    # 4. Compute the relative deviation\n    delta = (k_infinity - k_pme) / k_pme\n\n    # Collect all results\n    all_results = [k_pme] + k_rf_values + [k_infinity, delta]\n    \n    # Format results to six decimal places\n    formatted_results = [f\"{val:.6f}\" for val in all_results]\n    \n    # Print the final output in the specified format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3131560"}, {"introduction": "The power of molecular simulation lies in its ability to model large, complex systems, but this requires computationally efficient algorithms. A direct, all-pairs calculation of interactions scales quadratically with the number of particles, $O(N^2)$, quickly becoming intractable for large systems. This practice explores a foundational technique to overcome this barrier: the linked-cell method, which can reduce the complexity to be linear, $O(N)$, for short-ranged forces [@problem_id:3131669]. By identifying the performance crossover point, you will gain a practical understanding of why algorithmic choices are as important as the physical model itself for enabling large-scale simulations.", "problem": "You are to study the algorithmic cost of evaluating short-ranged pairwise interactions in a simple molecular simulation by comparing a direct all-pairs method with a linked-cell neighbor enumeration method. The scientific base for this task is that typical molecular mechanics force fields are pairwise additive and truncated at a finite cutoff, so that only particle pairs separated by less than a specified cutoff distance contribute to the energy and forces. You should proceed from the following foundations:\n- Newton’s laws of motion and the definition of pairwise additive potentials imply that the total potential energy is a sum over unordered particle pairs, and by Newton’s third law each pair needs to be considered only once.\n- For short-ranged interactions with a finite cutoff $r_c$, particles beyond $r_c$ do not interact, so it is sufficient to restrict candidate pairs to those that are possibly within the cutoff.\n- The cost of these algorithms is dominated by the number of particle-pair distance comparisons, which is a physically meaningful proxy for the computational effort required to evaluate a short-ranged force field.\n\nYour program must implement both strategies and count how many candidate pair distance comparisons each strategy makes, then determine the smallest system size where the linked-cell method performs fewer comparisons than the all-pairs method, for each specified number density. All calculations are in reduced units: Lennard–Jones (LJ) reduced length $\\sigma$ with $\\sigma = 1$, and a cutoff $r_c = 2.5 \\sigma$. The system is a cubic box with periodic boundary conditions (PBC), uniformly populated with $N$ particles at number density $\\rho$, so the box length is $L = (N/\\rho)^{1/3}$.\n\nDefinitions and requirements:\n- All-pairs baseline:\n  - The all-pairs method is defined as checking every unordered pair exactly once. Its candidate distance comparison count is $C_{\\text{naive}}(N) = N(N-1)/2$.\n- Linked-cell neighbor enumeration:\n  - Use a cubic cell grid with cell edge length equal to the cutoff, that is cell size $= r_c$.\n  - Let $M = \\max(1, \\lfloor L / r_c \\rfloor)$ be the number of cells per spatial dimension, so there are $M^3$ cells in total under PBC. Each particle is assigned to one cell.\n  - The linked-cell method first bins all particles into cells (count this binning step as an additive cost of $N$), then enumerates candidate pairs by considering only pairs of particles that lie in the same cell or in one of the $26$ neighboring cells under PBC. To avoid double counting unordered pairs, use lexicographic ordering on the linearized cell indices: for a cell with linear index $i$, only form cross-cell candidate pairs with neighboring cells whose linear index is strictly greater than $i$. Within a single cell, form unordered pairs once (that is, as combinations with $j>i$). The total candidate pair distance comparisons for the linked-cell method is the sum of all within-cell unordered pairs plus these cross-cell products, plus the binning overhead $N$.\n  - Use PBC in the cell indexing by wrapping cell coordinates modulo $M$.\n- Initial conditions:\n  - For each case, generate $N$ particle positions uniformly and independently in $[0, L)$ along each Cartesian axis. Use a fixed seed for reproducibility; you must reseed deterministically for each case so that results are deterministic. For example, you may use a base seed $s = 12345$ and increment it by $1$ for each case in the order specified below.\n\nYour task:\n- For each specified number density $\\rho$, and for each candidate system size $N$ in a given grid, compute:\n  - $C_{\\text{naive}}(N)$,\n  - $C_{\\text{cell}}(N,\\rho)$ as defined above (linked-cell candidate enumeration plus binning overhead),\n  and identify the smallest $N$ in the grid such that $C_{\\text{cell}}(N,\\rho) < C_{\\text{naive}}(N)$.\n- If no such $N$ exists within the grid for a given $\\rho$, report $-1$ for that $\\rho$.\n\nTest suite:\n- Use reduced units with $\\sigma = 1$ and $r_c = 2.5$.\n- Number densities $\\rho$ to test: $\\{0.01, 0.1, 0.8\\}$, in that order.\n- Candidate system sizes $N$ to test (the search grid): $[16, 32, 48, 64, 96, 128, 192, 256, 320, 384, 448, 512]$.\n- Periodic boundary conditions must be enforced in the cell indexing. Angles are not used. No physical unit conversion is required because reduced units are used.\n\nFinal output format:\n- Your program should produce a single line of output containing the crossover $N$ values as a comma-separated list of integers enclosed in square brackets, in the same order as the densities appear in the test suite. For example, the output must look like $[n_1,n_2,n_3]$ where each $n_k$ is an integer crossover $N$ or $-1$ if not found.\n\nYour program must be complete and self-contained, perform the computations as specified, and print exactly one line in the format above. No other output is permitted.", "solution": "The problem requires a comparison of the computational cost of two distinct algorithms for enumerating candidate particle pairs for short-ranged interaction calculations in a molecular simulation. The cost is quantified by the number of distance comparisons, a proxy for the computational work. The two algorithms are a direct all-pairs method and a linked-cell neighbor list method. We are tasked with finding the smallest system size `$N$`, from a given set of sizes, at which the linked-cell method becomes more efficient than the all-pairs method for several specified number densities `$\\rho$`.\n\nThe system under consideration is a cubic box of volume `$V$` containing `$N$` particles at a uniform number density `$\\rho = N/V$`. The box has side length `$L = V^{1/3} = (N/\\rho)^{1/3}$`. Periodic boundary conditions (PBC) are applied, meaning the box is effectively replicated infinitely in all three spatial dimensions. Interactions are truncated at a cutoff distance `$r_c = 2.5$`, where all lengths are in reduced units of `$\\sigma=1$`.\n\nFirst, we define the cost function for the all-pairs or \"naive\" method. This method considers every unique pair of particles in the system. For a system of `$N$` particles, the number of unordered pairs is given by the binomial coefficient `$\\binom{N}{2}$`. Therefore, the cost of the naive method, `$C_{\\text{naive}}$`, is:\n$$\nC_{\\text{naive}}(N) = \\frac{N(N-1)}{2}\n$$\nThis cost scales as `$O(N^2)$`, which becomes computationally prohibitive for large systems.\n\nNext, we define the cost function for the linked-cell method, `$C_{\\text{cell}}$`. This method aims to reduce the computational complexity by exploiting the short-ranged nature of the interactions. It does so by spatially decomposing the domain.\n1.  The simulation box is divided into a grid of `$M^3$` identical cubic cells. The side length of each cell is chosen to be equal to the interaction cutoff, `$r_c$`. The number of cells along each dimension, `$M$`, is given by `$M = \\max(1, \\lfloor L/r_c \\rfloor)$`. The `$\\max(1, ...)$` term handles cases where the box length `$L$` is smaller than `$r_c$`, ensuring there is at least one cell.\n2.  Each of the `$N$` particles is assigned to one of these `$M^3$` cells based on its position. This binning process requires a single pass over all particles, and its computational cost is defined as being an additive term of `$N$`.\n3.  Candidate pairs are then enumerated by considering only pairs of particles that reside either in the same cell or in adjacent cells. By construction, any two particles separated by a distance greater than `$r_c$` cannot be in the same or adjacent cells, thus correctly excluding them from consideration.\nThe total cost, `$C_{\\text{cell}}$`, is the sum of the binning overhead, the cost of within-cell pair enumeration, and the cost of cross-cell pair enumeration.\n$$\nC_{\\text{cell}}(N, \\rho) = N + \\sum_{k=0}^{M^3-1} \\frac{n_k(n_k-1)}{2} + \\sum_{i=0}^{M^3-1} \\sum_{\\substack{j \\in \\text{neighbors}(i) \\\\ j > i}} n_i n_j\n$$\nwhere `$n_k$` is the number of particles in cell `$k$`. The first term is the binning overhead. The second term is the sum of all unordered pairs within each cell. The third term is the sum of pairs between particles in a cell `$i$` and its neighboring cells `$j$`. To comply with Newton's third law and avoid double counting, each pair of cells `$(i, j)$` must be considered only once. The problem specifies a robust method for this: use lexicographic ordering on the linearized cell indices. For each cell `$i$`, we only form pairs with its neighboring cells `$j$` for which the linear index `$j$` is strictly greater than `$i$`. This ensures that the pair `$(i, j)$` is counted, but `$(j, i)` is not. Periodic boundary conditions are handled by applying modulo `$M$` arithmetic when determining the indices of neighboring cells.\n\nFor each specified density `$\\rho \\in \\{0.01, 0.1, 0.8\\}$`, the procedure is as follows:\n1.  A deterministic seed, unique to each `$\\rho$`, is used to initialize the random number generator. The base seed is `$12345$`, incremented by one for each subsequent density.\n2.  For each candidate system size `$N$` in the grid `$[16, 32, ..., 512]$`, `$N$` particle positions are generated uniformly within the box `$[0, L)^3$`.\n3.  The costs `$C_{\\text{naive}}(N)$` and `$C_{\\text{cell}}(N, \\rho)$` are computed based on this specific particle configuration.\n4.  The condition `$C_{\\text{cell}}(N, \\rho) < C_{\\text{naive}}(N)$` is checked. The smallest value of `$N$` from the grid that satisfies this inequality is identified as the crossover point for that density.\n5.  If no `$N$` in the grid satisfies the condition, a value of `$-1$` is reported for that density.\n\nThe following program systematically implements this procedure. For each `$(\\rho, N)` pair, it simulates the particle binning and calculates the two cost functions as defined, then identifies and reports the crossover points.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the crossover system size N where the linked-cell method becomes\n    more efficient than the all-pairs method for given densities.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_suite = {\n        'rc': 2.5,\n        'densities': [0.01, 0.1, 0.8],\n        'N_grid': [16, 32, 48, 64, 96, 128, 192, 256, 320, 384, 448, 512],\n        'base_seed': 12345,\n    }\n\n    rc = test_suite['rc']\n    densities = test_suite['densities']\n    N_grid = test_suite['N_grid']\n    base_seed = test_suite['base_seed']\n\n    crossover_results = []\n    \n    current_seed = base_seed\n    \n    for rho in densities:\n        crossover_N = -1\n        found_crossover = False\n        \n        for N in N_grid:\n            # Step 1: Calculate system parameters\n            L = (N / rho)**(1.0/3.0)\n            M = max(1, int(np.floor(L / rc)))\n            \n            # Step 2: Generate particle positions deterministically\n            np.random.seed(current_seed)\n            positions = np.random.uniform(0.0, L, size=(N, 3))\n            \n            # Step 3: Bin particles into cells\n            # Calculate 3D cell indices for each particle\n            cell_coords = np.floor(positions / rc).astype(int)\n            # Clip coordinates to be within [0, M-1] just in case of float precision issues at L\n            cell_coords = np.clip(cell_coords, 0, M - 1)\n            \n            # Convert 3D cell coordinates to 1D linear indices\n            linear_indices = cell_coords[:, 0] + cell_coords[:, 1] * M + cell_coords[:, 2] * M * M\n            \n            # Count number of particles in each cell\n            particle_counts = np.bincount(linear_indices, minlength=M**3)\n\n            # Step 4: Calculate C_cell\n            # Cost starts with the N operations for binning particles\n            C_cell = N\n            \n            # Add cost of within-cell pairs: n*(n-1)/2\n            C_cell += np.sum(particle_counts * (particle_counts - 1) // 2)\n\n            # Add cost of cross-cell pairs using the j > i rule\n            for i in range(M**3):\n                n_i = particle_counts[i]\n                if n_i == 0:\n                    continue\n                \n                # De-linearize index i to get its 3D coordinates (ix, iy, iz)\n                iz = i // (M * M)\n                iy = (i % (M * M)) // M\n                ix = i % M\n                \n                # Iterate through the 26 neighbor cell offsets\n                for dz in range(-1, 2):\n                    for dy in range(-1, 2):\n                        for dx in range(-1, 2):\n                            if dx == 0 and dy == 0 and dz == 0:\n                                continue\n\n                            # Apply periodic boundary conditions to get neighbor coordinates\n                            nx = (ix + dx) % M\n                            ny = (iy + dy) % M\n                            nz = (iz + dz) % M\n                            \n                            # Linearize neighbor index j\n                            j = nx + ny * M + nz * M * M\n                            \n                            # Apply the rule to avoid double counting\n                            if j > i:\n                                n_j = particle_counts[j]\n                                C_cell += n_i * n_j\n            \n            # Step 5: Calculate C_naive\n            C_naive = N * (N - 1) // 2\n            \n            # Step 6: Check for crossover\n            if not found_crossover and C_cell < C_naive:\n                crossover_N = N\n                found_crossover = True\n        \n        crossover_results.append(crossover_N)\n        current_seed += 1\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, crossover_results))}]\")\n\nsolve()\n```", "id": "3131669"}]}