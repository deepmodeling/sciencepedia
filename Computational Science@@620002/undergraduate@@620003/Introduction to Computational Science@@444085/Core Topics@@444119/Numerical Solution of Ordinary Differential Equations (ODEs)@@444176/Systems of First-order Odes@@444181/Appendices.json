{"hands_on_practices": [{"introduction": "Many physical phenomena, from molecular vibrations to electrical circuits, are best described as systems of coupled oscillators. This first practice invites you to model such a system—a pair of magnetically coupled LC circuits—and translate the physical laws into a system of first-order ordinary differential equations [@problem_id:2444847]. By analyzing this system, you will uncover its normal-mode frequencies, which correspond to the natural, collective oscillation patterns of the coupled components. This exercise is fundamental for understanding how the mathematical structure of a system, specifically its eigenvalues, dictates its physical behavior.", "problem": "Two identical lossless resistor-inductor-capacitor (RLC) loops are magnetically coupled via mutual inductance. Each loop consists of an inductor of inductance $L$ in series with a capacitor of capacitance $C$, and the resistive losses are negligible so that $R=0$. The two inductors are wound and oriented such that the mutual inductance $M$ is positive, with $0ML$. Let the loop currents $i_{1}(t)$ and $i_{2}(t)$ be defined in the directions that make the mutual coupling terms positive in the inductor voltage relations. Let $q_{1}(t)$ and $q_{2}(t)$ be the charges on the capacitors, defined so that the capacitor voltages are $v_{C1}(t)=q_{1}(t)/C$ and $v_{C2}(t)=q_{2}(t)/C$. The inductor voltage relations are\n$$\nv_{L1}(t)=L\\,\\frac{d i_{1}}{d t}(t)+M\\,\\frac{d i_{2}}{d t}(t),\\qquad\nv_{L2}(t)=M\\,\\frac{d i_{1}}{d t}(t)+L\\,\\frac{d i_{2}}{d t}(t),\n$$\nand the current-charge relations are $i_{1}(t)=\\frac{d q_{1}}{d t}(t)$ and $i_{2}(t)=\\frac{d q_{2}}{d t}(t)$. Each loop is closed on itself, and there are no external sources.\n\nStarting from Kirchhoff’s voltage law applied to each loop and the element constitutive relations above, do the following:\n\n- Derive the coupled first-order ordinary differential equations for the state vector $x(t)=\\big(i_{1}(t),\\,i_{2}(t),\\,q_{1}(t),\\,q_{2}(t)\\big)^{\\mathsf{T}}$.\n\n- From this system, determine the two undamped normal-mode angular frequencies of the coupled system. List the two positive angular frequencies in increasing order as exact symbolic expressions in terms of $L$, $C$, and $M$.\n\nExpress the final angular frequencies in radians per second. Provide the final answer as exact symbolic expressions; no numerical substitution or rounding is required.", "solution": "The problem is first validated for scientific soundness, well-posedness, and objectivity.\n\n**Step 1: Extract Givens**\n-   System: Two identical lossless resistor-inductor-capacitor loops, with resistance $R=0$.\n-   Components: Each loop has an inductor with self-inductance $L$ and a capacitor with capacitance $C$.\n-   Coupling: The loops are coupled by a mutual inductance $M$, with the constraint $0  M  L$.\n-   Variables: Loop currents are $i_{1}(t)$ and $i_{2}(t)$; capacitor charges are $q_{1}(t)$ and $q_{2}(t)$.\n-   State vector: $x(t) = \\big( i_{1}(t), i_{2}(t), q_{1}(t), q_{2}(t) \\big)^{\\mathsf{T}}$.\n-   Constitutive Relations:\n    -   Inductor voltages: $v_{L1}(t) = L \\frac{d i_{1}}{d t} + M \\frac{d i_{2}}{d t}$, and $v_{L2}(t) = M \\frac{d i_{1}}{d t} + L \\frac{d i_{2}}{d t}$.\n    -   Capacitor voltages: $v_{C1}(t) = q_{1}(t)/C$, and $v_{C2}(t) = q_{2}(t)/C$.\n    -   Current-charge relations: $i_{1}(t) = \\frac{d q_{1}}{d t}$, and $i_{2}(t) = \\frac{d q_{2}}{d t}$.\n-   Governing Law: Kirchhoff’s voltage law (KVL) for closed loops with no sources.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientific Grounding**: The problem describes a classic physical system of coupled LC oscillators based on fundamental principles of electromagnetism (KVL, inductance, capacitance). The constraint $0  M  L$ is physically realistic for coupled inductors. The problem is scientifically sound.\n-   **Well-Posedness**: All necessary parameters ($L$, $C$, $M$) and relationships are provided to establish a system of linear ordinary differential equations. The task of finding normal-mode frequencies is a well-defined eigenvalue problem that guarantees a unique set of solutions.\n-   **Objectivity**: The problem is stated using precise, unambiguous technical language.\n\n**Step 3: Verdict and Action**\nThe problem is deemed valid. A solution will be derived.\n\n**Derivation of the System of Equations**\n\nWe apply Kirchhoff's voltage law to each of the two closed loops. Since there are no resistors ($R=0$) and no external voltage sources, the sum of the voltage drops across the inductor and capacitor in each loop must be zero.\n\nFor the first loop:\n$$v_{L1}(t) + v_{C1}(t) = 0$$\nSubstituting the given constitutive relations:\n$$L \\frac{d i_{1}}{d t} + M \\frac{d i_{2}}{d t} + \\frac{q_{1}}{C} = 0 \\quad (1)$$\n\nFor the second loop:\n$$v_{L2}(t) + v_{C2}(t) = 0$$\nSubstituting the given constitutive relations:\n$$M \\frac{d i_{1}}{d t} + L \\frac{d i_{2}}{d t} + \\frac{q_{2}}{C} = 0 \\quad (2)$$\n\nThese two equations form a system of coupled differential equations. We must now express them in the form of a first-order system for the state vector $x(t) = (i_{1}, i_{2}, q_{1}, q_{2})^{\\mathsf{T}}$. To do this, we first need to solve equations $(1)$ and $(2)$ for the derivatives $\\frac{d i_{1}}{d t}$ and $\\frac{d i_{2}}{d t}$. In matrix form, the system is:\n$$\n\\begin{pmatrix} L  M \\\\ M  L \\end{pmatrix} \\begin{pmatrix} \\frac{d i_{1}}{d t} \\\\ \\frac{d i_{2}}{d t} \\end{pmatrix} = - \\begin{pmatrix} \\frac{q_{1}}{C} \\\\ \\frac{q_{2}}{C} \\end{pmatrix}\n$$\nThe inductance matrix is $\\mathbf{L} = \\begin{pmatrix} L  M \\\\ M  L \\end{pmatrix}$. Its determinant is $\\det(\\mathbf{L}) = L^{2} - M^{2}$. Since it is given that $0  M  L$, the determinant is non-zero, and the matrix is invertible. The inverse is:\n$$\n\\mathbf{L}^{-1} = \\frac{1}{L^{2} - M^{2}} \\begin{pmatrix} L  -M \\\\ -M  L \\end{pmatrix}\n$$\nMultiplying by $\\mathbf{L}^{-1}$ yields expressions for the time derivatives of the currents:\n$$\n\\begin{pmatrix} \\frac{d i_{1}}{d t} \\\\ \\frac{d i_{2}}{d t} \\end{pmatrix} = -\\frac{1}{C(L^{2} - M^{2})} \\begin{pmatrix} L  -M \\\\ -M  L \\end{pmatrix} \\begin{pmatrix} q_{1} \\\\ q_{2} \\end{pmatrix}\n$$\nThis gives us:\n$$\n\\frac{d i_{1}}{d t} = -\\frac{L}{C(L^{2} - M^{2})} q_{1} + \\frac{M}{C(L^{2} - M^{2})} q_{2}\n$$\n$$\n\\frac{d i_{2}}{d t} = \\frac{M}{C(L^{2} - M^{2})} q_{1} - \\frac{L}{C(L^{2} - M^{2})} q_{2}\n$$\nThe remaining two first-order equations are given by the definition of current:\n$$\n\\frac{d q_{1}}{d t} = i_{1}\n$$\n$$\n\\frac{d q_{2}}{d t} = i_{2}\n$$\nWe can now assemble the complete system of first-order ODEs, $\\frac{d x}{d t} = \\mathbf{A} x$:\n$$\n\\frac{d}{dt} \\begin{pmatrix} i_{1} \\\\ i_{2} \\\\ q_{1} \\\\ q_{2} \\end{pmatrix} = \\begin{pmatrix}\n0  0  -\\frac{L}{C(L^{2} - M^{2})}  \\frac{M}{C(L^{2} - M^{2})} \\\\\n0  0  \\frac{M}{C(L^{2} - M^{2})}  -\\frac{L}{C(L^{2} - M^{2})} \\\\\n1  0  0  0 \\\\\n0  1  0  0\n\\end{pmatrix} \\begin{pmatrix} i_{1} \\\\ i_{2} \\\\ q_{1} \\\\ q_{2} \\end{pmatrix}\n$$\nThis completes the first part of the problem.\n\n**Determination of Normal-Mode Frequencies**\n\nThe normal-mode angular frequencies $\\omega$ are related to the eigenvalues $\\lambda$ of the state matrix $\\mathbf{A}$. For an oscillatory system, solutions are of the form $x(t) = x_{0} \\exp(i\\omega t)$, where $i$ is the imaginary unit. This implies $\\frac{dx}{dt} = i\\omega x$, so the eigenvalues of $\\mathbf{A}$ are $\\lambda = i\\omega$. We find these eigenvalues by solving the characteristic equation $\\det(\\mathbf{A} - \\lambda \\mathbf{I}) = 0$.\n\nThe characteristic equation is:\n$$\n\\det \\begin{pmatrix}\n-\\lambda  0  -\\frac{L}{C(L^{2} - M^{2})}  \\frac{M}{C(L^{2} - M^{2})} \\\\\n0  -\\lambda  \\frac{M}{C(L^{2} - M^{2})}  -\\frac{L}{C(L^{2} - M^{2})} \\\\\n1  0  -\\lambda  0 \\\\\n0  1  0  -\\lambda\n\\end{pmatrix} = 0\n$$\nAn efficient way to solve this is to use the property of block matrix determinants. Let $\\mathbf{A} = \\begin{pmatrix} \\mathbf{0}  \\mathbf{K} \\\\ \\mathbf{I}  \\mathbf{0} \\end{pmatrix}$, where $\\mathbf{K} = \\frac{1}{C(L^2 - M^2)}\\begin{pmatrix} -L  M \\\\ M  -L \\end{pmatrix}$. The characteristic equation becomes $\\det(\\lambda^2 \\mathbf{I} - \\mathbf{K}) = 0$. This implies that $\\lambda^2$ must be an eigenvalue of the submatrix $\\mathbf{K}$.\n\nLet's find the eigenvalues $\\mu$ of $\\mathbf{K}$:\n$$\n\\det(\\mathbf{K} - \\mu \\mathbf{I}) = \\det \\begin{pmatrix} -\\frac{L}{C(L^{2} - M^{2})} - \\mu  \\frac{M}{C(L^{2} - M^{2})} \\\\ \\frac{M}{C(L^{2} - M^{2})}  -\\frac{L}{C(L^{2} - M^{2})} - \\mu \\end{pmatrix} = 0\n$$\n$$\n\\left(-\\frac{L}{C(L^{2} - M^{2})} - \\mu\\right)^2 - \\left(\\frac{M}{C(L^{2} - M^{2})}\\right)^2 = 0\n$$\nThis is a difference of squares, leading to two solutions for $\\mu$:\n$$\n-\\frac{L}{C(L^{2} - M^{2})} - \\mu = \\pm \\frac{M}{C(L^{2} - M^{2})}\n$$\n$$\n\\mu = -\\frac{L}{C(L^{2} - M^{2})} \\mp \\frac{M}{C(L^{2} - M^{2})} = -\\frac{L \\mp M}{C(L-M)(L+M)}\n$$\nThe two eigenvalues $\\mu$ are:\n$$\n\\mu_{1} = -\\frac{L - M}{C(L-M)(L+M)} = -\\frac{1}{C(L+M)}\n$$\n$$\n\\mu_{2} = -\\frac{L + M}{C(L-M)(L+M)} = -\\frac{1}{C(L-M)}\n$$\nSince $\\lambda^2 = \\mu$ and we expect undamped oscillations ($\\lambda = i\\omega$, so $\\lambda^2 = -\\omega^2$), we have:\n$$\n-\\omega^2 = \\mu\n$$\nFor the first eigenvalue $\\mu_{1}$:\n$$-\\omega_{1}^{2} = -\\frac{1}{C(L+M)} \\implies \\omega_{1}^{2} = \\frac{1}{C(L+M)}$$\n$$\n\\omega_{1} = \\frac{1}{\\sqrt{C(L+M)}}\n$$\nFor the second eigenvalue $\\mu_{2}$:\n$$\n-\\omega_{2}^{2} = -\\frac{1}{C(L-M)} \\implies \\omega_{2}^{2} = \\frac{1}{C(L-M)}\n$$\n$$\n\\omega_{2} = \\frac{1}{\\sqrt{C(L-M)}}\n$$\nThese are the two positive normal-mode angular frequencies. To list them in increasing order, we compare the denominators. Since $M0$, we have $L+M  L-M$. Therefore, $\\sqrt{C(L+M)}  \\sqrt{C(L-M)}$, which implies $\\frac{1}{\\sqrt{C(L+M)}}  \\frac{1}{\\sqrt{C(L-M)}}$.\n\nThus, the frequencies in increasing order are $\\omega_{1}$ and $\\omega_{2}$.\nThe slower frequency corresponds to the symmetric mode where the currents are in phase ($i_1=i_2$), and the effective inductance is $L+M$.\nThe faster frequency corresponds to the antisymmetric mode where the currents are out of phase ($i_1=-i_2$), and the effective inductance is $L-M$.", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\sqrt{C(L+M)}}  \\frac{1}{\\sqrt{C(L-M)}} \\end{pmatrix}}\n$$", "id": "2444847"}, {"introduction": "While analytical methods are powerful, most real-world ODE systems, especially non-linear ones, do not have closed-form solutions and must be solved numerically. This exercise dives into the heart of computational dynamics by tasking you with implementing two cornerstone integrators—the simple explicit Euler method and the more robust fourth-order Runge-Kutta (RK4) method [@problem_id:2444905]. By applying these methods to the famous chaotic Lorenz system, you will gain first-hand experience with numerical error and see how quickly solutions can diverge, a vivid demonstration of the challenges and nuances of simulating chaotic dynamics.", "problem": "Consider the initial value problem for a system of coupled first-order ordinary differential equations, defined by a vector field $\\mathbf{f}(\\mathbf{x}, t)$ as $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$ with an initial condition $\\mathbf{x}(0) = \\mathbf{x}_0$. The Lorenz system is a canonical chaotic flow given by the three-dimensional system\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z,\n$$\nwith parameters $\\sigma = 10$, $\\rho = 28$, and $\\beta = 8/3$, and initial condition $\\mathbf{x}_0 = (1, 1, 1)$. All quantities in this problem are dimensionless, so no physical units are required.\n\nStarting only from the definitions of an initial value problem, numerical time stepping, and the concept of deterministic chaos characterized by sensitive dependence on initial conditions, implement two explicit time integrators for $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$:\n- the explicit Euler method, and\n- the classical fourth-order Runge–Kutta method.\n\nFor each integrator, advance the Lorenz system on a uniform time grid with step size $\\Delta t$ over a finite horizon $[0, T]$. To quantify numerical error growth due to discretization in a chaotic system, define a high-accuracy reference trajectory $\\mathbf{x}_{\\text{ref}}(t)$ computed by an adaptive explicit method with strict tolerances, evaluated on the same uniform time grid. At each grid time $t_n$, define the instantaneous error as the Euclidean norm $e_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2$. For a given threshold $\\varepsilon  0$, define the first threshold-crossing time $t_{\\text{cross}}$ as the smallest grid time $t_n$ such that $e_n \\ge \\varepsilon$. If no such index exists on $[0, T]$, define $t_{\\text{cross}} = T$.\n\nYour program must:\n- implement the explicit Euler and the classical fourth-order Runge–Kutta methods from their algorithmic definitions;\n- compute the high-accuracy reference solution with strict error tolerances, interpolated or evaluated exactly on the uniform grid;\n- for each test case below, compute the two threshold-crossing times, one for explicit Euler and one for classical fourth-order Runge–Kutta, using the same grid and reference for that test case.\n\nTest suite specification:\n- System: Lorenz with $\\sigma = 10$, $\\rho = 28$, $\\beta = 8/3$, and $\\mathbf{x}_0 = (1, 1, 1)$, integrated from $t = 0$ to $t = T$ on a uniform grid with step $\\Delta t$.\n- High-accuracy reference: adaptive explicit method with relative tolerance $\\mathrm{rtol} = 10^{-12}$ and absolute tolerance $\\mathrm{atol} = 10^{-12}$, evaluated on the uniform grid used by the method under test.\n- Threshold definition: Euclidean norm threshold $\\varepsilon$ as specified per case.\n\nProvide results for the following four test cases, each identified by $(\\Delta t, T, \\varepsilon)$:\n- Case $1$: $(0.001, 20.0, 0.01)$\n- Case $2$: $(0.002, 20.0, 0.01)$\n- Case $3$: $(0.005, 20.0, 0.01)$\n- Case $4$: $(0.001, 5.0, 1.0)$\n\nFor each case, compute and report two floats: $t_{\\text{cross}}$ for explicit Euler followed by $t_{\\text{cross}}$ for classical fourth-order Runge–Kutta, both in the same time units as $t$ and expressed as plain decimal numbers. If a crossing does not occur, return $T$ for that method and case.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered as\n$[t_{\\text{cross}}^{\\text{Euler},1}, t_{\\text{cross}}^{\\text{RK4},1}, t_{\\text{cross}}^{\\text{Euler},2}, t_{\\text{cross}}^{\\text{RK4},2}, t_{\\text{cross}}^{\\text{Euler},3}, t_{\\text{cross}}^{\\text{RK4},3}, t_{\\text{cross}}^{\\text{Euler},4}, t_{\\text{cross}}^{\\text{RK4},4}]$.\nThe only allowed output is this single line in exactly the specified format. No additional text should be printed.", "solution": "The problem requires the implementation and comparison of two fundamental numerical integrators for ordinary differential equations (ODEs): the explicit Euler method and the classical fourth-order Runge-Kutta (RK4) method. The subject of this numerical experiment is the Lorenz system, a canonical example of deterministic chaos. Our objective is to determine, for each integrator and a given set of parameters, the time at which the numerical solution's trajectory diverges from a high-accuracy reference trajectory by a specified error threshold $\\varepsilon$.\n\nThe problem is stated as an initial value problem (IVP) for a system of coupled first-order ODEs, which has the general form:\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t), \\quad \\mathbf{x}(t_0) = \\mathbf{x}_0\n$$\nFor this problem, the state vector is $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$, and the vector field $\\mathbf{f}(\\mathbf{x}, t)$ is given by the Lorenz equations:\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{pmatrix} \\sigma (y - x) \\\\ x (\\rho - z) - y \\\\ xy - \\beta z \\end{pmatrix}\n$$\nThe system is autonomous, so $\\mathbf{f}$ does not explicitly depend on $t$. The parameters are fixed at their classical chaotic values: $\\sigma = 10$, $\\rho = 28$, and $\\beta = 8/3$. The initial condition is given as $\\mathbf{x}(0) = \\mathbf{x}_0 = [1, 1, 1]^T$.\n\nNumerical integration methods approximate the continuous solution $\\mathbf{x}(t)$ on a discrete time grid $t_n = n \\Delta t$, where $\\Delta t$ is the time step.\n\nFirst, we consider the explicit Euler method. This is a first-order method derived from a simple forward difference approximation of the derivative. The update rule to advance the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is:\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\Delta t \\cdot \\mathbf{f}(\\mathbf{x}_n)\n$$\nwhere $\\mathbf{x}_n$ is the numerical approximation of $\\mathbf{x}(t_n)$. This method is simple to implement but has low accuracy (local truncation error is of order $\\mathcal{O}(\\Delta t^2)$) and limited stability.\n\nSecond, we implement the classical fourth-order Runge-Kutta (RK4) method. This is a more sophisticated single-step method that achieves higher accuracy by evaluating the vector field $\\mathbf{f}$ at several intermediate points within the time step. Its update rule is given by:\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate stages are:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{x}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{x}_n + \\Delta t \\cdot \\mathbf{k}_3)\n\\end{aligned}\n$$\nThe RK4 method has a local truncation error of order $\\mathcal{O}(\\Delta t^5)$, making it significantly more accurate than the Euler method for the same step size $\\Delta t$.\n\nTo quantify the error of these fixed-step methods, we must first compute a highly accurate reference solution, $\\mathbf{x}_{\\text{ref}}(t)$. This is achieved using an adaptive step-size integrator, specifically the `solve_ivp` function from the `scipy.integrate` library, configured with very strict relative and absolute error tolerances ($\\mathrm{rtol} = 10^{-12}$, $\\mathrm{atol} = 10^{-12}$). We instruct this solver to evaluate the reference solution on the same uniform time grid $\\{t_n\\}$ that our fixed-step methods will use.\n\nWith the numerical solution $\\mathbf{x}_{\\text{num}}(t_n)$ from either Euler or RK4 and the reference solution $\\mathbf{x}_{\\text{ref}}(t_n)$, the instantaneous error at each time step is defined as the Euclidean norm of their difference:\n$$\ne_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2\n$$\nThe primary quantity of interest is the threshold-crossing time, $t_{\\text{cross}}$, defined as the first time $t_n$ in the grid for which the error $e_n$ meets or exceeds a given threshold $\\varepsilon$.\n$$\nt_{\\text{cross}} = \\min \\{ t_n \\mid e_n \\ge \\varepsilon, n  0 \\}\n$$\nIf the error never reaches the threshold over the entire integration interval $[0, T]$, then $t_{\\text{cross}}$ is taken to be $T$.\n\nThe computational procedure is as follows: for each test case defined by $(\\Delta t, T, \\varepsilon)$:\n1.  Construct the uniform time grid $\\{t_n\\}$ from $t=0$ to $t=T$ with step size $\\Delta t$.\n2.  Compute and store the reference solution $\\mathbf{x}_{\\text{ref}}(t_n)$ at all grid points.\n3.  Simulate the system using the explicit Euler method. At each step $n$, compute $\\mathbf{x}_{\\text{Euler}}(t_{n+1})$, calculate the error $e_{n+1}$ against $\\mathbf{x}_{\\text{ref}}(t_{n+1})$, and check if $e_{n+1} \\ge \\varepsilon$. The first $t_{n+1}$ that satisfies this condition is recorded as $t_{\\text{cross}}^{\\text{Euler}}$. If the loop finishes, $t_{\\text{cross}}^{\\text{Euler}} = T$.\n4.  Repeat the process independently for the RK4 method to find $t_{\\text{cross}}^{\\text{RK4}}$.\n\nThis entire process is encapsulated in the provided Python code, which iterates through the specified test cases and reports the resulting threshold-crossing times in the required format. The results will demonstrate the superior accuracy of the RK4 method, as it will maintain a small error for a longer duration compared to the Euler method, and how the error growth is sensitive to the step size $\\Delta t$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Lorenz system problem as specified.\n\n    This function implements the explicit Euler and classical RK4 methods to\n    integrate the Lorenz system. It compares their solutions against a\n    high-accuracy reference solution to find the time at which the numerical\n    error first exceeds a given threshold. This is performed for several\n    test cases.\n    \"\"\"\n\n    # Define the Lorenz system of ODEs\n    def lorenz(t, x, sigma, rho, beta):\n        \"\"\"\n        The vector field for the Lorenz system.\n        The 't' argument is required by scipy.integrate.solve_ivp.\n        \"\"\"\n        dxdt = sigma * (x[1] - x[0])\n        dydt = x[0] * (rho - x[2]) - x[1]\n        dzdt = x[0] * x[1] - beta * x[2]\n        return np.array([dxdt, dydt, dzdt])\n\n    # System parameters and initial condition\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n    x0 = np.array([1.0, 1.0, 1.0])\n    lorenz_params = (sigma, rho, beta)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_t, T, epsilon)\n        (0.001, 20.0, 0.01),\n        (0.002, 20.0, 0.01),\n        (0.005, 20.0, 0.01),\n        (0.001, 5.0, 1.0),\n    ]\n\n    results = []\n    for dt, T, epsilon in test_cases:\n        # 1. Setup time grid\n        # Use round to prevent floating point inaccuracies in calculating num_steps\n        num_steps = int(round(T / dt))\n        t_points = np.linspace(0, T, num_steps + 1)\n\n        # 2. Compute high-accuracy reference solution\n        ref_sol = solve_ivp(\n            fun=lorenz,\n            t_span=(0, T),\n            y0=x0,\n            method='RK45',\n            t_eval=t_points,\n            rtol=1e-12,\n            atol=1e-12,\n            args=lorenz_params\n        )\n        x_ref = ref_sol.y.T  # Transpose to shape (num_steps+1, 3)\n\n        # 3. Compute t_cross for Explicit Euler\n        x_euler = np.zeros_like(x_ref)\n        x_euler[0] = x0\n        t_cross_euler = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_euler[n]\n            # Euler step\n            x_euler[n + 1] = x_n + dt * lorenz(t_n, x_n, *lorenz_params)\n\n            # Check error against reference\n            error = np.linalg.norm(x_euler[n + 1] - x_ref[n + 1])\n            if error = epsilon:\n                t_cross_euler = t_points[n + 1]\n                break\n        results.append(t_cross_euler)\n\n        # 4. Compute t_cross for Fourth-Order Runge-Kutta (RK4)\n        x_rk4 = np.zeros_like(x_ref)\n        x_rk4[0] = x0\n        t_cross_rk4 = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_rk4[n]\n            # RK4 stages\n            k1 = lorenz(t_n, x_n, *lorenz_params)\n            k2 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k1, *lorenz_params)\n            k3 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k2, *lorenz_params)\n            k4 = lorenz(t_n + dt, x_n + dt * k3, *lorenz_params)\n            # RK4 step\n            x_rk4[n + 1] = x_n + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check error against reference\n            error = np.linalg.norm(x_rk4[n + 1] - x_ref[n + 1])\n            if error = epsilon:\n                t_cross_rk4 = t_points[n + 1]\n                break\n        results.append(t_cross_rk4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2444905"}, {"introduction": "A crucial challenge in numerical integration is the problem of 'stiffness,' where a system contains processes evolving on vastly different time scales. This practice presents a physically intuitive scenario where stiffness arises: approximating a hard geometric constraint with a very strong 'penalty' spring force governed by a stiffness parameter $k$ [@problem_id:3199683]. By implementing a fixed-step integrator and increasing the value of $k$, you will directly observe how stiffness can lead to numerical instability, an essential lesson in choosing the right tool for a computational problem.", "problem": "Consider a planar mechanical system modeled as a single point mass subject to a holonomic constraint that would ideally confine its motion to a circle. Instead of enforcing the constraint exactly, approximate it using a penalty potential that penalizes deviations from the constraint. The system must be formulated and simulated strictly as a system of first-order Ordinary Differential Equations (ODEs), and the numerical experiment must assess how increasing penalty stiffness affects both integrator stability and the magnitude of constraint violation.\n\nFoundational base and modeling. Begin with Newton’s Second Law, which states that the total force equals mass times acceleration, i.e., $m \\,\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$, where $\\mathbf{q}(t) = [x(t), y(t)]^\\top$ is the position vector and $m$ is the mass. Let the holonomic constraint be the circle defined by $g(\\mathbf{q}) = x^2 + y^2 - R^2 = 0$. Approximate this constraint using a penalty potential $U(\\mathbf{q}) = \\frac{k}{2}\\, g(\\mathbf{q})^2$, where $k$ is the penalty stiffness. The conservative force from this potential is given by $\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$. Convert the resulting second-order ODE into a system of first-order ODEs by introducing the velocity $\\mathbf{v}(t) = \\dot{\\mathbf{q}}(t) = [v_x(t), v_y(t)]^\\top$ and defining a state vector $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$.\n\nInitial conditions and units. Use $m = 1\\,\\mathrm{kg}$, $R = 1\\,\\mathrm{m}$, and initial conditions $x(0) = R$, $y(0) = 0$, $v_x(0) = 0$, $v_y(0) = v_0$ with $v_0 = 1\\,\\mathrm{m/s}$. All positions must be in $\\mathrm{m}$, velocities in $\\mathrm{m/s}$, time in $\\mathrm{s}$, and the penalty stiffness $k$ in $\\mathrm{N/m^3}$.\n\nIntegrator and simulation protocol. Implement an explicit fixed-step fourth-order Runge–Kutta method (RK4) to integrate the first-order ODE system. Use a constant time step $h = 0.005\\,\\mathrm{s}$ and simulate over a total time $T = 5.0\\,\\mathrm{s}$. At each time step, compute the instantaneous constraint violation as the radial deviation $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$ in $\\mathrm{m}$ and track the maximum over the entire simulation.\n\nStability criterion. Define the numerical stability of the integrator, for the purposes of this test, as follows: the simulation is stable if and only if throughout $t \\in [0,T]$, the state remains finite and bounded, meaning all components of $\\mathbf{z}(t)$ are finite and $\\lVert \\mathbf{z}(t) \\rVert_2  M_{\\mathrm{th}}$ with $M_{\\mathrm{th}} = 10^3$; otherwise it is unstable. If instability is detected, stop the simulation for that case immediately.\n\nTest suite. Simulate the system for the following penalty stiffness values:\n- Case $1$: $k = 100\\,\\mathrm{N/m^3}$ (happy path, relatively soft penalty),\n- Case $2$: $k = 1{,}000\\,\\mathrm{N/m^3}$ (moderate penalty),\n- Case $3$: $k = 10{,}000\\,\\mathrm{N/m^3}$ (stiff penalty),\n- Case $4$: $k = 50{,}000\\,\\mathrm{N/m^3}$ (very stiff, near stability boundary for a fixed-step explicit integrator).\n\nRequired outputs. For each case, compute:\n- The maximum constraint violation $\\max_{t \\in [0,T]} \\delta r(t)$ expressed as a float in $\\mathrm{m}$.\n- The stability flag, a boolean indicating whether the simulation remained stable according to the stated criterion.\n\nFinal output format. Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, interleaving each case’s maximum violation and stability flag in order: $[\\delta r_1, s_1, \\delta r_2, s_2, \\delta r_3, s_3, \\delta r_4, s_4]$, where each $\\delta r_i$ is a float in $\\mathrm{m}$ and each $s_i$ is either $\\mathrm{True}$ or $\\mathrm{False}$.", "solution": "The problem requires the formulation and numerical simulation of a planar mechanical system where a circular holonomic constraint is approximated using a penalty method. The core of the problem lies in converting the governing second-order differential equation into a system of first-order Ordinary Differential Equations (ODEs) and integrating it numerically to study the effects of the penalty stiffness parameter.\n\nFirst, we establish the physical model. The system is a point mass $m$ with position vector $\\mathbf{q}(t) = [x(t), y(t)]^\\top$. According to Newton's Second Law, the equation of motion is $m\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$, where $\\mathbf{F}$ is the total force acting on the mass.\n\nThe ideal constraint is a circle of radius $R$, described by the equation $g(\\mathbf{q}) = x(t)^2 + y(t)^2 - R^2 = 0$. The penalty method approximates this constraint by introducing a potential energy function $U(\\mathbf{q})$ that penalizes deviations from the constraint surface. The specified potential is $U(\\mathbf{q}) = \\frac{k}{2} g(\\mathbf{q})^2$, where $k$ is the penalty stiffness. This potential is zero when the constraint is satisfied ($g(\\mathbf{q})=0$) and grows quadratically with the deviation.\n\nThe force generated by this potential is a conservative force, given by the negative gradient of the potential: $\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$. We compute the components of this force:\n$$\n\\mathbf{F}(\\mathbf{q}) = -\\nabla \\left[ \\frac{k}{2} (x^2 + y^2 - R^2)^2 \\right]\n$$\nThe $x$-component of the force is:\n$$\nF_x = -\\frac{\\partial U}{\\partial x} = -\\frac{k}{2} \\cdot 2(x^2 + y^2 - R^2) \\cdot \\frac{\\partial}{\\partial x}(x^2 + y^2 - R^2) = -k(x^2 + y^2 - R^2)(2x) = -2kx(x^2 + y^2 - R^2)\n$$\nSimilarly, the $y$-component of the force is:\n$$\nF_y = -\\frac{\\partial U}{\\partial y} = -k(x^2 + y^2 - R^2)(2y) = -2ky(x^2 + y^2 - R^2)\n$$\nThe second-order equations of motion are thus:\n$$\n\\ddot{x}(t) = \\frac{F_x}{m} = -\\frac{2k}{m} x(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\n$$\n\\ddot{y}(t) = \\frac{F_y}{m} = -\\frac{2k}{m} y(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\nTo solve this system numerically, we convert it into a system of first-order ODEs. We define the state vector as $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$, where $v_x(t) = \\dot{x}(t)$ and $v_y(t) = \\dot{y}(t)$ are the velocity components. The time derivative of the state vector, $\\dot{\\mathbf{z}}(t) = f(\\mathbf{z}(t))$, is given by:\n$$\n\\dot{\\mathbf{z}}(t) = \n\\begin{bmatrix}\n\\dot{x} \\\\\n\\dot{y} \\\\\n\\dot{v}_x \\\\\n\\dot{v}_y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv_x \\\\\nv_y \\\\\n-\\frac{2k}{m} x (x^2 + y^2 - R^2) \\\\\n-\\frac{2k}{m} y (x^2 + y^2 - R^2)\n\\end{bmatrix}\n$$\nThis is a system of four coupled first-order ODEs of the form $\\dot{\\mathbf{z}} = f(\\mathbf{z})$. We are given the initial conditions $\\mathbf{z}(0) = [R, 0, 0, v_0]^\\top$.\n\nThe problem specifies using the explicit fourth-order Runge-Kutta (RK4) method for numerical integration with a fixed time step $h$. Given the state $\\mathbf{z}_n$ at time $t_n$, the state $\\mathbf{z}_{n+1}$ at time $t_{n+1} = t_n + h$ is calculated as follows:\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate slopes are:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{z}_n) \\\\\n\\mathbf{k}_2 = f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(\\mathbf{z}_n + h \\mathbf{k}_3)\n\\end{aligned}\n$$\nThe simulation proceeds from $t=0$ to $t=T=5.0\\,\\mathrm{s}$ with a time step of $h=0.005\\,\\mathrm{s}$. At each step, we calculate the instantaneous constraint violation, $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$, and keep track of its maximum value. We also monitor for numerical instability, defined as the L2-norm of the state vector, $\\lVert \\mathbf{z}(t) \\rVert_2$, exceeding a threshold $M_{\\mathrm{th}} = 10^3$, or any component becoming non-finite. If instability is detected, the simulation for that particular value of $k$ is terminated, and a stability flag is set to `False`.\n\nThis procedure is repeated for each of the four specified values of the penalty stiffness $k$: $100\\,\\mathrm{N/m^3}$, $1000\\,\\mathrm{N/m^3}$, $10000\\,\\mathrm{N/m^3}$, and $50000\\,\\mathrm{N/m^3}$.\nThe expected behavior is a trade-off: as $k$ increases, the penalty for deviating from the circle becomes harsher, so the maximum constraint violation $\\delta r$ should decrease. However, higher $k$ values introduce high-frequency oscillations into the system's dynamics, making the ODE system numerically \"stiff.\" An explicit integrator like RK4 with a fixed time step can become unstable when the time step $h$ is not small enough to resolve these fast dynamics, leading to a catastrophic blow-up of the numerical solution. We expect the last case, $k=50000\\,\\mathrm{N/m^3}$, to potentially exhibit this instability with the given time step $h=0.005\\,\\mathrm{s}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified mechanical system problem using the RK4 method.\n    \"\"\"\n    # Define physical constants and simulation parameters\n    m = 1.0  # mass in kg\n    R = 1.0  # radius in m\n    v0 = 1.0 # initial tangential velocity in m/s\n    \n    h = 0.005 # time step in s\n    T = 5.0   # total simulation time in s\n    M_th = 1000.0 # stability threshold\n\n    # Define the test cases for the penalty stiffness k\n    test_cases = [\n        100.0,    # Case 1: k in N/m^3\n        1000.0,   # Case 2: k in N/m^3\n        10000.0,  # Case 3: k in N/m^3\n        50000.0   # Case 4: k in N/m^3\n    ]\n\n    results = []\n\n    def f(z, k_val):\n        \"\"\"\n        Computes the time derivative of the state vector z.\n        z = [x, y, vx, vy]\n        \"\"\"\n        x, y, vx, vy = z\n        # Constraint function g(q) = x^2 + y^2 - R^2\n        g = x**2 + y**2 - R**2\n        \n        # Accelerations from penalty force F = -nabla(U)\n        ax = (-2.0 * k_val * x * g) / m\n        ay = (-2.0 * k_val * y * g) / m\n        \n        return np.array([vx, vy, ax, ay])\n\n    for k in test_cases:\n        # Initial state vector z = [x, y, vx, vy]\n        z = np.array([R, 0.0, 0.0, v0])\n        \n        # Initialize metrics for this case\n        max_violation = 0.0\n        stable = True\n        \n        # Calculate violation at the initial state (t=0)\n        violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n        max_violation = max(max_violation, violation)\n\n        # Determine the number of steps\n        num_steps = int(round(T / h))\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # RK4 integration step\n            k1 = f(z, k)\n            k2 = f(z + 0.5 * h * k1, k)\n            k3 = f(z + 0.5 * h * k2, k)\n            k4 = f(z + h * k3, k)\n            z = z + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check for instability\n            norm_z = np.linalg.norm(z)\n            if not np.isfinite(norm_z) or norm_z = M_th:\n                stable = False\n                break  # Terminate simulation for this k value\n\n            # Calculate constraint violation and update the maximum\n            violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n            max_violation = max(max_violation, violation)\n        \n        # Store the results for this case\n        results.append(max_violation)\n        results.append(stable)\n\n    # Format and print the final output\n    # Example format: [0.0123,True,-0.0045,True,...]\n    # The str() for a boolean correctly produces 'True' or 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3199683"}]}