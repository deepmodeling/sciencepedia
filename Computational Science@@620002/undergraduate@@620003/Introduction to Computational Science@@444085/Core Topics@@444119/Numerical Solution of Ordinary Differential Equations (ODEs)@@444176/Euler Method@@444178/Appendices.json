{"hands_on_practices": [{"introduction": "Mastering the Euler method begins with a solid understanding of its iterative formula. This first practice problem provides a direct, hands-on application of the method to a nonlinear differential equation. By manually calculating the first few steps, you will solidify your grasp of the core update rule, $y_{n+1} = y_n + h f(t_n, y_n)$, which forms the foundation of this numerical technique. [@problem_id:2172203]", "problem": "In a simplified model for the dynamics of a specialized electrical component, the time evolution of a certain phase angle $y(t)$ (measured in radians) is described by the differential equation $y' = t + \\sin(y)$. Here, $t$ is time measured in seconds. The initial state of the system at $t=0$ is given by $y(0) = \\pi$.\n\nYour task is to approximate the value of the phase angle at $t=0.2$ seconds. Use Euler's method with a step size of $h=0.1$ to perform this approximation.\n\nProvide your final answer in radians, rounded to five significant figures.", "solution": "We apply forward Eulerâ€™s method to the initial value problem $y' = f(t,y) = t + \\sin(y)$ with $y(0) = \\pi$ and step size $h = 0.1$. The update formula is\n$$\ny_{n+1} = y_{n} + h\\,f(t_{n}, y_{n}), \\quad t_{n+1} = t_{n} + h.\n$$\nInitialize $t_{0} = 0$ and $y_{0} = \\pi$.\n\nFirst step to $t_{1} = 0.1$:\n$$\nf(t_{0}, y_{0}) = f(0, \\pi) = 0 + \\sin(\\pi) = 0,\n$$\n$$\ny_{1} = y_{0} + h\\,f(t_{0}, y_{0}) = \\pi + 0.1 \\cdot 0 = \\pi.\n$$\n\nSecond step to $t_{2} = 0.2$:\n$$\nf(t_{1}, y_{1}) = f(0.1, \\pi) = 0.1 + \\sin(\\pi) = 0.1,\n$$\n$$\ny_{2} = y_{1} + h\\,f(t_{1}, y_{1}) = \\pi + 0.1 \\cdot 0.1 = \\pi + 0.01.\n$$\nThus the Euler approximation at $t=0.2$ is $y(0.2) \\approx \\pi + 0.01$. In decimal form, $\\pi + 0.01 \\approx 3.1515926535\\ldots$, which rounds to five significant figures as $3.1516$.", "answer": "$$\\boxed{3.1516}$$", "id": "2172203"}, {"introduction": "The accuracy of the Euler method is critically dependent on the chosen step size, $h$. This exercise demonstrates this principle by asking you to solve the same initial value problem twice, using different step sizes. Comparing the results will give you an intuitive feel for how reducing the step size generally improves the approximation, a fundamental concept in numerical analysis and error control. [@problem_id:2172241]", "problem": "Consider the initial value problem (IVP) given by the ordinary differential equation $y'(t) = -2y(t)$ with the initial condition $y(0) = 1$. We wish to approximate the value of $y(1)$ using Euler's method.\n\nLet $A_1$ be the approximation of $y(1)$ obtained using Euler's method with a single step of size $h=1$.\nLet $A_{0.5}$ be the approximation of $y(1)$ obtained using Euler's method with two steps, each of size $h=0.5$.\n\nCalculate the value of the expression $3A_1 - 2A_{0.5}$.", "solution": "We apply explicit Euler's method, which for an IVP $y'(t)=f(t,y)$ with step size $h$ updates as\n$$\ny_{n+1}=y_{n}+h\\,f(t_{n},y_{n}).\n$$\nHere $f(t,y)=-2y$, so\n$$\ny_{n+1}=y_{n}+h(-2y_{n})=y_{n}(1-2h).\n$$\n\nSingle step with $h=1$ from $t_{0}=0$ to $t_{1}=1$:\n$$\ny_{1}=y_{0}(1-2\\cdot 1)=1\\cdot(-1)=-1,\n$$\nso $A_{1}=-1$.\n\nTwo steps with $h=0.5$ from $t_{0}=0$ to $t_{2}=1$:\nFirst step to $t_{1}=0.5$:\n$$\ny_{1}=y_{0}(1-2\\cdot 0.5)=1\\cdot(1-1)=0.\n$$\nSecond step to $t_{2}=1$:\n$$\ny_{2}=y_{1}(1-2\\cdot 0.5)=0\\cdot(1-1)=0,\n$$\nso $A_{0.5}=0$.\n\nTherefore,\n$$\n3A_{1}-2A_{0.5}=3(-1)-2(0)=-3.\n$$", "answer": "$$\\boxed{-3}$$", "id": "2172241"}, {"introduction": "While manual calculations are essential for understanding the concept, the true power of numerical methods is realized in computation. This advanced practice challenges you to move from single calculations to a large-scale implementation by vectorizing the Euler method to solve thousands of equations simultaneously. This exercise not only teaches efficient coding practices common in scientific computing but also provides a practical look at numerical stability and error analysis. [@problem_id:3226233]", "problem": "You are asked to design and implement a fully vectorized explicit Euler solver for a family of independent linear ordinary differential equations. The goal is to leverage array operations to advance thousands of independent initial value problems simultaneously without writing per-equation loops.\n\nThe fundamental base is the definition of an initial value problem and the derivative. An initial value problem specifies a function $y(t)$ satisfying a differential equation and an initial condition: $y'(t) = f(t,y(t))$ with $y(0) = y_0$. The derivative is defined as $y'(t) = \\lim_{h \\to 0} \\dfrac{y(t+h) - y(t)}{h}$. The explicit Euler method is grounded in the first-order Taylor expansion of $y(t)$, which approximates the forward increment using the derivative evaluated at the current time.\n\nImplement the method for the following family of independent scalar equations indexed by $i \\in \\{0,1,\\dots,N-1\\}$:\n$$\n\\frac{d y_i}{d t} = a_i\\, y_i + b_i, \\quad y_i(0) = y_{0,i}, \\quad t \\in [0, T].\n$$\nYou must:\n- Construct the parameter arrays $\\{a_i\\}_{i=0}^{N-1}$, $\\{b_i\\}_{i=0}^{N-1}$, and $\\{y_{0,i}\\}_{i=0}^{N-1}$ exactly as specified in the test suite below.\n- Advance all $N$ equations in lockstep using a uniform step size $h$ with $M = T/h$ steps and compute the numerical approximation $\\{y_i^{E}(T)\\}_{i=0}^{N-1}$ at $t = T$.\n- Compute the closed-form solution $\\{y_i^{\\ast}(T)\\}_{i=0}^{N-1}$ for comparison. For $a_i \\neq 0$, the solution of $\\dfrac{d y}{dt} = a_i y + b_i$ with $y(0) = y_{0,i}$ is\n$$\ny_i^{\\ast}(t) = \\left(y_{0,i} + \\frac{b_i}{a_i}\\right) e^{a_i t} - \\frac{b_i}{a_i}.\n$$\nFor $a_i = 0$, the solution reduces to\n$$\ny_i^{\\ast}(t) = y_{0,i} + b_i t.\n$$\nHandle the case $a_i = 0$ exactly, not via limit approximations.\n\nError metrics:\n- Define the absolute error per equation at final time as $e_i = \\left| y_i^{E}(T) - y_i^{\\ast}(T) \\right|$.\n- For each test case, aggregate $\\{e_i\\}$ according to the specified metric.\n\nTest suite (four cases) to ensure coverage:\n1. Happy path, smooth parameter variation:\n   - $N = 2048$, $T = 1$, $h = 0.001$ (so $M = 1000$).\n   - For $i \\in \\{0,1,\\dots,N-1\\}$,\n     - $a_i = -1 + \\dfrac{2 i}{N - 1}$,\n     - $b_i = 0.3 \\sin\\!\\left(\\dfrac{3 i}{N}\\right)$,\n     - $y_{0,i} = 1.0 + 0.2 \\cos\\!\\left(\\dfrac{5 i}{N}\\right)$.\n   - Output the maximum absolute error $\\max_i e_i$ as a float.\n\n2. Boundary case with exact zeros in $a_i$:\n   - $N = 1024$, $T = 1$, $h = 0.01$ (so $M = 100$).\n   - For $i \\in \\{0,1,\\dots,N-1\\}$, let $r_i = i \\bmod 4$,\n     - $a_i = 0.5 (r_i - 2)$, which cycles through $-1.0$, $-0.5$, $0.0$, $0.5$,\n     - $b_i = 0.25 \\cos(\\pi i)$,\n     - $y_{0,i} = 0.75 + 0.1 \\sin\\!\\left(\\dfrac{2\\pi i}{N}\\right)$.\n   - Output the mean absolute error $\\dfrac{1}{N} \\sum_{i=0}^{N-1} e_i$ as a float.\n\n3. Stability-challenging case:\n   - $N = 512$, $T = 1$, $h = 0.25$ (so $M = 4$).\n   - For all $i$, $a_i = -10.0$, $b_i = 0.0$, and $y_{0,i} = 1.0 + \\dfrac{i}{N}$.\n   - Output the maximum absolute error $\\max_i e_i$ as a float.\n\n4. Single-equation check:\n   - $N = 1$, $T = 1$, $h = 0.05$ (so $M = 20$).\n   - Parameters: $a_0 = 0.3$, $b_0 = -0.1$, $y_{0,0} = 2.0$.\n   - Output the absolute error $e_0$ as a float.\n\nImplementation requirements:\n- The method must be vectorized across the $N$ equations using array operations; do not write loops over $i$.\n- Use only a loop over time steps to apply the explicit Euler increment simultaneously to all $N$ equations at each step.\n- Compute the exact solutions with a piecewise vectorized expression to correctly handle $a_i = 0$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\"), in the order of the test cases $1$ through $4$.", "solution": "The user wants to solve a system of independent linear ordinary differential equations using a vectorized explicit Euler method.\n\n### Step 1: Extract Givens\n- **Family of ODEs**: $\\dfrac{d y_i}{d t} = a_i\\, y_i + b_i$ for $i \\in \\{0, 1, \\dots, N-1\\}$.\n- **Initial Conditions**: $y_i(0) = y_{0,i}$.\n- **Time Interval**: $t \\in [0, T]$.\n- **Numerical Method**: Explicit Euler method with a uniform step size $h$. Number of steps $M = T/h$.\n- **Numerical Solution at T**: $\\{y_i^{E}(T)\\}_{i=0}^{N-1}$.\n- **Exact Solution for $a_i \\neq 0$**: $y_i^{\\ast}(t) = \\left(y_{0,i} + \\frac{b_i}{a_i}\\right) e^{a_i t} - \\frac{b_i}{a_i}$.\n- **Exact Solution for $a_i = 0$**: $y_i^{\\ast}(t) = y_{0,i} + b_i t$.\n- **Error Metric**: Absolute error $e_i = \\left| y_i^{E}(T) - y_i^{\\ast}(T) \\right|$. Aggregated by $\\max_i e_i$ or $\\frac{1}{N} \\sum_{i=0}^{N-1} e_i$.\n\n- **Test Case 1**:\n    - $N = 2048$, $T = 1$, $h = 0.001$.\n    - $a_i = -1 + \\dfrac{2 i}{N - 1}$.\n    - $b_i = 0.3 \\sin\\!\\left(\\dfrac{3 i}{N}\\right)$.\n    - $y_{0,i} = 1.0 + 0.2 \\cos\\!\\left(\\dfrac{5 i}{N}\\right)$.\n    - Output: $\\max_i e_i$.\n\n- **Test Case 2**:\n    - $N = 1024$, $T = 1$, $h = 0.01$.\n    - $r_i = i \\bmod 4$.\n    - $a_i = 0.5 (r_i - 2)$.\n    - $b_i = 0.25 \\cos(\\pi i)$.\n    - $y_{0,i} = 0.75 + 0.1 \\sin\\!\\left(\\dfrac{2\\pi i}{N}\\right)$.\n    - Output: $\\dfrac{1}{N} \\sum_{i=0}^{N-1} e_i$.\n\n- **Test Case 3**:\n    - $N = 512$, $T = 1$, $h = 0.25$.\n    - $a_i = -10.0$.\n    - $b_i = 0.0$.\n    - $y_{0,i} = 1.0 + \\dfrac{i}{N}$.\n    - Output: $\\max_i e_i$.\n\n- **Test Case 4**:\n    - $N = 1$, $T = 1$, $h = 0.05$.\n    - $a_0 = 0.3$, $b_0 = -0.1$, $y_{0,0} = 2.0$.\n    - Output: $e_0$.\n\n- **Implementation Requirement**: Vectorized implementation using array operations, without loops over the index $i$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem is based on the well-established theory of first-order linear ordinary differential equations and the standard explicit Euler method for their numerical solution. All concepts are fundamental to calculus and numerical analysis.\n- **Well-Posed**: Each initial value problem specified has a unique solution. The parameters and initial conditions for all test cases are clearly defined, ensuring a unique and computable result. The problem of evaluating a numerical method (including in regimes of instability, as in case 3) is a standard and well-posed task in scientific computing.\n- **Objective**: The problem is stated using precise mathematical language and definitions. The requirements are quantitative and verifiable. There are no subjective or ambiguous statements.\n\nThe problem does not violate any of the invalidity criteria. It is scientifically sound, formally specified, and objective. The test cases are well-designed to verify different aspects of the implementation, such as handling of parameter variations, the special case $a_i=0$, and numerical stability.\n\n### Step 3: Verdict and Action\nThe problem is valid. A reasoned solution will be provided.\n\nThe problem requires the implementation of a vectorized explicit Euler solver for a system of $N$ independent linear ordinary differential equations. The core principle is to replace loops over individual equations with array operations, which is significantly more efficient in computational environments like `NumPy`.\n\nThe family of ODEs is given by:\n$$\n\\frac{d y_i}{d t} = a_i y_i + b_i, \\quad y_i(0) = y_{0,i}\n$$\nIn vector notation, where $\\mathbf{y}(t) = [y_0(t), y_1(t), \\dots, y_{N-1}(t)]^T$ and similarly for $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{y}_0$, the system can be written as:\n$$\n\\frac{d \\mathbf{y}}{d t} = \\mathbf{a} \\odot \\mathbf{y} + \\mathbf{b}\n$$\nwhere $\\odot$ denotes the element-wise (Hadamard) product.\n\nThe explicit Euler method approximates the solution at the next time step, $t_{k+1} = t_k + h$, using a first-order Taylor expansion around the current time $t_k$:\n$$\ny(t_{k+1}) \\approx y(t_k) + h \\frac{d y}{d t}\\bigg|_{t_k}\n$$\nLet $\\mathbf{y}^k$ be the numerical approximation of $\\mathbf{y}(t_k)$. Substituting the ODE system into the Taylor approximation gives the update rule for the entire vector of solutions:\n$$\n\\mathbf{y}^{k+1} = \\mathbf{y}^k + h (\\mathbf{a} \\odot \\mathbf{y}^k + \\mathbf{b})\n$$\nThis update is performed in a loop for $M = T/h$ time steps, starting from the initial condition vector $\\mathbf{y}^0 = \\mathbf{y}_0$. This approach is fully vectorized and avoids any explicit loops over the index $i$.\n\nTo assess the accuracy of the numerical solution, we compare it against the exact analytical solution at the final time $T$. The problem provides the closed-form solutions, which depend on whether $a_i$ is zero.\nFor $a_i \\neq 0$:\n$$\ny_i^{\\ast}(T) = \\left(y_{0,i} + \\frac{b_i}{a_i}\\right) e^{a_i T} - \\frac{b_i}{a_i}\n$$\nFor $a_i = 0$, the ODE simplifies to $\\frac{d y_i}{d t} = b_i$, which integrates to:\n$$\ny_i^{\\ast}(T) = y_{0,i} + b_i T\n$$\nIn a vectorized implementation, these two cases must be handled correctly without disrupting the array-based computation. This is efficiently achieved using conditional array operations, such as `numpy.where`, which selects elements from two arrays based on a boolean condition, thereby avoiding division by zero where $a_i=0$.\n\nThe final step for each test case is to compute the absolute error vector, $\\mathbf{e} = |\\mathbf{y}^{E}(T) - \\mathbf{y}^{\\ast}(T)|$, and then aggregate its components as specified, either by taking the maximum value or the mean value.\n\nThe implementation will consist of a main function that iterates through the four test cases. A helper function will be designed to perform the computation for a single case, which involves:\n1.  Generating the parameter vectors $\\mathbf{a}$, $\\mathbf{b}$, and $\\mathbf{y}_0$ based on the case-specific rules.\n2.  Initializing the solution vector $\\mathbf{y}$ with $\\mathbf{y}_0$.\n3.  Iterating $M$ times, applying the vectorized Euler update at each step.\n4.  Computing the exact solution vector $\\mathbf{y}^{\\ast}(T)$ using conditional logic for the $a_i=0$ case.\n5.  Calculating the error vector and the required aggregate metric.\n\nA notable aspect is Test Case 3, where $a_i = -10$ and $h = 0.25$. For the explicit Euler method, the stability condition for an equation $y' = \\lambda y$ with $\\lambda < 0$ is $|1 + h\\lambda| \\le 1$, which simplifies to $h\\lambda \\ge -2$. In this case, $h a_i = 0.25 \\times (-10) = -2.5$, which violates the stability condition. We expect the numerical solution to exhibit large, oscillating errors, a correct and important observation about the limitations of the method. The algorithm must still compute this unstable result as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_euler_test_case(N, T, h, a_func, b_func, y0_func, metric):\n        \"\"\"\n        Solves a single test case for the vectorized Euler method.\n\n        Args:\n            N (int): Number of independent equations.\n            T (float): Final time.\n            h (float): Step size.\n            a_func (function): Function to generate parameter vector 'a'.\n            b_func (function): Function to generate parameter vector 'b'.\n            y0_func (function): Function to generate initial conditions 'y0'.\n            metric (str): The error aggregation metric ('max' or 'mean').\n\n        Returns:\n            float: The aggregated error metric.\n        \"\"\"\n        # 1. Construct parameter arrays\n        i = np.arange(N, dtype=float)\n        a = a_func(i, N)\n        b = b_func(i, N)\n        y0 = y0_func(i, N)\n\n        # 2. Advance all N equations using explicit Euler method\n        y_euler = y0.copy()\n        num_steps = int(round(T / h))\n\n        for _ in range(num_steps):\n            # Vectorized update rule: y_new = y_old + h * (a * y_old + b)\n            y_euler += h * (a * y_euler + b)\n\n        # 3. Compute the closed-form solution\n        y_exact = np.zeros(N, dtype=float)\n        \n        # Mask for a_i == 0 to handle cases separately\n        mask_zero_a = (a == 0)\n        \n        # Case a_i != 0\n        a_nonzero = a[~mask_zero_a]\n        y0_nonzero = y0[~mask_zero_a]\n        b_nonzero = b[~mask_zero_a]\n        y_exact[~mask_zero_a] = \\\n            (y0_nonzero + b_nonzero / a_nonzero) * np.exp(a_nonzero * T) - (b_nonzero / a_nonzero)\n        \n        # Case a_i == 0\n        y0_zero = y0[mask_zero_a]\n        b_zero = b[mask_zero_a]\n        y_exact[mask_zero_a] = y0_zero + b_zero * T\n        \n        # 4. Compute error metrics\n        errors = np.abs(y_euler - y_exact)\n        \n        if metric == 'max':\n            return np.max(errors)\n        elif metric == 'mean':\n            return np.mean(errors)\n        elif metric == 'single':\n            return errors[0]\n        else:\n            raise ValueError(\"Invalid metric specified\")\n\n    # Define test cases from the problem statement\n    test_cases = [\n        {\n            \"N\": 2048, \"T\": 1.0, \"h\": 0.001,\n            \"a_func\": lambda i, N: -1.0 + 2.0 * i / (N - 1) if N > 1 else np.array([-1.0]),\n            \"b_func\": lambda i, N: 0.3 * np.sin(3.0 * i / N),\n            \"y0_func\": lambda i, N: 1.0 + 0.2 * np.cos(5.0 * i / N),\n            \"metric\": \"max\"\n        },\n        {\n            \"N\": 1024, \"T\": 1.0, \"h\": 0.01,\n            \"a_func\": lambda i, N: 0.5 * ((i % 4) - 2.0),\n            \"b_func\": lambda i, N: 0.25 * np.cos(np.pi * i),\n            \"y0_func\": lambda i, N: 0.75 + 0.1 * np.sin(2.0 * np.pi * i / N),\n            \"metric\": \"mean\"\n        },\n        {\n            \"N\": 512, \"T\": 1.0, \"h\": 0.25,\n            \"a_func\": lambda i, N: np.full(N, -10.0),\n            \"b_func\": lambda i, N: np.zeros(N),\n            \"y0_func\": lambda i, N: 1.0 + i / N,\n            \"metric\": \"max\"\n        },\n        {\n            \"N\": 1, \"T\": 1.0, \"h\": 0.05,\n            \"a_func\": lambda i, N: np.array([0.3]),\n            \"b_func\": lambda i, N: np.array([-0.1]),\n            \"y0_func\": lambda i, N: np.array([2.0]),\n            \"metric\": \"single\"\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_euler_test_case(\n            case[\"N\"], case[\"T\"], case[\"h\"],\n            case[\"a_func\"], case[\"b_func\"], case[\"y0_func\"],\n            case[\"metric\"]\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```", "id": "3226233"}]}