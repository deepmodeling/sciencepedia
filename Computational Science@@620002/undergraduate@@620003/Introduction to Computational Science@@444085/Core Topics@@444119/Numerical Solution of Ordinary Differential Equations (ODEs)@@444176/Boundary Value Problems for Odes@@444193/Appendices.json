{"hands_on_practices": [{"introduction": "We begin our hands-on journey by building a finite difference solver from the ground up. This first practice uses the \"method of manufactured solutions,\" a powerful technique for verifying code where we start with a known answer and construct a problem that fits it. You will discretize a linear Boundary Value Problem (BVP) with Dirichlet conditions, assemble the corresponding matrix system, and compare your numerical results to the exact solution to confirm your implementation is correct [@problem_id:3104017]. Mastering this fundamental workflow is the first step toward tackling more complex BVPs.", "problem": "Consider the following manufactured-solution benchmark for a linear two-point Boundary Value Problem (BVP) for an ordinary differential equation (ODE) on the interval $[0,1]$. The exact solution is prescribed as $u(x)=e^{x}-x$, with Dirichlet boundary conditions $u(0)=1$ and $u(1)=e-1$. Your tasks:\n\n1) Derive a linear, constant-coefficient, second-order ODE with a polynomial right-hand side such that the exact solution $u(x)=e^{x}-x$ satisfies the ODE and the boundary conditions. Start from the definitions of the first and second derivatives and compute $u'(x)$ and $u''(x)$ to construct an ODE of the form $u''(x)-u(x)=g(x)$, then identify $g(x)$ that makes $u(x)$ an exact solution.\n\n2) Discretize the resulting BVP on a uniform grid $x_{i}=ih$ with $i\\in\\{0,1,\\dots,N+1\\}$, where $N$ is the number of interior points and $h=1/(N+1)$. Using the central-difference approximation for the second derivative derived from Taylor expansions, build the corresponding tridiagonal linear system for the unknowns $\\{u_{1},u_{2},\\dots,u_{N}\\}$ that enforces the boundary conditions $u_{0}=1$ and $u_{N+1}=e-1$.\n\n3) Implement a complete, runnable program that:\n- Constructs and solves the tridiagonal linear system for each $N$ in the test suite $N\\in\\{1,10,20,40\\}$.\n- Reconstructs the grid function including boundary values and computes the maximum absolute error over all grid points $x_{i}$, $i\\in\\{0,1,\\dots,N+1\\}$, compared to the exact solution $u(x)=e^{x}-x$.\n- Reports, for each $N$, the maximum absolute error as a floating-point number rounded to eight decimal places.\n\nFoundational base you may use:\n- Definitions of the first derivative $u'(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-u(x)}{h}$ and the second derivative $u''(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-2u(x)+u(x-h)}{h^{2}}$.\n- Taylor expansions about a point $x$ for a sufficiently smooth function.\n- Standard linear algebra for solving linear systems.\n\nScientific realism requirements:\n- Work purely in mathematical terms without physical units.\n- Angles and percentages are not involved.\n\nTest suite and output specification:\n- Use the test suite $N\\in\\{1,10,20,40\\}$.\n- For each $N$, compute the maximum absolute error over the full grid, including the endpoints.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite values of $N$. Each entry must be rounded to eight decimal places. For example, an output with three hypothetical results should look like [$r_{1},$ $r_{2},$ $r_{3}$], where each $r_{k}$ is a decimal number rounded to eight decimal places.\n- The program must be self-contained and require no user input.", "solution": "The user-provided problem is a well-defined exercise in numerical analysis, specifically the application of the finite difference method to a two-point boundary value problem (BVP). The problem is valid as it is mathematically sound, self-contained, and objective. It is based on established principles of calculus and numerical methods. All provided data, including the manufactured solution and boundary conditions, are consistent.\n$u(x) = e^x - x$\n$u(0) = e^0 - 0 = 1$\n$u(1) = e^1 - 1 = e-1$\nThe boundary conditions are correctly stated. The problem will be solved in three parts as requested.\n\n### Part 1: Derivation of the Boundary Value Problem\n\nThe problem asks to derive a linear, constant-coefficient, second-order ODE of the form $u''(x) - u(x) = g(x)$ for which the exact solution is $u(x) = e^x - x$.\n\nFirst, we compute the first and second derivatives of the given solution $u(x)$.\nThe exact solution is:\n$$u(x) = e^x - x$$\n\nThe first derivative, $u'(x)$, is:\n$$u'(x) = \\frac{d}{dx}(e^x - x) = e^x - 1$$\n\nThe second derivative, $u''(x)$, is:\n$$u''(x) = \\frac{d}{dx}(e^x - 1) = e^x$$\n\nNow, we substitute $u(x)$ and $u''(x)$ into the specified form of the ODE, $u''(x) - u(x) = g(x)$, to find the right-hand side function $g(x)$:\n$$g(x) = u''(x) - u(x) = (e^x) - (e^x - x)$$\n$$g(x) = e^x - e^x + x = x$$\n\nThe function $g(x) = x$ is a polynomial, as required. Therefore, the complete BVP is:\n$$\n\\begin{cases}\nu''(x) - u(x) = x, & x \\in [0, 1] \\\\\nu(0) = 1 \\\\\nu(1) = e - 1\n\\end{cases}\n$$\n\n### Part 2: Discretization and Formulation of the Linear System\n\nNext, we discretize the derived BVP using the finite difference method on a uniform grid. The domain $[0, 1]$ is divided into $N+1$ subintervals of equal width $h = 1/(N+1)$. The grid points are $x_i = ih$ for $i = 0, 1, \\dots, N+1$. The values of the solution at these grid points are denoted by $u_i = u(x_i)$.\n\nThe ODE $u''(x) - u(x) = x$ must hold at each interior grid point $x_i$ for $i = 1, 2, \\dots, N$:\n$$u''(x_i) - u(x_i) = x_i$$\n\nWe approximate the second derivative $u''(x_i)$ using the second-order central difference formula:\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n\nSubstituting this approximation into the ODE gives a system of algebraic equations for the unknown interior values $\\{u_1, u_2, \\dots, u_N\\}$:\n$$\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - u_i = x_i, \\quad \\text{for } i = 1, 2, \\dots, N$$\n\nTo form a linear system, we rearrange the equation, grouping terms involving the unknowns on the left side:\n$$u_{i-1} - 2u_i - h^2 u_i + u_{i+1} = h^2 x_i$$\n$$1 \\cdot u_{i-1} + (-2 - h^2)u_i + 1 \\cdot u_{i+1} = h^2 (ih) = ih^3$$\n\nThis set of $N$ equations forms a tridiagonal linear system $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$.\n\nThe $N \\times N$ matrix $A$ has the following structure:\n- Main diagonal elements: $A_{ii} = -2 - h^2$\n- Sub-diagonal elements: $A_{i, i-1} = 1$\n- Super-diagonal elements: $A_{i, i+1} = 1$\n\n$$A = \\begin{pmatrix}\n-2-h^2 & 1 & 0 & \\dots & 0 \\\\\n1 & -2-h^2 & 1 & \\dots & 0 \\\\\n0 & 1 & -2-h^2 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & 1 \\\\\n0 & \\dots & 0 & 1 & -2-h^2\n\\end{pmatrix}$$\n\nThe right-hand side vector $\\mathbf{b}$ is an $N \\times 1$ column vector. We must incorporate the given Dirichlet boundary conditions, $u_0 = 1$ and $u_{N+1} = e-1$.\n\nFor the first equation ($i=1$):\n$$u_0 + (-2 - h^2)u_1 + u_2 = 1 \\cdot h^3$$\nSince $u_0 = 1$ is known, we move it to the right-hand side:\n$$(-2 - h^2)u_1 + u_2 = h^3 - u_0 = h^3 - 1$$\nThus, the first element of the vector $\\mathbf{b}$ is $b_1 = h^3 - 1$.\n\nFor the last equation ($i=N$):\n$$u_{N-1} + (-2 - h^2)u_N + u_{N+1} = N h^3$$\nSince $u_{N+1} = e-1$ is known, we move it to the right-hand side:\n$$u_{N-1} + (-2 - h^2)u_N = Nh^3 - u_{N+1} = Nh^3 - (e-1)$$\nThus, the last element of the vector $\\mathbf{b}$ is $b_N = Nh^3 - e + 1$.\n\nFor the general interior equations ($i=2, \\dots, N-1$):\n$$u_{i-1} + (-2-h^2)u_i + u_{i+1} = ih^3$$\nThe corresponding elements of $\\mathbf{b}$ are $b_i = ih^3$.\n\nIn summary, the right-hand side vector $\\mathbf{b} = [b_1, b_2, \\dots, b_N]^T$ is:\n$$b_i = \\begin{cases}\nh^3 - 1 & \\text{if } i=1 \\\\\nih^3 & \\text{if } 2 \\le i \\le N-1 \\\\\nNh^3 - (e-1) & \\text{if } i=N\n\\end{cases}$$\nThe case $N=1$ is handled correctly by this construction, as the conditions for $i=1$ and $i=N$ would both apply to $b_1$, resulting in $b_1 = (h^3-1) - (e-1) = h^3 - e$, which is correct for a single equation $u_0 + (-2-h^2)u_1 + u_2 = h^3 \\implies (-2-h^2)u_1 = h^3 - u_0 - u_2$.\n\n### Part 3: Implementation Algorithm\n\nThe implementation will perform the following steps for each value of $N$ in the test suite $\\{1, 10, 20, 40\\}$:\n1.  **Initialize Parameters**: Calculate the step size $h = 1/(N+1)$ and the value of $e$.\n2.  **Construct Linear System**:\n    -   Create the tridiagonal matrix $A$ in a banded format suitable for efficient solvers (e.g., `scipy.linalg.solve_banded`). This requires creating a $3 \\times N$ array where rows represent the super-diagonal, main diagonal, and sub-diagonal.\n    -   Construct the right-hand side vector $\\mathbf{b}$ of size $N$ according to the formulas derived in Part 2.\n3.  **Solve System**: Solve the linear system $A\\mathbf{u} = \\mathbf{b}$ for the vector of interior solutions $\\mathbf{u} = [u_1, \\dots, u_N]^T$.\n4.  **Reconstruct Full Solution**: Assemble the complete numerical solution vector, including the boundary values: $U_{num} = [u_0, u_1, \\dots, u_N, u_{N+1}] = [1, \\mathbf{u}^T, e-1]^T$.\n5.  **Compute Exact Solution**: Create the vector of grid points $X = [x_0, x_1, \\dots, x_{N+1}]$ where $x_i = ih$. Evaluate the exact solution $u(x) = e^x - x$ at each grid point to get the vector $U_{exact}$.\n6.  **Calculate Error**: Compute the maximum absolute error between the numerical and exact solutions over all grid points: $E_{max} = \\max_{i \\in \\{0, \\dots, N+1\\}} |U_{num, i} - U_{exact, i}|$.\n7.  **Store and Format Result**: Round the computed maximum error to eight decimal places and store it. After processing all values of $N$, format the collected results into the specified string format.\n\nThis procedure will be encapsulated in a Python program using the `numpy` and `scipy` libraries as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the BVP u''(x) - u(x) = x on [0,1] with u(0)=1, u(1)=e-1\n    using a finite difference scheme for a given set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 20, 40]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Initialize Parameters\n        # N: number of interior points\n        # There are N+2 total points (including boundaries)\n        h = 1.0 / (N + 1)\n        \n        # Exact boundary values\n        u0 = 1.0\n        uN_plus_1 = np.e - 1.0\n\n        # Step 2: Construct the tridiagonal linear system A*u = b\n        \n        # Construct the tridiagonal matrix A in banded format for SciPy.\n        # The format is a (3, N) array:\n        # Row 0: Super-diagonal (padded with a 0 at the start)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (padded with a 0 at the end)\n        ab = np.zeros((3, N))\n        ab[0, 1:] = 1.0  # Super-diagonal\n        ab[1, :] = -2.0 - h**2  # Main diagonal\n        ab[2, :-1] = 1.0  # Sub-diagonal\n\n        # Construct the right-hand side vector b\n        # Start with the base value b_i = i * h^3\n        b = np.array([(i + 1) * h**3 for i in range(N)])\n        \n        # Incorporate boundary conditions\n        b[0] -= u0\n        b[-1] -= uN_plus_1\n        \n        # Step 3: Solve the system for the interior points u\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Step 4: Reconstruct the full numerical solution grid function\n        u_numerical = np.concatenate(([u0], u_interior, [uN_plus_1]))\n\n        # Step 5: Compute the exact solution at grid points\n        # Grid points x_i = i*h for i = 0, ..., N+1\n        x = np.linspace(0, 1, N + 2)\n        u_exact = np.exp(x) - x\n\n        # Step 6: Calculate the maximum absolute error\n        # The error at the boundaries is zero by construction (up to float precision)\n        max_error = np.max(np.abs(u_numerical - u_exact))\n        \n        # Add the rounded result to the list\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to eight decimal places.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3104017"}, {"introduction": "Building upon our foundational solver, we now extend its capabilities to handle Neumann boundary conditions, which specify the derivative of the solution at a boundary. This scenario is common in physics and engineering, representing constraints on flux or temperature gradients. You will implement the \"ghost point\" method, an elegant technique that preserves the second-order accuracy of our centered-difference scheme [@problem_id:3211343]. This exercise also introduces the crucial practice of performing a convergence study to numerically verify that your solver achieves its theoretical order of accuracy.", "problem": "You are tasked with designing and implementing a second-order finite difference solver for a one-dimensional boundary value problem for an ordinary differential equation with a Neumann boundary condition. The mathematical model is the linear Poisson equation\n$$\nu''(x) = f(x), \\quad x \\in [0,1],\n$$\nwith a Neumann boundary condition at the left endpoint and a Dirichlet boundary condition at the right endpoint:\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\nYou must use a uniform grid with $$m$$ equal subdivisions of the interval $$[0,1]$$, with grid points $$x_i = i h$$ where $$h = 1/m$$ and $$i = 0,1,\\dots,m$$. Your numerical method must:\n- Use the standard second-order centered difference approximation of the second derivative at interior nodes.\n- Implement the Neumann condition at $$x=0$$ using a \"ghost point\" so that the derivative at the boundary is approximated by a centered difference, and eliminate the ghost point by invoking the ordinary differential equation $$u''(x)=f(x)$$ and appropriate Taylor expansions to preserve second-order accuracy. The design must start from fundamental definitions (grid, Taylor expansions, and the ordinary differential equation) and avoid ad hoc formulas.\n- Incorporate the Dirichlet boundary condition at $$x=1$$ in a way that retains second-order accuracy at the last interior node.\n\nYour program must solve the discrete linear system for the interior unknowns $$u(x_i)$$ at $$i=1,2,\\dots,m-1$$, and then evaluate the maximum absolute error relative to an exact analytical solution over the interior grid points $$\\{x_i\\}_{i=1}^{m-1}$$.\n\nFor validation, derive exact analytical solutions by integrating $$u''(x)=f(x)$$ twice and using the boundary conditions to determine integration constants. For each test case below, the program must compute:\n- The numerical solution at interior grid points using your second-order scheme with the ghost point treatment at $$x=0$$.\n- The exact solution at the same interior grid points.\n- The maximum absolute error (the infinity norm of the pointwise error vector) over interior points, expressed as a real number.\n\nAdditionally, for a convergence assessment test, compute the observed order of accuracy $$p$$ defined by\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right),\n$$\nwhere $$E_{h}$$ and $$E_{h/2}$$ are the maximum absolute errors for grids with $$m$$ and $$2m$$ subdivisions, respectively.\n\nUse the following test suite:\n1. Happy path: $$f(x) = 2$$, $$\\alpha = 1$$, $$\\beta = 0$$, $$m = 50$$. The exact solution is found by solving $$u''(x)=2$$ with the given boundary conditions.\n2. Boundary-condition-dominant coarse grid: $$f(x) = 0$$, $$\\alpha = 0$$, $$\\beta = 1$$, $$m = 4$$. The exact solution is constant.\n3. Oscillatory forcing: $$f(x) = -\\pi^2 \\sin(\\pi x)$$, $$\\alpha = 0$$, $$\\beta = 0$$, $$m = 64$$. The exact solution is obtained by solving $$u''(x) = -\\pi^2 \\sin(\\pi x)$$ with the given boundary conditions.\n4. Convergence order: $$f(x) = x$$, $$\\alpha = 0$$, $$\\beta = 0$$ with two grids $$m=20$$ and $$m=40$$. Compute the observed order $$p$$ as defined above.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite above. The first three entries must be real numbers representing the maximum absolute error for each case, and the last entry must be a real number representing the observed order for the convergence test. For example, the output should look like $$[e_1,e_2,e_3,p]$$, where each $$e_i$$ and $$p$$ are real numbers.", "solution": "The user-provided problem is valid as it is scientifically grounded in the theory of numerical methods for ordinary differential equations, is mathematically well-posed, and is defined with objective, formal criteria. This document provides a complete derivation of the numerical method and the analytical solutions for validation.\n\nThe problem is to solve the one-dimensional Poisson equation, a linear second-order ordinary differential equation (ODE), on the interval $x \\in [0,1]$:\n$$\nu''(x) = f(x)\n$$\nwith a Neumann boundary condition at $x=0$ and a Dirichlet boundary condition at $x=1$:\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n\nWe will construct a second-order finite difference scheme to approximate the solution.\n\n**1. Discretization of the Domain**\n\nThe domain $[0,1]$ is discretized into a uniform grid with $m$ subdivisions. The grid spacing is $h = 1/m$. The grid points are defined as $x_i = i h$ for $i = 0, 1, \\dots, m$. Let $U_i$ be the numerical approximation of the exact solution $u(x_i)$ at grid point $x_i$. The boundary condition at $x=1$ gives $U_m = u(1) = \\beta$. The values to be determined are $U_0, U_1, \\dots, U_{m-1}$.\n\n**2. Finite Difference Approximation for Interior Points**\n\nFor any interior grid point $x_i$ where $i = 1, 2, \\dots, m-1$, we approximate the second derivative $u''(x_i)$ using the second-order centered difference formula. This is derived from Taylor series expansions of $u(x_{i+1})$ and $u(x_{i-1})$ around $x_i$:\n$$\nu(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n$$\nu(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\nAdding these two expansions and rearranging for $u''(x_i)$ yields:\n$$\nu''(x_i) = \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + \\dots\n$$\nThe approximation is second-order accurate, with a local truncation error of $O(h^2)$. Replacing $u(x_i)$ with $U_i$ and $u''(x_i)$ with $f(x_i)$ from the ODE, we obtain the discrete equations for the interior nodes:\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i), \\quad \\text{for } i = 1, 2, \\dots, m-1.\n$$\n\n**3. Discretization of the Neumann Boundary Condition at $x=0$**\n\nThe problem requires using a ghost point to maintain second-order accuracy. We introduce a ghost point at $x_{-1} = -h$.\nFirst, we approximate the derivative $u'(0) = \\alpha$ using a second-order centered difference at $x_0 = 0$:\n$$\nu'(0) = \\frac{u(x_1) - u(x_{-1})}{2h} + O(h^2) \\implies \\frac{U_1 - U_{-1}}{2h} = \\alpha\n$$\nThis gives an expression for the ghost value $U_{-1}$:\n$$\nU_{-1} = U_1 - 2h\\alpha\n$$\nNext, we assume the ODE $u''(x) = f(x)$ also holds at the boundary point $x_0=0$. We apply the centered difference formula for $u''(0)$:\n$$\n\\frac{U_{-1} - 2U_0 + U_1}{h^2} = f(x_0)\n$$\nNow, we eliminate the ghost point $U_{-1}$ by substituting its expression into this equation:\n$$\n\\frac{(U_1 - 2h\\alpha) - 2U_0 + U_1}{h^2} = f(x_0)\n$$\nSimplifying this expression gives the equation for the node $i=0$:\n$$\n\\frac{-2U_0 + 2U_1 - 2h\\alpha}{h^2} = f(x_0) \\implies -2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha\n$$\nThe local truncation error of this boundary scheme is $O(h)$, which is sufficient to ensure the global error of the overall method is $O(h^2)$.\n\n**4. Assembly of the Linear System**\n\nWe have a system of $m$ linear equations for the $m$ unknowns $U_0, U_1, \\dots, U_{m-1}$. Let $\\mathbf{U} = [U_0, U_1, \\dots, U_{m-1}]^T$ be the vector of unknowns. The system can be written as $A \\mathbf{U} = \\mathbf{b}$.\n\nThe equations are:\n- For $i=0$: $-2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha$\n- For $i=1, \\dots, m-2$: $U_{i-1} - 2U_i + U_{i+1} = h^2 f(x_i)$\n- For $i=m-1$: $U_{m-2} - 2U_{m-1} + U_m = h^2 f(x_{m-1})$. Since $U_m = \\beta$, this becomes $U_{m-2} - 2U_{m-1} = h^2 f(x_{m-1}) - \\beta$.\n\nThe $m \\times m$ coefficient matrix $A$ is:\n$$\nA = \\begin{pmatrix}\n-2 & 2 & 0 & \\cdots & \\cdots & 0 \\\\\n1 & -2 & 1 & \\ddots & & \\vdots \\\\\n0 & 1 & -2 & 1 & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\vdots & & \\ddots & 1 & -2 & 1 \\\\\n0 & \\cdots & \\cdots & 0 & 1 & -2\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ of size $m$ is:\n$$\n\\mathbf{b} = \\begin{pmatrix}\nh^2 f(x_0) + 2h\\alpha \\\\\nh^2 f(x_1) \\\\\n\\vdots \\\\\nh^2 f(x_{m-2}) \\\\\nh^2 f(x_{m-1}) - \\beta\n\\end{pmatrix}\n$$\nThis linear system $A \\mathbf{U} = \\mathbf{b}$ is non-singular and can be solved to find the numerical solution $\\mathbf{U}$.\n\n**5. Error Calculation and Convergence Order**\n\nThe maximum absolute error $E_h$ is computed over the interior grid points $\\{x_i\\}_{i=1}^{m-1}$ as the infinity norm of the error vector:\n$$\nE_h = \\max_{i=1,\\dots,m-1} |U_i - u(x_i)|\n$$\nFor a second-order accurate method, the error is expected to behave as $E_h \\approx C h^2$ for some constant $C$. The order of accuracy $p$ can be observed numerically by comparing errors from two different grid sizes, $h$ and $h/2$.\n$$\nE_h \\approx C h^p \\quad \\text{and} \\quad E_{h/2} \\approx C (h/2)^p\n$$\nTaking the ratio gives $\\frac{E_h}{E_{h/2}} \\approx 2^p$. Solving for $p$ yields:\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right)\n$$\n\n**6. Analytical Solutions for Test Cases**\n\nThe exact solution $u(x)$ is found by integrating $u''(x) = f(x)$ twice and applying the boundary conditions $u'(0) = \\alpha$ and $u(1) = \\beta$ to determine the constants of integration.\n\n- **Case 1:** $f(x) = 2$, $\\alpha = 1$, $\\beta = 0$.\n$u'' = 2 \\implies u'(x) = 2x+C_1$. $u'(0)=C_1=1$. So $u'(x)=2x+1$.\n$u(x) = x^2+x+C_2$. $u(1)=1+1+C_2=0 \\implies C_2=-2$.\n$u(x) = x^2+x-2$.\n\n- **Case 2:** $f(x) = 0$, $\\alpha = 0$, $\\beta = 1$.\n$u'' = 0 \\implies u'(x) = C_1$. $u'(0)=C_1=0$. So $u'(x)=0$.\n$u(x) = C_2$. $u(1)=C_2=1$.\n$u(x) = 1$.\n\n- **Case 3:** $f(x) = -\\pi^2 \\sin(\\pi x)$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = -\\pi^2 \\sin(\\pi x) \\implies u'(x) = \\pi \\cos(\\pi x)+C_1$. $u'(0)=\\pi+C_1=0 \\implies C_1=-\\pi$.\n$u'(x) = \\pi \\cos(\\pi x) - \\pi$.\n$u(x) = \\sin(\\pi x) - \\pi x + C_2$. $u(1)=\\sin(\\pi)-\\pi+C_2=0 \\implies C_2=\\pi$.\n$u(x) = \\sin(\\pi x) - \\pi x + \\pi$.\n\n- **Case 4:** $f(x) = x$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = x \\implies u'(x) = x^2/2+C_1$. $u'(0)=C_1=0$. So $u'(x)=x^2/2$.\n$u(x) = x^3/6+C_2$. $u(1)=1/6+C_2=0 \\implies C_2=-1/6$.\n$u(x) = \\frac{x^3}{6} - \\frac{1}{6}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the finite difference solver.\n    \"\"\"\n\n    def run_solver(f, alpha, beta, m):\n        \"\"\"\n        Solves u''(x) = f(x) with u'(0)=alpha, u(1)=beta on a grid with m subdivisions.\n        \n        Args:\n            f (callable): The forcing function f(x).\n            alpha (float): The Neumann boundary condition value at x=0.\n            beta (float): The Dirichlet boundary condition value at x=1.\n            m (int): The number of grid subdivisions.\n            \n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: Grid points for the interior, x_1, ..., x_{m-1}.\n                - np.ndarray: Numerical solution at the interior points, U_1, ..., U_{m-1}.\n        \"\"\"\n        # Grid setup\n        h = 1.0 / m\n        # We solve for unknowns at x_0, x_1, ..., x_{m-1}\n        x_nodes = np.linspace(0, 1, m + 1)\n        \n        # Assemble the m x m matrix A\n        A = np.zeros((m, m))\n        \n        # Fill diagonals for the standard interior stencil (1, -2, 1)\n        np.fill_diagonal(A, -2.0)\n        # Lower diagonal (k=-1): A[i, i-1] = 1 for i=1,...,m-1\n        np.fill_diagonal(A[1:], 1.0)\n        # Upper diagonal (k=1): A[i, i+1] = 1 for i=0,...,m-2\n        np.fill_diagonal(A[:, 1:], 1.0)\n        \n        # Modify the first row for the Neumann condition: -2*U_0 + 2*U_1 = ...\n        A[0, 1] = 2.0\n        \n        # Assemble the right-hand side vector b of size m\n        # We evaluate f at x_0, ..., x_{m-1}\n        b = h**2 * f(x_nodes[0:m])\n        \n        # Modify first and last elements of b for boundary conditions\n        # b_0 = h^2*f(x_0) + 2*h*alpha\n        b[0] += 2.0 * h * alpha\n        # b_{m-1} = h^2*f(x_{m-1}) - beta\n        b[m-1] -= beta\n        \n        # Solve the linear system A*U = b for U = [U_0, ..., U_{m-1}]\n        U = np.linalg.solve(A, b)\n        \n        # Return interior grid points and corresponding solution values\n        return x_nodes[1:m], U[1:]\n\n    results = []\n\n    # Test Case 1: Happy path\n    f1 = lambda x: 2.0 * np.ones_like(x)\n    u_exact1 = lambda x: x**2 + x - 2.0\n    alpha1, beta1, m1 = 1.0, 0.0, 50\n    x_interior1, U_interior1 = run_solver(f1, alpha1, beta1, m1)\n    u_exact_vals1 = u_exact1(x_interior1)\n    error1 = np.max(np.abs(U_interior1 - u_exact_vals1))\n    results.append(error1)\n\n    # Test Case 2: Boundary-condition-dominant coarse grid\n    f2 = lambda x: np.zeros_like(x)\n    u_exact2 = lambda x: np.ones_like(x)\n    alpha2, beta2, m2 = 0.0, 1.0, 4\n    x_interior2, U_interior2 = run_solver(f2, alpha2, beta2, m2)\n    u_exact_vals2 = u_exact2(x_interior2)\n    error2 = np.max(np.abs(U_interior2 - u_exact_vals2))\n    results.append(error2)\n\n    # Test Case 3: Oscillatory forcing\n    f3 = lambda x: -np.pi**2 * np.sin(np.pi * x)\n    u_exact3 = lambda x: np.sin(np.pi * x) - np.pi * x + np.pi\n    alpha3, beta3, m3 = 0.0, 0.0, 64\n    x_interior3, U_interior3 = run_solver(f3, alpha3, beta3, m3)\n    u_exact_vals3 = u_exact3(x_interior3)\n    error3 = np.max(np.abs(U_interior3 - u_exact_vals3))\n    results.append(error3)\n\n    # Test Case 4: Convergence order\n    f4 = lambda x: x\n    u_exact4 = lambda x: x**3 / 6.0 - 1.0 / 6.0\n    alpha4, beta4 = 0.0, 0.0\n    \n    # Solve on grid with m=20\n    m_h = 20\n    x_h, U_h = run_solver(f4, alpha4, beta4, m_h)\n    u_h = u_exact4(x_h)\n    E_h = np.max(np.abs(U_h - u_h))\n    \n    # Solve on grid with m=40\n    m_h2 = 40\n    x_h2, U_h2 = run_solver(f4, alpha4, beta4, m_h2)\n    u_h2 = u_exact4(x_h2)\n    E_h2 = np.max(np.abs(U_h2 - u_h2))\n    \n    order_p = np.log2(E_h / E_h2)\n    results.append(order_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3211343"}, {"introduction": "This final practice confronts a challenging class of problems known as singularly perturbed BVPs, where a small parameter $\\varepsilon$ gives rise to sharp gradients called \"boundary layers.\" Naively applying a standard uniform grid often yields poor, oscillatory results. This exercise demonstrates how to use a stability-enhancing \"upwind\" scheme and a specially designed \"Shishkin\" mesh that concentrates grid points inside the boundary layer [@problem_id:3211184]. By successfully resolving the sharp layer, you will gain insight into why adapting the numerical method to the structure of the problem is a cornerstone of advanced scientific computing.", "problem": "Consider the boundary value problem for a singularly perturbed ordinary differential equation on the closed interval $[0,1]$:\n$$\n\\varepsilon\\, u''(x) + u'(x) = 0,\\quad x\\in(0,1),\\qquad u(0)=1,\\quad u(1)=0,\n$$\nwhere $\\varepsilon>0$ is a given parameter. The goal is to study numerically how the solution develops a sharp boundary layer as $\\varepsilon\\to 0^+$ and to quantify the accuracy of different meshes.\n\nTask:\n- Starting from the fundamental definition of the derivative as a limit of difference quotients, construct a consistent finite difference discretization of the above boundary value problem on a grid of nodes $0=x_0<x_1<\\cdots<x_N=1$.\n- Use an upwind difference for the first derivative $u'(x)$ consistent with the sign of the convective term, and a second-order central difference for $u''(x)$ adapted to nonuniform meshes using only local grid spacings.\n- Impose the boundary conditions directly at $x_0$ and $x_N$.\n- Solve the resulting tridiagonal linear system for the nodal values.\n\nMesh families to be used:\n- A uniform mesh with $N$ subintervals, i.e., $x_i=i/N$ for $i=0,1,\\dots,N$, so all spacings are $h=1/N$.\n- A Shishkin-type piecewise-uniform mesh with $N$ even, defined by a transition point\n$$\n\\sigma = \\min\\left(\\tfrac{1}{2},\\, 2\\,\\varepsilon \\,\\ln N\\right),\n$$\nusing $N/2$ uniform subintervals on $[0,\\sigma]$ and $N/2$ uniform subintervals on $[\\sigma,1]$.\n\nVerification:\n- Derive the exact solution of the boundary value problem by solving the homogeneous linear ordinary differential equation with the given boundary conditions and use it to compute the pointwise error at the grid nodes. Report the maximum absolute error over all nodes for each test.\n\nTest suite:\n- Use the following four test cases, each specified by a triple $(\\varepsilon, \\text{mesh}, N)$:\n    - $(10^{-1}, \\text{uniform}, 128)$\n    - $(10^{-3}, \\text{uniform}, 128)$\n    - $(10^{-6}, \\text{uniform}, 128)$\n    - $(10^{-6}, \\text{Shishkin}, 128)$\n- For each test case, compute the numerical solution on the specified mesh and return the maximum absolute error with respect to the exact solution evaluated at the grid nodes.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered in the same order as the test suite above.\n- Each number must be printed in scientific notation with six digits after the decimal point.\n- Example of the required format (with placeholder values): \"[1.234567e-01,2.345678e-03,3.456789e-05,4.567890e-07]\".\n\nAll answers are purely numerical floats. No physical units are involved. Angles are not used. Percentages are not used. The program must be self-contained and require no input.", "solution": "The user-provided problem statement is a well-posed boundary value problem from the field of numerical analysis for ordinary differential equations. It is scientifically grounded in the theory of singular perturbations, self-contained, and objectively stated. All parameters, discretization methods, mesh generation rules, and test cases are clearly and unambiguously defined. Therefore, the problem is deemed valid and a complete solution is provided below.\n\nThe core of the problem is to solve the singularly perturbed convection-diffusion equation and analyze the numerical error for different meshes. The solution involves four main steps: deriving the analytical solution, constructing the finite difference scheme, formulating and solving the resulting linear system, and implementing the specified mesh generation strategies.\n\nFirst, we derive the exact analytical solution to the boundary value problem, which will serve as the benchmark for measuring numerical error. The given ordinary differential equation (ODE) is\n$$\n\\varepsilon\\, u''(x) + u'(x) = 0, \\quad x \\in (0,1).\n$$\nThis is a second-order linear homogeneous ODE with constant coefficients. The corresponding characteristic equation is $\\varepsilon r^2 + r = 0$, which factors as $r(\\varepsilon r + 1) = 0$. The roots are $r_1 = 0$ and $r_2 = -1/\\varepsilon$. The general solution to the ODE is therefore\n$$\nu(x) = C_1 e^{r_1 x} + C_2 e^{r_2 x} = C_1 + C_2 e^{-x/\\varepsilon},\n$$\nwhere $C_1$ and $C_2$ are constants to be determined by the boundary conditions $u(0)=1$ and $u(1)=0$.\nApplying the boundary condition at $x=0$:\n$$\nu(0) = C_1 + C_2 e^0 = C_1 + C_2 = 1.\n$$\nApplying the boundary condition at $x=1$:\n$$\nu(1) = C_1 + C_2 e^{-1/\\varepsilon} = 0.\n$$\nSolving this $2 \\times 2$ system for $C_1$ and $C_2$, we find\n$$\nC_2 = \\frac{1}{1 - e^{-1/\\varepsilon}}, \\quad C_1 = -C_2 e^{-1/\\varepsilon} = \\frac{-e^{-1/\\varepsilon}}{1 - e^{-1/\\varepsilon}}.\n$$\nSubstituting these constants back into the general solution gives the exact solution:\n$$\nu(x) = \\frac{-e^{-1/\\varepsilon} + e^{-x/\\varepsilon}}{1 - e^{-1/\\varepsilon}} = \\frac{e^{-x/\\varepsilon} - e^{-1/\\varepsilon}}{1 - e^{-1/\\varepsilon}}.\n$$\nThis solution confirms the presence of an exponential boundary layer of width $O(\\varepsilon)$ near $x=0$.\n\nNext, we construct the finite difference discretization on a grid of nodes $0=x_0 < x_1 < \\dots < x_N=1$. Let $U_i$ be the numerical approximation of $u(x_i)$. The grid may be non-uniform, so we define the local step sizes as $h_i = x_i - x_{i-1}$ for $i=1, \\dots, N$.\nThe problem specifies the discretization for each derivative term at an interior node $x_i$:\nFor the second derivative, $u''(x_i)$, we use a second-order central difference adapted for a non-uniform mesh, which is derived from Taylor series expansions around $x_i$:\n$$\nu''(x_i) \\approx \\frac{2}{h_i + h_{i+1}} \\left( \\frac{U_{i+1} - U_i}{h_{i+1}} - \\frac{U_i - U_{i-1}}{h_i} \\right),\n$$\nwhere $h_{i+1} = x_{i+1} - x_i$.\nFor the first derivative, $u'(x_i)$, we use an upwind scheme. The coefficient of the advection term $u'(x)$ is $1 > 0$, indicating the \"wind\" blows from left to right. Therefore, a backward difference is appropriate:\n$$\nu'(x_i) \\approx \\frac{U_i - U_{i-1}}{h_i}.\n$$\nSubstituting these discrete approximations into the ODE $\\varepsilon u''(x) + u'(x)=0$ at each interior node $x_i$ (for $i=1, \\dots, N-1$) yields the finite difference equation:\n$$\n\\varepsilon \\left( \\frac{2}{h_i + h_{i+1}} \\left( \\frac{U_{i+1} - U_i}{h_{i+1}} - \\frac{U_i - U_{i-1}}{h_i} \\right) \\right) + \\left( \\frac{U_i - U_{i-1}}{h_i} \\right) = 0.\n$$\nWe rearrange this equation by collecting coefficients for the nodal values $U_{i-1}$, $U_i$, and $U_{i+1}$ to form a linear equation $L_i U_{i-1} + D_i U_i + R_i U_{i+1} = 0$, where:\n$$\nL_i = \\left(\\frac{2\\varepsilon}{h_i(h_i+h_{i+1})} - \\frac{1}{h_i}\\right), \\quad D_i = \\left(\\frac{1}{h_i} - \\frac{2\\varepsilon}{h_i h_{i+1}}\\right), \\quad R_i = \\left(\\frac{2\\varepsilon}{h_{i+1}(h_i+h_{i+1})}\\right).\n$$\nThis set of $N-1$ equations for the $N-1$ unknown interior nodal values $U_1, \\dots, U_{N-1}$ forms a tridiagonal linear system. The boundary conditions $U_0 = 1$ and $U_N = 0$ are incorporated into the equations for the first and last interior nodes.\nFor $i=1$: $D_1 U_1 + R_1 U_2 = -L_1 U_0 = -L_1(1) = \\frac{1}{h_1} - \\frac{2\\varepsilon}{h_1(h_1+h_2)}$.\nFor $i=N-1$: $L_{N-1} U_{N-2} + D_{N-1} U_{N-1} = -R_{N-1} U_N = -R_{N-1}(0) = 0$.\nThe resulting $(N-1) \\times (N-1)$ tridiagonal system $\\mathbf{A}\\mathbf{U} = \\mathbf{b}$, where $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$, is then solved numerically.\n\nThe problem requires using two types of meshes:\n1.  A uniform mesh with $N$ subintervals, giving $N+1$ nodes $x_i = i/N$ for $i=0, \\dots, N$. The step size is constant: $h_i=h=1/N$ for all $i$.\n2.  A Shishkin-type piecewise-uniform mesh, defined for an even integer $N$. A transition point $\\sigma = \\min\\left(\\frac{1}{2}, 2\\varepsilon \\ln N\\right)$ partitions the domain into $[0, \\sigma]$ and $[\\sigma, 1]$. The fine-grid region $[0, \\sigma]$ is divided into $N/2$ intervals of width $h_{fine} = \\sigma / (N/2)$, and the coarse-grid region $[\\sigma, 1]$ is divided into $N/2$ intervals of width $h_{coarse} = (1-\\sigma) / (N/2)$. This mesh concentrates nodes in the boundary layer region.\n\nThe numerical solution $\\mathbf{U} = \\{U_i\\}_{i=0}^N$ is obtained by solving the linear system and including the boundary values. The accuracy is assessed by computing the maximum absolute pointwise error against the exact solution evaluated at the grid nodes:\n$$\n\\text{Error} = \\max_{i=0, \\dots, N} |U_i - u(x_i)|.\n$$\nThe following program implements this entire procedure for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    def exact_solution(x, eps):\n        \"\"\"\n        Computes the exact solution of the BVP.\n        u(x) = (exp(-x/eps) - exp(-1/eps)) / (1 - exp(-1/eps))\n        \"\"\"\n        numerator = np.exp(-x / eps) - np.exp(-1.0 / eps)\n        denominator = 1.0 - np.exp(-1.0 / eps)\n        # Avoid division by zero if denominator is zero (theoretically only for eps=inf)\n        if denominator == 0:\n            return np.zeros_like(x) # Should not happen for eps > 0\n        return numerator / denominator\n\n    def create_uniform_mesh(N):\n        \"\"\"\n        Generates a uniform mesh with N subintervals.\n        \"\"\"\n        x = np.linspace(0.0, 1.0, N + 1)\n        return x\n\n    def create_shishkin_mesh(eps, N):\n        \"\"\"\n        Generates a Shishkin piecewise-uniform mesh.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"N must be an even integer for Shishkin mesh.\")\n        \n        sigma = min(0.5, 2.0 * eps * np.log(N))\n        \n        n_half = N // 2\n        \n        x_fine = np.linspace(0.0, sigma, n_half + 1)\n        x_coarse = np.linspace(sigma, 1.0, n_half + 1)\n        \n        # Concatenate, removing the duplicate transition point sigma\n        x = np.concatenate((x_fine[:-1], x_coarse))\n        return x\n\n    def solve_bvp(eps, N, mesh_type):\n        \"\"\"\n        Solves the BVP for a given epsilon, N, and mesh type.\n        \"\"\"\n        if mesh_type == 'uniform':\n            x = create_uniform_mesh(N)\n        elif mesh_type == 'Shishkin':\n            x = create_shishkin_mesh(eps, N)\n        else:\n            raise ValueError(\"Unknown mesh type.\")\n\n        h_spacings = np.diff(x)\n        \n        num_unknowns = N - 1\n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n        \n        # Populate the tridiagonal matrix A and vector b\n        # Loop over interior nodes i = 1, ..., N-1\n        for i in range(1, N):\n            matrix_row_idx = i - 1\n            \n            # h_i = x_i - x_{i-1} corresponds to h_spacings[i-1]\n            # h_{i+1} = x_{i+1} - x_i corresponds to h_spacings[i]\n            h_i = h_spacings[i-1]\n            h_i_plus_1 = h_spacings[i]\n            \n            # Coefficients of the equation at node i: L_i*U_{i-1} + D_i*U_i + R_i*U_{i+1} = 0\n            # L_i: sub-diagonal, D_i: main diagonal, R_i: super-diagonal\n            \n            L_i = (2.0 * eps) / (h_i * (h_i + h_i_plus_1)) - 1.0 / h_i\n            D_i = 1.0 / h_i - (2.0 * eps) / (h_i * h_i_plus_1)\n            R_i = (2.0 * eps) / (h_i_plus_1 * (h_i + h_i_plus_1))\n            \n            if i > 1:\n                A[matrix_row_idx, matrix_row_idx - 1] = L_i\n            \n            A[matrix_row_idx, matrix_row_idx] = D_i\n            \n            if i < N - 1:\n                A[matrix_row_idx, matrix_row_idx + 1] = R_i\n\n        # Apply boundary conditions\n        # For i=1 (first row, index 0): D_1*U_1 + R_1*U_2 = -L_1*U_0\n        # Since U_0 = 1, RHS = -L_1\n        h1 = h_spacings[0]\n        h2 = h_spacings[1]\n        L1 = (2.0 * eps) / (h1 * (h1 + h2)) - 1.0 / h1\n        b[0] = -L1 * 1.0\n        \n        # For i=N-1 (last row, index N-2): L_{N-1}*U_{N-2} + D_{N-1}*U_{N-1} = -R_{N-1}*U_N\n        # Since U_N = 0, RHS is 0, which is the default value in b.\n\n        # Solve the linear system for internal nodes\n        U_internal = np.linalg.solve(A, b)\n        \n        # Assemble the full solution vector, including boundary values\n        U = np.concatenate(([1.0], U_internal, [0.0]))\n        \n        # Calculate maximum absolute error\n        U_ex = exact_solution(x, eps)\n        max_error = np.max(np.abs(U - U_ex))\n        \n        return max_error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1e-1, 'uniform', 128),\n        (1e-3, 'uniform', 128),\n        (1e-6, 'uniform', 128),\n        (1e-6, 'Shishkin', 128)\n    ]\n\n    results = []\n    for eps, mesh_type, N in test_cases:\n        error = solve_bvp(eps, N, mesh_type)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6e}' for r in results])}]\")\n\nsolve()\n```", "id": "3211184"}]}