{"hands_on_practices": [{"introduction": "Before we can apply stability theory, we must first understand how to determine the stability properties of a given numerical method. This first practice [@problem_id:3197800] guides you to derive the stability function $R(z)$ directly from a method's fundamental definition, its Butcher tableau. By implementing a numerical experiment to trace the stability boundary, where $|R(z)|=1$, you will build a tangible intuition for abstract concepts like A-stability and L-stability and see how they manifest for different types of integrators.", "problem": "Consider the linear test problem $y'(t)=\\lambda\\,y(t)$ with complex $\\lambda$, and define $z=h\\,\\lambda$ for time step $h$. When a one-step method is applied to this problem, it produces an update $y_{n+1}=R(z)\\,y_n$ for some scalar function $R(z)$, called the stability function. A method is said to have Absolute stability (A-stability) if for every $z$ with $\\operatorname{Re}(z)\\le 0$, the inequality $|R(z)|\\le 1$ holds. A method is said to have the stiff decay property (L-stability) if it is A-stable and additionally $\\lim_{|z|\\to\\infty,\\,\\operatorname{Re}(z)0} R(z)=0$. Starting from these base definitions and the standard construction of the stability function by applying a method to $y'(t)=\\lambda\\,y(t)$, derive $R(z)$ for each method in the test suite below, and design a numerical experiment that traces the real-axis intersection of the boundary $|R(z)|=1$ and infers A-stability by exploring large negative real $z$ and small negative real $z$ on a fine grid.\n\nYour program must:\n- Implement a procedure that, given a method specification, constructs the corresponding stability function $R(z)$ entirely from first principles, by applying the method to the test problem $y'(t)=\\lambda\\,y(t)$ and eliminating intermediate variables to obtain the factor relating $y_{n+1}$ to $y_n$ as a function of $z$.\n- For each method, generate a fine grid of real $z$ values over $[-50,0]$ and compute $|R(z)|$ on that grid.\n- Numerically identify and count all real-axis points in $[-50,0]$ where the boundary condition $|R(z)|=1$ is met. You must detect both crossing events and exact hits to within a small tolerance.\n- Infer A-stability on the real axis by checking whether $|R(z)|\\le 1$ for all $z\\in[-50,0]$ on the grid (this is an empirical inference restricted to the negative real axis). Report this inference as a boolean.\n- Infer L-stability by checking whether $|R(z)|$ evaluated at a large negative real value $z=-1000$ is below $0.01$. Report this inference as a boolean.\n\nUse the following test suite of Rungeâ€“Kutta methods expressed by their Butcher tableau $(A,b)$:\n- Explicit (forward) Euler: $A=\\begin{bmatrix}0\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n- Implicit (backward) Euler: $A=\\begin{bmatrix}1\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n- Trapezoidal rule (two-stage implicit): $A=\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$, $b=\\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$.\n\nNumerical parameters to use:\n- Real-axis exploration range $z\\in[-50,0]$ with a uniform grid of $5001$ points.\n- Boundary detection tolerance for equality $|R(z)|=1$ of $10^{-8}$.\n- L-stability threshold at $z=-1000$ of $0.01$.\n\nFor each method, your program must return a list of three items:\n- The integer count of distinct real-axis boundary points in $[-50,0]$ where $|R(z)|=1$.\n- A boolean indicating the empirical A-stability inference on the negative real axis based on the grid.\n- A boolean indicating the empirical L-stability inference based on the threshold at $z=-1000$.\n\nFinal output format:\n- Your program should produce a single line of output containing the three method results as a comma-separated list enclosed in square brackets, where each method result is itself a comma-separated list enclosed in square brackets. For example: $[[a_1,a_2,a_3],[b_1,b_2,b_3],[c_1,c_2,c_3]]$.", "solution": "The analysis of a numerical method's stability is fundamental to computational science. It determines the range of time steps $h$ for which the numerical solution to a differential equation remains bounded. The standard approach involves applying the method to the linear test problem $y'(t) = \\lambda y(t)$, where $\\lambda$ is a complex number with $\\operatorname{Re}(\\lambda) \\le 0$. This models the behavior of stiff systems, where different components evolve on vastly different time scales. Applying a one-step numerical method to this equation yields a recurrence relation of the form $y_{n+1} = R(z) y_n$, where $z = h\\lambda$ and $R(z)$ is the stability function. For the numerical solution to be stable, we require $|R(z)| \\le 1$.\n\nA general $s$-stage Runge-Kutta (RK) method is defined by its Butcher tableau, consisting of a matrix $A \\in \\mathbb{R}^{s \\times s}$ and a vector of weights $b \\in \\mathbb{R}^s$. When applied to the test problem $y'(t) = \\lambda y(t)$, the update rule is:\n$$ y_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i $$\nThe internal stage derivatives $k_i$ are given by:\n$$ k_i = f(t_n + c_i h, Y_i) = \\lambda Y_i = \\lambda \\left( y_n + h \\sum_{j=1}^s a_{ij} k_j \\right) $$\nfor $i=1, \\dots, s$. Let $z=h\\lambda$. The equations for the stage derivatives become:\n$$ k_i = \\frac{z}{h} \\left( y_n + h \\sum_{j=1}^s a_{ij} k_j \\right) = \\frac{z}{h} y_n + z \\sum_{j=1}^s a_{ij} k_j $$\nThis is a system of $s$ linear equations for the vector $\\mathbf{k} = [k_1, \\dots, k_s]^T$. In matrix form, with $\\mathbf{1}$ being the vector of ones:\n$$ \\mathbf{k} - z A \\mathbf{k} = \\frac{z}{h} y_n \\mathbf{1} \\implies (I - zA) \\mathbf{k} = \\frac{z}{h} y_n \\mathbf{1} $$\nSolving for $\\mathbf{k}$ yields:\n$$ \\mathbf{k} = \\frac{z}{h} y_n (I - zA)^{-1} \\mathbf{1} $$\nSubstituting this back into the update formula for $y_{n+1}$, written with vector notation as $y_{n+1} = y_n + h \\mathbf{b}^T \\mathbf{k}$:\n$$ y_{n+1} = y_n + h \\mathbf{b}^T \\left( \\frac{z}{h} y_n (I - zA)^{-1} \\mathbf{1} \\right) = y_n + z y_n \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1} $$\nFactoring out $y_n$, we identify the stability function $R(z)$:\n$$ R(z) = 1 + z \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1} $$\nThis general formula allows us to derive $R(z)$ for any RK method given its Butcher tableau $(A, b)$.\n\nWe now apply this formula to the specified methods.\n\n1.  **Explicit (Forward) Euler Method**:\n    The Butcher tableau is $s=1$, $A=\\begin{bmatrix}0\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n    The matrix $(I - zA)$ is the $1 \\times 1$ matrix $[1 - z(0)] = [1]$, whose inverse is $[1]$.\n    $$ R(z) = 1 + z [1] [1] [1] = 1 + z $$\n\n2.  **Implicit (Backward) Euler Method**:\n    The Butcher tableau is $s=1$, $A=\\begin{bmatrix}1\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$.\n    The matrix $(I - zA)$ is $[1 - z(1)] = [1-z]$, whose inverse is $[(1-z)^{-1}]$.\n    $$ R(z) = 1 + z [1] [(1-z)^{-1}] [1] = 1 + \\frac{z}{1-z} = \\frac{1-z+z}{1-z} = \\frac{1}{1-z} $$\n\n3.  **Trapezoidal Rule**:\n    This is a $2$-stage implicit method with $A=\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}$ and $b=\\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix}^T$.\n    First, we compute $(I - zA)^{-1}$:\n    $$ I - zA = \\begin{bmatrix}1  0 \\\\ 0  1\\end{bmatrix} - z\\begin{bmatrix}0  0 \\\\ \\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} = \\begin{bmatrix}1  0 \\\\ -z/2  1 - z/2\\end{bmatrix} $$\n    The inverse is:\n    $$ (I - zA)^{-1} = \\frac{1}{1(1-z/2) - 0} \\begin{bmatrix}1 - z/2  0 \\\\ z/2  1\\end{bmatrix} = \\frac{1}{1 - z/2} \\begin{bmatrix}1 - z/2  0 \\\\ z/2  1\\end{bmatrix} $$\n    Now we substitute this into the formula for $R(z)$:\n    $$ R(z) = 1 + z \\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} \\frac{1}{1-z/2} \\begin{bmatrix}1-z/2  0 \\\\ z/2  1\\end{bmatrix} \\begin{bmatrix}1 \\\\ 1\\end{bmatrix} $$\n    $$ R(z) = 1 + \\frac{z}{1-z/2} \\begin{bmatrix}\\tfrac{1}{2}  \\tfrac{1}{2}\\end{bmatrix} \\begin{bmatrix}1-z/2 \\\\ 1+z/2\\end{bmatrix} = 1 + \\frac{z}{1-z/2} \\left( \\frac{1}{2}(1-z/2) + \\frac{1}{2}(1+z/2) \\right) $$\n    $$ R(z) = 1 + \\frac{z}{1-z/2} (1) = \\frac{1-z/2+z}{1-z/2} = \\frac{1+z/2}{1-z/2} $$\n\nThe numerical experiment is designed as follows:\n\n1.  **Stability Function Implementation**: A general function is created that takes $A$ and $b$ and returns the corresponding stability function $R(z)$. This function computes $R(z) = 1 + z \\mathbf{b}^T (I - zA)^{-1} \\mathbf{1}$ and is vectorized to operate over an array of $z$ values.\n\n2.  **Grid Generation**: A uniform grid of $5001$ complex-valued points is generated for $z$ on the real-axis interval $[-50, 0]$.\n\n3.  **Boundary Point Counting**: To find where $|R(z)| = 1$, we analyze the function $g(z) = |R(z)| - 1$ on the grid. We count the number of \"boundary events\" using a stateful algorithm that iterates through the grid. An event is counted if we encounter a contiguous region of points where $|g(z_i)| \\le 10^{-8}$ (a \"hit\") or if there is a sign change $g(z_i)g(z_{i+1})  0$ between two non-hit points (a \"crossing\"). This prevents double-counting.\n\n4.  **A-stability Inference**: A-stability requires $|R(z)| \\le 1$ for all $\\operatorname{Re}(z) \\le 0$. Our experiment provides an empirical test restricted to the negative real axis. We compute $\\max(|R(z)|)$ over our grid $z \\in [-50, 0]$ and check if this maximum is less than or equal to $1$ (allowing for a small tolerance of $10^{-8}$). The result is a boolean.\n\n5.  **L-stability Inference**: L-stability requires A-stability and $\\lim_{|z|\\to\\infty,\\,\\operatorname{Re}(z)0} R(z)=0$. We test this second condition empirically by evaluating $|R(z)|$ at a large-magnitude negative real value, $z=-1000$. If the method is inferred to be A-stable from the previous step and $|R(-1000)|  0.01$, we infer it is L-stable. The result is a boolean.\n\nThis procedure is applied to each of the three methods, and the results are compiled.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and analyzes the stability functions for three Runge-Kutta methods.\n    \"\"\"\n\n    def get_stability_function(A, b):\n        \"\"\"\n        Constructs the stability function R(z) for a given Butcher tableau.\n        \n        Args:\n            A (np.ndarray): The A matrix of the Butcher tableau.\n            b (np.ndarray): The b vector of the Butcher tableau.\n\n        Returns:\n            A function that computes R(z) for a scalar or vector z.\n        \"\"\"\n        s = A.shape[0]\n        I = np.identity(s)\n        ones_s = np.ones((s, 1))\n        b_T = b.reshape(1, -1)\n\n        def R(z):\n            \"\"\"The stability function R(z).\"\"\"\n            # Vectorized implementation\n            if not np.isscalar(z):\n                z = np.asarray(z, dtype=np.complex128)\n                results = np.zeros_like(z, dtype=np.complex128)\n                for i, z_val in enumerate(z):\n                    if z_val == 0:\n                        results[i] = 1.0 + 0.0j\n                        continue\n                    try:\n                        mat_inv = np.linalg.inv(I - z_val * A)\n                        r_val = 1.0 + z_val * b_T @ mat_inv @ ones_s\n                        results[i] = r_val.item()\n                    except np.linalg.LinAlgError:\n                        results[i] = np.inf + 0.0j\n                return results\n\n            # Scalar implementation\n            z = complex(z)\n            if z == 0:\n                return 1.0 + 0.0j\n            try:\n                mat_inv = np.linalg.inv(I - z * A)\n                r_val = 1.0 + z * b_T @ mat_inv @ ones_s\n                return r_val.item()\n            except np.linalg.LinAlgError:\n                return np.inf + 0.0j\n        \n        return R\n\n    # Define the Butcher tableaus for the methods in the test suite.\n    test_cases = [\n        {\n            \"name\": \"Explicit (Forward) Euler\",\n            \"A\": np.array([[0.0]]),\n            \"b\": np.array([1.0]),\n        },\n        {\n            \"name\": \"Implicit (Backward) Euler\",\n            \"A\": np.array([[1.0]]),\n            \"b\": np.array([1.0]),\n        },\n        {\n            \"name\": \"Trapezoidal Rule\",\n            \"A\": np.array([[0.0, 0.0], [0.5, 0.5]]),\n            \"b\": np.array([0.5, 0.5]),\n        },\n    ]\n\n    # Numerical parameters from the problem statement\n    z_min = -50.0\n    z_max = 0.0\n    num_points = 5001\n    tolerance = 1e-8\n    l_stability_z = -1000.0\n    l_stability_threshold = 0.01\n\n    z_grid = np.linspace(z_min, z_max, num_points)\n    \n    final_results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        \n        # 1. Construct the stability function R(z)\n        R = get_stability_function(A, b)\n        \n        # 2. Compute |R(z)| on the grid\n        abs_R = np.abs(R(z_grid))\n\n        # 3. Count real-axis boundary points where |R(z)| = 1\n        g = abs_R - 1.0\n        boundary_points_count = 0\n        in_hit_region = False\n        for i in range(len(g) - 1):\n            is_current_hit = np.abs(g[i]) = tolerance\n            if is_current_hit:\n                if not in_hit_region:\n                    boundary_points_count += 1\n                in_hit_region = True\n            else:\n                if in_hit_region:\n                    in_hit_region = False\n                \n                # Check for a crossing only if the next point is not the start of a new hit region.\n                # This prevents double counting a crossing that leads into a hit.\n                is_next_hit = np.abs(g[i+1]) = tolerance\n                if g[i] * g[i+1]  0 and not is_next_hit:\n                    boundary_points_count += 1\n        \n        # Check the last point for a hit\n        is_last_hit = np.abs(g[-1]) = tolerance\n        if is_last_hit and not in_hit_region:\n            boundary_points_count += 1\n\n        # 4. Infer A-stability on the negative real axis\n        # Allow for small floating point errors near the boundary\n        is_A_stable_real = np.all(abs_R = 1.0 + tolerance)\n        \n        # 5. Infer L-stability\n        abs_R_inf = np.abs(R(l_stability_z))\n        is_L_stable = is_A_stable_real and (abs_R_inf  l_stability_threshold)\n        \n        final_results.append([boundary_points_count, is_A_stable_real, is_L_stable])\n\n    # Format the final output string as specified.\n    # e.g., [[a1,a2,a3],[b1,b2,b3],[c1,c2,c3]]\n    # Python's bool `True`/`False` needs to be lowercase `true`/`false` for some environments.\n    # However, the example shows list of lists, which implies `str()` on bool is fine. `str(True)` is 'True'.\n    # If JSON is intended, it would be `true`. But the format is a string of Python lists.\n    # The problem asks for comma-separated list of items, so the Python `str` representation is correct.\n    \n    formatted_results = []\n    for res in final_results:\n        # str(True) - \"True\", str(False) - \"False\"\n        formatted_results.append(f\"[{res[0]},{res[1]},{res[2]}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3197800"}, {"introduction": "Knowing the shape of a stability region is essential, particularly for explicit methods, as it imposes a direct constraint on the maximum allowable time step. This exercise [@problem_id:3197733] moves from the abstract $z$-plane to the practical challenge of integrating a system of linear ordinary differential equations, $y'(t) = Ay$. You will develop a procedure to find the largest possible time step $\\Delta t$ that guarantees a stable solution, a critical skill for preventing numerical instability and ensuring the reliability of your simulations.", "problem": "You are given the initial value problem $y'(t)=A_{\\text{sys}}\\,y(t)$, where $A_{\\text{sys}}$ is a complex-valued matrix and $y(t)$ is a complex-valued vector function. Consider integrating this system using a fixed-step explicit Rungeâ€“Kutta method described by a Butcher tableau. The stability of the time integration is governed by the behavior of the method on the linear test equation $y'(t)=\\lambda\\,y(t)$, where $\\lambda\\in\\mathbb{C}$. For an explicit Rungeâ€“Kutta method, its stability region is the set of $z\\in\\mathbb{C}$ such that the corresponding scalar amplification factor applied to $y'(t)=\\lambda\\,y(t)$ satisfies $\\lvert R(z)\\rvert\\leq 1$, where $z=\\Delta t\\,\\lambda$ and $\\Delta t$ is the time step size. A method is called A-stable if its stability region includes the entire left half-plane $\\{z\\in\\mathbb{C}:\\Re(z)\\leq 0\\}$, and is L-stable if it is A-stable and additionally $R(z)\\to 0$ as $z\\to -\\infty$ along the real axis. Explicit Rungeâ€“Kutta methods are not A-stable, so the maximal stable $\\Delta t$ is generally finite, even when $\\Re(\\lambda)0$.\n\nStarting from the fundamental base of the linear test equation and the definition of the Rungeâ€“Kutta method through its Butcher tableau, derive the stability function $R(z)$ for the given method, justify the stability criterion $\\lvert R(\\Delta t\\,\\lambda)\\rvert\\leq 1$ for each eigenvalue $\\lambda$ of $A_{\\text{sys}}$, and construct a numerical search procedure that, for a fixed Rungeâ€“Kutta method and a given system matrix $A_{\\text{sys}}$, finds the maximal $\\Delta t0$ such that all scaled eigenvalues $z_i=\\Delta t\\,\\lambda_i$ lie within the stability region, i.e., $\\lvert R(z_i)\\rvert\\leq 1$ for all eigenvalues $\\lambda_i$ of $A_{\\text{sys}}$. Your program must not assume a pre-tabulated stability polynomial; it must obtain $R(z)$ directly from the Butcher tableau and the definition of the method applied to $y'(t)=\\lambda\\,y(t)$.\n\nUse the classical $4$-stage explicit Rungeâ€“Kutta method (often referred to as \"RK$4$\") with the following Butcher tableau:\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix},\\quad\nc=\\begin{bmatrix}\n0\\\\\n\\frac{1}{2}\\\\\n\\frac{1}{2}\\\\\n1\n\\end{bmatrix}.\n$$\n\nDesign your program to apply this single RK method to each of the following test matrices $A_{\\text{sys}}^{(k)}$ and for each matrix compute a single float value: the maximal $\\Delta t$ such that the stability condition $\\lvert R(\\Delta t\\,\\lambda_i)\\rvert\\leq 1$ holds simultaneously for all eigenvalues $\\lambda_i$ of $A_{\\text{sys}}^{(k)}$. The search must be performed along the rays $z=\\Delta t\\,\\lambda_i$ in $\\mathbb{C}$ for $\\Delta t\\geq 0$, and should return the largest $\\Delta t$ satisfying the constraint. If the constraint only holds for $\\Delta t=0$, your program must return $0.0$ for that case. All numerical outputs must be rounded to $8$ decimal places.\n\nTest suite:\n- Case $1$ (general negative real eigenvalues):\n$$\nA_{\\text{sys}}^{(1)}=\\begin{bmatrix}\n-2  0\\\\\n0  -5\n\\end{bmatrix}.\n$$\n- Case $2$ (positive real eigenvalues):\n$$\nA_{\\text{sys}}^{(2)}=\\begin{bmatrix}\n1  0\\\\\n0  \\frac{1}{2}\n\\end{bmatrix}.\n$$\n- Case $3$ (complex-conjugate pair with negative real part):\n$$\nA_{\\text{sys}}^{(3)}=\\begin{bmatrix}\n-1  -4\\\\\n1  -1\n\\end{bmatrix}.\n$$\n- Case $4$ (highly oscillatory with small damping):\n$$\nA_{\\text{sys}}^{(4)}=\\begin{bmatrix}\n-0.1  10\\\\\n-10  -0.1\n\\end{bmatrix}.\n$$\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, with each float rounded to $8$ decimal places and no spaces. For example, the output must look like $[d_1,d_2,d_3,d_4]$ where each $d_k$ is a decimal string with exactly $8$ digits after the decimal point.", "solution": "The user-provided problem has been validated and is determined to be a well-posed, scientifically grounded problem in the field of numerical analysis for ordinary differential equations. All necessary information is provided, and the problem is free of contradictions or ambiguities. I will now proceed with a complete solution.\n\n### 1. The Explicit Runge-Kutta Method and the Stability Function\n\nAn $s$-stage explicit Rungeâ€“Kutta (ERK) method for solving the initial value problem $y'(t) = f(t, y(t))$ is defined by the equations:\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i k_i \\\\\nk_i = f\\left(t_n + c_i \\Delta t, y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\nThe coefficients $a_{ij}$, $b_i$, and $c_i$ are given by a Butcher tableau, which for an explicit method has a strictly lower triangular matrix $A = (a_{ij})$.\n\nTo analyze the stability of the method, we apply it to the Dahlquist test equation, $y'(t) = \\lambda y(t)$, where $\\lambda \\in \\mathbb{C}$. In this case, $f(t, y) = \\lambda y$. The stage values $k_i$ become:\n$$\nk_i = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} k_j\\right)\n$$\nLet us define the scaled time step $z = \\Delta t \\lambda$. We can observe that each stage vector $k_i$ must be proportional to $\\lambda y_n$. Let $k_i = K_i(z) \\lambda y_n$ for some function $K_i(z)$. Substituting this into the stage equation:\n$$\nK_i(z) \\lambda y_n = \\lambda \\left(y_n + \\Delta t \\sum_{j=1}^{i-1} a_{ij} (K_j(z) \\lambda y_n)\\right)\n$$\nDividing by $\\lambda y_n$ (assuming $\\lambda, y_n \\neq 0$), we obtain a recurrence relation for the stage polynomials $K_i(z)$:\n$$\nK_i(z) = 1 + z \\sum_{j=1}^{i-1} a_{ij} K_j(z)\n$$\nwith $K_1(z) = 1$ since the sum is empty for $i=1$. Because $A$ is strictly lower triangular, we can compute each $K_i(z)$ sequentially. $K_i(z)$ is a polynomial in $z$ of degree $i-1$.\n\nThe numerical solution is updated as:\n$$\ny_{n+1} = y_n + \\Delta t \\sum_{i=1}^s b_i (K_i(z) \\lambda y_n) = y_n \\left(1 + z \\sum_{i=1}^s b_i K_i(z)\\right)\n$$\nThe term in the parenthesis is the amplification factor, which maps $y_n$ to $y_{n+1}$. This is the stability function $R(z)$:\n$$\nR(z) = 1 + z \\sum_{i=1}^s b_i K_i(z)\n$$\nFor an $s$-stage ERK method, $R(z)$ is a polynomial in $z$ of degree at most $s$.\n\n### 2. Stability Function for the Classical RK4 Method\n\nThe problem provides the Butcher tableau for the classical $4$-stage Runge-Kutta method ($s=4$):\n$$\nA_{\\text{RK}}=\\begin{bmatrix}\n0  0  0  0\\\\\n\\frac{1}{2}  0  0  0\\\\\n0  \\frac{1}{2}  0  0\\\\\n0  0  1  0\n\\end{bmatrix},\\quad\nb=\\begin{bmatrix}\n\\frac{1}{6}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{3}\\\\\n\\frac{1}{6}\n\\end{bmatrix}\n$$\nWe derive the stage polynomials $K_i(z)$:\n\\begin{align*}\nK_1(z) = 1 \\\\\nK_2(z) = 1 + z a_{21} K_1(z) = 1 + z \\left(\\frac{1}{2}\\right)(1) = 1 + \\frac{z}{2} \\\\\nK_3(z) = 1 + z (a_{31} K_1(z) + a_{32} K_2(z)) = 1 + z \\left(0 + \\frac{1}{2}\\left(1 + \\frac{z}{2}\\right)\\right) = 1 + \\frac{z}{2} + \\frac{z^2}{4} \\\\\nK_4(z) = 1 + z (a_{41} K_1 + a_{42} K_2 + a_{43} K_3) = 1 + z \\left(0 + 0 + 1\\left(1 + \\frac{z}{2} + \\frac{z^2}{4}\\right)\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{4}\n\\end{align*}\nNow, we construct the stability function $R(z)$:\n$$\nR(z) = 1 + z \\left( b_1 K_1(z) + b_2 K_2(z) + b_3 K_3(z) + b_4 K_4(z) \\right)\n$$\nSubstituting the values of $b_i$ and polynomials $K_i(z)$:\n$$\nR(z) = 1 + z \\left[ \\frac{1}{6}(1) + \\frac{1}{3}\\left(1+\\frac{z}{2}\\right) + \\frac{1}{3}\\left(1+\\frac{z}{2}+\\frac{z^2}{4}\\right) + \\frac{1}{6}\\left(1+z+\\frac{z^2}{2}+\\frac{z^3}{4}\\right) \\right]\n$$\nCombining terms by powers of $z$ inside the brackets:\n\\begin{itemize}\n    \\item Constant term: $\\frac{1}{6} + \\frac{1}{3} + \\frac{1}{3} + \\frac{1}{6} = 1$\n    \\item Term in $z$: $\\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{3}\\left(\\frac{1}{2}\\right) + \\frac{1}{6}(1) = \\frac{1}{6} + \\frac{1}{6} + \\frac{1}{6} = \\frac{1}{2}$\n    \\item Term in $z^2$: $\\frac{1}{3}\\left(\\frac{1}{4}\\right) + \\frac{1}{6}\\left(\\frac{1}{2}\\right) = \\frac{1}{12} + \\frac{1}{12} = \\frac{1}{6}$\n    \\item Term in $z^3$: $\\frac{1}{6}\\left(\\frac{1}{4}\\right) = \\frac{1}{24}$\n\\end{itemize}\nMultiplying the expression in brackets by $z$ and adding $1$, we get:\n$$\nR(z) = 1 + z\\left(1 + \\frac{1}{2}z + \\frac{1}{6}z^2 + \\frac{1}{24}z^3\\right) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24} = \\sum_{k=0}^{4} \\frac{z^k}{k!}\n$$\nThis is the Taylor series expansion of $e^z$ truncated to the 4th order.\n\n### 3. Stability Criterion for Linear Systems\n\nFor the system of ODEs $y'(t) = A_{\\text{sys}} y(t)$, assuming $A_{\\text{sys}}$ is diagonalizable, there exists an invertible matrix $P$ such that $A_{\\text{sys}} = P \\Lambda P^{-1}$, where $\\Lambda$ is the diagonal matrix of eigenvalues $\\lambda_i$ of $A_{\\text{sys}}$.\nBy the change of variables $u(t) = P^{-1} y(t)$, the system decouples into a set of independent scalar equations: $u_i'(t) = \\lambda_i u_i(t)$.\nApplying a Runge-Kutta method to the original system $y' = A_{\\text{sys}} y$ is equivalent to applying the same method to each of these scalar equations. The update rule for the transformed variables is:\n$u_{i, n+1} = R(\\Delta t \\lambda_i) u_{i, n}$.\nFor the numerical solution $y_n$ to remain bounded as $n \\to \\infty$, all components $u_{i,n}$ must remain bounded. This requires that the amplification factor for each component has a magnitude no greater than one:\n$$\n|R(\\Delta t \\lambda_i)| \\leq 1 \\quad \\text{for all eigenvalues } \\lambda_i \\text{ of } A_{\\text{sys}}\n$$\nThis is the condition for numerical stability.\n\n### 4. Algorithm for Maximal Stable Time Step $\\Delta t_{\\max}$\n\nWe seek the largest $\\Delta t \\geq 0$ that satisfies the stability condition for all eigenvalues simultaneously. This is $\\Delta t_{\\max} = \\sup\\{\\Delta t \\geq 0 \\mid |R(\\Delta t \\lambda_i)| \\leq 1 \\text{ for all } i\\}$.\n\nThe algorithm is as follows:\n1.  Compute the set of eigenvalues $\\{\\lambda_i\\}$ of the matrix $A_{\\text{sys}}$.\n2.  For each eigenvalue $\\lambda_i$:\n    a. If $\\Re(\\lambda_i)  0$, the physical system is unstable. The numerical method will also be unstable for any $\\Delta t  0$, because for small $z=\\Delta t \\lambda_i$, $|R(z)| \\approx |1+z| = \\sqrt{(1+\\Delta t \\Re(\\lambda_i))^2 + (\\Delta t \\Im(\\lambda_i))^2}  1$. Thus, $\\Delta t_{\\max} = 0$.\n    b. If $\\lambda_i=0$, $R(0)=1$, so this eigenvalue imposes no restriction on $\\Delta t$.\n    c. If $\\Re(\\lambda_i) \\leq 0$ and $\\lambda_i \\neq 0$, we must find the smallest positive $\\Delta t_i^*$ such that $|R(\\Delta t_i^* \\lambda_i)| = 1$. This value represents the boundary of the stability region along the ray defined by $\\lambda_i$.\n3.  The overall maximal stable time step is the minimum of these individual limits: $\\Delta t_{\\max} = \\min_{i} \\{\\Delta t_i^*\\}$.\n\nTo find $\\Delta t_i^*$, we solve the equation $|R(\\Delta t \\lambda_i)| - 1 = 0$ for the smallest positive root $\\Delta t$. This is a nonlinear equation that we can solve numerically. A robust approach is to first bracket the root and then use a root-finding algorithm like Brent's method.\n-   **Bracketing**: For a given $\\lambda_i$ with $\\Re(\\lambda_i) \\le 0$, the function $h(\\Delta t) = |R(\\Delta t \\lambda_i)| - 1$ is non-positive for small $\\Delta t0$. Since the stability region of any explicit RK method is bounded, we can find an upper bound $b$ where $h(b)  0$ by starting with a guess and increasing it (e.g., by doubling) until the condition is met. This provides an interval $[a, b]$ containing the root.\n-   **Root-finding**: With the root bracketed in $[a, b]$, `scipy.optimize.brentq` can efficiently find the precise value of $\\Delta t_i^*$.\n\nThe implementation will compute $R(z)$ from the Butcher tableau as derived, then execute this numerical search for each test matrix.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It computes the maximum stable time step for the classical RK4 method\n    for several linear systems.\n    \"\"\"\n    # Butcher tableau for the classical 4-stage Runge-Kutta method (RK4)\n    A_rk4 = np.array([\n        [0.0, 0.0, 0.0, 0.0],\n        [0.5, 0.0, 0.0, 0.0],\n        [0.0, 0.5, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0]\n    ], dtype=float)\n    b_rk4 = np.array([1/6, 1/3, 1/3, 1/6], dtype=float)\n\n    # Test suite of system matrices A_sys\n    test_cases = [\n        # Case 1: general negative real eigenvalues\n        np.array([[-2.0, 0.0], [0.0, -5.0]], dtype=float),\n        # Case 2: positive real eigenvalues\n        np.array([[1.0, 0.0], [0.0, 0.5]], dtype=float),\n        # Case 3: complex-conjugate pair with negative real part\n        np.array([[-1.0, -4.0], [1.0, -1.0]], dtype=float),\n        # Case 4: highly oscillatory with small damping\n        np.array([[-0.1, 10.0], [-10.0, -0.1]], dtype=float)\n    ]\n\n    results = []\n    for A_sys in test_cases:\n        max_dt = find_max_dt(A_sys, A_rk4, b_rk4)\n        results.append(f\"{max_dt:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef compute_R_from_tableau(z, A, b):\n    \"\"\"\n    Computes the value of the stability function R(z) for a given z\n    and a Runge-Kutta method specified by its Butcher tableau (A, b).\n    \"\"\"\n    s = len(b)\n    K = np.zeros(s, dtype=np.complex128)\n    for i in range(s):\n        # K_i(z) = 1 + z * sum(a[i,j] * K_j(z) for j  i)\n        stage_sum = np.dot(A[i, :i], K[:i])\n        K[i] = 1.0 + z * stage_sum\n    \n    # R(z) = 1 + z * sum(b_i * K_i(z))\n    return 1.0 + z * np.dot(b, K)\n\ndef find_max_dt(A_sys, butcher_A, butcher_b):\n    \"\"\"\n    Finds the maximum stable time step dt for a system y'(t) = A_sys*y(t)\n    using the stability function derived from the provided Butcher tableau.\n    \"\"\"\n    try:\n        eigenvalues = np.linalg.eigvals(A_sys)\n    except np.linalg.LinAlgError:\n        return 0.0\n\n    # If any eigenvalue has a positive real part, the system is unstable,\n    # and the time integration will be unstable for any dt  0.\n    if any(lam.real  1e-9 for lam in eigenvalues):\n        return 0.0\n        \n    min_dt_root = float('inf')\n    \n    for lam in eigenvalues:\n        if abs(lam)  1e-9:  # An eigenvalue of 0 imposes no stability constraint.\n            continue\n\n        def h(dt):\n            \"\"\"Target function for root finding: |R(dt*lam)| - 1.\"\"\"\n            z = dt * lam\n            R_val = compute_R_from_tableau(z, butcher_A, butcher_b)\n            return abs(R_val) - 1.0\n\n        # Search for the smallest positive root of h(dt) = 0.\n        # This determines the stability limit for this eigenvalue.\n        \n        # Step 1: Bracket the root. Find an interval [a, b] such that\n        # h(a) = 0 and h(b)  0.\n        # For stable/neutral eigenvalues, h(dt) = 0 for small dt  0.\n        a = 1e-9 # Small positive number to start the search interval.\n        b = 1e-3 # Initial guess for the upper bound.\n        \n        # Exponentially increase b until h(b)  0.\n        while h(b) = 0:\n            b *= 2.0\n            if b  1e6: # Safety break to avoid infinite loops\n                b = float('inf')\n                break\n        \n        if b == float('inf'):\n            # This eigenvalue does not seem to impose a stability constraint\n            # within a reasonable range. This shouldn't happen for explicit methods.\n            continue\n            \n        a = b / 2.0\n        if a == 0: a = 1e-9\n\n        # Step 2: Use Brent's method to find the root within the bracketed interval.\n        try:\n            root = brentq(h, a, b)\n            min_dt_root = min(min_dt_root, root)\n        except ValueError:\n            # Should not happen with the bracketing logic above.\n            # If it does, it implies immediate instability for this eigenvalue.\n            min_dt_root = 0.0\n            break\n\n    if min_dt_root == float('inf'):\n        # This case would occur if all eigenvalues were zero.\n        # Any dt would be stable, so there's no finite maximum.\n        # The problem cases avoid this scenario. Returning 0.0 as a safe default.\n        return 0.0\n        \n    return min_dt_root\n\nsolve()\n```", "id": "3197733"}, {"introduction": "Our final practice synthesizes these concepts into a realistic design problem, placing you in the role of a computational scientist who must choose the right tool for the job. This capstone challenge [@problem_id:3197721] requires you to develop a decision-making algorithm that selects the optimal time integrator from a list of candidates. You will learn to navigate the critical trade-offs between a method's stability properties, its order of accuracy, and its computational cost, all while working within a fixed budget to solve problems that may or may not be stiff.", "problem": "You are given a linear initial value problem whose semidiscretization in space yields an ordinary differential equation of the form $y^{\\prime}(t) = J y(t)$, where $J \\in \\mathbb{C}^{n \\times n}$ is a finite difference Jacobian. For a one-step time integration method applied with a fixed step size $h  0$ to the scalar linear test equation $y^{\\prime} = \\lambda y$, the update has the form $y_{k+1} = R(z) y_{k}$ with $z = h \\lambda$ and method-dependent stability function $R(z)$. The absolute stability region is defined as the set $\\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$. An $A$-stable method is one whose absolute stability region contains the entire left half-plane $\\{ z \\in \\mathbb{C} : \\operatorname{Re}(z) \\le 0 \\}$. An $L$-stable method is an $A$-stable method with the additional property $\\lim_{z \\to -\\infty} R(z) = 0$ along the negative real axis. Your task is to select, for each test case, a time integrator and verify that for all eigenvalues $\\lambda$ of $J$, the scaled values $z = h \\lambda$ lie in the methodâ€™s absolute stability region, and that the total computational work does not exceed the given budget.\n\nYou must select from the following methods, indexed as follows:\n- Index $0$: Explicit Euler.\n- Index $1$: Classical Rungeâ€“Kutta of order $4$.\n- Index $2$: Backward Euler.\n- Index $3$: Trapezoidal rule (Crankâ€“Nicolson).\n\nCost model and selection policy:\n- The total simulated time is $T  0$ and the fixed step size is $h  0$. The number of steps is $N_{\\text{steps}} = \\lceil T / h \\rceil$.\n- Per-step costs (in abstract work units) are constants for each method: explicit Euler costs $1$, classical Rungeâ€“Kutta $4$, backward Euler $30$, trapezoidal rule $50$. The total work is $W = N_{\\text{steps}} \\times \\text{(per-step cost)}$.\n- A method is feasible for a test case if and only if both of the following hold:\n  1. For every eigenvalue $\\lambda$ provided for the case, with $z = h \\lambda$, the corresponding $z$ lies in the methodâ€™s absolute stability region (that is, $|R(z)| \\le 1$).\n  2. The total work $W$ does not exceed the given work budget $W_{\\max}$ for the case.\n- Preference rule for stiffness: define the stiffness indicator $\\sigma = \\max_{\\lambda} \\left( -\\operatorname{Re}(h \\lambda) \\right)$. If $\\sigma \\ge \\tau$ (the provided threshold for the case), then among feasible methods you must prefer an $L$-stable method. If no feasible $L$-stable method exists, fall back to any feasible method. If $\\sigma  \\tau$, ignore the $L$-stability preference.\n- Among methods within the preferred set (either $L$-stable-only when $\\sigma \\ge \\tau$, or all feasible methods when $\\sigma  \\tau$), choose the one with the smallest total work $W$. If there is a tie in total work, choose the method with higher order of accuracy. If there is still a tie, choose the method with the smaller index.\n\nFoundational base you must use:\n- The definition of the absolute stability region for a one-step method applied to $y^{\\prime} = \\lambda y$ is $\\{ z \\in \\mathbb{C} : |R(z)| \\le 1 \\}$.\n- The time-step-to-$z$ mapping is $z = h \\lambda$ for each eigenvalue $\\lambda$.\n- For $A$-stability and $L$-stability classification, you must base your reasoning on the above definitions.\n\nImplement a program that:\n- For each test case, evaluates feasibility and applies the selection policy, using exact stability functions $R(z)$ derived from the standard definitions of each listed method.\n- Produces the index of the selected method as an integer, or $-1$ if no method is feasible.\n\nTest suite:\nProvide outputs for the following $5$ test cases. In each case, the eigenvalues are listed explicitly, $T$, $h$, $W_{\\max}$, and $\\tau$ are given, and the angle unit is radians if needed for any complex arithmetic.\n\n- Case $1$:\n  - Eigenvalues: $\\{-1.0, -2.0\\}$.\n  - $T = 1.0$.\n  - $h = 0.2$.\n  - $W_{\\max} = 6$.\n  - $\\tau = 25$.\n- Case $2$:\n  - Eigenvalues: $\\{-100.0, -200.0\\}$.\n  - $T = 1.0$.\n  - $h = 0.1$.\n  - $W_{\\max} = 400$.\n  - $\\tau = 25$.\n- Case $3$:\n  - Eigenvalues: $\\{-1.0 + 1.0 i, -1.0 - 1.0 i\\}$ with $i = \\sqrt{-1}$.\n  - $T = 2.0$.\n  - $h = 0.2$.\n  - $W_{\\max} = 8$.\n  - $\\tau = 25$.\n- Case $4$:\n  - Eigenvalues: $\\{-25.0\\}$.\n  - $T = 1.0$.\n  - $h = 0.1$.\n  - $W_{\\max} = 50$.\n  - $\\tau = 25$.\n- Case $5$:\n  - Eigenvalues: $\\{-800.0\\}$.\n  - $T = 1.0$.\n  - $h = 0.05$.\n  - $W_{\\max} = 1000$.\n  - $\\tau = 25$.\n\nFinal output format:\nYour program should produce a single line of output containing the selected method indices for the cases in order, as a comma-separated list enclosed in square brackets, for example, $[a,b,c,d,e]$ where each entry is an integer index or $-1$ if no method is feasible. No spaces should appear in the output.", "solution": "The problem requires selecting the most suitable time integration method for a series of linear initial value problems of the form $y'(t) = Jy(t)$, based on criteria of stability, computational cost, and stiffness. This selection process must be performed for five distinct test cases.\n\nThe core of the problem lies in the concept of absolute stability. For the scalar test equation $y' = \\lambda y$, a one-step method with step size $h$ yields an iteration $y_{k+1} = R(z) y_k$, where $z = h\\lambda$ and $R(z)$ is the method's stability function. The method is stable for a given $z$ if and only if $|R(z)| \\le 1$. The set of all such $z \\in \\mathbb{C}$ constitutes the absolute stability region.\n\nFirst, we must establish the properties of the four candidate methods. The properties include the method's index, order of accuracy, per-step computational cost, stability function $R(z)$, and its classification regarding $A$-stability and $L$-stability.\n\nThe four methods are:\n- Index $0$: Explicit Euler (EE), Order $1$, Cost $1$.\n- Index $1$: Classical Runge-Kutta of order $4$ (RK4), Order $4$, Cost $4$.\n- Index $2$: Backward Euler (BE), Order $1$, Cost $30$.\n- Index $3$: Trapezoidal Rule (TR), Order $2$, Cost $50$.\n\nThe stability functions $R(z)$ are derived from applying each method to the test equation $y'=\\lambda y$.\n1.  **Explicit Euler (Method 0)**: The update is $y_{k+1} = y_k + h (\\lambda y_k) = (1+h\\lambda)y_k$.\n    $$R_0(z) = 1 + z$$\n    The stability region is $\\{z \\in \\mathbb{C} : |1+z| \\le 1\\}$, a disk of radius $1$ centered at $z=-1$. This does not contain the left half-plane $\\{z \\in \\mathbb{C} : \\operatorname{Re}(z) \\le 0\\}$, so the method is **not $A$-stable**.\n\n2.  **Classical Runge-Kutta (Method 1)**: This method's stability function is the truncated Taylor series of the exponential function, up to the order of the method. For order $4$, we have:\n    $$R_1(z) = 1 + z + \\frac{z^2}{2} + \\frac{z^3}{6} + \\frac{z^4}{24}$$\n    The stability region is bounded and does not contain the entire left half-plane. For example, for $z = -10$, $|R_1(-10)| \\approx 301  1$. Therefore, RK4 is **not $A$-stable**.\n\n3.  **Backward Euler (Method 2)**: The implicit update is $y_{k+1} = y_k + h (\\lambda y_{k+1})$. Solving for $y_{k+1}$ gives $y_{k+1}(1-h\\lambda) = y_k$, so $y_{k+1} = (1-h\\lambda)^{-1}y_k$.\n    $$R_2(z) = \\frac{1}{1 - z}$$\n    For any $z = x+iy$ with $x = \\operatorname{Re}(z) \\le 0$, we have $|R_2(z)|^2 = |\\frac{1}{1-x-iy}|^2 = \\frac{1}{(1-x)^2 + y^2}$. Since $x \\le 0$, it follows that $1-x \\ge 1$, and thus $(1-x)^2 \\ge 1$. The denominator is always greater than or equal to $1$, so $|R_2(z)| \\le 1$. The method is **$A$-stable**.\n    For $L$-stability, we examine the limit as $z \\to -\\infty$ along the negative real axis: $\\lim_{z \\to -\\infty} R_2(z) = \\lim_{z \\to -\\infty} \\frac{1}{1-z} = 0$. The condition is met, so the method is **$L$-stable**.\n\n4.  **Trapezoidal Rule (Method 3)**: The implicit update is $y_{k+1} = y_k + \\frac{h}{2}(\\lambda y_k + \\lambda y_{k+1})$. Solving for $y_{k+1}$ gives $y_{k+1}(1 - \\frac{h\\lambda}{2}) = y_k(1 + \\frac{h\\lambda}{2})$.\n    $$R_3(z) = \\frac{1 + z/2}{1 - z/2}$$\n    For any $z=x+iy$ with $x = \\operatorname{Re}(z) \\le 0$, $|R_3(z)|^2 = \\frac{|1+x/2+iy/2|^2}{|1-x/2-iy/2|^2} = \\frac{(1+x/2)^2+(y/2)^2}{(1-x/2)^2+(y/2)^2} = \\frac{1+x+x^2/4+y^2/4}{1-x+x^2/4+y^2/4}$. Since $x \\le 0$, the numerator is less than or equal to the denominator, so $|R_3(z)| \\le 1$. The method is **$A$-stable**.\n    For $L$-stability, we check the limit: $\\lim_{z \\to -\\infty} R_3(z) = \\lim_{z \\to -\\infty} \\frac{1+z/2}{1-z/2} = -1$. Since the limit is not $0$, the method is **not $L$-stable**.\n\nThe selection process for each test case is as follows:\n1.  Calculate the number of time steps $N_{\\text{steps}} = \\lceil T/h \\rceil$.\n2.  For each eigenvalue $\\lambda$ provided, compute the corresponding stability parameter $z = h\\lambda$.\n3.  Evaluate the stiffness indicator $\\sigma = \\max_{\\lambda}(-\\operatorname{Re}(z))$.\n4.  For each method (index $i=0, 1, 2, 3$):\n    a. Calculate the total work $W_i = N_{\\text{steps}} \\times \\text{cost}_i$.\n    b. Check the budget constraint: $W_i \\le W_{\\max}$.\n    c. Check the stability constraint: for all computed $z$ values, verify that $|R_i(z)| \\le 1$.\n    d. A method is feasible if both constraints are met.\n5.  From the set of all feasible methods, construct a preferred set.\n    a. If $\\sigma \\ge \\tau$, the preferred set consists of all feasible methods that are $L$-stable. If this set is empty, the preferred set defaults to all feasible methods.\n    b. If $\\sigma  \\tau$, the preferred set is simply the set of all feasible methods.\n6.  If the preferred set is empty, no solution exists, and the result is $-1$. Otherwise, select a single method from the preferred set using a tie-breaking hierarchy:\n    a. Choose the method with the minimum total work $W$.\n    b. If work is tied, choose the method with the highest order of accuracy.\n    c. If still tied, choose the method with the smallest index.\n\nWe now apply this procedure to each test case.\n\n**Case 1**: $\\lambda \\in \\{-1.0, -2.0\\}$, $T=1.0$, $h=0.2$, $W_{\\max}=6$, $\\tau=25$.\n- $N_{\\text{steps}} = \\lceil 1.0/0.2 \\rceil = 5$.\n- $z \\in \\{0.2(-1.0), 0.2(-2.0)\\} = \\{-0.2, -0.4\\}$.\n- $\\sigma = \\max(0.2, 0.4) = 0.4$. Since $\\sigma  \\tau$, there is no preference for $L$-stability.\n- **Method 0 (EE)**: $W_0=5 \\times 1=5 \\le 6$ (OK). $|R_0(-0.2)|=0.8 \\le 1$ and $|R_0(-0.4)|=0.6 \\le 1$ (OK). Feasible.\n- **Method 1 (RK4)**: $W_1=5 \\times 4=20  6$ (Not feasible).\n- **Method 2 (BE)**: $W_2=5 \\times 30=150  6$ (Not feasible).\n- **Method 3 (TR)**: $W_3=5 \\times 50=250  6$ (Not feasible).\nThe only feasible method is Method $0$.\n**Selected Index: $0$**\n\n**Case 2**: $\\lambda \\in \\{-100.0, -200.0\\}$, $T=1.0$, $h=0.1$, $W_{\\max}=400$, $\\tau=25$.\n- $N_{\\text{steps}} = \\lceil 1.0/0.1 \\rceil = 10$.\n- $z \\in \\{0.1(-100.0), 0.1(-200.0)\\} = \\{-10.0, -20.0\\}$.\n- $\\sigma = \\max(10.0, 20.0) = 20.0$. Since $\\sigma  \\tau$, there is no preference for $L$-stability.\n- **Method 0 (EE)**: Stable on $[-2, 0]$ only. Unstable for $z=-10, -20$. (Not feasible).\n- **Method 1 (RK4)**: Stable on approx. $[-2.785, 0]$. Unstable for $z=-10, -20$. (Not feasible).\n- **Method 2 (BE)**: $W_2=10 \\times 30=300 \\le 400$ (OK). $A$-stable, thus stable for $z=-10, -20$ (OK). Feasible.\n- **Method 3 (TR)**: $W_3=10 \\times 50=500  400$ (Not feasible).\nThe only feasible method is Method $2$.\n**Selected Index: $2$**\n\n**Case 3**: $\\lambda \\in \\{-1.0+1.0i, -1.0-1.0i\\}$, $T=2.0$, $h=0.2$, $W_{\\max}=8$, $\\tau=25$.\n- $N_{\\text{steps}} = \\lceil 2.0/0.2 \\rceil = 10$.\n- Smallest possible work is for Method $0$: $W_0=10 \\times 1 = 10$.\n- Since $W_0  W_{\\max}=8$, no method can satisfy the budget constraint.\n**Selected Index: $-1$**\n\n**Case 4**: $\\lambda \\in \\{-25.0\\}$, $T=1.0$, $h=0.1$, $W_{\\max}=50$, $\\tau=25$.\n- $N_{\\text{steps}} = \\lceil 1.0/0.1 \\rceil = 10$.\n- $z = 0.1(-25.0) = -2.5$.\n- $\\sigma = 2.5$. Since $\\sigma  \\tau$, no preference for $L$-stability.\n- **Method 0 (EE)**: Unstable for $z=-2.5$. (Not feasible).\n- **Method 1 (RK4)**: $W_1=10 \\times 4=40 \\le 50$ (OK). $|R_1(-2.5)| \\approx |-0.352| \\le 1$ (OK). Feasible.\n- **Method 2 (BE)**: $W_2=10 \\times 30=300  50$ (Not feasible).\n- **Method 3 (TR)**: $W_3=10 \\times 50=500  50$ (Not feasible).\nThe only feasible method is Method $1$.\n**Selected Index: $1$**\n\n**Case 5**: $\\lambda \\in \\{-800.0\\}$, $T=1.0$, $h=0.05$, $W_{\\max}=1000$, $\\tau=25$.\n- $N_{\\text{steps}} = \\lceil 1.0/0.05 \\rceil = 20$.\n- $z = 0.05(-800.0) = -40.0$.\n- $\\sigma = 40.0$. Since $\\sigma \\ge \\tau$, $L$-stable methods are preferred.\n- **Method 0 (EE)**: Unstable for $z=-40$. (Not feasible).\n- **Method 1 (RK4)**: Unstable for $z=-40$. (Not feasible).\n- **Method 2 (BE)**: $W_2=20 \\times 30=600 \\le 1000$ (OK). $A$-stable (OK). Feasible. Is $L$-stable.\n- **Method 3 (TR)**: $W_3=20 \\times 50=1000 \\le 1000$ (OK). $A$-stable (OK). Feasible. Is not $L$-stable.\nFeasible methods are $\\{2, 3\\}$. The preferred set, due to $\\sigma \\ge \\tau$, consists of feasible $L$-stable methods. Only Method $2$ is $L$-stable. Thus, the preferred set is $\\{2\\}$.\n**Selected Index: $2$**\n\nFinal Results: The selected indices for the five cases are $[0, 2, -1, 1, 2]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\nimport math\n\ndef solve():\n    \"\"\"\n    Solves for the optimal time integrator for a series of test cases based on\n    stability, cost, and stiffness criteria.\n    \"\"\"\n\n    # Define the properties of the four candidate methods.\n    # index, name, order, per_step_cost, is_L_stable, stability_function R(z)\n    methods = [\n        (0, \"Explicit Euler\", 1, 1, False, lambda z: 1 + z),\n        (1, \"RK4\", 4, 4, False, lambda z: 1 + z + z**2/2 + z**3/6 + z**4/24),\n        (2, \"Backward Euler\", 1, 30, True, lambda z: 1 / (1 - z)),\n        (3, \"Trapezoidal Rule\", 2, 50, False, lambda z: (1 + z/2) / (1 - z/2))\n    ]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { \"eigenvalues\": [-1.0, -2.0], \"T\": 1.0, \"h\": 0.2, \"W_max\": 6, \"tau\": 25 },\n        { \"eigenvalues\": [-100.0, -200.0], \"T\": 1.0, \"h\": 0.1, \"W_max\": 400, \"tau\": 25 },\n        { \"eigenvalues\": [-1.0 + 1.0j, -1.0 - 1.0j], \"T\": 2.0, \"h\": 0.2, \"W_max\": 8, \"tau\": 25 },\n        { \"eigenvalues\": [-25.0], \"T\": 1.0, \"h\": 0.1, \"W_max\": 50, \"tau\": 25 },\n        { \"eigenvalues\": [-800.0], \"T\": 1.0, \"h\": 0.05, \"W_max\": 1000, \"tau\": 25 },\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        T = case[\"T\"]\n        h = case[\"h\"]\n        W_max = case[\"W_max\"]\n        tau = case[\"tau\"]\n        eigenvalues = np.array(case[\"eigenvalues\"], dtype=complex)\n\n        n_steps = math.ceil(T / h)\n        \n        # Calculate z values and stiffness indicator sigma\n        z_values = h * eigenvalues\n        if len(z_values) == 0:\n            sigma = 0.0\n        else:\n            sigma = np.max(-np.real(z_values))\n\n        feasible_methods = []\n        for index, name, order, cost, is_l_stable, R_func in methods:\n            # 1. Check budget constraint\n            total_work = n_steps * cost\n            if total_work  W_max:\n                continue\n\n            # 2. Check stability constraint\n            is_stable = True\n            for z in z_values:\n                # Using a small tolerance for floating point comparison |R(z)| = 1\n                if abs(R_func(z))  1.0 + 1e-9:\n                    is_stable = False\n                    break\n            \n            if is_stable:\n                feasible_methods.append({\n                    \"index\": index,\n                    \"work\": total_work,\n                    \"order\": order,\n                    \"l_stable\": is_l_stable\n                })\n\n        if not feasible_methods:\n            final_results.append(-1)\n            continue\n        \n        # Apply selection logic\n        preferred_set = []\n        if sigma = tau:\n            l_stable_feasible = [m for m in feasible_methods if m[\"l_stable\"]]\n            if l_stable_feasible:\n                preferred_set = l_stable_feasible\n            else:\n                # Fallback rule\n                preferred_set = feasible_methods\n        else:\n            preferred_set = feasible_methods\n            \n        # Apply tie-breaking rules by sorting\n        # 1. Smallest total work (ascending)\n        # 2. Highest order of accuracy (descending, so use negative order)\n        # 3. Smallest index (ascending)\n        preferred_set.sort(key=lambda m: (m[\"work\"], -m[\"order\"], m[\"index\"]))\n        \n        best_method_index = preferred_set[0][\"index\"]\n        final_results.append(best_method_index)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3197721"}]}