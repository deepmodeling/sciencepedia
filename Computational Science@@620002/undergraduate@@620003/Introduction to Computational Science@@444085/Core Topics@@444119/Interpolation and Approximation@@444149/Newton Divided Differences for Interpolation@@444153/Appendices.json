{"hands_on_practices": [{"introduction": "Before applying a numerical method to complex problems, it is crucial to verify its implementation against a case with a known, exact answer. This practice serves as a fundamental \"unit test\" for your divided difference algorithm. You will leverage the theoretical property that the $k$-th order divided difference of the monomial $f(x) = x^k$ is exactly 1, regardless of the choice of $k+1$ distinct nodes, to validate your code across various scenarios [@problem_id:3164015].", "problem": "You are tasked with validating numerical computation of Newton's divided differences against an exact symbolic result for a specific class of functions within the domain of introduction to computational science. Work with the monomial function $f(x) = x^k$ and the $k$-th order divided difference over a set of $k+1$ distinct interpolation nodes. Your program must implement the numerical computation of the $k$-th order divided difference using the standard recursive definition of divided differences and compare it to the exact symbolic value that follows from foundational properties of polynomial interpolation. The comparison must be quantified by a boolean decision based on a specified tolerance.\n\nFundamental base for the derivation and validation:\n- The concept of polynomial interpolation: Given $k+1$ distinct points $(x_i, f(x_i))$ for $i \\in \\{0,1,\\dots,k\\}$, there exists a unique polynomial $p(x)$ of degree at most $k$ that interpolates the data.\n- The Newton form of the interpolation polynomial uses coefficients given by divided differences that are constructed from the data $(x_i, f(x_i))$ and the Newton basis of polynomials.\n\nYou must not assume any shortcut formulas that trivially reveal the result; you should reason from the stated fundamental base in your solution. In your program, you will:\n1. Compute the numerical $k$-th order divided difference of $f(x) = x^k$ over the provided nodes using floating-point arithmetic.\n2. Compute the exact symbolic value implied by the foundational properties of polynomial interpolation for $f(x) = x^k$.\n3. Decide if the numerical value matches the exact value within a specified absolute tolerance $\\varepsilon$.\n\nThe test suite consists of the following parameter sets $(k, [x_0,\\dots,x_k])$ designed for coverage of typical and edge scenarios. All nodes are real numbers and are pairwise distinct. Each case uses $f(x) = x^k$:\n- Case $1$: $k = 0$, nodes $[7.5]$.\n- Case $2$: $k = 1$, nodes $[-10.0, 10.0]$.\n- Case $3$: $k = 2$, nodes $[0.0, 0.5, 2.0]$.\n- Case $4$: $k = 3$, nodes $[-10^{-5}, 0.0, 10^{-5}, 2 \\cdot 10^{-5}]$.\n- Case $5$: $k = 4$, nodes $[-1.0, 5.0, -0.5, 0.0, 2.5]$ (unsorted order).\n- Case $6$: $k = 5$, nodes $[1.0, 1.0 + 10^{-8}, 1.0 + 2 \\cdot 10^{-8}, 1.0 + 3 \\cdot 10^{-8}, 1.0 + 4 \\cdot 10^{-8}, 1.0 + 5 \\cdot 10^{-8}]$.\n\nFor each case, your program must:\n- Compute the numerical $k$-th order divided difference $\\widehat{c}_k$ from the given nodes and $f(x) = x^k$.\n- Use the exact symbolic value $c_k$ implied by foundational theory for $f(x) = x^k$.\n- Compare with absolute tolerance $\\varepsilon = 10^{-10}$, and return a boolean $b$ defined as $b = \\left(|\\widehat{c}_k - c_k| \\le \\varepsilon\\right)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the boolean results for the six cases as a comma-separated list enclosed in square brackets, for example, `[True,False,...]`.\n\nNo physical units, angle units, or percentage formats are involved. All outputs are booleans.", "solution": "We begin from the foundational framework of polynomial interpolation. Given $k+1$ distinct nodes $x_0, x_1, \\dots, x_k$ and function values $f(x_i)$, there exists a unique interpolating polynomial $p(x)$ of degree at most $k$ such that $p(x_i) = f(x_i)$ for all $i$. The Newton form of this interpolating polynomial expresses $p(x)$ in the Newton basis:\n$$\np(x) = c_0 + c_1 (x - x_0) + c_2 (x - x_0)(x - x_1) + \\cdots + c_k \\prod_{m=0}^{k-1} (x - x_m),\n$$\nwhere each coefficient $c_j$ is the $j$-th order divided difference $[x_0, x_1, \\dots, x_j] f$.\n\nA core property of the Newton basis $\\prod_{m=0}^{j-1} (x - x_m)$ is that its leading term in $x$ equals $x^j$ with leading coefficient $1$. Consequently, the coefficient of $x^k$ in $p(x)$ is exactly $c_k$, since the product $\\prod_{m=0}^{k-1} (x - x_m)$ has leading term $x^k$ with leading coefficient $1$, while all lower-order basis polynomials have degree less than $k$. Therefore, if $p(x)$ interpolates a polynomial function $f(x)$ of degree at most $k$, the coefficient $c_k$ must equal the leading coefficient of $f(x)$.\n\nApplying this to the specific function $f(x) = x^k$, which is a monomial of degree $k$ with leading coefficient $1$, we conclude:\n$$\n[x_0, x_1, \\dots, x_k] f = 1,\n$$\nfor any choice of $k+1$ distinct nodes $x_0, x_1, \\dots, x_k$. This exact symbolic value $c_k = 1$ arises from the uniqueness of the interpolating polynomial and the structure of the Newton basis.\n\nTo compute the numerical $k$-th order divided difference, we use the standard recursive definition implemented via a triangular scheme (often called the divided difference table). Define the zeroth order divided differences as $d_i^{(0)} = f(x_i)$. For $m = 1$ to $k$, define:\n$$\nd_i^{(m)} = \\frac{d_{i+1}^{(m-1)} - d_i^{(m-1)}}{x_{i+m} - x_i}, \\quad i = 0, 1, \\dots, k - m.\n$$\nThe numerical estimate of the $k$-th order divided difference is then $\\widehat{c}_k = d_0^{(k)}$. This algorithm requires $O(k^2)$ floating-point operations and is standard in numerical interpolation.\n\nNumerical considerations: The computation of divided differences is sensitive to the spacing of the nodes because denominators $x_{i+m} - x_i$ can become very small, magnifying round-off errors. However, double-precision floating-point arithmetic typically suffices for well-scaled problems. The chosen test suite includes:\n- A boundary case $k = 0$ where $[x_0] f = f(x_0) = 1$.\n- Low-degree cases with moderate node spacing.\n- An unsorted node order to emphasize symmetry in the divided difference.\n- A near-coalesced node set for $k = 5$ with increments of $10^{-8}$ to mildly stress numerical conditioning while remaining within a reasonable tolerance.\n\nValidation protocol: For each test case, we compute $\\widehat{c}_k$ numerically via the triangular scheme, compare it to the exact $c_k = 1$, and declare success if $|\\widehat{c}_k - 1| \\le \\varepsilon$ with $\\varepsilon = 10^{-10}$. The program outputs the list of six booleans for the six cases in the required single-line format.\n\nThis approach integrates foundational theory (Newton interpolation and leading coefficients) with an algorithmic design (divided difference table) to validate computation against exact symbolic knowledge.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef monomial_values(xs, k):\n    \"\"\"Compute f(x) = x^k for all x in xs.\"\"\"\n    xs = np.asarray(xs, dtype=np.float64)\n    return xs ** k\n\ndef k_th_divided_difference(xs, ys):\n    \"\"\"\n    Compute the k-th order divided difference using the standard\n    recursive (triangular table) scheme.\n    Assumes len(xs) == len(ys) == k+1 and xs are distinct.\n    \"\"\"\n    n = len(xs)\n    dd = ys.astype(np.float64).copy()\n    # Build the table: dd[i] holds the current order divided differences\n    for m in range(1, n):\n        for i in range(n - m):\n            denom = xs[i + m] - xs[i]\n            dd[i] = (dd[i + 1] - dd[i]) / denom\n    return float(dd[0])\n\ndef solve():\n    # Define the test cases from the problem statement: (k, nodes)\n    test_cases = [\n        (0, [7.5]),\n        (1, [-10.0, 10.0]),\n        (2, [0.0, 0.5, 2.0]),\n        (3, [-1e-5, 0.0, 1e-5, 2e-5]),\n        (4, [-1.0, 5.0, -0.5, 0.0, 2.5]),\n        (5, [1.0, 1.0 + 1e-8, 1.0 + 2e-8, 1.0 + 3e-8, 1.0 + 4e-8, 1.0 + 5e-8]),\n    ]\n\n    tol = 1e-10\n    results = []\n    for k, nodes in test_cases:\n        xs = np.array(nodes, dtype=np.float64)\n        if len(xs) != k + 1:\n            # Defensive check: format requires k+1 nodes for k-th divided difference\n            raise ValueError(f\"Case with k={k} has {len(xs)} nodes; expected {k+1}.\")\n        ys = monomial_values(xs, k)\n        numeric = k_th_divided_difference(xs, ys)\n        exact = 1.0  # For f(x) = x^k, the k-th divided difference equals 1\n        ok = abs(numeric - exact) <= tol\n        results.append(ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3164015"}, {"introduction": "Building on a validated implementation, we can now explore a deeper structural property of polynomial interpolation. This exercise demonstrates that for any polynomial of degree $m$, all divided differences of order $r \\gt m$ are zero in exact arithmetic. By testing this numerically, you will not only reinforce the connection between a polynomial's degree and its representation in the Newton basis but also gain practical experience with the necessity of using numerical tolerances to handle floating-point inaccuracies [@problem_id:3164007].", "problem": "You are tasked with designing and implementing a numerical test that verifies a core structural property of Newtonâ€™s divided differences: for data sampled exactly from a polynomial of known degree, all divided differences of order strictly greater than that degree vanish in exact arithmetic. Your program must compute these divided differences from first principles and verify the vanishing property numerically, acknowledging floating-point rounding effects.\n\nStart from the fundamental definitions:\n- A polynomial of degree $m$ is any function $p(x)$ that can be written as $p(x) = \\sum_{k=0}^{m} a_k x^k$ for coefficients $a_0, a_1, \\dots, a_m$.\n- Given distinct nodes $x_0, x_1, \\dots, x_n$ and values $f(x_0), f(x_1), \\dots, f(x_n)$, the Newton divided differences are defined recursively by\n  $$ f[x_i] := f(x_i), $$\n  $$ f[x_i, x_{i+1}, \\dots, x_{i+k}] := \\frac{f[x_{i+1}, \\dots, x_{i+k}] - f[x_i, \\dots, x_{i+k-1}]}{x_{i+k} - x_i}, $$\n  for $k \\ge 1$ and $0 \\le i \\le n - k$.\n- In exact arithmetic, if $f$ is a polynomial of degree $m$, then for any order $r > m$, all $r$-th order divided differences $f[x_i, x_{i+1}, \\dots, x_{i+r}]$ are exactly zero.\n\nYour task is to:\n1. Implement a function to evaluate a polynomial $p(x)$ given its coefficients $[a_0, a_1, \\dots, a_m]$ in ascending degree order.\n2. Implement computation of the full Newton divided differences table for a given set of distinct nodes $[x_0, x_1, \\dots, x_{n-1}]$ and corresponding values $[f(x_0), f(x_1), \\dots, f(x_{n-1})]$, using only the fundamental recursive definition above.\n3. For a claimed polynomial degree $m$, verify that all divided differences of order strictly greater than $m$ are numerically negligible. To make this test robust to floating-point rounding, use an adaptive absolute tolerance\n   $$ \\tau = 10^{-10} \\cdot S, $$\n   where\n   $$ S = \\max\\left(1, \\max_{0 \\le i \\le n-1} |f(x_i)|, \\max_{0 \\le r \\le \\min(m, n-1)} \\max_{0 \\le i \\le n-1-r} |f[x_i, x_{i+1}, \\dots, x_{i+r}]| \\right). $$\n   Declare the test as passed if for every order $r$ with $r > m$ and every valid index $i$, the inequality $|f[x_i, \\dots, x_{i+r}]| \\le \\tau$ holds.\n\nTest Suite:\nProvide and use the following set of test cases. For each case, the polynomial coefficients are listed in ascending degree order $[a_0, a_1, \\dots, a_m]$, the known degree $m$ is given, and the nodes are specified. All nodes are distinct.\n\n- Case $1$ (happy path, quadratic):\n  - Polynomial coefficients: $[1, -2, 3]$ meaning $p(x) = 1 - 2x + 3x^2$.\n  - Degree: $m = 2$.\n  - Nodes: $[-2.0, -1.0, 0.5, 3.0]$.\n\n- Case $2$ (higher-degree, many nodes, nonuniform spacing):\n  - Polynomial coefficients: $[-4, 2, 0, -0.5]$ meaning $p(x) = -4 + 2x + 0x^2 - 0.5x^3$.\n  - Degree: $m = 3$.\n  - Nodes: $[-1.0, -0.5, 0.0, 0.1, 0.2, 0.5, 2.0]$.\n\n- Case $3$ (boundary case, constant polynomial):\n  - Polynomial coefficients: $[5]$ meaning $p(x) = 5$.\n  - Degree: $m = 0$.\n  - Nodes: $[-10.0, -5.0, 0.0, 4.0, 100.0]$.\n\n- Case $4$ (numerically challenging scale, quartic, small node spacing):\n  - Polynomial coefficients: $[7, 0, -300.0, 0, 1000000.0]$ meaning $p(x) = 7 - 300x^2 + 1000000x^4$.\n  - Degree: $m = 4$.\n  - Nodes: $[-0.01, -0.005, 0.0, 0.005, 0.01, 0.02]$.\n\n- Case $5$ (linear polynomial, symmetric nodes):\n  - Polynomial coefficients: $[0.25, -7.0]$ meaning $p(x) = 0.25 - 7x$.\n  - Degree: $m = 1$.\n  - Nodes: $[-3.0, -2.0, -1.0, 0.0, 1.0, 3.0]$.\n\nOutput Specification:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the above cases in order. Each result is a boolean indicating whether the verification passed for that case. For example, the output format must be exactly of the form `[True,False,True,...]` with no extra text printed.", "solution": "The problem requires the implementation of a numerical test to verify a fundamental property of Newton's divided differences for polynomials. Specifically, for a function $f(x)$ that is a polynomial of degree $m$, all divided differences of order $r > m$ must be zero in exact arithmetic. The test must account for floating-point inaccuracies by checking if these higher-order differences are numerically negligible, i.e., smaller in magnitude than an adaptive tolerance $\\tau$.\n\nThe solution is structured into three main components: a function to evaluate the polynomial, a function to compute the Newton divided differences table, and a main verification function that orchestrates the test.\n\nFirst, a robust method for evaluating the polynomial $p(x) = \\sum_{k=0}^{m} a_k x^k$ is necessary. Given the coefficients $[a_0, a_1, \\dots, a_m]$ in ascending order of degree, Horner's method is the preferred algorithm. It is computationally efficient, requiring only $m$ multiplications and $m$ additions, and is generally more numerically stable than naively computing and summing terms of the form $a_k x^k$. The method is based on rewriting the polynomial as $p(x) = a_0 + x(a_1 + x(a_2 + \\dots + x(a_{m-1} + a_m x)\\dots))$. This nested form is evaluated iteratively, typically by starting from the innermost term. For coefficients $[a_0, \\dots, a_m]$, the recurrence is $y \\leftarrow a_k + x \\cdot y$, iterating $k$ from $m-1$ down to $0$, with an initial value of $y = a_m$.\n\nSecond, the core of the problem is the computation of the Newton divided differences. Given $n$ distinct nodes $\\{x_0, x_1, \\dots, x_{n-1}\\}$ and their corresponding function values $\\{f(x_0), f(x_1), \\dots, f(x_{n-1})\\}$, the divided differences are defined by the recurrence relation:\n$$\nf[x_i, x_{i+1}, \\dots, x_{i+k}] := \\frac{f[x_{i+1}, \\dots, x_{i+k}] - f[x_i, \\dots, x_{i+k-1}]}{x_{i+k} - x_i}\n$$\nThe base case consists of the $0$-th order differences, which are simply the function values themselves: $f[x_i] = f(x_i)$.\n\nThis recursive structure lends itself to an iterative computation that fills a two-dimensional table. Let a table $D$ be structured such that $D_{i,k}$ stores the $k$-th order divided difference starting at node $x_i$, i.e., $D_{i,k} = f[x_i, \\dots, x_{i+k}]$. The first column ($k=0$) is initialized with the function values: $D_{i,0} = f(x_i)$. Subsequent columns for orders $k=1, 2, \\dots, n-1$ are computed using the values from the previous column ($k-1$):\n$$\nD_{i,k} = \\frac{D_{i+1, k-1} - D_{i, k-1}}{x_{i+k} - x_i}\n$$\nThis computation proceeds for $k$ from $1$ to $n-1$, and for each $k$, the index $i$ runs from $0$ to $n-1-k$.\n\nThird, the verification logic integrates these components. For a given polynomial with coefficients $[a_0, \\dots, a_m]$, claimed degree $m$, and a set of $n$ nodes $\\{x_j\\}$, the process is as follows:\n1.  Sample the polynomial: Evaluate $y_j = p(x_j)$ for all nodes $j=0, \\dots, n-1$ using Horner's method.\n2.  Compute the divided difference table: Use the nodes $\\{x_j\\}$ and computed values $\\{y_j\\}$ to generate the full $n \\times n$ table $D$ of divided differences.\n3.  Determine the adaptive tolerance $\\tau$: The tolerance must be scaled relative to the magnitude of the significant (non-zero) divided differences. The scaling factor $S$ is defined as:\n    $$\n    S = \\max\\left(1, \\max_{\\substack{0 \\le r \\le \\min(m, n-1) \\\\ 0 \\le i \\le n-1-r}} |f[x_i, \\dots, x_{i+r}]| \\right)\n    $$\n    This is calculated by finding the maximum absolute value among all entries in the divided difference table $D_{i,r}$ for orders $r$ from $0$ up to $\\min(m, n-1)$, and taking the maximum of that value and $1$. The tolerance is then $\\tau = 10^{-10} \\cdot S$. This adaptive approach prevents false positives/negatives due to the scale of the polynomial's values or its derivatives.\n4.  Perform the verification: The theoretical property states that for $r > m$, the divided differences $f[x_i, \\dots, x_{i+r}]$ should be zero. The numerical test checks if $|D_{i,r}| \\le \\tau$ for all orders $r$ from $m+1$ to $n-1$ and all valid indices $i$. If this inequality holds for all such differences, the test is passed for the given polynomial and nodes. If even one difference exceeds the tolerance, the test fails. If $m \\ge n-1$, there are no divided differences of order greater than $m$, so the test is vacuously true.\n\nThis complete procedure provides a principled and numerically robust method to test the specified property of Newton's divided differences.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef evaluate_poly(coeffs, x):\n    \"\"\"\n    Evaluates a polynomial at a given point x using Horner's method.\n\n    Args:\n        coeffs (list or np.ndarray): A list of coefficients [a_0, a_1, ..., a_m]\n                                      in ascending order of degree.\n        x (float): The point at which to evaluate the polynomial.\n\n    Returns:\n        float: The value of the polynomial p(x).\n    \"\"\"\n    result = 0.0\n    for coeff in reversed(coeffs):\n        result = coeff + x * result\n    return result\n\ndef compute_divided_differences(nodes, values):\n    \"\"\"\n    Computes the full Newton divided differences table.\n\n    Args:\n        nodes (np.ndarray): An array of distinct nodes x_0, ..., x_{n-1}.\n        values (np.ndarray): An array of function values f(x_0), ..., f(x_{n-1}).\n\n    Returns:\n        np.ndarray: A 2D array where table[i, k] is the k-th order\n                    divided difference f[x_i, ..., x_{i+k}].\n    \"\"\"\n    n = len(nodes)\n    dd_table = np.zeros((n, n))\n    dd_table[:, 0] = values\n\n    for k in range(1, n):  # k is the order of the difference\n        for i in range(n - k):  # i is the starting index\n            numerator = dd_table[i + 1, k - 1] - dd_table[i, k - 1]\n            denominator = nodes[i + k] - nodes[i]\n            if denominator == 0:\n                # This case should not be reached given the problem statement\n                # guarantees distinct nodes.\n                raise ValueError(\"Nodes must be distinct.\")\n            dd_table[i, k] = numerator / denominator\n            \n    return dd_table\n\ndef verify_vanishing_property(coeffs, m, nodes):\n    \"\"\"\n    Verifies that divided differences of order > m for a polynomial of\n    degree m are numerically negligible.\n\n    Args:\n        coeffs (list): Polynomial coefficients [a_0, ..., a_m].\n        m (int): The degree of the polynomial.\n        nodes (list): A list of distinct nodes for sampling.\n\n    Returns:\n        bool: True if the verification passes, False otherwise.\n    \"\"\"\n    nodes = np.array(nodes, dtype=float)\n    n = len(nodes)\n\n    # If there are not enough points to compute a difference of order > m,\n    # the condition is vacuously true. The loop range for verification will be empty.\n    # Ex: n=4 nodes, max order is 3. If m=3, test is for r > 3, which doesn't exist.\n\n    # 1. Sample the polynomial at the given nodes\n    values = np.array([evaluate_poly(coeffs, x) for x in nodes])\n\n    # 2. Compute the full divided difference table\n    dd_table = compute_divided_differences(nodes, values)\n\n    # 3. Determine the adaptive tolerance tau\n    # Calculate scale S\n    s_val = 1.0\n    # The max order to consider for S is min(m, n-1)\n    max_order_for_s = min(m, n - 1)\n    for r in range(max_order_for_s + 1):\n        num_diffs_in_order = n - r\n        max_abs_in_order = np.max(np.abs(dd_table[:num_diffs_in_order, r]))\n        s_val = max(s_val, max_abs_in_order)\n    \n    tau = 1e-10 * s_val\n\n    # 4. Perform the verification\n    # Check all divided differences of order r > m\n    for r in range(m + 1, n):\n        num_diffs_in_order = n - r\n        for i in range(num_diffs_in_order):\n            if abs(dd_table[i, r]) > tau:\n                return False\n\n    return True\n\ndef solve():\n    \"\"\"\n    Runs the verification test on a suite of predefined cases and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"coeffs\": [1, -2, 3],\n            \"m\": 2,\n            \"nodes\": [-2.0, -1.0, 0.5, 3.0],\n        },\n        {\n            \"coeffs\": [-4, 2, 0, -0.5],\n            \"m\": 3,\n            \"nodes\": [-1.0, -0.5, 0.0, 0.1, 0.2, 0.5, 2.0],\n        },\n        {\n            \"coeffs\": [5],\n            \"m\": 0,\n            \"nodes\": [-10.0, -5.0, 0.0, 4.0, 100.0],\n        },\n        {\n            \"coeffs\": [7, 0, -300.0, 0, 1000000.0],\n            \"m\": 4,\n            \"nodes\": [-0.01, -0.005, 0.0, 0.005, 0.01, 0.02],\n        },\n        {\n            \"coeffs\": [0.25, -7.0],\n            \"m\": 1,\n            \"nodes\": [-3.0, -2.0, -1.0, 0.0, 1.0, 3.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = verify_vanishing_property(case[\"coeffs\"], case[\"m\"], case[\"nodes\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3164007"}, {"introduction": "Polynomial interpolation works best for smooth functions, but what happens when a function has a \"kink\" or sharp corner? This practice moves beyond ideal polynomial data to investigate how divided differences behave for a non-smooth function, $f(x)=|x|$. By observing the magnitude of high-order coefficients, you will see how divided differences act as a diagnostic tool, effectively \"detecting\" and quantifying the non-smooth behavior of the underlying function [@problem_id:3164020].", "problem": "You are given the task of investigating how the highest-order Newton coefficient (also known as the highest-order divided difference) behaves when the interpolated function has a non-smooth point. Consider the absolute value function $f(x)=|x|$, which has a non-differentiable kink at $x=0$. The unique polynomial $P_{k}$ of degree at most $k$ that interpolates a function $f$ at distinct nodes $x_{0},x_{1},\\ldots,x_{k}$ admits a Newton basis representation whose highest-order coefficient is, by definition, the $k$-th order divided difference $[x_{0},x_{1},\\ldots,x_{k}]f$. Starting from the fundamental facts that (i) a unique interpolating polynomial exists for distinct nodes and (ii) the Newton basis expansion exists for every set of distinct nodes, investigate the magnitude of the highest-order Newton coefficient for $f(x)=|x|$ in various node configurations to assess how non-smoothness magnifies high-order coefficients.\n\nProgram requirements:\n- Implement a procedure that, given distinct nodes $x_{0},x_{1},\\ldots,x_{k}$ and a function $f$, computes the $k$-th order divided difference $[x_{0},x_{1},\\ldots,x_{k}]f$ by correctly extracting the highest-order coefficient from the Newton form of the interpolating polynomial. The computation must be consistent with the standard definition of divided differences.\n- Apply your implementation to the function $f(x)=|x|$ for each test case listed below.\n- For each test case, your program must compute and return a single real number equal to the $k$-th order divided difference $[x_{0},x_{1},\\ldots,x_{k}]f$ for the provided nodes and $f(x)=|x|$. No other quantities should be returned.\n\nTest suite (each case specifies nodes; here $k=\\text{number of nodes}-1$):\n1. Nodes $[-2,-1,0,1,2]$ (that is, $x_{0}=-2$, $x_{1}=-1$, $x_{2}=0$, $x_{3}=1$, $x_{4}=2$; thus $k=4$).\n2. Nodes $[-2,-1,-0.5,-0.25]$ (that is, $x_{0}=-2$, $x_{1}=-1$, $x_{2}=-0.5$, $x_{3}=-0.25$; thus $k=3$).\n3. Nodes $[0.25,0.5,1.0,2.0]$ (that is, $x_{0}=0.25$, $x_{1}=0.5$, $x_{2}=1.0$, $x_{3}=2.0$; thus $k=3$).\n4. Nodes $[-10^{-3},0,10^{-3}]$ (that is, $x_{0}=-10^{-3}$, $x_{1}=0$, $x_{2}=10^{-3}$; thus $k=2$).\n5. Nodes $[-10^{-3},10^{-3},2\\times 10^{-3}]$ (that is, $x_{0}=-10^{-3}$, $x_{1}=10^{-3}$, $x_{2}=2\\times 10^{-3}$; thus $k=2$).\n6. Nodes $[-3,-0.1,0.2,0.9]$ (that is, $x_{0}=-3$, $x_{1}=-0.1$, $x_{2}=0.2$, $x_{3}=0.9$; thus $k=3$).\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above. For example, an output with three results should look like `[result_1,result_2,result_3]`.\n- Each result must be a real number (a floating-point number). No units are involved in this problem.\n\nDesign intent and coverage:\n- The test suite includes a symmetric set containing the kink ($[-2,-1,0,1,2]$), two smooth-side sets entirely on one side of the kink ($[-2,-1,-0.5,-0.25]$ and $[0.25,0.5,1.0,2.0]$), two small-spacing edge cases near the kink that illustrate magnification ($[-10^{-3},0,10^{-3}]$ and $[-10^{-3},10^{-3},2\\times 10^{-3}]$), and a general irregular set crossing the kink ($[-3,-0.1,0.2,0.9]$). The answers are real numbers that quantify the highest-order Newton coefficients for $f(x)=|x|$ in each case.", "solution": "The problem is valid as it is scientifically grounded in the principles of numerical analysis, specifically polynomial interpolation and Newton's divided differences. It is well-posed, objective, and provides all necessary data for a unique solution to be computed for each test case. The function $f(x)=|x|$ serves as a standard and illustrative example of how interpolating polynomials behave for non-smooth functions.\n\nThe objective is to compute the highest-order divided difference, $[x_{0}, x_{1}, \\ldots, x_{k}]f$, for the function $f(x)=|x|$ given several sets of distinct nodes. This quantity is precisely the leading coefficient of the interpolating polynomial in its Newton form.\n\nLet $f(x)$ be a function and let $x_{0}, x_{1}, \\ldots, x_{k}$ be $k+1$ distinct points, called nodes. There exists a unique polynomial $P_k(x)$ of degree at most $k$ such that $P_k(x_i) = f(x_i)$ for all $i \\in \\{0, 1, \\ldots, k\\}$. This polynomial can be expressed in the Newton form:\n$$\nP_k(x) = c_0 + c_1(x-x_0) + c_2(x-x_0)(x-x_1) + \\cdots + c_k(x-x_0)(x-x_1)\\cdots(x-x_{k-1})\n$$\nThe coefficients $c_j$ are the divided differences, defined as $c_j = [x_0, x_1, \\ldots, x_j]f$. The problem asks for the computation of the highest-order coefficient, $c_k = [x_0, x_1, \\ldots, x_k]f$.\n\nDivided differences are defined by the following recursive formula:\nThe zeroth-order divided difference is the function value itself:\n$$\n[x_i]f = f(x_i)\n$$\nFor orders $j > 0$, the divided difference is defined recursively as:\n$$\n[x_i, x_{i+1}, \\ldots, x_{i+j}]f = \\frac{[x_{i+1}, \\ldots, x_{i+j}]f - [x_i, \\ldots, x_{i+j-1}]f}{x_{i+j} - x_i}\n$$\nThis recursive definition forms the basis of the computational algorithm. We can construct a divided difference table, but for the purpose of finding only the highest-order coefficient, a more space-efficient algorithm can be used. We can use a single one-dimensional array, say `c`, of size $k+1$, which is updated iteratively.\n\nThe algorithm proceeds as follows:\n1.  Initialize an array `c` of length $k+1$ with the function values at the nodes: $c_i = f(x_i)$ for $i=0, 1, \\ldots, k$.\n2.  Iterate for $j$ from $1$ to $k$. This corresponds to computing the $j$-th order divided differences.\n3.  In each iteration $j$, iterate for $i$ from $k$ down to $j$. This reverse loop order is crucial for correctly updating the array `c` in-place.\n4.  Update the entry $c_i$ using the recursive formula. At step $(j,i)$, the value $c_i$ holds the $(j-1)$-th order difference $[x_{i-j+1}, \\ldots, x_i]f$ and $c_{i-1}$ holds $[x_{i-j}, \\ldots, x_{i-1}]f$. The update is:\n    $$\n    c_i \\leftarrow \\frac{c_i - c_{i-1}}{x_i - x_{i-j}}\n    $$\n5.  After the loops complete (i.e., after the iteration for $j=k$), the last element of the array, $c_k$, will hold the desired highest-order divided difference $[x_0, x_1, \\ldots, x_k]f$.\n\nA key theoretical result connects divided differences to derivatives. If $f$ is $n$ times continuously differentiable on an interval containing the nodes $x_0, \\ldots, x_n$, then there exists a point $\\xi$ in the smallest interval containing the nodes such that:\n$$\n[x_0, \\ldots, x_n]f = \\frac{f^{(n)}(\\xi)}{n!}\n$$\nThe function in this problem is $f(x)=|x|$. This function is smooth everywhere except for a \"kink\", a non-differentiable point, at $x=0$.\n- For any set of nodes where all $x_i > 0$ or all $x_i < 0$, the function is equivalent to a linear polynomial ($f(x)=x$ or $f(x)=-x$, respectively). For such a function, $f''(x) = 0$ and all higher derivatives are also zero. Therefore, for $k \\ge 2$, the $k$-th order divided difference must be $0$. This applies to test cases 2 and 3.\n- When the set of nodes includes $x=0$ or straddles it, the function is not smooth over the interval containing the nodes. The divided difference formula still applies, but we can no longer relate it to a high-order derivative. Instead, the divided difference quantifies the \"polynomial-ness\" of the function over the given nodes. The non-smoothness at $x=0$ is expected to result in non-zero, and potentially large, high-order divided differences, reflecting the singularity introduced by the absolute value function. The test cases are designed to probe this behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_highest_order_dd(nodes):\n    \"\"\"\n    Computes the highest-order Newton divided difference for f(x)=|x|.\n\n    Args:\n        nodes (list or tuple of float): A list of distinct nodes x_0, x_1, ..., x_k.\n\n    Returns:\n        float: The k-th order divided difference [x_0, ..., x_k]f.\n    \"\"\"\n    x = np.array(nodes, dtype=float)\n    y = np.abs(x)\n    k = len(x) - 1\n\n    if k < 0:\n        # This case won't be triggered by the problem's test suite.\n        # A single node has a 0-th order difference, y[0]. \n        # For simplicity, we can handle it, though the loop structure naturally does.\n        return y[0] if k == -1 else 0.0\n\n    # The array 'coeffs' will be updated in-place.\n    # Initially, it holds the 0-th order differences (the function values).\n    coeffs = y.copy()\n\n    # Iterate from j=1 (1st order diff) to j=k (k-th order diff).\n    for j in range(1, k + 1):\n        # The inner loop computes the j-th order differences.\n        # It must run in reverse to use the (j-1)-th order differences\n        # from the previous 'j' iteration before they are overwritten.\n        for i in range(k, j - 1, -1):\n            numerator = coeffs[i] - coeffs[i-1]\n            denominator = x[i] - x[i-j]\n            coeffs[i] = numerator / denominator\n\n    # The highest-order coefficient is the last element.\n    return coeffs[k]\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the highest-order divided difference\n    for f(x)=|x| for each of the provided test cases.\n    \"\"\"\n    test_cases = [\n        # 1. Symmetric set containing the kink\n        [-2.0, -1.0, 0.0, 1.0, 2.0],\n        # 2. Smooth-side set on the negative side\n        [-2.0, -1.0, -0.5, -0.25],\n        # 3. Smooth-side set on the positive side\n        [0.25, 0.5, 1.0, 2.0],\n        # 4. Small-spacing set symmetric about the kink\n        [-1e-3, 0.0, 1e-3],\n        # 5. Small-spacing asymmetric set near the kink\n        [-1e-3, 1e-3, 2e-3],\n        # 6. General irregular set crossing the kink\n        [-3.0, -0.1, 0.2, 0.9],\n    ]\n\n    results = []\n    for nodes in test_cases:\n        result = compute_highest_order_dd(nodes)\n        results.append(result)\n\n    # Format the final output string as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3164020"}]}