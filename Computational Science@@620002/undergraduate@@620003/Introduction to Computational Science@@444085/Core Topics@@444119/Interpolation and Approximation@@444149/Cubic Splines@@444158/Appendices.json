{"hands_on_practices": [{"introduction": "To begin, it is essential to build an intuition for why cubic splines are so useful. This first exercise [@problem_id:2164998] provides a direct comparison between a simple piecewise linear interpolation and a natural cubic spline. By calculating the interpolated value for the same set of points using both methods, you will gain a concrete understanding of how a spline creates a smoother, more physically realistic curve than simply connecting the dots with straight lines.", "problem": "An engineer is modeling the shape of a thin, flexible rod that is constrained to pass through three points in a 2D Cartesian plane: $P_0=(-1, 1)$, $P_1=(0, 0)$, and $P_2=(1, 1)$. Two simple models are proposed to estimate the rod's vertical position, $y$, at other horizontal locations, $x$.\n\nModel A is a piecewise linear interpolant, which connects the specified points with straight line segments.\nModel B is a natural cubic spline, which ensures the curve is smooth by matching first and second derivatives at the interior points, and has zero second derivatives at the endpoints.\n\nCalculate the vertical position of the rod at $x=0.5$ as predicted by both Model A and Model B. Let these values be $y_A$ and $y_B$, respectively. Present your answer as a pair of exact fractions $(y_A, y_B)$.", "solution": "We label the nodes as $x_{0}=-1$, $x_{1}=0$, $x_{2}=1$ with corresponding values $y_{0}=1$, $y_{1}=0$, $y_{2}=1$.\n\nModel A (piecewise linear interpolant): For $x \\in [x_{1},x_{2}]$, the line through $(0,0)$ and $(1,1)$ has slope\n$$\nm=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\\frac{1-0}{1-0}=1,\n$$\nso the interpolant is\n$$\ny(x)=y_{1}+m(x-x_{1})=0+1\\cdot(x-0)=x.\n$$\nEvaluating at $x=\\frac{1}{2}$ gives\n$$\ny_{A}=y\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{2}.\n$$\n\nModel B (natural cubic spline): Let $M_{i}=S''(x_{i})$. Natural end conditions give $M_{0}=0$ and $M_{2}=0$. With $h_{0}=x_{1}-x_{0}=1$ and $h_{1}=x_{2}-x_{1}=1$, the cubic spline system at the interior node $i=1$ is\n$$\nh_{0}M_{0}+2(h_{0}+h_{1})M_{1}+h_{1}M_{2}=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\nSubstituting the values,\n$$\n1\\cdot 0+2(1+1)M_{1}+1\\cdot 0=6\\left(\\frac{1-0}{1}-\\frac{0-1}{1}\\right)=6(1-(-1))=12,\n$$\nso\n$$\n4M_{1}=12 \\quad \\Rightarrow \\quad M_{1}=3.\n$$\nOn the interval $[x_{1},x_{2}]=[0,1]$, the spline is\n$$\nS(x)=\\frac{M_{1}}{6h_{1}}(x_{2}-x)^{3}+\\frac{M_{2}}{6h_{1}}(x-x_{1})^{3}+\\left(y_{1}-\\frac{M_{1}h_{1}^{2}}{6}\\right)\\frac{x_{2}-x}{h_{1}}+\\left(y_{2}-\\frac{M_{2}h_{1}^{2}}{6}\\right)\\frac{x-x_{1}}{h_{1}}.\n$$\nWith $h_{1}=1$, $M_{1}=3$, $M_{2}=0$, $y_{1}=0$, and $y_{2}=1$, this simplifies to\n$$\nS(x)=\\frac{3}{6}(1-x)^{3}+0+\\left(0-\\frac{3}{6}\\right)(1-x)+\\left(1-0\\right)x\n=\\frac{1}{2}(1-x)^{3}-\\frac{1}{2}(1-x)+x.\n$$\nExpanding and combining like terms,\n$$\nS(x)=\\frac{1}{2}-\\frac{3}{2}x+\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}-\\frac{1}{2}+\\frac{1}{2}x+x\n=-\\frac{1}{2}x^{3}+\\frac{3}{2}x^{2}.\n$$\nEvaluating at $x=\\frac{1}{2}$ gives\n$$\ny_{B}=S\\!\\left(\\frac{1}{2}\\right)=-\\frac{1}{2}\\left(\\frac{1}{2}\\right)^{3}+\\frac{3}{2}\\left(\\frac{1}{2}\\right)^{2}\n=-\\frac{1}{2}\\cdot\\frac{1}{8}+\\frac{3}{2}\\cdot\\frac{1}{4}\n=-\\frac{1}{16}+\\frac{3}{8}\n=\\frac{5}{16}.\n$$\n\nThus, the required pair is $\\left(\\frac{1}{2},\\frac{5}{16}\\right)$.", "answer": "$$\\boxed{\\left(\\frac{1}{2}, \\frac{5}{16}\\right)}$$", "id": "2164998"}, {"introduction": "Having seen the result of a spline interpolation, we now delve deeper into its internal mechanics. This exercise [@problem_id:2164965] presents a \"reverse\" problem: instead of calculating the spline from a full set of data, you will use a known property of the spline's curvature—its second derivative at a point—to determine a missing data value. This practice reinforces the fundamental equations that govern the spline's shape and solidifies your understanding of the relationship between the data points and the spline's second derivatives, denoted as $M_i$.", "problem": "A natural cubic spline, denoted by $S(x)$, is used to interpolate a set of three data points: $(x_0, y_0) = (0, 0)$, $(x_1, y_1) = (1, y_1)$, and $(x_2, y_2) = (2, 0)$. The value of the ordinate $y_1$ is unknown. A cubic spline is a function that is piecewise-cubic and twice continuously differentiable. For a natural cubic spline, the second derivative at the endpoints is zero.\n\nIt is independently determined that the second derivative of this spline at the interior point $x_1=1$ is exactly $S''(1) = 6$. Using this information, determine the value of $y_1$.", "solution": "Let $x_{0}=0$, $x_{1}=1$, $x_{2}=2$ with $y_{0}=0$, $y_{1}$ unknown, and $y_{2}=0$. Denote $M_{i}=S''(x_{i})$. For a natural cubic spline, $M_{0}=0$ and $M_{2}=0$, and it is given that $M_{1}=6$.\n\nFor a cubic spline, the second derivatives at the knots satisfy the standard tridiagonal relation (obtained by enforcing $S'(x)$ continuity at interior knots):\n$$\nh_{0} M_{0} + 2\\left(h_{0}+h_{1}\\right) M_{1} + h_{1} M_{2}\n= 6\\left(\\frac{y_{2}-y_{1}}{h_{1}} - \\frac{y_{1}-y_{0}}{h_{0}}\\right),\n$$\nwhere $h_{i}=x_{i+1}-x_{i}$. Here $h_{0}=x_{1}-x_{0}=1$ and $h_{1}=x_{2}-x_{1}=1$, so the equation becomes\n$$\nM_{0} + 4 M_{1} + M_{2} = 6\\left((y_{2}-y_{1}) - (y_{1}-y_{0})\\right) = 6(y_{2} - 2 y_{1} + y_{0}).\n$$\nSubstituting $M_{0}=0$, $M_{1}=6$, $M_{2}=0$, $y_{0}=0$, and $y_{2}=0$, we obtain\n$$\n0 + 4\\cdot 6 + 0 = 6(0 - 2 y_{1} + 0),\n$$\nhence\n$$\n24 = -12 y_{1} \\quad \\Longrightarrow \\quad y_{1} = -2.\n$$", "answer": "$$\\boxed{-2}$$", "id": "2164965"}, {"introduction": "While natural splines provide smooth interpolations, their behavior at the endpoints, where the second derivative is forced to zero, can sometimes lead to unwanted oscillations, especially when dealing with rapidly changing data. This advanced computational exercise [@problem_id:3220873] challenges you to explore this phenomenon by comparing a natural spline with a \"clamped\" spline, where the endpoint slopes are specified. By implementing both and quantifying the \"overshoot,\" you will learn how boundary conditions can be used to control spline behavior and produce more stable and predictable interpolations.", "problem": "You are asked to implement from first principles the construction and evaluation of cubic spline interpolants with two distinct endpoint boundary conditions: the natural boundary condition and the clamped boundary condition. A cubic spline is defined as a function composed of piecewise cubic polynomials on consecutive subintervals that interpolate given data points and is twice continuously differentiable across the entire domain. The natural boundary condition sets the second derivative at the endpoints to zero, while the clamped boundary condition specifies the first derivative at the endpoints. Your task is to:\n- Derive an algorithmic formulation to compute a unique cubic spline interpolant for strictly increasing abscissae $\\{x_i\\}_{i=0}^{n-1}$ and ordinates $\\{y_i\\}_{i=0}^{n-1}$, under either the natural or the clamped boundary condition. The derivation must begin from the defining properties: cubic-by-interval, interpolation constraints, and continuity up to the second derivative at the internal knots.\n- Implement both boundary condition choices. For the clamped boundary condition, use endpoint derivatives given by the one-sided secant slopes,\n$$\ns_0 \\equiv \\frac{y_1 - y_0}{x_1 - x_0}, \\quad s_{n-1} \\equiv \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}}.\n$$\n\nTo quantify counter-intuitive oscillation, define the overshoot magnitude on one subinterval $[x_i,x_{i+1}]$ as follows. Let $m_i = \\min\\{y_i,y_{i+1}\\}$ and $M_i = \\max\\{y_i,y_{i+1}\\}$. Let $S(x)$ denote the spline value. The overshoot magnitude on $[x_i,x_{i+1}]$ is\n$$\n\\Delta_i \\equiv \\max\\Big\\{ \\max_{x \\in [x_i,x_{i+1}]} \\big(S(x) - M_i\\big), \\ \\max_{x \\in [x_i,x_{i+1}]}\\big(m_i - S(x)\\big), \\ 0 \\Big\\}.\n$$\nThe global overshoot is $\\Delta \\equiv \\max_i \\Delta_i$. Numerically approximate the subinterval maxima by evaluating $S(x)$ on a uniform grid of $1001$ points on each $[x_i,x_{i+1}]$.\n\nImplement a single program that:\n- Constructs both the natural spline and the clamped spline (with the above $s_0$ and $s_{n-1}$) for each dataset in the test suite.\n- Evaluates and reports the global overshoot $\\Delta$ for each spline.\n\nYour implementation must be fully self-contained and must not call external libraries beyond the specified ones. All computations are in pure mathematics (no physical units).\n\nTest suite. Use the following datasets, each given as lists $x$ and $y$ of equal length with strictly increasing $x$:\n\n- Case A (left-end steepening that induces a large natural-spline oscillation near the left endpoint):\n  - $x = [\\,0.0,\\,0.5,\\,0.6,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,10.0,\\,12.0\\,]$\n\n- Case B (near-linear, happy-path):\n  - $x = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n  - $y = [\\,0.0,\\,1.0,\\,2.0,\\,3.0\\,]$\n\n- Case C (right-end steepening that induces a natural-spline oscillation near the right endpoint):\n  - $x = [\\,0.0,\\,1.4,\\,1.5,\\,2.0\\,]$\n  - $y = [\\,0.0,\\,2.0,\\,3.0,\\,3.2\\,]$\n\nFor each case, compute and return the pair of overshoot magnitudes $\\Delta_{\\text{natural}}$ and $\\Delta_{\\text{clamped}}$ as floating-point numbers. Your program should produce a single line of output containing all results concatenated in order as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\,\\Delta_{\\text{natural}}^{(A)},\\,\\Delta_{\\text{clamped}}^{(A)},\\,\\Delta_{\\text{natural}}^{(B)},\\,\\Delta_{\\text{clamped}}^{(B)},\\,\\Delta_{\\text{natural}}^{(C)},\\,\\Delta_{\\text{clamped}}^{(C)}\\,].\n$$", "solution": "The user requires a derivation and implementation of cubic spline interpolation for both natural and clamped boundary conditions. The derivation must proceed from first principles, and the implementation must compute the global overshoot for several test cases.\n\n### Derivation of the Cubic Spline Interpolant\n\nA cubic spline $S(x)$ interpolating a set of $n$ data points $(x_i, y_i)$ for $i=0, 1, \\ldots, n-1$ with strictly increasing abscissae $x_0 < x_1 < \\ldots < x_{n-1}$ is a piecewise function defined on $[x_0, x_{n-1}]$. For each subinterval $[x_i, x_{i+1}]$, the spline segment $S_i(x)$ is a cubic polynomial. The entire spline $S(x)$ must satisfy the following properties:\n1.  **Interpolation**: $S(x_i) = y_i$ for all $i=0, \\ldots, n-1$.\n2.  **Continuity**: $S(x)$ is twice continuously differentiable on $[x_0, x_{n-1}]$, i.e., $S \\in C^2[x_0, x_{n-1}]$. This implies that at each interior knot $x_i$ ($i=1, \\ldots, n-2$), $S_{i-1}(x_i) = S_i(x_i)$, $S'_{i-1}(x_i) = S'_i(x_i)$, and $S''_{i-1}(x_i) = S''_i(x_i)$.\n\nLet us define the second derivatives of the spline at the knots as $M_i = S''(x_i)$ for $i=0, \\ldots, n-1$. Since each segment $S_i(x)$ is a cubic polynomial, its second derivative $S_i''(x)$ is a linear function. On the interval $[x_i, x_{i+1}]$, $S_i''(x)$ passes through the points $(x_i, M_i)$ and $(x_{i+1}, M_{i+1})$. Let $h_i = x_{i+1} - x_i$. The linear function $S_i''(x)$ can be written using Lagrange's linear interpolation formula:\n$$\nS_i''(x) = M_i \\frac{x_{i+1} - x}{h_i} + M_{i+1} \\frac{x - x_i}{h_i}\n$$\nIntegrating $S_i''(x)$ twice with respect to $x$ gives the general form of the cubic polynomial $S_i(x)$:\n$$\nS_i(x) = M_i \\frac{(x_{i+1} - x)^3}{6h_i} + M_{i+1} \\frac{(x - x_i)^3}{6h_i} + C(x-x_i) + D(x_{i+1}-x)\n$$\nwhere $C$ and $D$ are constants of integration, expressed in a form convenient for applying the interpolation conditions.\nWe enforce the interpolation conditions $S_i(x_i) = y_i$ and $S_i(x_{i+1}) = y_{i+1}$:\nAt $x=x_i$: $y_i = M_i \\frac{h_i^3}{6h_i} + D h_i \\implies D = \\frac{y_i}{h_i} - \\frac{M_i h_i}{6}$.\nAt $x=x_{i+1}$: $y_{i+1} = M_{i+1} \\frac{h_i^3}{6h_i} + C h_i \\implies C = \\frac{y_{i+1}}{h_i} - \\frac{M_{i+1} h_i}{6}$.\n\nSubstituting these constants back, we obtain the expression for the spline segment $S_i(x)$ in terms of the known data points and the unknown second derivatives $M_i$:\n$$\nS_i(x) = \\frac{M_i}{6h_i}(x_{i+1}-x)^3 + \\frac{M_{i+1}}{6h_i}(x-x_i)^3 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right)(x-x_i) + \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)(x_{i+1}-x)\n$$\nThis equation defines the spline on each subinterval $[x_i, x_{i+1}]$ for $i=0, \\ldots, n-2$. To find the unknown values $M_i$, we use the continuity condition for the first derivative, $S'_{i-1}(x_i) = S'_i(x_i)$, at the interior knots $x_i$ for $i=1, \\ldots, n-2$.\n\nFirst, we find the derivative $S'_i(x)$:\n$$\nS'_i(x) = -\\frac{M_i}{2h_i}(x_{i+1}-x)^2 + \\frac{M_{i+1}}{2h_i}(x-x_i)^2 + \\left(\\frac{y_{i+1}}{h_i} - \\frac{M_{i+1}h_i}{6}\\right) - \\left(\\frac{y_i}{h_i} - \\frac{M_i h_i}{6}\\right)\n$$\nEvaluating the derivatives at the knots:\n$S'_i(x_i) = -\\frac{M_i h_i}{2} + \\frac{y_{i+1}-y_i}{h_i} - \\frac{M_{i+1}h_i}{6} + \\frac{M_i h_i}{6} = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}$.\n$S'_{i-1}(x_i) = \\frac{M_{i-1}h_{i-1}}{6} + \\frac{M_i h_{i-1}}{3} + \\frac{y_i-y_{i-1}}{h_{i-1}}$.\n\nEquating $S'_{i-1}(x_i) = S'_i(x_i)$ for $i=1, \\ldots, n-2$:\n$$\n\\frac{y_i-y_{i-1}}{h_{i-1}} + \\frac{h_{i-1}}{6}M_{i-1} + \\frac{h_{i-1}}{3}M_i = \\frac{y_{i+1}-y_i}{h_i} - \\frac{h_i}{3}M_i - \\frac{h_i}{6}M_{i+1}\n$$\nRearranging the terms to group the unknowns $M_{i-1}$, $M_i$, and $M_{i+1}$:\n$$\nh_{i-1}M_{i-1} + (2h_{i-1} + 2h_i)M_i + h_iM_{i+1} = 6\\left(\\frac{y_{i+1}-y_i}{h_i} - \\frac{y_i-y_{i-1}}{h_{i-1}}\\right)\n$$\nThis fundamental relation provides a system of $n-2$ linear equations for the $n$ unknowns $M_0, \\ldots, M_{n-1}$. To obtain a unique solution, we need two additional equations, which are provided by the boundary conditions.\n\n### Boundary Conditions\n\n**1. Natural Spline:**\nThe natural boundary condition specifies zero curvature at the endpoints: $S''(x_0)=0$ and $S''(x_{n-1})=0$. This directly translates to:\n$$\nM_0 = 0, \\quad M_{n-1} = 0\n$$\nSubstituting these into the general system leaves $n-2$ equations for the $n-2$ unknowns $M_1, \\ldots, M_{n-2}$. The system forms a strictly diagonally dominant tridiagonal matrix, guaranteeing a unique solution.\n\n**2. Clamped Spline:**\nThe clamped boundary condition specifies the first derivatives at the endpoints: $S'(x_0)=s_0$ and $S'(x_{n-1})=s_{n-1}$.\nUsing our expression for $S'_i(x_i)$, we set $i=0$:\n$S'(x_0) = S'_0(x_0) = \\frac{y_1-y_0}{h_0} - \\frac{h_0}{3}M_0 - \\frac{h_0}{6}M_1 = s_0$.\nRearranging gives the first boundary equation:\n$$\n2h_0M_0 + h_0M_1 = 6\\left(\\frac{y_1-y_0}{h_0} - s_0\\right)\n$$\nFor the condition at $x_{n-1}$, we evaluate $S'_{n-2}(x_{n-1})=s_{n-1}$:\n$S'_{n-2}(x_{n-1}) = \\frac{y_{n-1}-y_{n-2}}{h_{n-2}} + \\frac{h_{n-2}}{6}M_{n-2} + \\frac{h_{n-2}}{3}M_{n-1} = s_{n-1}$.\nRearranging gives the second boundary equation:\n$$\nh_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 6\\left(s_{n-1} - \\frac{y_{n-1}-y_{n-2}}{h_{n-2}}\\right)\n$$\nThe problem specifies particular values for $s_0$ and $s_{n-1}$:\n$s_0 = \\frac{y_1 - y_0}{x_1 - x_0} = \\frac{y_1 - y_0}{h_0}$\n$s_{n-1} = \\frac{y_{n-1} - y_{n-2}}{x_{n-1} - x_{n-2}} = \\frac{y_{n-1} - y_{n-2}}{h_{n-2}}$\nWith these choices, the right-hand sides of both boundary equations become zero:\n$2h_0M_0 + h_0M_1 = 0 \\implies 2M_0 + M_1 = 0$.\n$h_{n-2}M_{n-2} + 2h_{n-2}M_{n-1} = 0 \\implies M_{n-2} + 2M_{n-1} = 0$.\nThese two equations, combined with the $n-2$ interior equations, form a full $n \\times n$ tridiagonal system for the unknowns $M_0, \\ldots, M_{n-1}$. This system is also strictly diagonally dominant and has a unique solution.\n\n### Overshoot Calculation\n\nThe overshoot magnitude on a subinterval $[x_i, x_{i+1}]$ is defined as:\n$$\n\\Delta_i = \\max\\left\\{ \\max_{x \\in [x_i,x_{i+1}]} \\left(S(x) - \\max\\{y_i,y_{i+1}\\}\\right), \\ \\max_{x \\in [x_i,x_{i+1}]}\\left(\\min\\{y_i,y_{i+1}\\} - S(x)\\right), \\ 0 \\right\\}\n$$\nThe global overshoot is the maximum over all subintervals, $\\Delta = \\max_i \\Delta_i$. Computationally, the maxima on each subinterval are approximated by evaluating the spline $S(x)$ on a fine uniform grid of $1001$ points spanning $[x_i, x_{i+1}]$. This procedure quantifies the extent to which the spline oscillates beyond the range of the data points it interpolates.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tdma(lower, main, upper, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax=d using the Thomas algorithm.\n\n    Args:\n        lower (np.ndarray): The lower diagonal of A (length n-1).\n        main (np.ndarray): The main diagonal of A (length n).\n        upper (np.ndarray): The upper diagonal of A (length n-1).\n        d (np.ndarray): The right-hand side vector (length n).\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(main)\n    c_p = np.zeros(n)\n    d_p = np.zeros(n)\n\n    # Forward elimination\n    c_p[0] = upper[0] / main[0]\n    d_p[0] = d[0] / main[0]\n    for i in range(1, n):\n        denom = main[i] - lower[i-1] * c_p[i-1]\n        if i < n - 1:\n            c_p[i] = upper[i] / denom\n        d_p[i] = (d[i] - lower[i-1] * d_p[i-1]) / denom\n\n    # Backward substitution\n    x = np.zeros(n)\n    x[n-1] = d_p[n-1]\n    for i in range(n-2, -1, -1):\n        x[i] = d_p[i] - c_p[i] * x[i+1]\n    return x\n\nclass CubicSpline:\n    \"\"\"\n    A class for computing and evaluating cubic spline interpolants.\n    \"\"\"\n    def __init__(self, x, y, bc_type='natural'):\n        self.x = np.asarray(x, dtype=float)\n        self.y = np.asarray(y, dtype=float)\n        self.n = len(x)\n        \n        if self.n < 2:\n            raise ValueError(\"Need at least 2 points for interpolation.\")\n        \n        self.h = self.x[1:] - self.x[:-1]\n        \n        if np.any(self.h <= 0):\n            raise ValueError(\"x coordinates must be strictly increasing.\")\n\n        if bc_type == 'natural':\n            self._compute_natural_spline()\n        elif bc_type == 'clamped':\n            self._compute_clamped_spline()\n        else:\n            raise ValueError(f\"Unsupported boundary condition type: {bc_type}\")\n\n    def _compute_natural_spline(self):\n        \"\"\"Computes the second derivatives M for a natural spline.\"\"\"\n        if self.n <= 2:\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n - 2  # Size of the internal system\n        \n        A_lower = self.h[1:-1]\n        A_main = 2 * (self.h[:-1] + self.h[1:])\n        A_upper = self.h[1:-1]\n\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        b_rhs = 6 * (delta[1:] - delta[:-1])\n\n        M_internal = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n        \n        self.M = np.zeros(self.n)\n        self.M[1:-1] = M_internal\n\n    def _compute_clamped_spline(self):\n        \"\"\"Computes the second derivatives M for a clamped spline with specified derivatives.\"\"\"\n        if self.n <= 2:\n            # Linear interpolation for 2 points, second derivatives are zero\n            self.M = np.zeros(self.n)\n            return\n\n        N = self.n\n        A_lower = np.zeros(N - 1)\n        A_main = np.zeros(N)\n        A_upper = np.zeros(N - 1)\n        b_rhs = np.zeros(N)\n\n        # First row from boundary condition: 2*M_0 + M_1 = 0\n        A_main[0] = 2.0\n        A_upper[0] = 1.0\n        b_rhs[0] = 0.0\n\n        # Internal rows\n        delta = (self.y[1:] - self.y[:-1]) / self.h\n        internal_rhs = 6 * (delta[1:] - delta[:-1])\n        b_rhs[1:-1] = internal_rhs\n\n        A_main[1:-1] = 2 * (self.h[:-1] + self.h[1:])\n        A_lower[:-1] = self.h[:-1]\n        A_upper[1:] = self.h[1:]\n\n        # Last row from boundary condition: M_{n-2} + 2*M_{n-1} = 0\n        A_lower[-1] = 1.0\n        A_main[-1] = 2.0\n        b_rhs[-1] = 0.0\n        \n        self.M = solve_tdma(A_lower, A_main, A_upper, b_rhs)\n\n    def evaluate(self, x_eval):\n        \"\"\"Evaluates the spline at given points.\"\"\"\n        x_eval = np.asarray(x_eval)\n        indices = np.searchsorted(self.x, x_eval, side='right') - 1\n        indices = np.clip(indices, 0, self.n - 2)\n\n        xi = self.x[indices]\n        xi1 = self.x[indices + 1]\n        yi = self.y[indices]\n        yi1 = self.y[indices + 1]\n        hi = self.h[indices]\n        Mi = self.M[indices]\n        Mi1 = self.M[indices + 1]\n\n        t = x_eval - xi\n        t_comp = xi1 - x_eval\n        \n        term1 = (Mi / (6 * hi)) * (t_comp**3)\n        term2 = (Mi1 / (6 * hi)) * (t**3)\n        term3 = (yi1 / hi - Mi1 * hi / 6) * t\n        term4 = (yi / hi - Mi * hi / 6) * t_comp\n        \n        return term1 + term2 + term3 + term4\n\ndef calculate_overshoot(spline, n_grid=1001):\n    \"\"\"Calculates the global overshoot magnitude for a given spline.\"\"\"\n    max_overshoot = 0.0\n    for i in range(spline.n - 1):\n        xi, xi1 = spline.x[i], spline.x[i+1]\n        yi, yi1 = spline.y[i], spline.y[i+1]\n        \n        m_i = min(yi, yi1)\n        M_i = max(yi, yi1)\n        \n        x_grid = np.linspace(xi, xi1, n_grid)\n        y_grid = spline.evaluate(x_grid)\n        \n        overshoot = np.max(y_grid) - M_i\n        undershoot = m_i - np.min(y_grid)\n        \n        interval_max_deviation = max(overshoot, undershoot, 0.0)\n        \n        if interval_max_deviation > max_overshoot:\n            max_overshoot = interval_max_deviation\n            \n    return max_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (left-end steepening)\n        {'x': [0.0, 0.5, 0.6, 2.0], 'y': [0.0, 1.0, 10.0, 12.0]},\n        # Case B (near-linear)\n        {'x': [0.0, 1.0, 2.0, 3.0], 'y': [0.0, 1.0, 2.0, 3.0]},\n        # Case C (right-end steepening)\n        {'x': [0.0, 1.4, 1.5, 2.0], 'y': [0.0, 2.0, 3.0, 3.2]}\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x = case['x']\n        y = case['y']\n        \n        # Natural Spline\n        natural_spline = CubicSpline(x, y, bc_type='natural')\n        delta_natural = calculate_overshoot(natural_spline)\n        results.append(delta_natural)\n        \n        # Clamped Spline\n        clamped_spline = CubicSpline(x, y, bc_type='clamped')\n        delta_clamped = calculate_overshoot(clamped_spline)\n        results.append(delta_clamped)\n\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3220873"}]}