{"hands_on_practices": [{"introduction": "In polynomial interpolation, the choice of data points is not arbitrary; it critically determines the accuracy of the resulting approximation. Chebyshev nodes are the specific set of points that provably minimize the maximum possible interpolation error, making them a cornerstone of numerical analysis. This first practice [@problem_id:2187308] grounds this theory by guiding you through the fundamental calculation of these optimal nodes directly from the definition of Chebyshev polynomials.", "problem": "In the field of numerical approximation, choosing the points at which to evaluate a function for polynomial interpolation is crucial for minimizing error. For a function defined on the interval $[-1, 1]$, the set of points that minimizes the maximum possible interpolation error are known as the Chebyshev nodes. For interpolation using a polynomial of degree at most $n$, the $n+1$ Chebyshev nodes are the roots of the Chebyshev polynomial of the first kind of degree $n+1$, denoted $T_{n+1}(x)$.\n\nThe Chebyshev polynomials are defined by the relation $T_k(x) = \\cos(k \\arccos(x))$ for an integer $k \\ge 0$.\n\nDetermine the set of nodes required for an optimal polynomial interpolation of degree at most 3. This corresponds to finding the roots of $T_4(x)$. Find the exact values of these four nodes. List the nodes in ascending order.", "solution": "We seek the optimal interpolation nodes on $[-1,1]$ for a polynomial of degree at most $3$. By the Chebyshev criterion, these are the $4$ roots of $T_{4}(x)$, where $T_{k}(x)$ is defined by $T_{k}(x)=\\cos(k\\arccos(x))$.\n\nLet $x=\\cos\\theta$ with $\\theta=\\arccos(x)$. Then\n$$\nT_{4}(x)=\\cos(4\\theta).\n$$\nThe roots of $T_{4}(x)$ occur when\n$$\n\\cos(4\\theta)=0.\n$$\nThe general solutions in $\\theta\\in[0,\\pi]$ are\n$$\n4\\theta=\\frac{(2m-1)\\pi}{2},\\quad m=1,2,3,4,\n$$\nso\n$$\n\\theta_{m}=\\frac{(2m-1)\\pi}{8},\\quad m=1,2,3,4.\n$$\nTherefore the nodes are\n$$\nx_{m}=\\cos\\left(\\frac{(2m-1)\\pi}{8}\\right),\\quad m=1,2,3,4,\n$$\nnamely\n$$\n\\cos\\left(\\frac{\\pi}{8}\\right),\\ \\cos\\left(\\frac{3\\pi}{8}\\right),\\ \\cos\\left(\\frac{5\\pi}{8}\\right),\\ \\cos\\left(\\frac{7\\pi}{8}\\right).\n$$\nUsing the identities $\\cos\\left(\\frac{5\\pi}{8}\\right)=-\\cos\\left(\\frac{3\\pi}{8}\\right)$ and $\\cos\\left(\\frac{7\\pi}{8}\\right)=-\\cos\\left(\\frac{\\pi}{8}\\right)$, and the half-angle values\n$$\n\\cos\\left(\\frac{\\pi}{8}\\right)=\\frac{1}{2}\\sqrt{2+\\sqrt{2}},\\quad \\cos\\left(\\frac{3\\pi}{8}\\right)=\\frac{1}{2}\\sqrt{2-\\sqrt{2}},\n$$\nthe four nodes in ascending order are $-\\frac{1}{2}\\sqrt{2+\\sqrt{2}}$, $-\\frac{1}{2}\\sqrt{2-\\sqrt{2}}$, $\\frac{1}{2}\\sqrt{2-\\sqrt{2}}$, and $\\frac{1}{2}\\sqrt{2+\\sqrt{2}}$.", "answer": "$$\\boxed{\\begin{pmatrix}-\\frac{1}{2}\\sqrt{2+\\sqrt{2}} & -\\frac{1}{2}\\sqrt{2-\\sqrt{2}} & \\frac{1}{2}\\sqrt{2-\\sqrt{2}} & \\frac{1}{2}\\sqrt{2+\\sqrt{2}}\\end{pmatrix}}$$", "id": "2187308"}, {"introduction": "After learning how to find Chebyshev nodes, the logical next step is to use them for their intended purpose: interpolation. By evaluating a function at these carefully selected points, we can construct a polynomial that not only passes through them but also minimizes oscillations and avoids the infamous Runge's phenomenon common with equally spaced points. This exercise [@problem_id:2187288] makes the concept tangible by having you interpolate the function $f(x) = x^3$, demonstrating the remarkable effectiveness and elegance of Chebyshev-based approximation.", "problem": "In numerical analysis, interpolation using Chebyshev nodes is a superior alternative to using equally spaced points, especially for avoiding Runge's phenomenon. This method chooses interpolation points that are the roots of Chebyshev polynomials, which are clustered near the endpoints of the interval.\n\nConsider the function $f(x) = x^3$ over the interval $[-1, 1]$. Your task is to find the unique polynomial of degree at most 2, let's call it $P_2(x)$, that interpolates $f(x)$ at the three Chebyshev nodes on this interval. These nodes are defined as the roots of the degree-3 Chebyshev polynomial of the first kind, $T_3(x)$.\n\nExpress your answer for $P_2(x)$ as a simplified polynomial in terms of $x$.", "solution": "We are given $f(x)=x^{3}$ on $[-1,1]$ and must find the unique polynomial $P_{2}(x)$ of degree at most $2$ that interpolates $f$ at the three Chebyshev nodes on $[-1,1]$, defined as the roots of $T_{3}(x)$, the degree-$3$ Chebyshev polynomial of the first kind.\n\nUse the identity $T_{3}(x)=\\cos\\!\\big(3\\arccos x\\big)=4x^{3}-3x$. The roots of $T_{3}$ are the three Chebyshev nodes:\n$$\nT_{3}(x)=4x^{3}-3x=x\\big(4x^{2}-3\\big)=0\n\\quad\\Longrightarrow\\quad\nx\\in\\left\\{0,\\;\\pm\\frac{\\sqrt{3}}{2}\\right\\}.\n$$\nLet $P_{2}(x)=A x^{2}+B x+C$. The interpolation conditions are $P_{2}(\\xi)=\\xi^{3}$ at each node $\\xi\\in\\left\\{0,\\pm\\frac{\\sqrt{3}}{2}\\right\\}$.\n\n1) At $x=0$:\n$$\nP_{2}(0)=C=0 \\quad\\Longrightarrow\\quad C=0.\n$$\n\n2) Let $a=\\frac{\\sqrt{3}}{2}$. At $x=a$ and $x=-a$:\n$$\nP_{2}(a)=A a^{2}+B a=a^{3},\\qquad P_{2}(-a)=A a^{2}-B a=-a^{3}.\n$$\nAdding these two equations eliminates $B$:\n$$\n\\big(A a^{2}+B a\\big)+\\big(A a^{2}-B a\\big)=a^{3}+(-a^{3})\n\\;\\Longrightarrow\\;\n2A a^{2}=0\n\\;\\Longrightarrow\\;\nA=0\n\\quad(\\text{since }a\\neq 0).\n$$\nSubstitute $A=0$ into $A a^{2}+B a=a^{3}$ to solve for $B$:\n$$\nB a=a^{3}\\;\\Longrightarrow\\;B=a^{2}.\n$$\nWith $a=\\frac{\\sqrt{3}}{2}$, we have\n$$\na^{2}=\\left(\\frac{\\sqrt{3}}{2}\\right)^{2}=\\frac{3}{4}.\n$$\nTherefore, the interpolating polynomial is\n$$\nP_{2}(x)=B x=\\frac{3}{4}\\,x.\n$$\nA quick check: $P_{2}(0)=0=f(0)$, and $P_{2}(\\pm a)=\\frac{3}{4}(\\pm a)=\\pm a\\cdot\\frac{3}{4}=\\pm a^{3}=f(\\pm a)$, so the interpolation conditions are satisfied at all three Chebyshev nodes.\n\nHence, the unique interpolating polynomial of degree at most $2$ is $P_{2}(x)=\\frac{3}{4}x$.", "answer": "$$\\boxed{\\frac{3}{4}x}$$", "id": "2187288"}, {"introduction": "We have established the optimality of Chebyshev interpolation within the interval $[-1, 1]$, but a crucial aspect of computational science is understanding the limitations of our methods. Extrapolating—or using a model outside the domain for which it was built—can lead to catastrophic errors, and Chebyshev polynomials are a prime example of this danger due to their exponential growth. This advanced practice [@problem_id:3105811] explores this critical behavior, guiding you to analyze this instability and develop a quantitative understanding of \"safe\" extrapolation margins, a key skill for any practitioner building robust numerical models.", "problem": "You are tasked with analyzing extrapolation behavior of Chebyshev polynomials and proposing principled margins for safe extrapolation outside the canonical interval. The analysis must be grounded in fundamental definitions and widely accepted facts, and implemented as a complete, runnable program that produces deterministic numeric outputs for a test suite.\n\nStarting from the following base:\n- The Chebyshev polynomials of the first kind $T_n(x)$ are defined by the recurrence $T_0(x)=1$, $T_1(x)=x$, and $T_{n+1}(x)=2 x T_n(x)-T_{n-1}(x)$ for $n \\ge 1$.\n- The identity $T_n(\\cos(\\theta))=\\cos(n \\theta)$ for real $\\theta$ holds by definition of the Chebyshev polynomials in terms of the cosine function.\n\nYour tasks are:\n1. Derive, from the base, a numerically stable expression for $T_n(x)$ when $|x|>1$, and use it to characterize the growth of $T_n(x)$ as a function of $n$ and $x$ outside the interval $[-1,1]$. Angles must be in radians.\n2. Define a safe extrapolation margin based on a growth cap: for a chosen polynomial degree $n$ and a cap $G \\ge 1$, define $\\delta(n,G) \\ge 0$ to be the minimal nonnegative number such that $|T_n(1+\\delta(n,G))|=G$. Interpret $\\delta(n,G)$ as a symmetric margin beyond the interval endpoints $-1$ and $1$ that controls amplification by at most the factor $G$. Derive the expression for $\\delta(n,G)$ purely from the base and your result for $|x|>1$.\n\nImplement the derived formulas in a program and evaluate the following test suite. Every numeric quantity must be treated as a real scalar:\n- Growth tests:\n  - Case $1$: Compute $|T_{10}(1.05)|$.\n  - Case $2$: Compute $|T_{20}(1.01)|$.\n  - Case $3$: Compute $T_{10}(-1.05)$ without an absolute value to expose the sign pattern.\n- Safe margin tests:\n  - Case $4$: Compute $\\delta(10,2)$.\n  - Case $5$: Compute $\\delta(50,2)$.\n  - Case $6$: Compute $\\delta(10,1.001)$.\n- Monotonicity checks:\n  - Case $7$: Return a boolean indicating whether $|T_{10}(1.10)|>|T_{10}(1.05)|$.\n  - Case $8$: Return a boolean indicating whether $|T_{10}(-1.10)|>|T_{10}(-1.05)|$.\n- Symmetry consistency:\n  - Case $9$: Let $\\delta=\\delta(10,2)$ and check whether $||T_{10}(-1-\\delta)|-2|\\le \\varepsilon$ with $\\varepsilon=10^{-12}$; return a boolean.\n- Boundary case:\n  - Case $10$: Compute $T_{37}(1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order of the above cases (for example, $[r_1,r_2,\\dots,r_{10}]$). The answers must be of fundamental types: a boolean or a float. No physical units are involved, and angles are in radians throughout.", "solution": "The Chebyshev polynomials of the first kind $T_n(x)$ are classically defined by the recurrence $T_0(x)=1$, $T_1(x)=x$, and $T_{n+1}(x)=2 x T_n(x)-T_{n-1}(x)$ for $n \\ge 1$. A well-tested identity is $T_n(\\cos(\\theta))=\\cos(n \\theta)$ for real $\\theta$, which follows from substituting $x=\\cos(\\theta)$ into the recurrence and verifying the cosine multiple-angle identity holds.\n\nTo analyze $T_n(x)$ for $|x|>1$, we use analytic continuation of the trigonometric identity. For $x \\ge 1$, write $x=\\cosh(u)$ for a unique $u \\ge 0$, where $\\cosh(u)$ is the hyperbolic cosine and $u=\\operatorname{arccosh}(x)$. Note that $\\cos(i u)=\\cosh(u)$ holds by the relation between trigonometric and hyperbolic functions. Then\n$$\nT_n(\\cos(i u))=\\cos(n \\, i u)=\\cosh(n u).\n$$\nSetting $x=\\cosh(u)$ gives $T_n(x)=\\cosh(n \\, \\operatorname{arccosh}(x))$ for $x \\ge 1$. This establishes a numerically stable expression that avoids the ill-conditioned direct recurrence for large $n$ and $x$ outside $[-1,1]$.\n\nFor $x \\le -1$, write $x=-\\cosh(u)$ with $u=\\operatorname{arccosh}(-x) \\ge 0$. The parity property $T_n(-x)=(-1)^n T_n(x)$ follows from the recurrence: since $T_0(x)$ is even and $T_1(x)$ is odd, the recurrence preserves parity, giving $T_n(-x)=(-1)^n T_n(x)$. Combining this with the $x \\ge 1$ case yields\n$$\nT_n(x)=(-1)^n \\cosh\\!\\big(n \\, \\operatorname{arccosh}(-x)\\big), \\quad x \\le -1.\n$$\nThus, for both sides outside $[-1,1]$, the magnitude growth is governed by $\\cosh(n u)$ with $u>0$, which behaves like $\\frac{1}{2} e^{n u}$ for large $n u$:\n$$\n\\cosh(n u)=\\frac{e^{n u}+e^{-n u}}{2} \\approx \\frac{e^{n u}}{2} \\quad \\text{for large } n u.\n$$\nThis demonstrates exponential amplification outside the interpolation interval and explains why naive extrapolation using high-degree polynomials is numerically hazardous.\n\nTo propose safe extrapolation margins, set a cap $G \\ge 1$ on allowable amplification at the endpoint and solve for the minimal $\\delta \\ge 0$ such that the amplification at $x=1+\\delta$ equals $G$:\n$$\n|T_n(1+\\delta)|=G.\n$$\nFor $\\delta \\ge 0$, use $u=\\operatorname{arccosh}(1+\\delta) \\ge 0$ to get\n$$\n|T_n(1+\\delta)|=\\cosh(n u).\n$$\nSolving $\\cosh(n u)=G$ for $u$ gives $u=\\frac{1}{n} \\operatorname{arccosh}(G)$, and converting back to $\\delta$ yields\n$$\n\\delta(n,G)=\\cosh\\!\\left(\\frac{1}{n} \\operatorname{arccosh}(G)\\right)-1.\n$$\nThis $\\delta(n,G)$ is the minimal nonnegative margin beyond $x=1$ that reaches amplification $G$, since $\\operatorname{arccosh}(x)$ is strictly increasing for $x \\ge 1$ and $\\cosh(n u)$ is strictly increasing for $u \\ge 0$. By symmetry and parity, the same margin applies at $x=-1-\\delta$ in magnitude:\n$$\n|T_n(-1-\\delta)|=\\cosh\\!\\left(n \\, \\operatorname{arccosh}(1+\\delta)\\right)=G.\n$$\n\nAlgorithmic design:\n- Implement $T_n(x)$ as:\n  - If $x \\ge 1$, compute $T_n(x)=\\cosh\\!\\big(n \\, \\operatorname{arccosh}(x)\\big)$.\n  - If $x \\le -1$, compute $T_n(x)=(-1)^n \\cosh\\!\\big(n \\, \\operatorname{arccosh}(-x)\\big)$.\n  - If $|x|1$, compute $T_n(x)=\\cos\\!\\big(n \\, \\arccos(x)\\big)$ to handle any boundary case such as $x=1$ via continuity (note that $\\operatorname{arccosh}(1)=0$ so the $x \\ge 1$ branch already yields $T_n(1)=1$).\n- Implement $\\delta(n,G)$ using the derived closed form $\\delta(n,G)=\\cosh\\!\\left(\\frac{1}{n} \\operatorname{arccosh}(G)\\right)-1$ for $G \\ge 1$.\n- For monotonicity checks, verify numerically that for fixed $n$ and $x_2>x_1>1$, $|T_n(x_2)|>|T_n(x_1)|$, and similarly for negative arguments using absolute values to ignore alternating signs.\n\nApplying this to the test suite:\n- Case $1$: $|T_{10}(1.05)|=\\cosh\\!\\left(10 \\, \\operatorname{arccosh}(1.05)\\right)$.\n- Case $2$: $|T_{20}(1.01)|=\\cosh\\!\\left(20 \\, \\operatorname{arccosh}(1.01)\\right)$.\n- Case $3$: $T_{10}(-1.05)=(-1)^{10}\\cosh\\!\\left(10 \\, \\operatorname{arccosh}(1.05)\\right)$, which equals $+\\cosh\\!\\left(10 \\, \\operatorname{arccosh}(1.05)\\right)$ because $(-1)^{10}=1$; the program will compute this directly.\n- Case $4$: $\\delta(10,2)=\\cosh\\!\\left(\\frac{1}{10}\\operatorname{arccosh}(2)\\right)-1$.\n- Case $5$: $\\delta(50,2)=\\cosh\\!\\left(\\frac{1}{50}\\operatorname{arccosh}(2)\\right)-1$.\n- Case $6$: $\\delta(10,1.001)=\\cosh\\!\\left(\\frac{1}{10}\\operatorname{arccosh}(1.001)\\right)-1$.\n- Case $7$: Check $|T_{10}(1.10)|>|T_{10}(1.05)|$.\n- Case $8$: Check $|T_{10}(-1.10)|>|T_{10}(-1.05)|$.\n- Case $9$: With $\\delta=\\delta(10,2)$, verify $||T_{10}(-1-\\delta)|-2|\\le 10^{-12}$.\n- Case $10$: $T_{37}(1)=1$ since $\\operatorname{arccosh}(1)=0$.\n\nThe program will compute and print a single list $[r_1,r_2,\\dots,r_{10}]$ corresponding to these cases, with floats and booleans as specified.", "answer": "```python\nimport numpy as np\n\ndef chebyshev_T(n: int, x: float) - float:\n    \"\"\"\n    Compute Chebyshev polynomial of the first kind T_n(x) for real x,\n    using numerically stable formulas across domains.\n    \"\"\"\n    if x = 1.0:\n        # x in [1, +inf): use hyperbolic form\n        return float(np.cosh(n * np.arccosh(x)))\n    elif x = -1.0:\n        # x in (-inf, -1]: use parity and hyperbolic form\n        return float(((-1)**n) * np.cosh(n * np.arccosh(-x)))\n    else:\n        # x in (-1, 1): use trigonometric form\n        return float(np.cos(n * np.arccos(x)))\n\ndef safe_margin(n: int, G: float) - float:\n    \"\"\"\n    Minimal nonnegative delta such that |T_n(1 + delta)| = G, for G = 1.\n    Derived: delta = cosh((1/n) * arccosh(G)) - 1.\n    \"\"\"\n    if G  1.0:\n        raise ValueError(\"Growth cap G must be = 1.\")\n    return float(np.cosh((1.0 / n) * np.arccosh(G)) - 1.0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case is encoded as a dict specifying the operation.\n    test_cases = [\n        {\"type\": \"abs_T\", \"n\": 10, \"x\": 1.05},       # Case 1\n        {\"type\": \"abs_T\", \"n\": 20, \"x\": 1.01},       # Case 2\n        {\"type\": \"T\", \"n\": 10, \"x\": -1.05},          # Case 3\n        {\"type\": \"delta\", \"n\": 10, \"G\": 2.0},        # Case 4\n        {\"type\": \"delta\", \"n\": 50, \"G\": 2.0},        # Case 5\n        {\"type\": \"delta\", \"n\": 10, \"G\": 1.001},      # Case 6\n        {\"type\": \"mono_pos\", \"n\": 10, \"x1\": 1.10, \"x0\": 1.05},  # Case 7\n        {\"type\": \"mono_neg\", \"n\": 10, \"x1\": -1.10, \"x0\": -1.05},# Case 8\n        {\"type\": \"sym_check\", \"n\": 10, \"G\": 2.0, \"eps\": 1e-12}, # Case 9\n        {\"type\": \"T\", \"n\": 37, \"x\": 1.0},            # Case 10\n    ]\n\n    results = []\n    for case in test_cases:\n        t = case[\"type\"]\n        if t == \"abs_T\":\n            n = case[\"n\"]; x = case[\"x\"]\n            val = abs(chebyshev_T(n, x))\n            results.append(val)\n        elif t == \"T\":\n            n = case[\"n\"]; x = case[\"x\"]\n            val = chebyshev_T(n, x)\n            results.append(val)\n        elif t == \"delta\":\n            n = case[\"n\"]; G = case[\"G\"]\n            d = safe_margin(n, G)\n            results.append(d)\n        elif t == \"mono_pos\":\n            n = case[\"n\"]; x1 = case[\"x1\"]; x0 = case[\"x0\"]\n            v1 = abs(chebyshev_T(n, x1))\n            v0 = abs(chebyshev_T(n, x0))\n            results.append(v1  v0)\n        elif t == \"mono_neg\":\n            n = case[\"n\"]; x1 = case[\"x1\"]; x0 = case[\"x0\"]\n            v1 = abs(chebyshev_T(n, x1))\n            v0 = abs(chebyshev_T(n, x0))\n            results.append(v1  v0)\n        elif t == \"sym_check\":\n            n = case[\"n\"]; G = case[\"G\"]; eps = case[\"eps\"]\n            d = safe_margin(n, G)\n            val = abs(chebyshev_T(n, -1.0 - d))\n            ok = abs(val - G) = eps\n            results.append(ok)\n        else:\n            # Unsupported test case type; for completeness, raise error\n            raise ValueError(f\"Unknown test case type: {t}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3105811"}]}