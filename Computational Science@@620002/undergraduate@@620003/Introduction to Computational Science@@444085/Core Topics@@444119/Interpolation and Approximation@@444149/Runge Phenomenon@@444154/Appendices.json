{"hands_on_practices": [{"introduction": "Before we visualize the Runge phenomenon on a full function, let's investigate one of its underlying causes hidden within the mathematics of the interpolation grid itself. The barycentric weights, which are crucial for a stable interpolation, have vastly different magnitudes depending on their location in a uniform grid. This practice will guide you through a precise calculation [@problem_id:2199710] to quantify this imbalance, providing a foundational insight into why uniform nodes can lead to instability in high-degree polynomial interpolation.", "problem": "In the study of polynomial interpolation, the choice of interpolation points (nodes) significantly affects the accuracy and stability of the resulting polynomial. The barycentric interpolation formula provides a numerically stable way to evaluate the interpolating polynomial, and its properties are closely tied to quantities known as barycentric weights.\n\nConsider a set of $n+1$ uniformly distributed interpolation nodes $x_j$ on the interval $[-1, 1]$, where $j=0, 1, \\ldots, n$. The nodes are given by the formula $x_j = -1 + j \\cdot h$, where the step size is $h = \\frac{2}{n}$.\n\nThe barycentric weight $w_j$ for the node $x_j$ is defined as:\n$$\nw_j = \\left(\\prod_{k=0, k \\neq j}^{n} (x_j - x_k)\\right)^{-1}\n$$\n\nFor the specific case where $n=10$, which results in 11 interpolation nodes, determine the exact value of the ratio $\\frac{|w_{10}|}{|w_5|}$. This ratio compares the magnitude of the barycentric weight at the right endpoint of the interval ($x_{10}=1$) to the magnitude of the weight at the center of the interval ($x_5=0$).\n\nExpress your final answer as a fraction in simplest form.", "solution": "We have uniformly spaced nodes $x_{j}=-1+jh$ with $h=\\frac{2}{n}$ and $j=0,1,\\ldots,n$. The barycentric weight is\n$$\nw_{j}=\\left(\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})\\right)^{-1}.\n$$\nFor uniform spacing,\n$$\nx_{j}-x_{k}=(-1+jh)-(-1+kh)=(j-k)h,\n$$\nso the product over the $n$ terms (excluding $k=j$) factors as\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(x_{j}-x_{k})=h^{n}\\prod_{k=0,\\,k\\neq j}^{n}(j-k).\n$$\nHence\n$$\nw_{j}=h^{-n}\\left(\\prod_{k=0,\\,k\\neq j}^{n}(j-k)\\right)^{-1}.\n$$\nEvaluate the integer product by splitting at $j$:\n$$\n\\prod_{k=0,\\,k\\neq j}^{n}(j-k)=\\left(\\prod_{k=0}^{j-1}(j-k)\\right)\\left(\\prod_{k=j+1}^{n}(j-k)\\right)\n=j!\\cdot\\left[\\prod_{m=1}^{n-j}(-m)\\right]=(-1)^{n-j}j!(n-j)!.\n$$\nTherefore, taking absolute values,\n$$\n|w_{j}|=h^{-n}\\left|(-1)^{n-j}j!(n-j)!\\right|^{-1}=h^{-n}\\frac{1}{j!(n-j)!}.\n$$\nFor $n=10$, we obtain\n$$\n\\frac{|w_{10}|}{|w_{5}|}=\\frac{h^{-10}/\\left(10!\\cdot 0!\\right)}{h^{-10}/\\left(5!\\cdot 5!\\right)}=\\frac{(5!)^{2}}{10!\\cdot 0!}=\\frac{(5!)^{2}}{10!}.\n$$\nSimplify using $10!=10\\cdot 9\\cdot 8\\cdot 7\\cdot 6\\cdot 5!$ and $5!=120$:\n$$\n\\frac{(5!)^{2}}{10!}=\\frac{5!}{10\\cdot 9\\cdot 8\\cdot 7\\cdot 6}=\\frac{120}{30240}=\\frac{1}{252}.\n$$\nThus the exact ratio is $\\frac{1}{252}$.", "answer": "$$\\boxed{\\frac{1}{252}}$$", "id": "2199710"}, {"introduction": "With a theoretical understanding of the instability of uniform nodes, we now turn to a direct computational experiment on the classic Runge function, $f(x) = \\frac{1}{1+25x^2}$. This exercise [@problem_id:3212557] challenges you to implement and compare polynomial interpolation using both equispaced nodes and the improved Chebyshev-Lobatto nodes. By quantifying the error and oscillatory behavior, you will gain a concrete, measurable understanding of the Runge phenomenon and the remarkable effectiveness of choosing better-behaved interpolation points.", "problem": "You are to investigate the Runge phenomenon for polynomial interpolation of the function $f(x)=\\dfrac{1}{1+25x^2}$ on the interval $[-1,1]$ by comparing two node choices: equispaced nodes and Chebyshev–Lobatto nodes. Your implementation must be a complete, runnable program that carries out the computations numerically and reports quantitative metrics that enable a clear comparison of the two node choices. All angles must be interpreted in radians.\n\nUse only foundational definitions and well-tested facts as your starting point:\n- The interpolation problem is: given nodes $\\{x_j\\}_{j=0}^n$ in $[-1,1]$ and data values $y_j=f(x_j)$, construct the unique polynomial $p_n$ of degree at most $n$ such that $p_n(x_j)=y_j$ for all $j$.\n- The Chebyshev polynomials of the first kind $\\{T_k\\}_{k\\ge 0}$ are defined by $T_k(\\cos\\theta)=\\cos(k\\theta)$ for $\\theta\\in\\mathbb{R}$, and the Chebyshev–Lobatto nodes are the extrema of $T_n$, namely $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$ for $k=0,1,\\dots,n$, with $\\pi$ measured in radians.\n- The Runge phenomenon refers to the large endpoint oscillations that may occur when interpolating analytic functions with high-degree polynomials at equispaced nodes on $[-1,1]$.\n\nYour task is to:\n1. For each node family and each degree $n$, construct the interpolating polynomial $p_n$ without using any pre-existing black-box interpolation routines. You may use any mathematically equivalent and numerically stable formulation consistent with the definition of polynomial interpolation (for example, a barycentric realization of Lagrange interpolation, or a Newton form constructed from divided differences). Ensure numerical stability.\n2. Approximate the uniform error $\\lVert f-p_n\\rVert_{\\infty}$ on $[-1,1]$ by sampling $p_n$ and $f$ on a uniform grid of $M$ points in $[-1,1]$. Use $M=20001$.\n3. Quantify endpoint behavior using two measures on the union of endpoint windows $[-1,-1+w]\\cup[1-w,1]$ with $w=0.1$:\n   - The endpoint error amplitude $E_{\\mathrm{end}}=\\max_{x\\in[-1,-1+w]\\cup[1-w,1]} |f(x)-p_n(x)|$.\n   - An endpoint oscillation count defined as the number of strict sign changes of a discrete derivative of $p_n$ on the sampled grid restricted to $[-1,-1+w]\\cup[1-w,1]$. Compute the derivative via a centered finite-difference on the uniform grid and threshold small magnitudes by declaring values with absolute value $\\le \\tau$ as zero, where $\\tau=10^{-8}$. A strict sign change is counted whenever two consecutive nonzero derivative samples have opposite signs. Zeros should be ignored (do not count transitions involving zero; compress runs of zeros by carrying forward the last nonzero sign when determining changes).\n4. Compare equispaced nodes and Chebyshev–Lobatto nodes for each $n$ using the above metrics.\n\nTest suite and parameters:\n- Use degrees $n\\in\\{5,10,20\\}$.\n- For each $n$, use both node families:\n  - Equispaced nodes: $x_j=-1+\\dfrac{2j}{n}$ for $j=0,1,\\dots,n$.\n  - Chebyshev–Lobatto nodes: $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$ for $k=0,1,\\dots,n$, with $\\pi$ in radians.\n\nRequired outputs per degree $n$:\n- For equispaced nodes: three values in this order $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{oscillation count})$.\n- For Chebyshev–Lobatto nodes: three values in this order $(\\lVert f-p_n\\rVert_{\\infty},\\ E_{\\mathrm{end}},\\ \\text{oscillation count})$.\n- Thus, for each $n$, report six values. For all three values of $n$, report a total of $18$ values.\n\nFinal output format:\n- Your program must produce a single line of output containing all $18$ results as a comma-separated list enclosed in square brackets, ordered by $n=5$, then $n=10$, then $n=20$, and within each $n$ the equispaced triplet followed by the Chebyshev–Lobatto triplet. For example, your output should look like\n  $[a_1,a_2,a_3,a_4,a_5,a_6,\\ a_7,a_8,a_9,a_{10},a_{11},a_{12},\\ a_{13},a_{14},a_{15},a_{16},a_{17},a_{18}]$,\n  where all $a_i$ are numbers in the specified order.\n- Express all floating-point outputs rounded to $8$ decimal places; oscillation counts must be integers.\n\nAngle unit specification:\n- Wherever the cosine function is used to define nodes, the argument must be in radians.\n\nYour program must be fully self-contained, require no user input, and rely only on the Python standard library and the specified numerical library. The only permitted numerical library is a standard numerical array library. The output must be reproducible under the given specifications.", "solution": "We begin with the definition of polynomial interpolation. For nodes $\\{x_j\\}_{j=0}^n\\subset[-1,1]$ and values $y_j=f(x_j)$, there exists a unique polynomial $p_n\\in\\mathbb{P}_n$ with $p_n(x_j)=y_j$ for all $j$. Any representation consistent with this definition is acceptable. From a numerical methods perspective, a robust approach uses the barycentric Lagrange formulation, which realizes the same interpolant while improving numerical stability compared to the naive Lagrange formula.\n\nFoundational facts used:\n1. Interpolation error identity: For $f\\in C^{n+1}([-1,1])$, the pointwise error can be expressed as\n   $$ f(x)-p_n(x)=\\frac{f^{(n+1)}(\\xi_x)}{(n+1)!}\\prod_{j=0}^n (x-x_j), $$\n   for some $\\xi_x\\in(-1,1)$ depending on $x$. This identity shows that the node placement $\\{x_j\\}$ shapes the factor $\\prod_{j=0}^n(x-x_j)$ and hence the size and distribution of the error.\n2. Chebyshev polynomials of the first kind $\\{T_k\\}$ satisfy $T_k(\\cos\\theta)=\\cos(k\\theta)$ for $\\theta\\in\\mathbb{R}$. The extrema of $T_n$ occur at $x_k=\\cos\\left(\\frac{k\\pi}{n}\\right)$, $k=0,\\dots,n$, which are the Chebyshev–Lobatto nodes. These nodes cluster near the endpoints and are known to tame the magnitude of $\\prod_{j=0}^n(x-x_j)$ on $[-1,1]$ relative to equispaced nodes.\n3. The Runge phenomenon arises prominently for equispaced nodes as $n$ grows, amplifying oscillations near endpoints even for analytic $f$. Chebyshev–Lobatto nodes mitigate this by distributing nodes according to the density induced by the map $x=\\cos\\theta$ with uniformly spaced $\\theta$.\n\nAlgorithmic design:\n- Function and grid:\n  - Define $f(x)=\\dfrac{1}{1+25x^2}$ on $[-1,1]$.\n  - Use a uniform grid $\\{x^{\\mathrm{eval}}_i\\}_{i=0}^{M-1}$ with $M=20001$ points spanning $[-1,1]$ to approximate $\\lVert f-p_n\\rVert_{\\infty}$ by sampling.\n- Node generation:\n  - Equispaced nodes: $x_j=-1+\\dfrac{2j}{n}$ for $j=0,\\dots,n$.\n  - Chebyshev–Lobatto nodes: $x_k=\\cos\\left(\\dfrac{k\\pi}{n}\\right)$ for $k=0,\\dots,n$ with $\\pi$ in radians.\n- Interpolation construction:\n  - Use the barycentric Lagrange interpolant (which is mathematically equivalent to the unique interpolating polynomial) with weights $w_j=\\left(\\prod_{m\\ne j}(x_j-x_m)\\right)^{-1}$. Scaling all $w_j$ by a common nonzero factor leaves the interpolant invariant and can be used to normalize the weights for numerical stability.\n  - For evaluation at a point $x$, the first barycentric formula reads\n    $$ p_n(x)=\\frac{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j} y_j}{\\sum_{j=0}^n \\dfrac{w_j}{x-x_j}}, $$\n    with the convention that if $x=x_j$ (to numerical tolerance), then $p_n(x)=y_j$ exactly to enforce interpolation and avoid division by zero.\n  - Vectorize evaluation across the entire grid $\\{x^{\\mathrm{eval}}_i\\}$ for efficiency.\n- Error metrics:\n  - Compute the sampled error $e_i=|f(x^{\\mathrm{eval}}_i)-p_n(x^{\\mathrm{eval}}_i)|$ and approximate $\\lVert f-p_n\\rVert_{\\infty}$ by $\\max_i e_i$.\n  - Define endpoint windows with width $w=0.1$ as $[-1,-1+w]\\cup[1-w,1]$, i.e., $[-1,-0.9]\\cup[0.9,1]$, and compute $E_{\\mathrm{end}}=\\max\\{e_i: x^{\\mathrm{eval}}_i\\in[-1,-0.9]\\cup[0.9,1]\\}$.\n- Oscillation metric:\n  - Approximate the derivative of $p_n$ on the grid by a centered finite-difference, i.e., the standard second-order accurate discrete derivative on a uniform grid with edge handling.\n  - Threshold small derivative magnitudes using $\\tau=10^{-8}$: map values with absolute value $\\le \\tau$ to $0$, leaving other values unchanged. Define the sign sequence $s_i=\\mathrm{sign}(p_n'(x^{\\mathrm{eval}}_i))$ with the thresholding applied.\n  - Restrict to indices in the union of endpoint windows. Remove zeros by compressing the sequence to its nonzero elements, and count strict sign changes: the number of indices where two consecutive nonzero signs differ (i.e., their product is negative). This yields an integer oscillation count for the endpoint regions.\n- Test suite:\n  - Degrees $n\\in\\{5,10,20\\}$. For each $n$, compute the triple $(\\lVert f-p_n\\rVert_{\\infty}, E_{\\mathrm{end}}, \\text{oscillation count})$ first for equispaced nodes and then for Chebyshev–Lobatto nodes.\n- Output formatting:\n  - For each $n$, concatenate the equispaced triple followed by the Chebyshev–Lobatto triple, yielding $6$ values per $n$ and $18$ values overall when $n=5,10,20$ are processed in order.\n  - Round all floating-point outputs to $8$ decimal places; keep oscillation counts as integers.\n  - Print a single line in the form of a comma-separated list enclosed in brackets.\n\nWhy this reveals the Runge phenomenon:\n- By the error identity, equispaced nodes do not control $\\max_{x\\in[-1,1]}\\left|\\prod_{j=0}^n(x-x_j)\\right|$ as $n$ grows, leading to large endpoint oscillations even for analytic $f$. Chebyshev–Lobatto nodes, arising from the extrema of $T_n$, effectively minimize the sup norm of the nodal polynomial up to scaling, spreading error more uniformly and suppressing endpoint blow-up. The global sup norm error and the endpoint error amplitude directly quantify these effects. The oscillation count detects spurious oscillatory behavior in $p_n$ near endpoints that is absent in $f$ (which is monotone on each endpoint window), providing a complementary qualitative assessment that is reduced for Chebyshev–Lobatto nodes relative to equispaced nodes.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef f(x):\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef equispaced_nodes(n):\n    # n: degree, so n+1 nodes including endpoints\n    j = np.arange(n + 1, dtype=float)\n    return -1.0 + 2.0 * j / n\n\ndef chebyshev_lobatto_nodes(n):\n    # x_k = cos(k*pi/n), k=0..n, with radians\n    k = np.arange(n + 1, dtype=float)\n    return np.cos(np.pi * k / n)\n\ndef barycentric_weights(x):\n    # Compute first-form barycentric weights: w_j = 1 / prod_{k!=j} (x_j - x_k)\n    # Normalize to avoid overflow/underflow; overall scaling cancels in formula.\n    x = np.asarray(x, dtype=float)\n    m = x.size\n    w = np.empty(m, dtype=float)\n    for j in range(m):\n        diffs = x[j] - np.delete(x, j)\n        w[j] = 1.0 / np.prod(diffs)\n    # Normalize weights to unit max absolute value\n    maxabs = np.max(np.abs(w))\n    if maxabs == 0.0 or not np.isfinite(maxabs):\n        return w\n    return w / maxabs\n\ndef barycentric_interpolate(x_nodes, y_nodes, w, x_eval, atol=1e-14):\n    # Vectorized first-form barycentric interpolation\n    x_nodes = np.asarray(x_nodes, dtype=float)\n    y_nodes = np.asarray(y_nodes, dtype=float)\n    w = np.asarray(w, dtype=float)\n    x_eval = np.asarray(x_eval, dtype=float)\n    # Compute differences matrix\n    Xdiff = x_eval[:, None] - x_nodes[None, :]\n    # Identify exact matches to nodes within tolerance\n    mask_eq = np.isclose(Xdiff, 0.0, rtol=0.0, atol=atol)\n    any_eq = np.any(mask_eq, axis=1)\n    # For non-matching points, compute barycentric formula\n    # Avoid division by zero by masking those rows later\n    with np.errstate(divide='ignore', invalid='ignore'):\n        tmp = w[None, :] / Xdiff\n        num = np.dot(tmp, y_nodes)\n        den = np.sum(tmp, axis=1)\n        y = num / den\n    # Fix rows where x_eval equals a node\n    if np.any(any_eq):\n        idxs = np.where(any_eq)[0]\n        # For each such row, pick the corresponding node value\n        # If multiple trues due to tolerance, take the first\n        j_star = np.argmax(mask_eq[idxs, :], axis=1)\n        y[idxs] = y_nodes[j_star]\n    return y\n\ndef endpoint_masks(x_grid, w=0.1):\n    left = x_grid <= (-1.0 + w)\n    right = x_grid >= (1.0 - w)\n    return left | right\n\ndef count_strict_sign_changes(values, tol=1e-8):\n    # values: derivative samples on a 1D grid\n    v = np.asarray(values, dtype=float)\n    s = np.sign(v)\n    s[np.abs(v) <= tol] = 0.0\n    nonzero = s[s != 0.0]\n    if nonzero.size <= 1:\n        return 0\n    # Count transitions where consecutive signs differ\n    return int(np.sum(nonzero[1:] * nonzero[:-1] < 0.0))\n\ndef interpolation_metrics(n, node_kind, x_eval, f_eval, tau=1e-8):\n    # node_kind: 'equispaced' or 'cheb_lobatto'\n    if node_kind == 'equispaced':\n        x_nodes = equispaced_nodes(n)\n    elif node_kind == 'cheb_lobatto':\n        x_nodes = chebyshev_lobatto_nodes(n)\n    else:\n        raise ValueError(\"Unknown node kind\")\n\n    y_nodes = f(x_nodes)\n    w = barycentric_weights(x_nodes)\n    p_eval = barycentric_interpolate(x_nodes, y_nodes, w, x_eval)\n\n    # Errors\n    err = np.abs(f_eval - p_eval)\n    E_inf = float(np.max(err))\n\n    # Endpoint window metrics\n    mask_end = endpoint_masks(x_eval, w=0.1)\n    E_end = float(np.max(err[mask_end]))\n\n    # Oscillation count via discrete derivative\n    # Use np.gradient with x grid for better edge approximation\n    dp = np.gradient(p_eval, x_eval, edge_order=2)\n    osc_count = count_strict_sign_changes(dp[mask_end], tol=tau)\n\n    return E_inf, E_end, osc_count\n\ndef solve():\n    # Define the test cases from the problem statement.\n    degrees = [5, 10, 20]  # n values\n    # Evaluation grid\n    M = 20001\n    x_eval = np.linspace(-1.0, 1.0, M, dtype=float)\n    f_eval = f(x_eval)\n\n    results = []\n    for n in degrees:\n        # Equispaced nodes metrics\n        E_inf_e, E_end_e, osc_e = interpolation_metrics(n, 'equispaced', x_eval, f_eval, tau=1e-8)\n        # Chebyshev–Lobatto nodes metrics\n        E_inf_c, E_end_c, osc_c = interpolation_metrics(n, 'cheb_lobatto', x_eval, f_eval, tau=1e-8)\n\n        # Round floats to 8 decimal places as required; integers unchanged\n        results.extend([\n            f\"{np.round(E_inf_e, 8):.8f}\",\n            f\"{np.round(E_end_e, 8):.8f}\",\n            str(int(osc_e)),\n            f\"{np.round(E_inf_c, 8):.8f}\",\n            f\"{np.round(E_end_c, 8):.8f}\",\n            str(int(osc_c)),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3212557"}, {"introduction": "Having witnessed the Runge phenomenon in its classic form, a natural question arises: is this phenomenon a rare fluke tied to the specific function $f(x)=\\frac{1}{1+25x^2}$, or is it a more general principle? This hands-on coding task [@problem_id:3188768] invites you to explore this question by investigating a family of functions, $f_\\alpha(x) = \\frac{1}{1+\\alpha x^2}$. By determining how the interpolation error behaves as you vary the parameter $\\alpha$, you will see that the Runge phenomenon is not an isolated curiosity but a predictable outcome for a whole class of functions, reinforcing the importance of node selection.", "problem": "You are asked to investigate Runge’s phenomenon in the context of polynomial interpolation on the interval $[-1,1]$ for the family of functions $f_{\\alpha}(x)=\\frac{1}{1+\\alpha x^2}$, where $\\alpha \\ge 0$ controls the curvature of the function near the endpoints. The goal is to demonstrate, through computation, that high-degree polynomial interpolation at equally spaced nodes can fail not only for the classical example $f(x)=\\frac{1}{1+25x^2}$ but across a range of $\\alpha$ values, and to contrast this with the behavior at Chebyshev nodes. The investigation must start from fundamental definitions of polynomial interpolation and the sup norm of the interpolation error and must avoid any pre-specified shortcut formulas.\n\nDefinitions and setup:\n- Let $n$ denote the polynomial degree. For a given $n$, define $n+1$ interpolation nodes $x_k$.\n- For equispaced nodes, set $x_k=-1+\\frac{2k}{n}$ for $k=0,1,\\dots,n$.\n- For Chebyshev nodes of the first kind on $[-1,1]$, set $x_k=\\cos\\left(\\frac{2k+1}{2(n+1)}\\pi\\right)$ for $k=0,1,\\dots,n$.\n- Given nodes $\\{x_k\\}_{k=0}^n$ and samples $y_k=f_{\\alpha}(x_k)$, let $p_{n,\\alpha}(x)$ denote the unique polynomial of degree at most $n$ that interpolates $f_{\\alpha}(x)$ at these nodes, meaning $p_{n,\\alpha}(x_k)=y_k$ for all $k$.\n- For a fixed $\\alpha$ and $n$, define the maximum absolute interpolation error on a dense grid $G$ of $1001$ points in $[-1,1]$ as $E_{n,\\alpha}=\\max_{x \\in G}\\left|p_{n,\\alpha}(x)-f_{\\alpha}(x)\\right|$, where $G=\\left\\{-1+\\frac{2j}{1000}\\mid j=0,1,\\dots,1000\\right\\}$.\n\nYour tasks:\n1. Threshold identification for equispaced nodes. For each $\\alpha$ in the set $\\{\\alpha_1,\\alpha_2,\\alpha_3,\\alpha_4,\\alpha_5,\\alpha_6\\}=\\{0,0.1,1,5,25,100\\}$ and for polynomial degrees in the set $S=\\{5,10,15,20,25,30,35,40\\}$, compute $E_{n,\\alpha}$ using equispaced nodes as defined above. Using the failure threshold $\\tau=0.05$, define, for each $\\alpha$, the smallest degree $n \\in S$ such that $E_{n,\\alpha}>\\tau$. If no degree in $S$ yields $E_{n,\\alpha}>\\tau$, report $-1$ for that $\\alpha$. This produces six integers corresponding to the six values of $\\alpha$ in the order given.\n2. Chebyshev comparison at high degree. For $\\alpha=25$ and $n=40$, compute $E_{n,\\alpha}^{\\mathrm{eq}}$ using equispaced nodes and $E_{n,\\alpha}^{\\mathrm{ch}}$ using Chebyshev nodes, both defined as in the setup. Determine whether Chebyshev nodes reduce the maximum error by at least a factor of $10$ relative to equispaced nodes, that is, whether $E_{n,\\alpha}^{\\mathrm{ch}}\\le \\frac{1}{10}E_{n,\\alpha}^{\\mathrm{eq}}$. Report a boolean for this single test case.\n\nGeneral requirements:\n- All computations are purely mathematical, with domain $[-1,1]$ and no physical units involved.\n- Angles used in trigonometric definitions must be in radians.\n- The final output must aggregate results from all test cases into a single line. The output format must be a comma-separated list enclosed in square brackets: specifically, the six integer thresholds from Task $1$ in the order of $\\alpha=\\{0,0.1,1,5,25,100\\}$, followed by the single boolean from Task $2$. For example, the final line should look like $[n_{\\alpha=0},n_{\\alpha=0.1},n_{\\alpha=1},n_{\\alpha=5},n_{\\alpha=25},n_{\\alpha=100},\\mathrm{bool}]$.\n\nTest suite summary:\n- Task $1$ tests interpolation failure thresholds across $\\alpha=\\{0,0.1,1,5,25,100\\}$ and degrees $S=\\{5,10,15,20,25,30,35,40\\}$, using the threshold $\\tau=0.05$ and grid size $1001$.\n- Task $2$ tests high-degree behavior at $n=40$ and $\\alpha=25$ comparing equispaced versus Chebyshev nodes.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets as specified above.", "solution": "The user requests an investigation of Runge's phenomenon for a family of functions, $f_{\\alpha}(x) = \\frac{1}{1+\\alpha x^2}$, by computing polynomial interpolation errors and comparing the performance of equispaced nodes versus Chebyshev nodes.\n\nThe problem is valid as it is scientifically grounded in the principles of numerical analysis, specifically polynomial interpolation theory. It is well-posed, with all necessary parameters and definitions provided for a unique, computable solution. The language is objective and the tasks are verifiable computational procedures.\n\nThe solution proceeds as follows:\nFirst, we establish the method for constructing and evaluating the interpolating polynomial. Given a set of $n+1$ distinct nodes $\\{x_k\\}_{k=0}^n$ and corresponding function values $\\{y_k = f_{\\alpha}(x_k)\\}_{k=0}^n$, there exists a unique interpolating polynomial $p_{n,\\alpha}(x)$ of degree at most $n$. While this can be expressed using the Lagrange basis, $p_{n,\\alpha}(x) = \\sum_{k=0}^n y_k L_k(x)$, direct evaluation is often inefficient and numerically unstable. A superior method for evaluation is the second barycentric interpolation formula:\n$$\np_{n,\\alpha}(x) = \\frac{\\sum_{k=0}^n \\frac{w_k}{x-x_k} y_k}{\\sum_{k=0}^n \\frac{w_k}{x-x_k}}\n$$\nThis formula holds for any $x$ that is not an interpolation node. If $x = x_j$ for some node $j$, the value of the polynomial is simply $y_j$. The barycentric weights, $w_k$, depend only on the set of nodes and are defined as:\n$$\nw_k = \\frac{1}{\\prod_{j=0, j \\neq k}^n (x_k - x_j)}\n$$\nAny constant multiple of these weights can also be used, as the formula is homogeneous in $w_k$.\n\nThe choice of interpolation nodes is critical. Runge's phenomenon describes the failure of convergence for high-degree polynomial interpolation, particularly when using equispaced nodes on a fixed interval for certain analytic functions. The error tends to grow unboundedly near the endpoints of the interval. Using nodes clustered near the endpoints, such as Chebyshev nodes, can mitigate or eliminate this phenomenon. The problem requires a comparison between these two node distributions:\n1.  **Equispaced nodes**: $x_k = -1 + \\frac{2k}{n}$ for $k=0, 1, \\dots, n$.\n2.  **Chebyshev nodes**: $x_k = \\cos\\left(\\frac{2k+1}{2(n+1)}\\pi\\right)$ for $k=0, 1, \\dots, n$.\n\nFor the algorithmic implementation, we will compute the barycentric weights for each set of nodes. For equispaced nodes, we will use the definitional product formula directly, as it is a fundamental definition. For Chebyshev nodes, a well-known simplified formula for the weights exists, which is both computationally efficient and numerically stable: $w_k = (-1)^k \\sin\\left(\\frac{2k+1}{2(n+1)}\\pi\\right)$, assuming the nodes are ordered in descending value, which they are by the given cosine definition.\n\nThe core of the algorithm involves a function that, for a given degree $n$, parameter $\\alpha$, and node type, performs the following steps:\n1.  Generate the $n+1$ interpolation nodes $\\{x_k\\}$.\n2.  Compute the corresponding function values $y_k = f_{\\alpha}(x_k)$.\n3.  Calculate the barycentric weights $\\{w_k\\}$.\n4.  Define the dense evaluation grid $G$ with $1001$ points from $-1$ to $1$.\n5.  Evaluate the interpolating polynomial $p_{n,\\alpha}(x)$ for each $x \\in G$ using the barycentric formula, carefully handling cases where $x$ is close to a node to ensure numerical stability.\n6.  Evaluate the true function $f_{\\alpha}(x)$ for each $x \\in G$.\n7.  Compute the maximum absolute error $E_{n,\\alpha} = \\max_{x \\in G} |p_{n,\\alpha}(x) - f_{\\alpha}(x)|$.\n\nThis error computation function is then applied to solve the two tasks specified:\n- **Task 1**: For each $\\alpha \\in \\{0, 0.1, 1, 5, 25, 100\\}$, we iterate through the degrees $n \\in \\{5, 10, \\dots, 40\\}$ using equispaced nodes. We find the smallest degree $n$ for which the error $E_{n,\\alpha}$ exceeds the threshold $\\tau=0.05$. If the error never exceeds the threshold for any $n$ in the set, we report $-1$. For $\\alpha=0$, the function is $f_0(x)=1$, a polynomial of degree $0$. The interpolation will be exact, yielding an error of $0$. Thus, the expected result for $\\alpha=0$ is $-1$.\n- **Task 2**: We fix $n=40$ and $\\alpha=25$ (the classic Runge function parameter). We compute the error for both equispaced nodes ($E_{40,25}^{\\mathrm{eq}}$) and Chebyshev nodes ($E_{40,25}^{\\mathrm{ch}}$). We then determine the boolean value of the condition $E_{40,25}^{\\mathrm{ch}} \\le \\frac{1}{10} E_{40,25}^{\\mathrm{eq}}$.\n\nThe final output is an aggregation of the results from these two tasks into a single formatted string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of investigating Runge's phenomenon by computing\n    interpolation errors for a family of functions.\n    \"\"\"\n    # Define parameters from the problem statement.\n    ALPHA_SET = [0.0, 0.1, 1.0, 5.0, 25.0, 100.0]\n    DEGREE_SET = [5, 10, 15, 20, 25, 30, 35, 40]\n    FAILURE_THRESHOLD = 0.05\n    EVAL_GRID_SIZE = 1001\n\n    eval_grid = np.linspace(-1.0, 1.0, EVAL_GRID_SIZE)\n\n    def f_alpha(x, alpha):\n        \"\"\"The function to be interpolated.\"\"\"\n        return 1.0 / (1.0 + alpha * x**2)\n\n    def get_nodes(n, node_type):\n        \"\"\"Generates interpolation nodes.\"\"\"\n        if node_type == 'equispaced':\n            return np.linspace(-1.0, 1.0, n + 1)\n        elif node_type == 'chebyshev':\n            k = np.arange(n + 1)\n            # Chebyshev nodes of the first kind (roots of T_{n+1})\n            # The formula provided orders them from largest to smallest.\n            return np.cos((2.0 * k + 1.0) * np.pi / (2.0 * (n + 1.0)))\n        else:\n            raise ValueError(\"Invalid node type specified.\")\n\n    def get_barycentric_weights(nodes, n, node_type):\n        \"\"\"Computes barycentric interpolation weights.\"\"\"\n        if node_type == 'equispaced':\n            # Use the fundamental definition: w_k = 1 / product(x_k - x_j) for j != k\n            weights = np.ones(n + 1, dtype=np.float64)\n            for k in range(n + 1):\n                diffs = nodes[k] - np.delete(nodes, k)\n                weights[k] = 1.0 / np.prod(diffs)\n            return weights\n        elif node_type == 'chebyshev':\n            # Use the simplified, well-known formula for Chebyshev nodes of the first kind,\n            # which is valid for a descending order of nodes.\n            k = np.arange(n + 1)\n            return ((-1.0)**k) * np.sin((2.0 * k + 1.0) * np.pi / (2.0 * (n + 1.0)))\n        else:\n            raise ValueError(\"Invalid node type specified.\")\n\n    def evaluate_barycentric(eval_points, nodes, y_values, weights):\n        \"\"\"Evaluates the interpolating polynomial using the barycentric formula.\"\"\"\n        p_eval = np.zeros_like(eval_points, dtype=np.float64)\n        for i, x in enumerate(eval_points):\n            # If x is very close to a node, use the node's y-value to avoid\n            # numerical instability from division by a very small number.\n            close_node_indices = np.where(np.isclose(x, nodes))\n            if close_node_indices[0].size > 0:\n                p_eval[i] = y_values[close_node_indices[0][0]]\n                continue\n\n            # If x is not a node, use the standard barycentric formula.\n            terms = weights / (x - nodes)\n            p_eval[i] = np.sum(terms * y_values) / np.sum(terms)\n        return p_eval\n\n    def compute_interpolation_error(n, alpha, node_type, grid):\n        \"\"\"Computes the maximum absolute interpolation error on a grid.\"\"\"\n        nodes = get_nodes(n, node_type)\n        y_values = f_alpha(nodes, alpha)\n        weights = get_barycentric_weights(nodes, n, node_type)\n        \n        p_eval = evaluate_barycentric(grid, nodes, y_values, weights)\n        f_eval = f_alpha(grid, alpha)\n        \n        error = np.max(np.abs(p_eval - f_eval))\n        return error\n\n    # --- Task 1: Threshold identification for equispaced nodes ---\n    task1_results = []\n    for alpha in ALPHA_SET:\n        failure_degree = -1\n        for n in DEGREE_SET:\n            error = compute_interpolation_error(n, alpha, 'equispaced', eval_grid)\n            if error > FAILURE_THRESHOLD:\n                failure_degree = n\n                break\n        task1_results.append(failure_degree)\n\n    # --- Task 2: Chebyshev comparison at high degree ---\n    n_task2 = 40\n    alpha_task2 = 25.0\n    err_eq = compute_interpolation_error(n_task2, alpha_task2, 'equispaced', eval_grid)\n    err_ch = compute_interpolation_error(n_task2, alpha_task2, 'chebyshev', eval_grid)\n    task2_result = err_ch <= (1.0 / 10.0) * err_eq\n\n    # --- Aggregate results and print ---\n    results = task1_results + [task2_result]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3188768"}]}