{"hands_on_practices": [{"introduction": "Understanding B-splines begins with their recursive definition. This first practice challenges you to build a B-spline curve evaluator from the ground up, starting with the fundamental Cox-de Boor recursion for basis functions [@problem_id:3207506]. By implementing this, you will gain a firsthand appreciation for how the choice of knot vector dictates the curve's behavior, specifically how a 'clamped' knot vector guarantees the curve passes directly through its first and last control points.", "problem": "You are asked to write a complete, runnable program that constructs and evaluates a Basis spline (B-spline) curve in a way that is guaranteed to interpolate its first and last control points. Your design must begin from the core recursive definition of B-spline basis functions and proceed to an algorithmic implementation that respects numerical stability and correctness.\n\nStart from the following fundamental base: the Cox–de Boor recursive definition of B-spline basis functions. For a given nondecreasing knot vector $\\{t_0, t_1, \\dots, t_m\\}$ and degree $p \\ge 0$, the basis functions $N_{i,p}(u)$ are defined recursively by\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1 & \\text{if } t_i \\le u < t_{i+1} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nand for $p \\ge 1$,\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\nwith the convention that terms with zero denominators are treated as zero. The parametric curve is then given by\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\nwhere $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ are the control points. When the knot vector is clamped (also called open), meaning the first and last knots are each repeated $p+1$ times, the curve is guaranteed to interpolate the first and last control points at the ends of the parametric domain. Your task is to implement an evaluation algorithm that uses these definitions and to demonstrate, through a test suite, that your curve passes exactly through its first and last control points.\n\nRequirements:\n- Implement B-spline curve evaluation based on the above recursive basis definition, using a numerically stable approach appropriate for advanced undergraduate numerical methods. You must ensure endpoint interpolation by using clamped knot vectors with multiplicity $p+1$ at both ends.\n- The domain of evaluation must be $[t_p, t_{m-p}]$. At $u = t_p$ and $u = t_{m-p}$, the curve must return $\\mathbf{P}_0$ and $\\mathbf{P}_n$, respectively.\n- Use Euclidean distance to compare vector equality up to a tolerance of $10^{-9}$, with zero relative tolerance. If the norm difference is less than or equal to $10^{-9}$, treat the values as equal.\n\nTest suite and parameters:\nFor each test case below, evaluate the curve at the left endpoint $u = t_p$ and the right endpoint $u = t_{m-p}$, and check whether these points match the first and last control points within the tolerance. Your program should produce one boolean per test case indicating whether both endpoint checks passed.\n\nLet each control point $\\mathbf{P}_i$ be a coordinate vector in either two dimensions or three dimensions as specified. The knot vectors are either explicitly given or must be constructed as clamped open-uniform knot vectors. An open-uniform clamped knot vector of length $m+1 = n + p + 2$ has the first $p+1$ entries equal to $0$, the last $p+1$ entries equal to $1$, and the interior knots evenly spaced in $(0,1)$.\n\n- Test case 1 (happy path, two dimensions, quadratic clamped open-uniform):\n  - Degree $p = 2$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=4$, $p=2$.\n- Test case 2 (boundary case with minimal interior knots, cubic clamped open-uniform, Bezier-like):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=3$, $p=3$.\n- Test case 3 (non-uniform clamped, two dimensions):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$.\n  - Explicit clamped non-uniform knot vector: $\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$.\n- Test case 4 (edge case, linear clamped open-uniform):\n  - Degree $p = 1$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=2$, $p=1$.\n- Test case 5 (three dimensions, cubic clamped open-uniform):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$.\n  - Construct a clamped open-uniform knot vector for $n=5$, $p=3$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $\\texttt{[true,false,true]}$. Use lowercase Python boolean formatting. The list must contain one boolean per test case, in the order listed above.", "solution": "The problem requires the implementation and verification of B-spline curve evaluation, demonstrating the endpoint interpolation property for clamped knot vectors. The solution is derived directly from the fundamental recursive definition of B-spline basis functions provided in the problem statement.\n\nA B-spline curve $\\mathbf{C}(u)$ of degree $p$ is a parametric curve defined as a weighted sum of $n+1$ control points $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$:\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\nThe weights are the B-spline basis functions $N_{i,p}(u)$, which are piecewise polynomials of degree $p$. Their definition depends on a non-decreasing sequence of real numbers $T = \\{t_0, t_1, \\dots, t_m\\}$ called the knot vector, where the relation $m = n+p+1$ must hold. The basis functions are defined by the Cox–de Boor recursion formula.\n\nFor $p=0$:\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1, & \\text{if } t_i \\le u < t_{i+1} \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\nThis definition implies that for any interval of zero length, where $t_i = t_{i+1}$, the basis function $N_{i,0}(u)$ is always $0$. A special consideration is required for the parameter value $u$ at the very end of the domain. If the curve domain is $[t_p, t_{n+1}]$, then for $u = t_{n+1}$, the relevant non-zero degree-$0$ basis function is taken to be $N_{n,0}(t_{n+1})=1$.\n\nFor $p \\ge 1$:\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\nThe problem specifies that if a denominator in this expression is zero, the corresponding term is treated as zero.\n\nThe core of the task is to implement an algorithm for $\\mathbf{C}(u)$ based on these definitions and verify that for a clamped knot vector, $\\mathbf{C}(t_p) = \\mathbf{P}_0$ and $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$. A clamped knot vector has its first $p+1$ knots equal and its last $p+1$ knots equal. This structure ensures that $N_{0,p}(t_p)=1$ and $N_{n,p}(t_{n+1})=1$, while all other basis functions $N_{i,p}$ are zero at the respective endpoints, leading to interpolation.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  **Parameter Setup**: The degree $p$ and the set of $n+1$ control points $\\{\\mathbf{P}_i\\}$ are defined.\n2.  **Knot Vector Construction**: The knot vector $T$ is constructed. For cases requiring a clamped open-uniform knot vector, the first $p+1$ knots are set to $0$, the last $p+1$ knots are set to $1$, and the $n-p$ interior knots are spaced uniformly in the interval $(0,1)$. The number of knots is $m+1 = n+p+2$.\n3.  **Curve Evaluation at Endpoints**:\n    *   The curve is evaluated at the left endpoint of its domain, $u_{left} = t_p$.\n    *   The curve is evaluated at the right endpoint of its domain, $u_{right} = t_{n+1}$.\n    *   The evaluation itself, $\\mathbf{C}(u)$, is performed by a function that calculates $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$.\n4.  **Basis Function Calculation**: The value of each basis function $N_{i,p}(u)$ is calculated using a recursive function that directly implements the Cox-de Boor formula. To ensure computational feasibility, this recursive function is memoized (a form of dynamic programming), preventing redundant calculations of the same basis function values. The implementation of the base case $N_{i,0}(u)$ must carefully handle the half-open interval and the special case at the domain's right endpoint.\n5.  **Verification**: The computed point $\\mathbf{C}(u_{left})$ is compared to the first control point $\\mathbf{P}_0$, and $\\mathbf{C}(u_{right})$ is compared to the last control point $\\mathbf{P}_n$. The comparison is done by calculating the Euclidean distance between the vectors. If the distance is within the specified tolerance of $10^{-9}$ for both endpoints, the test case is considered passed.\n\nThe implementation encapsulates these steps. A main function iterates through the test suite, calling helper functions to construct knot vectors and evaluate the B-spline curve. The evaluation function `b_spline_eval` uses a nested helper function `_basis_function` to compute the basis functions recursively. This nested structure allows the recursive function to be clean while having access to the parameter $u$, the knot vector $T$, and the memoization dictionary, avoiding the use of global state. The result of each test case (a boolean value) is collected and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots > 0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] <= u < T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val > 1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left <= tolerance\n        check_right = dist_right <= tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3207506"}, {"introduction": "One of the most powerful features of B-splines is the ability to exert fine-grained local control over the curve's shape. This practice moves beyond the basic setup to explore the profound effect of knot multiplicity [@problem_id:3099558]. You will conduct a numerical experiment to quantitatively measure how inserting a knot multiple times at the same location reduces the curve's continuity, allowing you to introduce sharp corners or other distinct features without altering the entire curve.", "problem": "You will investigate how increasing knot multiplicity in a cubic B-spline affects local shape, including possible overshoot relative to a baseline curve and the creation of corners or flat spots. Work entirely in a purely mathematical setting with two-dimensional control points and standard B-spline definitions. Your program must be a complete, runnable implementation that evaluates curves and their derivatives from first principles, and computes quantitative metrics for a small test suite.\n\nFundamental base and definitions:\n- A B-spline curve of degree $p$ with control points $\\{\\mathbf{P}_i\\}_{i=0}^{N-1}$ and nondecreasing knot vector $\\{t_j\\}_{j=0}^{N+p}$ is defined as\n$$\n\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i,\n$$\nwhere $N_{i,p}(t)$ are B-spline basis functions defined by the Cox–de Boor recursion:\n$$\nN_{i,0}(t) =\n\\begin{cases}\n1 & \\text{if } t_i \\le t < t_{i+1},\\\\\n0 & \\text{otherwise},\n\\end{cases}\n$$\nand for $p \\ge 1$\n$$\nN_{i,p}(t) = \\frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\nwith the convention that terms with zero denominators contribute $0$.\n- The derivative of the curve uses the derivatives of basis functions:\n$$\n\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i,\n$$\nwhere\n$$\n\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\nagain interpreting divisions by zero as contributing $0$.\n- For a knot of multiplicity $m$ in a degree-$p$ B-spline, the curve continuity at that knot is $C^{p-m}$, meaning that the first $p-m$ derivatives are continuous while the $(p-m+1)$-st derivative generally has a jump. In particular, if $m = p+1$, the curve has a break (no positional continuity) at that knot.\n\nScenario and modeling setup:\n- Use degree $p = 3$ (cubic) and $N = 8$ control points in $\\mathbb{R}^2$.\n- Use an open knot vector with repeated endpoints:\n$$\n\\underbrace{0,0,0,0}_{p+1\\text{ times}}, \\text{interior knots}, \\underbrace{1,1,1,1}_{p+1\\text{ times}}.\n$$\n- Let the interior knot location of interest be $u_0 = 0.5$. The total number of interior knot entries is $N - p - 1 = 4$. For a chosen multiplicity $m \\in \\{1,2,3,4\\}$ at $u_0$, construct the interior knot multiset as follows. Include $m$ copies of $u_0$ and use the remaining $4 - m$ entries from the fixed list $\\{0.25,\\,0.33,\\,0.75\\}$, taking the smallest $4-m$ elements from this list and then sorting all interior entries. This produces exactly four interior knot entries for every $m$.\n- Define two scenarios of control points:\n  - Scenario A (hump-like):\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 1.0)$,\n    - $\\mathbf{P}_2=(2.0, 2.0)$,\n    - $\\mathbf{P}_3=(3.0, 4.0)$,\n    - $\\mathbf{P}_4=(4.0, 2.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.5)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 1.1)$.\n  - Scenario B (locally flat region):\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 0.5)$,\n    - $\\mathbf{P}_2=(2.0, 1.0)$,\n    - $\\mathbf{P}_3=(3.0, 1.0)$,\n    - $\\mathbf{P}_4=(4.0, 1.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.0)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 2.0)$.\n\nQuantities to compute:\n- Define the baseline curve to be the cubic B-spline with multiplicity $m=1$ at $u_0=0.5$, using the interior-knot construction above. Denote this baseline as $\\mathbf{C}_{\\mathrm{base}}(t)$.\n- For each scenario and for each $m \\in \\{1,2,3,4\\}$, construct the corresponding knot vector and compute:\n  1. The maximum absolute deviation from the baseline on a uniform sample of parameter values:\n     $$\n     D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2.\n     $$\n     Use the Euclidean norm. Let the sample $\\mathcal{T}$ be $4001$ equally spaced points in the open interval $(0,1)$, for instance $t_k$ linearly spaced from $10^{-6}$ to $1-10^{-6}$ to avoid evaluating exactly at knots.\n  2. A numerical measure of the slope discontinuity at the interior knot $u_0$:\n     $$\n     J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2.\n     $$\n     To evaluate one-sided derivatives without hitting the knot exactly, choose\n     $$\n     \\delta = \\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right),\n     $$\n     where $u_\\text{L}$ is the largest knot strictly less than $u_0$, and $u_\\text{R}$ is the smallest knot strictly greater than $u_0$ in the constructed knot vector. Then approximate the one-sided derivatives by evaluating $\\mathbf{C}_m'(u_0 - \\delta)$ and $\\mathbf{C}_m'(u_0 + \\delta)$ using the basis-derivative formula above. The Euclidean norm of their difference is $J(m)$.\n\nTest suite and required output:\n- Use both Scenario A and Scenario B control points.\n- For each scenario, evaluate the pair $\\left(D_{\\max}(m), J(m)\\right)$ for $m = 1, 2, 3, 4$.\n- Round each reported floating-point result to six decimal places.\n- Your program should produce a single line of output containing all results for both scenarios as a comma-separated list enclosed in square brackets. The ordering must be:\n  - Scenario A: $D_{\\max}(1)$, $J(1)$, $D_{\\max}(2)$, $J(2)$, $D_{\\max}(3)$, $J(3)$, $D_{\\max}(4)$, $J(4)$,\n  - followed by Scenario B in the same order.\nThat is, the output format is\n$$\n[\\;D_{\\max}^{A}(1),J^{A}(1),D_{\\max}^{A}(2),J^{A}(2),D_{\\max}^{A}(3),J^{A}(3),D_{\\max}^{A}(4),J^{A}(4),D_{\\max}^{B}(1),J^{B}(1),D_{\\max}^{B}(2),J^{B}(2),D_{\\max}^{B}(3),J^{B}(3),D_{\\max}^{B}(4),J^{B}(4)\\;].\n$$\nNo units are required because all quantities are dimensionless.", "solution": "The user has provided a well-defined computational problem concerning the properties of B-spline curves. I will first validate the problem statement and then provide a comprehensive solution based on fundamental principles.\n\n### Problem Validation\n\n1.  **Extraction of Givens**:\n    - **Curve Type**: B-spline curve of degree $p=3$ with $N=8$ control points in $\\mathbb{R}^2$.\n    - **Curve Definition**: $\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i$, with basis functions $N_{i,p}(t)$ defined by the Cox–de Boor recursion.\n    - **Curve Derivative**: $\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i$, with $\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$.\n    - **Knot Vector**: Open knot vector with $p+1=4$ knots at $0$ and $4$ knots at $1$. It contains $N-p-1=4$ interior knots.\n    - **Interior Knot Construction**: For a multiplicity $m \\in \\{1,2,3,4\\}$ at $u_0 = 0.5$, the four interior knots are formed by $m$ copies of $0.5$ and the $4-m$ smallest values from the set $\\{0.25, 0.33, 0.75\\}$, sorted.\n    - **Control Point Scenarios**: Two sets of control points, Scenario A (hump-like) and Scenario B (locally flat region), are provided.\n    - **Metrics**:\n        1.  $D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2$, where $\\mathbf{C}_{\\mathrm{base}}$ is the curve for $m=1$. Evaluation grid $\\mathcal{T}$ has $4001$ points in $(0,1)$.\n        2.  $J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2$, with one-sided derivatives approximated at $u_0 \\pm \\delta$. $\\delta$ is defined as $\\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right)$.\n    - **Output Format**: A single line containing a comma-separated list of $16$ floating-point values rounded to six decimal places, representing $(D_{\\max}(m), J(m))$ for $m \\in \\{1,2,3,4\\}$ for each of the two scenarios.\n\n2.  **Validation against Criteria**:\n    - **Scientifically Grounded**: The problem is rooted in the standard mathematical theory of B-splines, a core topic in computational science and computer-aided geometric design. All definitions and formulas are correct.\n    - **Well-Posed**: The problem is specified with a high degree of precision. All parameters, data, construction rules, and formulas for the quantities to be computed are explicitly given. The setup is self-contained and sufficient to produce a unique, deterministic solution.\n    - **Objective**: The problem statement is entirely objective, using precise mathematical language and quantitative definitions. There are no subjective or ambiguous elements.\n    - **Other criteria**: The problem is not trivial, as it requires a correct from-first-principles implementation of a non-trivial algorithm. It is not contradictory, unrealistic, or ill-posed.\n\n3.  **Verdict and Action**:\n    The problem statement is **valid**. I will proceed with formulating and implementing a solution.\n\n### Solution Design\n\nThe solution requires implementing B-spline curve evaluation and its derivative from the provided fundamental definitions. A direct recursive implementation of the Cox-de Boor formula is computationally inefficient. A more robust and performant approach, based on algorithms from standard literature (e.g., \"The NURBS Book\" by Piegl and Tiller), will be used. This adheres to the \"from first principles\" requirement as the algorithms are direct implementations of the mathematical definitions.\n\n1.  **Core Algorithms**:\n    - **Knot Span Search**: A function `find_span` will be implemented to efficiently locate the knot interval (span) containing a given parameter value $t$. This is a prerequisite for efficient basis function evaluation and is typically implemented using binary search.\n    - **Basis Function Evaluation**: A function `basis_funs` will implement an iterative, dynamic programming approach (Algorithm A2.2 from The NURBS Book) to calculate the values of all non-zero basis functions of a given degree for a parameter $t$ within its knot span. This is significantly more efficient than a naive recursive approach.\n    - **Curve Evaluation**: The function `evaluate_bspline` will combine `find_span` and `basis_funs` to compute a point on the curve $\\mathbf{C}(t)$. It finds the relevant knot span, computes the non-zero basis functions, and then takes their weighted sum with the corresponding control points.\n    - **Curve Derivative Evaluation**: The function `evaluate_bspline_derivative` will compute $\\mathbf{C}'(t)$ by directly implementing the sum $\\sum_i \\frac{d N_{i,p}(t)}{dt} \\mathbf{P}_i$. The derivatives of the basis functions, $\\frac{d N_{i,p}(t)}{dt}$, will be calculated using the provided formula, which in turn requires basis functions of degree $p-1$. These will be efficiently computed using the same `basis_funs` algorithm.\n\n2.  **Workflow for a Single Case ($m$, Scenario)**:\n    - **Knot Vector Construction**: The full knot vector of length $N+p+1=12$ is constructed by concatenating the starting repeated knots ($p+1$ zeros), the four specified interior knots, and the ending repeated knots ($p+1$ ones).\n    - **Curve Evaluation for $D_{\\max}$**: For each $m$, the curve $\\mathbf{C}_m(t)$ is evaluated at $4001$ sample points in $(0,1)$. For $m=1$, these points define the baseline curve $\\mathbf{C}_{\\mathrm{base}}$. For $m>1$, the Euclidean distance to the corresponding baseline points is computed, and the maximum of these distances gives $D_{\\max}(m)$. By definition, $D_{\\max}(1)=0$.\n    - **Derivative Jump Calculation for $J(m)$**: The small offset $\\delta$ is determined according to the problem's rule. The derivative $\\mathbf{C}_m'(t)$ is evaluated at $u_0 - \\delta$ and $u_0 + \\delta$. The Euclidean norm of the difference between these two derivative vectors gives the jump $J(m)$. The continuity properties of B-splines suggest that $J(1)$ and $J(2)$ should be near zero, while $J(3)$ and $J(4)$ may be significantly non-zero, providing a good sanity check for the implementation.\n\n3.  **Overall Structure**:\n    The main program will iterate through the two control point scenarios. Within each scenario, it will iterate through multiplicities $m$ from $1$ to $4$. In each sub-case, it will construct the appropriate knot vector, compute the pair $(D_{\\max}(m), J(m))$, and store the results. Finally, all $16$ scalar results will be formatted into a single string as required.", "answer": "```python\nimport numpy as np\n\ndef find_span(num_cp, degree, t, knots):\n    \"\"\"\n    Finds the knot span index for a given parameter t.\n    num_cp: number of control points (N).\n    degree: degree of the curve (p).\n    t: parameter value.\n    knots: knot vector.\n    Returns the index k such that knots[k] <= t < knots[k+1].\n    \"\"\"\n    # For t=1.0, which can occur at the end of the domain for an open knot vector.\n    # The valid parameter range is [knots[p], knots[N]]. For an open knot vector,\n    # this is [0, 1]. The last span index is N-1.\n    if t >= knots[num_cp]:\n        return num_cp - 1\n    \n    # Binary search for the span. The search space is [p, N-1].\n    low = degree\n    high = num_cp\n    \n    while low < high:\n        mid = (low + high) // 2\n        if t < knots[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    return low - 1\n\ndef basis_funs(span, t, degree, knots):\n    \"\"\"\n    Computes the non-zero B-spline basis functions for a given parameter t.\n    (Algorithm A2.2 from The NURBS Book by Piegl and Tiller).\n    span: knot span index.\n    t: parameter value.\n    degree: degree of the curve.\n    knots: knot vector.\n    Returns an array of p+1 basis function values, N_{span-degree, degree}, ..., N_{span, degree}.\n    \"\"\"\n    basis = np.zeros(degree + 1)\n    left = np.zeros(degree + 1)\n    right = np.zeros(degree + 1)\n    \n    basis[0] = 1.0\n    for j in range(1, degree + 1):\n        left[j] = t - knots[span + 1 - j]\n        right[j] = knots[span + j] - t\n        saved = 0.0\n        for r in range(j):\n            den = knots[span + r + 1] - knots[span + r + 1 - j]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = basis[r] / den\n            basis[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        basis[j] = saved\n    return basis\n\ndef evaluate_bspline(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates a B-spline curve at a given parameter t.\n    \"\"\"\n    if t < knots[degree] or t > knots[num_cp]:\n        if t <= knots[degree]: return control_points[0]\n        else: return control_points[-1]\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values = basis_funs(span, t, degree, knots)\n    \n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(degree + 1):\n        curve_point += basis_values[i] * control_points[span - degree + i]\n    return curve_point\n\ndef evaluate_bspline_derivative(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates the derivative of a B-spline curve at a given parameter t.\n    \"\"\"\n    if t < knots[degree] or t > knots[num_cp]:\n        return np.zeros_like(control_points[0], dtype=float)\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values_p_minus_1 = basis_funs(span, t, degree - 1, knots)\n    \n    deriv_point = np.zeros_like(control_points[0], dtype=float)\n    \n    for i in range(span - degree, span + 1):\n        # Contribution from control point P_i\n        # dN_{i,p}/dt = p/(t_{i+p}-t_i) * N_{i,p-1} - p/(t_{i+p+1}-t_{i+1}) * N_{i+1,p-1}\n        \n        # Term 1: involving N_{i, p-1}\n        num1 = 0.0\n        # The non-zero basis functions of degree p-1 for span k are N_{k-(p-1),p-1} to N_{k,p-1}\n        # In our case, span=span, degree=p-1. So N_{span-(p-1),p-1} to N_{span,p-1}.\n        if (span - (degree - 1)) <= i <= span:\n            num1 = basis_values_p_minus_1[i - (span - (degree - 1))]\n        \n        den1 = knots[i + degree] - knots[i]\n        term1 = 0.0\n        if den1 != 0.0:\n            term1 = degree * num1 / den1\n\n        # Term 2: involving N_{i+1, p-1}\n        num2 = 0.0\n        if (span - (degree - 1)) <= (i + 1) <= span:\n            num2 = basis_values_p_minus_1[i + 1 - (span - (degree - 1))]\n\n        den2 = knots[i + degree + 1] - knots[i + 1]\n        term2 = 0.0\n        if den2 != 0.0:\n            term2 = degree * num2 / den2\n        \n        d_basis = term1 - term2\n        deriv_point += d_basis * control_points[i]\n        \n    return deriv_point\n\n\ndef solve():\n    p = 3\n    N = 8\n    u0 = 0.5\n    \n    P_A = np.array([\n        [0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 4.0],\n        [4.0, 2.0], [5.0, 1.5], [6.0, 1.2], [7.0, 1.1]\n    ], dtype=float)\n    \n    P_B = np.array([\n        [0.0, 0.0], [1.0, 0.5], [2.0, 1.0], [3.0, 1.0],\n        [4.0, 1.0], [5.0, 1.0], [6.0, 1.2], [7.0, 2.0]\n    ], dtype=float)\n\n    scenarios = [(\"A\", P_A), (\"B\", P_B)]\n    interior_knot_pool = [0.25, 0.33, 0.75]\n    \n    t_samples = np.linspace(1e-6, 1.0 - 1e-6, 4001)\n    \n    all_results = []\n    \n    for _, P in scenarios:\n        C_base_pts = None\n        \n        for m in range(1, 5):\n            # 1. Construct knot vector\n            num_other_knots = 4 - m\n            interior_knots = sorted(interior_knot_pool[:num_other_knots] + [u0] * m)\n            knots = np.concatenate((np.zeros(p + 1, dtype=float), np.array(interior_knots, dtype=float), np.ones(p + 1, dtype=float)))\n\n            # 2. Compute curve points for D_max calculation\n            C_m_pts = np.array([evaluate_bspline(t, N, p, knots, P) for t in t_samples])\n            \n            if m == 1:\n                C_base_pts = C_m_pts\n                D_max = 0.0\n            else:\n                deviations = np.linalg.norm(C_m_pts - C_base_pts, axis=1)\n                D_max = np.max(deviations)\n\n            # 3. Compute slope discontinuity J(m)\n            unique_knots = sorted(list(set(knots)))\n            u_L_idx = np.searchsorted(unique_knots, u0, side='left') - 1\n            u_R_idx = np.searchsorted(unique_knots, u0, side='right')\n            u_L = unique_knots[u_L_idx] if u_L_idx >= 0 else knots[0]\n            u_R = unique_knots[u_R_idx] if u_R_idx < len(unique_knots) else knots[-1]\n            \n            term_L = 0.1 * (u0 - u_L) if u_L < u0 else np.inf\n            term_R = 0.1 * (u_R - u0) if u_R > u0 else np.inf\n            delta = min(term_L, term_R, 1e-3)\n            \n            dC_left = evaluate_bspline_derivative(u0 - delta, N, p, knots, P)\n            dC_right = evaluate_bspline_derivative(u0 + delta, N, p, knots, P)\n            J_m = np.linalg.norm(dC_right - dC_left)\n            \n            all_results.extend([D_max, J_m])\n            \n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```", "id": "3099558"}, {"introduction": "Having mastered the construction and local manipulation of B-splines, we turn to a classic and practical application: finding the closest point on a curve to an external point. This 'point projection' problem is fundamental in fields like computer-aided design and robotics, and it requires combining your B-spline knowledge with numerical optimization techniques [@problem_id:3207471]. In this capstone practice, you will implement a robust, safeguarded Newton's method to solve this nonlinear problem, leveraging the B-spline's derivatives to efficiently find the solution.", "problem": "Design and implement a complete and numerically stable program that, for a given planar B-spline curve and a set of external points, computes the closest point on the curve to each external point using a safeguarded Newton–Raphson method. The curve is defined by a degree, a nondecreasing knot vector, and a sequence of control points. Your implementation must be self-contained and must not read any input.\n\nYou must start from the following fundamental definitions and facts.\n\n1. A B-spline curve of degree $p$ with control points $\\{\\mathbf{P}_i\\}_{i=0}^n \\subset \\mathbb{R}^2$ and nondecreasing knot vector $\\{U_j\\}_{j=0}^m$ is given by the linear combination of B-spline basis functions $\\{N_{i,p}(u)\\}_{i=0}^n$ over the parameter domain $u \\in [U_p, U_{m-p}]$, namely $\\mathbf{C}(u) = \\sum_{i=0}^n N_{i,p}(u)\\,\\mathbf{P}_i$. The Cox–de Boor recursion defines $N_{i,0}(u)$ by $N_{i,0}(u) = 1$ if $U_i \\le u < U_{i+1}$ and $0$ otherwise, and for $p \\ge 1$, $N_{i,p}(u) = \\alpha_{i,p}(u)\\,N_{i,p-1}(u) + \\beta_{i+1,p}(u)\\,N_{i+1,p-1}(u)$ with coefficients $\\alpha_{i,p}(u) = \\dfrac{u - U_i}{U_{i+p} - U_i}$ (interpreted as $0$ when the denominator is $0$) and $\\beta_{i+1,p}(u) = \\dfrac{U_{i+p+1} - u}{U_{i+p+1} - U_{i+1}}$ (interpreted as $0$ when the denominator is $0$). The de Boor algorithm is a numerically stable evaluation of $\\mathbf{C}(u)$ that is algebraically equivalent to the above recursion.\n2. The Euclidean squared distance from a point on the curve to a fixed point $\\mathbf{q} \\in \\mathbb{R}^2$ is $d^2(u) = \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2$. Minimizing $\\tfrac{1}{2} d^2(u)$ over the closed interval $[U_p, U_{m-p}]$ yields the closest point(s). You must derive from first principles the first and second derivatives with respect to $u$ of $\\tfrac{1}{2} d^2(u)$, expressed in terms of $\\mathbf{C}(u)$, $\\mathbf{C}'(u)$, and $\\mathbf{C}''(u)$, and use these derivatives in a Newton–Raphson iteration. Do not assume any derivative formulas without justification from the definition of differentiation and the chain rule.\n\nYour algorithmic design requirements are as follows.\n\n- Use the de Boor algorithm to evaluate $\\mathbf{C}(u)$ and construct derivative control polygons to evaluate $\\mathbf{C}'(u)$ and $\\mathbf{C}''(u)$ reliably. For derivative control polygons, use the well-tested finite-difference relations between successive control points and the knot vector; do not differentiate basis functions symbolically in code.\n- Implement a safeguarded Newton–Raphson method on the scalar function you obtain by differentiating $\\tfrac{1}{2} d^2(u)$. Your method must include all of the following numerical safeguards: \n  1. Parameter domain projection that keeps iterates within the closed interval $[U_p, U_{m-p}]$.\n  2. Bracketing of roots by scanning a uniform grid of $M$ sample parameters across the domain to detect sign changes of the first derivative, followed by a safeguarded Newton step inside each bracket that reverts to bisection when a Newton step exits the bracket or when the curvature information is unreliable.\n  3. A damped or backtracking step size strategy when running an unbracketed projected Newton refinement from promising seeds, to prevent increase of $\\tfrac{1}{2} d^2(u)$.\n  4. Selection of the global minimizer by evaluating the squared distance at all stationary candidates returned by the root-finding stage along with the two boundary parameters $U_p$ and $U_{m-p}$.\n\nTesting and output specification.\n\n- Use the following test curve data (all coordinates and knots are unitless):\n  - Degree $p = 3$.\n  - Control points $\\mathbf{P}_0 = (0,0)$, $\\mathbf{P}_1 = (1,2)$, $\\mathbf{P}_2 = (3,3)$, $\\mathbf{P}_3 = (6,2)$, $\\mathbf{P}_4 = (7,0)$, $\\mathbf{P}_5 = (8,-1)$.\n  - Open uniform knot vector $U = [0,0,0,0,\\tfrac{1}{3},\\tfrac{2}{3},1,1,1,1]$.\n  - Therefore, the parameter domain is $[0,1]$.\n- Use the following set of external query points $\\mathbf{q}$ to form your test suite:\n  1. $\\mathbf{q}_1 = (4,1.5)$, a general position point.\n  2. $\\mathbf{q}_2 = (0,0)$, exactly at the left endpoint of the curve.\n  3. $\\mathbf{q}_3 = (10,-2)$, far to the right of the curve.\n  4. $\\mathbf{q}_4 = (2.5,2.5)$, near the interior of the curve.\n  5. $\\mathbf{q}_5 = (6.8,-0.8)$, near the right portion of the curve.\n- Implementation details:\n  - Use double-precision floating-point arithmetic.\n  - Use a uniform grid of $M = 200$ samples for initial bracketing.\n  - Use a convergence tolerance of $\\varepsilon = 10^{-10}$ on the absolute value of the first derivative in Newton–Raphson and a parameter tolerance of $\\delta = 10^{-12}$ for bracketing shrinkage. Limit the maximum number of safeguarded iterations per root to $50$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain one entry for each test point, in the same order, where each entry is a two-element list $[u^\\star, d]$. Here $u^\\star$ is the minimizing parameter in $[0,1]$, and $d$ is the Euclidean distance from the external point to the closest point on the curve. Both entries must be floating-point numbers. For example, the output format should look like $[[u_1,d_1],[u_2,d_2],[u_3,d_3],[u_4,d_4],[u_5,d_5]]$ with no spaces.", "solution": "The posed problem is to determine, for a given planar B-spline curve and a set of query points, the parameter $u^\\star$ on the curve that corresponds to the point $\\mathbf{C}(u^\\star)$ closest to each query point. This is a classical nonlinear optimization problem in computational geometry.\n\nThe problem is first validated against the specified criteria.\n\n### Step 1: Extract Givens\n- **Curve Definition**: A B-spline curve of degree $p$ is defined as $\\mathbf{C}(u) = \\sum_{i=0}^n N_{i,p}(u)\\,\\mathbf{P}_i$ for a parameter $u \\in [U_p, U_{m-p}]$, with control points $\\{\\mathbf{P}_i\\}_{i=0}^n \\subset \\mathbb{R}^2$ and a nondecreasing knot vector $\\{U_j\\}_{j=0}^m$. The relation $m=n+p+1$ holds.\n- **Basis Functions**: The basis functions $N_{i,p}(u)$ are defined by the Cox–de Boor recursion.\n- **Evaluation**: The de Boor algorithm is specified for numerically stable evaluation of $\\mathbf{C}(u)$.\n- **Objective Function**: The quantity to minimize is the squared Euclidean distance $d^2(u) = \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2$ from a point on the curve to a fixed external point $\\mathbf{q}$, or equivalently, $f(u) = \\tfrac{1}{2} d^2(u)$.\n- **Derivatives**: The first and second derivatives of $f(u)$ must be derived from first principles and used in a Newton–Raphson method. Curve derivatives $\\mathbf{C}'(u)$ and $\\mathbf{C}''(u)$ are to be computed via derivative control polygons.\n- **Algorithm**: A safeguarded Newton–Raphson method is required, incorporating: $1$) domain projection, $2$) root bracketing with reversion to bisection, $3$) damped/backtracking steps for unbracketed refinement, and $4$) global minimum selection from stationary points and boundaries.\n- **Test Data**:\n  - Degree: $p = 3$.\n  - Control Points: $\\mathbf{P}_0 = (0,0)$, $\\mathbf{P}_1 = (1,2)$, $\\mathbf{P}_2 = (3,3)$, $\\mathbf{P}_3 = (6,2)$, $\\mathbf{P}_4 = (7,0)$, $\\mathbf{P}_5 = (8,-1)$. This implies $n=5$.\n  - Knot Vector: $U = [0,0,0,0,\\tfrac{1}{3},\\tfrac{2}{3},1,1,1,1]$. This implies $m=9$. The relation $m=n+p+1$ ($9=5+3+1$) is satisfied.\n  - Parameter Domain: $[U_p, U_{m-p}] = [U_3, U_6] = [0,1]$.\n  - Query Points: $\\mathbf{q}_1 = (4,1.5)$, $\\mathbf{q}_2 = (0,0)$, $\\mathbf{q}_3 = (10,-2)$, $\\mathbf{q}_4 = (2.5,2.5)$, $\\mathbf{q}_5 = (6.8,-0.8)$.\n- **Numerical Parameters**:\n  - Grid samples: $M = 200$.\n  - Convergence tolerance (derivative): $\\varepsilon = 10^{-10}$.\n  - Convergence tolerance (parameter): $\\delta = 10^{-12}$.\n  - Maximum iterations: $50$.\n- **Output Format**: A single line `[[u1,d1],[u2,d2],...]` where $u_k$ is the optimal parameter and $d_k$ is the minimum distance for the $k$-th query point.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is subjected to validation:\n- **Scientifically Grounded**: The problem is a standard, well-researched topic in numerical methods and computer-aided geometric design. All concepts (B-splines, de Boor's algorithm, Newton's method) are fundamental and correctly stated.\n- **Well-Posed**: The existence of a closest point is guaranteed by the Extreme Value Theorem, as we are minimizing a continuous function (distance) over a compact set (the parameter domain of the curve). The requested algorithm is a robust procedure for finding the global minimum.\n- **Objective**: The problem is specified using precise mathematical and algorithmic language, free of any subjectivity.\n- **Completeness and Consistency**: All necessary data, including the curve definition, query points, and numerical parameters for the algorithm, are provided. The relationship $m=n+p+1$ for B-splines is satisfied. The data is self-consistent.\n- **Feasibility**: The implementation of the specified algorithms is complex but entirely feasible within the given environment (Python with NumPy).\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is scientifically sound, well-posed, objective, complete, consistent, and feasible. I will now provide a complete solution.\n\n### Principle-Based Solution\nThe core of the problem is to find the parameter $u^\\star$ that minimizes the distance between a point on the B-spline curve $\\mathbf{C}(u)$ and a given external point $\\mathbf{q}$. This is equivalent to minimizing the squared distance function, which is computationally more convenient as it avoids square roots.\nLet the objective function be $f(u)$:\n$$f(u) = \\frac{1}{2} \\|\\mathbf{C}(u) - \\mathbf{q}\\|_2^2 = \\frac{1}{2} (\\mathbf{C}(u) - \\mathbf{q}) \\cdot (\\mathbf{C}(u) - \\mathbf{q})$$\nThe minimization is performed over the valid parameter domain, $u \\in [U_p, U_{m-p}]$. A necessary condition for a local minimum at an interior point of the domain is that the first derivative of the objective function is zero.\n\n**1. Derivatives of the Objective Function**\nWe derive the required derivatives of $f(u)$ using the chain rule and the product rule for vector-valued functions. Let $\\mathbf{r}(u) = \\mathbf{C}(u) - \\mathbf{q}$. Then $f(u) = \\frac{1}{2} \\mathbf{r}(u) \\cdot \\mathbf{r}(u)$.\n\nThe first derivative, $f'(u)$, is:\n$$f'(u) = \\frac{d}{du} \\left( \\frac{1}{2} \\mathbf{r}(u) \\cdot \\mathbf{r}(u) \\right) = \\mathbf{r}'(u) \\cdot \\mathbf{r}(u)$$\nSince $\\mathbf{r}'(u) = \\mathbf{C}'(u) - \\frac{d\\mathbf{q}}{du} = \\mathbf{C}'(u)$ (as $\\mathbf{q}$ is a constant point), we have:\n$$f'(u) = \\mathbf{C}'(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q})$$\nThe stationary points of $f(u)$ are the roots of the scalar equation $f'(u) = 0$. This condition has a clear geometric interpretation: the vector from the query point to the closest point on the curve, $\\mathbf{C}(u) - \\mathbf{q}$, must be orthogonal to the curve's tangent vector, $\\mathbf{C}'(u)$.\n\nThe second derivative, $f''(u)$, is found by differentiating $f'(u)$ with respect to $u$ using the product rule:\n$$f''(u) = \\frac{d}{du} \\left( \\mathbf{C}'(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) \\right) = \\mathbf{C}''(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) + \\mathbf{C}'(u) \\cdot \\mathbf{C}'(u)$$\n$$f''(u) = \\mathbf{C}''(u) \\cdot (\\mathbf{C}(u) - \\mathbf{q}) + \\|\\mathbf{C}'(u)\\|_2^2$$\nThese two derivatives, $f'(u)$ and $f''(u)$, form the basis of the Newton–Raphson method for finding the roots of $f'(u)$. The iteration is given by $u_{k+1} = u_k - \\frac{f'(u_k)}{f''(u_k)}$.\n\n**2. B-Spline Curve and Derivative Evaluation**\nTo evaluate $f'(u)$ and $f''(u)$, we need $\\mathbf{C}(u)$, $\\mathbf{C}'(u)$, and $\\mathbf{C}''(u)$. As stipulated, these are computed numerically.\n$\\mathbf{C}(u)$ is evaluated using the de Boor algorithm, which is a numerically stable recurrence relation operating on the control points within the knot span containing $u$.\nThe derivatives of a B-spline curve are themselves B-spline curves of a lower degree. A B-spline curve $\\mathbf{C}(u)$ of degree $p$ with control points $\\{\\mathbf{P}_i\\}_{i=0}^n$ and knot vector $\\{U_j\\}_{j=0}^m$ has a derivative $\\mathbf{C}'(u)$ which is a B-spline curve of degree $p-1$. Its control points $\\{\\mathbf{P}'_i\\}_{i=0}^{n-1}$ and knot vector $\\{U'_j\\}_{j=0}^{m-2}$ are derived from the original curve. The control points are given by:\n$$\\mathbf{P}'_i = p \\frac{\\mathbf{P}_{i+1} - \\mathbf{P}_i}{U_{i+p+1} - U_{i+1}} \\quad \\text{for } i \\in [0, n-1]$$\nThe knot vector for $\\mathbf{C}'(u)$ is $\\{U_j\\}_{j=1}^{m-1}$. $\\mathbf{C}'(u)$ is then evaluated by applying the de Boor algorithm to this newly defined curve. The second derivative, $\\mathbf{C}''(u)$, is found by applying the same process to $\\mathbf{C}'(u)$. This yields a B-spline of degree $p-2$ whose control points $\\{\\mathbf{P}''_i\\}$ and knots can be similarly derived.\n\n**3. Numerical Minimization Algorithm**\nThe global minimum of $f(u)$ on the compact interval $[U_p, U_{m-p}]$ must occur at either a boundary point ($U_p$ or $U_{m-p}$) or an interior point where $f'(u)=0$. The algorithm systematically finds all such candidates and selects the one that yields the smallest distance.\n\n**Stage 1: Bracketing and Safeguarded Root-Finding**\nTo ensure all roots of $f'(u)$ are found, the domain $[U_p, U_{m-p}]$ is first scanned.\n1.  A uniform grid of $M=200$ parameter values $\\{u_j\\}_{j=0}^{M-1}$ is created.\n2.  $f'(u_j)$ is computed for each grid point.\n3.  Any interval $[u_j, u_{j+1}]$ where $f'(u_j)$ and $f'(u_{j+1})$ have opposite signs must contain at least one root. These intervals become brackets for a root-finding algorithm.\n4.  For each bracket, a safeguarded Newton-Raphson method is employed. Starting with an initial guess (e.g., the midpoint of the bracket), the standard Newton step $u_{k+1} = u_k - f'(u_k)/f''(u_k)$ is computed.\n    -   **Safeguard**: If the new estimate $u_{k+1}$ falls outside the bracket, or if $|f''(u_k)|$ is close to zero (indicating an unreliable step), the method reverts to a bisection step, $u_{k+1} = (a+b)/2$, where $[a, b]$ is the current bracket.\n    -   The bracket is updated based on the sign of $f'(u_{k+1})$. The process iterates until the width of the bracket is smaller than a tolerance $\\delta=10^{-12}$ or $|f'(u_k)|$ is smaller than a tolerance $\\varepsilon=10^{-10}$. The resulting root is added to a set of candidate parameters.\n\n**Stage 2: Unbracketed Refinement from Promising Seeds**\nThe bracketing stage may miss roots if $f'(u)$ touches zero without crossing (i.e., roots of even multiplicity), or if two roots are very close together. To find additional candidates, we search for local minima of the distance itself on the grid.\n1.  The squared distance $d^2(u_j)$ is computed for each grid point $u_j$.\n2.  Points $u_j$ that are local minima on the grid (i.e., $d^2(u_{j-1}) > d^2(u_j) < d^2(u_{j+1})$) are identified as \"promising seeds.\"\n3.  From each seed, a projected, damped Newton's method is initiated to refine the estimate of the local minimum.\n    -   **Projection**: After each step, the new parameter value is clamped to the valid domain $[U_p, U_{m-p}]$.\n    -   **Damping/Backtracking**: The Newton step aims to find a root of $f'(u)$, not necessarily to decrease $f(u)$. To ensure progress, a backtracking line search is used. The full step is taken only if it decreases the objective function $f(u)$. If not, the step size is successively halved until a decrease is achieved or the step becomes too small.\n    This refinement process yields additional candidate parameters.\n\n**Stage 3: Global Minimum Selection**\nThe final set of candidates comprises:\n- The boundary parameters of the domain, $U_p$ and $U_{m-p}$.\n- All roots found by the safeguarded, bracketed root-finder.\n- All refined local minima from the unbracketed search.\n\nAfter removing duplicates, the objective function $f(u)$ is evaluated for every candidate parameter $u$ in this set. The parameter $u^\\star$ that yields the minimum value of $f(u)$ is the globally optimal parameter. The final closest distance is $d = \\sqrt{2f(u^\\star)} = \\|\\mathbf{C}(u^\\star) - \\mathbf{q}\\|_2$. This comprehensive search strategy is robust and designed to find the true global minimum.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_span(n, p, u, U):\n    \"\"\"\n    Determine the knot span index.\n    n: number of control points - 1\n    p: degree\n    u: parameter\n    U: knot vector\n    \"\"\"\n    # For open knot vectors, the end of the domain needs special handling.\n    if u >= U[n + 1]:\n        return n\n    \n    low = p\n    high = n + 1\n    mid = (low + high) // 2\n    \n    while u < U[mid] or u >= U[mid + 1]:\n        if u < U[mid]:\n            high = mid\n        else:\n            low = mid\n        mid = (low + high) // 2\n    return mid\n\ndef de_boor(p, U, P, u):\n    \"\"\"\n    Evaluate curve point and derivatives using de Boor's algorithm.\n    p: degree\n    U: knot vector\n    P: control points\n    u: parameter\n    Returns: C(u), C'(u), C''(u)\n    \"\"\"\n    n = len(P) - 1\n    \n    # --- C(u) ---\n    span = find_span(n, p, u, U)\n    pts = P[span - p : span + 1].copy()\n    for r in range(1, p + 1):\n        for j in range(p, r - 1, -1):\n            alpha = (u - U[span - p + j]) / (U[span - p + j + p - r + 1] - U[span - p + j])\n            pts[j] = (1.0 - alpha) * pts[j - 1] + alpha * pts[j]\n    C = pts[p]\n\n    # --- C'(u) ---\n    if p > 0:\n        P_prime = []\n        for i in range(n):\n            denom = U[i + p + 1] - U[i + 1]\n            if denom > 1e-12:\n                P_prime.append(p * (P[i + 1] - P[i]) / denom)\n            else:\n                # This case is complex, but for non-degenerate curves it's often zero\n                # or handled by context. For this problem, assume non-zero denominator.\n                P_prime.append(np.zeros_like(P[0]))\n        \n        P_prime = np.array(P_prime)\n        U_prime = U[1:-1]\n        \n        span_prime = find_span(len(P_prime) - 1, p - 1, u, U_prime)\n        pts_prime = P_prime[span_prime - (p - 1) : span_prime + 1].copy()\n\n        for r in range(1, p):\n            for j in range(p - 1, r - 1, -1):\n                alpha = (u - U_prime[span_prime - (p - 1) + j]) / (U_prime[span_prime - (p - 1) + j + (p - 1) - r + 1] - U_prime[span_prime - (p - 1) + j])\n                pts_prime[j] = (1.0 - alpha) * pts_prime[j - 1] + alpha * pts_prime[j]\n        C_prime = pts_prime[p - 1]\n    else:\n        C_prime = np.zeros_like(C)\n\n    # --- C''(u) ---\n    if p > 1:\n        P_prime2 = []\n        n_prime = len(P_prime) - 1\n        p_prime = p - 1\n        for i in range(n_prime):\n            denom = U_prime[i + p_prime + 1] - U_prime[i + 1]\n            if denom > 1e-12:\n                P_prime2.append(p_prime * (P_prime[i + 1] - P_prime[i]) / denom)\n            else:\n                P_prime2.append(np.zeros_like(P[0]))\n        \n        P_prime2 = np.array(P_prime2)\n        U_prime2 = U_prime[1:-1]\n        \n        span_prime2 = find_span(len(P_prime2) - 1, p - 2, u, U_prime2)\n        pts_prime2 = P_prime2[span_prime2 - (p - 2) : span_prime2 + 1].copy()\n        for r in range(1, p-1):\n            for j in range(p - 2, r - 1, -1):\n                alpha = (u - U_prime2[span_prime2 - (p - 2) + j]) / (U_prime2[span_prime2 - (p - 2) + j + (p - 2) - r + 1] - U_prime2[span_prime2 - (p - 2) + j])\n                pts_prime2[j] = (1.0 - alpha) * pts_prime2[j - 1] + alpha * pts_prime2[j]\n\n        C_prime2 = pts_prime2[p - 2]\n    else:\n        C_prime2 = np.zeros_like(C)\n\n    return C, C_prime, C_prime2\n\ndef find_closest_point(p, U, P, q, M, epsilon, delta, max_iter):\n    u_min, u_max = U[p], U[len(P)]\n\n    memo = {}\n    def get_ders(u):\n        u_rounded = round(u, 15) # Mitigate floating point re-computation issues\n        if u_rounded not in memo:\n            memo[u_rounded] = de_boor(p, U, P, u)\n        return memo[u_rounded]\n\n    def obj_fun_prime(u):\n        C, C_prime, _ = get_ders(u)\n        return np.dot(C_prime, C - q)\n    \n    def obj_fun_second(u):\n        C, C_prime, C_prime2 = get_ders(u)\n        return np.dot(C_prime2, C - q) + np.dot(C_prime, C_prime)\n\n    candidates = {u_min, u_max}\n\n    # Stage 1: Bracketing and Safeguarded Root-Finding\n    grid = np.linspace(u_min, u_max, M)\n    grid_vals = np.array([obj_fun_prime(u) for u in grid])\n    \n    for i in range(M - 1):\n        if np.sign(grid_vals[i]) != np.sign(grid_vals[i+1]):\n            a, b = grid[i], grid[i+1]\n            u_k = (a + b) / 2.0\n            for _ in range(max_iter):\n                if b - a < delta: break\n                \n                f_prime = obj_fun_prime(u_k)\n                if abs(f_prime) < epsilon: break\n\n                f_second = obj_fun_second(u_k)\n                if abs(f_second) > 1e-9:\n                    u_next = u_k - f_prime / f_second\n                    if u_next > a and u_next < b:\n                        u_k = u_next\n                    else:\n                        u_k = (a + b) / 2.0\n                else: # Unreliable curvature, revert to bisection\n                    u_k = (a + b) / 2.0\n                \n                f_prime_next = obj_fun_prime(u_k)\n                if np.sign(f_prime_next) == np.sign(obj_fun_prime(a)):\n                    a = u_k\n                else:\n                    b = u_k\n            \n            candidates.add(np.clip(u_k, u_min, u_max))\n\n    # Stage 2: Unbracketed Refinement from Promising Seeds\n    dist_sq_grid = [np.sum((get_ders(u)[0] - q)**2) for u in grid]\n    for i in range(1, M - 1):\n        if dist_sq_grid[i-1] > dist_sq_grid[i] < dist_sq_grid[i+1]:\n            u_k = grid[i]\n            for _ in range(max_iter):\n                f_prime = obj_fun_prime(u_k)\n                if abs(f_prime) < epsilon: break\n                \n                f_second = obj_fun_second(u_k)\n                if abs(f_second) > 1e-9:\n                    # Damped Newton step\n                    step = -f_prime/f_second\n                    alpha = 1.0\n                    current_dist_sq = np.sum((get_ders(u_k)[0] - q)**2)\n                    \n                    for _ in range(5): # Backtracking\n                        u_next = np.clip(u_k + alpha * step, u_min, u_max)\n                        next_dist_sq = np.sum((get_ders(u_next)[0] - q)**2)\n                        if next_dist_sq < current_dist_sq:\n                            break\n                        alpha /= 2.0\n                    else: # Damping failed, fall back to gradient descent\n                        alpha = 0.1 # Small-ish learning rate\n                        u_next = np.clip(u_k - alpha * f_prime, u_min, u_max)\n                    \n                    if abs(u_next - u_k) < delta: break\n                    u_k = u_next\n                else: # Gradient descent-like step if curvature is zero\n                    u_k = np.clip(u_k - 0.01 * f_prime, u_min, u_max)\n            candidates.add(u_k)\n\n    # Stage 3: Global Minimum Selection\n    best_u = -1\n    min_dist_sq = float('inf')\n    \n    for u in candidates:\n        C = get_ders(u)[0]\n        dist_sq = np.sum((C - q)**2)\n        if dist_sq < min_dist_sq:\n            min_dist_sq = dist_sq\n            best_u = u\n            \n    return [best_u, np.sqrt(min_dist_sq)]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n    # Test curve data\n    p = 3\n    P = np.array([\n        [0.0, 0.0], [1.0, 2.0], [3.0, 3.0], \n        [6.0, 2.0], [7.0, 0.0], [8.0, -1.0]\n    ])\n    U = np.array([0.0, 0.0, 0.0, 0.0, 1/3, 2/3, 1.0, 1.0, 1.0, 1.0])\n\n    # External query points\n    queries = [\n        np.array([4.0, 1.5]),\n        np.array([0.0, 0.0]),\n        np.array([10.0, -2.0]),\n        np.array([2.5, 2.5]),\n        np.array([6.8, -0.8]),\n    ]\n\n    # Numerical parameters\n    M = 200\n    epsilon = 1e-10\n    delta = 1e-12\n    max_iter = 50\n\n    results = []\n    for q in queries:\n        u_star, dist = find_closest_point(p, U, P, q, M, epsilon, delta, max_iter)\n        results.append(f\"[{u_star},{dist}]\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3207471"}]}