{"hands_on_practices": [{"introduction": "Before we can perform complex operations, we must first build a solid intuition for how data is organized. This exercise is a fundamental check of your understanding of the Compressed Sparse Row (CSR) format, tasking you with decoding its three core arrays to reconstruct the original matrix. Mastering this translation is the first step toward working efficiently with sparse data structures [@problem_id:2204554].", "problem": "In many scientific and engineering applications, matrices are often \"sparse,\" meaning most of their elements are zero. Storing all these zeros is inefficient. The Compressed Sparse Row (CSR) format is a common method for storing sparse matrices by using three one-dimensional arrays.\n\nConsider a sparse matrix $A$ of size $4 \\times 4$. In the CSR format (using 0-based indexing), this matrix is represented by the following three arrays:\n1.  An array `V` containing the non-zero elements of $A$, read row by row, from left to right.\n2.  An array `C` containing the column index for each corresponding element in `V`.\n3.  An array `R` (the row pointer) of size $m+1$ (where $m$ is the number of rows), where the $i$-th element indicates the index in `V` and `C` where the data for the $i$-th row begins. The last element of `R` is the total number of non-zero elements.\n\nThe three arrays for our $4 \\times 4$ matrix $A$ are given as follows:\n- `V = [5.1, -1.2, 2.0, -3.5, 4.0, 9.8]`\n- `C = [1, 3, 0, 2, 3, 0]`\n- `R = [0, 2, 3, 5, 6]`\n\nReconstruct the original dense $4 \\times 4$ matrix $A$. Present your answer as a $4 \\times 4$ matrix.", "solution": "We use the CSR definition with 0-based indexing. For each row index $i \\in \\{0,1,2,3\\}$, the nonzero entries of row $i$ are stored in the segments of `V` and `C` with indices $j$ from $R[i]$ to $R[i+1]-1$, where the column index is $C[j]$ and the value is $V[j]$. The last element $R[4]=6$ equals the total number of nonzeros, which matches $\\lvert V \\rvert=6$.\n\nRow $0$: indices $j=R[0]\\ldots R[1]-1=0\\ldots 1$.\n- $j=0$: $C[0]=1$, $V[0]=5.1$ gives $A_{0,1}=5.1$.\n- $j=1$: $C[1]=3$, $V[1]=-1.2$ gives $A_{0,3}=-1.2$.\nThus row $0$ is $[0,\\,5.1,\\,0,\\,-1.2]$.\n\nRow $1$: indices $j=R[1]\\ldots R[2]-1=2\\ldots 2$.\n- $j=2$: $C[2]=0$, $V[2]=2.0$ gives $A_{1,0}=2.0$.\nThus row $1$ is $[2.0,\\,0,\\,0,\\,0]$.\n\nRow $2$: indices $j=R[2]\\ldots R[3]-1=3\\ldots 4$.\n- $j=3$: $C[3]=2$, $V[3]=-3.5$ gives $A_{2,2}=-3.5$.\n- $j=4$: $C[4]=3$, $V[4]=4.0$ gives $A_{2,3}=4.0$.\nThus row $2$ is $[0,\\,0,\\,-3.5,\\,4.0]$.\n\nRow $3$: indices $j=R[3]\\ldots R[4]-1=5\\ldots 5$.\n- $j=5$: $C[5]=0$, $V[5]=9.8$ gives $A_{3,0}=9.8$.\nThus row $3$ is $[9.8,\\,0,\\,0,\\,0]$.\n\nTherefore, the reconstructed dense matrix $A$ is\n$$\n\\begin{pmatrix}\n0 & 5.1 & 0 & -1.2 \\\\\n2.0 & 0 & 0 & 0 \\\\\n0 & 0 & -3.5 & 4.0 \\\\\n9.8 & 0 & 0 & 0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 5.1 & 0 & -1.2 \\\\ 2.0 & 0 & 0 & 0 \\\\ 0 & 0 & -3.5 & 4.0 \\\\ 9.8 & 0 & 0 & 0\\end{pmatrix}}$$", "id": "2204554"}, {"introduction": "The power of sparse formats lies in performing computations without ever forming the full, dense matrix, thereby saving significant memory and time. This practice challenges you to compute the trace of a matrix—the sum of its diagonal elements—by working directly with its CSR representation [@problem_id:2204603]. Successfully solving this requires designing an efficient algorithm to navigate the CSR arrays and locate only the specific elements you need.", "problem": "In numerical analysis, sparse matrices (matrices in which most of the elements are zero) are often stored in specialized formats to save memory and computational time. One such popular format is the Compressed Sparse Row (CSR) format.\n\nA sparse square matrix $M$ of size $N \\times N$ is represented in CSR format using three one-dimensional arrays, assuming 0-based indexing for all arrays and for the matrix itself:\n1.  `A`: A floating-point array containing all the non-zero elements of the matrix, read row by row, from left to right.\n2.  `JA`: An integer array of the same size as `A`, containing the column index for each corresponding element in `A`.\n3.  `IA`: An integer array of size $N+1$. For a row `i` (where $0 \\le i < N$), the non-zero elements of that row are stored in array `A` starting from index `IA[i]` up to, but not including, index `IA[i+1]`. The last element, `IA[N]`, stores the total number of non-zero elements.\n\nConsider a square matrix $M$ stored in CSR format with the following array data:\n\n`A = [9.0, 2.0, 3.0, 7.0, 1.0, 4.0, 5.0, -4.0, 1.0, 8.0, 6.0, 2.0]`\n`JA = [0, 3, 0, 1, 2, 3, 1, 3, 4, 4, 5, 5]`\n`IA = [0, 2, 4, 6, 9, 11, 12]`\n\nCalculate the trace of the matrix $M$, which is defined as the sum of the elements on its main diagonal, $\\text{Tr}(M) = \\sum_{i=0}^{N-1} M_{ii}$.", "solution": "We are given a square matrix $M$ in CSR format with arrays $A$, $JA$, and $IA$, using 0-based indexing. By definition of CSR, for each row index $i$ with $0 \\leq i < N$, the indices $k$ of the nonzero entries in that row are in the half-open interval $[IA[i], IA[i+1])$, and the column index of entry $k$ is $JA[k]$ while its value is $A[k]$. The main diagonal entry of row $i$ is $M_{ii}$, which exists if and only if there is some $k \\in [IA[i], IA[i+1])$ such that $JA[k]=i$, in which case $M_{ii}=A[k]$. The trace is $\\text{Tr}(M)=\\sum_{i=0}^{N-1} M_{ii}$.\n\nFirst determine the matrix size. The array $IA$ has length $N+1$. Given $IA=[0,2,4,6,9,11,12]$, its length is $7$, hence $N=6$.\n\nProcess each row to extract its diagonal entry:\n- Row $i=0$: indices $k \\in [IA[0], IA[1])=[0,2) \\Rightarrow k=0,1$. We have $JA[0]=0$, so $M_{00}=A[0]=9.0$.\n- Row $i=1$: indices $k \\in [IA[1], IA[2])=[2,4) \\Rightarrow k=2,3$. We have $JA[3]=1$, so $M_{11}=A[3]=7.0$.\n- Row $i=2$: indices $k \\in [IA[2], IA[3])=[4,6) \\Rightarrow k=4,5$. We have $JA[4]=2$, so $M_{22}=A[4]=1.0$.\n- Row $i=3$: indices $k \\in [IA[3], IA[4])=[6,9) \\Rightarrow k=6,7,8$. We have $JA[7]=3$, so $M_{33}=A[7]=-4.0$.\n- Row $i=4$: indices $k \\in [IA[4], IA[5])=[9,11) \\Rightarrow k=9,10$. We have $JA[9]=4$, so $M_{44}=A[9]=8.0$.\n- Row $i=5$: indices $k \\in [IA[5], IA[6])=[11,12) \\Rightarrow k=11$. We have $JA[11]=5$, so $M_{55}=A[11]=2.0$.\n\nTherefore, the trace is\n$$\n\\text{Tr}(M)=M_{00}+M_{11}+M_{22}+M_{33}+M_{44}+M_{55}\n=9.0+7.0+1.0+(-4.0)+8.0+2.0=23.0.\n$$", "answer": "$$\\boxed{23}$$", "id": "2204603"}, {"introduction": "Choosing the right storage format is a critical decision that depends on the specific sparsity pattern of your matrix. This problem moves from mechanics to analysis, asking you to compare the memory costs of the CSR and Diagonal (DIA) formats for a special \"arrowhead\" matrix structure [@problem_id:2204576]. By deriving the memory usage for each, you will develop the analytical skills needed to justify format selection based on quantitative trade-offs.", "problem": "In scientific computing, sparse matrices, which are matrices populated primarily with zeros, are often stored in specialized formats to conserve memory. Consider an $N \\times N$ \"arrowhead\" matrix, defined as a matrix where the only non-zero elements are located on the main diagonal, the first row, and the first column.\n\nWe want to compare the memory efficiency of two common storage formats for this matrix: Compressed Sparse Row (CSR) and Diagonal (DIA).\n\nAssume that non-zero values are stored as double-precision floating-point numbers (8 bytes each) and all row/column indices and pointers are stored as integers (4 bytes each).\n\nThe memory requirements for each format are defined as follows:\n\n1.  **Compressed Sparse Row (CSR)**: This format uses three arrays:\n    *   `values`: An array of size `nnz` storing the non-zero values, where `nnz` is the total number of non-zero elements.\n    *   `col_indices`: An array of size `nnz` storing the column index of each non-zero element.\n    *   `row_pointers`: An array of size $N+1$ storing the index into the `values` array that marks the start of each row.\n\n2.  **Diagonal (DIA)**: This format is optimized for matrices with non-zeros along a few diagonals. It uses two arrays:\n    *   `offsets`: An array of size `d` that stores the offset of each diagonal from the main diagonal, where `d` is the number of non-zero diagonals.\n    *   `values`: A dense $N \\times d$ array. Each column of this array stores the elements of one of the non-zero diagonals. If a diagonal has fewer than $N$ elements, the corresponding column in the `values` array is padded with zeros.\n\nDetermine the smallest integer dimension $N \\ge 2$ for which the total memory required by the CSR format is strictly less than the total memory required by the DIA format for storing an arrowhead matrix.", "solution": "An $N \\times N$ arrowhead matrix has non-zero entries on the main diagonal, the first row, and the first column. Counting unique non-zeros:\n- Main diagonal contributes $N$ entries.\n- First row contributes $N-1$ additional entries (excluding the $(1,1)$ overlap).\n- First column contributes $N-1$ additional entries (excluding the $(1,1)$ overlap).\nTherefore, the total number of non-zeros is\n$$\n\\text{nnz} = N + (N - 1) + (N - 1) = 3N - 2.\n$$\n\nFor CSR:\n- The `values` array stores $\\text{nnz}$ doubles: $8(3N - 2)$ bytes.\n- The `col\\_indices` array stores $\\text{nnz}$ integers: $4(3N - 2)$ bytes.\n- The `row\\_pointers` array stores $N+1$ integers: $4(N+1)$ bytes.\nThus the total CSR memory is\n$$\nM_{\\text{CSR}} = 8(3N - 2) + 4(3N - 2) + 4(N+1) = 12(3N - 2) + 4(N+1) = 40N - 20.\n$$\n\nFor DIA:\n- The number of non-zero diagonals equals the number of distinct offsets present among the main diagonal, first row, and first column. The offsets from the first row are $\\{0,1,2,\\ldots,N-1\\}$, and from the first column are $\\{0,-1,-2,\\ldots,-(N-1)\\}$, so the union is $\\{-(N-1),\\ldots,0,\\ldots,(N-1)\\}$, giving\n$$\nd = 2N - 1.\n$$\n- The `offsets` array stores $d$ integers: $4(2N - 1)$ bytes.\n- The `values` array is dense $N \\times d$ doubles: $8N(2N - 1)$ bytes.\nThus the total DIA memory is\n$$\nM_{\\text{DIA}} = 4(2N - 1) + 8N(2N - 1) = (8N + 4)(2N - 1) = 16N^{2} - 4.\n$$\n\nWe seek the smallest integer $N \\geq 2$ such that $M_{\\text{CSR}} < M_{\\text{DIA}}$:\n$$\n40N - 20 < 16N^{2} - 4\n\\;\\;\\Longleftrightarrow\\;\\;\n16N^{2} - 40N + 16 > 0\n\\;\\;\\Longleftrightarrow\\;\\;\n16(N - 2)\\left(N - \\frac{1}{2}\\right) > 0.\n$$\nThis inequality holds for $N > 2$. At $N = 2$, both formats use the same memory. Therefore, the smallest integer $N \\geq 2$ for which CSR uses strictly less memory than DIA is $N = 3$.", "answer": "$$\\boxed{3}$$", "id": "2204576"}]}