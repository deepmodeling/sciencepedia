{"hands_on_practices": [{"introduction": "The journey into computational science often begins with translating a continuous partial differential equation into a set of algebraic rules a computer can solve. This first practice provides a direct, hands-on application of this fundamental process. We will discretize a one-dimensional reaction-diffusion equation using the explicit Forward-Time Central-Space (FTCS) scheme, allowing you to see firsthand how a system's state is evolved one time step at a time based on its neighbors' previous states [@problem_id:1127180].", "problem": "Consider the one-dimensional reaction-diffusion equation for a quantity $u(x, t)$:\n$$\n\\frac{\\partial u}{\\partial t} = D \\frac{\\partial^2 u}{\\partial x^2} - k u\n$$\nwhere $D$ is the diffusion coefficient and $k$ is the reaction rate, both positive constants. The equation is defined on a spatial domain $x \\in [0, L]$. The system is subject to homogeneous Dirichlet boundary conditions:\n$$\nu(0, t) = 0, \\quad u(L, t) = 0\n$$\nThe initial condition at time $t=0$ is given by a triangular \"tent\" function of height $A$:\n$$\nu(x, 0) = \\begin{cases} \\frac{2A}{L}x & 0 \\le x \\le L/2 \\\\ \\frac{2A}{L}(L-x) & L/2 < x \\le L \\end{cases}\n$$\nWe wish to solve this equation numerically using the explicit Forward-Time Central-Space (FTCS) finite difference method. The spatial domain $[0, L]$ is discretized into $N=4$ equal subintervals, with grid spacing $\\Delta x = L/N$. The time step is $\\Delta t$. Let the dimensionless parameters be defined as $\\mu = \\frac{D \\Delta t}{(\\Delta x)^2}$ and $\\beta = k \\Delta t$.\n\nUsing a single time step of the FTCS scheme, derive an expression for the solution at the midpoint of the spatial domain, $x = L/2$, at time $t = \\Delta t$. Express your answer in terms of $A$, $\\mu$, and $\\beta$.", "solution": "1. The FTCS finite‐difference update for $u_t = D u_{xx}-k u$ at grid point $i$ and time step $n\\to n+1$ is\n$$\nu_i^{n+1}=u_i^n+\\mu\\bigl(u_{i-1}^n-2u_i^n+u_{i+1}^n\\bigr)-\\beta\\,u_i^n,\n$$\nwith $\\mu=\\frac{D\\Delta t}{(\\Delta x)^2}$ and $\\beta=k\\Delta t$.\n\n2. Discretization: $N=4\\implies\\Delta x=L/4$. Grid points $x_i=i\\,\\Delta x$, so $x_2=L/2$.\n\n3. Initial values $u_i^0$ from the tent profile:\n$$\nu_0^0=0,\\quad u_1^0=\\frac{2A}{L}\\,\\frac{L}{4}=\\frac{A}{2},\\quad\nu_2^0=A,\\quad\nu_3^0=\\frac{2A}{L}\\,\\frac{L}{4}=\\frac{A}{2},\\quad\nu_4^0=0.\n$$\n\n4. Apply the scheme at $i=2$:\n$$\nu_2^1\n=u_2^0+\\mu\\bigl(u_1^0-2u_2^0+u_3^0\\bigr)-\\beta\\,u_2^0\n=A+\\mu\\bigl(\\tfrac{A}{2}-2A+\\tfrac{A}{2}\\bigr)-\\beta A\n=A-\\mu A-\\beta A\n=A\\bigl(1-\\mu-\\beta\\bigr)\\,. \n$$", "answer": "$$\\boxed{A(1-\\mu-\\beta)}$$", "id": "1127180"}, {"introduction": "While the finite difference method is powerful, a naive implementation can lead to unphysical results, such as spurious oscillations, especially when modeling systems where transport (convection) dominates diffusion. This exercise explores this critical issue by comparing the second-order Central Difference Scheme (CDS) with the more robust first-order Upwind Difference Scheme (UDS) for a convection-diffusion problem [@problem_id:3128259]. You will discover the importance of the cell Peclet number, $Pe_h$, and learn about the essential trade-off between formal accuracy and numerical stability that every computational scientist must navigate.", "problem": "You are asked to investigate spatial discretizations for the one-dimensional linear convection–diffusion Partial Differential Equation (PDE) given by $u_t + a\\,u_x = \\epsilon\\,u_{xx}$ on the domain $x \\in [0,1]$ with constant positive advection speed $a > 0$ and positive diffusivity $\\epsilon > 0$. Focus on the steady boundary layer structure that emerges from the stationary problem obtained by setting $u_t = 0$, namely $\\epsilon\\,u_{xx} - a\\,u_x = 0$, with Dirichlet boundary conditions $u(0) = 1$ and $u(1) = 0$. You will analyze how different spatial finite difference discretizations behave as the cell Peclet number increases, and quantify whether discrete oscillations appear in the numerical solution.\n\nStarting only from fundamental definitions, derive consistent second-order accurate finite differences for spatial derivatives on a uniform grid with $N$ points over $[0,1]$ and grid spacing $h = 1/(N-1)$:\n- Use the Central Difference Scheme (CDS) to approximate the first derivative by $u_x(x_i) \\approx \\left(u_{i+1} - u_{i-1}\\right)/(2h)$ and the second derivative by $u_{xx}(x_i) \\approx \\left(u_{i+1} - 2u_i + u_{i-1}\\right)/h^2$.\n- Use the Upwind Difference Scheme (UDS) for the first derivative when $a > 0$ by $u_x(x_i) \\approx \\left(u_i - u_{i-1}\\right)/h$, while keeping the same second derivative approximation as above.\n\nConstruct in each case the tridiagonal linear system for the interior unknowns $u_1,\\dots,u_{N-2}$ obtained from the steady equation $\\epsilon\\,u_{xx} - a\\,u_x = 0$ at interior grid points $x_i$ for $i = 1,\\dots,N-2$, and enforce the Dirichlet boundary conditions $u_0 = 1$ and $u_{N-1} = 0$ directly into the right-hand side. Solve the linear system to obtain the discrete steady profile $u_i$ for $i=0,\\dots,N-1$.\n\nDefine the cell Peclet number as $Pe_h = \\dfrac{a\\,h}{\\epsilon}$. Define a discrete solution to be oscillatory if either of the following holds:\n- It is not monotone decreasing from $x=0$ to $x=1$ in the sense that $\\Delta_i = u_{i+1} - u_i \\le \\tau$ for all $i=0,\\dots,N-2$ fails, where $\\tau = 10^{-10}$.\n- It exhibits overshoot or undershoot outside the physically consistent interval implied by the boundary conditions, i.e., $\\min_i u_i < -\\tau$ or $\\max_i u_i > 1 + \\tau$.\n\nFor each test case below, compute the steady solutions using both CDS and UDS. Then classify the pair of outcomes using the following integer code:\n- $0$ if CDS is non-oscillatory and UDS is non-oscillatory,\n- $1$ if CDS is oscillatory and UDS is non-oscillatory,\n- $2$ if CDS is oscillatory and UDS is oscillatory,\n- $3$ if CDS is non-oscillatory and UDS is oscillatory.\n\nTest suite (all parameters are dimensionless):\n- Case A: $a = 1$, $\\epsilon = 0.1$, $N = 41$.\n- Case B: $a = 5$, $\\epsilon = 0.01$, $N = 41$.\n- Case C: $a = 50$, $\\epsilon = 0.01$, $N = 41$.\n- Case D: $a = 1$, $\\epsilon = 0.0125$, $N = 41$.\n\nYour program must output a single line containing a comma-separated list of the integer codes for Cases A, B, C, and D in this order, enclosed in square brackets (for example, $[0,1,1,0]$). There are no physical units to report in this problem because the parameters and variables are nondimensional. The angle unit is not applicable. All final numeric outputs must be integers in the specified list format.", "solution": "The user-provided problem is valid as it is scientifically grounded, well-posed, and objective. It constitutes a standard exercise in the numerical analysis of partial differential equations, specifically examining the stability and accuracy of finite difference methods for the convection-diffusion equation.\n\nThe problem investigates the one-dimensional steady linear convection-diffusion equation:\n$$\n\\epsilon u_{xx} - a u_x = 0\n$$\non the spatial domain $x \\in [0, 1]$, with constant positive advection speed $a > 0$ and diffusivity $\\epsilon > 0$. The equation is subject to Dirichlet boundary conditions $u(0) = 1$ and $u(1) = 0$. The analytical solution to this boundary value problem is known to be:\n$$\nu(x) = \\frac{e^{ax/\\epsilon} - e^{a/\\epsilon}}{1 - e^{a/\\epsilon}}\n$$\nThis exact solution is monotonic, decreasing from $u(0)=1$ to $u(1)=0$. Any oscillations observed in a numerical solution are therefore artifacts of the discretization method.\n\nWe discretize the domain using a uniform grid of $N$ points, $x_i = i h$ for $i = 0, 1, \\dots, N-1$, where the grid spacing is $h = 1/(N-1)$. The numerical solution $u_i \\approx u(x_i)$ is sought at these grid points. The boundary conditions fix the values at the endpoints: $u_0 = 1$ and $u_{N-1} = 0$. The solution for the interior points, $u_1, \\dots, u_{N-2}$, is found by solving a system of linear equations derived from the discretized PDE.\n\nWe consider two different finite difference schemes for the spatial derivatives at an interior grid point $x_i$:\n\n1.  **Central Difference Scheme (CDS)**\n    This scheme utilizes second-order accurate central differences for both the first and second derivatives:\n    $$\n    u_x(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    Substituting these into the governing equation $\\epsilon u_{xx} - a u_x = 0$ yields:\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_{i+1} - u_{i-1}}{2h} \\right) = 0\n    $$\n    Multiplying by $h^2$ and collecting terms for $u_{i-1}$, $u_i$, and $u_{i+1}$, we obtain the discrete equation for each interior node $i=1, \\dots, N-2$:\n    $$\n    \\left(\\epsilon + \\frac{ah}{2}\\right) u_{i-1} - 2\\epsilon u_i + \\left(\\epsilon - \\frac{ah}{2}\\right) u_{i+1} = 0\n    $$\n    By defining the dimensionless cell Peclet number, $Pe_h = \\frac{ah}{\\epsilon}$, which compares the strength of advection to diffusion over a grid cell, the equation can be rewritten as:\n    $$\n    \\epsilon \\left( \\left(1 + \\frac{Pe_h}{2}\\right) u_{i-1} - 2 u_i + \\left(1 - \\frac{Pe_h}{2}\\right) u_{i+1} \\right) = 0\n    $$\n    A key stability criterion, related to the discrete maximum principle, requires the off-diagonal coefficients of the resulting matrix to have signs that do not cause unphysical extrema. For this equation, the coefficient of $u_{i+1}$, which is $(1 - Pe_h/2)$, becomes negative if $Pe_h > 2$. This condition is known to lead to spurious oscillations in the numerical solution, particularly in regions with strong gradients.\n\n2.  **Upwind Difference Scheme (UDS)**\n    This scheme employs a first-order accurate backward difference for the advection term (since $a>0$, the \"upwind\" direction is from smaller $x$) and the same second-order central difference for the diffusion term:\n    $$\n    u_x(x_i) \\approx \\frac{u_i - u_{i-1}}{h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    Substituting these approximations into the governing equation gives:\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_i - u_{i-1}}{h} \\right) = 0\n    $$\n    Multiplying by $h^2$ and collecting terms results in the discrete equation:\n    $$\n    (\\epsilon + ah) u_{i-1} - (2\\epsilon + ah) u_i + \\epsilon u_{i+1} = 0\n    $$\n    In this formulation, the coefficients for the neighboring points $u_{i-1}$ and $u_{i+1}$ are $(\\epsilon + ah)$ and $\\epsilon$, respectively. Since $a, \\epsilon, h$ are all positive, these coefficients are always positive. The resulting matrix is diagonally dominant, and this scheme is guaranteed to produce a non-oscillatory solution for any value of the cell Peclet number, at the cost of being only first-order accurate.\n\nFor both schemes, a tridiagonal system of linear equations $M \\mathbf{u}_{\\text{int}} = \\mathbf{b}$ is formed for the vector of interior unknowns $\\mathbf{u}_{\\text{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$. The boundary conditions are incorporated into the right-hand side vector $\\mathbf{b}$. For the first interior node ($i=1$), the term involving $u_0=1$ is moved to the right side, and for the last interior node ($i=N-2$), the term involving $u_{N-1}=0$ vanishes. This results in a system where only the first element of $\\mathbf{b}$ is non-zero.\n\nThe solution is deemed oscillatory if it is not monotonically decreasing (specifically, if $u_{i+1} - u_i > \\tau$ for any $i$, where $\\tau=10^{-10}$) or if it exhibits over/undershoot beyond the physical bounds set by the boundary conditions (i.e., $\\min_i u_i < -\\tau$ or $\\max_i u_i > 1 + \\tau$).\n\nThe procedure is to solve these linear systems for each test case using both CDS and UDS, check the resulting solutions for oscillations, and assign the corresponding integer code based on the pair of outcomes. This is implemented in the provided Python code, which uses `scipy.linalg.solve_banded` for an efficient solution of the tridiagonal systems.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady convection-diffusion equation for specified test cases\n    using Central Difference Scheme (CDS) and Upwind Difference Scheme (UDS),\n    and classifies the results based on the presence of numerical oscillations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, epsilon, N)\n        (1.0, 0.1, 41),    # Case A\n        (5.0, 0.01, 41),   # Case B\n        (50.0, 0.01, 41),  # Case C\n        (1.0, 0.0125, 41), # Case D\n    ]\n\n    # Tolerance for oscillation checks\n    tau = 1e-10\n\n    def check_oscillatory(u_sol, tau_val):\n        \"\"\"\n        Checks if a numerical solution is oscillatory.\n\n        A solution is defined as oscillatory if:\n        1. It is not monotone decreasing, i.e., u[i+1] > u[i] + tau for some i.\n        2. It has overshoot or undershoot outside the physical bounds [0, 1].\n        \"\"\"\n        # Check for non-monotonicity\n        if np.any(np.diff(u_sol) > tau_val):\n            return True\n            \n        # Check for overshoot/undershoot\n        if np.min(u_sol) < -tau_val or np.max(u_sol) > 1.0 + tau_val:\n            return True\n            \n        return False\n\n    def solve_system(a, epsilon, N, scheme):\n        \"\"\"\n        Constructs and solves the tridiagonal linear system for a given scheme.\n        \"\"\"\n        h = 1.0 / (N - 1)\n        N_int = N - 2  # Number of interior points\n        \n        # Define matrix coefficients based on the scheme\n        if scheme == 'CDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h / 2.0\n            B = -2.0 * epsilon\n            C = epsilon - a * h / 2.0\n        elif scheme == 'UDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h\n            B = -(2.0 * epsilon + a * h)\n            C = epsilon\n        else:\n            raise ValueError(\"Unknown scheme specified.\")\n            \n        # Create tridiagonal matrix in banded format for scipy.linalg.solve_banded\n        # For a tridiagonal matrix, (l, u) = (1, 1), so matrix `ab` has shape (3, N_int).\n        # ab[0, 1:] = upper diagonal (C)\n        # ab[1, :] = main diagonal (B)\n        # ab[2, :-1] = lower diagonal (A)\n        ab = np.zeros((3, N_int))\n        ab[0, 1:] = C\n        ab[1, :] = B\n        ab[2, :-1] = A\n        \n        # Create the right-hand side vector b\n        # For i=1: A*u_0 + B*u_1 + C*u_2 = 0 => B*u_1 + C*u_2 = -A*u_0\n        # Since u_0 = 1, the first element of b is -A.\n        # For i=N-2: A*u_{N-3} + B*u_{N-2} + C*u_{N-1} = 0\n        # Since u_{N-1} = 0, the last element remains 0.\n        b = np.zeros(N_int)\n        b[0] = -A * 1.0\n        \n        # Solve the linear system for interior points\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Assemble the full solution vector including boundaries u_0=1 and u_{N-1}=0\n        u_full = np.concatenate(([1.0], u_interior, [0.0]))\n        \n        return u_full\n\n    results = []\n    for case in test_cases:\n        a_val, eps_val, N_val = case\n        \n        # Solve for CDS and check for oscillations\n        u_cds = solve_system(a_val, eps_val, N_val, 'CDS')\n        cds_oscillatory = check_oscillatory(u_cds, tau)\n        \n        # Solve for UDS and check for oscillations\n        u_uds = solve_system(a_val, eps_val, N_val, 'UDS')\n        uds_oscillatory = check_oscillatory(u_uds, tau)\n        \n        # Classify the outcome based on the problem's integer codes\n        code = -1\n        if not cds_oscillatory and not uds_oscillatory:\n            code = 0  # Both non-oscillatory\n        elif cds_oscillatory and not uds_oscillatory:\n            code = 1  # CDS oscillatory, UDS non-oscillatory\n        elif cds_oscillatory and uds_oscillatory:\n            code = 2  # Both oscillatory\n        elif not cds_oscillatory and uds_oscillatory:\n            code = 3  # CDS non-oscillatory, UDS oscillatory\n        \n        results.append(code)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3128259"}, {"introduction": "After implementing a numerical scheme, a crucial question arises: \"Is my code correct?\" This final practice introduces the Method of Manufactured Solutions (MMS), a rigorous and indispensable technique for code verification in scientific computing. By designing a problem with a known analytical solution, you can precisely measure your implementation's error and computationally verify that it achieves its theoretical order of accuracy [@problem_id:3229592]. Mastering this technique is a vital step toward developing trustworthy and reliable numerical simulations.", "problem": "Consider the one-dimensional heat equation with a manufactured source term on a spatial interval and a finite time interval. Let the thermal diffusivity be a positive constant $\\,\\alpha > 0\\,$ and consider the problem on $\\,x \\in [0,1]\\,$ and $\\,t \\in [0,T]\\,$ with homogeneous Dirichlet boundary conditions. Use the method of manufactured solutions as follows.\n\n1. Choose the manufactured solution $\\,u(x,t) = \\exp(t)\\,\\sin(\\pi x)\\,$. Define the source term $\\,f(x,t)\\,$ so that $\\,u\\,$ satisfies the partial differential equation $\\,u_t = \\alpha u_{xx} + f\\,$ exactly. Impose initial and boundary conditions taken from this $\\,u\\,$, namely $\\,u(x,0) = \\sin(\\pi x)\\,$ and $\\,u(0,t) = u(1,t) = 0\\,$ for all $\\,t\\,$.\n\n2. Discretize $\\,[0,1]\\,$ with $\\,N_x\\,$ equal subintervals of width $\\,\\Delta x = 1/N_x\\,$ and grid points $\\,x_i = i\\,\\Delta x\\,$ for $\\,i = 0,1,\\dots,N_x\\,$. Discretize $\\, [0,T]\\,$ with $\\,N_t\\,$ equal time steps of size $\\,\\Delta t = T/N_t\\,$ and times $\\,t^n = n\\,\\Delta t\\,$ for $\\,n = 0,1,\\dots,N_t\\,$. Let $\\,u_i^n \\approx u(x_i,t^n)\\,$ denote the numerical approximation at interior indices $\\,i = 1,2,\\dots,N_x-1\\,$ and times $\\,n = 0,1,\\dots,N_t\\,$.\n\n3. Use the Crank–Nicolson method, which is the trapezoidal rule in time combined with second-order central differences in space, to discretize the heat equation at the interior nodes. Use the exact Dirichlet boundary values at $\\,x=0\\,$ and $\\,x=1\\,$ implied by the manufactured solution. Start the time stepping from the exact initial condition $\\,u_i^0 = \\sin(\\pi x_i)\\,$.\n\n4. Compute the discrete $\\,L^2\\,$ error at the final time $\\,t = T\\,$ defined by\n$$\nE(N_x,N_t) \\;=\\; \\left( \\Delta x \\sum_{i=0}^{N_x} \\bigl(u_i^{N_t} - u(x_i,T)\\bigr)^2 \\right)^{1/2},\n$$\nwith the convention that $\\,u_0^{N_t} = u_{N_x}^{N_t} = 0\\,$.\n\nYour program must verify second-order accuracy in both time and space by estimating observed convergence rates via the method of manufactured solutions. Use the following fixed parameters and test suite.\n\n- Use $\\,\\alpha = 1\\,$ and $\\,T = 0.1\\,$.\n\n- Temporal-order test suite: fix a sufficiently fine spatial grid $\\,N_x = 300\\,$ and vary the number of time steps $\\,N_t \\in \\{50,100,200,400,800\\}\\,$. For each $\\,N_t\\,$, compute $\\,E(N_x,N_t)\\,$ and then estimate the observed temporal order $\\,p_t\\,$ by a least-squares linear fit of $\\,\\log E\\,$ versus $\\,\\log \\Delta t\\,$ over these five cases, where $\\,\\Delta t = T/N_t\\,$. Report $\\,p_t\\,$ rounded to two decimal places.\n\n- Spatial-order test suite: fix a sufficiently small time step $\\,N_t = 1000\\,$ and vary the number of spatial subintervals $\\,N_x \\in \\{10,20,40,80,160\\}\\,$. For each $\\,N_x\\,$, compute $\\,E(N_x,N_t)\\,$ and then estimate the observed spatial order $\\,p_x\\,$ by a least-squares linear fit of $\\,\\log E\\,$ versus $\\,\\log \\Delta x\\,$ over these five cases, where $\\,\\Delta x = 1/N_x\\,$. Report $\\,p_x\\,$ rounded to two decimal places.\n\n- In addition, compute a boolean pass flag defined as true if and only if both $\\,p_t \\ge 1.90\\,$ and $\\,p_x \\ge 1.90\\,$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[p_t,p_x,pass]$. The first two entries must be floats rounded to two decimal places, and the third entry must be a boolean literal, for example $[1.99,2.01,True]$.", "solution": "The user-provided problem is assessed to be valid. It is a well-posed, scientifically sound, and complete problem in the field of numerical analysis for partial differential equations. The task is to verify the convergence order of the Crank-Nicolson method for the one-dimensional heat equation using the method of manufactured solutions.\n\nThe analysis and solution proceed as follows.\n\nFirst, we determine the source term $f(x,t)$ required for the manufactured solution $u(x,t) = \\exp(t)\\sin(\\pi x)$ to exactly satisfy the governing partial differential equation (PDE), $u_t = \\alpha u_{xx} + f(x,t)$.\n\nWe compute the partial derivatives of $u(x,t)$:\n-   The partial derivative with respect to time $t$ is:\n    $$ u_t = \\frac{\\partial}{\\partial t} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\exp(t)\\sin(\\pi x) $$\n-   The second partial derivative with respect to space $x$ is:\n    $$ u_x = \\frac{\\partial}{\\partial x} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\pi \\exp(t)\\cos(\\pi x) $$\n    $$ u_{xx} = \\frac{\\partial^2}{\\partial x^2} \\left( \\exp(t)\\sin(\\pi x) \\right) = -\\pi^2 \\exp(t)\\sin(\\pi x) $$\n\nSubstituting these derivatives into the PDE gives:\n$$ \\exp(t)\\sin(\\pi x) = \\alpha \\left( -\\pi^2 \\exp(t)\\sin(\\pi x) \\right) + f(x,t) $$\nSolving for the source term $f(x,t)$ yields:\n$$ f(x,t) = \\exp(t)\\sin(\\pi x) + \\alpha \\pi^2 \\exp(t)\\sin(\\pi x) = (1 + \\alpha \\pi^2) \\exp(t)\\sin(\\pi x) $$\n\nNext, we discretize the PDE using the Crank-Nicolson method. The spatial domain $[0,1]$ is discretized into $N_x$ subintervals of width $\\Delta x = 1/N_x$, and the time domain $[0,T]$ is discretized into $N_t$ steps of size $\\Delta t = T/N_t$. Let $u_i^n$ be the numerical approximation of $u(x_i, t^n)$, where $x_i = i\\Delta x$ and $t^n = n\\Delta t$.\n\nThe Crank-Nicolson scheme applies a central difference in space and the trapezoidal rule in time, evaluating both at the midpoint $t^{n+1/2} = t^n + \\Delta t/2$. This results in a scheme that is second-order accurate in both space and time. The discretized equation at an interior grid point $(x_i, t^{n+1/2})$ is:\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2} + \\frac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{(\\Delta x)^2} \\right) + f(x_i, t^{n+1/2}) $$\nApproximating the source term as $f(x_i, t^{n+1/2}) \\approx \\frac{1}{2}(f_i^{n+1} + f_i^n)$, where $f_i^n = f(x_i, t^n)$, we get:\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( D_{xx} u_i^{n+1} + D_{xx} u_i^{n} \\right) + \\frac{1}{2}(f_i^{n+1} + f_i^n) $$\nwhere $D_{xx}$ represents the second-order central difference operator.\n\nTo solve for the unknown values at time $t^{n+1}$, we rearrange the equation, moving terms at step $n+1$ to the left-hand side (LHS) and terms at step $n$ to the right-hand side (RHS). Let $\\nu = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$. The equation for each interior node $i \\in \\{1, 2, \\dots, N_x-1\\}$ becomes:\n$$ -\\nu u_{i-1}^{n+1} + (1+2\\nu)u_i^{n+1} - \\nu u_{i+1}^{n+1} = \\nu u_{i-1}^n + (1-2\\nu)u_i^n + \\nu u_{i+1}^n + \\frac{\\Delta t}{2}(f_i^{n+1} + f_i^n) $$\n\nThis system of $N_x-1$ linear equations must be solved at each time step. Let $U^n = [u_1^n, u_2^n, \\dots, u_{N_x-1}^n]^T$ be the vector of solutions at the interior nodes at time $t^n$. The system can be written in matrix form as:\n$$ A U^{n+1} = B U^n + d^n $$\nwhere $A$ and $B$ are $(N_x-1) \\times (N_x-1)$ tridiagonal matrices:\n$$ A = \\begin{pmatrix} 1+2\\nu & -\\nu & & \\\\ -\\nu & 1+2\\nu & -\\nu & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & -\\nu & 1+2\\nu & -\\nu \\\\ & & & -\\nu & 1+2\\nu \\end{pmatrix} $$\n$$ B = \\begin{pmatrix} 1-2\\nu & \\nu & & \\\\ \\nu & 1-2\\nu & \\nu & \\\\ & \\ddots & \\ddots & \\ddots \\\\ & & \\nu & 1-2\\nu & \\nu \\\\ & & & \\nu & 1-2\\nu \\end{pmatrix} $$\nThe vector $d^n$ contains the discretized source terms:\n$$ d^n = \\frac{\\Delta t}{2} [f_1^{n+1}+f_1^n, \\dots, f_{N_x-1}^{n+1}+f_{N_x-1}^n]^T $$\nThe homogeneous Dirichlet boundary conditions $u(0,t) = u(1,t) = 0$ imply $u_0^n = u_{N_x}^n = 0$ for all $n$. These conditions are incorporated into the system as the terms involving $u_0$ and $u_{N_x}$ on the boundaries of the stencils for $i=1$ and $i=N_x-1$ are zero.\n\nThe numerical simulation proceeds as follows:\n1.  Initialize the solution at $t=0$ using the exact initial condition: $u_i^0 = u(x_i, 0) = \\sin(\\pi x_i)$ for $i=0, \\dots, N_x$.\n2.  For each time step $n$ from $0$ to $N_t-1$:\n    a.  Construct the RHS vector $RHS = B U^n + d^n$.\n    b.  Solve the linear system $A U^{n+1} = RHS$ for the unknown vector $U^{n+1}$.\n3.  After the final time step, the numerical solution at time $T=t^{N_t}$ is obtained.\n\nThe error is calculated using the discrete $L^2$ norm at the final time $T$:\n$$ E(N_x, N_t) = \\left( \\Delta x \\sum_{i=0}^{N_x} (u_i^{N_t} - u(x_i,T))^2 \\right)^{1/2} $$\nSince the boundary conditions are enforced exactly, the terms for $i=0$ and $i=N_x$ in the sum are zero.\n\nTo verify the order of accuracy, we assume the error follows the form $E \\approx C (\\Delta x)^{p_x} + D (\\Delta t)^{p_t}$.\n-   For the temporal order test ($p_t$), we fix $N_x$ at a large value ($N_x=300$), making the spatial error term negligible. The error is then approximated by $E \\approx D (\\Delta t)^{p_t}$. Taking the logarithm, we have $\\log(E) \\approx \\log(D) + p_t \\log(\\Delta t)$. We perform a linear least-squares fit on the points $(\\log(\\Delta t), \\log(E))$ for a sequence of $N_t$ values. The slope of the resulting line is the estimated order of convergence, $p_t$.\n-   Similarly, for the spatial order test ($p_x$), we fix $N_t$ at a large value ($N_t=1000$) to make the temporal error term negligible. Then $E \\approx C (\\Delta x)^{p_x}$, and $\\log(E) \\approx \\log(C) + p_x \\log(\\Delta x)$. We perform a linear fit on $(\\log(\\Delta x), \\log(E))$ for a sequence of $N_x$ values to find the slope $p_x$.\n\nThe provided parameters are $\\alpha=1$ and $T=0.1$. The implementation will carry out these two convergence studies, compute $p_t$ and $p_x$, and determine a pass/fail flag based on the condition that both orders are at least $1.90$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation with a manufactured solution using the Crank-Nicolson method,\n    and computes the observed orders of convergence in time and space.\n    \"\"\"\n    \n    # --- Fixed Parameters ---\n    alpha = 1.0\n    T = 0.1\n\n    # --- Manufactured Solution and Source Term ---\n    # u(x,t) = exp(t) * sin(pi*x)\n    # f(x,t) = (1 + alpha*pi*pi) * exp(t) * sin(pi*x)\n    \n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    def run_simulation(Nx, Nt, alpha_val, T_final):\n        \"\"\"\n        Runs a single simulation for a given Nx, Nt and returns the L2 error.\n        \"\"\"\n        # Discretization parameters\n        dx = 1.0 / Nx\n        dt = T_final / Nt\n        x = np.linspace(0, 1, Nx + 1)\n        \n        # Grid for interior points\n        x_interior = x[1:Nx]\n\n        # Initial condition\n        u_current = u_exact(x_interior, 0)\n        \n        # Crank-Nicolson matrices A (LHS) and B (RHS) for interior points\n        nu = alpha_val * dt / (2.0 * dx**2)\n        M_interior = Nx - 1\n\n        # Matrix A\n        A = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(A, 1.0 + 2.0 * nu)\n        if M_interior > 1:\n            A_upper = np.diag(-nu * np.ones(M_interior - 1), 1)\n            A_lower = np.diag(-nu * np.ones(M_interior - 1), -1)\n            A += A_upper + A_lower\n\n        # Matrix B\n        B = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(B, 1.0 - 2.0 * nu)\n        if M_interior > 1:\n            B_upper = np.diag(nu * np.ones(M_interior - 1), 1)\n            B_lower = np.diag(nu * np.ones(M_interior - 1), -1)\n            B += B_upper + B_lower\n        \n        # Time-stepping loop\n        for n in range(Nt):\n            t_current = n * dt\n            t_next = (n + 1) * dt\n            \n            # Source term vector\n            f_curr_vals = f_source(x_interior, t_current, alpha_val)\n            f_next_vals = f_source(x_interior, t_next, alpha_val)\n            d = (dt / 2.0) * (f_curr_vals + f_next_vals)\n            \n            # RHS vector\n            rhs = B @ u_current + d\n            \n            # Solve the linear system: A * u_next = rhs\n            u_next = np.linalg.solve(A, rhs)\n            \n            u_current = u_next\n            \n        # At this point, u_current is the numerical solution at t=T\n        u_numerical_final = np.zeros(Nx + 1)\n        u_numerical_final[1:Nx] = u_current\n        \n        # Exact solution at t=T\n        u_exact_final = u_exact(x, T_final)\n        \n        # Compute L2 error\n        error_vec = u_numerical_final - u_exact_final\n        l2_error = np.sqrt(dx * np.sum(error_vec**2))\n        \n        return l2_error\n\n    # --- Temporal Order Test ---\n    Nx_temp_test = 300\n    Nt_temp_list = [50, 100, 200, 400, 800]\n    \n    log_dt_temp = []\n    log_E_temp = []\n    \n    for Nt in Nt_temp_list:\n        error = run_simulation(Nx_temp_test, Nt, alpha, T)\n        dt = T / Nt\n        log_dt_temp.append(np.log(dt))\n        log_E_temp.append(np.log(error))\n        \n    # Least-squares fit to find the slope (order of convergence)\n    p_t = np.polyfit(log_dt_temp, log_E_temp, 1)[0]\n    \n    # --- Spatial Order Test ---\n    Nt_spatial_test = 1000\n    Nx_spatial_list = [10, 20, 40, 80, 160]\n    \n    log_dx_spatial = []\n    log_E_spatial = []\n    \n    for Nx in Nx_spatial_list:\n        error = run_simulation(Nx, Nt_spatial_test, alpha, T)\n        dx = 1.0 / Nx\n        log_dx_spatial.append(np.log(dx))\n        log_E_spatial.append(np.log(error))\n        \n    # Least-squares fit to find the slope\n    p_x = np.polyfit(log_dx_spatial, log_E_spatial, 1)[0]\n    \n    # --- Pass Flag ---\n    pass_flag = (p_t >= 1.90) and (p_x >= 1.90)\n    \n    # --- Final Output ---\n    # Format: [p_t (2dp), p_x (2dp), pass_flag]\n    print(f\"[{p_t:.2f},{p_x:.2f},{pass_flag}]\")\n\nsolve()\n\n```", "id": "3229592"}]}