{"hands_on_practices": [{"introduction": "To begin our exploration of the finite difference method, we start with the most fundamental task: applying the discretized Laplace equation to a simple grid. This first exercise [@problem_id:2172039] will have you manually calculate one iteration of the Jacobi method. By doing so, you will gain a concrete feel for how information from the boundaries propagates into the domain and how the iterative process begins to shape the solution.", "problem": "Consider the problem of determining the electrostatic potential $u(x,y)$ inside a square, charge-free region. The potential satisfies the two-dimensional Laplace equation:\n$$\n\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0\n$$\nThe domain is discretized into a uniform grid of points $(x_i, y_j)$, where $x_i = i \\cdot h$ and $y_j = j \\cdot h$ for $i,j \\in \\{0, 1, 2, 3\\}$. The grid spacing $h$ is constant. This grid results in four interior points: $(x_1, y_1)$, $(x_1, y_2)$, $(x_2, y_1)$, and $(x_2, y_2)$. Let the potential at these grid points be denoted by $u_{ij} = u(x_i, y_j)$.\n\nThe potential on the boundary is fixed. The values at the boundary points adjacent to the interior grid points are given as follows:\n- On the left boundary: $u_{0,1} = 21.0$ V and $u_{0,2} = 21.0$ V.\n- On the right boundary: $u_{3,1} = 41.0$ V and $u_{3,2} = 41.0$ V.\n- On the bottom boundary: $u_{1,0} = 9.0$ V and $u_{2,0} = 9.0$ V.\n- On the top boundary: $u_{1,3} = 81.0$ V and $u_{2,3} = 81.0$ V.\n\nThe Laplace equation is approximated using the standard five-point stencil finite difference formula, which relates the potential at an interior point to its four nearest neighbors. The Jacobi method is used to solve the resulting system of linear equations.\n\nStarting with an initial guess of $u_{ij}^{(0)} = 0$ V for all four interior points (where $i,j \\in \\{1,2\\}$), calculate the numerical values of the potential at these points after one complete iteration of the Jacobi method.\n\nProvide the updated potential values for $u_{11}, u_{12}, u_{21}, u_{22}$ in this specific order. The final answer should be a set of four numbers. Do not include units in your final answer.", "solution": "The two-dimensional Laplace equation discretized with the standard five-point stencil on a uniform grid gives, for an interior node $(i,j)$,\n$$\n\\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{h^{2}}+\\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{h^{2}}=0,\n$$\nwhich simplifies to the averaging relation\n$$\nu_{i,j}=\\frac{1}{4}\\left(u_{i+1,j}+u_{i-1,j}+u_{i,j+1}+u_{i,j-1}\\right).\n$$\nThe Jacobi iteration updates each interior point using neighbors from the previous iterate:\n$$\nu_{i,j}^{(k+1)}=\\frac{1}{4}\\left(u_{i+1,j}^{(k)}+u_{i-1,j}^{(k)}+u_{i,j+1}^{(k)}+u_{i,j-1}^{(k)}\\right),\n$$\nwith boundary values held fixed. With the initial guess $u_{ij}^{(0)}=0$ for $i,j\\in\\{1,2\\}$ and the given boundary data, the first-iteration updates are:\n\nFor $u_{11}$:\n$$\nu_{11}^{(1)}=\\frac{1}{4}\\left(u_{21}^{(0)}+u_{01}+u_{12}^{(0)}+u_{10}\\right)=\\frac{1}{4}\\left(0+21+0+9\\right)=7.5.\n$$\n\nFor $u_{12}$:\n$$\nu_{12}^{(1)}=\\frac{1}{4}\\left(u_{22}^{(0)}+u_{02}+u_{13}+u_{11}^{(0)}\\right)=\\frac{1}{4}\\left(0+21+81+0\\right)=25.5.\n$$\n\nFor $u_{21}$:\n$$\nu_{21}^{(1)}=\\frac{1}{4}\\left(u_{31}+u_{11}^{(0)}+u_{22}^{(0)}+u_{20}\\right)=\\frac{1}{4}\\left(41+0+0+9\\right)=12.5.\n$$\n\nFor $u_{22}$:\n$$\nu_{22}^{(1)}=\\frac{1}{4}\\left(u_{32}+u_{12}^{(0)}+u_{23}+u_{21}^{(0)}\\right)=\\frac{1}{4}\\left(41+0+81+0\\right)=30.5.\n$$\n\nThus, after one Jacobi iteration starting from zero, the updated potentials in the order $(u_{11},u_{12},u_{21},u_{22})$ are $(7.5,25.5,12.5,30.5)$.", "answer": "$$\\boxed{\\begin{pmatrix} 7.5  25.5  12.5  30.5 \\end{pmatrix}}$$", "id": "2172039"}, {"introduction": "Having practiced a single iterative step, we now move to a more comprehensive implementation challenge that incorporates a different type of boundary condition. This problem [@problem_id:3128753] requires you to handle Neumann boundary conditions using the ghost point technique and to confront the critical concept of a solvability condition. This exercise bridges the gap between theoretical understanding and writing robust, functional code for solving partial differential equations.", "problem": "Consider the two-dimensional Laplace equation on a rectangular domain with homogeneous Neumann boundary conditions. The governing equation is $\\nabla^2 u = f$ in a domain $\\Omega = [0,1] \\times [0,1]$, together with the boundary condition $\\partial u / \\partial n = 0$ on $\\partial \\Omega$. Your task is to construct a second-order accurate finite difference discretization of this boundary value problem on a uniform Cartesian grid using ghost points to enforce the homogeneous Neumann condition. The implementation must start from fundamental definitions: the Laplace operator $\\nabla^2$, the central finite difference approximation to second derivatives on a uniform grid, and the Neumann boundary condition expressed as a vanishing normal derivative $\\partial u / \\partial n = 0$ on $\\partial \\Omega$. You must not use any pre-derived stencil formulas; instead, derive the discrete operator using core definitions and logical reasoning.\n\nKey requirements:\n- Use a uniform grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction, with spacings $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$. The unknowns $u_{i,j}$ are defined at the grid points $(x_i, y_j) = (i h_x, j h_y)$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$.\n- Enforce the homogeneous Neumann boundary condition $\\partial u / \\partial n = 0$ on $\\partial \\Omega$ by introducing ghost points outside the domain and eliminating them via the condition that the normal derivative vanishes. This must be integrated into the discrete Laplacian at boundary grid points without introducing any first-order approximations.\n- Recognize and test the solvability condition for the homogeneous Neumann problem. Begin from the fundamental identity that for sufficiently smooth $u$, $\\int_{\\Omega} \\nabla^2 u \\, dV = \\oint_{\\partial \\Omega} \\frac{\\partial u}{\\partial n} \\, dS$, and use it to derive the compatibility condition for $\\nabla^2 u = f$ with $\\partial u / \\partial n = 0$ on $\\partial \\Omega$. Implement a discrete check of this condition using the grid spacing $h_x$, $h_y$, and the discrete sum of $f$ over the grid.\n- Address the non-uniqueness inherent in the homogeneous Neumann problem (solutions determined up to an additive constant) using a principled approach that does not alter the physics, such as fixing a single nodal value of $u$.\n\nImplement a single program that:\n1. Constructs the discrete Laplacian operator with ghost points for homogeneous Neumann boundary conditions on $\\partial \\Omega$.\n2. Assembles the right-hand side vector from a given function $f(x,y)$ evaluated at grid points.\n3. Checks the solvability (compatibility) condition for homogeneous Neumann boundary conditions by computing the discrete approximation to $\\int_{\\Omega} f \\, dV$ as $h_x h_y \\sum_{i,j} f(x_i,y_j)$ and declaring the problem solvable if and only if this quantity is within a tolerance of $10^{-10}$ of $0$.\n4. Solves the resulting linear system after resolving the additive constant non-uniqueness in a principled way, and forms the residual to verify internal consistency. The residual itself does not need to be reported, but the program must perform the solve.\n\nTest suite:\n- Case $1$ (happy path, trivial forcing): $N_x = 8$, $N_y = 8$, $f(x,y) = 0$ for all $(x,y)$. Expect solvability to be declared as true.\n- Case $2$ (happy path, nontrivial compatible forcing): $N_x = 16$, $N_y = 10$, $f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. This forcing has zero integral over $\\Omega$. Expect solvability to be declared as true.\n- Case $3$ (constructed incompatibility): $N_x = 12$, $N_y = 14$, $f(x,y) = 1$ for all $(x,y)$. This violates the compatibility condition. Expect solvability to be declared as false.\n- Case $4$ (edge case with minimal grid, compatibility check): $N_x = 2$, $N_y = 2$, $f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. On this grid the discrete sum of $f$ is zero; expect solvability to be declared as true.\n\nFinal output specification:\n- For each test case, produce a boolean indicating whether the discrete compatibility condition for the homogeneous Neumann problem is satisfied within the specified tolerance, in the order of the cases above.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\texttt{[result1,result2,result3,result4]}$). No units are involved in this purely mathematical problem; angles, if any, are in radians by default.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded, well-posed with the specified constraints, objective, and provides a complete and consistent set of requirements for solving the two-dimensional Poisson equation with homogeneous Neumann boundary conditions using a finite difference method. The problem requests a solution derived from first principles, which is a standard and rigorous exercise in computational science.\n\nHerein, a complete solution is derived, starting from the continuous problem, proceeding to the finite difference discretization with careful treatment of boundary conditions, and culminating in the specification of a numerical algorithm.\n\n### 1. Continuous Problem: Analysis and Compatibility\n\nThe problem is to solve the Poisson equation $\\nabla^2 u = f$ on the unit square domain $\\Omega = [0,1] \\times [0,1]$. The boundary condition is the homogeneous Neumann condition, $\\frac{\\partial u}{\\partial n} = 0$, on the entire boundary $\\partial \\Omega$, where $\\mathbf{n}$ is the outward unit normal vector.\n\nA solvability or compatibility condition must be satisfied for a solution to exist. This condition can be derived from the divergence theorem, which states that for a vector field $\\mathbf{F}$ and a domain $\\Omega$ with boundary $\\partial \\Omega$:\n$$\n\\int_{\\Omega} (\\nabla \\cdot \\mathbf{F}) \\, dV = \\oint_{\\partial \\Omega} \\mathbf{F} \\cdot \\mathbf{n} \\, dS\n$$\nBy setting the vector field $\\mathbf{F} = \\nabla u$, we have $\\nabla \\cdot \\mathbf{F} = \\nabla \\cdot (\\nabla u) = \\nabla^2 u$. The dot product $\\mathbf{F} \\cdot \\mathbf{n} = \\nabla u \\cdot \\mathbf{n}$ is the directional derivative of $u$ in the direction of $\\mathbf{n}$, which is precisely the normal derivative $\\frac{\\partial u}{\\partial n}$.\n\nSubstituting these into the divergence theorem gives:\n$$\n\\int_{\\Omega} \\nabla^2 u \\, dV = \\oint_{\\partial \\Omega} \\frac{\\partial u}{\\partial n} \\, dS\n$$\nUsing the given governing equation $\\nabla^2 u = f$ and the boundary condition $\\frac{\\partial u}{\\partial n} = 0$, we obtain the compatibility condition:\n$$\n\\int_{\\Omega} f \\, dV = \\oint_{\\partial \\Omega} 0 \\, dS = 0\n$$\nThus, a solution to the Neumann problem can exist only if the integral of the source function $f$ over the domain is zero.\n\nFurthermore, if $u(x,y)$ is a solution, then for any constant $C$, the function $v(x,y) = u(x,y) + C$ is also a solution. This is because $\\nabla^2 v = \\nabla^2(u+C) = \\nabla^2 u = f$, and $\\frac{\\partial v}{\\partial n} = \\frac{\\partial (u+C)}{\\partial n} = \\frac{\\partial u}{\\partial n} = 0$. The solution is therefore unique only up to an additive constant. To obtain a unique solution, we must impose an additional constraint, such as fixing the value of $u$ at a specific point.\n\n### 2. Finite Difference Discretization\n\nWe discretize the domain $\\Omega$ using a uniform Cartesian grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction. The grid points are $(x_i, y_j)$, where $x_i = i h_x$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $y_j = j h_y$ for $j \\in \\{0, \\dots, N_y-1\\}$. The grid spacings are $h_x = 1/(N_x-1)$ and $h_y = 1/(N_y-1)$. The value of the function $u$ at a grid point $(x_i, y_j)$ is denoted by $u_{i,j}$.\n\nThe second partial derivatives in the Laplace operator $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ are approximated using second-order accurate central difference formulas:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2}\n$$\nFor an interior grid point $(i,j)$ (where $0  i  N_x-1$ and $0  j  N_y-1$), the discrete Poisson equation is:\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h_x^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h_y^2} = f_{i,j}\n$$\nThis is the standard 5-point stencil for the Laplacian.\n\n### 3. Boundary Conditions via Ghost Points\n\nFor points on the boundary $\\partial \\Omega$, the 5-point stencil involves points outside the domain. We introduce \"ghost points\" and use the boundary conditions to eliminate them, thereby deriving modified stencils for the boundary points.\n\nLet's consider the left boundary at $x=0$ (i.e., for points $(x_0, y_j)$ with $i=0$). The outward normal is $\\mathbf{n}=(-1,0)$, so the condition $\\frac{\\partial u}{\\partial n}=0$ becomes $-\\frac{\\partial u}{\\partial x}=0$. We approximate this derivative at $(x_0, y_j)$ using a second-order central difference:\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{(x_0, y_j)} \\approx \\frac{u(x_1, y_j) - u(x_{-1}, y_j)}{2h_x} = 0\n$$\nThis implies $u(x_{-1}, y_j) = u(x_1, y_j)$. In discrete notation, the ghost point value $u_{-1,j}$ is set equal to the interior point value $u_{1,j}$. We now write the discrete Laplacian at $(x_0, y_j)$:\n$$\n(\\nabla^2 u)_{0,j} \\approx \\frac{u_{1,j} - 2u_{0,j} + u_{-1,j}}{h_x^2} + \\frac{u_{0,j+1} - 2u_{0,j} + u_{0,j-1}}{h_y^2}\n$$\nSubstituting $u_{-1,j} = u_{1,j}$:\n$$\n(\\nabla^2 u)_{0,j} \\approx \\frac{u_{1,j} - 2u_{0,j} + u_{1,j}}{h_x^2} + \\frac{u_{0,j+1} - 2u_{0,j} + u_{0,j-1}}{h_y^2} = \\frac{2u_{1,j} - 2u_{0,j}}{h_x^2} + \\frac{u_{0,j+1} - 2u_{0,j} + u_{0,j-1}}{h_y^2}\n$$\nAnalogous derivations hold for the other three boundaries:\n- Right boundary ($i=N_x-1$): $\\frac{\\partial u}{\\partial x}=0 \\implies u_{N_x,j} = u_{N_x-2,j}$. The Laplacian becomes $\\frac{2u_{N_x-2,j} - 2u_{N_x-1,j}}{h_x^2} + \\dots$\n- Bottom boundary ($j=0$): $\\frac{\\partial u}{\\partial y}=0 \\implies u_{i,-1} = u_{i,1}$. The Laplacian becomes $\\dots + \\frac{2u_{i,1} - 2u_{i,0}}{h_y^2}$.\n- Top boundary ($j=N_y-1$): $\\frac{\\partial u}{\\partial y}=0 \\implies u_{i,N_y} = u_{i,N_y-2}$. The Laplacian becomes $\\dots + \\frac{2u_{i,N_y-2} - 2u_{i,N_y-1}}{h_y^2}$.\n\nFor corner points, both conditions apply. For example, at the bottom-left corner $(i=0, j=0)$:\n$u_{-1,0} = u_{1,0}$ and $u_{0,-1} = u_{0,1}$. The discrete Laplacian is:\n$$\n(\\nabla^2 u)_{0,0} \\approx \\frac{u_{1,0} - 2u_{0,0} + u_{-1,0}}{h_x^2} + \\frac{u_{0,1} - 2u_{0,0} + u_{0,-1}}{h_y^2} = \\frac{2u_{1,0} - 2u_{0,0}}{h_x^2} + \\frac{2u_{0,1} - 2u_{0,0}}{h_y^2}\n$$\n\n### 4. Linear System Formulation\n\nThe set of $N_x \\times N_y$ linear equations can be written in matrix form as $AU = F$. The unknowns $u_{i,j}$ are flattened into a single vector $U$ of size $N=N_x N_y$. We use lexicographical ordering, where the index $k$ for grid point $(i,j)$ is $k = i + j \\cdot N_x$. The vector $F$ is similarly constructed from the values of $f_{i,j}$.\n\nThe matrix $A$ is an $N \\times N$ sparse matrix. The entries of each row $k$ are determined by the stencil for the corresponding grid point $(i,j)$. Let $c_x = 1/h_x^2$ and $c_y = 1/h_y^2$.\n- For an interior point $(i,j)$ where $0  i  N_x-1, 0  j  N_y-1$:\n  $A_{k,k} = -2(c_x+c_y)$, $A_{k,k \\pm 1} = c_x$, $A_{k,k \\pm N_x} = c_y$.\n- For a left-edge point $(i=0, j)$ where $0  j  N_y-1$:\n  $A_{k,k} = -2(c_x+c_y)$, $A_{k,k+1} = 2c_x$, $A_{k,k \\pm N_x} = c_y$.\n- For a bottom-left corner point $(i=0, j=0)$:\n  $A_{k,k} = -2(c_x+c_y)$, $A_{k,k+1} = 2c_x$, $A_{k,k+N_x} = 2c_y$.\n\nA key property of the matrix $A$ for the pure Neumann problem is that the sum of the entries in each row is zero. This implies that the vector $\\mathbf{1}=(1,1,\\dots,1)^T$ is in the null space of $A$, i.e., $A\\mathbf{1} = \\mathbf{0}$. The matrix $A$ is singular.\n\n### 5. Discrete Solvability and System Regularization\n\nThe linear system $AU=F$ has a solution if and only if the right-hand side $F$ is orthogonal to the null space of $A^T$. Since $A$ is symmetric, this means $F$ must be orthogonal to the null space of $A$. Specifically, we need $\\mathbf{1}^T F = 0$, which means $\\sum_{k=0}^{N-1} F_k = 0$, or $\\sum_{i,j} f_{i,j} = 0$. This is the discrete analogue of the continuous compatibility condition $\\int_{\\Omega} f \\, dV = 0$. The problem specifies checking this condition by verifying that $|h_x h_y \\sum_{i,j} f_{i,j}|  10^{-10}$.\n\nTo resolve the non-uniqueness and obtain a solvable, non-singular system, we fix the value of $u$ at one point. A convenient choice is to set $u_{0,0}=0$. This is implemented by modifying the matrix system. The first equation (for $k=0$) is replaced by the constraint $u_{0,0}=0$. In the matrix $A$, the first row is replaced by $(1, 0, \\dots, 0)$, and the first element of $F$ is set to $0$. To ensure the resulting matrix is symmetric (which can be beneficial for some solvers, though not required here), one would also zero out the first column (except for the diagonal). However, for a general-purpose direct solver, modifying only the first row is sufficient to create a non-singular system.\n\nWith this modification, the system becomes uniquely solvable for any $F$ (provided the original compatibility condition held, ensuring consistency).\n\n### 6. Algorithm Summary\n\nFor each test case specified by $(N_x, N_y, f)$:\n1. Define grid parameters: $N=N_x N_y$, $h_x=1/(N_x-1)$, $h_y=1/(N_y-1)$.\n2. Generate the grid coordinates $(x_i, y_j)$ and evaluate the source function $f_{i,j}$ at each point.\n3. Check for solvability: Compute the discrete integral $S = h_x h_y \\sum_{i=0}^{N_x-1} \\sum_{j=0}^{N_y-1} f_{i,j}$. The problem is declared solvable if and only if $|S|  10^{-10}$. The boolean result of this check is stored for the final output.\n4. As per the problem requirements, if the system is solvable, proceed to construct the discrete operator and solve the system.\n   a. Construct the $N \\times N$ matrix $A$ using a sparse matrix format. Populate its entries based on the derived stencils for interior, edge, and corner points.\n   b. Flatten the $f_{i,j}$ grid values into a 1D vector $F$.\n   c. Regularize the system to enforce uniqueness: Set the first row of $A$ to be $(1, 0, \\dots, 0)$ and set the first element of $F$ to $0$.\n   d. Solve the non-singular linear system $AU=F$ for the solution vector $U$.\n\nThe final output consists only of the boolean solvability checks for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef process_case(Nx, Ny, f_func, tolerance=1e-10):\n    \"\"\"\n    Analyzes and solves the 2D Poisson equation with homogeneous Neumann BCs\n    for a given test case.\n    \"\"\"\n    # 1. Define grid parameters and generate the grid\n    if Nx  2 or Ny  2:\n        # Avoid division by zero for hx, hy if grid is too small\n        hx = 1.0 if Nx == 1 else 1.0 / (Nx - 1)\n        hy = 1.0 if Ny == 1 else 1.0 / (Ny - 1)\n    else:\n        hx = 1.0 / (Nx - 1)\n        hy = 1.0 / (Ny - 1)\n\n    x = np.linspace(0, 1, Nx)\n    y = np.linspace(0, 1, Ny)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # 2. Evaluate the source function on the grid\n    f_grid = f_func(xx, yy)\n\n    # 3. Check the discrete compatibility condition\n    # The problem defines the discrete integral as hx * hy * sum(f).\n    # Note: On a 1x1 or 1xN grid, one of hx or hy would be infinite.\n    # The problem cases avoid this, but we handle it for robustness.\n    # For Nx=1 or Ny=1, the area element hx*hy is ill-defined. However,\n    # the test cases are all Nx, Ny >= 2.\n    discrete_integral = hx * hy * np.sum(f_grid)\n    is_solvable = np.abs(discrete_integral)  tolerance\n\n    # Per problem requirements, proceed to solve if compatible.\n    if is_solvable:\n        # The following steps are required by the problem prompt but their\n        # output is not part of the final printed result.\n\n        # 4. Construct the discrete Laplacian operator A\n        N = Nx * Ny\n        A = lil_matrix((N, N), dtype=np.float64)\n        cx = 1.0 / hx**2 if hx > 0 else 0\n        cy = 1.0 / hy**2 if hy > 0 else 0\n\n        for j in range(Ny):\n            for i in range(Nx):\n                k = i + j * Nx\n                \n                # Diagonal term\n                A[k, k] = -2.0 * (cx + cy)\n\n                # Off-diagonal terms based on stencils derived from ghost points\n                # X-direction neighbors\n                if Nx > 1:\n                    if i == 0:  # Left boundary (i=0)\n                        A[k, k + 1] = 2.0 * cx\n                    elif i == Nx - 1:  # Right boundary (i=Nx-1)\n                        A[k, k - 1] = 2.0 * cx\n                    else:  # Interior\n                        A[k, k + 1] = cx\n                        A[k, k - 1] = cx\n\n                # Y-direction neighbors\n                if Ny > 1:\n                    if j == 0:  # Bottom boundary (j=0)\n                        A[k, k + Nx] = 2.0 * cy\n                    elif j == Ny - 1:  # Top boundary (j=Ny-1)\n                        A[k, k - Ny] = 2.0 * cy\n                    else:  # Interior\n                        A[k, k + Ny] = cy\n                        A[k, k - Ny] = cy\n\n        # 5. Assemble the right-hand side vector F\n        F = f_grid.flatten(order='C')\n\n        # 6. Regularize the system to enforce uniqueness\n        # We fix u_0,0 = 0\n        A = A.tocsr() # Convert to CSR for efficient row modification\n        A[0, :] = 0.0\n        A[0, 0] = 1.0\n        F[0] = 0.0\n\n        # 7. Solve the linear system\n        # This step is executed to fulfill the problem requirements.\n        try:\n            # The solve itself validates the setup.\n            _ = spsolve(A, F)\n        except Exception:\n            # This block should not be reached for a well-formed problem.\n            # If it is, something went wrong with the setup,\n            # which might imply the problem was actually unsolvable.\n            # This code path does not affect the official output.\n            pass\n\n\n    return is_solvable\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'Nx': 8, 'Ny': 8, 'f_func': lambda x, y: 0.0 * x},\n        {'Nx': 16, 'Ny': 10, 'f_func': lambda x, y: np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)},\n        {'Nx': 12, 'Ny': 14, 'f_func': lambda x, y: 1.0 + 0.0 * x},\n        {'Nx': 2, 'Ny': 2, 'f_func': lambda x, y: np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case['Nx'], case['Ny'], case['f_func'])\n        results.append(str(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3128753"}, {"introduction": "Once we have a working solver, a crucial question arises in computational science: how does its performance scale as we increase the problem size? This final practice [@problem_id:3128786] guides you to analyze and compare the computational complexity of two powerful solver families: a direct method and a multigrid iterative method. Understanding these scaling laws is essential for predicting performance and selecting the right tool for large-scale scientific simulations.", "problem": "Consider the two-dimensional Laplace equation on the unit square domain with Dirichlet boundary conditions, specified by $\\nabla^2 u = 0$ on $[0,1]\\times[0,1]$ with $u=0$ on the boundary. Using a standard five-point finite difference stencil on a uniform grid, let there be $N$ interior grid points along each axis, producing $M=N^2$ unknowns. The discrete linear system is of the form $A \\mathbf{u} = \\mathbf{b}$, where $A$ is sparse, symmetric positive definite (SPD).\n\nTwo solver families commonly used in computational science laboratories are considered:\n\n- A direct solver based on nested dissection and Cholesky factorization tailored to structured two-dimensional grids.\n- A multigrid V-cycle iterative solver with smoothing operations on each level.\n\nYour task is to reason from first principles about how the number of floating-point operations scales with the grid parameter $N$ for each solver family, and then use these scalings to produce time-to-solution predictions and practical limits. Assume the following modeling constants capturing implementation overheads and per-operation costs:\n- Proportionality constant $\\alpha = 40$ for the direct solver.\n- Proportionality constant $\\beta = 10$ for the multigrid solver.\nBoth constants are dimensionless multipliers on the leading-order scaling you derive.\n\nDefine the sustained floating-point execution rate of the hardware as $r$ (in floating-point operations per second), and define an allowable maximum wall-clock time per solve as $T_{\\max}$ (in seconds). The time to solution $t$ for a given solver model is computed by dividing the total operation count by $r$, and must be expressed in seconds.\n\nFor each test case, your program must:\n1. Compute the predicted time-to-solution for the direct solver, $t_{\\mathrm{direct}}$, in $\\mathrm{s}$.\n2. Compute the predicted time-to-solution for the multigrid solver, $t_{\\mathrm{mg}}$, in $\\mathrm{s}$.\n3. Compute the largest integer $N_{\\max,\\mathrm{direct}}$ such that the predicted time for the direct solver does not exceed $T_{\\max}$.\n4. Compute the largest integer $N_{\\max,\\mathrm{mg}}$ such that the predicted time for the multigrid solver does not exceed $T_{\\max}$.\n\nYou must express all times in seconds, rounded to six decimal places. The output must not include any unit symbols, only numeric values. Angles are not involved, so no angle unit is required.\n\nUse the following test suite, each case given as a triple $(N,r,T_{\\max})$:\n- Case A: $(N = 8,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$.\n- Case B: $(N = 64,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$.\n- Case C: $(N = 256,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$.\n- Case D: $(N = 512,\\ r = 1\\times 10^{11},\\ T_{\\max} = 1)$.\n- Case E (edge case): $(N = 1,\\ r = 1\\times 10^{9},\\ T_{\\max} = 0.1)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a four-element list in the order $[t_{\\mathrm{direct}},t_{\\mathrm{mg}},N_{\\max,\\mathrm{direct}},N_{\\max,\\mathrm{mg}}]$. For example, the overall output format must be\n$[[t_{\\mathrm{direct},A},t_{\\mathrm{mg},A},N_{\\max,\\mathrm{direct},A},N_{\\max,\\mathrm{mg},A}],[t_{\\mathrm{direct},B},t_{\\mathrm{mg},B},N_{\\max,\\mathrm{direct},B},N_{\\max,\\mathrm{mg},B}],\\dots]$,\nwith all numeric entries shown, times rounded to six decimal places, and no extra spaces.\n\nDesign your algorithm and compute the answers by starting from foundational properties of the finite difference method and solver structures, without using shortcut formulas provided to you. All numerical outputs must be either integers or floating-point numbers as specified.", "solution": "The problem statement has been critically examined and is determined to be valid. It is scientifically grounded in established principles of computational science, specifically the numerical solution of partial differential equations. The problem is well-posed, with all necessary data and definitions provided to derive a unique, meaningful solution. The language is objective and the constraints are consistent and physically plausible.\n\nThe task is to analyze the computational complexity of two different solver algorithms for the linear system arising from a finite difference discretization of the two-dimensional Laplace equation, $\\nabla^2 u = 0$. The domain is the unit square $[0,1]\\times[0,1]$ with homogeneous Dirichlet boundary conditions ($u=0$ on the boundary). The discretization uses a standard five-point stencil on a uniform grid with $N$ interior points along each axis, resulting in a system of $M = N^2$ linear equations $A \\mathbf{u} = \\mathbf{b}$. The matrix $A$ is known to be sparse and symmetric positive definite (SPD).\n\nWe first derive the scaling of the number of floating-point operations (FLOPS) with respect to the grid parameter $N$ for each solver family.\n\n**1. Direct Solver: Nested Dissection with Cholesky Factorization**\n\nA direct solver finds the exact solution (up to machine precision) by factoring the matrix $A$. For an SPD matrix, Cholesky factorization ($A=LL^T$) is the method of choice. The computational cost of Cholesky factorization is highly dependent on the ordering of the unknowns, which affects the amount of \"fill-in\"—zero entries in $A$ that become non-zero in the factor $L$.\n\nA simple lexicographical ordering of the grid points results in a matrix $A$ with a bandwidth of approximately $N$. The FLOPS for a banded Cholesky factorization scale as $O(M \\cdot (\\text{bandwidth})^2) = O(N^2 \\cdot N^2) = O(N^4)$.\n\nHowever, the problem specifies the use of **nested dissection**. This is a far more efficient ordering strategy for matrices arising from grid-based problems. The method recursively partitions the grid. For a two-dimensional grid, a \"separator\" of grid points is chosen to divide the grid into two subdomains. The unknowns associated with the separator are ordered last. This process is applied recursively to the subdomains. The resulting matrix structure minimizes fill-in.\n\nFor a 2D problem with $M=N^2$ unknowns, the seminal work by George and Liu showed that the number of operations for Cholesky factorization using nested dissection scales as $O(M^{3/2})$. Expressing this in terms of $N$:\n$$\n\\text{FLOPS}_{\\mathrm{direct}} \\propto M^{3/2} = (N^2)^{3/2} = N^3\n$$\nThe problem provides a dimensionless proportionality constant $\\alpha = 40$ to model implementation-specific overheads. The total operation count, $C_{\\mathrm{direct}}$, is therefore:\n$$\nC_{\\mathrm{direct}}(N) = \\alpha N^3 = 40 N^3\n$$\n\n**2. Iterative Solver: Multigrid V-Cycle**\n\nMultigrid is an advanced iterative method renowned for its optimal efficiency. The fundamental principle is that simple relaxation smoothers (like Jacobi or Gauss-Seidel) are effective at reducing high-frequency components of the error but are very slow to damp low-frequency (smooth) error components. Multigrid methods overcome this by representing the smooth error on coarser grids, where it becomes relatively high-frequency and can be efficiently eliminated.\n\nA single multigrid V-cycle involves:\n- A few pre-smoothing steps on the fine grid.\n- Restricting the residual error to a coarser grid.\n- Recursively calling the solver on the coarse grid problem. This continues until a very coarse grid is reached, where the problem can be solved directly at negligible cost.\n- Prolongating (interpolating) the coarse-grid correction back to the fine grid.\n- A few post-smoothing steps on the fine grid.\n\nThe cost of smoothing, restriction, and prolongation on a grid with $M$ points is proportional to $M$. If the grid size is reduced by a constant factor at each level (typically a factor of $4$ for 2D grids), the total work for one V-cycle, $W(M)$, follows the recurrence $W(M) \\approx cM + W(M/4)$. The solution is a geometric series:\n$$\nW(M) \\approx cM + \\frac{cM}{4} + \\frac{cM}{16} + \\dots = cM \\sum_{k=0}^{\\infty} \\left(\\frac{1}{4}\\right)^k = cM \\frac{1}{1 - 1/4} = \\frac{4}{3}cM\n$$\nThus, the work per V-cycle is $O(M)$. A key theoretical result for multigrid is that for elliptic problems like the Laplace equation, the convergence rate per V-cycle is a constant independent of the grid size $M$. This means a fixed, small number of V-cycles is sufficient to solve the problem to a given accuracy.\n\nTherefore, the total number of operations for a multigrid solver is proportional to the number of unknowns, $M$.\n$$\n\\text{FLOPS}_{\\mathrm{mg}} \\propto M = N^2\n$$\nUsing the provided proportionality constant $\\beta = 10$, the total operation count, $C_{\\mathrm{mg}}$, is:\n$$\nC_{\\mathrm{mg}}(N) = \\beta N^2 = 10 N^2\n$$\n\n**3. Time-to-Solution and Maximum Problem Size**\n\nGiven the hardware's sustained floating-point execution rate, $r$, the time-to-solution, $t$, is the total operation count divided by $r$.\n\nFor the direct solver:\n$$\nt_{\\mathrm{direct}}(N, r) = \\frac{C_{\\mathrm{direct}}(N)}{r} = \\frac{40 N^3}{r}\n$$\nFor the multigrid solver:\n$$\nt_{\\mathrm{mg}}(N, r) = \\frac{C_{\\mathrm{mg}}(N)}{r} = \\frac{10 N^2}{r}\n$$\n\nThe largest integer grid size, $N_{\\max}$, solvable within a maximum wall-clock time $T_{\\max}$ is found by setting $t \\le T_{\\max}$ and solving for $N$.\n\nFor the direct solver, we solve for $N$ in $\\frac{40 N^3}{r} \\le T_{\\max}$:\n$$\nN^3 \\le \\frac{r T_{\\max}}{40} \\implies N \\le \\left( \\frac{r T_{\\max}}{40} \\right)^{1/3}\n$$\nSince $N$ must be an integer, we take the floor of the result:\n$$\nN_{\\max,\\mathrm{direct}} = \\left\\lfloor \\left( \\frac{r T_{\\max}}{40} \\right)^{1/3} \\right\\rfloor\n$$\n\nFor the multigrid solver, we solve for $N$ in $\\frac{10 N^2}{r} \\le T_{\\max}$:\n$$\nN^2 \\le \\frac{r T_{\\max}}{10} \\implies N \\le \\sqrt{\\frac{r T_{\\max}}{10}}\n$$\nAs an integer, $N$ is the floor of the result:\n$$\nN_{\\max,\\mathrm{mg}} = \\left\\lfloor \\sqrt{\\frac{r T_{\\max}}{10}} \\right\\rfloor\n$$\n\nThese formulas are now applied to each test case to compute the required numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes time-to-solution predictions and practical limits for direct\n    and multigrid solvers for the 2D Laplace equation.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (N, r, T_max).\n    test_cases = [\n        # Case A\n        (8, 2e10, 2),\n        # Case B\n        (64, 2e10, 2),\n        # Case C\n        (256, 2e10, 2),\n        # Case D\n        (512, 1e11, 1),\n        # Case E\n        (1, 1e9, 0.1),\n    ]\n\n    # Proportionality constants from the problem.\n    # alpha for the direct solver (scaling with N^3).\n    alpha = 40.0\n    # beta for the multigrid solver (scaling with N^2).\n    beta = 10.0\n\n    all_results = []\n    for case in test_cases:\n        N, r, T_max = case\n\n        # 1. Compute predicted time-to-solution for the direct solver.\n        # Operation count C_direct = alpha * N^3.\n        # Time t_direct = C_direct / r.\n        t_direct = (alpha * N**3) / r\n\n        # 2. Compute predicted time-to-solution for the multigrid solver.\n        # Operation count C_mg = beta * N^2.\n        # Time t_mg = C_mg / r.\n        t_mg = (beta * N**2) / r\n\n        # 3. Compute the largest integer N_max,direct.\n        # We need t_direct = T_max, which is (alpha * N^3) / r = T_max.\n        # This simplifies to N = (r * T_max / alpha)^(1/3).\n        # Since N must be an integer, we take the floor.\n        N_max_direct = int(((r * T_max) / alpha)**(1/3))\n\n        # 4. Compute the largest integer N_max,mg.\n        # We need t_mg = T_max, which is (beta * N^2) / r = T_max.\n        # This simplifies to N = sqrt(r * T_max / beta).\n        # Since N must be an integer, we take the floor.\n        N_max_mg = int(((r * T_max) / beta)**(0.5))\n\n        # Format the case result as a string to exactly match the required output format,\n        # avoiding spaces that str(list) would introduce.\n        # Times are formatted to six decimal places.\n        case_result_str = f\"[{t_direct:.6f},{t_mg:.6f},{N_max_direct},{N_max_mg}]\"\n        all_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The output is a single line: a list of lists, represented as a string.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3128786"}]}