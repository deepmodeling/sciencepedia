{"hands_on_practices": [{"introduction": "The first and most fundamental question to ask of any numerical method is, \"Does it converge to the correct answer as the grid is refined?\" This practice guides you through the essential process of code verification using a known analytical solution. By implementing the explicit scheme and comparing your numerical results against this exact solution, you will measure the error and compute the observed order of convergence, confirming that your implementation is not only correct but also performs with the expected theoretical accuracy [@problem_id:3126907].", "problem": "Consider the one-dimensional heat conduction model based on conservation of energy and Fourierâ€™s law of heat conduction, which leads to the parabolic partial differential equation (PDE)\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2},\n$$\nwhere $u(x,t)$ is the temperature, $x \\in [0,1]$ is the spatial coordinate, $t \\in [0,T]$ is time, and $\\nu$ is the thermal diffusivity. Impose homogeneous Dirichlet boundary conditions, $u(0,t) = 0$ and $u(1,t) = 0$, and choose initial conditions that are finite Fourier sine series on $[0,1]$. For such initial data, each sine mode evolves independently, and the exact solution remains a sine series with exponentially decaying coefficients. Specifically, for initial data\n$$\nu(x,0) = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x),\n$$\nthe exact solution is\n$$\nu(x,t) = \\sum_{k \\in \\mathcal{K}} a_k \\exp\\!\\big(-\\nu (k\\pi)^2 t\\big)\\,\\sin(k\\pi x).\n$$\n\nYour task is to implement a numerical benchmark using a uniform explicit finite difference method that advances in time with a forward difference and approximates the second spatial derivative with a centered difference. This approach is commonly referred to as Forward Time Centered Space (FTCS). Use a uniform spatial grid on $[0,1]$ with $N_x$ intervals (i.e., grid spacing $\\Delta x = 1/N_x$), and time steps $\\Delta t$ chosen via a stability parameter\n$$\nr = \\frac{\\nu \\,\\Delta t}{(\\Delta x)^2},\n$$\nwhich must satisfy $0 < r < \\tfrac{1}{2}$ to maintain numerical stability for the explicit method. Evolve the numerical solution from $t=0$ to $t=T$ by repeating explicit updates. If $T$ is not an integer multiple of $\\Delta t$, use a final partial time step of size $\\Delta t_{\\text{last}} \\in (0,\\Delta t)$ so that the final time is exactly $t=T$, and update using the same explicit method with $r_{\\text{last}} = \\nu \\,\\Delta t_{\\text{last}} / (\\Delta x)^2$.\n\nFor each computation, measure the error at final time $t=T$ using the discrete $L^2$ norm on $[0,1]$ and the discrete $L^\\infty$ norm:\n$$\n\\|e\\|_{L^2} \\approx \\left(\\sum_{j=0}^{N_x} |e_j|^2\\,\\Delta x\\right)^{1/2},\\qquad\n\\|e\\|_{L^\\infty} \\approx \\max_{0 \\le j \\le N_x} |e_j|,\n$$\nwhere $e_j$ is the pointwise error at grid node $x_j = j\\,\\Delta x$ computed as the difference between the numerical solution and the exact solution at $t=T$. Use a sequence of spatial resolutions that halve the grid spacing by doubling $N_x$. Compute the observed convergence rates for the two finest resolutions using\n$$\np_{L^2} = \\frac{\\log\\left(\\|e\\|_{L^2}(\\Delta x_{\\text{coarse}}) / \\|e\\|_{L^2}(\\Delta x_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}}\\right)},\\quad\np_{L^\\infty} = \\frac{\\log\\left(\\|e\\|_{L^\\infty}(\\Delta x_{\\text{coarse}}) / \\|e\\|_{L^\\infty}(\\Delta x_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}}\\right)}.\n$$\n\nImplement the benchmark for the following test suite. In all cases, the spatial domain is $x \\in [0,1]$, boundary conditions are $u(0,t)=u(1,t)=0$, and the initial condition is the specified sine series with amplitudes $a_k$:\n\n- Test Case $1$ (general case with a single mode): $\\nu = 1$, $T = 0.05$, $\\mathcal{K} = \\{1\\}$, $a_1 = 1$, $r = 0.4$, and spatial resolutions $N_x \\in \\{20, 40, 80, 160\\}$.\n- Test Case $2$ (higher-frequency mode): $\\nu = 1$, $T = 0.05$, $\\mathcal{K} = \\{2\\}$, $a_2 = 1$, $r = 0.4$, and spatial resolutions $N_x \\in \\{20, 40, 80, 160\\}$.\n- Test Case $3$ (superposed modes near the stability limit): $\\nu = 0.75$, $T = 0.05$, $\\mathcal{K} = \\{1, 2\\}$, $a_1 = 1$, $a_2 = 0.5$, $r = 0.49$, and spatial resolutions $N_x \\in \\{20, 40, 80, 160\\}$.\n\nYour program must:\n- Construct the exact solution from the specified sine series for each test case.\n- Initialize the numerical solution from the exact initial condition at $t=0$.\n- Advance the numerical solution to $t=T$ using the explicit FTCS method with the given $r$, including a shorter last time step if needed.\n- Compute the discrete $L^2$ and $L^\\infty$ errors at $t=T$ for each spatial resolution.\n- Compute the observed convergence rates $p_{L^2}$ and $p_{L^\\infty}$ using only the two finest resolutions in the set for that test case.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the six results in the order $[p_{L^2}^{(1)}, p_{L^\\infty}^{(1)}, p_{L^2}^{(2)}, p_{L^\\infty}^{(2)}, p_{L^2}^{(3)}, p_{L^\\infty}^{(3)}]$, where the superscript indicates the test case number.\n- Express each rate as a float. No physical units are required because the benchmark is dimensionless.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$).", "solution": "The user-provided problem is assessed to be **valid**. It is scientifically grounded in the principles of heat transfer and numerical analysis, well-posed, objective, and provides a complete and consistent set of requirements for a standard convergence study of the Forward Time Centered Space (FTCS) method for the one-dimensional heat equation.\n\nThe solution proceeds as follows:\nFirst, we discretize the governing partial differential equation (PDE), then implement the numerical scheme, and finally, execute the specified benchmark to compute the convergence rates.\n\n### 1. Discretization of the Heat Equation\n\nThe one-dimensional heat equation is given by\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\non the domain $x \\in [0, 1]$ and $t \\in [0, T]$, with thermal diffusivity $\\nu$. We introduce a uniform spatial grid with $N_x$ intervals, where the grid spacing is $\\Delta x = 1/N_x$. The grid points are $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N_x$. The time domain is discretized with a uniform time step $\\Delta t$, such that $t_n = n \\Delta t$. We denote the numerical approximation of the solution $u(x_j, t_n)$ as $u_j^n$.\n\nThe FTCS method approximates the time and space derivatives as follows:\n- The time derivative $\\frac{\\partial u}{\\partial t}$ is approximated using a first-order forward difference:\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\n$$\n- The second spatial derivative $\\frac{\\partial^2 u}{\\partial x^2}$ is approximated using a second-order centered difference:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\n\nSubstituting these approximations into the heat equation yields the explicit update formula for the FTCS scheme:\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\nu \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\nRearranging for $u_j^{n+1}$, we obtain the update rule for the temperature at the next time step:\n$$\nu_j^{n+1} = u_j^n + \\frac{\\nu \\Delta t}{(\\Delta x)^2} \\left( u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right)\n$$\nIntroducing the stability parameter $r = \\frac{\\nu \\Delta t}{(\\Delta x)^2}$, the equation simplifies to:\n$$\nu_j^{n+1} = u_j^n + r \\left( u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right)\n$$\nThis formula is applied to all interior grid points, i.e., for $j = 1, 2, \\dots, N_x-1$.\n\n### 2. Implementation of Boundary Conditions and Initial State\n\nThe problem specifies homogeneous Dirichlet boundary conditions, $u(0,t) = 0$ and $u(1,t) = 0$. In our discrete framework, this translates to fixing the values at the endpoints of the grid for all time steps:\n$$\nu_0^n = 0 \\quad \\text{and} \\quad u_{N_x}^n = 0 \\quad \\forall n \\ge 0\n$$\nThe initial condition is a finite Fourier sine series:\n$$\nu(x,0) = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x)\n$$\nThe numerical solution is initialized by evaluating this function at each grid point $x_j$ at time $t=0$:\n$$\nu_j^0 = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x_j)\n$$\n\n### 3. Time-Stepping Algorithm\n\nThe numerical solution is advanced from $t=0$ to the final time $t=T$. The time step $\\Delta t$ is determined by the given stability parameter $r$ and the spatial resolution $N_x$: $\\Delta t = r (\\Delta x)^2 / \\nu$.\n\nSince $T$ may not be an integer multiple of $\\Delta t$, the process consists of two stages:\n1.  Calculate the number of full time steps, $N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$. The simulation is run for $N_{\\text{steps}}$ iterations using the standard FTCS update rule.\n2.  Calculate the remaining time, $\\Delta t_{\\text{last}} = T - N_{\\text{steps}} \\Delta t$. If $\\Delta t_{\\text{last}} > 0$, a final, shorter time step is taken. The update rule for this last step uses a modified stability parameter, $r_{\\text{last}} = \\frac{\\nu \\Delta t_{\\text{last}}}{(\\Delta x)^2}$.\n\n### 4. Error Analysis and Convergence Rate\n\nAfter evolving the numerical solution $u_j^{N_{\\text{final}}}$ to $t=T$, we compute the error by comparing it to the exact analytical solution evaluated at the same grid points and final time:\n$$\nu_{\\text{exact}}(x_j, T) = \\sum_{k \\in \\mathcal{K}} a_k \\exp(-\\nu (k\\pi)^2 T) \\sin(k\\pi x_j)\n$$\nThe pointwise error is $e_j = u_j^{N_{\\text{final}}} - u_{\\text{exact}}(x_j, T)$. The error is quantified using two discrete norms:\n- **Discrete $L^2$ norm:** $\\|e\\|_{L^2} = \\left(\\sum_{j=0}^{N_x} |e_j|^2 \\Delta x\\right)^{1/2}$\n- **Discrete $L^\\infty$ norm:** $\\|e\\|_{L^\\infty} = \\max_{0 \\le j \\le N_x} |e_j|$\n\nFor each test case, we compute these errors for a sequence of spatial resolutions $N_x$. The FTCS scheme has a truncation error of $O(\\Delta t + (\\Delta x)^2)$. Since we fix $r$, we have $\\Delta t \\propto (\\Delta x)^2$, making the method second-order accurate in space, i.e., the global error is expected to behave as $O((\\Delta x)^2)$.\n\nThe observed order of convergence, $p$, is computed using the errors from the two finest resolutions (with grid spacings $\\Delta x_{\\text{coarse}}$ and $\\Delta x_{\\text{fine}}$, where $\\Delta x_{\\text{coarse}} = 2 \\Delta x_{\\text{fine}}$):\n$$\np = \\frac{\\log(\\text{error}_{\\text{coarse}} / \\text{error}_{\\text{fine}})}{\\log(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}})} = \\frac{\\log(\\text{error}_{\\text{coarse}} / \\text{error}_{\\text{fine}})}{\\log(2)}\n$$\nThis is calculated for both the $L^2$ and $L^\\infty$ norms. The expected value for $p$ is approximately $2$.\n\nThe final program implements this entire procedure for the three specified test cases, collecting the six convergence rates for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(nu, T, r, initial_cond_coeffs, Nx):\n    \"\"\"\n    Runs a single simulation of the 1D heat equation using the FTCS method.\n\n    Args:\n        nu (float): Thermal diffusivity.\n        T (float): Final time.\n        r (float): Stability parameter r = nu * dt / dx^2.\n        initial_cond_coeffs (dict): Dictionary of {k: a_k} for the initial sine series.\n        Nx (int): Number of spatial intervals.\n\n    Returns:\n        tuple: A tuple containing the discrete L2 error and L-infinity error.\n    \"\"\"\n    # 1. Setup grid and time step\n    dx = 1.0 / Nx\n    x = np.linspace(0.0, 1.0, Nx + 1)\n    dt = r * dx**2 / nu\n\n    # 2. Define exact solution for verification\n    def exact_solution(x_grid, t):\n        sol = np.zeros_like(x_grid, dtype=np.float64)\n        for k, a_k in initial_cond_coeffs.items():\n            sol += a_k * np.exp(-nu * (k * np.pi)**2 * t) * np.sin(k * np.pi * x_grid)\n        return sol\n\n    # 3. Initialize numerical solution from IC\n    u_num = exact_solution(x, 0.0)\n\n    # 4. Time-stepping loop\n    num_steps = int(T / dt)\n    t_current = num_steps * dt\n    \n    # Vectorized FTCS update for full steps\n    for _ in range(num_steps):\n        # u_new = u_num.copy() # Avoids aliasing\n        # u_new[1:-1] = u_num[1:-1] + r * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n        # u_num = u_new\n        # The following is a slightly more memory-efficient version\n        u_num[1:-1] += r * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n\n\n    # Handle final partial time step\n    dt_last = T - t_current\n    if dt_last > 1e-12: # Use a small tolerance to check for non-zero last step\n        r_last = nu * dt_last / dx**2\n        # u_new = u_num.copy()\n        # u_new[1:-1] = u_num[1:-1] + r_last * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n        # u_num = u_new\n        u_num[1:-1] += r_last * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n\n\n    # 5. Compute error at final time T\n    u_ex = exact_solution(x, T)\n    error_vec = u_num - u_ex\n    \n    # Calculate discrete L2 and L-infinity norms\n    err_l2 = np.sqrt(np.sum(error_vec**2) * dx)\n    err_linf = np.max(np.abs(error_vec))\n    \n    return err_l2, err_linf\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"nu\": 1.0, \"T\": 0.05, \"r\": 0.4, \n            \"coeffs\": {1: 1.0}, \n            \"Nx_list\": [20, 40, 80, 160]\n        },\n        {\n            \"nu\": 1.0, \"T\": 0.05, \"r\": 0.4, \n            \"coeffs\": {2: 1.0}, \n            \"Nx_list\": [20, 40, 80, 160]\n        },\n        {\n            \"nu\": 0.75, \"T\": 0.05, \"r\": 0.49, \n            \"coeffs\": {1: 1.0, 2: 0.5},\n            \"Nx_list\": [20, 40, 80, 160]\n        }\n    ]\n\n    all_rates = []\n    \n    for case in test_cases:\n        errors_l2 = []\n        errors_linf = []\n        \n        for Nx in case[\"Nx_list\"]:\n            err_l2, err_linf = run_simulation(\n                case[\"nu\"], case[\"T\"], case[\"r\"], case[\"coeffs\"], Nx\n            )\n            errors_l2.append(err_l2)\n            errors_linf.append(err_linf)\n        \n        # Compute convergence rates using the two finest resolutions\n        # p = log(error_coarse / error_fine) / log(dx_coarse / dx_fine)\n        # Since dx_coarse / dx_fine = 2, the denominator is log(2).\n        \n        # error_coarse is at index -2 (e.g., Nx=80)\n        # error_fine is at index -1 (e.g., Nx=160)\n        p_l2 = np.log(errors_l2[-2] / errors_l2[-1]) / np.log(2.0)\n        p_linf = np.log(errors_linf[-2] / errors_linf[-1]) / np.log(2.0)\n        \n        all_rates.extend([p_l2, p_linf])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{rate:.6f}' for rate in all_rates)}]\")\n\nsolve()\n```", "id": "3126907"}, {"introduction": "A numerically accurate method is only useful if it is also stable. This exercise delves into the crucial concept of numerical stability, linking the mathematical constraints of the explicit method to the physical principle of non-negativity. You will investigate how the time step $\\Delta t$, spatial step $\\Delta x$, and thermal diffusivity $\\alpha$ are related through the Courantâ€“Friedrichsâ€“Lewy (CFL) condition and experimentally observe how violating this condition can lead to non-physical results like negative temperatures [@problem_id:3126925].", "problem": "Consider the one-dimensional heat equation on a finite interval with homogeneous Dirichlet boundary conditions in nondimensional units:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in [0,L], \\ t \\ge 0, \\quad u(0,t)=0,\\ u(L,t)=0,\n$$\nwhere $u(x,t)$ is temperature, $\\alpha > 0$ is thermal diffusivity, and $L>0$ is the domain length. You will construct an explicit finite-difference method using first principles and design a numerical experiment to demonstrate when positivity (non-negativity of the discrete temperature) is lost if the Courantâ€“Friedrichsâ€“Lewy (CFL) condition is violated, and to quantify the largest time step that preserves a discrete maximum principle.\n\nDiscretize the spatial domain with $N$ interior points and two boundary points, so that the spatial grid has indices $i=0,1,2,\\dots,N,N+1$, where $i=0$ and $i=N+1$ are boundaries. Let the spatial step be $\\Delta x = L/(N+1)$. For time, use steps $n=0,1,2,\\dots$ with time step $\\Delta t$. Construct the explicit scheme by approximating the time derivative using the forward difference,\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_n) \\approx \\frac{u_i^{n+1}-u_i^n}{\\Delta t},\n$$\nand approximating the second spatial derivative using the centered difference,\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t_n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.\n$$\nUse the resulting fully explicit method to update interior nodes $i=1,2,\\dots,N$ at each time step $n \\to n+1$.\n\nInitialize the discrete temperature to be nonnegative and highly localized: set $u_i^0=0$ for all $i$ except a single interior index $i^\\star$, where $u_{i^\\star}^0 = 1$. Choose $i^\\star$ to be the interior point closest to the middle of the interval, that is,\n$$\ni^\\star = \\left\\lfloor \\frac{N+1}{2} \\right\\rfloor.\n$$\nThis models a single hot spot in an otherwise cold rod and is a valid nonnegative initial condition.\n\nYour tasks:\n1. From the explicit construction above, determine the precise condition on $\\Delta t$ (as a function of $\\alpha$ and $\\Delta x$) that guarantees that the update at each interior node is a convex combination of nonnegative values, thereby preserving nonnegativity at all subsequent time levels if the initial state is nonnegative. Define the critical time step $\\Delta t_\\star$ to be the largest time step that still preserves this discrete maximum principle.\n2. Design a numerical experiment that, for each given parameter set $(\\alpha,L,N,K)$, does the following three runs starting from the same initial state described above:\n   - A violating time step $\\Delta t_{\\text{bad}} = 1.1 \\, \\Delta t_\\star$ (beyond the threshold).\n   - A borderline time step $\\Delta t_{\\text{border}} = \\Delta t_\\star$ (on the threshold).\n   - A safe time step $\\Delta t_{\\text{good}} = 0.9 \\, \\Delta t_\\star$ (below the threshold).\n   Evolve the explicit scheme for exactly $K$ steps for each of the three choices and, after each step, check whether any component has become strictly negative (i.e., less than $0$). Record a boolean for each run indicating whether negativity was observed at any time during those $K$ steps.\n3. Quantify $\\Delta t_\\star$ from first principles in terms of $\\alpha$ and $\\Delta x$, computed from the given parameters $(\\alpha,L,N)$. Report this value alongside the three booleans for each test.\n\nTest suite:\n- Case $1$: $(\\alpha,L,N,K) = (1,1,50,5)$.\n- Case $2$: $(\\alpha,L,N,K) = (0.5,2,1,3)$.\n- Case $3$: $(\\alpha,L,N,K) = (3,1,20,5)$.\n\nFinal output specification:\n- For each case, output a list with four entries in the order:\n  $[\\text{neg\\_bad}, \\text{neg\\_border}, \\text{neg\\_good}, \\Delta t_\\star]$, where $\\text{neg\\_bad}$, $\\text{neg\\_border}$, and $\\text{neg\\_good}$ are booleans indicating whether negativity was observed for $\\Delta t_{\\text{bad}}$, $\\Delta t_{\\text{border}}$, and $\\Delta t_{\\text{good}}$, respectively, and $\\Delta t_\\star$ is a float.\n- The final program output should be a single line containing a list of the three case-results in order, as a comma-separated list enclosed in square brackets, for example:\n$$\n[\\,[\\text{neg\\_bad}_1,\\text{neg\\_border}_1,\\text{neg\\_good}_1,\\Delta t_{\\star,1}],\\ [\\text{neg\\_bad}_2,\\text{neg\\_border}_2,\\text{neg\\_good}_2,\\Delta t_{\\star,2}],\\ [\\text{neg\\_bad}_3,\\text{neg\\_border}_3,\\text{neg\\_good}_3,\\Delta t_{\\star,3}]\\,].\n$$\nNo physical units are required, as all quantities are nondimensional. Angles are not involved. Percentages must not be used; any fractional factors (such as $0.9$ or $1.1$) should be expressed as decimals in the output if needed.", "solution": "The problem requires the derivation of a stability condition for an explicit finite-difference scheme for the one-dimensional heat equation and the design of a numerical experiment to verify it.\n\n### Step 1: Derivation of the Stability Condition and Critical Time Step $\\Delta t_\\star$\n\nThe governing one-dimensional heat equation is given by:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nwith parameters for thermal diffusivity $\\alpha > 0$ and domain length $L > 0$. The boundary conditions are homogeneous Dirichlet: $u(0,t) = 0$ and $u(L,t) = 0$.\n\nThe problem specifies using a forward difference in time and a centered difference in space. Let $u_i^n$ approximate the solution $u(x_i, t_n)$, where $x_i = i \\Delta x$ and $t_n = n \\Delta t$. The spatial domain $x \\in [0,L]$ is discretized with $N$ interior points, resulting in $N+2$ total grid points indexed $i=0, 1, \\dots, N+1$. The spatial step size is $\\Delta x = L/(N+1)$.\n\nThe specified finite-difference approximations are:\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_n) \\approx \\frac{u_i^{n+1}-u_i^n}{\\Delta t}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t_n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}\n$$\nSubstituting these approximations into the heat equation yields the fully explicit Forward-Time Centered-Space (FTCS) scheme:\n$$\n\\frac{u_i^{n+1}-u_i^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2} \\right)\n$$\nTo find the update rule for $u_i^{n+1}$, we solve for it:\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} (u_{i+1}^n - 2 u_i^n + u_{i-1}^n)\n$$\nLet's define the dimensionless parameter $\\mu$, often called the Courant number for the heat equation:\n$$\n\\mu = \\frac{\\alpha \\Delta t}{\\Delta x^2}\n$$\nThe update equation can be rewritten by grouping terms corresponding to the spatial stencil at time level $n$:\n$$\nu_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n\n$$\nThis equation applies to all interior nodes, $i=1, 2, \\dots, N$.\n\nThe problem asks for the condition that guarantees the preservation of non-negativity. If the initial state $u^0$ is non-negative, i.e., $u_i^0 \\ge 0$ for all $i$, we want to ensure that $u_i^n \\ge 0$ for all subsequent time steps $n > 0$. From the update formula, $u_i^{n+1}$ is a linear combination of its neighbors' values at the previous time step. If all values $u_j^n$ are non-negative, then $u_i^{n+1}$ is guaranteed to be non-negative if and only if all the coefficients in the linear combination are non-negative. This is a sufficient condition for a discrete maximum principle.\n\nThe coefficients are $\\mu$ and $(1 - 2\\mu)$.\n1.  The parameter $\\mu = \\alpha \\Delta t / \\Delta x^2$ is a product of non-negative quantities ($\\alpha>0, \\Delta t>0$), so $\\mu \\ge 0$ is always satisfied.\n2.  The coefficient $(1 - 2\\mu)$ must be non-negative:\n    $$\n    1 - 2\\mu \\ge 0 \\implies 1 \\ge 2\\mu \\implies \\mu \\le \\frac{1}{2}\n    $$\nThis condition, $\\mu \\le 1/2$, is the stability condition for the FTCS scheme for the heat equation. It ensures that the solution does not grow unboundedly and, in this context, preserves non-negativity.\n\nSubstituting the definition of $\\mu$ back into the inequality, we get the condition on the time step $\\Delta t$:\n$$\n\\frac{\\alpha \\Delta t}{\\Delta x^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{\\Delta x^2}{2\\alpha}\n$$\nThe problem defines the critical time step, $\\Delta t_\\star$, as the largest time step that still preserves this principle. This corresponds to the equality in the condition:\n$$\n\\Delta t_\\star = \\frac{\\Delta x^2}{2\\alpha}\n$$\nwhere $\\Delta x = L/(N+1)$.\n\n### Step 2: Design of the Numerical Experiment\n\nThe experiment validates the derived condition by testing three scenarios for the time step $\\Delta t$ relative to $\\Delta t_\\star$:\n-   $\\Delta t_{\\text{bad}} = 1.1 \\, \\Delta t_\\star$: This corresponds to $\\mu = 1.1 \\times 0.5 = 0.55$, which violates the condition $\\mu \\le 0.5$.\n-   $\\Delta t_{\\text{border}} = 1.0 \\, \\Delta t_\\star$: This corresponds to $\\mu = 0.5$, which is on the boundary of the stable region.\n-   $\\Delta t_{\\text{good}} = 0.9 \\, \\Delta t_\\star$: This corresponds to $\\mu = 0.9 \\times 0.5 = 0.45$, which is safely within the stable region.\n\nFor each parameter set $(\\alpha, L, N, K)$:\n1.  Calculate the spatial step size $\\Delta x = L / (N+1)$.\n2.  Calculate the critical time step $\\Delta t_\\star = \\Delta x^2 / (2\\alpha)$.\n3.  For each of the three time steps ($\\Delta t_{\\text{bad}}$, $\\Delta t_{\\text{border}}$, $\\Delta t_{\\text{good}}$), perform a simulation:\n    a. Initialize a one-dimensional array `u` of size $N+2$ to represent the temperature at grid points $i=0, \\dots, N+1$.\n    b. Set the initial condition: `u` is zero everywhere except at the interior index $i^\\star = \\lfloor (N+1)/2 \\rfloor$, where $u_{i^\\star} = 1$. The boundary points $u_0$ and $u_{N+1}$ are always zero.\n    c. Initialize a boolean flag `negativity_observed = False`.\n    d. Evolve the system for $K$ time steps. In each step $n=0, \\dots, K-1$:\n        i.  Compute the next state $u^{n+1}$ from the current state $u^n$ using the update rule $u_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n$ for all interior points $i=1, \\dots, N$.\n        ii. After computing $u^{n+1}$, check if any of its components $u_i^{n+1}$ (for $i=1, \\dots, N$) are strictly negative.\n        iii. If any component is less than $0$, set `negativity_observed = True` and terminate the simulation for this time step.\n    e. Record the final value of `negativity_observed`.\n\n4.  The result for one parameter set is a list containing the three boolean flags and the calculated value of $\\Delta t_\\star$: $[\\text{neg\\_bad}, \\text{neg\\_border}, \\text{neg\\_good}, \\Delta t_\\star]$.\n\nFor the initial condition $u_i^0 = \\delta_{i, i^\\star}$, the first time step updates the point $u_{i^\\star}$ to $u_{i^\\star}^1 = (1 - 2\\mu)u_{i^\\star}^0 = 1 - 2\\mu$. If $\\mu > 0.5$, this value will be negative, and negativity will be observed in the very first step. If $\\mu \\le 0.5$, all coefficients are non-negative, and since the initial state is non-negative, all subsequent states will remain non-negative in exact arithmetic. Therefore, we expect the boolean results to be `[True, False, False]` for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(alpha, L, N, K, dt):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        L (float): Domain length.\n        N (int): Number of interior spatial points.\n        K (int): Number of time steps.\n        dt (float): Time step size.\n\n    Returns:\n        bool: True if negativity is observed, False otherwise.\n    \"\"\"\n    dx = L / (N + 1)\n    \n    # Initialize temperature array u of size N+2 for indices 0 to N+1\n    u = np.zeros(N + 2)\n    \n    # Set initial condition: a single hot spot\n    # Note: problem statement's i_star=floor((N+1)/2) is a 1-based index if interior\n    # points are 1...N. For a 0-indexed array, this corresponds to array index i_star.\n    i_star = int(np.floor((N + 1) / 2))\n    if 1 <= i_star <= N:\n        u[i_star] = 1.0\n\n    mu = alpha * dt / (dx**2)\n    negativity_observed = False\n\n    for _ in range(K):\n        # Create a copy to store the next state\n        u_new = u.copy()\n        \n        # Update interior points using a vectorized operation\n        u_new[1:-1] = mu * u[:-2] + (1 - 2 * mu) * u[1:-1] + mu * u[2:]\n        \n        # The boundary conditions u[0]=0 and u[N+1]=0 are implicitly handled\n        # as u_new is a copy of u and these values don't change.\n        \n        u = u_new\n        \n        # Check for negativity\n        if np.any(u < 0):\n            negativity_observed = True\n            break\n            \n    return negativity_observed\n\ndef analyze_case(alpha, L, N, K):\n    \"\"\"\n    Analyzes one test case for the heat equation stability.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        L (float): Domain length.\n        N (int): Number of interior spatial points.\n        K (int): Number of time steps.\n\n    Returns:\n        list: A list containing [neg_bad, neg_border, neg_good, dt_star].\n    \"\"\"\n    # 1. Calculate the critical time step dt_star\n    dx = L / (N + 1)\n    dt_star = dx**2 / (2 * alpha)\n    \n    # 2. Define the three time steps for the experiment\n    dt_bad = 1.1 * dt_star\n    dt_border = dt_star\n    dt_good = 0.9 * dt_star\n    \n    # 3. Run simulations and record results\n    neg_bad = run_simulation(alpha, L, N, K, dt_bad)\n    neg_border = run_simulation(alpha, L, N, K, dt_border)\n    neg_good = run_simulation(alpha, L, N, K, dt_good)\n    \n    return [neg_bad, neg_border, neg_good, dt_star]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1, 50, 5),    # Case 1: (alpha, L, N, K)\n        (0.5, 2, 1, 3),   # Case 2\n        (3, 1, 20, 5)     # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, N, K = case\n        result = analyze_case(alpha, L, N, K)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) will correctly format each inner list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126925"}, {"introduction": "The physical process of heat conduction naturally smooths out sharp temperature variations over time. This practice explores how the explicit finite difference scheme captures this dissipative behavior by using the powerful tool of Fourier analysis. By analyzing the amplification factor for different Fourier modes, you will quantify the scheme's smoothing rate, gaining a deeper understanding of how it preferentially damps high-frequency components of the solution, which is a key feature of diffusion processes [@problem_id:3126921].", "problem": "You will implement and use an explicit forward-time, centered-space finite difference scheme for the one-dimensional heat equation to measure how rapidly discrete Fourier modes are smoothed. Begin from the heat equation as the fundamental base: the temperature field satisfies $u_t = \\alpha u_{xx}$ on a spatial interval of length $L$ with periodic boundary conditions, where $\\alpha$ is the thermal diffusivity. Consider a uniform grid of $N$ points, with spatial step $\\Delta x = L/N$, and advance in time with step $\\Delta t$, using the explicit forward-in-time update coupled with a centered second-difference approximation for the spatial second derivative. Treat the initial data as a single discrete Fourier mode with integer index $m \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$.\n\nFrom these fundamentals, derive the per-time-step amplification factor for a discrete Fourier mode, and then formulate a computation for the number of time steps required for the magnitude of that mode to be attenuated to at most $e^{-1}$ times its initial magnitude. In this context, interpret attenuation in terms of the magnitude, so oscillatory sign changes are irrelevant. The quantity to output for each case is the smallest integer number of steps $n$ such that the magnitude of the mode after $n$ explicit steps is less than or equal to $e^{-1}$ times the initial magnitude. If attenuation to at most $e^{-1}$ does not occur under the given parameters (for example, the per-step magnitude factor equals $1$), output the IEEE floating-point infinity value. If the magnitude drops to zero in one step, output $1$. All input parameters must be treated in the International System of Units (SI units): $L$ in meters, $\\alpha$ in square meters per second, and $\\Delta t$ in seconds. The output values are dimensionless integers or the floating-point infinity value.\n\nYour program must run with no user input and process the following test suite of parameter sets, each given as $(L, N, \\alpha, \\Delta t, m)$:\n\n- Case $1$: $(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.5,\\,8\\,)$.\n- Case $2$: $(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,1.220703125,\\,32\\,)$.\n- Case $3$: $(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.5,\\,0\\,)$.\n- Case $4$: $(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.01,\\,30\\,)$.\n- Case $5$: $(L, N, \\alpha, \\Delta t, m) = (\\,2,\\,100,\\,1.5\\times 10^{-4},\\,0.2,\\,25\\,)$.\n- Case $6$: $(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.6103515625,\\,32\\,)$.\n\nThese cases test: a general mid-frequency mode where smoothing is evident, a stability boundary case for the highest frequency, the constant mode that does not decay, a small time step causing very slow smoothing, a different grid and parameter set, and a case where the highest frequency is annihilated in one step.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$). The entries must be the smallest integer $n$ per case as specified, or the floating-point infinity value if attenuation to at most $e^{-1}$ never occurs for that case.", "solution": "We start from the heat equation $u_t = \\alpha u_{xx}$ on a spatial interval with periodic boundary conditions. On a uniform grid with $N$ points, spatial step $\\Delta x = L/N$, and time step $\\Delta t$, the explicit forward-time, centered-space finite difference scheme is constructed from core definitions: forward Euler for time and the centered second difference for the Laplacian. Denoting $u_j^n$ as the numerical approximation at grid index $j$ and time level $n$, the update rule is\n$$\nu_j^{n+1} = u_j^n + \\alpha \\Delta t \\,\\frac{u_{j+1}^n - 2 u_j^n + u_{j-1}^n}{(\\Delta x)^2}.\n$$\nDefine the dimensionless ratio\n$$\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}.\n$$\nUnder periodic boundary conditions, the discrete Fourier modes $u_j^n = A^n \\exp\\!\\left(i \\frac{2\\pi m}{N} j\\right)$ are eigenfunctions of the discrete Laplacian operator $u_{j+1} - 2 u_j + u_{j-1}$. Acting on such a mode yields the eigenvalue\n$$\n\\lambda_m = -4 \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right),\n$$\nwhich follows from the identity $\\exp(i\\theta) + \\exp(-i\\theta) - 2 = -4 \\sin^2(\\theta/2)$ with $\\theta = \\frac{2\\pi m}{N}$. Substituting this into the update gives the per-step amplification factor for mode $m$:\n$$\nG_m = 1 + r \\lambda_m = 1 - 4 r \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right).\n$$\nTherefore, after $n$ steps, the modeâ€™s amplitude magnitude is multiplied by $\\lvert G_m \\rvert^n$. To find the number of steps required to attenuate the magnitude to at most $e^{-1}$ times its initial value, we require\n$$\n\\lvert G_m \\rvert^n \\le e^{-1}.\n$$\nTaking natural logarithms when $0 < \\lvert G_m \\rvert < 1$ yields\n$$\nn \\ge \\frac{1}{-\\ln \\lvert G_m \\rvert}.\n$$\nSince the scheme advances in integer time steps, the smallest integer satisfying the inequality is\n$$\nn_{\\min} = \\left\\lceil \\frac{1}{-\\ln \\lvert G_m \\rvert} \\right\\rceil.\n$$\nSpecial cases must be handled carefully:\n- If $m = 0$, then $\\sin^2\\!\\left(\\frac{\\pi m}{N}\\right) = 0$ and $G_0 = 1$, implying no attenuation; we output the floating-point infinity value.\n- If $\\lvert G_m \\rvert = 1$ (for example, $r = \\tfrac{1}{2}$ with $m = \\tfrac{N}{2}$), then there is no attenuation; we output the floating-point infinity value.\n- If $G_m = 0$, then the mode is annihilated in one step; the smallest integer $n$ such that $\\lvert G_m \\rvert^n \\le e^{-1}$ is $n=1$.\n\nAlgorithmic steps for each test case $(L, N, \\alpha, \\Delta t, m)$:\n1. Compute $\\Delta x = L/N$ and $r = \\alpha \\Delta t / (\\Delta x)^2$.\n2. Compute $s = \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right)$ and $G_m = 1 - 4 r s$.\n3. Set $g = \\lvert G_m \\rvert$.\n4. If $g$ is numerically $1$ within a small tolerance, return the floating-point infinity value.\n5. If $g$ is numerically $0$ within a small tolerance, return $1$.\n6. Otherwise, compute $n_{\\min} = \\left\\lceil \\frac{1}{-\\ln g} \\right\\rceil$ and return that integer.\n\nThe provided test suite ensures coverage:\n- Case $1$ tests a mid-frequency mode with clear smoothing ($0 < \\lvert G_m \\rvert < 1$).\n- Case $2$ sets $r=\\tfrac{1}{2}$ and $m=\\tfrac{N}{2}$, yielding $\\lvert G_m \\rvert = 1$ and no attenuation.\n- Case $3$ uses $m=0$ (the constant mode), which does not decay.\n- Case $4$ uses a very small $\\Delta t$, producing slow smoothing with a large $n_{\\min}$.\n- Case $5$ changes $L$, $N$, and $\\alpha$ to demonstrate parameter sensitivity.\n- Case $6$ sets $r=\\tfrac{1}{4}$ and $m=\\tfrac{N}{2}$, giving $G_m=0$ and immediate annihilation in one step.\n\nThe final program computes these quantities and prints a single line with the six results as a comma-separated list within square brackets.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef steps_to_e_minus_one(L, N, alpha, dt, m):\n    \"\"\"\n    Compute the smallest integer number of explicit time steps required\n    to attenuate the magnitude of discrete Fourier mode m by at most e^{-1}.\n    Special cases:\n      - If |G| == 1 (no attenuation), return float('inf').\n      - If |G| == 0 (annihilated in one step), return 1.\n    \"\"\"\n    dx = L / N\n    r = alpha * dt / (dx * dx)\n    s = np.sin(np.pi * m / N) ** 2\n    G = 1.0 - 4.0 * r * s\n    gmag = abs(G)\n\n    # Numerical tolerances to handle floating-point edge cases\n    # Treat values extremely close to 1 as no attenuation and close to 0 as annihilation.\n    if np.isclose(gmag, 1.0, rtol=1e-12, atol=1e-15):\n        return float('inf')\n    if np.isclose(gmag, 0.0, rtol=0.0, atol=1e-15):\n        return 1\n\n    # For 0 < gmag < 1, compute smallest integer n such that gmag^n <= e^{-1}\n    # i.e., n >= 1 / (-ln(gmag)).\n    ln_g = np.log(gmag)\n    if ln_g >= 0.0:\n        # Unstable or no decay (shouldn't occur in our test suite if parameters are stable),\n        # conservatively return infinity.\n        return float('inf')\n\n    n_min = int(np.ceil(1.0 / (-ln_g)))\n    # Ensure at least 1 step when attenuation happens immediately (guard against pathological roundoff).\n    return max(1, n_min)\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each case is a tuple: (L [m], N, alpha [m^2/s], dt [s], m)\n    test_cases = [\n        (1.0, 64, 1e-4, 0.5, 8),\n        (1.0, 64, 1e-4, 1.220703125, 32),\n        (1.0, 64, 1e-4, 0.5, 0),\n        (1.0, 64, 1e-4, 0.01, 30),\n        (2.0, 100, 1.5e-4, 0.2, 25),\n        (1.0, 64, 1e-4, 0.6103515625, 32),\n    ]\n\n    results = []\n    for L, N, alpha, dt, m in test_cases:\n        result = steps_to_e_minus_one(L, N, alpha, dt, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126921"}]}