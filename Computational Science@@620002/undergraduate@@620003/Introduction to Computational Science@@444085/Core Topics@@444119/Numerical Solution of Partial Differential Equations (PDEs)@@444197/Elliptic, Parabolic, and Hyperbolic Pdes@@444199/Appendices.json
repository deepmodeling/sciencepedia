{"hands_on_practices": [{"introduction": "The linear advection equation, $u_t + c u_x = 0$, is the archetypal hyperbolic PDE, modeling the transport of a quantity without change in shape. This exercise invites you to implement the simple first-order upwind scheme to solve it. Through this practice, you will directly observe and quantify a common numerical artifact known as numerical diffusion, where sharp features in the solution are artificially smeared out by the discretization.", "problem": "Consider the linear advection equation $u_t + c\\,u_x = 0$ on the periodic spatial domain $x \\in [0,1)$ with constant wave speed $c > 0$. Let the initial condition be the square wave\n$$\nu(x,0) = \\begin{cases}\n1, & x \\in [0.4,0.6),\\\\\n0, & \\text{otherwise,}\n\\end{cases}\n$$\ninterpreted periodically on $[0,1)$.\n\nDiscretize space with $N$ equally spaced points $x_j = j\\,\\Delta x$ for $j \\in \\{0,1,\\dots,N-1\\}$ and $\\Delta x = 1/N$. Evolve the solution with the first-order upwind finite difference scheme for $c>0$,\n$$\nu_j^{n+1} = u_j^n - \\nu\\,\\big(u_j^n - u_{j-1}^n\\big), \\quad \\nu = \\frac{c\\,\\Delta t}{\\Delta x},\n$$\nusing periodic boundary conditions $u_{-1}^n \\equiv u_{N-1}^n$. Here $u_j^n$ approximates $u(x_j, t^n)$ at time $t^n = n\\,\\Delta t$. The final simulation time is $T>0$. The discrete initial data are $u_j^0 = 1$ if $x_j \\in [0.4,0.6)$ and $u_j^0 = 0$ otherwise.\n\nFor each parameter set in the test suite below, integrate from $t=0$ to $t=T$ with Courant–Friedrichs–Lewy (CFL) number $\\nu \\in (0,1]$ as specified by the parameter set, and with constant $c=1$ unless stated otherwise. If $T/\\Delta t$ is not an integer, take any sequence of time steps whose total equals exactly $T$ and whose individual steps respect the same first-order upwind update with the appropriate $\\nu$ for each step. After reaching time $T$, quantify the smearing of the square wave by the numerical diffusion index\n$$\nD = 1 - \\frac{TV(u^N)}{2}, \\quad TV(u^N) = \\sum_{j=0}^{N-1} \\big|u_{j+1}^N - u_j^N\\big|,\n$$\nwith periodic indexing $u_N^N \\equiv u_0^N$. For an ideal, perfectly sharp, unit-height square wave on a periodic domain, $TV = 2$ and hence $D=0$. Increased smearing corresponds to smaller $TV$ and thus larger $D \\in [0,1]$.\n\nTest suite (each case is $(N,c,\\nu,T)$):\n- Case $1$: $(200,\\,1,\\,1.0,\\,1.0)$,\n- Case $2$: $(200,\\,1,\\,0.9,\\,1.0)$,\n- Case $3$: $(200,\\,1,\\,0.5,\\,1.0)$,\n- Case $4$: $(50,\\,1,\\,0.5,\\,1.0)$,\n- Case $5$: $(200,\\,1,\\,0.1,\\,1.0)$.\n\nYour program must compute $D$ for each case in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[d_1,d_2,d_3,d_4,d_5]$. All quantities are nondimensional; no physical units are required. Angles are not involved. Each result must be a floating-point number.", "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to proceed with a unique and meaningful solution. The problem requires the simulation of the linear advection equation using a first-order upwind finite difference scheme and the quantification of numerical diffusion.\n\nThe governing partial differential equation is the linear advection equation:\n$$ u_t + c\\,u_x = 0 $$\non a periodic spatial domain $x \\in [0,1)$ with a constant wave speed $c > 0$. The exact solution to this equation is a simple translation of the initial profile, $u(x,t) = u_0(x-ct)$, where $u_0(x)$ is the initial condition.\n\nThe solution process involves the following steps:\n\n1.  **Discretization**: The spatial domain $x \\in [0,1)$ is discretized into $N$ equally spaced grid points $x_j = j\\,\\Delta x$ for $j \\in \\{0, 1, \\dots, N-1\\}$, where the grid spacing is $\\Delta x = 1/N$. The time domain is discretized into steps of size $\\Delta t$, such that $t^n = n\\,\\Delta t$. The numerical solution at grid point $x_j$ and time $t^n$ is denoted by $u_j^n$.\n\n2.  **Initial Condition**: The initial condition is a square wave:\n    $$\n    u(x,0) = \\begin{cases}\n    1, & x \\in [0.4, 0.6) \\\\\n    0, & \\text{otherwise}\n    \\end{cases}\n    $$\n    This is translated into discrete initial data $u_j^0$ by setting $u_j^0 = 1$ for all indices $j$ where the grid point $x_j = j/N$ falls within the interval $[0.4, 0.6)$, i.e., for all integers $j$ satisfying $0.4 \\le j/N < 0.6$, which is equivalent to $0.4N \\le j < 0.6N$. For all other indices, $u_j^0 = 0$.\n\n3.  **Numerical Scheme**: The time evolution is governed by the first-order upwind finite difference scheme. For a positive wave speed $c > 0$, the scheme is:\n    $$\n    u_j^{n+1} = u_j^n - \\nu \\left(u_j^n - u_{j-1}^n\\right)\n    $$\n    Here, $\\nu = \\frac{c\\,\\Delta t}{\\Delta x}$ is the Courant–Friedrichs–Lewy (CFL) number. This explicit scheme is stable for $\\nu \\in [0, 1]$. All test cases use $\\nu$ values within this stable range. The periodic boundary condition $u_{-1}^n \\equiv u_{N-1}^n$ is applied. In a vectorized implementation, this is handled efficiently by treating the solution array $u^n$ as a periodic sequence. The term $u_{j-1}^n$ for all $j$ corresponds to a circular shift of the vector $u^n$. The update can be written as $u^{n+1} = u^n - \\nu(u^n - \\text{roll}(u^n, 1))$.\n\n4.  **Time Integration**: We must integrate the solution up to a final time $T$. The time step $\\Delta t$ is determined by the given parameters: $\\Delta t = \\nu \\Delta x / c = \\nu / (Nc)$. The total number of steps, $T/\\Delta t$, may not be an integer. The specified procedure is to perform $N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$ full steps using the Courant number $\\nu$. If there is a remaining time $T_{\\text{rem}} = T - N_{\\text{steps}}\\Delta t > 0$, a final, smaller time step of duration $\\Delta t_{\\text{rem}} = T_{\\text{rem}}$ is taken. For this final step, the corresponding Courant number is $\\nu_{\\text{rem}} = c \\Delta t_{\\text{rem}} / \\Delta x$, and the upwind update rule is applied with this value. This ensures the simulation ends precisely at time $T$.\n\n5.  **Quantification of Numerical Diffusion**: After evolving the solution to time $T$, we compute the numerical diffusion index $D$. This requires calculating the total variation (TV) of the final numerical solution, let's call it $u^{\\text{final}}$:\n    $$\n    TV(u^{\\text{final}}) = \\sum_{j=0}^{N-1} |u_{j+1}^{\\text{final}} - u_j^{\\text{final}}|\n    $$\n    where periodic indexing $u_N^{\\text{final}} \\equiv u_0^{\\text{final}}$ is used. The diffusion index $D$ is then defined as:\n    $$\n    D = 1 - \\frac{TV(u^{\\text{final}})}{2}\n    $$\n    For an ideal, non-diffused square wave of unit height on a periodic domain, there are two jumps of magnitude $1$, one up and one down, so its total variation is $TV=2$. This results in $D=0$. Numerical diffusion smears these sharp jumps, reducing the total variation ($TV < 2$) and thus increasing the diffusion index $D > 0$. A completely smeared-out constant solution would have $TV=0$ and $D=1$.\n\nThe provided Python code implements this entire procedure. For each test case, it sets up the grid and initial condition, performs the time evolution according to the specified stepping logic, calculates the total variation of the final state, computes the diffusion index $D$, and collects the results for final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation for a set of test cases and computes\n    the numerical diffusion index for each.\n    \"\"\"\n    test_cases = [\n        # (N, c, nu, T)\n        (200, 1.0, 1.0, 1.0),\n        (200, 1.0, 0.9, 1.0),\n        (200, 1.0, 0.5, 1.0),\n        (50,  1.0, 0.5, 1.0),\n        (200, 1.0, 0.1, 1.0),\n    ]\n\n    results = []\n    for N, c, nu, T in test_cases:\n        # Spatial discretization\n        delta_x = 1.0 / N\n\n        # Discrete initial condition\n        # u_j^0 = 1 if x_j in [0.4, 0.6)\n        # x_j = j/N => 0.4 <= j/N < 0.6  =>  0.4*N <= j < 0.6*N\n        u = np.zeros(N, dtype=np.float64)\n        j_indices = np.arange(N)\n        mask = (j_indices >= 0.4 * N) & (j_indices < 0.6 * N)\n        u[mask] = 1.0\n\n        # Time stepping parameters\n        # nu = c * delta_t / delta_x  =>  delta_t = nu * delta_x / c\n        # The problem statement ensures c > 0 and nu > 0\n        delta_t = nu * delta_x / c\n\n        num_steps = 0\n        T_rem = T\n        \n        # Check if T is an integer multiple of delta_t\n        if delta_t > 0:\n            num_steps_float = T / delta_t\n            # Use a tolerance for floating point comparison to handle potential precision issues\n            if np.isclose(num_steps_float, np.round(num_steps_float)):\n                num_steps = int(np.round(num_steps_float))\n                T_rem = 0.0\n            else:\n                num_steps = int(np.floor(num_steps_float))\n                T_rem = T - num_steps * delta_t\n        \n        # Time evolution with full steps\n        for _ in range(num_steps):\n            # First-order upwind scheme: u_j^{n+1} = u_j^n - nu * (u_j^n - u_{j-1}^n)\n            # Periodic boundaries are handled by np.roll\n            u_prev = np.roll(u, 1)\n            u = u - nu * (u - u_prev)\n\n        # Final smaller step to reach T exactly, if needed\n        # Use a tolerance to avoid negligible final steps\n        if T_rem > 1e-12:\n            nu_rem = c * T_rem / delta_x\n            u_prev = np.roll(u, 1)\n            u = u - nu_rem * (u - u_prev)\n\n        # Calculate Total Variation (TV)\n        # TV = sum(|u_{j+1} - u_j|) over the periodic domain\n        # u_{j+1} is equivalent to rolling the array left by 1\n        tv = np.sum(np.abs(np.roll(u, -1) - u))\n        \n        # Calculate numerical diffusion index D\n        d = 1.0 - tv / 2.0\n        results.append(d)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393564"}, {"introduction": "Parabolic PDEs, like the heat equation $\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}$, model diffusive processes where sharp features naturally smooth out. The Crank-Nicolson scheme is a popular method for this equation because it is unconditionally stable, suggesting that any time step size can be used without the solution blowing up. However, this practice reveals a crucial subtlety: for non-smooth initial conditions, large time steps can introduce unphysical oscillations, violating the physical constraints of the system even as the solution remains numerically stable.", "problem": "Consider the one-dimensional heat (diffusion) equation on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions,\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t > 0, \\quad u(0,t) = 0, \\ u(1,t) = 0,\n$$\nand a discontinuous initial condition\n$$\nu(x,0) = \\begin{cases}\n1, & x \\in [0.45, 0.55],\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nAll quantities are dimensionless. Use a uniform spatial grid with $N=201$ equally spaced points (including boundaries), so that $\\Delta x = 1/(N-1)$. Let $\\alpha = 1$.\n\nLet $u_i^n$ denote the numerical approximation to $u(x_i,t_n)$ at the interior grid points $x_i = i \\, \\Delta x$ for $i=1,2,\\dots,N-2$ and time level $t_n = n \\, \\Delta t$. Define the Crank–Nicolson finite difference scheme for advancing one time step from $t_n$ to $t_{n+1}$ as the unique solution $u^{n+1}$ of\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\, \\Delta t}{(\\Delta x)^2},\n$$\nwhere $I$ is the identity operator on the interior grid, and $L$ is the standard second-difference operator with homogeneous Dirichlet boundary conditions acting on interior grid values:\n$$\n(L u)_i = u_{i+1} - 2 u_i + u_{i-1}, \\quad i=1,2,\\dots,N-2,\n$$\nwith the understanding that $u_0 = 0$ and $u_{N-1} = 0$ due to the boundary conditions.\n\nFor a given time step $\\Delta t$, define the oscillation amplitude after one Crank–Nicolson time step by\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\nThis quantity is the sum of the overshoot above the physical upper bound $1$ and the undershoot below the physical lower bound $0$ in the interior after a single time step, starting from the specified discontinuous initial condition at $t=0$.\n\nTest Suite:\n- Use $N=201$ and $\\alpha = 1$ as specified.\n- Let $\\Delta x = 1/(N-1)$.\n- Consider the four time steps\n  1. $\\Delta t_1 = 0.2 \\, (\\Delta x)^2 / \\alpha$,\n  2. $\\Delta t_2 = 1.0 \\, (\\Delta x)^2 / \\alpha$,\n  3. $\\Delta t_3 = 5.0 \\, (\\Delta x)^2 / \\alpha$,\n  4. $\\Delta t_4 = 25.0 \\, (\\Delta x)^2 / \\alpha$.\n  \nFor each $\\Delta t_k$, compute $A(\\Delta t_k)$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$, with each value rounded to six decimal places. The output is dimensionless and contains floating-point numbers only.", "solution": "We begin from the heat equation $\\partial_t u = \\alpha \\partial_{xx} u$ on $[0,1]$ with homogeneous Dirichlet boundary conditions and a discontinuous step initial condition confined to $[0.45,0.55]$. The maximum principle for the continuous problem implies that, for $t>0$, the solution remains between $0$ and $1$. However, certain time discretizations, while stable in a norm, are not monotone and can produce nonphysical oscillations such as undershoot (values below $0$) or overshoot (values above $1$) when the initial data has sharp discontinuities. The Crank–Nicolson scheme is a second-order accurate, implicit, unconditionally stable method in the $\\ell^2$ sense, but it is not total variation diminishing nor monotonicity preserving, and can produce such oscillations for sufficiently large time steps.\n\nWe discretize the spatial domain with $N=201$ uniformly spaced nodes, including boundaries, so that $\\Delta x = 1/(N-1)$. We index interior nodes by $i=1,2,\\dots,N-2$ and denote by $u_i^n$ the numerical approximation at $x_i=i\\Delta x$ and time $t_n=n\\Delta t$. The standard centered second-difference operator with homogeneous Dirichlet boundary conditions is defined on interior indices by\n$$\n(Lu)_i = u_{i+1} - 2u_i + u_{i-1}, \\quad i=1,\\dots,N-2,\n$$\nwith boundary values $u_0=0$ and $u_{N-1}=0$ enforced.\n\nThe Crank–Nicolson time-stepping scheme for the semidiscrete system $\\dot{u}=\\alpha \\Delta_x u$ is\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}.\n$$\nOn a one-dimensional uniform grid, this becomes a tridiagonal linear system for $u^{n+1}$ at interior indices. Writing componentwise for $i=1,\\dots,N-2$,\n$$\n-\\frac{r}{2} \\, u_{i-1}^{n+1} + (1+r) \\, u_i^{n+1} - \\frac{r}{2} \\, u_{i+1}^{n+1}\n=\n\\frac{r}{2} \\, u_{i-1}^{n} + (1-r) \\, u_i^{n} + \\frac{r}{2} \\, u_{i+1}^{n},\n$$\nwith boundary contributions vanishing because $u_0^n=u_{N-1}^n=0$.\n\nThe initial data is set by\n$$\nu_i^0 = \\begin{cases}\n1, & x_i \\in [0.45,0.55],\\\\\n0, & \\text{otherwise},\n\\end{cases}\n\\qquad x_i = i \\Delta x, \\quad i=1,\\dots,N-2.\n$$\n\nTo quantify nonphysical oscillations after one time step, we define the amplitude\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\nThe first term measures overshoot beyond the physical bound $1$, and the second term measures undershoot below $0$. For the heat equation with nonnegative, bounded initial data, the exact solution remains in $[0,1]$, so any positive $A(\\Delta t)$ indicates an unphysical oscillation caused by the discrete scheme.\n\nWe now discuss why large $r$ leads to oscillations. The discrete Laplacian $L$ on a uniform grid has eigenmodes resembling discrete sines. For a Fourier component with wavenumber $\\theta$, the discrete Laplacian has eigenvalue $\\lambda_d(\\theta) = -4\\sin^2(\\theta/2)$. The Crank–Nicolson amplification factor for this mode is\n$$\ng(\\theta; r) = \\frac{1 + \\frac{r}{2}\\lambda_d(\\theta)}{1 - \\frac{r}{2}\\lambda_d(\\theta)}\n= \\frac{1 - 2 r \\sin^2(\\theta/2)}{1 + 2 r \\sin^2(\\theta/2)}.\n$$\nFor any $r>0$, we have $|g(\\theta;r)|<1$, ensuring unconditional stability in $\\ell^2$. However, if $2 r \\sin^2(\\theta/2) > 1$, then $g(\\theta;r) < 0$, which flips the sign of those Fourier components in a single time step, generating oscillations near sharp discontinuities where high-frequency content is present. The largest $\\sin^2(\\theta/2)$ is $1$, hence for $r > 1/2$, the highest frequency modes are inverted in sign after one step. Therefore we anticipate negligible oscillations for $r=0.2$, increasing oscillatory undershoot/overshoot for $r=1$, and more pronounced oscillations for $r=5$ and $r=25$.\n\nAlgorithmically, for each specified $\\Delta t_k$ (equivalently $r_k$), we:\n1. Construct $u^0$ from the step initial condition on the interior grid.\n2. Form the tridiagonal system with subdiagonal entries $-r_k/2$, diagonal entries $1+r_k$, and superdiagonal entries $-r_k/2$.\n3. Assemble the right-hand side $(I + \\frac{r_k}{2} L) u^0$ using interior values and $0$ at the boundaries.\n4. Solve the tridiagonal system to obtain $u^1$.\n5. Compute $A(\\Delta t_k)$ as defined above from the interior values of $u^1$.\n6. Repeat for the four test values of $\\Delta t_k$ in the suite.\n\nFinally, we output the list $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$, each rounded to six decimal places, as a single line, comma-separated within brackets. This procedure directly reflects the mathematical structure of the Crank–Nicolson method and quantifies the unphysical oscillations that can arise for large time steps with discontinuous initial data.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_tridiagonal(lower, diag, upper, rhs):\n    \"\"\"\n    Solve a tridiagonal system Ax = rhs with A having\n    lower (a), diagonal (b), and upper (c) diagonals.\n    All inputs are 1D numpy arrays:\n      lower: length n-1\n      diag:  length n\n      upper: length n-1\n      rhs:   length n\n    Returns x of length n.\n    \"\"\"\n    n = diag.size\n    # Copy to avoid modifying inputs\n    a = lower.astype(float).copy()\n    b = diag.astype(float).copy()\n    c = upper.astype(float).copy()\n    d = rhs.astype(float).copy()\n\n    # Forward elimination\n    for i in range(1, n):\n        w = a[i-1] / b[i-1]\n        b[i] = b[i] - w * c[i-1]\n        d[i] = d[i] - w * d[i-1]\n\n    # Back substitution\n    x = np.empty(n, dtype=float)\n    x[-1] = d[-1] / b[-1]\n    for i in range(n-2, -1, -1):\n        x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n\n    return x\n\ndef crank_nicolson_first_step_amplitude(N, alpha, dt):\n    \"\"\"\n    Compute the oscillation amplitude A(dt) after one Crank-Nicolson step\n    for the 1D heat equation on [0,1] with homogeneous Dirichlet BCs and\n    discontinuous initial condition: u(x,0)=1 on [0.45,0.55], 0 otherwise.\n    \"\"\"\n    # Grid setup\n    L = 1.0\n    dx = L / (N - 1)\n    r = alpha * dt / (dx * dx)\n\n    # Interior indices: 1..N-2 (Python 0..M-1)\n    M = N - 2\n    x_interior = np.linspace(dx, L - dx, M)\n\n    # Initial condition on interior: 1 on [0.45,0.55], else 0\n    u0 = np.where((x_interior >= 0.45) & (x_interior <= 0.55), 1.0, 0.0)\n\n    # Build Crank-Nicolson matrices (implicit LHS tridiagonal, RHS vector)\n    # LHS: (I - r/2 * L) => diag: 1 + r; off-diag: -r/2\n    lower = -0.5 * r * np.ones(M - 1)\n    diag = (1.0 + r) * np.ones(M)\n    upper = -0.5 * r * np.ones(M - 1)\n\n    # RHS: (I + r/2 * L) u0 => (1 - r) * u0 + (r/2) * (u0_{i-1} + u0_{i+1})\n    rhs = (1.0 - r) * u0.copy()\n    rhs[:-1] += 0.5 * r * u0[1:]     # contribution from u0_{i+1}\n    rhs[1:]  += 0.5 * r * u0[:-1]    # contribution from u0_{i-1}\n    # Boundary contributions are zero due to homogeneous Dirichlet BCs.\n\n    # Solve for u1\n    u1 = thomas_tridiagonal(lower, diag, upper, rhs)\n\n    # Compute amplitude A(dt) over interior values\n    max_val = float(np.max(u1))\n    min_val = float(np.min(u1))\n    overshoot = max(0.0, max_val - 1.0)\n    undershoot = max(0.0, -min_val)\n    A = overshoot + undershoot\n    return A\n\ndef solve():\n    # Parameters from the problem statement\n    N = 201\n    alpha = 1.0\n    L = 1.0\n    dx = L / (N - 1)\n\n    # Test suite time steps: dt_k = [0.2, 1.0, 5.0, 25.0] * dx^2 / alpha\n    r_values = [0.2, 1.0, 5.0, 25.0]\n    test_dts = [r * dx * dx / alpha for r in r_values]\n\n    results = []\n    for dt in test_dts:\n        A = crank_nicolson_first_step_amplitude(N, alpha, dt)\n        results.append(f\"{A:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2393571"}, {"introduction": "Elliptic PDEs, exemplified by the Poisson equation $-\\nabla^2 u = f$, describe steady-state systems and are fundamental in physics and engineering. A cornerstone of computational science is not just implementing a numerical method, but also verifying that it works correctly. This exercise guides you through this vital process by comparing a standard second-order 5-point stencil with a higher, fourth-order 9-point stencil, allowing you to numerically measure and confirm their theoretical rates of convergence as the grid is refined.", "problem": "Consider the two-dimensional Poisson equation on the unit square domain with homogeneous Dirichlet boundary condition. Let the open domain be $\\Omega = (0,1)\\times(0,1)$ and the boundary be $\\partial\\Omega$. Define the exact solution by $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ for $(x,y)\\in \\overline{\\Omega}$, which is analytic and non-polynomial. The source term is determined from the governing equation $-\\Delta u = f$ in $\\Omega$, with $u = 0$ on $\\partial\\Omega$. \n\na) Derive $f(x,y)$ in closed form from the definition of $u(x,y)$ and the equality $-\\Delta u = f$.\n\nb) For a uniform Cartesian grid with $m$ equal subdivisions per coordinate direction, define the grid spacing $h = 1/m$ and grid nodes $(x_i,y_j) = (i h, j h)$ for $i,j\\in\\{0,1,\\dots,m\\}$. Impose the boundary values by the Dirichlet condition $u(x,y)=0$ on $\\partial\\Omega$, which holds for the exact $u$. For interior nodes, form the discrete linear system corresponding to $-\\Delta u = f$ using both of the following discrete operators for $-\\Delta$ at an interior node $(i,j)$:\n- The standard second-order $5$-point stencil,\n$$\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right).$$\n- The classical fourth-order $9$-point stencil,\n$$\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} - u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big).$$\n\nc) For each chosen $m$, let $u_h^{(5)}$ and $u_h^{(9)}$ denote the numerical solutions on the grid obtained by solving the respective discrete systems with the right-hand side set to $f(x_i,y_j)$ at interior nodes. Construct the full grid function by setting boundary values to the exact $u(x_i,y_j)$ and interior values to the corresponding numerical solution. Define the discrete root-mean-square error (a discrete $L^2$ approximation) for a grid function $w$ relative to the exact $u$ by\n$$E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}.$$\nLet $E^{(5)}(h)$ and $E^{(9)}(h)$ denote these errors for the $5$-point and $9$-point solutions, respectively.\n\nd) For each consecutive pair of grid spacings $(h, h/2)$, define the observed base-$2$ convergence rates by\n$$p^{(5)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(5)}(h)}{E^{(5)}(h/2)}\\right),\\qquad p^{(9)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(9)}(h)}{E^{(9)}(h/2)}\\right).$$\n\nUse the following test suite of subdivision counts: $m\\in\\{2,4,8,16\\}$. For each $m$, use the definition of $u$ to compute $f$ and enforce the boundary condition $u=0$ on $\\partial\\Omega$. For the pairwise refinements $(m,m') = (2,4)$, $(4,8)$, and $(8,16)$, compute the corresponding observed convergence rates.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$.\n\nAll numerical values must be reported as floating-point numbers. No physical units are involved. Angles, if any appear, must be in radians. The final output format must match the specification exactly: a single line with the list in square brackets and values separated by commas.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extracted Givens\n-   **Governing Equation**: The two-dimensional Poisson equation $-\\Delta u = f$ on the open unit square domain $\\Omega = (0,1)\\times(0,1)$.\n-   **Boundary Condition (BC)**: Homogeneous Dirichlet boundary condition, $u = 0$ on the boundary $\\partial\\Omega$.\n-   **Exact Solution**: $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ for $(x,y)\\in \\overline{\\Omega} = [0,1]\\times[0,1]$.\n-   **Source Term**: Defined by the equality $f = -\\Delta u$.\n-   **Discretization**: A uniform Cartesian grid with $m$ subdivisions in each direction, resulting in grid spacing $h = 1/m$ and nodes $(x_i,y_j) = (ih, jh)$ for $i,j\\in\\{0,1,\\dots,m\\}$.\n-   **Discrete Operators**:\n    -   Standard second-order $5$-point stencil for the negative Laplacian: $\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right)$.\n    -   Classical fourth-order $9$-point stencil for the negative Laplacian: $\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big)$.\n-   **Numerical Solution**: $u_h^{(5)}$ and $u_h^{(9)}$ are solutions to the discrete linear systems arising from the stencils. The right-hand side is $f(x_i,y_j)$ at interior nodes. Boundary values are set to $u(x_i,y_j)=0$.\n-   **Error Metric**: Discrete root-mean-square error $E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}$.\n-   **Convergence Rate**: Observed base-$2$ rate $p(h\\to h/2) = \\log_2\\left(\\frac{E(h)}{E(h/2)}\\right)$.\n-   **Test Parameters**: Subdivision counts $m\\in\\{2,4,8,16\\}$.\n-   **Required Output**: A list of numerical values: $[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$.\n\nStep 2: Validation Using Extracted Givens\nThe problem is a standard exercise in the numerical analysis of partial differential equations, specifically the application of finite difference methods to the Poisson equation.\n-   **Scientifically Grounded**: The problem is based on established mathematical principles of numerical analysis and PDEs. The Poisson equation, finite difference stencils, and convergence analysis are all fundamental, well-understood concepts.\n-   **Well-Posed**: The Poisson equation with Dirichlet boundary conditions is a classic example of a well-posed elliptic problem. The resulting discrete linear systems for both stencils correspond to symmetric positive-definite matrices, guaranteeing unique solutions.\n-   **Objective**: The problem is stated in precise, objective mathematical language.\n-   **Consistency Check**: The prescribed exact solution $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ correctly satisfies the homogeneous Dirichlet boundary condition $u=0$ on $\\partial\\Omega$, since $\\sin(\\pi x) = 0$ for $x=0,1$ and $\\sin(\\pi y)=0$ for $y=0,1$.\n-   **Completeness**: All necessary information to formulate and solve the problem is provided.\n\nStep 3: Verdict and Action\nThe problem is valid. It is scientifically sound, well-posed, and self-contained. A complete solution will be provided.\n\n**Part a) Derivation of the Source Term $f(x,y)$**\n\nThe source term $f(x,y)$ is determined by the relation $f = -\\Delta u = -(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2})$. We compute the second partial derivatives of the exact solution $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$.\n\nFirst, the partial derivative with respect to $x$:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) \\right) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) + \\pi \\mathrm{e}^{x+y}\\cos(\\pi x)\\sin(\\pi y) $$\nThe second partial derivative with respect to $x$:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) \\right) \\\\ = \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) + \\mathrm{e}^{x+y}(\\pi\\cos(\\pi x) - \\pi^2\\sin(\\pi x))\\sin(\\pi y) \\\\ = \\mathrm{e}^{x+y}\\sin(\\pi y) \\left[ (1-\\pi^2)\\sin(\\pi x) + 2\\pi\\cos(\\pi x) \\right] $$\nDue to the symmetry of $u(x,y)$ with respect to interchange of $x$ and $y$, the second partial derivative with respect to $y$ is analogous:\n$$ \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y}\\sin(\\pi x) \\left[ (1-\\pi^2)\\sin(\\pi y) + 2\\pi\\cos(\\pi y) \\right] $$\nThe Laplacian $\\Delta u$ is the sum of these second derivatives:\n$$ \\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y} \\left[ 2(1-\\pi^2)\\sin(\\pi x)\\sin(\\pi y) + 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\nFinally, the source term is $f(x,y) = -\\Delta u$:\n$$ f(x,y) = \\mathrm{e}^{x+y} \\left[ 2(\\pi^2-1)\\sin(\\pi x)\\sin(\\pi y) - 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\nThis is the closed-form expression required.\n\n**Part b, c, d) Numerical Solution and Analysis**\n\nThe problem requires solving the linear system $A \\mathbf{u}_h = \\mathbf{b}$ for the unknown values of the numerical solution at the $(m-1)^2$ interior grid points. The vector $\\mathbf{u}_h$ contains the values $u_{i,j}$ for $i,j \\in \\{1, \\dots, m-1\\}$, arranged in lexicographical (column-major) order. The matrix $A$ represents the discrete negative Laplacian operator, and the vector $\\mathbf{b}$ contains the values of the source term $f(x_i, y_j)$ at the interior points.\n\nFor the $5$-point stencil, the matrix $A_5$ corresponding to $(-\\Delta_h^{(5)})$ can be constructed using Kronecker products. Let $T_{1D}$ be the $(m-1) \\times (m-1)$ matrix for the one-dimensional second derivative operator $-\\frac{d^2}{dx^2}$, given by $T_{1D} = \\frac{1}{h^2} \\text{tridiag}(-1, 2, -1)$. Let $I$ be the $(m-1) \\times (m-1)$ identity matrix. Then, the matrix for the two-dimensional operator is:\n$$ A_5 = I \\otimes T_{1D} + T_{1D} \\otimes I $$\n\nFor the $9$-point stencil, the matrix $A_9$ corresponding to $(-\\Delta_h^{(9)})$ has a block-tridiagonal structure $A_9 = \\text{block_tridiag}(B, D, B)$, where the blocks $D$ and $B$ are $(m-1) \\times (m-1)$ matrices:\n$$ D = \\frac{1}{6h^2} \\text{tridiag}(-4, 20, -4) $$\n$$ B = \\frac{1}{6h^2} \\text{tridiag}(-1, -4, -1) $$\nThis structure arises from the coefficients of the stencil coupling nodes within the same grid row (matrix $D$) and between adjacent grid rows (matrix $B$).\n\nThe numerical procedure for each $m \\in \\{2, 4, 8, 16\\}$ is as follows:\n1.  Set the grid spacing $h=1/m$ and define the grid coordinates.\n2.  Construct the sparse matrices $A_5$ and $A_9$ of size $(m-1)^2 \\times (m-1)^2$.\n3.  Construct the right-hand side vector $\\mathbf{b}$ by evaluating $f(x_i, y_j)$ at the $(m-1)^2$ interior grid points.\n4.  Solve the two linear systems $A_5 \\mathbf{u}_h^{(5)} = \\mathbf{b}$ and $A_9 \\mathbf{u}_h^{(9)} = \\mathbf{b}$ to obtain the numerical solutions at the interior points.\n5.  Form the full $(m+1) \\times (m+1)$ grid solutions $u_h^{(5)}$ and $u_h^{(9)}$ by embedding the interior solutions into a grid of zeros, which correctly represents the homogeneous boundary conditions.\n6.  Evaluate the exact solution $u(x,y)$ on the full grid.\n7.  Compute the discrete RMS errors $E^{(5)}(h)$ and $E^{(9)}(h)$ using the specified formula. These errors are stored for each value of $m$.\n8.  After computing errors for all $m$, the observed convergence rates $p^{(5)}$ and $p^{(9)}$ are calculated for each refinement level using the given logarithmic formula.\n\nThe expected convergence rates are $p \\approx 2$ for the second-order $5$-point stencil and $p \\approx 4$ for the fourth-order $9$-point stencil, as these are the theoretical orders of accuracy for the respective discretizations. The numerical experiment serves to verify this theoretical behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation on a unit square using 5-point and 9-point\n    finite difference stencils and computes errors and convergence rates.\n    \"\"\"\n    m_values = [2, 4, 8, 16]\n    errors = {'5': {}, '9': {}}\n\n    def u_exact_func(x, y):\n        \"\"\"Computes the exact solution u(x,y).\"\"\"\n        return np.exp(x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_func(x, y):\n        \"\"\"Computes the source term f(x,y) = -Delta u.\"\"\"\n        term1 = 2 * (np.pi**2 - 1) * np.sin(np.pi * x) * np.sin(np.pi * y)\n        term2 = -2 * np.pi * (np.cos(np.pi * x) * np.sin(np.pi * y) + np.sin(np.pi * x) * np.cos(np.pi * y))\n        return np.exp(x + y) * (term1 + term2)\n\n    for m in m_values:\n        h = 1.0 / m\n        N = m - 1  # Number of interior grid points in one dimension\n\n        # Create the full grid\n        grid_pts = np.linspace(0, 1, m + 1)\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n        # Evaluate exact solution on the full grid\n        u_exact_grid = u_exact_func(X, Y)\n\n        if N == 0: # Trivial case with no interior points\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n        else:\n            N2 = N * N # Total number of unknowns\n\n            # Interior grid points and RHS vector b\n            interior_grid_pts = np.linspace(h, 1 - h, N)\n            XI, YI = np.meshgrid(interior_grid_pts, interior_grid_pts, indexing='ij')\n            # Use Fortran ordering for flattening to match lexicographical (column-major) order\n            b = f_func(XI, YI).flatten(order='F')\n\n            # --- 5-point stencil system ---\n            # A_5 = I kron T + T kron I for -Delta\n            T_1d = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(N, N))\n            I_n = sparse.eye(N)\n            A5 = (1 / h**2) * (sparse.kron(I_n, T_1d) + sparse.kron(T_1d, I_n))\n            \n            u_sol_5_flat = spsolve(A5.tocsc(), b)\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_5[1:-1, 1:-1] = u_sol_5_flat.reshape((N, N), order='F')\n\n            # --- 9-point stencil system ---\n            # Block-tridiagonal construction A_9 = block_tridiag(B, D, B)\n            D_diag_vals = [np.full(N - 1, -4), np.full(N, 20), np.full(N - 1, -4)]\n            D = (1 / (6 * h**2)) * sparse.diags(D_diag_vals, [-1, 0, 1])\n\n            B_diag_vals = [np.full(N - 1, -1), np.full(N, -4), np.full(N - 1, -1)]\n            B = (1 / (6 * h**2)) * sparse.diags(B_diag_vals, [-1, 0, 1])\n            \n            # Off-diagonal blocks for Kronecker sum\n            off_diag_block_matrix = sparse.diags([1, 1], [-1, 1], shape=(N, N))\n            A9 = sparse.kron(I_n, D) + sparse.kron(off_diag_block_matrix, B)\n            \n            u_sol_9_flat = spsolve(A9.tocsc(), b)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n            u_sol_9[1:-1, 1:-1] = u_sol_9_flat.reshape((N, N), order='F')\n\n        # Compute discrete RMS error: E = sqrt(h^2 * sum((w-u)^2))\n        # This is equivalent to h * Frobenius_norm(w-u)\n        diff_5 = u_sol_5 - u_exact_grid\n        errors['5'][m] = h * np.sqrt(np.sum(diff_5**2))\n\n        diff_9 = u_sol_9 - u_exact_grid\n        errors['9'][m] = h * np.sqrt(np.sum(diff_9**2))\n\n    # Calculate convergence rates and assemble final results\n    results = []\n    \n    # E(h=1/2) for m=2\n    results.append(errors['5'][2])\n    results.append(errors['9'][2])\n\n    # p(1/2 -> 1/4) for m=2,4\n    results.append(np.log2(errors['5'][2] / errors['5'][4]))\n    results.append(np.log2(errors['9'][2] / errors['9'][4]))\n\n    # p(1/4 -> 1/8) for m=4,8\n    results.append(np.log2(errors['5'][4] / errors['5'][8]))\n    results.append(np.log2(errors['9'][4] / errors['9'][8]))\n\n    # p(1/8 -> 1/16) for m=8,16\n    results.append(np.log2(errors['5'][8] / errors['5'][16]))\n    results.append(np.log2(errors['9'][8] / errors['9'][16]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393516"}]}