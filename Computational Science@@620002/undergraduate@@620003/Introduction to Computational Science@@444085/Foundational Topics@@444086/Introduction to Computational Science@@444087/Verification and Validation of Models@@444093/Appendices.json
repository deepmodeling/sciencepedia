{"hands_on_practices": [{"introduction": "A crucial step in verifying a numerical simulation is to check if it respects the fundamental physical laws of the system it models. The heat equation, governing diffusion, is a dissipative process where the system's total energy, proportional to $\\int u^2 \\, dx$, should not increase. This exercise [@problem_id:3201887] tasks you with verifying if a Forward-Time Centered-Space (FTCS) scheme for the heat equation upholds this law, providing direct insight into the connection between numerical stability and physical conservation principles.", "problem": "You will implement a numerical verification of a physically motivated property for the one-dimensional heat equation. The fundamental base is the heat equation, which is a linear partial differential equation (PDE) expressing conservation and diffusion of heat. The one-dimensional heat equation with Dirichlet boundary conditions on the spatial interval $[0,1]$ is\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1], \\ t \\ge 0,\n$$\nwith boundary conditions $u(0,t) = 0$ and $u(1,t) = 0$, where $\\nu > 0$ is the diffusion coefficient. A fundamental and well-tested fact about this PDE is that the squared $L^2$ energy,\n$$\nE(t) = \\int_0^1 u(x,t)^2 \\, dx,\n$$\nis non-increasing in time, reflecting physical dissipation.\n\nYour task is to discretize this PDE and verify whether the discrete energy\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} (u_i^n)^2,\n$$\nis monotonic non-increasing over time steps. Use a uniform grid with $N$ points, where $\\Delta x = \\frac{1}{N-1}$, and time step $\\Delta t$. Approximate spatial derivatives by second-order central differences and advance in time using the forward Euler method:\n$$\nu_i^{n+1} = u_i^n + \\alpha\\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right), \\quad i=1,\\dots,N-2,\n$$\nwhere $u_0^n = u_{N-1}^n = 0$ enforce the Dirichlet boundary conditions and $\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$. The discrete energy $E_n$ should be computed at each time step using the interior points $i=1,\\dots,N-2$, with the boundary points set to zero.\n\nImplement a program that, for each provided test case, initializes $u_i^0$ according to the specified initial condition, runs the explicit scheme for $n = 0,1,\\dots,n_{\\text{steps}}$ with $n_{\\text{steps}} = \\left\\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\right\\rfloor$, and checks whether $E_{n+1} \\le E_n$ for all steps within a small numerical tolerance $\\varepsilon = 10^{-12} \\cdot (1 + E_n)$ to account for floating-point roundoff. The program must return a boolean for each test case indicating whether the energy is monotonic non-increasing for the entire simulation.\n\nInitial conditions are defined as follows for spatial grid points $x_i = i \\Delta x$:\n- \"sine\": $u_i^0 = \\sin(\\pi x_i)$.\n- \"highfreq\": $u_i^0 = \\sin(m \\pi x_i)$ with $m = \\left\\lfloor 0.45\\cdot(N-1) \\right\\rfloor$ and $m \\ge 1$.\n- \"zero\": $u_i^0 = 0$.\n\nThe parameter $\\alpha$ determines the time step via $\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$.\n\nTest Suite:\nProvide a program that evaluates the following test cases, each as a tuple $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$:\n1. $(41, 0.1, 0.4, 0.1, \\text{\"sine\"})$.\n2. $(41, 0.1, 0.5, 0.1, \\text{\"sine\"})$.\n3. $(41, 0.1, 0.6, 0.1, \\text{\"highfreq\"})$.\n4. $(5, 1.0, 0.5, 0.5, \\text{\"sine\"})$.\n5. $(21, 0.5, 0.9, 0.1, \\text{\"zero\"})$.\n\nDesign for coverage:\n- Case 1 is a standard stable configuration expected to exhibit energy decay.\n- Case 2 is a boundary stability case.\n- Case 3 uses a larger $\\alpha$ and a high-frequency initial condition that stresses stability and may violate energy monotonicity.\n- Case 4 uses a coarse grid to exercise boundary and discretization handling.\n- Case 5 has zero initial energy and checks trivial monotonicity under potentially unstable parameters.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\"), where each result is a boolean (\"True\" or \"False\") corresponding to the monotonicity check for the respective test case. No physical units are involved, and the answers are booleans only.", "solution": "The problem requires a numerical verification of the energy dissipation property for a finite difference discretization of the one-dimensional heat equation. The continuous problem is given by the partial differential equation (PDE)\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t)\n$$\non the spatial domain $x \\in [0,1]$ with homogeneous Dirichlet boundary conditions $u(0,t) = u(1,t) = 0$. The diffusion coefficient is $\\nu > 0$. A fundamental property of this system is that the total energy, defined by the squared $L^2$-norm $E(t) = \\int_0^1 u(x,t)^2 \\, dx$, is a non-increasing function of time, i.e., $\\frac{dE}{dt} \\le 0$. This reflects the physical principle of heat dissipation in an isolated system with boundaries held at a constant temperature.\n\nWe are tasked to verify if a specific numerical scheme preserves a discrete analog of this property. The spatial domain $[0,1]$ is discretized using a uniform grid with $N$ points, $x_i = i \\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = \\frac{1}{N-1}$. The solution at grid point $x_i$ and time step $n$ is denoted by $u_i^n \\approx u(x_i, n\\Delta t)$.\n\nThe provided numerical scheme is the Forward Time, Centered Space (FTCS) method. The time derivative is approximated by a forward difference, and the spatial second derivative is approximated by a second-order central difference:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\nu \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{\\Delta x^2}.\n$$\nRearranging this equation gives the explicit update rule for the interior grid points ($i=1, \\dots, N-2$):\n$$\nu_i^{n+1} = u_i^n + \\alpha \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right),\n$$\nwhere $\\alpha = \\nu \\frac{\\Delta t}{\\Delta x^2}$ is the dimensionless diffusion number. The boundary conditions are enforced by setting $u_0^n = 0$ and $u_{N-1}^n = 0$ for all time steps $n$.\n\nA crucial aspect of this explicit scheme is its conditional stability. A von Neumann stability analysis shows that the scheme is stable if and only if $\\alpha \\le 0.5$. If this condition is violated ($\\alpha > 0.5$), high-frequency components of the numerical solution are amplified at each time step, leading to exponential growth and a complete departure from the true solution.\n\nThe discrete energy is defined as a numerical quadrature of the continuous energy integral:\n$$\nE_n = \\Delta x \\sum_{i=1}^{N-2} (u_i^n)^2.\n$$\nThis corresponds to a trapezoidal rule approximation of $\\int_0^1 u(x,t)^2 dx$, given that the integrand is zero at the boundaries. Our task is to check whether this discrete energy is monotonically non-increasing for each time step of the simulation, i.e., if $E_{n+1} \\le E_n$ for all $n$. Due to floating-point arithmetic, we must check this inequality with a small tolerance: $E_{n+1} \\le E_n + \\varepsilon$, where $\\varepsilon = 10^{-12} (1 + E_n)$. A failure to meet this condition at any step implies that the energy monotonicity is violated for that test case.\n\nThe algorithm to be implemented for each test case $(N,\\nu,\\alpha,T_{\\text{end}},\\text{initial})$ is as follows:\n1.  Calculate discretization parameters: $\\Delta x = \\frac{1}{N-1}$, $\\Delta t = \\alpha \\frac{\\Delta x^2}{\\nu}$, and the number of time steps $n_{\\text{steps}} = \\lfloor \\frac{T_{\\text{end}}}{\\Delta t} \\rfloor$.\n2.  Initialize the solution vector $u^0$ of size $N$ based on the specified initial condition (\"sine\", \"highfreq\", or \"zero\"). The boundary values $u_0^0$ and $u_{N-1}^0$ are set to $0$.\n3.  Calculate the initial energy $E_0$.\n4.  Iterate for $n$ from $0$ to $n_{\\text{steps}}-1$:\n    a. Compute the solution at the next time step, $u^{n+1}$, using the FTCS update rule for all interior points. The boundary values remain zero.\n    b. Calculate the new energy, $E_{n+1}$.\n    c. Check if $E_{n+1} > E_n + \\varepsilon$. If this condition is met, the property is violated. The result for the test case is `False`, and the simulation for this case can be terminated.\n    d. Update the energy for the next comparison: $E_n \\leftarrow E_{n+1}$.\n5.  If the loop completes without any violation, the property holds, and the result is `True`.\n\nThis procedure will be applied to each test case.\n-   Cases 1, 2, and 4 have $\\alpha \\le 0.5$, so the scheme is stable, and energy monotonicity is expected to hold (`True`). Case 2 represents the stability limit $\\alpha=0.5$.\n-   Case 3 has $\\alpha = 0.6 > 0.5$, which is unstable. The \"highfreq\" initial condition will excite the unstable modes, leading to energy growth (`False`).\n-   Case 5 has $\\alpha = 0.9 > 0.5$ (unstable), but the initial condition is identically zero. For a linear scheme, zero initial data yields a zero solution for all time, assuming no round-off error. Thus, $E_n = 0$ for all $n$, and the condition $E_{n+1} \\le E_n$ is trivially satisfied (`True`).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, nu, alpha, T_end, initial_type):\n    \"\"\"\n    Runs a single simulation of the 1D heat equation and checks for energy monotonicity.\n\n    Args:\n        N (int): Number of grid points.\n        nu (float): Diffusion coefficient.\n        alpha (float): Dimensionless diffusion number.\n        T_end (float): Total simulation time.\n        initial_type (str): Type of initial condition (\"sine\", \"highfreq\", \"zero\").\n\n    Returns:\n        bool: True if discrete energy is monotonically non-increasing, False otherwise.\n    \"\"\"\n    # Step 1: Initialize parameters and grid\n    dx = 1.0 / (N - 1)\n    # Avoid division by zero if nu is zero, though problem states nu > 0\n    if nu == 0:\n        # If nu=0, dt is technically infinite unless alpha=0.\n        # This case is not in the test suite but is a safe guard.\n        if alpha == 0:\n            dt = 0  # No time evolution\n        else:\n            return False # Ill-defined problem\n    else:\n        dt = alpha * dx**2 / nu\n\n    if dt == 0:\n        n_steps = 0\n    else:\n        n_steps = int(T_end / dt)\n\n    x = np.linspace(0.0, 1.0, N)\n    u = np.zeros(N, dtype=np.float64)\n\n    # Step 2: Set initial condition\n    if initial_type == \"sine\":\n        u = np.sin(np.pi * x)\n    elif initial_type == \"highfreq\":\n        m = int(0.45 * (N - 1))\n        # Per problem spec, ensure m >= 1\n        if m < 1:\n            m = 1\n        u = np.sin(m * np.pi * x)\n    elif initial_type == \"zero\":\n        # u is already initialized to zeros\n        pass\n    \n    # Enforce boundary conditions, though initializers above already satisfy them\n    u[0] = 0.0\n    u[-1] = 0.0\n\n    # Step 3: Calculate initial energy\n    E_prev = dx * np.sum(u[1:-1]**2)\n    is_monotonic = True\n\n    # Step 4: Time-stepping loop\n    for _ in range(n_steps):\n        # Create a copy to store the new state\n        u_new = u.copy()\n        \n        # Apply FTCS update rule for interior points\n        u_new[1:-1] = u[1:-1] + alpha * (u[2:] - 2 * u[1:-1] + u[:-2])\n        \n        # Update u for the next iteration\n        u = u_new\n\n        # Calculate new energy\n        E_curr = dx * np.sum(u[1:-1]**2)\n\n        # Check for monotonicity violation with tolerance\n        epsilon = 1e-12 * (1.0 + E_prev)\n        if E_curr > E_prev + epsilon:\n            is_monotonic = False\n            break\n\n        # Update previous energy\n        E_prev = E_curr\n\n    return is_monotonic\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (41, 0.1, 0.4, 0.1, \"sine\"),\n        (41, 0.1, 0.5, 0.1, \"sine\"),\n        (41, 0.1, 0.6, 0.1, \"highfreq\"),\n        (5, 1.0, 0.5, 0.5, \"sine\"),\n        (21, 0.5, 0.9, 0.1, \"zero\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3201887"}, {"introduction": "While global properties like energy are important, the local behavior of a solution is often just as critical. For instance, a model simulating chemical concentration or population density must never produce physically impossible negative values. In this practice [@problem_id:3201856], you will discover that a seemingly reasonable numerical scheme can fail this basic test, and you will compare it with a more robust method that preserves positivity, illustrating a key trade-off between simplicity, accuracy, and physical realism in numerical modeling.", "problem": "You are tasked with verifying positivity-preserving properties of numerical schemes for a one-dimensional concentration field $c(x,t)$ that must satisfy $c(x,t) \\ge 0$ for all $x$ and $t$ when initialized with $c(x,0) \\ge 0$. Your program must implement and test basic schemes for the linear advection equation and the linear diffusion equation on a periodic domain, and then report whether each scheme preserves nonnegativity in practice for a set of carefully chosen test cases designed to challenge positivity. The verification must be conducted purely by numerical experiment, i.e., compute a discretized evolution and test the discrete minimum. All computations are dimensionless and do not require physical units.\n\nFundamental base:\n- The linear advection equation is $c_t + a\\, c_x = 0$, where $a$ is a constant advection speed. If $c(x,0) \\ge 0$ and the boundary conditions are periodic, then the exact solution remains nonnegative for all $t \\ge 0$.\n- The linear diffusion equation is $c_t = D\\, c_{xx}$, where $D$ is a constant diffusivity. If $c(x,0) \\ge 0$ and the boundary conditions are periodic, then the exact solution remains nonnegative for all $t \\ge 0$.\n- Numerical schemes may or may not preserve this nonnegativity; the goal is to empirically verify which schemes do, by constructing tests where naïve choices produce negative values.\n\nDefinitions and discretization framework:\n- Use a periodic domain $x \\in [0,1]$ with $N$ uniformly spaced grid points $x_j = j \\,\\Delta x$ for $j \\in \\{0,1,\\dots,N-1\\}$, where $\\Delta x = 1/N$ and indices wrap around periodically (i.e., use circular indexing).\n- Use forward Euler time stepping with a fixed time step $\\Delta t$ and a specified number of steps $n_{\\text{steps}}$.\n- Implement the following spatial discretizations:\n  - Forward-Time Central-Space (FTCS) scheme for advection: approximate $c_x$ by the central difference on the periodic grid.\n  - Upwind scheme for advection: for $a \\ge 0$, approximate $c_x$ by the backward difference; for $a < 0$, use the forward difference, on the periodic grid.\n  - Explicit central-difference scheme for diffusion: approximate $c_{xx}$ by the second-order central difference on the periodic grid.\n- For advection-diffusion, use operator splitting at each time step: first apply one explicit advection step (FTCS), then apply one explicit diffusion step (central difference), both with the same $\\Delta t$.\n\nVerification criterion:\n- For each test case, initialize $c(x,0)$ as prescribed, evolve for the specified number of steps, and at each step compute the discrete minimum $\\min_j c_j^n$.\n- Declare a test case \"positivity-preserving\" if $\\min_j c_j^n \\ge -\\varepsilon$ for all steps, with a tolerance $\\varepsilon = 10^{-12}$ to account for round-off. Otherwise, declare it \"not positivity-preserving.\" The reported result for each test must be a boolean.\n\nTest suite:\nImplement the following six test cases. In all cases, use periodic boundary conditions and forward Euler time stepping. The domain length is $L = 1$.\n\nLet the top-hat initial condition be\n$$\nc(x,0) = \\begin{cases}\n1 & \\text{if } 0.2 \\le x \\le 0.4,\\\\\n0 & \\text{otherwise}.\n\\end{cases}\n$$\nand the smooth nonnegative initial condition be the sum of Gaussians\n$$\nc(x,0) = \\exp\\!\\left(-\\frac{(x-0.25)^2}{\\sigma^2}\\right) + \\frac{1}{2}\\,\\exp\\!\\left(-\\frac{(x-0.75)^2}{\\sigma^2}\\right),\n$$\nwith $\\sigma = 0.05$.\n\nFor each case, compute $\\Delta x = L/N$ and use the specified rule for $\\Delta t$.\n\n- Test $1$ (Advection FTCS, expected to fail): $N = 200$, $a = 1$, initial top-hat, $\\Delta t = 0.5\\,\\Delta x$, $n_{\\text{steps}} = 80$.\n- Test $2$ (Advection upwind, expected to pass): $N = 200$, $a = 1$, initial top-hat, $\\Delta t = 0.5\\,\\Delta x$, $n_{\\text{steps}} = 80$.\n- Test $3$ (Diffusion explicit stable, expected to pass): $N = 200$, $D = 0.1$, initial smooth Gaussians, set the diffusion ratio $r = D\\,\\Delta t/\\Delta x^2 = 0.49$ so $\\Delta t = r\\,\\Delta x^2/D$, and $n_{\\text{steps}} = 60$.\n- Test $4$ (Diffusion explicit deliberately unstable, expected to fail): $N = 200$, $D = 0.1$, initial top-hat, set $r = D\\,\\Delta t/\\Delta x^2 = 2.0$ so $\\Delta t = r\\,\\Delta x^2/D$, and $n_{\\text{steps}} = 1$.\n- Test $5$ (Advection-diffusion splitting with FTCS advection, expected to fail due to advection): $N = 200$, $a = 1$, $D = 0.005$, initial top-hat, $\\Delta t = 0.1\\,\\Delta x$, $n_{\\text{steps}} = 200$.\n- Test $6$ (Diffusion explicit boundary case at the nonnegativity limit, expected to pass): $N = 200$, $D = 0.1$, initial smooth Gaussians, set $r = D\\,\\Delta t/\\Delta x^2 = 0.5$ so $\\Delta t = r\\,\\Delta x^2/D$, and $n_{\\text{steps}} = 60$.\n\nAcronyms used:\n- Courant–Friedrichs–Lewy (CFL): this is the advection ratio $\\nu = a\\,\\Delta t/\\Delta x$.\n- Forward-Time Central-Space (FTCS): a time–space discretization using forward Euler in time and central differencing in space.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the six tests described above (e.g., $[r_1,r_2,r_3,r_4,r_5,r_6]$ where each $r_k$ is a boolean). No other text should be printed.", "solution": "The problem requires the numerical verification of the positivity-preserving property of several finite difference schemes for linear advection and diffusion equations. The verification is to be conducted through a series of six numerical experiments with specified parameters, initial conditions, and discretization schemes on a one-dimensional periodic domain. A scheme is considered positivity-preserving for a given test if the computed solution $c_j^n$ remains non-negative (within a small tolerance $\\varepsilon$) at all grid points $j$ and for all time steps $n$, given a non-negative initial condition $c_j^0 \\ge 0$.\n\nFirst, we establish the computational framework. The spatial domain is $x \\in [0, 1]$, discretized into $N$ grid points $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 1/N$. Periodicity is handled by using circular indexing, meaning indices are taken modulo $N$. Time is advanced using the explicit forward Euler method with a constant time step $\\Delta t$.\n\nThe two initial conditions are defined as follows:\n1.  The top-hat initial condition is a discontinuous function given by\n    $$\n    c(x,0) = \\begin{cases} 1 & \\text{if } 0.2 \\le x \\le 0.4, \\\\ 0 & \\text{otherwise}. \\end{cases}\n    $$\n    On the discrete grid, this translates to $c_j^0 = 1$ for indices $j$ where $x_j \\in [0.2, 0.4]$, and $c_j^0 = 0$ otherwise.\n2.  The smooth initial condition is a sum of two Gaussians:\n    $$\n    c(x,0) = \\exp\\left(-\\frac{(x-0.25)^2}{\\sigma^2}\\right) + \\frac{1}{2}\\exp\\left(-\\frac{(x-0.75)^2}{\\sigma^2}\\right),\n    $$\n    with $\\sigma = 0.05$. Both initial conditions are non-negative.\n\nNext, we detail the implementation of the specified numerical schemes for a discrete concentration vector $C^n = [c_0^n, c_1^n, \\dots, c_{N-1}^n]^T$. The periodic boundary conditions are efficiently implemented using array-based roll operations, where `numpy.roll(C, 1)` yields the vector of values from the left neighbor ($c_{j-1}$) and `numpy.roll(C, -1)` yields the vector from the right neighbor ($c_{j+1}$).\n\nThe update from time step $n$ to $n+1$ for each scheme is as follows:\n\n**Forward-Time Central-Space (FTCS) for Advection:**\nThe linear advection equation is $c_t + a c_x = 0$. The FTCS scheme uses forward Euler in time and a second-order central difference for the spatial derivative $c_x \\approx (c_{j+1} - c_{j-1})/(2\\Delta x)$. The update rule is:\n$$\nc_j^{n+1} = c_j^n - a \\frac{\\Delta t}{2\\Delta x} (c_{j+1}^n - c_{j-1}^n).\n$$\nThis scheme is known to be unconditionally unstable for the pure advection problem, often leading to non-physical oscillations and violation of positivity.\n\n**Upwind Scheme for Advection:**\nThis scheme uses a one-sided difference for the spatial derivative, chosen based on the sign of the advection speed $a$ to ensure information propagates from the correct \"upwind\" direction.\n- For $a \\ge 0$, a backward difference is used for $c_x \\approx (c_j - c_{j-1})/\\Delta x$:\n  $$\n  c_j^{n+1} = c_j^n - a \\frac{\\Delta t}{\\Delta x} (c_j^n - c_{j-1}^n) = (1 - \\nu) c_j^n + \\nu c_{j-1}^n,\n  $$\n  where $\\nu = a \\Delta t/\\Delta x$ is the Courant number.\n- For $a < 0$, a forward difference is used for $c_x \\approx (c_{j+1} - c_j)/\\Delta x$.\nThe scheme is positivity-preserving if the Courant-Friedrichs-Lewy (CFL) condition $0 \\le |a|\\Delta t/\\Delta x \\le 1$ is satisfied, as the coefficients of $c_j^n$ and its upwind neighbor remain non-negative.\n\n**Explicit Central-Difference Scheme for Diffusion:**\nThe linear diffusion equation is $c_t = D c_{xx}$. Using forward Euler in time and a second-order central difference for the spatial derivative $c_{xx} \\approx (c_{j+1} - 2c_j + c_{j-1})/\\Delta x^2$, the update rule is:\n$$\nc_j^{n+1} = c_j^n + D \\frac{\\Delta t}{\\Delta x^2} (c_{j+1}^n - 2c_j^n + c_{j-1}^n) = r c_{j-1}^n + (1 - 2r) c_j^n + r c_{j+1}^n,\n$$\nwhere $r = D \\Delta t/\\Delta x^2$ is the diffusion number. This scheme is positivity-preserving if and only if all coefficients on the right-hand side are non-negative. Since $r \\ge 0$, this requires $1 - 2r \\ge 0$, which implies the stability condition $r \\le 0.5$.\n\n**Operator Splitting for Advection-Diffusion:**\nFor the combined advection-diffusion equation, the solution is advanced in two stages per time step. First, an advection step is performed, followed by a diffusion step on the result of the advection step:\n$$\nC^* = \\text{AdvectionStep}(C^n, \\Delta t) \\\\\nC^{n+1} = \\text{DiffusionStep}(C^*, \\Delta t)\n$$\nFor the specified test case, the advection step uses the FTCS scheme.\n\nThe verification process for each of the six test cases involves initializing the discrete field $C^0$ and iterating for the specified number of time steps, $n_{\\text{steps}}$. In each iteration $n=0, 1, \\dots, n_{\\text{steps}}-1$, the field $C^{n+1}$ is computed from $C^n$. After each update, the minimum value of the solution, $\\min_j c_j^{n+1}$, is checked. If this minimum ever drops below $-\\varepsilon$ (where $\\varepsilon = 10^{-12}$ is a tolerance for floating-point error), the test is immediately declared as \"not positivity-preserving\" (False). If all time steps are completed without violating this condition, the test is declared \"positivity-preserving\" (True).\n\nThe six test cases are designed to probe the theoretical limits of these schemes:\n- **Test 1:** Uses FTCS for advection, which is expected to fail positivity due to its inherent instability.\n- **Test 2:** Uses the upwind scheme for advection under a stable CFL condition ($\\nu = 0.5$), expected to preserve positivity.\n- **Test 3:** Uses the explicit diffusion scheme with a stable diffusion number ($r = 0.49  0.5$), expected to preserve positivity.\n- **Test 4:** Uses the explicit diffusion scheme with an unstable diffusion number ($r=2.0 > 0.5$), expected to fail positivity.\n- **Test 5:** Uses an operator splitting method where the advection component is FTCS, expected to fail positivity due to the advection scheme.\n- **Test 6:** Uses the explicit diffusion scheme at the boundary of the positivity condition ($r=0.5$), which should be positivity-preserving.\n\nThe program implements these schemes and the testing loop, calculates the boolean result for each case, and formats the final output as a list.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests numerical schemes for positivity preservation.\n    \"\"\"\n    \n    # Global parameters for all tests\n    L = 1.0\n    EPSILON = 1e-12\n\n    def ic_top_hat(x, N):\n        \"\"\"Generates a top-hat initial condition.\"\"\"\n        c0 = np.zeros(N)\n        # Note: x is vector of grid cell centers, so x = 0.4 is fine.\n        c0[(x = 0.2)  (x = 0.4)] = 1.0\n        return c0\n\n    def ic_smooth_gaussians(x, N, sigma=0.05):\n        \"\"\"Generates a sum of Gaussians initial condition.\"\"\"\n        term1 = np.exp(-((x - 0.25)**2) / sigma**2)\n        term2 = 0.5 * np.exp(-((x - 0.75)**2) / sigma**2)\n        return term1 + term2\n\n    # --- Numerical schemes ---\n    def advection_ftcs_step(c, a, dx, dt):\n        \"\"\"One step of the FTCS advection scheme.\"\"\"\n        c_jp1 = np.roll(c, -1)\n        c_jm1 = np.roll(c, 1)\n        nu_half = a * dt / (2.0 * dx)\n        c_new = c - nu_half * (c_jp1 - c_jm1)\n        return c_new\n\n    def advection_upwind_step(c, a, dx, dt):\n        \"\"\"One step of the upwind advection scheme.\"\"\"\n        nu = a * dt / dx\n        if a = 0:\n            c_jm1 = np.roll(c, 1)\n            c_new = c - nu * (c - c_jm1)\n        else:\n            c_jp1 = np.roll(c, -1)\n            c_new = c - nu * (c_jp1 - c)\n        return c_new\n\n    def diffusion_explicit_step(c, D, dx, dt):\n        \"\"\"One step of the explicit central-difference diffusion scheme.\"\"\"\n        c_jp1 = np.roll(c, -1)\n        c_jm1 = np.roll(c, 1)\n        r = D * dt / (dx**2)\n        c_new = c + r * (c_jp1 - 2 * c + c_jm1)\n        return c_new\n    \n    # --- Test case definitions ---\n    test_cases = [\n        {'id': 1, 'N': 200, 'scheme': 'advection_ftcs', 'ic': 'top_hat', 'params': {'a': 1.0}, 'dt_def': ('const_mult', 0.5), 'n_steps': 80},\n        {'id': 2, 'N': 200, 'scheme': 'advection_upwind', 'ic': 'top_hat', 'params': {'a': 1.0}, 'dt_def': ('const_mult', 0.5), 'n_steps': 80},\n        {'id': 3, 'N': 200, 'scheme': 'diffusion_explicit', 'ic': 'smooth_gaussians', 'params': {'D': 0.1}, 'dt_def': ('diffusion_r', 0.49), 'n_steps': 60},\n        {'id': 4, 'N': 200, 'scheme': 'diffusion_explicit', 'ic': 'top_hat', 'params': {'D': 0.1}, 'dt_def': ('diffusion_r', 2.0), 'n_steps': 1},\n        {'id': 5, 'N': 200, 'scheme': 'split_advection_diffusion', 'ic': 'top_hat', 'params': {'a': 1.0, 'D': 0.005}, 'dt_def': ('const_mult', 0.1), 'n_steps': 200},\n        {'id': 6, 'N': 200, 'scheme': 'diffusion_explicit', 'ic': 'smooth_gaussians', 'params': {'D': 0.1}, 'dt_def': ('diffusion_r', 0.5), 'n_steps': 60},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        dx = L / N\n        x = np.arange(N) * dx\n\n        # Define dt based on the rule\n        dt_type, dt_val = case['dt_def']\n        if dt_type == 'const_mult': # dt = val * dx\n            dt = dt_val * dx\n        elif dt_type == 'diffusion_r': # r = D*dt/dx^2 = val\n            D_param = case['params']['D']\n            dt = dt_val * dx**2 / D_param\n        else:\n            raise ValueError(f\"Unknown dt_def type: {dt_type}\")\n\n        # Initialize concentration field\n        if case['ic'] == 'top_hat':\n            c = ic_top_hat(x, N)\n        elif case['ic'] == 'smooth_gaussians':\n            c = ic_smooth_gaussians(x, N)\n        \n        positivity_preserved = True\n        \n        # Time-stepping loop\n        for _ in range(case['n_steps']):\n            if case['scheme'] == 'advection_ftcs':\n                c = advection_ftcs_step(c, case['params']['a'], dx, dt)\n            elif case['scheme'] == 'advection_upwind':\n                c = advection_upwind_step(c, case['params']['a'], dx, dt)\n            elif case['scheme'] == 'diffusion_explicit':\n                c = diffusion_explicit_step(c, case['params']['D'], dx, dt)\n            elif case['scheme'] == 'split_advection_diffusion':\n                c_star = advection_ftcs_step(c, case['params']['a'], dx, dt)\n                c = diffusion_explicit_step(c_star, case['params']['D'], dx, dt)\n            \n            if np.min(c)  -EPSILON:\n                positivity_preserved = False\n                break\n        \n        results.append(positivity_preserved)\n\n    # Format and print final results\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3201856"}, {"introduction": "The ultimate test of verification is to compare a numerical simulation against a known exact solution. While rarely possible for complex industrial problems, this technique is essential for validating numerical methods on canonical equations like the inviscid Burgers' equation, a cornerstone for understanding nonlinear waves and shock formation. This advanced exercise [@problem_id:3201943] guides you through implementing a shock-capturing finite volume scheme and measuring its performance against the exact Riemann solution, offering a direct, quantitative measure of your model's ability to handle one of the most challenging features in computational fluid dynamics.", "problem": "You are asked to construct a program that verifies the shock-capturing capability of a first-order finite volume scheme for the one-dimensional inviscid Burgers equation, viewed as a nonlinear conservation law, by comparing computed numerical solutions against exact Riemann solutions for step initial data. Your design must proceed from fundamental definitions: conservation form, flux evaluation, Rankine–Hugoniot jump condition, and entropy-admissible self-similar solutions. Do not use any pre-derived formulas beyond those principles. Implement the following, keeping everything dimensionless.\n\nCore model and verification objective:\n- Consider the one-dimensional inviscid Burgers equation in conservation form\n  $$u_t + \\left(f(u)\\right)_x = 0,$$\n  where the flux is given by $$f(u) = \\tfrac{1}{2} u^2.$$\n- Use a Riemann initial condition with a single discontinuity located at a point $$x_0 \\in \\mathbb{R}:$$\n  $$u(x,0) = \\begin{cases}\n  u_L,  x  x_0,\\\\\n  u_R,  x  x_0.\n  \\end{cases}$$\n- For validation, compare the numerical solution to the exact entropy solution of the Riemann problem constructed from the conservation law, the Rankine–Hugoniot condition for shocks, and the self-similar rarefaction solution where appropriate.\n- For verification, quantify the difference using the discrete $$L^1$$ error at a specified final time $$T  0,$$ and, for shock cases, additionally estimate the shock location numerically and compare to the exact shock position.\n\nNumerical method to implement:\n- Use a first-order explicit finite volume method on a uniform grid with $$N$$ cells over a domain $$[x_{\\min}, x_{\\max}].$$\n- Let $$\\Delta x = (x_{\\max} - x_{\\min}) / N$$ and advance in time with explicit forward Euler using a time step $$\\Delta t$$ satisfying the Courant–Friedrichs–Lewy (CFL) condition:\n  $$\\Delta t \\le \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max_i |u_i|},$$\n  where $$u_i$$ are the cell averages. Choose the Courant–Friedrichs–Lewy (CFL) number as specified in the test suite below.\n- Use the Godunov numerical flux for the inviscid Burgers equation at each cell interface to ensure the correct entropy solution is selected. Implement transmissive (outflow) boundary conditions by copying boundary cell values into ghost states at each time step.\n- Stop at time $$T$$, clipping the last step so that the final time is exactly $$T.$$\n\nExact solution and error metrics:\n- Construct the exact Riemann solution at time $$t = T$$ using:\n  - The Rankine–Hugoniot condition for shocks for $$u_L  u_R,$$ with the exact shock located at $$x_s(T)$$.\n  - The self-similar rarefaction fan for $$u_L  u_R,$$ based on characteristics.\n- Compute the discrete $$L^1$$ error:\n  $$E_{L^1} = \\sum_{i=1}^{N} \\left| u_i^{\\text{num}}(T) - u_i^{\\text{exact}}(T) \\right| \\Delta x.$$\n- For shock cases, estimate the numerical shock position $$\\hat{x}_s(T)$$ by locating where the numerical solution crosses the midpoint state $$\\tfrac{u_L + u_R}{2}$$ and linearly interpolating between neighboring cells; if no sign change is detected, fall back to the position of the largest magnitude discrete gradient. Report the absolute position error $$| \\hat{x}_s(T) - x_s(T) |.$$\n\nGrid, domain, and time:\n- Use the spatial domain $$[x_{\\min}, x_{\\max}] = [-1, 1],$$ discontinuity position $$x_0 = 0,$$ and the final time $$T = 0.2.$$\n- Unless explicitly stated by a test case, use $$\\mathrm{CFL} = 0.9.$$\n\nTest suite:\nImplement the five test cases below. Each case defines input parameters and specifies the single scalar result to be reported for that case. All computations are dimensionless.\n\n1. Shock, error at moderate resolution (happy path):\n   - Parameters: $$u_L = 2.0, \\; u_R = 0.0, \\; x_0 = 0.0, \\; N = 200, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the $$L^1$$ error $$E_{L^1}$$ as a float.\n\n2. Shock, observed convergence under refinement:\n   - Parameters: same as Case 1 but compute with both $$N = 200$$ and $$N = 400.$$\n   - Output: an integer indicator that equals $$1$$ if the $$L^1$$ error at $$N = 400$$ is strictly smaller than at $$N = 200,$$ and $$0$$ otherwise.\n\n3. Rarefaction, error at moderate resolution:\n   - Parameters: $$u_L = 0.0, \\; u_R = 2.0, \\; x_0 = 0.0, \\; N = 400, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the $$L^1$$ error $$E_{L^1}$$ as a float.\n\n4. Constant state preservation (edge case):\n   - Parameters: $$u_L = 1.0, \\; u_R = 1.0, \\; x_0 = 0.0, \\; N = 200, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the maximum absolute deviation of the numerical solution from $$1.0$$ at time $$T,$$ reported as a float.\n\n5. Left-moving shock, shock position accuracy:\n   - Parameters: $$u_L = 0.0, \\; u_R = -2.0, \\; x_0 = 0.0, \\; N = 300, \\; T = 0.2, \\; \\mathrm{CFL} = 0.9.$$\n   - Output: the absolute error in the shock position $$| \\hat{x}_s(T) - x_s(T) |,$$ reported as a float.\n\nRequired final output format:\n- Your program must produce a single line containing a Python-style list with exactly five entries corresponding to the five test cases in order.\n- Floats must be rounded to six decimal places and printed in fixed-point notation without scientific notation.\n- The convergence indicator in Case 2 must be printed as an integer $$0$$ or $$1.$$\n- Example format (values shown are placeholders): \"[0.012345,1,0.006789,0.000000,0.004321]\".", "solution": "This problem requires verifying a first-order finite volume scheme for the one-dimensional inviscid Burgers' equation, $u_t + (\\frac{1}{2}u^2)_x = 0$, against its exact Riemann solutions. This involves several key components: constructing the exact solution, implementing the numerical scheme with a Godunov flux, and defining appropriate error metrics.\n\n**1. Exact Solution of the Riemann Problem**\n\nThe solution to the Riemann problem with initial condition $u(x,0) = u_L$ for $x  x_0$ and $u(x,0) = u_R$ for $x > x_0$ depends on the relative values of $u_L$ and $u_R$. The characteristic speed is $f'(u) = u$.\n\n*   **Shock Wave ($u_L > u_R$)**: Characteristics collide, forming a discontinuity (a shock) that travels with speed $s$ given by the Rankine-Hugoniot condition:\n    $$s = \\frac{f(u_R) - f(u_L)}{u_R - u_L} = \\frac{\\frac{1}{2}u_R^2 - \\frac{1}{2}u_L^2}{u_R - u_L} = \\frac{1}{2}(u_L + u_R)$$\n    The shock's position at time $T$ is $x_s(T) = x_0 + sT$. The solution is piecewise constant: $u(x,T) = u_L$ for $x  x_s(T)$ and $u(x,T) = u_R$ for $x > x_s(T)$.\n\n*   **Rarefaction Wave ($u_L  u_R$)**: Characteristics move apart, creating an expansion fan. The solution is continuous and is given by a self-similar profile based on $\\xi = (x-x_0)/T$:\n    $$ u(x, T) = \\begin{cases} u_L,  \\text{if } (x-x_0)/T \\le u_L \\\\ (x-x_0)/T,  \\text{if } u_L  (x-x_0)/T  u_R \\\\ u_R,  \\text{if } (x-x_0)/T \\ge u_R \\end{cases} $$\n\n**2. Finite Volume Method with Godunov Flux**\n\nThe domain is divided into cells $C_i$ of width $\\Delta x$. We evolve the cell-averaged quantity $u_i$. The first-order update scheme is:\n$$ u_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right) $$\nwhere $F_{i+1/2} = F_G(u_i^n, u_{i+1}^n)$ is the Godunov numerical flux at the interface between cells $i$ and $i+1$. The Godunov flux is derived by solving the exact Riemann problem at the interface and evaluating the flux $f(u)$ at the interface location ($x=0$ in the local problem). For Burgers' equation, this yields:\n$$ F_G(u_L, u_R) = \\begin{cases} f(u_L)  \\text{if } s > 0 \\text{ and } u_L > u_R \\text{ (shock moves right)} \\\\ f(u_R)  \\text{if } s \\le 0 \\text{ and } u_L > u_R \\text{ (shock moves left)} \\\\ f(u_L)  \\text{if } u_L \\le u_R \\text{ and } u_L \\ge 0 \\text{ (rarefaction, all positive speeds)} \\\\ f(u_R)  \\text{if } u_L \\le u_R \\text{ and } u_R \\le 0 \\text{ (rarefaction, all negative speeds)} \\\\ 0  \\text{if } u_L  0  u_R \\text{ (rarefaction with sonic point)} \\end{cases} $$\nwhere $s = (u_L+u_R)/2$. This scheme is entropy-satisfying, ensuring that only physically correct shocks are captured. The time step $\\Delta t$ is constrained by the CFL condition to ensure stability.\n\n**3. Error Metrics**\n\nTo compute the discrete $L^1$ error, we compare the numerical cell averages $u_i^{\\text{num}}(T)$ with the exact cell averages $u_i^{\\text{exact}}(T)$. The exact average is found by integrating the exact solution profile over each cell:\n$$u_i^{\\text{exact}}(T) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u_{\\text{exact}}(x, T) \\,dx$$\nThis integral can be calculated analytically for both shock and rarefaction cases. For the shock position error, the numerical shock location $\\hat{x}_s(T)$ is estimated (e.g., via interpolation) and compared to the exact position $x_s(T)$.\n\nThe five test cases explore different scenarios: a right-moving shock to test error magnitude and convergence, a rarefaction wave, a trivial constant state to check for preservation, and a left-moving shock to test shock position accuracy. The implementation involves a time-stepping loop that applies the Godunov flux update, coupled with functions to generate the exact solution and compute the required error metrics for each case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main driver function to execute the verification suite for the \n    finite volume solution of the inviscid Burgers' equation.\n    \"\"\"\n\n    def godunov_flux(u_l, u_r):\n        \"\"\"Computes the Godunov flux for the Burgers' equation f(u) = 0.5*u^2.\"\"\"\n        f_l = 0.5 * u_l**2\n        f_r = 0.5 * u_r**2\n\n        if u_l > u_r:  # Shock\n            s = 0.5 * (u_l + u_r)\n            return f_l if s >= 0 else f_r\n        else:  # Rarefaction or constant state\n            if u_l >= 0:\n                return f_l\n            elif u_r = 0:\n                return f_r\n            else:  # u_l  0  u_r\n                return 0.0\n\n    def get_exact_solution_cell_avg(x_centers, dx, T, u_l, u_r, x0):\n        \"\"\"\n        Computes the cell-averaged exact solution of the Riemann problem\n        for the Burgers' equation at time T.\n        \"\"\"\n        N = len(x_centers)\n        u_exact_avg = np.zeros(N)\n        \n        if T == 0:\n            return np.where(x_centers  x0, u_l, u_r)\n\n        if u_l > u_r:  # Shock wave\n            s = 0.5 * (u_l + u_r)\n            xs = x0 + s * T\n            for i in range(N):\n                xa = x_centers[i] - 0.5 * dx\n                xb = x_centers[i] + 0.5 * dx\n                if xb = xs:\n                    u_exact_avg[i] = u_l\n                elif xa >= xs:\n                    u_exact_avg[i] = u_r\n                else:\n                    u_exact_avg[i] = (u_l * (xs - xa) + u_r * (xb - xs)) / dx\n        else:  # Rarefaction wave\n            x_fan_l = x0 + u_l * T\n            x_fan_r = x0 + u_r * T\n            \n            # Indefinite integral of (x-x0)/T is F(x)\n            F = lambda x: (0.5 * x**2 - x0 * x) / T\n            \n            for i in range(N):\n                xa = x_centers[i] - 0.5 * dx\n                xb = x_centers[i] + 0.5 * dx\n                \n                # Part 1: Integral over the left constant region\n                len_l = max(0, min(xb, x_fan_l) - xa)\n                integral_l = u_l * len_l\n\n                # Part 2: Integral over the right constant region\n                len_r = max(0, xb - max(xa, x_fan_r))\n                integral_r = u_r * len_r\n\n                # Part 3: Integral over the fan region\n                ix_a = max(xa, x_fan_l)\n                ix_b = min(xb, x_fan_r)\n                if ix_a >= ix_b:\n                    integral_fan = 0.0\n                else:\n                    integral_fan = F(ix_b) - F(ix_a)\n                \n                u_exact_avg[i] = (integral_l + integral_fan + integral_r) / dx\n\n        return u_exact_avg\n\n    def estimate_shock_pos(u_num, x_centers, dx, u_l, u_r):\n        \"\"\"Estimates the numerical shock position.\"\"\"\n        u_mid = 0.5 * (u_l + u_r)\n        \n        # Find where solution crosses the midpoint\n        crossings = np.where(np.diff(np.sign(u_num - u_mid)))[0]\n\n        if len(crossings) > 0:\n            idx = crossings[0]\n            u1, u2 = u_num[idx], u_num[idx+1]\n            x1, x2 = x_centers[idx], x_centers[idx+1]\n            # Linear interpolation\n            if u2 - u1 != 0:\n                pos = x1 + (x2 - x1) * (u_mid - u1) / (u2 - u1)\n                return pos\n        \n        # Fallback: position of largest gradient magnitude\n        gradient_mag = np.abs(np.diff(u_num))\n        idx = np.argmax(gradient_mag)\n        # Position is the interface between cell idx and idx+1\n        pos = x_centers[idx] + 0.5 * dx\n        return pos\n\n    def run_simulation(u_l, u_r, x0, N, T, cfl, x_min=-1.0, x_max=1.0):\n        \"\"\"\n        Runs the first-order finite volume simulation for Burgers' equation.\n        \"\"\"\n        dx = (x_max - x_min) / N\n        x_centers = x_min + (np.arange(N) + 0.5) * dx\n        u = np.where(x_centers  x0, u_l, u_r)\n        \n        t = 0.0\n        while t  T:\n            max_abs_u = np.max(np.abs(u))\n            \n            if max_abs_u == 0:\n                dt = T - t # If u is zero, it stays zero. Fast-forward.\n            else:\n                dt = cfl * dx / max_abs_u\n            \n            dt = min(dt, T - t)\n            \n            # Transmissive (outflow) boundary conditions using padding\n            u_padded = np.pad(u, 1, 'edge')\n            \n            fluxes = np.zeros(N + 1)\n            for i in range(N + 1):\n                fluxes[i] = godunov_flux(u_padded[i], u_padded[i + 1])\n                \n            u = u - (dt / dx) * (fluxes[1:] - fluxes[:-1])\n            t += dt\n            \n        return u, x_centers, dx\n\n    results = []\n    \n    # --- Test Case 1: Shock, L1 error ---\n    params1 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params1)\n    u_exact = get_exact_solution_cell_avg(x_centers, dx, params1['T'], params1['u_l'], params1['u_r'], params1['x0'])\n    l1_error = np.sum(np.abs(u_num - u_exact)) * dx\n    results.append(l1_error)\n    \n    # --- Test Case 2: Shock, convergence ---\n    params2_200 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num_200, x_200, dx_200 = run_simulation(**params2_200)\n    u_exact_200 = get_exact_solution_cell_avg(x_200, dx_200, params2_200['T'], params2_200['u_l'], params2_200['u_r'], params2_200['x0'])\n    l1_error_200 = np.sum(np.abs(u_num_200 - u_exact_200)) * dx_200\n    \n    params2_400 = {'u_l': 2.0, 'u_r': 0.0, 'x0': 0.0, 'N': 400, 'T': 0.2, 'cfl': 0.9}\n    u_num_400, x_400, dx_400 = run_simulation(**params2_400)\n    u_exact_400 = get_exact_solution_cell_avg(x_400, dx_400, params2_400['T'], params2_400['u_l'], params2_400['u_r'], params2_400['x0'])\n    l1_error_400 = np.sum(np.abs(u_num_400 - u_exact_400)) * dx_400\n    \n    convergence_indicator = 1 if l1_error_400  l1_error_200 else 0\n    results.append(convergence_indicator)\n\n    # --- Test Case 3: Rarefaction, L1 error ---\n    params3 = {'u_l': 0.0, 'u_r': 2.0, 'x0': 0.0, 'N': 400, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params3)\n    u_exact = get_exact_solution_cell_avg(x_centers, dx, params3['T'], params3['u_l'], params3['u_r'], params3['x0'])\n    l1_error = np.sum(np.abs(u_num - u_exact)) * dx\n    results.append(l1_error)\n    \n    # --- Test Case 4: Constant state preservation ---\n    params4 = {'u_l': 1.0, 'u_r': 1.0, 'x0': 0.0, 'N': 200, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params4)\n    max_dev = np.max(np.abs(u_num - 1.0))\n    results.append(max_dev)\n    \n    # --- Test Case 5: Left-moving shock, position error ---\n    params5 = {'u_l': 0.0, 'u_r': -2.0, 'x0': 0.0, 'N': 300, 'T': 0.2, 'cfl': 0.9}\n    u_num, x_centers, dx = run_simulation(**params5)\n    \n    # Exact shock position\n    s_exact = 0.5 * (params5['u_l'] + params5['u_r'])\n    x_s_exact = params5['x0'] + s_exact * params5['T']\n    \n    # Numerical shock position\n    x_s_hat = estimate_shock_pos(u_num, x_centers, dx, params5['u_l'], params5['u_r'])\n    \n    pos_error = np.abs(x_s_hat - x_s_exact)\n    results.append(pos_error)\n\n    # Format output\n    formatted_results = []\n    for i, res in enumerate(results):\n        if i == 1: # Case 2 is an integer\n            formatted_results.append(str(int(res)))\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3201943"}]}