{"hands_on_practices": [{"introduction": "The power of a quantum algorithm is not universal; it is deeply connected to the structure of the problem it aims to solve. This exercise explores the fundamental distinction between unstructured search, where Grover's algorithm provides its famous quadratic speedup, and structured search, where the advantage can diminish or disappear entirely. By comparing search on an unsorted array to search on a balanced binary search tree, you will investigate how the type of information revealed by an oracle dictates the potential for quantum acceleration [@problem_id:3242170].", "problem": "Consider two search tasks over a set of $n$ distinct keys in the Quantum Query Model (QQM), where a query is the application of a unitary oracle on a quantum register and the cost measure is the number of oracle applications.\n\nTask 1 (Uniform Unsorted Array with a Single Marked Item): The keys are stored in an array in arbitrary order, and there is exactly one marked index $i^\\star \\in \\{0,1,\\dots,n-1\\}$ such that a Boolean predicate $f(i^\\star) = 1$ and $f(i) = 0$ for all $i \\neq i^\\star$. Access is via the standard membership oracle $O_f$ that acts as $O_f\\colon \\lvert i\\rangle \\lvert b\\rangle \\mapsto \\lvert i\\rangle \\lvert b \\oplus f(i)\\rangle$, with unit cost per query.\n\nTask 2 (Ordered Search via a Balanced Binary Search Tree): The keys are maintained in a Balanced Binary Search Tree (BST), which is a binary tree whose in-order traversal yields the keys in strictly increasing order and whose height is $\\Theta(\\log n)$ in the worst case. The unknown target key $x^\\star$ is known to be one of the stored keys. Access is via a comparison oracle $O_{\\leq}$ that implements $O_{\\leq}\\colon \\lvert y\\rangle \\lvert b\\rangle \\mapsto \\lvert y\\rangle \\lvert b \\oplus \\mathbf{1}[x^\\star \\leq y]\\rangle$, where $\\mathbf{1}[\\cdot]$ is the indicator function, with unit cost per query.\n\nStarting from fundamental definitions and well-tested facts:\n- A Balanced Binary Search Tree (BST) supports comparisons that deterministically partition the set of possible ranks of $x^\\star$ into two halves per comparison, and classical binary search isolates $x^\\star$ by halving the candidate set at each step.\n- Grover’s algorithm is the canonical amplitude-amplification procedure for searching a single marked item in an unstructured domain using a membership oracle.\n\nSelect all statements that are correct about the optimal quantum query complexities in these two tasks and about how order information constrains potential quantum speedups.\n\nA. In Task $1$, with a single marked index and access only to $O_f$, the optimal quantum query complexity is $\\Theta(\\sqrt{n})$, achieved by Grover’s algorithm, whereas any classical algorithm requires $\\Theta(n)$ queries in the worst case.\n\nB. In Task $2$, by leveraging superposition over comparisons in the BST, a quantum algorithm can locate $x^\\star$ using only $\\Theta(\\sqrt{\\log n})$ comparison queries.\n\nC. In Task $2$, the presence of total order information induces an $\\Omega(\\log n)$ quantum query lower bound for ordered search, so the best quantum algorithms still use $\\Theta(\\log n)$ queries up to constant factors, rather than $\\Theta(\\sqrt{n})$.\n\nD. If the keys are sorted but the oracle access is restricted to equality testing $O_{=}\\colon \\lvert y\\rangle \\lvert b\\rangle \\mapsto \\lvert y\\rangle \\lvert b \\oplus \\mathbf{1}[y = x^\\star]\\rangle$, without exposing order information, the optimal quantum query complexity to find $x^\\star$ remains $\\Theta(\\sqrt{n})$, matching the unstructured case.", "solution": "This problem tests the understanding of how problem structure affects quantum speedups, specifically comparing unstructured search (Grover's algorithm) with structured search (ordered search).\n\n**Analysis of Task 1: Unstructured Search**\n- **Classical Complexity:** In an unsorted array of size $n$, finding a single marked item without any precomputation requires, in the worst case, checking all $n$ items. On average, it takes $O(n)$ queries.\n- **Quantum Complexity:** This is the canonical problem for Grover's algorithm. It finds the marked item with high probability using $O(\\sqrt{n})$ oracle queries. A known lower bound proves that any quantum algorithm for this problem requires $\\Omega(\\sqrt{n})$ queries. Thus, the optimal quantum query complexity is $\\Theta(\\sqrt{n})$.\n\n**Analysis of Task 2: Ordered Search**\n- **Classical Complexity:** The data is sorted, which allows the use of binary search. Each query to the comparison oracle halves the search space. This requires $O(\\log n)$ queries to find the target.\n- **Quantum Complexity:** A common misconception is to apply Grover's algorithm to the $\\log n$ steps of binary search, which would suggest a $O(\\sqrt{\\log n})$ complexity. This is incorrect because the queries in binary search are dependent on previous results. The problem of searching a sorted list has a quantum query lower bound of $\\Omega(\\log n)$. Since a quantum computer can simply execute the classical binary search algorithm in $O(\\log n)$ time, the optimal quantum query complexity is $\\Theta(\\log n)$. The structure of the problem (total order) limits the potential for quantum speedup.\n\n**Option Evaluation**\n*   **A. Correct.** It accurately states the $\\Theta(n)$ classical and $\\Theta(\\sqrt{n})$ quantum complexities for unstructured search.\n*   **B. Incorrect.** It presents the common fallacy of a $O(\\sqrt{\\log n})$ complexity for ordered search, which violates the $\\Omega(\\log n)$ lower bound.\n*   **C. Correct.** It correctly states the $\\Omega(\\log n)$ lower bound for ordered search and that the optimal complexity is $\\Theta(\\log n)$, offering no asymptotic speedup over classical binary search.\n*   **D. Correct.** If the oracle only allows equality testing, it cannot leverage the sorted order of the data. The problem becomes equivalent to an unstructured search, for which the complexity is $\\Theta(\\sqrt{n})$.", "answer": "$$\\boxed{ACD}$$", "id": "3242170"}, {"introduction": "A theoretical speedup does not guarantee practical superiority. In the real world, we must weigh a quantum algorithm's performance against the best available classical techniques, which often leverage preprocessing and sophisticated data structures. This practice challenges you to perform such a comparative analysis, pitting Grover's algorithm against classical hashing for a batch of search queries [@problem_id:3133889]. You will analyze the asymptotic time complexities, factoring in crucial elements like one-time preprocessing costs and memory usage, to determine the threshold beyond which the classical approach becomes more efficient.", "problem": "You are given a static set of $N$ distinct keys drawn from a large universe, stored in arbitrary order in classical memory. You will receive a batch of $Q$ membership queries, each query asking whether a presented key is in the set. Assume the following computational models.\n\n- Classical, unstructured search with no precomputation uses only $O(1)$ extra memory and may sequentially inspect the stored keys.\n- Classical hashing with precomputation may preprocess the keys into a hash table using $O(N)$ extra memory and $O(N)$ preprocessing time; lookups in the resulting table have expected time $O(1)$ under standard hashing assumptions.\n- Grover’s algorithm for unstructured search runs in $O(\\sqrt{N})$ oracle queries per successful search using only $O(1)$ extra memory, and there is no assumed quantum random-access memory structure.\n\nYou should compare total time across the $Q$ queries and account for the one-time classical preprocessing cost when applicable. In addition, consider the effect of a memory budget $M$ when $M < N$ for classical hashing if relevant. Ignore constant factors and lower-order terms, and suppose that the hashing model uses separate chaining with table size proportional to the allocated memory so that load factor is $\\alpha = N/M$.\n\nWhich of the following statements are true?\n\nA. With no precomputation beyond $O(1)$ extra memory, Grover’s algorithm answers a single successful membership query in expected $O(\\sqrt{N})$ time, whereas the best classical method requires expected $O(N)$ time; thus Grover provides a quadratic advantage in $N$ in this regime.\n\nB. If a classical algorithm is allowed to build a hash table in $O(N)$ time using $O(N)$ memory, then for a batch of $Q$ queries the classical total time is $O(N + Q)$ while a straightforward application of Grover’s algorithm uses $O(Q\\sqrt{N})$ time. Consequently, there is a threshold $Q = \\Theta(\\sqrt{N})$ beyond which the classical approach is asymptotically faster in total time.\n\nC. With $O(N)$ precomputation memory, a quantum algorithm can combine Grover’s algorithm with hashing to achieve worst-case $O(1)$ query time while using only $O(\\sqrt{N})$ preprocessing time.\n\nD. Even when restricted to a precomputation memory budget $M = o(N)$, a classical algorithm can guarantee expected $O(1)$ lookup time for arbitrary adversarial queries by using a carefully chosen hash function.\n\nE. Under separate chaining with a table of $M$ slots built in $O(N)$ time, the classical expected lookup time per query is $O(1 + N/M)$; hence a simple time–memory tradeoff is that expected per-query time scales as $O(N/M)$ when $M \\ll N$.", "solution": "This problem compares the total time complexity of classical and quantum search algorithms for a batch of $Q$ queries on a static dataset of size $N$, accounting for preprocessing.\n\n*   **A. Correct.** With no precomputation ($O(1)$ memory), a classical search is a linear scan, requiring expected $O(N)$ time. Grover's algorithm requires $O(\\sqrt{N})$ time (assuming oracle calls are $O(1)$). The speedup is quadratic since $(O(\\sqrt{N}))^2 = O(N)$.\n*   **B. Correct.** With precomputation, the classical algorithm pays a one-time cost of $O(N)$ to build a hash table, then each of the $Q$ queries takes $O(1)$ time. Total classical time: $O(N + Q)$. The quantum approach, running Grover for each query, takes $O(Q\\sqrt{N})$. To find the crossover point, we set $N + Q \\approx Q\\sqrt{N}$, which gives $Q \\approx N/(\\sqrt{N}-1) = \\Theta(\\sqrt{N})$. For $Q$ asymptotically larger than $\\sqrt{N}$, the classical approach is faster.\n*   **C. Incorrect.** Building any data structure (like a hash table) that depends on all $N$ items requires at least $\\Omega(N)$ time just to read the input data. A preprocessing time of $O(\\sqrt{N})$ is not possible.\n*   **D. Incorrect.** If the memory $M$ is sublinear in $N$ ($M=o(N)$), the hash table's load factor $\\alpha = N/M$ will grow without bound. The expected lookup time, which is typically $O(1+\\alpha)$, cannot be $O(1)$.\n*   **E. Correct.** For separate chaining with a table of size $M$, the load factor is $\\alpha = N/M$. The expected lookup time is $O(1+\\alpha) = O(1+N/M)$. When $M \\ll N$, the $N/M$ term dominates, so the time scales as $O(N/M)$, demonstrating a clear time-memory tradeoff.", "answer": "$$\\boxed{ABE}$$", "id": "3133889"}, {"introduction": "Quantum algorithms are often described using abstract \"oracles\" that act as black boxes, but on a real quantum computer, these oracles must be constructed from a finite set of physical gate operations. This exercise lifts the veil on the oracle by tasking you with estimating the implementation cost for a significant computational problem: the Boolean satisfiability problem (SAT). You will derive the resource cost, specifically the number of non-Clifford $T$ gates, required to build a Grover oracle for a $3$-SAT formula, providing a concrete link between high-level algorithmic theory and the practicalities of fault-tolerant quantum circuit design [@problem_id:3133929].", "problem": "Consider building a Grover oracle for a Boolean formula in Conjunctive Normal Form (CNF) with $n$ input bits and $m$ clauses, where each clause is the disjunction of exactly three literals (three-satisfiability, also called $3$-SAT). The oracle should flip the phase of computational basis states $|x\\rangle$ that satisfy all clauses. Assume the standard reversible compute–phase–uncompute pattern, and that the circuit is compiled into the Clifford plus $T$ (Clifford+$T$) gate set. Use the following modeling assumptions that are common in fault-tolerant resource estimation:\n\n- Each literal is either a variable $x_{j}$ or its negation $\\neg x_{j}$, and negations are implemented by Pauli-$X$ gates, which are Clifford gates.\n- A two-input disjunction $a \\lor b$ is implemented reversibly via De Morgan’s law as $a \\lor b = \\neg(\\neg a \\land \\neg b)$, so its non-Clifford cost is that of one two-input conjunction.\n- A two-input conjunction is implemented by a controlled-controlled-NOT (Toffoli) using clean ancillae. Take the non-Clifford cost of one Toffoli to be exactly $7$ $T$ gates.\n- A three-input disjunction $a \\lor b \\lor c$ is built by composing two two-input disjunctions.\n- The global conjunction of the $m$ clause outputs is formed as a binary tree of two-input conjunctions with clean ancillae.\n- The phase flip conditioned on the final conjunction is implemented by a Clifford gate (for example, a controlled-$Z$), contributing no $T$ gates.\n- All intermediate values are uncomputed after the phase flip to restore all ancillae to $|0\\rangle$.\n\nUnder these assumptions, derive a closed-form symbolic expression for the total $T$-count of a single application of the Grover oracle as a function of $n$ and $m$. Express your final answer as a single analytic expression. No rounding is required, and no units are involved.", "solution": "The problem requires the derivation of a closed-form expression for the total $T$-count of a single Grover oracle application for a $3$-SAT problem with $n$ variables and $m$ clauses. The solution is derived based on the provided modeling assumptions for a circuit compiled into the Clifford+$T$ gate set.\n\nThe oracle implementation follows the standard compute-phase-uncompute pattern. The total $T$-count, denoted as $T_{\\text{total}}$, is the sum of the $T$-counts for these three stages:\n$$T_{\\text{total}} = T_{\\text{compute}} + T_{\\text{phase}} + T_{\\text{uncompute}}$$\n\nLet us analyze the $T$-count for each stage.\n\n1.  **Phase Stage ($T_{\\text{phase}}$):**\n    As per assumption 6, the conditional phase flip, which is applied to the final output bit of the computation, is implemented by a Clifford gate (such as a controlled-$Z$ gate). By definition, Clifford gates have a $T$-count of zero. Therefore,\n    $$T_{\\text{phase}} = 0$$\n\n2.  **Uncomputation Stage ($T_{\\text{uncompute}}$):**\n    Assumption 7 states that all intermediate values are uncomputed to restore ancilla qubits to their initial $|0\\rangle$ state. This is achieved by running the computation circuit in reverse. The inverse of a circuit composed of Clifford and $T$ gates has the same $T$-count as the original circuit because the inverse of a $T$ gate, $T^\\dagger$, has the same implementation cost. Thus, the $T$-count for the uncomputation stage is equal to the $T$-count for the computation stage:\n    $$T_{\\text{uncompute}} = T_{\\text{compute}}$$\n\n3.  **Total $T$-Count Expression:**\n    Substituting these into the initial equation, the total $T$-count for the oracle is:\n    $$T_{\\text{total}} = T_{\\text{compute}} + 0 + T_{\\text{compute}} = 2 \\times T_{\\text{compute}}$$\n    Our task reduces to finding the $T$-count for the computation stage, $T_{\\text{compute}}$.\n\n4.  **Computation Stage ($T_{\\text{compute}}$):**\n    The computation stage evaluates the entire Boolean formula for a given input $|x\\rangle$. This process can be divided into two main parts:\n    -   Part A: Evaluating each of the $m$ clauses of the $3$-SAT formula.\n    -   Part B: Computing the logical AND (conjunction) of the results of all $m$ clauses to get a single final bit indicating whether the input $|x\\rangle$ is a satisfying assignment.\n\n    Let's calculate the $T$-count for each part.\n\n    **Part A: Cost of Evaluating $m$ Clauses**\n    Each clause is a disjunction of three literals, e.g., $l_1 \\lor l_2 \\lor l_3$.\n    -   According to assumption 4, this is implemented by composing two $2$-input disjunctions, for example, as $(l_1 \\lor l_2) \\lor l_3$. This requires two $2$-input disjunction operations.\n    -   According to assumption 2, the non-Clifford cost of one $2$-input disjunction ($a \\lor b$) is that of one $2$-input conjunction.\n    -   According to assumption 3, a $2$-input conjunction is implemented using a Toffoli gate, which costs $7$ $T$ gates.\n    -   Thus, evaluating one clause requires $2$ Toffoli gates, for a $T$-count of $T_{\\text{clause}} = 2 \\times 7 = 14$.\n    -   Since there are $m$ clauses, the total $T$-count for Part A is:\n        $$T_{\\text{Part A}} = m \\times T_{\\text{clause}} = 14m$$\n\n    **Part B: Cost of the Global Conjunction**\n    This part takes the $m$ output bits from the clause evaluations and computes their logical AND.\n    -   According to assumption 5, this global conjunction is formed as a binary tree of $2$-input conjunctions.\n    -   To compute the conjunction of $m$ bits, $m-1$ applications of a $2$-input conjunction are required.\n    -   Each $2$-input conjunction is a Toffoli gate.\n    -   Therefore, this part requires $m-1$ Toffoli gates.\n    -   With each Toffoli gate costing $7$ $T$ gates, the total $T$-count for Part B is:\n        $$T_{\\text{Part B}} = (m-1) \\times 7 = 7m - 7$$\n\n    **Total Computation $T$-Count ($T_{\\text{compute}}$)**\n    The total $T$-count for the computation stage is the sum of the counts for Part A and Part B:\n    $$T_{\\text{compute}} = T_{\\text{Part A}} + T_{\\text{Part B}} = 14m + (7m - 7) = 21m - 7$$\n\n5.  **Final Calculation:**\n    Finally, we substitute the expression for $T_{\\text{compute}}$ back into the equation for the total oracle cost:\n    $$T_{\\text{total}} = 2 \\times T_{\\text{compute}} = 2 \\times (21m - 7)$$\n    $$T_{\\text{total}} = 42m - 14$$\n\n    The result is a function of $m$ only. The number of input variables, $n$, does not appear in the final expression because the cost model depends on the number of logical operations (driven by clause count), not the number of input bits.", "answer": "$$\\boxed{42m - 14}$$", "id": "3133929"}]}