{"hands_on_practices": [{"introduction": "This practice introduces the fundamentals of digital quantum simulation by asking you to simulate the time evolution of a particle on a lattice, a common model in condensed matter physics. The core task is to implement the Trotter-Suzuki approximation, a cornerstone technique for simulating Hamiltonians that do not have a simple analytical solution. You will also explore a crucial aspect of real-world quantum computation by introducing a simple error model to see how non-unitary effects can lead to a breakdown of probability conservation, a key feature of ideal quantum mechanics [@problem_id:3181193].", "problem": "Consider a one-dimensional lattice with $N$ sites and periodic boundary conditions. The quantum state is represented by a complex vector $\\psi \\in \\mathbb{C}^N$ with components $\\psi(x,t)$, where $x \\in \\{0,1,\\dots,N-1\\}$ indexes lattice sites and $t$ denotes time. The evolution is governed by the time-dependent Schrödinger equation $i \\frac{d}{dt} \\lvert \\psi(t) \\rangle = H \\lvert \\psi(t) \\rangle$, where $H = T + V$ is a Hermitian Hamiltonian consisting of a kinetic (hopping) term $T$ and an on-site potential $V$. The kinetic term is $T = -J \\sum_{x=0}^{N-1} \\left( \\lvert x \\rangle \\langle x+1 \\rvert + \\lvert x+1 \\rangle \\langle x \\rvert \\right)$ with addition modulo $N$, and the potential is $V = \\sum_{x=0}^{N-1} V_x \\lvert x \\rangle \\langle x \\rvert$ with $V_x = V_0 \\cos\\left( \\frac{2\\pi x}{N} \\right)$. The time evolution is approximated by first-order Trotterization: one discrete step of duration $\\Delta t$ applies $U_V = e^{-i V \\Delta t}$ followed by $U_T = e^{-i T \\Delta t}$ to the state. In exact arithmetic with perfect gates, the evolution operator is unitary and the norm $\\sum_x \\lvert \\psi(x,t) \\rvert^2$ is preserved at each step.\n\nTo study the impact of gate imperfections, model finite gate errors by a uniform leakage operator $L(\\delta) = (1-\\delta) I$ with $0 \\le \\delta \\ll 1$ applied immediately after each gate. This leakage models amplitude loss to degrees of freedom outside the simulated Hilbert space (computational subspace), and therefore is non-unitary on the simulated subspace. At each Trotter step, apply $U_V$, then $L(\\delta)$, then $U_T$, then $L(\\delta)$.\n\nStarting from the normalized initial condition $\\psi(x,0) = 1$ for $x=0$ and $\\psi(x,0) = 0$ for $x \\neq 0$, implement the above evolution for $M$ discrete steps. After each Trotter step $k$ (i.e., after the sequence $U_V$, $L(\\delta)$, $U_T$, $L(\\delta)$ is applied once), compute the norm $n_k = \\sum_{x=0}^{N-1} \\lvert \\psi(x,t_k) \\rvert^2$ and verify the norm preservation property in the error-free case. Quantify the drift due to finite gate errors by reporting the single metric $D = \\max_{1 \\le k \\le M} \\lvert 1 - n_k \\rvert$, the maximum absolute deviation of the norm from $1$ over all steps.\n\nUse dimensionless units for all quantities. Angles are dimensionless phases; no angle unit conversion is required.\n\nYour program must simulate the evolution and, for the parameter sets below, output the drift metric $D$ for each case. Round each reported $D$ to six decimal places. The final output must be a single line containing the results as a comma-separated list enclosed in square brackets.\n\nTest suite (each tuple is $(N, J, V_0, \\Delta t, M, \\delta)$):\n- Case $1$: $(8, 1.0, 0.0, 0.10, 100, 0.0)$.\n- Case $2$: $(8, 1.0, 0.5, 0.05, 200, 0.0)$.\n- Case $3$: $(8, 1.0, 0.5, 0.05, 200, 1.0 \\times 10^{-4})$.\n- Case $4$: $(8, 1.0, 0.5, 0.05, 10, 5.0 \\times 10^{-2})$.\n- Case $5$: $(8, 1.0, 1.0, 0.50, 20, 0.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[D_1,D_2,D_3,D_4,D_5]$), where each $D_i$ is the drift metric for Case $i$ rounded to six decimal places.", "solution": "The problem requires the simulation of a quantum system on a one-dimensional lattice and the quantification of norm deviation due to simulated gate errors. The process involves constructing the Hamiltonian, implementing the time evolution via Trotterization, and calculating a specific error metric.\n\n**1. System Representation**\n\nThe quantum state of the system is a vector $\\lvert \\psi \\rangle \\in \\mathbb{C}^N$, where $N$ is the number of lattice sites. In the computational implementation, this is represented as a `numpy` array of size $N$ with a complex data type. The initial condition is $\\psi(x,0) = 1$ for $x=0$ and $\\psi(x,0) = 0$ otherwise, which corresponds to a state vector with a $1$ in the first component and $0$s elsewhere. This is a normalized state, i.e., $\\langle \\psi(0) \\mid \\psi(0) \\rangle = \\sum_{x=0}^{N-1} \\lvert \\psi(x,0) \\rvert^2 = 1$.\n\n**2. Hamiltonian and Evolution Operators**\n\nThe time evolution is governed by the Schrödinger equation $i \\frac{d}{dt} \\lvert \\psi(t) \\rangle = H \\lvert \\psi(t) \\rangle$. For a small time step $\\Delta t$, the evolution operator is approximately $U(\\Delta t) \\approx e^{-i H \\Delta t}$. The Hamiltonian $H$ is the sum of a kinetic term $T$ and a potential term $V$.\n\n- **Potential Operator ($V$):** The potential is an on-site term $V = \\sum_{x=0}^{N-1} V_x \\lvert x \\rangle \\langle x \\rvert$, with $V_x = V_0 \\cos(\\frac{2\\pi x}{N})$. This operator is diagonal in the position basis $\\{\\lvert x \\rangle\\}$. The corresponding evolution operator, $U_V = e^{-i V \\Delta t}$, is also diagonal, with matrix elements $(U_V)_{xx} = e^{-i V_x \\Delta t}$. Its application to a state vector $\\psi$ is an efficient element-wise multiplication: $(\\psi')_x = e^{-i V_x \\Delta t} \\psi_x$.\n\n- **Kinetic Operator ($T$):** The kinetic term is a hopping term $T = -J \\sum_{x=0}^{N-1} \\left( \\lvert x \\rangle \\langle x+1 \\rvert + \\lvert x+1 \\rangle \\langle x \\rvert \\right)$, where addition is modulo $N$. In the position basis, this is a real, symmetric $N \\times N$ matrix. The diagonal elements are $0$, and the elements on the first super-diagonal and sub-diagonal are $-J$. Due to the periodic boundary conditions, the elements $T_{0,N-1}$ and $T_{N-1,0}$ are also $-J$. The evolution operator for the kinetic part is $U_T = e^{-i T \\Delta t}$. Since $T$ is not a diagonal matrix, its exponential must be computed using a numerical matrix exponentiation algorithm, such as the one provided by `scipy.linalg.expm`. The operators $T$ and $V$ are Hermitian, so $U_T$ and $U_V$ are unitary.\n\n**3. Trotterized Evolution with Errors**\n\nThe problem specifies a first-order Trotter-Suzuki decomposition to approximate the full evolution operator $e^{-i(T+V)\\Delta t}$. A single step of the ideal evolution applies first $U_V$ and then $U_T$, resulting in the combined operator $U_{\\text{Trotter}} = U_T U_V$. Since $U_T$ and $U_V$ are unitary, their product $U_{\\text{Trotter}}$ is also unitary, which guarantees the conservation of the state norm: $\\lVert U_{\\text{Trotter}} \\psi \\rVert^2 = \\lVert \\psi \\rVert^2$.\n\nGate errors are modeled by a non-unitary leakage operator $L(\\delta) = (1-\\delta)I$, which is applied after each of the unitary gates. The evolution of the state vector $\\psi_k$ at step $k$ to $\\psi_{k+1}$ at step $k+1$ is given by:\n$$\n\\lvert \\psi_{k+1} \\rangle = L(\\delta) U_T L(\\delta) U_V \\lvert \\psi_k \\rangle\n$$\nThis operator is not unitary for $\\delta > 0$. Let $n_k = \\lVert \\psi_k \\rVert^2$ be the norm at step $k$. The norm evolves as:\n$$\nn_{k+1} = \\lVert L(\\delta) U_T L(\\delta) U_V \\psi_k \\rVert^2 = \\langle \\psi_k \\rvert U_V^\\dagger L(\\delta)^\\dagger U_T^\\dagger L(\\delta)^\\dagger L(\\delta) U_T L(\\delta) U_V \\lvert \\psi_k \\rangle\n$$\nSince $L(\\delta)$ is a scalar operator $(1-\\delta)I$, and $U_T, U_V$ are unitary, this simplifies to:\n$$\nn_{k+1} = (1-\\delta)^2 \\cdot (1-\\delta)^2 \\cdot \\langle \\psi_k \\rvert U_V^\\dagger U_T^\\dagger U_T U_V \\lvert \\psi_k \\rangle = (1-\\delta)^4 n_k\n$$\nStarting with $n_0=1$, the norm after $k$ steps is $n_k = ((1-\\delta)^4)^k = (1-\\delta)^{4k}$.\n\n**4. Simulation Algorithm and Metric Calculation**\n\nThe simulation algorithm proceeds as follows for each set of parameters $(N, J, V_0, \\Delta t, M, \\delta)$:\n\n1.  **Initialization:** Create the initial state vector $\\psi$, where $\\psi_0=1$ and $\\psi_x=0$ for $x>0$.\n2.  **Operator Construction:**\n    a. Construct the vector of potential values $V_x$ and from it the vector of multiplicative phase factors $e^{-i V_x \\Delta t}$.\n    b. Construct the $N \\times N$ kinetic matrix $T$.\n    c. Compute the kinetic evolution matrix $U_T = e^{-i T \\Delta t}$ once before the time-stepping loop.\n3.  **Time Evolution:** Loop for $k$ from $1$ to $M$:\n    a. Apply the potential evolution operator: $\\psi \\leftarrow U_V \\psi$ (element-wise multiplication).\n    b. Apply the first leakage operator: $\\psi \\leftarrow (1-\\delta) \\psi$ (scalar multiplication).\n    c. Apply the kinetic evolution operator: $\\psi \\leftarrow U_T \\psi$ (matrix-vector multiplication).\n    d. Apply the second leakage operator: $\\psi \\leftarrow (1-\\delta) \\psi$ (scalar multiplication).\n    e. After this full step, compute the norm squared $n_k = \\sum_{x=0}^{N-1} \\lvert \\psi_x \\rvert^2$.\n    f. Record the deviation for this step: $|1 - n_k|$.\n4.  **Metric Calculation:** The final drift metric $D$ is the maximum deviation recorded over all $M$ steps: $D = \\max_{1 \\le k \\le M} |1 - n_k|$.\n\nFor the cases where $\\delta=0$, the leakage operator is the identity operator, $L(0) = I$. The evolution is unitary, and the norm is conserved at every step. Therefore, the deviation $|1-n_k|$ should be $0$ within the limits of floating-point arithmetic precision. For cases where $\\delta>0$, the norm decays, and the deviation $|1 - n_k| = 1 - (1-\\delta)^{4k}$ increases with $k$. The maximum deviation will thus occur at the final step, $k=M$, giving $D = 1 - (1-\\delta)^{4M}$.\n\nThe provided Python code implements this algorithm. It iterates through each test case, performs the simulation, calculates $D$, and formats the results as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Simulates the quantum evolution on a 1D lattice and calculates the norm drift.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 1.0, 0.0, 0.10, 100, 0.0),            # Case 1\n        (8, 1.0, 0.5, 0.05, 200, 0.0),            # Case 2\n        (8, 1.0, 0.5, 0.05, 200, 1.0e-4),         # Case 3\n        (8, 1.0, 0.5, 0.05, 10, 5.0e-2),          # Case 4\n        (8, 1.0, 1.0, 0.50, 20, 0.0),             # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        N, J, V0, dt, M, delta = case\n\n        # 1. Initialization\n        # a. Initial state: psi(x,0) = 1 for x=0, 0 otherwise.\n        psi = np.zeros(N, dtype=np.complex128)\n        psi[0] = 1.0 + 0.0j\n\n        # 2. Operator Construction\n        # a. Potential evolution operator U_V (as element-wise multiplicative factors)\n        x_sites = np.arange(N)\n        V_diag = V0 * np.cos(2 * np.pi * x_sites / N)\n        U_V_factors = np.exp(-1j * V_diag * dt)\n\n        # b. Kinetic operator T\n        T = np.zeros((N, N), dtype=np.float64)\n        for i in range(N):\n            T[i, (i + 1) % N] = -J\n            T[i, (i - 1 + N) % N] = -J\n        \n        # c. Kinetic evolution operator U_T\n        U_T = expm(-1j * T * dt)\n\n        # d. Leakage factor\n        leakage_factor = 1.0 - delta\n\n        # 3. Time Evolution Loop\n        deviations = []\n        for _ in range(M):\n            # Apply U_V\n            psi = U_V_factors * psi\n            \n            # Apply first leakage L(delta)\n            psi = leakage_factor * psi\n            \n            # Apply U_T\n            psi = U_T @ psi\n            \n            # Apply second leakage L(delta)\n            psi = leakage_factor * psi\n\n            # Calculate and store the norm deviation for the current step\n            norm_k = np.sum(np.abs(psi)**2)\n            deviations.append(np.abs(1.0 - norm_k))\n\n        # 4. Metric Calculation\n        # The drift D is the maximum absolute deviation over all M steps.\n        if not deviations:\n            D = 0.0\n        else:\n            D = np.max(deviations)\n        \n        results.append(D)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3181193"}, {"introduction": "After simulating a quantum state, a critical task is to verify its correctness by comparing it to a target state. This practice introduces the swap test, a fundamental quantum subroutine designed to measure the fidelity $F = |\\langle \\psi|\\phi\\rangle|^{2}$ between two states $|\\psi\\rangle$ and $|\\phi\\rangle$. By deriving the behavior of the swap test circuit from first principles, you will directly connect the abstract geometry of quantum states to concrete measurement probabilities [@problem_id:3181173]. Furthermore, this exercise bridges the gap between quantum theory and experimental reality by exploring how the statistical nature of quantum measurement dictates the number of experimental \"shots\" required to estimate the fidelity to a desired precision.", "problem": "You will implement a program that uses the logic of the swap test to determine how many experimental repetitions (shots) are required to estimate the fidelity between two pure quantum states with a prescribed estimator variance. The fidelity between two pure states is defined as $F=\\left|\\langle \\psi \\mid \\phi \\rangle\\right|^{2}$. The swap test circuit prepares an ancilla qubit, applies a Hadamard gate, a controlled-SWAP between the two registers holding $\\lvert \\psi \\rangle$ and $\\lvert \\phi \\rangle$, and then applies another Hadamard before measuring the ancilla in the computational basis. Assume ideal, noiseless operations except for the inherent sampling randomness from repeated measurements.\n\nUse only the following as your fundamental base:\n- The Born rule: for a quantum state $\\lvert \\chi \\rangle$ and a projective measurement $\\{\\Pi_{k}\\}$, the probability of outcome $k$ is $p_{k}=\\langle \\chi | \\Pi_{k} | \\chi \\rangle$.\n- The definition of fidelity between pure states: $F=\\left|\\langle \\psi \\mid \\phi \\rangle\\right|^{2}$.\n- The definition of variance for independent, identically distributed Bernoulli trials and linear functions of their sample mean.\n\nTask overview:\n1) Derive from first principles (starting from the Born rule and the action of the controlled-SWAP and Hadamard gates) an unbiased estimator $\\widehat{F}$ for $F$ based on the swap test ancilla measurement outcomes, and its variance as a function of the number of shots $M$. Your derivation must not assume any pre-quoted formulas for the swap test; it must start from the circuit action and the Born rule.\n2) From your variance expression, derive an inequality that the number of shots $M$ must satisfy to ensure that the estimator variance is at most a user-specified target value $v$.\n3) Implement a program that:\n   - Constructs the given state vectors from specified parameters.\n   - Computes the exact fidelity $F$ for each test case.\n   - Computes the minimal integer number of shots $M_{\\min}$ that satisfies your inequality for the given target variance $v$.\n   - Enforces the realistic constraint that at least $1$ shot is required, even in cases where the exact variance bound would suggest $0$.\n\nAngle units: all angles are specified in radians. There are no physical units in this task. The final outputs are integers.\n\nTest suite:\nFor each case below, the computational basis ordering is standard binary order. For one qubit, the basis is $\\{\\lvert 0 \\rangle,\\lvert 1 \\rangle\\}$, so a state is represented by a length-$2$ complex vector $\\left[\\alpha_{0},\\alpha_{1}\\right]$ with $\\sum_{j} \\lvert \\alpha_{j} \\rvert^{2}=1$. For two qubits, the basis is $\\{\\lvert 00 \\rangle,\\lvert 01 \\rangle,\\lvert 10 \\rangle,\\lvert 11 \\rangle\\}$, represented by a length-$4$ complex vector.\n\nProvide results for the following five cases, each with a specified target variance $v$:\n- Case A (orthogonal $1$-qubit states): $\\lvert \\psi \\rangle=\\left[1,0\\right]$, $\\lvert \\phi \\rangle=\\left[0,1\\right]$, target variance $v=10^{-3}$.\n- Case B (global phase invariance): $\\lvert \\psi \\rangle=\\left[1,0\\right]$, $\\lvert \\phi \\rangle=\\left[e^{i\\cdot 0.7},0\\right]$, target variance $v=10^{-3}$.\n- Case C (general $1$-qubit superpositions): Let $a=0.3$, $b=1.1$, $c=0.2$. Define $\\lvert \\psi \\rangle=\\left[\\cos a,\\sin a\\right]$ and $\\lvert \\phi \\rangle=\\left[\\cos b,e^{i c}\\sin b\\right]$. Target variance $v=5\\times 10^{-4}$.\n- Case D ($2$-qubit entangled versus product): $\\lvert \\psi \\rangle=\\frac{1}{\\sqrt{2}}\\left[1,0,0,1\\right]$ (the Bell state $(\\lvert 00 \\rangle + \\lvert 11 \\rangle)/\\sqrt{2}$), $\\lvert \\phi \\rangle=\\left[1,0,0,0\\right]$, target variance $v=10^{-4}$.\n- Case E (nearly identical $1$-qubit states): Let $a=0.2$ and $\\delta=0.01$. Define $\\lvert \\psi \\rangle=\\left[\\cos a,\\sin a\\right]$ and $\\lvert \\phi \\rangle=\\left[\\cos(a+\\delta),\\sin(a+\\delta)\\right]$. Target variance $v=10^{-6}$.\n\nYour program must:\n- Compute $F$ exactly from the state vectors and then compute the minimal integer $M_{\\min}$ that ensures the variance of your unbiased fidelity estimator is at most $v$ for each case.\n- Aggregate the five resulting shot counts into a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order A, B, C, D, E, for example, $\\left[\\text{result}_{A},\\text{result}_{B},\\text{result}_{C},\\text{result}_{D},\\text{result}_{E}\\right]$.\n\nNotes:\n- All complex exponentials are of the form $e^{i\\theta}=\\cos \\theta + i \\sin \\theta$ with $\\theta$ in radians.\n- Ensure numerical stability by normalizing any constructed states before computing inner products.\n- The final printed results must be integers with no additional formatting or text beyond the required list.", "solution": "The user wants me to solve a computational science problem.\n\n### Step 1: Extract Givens\n- **Problem:** Implement a program to calculate the minimum number of experimental repetitions (shots), $M$, for a swap test to estimate the fidelity $F$ between two pure quantum states, $|\\psi\\rangle$ and $|\\phi\\rangle$, such that the variance of the estimator is at most a given value $v$.\n- **Fidelity Definition:** $F = |\\langle\\psi|\\phi\\rangle|^2$.\n- **Swap Test Circuit:** An ancilla qubit is initialized to $|0\\rangle$, followed by a Hadamard gate ($H$), a controlled-SWAP gate (with the ancilla as control and state registers as targets), another $H$ on the ancilla, and finally a measurement of the ancilla in the computational basis.\n- **Fundamental Principles:** The solution must be derived from the Born rule ($p_k = \\langle\\chi|\\Pi_k|\\chi\\rangle$) and the definition of variance for i.i.d. Bernoulli trials.\n- **Task 1 (Derivation):** Derive an unbiased estimator $\\widehat{F}$ for $F$ and its variance, $\\text{Var}(\\widehat{F})$, as a function of the number of shots $M$.\n- **Task 2 (Inequality):** Derive an inequality for $M$ to ensure $\\text{Var}(\\widehat{F}) \\leq v$.\n- **Task 3 (Implementation):** Implement a program to compute the minimal integer shots $M_{\\min}$ for given test cases.\n- **Constraint:** $M_{\\min}$ must be at least $1$.\n- **Test Cases:**\n    - **Case A:** $|\\psi\\rangle=[1,0]$, $|\\phi\\rangle=[0,1]$, $v=10^{-3}$.\n    - **Case B:** $|\\psi\\rangle=[1,0]$, $|\\phi\\rangle=[e^{i \\cdot 0.7},0]$, $v=10^{-3}$.\n    - **Case C:** $a=0.3, b=1.1, c=0.2$. $|\\psi\\rangle=[\\cos a, \\sin a]$, $|\\phi\\rangle=[\\cos b, e^{ic}\\sin b]$, $v=5 \\times 10^{-4}$.\n    - **Case D:** $|\\psi\\rangle=\\frac{1}{\\sqrt{2}}[1,0,0,1]$, $|\\phi\\rangle=[1,0,0,0]$, $v=10^{-4}$.\n    - **Case E:** $a=0.2, \\delta=0.01$. $|\\psi\\rangle=[\\cos a, \\sin a]$, $|\\phi\\rangle=[\\cos(a+\\delta), \\sin(a+\\delta)]$, $v=10^{-6}$.\n- **Output Format:** A single line containing a comma-separated list of integer results: $[\\text{result}_A, \\text{result}_B, \\text{result}_C, \\text{result}_D, \\text{result}_E]$.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is firmly rooted in the principles of quantum mechanics and quantum information theory, specifically the analysis of a standard quantum circuit (the swap test). All definitions and concepts are standard in the field.\n- **Well-Posed:** The problem provides all necessary information (state definitions, target variance) to derive a formula and compute a unique numerical answer for each case. The objective is clear and the constraints are well-defined.\n- **Objective:** The problem is stated in precise mathematical and physical terms, free of ambiguity or subjective language.\n\nThe problem does not exhibit any of the invalidity flaws. It is a scientifically sound, well-posed, and objective problem.\n\n### Step 3: Verdict and Action\nThe problem is valid. I will proceed with the solution.\n\n#### Derivation of Estimator and Variance\nThe derivation proceeds by analyzing the quantum state of the system at each step of the swap test circuit. The system consists of three registers: an ancilla qubit (subscript $a$) and two registers holding the states $|\\psi\\rangle$ and $|\\phi\\rangle$. We assume $|\\psi\\rangle$ and $|\\phi\\rangle$ are normalized pure states.\n\n1.  **Initial State**: The system is initialized in the state $|\\Psi_0\\rangle = |0\\rangle_a |\\psi\\rangle |\\phi\\rangle$.\n\n2.  **First Hadamard Gate**: A Hadamard gate $H$ is applied to the ancilla qubit.\n    $$ H = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ 1 & -1 \\end{pmatrix} $$\n    The state becomes:\n    $$ |\\Psi_1\\rangle = (H \\otimes I \\otimes I) |\\Psi_0\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle_a + |1\\rangle_a) |\\psi\\rangle |\\phi\\rangle = \\frac{1}{\\sqrt{2}} \\left( |0\\rangle_a |\\psi\\rangle |\\phi\\rangle + |1\\rangle_a |\\psi\\rangle |\\phi\\rangle \\right) $$\n\n3.  **Controlled-SWAP Gate**: A controlled-SWAP (C-SWAP) gate is applied, using the ancilla as the control. The C-SWAP operation is defined as C-SWAP$|c\\rangle|x\\rangle|y\\rangle = |c\\rangle|y\\rangle|x\\rangle$ if $c=1$, and $|c\\rangle|x\\rangle|y\\rangle$ if $c=0$.\n    Applying this to $|\\Psi_1\\rangle$:\n    $$ |\\Psi_2\\rangle = \\text{C-SWAP} |\\Psi_1\\rangle = \\frac{1}{\\sqrt{2}} \\left( |0\\rangle_a |\\psi\\rangle |\\phi\\rangle + |1\\rangle_a |\\phi\\rangle |\\psi\\rangle \\right) $$\n\n4.  **Second Hadamard Gate**: Another Hadamard gate is applied to the ancilla.\n    $$ |\\Psi_3\\rangle = (H \\otimes I \\otimes I) |\\Psi_2\\rangle = \\frac{1}{\\sqrt{2}} \\left( H|0\\rangle_a |\\psi\\rangle |\\phi\\rangle + H|1\\rangle_a |\\phi\\rangle |\\psi\\rangle \\right) $$\n    Substituting $H|0\\rangle_a = \\frac{1}{\\sqrt{2}}(|0\\rangle_a + |1\\rangle_a)$ and $H|1\\rangle_a = \\frac{1}{\\sqrt{2}}(|0\\rangle_a - |1\\rangle_a)$:\n    $$ |\\Psi_3\\rangle = \\frac{1}{2} \\left[ (|0\\rangle_a + |1\\rangle_a) |\\psi\\rangle |\\phi\\rangle + (|0\\rangle_a - |1\\rangle_a) |\\phi\\rangle |\\psi\\rangle \\right] $$\n    We regroup the terms based on the ancilla's state:\n    $$ |\\Psi_3\\rangle = \\frac{1}{2} |0\\rangle_a (|\\psi\\rangle|\\phi\\rangle + |\\phi\\rangle|\\psi\\rangle) + \\frac{1}{2} |1\\rangle_a (|\\psi\\rangle|\\phi\\rangle - |\\phi\\rangle|\\psi\\rangle) $$\n\n5.  **Measurement Probabilities**: We measure the ancilla in the computational basis $\\{|0\\rangle, |1\\rangle\\}$. The projectors are $\\Pi_0 = |0\\rangle_a\\langle 0|_a$ and $\\Pi_1 = |1\\rangle_a\\langle 1|_a$. According to the Born rule, the probability $p_k$ of obtaining outcome $k$ is $p_k = \\langle\\Psi_3|\\Pi_k|\\Psi_3\\rangle$.\n\n    The probability of measuring $|0\\rangle$, denoted $p_0$, is the squared norm of the part of the state associated with $|0\\rangle_a$:\n    $$ p_0 = \\left\\| \\frac{1}{2} |0\\rangle_a (|\\psi\\rangle|\\phi\\rangle + |\\phi\\rangle|\\psi\\rangle) \\right\\|^2 = \\frac{1}{4} \\left(\\langle\\psi|\\langle\\phi| + \\langle\\phi|\\langle\\psi|\\right) \\left(|\\psi\\rangle|\\phi\\rangle + |\\phi\\rangle|\\psi\\rangle\\right) $$\n    $$ p_0 = \\frac{1}{4} (\\langle\\psi|\\psi\\rangle\\langle\\phi|\\phi\\rangle + \\langle\\psi|\\phi\\rangle\\langle\\phi|\\psi\\rangle + \\langle\\phi|\\psi\\rangle\\langle\\psi|\\phi\\rangle + \\langle\\phi|\\phi\\rangle\\langle\\psi|\\psi\\rangle) $$\n    Since the states are normalized, $\\langle\\psi|\\psi\\rangle = 1$ and $\\langle\\phi|\\phi\\rangle = 1$. The fidelity is $F = |\\langle\\psi|\\phi\\rangle|^2$. Also, $\\langle\\phi|\\psi\\rangle = (\\langle\\psi|\\phi\\rangle)^*$.\n    $$ p_0 = \\frac{1}{4} (1 + |\\langle\\psi|\\phi\\rangle|^2 + |\\langle\\psi|\\phi\\rangle|^2 + 1) = \\frac{1}{4}(2 + 2F) = \\frac{1}{2}(1 + F) $$\n    The probability of measuring $|1\\rangle$, denoted $p_1$, is simply $1-p_0$:\n    $$ p_1 = 1 - p_0 = 1 - \\frac{1}{2}(1 + F) = \\frac{1}{2}(1 - F) $$\n\n6.  **Fidelity Estimator**: We seek an unbiased estimator for $F$. Let us define a random variable $m$ for a single measurement outcome, assigning $m=+1$ if the ancilla is measured as $|0\\rangle$ and $m=-1$ if measured as $|1\\rangle$. This corresponds to measuring the Pauli-$Z$ observable $\\sigma_z$ on the ancilla. The expectation value of this variable is:\n    $$ E[m] = (+1) \\cdot p_0 + (-1) \\cdot p_1 = p_0 - p_1 = \\frac{1}{2}(1+F) - \\frac{1}{2}(1-F) = F $$\n    The expectation value of a single measurement is the fidelity $F$. Therefore, after $M$ independent and identically distributed shots, the sample mean is an unbiased estimator for $F$:\n    $$ \\widehat{F} = \\frac{1}{M}\\sum_{i=1}^M m_i $$\n    where $m_i$ is the outcome of the $i$-th shot. The expectation value of the estimator is $E[\\widehat{F}] = E\\left[\\frac{1}{M}\\sum m_i\\right] = \\frac{1}{M}\\sum E[m_i] = \\frac{1}{M} (M \\cdot F) = F$.\n\n7.  **Variance of the Estimator**: For i.i.d. random variables, the variance of the sample mean is $\\text{Var}(\\widehat{F}) = \\frac{\\text{Var}(m)}{M}$. We compute the variance of a single outcome $m$:\n    $$ \\text{Var}(m) = E[m^2] - (E[m])^2 $$\n    The possible values for $m$ are $+1$ and $-1$, so $m^2=1$ in all cases. This means $E[m^2] = 1$. We already found $E[m]=F$.\n    $$ \\text{Var}(m) = 1 - F^2 $$\n    Therefore, the variance of the fidelity estimator is:\n    $$ \\text{Var}(\\widehat{F}) = \\frac{1-F^2}{M} $$\n\n#### Minimum Number of Shots\nThe problem requires that the estimator variance be no greater than a specified value $v$:\n$$ \\text{Var}(\\widehat{F}) \\le v \\implies \\frac{1-F^2}{M} \\le v $$\nSolving for $M$, and noting that $1-F^2 \\ge 0$ since $0 \\le F \\le 1$:\n$$ M \\ge \\frac{1-F^2}{v} $$\nSince the number of shots $M$ must be an integer, the minimum number of shots is the smallest integer satisfying this inequality, which is given by the ceiling function:\n$$ M_{\\min} = \\left\\lceil \\frac{1-F^2}{v} \\right\\rceil $$\nThe problem also imposes the constraint that at least one shot must be performed. This is relevant when $F=1$, which makes the numerator zero, yielding a raw shot count of $0$. We incorporate this with a $\\max$ function:\n$$ M_{\\min} = \\max\\left(1, \\left\\lceil \\frac{1-F^2}{v} \\right\\rceil\\right) $$\n\n#### Algorithmic Implementation\nThe program will execute the following steps for each test case:\n1.  Construct the complex state vectors $|\\psi\\rangle$ and $|\\phi\\rangle$ using the provided parameters. Normalization is performed as a safeguard, though the provided states are defined to be normalized.\n2.  Compute the inner product $\\langle\\psi|\\phi\\rangle$. In NumPy, this is `np.vdot(psi, phi)`.\n3.  Calculate the exact fidelity $F = |\\langle\\psi|\\phi\\rangle|^2$.\n4.  Use the derived formula to calculate the minimal integer number of shots $M_{\\min}$ required to achieve the target variance $v$.\n5.  Collect the integer results for all cases and format them as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the minimum number of swap test shots\n    to estimate fidelity with a given estimator variance.\n    \"\"\"\n\n    # Helper function to compute the minimum number of shots\n    def get_min_shots(psi, phi, v):\n        \"\"\"\n        Calculates the minimum shots M_min for a given pair of states and target variance.\n\n        Args:\n            psi (np.ndarray): The first quantum state vector.\n            phi (np.ndarray): The second quantum state vector.\n            v (float): The target maximum variance for the fidelity estimator.\n\n        Returns:\n            int: The minimum number of integer shots required.\n        \"\"\"\n        # Ensure states are normalized for numerical stability\n        psi = psi / np.linalg.norm(psi)\n        phi = phi / np.linalg.norm(phi)\n\n        # Compute the fidelity F = |<psi|phi>|^2\n        # np.vdot computes the dot product of psi.conj() and phi\n        inner_product = np.vdot(psi, phi)\n        fidelity = np.abs(inner_product)**2\n\n        # The variance of the fidelity estimator is (1 - F^2) / M.\n        # We require Var <= v, so M >= (1 - F^2) / v.\n        # The numerator (1 - F^2) is always non-negative since 0 <= F <= 1.\n        if v <= 0:\n            # Variance must be positive. If v is non-positive, the inequality\n            # can only be satisfied if 1 - F^2 is 0. If not, M would be infinite.\n            # In a practical setting, this would be an error, but for this problem,\n            # we can handle the F=1 case.\n            if np.isclose(fidelity, 1.0):\n                # Numerator is 0, so M >= 0.\n                min_shots_float = 0.0\n            else:\n                # M would need to be infinite, but we return a large number\n                # as a placeholder for an impossible requirement. Given problem constraints,\n                # v is always positive.\n                return int(1e18) \n        else:\n            min_shots_float = (1 - fidelity**2) / v\n        \n        # M_min must be an integer, so we take the ceiling.\n        m_min_raw = int(np.ceil(min_shots_float))\n        \n        # Enforce the constraint that at least 1 shot is required.\n        m_min = max(1, m_min_raw)\n        \n        return m_min\n\n    results = []\n    \n    # Case A: orthogonal 1-qubit states\n    psi_A = np.array([1.0, 0.0], dtype=np.complex128)\n    phi_A = np.array([0.0, 1.0], dtype=np.complex128)\n    v_A = 1e-3\n    results.append(get_min_shots(psi_A, phi_A, v_A))\n\n    # Case B: global phase invariance\n    psi_B = np.array([1.0, 0.0], dtype=np.complex128)\n    phi_B = np.array([np.exp(1j * 0.7), 0.0], dtype=np.complex128)\n    v_B = 1e-3\n    results.append(get_min_shots(psi_B, phi_B, v_B))\n\n    # Case C: general 1-qubit superpositions\n    a_C, b_C, c_C = 0.3, 1.1, 0.2\n    v_C = 5e-4\n    psi_C = np.array([np.cos(a_C), np.sin(a_C)], dtype=np.complex128)\n    phi_C = np.array([np.cos(b_C), np.exp(1j * c_C) * np.sin(b_C)], dtype=np.complex128)\n    results.append(get_min_shots(psi_C, phi_C, v_C))\n    \n    # Case D: 2-qubit entangled versus product\n    psi_D = (1/np.sqrt(2)) * np.array([1.0, 0.0, 0.0, 1.0], dtype=np.complex128)\n    phi_D = np.array([1.0, 0.0, 0.0, 0.0], dtype=np.complex128)\n    v_D = 1e-4\n    results.append(get_min_shots(psi_D, phi_D, v_D))\n\n    # Case E: nearly identical 1-qubit states\n    a_E, delta_E = 0.2, 0.01\n    v_E = 1e-6\n    psi_E = np.array([np.cos(a_E), np.sin(a_E)], dtype=np.complex128)\n    phi_E = np.array([np.cos(a_E + delta_E), np.sin(a_E + delta_E)], dtype=np.complex128)\n    results.append(get_min_shots(psi_E, phi_E, v_E))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3181173"}, {"introduction": "This final practice shifts our perspective from forward simulation to an inverse problem: can we deduce the governing laws of a system from experimental observation? You will step into the role of an experimentalist to perform Hamiltonian learning for a single qubit, reconstructing its unknown Hamiltonian from simulated, noisy measurement data [@problem_id:3181125]. This involves simulating the qubit's precession, modeling the statistical noise from finite measurement shots, and then using numerical differentiation and linear regression to solve for the Hamiltonian parameters. This exercise demonstrates a powerful and practical application of computational science, showcasing how data analysis techniques are used to characterize and understand the fundamental properties of quantum systems.", "problem": "You will implement Hamiltonian learning for a single qubit by reconstructing an unknown time-independent Hamiltonian from noisy time-series measurements of observables and quantifying the reconstruction error under finite measurement shots and limited timesteps. Work in natural units with reduced Planck constant set to $1$ so that all quantities are dimensionless. The unknown Hamiltonian has the form $H = \\tfrac{1}{2}\\,\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$, where $\\mathbf{h} \\in \\mathbb{R}^3$ is an unknown vector and $\\boldsymbol{\\sigma} = (\\sigma_x,\\sigma_y,\\sigma_z)$ are the Pauli operators. A pure initial state is represented by its Bloch vector $\\mathbf{r}(0) \\in \\mathbb{R}^3$ with $\\|\\mathbf{r}(0)\\|=1$, and its Bloch vector $\\mathbf{r}(t)$ evolves in time under the dynamics generated by $H$.\n\nFundamental base and modeling assumptions:\n- The Heisenberg equation of motion states that $\\tfrac{d}{dt}\\langle O\\rangle = i \\langle [H,O]\\rangle$ for any observable $O$, and the Pauli commutation relations state $[\\sigma_a,\\sigma_b]=2i\\sum_{c}\\epsilon_{abc}\\sigma_c$, where $\\epsilon_{abc}$ is the Levi-Civita symbol.\n- For a single qubit with $H=\\tfrac{1}{2}\\,\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$, the Bloch vector obeys $\\tfrac{d}{dt}\\mathbf{r}(t)=\\mathbf{h}\\times \\mathbf{r}(t)$, where $\\times$ denotes the vector cross product.\n- A projective measurement of $\\sigma_k$ at time $t$ yields an outcome in $\\{+1,-1\\}$ with probabilities $p_{+}(t)=\\tfrac{1+\\langle\\sigma_k\\rangle_t}{2}$ and $p_{-}(t)=\\tfrac{1-\\langle\\sigma_k\\rangle_t}{2}$, where $\\langle\\sigma_k\\rangle_t=r_k(t)$ is the $k$-th component of $\\mathbf{r}(t)$. With $N$ independent shots, the sample mean is an unbiased estimator of $r_k(t)$ with variance decreasing as $1/N$.\n\nYour program must:\n1. Fix the true Hamiltonian parameter vector to $\\mathbf{h}_{\\text{true}} = (0.9,-1.2,0.7)$ and the initial Bloch vector to $\\mathbf{r}(0) = \\frac{(0.3,0.8,0.5)}{\\|(0.3,0.8,0.5)\\|}$.\n2. Simulate the exact noiseless time evolution of the Bloch vector $\\mathbf{r}(t)$ implied by the dynamics $\\tfrac{d}{dt}\\mathbf{r}(t)=\\mathbf{h}\\times \\mathbf{r}(t)$. You may compute $\\mathbf{r}(t_k)$ at discrete times $t_k = k\\,\\Delta t$ for $k=0,1,\\dots,N_t-1$ using any correct method consistent with the stated laws (for example, propagating the state by unitary evolution or using rotation of the Bloch vector about the axis $\\mathbf{h}$).\n3. Model finite-shot measurements at each time $t_k$ for each Pauli observable $\\sigma_x,\\sigma_y,\\sigma_z$ by drawing $N$ outcomes in $\\{+1,-1\\}$ with probabilities determined by the exact expectations and computing the sample mean for each component, yielding a noisy estimate $\\widehat{\\mathbf{r}}(t_k)$.\n4. Estimate the time derivative $\\tfrac{d}{dt}\\mathbf{r}(t)$ at interior times using a central finite difference on the noisy estimates: for $k=1,\\dots,N_t-2$, set $\\widehat{\\dot{\\mathbf{r}}}(t_k) = \\frac{\\widehat{\\mathbf{r}}(t_{k+1}) - \\widehat{\\mathbf{r}}(t_{k-1})}{2\\,\\Delta t}$.\n5. Use linear regression to estimate $\\mathbf{h}$ from the relation $\\dot{\\mathbf{r}}(t) = \\mathbf{h}\\times \\mathbf{r}(t)$. Write this as a linear system $\\dot{\\mathbf{r}}(t_k)=C(\\mathbf{r}(t_k))\\,\\mathbf{h}$, where $C(\\mathbf{r})$ is the $3\\times 3$ matrix\n$$\nC(\\mathbf{r})=\\begin{bmatrix}\n0 & r_z & -r_y\\\\\n-r_z & 0 & r_x\\\\\nr_y & -r_x & 0\n\\end{bmatrix}.\n$$\nConstruct an overdetermined system by stacking all interior times with $C(\\widehat{\\mathbf{r}}(t_k))$ on the left-hand side and $\\widehat{\\dot{\\mathbf{r}}}(t_k)$ on the right-hand side, and compute the least squares estimate $\\widehat{\\mathbf{h}}$ that minimizes the sum of squared residuals. Here, you must use Ordinary Least Squares (OLS), that is, unweighted least squares without additional regularization.\n6. Quantify the reconstruction error for each test case as the Euclidean norm $e=\\|\\widehat{\\mathbf{h}}-\\mathbf{h}_{\\text{true}}\\|_2$.\n\nUse a fixed pseudorandom seed $12345$ for all random sampling to make the results reproducible.\n\nTest suite:\nRun your program for the following five cases, each specified by the triple $(N_t,\\Delta t,N)$:\n- Case $1$ (happy path): $(101,\\,0.05,\\,20000)$.\n- Case $2$ (limited timesteps): $(7,\\,0.2,\\,20000)$.\n- Case $3$ (finite shots): $(101,\\,0.05,\\,200)$.\n- Case $4$ (limited timesteps and finite shots): $(7,\\,0.2,\\,200)$.\n- Case $5$ (many timesteps but very few shots): $(401,\\,0.01,\\,50)$.\n\nFinal output format:\nYour program should produce a single line of output containing the list of errors for the five cases, in order, as a comma-separated list enclosed in square brackets. Each error must be rounded to exactly six digits after the decimal point. For example: $[0.123456,0.000001,0.314159,0.271828,0.000000]$. No other text should be printed.", "solution": "The problem is assessed to be valid as it is scientifically grounded in the principles of single-qubit quantum dynamics, is mathematically and algorithmically well-posed, and provides a complete and consistent set of requirements for a solvable computational task.\n\nThe objective is to reconstruct the Hamiltonian vector $\\mathbf{h}$ of a single-qubit system, described by $H = \\frac{1}{2}\\mathbf{h}\\cdot\\boldsymbol{\\sigma}$, from noisy time-series data. The procedure involves simulating the system's evolution, modeling measurement noise, estimating time derivatives from the noisy data, and applying linear regression to infer $\\mathbf{h}$.\n\n**Step 1: Simulation of Exact Qubit Dynamics**\nThe evolution of the qubit's state, represented by the Bloch vector $\\mathbf{r}(t)$, is governed by the differential equation $\\frac{d}{dt}\\mathbf{r}(t) = \\mathbf{h} \\times \\mathbf{r}(t)$. This equation describes the precession of the vector $\\mathbf{r}(t)$ around the constant vector $\\mathbf{h}$ with an angular frequency $\\omega = \\|\\mathbf{h}\\|_2$. The exact analytical solution for $\\mathbf{r}(t)$ given an initial state $\\mathbf{r}(0)$ is provided by Rodrigues' rotation formula:\n$$\n\\mathbf{r}(t) = \\mathbf{r}(0)\\cos(\\omega t) + (\\hat{\\mathbf{h}} \\times \\mathbf{r}(0))\\sin(\\omega t) + \\hat{\\mathbf{h}}(\\hat{\\mathbf{h}} \\cdot \\mathbf{r}(0))(1 - \\cos(\\omega t))\n$$\nwhere $\\hat{\\mathbf{h}} = \\mathbf{h}/\\|\\mathbf{h}\\|_2$ is the unit vector along the Hamiltonian axis. We use this formula to compute the exact, noiseless Bloch vector $\\mathbf{r}(t_k)$ at discrete time points $t_k = k\\Delta t$ for $k=0, 1, \\dots, N_t-1$.\n\n**Step 2: Simulation of Measurement Noise**\nIn a real experiment, the expectation values $\\langle \\sigma_j \\rangle_t = r_j(t)$ are not directly accessible. They are estimated from a finite number of projective measurements. For a measurement of the Pauli operator $\\sigma_j$ on a system in a state with expectation value $r_j(t)$, the outcomes are $\\{+1, -1\\}$. The probability of obtaining the outcome $+1$ is given by $p_+(t) = \\frac{1 + r_j(t)}{2}$.\nTo simulate this process, we perform $N$ independent trials (shots). The number of times the outcome $+1$ is observed, $n_+$, follows a binomial distribution, $n_+ \\sim \\text{Binomial}(N, p_+)$. The empirical estimate for the expectation value, $\\widehat{r}_j(t)$, is the sample mean of the outcomes:\n$$\n\\widehat{r}_j(t) = \\frac{n_+ \\cdot (+1) + (N - n_+) \\cdot (-1)}{N} = \\frac{2n_+ - N}{N}\n$$\nThis procedure is applied at each time $t_k$ for each component $\\{x, y, z\\}$ to generate the noisy time-series data $\\widehat{\\mathbf{r}}(t_k)$.\n\n**Step 3: Numerical Estimation of the Time Derivative**\nTo utilize the dynamical equation $\\dot{\\mathbf{r}} = \\mathbf{h} \\times \\mathbf{r}$, we must estimate the time derivative of the Bloch vector from the noisy, discrete data $\\widehat{\\mathbf{r}}(t_k)$. We employ a second-order central finite difference scheme, which offers a good balance between accuracy and noise amplification. For interior time points $t_k$ where $k \\in \\{1, \\dots, N_t-2\\}$, the derivative is estimated as:\n$$\n\\widehat{\\dot{\\mathbf{r}}}(t_k) = \\frac{\\widehat{\\mathbf{r}}(t_{k+1}) - \\widehat{\\mathbf{r}}(t_{k-1})}{2\\Delta t}\n$$\n\n**Step 4: Hamiltonian Estimation via Linear Regression**\nThe core of the reconstruction is to solve for $\\mathbf{h}$ from the dynamical equation. We rewrite the cross product as a matrix-vector multiplication: $\\mathbf{h} \\times \\mathbf{r}(t) = C(\\mathbf{r}(t))\\mathbf{h}$, where $C(\\mathbf{r})$ is the skew-symmetric matrix:\n$$\nC(\\mathbf{r}) = \\begin{bmatrix}\n0 & r_z & -r_y\\\\\n-r_z & 0 & r_x\\\\\nr_y & -r_x & 0\n\\end{bmatrix}\n$$\nSubstituting our noisy estimates for the state and its derivative, we obtain a set of approximate linear equations for each interior time point $t_k$:\n$$\n\\widehat{\\dot{\\mathbf{r}}}(t_k) \\approx C(\\widehat{\\mathbf{r}}(t_k))\\mathbf{h}\n$$\nBy stacking these $3$-dimensional vector equations for all $N_t-2$ interior points, we form a single large, overdetermined linear system of the form $A\\mathbf{h} \\approx \\mathbf{b}$. The design matrix $A$ is a tall matrix of size $(3(N_t-2)) \\times 3$, constructed by vertically stacking the individual $C(\\widehat{\\mathbf{r}}(t_k))$ matrices. The observation vector $\\mathbf{b}$ has size $(3(N_t-2)) \\times 1$ and is formed by stacking the estimated derivative vectors $\\widehat{\\dot{\\mathbf{r}}}(t_k)$.\nThe problem specifies using Ordinary Least Squares (OLS) to find the estimate $\\widehat{\\mathbf{h}}$ that minimizes the sum of squared residuals, i.e., $\\|\\mathbf{b} - A\\widehat{\\mathbf{h}}\\|_2^2$. This solution is given formally by $\\widehat{\\mathbf{h}} = (A^T A)^{-1}A^T \\mathbf{b}$, though it is computed using more numerically stable algorithms such as QR decomposition.\n\n**Step 5: Error Quantification**\nFinally, the accuracy of the Hamiltonian reconstruction is quantified by calculating the Euclidean norm of the difference between the estimated vector $\\widehat{\\mathbf{h}}$ and the true vector $\\mathbf{h}_{\\text{true}}$:\n$$\ne = \\|\\widehat{\\mathbf{h}} - \\mathbf{h}_{\\text{true}}\\|_2\n$$\nThis entire procedure is repeated for each test case specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Implements Hamiltonian learning for a single qubit from noisy measurements.\n    \"\"\"\n    \n    # Define globally fixed parameters\n    h_true = np.array([0.9, -1.2, 0.7])\n    r0_unnormalized = np.array([0.3, 0.8, 0.5])\n    r0 = r0_unnormalized / np.linalg.norm(r0_unnormalized)\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (101, 0.05, 20000),  # Case 1: happy path\n        (7, 0.2, 20000),   # Case 2: limited timesteps\n        (101, 0.05, 200),    # Case 3: finite shots\n        (7, 0.2, 200),     # Case 4: limited timesteps and finite shots\n        (401, 0.01, 50),     # Case 5: many timesteps but very few shots\n    ]\n\n    results = []\n    \n    for Nt, dt, N in test_cases:\n        # Step 1: Simulate exact time evolution of the Bloch vector\n        # This uses Rodrigues' rotation formula.\n        omega = np.linalg.norm(h_true)\n        h_hat = h_true / omega\n        times = np.linspace(0, (Nt - 1) * dt, Nt)\n        \n        cos_omega_t = np.cos(omega * times)\n        sin_omega_t = np.sin(omega * times)\n        \n        r0_dot_h_hat = np.dot(r0, h_hat)\n        h_hat_cross_r0 = np.cross(h_hat, r0)\n        \n        # Broadcasting to calculate r(t) for all times at once\n        r_exact = (r0[:, np.newaxis] * cos_omega_t +\n                   h_hat_cross_r0[:, np.newaxis] * sin_omega_t +\n                   h_hat[:, np.newaxis] * r0_dot_h_hat * (1 - cos_omega_t)).T\n\n        # Step 2: Model finite-shot measurements to get noisy estimates\n        r_noisy = np.zeros_like(r_exact)\n        for k in range(Nt):\n            for j in range(3):\n                # Probability of measuring +1\n                p_plus = (1 + r_exact[k, j]) / 2\n                # Number of +1 outcomes in N shots\n                n_plus = rng.binomial(N, p_plus)\n                # Sample mean is the estimate for the expectation value\n                r_noisy[k, j] = (2 * n_plus - N) / N\n                \n        # Step 3: Estimate the time derivative using a central finite difference\n        # This applies to interior points k=1, ..., Nt-2\n        r_dot_noisy = (r_noisy[2:] - r_noisy[:-2]) / (2 * dt)\n        \n        # Step 4: Use linear regression to estimate h\n        # We solve A*h = b, where A is the design matrix and b is the observation vector.\n        num_interior_points = Nt - 2\n        \n        # We need r_noisy at the same interior points for constructing C(r)\n        r_noisy_interior = r_noisy[1:-1]\n        \n        # Construct the design matrix A by stacking C(r(t_k)) matrices\n        A = np.zeros((3 * num_interior_points, 3))\n        \n        rx, ry, rz = r_noisy_interior[:, 0], r_noisy_interior[:, 1], r_noisy_interior[:, 2]\n        \n        # A_ij is C(r_i)_j\n        # Populate A based on the structure of C(r)\n        A[0::3, 1] = rz\n        A[0::3, 2] = -ry\n        A[1::3, 0] = -rz\n        A[1::3, 2] = rx\n        A[2::3, 0] = ry\n        A[2::3, 1] = -rx\n        \n        # Construct the observation vector b by flattening the estimated derivatives\n        b = r_dot_noisy.flatten()\n        \n        # Solve the overdetermined system using Ordinary Least Squares\n        h_estimated, _, _, _ = linalg.lstsq(A, b)\n        \n        # Step 5: Quantify the reconstruction error\n        error = np.linalg.norm(h_estimated - h_true)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.6f}' for err in results)}]\")\n\nsolve()\n```", "id": "3181125"}]}