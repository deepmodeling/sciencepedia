{"hands_on_practices": [{"introduction": "Before applying any numerical scheme, we must understand its fundamental limits, chief among them being stability. This practice moves beyond simply accepting the Courant-Friedrichs-Lewy (CFL) condition as a given by guiding you to computationally verify it from first principles. By deriving and implementing the von Neumann stability analysis for the Lax-Friedrichs scheme, you will solidify your understanding of how numerical errors are controlled and why the CFL condition, $|\\nu| = |a \\Delta t / \\Delta x| \\le 1$, emerges as a necessary constraint [@problem_id:3151507].", "problem": "You are to write a complete and runnable program that empirically maps the stability region of the Lax–Friedrichs scheme applied to the constant-coefficient linear advection equation $u_t + a\\,u_x = 0$, and then compares this empirical region to the theoretical bound given by the Courant–Friedrichs–Lewy (CFL) condition. Work from first principles by using the standard Fourier stability (von Neumann) reasoning: on a uniform grid, linear, translation-invariant schemes admit plane-wave modes $e^{\\mathrm{i}(j\\theta - n\\omega)}$ and thus a one-step amplification factor $g(\\theta,\\nu)$, where $\\theta$ is the nondimensional wavenumber and $\\nu$ is the nondimensional time-step parameter (Courant number). For the Lax–Friedrichs scheme constructed via two-point averaging in space combined with a centered difference for the flux and explicit forward Euler in time, this amplification factor can be derived from the scheme definition and used to test stability by verifying whether $\\lvert g(\\theta,\\nu)\\rvert \\le 1$ for all $\\theta$.\n\nYour program must implement the following tasks purely numerically:\n- Sweep a set of Courant numbers $\\nu = a\\,\\Delta t/\\Delta x$ across a specified interval, and for each $\\nu$ sweep the nondimensional wavenumber $\\theta$ over the interval $[0,\\pi]$ (angles in radians). For each pair $(\\nu,\\theta)$ compute the magnitude of the one-step amplification factor $\\lvert g(\\theta,\\nu)\\rvert$ that is implied by the Lax–Friedrichs scheme and Fourier mode analysis. For each $\\nu$, define the empirical stability indicator as $\\max_{\\theta\\in[0,\\pi]} \\lvert g(\\theta,\\nu)\\rvert \\le 1$ (allow an absolute tolerance when comparing to $1$ to avoid floating-point artifacts).\n- Construct the theoretical stability indicator based on the CFL condition for the Lax–Friedrichs scheme, expressed solely in terms of $\\nu$, and compare it to the empirical indicator across the sweep.\n\nUse the following test suite to probe different aspects of the comparison between empirical stability and theoretical CFL bounds. In all tests, interpret $\\theta$ in radians.\n- Test A (general sweep): $\\nu \\in [-1.5,\\,1.5]$ sampled with step size $0.01$, and $\\theta \\in [0,\\pi]$ sampled with $2049$ equally spaced points. Use an absolute tolerance of $10^{-12}$ when deciding whether $\\max_{\\theta}\\lvert g(\\theta,\\nu)\\rvert \\le 1$. Output a boolean that is $\\,\\mathrm{True}\\,$ if and only if the empirical stability indicator for every sampled $\\nu$ matches the theoretical indicator for that $\\nu$, and $\\,\\mathrm{False}\\,$ otherwise.\n- Test B (boundary check): take the two values $\\nu=-1$ and $\\nu=1$, and sweep $\\theta \\in [0,\\pi]$ with $10001$ equally spaced points. Compute, for these two $\\nu$ values, the quantity $\\max_{\\theta} \\lvert g(\\theta,\\nu)\\rvert - 1$, and output a single float equal to the maximum absolute value of this quantity over the two boundary values of $\\nu$.\n- Test C (outside-CFL rejection, coarse grid): $\\nu \\in [-2,\\,2]$ sampled with step size $0.5$, and $\\theta \\in [0,\\pi]$ sampled with $33$ equally spaced points. Output a boolean that is $\\,\\mathrm{True}\\,$ if and only if for every sampled $\\nu$ with $\\lvert\\nu\\rvert > 1$ one has $\\max_{\\theta}\\lvert g(\\theta,\\nu)\\rvert > 1$ by at least $10^{-9}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for Tests A, B, and C as a comma-separated list enclosed in square brackets, in that order, for example: \"[rA,rB,rC]\".\n- Ensure that there is exactly one list on a single line and no additional output.\n\nNotes and constraints:\n- The only quantities that may be assumed from theory are the linear advection equation $u_t + a\\,u_x = 0$, the definition $\\nu = a\\,\\Delta t/\\Delta x$, the characterization of stability via $\\lvert g(\\theta,\\nu)\\rvert \\le 1$, and that the Lax–Friedrichs scheme uses spatial averaging and a centered flux with forward Euler time stepping. All other expressions must be derived or reasoned in your solution.\n- Angles must be in radians.\n- There are no physical units to report in the output; all quantities are nondimensional.", "solution": "The problem requires an empirical validation of the stability region for the Lax-Friedrichs numerical scheme applied to the one-dimensional linear advection equation, $u_t + a u_x = 0$. The analysis is to be performed from first principles using Fourier (von Neumann) stability analysis and compared against the theoretical Courant–Friedrichs–Lewy (CFL) condition.\n\nFirst, we derive the explicit form of the Lax-Friedrichs scheme and its amplification factor. The scheme is constructed on a uniform grid with spatial step $\\Delta x$ and time step $\\Delta t$. Let $u_j^n$ denote the numerical approximation of the solution $u(x_j, t_n)$ at grid point $x_j = j\\Delta x$ and time level $t_n = n\\Delta t$. The scheme is defined by a forward Euler step in time, where the value $u_j^n$ is replaced by a spatial average, and the spatial derivative $u_x$ is approximated by a centered difference. The equation $u_t = -a u_x$ is thus discretized as:\n$$\n\\frac{u_j^{n+1} - \\frac{1}{2}(u_{j+1}^n + u_{j-1}^n)}{\\Delta t} = -a \\left( \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x} \\right)\n$$\nSolving for $u_j^{n+1}$ yields:\n$$\nu_j^{n+1} = \\frac{1}{2}(u_{j+1}^n + u_{j-1}^n) - \\frac{a \\Delta t}{2\\Delta x}(u_{j+1}^n - u_{j-1}^n)\n$$\nBy defining the nondimensional Courant number $\\nu = a \\Delta t / \\Delta x$, we can simplify the expression:\n$$\nu_j^{n+1} = \\frac{1}{2}(u_{j+1}^n + u_{j-1}^n) - \\frac{\\nu}{2}(u_{j+1}^n - u_{j-1}^n)\n$$\nGrouping terms by their spatial indices gives the final form of the scheme:\n$$\nu_j^{n+1} = \\left(\\frac{1 - \\nu}{2}\\right) u_{j+1}^n + \\left(\\frac{1 + \\nu}{2}\\right) u_{j-1}^n\n$$\nFor von Neumann stability analysis, we substitute a single Fourier mode, $u_j^n = g^n(\\theta, \\nu) e^{\\mathrm{i} j \\theta}$, into the scheme. Here, $\\theta$ is the nondimensional wavenumber and $g(\\theta, \\nu)$ is the one-step amplification factor.\n$$\ng^{n+1} e^{\\mathrm{i} j \\theta} = \\left(\\frac{1 - \\nu}{2}\\right) g^n e^{\\mathrm{i} (j+1) \\theta} + \\left(\\frac{1 + \\nu}{2}\\right) g^n e^{\\mathrm{i} (j-1) \\theta}\n$$\nDividing by $g^n e^{\\mathrm{i} j \\theta}$, we obtain the expression for the amplification factor $g \\equiv g(\\theta, \\nu)$:\n$$\ng = \\left(\\frac{1 - \\nu}{2}\\right) e^{\\mathrm{i} \\theta} + \\left(\\frac{1 + \\nu}{2}\\right) e^{-\\mathrm{i} \\theta}\n$$\nUsing Euler's identity, $e^{\\pm \\mathrm{i} \\theta} = \\cos\\theta \\pm \\mathrm{i}\\sin\\theta$, we can separate the real and imaginary parts of $g$:\n$$\ng = \\frac{1}{2} (e^{\\mathrm{i} \\theta} + e^{-\\mathrm{i} \\theta}) - \\frac{\\nu}{2} (e^{\\mathrm{i} \\theta} - e^{-\\mathrm{i} \\theta}) = \\cos\\theta - \\nu (\\mathrm{i}\\sin\\theta)\n$$\nSo, the amplification factor is $g(\\theta, \\nu) = \\cos\\theta - \\mathrm{i}\\nu\\sin\\theta$.\n\nFor the scheme to be stable, the magnitude of the amplification factor must not exceed $1$ for any wavenumber $\\theta$, i.e., $\\lvert g(\\theta, \\nu) \\rvert \\le 1$. The magnitude is computed as:\n$$\n\\lvert g(\\theta, \\nu) \\rvert = \\sqrt{(\\mathrm{Re}(g))^2 + (\\mathrm{Im}(g))^2} = \\sqrt{\\cos^2\\theta + (-\\nu\\sin\\theta)^2} = \\sqrt{\\cos^2\\theta + \\nu^2\\sin^2\\theta}\n$$\nThe stability condition is therefore $\\sqrt{\\cos^2\\theta + \\nu^2\\sin^2\\theta} \\le 1$. Since both sides are non-negative, we can square them:\n$$\n\\cos^2\\theta + \\nu^2\\sin^2\\theta \\le 1\n$$\nUsing the identity $\\cos^2\\theta = 1 - \\sin^2\\theta$, we get:\n$$\n1 - \\sin^2\\theta + \\nu^2\\sin^2\\theta \\le 1 \\implies (\\nu^2 - 1)\\sin^2\\theta \\le 0\n$$\nSince $\\sin^2\\theta \\ge 0$ for all real $\\theta$, this inequality holds for all $\\theta$ if and only if the coefficient $(\\nu^2 - 1)$ is non-positive:\n$$\n\\nu^2 - 1 \\le 0 \\implies \\nu^2 \\le 1 \\implies \\lvert\\nu\\rvert \\le 1\n$$\nThis is the theoretical CFL stability condition for the Lax-Friedrichs scheme. The program will empirically test this condition. The maximum value of $\\lvert g(\\theta, \\nu) \\rvert$ is found at $\\theta=0$ and $\\theta=\\pi$ (where $\\lvert g \\rvert = 1$) or at $\\theta = \\pi/2$ (where $\\lvert g \\rvert = \\lvert\\nu\\rvert$). Thus, $\\max_\\theta \\lvert g(\\theta, \\nu) \\rvert = \\max(1, \\lvert\\nu\\rvert)$. The empirical stability test, $\\max_\\theta \\lvert g(\\theta, \\nu) \\rvert \\le 1$, is therefore analytically equivalent to the theoretical condition $\\lvert\\nu\\rvert \\le 1$.\n\nThe program implements the following three tests:\nTest A: This test performs a fine-grained sweep of $\\nu$ from $-1.5$ to $1.5$ with a step of $0.01$, and for each $\\nu$, it samples $\\theta$ across $[0, \\pi]$ with $2049$ points. It compares the empirical stability indicator, `max_g <= 1 + 1e-12`, with the theoretical indicator, `abs(nu) <= 1`. The result is `True` if they match for all $\\nu$, and `False` otherwise.\n\nTest B: This test checks the stability boundary. For $\\nu = -1$ and $\\nu = 1$, the analytical result is $\\max_\\theta \\lvert g(\\theta, \\nu) \\rvert = 1$. The test computes the numerical value of $\\max_\\theta \\lvert g(\\theta, \\nu) \\rvert - 1$ for these two $\\nu$ values using a dense sampling of $\\theta$ ($10001$ points) and reports the maximum absolute deviation, which quantifies the numerical precision.\n\nTest C: This test confirms that the scheme is unstable outside the CFL limit. It sweeps $\\nu$ from $-2$ to $2$ with a step of $0.5$. For each $\\nu$ where $\\lvert\\nu\\rvert > 1$, it verifies that the computed $\\max_\\theta \\lvert g(\\theta, \\nu) \\rvert$ is greater than $1$ by at least $10^{-9}$. A coarse grid of $33$ points for $\\theta$ is used, which is sufficient because it includes the critical point $\\theta = \\pi/2$ where the maximum amplification occurs for unstable $\\nu$. The result is `True` if all checked $\\nu$ values are confirmed to be unstable.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically maps and validates the stability region of the Lax-Friedrichs scheme.\n    \"\"\"\n\n    def get_max_g_mag(nu, theta_vals):\n        \"\"\"\n        Computes the maximum magnitude of the amplification factor for a given Courant number nu.\n        The amplification factor g(theta, nu) = cos(theta) - i*nu*sin(theta).\n        Its magnitude |g| = sqrt(cos(theta)^2 + (nu*sin(theta))^2).\n        \"\"\"\n        cos_theta = np.cos(theta_vals)\n        sin_theta = np.sin(theta_vals)\n        g_mag_sq = cos_theta**2 + (nu**2) * (sin_theta**2)\n        max_g_mag = np.sqrt(np.max(g_mag_sq))\n        return max_g_mag\n\n    # Test A: General sweep to compare empirical and theoretical stability\n    def run_test_a():\n        nu_vals = np.linspace(-1.5, 1.5, int(3.0 / 0.01) + 1)\n        theta_vals = np.linspace(0, np.pi, 2049)\n        tolerance = 1e-12\n        \n        all_match = True\n        for nu in nu_vals:\n            max_g = get_max_g_mag(nu, theta_vals)\n            \n            # Empirical stability: max|g| <= 1 (with tolerance)\n            empirical_stable = (max_g - 1.0) <= tolerance\n            \n            # Theoretical stability: |nu| <= 1\n            theoretical_stable = np.abs(nu) <= 1.0\n            \n            if empirical_stable != theoretical_stable:\n                all_match = False\n                break\n        return all_match\n\n    # Test B: Check deviation at the stability boundary\n    def run_test_b():\n        nu_vals = [-1.0, 1.0]\n        theta_vals = np.linspace(0, np.pi, 10001)\n        \n        deviations = []\n        for nu in nu_vals:\n            max_g = get_max_g_mag(nu, theta_vals)\n            deviation = max_g - 1.0\n            deviations.append(deviation)\n            \n        return np.max(np.abs(deviations))\n\n    # Test C: Verify instability outside the CFL condition on a coarse grid\n    def run_test_c():\n        nu_vals = np.linspace(-2.0, 2.0, int(4.0 / 0.5) + 1)\n        theta_vals = np.linspace(0, np.pi, 33)\n        tolerance = 1e-9\n        \n        all_unstable_as_expected = True\n        for nu in nu_vals:\n            # Only check for nu values that should be unstable\n            if np.abs(nu) > 1.0:\n                max_g = get_max_g_mag(nu, theta_vals)\n                # Check if max|g| is strictly greater than 1 by the tolerance\n                is_unstable = (max_g - 1.0) > tolerance\n                if not is_unstable:\n                    all_unstable_as_expected = False\n                    break\n        return all_unstable_as_expected\n\n    rA = run_test_a()\n    rB = run_test_b()\n    rC = run_test_c()\n    \n    results = [rA, rB, rC]\n    \n    # Format and print the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3151507"}, {"introduction": "After confirming a scheme's stability, the next step is to evaluate its practical performance, particularly its accuracy and qualitative behavior. This exercise places the Lax-Friedrichs scheme in context by comparing its solution for the linear advection equation against two other classic methods: the first-order upwind scheme and the second-order Lax-Wendroff scheme. You will learn to quantify key performance metrics like numerical diffusion (smearing) and dispersion (oscillations) by observing how each scheme handles a sharp, discontinuous signal, providing a clear visual and quantitative sense of their strengths and weaknesses [@problem_id:3151529].", "problem": "Consider the one-dimensional linear advection (transport) equation $u_t + a u_x = 0$ posed on a periodic domain $x \\in [0,1]$ with constant advection speed $a$. The initial condition is a square pulse defined by $u(x,0) = 1$ for $x \\in [0.2,0.4)$ and $u(x,0) = 0$ elsewhere. The exact solution translates the pulse without distortion at speed $a$ and conserves the $L^1$ norm and the Total Variation (TV). In numerical computation, different explicit schemes introduce dissipation and dispersion that can change these quantities.\n\nStarting only from the partial differential equation $u_t + a u_x = 0$, the concept of numerical flux, and cell-average discretization on a uniform grid, derive and implement three explicit schemes: the Lax-Friedrichs scheme, the upwind (Godunov) scheme, and the Lax-Wendroff scheme. Use periodic boundary conditions. Define the uniform mesh with $N$ cells, grid spacing $\\Delta x = 1/N$, and time step $\\Delta t$ chosen by the Courant-Friedrichs-Lewy (CFL) condition with $\\nu = a \\Delta t / \\Delta x$, where the CFL number is set to $\\nu = 0.9$ unless reduced to make the final time exact. Evolve the solution until final time $T = 0.5$.\n\nFor a discrete function $u_i$ on a periodic grid, define the $L^1$ norm by $\\|u\\|_1 = \\sum_i |u_i| \\Delta x$ and the Total Variation (TV) by $\\mathrm{TV}(u) = \\sum_i |u_{i+1} - u_i|$ with periodic indexing. For each scheme and grid resolution, compute the decays\n$\\Delta \\|u\\|_1 = \\|u(\\cdot,0)\\|_1 - \\|u(\\cdot,T)\\|_1$\nand\n$\\Delta \\mathrm{TV} = \\mathrm{TV}(u(\\cdot,0)) - \\mathrm{TV}(u(\\cdot,T))$.\nA positive decay indicates dissipation. Negative values indicate growth due to numerical oscillations.\n\nImplement a single program that, for each specified test case, computes these decays for the Lax-Friedrichs, upwind, and Lax-Wendroff schemes, in that order. The program must use periodic boundary conditions, choose $\\Delta t$ to satisfy the stated CFL and end exactly at $T$, and report results rounded to six decimal places.\n\nUse the following test suite of parameter values to assess grid refinement, stability limits, and directionality:\n- Case $1$: $N = 40$, $a = 1.0$.\n- Case $2$: $N = 80$, $a = 1.0$.\n- Case $3$: $N = 160$, $a = 1.0$.\n- Case $4$: $N = 80$, $a = -1.0$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each case, output six numbers in the fixed order: $\\Delta \\|u\\|_1$ for Lax-Friedrichs, $\\Delta \\mathrm{TV}$ for Lax-Friedrichs, $\\Delta \\|u\\|_1$ for upwind, $\\Delta \\mathrm{TV}$ for upwind, $\\Delta \\|u\\|_1$ for Lax-Wendroff, $\\Delta \\mathrm{TV}$ for Lax-Wendroff. Concatenate these six numbers for Case $1$, then for Case $2$, Case $3$, and Case $4$. The final output thus contains twenty-four numbers formatted as described, for example:\n$[\\Delta\\|u\\|_1^{\\mathrm{LF},1},\\Delta\\mathrm{TV}^{\\mathrm{LF},1},\\Delta\\|u\\|_1^{\\mathrm{UP},1},\\Delta\\mathrm{TV}^{\\mathrm{UP},1},\\Delta\\|u\\|_1^{\\mathrm{LW},1},\\Delta\\mathrm{TV}^{\\mathrm{LW},1},\\ldots,\\Delta\\|u\\|_1^{\\mathrm{LW},4},\\Delta\\mathrm{TV}^{\\mathrm{LW},4}]$.", "solution": "The problem requires deriving three numerical schemes from the finite volume perspective for the linear advection equation $u_t + a u_x = 0$. In integral form, for a control volume (cell) $[x_{i-1/2}, x_{i+1/2}]$, the conservation law is:\n$$\n\\frac{d}{dt} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx + F(u(x_{i+1/2},t)) - F(u(x_{i-1/2},t)) = 0\n$$\nwhere $F(u) = au$ is the physical flux. Defining the cell average $u_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) \\,dx$ and approximating the fluxes at cell interfaces with a numerical flux function $\\widehat{F}(u_L, u_R)$, we get the semi-discrete form:\n$$\n\\frac{d u_i}{dt} + \\frac{1}{\\Delta x} \\left( \\widehat{F}_{i+1/2} - \\widehat{F}_{i-1/2} \\right) = 0\n$$\nwhere $\\widehat{F}_{i+1/2} = \\widehat{F}(u_i, u_{i+1})$. Using a first-order forward Euler time discretization gives the fully discrete finite volume scheme:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\widehat{F}_{i+1/2}^n - \\widehat{F}_{i-1/2}^n \\right)\n$$\nLet $\\nu = a \\Delta t / \\Delta x$ be the Courant number. The three schemes are defined by their specific choice of numerical flux $\\widehat{F}$.\n\n**1. Lax-Friedrichs Scheme**\nThe Lax-Friedrichs flux is an average of the physical fluxes plus a maximal dissipation term:\n$$\n\\widehat{F}_{i+1/2}^{\\text{LF}} = \\frac{1}{2}(F(u_i) + F(u_{i+1})) - \\frac{1}{2} \\frac{\\Delta x}{\\Delta t} (u_{i+1} - u_i) = \\frac{a}{2}(u_i + u_{i+1}) - \\frac{\\Delta x}{2\\Delta t} (u_{i+1} - u_i)\n$$\nSubstituting this into the update formula and simplifying leads to the well-known stencil form:\n$$\nu_i^{n+1} = \\frac{1}{2}(u_{i+1}^n + u_{i-1}^n) - \\frac{a \\Delta t}{2\\Delta x}(u_{i+1}^n - u_{i-1}^n) = \\frac{1}{2}(u_{i+1}^n + u_{i-1}^n) - \\frac{\\nu}{2}(u_{i+1}^n - u_{i-1}^n)\n$$\nThis is equivalent to averaging the neighboring values before applying a central difference for the advection term.\n\n**2. Upwind (Godunov) Scheme**\nThe Godunov flux for linear advection is the exact solution to the Riemann problem at the interface, which simply selects the value from the upwind direction:\n$$\n\\widehat{F}_{i+1/2}^{\\text{Upwind}} = \\begin{cases} F(u_i) = au_i  \\text{if } a > 0 \\\\ F(u_{i+1}) = au_{i+1}  \\text{if } a  0 \\end{cases}\n$$\nFor $a > 0$, the update becomes:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (au_i^n - au_{i-1}^n) = u_i^n - \\nu (u_i^n - u_{i-1}^n)\n$$\nFor $a  0$, the update becomes:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (au_{i+1}^n - au_i^n) = u_i^n - \\nu (u_{i+1}^n - u_i^n)\n$$\nThese are the standard first-order upwind stencils.\n\n**3. Lax-Wendroff Scheme**\nThe Lax-Wendroff flux can be derived using the two-step Richtmyer method. The flux is defined using a predicted state at the half-time step at the interface:\n$$\n\\widehat{F}_{i+1/2}^{\\text{LW}} = F(u_{i+1/2}^{n+1/2}) = a u_{i+1/2}^{n+1/2}\n$$\nwhere $u_{i+1/2}^{n+1/2}$ is an intermediate state given by:\n$$\nu_{i+1/2}^{n+1/2} = \\frac{1}{2}(u_i^n + u_{i+1}^n) - \\frac{\\Delta t}{2\\Delta x}(F(u_{i+1}^n) - F(u_i^n)) = \\frac{1}{2}(u_i^n + u_{i+1}^n) - \\frac{a\\Delta t}{2\\Delta x}(u_{i+1}^n - u_i^n)\n$$\nThus, the numerical flux is:\n$$\n\\widehat{F}_{i+1/2}^{\\text{LW}} = \\frac{a}{2}(u_i^n + u_{i+1}^n) - \\frac{a^2 \\Delta t}{2\\Delta x}(u_{i+1}^n - u_i^n)\n$$\nSubstituting this into the finite volume update formula yields the second-order accurate Lax-Wendroff stencil:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\nu}{2}(u_{i+1}^n - u_{i-1}^n) + \\frac{\\nu^2}{2}(u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nThe implementation in the provided code directly uses these final stencils for each scheme.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements Lax-Friedrichs, upwind, and Lax-Wendroff schemes\n    for the 1D linear advection equation, and computes norm/TV decays.\n    \"\"\"\n\n    test_cases = [\n        (40, 1.0),\n        (80, 1.0),\n        (160, 1.0),\n        (80, -1.0),\n    ]\n\n    all_results = []\n\n    for N, a in test_cases:\n        # ---- 1. Setup Grid, Time, and Initial Conditions ----\n        \n        # Constants and domain parameters\n        T_final = 0.5\n        X_domain = 1.0\n        pulse_start = 0.2\n        pulse_end = 0.4\n        cfl_target = 0.9\n\n        # Spatial grid\n        dx = X_domain / N\n        # Cell-centered grid\n        x = np.arange(N) * dx + 0.5 * dx\n\n        # Initial condition: square pulse sampled at cell centers\n        u0 = np.zeros(N)\n        u0[(x = pulse_start)  (x  pulse_end)] = 1.0\n\n        # Time stepping parameters\n        # Ensure a is non-zero to avoid division by zero\n        if abs(a)  1e-12:\n            raise ValueError(\"Advection speed 'a' cannot be zero.\")\n            \n        dt_ideal = cfl_target * dx / abs(a)\n        num_steps = int(np.ceil(T_final / dt_ideal))\n        dt = T_final / num_steps\n        nu = a * dt / dx  # Courant number\n\n        # ---- 2. Define Diagnostic Functions ----\n        \n        def l1_norm(u_vec, delta_x):\n            return np.sum(np.abs(u_vec)) * delta_x\n\n        def total_variation(u_vec):\n            # np.roll with shift -1 gets u_{i+1} for all i, with periodicity\n            u_next = np.roll(u_vec, -1)\n            return np.sum(np.abs(u_next - u_vec))\n\n        # Calculate initial diagnostics\n        l1_initial = l1_norm(u0, dx)\n        tv_initial = total_variation(u0)\n        \n        case_results = []\n\n        # ---- 3. Evolve Solution with each Scheme ----\n\n        # --- Lax-Friedrichs Scheme ---\n        u_lf = u0.copy()\n        for _ in range(num_steps):\n            u_prev = np.roll(u_lf, 1)  # u_{i-1}\n            u_next = np.roll(u_lf, -1) # u_{i+1}\n            # Stencil: u_i^{n+1} = 0.5*(u_{i+1}+u_{i-1}) - 0.5*nu*(u_{i+1}-u_{i-1})\n            u_lf = 0.5 * (u_next + u_prev) - 0.5 * nu * (u_next - u_prev)\n        \n        l1_final_lf = l1_norm(u_lf, dx)\n        tv_final_lf = total_variation(u_lf)\n        case_results.extend([l1_initial - l1_final_lf, tv_initial - tv_final_lf])\n\n        # --- Upwind (Godunov) Scheme ---\n        u_up = u0.copy()\n        if a  0:\n            # Stencil: u_i^{n+1} = u_i - nu*(u_i - u_{i-1})\n            for _ in range(num_steps):\n                u_prev = np.roll(u_up, 1)\n                u_up = u_up - nu * (u_up - u_prev)\n        else: # a  0\n            # Stencil: u_i^{n+1} = u_i - nu*(u_{i+1} - u_i)\n            for _ in range(num_steps):\n                u_next = np.roll(u_up, -1)\n                u_up = u_up - nu * (u_next - u_up)\n                \n        l1_final_up = l1_norm(u_up, dx)\n        tv_final_up = total_variation(u_up)\n        case_results.extend([l1_initial - l1_final_up, tv_initial - tv_final_up])\n\n        # --- Lax-Wendroff Scheme ---\n        u_lw = u0.copy()\n        for _ in range(num_steps):\n            u_prev = np.roll(u_lw, 1)\n            u_next = np.roll(u_lw, -1)\n            # Stencil: u_i^{n+1} = u_i - 0.5*nu*(u_{i+1}-u_{i-1}) + 0.5*nu^2*(u_{i+1}-2u_i+u_{i-1})\n            term1 = -0.5 * nu * (u_next - u_prev)\n            term2 = 0.5 * nu**2 * (u_next - 2 * u_lw + u_prev)\n            u_lw = u_lw + term1 + term2\n\n        l1_final_lw = l1_norm(u_lw, dx)\n        tv_final_lw = total_variation(u_lw)\n        case_results.extend([l1_initial - l1_final_lw, tv_initial - tv_final_lw])\n        \n        all_results.extend(case_results)\n\n    # ---- 4. Format and Print Final Output ----\n    formatted_results = [f'{x:.6f}' for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3151529"}, {"introduction": "The true test of a numerical method comes when moving from simple linear equations with constant coefficients to more complex, nonlinear systems where wave speeds vary in space and time. This advanced practice demonstrates a critical failure mode of a naive Lax-Friedrichs implementation when applied to the shallow water equations and, more importantly, shows how to remedy it. By constructing a scenario where a global wavespeed estimate is insufficient, you will gain a deep appreciation for why a local, adaptive dissipation parameter is essential for robustly capturing the physics of nonlinear phenomena [@problem_id:3151487].", "problem": "You are asked to construct and analyze a numerical experiment in the setting of one-dimensional nonlinear hyperbolic conservation laws that demonstrates a failure mode of the Lax–Friedrichs (LF) scheme when its single-speed dissipation parameter underestimates true local wave speeds, and then to implement a remedy. The fundamental base for the derivation must begin from the conservation law $U_t + F(U)_x = 0$, where $U$ is the vector of conserved variables and $F(U)$ is the flux, evolved by a finite volume method on a uniform grid. The test model must be scientifically realistic and self-consistent, explicitly state physical units where relevant, and be solved with programmatic logic that is applicable in any modern programming language.\n\nScenario:\n- Consider the one-dimensional shallow water equations on a periodic domain, a nonlinear system of conservation laws for water depth and momentum:\n  - Conserved variables: $U = \\begin{bmatrix} h \\\\ q \\end{bmatrix}$, where $h$ is water depth (in $\\mathrm{m}$) and $q = h u$ is discharge (in $\\mathrm{m}^2/\\mathrm{s}$), with velocity $u$ (in $\\mathrm{m/s}$).\n  - Physical flux: $F(U) = \\begin{bmatrix} q \\\\ \\dfrac{q^2}{h} + \\dfrac{1}{2} g h^2 \\end{bmatrix}$, with gravitational acceleration $g$ (in $\\mathrm{m/s^2}$).\n  - Characteristic wave speeds: $\\lambda_{\\pm} = u \\pm \\sqrt{g h}$, hence any stable LF dissipation parameter must satisfy $\\alpha \\ge \\max(|u| + \\sqrt{g h})$ in the region of interest.\n\nTask:\n- Implement a first-order explicit finite volume method using the Lax–Friedrichs interface flux on a uniform grid over the periodic interval $[0, L]$ with $L$ (in $\\mathrm{m}$), and evolve to a final time $T$ (in $\\mathrm{s}$).\n- Design initial conditions with a localized depth bump that increases the local wave speeds relative to a far-field reference. Specifically, use\n  - Base depth $h_0$ (in $\\mathrm{m}$).\n  - A Gaussian bump of amplitude $A$ (in $\\mathrm{m}$) centered at $x_0$ (in $\\mathrm{m}$) with width parameter $\\sigma$ (in $\\mathrm{m}$), superimposed on $h_0$.\n  - Initial discharge $q(x, 0) = 0$ (i.e., $u(x, 0) = 0$).\n- Compare two LF dissipation strategies:\n  1. A single-speed estimate: $\\alpha_{\\mathrm{single}} = \\beta \\left(|u_{\\infty}| + \\sqrt{g h_{\\infty}}\\right)$, where $h_{\\infty} = h_0$ and $u_{\\infty} = 0$ represent far-field reference values. The scaling factor $\\beta$ is chosen to be less than $1$ in some tests to intentionally underestimate local speeds; the time step is selected as $\\Delta t_{\\mathrm{single}} = \\mathrm{CFL} \\cdot \\Delta x / \\alpha_{\\mathrm{single}}$.\n  2. A local-speed remedy: for each interface, use $\\alpha_{i+\\frac{1}{2}} = \\max\\!\\left(|u_i| + \\sqrt{g h_i},\\,|u_{i+1}| + \\sqrt{g h_{i+1}}\\right)$ and select the time step as $\\Delta t_{\\mathrm{local}} = \\mathrm{CFL} \\cdot \\Delta x / \\max_i \\alpha_{i+\\frac{1}{2}}$, ensuring global compliance with the Courant–Friedrichs–Lewy (CFL) condition.\n- Use periodic boundary conditions and a positivity check: declare instability if any $h$ becomes nonpositive at any time or if any value becomes nonfinite (not a number or infinite).\n\nAlgorithmic specification:\n- Uniform grid with $N$ cells, grid spacing $\\Delta x = L/N$, and explicit update using the Lax–Friedrichs numerical flux at interfaces. You must implement both the naive single-speed scheme and the local-speed remedy within the same program and evaluate their stability on the defined test suite.\n\nNumerical and physical parameters:\n- Domain length $L$ (in $\\mathrm{m}$), gravitational acceleration $g$ (in $\\mathrm{m/s^2}$), base depth $h_0$ (in $\\mathrm{m}$), bump center $x_0$ (in $\\mathrm{m}$), bump width $\\sigma$ (in $\\mathrm{m}$), final time $T$ (in $\\mathrm{s}$), number of cells $N$ (unitless), and Courant–Friedrichs–Lewy (CFL) number (unitless).\n\nTest suite:\n- You must run the program for the following parameter sets, each given as a tuple $(A,\\beta)$:\n  - Case $1$ (happy path, no underestimation): $(A = 0.05,\\, \\beta = 1.0)$.\n  - Case $2$ (underestimation causing instability): $(A = 0.8,\\, \\beta = 0.7)$.\n  - Case $3$ (strong underestimation causing instability): $(A = 1.5,\\, \\beta = 0.6)$.\n- Fixed parameters for all cases:\n  - $L = 1.0\\,\\mathrm{m}$, $g = 9.81\\,\\mathrm{m/s^2}$, $h_0 = 1.0\\,\\mathrm{m}$, $x_0 = 0.5\\,\\mathrm{m}$, $\\sigma = 0.05\\,\\mathrm{m}$, $T = 0.15\\,\\mathrm{s}$, $N = 200$, $\\mathrm{CFL} = 0.9$ for the local-speed remedy, and $\\mathrm{CFL} = 0.95$ for the single-speed estimate.\n\nQuantifiable outputs:\n- For each case, compute a pair of booleans $[\\mathrm{stable}_{\\mathrm{single}}, \\mathrm{stable}_{\\mathrm{local}}]$ indicating whether the single-speed LF scheme and the local-speed LF remedy scheme remain numerically stable up to time $T$ under the stated positivity and finiteness criteria.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the list has one element per test case, and each element is itself a list of two booleans $[\\mathrm{stable}_{\\mathrm{single}}, \\mathrm{stable}_{\\mathrm{local}}]$. For example, the format must look like $[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{True}]]$ (this is only an illustrative format, not the expected numerical answers).", "solution": "We begin from the fundamental base of one-dimensional nonlinear hyperbolic conservation laws,\n$$\nU_t + F(U)_x = 0,\n$$\nwhere $U$ is the vector of conserved variables and $F(U)$ is the physical flux. A first-order explicit finite volume method on a uniform grid with spacing $\\Delta x$ evolves cell averages $U_i^n$ in time using interface fluxes $\\widehat{F}_{i+\\frac{1}{2}}$:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\widehat{F}_{i+\\frac{1}{2}}^n - \\widehat{F}_{i-\\frac{1}{2}}^n\\right).\n$$\nThe Lax–Friedrichs numerical flux introduces a central average of fluxes augmented by a linear dissipation proportional to a speed estimate $\\alpha$:\n$$\n\\widehat{F}_{i+\\frac{1}{2}}^n = \\frac{1}{2}\\left(F\\!\\left(U_i^n\\right) + F\\!\\left(U_{i+1}^n\\right)\\right) - \\frac{1}{2}\\,\\alpha_{i+\\frac{1}{2}}^n \\left(U_{i+1}^n - U_i^n\\right).\n$$\nThis form can be justified by Taylor expansion and consistency arguments: the central part provides second-order accuracy for smooth solutions, while the dissipative part stabilizes high-frequency modes. For monotonicity and stability, a standard requirement is that the dissipation parameter $\\alpha_{i+\\frac{1}{2}}^n$ bound the largest magnitude of the characteristic speeds of the local linearization of $F$ at the interface. That is, if $A(U) = \\partial F / \\partial U$ has eigenvalues $\\lambda_k(U)$, one requires\n$$\n\\alpha_{i+\\frac{1}{2}}^n \\ge \\max_{k}\\left|\\lambda_k\\left(U_i^n\\right)\\right|, \\quad \\text{and} \\quad \\alpha_{i+\\frac{1}{2}}^n \\ge \\max_{k}\\left|\\lambda_k\\left(U_{i+1}^n\\right)\\right|,\n$$\nso that numerical viscosity is sufficient to counteract the central differencing. Furthermore, the time step must satisfy the Courant–Friedrichs–Lewy (CFL) stability condition,\n$$\n\\Delta t \\le \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max\\limits_{i}\\alpha_{i+\\frac{1}{2}}^n},\n$$\nwhich ensures that information does not propagate beyond one cell per time step according to the numerical waves.\n\nIn the one-dimensional shallow water equations, the conserved variables and flux are\n$$\nU = \\begin{bmatrix} h \\\\ q \\end{bmatrix}, \\qquad F(U) = \\begin{bmatrix} q \\\\ \\dfrac{q^2}{h} + \\dfrac{1}{2} g h^2 \\end{bmatrix}.\n$$\nThe Jacobian $A(U) = \\partial F / \\partial U$ has eigenvalues\n$$\n\\lambda_{\\pm} = u \\pm \\sqrt{g h}, \\quad \\text{where} \\quad u = \\frac{q}{h}.\n$$\nThus, the largest magnitude local wave speed is\n$$\n\\lambda_{\\max}(U) = |u| + \\sqrt{g h}.\n$$\n\nDesigning the instability:\n- If one selects a single global estimate $\\alpha_{\\mathrm{single}}$ that underestimates $\\lambda_{\\max}(U)$ in some region, the LF flux provides insufficient dissipation relative to true local wave propagation. Combined with a time step based on $\\alpha_{\\mathrm{single}}$, the update can violate the positivity of $h$ or produce nonphysical oscillations leading to nonfinite values.\n- A scientifically plausible way to produce this underestimation is to initialize a localized bump in depth $h(x,0)$ on top of a far-field constant $h_0$, which increases $\\sqrt{g h}$ locally. If $\\alpha_{\\mathrm{single}}$ is computed from far-field values $h_0$ and $u_{\\infty} = 0$ (and then scaled by $\\beta  1$), the true local speeds near the bump are larger than $\\alpha_{\\mathrm{single}}$, breaking the underlying assumption for LF stability.\n\nRemedy:\n- Use a local Lax–Friedrichs dissipation parameter at each interface,\n$$\n\\alpha_{i+\\frac{1}{2}}^n = \\max\\!\\left(|u_i^n| + \\sqrt{g h_i^n},\\,|u_{i+1}^n| + \\sqrt{g h_{i+1}^n}\\right),\n$$\nand select a time step via the global maximum of these local values,\n$$\n\\Delta t^n = \\mathrm{CFL} \\cdot \\frac{\\Delta x}{\\max\\limits_{i}\\alpha_{i+\\frac{1}{2}}^n}.\n$$\nThis design respects the requirement that the numerical dissipation bound the local spectral radius of the flux Jacobian and ensures compliance with the Courant–Friedrichs–Lewy (CFL) condition.\n\nAlgorithmic steps integrated with principles:\n- Initialize the grid over $[0, L]$ with $N$ cells and periodic boundary conditions.\n- Set physical parameters $g$, $h_0$ and the Gaussian bump for $h(x,0) = h_0 + A \\exp\\!\\left(-\\frac{(x-x_0)^2}{2\\sigma^2}\\right)$, with $q(x,0) = 0$ so that $u(x,0) = 0$.\n- For the single-speed LF scheme:\n  - Set $\\alpha_{\\mathrm{single}} = \\beta\\left(|u_{\\infty}| + \\sqrt{g h_{\\infty}}\\right)$ with $u_{\\infty} = 0$ and $h_{\\infty} = h_0$.\n  - Use a fixed time step $\\Delta t_{\\mathrm{single}} = \\mathrm{CFL} \\cdot \\Delta x / \\alpha_{\\mathrm{single}}$ and update via the LF flux with constant $\\alpha_{\\mathrm{single}}$ at all interfaces.\n- For the local-speed remedy:\n  - At each step, compute $\\alpha_{i+\\frac{1}{2}}^n = \\max\\!\\left(|u_i^n| + \\sqrt{g h_i^n},\\,|u_{i+1}^n| + \\sqrt{g h_{i+1}^n}\\right)$ at all interfaces.\n  - Select $\\Delta t^n = \\mathrm{CFL} \\cdot \\Delta x / \\max_i \\alpha_{i+\\frac{1}{2}}^n$ and update via the LF flux using the per-interface $\\alpha_{i+\\frac{1}{2}}^n$.\n- At each step for both schemes, check positivity $h_i^n  0$ and finiteness; if violated, declare instability and stop.\n\nTest suite and expected behavior:\n- Case $1$: $(A = 0.05, \\beta = 1.0)$ produces local speeds close to far-field values, so both schemes are expected to be stable.\n- Case $2$: $(A = 0.8, \\beta = 0.7)$ produces local speeds substantially larger than $\\alpha_{\\mathrm{single}}$, likely destabilizing the single-speed scheme, while the local-speed remedy remains stable.\n- Case $3$: $(A = 1.5, \\beta = 0.6)$ produces even larger local speeds, strongly destabilizing the single-speed scheme, while the local-speed remedy remains stable.\n\nOutput specification:\n- For each case, return a pair of booleans $[\\mathrm{stable}_{\\mathrm{single}}, \\mathrm{stable}_{\\mathrm{local}}]$.\n- Aggregate the three case results into a single line as a comma-separated list enclosed in square brackets, for example $[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{True}]]$.\n\nThis experiment directly connects the principle that the Lax–Friedrichs dissipation must bound the local spectral radius of the flux Jacobian to practical algorithmic design: underestimation of $\\alpha$ in a nonlinear system leads to instability, while computing a local $\\alpha$ at interfaces and selecting $\\Delta t$ by the global maximum of local speeds remedies the issue by enforcing sufficient numerical viscosity and the Courant–Friedrichs–Lewy (CFL) condition.", "answer": "```python\nimport numpy as np\n\n# Shallow water equations: U = [h, q], F(U) = [q, q^2/h + 0.5*g*h^2]\n# Periodic domain, first-order finite volume with Lax-Friedrichs flux.\n# We compare a naive single-speed alpha with a local-speed alpha remedy.\n\ndef flux(h, q, g):\n    # Returns F1, F2 component-wise flux for arrays h, q.\n    # Handle division safely; the simulation will stop if h = 0 occurs.\n    u = np.where(h  1e-14, q / h, 0.0)\n    F1 = q\n    F2 = u * q + 0.5 * g * h * h  # since q^2/h = u*q\n    return F1, F2\n\ndef local_interface_alpha(h, q, g):\n    # Compute per-interface alpha = max(|u| + sqrt(g*h)) over left/right states.\n    # Periodic: interface i+1/2 uses cells i and i+1 (with wrap).\n    if np.any(h = 0) or (not np.isfinite(h).all()) or (not np.isfinite(q).all()):\n        # If already nonphysical, return None to signal instability\n        return None\n    u = np.where(h  1e-14, q / h, 0.0)\n    c = np.sqrt(g * h)\n    s = np.abs(u) + c  # local speed per cell\n    s_right = np.roll(s, -1)\n    alpha_int = np.maximum(s, s_right)\n    return alpha_int\n\ndef lax_friedrichs_step(h, q, g, dt, dx, alpha_mode, alpha_single=None):\n    \"\"\"\n    Advance one time step using LF flux.\n    alpha_mode: 'single' or 'local'\n    alpha_single: scalar, required if alpha_mode == 'single'\n    Returns updated (h, q) and a flag indicating instability (True if unstable).\n    \"\"\"\n    # Instability pre-check\n    if np.any(h = 0) or (not np.isfinite(h).all()) or (not np.isfinite(q).all()):\n        return h, q, True\n\n    F1, F2 = flux(h, q, g)\n    h_right = np.roll(h, -1)\n    q_right = np.roll(q, -1)\n    F1_right = np.roll(F1, -1)\n    F2_right = np.roll(F2, -1)\n\n    if alpha_mode == 'single':\n        alpha_interfaces = alpha_single  # scalar\n        # Build interface fluxes:\n        Fhat1_right = 0.5 * (F1 + F1_right) - 0.5 * alpha_interfaces * (h_right - h)\n        Fhat2_right = 0.5 * (F2 + F2_right) - 0.5 * alpha_interfaces * (q_right - q)\n    elif alpha_mode == 'local':\n        alpha_interfaces = local_interface_alpha(h, q, g)\n        if alpha_interfaces is None:\n            return h, q, True\n        Fhat1_right = 0.5 * (F1 + F1_right) - 0.5 * alpha_interfaces * (h_right - h)\n        Fhat2_right = 0.5 * (F2 + F2_right) - 0.5 * alpha_interfaces * (q_right - q)\n    else:\n        raise ValueError(\"alpha_mode must be 'single' or 'local'\")\n\n    # Flux at left interfaces is Fhat_right rolled by +1\n    Fhat1_left = np.roll(Fhat1_right, 1)\n    Fhat2_left = np.roll(Fhat2_right, 1)\n\n    # Update:\n    h_new = h - (dt / dx) * (Fhat1_right - Fhat1_left)\n    q_new = q - (dt / dx) * (Fhat2_right - Fhat2_left)\n\n    # Instability post-check: positivity and finiteness\n    unstable = (np.any(h_new = 0) or (not np.isfinite(h_new).all()) or (not np.isfinite(q_new).all()))\n    return h_new, q_new, unstable\n\ndef simulate_case(A, beta,\n                  L=1.0, g=9.81, h0=1.0, x0=0.5, sigma=0.05,\n                  T=0.15, N=200, CFL_local=0.9, CFL_single=0.95):\n    \"\"\"\n    Simulate both naive single-speed LF scheme and local-speed LF remedy for given A, beta.\n    Returns [stable_single, stable_local] booleans.\n    \"\"\"\n    # Grid\n    x = np.linspace(0.0, L, N, endpoint=False)\n    dx = L / N\n\n    # Initial conditions: Gaussian bump on h0; q=0\n    h_init = h0 + A * np.exp(-((x - x0) ** 2) / (2.0 * sigma ** 2))\n    q_init = np.zeros_like(h_init)\n    # Sanity check\n    if np.any(h_init = 0):\n        return [False, False]\n\n    # Single-speed parameters:\n    u_inf = 0.0\n    h_inf = h0\n    alpha_single = beta * (abs(u_inf) + np.sqrt(g * h_inf))\n    # Fixed dt for single-speed\n    dt_single = CFL_single * dx / alpha_single\n\n    # Evolve single-speed scheme:\n    h_s, q_s = h_init.copy(), q_init.copy()\n    t = 0.0\n    stable_single = True\n    while t  T:\n        dt = min(dt_single, T - t)\n        h_s, q_s, unstable = lax_friedrichs_step(h_s, q_s, g, dt, dx, alpha_mode='single', alpha_single=alpha_single)\n        if unstable:\n            stable_single = False\n            break\n        t += dt\n\n    # Evolve local-speed remedy:\n    h_l, q_l = h_init.copy(), q_init.copy()\n    t = 0.0\n    stable_local = True\n    while t  T:\n        # Compute local alphas and dt\n        alpha_int = local_interface_alpha(h_l, q_l, g)\n        if alpha_int is None:\n            stable_local = False\n            break\n        alpha_max = np.max(alpha_int)\n        dt = CFL_local * dx / alpha_max\n        dt = min(dt, T - t)\n        h_l, q_l, unstable = lax_friedrichs_step(h_l, q_l, g, dt, dx, alpha_mode='local')\n        if unstable:\n            stable_local = False\n            break\n        t += dt\n\n    return [stable_single, stable_local]\n\ndef solve():\n    # Test suite as specified in the problem statement: tuples (A, beta)\n    test_cases = [\n        (0.05, 1.0),  # Case 1: happy path\n        (0.8, 0.7),   # Case 2: underestimation\n        (1.5, 0.6),   # Case 3: strong underestimation\n    ]\n\n    results = []\n    for A, beta in test_cases:\n        res = simulate_case(A, beta)\n        results.append(res)\n\n    # Print final results in the exact required format: nested list of booleans.\n    # Example: [[True,False],[True,True],[False,True]]\n    def bool_to_str(b):\n        return \"True\" if b else \"False\"\n\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(bool_to_str(x) for x in pair) + \"]\" for pair in results) + \"]\"\n    print(formatted)\n\nsolve()\n```", "id": "3151487"}]}