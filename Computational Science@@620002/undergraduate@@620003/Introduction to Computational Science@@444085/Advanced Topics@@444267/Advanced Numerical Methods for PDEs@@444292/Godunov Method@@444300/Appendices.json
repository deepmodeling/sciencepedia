{"hands_on_practices": [{"introduction": "To begin, let's solidify our understanding of the core mechanism of the Godunov method with a foundational exercise. This problem requires you to perform a single time-step update for a specific cell using the finite volume formulation. By manually calculating the numerical fluxes from the solutions to local Riemann problems for the Burgers' equation, you will see directly how information about waves (in this case, shocks) at cell interfaces determines the evolution of the solution. This practice [@problem_id:1073353] is essential for grasping the fundamental \"building block\" of the entire scheme.", "problem": "Consider the one-dimensional inviscid Burgers' equation, which serves as a prototype for equations with shocks:\n$$ \\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{1}{2} u^2 \\right) = 0 $$\nThis equation is a conservation law of the form $\\frac{\\partial u}{\\partial t} + \\frac{\\partial f(u)}{\\partial x} = 0$, with flux $f(u) = \\frac{1}{2} u^2$.\n\nWe wish to solve this equation numerically using the Godunov method, which is a finite volume scheme. The spatial domain is divided into cells of uniform width $\\Delta x$, centered at $x_i = i \\Delta x$. The value $U_i^n$ represents the average value of the solution $u(x, t)$ over cell $i$ at time $t_n = n \\Delta t$.\n\nThe update formula for the cell average in one time step is given by:\n$$ U_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right) $$\nwhere $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$.\n\nIn the Godunov method, the flux $F_{i+1/2}$ is determined by solving the Riemann problem at the interface $x_{i+1/2}$ with initial data $u(x,t_n) = U_i^n$ for $x  x_{i+1/2}$ and $u(x,t_n) = U_{i+1}^n$ for $x > x_{i+1/2}$. Let us denote the left and right states as $u_L=U_i^n$ and $u_R=U_{i+1}^n$. The Godunov flux is $F_{i+1/2} = f(u_{RP}(0))$, where $u_{RP}(0)$ is the value of the Riemann problem solution along the line $x-x_{i+1/2}=0$. The rules for finding $u_{RP}(0)$ for the Burgers' equation are as follows:\n1.  If $u_L > u_R$, the solution is a shock wave. The shock speed is given by the Rankine-Hugoniot condition $s = \\frac{f(u_R)-f(u_L)}{u_R-u_L} = \\frac{1}{2}(u_L+u_R)$. If the shock moves to the right ($s > 0$), the state at the interface is $u_L$. If it moves to the left ($s  0$), the state is $u_R$. If $s=0$, the flux is $f(u_L)=f(u_R)$.\n2.  If $u_L  u_R$, the solution is a rarefaction wave. The value at the interface is $u_{RP}(0) = 0$ if $u_L \\le 0 \\le u_R$. If $u_L$ and $u_R$ have the same sign, then $u_{RP}(0) = u_L$ if $u_L > 0$, and $u_{RP}(0) = u_R$ if $u_R  0$.\n\nConsider the following piecewise constant initial state for the cell averages at time $t=0$:\n$$ U_i^0 = \\begin{cases} 3V  \\text{for } i \\le -1 \\\\ V  \\text{for } i = 0 \\\\ -2V  \\text{for } i \\ge 1 \\end{cases} $$\nwhere $V$ is a positive constant. Let $\\lambda = \\frac{\\Delta t}{\\Delta x}$ be the Courant number, which is assumed to be sufficiently small to ensure numerical stability.\n\nDerive an expression for the updated velocity average $U_0^1$ in the central cell ($i=0$) after one time step. Express your answer in terms of $V$ and $\\lambda$.", "solution": "We apply the Godunov update\n$$\nU_0^1 \\;=\\; U_0^0 \\;-\\;\\lambda\\bigl(F_{1/2}-F_{-1/2}\\bigr),\n\\quad \\lambda=\\frac{\\Delta t}{\\Delta x},\n\\quad U_0^0=V.\n$$\nCompute interfaces:\n\n1. Interface $x_{-1/2}$ between $u_L=U_{-1}=3V$ and $u_R=U_0=V$.  Since $u_L>u_R$, we have a shock with speed\n$$\ns=\\frac{f(u_R)-f(u_L)}{u_R-u_L}\n=\\frac{\\tfrac12V^2-\\tfrac12(3V)^2}{V-3V}\n=\\frac{-4V^2}{-2V}=2V>0.\n$$\nThus the state at the interface is $u_L=3V$ and\n$$\nF_{-1/2}=f(3V)=\\tfrac12(3V)^2=\\tfrac92\\,V^2.\n$$\n\n2. Interface $x_{1/2}$ between $u_L=U_0=V$ and $u_R=U_1=-2V$.  Again $u_L>u_R$, so a shock with speed\n$$\ns=\\frac{f(u_R)-f(u_L)}{u_R-u_L}\n=\\frac{\\tfrac12( -2V)^2-\\tfrac12V^2}{-2V-V}\n=\\frac{\\tfrac32V^2}{-3V}=-\\tfrac12V0.\n$$\nHence the state is $u_R=-2V$ and\n$$\nF_{1/2}=f(-2V)=\\tfrac12( -2V)^2=2\\,V^2.\n$$\n\nSubstitute into the update:\n$$\nU_0^1\n=V-\\lambda\\bigl(2V^2-\\tfrac92V^2\\bigr)\n=V-\\lambda\\bigl(-\\tfrac52V^2\\bigr)\n=V+\\tfrac52\\,\\lambda\\,V^2.\n$$", "answer": "$$\\boxed{V+\\tfrac{5}{2}\\,\\lambda\\,V^2}$$", "id": "1073353"}, {"introduction": "Having mastered the single-step update, we now move to a full simulation to observe the method's behavior over time. First-order methods like Godunov's are known for their stability but often suffer from numerical diffusion, which can smear out sharp features in the solution. This coding exercise [@problem_id:3138441] challenges you to implement and run the Godunov method for linear advection and compare its results against another classic scheme, the Lax-Friedrichs method. By quantifying the $L^1$-error, you will gain a practical understanding of numerical diffusion and the trade-offs between different numerical schemes.", "problem": "Consider the linear scalar conservation law with periodic boundary conditions on the unit interval,\n$$\nu_t + a\\,u_x = 0,\\quad x\\in[0,1),\\ t\\ge 0,\n$$\nwith constant advection speed $$a=1$$ and initial data given by a square wave\n$$\nu(x,0)=u_0(x)=\\begin{cases}\n1,  x\\in[0.2,0.4),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\ninterpreted periodically on $$[0,1)$$. The exact solution is the advected initial data\n$$\nu(x,t)=u_0\\!\\big((x-a\\,t)\\bmod 1\\big).\n$$\nYou will implement two finite volume methods on a uniform grid with $$N$$ cells of size $$\\Delta x=1/N$$, with cell centers at $$x_i=(i+1/2)\\Delta x$$ for $$i=0,\\dots,N-1$$, and advance the numerical solution to the final time $$T=0.2$$. The methods are:\n\n- Godunov's method for scalar linear advection, which reduces to the upwind scheme when $$a>0$$. In finite volume form with numerical fluxes, it uses the exact Riemann solver at each interface; for $$a>0$$ this yields the upwind update that depends on the left cell state.\n- The Lax–Friedrichs method, which can be written in conservative form as a combination of central differencing and artificial dissipation.\n\nUse a time step determined by the Courant–Friedrichs–Lewy (CFL) number,\n$$\n\\Delta t = \\text{CFL}\\,\\frac{\\Delta x}{|a|},\\quad \\text{with}\\ \\text{CFL}=0.9,\n$$\nand ensure that the last time step exactly reaches $$T$$ by reducing $$\\Delta t$$ as needed on the final step. Use periodic boundary conditions.\n\nQuantify the numerical diffusion by computing the discrete $$L^1$$-error at time $$T$$,\n$$\nE_{L^1} = \\sum_{i=0}^{N-1} \\left|U_i^N - u(x_i,T)\\right|\\,\\Delta x,\n$$\nwhere $$U_i^N$$ denotes the numerical cell average at final time and $$u(x_i,T)$$ is the exact solution evaluated at the cell center.\n\nImplement both methods and evaluate $$E_{L^1}$$ for the following test suite of grid resolutions:\n- $$N=100$$, $$N=200$$, and $$N=400$$ for Lax–Friedrichs.\n- $$N=100$$, $$N=200$$, and $$N=400$$ for Godunov (upwind with $$a>0$$).\n\nYour program must:\n- Initialize $$U_i^0$$ by sampling $$u_0$$ at cell centers $$x_i$$.\n- Evolve in time to $$T=0.2$$ with the specified methods and time stepping.\n- Compute and report the discrete $$L^1$$-error $$E_{L^1}$$ for each test case.\n\nFinal output format:\n- Produce a single line of output containing the errors as a comma-separated list enclosed in square brackets, ordered as\n$$\n[\\ E^{\\text{LF}}_{100},\\ E^{\\text{LF}}_{200},\\ E^{\\text{LF}}_{400},\\ E^{\\text{God}}_{100},\\ E^{\\text{God}}_{200},\\ E^{\\text{God}}_{400}\\ ],\n$$\nwhere $$E^{\\text{LF}}_N$$ is the $$L^1$$-error for Lax–Friedrichs with $$N$$ cells, and $$E^{\\text{God}}_N$$ is the $$L^1$$-error for Godunov with $$N$$ cells. Each number in the list must be printed as a decimal rounded to exactly $$6$$ places. No additional text should be printed.\n\nNotes:\n- Angles are not involved; no angle units apply.\n- The quantities are dimensionless; no physical units are required.\n- The implemented methods must follow the finite volume update with periodic boundary conditions and the specified time stepping. The program must be self-contained and require no user input or external files.", "solution": "The problem requires the numerical solution of the linear scalar advection equation,\n$$\nu_t + a\\,u_x = 0\n$$\non the domain $x \\in [0, 1)$ with periodic boundary conditions. The advection speed is a constant, $a=1$. The initial condition is a square wave defined as\n$$\nu(x,0) = u_0(x) = \\begin{cases} 1,  x \\in [0.2, 0.4) \\\\ 0,  \\text{otherwise}. \\end{cases}\n$$\nThe exact solution to this problem is the initial profile advected to the right with speed $a$, given by\n$$\nu(x,t) = u_0\\big((x - a\\,t) \\pmod 1\\big).\n$$\nWe will use a finite volume method on a uniform grid of $N$ cells, where cell $i$ is centered at $x_i = (i+1/2)\\Delta x$ with cell width $\\Delta x = 1/N$, for $i=0, \\dots, N-1$. Let $U_i(t)$ be the cell average of the solution in cell $i$ at time $t$. The semi-discrete finite volume formulation of the conservation law is\n$$\n\\frac{dU_i}{dt} + \\frac{1}{\\Delta x} \\left( \\hat{F}_{i+1/2} - \\hat{F}_{i-1/2} \\right) = 0,\n$$\nwhere $\\hat{F}_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$. A forward Euler time discretization gives the fully discrete update formula:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{F}_{i+1/2}^n - \\hat{F}_{i-1/2}^n \\right),\n$$\nwhere $U_i^n$ is the approximation of the cell average at time $t^n = n\\Delta t$, and $\\hat{F}_{i+1/2}^n$ is the flux computed from the solution at time $t^n$. The physical flux for this equation is $F(u) = a\\,u$.\n\nThe problem specifies two methods, which differ in their definition of the numerical flux.\n\n**Godunov's Method**\nGodunov's method defines the numerical flux by solving the exact Riemann problem at each cell interface. The Riemann problem at interface $x_{i+1/2}$ has the initial condition\n$$\nu(x,0) = \\begin{cases} U_i^n,  x  x_{i+1/2} \\\\ U_{i+1}^n,  x  x_{i+1/2}. \\end{cases}\n$$\nFor the linear advection equation $u_t + a u_x = 0$, the characteristics are straight lines with slope $1/a$. The solution to the Riemann problem is constant along these characteristics. The value at the interface $x=x_{i+1/2}$ is determined by the characteristic that passes through it. Since the problem specifies $a=1>0$, the information travels from left to right. Therefore, the solution at the interface is the value from the left state, $U_i^n$.\nThe numerical flux is then the physical flux evaluated at this interface value:\n$$\n\\hat{F}_{i+1/2}^n = F(U_i^n) = a\\,U_i^n.\n$$\nSubstituting this into the finite volume update formula gives:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a\\,U_i^n - a\\,U_{i-1}^n \\right).\n$$\nThis is the first-order upwind scheme, which is appropriate for $a>0$.\n\n**Lax-Friedrichs Method**\nThe Lax-Friedrichs method is another first-order scheme. Its numerical flux can be derived from a staggered grid formulation or defined directly. A common form for its numerical flux is\n$$\n\\hat{F}_{i+1/2}^n = \\frac{1}{2}\\left( F(U_i^n) + F(U_{i+1}^n) \\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left( U_{i+1}^n - U_i^n \\right).\n$$\nThe first term is a simple average of the fluxes from the left and right states, which corresponds to a central difference scheme. The second term is a numerical diffusion term, proportional to $\\Delta x / \\Delta t$, which is necessary for stability. Substituting $F(u)=a\\,u$ gives\n$$\n\\hat{F}_{i+1/2}^n = \\frac{a}{2}\\left( U_i^n + U_{i+1}^n \\right) - \\frac{1}{2}\\frac{\\Delta x}{\\Delta t}\\left( U_{i+1}^n - U_i^n \\right).\n$$\nSubstituting this flux into the conservation law update yields a direct update formula. This form simplifies to:\n$$\nU_i^{n+1} = \\frac{1}{2}\\left( U_{i+1}^n + U_{i-1}^n \\right) - \\frac{a\\,\\Delta t}{2\\,\\Delta x}\\left( U_{i+1}^n - U_{i-1}^n \\right).\n$$\nThis form is computationally convenient. Both Godunov's and Lax-Friedrichs' methods are first-order accurate in space and time. They are known to be dissipative, which tends to smear out sharp features like the discontinuities in the square wave initial condition. The Lax-Friedrichs method is generally more diffusive than the upwind (Godunov) method.\n\n**Implementation Details**\nThe simulation proceeds as follows for each value of $N \\in \\{100, 200, 400\\}$ and each method:\n\n1.  **Grid and Initialization**: A uniform grid with $N$ cells is defined. The spatial step is $\\Delta x = 1/N$. An array $U$ of size $N$ stores the cell averages. The initial state $U^0$ is populated by evaluating the initial condition $u_0(x)$ at the cell centers $x_i = (i+0.5)\\Delta x$.\n    $$\n    U_i^0 = u_0(x_i).\n    $$\n\n2.  **Time Stepping**: The time step $\\Delta t$ is determined by the Courant-Friedrichs-Lewy (CFL) condition. With a given CFL number of $0.9$:\n    $$\n    \\Delta t = \\text{CFL} \\frac{\\Delta x}{|a|} = 0.9 \\Delta x.\n    $$\n    The solution is advanced in time from $t=0$ to the final time $T=0.2$. A loop is used which continues as long as the current time $t$ is less than $T$. On the final step, if $t + \\Delta t  T$, the time step is adjusted to $\\Delta t' = T - t$ to ensure the simulation terminates exactly at $T$.\n\n3.  **Boundary Conditions**: The problem specifies periodic boundary conditions on the domain $[0,1)$. For a cell $i=0$, the left neighbor is cell $N-1$. For a cell $i=N-1$, the right neighbor is cell $0$. In the implementation, this is handled using array manipulations, such as `numpy.roll`, to access the states $U_{i-1}$ and $U_{i+1}$ for all $i$ simultaneously.\n\n4.  **Error Calculation**: After the simulation reaches $T=0.2$, the numerical solution is an array $U^N_{final}$. The discrete $L^1$-error is computed by comparing this numerical solution to the exact solution evaluated at the cell centers $x_i$. The exact solution at time $T$ is $u(x_i, T) = u_0((x_i - aT)\\pmod 1)$. The error is\n    $$\n    E_{L^1} = \\sum_{i=0}^{N-1} \\left| U_{i,final}^N - u(x_i, T) \\right| \\Delta x.\n    $$\n    This value quantifies the total absolute difference between the numerical and exact solutions, integrated over the domain. It is a measure of the numerical scheme's accuracy and, in this case, primarily its numerical diffusion.\n\nThe procedure is repeated for each configuration (Lax-Friedrichs for $N=100, 200, 400$ and Godunov for $N=100, 200, 400$), and the six resulting $E_{L^1}$ error values are reported.", "answer": "```python\nimport numpy as np\n\ndef u0(x):\n    \"\"\"\n    Computes the initial square wave profile.\n    u(x,0) = 1 for x in [0.2, 0.4), 0 otherwise.\n    \"\"\"\n    return np.where((x = 0.2)  (x  0.4), 1.0, 0.0)\n\ndef u_exact(x, t, a):\n    \"\"\"\n    Computes the exact solution u(x,t) for the linear advection equation.\n    The solution is the initial profile advected by a*t.\n    \"\"\"\n    # Use a robust modulo operation for floating point numbers on [0, 1)\n    x_shifted = (x - a * t) - np.floor(x - a * t)\n    return u0(x_shifted)\n\ndef solve_godunov(N, T, CFL, a):\n    \"\"\"\n    Solves the linear advection equation using Godunov's method (upwind for a0).\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    U = u0(x)\n\n    dt = CFL * dx / np.abs(a)\n    t = 0.0\n\n    while t  T:\n        if t + dt  T:\n            dt_step = T - t\n        else:\n            dt_step = dt\n        \n        # Periodic boundary conditions: U_{i-1} is fetched using np.roll\n        U_prev = np.roll(U, 1)\n        \n        # Godunov's method update (first-order upwind for a  0)\n        # U_i^{n+1} = U_i^n - (a*dt/dx) * (U_i^n - U_{i-1}^n)\n        U = U - (a * dt_step / dx) * (U - U_prev)\n        \n        t += dt_step\n    \n    U_ex = u_exact(x, T, a)\n    error = np.sum(np.abs(U - U_ex)) * dx\n    return error\n\ndef solve_lax_friedrichs(N, T, CFL, a):\n    \"\"\"\n    Solves the linear advection equation using the Lax-Friedrichs method.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    U = u0(x)\n\n    dt = CFL * dx / np.abs(a)\n    t = 0.0\n\n    while t  T:\n        if t + dt  T:\n            dt_step = T - t\n        else:\n            dt_step = dt\n        \n        # Periodic boundary conditions for U_{i-1} and U_{i+1}\n        U_prev = np.roll(U, 1)\n        U_next = np.roll(U, -1)\n        \n        # Lax-Friedrichs update\n        # U_i^{n+1} = 0.5*(U_{i+1}^n + U_{i-1}^n) - (a*dt/(2*dx))*(U_{i+1}^n - U_{i-1}^n)\n        U = 0.5 * (U_next + U_prev) - (a * dt_step / (2.0 * dx)) * (U_next - U_prev)\n        \n        t += dt_step\n\n    U_ex = u_exact(x, T, a)\n    error = np.sum(np.abs(U - U_ex)) * dx\n    return error\n\ndef solve():\n    \"\"\"\n    Main driver function to run simulations and print results.\n    \"\"\"\n    # Problem parameters\n    T_final = 0.2\n    advection_speed = 1.0\n    CFL_number = 0.9\n    grid_resolutions = [100, 200, 400]\n    \n    results = []\n    \n    # Run Lax-Friedrichs simulations\n    for N_val in grid_resolutions:\n        error = solve_lax_friedrichs(N_val, T_final, CFL_number, advection_speed)\n        results.append(f\"{error:.6f}\")\n        \n    # Run Godunov (upwind) simulations\n    for N_val in grid_resolutions:\n        error = solve_godunov(N_val, T_final, CFL_number, advection_speed)\n        results.append(f\"{error:.6f}\")\n        \n    # Print results in the specified format\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3138441"}, {"introduction": "While robust, the first-order Godunov method's high numerical diffusion limits its accuracy. The next step in developing high-performance schemes is to increase the order of accuracy while maintaining stability. This advanced practice [@problem_id:3138413] guides you through implementing a second-order Godunov-type scheme using the MUSCL (Monotonic Upstream-centered Schemes for Conservation Laws) approach for the nonlinear Burgers' equation. You will explore the crucial role of slope limiters (Minmod, Superbee, and MC) in preventing spurious oscillations and controlling the sharpness of captured discontinuities, a central theme in modern computational fluid dynamics.", "problem": "Consider the scalar conservation law for the one-dimensional inviscid Burgers’ equation, which is given by $u_t + \\left(f(u)\\right)_x = 0$ with $f(u)=\\frac{u^2}{2}$. A finite volume scheme evolves cell averages by balancing numerical fluxes across cell interfaces. In a second-order Godunov–Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) framework, interface states are reconstructed from neighboring cell averages by applying a slope limiter to enforce the Total Variation Diminishing (TVD) property. The three slope limiters to be considered are Minmod, Superbee, and Monotonized Central (MC), each enforcing different compressiveness and numerical diffusion characteristics.\n\nYour task is to implement a complete program that:\n- Discretizes the domain $[0,1]$ into $200$ uniform cells, with $\\Delta x = \\frac{1}{200}$, and uses periodic boundary conditions.\n- Evolves the solution from $t=0$ to a final time $T$ using a conservative finite volume update with a Godunov numerical flux based on the exact Riemann solver for Burgers’ equation. The time step $\\Delta t$ must satisfy a suitable Courant–Friedrichs–Lewy (CFL) condition, with Courant number set to $\\nu=0.9$, i.e., choose $\\Delta t = \\min\\!\\left(\\nu \\frac{\\Delta x}{\\max_i |u_i|}, T-t\\right)$ at each step, where $u_i$ denotes the cell averages.\n- Employ MUSCL reconstruction with limited linear slopes to define left and right interface states; perform three runs, one for each slope limiter: Minmod, Superbee, and Monotonized Central (MC), keeping all other parameters identical.\n- Initializes the solution with a single discontinuity located at $x_0 = 0.5$ using a Riemann-type step: $u(x,0) = u_L$ for $x  x_0$ and $u(x,0) = u_R$ for $x \\ge x_0$.\n\nDefine and compute quantitative overshoot and undershoot as follows at final time $T$:\n- Overshoot magnitude: $\\max\\!\\left(0, \\max_i u_i - \\max\\!\\left(u_L, u_R\\right)\\right)$.\n- Undershoot magnitude: $\\max\\!\\left(0, \\min\\!\\left(u_L, u_R\\right) - \\min_i u_i\\right)$.\n\nImplement the program to evaluate these metrics for the following test suite, which covers shocks, rarefactions, and sign changes across the discontinuity:\n- Case $A$: $(u_L, u_R) = (1, 0)$, $T = 0.2$.\n- Case $B$: $(u_L, u_R) = (0, 1)$, $T = 0.2$.\n- Case $C$: $(u_L, u_R) = (-1, 0.5)$, $T = 0.2$.\n\nFor each case, run the simulation for the three limiters (Minmod, Superbee, MC) and compute the overshoot and undershoot magnitudes. Express all reported values as decimal floats rounded to six decimal places. No physical units are involved.\n\nFinal output format specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets.\n- The list must be ordered by case and limiter as follows: for Case $A$ Minmod overshoot, Case $A$ Minmod undershoot, Case $A$ Superbee overshoot, Case $A$ Superbee undershoot, Case $A$ MC overshoot, Case $A$ MC undershoot, then Case $B$ in the same limiter order, and finally Case $C$ in the same limiter order.\n- For example, the structure is $[A\\text{-}\\text{Minmod-OS},A\\text{-}\\text{Minmod-US},A\\text{-}\\text{Superbee-OS},A\\text{-}\\text{Superbee-US},A\\text{-}\\text{MC-OS},A\\text{-}\\text{MC-US},B\\text{-}\\text{Minmod-OS},\\dots,C\\text{-}\\text{MC-US}]$.\n\nYour program must be self-contained, require no input, and strictly print only the final single-line output in the specified format.", "solution": "The user-provided problem is a well-defined task in computational science, requiring the implementation and comparison of a second-order numerical scheme for a nonlinear hyperbolic conservation law. The problem is scientifically grounded, internally consistent, and possesses all necessary information for a unique solution. Therefore, it is deemed valid.\n\nThe core of the problem is to solve the one-dimensional inviscid Burgers' equation:\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x} \\left( \\frac{u^2}{2} \\right) = 0\n$$\nThis is a scalar conservation law of the form $u_t + (f(u))_x = 0$, with a convex flux function $f(u) = u^2/2$. We will employ a finite volume method on a uniform grid over the domain $[0,1]$ with $N=200$ cells of width $\\Delta x = 1/200$.\n\nA finite volume scheme evolves the cell averages, $u_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$, over time. The semi-discrete form of the conservation law is:\n$$\n\\frac{d u_i}{dt} = - \\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right)\n$$\nwhere $F_{i+1/2}$ is the numerical flux at the interface between cell $i$ and cell $i+1$.\n\nTo achieve second-order accuracy in space, we use the Monotonic Upstream-centered Schemes for Conservation Laws (MUSCL) approach. This involves reconstructing a piecewise-linear representation of the solution within each cell at the beginning of each time step. Within cell $i$, the solution is approximated as:\n$$\nu(x, t^n) = u_i^n + \\frac{\\sigma_i}{\\Delta x}(x-x_i)\n$$\nwhere $u_i^n$ is the cell average at time $t^n$, $x_i$ is the center of cell $i$, and $\\sigma_i$ is a limited slope. The slope must be limited to prevent the generation of new extrema and ensure the scheme is Total Variation Diminishing (TVD). The slope $\\sigma_i$ is computed based on the adjacent cell averages. Let $\\Delta_i^- = u_i^n - u_{i-1}^n$ and $\\Delta_i^+ = u_{i+1}^n - u_i^n$. The limited slope $\\sigma_i$ is a function of these differences, $\\sigma_i = \\text{limiter}(\\Delta_i^-, \\Delta_i^+)$. We will implement three standard limiters:\n\n1.  **Minmod Limiter:** This is the most dissipative TVD limiter.\n    $$\n    \\sigma_i = \\text{minmod}(\\Delta_i^-, \\Delta_i^+) = \\frac{1}{2}(\\text{sgn}(\\Delta_i^-) + \\text{sgn}(\\Delta_i^+)) \\min(|\\Delta_i^-|, |\\Delta_i^+|)\n    $$\n    It returns the argument with the smallest magnitude if both have the same sign, and zero otherwise.\n\n2.  **Monotonized Central (MC) Limiter:** A more accurate limiter that aims to be as close to a central difference as possible without violating monotonicity.\n    $$\n    \\sigma_i = \\text{minmod}\\left(2\\Delta_i^-, \\frac{\\Delta_i^- + \\Delta_i^+}{2}, 2\\Delta_i^+\\right)\n    $$\n    Here, the `minmod` function is extended to multiple arguments: it returns the argument with the smallest magnitude if all arguments have the same sign, and zero otherwise.\n\n3.  **Superbee Limiter:** A highly compressive limiter, which produces sharp profiles for discontinuities but is more prone to overshoots.\n    $$\n    \\sigma_i = \\text{sgn}(\\Delta_i^-) \\max\\left( |\\text{minmod}(\\Delta_i^-, 2\\Delta_i^+)|, |\\text{minmod}(2\\Delta_i^-, \\Delta_i^+)| \\right)\n    $$\n    This selects the steeper of two minmod-limited slopes.\n\nWith the limited slopes, we reconstruct the solution values at the left and right sides of each interface $x_{i+1/2}$:\n$$\nu_{L, i+1/2} = u_i^n + \\frac{1}{2}\\sigma_i\n$$\n$$\nu_{R, i+1/2} = u_{i+1}^n - \\frac{1}{2}\\sigma_{i+1}\n$$\nThese values serve as the initial data for a Riemann problem at each interface. Periodic boundary conditions are enforced by treating cell $N-1$ as the neighbor of cell $0$, and vice-versa, when computing slopes and fluxes at the domain boundaries.\n\nThe numerical flux $F_{i+1/2}$ is given by the Godunov flux, which is derived from the exact solution of the Riemann problem with initial states $(u_L, u_R) = (u_{L, i+1/2}, u_{R, i+1/2})$. For the convex flux $f(u)=u^2/2$, the solution depends on the relative values of $u_L$ and $u_R$:\n\n-   If $u_L > u_R$, the solution is a shock wave traveling at speed $s = (f(u_R) - f(u_L))/(u_R - u_L) = (u_L + u_R)/2$. The state at the interface ($x/t=0$) is $u_L$ if $s > 0$ and $u_R$ if $s  0$. The flux is $f(u_L)$ or $f(u_R)$ accordingly. We use the convention that for $s=0$, the flux is $f(u_L)$.\n-   If $u_L \\leq u_R$, the solution is a rarefaction wave. The state at the interface is determined by the characteristic speed $f'(u) = u$. If the range $[u_L, u_R]$ contains $u=0$, the state at the interface is $u=0$ and the flux is $f(0)=0$. Otherwise, if $u_L>0$, the state is $u_L$; if $u_R0$, the state is $u_R$.\n\nThe time integration is performed using a simple forward Euler method, $u_i^{n+1} = u_i^n + \\Delta t \\frac{du_i}{dt}$. The time step $\\Delta t$ is chosen adaptively to satisfy the Courant–Friedrichs–Lewy (CFL) stability condition:\n$$\n\\Delta t = \\min\\left( \\nu \\frac{\\Delta x}{\\max_i |u_i^n|}, T - t^n \\right)\n$$\nwith a Courant number $\\nu = 0.9$. A small tolerance $\\epsilon$ is added to the denominator to prevent division by zero if all cell averages are zero.\n\nThe complete algorithm proceeds as follows for each test case:\n1.  Initialize cell averages $u_i^0$ based on the given step function.\n2.  Start the time loop, continuing until $t=T$.\n3.  Calculate the stable time step $\\Delta t$.\n4.  Compute the limited slope $\\sigma_i$ for each cell $i$, handling periodic boundaries.\n5.  Reconstruct the interface states $u_{L, i+1/2}$ and $u_{R, i+1/2}$ for all interfaces.\n6.  Calculate the Godunov flux $F_{i+1/2}$ at each interface.\n7.  Update all cell averages $u_i$ using the conservative finite volume formula.\n8.  Increment time $t = t + \\Delta t$.\n9.  After the final time step, compute the overshoot and undershoot metrics from the final solution profile.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef minmod(a, b):\n    \"\"\"Vectorized minmod function.\"\"\"\n    return 0.5 * (np.sign(a) + np.sign(b)) * np.minimum(np.abs(a), np.abs(b))\n\ndef minmod_multi(*args):\n    \"\"\"Vectorized multi-argument minmod function.\"\"\"\n    arrs = np.asarray(args)\n    s = np.sign(arrs)\n    # Signs are the same if the sum of signs is +/- the number of arguments.\n    same_sign = np.abs(np.sum(s, axis=0)) == len(args)\n    min_mag = np.min(np.abs(arrs), axis=0)\n    # Use the sign of the first argument as the representative sign.\n    return np.where(same_sign, np.sign(arrs[0]) * min_mag, 0)\n\ndef mc_limiter(a, b):\n    \"\"\"Vectorized Monotonized Central (MC) limiter.\"\"\"\n    return minmod_multi(2 * a, 0.5 * (a + b), 2 * b)\n\ndef superbee_limiter(a, b):\n    \"\"\"Vectorized Superbee limiter.\"\"\"\n    m1 = minmod(a, 2 * b)\n    m2 = minmod(2 * a, b)\n    # We must ensure the result has the correct sign and is the one with the larger magnitude.\n    return np.where(np.sign(m1) == np.sign(m2), \n                    np.sign(m1) * np.maximum(np.abs(m1), np.abs(m2)), \n                    0)\n\ndef godunov_flux(uL, uR):\n    \"\"\"\n    Computes the Godunov flux for the Burgers' equation f(u) = u^2/2.\n    \"\"\"\n    f = lambda u: 0.5 * u**2\n    \n    # Shock speed\n    s = 0.5 * (uL + uR)\n\n    # Flux for shock case (uL  uR)\n    flux_shock = np.where(s  0, f(uL), f(uR))\n    # Correct for s=0 case where f(uL)=f(uR)\n    # It is implicitly correct, but for clarity:\n    flux_shock[s == 0] = f(uL[s == 0])\n\n    # Flux for rarefaction case (uL = uR)\n    # The state at x/t=0 is 0 if uL  0  uR, uL if uL  0, uR if uR  0\n    f_rar = np.zeros_like(uL)\n    # if uL = 0 = uR, flux is f(0)=0. This is the f_rar default.\n    f_rar = np.where(uL  0, f(uL), f_rar) # uL0 = 0uL=uR\n    f_rar = np.where(uR  0, f(uR), f_rar) # uL=uR0\n    \n    return np.where(uL  uR, flux_shock, f_rar)\n\ndef run_simulation(u_initial, T_final, dx, nu, limiter_func):\n    \"\"\"\n    Runs the MUSCL simulation for Burgers' equation.\n    \"\"\"\n    u = np.copy(u_initial)\n    N = len(u)\n    t = 0.0\n    \n    while t  T_final:\n        # 1. Determine time step using CFL condition\n        u_max = np.max(np.abs(u))\n        # Add a small epsilon to prevent division by zero\n        dt = nu * dx / (u_max + 1e-9)\n        # Ensure we do not step past the final time\n        if t + dt  T_final:\n            dt = T_final - t\n        \n        # 2. Add ghost cells for periodic boundary conditions\n        u_padded = np.pad(u, 1, 'wrap')\n\n        # 3. Compute limited slopes for all cells\n        delta_minus = u_padded[1:-1] - u_padded[0:-2] # u_i - u_{i-1}\n        delta_plus = u_padded[2:] - u_padded[1:-1]   # u_{i+1} - u_i\n        slopes = limiter_func(delta_minus, delta_plus)\n        \n        # 4. Reconstruct interface states\n        # u_L_at_iface[i] is the left state at interface i+1/2\n        u_L_at_iface = u + 0.5 * slopes\n        \n        # u_R_at_iface[i] is the right state at interface i+1/2\n        # For this, we need info from cell i+1, so we roll the arrays\n        u_shifted_left = np.roll(u, -1)\n        slopes_shifted_left = np.roll(slopes, -1)\n        u_R_at_iface = u_shifted_left - 0.5 * slopes_shifted_left\n\n        # 5. Compute fluxes at interfaces\n        # fluxes[i] corresponds to flux at interface i+1/2\n        fluxes = godunov_flux(u_L_at_iface, u_R_at_iface)\n        \n        # 6. Update cell averages using conservative update\n        # For cell i, the update is -(dt/dx) * (F_{i+1/2} - F_{i-1/2})\n        # F_{i-1/2} is fluxes[i-1]. We can get this by rolling the fluxes array.\n        fluxes_left_neighbor = np.roll(fluxes, 1)\n        u -= (dt / dx) * (fluxes - fluxes_left_neighbor)\n        \n        t += dt\n        \n    return u\n\ndef solve():\n    # Define problem parameters\n    N_cells = 200\n    domain_length = 1.0\n    dx = domain_length / N_cells\n    x = np.linspace(dx / 2, domain_length - dx / 2, N_cells)\n    nu = 0.9\n\n    # Define test cases\n    test_cases = [\n        {'name': 'A', 'uL': 1.0, 'uR': 0.0, 'T': 0.2}, # Shock\n        {'name': 'B', 'uL': 0.0, 'uR': 1.0, 'T': 0.2}, # Rarefaction\n        {'name': 'C', 'uL': -1.0, 'uR': 0.5, 'T': 0.2} # Transonic Rarefaction\n    ]\n\n    limiters = {\n        'Minmod': minmod,\n        'Superbee': superbee_limiter,\n        'MC': mc_limiter\n    }\n    limiter_order = ['Minmod', 'Superbee', 'MC']\n\n    results = []\n    \n    for case in test_cases:\n        uL, uR, T = case['uL'], case['uR'], case['T']\n        \n        # Create initial condition\n        x0 = 0.5\n        u0 = np.where(x  x0, uL, uR)\n\n        for limiter_name in limiter_order:\n            limiter_func = limiters[limiter_name]\n            \n            # Run the simulation\n            u_final = run_simulation(u0, T, dx, nu, limiter_func)\n            \n            # Compute metrics\n            u_max_init = max(uL, uR)\n            u_min_init = min(uL, uR)\n            \n            overshoot = max(0, np.max(u_final) - u_max_init)\n            undershoot = max(0, u_min_init - np.min(u_final))\n            \n            results.append(round(overshoot, 6))\n            results.append(round(undershoot, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3138413"}]}