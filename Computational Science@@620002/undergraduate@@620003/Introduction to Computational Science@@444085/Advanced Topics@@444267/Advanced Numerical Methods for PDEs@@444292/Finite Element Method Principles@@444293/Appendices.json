{"hands_on_practices": [{"introduction": "Real-world systems are rarely made of a single material. This practice explores how the Finite Element Method handles problems with heterogeneous materials, such as composites or layered structures. By implementing a solver for a diffusion problem with a discontinuous conductivity coefficient $k(x)$, you will see firsthand how the weak formulation naturally enforces physical interface conditions and discover the importance of accurate integration schemes for achieving correct results. [@problem_id:3129650]", "problem": "Consider the one-dimensional boundary value problem on the interval $[0,1]$ with heterogeneous material properties described by the partial differential equation $- \\dfrac{d}{dx}\\big(k(x)\\,u'(x)\\big) = f(x)$, subject to Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. Assume a piecewise-constant conductivity $k(x)$ with a single jump discontinuity at an interface location $\\xi \\in (0,1)$ given by\n$$\nk(x) = \\begin{cases}\nk_1, & x < \\xi,\\\\\nk_2, & x \\ge \\xi,\n\\end{cases}\n$$\nand a constant right-hand side $f(x) = 1$.\n\nStarting from the variational formulation of the problem (i.e., multiply by a test function $v(x)$ and integrate by parts), derive the bilinear form and the linear functional in the weak formulation using the Sobolev space $H_0^1([0,1])$. Use the standard piecewise-linear (hat) functions on a uniform mesh with $N$ elements to construct a Galerkin approximation. In the aligned case where $\\xi$ coincides with a mesh node, the element-wise integral $\\int k(x)\\,dx$ reduces to $k_e\\,h$, where $k_e$ is constant on the element and $h$ is the element length. In the misaligned case where the interface lies strictly inside an element, implement two assembly strategies:\n- An interface-aware strategy that computes the element-wise integral $\\int k(x)\\,dx$ exactly by splitting the element at $x=\\xi$ and summing contributions from the subsegments with $k_1$ and $k_2$.\n- An interface-unaware strategy that approximates the element-wise integral using the midpoint quadrature rule, i.e., $\\int k(x)\\,dx \\approx k(x_m)\\,h$ with $x_m$ the element midpoint, thus not enforcing interface conditions within the element.\n\nFrom fundamental principles, show that interface conditions, namely the continuity of $u(x)$ and the continuity of the flux $k(x)\\,u'(x)$ at $x=\\xi$, emerge naturally from the weak formulation. Using these principles, implement a finite element method (FEM) solver that:\n1. Assembles the global stiffness matrix from the element matrices derived from $\\int k(x)\\,dx$ and the derivatives of the basis functions.\n2. Assembles the global load vector using $\\int f(x)\\,N_i(x)\\,dx$ for each basis function $N_i(x)$.\n3. Enforces Dirichlet boundary conditions at $x=0$ and $x=1$.\n\nFor validation, derive the exact solution $u(x)$ for $f(x)=1$ and piecewise-constant $k(x)$ by solving the ordinary differential equations $u''(x) = -\\dfrac{1}{k_1}$ on $[0,\\xi)$ and $u''(x) = -\\dfrac{1}{k_2}$ on $[\\xi,1]$, applying $u(0)=0$, $u(1)=0$, and the interface conditions $u(\\xi^-)=u(\\xi^+)$ and $k_1\\,u'(\\xi^-)=k_2\\,u'(\\xi^+)$. Use this exact solution to compute the $L^2$-norm of the error between the FEM approximation and the exact solution,\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2},\n$$\nvia sufficiently accurate numerical quadrature.\n\nYour program must evaluate the $L^2$ error for the following test suite, which explores aligned versus misaligned meshes and interface-aware versus interface-unaware strategies, including an edge case with high contrast in $k(x)$ and a case where the interface is very close to a mesh node:\n- Test $1$: $N=20$, $\\xi=0.5$, $k_1=1$, $k_2=5$, interface-aware assembly $\\text{True}$.\n- Test $2$: $N=20$, $\\xi=0.47$, $k_1=1$, $k_2=5$, interface-aware assembly $\\text{True}$.\n- Test $3$: $N=20$, $\\xi=0.47$, $k_1=1$, $k_2=5$, interface-aware assembly $\\text{False}$.\n- Test $4$: $N=40$, $\\xi=0.3$, $k_1=0.01$, $k_2=100$, interface-aware assembly $\\text{False}$.\n- Test $5$: $N=40$, $\\xi=0.025$, $k_1=2$, $k_2=3$, interface-aware assembly $\\text{True}$.\n\nAll quantities are dimensionless. Your program should produce a single line of output containing the $L^2$-errors for the five test cases as a comma-separated list of floating-point numbers rounded to six decimal places, enclosed in square brackets, i.e., in the format $[e_1,e_2,e_3,e_4,e_5]$ where each $e_i$ is a float.", "solution": "The user-provided problem has been validated and is determined to be a well-posed, scientifically grounded, and objective problem in computational science. All necessary data and conditions are provided, and there are no contradictions or ambiguities.\n\n### 1. Weak Formulation\nThe strong form of the boundary value problem is given by:\n$$\n- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x), \\quad x \\in (0,1)\n$$\nwith Dirichlet boundary conditions $u(0) = 0$ and $u(1) = 0$. The solution $u(x)$ and test functions $v(x)$ are sought in the Sobolev space $H_0^1([0,1])$, which consists of functions that are square-integrable, have square-integrable weak derivatives, and satisfy the homogeneous boundary conditions.\n\nTo derive the weak formulation, we multiply the partial differential equation by a test function $v \\in H_0^1([0,1])$ and integrate over the domain $[0,1]$:\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(k(x) u'(x)\\right) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx\n$$\nwhere $u'(x) = \\frac{du}{dx}$. We apply integration by parts to the left-hand side:\n$$\n\\int_0^1 k(x) u'(x) v'(x) \\, dx - \\left[ k(x) u'(x) v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx\n$$\nSince the test function $v \\in H_0^1([0,1])$, we have $v(0) = v(1) = 0$, which causes the boundary term to vanish. The resulting weak formulation is: Find $u \\in H_0^1([0,1])$ such that\n$$\na(u,v) = L(v) \\quad \\forall v \\in H_0^1([0,1])\n$$\nwhere the bilinear form $a(u,v)$ and the linear functional $L(v)$ are defined as:\n$$\na(u,v) = \\int_0^1 k(x) u'(x) v'(x) \\, dx\n$$\n$$\nL(v) = \\int_0^1 f(x) v(x) \\, dx\n$$\n\n### 2. Interface Conditions\nThe weak formulation naturally incorporates the physical interface conditions. If we assume the solution $u$ is twice differentiable on the subdomains $[0, \\xi)$ and $(\\xi, 1]$, and we integrate by parts over these subdomains separately, we obtain:\n$$\n\\int_0^\\xi k_1 u' v' dx - [k_1 u' v]_0^{\\xi^-} + \\int_\\xi^1 k_2 u' v' dx - [k_2 u' v]_{\\xi^+}^1 = \\int_0^1 f v dx\n$$\nUsing $v(0)=v(1)=0$, this simplifies to:\n$$\n\\int_0^1 k u' v' dx + [k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi) = \\int_0^1 f v dx\n$$\nComparing this with the weak formulation, we see that for the two to be equivalent for every $v \\in H_0^1([0,1])$, the term $[k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi)$ must be zero. Since we can choose a test function $v$ such that $v(\\xi) \\neq 0$, we must have $k_1 u'(\\xi^-) = k_2 u'(\\xi^+)$. This is the continuity of flux condition, which emerges as a natural boundary condition from the weak form. The continuity of the solution $u(\\xi^-) = u(\\xi^+)$ is an essential condition, enforced by seeking a solution $u$ in the space $H^1([0,1])$.\n\n### 3. Finite Element Discretization\nWe discretize the domain $[0,1]$ into $N$ uniform elements of length $h = 1/N$. The nodes are $x_i = i h$ for $i=0, 1, \\dots, N$. The finite element solution $u_h(x)$ is approximated as a linear combination of piecewise-linear basis (hat) functions $N_j(x)$:\n$$\nu_h(x) = \\sum_{j=0}^{N} U_j N_j(x)\n$$\nwhere $U_j$ are the unknown nodal values. The boundary conditions $u(0)=0$ and $u(1)=0$ imply $U_0 = 0$ and $U_N = 0$, so the sum is effectively over the $N-1$ interior nodes.\n\nSubstituting $u_h(x)$ into the weak form and choosing the test functions to be the basis functions themselves ($v(x) = N_i(x)$ for $i=1, \\dots, N-1$), we obtain the Galerkin system of linear equations $K \\mathbf{U} = \\mathbf{F}$:\n$$\n\\sum_{j=1}^{N-1} U_j \\underbrace{\\left( \\int_0^1 k(x) N'_j(x) N'_i(x) \\, dx \\right)}_{K_{ij}} = \\underbrace{\\int_0^1 f(x) N_i(x) \\, dx}_{F_i}\n$$\nwhere $\\mathbf{U}$ is the vector of unknown nodal values $[U_1, \\dots, U_{N-1}]^T$.\n\n### 4. System Assembly\nThe stiffness matrix $K$ and load vector $\\mathbf{F}$ are assembled from element-wise contributions. For an element $e$ spanning $[x_e, x_{e+1}]$, the local basis functions have derivatives $\\pm 1/h$. The $2 \\times 2$ element stiffness matrix $K^e$ is:\n$$\nK^e = \\frac{1}{h^2} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix} \\int_{x_e}^{x_{e+1}} k(x) \\, dx\n$$\nThe crucial term is the integral of the conductivity, $I_e = \\int_{x_e}^{x_{e+1}} k(x) \\, dx$.\n- **Interface-aware strategy**: $I_e$ is computed exactly. If the interface $\\xi$ is in $(x_e, x_{e+1})$, the integral is split: $I_e = \\int_{x_e}^{\\xi} k_1 dx + \\int_{\\xi}^{x_{e+1}} k_2 dx = k_1(\\xi-x_e) + k_2(x_{e+1}-\\xi)$. Otherwise, $I_e$ is either $k_1 h$ or $k_2 h$.\n- **Interface-unaware strategy**: $I_e$ is approximated using the midpoint rule: $I_e \\approx k(x_m)h$, where $x_m = (x_e+x_{e+1})/2$. This assigns a single conductivity value to the entire element based on its midpoint, ignoring any sub-element variation.\n\nFor the load vector with $f(x)=1$, the entry for an interior node $i$ is $F_i = \\int_0^1 N_i(x) dx$. The integral of a hat function over its support is its area, which is $\\frac{1}{2} \\times \\text{base} \\times \\text{height} = \\frac{1}{2} \\times 2h \\times 1 = h$. Thus, $F_i = h$ for all interior nodes.\n\nAfter assembly, the $(N-1) \\times (N-1)$ tridiagonal system $K \\mathbf{U} = \\mathbf{F}$ is solved for the nodal values $\\mathbf{U}$.\n\n### 5. Exact Solution\nFor a piecewise-constant $k(x)$ and constant forcing $f(x)=1$, the ODEs are $u_1''(x) = -1/k_1$ for $x \\in [0, \\xi)$ and $u_2''(x) = -1/k_2$ for $x \\in [\\xi, 1]$. Double integration yields:\n$$\nu_1(x) = -\\frac{x^2}{2k_1} + C_1 x + D_1\n$$\n$$\nu_2(x) = -\\frac{x^2}{2k_2} + C_2 x + D_2\n$$\nApplying the four conditions ($u(0)=0$, $u(1)=0$, $u(\\xi^-)=u(\\xi^+)$, $k_1 u'(\\xi^-)=k_2 u'(\\xi^+)$) allows for the determination of the four constants of integration $C_1, C_2, D_1, D_2$. The solution is:\n$$\nu(x) = \\begin{cases}\n-\\frac{x^2}{2k_1} + C_1 x, & x < \\xi \\\\\n-\\frac{x^2}{2k_2} + C_2 x + D_2, & x \\ge \\xi\n\\end{cases}\n$$\nwith $D_1=0$ and\n$$\nC_1 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_1(k_1(1-\\xi) + k_2 \\xi)}, \\quad C_2 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_2(k_1(1-\\xi) + k_2 \\xi)}, \\quad D_2 = \\frac{(\\xi^2-\\xi)(k_1-k_2)}{2k_2(k_1(1-\\xi) + k_2 \\xi)}\n$$\n\n### 6. Error Computation\nThe accuracy of the FEM solution $u_h(x)$ is measured by the $L^2$-norm of the error, $\\|u - u_h\\|_{L^2(0,1)}$:\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2}\n$$\nThis integral is computed numerically using a high-order quadrature rule. Here, the trapezoidal rule is applied on a fine grid of $10000$ points to ensure the quadrature error is negligible compared to the FEM discretization error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # N, xi, k1, k2, is_aware\n        (20, 0.5, 1, 5, True),\n        (20, 0.47, 1, 5, True),\n        (20, 0.47, 1, 5, False),\n        (40, 0.3, 0.01, 100, False),\n        (40, 0.025, 2, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_fem_bvp(*case)\n        results.append(error)\n\n    # Format the output as specified\n    formatted_results = [\"{:.6f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef solve_fem_bvp(N, xi, k1, k2, is_aware):\n    \"\"\"\n    Solves the 1D BVP using FEM for a given set of parameters.\n\n    Args:\n        N (int): Number of elements.\n        xi (float): Interface location.\n        k1 (float): Conductivity for x < xi.\n        k2 (float): Conductivity for x >= xi.\n        is_aware (bool): Flag for interface-aware assembly strategy.\n\n    Returns:\n        float: The L2 norm of the error.\n    \"\"\"\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    num_dof = N - 1\n\n    # 1. Assemble Stiffness Matrix K and Load Vector F\n    K = np.zeros((num_dof, num_dof))\n    F = np.full(num_dof, h)\n\n    # Pre-calculate all element integrals of k(x), denoted I_e\n    I_e = np.zeros(N)\n    for e in range(N):\n        x_e = nodes[e]\n        x_e_plus_1 = nodes[e+1]\n\n        if is_aware:\n            # Interface-aware assembly (exact integral)\n            if xi <= x_e:\n                I_e[e] = k2 * h\n            elif xi > x_e_plus_1:\n                I_e[e] = k1 * h\n            else:  # Interface is inside the element\n                I_e[e] = k1 * (xi - x_e) + k2 * (x_e_plus_1 - xi)\n        else:\n            # Interface-unaware assembly (midpoint rule)\n            x_m = (x_e + x_e_plus_1) / 2.0\n            k_mid = k1 if x_m < xi else k2\n            I_e[e] = k_mid * h\n\n    # Assemble K for interior nodes (DoFs 1 to N-1)\n    for i in range(num_dof):  # Matrix index i from 0 to N-2\n        # Diagonal entry K[i, i] corresponds to node i+1\n        # Contribution from element i and element i+1\n        K[i, i] = (I_e[i] + I_e[i+1]) / (h ** 2)\n        # Off-diagonal entries\n        if i > 0:\n            K[i, i - 1] = -I_e[i] / (h ** 2)\n        if i < num_dof - 1:\n            K[i, i + 1] = -I_e[i+1] / (h ** 2)\n\n    # 2. Solve the linear system for interior node values\n    U_interior = np.linalg.solve(K, F)\n\n    # Reconstruct full solution vector including boundary conditions\n    U_full = np.zeros(N + 1)\n    U_full[1:N] = U_interior\n\n    # 3. Calculate L2 error\n    # Define exact solution function\n    def get_exact_solution(xi_p, k1_p, k2_p):\n        A = k1_p * (1 - xi_p) + k2_p * xi_p\n        if np.isclose(A, 0): # Should not happen with positive k values\n            return lambda x: 0.0\n\n        C1_num = k1_p * (1 - xi_p**2) + k2_p * xi_p**2\n        C1 = C1_num / (2 * k1_p * A)\n        C2 = C1_num / (2 * k2_p * A)\n        D2 = ((xi_p**2 - xi_p) * (k1_p - k2_p)) / (2 * k2_p * A)\n\n        def u_exact(x):\n            if x < xi_p:\n                return -x**2 / (2 * k1_p) + C1 * x\n            else:\n                return -x**2 / (2 * k2_p) + C2 * x + D2\n        return u_exact\n\n    u_exact_func = get_exact_solution(xi, k1, k2)\n\n    # Define FEM solution function\n    def u_h(x, nodes_h, U_sol, h_val):\n        if x <= 0.0: return 0.0\n        if x >= 1.0: return 0.0\n        \n        i = int(np.floor(x / h_val))\n        x_i = nodes_h[i]\n        # Linear interpolation within element i\n        val = U_sol[i] * (nodes_h[i+1] - x) / h_val + U_sol[i+1] * (x - x_i) / h_val\n        return val\n\n    # Numerical integration for L2 norm using a fine grid\n    num_quad_points = 10000\n    quad_points = np.linspace(0, 1, num_quad_points + 1)\n    \n    # Vectorized evaluation over the fine grid\n    exact_vals = np.array([u_exact_func(x) for x in quad_points])\n    fem_vals = np.array([u_h(x, nodes, U_full, h) for x in quad_points])\n\n    squared_errors = (exact_vals - fem_vals)**2\n    \n    # Trapezoidal rule for integration\n    integral = np.trapz(squared_errors, quad_points)\n\n    l2_error = np.sqrt(integral)\n    \n    return l2_error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3129650"}, {"introduction": "Most engineering designs involve curves, yet basic finite elements are straight-sided polygons. This exercise delves into how FEM represents curved boundaries using isoparametric mapping, a cornerstone of modern computational modeling. You will quantify the geometric error introduced by approximating a curved edge with a straight one by directly comparing a flux integral, providing insight into why higher-order elements are essential for accurately simulating complex geometries. [@problem_id:3129704]", "problem": "Consider a two-dimensional boundary segment that is either curved or approximated by a straight edge in the context of the Finite Element Method (FEM) principles. The objective is to quantify the impact of geometric approximation on a flux line integral. Start from the fundamental definition of flux across a curve: the flux of a vector field $\\mathbf{F}(x,y)$ across a boundary curve $\\Gamma$ with unit normal $\\hat{\\mathbf{n}}$ is the line integral $\\int_{\\Gamma} \\mathbf{F} \\cdot \\hat{\\mathbf{n}} \\, ds$. For a differentiable parametrization $\\mathbf{x}(\\xi)$ with parameter $\\xi \\in [-1,1]$, the tangent is $\\mathbf{t}(\\xi) = \\dfrac{d\\mathbf{x}}{d\\xi}$, a normal of length $\\|\\mathbf{t}(\\xi)\\|$ is $\\mathbf{n}(\\xi) = \\mathbf{R}\\,\\mathbf{t}(\\xi)$ where $\\mathbf{R} = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$ (rotation by $+90^\\circ$), and $ds = \\|\\mathbf{t}(\\xi)\\| \\, d\\xi$. Therefore, the flux integral can be expressed as $\\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\mathbf{n}(\\xi) \\, d\\xi$.\n\nYou will compare:\n- The curved-edge flux integral using a quadratic isoparametric mapping with nodes at $\\xi=-1$, $\\xi=0$, and $\\xi=1$.\n- The straight-edge approximation using a linear mapping between the endpoints (ignoring the middle node).\n\nLet the vector field be $\\mathbf{F}(x,y) = \\big[x^2 y,\\; x - y^2\\big]$.\n\nCurved edge mapping: Use quadratic Lagrange shape functions on $[-1,1]$ with node positions at $\\xi=-1$, $\\xi=0$, and $\\xi=1$:\n- $N_{-1}(\\xi) = \\dfrac{\\xi(\\xi - 1)}{2}$,\n- $N_{0}(\\xi) = 1 - \\xi^2$,\n- $N_{1}(\\xi) = \\dfrac{\\xi(\\xi + 1)}{2}$.\nGiven physical node coordinates $\\mathbf{P}_{-1}$, $\\mathbf{P}_0$, $\\mathbf{P}_{1}$, define $\\mathbf{x}(\\xi) = N_{-1}(\\xi)\\,\\mathbf{P}_{-1} + N_{0}(\\xi)\\,\\mathbf{P}_{0} + N_{1}(\\xi)\\,\\mathbf{P}_{1}$, and $\\mathbf{t}(\\xi) = \\dfrac{d\\mathbf{x}}{d\\xi}$ with derivatives $N_{-1}'(\\xi) = \\xi - \\dfrac{1}{2}$, $N_0'(\\xi) = -2\\xi$, $N_1'(\\xi) = \\xi + \\dfrac{1}{2}$. The curved-edge flux is $I_{\\mathrm{curved}} = \\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\big(\\mathbf{R}\\,\\mathbf{t}(\\xi)\\big) \\, d\\xi$.\n\nStraight-edge approximation: Parameterize the straight segment from $\\mathbf{P}_{-1}$ to $\\mathbf{P}_{1}$ by $\\mathbf{x}_s(p) = \\dfrac{1-p}{2}\\,\\mathbf{P}_{-1} + \\dfrac{1+p}{2}\\,\\mathbf{P}_{1}$ for $p \\in [-1,1]$. Then $\\mathbf{t}_s = \\dfrac{d\\mathbf{x}_s}{dp} = \\dfrac{\\mathbf{P}_{1} - \\mathbf{P}_{-1}}{2}$ is constant, and the straight-edge flux is $I_{\\mathrm{straight}} = \\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}_s(p)) \\cdot \\big(\\mathbf{R}\\,\\mathbf{t}_s\\big) \\, dp$.\n\nImplement both integrals using Gauss–Legendre quadrature on $[-1,1]$ with at least $n_q = 16$ points to ensure high accuracy for the given polynomial vector field and mappings.\n\nTest suite: For each case below, compute $I_{\\mathrm{curved}}$, $I_{\\mathrm{straight}}$, and report the absolute difference $\\Delta = \\big|I_{\\mathrm{curved}} - I_{\\mathrm{straight}}\\big|$.\n- Case $1$ (mild curvature, horizontal chord): $\\mathbf{P}_{-1} = (0,0)$, $\\mathbf{P}_0 = (0.5, 0.2)$, $\\mathbf{P}_{1} = (1,0)$.\n- Case $2$ (strong curvature, horizontal chord): $\\mathbf{P}_{-1} = (0,0)$, $\\mathbf{P}_0 = (0.5, -0.6)$, $\\mathbf{P}_{1} = (1,0)$.\n- Case $3$ (diagonal chord with curvature): $\\mathbf{P}_{-1} = (0,0)$, $\\mathbf{P}_0 = (0.7, 0.4)$, $\\mathbf{P}_{1} = (1,1)$.\n- Case $4$ (zero curvature, exactly straight): $\\mathbf{P}_{-1} = (0,0)$, $\\mathbf{P}_0 = (0.5, 0.5)$, $\\mathbf{P}_{1} = (1,1)$.\n\nYour program must:\n- Implement the definitions above to compute $I_{\\mathrm{curved}}$ and $I_{\\mathrm{straight}}$ via numerical quadrature.\n- Produce, for the four cases in the given order, the list of absolute differences $\\Delta$.\n\nFinal output format: Your program should produce a single line of output containing a comma-separated list of four floating-point numbers enclosed in square brackets, with each number rounded to exactly $8$ decimal places, for example, $[\\Delta_1,\\Delta_2,\\Delta_3,\\Delta_4]$.", "solution": "The problem requires a quantitative comparison between the flux of a vector field across a quadratically-defined curved boundary and its linear (straight-edge) approximation. This analysis is fundamental to understanding geometric errors in the Finite Element Method (FEM). The flux of a vector field $\\mathbf{F}$ across a curve $\\Gamma$ is given by the line integral $\\int_{\\Gamma} \\mathbf{F} \\cdot \\hat{\\mathbf{n}} \\, ds$, where $\\hat{\\mathbf{n}}$ is the unit normal vector and $ds$ is the differential arc length.\n\nWe are given a methodology to compute this flux using a parametric representation of the boundary, $\\mathbf{x}(\\xi)$, where $\\xi \\in [-1, 1]$. The flux integral is transformed to an integral over the reference domain $[-1, 1]$:\n$$I = \\int_{-1}^{1} \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\mathbf{n}(\\xi) \\, d\\xi$$\nHere, $\\mathbf{t}(\\xi) = \\frac{d\\mathbf{x}}{d\\xi}$ is the tangent vector, and $\\mathbf{n}(\\xi) = \\mathbf{R}\\,\\mathbf{t}(\\xi)$ is a normal vector, where $\\mathbf{R} = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}$ is the rotation matrix for a $+90^\\circ$ rotation. The vector field is specified as $\\mathbf{F}(x,y) = \\begin{bmatrix} x^2 y \\\\ x - y^2 \\end{bmatrix}$.\n\nThe objective is to compute the absolute difference $\\Delta = |I_{\\mathrm{curved}} - I_{\\mathrm{straight}}|$ for four different sets of control points. Both integrals will be approximated numerically using an $n_q$-point Gauss–Legendre quadrature rule on the interval $[-1, 1]$:\n$$\\int_{-1}^{1} g(\\xi) \\, d\\xi \\approx \\sum_{i=1}^{n_q} w_i g(\\xi_i)$$\nwhere $\\xi_i$ are the quadrature points (roots of the Legendre polynomial of degree $n_q$) and $w_i$ are the corresponding weights. We will use $n_q = 16$, which ensures high accuracy.\n\n**1. Curved-Edge Flux, $I_{\\mathrm{curved}}$**\n\nThe curved edge is defined by a quadratic isoparametric mapping using three nodes: $\\mathbf{P}_{-1}$, $\\mathbf{P}_0$, and $\\mathbf{P}_{1}$. The position vector $\\mathbf{x}(\\xi)$ is given by:\n$$\\mathbf{x}(\\xi) = N_{-1}(\\xi)\\,\\mathbf{P}_{-1} + N_{0}(\\xi)\\,\\mathbf{P}_{0} + N_{1}(\\xi)\\,\\mathbf{P}_{1}$$\nwhere $N_{-1}(\\xi)$, $N_0(\\xi)$, and $N_1(\\xi)$ are the quadratic Lagrange shape functions:\n- $N_{-1}(\\xi) = \\dfrac{\\xi(\\xi - 1)}{2}$\n- $N_{0}(\\xi) = 1 - \\xi^2$\n- $N_{1}(\\xi) = \\dfrac{\\xi(\\xi + 1)}{2}$\n\nThe tangent vector $\\mathbf{t}(\\xi) = \\frac{d\\mathbf{x}}{d\\xi}$ is found by differentiating the shape functions:\n$$\\mathbf{t}(\\xi) = N_{-1}'(\\xi)\\,\\mathbf{P}_{-1} + N_{0}'(\\xi)\\,\\mathbf{P}_{0} + N_{1}'(\\xi)\\,\\mathbf{P}_{1}$$\nwith the derivatives given as:\n- $N_{-1}'(\\xi) = \\xi - \\dfrac{1}{2}$\n- $N_0'(\\xi) = -2\\xi$\n- $N_1'(\\xi) = \\xi + \\dfrac{1}{2}$\n\nLet $\\mathbf{P}_j = \\begin{bmatrix} P_{jx} \\\\ P_{jy} \\end{bmatrix}$. Then the components of the tangent vector $\\mathbf{t}(\\xi) = \\begin{bmatrix} t_x(\\xi) \\\\ t_y(\\xi) \\end{bmatrix}$ are:\n$$t_x(\\xi) = N_{-1}'(\\xi)P_{-1x} + N_{0}'(\\xi)P_{0x} + N_{1}'(\\xi)P_{1x}$$\n$$t_y(\\xi) = N_{-1}'(\\xi)P_{-1y} + N_{0}'(\\xi)P_{0y} + N_{1}'(\\xi)P_{1y}$$\nThe normal vector is $\\mathbf{n}(\\xi) = \\mathbf{R}\\,\\mathbf{t}(\\xi) = \\begin{bmatrix} -t_y(\\xi) \\\\ t_x(\\xi) \\end{bmatrix}$.\n\nThe integrand for the curved-edge flux is $g(\\xi) = \\mathbf{F}(\\mathbf{x}(\\xi)) \\cdot \\mathbf{n}(\\xi)$. The algorithm for computing $I_{\\mathrm{curved}}$ is:\n1. Obtain the $n_q$ Gauss-Legendre points $\\xi_i$ and weights $w_i$.\n2. Initialize the integral $I_{\\mathrm{curved}} = 0$.\n3. For each quadrature point $\\xi_i$:\n    a. Evaluate the shape functions $N_j(\\xi_i)$ and their derivatives $N_j'(\\xi_i)$ for $j \\in \\{-1, 0, 1\\}$.\n    b. Compute the physical coordinates $\\mathbf{x}(\\xi_i) = \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix}$.\n    c. Compute the tangent vector $\\mathbf{t}(\\xi_i) = \\begin{bmatrix} t_{x,i} \\\\ t_{y,i} \\end{bmatrix}$ and the normal vector $\\mathbf{n}(\\xi_i) = \\begin{bmatrix} -t_{y,i} \\\\ t_{x,i} \\end{bmatrix}$.\n    d. Evaluate the vector field at this point: $\\mathbf{F}(x_i, y_i) = \\begin{bmatrix} x_i^2 y_i \\\\ x_i - y_i^2 \\end{bmatrix}$.\n    e. Compute the dot product: $d_i = \\mathbf{F}(x_i, y_i) \\cdot \\mathbf{n}(\\xi_i)$.\n    f. Add the weighted contribution to the integral: $I_{\\mathrm{curved}} = I_{\\mathrm{curved}} + w_i d_i$.\n\n**2. Straight-Edge Flux, $I_{\\mathrm{straight}}$**\n\nThe straight-edge approximation connects the endpoints $\\mathbf{P}_{-1}$ and $\\mathbf{P}_{1}$ with a linear segment. The parameterization over $p \\in [-1, 1]$ is:\n$$\\mathbf{x}_s(p) = \\dfrac{1-p}{2}\\,\\mathbf{P}_{-1} + \\dfrac{1+p}{2}\\,\\mathbf{P}_{1}$$\nThe tangent vector is constant:\n$$\\mathbf{t}_s = \\frac{d\\mathbf{x}_s}{dp} = \\dfrac{\\mathbf{P}_{1} - \\mathbf{P}_{-1}}{2}$$\nLet $\\mathbf{t}_s = \\begin{bmatrix} t_{sx} \\\\ t_{sy} \\end{bmatrix}$. The normal vector $\\mathbf{n}_s = \\mathbf{R}\\,\\mathbf{t}_s = \\begin{bmatrix} -t_{sy} \\\\ t_{sx} \\end{bmatrix}$ is also constant.\n\nThe integrand is $h(p) = \\mathbf{F}(\\mathbf{x}_s(p)) \\cdot \\mathbf{n}_s$. The algorithm for computing $I_{\\mathrm{straight}}$ is:\n1. Obtain the $n_q$ Gauss-Legendre points $p_i$ (identical to $\\xi_i$) and weights $w_i$.\n2. Calculate the constant tangent $\\mathbf{t}_s$ and normal $\\mathbf{n}_s$.\n3. Initialize the integral $I_{\\mathrm{straight}} = 0$.\n4. For each quadrature point $p_i$:\n    a. Compute the physical coordinates $\\mathbf{x}_s(p_i) = \\begin{bmatrix} x_{s,i} \\\\ y_{s,i} \\end{bmatrix}$.\n    b. Evaluate the vector field: $\\mathbf{F}(x_{s,i}, y_{s,i}) = \\begin{bmatrix} x_{s,i}^2 y_{s,i} \\\\ x_{s,i} - y_{s,i}^2 \\end{bmatrix}$.\n    c. Compute the dot product: $d_{s,i} = \\mathbf{F}(x_{s,i}, y_{s,i}) \\cdot \\mathbf{n}_s$.\n    d. Add the weighted contribution to the integral: $I_{\\mathrm{straight}} = I_{\\mathrm{straight}} + w_i d_{s,i}$.\n\nFinally, for each test case, the absolute difference $\\Delta = |I_{\\mathrm{curved}} - I_{\\mathrm{straight}}|$ is computed. For Case $4$, the three nodes are collinear with $\\mathbf{P}_0$ being the midpoint of the segment $\\mathbf{P}_{-1}\\mathbf{P}_{1}$. In this specific situation, the quadratic mapping exactly reproduces the linear path, so we expect $I_{\\mathrm{curved}} = I_{\\mathrm{straight}}$ and thus $\\Delta = 0$ (or a value very close to zero due to floating-point arithmetic).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the absolute difference in flux integrals between a curved quadratic edge\n    and its straight-line approximation for a given vector field and several geometries.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mild curvature, horizontal chord)\n        (np.array([0.0, 0.0]), np.array([0.5, 0.2]), np.array([1.0, 0.0])),\n        # Case 2 (strong curvature, horizontal chord)\n        (np.array([0.0, 0.0]), np.array([0.5, -0.6]), np.array([1.0, 0.0])),\n        # Case 3 (diagonal chord with curvature)\n        (np.array([0.0, 0.0]), np.array([0.7, 0.4]), np.array([1.0, 1.0])),\n        # Case 4 (zero curvature, exactly straight)\n        (np.array([0.0, 0.0]), np.array([0.5, 0.5]), np.array([1.0, 1.0])),\n    ]\n\n    # Use n_q=16 points for Gauss-Legendre quadrature as required.\n    n_q = 16\n    xi_q, w_q = roots_legendre(n_q)\n    \n    # Rotation matrix R for a +90 degree rotation.\n    R = np.array([[0, -1], [1, 0]])\n\n    # Vector field F(x, y) = [x^2*y, x - y^2]\n    def F_field(x, y):\n        return np.array([x**2 * y, x - y**2])\n\n    results = []\n    for case in test_cases:\n        p_m1, p_0, p_1 = case\n\n        # --- Calculate I_curved ---\n        I_curved = 0.0\n        for i in range(n_q):\n            xi = xi_q[i]\n            w = w_q[i]\n            \n            # Quadratic shape functions and their derivatives\n            N_m1 = 0.5 * xi * (xi - 1)\n            N_0 = 1 - xi**2\n            N_1 = 0.5 * xi * (xi + 1)\n            \n            dN_m1 = xi - 0.5\n            dN_0 = -2 * xi\n            dN_1 = xi + 0.5\n\n            # Physical coordinates x(xi)\n            x_vec = N_m1 * p_m1 + N_0 * p_0 + N_1 * p_1\n            \n            # Tangent vector t(xi)\n            t_vec = dN_m1 * p_m1 + dN_0 * p_0 + dN_1 * p_1\n            \n            # Normal vector n(xi) = R * t(xi)\n            n_vec = R @ t_vec\n            \n            # Evaluate vector field F at x(xi)\n            F_val = F_field(x_vec[0], x_vec[1])\n            \n            # Integrand value\n            integrand = np.dot(F_val, n_vec)\n            \n            I_curved += w * integrand\n            \n        # --- Calculate I_straight ---\n        I_straight = 0.0\n        \n        # Constant tangent and normal for the straight edge\n        t_s_vec = 0.5 * (p_1 - p_m1)\n        n_s_vec = R @ t_s_vec\n\n        for i in range(n_q):\n            p = xi_q[i] # Use same quadrature points for parameter 'p'\n            w = w_q[i]\n            \n            # Linear shape functions for the straight segment\n            M_m1 = 0.5 * (1 - p)\n            M_1 = 0.5 * (1 + p)\n            \n            # Physical coordinates x_s(p)\n            xs_vec = M_m1 * p_m1 + M_1 * p_1\n            \n            # Evaluate vector field F at x_s(p)\n            Fs_val = F_field(xs_vec[0], xs_vec[1])\n            \n            # Integrand value\n            integrand_s = np.dot(Fs_val, n_s_vec)\n            \n            I_straight += w * integrand_s\n\n        delta = abs(I_curved - I_straight)\n        results.append(delta)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3129704"}, {"introduction": "Many physical phenomena, from heat transfer to structural vibrations, evolve over time. This practice extends the FEM framework from static problems to dynamics by solving the time-dependent heat equation. After deriving the semi-discrete system $M \\dot{u} + K u = f$, you will compare the performance of several crucial time integration schemes, investigating the trade-offs between accuracy, stability, and their ability to handle the stiff systems that frequently arise from spatial discretization. [@problem_id:3129641]", "problem": "You will write a complete, runnable program that constructs a one-dimensional Finite Element Method (FEM) semi-discrete model of the heat equation and compares three implicit time integrators in terms of accuracy and stiffness handling. The semi-discrete model has the form $M \\, \\dot{u}(t) + K \\, u(t) = f(t)$, where $M$ is the symmetric positive definite mass matrix and $K$ is the symmetric positive semidefinite stiffness matrix arising from a conforming Galerkin discretization with linear basis functions on a uniform mesh of the unit interval with homogeneous Dirichlet boundary conditions.\n\nYour implementation must be derived from the following fundamental base:\n- The strong form of the heat equation in one spatial dimension is $\\partial_t u(x,t) - \\partial_{xx} u(x,t) = s(x,t)$ with appropriate boundary and initial data.\n- The weak form is obtained by multiplying by a test function, integrating by parts in space, and applying the boundary conditions, which leads to a semi-discrete linear system of the form $M \\, \\dot{u}(t) + K \\, u(t) = f(t)$ when the spatial variable is discretized by a conforming Galerkin method using piecewise linear shape functions.\n- Time integrators are constructed by consistent time discretization of $\\dot{u}(t)$ using algebraically stable implicit schemes.\n\nFrom this base, without using any shortcut formulas, derive and then implement the following time integrators applied to the semi-discrete system:\n- Backward Euler (also called implicit Euler).\n- Crank–Nicolson.\n- Backward Differentiation Formula of order $2$ (BDF2), with a consistent one-step implicit start.\n\nYou must ensure scientific realism and correctness at every stage, including the assembly of $M$ and $K$ for the mesh and the handling of homogeneous Dirichlet boundary conditions.\n\nTo make the problem fully testable, use the following test suite and evaluation metrics, all expressed in purely mathematical terms with no physical units:\n\n1) Accuracy tests (temporal convergence at a fixed final time):\n- Let the spatial mesh have $N_\\text{el} = 50$ uniform elements on $[0,1]$, so there are $N = N_\\text{el} - 1$ interior nodes. Assemble the consistent FEM mass matrix $M$ and stiffness matrix $K$ using standard linear basis functions with homogeneous Dirichlet boundary conditions at $x=0$ and $x=1$.\n- Define the semi-discrete initial condition $u(0)$ as a linear combination of the first two generalized eigenvectors of the pencil $(K,M)$ corresponding to the two smallest generalized eigenvalues. Specifically, let $K v_i = \\lambda_i M v_i$ with $v_i^\\top M v_j = \\delta_{ij}$, and define $u(0) = 1 \\cdot v_1 + 0.5 \\cdot v_2$. Set $f(t) \\equiv 0$. The exact semi-discrete solution is then $u_\\text{exact}(t) = \\sum_{i} c_i e^{-\\lambda_i t} v_i$ with coefficients $c_i = v_i^\\top M u(0)$.\n- Choose the final time $T = 0.1$. For each method, compute the numerical solution at $T$ using two time step sizes: $\\Delta t_\\text{coarse} = T/40$ and $\\Delta t_\\text{fine} = T/80$. For each $\\Delta t$, compute the error $e(\\Delta t) = \\| u_\\text{num}(T;\\Delta t) - u_\\text{exact}(T) \\|_M$, where $\\|w\\|_M = \\sqrt{w^\\top M w}$.\n- For each method, estimate the observed temporal order of accuracy by $p = \\dfrac{\\log\\big(e(\\Delta t_\\text{coarse}) / e(\\Delta t_\\text{fine})\\big)}{\\log(2)}$.\n\n2) Stiffness handling test (damping of the stiffest mode at a large time step):\n- Let the spatial mesh have $N_\\text{el} = 200$ uniform elements on $[0,1]$, again with homogeneous Dirichlet boundary conditions, and assemble $M$ and $K$.\n- Compute the largest generalized eigenvalue $\\lambda_{\\max}$ and corresponding $M$-normalized eigenvector $v_{\\max}$ of the pencil $(K,M)$, so that $K v_{\\max} = \\lambda_{\\max} M v_{\\max}$ and $v_{\\max}^\\top M v_{\\max} = 1$.\n- Set $u(0) = v_{\\max}$ and $f(t) \\equiv 0$. Define a large time step $\\Delta t_\\text{stiff} = 50 / \\lambda_{\\max}$ and take a single time step with Backward Euler and with Crank–Nicolson. For Backward Euler and for Crank–Nicolson, compute the one-step amplification factor in the $M$-norm:\n  - $r_\\text{BE} = \\dfrac{\\|u^{1}_\\text{BE}\\|_M}{\\|u^0\\|_M}$,\n  - $r_\\text{CN} = \\dfrac{\\|u^{1}_\\text{CN}\\|_M}{\\|u^0\\|_M}$,\n  where $u^{1}_\\text{method}$ denotes the solution after one time step.\n- For BDF2, use a consistent one-step implicit start: first take one Backward Euler step to obtain $u^{1}$, then take one BDF2 step to obtain $u^{2}$. Define the per-step amplification measured on the BDF2 step by $r_\\text{BDF2} = \\dfrac{\\|u^{2}\\|_M}{\\|u^{1}\\|_M}$.\n- Additionally, detect whether Crank–Nicolson exhibits oscillatory behavior on the stiff mode by checking the sign change of the modal coefficient along $v_{\\max}$: compute $c_0 = v_{\\max}^\\top M u^{0}$ and $c_1 = v_{\\max}^\\top M u^{1}_\\text{CN}$, and set a boolean flag `osc_CN` = $\\text{True}$ if $c_0 \\cdot c_1 < 0$, otherwise $\\text{False}$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The aggregated results must be, in order:\n  - The three observed orders $p$ for Backward Euler, Crank–Nicolson, and BDF2 from the accuracy tests, each rounded to three decimals.\n  - The three amplification factors $r_\\text{BE}$, $r_\\text{CN}$, and $r_\\text{BDF2}$ from the stiffness handling test, each rounded to six decimals.\n  - The boolean flag `osc_CN`.\n- Concretely, the output format is $[p_\\text{BE},p_\\text{CN},p_\\text{BDF2},r_\\text{BE},r_\\text{CN},r_\\text{BDF2},\\text{osc}_\\text{CN}]$.\n\nNotes and constraints:\n- All mathematical quantities are dimensionless; no physical units are to be reported.\n- Angles do not appear; no angle units are needed.\n- Percentages are not used.\n- You must derive each time integrator from first principles based on the semi-discrete system $M \\, \\dot{u} + K \\, u = f$.\n- Use the consistent mass matrix, not a lumped mass approximation.\n- Use homogeneous Dirichlet boundary conditions by eliminating the boundary degrees of freedom.\n\nYour program must strictly adhere to the required final output format and must not read any input. It must be fully self-contained and deterministic for the prescribed test suite.", "solution": "The user has provided a valid, well-posed, and scientifically grounded problem. The task is to construct a one-dimensional Finite Element Method (FEM) model for the heat equation and evaluate three implicit time integration schemes. The solution proceeds by first deriving the necessary mathematical formulations and then implementing them in a Python script to perform the specified numerical experiments.\n\n### 1. Spatial Discretization: Finite Element Method\n\nThe problem starts with the strong form of the one-dimensional heat equation on the domain $\\Omega = [0, 1]$ with homogeneous Dirichlet boundary conditions:\n$$\n\\begin{cases}\n\\partial_t u(x,t) - \\partial_{xx} u(x,t) = s(x,t) & \\text{for } x \\in (0,1), t > 0 \\\\\nu(0,t) = 0, \\quad u(1,t) = 0 & \\text{for } t > 0 \\\\\nu(x,0) = u_0(x) & \\text{for } x \\in [0,1]\n\\end{cases}\n$$\nThe weak form is derived by multiplying the partial differential equation by a test function $v(x)$ from a suitable space (here, $H^1_0(0,1)$, the space of functions with square-integrable first derivatives that are zero at the boundaries) and integrating over the domain $\\Omega$:\n$$\n\\int_0^1 v(x) \\partial_t u(x,t) \\,dx - \\int_0^1 v(x) \\partial_{xx} u(x,t) \\,dx = \\int_0^1 v(x) s(x,t) \\,dx\n$$\nApplying integration by parts to the second term and using the homogeneous Dirichlet boundary conditions ($v(0)=v(1)=0$) yields:\n$$\n\\int_0^1 v \\partial_t u \\,dx + \\int_0^1 \\partial_x v \\partial_x u \\,dx = \\int_0^1 v s \\,dx\n$$\nFor the FEM discretization, we divide the interval $[0,1]$ into $N_\\text{el}$ uniform elements of length $h = 1/N_\\text{el}$. This creates $N = N_\\text{el} - 1$ interior nodes. The solution $u(x,t)$ is approximated by a function $u_h(x,t)$ which is a linear combination of piecewise linear basis functions $\\phi_j(x)$, often called \"hat\" functions:\n$$\nu_h(x,t) = \\sum_{j=1}^{N} u_j(t) \\phi_j(x)\n$$\nwhere $u_j(t)$ are the time-dependent nodal values of the solution and $\\phi_j(x)$ is the basis function associated with node $j$ such that $\\phi_j(x_k) = \\delta_{jk}$.\n\nFollowing the Galerkin principle, we choose the test functions to be the basis functions themselves, $v(x) = \\phi_i(x)$ for $i=1, \\dots, N$. Substituting the approximation $u_h$ into the weak form gives a system of ordinary differential equations (ODEs):\n$$\n\\sum_{j=1}^{N} \\left(\\int_0^1 \\phi_i \\phi_j \\,dx\\right) \\dot{u}_j(t) + \\sum_{j=1}^{N} \\left(\\int_0^1 \\phi'_i \\phi'_j \\,dx\\right) u_j(t) = \\int_0^1 \\phi_i s(x,t) \\,dx\n$$\nThis is the semi-discrete system $M \\dot{u}(t) + K u(t) = f(t)$, where $u(t)$ is the vector of nodal values $[u_1(t), ..., u_N(t)]^T$, and the matrices and vector are defined component-wise as:\n- **Mass Matrix**: $M_{ij} = \\int_0^1 \\phi_i(x) \\phi_j(x) \\,dx$\n- **Stiffness Matrix**: $K_{ij} = \\int_0^1 \\phi'_i(x) \\phi'_j(x) \\,dx$\n- **Load Vector**: $f_i(t) = \\int_0^1 \\phi_i(x) s(x,t) \\,dx$\n\nThe integrals for the matrix entries are computed element-wise. For linear basis functions on a uniform mesh of size $h$, the non-zero entries of the resulting tridiagonal matrices are:\n- $M_{ii} = \\int_{x_{i-1}}^{x_{i+1}} \\phi_i^2 \\,dx = \\frac{2h}{3}$\n- $M_{i, i\\pm1} = \\int_{x_{i}}^{x_{i\\pm1}} \\phi_i \\phi_{i\\pm1} \\,dx = \\frac{h}{6}$\n- $K_{ii} = \\int_{x_{i-1}}^{x_{i+1}} (\\phi'_i)^2 \\,dx = \\frac{2}{h}$\n- $K_{i, i\\pm1} = \\int_{x_{i}}^{x_{i\\pm1}} \\phi'_i \\phi'_{i\\pm1} \\,dx = -\\frac{1}{h}$\n\nThe test cases specify $s(x,t)=0$, so the load vector is $f(t) = 0$.\n\n### 2. Temporal Discretization: Implicit Time Integrators\n\nWe solve the homogeneous semi-discrete system $M \\dot{u} + K u = 0$. Let $u^n$ be the numerical approximation of $u(t_n)$ at time $t_n = n \\Delta t$.\n\n**Backward Euler (Implicit Euler)**\nThis first-order method approximates the time derivative at $t_{n+1}$: $\\dot{u}(t_{n+1}) \\approx \\frac{u^{n+1}-u^n}{\\Delta t}$. The system is evaluated at $t_{n+1}$:\n$$\nM \\left(\\frac{u^{n+1} - u^n}{\\Delta t}\\right) + K u^{n+1} = 0 \\implies (M + \\Delta t K) u^{n+1} = M u^n\n$$\nAt each time step, a linear system must be solved for $u^{n+1}$. This method is A-stable and L-stable, providing strong damping for high-frequency (stiff) components.\n\n**Crank-Nicolson**\nThis second-order method is based on the trapezoidal rule. The time derivative is approximated at the midpoint $t_{n+1/2}$, and the term $K u$ is averaged over $t_n$ and $t_{n+1}$:\n$$\nM \\left(\\frac{u^{n+1} - u^n}{\\Delta t}\\right) + K \\left(\\frac{u^n + u^{n+1}}{2}\\right) = 0 \\implies \\left(M + \\frac{\\Delta t}{2} K\\right) u^{n+1} = \\left(M - \\frac{\\Delta t}{2} K\\right) u^n\n$$\nThis method is A-stable but not L-stable. For stiff components, the amplification factor approaches $-1$, leading to persistent, non-decaying oscillations.\n\n**Backward Differentiation Formula of Order 2 (BDF2)**\nThis is a second-order, two-step method. The derivative at $t_{n+1}$ is approximated using values at $t_{n+1}$, $t_n$, and $t_{n-1}$:\n$$\n\\dot{u}(t_{n+1}) \\approx \\frac{3u^{n+1} - 4u^n + u^{n-1}}{2\\Delta t}\n$$\nSubstituting this into the ODE system gives:\n$$\nM \\left(\\frac{3u^{n+1} - 4u^n + u^{n-1}}{2\\Delta t}\\right) + K u^{n+1} = 0 \\implies (3M + 2 \\Delta t K) u^{n+1} = 4M u^n - M u^{n-1}\n$$\nSince it is a two-step method, it requires a startup procedure to compute $u^1$ from $u^0$. As specified, a single step of the first-order Backward Euler method is used for this purpose. BDF2 is stiffly stable and L-stable, making it suitable for stiff problems.\n\n### 3. Numerical Experiments and Implementation\n\nThe provided problem specifies two numerical experiments to evaluate these integrators.\n\n**Accuracy Test**: The temporal order of accuracy is measured by comparing numerical solutions to a known exact semi-discrete solution. The initial condition is a linear combination of the first two generalized eigenvectors of the pencil $(K, M)$, $u(0) = c_1 v_1 + c_2 v_2$. The exact solution to $M\\dot{u} + Ku = 0$ is then $u(t) = c_1 e^{-\\lambda_1 t} v_1 + c_2 e^{-\\lambda_2 t} v_2$. By computing the error for two different time steps, $\\Delta t_\\text{coarse}$ and $\\Delta t_\\text{fine}$, the observed order of accuracy $p$ is estimated as $p = \\log(e_\\text{coarse}/e_\\text{fine}) / \\log(2)$.\n\n**Stiffness Handling Test**: This test assesses the numerical damping of the stiffest mode, which corresponds to the largest generalized eigenvalue $\\lambda_\\text{max}$. Starting with $u(0)=v_\\text{max}$, a single large time step $\\Delta t_\\text{stiff} = 50/\\lambda_\\text{max}$ is taken. The one-step amplification factor $r$ in the $M$-norm is computed, which quantifies the damping. For BDF2, a two-step procedure is followed as defined. The tendency of Crank-Nicolson to produce oscillations is checked by observing the sign of the modal coefficient of the solution.\n\nThe implementation will construct the matrices $M$ and $K$ and then perform these tests. The generalized eigenproblem $K v_i = \\lambda_i M v_i$ is solved using `scipy.linalg.eigh`. The time-stepping schemes involve solving linear systems at each step. For efficiency, the system matrix (e.g., $M + \\Delta t K$) is factorized once using LU decomposition before the time loop.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh, lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Constructs a 1D FEM model for the heat equation and evaluates three implicit time integrators.\n    \"\"\"\n\n    def assemble_matrices(Nel):\n        \"\"\"Assembles the consistent mass (M) and stiffness (K) matrices for 1D FEM.\"\"\"\n        N = Nel - 1\n        h = 1.0 / Nel\n\n        # Mass Matrix M = h/6 * tridiag(1, 4, 1)\n        diag_M = np.full(N, 4.0 * h / 6.0)\n        offdiag_M = np.full(N - 1, 1.0 * h / 6.0)\n        M = np.diag(diag_M) + np.diag(offdiag_M, k=1) + np.diag(offdiag_M, k=-1)\n\n        # Stiffness Matrix K = 1/h * tridiag(-1, 2, -1)\n        diag_K = np.full(N, 2.0 / h)\n        offdiag_K = np.full(N - 1, -1.0 / h)\n        K = np.diag(diag_K) + np.diag(offdiag_K, k=1) + np.diag(offdiag_K, k=-1)\n        \n        return M, K\n\n    def compute_m_norm(vec, M):\n        \"\"\"Computes the M-norm of a vector.\"\"\"\n        return np.sqrt(vec.T @ M @ vec)\n\n    # --- Part 1: Accuracy Test ---\n    def run_accuracy_test():\n        Nel = 50\n        T = 0.1\n        N_steps_coarse = 40\n        N_steps_fine = 80\n        dt_coarse = T / N_steps_coarse\n        dt_fine = T / N_steps_fine\n\n        M, K = assemble_matrices(Nel)\n        \n        # Solve generalized eigenproblem K v = lambda M v\n        # eigh returns M-orthonormal eigenvectors\n        eigenvalues, eigenvectors = eigh(K, M)\n        lambda1, lambda2 = eigenvalues[0:2]\n        v1, v2 = eigenvectors[:, 0], eigenvectors[:, 1]\n        \n        u0 = 1.0 * v1 + 0.5 * v2\n        u_exact_T = np.exp(-lambda1 * T) * v1 + 0.5 * np.exp(-lambda2 * T) * v2\n\n        errors = {}\n        for method in ['BE', 'CN', 'BDF2']:\n            errors[method] = []\n            for dt, num_steps in [(dt_coarse, N_steps_coarse), (dt_fine, N_steps_fine)]:\n                u = np.copy(u0)\n                \n                if method == 'BE':\n                    A_lu = lu_factor(M + dt * K)\n                    for _ in range(num_steps):\n                        rhs = M @ u\n                        u = lu_solve(A_lu, rhs)\n                \n                elif method == 'CN':\n                    A_lu = lu_factor(M + 0.5 * dt * K)\n                    B = M - 0.5 * dt * K\n                    for _ in range(num_steps):\n                        rhs = B @ u\n                        u = lu_solve(A_lu, rhs)\n                \n                elif method == 'BDF2':\n                    # Startup step with Backward Euler\n                    A_be_lu = lu_factor(M + dt * K)\n                    rhs_be = M @ u\n                    u_curr = lu_solve(A_be_lu, rhs_be)\n                    u_prev = np.copy(u0)\n\n                    # BDF2 steps\n                    A_bdf2_lu = lu_factor(3 * M + 2 * dt * K)\n                    for _ in range(1, num_steps):\n                        rhs = 4 * M @ u_curr - M @ u_prev\n                        u_next = lu_solve(A_bdf2_lu, rhs)\n                        u_prev = u_curr\n                        u_curr = u_next\n                    u = u_curr\n\n                error_vec = u - u_exact_T\n                err = np.sqrt(error_vec.T @ M @ error_vec)\n                errors[method].append(err)\n        \n        # Calculate observed order of accuracy p\n        p_be = np.log(errors['BE'][0] / errors['BE'][1]) / np.log(2)\n        p_cn = np.log(errors['CN'][0] / errors['CN'][1]) / np.log(2)\n        p_bdf2 = np.log(errors['BDF2'][0] / errors['BDF2'][1]) / np.log(2)\n\n        return p_be, p_cn, p_bdf2\n\n    # --- Part 2: Stiffness Handling Test ---\n    def run_stiffness_test():\n        Nel = 200\n        M, K = assemble_matrices(Nel)\n        \n        eigenvalues, eigenvectors = eigh(K, M)\n        lambda_max = eigenvalues[-1]\n        v_max = eigenvectors[:, -1]\n        \n        u0 = v_max\n        dt = 50.0 / lambda_max\n\n        norm_u0 = compute_m_norm(u0, M)\n        if not np.isclose(norm_u0, 1.0):\n             # This should not happen with eigh, but good practice to check\n             norm_u0 = 1.0 \n\n        # Backward Euler\n        A_be = M + dt * K\n        rhs_be = M @ u0\n        u1_be = np.linalg.solve(A_be, rhs_be)\n        r_be = compute_m_norm(u1_be, M) / norm_u0\n\n        # Crank-Nicolson\n        A_cn = M + 0.5 * dt * K\n        B_cn = M - 0.5 * dt * K\n        rhs_cn = B_cn @ u0\n        u1_cn = np.linalg.solve(A_cn, rhs_cn)\n        r_cn = compute_m_norm(u1_cn, M) / norm_u0\n        \n        c0 = v_max.T @ M @ u0 # This is v_max.T @ M @ v_max = 1\n        c1 = v_max.T @ M @ u1_cn\n        osc_cn = bool(c0 * c1  0)\n\n        # BDF2\n        # u1 is from the BE startup step\n        u1 = u1_be\n        # Second step is BDF2\n        A_bdf2 = 3 * M + 2 * dt * K\n        rhs_bdf2 = 4 * M @ u1 - M @ u0\n        u2_bdf2 = np.linalg.solve(A_bdf2, rhs_bdf2)\n        \n        r_bdf2 = compute_m_norm(u2_bdf2, M) / compute_m_norm(u1, M)\n\n        return r_be, r_cn, r_bdf2, osc_cn\n\n    # --- Run tests and aggregate results ---\n    p_be, p_cn, p_bdf2 = run_accuracy_test()\n    r_be, r_cn, r_bdf2, osc_cn = run_stiffness_test()\n\n    results = [\n        round(p_be, 3),\n        round(p_cn, 3),\n        round(p_bdf2, 3),\n        round(r_be, 6),\n        round(r_cn, 6),\n        round(r_bdf2, 6),\n        osc_cn\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129641"}]}