{"hands_on_practices": [{"introduction": "This first exercise gets to the heart of why careful numerical flux design is crucial for problems involving transport, or advection. We will compare a simple, intuitive central flux with the physically-motivated upwind flux for the linear advection equation, $u_t + a u_x = 0$. Through this practical example, you will discover how an unstable scheme can create non-physical results, while a well-designed upwind scheme provides stable and meaningful solutions, illustrating the core concepts of numerical stability and dissipation. [@problem_id:3130164]", "problem": "You are asked to construct, verify, and programmatically demonstrate a counterexample in the context of the finite volume method for a linear conservation law. Consider the scalar linear advection equation $u_t + a u_x = 0$ on a one-dimensional periodic domain, with a uniform grid of $N$ cells. Let $\\bar{u}_i^n$ denote the cell average in cell $i$ at time $t^n$. The finite volume update for one explicit forward Euler time step with time step $\\Delta t$ and spatial mesh size $\\Delta x$ is derived by integrating the conservation law over each control volume and approximating the physical flux by a chosen numerical flux. Denote the numerical flux at the interface between cells $i$ and $i+1$ by $F_{i+\\frac{1}{2}}^n$. The update is\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\nwith periodic boundary conditions. Define the discrete entropy\n$$\nE^n = \\sum_{i=0}^{N-1} \\left|\\bar{u}_i^n\\right|.\n$$\nTwo numerical fluxes are to be considered:\n- The central flux: $F_{i+\\frac{1}{2}}^n = a \\,\\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2}$.\n- The upwind flux: $F_{i+\\frac{1}{2}}^n = a\\,\\bar{u}_i^n$ if $a > 0$, and $F_{i+\\frac{1}{2}}^n = a\\,\\bar{u}_{i+1}^n$ if $a < 0$; if $a = 0$ then $F_{i+\\frac{1}{2}}^n = 0$.\n\nYour task is to implement a program that, for each test case in the suite below, performs a single forward Euler time step using both the central flux and the upwind flux with periodic boundary conditions, computes $E^n$ and $E^{n+1}$ for each flux, and reports two booleans per test case:\n- A boolean indicating whether the central flux violates discrete entropy monotonicity, defined as $E^{n+1} > E^n$ for the central flux.\n- A boolean indicating whether the upwind flux violates discrete entropy monotonicity, defined as $E^{n+1} > E^n$ for the upwind flux.\n\nThe Courant–Friedrichs–Lewy (CFL) number is $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$. Use the following test suite, each specified by $(N, a, \\Delta x, \\Delta t, \\text{initial data})$, where the initial data is the list of $\\bar{u}_i^0$ for $i = 0,1,\\ldots,N-1$:\n1. $N = 4$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.9$, initial data $[1,0,0,0]$.\n2. $N = 4$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 1.0$, initial data $[1,0,0,0]$.\n3. $N = 4$, $a = -1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.7$, initial data $[0,0,0,1]$.\n4. $N = 4$, $a = 0.0$, $\\Delta x = 1.0$, $\\Delta t = 0.5$, initial data $[-2,1,0,3]$.\n5. $N = 5$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.6$, initial data $[0,1,-1,0,0]$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case yields a two-boolean list without spaces for that test case. For example, the final output should look like\n[[True,False],[True,False],[True,False],[False,False],[True,False]].", "solution": "The problem requires a computational verification of the discrete entropy monotonicity property for two different numerical flux functions within a finite volume framework for the scalar linear advection equation, $u_t + a u_x = 0$. The analysis is performed over a single time step on a one-dimensional periodic domain.\n\nThe finite volume method is based on the integral form of the conservation law. Integrating $u_t + f(u)_x=0$, where $f(u)=au$ is the flux, over a control volume $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ of width $\\Delta x$ and a time interval $[t^n, t^{n+1}]$ of duration $\\Delta t$ yields an exact relation for the cell average $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{C_i} u(x,t) dx$:\n$$\n\\bar{u}_i(t^{n+1}) = \\bar{u}_i(t^n) - \\frac{1}{\\Delta x} \\int_{t^n}^{t^{n+1}} \\left( f(u(x_{i+\\frac{1}{2}},t)) - f(u(x_{i-\\frac{1}{2}},t)) \\right) dt\n$$\nApplying a first-order forward Euler time integration and approximating the exact flux $f(u)$ at the cell interfaces by a numerical flux function $F$, we arrive at the semi-discrete finite volume scheme provided in the problem statement:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\nwhere $\\bar{u}_i^n \\approx \\bar{u}_i(t^n)$ and $F_{i\\pm\\frac{1}{2}}^n$ is the numerical flux, which depends on the cell average values in the vicinity of the interface. The Courant–Friedrichs–Lewy (CFL) number is defined as the dimensionless ratio $\\nu = \\frac{a \\Delta t}{\\Delta x}$. We investigate two definitions for the numerical flux, $F$.\n\nThe discrete entropy is defined as the discrete $L^1$-norm of the solution vector, $E^n = \\sum_{i=0}^{N-1} |\\bar{u}_i^n|$. The problem asks to check for entropy violation, defined as the condition $E^{n+1} > E^n$.\n\n**1. Central Flux Scheme**\n\nThe central flux at the interface $x_{i+\\frac{1}{2}}$ is defined as the arithmetic mean of the flux values corresponding to the states in the adjacent cells, $i$ and $i+1$:\n$$\nF_{i+\\frac{1}{2}}^n = a \\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2}\n$$\nSubstituting this into the general finite volume update equation gives:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a \\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2} - a \\frac{\\bar{u}_{i-1}^n + \\bar{u}_i^n}{2} \\right)\n$$\nThis expression simplifies to the update rule for the central scheme:\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{a \\Delta t}{2 \\Delta x} (\\bar{u}_{i+1}^n - \\bar{u}_{i-1}^n) = \\bar{u}_i^n - \\frac{\\nu}{2} (\\bar{u}_{i+1}^n - \\bar{u}_{i-1}^n)\n$$\nThis scheme is equivalent to the forward-time, centered-space (FTCS) finite difference method. It is a well-established result in numerical analysis that the FTCS scheme is unconditionally unstable for purely hyperbolic equations like the linear advection equation. This instability leads to the generation and amplification of spurious oscillations, which causes the discrete $L^1$-norm (our entropy $E^n$) to grow. We therefore anticipate that this scheme will violate the entropy monotonicity condition, i.e., $E^{n+1} > E^n$, for non-trivial initial data.\n\n**2. Upwind Flux Scheme**\n\nThe upwind flux is constructed based on the direction of information propagation, which is determined by the sign of the advection speed $a$.\n\n- If $a > 0$, the wave propagates from left to right. The flux at interface $x_{i+\\frac{1}{2}}$ is determined by the \"upwind\" state in cell $i$:\n  $$\n  F_{i+\\frac{1}{2}}^n = a \\bar{u}_i^n\n  $$\n  The update rule becomes:\n  $$\n  \\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{u}_i^n - a \\bar{u}_{i-1}^n) = (1-\\nu)\\bar{u}_i^n + \\nu\\bar{u}_{i-1}^n\n  $$\n\n- If $a < 0$, the wave propagates from right to left. The flux at interface $x_{i+\\frac{1}{2}}$ is determined by the \"upwind\" state in cell $i+1$:\n  $$\n  F_{i+\\frac{1}{2}}^n = a \\bar{u}_{i+1}^n\n  $$\n  The update rule becomes:\n  $$\n  \\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{u}_{i+1}^n - a \\bar{u}_i^n) = \\bar{u}_i^n - \\nu (\\bar{u}_{i+1}^n - \\bar{u}_i^n) = (1+\\nu)\\bar{u}_i^n - \\nu\\bar{u}_{i+1}^n\n  $$\n\n- If $a = 0$, the flux is zero, $F_{i+\\frac{1}{2}}^n = 0$, and the solution is stationary, $\\bar{u}_i^{n+1} = \\bar{u}_i^n$.\n\nThe first-order upwind scheme is conditionally stable. The stability condition is the CFL condition, $0 \\le |\\nu| \\le 1$. All test cases provided in the problem satisfy this condition. When $0 \\le \\nu \\le 1$ ($a>0$) or $-1 \\le \\nu \\le 0$ ($a<0$), the update for $\\bar{u}_i^{n+1}$ is a convex combination of the values $\\bar{u}_j^n$ from the previous time step. This is because the coefficients are non-negative and sum to $1$. A key result by Harten states that schemes which can be written as a convex combination are Total Variation Diminishing (TVD). TVD schemes have the property of being $L^1$-contractive, which implies that the discrete $L^1$-norm cannot increase: $E^{n+1} \\leq E^n$. Therefore, we expect the upwind scheme to satisfy discrete entropy monotonicity for all provided test cases.\n\n**Computational Implementation**\n\nThe programmatic solution implements these steps for each test case.\n1.  The initial cell averages $\\bar{u}^0$ are stored in a NumPy array.\n2.  The initial entropy $E^0 = \\sum_{i=0}^{N-1} |\\bar{u}_i^0|$ is computed.\n3.  The CFL number $\\nu$ is calculated.\n4.  For both schemes, the updated solution $\\bar{u}^1$ is computed using vectorized operations. Periodic boundary conditions are implemented using `numpy.roll` to access neighboring elements $\\bar{u}_{i-1}^0$ and $\\bar{u}_{i+1}^0$.\n5.  The final entropies, $E^1_{\\text{central}}$ and $E^1_{\\text{upwind}}$, are calculated by summing the absolute values of the elements in the updated solution arrays.\n6.  For each scheme, the final entropy is compared to the initial entropy to determine if the violation condition $E^{n+1} > E^n$ is met. The results are stored as a pair of booleans.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the finite volume problem for a series of test cases.\n\n    For each case, it performs a single forward Euler time step for the 1D\n    linear advection equation using both central and upwind numerical fluxes.\n    It then checks if the discrete L1-norm (entropy) has increased for\n    each scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a, dx, dt, initial_data_list)\n        (4, 1.0, 1.0, 0.9, [1, 0, 0, 0]),\n        (4, 1.0, 1.0, 1.0, [1, 0, 0, 0]),\n        (4, -1.0, 1.0, 0.7, [0, 0, 0, 1]),\n        (4, 0.0, 1.0, 0.5, [-2, 1, 0, 3]),\n        (5, 1.0, 1.0, 0.6, [0, 1, -1, 0, 0]),\n    ]\n\n    final_results = []\n    TOL = 1e-12 # A small tolerance for floating point comparisons\n\n    for case in test_cases:\n        N, a, dx, dt, u0_list = case\n        u0 = np.array(u0_list, dtype=float)\n\n        # Calculate initial discrete entropy (L1-norm)\n        E0 = np.sum(np.abs(u0))\n\n        # Calculate the CFL number\n        nu = a * dt / dx\n\n        # --- Central Flux Scheme ---\n        # Update rule: u_i^{n+1} = u_i^n - (nu/2) * (u_{i+1}^n - u_{i-1}^n)\n        u_prev_c = np.roll(u0, 1)   # u_{i-1}\n        u_next_c = np.roll(u0, -1)  # u_{i+1}\n        u1_central = u0 - (nu / 2.0) * (u_next_c - u_prev_c)\n        \n        # Calculate final entropy for the central scheme\n        E1_central = np.sum(np.abs(u1_central))\n        \n        # Check for entropy violation\n        central_violates = (E1_central - E0) > TOL\n\n        # --- Upwind Flux Scheme ---\n        if a > 0:\n            # Update rule: u_i^{n+1} = (1-nu)*u_i^n + nu*u_{i-1}^n\n            u_prev_u = np.roll(u0, 1)  # u_{i-1}\n            u1_upwind = u0 - nu * (u0 - u_prev_u)\n        elif a  0:\n            # Update rule: u_i^{n+1} = (1+nu)*u_i^n - nu*u_{i+1}^n\n            u_next_u = np.roll(u0, -1)  # u_{i+1}\n            u1_upwind = u0 - nu * (u_next_u - u0)\n        else:  # a == 0\n            # Update rule: u_i^{n+1} = u_i^n\n            u1_upwind = np.copy(u0)\n            \n        # Calculate final entropy for the upwind scheme\n        E1_upwind = np.sum(np.abs(u1_upwind))\n        \n        # Check for entropy violation\n        upwind_violates = (E1_upwind - E0) > TOL\n        \n        final_results.append([central_violates, upwind_violates])\n\n    # Format the final output string as specified in the problem statement.\n    # e.g., [[True,False],[True,False],...]\n    case_results_str = [f\"[{res[0]},{res[1]}]\" for res in final_results]\n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```", "id": "3130164"}, {"introduction": "The cornerstone of the Finite Volume Method is its inherent ability to conserve quantities like mass and energy perfectly at the discrete level. This practice challenges you to implement a robust implicit solver for a diffusion equation, a model for processes like heat conduction or molecular transport. You will tackle practical complexities such as non-uniform meshes and variable material properties, ultimately verifying that your numerical scheme conserves the total quantity to machine precision, demonstrating the power and reliability of the FVM framework. [@problem_id:3130123]", "problem": "Consider the one-dimensional diffusion equation in conservation form on the domain $[0,1]$:\n$$\nu_t = (k(x)\\,u_x)_x,\n$$\nwhere $u(x,t)$ is the scalar field and $k(x) \\gt 0$ is a given, sufficiently smooth diffusivity field. Let a cell-centered Finite Volume Method (FVM) be used on a general nonuniform mesh with $N$ cells. Denote cell interfaces by $\\{x_{i-\\tfrac{1}{2}}\\}_{i=1}^{N+1}$ with $x_{\\tfrac{1}{2}} = 0$ and $x_{N+\\tfrac{1}{2}} = 1$, cell centers by $x_i = \\tfrac{1}{2}(x_{i-\\tfrac{1}{2}}+x_{i+\\tfrac{1}{2}})$, and cell widths by $\\Delta x_i = x_{i+\\tfrac{1}{2}}-x_{i-\\tfrac{1}{2}}$. Let the cell average be $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{x_{i-\\tfrac{1}{2}}}^{x_{i+\\tfrac{1}{2}}} u(x,t)\\,dx$. Define the discrete total mass by\n$$\nM(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i.\n$$\n\nStarting only from the integral balance over each control volume and the Divergence (Gauss) theorem, derive a conservative semi-discrete FVM for the cells $\\{C_i\\}_{i=1}^N$ of the form\n$$\n\\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = F_{i-\\tfrac{1}{2}} - F_{i+\\tfrac{1}{2}},\n$$\nwhere $F_{i\\pm\\tfrac{1}{2}}$ are consistent numerical approximations to the physical diffusive fluxes at interfaces. Then discretize in time using the first-order Implicit (Backward) Euler method with time step $\\Delta t \\gt 0$ to obtain a linear system at each time step for $\\{\\bar{u}_i^{n+1}\\}_{i=1}^N$. Use a two-point flux approximation at each internal interface that depends only on adjacent cells and the distances from centers to the interface, and approximates the flux gradient over the distance between adjacent cell centers. For heterogeneous diffusivity, use a face coefficient that is consistent with series resistors in one dimension.\n\nImpose either homogeneous Neumann boundary conditions (zero flux at $x=0$ and $x=1$) or periodic boundary conditions (fluxes through $x=0$ and $x=1$ cancel through identification of the end cells). In all cases below where homogeneous Neumann is specified, require that the boundary fluxes be exactly zero in the discrete sense. For periodic boundary conditions, couple the first and last cells through the boundary.\n\nUse the following initial condition for all test cases, specified via exact cell averages:\n$$\nu(x,0) = 1 + \\sin(2\\pi x),\n$$\nso that for each cell $i$ with edges $a = x_{i-\\tfrac{1}{2}}$ and $b = x_{i+\\tfrac{1}{2}}$,\n$$\n\\bar{u}_i(0) = 1 + \\frac{1}{b-a}\\int_a^b \\sin(2\\pi x)\\,dx = 1 + \\frac{-\\cos(2\\pi b) + \\cos(2\\pi a)}{2\\pi (b-a)}.\n$$\nThe domain length is $1$, so the exact continuous mass at $t=0$ equals $1$. Compute the discrete mass $M(0)$ from the cell averages and widths.\n\nImplement the fully implicit FVM time stepping and test whether the discrete total mass $M(t)$ is conserved under Implicit Euler for the following test suite. For each test, advance the solution by $n_{\\text{steps}}$ steps of size $\\Delta t$ and compare $M(n_{\\text{steps}}\\Delta t)$ against $M(0)$.\n\n- Test $1$ (happy path): $N=50$, uniform mesh with $\\Delta x_i = 1/N$, homogeneous Neumann boundary conditions, constant diffusivity $k(x) \\equiv 1$, $\\Delta t = 0.1$, $n_{\\text{steps}} = 5$.\n- Test $2$ (nonuniform and heterogeneous): $N=37$, nonuniform mesh with widths proportional to $1 + 0.6\\sin(2\\pi \\tfrac{i-0.5}{N})$ for $i=1,\\dots,N$ and then normalized so that $\\sum_i \\Delta x_i = 1$, homogeneous Neumann boundary conditions, heterogeneous diffusivity $k(x) = 1 + 0.4 x$, $\\Delta t = 0.05$, $n_{\\text{steps}} = 10$.\n- Test $3$ (periodic, strongly graded mesh): $N=41$, nonuniform mesh with geometric progression $\\Delta x_i \\propto r^{i-1}$ for $i=1,\\dots,N$ with $r=1.3$, normalized so that $\\sum_i \\Delta x_i = 1$, periodic boundary conditions, heterogeneous diffusivity $k(x) = 2 + 0.5\\cos(2\\pi x)$, $\\Delta t = 0.05$, $n_{\\text{steps}} = 7$.\n\nYour program must:\n- Construct the meshes explicitly from the specified $\\Delta x_i$ so that $\\sum_i \\Delta x_i = 1$, assemble the conservative FVM linear system using the two-point flux across adjacent cell centers for internal interfaces, enforce the specified boundary conditions, and advance with Implicit Euler.\n- Compute the discrete total mass $M(0)$ and $M(n_{\\text{steps}}\\Delta t)$ for each test.\n- For each test, decide a boolean outcome: return True if $\\left|M(n_{\\text{steps}}\\Delta t) - M(0)\\right| \\le 10^{-12}$, and False otherwise.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of the three boolean outcomes enclosed in square brackets (e.g., [True,False,True]). No additional text should be printed. No physical units are required because the problem is dimensionless. Angles do not appear. All numeric values in the program should be treated as dimensionless scalars.", "solution": "The problem requires the derivation and implementation of a cell-centered finite volume method (FVM) for the one-dimensional diffusion equation, followed by a test of its mass conservation property under different conditions.\n\n### 1. Finite Volume Formulation\nThe governing partial differential equation (PDE) is given in conservation form:\n$$ u_t = (k(x)\\,u_x)_x $$\nWe apply the finite volume method by integrating this equation over a control volume $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$:\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx $$\nThe left-hand side (LHS), using the definition of the cell average $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{C_i} u(x,t)\\,dx$ and the Leibniz integral rule, becomes:\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx = \\frac{d}{dt}\\left(\\bar{u}_i(t) \\Delta x_i\\right) $$\nThe right-hand side (RHS) is integrated using the Fundamental Theorem of Calculus (the 1D version of the Divergence Theorem):\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx = \\left[ k(x)u_x \\right]_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} = (k u_x)\\Big|_{x_{i+\\frac{1}{2}}} - (k u_x)\\Big|_{x_{i-\\frac{1}{2}}} $$\nLet $G(x,t) = k(x)u_x$ be the physical diffusive flux. The exact balance equation for cell $i$ is:\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G(x_{i+\\frac{1}{2}}, t) - G(x_{i-\\frac{1}{2}}, t) $$\nThis equation is then semi-discretized by approximating the fluxes $G$ at the cell interfaces (faces) with numerical fluxes, denoted $G_{i\\pm\\frac{1}{2}}$, which are functions of the cell-average values $\\bar{u}_j$. This yields the semi-discrete FVM system:\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}} $$\nNote that the problem statement uses $F$ for numerical flux but defines it with a sign convention that differs from the direct result of the integration. To avoid ambiguity, we use $G$ as defined here. The key is the conservative \"flux-in minus flux-out\" structure which, after rearrangement to match the problem's form, yields the same underlying stencil.\n\n### 2. Numerical Flux Approximation\nThe flux $G_{i+\\frac{1}{2}}$ at the interface between cells $i$ and $i+1$ is approximated using a two-point stencil involving $\\bar{u}_i$ and $\\bar{u}_{i+1}$. The derivative $u_x$ at the interface is approximated by a finite difference between the cell centers $x_i$ and $x_{i+1}$:\n$$ G_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{x_{i+1} - x_i} $$\nwhere $k_{i+\\frac{1}{2}}$ is an effective diffusivity at the interface. As specified, for heterogeneous media, this is chosen to be consistent with resistors in series. The \"resistance\" to diffusion over a segment of length $L$ with diffusivity $k$ is $L/k$. The total resistance between cell centers $x_i$ and $x_{i+1}$ is the sum of resistances from $x_i$ to $x_{i+\\frac{1}{2}}$ and from $x_{i+\\frac{1}{2}}$ to $x_{i+1}$. This leads to a harmonic average for the effective conductivity $k_{i+\\frac{1}{2}} / (x_{i+1}-x_i) $:\n$$ \\frac{1}{\\text{Total Resistance}} = \\frac{1}{\\frac{x_{i+1}-x_i}{k_{i+\\frac{1}{2}}}} = \\frac{1}{\\frac{x_{i+\\frac{1}{2}}-x_i}{k(x_i)} + \\frac{x_{i+1}-x_{i+\\frac{1}{2}}}{k(x_{i+1})}} $$\nWith $x_i = \\frac{1}{2}(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}})$ and $\\Delta x_i = x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}$, we have $x_{i+1}-x_i = \\frac{1}{2}(\\Delta x_i + \\Delta x_{i+1})$, $x_{i+\\frac{1}{2}}-x_i = \\frac{1}{2}\\Delta x_i$, and $x_{i+1}-x_{i+\\frac{1}{2}} = \\frac{1}{2}\\Delta x_{i+1}$. The flux coefficient for the term $(\\bar{u}_{i+1} - \\bar{u}_i)$ is then:\n$$ \\beta_{i+\\frac{1}{2}} = \\frac{k_{i+\\frac{1}{2}}}{x_{i+1} - x_i} = \\frac{1}{\\frac{\\frac{1}{2}\\Delta x_i}{k(x_i)} + \\frac{\\frac{1}{2}\\Delta x_{i+1}}{k(x_{i+1})}} = \\frac{2}{\\frac{\\Delta x_i}{k(x_i)} + \\frac{\\Delta x_{i+1}}{k(x_{i+1})}} $$\nThe numerical flux is $G_{i+\\frac{1}{2}} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i)$. The semi-discrete equation for an internal cell $i$ is:\n$$ \\Delta x_i \\frac{d\\bar{u}_i}{dt} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i - \\bar{u}_{i-1}) $$\n\n### 3. Implicit Time Discretization\nUsing the first-order Implicit (Backward) Euler method, we approximate $\\frac{d\\bar{u}_i}{dt} \\approx \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t}$ and evaluate the spatial terms at the new time level $n+1$:\n$$ \\Delta x_i \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1}^{n+1} - \\bar{u}_i^{n+1}) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i^{n+1} - \\bar{u}_{i-1}^{n+1}) $$\nRearranging the terms yields a linear system for the unknown vector $\\mathbf{u}^{n+1} = [\\bar{u}_1^{n+1}, \\dots, \\bar{u}_N^{n+1}]^T$:\n$$ -\\frac{\\Delta t}{\\Delta x_i}\\beta_{i-\\frac{1}{2}}\\bar{u}_{i-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_i}(\\beta_{i-\\frac{1}{2}} + \\beta_{i+\\frac{1}{2}})\\right)\\bar{u}_i^{n+1} - \\frac{\\Delta t}{\\Delta x_i}\\beta_{i+\\frac{1}{2}}\\bar{u}_{i+1}^{n+1} = \\bar{u}_i^n $$\nThis equation defines the $i$-th row of a linear system $A\\mathbf{u}^{n+1} = \\mathbf{u}^n$. The matrix $A$ is tridiagonal for internal cells.\n\n### 4. Boundary Conditions\n**Homogeneous Neumann**: The boundary fluxes are zero, $G_{\\frac{1}{2}} = G_{N+\\frac{1}{2}} = 0$.\nFor cell $i=1$: $\\Delta x_1 \\frac{d\\bar{u}_1}{dt} = G_{\\frac{3}{2}} - G_{\\frac{1}{2}} = G_{\\frac{3}{2}}$. The first row of the system becomes:\n$$ \\left(1 + \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\nFor cell $i=N$: $\\Delta x_N \\frac{d\\bar{u}_N}{dt} = G_{N+\\frac{1}{2}} - G_{N-\\frac{1}{2}} = -G_{N-\\frac{1}{2}}$. The last row becomes:\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\nThe resulting system matrix $A$ is tridiagonal.\n\n**Periodic**: Cells $1$ and $N$ are adjacent. We identify $\\bar{u}_0 \\equiv \\bar{u}_N$ and $\\bar{u}_{N+1} \\equiv \\bar{u}_1$.\nFor cell $i=1$: $G_{\\frac{1}{2}} = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$. The first row includes a term for $\\bar{u}_N$:\n$$ -\\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{1}{2}}\\bar{u}_N^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_1}(\\beta_{\\frac{1}{2}} + \\beta_{\\frac{3}{2}})\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\nFor cell $i=N$: $G_{N+\\frac{1}{2}} = \\beta_{N+\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N) = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$. The last row includes a term for $\\bar{u}_1$:\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{\\frac{1}{2}}\\bar{u}_1^{n+1} -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}(\\beta_{N-\\frac{1}{2}} + \\beta_{\\frac{1}{2}})\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\nThe matrix $A$ is cyclic tridiagonal.\n\n### 5. Mass Conservation\nThe discrete total mass is $M(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i$. Taking the time derivative of the semi-discrete system and summing over all cells:\n$$ \\frac{dM}{dt} = \\sum_{i=1}^N \\frac{d}{dt}(\\bar{u}_i \\Delta x_i) = \\sum_{i=1}^N (G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}}) $$\nThis is a telescoping sum which evaluates to $G_{N+\\frac{1}{2}} - G_{\\frac{1}{2}}$, the net flux across the domain boundaries.\n- For homogeneous Neumann BCs, $G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}} = 0$, so $\\frac{dM}{dt} = 0$.\n- For periodic BCs, the domain has no boundaries, and $G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}}$ represents the same internal flux, so their difference is zero, and $\\frac{dM}{dt} = 0$.\n\nThis property of the semi-discretization carries over to the fully discrete Implicit Euler scheme. Summing the fully discrete equations over all $i$:\n$$ \\sum_{i=1}^N \\Delta x_i (\\bar{u}_i^{n+1} - \\bar{u}_i^n) = \\Delta t \\sum_{i=1}^N (G_{i+\\frac{1}{2}}^{n+1} - G_{i-\\frac{1}{2}}^{n+1}) $$\n$$ M^{n+1} - M^n = \\Delta t (G_{N+\\frac{1}{2}}^{n+1} - G_{\\frac{1}{2}}^{n+1}) $$\nFor both Neumann and periodic boundary conditions, the RHS is zero. Thus, $M^{n+1} = M^n$. The implemented scheme is exactly mass-conservative. Any deviation in the computed result will be solely due to floating-point arithmetic errors. Given the tolerance of $10^{-12}$, we expect the tests to pass.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the FVM simulation for all test cases.\n    \"\"\"\n\n    def run_one_case(N, mesh_type, bc_type, k_func, dt, n_steps):\n        \"\"\"\n        Sets up and runs a single test case for the FVM simulation.\n        \"\"\"\n        # 1. Mesh Generation\n        if mesh_type == 'uniform':\n            dx_unnormalized = np.ones(N)\n        elif mesh_type == 'proportional':\n            i_vals = np.arange(1, N + 1)\n            dx_unnormalized = 1.0 + 0.6 * np.sin(2.0 * np.pi * (i_vals - 0.5) / N)\n        elif mesh_type == 'geometric':\n            r = 1.3\n            i_vals = np.arange(N)\n            dx_unnormalized = r**i_vals\n        else:\n            raise ValueError(\"Unknown mesh type\")\n\n        # Normalize dx so that the domain length is 1\n        dx = dx_unnormalized / np.sum(dx_unnormalized)\n\n        # Calculate interface and center positions\n        x_interfaces = np.zeros(N + 1)\n        x_interfaces[1:] = np.cumsum(dx)\n        x_centers = 0.5 * (x_interfaces[:-1] + x_interfaces[1:])\n\n        # 2. Initial Condition\n        a = x_interfaces[:-1]\n        b = x_interfaces[1:]\n        # Use a small tolerance for the denominator to avoid division by zero\n        # This is not strictly necessary due to how the mesh is created, but is good practice.\n        den = 2.0 * np.pi * (b - a)\n        # For cases where a and b are very close, the fraction approaches 0\n        safe_den = np.where(np.abs(den)  1e-15, 1, den)\n        num = -np.cos(2.0 * np.pi * b) + np.cos(2.0 * np.pi * a)\n        frac = np.where(np.abs(den)  1e-15, 0, num / safe_den)\n        u_initial = 1.0 + frac\n\n        # 3. Initial Mass\n        mass_initial = np.dot(u_initial, dx)\n\n        # 4. Time Stepping\n        u_current = np.copy(u_initial)\n        k_vals = k_func(x_centers)\n\n        for _ in range(n_steps):\n            A = np.zeros((N, N))\n            b_vec = u_current\n\n            # 5. Assemble matrix A\n            # Internal cells (i in 1..N-2)\n            for i in range(1, N - 1):\n                beta_left = 2.0 / (dx[i - 1] / k_vals[i - 1] + dx[i] / k_vals[i])\n                beta_right = 2.0 / (dx[i] / k_vals[i] + dx[i + 1] / k_vals[i + 1])\n                c_i = dt / dx[i]\n                A[i, i - 1] = -c_i * beta_left\n                A[i, i] = 1.0 + c_i * (beta_left + beta_right)\n                A[i, i + 1] = -c_i * beta_right\n\n            # Boundary Conditions\n            if bc_type == 'neumann':\n                # First row (i=0)\n                beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                c_0 = dt / dx[0]\n                A[0, 0] = 1.0 + c_0 * beta_right_0\n                A[0, 1] = -c_0 * beta_right_0\n                # Last row (i=N-1)\n                beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                c_N = dt / dx[N - 1]\n                A[N - 1, N - 2] = -c_N * beta_left_N\n                A[N - 1, N - 1] = 1.0 + c_N * beta_left_N\n            elif bc_type == 'periodic':\n                beta_periodic = 2.0 / (dx[N - 1] / k_vals[N - 1] + dx[0] / k_vals[0])\n                # First row (i=0)\n                beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                c_0 = dt / dx[0]\n                A[0, 0] = 1.0 + c_0 * (beta_periodic + beta_right_0)\n                A[0, 1] = -c_0 * beta_right_0\n                A[0, N - 1] = -c_0 * beta_periodic\n                # Last row (i=N-1)\n                beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                c_N = dt / dx[N - 1]\n                A[N - 1, N - 1] = 1.0 + c_N * (beta_left_N + beta_periodic)\n                A[N - 1, N - 2] = -c_N * beta_left_N\n                A[N - 1, 0] = -c_N * beta_periodic\n            \n            # 6. Solve the linear system\n            u_next = linalg.solve(A, b_vec)\n            u_current = u_next\n\n        # 7. Final Mass and comparison\n        mass_final = np.dot(u_current, dx)\n\n        return np.abs(mass_final - mass_initial) = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (50, 'uniform', 'neumann', lambda x: np.ones_like(x), 0.1, 5),\n        # Test 2\n        (37, 'proportional', 'neumann', lambda x: 1.0 + 0.4 * x, 0.05, 10),\n        # Test 3\n        (41, 'geometric', 'periodic', lambda x: 2.0 + 0.5 * np.cos(2.0 * np.pi * x), 0.05, 7),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, mesh_t, bc_t, k_f, dt, n_s = params\n        result = run_one_case(N, mesh_t, bc_t, k_f, dt, n_s)\n        results.append(result)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3130123"}, {"introduction": "Many real-world systems involve multiple physical processes happening simultaneously, such as transport and chemical reactions. This exercise introduces a powerful technique called operator splitting to simulate an advection-reaction system where chemical species are both carried by a flow and transformed into one another. You will build a solver that handles each process separately and then verify that the total amount of all species remains constant, showcasing FVM's flexibility for tackling complex, multi-physics problems. [@problem_id:3130189]", "problem": "A one-dimensional advection–reaction system models two chemical species, labeled $A$ and $B$, that reversibly react and are transported by a uniform flow. Let the spatial domain be periodic on the interval $[0,L]$ with $L$ a positive number, and let time $t \\ge 0$. The concentrations $c_A(x,t)$ and $c_B(x,t)$ are nonnegative and dimensionless. The reversible reaction is $A \\leftrightarrow B$ with forward rate $k_1$ (units: inverse time) and backward rate $k_2$ (units: inverse time), and advection velocity $u$ (units: length per time) is constant. The foundational base is the integral conservation law over any control volume $V$ of width $\\Delta x$, which states that the rate of change of the amount of a species in the control volume equals the net advective flux across its boundary plus the net production by reactions inside:\n$$\n\\frac{d}{dt}\\int_{V} c_A(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_A\\right)\\cdot n \\, dS + \\int_{V} \\left(-k_1 c_A + k_2 c_B\\right)\\, dx,\n$$\n$$\n\\frac{d}{dt}\\int_{V} c_B(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_B\\right)\\cdot n \\, dS + \\int_{V} \\left(k_1 c_A - k_2 c_B\\right)\\, dx.\n$$\nThe total concentration $c_T(x,t) \\equiv c_A(x,t) + c_B(x,t)$ is expected to be conserved by the reaction locally, because the reaction transfers between species without net creation or destruction, and globally conserved by advection under periodic boundaries when a finite volume discretization is used.\n\nYour task is to derive from first principles a conservative finite volume method for this system on a uniform mesh with $N$ cells of width $\\Delta x = L/N$, using first-order upwind numerical flux for advection and an exact local update for the reversible reaction obtained by solving the linear ordinary differential equation (ODE) system in each cell. Specifically:\n- Start from the integral conservation law and state how a finite volume method approximates the time evolution of cell-averaged concentrations by balancing numerical fluxes across cell interfaces and local source terms.\n- Use a constant advection velocity $u$ and periodic boundary conditions to construct a conservative, first-order upwind flux at each interface, ensuring that the discrete advection update preserves the global sum of $c_A + c_B$ exactly up to floating-point rounding.\n- For the reaction terms, derive the exact solution for the local ODE system in each cell over a time step $\\Delta t$, and use it to update $c_A$ and $c_B$ without introducing reaction-related mass error.\n- Implement the complete algorithm in code, using a splitting approach that performs an advection update followed by a reaction update in each time step, and choose $\\Delta t$ from a Courant-Friedrichs-Lewy (CFL) condition to maintain explicit advection stability. When $|u| = 0$, you may choose any $\\Delta t$ since advection imposes no restriction.\n- Assume dimensionless variables for concentrations and domain length, and specify that time and rates are also dimensionless.\n\nInitial conditions are cell-centered and identical across tests, given by smooth functions:\n$$\nc_A(x,0) = 1 + 0.5 \\sin\\!\\left(\\frac{2\\pi x}{L}\\right), \\quad c_B(x,0) = 0.5 + 0.25 \\cos\\!\\left(\\frac{2\\pi x}{L}\\right).\n$$\nThese are dimensionless and strictly nonnegative for all $x$.\n\nDefine the following test suite of parameter sets, all with periodic boundaries:\n- Test $1$ (general reversible reaction with positive advection): $N = 200$, $L = 1$, $u = 1$, $k_1 = 1$, $k_2 = 1$, final time $T = 0.5$.\n- Test $2$ (pure advection, no reaction, negative velocity): $N = 200$, $L = 1$, $u = -0.7$, $k_1 = 0$, $k_2 = 0$, final time $T = 0.5$.\n- Test $3$ (stiff reversible reaction with moderate advection): $N = 200$, $L = 1$, $u = 0.3$, $k_1 = 50$, $k_2 = 20$, final time $T = 0.2$.\n- Test $4$ (pure reaction, zero advection): $N = 200$, $L = 1$, $u = 0$, $k_1 = 3$, $k_2 = 2$, final time $T = 1$.\n\nFor each test, compute the absolute relative change in total mass of $c_A + c_B$ between $t = 0$ and $t = T$:\n$$\n\\varepsilon = \\frac{\\left|\\int_{0}^{L} \\left(c_A(x,T) + c_B(x,T)\\right)\\, dx - \\int_{0}^{L} \\left(c_A(x,0) + c_B(x,0)\\right)\\, dx \\right|}{\\int_{0}^{L} \\left(c_A(x,0) + c_B(x,0)\\right)\\, dx}.\n$$\nAll integrals are to be approximated by the sum over cell averages times $\\Delta x$, consistent with the finite volume method. The expected result is that $\\varepsilon$ is extremely small (close to machine precision), demonstrating conservation of $c_A + c_B$ under the conservative finite volume advection and exact local reaction update.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4]$), where each $r_i$ is the floating-point value of $\\varepsilon$ for the corresponding test. No units are required because all quantities are dimensionless. The program must be self-contained, require no input, and run to completion using the specified tests.", "solution": "The problem requires the derivation and implementation of a conservative finite volume method for a one-dimensional advection-reaction system. The method must be constructed from first principles, employing operator splitting, a first-order upwind scheme for advection, and an exact analytical solution for the local reaction kinetics. The objective is to verify the conservation property of the total concentration, $c_A + c_B$, for the proposed numerical scheme.\n\n**1. Finite Volume Formulation**\nThe system is governed by the integral conservation laws for species $A$ and $B$:\n$$\n\\frac{d}{dt}\\int_{V} c_A(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_A\\right)\\cdot n \\, dS + \\int_{V} \\left(-k_1 c_A + k_2 c_B\\right)\\, dx\n$$\n$$\n\\frac{d}{dt}\\int_{V} c_B(x,t)\\,dx = -\\int_{\\partial V} \\left(u\\, c_B\\right)\\cdot n \\, dS + \\int_{V} \\left(k_1 c_A - k_2 c_B\\right)\\, dx\n$$\nWe discretize the spatial domain $[0, L]$ into $N$ uniform cells, $V_i = [x_{i-1/2}, x_{i+1/2}]$, each of width $\\Delta x = L/N$. The cell centers are $x_i = (i-1/2)\\Delta x$ for $i=1, \\dots, N$.\nThe cell-averaged concentration for a species $c$ in cell $i$ is defined as:\n$$\n\\bar{c}_i(t) = \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} c(x,t)\\,dx\n$$\nApplying the integral law for species $A$ to cell $V_i$, we obtain:\n$$\n\\frac{d}{dt} \\left( \\Delta x \\, \\bar{c}_{A,i} \\right) = \\left[ (u c_A) n \\right]_{x_{i-1/2}} - \\left[ (u c_A) n \\right]_{x_{i+1/2}} + \\int_{V_i} (-k_1 c_A + k_2 c_B) \\, dx\n$$\nIn one dimension, the outward normal vector $n$ is $-1$ at the left boundary $x_{i-1/2}$ and $+1$ at the right boundary $x_{i+1/2}$. The advective flux is $F_A(x,t) = u c_A(x,t)$. Thus, the equation simplifies to:\n$$\n\\Delta x \\frac{d\\bar{c}_{A,i}}{dt} = F_A(x_{i-1/2}, t) - F_A(x_{i+1/2}, t) + \\int_{V_i} (-k_1 c_A + k_2 c_B) \\, dx\n$$\nDividing by $\\Delta x$ and approximating the integrals, we arrive at the semi-discrete finite volume formulation. The flux terms are replaced by a numerical flux function $F^*_{A, i\\pm1/2}$, and the source term integral is approximated as $\\Delta x$ times the source evaluated at the cell average concentrations:\n$$\n\\frac{d\\bar{c}_{A,i}}{dt} = -\\frac{F^*_{A,i+1/2} - F^*_{A,i-1/2}}{\\Delta x} + (-k_1 \\bar{c}_{A,i} + k_2 \\bar{c}_{B,i})\n$$\nAn analogous equation holds for $\\bar{c}_{B,i}$.\n\n**2. Numerical Method: Operator Splitting**\nTo solve the semi-discrete system, we employ operator splitting. Over a small time step $\\Delta t$, the evolution of the cell-averaged concentrations $\\bar{\\mathbf{c}}_i = (\\bar{c}_{A,i}, \\bar{c}_{B,i})^T$ from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is split into two steps:\n1.  **Advection Step:** Solve $\\frac{\\partial \\mathbf{c}}{\\partial t} + u \\frac{\\partial \\mathbf{c}}{\\partial x} = 0$ for a duration $\\Delta t$. This yields an intermediate state $\\bar{\\mathbf{c}}^*$.\n2.  **Reaction Step:** Solve $\\frac{d \\mathbf{c}}{dt} = \\mathbf{R}(\\mathbf{c})$ for a duration $\\Delta t$, with $\\bar{\\mathbf{c}}^*$ as the initial condition. This gives the final state $\\bar{\\mathbf{c}}^{n+1}$.\nSymbolically, $\\bar{\\mathbf{c}}^{n+1} = \\mathcal{L}_{react}(\\Delta t) \\mathcal{L}_{adv}(\\Delta t) \\bar{\\mathbf{c}}^n$.\n\n**3. Advection Step: First-Order Upwind Method**\nFor the advection equation, we use a forward Euler time discretization. The update for an arbitrary species $c$ is:\n$$\n\\bar{c}_i^* = \\bar{c}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( F^*_{i+1/2} - F^*_{i-1/2} \\right)\n$$\nThe first-order upwind numerical flux $F^*_{i+1/2}$ depends on the sign of the velocity $u$:\n- If $u  0$, information flows from left to right, so the flux at the interface $x_{i+1/2}$ is determined by the state in cell $i$: $F^*_{i+1/2} = u \\bar{c}_i^n$.\n- If $u  0$, information flows from right to left, so the flux is determined by the state in cell $i+1$: $F^*_{i+1/2} = u \\bar{c}_{i+1}^n$.\n\nSubstituting these fluxes into the update equation gives:\n- For $u  0$: $\\bar{c}_i^* = \\bar{c}_i^n - \\frac{u \\Delta t}{\\Delta x} \\left( \\bar{c}_i^n - \\bar{c}_{i-1}^n \\right)$.\n- For $u  0$: $\\bar{c}_i^* = \\bar{c}_i^n - \\frac{u \\Delta t}{\\Delta x} \\left( \\bar{c}_{i+1}^n - \\bar{c}_i^n \\right)$.\nPeriodic boundary conditions are imposed, meaning that for cell $i=1$, the \"left\" neighbor is cell $i=N$, and for cell $i=N$, the \"right\" neighbor is cell $i=1$. This scheme is conservative; the sum of fluxes over all cells telescopes, and due to periodicity, the net sum is zero, thus preserving the total mass $\\sum_i \\bar{c}_i \\Delta x$.\n\n**4. Reaction Step: Exact Solution**\nThe reaction step involves solving the system of ordinary differential equations (ODEs) in each cell $i$, for a duration $\\Delta t$, starting from the post-advection values $(\\bar{c}_{A,i}^*, \\bar{c}_{B,i}^*)$. For a given cell, let the initial concentrations for this step be $c_A(0)$ and $c_B(0)$. The governing ODEs are:\n$$\n\\frac{dc_A}{dt} = -k_1 c_A + k_2 c_B\n$$\n$$\n\\frac{dc_B}{dt} = k_1 c_A - k_2 c_B\n$$\nSumming these two equations gives $\\frac{d}{dt}(c_A + c_B) = 0$. This confirms that the total concentration $S = c_A(t) + c_B(t)$ is constant during the reaction. Thus, $c_B(t) = S - c_A(t)$. Substituting this into the first ODE:\n$$\n\\frac{dc_A}{dt} = -k_1 c_A + k_2 (S - c_A) = -(k_1+k_2)c_A + k_2 S\n$$\nThis is a standard first-order linear ODE. If $k_1+k_2  0$, the solution is:\n$$\nc_A(t) = c_{A,eq} + (c_A(0) - c_{A,eq}) e^{-(k_1+k_2)t}\n$$\nwhere $c_{A,eq} = S \\frac{k_2}{k_1+k_2}$ is the equilibrium concentration of species $A$. The concentration of $B$ is then $c_B(t) = S - c_A(t)$. This analytical solution provides the exact update for the cell averages over the time step $\\Delta t$.\nIf $k_1+k_2=0$ (which implies $k_1=0$ and $k_2=0$), the ODEs become $\\frac{dc_A}{dt}=0$ and $\\frac{dc_B}{dt}=0$, so the concentrations remain unchanged.\nThis reaction update is performed independently in each cell and, by its derivation, exactly conserves the local mass $c_A+c_B$ in each cell, and therefore the global total mass.\n\n**5. Stability and Algorithm Summary**\nThe stability of the explicit advection scheme is governed by the Courant-Friedrichs-Lewy (CFL) condition, which requires the numerical domain of dependence to contain the physical one. For the first-order upwind scheme, this is:\n$$\nC_{cfl} = \\frac{|u|\\Delta t}{\\Delta x} \\le 1\n$$\nTo ensure stability, we choose a Courant number less than one, for example $C_{num} = 0.9$, which determines the time step size $\\Delta t = C_{num} \\frac{\\Delta x}{|u|}$ when $u \\ne 0$. When $u=0$, there is no advection and thus no CFL constraint from it; any sufficiently small $\\Delta t$ that resolves the reaction dynamics can be chosen.\n\nThe complete algorithm is as follows:\n1.  Initialize grid, concentrations $\\bar{c}_{A,i}(0)$, $\\bar{c}_{B,i}(0)$, and compute initial total mass.\n2.  Determine $\\Delta t$ based on the CFL condition.\n3.  Loop over time steps until the final time $T$ is reached.\n    a. Perform the advection update for both $\\bar{c}_A$ and $\\bar{c}_B$ arrays using the upwind scheme and periodic boundaries, yielding intermediate arrays $\\bar{c}_A^*$ and $\\bar{c}_B^*$.\n    b. Perform the reaction update for each cell $i$, using the exact solution of the local ODE system with initial conditions $(\\bar{c}_{A,i}^*, \\bar{c}_{B,i}^*)$ to find the new concentrations $(\\bar{c}_{A,i}^{n+1}, \\bar{c}_{B,i}^{n+1})$.\n4.  After the final time step, compute the final total mass and the relative change $\\varepsilon$.\n\nThis combined scheme is designed to be conservative for the total mass $c_A+c_B$, meaning any change should be attributable only to floating-point precision errors.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-reaction problem for four test cases\n    using a conservative finite volume method with operator splitting.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, L, u, k1, k2, T)\n        (200, 1.0, 1.0, 1.0, 1.0, 0.5),   # Test 1\n        (200, 1.0, -0.7, 0.0, 0.0, 0.5),  # Test 2\n        (200, 1.0, 0.3, 50.0, 20.0, 0.2), # Test 3\n        (200, 1.0, 0.0, 3.0, 2.0, 1.0),   # Test 4\n    ]\n\n    results = []\n\n    for N, L, u, k1, k2, T in test_cases:\n        # --- 1. Initialization ---\n        dx = L / N\n        x = np.linspace(dx / 2.0, L - dx / 2.0, N)\n\n        # Initial conditions for cA and cB\n        cA = 1.0 + 0.5 * np.sin(2.0 * np.pi * x / L)\n        cB = 0.5 + 0.25 * np.cos(2.0 * np.pi * x / L)\n\n        # Calculate initial total mass\n        initial_total_mass = np.sum(cA + cB) * dx\n\n        # --- 2. Time Stepping Setup ---\n        cfl_number = 0.9\n        \n        if u == 0:\n            # For pure reaction, advection CFL is not applicable.\n            # Choose a dt small enough to resolve reaction dynamics well.\n            # Time scale for reaction is ~1/(k1+k2).\n            # For Test 4, 1/(3+2) = 0.2. dt=0.001 is small enough.\n            dt = 0.001\n        else:\n            dt = cfl_number * dx / abs(u)\n\n        num_steps = int(np.ceil(T / dt))\n        dt = T / num_steps  # Adjust dt to hit T exactly\n        \n        t = 0.0\n\n        # --- 3. Time-Stepping Loop ---\n        for _ in range(num_steps):\n            # A. Advection Step (using operator splitting)\n            if u != 0:\n                # First-order upwind scheme with periodic boundaries\n                # np.roll(arr, 1) gets the i-1 element\n                # np.roll(arr, -1) gets the i+1 element\n                \n                courant = u * dt / dx\n                \n                if u > 0:\n                    # Upwind nodes are from the left (i-1)\n                    cA_star = cA - courant * (cA - np.roll(cA, 1))\n                    cB_star = cB - courant * (cB - np.roll(cB, 1))\n                else: # u  0\n                    # Upwind nodes are from the right (i+1)\n                    cA_star = cA - courant * (np.roll(cA, -1) - cA)\n                    cB_star = cB - courant * (np.roll(cB, -1) - cB)\n            else:\n                cA_star = cA.copy()\n                cB_star = cB.copy()\n\n            # B. Reaction Step (using exact solution)\n            k_sum = k1 + k2\n            if k_sum > 0:\n                # Total concentration in each cell (conserved by reaction)\n                S = cA_star + cB_star\n                \n                # Equilibrium concentration for cA\n                cA_eq = S * k2 / k_sum\n                \n                # Initial deviation from equilibrium\n                cA_dev_initial = cA_star - cA_eq\n                \n                # Evolve deviation for time dt\n                cA_dev_final = cA_dev_initial * np.exp(-k_sum * dt)\n                \n                # Final concentrations after reaction\n                cA = cA_eq + cA_dev_final\n                cB = S - cA\n            else: # k1 = 0, k2 = 0, no reaction\n                cA = cA_star\n                cB = cB_star\n            \n            t += dt\n\n        # --- 4. Finalization ---\n        # Calculate final total mass\n        final_total_mass = np.sum(cA + cB) * dx\n        \n        # Calculate absolute relative change in total mass\n        if initial_total_mass == 0:\n            # Avoid division by zero, though unlikely with given ICs\n            relative_change = 0.0 if final_total_mass == 0 else np.inf\n        else:\n            relative_change = abs(final_total_mass - initial_total_mass) / initial_total_mass\n        \n        results.append(relative_change)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3130189"}]}