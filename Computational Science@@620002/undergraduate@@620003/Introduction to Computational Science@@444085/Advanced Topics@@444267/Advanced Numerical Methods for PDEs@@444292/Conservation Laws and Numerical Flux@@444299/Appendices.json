{"hands_on_practices": [{"introduction": "The choice of a numerical flux is not merely a detail; it is fundamental to the stability and physical realism of a simulation. An intuitive choice, like averaging values from neighboring cells, can lead to catastrophic failure. This first exercise [@problem_id:3111406] provides a stark contrast between the stable, reliable upwind flux and the unconditionally unstable central flux for the linear advection equation, demonstrating from first principles how the flux formulation directly governs whether small errors will decay or grow exponentially.", "problem": "You are given the linear conservation law $u_t + (f(u))_x = 0$ with $f(u) = c\\,u$, where $c$ is a strictly positive constant. Consider a uniform grid with $N$ cells on a periodic domain of length $L$. Let $U_i^n$ denote the cell average in cell $i$ at time level $n$, with cell width $\\Delta x = L/N$, time step $\\Delta t$, and Courant number $\\nu = c\\,\\Delta t/\\Delta x$. Let $\\mathcal{F}_{i+\\frac{1}{2}}$ denote a consistent numerical flux at the interface between cell $i$ and $i+1$. The explicit forward Euler finite volume update reads\n$$\nU_i^{n+1} \\;=\\; U_i^n \\;-\\;\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big), \n$$\nwith periodic boundary conditions.\n\nTwo fluxes are to be compared:\n\n- Upwind flux for $c>0$: $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i^n$.\n- Central flux: $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\tfrac{1}{2}\\,c\\,(U_i^n + U_{i+1}^n)$.\n\nStarting from the fundamental definition of a discrete conservation law and these flux choices, reason from first principles to establish the following properties.\n\n1) Discrete steady states: A discrete steady state is any grid function $U_i$ such that the explicit update yields $U_i^{n+1} = U_i^n$ for all $i$. Identify the discrete steady states for the given equation and fluxes, and determine whether the constant state $U_i \\equiv U_0$ is invariant under each scheme.\n\n2) Linear stability about steady states: For a small perturbation about the constant steady state, $U_i^n = U_0 + \\varepsilon\\,\\phi_i^n$ with $0<\\varepsilon\\ll 1$, determine whether the perturbation amplitude can grow in time. Use the Courant–Friedrichs–Lewy (CFL) number $\\nu$ as the nondimensional control parameter. Your reasoning must start from the discrete update and admissible Fourier modes on the periodic grid.\n\n3) Numerical demonstration: Implement both finite volume schemes to illustrate that:\n- Under upwind flux, the discrete steady state is preserved in the sense that small perturbations do not grow for $0 \\le \\nu \\le 1$; the distance to the steady state is nonincreasing.\n- Under central flux, the discrete steady state drifts for marginal CFL choices, that is, any nonzero $\\nu$ results in growth of a nontrivial perturbation.\n\nYou must quantify “preserved” versus “drift” by measuring the ratio of the perturbation norm at final time to its initial value.\n\nImplementation requirements:\n\n- Domain and parameters: use a periodic domain of length $L = 1$, wave speed $c = 1$, number of cells $N = 128$, cell centers at $x_i = (i+\\tfrac{1}{2})\\,\\Delta x$ with $\\Delta x = L/N$, and number of time steps $M = 200$.\n- Initial data: $U_i^0 = U_0 + \\varepsilon \\sin(2\\pi k x_i)$ with $U_0 = 1$, wavenumber $k = 1$, and perturbation amplitude $\\varepsilon = 10^{-3}$.\n- Time step: for each test, choose $\\Delta t = \\nu\\,\\Delta x / c$ for the specified $\\nu$.\n- Perturbation norm: for any vector $U$, define the perturbation relative to its spatial mean $\\bar U = \\frac{1}{N}\\sum_i U_i$ by $\\delta U = U - \\bar U\\,\\mathbf{1}$, and the discrete $L^2$ norm $\\|\\delta U\\|_2 = \\sqrt{\\sum_i (\\delta U_i)^2}$. For each scheme and each test, compute the ratio $R = \\|\\delta U^{M}\\|_2/\\|\\delta U^{0}\\|_2$.\n- Test suite (CFL numbers): run tests for $\\nu \\in \\{0.1,\\,0.5,\\,0.9\\}$.\n- Expected behavior to be checked by your program: for upwind flux, $R \\le 1$; for central flux, $R > 1$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the six ratios as a comma-separated list enclosed in square brackets in the following order:\n$$\n[\\;R_{\\mathrm{up}}(\\nu{=}0.1),\\;R_{\\mathrm{ce}}(\\nu{=}0.1),\\;R_{\\mathrm{up}}(\\nu{=}0.5),\\;R_{\\mathrm{ce}}(\\nu{=}0.5),\\;R_{\\mathrm{up}}(\\nu{=}0.9),\\;R_{\\mathrm{ce}}(\\nu{=}0.9)\\;].\n$$\nExpress each ratio as a decimal (unitless), rounded to six digits after the decimal point. No other text should be printed.", "solution": "The problem requires a first-principles analysis of two finite volume schemes for the linear advection equation, $u_t + c u_x = 0$, where $c > 0$ is a constant. The equation is a conservation law of the form $u_t + (f(u))_x = 0$ with a linear flux function $f(u) = c\\,u$. The finite volume method approximates the integral form of this law. For a uniform grid with cell width $\\Delta x$ and time step $\\Delta t$, the cell average $U_i^n$ in cell $i$ at time $n$ is updated using the explicit forward Euler scheme:\n$$\nU_i^{n+1} \\;=\\; U_i^n \\;-\\;\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big)\n$$\nwhere $\\mathcal{F}_{i+\\frac{1}{2}}$ is the numerical flux at the interface between cells $i$ and $i+1$. We analyze two flux choices: the upwind flux $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i^n$ (since $c>0$) and the central flux $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\frac{1}{2}\\,c\\,(U_i^n + U_{i+1}^n)$. The Courant number is defined as $\\nu = c\\,\\Delta t/\\Delta x$.\n\n1) Discrete steady states.\nA discrete steady state is a grid function $U_i$ that does not change in time, i.e., $U_i^{n+1} = U_i^n$ for all grid indices $i$. Substituting this condition into the update equation yields:\n$$\n0 \\;=\\; -\\frac{\\Delta t}{\\Delta x}\\,\\Big(\\mathcal{F}_{i+\\frac{1}{2}} - \\mathcal{F}_{i-\\frac{1}{2}}\\Big)\n$$\nSince $\\Delta t > 0$ and $\\Delta x > 0$, this implies that $\\mathcal{F}_{i+\\frac{1}{2}} = \\mathcal{F}_{i-\\frac{1}{2}}$ for all $i$. Due to the periodic boundary conditions, this means the numerical flux must be constant across all cell interfaces: $\\mathcal{F}_{i+\\frac{1}{2}} = F_{const}$ for some constant $F_{const}$.\n\nFor the upwind flux, $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_i$. The steady state condition becomes $c\\,U_i = F_{const}$. Since $c$ is a strictly positive constant, this requires $U_i = F_{const} / c$. Therefore, any constant grid function, $U_i = U_{const}$, is a discrete steady state for the upwind scheme. Specifically, the constant state $U_i \\equiv U_0$ is invariant. If $U_i^n = U_0$ for all $i$, then $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_0$ and $\\mathcal{F}_{i-\\frac{1}{2}}^{\\mathrm{up}} = c\\,U_0$, making the update term zero.\n\nFor the central flux, $\\mathcal{F}_{i+\\frac{1}{2}}^{\\mathrm{ce}} = \\frac{1}{2}\\,c\\,(U_i + U_{i+1})$. The steady state condition is $\\frac{1}{2}\\,c\\,(U_i + U_{i+1}) = F_{const}$, or $U_i + U_{i+1} = C_{const}$, where $C_{const} = 2F_{const}/c$. This recurrence relation is satisfied by any constant grid function $U_i = U_0$ (where $C_{const} = 2U_0$), so the constant state $U_i \\equiv U_0$ is also invariant under the central scheme. However, this condition also admits non-constant solutions. For example, a period-$2$ wave of the form $U_i = A(-1)^i + B$ for constants $A$ and $B$ is a steady state, because $U_i + U_{i+1} = (A(-1)^i + B) + (A(-1)^{i+1} + B) = 2B = C_{const}$. These non-constant solutions are often referred to as spurious steady states.\n\n2) Linear stability about steady states.\nWe analyze the stability of the constant steady state $U_0$ by considering the evolution of a small perturbation, $U_i^n = U_0 + \\varepsilon\\,\\phi_i^n$, where $0 < \\varepsilon \\ll 1$. Since both schemes are linear, the equation governing the perturbation $\\phi_i^n$ is identical to the one governing $U_i^n$. We apply von Neumann stability analysis by decomposing the perturbation into Fourier modes on the periodic grid. A single Fourier mode has the form $\\phi_i^n = (g(\\xi))^n e^{\\mathrm{j} i \\xi}$, where $\\xi = k_g \\Delta x$ is the dimensionless wavenumber, $k_g$ is the physical wavenumber, $\\mathrm{j} = \\sqrt{-1}$, and $g(\\xi)$ is the complex amplification factor. The scheme is stable if $|g(\\xi)| \\le 1$ for all admissible wavenumbers $\\xi$.\n\nFor the upwind scheme, the update equation can be written as:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}(c\\,U_i^n - c\\,U_{i-1}^n) = U_i^n - \\nu(U_i^n - U_{i-1}^n) = (1-\\nu)U_i^n + \\nu U_{i-1}^n\n$$\nSubstituting the Fourier mode $\\phi_i^n = g^n e^{\\mathrm{j} i \\xi}$ into the equation for the perturbation gives:\n$$\ng^{n+1}e^{\\mathrm{j} i \\xi} = (1-\\nu)g^n e^{\\mathrm{j} i \\xi} + \\nu g^n e^{\\mathrm{j} (i-1) \\xi}\n$$\nDividing by $g^n e^{\\mathrm{j} i \\xi}$ yields the amplification factor:\n$$\ng(\\xi) = 1 - \\nu + \\nu e^{-\\mathrm{j}\\xi} = 1 - \\nu + \\nu(\\cos\\xi - \\mathrm{j}\\sin\\xi)\n$$\nThe squared magnitude is:\n$$\n|g(\\xi)|^2 = (1 - \\nu + \\nu\\cos\\xi)^2 + (-\\nu\\sin\\xi)^2 = 1 - 2\\nu(1-\\nu)(1-\\cos\\xi)\n$$\nFor stability, we require $|g(\\xi)|^2 \\le 1$, which means $2\\nu(1-\\nu)(1-\\cos\\xi) \\ge 0$. Since $1-\\cos\\xi \\ge 0$ for all real $\\xi$, the condition reduces to $\\nu(1-\\nu) \\ge 0$. This is satisfied for $0 \\le \\nu \\le 1$. Thus, the upwind scheme is conditionally stable. For $\\nu$ in this range, perturbations do not grow. Furthermore, for $\\nu \\in (0, 1)$ and $\\xi \\ne 0$, we have $|g(\\xi)| < 1$, indicating that the scheme is dissipative and will damp perturbations over time.\n\nFor the central scheme, the update equation is:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left(\\frac{c}{2}(U_i^n+U_{i+1}^n) - \\frac{c}{2}(U_{i-1}^n+U_i^n)\\right) = U_i^n - \\frac{\\nu}{2}(U_{i+1}^n - U_{i-1}^n)\n$$\nSubstituting the Fourier mode yields:\n$$\ng^{n+1}e^{\\mathrm{j} i \\xi} = g^n e^{\\mathrm{j} i \\xi} - \\frac{\\nu}{2}(g^n e^{\\mathrm{j} (i+1) \\xi} - g^n e^{\\mathrm{j} (i-1) \\xi})\n$$\nThe amplification factor is:\n$$\ng(\\xi) = 1 - \\frac{\\nu}{2}(e^{\\mathrm{j}\\xi} - e^{-\\mathrm{j}\\xi}) = 1 - \\frac{\\nu}{2}(2\\mathrm{j}\\sin\\xi) = 1 - \\mathrm{j}\\nu\\sin\\xi\n$$\nIts squared magnitude is:\n$$\n|g(\\xi)|^2 = 1^2 + (-\\nu\\sin\\xi)^2 = 1 + \\nu^2\\sin^2\\xi\n$$\nThe stability condition $|g(\\xi)|^2 \\le 1$ requires $1 + \\nu^2\\sin^2\\xi \\le 1$, which simplifies to $\\nu^2\\sin^2\\xi \\le 0$. As $\\nu^2 \\ge 0$ and $\\sin^2\\xi \\ge 0$, this condition is only met if $\\nu=0$ or $\\sin\\xi=0$. For any $\\nu>0$ and any mode with $\\sin\\xi \\ne 0$, we have $|g(\\xi)| > 1$. The scheme is therefore unconditionally unstable for any $\\nu>0$. Any nontrivial perturbation containing unstable Fourier components will grow in time.\n\n3) Numerical demonstration.\nThe numerical experiment illustrates these stability properties. The perturbation is defined relative to the spatial mean, $\\delta U = U - \\bar U \\mathbf{1}$. For a conservative scheme, the mean $\\bar U$ is constant in time. Analyzing $\\|\\delta U\\|_2$ is equivalent to analyzing the evolution of all non-zero wavenumber modes ($\\xi \\ne 0$).\n\nFor the upwind scheme, with the tested Courant numbers $\\nu \\in \\{0.1, 0.5, 0.9\\}$ all falling within the stability range $[0, 1]$, the amplification factor satisfies $|g(\\xi)| < 1$ for all non-zero wavenumber components of the initial sinusoidal perturbation. Consequently, the amplitude of the perturbation is expected to decrease over time. The ratio $R = \\|\\delta U^M\\|_2 / \\|\\delta U^0\\|_2$ should be less than or equal to $1$, confirming that the discrete steady state is preserved in the sense that perturbations are damped.\n\nFor the central scheme, the stability analysis showed that for any non-zero $\\nu$, there are unstable modes with $|g(\\xi)| > 1$. The initial sinusoidal perturbation contains such modes. Their amplitudes will grow over time, leading to an increase in the overall norm of the perturbation. The ratio $R$ is therefore expected to be greater than $1$, demonstrating that the constant steady state is unstable and \"drifts\" away due to the growth of any small perturbation. The program will compute these ratios to verify this theoretical prediction.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using upwind and central finite volume schemes\n    to demonstrate stability properties.\n    \"\"\"\n    # Define parameters from the problem statement\n    L = 1.0\n    c = 1.0\n    N = 128\n    U0 = 1.0\n    epsilon = 1e-3\n    k_wave = 1\n    M = 200\n    \n    # Test cases are the different Courant numbers (nu)\n    test_cases_nu = [0.1, 0.5, 0.9]\n\n    # Set up the computational grid\n    dx = L / N\n    x = (np.arange(N, dtype=np.float64) + 0.5) * dx\n\n    # Define the initial condition\n    U_initial = U0 + epsilon * np.sin(2 * np.pi * k_wave * x)\n\n    # Calculate the norm of the initial perturbation\n    # The perturbation is defined relative to the spatial mean.\n    U_mean_initial = np.mean(U_initial)\n    delta_U_initial = U_initial - U_mean_initial\n    norm_delta_U_initial = np.linalg.norm(delta_U_initial)\n\n    results = []\n    # Loop over the specified Courant-Friedrichs-Lewy (CFL) numbers\n    for nu in test_cases_nu:\n        \n        # --- Upwind Scheme ---\n        U_up = np.copy(U_initial)\n        for _ in range(M):\n            # U_i^{n+1} = U_i^n - nu * (U_i^n - U_{i-1}^n)\n            # Periodic boundary conditions are handled by np.roll\n            U_up = U_up - nu * (U_up - np.roll(U_up, 1, axis=0))\n\n        # Calculate the ratio R for the upwind scheme\n        U_mean_final_up = np.mean(U_up)\n        delta_U_final_up = U_up - U_mean_final_up\n        norm_delta_U_final_up = np.linalg.norm(delta_U_final_up)\n        R_up = norm_delta_U_final_up / norm_delta_U_initial\n        results.append(R_up)\n\n        # --- Central Flux Scheme ---\n        U_ce = np.copy(U_initial)\n        for _ in range(M):\n            # U_i^{n+1} = U_i^n - (nu/2) * (U_{i+1}^n - U_{i-1}^n)\n            # Periodic boundary conditions are handled by np.roll\n            U_ce = U_ce - (nu / 2.0) * (np.roll(U_ce, -1, axis=0) - np.roll(U_ce, 1, axis=0))\n        \n        # Calculate the ratio R for the central scheme\n        U_mean_final_ce = np.mean(U_ce)\n        delta_U_final_ce = U_ce - U_mean_final_ce\n        norm_delta_U_final_ce = np.linalg.norm(delta_U_final_ce)\n        R_ce = norm_delta_U_final_ce / norm_delta_U_initial\n        results.append(R_ce)\n    \n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3111406"}, {"introduction": "The cornerstone of the finite volume method is the principle of local conservation, which ensures that a conserved quantity is perfectly transferred between adjacent cells without any artificial loss or gain. This practice [@problem_id:3111462] moves beyond a single flux calculation to test the integrity of the entire numerical framework. By implementing a computational test harness, you will verify that the sum of fluxes out of an arbitrary collection of cells is precisely equal to the net flux across that region's boundary, confirming the scheme's conservative \"bookkeeping\" up to machine precision.", "problem": "You are to design and implement a complete, runnable program that tests the local conservation property of a two-dimensional finite volume discretization by summing numerical fluxes around randomly generated control volumes and verifying cancellation to round-off. The underlying mathematical model is the scalar conservation law in integral form, which states that the rate of change of a conserved quantity equals the net flux of that quantity through the boundary of a control volume.\n\nFundamental base to use:\n- The integral conservation law on a control volume $\\Omega$:\n$$\n\\frac{d}{dt}\\int_{\\Omega} q(\\mathbf{x},t)\\,d\\mathbf{x} \\;+\\; \\int_{\\partial \\Omega} \\mathbf{F}(q)\\cdot \\mathbf{n}\\,ds \\;=\\; 0,\n$$\nwhere $q$ is the conserved scalar and $\\mathbf{F}(q)$ is the physical flux vector.\n- The finite volume method constructs discrete face fluxes so that shared internal faces contribute equal and opposite amounts to adjacent cells, ensuring local conservation.\n\nDiscretization setup to be implemented:\n- A rectangular, periodic grid of $N_x\\times N_y$ cells over the domain $[0,2\\pi]\\times[0,2\\pi]$ with uniform spacings $dx=2\\pi/N_x$ and $dy=2\\pi/N_y$.\n- A smooth streamfunction $\\psi(x,y)=\\sin(x)\\sin(y)$ defining a divergence-free velocity field via\n$$\nu^x(x,y)=\\frac{\\partial \\psi}{\\partial y}(x,y)=\\cos(y)\\sin(x), \\quad\nu^y(x,y)=-\\frac{\\partial \\psi}{\\partial x}(x,y)=-\\cos(x)\\sin(y).\n$$\n- A discrete scalar field $q_{i,j}$ defined at cell centers $(x_i,y_j)$, generated deterministically from a pseudorandom number generator with specified seeds.\n\nNumerical fluxes to be constructed:\n- Define face-centered velocities at vertical faces $(i+\\tfrac{1}{2},j)$ using $x_{i+\\tfrac{1}{2}}=x_i+\\tfrac{dx}{2}$ and $y_j$, and at horizontal faces $(i,j+\\tfrac{1}{2})$ using $x_i$ and $y_{j+\\tfrac{1}{2}}=y_j+\\tfrac{dy}{2}$.\n- Define the numerical fluxes across faces using central averaging of the scalar:\n$$\nF^x_{i+\\tfrac{1}{2},j}=u^x(x_{i+\\tfrac{1}{2}},y_j)\\cdot \\frac{q_{i,j}+q_{i+1\\ \\mathrm{mod}\\ N_x,j}}{2}, \\quad\nF^y_{i,j+\\tfrac{1}{2}}=u^y(x_i,y_{j+\\tfrac{1}{2}})\\cdot \\frac{q_{i,j}+q_{i,j+1\\ \\mathrm{mod}\\ N_y}}{2}.\n$$\nHere, periodic indexing is used so that $i+1\\ \\mathrm{mod}\\ N_x$ and $j+1\\ \\mathrm{mod}\\ N_y$ wrap around the grid.\n\nLocal conservation check to perform:\n- For any subset $\\mathcal{S}$ of cells, the net outward flux computed by summing per-cell outward flux contributions\n$$\n\\sum_{(i,j)\\in\\mathcal{S}} \\left( F^x_{i+\\tfrac{1}{2},j}-F^x_{i-\\tfrac{1}{2},j}+F^y_{i,j+\\tfrac{1}{2}}-F^y_{i,j-\\tfrac{1}{2}} \\right)\n$$\nmust equal the sum of fluxes across only the boundary faces of $\\mathcal{S}$ with outward orientation. Internal shared faces must cancel to round-off because they appear as equal and opposite contributions. Your program must compute both quantities and verify their difference is within a small tolerance relative to the magnitude of the boundary flux.\n\nProgram requirements:\n- Implement the grid, velocity field, scalar field $q_{i,j}$, and numerical fluxes exactly as specified.\n- Generate control volumes $\\mathcal{S}$ as subsets of cells according to the test suite below.\n- For each control volume, compute the net outward flux in two ways:\n  1. By summing per-cell outward flux contributions over all cells in $\\mathcal{S}$.\n  2. By summing outward-oriented fluxes across only the faces that separate $\\mathcal{S}$ from its complement.\n- Define the error measure $E=|S_{\\text{cells}}-S_{\\text{boundary}}|$ and the scale $A=\\sum |\\text{boundary face fluxes}|$. Report a boolean result that is true if $E\\le \\tau\\cdot(1+A)$, where $\\tau$ is a tolerance constant to be set to $\\tau=10^{-12}$.\n\nTest suite:\nFor each test case, the tuple specifies $(N_x,N_y,\\text{mode},\\text{param},\\text{seed})$, where $\\text{mode}$ defines the subset selection method and $\\text{param}$ is its parameter.\n- Case 1 (general random subset): $(32,24,\\text{random\\_fraction},0.3,2024)$.\n- Case 2 (single cell at center): $(16,16,\\text{single\\_cell},\\text{None},7)$; select the single cell at indices $(\\lfloor N_x/2\\rfloor,\\lfloor N_y/2\\rfloor)$.\n- Case 3 (full grid): $(20,30,\\text{full\\_grid},\\text{None},99)$; select all cells of the grid.\n- Case 4 (larger random subset): $(48,10,\\text{random\\_fraction},0.5,12345)$.\n- Case 5 (checkerboard subset): $(12,12,\\text{checkerboard},\\text{None},2025)$; select cells where $(i+j)$ is even.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5]\"), where each result is a boolean corresponding to the five test cases in the order listed above. No additional text should be printed.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of computational fluid dynamics, specifically the finite volume method for conservation laws. The problem is well-posed, with all necessary parameters, equations, and conditions explicitly defined, leading to a unique, verifiable solution for each test case. The task constitutes a standard and instructive numerical experiment to verify the property of local conservation, which is fundamental to the construction of finite volume schemes.\n\nThe solution proceeds by implementing the specified numerical discretization and performing the conservation check for several defined control volumes.\n\n**1. Discretization of the Domain and Fields**\n\nThe continuous domain $[0, 2\\pi] \\times [0, 2\\pi]$ is discretized into a uniform grid of $N_x \\times N_y$ rectangular cells, or control volumes. The width and height of each cell are $\\Delta x = 2\\pi/N_x$ and $\\Delta y = 2\\pi/N_y$, respectively. A cell is indexed by $(i,j)$ for $i \\in \\{0, 1, \\dots, N_x-1\\}$ and $j \\in \\{0, 1, \\dots, N_y-1\\}$.\n\nThe scalar quantity $q$ is represented by a discrete field $q_{i,j}$ located at the center of each cell. The coordinates of the cell center $(x_i, y_j)$ are given by $x_i = (i+0.5)\\Delta x$ and $y_j = (j+0.5)\\Delta y$. The values of $q_{i,j}$ for each test case are generated using a pseudorandom number generator with a specified seed, ensuring deterministic and reproducible results.\n\nThe problem defines a divergence-free velocity field $\\mathbf{u} = (u^x, u^y)$ derived from a streamfunction $\\psi(x,y) = \\sin(x)\\sin(y)$:\n$$\nu^x(x,y) = \\frac{\\partial \\psi}{\\partial y} = \\cos(y)\\sin(x)\n$$\n$$\nu^y(x,y) = -\\frac{\\partial \\psi}{\\partial x} = -\\cos(x)\\sin(y)\n$$\nThis continuous velocity field is evaluated at the centers of the cell faces to compute the fluxes. The vertical faces between cells $(i,j)$ and $(i+1,j)$ are located at coordinate $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$. The horizontal faces between cells $(i,j)$ and $(i,j+1)$ are at $y_{j+\\frac{1}{2}} = (j+1)\\Delta y$.\n\n**2. Numerical Flux Construction**\n\nThe finite volume method approximates the integral form of the conservation law. The flux of $q$ across cell faces is computed using a numerical flux function. The problem specifies a central-averaging scheme.\n\nThe numerical flux across the vertical face at $(x_{i+\\frac{1}{2}}, y_j)$ is:\n$$\nF^x_{i+\\frac{1}{2},j} = u^x(x_{i+\\frac{1}{2}}, y_j) \\cdot \\frac{q_{i,j} + q_{i+1 \\pmod{N_x}, j}}{2}\n$$\nThe numerical flux across the horizontal face at $(x_i, y_{j+\\frac{1}{2}})$ is:\n$$\nF^y_{i,j+\\frac{1}{2}} = u^y(x_i, y_{j+\\frac{1}{2}}) \\cdot \\frac{q_{i,j} + q_{i,j+1 \\pmod{N_y}}}{2}\n$$\nThe use of modulo arithmetic in the indices, e.g., $i+1 \\pmod{N_x}$, correctly implements the specified periodic boundary conditions.\n\n**3. Verification of Local Conservation**\n\nThe core of the problem is to verify the local conservation property for an arbitrary subset of cells $\\mathcal{S}$. This property implies that the net flux out of the region $\\mathcal{S}$ can be computed in two equivalent ways, which must match up to floating-point precision.\n\n**Method 1: Sum of Cell-Wise Divergences ($S_{\\text{cells}}$)**\nFor each cell $(i,j) \\in \\mathcal{S}$, we compute its discrete divergence, which is the sum of fluxes leaving through its four faces. The net flux for the entire subset $\\mathcal{S}$ is the sum of these individual cell divergences:\n$$\nS_{\\text{cells}} = \\sum_{(i,j) \\in \\mathcal{S}} \\left( \\left( F^x_{i+\\frac{1}{2},j} - F^x_{i-\\frac{1}{2},j} \\right) + \\left( F^y_{i,j+\\frac{1}{2}} - F^y_{i,j-\\frac{1}{2}} \\right) \\right)\n$$\nHere, $F^x_{i-\\frac{1}{2},j}$ denotes the flux at the left face of cell $(i,j)$ and is identical to $F^x_{(i-1)+\\frac{1}{2},j}$. A key feature of a conservative discretization is that for any two adjacent cells, the flux leaving one is identical to the flux entering the other. This ensures that when summing divergences, the fluxes across all internal faces of $\\mathcal{S}$ cancel out perfectly.\n\n**Method 2: Sum over Boundary Faces ($S_{\\text{boundary}}$)**\nThis method directly computes the net flux by summing only the fluxes across the faces that form the boundary of the subset $\\mathcal{S}$, denoted $\\partial\\mathcal{S}$. A face is part of $\\partial\\mathcal{S}$ if it separates a cell inside $\\mathcal{S}$ from a cell outside $\\mathcal{S}$. The sum is performed with respect to an outward-pointing normal for $\\mathcal{S}$:\n$$\nS_{\\text{boundary}} = \\int_{\\partial\\mathcal{S}} \\mathbf{F} \\cdot \\mathbf{n} \\, ds\n$$\nIn discrete form, this involves identifying all boundary faces, determining their orientation (outward or inward), and summing the corresponding numerical fluxes with the appropriate sign.\n\nBy construction, $S_{\\text{cells}}$ and $S_{\\text{boundary}}$ are algebraically identical expressions. Our implementation computes them via two distinct algorithms to verify that this identity holds in practice.\n\n**4. Error Analysis**\n\nThe difference between the two computations, $E = |S_{\\text{cells}} - S_{\\text{boundary}}|$, should be on the order of machine floating-point precision. To provide a scale-invariant measure, this error is compared against the sum of the absolute magnitudes of all fluxes crossing the boundary, $A = \\sum_{\\text{face} \\in \\partial\\mathcal{S}} |F_{\\text{face}}|$. The conservation property is considered verified if the relative error is small, according to the criterion:\n$$\nE \\le \\tau \\cdot (1 + A)\n$$\nwhere the tolerance $\\tau$ is set to a small value, $10^{-12}$, and the $1$ in $(1+A)$ accounts for cases where the total boundary flux $A$ might be zero (e.g., the full grid). A boolean result is reported for each test case based on this condition.\n\nThe program implements this entire procedure for the five specified test cases, which include generating subsets $\\mathcal{S}$ as a random fraction of cells, a single cell, the full grid, and a checkerboard pattern.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a program to test the local conservation property\n    of a two-dimensional finite volume discretization.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 24, 'random_fraction', 0.3, 2024),\n        (16, 16, 'single_cell', None, 7),\n        (20, 30, 'full_grid', None, 99),\n        (48, 10, 'random_fraction', 0.5, 12345),\n        (12, 12, 'checkerboard', None, 2025),\n    ]\n\n    results = []\n    tau = 1e-12\n\n    for case in test_cases:\n        Nx, Ny, mode, param, seed = case\n        \n        # 1. Grid and Field Setup\n        dx = 2.0 * np.pi / Nx\n        dy = 2.0 * np.pi / Ny\n        \n        # Cell-center coordinates\n        x_centers = (np.arange(Nx) + 0.5) * dx\n        y_centers = (np.arange(Ny) + 0.5) * dy\n        \n        # Scalar field q from a seeded pseudo-random number generator\n        rng = np.random.default_rng(seed)\n        q = rng.random(size=(Nx, Ny))\n\n        # 2. Velocity and Numerical Flux Calculation\n        # Vertical face coordinates (i+1/2, j)\n        x_v_faces = (np.arange(Nx) + 1.0) * dx\n        xv_grid, yv_grid = np.meshgrid(x_v_faces, y_centers, indexing='ij')\n        \n        # Horizontal face coordinates (i, j+1/2)\n        y_h_faces = (np.arange(Ny) + 1.0) * dy\n        xh_grid, yh_grid = np.meshgrid(x_centers, y_h_faces, indexing='ij')\n\n        # Velocity at faces\n        u_x_at_faces = np.cos(yv_grid) * np.sin(xv_grid)\n        u_y_at_faces = -np.cos(xh_grid) * np.sin(yh_grid)\n\n        # Periodic shifts of q for averaging\n        q_ip1 = np.roll(q, -1, axis=0) # q at (i+1, j)\n        q_jp1 = np.roll(q, -1, axis=1) # q at (i, j+1)\n\n        # Numerical fluxes F_x at (i+1/2, j) and F_y at (i, j+1/2)\n        F_x = u_x_at_faces * (q + q_ip1) / 2.0\n        F_y = u_y_at_faces * (q + q_jp1) / 2.0\n\n        # 3. Control Volume (Subset S) Generation\n        S_mask = np.zeros((Nx, Ny), dtype=bool)\n        if mode == 'random_fraction':\n            S_mask = rng.choice([True, False], size=(Nx, Ny), p=[param, 1.0 - param])\n        elif mode == 'single_cell':\n            S_mask[Nx // 2, Ny // 2] = True\n        elif mode == 'full_grid':\n            S_mask[:, :] = True\n        elif mode == 'checkerboard':\n            I, J = np.meshgrid(np.arange(Nx), np.arange(Ny), indexing='ij')\n            S_mask = (I + J) % 2 == 0\n        \n        # 4. Conservation Check\n        # Method 1: Sum of cell divergences\n        F_x_im1 = np.roll(F_x, 1, axis=0) # F_x at (i-1/2, j)\n        F_y_jm1 = np.roll(F_y, 1, axis=1) # F_y at (i, j-1/2)\n        cell_divergence = (F_x - F_x_im1) + (F_y - F_y_jm1)\n        S_cells = np.sum(cell_divergence[S_mask])\n\n        # Method 2: Sum over boundary faces\n        S_boundary = 0.0\n        A = 0.0\n        \n        # Iterate over all faces to identify boundary faces and sum fluxes\n        for i in range(Nx):\n            for j in range(Ny):\n                i_next = (i + 1) % Nx\n                j_next = (j + 1) % Ny\n\n                # Vertical face (i+1/2, j)\n                if S_mask[i, j] != S_mask[i_next, j]:\n                    flux = F_x[i, j]\n                    A += np.abs(flux)\n                    if S_mask[i, j]:  # Outward flux from S\n                        S_boundary += flux\n                    else:  # Inward flux to S (outward from neighbor)\n                        S_boundary -= flux\n\n                # Horizontal face (i, j+1/2)\n                if S_mask[i, j] != S_mask[i, j_next]:\n                    flux = F_y[i, j]\n                    A += np.abs(flux)\n                    if S_mask[i, j]:  # Outward flux from S\n                        S_boundary += flux\n                    else:  # Inward flux to S (outward from neighbor)\n                        S_boundary -= flux\n\n        # 5. Error Calculation and Result\n        E = np.abs(S_cells - S_boundary)\n        is_conserved = E <= tau * (1.0 + A)\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3111462"}, {"introduction": "A robust numerical scheme must do more than just remain stable; it must also respect the fundamental physical laws of the system it models. For quantities like density or concentration, this means the solution must never become negative. This advanced exercise [@problem_id:3111441] tackles this challenge head-on by requiring the design of a positivity-preserving limiter, a crucial technique in developing high-fidelity scientific codes that ensures the numerical results remain physically meaningful.", "problem": "Consider the scalar conservation law $u_t + f(u)_x = 0$ on the periodic domain $[0,1]$, where the flux function is $f(u) = u^2/2$. Assume an initial condition $u_0(x) \\ge 0$ is given. Starting from the finite volume formulation based on cell averages and a consistent numerical flux, design and implement a one-step explicit method whose numerical flux is the Rusanov flux, and augment it with a positivity-preserving modification that ensures $u \\ge 0$ is maintained at all subsequent time steps whenever $u_0 \\ge 0$. The modification must be constructed from first principles: define how the outgoing and incoming interface fluxes contribute to the decrease of a cell average and derive a single global scaling factor in $[0,1]$ per time step chosen as the largest value that guarantees nonnegativity of all updated cell averages.\n\nThe base method is first-order accurate in space and time. Use Courant-Friedrichs-Lewy (CFL) number denoted by $\\text{CFL}$ to select the time step $\\Delta t$ dynamically at each step according to a bound derived from local characteristic speeds. Impose periodic boundary conditions. Use forward Euler time stepping.\n\nYour task is to implement a complete program that:\n- Discretizes the interval $[0,1]$ into $N$ uniform cells of width $\\Delta x = 1/N$ and evolves the cell averages until final time $T$.\n- Constructs the Rusanov flux for $f(u) = u^2/2$ and applies a positivity-preserving modification via a single per-step scaling factor in $[0,1]$ that is the largest possible value ensuring all updated cell averages remain nonnegative.\n- Uses dynamic time stepping with the given $\\text{CFL}$ number and local characteristic speed bound.\n- Verifies for each test case that throughout the integration, all cell averages remain nonnegative up to a small numerical tolerance.\n\nInitial conditions for the test suite are specified as follows, with the domain $x \\in [0,1]$ and periodic boundary conditions:\n- Case A (general smooth bump): $N = 200$, $T = 0.2$, $\\text{CFL} = 0.9$, $u_0(x) = 0.2 + 0.8 \\exp\\left(-\\frac{(x - 0.5)^2}{0.05^2}\\right)$.\n- Case B (near-zero to large jump): $N = 100$, $T = 0.1$, $\\text{CFL} = 0.95$, $u_0(x) = 0.01$ for $x < 0.5$ and $u_0(x) = 1.0$ for $x \\ge 0.5$.\n- Case C (stress test with large time step demand): $N = 150$, $T = 0.1$, $\\text{CFL} = 1.5$, $u_0(x) = 0.2 + 0.8 \\exp\\left(-\\frac{(x - 0.5)^2}{0.08^2}\\right)$.\n- Case D (zero solution): $N = 50$, $T = 0.05$, $\\text{CFL} = 0.99$, $u_0(x) \\equiv 0.0$.\n\nYour program must report, for each case, whether nonnegativity was preserved at all intermediate time steps up to final time $T$. The answer for each case must be a boolean value. The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example: $[result\\_A,result\\_B,result\\_C,result\\_D]$ where each entry is either $\\text{True}$ or $\\text{False}$.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in the theory of numerical methods for hyperbolic conservation laws, is well-posed with all necessary data provided, and is formulated objectively. The inclusion of a test case with a Courant-Friedrichs-Lewy (CFL) number greater than one is interpreted as a deliberate stress test for the positivity-preserving properties of the scheme, not as a flaw in the problem statement.\n\nHerein, a complete solution is developed based on first principles as requested.\n\n### 1. Finite Volume Discretization\n\nThe problem considers the scalar conservation law $\\partial_t u + \\partial_x f(u) = 0$ over the periodic spatial domain $x \\in [0,1]$, with a convex flux function $f(u) = u^2/2$. This is the inviscid Burgers' equation. The domain is discretized into $N$ uniform cells, $I_i = [x_{i-1/2}, x_{i+1/2}]$, for $i=1, \\dots, N$. Each cell has a width $\\Delta x = 1/N$ and a center $x_i = (i-1/2)\\Delta x$.\n\nThe finite volume method is based on evolving the cell average of the solution, defined as $U_i(t) = \\frac{1}{\\Delta x} \\int_{I_i} u(x,t) dx$. Integrating the conservation law over cell $I_i$ and applying the divergence theorem yields the semi-discrete formulation:\n$$\n\\frac{d U_i}{dt} = - \\frac{1}{\\Delta x} \\left[ f(u(x_{i+1/2}, t)) - f(u(x_{i-1/2}, t)) \\right]\n$$\nThe point values of the flux $f(u)$ at the cell interfaces are replaced by a numerical flux function $\\hat{f}(u_L, u_R)$, which depends on the state on the left ($u_L$) and right ($u_R$) of the interface. This gives:\n$$\n\\frac{d U_i}{dt} = - \\frac{1}{\\Delta x} \\left[ \\hat{f}_{i+1/2} - \\hat{f}_{i-1/2} \\right]\n$$\nwhere $\\hat{f}_{i+1/2} = \\hat{f}(U_i, U_{i+1})$. For time integration, we use the first-order accurate forward Euler method. Let $U_i^n$ be the approximation of $U_i(t_n)$ at time $t_n$. The fully discrete scheme is:\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = - \\frac{1}{\\Delta x} \\left[ \\hat{f}_{i+1/2}^n - \\hat{f}_{i-1/2}^n \\right]\n$$\nwhich can be rearranged to the explicit update formula:\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{f}_{i+1/2}^n - \\hat{f}_{i-1/2}^n \\right)\n$$\nPeriodic boundary conditions imply that for a $0$-indexed array of cells $U_0, \\dots, U_{N-1}$, the right neighbor of cell $N-1$ is cell $0$, and the left neighbor of cell $0$ is cell $N-1$.\n\n### 2. Rusanov Numerical Flux\n\nThe problem specifies the Rusanov flux. For a general scalar conservation law, the Rusanov flux is defined as:\n$$\n\\hat{f}(u_L, u_R) = \\frac{f(u_L) + f(u_R)}{2} - \\frac{\\alpha(u_L, u_R)}{2} (u_R - u_L)\n$$\nwhere $\\alpha(u_L, u_R)$ is an estimate for the maximum local wave speed. A standard choice is $\\alpha(u_L, u_R) = \\max(|f'(u_L)|, |f'(u_R)|)$. For the given flux $f(u) = u^2/2$, the characteristic speed is $f'(u) = u$. Therefore, $\\alpha(u_L,u_R) = \\max(|u_L|, |u_R|)$. Since the initial condition is non-negative ($u_0(x) \\ge 0$) and we aim to preserve this property, we can assume $u \\ge 0$, which simplifies the speed estimate to $\\alpha(u_L, u_R) = \\max(u_L, u_R)$.\n\nThe numerical flux at the interface $x_{i+1/2}$ between cell $i$ and cell $i+1$ is thus:\n$$\n\\hat{f}_{i+1/2}^n = \\hat{f}(U_i^n, U_{i+1}^n) = \\frac{f(U_i^n) + f(U_{i+1}^n)}{2} - \\frac{\\max(U_i^n, U_{i+1}^n)}{2} (U_{i+1}^n - U_i^n)\n$$\n\n### 3. Dynamic Time-Stepping\n\nThe time step $\\Delta t$ is selected dynamically at each step $n$ to satisfy a Courant-Friedrichs-Lewy (CFL) condition. For a first-order explicit finite volume method, this condition is:\n$$\n\\frac{\\Delta t}{\\Delta x} S_{max} \\le \\text{CFL}\n$$\nwhere $S_{max}$ is the maximum characteristic speed over the entire domain. At time $t_n$, we have $S_{max}^n = \\max_i |f'(U_i^n)|$. Given $f'(u) = u$ and $U_i^n \\ge 0$, this is $S_{max}^n = \\max_i U_i^n$. The time step is therefore calculated as:\n$$\n\\Delta t_n = \\text{CFL} \\frac{\\Delta x}{S_{max}^n}\n$$\nIf $S_{max}^n = 0$ (as in the trivial zero solution case), the time step becomes undefined. In this situation, the solution is static, so any time step is technically valid. A practical choice is to cap $\\Delta t_n$ by the remaining time to reach the final time $T$, i.e., $\\Delta t_n = T - t_n$.\n\n### 4. Derivation of the Positivity-Preserving Modification\n\nThe standard explicit update may produce negative cell averages even if all $U_i^n$ are non-negative. We must design a modification to ensure $U_i^{n+1} \\ge 0$ for all $i$. The problem requires a single global scaling factor $\\theta \\in [0,1]$ that is applied to the update term.\n\nLet the unmodified update for cell $i$ be $D_i = \\frac{\\Delta t}{\\Delta x}(\\hat{f}_{i+1/2}^n - \\hat{f}_{i-1/2}^n)$. The standard update is $U_i^{n+1} = U_i^n - D_i$. The modified update is proposed as:\n$$\nU_i^{n+1}(\\theta) = U_i^n - \\theta D_i\n$$\nWe need to find the largest $\\theta \\in [0,1]$ such that $U_i^{n+1}(\\theta) \\ge 0$ for all cells $i=0, \\dots, N-1$. The condition is:\n$$\nU_i^n - \\theta D_i \\ge 0 \\quad \\forall i \\in \\{0, \\dots, N-1\\}\n$$\nThis is equivalent to $\\theta D_i \\le U_i^n$.\n\nWe analyze this condition based on the sign of $D_i$:\n- If $D_i \\le 0$: The cell average is non-decreasing ($U_i^{n+1}(\\theta) \\ge U_i^n$). Since $U_i^n \\ge 0$, positivity is automatically satisfied for this cell for any $\\theta \\ge 0$.\n- If $D_i > 0$: The cell average decreases. To maintain non-negativity, we must enforce the constraint $\\theta D_i \\le U_i^n$, which implies $\\theta \\le \\frac{U_i^n}{D_i}$.\n\nThis constraint must hold for all cells where $D_i > 0$. To find a single global factor $\\theta$ valid for all cells, we must satisfy the most restrictive constraint, which corresponds to the minimum ratio $U_i^n/D_i$ over all cells at risk. Let $I_{risk} = \\{ i \\mid D_i > 0 \\}$. The condition on $\\theta$ is:\n$$\n\\theta \\le \\min_{i \\in I_{risk}} \\left( \\frac{U_i^n}{D_i} \\right)\n$$\nIf the set $I_{risk}$ is empty, there is no upper bound on $\\theta$ from positivity constraints.\nThe problem requires choosing the largest possible $\\theta$ in the interval $[0,1]$. This value is:\n$$\n\\theta^* = \\min \\left( 1, \\min_{i \\in I_{risk}} \\frac{U_i^n}{D_i} \\right)\n$$\nConventionally, the minimum over an empty set is defined as $+\\infty$, so if $I_{risk}$ is empty, $\\theta^* = \\min(1, \\infty) = 1$. This means no modification is applied if no cell average is at risk of becoming negative. If any $U_i^n=0$ for an $i \\in I_{risk}$, then $\\theta^*=0$, which freezes the solution to prevent negativity. This completes the first-principles derivation of the positivity-preserving scaling factor.\n\n### 5. Algorithm Summary\n\nThe complete algorithm for one time step from $t_n$ to $t_{n+1}$ is as follows:\n1. Given cell averages $\\{U_i^n\\}_{i=0}^{N-1}$.\n2. Compute the maximum signal speed $S_{max}^n = \\max_i U_i^n$.\n3. Compute the time step $\\Delta t_n$. If $S_{max}^n=0$, set $\\Delta t_n=T-t_n$; otherwise, $\\Delta t_n = \\text{CFL} \\cdot \\Delta x / S_{max}^n$. Ensure $t_n + \\Delta t_n \\le T$.\n4. Compute all interface fluxes $\\hat{f}_{i+1/2}^n = \\hat{f}(U_i^n, U_{(i+1)\\%N}^n)$ for $i = 0, \\dots, N-1$.\n5. For each cell $i$, compute the update term $D_i = (\\Delta t_n / \\Delta x) (\\hat{f}_{i+1/2}^n - \\hat{f}_{(i-1+N)\\%N}^n)$.\n6. Determine the set of indices $I_{risk} = \\{i \\mid D_i > 0\\}$.\n7. Compute the scaling factor $\\theta^* = 1$ if $I_{risk}$ is empty. Otherwise, $\\theta^* = \\min(1, \\min_{i \\in I_{risk}} \\{U_i^n / D_i\\})$.\n8. Apply the positivity-preserving update for all $i$: $U_i^{n+1} = U_i^n - \\theta^* D_i$.\n9. Check if $\\min_i U_i^{n+1} < -\\epsilon$ for a small tolerance $\\epsilon > 0$. Record the result.\n10. Update time: $t_{n+1} = t_n + \\Delta t_n$.\n\nThis procedure is repeated until the final time $T$ is reached. By construction, this numerical scheme guarantees that if $U^n_i \\ge 0$ for all $i$, then $U^{n+1}_i \\ge 0$ for all $i$, up to floating-point precision. This should hold even for the stress test Case C, where the underlying scheme without the limiter is unstable ($\\text{CFL}=1.5>1$).", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # Define the initial condition functions for each test case.\n    def u0_A(x):\n        return 0.2 + 0.8 * np.exp(-((x - 0.5)**2) / 0.05**2)\n\n    def u0_B(x):\n        return np.where(x < 0.5, 0.01, 1.0)\n\n    def u0_C(x):\n        return 0.2 + 0.8 * np.exp(-((x - 0.5)**2) / 0.08**2)\n\n    def u0_D(x):\n        return np.zeros_like(x)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N': 200, 'T': 0.2, 'CFL': 0.9, 'u0_func': u0_A},\n        {'N': 100, 'T': 0.1, 'CFL': 0.95, 'u0_func': u0_B},\n        {'N': 150, 'T': 0.1, 'CFL': 1.5, 'u0_func': u0_C},\n        {'N': 50, 'T': 0.05, 'CFL': 0.99, 'u0_func': u0_D},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, T, CFL, u0_func):\n    \"\"\"\n    Runs a single simulation for a given test case.\n\n    Returns:\n        bool: True if nonnegativity was preserved at all steps, False otherwise.\n    \"\"\"\n    dx = 1.0 / N\n    x = (np.arange(N) + 0.5) * dx\n    \n    # Initialize cell averages\n    U = u0_func(x)\n    \n    t = 0.0\n    positivity_preserved = True\n    # Tolerance for checking nonnegativity\n    neg_tol = -1e-12\n\n    if np.min(U) < neg_tol:\n        positivity_preserved = False\n\n    # Flux function f(u) = u^2/2\n    def flux_func(u_vals):\n        return 0.5 * u_vals**2\n\n    # Rusanov numerical flux\n    def rusanov_flux(uL, uR):\n        alpha = np.maximum(uL, uR) # Assuming u >= 0\n        fL = flux_func(uL)\n        fR = flux_func(uR)\n        return 0.5 * (fL + fR) - 0.5 * alpha * (uR - uL)\n\n    while t < T and positivity_preserved:\n        # Dynamic time step based on CFL condition\n        max_speed = np.max(U)\n        if max_speed < 1e-12: # Handle zero solution or near-zero\n            dt = T - t\n        else:\n            dt = CFL * dx / max_speed\n        \n        # Ensure we don't step over the final time T\n        dt = min(dt, T - t)\n\n        # Periodic boundary conditions are handled by np.roll\n        U_left = np.roll(U, 1)  # U_{i-1} for each i\n        U_right = np.roll(U, -1) # U_{i+1} for each i\n        \n        # Calculate numerical fluxes at all interfaces\n        # f_hat_right[i] is the flux at the right boundary of cell i (i+1/2)\n        f_hat_right = rusanov_flux(U, U_right)\n        # f_hat_left[i] is the flux at the left boundary of cell i (i-1/2)\n        f_hat_left = rusanov_flux(U_left, U)\n\n        # Calculate the update term D_i for each cell\n        D = (dt / dx) * (f_hat_right - f_hat_left)\n\n        # --- Positivity-Preserving Modification ---\n        theta = 1.0\n        # Find indices where the update could lead to negative values\n        risk_indices = np.where(D > 1e-14)[0]\n        \n        if risk_indices.size > 0:\n            U_risk = U[risk_indices]\n            D_risk = D[risk_indices]\n\n            # The ratio U/D gives the maximum allowable scaling for each cell.\n            # D_risk is guaranteed positive. U_risk might be zero.\n            ratios = U_risk / D_risk\n            \n            # The global scaling factor must satisfy the most restrictive constraint.\n            min_ratio = np.min(ratios)\n            theta = min(1.0, min_ratio)\n        \n        # Apply the scaled update\n        U_new = U - theta * D\n        \n        # Update solution and time\n        U = U_new\n        t += dt\n\n        # Verify nonnegativity at the end of the step\n        if np.min(U) < neg_tol:\n            positivity_preserved = False\n            \n    return positivity_preserved\n\nsolve()\n```", "id": "3111441"}]}