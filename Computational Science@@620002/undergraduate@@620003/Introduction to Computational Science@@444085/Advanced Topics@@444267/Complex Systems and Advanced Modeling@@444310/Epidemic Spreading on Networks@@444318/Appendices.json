{"hands_on_practices": [{"introduction": "A crucial skill in computational epidemiology is the ability to connect the parameters of a theoretical model to observable, real-world outcomes. This first exercise focuses on this fundamental task using the classic Susceptible-Infected-Recovered (SIR) model. By working through the relationship between the final fraction of the population infected—the 'final attack rate'—and the model's core parameters, you will practice how to infer a key quantity like the transmission rate $\\beta$ from post-epidemic data [@problem_id:883374].", "problem": "Consider the Susceptible-Infected-Recovered (SIR) model for an epidemic spreading on a large, densely connected network, which can be approximated by the following mean-field differential equations for the fractions of susceptible ($s$), infected ($i$), and recovered ($r$) individuals:\n$$\n\\frac{ds}{dt} = -\\beta s i\n$$\n$$\n\\frac{di}{dt} = \\beta s i - \\gamma i\n$$\n$$\n\\frac{dr}{dt} = \\gamma i\n$$\nwhere $\\beta$ is the transmission rate and $\\gamma$ is the recovery rate. The total population is constant, $s+i+r=1$.\n\nThe basic reproduction number, $R_0 = \\beta/\\gamma$, represents the average number of secondary infections caused by a single infected individual in a fully susceptible population. The final attack rate, $A$, is the total fraction of the population that has been infected by the end of the epidemic, i.e., $A=r(t\\to\\infty)$.\n\nFor this model, it can be shown that the final attack rate $A$ and the basic reproduction number $R_0$ are related by the transcendental final-size equation:\n$$\n\\ln(1-A) = -R_0 A\n$$\nThis assumes that the epidemic starts with an infinitesimally small fraction of infected individuals, $i(0) \\to 0$, in an otherwise susceptible population, $s(0) \\to 1$.\n\nSuppose that after an epidemic has run its course, the final attack rate is precisely measured to be $A$. The recovery rate $\\gamma$ is also known from clinical studies. Assuming the epidemic perfectly followed the SIR model described, derive a closed-form expression for the transmission rate $\\beta$ in terms of the known quantities $A$ and $\\gamma$.", "solution": "We start from the known final‐size relation in the SIR model, valid when $i(0)\\to0$, $s(0)\\to1$:\n$$\n\\ln(1 - A) \\;=\\;-R_0\\,A,\n$$\nwhere $A=r(\\infty)$ is the final attack rate and $R_0=\\beta/\\gamma$.\n\n1.  Solve for $R_0$:\n$$\nR_0 \\;=\\;-\\,\\frac{\\ln(1 - A)}{A}.\n$$\n\n2.  Relate $\\beta$ to $R_0$ and $\\gamma$:\n$$\n\\beta = R_0\\,\\gamma.\n$$\n\n3.  Substitute the expression for $R_0$ into $\\beta$:\n$$\n\\beta \\;=\\;\\gamma\\;\\Bigl(-\\,\\frac{\\ln(1 - A)}{A}\\Bigr)\n\\;=\\;-\\,\\frac{\\gamma\\,\\ln(1 - A)}{A}.\n$$", "answer": "$$\\boxed{\\beta \\;=\\;-\\,\\frac{\\gamma\\,\\ln\\bigl(1 - A\\bigr)}{A}}$$", "id": "883374"}, {"introduction": "While mean-field models provide a valuable large-scale view, real epidemics unfold on the specific connections within a population's contact network. This practice delves into how network topology governs the speed of an outbreak in its critical early stages. You will derive and then computationally verify the profound link between the network's spectral radius—a measure of its connectivity—and the epidemic's exponential growth rate, providing a tangible example of how structure dictates function in complex systems [@problem_id:3124341].", "problem": "You are asked to connect early exponential growth in an epidemic to the structure of the contact network via the Next-Generation Matrix (NGM), and to validate the prediction against a directly computed time series. Work within the following setting.\n\nFundamental base and definitions to be used:\n- In the early phase of a Susceptible-Infected-Recovered (SIR) process on a static, undirected contact network with adjacency matrix $A$, per-contact transmission rate $\\beta$ (in $\\text{day}^{-1}$), and recovery rate $\\gamma$ (in $\\text{day}^{-1}$), the expected infected state vector $i(t)$ evolves according to the linear Ordinary Differential Equation (ODE) $$\\frac{d}{dt} i(t) = \\left(\\beta A - \\gamma I\\right) i(t),$$ where $I$ is the identity matrix and $i(t)$ is the vector of expected infected counts per node. This is the standard linearization valid when the fraction infected is small.\n- The Next-Generation Matrix (NGM) $K$ is defined as the expected number of secondary infections along edges over the infectious lifetime in the early phase. In this network setting with exponential infectious periods, $K$ is given by $$K = \\frac{\\beta}{\\gamma} A.$$ The leading eigenvalue (spectral radius) of $K$ is denoted by $\\rho(K)$.\n- The total infected quantity is defined as $$I_{\\text{tot}}(t) = \\sum_{j} i_j(t).$$ In the early phase, one expects $$I_{\\text{tot}}(t) \\approx I_0 e^{r t},$$ where $r$ is the early exponential growth rate (in $\\text{day}^{-1}$) and $I_0$ is a constant.\n\nYour tasks:\n1. From first principles and the above base, derive a way to compute the early exponential growth rate $r$ from the leading eigenvalue of $K$.\n2. Independently estimate $r$ by generating a time series from the linear ODE. Use the following protocol so that results are reproducible and fully specified:\n   - Use the initial condition $$i(0) = \\frac{1}{N} \\mathbf{1},$$ where $N$ is the number of nodes and $\\mathbf{1}$ is the all-ones vector, so that $$I_{\\text{tot}}(0) = 1.$$\n   - Evolve the linear ODE solution exactly using matrix exponentials: $$i(t) = \\exp\\left[\\left(\\beta A - \\gamma I\\right) t\\right] i(0).$$\n   - Sample times uniformly from $t_{\\min}$ to $t_{\\max}$ with step $\\Delta t$, where $$t_{\\min} = 0.5\\ \\text{days},\\quad t_{\\max} = 8.0\\ \\text{days},\\quad \\Delta t = 0.05\\ \\text{days}.$$\n   - Form $$y(t) = \\ln I_{\\text{tot}}(t)$$ using the natural logarithm and estimate $r_{\\text{fit}}$ as the slope in an Ordinary Least Squares (OLS) linear regression of $y(t)$ versus $t$ over the sampled times.\n3. For each test case below, compute the absolute difference $$\\left|r_{\\text{fit}} - r_{\\text{theory}}\\right|,$$ where $r_{\\text{theory}}$ is the early growth rate computed from the leading eigenvalue of $K$ and $r_{\\text{fit}}$ is the regression-based estimate.\n\nTest suite (all rates are in $\\text{day}^{-1}$, time is in days):\n- Case $1$ (path graph of length $4$): $$A_1 = \\begin{bmatrix} 0 & 1 & 0 & 0 \\\\ 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \\end{bmatrix},\\quad \\beta_1 = 0.5,\\quad \\gamma_1 = 0.4.$$\n- Case $2$ (complete graph on $3$ nodes): $$A_2 = \\begin{bmatrix} 0 & 1 & 1 \\\\ 1 & 0 & 1 \\\\ 1 & 1 & 0 \\end{bmatrix},\\quad \\beta_2 = 0.3,\\quad \\gamma_2 = 0.6.$$\n- Case $3$ (star graph on $5$ nodes, node $0$ is the hub): $$A_3 = \\begin{bmatrix} 0 & 1 & 1 & 1 & 1 \\\\ 1 & 0 & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 & 0 \\\\ 1 & 0 & 0 & 0 & 0 \\end{bmatrix},\\quad \\beta_3 = 0.2,\\quad \\gamma_3 = 0.5.$$\n\nRequired program behavior:\n- Implement the above computations for all three cases.\n- Your program must output a single line containing a comma-separated list of the three absolute differences, in the order of Cases $1,2,3$, enclosed in square brackets. Each number must be rounded to exactly $6$ decimal places. For example, the output format should be like $$[0.000123,0.000000,0.000457].$$", "solution": "The user's request is to validate the relationship between the early exponential growth rate of an epidemic on a network and the spectral properties of the Next-Generation Matrix (NGM). This involves two main tasks: first, deriving the theoretical growth rate, $r_{\\text{theory}}$, from the NGM's leading eigenvalue; second, estimating the growth rate, $r_{\\text{fit}}$, by fitting a time series generated from the linearized epidemic dynamics. Finally, the absolute difference between these two quantities is to be computed for three specific network structures.\n\n### Step 1: Theoretical Growth Rate ($r_{\\text{theory}}$) Derivation\n\nThe analysis begins with the provided linear Ordinary Differential Equation (ODE) system for the expected number of infected individuals at each node, $i(t)$:\n$$ \\frac{d}{dt} i(t) = (\\beta A - \\gamma I) i(t) $$\nwhere $A$ is the adjacency matrix, $\\beta$ is the transmission rate, $\\gamma$ is the recovery rate, and $I$ is the identity matrix. Let us define the matrix $M = \\beta A - \\gamma I$. The system is then $\\frac{d}{dt} i(t) = M i(t)$.\n\nThis is a system of linear, first-order, homogeneous ODEs with constant coefficients. The general solution can be expressed as a linear combination of its fundamental modes. If $\\{\\lambda_j\\}$ and $\\{v_j\\}$ are the set of eigenvalues and corresponding eigenvectors of $M$, the solution is given by:\n$$ i(t) = \\sum_j c_j v_j e^{\\lambda_j t} $$\nwhere the coefficients $c_j$ are determined by the initial condition $i(0)$.\n\nFor large $t$, the term corresponding to the largest eigenvalue, $\\lambda_{\\text{max}} = \\rho(M)$ (the spectral radius of $M$), will dominate the sum, provided its initial component $c_{\\text{max}}$ is non-zero.\n$$ i(t) \\approx c_{\\text{max}} v_{\\text{max}} e^{\\lambda_{\\text{max}} t} \\quad \\text{for } t \\to \\infty $$\nThe total number of infected individuals is $I_{\\text{tot}}(t) = \\mathbf{1}^T i(t)$, where $\\mathbf{1}$ is the all-ones vector. In the early phase, driven by the dominant mode, this becomes:\n$$ I_{\\text{tot}}(t) \\approx (c_{\\text{max}} \\mathbf{1}^T v_{\\text{max}}) e^{\\lambda_{\\text{max}} t} $$\nComparing this with the expected exponential growth form $I_{\\text{tot}}(t) \\approx I_0 e^{rt}$, we identify the early exponential growth rate $r$ with the leading eigenvalue of $M$:\n$$ r = \\lambda_{\\text{max}}(M) = \\rho(\\beta A - \\gamma I) $$\nThe eigenvalues of $M$ can be related to the eigenvalues of $A$. If $\\mu_j$ are the eigenvalues of $A$, then the eigenvalues of $\\beta A - \\gamma I$ are $\\beta \\mu_j - \\gamma$. Thus, the leading eigenvalue is:\n$$ r = \\beta \\mu_{\\text{max}} - \\gamma = \\beta \\rho(A) - \\gamma $$\nwhere $\\rho(A)$ is the spectral radius of the adjacency matrix $A$.\n\nThe Next-Generation Matrix is given as $K = \\frac{\\beta}{\\gamma} A$. The eigenvalues of $K$ are $\\frac{\\beta}{\\gamma} \\mu_j$. Its leading eigenvalue is $\\rho(K) = \\frac{\\beta}{\\gamma} \\rho(A)$. We can express $\\rho(A)$ in terms of $\\rho(K)$: $\\rho(A) = \\frac{\\gamma}{\\beta} \\rho(K)$.\n\nSubstituting this back into the expression for $r$, we obtain the desired relationship:\n$$ r_{\\text{theory}} = \\beta \\left(\\frac{\\gamma}{\\beta} \\rho(K)\\right) - \\gamma = \\gamma \\rho(K) - \\gamma $$\n$$ r_{\\text{theory}} = \\gamma (\\rho(K) - 1) $$\nThis equation connects the macroscopic growth rate $r$ to the microscopic parameters ($\\beta, \\gamma$) and the network topology (encapsulated in $\\rho(A)$, and thus $\\rho(K)$). An epidemic grows ($r_{\\text{theory}} > 0$) if and only if $\\rho(K) > 1$, which is the well-known threshold condition.\n\n### Step 2: Numerical Estimation of Growth Rate ($r_{\\text{fit}}$)\n\nAn independent estimate for $r$ is obtained by numerically simulating the dynamics and fitting the result.\n1.  **Solve the ODE**: The exact solution to $\\frac{d}{dt} i(t) = M i(t)$ with initial condition $i(0)$ is given by the matrix exponential:\n    $$ i(t) = \\exp(M t) i(0) $$\n    where $M = \\beta A - \\gamma I$. The initial condition is specified as $i(0) = \\frac{1}{N} \\mathbf{1}$, where $N$ is the number of nodes.\n\n2.  **Generate Time Series**: We compute $i(t)$ at discrete time points $t_k$ sampled uniformly from $t_{\\min} = 0.5$ to $t_{\\max} = 8.0$ with step $\\Delta t = 0.05$. For each $t_k$, we calculate the total infected population $I_{\\text{tot}}(t_k) = \\sum_j i_j(t_k)$.\n\n3.  **Perform Linear Regression**: The model $I_{\\text{tot}}(t) \\approx I_0 e^{rt}$ can be linearized by taking the natural logarithm:\n    $$ y(t) = \\ln I_{\\text{tot}}(t) \\approx \\ln(I_0) + r t $$\n    This is a linear equation of the form $y = c + r t$. We estimate the slope $r$ by performing an Ordinary Least Squares (OLS) linear regression on the data pairs $(t_k, y(t_k))$. The resulting slope is our estimate, $r_{\\text{fit}}$.\n\n### Step 3: Computation for Test Cases\n\nFor each of the three test cases, we perform the following calculations:\n1.  Define the adjacency matrix $A$ and parameters $\\beta, \\gamma$.\n2.  Compute $r_{\\text{theory}}$:\n    a. Construct the NGM, $K = (\\beta / \\gamma) A$.\n    b. Find its spectral radius, $\\rho(K) = \\max_j |\\lambda_j(K)|$.\n    c. Calculate $r_{\\text{theory}} = \\gamma (\\rho(K) - 1)$.\n3.  Compute $r_{\\text{fit}}$:\n    a. Construct the dynamics matrix, $M = \\beta A - \\gamma I$.\n    b. Generate the time vector $t$ from $t_{\\min}$ to $t_{\\max}$.\n    c. For each time point, calculate $i(t) = \\exp(Mt)i(0)$ and then $I_{\\text{tot}}(t) = \\sum_j i_j(t)$.\n    d. Form the vector $y(t) = \\ln I_{\\text{tot}}(t)$.\n    e. Find the slope of the best-fit line for $y(t)$ versus $t$, which gives $r_{\\text{fit}}$.\n4.  Calculate the absolute difference $|r_{\\text{fit}} - r_{\\text{theory}}|$.\n\nThe discrepancy between $r_{\\text{theory}}$ and $r_{\\text{fit}}$ arises because the time-series fit is performed over a finite interval where non-dominant eigenmodes may still have a non-negligible influence, causing $\\ln I_{\\text{tot}}(t)$ to deviate slightly from a perfect straight line. The theoretical rate $r_{\\text{theory}}$ represents the asymptotic growth rate as $t \\to \\infty$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes the absolute difference between theoretical and fitted epidemic growth rates\n    for three network test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (path graph of length 4)\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0],\n                [1, 0, 1, 0],\n                [0, 1, 0, 1],\n                [0, 0, 1, 0]\n            ]),\n            \"beta\": 0.5,\n            \"gamma\": 0.4\n        },\n        # Case 2 (complete graph on 3 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1],\n                [1, 0, 1],\n                [1, 1, 0]\n            ]),\n            \"beta\": 0.3,\n            \"gamma\": 0.6\n        },\n        # Case 3 (star graph on 5 nodes)\n        {\n            \"A\": np.array([\n                [0, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0]\n            ]),\n            \"beta\": 0.2,\n            \"gamma\": 0.5\n        }\n    ]\n\n    results = []\n    \n    # Define time sampling parameters\n    t_min = 0.5\n    t_max = 8.0\n    dt = 0.05\n    # Use np.arange which handles floating point steps robustly\n    t_vals = np.arange(t_min, t_max + dt/2, dt)\n\n    for case in test_cases:\n        A = case[\"A\"]\n        beta = case[\"beta\"]\n        gamma = case[\"gamma\"]\n        N = A.shape[0]\n\n        # 1. Compute theoretical growth rate (r_theory)\n        # Construct the Next-Generation Matrix K\n        K = (beta / gamma) * A\n        \n        # Find the spectral radius of K (leading eigenvalue)\n        # For non-negative matrices (like A and K), the spectral radius is an eigenvalue\n        eigvals_K = np.linalg.eigvals(K)\n        rho_K = np.max(np.abs(eigvals_K))\n        \n        # Calculate r_theory\n        r_theory = gamma * (rho_K - 1)\n\n        # 2. Compute fitted growth rate (r_fit)\n        # Construct the dynamics matrix M\n        M = beta * A - gamma * np.identity(N)\n        \n        # Define initial condition\n        i0 = np.ones(N) / N\n        \n        I_tot_vals = []\n        for t in t_vals:\n            # Evolve the system using the matrix exponential\n            exp_Mt = expm(M * t)\n            i_t = exp_Mt @ i0\n            \n            # Calculate total infected\n            I_tot_t = np.sum(i_t)\n            I_tot_vals.append(I_tot_t)\n        \n        # Take natural log for linear regression\n        y_vals = np.log(np.array(I_tot_vals))\n        \n        # Perform Ordinary Least Squares regression to find the slope\n        # np.polyfit(x, y, 1) returns [slope, intercept]\n        coeffs = np.polyfit(t_vals, y_vals, 1)\n        r_fit = coeffs[0]\n\n        # 3. Compute the absolute difference\n        diff = np.abs(r_fit - r_theory)\n        results.append(diff)\n\n    # Final print statement in the exact required format.\n    # Each number is rounded to exactly 6 decimal places.\n    print(f\"[{','.join([f'{x:.6f}' for x in results])}]\")\n\nsolve()\n```", "id": "3124341"}, {"introduction": "Understanding how network structure influences epidemic spread is not just an academic exercise; it has critical real-world applications for control and mitigation. This final practice puts this knowledge to work by tackling a resource allocation problem: how to most effectively use a limited number of tests to detect infections. By comparing different strategies—from uniform testing to those guided by network centrality—you will quantitatively evaluate the power of network-informed interventions and develop an intuition for designing smarter public health policies [@problem_id:3124329].", "problem": "Consider a simple, undirected, unweighted network of $N$ nodes with adjacency matrix $A \\in \\{0,1\\}^{N \\times N}$, where $A_{ij} = 1$ indicates an edge between node $i$ and node $j$, and $A_{ii} = 0$. Let Degree Centrality (DC) for node $i$ be defined as $c_i = \\sum_{j=1}^{N} A_{ij}$. Suppose that each edge independently carries an exposure that leads to infection with probability $\\alpha \\in [0,1]$. Under the independence assumption across edges, the probability that node $i$ is infected at the snapshot time is $q_i$, which depends on $c_i$ and $\\alpha$. Assume perfect testing: a test always detects infection if present and has no false positives or false negatives.\n\nA testing budget of $B \\in \\mathbb{N}_0$ is available. Consider the following policies to choose which nodes to test:\n\n- Policy $\\mathcal{T}$ (targeted, with replacement): perform $B$ independent draws (with replacement). On each draw, select node $i$ with probability proportional to $c_i$. If $\\sum_{j=1}^{N} c_j = 0$, interpret selection probabilities as uniform over nodes. A node is considered \"tested\" if it appears at least once among the $B$ draws.\n- Policy $\\mathcal{U}$ (uniform, with replacement): perform $B$ independent draws (with replacement), each draw selecting a node uniformly at random from the $N$ nodes. A node is considered \"tested\" if it appears at least once among the $B$ draws.\n- Policy $\\mathcal{D}$ (deterministic top-$B$ without replacement): select up to $B$ distinct nodes with the largest $c_i$ values (ties broken by increasing node index), and test each exactly once. If $B \\ge N$, test all $N$ nodes.\n\nYour task is to compute, for each policy, the expected number of infected nodes that are detected by testing. The computation must begin from the independence of edge exposures and the definition of Degree Centrality, and must proceed via probability laws for repeated independent draws and set inclusion for detection. No shortcut formulas should be assumed in the problem statement; derive the quantities needed from first principles in your solution and program design.\n\nUse the following test suite. For each case, $A$ is specified, as well as $B$ and $\\alpha$. Nodes are indexed from $0$ to $N-1$.\n\n- Case $1$ (general connected network, moderate budget): $N = 6$, \n$$\nA^{(1)} = \\begin{bmatrix}\n0 & 1 & 1 & 0 & 0 & 0 \\\\\n1 & 0 & 1 & 1 & 0 & 0 \\\\\n1 & 1 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 1 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1 & 0 & 1 \\\\\n0 & 0 & 0 & 0 & 1 & 0\n\\end{bmatrix},\\quad B^{(1)} = 3,\\quad \\alpha^{(1)} = 0.2.\n$$\n\n- Case $2$ (regular graph where centralities are equal): $N = 5$, \n$$\nA^{(2)} = \\begin{bmatrix}\n0 & 1 & 0 & 0 & 1 \\\\\n1 & 0 & 1 & 0 & 0 \\\\\n0 & 1 & 0 & 1 & 0 \\\\\n0 & 0 & 1 & 0 & 1 \\\\\n1 & 0 & 0 & 1 & 0\n\\end{bmatrix},\\quad B^{(2)} = 4,\\quad \\alpha^{(2)} = 0.3.\n$$\n\n- Case $3$ (boundary budget): reuse $A^{(1)}$ with $B^{(3)} = 0$ and $\\alpha^{(3)} = 0.7$.\n\n- Case $4$ (star network, large budget): $N = 6$, \n$$\nA^{(4)} = \\begin{bmatrix}\n0 & 1 & 1 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0\n\\end{bmatrix},\\quad B^{(4)} = 20,\\quad \\alpha^{(4)} = 0.1.\n$$\n\nFor each case, compute three values: the expected number of detected infected nodes under $\\mathcal{T}$, under $\\mathcal{U}$, and under $\\mathcal{D}$. Your program should produce a single line of output containing the results for the four cases as a comma-separated list of lists, each inner list in the order $[\\mathcal{T}, \\mathcal{U}, \\mathcal{D}]$, and each numeric value printed with six decimal places, for example \n$$\n\\text{[}[r_{1,\\mathcal{T}},r_{1,\\mathcal{U}},r_{1,\\mathcal{D}}],[r_{2,\\mathcal{T}},r_{2,\\mathcal{U}},r_{2,\\mathcal{D}}],[r_{3,\\mathcal{T}},r_{3,\\mathcal{U}},r_{3,\\mathcal{D}}],[r_{4,\\mathcal{T}},r_{4,\\mathcal{U}},r_{4,\\mathcal{D}}]\\text{]}.\n$$\nNo physical units are involved. Express all results as real numbers (floats). The computation must be scientifically consistent with the independence assumptions described above.", "solution": "The problem is assessed to be valid as it is scientifically grounded in probability theory and network science, is well-posed, and is expressed in objective, formal language. It is self-contained, with all necessary data and definitions provided. We may therefore proceed with the solution.\n\nThe objective is to compute the expected number of detected infected nodes, denoted by $E[X]$, for three different testing policies. Let $N$ be the number of nodes in the network. Let $I_i$ be an indicator random variable for the event that node $i$ is infected, and $T_i$ be an indicator random variable for the event that node $i$ is tested. The number of detected infected nodes is $X = \\sum_{i=0}^{N-1} I_i T_i$.\n\nBy the linearity of expectation, the expected number of detected infected nodes is:\n$$ E[X] = E\\left[\\sum_{i=0}^{N-1} I_i T_i\\right] = \\sum_{i=0}^{N-1} E[I_i T_i] $$\nThe expectation of an indicator variable is the probability of the event it indicates. Thus, $E[I_i T_i] = P(I_i=1 \\text{ and } T_i=1)$. The infection status of a node is determined by the properties of the network and the infection probability $\\alpha$, while the testing status is determined by the testing policy and budget $B$. These two processes are independent. Therefore, we can write:\n$$ P(I_i=1 \\text{ and } T_i=1) = P(I_i=1) \\cdot P(T_i=1) $$\nLet's denote $q_i = P(I_i=1)$ as the probability that node $i$ is infected, and $p_{\\text{test},i} = P(T_i=1)$ as the probability that node $i$ is tested. The expected number of detected infected nodes is then:\n$$ E[X] = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i} $$\nWe must now derive expressions for $q_i$ and $p_{\\text{test},i}$ for each policy from first principles.\n\n**1. Derivation of Infection Probability ($q_i$)**\nThe problem states that each edge independently carries an exposure that leads to infection with probability $\\alpha$. A node $i$ becomes infected if at least one of its neighbors transmits the infection. It is more straightforward to calculate the probability of the complementary event: node $i$ is *not* infected. This occurs if and only if *none* of its neighbors transmit the infection.\n\nLet $c_i$ be the Degree Centrality of node $i$, which is the number of its neighbors.\n$$ c_i = \\sum_{j=0}^{N-1} A_{ij} $$\nFor a single neighbor, the probability of *not* transmitting the infection is $(1-\\alpha)$. Since the exposures from all $c_i$ neighbors are independent events, the probability that none of them transmit the infection to node $i$ is the product of their individual probabilities of non-transmission:\n$$ P(I_i=0) = (1-\\alpha)^{c_i} $$\nThe probability $q_i$ that node $i$ is infected is the complement of this event:\n$$ q_i = P(I_i=1) = 1 - P(I_i=0) = 1 - (1-\\alpha)^{c_i} $$\n\n**2. Derivation of Testing Probability ($p_{\\text{test},i}$) for each Policy**\n\n**Policy $\\mathcal{T}$ (Targeted, with replacement):**\nIn this policy, $B$ independent tests are performed. For each test, a node $i$ is selected with a probability $p_i^{(\\mathcal{T})}$ proportional to its degree centrality $c_i$.\n$$ p_i^{(\\mathcal{T})} = \\frac{c_i}{\\sum_{j=0}^{N-1} c_j} $$\nIf the total degree sum $\\sum_{j=0}^{N-1} c_j = 0$ (a network with no edges), the selection probability is uniform: $p_i^{(\\mathcal{T})} = 1/N$. Let $C_{\\text{tot}} = \\sum_{j=0}^{N-1} c_j$.\nA node $i$ is considered tested if it is selected at least once in the $B$ draws. The probability that node $i$ is *not* selected in a single draw is $(1 - p_i^{(\\mathcal{T})})$. Since the $B$ draws are independent, the probability that node $i$ is *never* selected in $B$ draws is $(1 - p_i^{(\\mathcal{T})})^B$.\nThe probability $p_{\\text{test},i}^{(\\mathcal{T})}$ that node $i$ is tested is the complement:\n$$ p_{\\text{test},i}^{(\\mathcal{T})} = 1 - \\left(1 - \\frac{c_i}{C_{\\text{tot}}}\\right)^B $$\n(with the uniform case handled if $C_{\\text{tot}}=0$).\n\n**Policy $\\mathcal{U}$ (Uniform, with replacement):**\nThis is a simplification of the targeted policy where the selection probability for any node $i$ in a single draw is uniform: $p_i^{(\\mathcal{U})} = 1/N$. Following the same logic as for Policy $\\mathcal{T}$:\n$$ p_{\\text{test},i}^{(\\mathcal{U})} = 1 - \\left(1 - \\frac{1}{N}\\right)^B $$\nNote that this probability is the same for all nodes.\n\n**Policy $\\mathcal{D}$ (Deterministic Top-$B$, without replacement):**\nThis policy is deterministic. A fixed set of nodes $S_D$ is chosen for testing. The nodes are ranked in descending order of their degree centrality $c_i$. Ties are broken by choosing the node with the smaller index. The top $B$ nodes from this ranking are selected. If $B \\ge N$, all nodes are tested.\nFor a node $i$, the \"probability\" of being tested is either $1$ or $0$:\n$$ p_{\\text{test},i}^{(\\mathcal{D})} = \\begin{cases} 1 & \\text{if node } i \\in S_D \\\\ 0 & \\text{if node } i \\notin S_D \\end{cases} $$\nThe set $S_D$ contains the first $\\min(B, N)$ nodes from the ranked list.\n\n**3. Final Computation**\nFor each policy $\\mathcal{P} \\in \\{\\mathcal{T}, \\mathcal{U}, \\mathcal{D}\\}$, the expected number of detected infected nodes is calculated by summing the contributions from each node:\n$$ E[X]_{\\mathcal{P}} = \\sum_{i=0}^{N-1} q_i \\cdot p_{\\text{test},i}^{(\\mathcal{P})} = \\sum_{i=0}^{N-1} \\left(1 - (1-\\alpha)^{c_i}\\right) \\cdot p_{\\text{test},i}^{(\\mathcal{P})} $$\nThis formula, with the specific expressions for $p_{\\text{test},i}^{(\\mathcal{P})}$, is implemented for each test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected number of detected infected nodes for four test cases\n    under three different testing policies.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [0, 1, 1, 0, 0, 0],\n        [1, 0, 1, 1, 0, 0],\n        [1, 1, 0, 1, 0, 0],\n        [0, 1, 1, 0, 1, 0],\n        [0, 0, 0, 1, 0, 1],\n        [0, 0, 0, 0, 1, 0]\n    ])\n\n    A2 = np.array([\n        [0, 1, 0, 0, 1],\n        [1, 0, 1, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 0]\n    ])\n\n    A4 = np.array([\n        [0, 1, 1, 1, 1, 1],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0],\n        [1, 0, 0, 0, 0, 0]\n    ])\n\n    test_cases = [\n        (A1, 3, 0.2),  # Case 1\n        (A2, 4, 0.3),  # Case 2\n        (A1, 0, 0.7),  # Case 3\n        (A4, 20, 0.1)  # Case 4\n    ]\n\n    results = []\n    for A, B, alpha in test_cases:\n        case_results = _calculate_expected_detections(A, B, alpha)\n        results.append(case_results)\n    \n    # Format the final output string as specified.\n    outer_list = []\n    for inner_list in results:\n        formatted_inner = [f\"{v:.6f}\" for v in inner_list]\n        outer_list.append(f\"[{','.join(formatted_inner)}]\")\n    final_output = f\"[{','.join(outer_list)}]\"\n\n    print(final_output)\n\ndef _calculate_expected_detections(A, B, alpha):\n    \"\"\"\n    Calculates the expected detections for a single case (A, B, alpha).\n    Returns a list of three float values for policies T, U, and D.\n    \"\"\"\n    N = A.shape[0]\n    \n    # 1. Calculate degree centrality and infection probabilities\n    degrees = np.sum(A, axis=1)\n    q = 1 - (1 - alpha)**degrees\n    \n    # --- Policy T (Targeted, with replacement) ---\n    total_degree = np.sum(degrees)\n    if B == 0:\n        p_test_T = np.zeros(N)\n    elif total_degree == 0:\n        # Uniform selection if no edges exist\n        p_draw_T = np.full(N, 1/N)\n        p_test_T = 1 - (1 - p_draw_T)**B\n    else:\n        p_draw_T = degrees / total_degree\n        p_test_T = 1 - (1 - p_draw_T)**B\n    \n    exp_detected_T = np.sum(q * p_test_T)\n\n    # --- Policy U (Uniform, with replacement) ---\n    if B == 0:\n        p_test_U_scalar = 0.0\n    else:\n        p_test_U_scalar = 1 - (1 - 1/N)**B\n    \n    exp_detected_U = np.sum(q) * p_test_U_scalar\n\n    # --- Policy D (Deterministic top-B, without replacement) ---\n    exp_detected_D = 0.0\n    if B > 0:\n        # Sort nodes by degree (desc) and then index (asc)\n        node_indices = np.arange(N)\n        # We sort by (-degree, index)\n        ranked_nodes = sorted(node_indices, key=lambda i: (-degrees[i], i))\n        \n        # Select top min(B, N) nodes to test\n        nodes_to_test = ranked_nodes[:min(B, N)]\n        \n        # Sum infection probabilities for tested nodes\n        exp_detected_D = np.sum(q[nodes_to_test])\n        \n    return [exp_detected_T, exp_detected_U, exp_detected_D]\n\nsolve()\n```", "id": "3124329"}]}