{"hands_on_practices": [{"introduction": "Particle-in-Cell simulations are powerful but subject to numerical artifacts arising from spatial discretization. One of the most fundamental of these is the non-physical \"self-force,\" where a particle interacts with the gridded field generated by its own charge, leading to a violation of energy conservation. This exercise provides a crucial theoretical foundation by guiding you through an analytical derivation of the self-force's magnitude, revealing how it depends on the particle's position within a grid cell [@problem_id:296780].", "problem": "In one-dimensional electrostatic Particle-in-Cell (PIC) simulations using linear weighting (also known as Cloud-in-Cell or CIC), a charged particle interacts with the computational grid, giving rise to a non-physical \"self-force\". This force arises because the particle's own charge, when deposited onto the grid, creates a gridded electric field which then acts back on the particle itself after interpolation. This spurious force is a direct consequence of the spatial discretization and is responsible for numerical heating and a violation of energy conservation.\n\nFor a single particle of charge $q$ in an infinite, one-dimensional system with grid spacing $\\Delta x$ and vacuum permittivity $\\epsilon_0$, the potential energy of its own gridded electric field, $U_{self}$, can be shown to vary with its position within a grid cell. The potential is periodic with the grid period $\\Delta x$ and within a given cell, defined by grid nodes at $x_j$ and $x_{j+1}$, it is given by:\n$$\nU_{self}(x) = \\frac{q^2 \\Delta x}{2\\epsilon_0} u(1-u)\n$$\nwhere $u = \\frac{x - x_j}{\\Delta x}$ is the normalized position of the particle within the cell, for $x \\in [x_j, x_{j+1}]$. This energy is zero at the cell boundaries ($u=0$ and $u=1$) and maximum at the cell center ($u=1/2$).\n\nThe conservative force associated with this self-potential is $F_{self}(x) = -\\frac{\\partial U_{self}}{\\partial x}$. This force varies as the particle moves across the cell, and its spatial average over a cell is zero. To quantify the typical magnitude of this force, it is useful to compute its root-mean-square (RMS) value.\n\nDerive the root-mean-square value of the self-force, $F_{RMS}$, for a particle uniformly distributed over a single grid cell.", "solution": "Relevant self-potential and normalized position:  \n$$U_{self}(x)=\\frac{q^2\\Delta x}{2\\epsilon_0}\\,u(1-u),\\qquad u=\\frac{x-x_j}{\\Delta x}.$$  \nSelf‐force:  \n$$F_{self}(x)=-\\frac{\\partial U_{self}}{\\partial x}\n=-\\frac{1}{\\Delta x}\\frac{\\partial}{\\partial u}\\Bigl(\\frac{q^2\\Delta x}{2\\epsilon_0}u(1-u)\\Bigr)$$  \n$$\\;=\\;-\\,\\frac{q^2}{2\\epsilon_0}(1-2u)\n=\\frac{q^2}{2\\epsilon_0}(2u-1).$$  \n\nSquare and average over $u\\in[0,1]$:  \n$$F_{self}^2=\\frac{q^4}{4\\epsilon_0^2}(2u-1)^2,$$  \n$$\\langle F^2\\rangle=\\int_0^1\\frac{q^4}{4\\epsilon_0^2}(2u-1)^2\\,du\n=\\frac{q^4}{4\\epsilon_0^2}\\int_0^1(4u^2-4u+1)\\,du\n=\\frac{q^4}{4\\epsilon_0^2}\\cdot\\frac{1}{3}.$$\n\nThus the RMS self‐force is  \n$$F_{RMS}=\\sqrt{\\langle F^2\\rangle}\n=\\frac{q^2}{2\\epsilon_0}\\sqrt{\\frac{1}{3}}\n=\\frac{q^2}{2\\sqrt{3}\\,\\epsilon_0}.$$", "answer": "$$\\boxed{\\frac{q^2}{2\\sqrt{3}\\,\\epsilon_0}}$$", "id": "296780"}, {"introduction": "Building on the analytical concept of the self-force, this practice challenges you to measure it directly in a computational experiment. You will implement a minimal 1D PIC code to quantify the spurious acceleration on a single particle in a vacuum, which should ideally be zero [@problem_id:3171279]. This hands-on task bridges theory and practice, demonstrating how numerical parameters like grid spacing and particle shape order directly impact the accuracy and physical fidelity of a simulation.", "problem": "You are asked to implement a minimal one-dimensional (1D) Particle-In-Cell (PIC) simulation in vacuum to quantify self-force errors. In a physically correct vacuum, a single isolated macro-particle should experience zero acceleration because there are no external fields and a particle does not act on itself in the continuous theory. However, in a discrete Particle-In-Cell (PIC) system, finite grid spacing and particle shape cause a non-zero spurious self-force. Your task is to measure the magnitude of this spurious acceleration as a function of the particle shape order and the grid spacing.\n\nStart from fundamental electromagnetic laws. Use Gauss’s law in electrostatics, which states that the divergence of the electric field equals the charge density divided by the permittivity, i.e., $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$. In one spatial dimension with periodic boundary conditions and time-independent fields, use the electrostatic potential $\\phi$ such that $\\mathbf{E} = -\\nabla \\phi$ and $\\partial^2 \\phi / \\partial x^2 = -\\rho / \\varepsilon_0$. Work in normalized units such that the domain length, the particle charge, the particle mass, and the vacuum permittivity are all unity, i.e., $L = 1$, $q = 1$, $m = 1$, and $\\varepsilon_0 = 1$. Under these normalized units, the acceleration equals the electric field evaluated at the particle’s position, i.e., $a = E(x)$.\n\nImplement the following algorithm in a program:\n\n- Domain and grid: Use a periodic domain of length $L = 1$. Discretize using $N$ uniformly spaced nodes at positions $x_i = i \\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$ where $\\Delta x = L/N$.\n- Single particle: Place a single macro-particle with charge $q = 1$ and mass $m = 1$ at position $x_0 \\in [0, L)$.\n- Charge assignment (deposition): Deposit the particle’s charge onto the grid nodes using a B-spline shape function of order $S_m \\in \\{0, 1, 2\\}$, with periodic wrapping. Denote the normalized distance `r = (x_0 - x_i)/\\Delta x` reduced to $(-\\tfrac{1}{2}N, \\tfrac{1}{2}N)$ via periodicity and then to the local cell-centered interval using the minimal periodic image. The shape weights `w_i` must satisfy $\\sum_i w_i = 1$. Use the following standard one-dimensional shape functions:\n  - Order $S_m = 0$ (Nearest Grid Point, NGP): $W_0(r) = 1$ if $|r|  \\tfrac{1}{2}$ and $0$ otherwise.\n  - Order $S_m = 1$ (Cloud-In-Cell, CIC): $W_1(r) = 1 - |r|$ for $|r|  1$ and $0$ otherwise.\n  - Order $S_m = 2$ (Triangular Shaped Cloud, TSC): \n    - $W_2(r) = \\tfrac{3}{4} - r^2$ for $|r| \\le \\tfrac{1}{2}$,\n    - $W_2(r) = \\tfrac{1}{2} \\left(\\tfrac{3}{2} - |r|\\right)^2$ for $\\tfrac{1}{2}  |r|  \\tfrac{3}{2}$,\n    - $W_2(r) = 0$ otherwise.\n  Form the grid charge density by $\\rho_i = q \\, w_i / \\Delta x$.\n- Field solve (electrostatics with periodic boundary conditions): Solve the discrete periodic Poisson system using the discrete Fourier transform. Let $\\hat{\\rho}(k)$ be the discrete Fourier transform of $\\rho_i$. For each nonzero angular wavenumber $k$, set $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$. For $k = 0$, set $\\hat{E}(0) = 0$ to enforce zero-mean field consistent with periodicity. Inverse transform to get the real-space field $E_i$ at grid nodes.\n- Field interpolation to particle: Interpolate the electric field back to the particle position using the same shape weights, $E(x_0) = \\sum_i E_i \\, w_i$.\n- Spurious acceleration: Compute the acceleration $a = q E(x_0)/m$ and report its magnitude $|a|$ as a dimensionless number.\n\nUse normalized units as specified (all quantities dimensionless), and report accelerations as dimensionless floats rounded to $10$ decimal places.\n\nTest suite. Run your program on the following parameter sets, each specified by $(N, S_m, x_0)$ with $L = 1$:\n- Case $1$: $(16, 0, 0.13)$\n- Case $2$: $(16, 1, 0.13)$\n- Case $3$: $(16, 2, 0.13)$\n- Case $4$: $(64, 2, 0.13)$\n- Case $5$: $(64, 2, 0.5)$\n- Case $6$: $(32, 1, 1/(2 \\cdot 32))$ which equals $(32, 1, 0.015625)$\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test suite and each value rounded to $10$ decimal places (e.g., $[0.1230000000,0.0456000000,\\dots]$).", "solution": "The user wants to implement a one-dimensional Particle-In-Cell (PIC) simulation to compute the spurious self-force on a single particle in a periodic domain.\n\n### Step 1: Problem Validation\n\n**1.1. Extracted Givens**\n- **Physics Model:** 1D electrostatics, periodic boundary conditions.\n- **Governing Equations:** $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$, which in 1D with $\\mathbf{E} = -\\nabla \\phi$ becomes $\\partial^2 \\phi / \\partial x^2 = -\\rho / \\varepsilon_0$.\n- **Normalized Units:** Domain length $L=1$, particle charge $q=1$, particle mass $m=1$, vacuum permittivity $\\varepsilon_0=1$. This implies acceleration $a = E(x)$.\n- **Discretization:**\n    - Domain $[0, L)$ discretized into $N$ grid cells of size $\\Delta x = L/N$.\n    - Grid nodes at $x_i = i \\Delta x$ for $i \\in \\{0, \\dots, N-1\\}$.\n- **Particle:** A single particle at position $x_0$.\n- **Algorithm:**\n    1.  **Charge Deposition:** Assign particle charge $q$ to grid nodes $i$ using weights $w_i$. The weights are derived from a B-spline shape function $W_{S_m}(r)$ of order $S_m \\in \\{0, 1, 2\\}$, where $r = (x_0 - x_i)/\\Delta x$ calculated using the minimal periodic image. The grid charge density is $\\rho_i = q w_i / \\Delta x$.\n        - Order $S_m = 0$ (NGP): $W_0(r) = 1$ for $|r|  0.5$, $0$ otherwise.\n        - Order $S_m = 1$ (CIC): $W_1(r) = 1 - |r|$ for $|r|  1$, $0$ otherwise.\n        - Order $S_m = 2$ (TSC): $W_2(r) = \\tfrac{3}{4} - r^2$ for $|r| \\le 0.5$; $W_2(r) = \\tfrac{1}{2}(\\tfrac{3}{2} - |r|)^2$ for $0.5  |r|  1.5$; $0$ otherwise.\n    2.  **Field Solve:** Solve for the electric field $E_i$ on the grid using the discrete Fourier transform (DFT).\n        - Let $\\hat{\\rho}(k)$ be the DFT of $\\rho_i$.\n        - The DFT of the electric field is $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$ for non-zero angular wavenumber $k$.\n        - $\\hat{E}(k=0) = 0$.\n        - $E_i$ is obtained via inverse DFT of $\\hat{E}(k)$.\n    3.  **Field Interpolation:** Interpolate the grid field to the particle's position using the same weights: $E(x_0) = \\sum_i E_i w_i$.\n    4.  **Acceleration:** Calculate acceleration $a = q E(x_0)/m$ and report $|a|$.\n- **Test Cases:**\n    - $(N, S_m, x_0) = (16, 0, 0.13)$\n    - $(N, S_m, x_0) = (16, 1, 0.13)$\n    - $(N, S_m, x_0) = (16, 2, 0.13)$\n    - $(N, S_m, x_0) = (64, 2, 0.13)$\n    - $(N, S_m, x_0) = (64, 2, 0.5)$\n    - $(N, S_m, x_0) = (32, 1, 0.015625)$\n- **Output Format:** A single line with a comma-separated list of results in brackets, rounded to $10$ decimal places.\n\n**1.2. Validation**\nThe problem is scientifically grounded, describing a standard numerical experiment in computational plasma physics. The physical and mathematical framework (1D electrostatics, Poisson's equation, periodic boundaries) is sound. The specified algorithm is a well-established pseudo-spectral Particle-In-Cell method. All parameters, definitions, and equations are provided, making the problem self-contained and well-posed. The wording is objective and unambiguous. The test cases are well-chosen, including cases of high symmetry ($x_0$ on a grid node, $x_0$ at a cell center) where the self-force is expected to be zero, providing a strong correctness check. The problem does not violate any of the invalidity criteria.\n\n**1.3. Verdict**\nThe problem is **valid**.\n\n### Step 2: Solution Design\n\nThe implementation will follow the specified algorithm precisely. A primary function, `calculate_self_force(N, Sm, x0)`, will encapsulate the logic for a single test case. Helper functions will be defined for the B-spline shape functions. The overall procedure is as follows:\n\n1.  **Initialization:** Set physical constants ($L, q, m$) and derive grid parameters ($\\Delta x$).\n2.  **Weight Calculation:** A helper function, `get_weights`, will compute the weights $\\{w_i\\}$ for a given particle position $x_0$, grid size $N$, and shape order $S_m$. This involves calculating the normalized periodic distance $r = (x_0 - x_i)/\\Delta x$ for each grid node $i$ and applying the corresponding shape function $W_{S_m}(r)$.\n3.  **Charge Deposition:** The grid charge density $\\rho$ is calculated as $\\rho_i = q \\cdot w_i / \\Delta x$. As $q=1$, this simplifies to $\\rho_i = w_i / \\Delta x$.\n4.  **Field Calculation in Fourier Space:**\n    - The `numpy.fft.fft` function is used to compute the DFT of `rho_grid`, yielding `rho_hat`.\n    - The corresponding angular wavenumbers $k$ are obtained using `numpy.fft.fftfreq` scaled by $2\\pi$ and the grid spacing.\n    - The electric field in Fourier space, `E_hat`, is calculated using the provided formula $\\hat{E}(k) = -\\mathrm{i} \\, \\hat{\\rho}(k) / k$. Special care is taken for the $k=0$ mode, which is set to zero, to avoid division by zero and enforce a zero-mean field.\n5.  **Field in Real Space:** The grid electric field $E_i$ is recovered by applying the inverse DFT (`numpy.fft.ifft`) to `E_hat` and taking the real part.\n6.  **Force Interpolation:** The electric field at the particle position, $E(x_0)$, is computed by interpolating the grid field using the same weights: $E(x_0) = \\sum_i E_i w_i$. This is a dot product between the grid field vector and the weights vector.\n7.  **Acceleration Calculation:** With normalized units ($q=1, m=1$), the acceleration is simply equal to the interpolated field, $a = E(x_0)$. The magnitude $|a|$ is the required result.\n8.  **Execution Loop:** A main function, `solve`, will iterate through the provided test suite, call `calculate_self_force` for each case, format the results to $10$ decimal places, and print them in the specified list format.\n\nFor cases 5 ($x_0=0.5$ on a grid node) and 6 ($x_0=0.5 \\Delta x$ at a cell center), the force is expected to be zero due to symmetry. Any non-zero result will be on the order of machine floating-point precision.", "answer": "```python\nimport numpy as np\n\ndef _get_shape_function(Sm):\n    \"\"\"Returns the appropriate B-spline shape function for a given order.\"\"\"\n    if Sm == 0:\n        # Order 0: Nearest Grid Point (NGP)\n        def W(r):\n            ar = np.abs(r)\n            if ar  0.5:\n                return 1.0\n            return 0.0\n    elif Sm == 1:\n        # Order 1: Cloud-In-Cell (CIC) or Linear\n        def W(r):\n            ar = np.abs(r)\n            if ar  1.0:\n                return 1.0 - ar\n            return 0.0\n    elif Sm == 2:\n        # Order 2: Triangular Shaped Cloud (TSC) or Quadratic\n        def W(r):\n            ar = np.abs(r)\n            if ar = 0.5:\n                return 0.75 - ar**2\n            elif ar  1.5:\n                return 0.5 * (1.5 - ar)**2\n            return 0.0\n    else:\n        raise ValueError(\"Shape function order Sm must be 0, 1, or 2.\")\n    return W\n\ndef get_weights(N, Sm, x0, delta_x, L):\n    \"\"\"\n    Calculates the charge weights on the grid for a single particle.\n    The weights are calculated based on the particle's position relative to grid nodes.\n    \"\"\"\n    weights = np.zeros(N)\n    shape_func = _get_shape_function(Sm)\n    \n    # Vectorized calculation for efficiency\n    grid_indices = np.arange(N)\n    grid_positions = grid_indices * delta_x\n    \n    # Calculate distance from particle to each grid node\n    d = x0 - grid_positions\n    \n    # Apply periodic boundary condition to find the minimum image distance\n    d_periodic = (d + L/2) % L - L/2\n    \n    # Normalize distance by grid spacing\n    r = d_periodic / delta_x\n    \n    # Apply the shape function to the normalized distances\n    # This is faster than a Python loop for large N.\n    v_shape_func = np.vectorize(shape_func)\n    weights = v_shape_func(r)\n    \n    # As a property of B-splines (partition of unity), the sum should be 1.\n    # A small tolerance is used to account for floating-point inaccuracies.\n    assert np.isclose(np.sum(weights), 1.0), \"Sum of weights is not 1.\"\n\n    return weights\n\ndef calculate_self_force(N, Sm, x0):\n    \"\"\"\n    Implements the 1D PIC algorithm to find the spurious self-force on a single particle.\n    \"\"\"\n    # 1. Domain and particle properties (normalized units)\n    L = 1.0\n    q = 1.0\n    m = 1.0\n    delta_x = L / N\n\n    # 2. Charge Assignment (Deposition)\n    # Get the weights for each grid node. These same weights will be used for interpolation.\n    weights = get_weights(N, Sm, x0, delta_x, L)\n\n    # Calculate charge density on the grid: rho_i = q * w_i / delta_x\n    rho_grid = (q / delta_x) * weights\n\n    # 3. Field Solve (using Discrete Fourier Transform)\n    # Perform DFT on the charge density\n    rho_hat = np.fft.fft(rho_grid)\n    \n    # Get the corresponding frequencies and angular wavenumbers\n    # The sample spacing 'd' for fftfreq is the grid spacing delta_x\n    freqs = np.fft.fftfreq(N, d=delta_x)\n    k = 2.0 * np.pi * freqs\n    \n    # Calculate the electric field in Fourier space\n    E_hat = np.zeros_like(rho_hat, dtype=complex)\n    \n    # Create a mask for non-zero wavenumbers to avoid division by zero\n    k_nonzero_mask = (k != 0)\n    \n    # E_hat(k) = -i * rho_hat(k) / k for k != 0\n    E_hat[k_nonzero_mask] = -1j * rho_hat[k_nonzero_mask] / k[k_nonzero_mask]\n    \n    # E_hat(k=0) must be 0, which is handled by the mask and np.zeros_like initialization.\n    \n    # Perform Inverse DFT to get the electric field on the grid\n    E_grid = np.real(np.fft.ifft(E_hat))\n\n    # 4. Field Interpolation to Particle\n    # Interpolate the electric field back to the particle's position using the same weights\n    # E(x0) = sum(E_i * w_i)\n    E_particle = np.dot(E_grid, weights)\n    \n    # 5. Spurious Acceleration\n    # a = q * E(x0) / m. With normalized units, a = E(x0)\n    acceleration = E_particle / m\n    \n    return np.abs(acceleration)\n\ndef solve():\n    \"\"\"\n    Runs the simulation for the specified test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        # (N, Sm, x0)\n        (16, 0, 0.13),\n        (16, 1, 0.13),\n        (16, 2, 0.13),\n        (64, 2, 0.13),\n        (64, 2, 0.5),\n        (32, 1, 1.0 / (2.0 * 32.0)), # which is 0.015625\n    ]\n\n    results = []\n    for N, Sm, x0 in test_cases:\n        accel_magnitude = calculate_self_force(N, Sm, x0)\n        results.append(f\"{accel_magnitude:.10f}\")\n        \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the main function\nsolve()\n```", "id": "3171279"}, {"introduction": "Having explored a key single-particle numerical artifact, we now advance to a full, dynamic simulation of a collective plasma phenomenon. In this culminating practice, you will implement a complete PIC code to model the two-stream instability, a classic plasma physics problem [@problem_id:3171208]. The core task is to verify one of the most fundamental principles of physics—the conservation of momentum—by tracking the system's center-of-mass, a critical step in validating any scientific simulation.", "problem": "You must write a complete, runnable program that performs a one-dimensional electrostatic Particle-In-Cell (PIC) simulation to validate momentum conservation by colliding two equal, counter-streaming beams and measuring center-of-mass drift over time. The program must implement a self-consistent field computation and particle push using fundamental physical laws and core numerical definitions. All quantities are to be expressed in dimensionless normalized units where the particle mass is $m=1$, the particle charge is $q=-1$ for electrons, the permittivity of free space is $\\epsilon_0=1$, and the domain length is $L=1$, so the final results are dimensionless. Use periodic boundary conditions on the interval $[0,L)$.\n\nStart from the following base principles:\n- Newton's second law: $m \\, \\frac{d v_i}{d t} = q \\, E(x_i)$ for each particle index $i$.\n- Kinematics: $\\frac{d x_i}{d t} = v_i$.\n- Electrostatics with a uniform ion background ensuring neutrality: the electric potential $\\phi(x)$ satisfies the one-dimensional Poisson equation $\\frac{d^2 \\phi}{d x^2} = -\\frac{\\rho(x)}{\\epsilon_0}$, and the electric field satisfies $E(x) = -\\frac{d \\phi}{d x}$, where $\\rho(x)$ is the charge density.\n- Discrete field solve in Fourier space using the Fast Fourier Transform (FFT): for wavenumber $k \\neq 0$, the Fourier coefficients obey $\\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}$ and $E_k = - i k \\phi_k$, with the $k=0$ mode set to zero to remove the uniform background component.\n\nImplement the Particle-In-Cell (PIC) method (Particle-In-Cell (PIC)) with these numerical components:\n- Cloud-In-Cell (CIC) deposition and interpolation (Cloud-In-Cell (CIC)): deposit particle charges to the grid to obtain $\\rho(x)$, and interpolate $E(x)$ from the grid to particle positions using the same linear weights.\n- A leapfrog time integrator for particles: velocities are defined at half time steps and positions at integer time steps, specifically $v_{i}^{n+\\frac{1}{2}} = v_{i}^{n-\\frac{1}{2}} + \\frac{q}{m} E(x_i^n) \\Delta t$ and $x_i^{n+1} = x_i^n + v_{i}^{n+\\frac{1}{2}} \\Delta t$, with periodic wrapping $x \\mapsto x \\bmod L$.\n\nInitialization:\n- Place $N$ electrons uniformly at random in $[0,L)$.\n- Assign half the electrons the constant velocity $+v_0$ and the other half $-v_0$ to form two equal counter-streaming beams.\n- Include a uniform ion background charge density that exactly cancels the mean electron charge density so the system is overall neutral.\n\nMeasurement target:\n- Let $P(t) = \\sum_{i=1}^{N} m \\, v_i(t)$ denote the total momentum, and let $V_{\\mathrm{cm}}(t) = \\frac{P(t)}{N m}$ denote the center-of-mass velocity. Using $X_{\\mathrm{cm}}(t) - X_{\\mathrm{cm}}(0) = \\int_0^t V_{\\mathrm{cm}}(t') \\, dt'$, numerically integrate $V_{\\mathrm{cm}}(t)$ over the simulation time to obtain the center-of-mass displacement $S(t)$. Report the maximum absolute center-of-mass displacement over the simulated time, normalized by the domain length $L$, i.e., $D = \\max_t \\frac{|S(t)|}{L}$.\n\nYour program must:\n1. Implement the above PIC algorithm in one dimension with periodic boundary conditions and a spectral Poisson solver using FFT.\n2. Use Cloud-In-Cell deposition and interpolation consistently.\n3. Use a leapfrog scheme for particle updates that initializes $v^{\\frac{1}{2}}$ with a half-step acceleration from the initial field.\n4. For reproducibility, use a fixed pseudorandom seed for each test case.\n\nTest Suite:\nRun your program for the following parameter sets, returning one result per case:\n- Case 1 (general case): $N=800$, $N_g=128$, $\\Delta t=0.01$, $T=400$ steps, $v_0=0.2$, $L=1$, seed $= 12345$.\n- Case 2 (smaller time step): $N=800$, $N_g=128$, $\\Delta t=0.005$, $T=400$ steps, $v_0=0.2$, $L=1$, seed $= 12346$.\n- Case 3 (coarser grid and fewer particles): $N=200$, $N_g=64$, $\\Delta t=0.01$, $T=400$ steps, $v_0=0.2$, $L=1$, seed $= 12347$.\n- Case 4 (larger time step and coarser grid): $N=800$, $N_g=64$, $\\Delta t=0.015$, $T=400$ steps, $v_0=0.2$, $L=1$, seed $= 12348$.\n\nOutput Specification:\n- For each case, compute $D = \\max_t \\frac{|S(t)|}{L}$ over the entire simulation.\n- Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places, for example, \"[0.000001,0.000002,0.000100,0.000500]\".\n- All returned values are dimensionless floats.\n\nScientific realism and constraints:\n- Use only the given fundamental principles and numerical constructs.\n- Ensure deposition and interpolation use the same linear weights.\n- Enforce periodic boundary conditions.\n- Use a spectral field solve that sets the $k=0$ mode to zero to avoid singularities and remove the uniform background.\n\nNo external input or files are allowed. The code must be entirely self-contained and executable.", "solution": "The user's problem statement has been analyzed and is determined to be **valid**. It is scientifically grounded, self-contained, and well-posed. The task is to implement a one-dimensional electrostatic Particle-In-Cell (PIC) simulation to quantify the numerical error in momentum conservation for a two-stream instability scenario.\n\n### 1. Principle of the Particle-In-Cell Method\n\nThe Particle-In-Cell (PIC) method is a numerical technique used to simulate the dynamics of a plasma, which consists of charged particles interacting via self-generated electromagnetic fields. The simulation evolves the system by coupling the particle motion (governed by the Lorentz force) to the field evolution (governed by Maxwell's equations) in a self-consistent loop. In this problem, we consider an electrostatic system, simplifying the field equations to Poisson's equation. The core PIC cycle consists of four main steps:\n\n1.  **Charge Deposition**: The charges of discrete 'macro-particles' are deposited onto a computational grid to compute a continuous charge density field, $\\rho(x)$.\n2.  **Field Solve**: The electric field, $E(x)$, is computed on the grid by solving Poisson's equation using the charge density from the previous step.\n3.  **Force Interpolation**: The electric field is interpolated from the grid nodes back to the continuous particle positions.\n4.  **Particle Push**: The particles are advanced in time by integrating their equations of motion, using the interpolated forces.\n\n### 2. Numerical Implementation Details\n\nThe simulation is implemented following the specifications, using dimensionless units where particle mass $m=1$, particle charge $q=-1$, permittivity of free space $\\epsilon_0=1$, and domain length $L=1$.\n\n#### 2.1. Charge Deposition and Force Interpolation\n\nWe use the Cloud-In-Cell (CIC) scheme, a first-order (linear) weighting method. For a particle at position $x_p$ located in the grid cell between nodes $x_j=j\\Delta x$ and $x_{j+1}=(j+1)\\Delta x$, where $\\Delta x = L/N_g$ is the grid spacing, its charge is distributed between these two nodes. Let $j = \\lfloor x_p/\\Delta x \\rfloor$ be the index of the left grid node. The fractional distance to the next node is $h = (x_p/\\Delta x) - j$. The particle's charge $q_p$ is then deposited as:\n- $q_j = q_p (1-h)$ to node $j$.\n- $q_{j+1} = q_p h$ to node $j+1$.\n\nThe total charge on each grid node is the sum of contributions from all particles. The charge density is then $\\rho_j = Q_j / \\Delta x$, where $Q_j$ is the total charge on node $j$.\nFor force interpolation, the same linear weighting factors are used to find the electric field at the particle's position:\n$$\nE(x_p) = E_j(1-h) + E_{j+1}h\n$$\nwhere $E_j$ and $E_{j+1}$ are the electric fields at nodes $j$ and $j+1$.\n\n#### 2.2. Spectral Field Solve\n\nPoisson's equation in one dimension, $\\frac{d^2\\phi}{dx^2} = -\\frac{\\rho}{\\epsilon_0}$, becomes an algebraic equation in Fourier space. Taking the Fourier transform yields:\n$$\n(-k^2) \\phi_k = -\\frac{\\rho_k}{\\epsilon_0} \\implies \\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}\n$$\nwhere $k$ is the wavenumber. Similarly, the relation $E = -\\frac{d\\phi}{dx}$ becomes $E_k = -i k \\phi_k$. The algorithm is:\n1.  Compute $\\rho_j$ on the grid.\n2.  Compute its discrete Fourier transform $\\rho_k = \\text{FFT}(\\rho_j)$.\n3.  The wavenumbers corresponding to the grid are $k_m = \\frac{2\\pi m}{L}$ for integer modes $m$. For the discrete FFT, these are generated via `fftfreq`.\n4.  For $k \\neq 0$, calculate $\\phi_k = \\frac{\\rho_k}{\\epsilon_0 k^2}$. The mode $k=0$, which corresponds to the average potential, is set to zero ($\\phi_{k=0}=0$) consistent with the overall charge neutrality of the system (electrons plus a uniform ion background). This avoids a division-by-zero singularity.\n5.  Calculate the electric field transform $E_k = -i k \\phi_k$.\n6.  Compute the inverse Fourier transform $E_j = \\text{IFFT}(E_k)$ to get the electric field on the grid.\n\n#### 2.3. Particle Mover: The Leapfrog Integrator\n\nThe leapfrog method is a second-order accurate time integration scheme that is canonical (conserves phase space volume) for Hamiltonian systems. It staggers positions and velocities in time: positions are defined at integer time steps ($t^n = n\\Delta t$), while velocities are defined at half time steps ($t^{n \\pm 1/2} = (n \\pm 1/2)\\Delta t$). The update equations are:\n$$\nv_i^{n+\\frac{1}{2}} = v_i^{n-\\frac{1}{2}} + \\frac{q}{m} E(x_i^n) \\Delta t\n$$\n$$\nx_i^{n+1} = x_i^n + v_i^{n+\\frac{1}{2}} \\Delta t\n$$\nPeriodic boundary conditions are applied to the particle positions: $x_i \\rightarrow x_i \\pmod L$.\n\nTo initialize this scheme, we start with positions $x_i^0$ and velocities $v_i^0$ at $t=0$. The main loop requires velocities at half-steps. We require $v_i^{-1/2}$ to begin the first step ($n=0$). By centering the initial velocity $v_i^0 = \\frac{1}{2}(v_i^{-1/2} + v_i^{1/2})$ and using the update rule, we can derive an expression for the required starting velocity:\n$$\nv_i^{-1/2} = v_i^0 - \\frac{1}{2}\\frac{q}{m} E(x_i^0) \\Delta t\n$$\nThis involves a \"kick-back\" half-step using the electric field calculated from the initial particle positions.\n\n### 3. Measurement of Center-of-Mass Drift\n\nThe total momentum of the system should be conserved because only internal forces are present. Any change in total momentum is due to numerical errors, such as the imperfect cancellation of self-forces in a discrete system. We measure this error by tracking the center-of-mass displacement.\n\nAt each integer time step $n$, the velocity $v_i^n$ is needed. It is calculated by averaging the half-step velocities:\n$$\nv_i^n = \\frac{1}{2} (v_i^{n-\\frac{1}{2}} + v_i^{n+\\frac{1}{2}})\n$$\nThe center-of-mass velocity is then $V_{\\mathrm{cm}}^n = \\frac{\\sum_i m v_i^n}{N m}$. The displacement $S(t)$ is the time integral of $V_{\\mathrm{cm}}$, which we approximate numerically as a cumulative sum:\n$$\nS^k = \\sum_{n=0}^{k-1} V_{\\mathrm{cm}}^n \\Delta t\n$$\nThe metric to be reported is the maximum absolute displacement over the simulation, normalized by the domain length: $D = \\frac{1}{L} \\max_{k} |S^k|$. For an ideal simulation, $D=0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_pic_simulation(N, Ng, dt, T_steps, v0, L, seed):\n    \"\"\"\n    Performs a 1D electrostatic Particle-In-Cell (PIC) simulation.\n\n    Args:\n        N (int): Number of particles.\n        Ng (int): Number of grid points.\n        dt (float): Time step.\n        T_steps (int): Total number of time steps.\n        v0 (float): Initial beam speed.\n        L (float): Length of the periodic domain.\n        seed (int): Seed for the pseudorandom number generator.\n\n    Returns:\n        float: The maximum absolute center-of-mass displacement normalized by L.\n    \"\"\"\n    # 1. Define constants and simulation parameters\n    m = 1.0  # Particle mass\n    q = -1.0  # Particle charge\n    eps0 = 1.0 # Permittivity of free space\n    dx = L / Ng   # Grid spacing\n\n    # 2. Grid and k-space setup\n    # Define wavenumbers for the spectral solver.\n    k_vec = 2 * np.pi / L * np.fft.fftfreq(Ng, d=dx)\n    k_squared = k_vec**2\n    # Pre-calculate indices of non-zero k modes to avoid division by zero.\n    non_zero_k_indices = k_squared != 0\n\n    # 3. Particle initialization\n    rng = np.random.default_rng(seed)\n    # Uniformly random positions in [0, L)\n    pos = rng.random(N, dtype=np.float64) * L\n    # Two counter-streaming beams\n    vel = np.full(N, v0, dtype=np.float64)\n    vel[N // 2:] = -v0\n\n    # 4. Leapfrog Initialization\n    # To start the leapfrog integrator, we need v^{-1/2}.\n    # We first compute the initial electric field E(x^0).\n    \n    # 4a. Initial charge deposition (CIC)\n    rho = np.zeros(Ng, dtype=np.float64)\n    j_indices = (pos / dx).astype(int)\n    h = (pos / dx) - j_indices\n    w_left = 1.0 - h\n    w_right = h\n    np.add.at(rho, j_indices, q * w_left)\n    np.add.at(rho, (j_indices + 1) % Ng, q * w_right)\n    rho /= dx  # Convert charge to charge density\n\n    # 4b. Initial field solve (spectral)\n    rho_k = np.fft.fft(rho)\n    phi_k = np.zeros_like(rho_k)\n    phi_k[non_zero_k_indices] = rho_k[non_zero_k_indices] / (eps0 * k_squared[non_zero_k_indices])\n    E_k = -1j * k_vec * phi_k\n    E_grid = np.fft.ifft(E_k).real\n\n    # 4c. Initial force interpolation and velocity kick-back\n    E_p = E_grid[j_indices] * w_left + E_grid[(j_indices + 1) % Ng] * w_right\n    a0 = (q / m) * E_p\n    vel_half = vel - 0.5 * a0 * dt  # This is v^{-1/2}\n\n    # 5. Measurement initialization\n    s_cm = 0.0\n    max_s_cm_abs = 0.0\n\n    # 6. Main PIC Loop\n    for _ in range(T_steps):\n        # At the start of step n, we have pos (x^n) and vel_half (v^{n-1/2})\n        \n        # 6a. Charge Deposition (CIC)\n        rho.fill(0)\n        j_indices = (pos / dx).astype(int)\n        h = (pos / dx) - j_indices\n        w_left = 1.0 - h\n        w_right = h\n        np.add.at(rho, j_indices, q * w_left)\n        np.add.at(rho, (j_indices + 1) % Ng, q * w_right)\n        rho /= dx\n        \n        # 6b. Field Solve (spectral)\n        rho_k = np.fft.fft(rho)\n        phi_k.fill(0)\n        phi_k[non_zero_k_indices] = rho_k[non_zero_k_indices] / (eps0 * k_squared[non_zero_k_indices])\n        E_k = -1j * k_vec * phi_k\n        E_grid = np.fft.ifft(E_k).real\n\n        # 6c. Force Interpolation (CIC)\n        E_p = E_grid[j_indices] * w_left + E_grid[(j_indices + 1) % Ng] * w_right\n        an = (q / m) * E_p # Acceleration a^n\n\n        # 6d. Particle Push (Leapfrog) - Velocity update\n        vel_next_half = vel_half + an * dt # This gives v^{n+1/2}\n\n        # 6e. Measurement\n        # Get velocity at integer time step n: v^n = 0.5 * (v^{n-1/2} + v^{n+1/2})\n        vel_full = 0.5 * (vel_half + vel_next_half)\n        total_momentum = np.sum(m * vel_full)\n        v_cm = total_momentum / (N * m)\n        s_cm += v_cm * dt\n        max_s_cm_abs = max(max_s_cm_abs, abs(s_cm))\n\n        # 6f. Particle Push (Leapfrog) - Position update\n        pos = (pos + vel_next_half * dt) % L # This gives x^{n+1}\n        \n        # Update velocity for the next iteration\n        vel_half = vel_next_half\n        \n    return max_s_cm_abs / L\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, Ng, dt, T_steps, v0, L, seed)\n        (800, 128, 0.01, 400, 0.2, 1, 12345),\n        (800, 128, 0.005, 400, 0.2, 1, 12346),\n        (200, 64, 0.01, 400, 0.2, 1, 12347),\n        (800, 64, 0.015, 400, 0.2, 1, 12348),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_pic_simulation(*params)\n        results.append(result)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n```", "id": "3171208"}]}