{"hands_on_practices": [{"introduction": "The \"butterfly effect,\" or sensitive dependence on initial conditions, is a hallmark of chaos. This practice provides a tangible demonstration of this principle by exploring how minuscule computational rounding errors can lead to dramatically different outcomes. You will simulate the famous Lorenz system twice, once using single-precision and once using double-precision floating-point numbers, and observe how the two trajectories diverge over time. This exercise [@problem_id:3105374] makes the abstract concept of chaos concrete, introducing the idea of a \"shadowing time\" which represents the limited horizon of predictability in any numerical simulation of a chaotic system.", "problem": "Consider the Lorenz initial value problem defined by the ordinary differential equation (ODE) system\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad \\frac{dy}{dt} = x(\\rho - z) - y, \\quad \\frac{dz}{dt} = xy - \\beta z,\n$$\nwhere $x$, $y$, and $z$ are state variables and $\\sigma$, $\\rho$, and $\\beta$ are fixed real parameters. This system is a canonical chaotic dynamical system. In a chaotic system, small perturbations in the state or computation grow over time, leading to divergence of trajectories. Floating-point roundoff and truncation errors in numerical integration act as such perturbations.\n\nYour task is to write a complete, runnable computer program that:\n- Simulates the Lorenz system using a fixed-step numerical integrator derived from first principles for the ODE initial value problem. Use a method consistent with the fourth-order Runge–Kutta (RK) scheme to approximate the solution at discrete times $t_k = k \\,\\Delta t$ for $k = 0,1,\\dots,N$ with time step $\\Delta t$ and horizon $T_{\\text{total}} = N \\Delta t$.\n- Runs the simulation twice in parallel for identical parameters and initial conditions: once in single precision (IEEE 754 binary32, hereafter denoted $\\text{float32}$) and once in double precision (IEEE 754 binary64, hereafter denoted $\\text{float64}$). Ensure that all arithmetic in each run adheres to the respective precision.\n- Measures the divergence between the two trajectories by computing at each step $k$ the Euclidean norm of the difference\n$$\ns_k = \\left\\| \\mathbf{x}^{(32)}_k - \\mathbf{x}^{(64)}_k \\right\\|_2,\n$$\nwhere $\\mathbf{x}^{(p)}_k$ denotes the state vector computed at precision $p \\in \\{32, 64\\}$.\n- Estimates the shadowing time $T_{\\text{shadow}}$ for a given tolerance $\\varepsilon$ as the earliest discrete time $t_k$ such that $s_k \\ge \\varepsilon$. If no such $k$ exists before $T_{\\text{total}}$, set $T_{\\text{shadow}} = T_{\\text{total}}$.\n\nFundamental base to use and respect:\n- The Lorenz ODE definition above.\n- The initial value problem formulation and the concept of discretizing time with a fixed-step method based on evaluating instantaneous rates of change and aggregating them to approximate the flow.\n- The notion of floating-point arithmetic with rounding errors that accumulate and propagate through the dynamics.\n\nUse the following fixed parameters in all simulations:\n- $\\sigma = 10$, $\\rho = 28$, $\\beta = \\frac{8}{3}$.\n- Initial condition $\\mathbf{x}_0 = (1, 1, 1)$.\n- The time variable $t$ is dimensionless; report times in the same dimensionless units. No physical units apply.\n\nDefine and apply the test suite consisting of $3$ cases, each specified by $(\\Delta t, T_{\\text{total}}, \\varepsilon)$:\n- Case $1$: $\\Delta t = 0.01$, $T_{\\text{total}} = 30$, $\\varepsilon = 10^{-3}$.\n- Case $2$: $\\Delta t = 0.02$, $T_{\\text{total}} = 30$, $\\varepsilon = 10^{-2}$.\n- Case $3$: $\\Delta t = 0.005$, $T_{\\text{total}} = 50$, $\\varepsilon = 10^{-5}$.\n\nCoverage rationale:\n- Case $1$ is a standard \"happy path\" with a moderate step size and tolerance.\n- Case $2$ probes sensitivity to a coarser discretization, which can amplify numerical error and hasten divergence.\n- Case $3$ uses a finer step and a very small tolerance to examine early-time exponential separation and threshold crossing.\n\nFor each case, your program must compute and return two quantities:\n- $T_{\\text{shadow}}$ as defined above.\n- The final-step divergence $s_N$ at $t_N = T_{\\text{total}}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for all $3$ test cases as a comma-separated list enclosed in square brackets, where each case’s result is itself a two-element list of floats $[T_{\\text{shadow}}, s_N]$. For example, the output must have the form\n```\n[[T_1,s_1],[T_2,s_2],[T_3,s_3]]\n```\nwith numeric values in place of $T_i$ and $s_i$. No additional text should be printed.", "solution": "The Lorenz system is a set of coupled ordinary differential equations (ODEs) defining a deterministic flow $\\Phi_t$ on $\\mathbb{R}^3$. Given parameters $(\\sigma,\\rho,\\beta)$ and an initial condition $\\mathbf{x}_0 = (x_0,y_0,z_0)$, the initial value problem seeks $\\mathbf{x}(t)$ satisfying\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}) \\quad \\text{with} \\quad \\mathbf{x}(0) = \\mathbf{x}_0,\n$$\nwhere\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{bmatrix}\n\\sigma(y - x)\\\\\nx(\\rho - z) - y\\\\\nxy - \\beta z\n\\end{bmatrix}.\n$$\nA standard way to compute an approximate solution is to discretize time into steps of size $\\Delta t$ and apply a fixed-step explicit method that approximates the flow by composing local updates computed from instantaneous rates of change. The fourth-order Runge–Kutta (RK$4$) method is derived by matching the Taylor expansion of the exact solution up to fourth order. In each step from $\\mathbf{x}_k$ to $\\mathbf{x}_{k+1}$, RK$4$ computes staged slope evaluations:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= \\mathbf{f}(\\mathbf{x}_k),\\\\\n\\mathbf{k}_2 &= \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\frac{\\Delta t}{2}\\mathbf{k}_1\\right),\\\\\n\\mathbf{k}_3 &= \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\frac{\\Delta t}{2}\\mathbf{k}_2\\right),\\\\\n\\mathbf{k}_4 &= \\mathbf{f}\\!\\left(\\mathbf{x}_k + \\Delta t\\,\\mathbf{k}_3\\right),\n\\end{aligned}\n$$\nand advances the state by\n$$\n\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta t\\,\\frac{1}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n$$\nThis construction arises from integrating the ODE over the interval $[t_k, t_{k+1}]$ and approximating the integral using a quadrature that matches the local truncation error order conditions.\n\nFloating-point arithmetic on digital computers represents real numbers as a finite set with rounding. In IEEE $754$ binary$32$ (single precision), the machine epsilon (the distance from $1$ to the next representable number greater than $1$) is approximately $2^{-23} \\approx 1.19\\times 10^{-7}$, while in IEEE $754$ binary$64$ (double precision) it is approximately $2^{-52} \\approx 2.22\\times 10^{-16}$. Each arithmetic operation incurs rounding to the nearest representable number in the chosen precision, introducing a small perturbation.\n\nChaotic dynamics, characterized by positive largest Lyapunov exponent, amplify small perturbations exponentially for sufficiently small times. If $\\lambda_{\\max} > 0$ denotes the largest Lyapunov exponent, then for sufficiently small initial separation $s_0$ and within the linearized regime, the separation between two nearby trajectories obeys\n$$\ns(t) \\approx s_0\\,e^{\\lambda_{\\max} t}.\n$$\nThus, the time to reach a threshold $\\varepsilon$ scales as\n$$\nT_{\\text{shadow}} \\approx \\frac{1}{\\lambda_{\\max}} \\ln\\!\\left(\\frac{\\varepsilon}{s_0}\\right),\n$$\nillustrating the dependence on both the initial separation $s_0$ (which here is implicitly set by the accumulation of rounding differences between single and double precision computations) and the system’s instability rate.\n\nAlgorithmic design:\n- Compute two trajectories in parallel using the same numerical method (RK$4$), time step $\\Delta t$, parameters $(\\sigma,\\rho,\\beta)$, and initial condition $\\mathbf{x}_0$, but with distinct arithmetic precisions: one in $\\text{float32}$ and the other in $\\text{float64}$. Ensure that all intermediate quantities and constants are cast to the respective precision in each run to isolate floating-point effects.\n- At each discrete time $t_k = k\\,\\Delta t$, compute the Euclidean separation\n$$\ns_k = \\left\\|\\mathbf{x}^{(32)}_k - \\mathbf{x}^{(64)}_k\\right\\|_2 = \\sqrt{(x^{(32)}_k - x^{(64)}_k)^2 + (y^{(32)}_k - y^{(64)}_k)^2 + (z^{(32)}_k - z^{(64)}_k)^2}.\n$$\n- The shadowing time is determined as\n$$\nT_{\\text{shadow}} = \\min\\{t_k \\,:\\, s_k \\ge \\varepsilon\\},\n$$\nwith the convention that if the set is empty up to $T_{\\text{total}}$, then $T_{\\text{shadow}} = T_{\\text{total}}$.\n- Also record the final-step divergence $s_N$ at $t_N = T_{\\text{total}}$ to quantify the cumulative separation by the end of the simulation.\n\nTest suite:\n- Use the fixed parameters $\\sigma=10$, $\\rho=28$, $\\beta=8/3$, initial condition $\\mathbf{x}_0=(1,1,1)$, and the three cases specified:\n  - Case $1$: $\\Delta t = 0.01$, $T_{\\text{total}} = 30$, $\\varepsilon=10^{-3}$.\n  - Case $2$: $\\Delta t = 0.02$, $T_{\\text{total}} = 30$, $\\varepsilon=10^{-2}$.\n  - Case $3$: $\\Delta t = 0.005$, $T_{\\text{total}} = 50$, $\\varepsilon=10^{-5}$.\nSince each $T_{\\text{total}}/\\Delta t$ is an integer, the discrete grid aligns exactly with the horizon, avoiding off-by-one artifacts.\n\nThe program computes and aggregates the results in the required single-line format:\n$$\n\\texttt{[[T_1,s_1],[T_2,s_2],[T_3,s_3]]}.\n$$\nThis design directly probes how computational precision ($\\text{float32}$ versus $\\text{float64}$) affects the divergence in a chaotic system and provides an empirical estimate of the shadowing time for each tolerance and step size choice, grounded in the principles of ODE integration, floating-point rounding, and sensitivity to initial conditions.", "answer": "```python\nimport numpy as np\n\ndef lorenz_deriv(x, sigma, rho, beta, dtype):\n    # x is a vector [x, y, z] with given dtype\n    # Returns derivative dx/dt as the same dtype vector.\n    x0 = x[0]; y0 = x[1]; z0 = x[2]\n    # Cast parameters to dtype to keep arithmetic consistent.\n    sigma = dtype(sigma)\n    rho = dtype(rho)\n    beta = dtype(beta)\n    dx = sigma * (y0 - x0)\n    dy = x0 * (rho - z0) - y0\n    dz = x0 * y0 - beta * z0\n    return np.array([dx, dy, dz], dtype=dtype)\n\ndef rk4_step(x, dt, sigma, rho, beta, dtype):\n    # One RK4 step with all arithmetic in given dtype.\n    dt = dtype(dt)\n    k1 = lorenz_deriv(x, sigma, rho, beta, dtype)\n    k2 = lorenz_deriv(x + (dt / dtype(2)) * k1, sigma, rho, beta, dtype)\n    k3 = lorenz_deriv(x + (dt / dtype(2)) * k2, sigma, rho, beta, dtype)\n    k4 = lorenz_deriv(x + dt * k3, sigma, rho, beta, dtype)\n    x_next = x + dt * (dtype(1)/dtype(6)) * (k1 + dtype(2)*k2 + dtype(2)*k3 + k4)\n    return x_next\n\ndef shadowing_time_and_final_separation(x0, sigma, rho, beta, dt, T_total, epsilon):\n    \"\"\"\n    Integrate the Lorenz system in float32 and float64 in parallel using RK4.\n    Compute the shadowing time T_shadow as the earliest t_k where separation >= epsilon.\n    Also return the final separation at t_N = T_total.\n    \"\"\"\n    # Ensure integer number of steps\n    steps = int(round(T_total / dt))\n    # Initialize states in respective precisions\n    x32 = np.array(x0, dtype=np.float32)\n    x64 = np.array(x0, dtype=np.float64)\n\n    T_shadow = None\n    separation_final = None\n\n    # Time loop\n    for k in range(steps):\n        # Advance both states\n        x32 = rk4_step(x32, dt, sigma, rho, beta, np.float32)\n        x64 = rk4_step(x64, dt, sigma, rho, beta, np.float64)\n        # Compute separation using higher precision for the difference\n        diff = x32.astype(np.float64) - x64\n        sep = float(np.linalg.norm(diff, ord=2))\n        # Record earliest crossing of epsilon\n        if T_shadow is None and sep >= epsilon:\n            T_shadow = (k + 1) * dt  # time after completing this step\n        # Update final separation\n        separation_final = sep\n\n    if T_shadow is None:\n        T_shadow = T_total\n\n    return float(T_shadow), float(separation_final)\n\ndef solve():\n    # Fixed Lorenz parameters and initial condition\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n    x0 = (1.0, 1.0, 1.0)\n\n    # Test suite: (dt, T_total, epsilon)\n    test_cases = [\n        (0.01, 30.0, 1e-3),   # Case 1: happy path\n        (0.02, 30.0, 1e-2),   # Case 2: coarser step, larger tolerance\n        (0.005, 50.0, 1e-5),  # Case 3: finer step, very small tolerance\n    ]\n\n    results = []\n    for dt, T_total, epsilon in test_cases:\n        T_shadow, s_final = shadowing_time_and_final_separation(\n            x0=x0, sigma=sigma, rho=rho, beta=beta, dt=dt, T_total=T_total, epsilon=epsilon\n        )\n        results.append([T_shadow, s_final])\n\n    # Final print statement in the exact required format.\n    # Single line, list of lists with floats.\n    print(f\"[{','.join('[' + ','.join(map(str, r)) + ']' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3105374"}, {"introduction": "After witnessing the qualitative effects of chaos, the next step is to quantify it. The primary tool for this is the largest Lyapunov exponent, $\\lambda_{\\max}$, which measures the average exponential rate at which nearby trajectories diverge. In this practice [@problem_id:3105291], you will implement the standard algorithm for calculating $\\lambda_{\\max}$ for the Lorenz system by integrating both the system's equations and its accompanying variational equations. This exercise not only provides experience with a fundamental technique in nonlinear dynamics but also highlights the practical importance of numerical methods by comparing the results obtained from second-order, fourth-order, and adaptive Runge-Kutta schemes.", "problem": "Consider the Lorenz system of ordinary differential equations (ODEs), defined for state vector $\\mathbf{x}(t) = (x(t), y(t), z(t))$ by\n$$\n\\dot{x} = \\sigma\\,(y - x), \\quad\n\\dot{y} = x\\,(\\rho - z) - y, \\quad\n\\dot{z} = x\\,y - \\beta\\,z,\n$$\nwhere $\\sigma$, $\\rho$, and $\\beta$ are positive parameters. The largest Lyapunov exponent (LE) $\\lambda_{\\max}$ measures the average exponential rate at which nearby trajectories of the flow $\\Phi^t$ separate, and can be defined from first principles as\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|},\n$$\nwhere $\\delta \\mathbf{x}(t)$ evolves according to the linearized (variational) dynamics about $\\mathbf{x}(t)$. The variational equation is\n$$\n\\frac{d}{dt}\\,\\delta \\mathbf{x} = J(\\mathbf{x}(t))\\,\\delta \\mathbf{x},\n$$\nwhere $J(\\mathbf{x})$ is the Jacobian matrix of the vector field evaluated along the trajectory $\\mathbf{x}(t)$. For the Lorenz system,\n$$\nJ(\\mathbf{x}) =\n\\begin{bmatrix}\n-\\sigma & \\sigma & 0 \\\\\n\\rho - z & -1 & -x \\\\\ny & x & -\\beta\n\\end{bmatrix}.\n$$\n\nTask: Write a complete, runnable program that numerically estimates the largest Lyapunov exponent $\\lambda_{\\max}$ for the Lorenz system using three different time-stepping schemes:\n- Explicit second-order Runge–Kutta (RK2, midpoint method).\n- Explicit classical fourth-order Runge–Kutta (RK4).\n- Adaptive embedded Runge–Kutta with automatic step-size control (adaptive RK45).\n\nYour program must:\n- Implement the augmented ODE system for $(\\mathbf{x}, \\delta \\mathbf{x})$ with dynamics\n$$\n\\frac{d}{dt} \\begin{bmatrix} \\mathbf{x} \\\\ \\delta \\mathbf{x} \\end{bmatrix}\n=\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(\\mathbf{x}) \\\\\nJ(\\mathbf{x})\\,\\delta \\mathbf{x}\n\\end{bmatrix}.\n$$\n- Evolve the system in time, periodically re-normalizing the perturbation vector $\\delta \\mathbf{x}$ to a fixed small norm $\\delta_0$ every $\\tau_R$ units of time to avoid overflow or underflow in the norm of $\\delta \\mathbf{x}$. If the perturbation norm immediately before re-normalization is $\\|\\delta \\mathbf{x}\\|$, accumulate $\\ln\\left(\\|\\delta \\mathbf{x}\\|/\\delta_0\\right)$, and then set $\\delta \\mathbf{x} \\leftarrow \\delta_0\\, \\delta \\mathbf{x} / \\|\\delta \\mathbf{x}\\|$. Discard an initial transient interval of duration $T_{\\mathrm{trans}}$ from the accumulation. After integrating for total time $T_{\\mathrm{tot}}$, estimate\n$$\n\\hat{\\lambda}_{\\max} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{trans}}} \\sum_{k} \\ln\\left(\\frac{\\|\\delta \\mathbf{x}_k\\|}{\\delta_0}\\right),\n$$\nwhere the sum is over re-normalization instants occurring after time $T_{\\mathrm{trans}}$.\n\nUse the following scientifically sound and widely used parameter values and settings:\n- Lorenz parameters: $\\sigma = 10$, $\\rho = 28$, $\\beta = 8/3$.\n- Initial condition for the state: $\\mathbf{x}(0) = (1, 1, 1)$.\n- Initial perturbation: $\\delta \\mathbf{x}(0)$ is aligned with the $x$-axis and normalized to $\\|\\delta \\mathbf{x}(0)\\| = \\delta_0$, where $\\delta_0 = 10^{-8}$.\n- Total integration time: $T_{\\mathrm{tot}} = 20$.\n- Transient discard time: $T_{\\mathrm{trans}} = 5$.\n- Re-normalization interval: $\\tau_R = 0.1$.\n\nTime-stepping schemes and parameters to implement:\n- RK2 (midpoint) with fixed steps of size $h$.\n- RK4 (classical) with fixed steps of size $h$.\n- Adaptive RK45 using embedded error control with relative tolerance $\\mathrm{rtol}$ and absolute tolerance $\\mathrm{atol}$.\n\nTest suite:\n- Case $1$: RK2 with $h = 0.02$.\n- Case $2$: RK2 with $h = 0.005$.\n- Case $3$: RK4 with $h = 0.02$.\n- Case $4$: RK4 with $h = 0.005$.\n- Case $5$: Adaptive RK45 with $\\mathrm{rtol} = 10^{-3}$ and $\\mathrm{atol} = 10^{-6}$.\n- Case $6$: Adaptive RK45 with $\\mathrm{rtol} = 10^{-6}$ and $\\mathrm{atol} = 10^{-9}$.\n\nRequirements:\n- Implement RK2 and RK4 explicitly for the augmented $(\\mathbf{x}, \\delta \\mathbf{x})$ system, and ensure that the re-normalization interval $\\tau_R$ is an integer multiple of $h$ for fixed-step cases.\n- Implement the adaptive RK45 using an embedded method with automatic step-size control (you may use a standard scientific library routine), integrating piecewise over each interval of length $\\tau_R$ so that re-normalization occurs exactly at multiples of $\\tau_R$.\n- Estimate $\\hat{\\lambda}_{\\max}$ for each test case as specified above and round each result to four decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test suite, for example `[float,float,float,float,float,float]` with each $\\hat{\\lambda}_i$ rounded to four decimal places.\n\nNotes on foundations to use for your derivation and design:\n- Use the definition of an ODE, the flow map generated by an ODE, and the definition of Lyapunov exponents via the linearized dynamics as fundamental bases.\n- Use the well-tested error order facts: the global truncation error for fixed-step explicit Runge–Kutta methods of order $p$ scales proportionally to $h^p$ for sufficiently smooth problems, and adaptive embedded Runge–Kutta schemes control local error to meet specified tolerances. Do not cite or use any end-formula that bypasses deriving the estimator from the variational equation and re-normalization process.\n\nFinal output format:\n- A single line containing a list of $6$ floats, each rounded to four decimal places, in the exact form `[float,float,float,float,float,float]` with no spaces.", "solution": "The problem requires the numerical estimation of the largest Lyapunov exponent, $\\lambda_{\\max}$, for the Lorenz system. The method specified is the standard algorithm based on integrating the system of ordinary differential equations (ODEs) augmented with its corresponding variational equations, followed by a periodic re-normalization of the perturbation vector.\n\nFirst, we define the augmented state vector $\\mathbf{Y}(t) \\in \\mathbb{R}^6$. This vector combines the original state vector $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$ and the infinitesimal perturbation vector $\\delta\\mathbf{x}(t) = [\\delta x(t), \\delta y(t), \\delta z(t)]^T$. Thus, $\\mathbf{Y}(t) = [\\mathbf{x}(t)^T, \\delta\\mathbf{x}(t)^T]^T$. The time evolution of this augmented state is governed by a system of six coupled first-order ODEs:\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{F}(\\mathbf{Y}(t)) =\n\\begin{bmatrix}\n\\dot{\\mathbf{x}}(\\mathbf{x}) \\\\\n\\frac{d}{dt}\\delta\\mathbf{x}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathbf{f}(\\mathbf{x}) \\\\\nJ(\\mathbf{x})\\,\\delta\\mathbf{x}\n\\end{bmatrix}\n$$\nwhere $\\mathbf{f}(\\mathbf{x})$ is the vector field of the Lorenz system and $J(\\mathbf{x})$ is its Jacobian matrix.\n\nThe components of $\\mathbf{f}(\\mathbf{x})$ are given by:\n$$\n\\dot{x} = \\sigma (y - x) \\\\\n\\dot{y} = x (\\rho - z) - y \\\\\n\\dot{z} = x y - \\beta z\n$$\nThe Jacobian matrix $J(\\mathbf{x}) = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{x}}$ is:\n$$\nJ(\\mathbf{x}) =\n\\begin{bmatrix}\n-\\sigma & \\sigma & 0 \\\\\n\\rho - z & -1 & -x \\\\\ny & x & -\\beta\n\\end{bmatrix}\n$$\nThe parameters are specified as $\\sigma = 10$, $\\rho = 28$, and $\\beta = 8/3$.\n\nThe largest Lyapunov exponent is defined by the long-term average exponential rate of separation of nearby trajectories:\n$$\n\\lambda_{\\max} = \\lim_{t \\to \\infty} \\frac{1}{t} \\ln \\frac{\\|\\delta \\mathbf{x}(t)\\|}{\\|\\delta \\mathbf{x}(0)\\|}\n$$\nDirect numerical integration of the variational equation leads to overflow as $\\|\\delta \\mathbf{x}(t)\\|$ grows exponentially. To circumvent this, we use a re-normalization procedure. The total integration time $T_{\\mathrm{tot}}$ is divided into $N = T_{\\mathrm{tot}} / \\tau_R$ intervals of length $\\tau_R$.\n\nThe algorithm proceeds as follows:\n1.  Initialize the state at $t=0$: $\\mathbf{x}(0) = (1, 1, 1)$ and $\\delta\\mathbf{x}(0) = (\\delta_0, 0, 0)$, where $\\delta_0 = 10^{-8}$. This sets the initial augmented state $\\mathbf{Y}(0)$.\n2.  For each interval $k=1, \\dots, N$, integrate the 6D system $\\dot{\\mathbf{Y}} = \\mathbf{F}(\\mathbf{Y})$ over the time span $[(k-1)\\tau_R, k\\tau_R]$.\n3.  Let the perturbation vector at the end of the interval be $\\delta\\mathbf{x}_k^{\\text{pre}}$. Calculate its norm, $d_k = \\|\\delta\\mathbf{x}_k^{\\text{pre}}\\|$.\n4.  If the current time $t_k = k\\tau_R$ is greater than the transient time $T_{\\mathrm{trans}}$, accumulate the value $\\ln(d_k / \\delta_0)$ into a running sum. The term $d_k/\\delta_0$ represents the growth factor of the perturbation over the interval of length $\\tau_R$.\n5.  Re-normalize the perturbation vector to have norm $\\delta_0$: $\\delta\\mathbf{x}_k^{\\text{post}} = (\\delta_0 / d_k) \\delta\\mathbf{x}_k^{\\text{pre}}$. This new vector is used as the initial condition for the perturbation part of $\\mathbf{Y}$ for the next integration interval. The state part $\\mathbf{x}$ continues its evolution without modification.\n6.  After integrating for the total time $T_{\\mathrm{tot}}$, the estimate for the largest Lyapunov exponent is calculated as the time-average of the accumulated log-growth factors over the non-transient period:\n$$\n\\hat{\\lambda}_{\\max} = \\frac{1}{T_{\\mathrm{tot}} - T_{\\mathrm{trans}}} \\sum_{k \\text{ s.t. } k\\tau_R > T_{\\mathrm{trans}}} \\ln\\left(\\frac{d_k}{\\delta_0}\\right)\n$$\nThe simulation parameters are $T_{\\mathrm{tot}} = 20$, $T_{\\mathrm{trans}} = 5$, and $\\tau_R = 0.1$.\n\nWe implement three numerical integration schemes for this procedure:\n\n**1. Fixed-Step Runge-Kutta Methods (RK2 and RK4):**\nFor an ODE system $\\dot{\\mathbf{Y}} = \\mathbf{F}(t, \\mathbf{Y})$, a single step from $t_n$ to $t_{n+1} = t_n + h$ is computed as follows:\n- **RK2 (Midpoint Method):**\n  $$\n  \\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{Y}_n) \\\\\n  \\mathbf{k}_2 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_1) \\\\\n  \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\mathbf{k}_2\n  $$\n- **RK4 (Classical Method):**\n  $$\n  \\mathbf{k}_1 = \\mathbf{F}(t_n, \\mathbf{Y}_n) \\\\\n  \\mathbf{k}_2 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_1) \\\\\n  \\mathbf{k}_3 = \\mathbf{F}(t_n + h/2, \\mathbf{Y}_n + (h/2)\\mathbf{k}_2) \\\\\n  \\mathbf{k}_4 = \\mathbf{F}(t_n + h, \\mathbf{Y}_n + h\\mathbf{k}_3) \\\\\n  \\mathbf{Y}_{n+1} = \\mathbf{Y}_n + (h/6)(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n  $$\nFor each re-normalization interval of duration $\\tau_R$, we perform $M = \\tau_R / h$ steps of the chosen fixed-step integrator.\n\n**2. Adaptive Runge-Kutta Method (RK45):**\nThis method uses an embedded pair of fourth- and fifth-order Runge-Kutta formulas to estimate the local truncation error at each step. The step size is automatically adjusted to keep this error within user-specified relative and absolute tolerances, $\\mathrm{rtol}$ and $\\mathrm{atol}$. We use the `scipy.integrate.solve_ivp` function with `method='RK45'`. To ensure re-normalization occurs exactly at multiples of $\\tau_R$, we call this solver independently for each interval $[(k-1)\\tau_R, k\\tau_R]$.\n\nThe program calculates $\\hat{\\lambda}_{\\max}$ for six test cases, varying the integration method and its parameters ($h$, $\\mathrm{rtol}$, $\\mathrm{atol}$), and rounds each result to four decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# --- Problem Parameters ---\n# Lorenz system parameters\nSIGMA = 10.0\nRHO = 28.0\nBETA = 8.0 / 3.0\n\n# Simulation parameters\nT_TOT = 20.0\nT_TRANS = 5.0\nTAU_R = 0.1\nDELTA_0 = 1e-8\n\ndef lorenz_augmented(t, Y):\n    \"\"\"\n    Defines the augmented ODE system for the Lorenz equations and their\n    variational dynamics.\n    \n    Args:\n        t (float): Current time (unused, for compatibility with solvers).\n        Y (np.ndarray): 6-element state vector [x, y, z, dx, dy, dz].\n\n    Returns:\n        np.ndarray: 6-element time derivative vector dY/dt.\n    \"\"\"\n    x, y, z = Y[0], Y[1], Y[2]\n    d_vec = Y[3:]\n\n    # Lorenz system dynamics\n    dxdt = SIGMA * (y - x)\n    dydt = x * (RHO - z) - y\n    dzdt = x * y - BETA * z\n    \n    # Jacobian matrix J(x)\n    J = np.array([\n        [-SIGMA, SIGMA, 0.0],\n        [RHO - z, -1.0, -x],\n        [y, x, -BETA]\n    ])\n\n    # Variational equation dynamics\n    d_delta_vec_dt = J @ d_vec\n    \n    return np.hstack(([dxdt, dydt, dzdt], d_delta_vec_dt))\n\ndef rk2_step(f, t, y, h):\n    \"\"\"Performs a single step of the RK2 (midpoint) method.\"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n    return y + h * k2\n\ndef rk4_step(f, t, y, h):\n    \"\"\"Performs a single step of the classical RK4 method.\"\"\"\n    k1 = f(t, y)\n    k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n    k3 = f(t + h / 2.0, y + h / 2.0 * k2)\n    k4 = f(t + h, y + h * k3)\n    return y + h / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef calculate_lyapunov(method, h=None, rtol=None, atol=None):\n    \"\"\"\n    Calculates the largest Lyapunov exponent for the Lorenz system\n    using the specified numerical method and parameters.\n    \n    Args:\n        method (str): 'rk2', 'rk4', or 'rk45'.\n        h (float, optional): Fixed step size for RK2/RK4.\n        rtol (float, optional): Relative tolerance for RK45.\n        atol (float, optional): Absolute tolerance for RK45.\n        \n    Returns:\n        float: The estimated largest Lyapunov exponent.\n    \"\"\"\n    # Initial conditions\n    x0 = np.array([1.0, 1.0, 1.0])\n    dx0 = np.array([DELTA_0, 0.0, 0.0]) # Perturbation aligned with x-axis\n    Y = np.hstack((x0, dx0))\n    \n    t = 0.0\n    log_sum = 0.0\n    \n    num_renorm_intervals = int(round(T_TOT / TAU_R))\n    \n    for i in range(num_renorm_intervals):\n        t_start = i * TAU_R\n        t_end = (i + 1) * TAU_R\n        \n        # Integrate over one re-normalization interval\n        if method in ['rk2', 'rk4']:\n            num_steps = int(round(TAU_R / h))\n            solver_step = rk2_step if method == 'rk2' else rk4_step\n            Y_interval = Y.copy()\n            t_interval = t_start\n            for _ in range(num_steps):\n                Y_interval = solver_step(lorenz_augmented, t_interval, Y_interval, h)\n                t_interval += h\n            Y = Y_interval\n        elif method == 'rk45':\n            sol = solve_ivp(lorenz_augmented, (t_start, t_end), Y, \n                            method='RK45', rtol=rtol, atol=atol)\n            Y = sol.y[:, -1]\n\n        t = t_end\n        \n        # Extract perturbation vector and calculate its norm\n        delta_x = Y[3:]\n        norm_delta_x = np.linalg.norm(delta_x)\n        \n        # Accumulate log of growth factor after transient period\n        if t > T_TRANS:\n            # Avoid log(0) in case of underflow\n            if norm_delta_x > 0:\n                log_sum += np.log(norm_delta_x / DELTA_0)\n        \n        # Re-normalize perturbation vector\n        Y[3:] = (delta_x / norm_delta_x) * DELTA_0 if norm_delta_x > 0 else dx0\n    \n    # Calculate final Lyapunov exponent estimate\n    lambda_max = log_sum / (T_TOT - T_TRANS)\n    return lambda_max\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'method': 'rk2', 'h': 0.02},\n        {'method': 'rk2', 'h': 0.005},\n        {'method': 'rk4', 'h': 0.02},\n        {'method': 'rk4', 'h': 0.005},\n        {'method': 'rk45', 'rtol': 1e-3, 'atol': 1e-6},\n        {'method': 'rk45', 'rtol': 1e-6, 'atol': 1e-9},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_lyapunov(**case)\n        results.append(f\"{result:.4f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3105291"}, {"introduction": "Chaotic systems are not merely random; they harbor deep and intricate structures. This practice explores this complexity within the logistic map, one of the most iconic models in chaos theory. You will develop an algorithm to scan the map's parameter space and discover that within the apparently chaotic regime, there exist stable \"periodic windows\" where the system's behavior unexpectedly returns to order. By computationally identifying a period-3 window and measuring its width [@problem_id:3105341], you will gain a deeper appreciation for the rich, fractal-like structure that underlies the transition to chaos.", "problem": "You will write a complete, runnable program that investigates periodic windows inside chaotic parameter regimes of the logistic map using computational methods. Start from core definitions of discrete dynamical systems and limit-based quantities, and derive an algorithm that uses these foundations without shortcut formulas.\n\nFundamental base:\n- Consider the logistic map defined by the iteration $x_{n+1} = f_r(x_n)$ with $f_r(x) = r x (1 - x)$ for control parameter $r \\in [0,4]$ and state $x_n \\in [0,1]$.\n- An orbit $(x_n)$ has (least) period $p \\in \\mathbb{N}$ if there exists a minimal $p$ such that $x_{n+p} = x_n$ for all sufficiently large $n$. If no such finite $p$ exists, the orbit is aperiodic.\n- The Lyapunov exponent (LE) $\\lambda$ for the map at parameter $r$ along an orbit $(x_n)$ is defined by $\\lambda = \\lim_{N \\to \\infty} \\frac{1}{N}\\sum_{n=0}^{N-1} \\ln |f_r'(x_n)|$, where $f_r'(x) = r (1 - 2x)$. A negative Lyapunov exponent indicates exponential stability of the orbit, while a positive Lyapunov exponent indicates exponential divergence of nearby trajectories.\n- In computation, approximate the Lyapunov exponent by a finite-time average after discarding an initial transient to mitigate sensitivity to initial conditions.\n\nProblem requirements:\n- Implement an algorithm that, for a given parameter $r$, detects whether the post-transient orbit is periodic with some period $p \\leq p_{\\max}$ by testing the recurrence condition $x_{n+p} \\approx x_n$ in the sense of a small tolerance. Use a minimal period criterion (no smaller $q < p$ satisfies the condition) and check that distinct phases are not numerically collapsed (for $p > 1$, ensure the $p$ phase values are separated by a threshold). Accept a period classification only if the finite-time Lyapunov exponent is negative.\n- Implement a parameter scan over a closed interval $[r_{\\min}, r_{\\max}]$ with a uniform grid of step size $\\Delta r$, classify each grid point $r$ as belonging to a specified target period-$p$ window if the orbit has least period $p$ and the Lyapunov exponent is negative, and compute the measure of the window as the Riemann sum $\\sum \\Delta r$ over all classified grid points. Also compute the count of contiguous window segments detected on the grid.\n\nTest suite and answer specification:\n- Use the logistic map $x_{n+1} = r x_n (1 - x_n)$ as defined above.\n- Use fixed initial conditions and iteration counts specified in each test case. Do not introduce randomness.\n- For all angles (none in this problem), if any appear, use radians. For all numerical outputs in this problem, no physical units are involved.\n- Your program must implement the following test cases exactly:\n\n1. Period detection at a known region where period-$3$ exists:\n   - Parameters: $r = 3.82842712$, $x_0 = 0.2$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1500$, $p_{\\max} = 10$, tolerance $\\varepsilon = 10^{-7}$.\n   - Output for this case: the detected least period $p$ as an integer in $\\{0,1,2,\\dots,p_{\\max}\\}$. Use $p = 0$ if no period $\\leq p_{\\max}$ is detected.\n\n2. Period detection in a chaotic region:\n   - Parameters: $r = 3.57$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1500$, $p_{\\max} = 10$, tolerance $\\varepsilon = 10^{-7}$.\n   - Output for this case: the detected least period $p$ (use $p = 0$ if none).\n\n3. Measure of the period-$3$ window in a local interval:\n   - Parameters: $r_{\\min} = 3.82$, $r_{\\max} = 3.86$, $\\Delta r = 10^{-4}$, target period $p = 3$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1000$, $p_{\\max} = 10$, tolerance $\\varepsilon = 10^{-7}$.\n   - Output for this case: the total measure of the detected period-$3$ window(s) on this grid, expressed as a float rounded to $6$ decimal places.\n\n4. Count of contiguous period-$3$ window segments in the same local interval:\n   - Use the same parameters as in Case $3$.\n   - Output for this case: the number of contiguous segments, as an integer.\n\n5. Measure of the period-$3$ windows over a wider chaotic interval:\n   - Parameters: $r_{\\min} = 3.5$, $r_{\\max} = 4.0$, $\\Delta r = 10^{-3}$, target period $p = 3$, $x_0 = 0.5$, $N_{\\text{transient}} = 2000$, $N_{\\text{sample}} = 1000$, $p_{\\max} = 10$, tolerance $\\varepsilon = 10^{-7}$.\n   - Output for this case: the total measure, expressed as a float rounded to $6$ decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the five test cases above. For example, the output should look like `[p_1,p_2,m_3,c_4,m_5]` where $p_1$ and $p_2$ are integers, $m_3$ and $m_5$ are floats rounded to $6$ decimal places, and $c_4$ is an integer.", "solution": "The problem is valid. It presents a well-defined computational task grounded in the established principles of chaos theory and discrete dynamical systems. The definitions of the logistic map, periodicity, and the Lyapunov exponent are standard. The problem requires the implementation of numerical algorithms to approximate these quantities, which is a standard approach in computational science. All parameters for the test cases are explicitly provided.\n\nA minor ambiguity exists in the requirement to \"ensure the $p$ phase values are separated by a threshold\" for the distinct phase check, as no specific value for this threshold is given. A reasonable and consistent interpretation, which will be adopted here, is to use the same tolerance $\\varepsilon$ specified for the recurrence check. That is, for a candidate period-$p$ cycle with points $\\{c_1, \\dots, c_p\\}$, it is required that $|c_i - c_j| \\ge \\varepsilon$ for all $i \\neq j$. This interpretation makes the problem fully specified and solvable.\n\nThe solution is designed based on fundamental principles, starting with the core definitions and building the required algorithms step-by-step.\n\n**1. The Logistic Map and Orbit Generation**\n\nThe dynamical system under consideration is the logistic map, a function $f_r: [0,1] \\to [0,1]$ defined by the iterative formula:\n$$x_{n+1} = f_r(x_n) = r x_n (1 - x_n)$$\nHere, $x_n$ is the state of the system at step $n$, and $r \\in [0,4]$ is a control parameter. An orbit is the sequence of states $(x_n)_{n \\ge 0}$ generated from an initial condition $x_0$. To analyze the long-term (asymptotic) behavior, we first iterate the map for $N_{\\text{transient}}$ steps to let the orbit settle onto its attractor. We then record the subsequent $N_{\\text{sample}}$ points for analysis.\n\n**2. Lyapunov Exponent for Stability Analysis**\n\nThe stability of an orbit is quantified by the Lyapunov exponent (LE), $\\lambda$. For a given orbit $(x_n)$, it is defined as the average rate of exponential divergence of infinitesimally close trajectories:\n$$\\lambda = \\lim_{N \\to \\infty} \\frac{1}{N}\\sum_{n=0}^{N-1} \\ln |f_r'(x_n)|$$\nThe derivative of the logistic map is $f_r'(x) = r (1 - 2x)$. A negative LE ($\\lambda < 0$) indicates that nearby trajectories converge, characteristic of a stable orbit (like a fixed point or a periodic cycle). A positive LE ($\\lambda > 0$) indicates exponential divergence, a hallmark of chaos.\n\nIn our computational approach, we approximate the LE with a finite-time average over the $N_{\\text{sample}}$ post-transient points of the orbit:\n$$\\hat{\\lambda} \\approx \\frac{1}{N_{\\text{sample}}} \\sum_{i=0}^{N_{\\text{sample}}-1} \\ln|f_r'(x_{N_{\\text{transient}}+i})|$$\n\n**3. Algorithm for Orbit Classification**\n\nTo determine the nature of an orbit for a given $r$, we implement a function that performs the following steps:\n\n1.  **Generate Orbit and Compute LE**: Generate the orbit for $N_{\\text{transient}} + N_{\\text{sample}}$ iterations from $x_0$. Store the last $N_{\\text{sample}}$ points. Concurrently, compute the sum for the LE, $\\sum \\ln|f_r'(x_n)|$, over the sampling phase to find $\\hat{\\lambda}$.\n\n2.  **Search for Minimal Period**: We search for the smallest integer period $p$ (where $1 \\le p \\le p_{\\max}$) that characterizes the orbit. This is done by iterating $p$ from $1$ to $p_{\\max}$. The first value of $p$ that satisfies the following conditions is considered the minimal period, $p_{\\text{candidate}}$.\n    *   **Recurrence Condition**: The orbit must repeat every $p$ steps. Numerically, we test if the last $p$ points of the sequence match the $p$ points preceding them, within a small tolerance $\\varepsilon$. That is, for $k \\in \\{0, 1, \\dots, p-1\\}$, we check if $|x_{N-1-k} - x_{N-1-k-p}| < \\varepsilon$, where $N = N_{\\text{transient}} + N_{\\text{sample}}$.\n    *   **Distinct Phase Condition**: For a period $p > 1$ to be valid, its constituent points must be numerically distinct. We verify this by checking that for any two points $c_i, c_j$ in the final cycle of $p$ points, $|c_i - c_j| \\ge \\varepsilon$ for $i \\neq j$.\n\n3.  **Final Classification**: An orbit is classified as a stable period-$p$ cycle only if a minimal period $p_{\\text{candidate}} > 0$ is found **and** its corresponding finite-time Lyapunov exponent is negative ($\\hat{\\lambda} < 0$). If $p_{\\text{candidate}}>0$ but $\\hat{\\lambda} \\ge 0$, the orbit is periodic but unstable, so we classify it as aperiodic (period $0$) per the problem's stability requirement. If no period $p \\le p_{\\max}$ is found, the orbit is also classified as aperiodic (period $0$).\n\n**4. Parameter Scan Algorithm**\n\nTo analyze properties over an interval of the parameter $r$, we employ a scanning algorithm:\n1.  **Discretize Parameter Space**: A uniform grid of $r$ values is created over the interval $[r_{\\min}, r_{\\max}]$ with a step size of $\\Delta r$.\n\n2.  **Classify Each Point**: For each $r_i$ on the grid, the orbit classification algorithm described above is executed to determine its period.\n\n3.  **Compute Window Measure**: The measure (or total width) of a target period-$p$ window is approximated by a Riemann sum. We sum the step size $\\Delta r$ for every $r_i$ on the grid that was classified as having the target period $p$:\n    $$M_p = \\sum_{r_i \\text{ where period is } p} \\Delta r$$\n\n4.  **Count Contiguous Segments**: To count the number of separate, contiguous segments of a target period, we iterate through the sequence of classifications for each $r_i$. A counter is incremented only when we encounter a point with the target period that was preceded by a point with a different period, thus marking the start of a new segment.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_orbit(r, x0, N_transient, N_sample, p_max, tol):\n    \"\"\"\n    Analyzes the logistic map orbit for a given parameter r.\n    \n    Returns the detected least period p if the orbit is stable (LE < 0),\n    otherwise returns 0.\n    \"\"\"\n    # Step 1: Generate orbit and compute Lyapunov exponent\n    x = x0\n    orbit_points = np.zeros(N_transient + N_sample)\n    \n    # Generate the full orbit\n    for i in range(N_transient + N_sample):\n        x = r * x * (1.0 - x)\n        orbit_points[i] = x\n\n    # Extract the post-transient part of the orbit\n    orbit_sample = orbit_points[N_transient:]\n    \n    le_sum = 0.0\n    for val in orbit_sample:\n        derivative_val = r * (1.0 - 2.0 * val)\n        # Prevent log(0) if x lands exactly on 0.5\n        if abs(derivative_val) > 1e-12:\n            le_sum += np.log(abs(derivative_val))\n    \n    le = le_sum / N_sample\n\n    # Step 2: Find minimal period p <= p_max\n    p_candidate = 0\n    for p in range(1, p_max + 1):\n        # Ensure there are enough points in the orbit to check for period p\n        if N_sample < 2 * p:\n            continue\n\n        # Check recurrence condition for the last p points of the sample\n        is_periodic = True\n        for k in range(p):\n            if abs(orbit_sample[-1 - k] - orbit_sample[-1 - k - p]) >= tol:\n                is_periodic = False\n                break\n        \n        if is_periodic:\n            # Minimal period found (due to loop order). Now check for distinct phases.\n            if p > 1:\n                last_cycle = orbit_sample[-p:]\n                phases_distinct = True\n                for i in range(p):\n                    for j in range(i + 1, p):\n                        if abs(last_cycle[i] - last_cycle[j]) < tol:\n                            phases_distinct = False\n                            break\n                    if not phases_distinct:\n                        break\n                \n                if not phases_distinct:\n                    # Not a true p-cycle (numerically collapsed phases), try a larger p\n                    continue\n\n            # Found minimal period p with distinct phases.\n            p_candidate = p\n            break  # Exit the loop for p\n\n    # Step 3: Classify based on Lyapunov exponent\n    if p_candidate > 0 and le < 0:\n        return p_candidate\n    else:\n        return 0\n\ndef solve():\n    \"\"\"\n    Solves all test cases as specified in the problem statement.\n    \"\"\"\n    results = []\n    \n    # Case 1: Period detection in period-3 window\n    params1 = {'r': 3.82842712, 'x0': 0.2, 'N_transient': 2000, 'N_sample': 1500, 'p_max': 10, 'tol': 1e-7}\n    p1 = analyze_orbit(**params1)\n    results.append(p1)\n\n    # Case 2: Period detection in chaotic region\n    params2 = {'r': 3.57, 'x0': 0.5, 'N_transient': 2000, 'N_sample': 1500, 'p_max': 10, 'tol': 1e-7}\n    p2 = analyze_orbit(**params2)\n    results.append(p2)\n\n    # Cases 3 and 4: Measure and segment count of period-3 window\n    r_min3, r_max3, dr3 = 3.82, 3.86, 1e-4\n    params3 = {'x0': 0.5, 'N_transient': 2000, 'N_sample': 1000, 'p_max': 10, 'tol': 1e-7}\n    target_p3 = 3\n    \n    num_points3 = int(round((r_max3 - r_min3) / dr3)) + 1\n    r_values3 = np.linspace(r_min3, r_max3, num_points3)\n    \n    measure3 = 0.0\n    segments4 = 0\n    in_segment = False\n    \n    for r_val in r_values3:\n        p = analyze_orbit(r_val, **params3)\n        if p == target_p3:\n            measure3 += dr3\n            if not in_segment:\n                segments4 += 1\n                in_segment = True\n        else:\n            in_segment = False\n            \n    m3 = round(measure3, 6)\n    c4 = segments4\n    results.append(f\"{m3:.6f}\")\n    results.append(c4)\n\n    # Case 5: Measure of period-3 windows over a wider interval\n    r_min5, r_max5, dr5 = 3.5, 4.0, 1e-3\n    params5 = {'x0': 0.5, 'N_transient': 2000, 'N_sample': 1000, 'p_max': 10, 'tol': 1e-7}\n    target_p5 = 3\n    \n    num_points5 = int(round((r_max5 - r_min5) / dr5)) + 1\n    r_values5 = np.linspace(r_min5, r_max5, num_points5)\n    \n    measure5 = 0.0\n    for r_val in r_values5:\n        p = analyze_orbit(r_val, **params5)\n        if p == target_p5:\n            measure5 += dr5\n\n    m5 = round(measure5, 6)\n    results.append(f\"{m5:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3105341"}]}