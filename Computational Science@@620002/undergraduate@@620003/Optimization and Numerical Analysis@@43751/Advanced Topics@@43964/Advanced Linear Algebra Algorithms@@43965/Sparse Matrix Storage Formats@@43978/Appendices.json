{"hands_on_practices": [{"introduction": "Understanding a sparse matrix format begins with the ability to decode it. The Compressed Sparse Row (CSR) format is a cornerstone of high-performance computing, but its three-array structure can be unintuitive at first. This first practice is a fundamental exercise in reverse-engineering: given the raw CSR arrays, you will reconstruct the original dense matrix, providing a concrete understanding of how rows, column indices, and values are intertwined [@problem_id:2204554].", "problem": "In many scientific and engineering applications, matrices are often \"sparse,\" meaning most of their elements are zero. Storing all these zeros is inefficient. The Compressed Sparse Row (CSR) format is a common method for storing sparse matrices by using three one-dimensional arrays.\n\nConsider a sparse matrix $A$ of size $4 \\times 4$. In the CSR format (using 0-based indexing), this matrix is represented by the following three arrays:\n1.  An array `V` containing the non-zero elements of $A$, read row by row, from left to right.\n2.  An array `C` containing the column index for each corresponding element in `V`.\n3.  An array `R` (the row pointer) of size $m+1$ (where $m$ is the number of rows), where the $i$-th element indicates the index in `V` and `C` where the data for the $i$-th row begins. The last element of `R` is the total number of non-zero elements.\n\nThe three arrays for our $4 \\times 4$ matrix $A$ are given as follows:\n- `V = [5.1, -1.2, 2.0, -3.5, 4.0, 9.8]`\n- `C = [1, 3, 0, 2, 3, 0]`\n- `R = [0, 2, 3, 5, 6]`\n\nReconstruct the original dense $4 \\times 4$ matrix $A$. Present your answer as a $4 \\times 4$ matrix.", "solution": "We use the CSR definition with 0-based indexing. For each row index $i \\in \\{0,1,2,3\\}$, the nonzero entries of row $i$ are stored in the segments of `V` and `C` with indices $j$ from $R[i]$ to $R[i+1]-1$, where the column index is $C[j]$ and the value is $V[j]$. The last element $R[4]=6$ equals the total number of nonzeros, which matches $\\lvert V \\rvert=6$.\n\nRow $0$: indices $j=R[0]\\ldots R[1]-1=0\\ldots 1$.\n- $j=0$: $C[0]=1$, $V[0]=5.1$ gives $A_{0,1}=5.1$.\n- $j=1$: $C[1]=3$, $V[1]=-1.2$ gives $A_{0,3}=-1.2$.\nThus row $0$ is $[0,\\,5.1,\\,0,\\,-1.2]$.\n\nRow $1$: indices $j=R[1]\\ldots R[2]-1=2\\ldots 2$.\n- $j=2$: $C[2]=0$, $V[2]=2.0$ gives $A_{1,0}=2.0$.\nThus row $1$ is $[2.0,\\,0,\\,0,\\,0]$.\n\nRow $2$: indices $j=R[2]\\ldots R[3]-1=3\\ldots 4$.\n- $j=3$: $C[3]=2$, $V[3]=-3.5$ gives $A_{2,2}=-3.5$.\n- $j=4$: $C[4]=3$, $V[4]=4.0$ gives $A_{2,3}=4.0$.\nThus row $2$ is $[0,\\,0,\\,-3.5,\\,4.0]$.\n\nRow $3$: indices $j=R[3]\\ldots R[4]-1=5\\ldots 5$.\n- $j=5$: $C[5]=0$, $V[5]=9.8$ gives $A_{3,0}=9.8$.\nThus row $3$ is $[9.8,\\,0,\\,0,\\,0]$.\n\nTherefore, the reconstructed dense matrix $A$ is\n$$\n\\begin{pmatrix}\n0 & 5.1 & 0 & -1.2 \\\\\n2.0 & 0 & 0 & 0 \\\\\n0 & 0 & -3.5 & 4.0 \\\\\n9.8 & 0 & 0 & 0\n\\end{pmatrix}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0 & 5.1 & 0 & -1.2 \\\\ 2.0 & 0 & 0 & 0 \\\\ 0 & 0 & -3.5 & 4.0 \\\\ 9.8 & 0 & 0 & 0\\end{pmatrix}}$$", "id": "2204554"}, {"introduction": "Knowing how to use a format is one thing; knowing when to use it is another. In numerical analysis, efficiency is paramount, and the choice of sparse matrix format can have significant impacts on memory usage. This practice challenges you to compare the memory footprint of the familiar CSR format against the Diagonal (DIA) format for a special \"arrowhead\" matrix, forcing you to analyze how a matrix's specific non-zero pattern dictates the most efficient storage solution [@problem_id:2204576].", "problem": "In scientific computing, sparse matrices, which are matrices populated primarily with zeros, are often stored in specialized formats to conserve memory. Consider an $N \\times N$ \"arrowhead\" matrix, defined as a matrix where the only non-zero elements are located on the main diagonal, the first row, and the first column.\n\nWe want to compare the memory efficiency of two common storage formats for this matrix: Compressed Sparse Row (CSR) and Diagonal (DIA).\n\nAssume that non-zero values are stored as double-precision floating-point numbers (8 bytes each) and all row/column indices and pointers are stored as integers (4 bytes each).\n\nThe memory requirements for each format are defined as follows:\n\n1.  **Compressed Sparse Row (CSR)**: This format uses three arrays:\n    *   `values`: An array of size $\\text{nnz}$ storing the non-zero values, where $\\text{nnz}$ is the total number of non-zero elements.\n    *   `col_indices`: An array of size $\\text{nnz}$ storing the column index of each non-zero element.\n    *   `row_pointers`: An array of size $N+1$ storing the index into the `values` array that marks the start of each row.\n\n2.  **Diagonal (DIA)**: This format is optimized for matrices with non-zeros along a few diagonals. It uses two arrays:\n    *   `offsets`: An array of size $d$ that stores the offset of each diagonal from the main diagonal, where $d$ is the number of non-zero diagonals.\n    *   `values`: A dense $N \\times d$ array. Each column of this array stores the elements of one of the non-zero diagonals. If a diagonal has fewer than $N$ elements, the corresponding column in the `values` array is padded with zeros.\n\nDetermine the smallest integer dimension $N \\ge 2$ for which the total memory required by the CSR format is strictly less than the total memory required by the DIA format for storing an arrowhead matrix.", "solution": "An $N \\times N$ arrowhead matrix has non-zero entries on the main diagonal, the first row, and the first column. Counting unique non-zeros:\n- Main diagonal contributes $N$ entries.\n- First row contributes $N-1$ additional entries (excluding the $(1,1)$ overlap).\n- First column contributes $N-1$ additional entries (excluding the $(1,1)$ overlap).\nTherefore, the total number of non-zeros is\n$$\n\\text{nnz} = N + (N - 1) + (N - 1) = 3N - 2.\n$$\n\nFor CSR:\n- The `values` array stores $\\text{nnz}$ doubles: $8(3N - 2)$ bytes.\n- The `col_indices` array stores $\\text{nnz}$ integers: $4(3N - 2)$ bytes.\n- The `row_pointers` array stores $N+1$ integers: $4(N+1)$ bytes.\nThus the total CSR memory is\n$$\nM_{\\text{CSR}} = 8(3N - 2) + 4(3N - 2) + 4(N+1) = 12(3N - 2) + 4(N+1) = 40N - 20.\n$$\n\nFor DIA:\n- The number of non-zero diagonals equals the number of distinct offsets present among the main diagonal, first row, and first column. The offsets from the first row are $\\{0,1,2,\\ldots,N-1\\}$, and from the first column are $\\{0,-1,-2,\\ldots,-(N-1)\\}$, so the union is $\\{-(N-1),\\ldots,0,\\ldots,(N-1)\\}$, giving\n$$\nd = 2N - 1.\n$$\n- The `offsets` array stores $d$ integers: $4(2N - 1)$ bytes.\n- The `values` array is dense $N \\times d$ doubles: $8N(2N - 1)$ bytes.\nThus the total DIA memory is\n$$\nM_{\\text{DIA}} = 4(2N - 1) + 8N(2N - 1) = (8N + 4)(2N - 1) = 16N^{2} - 4.\n$$\n\nWe seek the smallest integer $N \\geq 2$ such that $M_{\\text{CSR}}  M_{\\text{DIA}}$:\n$$\n40N - 20  16N^{2} - 4\n\\;\\;\\Longleftrightarrow\\;\\;\n16N^{2} - 40N + 16 > 0\n\\;\\;\\Longleftrightarrow\\;\\;\n16(N - 2)\\left(N - \\frac{1}{2}\\right) > 0.\n$$\nThis inequality holds for $N > 2$. At $N = 2$, both formats use the same memory. Therefore, the smallest integer $N \\geq 2$ for which CSR uses strictly less memory than DIA is $N = 3$.", "answer": "$$\\boxed{3}$$", "id": "2204576"}, {"introduction": "Beyond storage and analysis lies the realm of algorithmic manipulation. Real-world applications often require focusing on a smaller part of a large system, which means extracting a submatrix from a larger sparse matrix. This hands-on exercise requires you to develop a procedure to navigate a matrix in CSR format, select specific rows and columns, and construct a new submatrix in the Coordinate (COO) format. This task hones your ability to implement practical algorithms on compressed data structures, a core skill in computational science [@problem_id:2204591].", "problem": "In computational science, many problems involving large-scale simulations, such as analyzing network graphs or solving discretized partial differential equations, result in large, sparse matrices. To conserve memory, these matrices are stored in specialized formats.\n\nConsider a large $8 \\times 8$ sparse matrix $A$ representing a system, stored in the Compressed Sparse Row (CSR) format. The CSR format uses three arrays to represent the matrix:\n- `values`: A list of the non-zero values of the matrix, read row by row.\n- `col_indices`: A list of the column indices corresponding to each element in the `values` array.\n- `row_ptr`: A list of pointers indicating the start of each row's data within the `values` and `col_indices` arrays. The length of this array is one greater than the number of rows, and its last element is the total number of non-zero elements ($\\text{NNZ}$). For a row $i$, its non-zero elements are found in `values` from index $\\text{row\\_ptr}[i]$ up to (but not including) $\\text{row\\_ptr}[i+1]$.\n\nThe specific matrix $A$ is given by the following 0-indexed CSR arrays:\n- `values` = `[10, 15, 20, 22, 30, 35, 40, 48, 51, 50, 57, 62, 60, 75, 70, 81, 80]`\n- `col_indices` = `[0, 4, 1, 3, 2, 5, 3, 7, 0, 4, 6, 2, 5, 4, 6, 1, 7]`\n- `row_ptr` = `[0, 2, 4, 6, 8, 11, 13, 15, 17]`\n\nWe wish to analyze a specific sub-system. This corresponds to extracting a submatrix $B$ from $A$. The submatrix is defined by a curated list of row and column indices from the original matrix. The rows and columns for the submatrix are given by the following 0-indexed lists:\n- `sub_rows` = `[1, 4, 5, 7]`\n- `sub_cols` = `[0, 1, 4, 5]`\n\nThe extracted submatrix $B$ is constructed such that $B_{ij} = A_{\\text{sub\\_rows}[i], \\text{sub\\_cols}[j]}$. Your task is to generate this submatrix $B$ and represent it in the Coordinate list (COO) format. The COO format uses three arrays of equal length:\n- `data`: A list of the non-zero values.\n- `row`: A list of the row indices for each non-zero value.\n- `col`: A list of the column indices for each non-zero value.\n\nThe indices in the `row` and `col` arrays for the COO representation of $B$ must be relative to the new submatrix's dimensions (i.e., from 0 to 3 for both rows and columns).\n\nAfter determining the COO representation for the submatrix $B$, calculate the sum of all numerical values in its `data` array.", "solution": "We interpret the CSR arrays using the rule that the non-zero entries of row $i$ are at indices $k$ with $k \\in \\{ \\text{row\\_ptr}[i], \\ldots, \\text{row\\_ptr}[i+1]-1 \\}$, with corresponding columns $\\text{col\\_indices}[k]$ and values $\\text{values}[k]$.\n\nGiven $\\text{row\\_ptr} = [0,2,4,6,8,11,13,15,17]$, the rows of $A$ are:\n- Row $0$: indices $k=0,1$, so $(c,v)=(0,10),(4,15)$, hence $A_{0,0}=10$, $A_{0,4}=15$.\n- Row $1$: indices $k=2,3$, so $(c,v)=(1,20),(3,22)$, hence $A_{1,1}=20$, $A_{1,3}=22$.\n- Row $2$: indices $k=4,5$, so $(c,v)=(2,30),(5,35)$, hence $A_{2,2}=30$, $A_{2,5}=35$.\n- Row $3$: indices $k=6,7$, so $(c,v)=(3,40),(7,48)$, hence $A_{3,3}=40$, $A_{3,7}=48$.\n- Row $4$: indices $k=8,9,10$, so $(c,v)=(0,51),(4,50),(6,57)$, hence $A_{4,0}=51$, $A_{4,4}=50$, $A_{4,6}=57$.\n- Row $5$: indices $k=11,12$, so $(c,v)=(2,62),(5,60)$, hence $A_{5,2}=62$, $A_{5,5}=60$.\n- Row $6$: indices $k=13,14$, so $(c,v)=(4,75),(6,70)$, hence $A_{6,4}=75$, $A_{6,6}=70$.\n- Row $7$: indices $k=15,16$, so $(c,v)=(1,81),(7,80)$, hence $A_{7,1}=81$, $A_{7,7}=80$.\n\nWe extract the submatrix $B$ with $\\text{sub\\_rows}=[1,4,5,7]$ and $\\text{sub\\_cols}=[0,1,4,5]$, where $B_{ij}=A_{\\text{sub\\_rows}[i],\\,\\text{sub\\_cols}[j]}$, and reindex rows and columns to $0,1,2,3$.\n\nFor $i=0$ (original row $1$), among columns $\\{0,1,4,5\\}$ only column $1$ is non-zero with value $20$, so $B_{0,1}=20$.\nFor $i=1$ (original row $4$), among columns $\\{0,1,4,5\\}$ columns $0$ and $4$ are non-zero with values $51$ and $50$, mapping to $j=0$ and $j=2$, so $B_{1,0}=51$, $B_{1,2}=50$.\nFor $i=2$ (original row $5$), among columns $\\{0,1,4,5\\}$ only column $5$ is non-zero with value $60$, mapping to $j=3$, so $B_{2,3}=60$.\nFor $i=3$ (original row $7$), among columns $\\{0,1,4,5\\}$ only column $1$ is non-zero with value $81$, mapping to $j=1$, so $B_{3,1}=81$.\n\nThus a valid COO representation (ordered by ascending row and then column) is:\n$\\text{data}=[20,51,50,60,81]$, $\\text{row}=[0,1,1,2,3]$, $\\text{col}=[1,0,2,3,1]$.\n\nThe sum of the entries in the data array is\n$$20+51+50+60+81=262.$$", "answer": "$$\\boxed{262}$$", "id": "2204591"}]}