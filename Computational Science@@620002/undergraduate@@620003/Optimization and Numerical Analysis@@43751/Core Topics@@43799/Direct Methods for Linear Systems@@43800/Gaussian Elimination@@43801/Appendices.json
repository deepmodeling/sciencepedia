{"hands_on_practices": [{"introduction": "The most effective way to grasp Gaussian elimination is to apply it directly. This first practice exercise provides a foundational opportunity to solve a standard $3 \\times 3$ system of linear equations. By systematically converting the system into an augmented matrix and applying elementary row operations to reach row echelon form, you will build the core mechanical skills necessary for tackling more complex problems [@problem_id:23125].", "problem": "Consider the following system of linear equations in three variables $x, y,$ and $z$:\n$$\n\\begin{cases}\nx + y + z = 4 \\\\\n2x - y + z = 8 \\\\\nx - 2y - z = 1\n\\end{cases}\n$$\nUsing the method of Gaussian elimination, transform the system into row echelon form and determine the value of the variable $z$.", "solution": "We write the augmented matrix for the system:\n$$\n\\left[\n\\begin{array}{ccc|c}\n1 & 1 & 1 & 4 \\\\\n2 & -1 & 1 & 8 \\\\\n1 & -2 & -1 & 1\n\\end{array}\n\\right].\n$$\nStep 1: Eliminate $x$ from the second row via $R_2\\leftarrow R_2-2R_1$ and from the third row via $R_3\\leftarrow R_3-R_1$:\n$$\nR_2: (2-2\\cdot1,\\;-1-2\\cdot1,\\;1-2\\cdot1\\;|\\;8-2\\cdot4)\n=(0,\\,-3,\\,-1\\;|\\;0),\n$$\n$$\nR_3: (1-1,\\;-2-1,\\;-1-1\\;|\\;1-4)\n=(0,\\,-3,\\,-2\\;|\\;-3).\n$$\nThe matrix becomes\n$$\n\\left[\n\\begin{array}{ccc|c}\n1 & 1 & 1 & 4 \\\\\n0 & -3 & -1 & 0 \\\\\n0 & -3 & -2 & -3\n\\end{array}\n\\right].\n$$\nStep 2: Eliminate $y$ from the third row via $R_3\\leftarrow R_3-R_2$:\n$$\nR_3: (0-0,\\;-3-(-3),\\;-2-(-1)\\;|\\;-3-0)\n=(0,\\;0,\\;-1\\;|\\;-3).\n$$\nNow the matrix is in row echelon form:\n$$\n\\left[\n\\begin{array}{ccc|c}\n1 & 1 & 1 & 4 \\\\\n0 & -3 & -1 & 0 \\\\\n0 & 0 & -1 & -3\n\\end{array}\n\\right].\n$$\nFrom the third row we have\n$$\n-1\\cdot z=-3,\n$$\nhence\n$$\nz=3.\n$$", "answer": "$$\\boxed{3}$$", "id": "23125"}, {"introduction": "Gaussian elimination is more than just a tool for finding a single, unique solution; it's a powerful method for understanding the fundamental nature of a linear system. This practice explores a scenario where the system of equations is dependent, resulting in an infinite number of solutions. Your task is to use the outcome of the elimination process to describe the geometric shape of the solution set, connecting the abstract algebraic steps to a concrete geometric interpretation in three-dimensional space [@problem_id:2175262].", "problem": "Consider the following system of linear equations in three variables $x_1, x_2, x_3$:\n$$\n\\begin{cases}\nx_1 + x_2 + x_3 = 6 \\\\\n2x_1 - x_2 + 3x_3 = 9 \\\\\n4x_1 + x_2 + 5x_3 = 21\n\\end{cases}\n$$\nThe set of all solutions $(x_1, x_2, x_3)$ to this system forms a geometric object in three-dimensional space $\\mathbb{R}^3$. Which of the following options correctly describes this object?\n\nA. A single point\nB. A line\nC. A plane\nD. The empty set\nE. The entire three-dimensional space $\\mathbb{R}^3$", "solution": "Each linear equation represents a plane in $\\mathbb{R}^{3}$; their common solution set is their intersection. To classify the intersection, we analyze the system via Gaussian elimination.\n\nStart with the augmented matrix corresponding to\n$$\n\\begin{cases}\nx_{1} + x_{2} + x_{3} = 6 \\\\\n2x_{1} - x_{2} + 3x_{3} = 9 \\\\\n4x_{1} + x_{2} + 5x_{3} = 21\n\\end{cases}\n$$\nApply row operations:\n1) $R_{2} \\leftarrow R_{2} - 2R_{1}$ gives $[0,\\,-3,\\,1\\,|\\,-3]$.\n2) $R_{3} \\leftarrow R_{3} - 4R_{1}$ gives $[0,\\,-3,\\,1\\,|\\,-3]$.\n3) $R_{3} \\leftarrow R_{3} - R_{2}$ gives $[0,\\,0,\\,0\\,|\\,0]$.\n\nThus the reduced system is\n$$\n\\begin{cases}\nx_{1} + x_{2} + x_{3} = 6 \\\\\n-3x_{2} + x_{3} = -3 \\\\\n0=0\n\\end{cases}\n$$\nThere is no contradiction, so the system is consistent. The coefficient matrix has rank $2$ (two independent equations), and the augmented matrix has the same rank $2$. With $3$ variables and rank $2$, the solution set has dimension $3-2=1$, which is an affine line in $\\mathbb{R}^{3}$.\n\nTherefore, the geometric object is a line.", "answer": "$$\\boxed{B}$$", "id": "2175262"}, {"introduction": "In scientific and engineering applications, linear systems can be immense, but they often possess a special structure that allows for highly efficient solutions. This advanced practice challenges you to apply Gaussian elimination in a real-world context by implementing the Thomas algorithm—a specialized version for tridiagonal systems—to model steady-state heat conduction [@problem_id:2396200]. This exercise not only demonstrates the practical utility of the algorithm but also guides you in verifying its linear-time $O(N)$ computational complexity, a critical advantage in large-scale numerical simulations.", "problem": "Consider the one-dimensional steady heat conduction model governed by the boundary value problem\n$$\n-\\dfrac{d}{dx}\\!\\left(k(x)\\,\\dfrac{du}{dx}\\right) = q(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0,\n$$\nwhere $k(x)$ is the thermal conductivity and $q(x)$ is a volumetric source term. Use a uniform grid with $N$ interior nodes, grid spacing $h = \\dfrac{1}{N+1}$, and node locations $x_i = i\\,h$ for $i=1,2,\\dots,N$. The conservative second-order finite-difference discretization at node $i$ employs interface conductivities $k_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right)$ and $k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right)$, producing a tridiagonal linear system of the form\n$$\n-\\,k_{i-\\tfrac{1}{2}}\\,u_{i-1} + \\left(k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}\\right) u_i - k_{i+\\tfrac{1}{2}}\\,u_{i+1} = q(x_i)\\,h^2, \\quad i=1,2,\\dots,N,\n$$\nwith $u_0=0$ and $u_{N+1}=0$. The coefficient matrix is strictly diagonally dominant when $k(x) \\ge \\kappa_{\\min} > 0$ and $q(x)$ is bounded, ensuring a unique solution.\n\nWrite a complete, runnable program that:\n- Accepts no input and uses only the parameter values specified below.\n- Constructs the three diagonals of the tridiagonal system implied by the above discretization for each specified case.\n- Solves each system by applying a direct elimination scheme tailored to tridiagonal matrices followed by back substitution.\n- For correctness, compares the computed solution vector to the solution obtained by solving the corresponding dense linear system with a general-purpose solver, and reports the maximum absolute difference.\n- For computational complexity verification, empirically measures the solve time as the system size $N$ doubles, holding all other parameters fixed, and reports whether the observed timing ratios are consistent with linear-time $O(N)$ complexity.\n\nUse the following test suite of parameter values:\n- Case A (uniform properties):\n  - $k(x) = 1$ for all $x \\in [0,1]$,\n  - $q(x) = 2$ for all $x \\in [0,1]$,\n  - $N = 10$.\n  - Required result: the maximum absolute difference between the tridiagonal direct-solve solution and a dense-matrix general solution, expressed as a floating-point number.\n- Case B (boundary-size edge case):\n  - $k(x) = 1$ for all $x \\in [0,1]$,\n  - $q(x) = 2$ for all $x \\in [0,1]$,\n  - $N = 1$.\n  - Required result: the single interior solution value $u_1$, expressed as a floating-point number.\n- Case C (variable conductivity):\n  - $k(x) = 1 + x$ for all $x \\in [0,1]$,\n  - $q(x) = 1$ for all $x \\in [0,1]$,\n  - $N = 15$.\n  - Required result: the maximum absolute difference between the tridiagonal direct-solve solution and a dense-matrix general solution, expressed as a floating-point number.\n- Case D (empirical complexity verification):\n  - $k(x) = 1$ for all $x \\in [0,1]$,\n  - $q(x) = 2$ for all $x \\in [0,1]$,\n  - Solve sizes $N \\in \\{4000,\\,8000,\\,16000\\}$,\n  - Measure solve time per system for each $N$ by averaging repeated solves, then compute the timing ratios $T(8000)/T(4000)$ and $T(16000)/T(8000)$. Return a boolean indicating whether both ratios lie in the interval $[1.6,\\,2.5]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\text{Case A result}, \\text{Case B result}, \\text{Case C result}, \\text{Case D result}]$. For example, a valid output shape is $[x_1,x_2,x_3,x_4]$, where $x_1$, $x_2$, and $x_3$ are floating-point numbers and $x_4$ is a boolean.", "solution": "The boundary value problem\n$$\n-\\dfrac{d}{dx}\\!\\left(k(x)\\,\\dfrac{du}{dx}\\right) = q(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0,\n$$\nis discretized on a uniform grid with $N$ interior nodes, spacing $h=\\dfrac{1}{N+1}$, and nodes $x_i = i\\,h$ for $i=1,2,\\dots,N$. The conservative finite-volume or finite-difference formulation uses harmonic fluxes at half-grid interfaces. Denote\n$$\nk_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right), \\qquad k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right).\n$$\nApproximating the divergence of the flux over the cell around $x_i$ yields\n$$\n-\\dfrac{1}{h}\\left(\\dfrac{k_{i+\\tfrac{1}{2}}(u_{i+1} - u_{i})}{h} - \\dfrac{k_{i-\\tfrac{1}{2}}(u_{i} - u_{i-1})}{h}\\right) = q(x_i),\n$$\nwhich rearranges to the tridiagonal linear system\n$$\n-\\,k_{i-\\tfrac{1}{2}}\\,u_{i-1} + \\left(k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}\\right) u_i - k_{i+\\tfrac{1}{2}}\\,u_{i+1} = q(x_i)\\,h^2, \\quad i=1,2,\\dots,N,\n$$\nwith the Dirichlet conditions $u_0=0$ and $u_{N+1}=0$. For $k(x) \\ge \\kappa_{\\min} > 0$, the main diagonal entries satisfy\n$$\nk_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}} \\ge \\kappa_{\\min} + \\kappa_{\\min} = 2\\,\\kappa_{\\min},\n$$\nand the off-diagonals are $-k_{i-\\tfrac{1}{2}}$ and $-k_{i+\\tfrac{1}{2}}$, which implies strict diagonal dominance and a unique solution.\n\nAlgorithmic solution via Gaussian elimination specialized to tridiagonal matrices proceeds by eliminating the lower subdiagonal in $O(N)$ arithmetic operations, followed by a single $O(N)$ back substitution. Let the three diagonals be stored as vectors\n$$\n\\ell = \\left[\\ell_1,\\dots,\\ell_{N-1}\\right], \\quad d = \\left[d_1,\\dots,d_N\\right], \\quad u = \\left[u_1,\\dots,u_{N-1}\\right],\n$$\nand the right-hand side as $b = \\left[b_1,\\dots,b_N\\right]$. The forward elimination for $i=2$ to $N$ computes the multiplier\n$$\nm_i = \\dfrac{\\ell_{i-1}}{d_{i-1}},\n$$\nthen updates\n$$\nd_i \\leftarrow d_i - m_i\\,u_{i-1}, \\qquad b_i \\leftarrow b_i - m_i\\,b_{i-1}.\n$$\nBecause $d_{i-1} > 0$ and strict diagonal dominance holds, division by zero does not occur. After elimination, the system is upper triangular with the same upper diagonal $u$ and modified diagonal $d$. Back substitution sets\n$$\nx_N = \\dfrac{b_N}{d_N}, \\qquad x_i = \\dfrac{b_i - u_i\\,x_{i+1}}{d_i} \\quad \\text{for } i=N-1,\\dots,1.\n$$\nThis is precisely Gaussian elimination and back substitution but exploiting the tridiagonal sparsity to ensure $O(N)$ runtime and $O(N)$ storage.\n\nTo construct the diagonals from the heat equation discretization, for each $i \\in \\{1,\\dots,N\\}$ define\n$$\nx_i = i\\,h, \\quad k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right), \\quad k_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right).\n$$\nThen set\n$$\n\\ell_{i-1} = -\\,k_{i-\\tfrac{1}{2}} \\quad (i \\ge 2), \\qquad d_i = k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}, \\qquad u_i = -\\,k_{i+\\tfrac{1}{2}} \\quad (i \\le N-1),\n$$\nand\n$$\nb_i = q(x_i)\\,h^2.\n$$\nFor Case A and Case B with $k(x)=1$ and $q(x)=2$, one has $k_{i-\\tfrac{1}{2}}=1$ and $k_{i+\\tfrac{1}{2}}=1$, so $\\ell_i=-1$, $d_i=2$, $u_i=-1$, and $b_i = 2\\,h^2$. For Case C with $k(x)=1+x$ and $q(x)=1$, conductivities vary linearly with position but remain positive, preserving strict diagonal dominance.\n\nCorrectness verification is performed by assembling the dense matrix $A \\in \\mathbb{R}^{N\\times N}$ with $A_{i,i}=d_i$, $A_{i,i-1}=\\ell_{i-1}$ for $i \\ge 2$, and $A_{i,i+1}=u_i$ for $i \\le N-1$, then comparing the specialized tridiagonal solution $x$ with the dense solve $A^{-1}b$ using the maximum absolute difference\n$$\n\\|x - A^{-1}b\\|_{\\infty} = \\max_i |x_i - (A^{-1}b)_i|.\n$$\n\nTo empirically verify $O(N)$ complexity, measure the wall-clock time $T(N)$ required to solve for $N \\in \\{4000,8000,16000\\}$ while holding $k(x)$ and $q(x)$ fixed. The ratio\n$$\n\\rho_1 = \\dfrac{T(8000)}{T(4000)}, \\qquad \\rho_2 = \\dfrac{T(16000)}{T(8000)}\n$$\nshould be close to $2$ for sufficiently large $N$. To reduce timing noise, average the time over multiple repeated solves and use the median or mean. Report a boolean indicating whether both $\\rho_1$ and $\\rho_2$ lie within the interval $[1.6,\\,2.5]$, which accommodates typical measurement variability while reflecting linear growth.\n\nThe program computes and outputs:\n- Case A: a floating-point value equal to $\\|x - A^{-1}b\\|_{\\infty}$ for $N=10$, $k(x)=1$, $q(x)=2$.\n- Case B: a floating-point value equal to $u_1$ for $N=1$, $k(x)=1$, $q(x)=2$.\n- Case C: a floating-point value equal to $\\|x - A^{-1}b\\|_{\\infty}$ for $N=15$, $k(x)=1+x$, $q(x)=1$.\n- Case D: a boolean equal to $\\left(\\rho_1 \\in [1.6,2.5]\\right) \\wedge \\left(\\rho_2 \\in [1.6,2.5]\\right)$ for $N \\in \\{4000,8000,16000\\}$, $k(x)=1$, $q(x)=2$.\n\nThe final output is a single line in the format $[r_A, r_B, r_C, r_D]$, where $r_A$, $r_B$, and $r_C$ are floating-point numbers and $r_D$ is a boolean.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport time\n\ndef thomas_solve(lower, diag, upper, rhs):\n    \"\"\"\n    Solve a tridiagonal linear system Ax = rhs where:\n    - lower: subdiagonal (length n-1)\n    - diag: main diagonal (length n)\n    - upper: superdiagonal (length n-1)\n    - rhs: right-hand side (length n)\n    Returns x (length n).\n    \"\"\"\n    n = diag.size\n    # Make working copies to preserve inputs\n    c = upper.astype(float).copy()\n    d = diag.astype(float).copy()\n    b = rhs.astype(float).copy()\n\n    # Forward elimination\n    for i in range(1, n):\n        if d[i-1] == 0.0:\n            # Extremely unlikely for strictly diagonally dominant matrices\n            raise ZeroDivisionError(\"Zero pivot encountered in tridiagonal elimination.\")\n        m = lower[i-1] / d[i-1]\n        d[i] -= m * c[i-1]\n        b[i] -= m * b[i-1]\n\n    # Back substitution\n    x = np.empty(n, dtype=float)\n    x[-1] = b[-1] / d[-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = (b[i] - c[i] * x[i + 1]) / d[i]\n    return x\n\ndef build_heat_tridiag(N, k_func, q_func):\n    \"\"\"\n    Build tridiagonal coefficients (lower, diag, upper) and rhs for the 1D steady heat equation:\n      -d/dx (k(x) du/dx) = q(x), u(0)=u(1)=0\n    using uniform grid with N interior points.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = (np.arange(1, N + 1, dtype=float)) * h\n    diag = np.empty(N, dtype=float)\n    rhs = np.empty(N, dtype=float)\n    lower = np.empty(max(N - 1, 0), dtype=float)\n    upper = np.empty(max(N - 1, 0), dtype=float)\n\n    for j in range(N):\n        xi = x[j]\n        km = k_func(xi - 0.5 * h)\n        kp = k_func(xi + 0.5 * h)\n        diag[j] = km + kp\n        rhs[j] = q_func(xi) * (h ** 2)\n        if j > 0:\n            lower[j - 1] = -km\n        if j  N - 1:\n            upper[j] = -kp\n    return lower, diag, upper, rhs\n\ndef dense_from_tridiag(lower, diag, upper):\n    \"\"\"Construct a dense matrix from tridiagonal vectors.\"\"\"\n    n = diag.size\n    A = np.zeros((n, n), dtype=float)\n    A[np.arange(n), np.arange(n)] = diag\n    if n >= 2:\n        A[np.arange(1, n), np.arange(0, n - 1)] = lower\n        A[np.arange(0, n - 1), np.arange(1, n)] = upper\n    return A\n\ndef case_A():\n    # k(x)=1, q(x)=2, N=10\n    N = 10\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    A = dense_from_tridiag(lower, diag, upper)\n    x_dense = np.linalg.solve(A, rhs)\n    err = float(np.max(np.abs(x_tridiag - x_dense)))\n    return err\n\ndef case_B():\n    # Edge case N=1, k(x)=1, q(x)=2\n    N = 1\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    return float(x_tridiag[0])\n\ndef case_C():\n    # Variable conductivity k(x)=1+x, source q(x)=1, N=15\n    N = 15\n    k_func = lambda x: 1.0 + x\n    q_func = lambda x: 1.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    A = dense_from_tridiag(lower, diag, upper)\n    x_dense = np.linalg.solve(A, rhs)\n    err = float(np.max(np.abs(x_tridiag - x_dense)))\n    return err\n\ndef time_one_size(N, repeats_inner=30, repeats_outer=5):\n    \"\"\"\n    Time the tridiagonal solve for a given N.\n    Build the system once and solve it repeats_inner times per outer repetition.\n    Return the median time per solve over outer repetitions.\n    \"\"\"\n    # Use constant coefficients k=1, q=2\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n\n    times = []\n    for _ in range(repeats_outer):\n        t0 = time.perf_counter()\n        for _ in range(repeats_inner):\n            # Each solve copies arrays internally, so inputs are reusable\n            _ = thomas_solve(lower, diag, upper, rhs)\n        t1 = time.perf_counter()\n        times.append((t1 - t0) / repeats_inner)\n    # Median helps mitigate noise\n    return float(np.median(times))\n\ndef case_D():\n    sizes = [4000, 8000, 16000]\n    # Increase repeats_inner if needed to stabilize timing; chosen to be modest to keep runtime short.\n    t1 = time_one_size(sizes[0], repeats_inner=30, repeats_outer=5)\n    t2 = time_one_size(sizes[1], repeats_inner=30, repeats_outer=5)\n    t3 = time_one_size(sizes[2], repeats_inner=30, repeats_outer=5)\n    # Compute ratios\n    ratio1 = t2 / t1 if t1 > 0 else float('inf')\n    ratio2 = t3 / t2 if t2 > 0 else float('inf')\n    is_linear = (1.6 = ratio1 = 2.5) and (1.6 = ratio2 = 2.5)\n    return bool(is_linear)\n\ndef solve():\n    results = []\n    results.append(case_A())\n    results.append(case_B())\n    results.append(case_C())\n    results.append(case_D())\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2396200"}]}