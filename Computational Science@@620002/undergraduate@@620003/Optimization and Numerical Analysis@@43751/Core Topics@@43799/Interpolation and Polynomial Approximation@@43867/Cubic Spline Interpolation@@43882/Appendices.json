{"hands_on_practices": [{"introduction": "A core task in constructing a cubic spline is determining the second derivatives at the data points, or \"knots.\" This first exercise simplifies the process to its most essential step: setting up and solving the linear system for these derivatives. By focusing on a simple case with only three data points, you can master the central calculation that forms the foundation of spline interpolation without getting lost in complex algebra [@problem_id:2164958].", "problem": "A function $S(x)$ is a natural cubic spline that interpolates a set of data points. By definition, a cubic spline is a piecewise function composed of cubic polynomials, and it is continuous along with its first and second derivatives. A \"natural\" cubic spline has the additional property that its second derivative is zero at the two endpoints of the interval of interpolation.\n\nConsider a natural cubic spline $S(x)$ that passes through the following three data points: $(x_0, y_0) = (0, 0)$, $(x_1, y_1) = (1, 1)$, and $(x_2, y_2) = (2, 0)$.\n\nCalculate the value of the second derivative of the spline at $x=1$, which is denoted by $S''(1)$.", "solution": "Let $x_{0}=0$, $x_{1}=1$, $x_{2}=2$ with $y_{0}=0$, $y_{1}=1$, $y_{2}=0$. For a natural cubic spline, the second derivatives at the knots $M_{i}=S''(x_{i})$ satisfy $M_{0}=0$ and $M_{2}=0$, and the interior equations are\n$$\nh_{i-1}M_{i-1}+2(h_{i-1}+h_{i})M_{i}+h_{i}M_{i+1}\n=6\\left(\\frac{y_{i+1}-y_{i}}{h_{i}}-\\frac{y_{i}-y_{i-1}}{h_{i-1}}\\right),\n$$\nfor $i=1,\\ldots,n-1$, where $h_{i}=x_{i+1}-x_{i}$. Here $h_{0}=x_{1}-x_{0}=1$ and $h_{1}=x_{2}-x_{1}=1$, and there is a single interior equation at $i=1$:\n$$\n1\\cdot M_{0}+2(1+1)M_{1}+1\\cdot M_{2}\n=6\\left(\\frac{y_{2}-y_{1}}{1}-\\frac{y_{1}-y_{0}}{1}\\right).\n$$\nSubstituting $M_{0}=0$, $M_{2}=0$, $y_{2}-y_{1}=0-1=-1$, and $y_{1}-y_{0}=1-0=1$ gives\n$$\n4M_{1}=6(-1-1)=6(-2)=-12,\n$$\nhence\n$$\nM_{1}=-3.\n$$\nTherefore $S''(1)=M_{1}=-3$.", "answer": "$$\\boxed{-3}$$", "id": "2164958"}, {"introduction": "The characteristic \"smoothness\" of a cubic spline arises from requiring continuity not just of the function itself ($C^0$), but also of its first ($C^1$) and second ($C^2$) derivatives. To truly appreciate why all these conditions are necessary, this problem challenges you to construct a piecewise function that satisfies interpolation and $C^1$ continuity but fails to be a cubic spline [@problem_id:2165003]. This exercise sharpens your understanding by illustrating precisely what a spline *isn't*, highlighting the critical role of $C^2$ continuity.", "problem": "A piecewise function $S(x)$ is defined over the interval $[-1, 1]$ by two cubic polynomials, with a knot at $x=0$:\n$$\nS(x) = \\begin{cases}\nP_1(x) = a_1 x^3 + b_1 x^2 + c_1 x + d_1 & \\text{if } -1 \\le x \\le 0 \\\\\nP_2(x) = x^2 & \\text{if } 0 < x \\le 1\n\\end{cases}\n$$\nThe function $S(x)$ is constructed to satisfy the following set of conditions:\n1.  The function interpolates the point $(-1, 1)$.\n2.  The function and its first derivative are continuous across the entire interval $[-1, 1]$. This implies that $S(x)$ and $S'(x)$ must be continuous at the knot $x=0$.\n3.  The derivative of the function at the left endpoint is zero, i.e., $S'(-1)=0$.\n\nThese conditions uniquely determine the coefficients of the polynomial $P_1(x)$. Find the value of the coefficient $a_1$.", "solution": "We have $S(x)=P_{1}(x)$ on $[-1,0]$ and $S(x)=P_{2}(x)=x^{2}$ on $(0,1]$, with $P_{1}(x)=a_{1}x^{3}+b_{1}x^{2}+c_{1}x+d_{1}$. The conditions are:\n- Interpolation at $(-1,1)$: $P_{1}(-1)=1$.\n- Continuity at $x=0$: $P_{1}(0)=P_{2}(0)$.\n- First-derivative continuity at $x=0$: $P_{1}'(0)=P_{2}'(0)$.\n- Endpoint derivative: $S'(-1)=0$, so $P_{1}'(-1)=0$.\n\nCompute derivatives: $P_{1}'(x)=3a_{1}x^{2}+2b_{1}x+c_{1}$ and $P_{2}'(x)=2x$.\n\nContinuity at $x=0$ gives $P_{1}(0)=d_{1}=P_{2}(0)=0$, hence $d_{1}=0$.\nFirst-derivative continuity at $x=0$ gives $P_{1}'(0)=c_{1}=P_{2}'(0)=0$, hence $c_{1}=0$.\nThe endpoint derivative condition $P_{1}'(-1)=0$ yields\n$$\n3a_{1}(-1)^{2}+2b_{1}(-1)+c_{1}=0 \\;\\;\\Longrightarrow\\;\\; 3a_{1}-2b_{1}+0=0 \\;\\;\\Longrightarrow\\;\\; b_{1}=\\frac{3}{2}a_{1}.\n$$\nThe interpolation condition $P_{1}(-1)=1$ gives\n$$\na_{1}(-1)^{3}+b_{1}(-1)^{2}+c_{1}(-1)+d_{1}=1 \\;\\;\\Longrightarrow\\;\\; -a_{1}+b_{1}-0+0=1.\n$$\nSubstituting $b_{1}=\\frac{3}{2}a_{1}$,\n$$\n-a_{1}+\\frac{3}{2}a_{1}=1 \\;\\;\\Longrightarrow\\;\\; \\frac{1}{2}a_{1}=1 \\;\\;\\Longrightarrow\\;\\; a_{1}=2.\n$$\nThus the uniquely determined coefficient is $a_{1}=2$.", "answer": "$$\\boxed{2}$$", "id": "2165003"}, {"introduction": "Moving from pencil-and-paper calculations to real-world applications requires implementing the interpolation algorithm in code. This final practice brings all the concepts together by challenging you to build a complete natural cubic spline interpolator from scratch [@problem_id:2384309]. You will implement the full workflow, from solving the tridiagonal system for the second derivatives to evaluating the final spline, bridging the gap between theoretical formulas and a practical computational tool.", "problem": "You are given one-dimensional data sampled at strictly increasing nodes. For a set of nodes $x_0 < x_1 < \\dots < x_n$ with corresponding values $y_0, y_1, \\dots, y_n$, consider the unique natural cubic spline $S(x)$ defined by the following properties: on each interval $[x_i, x_{i+1}]$ the function $S(x)$ is a cubic polynomial; the function $S(x)$ satisfies the interpolation conditions $S(x_i) = y_i$ for all $i$ with $0 \\le i \\le n$; the first derivative $S'(x)$ is continuous on $[x_0, x_n]$; the second derivative $S''(x)$ is continuous on $[x_0, x_n]$; and the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$ hold. Your task is to write a complete program that, for each test case below, constructs the unique natural cubic spline $S(x)$ for the provided data set and evaluates $S(x)$ at a specified query point $x_q$.\n\nAll inputs in the test suite are explicitly given below. Each test case is independent. In each case, use the provided arrays $x$ and $y$ as the exact data to construct $S(x)$, and then compute the scalar value $S(x_q)$. No external data sources are permitted or needed. All computations are purely numerical and dimensionless; no physical units apply.\n\nTest Suite (each item is a triple $(x, y, x_q)$ to be processed independently, in the given order):\n- Test case 1: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 1.3$.\n- Test case 2: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 0.0$.\n- Test case 3: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 3.0$.\n- Test case 4: $x = [0, 0.5, 1.7, 2.2, 3.0]$, $y = [0.0, 0.5, 1.8, 2.1, 1.2]$, $x_q = 2.2$.\n- Test case 5: $x = [-1.0, 2.0]$, $y = [-1.0, 4.0]$, $x_q = 0.5$.\n\nYour program must compute $S(x_q)$ for each of the above 5 cases, in order, and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each number in the output list must be a floating-point value rounded to exactly 8 decimal places. For example, the required output format is $[r_1,r_2,r_3,r_4,r_5]$ where each $r_i$ is $S(x_q)$ rounded to 8 decimal places for test case $i$.", "solution": "The goal is to construct the unique natural cubic spline $S(x)$ from the given data $(x_i, y_i)$ with $0 \\le i \\le n$, where $x_0 < x_1 < \\dots < x_n$. By definition, $S(x)$ is piecewise cubic on each interval $[x_i, x_{i+1}]$, interpolates the data $S(x_i) = y_i$, and has continuous first and second derivatives on $[x_0, x_n]$, with the natural boundary conditions $S''(x_0) = 0$ and $S''(x_n) = 0$.\n\nA standard construction proceeds by introducing the unknown vector of second derivatives at the knots, denoted by $M_i = S''(x_i)$ for $0 \\le i \\le n$. The step sizes are $h_i = x_{i+1} - x_i$ for $0 \\le i \\le n-1$. For interior indices $i$ with $1 \\le i \\le n-1$, continuity of $S'(x)$ and $S''(x)$ across the knots leads to a linear system for the interior second derivatives $M_1, M_2, \\dots, M_{n-1}$:\n$$\nh_{i-1} M_{i-1} + 2(h_{i-1} + h_{i}) M_i + h_i M_{i+1} = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right),\n$$\nwith the natural boundary conditions $M_0 = 0$ and $M_n = 0$. For $n = 1$ (i.e., two nodes), there are no interior unknowns and the natural cubic spline reduces exactly to linear interpolation between the two points, which is consistent with $M_0 = 0$ and $M_1 = 0$.\n\nThe coefficient matrix of the system for $(M_1, \\dots, M_{n-1})$ is tridiagonal, with the following entries for $1 \\le i \\le n-1$:\n- Main diagonal: $b_i = 2(h_{i-1} + h_i)$.\n- Subdiagonal: $a_i = h_{i-1}$ for $i \\ge 2$.\n- Superdiagonal: $c_i = h_i$ for $i \\le n-2$.\nThe right-hand side is $d_i = 6\\left( \\frac{y_{i+1} - y_i}{h_i} - \\frac{y_i - y_{i-1}}{h_{i-1}} \\right)$.\n\nThis linear system is strictly diagonally dominant for strictly increasing $x_i$ with $h_i > 0$, ensuring a unique solution. An efficient and exact method to solve a tridiagonal linear system in $\\mathcal{O}(n)$ time consists of a forward elimination phase that eliminates subdiagonal entries followed by a backward substitution phase to recover the unknowns. Specifically, let the system be expressed in compact notation as\n$$\na_i M_{i-1} + b_i M_i + c_i M_{i+1} = d_i, \\quad \\text{for } i = 1, 2, \\dots, n-1,\n$$\nwith the conventions that $a_1 = 0$ and $c_{n-1} = 0$. The forward elimination step constructs modified diagonals and right-hand side:\nfor $i = 2, 3, \\dots, n-1$,\n$$\nw = \\frac{a_i}{b_{i-1}}, \\quad\nb_i \\leftarrow b_i - w c_{i-1}, \\quad\nd_i \\leftarrow d_i - w d_{i-1}.\n$$\nThe backward substitution then computes\n$$\nM_{n-1} = \\frac{d_{n-1}}{b_{n-1}}, \\quad\nM_i = \\frac{d_i - c_i M_{i+1}}{b_i} \\quad \\text{for } i = n-2, n-3, \\dots, 1.\n$$\nFinally, set $M_0 = 0$ and $M_n = 0$ to obtain the full vector $(M_0, M_1, \\dots, M_n)$.\n\nWith the second derivatives known, the spline on interval $[x_i, x_{i+1}]$ can be evaluated for any $x \\in [x_i, x_{i+1}]$ using the Hermite-like representation\n$$\nS(x) = A y_i + B y_{i+1} + \\frac{h_i^2}{6} \\left[ (A^3 - A) M_i + (B^3 - B) M_{i+1} \\right],\n$$\nwhere $h_i = x_{i+1} - x_i$, $A = \\frac{x_{i+1} - x}{h_i}$, and $B = \\frac{x - x_i}{h_i}$. This representation satisfies $S(x_i) = y_i$, $S(x_{i+1}) = y_{i+1}$, and the continuity conditions by construction. If $n = 1$, then $M_i = 0$ for all indices and the formula reduces to the linear interpolation $S(x) = A y_0 + B y_1$.\n\nTo evaluate $S(x_q)$, determine the interval $[x_i, x_{i+1}]$ such that $x_q \\in [x_i, x_{i+1}]$. If $x_q = x_n$, select the final interval $[x_{n-1}, x_n]$. Compute $A$, $B$, and then $S(x_q)$ via the above formula. Repeating this for each test case produces the required scalar outputs. Each result is finally rounded to exactly $8$ decimal places and emitted in a single bracketed, comma-separated list in the specified order.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef natural_cubic_spline_second_derivatives(x, y):\n    \"\"\"\n    Compute second derivatives M at knots for the natural cubic spline.\n    x: list or array of strictly increasing floats\n    y: list or array of floats of same length as x\n    Returns: list of M values (second derivatives) at each knot.\n    \"\"\"\n    n = len(x) - 1  # number of intervals\n    if n  1:\n        raise ValueError(\"At least two data points are required.\")\n    if n == 1:\n        # Two nodes: linear interpolation, M = 0 at both ends.\n        return [0.0, 0.0]\n\n    h = [x[i+1] - x[i] for i in range(n)]\n    # Build tridiagonal system for M[1..n-1]\n    m = n - 1  # number of interior unknowns\n    a = [0.0] * m  # sub-diagonal (a[0] unused or zero)\n    b = [0.0] * m  # main diagonal\n    c = [0.0] * m  # super-diagonal (c[m-1] unused or zero)\n    d = [0.0] * m  # right-hand side\n\n    for i in range(m):\n        hi_prev = h[i] if i >= 0 else None\n        hi = h[i+1] if (i + 1)  n else None\n        # Using indices: interior i corresponds to global index i+1\n        if i == 0:\n            a[i] = 0.0\n        else:\n            a[i] = h[i]\n        if i == m - 1:\n            c[i] = 0.0\n        else:\n            c[i] = h[i+1]\n        b[i] = 2.0 * (h[i] + h[i+1])\n\n        # Right-hand side\n        yi_minus = y[i]\n        yi = y[i+1]\n        yi_plus = y[i+2]\n        d[i] = 6.0 * ((yi_plus - yi) / h[i+1] - (yi - yi_minus) / h[i])\n\n    # Thomas algorithm: forward elimination\n    for i in range(1, m):\n        if b[i-1] == 0.0:\n            raise ZeroDivisionError(\"Singular tridiagonal system encountered.\")\n        w = a[i] / b[i-1]\n        b[i] -= w * c[i-1]\n        d[i] -= w * d[i-1]\n\n    # Back substitution\n    M_interior = [0.0] * m\n    M_interior[-1] = d[-1] / b[-1]\n    for i in range(m - 2, -1, -1):\n        M_interior[i] = (d[i] - c[i] * M_interior[i + 1]) / b[i]\n\n    # Assemble full M with natural boundary conditions\n    M = [0.0] + M_interior + [0.0]\n    return M\n\ndef evaluate_natural_cubic_spline(x, y, M, xq):\n    \"\"\"\n    Evaluate the natural cubic spline defined by (x, y, M) at xq.\n    x: list of knots (strictly increasing)\n    y: list of values\n    M: list of second derivatives at knots\n    xq: query point within [x[0], x[-1]]\n    \"\"\"\n    n = len(x) - 1\n    if xq = x[0]:\n        i = 0\n    elif xq >= x[-1]:\n        i = n - 1\n    else:\n        # Find right interval i such that x[i] = xq = x[i+1]\n        # Using binary search\n        left, right = 0, n\n        while left = right:\n            mid = (left + right) // 2\n            if x[mid] = xq:\n                left = mid + 1\n            else:\n                right = mid - 1\n        i = max(0, min(right, n - 1))\n\n    h = x[i+1] - x[i]\n    if h == 0.0:\n        raise ZeroDivisionError(\"Zero interval width encountered.\")\n    A = (x[i+1] - xq) / h\n    B = (xq - x[i]) / h\n    # S(x) formula using second derivatives M\n    term = ((A**3 - A) * M[i] + (B**3 - B) * M[i+1]) * (h**2) / 6.0\n    Sx = A * y[i] + B * y[i+1] + term\n    return Sx\n\ndef solve():\n    # Define the test cases from the problem statement.\n    xA = [0.0, 0.5, 1.7, 2.2, 3.0]\n    yA = [0.0, 0.5, 1.8, 2.1, 1.2]\n    test_cases = [\n        (xA, yA, 1.3),\n        (xA, yA, 0.0),\n        (xA, yA, 3.0),\n        (xA, yA, 2.2),\n        ([-1.0, 2.0], [-1.0, 4.0], 0.5),\n    ]\n\n    results = []\n    for x, y, xq in test_cases:\n        # Compute second derivatives for the dataset\n        M = natural_cubic_spline_second_derivatives(x, y)\n        # Evaluate spline at query point\n        val = evaluate_natural_cubic_spline(x, y, M, xq)\n        results.append(val)\n\n    # Final print statement in the exact required format: 8 decimal places, no spaces\n    formatted = \"[\" + \",\".join(f\"{r:.8f}\" for r in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2384309"}]}