{"hands_on_practices": [{"introduction": "Implicit methods like the Adams-Moulton formulas often require solving a potentially complex equation at each time step. This exercise introduces the popular and computationally efficient predictor-corrector technique, which sidesteps this difficulty by using an explicit method to \"predict\" a value and an implicit method to \"correct\" it. By working through a single step of this process, you will gain hands-on experience with the mechanics of one of the most common approaches for implementing implicit multistep solvers. [@problem_id:2152822]", "problem": "Consider the initial value problem defined by the ordinary differential equation $y'(t) = y(t) - t^2 + 1$. Suppose we are using a numerical method with a fixed step size $h = 0.2$ to approximate the solution. We are given the first two points on the approximate solution curve: at $t_0 = 0.0$, the value is $y_0 = 0.5$, and at $t_1 = 0.2$, the value is $y_1 = 0.82930$.\n\nYour task is to compute the next value, $y_2$, at time $t_2 = 0.4$, by applying a single step of the following predictor-corrector scheme.\n\nFirst, compute a predicted value $y_{i+1}^*$ using the formula:\n$$y_{i+1}^* = y_i + \\frac{h}{2}\\left(3f(t_i, y_i) - f(t_{i-1}, y_{i-1})\\right)$$\nwhere $f(t,y) = y'(t)$.\n\nSecond, use this predicted value to compute the corrected value $y_{i+1}$ using the formula:\n$$y_{i+1} = y_i + \\frac{h}{2}\\left(f(t_{i+1}, y_{i+1}^*) + f(t_i, y_i)\\right)$$\n\nReport the final corrected value $y_2$. Round your final answer to five significant figures.", "solution": "We are given the ODE $y'(t)=f(t,y)=y-t^{2}+1$ and step size $h=0.2$, with known values $(t_{0},y_{0})=(0.0,0.5)$ and $(t_{1},y_{1})=(0.2,0.82930)$. We aim to compute $y_{2}$ at $t_{2}=0.4$ using the specified predictor-corrector scheme.\n\nFirst compute the needed function values at the known points:\n$$f(t_{0},y_{0})=y_{0}-t_{0}^{2}+1=0.5-0+1=1.5,$$\n$$f(t_{1},y_{1})=y_{1}-t_{1}^{2}+1=0.82930-0.04+1=1.78930.$$\n\nPredictor (Adams-Bashforth two-step):\n$$y_{2}^{*}=y_{1}+\\frac{h}{2}\\left(3f(t_{1},y_{1})-f(t_{0},y_{0})\\right)\n=0.82930+0.1\\left(3\\cdot 1.78930-1.5\\right)=0.82930+0.1\\cdot 3.86790=1.216090.$$\n\nEvaluate $f$ at the predicted point $(t_{2},y_{2}^{*})=(0.4,1.216090)$:\n$$f(t_{2},y_{2}^{*})=y_{2}^{*}-t_{2}^{2}+1=1.216090-0.16+1=2.056090.$$\n\nCorrector (trapezoidal step using the predicted endpoint value):\n$$y_{2}=y_{1}+\\frac{h}{2}\\left(f(t_{2},y_{2}^{*})+f(t_{1},y_{1})\\right)\n=0.82930+0.1\\left(2.056090+1.78930\\right)\n=0.82930+0.3845390=1.2138390.$$\n\nRounding to five significant figures yields $1.2138$.", "answer": "$$\\boxed{1.2138}$$", "id": "2152822"}, {"introduction": "After learning how to perform a calculation, a numerical analyst must ask: how accurate is the result? This problem shifts focus from procedure to principle, exploring the fundamental concept of a method's \"order of convergence.\" Understanding the order allows us to predict how the global error scales with the step size, $h$, which is essential for making informed decisions about the trade-off between computational effort and desired accuracy in any scientific simulation. [@problem_id:2152827]", "problem": "A computational scientist is simulating a system whose state, represented by a function $y(t)$, evolves according to a well-behaved ordinary differential equation (ODE). To find an approximate solution, they employ the 4th-order Adams-Moulton method, a popular implicit multi-step method.\n\nIn the first simulation, a constant step size $h$ is used to integrate the ODE from an initial time $t_0$ to a final time $t_f$. Upon completion, the computed solution is compared against a high-precision benchmark solution, revealing a global error of $\\epsilon$ at the final time $t_f$.\n\nTo explore the trade-off between accuracy and computational cost, the scientist runs the simulation again over the same time interval, but this time using a new, larger step size $h_{new} = 2h$. Assuming that both $h$ and $h_{new}$ are small enough to be in the asymptotic regime of convergence for the method, provide the best estimate for the new global error, $\\epsilon_{new}$, at time $t_f$.\n\nA. $2\\epsilon$\n\nB. $4\\epsilon$\n\nC. $8\\epsilon$\n\nD. $16\\epsilon$\n\nE. $32\\epsilon$", "solution": "We are told the method used is the 4th-order Adams-Moulton method. A linear multistep method of order $p$ has local truncation error of order $O(h^{p+1})$ and, under zero-stability and smoothness of the solution, a global error of order $O(h^{p})$. For the 4th-order Adams-Moulton method, $p=4$.\n\nIn the asymptotic regime, the global error at a fixed final time can be modeled as\n$$\n\\epsilon \\approx C h^{p},\n$$\nwhere $C$ is a problem- and method-dependent constant that does not depend on $h$. With $p=4$, this becomes\n$$\n\\epsilon \\approx C h^{4}.\n$$\nWhen the step size is doubled to $h_{new} = 2h$, the new global error scales as\n$$\n\\epsilon_{new} \\approx C (h_{new})^{4} = C (2h)^{4} = 16 C h^{4} = 16 \\epsilon.\n$$\nThus, the best estimate for the new global error is $16\\epsilon$, corresponding to option D.", "answer": "$$\\boxed{D}$$", "id": "2152827"}, {"introduction": "A numerical method can be technically accurate but practically useless if it's unstable, meaning small errors amplify and destroy the solution. This advanced practice explores the critical concept of absolute stability and uncovers a non-intuitive but vital principle: higher order does not always imply better stability. Through a hands-on coding exercise, you will identify a scenario where the lower-order, A-stable Adams-Moulton method succeeds but its higher-order counterpart fails, providing a powerful lesson on choosing the right method for stiff differential equations. [@problem_id:2371562]", "problem": "You are to construct and analyze a linear ordinary differential equation (ODE) to expose a counterintuitive stability behavior between two implicit Adams–Moulton multistep methods of different orders. The goal is to identify an example where the second-order Adams–Moulton method (AM-2) is stable for a given step size, while the higher-order fourth-order Adams–Moulton method (AM-4) is unstable. You must implement a program that certifies stability or instability by applying the fundamental root condition for linear multistep methods to the linear test equation.\n\nFundamental base and definitions:\n- Consider the linear test equation $y' = \\lambda y$ with complex scalar $ \\lambda \\in \\mathbb{C} $. For a fixed step size $h > 0$, define the complex number $z = h \\lambda$.\n- A linear multistep method has the form $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$, where $f_{n+j} = f(t_{n+j}, y_{n+j})$. On the test equation $f(t,y) = \\lambda y$, the method reduces to the characteristic equation in the amplification factor $\\xi$: $ \\rho(\\xi) - z \\sigma(\\xi) = 0$, where $ \\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ and $ \\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$.\n- Absolute stability for a given $z$ means that all roots $\\xi$ of $ \\rho(\\xi) - z \\sigma(\\xi) = 0$ satisfy $|\\xi| < 1$; if a root lies on the unit circle it must be simple to be marginally stable. You should implement a numerical check of the root condition and treat $|\\xi| \\le 1$ within a small numerical tolerance as stable.\n\nTask requirements:\n1. Use the above principles to implement stability tests for the Adams–Moulton method of order $2$ (AM-2) and the Adams–Moulton method of order $4$ (AM-4). You should use the standard Adams–Moulton coefficients for these methods. For each method, construct the corresponding polynomials $ \\rho(\\xi)$ and $ \\sigma(\\xi)$ and test the root condition for a given $z$.\n2. Construct a scalar linear ODE of the form $y' = \\lambda y$ that is “pathological” in the following sense: for a specified step size $h$ the AM-2 method is stable (all roots satisfy $|\\xi| < 1$) while the AM-4 method is unstable (at least one root satisfies $|\\xi| > 1$). Your program should verify this numerically via the root condition, not by appealing to any external stability region plot.\n3. Implement the stability check robustly by computing the roots of the characteristic polynomial using a standard polynomial root finder and verifying the modulus condition with a small numerical tolerance.\n\nTest suite:\nEvaluate your implementation on the following three test cases, each specified by the pair $(\\lambda,h)$:\n- Case $1$: $\\lambda = -1.0$, $h = 0.1$.\n- Case $2$: $\\lambda = -50.0$, $h = 0.2$.\n- Case $3$: $\\lambda = 1.0$, $h = 0.1$.\n\nFor each case, compute $z = h \\lambda$ and determine two booleans: the first indicates whether AM-2 is stable, and the second indicates whether AM-4 is stable, both according to the root condition. The “pathological” behavior is embedded in one of these cases.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of lists, each inner list being of the form $[b_{\\mathrm{AM2}}, b_{\\mathrm{AM4}}]$ with unquoted booleans. For example, the output must look like $[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{False}]]$ but with the actual values determined by your computation for the above test suite.", "solution": "The problem as stated is a standard exercise in the numerical analysis of ordinary differential equations. It is scientifically grounded, well-posed, and contains sufficient information to proceed. The objective is to demonstrate a known phenomenon where a higher-order numerical method can exhibit a smaller stability region than a lower-order one, leading to counterintuitive behavior for certain stiff problems. I will proceed with the solution.\n\nThe analysis is centered on the linear test equation, a fundamental tool for studying the stability of numerical methods for ODEs. The equation is given by:\n$$\ny'(t) = \\lambda y(t)\n$$\nwhere $y(t) \\in \\mathbb{C}$ and $\\lambda \\in \\mathbb{C}$. When a linear multistep method (LMM) of the form $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ is applied to this equation with $f(t,y) = \\lambda y$, it yields a linear constant-coefficient recurrence relation for the sequence $\\{y_n\\}$. The solutions to this recurrence are of the form $y_n = \\xi^n$, where $\\xi$ is a root of the characteristic equation:\n$$\n\\rho(\\xi) - z \\sigma(\\xi) = 0\n$$\nHere, $z = h\\lambda$, and $\\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ and $\\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$ are the first and second characteristic polynomials of the method, respectively.\n\nA method is defined as absolutely stable for a given $z$ if all roots $\\xi_k$ of its characteristic equation satisfy $|\\xi_k| \\le 1$. Any root with modulus equal to $1$ must be simple. The problem statement permits a slight relaxation for numerical implementation, where $|\\xi_k| \\le 1 + \\epsilon$ for a small tolerance $\\epsilon$ is considered stable. This check simplifies the analysis by avoiding the explicit check for simple roots on the unit circle.\n\nFirst, we analyze the second-order Adams-Moulton method (AM-2), also known as the trapezoidal rule. This is a one-step method ($s=1$) defined by:\n$$\ny_{n+1} - y_{n} = \\frac{h}{2} (f_{n+1} + f_n)\n$$\nFrom this form, we identify the coefficients $\\alpha_1=1$, $\\alpha_0=-1$ and $\\beta_1=1/2$, $\\beta_0=1/2$. The characteristic polynomials are:\n$$\n\\rho(\\xi) = \\xi - 1\n$$\n$$\n\\sigma(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2}\n$$\nThe resulting characteristic equation is a linear equation for $\\xi$:\n$$\n(\\xi - 1) - z \\left( \\frac{1}{2}\\xi + \\frac{1}{2} \\right) = 0 \\implies \\xi\\left(1 - \\frac{z}{2}\\right) = 1 + \\frac{z}{2}\n$$\nThe single root, known as the amplification factor, is:\n$$\n\\xi = \\frac{1 + z/2}{1 - z/2}\n$$\nFor stability, we require $|\\xi| \\le 1$. Let $z = x+iy$. The condition $|\\frac{2+z}{2-z}| \\le 1$ is equivalent to $|2+z|^2 \\le |2-z|^2$.\n$$\n(2+x)^2 + y^2 \\le (2-x)^2 + y^2 \\implies 4+4x+x^2 \\le 4-4x+x^2 \\implies 8x \\le 0 \\implies x \\le 0\n$$\nThus, the AM-2 method is stable for all $z$ in the left half of the complex plane, $\\text{Re}(z) \\le 0$. This property is known as A-stability.\n\nNext, we analyze the fourth-order Adams-Moulton method (AM-4). This is a three-step method ($s=3$) given by the formula:\n$$\ny_{n+3} - y_{n+2} = \\frac{h}{24}(9f_{n+3} + 19f_{n+2} - 5f_{n+1} + f_n)\n$$\nFrom this, we extract the coefficients. The first characteristic polynomial has $\\alpha_3=1$, $\\alpha_2=-1$, and all other $\\alpha_j=0$:\n$$\n\\rho(\\xi) = \\xi^3 - \\xi^2\n$$\nThe coefficients for the second characteristic polynomial are $\\beta_3 = 9/24$, $\\beta_2 = 19/24$, $\\beta_1 = -5/24$, and $\\beta_0 = 1/24$:\n$$\n\\sigma(\\xi) = \\frac{1}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1)\n$$\nThe characteristic equation $\\rho(\\xi) - z \\sigma(\\xi) = 0$ is:\n$$\n(\\xi^3 - \\xi^2) - \\frac{z}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1) = 0\n$$\nMultiplying by $24$ and collecting terms by powers of $\\xi$ yields a cubic polynomial equation:\n$$\n(24 - 9z)\\xi^3 + (-24 - 19z)\\xi^2 + (5z)\\xi - z = 0\n$$\nUnlike AM-2, this equation cannot be easily solved analytically for regions of stability. The stability of AM-4 for a given $z$ must be determined by numerically finding the three roots of this polynomial and checking if their moduli are all less than or equal to $1$. It is a known result that AM-4 is not A-stable; its region of absolute stability does not contain the entire left half-plane.\n\nThe implementation will proceed as follows. For each given pair $(\\lambda, h)$:\n1. Calculate $z = h\\lambda$.\n2. For AM-2, compute $\\xi = (1 + z/2)/(1 - z/2)$ and check if $|\\xi| \\le 1 + \\epsilon$.\n3. For AM-4, construct the complex coefficients of the cubic polynomial $P(\\xi) = a_3 \\xi^3 + a_2 \\xi^2 + a_1 \\xi + a_0$, where $a_3=24-9z$, $a_2=-24-19z$, $a_1=5z$, and $a_0=-z$. Use a standard numerical root-finder to obtain the roots $\\xi_1, \\xi_2, \\xi_3$. Check if $\\max(|\\xi_1|, |\\xi_2|, |\\xi_3|) \\le 1 + \\epsilon$.\n4. A small tolerance $\\epsilon = 10^{-9}$ is appropriate for this numerical check.\n\nWe now evaluate the provided test cases based on this procedure.\n\n- **Case 1**: $(\\lambda, h) = (-1.0, 0.1) \\implies z = -0.1$.\n  - AM-2: $\\text{Re}(z) = -0.1 \\le 0$. The method is stable.\n  - AM-4: $z = -0.1$ is a point very close to the origin. The method is zero-stable, and for small negative real $z$, it is known to be stable. We expect stability.\n  - Predicted outcome: $[\\text{True}, \\text{True}]$.\n\n- **Case 2**: $(\\lambda, h) = (-50.0, 0.2) \\implies z = -10.0$.\n  - AM-2: $\\text{Re}(z) = -10.0 \\le 0$. The method is A-stable, so it remains stable.\n  - AM-4: The stability region of AM-4 along the negative real axis is approximately $(-3.0, 0)$. Since $z = -10.0$ is far outside this interval, we expect at least one root to have a modulus greater than $1$. The method is unstable. This is the pathological case.\n  - Predicted outcome: $[\\text{True}, \\text{False}]$.\n\n- **Case 3**: $(\\lambda, h) = (1.0, 0.1) \\implies z = 0.1$.\n  - AM-2: $\\text{Re}(z) = 0.1 > 0$. The method is unstable.\n  - AM-4: For $\\text{Re}(z) > 0$, instability is expected. The root of $\\rho(\\xi)$ at $\\xi=1$ is perturbed to a value greater than $1$. The method is unstable.\n  - Predicted outcome: $[\\text{False}, \\text{False}]$.\n\nThe final program will implement this logic and confirm these predictions numerically.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_stability_am2(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-2 method for a given z = h*lambda.\n    AM-2 is stable if the single root xi of its characteristic equation has |xi| <= 1.\n    \"\"\"\n    # The characteristic polynomial for AM-2 is (1 - z/2)*xi - (1 + z/2) = 0.\n    # Avoid division by zero if z = 2.\n    if abs(z - 2.0) < tol:\n        # If z=2, the equation is degenerate. Physically, this corresponds to an\n        # infinite amplification factor, hence unstable.\n        return False\n        \n    xi = (1 + z / 2) / (1 - z / 2)\n    return np.abs(xi) <= 1.0 + tol\n\ndef check_stability_am4(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-4 method for a given z = h*lambda.\n    AM-4 is stable if all roots xi of its characteristic equation have |xi| <= 1.\n    \"\"\"\n    # Characteristic equation for AM-4:\n    # (24 - 9*z)*xi^3 + (-24 - 19*z)*xi^2 + (5*z)*xi - z = 0\n    # Coefficients of the cubic polynomial a*xi^3 + b*xi^2 + c*xi + d = 0\n    # The coefficients are complex numbers.\n    coeffs = [\n        24 - 9 * z,\n        -24 - 19 * z,\n        5 * z,\n        -z\n    ]\n    \n    # Use numpy.roots to find the roots of the polynomial.\n    # The roots will be complex.\n    try:\n        roots = np.roots(coeffs)\n    except np.linalg.LinAlgError:\n        # This can happen in degenerate cases, considered unstable.\n        return False\n\n    # Check the modulus of each root. The method is unstable if any root has\n    # a modulus greater than 1 (plus tolerance).\n    max_modulus = np.max(np.abs(roots))\n    \n    return max_modulus <= 1.0 + tol\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating the stability of AM-2 and AM-4 for given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (lambda, h).\n    test_cases = [\n        (-1.0, 0.1),\n        (-50.0, 0.2),\n        (1.0, 0.1),\n    ]\n\n    results = []\n    for lambda_val, h_val in test_cases:\n        # Calculate z = h * lambda\n        z = h_val * lambda_val\n        \n        # Check stability for AM-2 and AM-4\n        is_stable_am2 = check_stability_am2(z)\n        is_stable_am4 = check_stability_am4(z)\n        \n        results.append([is_stable_am2, is_stable_am4])\n\n    # Format the final output string exactly as specified.\n    # e.g., [[True,False],[True,True],[False,False]]\n    # No spaces within the inner lists.\n    formatted_inner_lists = [f\"[{r[0]},{r[1]}]\" for r in results]\n    output_string = f\"[{','.join(formatted_inner_lists)}]\"\n    \n    print(output_string)\n\nsolve()\n```", "id": "2371562"}]}