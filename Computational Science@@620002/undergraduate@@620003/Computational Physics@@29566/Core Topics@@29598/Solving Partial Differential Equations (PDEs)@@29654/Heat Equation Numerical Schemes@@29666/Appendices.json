{"hands_on_practices": [{"introduction": "The Forward-Time Centered-Space (FTCS) scheme is often the first method taught for the heat equation due to its simplicity. However, this simplicity comes with a critical caveat: it is only conditionally stable, meaning the time step $\\Delta t$ is strictly limited relative to the spatial grid spacing $\\Delta x$. In this exercise, we will perform a direct numerical experiment to visualize the meaning of stability by observing the evolution of a tiny, single-point perturbation—a stand-in for numerical round-off error—under different stability regimes. This practice provides a powerful, intuitive grasp of why the stability condition is not just a mathematical formality but a crucial practical constraint. [@problem_id:2400867]", "problem": "You are to write a complete, runnable program that studies how a single-point numerical round-off error propagates under the Forward-Time Centered-Space (FTCS) scheme for the one-dimensional heat equation in nondimensional form. Start from the fundamental model of heat diffusion described by the partial differential equation $u_t = u_{xx}$ on a periodic domain. Discretize space into $N$ uniform points with spacing $\\Delta x$, discretize time with step $\\Delta t$, and apply the FTCS update at each time step. Work in nondimensional units, so no physical units are required in your answer.\n\nYour program must implement the following mathematical definitions and tasks without using any pre-derived stability or amplification formulas in the implementation:\n- Define the nondimensional ratio $r = \\Delta t / \\Delta x^2$.\n- Use the periodic FTCS update for each time step for indices $i = 0, 1, \\dots, N - 1$,\n  $$u_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\n  with periodic indexing $u_{-1} = u_{N-1}$ and $u_N = u_0$.\n- Initialize a perturbation field that is identically zero except at a single index $i_0 = \\lfloor N/2 \\rfloor$, where the value is set to the IEEE $754$ double-precision machine epsilon $\\varepsilon = 2^{-52}$. This emulates a single-point numerical round-off error.\n- Evolve the perturbation for $T$ time steps using the FTCS update. Compute the two-norm amplification factor per time step\n  $$g = \\left(\\frac{\\lVert e^T \\rVert_2}{\\lVert e^0 \\rVert_2}\\right)^{1/T},$$\n  where $e^n$ is the perturbation vector after $n$ steps, and $\\lVert \\cdot \\rVert_2$ denotes the Euclidean norm.\n\nThe goal is to quantify how the single-point round-off error is amplified or damped in both stable ($r < 0.5$) and unstable ($r > 0.5$) FTCS regimes by reporting the measured geometric growth factor $g$.\n\nImplement your program to handle the following test suite of parameter sets $(N, r, T)$, all with periodic boundaries and index $i_0 = \\lfloor N/2 \\rfloor$:\n- Test $1$ (stable, happy path): $N = 64$, $r = 0.25$, $T = 200$.\n- Test $2$ (unstable, mild): $N = 64$, $r = 0.51$, $T = 80$.\n- Test $3$ (borderline): $N = 33$, $r = 0.5$, $T = 200$.\n- Test $4$ (unstable, severe): $N = 128$, $r = 0.9$, $T = 30$.\n\nYour program should compute $g$ for each test and produce a single line of output containing the results as a comma-separated list of floats rounded to six decimal places, enclosed in square brackets, in the same order as above (for example, \"[$g_1, g_2, g_3, g_4$]\"). The outputs are nondimensional numbers, so no physical units are required. Each $g$ must be printed as a float rounded to six decimal places. The final output type is a list of floats.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It is scientifically grounded, well-posed, objective, and contains all necessary information to proceed with a unique and meaningful solution. The problem constitutes a standard numerical experiment in the field of computational physics to investigate the stability of a finite difference scheme. We will now proceed with the solution.\n\nThe fundamental physical process under consideration is one-dimensional heat diffusion, described by the partial differential equation (PDE):\n$$\n\\frac{\\partial u}{\\partial t} = \\frac{\\partial^2 u}{\\partial x^2}\n$$\nwhere $u(x, t)$ is the temperature at position $x$ and time $t$. The problem specifies a periodic domain, which implies $u(x, t) = u(x+L, t)$ for some period $L$. For our numerical simulation, the domain is a discrete set of $N$ points, and periodicity is enforced by connecting the boundaries, such that the neighbor of point $i=0$ to the left is $i=N-1$, and the neighbor of point $i=N-1$ to the right is $i=0$.\n\nTo solve this equation numerically, we discretize both space and time. Let the spatial domain be discretized into $N$ points with a uniform spacing $\\Delta x$, and time be discretized into steps of size $\\Delta t$. We denote the numerical approximation of $u(i\\Delta x, n\\Delta t)$ as $u_i^n$. The Forward-Time Centered-Space (FTCS) scheme approximates the derivatives as follows:\n- The time derivative $\\frac{\\partial u}{\\partial t}$ is approximated using a forward difference:\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(i,n)} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n- The spatial second derivative $\\frac{\\partial^2 u}{\\partial x^2}$ is approximated using a centered difference:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,n)} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\nSubstituting these approximations into the heat equation yields the FTCS update rule:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}\n$$\nRearranging this equation to solve for the future state $u_i^{n+1}$ gives the explicit formula provided in the problem statement:\n$$\nu_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right)\n$$\nwhere $r = \\frac{\\Delta t}{(\\Delta x)^2}$ is the non-dimensional Courant-Friedrichs-Lewy (CFL) number for this parabolic problem.\n\nThis update rule is a linear transformation. If we represent the state of the system at time step $n$ as a vector $\\mathbf{u}^n = [u_0^n, u_1^n, \\dots, u_{N-1}^n]^T$, the evolution from one time step to the next can be expressed in matrix form:\n$$\n\\mathbf{u}^{n+1} = \\mathbf{A} \\mathbf{u}^n\n$$\nwhere $\\mathbf{A}$ is the $N \\times N$ amplification matrix. Based on the update rule and the periodic boundary conditions ($u_{-1} = u_{N-1}$ and $u_N = u_0$), the matrix $\\mathbf{A}$ is a circulant matrix with the following structure:\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1-2r & r & 0 & \\dots & 0 & r \\\\\nr & 1-2r & r & \\dots & 0 & 0 \\\\\n0 & r & 1-2r & \\dots & 0 & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots & \\vdots \\\\\n0 & 0 & 0 & \\dots & 1-2r & r \\\\\nr & 0 & 0 & \\dots & r & 1-2r\n\\end{pmatrix}\n$$\nThe problem is to study the propagation of a numerical round-off error. Since the evolution equation is linear, any error $\\mathbf{e}^n$ will evolve according to the same rule: $\\mathbf{e}^{n+1} = \\mathbf{A} \\mathbf{e}^n$. By induction, the error after $T$ time steps is given by $\\mathbf{e}^T = \\mathbf{A}^T \\mathbf{e}^0$.\n\nThe simulation procedure is as follows:\n1.  For each test case $(N, r, T)$, an initial error vector $\\mathbf{e}^0$ of size $N$ is created. This vector is initialized to zeros everywhere except at the central index $i_0 = \\lfloor N/2 \\rfloor$.\n2.  The value at this single point is set to the double-precision machine epsilon, $\\varepsilon = 2^{-52}$. Thus, $\\mathbf{e}^0_{i_0} = \\varepsilon$.\n3.  The Euclidean norm (or $L_2$-norm) of this initial vector is calculated: $\\lVert \\mathbf{e}^0 \\rVert_2 = \\sqrt{\\sum_{i=0}^{N-1} (e_i^0)^2} = \\sqrt{\\varepsilon^2} = \\varepsilon$.\n4.  A loop iterates for $T$ time steps. In each step $n$, the error vector $\\mathbf{e}^{n+1}$ is computed from $\\mathbf{e}^n$ using the FTCS update rule with periodic boundary conditions.\n5.  After $T$ steps, the final error vector is $\\mathbf{e}^T$. Its Euclidean norm, $\\lVert \\mathbf{e}^T \\rVert_2$, is computed.\n6.  The geometric growth factor per time step, $g$, is then calculated from its definition:\n$$\ng = \\left(\\frac{\\lVert \\mathbf{e}^T \\rVert_2}{\\lVert \\mathbf{e}^0 \\rVert_2}\\right)^{1/T}\n$$\nA value of $g > 1$ indicates that the error is amplified, and the scheme is unstable for the given parameters. A value of $g < 1$ indicates that the error is damped, and the scheme is stable. A value of $g \\approx 1$ suggests a neutrally stable or borderline case. This procedure is executed for each of the four test cases provided. The implementation will use `numpy` for efficient array operations, particularly `numpy.roll` to handle the periodic boundary conditions elegantly.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the numerical amplification factor for the FTCS scheme\n    for the 1D heat equation under different stability regimes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, r, T)\n    # N: number of spatial points\n    # r: nondimensional ratio delta_t / (delta_x)^2\n    # T: number of time steps\n    test_cases = [\n        (64, 0.25, 200),  # Test 1: stable\n        (64, 0.51, 80),   # Test 2: unstable (mild)\n        (33, 0.5, 200),   # Test 3: borderline\n        (128, 0.9, 30),   # Test 4: unstable (severe)\n    ]\n\n    results = []\n    \n    # The IEEE 754 double-precision machine epsilon\n    epsilon = np.finfo(float).eps\n\n    for N, r, T in test_cases:\n        # Initialize the perturbation field 'e'.\n        # It is zero everywhere except for a single point.\n        e = np.zeros(N, dtype=float)\n        \n        # Set the perturbation at the central grid point.\n        # i_0 = floor(N/2) is implemented via integer division.\n        i0 = N // 2\n        e[i0] = epsilon\n        \n        # The initial L2 norm of the error vector.\n        # Since only one element is non-zero, the norm is its absolute value.\n        norm_e0 = np.linalg.norm(e)\n\n        # Evolve the perturbation for T time steps using the FTCS scheme.\n        for _ in range(T):\n            # Applying periodic boundary conditions efficiently using np.roll.\n            # np.roll(e, 1) shifts elements to the right (e_{i-1})\n            # np.roll(e, -1) shifts elements to the left (e_{i+1})\n            e_im1 = np.roll(e, 1)\n            e_ip1 = np.roll(e, -1)\n            \n            # Apply the FTCS update rule.\n            e = e + r * (e_ip1 - 2 * e + e_im1)\n\n        # Calculate the L2 norm of the final error vector.\n        norm_eT = np.linalg.norm(e)\n        \n        # Calculate the geometric amplification factor per time step, g.\n        # Handle the case where the error is damped to zero to avoid division errors.\n        if norm_eT == 0.0 or norm_e0 == 0.0:\n            g = 0.0\n        else:\n            g = (norm_eT / norm_e0)**(1.0 / T)\n\n        results.append(g)\n\n    # Format the results as a list of strings, each rounded to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2400867"}, {"introduction": "To overcome the strict time-step limitations of explicit schemes like FTCS, we often turn to implicit methods, which are unconditionally stable. This practice challenges you to implement the widely-used Crank-Nicolson scheme, a popular method that is second-order accurate in both space and time. We will apply it to a more complex physical scenario: radially symmetric heat conduction on a 2D circular disk, which requires careful handling of the heat equation in polar coordinates and deriving a consistent discretization for the coordinate singularity at the origin. [@problem_id:2400870]", "problem": "Consider the radially symmetric heat conduction in a two-dimensional circular disk of radius $R$, where the temperature depends only on the radial coordinate $r$ and time $t$. The governing equation, derived from local energy conservation and Fourier’s law of heat conduction, is the heat equation in polar coordinates without angular dependence:\n$$\n\\frac{\\partial u}{\\partial t}(r,t) = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}(r,t) + \\frac{1}{r}\\frac{\\partial u}{\\partial r}(r,t) \\right), \\quad 0 \\le r \\le R, \\; t \\ge 0,\n$$\nwith boundary condition $u(R,t) = 0$ for all $t \\ge 0$, and regularity at the origin consistent with physical symmetry. Assume all quantities are dimensionless.\n\nYour task is to write a complete, runnable program that computes the temperature evolution using an unconditionally stable, second-order accurate in time scheme for this initial-boundary value problem. The spatial discretization must be second-order accurate and must be constructed so that the discretization at the origin $r=0$ is consistent with the polar form of the Laplace operator and the symmetry condition implied by finite energy and Fourier’s law. You must start from the conservation-law form and obtain a discretization that respects the correct limiting behavior as $r \\to 0$.\n\nUse the following specifications:\n\n- The computational domain is the interval $[0,R]$ in the radial coordinate.\n- Use a uniform grid $r_i = i \\,\\Delta r$ for $i = 0,1,\\dots,N$, where $\\Delta r = R/N$.\n- Impose the boundary condition $u_N^n = 0$ for all time levels $n$.\n- The initial condition is $u(r,0) = \\exp\\!\\left( -\\left(\\frac{r}{\\sigma}\\right)^2 \\right)$.\n- The time-stepping scheme must be the Crank–Nicolson method (also known as the trapezoidal rule in time), which is unconditionally stable and second-order accurate in time when paired with a second-order accurate spatial discretization. Assemble the method in matrix form and solve the resulting linear system at each time step.\n- The discrete spatial operator must correctly handle $r=0$ without singularities and must be derived from first principles by taking the appropriate limit of the polar Laplacian at the origin. You must not introduce ad hoc lower-order fixes at $r=0$.\n\nTest suite and output:\n\n- Run your program for the following four test cases. In each case, set the parameters $(\\alpha, R, \\sigma, N, M, T)$ as listed below, where $M$ is the number of uniform time steps and $\\Delta t = T/M$:\n  - Case $1$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 200, 50, 0.05)$.\n  - Case $2$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.2, 50, 50, 0.05)$.\n  - Case $3$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.05, 200, 100, 0.02)$.\n  - Case $4$: $(\\alpha, R, \\sigma, N, M, T) = (1, 1, 0.5, 200, 50, 0.05)$.\n- For each case, compute the numerical solution up to final time $T$ and report the temperature at the origin, i.e., $u(0,T)$.\n- Your program must produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $4$. Each number must be rounded to eight decimal places. For example, the output format must be exactly\n$[x_1,x_2,x_3,x_4]$\nwhere each $x_i$ is $u(0,T)$ for Case $i$, rounded to eight decimal places.\n\nYour implementation must be self-contained, must not read any user input, and must not require any external files or network access. The final answer of the question must be code. Ensure scientific realism by deriving and using a spatial discretization at the origin that is consistent with the limiting behavior of the polar Laplacian. The numerical quantities in this problem are dimensionless; no physical units are required. The final output format requirement is strict and must be followed exactly.", "solution": "The problem presented is a well-posed initial-boundary value problem for the linear heat equation in a two-dimensional disk with radial symmetry. It is scientifically sound and contains all necessary information for a numerical solution. We shall therefore proceed with its resolution.\n\nOur objective is to compute the temperature evolution $u(r,t)$ governed by the radially symmetric heat equation in polar coordinates:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial u}{\\partial r} \\right)\n$$\nfor $r \\in [0, R]$ and $t \\ge 0$. The problem is subject to the boundary condition $u(R,t) = 0$ and the initial condition $u(r,0) = \\exp(-(r/\\sigma)^2)$. Physical consistency requires the temperature gradient to vanish at the origin due to symmetry, i.e., $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$.\n\nWe will employ the Crank-Nicolson method for time integration, which is a second-order accurate and unconditionally stable scheme. The equation is discretized in time as:\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\mathcal{L}_h \\mathbf{u}^{n+1} + \\mathcal{L}_h \\mathbf{u}^n \\right)\n$$\nwhere $\\mathbf{u}^n$ is the vector of numerical solutions at time $t_n = n\\Delta t$, and $\\mathcal{L}_h$ is the discrete spatial operator approximating the continuous operator $\\mathcal{L} \\equiv \\alpha \\left( \\frac{\\partial^2}{\\partial r^2} + \\frac{1}{r}\\frac{\\partial}{\\partial r} \\right)$. The scheme is implicit and can be arranged into a linear system to be solved at each time step:\n$$\n\\left(I - \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{\\Delta t}{2} L\\right) \\mathbf{u}^n\n$$\nwhere $L$ is the matrix representation of $\\mathcal{L}_h$. The vector of unknowns consists of the temperature at the discrete radial points $\\mathbf{u} = [u_0, u_1, \\ldots, u_{N-1}]^T$, corresponding to radii $r_i = i\\Delta r$ for $i=0, \\ldots, N-1$, with $\\Delta r = R/N$. The boundary condition fixes $u_N^n = 0$ for all $n$.\n\nThe crucial step is to construct a second-order accurate spatial discretization $\\mathcal{L}_h$.\n\nFor interior points $r_i$ where $i \\in \\{1, 2, \\ldots, N-1\\}$, we use standard second-order central difference formulas for the derivatives:\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2}, \\quad \\frac{\\partial u}{\\partial r}\\bigg|_{r_i} \\approx \\frac{u_{i+1} - u_{i-1}}{2\\Delta r}\n$$\nSubstituting these into the expression for $\\mathcal{L}u$ yields the discrete operator at node $i$:\n$$\n(\\mathcal{L}_h \\mathbf{u})_i = \\alpha \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{(\\Delta r)^2} + \\frac{1}{i\\Delta r} \\frac{u_{i+1} - u_{i-1}}{2\\Delta r} \\right) = \\frac{\\alpha}{(\\Delta r)^2} \\left[ \\left(1 - \\frac{1}{2i}\\right)u_{i-1} - 2u_i + \\left(1 + \\frac{1}{2i}\\right)u_{i+1} \\right]\n$$\n\nAt the origin, $r=0$ ($i=0$), the term $\\frac{1}{r}\\frac{\\partial u}{\\partial r}$ is singular. A correct discretization must be derived by considering the limiting behavior of the Laplacian operator. By symmetry, the temperature profile must be an even function of $r$, which implies $\\frac{\\partial u}{\\partial r}\\big|_{r=0} = 0$. Applying L'Hôpital's rule to the singular term, we find:\n$$\n\\lim_{r\\to 0} \\frac{1}{r}\\frac{\\partial u}{\\partial r} = \\lim_{r\\to 0} \\frac{\\frac{\\partial^2 u}{\\partial r^2}}{1} = \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\nThus, the heat equation at the origin becomes:\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{r=0} = \\alpha \\left( \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} + \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0} \\right) = 2\\alpha \\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r=0}\n$$\nWe discretize the second derivative at $r=0$ using a central difference. The symmetry condition $u_r(0)=0$ implies that for a Taylor expansion around $r=0$, $u(r) = u(0) + \\frac{1}{2}u_{rr}(0)r^2 + O(r^4)$. This implies $u(\\Delta r) = u(-\\Delta r)$, which in our discrete notation is $u_1 = u_{-1}$. The central difference for $u_{rr}(0)$ is:\n$$\n\\frac{\\partial^2 u}{\\partial r^2}\\bigg|_{r_0} \\approx \\frac{u_1 - 2u_0 + u_{-1}}{(\\Delta r)^2} = \\frac{u_1 - 2u_0 + u_1}{(\\Delta r)^2} = \\frac{2(u_1 - u_0)}{(\\Delta r)^2}\n$$\nSubstituting this into the specialized heat equation at the origin gives the discretization for $i=0$:\n$$\n(\\mathcal{L}_h \\mathbf{u})_0 = 2\\alpha \\left( \\frac{2(u_1 - u_0)}{(\\Delta r)^2} \\right) = \\frac{4\\alpha}{(\\Delta r)^2} (u_1 - u_0)\n$$\nThis discretization is second-order accurate and consistent with the geometry.\n\nWith these expressions, we construct the $N \\times N$ matrix $L$. Let $c = \\alpha/(\\Delta r)^2$.\n- The first row ($i=0$) is: $L_{0,0} = -4c$, $L_{0,1} = 4c$, and $L_{0,j}=0$ for $j>1$.\n- For rows $i=1, \\ldots, N-2$, the non-zero elements are:\n  $L_{i,i-1} = c(1 - 1/(2i))$, $L_{i,i} = -2c$, and $L_{i,i+1} = c(1+1/(2i))$.\n- The last row ($i=N-1$) must account for the boundary condition $u_N=0$:\n  $L_{N-1,N-2} = c(1 - 1/(2(N-1)))$ and $L_{N-1,N-1} = -2c$.\n\nThe algorithm proceeds as follows:\n1.  For each test case, define parameters $(\\alpha, R, \\sigma, N, M, T)$ and calculate $\\Delta r=R/N$ and $\\Delta t=T/M$.\n2.  Construct the matrices $A = I - \\frac{\\Delta t}{2} L$ and $B = I + \\frac{\\Delta t}{2} L$. For efficiency, we compute the LU factorization of matrix $A$ once before the time-stepping loop.\n3.  Initialize the solution vector $\\mathbf{u}^0$ using the initial condition: $u_i^0 = \\exp(-(i\\Delta r/\\sigma)^2)$ for $i=0, \\ldots, N-1$.\n4.  Iterate for $n=0, \\ldots, M-1$:\n    a. Compute the right-hand-side vector $\\mathbf{b} = B \\mathbf{u}^n$.\n    b. Solve the linear system $A \\mathbf{u}^{n+1} = \\mathbf{b}$ for $\\mathbf{u}^{n+1}$ using the pre-computed LU factorization of $A$.\n5.  After $M$ steps, the final temperature at the origin is $u_0^M$, which is the first element of the final solution vector. This value is reported.\nThe implementation will use `numpy` for matrix operations and `scipy.linalg` for the efficient solution of the linear system.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to solve the radially symmetric heat equation for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, R, sigma, N, M, T)\n        (1.0, 1.0, 0.2, 200, 50, 0.05),\n        (1.0, 1.0, 0.2, 50, 50, 0.05),\n        (1.0, 1.0, 0.05, 200, 100, 0.02),\n        (1.0, 1.0, 0.5, 200, 50, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, R, sigma, N, M, T = case\n        result = run_simulation(alpha, R, sigma, N, M, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(alpha, R, sigma, N, M, T):\n    \"\"\"\n    Computes the temperature evolution for a single test case.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        R (float): Radius of the disk.\n        sigma (float): Width of the initial Gaussian profile.\n        N (int): Number of spatial grid points in the radius (excluding the boundary).\n        M (int): Number of time steps.\n        T (float): Final time.\n\n    Returns:\n        float: Temperature at the origin u(0, T).\n    \"\"\"\n    # Grid parameters\n    dr = R / N\n    dt = T / M\n    \n    # Grid points for r (interior points from r=0 to r=R-dr)\n    r = np.linspace(0, R - dr, N)\n\n    # Construct the spatial discretization matrix L\n    # The size of the system is N x N for points u_0, u_1, ..., u_{N-1}\n    L = np.zeros((N, N))\n    c = alpha / dr**2\n\n    # Equation at the origin (i=0)\n    L[0, 0] = -4.0 * c\n    L[0, 1] = 4.0 * c\n\n    # Equations for interior points (i=1 to N-2)\n    for i in range(1, N - 1):\n        # r_i = i * dr, so the coefficients simplify\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        L[i, i + 1] = c * (1.0 + 1.0 / (2.0 * i))\n\n    # Equation at the point next to the boundary (i=N-1)\n    # The u_N term is zero due to boundary condition and moves to the other side.\n    if N > 1:\n        i = N - 1\n        L[i, i - 1] = c * (1.0 - 1.0 / (2.0 * i))\n        L[i, i]     = -2.0 * c\n        # The u_{N} term is u_N = 0, so L[i, i+1] which would reference u_N is zero.\n\n    # Construct Crank-Nicolson matrices A and B\n    # A u^{n+1} = B u^{n}\n    # where A = I - dt/2 * L, B = I + dt/2 * L\n    I = np.identity(N)\n    A = I - (dt / 2.0) * L\n    B = I + (dt / 2.0) * L\n\n    # Initial condition u(r, 0)\n    u = np.exp(-(r / sigma)**2)\n\n    # Pre-compute LU factorization of A for efficiency\n    try:\n        lu_and_piv = linalg.lu_factor(A)\n    except linalg.LinAlgError:\n        # This case should not be reached for a well-posed problem.\n        return np.nan\n\n    # Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side vector\n        b = B @ u\n        # Solve the linear system A u_next = b\n        u = linalg.lu_solve(lu_and_piv, b)\n\n    # Return the temperature at the origin at the final time\n    return u[0]\n\n# Execute the solver\nsolve()\n```", "id": "2400870"}, {"introduction": "Once a stable numerical solution is obtained, the next question is how to improve its accuracy. This exercise introduces Richardson extrapolation, a general and powerful technique for increasing the order of accuracy of a numerical method. By combining the results from two simulations run with different time steps, you will derive and implement a formula from first principles to cancel the leading-order temporal error term, thereby creating a more accurate, higher-order estimate of the true solution. [@problem_id:2400855]", "problem": "Consider the one-dimensional heat equation on a bounded domain with homogeneous Dirichlet boundary conditions. The unknown field is the temperature $u(x,t)$ governed by the partial differential equation $u_t=\\alpha u_{xx}$ on $x\\in[0,L]$, $t\\ge 0$, where $\\alpha>0$ is the thermal diffusivity. Let the initial condition be $u(x,0)=\\sin\\left(\\pi x/L\\right)$ and the boundaries satisfy $u(0,t)=0$ and $u(L,t)=0$ for all $t\\ge 0$. The exact solution is known for this configuration and is given by $u(x,t)=\\sin\\left(\\pi x/L\\right)\\exp\\left(-\\alpha (\\pi/L)^2 t\\right)$.\n\nStarting from the fundamental base that a forward Euler (Forward-Time) discretization of $u_t$ and a centered second-order discretization (Central-Space) of $u_{xx}$ yield a fully explicit finite difference method for parabolic diffusion, construct a Forward-Time Central-Space (FTCS) scheme. Use a uniform spatial grid with spacing $\\Delta x=L/N$, grid points $x_i=i\\Delta x$ for integer $i$, and a uniform time step $\\Delta t$. Define the non-dimensional parameter $r=\\alpha \\Delta t/\\Delta x^2$. Work with the standard FTCS interior-node stencil that is consistent with the homogeneous Dirichlet boundaries. Assume the classical stability requirement $r\\le 1/2$.\n\nYou will run two FTCS simulations having the same spatial grid but different time steps: a coarse step $\\Delta t$ and a fine step $\\Delta t/2$, both integrated to the same physical time $T$. Let $U_{\\Delta t}(x_i,T)$ and $U_{\\Delta t/2}(x_i,T)$ denote the corresponding numerical solutions at the grid points $x_i$ at time $T$. Use the premise that FTCS is first-order accurate in time to derive from first principles a Richardson extrapolation in time that eliminates the leading-order temporal truncation error term and produces a higher-order-in-time estimate $U_{\\mathrm{RE}}(x_i,T)$ at the same grid points. Your derivation must start from the assumption that the leading temporal error behaves linearly in $\\Delta t$ while spatial discretization is held fixed, and you must determine the extrapolation coefficients without appealing to any pre-memorized formula.\n\nImplement an algorithm that:\n- Constructs the FTCS scheme from the discrete forms of $u_t$ and $u_{xx}$, enforces the boundary values, and advances to time $T$ using both $\\Delta t$ and $\\Delta t/2$ on the same spatial grid.\n- Constructs the Richardson-extrapolated solution $U_{\\mathrm{RE}}(x_i,T)$ at the same grid points by combining $U_{\\Delta t}(x_i,T)$ and $U_{\\Delta t/2}(x_i,T)$ using the coefficients you derived.\n- Computes for each run the discrete $L^2$ error at time $T$ with respect to the exact solution using the formula\n$$\nE=\\left(\\Delta x\\sum_{i=1}^{N-1}\\left[U(x_i,T)-u(x_i,T)\\right]^2\\right)^{1/2},\n$$\nwhere $U$ denotes the numerical approximation (either $U_{\\Delta t}$, $U_{\\Delta t/2}$, or $U_{\\mathrm{RE}}$), and $u$ denotes the exact solution.\n\nAll quantities are non-dimensional; you must report errors as pure numbers without units.\n\nTest suite and required output:\n- Use $L=1$, $\\alpha=1$, and the initial condition $u(x,0)=\\sin(\\pi x)$ on $x\\in[0,1]$.\n- For all tests, take the spatial grid to include the endpoints. With $N$ subintervals, the grid has $N+1$ points and spacing $\\Delta x=L/N$.\n- Run the following three test cases, each defined by the pair $(N,\\Delta t,T)$:\n    1. $(N,\\Delta t,T)=\\left(100,4\\times 10^{-5},0.05\\right)$ so that $r=0.4$.\n    2. $(N,\\Delta t,T)=\\left(100,5\\times 10^{-5},0.05\\right)$ so that $r=0.5$.\n    3. $(N,\\Delta t,T)=\\left(80,7.5\\times 10^{-5},0.06\\right)$ so that $r=0.48$.\n- For each test case, compute and record three floating-point results in this order: the $L^2$ error for the coarse FTCS solution $E_{\\Delta t}$, the $L^2$ error for the fine FTCS solution $E_{\\Delta t/2}$, and the $L^2$ error for the Richardson-extrapolated solution $E_{\\mathrm{RE}}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, ordered by test case and by error type as specified above. Concretely, the final output must be a flat list\n$$\n\\left[E_{\\Delta t}^{(1)},E_{\\Delta t/2}^{(1)},E_{\\mathrm{RE}}^{(1)},E_{\\Delta t}^{(2)},E_{\\Delta t/2}^{(2)},E_{\\mathrm{RE}}^{(2)},E_{\\Delta t}^{(3)},E_{\\Delta t/2}^{(3)},E_{\\mathrm{RE}}^{(3)}\\right].\n$$", "solution": "The problem presented is a standard exercise in computational physics, concerning the numerical solution of the one-dimensional heat equation. It is scientifically grounded, well-posed, and contains all necessary information. We may therefore proceed with a rigorous derivation and solution.\n\nThe governing partial differential equation (PDE) is the heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nfor a temperature field $u(x,t)$ on the domain $x \\in [0, L]$ and for time $t \\ge 0$. The parameter $\\alpha > 0$ is the thermal diffusivity. The problem is supplemented with homogeneous Dirichlet boundary conditions $u(0,t) = u(L,t) = 0$ and an initial condition $u(x,0) = \\sin(\\pi x / L)$.\n\nFirst, we construct the Forward-Time Central-Space (FTCS) numerical scheme. We discretize the domain into a uniform grid with spatial step $\\Delta x = L/N$ and temporal step $\\Delta t$. Let $U_i^n$ denote the numerical approximation of the exact solution $u(x_i, t_n)$ at grid point $x_i = i \\Delta x$ and time $t_n = n \\Delta t$.\n\nThe time derivative $\\frac{\\partial u}{\\partial t}$ is approximated using a first-order forward difference:\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_i, t_n)} \\approx \\frac{U_i^{n+1} - U_i^n}{\\Delta t}\n$$\nThis discretization introduces a local truncation error of order $\\mathcal{O}(\\Delta t)$.\n\nThe spatial second derivative $\\frac{\\partial^2 u}{\\partial x^2}$ is approximated using a second-order central difference:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, t_n)} \\approx \\frac{U_{i+1}^n - 2U_i^n + U_{i-1}^n}{\\Delta x^2}\n$$\nThis introduces a local truncation error of order $\\mathcal{O}(\\Delta x^2)$.\n\nSubstituting these finite difference approximations into the heat equation yields the FTCS scheme:\n$$\n\\frac{U_i^{n+1} - U_i^n}{\\Delta t} = \\alpha \\frac{U_{i+1}^n - 2U_i^n + U_{i-1}^n}{\\Delta x^2}\n$$\nSolving for the solution at the next time step, $U_i^{n+1}$, gives the explicit update rule for the interior grid points ($i=1, 2, \\dots, N-1$):\n$$\nU_i^{n+1} = U_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} \\left( U_{i+1}^n - 2U_i^n + U_{i-1}^n \\right)\n$$\nBy defining the non-dimensional mesh Fourier number, or diffusion number, as $r = \\frac{\\alpha \\Delta t}{\\Delta x^2}$, the update rule simplifies to:\n$$\nU_i^{n+1} = U_i^n + r \\left( U_{i+1}^n - 2U_i^n + U_{i-1}^n \\right) = r U_{i-1}^n + (1 - 2r) U_i^n + r U_{i+1}^n\n$$\nThis scheme is known to be stable only if the condition $r \\le 1/2$ is met. The problem statement guarantees this condition is satisfied for all test cases. The homogeneous Dirichlet boundary conditions are enforced by setting $U_0^n = 0$ and $U_N^n = 0$ for all time steps $n$. The initial condition is applied at $n=0$: $U_i^0 = \\sin(\\pi x_i / L)$.\n\nNext, we derive the formula for Richardson extrapolation in time. The FTCS scheme has a global error that is first-order in time and second-order in space, i.e., the error is $\\mathcal{O}(\\Delta t, \\Delta x^2)$. For a fixed spatial grid (fixed $\\Delta x$), the numerical solution $U_{\\Delta t}$ at a final time $T$ can be expressed as an expansion in powers of $\\Delta t$ around the exact solution $u$:\n$$\nU_{\\Delta t}(x,T) = u(x,T) + C_1(x,T) \\Delta t + C_2(x,T) \\Delta t^2 + \\dots\n$$\nwhere the coefficients $C_k$ are independent of $\\Delta t$. The term $C_1(x,T) \\Delta t$ is the leading-order temporal error.\n\nWe perform two separate simulations until the same final time $T$: one with a coarse time step $\\Delta t$, yielding solution $U_1 = U_{\\Delta t}$, and one with a fine time step $\\Delta t/2$, yielding solution $U_2 = U_{\\Delta t/2}$. Their error expansions are:\n$$\n(1) \\quad U_1 = u + C_1 \\Delta t + \\mathcal{O}(\\Delta t^2)\n$$\n$$\n(2) \\quad U_2 = u + C_1 \\left(\\frac{\\Delta t}{2}\\right) + \\mathcal{O}(\\Delta t^2)\n$$\nWe seek a linear combination of $U_1$ and $U_2$, denoted $U_{\\mathrm{RE}} = a U_1 + b U_2$, that eliminates the leading-order error term.\n$$\nU_{\\mathrm{RE}} = a(u + C_1 \\Delta t) + b(u + C_1 \\frac{\\Delta t}{2}) + \\mathcal{O}(\\Delta t^2)\n$$\n$$\nU_{\\mathrm{RE}} = (a+b)u + (a + \\frac{b}{2}) C_1 \\Delta t + \\mathcal{O}(\\Delta t^2)\n$$\nTo construct a better approximation of $u$, we require the coefficient of $u$ to be $1$ and the coefficient of the $\\mathcal{O}(\\Delta t)$ error term to be $0$. This results in a system of linear equations for coefficients $a$ and $b$:\n\\begin{cases}\na+b = 1 \\\\\na + \\frac{b}{2} = 0\n\\end{cases}\nFrom the second equation, we have $a = -b/2$. Substituting this into the first equation gives $-b/2 + b = 1$, which simplifies to $b/2 = 1$, so $b=2$. Consequently, $a=-1$.\n\nThe Richardson-extrapolated solution is therefore:\n$$\nU_{\\mathrm{RE}} = 2 U_2 - U_1 = 2 U_{\\Delta t/2} - U_{\\Delta t}\n$$\nThe error of this extrapolated solution is of order $\\mathcal{O}(\\Delta t^2)$, demonstrating a second-order accuracy in time, an improvement over the original first-order scheme.\n\nThe final part of the task is to compute the discrete $L^2$ error for each numerical solution ($U_{\\Delta t}$, $U_{\\Delta t/2}$, and $U_{\\mathrm{RE}}$) with respect to the exact solution $u(x,T) = \\sin(\\pi x/L)\\exp(-\\alpha (\\pi/L)^2 T)$. The error is computed at the final time $T$ using the given formula:\n$$\nE = \\left( \\Delta x \\sum_{i=1}^{N-1} [U(x, T) - u(x, T)]^2 \\right)^{1/2}\n$$\nThe summation is performed over the interior grid points $i=1, \\dots, N-1$, as the boundary values are fixed and exact. The implementation will proceed by first running the coarse and fine simulations, then combining their results to obtain the extrapolated solution, and finally computing the three corresponding error norms for each specified test case.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_ftcs(N, dt, T, L, alpha):\n    \"\"\"\n    Solves the 1D heat equation using the FTCS scheme.\n\n    Args:\n        N (int): Number of spatial subintervals.\n        dt (float): Time step size.\n        T (float): Final integration time.\n        L (float): Length of the spatial domain.\n        alpha (float): Thermal diffusivity.\n\n    Returns:\n        numpy.ndarray: The numerical solution at time T.\n    \"\"\"\n    dx = L / N\n    x = np.linspace(0, L, N + 1)\n    \n    # Calculate non-dimensional parameter r\n    r = alpha * dt / dx**2\n    if r > 0.5:\n        # A proper professor warns about instability.\n        print(f\"Warning: Stability condition r = 0.5 not met. r = {r}\")\n\n    # Number of time steps - ensure it's an integer\n    num_steps = int(round(T / dt))\n    \n    # Initial condition\n    u = np.sin(np.pi * x / L)\n    \n    # Set boundary conditions (which are already zero for sin(0) and sin(pi))\n    u[0] = 0.0\n    u[-1] = 0.0\n    \n    # Time-stepping loop\n    for _ in range(num_steps):\n        # Use slicing for a vectorized update of interior points\n        u_new = u.copy()\n        u_new[1:-1] = r * u[:-2] + (1 - 2 * r) * u[1:-1] + r * u[2:]\n        u = u_new\n        \n    return u\n\ndef calculate_l2_error(u_numerical, u_exact, dx):\n    \"\"\"\n    Calculates the discrete L2 error between numerical and exact solutions.\n    The sum is over interior points only.\n\n    Args:\n        u_numerical (numpy.ndarray): The numerical solution array.\n        u_exact (numpy.ndarray): The exact solution array.\n        dx (float): Spatial grid spacing.\n\n    Returns:\n        float: The discrete L2 error.\n    \"\"\"\n    # Error is calculated over interior points [1:-1]\n    error_sq = (u_numerical[1:-1] - u_exact[1:-1])**2\n    return np.sqrt(dx * np.sum(error_sq))\n\ndef solve():\n    \"\"\"\n    Runs the simulations for the test cases, computes errors, and prints results.\n    \"\"\"\n    # Global parameters for all test cases\n    L = 1.0\n    alpha = 1.0\n\n    # Test cases defined as (N, dt, T)\n    test_cases = [\n        (100, 4e-5, 0.05),\n        (100, 5e-5, 0.05),\n        (80, 7.5e-5, 0.06),\n    ]\n\n    results = []\n\n    for N, dt_coarse, T in test_cases:\n        dx = L / N\n        dt_fine = dt_coarse / 2.0\n        \n        # --- Run simulations ---\n        # Coarse time step simulation\n        U_coarse = run_ftcs(N, dt_coarse, T, L, alpha)\n        \n        # Fine time step simulation\n        U_fine = run_ftcs(N, dt_fine, T, L, alpha)\n        \n        # --- Richardson Extrapolation ---\n        # U_RE = 2 * U_fine - U_coarse\n        U_RE = 2.0 * U_fine - U_coarse\n\n        # --- Calculate exact solution ---\n        x_grid = np.linspace(0, L, N + 1)\n        u_exact = np.sin(np.pi * x_grid / L) * np.exp(-alpha * (np.pi / L)**2 * T)\n\n        # --- Calculate L2 errors ---\n        error_coarse = calculate_l2_error(U_coarse, u_exact, dx)\n        error_fine = calculate_l2_error(U_fine, u_exact, dx)\n        error_re = calculate_l2_error(U_RE, u_exact, dx)\n        \n        results.extend([error_coarse, error_fine, error_re])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400855"}]}