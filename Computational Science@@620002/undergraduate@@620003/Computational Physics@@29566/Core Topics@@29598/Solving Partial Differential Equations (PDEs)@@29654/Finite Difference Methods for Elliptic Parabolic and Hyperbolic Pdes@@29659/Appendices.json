{"hands_on_practices": [{"introduction": "This first practice is your entry into solving elliptic PDEs, focusing on the two-dimensional Poisson equation which governs phenomena from electrostatics to steady-state heat flow. You will implement and compare the standard 5-point stencil against a higher-order 9-point stencil to discretize the Laplacian operator. Through this hands-on comparison, you will gain a concrete understanding of how the choice of discretization impacts numerical accuracy and see the theoretical order of accuracy verified in practice through a convergence study [@problem_id:2393516].", "problem": "Consider the two-dimensional Poisson equation on the unit square domain with homogeneous Dirichlet boundary condition. Let the open domain be $\\Omega = (0,1)\\times(0,1)$ and the boundary be $\\partial\\Omega$. Define the exact solution by $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ for $(x,y)\\in \\overline{\\Omega}$, which is analytic and non-polynomial. The source term is determined from the governing equation $-\\Delta u = f$ in $\\Omega$, with $u = 0$ on $\\partial\\Omega$. \n\na) Derive $f(x,y)$ in closed form from the definition of $u(x,y)$ and the equality $-\\Delta u = f$.\n\nb) For a uniform Cartesian grid with $m$ equal subdivisions per coordinate direction, define the grid spacing $h = 1/m$ and grid nodes $(x_i,y_j) = (i h, j h)$ for $i,j\\in\\{0,1,\\dots,m\\}$. Impose the boundary values by the Dirichlet condition $u(x,y)=0$ on $\\partial\\Omega$, which holds for the exact $u$. For interior nodes, form the discrete linear system corresponding to $-\\Delta u = f$ using both of the following discrete operators for $-\\Delta$ at an interior node $(i,j)$:\n- The standard second-order $5$-point stencil,\n$$\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right).$$\n- The classical fourth-order $9$-point stencil,\n$$\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big).$$\n\nc) For each chosen $m$, let $u_h^{(5)}$ and $u_h^{(9)}$ denote the numerical solutions on the grid obtained by solving the respective discrete systems with the right-hand side set to $f(x_i,y_j)$ at interior nodes. Construct the full grid function by setting boundary values to the exact $u(x_i,y_j)$ and interior values to the corresponding numerical solution. Define the discrete root-mean-square error (a discrete $L^2$ approximation) for a grid function $w$ relative to the exact $u$ by\n$$E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}.$$\nLet $E^{(5)}(h)$ and $E^{(9)}(h)$ denote these errors for the $5$-point and $9$-point solutions, respectively.\n\nd) For each consecutive pair of grid spacings $(h, h/2)$, define the observed base-$2$ convergence rates by\n$$p^{(5)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(5)}(h)}{E^{(5)}(h/2)}\\right),\\qquad p^{(9)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(9)}(h)}{E^{(9)}(h/2)}\\right).$$\n\nUse the following test suite of subdivision counts: $m\\in\\{2,4,8,16\\}$. For each $m$, use the definition of $u$ to compute $f$ and enforce the boundary condition $u=0$ on $\\partial\\Omega$. For the pairwise refinements $(m,m') = (2,4)$, $(4,8)$, and $(8,16)$, compute the corresponding observed convergence rates.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$.\n\nAll numerical values must be reported as floating-point numbers. No physical units are involved. Angles, if any appear, must be in radians. The final output format must match the specification exactly: a single line with the list in square brackets and values separated by commas.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extracted Givens\n-   **Governing Equation**: The two-dimensional Poisson equation $-\\Delta u = f$ on the open unit square domain $\\Omega = (0,1)\\times(0,1)$.\n-   **Boundary Condition (BC)**: Homogeneous Dirichlet boundary condition, $u = 0$ on the boundary $\\partial\\Omega$.\n-   **Exact Solution**: $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ for $(x,y)\\in \\overline{\\Omega} = [0,1]\\times[0,1]$.\n-   **Source Term**: Defined by the equality $f = -\\Delta u$.\n-   **Discretization**: A uniform Cartesian grid with $m$ subdivisions in each direction, resulting in grid spacing $h = 1/m$ and nodes $(x_i,y_j) = (ih, jh)$ for $i,j\\in\\{0,1,\\dots,m\\}$.\n-   **Discrete Operators**:\n    -   Standard second-order $5$-point stencil for the negative Laplacian: $\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right)$.\n    -   Classical fourth-order $9$-point stencil for the negative Laplacian: $\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big)$.\n-   **Numerical Solution**: $u_h^{(5)}$ and $u_h^{(9)}$ are solutions to the discrete linear systems arising from the stencils. The right-hand side is $f(x_i,y_j)$ at interior nodes. Boundary values are set to $u(x_i,y_j)=0$.\n-   **Error Metric**: Discrete root-mean-square error $E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}$.\n-   **Convergence Rate**: Observed base-$2$ rate $p(h\\to h/2) = \\log_2\\left(\\frac{E(h)}{E(h/2)}\\right)$.\n-   **Test Parameters**: Subdivision counts $m\\in\\{2,4,8,16\\}$.\n-   **Required Output**: A list of numerical values: $[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$.\n\nStep 2: Validation Using Extracted Givens\nThe problem is a standard exercise in the numerical analysis of partial differential equations, specifically the application of finite difference methods to the Poisson equation.\n-   **Scientifically Grounded**: The problem is based on established mathematical principles of numerical analysis and PDEs. The Poisson equation, finite difference stencils, and convergence analysis are all fundamental, well-understood concepts.\n-   **Well-Posed**: The Poisson equation with Dirichlet boundary conditions is a classic example of a well-posed elliptic problem. The resulting discrete linear systems for both stencils correspond to symmetric positive-definite matrices, guaranteeing unique solutions.\n-   **Objective**: The problem is stated in precise, objective mathematical language.\n-   **Consistency Check**: The prescribed exact solution $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ correctly satisfies the homogeneous Dirichlet boundary condition $u=0$ on $\\partial\\Omega$, since $\\sin(\\pi x) = 0$ for $x=0,1$ and $\\sin(\\pi y)=0$ for $y=0,1$.\n-   **Completeness**: All necessary information to formulate and solve the problem is provided.\n\nStep 3: Verdict and Action\nThe problem is valid. It is scientifically sound, well-posed, and self-contained. A complete solution will be provided.\n\n**Part a) Derivation of the Source Term $f(x,y)$**\n\nThe source term $f(x,y)$ is determined by the relation $f = -\\Delta u = -(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2})$. We compute the second partial derivatives of the exact solution $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$.\n\nFirst, the partial derivative with respect to $x$:\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) \\right) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) + \\pi \\mathrm{e}^{x+y}\\cos(\\pi x)\\sin(\\pi y) $$\nThe second partial derivative with respect to $x$:\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) \\right) \\\\ = \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) + \\mathrm{e}^{x+y}(\\pi\\cos(\\pi x) - \\pi^2\\sin(\\pi x))\\sin(\\pi y) \\\\ = \\mathrm{e}^{x+y}\\sin(\\pi y) \\left[ (1-\\pi^2)\\sin(\\pi x) + 2\\pi\\cos(\\pi x) \\right] $$\nDue to the symmetry of $u(x,y)$ with respect to interchange of $x$ and $y$, the second partial derivative with respect to $y$ is analogous:\n$$ \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y}\\sin(\\pi x) \\left[ (1-\\pi^2)\\sin(\\pi y) + 2\\pi\\cos(\\pi y) \\right] $$\nThe Laplacian $\\Delta u$ is the sum of these second derivatives:\n$$ \\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y} \\left[ 2(1-\\pi^2)\\sin(\\pi x)\\sin(\\pi y) + 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\nFinally, the source term is $f(x,y) = -\\Delta u$:\n$$ f(x,y) = \\mathrm{e}^{x+y} \\left[ 2(\\pi^2-1)\\sin(\\pi x)\\sin(\\pi y) - 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\nThis is the closed-form expression required.\n\n**Part b, c, d) Numerical Solution and Analysis**\n\nThe problem requires solving the linear system $A \\mathbf{u}_h = \\mathbf{b}$ for the unknown values of the numerical solution at the $(m-1)^2$ interior grid points. The vector $\\mathbf{u}_h$ contains the values $u_{i,j}$ for $i,j \\in \\{1, \\dots, m-1\\}$, arranged in lexicographical (column-major) order. The matrix $A$ represents the discrete negative Laplacian operator, and the vector $\\mathbf{b}$ contains the values of the source term $f(x_i, y_j)$ at the interior points.\n\nFor the $5$-point stencil, the matrix $A_5$ corresponding to $(-\\Delta_h^{(5)})$ can be constructed using Kronecker products. Let $T_{1D}$ be the $(m-1) \\times (m-1)$ matrix for the one-dimensional second derivative operator $-\\frac{d^2}{dx^2}$, given by $T_{1D} = \\frac{1}{h^2} \\text{tridiag}(-1, 2, -1)$. Let $I$ be the $(m-1) \\times (m-1)$ identity matrix. Then, the matrix for the two-dimensional operator is:\n$$ A_5 = I \\otimes T_{1D} + T_{1D} \\otimes I $$\n\nFor the $9$-point stencil, the matrix $A_9$ corresponding to $(-\\Delta_h^{(9)})$ has a block-tridiagonal structure $A_9 = \\text{block_tridiag}(B, D, B)$, where the blocks $D$ and $B$ are $(m-1) \\times (m-1)$ matrices:\n$$ D = \\frac{1}{6h^2} \\text{tridiag}(-4, 20, -4) $$\n$$ B = \\frac{1}{6h^2} \\text{tridiag}(-1, -4, -1) $$\nThis structure arises from the coefficients of the stencil coupling nodes within the same grid row (matrix $D$) and between adjacent grid rows (matrix $B$).\n\nThe numerical procedure for each $m \\in \\{2, 4, 8, 16\\}$ is as follows:\n1.  Set the grid spacing $h=1/m$ and define the grid coordinates.\n2.  Construct the sparse matrices $A_5$ and $A_9$ of size $(m-1)^2 \\times (m-1)^2$.\n3.  Construct the right-hand side vector $\\mathbf{b}$ by evaluating $f(x_i, y_j)$ at the $(m-1)^2$ interior grid points.\n4.  Solve the two linear systems $A_5 \\mathbf{u}_h^{(5)} = \\mathbf{b}$ and $A_9 \\mathbf{u}_h^{(9)} = \\mathbf{b}$ to obtain the numerical solutions at the interior points.\n5.  Form the full $(m+1) \\times (m+1)$ grid solutions $u_h^{(5)}$ and $u_h^{(9)}$ by embedding the interior solutions into a grid of zeros, which correctly represents the homogeneous boundary conditions.\n6.  Evaluate the exact solution $u(x,y)$ on the full grid.\n7.  Compute the discrete RMS errors $E^{(5)}(h)$ and $E^{(9)}(h)$ using the specified formula. These errors are stored for each value of $m$.\n8.  After computing errors for all $m$, the observed convergence rates $p^{(5)}$ and $p^{(9)}$ are calculated for each refinement level using the given logarithmic formula.\n\nThe expected convergence rates are $p \\approx 2$ for the second-order $5$-point stencil and $p \\approx 4$ for the fourth-order $9$-point stencil, as these are the theoretical orders of accuracy for the respective discretizations. The numerical experiment serves to verify this theoretical behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation on a unit square using 5-point and 9-point\n    finite difference stencils and computes errors and convergence rates.\n    \"\"\"\n    m_values = [2, 4, 8, 16]\n    errors = {'5': {}, '9': {}}\n\n    def u_exact_func(x, y):\n        \"\"\"Computes the exact solution u(x,y).\"\"\"\n        return np.exp(x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_func(x, y):\n        \"\"\"Computes the source term f(x,y) = -Delta u.\"\"\"\n        term1 = 2 * (np.pi**2 - 1) * np.sin(np.pi * x) * np.sin(np.pi * y)\n        term2 = -2 * np.pi * (np.cos(np.pi * x) * np.sin(np.pi * y) + np.sin(np.pi * x) * np.cos(np.pi * y))\n        return np.exp(x + y) * (term1 + term2)\n\n    for m in m_values:\n        h = 1.0 / m\n        N = m - 1  # Number of interior grid points in one dimension\n\n        # Create the full grid\n        grid_pts = np.linspace(0, 1, m + 1)\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n        # Evaluate exact solution on the full grid\n        u_exact_grid = u_exact_func(X, Y)\n\n        if N == 0: # Trivial case with no interior points\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n        else:\n            N2 = N * N # Total number of unknowns\n\n            # Interior grid points and RHS vector b\n            interior_grid_pts = np.linspace(h, 1 - h, N)\n            XI, YI = np.meshgrid(interior_grid_pts, interior_grid_pts, indexing='ij')\n            # Use Fortran ordering for flattening to match lexicographical (column-major) order\n            b = f_func(XI, YI).flatten(order='F')\n\n            # --- 5-point stencil system ---\n            # A_5 = I kron T + T kron I for -Delta\n            T_1d = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(N, N))\n            I_n = sparse.eye(N)\n            A5 = (1 / h**2) * (sparse.kron(I_n, T_1d) + sparse.kron(T_1d, I_n))\n            \n            u_sol_5_flat = spsolve(A5.tocsc(), b)\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_5[1:-1, 1:-1] = u_sol_5_flat.reshape((N, N), order='F')\n\n            # --- 9-point stencil system ---\n            # Block-tridiagonal construction A_9 = block_tridiag(B, D, B)\n            D_diag_vals = [np.full(N - 1, -4), np.full(N, 20), np.full(N - 1, -4)]\n            D = (1 / (6 * h**2)) * sparse.diags(D_diag_vals, [-1, 0, 1])\n\n            B_diag_vals = [np.full(N - 1, -1), np.full(N, -4), np.full(N - 1, -1)]\n            B = (1 / (6 * h**2)) * sparse.diags(B_diag_vals, [-1, 0, 1])\n            \n            # Off-diagonal blocks for Kronecker sum\n            off_diag_block_matrix = sparse.diags([1, 1], [-1, 1], shape=(N, N))\n            A9 = sparse.kron(I_n, D) + sparse.kron(off_diag_block_matrix, B)\n            \n            u_sol_9_flat = spsolve(A9.tocsc(), b)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n            u_sol_9[1:-1, 1:-1] = u_sol_9_flat.reshape((N, N), order='F')\n\n        # Compute discrete RMS error: E = sqrt(h^2 * sum((w-u)^2))\n        # This is equivalent to h * Frobenius_norm(w-u)\n        diff_5 = u_sol_5 - u_exact_grid\n        errors['5'][m] = h * np.sqrt(np.sum(diff_5**2))\n\n        diff_9 = u_sol_9 - u_exact_grid\n        errors['9'][m] = h * np.sqrt(np.sum(diff_9**2))\n\n    # Calculate convergence rates and assemble final results\n    results = []\n    \n    # E(h=1/2) for m=2\n    results.append(errors['5'][2])\n    results.append(errors['9'][2])\n\n    # p(1/2 -> 1/4) for m=2,4\n    results.append(np.log2(errors['5'][2] / errors['5'][4]))\n    results.append(np.log2(errors['9'][2] / errors['9'][4]))\n\n    # p(1/4 -> 1/8) for m=4,8\n    results.append(np.log2(errors['5'][4] / errors['5'][8]))\n    results.append(np.log2(errors['9'][4] / errors['9'][8]))\n\n    # p(1/8 -> 1/16) for m=8,16\n    results.append(np.log2(errors['5'][8] / errors['5'][16]))\n    results.append(np.log2(errors['9'][8] / errors['9'][16]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393516"}, {"introduction": "Building on our understanding of elliptic solvers, we now tackle a more realistic scenario common in physics and engineering: problems with discontinuous coefficients. This exercise explores a steady-state heat conduction problem across an interface between two different materials, a situation where the governing equation's coefficients change abruptly. By implementing a finite difference scheme that bridges this discontinuity, you will gain critical insight into why the numerical treatment of such interfaces is fundamental to building a reliable physical model and how seemingly simple choices can affect the global accuracy of the solution [@problem_id:2393520].", "problem": "Consider the one-dimensional steady heat conduction problem with a discontinuous thermal conductivity across a material interface. Let the domain be the closed interval $[0,1]$ with interface location $x_{\\mathrm{I}}=\\tfrac{1}{2}$. The thermal conductivity $k(x)$ is piecewise constant and right-continuous, defined by\n$$\nk(x) = \\begin{cases}\nk_1, & x &lt; x_{\\mathrm{I}},\\\\\nk_2, & x \\ge x_{\\mathrm{I}}.\n\\end{cases}\n$$\nThe temperature $u(x)$ satisfies the boundary value problem\n$$\n- \\dfrac{\\mathrm{d}}{\\mathrm{d}x}\\left( k(x)\\, \\dfrac{\\mathrm{d}u}{\\mathrm{d}x}(x) \\right) = 1 \\quad \\text{for } x \\in (0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\nand at the interface $x=x_{\\mathrm{I}}$ the exact solution is characterized by continuity of temperature and continuity of heat flux,\n$$\nu(x_{\\mathrm{I}}^-)=u(x_{\\mathrm{I}}^+), \\qquad k_1\\, u'(x_{\\mathrm{I}}^-)=k_2\\, u'(x_{\\mathrm{I}}^+).\n$$\nOn a uniform grid with $N$ subintervals, grid spacing $h=1/N$, and grid points $x_i=i\\,h$ for $i=0,1,\\dots,N$, let $u_i$ denote an approximation to $u(x_i)$. Define nodal conductivities by the right-continuous rule $k_i := k(x_i)$ and face conductivities by the arithmetic average $k_{i+\\tfrac{1}{2}} := \\tfrac{1}{2}\\big(k_i+k_{i+1}\\big)$. The discrete interior equations for $i=1,2,\\dots,N-1$ are specified by the conservative centered finite difference form\n$$\n-\\frac{1}{h}\\left( k_{i+\\tfrac{1}{2}}\\, \\frac{u_{i+1}-u_i}{h} - k_{i-\\tfrac{1}{2}}\\, \\frac{u_i-u_{i-1}}{h} \\right) = 1,\n$$\nwith boundary values $u_0=0$ and $u_N=0$ imposed exactly.\n\nTasks to perform:\n\n1) For given $(k_1,k_2,N)$, compute the numerical solution $\\{u_i\\}_{i=0}^N$ from the discrete equations. Define the maximum-norm nodal error\n$$\nE(N;k_1,k_2) := \\max_{0 \\le i \\le N} \\left| u_i - u(x_i) \\right|,\n$$\nwhere $u(x)$ is the exact solution that satisfies $-k_j\\,u''(x)=1$ in each material region $j\\in\\{1,2\\}$, together with the boundary and interface conditions stated above.\n\n2) For a pair of grids with $N_{\\mathrm{c}}&lt;N_{\\mathrm{f}}$, define the observed order of accuracy\n$$\np := \\frac{\\log\\!\\left( E(N_{\\mathrm{c}};k_1,k_2)\\big/ E(N_{\\mathrm{f}};k_1,k_2)\\right)}{\\log\\!\\left(N_{\\mathrm{f}}/N_{\\mathrm{c}}\\right)}.\n$$\n\nYour program must compute $p$ for each parameter set in the following test suite, where each case uses $x_{\\mathrm{I}}=\\tfrac{1}{2}$ and $N_{\\mathrm{c}}$ and $N_{\\mathrm{f}}$ are even integers:\n\n- Case 1 (moderate contrast): $(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(1.0,2.0,64,128)$.\n- Case 2 (high contrast, soft to hard): $(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(1.0,100.0,64,128)$.\n- Case 3 (high contrast, hard to soft): $(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(100.0,1.0,64,128)$.\n- Case 4 (no interface effect): $(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(1.0,1.0,64,128)$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the four values of $p$ for the cases above, in this order, as a comma-separated list enclosed in square brackets. Each value must be printed as a decimal number with exactly six digits after the decimal point. For example: \"[p1,p2,p3,p4]\".", "solution": "The problem as stated is a standard, well-posed one-dimensional, two-point boundary value problem for steady-state heat conduction with a piecewise constant coefficient. It is scientifically grounded, self-contained, and presents a clear, objective task. Therefore, it is valid for analysis. We proceed with the solution.\n\nThe solution requires two main components: first, the derivation of the exact analytical solution to serve as a benchmark, and second, the implementation and analysis of the specified finite difference scheme.\n\nFirst, we determine the exact solution $u(x)$. The governing equation is $-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left( k(x)\\, \\frac{\\mathrm{d}u}{\\mathrm{d}x}(x) \\right) = 1$. The domain is partitioned at the interface $x_{\\mathrm{I}}=\\tfrac{1}{2}$ into two regions.\nIn Region $1$ ($0 \\le x < \\tfrac{1}{2}$), the thermal conductivity is $k(x)=k_1$, and the equation simplifies to $-k_1 u_1''(x) = 1$.\nIn Region $2$ ($\\tfrac{1}{2} \\le x \\le 1$), the thermal conductivity is $k(x)=k_2$, and the equation is $-k_2 u_2''(x) = 1$.\n\nIntegrating twice in each region yields general solutions that are quadratic in $x$:\nFor Region $1$: $u_1(x) = -\\frac{x^2}{2k_1} + A_1 x + B_1$.\nFor Region $2$: $u_2(x) = -\\frac{x^2}{2k_2} + A_2 x + B_2$.\nThe four constants of integration, $A_1$, $B_1$, $A_2$, and $B_2$, are determined by the four given conditions:\n$1$. Boundary condition at $x=0$: $u_1(0)=0$.\n$2$. Boundary condition at $x=1$: $u_2(1)=0$.\n$3$. Temperature continuity at $x=x_{\\mathrm{I}}$: $u_1(x_{\\mathrm{I}}) = u_2(x_{\\mathrm{I}})$.\n$4$. Heat flux continuity at $x=x_{\\mathrm{I}}$: $k_1 u_1'(x_{\\mathrm{I}}) = k_2 u_2'(x_{\\mathrm{I}})$.\n\nApplying these conditions systematically:\nFrom $u_1(0)=0$, we find $B_1=0$.\nFrom $k_1 u_1'(x_{\\mathrm{I}}) = k_2 u_2'(x_{\\mathrm{I}})$, we have $k_1(-\\frac{x_{\\mathrm{I}}}{k_1} + A_1) = k_2(-\\frac{x_{\\mathrm{I}}}{k_2} + A_2)$, which simplifies to $k_1 A_1 = k_2 A_2$.\nThe remaining two conditions form a linear system for $A_1$ and $B_2$ (or $A_1$ and $A_2$). Substituting $x_{\\mathrm{I}} = \\tfrac{1}{2}$, we solve this system to find the constants:\n$$\nA_1 = \\frac{k_2+3k_1}{4k_1(k_1+k_2)}, \\qquad A_2 = \\frac{k_1}{k_2}A_1 = \\frac{k_2+3k_1}{4k_2(k_1+k_2)}\n$$\n$$\nB_1 = 0, \\qquad B_2 = \\frac{1}{2k_2} - A_2 = \\frac{k_2-k_1}{4k_2(k_1+k_2)}\n$$\nThe exact solution is therefore given by the piecewise function:\n$$\nu(x) = \\begin{cases}\n    -\\dfrac{x^2}{2k_1} + \\dfrac{k_2+3k_1}{4k_1(k_1+k_2)} x & \\text{for } 0 \\le x \\le \\tfrac{1}{2} \\\\[1.5em]\n    -\\dfrac{x^2}{2k_2} + \\dfrac{k_2+3k_1}{4k_2(k_1+k_2)} x + \\dfrac{k_2-k_1}{4k_2(k_1+k_2)} & \\text{for } \\tfrac{1}{2} < x \\le 1\n\\end{cases}\n$$\n\nNext, we address the numerical solution. The domain $[0, 1]$ is discretized into a uniform grid with $N$ subintervals of width $h=1/N$. The grid points are $x_i = i h$ for $i=0, 1, \\dots, N$. The specified finite difference scheme is:\n$$\n-\\frac{1}{h}\\left( k_{i+\\tfrac{1}{2}}\\, \\frac{u_{i+1}-u_i}{h} - k_{i-\\tfrac{1}{2}}\\, \\frac{u_i-u_{i-1}}{h} \\right) = 1, \\quad \\text{for } i=1, \\dots, N-1.\n$$\nRearranging, we obtain a linear equation for each interior node $i$:\n$$\n-k_{i-\\tfrac{1}{2}} u_{i-1} + (k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}) u_i - k_{i+\\tfrac{1}{2}} u_{i+1} = h^2.\n$$\nThe set of these $N-1$ equations, together with the boundary conditions $u_0=0$ and $u_N=0$, forms a linear system $A\\mathbf{u} = \\mathbf{b}$ for the vector of unknowns $\\mathbf{u} = (u_1, u_2, \\dots, u_{N-1})^T$. The matrix $A$ is a symmetric, positive-definite, tridiagonal matrix. The face conductivities $k_{i\\pm\\tfrac{1}{2}}$ are defined by the arithmetic mean of nodal conductivities, $k_{i+\\tfrac{1}{2}} = \\tfrac{1}{2}(k_i + k_{i+1})$, where $k_i = k(x_i)$. Since $N$ is even, the interface $x_{\\mathrm{I}}=\\tfrac{1}{2}$ coincides with the grid point $x_{N/2}$. The right-continuous definition of $k(x)$ implies $k_{N/2} = k_2$, while $k_{N/2-1} = k_1$. The face conductivity across the interface is thus $k_{N/2 - \\tfrac{1}{2}} = \\tfrac{1}{2}(k_1+k_2)$.\n\nThe computational procedure is as follows:\n$1$. For a given grid size $N$ and conductivities $k_1, k_2$, define the nodal conductivities $k_i$ and face conductivities $k_{i\\pm\\tfrac{1}{2}}$.\n$2$. Construct the $(N-1) \\times (N-1)$ tridiagonal matrix $A$ and the right-hand side vector $\\mathbf{b}$ of size $N-1$ with all elements equal to $h^2$.\n$3$. Solve the linear system $A\\mathbf{u} = \\mathbf{b}$ for the interior nodal values $u_1, \\dots, u_{N-1}$. A specialized solver for banded systems is efficient for this task.\n$4$. Append the boundary values $u_0=0$ and $u_N=0$ to form the complete numerical solution vector $\\{u_i\\}_{i=0}^N$.\n$5$. Evaluate the exact solution $u(x_i)$ at each grid point $x_i$.\n$6$. Compute the maximum-norm nodal error $E(N;k_1,k_2) = \\max_{0 \\le i \\le N} | u_i - u(x_i) |$.\n$7$. Repeat steps $1$-$6$ for the coarse grid ($N=N_{\\mathrm{c}}$) and the fine grid ($N=N_{\\mathrm{f}}$) to obtain errors $E_{\\mathrm{c}}$ and $E_{\\mathrm{f}}$.\n$8$. Calculate the observed order of accuracy using the formula $p = \\log(E_{\\mathrm{c}}/E_{\\mathrm{f}}) / \\log(N_{\\mathrm{f}}/N_{\\mathrm{c}})$.\n\nIt must be noted that while the finite difference stencil is formally second-order accurate for a smooth problem, the use of an arithmetic mean for conductivity at a material interface is known to reduce the global accuracy to first order ($p \\approx 1$). In the special case where $k_1=k_2$, there is no interface, the problem is smooth, and the expected second-order accuracy ($p \\approx 2$) should be recovered. The numerical experiment will verify this behavior.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n\n    def get_exact_solution(x, k1, k2):\n        \"\"\"\n        Computes the exact analytical solution u(x) for the given problem.\n\n        Args:\n            x (np.ndarray): Array of spatial coordinates.\n            k1 (float): Thermal conductivity in the region x < 0.5.\n            k2 (float): Thermal conductivity in the region x >= 0.5.\n\n        Returns:\n            np.ndarray: The exact solution evaluated at points x.\n        \"\"\"\n        xI = 0.5\n        \n        # Handle the homogeneous case to avoid division by zero if k1+k2=0\n        if k1 + k2 == 0:\n            if k1 == 0 and k2 == 0: # Not a physically valid case, but handle numerically\n                return np.zeros_like(x, dtype=float)\n        \n        # Coefficients from analytical derivation\n        A1 = (k2 + 3.0 * k1) / (4.0 * k1 * (k1 + k2))\n        A2 = (k2 + 3.0 * k1) / (4.0 * k2 * (k1 + k2))\n        \n        u = np.zeros_like(x, dtype=float)\n        \n        # Define masks for the two material regions\n        mask1 = x = xI\n        mask2 = x > xI\n        \n        # Solution in the first region\n        u[mask1] = -x[mask1]**2 / (2.0 * k1) + A1 * x[mask1]\n        \n        # Solution in the second region can be written in a more stable form\n        # u(x) = (-x^2+1)/(2k2) + A2(x-1)\n        u[mask2] = -(x[mask2]**2 - 1.0) / (2.0 * k2) + A2 * (x[mask2] - 1.0)\n        \n        return u\n\n    def compute_error(N, k1, k2):\n        \"\"\"\n        Computes the numerical solution and its maximum-norm error against the exact solution.\n\n        Args:\n            N (int): Number of subintervals in the grid.\n            k1 (float): Thermal conductivity for x  0.5.\n            k2 (float): Thermal conductivity for x = 0.5.\n\n        Returns:\n            float: The maximum-norm error between numerical and exact solutions.\n        \"\"\"\n        h = 1.0 / N\n        x_grid = np.linspace(0.0, 1.0, N + 1)\n        \n        # Nodal conductivities k_i based on right-continuous k(x)\n        xI_idx = N // 2\n        k_nodal = np.full(N + 1, k1)\n        k_nodal[xI_idx:] = k2\n\n        # Face conductivities k_{i+1/2} using arithmetic mean\n        k_face = 0.5 * (k_nodal[:-1] + k_nodal[1:])\n\n        # Set up the tridiagonal system A*u = b for interior nodes u_1, ..., u_{N-1}\n        num_unknowns = N - 1\n        \n        # The banded matrix `ab` for scipy.linalg.solve_banded\n        # ab has l=1 lower diagonal, u=1 upper diagonal\n        ab = np.zeros((3, num_unknowns))\n        \n        # Main diagonal (row u=1)\n        ab[1, :] = k_face[1:N] + k_face[0:N-1]\n        \n        # Upper diagonal (row u-1=0), shifted\n        ab[0, 1:] = -k_face[1:N-1]\n\n        # Lower diagonal (row u+1=2), shifted\n        ab[2, :-1] = -k_face[1:N-1]\n        \n        # Right-hand side vector\n        b = np.full(num_unknowns, h**2)\n        \n        # Solve the linear system for interior nodes\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Assemble the full numerical solution including boundaries\n        u_numerical = np.zeros(N + 1)\n        u_numerical[1:-1] = u_interior\n        \n        # Compute exact solution at grid points\n        u_exact = get_exact_solution(x_grid, k1, k2)\n        \n        # Calculate the maximum-norm nodal error\n        error = np.max(np.abs(u_numerical - u_exact))\n        return error\n\n    # -- Main execution --\n    \n    test_cases = [\n        # (k1, k2, Nc, Nf)\n        (1.0, 2.0, 64, 128),     # Case 1: moderate contrast\n        (1.0, 100.0, 64, 128),  # Case 2: high contrast, soft to hard\n        (100.0, 1.0, 64, 128),  # Case 3: high contrast, hard to soft\n        (1.0, 1.0, 64, 128),     # Case 4: no interface\n    ]\n\n    results = []\n    for k1, k2, Nc, Nf in test_cases:\n        # Calculate errors on coarse and fine grids\n        error_c = compute_error(Nc, k1, k2)\n        error_f = compute_error(Nf, k1, k2)\n        \n        # Compute the observed order of accuracy\n        # p = log(E_c / E_f) / log(N_f / N_c)\n        p = np.log(error_c / error_f) / np.log(Nf / Nc)\n        results.append(p)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join([f'{p:.6f}' for p in results])}]\")\n\nsolve()\n```", "id": "2393520"}, {"introduction": "We now transition from steady-state elliptic equations to time-dependent parabolic equations, with the 1D heat equation as our canonical example. This practice focuses on a subtle but critical aspect of numerical simulation: the implementation of derivative boundary conditions, known as Neumann conditions, which specify the flux at the domain edges. By comparing a simple first-order method with a more sophisticated second-order 'ghost point' implementation, you will observe firsthand how a seemingly local choice at the boundary dictates the global accuracy of the entire time-evolving solution [@problem_id:2393512].", "problem": "Consider the one-dimensional heat equation (a parabolic partial differential equation) on the spatial interval $[0,1]$,\n$$\nu_t(x,t) = \\alpha \\, u_{xx}(x,t), \\quad x \\in [0,1], \\; t \\in [0,T],\n$$\nwith thermal diffusivity $\\alpha  0$, subject to Neumann boundary conditions\n$$\nu_x(0,t) = g_0(t), \\quad u_x(1,t) = g_1(t),\n$$\nand an initial condition\n$$\nu(x,0) = u_0(x).\n$$\nInvestigate how different boundary condition closures affect the overall accuracy by comparing two mathematically specified implementations of the Neumann boundary condition that differ in their consistency order in space. The interior spatial discretization must be the standard second-order centered finite difference for $u_{xx}$ at all interior grid points, and time advancement must be the forward Euler method. The two boundary closures to be compared are:\n\n1. A first-order-consistent one-sided closure (denoted $\\mathrm{FO}$): enforce the Neumann boundary condition at $x=0$ and $x=1$ using one-sided first-order finite differences to eliminate ghost values,\n$$\n\\frac{u(x_0,t) - u(x_{-1},t)}{h} = g_0(t) \\;\\;\\Rightarrow\\;\\; u(x_{-1},t) = u(x_0,t) - h\\, g_0(t),\n$$\n$$\n\\frac{u(x_{N+1},t) - u(x_N,t)}{h} = g_1(t) \\;\\;\\Rightarrow\\;\\; u(x_{N+1},t) = u(x_N,t) + h\\, g_1(t),\n$$\nwhere $h$ is the spatial step, $x_i = i h$, $i=0,1,\\dots,N$, with $N h = 1$, and $x_{-1}$ and $x_{N+1}$ are ghost points.\n\n2. A second-order-consistent centered closure (denoted $\\mathrm{SO}$): enforce the Neumann boundary condition at $x=0$ and $x=1$ using centered finite differences to eliminate ghost values,\n$$\n\\frac{u(x_1,t) - u(x_{-1},t)}{2h} = g_0(t) \\;\\Rightarrow\\; u(x_{-1},t) = u(x_1,t) - 2 h\\, g_0(t),\n$$\n$$\n\\frac{u(x_{N+1},t) - u(x_{N-1},t)}{2h} = g_1(t) \\;\\Rightarrow\\; u(x_{N+1},t) = u(x_{N-1},t) + 2 h\\, g_1(t).\n$$\n\nAt each explicit time step, the ghost values are used to evaluate the discrete Laplacian at the boundary nodes with the same second-order centered formula for $u_{xx}$ as used in the interior. The forward Euler time step must be chosen as\n$$\n\\Delta t = c \\, \\frac{h^2}{2 \\alpha},\n$$\nwith a fixed constant $c = 0.45$, so that for $T  0$ the number of time steps is the nearest integer to $T / \\Delta t$, and the final step size is adjusted so that the final time is exactly $T$.\n\nUse the following two exact manufactured solutions (no physical units are involved in this problem):\n- Case A (nonzero Neumann flux): take\n$$\nu(x,t) = \\sin(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\sin(\\pi x), \\quad g_0(t) = \\pi \\, e^{-\\alpha \\pi^2 t}, \\quad g_1(t) = -\\pi \\, e^{-\\alpha \\pi^2 t}.\n$$\n- Case B (homogeneous Neumann flux): take\n$$\nu(x,t) = \\cos(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\cos(\\pi x), \\quad g_0(t) = 0, \\quad g_1(t) = 0.\n$$\n\nFix parameters $\\alpha = 1$, $T = 0.1$. For each of the two boundary closures $\\mathrm{FO}$ and $\\mathrm{SO}$, and for each of the two cases A and B, compute the discrete $L^2$-error at time $T$ for the uniform grids with $N \\in \\{20, 40, 80, 160\\}$ (so that $h = 1/N$ and the grid points are $x_i = i h$, $i = 0, 1, \\dots, N$). For an error sequence $E(h)$ gathered over these $4$ refinements, define the observed spatial order $p$ as the slope of the least-squares fit of $\\log E$ versus $\\log h$.\n\nYour program must:\n- Implement the forward Euler time integration with the stated $\\Delta t$ formula and second-order centered interior spatial discretization.\n- Implement the two boundary closures $\\mathrm{FO}$ and $\\mathrm{SO}$ exactly as stated.\n- For each of the two cases (A and B) and each boundary closure, compute the observed order $p$ from the four-grid error sequences using least squares on $\\{(\\log h, \\log E(h))\\}$.\n- Additionally, report whether, on the finest grid $N=160$, the $\\mathrm{SO}$ closure attains a smaller $L^2$-error than the $\\mathrm{FO}$ closure.\n\nTest suite and required outputs:\n- Use $\\alpha = 1$, $T = 0.1$, $c = 0.45$, and $N \\in \\{20, 40, 80, 160\\}$.\n- Produce six outputs in the following order:\n  1. The observed order $p$ for Case A with $\\mathrm{FO}$.\n  2. The observed order $p$ for Case A with $\\mathrm{SO}$.\n  3. The observed order $p$ for Case B with $\\mathrm{FO}$.\n  4. The observed order $p$ for Case B with $\\mathrm{SO}$.\n  5. A boolean indicating whether, on $N=160$ for Case A, the $L^2$-error with $\\mathrm{SO}$ is strictly smaller than with $\\mathrm{FO}$.\n  6. A boolean indicating whether, on $N=160$ for Case B, the $L^2$-error with $\\mathrm{SO}$ is strictly smaller than with $\\mathrm{FO}$.\n\nFinal output format:\nYour program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the exact order listed above. For example, an output like\n$$\n[p_A^{\\mathrm{FO}}, p_A^{\\mathrm{SO}}, p_B^{\\mathrm{FO}}, p_B^{\\mathrm{SO}}, b_A, b_B]\n$$\nwhere the first four entries are real numbers (floats) and the last two entries are booleans. No other text should be printed.", "solution": "The problem statement has been rigorously validated and is determined to be scientifically grounded, well-posed, and self-contained. It presents a standard numerical analysis task involving the finite difference method for a parabolic partial differential equation. All parameters, equations, and conditions are explicitly defined, forming a consistent and solvable problem. We proceed with the derivation and implementation of the solution.\n\nThe problem requires simulating the one-dimensional heat equation $u_t(x,t) = \\alpha \\, u_{xx}(x,t)$ on the domain $x \\in [0,1]$ and $t \\in [0,T]$. We employ a finite difference method on a uniform grid with spatial points $x_i = i h$ for $i=0, 1, \\dots, N$ where $h=1/N$ is the spatial step size. The time domain is discretized into steps of size $\\Delta t$, with $t_n = n \\Delta t$. Let $u_i^n$ be the numerical approximation of the exact solution $u(x_i, t_n)$.\n\nThe time derivative $u_t$ is approximated using the first-order accurate forward Euler method. The spatial second derivative $u_{xx}$ is approximated using the second-order accurate centered difference stencil. Combining these discretizations yields the update rule for all grid points $i=0, \\dots, N$:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\nRearranging for $u_i^{n+1}$ and introducing the mesh Fourier number $\\lambda = \\frac{\\alpha \\Delta t}{h^2}$, we obtain the explicit update formula:\n$$\nu_i^{n+1} = u_i^n + \\lambda (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\nThis formula is applied at all interior points, $i = 1, \\dots, N-1$. For the boundary points $i=0$ and $i=N$, the formula requires values at the \"ghost points\" $x_{-1} = -h$ and $x_{N+1} = 1+h$. These values, $u_{-1}^n$ and $u_{N+1}^n$, are determined by enforcing the Neumann boundary conditions, $u_x(0,t) = g_0(t)$ and $u_x(1,t) = g_1(t)$, using two different finite difference closures.\n\nThe problem specifies a fixed relationship between the time and space steps: $\\Delta t = c \\frac{h^2}{2 \\alpha}$ with $c = 0.45$. This gives $\\lambda = c/2 = 0.225$, which satisfies the stability condition $\\lambda \\le 1/2$ for the forward Euler method. The number of time steps is chosen as the nearest integer to $T/\\Delta t$, and $\\Delta t$ is then adjusted to ensure the final time is exactly $T$.\n\nThe two boundary closures are as follows:\n\n1.  **First-Order (FO) Closure**: The ghost points are determined by a first-order accurate one-sided difference approximation of the Neumann condition as specified:\n    $$\n    u_{-1}^n = u_0^n - h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_N^n + h g_1(t_n)\n    $$\n    Substituting these into the general update formula for $i=0$ and $i=N$ gives the specific boundary update rules:\n    -   At $i=0$: $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + (u_0^n - h g_0(t_n))) = (1-\\lambda) u_0^n + \\lambda u_1^n - \\lambda h g_0(t_n)$.\n    -   At $i=N$: $u_N^{n+1} = u_N^n + \\lambda ((u_N^n + h g_1(t_n)) - 2u_N^n + u_{N-1}^n) = \\lambda u_{N-1}^n + (1-\\lambda) u_N^n + \\lambda h g_1(t_n)$.\n    The local truncation error of this boundary condition implementation is $\\mathcal{O}(h)$. This is expected to limit the overall spatial accuracy of the entire scheme to first order, so the observed convergence rate $p$ should be approximately $1$.\n\n2.  **Second-Order (SO) Closure**: The ghost points are determined by a second-order accurate centered difference approximation of the Neumann condition:\n    $$\n    u_{-1}^n = u_1^n - 2h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_{N-1}^n + 2h g_1(t_n)\n    $$\n    Substituting these yields the boundary update rules:\n    -   At $i=0$: $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + (u_1^n - 2h g_0(t_n))) = (1-2\\lambda) u_0^n + 2\\lambda u_1^n - 2\\lambda h g_0(t_n)$.\n    -   At $i=N$: $u_N^{n+1} = u_N^n + \\lambda ((u_{N-1}^n + 2h g_1(t_n)) - 2u_N^n + u_{N-1}^n) = 2\\lambda u_{N-1}^n + (1-2\\lambda) u_N^n + 2\\lambda h g_1(t_n)$.\n    The local truncation error of this boundary implementation is $\\mathcal{O}(h^2)$, which is consistent with the $\\mathcal{O}(h^2)$ accuracy of the interior spatial discretization. The temporal error is $\\mathcal{O}(\\Delta t) = \\mathcal{O}(h^2)$. Therefore, the entire scheme is expected to be second-order accurate, and the observed convergence rate $p$ should be approximately $2$.\n\nThe numerical experiment proceeds as follows: for each case (A, B) and each closure (FO, SO), we solve the problem for a sequence of grid resolutions $N \\in \\{20, 40, 80, 160\\}$. For each resolution, we compute the final numerical solution $u_i$ at time $T$. The error is measured using the discrete $L^2$-norm, defined as $E(h) = \\sqrt{h \\sum_{i=0}^N (u_i - u_{exact}(x_i, T))^2}$. The observed order of convergence, $p$, is calculated as the slope of the linear least-squares fit to the points $(\\log h, \\log E(h))$. Finally, the errors on the finest grid ($N=160$) are compared for the two closures.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified. It computes convergence orders\n    for two different Neumann boundary condition closures for the 1D heat equation.\n    \"\"\"\n    # Define problem parameters\n    alpha = 1.0\n    T = 0.1\n    c = 0.45\n    N_values = [20, 40, 80, 160]\n\n    # Define the two manufactured solution cases\n    case_A = {\n        'name': 'A',\n        'u_exact': lambda x, t, a: np.sin(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.sin(np.pi * x),\n        'g_0': lambda t, a: np.pi * np.exp(-a * np.pi**2 * t),\n        'g_1': lambda t, a: -np.pi * np.exp(-a * np.pi**2 * t)\n    }\n\n    case_B = {\n        'name': 'B',\n        'u_exact': lambda x, t, a: np.cos(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.cos(np.pi * x),\n        'g_0': lambda t, a: 0.0,\n        'g_1': lambda t, a: 0.0\n    }\n\n    # Define the configurations to test\n    test_configs = [\n        {'case': case_A, 'closure': 'FO'},\n        {'case': case_A, 'closure': 'SO'},\n        {'case': case_B, 'closure': 'FO'},\n        {'case': case_B, 'closure': 'SO'},\n    ]\n\n    observed_orders = []\n    errors_N160 = {}\n\n    for config in test_configs:\n        case = config['case']\n        closure_type = config['closure']\n        \n        log_h_list = []\n        log_E_list = []\n\n        for N in N_values:\n            h = 1.0 / N\n            x = np.linspace(0.0, 1.0, N + 1)\n            \n            # Time stepping setup\n            dt_base = c * h**2 / (2.0 * alpha)\n            num_steps = int(round(T / dt_base))\n            dt = T / num_steps\n            \n            lam = alpha * dt / h**2\n            \n            # Initial condition\n            u = case['u_0'](x)\n            \n            # Time integration loop\n            for n in range(num_steps):\n                t_n = n * dt\n                u_new = np.zeros_like(u)\n                \n                # Interior points update\n                u_new[1:-1] = u[1:-1] + lam * (u[:-2] - 2 * u[1:-1] + u[2:])\n                \n                # Boundary functions g0(t), g1(t)\n                g0_tn = case['g_0'](t_n, alpha)\n                g1_tn = case['g_1'](t_n, alpha)\n\n                # Boundary points update\n                if closure_type == 'FO':\n                    u_new[0] = (1.0 - lam) * u[0] + lam * u[1] - lam * h * g0_tn\n                    u_new[-1] = lam * u[-2] + (1.0 - lam) * u[-1] + lam * h * g1_tn\n                elif closure_type == 'SO':\n                    u_new[0] = (1.0 - 2.0 * lam) * u[0] + 2.0 * lam * u[1] - 2.0 * lam * h * g0_tn\n                    u_new[-1] = 2.0 * lam * u[-2] + (1.0 - 2.0 * lam) * u[-1] + 2.0 * lam * h * g1_tn\n\n                u = u_new\n\n            # Compute error at final time T\n            u_exact_T = case['u_exact'](x, T, alpha)\n            error = np.sqrt(h) * np.linalg.norm(u - u_exact_T)\n            \n            log_h_list.append(np.log(h))\n            log_E_list.append(np.log(error))\n            \n            if N == 160:\n                errors_N160[(case['name'], closure_type)] = error\n\n        # Compute observed order of convergence using least-squares fit\n        p, _ = np.polyfit(log_h_list, log_E_list, 1)\n        observed_orders.append(p)\n    \n    # Final comparisons for N=160\n    b_A = errors_N160[('A', 'SO')]  errors_N160[('A', 'FO')]\n    b_B = errors_N160[('B', 'SO')]  errors_N160[('B', 'FO')]\n    \n    # Prepare results for printing\n    results_list = observed_orders + [b_A, b_B]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results_list))}]\")\n\nsolve()\n```", "id": "2393512"}]}