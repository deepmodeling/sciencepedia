{"hands_on_practices": [{"introduction": "The journey into solving elliptic partial differential equations often begins with the canonical problem of finding the electrostatic potential in a charge-free region. This first practice provides a direct, hands-on opportunity to implement the Jacobi relaxation method for the three-dimensional Laplace equation, $\\nabla^2 V = 0$. By discretizing a cubic domain and iteratively applying the discrete harmonic averaging rule, you will build a foundational solver and observe how the potential field relaxes towards its equilibrium state under given boundary conditions.", "problem": "Consider the electrostatic potential inside a hollow, perfectly conducting cube occupying the domain $[0,1]^3$ in Cartesian coordinates. The potential $V(x,y,z)$ satisfies the three-dimensional Laplace equation, that is, the Partial Differential Equation (PDE) $\\nabla^2 V = 0$ in the open unit cube, with Dirichlet Boundary Conditions (BC). Exactly one face of the cube is held at a fixed potential $V_0$ (in volts), and the other five faces are held at $0$ volts (grounded). The specific face at potential $V_0$ is identified by an axis label $a \\in \\{x,y,z\\}$ and is always the “positive” face, i.e., the plane $x=1$ if $a=x$, the plane $y=1$ if $a=y$, or the plane $z=1$ if $a=z$.\n\nDiscretize the unit cube on a uniform grid with $N$ interior points in each coordinate direction, so the total number of grid points per axis is $N+2$ including the boundaries, and the grid spacing is $h = \\frac{1}{N+1}$. Let $U_{i,j,k}$ denote the discrete potential at the grid point $(x_i,y_j,z_k) = (i\\,h,j\\,h,k\\,h)$ for integer indices $i,j,k \\in \\{0,1,\\dots,N+1\\}$. Impose $U_{i,j,k}=0$ on all boundary points except those on the single face specified by $a$ at the “positive” side, where $U_{i,j,k}=V_0$.\n\nDefine a sequence $\\{U^{(m)}\\}_{m=0}^{\\infty}$ of grid functions on this mesh by the following rules:\n- Initialize the interior values by $U^{(0)}_{i,j,k}=0$ for all $1 \\le i,j,k \\le N$, while all boundary values are set by the Dirichlet BC described above and held fixed for all $m$.\n- For each integer $m \\ge 0$, define the next iterate on interior points by the discrete harmonic averaging relation\n$$\nU^{(m+1)}_{i,j,k} = \\frac{1}{6}\\Big(U^{(m)}_{i+1,j,k} + U^{(m)}_{i-1,j,k} + U^{(m)}_{i,j+1,k} + U^{(m)}_{i,j-1,k} + U^{(m)}_{i,j,k+1} + U^{(m)}_{i,j,k-1}\\Big)\n$$\nfor all $1 \\le i,j,k \\le N$, while preserving the boundary values unchanged at every iteration.\n- For a given tolerance $\\varepsilon > 0$, define the stopping time $K$ to be the smallest nonnegative integer such that after performing $K$ complete sweeps (each sweep updates all interior points once via the averaging rule above), the following holds:\n$$\n\\max_{0 \\le i,j,k \\le N+1} \\left| U^{(K)}_{i,j,k} - U^{(K-1)}_{i,j,k} \\right| < \\varepsilon,\n$$\nwith the convention that $U^{(-1)}$ is not used (so the first time the strict inequality can be evaluated is after one sweep, i.e., for $K \\ge 1$). Report $K$ as the number of sweeps executed up to and including the first sweep for which the strict inequality is satisfied.\n\nFor each case, also report the value (in volts) of the discrete potential at the single grid node nearest to the geometric center $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$. Let $n = N+2$ be the total number of grid points per axis; then the nearest center index in each direction is $c = \\operatorname{round}\\!\\big(\\tfrac{1}{2}(n-1)\\big)$, and the reported central value is $U^{(K)}_{c,c,c}$ in volts.\n\nTest Suite:\nProvide results for the following parameter sets $(N,\\varepsilon,V_0,a)$:\n- Case A (general instance): $(N,\\varepsilon,V_0,a) = (10,\\,10^{-3},\\,1,\\,z)$.\n- Case B (minimal interior, exact discrete fixed-point in two sweeps): $(N,\\varepsilon,V_0,a) = (1,\\,10^{-12},\\,1,\\,x)$.\n- Case C (degenerate boundary data): $(N,\\varepsilon,V_0,a) = (6,\\,5\\times 10^{-3},\\,0,\\,y)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[K, U^{(K)}_{c,c,c}]$. For example, the output format must be\n\"[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]\"\nwith $K_A$, $K_B$, $K_C$ integers and $V_A$, $V_B$, $V_C$ floats representing volts. All potentials must be expressed in volts. Angles are not involved. No percentages appear in the output; all quantities are raw integers or floats.", "solution": "The problem requires the numerical solution of the three-dimensional Laplace equation, $\\nabla^2 V = 0$, within a unit cube, subject to Dirichlet boundary conditions. The potential $V$ is specified on all six faces of the cube: one face is held at a constant potential $V_0$, while the other five are grounded (potential $0$). This is a standard problem in electrostatics, describing the potential in a charge-free region.\n\nThe continuous problem is discretized on a uniform Cartesian grid. The domain $[0,1]^3$ is divided into a grid with $N+2$ points along each axis, resulting in a grid spacing of $h = \\frac{1}{N+1}$. The discrete potential at a grid point $(x_i, y_j, z_k) = (ih, jh, kh)$ is denoted by $U_{i,j,k}$, for indices $i,j,k \\in \\{0, 1, \\dots, N+1\\}$.\n\nThe Laplace operator $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}$ is approximated at each interior grid point $(i,j,k)$ using a second-order central difference scheme:\n$$\n\\nabla^2 V \\bigg|_{(x_i,y_j,z_k)} \\approx \\frac{U_{i+1,j,k} - 2U_{i,j,k} + U_{i-1,j,k}}{h^2} + \\frac{U_{i,j+1,k} - 2U_{i,j,k} + U_{i,j-1,k}}{h^2} + \\frac{U_{i,j,k+1} - 2U_{i,j,k} + U_{i,j,k-1}}{h^2}\n$$\nSetting this approximation to $0$ yields a system of linear equations for the unknown interior potentials. Rearranging the terms for $U_{i,j,k}$ gives the discrete harmonic mean property:\n$$\nU_{i,j,k} = \\frac{1}{6}\\Big(U_{i+1,j,k} + U_{i-1,j,k} + U_{i,j+1,k} + U_{i,j-1,k} + U_{i,j,k+1} + U_{i,j,k-1}\\Big)\n$$\nThis equation must hold for all interior points, i.e., for $1 \\le i,j,k \\le N$.\n\nThe problem specifies the Jacobi method for solving this linear system. This is an iterative relaxation technique. Given an initial guess for the potential on the interior grid, $U^{(0)}$, a sequence of refined approximations $\\{U^{(m)}\\}_{m=0}^{\\infty}$ is generated. The update from iteration $m$ to $m+1$ is defined by applying the discrete harmonic mean rule simultaneously to all interior points, using only the values from the previous iteration $m$:\n$$\nU^{(m+1)}_{i,j,k} = \\frac{1}{6}\\Big(U^{(m)}_{i+1,j,k} + U^{(m)}_{i-1,j,k} + U^{(m)}_{i,j+1,k} + U^{(m)}_{i,j-1,k} + U^{(m)}_{i,j,k+1} + U^{(m)}_{i,j,k-1}\\Big)\n$$\nThe boundary values are held constant throughout the process. The initial guess for all interior points is specified as $U^{(0)}_{i,j,k}=0$.\n\nThe iteration continues until the solution converges. Convergence is determined by a stopping criterion based on the maximum change in potential values between successive iterations. The process terminates at the first iteration $K \\ge 1$ for which the maximum absolute difference over the entire grid falls below a given tolerance $\\varepsilon$:\n$$\n\\max_{0 \\le i,j,k \\le N+1} \\left| U^{(K)}_{i,j,k} - U^{(K-1)}_{i,j,k} \\right| < \\varepsilon\n$$\nThe number of iterations $K$ and the final potential at the grid point closest to the geometric center of the cube, $U^{(K)}_{c,c,c}$, are reported. The center index $c$ is calculated as $c = \\operatorname{round}\\!\\big(\\frac{1}{2}((N+2)-1)\\big)$.\n\nThe implementation proceeds as follows:\n1.  Two three-dimensional arrays, `U` and `U_next`, of size $(N+2) \\times (N+2) \\times (N+2)$, are initialized to represent the potential at the current and next iteration steps, respectively.\n2.  The Dirichlet boundary conditions are imposed on both arrays. For a given axis $a$ and potential $V_0$, the face at the positive end of that axis ($x=1$, $y=1$, or $z=1$) is set to $V_0$. The remaining boundary faces and the initial interior points are set to $0$.\n3.  An iterative loop is executed. In each iteration $m$, `U_next` (representing $U^{(m)}$) is computed from `U` (representing $U^{(m-1)}$) using a vectorized version of the Jacobi update rule for all interior points.\n4.  The maximum absolute difference between `U_next` and `U` is calculated.\n5.  The values from `U_next` are copied to `U` to prepare for the subsequent iteration.\n6.  The loop terminates when the maximum difference is less than $\\varepsilon$. The final iteration count $K$ is the number of sweeps performed.\n7.  The final potential at the center index $(c,c,c)$ is extracted from the converged grid `U`.\n\nThe test cases are:\n- Case A: $(N,\\varepsilon,V_0,a) = (10, 10^{-3}, 1, z)$ is a standard case with a reasonably fine grid.\n- Case B: $(N,\\varepsilon,V_0,a) = (1, 10^{-12}, 1, x)$ represents a minimal problem with only one interior grid point. The Jacobi iteration converges to the exact discrete solution in $K=2$ steps, as the second update produces no change.\n- Case C: $(N,\\varepsilon,V_0,a) = (6, 5 \\times 10^{-3}, 0, y)$ is a degenerate case where $V_0=0$. All boundary potentials are $0$, and the initial interior potential is also $0$. The unique solution is $U=0$ everywhere. The algorithm converges in a single step ($K=1$) because the initial state is already the fixed point, so the difference after the first iteration is zero.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef solve_case(N, epsilon, V0, a):\n    \"\"\"\n    Solves the 3D Laplace equation on a unit cube using Jacobi relaxation.\n\n    Args:\n        N (int): Number of interior points in each dimension.\n        epsilon (float): Convergence tolerance.\n        V0 (float): Potential on the high-potential face.\n        a (str): Axis ('x', 'y', or 'z') of the high-potential face.\n\n    Returns:\n        list: A list containing [K, central_potential], where K is the number\n              of iterations and central_potential is the potential at the\n              grid point nearest the center.\n    \"\"\"\n    n = N + 2  # Total number of grid points per axis including boundaries\n\n    # Initialize U for iteration m and U_next for iteration m+1.\n    # Start with U^(0) = 0 everywhere.\n    U = np.zeros((n, n, n), dtype=np.float64)\n\n    # Apply Dirichlet boundary conditions.\n    # All faces are at 0V (grounded) by default.\n    # We only need to set the face at V0.\n    if V0 != 0:\n        if a == 'x':\n            U[N + 1, :, :] = V0\n        elif a == 'y':\n            U[:, N + 1, :] = V0\n        elif a == 'z':\n            U[:, :, N + 1] = V0\n            \n    # U_next must also have the boundary conditions.\n    U_next = U.copy()\n\n    K = 0\n    while True:\n        K += 1\n\n        # Perform one sweep of Jacobi relaxation.\n        # Update interior points of U_next based on values in U.\n        # This is the vectorized form of the 7-point stencil update.\n        U_next[1:-1, 1:-1, 1:-1] = (\n            U[0:-2, 1:-1, 1:-1] + U[2:, 1:-1, 1:-1] +\n            U[1:-1, 0:-2, 1:-1] + U[1:-1, 2:, 1:-1] +\n            U[1:-1, 1:-1, 0:-2] + U[1:-1, 1:-1, 2:]\n        ) / 6.0\n\n        # Calculate the maximum absolute difference between the new and old grids.\n        # The maximum is taken over all points, including boundaries.\n        max_diff = np.max(np.abs(U_next - U))\n\n        # Prepare for the next iteration by copying U_next to U.\n        U = U_next.copy()\n\n        # Check for convergence.\n        if max_diff  epsilon:\n            break\n            \n    # Find the index of the grid point nearest to the geometric center.\n    c = int(round(0.5 * (n - 1)))\n    \n    central_potential = U[c, c, c]\n    \n    return [K, central_potential]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, V0, a)\n        (10, 1e-3, 1.0, 'z'),      # Case A\n        (1, 1e-12, 1.0, 'x'),      # Case B\n        (6, 5e-3, 0.0, 'y'),      # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, epsilon, V0, a = case\n        result = solve_case(N, epsilon, V0, a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes a space after the comma,\n    # which matches the format example '[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]'.\n    # The provided template code produces this format correctly.\n    inner_parts = []\n    for pair in results:\n        # Manually format each inner list to avoid locale-specific representations\n        # and ensure consistency with the problem's example format '[K, V]'.\n        inner_parts.append(f\"[{pair[0]}, {pair[1]}]\")\n    \n    # The example format shows spaces between elements: \"[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]\"\n    final_output_string = f\"[{', '.join(inner_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2404972"}, {"introduction": "Having established a basic solver, we now explore how a local constraint influences the global solution of a Laplace problem. This exercise modifies the standard setup by introducing a single fixed-voltage point within the interior of the domain, akin to placing a charged probe inside a grounded box. By comparing the solution with and without this internal constraint, you will gain a tangible understanding of how elliptic equations propagate information globally and learn to quantify the resulting perturbation across the entire field.", "problem": "You are given the two-dimensional Laplace equation on a square domain with uniform Cartesian discretization and Dirichlet boundary conditions. Consider a square domain of side length $1$ meter, discretized into a uniform grid of $N \\times N$ nodes with grid spacing $h = \\dfrac{1}{N-1}$ meters. Let the grid indices be zero-based, with $i \\in \\{0,\\dots,N-1\\}$ indexing the vertical coordinate (bottom to top) and $j \\in \\{0,\\dots,N-1\\}$ indexing the horizontal coordinate (left to right). The discrete Laplace equation at each strictly interior node $(i,j)$ (i.e., $1 \\le i \\le N-2$ and $1 \\le j \\le N-2$) is\n$$\n\\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2} = 0,\n$$\nwhich is equivalent to \n$$\n\\phi_{i,j} = \\frac{1}{4}\\left(\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1}\\right).\n$$\nOn the boundary, Dirichlet values are prescribed on each edge: bottom edge $i=0$, top edge $i=N-1$, left edge $j=0$, and right edge $j=N-1$. At the four corner nodes, where two edge specifications meet, the boundary value is defined to be the arithmetic mean of the values prescribed on the two incident edges. All electric potentials must be treated and reported in volts.\n\nThe task is to study the effect of introducing a single interior Dirichlet constraint (an \"internal\" fixed-voltage point) on the global discrete solution. For a given set of boundary edge values and a specified interior node $(i^\\star,j^\\star)$ with a fixed interior voltage $V^\\star$, define two discrete solutions:\n- $\\phi^{(0)}$: the unique discrete harmonic function satisfying the boundary Dirichlet conditions on the edges with no interior constraints;\n- $\\phi^{(\\mathrm{int})}$: the unique discrete harmonic function satisfying the same boundary Dirichlet conditions on the edges together with the interior Dirichlet constraint $\\phi_{i^\\star,j^\\star} = V^\\star$.\n\nFor each case, compute the root-mean-square (RMS) difference between these two solutions over the whole grid,\n$$\nD = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\phi^{(\\mathrm{int})}_{i,j} - \\phi^{(0)}_{i,j}\\right)^2},\n$$\nexpressed in volts.\n\nA discrete solution is considered acceptable if the uniform maximum absolute change between successive iterates across all grid nodes is strictly less than a specified tolerance $\\varepsilon$ in volts, or a specified maximum number of iterations is reached. Use the tolerance $\\varepsilon = 10^{-6}$ volts, and use a maximum iteration count of $200{,}000$.\n\nTest suite. For each test, you must compute $D$ as defined above. The three tests below specify $N$, the boundary voltages on each edge, and the interior point and its fixed voltage. Use zero-based indexing for $(i^\\star,j^\\star)$.\n- Test $1$ (general case):\n  - $N = 41$.\n  - Edge voltages: top edge $1.0$ volts, bottom edge $0.0$ volts, left edge $0.0$ volts, right edge $0.0$ volts.\n  - Interior constraint: $(i^\\star,j^\\star) = (20,20)$ with $V^\\star = 0.75$ volts.\n- Test $2$ (interior point near an edge):\n  - $N = 21$.\n  - Edge voltages: left edge $1.0$ volts, top edge $0.0$ volts, bottom edge $0.0$ volts, right edge $0.0$ volts.\n  - Interior constraint: $(i^\\star,j^\\star) = (10,2)$ with $V^\\star = 0.20$ volts.\n- Test $3$ (zero boundary, interior source only):\n  - $N = 11$.\n  - Edge voltages: top edge $0.0$ volts, bottom edge $0.0$ volts, left edge $0.0$ volts, right edge $0.0$ volts.\n  - Interior constraint: $(i^\\star,j^\\star) = (5,5)$ with $V^\\star = 1.00$ volts.\n\nYour program must, for each test, compute $\\phi^{(0)}$ and $\\phi^{(\\mathrm{int})}$ that satisfy the discrete equations to within the specified tolerance, then compute the RMS difference $D$ in volts. The final program output must be a single line containing a list of the three values of $D$ for Tests $1$ through $3$, in that order, rounded to $6$ decimal places, and formatted exactly as a comma-separated list with no spaces enclosed in square brackets (for example, \"[0.123456,0.000001,1.234567]\").", "solution": "The posed problem is valid. It is a standard exercise in computational physics, concerning the solution of the two-dimensional Laplace equation using a finite-difference scheme on a Cartesian grid. The method of choice is Jacobi relaxation, a classic iterative technique for solving systems of linear equations that arise from such discretizations. The problem is well-defined, scientifically sound, and all parameters are provided for its unambiguous solution.\n\nThe governing equation is the Laplace equation, $\\nabla^2 \\phi = 0$. For a two-dimensional domain with a uniform Cartesian grid of spacing $h$, a second-order central difference approximation to the Laplacian operator $\\nabla^2$ at a node $(i,j)$ yields the discrete equation:\n$$\n\\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2} = 0\n$$\nThis can be rearranged to express the potential $\\phi_{i,j}$ as the average of its four nearest neighbors, which forms the basis of the Jacobi iterative update rule:\n$$\n\\phi_{i,j}^{(k+1)} = \\frac{1}{4}\\left(\\phi_{i+1,j}^{(k)} + \\phi_{i-1,j}^{(k)} + \\phi_{i,j+1}^{(k)} + \\phi_{i,j-1}^{(k)}\\right)\n$$\nwhere the superscript $(k)$ denotes the iteration number. This update is applied simultaneously to all strictly interior nodes of the grid, meaning for indices $i,j$ in the range $[1, N-2]$.\n\nThe overall algorithm to address the problem for each test case is as follows:\n\n1.  **Grid Initialization**: For a given grid size $N \\times N$, an array representing the potential $\\phi$ is created. The boundary values are set according to the problem specification. The potential at the four corner nodes is set to the arithmetic mean of the potentials of the two intersecting edges. For instance, the potential at the bottom-left corner $(i=0, j=0)$ is set to $\\phi_{0,0} = \\frac{1}{2}(V_{\\text{bottom}} + V_{\\text{left}})$, where $V_{\\text{bottom}}$ and $V_{\\text{left}}$ are the voltages on the respective edges.\n\n2.  **Solving for $\\phi^{(0)}$ (Unconstrained Solution)**:\n    - Starting with the initialized grid, the Jacobi iteration is applied. In each iteration, a new grid of potential values is computed where each interior point's value is the average of its neighbors from the previous iteration's grid.\n    - This process is repeated until the convergence criterion is met. Convergence is achieved when the maximum absolute difference in potential at any node between two successive iterations, $\\max(|\\phi^{(k+1)} - \\phi^{(k)}|)$, is less than the specified tolerance $\\varepsilon = 10^{-6}$ volts. The iteration also terminates if the maximum number of iterations, $200,000$, is reached.\n    - The resulting grid is the discrete solution $\\phi^{(0)}$.\n\n3.  **Solving for $\\phi^{(\\mathrm{int})}$ (Constrained Solution)**:\n    - The procedure is nearly identical to that for $\\phi^{(0)}$, with one crucial modification. An interior Dirichlet constraint is introduced at a specific node $(i^\\star, j^\\star)$, fixing its potential to $V^\\star$.\n    - The Jacobi iteration is performed on all interior nodes. After the update step, the value at the constrained node is reset to its fixed value, $\\phi_{i^\\star, j^\\star} = V^\\star$. This enforces the interior constraint throughout the iterative process.\n    - The same convergence criteria are applied. The resulting grid is the discrete solution $\\phi^{(\\mathrm{int})}$.\n\n4.  **Calculating the RMS Difference**: Once both $\\phi^{(0)}$ and $\\phi^{(\\mathrm{int})}$ have been computed, the root-mean-square (RMS) difference $D$ between them is calculated over the entire $N \\times N$ grid using the provided formula:\n    $$\n    D = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\phi^{(\\mathrm{int})}_{i,j} - \\phi^{(0)}_{i,j}\\right)^2}\n    $$\n    This metric quantifies the average global perturbation to the potential field caused by the introduction of the single interior fixed-voltage point.\n\nThe implementation will be carried out in Python using the NumPy library, which allows for efficient, vectorized operations on the grid. A single function encapsulates the Jacobi solver, capable of handling both the unconstrained and constrained cases. This function is called for each scenario ($\\phi^{(0)}$ and $\\phi^{(\\mathrm{int})}$) for each of the three test cases to compute the required solutions. The final list of $D$ values is then formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right,\n                  interior_constraint=None, tol=1e-6, max_iter=200000):\n    \"\"\"\n    Solves the 2D Laplace equation on a square grid using Jacobi relaxation.\n\n    Args:\n        N (int): The number of nodes along one dimension of the grid.\n        bc_top (float): Voltage on the top edge.\n        bc_bottom (float): Voltage on the bottom edge.\n        bc_left (float): Voltage on the left edge.\n        bc_right (float): Voltage on the right edge.\n        interior_constraint (tuple, optional): A tuple (i, j, V) specifying an\n            interior fixed-voltage point. Defaults to None.\n        tol (float, optional): Convergence tolerance. Defaults to 1e-6.\n        max_iter (int, optional): Maximum number of iterations. Defaults to 200000.\n\n    Returns:\n        numpy.ndarray: The converged potential field phi.\n    \"\"\"\n    phi = np.zeros((N, N), dtype=np.float64)\n\n    # Apply boundary conditions to edges\n    phi[N-1, :] = bc_top      # Top edge (i = N-1)\n    phi[0, :] = bc_bottom     # Bottom edge (i = 0)\n    phi[:, 0] = bc_left       # Left edge (j = 0)\n    phi[:, N-1] = bc_right    # Right edge (j = N-1)\n\n    # Apply boundary conditions to corners (arithmetic mean)\n    phi[0, 0] = (bc_bottom + bc_left) / 2.0\n    phi[0, N-1] = (bc_bottom + bc_right) / 2.0\n    phi[N-1, 0] = (bc_top + bc_left) / 2.0\n    phi[N-1, N-1] = (bc_top + bc_right) / 2.0\n\n    # If an interior constraint exists, retrieve its details\n    if interior_constraint:\n        i_star, j_star, v_star = interior_constraint\n        phi[i_star, j_star] = v_star\n\n    for _ in range(max_iter):\n        phi_old = phi.copy()\n\n        # Vectorized Jacobi update for all interior points\n        phi[1:-1, 1:-1] = 0.25 * (\n            phi_old[2:, 1:-1] +   # phi_{i+1, j}\n            phi_old[:-2, 1:-1] +  # phi_{i-1, j}\n            phi_old[1:-1, 2:] +   # phi_{i, j+1}\n            phi_old[1:-1, :-2]    # phi_{i, j-1}\n        )\n\n        # Re-enforce the interior constraint after the update\n        if interior_constraint:\n            phi[i_star, j_star] = v_star\n\n        # Check for convergence across the whole grid\n        max_change = np.max(np.abs(phi - phi_old))\n        if max_change  tol:\n            break\n\n    return phi\n\ndef calculate_rms_difference(case_params):\n    \"\"\"\n    Calculates the RMS difference D for a given test case.\n    \n    Args:\n        case_params (tuple): Contains N, boundary conditions, and interior constraint.\n    \n    Returns:\n        float: The computed RMS difference D.\n    \"\"\"\n    N, bcs, int_constr = case_params\n    bc_top, bc_bottom, bc_left, bc_right = bcs\n\n    # Solve for phi^(0) (unconstrained)\n    phi_0 = jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right)\n    \n    # Solve for phi^(int) (with interior constraint)\n    phi_int = jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right, \n                            interior_constraint=int_constr)\n    \n    # Calculate the RMS difference D\n    rms_diff = np.sqrt(np.mean((phi_int - phi_0)**2))\n    \n    return rms_diff\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: N=41, top=1V, others=0V, constraint=(20,20) at 0.75V\n        (41, (1.0, 0.0, 0.0, 0.0), (20, 20, 0.75)),\n        # Test 2: N=21, left=1V, others=0V, constraint=(10,2) at 0.20V\n        (21, (0.0, 0.0, 1.0, 0.0), (10, 2, 0.20)),\n        # Test 3: N=11, all=0V, constraint=(5,5) at 1.00V\n        (11, (0.0, 0.0, 0.0, 0.0), (5, 5, 1.00)),\n    ]\n\n    results = []\n    for case in test_cases:\n        D = calculate_rms_difference(case)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    formatted_results = ','.join([f\"{res:.6f}\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2405011"}, {"introduction": "Our exploration now advances from the source-free Laplace equation to the more general Poisson equation, $\\nabla^2 u = f$, which models systems with charge or source distributions. This practice challenges you to contrast two fundamentally different physical scenarios by implementing the solver for both homogeneous Dirichlet and periodic boundary conditions. This exercise will not only test your ability to adapt the Jacobi algorithm but also deepen your understanding of the profound impact boundary conditions have on the solution's structure and the unique solvability requirements of periodic systems.", "problem": "Consider the two-dimensional Poisson partial differential equation (PDE) $$\\nabla^2 u(x,y) = f(x,y)$$ on the unit square domain $$\\Omega = [0,1]\\times[0,1]$$, where all angles in trigonometric functions are in radians. You will implement the Jacobi relaxation method to solve finite-difference discretizations of this equation under two different boundary models and then quantify how the choice of boundary model affects the solution structure. The two boundary models are: (i) periodic boundary conditions on the torus (opposite edges identified), and (ii) homogeneous Dirichlet boundary conditions on the square (zero value at the boundary). For the periodic model, recall that solvability requires a zero-mean right-hand side.\n\nYour implementation must start from the following fundamental base:\n- The definition of the Poisson equation $$\\nabla^2 u = f$$ as the divergence of the gradient, and its finite-difference discretization using second-order centered differences on a uniform grid with spacing $$h$$ in each coordinate.\n- The Jacobi relaxation scheme as a fixed-point iteration obtained by isolating the central point of the five-point stencil.\n- The solvability condition for the periodic Poisson problem obtained by integrating $$\\nabla^2 u = f$$ over the domain and using the divergence theorem and periodicity.\n\nFrom these bases, derive the update rules for Jacobi relaxation on a uniform grid for each boundary model:\n- Periodic boundary conditions: every grid point has four neighbors with wrap-around indexing; the discrete Laplacian uses periodic shifts.\n- Homogeneous Dirichlet boundary conditions: the solution is held fixed at $$0$$ on the boundary; only the interior unknowns are updated using their neighbors and the boundary values.\n\nUse a uniform grid with $$N_x=N_y$$ points per dimension. For the periodic model, place the grid on the flat torus with points $$x_i = i/N_x$$ and $$y_j = j/N_y$$ for $$i,j \\in \\{0,1,\\dots,N_x-1\\}$$, with spacing $$h_p = 1/N_x$$. For the Dirichlet model, use points $$x_i = i/(N_x-1)$$ and $$y_j = j/(N_y-1)$$ for $$i,j \\in \\{0,1,\\dots,N_x-1\\}$$, with spacing $$h_d = 1/(N_x-1)$$, and enforce $$u=0$$ on the boundary indices $$i=0$$, $$i=N_x-1$$, $$j=0$$, $$j=N_y-1$$.\n\nImplement the Jacobi scheme with a zero initial guess and a stopping criterion based on the relative discrete $$L^2$$-norm of the residual. Let the residual be $$r = f - \\Delta_h u$$, where $$\\Delta_h$$ denotes the standard five-point discrete Laplacian with the appropriate boundary treatment. Define the relative residual as $$\\|r\\|_2 / \\|f\\|_2$$, where $$\\|g\\|_2 = \\left(\\sum_{i,j} g_{i,j}^2 \\, h^2\\right)^{1/2}$$ uses the appropriate grid spacing $$h\\in\\{h_p,h_d\\}$$. Stop when the relative residual is below a specified tolerance or when a maximum number of iterations is reached. For the periodic model, if the discrete mean of $$f$$, i.e., $$\\bar f = \\frac{1}{N_x N_y} \\sum_{i,j} f_{i,j}$$, is nonzero in magnitude above a small threshold, the discrete problem is not solvable; in that case, report that the periodic solver does not converge (do not attempt to “fix” $$f$$ by subtracting its mean).\n\nTest suite and required outputs:\n- Test case $$1$$ (periodic, analytic mode with zero mean): Use $$N_x=N_y=64$$ and $$f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$$. Solve with periodic boundary conditions up to a relative residual tolerance of $$10^{-8}$$ or a maximum of $$6000$$ Jacobi iterations, whichever occurs first. Compare the numerical solution against the discrete Fourier-mode solution of the periodic five-point Laplacian for this mode. Specifically, for the grid function $$f_{i,j} = \\sin(2\\pi x_i)\\sin(2\\pi y_j)$$, the corresponding discrete solution that exactly satisfies $$\\Delta_h u = f$$ is $$u^\\star = -f/\\lambda_d$$ with $$\\lambda_d = \\frac{8}{h_p^2}\\sin^2\\!\\left(\\frac{\\pi}{N_x}\\right)$$. Report the relative $$L^2$$ error $$\\|u-u^\\star\\|_2/\\|u^\\star\\|_2$$ as a floating-point number.\n- Test case $$2$$ (periodic, non-solvable forcing): Use $$N_x=N_y=64$$ and $$f(x,y) \\equiv 1$$ (the constant grid function of value $$1$$). Attempt to solve with periodic boundary conditions under the same tolerance and iteration cap. Detect the nonzero mean of $$f$$ and report a boolean indicating whether the solver correctly refuses to converge because the discrete problem is not solvable. The expected output for this case is the boolean value $$\\mathrm{False}$$ to indicate non-convergence due to the violated solvability condition.\n- Test case $$3$$ (periodic versus Dirichlet structural effect): Use the pair of problems defined by $$f(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$$ with the same tolerance and iteration cap. Solve once with periodic boundary conditions on a $$64\\times 64$$ torus grid (spacing $$h_p=1/64$$) and once with homogeneous Dirichlet boundary conditions on a $$65\\times 65$$ square grid (spacing $$h_d=1/64$$). Compute the continuous $$L^2$$ norms of both numerical solutions, $$\\|u_{\\mathrm{per}}\\|_2$$ and $$\\|u_{\\mathrm{dir}}\\|_2$$, using their respective spacings. Report the floating-point ratio $$R = \\|u_{\\mathrm{per}}\\|_2 / \\|u_{\\mathrm{dir}}\\|_2$$.\n\nAngle unit specification: all trigonometric functions must use radians.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the three test cases described above. That is, the output must be of the form $$[e_1,b_2,R_3]$$, where $$e_1$$ is the floating-point relative error for test case $$1$$, $$b_2$$ is the boolean for test case $$2$$, and $$R_3$$ is the floating-point ratio for test case $$3$$. For example, $$[0.00012,False,1.73]$$.", "solution": "The problem as stated is valid. It constitutes a well-posed exercise in the field of computational physics, requiring the implementation and analysis of the Jacobi relaxation method for the two-dimensional Poisson equation. The problem is scientifically grounded, free of contradictions, and provides all necessary data and conditions for a unique and meaningful solution to be computed for each test case. We proceed with the derivation and solution.\n\nThe governing partial differential equation is the Poisson equation on a two-dimensional domain $\\Omega = [0,1]\\times[0,1]$:\n$$ \\nabla^2 u(x,y) = f(x,y) $$\nwhere $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ is the Laplace operator. To solve this equation numerically, we discretize the domain $\\Omega$ into a uniform grid of points $(x_i, y_j)$ with equal spacing $h$ in both coordinate directions. The function $u(x,y)$ is represented by its values on this grid, $u_{i,j} = u(x_i, y_j)$.\n\nThe second-order partial derivatives are approximated using second-order centered finite differences:\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\nSubstituting these approximations into the Poisson equation yields the discrete five-point stencil representation of the Laplacian, denoted $\\Delta_h$:\n$$ (\\Delta_h u)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} = f_{i,j} $$\nThis equation forms a large system of linear algebraic equations for the unknown grid values $u_{i,j}$.\n\nThe Jacobi relaxation method is an iterative scheme for solving this system. It is derived by rearranging the discrete equation to isolate the central point $u_{i,j}$:\n$$ 4u_{i,j} = u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - h^2 f_{i,j} $$\n$$ u_{i,j} = \\frac{1}{4} (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - h^2 f_{i,j}) $$\nThis algebraic identity is transformed into a fixed-point iteration by evaluating the right-hand side using values from the previous iteration, indexed by $k$, to compute the value for the next iteration, $k+1$:\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(k)} + u_{i-1,j}^{(k)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k)} - h^2 f_{i,j} \\right) $$\nStarting with an initial guess $u^{(0)}$, this formula is applied repeatedly to all grid points until the solution converges. The handling of the neighbor points $(u_{i\\pm 1, j}, u_{i, j\\pm 1})$ depends on the boundary conditions.\n\nFor periodic boundary conditions, the grid represents a torus. The domain $\\Omega$ is considered to have its opposite edges identified. A grid of $N_x \\times N_y$ points is used, where $x_i = i/N_x$ and $y_j = j/N_y$ for $i \\in \\{0, \\dots, N_x-1\\}$ and $j \\in \\{0, \\dots, N_y-1\\}$. The grid spacing is $h_p = 1/N_x$. The indices are treated modulo $N_x$ and $N_y$, so for a point $(i,j)$, its neighbors are $((i\\pm 1) \\pmod{N_x}, j)$ and $(i, (j\\pm 1) \\pmod{N_y})$. A crucial solvability condition arises from integrating the PDE over the domain: $\\int_\\Omega \\nabla^2 u \\, dA = \\int_\\Omega f \\, dA$. The divergence theorem transforms the left side into a boundary integral, $\\oint_{\\partial\\Omega} \\nabla u \\cdot \\mathbf{n} \\, dS$, which is zero for periodic functions. Thus, we must have $\\int_\\Omega f \\, dA = 0$. The discrete analog is $\\sum_{i,j} f_{i,j} = 0$. If the mean of the forcing function $f$ is non-zero, a solution does not exist, and the Jacobi iteration will not converge.\n\nFor homogeneous Dirichlet boundary conditions, the solution is fixed to zero on the boundary of the square domain: $u(x,y)=0$ for $(x,y) \\in \\partial\\Omega$. A grid of $N_x \\times N_y$ points is used, with $x_i = i/(N_x-1)$ and $y_j = j/(N_y-1)$ for $i,j \\in \\{0, \\dots, N_x-1\\}$. The grid spacing is $h_d = 1/(N_x-1)$. The boundary points are those with indices $i=0$, $i=N_x-1$, $j=0$, or $j=N_y-1$. The Jacobi update is applied only to the interior grid points, where $i,j \\in \\{1, \\dots, N_x-2\\}$. For interior points adjacent to the boundary, the update formula simply uses the known zero values from the boundary.\n\nThe algorithm proceeds as follows:\n1. Initialize the solution grid, $u^{(0)}_{i,j} = 0$.\n2. For each iteration $k=0, 1, 2, \\dots$ up to a maximum:\n   a. Compute the next iterate $u^{(k+1)}$ from $u^{(k)}$ using the Jacobi update rule appropriate for the boundary conditions.\n   b. Compute the discrete residual grid $r^{(k+1)} = f - \\Delta_h u^{(k+1)}$. The discrete Laplacian operator $\\Delta_h$ must also respect the boundary conditions.\n   c. Calculate the discrete relative $L^2$-norm of the residual: $\\frac{\\|r^{(k+1)}\\|_2}{\\|f\\|_2}$, where the norm is defined as $\\|g\\|_2 = \\sqrt{\\sum_{i,j} g_{i,j}^2 h^2}$.\n   d. If the relative residual is below a specified tolerance $\\epsilon$, the iteration has converged and is terminated.\n3. For the periodic case, a preliminary check for the solvability condition $\\left| \\sum_{i,j} f_{i,j} \\right|  \\delta$ for some small numerical tolerance $\\delta$ must be performed. If this condition is violated, the solver must report non-convergence.\n\nThis procedure is applied to the three specified test cases.\n\nCase $1$: Periodic problem with $N_x=N_y=64$ and $f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$. This forcing function has zero mean, so a solution exists. The numerical solution $u$ is compared to the exact discrete solution $u^\\star = -f/\\lambda_d$ where $\\lambda_d = \\frac{8}{h_p^2}\\sin^2(\\frac{\\pi}{N_x})$ is the exact eigenvalue of the discrete Laplacian for this mode. The relative error $\\|u-u^\\star\\|_2/\\|u^\\star\\|_2$ is computed.\n\nCase $2$: Periodic problem with $N_x=N_y=64$ and $f(x,y)=1$. The discrete mean of $f$ is $1$, which violates the solvability condition. The solver is expected to detect this and not converge. The required output is `False`.\n\nCase $3$: Comparison of periodic and Dirichlet solutions for $f(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$. The grid spacing is held constant at $h=1/64$. For the periodic case, this requires a $64 \\times 64$ grid. For the Dirichlet case, this requires a $65 \\times 65$ grid. The ratio of the $L^2$-norms of the resulting solutions, $R = \\|u_{\\mathrm{per}}\\|_2 / \\|u_{\\mathrm{dir}}\\|_2$, is computed to quantify the structural difference imposed by the boundary conditions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def get_l2_norm(grid, h):\n        \"\"\"Calculates the discrete L2 norm: sqrt(sum(g_ij^2 * h^2)).\"\"\"\n        # Note: np.linalg.norm computes the Frobenius norm sqrt(sum(g_ij^2)).\n        return h * np.linalg.norm(grid)\n\n    def apply_laplacian(u, h, bc_type):\n        \"\"\"Applies the 5-point discrete Laplacian to a grid u.\"\"\"\n        if bc_type == 'periodic':\n            # Use np.roll for efficient periodic boundary handling.\n            u_i_plus = np.roll(u, -1, axis=1)\n            u_i_minus = np.roll(u, 1, axis=1)\n            u_j_plus = np.roll(u, -1, axis=0)\n            u_j_minus = np.roll(u, 1, axis=0)\n            lap_u = (u_i_plus + u_i_minus + u_j_plus + u_j_minus - 4.0 * u) / (h**2)\n        elif bc_type == 'dirichlet':\n            # Create a zero-padded laplacian grid and fill the interior.\n            lap_u = np.zeros_like(u)\n            # Central difference on the interior of the grid.\n            lap_u[1:-1, 1:-1] = (u[1:-1, 2:] + u[1:-1, :-2] + u[2:, 1:-1] + u[:-2, 1:-1] - 4.0 * u[1:-1, 1:-1]) / (h**2)\n        else:\n            raise ValueError(\"Unknown boundary condition type.\")\n        return lap_u\n\n    def jacobi_solver(N, f_func, bc_type, tol, max_iter):\n        \"\"\"\n        Solves the 2D Poisson equation using Jacobi relaxation.\n\n        Args:\n            N (int): Number of grid points in each dimension (Nx=Ny=N).\n            f_func (function): The forcing function f(x, y).\n            bc_type (str): 'periodic' or 'dirichlet'.\n            tol (float): Relative residual tolerance for convergence.\n            max_iter (int): Maximum number of iterations.\n        \n        Returns:\n            A tuple (u, h, converged_flag) or (None, h, converged_flag) for non-solvable periodic case.\n        \"\"\"\n        if bc_type == 'periodic':\n            h = 1.0 / N\n            x = np.linspace(0, 1.0 - h, N)\n        elif bc_type == 'dirichlet':\n            h = 1.0 / (N - 1)\n            x = np.linspace(0, 1.0, N)\n        else:\n            raise ValueError(\"Unknown boundary condition type.\")\n            \n        xv, yv = np.meshgrid(x, x, indexing='ij')\n        f = f_func(xv, yv)\n        u = np.zeros_like(f)\n\n        if bc_type == 'periodic':\n            # Check solvability condition for periodic problem.\n            mean_f = np.mean(f)\n            if abs(mean_f) > 1e-12:\n                # The problem is not solvable.\n                return None, h, False\n\n        f_norm = get_l2_norm(f, h)\n        if f_norm == 0:\n            # If f is zero everywhere, u=0 is the solution.\n            return u, h, True\n\n        for k in range(max_iter):\n            u_old = u.copy()\n            \n            if bc_type == 'periodic':\n                u_i_plus = np.roll(u_old, -1, axis=1)\n                u_i_minus = np.roll(u_old, 1, axis=1)\n                u_j_plus = np.roll(u_old, -1, axis=0)\n                u_j_minus = np.roll(u_old, 1, axis=0)\n                u = 0.25 * (u_i_plus + u_i_minus + u_j_plus + u_j_minus - h**2 * f)\n            else: # dirichlet\n                # Update only interior points\n                u[1:-1, 1:-1] = 0.25 * (u_old[1:-1, 2:] + u_old[1:-1, :-2] + \\\n                                       u_old[2:, 1:-1] + u_old[:-2, 1:-1] - h**2 * f[1:-1, 1:-1])\n\n            # Check for convergence\n            lap_u = apply_laplacian(u, h, bc_type)\n            residual = f - lap_u\n            residual_norm = get_l2_norm(residual, h)\n            \n            if residual_norm / f_norm  tol:\n                return u, h, True\n        \n        # If loop finishes, max iterations were reached without convergence.\n        # This is also considered non-convergence for the purpose of the problem.\n        return u, h, False\n\n    results = []\n    \n    # --- Test Case 1: Periodic, analytic mode ---\n    N1 = 64\n    tol1 = 1e-8\n    max_iter1 = 6000\n    f1_func = lambda x, y: np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n    \n    u1, h1, _ = jacobi_solver(N1, f1_func, 'periodic', tol1, max_iter1)\n    \n    # Analytic discrete solution\n    lambda_d = (8.0 / h1**2) * (np.sin(np.pi / N1)**2)\n    x1 = np.linspace(0, 1.0 - h1, N1)\n    xv1, yv1 = np.meshgrid(x1, x1, indexing='ij')\n    f1 = f1_func(xv1, yv1)\n    u_star1 = -f1 / lambda_d\n    \n    # Relative L2 error\n    error_norm = get_l2_norm(u1 - u_star1, h1)\n    ustar_norm = get_l2_norm(u_star1, h1)\n    relative_error = error_norm / ustar_norm\n    results.append(relative_error)\n\n    # --- Test Case 2: Periodic, non-solvable forcing ---\n    N2 = 64\n    tol2 = 1e-8\n    max_iter2 = 6000\n    f2_func = lambda x, y: np.ones_like(x)\n    \n    # Solver will detect non-zero mean and return converged_flag=False.\n    _, _, converged2 = jacobi_solver(N2, f2_func, 'periodic', tol2, max_iter2)\n    # As per prompt, output False for non-convergence.\n    results.append(converged2)\n\n    # --- Test Case 3: Periodic vs. Dirichlet ---\n    f3_func = lambda x, y: np.cos(2 * np.pi * x) + np.cos(2 * np.pi * y)\n    tol3 = 1e-8\n    max_iter3 = 6000\n    \n    # Periodic solution\n    # N=64 gives h=1/64\n    u_per, h_per, _ = jacobi_solver(64, f3_func, 'periodic', tol3, max_iter3)\n    norm_per = get_l2_norm(u_per, h_per)\n    \n    # Dirichlet solution\n    # N=65 gives h=1/64\n    u_dir, h_dir, _ = jacobi_solver(65, f3_func, 'dirichlet', tol3, max_iter3)\n    norm_dir = get_l2_norm(u_dir, h_dir)\n    \n    # Ratio of norms\n    ratio = norm_per / norm_dir\n    results.append(ratio)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2404984"}]}