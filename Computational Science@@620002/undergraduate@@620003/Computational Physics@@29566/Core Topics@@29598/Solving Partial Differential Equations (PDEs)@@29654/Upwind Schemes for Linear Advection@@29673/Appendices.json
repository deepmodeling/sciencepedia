{"hands_on_practices": [{"introduction": "This first exercise is your gateway to implementing advection solvers. You will simulate the movement of a sharp front, or a step function, which is one of the most challenging tests for a numerical scheme. By implementing a first-order upwind scheme for both positive and negative velocities [@problem_id:2448567], you will directly observe the scheme's most notable characteristic: numerical diffusion, which smooths out sharp features.", "problem": "Consider the one-dimensional linear advection equation for a scalar field $u(x,t)$ with constant advection speed $a$,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\nwith the initial condition given by the Heaviside step function\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1,& \\xi \\ge 0,\\\\\n0,& \\xi &lt; 0.\n\\end{cases}\n$$\nImpose inflow boundary conditions consistent with the far-field states of the initial data: if $a &gt; 0$, enforce $u(x_{\\min},t)=0$ for all $t \\ge 0$; if $a &lt; 0$, enforce $u(x_{\\max},t)=1$ for all $t \\ge 0$. All quantities are dimensionless.\n\nAdvance the solution in time on a uniform spatial grid of $N$ points in $[x_{\\min},x_{\\max}]$ up to a final time $T$, with a time step $\\Delta t$ chosen to satisfy a specified Courant–Friedrichs–Lewy (CFL) number $C$, where\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\nUse a first-order upwind discretization consistent with the sign of $a$. For each test case below, compute the discrete $\\ell^1$ error at time $T$ defined by\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\nwhere $x_i$ are the grid points, $u_i^{\\text{num}}(T)$ is the numerical solution at time $T$, and the analytical solution is the translated step\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\nwhich is valid for the times and parameters given below because the advected discontinuity remains strictly inside the interval $[x_{\\min},x_{\\max}]$ and does not interact with the boundaries.\n\nTest Suite (each test case is a tuple $(a,x_{\\min},x_{\\max},x_0,N,T,C)$):\n- Test $1$: $(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$.\n- Test $2$: $(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$.\n- Test $3$: $(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$.\n\nYour program must compute $E_1$ for each test in the order listed and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each number rounded to six decimal places (for example, $[0.123456,0.000000,1.234568]$).", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It presents a standard task in computational physics: solving the linear advection equation using a first-order upwind scheme and evaluating the numerical error. All parameters and conditions are clearly defined.\n\nThe governing equation is the one-dimensional linear advection equation for a scalar field $u(x,t)$ with a constant advection speed $a$:\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\nTo solve this equation numerically, we discretize the spatio-temporal domain. The spatial domain $[x_{\\min}, x_{\\max}]$ is divided into a uniform grid of $N$ points, $x_i = x_{\\min} + i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$. Time is advanced in discrete steps, and we denote the numerical approximation of $u(x_i, t^n)$ as $u_i^n$.\n\nThe time derivative $\\partial_t u$ is approximated using a first-order forward difference (Forward Euler method):\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\nThe first-order upwind scheme approximates the spatial derivative $\\partial_x u$ using a one-sided finite difference. The choice of the one-sided stencil depends on the direction of information propagation, which is given by the sign of the advection speed $a$. This ensures that the numerical method draws information from the \"upwind\" direction, a crucial property for the stability of hyperbolic solvers.\n\nCase 1: $a > 0$\nInformation propagates from left to right (in the positive $x$ direction). The spatial derivative at $x_i$ is approximated using a backward difference, which involves the point upwind, $x_{i-1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\nSubstituting these discrete approximations into the partial differential equation yields the update rule:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\nSolving for the solution at the next time step, $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\nwhere $C = \\frac{a \\Delta t}{\\Delta x}$ is the Courant–Friedrichs–Lewy (CFL) number, as $a>0$. This scheme is applied for $i=1, \\dots, N-1$.\n\nCase 2: $a < 0$\nInformation propagates from right to left (in the negative $x$ direction). The spatial derivative is approximated using a forward difference, involving the upwind point $x_{i+1}$:\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\nThe corresponding update rule is:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\nSolving for $u_i^{n+1}$:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\nHere, the CFL number is defined as $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$, which means $\\frac{a \\Delta t}{\\Delta x} = -C$. This scheme is applied for $i=0, \\dots, N-2$.\n\nThe stability of this explicit time-stepping scheme is guaranteed if the CFL condition, $C \\le 1$, is met. All test cases provided satisfy this condition.\n\nThe simulation proceeds as follows:\n1.  **Initialization**: For each test case $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$, the grid spacing $\\Delta x$ and nominal time step $\\Delta t = C \\Delta x / |a|$ are calculated. The solution array $u$ is initialized with the Heaviside function $u(x,0) = H(x - x_0)$.\n2.  **Time Evolution**: A loop advances the solution from $t=0$ to $T$. To ensure the final time $T$ is reached precisely, the time step for each iteration is calculated as $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$. This handles cases where $T$ is not an integer multiple of $\\Delta t$.\n3.  **Update Step**: Inside the loop, a copy of the solution $u^n$ is made. The new solution $u^{n+1}$ is computed for all interior points using the appropriate upwind formula, with the update coefficient scaled by $\\Delta t_{\\text{curr}}$.\n4.  **Boundary Conditions**: After computing the interior-point updates, the inflow boundary condition is enforced. If $a > 0$, the value at the left boundary is set: $u_0^{n+1} = 0$. If $a < 0$, the value at the right boundary is set: $u_{N-1}^{n+1} = 1$. The outflow boundary requires no special treatment as it is handled by the one-sided nature of the upwind stencil.\n5.  **Error Calculation**: Once the simulation reaches $t=T$, the final numerical solution $u_i^{\\text{num}}(T)$ is obtained. The analytical solution $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$ is computed on the same grid. The discrete $\\ell^1$ error is then calculated using the formula:\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\nFor the test case where $C=1.0$, the scheme (for $a>0$) simplifies to $u_i^{n+1} = u_{i-1}^n$. This corresponds to an exact shift of the discrete data by one grid cell per time step. Since the total time $T$ is chosen such that the total advection distance $aT$ is an integer multiple of $\\Delta x$, the numerical solution on the grid is identical to the exact solution, resulting in zero error. For $C < 1$, the scheme introduces numerical diffusion, which smears the sharp step and produces a non-zero error.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi >= 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t < T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a > 0:\n            # FTBS (Forward-Time, Backward-Space) for a > 0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a < 0\n            # FTFS (Forward-Time, Forward-Space) for a < 0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```", "id": "2448567"}, {"introduction": "Having mastered the one-dimensional case, let's expand our horizons into two dimensions. This practice challenges you to advect a two-dimensional Gaussian profile using a constant velocity vector. You will extend the upwind logic by applying it independently to each spatial dimension, a technique known as dimensional splitting, which is a cornerstone of building multi-dimensional solvers [@problem_id:2448614]. This exercise is a crucial step towards modeling more realistic physical phenomena that occur in a multi-dimensional world.", "problem": "Implement a complete, runnable program that advances the solution of the two-dimensional linear advection equation\n$$\n\\partial_t u(x,y,t) + v_x\\,\\partial_x u(x,y,t) + v_y\\,\\partial_y u(x,y,t) = 0\n$$\non the periodic domain $[0,L_x)\\times[0,L_y)$ using a first-order upwind finite-difference method on a uniform, cell-centered grid. The initial condition is a dimensionless Gaussian profile\n$$\nu(x,y,0) = \\exp\\!\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2\\,\\sigma^2}\\right),\n$$\nwith periodic boundary conditions in both spatial directions. All quantities are dimensionless. Use the uniform grid with $N_x$ points in the $x$-direction and $N_y$ points in the $y$-direction, cell-centered at\n$$\nx_i=(i+\\tfrac{1}{2})\\,\\Delta x,\\quad \\Delta x=\\frac{L_x}{N_x},\\quad i=0,1,\\dots,N_x-1,\n$$\n$$\ny_j=(j+\\tfrac{1}{2})\\,\\Delta y,\\quad \\Delta y=\\frac{L_y}{N_y},\\quad j=0,1,\\dots,N_y-1.\n$$\nAdvance the numerical solution to final time $T$ using a constant time step $\\Delta t$ such that $T = N_{\\text{steps}}\\Delta t$ with given integer $N_{\\text{steps}}$. Impose periodic boundary conditions in both spatial directions. For each test case, compute the discrete root-mean-square error at time $T$,\n$$\nE = \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left(u_{i,j}(T) - u_{\\text{exact}}(x_i,y_j,T)\\right)^2},\n$$\nwhere the exact solution under periodic boundary conditions is given by the periodic shift of the initial condition,\n$$\nu_{\\text{exact}}(x,y,T) = u_0\\!\\Big(\\operatorname{wrap}(x - v_x T,L_x),\\ \\operatorname{wrap}(y - v_y T,L_y)\\Big),\n$$\nand $\\operatorname{wrap}(z,L)$ denotes the unique representative of $z$ modulo $L$ in $[0,L)$. Here $u_0(x,y)$ denotes the initial Gaussian profile. All computations must be performed in dimensionless units.\n\nUse the following fixed parameters (common to all test cases):\n- Domain sizes: $L_x=1$, $L_y=1$.\n- Initial Gaussian center: $x_0=0.35$, $y_0=0.40$.\n- Initial Gaussian width: $\\sigma=0.08$.\n\nTest suite. Run the program for each of the following parameter sets. In each case, set the time step as $\\Delta t = T/N_{\\text{steps}}$ and use the given values exactly:\n- Case $1$: $N_x=64$, $N_y=64$, $v_x=0.7$, $v_y=0.2$, $T=0.5$, $N_{\\text{steps}}=36$.\n- Case $2$: $N_x=100$, $N_y=60$, $v_x=-1.0$, $v_y=0.0$, $T=0.4$, $N_{\\text{steps}}=50$.\n- Case $3$: $N_x=64$, $N_y=80$, $v_x=0.0$, $v_y=0.5$, $T=0.6$, $N_{\\text{steps}}=30$.\n- Case $4$: $N_x=64$, $N_y=64$, $v_x=0.0$, $v_y=0.0$, $T=0.25$, $N_{\\text{steps}}=25$.\n- Case $5$: $N_x=50$, $N_y=50$, $v_x=0.9$, $v_y=-0.9$, $T=0.44$, $N_{\\text{steps}}=40$.\n\nRequired final output format. Your program should produce a single line of output containing the five root-mean-square errors, in the order of Cases $1$ through $5$, as a comma-separated list enclosed in square brackets, for example\n$$\n[\\text{E}_1,\\text{E}_2,\\text{E}_3,\\text{E}_4,\\text{E}_5].\n$$\nEach entry must be a floating-point number. No other text should be printed.", "solution": "The problem presented is a standard exercise in computational physics, concerning the numerical solution of the two-dimensional linear advection equation. It is scientifically grounded, well-posed, and contains all necessary information for a unique solution. All provided parameters for the test cases satisfy the Courant-Friedrichs-Lewy (CFL) stability condition for the proposed explicit first-order upwind scheme. The problem is therefore deemed valid and a solution is constructed as follows.\n\nThe governing equation is the linear advection equation in two spatial dimensions $(x,y)$ and time $t$:\n$$\n\\partial_t u + v_x\\,\\partial_x u + v_y\\,\\partial_y u = 0\n$$\nwhere $u(x,y,t)$ is a scalar quantity being advected by a constant velocity field $\\vec{v} = (v_x, v_y)$. We are tasked to solve this equation numerically on a periodic domain $[0,L_x) \\times [0,L_y)$.\n\nThe solution employs the method of lines, where the spatial and temporal dimensions are discretized separately. The temporal discretization uses the explicit first-order forward Euler method, while the spatial derivatives are approximated using a first-order upwind finite difference scheme. Let $u_{i,j}^n$ denote the numerical approximation of $u(x_i, y_j, t_n)$, where $x_i = (i + 1/2)\\Delta x$ and $y_j = (j + 1/2)\\Delta y$ are the cell-centered grid coordinates, and $t_n = n\\Delta t$ is the time at step $n$.\n\nThe semi-discretization of the equation in time is:\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = - (v_x\\,\\partial_x u + v_y\\,\\partial_y u)\\Big|_{i,j}^n\n$$\n\nThe core of the upwind method is that the spatial differencing is biased in the direction from which information is propagating, i.e., \"upwind\" of the advection velocity. The approximation for the spatial derivatives depends on the sign of the velocity components $v_x$ and $v_y$.\n\nFor the $\\partial_x u$ term:\n- If $v_x > 0$, information propagates from smaller $x$ (left), so a backward difference is used:\n  $$ \\partial_x u \\approx \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} $$\n- If $v_x < 0$, information propagates from larger $x$ (right), so a forward difference is used:\n  $$ \\partial_x u \\approx \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x} $$\n- If $v_x = 0$, the term is zero.\n\nThis can be expressed compactly using the positive and negative parts of the velocity, $v_x^+ = \\max(v_x, 0)$ and $v_x^- = \\min(v_x, 0)$:\n$$\nv_x \\partial_x u \\approx v_x^+ \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} + v_x^- \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x}\n$$\nA similar expression holds for the $y$-derivative:\n$$\nv_y \\partial_y u \\approx v_y^+ \\frac{u_{i,j}^n - u_{i,j-1}^n}{\\Delta y} + v_y^- \\frac{u_{i,j+1}^n - u_{i,j}^n}{\\Delta y}\n$$\n\nCombining these discretizations, we obtain the full update rule for $u_{i,j}^{n+1}$:\n$$\nu_{i,j}^{n+1} = u_{i,j}^n - \\Delta t \\left( v_x^+ \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} + v_x^- \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x} \\right) - \\Delta t \\left( v_y^+ \\frac{u_{i,j}^n - u_{i,j-1}^n}{\\Delta y} + v_y^- \\frac{u_{i,j+1}^n - u_{i,j}^n}{\\Delta y} \\right)\n$$\nThis scheme is first-order accurate in both time and space. While simple and stable under the CFL condition $\\Delta t (|v_x|/\\Delta x + |v_y|/\\Delta y) \\le 1$, it is known to be highly dissipative, meaning it introduces significant numerical diffusion which smooths out sharp features in the solution. This will be the dominant source of error.\n\nThe implementation proceeds as follows:\n$1$. For each test case, the grid parameters ($N_x, N_y$), velocity components ($v_x, v_y$), and time integration parameters ($T, N_{\\text{steps}}$) are defined. Derived quantities $\\Delta x=L_x/N_x$, $\\Delta y=L_y/N_y$, and $\\Delta t=T/N_{\\text{steps}}$ are computed.\n$2$. A two-dimensional grid of cell-center coordinates $(X, Y)$ is constructed. The initial condition $u(x,y,0)$ is evaluated at these grid points to initialize the solution array $u$.\n$3$. A loop iterates for $N_{\\text{steps}}$ to advance the solution from $t=0$ to $t=T$. In each step, the update rule is applied to all grid points simultaneously. Periodic boundary conditions are enforced by using array-rolling operations (such as `numpy.roll`), which correctly wraps the indices at the domain boundaries. For example, to access $u_{i-1,j}$, the array is shifted such that the data from index $i-1$ moves to index $i$. For $i=0$, the data from the last index $N_x-1$ is used.\n$4$. After the final time step, the numerical solution $u(T)$ is obtained.\n$5$. The exact solution at the final time $T$ is computed. For the linear advection equation on a periodic domain, the initial profile is simply translated. The position of a fluid element at time $T$ that was initially at $(x', y')$ is $(x,y) = (x'+v_x T, y'+v_y T)$. Thus, the solution at $(x,y,T)$ is the initial state at $(x-v_x T, y-v_y T)$. For the periodic domain, this argument must be wrapped:\n$$\nu_{\\text{exact}}(x,y,T) = u_0(\\operatorname{wrap}(x - v_x T,L_x),\\ \\operatorname{wrap}(y - v_y T,L_y))\n$$\nwhere $\\operatorname{wrap}(z, L)$ computes $z \\pmod{L}$ into the interval $[0,L)$.\n$6$. Finally, the discrete root-mean-square error $E$ is calculated as specified:\n$$\nE = \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left(u_{i,j}(T) - u_{\\text{exact}}(x_i,y_j,T)\\right)^2}\n$$\nThe program computes this error for each of the five test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear advection equation using a first-order upwind scheme.\n    \"\"\"\n    \n    # Fixed parameters common to all test cases (dimensionless)\n    L_x = 1.0\n    L_y = 1.0\n    x_0 = 0.35\n    y_0 = 0.40\n    sigma = 0.08\n\n    # Test suite: (Nx, Ny, vx, vy, T, N_steps)\n    test_cases = [\n        (64, 64, 0.7, 0.2, 0.5, 36),\n        (100, 60, -1.0, 0.0, 0.4, 50),\n        (64, 80, 0.0, 0.5, 0.6, 30),\n        (64, 64, 0.0, 0.0, 0.25, 25),\n        (50, 50, 0.9, -0.9, 0.44, 40),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N_x, N_y, v_x, v_y, T, N_steps = case\n        \n        # Calculate grid spacing and time step\n        delta_x = L_x / N_x\n        delta_y = L_y / N_y\n        delta_t = T / N_steps\n\n        # Create cell-centered grid coordinates\n        x_coords = (np.arange(N_x) + 0.5) * delta_x\n        y_coords = (np.arange(N_y) + 0.5) * delta_y\n        X, Y = np.meshgrid(x_coords, y_coords)\n\n        # Initialize the solution with the Gaussian profile\n        u = np.exp(-((X - x_0)**2 + (Y - y_0)**2) / (2 * sigma**2))\n\n        # Time evolution loop\n        for _ in range(N_steps):\n            u_current = u.copy()\n            \n            # X-advection flux term based on upwinding\n            if v_x > 0:\n                flux_x = v_x * (u_current - np.roll(u_current, 1, axis=1)) / delta_x\n            elif v_x < 0:\n                flux_x = v_x * (np.roll(u_current, -1, axis=1) - u_current) / delta_x\n            else:  # v_x == 0\n                flux_x = np.zeros_like(u_current)\n\n            # Y-advection flux term based on upwinding\n            if v_y > 0:\n                flux_y = v_y * (u_current - np.roll(u_current, 1, axis=0)) / delta_y\n            elif v_y < 0:\n                flux_y = v_y * (np.roll(u_current, -1, axis=0) - u_current) / delta_y\n            else:  # v_y == 0\n                flux_y = np.zeros_like(u_current)\n            \n            # Update the solution using forward Euler\n            u = u_current - delta_t * (flux_x + flux_y)\n\n        # Calculate the exact solution at time T\n        # The modulo operator '%' in Python correctly handles wrapping for periodic BC\n        x_exact_arg = (X - v_x * T) % L_x\n        y_exact_arg = (Y - v_y * T) % L_y\n        u_exact = np.exp(-((x_exact_arg - x_0)**2 + (y_exact_arg - y_0)**2) / (2 * sigma**2))\n\n        # Compute the discrete root-mean-square error\n        error = np.sqrt(np.mean((u - u_exact)**2))\n        results.append(error)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "2448614"}, {"introduction": "Our final practice takes a deeper look into the subtle effects of numerical schemes. The original advection equation conserves not only the total \"mass\" of the solution but also higher-order moments like the total \"energy,\" proportional to $\\int u^2 dx$. This exercise asks you to investigate whether the upwind scheme preserves this energy [@problem_id:2448571]. By tracking the evolution of the discrete second moment, you will quantitatively measure the scheme's numerical dissipation, revealing a key difference between the continuous PDE and its discrete approximation.", "problem": "Consider the linear advection equation with constant velocity on a one-dimensional periodic domain,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\qquad x\\in[0,L],\\ t\\ge 0,\n$$\nwith periodic boundary conditions and the initial condition\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right).\n$$\nOn a uniform grid with $N$ points at positions $x_i=i\\,\\Delta x$ for $i=0,1,\\dots,N-1$ and $\\Delta x=L/N$, define the discrete solution values $u_i^n\\approx u(x_i,t^n)$ at time levels $t^n=n\\,\\Delta t$, where the time step is chosen through a Courant number $s\\in(0,1]$ by\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}.\n$$\nUse the first-order upwind finite difference scheme with periodic wrapping for the update from time level $n$ to $n+1$:\n- If $a>0$,\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right),\n$$\n- If $a<0$,\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right),\n$$\nwhere indices are understood modulo $N$ due to periodicity. Evolve the discrete solution from $t=0$ to the final time\n$$\nt_{\\mathrm{final}}=\\frac{L}{|a|},\n$$\nwhich corresponds to exactly $N_t=N/s$ time steps (all test cases below ensure that $N/s$ is an integer), so that the exact continuous solution has completed one full wrap around the domain.\n\nDefine the discrete second moment at time level $n$ by\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x,\n$$\nand the diagnostic ratio\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}.\n$$\nIn the continuous equation with periodic boundaries, the quantity $\\int_0^L u(x,t)^2\\,\\mathrm{d}x$ is conserved in time. This problem examines how the numerical diffusion introduced by the upwind scheme affects the conservation of the discrete second moment $M_2^n$ over one domain traversal.\n\nAll quantities in this problem are dimensionless.\n\nImplement a program that, for each parameter set in the test suite below, computes the ratio $R$ as defined above.\n\nTest suite (each tuple lists $(L,a,N,s)$):\n1. $(1,\\ 1,\\ 200,\\ 0.5)$,\n2. $(1,\\ 1,\\ 100,\\ 1)$,\n3. $(1,\\ -1,\\ 200,\\ 0.5)$,\n4. $(1,\\ 1,\\ 20,\\ 0.5)$,\n5. $(1,\\ 1,\\ 200,\\ 0.25)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3,r_4,r_5]$), where each $r_k$ is the floating-point value of $R$ for the $k$-th test case in the order listed above.", "solution": "The problem presented is a standard exercise in computational physics, concerning the numerical solution of the linear advection equation. It is well-posed, scientifically sound, and all parameters and conditions are specified unambiguously. Therefore, a solution can be constructed.\n\nThe core of the problem is to quantify the numerical dissipation inherent in the first-order upwind finite difference scheme. The governing partial differential equation is the linear advection equation:\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\non a one-dimensional domain $x\\in[0,L]$ with periodic boundary conditions. For such a system, the integrated square of the solution, $\\int_0^L u(x,t)^2\\,\\mathrm{d}x$, is a conserved quantity. The numerical scheme, however, introduces artificial diffusion which causes the discrete analogue of this quantity to decay over time.\n\nWe discretize the domain using a uniform grid of $N$ points, $x_i = i\\,\\Delta x$ for $i \\in \\{0, 1, \\dots, N-1\\}$, where the grid spacing is $\\Delta x = L/N$. The solution $u(x,t)$ is approximated by discrete values $u_i^n \\approx u(x_i, t^n)$, where $t^n = n\\,\\Delta t$ are the discrete time levels.\n\nFirst, we establish the initial state of the system at time $t=0$. The initial condition is given by:\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right)\n$$\nIn discrete form, the initial solution vector $u^0 = [u_0^0, u_1^0, \\dots, u_{N-1}^0]^T$ is initialized as:\n$$\nu_i^0 = \\sin\\!\\left(\\tfrac{2\\pi x_i}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x_i}{L}\\right) = \\sin\\!\\left(\\tfrac{2\\pi i}{N}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi i}{N}\\right)\n$$\nfor each grid point $i=0, 1, \\dots, N-1$.\n\nNext, we evolve the solution in time using the first-order upwind scheme. The time step $\\Delta t$ is determined by the Courant number $s \\in (0,1]$:\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}\n$$\nThe upwind scheme's update rule depends on the sign of the advection velocity $a$, which determines the direction of information propagation.\n\nCase 1: $a>0$ (propagation to the right). The spatial derivative $\\partial_x u$ is approximated using a backward difference, as information comes from the \"upwind\" direction, i.e., from smaller $x$. The update rule is:\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right)\n$$\nHere, $s = a \\frac{\\Delta t}{\\Delta x}$ since $a>0$. Due to periodic boundary conditions, the index $i-1$ is evaluated modulo $N$, meaning $u_{-1}^n = u_{N-1}^n$.\n\nCase 2: $a<0$ (propagation to the left). The spatial derivative is approximated using a forward difference, as information comes from larger $x$. The update rule is:\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right)\n$$\nHere, $s = |a| \\frac{\\Delta t}{\\Delta x} = -a \\frac{\\Delta t}{\\Delta x}$. Due to periodicity, the index $i+1$ is evaluated modulo $N$, meaning $u_{N}^n = u_0^n$.\n\nThe simulation proceeds from $t=0$ to a final time $t_{\\mathrm{final}}=L/|a|$. This time corresponds to one full periodic transit of a wave across the domain. The total number of time steps, $N_t$, is:\n$$\nN_t = \\frac{t_{\\mathrm{final}}}{\\Delta t} = \\frac{L/|a|}{s\\,\\Delta x/|a|} = \\frac{L}{s\\,\\Delta x} = \\frac{L}{s(L/N)} = \\frac{N}{s}\n$$\nThe problem guarantees that $N_t$ is an integer for all test cases. A loop will execute this update step $N_t$ times to obtain the final discrete solution $u^{N_t}$.\n\nFinally, we compute the diagnostic ratio $R$. This requires calculating the discrete second moment, defined as:\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x\n$$\nWe compute this quantity at the initial time, $M_2^0$, using the initial solution $u^0$, and at the final time, $M_2^{N_t}$, using the final solution $u^{N_t}$. The ratio $R$ is then given by:\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}\n$$\nThis ratio $R$ quantifies the decay of the discrete squared $L_2$-norm due to numerical dissipation over one traversal period. For a non-dissipative scheme, $R$ would be exactly $1$. For the first-order upwind scheme, we expect $R<1$ for $s<1$, with the deviation from $1$ indicating the magnitude of dissipation.\n\nThe algorithm for each test case $(L, a, N, s)$ is as follows:\n1.  Define grid parameters: $\\Delta x = L/N$ and $N_t = \\text{int}(N/s)$.\n2.  Generate the spatial grid $x_i = i \\Delta x$ for $i = 0, \\dots, N-1$.\n3.  Compute the initial solution vector $u^0$ using the given formula.\n4.  Calculate the initial second moment $M_2^0 = \\Delta x \\sum_{i=0}^{N-1} (u_i^0)^2$.\n5.  Iterate $N_t$ times: in each step, update the solution vector $u$ using the appropriate upwind formula based on the sign of $a$, respecting periodic boundaries. This is efficiently implemented using vectorized array operations.\n6.  After the loop, calculate the final second moment $M_2^{N_t}$ from the final solution vector.\n7.  Compute and store the ratio $R = M_2^{N_t} / M_2^0$.\n\nThis procedure is repeated for all provided test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using the first-order upwind scheme\n    and computes the diagnostic ratio R for several test cases.\n    \"\"\"\n    # Test suite from the problem statement: (L, a, N, s)\n    test_cases = [\n        (1, 1, 200, 0.5),\n        (1, 1, 100, 1),\n        (1, -1, 200, 0.5),\n        (1, 1, 20, 0.5),\n        (1, 1, 200, 0.25),\n    ]\n\n    results = []\n    \n    for L, a, N, s in test_cases:\n        # Step 1: Define grid parameters and number of time steps.\n        dx = L / N\n        # The problem statement guarantees that N/s is an integer.\n        num_time_steps = int(N / s)\n        \n        # Step 2: Set the initial condition on the grid.\n        # Grid points x_i = i * dx for i = 0, ..., N-1.\n        x = np.linspace(0, L, N, endpoint=False)\n        u_initial = np.sin(2 * np.pi * x / L) + 0.5 * np.sin(4 * np.pi * x / L)\n        \n        # Step 3: Calculate the initial discrete second moment M_2^0.\n        m2_initial = np.sum(u_initial**2) * dx\n        \n        # Step 4: Evolve the solution in time using the upwind scheme.\n        u_current = np.copy(u_initial)\n        \n        # The update rule depends on the sign of the velocity 'a'.\n        if a > 0:\n            # For a > 0, the scheme uses the backward difference (u_i - u_{i-1}).\n            # u_i^{n+1} = u_i^n - s * (u_i^n - u_{i-1}^n)\n            # np.roll(u, 1) provides u_{i-1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_previous = np.roll(u_current, 1)\n                u_current = u_current - s * (u_current - u_previous)\n        else: # a < 0\n            # For a < 0, the scheme uses the forward difference (u_{i+1} - u_i).\n            # The problem statement gives u_i^{n+1} = u_i^n - s * (u_i^n - u_{i+1}^n)\n            # which is equivalent to u_i^{n+1} = u_i^n + s * (u_{i+1}^n - u_i^n).\n            # np.roll(u, -1) provides u_{i+1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_next = np.roll(u_current, -1)\n                u_current = u_current - s * (u_current - u_next)\n                \n        # Step 5: Calculate the final discrete second moment M_2^{N_t}.\n        m2_final = np.sum(u_current**2) * dx\n        \n        # Step 6: Compute the diagnostic ratio R.\n        # A check is included for the theoretical case of M_2^0 = 0, though not\n        # possible with the given initial condition.\n        if m2_initial == 0:\n            ratio = 1.0 if m2_final == 0 else np.inf\n        else:\n            ratio = m2_final / m2_initial\n            \n        results.append(ratio)\n        \n    # Final print statement in the exact required format.\n    # Results are formatted as floating-point numbers to ensure consistency.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "2448571"}]}