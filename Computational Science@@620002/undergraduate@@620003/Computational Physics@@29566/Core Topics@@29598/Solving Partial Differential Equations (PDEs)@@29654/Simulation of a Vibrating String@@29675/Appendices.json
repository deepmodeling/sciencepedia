{"hands_on_practices": [{"introduction": "This first practice is your entry into simulating wave dynamics. You will implement the fundamental finite-difference time-domain (FDTD) scheme to solve the 1D wave equation, exploring how to set initial conditions that create traveling wave packets [@problem_id:2438583]. This exercise will solidify your understanding of numerical stability through the Courant–Friedrichs–Lewy (CFL) condition and allow you to observe classic wave phenomena like constructive and destructive interference firsthand.", "problem": "You are to derive, implement, and test a numerical simulation of a taut, uniform string subject to small transverse vibrations, in which two localized Gaussian wave packets travel in opposite directions, superpose, and interfere. Your program must implement an explicit finite-difference time-domain scheme for the one-dimensional wave equation with fixed-end boundary conditions. The program must run without user input and must output a single line containing the results for the specified test suite.\n\nPhysical and mathematical base:\n- Start from Newton’s second law applied to a uniformly dense string: a small segment of linear mass density $\\mu$ subject to nearly horizontal tension $T$ yields the continuum equation $\\mu \\partial^2 u / \\partial t^2 = T \\partial^2 u / \\partial x^2$, where $u(x,t)$ is the transverse displacement. Define the wave speed $c$ by $c^2 = T/\\mu$ to obtain the wave equation $\\partial^2 u / \\partial t^2 = c^2 \\partial^2 u / \\partial x^2$.\n- Impose fixed-end (Dirichlet) boundary conditions $u(0,t)=0$ and $u(L,t)=0$, with $L$ the string length.\n- Use a uniform spatial grid with spacing $\\Delta x$ and a uniform time step $\\Delta t$ satisfying the Courant–Friedrichs–Lewy (CFL) condition for stability.\n- Discretize the wave equation using centered second-order differences in space and time, producing an explicit update for $u_i^{n+1}$ in terms of $u_i^n$ and $u_i^{n-1}$, where $u_i^n$ approximates $u(x_i, t_n)$ at $x_i = i \\Delta x$ and $t_n = n \\Delta t$. Derive the second-order accurate first-step formula for $u_i^1$ from a Taylor expansion using the initial velocity $v(x)=\\partial u/\\partial t(x,0)$.\n- Choose the initial displacement $u(x,0)$ to be the sum of two Gaussian profiles centered at $x=x_1$ and $x=x_2$ with amplitudes $A_1$ and $A_2$ and widths $\\sigma_1$ and $\\sigma_2$. Choose the initial velocity $v(x)$ so that the first Gaussian travels to the right with speed $c$ and the second Gaussian travels to the left with speed $c$. Derive the needed $v(x)$ explicitly in terms of $u(x,0)$ constructed from the two Gaussians and their spatial derivatives. Do not use any shortcut formulas beyond the fundamental laws and definitions described above; derive what you need from first principles and standard calculus.\n- The total mechanical energy of the string (per unit width out of plane) is $E(t) = \\int_0^L \\tfrac{1}{2}\\left[(\\partial u/\\partial t)^2 + c^2 (\\partial u/\\partial x)^2\\right] \\, dx$. For fixed ends and no external forcing, $E(t)$ should be approximately conserved in the numerical simulation as long as wave packets do not reach the boundaries during the simulated time.\n\nNumerical specifications:\n- Use units of meters for $x$ and $u$, and seconds for $t$. The wave speed $c$ is in meters per second. All reported displacement quantities and errors must be in meters. Any reported energy changes are dimensionless ratios. No angles are involved.\n- Use a spatial grid of $N_x$ points on $[0,L]$ with $x_i = i \\Delta x$, where $\\Delta x = L/(N_x-1)$.\n- Use a time step $\\Delta t$ satisfying $0 < \\lambda \\le 1$, where $\\lambda = c \\Delta t / \\Delta x$ is the Courant number. Use $\\lambda$ strictly less than $1$ for stability. Define and use a specific $\\lambda$ of your choice in your implementation, and compute $\\Delta t$ accordingly.\n\nObservables to compute:\n- Let $t_\\star$ be the time when the centers of the two Gaussian wave packets coincide, and let $x_\\star$ be the collision location. Compute the simulated string displacement at $(x_\\star, t_\\star)$ by temporal interpolation if $t_\\star$ does not land exactly on a time step and by using the nearest grid point to $x_\\star$ if $x_\\star$ is not exactly a grid point. Report the absolute error at the collision for two test cases: one with constructive interference (both amplitudes positive) and one with destructive interference (opposite-sign amplitudes). Errors must be in meters.\n- For a third test case (different parameter set), compute the relative change in total energy between $t=0$ and $t=t_\\star$, defined as $|E(t_\\star)-E(0)|/E(0)$, and report whether this relative change is strictly less than a chosen tolerance (return a boolean). Choose the simulation parameters and $t_\\star$ so that the wave packets remain well separated from the boundaries for $0 \\le t \\le t_\\star$.\n\nTest suite:\nProvide three parameter sets. In each case, the domain is $[0,L]$ with $L$ in meters, wave speed $c$ in meters per second, and Gaussian parameters in meters.\n- Case A (constructive interference):\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$.\n  - The expected collision occurs at $t_\\star = (x_2 - x_1)/(2c)$ and $x_\\star = (x_1 + x_2)/2$. The expected displacement at $(x_\\star, t_\\star)$ is $A_1 + A_2$. Your program must output the absolute error in meters for this case as the first number.\n- Case B (destructive interference):\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$.\n  - The expected displacement at $(x_\\star, t_\\star)$ is $0.0$. Your program must output the absolute error in meters for this case as the second number.\n- Case C (energy check):\n  - $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$.\n  - Compute the relative energy change $|E(t_\\star)-E(0)|/E(0)$ at $t_\\star = (x_2 - x_1)/(2c)$ and return a boolean that is true if this value is strictly less than a tolerance of $0.02$ and false otherwise. This boolean must be the third output.\n\nImplementation requirements:\n- Use a second-order accurate explicit scheme in time and space, enforce $u(0,t)=0$ and $u(L,t)=0$ at all time steps, and initialize $u(x,0)$ as the sum of the two Gaussians. Derive and implement $v(x)=\\partial u/\\partial t(x,0)$ so that the first Gaussian travels rightward with speed $c$ and the second travels leftward with speed $c$.\n- Use a Courant number $\\lambda$ strictly less than $1$ for stability. Explicitly compute $\\Delta t$ from $\\lambda$, $c$, and $\\Delta x$.\n- Compute $E(0)$ using $v(x)$ and the spatial gradient of $u(x,0)$, and compute $E(t_\\star)$ using a consistent discrete approximation to $\\partial u/\\partial t$ and $\\partial u/\\partial x$ at $t_\\star$. Ensure that the simulated time span does not allow the packets to interact with the boundaries for any test case.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: Case A error (meters), Case B error (meters), Case C energy-conservation boolean. For example: \"[0.00012,0.00003,True]\". Do not print any other text.\n\nAssumptions and constraints:\n- Use $N_x$ sufficiently large that $x_\\star$ lies on or very near a grid point and the Gaussians are well resolved. You must ensure $\\lambda \\in (0,1)$ and that $t_\\star$ is reached by the time integration for each case.\n- All floating-point outputs are to be given as raw decimal numbers; do not append units in the printed output. Internally, all quantities must be handled with the physically correct units as specified above.", "solution": "We begin from Newton’s second law applied to a differential element of a taut uniform string. Let $\\mu$ be the linear mass density (mass per unit length) and $T$ the constant tension. For small transverse displacements $u(x,t)$, the vertical force due to tension is $T \\partial^2 u / \\partial x^2 \\, \\mathrm{d}x$, which equals the element’s mass $\\mu \\, \\mathrm{d}x$ times its vertical acceleration $\\partial^2 u / \\partial t^2$. Dividing by $\\mu \\, \\mathrm{d}x$ yields the standard wave equation\n$$\n\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}, \\quad c^2 = \\frac{T}{\\mu}.\n$$\nWe impose fixed ends $u(0,t)=0$ and $u(L,t)=0$, and choose initial conditions $u(x,0) = u_0(x)$ and $u_t(x,0)=v_0(x)$ to launch two oppositely traveling Gaussian wave packets.\n\nFinite-difference scheme:\nDiscretize space on a uniform grid $x_i = i \\Delta x$, $i=0,\\dots,N_x-1$ with $\\Delta x = L/(N_x-1)$, and time $t_n = n \\Delta t$, $n=0,1,2,\\dots$. Denote $u_i^n \\approx u(x_i,t_n)$. Use centered differences in space and time. The wave equation becomes\n$$\n\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2},\n$$\nor equivalently the explicit update\n$$\nu_i^{n+1} = 2 u_i^n - u_i^{n-1} + \\lambda^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n \\right), \\quad \\lambda = \\frac{c \\Delta t}{\\Delta x}.\n$$\nThe Courant–Friedrichs–Lewy (CFL) condition requires $0<\\lambda \\le 1$ for stability; we choose $\\lambda < 1$ strictly. Fixed ends are enforced by setting $u_0^n = 0$ and $u_{N_x-1}^n = 0$ for all $n$.\n\nInitialization:\nWe require $u_i^0 = u_0(x_i)$ and $u_i^1$ to start the recurrence. A second-order Taylor expansion in time gives\n$$\nu(x,t+\\Delta t) = u(x,t) + \\Delta t \\, u_t(x,t) + \\frac{\\Delta t^2}{2} \\, u_{tt}(x,t) + \\mathcal{O}(\\Delta t^3).\n$$\nUsing the wave equation $u_{tt} = c^2 u_{xx}$ and the centered spatial Laplacian, we obtain the second-order accurate first step\n$$\nu_i^1 = u_i^0 + \\Delta t \\, v_0(x_i) + \\frac{\\lambda^2}{2}\\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right),\n$$\nwith boundary enforcement $u_0^1 = u_{N_x-1}^1 = 0$.\n\nConstructing counter-propagating Gaussians:\nWe define two Gaussian profiles\n$$\nf(x) = A_1 \\exp\\!\\left(-\\frac{(x - x_1)^2}{2 \\sigma_1^2}\\right), \\quad\ng(x) = A_2 \\exp\\!\\left(-\\frac{(x - x_2)^2}{2 \\sigma_2^2}\\right),\n$$\nand set the initial displacement to their sum $u_0(x) = f(x) + g(x)$. To make $f$ propagate rightward at speed $c$ and $g$ propagate leftward at speed $c$, we use the d’Alembert decomposition derived from the wave equation’s linearity and invariance: $u(x,t) = F(x - c t) + G(x + c t)$, where $F$ and $G$ are determined by initial data. Matching to $u_0(x) = f(x) + g(x)$ gives $F(x) = f(x)$ and $G(x) = g(x)$. Differentiating in time at $t=0$ yields\n$$\nv_0(x) = \\left.\\frac{\\partial u}{\\partial t}\\right|_{t=0} = - c F'(x) + c G'(x) = - c f'(x) + c g'(x).\n$$\nFor the Gaussian derivative,\n$$\n\\frac{d}{dx}\\left[A \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right)\\right]\n= - A \\frac{x - x_0}{\\sigma^2} \\exp\\!\\left(-\\frac{(x - x_0)^2}{2 \\sigma^2}\\right).\n$$\nThus we construct $v_0(x) = - c f'(x) + c g'(x)$ explicitly from the above expression.\n\nCollision time and location:\nThe centers of $f$ and $g$ are at $x_f(t) = x_1 + c t$ and $x_g(t) = x_2 - c t$. They meet when $x_f(t_\\star) = x_g(t_\\star)$, giving $t_\\star = (x_2 - x_1)/(2 c)$ and $x_\\star = (x_1 + x_2)/2$. At $(x_\\star,t_\\star)$, the continuous solution evaluates to $u(x_\\star,t_\\star) = f(x_1) + g(x_2) = A_1 + A_2$, independent of $\\sigma_1$ and $\\sigma_2$. For destructive interference with $A_1 = -A_2$ and symmetric widths, the sum is $0$.\n\nEnergy and its discrete approximation:\nThe total energy is\n$$\nE(t) = \\int_0^L \\frac{1}{2}\\left[\\left(\\frac{\\partial u}{\\partial t}\\right)^2 + c^2 \\left(\\frac{\\partial u}{\\partial x}\\right)^2 \\right] dx,\n$$\nwhich is conserved for the continuous wave equation with fixed ends. Discretely, we approximate\n$$\nE^n \\approx \\sum_{i=0}^{N_x-1} \\frac{1}{2} \\left[ (v_i^n)^2 + c^2 (D_x u_i^n)^2 \\right] \\Delta x,\n$$\nwhere $D_x u_i^n$ is a centered spatial difference for interior points,\n$$\nD_x u_i^n = \\frac{u_{i+1}^n - u_{i-1}^n}{2 \\Delta x} \\quad \\text{for } 1 \\le i \\le N_x-2,\n$$\nwith one-sided differences at boundaries consistent with $u=0$. For $E^0$ we use $v_i^0 = v_0(x_i)$. For $E^n$ at later times, a centered time difference $v_i^n \\approx \\left(u_i^{n+1} - u_i^{n-1}\\right)/(2 \\Delta t)$ is second-order; in a two-level marching implementation, an accurate proxy is $v_i^{n} \\approx \\left(u_i^{n} - u_i^{n-1}\\right)/\\Delta t$ at the available time level, which suffices to monitor near-conservation over modest times before boundary interaction.\n\nAlgorithmic design:\n1. Choose $N_x$ large and $\\lambda = c \\Delta t / \\Delta x$ strictly less than $1$; compute $\\Delta t$ from $\\lambda$.\n2. Build the grid $x_i$ on $[0,L]$ and assemble $u_i^0$ from the two Gaussians. Compute $v_i^0 = -c f'(x_i) + c g'(x_i)$. Enforce $u_0^0=u_{N_x-1}^0=0$ and $v_0^0=v_{N_x-1}^0=0$.\n3. Compute $u_i^1$ using the Taylor-based first-step formula and enforce boundary values.\n4. March in time with the explicit update until just past $t_\\star$. Detect the step where $t$ crosses $t_\\star$ and linearly interpolate in time at the grid index nearest to $x_\\star$ to estimate $u(x_\\star,t_\\star)$.\n5. Compute $E(0)$ from $u^0$ and $v^0$. Compute $E(t_\\star)$ from the two most recent time levels and spatial gradients. Form the relative energy change.\n6. Repeat for the three test cases.\n\nTest suite and outputs:\n- Case A: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.020$, $\\sigma_1 = 0.050$, $\\sigma_2 = 0.050$, $x_1 = 0.300$, $x_2 = 0.700$. Compute the absolute error $|u(x_\\star,t_\\star) - (A_1 + A_2)|$ in meters.\n- Case B: $L = 1.0$, $c = 1.0$, $A_1 = 0.015$, $A_2 = -0.015$, $\\sigma_1 = 0.040$, $\\sigma_2 = 0.040$, $x_1 = 0.350$, $x_2 = 0.650$. Compute the absolute error $|u(x_\\star,t_\\star) - 0.0|$ in meters.\n- Case C: $L = 1.0$, $c = 1.0$, $A_1 = 0.010$, $A_2 = 0.013$, $\\sigma_1 = 0.030$, $\\sigma_2 = 0.070$, $x_1 = 0.250$, $x_2 = 0.750$. Compute the boolean that is true if $|E(t_\\star)-E(0)|/E(0) < 0.02$ and false otherwise.\n\nThe program outputs one line: a list with the Case A error (meters), the Case B error (meters), and the Case C boolean, in that order, formatted as a comma-separated list in square brackets with no extra text. The chosen grid and time step ensure that the wave packets do not reach the boundaries before $t_\\star$, making interference and energy diagnostics meaningful and boundary-reflection-free within the simulated window.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef gaussian(x, A, x0, sigma):\n    return A * np.exp(-0.5 * ((x - x0) / sigma) ** 2)\n\ndef gaussian_derivative(x, A, x0, sigma):\n    # d/dx of Gaussian profile\n    return gaussian(x, A, x0, sigma) * (-(x - x0) / (sigma ** 2))\n\ndef discrete_energy(u, v, c, dx):\n    # Spatial derivative with centered differences (one-sided at boundaries)\n    du_dx = np.empty_like(u)\n    du_dx[0] = (u[1] - u[0]) / dx\n    du_dx[-1] = (u[-1] - u[-2]) / dx\n    du_dx[1:-1] = (u[2:] - u[:-2]) / (2.0 * dx)\n    energy_density = 0.5 * (v ** 2 + (c ** 2) * (du_dx ** 2))\n    return np.sum(energy_density) * dx\n\ndef simulate_case(L, c, A1, A2, sigma1, sigma2, x1, x2, Nx=2001, CFL=0.9):\n    # Grid setup\n    x = np.linspace(0.0, L, Nx)\n    dx = x[1] - x[0]\n    dt = CFL * dx / c\n    lam2 = (c * dt / dx) ** 2\n\n    # Initial conditions u0 and v0 to produce right- and left-moving Gaussians\n    f = gaussian(x, A1, x1, sigma1)  # right-moving\n    g = gaussian(x, A2, x2, sigma2)  # left-moving\n    u0 = f + g\n    v0 = -c * gaussian_derivative(x, A1, x1, sigma1) + c * gaussian_derivative(x, A2, x2, sigma2)\n\n    # Enforce fixed ends\n    u0[0] = 0.0\n    u0[-1] = 0.0\n    v0[0] = 0.0\n    v0[-1] = 0.0\n\n    # First time step (second-order accurate)\n    u1 = np.empty_like(u0)\n    u1[1:-1] = u0[1:-1] + dt * v0[1:-1] + 0.5 * lam2 * (u0[2:] - 2.0 * u0[1:-1] + u0[:-2])\n    u1[0] = 0.0\n    u1[-1] = 0.0\n\n    # Collision time and location\n    t_star = (x2 - x1) / (2.0 * c)\n    x_star = 0.5 * (x1 + x2)\n    # Index nearest to x_star\n    i_star = int(np.round((x_star - x[0]) / dx))\n    i_star = max(0, min(Nx - 1, i_star))\n\n    # Energy at t=0\n    E0 = discrete_energy(u0, v0, c, dx)\n\n    # Time march until just past t_star\n    t_prev = 0.0\n    t_curr = dt\n    u_prev = u0.copy()\n    u_curr = u1.copy()\n\n    u_at_tstar = None\n\n    # If t_star is before dt (unlikely with these parameters), handle interpolation from u0 and u1\n    if t_prev = t_star = t_curr:\n        alpha = (t_star - t_prev) / (t_curr - t_prev)\n        u_at_tstar = (1.0 - alpha) * u_prev[i_star] + alpha * u_curr[i_star]\n\n    # March forward\n    # Target to go slightly beyond t_star\n    t_end = t_star + 2.0 * dt\n    n_steps = int(np.ceil((t_end - t_curr) / dt))\n    for _ in range(n_steps):\n        u_next = np.empty_like(u_curr)\n        # Interior update\n        u_next[1:-1] = (2.0 * u_curr[1:-1] - u_prev[1:-1] +\n                        lam2 * (u_curr[2:] - 2.0 * u_curr[1:-1] + u_curr[:-2]))\n        # Fixed ends\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Advance times\n        t_next = t_curr + dt\n\n        # Capture u at t_star by temporal interpolation when crossed\n        if u_at_tstar is None and (t_curr = t_star = t_next):\n            alpha = (t_star - t_curr) / (t_next - t_curr)\n            u_at_tstar = (1.0 - alpha) * u_curr[i_star] + alpha * u_next[i_star]\n\n        # Shift\n        u_prev, u_curr = u_curr, u_next\n        t_prev, t_curr = t_curr, t_next\n\n    # Safety: if u_at_tstar still None due to rounding, take nearest\n    if u_at_tstar is None:\n        u_at_tstar = u_curr[i_star]\n\n    # Approximate velocity at final time level for energy at t_star\n    v_end = (u_curr - u_prev) / dt\n    E_end = discrete_energy(u_curr, v_end, c, dx)\n\n    return u_at_tstar, E0, E_end\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: constructive interference\n    case_A = dict(L=1.0, c=1.0, A1=0.010, A2=0.020, sigma1=0.050, sigma2=0.050, x1=0.300, x2=0.700)\n    # Case B: destructive interference\n    case_B = dict(L=1.0, c=1.0, A1=0.015, A2=-0.015, sigma1=0.040, sigma2=0.040, x1=0.350, x2=0.650)\n    # Case C: energy check\n    case_C = dict(L=1.0, c=1.0, A1=0.010, A2=0.013, sigma1=0.030, sigma2=0.070, x1=0.250, x2=0.750)\n\n    # Common numerical parameters\n    Nx = 2001\n    CFL = 0.9\n\n    # Run simulations\n    uA_at_star, EA0, EAend = simulate_case(Nx=Nx, CFL=CFL, **case_A)\n    uB_at_star, EB0, EBend = simulate_case(Nx=Nx, CFL=CFL, **case_B)\n    uC_at_star, EC0, ECend = simulate_case(Nx=Nx, CFL=CFL, **case_C)\n\n    # Expected values at collision\n    expected_A = case_A[\"A1\"] + case_A[\"A2\"]  # constructive\n    expected_B = 0.0  # destructive\n\n    err_A = abs(uA_at_star - expected_A)  # meters\n    err_B = abs(uB_at_star - expected_B)  # meters\n\n    rel_energy_change_C = abs(ECend - EC0) / EC0 if EC0 != 0.0 else float('inf')\n    energy_ok_C = bool(rel_energy_change_C  0.02)\n\n    results = [err_A, err_B, energy_ok_C]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2438583"}, {"introduction": "Building on the basic solver, this practice introduces the challenge of a non-uniform medium, where the wave speed $c(x,t)$ varies in space and time. You will adapt your numerical scheme to solve the wave equation in a conservative form, a crucial technique for ensuring physical accuracy in complex systems [@problem_id:2438557]. This thought experiment, involving a hypothetical 'light-sensitive' string, provides a tangible framework for modeling wave propagation in any inhomogeneous material.", "problem": "You are asked to model a one-dimensional vibrating string whose local wave speed is modulated by light. The transverse displacement field is denoted by $u(x,t)$ on a spatial domain $x \\in [0,L]$ with fixed ends. Starting from Newton's second law and the definition of local wave speed $c(x,t)$, derive a conservative, second-order accurate finite difference scheme in space and time for the partial differential equation\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big),\n$$\nwith homogeneous Dirichlet boundary conditions $u(0,t)=u(L,t)=0$ and given initial data $u(x,0)=u_0(x)$, $u_t(x,0)=v_0(x)$. The light-sensitive wave speed is specified by\n$$\nc(x,t) \\;=\\; c_0\\,\\sqrt{\\,1 - \\beta\\,I(x,t)\\,},\\quad\nI(x,t) \\;=\\; \\exp\\!\\left(-\\dfrac{(x - x_s(t))^2}{2\\sigma^2}\\right),\\quad\nx_s(t) \\;=\\; x_{\\text{start}} + v_s\\,t,\n$$\nwhere $c_0$ is the baseline wave speed in $\\mathrm{m/s}$, $0 \\le \\beta  1$ is the light sensitivity coefficient (dimensionless), $\\sigma$ is the spotlight width in $\\mathrm{m}$, and $v_s$ is the spotlight speed in $\\mathrm{m/s}$. You may assume all parameters are such that $c(x,t)$ remains real and strictly positive for all $x$ and $t$ of interest.\n\nYour tasks are:\n1) From the balance of forces on a small string element and the definition $c^2(x,t) = T(x,t)/\\rho$, where $T(x,t)$ is the local tension and $\\rho$ is the mass density per unit length, show that the governing equation above follows in the small-slope limit when light modulates tension as $T(x,t)=\\rho\\,c^2(x,t)$ with $c(x,t)$ as given.\n\n2) Discretize the equation on a uniform grid $x_i = i\\,\\Delta x$ for $i=0,1,\\dots,N-1$ with $\\Delta x = L/(N-1)$ and uniform time steps $t^n = n\\,\\Delta t$ for $n=0,1,2,\\dots$. Use centered differences in space on the flux $\\partial_x\\!\\big(c^2 u_x\\big)$ with half-node coefficients and centered differences in time for $u_{tt}$. That is, approximate\n$$\n\\big(c^2 u_x\\big)_x\\Big|_{x=x_i,\\,t=t^{n+\\tfrac{1}{2}}} \\;\\approx\\; \\dfrac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\nwhere $a^{n+\\tfrac{1}{2}}_{i\\pm \\tfrac{1}{2}}$ approximates $c^2\\!\\left(x_{i\\pm \\tfrac{1}{2}},t^{n+\\tfrac{1}{2}}\\right)$ using arithmetic averages of nodal values of $a=c^2$. Derive the explicit update for $u^{n+1}_i$ at interior nodes $i=1,\\dots,N-2$, and a consistent second-order start-up formula for $u^1_i$ that uses $u^0_i$, $v^0_i$ and the spatial operator evaluated at $t^{\\tfrac{1}{2}}$.\n\n3) State a sufficient Courant–Friedrichs–Lewy (CFL) condition for stability in terms of $\\Delta t$, $\\Delta x$, and the maximum wave speed. Use it to choose $\\Delta t$ via $\\Delta t = C_{\\mathrm{CFL}}\\,\\Delta x/\\max_{x,t} c(x,t)$ with $0  C_{\\mathrm{CFL}} \\le 1$. For this problem, you must take $C_{\\mathrm{CFL}} = 0.9$ and note that $\\max_{x,t} c(x,t) = c_0$ for the given model.\n\n4) Implement the explicit scheme in a program that runs three specified test cases. Use fixed-end boundary conditions $u_0^n = u_{N-1}^n = 0$ for all $n$. The required observables and units are specified below.\n\nImplementation details and physical units:\n- All lengths must be in $\\mathrm{m}$, time in $\\mathrm{s}$, and wave speed in $\\mathrm{m/s}$. Report displacements in $\\mathrm{m}$ and frequency in $\\mathrm{Hz}$.\n- Angles, if used, must be in radians.\n- The final program must produce a single line of output containing a Python-style list with three floating-point numbers in the order of the test cases, each rounded to six decimal places.\n\nTest suite (each test set must be simulated independently with the provided parameters):\n- Test $1$ (happy path; moving spotlight, Gaussian initial bump):\n  - $L = 1.0\\,\\mathrm{m}$, $c_0 = 100.0\\,\\mathrm{m/s}$, $\\beta = 0.3$, $\\sigma = 0.05\\,\\mathrm{m}$, $v_s = 2.0\\,\\mathrm{m/s}$, $x_{\\text{start}} = 0.0\\,\\mathrm{m}$.\n  - Grid: $N = 401$ points, so $\\Delta x = L/(N-1)$.\n  - Time step: $\\Delta t = 0.9\\,\\Delta x/c_0$.\n  - Final time: $T_{\\text{end}} = 0.015\\,\\mathrm{s}$.\n  - Initial conditions: $u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$ with $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$, $x_c = 0.25\\,L$, $w = 0.02\\,\\mathrm{m}$, and $v_0(x)=0$.\n  - Output: the final-time spatial $\\mathrm{L}^2$ norm of the displacement, defined by $\\|u(\\cdot,T_{\\text{end}})\\|_2 = \\left(\\sum_{i=0}^{N-1} u_i^2(T_{\\text{end}})\\,\\Delta x\\right)^{1/2}$ in $\\mathrm{m}$.\n\n- Test $2$ (boundary-interaction edge case; spotlight present, bump near boundary):\n  - $L = 1.0\\,\\mathrm{m}$, $c_0 = 100.0\\,\\mathrm{m/s}$, $\\beta = 0.5$, $\\sigma = 0.03\\,\\mathrm{m}$, $v_s = 3.0\\,\\mathrm{m/s}$, $x_{\\text{start}} = 0.0\\,\\mathrm{m}$.\n  - Grid: $N = 401$.\n  - Time step: $\\Delta t = 0.9\\,\\Delta x/c_0$.\n  - Final time: $T_{\\text{end}} = 0.010\\,\\mathrm{s}$.\n  - Initial conditions: $u_0(x) = A\\,\\exp\\!\\left(-\\dfrac{(x-x_c)^2}{2w^2}\\right)$ with $A = 1.0\\times 10^{-3}\\,\\mathrm{m}$, $x_c = 0.02\\,\\mathrm{m}$, $w = 0.01\\,\\mathrm{m}$, and $v_0(x)=0$.\n  - Output: the maximum absolute displacement observed anywhere on the string over the entire simulation interval, $\\max_{0\\le n \\le T_{\\text{end}}/\\Delta t}\\max_{0\\le i \\le N-1} |u_i^n|$, in $\\mathrm{m}$.\n\n- Test $3$ (consistency check; no spotlight, first normal mode and frequency extraction):\n  - $L = 1.0\\,\\mathrm{m}$, $c_0 = 100.0\\,\\mathrm{m/s}$, $\\beta = 0.0$ (so $c(x,t)\\equiv c_0$), $\\sigma$ and $v_s$ arbitrary and unused.\n  - Grid: $N = 601$.\n  - Time step: $\\Delta t = 0.9\\,\\Delta x/c_0$.\n  - Final time: $T_{\\text{end}} = 0.100\\,\\mathrm{s}$.\n  - Initial conditions: $u_0(x) = A\\,\\sin\\!\\left(\\dfrac{\\pi x}{L}\\right)$ with $A=1.0\\times 10^{-3}\\,\\mathrm{m}$ and $v_0(x)=0$.\n  - Track $u$ at the antinode $x=L/2$ over time, estimate the dominant oscillation frequency by detecting zero crossings and linearly interpolating crossing times to estimate the average period. The theoretical first-mode frequency is $f_1 = c_0/(2L)$ in $\\mathrm{Hz}$.\n  - Output: the absolute error $|f_{\\text{num}} - f_1|$ in $\\mathrm{Hz}$.\n\nFinal output format:\n- Your program should produce a single line of output containing a Python list with three numbers corresponding to Tests $1$, $2$, and $3$ in that order, rounded to six decimal places, for example: `[0.001234,0.001345,0.000120]`.", "solution": "The problem proposed is a standard, well-posed initial-boundary value problem from computational physics. It is scientifically sound, mathematically consistent, and all parameters and conditions required for a unique, stable numerical solution are provided. The problem is therefore deemed **valid**, and a solution will be provided.\n\nThe primary task is to derive and implement a finite difference scheme for the one-dimensional wave equation with a variable coefficient, given by\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\!\\big(c^2(x,t)\\,u_x(x,t)\\big)\n$$\nwhere $u(x,t)$ is the transverse displacement of a string, and $c(x,t)$ is the non-uniform, time-dependent wave speed.\n\n**1. Derivation of the Governing Equation**\n\nWe begin from Newton's second law applied to an infinitesimal element of the string of length $\\Delta s$ between horizontal positions $x$ and $x+\\Delta x$. Let $\\rho$ be the constant linear mass density. The mass of the element is $\\Delta m = \\rho \\Delta s$. For small displacements, the slope $u_x = \\partial u/\\partial x$ is small, so the element length is approximately its horizontal projection, $\\Delta s \\approx \\Delta x$. The mass is then $\\Delta m \\approx \\rho \\Delta x$.\n\nThe net vertical force on the element is the difference in the vertical components of the tension force $T(x,t)$ acting at its ends. The vertical component of tension at a point is $T \\sin\\theta$, where $\\theta$ is the angle of the string with the horizontal. In the small-slope approximation, $\\sin\\theta \\approx \\tan\\theta = u_x$.\nThe net vertical force $\\Delta F_v$ is therefore\n$$\n\\Delta F_v \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\nAccording to Newton's second law, $F=ma$, the net force equals mass times acceleration, where the acceleration is the second partial derivative of displacement with respect to time, $u_{tt}$.\n$$\n(\\rho \\Delta x)\\, u_{tt}(x,t) \\;=\\; T(x+\\Delta x, t)\\,u_x(x+\\Delta x, t) - T(x,t)\\,u_x(x,t).\n$$\nDividing by $\\Delta x$ and taking the limit as $\\Delta x \\to 0$ gives the definition of the partial derivative with respect to $x$:\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( T(x,t)\\,u_x(x,t) \\big).\n$$\nThe problem states that the wave speed squared is defined by $c^2(x,t) = T(x,t)/\\rho$, implying the tension is modulated as $T(x,t) = \\rho\\,c^2(x,t)$. Substituting this into the equation of motion yields\n$$\n\\rho\\,u_{tt}(x,t) \\;=\\; \\partial_x \\big( \\rho\\,c^2(x,t)\\,u_x(x,t) \\big).\n$$\nSince $\\rho$ is a constant, it can be factored out of the spatial derivative and canceled from both sides, which results in the specified governing equation:\n$$\nu_{tt}(x,t) \\;=\\; \\partial_x\\big(c^2(x,t)\\,u_x(x,t)\\big).\n$$\nThis completes the derivation. The form of the equation is conservative because the spatial part is the divergence of a flux, in this case the flux of transverse momentum.\n\n**2. Derivation of the Finite Difference Scheme**\n\nWe discretize the domain with a uniform spatial grid $x_i = i\\,\\Delta x$ for $i=0, 1, \\dots, N-1$, where $\\Delta x = L/(N-1)$, and uniform time steps $t^n = n\\,\\Delta t$. The displacement is denoted by $u_i^n \\approx u(x_i, t^n)$.\n\nThe second time derivative $u_{tt}$ at $(x_i, t^n)$ is approximated using a second-order accurate centered difference:\n$$\nu_{tt}(x_i, t^n) \\;\\approx\\; \\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2}.\n$$\nThe spatial operator $\\partial_x(c^2 u_x)$ is discretized as specified in the problem statement. This is a second-order accurate centered difference scheme for a flux term. Let $a(x,t) = c^2(x,t)$. The flux is $F(x,t) = a(x,t)u_x(x,t)$. We have $\\partial_x F \\approx (F_{i+1/2} - F_{i-1/2})/\\Delta x$. The fluxes at half-grid points are approximated as $F_{i\\pm 1/2} \\approx a_{i\\pm 1/2} (u_{i\\pm 1} - u_i)/\\Delta x$. This results in the specified form, which we denote $\\mathcal{L}[u]$. The problem requires evaluating the coefficients $a = c^2$ at the half-time step $t^{n+1/2}$, while using the displacement $u$ at time $t^n$. The full discrete equation is:\n$$\n\\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{\\Delta t^2} \\;=\\; \\frac{1}{\\Delta x^2}\\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}\\,(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}\\,(u^n_i-u^n_{i-1})\\right],\n$$\nwhere the coefficients at half-nodes are arithmetic averages of the nodal values:\n$$\na^{n+\\tfrac{1}{2}}_{i\\pm\\tfrac{1}{2}} \\;=\\; \\frac{1}{2}\\left( a(x_i, t^{n+\\tfrac{1}{2}}) + a(x_{i\\pm 1}, t^{n+\\tfrac{1}{2}}) \\right).\n$$\nThis scheme is explicit. Solving for $u_i^{n+1}$ gives the update rule for interior nodes ($i=1, \\dots, N-2$):\n$$\nu_i^{n+1} \\;=\\; 2u_i^n - u_i^{n-1} + \\left(\\frac{\\Delta t}{\\Delta x}\\right)^2 \\left[a^{n+\\tfrac{1}{2}}_{i+\\tfrac{1}{2}}(u^n_{i+1}-u^n_i)-a^{n+\\tfrac{1}{2}}_{i-\\tfrac{1}{2}}(u^n_i-u^n_{i-1})\\right].\n$$\nThe boundary conditions are $u_0^n = 0$ and $u_{N-1}^n = 0$ for all $n \\ge 0$.\n\nFor the first time step ($n=0$), we need $u^1_i$. The general update requires $u^{-1}_i$, which is not given. We use the initial velocity $v_0(x) = u_t(x,0)$ and a centered difference approximation at $t=0$:\n$$\nv_i^0 \\;\\approx\\; \\frac{u_i^1 - u_i^{-1}}{2\\Delta t} \\quad\\implies\\quad u_i^{-1} \\;=\\; u_i^1 - 2\\Delta t v_i^0.\n$$\nSubstituting this into the update rule for $n=0$ gives:\n$$\nu_i^1 \\;=\\; 2u_i^0 - (u_i^1 - 2\\Delta t v_i^0) + \\Delta t^2 \\mathcal{L}^{1/2}[u^0]_i,\n$$\nwhere $\\mathcal{L}^{1/2}[u^0]_i$ is the spatial operator with coefficients evaluated at $t^{1/2}=\\Delta t/2$ and applied to $u^0$. Solving for $u_i^1$ yields the second-order accurate start-up formula:\n$$\nu_i^1 \\;=\\; u_i^0 + \\Delta t v_i^0 + \\frac{\\Delta t^2}{2} \\mathcal{L}^{1/2}[u^0]_i.\n$$\nThis formula is consistent with the problem's requirements.\n\n**3. Stability Condition**\n\nFor an explicit finite difference scheme for the wave equation, stability is governed by the Courant–Friedrichs–Lewy (CFL) condition. For a variable wave speed $c(x,t)$, a sufficient condition for stability is that the numerical domain of dependence must contain the physical domain of dependence. This leads to the requirement:\n$$\nC_{\\text{CFL}} \\;=\\; \\frac{\\max_{x,t} c(x,t) \\cdot \\Delta t}{\\Delta x} \\;\\le\\; 1.\n$$\nThe wave speed is given by $c(x,t) = c_0\\sqrt{1 - \\beta I(x,t)}$. Since $0 \\le \\beta  1$ and the intensity term $I(x,t) = \\exp(\\dots)$ is non-negative, the maximum value of $c(x,t)$ occurs where $I(x,t)$ is minimum. The minimum value of $I(x,t)$ is $0$, which occurs as $|x-x_s(t)| \\to \\infty$. Thus, $\\max_{x,t} c(x,t) = c_0$.\nThe stability condition simplifies to $c_0 \\Delta t / \\Delta x \\le 1$. The problem specifies choosing the time step as\n$$\n\\Delta t = 0.9 \\frac{\\Delta x}{c_0},\n$$\nwhich corresponds to a Courant number $C_{\\text{CFL}} = 0.9$. Since $0.9 \\le 1$, the scheme is stable under this choice.\n\n**4. Implementation Strategy**\n\nThe numerical scheme is implemented in Python using the `numpy` library for efficient array operations.\n- The simulation state is maintained by three arrays: `u_prev` ($u^{n-1}$), `u_curr` ($u^n$), and `u_next` ($u^{n+1}$).\n- The simulation starts by initializing `u_curr` from the initial condition $u_0(x)$ and applying boundary conditions.\n- The first time step computes $u^1$ using the derived start-up formula, which is a special case since the initial velocity $v_0(x)=0$ for all test cases.\n- The main loop then iterates from $n=1$ to the final time step. In each iteration, it computes $u^{n+1}$ from $u^n$ and $u^{n-1}$ using the general update rule.\n- In each step, the time-dependent coefficients $a(x, t^{n+1/2})$ are calculated first, followed by the averaged half-node coefficients. The spatial operator is then computed using vectorized `numpy` operations on the interior grid points.\n- Boundary conditions $u_0=0, u_{N-1}=0$ are enforced after each update.\n- The required observables for each test case are computed:\n  - **Test 1:** The final spatial $\\mathrm{L}^2$ norm, $\\|u(\\cdot, T_{\\text{end}})\\|_2 = \\left(\\sum_i (u_i^{\\text{final}})^2 \\Delta x\\right)^{1/2}$, is computed after the loop finishes.\n  - **Test 2:** The maximum absolute displacement, $\\max_{n,i}|u_i^n|$, is updated within the loop at each time step.\n  - **Test 3:** The displacement at the string's midpoint, $u(L/2, t)$, is recorded. After the simulation, these time series data are processed to detect zero-crossings via sign changes. Linear interpolation is used to estimate the precise time of each crossing. The average time difference between crossings gives the half-period, from which the numerical frequency $f_{\\text{num}}$ is calculated. The final result is the absolute error $|f_{\\text{num}} - f_1|$, where $f_1 = c_0/(2L)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that runs three test cases for the vibrating string simulation.\n    \"\"\"\n\n    def run_simulation(L, c0, beta, sigma, vs, x_start, N, T_end, u0_func, v0_func, C_CFL=0.9):\n        \"\"\"\n        Generic simulation engine for the 1D wave equation with variable coefficients.\n        \"\"\"\n        dx = L / (N - 1)\n        x = np.linspace(0, L, N)\n        \n        c_max = c0\n        dt = C_CFL * dx / c_max\n        \n        num_steps = int(np.ceil(T_end / dt))\n        \n        def x_s(t):\n            \"\"\"Calculates the center of the moving spotlight at a given time.\"\"\"\n            return x_start + vs * t\n\n        def I(x_nodes, t):\n            \"\"\"Calculates the light intensity profile on the grid at a given time.\"\"\"\n            return np.exp(-(x_nodes - x_s(t))**2 / (2 * sigma**2))\n\n        def a(x_nodes, t):\n            \"\"\"Calculates the square of the wave speed, c^2, on the grid.\"\"\"\n            if beta == 0:\n                return np.full_like(x_nodes, c0**2)\n            return c0**2 * (1 - beta * I(x_nodes, t))\n\n        # Initialize displacement fields\n        u_prev = np.zeros(N)\n        u_curr = u0_func(x)\n        u_next = np.zeros(N)\n        v0 = v0_func(x)\n        \n        # Apply boundary conditions to initial state\n        u_curr[0] = 0\n        u_curr[-1] = 0\n\n        # Storage for observables\n        max_abs_u = np.max(np.abs(u_curr))\n        u_mid_history = []\n        time_history = []\n        mid_point_idx = (N - 1) // 2\n\n        # First step (n=0 to n=1) using the second-order start-up formula\n        t_half = 0.5 * dt\n        a_vals_t_half = a(x, t_half)\n        \n        a_half_p = 0.5 * (a_vals_t_half[1:-1] + a_vals_t_half[2:])\n        a_half_m = 0.5 * (a_vals_t_half[:-2] + a_vals_t_half[1:-1])\n\n        spatial_op_u0 = (a_half_p * (u_curr[2:] - u_curr[1:-1]) - \n                         a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n        \n        u_next[1:-1] = (u_curr[1:-1] + dt * v0[1:-1] + \n                        0.5 * (dt / dx)**2 * spatial_op_u0)\n\n        # Update state variables for the main loop\n        u_prev[:] = u_curr\n        u_curr[:] = u_next\n        \n        # Update observables after first step\n        max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n        if beta == 0.0:  # For Test 3\n            u_mid_history.append(u_curr[mid_point_idx])\n            time_history.append(dt)\n        \n        # Main time-stepping loop (n=1, 2, ..., num_steps-1)\n        for n in range(1, num_steps):\n            t_n_plus_half = (n + 0.5) * dt\n            \n            a_vals_n_plus_half = a(x, t_n_plus_half)\n            \n            a_half_p = 0.5 * (a_vals_n_plus_half[1:-1] + a_vals_n_plus_half[2:])\n            a_half_m = 0.5 * (a_vals_n_plus_half[:-2] + a_vals_n_plus_half[1:-1])\n\n            spatial_op_un = (a_half_p * (u_curr[2:] - u_curr[1:-1]) -\n                             a_half_m * (u_curr[1:-1] - u_curr[:-2]))\n            \n            u_next[1:-1] = (2 * u_curr[1:-1] - u_prev[1:-1] + \n                            (dt / dx)**2 * spatial_op_un)\n            \n            u_prev[:] = u_curr\n            u_curr[:] = u_next\n            \n            max_abs_u = max(max_abs_u, np.max(np.abs(u_curr)))\n            if beta == 0.0:\n                u_mid_history.append(u_curr[mid_point_idx])\n                time_history.append((n + 1) * dt)\n\n        return u_curr, dx, max_abs_u, u_mid_history, time_history\n\n    # --- Test Case 1 ---\n    L1, c0_1, beta1, sigma1, vs1, x_start1 = 1.0, 100.0, 0.3, 0.05, 2.0, 0.0\n    N1, T_end1 = 401, 0.015\n    A1, xc1, w1 = 1.0e-3, 0.25 * L1, 0.02\n    u0_1 = lambda x: A1 * np.exp(-(x - xc1)**2 / (2 * w1**2))\n    v0_1 = lambda x: np.zeros_like(x)\n    u_final1, dx1, _, _, _ = run_simulation(L1, c0_1, beta1, sigma1, vs1, x_start1, N1, T_end1, u0_1, v0_1)\n    l2_norm = np.sqrt(np.sum(u_final1**2) * dx1)\n    result1 = round(l2_norm, 6)\n\n    # --- Test Case 2 ---\n    L2, c0_2, beta2, sigma2, vs2, x_start2 = 1.0, 100.0, 0.5, 0.03, 3.0, 0.0\n    N2, T_end2 = 401, 0.010\n    A2, xc2, w2 = 1.0e-3, 0.02, 0.01\n    u0_2 = lambda x: A2 * np.exp(-(x - xc2)**2 / (2 * w2**2))\n    v0_2 = lambda x: np.zeros_like(x)\n    _, _, max_u, _, _ = run_simulation(L2, c0_2, beta2, sigma2, vs2, x_start2, N2, T_end2, u0_2, v0_2)\n    result2 = round(max_u, 6)\n\n    # --- Test Case 3 ---\n    L3, c0_3, beta3, N3, T_end3, A3 = 1.0, 100.0, 0.0, 601, 0.100, 1.0e-3\n    u0_3 = lambda x: A3 * np.sin(np.pi * x / L3)\n    v0_3 = lambda x: np.zeros_like(x)\n    _, _, _, u_mid, t_hist = run_simulation(L3, c0_3, beta3, 1.0, 0.0, 0.0, N3, T_end3, u0_3, v0_3)\n    \n    u_mid = np.array(u_mid)\n    t_hist = np.array(t_hist)\n    \n    # Find zero crossings by detecting sign changes\n    crossings_indices = np.where(np.diff(np.sign(u_mid)))[0]\n    \n    crossing_times = []\n    for idx in crossings_indices:\n        t1, t2 = t_hist[idx], t_hist[idx+1]\n        u1, u2 = u_mid[idx], u_mid[idx+1]\n        # Linear interpolation to find precise time of zero crossing\n        if u2 - u1 != 0:\n            t_cross = t1 - u1 * (t2 - t1) / (u2 - u1)\n            crossing_times.append(t_cross)\n            \n    if len(crossing_times)  2:\n        f_num = np.nan\n    else:\n        half_periods = np.diff(crossing_times)\n        avg_period = 2 * np.mean(half_periods)\n        f_num = 1 / avg_period\n        \n    f_theory = c0_3 / (2 * L3)\n    abs_error = abs(f_num - f_theory)\n    result3 = round(abs_error, 6)\n    \n    results = [f\"{result1:.6f}\", f\"{result2:.6f}\", f\"{result3:.6f}\"]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2438557"}, {"introduction": "Our final practice takes a significant step towards realism by modeling the string's interaction with a thermal environment. You will implement a Langevin model, which extends the wave equation to include both damping and a stochastic force, representing the random kicks from a heat bath at temperature $\\Theta$ [@problem_id:2438534]. This exercise provides a hands-on introduction to stochastic partial differential equations and the profound connection between dissipation and fluctuation in physical systems.", "problem": "You are asked to formulate and simulate a one-dimensional stochastic model of a taut string undergoing small transverse vibrations with thermal fluctuations. Starting from Newton’s Second Law applied to a differential element of the string and the definition of transverse displacement, derive a continuum model that includes a linear damping force and a random fluctuating (Langevin) force representing a thermal bath. The model must be specified for transverse displacement $y(x,t)$ on a domain $x \\in [0,L]$ with fixed ends. The damping must be linear in the local transverse velocity, and the random force must be a zero-mean Gaussian white noise that is consistent with thermal equilibrium at absolute temperature $\\Theta$ as prescribed by the fluctuation-dissipation principle. You must then discretize the model in space and time using a stable explicit scheme subject to a Courant–Friedrichs–Lewy condition, and implement a program to compute a physically meaningful observable.\n\nYour simulation must adhere to the following foundational and modeling specifications:\n\n- Start from the fundamental balance of transverse forces on a string element of length $\\mathrm{d}x$ with linear mass density $\\mu$ and tension $\\mathcal{T}$, using small-amplitude approximations justified by linearizing the geometry.\n- Include a linear damping force per unit length proportional to $-\\mu \\gamma \\,\\partial y/\\partial t$, where $\\gamma$ has units $\\mathrm{s}^{-1}$.\n- Introduce a random fluctuating force per unit length with zero mean and delta-correlated statistics in space and time. Its amplitude must be chosen so that the long-time stationary state of the discretized system is consistent with thermal equilibrium at absolute temperature $\\Theta$ according to the fluctuation-dissipation principle. Do not assume any pre-given formula for the amplitude; derive it from first principles.\n- Impose fixed-end boundary conditions $y(0,t) = 0$ and $y(L,t) = 0$ for all $t \\ge 0$.\n- Define the wave speed $c$ via $c^2 = \\mathcal{T}/\\mu$. Choose the time step $\\Delta t$ to satisfy the Courant–Friedrichs–Lewy condition $\\Delta t \\le \\mathrm{CFL} \\cdot \\Delta x / c$ for a specified Courant factor $\\mathrm{CFL} \\in (0,1]$, where $\\Delta x$ is the uniform spatial grid spacing.\n- Compute the total mechanical energy\n$$\nE(t) \\;=\\; \\int_{0}^{L} \\left( \\tfrac{1}{2}\\,\\mu \\left(\\tfrac{\\partial y}{\\partial t}\\right)^{2} \\;+\\; \\tfrac{1}{2}\\,\\mathcal{T}\\,\\left(\\tfrac{\\partial y}{\\partial x}\\right)^{2} \\right)\\,\\mathrm{d}x\n$$\nand report the time average of $E(t)$ over the last $20\\%$ of the simulated time interval. The averaging operation must be implemented numerically using your discrete solution and must be expressed in Joules.\n\nDiscretization and numerical requirements:\n\n- Use a uniform grid with $N$ points including the endpoints, so that $\\Delta x = L/(N-1)$.\n- Use an explicit, stable, finite-difference time-stepping method of your choice consistent with the stochastic differential equation interpretation. Ensure that the random forcing is implemented with the correct units and scaling with respect to $\\Delta t$ and $\\Delta x$ so that the discretized system reproduces the correct thermal equilibrium in the long-time limit. Angles do not appear; no angle unit is needed.\n- Use the Boltzmann constant $k_{\\mathrm{B}}$ with value $k_{\\mathrm{B}} = 1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$.\n\nTest suite:\n\nImplement your program to run the following test cases, each fully specified and mutually independent. All inputs are in the International System of Units (SI). When a random number generator is needed, set it to a fixed seed to ensure deterministic output.\n\n- Test $1$ (thermalized, moderate damping, safe stability):\n  - $L = 1.0\\,\\mathrm{m}$, $\\mu = 0.01\\,\\mathrm{kg/m}$, $\\mathcal{T} = 100\\,\\mathrm{N}$, $\\gamma = 10\\,\\mathrm{s}^{-1}$, $\\Theta = 300\\,\\mathrm{K}$.\n  - $N = 101$, final time $t_{\\mathrm{f}} = 0.2\\,\\mathrm{s}$, Courant factor $\\mathrm{CFL} = 0.9$.\n  - Initial condition: $y(x,0) = 0$ and $\\partial y/\\partial t (x,0) = 0$ for all $x$.\n  - Random seed: $314159$.\n\n- Test $2$ (no thermal noise, damped decay from a pluck):\n  - $L = 1.0\\,\\mathrm{m}$, $\\mu = 0.01\\,\\mathrm{kg/m}$, $\\mathcal{T} = 100\\,\\mathrm{N}$, $\\gamma = 10\\,\\mathrm{s}^{-1}$, $\\Theta = 0\\,\\mathrm{K}$.\n  - $N = 101$, final time $t_{\\mathrm{f}} = 0.2\\,\\mathrm{s}$, Courant factor $\\mathrm{CFL} = 0.9$.\n  - Initial condition: $y(x,0) = A \\sin(\\pi x/L)$ with $A = 1.0 \\times 10^{-3}\\,\\mathrm{m}$ and $\\partial y/\\partial t (x,0) = 0$ for all $x$.\n  - Random seed: $0$.\n\n- Test $3$ (thermalized, weak damping, near-stability Courant factor):\n  - $L = 1.0\\,\\mathrm{m}$, $\\mu = 0.01\\,\\mathrm{kg/m}$, $\\mathcal{T} = 100\\,\\mathrm{N}$, $\\gamma = 0.1\\,\\mathrm{s}^{-1}$, $\\Theta = 300\\,\\mathrm{K}$.\n  - $N = 101$, final time $t_{\\mathrm{f}} = 0.2\\,\\mathrm{s}$, Courant factor $\\mathrm{CFL} = 0.99$.\n  - Initial condition: $y(x,0) = 0$ and $\\partial y/\\partial t (x,0) = 0$ for all $x$.\n  - Random seed: $271828$.\n\nOutput specification:\n\n- For each test case, compute the time-averaged total energy $\\overline{E}$ over the last $20\\%$ of time steps, in Joules, as a floating-point number. There are no angles or percentages to report.\n- Your program must produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, in the order of Tests $1$, $2$, then $3$, for example, `[$\\overline{E}_{1}$,$\\overline{E}_{2}$,$\\overline{E}_{3}$]`, where each $\\overline{E}_{i}$ is in Joules.", "solution": "The problem statement is scientifically sound, well-posed, and provides all necessary information for a complete physical and numerical analysis. It is based on established principles of classical mechanics and statistical physics, specifically the Langevin model for a system in contact with a thermal reservoir, governed by the fluctuation-dissipation theorem. The problem is therefore valid. We proceed with the solution.\n\n### 1. Derivation of the Stochastic Wave Equation\n\nWe begin by applying Newton's Second Law to a differential element of the string, located between $x$ and $x + \\mathrm{d}x$. Let $y(x,t)$ be the transverse displacement. For small amplitude vibrations, we can make the approximation $\\sin\\theta \\approx \\tan\\theta = \\partial y/\\partial x$, where $\\theta$ is the angle of the string element with the horizontal axis. The mass of the element is $\\mathrm{d}m = \\mu \\,\\mathrm{d}x$, where $\\mu$ is the linear mass density.\n\nThe net transverse force on the element is the sum of the restoring force from tension $\\mathcal{T}$, the damping force, and the stochastic thermal force.\nThe restoring force is the sum of the vertical components of tension at the ends of the element:\n$$ F_{\\text{tension}} = \\mathcal{T} \\sin\\theta(x+\\mathrm{d}x, t) - \\mathcal{T} \\sin\\theta(x, t) \\approx \\mathcal{T} \\left( \\frac{\\partial y}{\\partial x}\\bigg|_{x+\\mathrm{d}x} - \\frac{\\partial y}{\\partial x}\\bigg|_{x} \\right) \\approx \\mathcal{T} \\frac{\\partial^2 y}{\\partial x^2} \\mathrm{d}x $$\nThe problem specifies a linear damping force per unit length as $-\\mu \\gamma (\\partial y/\\partial t)$. For an element of length $\\mathrm{d}x$, this is:\n$$ F_{\\text{damping}} = -\\mu \\gamma \\frac{\\partial y}{\\partial t} \\mathrm{d}x $$\nThe thermal fluctuations from the heat bath are represented by a stochastic force per unit length, $\\eta(x,t)$. For the element, this force is:\n$$ F_{\\text{stochastic}} = \\eta(x,t) \\mathrm{d}x $$\nApplying Newton's Second Law, $(\\mu \\mathrm{d}x) \\frac{\\partial^2 y}{\\partial t^2} = F_{\\text{tension}} + F_{\\text{damping}} + F_{\\text{stochastic}}$, we obtain:\n$$ \\mu \\frac{\\partial^2 y}{\\partial t^2} \\mathrm{d}x = \\mathcal{T} \\frac{\\partial^2 y}{\\partial x^2} \\mathrm{d}x - \\mu \\gamma \\frac{\\partial y}{\\partial t} \\mathrm{d}x + \\eta(x,t) \\mathrm{d}x $$\nDividing by $\\mu \\mathrm{d}x$ and defining the wave speed $c = \\sqrt{\\mathcal{T}/\\mu}$, we arrive at the Langevin equation for the string:\n$$ \\frac{\\partial^2 y}{\\partial t^2} + \\gamma \\frac{\\partial y}{\\partial t} = c^2 \\frac{\\partial^2 y}{\\partial x^2} + \\frac{1}{\\mu} \\eta(x,t) $$\n\n### 2. Fluctuation-Dissipation Principle and Noise Amplitude\n\nThe stochastic force $\\eta(x,t)$ is assumed to be a zero-mean, Gaussian white noise process, characterized by its correlation function:\n$$ \\langle \\eta(x,t) \\rangle = 0 \\quad \\text{and} \\quad \\langle \\eta(x,t) \\eta(x',t') \\rangle = A \\, \\delta(x-x') \\delta(t-t') $$\nThe constant $A$ must be determined by the fluctuation-dissipation theorem, which requires that in thermal equilibrium at temperature $\\Theta$, the system satisfies the equipartition theorem. Each normal mode of the string must have an average energy of $k_{\\mathrm{B}} \\Theta$.\n\nWe decompose the displacement $y(x,t)$ into the string's normal modes, which for fixed ends ($y(0,t)=y(L,t)=0$) are sinusoidal:\n$$ y(x,t) = \\sum_{n=1}^{\\infty} q_n(t) \\sin(k_n x), \\quad \\text{where } k_n = \\frac{n\\pi}{L} $$\nSubstituting this into the Langevin equation and using the orthogonality of the sine functions, $\\int_0^L \\sin(k_n x) \\sin(k_m x) \\mathrm{d}x = \\frac{L}{2}\\delta_{nm}$, we project the dynamics onto each mode. The equation for the modal amplitude $q_n(t)$ becomes:\n$$ \\ddot{q}_n + \\gamma \\dot{q}_n + \\omega_n^2 q_n = \\tilde{\\eta}_n(t) $$\nwhere $\\omega_n = c k_n$ is the angular frequency of the $n$-th mode, and $\\tilde{\\eta}_n(t) = \\frac{2}{\\mu L} \\int_0^L \\eta(x,t) \\sin(k_n x) \\mathrm{d}x$ is the modal stochastic force. The correlation of the modal force is:\n$$ \\langle \\tilde{\\eta}_n(t) \\tilde{\\eta}_m(t') \\rangle = \\frac{4}{\\mu^2 L^2} \\int_0^L\\int_0^L \\langle \\eta(x,t)\\eta(x',t') \\rangle \\sin(k_n x)\\sin(k_m x') \\mathrm{d}x\\mathrm{d}x' = \\frac{2A}{\\mu^2 L} \\delta_{nm} \\delta(t-t') $$\nThe total energy of the string, $E(t) = \\int_0^L (\\frac{1}{2}\\mu(\\partial y/\\partial t)^2 + \\frac{1}{2}\\mathcal{T}(\\partial y/\\partial x)^2)\\mathrm{d}x$, can be expressed as a sum of modal energies $E_n$:\n$$ E(t) = \\sum_{n=1}^{\\infty} E_n(t) = \\sum_{n=1}^{\\infty} \\frac{\\mu L}{4} (\\dot{q}_n^2 + \\omega_n^2 q_n^2) $$\nThe effective mass for the $n$-th mode is $M_n = \\mu L/2$. According to the equipartition theorem, the average energy of each mode in thermal equilibrium is $\\langle E_n \\rangle = k_{\\mathrm{B}}\\Theta$. Standard results for a Langevin oscillator state that the average kinetic energy is $\\frac{1}{2}M_n\\langle\\dot{q}_n^2\\rangle = \\frac{1}{2}k_{\\mathrm{B}}\\Theta$. This requires the two-sided power spectral density of the force $\\tilde{\\eta}_n(t)$ to be $2\\gamma k_{\\mathrm{B}}\\Theta/M_n$. This implies the correlation strength of $\\tilde{\\eta}_n(t)$ is $C = \\langle \\tilde{\\eta}_n(t)\\tilde{\\eta}_n(t') \\rangle/\\delta(t-t') = 2\\gamma k_{\\mathrm{B}}\\Theta/M_n$.\nPlugging in our expressions for $C$ and $M_n$:\n$$ \\frac{2A}{\\mu^2 L} = \\frac{2\\gamma k_{\\mathrm{B}}\\Theta}{\\mu L/2} = \\frac{4\\gamma k_{\\mathrm{B}}\\Theta}{\\mu L} $$\nSolving for $A$, we find the required amplitude for the physical noise:\n$$ A = 2\\mu\\gamma k_{\\mathrm{B}}\\Theta $$\n\n### 3. Numerical Discretization and Algorithm\n\nTo solve the SPDE numerically, we discretize it in space and time. We use a uniform grid $x_i = i\\Delta x$ for $i=0, \\dots, N-1$ with $\\Delta x = L/(N-1)$, and discrete time steps $t_j = j\\Delta t$. We rewrite the second-order SPDE as a system of two first-order equations for position $y(x,t)$ and velocity $v(x,t) = \\partial y/\\partial t$:\n$$ \\frac{\\partial y}{\\partial t} = v \\qquad \\text{and} \\qquad \\frac{\\partial v}{\\partial t} = c^2 \\frac{\\partial^2 y}{\\partial x^2} - \\gamma v + \\frac{1}{\\mu} \\eta(x,t) $$\nWe use an explicit Euler-Cromer (or symplectic Euler) integration scheme, which is known for its better stability properties for oscillatory systems compared to the standard Euler method. For a grid point $i$ and time step $j$, the updates are:\n1. Calculate the total acceleration $a_i^j$ on node $i$ at time $t_j$.\n2. Update the velocity to $v_i^{j+1}$ using $a_i^j$.\n3. Update the position to $y_i^{j+1}$ using the new velocity $v_i^{j+1}$.\n\nThe discrete equations for the interior points ($i=1, \\dots, N-2$) are:\n$$ a_i^j = c^2 \\frac{y_{i+1}^j - 2y_i^j + y_{i-1}^j}{\\Delta x^2} - \\gamma v_i^j + R_i^j $$\n$$ v_i^{j+1} = v_i^j + a_i^j \\Delta t $$\n$$ y_i^{j+1} = y_i^j + v_i^{j+1} \\Delta t $$\nThe boundary conditions are $y_0^j=y_{N-1}^j=0$ and $v_0^j=v_{N-1}^j=0$ for all $j$.\n\nThe discrete random acceleration term $R_i^j$ corresponds to the continuous noise $\\eta(x,t)$. The random velocity kick over one time step, $\\Delta v_{\\text{stoch}} = R_i^j \\Delta t$, must have a variance consistent with the FDT. The variance of the velocity change of a particle of mass $m_i=\\mu\\Delta x$ due to thermal noise in time $\\Delta t$ is $\\langle (\\Delta v_{\\text{stoch}})^2 \\rangle = \\frac{2\\gamma k_{\\mathrm{B}}\\Theta}{m_i} \\Delta t = \\frac{2\\gamma k_{\\mathrm{B}}\\Theta}{\\mu\\Delta x}\\Delta t$.\nTherefore, $\\langle (R_i^j \\Delta t)^2 \\rangle = \\frac{2\\gamma k_{\\mathrm{B}}\\Theta}{\\mu\\Delta x}\\Delta t$, which implies that the variance of the random acceleration term is $\\langle (R_i^j)^2 \\rangle = \\frac{2\\gamma k_{\\mathrm{B}}\\Theta}{\\mu\\Delta x \\Delta t}$. We can thus write $R_i^j$ as:\n$$ R_i^j = \\sqrt{\\frac{2\\gamma k_{\\mathrm{B}}\\Theta}{\\mu\\Delta x \\Delta t}} Z_i^j $$\nwhere $Z_i^j$ are independent random numbers drawn from a standard normal distribution $N(0,1)$.\n\n### 4. Energy Calculation\n\nThe total mechanical energy $E(t)$ is computed at each required time step.\nThe kinetic energy $K = \\frac{1}{2}\\mu \\int_0^L v^2 \\mathrm{d}x$ is discretized using the trapezoidal rule:\n$$ K^j \\approx \\frac{1}{2}\\mu \\sum_{i=0}^{N-2} \\frac{(v_i^j)^2 + (v_{i+1}^j)^2}{2} \\Delta x = \\frac{1}{2}\\mu \\cdot \\text{trapz}((v^j)^2, x) $$\nThe potential energy $U = \\frac{1}{2}\\mathcal{T} \\int_0^L (\\partial y/\\partial x)^2 \\mathrm{d}x$ is discretized by approximating the derivative with finite differences. Using forward differences $\\frac{\\partial y}{\\partial x}\\big|_{x_{i+1/2}} \\approx \\frac{y_{i+1}-y_i}{\\Delta x}$ centered on the segments, the integral becomes a sum over the segments:\n$$ U^j \\approx \\frac{1}{2}\\mathcal{T} \\sum_{i=0}^{N-2} \\left(\\frac{y_{i+1}^j - y_i^j}{\\Delta x}\\right)^2 \\Delta x = \\frac{\\mathcal{T}}{2\\Delta x} \\sum_{i=0}^{N-2} (y_{i+1}^j - y_i^j)^2 $$\nThe total energy is $E^j = K^j + U^j$. The final result for each test case is the time average of $E^j$ over the last $20\\%$ of the simulation steps.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a one-dimensional stochastic model of a vibrating string\n    with thermal fluctuations and computes the time-averaged total energy.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Thermalized, moderate damping, safe stability\n        {'L': 1.0, 'mu': 0.01, 'T': 100.0, 'gamma': 10.0, 'Theta': 300.0,\n         'N': 101, 'tf': 0.2, 'CFL': 0.9,\n         'ic_type': 'zero', 'A': 0.0, 'seed': 314159},\n        # Test 2: No thermal noise, damped decay from a pluck\n        {'L': 1.0, 'mu': 0.01, 'T': 100.0, 'gamma': 10.0, 'Theta': 0.0,\n         'N': 101, 'tf': 0.2, 'CFL': 0.9,\n         'ic_type': 'pluck', 'A': 1.0e-3, 'seed': 0},\n        # Test 3: Thermalized, weak damping, near-stability Courant factor\n        {'L': 1.0, 'mu': 0.01, 'T': 100.0, 'gamma': 0.1, 'Theta': 300.0,\n         'N': 101, 'tf': 0.2, 'CFL': 0.99,\n         'ic_type': 'zero', 'A': 0.0, 'seed': 271828},\n    ]\n\n    results = []\n    k_B = 1.380649e-23  # Boltzmann constant in J/K\n\n    for params in test_cases:\n        # Extract parameters for the current test case\n        L = params['L']\n        mu = params['mu']\n        T = params['T']\n        gamma = params['gamma']\n        Theta = params['Theta']\n        N = params['N']\n        tf = params['tf']\n        CFL = params['CFL']\n        ic_type = params['ic_type']\n        A = params['A']\n        seed = params['seed']\n\n        # Setup spatial grid and time step\n        x = np.linspace(0.0, L, N)\n        dx = L / (N - 1)\n        c = np.sqrt(T / mu)\n        dt = CFL * dx / c\n        num_steps = int(tf / dt)\n\n        # Initialize state arrays for position (y) and velocity (v)\n        y = np.zeros(N, dtype=np.float64)\n        v = np.zeros(N, dtype=np.float64)\n\n        # Set initial conditions based on the test case\n        if ic_type == 'pluck':\n            # Set initial displacement for interior points, ends are fixed at 0\n            y[1:-1] = A * np.sin(np.pi * x[1:-1] / L)\n\n        # Setup random number generator with a fixed seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Calculate the amplitude of the stochastic acceleration term\n        # This term is zero if temperature is zero\n        if Theta > 0:\n            noise_amp = np.sqrt(2 * gamma * k_B * Theta / (mu * dx * dt))\n        else:\n            noise_amp = 0.0\n\n        # Storage for energy values during the averaging window\n        energies = []\n        # Determine the time step to start averaging energy\n        start_avg_step = int(0.8 * num_steps)\n\n        # Main simulation loop using the Euler-Cromer method\n        for j in range(num_steps):\n            # Calculate acceleration for interior points (vectorized)\n            # The endpoints (i=0 and i=N-1) are fixed, so their acceleration is 0.\n            \n            # 1.a) Restoring acceleration from tension (curvature)\n            a_curve = (c**2 / dx**2) * (y[2:] - 2*y[1:-1] + y[:-2])\n            \n            # 1.b) Damping acceleration\n            a_damp = -gamma * v[1:-1]\n            \n            # 1.c) Stochastic acceleration from thermal noise\n            if noise_amp > 0:\n                Z = rng.normal(0, 1, size=N - 2)\n                a_stoch = noise_amp * Z\n            else:\n                a_stoch = 0.0\n            \n            # Total acceleration for interior points\n            a = a_curve + a_damp + a_stoch\n\n            # 2. Update velocity of interior points\n            v[1:-1] += a * dt\n\n            # 3. Update position of interior points using the new velocity\n            y[1:-1] += v[1:-1] * dt\n\n            # If in the averaging window, calculate and store total energy\n            if j >= start_avg_step:\n                # Kinetic Energy: integral of 0.5 * mu * v^2 dx\n                # np.trapz provides an accurate numerical integration\n                K = 0.5 * mu * np.trapz(v**2, x=x)\n                \n                # Potential Energy: integral of 0.5 * T * (dy/dx)^2 dx\n                # Approximate dy/dx on segments between grid points\n                dydx = np.diff(y) / dx\n                # Sum the energy density over all segments\n                U = 0.5 * T * np.sum(dydx**2) * dx\n\n                energies.append(K + U)\n\n        # Calculate the time-averaged energy over the collected samples\n        avg_E = np.mean(energies) if energies else 0.0\n        results.append(avg_E)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "2438534"}]}