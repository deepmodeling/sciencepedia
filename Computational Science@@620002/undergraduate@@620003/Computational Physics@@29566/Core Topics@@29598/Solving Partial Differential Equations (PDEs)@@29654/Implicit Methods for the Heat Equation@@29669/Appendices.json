{"hands_on_practices": [{"introduction": "Moving from explicit to implicit methods is a crucial step in computational physics, primarily to overcome the strict stability constraints of schemes like FTCS. This first practice provides a fundamental exercise where an explicit method would fail, requiring the implementation of the unconditionally stable Crank-Nicolson method. By solving the 1D heat equation and comparing your numerical results to a known analytical solution, you will validate your implementation and gain hands-on experience with the accuracy and robustness of implicit techniques [@problem_id:2402549].", "problem": "Consider one-dimensional heat conduction into a semi-infinite homogeneous solid. The temperature field $T(x,t)$ satisfies the heat equation (a Partial Differential Equation (PDE))\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T}{\\partial x^2}, \\quad x > 0, \\; t > 0,\n$$\nwhere $\\alpha$ is the thermal diffusivity. The solid is initially at a uniform temperature and the surface at $x=0$ is suddenly brought to and maintained at a higher temperature. To compute a numerical approximation, approximate the semi-infinite domain by a finite interval $[0,L]$ and use the following well-posed initial and boundary conditions:\n- Initial condition: $T(x,0) = T_0$ for all $x \\in (0,L]$.\n- Boundary condition at the surface: $T(0,t) = T_s$ for all $t > 0$.\n- Boundary condition at the far end: $\\frac{\\partial T}{\\partial x}(L,t) = 0$ for all $t > 0$.\n\nThe exact analytical solution for the semi-infinite domain (with no finite-$L$ truncation) under these conditions is known and given by\n$$\nT_{\\text{exact}}(x,t) = T_0 + \\bigl(T_s - T_0\\bigr)\\,\\mathrm{erfc}\\!\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right), \\quad x \\ge 0, \\; t > 0,\n$$\nwhere $\\mathrm{erfc}$ denotes the complementary error function.\n\nYour task is to compute, for each specified parameter set, a numerical approximation to $T(x,t)$ on the truncated domain $[0,L]$ at a final time $t = t_f$, using a uniform spatial grid with $N_x$ equal-sized subintervals (so the grid points are $x_i = i\\,\\Delta x$ with $\\Delta x = L/N_x$ for $i=0,1,\\dots,N_x$) and a uniform time step $\\Delta t$ (so that the number of time steps up to $t_f$ is $t_f/\\Delta t$, which is guaranteed to be an integer in the test suite). Then, on the grid $\\{x_i\\}_{i=0}^{N_x}$, compute the maximum absolute error (in Kelvin) between the numerical solution $T_{\\text{num}}(x_i,t_f)$ and $T_{\\text{exact}}(x_i,t_f)$:\n$$\nE_{\\max} = \\max_{0 \\le i \\le N_x} \\left| T_{\\text{num}}(x_i,t_f) - T_{\\text{exact}}(x_i,t_f) \\right|.\n$$\n\nAll physical units must be used consistently: lengths in meters ($\\mathrm{m}$), time in seconds ($\\mathrm{s}$), temperature in Kelvin ($\\mathrm{K}$), and diffusivity in square meters per second ($\\mathrm{m^2/s}$). Report each $E_{\\max}$ in Kelvin, rounded to six decimal places.\n\nTest suite. For each of the following parameter sets $(\\alpha, L, T_0, T_s, t_f, N_x, \\Delta t)$, compute $E_{\\max}$:\n\n- Case $1$: $\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$, $L = 0.1\\ \\mathrm{m}$, $T_0 = 300\\ \\mathrm{K}$, $T_s = 400\\ \\mathrm{K}$, $t_f = 100\\ \\mathrm{s}$, $N_x = 400$, $\\Delta t = 0.1\\ \\mathrm{s}$.\n- Case $2$: $\\alpha = 1.4\\times 10^{-7}\\ \\mathrm{m^2/s}$, $L = 0.02\\ \\mathrm{m}$, $T_0 = 293\\ \\mathrm{K}$, $T_s = 350\\ \\mathrm{K}$, $t_f = 10\\ \\mathrm{s}$, $N_x = 200$, $\\Delta t = 0.5\\ \\mathrm{s}$.\n- Case $3$: $\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$, $L = 0.02\\ \\mathrm{m}$, $T_0 = 300\\ \\mathrm{K}$, $T_s = 310\\ \\mathrm{K}$, $t_f = 200\\ \\mathrm{s}$, $N_x = 200$, $\\Delta t = 0.2\\ \\mathrm{s}$.\n- Case $4$: $\\alpha = 5.0\\times 10^{-6}\\ \\mathrm{m^2/s}$, $L = 0.05\\ \\mathrm{m}$, $T_0 = 300\\ \\mathrm{K}$, $T_s = 360\\ \\mathrm{K}$, $t_f = 200\\ \\mathrm{s}$, $N_x = 40$, $\\Delta t = 2.0\\ \\mathrm{s}$.\n\nFinal output format. Your program should produce a single line of output containing the list of the four rounded errors, in the order of the test suite, as a comma-separated list enclosed in square brackets, for example\n$[e_1,e_2,e_3,e_4]$,\nwhere each $e_k$ is the error for Case $k$ in Kelvin rounded to six decimal places (no units or extra spaces in the output line).", "solution": "The problem presented is a well-posed initial-boundary value problem for the one-dimensional heat equation on a truncated spatial domain. A numerical solution is to be computed and compared against a given analytical solution corresponding to a semi-infinite domain.\n\nThe problem is validated as follows. The governing partial differential equation, $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$, is a fundamental principle of heat transfer. The initial and boundary conditions are standard and physically meaningful. All parameters are provided with consistent units. Critically, an analysis of the stability parameter for an explicit forward-time, centered-space (FTCS) scheme, $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$, reveals values of $s \\approx 16$, $s=7$, $s=200$, and $s \\approx 6.4$ for the four respective test cases. Since for stability the FTCS scheme requires $s \\le \\frac{1}{2}$, an explicit method would be violently unstable. This necessitates the use of an unconditionally stable implicit method. The problem is therefore scientifically sound and rigorously structured to test the implementation of such a method.\n\nThe Crank-Nicolson method is selected for its unconditional stability and second-order accuracy in both time $O((\\Delta t)^2)$ and space $O((\\Delta x)^2)$. The method approximates the time derivative at the midpoint of a time interval $[t_n, t_{n+1}]$ and averages the spatial derivative over the two time levels. Let $T_i^n$ denote the numerical approximation of the temperature $T(x_i, t_n)$ at grid point $x_i = i\\Delta x$ and time $t_n = n\\Delta t$. The Crank-Nicolson discretization of the heat equation is:\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left[ \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} + \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{(\\Delta x)^2} \\right] $$\nThis equation applies to the interior spatial grid points $i = 1, 2, \\dots, N_x - 1$. Let $r = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$. Rearranging the equation to separate the unknown temperatures at time step $n+1$ from the known temperatures at time step $n$ yields:\n$$ -r T_{i-1}^{n+1} + (1+2r) T_i^{n+1} - r T_{i+1}^{n+1} = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n $$\nThis system of equations must be supplemented with boundary conditions. The spatial grid has $N_x+1$ points indexed from $i=0$ to $i=N_x$. The temperatures $T_1^{n+1}, \\dots, T_{N_x}^{n+1}$ are the $N_x$ unknowns to be found at each time step.\n\nAt the boundary $x=0$ (corresponding to $i=0$), the Dirichlet condition $T(0,t) = T_s$ is applied, so $T_0^n = T_s$ for all $n \\ge 0$. For the first unknown $T_1^{n+1}$ (i.e., at $i=1$), the known value $T_0^{n+1} = T_s$ is moved to the right-hand side of the equation:\n$$ (1+2r) T_1^{n+1} - r T_2^{n+1} = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n\nAt the boundary $x=L$ (corresponding to $i=N_x$), the Neumann condition $\\frac{\\partial T}{\\partial x}(L,t)=0$ is imposed. This is approximated using a second-order accurate central difference involving a \"ghost point\" at $x_{N_x+1} = L+\\Delta x$. The condition $\\frac{T_{N_x+1} - T_{N_x-1}}{2\\Delta x} = 0$ implies $T_{N_x+1} = T_{N_x-1}$. Substituting this into the general Crank-Nicolson equation for $i=N_x$ provides the equation for the final unknown $T_{N_x}^{n+1}$:\n$$ -2r T_{N_x-1}^{n+1} + (1+2r) T_{N_x}^{n+1} = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\nThese equations for $i = 1, \\dots, N_x$ form a linear system of the form $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$, where $\\mathbf{U}^{n+1}$ is the vector of unknown temperatures $[T_1^{n+1}, \\dots, T_{N_x}^{n+1}]^T$. The matrix $\\mathbf{A}$ is a constant, $N_x \\times N_x$ tridiagonal matrix:\n$$ \\mathbf{A} = \\begin{pmatrix}\n1+2r & -r & 0 & \\dots & \\dots & 0 \\\\\n-r & 1+2r & -r & \\ddots & & \\vdots \\\\\n0 & \\ddots & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & \\ddots & -r & 1+2r & -r & 0 \\\\\n\\vdots & & \\ddots & 0 & -2r & 1+2r\n\\end{pmatrix} $$\nThe right-hand side vector $\\mathbf{b}^n$ is computed from the known temperatures at time $n$:\n$$ b_1^n = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n$$ b_i^n = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n \\quad \\text{for } i=2, \\dots, N_x-1 $$\n$$ b_{N_x}^n = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\nThe numerical solution proceeds by first setting the initial temperature profile $T(x,0) = T_0$ for $x>0$ and $T(0,0)=T_s$. Then, for each time step from $n=0$ to $N_t-1$, where $N_t=t_f/\\Delta t$, the right-hand side vector $\\mathbf{b}^n$ is constructed and the tridiagonal system $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$ is solved to find the temperatures at the next time step. This process is repeated until the final time $t_f$ is reached. This tridiagonal system is efficiently solved using an algorithm such as the Thomas algorithm, available in scientific computing libraries.\n\nFinally, at $t=t_f$, the computed numerical solution $T_{\\text{num}}(x_i, t_f)$ is compared to the analytical solution for the semi-infinite domain, $T_{\\text{exact}}(x_i, t_f)$, and the maximum absolute error $E_{\\max}$ over all grid points is determined. It is noted that this error metric conflates the numerical discretization error with the modeling error arising from the domain truncation and the approximate far-field boundary condition.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation for given test cases using the Crank-Nicolson method\n    and computes the maximum error against the analytical solution.\n    \"\"\"\n    # (alpha, L, T0, Ts, tf, Nx, dt)\n    test_cases = [\n        (1.0e-5, 0.1, 300.0, 400.0, 100.0, 400, 0.1),\n        (1.4e-7, 0.02, 293.0, 350.0, 10.0, 200, 0.5),\n        (1.0e-5, 0.02, 300.0, 310.0, 200.0, 200, 0.2),\n        (5.0e-6, 0.05, 300.0, 360.0, 200.0, 40, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, T0, Ts, tf, Nx, dt = case\n\n        # Discretization parameters\n        dx = L / Nx\n        # Note: The stability parameter for FTCS is alpha*dt/dx**2.\n        # The Crank-Nicolson parameter 'r' is defined with a factor of 2.\n        r = (alpha * dt) / (2 * dx**2)\n        Nt = int(round(tf / dt))\n\n        # --- Initial Condition ---\n        # T_current is the temperature vector at the current time step.\n        # It has Nx+1 points, from x=0 to x=L.\n        T_current = np.full(Nx + 1, T0)\n        T_current[0] = Ts # Boundary condition at x=0\n\n        # --- Set up the Crank-Nicolson matrix system A*U_next = b ---\n        # Matrix A is tridiagonal and constant through time.\n        # We use scipy.linalg.solve_banded which is efficient.\n        # The matrix A acts on the interior points plus the far boundary, so it is Nx x Nx.\n        \n        # 'ab' stores the bands of matrix A in a format required by solve_banded.\n        # For a (1,1) banded matrix A, ab is (3, Nx).\n        # ab[0, 1:] = upper diagonal\n        # ab[1, :]   = main diagonal\n        # ab[2, :-1] = lower diagonal\n        ab = np.zeros((3, Nx))\n\n        # Main diagonal\n        ab[1, :] = 1 + 2 * r\n\n        # Upper diagonal\n        ab[0, 1:] = -r\n\n        # Lower diagonal\n        ab[2, :-1] = -r\n        # Modification for Neumann boundary condition at x=L (i=Nx)\n        # This affects the last row of matrix A: A[Nx-1, Nx-2] = -2*r\n        # which corresponds to the last element of the lower diagonal band.\n        if Nx > 1:\n            ab[2, Nx - 2] = -2 * r\n\n        # --- Time-stepping loop ---\n        for _ in range(Nt):\n            # Construct the right-hand side vector b\n            b = np.zeros(Nx)\n\n            # Equation for the first interior point i=1 (vector index 0)\n            b[0] = (1 - 2 * r) * T_current[1] + r * T_current[2] + 2 * r * Ts\n\n            # Equations for interior points i=2 to Nx-1 (vector indices 1 to Nx-2)\n            # This loop is slow but clear. Vectorization is possible but complex to write.\n            for i in range(2, Nx):\n                b[i-1] = r * T_current[i-1] + (1 - 2 * r) * T_current[i] + r * T_current[i+1]\n\n            # Equation for the last point i=Nx (vector index Nx-1)\n            # This is only relevant if there's more than one unknown point\n            if Nx > 1:\n                b[Nx - 1] = 2 * r * T_current[Nx - 1] + (1 - 2 * r) * T_current[Nx]\n\n            # Solve the linear system for the unknown interior temperatures at the next time step\n            T_next_interior = solve_banded((1, 1), ab, b)\n            \n            # Update the temperature vector\n            T_current[1:] = T_next_interior\n            # T_current[0] is always Ts\n\n        # --- Error Calculation ---\n        # The numerical solution at t=tf is in T_current\n        T_numerical = T_current\n\n        # Calculate the exact solution at t=tf\n        x = np.linspace(0, L, Nx + 1)\n        # The argument of erfc can become infinite if t=0, but tf > 0 here.\n        argument = x / (2 * np.sqrt(alpha * tf))\n        T_exact = T0 + (Ts - T0) * erfc(argument)\n        \n        # Compute the maximum absolute error\n        max_error = np.max(np.abs(T_numerical - T_exact))\n        results.append(round(max_error, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402549"}, {"introduction": "While the Crank-Nicolson method is celebrated for its second-order accuracy and unconditional stability, it is not without its subtleties; for certain problems, it can introduce non-physical oscillations near sharp gradients. This exercise challenges you to implement the more general $\\theta$-scheme, which blends implicit and explicit approaches, allowing you to directly control the numerical damping properties of the solver. Through an empirical search, you will find the optimal value of $\\theta$ to suppress these oscillations, developing a more nuanced understanding of numerical stability and solution quality [@problem_id:2402615].", "problem": "You will implement and test a fully implicit one-dimensional time-integration method for the linear heat equation using the generalized $\\theta$-scheme, and then empirically determine the smallest value of $\\theta$ that eliminates the oscillations associated with the Crank–Nicolson scheme. All variables are dimensionless.\n\nConsider the heat equation on a finite interval with fixed Dirichlet boundary data:\n- Partial differential equation: $u_t = \\alpha\\,u_{xx}$ for $x \\in (0,L)$ and $t > 0$.\n- Domain length: $L = 1$.\n- Diffusivity: $\\alpha = 1$.\n- Boundary conditions: $u(0,t) = 1$ and $u(L,t) = 0$ for all $t \\ge 0$.\n- Initial condition: a unit step located at the midpoint, $u(x,0) = 1$ for $x < L/2$ and $u(x,0) = 0$ for $x \\ge L/2$.\n\nDiscretize space using a uniform grid with $N$ subintervals (so there are $N+1$ grid points, including boundaries) and time using a uniform step $\\Delta t$. Define $\\Delta x = L/N$ and the dimensionless ratio $r = \\alpha\\,\\Delta t/\\Delta x^2$ so that $\\Delta t = r\\,\\Delta x^2/\\alpha$. On the interior grid points $x_i = i\\,\\Delta x$ for $i = 1,2,\\dots,N-1$, approximate the spatial second derivative by the standard central second difference and the time derivative by a finite difference. The generalized $\\theta$-scheme blends implicit and explicit treatment of the diffusion term by evaluating the discrete Laplacian at times $t^{n+1}$ and $t^n$ with weights $\\theta$ and $(1-\\theta)$, respectively. You must derive the linear system for the interior unknowns at each time step starting from the heat equation and these consistent discretizations.\n\nOscillations: The Crank–Nicolson choice $\\theta = 1/2$ is known to be A-stable but not L-stable for the scalar test equation, which can cause temporally oscillatory decay of high-frequency spatial modes when $r$ is moderately large, leading to spatial overshoot and undershoot near discontinuities. To quantify this, define the overshoot metric at a given time $t$ as\n$$\n\\mathcal{M} = \\max\\{0,\\max_i u_i - 1\\} + \\max\\{0,-\\min_i u_i\\},\n$$\nthat is, the sum of the amount above $1$ and the amount below $0$ attained anywhere on the grid (including boundaries).\n\nYour task is to:\n- Implement a solver for the generalized $\\theta$-scheme on the described grid for the one-dimensional heat equation with the specified boundary and initial data.\n- For a given $(N,r,T,\\tau)$, with final time $T$ and tolerance $\\tau$, empirically determine\n$$\n\\theta^\\star = \\min\\{\\theta \\in [1/2,1]: \\mathcal{M}(\\theta;N,r,T) \\le \\tau\\},\n$$\nthe smallest $\\theta$ in the interval $[1/2,1]$ for which the overshoot metric at time $T$ is less than or equal to $\\tau$. If $\\theta = 1/2$ already meets the tolerance, return $\\theta^\\star = 1/2$. If no $\\theta \\in [1/2,1]$ meets the tolerance, return $\\theta^\\star = 1$.\n- Use a robust search strategy that leverages the monotone damping behavior of the $\\theta$-scheme with respect to $\\theta$ to find $\\theta^\\star$ to within an absolute accuracy of $10^{-3}$.\n\nFundamental base for derivation:\n- Use $u_t = \\alpha u_{xx}$, the definitions of $\\Delta x$, $\\Delta t$, and $r$, the central second difference for $u_{xx}$, and a consistent finite difference for $u_t$ combined with the generalized $\\theta$-blending of spatial terms. Incorporate Dirichlet boundary conditions exactly at each time step.\n\nNumerical requirements:\n- Space is discretized with $N$ subintervals (so $N+1$ nodes). Time steps use $\\Delta t = r\\,\\Delta x^2$ with $\\alpha = 1$ and $L=1$. March the solution from $t=0$ to $t \\approx T$ using a number of time steps equal to $\\lceil T / \\Delta t \\rceil$, and evaluate $\\mathcal{M}$ at that final step.\n- The initial condition on interior nodes is the step: $u_i^0 = 1$ if $x_i < 1/2$ and $u_i^0 = 0$ otherwise. Boundaries satisfy $u_0^n = 1$ and $u_N^n = 0$ for all $n$.\n\nTest suite:\nProvide results for the following parameter sets $(N,r,T,\\tau)$:\n- Case $1$: $(N,r,T,\\tau) = (200,\\,1.0,\\,0.02,\\,10^{-3})$.\n- Case $2$: $(N,r,T,\\tau) = (200,\\,2.0,\\,0.02,\\,10^{-3})$.\n- Case $3$: $(N,r,T,\\tau) = (200,\\,0.6,\\,0.02,\\,10^{-3})$.\n- Case $4$: $(N,r,T,\\tau) = (200,\\,0.2,\\,0.02,\\,10^{-3})$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above, with each $\\theta^\\star$ rounded to exactly three digits after the decimal point (for example, $[0.500,0.625,0.575,0.500]$).", "solution": "The problem presented is valid. It is a well-posed, scientifically grounded problem in the field of computational physics concerning the numerical solution of the one-dimensional heat equation. All parameters, conditions, and objectives are clearly and objectively defined. We shall proceed with a complete solution.\n\nThe fundamental task is to solve the linear heat equation and empirically determine the minimum value of a parameter $\\theta$ in a generalized time-integration scheme that suppresses non-physical oscillations to within a given tolerance.\n\nThe governing partial differential equation (PDE) is the one-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nfor the function $u(x,t)$ in the domain $x \\in (0, L)$ and $t > 0$. The provided parameters are a domain length of $L=1$ and a thermal diffusivity of $\\alpha=1$. The system is subject to fixed Dirichlet boundary conditions and a discontinuous initial condition:\n- Boundary Conditions (BCs): $u(0,t) = 1$ and $u(L,t) = 0$ for $t \\ge 0$.\n- Initial Condition (IC): $u(x,0) = 1$ for $x < L/2$ and $u(x,0) = 0$ for $x \\ge L/2$.\n\nWe discretize the domain using a uniform grid. The spatial domain $x \\in [0, L]$ is divided into $N$ subintervals of width $\\Delta x = L/N$. The grid points are $x_i = i \\Delta x$ for $i = 0, 1, \\dots, N$. The time domain is discretized with a uniform time step $\\Delta t$. Let $u_i^n$ denote the numerical approximation of $u(x_i, t^n)$ where $t^n = n \\Delta t$. The dimensionless parameter $r$ is defined as $r = \\alpha \\Delta t / \\Delta x^2$. Given the problem values $L=1$ and $\\alpha=1$, we have $\\Delta x = 1/N$ and $\\Delta t = r/N^2$.\n\nThe generalized $\\theta$-scheme for the heat equation is formulated by approximating the time derivative with a forward difference and the spatial second derivative with a weighted average of central differences evaluated at time levels $n$ and $n+1$:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\left[ \\theta \\left( \\frac{u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}}{\\Delta x^2} \\right) + (1-\\theta) \\left( \\frac{u_{i-1}^{n} - 2u_i^{n} + u_{i+1}^{n}}{\\Delta x^2} \\right) \\right]\n$$\nThis scheme applies to the interior grid points, i.e., for $i = 1, 2, \\dots, N-1$. The parameter $\\theta \\in [0, 1]$ controls the degree of implicitness: $\\theta=0$ gives the explicit forward Euler method, $\\theta=1/2$ gives the Crank-Nicolson method, and $\\theta=1$ gives the fully implicit backward Euler method.\n\nTo derive the linear system for the unknown values $u_i^{n+1}$, we multiply by $\\Delta t$ and substitute $r = \\alpha \\Delta t / \\Delta x^2$:\n$$\nu_i^{n+1} - u_i^n = r \\theta (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) + r(1-\\theta) (u_{i-1}^{n} - 2u_i^{n} + u_{i+1}^{n})\n$$\nWe rearrange this equation by grouping all terms at the new time level $n+1$ on the left-hand side (LHS) and all terms at the current time level $n$ on the right-hand side (RHS):\n$$\n-r\\theta u_{i-1}^{n+1} + (1 + 2r\\theta)u_i^{n+1} - r\\theta u_{i+1}^{n+1} = r(1-\\theta)u_{i-1}^{n} + (1 - 2r(1-\\theta))u_i^n + r(1-\\theta)u_{i+1}^{n}\n$$\nThis represents a system of $N-1$ linear equations for the $N-1$ unknown interior values $\\{u_i^{n+1}\\}_{i=1}^{N-1}$. We can write this system in matrix form as $\\mathbf{A} \\mathbf{u}^{n+1}_{\\text{int}} = \\mathbf{b}$, where $\\mathbf{u}^{n+1}_{\\text{int}} = (u_1^{n+1}, \\dots, u_{N-1}^{n+1})^T$.\n\nThe matrix $\\mathbf{A}$ is an $(N-1) \\times (N-1)$ symmetric tridiagonal matrix with constant entries defined by $r$ and $\\theta$:\n$$\n\\mathbf{A} = \\begin{pmatrix}\n1+2r\\theta & -r\\theta & & \\\\\n-r\\theta & 1+2r\\theta & -r\\theta & \\\\\n& \\ddots & \\ddots & \\ddots & \\\\\n& & -r\\theta & 1+2r\\theta & -r\\theta \\\\\n& & & -r\\theta & 1+2r\\theta\n\\end{pmatrix}\n$$\nThe right-hand side vector $\\mathbf{b}$ depends on the known solution at time $n$ and the boundary conditions. The boundary conditions are $u_0^n = 1$ and $u_N^n = 0$ for all $n$. These known values modify the first and last equations of the system.\n\nFor $i=1$:\n$$\n-r\\theta u_0^{n+1} + (1+2r\\theta)u_1^{n+1} - r\\theta u_2^{n+1} = r(1-\\theta)u_0^n + (1 - 2r(1-\\theta))u_1^n + r(1-\\theta)u_2^n\n$$\nMoving the known boundary terms $u_0^{n+1}=1$ and $u_0^n=1$ to the RHS gives:\n$$\n(1+2r\\theta)u_1^{n+1} - r\\theta u_2^{n+1} = r\\theta(1) + r(1-\\theta)(1) + (1 - 2r(1-\\theta))u_1^n + r(1-\\theta)u_2^n\n$$\nThe RHS for the first equation becomes $b_1 = r + (1 - 2r(1-\\theta))u_1^n + r(1-\\theta)u_2^n$.\n\nFor $i=N-1$:\n$$\n-r\\theta u_{N-2}^{n+1} + (1+2r\\theta)u_{N-1}^{n+1} - r\\theta u_N^{n+1} = \\dots\n$$\nThe boundary terms involving $u_N^{n+1}=0$ and $u_N^n=0$ vanish. The RHS for the last equation is $b_{N-1} = r(1-\\theta)u_{N-2}^n + (1 - 2r(1-\\theta))u_{N-1}^n$.\n\nThe time-stepping procedure is as follows:\n$1$. Initialize the solution vector $\\mathbf{u}^0$ according to the IC and BCs.\n$2$. For each time step from $n=0$ to $n_{\\text{steps}}-1 = \\lceil T/\\Delta t \\rceil-1$:\n    a. Construct the RHS vector $\\mathbf{b}$ using the solution $\\mathbf{u}^n$.\n    b. Solve the tridiagonal system $\\mathbf{A} \\mathbf{u}^{n+1}_{\\text{int}} = \\mathbf{b}$ to find the interior solution at the next time step. This is efficiently done using an algorithm such as the Thomas algorithm (TDMA), which has a linear time complexity of $O(N)$.\n$3$. After the final time step, calculate the overshoot metric $\\mathcal{M}$:\n$$\n\\mathcal{M} = \\max\\{0, \\max_i u_i - 1\\} + \\max\\{0, -\\min_i u_i\\}\n$$\nThis metric quantifies the total violation of the maximum principle; for the continuous heat equation, the solution must remain bounded by the minimum and maximum of the initial and boundary data, i.e., $u(x,t) \\in [0, 1]$. Numerical schemes may violate this, especially for non-smooth initial data as given here.\n\nThe problem requires finding $\\theta^\\star = \\min\\{\\theta \\in [1/2, 1] | \\mathcal{M}(\\theta) \\le \\tau\\}$, where $\\tau$ is a small tolerance. The metric $\\mathcal{M}(\\theta)$ is a monotonically decreasing function of $\\theta$ for $\\theta \\in [1/2, 1]$, as increasing $\\theta$ enhances the numerical damping of the scheme. This monotonic behavior allows for an efficient search for $\\theta^\\star$ using a bisection method.\n\nThe search algorithm for $\\theta^\\star$ is as follows:\n$1$. Define a search interval $[\\theta_{\\text{low}}, \\theta_{\\text{high}}] = [1/2, 1]$.\n$2$. First, check the overshoot for $\\theta=1/2$. If $\\mathcal{M}(1/2) \\le \\tau$, then $\\theta^\\star = 1/2$.\n$3$. If not, check for $\\theta=1$. If $\\mathcal{M}(1) > \\tau$, then no solution in the interval meets the criterion, and we must return $\\theta^\\star=1$.\n$4$. Otherwise, perform a bisection search:\n   - While $(\\theta_{\\text{high}} - \\theta_{\\text{low}})$ is greater than the desired accuracy of $10^{-3}$:\n     - Set $\\theta_{\\text{mid}} = (\\theta_{\\text{low}} + \\theta_{\\text{high}})/2$.\n     - Compute $\\mathcal{M}(\\theta_{\\text{mid}})$.\n     - If $\\mathcal{M}(\\theta_{\\text{mid}}) \\le \\tau$, it means a valid $\\theta$ is found, so we try to find a smaller one by setting $\\theta_{\\text{high}} = \\theta_{\\text{mid}}$.\n     - If $\\mathcal{M}(\\theta_{\\text{mid}}) > \\tau$, $\\theta_{\\text{mid}}$ is too small, so we must seek a larger value by setting $\\theta_{\\text{low}} = \\theta_{\\text{mid}}$.\n$5$. The resulting $\\theta_{\\text{high}}$ is the desired approximation of $\\theta^\\star$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef _calculate_overshoot(theta, N, r, T):\n    \"\"\"\n    Solves the 1D heat equation using the generalized theta-scheme and calculates\n    the overshoot metric M at the final time.\n    \"\"\"\n    # System parameters\n    L = 1.0\n    alpha = 1.0\n    \n    # Discretization\n    dx = L / N\n    dt = r * dx**2 / alpha\n    num_steps = int(np.ceil(T / dt))\n\n    # Initial condition\n    x = np.linspace(0, L, N + 1)\n    u = np.where(x < L / 2, 1.0, 0.0)\n    \n    # Enforce boundary conditions on the initial state\n    u[0] = 1.0\n    u[N] = 0.0\n    \n    # Extract interior points for time marching\n    u_int = u[1:N].copy()\n    \n    # Set up the tridiagonal system for the implicit part: A * u_new = b\n    # A is constant throughout the simulation for fixed theta and r.\n    diag_A = 1 + 2 * r * theta\n    offdiag_A = -r * theta\n    A_banded = np.zeros((3, N - 1))\n    A_banded[0, 1:] = offdiag_A\n    A_banded[1, :] = diag_A\n    A_banded[2, :-1] = offdiag_A\n\n    # RHS contribution from a portion of the explicit scheme and boundary conditions\n    r_expl = r * (1 - theta)\n    # The vector d contains contributions from boundary conditions.\n    # For a constant BC u_0=1, the total contribution is r*(1-theta)*u_0^n + r*theta*u_0^{n+1} = r.\n    # For u_N=0, the contribution is 0.\n    d = np.zeros(N - 1)\n    d[0] = r\n\n    # Time marching loop\n    for _ in range(num_steps):\n        # Calculate the RHS vector b = B*u_int + d, where B is the explicit matrix.\n        # This is implemented via direct vector operations for efficiency.\n        b = np.empty(N - 1)\n        \n        # Interior of the RHS vector\n        b[1:-1] = r_expl * u_int[:-2] + (1 - 2 * r_expl) * u_int[1:-1] + r_expl * u_int[2:]\n        \n        # First element (affected by u_0=1 BC)\n        b[0] = (1 - 2 * r_expl) * u_int[0] + r_expl * u_int[1]\n        \n        # Last element (affected by u_N=0 BC, which adds nothing)\n        b[-1] = r_expl * u_int[-2] + (1 - 2 * r_expl) * u_int[-1]\n        \n        # Add the boundary contributions vector\n        b += d\n        \n        # Solve the tridiagonal system for the next time step's interior values\n        u_int = solve_banded((1, 1), A_banded, b, check_finite=False)\n\n    # Reconstruct full solution vector with final boundaries\n    u_final = np.concatenate(([1.0], u_int, [0.0]))\n\n    # Calculate the overshoot metric M\n    overshoot = np.maximum(0, u_final.max() - 1.0)\n    undershoot = np.maximum(0, -u_final.min())\n    metric = overshoot + undershoot\n    \n    return metric\n\ndef find_theta_star(N, r, T, tau):\n    \"\"\"\n    Finds the smallest theta in [0.5, 1.0] for which the overshoot metric\n    is below a tolerance tau, using a bisection search.\n    \"\"\"\n    theta_low = 0.5\n    theta_high = 1.0\n    accuracy = 1e-3\n\n    # Check the lower bound (Crank-Nicolson) first.\n    m_low = _calculate_overshoot(theta_low, N, r, T)\n    if m_low <= tau:\n        return theta_low\n    \n    # Check the upper bound (Fully Implicit). If it fails, no solution in range.\n    m_high = _calculate_overshoot(theta_high, N, r, T)\n    if m_high > tau:\n        return theta_high\n\n    # Bisection search for the optimal theta\n    while (theta_high - theta_low) > accuracy:\n        theta_mid = (theta_low + theta_high) / 2.0\n        m_mid = _calculate_overshoot(theta_mid, N, r, T)\n        \n        if m_mid <= tau:\n            # Condition met, try for a smaller theta (less damping)\n            theta_high = theta_mid\n        else:\n            # Condition not met, need a larger theta (more damping)\n            theta_low = theta_mid\n            \n    return theta_high\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, r, T, tau)\n        (200, 1.0, 0.02, 1e-3),\n        (200, 2.0, 0.02, 1e-3),\n        (200, 0.6, 0.02, 1e-3),\n        (200, 0.2, 0.02, 1e-3),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, r, T, tau = case\n        theta_star = find_theta_star(N, r, T, tau)\n        results.append(f\"{theta_star:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2402615"}, {"introduction": "Extending implicit methods to higher dimensions presents a new challenge: a fully implicit 2D discretization results in a large, banded matrix system that is complex to solve directly. This practice introduces the Alternating-Direction Implicit (ADI) method, an elegant and efficient technique that transforms the 2D problem into a sequence of easily solvable 1D tridiagonal systems. By simulating heat diffusion on a 2D plate, you will learn how to make implicit methods computationally tractable in higher dimensions, a vital skill for tackling real-world physics problems [@problem_id:2402582].", "problem": "Consider the two-dimensional heat diffusion on a square domain governed by the partial differential equation (PDE)\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right),\n$$\non the square plate $\\Omega = [0,L]\\times[0,L]$, with constant Dirichlet boundary conditions\n$$\nT(x,y,t) = T_b \\quad \\text{for all } (x,y)\\in \\partial \\Omega, \\; t \\ge 0,\n$$\nand an initial condition of the form\n$$\nT(x,y,0) = T_b + A \\exp\\left(-\\frac{(x - L/2)^2 + (y - L/2)^2}{2\\sigma^2}\\right).\n$$\nUse a uniform Cartesian grid with $N\\times N$ points, spatial step $\\Delta x = \\Delta y = L/(N-1)$, and a uniform time step $\\Delta t$. Evolve the temperature up to a final time $t_{\\text{final}}$ starting from $t=0$. All temperatures must be reported in Kelvin (K), all lengths in meters (m), and all times in seconds (s).\n\nYour task is to compute, for each test case listed below, the following two quantities:\n- The temperature at the plate center grid point $(x=L/2,y=L/2)$ at time $t=t_{\\text{final}}$ (Kelvin).\n- The maximum temperature over all grid points at time $t=t_{\\text{final}}$ (Kelvin).\n\nAssume $N$ is odd so that the grid contains the exact center $(L/2,L/2)$. Treat the boundary values as fixed at $T_b$ for all $t \\ge 0$.\n\nTest Suite (each case specifies $(L,\\alpha,T_b,A,\\sigma,\\Delta t,t_{\\text{final}},N)$):\n- Case $1$: $L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=100.0$ K, $\\sigma=0.01$ m, $\\Delta t=2.5\\times 10^{-4}$ s, $t_{\\text{final}}=0.01$ s, $N=41$.\n- Case $2$: $L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=50.0$ K, $\\sigma=0.02$ m, $\\Delta t=1.0\\times 10^{-3}$ s, $t_{\\text{final}}=0.01$ s, $N=5$.\n- Case $3$: $L=0.1$ m, $\\alpha=1.0\\times 10^{-4}$ m$^2$/s, $T_b=300.0$ K, $A=0.0$ K, $\\sigma=0.01$ m, $\\Delta t=1.0\\times 10^{-3}$ s, $t_{\\text{final}}=0.02$ s, $N=31$.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[T_{\\text{center}},T_{\\max}]$ in Kelvin. For the three cases above, the required format is\n[ [T_center_case1,T_max_case1], [T_center_case2,T_max_case2], [T_center_case3,T_max_case3] ]\nwith no spaces in the printed output (for example: [[300.123456,350.654321],[...],[...]]). The values are real numbers in Kelvin.", "solution": "The problem statement has been validated and is deemed valid. It presents a well-posed initial-boundary value problem for the two-dimensional heat equation, a fundamental model in physics. All parameters and conditions are specified, allowing for a unique, stable, and meaningful numerical solution.\n\nThe problem requires the numerical solution of the two-dimensional heat equation:\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right)\n$$\non a square domain $\\Omega = [0,L]\\times[0,L]$ with a spatial grid of $N \\times N$ points. The boundary temperature is fixed at $T(x,y,t) = T_b$ for $(x,y) \\in \\partial\\Omega$, and the initial temperature distribution is given by a Gaussian function superimposed on the boundary temperature.\n\nFor the numerical solution of this parabolic partial differential equation, an implicit finite difference method is appropriate due to its property of unconditional stability. The Alternating-Direction Implicit (ADI) method, specifically the Peaceman-Rachford scheme, is an efficient choice for two-dimensional problems. This method decouples the dimensions by splitting each time step $\\Delta t$ into two half-steps of size $\\Delta t / 2$, transforming the large two-dimensional problem into a series of smaller, independent one-dimensional problems that can be solved very efficiently.\n\nLet $T_{i,j}^n$ represent the temperature at grid point $(x_i, y_j)$ at time $t_n = n\\Delta t$. The spatial grid steps are $\\Delta x = \\Delta y = L/(N-1)$.\n\nThe ADI scheme proceeds in two half-steps to advance the solution from time $t_n$ to $t_{n+1} = t_n + \\Delta t$:\n\nStep 1: Advance from $t_n$ to an intermediate time $t_{n+1/2} = t_n + \\Delta t/2$.\nIn this step, the scheme is implicit in the $x$-direction and explicit in the $y$-direction. The finite difference equation is:\n$$\n\\frac{T_{i,j}^{n+1/2} - T_{i,j}^n}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n}{\\Delta y^2} \\right)\n$$\nLet $r = \\frac{\\alpha \\Delta t}{2\\Delta x^2}$ (since $\\Delta x = \\Delta y$). After rearranging the terms to group unknowns at time level $n+1/2$ on the left-hand side, we get:\n$$\n-r T_{i-1,j}^{n+1/2} + (1+2r) T_{i,j}^{n+1/2} - r T_{i+1,j}^{n+1/2} = T_{i,j}^n + r (T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n)\n$$\nThis equation is formulated for each interior row $j \\in \\{1, 2, \\dots, N-2\\}$. For a fixed $j$, this is a tridiagonal system of linear equations for the unknown temperatures $T_{i,j}^{n+1/2}$ for $i \\in \\{1, 2, \\dots, N-2\\}$. The boundary values $T_{0,j}^{n+1/2}$ and $T_{N-1,j}^{n+1/2}$ are known and equal to $T_b$. These systems are solved efficiently using the Thomas algorithm (Tridiagonal Matrix Algorithm).\n\nStep 2: Advance from $t_{n+1/2}$ to $t_{n+1}$.\nIn this step, the scheme is explicit in the $x$-direction and implicit in the $y$-direction:\n$$\n\\frac{T_{i,j}^{n+1} - T_{i,j}^{n+1/2}}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^{n+1} - 2T_{i,j}^{n+1} + T_{i,j+1}^{n+1}}{\\Delta y^2} \\right)\n$$\nRearranging gives a tridiagonal system for the $y$-direction:\n$$\n-r T_{i,j-1}^{n+1} + (1+2r) T_{i,j}^{n+1} - r T_{i,j+1}^{n+1} = T_{i,j}^{n+1/2} + r(T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2})\n$$\nThis equation is formulated for each interior column $i \\in \\{1, 2, \\dots, N-2\\}$. For a fixed $i$, this forms a tridiagonal system for the unknowns $T_{i,j}^{n+1}$ for $j \\in \\{1, 2, \\dots, N-2\\}$. The boundary values $T_{i,0}^{n+1}$ and $T_{i,N-1}^{n+1}$ are known and equal to $T_b$. These systems are also solved using the Thomas algorithm.\n\nThe overall algorithm is as follows:\n1.  **Initialization**: Define the simulation parameters $(L, \\alpha, T_b, A, \\sigma, \\Delta t, t_{\\text{final}}, N)$. Construct the spatial grid $x_i, y_j$. Calculate the total number of time steps, $N_t = \\lceil t_{\\text{final}} / \\Delta t \\rceil$. Initialize the temperature field $T$ at $t=0$ using the provided Gaussian function. The boundary points are kept fixed at $T_b$. Pre-calculate the parameter $r$. Construct the constant tridiagonal matrix for the linear solves.\n\n2.  **Time Evolution**: Loop for $n$ from $0$ to $N_t-1$:\n    a. Create an intermediate temperature array, $T_{\\text{intermediate}}$.\n    b. For each interior row $j$, assemble the right-hand side vector from the known values in $T^n$ and solve the tridiagonal system for the corresponding row in $T_{\\text{intermediate}}$. The boundary values are enforced by adjusting the right-hand side vector.\n    c. For each interior column $i$, assemble the right-hand side vector from the known values in $T_{\\text{intermediate}}$ and solve the tridiagonal system for the corresponding column in the new temperature array $T^{n+1}$.\n    d. Update the temperature array: $T \\leftarrow T^{n+1}$.\n\n3.  **Result Extraction**: After the final time step, the temperature field $T$ at $t=t_{\\text{final}}$ is obtained. The temperature at the center grid point, $T_{\\text{center}}$, is found at the index $((N-1)/2, (N-1)/2)$. The maximum temperature, $T_{\\max}$, is found by taking the maximum value over the entire grid.\n\nDue to the symmetry of the domain, boundary conditions, and initial condition, the maximum temperature is expected to remain at the geometric center of the plate throughout the simulation. Therefore, it is expected that $T_{\\text{center}} = T_{\\max}}$ at $t_{\\text{final}}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single test case using the ADI method.\n    \"\"\"\n    L, alpha, T_b, A, sigma, dt, t_final, N = params\n    \n    # 1. Initialization\n    dx = L / (N - 1)\n    # The problem asks to treat N as odd, so center index is integer\n    center_idx = (N - 1) // 2\n\n    # Create spatial grid\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    X, Y = np.meshgrid(x, y)\n\n    # Initialize temperature field from IC\n    T = T_b + A * np.exp(-((X - L/2)**2 + (Y - L/2)**2) / (2 * sigma**2))\n    \n    # Enforce boundary conditions (though IC should be consistent)\n    T[0, :] = T_b\n    T[-1, :] = T_b\n    T[:, 0] = T_b\n    T[:, -1] = T_b\n\n    # ADI parameters\n    r = (alpha * dt) / (2 * dx**2)\n    num_steps = int(np.ceil(t_final / dt))\n\n    # Construct the tridiagonal matrix for the linear solver.\n    # The matrix is for an (N-2) x (N-2) system (interior points).\n    M = N - 2\n    # For solve_banded, the matrix is specified in banded format (3, M)\n    # ab[0,:] = upper diagonal (length M, first element unused)\n    # ab[1,:] = main diagonal (length M)\n    # ab[2,:] = lower diagonal (length M, last element unused)\n    ab = np.zeros((3, M))\n    ab[0, 1:] = -r\n    ab[1, :] = 1 + 2 * r\n    ab[2, :-1] = -r\n    \n    # 2. Time Evolution\n    T_intermediate = np.copy(T)\n\n    for _ in range(num_steps):\n        # --- Step 1: Implicit in x, explicit in y ---\n        for j in range(1, N - 1): # Iterate over interior rows\n            # Construct RHS vector d\n            d = T[j, 1:-1] + r * (T[j-1, 1:-1] - 2*T[j, 1:-1] + T[j+1, 1:-1])\n            # Add boundary contributions\n            d[0] += r * T_b  # Boundary at x=0\n            d[-1] += r * T_b # Boundary at x=L\n\n            # Solve the tridiagonal system for the current row\n            T_intermediate[j, 1:-1] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on intermediate solution\n        T_intermediate[0, :] = T_b\n        T_intermediate[-1, :] = T_b\n        T_intermediate[:, 0] = T_b\n        T_intermediate[:, -1] = T_b\n\n        # --- Step 2: Implicit in y, explicit in x ---\n        for i in range(1, N - 1): # Iterate over interior columns\n            # Construct RHS vector d\n            d = T_intermediate[1:-1, i] + r * (T_intermediate[1:-1, i-1] - 2*T_intermediate[1:-1, i] + T_intermediate[1:-1, i+1])\n            # Add boundary contributions\n            d[0] += r * T_b # Boundary at y=0\n            d[-1] += r * T_b # Boundary at y=L\n\n            # Solve the tridiagonal system for the current column\n            T[1:-1, i] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on final solution for the step\n        T[0, :] = T_b\n        T[-1, :] = T_b\n        T[:, 0] = T_b\n        T[:, -1] = T_b\n        \n    # 3. Result Extraction\n    T_center = T[center_idx, center_idx]\n    T_max = np.max(T)\n    \n    return [T_center, T_max]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, T_b, A, sigma, dt, t_final, N)\n        (0.1, 1.0e-4, 300.0, 100.0, 0.01, 2.5e-4, 0.01, 41),\n        (0.1, 1.0e-4, 300.0, 50.0, 0.02, 1.0e-3, 0.01, 5),\n        (0.1, 1.0e-4, 300.0, 0.0, 0.01, 1.0e-3, 0.02, 31),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format the output string as required\n    results_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2402582"}]}