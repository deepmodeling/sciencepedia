{"hands_on_practices": [{"introduction": "Before tackling complex physical scenarios, it is crucial to build and verify a foundational solver. This first practice focuses on implementing a Finite-Difference Time-Domain (FDTD) scheme for the two-dimensional wave equation with an anisotropic wave speed, where waves travel at different speeds $c_x$ and $c_y$ along the axes. By comparing your numerical results against a provided exact analytical solution, you will perform a critical verification step, ensuring your core algorithm is correct and gaining intuition for how the discretization parameters affect numerical accuracy [@problem_id:2449882].", "problem": "Design and implement a complete program that numerically approximates the solution of the two-dimensional wave equation with anisotropic wave speed and quantitatively compares it to the corresponding exact solution at a specified final time for multiple parameter sets. The governing partial differential equation is\n$$\n\\frac{\\partial^2 u}{\\partial t^2}(x,y,t) = c_x^2 \\,\\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + c_y^2 \\,\\frac{\\partial^2 u}{\\partial y^2}(x,y,t),\n$$\non the rectangular spatial domain $[0,L_x]\\times[0,L_y]$ for time $t\\in[0,T]$, with homogeneous Dirichlet boundary conditions\n$$\nu(0,y,t)=u(L_x,y,t)=u(x,0,t)=u(x,L_y,t)=0,\n$$\nand separable initial conditions\n$$\nu(x,y,0)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big),\\qquad\n\\frac{\\partial u}{\\partial t}(x,y,0)=0.\n$$\nHere $u$ is dimensionless, $x$ and $y$ are in meters, $t$ is in seconds, $c_x$ and $c_y$ are in meters per second, and $L_x$, $L_y$, $T$ are in meters and seconds as appropriate. The exact solution consistent with the above is\n$$\nu_{\\text{exact}}(x,y,t)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big)\\,\\cos(\\omega t),\n\\quad\n\\omega=\\sqrt{c_x^2\\Big(\\frac{m\\pi}{L_x}\\Big)^2 + c_y^2\\Big(\\frac{n\\pi}{L_y}\\Big)^2 }.\n$$\nUse a uniform grid of $N_x\\times N_y$ points including the boundaries in each spatial direction, with spacings $\\Delta x=L_x/(N_x-1)$ and $\\Delta y=L_y/(N_y-1)$, and evolve in time with constant time step $\\Delta t$ for exactly $N=\\operatorname{round}(T/\\Delta t)$ steps. Evaluate the error at $t_N=N\\,\\Delta t$ by sampling $u_{\\text{exact}}$ on the same grid and computing the maximum absolute difference over all grid points. Report this maximum absolute error as a dimensionless real number for each test case below.\n\nYour program must implement this for each of the following three test cases and aggregate the three resulting errors in a single output line as specified under Final Output Format. All inputs are to be treated in International System of Units (SI), that is, meters and seconds. The error values themselves are dimensionless.\n\nTest Suite (each line specifies $\\{L_x,L_y,c_x,c_y,m,n,N_x,N_y,\\Delta t,T\\}$):\n- Case A: $\\{\\,1.0,\\,1.0,\\,1.0,\\,2.0,\\,1,\\,1,\\,81,\\,81,\\,0.005,\\,0.5\\,\\}$\n- Case B: $\\{\\,1.0,\\,1.0,\\,0.5,\\,3.0,\\,2,\\,3,\\,101,\\,71,\\,0.0042,\\,0.28\\,\\}$\n- Case C: $\\{\\,1.0,\\,1.0,\\,2.0,\\,2.5,\\,3,\\,1,\\,65,\\,65,\\,0.0047,\\,0.235\\,\\}$\n\nFinal Output Format: Your program should produce a single line of output containing the three error values as a comma-separated list enclosed in square brackets, in the order of cases A, B, C, for example,\n$$\n[\\varepsilon_A,\\varepsilon_B,\\varepsilon_C],\n$$\nwhere each $\\varepsilon$ is a real number.", "solution": "The problem statement is subjected to analysis for validation before a solution is attempted.\n\nFirst, all provided data and conditions are extracted verbatim.\nGoverning Equation:\n$$\n\\frac{\\partial^2 u}{\\partial t^2}(x,y,t) = c_x^2 \\,\\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + c_y^2 \\,\\frac{\\partial^2 u}{\\partial y^2}(x,y,t)\n$$\nDomain: $x \\in [0,L_x]$, $y \\in [0,L_y]$, $t \\in [0,T]$.\nBoundary Conditions (Homogeneous Dirichlet):\n$$\nu(0,y,t)=u(L_x,y,t)=u(x,0,t)=u(x,L_y,t)=0\n$$\nInitial Conditions:\n$$\nu(x,y,0)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big),\\qquad \\frac{\\partial u}{\\partial t}(x,y,0)=0\n$$\nExact Solution:\n$$\nu_{\\text{exact}}(x,y,t)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big)\\,\\cos(\\omega t),\n\\quad\n\\omega=\\sqrt{c_x^2\\Big(\\frac{m\\pi}{L_x}\\Big)^2 + c_y^2\\Big(\\frac{n\\pi}{L_y}\\Big)^2 }\n$$\nNumerical Grid:\n$N_x \\times N_y$ points; $\\Delta x=L_x/(N_x-1)$, $\\Delta y=L_y/(N_y-1)$; $\\Delta t$ is the time step.\nNumber of Steps: $N=\\operatorname{round}(T/\\Delta t)$.\nError Metric: Maximum absolute difference between numerical and exact solutions at $t_N = N \\Delta t$.\nTest Cases:\n- Case A: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=1.0,\\,c_y=2.0,\\,m=1,\\,n=1,\\,N_x=81,\\,N_y=81,\\,\\Delta t=0.005,\\,T=0.5\\}$\n- Case B: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=0.5,\\,c_y=3.0,\\,m=2,\\,n=3,\\,N_x=101,\\,N_y=71,\\,\\Delta t=0.0042,\\,T=0.28\\}$\n- Case C: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=2.0,\\,c_y=2.5,\\,m=3,\\,n=1,\\,N_x=65,\\,N_y=65,\\,\\Delta t=0.0047,\\,T=0.235\\}$\n\nNext, the problem is validated against formal criteria.\n1.  **Scientific Grounding**: The problem describes the two-dimensional linear wave equation with anisotropic wave speed, a fundamental model in physics. The provided initial and boundary conditions are standard. The given exact solution is readily verified by substitution into the partial differential equation and checking the initial and boundary conditions. The problem is mathematically and scientifically sound.\n2.  **Well-Posedness**: The problem is a classic initial-boundary value problem for a hyperbolic PDE. With the given smooth initial data and Dirichlet boundary conditions, a unique and stable solution is guaranteed. The numerical task is also precisely defined.\n3.  **Objectivity**: The problem is stated in quantitative, unambiguous language. All parameters are defined.\n4.  **Completeness and Consistency**: All required information is provided for each test case.\n5.  **Feasibility**: The parameters for the numerical simulation must satisfy the Courant-Friedrichs-Lewy (CFL) stability condition for an explicit finite-difference scheme. The condition for the 2D anisotropic wave equation is $S = \\Delta t \\sqrt{ (c_x/\\Delta x)^2 + (c_y/\\Delta y)^2 } \\leq 1$. Let's check this for each case:\n    - Case A: $\\Delta x = 1/(80)$, $\\Delta y = 1/(80)$. $S = 0.005 \\sqrt{(1.0/(1/80))^2 + (2.0/(1/80))^2} = 0.005 \\sqrt{80^2 + 160^2} \\approx 0.894 < 1$. Stable.\n    - Case B: $\\Delta x = 1/(100)$, $\\Delta y = 1/(70)$. $S = 0.0042 \\sqrt{(0.5/(1/100))^2 + (3.0/(1/70))^2} = 0.0042 \\sqrt{50^2 + 210^2} \\approx 0.907 < 1$. Stable.\n    - Case C: $\\Delta x = 1/(64)$, $\\Delta y = 1/(64)$. $S = 0.0047 \\sqrt{(2.0/(1/64))^2 + (2.5/(1/64))^2} = 0.0047 \\sqrt{128^2 + 160^2} \\approx 0.963 < 1$. Stable.\nAll test cases use parameters that result in a stable numerical scheme.\n\nVerdict: The problem is valid. It is a well-defined, scientifically sound, and numerically tractable problem. We proceed to the solution.\n\nThe solution is constructed using the Finite-Difference Time-Domain (FDTD) method. We discretize the spatial domain into a grid $\\{ (x_i, y_j) | x_i = i\\Delta x, y_j = j\\Delta y \\}$ for $i \\in \\{0, ..., N_x-1\\}$ and $j \\in \\{0, ..., N_y-1\\}$, and time as $t_k = k\\Delta t$. Let $u_{i,j}^k$ be the numerical approximation of $u(x_i, y_j, t_k)$.\n\nThe second-order partial derivatives are approximated using second-order central difference formulas:\n$$\n\\frac{\\partial^2 u}{\\partial t^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i,j}^{k+1} - 2u_{i,j}^k + u_{i,j}^{k-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k}{(\\Delta y)^2}\n$$\nSubstituting these into the governing PDE yields the explicit update scheme. For all interior grid points $(i,j)$ where $1 \\leq i \\leq N_x-2$ and $1 \\leq j \\leq N_y-2$:\n$$\n\\frac{u_{i,j}^{k+1} - 2u_{i,j}^k + u_{i,j}^{k-1}}{(\\Delta t)^2} = c_x^2 \\frac{u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k}{(\\Delta x)^2} + c_y^2 \\frac{u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k}{(\\Delta y)^2}\n$$\nSolving for $u_{i,j}^{k+1}$, we obtain the three-level time-stepping scheme:\n$$\nu_{i,j}^{k+1} = 2u_{i,j}^k - u_{i,j}^{k-1} + \\left(\\frac{c_x \\Delta t}{\\Delta x}\\right)^2(u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k) + \\left(\\frac{c_y \\Delta t}{\\Delta y}\\right)^2(u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k)\n$$\nThis formula computes the solution at time step $k+1$ from the solutions at steps $k$ and $k-1$. This applies for $k \\geq 1$.\n\nFor the first time step ($k=0$), we must use the initial conditions. The state $u_{i,j}^0$ is given by $u(x_i, y_j, 0)$. To find $u_{i,j}^1$, we need the fictitious state $u_{i,j}^{-1}$. This is obtained by discretizing the initial velocity condition, $\\frac{\\partial u}{\\partial t}(x,y,0)=0$, using a central difference:\n$$\n\\frac{\\partial u}{\\partial t}\\Bigg|_{i,j,0} \\approx \\frac{u_{i,j}^1 - u_{i,j}^{-1}}{2\\Delta t} = 0 \\implies u_{i,j}^{-1} = u_{i,j}^1\n$$\nSubstituting $u_{i,j}^{-1} = u_{i,j}^1$ into the general update formula for $k=0$:\n$$\nu_{i,j}^1 = 2u_{i,j}^0 - u_{i,j}^1 + (\\Delta t)^2 \\left[ c_x^2 \\frac{u_{i+1,j}^0 - 2u_{i,j}^0 + u_{i-1,j}^0}{\\Delta x^2} + c_y^2 \\frac{u_{i,j+1}^0 - 2u_{i,j}^0 + u_{i,j-1}^0}{\\Delta y^2} \\right]\n$$\nSolving for $u_{i,j}^1$ gives a two-level scheme for the first step:\n$$\nu_{i,j}^1 = u_{i,j}^0 + \\frac{(\\Delta t)^2}{2} \\left[ c_x^2 \\frac{u_{i+1,j}^0 - 2u_{i,j}^0 + u_{i-1,j}^0}{\\Delta x^2} + c_y^2 \\frac{u_{i,j+1}^0 - 2u_{i,j}^0 + u_{i,j-1}^0}{\\Delta y^2} \\right]\n$$\nThe homogeneous Dirichlet boundary conditions $u=0$ are enforced by setting the values on the borders of the numerical grid to zero for all time steps.\n\nThe overall algorithm is as follows:\n1.  Initialize parameters and create the spatial grid.\n2.  Compute the initial state $u^0$ at $t=0$. This array will represent the solution at the \"previous\" time step, $u_{\\text{prev}}$.\n3.  Compute the state $u^1$ at $t=\\Delta t$ using the special first-step formula. This array represents the \"current\" solution, $u_{\\text{curr}}$.\n4.  Iterate from $k=1$ to $N-1$:\n    a. Calculate the next state $u^{k+1}$ using the general three-level update formula, from $u_{\\text{curr}} (= u^k)$ and $u_{\\text{prev}} (= u^{k-1})$.\n    b. Update the state arrays for the next iteration: $u_{\\text{prev}}$ becomes $u_{\\text{curr}}$, and $u_{\\text{curr}}$ becomes the newly computed $u^{k+1}$. This is managed efficiently to avoid repeated memory allocation.\n5.  After $N$ steps, the array $u_{\\text{curr}}$ holds the numerical solution at the final time $t_N = N \\Delta t$.\n6.  Compute the exact solution on the same grid at $t_N$.\n7.  Calculate the maximum absolute error by comparing the numerical and exact solutions point-wise over the entire grid.\n\nThis procedure is implemented for each test case. Vectorized array operations with NumPy are used for efficiency.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (Lx, Ly, cx, cy, m, n, Nx, Ny, dt, T)\n        (1.0, 1.0, 1.0, 2.0, 1, 1, 81, 81, 0.005, 0.5),   # Case A\n        (1.0, 1.0, 0.5, 3.0, 2, 3, 101, 71, 0.0042, 0.28), # Case B\n        (1.0, 1.0, 2.0, 2.5, 3, 1, 65, 65, 0.0047, 0.235), # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        error = solve_wave_equation_2d(*params)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_wave_equation_2d(Lx, Ly, cx, cy, m, n, Nx, Ny, dt, T):\n    \"\"\"\n    Numerically solves the 2D anisotropic wave equation for a single test case.\n\n    Implements a finite-difference time-domain (FDTD) scheme with second-order\n    central differences in space and time.\n    \"\"\"\n    # 1. Grid and parameter setup\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    \n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    # 'ij' indexing ensures X.shape is (Nx, Ny) and corresponds to u[i, j]\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Initial conditions\n    # u_prev stores the solution at the previous time step (k-1)\n    # u_curr stores the solution at the current time step (k)\n    \n    # Initialize u_prev to u(t=0)\n    u_prev = np.sin(m * np.pi * X / Lx) * np.sin(n * np.pi * Y / Ly)\n    \n    # Initialize u_curr to zeros, which respects boundary conditions\n    u_curr = np.zeros_like(u_prev)\n\n    # 3. Calculate first time step (t=dt) using special update rule\n    # This is a discrete version of the spatial operator L(u)\n    lap_u0 = (cx**2 * (u_prev[0:-2, 1:-1] - 2*u_prev[1:-1, 1:-1] + u_prev[2:, 1:-1]) / dx**2 +\n              cy**2 * (u_prev[1:-1, 0:-2] - 2*u_prev[1:-1, 1:-1] + u_prev[1:-1, 2:]) / dy**2)\n    \n    # Update interior points for u(t=dt)\n    u_curr[1:-1, 1:-1] = u_prev[1:-1, 1:-1] + 0.5 * dt**2 * lap_u0\n\n    # 4. Time-stepping loop\n    num_steps = round(T / dt)\n    # Loop from k=1 up to num_steps-1 to calculate u^2, u^3, ..., u^N\n    for _ in range(1, num_steps):\n        # Calculate Laplacian of the current state u_curr\n        lap_uk = (cx**2 * (u_curr[0:-2, 1:-1] - 2*u_curr[1:-1, 1:-1] + u_curr[2:, 1:-1]) / dx**2 +\n                  cy**2 * (u_curr[1:-1, 0:-2] - 2*u_curr[1:-1, 1:-1] + u_curr[1:-1, 2:]) / dy**2)\n        \n        # Calculate the interior of the next state u_next using the general update rule\n        u_next_interior = (2.0 * u_curr[1:-1, 1:-1] - u_prev[1:-1, 1:-1] + dt**2 * lap_uk)\n        \n        # Swap arrays to advance time, reusing memory\n        # u_prev will now hold u_curr's data\n        # u_curr will be overwritten with u_next's data\n        u_prev, u_curr = u_curr, u_prev\n        u_curr[1:-1, 1:-1] = u_next_interior\n\n    # 5. Final time and exact solution\n    final_time = num_steps * dt\n    omega = np.sqrt(cx**2 * (m * np.pi / Lx)**2 + cy**2 * (n * np.pi / Ly)**2)\n    \n    u_exact = (np.sin(m * np.pi * X / Lx) * \n               np.sin(n * np.pi * Y / Ly) * \n               np.cos(omega * final_time))\n    \n    # 6. Calculate and return final error\n    # The error is the maximum absolute difference over all grid points.\n    error = np.max(np.abs(u_curr - u_exact))\n    \n    return error\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2449882"}, {"introduction": "Many problems in computational physics involving wave phenomena are best solved using methods other than finite differences. This exercise introduces the powerful Split-Step Fourier Method to solve the time-dependent Schrödinger equation, a \"wave equation\" that governs quantum mechanics. You will simulate the evolution of a Gaussian wave packet in an unstable inverted harmonic potential, a scenario that dramatically amplifies any errors, making it an excellent test for the accuracy and stability of your implementation. This practice will add a versatile and highly efficient spectral method to your computational toolkit [@problem_id:2449888].", "problem": "Consider the one-dimensional time-dependent Schrödinger equation for a particle of unit mass in a spatially varying potential on a finite interval with periodic boundary conditions. Use dimensionless units where the reduced Planck constant is set to unity, that is, $\\hbar = 1$, and the mass is $m = 1$. The wave function $\\psi(x,t)$ satisfies\n$$\ni \\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t),\n$$\nwith the inverted harmonic potential\n$$\nV(x) \\;=\\; -k\\,x^2,\n$$\nwhere $k \\ge 0$ is a real constant.\n\nThe computational domain is the interval $x \\in [-L, L)$ with periodic boundary conditions, where $L = 50$. The initial condition at time $t=0$ is a normalized Gaussian wave packet centered at $x_0$, with width parameter $\\sigma$ and mean momentum $p_0$,\n$$\n\\psi(x,0) \\;=\\; \\frac{1}{(\\pi \\sigma^2)^{1/4}} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} + i\\,p_0\\,(x-x_0) \\right).\n$$\nTake $x_0 = -8$, $\\sigma = 1$, and $p_0 = 2$. Use a uniform spatial grid of $N = 2048$ points spanning $[-L,L)$, and a uniform temporal grid with time step $\\Delta t = 10^{-3}$.\n\nYour task is to compute a numerical approximation to $\\psi(x,t)$ over the given domain and time horizon for each of the following three test cases. For each test case, report a single scalar quantity as specified below. All quantities are dimensionless.\n\nTest suite:\n- Case A (free propagation): $k = 0$, final time $T = 1.5$. Let $\\langle x \\rangle_T$ denote the numerically computed expectation value of position at time $T$, defined by\n$$\n\\langle x \\rangle_T \\;=\\; \\frac{\\int_{-L}^{L} x\\,|\\psi(x,T)|^2\\,dx}{\\int_{-L}^{L} |\\psi(x,T)|^2\\,dx}.\n$$\nFor a free particle with $m=1$, the exact prediction for the center is $x_{\\mathrm{pred}}(T) = x_0 + p_0\\,T$. Output the absolute error\n$$\nE_A \\;=\\; \\left|\\, \\langle x \\rangle_T \\;-\\; x_{\\mathrm{pred}}(T) \\,\\right|.\n$$\n- Case B (weak inverted potential): $k = 0.02$, final time $T = 1.0$. Let $\\mathcal{N}_T = \\int_{-L}^{L} |\\psi(x,T)|^2\\,dx$ be the norm at time $T$. Output the absolute deviation from unity\n$$\nE_B \\;=\\; \\left|\\, 1 \\;-\\; \\mathcal{N}_T \\,\\right|.\n$$\n- Case C (stronger inverted potential): $k = 0.2$, final time $T = 0.8$. Let $\\sigma_x(t)$ denote the standard deviation of position at time $t$,\n$$\n\\sigma_x(t) \\;=\\; \\sqrt{\\langle x^2 \\rangle_t - \\langle x \\rangle_t^2}, \\quad \\langle x^n \\rangle_t \\;=\\; \\frac{\\int_{-L}^{L} x^n\\,|\\psi(x,t)|^2\\,dx}{\\int_{-L}^{L} |\\psi(x,t)|^2\\,dx}.\n$$\nOutput the ratio\n$$\nR_C \\;=\\; \\frac{\\sigma_x(T)}{\\sigma_x(0)}.\n$$\n\nAll spatial integrals must be computed consistently with the specified uniform grid. Your program should produce a single line of output containing the results in the order $[E_A, E_B, R_C]$ as a comma-separated list enclosed in square brackets, for example, $[a,b,c]$, where each of $a$, $b$, and $c$ is a floating-point number.", "solution": "The problem is valid. It presents a well-posed initial-boundary value problem for the one-dimensional time-dependent Schrödinger equation, a fundamental equation in quantum mechanics. All parameters, conditions, and objectives are specified with sufficient clarity and scientific rigor to permit a unique numerical solution.\n\nThe problem requires the numerical solution of the time-dependent Schrödinger equation (TDSE):\n$$\ni \\frac{\\partial \\psi(x,t)}{\\partial t} = \\hat{H} \\psi(x,t)\n$$\nwhere the Hamiltonian operator $\\hat{H}$ is the sum of the kinetic energy operator $\\hat{T}$ and the potential energy operator $\\hat{V}$:\n$$\n\\hat{H} = \\hat{T} + \\hat{V} = -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x)\n$$\nwith constants $\\hbar=1$ and $m=1$. Since the kinetic and potential operators, $\\hat{T}$ and $\\hat{V}$, do not commute in general, the time-evolution operator $e^{-i\\hat{H}\\Delta t}$ cannot be naively factored.\n\nThe most appropriate and efficient numerical method for this class of problems is the **Split-Step Fourier Method**. We employ a second-order symmetric splitting scheme, also known as Strang splitting, which is both accurate and unitary, thus conserving the norm $|\\psi|^2$ over time. This scheme approximates the evolution operator for a single time step $\\Delta t$ as:\n$$\nU(\\Delta t) = e^{-i\\hat{H}\\Delta t} \\approx e^{-i\\hat{V}\\Delta t/2} \\, e^{-i\\hat{T}\\Delta t} \\, e^{-i\\hat{V}\\Delta t/2} + \\mathcal{O}(\\Delta t^3)\n$$\nThe global error over a finite time interval $T$ is of order $\\mathcal{O}(\\Delta t^2)$. The action of this operator is implemented in three sequential steps for each time increment. Let $\\psi_n = \\psi(x, n\\Delta t)$.\n\n$1$. **First Potential Half-Step:** The wave function is evolved under the potential operator $\\hat{V}$ for a duration of $\\Delta t/2$. In coordinate representation, this is a simple multiplication:\n$$\n\\psi'(x) = e^{-iV(x)\\Delta t/2} \\psi_n(x)\n$$\n\n$2$. **Full Kinetic Step:** The wave function is then evolved under the kinetic operator $\\hat{T}$ for a full time step $\\Delta t$. This operation is most efficiently performed in Fourier (momentum) space. The kinetic operator $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ becomes a multiplicative operator $\\frac{k_x^2}{2}$ in the space of wave numbers $k_x$. The procedure is:\n   a. Transform $\\psi'(x)$ to Fourier space: $\\tilde{\\psi}'(k_x) = \\mathcal{F}[\\psi'(x)]$.\n   b. Multiply by the kinetic evolution factor: $\\tilde{\\psi}''(k_x) = e^{-i (k_x^2/2) \\Delta t} \\tilde{\\psi}'(k_x)$.\n   c. Transform back to coordinate space: $\\psi''(x) = \\mathcal{F}^{-1}[\\tilde{\\psi}''(k_x)]$.\nHere, $\\mathcal{F}$ and $\\mathcal{F}^{-1}$ denote the Fast Fourier Transform (FFT) and its inverse, respectively.\n\n$3$. **Second Potential Half-Step:** A final evolution under the potential operator for $\\Delta t/2$ completes the time step:\n$$\n\\psi_{n+1}(x) = e^{-iV(x)\\Delta t/2} \\psi''(x)\n$$\n\nThe overall numerical algorithm is as follows:\nFirst, we discretize the spatial domain $x \\in [-L, L)$ using $N$ uniformly spaced points $x_j$ with grid spacing $\\Delta x = 2L/N$. We also define the corresponding grid of wave numbers $k_{x,j}$ required for the FFT.\n\nNext, we evaluate the initial wave function $\\psi(x,0)$ on the spatial grid $x_j$.\n\nThe system is then evolved from $t=0$ to the final time $T$ by repeatedly applying the three-step Strang splitting procedure for a total of $N_t = T/\\Delta t$ time steps.\n\nFinally, we compute the required physical observables. Spatial integrals of a function $f(x)$ are approximated by a discrete sum over the grid points, consistent with the problem specification:\n$$\n\\int_{-L}^{L} f(x)\\,dx \\approx \\sum_{j=0}^{N-1} f(x_j)\\,\\Delta x\n$$\nThe expectation value of an observable $\\hat{A}$ is computed as:\n$$\n\\langle A \\rangle_t = \\frac{\\int_{-L}^{L} \\psi^*(x,t) [\\hat{A}\\psi(x,t)] \\,dx}{\\int_{-L}^{L} |\\psi(x,t)|^2\\,dx} \\approx \\frac{\\sum_j (\\psi^* \\hat{A}\\psi)_j}{\\sum_j |\\psi_j|^2}\n$$\nwhere the $\\Delta x$ factors cancel. For position-dependent observables like $x^n$, this simplifies to a weighted average over the probability density $|\\psi(x,t)|^2$.\n\nThe specific quantities for each case are calculated based on these principles using the final wave function $\\psi(x,T)$ and, for Case C, the initial wave function $\\psi(x,0)$.\n\n- **Case A:** $E_A = |\\langle x \\rangle_T - (x_0 + p_0T)|$. $\\langle x \\rangle_T$ is computed from the final state $\\psi(x,T)$.\n- **Case B:** $E_B = |1 - \\mathcal{N}_T|$. The norm $\\mathcal{N}_T = \\int_{-L}^{L} |\\psi(x,T)|^2 dx$ is computed. As the numerical scheme is unitary, this value is expected to be very small, reflecting the conservation of probability.\n- **Case C:** $R_C = \\sigma_x(T)/\\sigma_x(0)$. The standard deviation $\\sigma_x(t) = \\sqrt{\\langle x^2 \\rangle_t - \\langle x \\rangle_t^2}$ is computed for both $t=0$ and $t=T$.\n\nThe provided code implements this complete procedure to determine the values $E_A$, $E_B$, and $R_C$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-dependent Schrödinger equation using the split-step Fourier method\n    for three specified test cases and prints the results.\n    \"\"\"\n\n    # Global parameters from the problem statement\n    L_param = 50.0\n    N_param = 2048\n    dt_param = 1e-3\n    x0_param = -8.0\n    sigma_param = 1.0\n    p0_param = 2.0\n\n    # Discretization of the spatial and momentum domains\n    dx = 2 * L_param / N_param\n    x_grid = -L_param + np.arange(N_param) * dx\n    k_grid = 2 * np.pi * np.fft.fftfreq(N_param, d=dx)\n\n    # Initial wave function (normalized Gaussian wave packet)\n    norm_const = (np.pi * sigma_param**2)**(-0.25)\n    phase = 1j * p0_param * (x_grid - x0_param)\n    envelope = -(x_grid - x0_param)**2 / (2 * sigma_param**2)\n    psi0 = norm_const * np.exp(envelope + phase)\n\n    def compute_observables(psi):\n        \"\"\"Computes norm, expectation value of x, and expectation value of x^2.\"\"\"\n        prob_density = np.abs(psi)**2\n        norm_sum = np.sum(prob_density)\n        \n        # Expectation values are ratios, so the dx factor from integration cancels\n        x_exp = np.sum(x_grid * prob_density) / norm_sum\n        x2_exp = np.sum(x_grid**2 * prob_density) / norm_sum\n        \n        # The true norm requires multiplication by dx\n        norm_val = dx * norm_sum\n        \n        return norm_val, x_exp, x2_exp\n\n    def run_simulation(k, T):\n        \"\"\"\n        Runs the split-step simulation for a given potential parameter k and final time T.\n        \"\"\"\n        num_steps = int(round(T / dt_param))\n\n        # Potential V(x) = -k*x^2\n        V = -k * x_grid**2\n        \n        # Pre-compute time evolution operators for efficiency\n        potential_op_half = np.exp(-0.5j * V * dt_param)\n        kinetic_op_full = np.exp(-1.0j * 0.5 * k_grid**2 * dt_param)\n        \n        psi = psi0.copy()\n        \n        for _ in range(num_steps):\n            # Strang splitting a.k.a. symmetric split-step method\n            psi = potential_op_half * psi\n            psi = np.fft.ifft(kinetic_op_full * np.fft.fft(psi))\n            psi = potential_op_half * psi\n            \n        return psi\n\n    # --- Test Case A: Free Propagation ---\n    k_A = 0.0\n    T_A = 1.5\n    psi_A = run_simulation(k_A, T_A)\n    _, x_exp_A, _ = compute_observables(psi_A)\n    x_pred_A = x0_param + p0_param * T_A\n    E_A = np.abs(x_exp_A - x_pred_A)\n\n    # --- Test Case B: Weak Inverted Potential ---\n    k_B = 0.02\n    T_B = 1.0\n    psi_B = run_simulation(k_B, T_B)\n    norm_T_B, _, _ = compute_observables(psi_B)\n    E_B = np.abs(1.0 - norm_T_B)\n\n    # --- Test Case C: Stronger Inverted Potential ---\n    k_C = 0.2\n    T_C = 0.8\n    # Calculate observables at t=0\n    _, x_exp_0, x2_exp_0 = compute_observables(psi0)\n    variance_0 = x2_exp_0 - x_exp_0**2\n    sigma_x_0 = np.sqrt(variance_0)\n    \n    # Run simulation and calculate observables at t=T\n    psi_C = run_simulation(k_C, T_C)\n    _, x_exp_C, x2_exp_C = compute_observables(psi_C)\n    variance_C = x2_exp_C - x_exp_C**2\n    sigma_x_T = np.sqrt(variance_C)\n    \n    R_C = sigma_x_T / sigma_x_0\n    \n    # Collect results and format output\n    results = [E_A, E_B, R_C]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2449888"}, {"introduction": "This final practice bridges the gap from abstract numerical methods to real-world physical analysis by simulating the acoustics of a 2D room. You will apply the FDTD method to model the propagation of a sound pulse, but with a new challenge: implementing Neumann boundary conditions to represent sound-reflecting rigid walls. The true test of your simulation will be in the analysis, where you will use the Fast Fourier Transform (FFT) on the recorded pressure signal to identify the room's resonant frequencies, or standing wave modes. This exercise mirrors the complete workflow of a computational physicist: building a solver, simulating a phenomenon, and processing the output data to extract meaningful physical insights [@problem_id:2449910].", "problem": "Consider the two-dimensional scalar acoustic pressure field governed by the linear wave equation\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right),\n$$\nin a rectangular domain $$0 \\le x \\le L_x$$ and $$0 \\le y \\le L_y$$, with rigid walls so that the outward-normal derivative of pressure vanishes on the boundary,\n$$\n\\left.\\frac{\\partial p}{\\partial n}\\right|_{\\partial \\Omega} = 0,\n$$\nwhich are Neumann boundary conditions. Let $$c$$ be the constant speed of sound in meters per second. You will model the time evolution numerically using a second-order accurate central-difference scheme in both time and space on a uniform Cartesian grid with $$\\Delta x = \\Delta y$$. Let $$\\Delta t$$ be the time step. The scheme must satisfy a Courant–Friedrichs–Lewy (CFL) stability constraint appropriate to two space dimensions with equal spacing. The initial state is at rest, and the field is excited by a single impulsive source applied at the first time step at an interior grid node. A receiver at another interior grid node records the pressure time series. Use no physical damping.\n\nYour task is to implement a complete program that:\n- Discretizes the wave equation with second-order central differences in time and space.\n- Enforces the Neumann boundary condition for $$p$$ on all four walls consistently with the discretization.\n- Uses a uniform spatial step $$\\Delta x = \\Delta y$$.\n- Uses a time step $$\\Delta t$$ chosen via a Courant number $$s$$ that satisfies the two-dimensional stability constraint, with $$\\Delta t = s \\, \\Delta x / c$$.\n- Injects a unit impulsive source at time index $$n=0$$ at a source grid node and records the pressure at a receiver grid node for a specified total simulation time $$T$$.\n- Estimates the three lowest standing-wave mode frequencies (in hertz) by computing the discrete Fourier transform magnitude of the recorded time series and, for each of the three analytically lowest nonzero modes, searching for the dominant spectral peak in a narrow frequency window around the corresponding analytical frequency.\n\nUse the following foundational facts only:\n- The scalar wave equation above and the definition of Neumann boundary condition on a rectangle.\n- The two-dimensional uniform-grid central-difference approximations for first and second derivatives.\n- The stability constraint concept for explicit hyperbolic schemes in multiple dimensions.\n- The analytical nonzero eigenfrequencies of a rectangular rigid-walled cavity (Neumann boundary conditions) are given by\n$$\nf_{m,n} = \\frac{c}{2}\\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2},\n$$\nfor nonnegative integers $$m,n$$ not both zero, with $$f_{0,0}=0$$ excluded. Degeneracy can occur when $$L_x=L_y$$.\n\nNumerical details you must adhere to:\n- Use $$\\Delta x$$ in meters, $$\\Delta t$$ in seconds, $$c$$ in meters per second, lengths $$L_x, L_y$$ in meters, and total time $$T$$ in seconds. Frequencies must be reported in hertz.\n- Choose the Courant number $$s$$ such that the explicit scheme is stable in two dimensions with $$\\Delta x = \\Delta y$$.\n- To estimate modal frequencies robustly, apply a Hann window to the recorded time series before computing its discrete Fourier transform. Remove the mean value of the recorded signal before windowing to suppress the zero-frequency component. When searching for the measured frequency corresponding to a given analytical $$f_{m,n}$$, search for the largest-magnitude spectral bin in a symmetric window of width set as the larger of $$5\\ \\text{Hz}$$ or $$0.15 f_{m,n}$$, centered at $$f_{m,n}$$, clamped to the overall analysis band.\n- Express all final frequency errors as absolute relative errors, that is $$\\left| \\hat{f} - f \\right| / f$$ as a decimal (unitless).\n\nTest suite:\nRun your program for the three test cases below. In all cases, set $$c = 343\\ \\text{m/s}$$, $$\\Delta x = \\Delta y = 0.1\\ \\text{m}$$, Courant number $$s = 0.5$$ so that $$\\Delta t = s \\Delta x / c$$, and a total simulated time $$T = 1.6\\ \\text{s}$$. Place the impulsive source at $$x_s = 0.37 L_x$$, $$y_s = 0.41 L_y$$, and the receiver at $$x_r = 0.23 L_x$$, $$y_r = 0.67 L_y$$, both snapped to the nearest grid nodes. Use an analysis band of $$20\\ \\text{Hz} \\le f \\le 300\\ \\text{Hz}$$.\n- Case 1 (general rectangular room): $$L_x = 3.0\\ \\text{m}$$, $$L_y = 4.0\\ \\text{m}$$.\n- Case 2 (square room): $$L_x = 2.0\\ \\text{m}$$, $$L_y = 2.0\\ \\text{m}$$.\n- Case 3 (elongated room): $$L_x = 5.0\\ \\text{m}$$, $$L_y = 2.0\\ \\text{m}$$.\n\nFor each case, compute the three lowest nonzero analytical modal frequencies $$f_{m,n}$$, identify their measured counterparts from the simulated spectrum as described, and report the three absolute relative errors as decimals.\n\nFinal output format:\nYour program should produce a single line of output containing the nine results (three per test case in the order Case 1, then Case 2, then Case 3), as a comma-separated list enclosed in square brackets (e.g., \"[r1,r2,r3,r4,r5,r6,r7,r8,r9]\"). Each entry must be a decimal number.", "solution": "The problem statement has been evaluated and is determined to be scientifically sound, well-posed, and complete. It describes a standard problem in computational acoustics: the simulation of wave propagation in a closed two-dimensional domain and the subsequent analysis of its resonant frequencies. We proceed with the derivation and implementation of the solution.\n\nThe governing equation is the two-dimensional linear scalar wave equation for acoustic pressure $$p(x,y,t)$$:\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right) = c^2 \\nabla^2 p\n$$\nwhere $$c$$ is the constant speed of sound. The problem will be solved numerically using the finite-difference time-domain (FDTD) method on a uniform Cartesian grid.\n\nLet the discrete pressure field be denoted $$p_{i,j}^n \\approx p(i\\Delta x, j\\Delta y, n\\Delta t)$$, where $$i, j, n$$ are integer indices for space and time, and $$\\Delta x, \\Delta y, \\Delta t$$ are the corresponding step sizes. We are given $$\\Delta x = \\Delta y$$.\n\nWe discretize the partial derivatives using second-order accurate central difference approximations:\n$$\n\\frac{\\partial^2 p}{\\partial t^2} \\approx \\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\nabla^2 p \\approx \\frac{p_{i+1,j}^n - 2p_{i,j}^n + p_{i-1,j}^n}{(\\Delta x)^2} + \\frac{p_{i,j+1}^n - 2p_{i,j}^n + p_{i,j-1}^n}{(\\Delta y)^2}\n$$\nSubstituting these into the wave equation and noting that $$\\Delta x = \\Delta y$$, we obtain the discrete update equation:\n$$\n\\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{(\\Delta t)^2} = c^2 \\left( \\frac{p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n}{(\\Delta x)^2} \\right)\n$$\nSolving for the pressure at the next time step, $$p_{i,j}^{n+1}$$, yields the explicit FDTD scheme:\n$$\np_{i,j}^{n+1} = 2p_{i,j}^n - p_{i,j}^{n-1} + \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 \\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n \\right)\n$$\nThe quantity $$s = c\\Delta t/\\Delta x$$ is the Courant number. The update equation is then:\n$$\np_{i,j}^{n+1} = 2p_{i,j}^n - p_{i,j}^{n-1} + s^2 \\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n \\right)\n$$\nFor this explicit scheme to be numerically stable in two dimensions with $$\\Delta x = \\Delta y$$, the Courant number $$s$$ must satisfy the Courant–Friedrichs–Lewy (CFL) condition:\n$$\ns \\le \\frac{1}{\\sqrt{2}} \\approx 0.7071\n$$\nThe specified Courant number $$s = 0.5$$ adheres to this condition, ensuring stability.\n\nThe simulation starts from a state of rest, meaning the initial conditions are $$p(x,y,0) = 0$$ and $$\\frac{\\partial p}{\\partial t}(x,y,0) = 0$$. In discrete form, $$p_{i,j}^0 = 0$$. The zero-velocity condition is implemented using a central difference for the time derivative at $$n=0$$:\n$$\n\\frac{p_{i,j}^1 - p_{i,j}^{-1}}{2\\Delta t} = 0 \\implies p_{i,j}^{-1} = p_{i,j}^1\n$$\nSubstituting $$n=0$$ into the update equation and using $$p_{i,j}^{-1} = p_{i,j}^1$$ allows us to eliminate the need for the fictitious $$n=-1$$ time level. However, a simpler approach is to initialize both pressure fields, $$p^n$$ and $$p^{n-1}$$, to zero. The impulsive source is introduced as an additive term at the first time step, $$n=0$$. Let the source be at grid node $$(i_s, j_s)$$. The update equation for $$p_{i,j}^1$$ includes a source term, which we model by adding a value proportional to $$\\Delta t$$ to the pressure field at the source location during the first update step. This modifies the calculation of $$p^1$$:\n$$\np_{i_s,j_s}^1 = 2p_{i_s,j_s}^0 - p_{i_s,j_s}^{-1} + s^2(...)_{i_s,j_s}^0 + \\text{source} \\cdot \\delta_{n,0}\n$$\nWith resting initial conditions, this simplifies the time evolution. The source is applied at time index $$n=0$$, affecting the computation of the pressure field at time index $$n=1$$.\n\nThe boundary conditions are of the rigid-wall (Neumann) type, $$\\partial p / \\partial n = 0$$, where $$\\mathbf{n}$$ is the outward-pointing normal vector. For the wall at $$x=0$$, this is $$\\partial p / \\partial x = 0$$. Discretizing this condition with a second-order central difference at the boundary node $$i=0$$ gives:\n$$\n\\frac{p_{1,j}^n - p_{-1,j}^n}{2\\Delta x} = 0 \\implies p_{-1,j}^n = p_{1,j}^n\n$$\nwhere $$p_{-1,j}^n$$ is the pressure at a \"ghost point\" outside the domain. This ghost point value is used in the main update stencil for boundary points. For example, at $$i=0$$, the term $$p_{i-1,j}^n$$ becomes $$p_{1,j}^n$$. The update rule for a point on the left wall ($$i=0$$) becomes:\n$$\np_{0,j}^{n+1} = 2p_{0,j}^n - p_{0,j}^{n-1} + s^2 \\left( 2p_{1,j}^n + p_{0,j+1}^n + p_{0,j-1}^n - 4p_{0,j}^n \\right)\n$$\nAnalogous rules apply to the other three walls and the four corners. A systematic way to implement this is to pad the pressure grid with a layer of ghost cells and populate them according to these relations before each spatial derivative calculation.\n\nThe simulation proceeds by iteratively applying the update equation for a total number of time steps $$N_t = \\lfloor T/\\Delta t \\rfloor$$. At each step, the pressure at the receiver location $$(i_r, j_r)$$ is recorded, forming a time series.\n\nFor frequency analysis, the recorded time series is first processed by removing its mean to eliminate the DC component. Then, a Hann window is applied to reduce spectral leakage. The discrete Fourier transform (DFT) of the windowed signal is computed using a Fast Fourier Transform (FFT) algorithm, yielding the magnitude spectrum.\n\nThe analytical eigenfrequencies for the given domain with Neumann boundary conditions are:\n$$\nf_{m,n} = \\frac{c}{2}\\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2}\n$$\nwhere $$m, n$$ are non-negative integers, not both zero. For each test case, we compute the three lowest distinct non-zero analytical frequencies.\n\nFor each analytical frequency $$f_{\\text{anal}}$$, we search for its measured counterpart, $$\\hat{f}_{\\text{meas}}$$, in the computed spectrum. The search is conducted within a frequency window centered at $$f_{\\text{anal}}$$ with a width of $$\\max(5 \\text{ Hz}, 0.15 f_{\\text{anal}})$$. This window is clamped to the specified analysis band of $$[20 \\text{ Hz}, 300 \\text{ Hz}]$$. The frequency corresponding to the maximum magnitude peak within this search window is taken as $$\\hat{f}_{\\text{meas}}$$.\n\nFinally, the absolute relative error for each modal frequency is calculated as:\n$$\n\\text{Error} = \\frac{|\\hat{f}_{\\text{meas}} - f_{\\text{anal}}|}{f_{\\text{anal}}}\n$$\nThis procedure is repeated for all three test cases, and the nine resulting error values are reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Lx, Ly)\n        (3.0, 4.0),  # Case 1\n        (2.0, 2.0),  # Case 2\n        (5.0, 2.0),  # Case 3\n    ]\n\n    all_results = []\n    for Lx, Ly in test_cases:\n        errors = run_simulation_and_analyze(Lx, Ly)\n        all_results.extend(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in all_results)}]\")\n\ndef run_simulation_and_analyze(Lx, Ly):\n    \"\"\"\n    Runs the FDTD simulation for a given geometry and analyzes the results.\n    Returns a list of three relative frequency errors.\n    \"\"\"\n    # --- 1. Simulation Setup ---\n\n    # Constants and parameters\n    c = 343.0      # Speed of sound (m/s)\n    dx = 0.1       # Spatial step (m), dy = dx\n    s = 0.5        # Courant number\n    T = 1.6        # Total simulation time (s)\n\n    # Derived parameters\n    dt = s * dx / c\n    Nx = int(round(Lx / dx)) + 1\n    Ny = int(round(Ly / dx)) + 1\n    Nt = int(np.floor(T / dt))\n\n    # Effective dimensions based on grid\n    Lx_eff = (Nx - 1) * dx\n    Ly_eff = (Ny - 1) * dx\n\n    # Source and receiver locations (snapped to grid)\n    xs_frac, ys_frac = 0.37, 0.41\n    xr_frac, yr_frac = 0.23, 0.67\n    is_ = int(round(xs_frac * (Nx - 1)))\n    js_ = int(round(ys_frac * (Ny - 1)))\n    ir_ = int(round(xr_frac * (Nx - 1)))\n    jr_ = int(round(yr_frac * (Ny - 1)))\n    \n    # Pressure fields (current, previous)\n    p_now = np.zeros((Nx, Ny), dtype=np.float64)\n    p_prev = np.zeros((Nx, Ny), dtype=np.float64)\n    \n    receiver_signal = np.zeros(Nt, dtype=np.float64)\n    s2 = s**2\n\n    # --- 2. FDTD Simulation Loop ---\n    \n    p_padded = np.zeros((Nx + 2, Ny + 2), dtype=np.float64)\n\n    for n in range(Nt):\n        # Apply Neumann boundary conditions using ghost cells\n        p_padded[1:-1, 1:-1] = p_now\n        \n        # Walls\n        p_padded[0, 1:-1] = p_padded[2, 1:-1]      # x=0\n        p_padded[-1, 1:-1] = p_padded[-3, 1:-1]    # x=Lx\n        p_padded[1:-1, 0] = p_padded[1:-1, 2]      # y=0\n        p_padded[1:-1, -1] = p_padded[1:-1, -3]    # y=Ly\n\n        # Corners\n        p_padded[0, 0] = p_padded[2, 2]\n        p_padded[-1, 0] = p_padded[-3, 2]\n        p_padded[0, -1] = p_padded[2, -3]\n        p_padded[-1, -1] = p_padded[-3, -3]\n\n        # Calculate Laplacian using the padded grid\n        laplacian = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                     p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - 4 * p_now)\n\n        # Update pressure field\n        p_next = 2 * p_now - p_prev + s2 * laplacian\n\n        # Inject impulsive source at n=0\n        if n == 0:\n            # Source is applied to affect the field at n=1\n            p_next[is_, js_] += dt\n\n        # Update fields for next iteration\n        p_prev, p_now = p_now, p_next\n\n        # Record pressure at receiver\n        receiver_signal[n] = p_now[ir_, jr_]\n\n    # --- 3. Frequency Analysis ---\n\n    # Signal processing\n    signal_proc = receiver_signal - np.mean(receiver_signal)\n    signal_win = signal_proc * np.hanning(Nt)\n\n    # FFT\n    yf = fft.rfft(signal_win)\n    xf = fft.rfftfreq(Nt, d=dt)\n    spectrum = np.abs(yf)\n\n    # Analysis band\n    analysis_f_min, analysis_f_max = 20.0, 300.0\n\n    # --- 4. Analytical Frequencies and Error Calculation ---\n\n    # Find the 3 lowest non-zero analytical frequencies\n    modes = []\n    max_m, max_n = 10, 10\n    for m in range(max_m):\n        for n in range(max_n):\n            if m == 0 and n == 0:\n                continue\n            freq = (c / 2.0) * np.sqrt((m / Lx_eff)**2 + (n / Ly_eff)**2)\n            if freq > 0:\n                modes.append({'m': m, 'n': n, 'freq': freq})\n    \n    # Sort by frequency, handling degeneracies\n    modes.sort(key=lambda x: x['freq'])\n    unique_freqs = []\n    seen_freqs = set()\n    for mode in modes:\n        f_rounded = round(mode['freq'], 4)\n        if f_rounded not in seen_freqs:\n            unique_freqs.append(mode['freq'])\n            seen_freqs.add(f_rounded)\n        if len(unique_freqs) >= 3:\n            break\n            \n    analytical_freqs = unique_freqs[:3]\n    \n    errors = []\n    for f_anal in analytical_freqs:\n        # Define search window for peak picking\n        search_width = max(5.0, 0.15 * f_anal)\n        search_min = f_anal - search_width / 2.0\n        search_max = f_anal + search_width / 2.0\n        \n        # Clamp to analysis band\n        clamped_search_min = max(analysis_f_min, search_min)\n        clamped_search_max = min(analysis_f_max, search_max)\n\n        # Find indices for the search window in the FFT frequency array\n        idx_low = np.searchsorted(xf, clamped_search_min, side='left')\n        idx_high = np.searchsorted(xf, clamped_search_max, side='right')\n\n        if idx_low >= idx_high: \n            # If window is empty or outside range, this indicates a problem\n            # But for this problem, modes are expected to be found\n            errors.append(1.0) # Maximum error\n            continue\n\n        # Find peak in the search window\n        peak_idx_local = np.argmax(spectrum[idx_low:idx_high])\n        peak_idx_global = idx_low + peak_idx_local\n        f_meas = xf[peak_idx_global]\n        \n        # Calculate relative error\n        rel_error = np.abs(f_meas - f_anal) / f_anal\n        errors.append(rel_error)\n\n    return errors\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2449910"}]}