{"hands_on_practices": [{"introduction": "While library functions provide powerful tools for cluster labeling, a deep understanding of the underlying algorithm is crucial for any computational scientist. This practice challenges you to implement the Hoshen-Kopelman algorithm from first principles, extending it from the familiar two-dimensional plane to a three-dimensional cubic lattice [@problem_id:2380636]. By carefully considering the raster scan order and the necessary neighbor checks in 3D, you will build a robust labeling tool and use it to measure fundamental percolation properties, gaining a core skill applicable to a wide range of lattice models.", "problem": "You are to implement and analyze a generalization of a cluster labeling algorithm from a two-dimensional square lattice to a three-dimensional cubic lattice for site percolation. Start from the following foundational definitions and facts, and derive a correct and efficient algorithm.\n\nFoundational base:\n- A cluster is a maximal connected set of occupied sites under a specified neighborhood. In a cubic lattice of dimension $d=3$, the standard nearest-neighbor connectivity uses the $6$ face-adjacent neighbors.\n- A site percolates along a Cartesian axis if there exists a cluster that simultaneously touches both boundary hyperplanes orthogonal to that axis.\n- The Hoshen–Kopelman (HK) algorithm (to be defined and adapted by you) is a one-pass cluster labeling algorithm that builds label equivalences based on already-visited neighbors under a specified scanning order and resolves them with a disjoint-set data structure (also called union–find).\n\nYour task:\n- Generalize a cluster labeling algorithm from $d=2$ to $d=3$ for a cubic lattice of linear size $L$. Use nearest-neighbor connectivity with the $6$ face-adjacent neighbors. Adopt a deterministic scanning order where sites are visited in increasing $z$, then increasing $y$, then increasing $x$. At each occupied site, consider only the already-visited neighbors in this order, namely $(x-1,y,z)$, $(x,y-1,z)$, and $(x,y,z-1)$, when assigning and merging labels.\n- Use a disjoint-set representation to manage label equivalences during the scan, and after the scan, resolve all labels to their canonical representatives (roots).\n- From first principles, encode the percolation criterion along each axis as follows: along the $x$-axis, a cluster percolates if and only if there exists a root label whose cluster contains at least one site with $x=0$ and at least one site with $x=L-1$. Define analogous criteria for the $y$-axis and the $z$-axis. For $L=1$, note that $0=L-1$, so a single occupied site satisfies the criterion along all axes.\n- Compute, for each test lattice, the number of clusters, the size of the largest cluster, and the three percolation booleans along $x$, $y$, and $z$.\n\nImplementation constraints:\n- Lattices are three-dimensional arrays of shape $(L,L,L)$ with boolean occupancy.\n- Neighbor connectivity is strictly the $6$ face-adjacent neighbors.\n- Boundary conditions are open (non-periodic).\n\nTest suite:\nImplement your algorithm and apply it to the following five deterministic test cases. Each case is a cubic lattice with linear size $L$ and a prescribed set of occupied sites. Represent coordinates as ordered triples $(x,y,z)$ with $x,y,z \\in \\{0,1,\\dots,L-1\\}$.\n\n- Test $1$ (empty lattice): $L=3$, occupied set $\\varnothing$.\n- Test $2$ (single site, minimal system): $L=1$, occupied set $\\{(0,0,0)\\}$.\n- Test $3$ (single percolating line along $z$): $L=3$, occupied set $\\{(1,1,0),(1,1,1),(1,1,2)\\}$.\n- Test $4$ (two disconnected $2\\times 2$ squares on opposite faces): $L=4$, occupied set $\\{(0,0,0),(1,0,0),(0,1,0),(1,1,0),(2,2,3),(3,2,3),(2,3,3),(3,3,3)\\}$.\n- Test $5$ (fully occupied lattice): $L=3$, occupied set equals the entire lattice, i.e., all $L^3=27$ sites are occupied.\n\nRequired outputs per test:\n- The number of clusters (an integer).\n- The size of the largest cluster (an integer).\n- Three booleans indicating whether there is percolation along the $x$, $y$, and $z$ axes, respectively.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the five tests as a comma-separated list enclosed in square brackets, where each element is itself a list of the form `[n_c, s_max, b_x, b_y, b_z]` with $n_c$ the number of clusters, $s_{\\max}$ the largest cluster size, and $b_x, b_y, b_z$ the percolation booleans along $x,y,z$ for that test, respectively. For example, a valid overall format is $[[1,8,\\mathrm{True},\\mathrm{False},\\mathrm{True}],[\\dots],\\dots]$ with no whitespace in the printed string.", "solution": "The provided problem statement is subjected to rigorous validation.\n\n**Step 1: Extract Givens**\n\n- **Domain**: Computational physics, specifically cluster labeling algorithms for percolation.\n- **Lattice**: Three-dimensional cubic lattice of linear size $L$.\n- **Connectivity**: Nearest-neighbor, defined by the $6$ face-adjacent sites.\n- **Boundary Conditions**: Open (non-periodic).\n- **Algorithm**: A generalization of the Hoshen–Kopelman (HK) algorithm.\n- **Scanning Order**: Deterministic, lexicographical on coordinates $(z, y, x)$.\n- **Neighbor Set for Labeling**: For a site at $(x, y, z)$, the set of previously visited neighbors to consider is $\\{(x-1, y, z), (x, y-1, z), (x, y, z-1)\\}$.\n- **Label Equivalence**: Managed with a disjoint-set (union–find) data structure.\n- **Label Resolution**: All labels must be resolved to their canonical representatives (roots) after the initial scan.\n- **Percolation Definition**: A cluster percolates along an axis (e.g., $x$) if it contains at least one site on the boundary hyperplane $x=0$ and at least one site on the boundary hyperplane $x=L-1$. The same logic applies to the $y$ and $z$ axes.\n- **Special Case $L=1$**: For a system of size $L=1$, an occupied site at $(0,0,0)$ satisfies the percolation criterion for all three axes, as the condition $x=0$ is identical to $x=L-1$.\n- **Required Outputs**: For each test case, compute:\n    1. The total number of distinct clusters, $n_c$.\n    2. The size of the largest cluster, $s_{\\max}$.\n    3. Three booleans indicating percolation along the $x$, $y$, and $z$ axes, $(b_x, b_y, b_z)$.\n- **Test Cases**:\n    - **Test 1**: $L=3$, occupied set $\\varnothing$.\n    - **Test 2**: $L=1$, occupied set $\\{(0,0,0)\\}$.\n    - **Test 3**: $L=3$, occupied set $\\{(1,1,0), (1,1,1), (1,1,2)\\}$.\n    - **Test 4**: $L=4$, occupied set $\\{(0,0,0), (1,0,0), (0,1,0), (1,1,0), (2,2,3), (3,2,3), (2,3,3), (3,3,3)\\}$.\n    - **Test 5**: $L=3$, occupied set is the entire lattice of $27$ sites.\n- **Implementation Constraint**: Lattices are boolean arrays of shape $(L,L,L)$.\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is reviewed against the validation criteria:\n\n1.  **Scientifically Grounded**: The problem is based on the Hoshen-Kopelman algorithm and percolation theory, which are standard, well-established topics in computational and statistical physics. The extension from two to three dimensions is a canonical exercise. The definitions of clusters, connectivity, and percolation are standard. The problem is scientifically sound.\n2.  **Well-Posed**: The problem is specified with high precision. It defines a deterministic scanning order, a specific set of neighbors to check, a clear method for handling label equivalences, and unambiguous criteria for the required outputs. The given test cases are deterministic. A unique and stable solution exists for each test case.\n3.  **Objective**: The language is formal, precise, and free of any subjectivity or ambiguity.\n4.  **Complete and Consistent**: All necessary information is provided. The lattice dimensions, occupied sites, connectivity rules, and output requirements are fully specified. The special case for $L=1$ is explicitly handled, preventing ambiguity. The description of the algorithm is internally consistent; the specified neighbor set corresponds precisely to the set of already-visited sites under the given scanning order.\n5.  **No Other Flaws**: The problem is not metaphorical, trivial, or ill-structured. It requests the implementation of a non-trivial algorithm from first principles.\n\n**Step 3: Verdict and Action**\n\nThe problem is **valid**. It is a well-posed, scientifically sound problem in computational physics. A solution will be constructed as specified.\n\n**Algorithmic Solution**\n\nThe task requires the implementation of a three-dimensional Hoshen-Kopelman (HK) algorithm. This will be performed in three main passes over the lattice data.\n\nLet the cubic lattice be represented by a three-dimensional boolean array, $\\mathcal{G}$, of shape $(L, L, L)$, where $\\mathcal{G}[z, y, x] = \\mathrm{True}$ if the site $(x, y, z)$ is occupied. We will create a corresponding integer array, $\\Lambda$, of the same shape to store cluster labels, initialized to $0$.\n\nA disjoint-set union (DSU) or union-find data structure is required to manage label equivalences. This will be implemented using a parent array, $P$, where $P[i]$ stores the parent of label $i$. The fundamental operations are `find(i)`, which returns the canonical representative (root) of the set containing $i$ (with path compression for efficiency), and `union(i, j)`, which merges the sets containing labels $i$ and $j$.\n\n**Pass 1: Site Labeling and Equivalence Recording**\n\nThe lattice $\\mathcal{G}$ is scanned in the specified lexicographical order of indices $(z, y, x)$, from $(0, 0, 0)$ to $(L-1, L-1, L-1)$. A counter for new labels, `next_label`, is initialized to $1$.\n\nFor each site $(x, y, z)$:\nIf $\\mathcal{G}[z, y, x]$ is unoccupied, $\\Lambda[z, y, x]$ remains $0$.\nIf $\\mathcal{G}[z, y, x]$ is occupied, we examine its previously scanned neighbors. Due to the scanning order, these neighbors are located at $(x-1, y, z)$, $(x, y-1, z)$, and $(x, y, z-1)$. Let $N(z, y, x)$ be the set of labels of the occupied, already-visited neighbors:\n$$\nN(z, y, x) = \\{ \\Lambda[z, y, k] \\mid k=x-1, \\mathcal{G}[z, y, k]=\\mathrm{True}, x>0 \\} \\cup \\\\ \\{ \\Lambda[z, l, x] \\mid l=y-1, \\mathcal{G}[z, l, x]=\\mathrm{True}, y>0 \\} \\cup \\\\ \\{ \\Lambda[k, y, x] \\mid k=z-1, \\mathcal{G}[k, y, x]=\\mathrm{True}, z>0 \\}\n$$\nThere are two cases for the set $N(z, y, x)$:\n1.  **$N(z, y, x)$ is empty**: The current site is not connected to any previously labeled cluster. It initiates a new cluster. We assign it a new label: $\\Lambda[z, y, x] \\leftarrow \\text{next\\_label}$. The DSU is updated by setting $P[\\text{next\\_label}] \\leftarrow \\text{next\\_label}$. The `next_label` counter is then incremented.\n2.  **$N(z, y, x)$ is non-empty**: The current site is connected to one or more existing clusters. We assign it the smallest label in $N(z,y,x)$: $\\Lambda[z, y, x] \\leftarrow \\min(N)$. Subsequently, all labels in $N$ must be declared equivalent. For every label $l \\in N$, we perform the operation `union(min(N), l)`. This ensures that all connected components found so far are merged in the DSU data structure.\n\n**Pass 2: Label Resolution**\n\nAfter the first pass, the array $\\Lambda$ contains provisional labels, and the DSU parent array $P$ holds the complete set of equivalences. The second pass resolves these equivalences.\nFirst, the DSU structure is flattened by applying path compression to every label. For each label $i$ from $1$ to `next_label`$-1$, we set $P[i] \\leftarrow \\text{find}(i)$.\nNext, the label array $\\Lambda$ is updated. We iterate through each site $(x, y, z)$. If the site is occupied (i.e., $\\Lambda[z, y, x] > 0$), its label is replaced by its canonical representative: $\\Lambda[z, y, x] \\leftarrow P[\\Lambda[z, y, x]]$. After this pass, all sites belonging to the same cluster share the exact same label, which is the root of their equivalence class.\n\n**Pass 3: Metric Computation**\n\nWith the resolved label grid $\\Lambda$, we can compute the required metrics. We use two dictionaries: `cluster_sizes` to map each canonical label to its size, and `cluster_boundaries` to map each canonical label to the set of boundary hyperplanes it touches.\n\nWe iterate through the lattice a final time. For each site $(x, y, z)$:\nIf the site is occupied with canonical label $k = \\Lambda[z, y, x]$:\n- Increment the size of cluster $k$ in `cluster_sizes`.\n- Check if the site lies on a boundary. If $x=0$, document that cluster $k$ touches the '$x_0$' boundary. If $x=L-1$, document that it touches the '$x_{L-1}$' boundary. The same is done for the $y$ and $z$ axes.\n\nFinally, the output quantities are calculated:\n- **Number of clusters, $n_c$**: This is the total number of unique canonical labels, which is simply the number of entries in the `cluster_sizes` dictionary. If no sites are occupied, $n_c=0$.\n- **Largest cluster size, $s_{\\max}$**: This is the maximum value in the `cluster_sizes` dictionary. If no sites are occupied, $s_{\\max}=0$.\n- **Percolation booleans, $(b_x, b_y, b_z)$**: For each canonical cluster $k$, we check its recorded boundary intersections.\n    - $b_x = \\mathrm{True}$ if there exists any $k$ that touches both the $x=0$ and $x=L-1$ boundaries. Special case: if $L=1$, touching the $x=0$ boundary suffices.\n    - $b_y = \\mathrm{True}$ if there exists any $k$ that touches both the $y=0$ and $y=L-1$ boundaries. Special case: if $L=1$, touching the $y=0$ boundary suffices.\n    - $b_z = \\mathrm{True}$ if there exists any $k$ that touches both the $z=0$ and $z=L-1$ boundaries. Special case: if $L=1$, touching the $z=0$ boundary suffices.\n\nThis completes the derivation of the algorithm from the specified first principles.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results in the required format.\n    \"\"\"\n    test_cases = [\n        # Test 1: L=3, empty lattice\n        (3, set()),\n        # Test 2: L=1, single site\n        (1, {(0, 0, 0)}),\n        # Test 3: L=3, single percolating line along z\n        (3, {(1, 1, 0), (1, 1, 1), (1, 1, 2)}),\n        # Test 4: L=4, two disconnected 2x2 squares\n        (4, {(0, 0, 0), (1, 0, 0), (0, 1, 0), (1, 1, 0), \n             (2, 2, 3), (3, 2, 3), (2, 3, 3), (3, 3, 3)}),\n        # Test 5: L=3, fully occupied lattice\n        (3, {(x, y, z) for x in range(3) for y in range(3) for z in range(3)}),\n    ]\n\n    results_str = []\n    for L, occupied_sites in test_cases:\n        result = analyze_lattice(L, occupied_sites)\n        # Format each result list as a string, e.g., \"[1,27,True,True,True]\"\n        results_str.append(f\"[{result[0]},{result[1]},{result[2]},{result[3]},{result[4]}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\ndef analyze_lattice(L, occupied_sites):\n    \"\"\"\n    Implements the 3D Hoshen-Kopelman algorithm and computes cluster statistics.\n    \"\"\"\n    if not occupied_sites:\n        return [0, 0, False, False, False]\n\n    # Create a boolean grid for occupied sites\n    grid = np.zeros((L, L, L), dtype=bool)\n    for x, y, z in occupied_sites:\n        grid[z, y, x] = True\n\n    labels = np.zeros_like(grid, dtype=int)\n    \n    # Disjoint-Set Union (DSU) implementation\n    # The max number of labels is the number of occupied sites.\n    # We add 1 for 1-based indexing, and another 1 for range safety.\n    max_labels = L * L * L + 1\n    parent = list(range(max_labels))\n\n    def find(i):\n        if parent[i] == i:\n            return i\n        parent[i] = find(parent[i]) # Path compression\n        return parent[i]\n\n    def union(i, j):\n        root_i = find(i)\n        root_j = find(j)\n        if root_i != root_j:\n            # A simple union rule: smaller root points to larger root\n            if root_i < root_j:\n                parent[root_j] = root_i\n            else:\n                parent[root_i] = root_j\n\n    # --- Pass 1: Labeling and Equivalence Recording ---\n    next_label = 1\n    # Scan in order z, then y, then x\n    for z in range(L):\n        for y in range(L):\n            for x in range(L):\n                if not grid[z, y, x]:\n                    continue\n\n                neighbor_labels = set()\n                # Check neighbors that have already been visited\n                # Neighbor (x-1, y, z) -> grid[z, y, x-1]\n                if x > 0 and grid[z, y, x-1]:\n                    neighbor_labels.add(labels[z, y, x-1])\n                # Neighbor (x, y-1, z) -> grid[z, y-1, x]\n                if y > 0 and grid[z, y-1, x]:\n                    neighbor_labels.add(labels[z, y-1, x])\n                # Neighbor (x, y, z-1) -> grid[z-1, y, x]\n                if z > 0 and grid[z-1, y, x]:\n                    neighbor_labels.add(labels[z-1, y, x])\n\n                if not neighbor_labels:\n                    # New cluster\n                    labels[z, y, x] = next_label\n                    next_label += 1\n                else:\n                    # Connected to existing clusters\n                    min_label = min(neighbor_labels)\n                    labels[z, y, x] = min_label\n                    for label in neighbor_labels:\n                        if label != min_label:\n                            union(min_label, label)\n    \n    # --- Pass 2 & 3: Label Resolution and Metric Computation ---\n    cluster_sizes = {}\n    cluster_boundaries = {}\n\n    for z in range(L):\n        for y in range(L):\n            for x in range(L):\n                if not grid[z, y, x]:\n                    continue\n                \n                # Find the canonical root label for the current site\n                root = find(labels[z, y, x])\n                labels[z, y, x] = root # Resolve label in place (optional but good practice)\n                \n                if root not in cluster_sizes:\n                    cluster_sizes[root] = 0\n                    cluster_boundaries[root] = set()\n\n                cluster_sizes[root] += 1\n                \n                # Record boundary intersections\n                if x == 0: cluster_boundaries[root].add('x0')\n                if x == L - 1: cluster_boundaries[root].add('xL')\n                if y == 0: cluster_boundaries[root].add('y0')\n                if y == L - 1: cluster_boundaries[root].add('yL')\n                if z == 0: cluster_boundaries[root].add('z0')\n                if z == L - 1: cluster_boundaries[root].add('zL')\n\n    # --- Final Calculation of Metrics ---\n    n_clusters = len(cluster_sizes)\n    s_max = max(cluster_sizes.values()) if cluster_sizes else 0\n    \n    b_x, b_y, b_z = False, False, False\n    for root in cluster_boundaries:\n        boundaries = cluster_boundaries[root]\n        if L == 1:\n            if 'x0' in boundaries: b_x = True\n            if 'y0' in boundaries: b_y = True\n            if 'z0' in boundaries: b_z = True\n        else:\n            if 'x0' in boundaries and 'xL' in boundaries: b_x = True\n            if 'y0' in boundaries and 'yL' in boundaries: b_y = True\n            if 'z0' in boundaries and 'zL' in boundaries: b_z = True\n\n    return [n_clusters, s_max, b_x, b_y, b_z]\n\n\nsolve()\n```", "id": "2380636"}, {"introduction": "Once clusters are identified, how can we describe their structure? Percolation clusters are not simple geometric objects; they are complex and often fractal. This practice introduces a powerful technique from classical mechanics—the gyration tensor—to quantitatively measure the shape of these clusters [@problem_id:2380616]. By calculating the tensor's eigenvalues, you will compute the shape anisotropy, a ratio $R = \\lambda_{\\max}/\\lambda_{\\min}$ that tells us how elongated or isotropic each cluster is, providing a window into the intricate geometry of percolation.", "problem": "Consider independent site percolation on a finite square lattice. Let $L \\in \\mathbb{N}$ denote the linear size of the lattice, with sites indexed by integer coordinates $(x,y)$ where $x \\in \\{0,1,\\dots,L-1\\}$ and $y \\in \\{0,1,\\dots,L-1\\}$. Let $p \\in [0,1]$ be the occupation probability. A pseudorandom generator seeded by an integer $s$ independently occupies each site with probability $p$, producing a binary field $n(x,y) \\in \\{0,1\\}$. Two occupied sites are connected if and only if they are nearest neighbors horizontally or vertically (that is, at Manhattan distance $1$). A cluster is a maximal set of occupied sites that are pairwise connected by such nearest-neighbor steps. Open boundary conditions are used.\n\nFor a cluster comprising $n \\ge 1$ occupied sites with coordinates $\\{(x_i,y_i)\\}_{i=1}^n$, define the center of mass\n$$\n\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{n} \\sum_{i=1}^{n} \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix},\n$$\nand the $2 \\times 2$ gyration tensor\n$$\nG = \\sum_{i=1}^{n} \\left( \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix} - \\mathbf{r}_{\\mathrm{cm}} \\right) \\left( \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix} - \\mathbf{r}_{\\mathrm{cm}} \\right)^{\\!\\top}.\n$$\nLet $\\lambda_{\\max}$ and $\\lambda_{\\min}$ denote the larger and smaller eigenvalues of $G$, respectively, so that $\\lambda_{\\max} \\ge \\lambda_{\\min} \\ge 0$. For each cluster with $n \\ge 3$ and $\\lambda_{\\min} > 0$, define the shape anisotropy ratio\n$$\nR = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}}.\n$$\nClusters with $n < 3$ or with $\\lambda_{\\min} = 0$ are excluded from the list of ratios.\n\nImplement a program that, for each specified test case $(L,p,s)$, generates one percolation configuration, identifies all clusters under the connectivity definition above, computes the list of shape anisotropy ratios $\\{R\\}$ over all clusters that satisfy the inclusion criteria, sorts this list in nondecreasing order, and rounds each $R$ to $6$ decimal places.\n\nUse the following test suite:\n- Test $1$: $L=4$, $p=0$, $s=42$.\n- Test $2$: $L=4$, $p=1$, $s=0$.\n- Test $3$: $L=8$, $p=0.5$, $s=12345$.\n- Test $4$: $L=12$, $p=0.592746$, $s=777$.\n- Test $5$: $L=6$, $p=0.3$, $s=2024$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is itself a bracketed, comma-separated list of the rounded ratios for that test case, in the same order as the test suite (for example, $[[\\,],[1.000000],\\dots]$). No additional text should be printed.", "solution": "The problem requires the computation of shape anisotropy ratios for clusters in a site percolation model on a two-dimensional square lattice. The problem statement is rigorously defined, scientifically sound, and computationally tractable. It is therefore deemed valid. The solution proceeds according to the following systematic method.\n\nFirst, the percolation configuration is generated. For a given lattice of size $L \\times L$, occupation probability $p \\in [0,1]$, and seed $s \\in \\mathbb{N}$, a pseudorandom number generator is initialized. An $L \\times L$ grid is populated with values from a uniform distribution on $[0,1]$. Each site $(x,y)$, where $x, y \\in \\{0,1,\\dots,L-1\\}$, is considered occupied, $n(x,y)=1$, if its corresponding random value is less than $p$; otherwise, it is unoccupied, $n(x,y)=0$. The use of a fixed seed $s$ ensures the complete reproducibility of the configuration, making the problem deterministic.\n\nSecond, clusters of connected occupied sites are identified. A cluster is defined as a maximal set of occupied sites connected by paths of nearest neighbors, where neighbors are adjacent horizontally or vertically. This is a standard connected-components labeling problem. For algorithmic efficiency and clarity, we employ the `scipy.ndimage.label` function. This function requires a structuring element to define connectivity; we specify a kernel that represents $4$-connectivity, corresponding to the problem's definition of neighbors at Manhattan distance $1$. This process partitions the set of all occupied sites into disjoint clusters and assigns a unique integer label to each.\n\nThird, each identified cluster is analyzed for its geometric properties, subject to specific inclusion criteria. The analysis is restricted to clusters with size $n \\ge 3$. For each qualifying cluster, defined by its set of $n$ site coordinates $\\{(x_i, y_i)\\}_{i=1}^n$, we compute the center of mass $\\mathbf{r}_{\\mathrm{cm}}$ and the gyration tensor $G$. The center of mass is the arithmetic mean of the site coordinates:\n$$\n\\mathbf{r}_{\\mathrm{cm}} = \\frac{1}{n} \\sum_{i=1}^{n} \\begin{bmatrix} x_i \\\\ y_i \\end{bmatrix}\n$$\nThe gyration tensor $G$, a $2 \\times 2$ real symmetric matrix, is then computed:\n$$\nG = \\sum_{i=1}^{n} \\left( \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\right) \\left( \\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}} \\right)^{\\!\\top}\n$$\nwhere $\\mathbf{r}_i = [x_i, y_i]^\\top$. This tensor is the discrete analogue of the moment of inertia tensor and fundamentally characterizes the spatial distribution of the cluster's mass (sites) around its center. Its eigenvalues, $\\lambda_{\\max}$ and $\\lambda_{\\min}$, are the squared principal radii of gyration and quantify the cluster's spatial extent along its principal axes. A second inclusion criterion, $\\lambda_{\\min} > 0$, is applied. This condition is crucial as it excludes degenerate, one-dimensional clusters where all sites are perfectly collinear. For such structures, the set of vectors $\\{\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\}$ spans only a $1$-dimensional subspace, causing the gyration tensor to be rank-deficient, which results in $\\lambda_{\\min} = 0$ and an undefined anisotropy ratio.\n\nFor all non-degenerate clusters satisfying both $n \\ge 3$ and $\\lambda_{\\min} > 0$, the shape anisotropy ratio is calculated as:\n$$\nR = \\frac{\\lambda_{\\max}}{\\lambda_{\\min}}\n$$\nA value of $R=1$ signifies a perfectly isotropic shape (e.g., a square), while $R > 1$ indicates increasing elongation or anisotropy.\n\nFinally, for each test case $(L, p, s)$, the computed ratios $\\{R\\}$ are collected into a list, sorted in nondecreasing order, and each value is rounded to $6$ decimal places as required. The resulting lists of ratios, one for each test case, are then formatted into the specified final output string.", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Main function to solve the percolation problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (4, 0, 42),\n        (4, 1, 0),\n        (8, 0.5, 12345),\n        (12, 0.592746, 777),\n        (6, 0.3, 2024),\n    ]\n\n    all_results = []\n    for L, p, s in test_cases:\n        ratios = process_case(L, p, s)\n        all_results.append(ratios)\n\n    # Format the final output string according to the problem specification.\n    outer_parts = []\n    for res_list in all_results:\n        # Format each ratio to 6 decimal places.\n        formatted_nums = [f\"{num:.6f}\" for num in res_list]\n        outer_parts.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    print(final_output)\n\ndef process_case(L, p, s):\n    \"\"\"\n    Generates a percolation configuration, finds clusters, and computes\n    shape anisotropy ratios for a single test case.\n    \"\"\"\n    # 1. Generate the lattice using a seeded pseudorandom number generator.\n    rng = np.random.default_rng(s)\n    grid = rng.random((L, L)) < p\n\n    # 2. Identify clusters using 4-connectivity (von Neumann neighborhood).\n    # The structuring element defines connectivity to horizontal/vertical neighbors.\n    structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n    labeled_grid, num_labels = label(grid, structure=structure)\n    \n    if num_labels == 0:\n        return []\n\n    ratios = []\n    \n    # 3. Process each found cluster.\n    for i in range(1, num_labels + 1):\n        # Find all coordinates (row, col) for the current cluster label.\n        coords = np.argwhere(labeled_grid == i)\n        \n        # The problem statement uses (x, y) coordinates. Numpy's (row, col)\n        # corresponds to (y, x). We convert to (x, y) for consistency.\n        xy_coords = coords[:, ::-1].astype(np.float64)\n        \n        n = xy_coords.shape[0]\n\n        # Inclusion criterion 1: Cluster size n >= 3.\n        if n < 3:\n            continue\n        \n        # Calculate the center of mass.\n        r_cm = np.mean(xy_coords, axis=0)\n        \n        # Center the coordinates and compute the gyration tensor G.\n        # G = sum_i (r_i - r_cm)(r_i - r_cm)^T\n        centered_coords = xy_coords - r_cm\n        G = centered_coords.T @ centered_coords\n        \n        # Eigenvalues of G are the squared principal radii of gyration.\n        # `eigvalsh` is used for real symmetric matrices.\n        eigenvalues = np.linalg.eigvalsh(G)\n        \n        lambda_min, lambda_max = eigenvalues[0], eigenvalues[1]\n        \n        # Inclusion criterion 2: Exclude collinear (degenerate) clusters.\n        # This corresponds to lambda_min > 0.\n        if lambda_min > 1e-12: # Using a small tolerance for floating point stability\n            R = lambda_max / lambda_min\n            ratios.append(R)\n            \n    # 4. Sort the list of ratios in nondecreasing order.\n    ratios.sort()\n    \n    return ratios\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2380616"}, {"introduction": "Percolation is not limited to regular, periodic lattices. This advanced practice takes you beyond the grid to explore connectivity in a quasicrystal, a fascinating structure with long-range order but no translational symmetry [@problem_id:2380602]. Here, the very notion of 'neighborhood' must be redefined using concepts from computational geometry, where the Delaunay triangulation provides the natural connectivity. This exercise demonstrates the power and generality of cluster analysis, showing how it can be adapted to study phase transitions on complex, aperiodic networks.", "problem": "You will investigate site percolation on an aperiodic quasicrystal point set that exhibits long-range order akin to a Penrose tiling. The point set is defined as the Cartesian product of two one-dimensional Fibonacci chains constructed by substitution and metric embedding. Let the golden ratio be $\\varphi = \\frac{1+\\sqrt{5}}{2}$. Define two segment lengths: a long segment $L$ of length $\\varphi$ and a short segment $S$ of length $1$. For a nonnegative integer $k$, construct a word $W_k$ over the alphabet $\\{L,S\\}$ by the substitutions $L \\mapsto L\\,S$ and $S \\mapsto L$, starting from $W_0 = L$ and iterating exactly $k$ times. From $W_k$, define a sequence of coordinates on the real line by $x_0 = 0$ and $x_{i+1} = x_i + \\ell_i$ for $i = 0,1,\\dots,|W_k|-1$, where $\\ell_i = \\varphi$ if the $i$-th symbol of $W_k$ is $L$ and $\\ell_i = 1$ if it is $S$. This produces a strictly increasing coordinate list $\\{x_i\\}_{i=0}^{|W_k|}$. Given two iteration counts $k_x$ and $k_y$, the two-dimensional point set is\n$$\n\\mathcal{P} = \\{(x_i, y_j) \\mid 0 \\le i \\le |W_{k_x}|,\\ 0 \\le j \\le |W_{k_y}|\\},\n$$\nwhere $\\{y_j\\}$ is constructed from $W_{k_y}$ in the same way as $\\{x_i\\}$. This $\\mathcal{P}$ is a quasicrystal lattice with aperiodic structure and long-range order.\n\nDefine the neighborhood relation between two distinct sites $u, v \\in \\mathcal{P}$ as follows: $u$ and $v$ are neighbors if and only if there exists at least one circle in the plane that passes through $u$ and $v$ whose open disk contains no site of $\\mathcal{P}$. Equivalently, $u$ and $v$ are joined by an edge if they satisfy the empty circumcircle property in the sense of planar geometric graphs.\n\nPerform site percolation with occupation probability $p \\in [0,1]$ by independently declaring each site occupied with probability $p$. Use a deterministic pseudo-random sequence initialized with integer seed $s$ to draw independent uniform random numbers on $[0,1)$, and declare a site occupied if and only if the corresponding draw is strictly less than $p$. Clusters are defined as maximal sets of occupied sites connected by the neighborhood relation. Let $x_{\\min} = \\min\\{x \\mid (x,y) \\in \\mathcal{P}\\}$ and $x_{\\max} = \\max\\{x \\mid (x,y) \\in \\mathcal{P}\\}$, and let $\\Delta_x$ be half of the minimum spacing between consecutive distinct $x$-coordinates in $\\{x_i\\}$. Define the left boundary as the set of sites with $x \\le x_{\\min} + \\Delta_x$ and the right boundary as the set of sites with $x \\ge x_{\\max} - \\Delta_x$. The percolation event of interest is the existence of at least one occupied cluster that intersects both the left and right boundaries. The required output for each parameter set is a boolean indicating whether this event occurs.\n\nYour task is to implement a complete program that, for each parameter tuple $(k_x, k_y, p, s)$ in the test suite below, constructs $\\mathcal{P}$, determines the neighborhood by the empty circumcircle condition, performs site percolation as specified, labels clusters, and decides whether a left-to-right spanning occupied cluster exists. There are no physical units involved in this problem.\n\nTest suite parameters to cover general behavior and edge cases:\n- Case A (fully occupied): $(k_x, k_y, p, s) = (2, 2, 1.0, 0)$.\n- Case B (no occupation): $(k_x, k_y, p, s) = (2, 2, 0.0, 0)$.\n- Case C (subcritical example): $(k_x, k_y, p, s) = (4, 3, 0.4, 12345)$.\n- Case D (near-critical example): $(k_x, k_y, p, s) = (5, 5, 0.55, 2468)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets and with no spaces, in the order of the cases above. For example, the format must be exactly like $[r_A,r_B,r_C,r_D]$ where each $r_\\cdot$ is either True or False.", "solution": "The user has provided a problem statement that requires a computational investigation of site percolation on a two-dimensional quasicrystal lattice. The problem is to determine, for several parameter sets, whether a spanning cluster of occupied sites connects the left and right boundaries of the system.\n\nThe problem statement is algorithmically specified and scientifically sound. It is firmly rooted in the established principles of computational physics, specifically percolation theory and the study of quasicrystals. All terms are defined with mathematical precision, the parameters are complete, and the objective is unambiguous. Therefore, the problem is deemed valid and a full solution is warranted.\n\nThe solution is developed by following a sequence of logical steps, from constructing the physical system to performing the percolation analysis.\n\n**1. Construction of the Quasicrystal Point Set**\n\nThe foundation of the system is a one-dimensional aperiodic chain known as a Fibonacci chain. This chain is constructed from a symbolic sequence, which is then mapped to physical coordinates.\n\n*   **Fibonacci Word Generation**: We start with a symbolic alphabet $\\{L, S\\}$ representing long and short segments, respectively. The sequence of segments, a word $W_k$, is generated by an iterative substitution process starting from $W_0=L$. For a given integer $k \\ge 0$, the word $W_{k+1}$ is obtained from $W_k$ by applying the substitution rules $L \\mapsto LS$ and $S \\mapsto L$. For instance, $W_0=L$, $W_1=LS$, $W_2=LSL$, and so on.\n\n*   **1D Coordinate Generation**: The symbolic word $W_k$ is embedded onto the real line to create a set of coordinates. The segment lengths are defined as $\\varphi = \\frac{1+\\sqrt{5}}{2}$ for $L$ and $1$ for $S$. A strictly increasing sequence of coordinates $\\{x_i\\}_{i=0}^{|W_k|}$ is generated by setting $x_0=0$ and subsequently $x_{i+1} = x_i + \\ell_i$, where $\\ell_i$ is the length of the $i$-th symbol in $W_k$.\n\n*   **2D Point Set Construction**: The two-dimensional quasicrystal point set, denoted $\\mathcal{P}$, is formed by the Cartesian product of two one-dimensional Fibonacci chains. Given iteration counts $k_x$ and $k_y$, we generate the coordinate sets $\\{x_i\\}$ from $W_{k_x}$ and $\\{y_j\\}$ from $W_{k_y}$. The point set is then $\\mathcal{P} = \\{(x_i, y_j) \\mid 0 \\le i \\le |W_{k_x}|, 0 \\le j \\le |W_{k_y}|\\}$.\n\n**2. Defining the Neighborhood Graph**\n\nThe connectivity between sites in $\\mathcal{P}$ is defined by a specific geometric condition. Two distinct sites $u, v \\in \\mathcal{P}$ are considered neighbors if an empty circumcircle can be drawn through them, meaning there exists a circle passing through $u$ and $v$ whose open disk contains no other sites from $\\mathcal{P}$. This \"empty circumcircle\" property is the defining characteristic of edges in the Delaunay triangulation of a point set. Therefore, the neighborhood structure of our system is precisely the graph formed by the edges of the Delaunay triangulation of $\\mathcal{P}$. This graph provides the underlying network for the percolation process.\n\n**3. Site Percolation and Cluster Identification**\n\nPercolation is simulated on the sites of the set $\\mathcal{P}$.\n\n*   **Site Occupation**: Each site is independently declared \"occupied\" with a probability $p \\in [0,1]$. To ensure deterministic and reproducible results, a pseudo-random number generator is initialized with a given integer seed $s$. For each site, a random number $r \\in [0,1)$ is drawn; the site is occupied if and only if $r < p$.\n\n*   **Cluster Definition**: A cluster is a maximal set of occupied sites that are connected. Two occupied sites belong to the same cluster if there is a path between them consisting entirely of occupied sites and edges from the neighborhood graph (the Delaunay triangulation).\n\n**4. The Spanning Condition**\n\nThe primary objective is to check for the existence of a \"spanning cluster\".\n\n*   **Boundary Definition**: The left boundary is defined as the set of sites $(x,y) \\in \\mathcal{P}$ where $x \\le x_{\\min} + \\Delta_x$. Here, $x_{\\min} = \\min\\{x \\mid (x,y) \\in \\mathcal{P}\\} = 0$. The value $\\Delta_x$ is half the minimum spacing between consecutive distinct $x$-coordinates. The spacings are either $1$ or $\\varphi$, so the minimum is $1$, making $\\Delta_x = 0.5$. The condition $x \\le 0.5$ selects only sites with $x=0$.\nSimilarly, the right boundary consists of sites where $x \\ge x_{\\max} - \\Delta_x$. Since the coordinate preceding $x_{\\max}$ is at most $x_{\\max}-1$, this condition selects only sites with $x=x_{\\max}$.\n\n*   **Spanning Event**: A spanning event occurs if there exists at least one cluster that contains a site from the left boundary and a site from the right boundary.\n\n**5. Algorithmic Implementation**\n\nA computational algorithm is designed to implement this model and test for the spanning condition.\n\n1.  **System Generation**: For each parameter set $(k_x, k_y, p, s)$, the algorithm first generates the 1D coordinate sets $\\{x_i\\}$ and $\\{y_j\\}$ and then constructs the 2D point set $\\mathcal{P}$.\n2.  **Graph Construction**: It then computes the Delaunay triangulation of $\\mathcal{P}$ using scientific libraries (e.g., `scipy.spatial.Delaunay`). The edges of the triangulation are stored in an adjacency list representation of the neighborhood graph.\n3.  **Percolation Simulation**: An array of boolean values is created to represent the occupation status of each site, determined according to the probability $p$ and seed $s$.\n4.  **Spanning Check**: To efficiently test for a spanning cluster, a Breadth-First Search (BFS) algorithm is employed.\n    a. A queue is initialized with all occupied sites that lie on the left boundary. A `visited` array is used to avoid redundant explorations.\n    b. The BFS proceeds by exploring neighbors of sites in the queue. The search is restricted to only traverse to neighbors that are also occupied.\n    c. If the BFS reaches any site on the right boundary, a path has been found from left to right through occupied sites. This signifies a spanning cluster, and the result for the test case is `True`.\n    d. If the BFS completes without reaching the right boundary, no such spanning cluster exists, and the result is `False`.\n\nThis algorithm provides a complete and correct solution to the posed problem. The use of Delaunay triangulation correctly interprets the neighborhood definition, and the BFS starting from one boundary is an efficient method for detecting spanning clusters.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import Delaunay\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the percolation problem for the given test cases.\n    It iterates through each parameter set, determines if a spanning cluster exists,\n    and prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # (k_x, k_y, p, s)\n        (2, 2, 1.0, 0),        # Case A: fully occupied\n        (2, 2, 0.0, 0),        # Case B: no occupation\n        (4, 3, 0.4, 12345),    # Case C: subcritical example\n        (5, 5, 0.55, 2468),    # Case D: near-critical example\n    ]\n\n    results = []\n    for kx, ky, p, s in test_cases:\n        result = check_percolation(kx, ky, p, s)\n        results.append(result)\n\n    # Format the final output as specified.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef check_percolation(kx, ky, p, s):\n    \"\"\"\n    Performs the full percolation simulation for a single parameter set.\n\n    Args:\n        kx (int): Iteration count for the x-dimension Fibonacci chain.\n        ky (int): Iteration count for the y-dimension Fibonacci chain.\n        p (float): Occupation probability.\n        s (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        bool: True if a left-to-right spanning cluster exists, False otherwise.\n    \"\"\"\n    phi = (1.0 + np.sqrt(5.0)) / 2.0\n\n    def generate_word(k):\n        \"\"\"Generates the k-th Fibonacci word.\"\"\"\n        if k == 0:\n            return \"L\"\n        w = \"L\"\n        for _ in range(k):\n            next_w = []\n            for char in w:\n                if char == 'L':\n                    next_w.append('LS')\n                else:  # char == 'S'\n                    next_w.append('L')\n            w = \"\".join(next_w)\n        return w\n\n    def generate_coords(word):\n        \"\"\"Generates 1D coordinates from a Fibonacci word.\"\"\"\n        coords = [0.0]\n        current_pos = 0.0\n        for char in word:\n            if char == 'L':\n                current_pos += phi\n            else:  # char == 'S'\n                current_pos += 1.0\n            coords.append(current_pos)\n        return np.array(coords, dtype=np.float64)\n\n    # 1. Generate 1D and 2D point sets\n    word_x = generate_word(kx)\n    word_y = generate_word(ky)\n    x_coords = generate_coords(word_x)\n    y_coords = generate_coords(word_y)\n\n    nx, ny = len(x_coords), len(y_coords)\n    num_points = nx * ny\n    points = np.zeros((num_points, 2), dtype=np.float64)\n    point_idx = 0\n    for i in range(nx):\n        for j in range(ny):\n            points[point_idx] = [x_coords[i], y_coords[j]]\n            point_idx += 1\n\n    # Handle trivial case of p=0.0 early\n    if p == 0.0:\n        return False\n        \n    # Handle single column case, no spanning possible unless nx=1\n    if nx <= 1:\n        return p == 1.0 # True if fully occupied (and nx=1), False otherwise\n        \n    # 2. Determine neighborhood graph (Delaunay triangulation)\n    delaunay = Delaunay(points)\n    adj = {i: set() for i in range(num_points)}\n    for simplex in delaunay.simplices:\n        p1, p2, p3 = simplex\n        adj[p1].add(p2)\n        adj[p1].add(p3)\n        adj[p2].add(p1)\n        adj[p2].add(p3)\n        adj[p3].add(p1)\n        adj[p3].add(p2)\n\n    # 3. Perform site percolation\n    rng = np.random.default_rng(s)\n    random_values = rng.random(num_points)\n    occupied = random_values < p\n\n    # 4. Identify boundary sites\n    x_min, x_max = x_coords[0], x_coords[-1]\n    \n    # As derived, left boundary is x=x_min and right is x=x_max\n    left_boundary_indices = np.where(points[:, 0] == x_min)[0]\n    right_boundary_indices = set(np.where(points[:, 0] == x_max)[0])\n\n    # 5. Find spanning cluster using BFS\n    q = deque()\n    visited = np.full(num_points, False, dtype=bool)\n\n    # Initialize queue with occupied sites on the left boundary\n    for idx in left_boundary_indices:\n        if occupied[idx] and not visited[idx]:\n            q.append(idx)\n            visited[idx] = True\n\n    while q:\n        current_idx = q.popleft()\n\n        # Check if the cluster has reached the right boundary\n        if current_idx in right_boundary_indices:\n            return True\n\n        # Explore neighbors\n        for neighbor_idx in adj[current_idx]:\n            if occupied[neighbor_idx] and not visited[neighbor_idx]:\n                visited[neighbor_idx] = True\n                q.append(neighbor_idx)\n\n    # If BFS completes without reaching the right boundary\n    return False\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2380602"}]}