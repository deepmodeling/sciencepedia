{"hands_on_practices": [{"introduction": "Many problems in physics result in differential equations of an order higher than one. To leverage the power of standard numerical solvers, which are typically designed for first-order systems, we must first master the technique of reduction. This exercise [@problem_id:2433640] challenges you to generalize this process by writing a program that can convert any explicit $n$-th order ODE into its equivalent first-order system, providing a robust tool for your computational toolkit. By testing your implementation against canonical equations with known exact solutions, you will gain confidence in this fundamental and widely applicable method.", "problem": "You are to write a complete program that constructs a numerical first-order system from an explicit higher-order ordinary differential equation (ODE) and evaluates its correctness on a specified test suite. An ordinary differential equation (ODE) is a relation involving an unknown function and its derivatives with respect to a single independent variable. In this task, the ODE is given in explicit $n$th-order form\n$$\ny^{(n)}(t) \\;=\\; G\\!\\big(t,\\,y(t),\\,y^{(1)}(t),\\,\\dots,\\,y^{(n-1)}(t)\\big),\n$$\nwhere $n \\in \\mathbb{N}$, $t \\in \\mathbb{R}$ is time, and $G$ is a known function. Your program must implement a function that, given the integer $n$ and the function $G$, returns a numerical right-hand side for the equivalent first-order system. Use this to compute outputs for the provided test suite. All angles must be in radians. No physical units are involved in the outputs; report dimensionless quantities as requested.\n\nDefinition of the required constructor function:\n- Input: an integer $n \\geq 1$ and a callable $G$ taking exactly $n+1$ real arguments $(t,x_0,\\dots,x_{n-1})$, which corresponds to the explicit right-hand side in the $n$th-order ODE $y^{(n)}(t)=G(t,y(t),\\dots,y^{(n-1)}(t))$.\n- Output: a callable $F$ that maps $(t,X)$ to a vector in $\\mathbb{R}^n$, where $X=(x_0,\\dots,x_{n-1})$ represents $(y(t),y^{(1)}(t),\\dots,y^{(n-1)}(t))$, and\n$$\nF(t,X) \\;=\\; \\big(x_1,\\;x_2,\\;\\dots,\\;x_{n-1},\\;G(t,x_0,\\dots,x_{n-1})\\big).\n$$\n\nTest suite specification:\nFor each test case, let $T>0$ be the final time, and let $\\{t_j\\}_{j=0}^{200}$ be $201$ uniformly spaced points on $[0,T]$. For each case, you must:\n- Numerically evolve the corresponding first-order system from $t=0$ to $t=T$ with the given initial state $X(0)=(y(0),y^{(1)}(0),\\dots,y^{(n-1)}(0))$.\n- Compute the maximum absolute error in the primary variable $y(t)$ over the grid $\\{t_j\\}$, namely\n$$\nE \\;=\\; \\max_{0 \\le j \\le 200}\\,\\big|\\,y_{\\text{num}}(t_j) - y_{\\text{exact}}(t_j)\\,\\big|.\n$$\n- Report the three resulting errors as floating-point numbers rounded to $6$ decimal places.\n\nAll trigonometric function arguments are in radians.\n\nTest cases:\n- Case $1$ (second-order linear oscillator): $n=2$, parameter $\\omega=2.0$. The equation is\n$$\ny^{(2)}(t) + \\omega^2\\,y(t) \\;=\\; 0,\n$$\ni.e.,\n$$\ny^{(2)}(t) \\;=\\; -\\omega^2\\,y(t).\n$$\nInitial conditions: $y(0)=1.0$, $y^{(1)}(0)=0.0$. Final time: $T=3.0$. Exact solution:\n$$\ny_{\\text{exact}}(t) \\;=\\; \\cos\\!\\big(\\omega\\,t\\big).\n$$\n\n- Case $2$ (third-order scalar equation): $n=3$. The equation is\n$$\ny^{(3)}(t) \\;=\\; -\\,y(t).\n$$\nInitial conditions: $y(0)=0.0$, $y^{(1)}(0)=1.0$, $y^{(2)}(0)=0.0$. Final time: $T=1.0$. The exact solution is the unique solution of the homogeneous linear ODE with these initial data. You must use the closed-form exact expression derived from the characteristic equation $r^3+1=0$ to evaluate $y_{\\text{exact}}(t)$ for error computation.\n\n- Case $3$ (fourth-order polynomial dynamics): $n=4$. The equation is\n$$\ny^{(4)}(t) \\;=\\; 0.\n$$\nInitial conditions: $y(0)=1.0$, $y^{(1)}(0)=2.0$, $y^{(2)}(0)=3.0$, $y^{(3)}(0)=4.0$. Final time: $T=2.0$. The exact solution is the unique cubic polynomial consistent with these initial derivatives at $t=0$.\n\nFinal output format:\nYour program should produce a single line of output containing the three rounded errors as a comma-separated list enclosed in square brackets, in the order of Cases $1$, $2$, $3$. For example, a valid output line looks like\n\"[0.000123,0.000456,0.000789]\".\n\nYour program must be self-contained and must not require any user input or external files. Angles must be in radians, and all outputs are dimensionless numbers rounded to $6$ decimal places.", "solution": "The problem statement is valid. It presents a well-posed task in computational mathematics, specifically the numerical solution of higher-order ordinary differential equations (ODEs). The methodology prescribed—reduction to a first-order system—is a standard and fundamental technique. The problem is scientifically grounded, objective, and provides all necessary information to proceed with a solution. The test cases are canonical examples from physics and mathematics for which exact solutions are known, allowing for a quantitative evaluation of the numerical method's accuracy.\n\nThe core principle is the transformation of an explicit $n$-th order ODE of the form\n$$\ny^{(n)}(t) = G\\big(t, y(t), y^{(1)}(t), \\dots, y^{(n-1)}(t)\\big)\n$$\ninto an equivalent system of $n$ first-order ODEs. This is achieved by defining a state vector $X(t) \\in \\mathbb{R}^n$ as:\n$$\nX(t) = \\begin{pmatrix} x_0(t) \\\\ x_1(t) \\\\ \\vdots \\\\ x_{n-1}(t) \\end{pmatrix} = \\begin{pmatrix} y(t) \\\\ y^{(1)}(t) \\\\ \\vdots \\\\ y^{(n-1)}(t) \\end{pmatrix}\n$$\nThe time evolution of this state vector is governed by a first-order system $\\frac{d}{dt}X(t) = F(t, X(t))$, where the function $F: \\mathbb{R} \\times \\mathbb{R}^n \\to \\mathbb{R}^n$ is defined as:\n$$\n\\frac{d}{dt} \\begin{pmatrix} x_0 \\\\ x_1 \\\\ \\vdots \\\\ x_{n-2} \\\\ x_{n-1} \\end{pmatrix} = \\begin{pmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_{n-1} \\\\ G(t, x_0, x_1, \\dots, x_{n-1}) \\end{pmatrix}\n$$\nThis structure arises directly from the definition of the state variables, where $\\frac{d}{dt}x_k = \\frac{d}{dt}y^{(k)} = y^{(k+1)} = x_{k+1}$ for $k = 0, \\dots, n-2$, and the final component is given by the original ODE, $\\frac{d}{dt}x_{n-1} = \\frac{d}{dt}y^{(n-1)} = y^{(n)} = G(t, y, y', \\dots, y^{(n-1)})$.\n\nThe solution will be implemented as follows:\n$1$. A constructor function, as specified in the problem, will be created. This function will accept the order $n$ and the right-hand side function $G$ and return the system function $F(t, X)$.\n$2$. For each test case, the corresponding parameters ($n$, $G$, initial conditions $X(0)$, final time $T$) and the exact analytical solution $y_{\\text{exact}}(t)$ will be defined.\n$3$. The numerical solution will be obtained using the `solve_ivp` function from the `scipy.integrate` library, which is a robust, adaptive solver suitable for such initial value problems. The integration will be evaluated at $201$ uniformly spaced time points $t_j$ in the interval $[0, T]$.\n$4$. The maximum absolute error $E = \\max_{j} |y_{\\text{num}}(t_j) - y_{\\text{exact}}(t_j)|$ will be computed, where $y_{\\text{num}}(t_j)$ is the first component of the state vector at time $t_j$.\n$5$. The errors for all three cases will be collected and reported in the specified format.\n\nThe details for each test case are as follows:\n\nCase $1$: Second-order linear oscillator\nThe ODE is $y^{(2)}(t) + \\omega^2 y(t) = 0$ with $\\omega = 2.0$. This is equivalent to $y^{(2)}(t) = -4y(t)$.\nThe order is $n=2$. The state vector is $X = (y, y') = (x_0, x_1)$.\nThe function $G$ is $G(t, x_0, x_1) = -4x_0$.\nThe system is $\\frac{d}{dt}(x_0, x_1) = (x_1, -4x_0)$.\nThe initial condition is $X(0) = (y(0), y'(0)) = (1.0, 0.0)$.\nThe integration interval is $[0, 3.0]$.\nThe exact solution is $y_{\\text{exact}}(t) = \\cos(2t)$.\n\nCase $2$: Third-order scalar equation\nThe ODE is $y^{(3)}(t) = -y(t)$.\nThe order is $n=3$. The state vector is $X = (y, y', y'') = (x_0, x_1, x_2)$.\nThe function $G$ is $G(t, x_0, x_1, x_2) = -x_0$.\nThe system is $\\frac{d}{dt}(x_0, x_1, x_2) = (x_1, x_2, -x_0)$.\nThe initial condition is $X(0) = (y(0), y'(0), y''(0)) = (0.0, 1.0, 0.0)$.\nThe integration interval is $[0, 1.0]$.\nTo find the exact solution, we solve the characteristic equation $r^3 + 1 = 0$. The roots are $r_1 = -1$, $r_2 = \\frac{1}{2} + i\\frac{\\sqrt{3}}{2}$, and $r_3 = \\frac{1}{2} - i\\frac{\\sqrt{3}}{2}$. The general solution is $y(t) = C_1 e^{-t} + e^{t/2}(C_2 \\cos(\\frac{\\sqrt{3}}{2}t) + C_3 \\sin(\\frac{\\sqrt{3}}{2}t))$. Applying the initial conditions yields the constants $C_1 = -1/3$, $C_2 = 1/3$, and $C_3 = \\sqrt{3}/3$.\nThus, the exact solution is $y_{\\text{exact}}(t) = -\\frac{1}{3}e^{-t} + \\frac{1}{3}e^{t/2}\\cos(\\frac{\\sqrt{3}}{2}t) + \\frac{\\sqrt{3}}{3}e^{t/2}\\sin(\\frac{\\sqrt{3}}{2}t)$.\n\nCase $3$: Fourth-order polynomial dynamics\nThe ODE is $y^{(4)}(t) = 0$.\nThe order is $n=4$. The state vector is $X = (y, y', y'', y''') = (x_0, x_1, x_2, x_3)$.\nThe function $G$ is $G(t, x_0, x_1, x_2, x_3) = 0$.\nThe system is $\\frac{d}{dt}(x_0, x_1, x_2, x_3) = (x_1, x_2, x_3, 0)$.\nThe initial condition is $X(0) = (y(0), y'(0), y''(0), y'''(0)) = (1.0, 2.0, 3.0, 4.0)$.\nThe integration interval is $[0, 2.0]$.\nThe exact solution is found by integrating $y^{(4)}(t)=0$ four times. This gives a cubic polynomial $y(t) = at^3 + bt^2 + ct + d$. The coefficients are determined by the initial conditions: $y(t) = \\frac{y'''(0)}{6}t^3 + \\frac{y''(0)}{2}t^2 + y'(0)t + y(0)$.\nSubstituting the given values: $a = 4/6 = 2/3$, $b = 3/2 = 1.5$, $c = 2$, $d = 1$.\nThe exact solution is $y_{\\text{exact}}(t) = \\frac{2}{3}t^3 + \\frac{3}{2}t^2 + 2t + 1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution of the three test cases.\n    \"\"\"\n\n    def construct_first_order_system(n, G):\n        \"\"\"\n        Constructs the right-hand side function for the equivalent first-order system.\n\n        Args:\n            n (int): The order of the ODE.\n            G (callable): The function G(t, y, y', ..., y^(n-1)).\n\n        Returns:\n            callable: A function F(t, X) for the first-order system dX/dt = F(t, X).\n        \"\"\"\n        def F(t, X):\n            if not isinstance(X, np.ndarray):\n                X = np.array(X)\n            \n            derivatives = np.zeros(n)\n            # dx_i/dt = x_{i+1} for i = 0 to n-2\n            if n > 1:\n                derivatives[:n-1] = X[1:]\n            # dx_{n-1}/dt = G(t, x_0, ..., x_{n-1})\n            derivatives[n-1] = G(t, *X)\n            return derivatives\n        return F\n\n    def run_test_case(n, G, X0, T, y_exact_func):\n        \"\"\"\n        Runs a single test case: solves the ODE and computes the error.\n\n        Args:\n            n (int): Order of the ODE.\n            G (callable): The right-hand side function of the n-th order ODE.\n            X0 (list or np.ndarray): Initial conditions [y(0), y'(0), ...].\n            T (float): Final time.\n            y_exact_func (callable): Function for the exact solution y_exact(t).\n\n        Returns:\n            float: Maximum absolute error over the time grid.\n        \"\"\"\n        # Construct the first-order system\n        F = construct_first_order_system(n, G)\n\n        # Define time grid\n        t_span = (0, T)\n        t_eval = np.linspace(0, T, 201)\n\n        # Solve the IVP\n        sol = solve_ivp(F, t_span, X0, t_eval=t_eval, rtol=1e-8, atol=1e-10)\n\n        # Extract numerical solution for y(t)\n        y_num = sol.y[0]\n\n        # Compute exact solution at grid points\n        y_exact = y_exact_func(t_eval)\n        \n        # Compute maximum absolute error\n        error = np.max(np.abs(y_num - y_exact))\n        \n        return error\n\n    # Test Case 1: Second-order linear oscillator\n    w1 = 2.0\n    case1_params = {\n        \"n\": 2,\n        \"G\": lambda t, y, y_prime: -w1**2 * y,\n        \"X0\": [1.0, 0.0],\n        \"T\": 3.0,\n        \"y_exact_func\": lambda t: np.cos(w1 * t)\n    }\n\n    # Test Case 2: Third-order scalar equation\n    def y_exact_case2(t):\n        C1 = -1.0/3.0\n        C2 = 1.0/3.0\n        C3 = np.sqrt(3.0)/3.0\n        omega = np.sqrt(3.0)/2.0\n        return (C1 * np.exp(-t) + \n                np.exp(t/2.0) * (C2 * np.cos(omega * t) + C3 * np.sin(omega * t)))\n\n    case2_params = {\n        \"n\": 3,\n        \"G\": lambda t, y, y1, y2: -y,\n        \"X0\": [0.0, 1.0, 0.0],\n        \"T\": 1.0,\n        \"y_exact_func\": y_exact_case2\n    }\n\n    # Test Case 3: Fourth-order polynomial dynamics\n    y0, y1, y2, y3 = 1.0, 2.0, 3.0, 4.0\n    case3_params = {\n        \"n\": 4,\n        \"G\": lambda t, y, y_1, y_2, y_3: 0.0,\n        \"X0\": [y0, y1, y2, y3],\n        \"T\": 2.0,\n        \"y_exact_func\": lambda t: (y3/6.0)*t**3 + (y2/2.0)*t**2 + y1*t + y0\n    }\n    \n    test_cases = [case1_params, case2_params, case3_params]\n    \n    results = []\n    for params in test_cases:\n        error = run_test_case(\n            params[\"n\"],\n            params[\"G\"],\n            params[\"X0\"],\n            params[\"T\"],\n            params[\"y_exact_func\"]\n        )\n        results.append(error)\n\n    # Format output to 6 decimal places as strings and join them\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2433640"}, {"introduction": "With the general reduction technique in hand, we can now apply it to a fascinating problem in optics. This practice [@problem_id:2433582] begins with Fermat's principle—the fundamental idea that light travels along the path of least time—to derive the equation governing a ray's trajectory through a medium with a varying refractive index, $n(y)$. You will then use the reduction method to transform this second-order ODE into a first-order system, allowing you to numerically compute the bending of light, a key principle behind technologies like graded-index optical fibers.", "problem": "A monochromatic light ray propagates in the plane with Cartesian coordinates. The optical path length functional is given by Fermat's principle as the integral $S = \\int n(y)\\,ds$, where $ds = \\sqrt{dx^2 + dy^2}$ and $n(y)$ is the refractive index depending only on the transverse coordinate $y$. Parameterize the ray path as $y(x)$ over the interval $x \\in [0,L]$. The initial position and direction are $y(0) = y_0$ and an initial angle $\\theta_0$ with respect to the positive $x$-axis, which implies $y'(0) = \\tan(\\theta_0)$. Distances must be expressed in meters and angles in radians.\n\nStarting from the functional $S = \\int n(y)\\sqrt{1+y'(x)^2}\\,dx$, obtain the governing ordinary differential equation for $y(x)$ from first principles and reduce it to a first-order system suitable for numerical solution with the state variables $y(x)$ and $v(x) = y'(x)$. For each test case below, compute the transverse position $y(L)$ in meters and the exit angle $\\theta(L)$ in radians at $x = L$.\n\nTest suite (each test case specifies a refractive index profile $n(y)$, its parameters, and the initial and terminal conditions):\n\n- Test case A (baseline, uniform medium):\n  - $n(y) = n_0$ with $n_0 = 1.5$.\n  - $y_0 = 0.0\\,\\mathrm{m}$, $\\theta_0 = 0.1\\,\\mathrm{rad}$, $L = 0.2\\,\\mathrm{m}$.\n\n- Test case B (linear graded index):\n  - $n(y) = n_0 + a\\,y$ with $n_0 = 1.0$ and $a = 0.5\\,\\mathrm{m}^{-1}$.\n  - $y_0 = 0.0\\,\\mathrm{m}$, $\\theta_0 = 0.2\\,\\mathrm{rad}$, $L = 0.5\\,\\mathrm{m}$.\n\n- Test case C (parabolic graded index, small curvature):\n  - $n(y) = n_0\\left(1 - \\dfrac{1}{2}(g\\,y)^2\\right)$ with $n_0 = 1.6$ and $g = 3.0\\,\\mathrm{m}^{-1}$.\n  - $y_0 = 0.01\\,\\mathrm{m}$, $\\theta_0 = -0.15\\,\\mathrm{rad}$, $L = 0.3\\,\\mathrm{m}$.\n\n- Test case D (boundary condition with zero propagation length):\n  - $n(y) = n_0 + a\\,y$ with $n_0 = 1.2$ and $a = 1.0\\,\\mathrm{m}^{-1}$.\n  - $y_0 = 0.02\\,\\mathrm{m}$, $\\theta_0 = 0.3\\,\\mathrm{rad}$, $L = 0.0\\,\\mathrm{m}$.\n\nYour program must output the results for all test cases in a single line, as a comma-separated list enclosed in square brackets. Each test case result must itself be a two-element list $[y(L), \\theta(L)]$ with both values rounded to six decimal places. The final output format must therefore be\n$[[y_A(L), \\theta_A(L)],[y_B(L), \\theta_B(L)],[y_C(L), \\theta_C(L)],[y_D(L), \\theta_D(L)]]$\nwith no additional text.", "solution": "The problem statement is scientifically sound, well-posed, and objective. It is based on the fundamental Fermat's principle in optics and the standard mathematical framework of the calculus of variations for deriving equations of motion. All required parameters and conditions are provided for each test case. The problem is a standard exercise in computational physics related to the reduction of higher-order ordinary differential equations (ODEs). Therefore, the problem is valid, and a solution will be provided.\n\nThe objective is to determine the trajectory of a light ray $y(x)$ in a medium with a variable refractive index $n(y)$. According to Fermat's principle, the light ray follows a path that extremizes the optical path length, given by the functional $S$:\n$$\nS[y] = \\int n(y) \\, ds\n$$\nwhere $ds = \\sqrt{dx^2 + dy^2}$ is the infinitesimal arc length. Parameterizing the path as $y(x)$, we can write $ds = \\sqrt{1 + (y'(x))^2} \\, dx$, where $y'(x) = dy/dx$. The functional becomes:\n$$\nS[y] = \\int_{0}^{L} n(y(x)) \\sqrt{1 + (y'(x))^2} \\, dx\n$$\nThis is a classic problem in the calculus of variations. The integrand, $F(y, y') = n(y)\\sqrt{1 + (y')^2}$, is the Lagrangian for the system. The path $y(x)$ that extremizes this integral must satisfy the Euler-Lagrange equation:\n$$\n\\frac{\\partial F}{\\partial y} - \\frac{d}{dx}\\left(\\frac{\\partial F}{\\partial y'}\\right) = 0\n$$\nWe compute the necessary partial derivatives of $F(y, y') = n(y)\\sqrt{1 + (y')^2}$:\n$$\n\\frac{\\partial F}{\\partial y} = \\frac{dn}{dy} \\sqrt{1 + (y')^2} = n'(y) \\sqrt{1 + (y')^2}\n$$\n$$\n\\frac{\\partial F}{\\partial y'} = n(y) \\frac{y'}{\\sqrt{1 + (y')^2}}\n$$\nSubstituting these into the Euler-Lagrange equation gives the ray equation:\n$$\nn'(y) \\sqrt{1 + (y')^2} - \\frac{d}{dx}\\left( \\frac{n(y)y'}{\\sqrt{1 + (y')^2}} \\right) = 0\n$$\nTo obtain an explicit second-order ODE for $y(x)$, we must evaluate the total derivative with respect to $x$. Let us rearrange the equation first:\n$$\n\\frac{d}{dx}\\left( \\frac{n(y)y'}{\\sqrt{1 + (y')^2}} \\right) = n'(y) \\sqrt{1 + (y')^2}\n$$\nBy applying the chain rule to the term being differentiated, $\\frac{d}{dx} = y' \\frac{\\partial}{\\partial y} + y'' \\frac{\\partial}{\\partial y'}$, and then solving for $y''$, we arrive at the following second-order ODE after algebraic simplification:\n$$\ny'' = \\frac{n'(y)}{n(y)} \\left(1 + (y')^2\\right)\n$$\nThis is the governing differential equation for the ray path $y(x)$.\n\nThe next task is to reduce this second-order ODE to a system of two first-order ODEs. We introduce the state variables as requested: $u_1(x) = y(x)$ and $u_2(x) = v(x) = y'(x)$. The state vector is $\\mathbf{u}(x) = [u_1(x), u_2(x)]^T$. We seek a system of the form $d\\mathbf{u}/dx = \\mathbf{f}(x, \\mathbf{u})$.\n\nThe first equation of the system comes directly from the definition of $u_2(x)$:\n$$\n\\frac{du_1}{dx} = \\frac{dy}{dx} = y' = v = u_2\n$$\nThe second equation is obtained by substituting the state variables into the governing ODE:\n$$\n\\frac{du_2}{dx} = \\frac{dv}{dx} = y'' = \\frac{n'(y)}{n(y)} (1 + (y')^2) = \\frac{n'(u_1)}{n(u_1)} (1 + u_2^2)\n$$\nThus, the first-order system is:\n$$\n\\frac{d}{dx}\\begin{pmatrix} y \\\\ v \\end{pmatrix} = \\begin{pmatrix} v \\\\ \\frac{n'(y)}{n(y)}(1+v^2) \\end{pmatrix}\n$$\nThe initial conditions at $x=0$ are given as $y(0) = y_0$ and an angle $\\theta_0$ with the x-axis. The initial slope is $y'(0) = v(0) = \\tan(\\theta_0)$. The initial state vector for the numerical integration is therefore:\n$$\n\\mathbf{u}(0) = \\begin{pmatrix} y(0) \\\\ v(0) \\end{pmatrix} = \\begin{pmatrix} y_0 \\\\ \\tan(\\theta_0) \\end{pmatrix}\n$$\nThis initial value problem can be solved numerically from $x=0$ to $x=L$ using standard methods like the Runge-Kutta family. After integrating, we obtain the final state vector $\\mathbf{u}(L) = [y(L), v(L)]^T$. The final transverse position is $y(L)$. The final angle $\\theta(L)$ is found from the final slope $v(L) = y'(L) = \\tan(\\theta(L))$, which gives $\\theta(L) = \\arctan(v(L))$.\n\nFor each test case, the appropriate functions for $n(y)$ and its derivative $n'(y) = dn/dy$ must be supplied to the system.\n- Case A ($n(y)=n_0$): $n'(y) = 0$. The system becomes $y' = v$, $v' = 0$. This yields $v(x) = v_0$ and $y(x) = y_0 + v_0 x$, representing a straight line, which is solved analytically.\n- Case B ($n(y)=n_0 + a\\,y$): $n'(y) = a$.\n- Case C ($n(y)=n_0(1 - \\frac{1}{2}(g\\,y)^2)$): $n'(y) = -n_0 g^2 y$.\n- Case D ($L=0$): This is a trivial case where the propagation distance is zero, so the final state is identical to the initial state. $y(L)=y(0)$ and $\\theta(L)=\\theta(0)$.\n\nCases B and C do not generally have simple analytical solutions and require numerical integration. The provided program will implement a numerical solver for these cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Solves the ray equation for different refractive index profiles.\n    Derives the ODE from Fermat's principle, reduces it to a first-order system,\n    and solves it numerically for the given test cases.\n    \"\"\"\n\n    # Define refractive index functions and their derivatives for each case\n    def n_A(y, n0, **kwargs):\n        return n0\n\n    def dn_dy_A(y, n0, **kwargs):\n        return 0.0\n\n    def n_B_D(y, n0, a, **kwargs):\n        return n0 + a * y\n\n    def dn_dy_B_D(y, n0, a, **kwargs):\n        return a\n    \n    def n_C(y, n0, g, **kwargs):\n        return n0 * (1.0 - 0.5 * (g * y)**2)\n\n    def dn_dy_C(y, n0, g, **kwargs):\n        return -n0 * g**2 * y\n\n    def ray_ode_system(x, u, n_func, dn_dy_func, params):\n        \"\"\"\n        Defines the first-order system for the ray equation.\n        u = [y, v], where v = y'.\n        y'' = (n'(y)/n(y)) * (1 + (y')^2)\n        \"\"\"\n        y, v = u\n        \n        n_val = n_func(y, **params)\n        dn_dy_val = dn_dy_func(y, **params)\n        \n        # Avoid potential division by zero, though not expected for these test cases.\n        if abs(n_val)  1e-12:\n            # At n=0, physics is singular. Stop integration.\n            # Here we can return a large number to signify an error or NaN.\n            # However, for given parameters, n(y) is always positive.\n            dv_dx = np.nan\n        else:\n            dv_dx = (dn_dy_val / n_val) * (1.0 + v**2)\n            \n        return [v, dv_dx]\n\n    test_cases = [\n        {'id': 'A', 'n_func': n_A, 'dn_dy_func': dn_dy_A, 'params': {'n0': 1.5}, 'y0': 0.0, 'theta0': 0.1, 'L': 0.2},\n        {'id': 'B', 'n_func': n_B_D, 'dn_dy_func': dn_dy_B_D, 'params': {'n0': 1.0, 'a': 0.5}, 'y0': 0.0, 'theta0': 0.2, 'L': 0.5},\n        {'id': 'C', 'n_func': n_C, 'dn_dy_func': dn_dy_C, 'params': {'n0': 1.6, 'g': 3.0}, 'y0': 0.01, 'theta0': -0.15, 'L': 0.3},\n        {'id': 'D', 'n_func': n_B_D, 'dn_dy_func': dn_dy_B_D, 'params': {'n0': 1.2, 'a': 1.0}, 'y0': 0.02, 'theta0': 0.3, 'L': 0.0},\n    ]\n\n    output_parts = []\n    \n    for case in test_cases:\n        y0, theta0, L = case['y0'], case['theta0'], case['L']\n        v0 = np.tan(theta0)\n\n        y_L = 0.0\n        theta_L = 0.0\n\n        if L == 0.0:\n            # Case D: Zero propagation distance, final state is initial state\n            y_L = y0\n            theta_L = theta0\n        elif case['id'] == 'A':\n            # Case A: Uniform medium, analytical solution (straight line)\n            # v' = 0 -> v(x) = v0. y' = v0 -> y(x) = y0 + v0*x\n            y_L = y0 + L * v0\n            theta_L = theta0\n        else:\n            # Cases B and C: Numerical integration\n            initial_state = [y0, v0]\n            \n            sol = solve_ivp(\n                ray_ode_system,\n                [0.0, L],\n                initial_state,\n                args=(case['n_func'], case['dn_dy_func'], case['params']),\n                method='DOP853',  # A high-accuracy solver\n                rtol=1e-9,\n                atol=1e-12\n            )\n            \n            y_L, v_L = sol.y[:, -1]\n            theta_L = np.arctan(v_L)\n\n        # Format each result as a string '[y,theta]' with 6 decimal places.\n        y_L_str = f\"{y_L:.6f}\"\n        theta_L_str = f\"{theta_L:.6f}\"\n        output_parts.append(f\"[{y_L_str},{theta_L_str}]\")\n\n    # Combine all results into the final required format.\n    print(f\"[{','.join(output_parts)}]\")\n\nsolve()\n```", "id": "2433582"}, {"introduction": "Our final practice tackles a subtle yet profound problem from classical electrodynamics: the self-force on an accelerating charge. The Abraham-Lorentz model leads to a third-order differential equation that notoriously permits unphysical \"runaway\" solutions. This exercise [@problem_id:2433622] challenges you to go beyond a direct numerical translation by implementing a physical boundary condition to eliminate these artifacts, transforming the problem into a boundary value problem that requires a more sophisticated computational approach. Mastering this scenario will deepen your understanding of how to critically unite physical insight with numerical strategy to obtain meaningful results.", "problem": "Consider a nonrelativistic point electron moving along one spatial dimension under a prescribed external electric field $E(t)$ in the absence of magnetic fields. The electron has charge $q=-e$ and mass $m=m_e$. The Abraham–Lorentz radiation-reaction model states that the net force equals the sum of the external force and a radiation-reaction term proportional to the time derivative of acceleration. Starting from Newton's second law and the radiation-reaction model, the governing equation for the position $x(t)$ is a third-order ordinary differential equation in time, involving $x(t)$, $\\dot{x}(t)$, $\\ddot{x}(t)$, and $\\dddot{x}(t)$. Your tasks are:\n\n- Derive a first-order system of ordinary differential equations equivalent to this third-order equation by introducing appropriate state variables. Clearly identify the state variables, their physical meanings, and their first-order time derivatives in terms of each other and the external field.\n- Explain and adopt a physically motivated boundary condition that removes runaway (exponentially growing) solutions, and state how it changes the well-posedness of the problem.\n- Implement a robust numerical strategy based on this first-order system to compute the final position $x(T)$ for several prescribed external fields. Your implementation must be a complete, runnable program, with no user input, that numerically integrates the required system and prints the requested results in the exact format described below.\n\nFundamental base and constants to use:\n- Newton's second law: $m\\,\\ddot{x}(t)=F_{\\text{net}}(t)$.\n- External electric force: $F_{\\text{ext}}(t)=q\\,E(t)$.\n- Abraham–Lorentz radiation-reaction model: $F_{\\text{rr}}(t)=m\\,\\tau\\,\\dot{a}(t)$, where $a(t)=\\ddot{x}(t)$ and $\\tau$ is a constant given by\n$$\n\\tau=\\frac{2\\,e^2}{3\\,4\\pi\\,\\varepsilon_0\\,m\\,c^3}.\n$$\n- Physical constants in the International System of Units (SI) to be used numerically in your code:\n    - Elementary charge $e=1.602176634\\times 10^{-19}$ coulombs.\n    - Electron mass $m_e=9.1093837015\\times 10^{-31}$ kilograms.\n    - Vacuum permittivity $\\varepsilon_0=8.8541878128\\times 10^{-12}$ farads per meter.\n    - Speed of light $c=299792458$ meters per second.\n\nInitial and boundary conditions:\n- Use $x(0)=0$ meters and $\\dot{x}(0)=0$ meters per second.\n- Impose the physically acceptable, non-runaway condition that $a(t)\\to 0$ as $t\\to +\\infty$. For practical computation, enforce $a(T)=0$ at a sufficiently large finite time $T$ where $E(t)$ is negligible.\n\nNumerical strategy requirements:\n- To obtain a stable and accurate computation that respects the non-runaway condition, reduce the third-order equation to a first-order system in the variables $x(t)$, $v(t)=\\dot{x}(t)$, and $a(t)=\\ddot{x}(t)$. Then, exploit the fact that the equation for $a(t)$ is linear and first order in time to compute $a(t)$ on $[0,T]$ subject to $a(T)=0$ and the given $E(t)$. Next, compute $v(t)$ and $x(t)$ on $[0,T]$ using their definitions in terms of $a(t)$. You may use any scientifically sound discretization and ordinary differential equation integration method consistent with the above physical requirements.\n- Angles are not used; no angle unit specification is needed.\n- All reported positions must be expressed in meters.\n\nTest suite:\nYour program must compute $x(T)$ for each of the following three external fields. In each case, define the characteristic Abraham–Lorentz time $\\tau$ from the constants above, and use it to construct the fields and the final time $T$. Let $U=\\frac{T}{\\tau}$ denote the dimensionless final time.\n\n1. Gaussian pulse (happy-path smooth pulse):\n   - Electric field: $E(t)=E_0\\exp\\!\\left(-\\dfrac{(t-t_c)^2}{2\\,\\sigma^2}\\right)$.\n   - Parameters: $E_0=1.0\\times 10^6$ volts per meter, $t_c=10\\,\\tau$, $\\sigma=3\\,\\tau$, $U=40$, so $T=U\\,\\tau$.\n\n2. Damped sinusoid (oscillatory forcing with decay):\n   - Electric field: $E(t)=E_0\\,\\sin(\\omega t)\\,\\exp\\!\\left(-\\dfrac{t}{T_{\\text{env}}}\\right)$.\n   - Parameters: $E_0=1.0\\times 10^6$ volts per meter, $\\omega=\\dfrac{0.2}{\\tau}$ radians per second, $T_{\\text{env}}=15\\,\\tau$, $U=60$, so $T=U\\,\\tau$.\n\n3. Zero field (edge case):\n   - Electric field: $E(t)=0$ for all $t$.\n   - Parameters: $U=10$, so $T=U\\,\\tau$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, namely $[x_1,x_2,x_3]$, where $x_k$ is the final position $x(T)$ in meters for test case $k$, represented as a floating-point decimal number with standard string formatting (no units in the printout).", "solution": "The problem statement has been analyzed and is deemed valid. It is a well-posed problem in computational physics, based on established, albeit simplified, principles of classical electrodynamics. The formulation is self-contained, objective, and provides all necessary information for a unique solution under the prescribed physical boundary condition. I will now proceed with the derivation and construction of the numerical solution.\n\nThe motion of the nonrelativistic electron is governed by Newton's second law, where the net force is the sum of the external electric force and the Abraham-Lorentz radiation-reaction force. The equation is:\n$$\nm\\,\\ddot{x}(t) = F_{\\text{net}}(t) = F_{\\text{ext}}(t) + F_{\\text{rr}}(t)\n$$\nHere, $m$ is the electron mass, $x(t)$ is its position, $F_{\\text{ext}}(t) = q\\,E(t)$ is the external force from the electric field $E(t)$ with charge $q=-e$, and $F_{\\text{rr}}(t) = m\\,\\tau\\,\\dot{a}(t)$ is the radiation-reaction force. The quantity $a(t) = \\ddot{x}(t)$ is the acceleration, and $\\tau = \\frac{2\\,e^2}{3\\,4\\pi\\,\\varepsilon_0\\,m\\,c^3}$ is the characteristic time constant of the radiation reaction. Substituting these expressions yields the governing equation:\n$$\nm\\,\\ddot{x}(t) = q\\,E(t) + m\\,\\tau\\,\\dddot{x}(t)\n$$\nThis is a third-order linear ordinary differential equation for the position $x(t)$. It is customary to write it with the highest derivative isolated:\n$$\n\\dddot{x}(t) - \\frac{1}{\\tau}\\ddot{x}(t) = \\frac{q}{m\\,\\tau}E(t)\n$$\n\nTo solve this equation numerically, we reduce it to a system of first-order differential equations. We introduce a state vector $\\mathbf{y}(t)$ whose components are the physically meaningful quantities of position, velocity, and acceleration. Let the state variables be:\n- $y_1(t) = x(t)$: position\n- $y_2(t) = v(t) = \\dot{x}(t)$: velocity\n- $y_3(t) = a(t) = \\ddot{x}(t)$: acceleration\n\nThe first-order time derivatives of these state variables are then expressed in terms of the state variables themselves and the external forcing function $E(t)$. The first two are definitions:\n$$\n\\dot{y}_1(t) = \\dot{x}(t) = v(t) = y_2(t)\n$$\n$$\n\\dot{y}_2(t) = \\dot{v}(t) = a(t) = y_3(t)\n$$\nThe third equation is obtained from the governing third-order ODE by substituting the state variables:\n$$\n\\dot{y}_3(t) = \\dot{a}(t) = \\dddot{x}(t) = \\frac{1}{\\tau}\\ddot{x}(t) + \\frac{q}{m\\,\\tau}E(t) = \\frac{1}{\\tau}y_3(t) + \\frac{q}{m\\,\\tau}E(t)\n$$\nThus, the equivalent first-order system is:\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_2 \\\\\ny_3 \\\\\n\\frac{1}{\\tau}y_3 + \\frac{q}{m\\,\\tau}E(t)\n\\end{pmatrix}\n$$\n\nThe equation for acceleration, $\\dot{a}(t) - \\frac{1}{\\tau}a(t) = \\frac{q}{m\\,\\tau}E(t)$, has a homogeneous part $\\dot{a}_h(t) - \\frac{1}{\\tau}a_h(t) = 0$ whose solution is $a_h(t) = C\\,e^{t/\\tau}$ for some constant $C$. This solution grows exponentially in time and is referred to as a \"runaway\" solution. Such behavior is unphysical; an electron's acceleration should not grow without bound in the absence of a continuously growing external force. The problem statement correctly mandates the adoption of a physical condition to eliminate this non-physical behavior, namely that $a(t) \\to 0$ as $t \\to \\infty$. This condition forces the constant $C$ to be zero, thereby selecting the unique physically acceptable solution from an infinite family of mathematical solutions. For a numerical computation over a finite interval $[0, T]$, where $T$ is chosen such that $E(t)$ is negligible for $t \\ge T$, this condition is imposed as $a(T)=0$.\n\nThe combination of two initial conditions, $x(0)=0$ and $\\dot{x}(0)=0$, with the final boundary condition $a(T)=0$ makes the problem a boundary value problem, not a simple initial value problem. The numerical strategy must respect this structure. The problem is decoupled. The equation for $a(t)$ can be solved first, independently of $x(t)$ and $v(t)$, as it does not depend on them. We must solve the linear first-order equation for $a(t)$ with a final value condition. A standard technique for this is time reversal. Let $s = T-t$, which implies $t=T-s$ and $\\frac{d}{dt} = -\\frac{d}{ds}$. The ODE for $a(t(s))$ becomes:\n$$\n-\\frac{da}{ds} = \\frac{1}{\\tau}a(s) + \\frac{q}{m\\,\\tau}E(T-s)\n$$\nRearranging gives a standard initial value problem for $a(s)$:\n$$\n\\frac{da}{ds} = -\\frac{1}{\\tau}a(s) - \\frac{q}{m\\,\\tau}E(T-s)\n$$\nThe boundary condition $a(t=T)=0$ becomes an initial condition $a(s=0)=0$. This equation can be robustly integrated forward in $s$ from $s=0$ to $s=T$ using a standard numerical solver like a Runge-Kutta method. The result is the function $a(s)$ on the interval $[0, T]$. Reversing the resulting array of values gives the solution $a(t)$ on the interval $[0, T]$.\n\nOnce the acceleration $a(t)$ is determined numerically on a discrete time grid, the velocity $v(t)$ and position $x(t)$ are obtained by successive integrations, using the initial conditions $v(0)=0$ and $x(0)=0$:\n$$\nv(t) = v(0) + \\int_0^t a(t') dt' = \\int_0^t a(t') dt'\n$$\n$$\nx(t) = x(0) + \\int_0^t v(t') dt' = \\int_0^t v(t') dt'\n$$\nThese integrations are performed numerically. For instance, the cumulative trapezoidal rule is suitable. The final position $x(T)$ is the last value obtained in the numerical integration for $x(t)$. This completes the design of the numerical solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, cumulative_trapezoid\n\ndef solve():\n    \"\"\"\n    Solves the Abraham-Lorentz equation of motion for an electron for three test cases\n    and prints the final positions.\n    \"\"\"\n    # Physical constants in SI units\n    E_CHARGE = 1.602176634e-19  # Elementary charge in Coulombs\n    M_ELECTRON = 9.1093837015e-31 # Electron mass in Kilograms\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity in Farads/meter\n    C_LIGHT = 299792458.0         # Speed of light in meters/second\n\n    # Derived constants\n    Q = -E_CHARGE\n    M = M_ELECTRON\n    # Abraham-Lorentz characteristic time\n    TAU = (2 * E_CHARGE**2) / (3 * 4 * np.pi * EPSILON_0 * M * C_LIGHT**3)\n    # Pre-calculated coefficient for the ODE\n    Q_OVER_M_TAU = Q / (M * TAU)\n\n    def compute_final_position(E_func, T, num_points):\n        \"\"\"\n        Computes the final position x(T) for a given electric field and duration.\n\n        Args:\n            E_func (callable): A function E(t) for the external electric field.\n            T (float): The final time for the simulation.\n            num_points (int): The number of points for the time grid.\n\n        Returns:\n            float: The final position x(T) in meters.\n        \"\"\"\n        # Set up a uniform time grid for the simulation.\n        t_grid = np.linspace(0.0, T, num_points)\n\n        # Define the ODE for a(s) where s = T - t.\n        # This transforms the final value problem into an initial value problem.\n        # da/ds = -a/tau - (q/(m*tau)) * E(T-s)\n        def a_ode(s, a_vec):\n            a = a_vec[0]\n            return [-a / TAU - Q_OVER_M_TAU * E_func(T - s)]\n\n        # The time-reversed variable s runs from 0 to T. We ask the solver\n        # to evaluate the solution on a grid for s that corresponds to our t_grid.\n        s_eval = np.linspace(0.0, T, num_points)\n\n        # Solve the IVP for a(s) from s=0 to s=T with initial condition a(s=0)=0.\n        # We use RK45, a standard adaptive Runge-Kutta method.\n        sol = solve_ivp(a_ode, [0.0, T], [0.0], method='RK45', t_eval=s_eval)\n        \n        a_s = sol.y[0]\n        \n        # The solution a(t) is a(s) reversed in time.\n        a_t = a_s[::-1]\n        \n        # Integrate a(t) to get v(t) with v(0)=0.\n        # cumulative_trapezoid produces an array one element shorter than the input.\n        # By setting initial=0, it prepends a 0 and returns an array of the same size.\n        v_t = cumulative_trapezoid(a_t, t_grid, initial=0.0)\n        \n        # Integrate v(t) to get x(t) with x(0)=0.\n        x_t = cumulative_trapezoid(v_t, t_grid, initial=0.0)\n        \n        # The final position is the last element of the integrated array.\n        return x_t[-1]\n\n    # Test Case 1: Gaussian pulse\n    E0_1 = 1.0e6\n    tc_1 = 10.0 * TAU\n    sigma_1 = 3.0 * TAU\n    U_1 = 40.0\n    T_1 = U_1 * TAU\n    def E1(t):\n        return E0_1 * np.exp(-((t - tc_1)**2) / (2.0 * sigma_1**2))\n    \n    # Test Case 2: Damped sinusoid\n    E0_2 = 1.0e6\n    omega_2 = 0.2 / TAU\n    T_env_2 = 15.0 * TAU\n    U_2 = 60.0\n    T_2 = U_2 * TAU\n    def E2(t):\n        # Piecewise definition to handle large arguments in exp for t0 from E(T-s)\n        if t  0:\n            return 0.0\n        return E0_2 * np.sin(omega_2 * t) * np.exp(-t / T_env_2)\n\n    # Test Case 3: Zero field\n    U_3 = 10.0\n    T_3 = U_3 * TAU\n    def E3(t):\n        return 0.0\n\n    # Number of points for each simulation.\n    # A higher density of points is used to ensure accuracy,\n    # chosen proportional to the dimensionless simulation time U.\n    points_per_tau = 2000\n    num_points_1 = int(U_1 * points_per_tau) + 1\n    num_points_2 = int(U_2 * points_per_tau) + 1\n    num_points_3 = int(U_3 * points_per_tau) + 1\n        \n    test_cases = [\n        (E1, T_1, num_points_1),\n        (E2, T_2, num_points_2),\n        (E3, T_3, num_points_3),\n    ]\n\n    results = []\n    for case in test_cases:\n        E_func, T, n_pts = case\n        x_final = compute_final_position(E_func, T, n_pts)\n        results.append(x_final)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2433622"}]}