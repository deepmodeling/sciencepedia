{"hands_on_practices": [{"introduction": "The foundation of computational physics lies in translating the laws of nature into algorithms. This first practice is your cornerstone: building a projectile motion simulator from first principles. You will implement the ordinary differential equations (ODEs) derived from Newton's second law, including quadratic drag, and use a numerical integrator to compute the trajectory step-by-step. Mastering the skills in this exercise [@problem_id:2430459], such as setting up the state evolution and handling event detection, will equip you with the fundamental tool needed for the more advanced applications that follow.", "problem": "A cannonball of mass $m$ is launched from ground level at initial speed $v_0$ and launch angle $\\theta$ above the horizontal. The motion occurs in a uniform gravitational field of magnitude $g$, with quadratic aerodynamic drag proportional to the square of the speed. The air has density $\\rho$, and the cannonball is modeled as a rigid sphere of radius $r$ with drag coefficient $C_d$ and cross-sectional area $A = \\pi r^2$. The drag force always opposes the instantaneous velocity. A vertical castle wall of height $H$ is located at horizontal distance $D$ from the launch point. The task is to determine, by first principles and numerical simulation, whether the cannonball clears the wall, defined as the projectile height at horizontal position $x = D$ being greater than or equal to $H$ before the projectile impacts the ground.\n\nYour program must:\n- Start from fundamental physical laws (Newton's second law and kinematics definitions) to formulate the equations of motion for the cannonball with quadratic air resistance under uniform gravity.\n- Implement a time-marching numerical integrator to evolve the system state $(x(t), y(t), v_x(t), v_y(t))$ from $t = 0$ until one of the following conditions occurs:\n    1. The horizontal position reaches or exceeds the wall location ($x \\ge D$).\n    2. The projectile hits the ground ($y  0$).\n    3. A predefined maximum simulation time is exceeded (declare failure to reach the wall).\n- When condition $x \\ge D$ is met, compute the vertical position at $x = D$ by linearly interpolating between the last two time steps that bracket $D$ and compare it to $H$ to decide if the wall is cleared.\n- If the projectile hits the ground before reaching $x = D$, or if the maximum simulation time is reached without attaining $x \\ge D$, declare that the wall is not cleared.\n\nAll quantities must be expressed in International System of Units (SI): lengths in $\\mathrm{m}$, mass in $\\mathrm{kg}$, time in $\\mathrm{s}$, and gravitational acceleration in $\\mathrm{m/s^2}$. Use $g = 9.81\\,\\mathrm{m/s^2}$. Angles $\\theta$ are specified in degrees.\n\nTest suite:\nUse the following five test cases. For each, output a boolean indicating whether the cannonball clears the wall (True if it clears, False otherwise). The parameters for all cases use the same air density $\\rho$ and gravitational acceleration $g$, but other parameters may vary per case.\n\nCommon parameters:\n- $\\rho = 1.225\\,\\mathrm{kg/m^3}$,\n- $g = 9.81\\,\\mathrm{m/s^2}$.\n\nPer-case parameters:\n1. Case 1 (happy path, clears easily):\n   - $m = 5.0\\,\\mathrm{kg}$, $r = 0.06\\,\\mathrm{m}$, $C_d = 0.47$, $v_0 = 200.0\\,\\mathrm{m/s}$, $\\theta = 45.0^\\circ$, $D = 100.0\\,\\mathrm{m}$, $H = 10.0\\,\\mathrm{m}$.\n2. Case 2 (boundary: purely vertical launch, never reaches the wall):\n   - $m = 5.0\\,\\mathrm{kg}$, $r = 0.06\\,\\mathrm{m}$, $C_d = 0.47$, $v_0 = 100.0\\,\\mathrm{m/s}$, $\\theta = 90.0^\\circ$, $D = 50.0\\,\\mathrm{m}$, $H = 5.0\\,\\mathrm{m}$.\n3. Case 3 (boundary: wall at the launch point):\n   - $m = 5.0\\,\\mathrm{kg}$, $r = 0.06\\,\\mathrm{m}$, $C_d = 0.47$, $v_0 = 100.0\\,\\mathrm{m/s}$, $\\theta = 45.0^\\circ$, $D = 0.0\\,\\mathrm{m}$, $H = 1.0\\,\\mathrm{m}$.\n4. Case 4 (low speed, vacuum limit to test ground impact before wall):\n   - $m = 5.0\\,\\mathrm{kg}$, $r = 0.06\\,\\mathrm{m}$, $C_d = 0.0$, $v_0 = 20.0\\,\\mathrm{m/s}$, $\\theta = 10.0^\\circ$, $D = 30.0\\,\\mathrm{m}$, $H = 0.1\\,\\mathrm{m}$.\n5. Case 5 (plausible medieval high-performance shot, clears at range):\n   - $m = 5.0\\,\\mathrm{kg}$, $r = 0.06\\,\\mathrm{m}$, $C_d = 0.47$, $v_0 = 250.0\\,\\mathrm{m/s}$, $\\theta = 45.0^\\circ$, $D = 300.0\\,\\mathrm{m}$, $H = 30.0\\,\\mathrm{m}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets. For example, a valid output with five results is of the form \"[True,False,True,False,True]\". No other text should be printed.\n\nAngle unit requirement:\nAngles $\\theta$ are provided in degrees and must be converted to radians internally for any trigonometric computations.\n\nUnit requirement:\nExpress all internal computations in SI units; comparisons are unitless booleans. The wall clearance decision compares the interpolated height $y(D)$ in $\\mathrm{m}$ to the wall height $H$ in $\\mathrm{m}$.\n\nYour program must be a complete, runnable program that hardcodes the above test suite and prints the single required output line.", "solution": "We begin from Newton's second law and kinematics. Let $(x(t), y(t))$ denote the projectile position, and $(v_x(t), v_y(t))$ its velocity components, with speed $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$. The mass is $m$, gravity has magnitude $g$ directed downward. The drag force for a sphere in a steady flow at moderate Reynolds number is modeled as quadratic in speed, with magnitude $\\frac{1}{2}\\rho C_d A v(t)^2$ and direction opposite the instantaneous velocity. Here $\\rho$ is the air density, $C_d$ is the drag coefficient, and $A = \\pi r^2$ is the cross-sectional area.\n\nBy Newton's second law,\n$$\nm \\frac{d\\mathbf{v}}{dt} = \\mathbf{F}_g + \\mathbf{F}_d,\n$$\nwhere $\\mathbf{F}_g = (0, - m g)$ and $\\mathbf{F}_d = - \\frac{1}{2} \\rho C_d A \\, v \\, \\mathbf{v}$, because $v \\, \\mathbf{v}$ equals $v^2$ in the direction of $\\mathbf{v}$ and the negative sign enforces opposition to motion. In components,\n$$\n\\frac{dv_x}{dt} = - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_x, \\quad\n\\frac{dv_y}{dt} = - g - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_y.\n$$\nKinematics provides\n$$\n\\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y.\n$$\n\nInitial conditions at launch ($t=0$) from ground level ($x(0)=0$, $y(0)=0$) are determined by the initial speed $v_0$ and angle $\\theta$ (in degrees, converted to radians $\\theta_\\mathrm{rad}$):\n$$\nv_x(0) = v_0 \\cos(\\theta_\\mathrm{rad}), \\quad v_y(0) = v_0 \\sin(\\theta_\\mathrm{rad}).\n$$\n\nThese coupled, nonlinear, first-order ordinary differential equations have no closed-form solution in general under quadratic drag, so we proceed numerically. A robust choice is the classical fourth-order Rungeâ€“Kutta (RK4) method. For a state vector $\\mathbf{s} = (x, y, v_x, v_y)$ and time step $\\Delta t$, define the right-hand side $\\mathbf{f}(\\mathbf{s}) = (v_x, v_y, a_x, a_y)$, where\n$$\na_x = - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_x, \\quad a_y = - g - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_y, \\quad v = \\sqrt{v_x^2 + v_y^2}.\n$$\nGiven $\\mathbf{s}_n$ at time $t_n$, RK4 advances to $\\mathbf{s}_{n+1}$ at $t_{n+1} = t_n + \\Delta t$ via\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{s}_n), \\\\\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_1 \\right), \\\\\n\\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_2 \\right), \\\\\n\\mathbf{k}_4 = \\mathbf{f}\\left(\\mathbf{s}_n + \\Delta t \\, \\mathbf{k}_3 \\right), \\\\\n\\mathbf{s}_{n+1} = \\mathbf{s}_n + \\frac{\\Delta t}{6} \\left( \\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4 \\right).\n\\end{aligned}\n$$\n\nTermination and event handling:\n- We integrate forward in time until one of three conditions is met: (i) the wall is reached or exceeded horizontally ($x \\ge D$), (ii) the projectile impacts the ground ($y  0$), or (iii) a maximum simulation time $t_{\\max}$ is reached to avoid infinite loops in degenerate cases (e.g., zero horizontal velocity).\n- To evaluate the vertical position at exactly the wall location $x = D$, we perform linear interpolation between the last two integration states that satisfy $x_\\text{prev}  D \\le x_\\text{next}$. Denoting the two bracketing states as $(x_\\text{prev}, y_\\text{prev})$ and $(x_\\text{next}, y_\\text{next})$, with $x_\\text{next} \\ne x_\\text{prev}$, the interpolated wall height is\n$$\ny(D) \\approx y_\\text{prev} + \\frac{D - x_\\text{prev}}{x_\\text{next} - x_\\text{prev}} \\left( y_\\text{next} - y_\\text{prev} \\right).\n$$\n- The wall is cleared if and only if $y(D) \\ge H$ and the projectile has not impacted the ground before reaching $x = D$.\n\nNumerical parameters:\n- We use $g = 9.81\\,\\mathrm{m/s^2}$, $\\rho = 1.225\\,\\mathrm{kg/m^3}$ as specified.\n- A fixed time step $\\Delta t$ such as $\\Delta t = 10^{-3}\\,\\mathrm{s}$ provides a balance between accuracy and computational cost for the distances and speeds in the test suite.\n- The maximum simulation time $t_{\\max}$ can be set to a sufficiently large value (e.g., $t_{\\max} = 200\\,\\mathrm{s}$) to ensure termination.\n\nCorrectness considerations:\n- The RK4 scheme is fourth-order accurate in $\\Delta t$ for smooth right-hand sides. The drag and gravity forces are smooth functions of the state, so the method is appropriate.\n- Linear interpolation in $x$ is justified for small $\\Delta t$ because the state varies smoothly, and the distance between $x_\\text{prev}$ and $x_\\text{next}$ is small.\n\nApplication to the test suite:\nWe now reason qualitatively about each case; the program performs the exact numerical evaluation and comparison.\n\n1. Case $1$: $m = 5.0\\,\\mathrm{kg}$, $r = 0.06\\,\\mathrm{m}$, $C_d = 0.47$, $v_0 = 200.0\\,\\mathrm{m/s}$, $\\theta = 45.0^\\circ$, $D = 100.0\\,\\mathrm{m}$, $H = 10.0\\,\\mathrm{m}$. Even without drag, the height at $x = D$ is approximately large (on the order of $10^2\\,\\mathrm{m}$), so including drag still leaves $y(D) \\gg H$. The program yields True.\n2. Case $2$: $\\theta = 90.0^\\circ$ implies $v_x(0) = 0$. The projectile moves vertically and never reaches $x = D = 50.0\\,\\mathrm{m}$, so it cannot clear the wall. The program yields False.\n3. Case $3$: $D = 0.0\\,\\mathrm{m}$ means we compare the initial height $y(0) = 0$ to $H = 1.0\\,\\mathrm{m}$. Since $0  1.0$, the wall is not cleared. The program yields False.\n4. Case $4$: $v_0 = 20.0\\,\\mathrm{m/s}$ and $\\theta = 10.0^\\circ$ in vacuum ($C_d = 0.0$) produce a low, rapidly descending trajectory that impacts the ground before $x$ reaches $D = 30.0\\,\\mathrm{m}$ (as can be verified analytically in the no-drag limit), so the wall is not cleared. The program yields False.\n5. Case $5$: $v_0 = 250.0\\,\\mathrm{m/s}$, $\\theta = 45.0^\\circ$, $D = 300.0\\,\\mathrm{m}$, $H = 30.0\\,\\mathrm{m}$. The projectile reaches $x = 300.0\\,\\mathrm{m}$ in approximately a couple of seconds and remains at a substantial altitude despite drag; thus $y(D) \\ge H$. The program yields True.\n\nTherefore, the expected output list of booleans for the five test cases, in order, is:\n[True, False, False, False, True].\n\nThe accompanying program implements the RK4 integrator, event detection, interpolation at $x = D$, and prints exactly the required output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_clearance(m, r, Cd, rho, v0, theta_deg, D, H, g=9.81, dt=1e-3, t_max=200.0):\n    \"\"\"\n    Simulate a projectile with quadratic drag and determine if it clears a wall.\n\n    Parameters:\n        m (float): mass [kg]\n        r (float): radius [m]\n        Cd (float): drag coefficient [-]\n        rho (float): air density [kg/m^3]\n        v0 (float): initial speed [m/s]\n        theta_deg (float): launch angle [deg]\n        D (float): wall horizontal distance [m]\n        H (float): wall height [m]\n        g (float): gravitational acceleration [m/s^2]\n        dt (float): time step [s]\n        t_max (float): maximum simulation time [s]\n\n    Returns:\n        bool: True if clears (y(D) >= H before ground impact), else False.\n    \"\"\"\n    # Handle trivial D == 0 without integrating\n    if D == 0.0:\n        # Launched from y=0, so cannot clear any positive H\n        return 0.0 >= H\n\n    # Cross-sectional area of sphere\n    A = np.pi * r * r\n\n    # Initial state\n    theta = np.deg2rad(theta_deg)\n    vx = v0 * np.cos(theta)\n    vy = v0 * np.sin(theta)\n    x = 0.0\n    y = 0.0\n    t = 0.0\n\n    # Precompute drag factor\n    drag_coeff_factor = 0.5 * rho * Cd * A / m\n\n    # Keep previous state for interpolation\n    prev_x, prev_y = x, y\n\n    # Integration loop using RK4\n    while t  t_max:\n        if x >= D:\n            break\n        if y  0.0:\n            # Impacted ground before reaching the wall\n            return False\n\n        # Store current for interpolation after step\n        prev_x, prev_y = x, y\n\n        # Define RHS function\n        def rhs(state):\n            sx, sy, svx, svy = state\n            v = np.hypot(svx, svy)\n            ax = -drag_coeff_factor * v * svx\n            ay = -g - drag_coeff_factor * v * svy\n            return np.array([svx, svy, ax, ay], dtype=float)\n\n        state = np.array([x, y, vx, vy], dtype=float)\n\n        k1 = rhs(state)\n        k2 = rhs(state + 0.5 * dt * k1)\n        k3 = rhs(state + 0.5 * dt * k2)\n        k4 = rhs(state + dt * k3)\n\n        state_next = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        x, y, vx, vy = state_next\n        t += dt\n\n        # Check if we have crossed or reached the wall this step\n        if x >= D:\n            dx = x - prev_x\n            if dx == 0.0:\n                # No horizontal progress; cannot interpolate meaningfully\n                # Let the loop continue (will hit t_max or ground)\n                continue\n            # Linear interpolation to find y at x = D\n            frac = (D - prev_x) / dx\n            y_at_D = prev_y + frac * (y - prev_y)\n            return y_at_D >= H\n\n    # If loop exits due to time max or other reasons without reaching D, or check at end\n    if x >= D:\n        # If exactly at or beyond D at final step, compute y_at_D by interpolation\n        dx = x - prev_x\n        if dx == 0.0:\n            # Degenerate; treat as not cleared unless y itself is defined at D (unlikely)\n            return y >= H\n        frac = (D - prev_x) / dx\n        y_at_D = prev_y + frac * (y - prev_y)\n        return y_at_D >= H\n\n    # Did not reach the wall\n    return False\n\ndef solve():\n    # Common parameters\n    rho = 1.225  # kg/m^3\n    g = 9.81     # m/s^2\n\n    # Test cases as tuples: (m, r, Cd, rho, v0, theta_deg, D, H)\n    test_cases = [\n        # Case 1: happy path, clears easily\n        (5.0, 0.06, 0.47, rho, 200.0, 45.0, 100.0, 10.0),\n        # Case 2: vertical launch; never reaches the wall\n        (5.0, 0.06, 0.47, rho, 100.0, 90.0, 50.0, 5.0),\n        # Case 3: wall at launch point\n        (5.0, 0.06, 0.47, rho, 100.0, 45.0, 0.0, 1.0),\n        # Case 4: low speed, vacuum; hits ground before reaching D\n        (5.0, 0.06, 0.0,  rho, 20.0,  10.0, 30.0, 0.1),\n        # Case 5: plausible medieval high-performance shot\n        (5.0, 0.06, 0.47, rho, 250.0, 45.0, 300.0, 30.0),\n    ]\n\n    results = []\n    for (m, r, Cd, rho_i, v0, theta_deg, D, H) in test_cases:\n        clears = simulate_clearance(\n            m=m, r=r, Cd=Cd, rho=rho_i, v0=v0,\n            theta_deg=theta_deg, D=D, H=H, g=g, dt=1e-3, t_max=200.0\n        )\n        results.append(clears)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2430459"}, {"introduction": "Once we can simulate a single trajectory, we can begin to ask \"what if\" questions and find optimal outcomes. This practice [@problem_id:2398598] addresses a classic question: what launch angle $\\theta$ yields the maximum possible horizontal range? Since air resistance complicates the problem beyond an analytical solution, you will wrap your numerical simulator within a golden-section search algorithm. This powerful, derivative-free technique allows you to systematically and efficiently find the maximum of the range function $R(\\theta)$, demonstrating how simulation can be coupled with optimization to solve practical design problems.", "problem": "You are asked to implement a complete program that uses golden-section search to maximize a univariate objective that is available only via numerical simulation. The objective function is the horizontal range (in meters) of a projectile launched at ground level at speed $v_0$ and angle $\\theta$ (in degrees) under quadratic air resistance. The equations of motion follow from Newtonâ€™s second law and are given by\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad\n\\frac{d\\mathbf{v}}{dt} = -g \\,\\mathbf{e}_y - \\frac{k}{m}\\,\\|\\mathbf{v}\\|\\,\\mathbf{v},\n$$\nwhere $\\mathbf{r} = (x,y)$ is position in meters, $\\mathbf{v} = (v_x,v_y)$ is velocity in meters per second, $m$ is mass in kilograms, $g$ is gravitational acceleration in meters per second squared, $k$ is the quadratic drag coefficient in kilograms per meter, and $\\mathbf{e}_y$ is the unit vector in the vertical direction. The initial conditions at time $t=0$ are\n$$\nx(0)=0,\\quad y(0)=0,\\quad v_x(0)=v_0\\cos\\theta,\\quad v_y(0)=v_0\\sin\\theta.\n$$\nDefine the horizontal range $R(\\theta)$ as the value of $x(t)$ at the first time the trajectory returns to the ground, that is, the smallest $t0$ such that $y(t)=0$, with linear interpolation between the last step above the ground and the first step below to estimate the crossing. Because $R(\\theta)$ has no closed form for $k0$, it must be computed by numerical time integration.\n\nFundamental base for modeling and computation:\n- Use Newtonâ€™s second law to derive the system above.\n- Discretize time and evolve the system with the classical fourth-order Rungeâ€“Kutta method, with fixed time step $\\Delta t = 0.005$ seconds.\n- Detect the ground crossing and linearly interpolate to estimate the exact landing $x$.\n- Assume constant $g$ and constant $k$.\n\nGolden-section search specification:\n- Maximize $R(\\theta)$ over the closed interval $[\\underline{\\theta},\\overline{\\theta}] = [0.1^\\circ, 89.9^\\circ]$.\n- Assume $R(\\theta)$ is unimodal on this interval.\n- Implement golden-section search using the golden ratio conjugate $\\varphi = (\\sqrt{5}-1)/2$ to bracket and shrink the search interval without derivatives.\n- Terminate when the interval width is at most $\\varepsilon_\\theta = 10^{-5}$ degrees, or after $N_{\\max} = 64$ iterations, whichever occurs first.\n- Return the midpoint of the final interval as the maximizer $\\theta^\\star$.\n\nUnits and numerical requirements:\n- All distances must be computed in meters.\n- All times must be computed in seconds.\n- All angles must be treated in degrees throughout the search, and reported in degrees.\n- Round each reported optimal angle to $4$ decimal places.\n\nTest suite:\nImplement your program so that it solves the following three test cases, each defined by $(v_0, m, k, g)$ with units as above. For each case, compute the maximizing launch angle $\\theta^\\star$ in degrees, using the specified algorithm and numerical method.\n\n- Case A (no drag baseline, interior maximum expected near $45^\\circ$): $(v_0, m, k, g) = (50, 1.0, 0.0, 9.81)$.\n- Case B (moderate quadratic drag): $(v_0, m, k, g) = (50, 0.145, 0.001286, 9.81)$.\n- Case C (strong quadratic drag, potential boundary-leaning maximum): $(v_0, m, k, g) = (20, 0.005, 0.001372, 9.81)$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the three maximizing angles (in degrees), in the order of the test cases above, each rounded to $4$ decimal places, for example: \"[45.0000,38.1234,5.6789]\". There must be no spaces in the printed list.", "solution": "The problem as stated is valid. It is a well-posed problem in computational physics and numerical optimization. All parameters, methods, and conditions are specified with sufficient clarity and are scientifically sound. The problem requires the implementation of a numerical simulation coupled with an optimization algorithm, which is a standard procedure in science and engineering. We shall proceed with the solution.\n\nThe core of this problem is to find the launch angle $\\theta$ that maximizes the horizontal range $R(\\theta)$ of a projectile subject to quadratic air resistance. Since the function $R(\\theta)$ is not available in closed form, we must construct it numerically. This process involves two main components: first, a numerical integrator to solve the equations of motion, and second, an optimization algorithm to find the maximum of the resulting function.\n\nLet us begin by formalizing the system of ordinary differential equations (ODEs). The state of the projectile at any time $t$ is described by its position $\\mathbf{r}(t) = (x(t), y(t))$ and velocity $\\mathbf{v}(t) = (v_x(t), v_y(t))$. We can define a state vector $\\mathbf{y}(t) \\in \\mathbb{R}^4$ as:\n$$\n\\mathbf{y}(t) = \\begin{pmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{pmatrix}\n$$\nThe governing equations given are $\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}$ and $\\frac{d\\mathbf{v}}{dt} = -g_v\\mathbf{e}_y - \\frac{k}{m}\\|\\mathbf{v}\\|\\mathbf{v}$. Let's be precise here, the problem uses $g$ not $g_v$. So, $\\frac{d\\mathbf{v}}{dt} = -g\\mathbf{e}_y - \\frac{k}{m}\\|\\mathbf{v}\\|\\mathbf{v}$. We can write this as a system of four first-order ODEs, $\\frac{d\\mathbf{y}}{dt} = f(t, \\mathbf{y})$:\n$$\nf(t, \\mathbf{y}) = \\begin{pmatrix} v_x \\\\ v_y \\\\ -\\frac{k}{m} \\sqrt{v_x^2 + v_y^2} \\cdot v_x \\\\ -g - \\frac{k}{m} \\sqrt{v_x^2 + v_y^2} \\cdot v_y \\end{pmatrix}\n$$\nThe initial conditions at $t=0$ for a given launch speed $v_0$ and angle $\\theta$ are:\n$$\n\\mathbf{y}(0) = \\begin{pmatrix} 0 \\\\ 0 \\\\ v_0 \\cos(\\theta_{rad}) \\\\ v_0 \\sin(\\theta_{rad}) \\end{pmatrix}\n$$\nNote that the angle $\\theta$ is given in degrees and must be converted to radians ($\\theta_{rad}$) for use in trigonometric functions.\n\nTo solve this system, we employ the classical fourth-order Runge-Kutta (RK4) method. Given the state $\\mathbf{y}_n$ at time $t_n$, the state $\\mathbf{y}_{n+1}$ at time $t_{n+1} = t_n + \\Delta t$ is approximated by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate vector slopes are:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t\\mathbf{k}_3)\n\\end{aligned}\n$$\nWe perform this integration step-by-step with a fixed time step $\\Delta t = 0.005$ seconds, starting from $\\mathbf{y}(0)$. The simulation for a given $\\theta$ terminates when the projectile hits the ground. This is detected when the vertical position $y(t)$ becomes negative. Let $\\mathbf{y}_{n-1}$ be the last state with $y_{n-1} \\ge 0$ and $\\mathbf{y}_{n}$ be the first state with $y_{n}  0$. The horizontal range $R(\\theta)$ is the interpolated value of the $x$-coordinate at the moment $y(t)=0$. Using linear interpolation between $(x_{n-1}, y_{n-1})$ and $(x_n, y_n)$, we find the range:\n$$\nR(\\theta) = x_{n-1} - y_{n-1} \\frac{x_n - x_{n-1}}{y_n - y_{n-1}}\n$$\nThis procedure defines our objective function, $R(\\theta)$, which we must maximize.\n\nThe optimization is performed using the golden-section search algorithm, which is suitable for maximizing a unimodal function on a closed interval without requiring derivatives. The search interval is $[\\underline{\\theta}, \\overline{\\theta}] = [0.1^\\circ, 89.9^\\circ]$. Let the interval at a given iteration be $[a, b]$. We compute two interior points, $c$ and $d$:\n$$\n\\begin{aligned}\nc = b - \\varphi(b - a) \\\\\nd = a + \\varphi(b - a)\n\\end{aligned}\n$$\nwhere $\\varphi = \\frac{\\sqrt{5}-1}{2}$ is the golden ratio conjugate. We then evaluate the objective function at these points, $R(c)$ and $R(d)$.\n- If $R(c)  R(d)$, the maximum must lie in the interval $[a, d]$. We update our search interval by setting $b=d$.\n- If $R(d) \\ge R(c)$, the maximum must lie in the interval $[c, b]$. We update our search interval by setting $a=c$.\nThis process is repeated, shrinking the interval width by a factor of $\\varphi$ at each step. The algorithm terminates when the interval width $(b-a)$ is less than or equal to the tolerance $\\varepsilon_\\theta = 10^{-5}$ degrees, or after a maximum of $N_{\\max} = 64$ iterations. The optimal angle, $\\theta^\\star$, is then reported as the midpoint of the final interval, $\\frac{a+b}{2}$.\n\nThe overall procedure is as follows:\n1.  Implement the function $f(t, \\mathbf{y})$ representing the ODE system.\n2.  Implement the RK4 integration step.\n3.  Implement the objective function $R(\\theta)$ which, for a given angle $\\theta$, simulates the trajectory using RK4, detects ground impact, and returns the interpolated range.\n4.  Implement the golden-section search algorithm to find the angle $\\theta^\\star \\in [0.1, 89.9]$ that maximizes $R(\\theta)$.\n5.  Apply this procedure to each of the three test cases provided.\nThe baseline case (Case A with $k=0$) serves as a crucial validation point. In the absence of air resistance, the range is given by $R(\\theta) = (v_0^2/g) \\sin(2\\theta)$, which is maximized at $\\theta = 45^\\circ$. Our numerical solution for this case should closely approximate this theoretical result.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile optimization problem for the given test cases.\n    \"\"\"\n\n    # Golden ratio conjugate as specified\n    PHI_CONJ = (np.sqrt(5) - 1.0) / 2.0\n\n    def dydt(y_state, k, m, g):\n        \"\"\"\n        Computes the derivative of the state vector for the projectile motion ODEs.\n        State vector y_state = [x, y, vx, vy].\n        \"\"\"\n        _, _, vx, vy = y_state\n        v_mag = np.sqrt(vx**2 + vy**2)\n        \n        # When v_mag is zero (at t=0), the drag term is zero.\n        # This check avoids potential division by zero if not handled carefully, though here it just multiplies.\n        if v_mag == 0.0:\n            drag_term_x = 0.0\n            drag_term_y = 0.0\n        else:\n            drag_factor = (k / m) * v_mag\n            drag_term_x = drag_factor * vx\n            drag_term_y = drag_factor * vy\n\n        ax = -drag_term_x\n        ay = -g - drag_term_y\n        \n        return np.array([vx, vy, ax, ay])\n\n    def rk4_step(f_ode, y_state, dt, k, m, g):\n        \"\"\"\n        Performs a single step of the classical fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = f_ode(y_state, k, m, g)\n        k2 = f_ode(y_state + 0.5 * dt * k1, k, m, g)\n        k3 = f_ode(y_state + 0.5 * dt * k2, k, m, g)\n        k4 = f_ode(y_state + dt * k3, k, m, g)\n        return y_state + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def calculate_range(theta_deg, v0, m, k, g):\n        \"\"\"\n        Numerically simulates projectile trajectory to calculate the horizontal range.\n        This serves as the objective function R(theta).\n        \"\"\"\n        dt = 0.005  # Time step in seconds\n        \n        # Initial conditions\n        theta_rad = np.deg2rad(theta_deg)\n        y_state = np.array([\n            0.0,  # x(0)\n            0.0,  # y(0)\n            v0 * np.cos(theta_rad),  # vx(0)\n            v0 * np.sin(theta_rad)   # vy(0)\n        ])\n\n        y_prev = y_state\n        \n        # Max simulation steps to prevent infinite loops (e.g., if it never lands)\n        max_steps = 100000 \n        for _ in range(max_steps):\n            y_curr = rk4_step(dydt, y_prev, dt, k, m, g)\n            \n            # Check for ground crossing (y becomes negative)\n            if y_curr[1]  0.0 and y_prev[1] >= 0.0:\n                # Linearly interpolate to find the range at y = 0\n                x_prev, y_pos_prev = y_prev[0], y_prev[1]\n                x_curr, y_pos_curr = y_curr[0], y_curr[1]\n                # Formula: R = x_prev - y_prev * (dx / dy)\n                range_val = x_prev - y_pos_prev * (x_curr - x_prev) / (y_pos_curr - y_pos_prev)\n                return range_val\n            \n            y_prev = y_curr\n            \n        # Return 0 if the projectile does not land within the maximum number of steps\n        return 0.0\n\n    def golden_section_maximize(f_obj, a, b, tol, max_iter):\n        \"\"\"\n        Maximizes a unimodal function f_obj on the interval [a, b] using golden-section search.\n        \"\"\"\n        # Pre-calculate initial interior points and their function values\n        h = b - a\n        c = b - PHI_CONJ * h\n        d = a + PHI_CONJ * h\n        f_c = f_obj(c)\n        f_d = f_obj(d)\n\n        for _ in range(max_iter):\n            if (b - a)  tol:\n                break\n            \n            if f_c > f_d:\n                b = d\n                d = c\n                f_d = f_c\n                h = b - a\n                c = b - PHI_CONJ * h\n                f_c = f_obj(c)\n            else:\n                a = c\n                c = d\n                f_c = f_d\n                h = b - a\n                d = a + PHI_CONJ * h\n                f_d = f_obj(d)\n                \n        return (a + b) / 2.0\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        # (v0, m, k, g)\n        (50.0, 1.0, 0.0, 9.81),        # Case A: No drag\n        (50.0, 0.145, 0.001286, 9.81), # Case B: Moderate drag (baseball-like)\n        (20.0, 0.005, 0.001372, 9.81)  # Case C: Strong drag\n    ]\n\n    results = []\n    # Search parameters\n    theta_min, theta_max = 0.1, 89.9\n    tolerance = 1e-5\n    max_iterations = 64\n\n    for v0, m, k, g in test_cases:\n        # Create a lambda function to pass parameters to the objective function\n        objective_function = lambda theta: calculate_range(theta, v0, m, k, g)\n        \n        # Perform the optimization\n        optimal_angle = golden_section_maximize(\n            objective_function, theta_min, theta_max, tolerance, max_iterations\n        )\n        \n        # Append the rounded result\n        results.append(f\"{optimal_angle:.4f}\")\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2398598"}, {"introduction": "A common challenge in physics and engineering is not just predicting an outcome from given conditions, but finding the initial conditions that lead to a desired outcome. This practice [@problem_id:2430429] introduces the \"shooting method\" to solve exactly this kind of boundary value problem. Your task is to find the precise launch angle, or angles, required to make a projectile hit a specific target $(x_T, y_T)$. By combining your trajectory simulator with a numerical root-finding algorithm, you will learn to systematically zero in on the correct initial parameters, a technique with widespread applications from orbital mechanics to electronics.", "problem": "A two-dimensional projectile of mass $m$ is launched from the origin with initial speed $v_0$ at launch angle $\\theta$ measured from the horizontal. The projectile moves under uniform gravitational acceleration $\\mathbf{g} = (0,-g)$ and experiences a quadratic aerodynamic drag force proportional to the square of the speed and opposite to the instantaneous velocity. Model the drag using Newton's second law as follows. Let the state be $\\mathbf{r}(t) = (x(t),y(t))$ and $\\mathbf{v}(t) = (v_x(t),v_y(t))$ with $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$. The equations of motion are\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\nwith initial conditions\n$$\nx(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.\n$$\nThe drag parameter $k$ is defined by\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\nwhere $\\rho$ is the air density, $C_d$ is the drag coefficient, and $A$ is the cross-sectional area.\n\nYour task is to write a complete, runnable program that, for each target point $(x_T,y_T)$, uses a root-finding algorithm to determine all launch angle(s) $\\theta \\in (0,\\tfrac{\\pi}{2})$ (strictly between horizontal and vertical) that cause the projectile to pass the vertical line $x = x_T$ at height $y = y_T$. The root-finding must be applied to a scalar function of the launch angle constructed from first principles as follows.\n\n1. For a given $\\theta$, define the scalar function\n$$\nF(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,\n$$\nwhere $t^\\star(\\theta)$ is the first time (if any) at which $x\\big(t^\\star(\\theta)\\big) = x_T$ during the flight launched at angle $\\theta$ with speed $v_0$. If the projectile never reaches $x_T$ (for example, if it lands with $y=0$ before $x$ reaches $x_T$), then $F(\\theta)$ is undefined and that $\\theta$ should not be used in a bracketing pair for root finding.\n\n2. A valid solution angle $\\theta^\\star$ satisfies $F(\\theta^\\star) = 0$. Your program must systematically search the interval $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$ with $\\theta_{\\min} = 0.1^\\circ$ and $\\theta_{\\max} = 89.9^\\circ$ to detect subintervals where $F(\\theta)$ changes sign, and then apply a one-dimensional root-finding algorithm (for example, a bracketing method) to each detected subinterval to converge to a root.\n\n3. If multiple distinct roots exist, all such angles in $(0^\\circ,90^\\circ)$ must be found and reported. If no root exists, report an empty list for that case.\n\nNumerical requirements and conventions:\n\n- Use the above differential equations and initial conditions as the only physical model; do not substitute any closed-form trajectory formulas.\n- Implement a numerical ordinary differential equation integrator that halts when $x(t)$ first equals $x_T$ (if it occurs) or when the projectile hits the ground $y(t)=0$ while descending. Use tolerances sufficiently tight to reliably detect crossings.\n- Distances must be in meters, time in seconds, mass in kilograms, air density in kilograms per cubic meter, area in square meters, and acceleration in meters per second squared. Angles must be reported in degrees.\n- Report each solution angle in degrees, rounded to three decimal places.\n- A solution angle is acceptable if, at the crossing time $t^\\star$, the value $|y(t^\\star) - y_T|$ is within $10^{-3}$ meters. Your root-finding tolerance should ensure this target accuracy.\n- For reproducibility, use the following fixed physical parameters for all test cases: $m = 0.145$ kilograms, $\\rho = 1.225$ kilograms per cubic meter, $C_d = 0.47$, $A = 0.0042$ square meters, and $g = 9.81$ meters per second squared.\n\nTest suite to cover different regimes:\n\n- Case $1$ (happy path, ground target with two solutions expected): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (80.0, 0.0)$ meters.\n- Case $2$ (elevated target, typically one or two solutions): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (60.0, 10.0)$ meters.\n- Case $3$ (short range, two solutions expected): $v_0 = 30.0$ meters per second, $(x_T,y_T) = (30.0, 0.0)$ meters.\n- Case $4$ (beyond maximum range, no solution expected): $v_0 = 40.0$ meters per second, $(x_T,y_T) = (200.0, 0.0)$ meters.\n\nProgram input and output specification:\n\n- There is no external input. Use the exact constants and test suite above.\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets. Each case's result must be a list of the solution angle(s) in degrees, sorted in ascending order and rounded to three decimal places. If no solution exists for a case, output an empty list for that case.\n- For example, the required overall output format is like $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$ with numeric entries shown in decimal form and no extra text.\n\nYour program must be complete and runnable as provided, and it must use a root-finding algorithm applied to $F(\\theta)$ as defined above to locate the solution angle(s) for each case. Angles must be reported in degrees.", "solution": "The problem proposed is a well-defined and standard exercise in computational physics. It is scientifically grounded, mathematically consistent, and all necessary parameters for its solution are provided. The physical model, based on Newton's second law with quadratic air resistance, is a canonical representation of projectile motion in a viscous medium. The numerical task, which is to find the launch angles that result in the projectile passing through a specific target point, constitutes a boundary value problem. The prescribed method of solutionâ€”the shooting method coupled with a root-finding algorithm for a scalar functionâ€”is a robust and appropriate technique for this class of problems. Therefore, the problem is valid and we shall proceed with a complete solution.\n\nThe core of the problem is to solve a system of coupled first-order ordinary differential equations (ODEs). Let the state of the system at time $t$ be described by the vector $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$. The equations of motion can be written in the form $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$, where the function $\\mathbf{f}$ is defined as:\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\nThe initial state at $t=0$ is given by $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$. The parameter $\\theta$ is the launch angle, which we must determine.\n\nA direct analytical solution for the trajectory $\\mathbf{r}(t)$ does not exist for this system. We must employ a numerical approach. The problem asks us to find the value(s) of $\\theta$ for which the trajectory passes through the target point $(x_T, y_T)$. This is a boundary value problem. We will solve it using a \"shooting method,\" which transforms the boundary value problem into a root-finding problem.\n\nThe shooting method proceeds as follows:\n1.  We select a trial launch angle $\\theta$. This fully specifies the initial conditions $\\mathbf{S}(0)$.\n2.  We numerically integrate the system of ODEs from $t=0$ forward in time. This process \"shoots\" the projectile.\n3.  We monitor the trajectory to find the time $t^\\star$ at which the projectile's horizontal position $x(t)$ first equals the target's horizontal position $x_T$.\n4.  At this time $t^\\star$, we evaluate the projectile's height, $y(t^\\star)$.\n5.  We define a scalar objective function, $F(\\theta)$, as the difference between the projectile's height at $x=x_T$ and the target height $y_T$:\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    A solution angle $\\theta^\\star$ is one for which $F(\\theta^\\star) = 0$. The problem is therefore reduced to finding the roots of the function $F(\\theta)$.\n\nTo implement this method, we require a robust ODE integrator. The `solve_ivp` function from the SciPy library is an excellent tool for this. A critical feature of `solve_ivp` is its ability to detect \"events\"â€”conditions where a function of the state and time becomes zero. We will use this feature to precisely determine the crossing time $t^\\star$ without having to integrate to a fixed maximum time and then interpolate.\n\nWe define two terminal event functions:\n1.  `event_reach_x_target(t, S)`: This function returns $x(t) - x_T$. The integrator will stop when this value is zero, indicating the projectile has reached the target's longitude.\n2.  `event_hit_ground(t, S)`: This function returns $y(t)$. We configure it to trigger only when $y(t)$ is decreasing (i.e., the projectile is falling), which signals that the projectile has hit the ground before reaching $x=x_T$.\n\nThe function $F(\\theta)$ is constructed by calling the ODE solver for a given $\\theta$. If the integration is terminated by the `event_reach_x_target` event, we calculate and return $y(t^\\star) - y_T$. If it is terminated by `event_hit_ground`, or if it reaches a maximum simulation time without triggering any event, it means the trajectory falls short. In this case, the function $F(\\theta)$ is considered undefined for the purpose of bracketing, and we can return a non-numerical value like `NaN` (Not a Number) to signify this.\n\nTo find all roots of $F(\\theta)=0$ in the specified interval $\\theta \\in [0.1^\\circ, 89.9^\\circ]$, we employ a two-stage process:\n1.  **Bracketing**: We first discretize the search interval into a fine grid of angles. We evaluate $F(\\theta)$ at each point on this grid. By searching for adjacent grid points $(\\theta_i, \\theta_{i+1})$ where the sign of the function changes (i.e., $F(\\theta_i) \\cdot F(\\theta_{i+1})  0$), we identify sub-intervals that are guaranteed to contain at least one root, according to the Intermediate Value Theorem. It is important to handle the `NaN` cases correctly, as a valid bracket requires defined numerical values at both ends.\n2.  **Solving**: For each bracket $[\\theta_a, \\theta_b]$ found, we apply a numerical root-finding algorithm. Brent's method, implemented in `scipy.optimize.brentq`, is a highly effective choice. It combines the guaranteed convergence of the bisection method with the faster convergence of the secant method, and it is the standard for one-dimensional root-finding when a bracketing interval is known. The tolerance of the root-finder will be set to ensure the required precision on both the angle and the final target height.\n\nThis systematic procedure of numerical integration, event detection, bracketing, and root-solving will be applied to each test case to find all valid launch angles.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2  0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root)  1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}]}