{"hands_on_practices": [{"introduction": "This practice serves as the cornerstone of our hands-on work, guiding you to implement a general-purpose solver for a common class of 1D boundary value problems ([@problem_id:2392775]). By learning to handle variable coefficients and diverse boundary conditions such as Dirichlet, Neumann, and Robin, you will build a flexible computational tool and gain a deep understanding of how differential operators are translated into solvable matrix equations.", "problem": "You are asked to design and implement a general-purpose finite difference solver for a linear, second-order, self-adjoint boundary value problem on a closed interval. The governing equation is the steady one-dimensional linear differential equation in conservation form:\n$$\n- \\frac{d}{dx}\\!\\left(p(x)\\,\\frac{du}{dx}\\right) + q(x)\\,u(x) = r(x), \\quad x \\in [a,b].\n$$\nThe function $u(x)$ is unknown, while $p(x)$, $q(x)$, and $r(x)$ are given functions with $p(x) \\gt 0$ on $[a,b]$. You must support boundary conditions at both $x=a$ and $x=b$ of the following types:\n- Dirichlet: $u = \\text{value}$,\n- Neumann: $u' = \\text{value}$,\n- Robin: $\\alpha\\,u + \\beta\\,u' = \\gamma$, where $\\alpha$, $\\beta$, and $\\gamma$ are given constants.\n\nYour task is to:\n- Derive a stable second-order accurate finite difference discretization of the interior operator based on flux differences, using midpoint evaluations of $p(x)$, and central differences for gradients.\n- Derive second-order accurate one-sided boundary stencils for $u'(a)$ and $u'(b)$ suitable for Neumann and Robin boundary conditions.\n- Implement a solver that accepts arbitrary Python callables for $p(x)$, $q(x)$, and $r(x)$; real numbers $a$, $b$; an integer $N \\ge 2$ specifying the number of subintervals of a uniform grid; and boundary condition specifications at both ends, returning the grid points and the numerical solution vector.\n\nFundamental base you may use for derivations:\n- The definition of the derivative as a limit of difference quotients and standard Taylor expansions.\n- The interpretation of the conservative operator $-\\frac{d}{dx}(p\\,u')$ as the negative divergence of a flux.\n- Widely used central and one-sided finite difference formulas derived from Taylor series.\n\nYour program must validate the solver on the following four test cases, each on a uniform grid of $N$ subintervals with step $h = (b-a)/N$, and must compute the maximum absolute error over the grid compared to the provided analytic solution for each case.\n\nTest Suite:\n- Case $1$ (Dirichlet–Dirichlet, constant $p$, no reaction):\n  - Domain: $[a,b] = [0,1]$, choose $N = 200$.\n  - Coefficients: $p(x) = 1$, $q(x) = 0$, $r(x) = \\sin(\\pi x)$.\n  - Boundary conditions: $u(0) = 0$, $u(1) = 0$.\n  - Analytic solution: $u_\\text{exact}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$.\n- Case $2$ (Dirichlet–Neumann, constant $p$, positive reaction):\n  - Domain: $[a,b] = [0,1]$, choose $N = 200$.\n  - Coefficients: $p(x) = 1$, $q(x) = 1$, $r(x) = 0$.\n  - Boundary conditions: $u(0) = e^0 = 1$, $u'(1) = e^1$.\n  - Analytic solution: $u_\\text{exact}(x) = e^x$.\n- Case $3$ (Robin–Robin, variable $p$ and $q$):\n  - Domain: $[a,b] = [0,1]$, choose $N = 200$.\n  - Coefficients: $p(x) = 1 + x$, $q(x) = x^2$, $r(x) = 1 + 4x + x^3 - x^4$.\n  - Boundary conditions at $x=0$: $\\alpha_L = 2$, $\\beta_L = 1$, $\\gamma_L = 1$; at $x=1$: $\\alpha_R = 3$, $\\beta_R = -1$, $\\gamma_R = 1$.\n  - Analytic solution: $u_\\text{exact}(x) = x(1-x)$.\n- Case $4$ (Neumann–Neumann, constant coefficients with strictly positive reaction to ensure uniqueness):\n  - Domain: $[a,b] = [0,1]$, choose $N = 80$.\n  - Coefficients: $p(x) = 2$, $q(x) = 5$, $r(x) = 7 \\cos(x)$.\n  - Boundary conditions: $u'(0) = 0$, $u'(1) = -\\sin(1)$.\n  - Analytic solution: $u_\\text{exact}(x) = \\cos(x)$.\n\nNumerical requirements and output:\n- Use a uniform grid with $N$ subintervals and $N+1$ nodes, and approximate $p$ at half-nodes using midpoint evaluation $p(x_i \\pm h/2)$.\n- For interior nodes $x_i$, $i \\in \\{1,2,\\dots,N-1\\}$, discretize the conservative form using flux differences to obtain a tri-diagonal contribution.\n- For Neumann and Robin boundary conditions, use the second-order one-sided approximations:\n  - Left derivative: $u'(a) \\approx \\dfrac{-3u_0 + 4u_1 - u_2}{2h}$,\n  - Right derivative: $u'(b) \\approx \\dfrac{3u_N - 4u_{N-1} + u_{N-2}}{2h}$.\n- Your program must compute, for each case, the maximum absolute error over all grid nodes, and then produce a single line of output containing the four errors as a comma-separated list enclosed in square brackets, in the order of cases $1$ through $4$. Express each error as a floating-point number. For consistency, round each error to eight decimal places before printing.", "solution": "The problem presented is a linear, second-order, self-adjoint ordinary differential equation, a form of the Sturm-Liouville problem, defined on a closed interval $[a, b]$ with specified boundary conditions. The governing equation is:\n$$\n- \\frac{d}{dx}\\!\\left(p(x)\\,\\frac{du}{dx}\\right) + q(x)\\,u(x) = r(x)\n$$\nwhere $p(x) > 0$. We are tasked with developing a second-order accurate finite difference solver for this boundary value problem (BVP). The derivation proceeds as follows.\n\nFirst, we establish a uniform computational grid. The domain $[a, b]$ is discretized into $N$ subintervals of equal width $h = (b-a)/N$. This creates $N+1$ grid points, or nodes, indexed from $i=0$ to $i=N$, located at positions $x_i = a + i h$. Our objective is to determine the approximate values of the unknown function $u(x)$ at these nodes, denoted by $u_i \\approx u(x_i)$.\n\nThe core of the method is the discretization of the differential operator at the interior nodes of the grid, i.e., for $i \\in \\{1, 2, \\dots, N-1\\}$. The operator is given in conservative form, which suggests a discretization based on the flux, $F(x) = -p(x) \\frac{du}{dx}$. The differential equation can be written as $-\\frac{dF}{dx} + q(x)u(x) = r(x)$.\n\nAt an interior node $x_i$, we approximate the term $-\\frac{dF}{dx}$ using a central difference on the fluxes evaluated at the midpoints of the grid cells, $x_{i \\pm 1/2} = x_i \\pm h/2$:\n$$\n\\left. -\\frac{dF}{dx} \\right|_{x_i} \\approx -\\frac{F(x_{i+1/2}) - F(x_{i-1/2})}{h}\n$$\nThis is a second-order accurate approximation. The flux $F$ itself must be approximated at these midpoints. We use a central difference for the derivative $\\frac{du}{dx}$ centered at the midpoints:\n$$\n\\left. \\frac{du}{dx} \\right|_{x_{i+1/2}} \\approx \\frac{u(x_{i+1}) - u(x_i)}{h} = \\frac{u_{i+1} - u_i}{h}\n$$\n$$\n\\left. \\frac{du}{dx} \\right|_{x_{i-1/2}} \\approx \\frac{u(x_i) - u(x_{i-1})}{h} = \\frac{u_i - u_{i-1}}{h}\n$$\nThe problem specifies that the coefficient $p(x)$ is evaluated at the midpoints, $p_{i \\pm 1/2} = p(x_{i \\pm 1/2})$. The fluxes are therefore approximated as:\n$$\nF_{i+1/2} \\approx -p_{i+1/2} \\frac{u_{i+1} - u_i}{h}\n$$\n$$\nF_{i-1/2} \\approx -p_{i-1/2} \\frac{u_i - u_{i-1}}{h}\n$$\nSubstituting these flux approximations into the equation for $-\\frac{dF}{dx}$ yields:\n$$\n\\left. -\\frac{dF}{dx} \\right|_{x_i} \\approx -\\frac{1}{h} \\left( -p_{i+1/2} \\frac{u_{i+1} - u_i}{h} - \\left(-p_{i-1/2} \\frac{u_i - u_{i-1}}{h}\\right) \\right) = \\frac{1}{h^2} \\left( p_{i+1/2}(u_{i+1} - u_i) - p_{i-1/2}(u_i - u_{i-1}) \\right)\n$$\nRecombining this with the other terms in the governing equation, evaluated at $x_i$, we get the full discretized equation for an interior node:\n$$\n\\frac{1}{h^2} \\left[ -p_{i-1/2} u_{i-1} + (p_{i-1/2} + p_{i+1/2}) u_i - p_{i+1/2} u_{i+1} \\right] + q(x_i) u_i = r(x_i)\n$$\nBy collecting terms associated with $u_{i-1}$, $u_i$, and $u_{i+1}$, we obtain the linear algebraic equation for row $i$:\n$$\n\\left( -\\frac{p_{i-1/2}}{h^2} \\right) u_{i-1} + \\left( \\frac{p_{i-1/2} + p_{i+1/2}}{h^2} + q_i \\right) u_i + \\left( -\\frac{p_{i+1/2}}{h^2} \\right) u_{i+1} = r_i\n$$\nwhere $q_i = q(x_i)$ and $r_i = r(x_i)$. This provides $N-1$ equations for the $N+1$ unknowns $\\{u_0, u_1, \\dots, u_N\\}$. The remaining two equations are derived from the boundary conditions at $x_0=a$ and $x_N=b$.\n\nWe now form the equations for the boundary nodes, $i=0$ and $i=N$.\n\n**Left Boundary at $x_0 = a$ (Row $0$):**\n- **Dirichlet Condition:** $u(a) = \\gamma_L$.\n  This condition is implemented directly as $u_0 = \\gamma_L$. The first equation is $1 \\cdot u_0 = \\gamma_L$.\n- **Neumann Condition:** $u'(a) = \\gamma_L$.\n  We use the provided second-order accurate one-sided forward difference formula:\n  $$u'(a) \\approx \\frac{-3u_0 + 4u_1 - u_2}{2h} = \\gamma_L$$\n  This yields the linear equation: $-3u_0 + 4u_1 - u_2 = 2h\\gamma_L$.\n- **Robin Condition:** $\\alpha_L u(a) + \\beta_L u'(a) = \\gamma_L$.\n  Substituting the same one-sided formula for $u'(a)$:\n  $$\\alpha_L u_0 + \\beta_L \\left(\\frac{-3u_0 + 4u_1 - u_2}{2h}\\right) = \\gamma_L$$\n  Multiplying by $2h$ and grouping terms gives the equation:\n  $$(2h\\alpha_L - 3\\beta_L)u_0 + (4\\beta_L)u_1 - \\beta_L u_2 = 2h\\gamma_L$$\n\n**Right Boundary at $x_N = b$ (Row $N$):**\n- **Dirichlet Condition:** $u(b) = \\gamma_R$.\n  This is simply $u_N = \\gamma_R$. The last equation is $1 \\cdot u_N = \\gamma_R$.\n- **Neumann Condition:** $u'(b) = \\gamma_R$.\n  We use the provided second-order accurate one-sided backward difference formula:\n  $$u'(b) \\approx \\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h} = \\gamma_R$$\n  This yields the linear equation: $3u_N - 4u_{N-1} + u_{N-2} = 2h\\gamma_R$.\n- **Robin Condition:** $\\alpha_R u(b) + \\beta_R u'(b) = \\gamma_R$.\n  Substituting the one-sided formula for $u'(b)$:\n  $$\\alpha_R u_N + \\beta_R \\left(\\frac{3u_N - 4u_{N-1} + u_{N-2}}{2h}\\right) = \\gamma_R$$\n  Multiplying by $2h$ and grouping terms gives the equation:\n  $$\\beta_R u_{N-2} - (4\\beta_R)u_{N-1} + (2h\\alpha_R + 3\\beta_R)u_N = 2h\\gamma_R$$\n\nThese equations collectively form a system of $N+1$ linear equations in $N+1$ unknowns, which can be written in matrix form as $A\\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_0, u_1, \\dots, u_N]^T$. The matrix $A$ and vector $\\mathbf{b}$ are constructed row by row.\n\n- **Rows $i=1, \\dots, N-1$ (Interior):**\n  $A_{i, i-1} = -p_{i-1/2}/h^2$\n  $A_{i, i} = (p_{i-1/2} + p_{i+1/2})/h^2 + q_i$\n  $A_{i, i+1} = -p_{i+1/2}/h^2$\n  $b_i = r_i$\n\n- **Row $0$ (Left Boundary):**\n  - Dirichlet ($\\gamma_L$): $A_{0,0}=1$, $b_0=\\gamma_L$.\n  - Neumann ($\\gamma_L$): $A_{0,0}=-3$, $A_{0,1}=4$, $A_{0,2}=-1$, $b_0=2h\\gamma_L$.\n  - Robin ($\\alpha_L, \\beta_L, \\gamma_L$): $A_{0,0}=2h\\alpha_L-3\\beta_L$, $A_{0,1}=4\\beta_L$, $A_{0,2}=-\\beta_L$, $b_0=2h\\gamma_L$.\n\n- **Row $N$ (Right Boundary):**\n  - Dirichlet ($\\gamma_R$): $A_{N,N}=1$, $b_N=\\gamma_R$.\n  - Neumann ($\\gamma_R$): $A_{N,N-2}=1$, $A_{N,N-1}=-4$, $A_{N,N}=3$, $b_N=2h\\gamma_R$.\n  - Robin ($\\alpha_R, \\beta_R, \\gamma_R$): $A_{N,N-2}=\\beta_R$, $A_{N,N-1}=-4\\beta_R$, $A_{N,N}=2h\\alpha_R+3\\beta_R$, $b_N=2h\\gamma_R$.\n\nAll other elements of $A$ are zero. The resulting matrix $A$ is sparse and banded. For the specified problem parameters, this system is non-singular and has a unique solution $\\mathbf{u} = A^{-1}\\mathbf{b}$, which can be found using a standard linear algebra solver.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(p, q, r, a, b, N, bc_left, bc_right):\n    \"\"\"\n    Solves a linear, second-order, self-adjoint BVP using finite differences.\n\n    Equation: -(p(x)u')' + q(x)u(x) = r(x) on [a, b]\n\n    Args:\n        p (callable): Coefficient function p(x).\n        q (callable): Coefficient function q(x).\n        r (callable): Source function r(x).\n        a (float): Left boundary of the domain.\n        b (float): Right boundary of the domain.\n        N (int): Number of subintervals in the uniform grid.\n        bc_left (tuple): Left boundary condition.\n            - ('dirichlet', gamma): u(a) = gamma\n            - ('neumann', gamma): u'(a) = gamma\n            - ('robin', alpha, beta, gamma): alpha*u(a) + beta*u'(a) = gamma\n        bc_right (tuple): Right boundary condition (similar format).\n\n    Returns:\n        tuple: (x, u) where x is the grid and u is the numerical solution.\n    \"\"\"\n    if N < 2:\n        raise ValueError(\"N must be at least 2.\")\n\n    h = (b - a) / N\n    x = np.linspace(a, b, N + 1)\n    \n    A = np.zeros((N + 1, N + 1))\n    rhs = np.zeros(N + 1)\n\n    # Interior points (i = 1, ..., N-1)\n    for i in range(1, N):\n        x_i = x[i]\n        p_minus_half = p(x_i - h / 2)\n        p_plus_half = p(x_i + h / 2)\n        \n        A[i, i-1] = -p_minus_half / h**2\n        A[i, i] = (p_minus_half + p_plus_half) / h**2 + q(x_i)\n        A[i, i+1] = -p_plus_half / h**2\n        rhs[i] = r(x_i)\n\n    # Left boundary condition (i = 0)\n    bc_type_left = bc_left[0]\n    if bc_type_left == 'dirichlet':\n        gamma_L = bc_left[1]\n        A[0, 0] = 1\n        rhs[0] = gamma_L\n    elif bc_type_left == 'neumann':\n        gamma_L = bc_left[1]\n        A[0, 0] = -3\n        A[0, 1] = 4\n        A[0, 2] = -1\n        rhs[0] = 2 * h * gamma_L\n    elif bc_type_left == 'robin':\n        alpha_L, beta_L, gamma_L = bc_left[1:]\n        A[0, 0] = 2 * h * alpha_L - 3 * beta_L\n        A[0, 1] = 4 * beta_L\n        A[0, 2] = -beta_L\n        rhs[0] = 2 * h * gamma_L\n    else:\n        raise ValueError(f\"Unknown left boundary condition type: {bc_type_left}\")\n\n    # Right boundary condition (i = N)\n    bc_type_right = bc_right[0]\n    if bc_type_right == 'dirichlet':\n        gamma_R = bc_right[1]\n        A[N, N] = 1\n        rhs[N] = gamma_R\n    elif bc_type_right == 'neumann':\n        gamma_R = bc_right[1]\n        A[N, N-2] = 1\n        A[N, N-1] = -4\n        A[N, N] = 3\n        rhs[N] = 2 * h * gamma_R\n    elif bc_type_right == 'robin':\n        alpha_R, beta_R, gamma_R = bc_right[1:]\n        A[N, N-2] = beta_R\n        A[N, N-1] = -4 * beta_R\n        A[N, N] = 2 * h * alpha_R + 3 * beta_R\n        rhs[N] = 2 * h * gamma_R\n    else:\n        raise ValueError(f\"Unknown right boundary condition type: {bc_type_right}\")\n\n    u = np.linalg.solve(A, rhs)\n    return x, u\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (Dirichlet–Dirichlet)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0,\n            'q': lambda x: 0.0,\n            'r': lambda x: np.sin(np.pi * x),\n            'bc_left': ('dirichlet', 0.0),\n            'bc_right': ('dirichlet', 0.0),\n            'u_exact': lambda x: np.sin(np.pi * x) / (np.pi**2)\n        },\n        # Case 2 (Dirichlet–Neumann)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0,\n            'q': lambda x: 1.0,\n            'r': lambda x: 0.0,\n            'bc_left': ('dirichlet', 1.0),\n            'bc_right': ('neumann', np.e),\n            'u_exact': lambda x: np.exp(x)\n        },\n        # Case 3 (Robin–Robin)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 200,\n            'p': lambda x: 1.0 + x,\n            'q': lambda x: x**2,\n            'r': lambda x: 1.0 + 4.0*x + x**3 - x**4,\n            'bc_left': ('robin', 2.0, 1.0, 1.0),\n            'bc_right': ('robin', 3.0, -1.0, 1.0),\n            'u_exact': lambda x: x * (1.0 - x)\n        },\n        # Case 4 (Neumann–Neumann)\n        {\n            'a': 0.0, 'b': 1.0, 'N': 80,\n            'p': lambda x: 2.0,\n            'q': lambda x: 5.0,\n            'r': lambda x: 7.0 * np.cos(x),\n            'bc_left': ('neumann', 0.0),\n            'bc_right': ('neumann', -np.sin(1.0)),\n            'u_exact': lambda x: np.cos(x)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        x_grid, u_numerical = solve_bvp(\n            p=case['p'],\n            q=case['q'],\n            r=case['r'],\n            a=case['a'],\n            b=case['b'],\n            N=case['N'],\n            bc_left=case['bc_left'],\n            bc_right=case['bc_right']\n        )\n        \n        u_analytic = case['u_exact'](x_grid)\n        \n        # Compute maximum absolute error\n        max_abs_error = np.max(np.abs(u_numerical - u_analytic))\n        \n        # Round to 8 decimal places as required\n        results.append(round(max_abs_error, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392775"}, {"introduction": "Building on the 1D foundation, this exercise takes you into two dimensions by tackling the famous Laplace equation, $\\nabla^2 \\phi = 0$, which governs phenomena from electrostatics to steady-state heat flow. You will practice applying the five-point stencil for the Laplacian and manage the crucial organizational challenge of mapping a 2D grid of unknowns into a single linear system for solution ([@problem_id:2392730]).", "problem": "Consider the electrostatic potential field inside a square region governed by electrostatics in the absence of free charge. The fundamental base is that, in electrostatics, the electric field satisfies $\\nabla \\cdot \\mathbf{E} = \\rho / \\varepsilon_0$ and $\\mathbf{E} = -\\nabla \\phi$. For a region with $\\rho = 0$ (no free charge), the potential $\\phi(x,y)$ satisfies the two-dimensional Laplace equation $\\nabla^2 \\phi = 0$ with Dirichlet boundary conditions (fixed values of the potential on the boundary). You are to discretize this boundary value problem using the Finite Difference Method (FDM) with second-order central differences to obtain a linear system for the interior grid values and solve it numerically.\n\nA square box of side length $L$ (in meters) has its right wall at $x = L$ held at a fixed potential $V_0$ (in volts), while the other three walls at $x = 0$, $y = 0$, and $y = L$ are grounded at $0$ volts. Use a uniform grid of $N$ grid points per direction, including the boundaries, so the grid spacing is $h = L / (N-1)$. Let $\\phi_{i,j}$ denote the discrete potential at the grid point $(x_i, y_j) = (i h, j h)$, where $i, j \\in \\{0, 1, \\dots, N-1\\}$. The interior unknowns are those with $i, j \\in \\{1, 2, \\dots, N-2\\}$. Using second-order central differences to approximate $\\nabla^2 \\phi$, formulate the resulting linear system for the interior values $\\phi_{i,j}$, enforce the Dirichlet boundary conditions on the four walls, and solve for the potential.\n\nYour program must:\n- Construct the five-point stencil discrete Laplace operator corresponding to the second-order central difference approximation on a uniform grid.\n- Incorporate the boundary values into the right-hand side consistently with Dirichlet boundary conditions, where the right wall at $x=L$ has $\\phi = V_0$ and the other three walls have $\\phi = 0$.\n- Solve the linear system for the interior unknowns.\n- Extract and report the potential at the geometric center $(x,y) = (L/2, L/2)$. Assume $N$ is odd so that the geometric center coincides with a grid point. Report the center value in volts.\n\nPhysical units: potentials must be reported in volts, expressed as decimal floats rounded to six decimals.\n\nAngle units: no angles are involved.\n\nYour program should use the following test suite, each specified as a tuple $(L, N, V_0)$ with $L$ in meters and $V_0$ in volts:\n- Test $1$: $(L, N, V_0) = (1.0, 3, 1.0)$\n- Test $2$: $(L, N, V_0) = (1.0, 5, 1.0)$\n- Test $3$: $(L, N, V_0) = (1.0, 21, 2.0)$\n\nFor each test, compute a single float: the value of $\\phi$ at the geometric center in volts, rounded to six decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the tests above. For example, the format must be exactly like $[r_1,r_2,r_3]$ where each $r_k$ is a decimal float with six digits after the decimal point.", "solution": "The problem presented is a classic boundary value problem in electrostatics, specifically the solution of the two-dimensional Laplace equation in a square domain with specified Dirichlet boundary conditions. The problem is scientifically grounded, well-posed, and contains all necessary information for a numerical solution. It is therefore deemed valid.\n\nThe governing partial differential equation for the electrostatic potential $\\phi(x,y)$ in a charge-free region ($\\rho=0$) is the Laplace equation:\n$$\n\\nabla^2 \\phi(x,y) = \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = 0\n$$\nThe domain is a square of side length $L$, defined by $x \\in [0, L]$ and $y \\in [0, L]$. The boundary conditions are of the Dirichlet type, meaning the potential is fixed on the boundaries:\n- $\\phi(x,0) = 0$ (bottom wall)\n- $\\phi(x,L) = 0$ (top wall)\n- $\\phi(0,y) = 0$ (left wall)\n- $\\phi(L,y) = V_0$ (right wall)\n\nTo solve this problem numerically, we employ the Finite Difference Method (FDM). First, the continuous domain is discretized into a uniform grid of points $(x_i, y_j)$, where $x_i = i h$ and $y_j = j h$. The grid spacing $h$ is given by $h = L / (N-1)$, where $N$ is the number of grid points in each direction. The grid indices $i$ and $j$ range from $0$ to $N-1$. The potential at a grid point $(x_i, y_j)$ is denoted by $\\phi_{i,j}$.\n\nThe second-order partial derivatives are approximated using second-order central difference formulas:\n$$\n\\frac{\\partial^2 \\phi}{\\partial x^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 \\phi}{\\partial y^2}\\bigg|_{(x_i,y_j)} \\approx \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2}\n$$\nSubstituting these approximations into the Laplace equation for each interior grid point, where $i, j \\in \\{1, 2, \\dots, N-2\\}$, yields:\n$$\n\\frac{\\phi_{i+1,j} - 2\\phi_{i,j} + \\phi_{i-1,j}}{h^2} + \\frac{\\phi_{i,j+1} - 2\\phi_{i,j} + \\phi_{i,j-1}}{h^2} = 0\n$$\nMultiplying by $h^2$ and rearranging terms gives the five-point stencil equation, which states that the potential at an interior point is the average of the potentials at its four nearest neighbors:\n$$\n4\\phi_{i,j} - \\phi_{i+1,j} - \\phi_{i-1,j} - \\phi_{i,j+1} - \\phi_{i,j-1} = 0\n$$\nThis equation must hold for all $M = (N-2)^2$ interior points. This set of equations forms a system of linear equations of the form $A\\vec{\\Phi} = \\vec{b}$, where $\\vec{\\Phi}$ is a vector containing the unknown potentials $\\phi_{i,j}$ for the interior points.\n\nTo construct the system, we must flatten the two-dimensional grid of unknowns into a one-dimensional vector $\\vec{\\Phi}$. A consistent mapping is required. We use a column-major ordering where the index $k$ for the unknown $\\phi_{i,j}$ (where $i, j \\in \\{1, \\dots, N-2\\}$) is given by $k = (i-1)(N-2) + (j-1)$.\n\nThe matrix $A$ is an $M \\times M$ matrix representing the coefficients of the unknown potentials. The vector $\\vec{b}$ of size $M$ contains terms resulting from the known boundary values. When a neighboring point $(i', j')$ lies on a boundary, its potential $\\phi_{i',j'}$ is known. This term is moved to the right-hand side of the equation.\n- For points adjacent to the left wall ($i=1$), the term $\\phi_{0,j}=0$ is known.\n- For points adjacent to the bottom wall ($j=1$), the term $\\phi_{i,0}=0$ is known.\n- For points adjacent to the top wall ($j=N-2$), the term $\\phi_{i,N-1}=0$ is known.\nThese zero-potential boundaries contribute nothing to the right-hand side vector $\\vec{b}$.\n- For points adjacent to the right wall ($i=N-2$), the term $\\phi_{N-1,j}=V_0$ is known. The equation for such a point becomes $4\\phi_{N-2,j} - \\phi_{N-3,j} - \\phi_{N-2,j-1} - \\phi_{N-2,j+1} = V_0$.\n\nThus, the components of the vector $\\vec{b}$ are zero for all points except those adjacent to the right wall (where $i = N-2$), for which the value is $V_0$. The matrix $A$ has a sparse, block-tridiagonal structure with $4$ on the main diagonal and $-1$ on certain off-diagonals corresponding to the neighboring points in the grid.\n\nOnce the matrix $A$ and vector $\\vec{b}$ are constructed, the linear system $A\\vec{\\Phi} = \\vec{b}$ is solved for the vector of unknown potentials $\\vec{\\Phi}$.\n\nThe final step is to extract the potential at the geometric center of the square, $(L/2, L/2)$. Since $N$ is specified to be odd, the center coincides with a grid point $(x_{i_c}, y_{j_c})$, where the indices are $i_c = j_c = (N-1)/2$. These indices fall within the range of interior points, $\\{1, \\dots, N-2\\}$, for $N \\ge 3$. The potential at this point is one of the elements of the solution vector $\\vec{\\Phi}$, which can be located using the same index mapping.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_laplace(L, N, V0):\n    \"\"\"\n    Solves the 2D Laplace equation on a square grid using the Finite Difference Method.\n\n    Args:\n        L (float): Side length of the square domain in meters.\n        N (int): Number of grid points in each direction.\n        V0 (float): Potential on the right wall in volts.\n\n    Returns:\n        float: The potential at the geometric center of the grid.\n    \"\"\"\n    # Number of interior grid points in one dimension.\n    N_int = N - 2\n\n    # If N <= 2, there are no interior points to solve for.\n    if N_int <= 0:\n        # A grid with N=1 or N=2 has no interior. The problem statement implies N>=3.\n        # For N=3, the center is the only interior point. Its value can be calculated\n        # as V0/4. A general solution is implemented anyway.\n        if N == 1: # A single point can't have these conflicting BCs.\n           return 0.0\n        return 0.0\n\n    # Total number of unknown interior potentials.\n    M = N_int * N_int\n\n    # Initialize the matrix A and vector b for the linear system A*phi = b.\n    A = np.zeros((M, M))\n    b = np.zeros(M)\n\n    # Function to map 2D interior grid indices (ii, jj) to a 1D vector index k.\n    # We use 0-indexed interior indices: ii, jj in [0, N_int-1].\n    # These correspond to original grid indices i=ii+1, j=jj+1.\n    # The mapping is column-major for consistency with (x,y) -> (i,j).\n    map_k = lambda ii, jj: ii * N_int + jj\n\n    for ii in range(N_int):  # Corresponds to x-direction grid index i = ii + 1\n        for jj in range(N_int):  # Corresponds to y-direction grid index j = jj + 1\n            k = map_k(ii, jj)\n\n            # The discrete Laplace equation is:\n            # 4*phi_i,j - phi_i-1,j - phi_i+1,j - phi_i,j-1 - phi_i,j+1 = 0\n            # We move known boundary values to the right-hand side (vector b).\n\n            # Main diagonal from the term 4*phi_i,j\n            A[k, k] = 4\n\n            # Neighbor in negative x-direction (i-1, j)\n            if ii > 0:  # Neighbor is an interior point\n                A[k, map_k(ii - 1, jj)] = -1\n            else:  # Neighbor is on the boundary x=0 (i=0), where phi=0\n                b[k] += 0.0\n\n            # Neighbor in positive x-direction (i+1, j)\n            if ii < N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii + 1, jj)] = -1\n            else:  # Neighbor is on the boundary x=L (i=N-1), where phi=V0\n                b[k] += V0\n\n            # Neighbor in negative y-direction (i, j-1)\n            if jj > 0:  # Neighbor is an interior point\n                A[k, map_k(ii, jj - 1)] = -1\n            else:  # Neighbor is on the boundary y=0 (j=0), where phi=0\n                b[k] += 0.0\n\n            # Neighbor in positive y-direction (i, j+1)\n            if jj < N_int - 1:  # Neighbor is an interior point\n                A[k, map_k(ii, jj + 1)] = -1\n            else:  # Neighbor is on the boundary y=L (j=N-1), where phi=0\n                b[k] += 0.0\n    \n    # Solve the linear system for the unknown interior potentials.\n    phi_sol = np.linalg.solve(A, b)\n\n    # Find the potential at the geometric center.\n    # Since N is odd, the center (L/2, L/2) is a grid point.\n    center_grid_idx = (N - 1) // 2\n    \n    # Convert grid index to 0-indexed interior index.\n    ii_center = center_grid_idx - 1\n    jj_center = center_grid_idx - 1\n    \n    # Get the 1D vector index for the center point.\n    k_center = map_k(ii_center, jj_center)\n\n    return phi_sol[k_center]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 3, 1.0),\n        (1.0, 5, 1.0),\n        (1.0, 21, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, V0 = case\n        center_potential = solve_laplace(L, N, V0)\n        # Round the result to six decimal places as required.\n        results.append(f\"{center_potential:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2392730"}, {"introduction": "Numerical solutions are approximations, and a key skill is not just generating them but also improving their quality. This practice introduces Richardson extrapolation, a powerful technique to enhance the accuracy of a numerical method by cleverly combining results from different grid spacings to cancel the leading-order error term. This exercise will demonstrate how to achieve a higher order of accuracy, for instance from $O(h^2)$ to $O(h^4)$, without fundamentally changing the underlying discretization scheme ([@problem_id:2392773]).", "problem": "Consider the two-point boundary value problem on the unit interval: find a function $u(x)$ such that\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\nwhere $\\sin(\\cdot)$ uses angles in radians. Let $n$ denote the number of interior grid points on a uniform mesh of $[0,1]$ with grid spacing $h = \\frac{1}{n+1}$ and nodes $x_i = i h$ for $i=0,1,\\ldots,n+1$. Approximate $u''(x)$ by the standard second-order centered finite difference on this mesh, enforce the Dirichlet boundary conditions $u(0)=0$ and $u(1)=0$ exactly, and solve the resulting linear system for the interior unknowns.\n\nNext, refine the mesh by halving the grid spacing (i.e., use a mesh with $m = 2n+1$ interior points so that the refined spacing is $h/2$ and refined interior nodes coincide with the coarse ones). Solve the same discrete problem on the refined mesh. Use Richardson extrapolation, assuming a leading truncation error proportional to $h^2$, to combine the two numerical solutions and obtain a higher-accuracy approximation on the coarse mesh interior nodes.\n\nUse the exact analytical solution $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$ to quantify accuracy. For each test case specified below, compute the maximum absolute error of the Richardson-extrapolated solution evaluated at the coarse mesh interior nodes, i.e.,\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|.\n$$\n\nTest suite:\n- Case $1$: $n=1$.\n- Case $2$: $n=4$.\n- Case $3$: $n=10$.\n\nFinal output format:\nYour program should produce a single line of output containing the three results $E_\\infty$ for the cases listed above, in order, as a comma-separated list enclosed in square brackets (for example, $[e_1,e_2,e_3]$). Each $e_k$ must be a real number (a floating-point value). No additional text should be printed.", "solution": "The problem presented is a well-posed, two-point boundary value problem (BVP) from the field of differential equations. It is scientifically grounded and contains all necessary information for obtaining a unique numerical solution. The proposed method, employing finite differences and Richardson extrapolation, is a standard and valid technique in computational physics. Therefore, the problem is valid, and a solution will be presented.\n\nThe problem is to find a function $u(x)$ satisfying the following second-order ordinary differential equation and boundary conditions:\n$$\nu''(x) = -\\sin(\\pi x), \\quad x \\in (0,1)\n$$\n$$\nu(0)=0, \\quad u(1)=0\n$$\nThe analytical solution is given as $u_{\\text{exact}}(x) = \\dfrac{\\sin(\\pi x)}{\\pi^2}$, which can be verified by direct differentiation and substitution.\n\nThe first step is to discretize the domain $[0,1]$ using a uniform mesh. For a given integer $n$, we define $n$ interior grid points. The grid spacing is $h = \\frac{1}{n+1}$, and the grid nodes are $x_i = ih$ for $i=0, 1, \\ldots, n+1$. The values of the solution at these nodes are denoted by $u_i = u(x_i)$. The boundary conditions dictate that $u_0 = 0$ and $u_{n+1} = 0$. We seek to find the unknown values $u_i$ for $i=1, 2, \\ldots, n$.\n\nThe second derivative $u''(x)$ at an interior node $x_i$ is approximated using a second-order accurate centered finite difference formula:\n$$\nu''(x_i) \\approx \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} = \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\nSubstituting this approximation into the original differential equation yields a system of algebraic equations for the unknowns $u_i$:\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = -\\sin(\\pi x_i), \\quad \\text{for } i = 1, 2, \\ldots, n\n$$\nRearranging this equation, we obtain:\n$$\nu_{i-1} - 2u_i + u_{i+1} = -h^2 \\sin(\\pi x_i)\n$$\nIncorporating the boundary conditions ($u_0=0$ and $u_{n+1}=0$), we can write out the equations for the first and last interior nodes:\nFor $i=1$: $u_0 - 2u_1 + u_2 = -h^2 \\sin(\\pi x_1) \\implies -2u_1 + u_2 = -h^2 \\sin(\\pi x_1)$.\nFor $i=n$: $u_{n-1} - 2u_n + u_{n+1} = -h^2 \\sin(\\pi x_n) \\implies u_{n-1} - 2u_n = -h^2 \\sin(\\pi x_n)$.\n\nThese $n$ equations form a system of linear equations of the form $A \\mathbf{u} = \\mathbf{b}$, where $\\mathbf{u} = [u_1, u_2, \\ldots, u_n]^T$ is the vector of unknown solution values at the interior nodes. The matrix $A$ is an $n \\times n$ symmetric, tridiagonal matrix, and the vector $\\mathbf{b}$ is the right-hand side.\n$$\nA = \\begin{pmatrix}\n-2 & 1 & 0 & \\cdots & 0 \\\\\n1 & -2 & 1 & \\cdots & 0 \\\\\n0 & 1 & -2 & \\ddots & \\vdots \\\\\n\\vdots & \\vdots & \\ddots & -2 & 1 \\\\\n0 & 0 & \\cdots & 1 & -2\n\\end{pmatrix}, \\quad \\mathbf{b} = -h^2 \\begin{pmatrix}\n\\sin(\\pi x_1) \\\\\n\\sin(\\pi x_2) \\\\\n\\vdots \\\\\n\\sin(\\pi x_n)\n\\end{pmatrix}\n$$\nThis linear system is diagonally dominant and therefore has a unique solution which can be found using standard numerical linear algebra methods.\n\nThe problem requires using Richardson extrapolation to improve the accuracy of the solution. The centered difference scheme has a global error that has an asymptotic expansion in even powers of $h$:\n$$\nu_h(x) = u_{\\text{exact}}(x) + C_1(x)h^2 + C_2(x)h^4 + \\dots\n$$\nwhere $u_h(x)$ is the numerical solution at point $x$ computed with grid spacing $h$.\n\nWe compute two numerical solutions:\n1. A coarse solution, $\\mathbf{u}_h$, on a grid with $n$ interior points and spacing $h = \\frac{1}{n+1}$.\n2. A fine solution, $\\mathbf{u}_{h/2}$, on a grid with $m = 2n+1$ interior points and spacing $h/2 = \\frac{1}{m+1}$.\n\nAt a coarse grid node $x_i$, we have the following approximations for the exact solution $u_{\\text{exact}}(x_i)$:\n$$\nu_h(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)h^2\n$$\n$$\nu_{h/2}(x_i) \\approx u_{\\text{exact}}(x_i) + C_1(x_i)(h/2)^2 = u_{\\text{exact}}(x_i) + \\frac{1}{4}C_1(x_i)h^2\n$$\nWe can eliminate the leading error term $C_1(x_i)h^2$ by algebraically combining these two expressions. Multiplying the second equation by $4$ and subtracting the first gives:\n$$\n4u_{h/2}(x_i) - u_h(x_i) \\approx 3u_{\\text{exact}}(x_i)\n$$\nThis leads to the Richardson-extrapolated solution $u_{\\text{RE}}(x_i)$, which has an error of order $O(h^4)$:\n$$\nu_{\\text{RE}}(x_i) = \\frac{4u_{h/2}(x_i) - u_h(x_i)}{3}\n$$\nThis extrapolation is performed for each node $x_i$ on the coarse grid, $i = 1, \\ldots, n$. Note that the coarse grid nodes $\\{x_i\\}$ are a subset of the fine grid nodes. Specifically, the coarse node $x_i = i h$ corresponds to the fine grid node at the same position, which is the $(2i)$-th interior node on the fine mesh.\n\nThe final step is to quantify the accuracy of the extrapolated solution. For each test case, we compute the maximum absolute error $E_\\infty$ over the coarse interior grid points:\n$$\nE_\\infty = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - u_{\\text{exact}}(x_i) \\right| = \\max_{1 \\le i \\le n} \\left| u_{\\text{RE}}(x_i) - \\frac{\\sin(\\pi x_i)}{\\pi^2} \\right|\n$$\nThe computational procedure for each test value of $n$ is as follows:\n1.  Solve the BVP for the coarse grid with $n$ interior points to get $\\mathbf{u}_h$.\n2.  Solve the BVP for the fine grid with $m=2n+1$ interior points to get $\\mathbf{u}_{h/2}$.\n3.  Extract the values from $\\mathbf{u}_{h/2}$ that correspond to the coarse grid locations.\n4.  Compute the Richardson-extrapolated solution vector $\\mathbf{u}_{\\text{RE}}$.\n5.  Compute the exact solution at the coarse grid points.\n6.  Calculate the maximum absolute error $E_\\infty$.\n\nThis procedure will be implemented for the specified test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_bvp(n):\n    \"\"\"\n    Solves the BVP u''(x) = -sin(pi*x) on [0,1] with u(0)=u(1)=0\n    using a centered finite difference scheme with n interior points.\n\n    Args:\n        n (int): The number of interior grid points.\n\n    Returns:\n        tuple: A tuple containing:\n            - np.ndarray: The solution vector u at the interior points.\n            - np.ndarray: The x-coordinates of the interior points.\n    \"\"\"\n    if n == 0:\n        return np.array([]), np.array([])\n    \n    # Grid spacing\n    h = 1.0 / (n + 1)\n    \n    # Interior grid points\n    x_interior = np.linspace(h, 1.0 - h, n)\n    \n    # Construct the right-hand side vector b\n    b = -h**2 * np.sin(np.pi * x_interior)\n    \n    # Construct the tridiagonal matrix A\n    A = np.diag(-2 * np.ones(n)) + np.diag(np.ones(n - 1), k=1) + np.diag(np.ones(n - 1), k=-1)\n    \n    # Solve the linear system Au = b\n    u = np.linalg.solve(A, b)\n    \n    return u, x_interior\n\ndef solve():\n    \"\"\"\n    Main driver function to solve the problem for all test cases and print the result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 4, 10]\n\n    results = []\n    for n in test_cases:\n        # 1. Solve on coarse mesh\n        u_coarse, x_coarse = solve_bvp(n)\n        \n        # 2. Solve on fine mesh\n        m = 2 * n + 1\n        u_fine, _ = solve_bvp(m)\n        \n        # 3. Extract fine solution at coarse grid points\n        # The coarse grid points correspond to every second point of the fine grid's interior.\n        # Python indices are 0-based. The i-th coarse point (i=0 to n-1) is at the same\n        # spatial location as the (2i+1)-th fine point (index 2i+1).\n        # This corresponds to slicing u_fine with [1::2].\n        u_fine_at_coarse_points = u_fine[1::2]\n\n        # 4. Apply Richardson extrapolation\n        # u_RE = (4 * u_h/2 - u_h) / 3\n        u_re = (4.0 * u_fine_at_coarse_points - u_coarse) / 3.0\n        \n        # 5. Compute exact solution at coarse grid points\n        u_exact = np.sin(np.pi * x_coarse) / (np.pi**2)\n        \n        # 6. Calculate the maximum absolute error\n        max_error = np.max(np.abs(u_re - u_exact))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2392773"}]}