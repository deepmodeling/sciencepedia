{"hands_on_practices": [{"introduction": "While linear oscillators are foundational, most real-world systems exhibit nonlinearity, with the Duffing oscillator being a canonical example. In such systems, response characteristics like the phase lag $\\delta$ relative to the driving force become dependent on the amplitude of the motion, unlike in linear systems [@problem_id:2419785]. This exercise provides direct practice in numerically solving a nonlinear ordinary differential equation (ODE) and analyzing its steady-state response, building a crucial bridge from textbook linear models to the behavior of more realistic physical systems.", "problem": "Consider the forced, damped, nonlinear oscillator governed by the ordinary differential equation (ODE)\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t),\n$$\nwith mass $m$, damping coefficient $c$, linear stiffness $k$, cubic stiffness $\\alpha$, forcing amplitude $F_{0}$, and driving angular frequency $\\omega$. Take the following fixed parameter values in International System of Units (SI) units: $m = 1.0\\,\\mathrm{kg}$, $c = 0.3\\,\\mathrm{kg/s}$, $k = 1.0\\,\\mathrm{N/m}$, $\\alpha = 1.0\\,\\mathrm{N/m^{3}}$, and $\\omega = 1.2\\,\\mathrm{rad/s}$. The initial conditions are $x(0) = 0.0\\,\\mathrm{m}$ and $\\dot{x}(0) = 0.0\\,\\mathrm{m/s}$, and time $t$ is in $\\mathrm{s}$. Define the phase lag $\\delta$ between the driver and the oscillator as follows. In the steady-state, define the fundamental (at angular frequency $\\omega$) in-phase and quadrature projections of the displacement $x(t)$ over a finite averaging window of length $T_{\\mathrm{w}}$ by\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt, \\qquad\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt,\n$$\nand set\n$$\n\\delta = \\operatorname{atan2}(B, A),\n$$\nmapped into the interval $[0, 2\\pi)$ by adding $2\\pi$ if the computed value is negative. The averaging must be performed after transients have decayed, using $t_{0} = 200.0\\,\\mathrm{s}$ and a window $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\,\\frac{2\\pi}{\\omega}$ with $N_{\\mathrm{avg}} = 20$. Angles must be expressed in radians. Your task is to compute the phase lag $\\delta$ for each of the following forcing amplitudes $F_{0}$ (expressed in $\\mathrm{N}$): $F_{0} \\in \\{\\,0.05,\\,0.20,\\,0.50,\\,0.80\\,\\}$. Use the fixed values of $(m,c,k,\\alpha,\\omega)$ and the initial conditions given above, and evaluate the integrals defining $A$ and $B$ over the specified averaging window starting at $t_{0}$.\n\nTest Suite and Answer Specification:\n- Use the four forcing amplitudes $F_{0}$ given above as the test suite.\n- For each case, produce a single real number corresponding to the phase lag $\\delta$ in radians, mapped to $[0, 2\\pi)$ as prescribed.\n- The final program output must be one line containing the four values of $\\delta$ corresponding to the test cases, in the same order as listed, rounded to exactly $6$ decimal places.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example $[0.123456,1.234567,2.345678,3.456789]$.", "solution": "The problem statement is subjected to validation and is found to be valid. It describes a well-posed initial value problem for the forced, damped Duffing oscillator, a canonical system in the study of nonlinear dynamics. All parameters, initial conditions, and procedures for analysis are defined with scientific and mathematical rigor. There are no contradictions, ambiguities, or factual inaccuracies.\n\nThe task is to compute the steady-state phase lag $\\delta$ between the response $x(t)$ and the driving force for a nonlinear oscillator. The governing equation is the second-order ordinary differential equation (ODE):\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t)\n$$\nThe solution requires a numerical approach, which proceeds as follows.\n\nFirst, we convert the second-order ODE into a system of two first-order ODEs. Let us define a state vector $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$, where $y_1(t) = x(t)$ represents the position and $y_2(t) = \\dot{x}(t)$ represents the velocity. The time evolution of this state vector is given by the system:\n$$\n\\dot{\\mathbf{y}}(t) = \n\\begin{pmatrix} \\dot{y}_1(t) \\\\ \\dot{y}_2(t) \\end{pmatrix} =\n\\begin{pmatrix} y_2(t) \\\\ \\frac{1}{m} \\left( F_{0}\\cos(\\omega t) - c\\,y_2(t) - k\\,y_1(t) - \\alpha\\,y_1^3(t) \\right) \\end{pmatrix}\n$$\nThis system is to be solved with the initial conditions $x(0) = y_1(0) = 0.0\\,\\mathrm{m}$ and $\\dot{x}(0) = y_2(0) = 0.0\\,\\mathrm{m/s}$. The given parameters are $m = 1.0\\,\\mathrm{kg}$, $c = 0.3\\,\\mathrm{kg/s}$, $k = 1.0\\,\\mathrm{N/m}$, $\\alpha = 1.0\\,\\mathrm{N/m^{3}}$, and $\\omega = 1.2\\,\\mathrm{rad/s}$. The problem is to be solved for four different values of the forcing amplitude $F_{0} \\in \\{0.05, 0.20, 0.50, 0.80\\}\\,\\mathrm{N}$.\n\nThis initial value problem (IVP) is solved numerically using an appropriate algorithm. The `scipy.integrate.solve_ivp` function, which implements a high-order adaptive step-size Runge-Kutta method (e.g., `RK45`), is a suitable choice for this task. The integration must be performed over a time interval sufficient to allow transients to decay and to cover the specified averaging window. The integration interval is from $t=0$ to $t_{f} = t_{0} + T_{w}$. The start time for averaging is $t_{0} = 200.0\\,\\mathrm{s}$, and the window duration is $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\frac{2\\pi}{\\omega}$, with $N_{\\mathrm{avg}} = 20$. This gives $t_{f} = 200.0 + 20 \\frac{2\\pi}{1.2} \\approx 304.7198\\,\\mathrm{s}$. To facilitate the subsequent integral calculations, the ODE solver is configured to produce a dense output, which provides a continuous interpolating function for the solution $x(t)$.\n\nOnce the numerical solution for $x(t)$ is obtained, the in-phase and quadrature projections, $A$ and $B$, are computed. These are defined as the fundamental Fourier coefficients of the steady-state response:\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt\n$$\n$$\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt\n$$\nThese definite integrals are computed numerically using a robust quadrature method. The `scipy.integrate.quad` function, which employs an adaptive quadrature scheme, is an excellent choice. It operates on the integrand functions, where $x(t)$ is provided by the interpolant from the `solve_ivp` output.\n\nFinally, the phase lag $\\delta$ is determined from the coefficients $A$ and $B$ using the two-argument arctangent function:\n$$\n\\delta = \\operatorname{atan2}(B, A)\n$$\nThe use of `atan2` correctly places the angle in the proper quadrant, yielding a result in the range $(-\\pi, \\pi]$. As per the problem specification, this value is then mapped into the interval $[0, 2\\pi)$ by adding $2\\pi$ to any negative result.\n\nThis entire procedure—numerical solution of the ODE, numerical evaluation of the integrals for $A$ and $B$, and calculation of $\\delta$—is repeated for each specified value of $F_{0}$. The final numerical results are rounded to six decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\n\ndef solve():\n    \"\"\"\n    Solves the damped, driven Duffing oscillator equation for several forcing\n    amplitudes and computes the steady-state phase lag for each case.\n    \"\"\"\n\n    # --- Define problem parameters in SI units ---\n    m = 1.0        # mass (kg)\n    c = 0.3        # damping coefficient (kg/s)\n    k = 1.0        # linear stiffness (N/m)\n    alpha = 1.0    # cubic stiffness (N/m^3)\n    omega = 1.2    # driving angular frequency (rad/s)\n\n    # --- Define simulation and analysis parameters ---\n    x0 = 0.0       # initial position (m)\n    v0 = 0.0       # initial velocity (m/s)\n    y0 = [x0, v0]  # initial state vector [x, v]\n\n    t0 = 200.0     # start time for averaging (s)\n    N_avg = 20     # number of cycles for averaging\n    T_w = N_avg * (2 * np.pi / omega)  # averaging window duration (s)\n    t_final = t0 + T_w               # end time for simulation\n\n    # --- Test cases for forcing amplitude ---\n    test_cases_F0 = [0.05, 0.20, 0.50, 0.80]  # (N)\n\n    results = []\n\n    def duffing_ode_system(t, y, F0):\n        \"\"\"\n        Defines the system of first-order ODEs for the Duffing oscillator.\n        y[0] = x (position), y[1] = v (velocity).\n        \"\"\"\n        x, v = y\n        # Equation: m*x_ddot + c*v + k*x + alpha*x^3 = F0*cos(omega*t)\n        # Transformed to: x_ddot = (F0*cos(omega*t) - c*v - k*x - alpha*x^3) / m\n        dv_dt = (F0 * np.cos(omega * t) - c * v - k * x - alpha * x**3) / m\n        return [v, dv_dt]\n\n    for F0 in test_cases_F0:\n        # Numerically solve the ODE system.\n        # dense_output=True creates an interpolant for the solution,\n        # which is needed for accurate quadrature.\n        # Stricter tolerances are used for higher accuracy of the final result.\n        solution = solve_ivp(\n            fun=lambda t, y: duffing_ode_system(t, y, F0),\n            t_span=(0, t_final),\n            y0=y0,\n            dense_output=True,\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # The solution object `sol.sol` is a callable interpolating function.\n        x_t = lambda t: solution.sol(t)[0]\n\n        # Define the integrands for the Fourier projections A and B.\n        integrand_A = lambda t: x_t(t) * np.cos(omega * t)\n        integrand_B = lambda t: x_t(t) * np.sin(omega * t)\n\n        # Compute the integrals using `scipy.integrate.quad`.\n        # `quad` returns (integral_value, error_estimate), we only need the value.\n        A_integral, _ = quad(integrand_A, t0, t_final)\n        B_integral, _ = quad(integrand_B, t0, t_final)\n\n        # Calculate the A and B coefficients based on their definition.\n        A = (2 / T_w) * A_integral\n        B = (2 / T_w) * B_integral\n\n        # Calculate the phase lag delta using atan2(B, A).\n        delta = np.arctan2(B, A)\n\n        # Map delta from (-pi, pi] to the required interval [0, 2pi).\n        if delta < 0:\n            delta += 2 * np.pi\n\n        results.append(delta)\n\n    # Format the final output string to exactly 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2419785"}, {"introduction": "The principles of oscillation can be adapted to model surprisingly complex phenomena, such as the intricate, chaotic behavior of a dripping faucet. This model [@problem_id:2419756] treats the drop as a variable-mass oscillator with a state-reset mechanism upon detachment, creating a \"memory\" between successive drips that drives the system through a period-doubling cascade—a famous route to chaos. This practice develops skills in advanced numerical methods, including event detection and state-reset handling, and offers a tangible look at the emergence of complex dynamics from a seemingly simple physical model.", "problem": "You are asked to build a complete, runnable program that numerically models a dripping faucet through the lens of a damped driven oscillator. The model is constructed from Newton’s second law, under the following simplifying and widely used assumptions: while a drop remains attached to the faucet, it behaves as a point mass connected to a linear spring and damper, subject to a constant gravitational force. The faucet adds mass at a constant flow rate, and the drop detaches when the elongation exceeds a mass-dependent rupture threshold. After detachment, a small residue remains as the seed of the next drop. This setting is a standard computational physics exercise and leads to a nonautonomous ordinary differential equation (ODE) with state resets. The goal is to simulate the dynamics as the flow rate changes and to extract the number of distinct inter-drip times after transients, thereby revealing a period-doubling sequence.\n\nStart from Newton’s second law and the definitions of linear damping and linear elasticity. While the drop is attached, assume the following:\n- The position of the drop relative to the faucet is a scalar displacement $x(t)$ measured downward, with velocity $v(t) = \\frac{dx}{dt}$.\n- The instantaneous mass $m(t)$ increases at a constant inflow rate $q$, i.e., $\\frac{dm}{dt} = q$.\n- The forces on the drop are due to gravity, a linear spring, and a linear damper, with coefficients $g$, $\\kappa$, and $\\gamma$, respectively.\n- The newly added mass is assumed to attach with negligible relative momentum effect, giving a commonly used approximation where the left-hand side uses $m(t)\\,x''(t)$ without an additional jet-momentum term.\n\nUnder these assumptions, the governing equations while attached are\n$$\n\\frac{dx}{dt} = v, \\quad \n\\frac{dv}{dt} = \\frac{m(t)\\,g - \\gamma\\,v - \\kappa\\,x}{m(t)}, \\quad\n\\frac{dm}{dt} = q.\n$$\nA rupture (detachment) occurs when the elongation $x(t)$ reaches a threshold $x_{\\mathrm{break}}(m)$ from below, with\n$$\nx_{\\mathrm{break}}(m) = x_0 - \\beta\\,m,\n$$\nwhere $x_0$ and $\\beta$ are positive constants. At detachment time $t_d$, the state is reset to model a remnant (residual) mass sticking to the faucet neck and a relaxed, motionless initial condition for the next drop:\n$$\nx(t_d^+) = 0, \\quad v(t_d^+) = 0, \\quad m(t_d^+) = \\alpha\\,m(t_d^-),\n$$\nwhere $0 < \\alpha < 1$ is the residual-mass fraction and the superscripts $^-$ and $^+$ denote limits from before and after the event, respectively.\n\nYour tasks are:\n1) From Newton’s second law, justify the above ODE system and reset rule under the stated assumptions. Clarify how the variable mass enters the acceleration equation and why the chosen simplification is appropriate in this context.\n2) Design and implement a robust event-driven numerical integrator to:\n   - Integrate the ODE until the rupture event $x(t) - x_{\\mathrm{break}}(m(t)) = 0$ is detected with increasing $x$.\n   - Apply the reset rule and continue simulating to generate a long sequence of drip times.\n3) For each specified flow rate $q$, compute the inter-drip times $\\Delta t_n = t_{n} - t_{n-1}$. Discard an initial transient and then determine the number of distinct inter-drip times present within a tolerance, which is an integer diagnostic of the period-$k$ behavior (e.g., $k=1$ for period-1, $k=2$ for period-2 after a period-doubling, etc.). Use a tolerance that combines absolute and relative components to avoid false distinctions due to numerical noise.\n4) Use the following dimensionless parameters for the oscillator and rupture model, and specify the test suite of flow rates:\n   - Oscillator parameters: $\\kappa = 1.0$, $\\gamma = 0.05$, $g = 0.34$.\n   - Rupture parameters: $x_0 = 0.50$, $\\beta = 0.10$, $\\alpha = 0.30$.\n   - Initial conditions at the very start: $x(0) = 0$, $v(0) = 0$, $m(0) = 0.40$.\n   - Flow-rate test suite (four cases): $q \\in \\{\\,0.010,\\,0.025,\\,0.050,\\,0.080\\,\\}$.\n   - Integrate long enough to observe at least $N_{\\mathrm{total}} = 60$ drips per case, discarding the first $N_{\\mathrm{trans}} = 30$ as transient, and analyzing the next $N_{\\mathrm{keep}} = 30$ drips.\n   - Use a detection tolerance that clusters inter-drip times $\\Delta t$ into distinct groups using the rule “same group if $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$” with $\\varepsilon_{\\mathrm{abs}}=10^{-3}$ and $\\varepsilon_{\\mathrm{rel}}=10^{-3}$.\n5) Your program must produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets (e.g., “[1,2,4,1]”), where each integer is the counted number of distinct inter-drip times for the corresponding flow rate in the order given above.\n\nThe problem must be solved in purely mathematical and algorithmic terms so that it is implementable in any programming language. All quantities above are dimensionless, so no physical unit conversion is required. Ensure scientific realism in parameters and discuss in your solution why the approach captures the period-doubling sequence. The final answers for each test case are integers that quantify the distinct inter-drip times found after transients.", "solution": "The problem presented is a valid exercise in computational physics. It is scientifically sound, well-posed, and all necessary parameters and conditions are specified. It represents a standard simplification of a complex physical phenomenon—the dripping faucet—into a non-autonomous system of ordinary differential equations with state resets, a model known to exhibit period-doubling bifurcations and chaos. We shall proceed with a rigorous derivation and algorithmic design.\n\nFirst, we must justify the governing equations from fundamental principles. The system described is a point mass whose mass $m(t)$ changes with time. Newton's second law for a body of variable mass is most generally stated as the rate of change of momentum $\\vec{p}$ being equal to the net external force $\\vec{F}_{\\mathrm{ext}}$, i.e., $\\vec{F}_{\\mathrm{ext}} = \\frac{d\\vec{p}}{dt}$. In our one-dimensional system, the momentum is $p(t) = m(t)v(t)$, where $v(t) = \\frac{dx}{dt}$ is the velocity. Applying the product rule for differentiation, we get:\n$$\n\\frac{dp}{dt} = \\frac{d(mv)}{dt} = m(t)\\frac{dv}{dt} + v(t)\\frac{dm}{dt} = m(t)a(t) + v(t)q\n$$\nwhere $a(t) = \\frac{dv}{dt}$ is the acceleration and $\\frac{dm}{dt} = q$ is the constant mass inflow rate. The term $v(t)q$ represents the force required to accelerate the incoming fluid (which is assumed to have zero initial vertical velocity) to the current velocity $v(t)$ of the drop. The problem statement directs us to use a common simplification where this \"jet-momentum\" term is neglected. This is a reasonable approximation if the velocity $v(t)$ is small or if the primary dynamics are dominated by other forces, which is often the case. Under this simplification, Newton's second law reduces to:\n$$\nm(t)a(t) \\approx F_{\\mathrm{ext}}\n$$\nThe external forces acting on the mass are gravity ($F_g = m(t)g$), the restoring force of a linear spring ($F_s = -\\kappa x$), and a linear viscous damping force ($F_d = -\\gamma v$). The spring constant is $\\kappa$, the damping coefficient is $\\gamma$, and $g$ is the acceleration due to gravity. The displacement $x$ is measured downwards from the faucet, so the gravitational force is positive. The sum of these forces is:\n$$\nF_{\\mathrm{ext}} = m(t)g - \\kappa x - \\gamma v\n$$\nEquating this with the simplified expression for the rate of change of momentum gives the equation of motion for the drop:\n$$\nm(t)\\frac{dv}{dt} = m(t)g - \\kappa x - \\gamma v\n$$\nDividing by the instantaneous mass $m(t)$ yields the acceleration:\n$$\n\\frac{dv}{dt} = g - \\frac{\\gamma}{m(t)}v - \\frac{\\kappa}{m(t)}x\n$$\nThis is precisely the equation provided. This equation, combined with the definitions $\\frac{dx}{dt} = v$ and $\\frac{dm}{dt} = q$, forms a system of three coupled, first-order, non-autonomous ordinary differential equations. The system is non-autonomous because the coefficients of $v$ and $x$ in the acceleration equation depend explicitly on time through the mass $m(t) = m(0) + qt$.\n\nThe simulation proceeds by integrating this system until a rupture event occurs. The condition for rupture is that the elongation $x(t)$ reaches a mass-dependent threshold $x_{\\mathrm{break}}(m) = x_0 - \\beta m$. The physical intuition is that as the drop gets heavier, surface tension is less able to support a large elongation. The event function is therefore $ G(t, x, m) = x(t) - x_{\\mathrm{break}}(m(t)) = 0$. We are interested in the event where $x(t)$ crosses this threshold from below, so we must detect a zero-crossing in the increasing direction.\n\nUpon detachment at a time $t_d$, the system state is reset. The new drop begins with zero displacement and velocity, $x(t_d^+) = 0$ and $v(t_d^+) = 0$. This is a simplification that assumes the remnant fluid settles instantly to a quiescent state. Crucially, not all mass detaches. A fraction $\\alpha$ of the drop's mass at rupture, $m(t_d^-)$, remains attached to the faucet: $m(t_d^+) = \\alpha m(t_d^-)$. This remnant mass $m(t_d^+)$ serves as the initial condition for the next drop and provides a \"memory\" between successive drip events. It is this memory, coupled with the nonlinear nature of the reset mechanism and the driving force of the mass influx, that allows the system to exhibit complex dynamics. The mass of the $n$-th drop at its formation, $m_n(0)$, depends on the mass of the $(n-1)$-th drop at its rupture, $m_{n-1}(t_{\\text{rupture}})$. This creates a mapping from one drip to the next, which for certain parameter regimes, such as the flow rate $q$, undergoes a period-doubling cascade, a hallmark of the route to chaos. For a low flow rate $q$, the system settles into a period-$1$ limit cycle, where each drop is identical and the time between drips is constant. As $q$ is increased, the system may bifurcate to a period-$2$ cycle, where inter-drip times (and drop sizes) alternate between two distinct values. Further increases in $q$ can lead to period-$4$, period-$8$, and eventually chaotic behavior where the inter-drip times appear random. Our task is to count these distinct inter-drip times for given values of $q$.\n\nThe algorithm is as follows:\n1.  Define a function for the system of ODEs: $\\frac{dY}{dt} = F(t, Y)$, where $Y = [x, v, m]^T$.\n2.  Define an event function for the rupture condition $x - (x_0 - \\beta m) = 0$. This function must be terminal and detect crossing from negative to positive values.\n3.  For each flow rate $q$ in the test suite:\n    a. Initialize the state vector $Y_0 = [0, 0, 0.40]^T$, current time $t_{\\mathrm{current}} = 0$, and a list to store drip times, `drip_times`.\n    b. Loop $N_{\\mathrm{total}} = 60$ times to collect data for $60$ drips.\n        i. Use a numerical ODE solver (such as `scipy.integrate.solve_ivp`) to integrate the system from $t_{\\mathrm{current}}$ with the current state, until the rupture event is triggered.\n        ii. Record the event time $t_{\\mathrm{event}}$. Add it to `drip_times`.\n        iii. Update the state vector according to the reset rules: $x_{\\mathrm{new}} = 0$, $v_{\\mathrm{new}} = 0$, $m_{\\mathrm{new}} = \\alpha \\cdot m_{\\mathrm{event}}$, where $m_{\\mathrm{event}}$ is the mass at the time of rupture. The new current time is $t_{\\mathrm{current}} = t_{\\mathrm{event}}$.\n    c. Compute the inter-drip times $\\Delta t_i = \\text{drip\\_times}[i] - \\text{drip\\_times}[i-1]$ for $i=1, \\dots, N_{\\mathrm{total}}-1$. We also need the first interval $\\text{drip\\_times}[0] - 0$. This yields $N_{\\mathrm{total}}$ intervals.\n    d. Discard the first $N_{\\mathrm{trans}} = 30$ intervals as transient dynamics.\n    e. Analyze the subsequent $N_{\\mathrm{keep}} = 30$ intervals. To count the number of distinct values, sort the intervals and iterate through the sorted list, counting groups of values that are close to each other based on the specified tolerance: $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$. A simple way is to count how many times an element is significantly different from the previous one in the sorted list.\n    f. Record this count as the result for the given $q$.\n4.  Format the final list of counts as specified.\nThis robust, event-driven approach correctly models the physics and allows for the accurate determination of the system's periodic behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically models a dripping faucet to observe period-doubling.\n\n    The model treats a growing water drop as a damped, driven harmonic oscillator\n    with variable mass. The system is described by a non-autonomous ODE with\n    state resets upon drop detachment. This function simulates the dynamics for\n    a set of flow rates and determines the periodicity of the drip intervals.\n    \"\"\"\n\n    # Define physical and numerical parameters as per the problem statement.\n    # Oscillator parameters\n    kappa = 1.0  # Spring constant\n    gamma = 0.05 # Damping coefficient\n    g = 0.34     # Gravitational acceleration\n\n    # Rupture and reset parameters\n    x0 = 0.50    # Rupture threshold constant\n    beta = 0.10  # Rupture threshold mass dependency\n    alpha = 0.30 # Residual mass fraction\n\n    # Initial conditions for the very first drop\n    x_init = 0.0\n    v_init = 0.0\n    m_init = 0.40\n\n    # Simulation control\n    N_total = 60  # Total number of drips to simulate per case\n    N_trans = 30  # Number of transient drips to discard\n    \n    # Tolerance for clustering inter-drip times\n    eps_abs = 1e-3\n    eps_rel = 1e-3\n    \n    # Test suite of flow rates\n    test_cases = [0.010, 0.025, 0.050, 0.080]\n\n    results = []\n\n    # ODE system definition: dy/dt = f(t, y)\n    # y = [x, v, m]\n    def ode_system(t, y, q_val):\n        x, v, m = y\n        # Avoid division by zero if mass is ever zero, though m_init > 0.\n        if m <= 0:\n            return [0.0, 0.0, q_val]\n        \n        dxdt = v\n        dvdt = g - (gamma * v / m) - (kappa * x / m)\n        dmdt = q_val\n        return [dxdt, dvdt, dmdt]\n\n    # Event function: fires when x(t) = x_break(m(t))\n    # x_break(m) = x0 - beta * m\n    def rupture_event(t, y, q_val):\n        x, v, m = y\n        return x - (x0 - beta * m)\n    \n    rupture_event.terminal = True  # Stop integration at the event\n    rupture_event.direction = 1    # Event triggers when x is increasing\n\n    # Main loop over each flow rate\n    for q_flow in test_cases:\n        \n        # Initialize state for this test case\n        current_time = 0.0\n        y_current = np.array([x_init, v_init, m_init])\n        \n        drip_times = []\n\n        # Simulate N_total drips\n        for _ in range(N_total):\n            # Define a sufficiently long time span for the next drip\n            t_span = (current_time, current_time + 100.0)\n            \n            # Integrate until the next rupture event\n            sol = solve_ivp(\n                fun=lambda t, y: ode_system(t, y, q_flow),\n                t_span=t_span,\n                y0=y_current,\n                events=lambda t, y: rupture_event(t, y, q_flow),\n                dense_output=True,\n                max_step=0.1\n            )\n            \n            # Check if an event was found\n            if sol.t_events[0].size > 0:\n                event_time = sol.t_events[0][0]\n                drip_times.append(event_time)\n                \n                # State at the moment of rupture\n                y_event = sol.sol(event_time)\n                m_rupture = y_event[2]\n                \n                # Apply reset rules\n                current_time = event_time\n                y_current = np.array([0.0, 0.0, alpha * m_rupture])\n            else:\n                # Should not happen with given parameters and t_span\n                # Break if no drip is found in the time window\n                break\n\n        # Analyze the collected drip times\n        if len(drip_times) < N_total:\n             # If simulation failed, append an error code (e.g., -1)\n             results.append(-1)\n             continue\n        \n        # Calculate inter-drip times\n        all_times = np.insert(np.array(drip_times), 0, 0.0)\n        inter_drip_times = np.diff(all_times)\n\n        # Discard transients and keep the part for analysis\n        analysis_times = inter_drip_times[N_trans:]\n\n        if len(analysis_times) == 0:\n            results.append(0)\n            continue\n        \n        # Cluster the inter-drip times to count distinct values\n        sorted_times = np.sort(analysis_times)\n        \n        num_distinct_times = 1\n        # The first time interval starts the first cluster\n        cluster_representative = sorted_times[0]\n        \n        for i in range(1, len(sorted_times)):\n            dt_current = sorted_times[i]\n            dt_prev = sorted_times[i-1]\n            \n            # Check if current time is \"far\" from previous one using the tolerance rule\n            tolerance = max(eps_abs, eps_rel * max(abs(dt_current), abs(dt_prev)))\n            if abs(dt_current - dt_prev) > tolerance:\n                num_distinct_times += 1\n        \n        results.append(num_distinct_times)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419756"}, {"introduction": "Physical systems are invariably coupled to a noisy environment, which can be modeled by adding a random force to the equation of motion. This problem [@problem_id:2419810] extends the deterministic oscillator by adding a stochastic forcing term, transforming the ordinary differential equation (ODE) into a stochastic differential equation (SDE). This exercise provides essential experience in integrating SDEs using methods like the Euler-Maruyama scheme and applying power spectrum analysis to understand how a system's resonant properties shape its response to both deterministic and random inputs.", "problem": "Consider the classical damped, driven harmonic oscillator subject to an external random force. Start from Newton’s Second Law: the total force equals mass times acceleration. Let the position be $x(t)$, the velocity be $v(t) = dx/dt$, the mass be $m$, the linear viscous damping coefficient be $c$, the spring constant be $k$, and the external drive be $F(t) = F_0 \\cos(\\omega_d t) + \\eta(t)$, where $\\eta(t)$ is a zero-mean Gaussian white noise process with autocorrelation $\\langle \\eta(t)\\eta(t')\\rangle = 2 D \\delta(t-t')$. The equation of motion is\n$$\nm \\frac{d^2 x}{dt^2} + c \\frac{dx}{dt} + k x = F_0 \\cos(\\omega_d t) + \\eta(t).\n$$\nYou must derive a numerical method to simulate the position time series and then analyze its frequency content. Your development must adhere to the following constraints and steps.\n\n1) Derive the first-order stochastic differential equation (SDE) system by introducing $v(t) = dx/dt$ and writing the system for $(x,v)$. Use an additive white noise force $\\eta(t)$ as specified. You must then construct a discrete-time integrator based on first principles, using the Euler–Maruyama scheme for stochastic differential equations, to evolve $(x,v)$ forward in time by a fixed timestep $\\Delta t$. Explicitly use independent, identically distributed standard normal variates to model the Wiener increments, and relate the continuous-time noise intensity $D$ to the discrete-time update.\n\n2) Implement a simulation that, for each parameter set below, integrates from $t=0$ to $t=T$ with fixed step $\\Delta t$, starting from $x(0)=0$ and $v(0)=0$. Use a deterministic seed for the pseudo-random number generator to ensure reproducibility across runs; use seed $12345 + i$ for test case index $i=0,1,2,3$. Discard the initial “transient” segment of duration $T_{\\text{burn}}$ before computing any spectral quantity. All angles and angular frequencies must be in radians, and time in seconds.\n\n3) Compute the one-sided power spectrum of position from the post-transient segment of the simulation as follows:\n- Remove the sample mean from the retained $x(t)$.\n- Apply a Hann window to the retained samples to reduce spectral leakage, where the Hann window $w(n)$ for $n=0,\\dots,N-1$ is $w(n) = \\tfrac{1}{2}\\left(1-\\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$.\n- Compute the discrete Fourier transform using the Fast Fourier Transform (FFT) algorithm to obtain the frequency-domain representation, and form the one-sided power spectrum by taking the squared magnitude at nonnegative frequencies. Let the sampling interval be $\\Delta t$ and the corresponding nonnegative frequency grid be $f_k$, then define the angular frequency grid as $\\omega_k = 2\\pi f_k$, expressed in radians per second.\n- To determine the characteristic frequency of the response, locate the angular frequency $\\omega_{\\text{peak}}$ (in radians per second) at which the one-sided power spectrum of $x(t)$ attains its maximum within the search band $\\omega \\in [\\omega_{\\min}, \\omega_{\\max}]$, where $\\omega_{\\min} = 0.1$ and $\\omega_{\\max} = 4.0$. Exclude the direct current (DC) bin at $\\omega=0$ from consideration.\n\n4) Your program must output, for each test case, the single float $\\omega_{\\text{peak}}$ in radians per second, rounded to three decimal places. Aggregate all four results into a single line as a comma-separated Python-style list, for example, $[1.000,0.950, \\dots]$ with no spaces.\n\nPhysical units:\n- Use the International System of Units: $m$ in kilograms, $c$ in kilograms per second, $k$ in newtons per meter, $F_0$ in newtons, $D$ in newton squared times second, time in seconds, and angular frequencies in radians per second.\n- Report $\\omega_{\\text{peak}}$ in radians per second.\n\nAngle unit: All angles and angular frequencies must be in radians.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, e.g., $[\\omega_{\\text{peak},1},\\omega_{\\text{peak},2},\\omega_{\\text{peak},3},\\omega_{\\text{peak},4}]$.\n\nTest suite and parameter sets:\n- Use total time $T=60$, timestep $\\Delta t = 10^{-3}$, and burn-in duration $T_{\\text{burn}}=10$ for all cases. For all cases, the natural angular frequency is determined by $\\omega_0 = \\sqrt{k/m}$, and the damping ratio by $\\zeta = c/(2\\sqrt{km})$.\n- Case $1$ (typical driven, noisy): $m=1.0$, $c=0.25$, $k=1.0$, $F_0=1.0$, $\\omega_d=0.9$, $D=0.02$.\n- Case $2$ (deterministic drive, no noise): $m=1.0$, $c=0.25$, $k=1.0$, $F_0=1.0$, $\\omega_d=0.8$, $D=0.0$.\n- Case $3$ (strong damping): $m=1.0$, $c=2.0$, $k=1.0$, $F_0=1.0$, $\\omega_d=1.2$, $D=0.03$.\n- Case $4$ (noise-only resonance shaping): $m=1.0$, $c=0.2$, $k=1.0$, $F_0=0.0$, $\\omega_d=1.0$, $D=0.05$.\n\nDesign for coverage:\n- Case $1$ probes a typical underdamped, noisy driven response near resonance.\n- Case $2$ tests the boundary where the stochastic term vanishes, verifying the spectral peak aligns with the deterministic drive.\n- Case $3$ tests a near-critically damped system with broadened response.\n- Case $4$ tests the edge case with no deterministic drive, where the spectrum is shaped solely by the linear response to white acceleration noise.\n\nYour task: Implement the above and output the list $[\\omega_{\\text{peak},1},\\omega_{\\text{peak},2},\\omega_{\\text{peak},3},\\omega_{\\text{peak},4}]$, each entry rounded to three decimal places, in a single line with no additional text.", "solution": "The problem posed is valid, as it is scientifically grounded in the principles of classical mechanics and stochastic processes, is well-posed with a complete set of parameters and conditions, and is expressed in objective, formal language. We proceed with the solution.\n\nThe problem requires the numerical simulation of a damped, driven harmonic oscillator subjected to an additional random force. The analysis proceeds in three stages: first, the reformulation of the governing equation into a system of first-order stochastic differential equations (SDEs); second, the derivation and implementation of a suitable numerical integration scheme; and third, the spectral analysis of the simulated position time series.\n\nThe equation of motion is given as:\n$$\nm \\frac{d^2 x}{dt^2} + c \\frac{dx}{dt} + k x = F_0 \\cos(\\omega_d t) + \\eta(t)\n$$\nwhere $m$ is mass, $c$ is the damping coefficient, $k$ is the spring constant, $F_0$ and $\\omega_d$ are the amplitude and angular frequency of the deterministic drive, and $\\eta(t)$ is a Gaussian white noise process with autocorrelation $\\langle \\eta(t)\\eta(t')\\rangle = 2D\\delta(t-t')$.\n\nFirst, we convert this second-order equation into a system of two first-order SDEs. Let the state variables be position $x_1(t) = x(t)$ and velocity $x_2(t) = v(t) = dx/dt$. The system is:\n$$\n\\frac{dx_1}{dt} = x_2\n$$\n$$\n\\frac{dx_2}{dt} = -\\frac{k}{m} x_1 - \\frac{c}{m} x_2 + \\frac{F_0}{m} \\cos(\\omega_d t) + \\frac{1}{m} \\eta(t)\n$$\nThis system is expressed in the language of SDEs by interpreting the white noise term $\\eta(t) dt$ as the increment of a scaled Wiener process, $dW'_t$. The process $W'(t)$ has a variance that grows linearly with time, such that the variance of an increment $dW'_t$ over an interval $dt$ is $\\langle (dW'_t)^2 \\rangle = 2D dt$. The SDE system is thus:\n$$\ndx_1 = x_2 dt\n$$\n$$\ndx_2 = \\left( -\\frac{k}{m} x_1 - \\frac{c}{m} x_2 + \\frac{F_0}{m} \\cos(\\omega_d t) \\right) dt + \\frac{\\sqrt{2D}}{m} dW_t\n$$\nwhere $dW_t$ is the increment of a standard Wiener process, with $\\langle (dW_t)^2 \\rangle = dt$.\n\nNext, we discretize this SDE system using the Euler-Maruyama scheme with a fixed time step $\\Delta t$. Let the state at time $t_n = n \\Delta t$ be $(x_n, v_n)$. The state at the next time step $t_{n+1} = (n+1) \\Delta t$ is approximated as:\n$$\nx_{n+1} = x_n + v_n \\Delta t\n$$\n$$\nv_{n+1} = v_n + \\left( -\\frac{k}{m} x_n - \\frac{c}{m} v_n + \\frac{F_0}{m} \\cos(\\omega_d t_n) \\right) \\Delta t + \\frac{\\sqrt{2D}}{m} \\Delta W_n\n$$\nThe discrete Wiener increment $\\Delta W_n$ is a random variable drawn from a normal distribution with mean $0$ and variance $\\Delta t$. We can therefore write $\\Delta W_n = \\sqrt{\\Delta t} Z_n$, where $Z_n$ is a random variable drawn from the standard normal distribution $\\mathcal{N}(0, 1)$. The final update rule for the velocity is:\n$$\nv_{n+1} = v_n + \\left( -\\frac{k}{m} x_n - \\frac{c}{m} v_n + \\frac{F_0}{m} \\cos(\\omega_d n \\Delta t) \\right) \\Delta t + \\frac{\\sqrt{2D \\Delta t}}{m} Z_n\n$$\nThese equations are implemented to simulate the time evolution of the system from the initial conditions $x(0)=0$ and $v(0)=0$.\n\nFinally, we perform spectral analysis on the simulated position time series $x(t)$. The initial segment of the simulation, of duration $T_{\\text{burn}}$, is discarded to ensure the system has reached a statistical steady state. For the remaining segment of the signal, of length $N$:\n$1$. The sample mean of the position data is subtracted to remove any DC offset.\n$2$. A Hann window, $w(n) = \\frac{1}{2}(1-\\cos(\\frac{2\\pi n}{N-1}))$ for $n = 0, \\dots, N-1$, is applied to the detrended signal. This tapering reduces spectral leakage caused by the finite duration of the signal.\n$3$. The Fast Fourier Transform (FFT) of the windowed signal is computed. We use the real-valued FFT variant for efficiency.\n$4$. The one-sided power spectrum is calculated as the squared magnitude of the complex FFT coefficients.\n$5$. The angular frequency grid $\\omega_k = 2\\pi f_k$ is constructed, where $f_k$ are the discrete frequencies corresponding to the FFT bins.\n$6$. The peak angular frequency, $\\omega_{\\text{peak}}$, is identified by finding the maximum of the power spectrum within the specified search band $\\omega \\in [0.1, 4.0]$ rad/s.\nThis procedure is repeated for each of the four parameter sets provided, using the specified random number generator seed for reproducibility. The resulting values of $\\omega_{\\text{peak}}$ are then reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import rfft, rfftfreq\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a damped, driven harmonic oscillator\n    with stochastic forcing and finding the peak frequency of its power spectrum.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, c, k, F0, wd, D)\n        (1.0, 0.25, 1.0, 1.0, 0.9, 0.02),  # Case 1\n        (1.0, 0.25, 1.0, 1.0, 0.8, 0.0),   # Case 2\n        (1.0, 2.0,  1.0, 1.0, 1.2, 0.03),  # Case 3\n        (1.0, 0.2,  1.0, 0.0, 1.0, 0.05),  # Case 4\n    ]\n\n    # Simulation and analysis parameters\n    T = 60.0  # Total simulation time in seconds\n    dt = 1e-3  # Timestep in seconds\n    T_burn = 10.0  # Burn-in time in seconds\n    omega_min = 0.1  # Search band minimum angular frequency in rad/s\n    omega_max = 4.0  # Search band maximum angular frequency in rad/s\n\n    N_total = int(T / dt)\n    N_burn = int(T_burn / dt)\n    N_signal = N_total - N_burn\n    \n    time_pts = np.arange(0, T, dt)\n    \n    results = []\n    for i, params in enumerate(test_cases):\n        m, c, k, F0, wd, D = params\n        seed = 12345 + i\n        rng = np.random.default_rng(seed)\n\n        x = np.zeros(N_total)\n        v = np.zeros(N_total)\n        \n        # Initial conditions x(0)=0, v(0)=0 are set by np.zeros\n\n        # Pre-compute coefficients for the integration loop\n        c1 = -k / m\n        c2 = -c / m\n        c3 = F0 / m\n        stochastic_term_coeff = np.sqrt(2 * D * dt) / m\n        \n        # Euler-Maruyama integration\n        for n in range(N_total - 1):\n            t_n = time_pts[n]\n            Z_n = rng.normal(0.0, 1.0)\n            \n            # Update velocity first\n            v_drift = (c1 * x[n] + c2 * v[n] + c3 * np.cos(wd * t_n))\n            v_stochastic = stochastic_term_coeff * Z_n\n            v[n+1] = v[n] + v_drift * dt + v_stochastic\n            \n            # Update position using velocity at step n\n            x[n+1] = x[n] + v[n] * dt\n            \n        # --- Spectral Analysis ---\n        x_signal = x[N_burn:]\n        \n        # 1. Remove sample mean\n        x_signal_detrended = x_signal - np.mean(x_signal)\n        \n        # 2. Apply Hann window\n        hann_window = np.hanning(N_signal)\n        x_windowed = x_signal_detrended * hann_window\n        \n        # 3. Compute FFT for real input\n        yf = rfft(x_windowed)\n        xf = rfftfreq(N_signal, dt)\n        \n        # 4. Form angular frequencies and one-sided power spectrum\n        omega = 2.0 * np.pi * xf\n        power_spectrum = np.abs(yf)**2\n        \n        # 5. Find peak frequency in the specified band\n        search_indices = np.where((omega >= omega_min) & (omega <= omega_max))\n        \n        peak_idx_local = np.argmax(power_spectrum[search_indices])\n        peak_idx_global = search_indices[0][peak_idx_local]\n        \n        omega_peak = omega[peak_idx_global]\n        \n        results.append(f\"{omega_peak:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2419810"}]}