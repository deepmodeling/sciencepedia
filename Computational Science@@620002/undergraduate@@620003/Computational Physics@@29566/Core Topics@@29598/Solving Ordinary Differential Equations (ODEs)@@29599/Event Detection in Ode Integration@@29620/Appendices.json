{"hands_on_practices": [{"introduction": "This first exercise provides a classic entry point into event detection by modeling a projectile's trajectory until it impacts a non-flat surface. The core task is to identify the precise moment a projectile's path, governed by simple kinematic equations, intersects with a static parabolic hill [@problem_id:2390630]. This practice solidifies the fundamental concept of defining an event as the zero of a function that depends on the system's state variables, a cornerstone of simulating interactions and boundary crossings.", "problem": "Consider the ballistic motion of a point-mass projectile in a uniform gravitational field without aerodynamic drag. Let the state of the projectile be given by position $(x(t), y(t))$ in meters and velocity $(v_x(t), v_y(t))$ in meters per second. The dynamics follow Newton’s second law with constant gravitational acceleration $g$ pointing downward. The ground is a deterministic, perfectly rigid, parabolic surface described by the height function $h(x) = a x^2 + b$, where $a$ has units of inverse meters and $b$ has units of meters. An impact event occurs at the earliest time $t_{\\text{hit}} > 0$ such that $y(t_{\\text{hit}}) = h(x(t_{\\text{hit}}))$, with the event detected only when the trajectory crosses the surface from above to below. There is no rebound. Assume the projectile’s initial state is specified by $(x(0), y(0)) = (x_0, y_0)$ in meters and an initial speed $v_0$ in meters per second at a launch angle $\\theta$ measured from the positive $x$-axis (angles expressed in degrees).\n\nFrom first principles, the motion is governed by the ordinary differential equations (ODEs):\n- $dx/dt = v_x$,\n- $dy/dt = v_y$,\n- $dv_x/dt = 0$,\n- $dv_y/dt = -g$.\n\nDefine the event function $\\phi(t) = y(t) - h(x(t))$. The impact time $t_{\\text{hit}}$ is the smallest positive root of $\\phi(t)$ such that the directional crossing is negative (i.e., $\\phi$ crosses zero from positive to negative).\n\nYour task is to write a complete program that, for each test case below, integrates the ODE forward in time from $t = 0$ until the first impact event or until a finite cutoff time $t_{\\max}$ is reached if no event occurs. Use the following rules:\n- Use $g = 9.81$ in meters per second squared.\n- Convert the launch angle $\\theta$ from degrees to radians before using trigonometric functions.\n- The event is defined by $\\phi(t) = y(t) - (a x(t)^2 + b)$ with detection restricted to downward crossing only.\n- If the event is detected, return the quadruple $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$, where $v_{\\text{hit}} = \\sqrt{v_x(t_{\\text{hit}})^2 + v_y(t_{\\text{hit}})^2}$ is the speed at impact.\n- If no event occurs on $[0, t_{\\max}]$, return $[\\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}, \\mathrm{nan}]$.\n\nAll answers must be expressed in International System of Units (SI): time in seconds, position in meters, speed in meters per second. Angles are provided in degrees and must be converted to radians internally. Your program must round each reported floating-point value to six decimal places.\n\nTest suite (each case is $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$):\n- Case A (general “happy path”): $(0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0)$.\n- Case B (near-horizontal launch above a raised hill): $(0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0)$.\n- Case C (steep launch; impact occurs later as the hill rises): $(0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0)$.\n- Case D (vertical drop at fixed horizontal position): $(0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0)$.\n\nFinal output format: Your program should produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets, where each element is itself a list in the form $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$. For example: $[[t_1,x_1,y_1,v_1],[t_2,x_2,y_2,v_2],[t_3,x_3,y_3,v_3],[t_4,x_4,y_4,v_4]]$. Each number must be rounded to six decimal places as specified.", "solution": "The problem presented is valid. It is a well-posed problem in classical mechanics and computational physics, grounded in the established principles of kinematics and ordinary differential equations. All necessary conditions and parameters are provided, and there are no scientific or logical inconsistencies. We shall proceed with a solution.\n\nThe problem requires a numerical solution to a system of ordinary differential equations (ODEs) describing projectile motion, with the integration terminating upon a specific event: the impact of the projectile with a parabolic surface. The core of the task is the correct formulation of the dynamical system and the implementation of an event detection algorithm.\n\nFirst, we define the state of the system at any time $t \\ge 0$. The state vector $S(t)$ is given by the projectile's position and velocity components:\n$$\nS(t) = \\begin{bmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{bmatrix}\n$$\nThe dynamics of the system are governed by Newton's second law for a point mass in a uniform gravitational field with acceleration $g$. This yields a system of four first-order ODEs:\n$$\n\\frac{dS}{dt} = \\frac{d}{dt} \\begin{bmatrix} x \\\\ y \\\\ v_x \\\\ v_y \\end{bmatrix} = \\begin{bmatrix} v_x \\\\ v_y \\\\ 0 \\\\ -g \\end{bmatrix} = F(S)\n$$\nThe initial state $S(0)$ is determined from the given initial conditions: position $(x_0, y_0)$, speed $v_0$, and launch angle $\\theta$. The angle $\\theta$ must first be converted from degrees to radians, let's call it $\\theta_{\\text{rad}}$. The initial velocity components are then:\n$$\nv_x(0) = v_0 \\cos(\\theta_{\\text{rad}})\n$$\n$$\nv_y(0) = v_0 \\sin(\\theta_{\\text{rad}})\n$$\nThus, the initial state vector is fully specified as $S(0) = [x_0, y_0, v_x(0), v_y(0)]^T$.\n\nThe impact event is defined by the condition that the projectile's vertical position $y(t)$ is equal to the height of the parabolic ground surface $h(x(t)) = ax(t)^2 + b$. We define an event function $\\phi(t)$ whose roots correspond to intersections of the trajectory with the surface:\n$$\n\\phi(t) = y(t) - h(x(t)) = y(t) - (a \\cdot x(t)^2 + b)\n$$\nAn impact occurs at time $t_{\\text{hit}}$ if $\\phi(t_{\\text{hit}}) = 0$. The problem specifies two additional constraints:\n$1$. The impact must be the earliest such event for $t > 0$.\n$2$. The event is detected only for a downward crossing, which means the projectile is moving from above the surface to below it. This translates to the condition that the event function is decreasing at the root, i.e., $\\frac{d\\phi}{dt} \\bigg|_{t=t_{\\text{hit}}}  0$.\n\nThe standard and most robust method for solving such a problem is to use a numerical ODE integrator that includes a root-finding capability for event detection. The `scipy.integrate.solve_ivp` function from the SciPy library is precisely designed for this purpose.\n\nThe algorithm proceeds as follows for each test case:\n$1$. **Initialization**: The parameters $(a, b, x_0, y_0, v_0, \\theta, t_{\\max})$ are used to define the specific problem instance. The gravitational constant is $g = 9.81 \\, \\text{m/s}^2$. The initial state vector $S(0)$ is computed as described above. The integration time interval is $[0, t_{\\max}]$.\n\n$2$. **ODE System Definition**: A function, say `ode_system(t, S)`, is defined to compute the derivative vector $\\frac{dS}{dt}$. This function implements the equations of motion. Given the state vector $S = [x, y, v_x, v_y]$ (using 0-based indexing), the function returns $[S[2], S[3], 0, -g]$.\n\n$3$. **Event Function Definition**: A function, say `event_func(t, S)`, is defined to compute the value of the event function $\\phi(t, S(t)) = S[1] - (a \\cdot S[0]^2 + b)$. To satisfy the problem's constraints, we configure this event function for the solver:\n    - We set its `terminal` attribute to `True`. This instructs the solver to terminate the integration when the event is found.\n    - We set its `direction` attribute to $-1$. This instructs the solver to only report roots where the event function is decreasing (crossing zero from positive to negative), which matches the physical requirement.\n\n$4$. **Numerical Integration**: The `solve_ivp` function is called with the ODE system, the time interval, the initial state vector, and the configured event function. We must also request `dense_output=True` to ensure the solver can accurately locate the root between integration steps.\n\n$5$. **Result Extraction**: After the solver returns, we inspect its output.\n    - If the `sol.t_events` list is not empty, an event was successfully detected. The first element, `sol.t_events[0][0]`, gives the impact time $t_{\\text{hit}}$. The corresponding state at impact, $S(t_{\\text{hit}})$, is found in `sol.y_events[0][0]`.\n    - From the state at impact, we extract the position $(x_{\\text{hit}}, y_{\\text{hit}})$ and velocity $(v_{x,\\text{hit}}, v_{y,\\text{hit}})$. The final impact speed is calculated as $v_{\\text{hit}} = \\sqrt{v_{x,\\text{hit}}^2 + v_{y,\\text{hit}}^2}$.\n    - If the `sol.t_events` list is empty, no event satisfying the conditions occurred within the interval $[0, t_{\\max}]$. In this case, the result is reported as not a number (`nan`) for all four output values.\n\n$6$. **Formatting**: The final numerical results, $[t_{\\text{hit}}, x_{\\text{hit}}, y_{\\text{hit}}, v_{\\text{hit}}]$, are rounded to six decimal places as required.\n\nThis procedure provides a complete, correct, and robust solution to the problem, directly implementing the physical principles using standard, validated computational tools.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the impact time and state of a projectile on a parabolic surface.\n    \"\"\"\n    # Gravitational constant in m/s^2\n    G = 9.81\n\n    # Test suite: (a, b, x0, y0, v0, theta, t_max)\n    test_cases = [\n        # Case A (general “happy path”)\n        (0.02, 0.0, 0.0, 2.0, 20.0, 30.0, 10.0),\n        # Case B (near-horizontal launch above a raised hill)\n        (0.05, 1.0, 0.0, 1.5, 10.0, 0.0, 10.0),\n        # Case C (steep launch; impact occurs later as the hill rises)\n        (0.001, 0.0, 0.0, 1.0, 50.0, 60.0, 30.0),\n        # Case D (vertical drop at fixed horizontal position)\n        (0.01, 2.0, 5.0, 5.0, 0.0, 90.0, 10.0),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a, b, x0, y0, v0, theta_deg, t_max = case\n\n        # Convert angle to radians for trigonometric functions\n        theta_rad = np.deg2rad(theta_deg)\n\n        # Calculate initial velocity components\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n\n        # Initial state vector: [x, y, vx, vy]\n        s0 = [x0, y0, vx0, vy0]\n\n        def ode_system(t, s):\n            \"\"\"\n            Defines the system of ordinary differential equations for projectile motion.\n            s = [x, y, vx, vy]\n            \"\"\"\n            # dx/dt = vx\n            # dy/dt = vy\n            # dvx/dt = 0\n            # dvy/dt = -g\n            return [s[2], s[3], 0, -G]\n\n        def event_func(t, s):\n            \"\"\"\n            Event function for impact detection.\n            The event occurs when y(t) - h(x(t)) = 0.\n            h(x) = a*x^2 + b\n            \"\"\"\n            return s[1] - (a * s[0]**2 + b)\n\n        # Set event properties: terminate on event, detect downward crossing\n        event_func.terminal = True\n        event_func.direction = -1\n\n        # Integrate the ODE system\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, t_max],\n            y0=s0,\n            events=event_func,\n            dense_output=True,\n        )\n\n        # Process the results\n        if sol.t_events and len(sol.t_events[0]) > 0:\n            # Event was detected\n            t_hit = sol.t_events[0][0]\n            s_hit = sol.y_events[0][0]\n            x_hit, y_hit, vx_hit, vy_hit = s_hit\n\n            # The problem asks for the height of the impact to be y_hit,\n            # which is guaranteed by the event function to be a*x_hit**2 + b\n            # at the located root.\n            \n            # Calculate final speed at impact\n            v_hit = np.sqrt(vx_hit**2 + vy_hit**2)\n\n            case_result = [t_hit, x_hit, y_hit, v_hit]\n        else:\n            # No event detected within t_max\n            case_result = [np.nan, np.nan, np.nan, np.nan]\n\n        all_results.append(case_result)\n\n    # Format the final output string\n    formatted_results = []\n    for case_res in all_results:\n        str_vals = []\n        for val in case_res:\n            if np.isnan(val):\n                str_vals.append(\"nan\")\n            else:\n                str_vals.append(f\"{val:.6f}\")\n        formatted_results.append(f\"[{','.join(str_vals)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2390630"}, {"introduction": "Building upon the foundational skills, this problem introduces two critical complexities: handling a sequence of multiple events and modeling a boundary that is itself in motion. You will simulate a ball bouncing on an oscillating platform, where each impact is an event that resets the ball's velocity according to a coefficient of restitution [@problem_id:2390644]. This practice is essential for learning how to manage discrete state changes within a continuous integration, a technique vital for modeling everything from mechanical collisions to switching electronic circuits.", "problem": "You are asked to implement event detection in ordinary differential equation integration for a one-dimensional bouncing ball over an oscillating platform. The vertical position of the ball is modeled by the second-order ordinary differential equation derived from Newton’s Second Law for motion under gravity. The platform moves vertically according to a prescribed kinematic function. An impact event occurs at the instant when the height of the ball equals the height of the platform while the ball approaches the platform from above. Upon impact, the ball’s velocity changes according to the definition of the coefficient of restitution. Your task is to detect all such events within a finite time interval and update the ball’s velocity at each impact consistently with the collision law. The final outputs must be computed for a small set of specified test cases.\n\nUse the following fundamental base:\n- Newton’s Second Law for vertical motion under uniform gravity: the vertical position $y(t)$ and vertical velocity $v(t)$ of the ball obey $\\dot{y}(t) = v(t)$ and $\\dot{v}(t) = -g$, where $g$ is the gravitational acceleration.\n- The platform height is $y_{p}(t)$, a known function of time. The platform velocity is $v_{p}(t) = \\dot{y}_{p}(t)$.\n- The coefficient of restitution $e \\in [0,1]$ is defined as the ratio of the magnitude of the post-impact relative normal speed to the pre-impact relative normal speed.\n\nMathematical setup:\n- State vector: $\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$ governed by\n$$\n\\dot{\\mathbf{x}}(t) = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}.\n$$\n- Platform motion: $y_{p}(t) = A \\sin(\\omega t)$ with $\\omega = 2\\pi f$, where $A$ is the oscillation amplitude and $f$ is the frequency. The platform velocity is $v_{p}(t) = A \\omega \\cos(\\omega t)$.\n- Event definition: an event occurs at times $t$ such that $y(t) = y_{p}(t)$ while the ball is approaching the platform from above. An event must be detected through a zero of a scalar function, and your detection must enforce the approach direction to avoid spurious contacts.\n- Impact update: if an event occurs at time $t_{\\mathrm{imp}}$, let $v^{-}$ be the ball velocity just before impact and $v^{+}$ the velocity just after. Let $v_{p}$ be the platform velocity at the same instant. Use the coefficient of restitution definition to update $v^{+}$ from $v^{-}$ and $v_{p}$.\n- Sticking criterion: to avoid numerical chattering when the post-impact relative speed is negligible, treat the ball as “sticking” to the platform if $|v^{+} - v_{p}|$ falls below a small tolerance $\\varepsilon_{v}$. In this case, for the remainder of the simulation, the ball moves with the platform, i.e., $y(t) = y_{p}(t)$.\n\nNumerical instructions:\n- Use an event-capable adaptive ordinary differential equation integrator to advance the state from $t=0$ to $t=T$, repeatedly handling impacts when they occur. Ensure that event bracketing and directionality are configured to detect $y(t) - y_{p}(t)$ crossings only when decreasing through zero.\n- Use a small positive time offset after each handled impact to reinitialize the integrator away from the event surface.\n- Use relative and absolute tolerances small enough to reliably localize event times.\n\nOutputs:\nFor each test case, compute the following quantities:\n1. The total number of impact events $N$ detected in $t \\in [0,T]$ (integer).\n2. The time of the first impact $t_{\\mathrm{first}}$ in seconds if at least one impact occurs; otherwise report $-1.0$.\n3. The time of the last impact $t_{\\mathrm{last}}$ in seconds if at least one impact occurs; otherwise report $-1.0$.\n4. The final ball height $y(T)$ in meters at the end of the simulation.\n\nPhysical and numerical units and formatting:\n- All times must be reported in seconds, and all lengths in meters.\n- Report $t_{\\mathrm{first}}$, $t_{\\mathrm{last}}$, and $y(T)$ rounded to six decimal places.\n- The coefficient of restitution $e$ is dimensionless. The gravitational acceleration $g$ is in $\\mathrm{m}/\\mathrm{s}^2$. The oscillation amplitude $A$ is in meters, frequency $f$ in hertz, and angular frequency $\\omega$ in radians per second.\n\nTest suite:\nSimulate the following four cases, each specified as $(g, A, f, e, y_{0}, v_{0}, T)$ where $y_{0}$ and $v_{0}$ are the initial height (in meters) and vertical velocity (in meters per second) at $t=0$:\n\n- Case 1 (general oscillating platform): $(9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0)$.\n- Case 2 (boundary: initial contact with downward approach): $(9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0)$.\n- Case 3 (edge: no collision within the horizon): $(9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5)$.\n- Case 4 (edge: completely inelastic on a static floor): $(9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the four cases as a comma-separated list of four sublists, each sublist in the order $[N, t_{\\mathrm{first}}, t_{\\mathrm{last}}, y(T)]$ and with floating-point values rounded to six decimals. For example, the output must look like:\n\"[[N1,tfirst1,tlast1,yT1],[N2,tfirst2,tlast2,yT2],[N3,tfirst3,tlast3,yT3],[N4,tfirst4,tlast4,yT4]]\" but without extra spaces except those required by list delimiters. Replace each placeholder with the computed numbers.", "solution": "The problem statement has been analyzed and is determined to be valid. It constitutes a well-posed problem in computational physics, based on fundamental principles of classical mechanics. The objectives are clearly defined, and the provided data are sufficient and consistent for constructing a numerical solution. The task is to simulate the one-dimensional motion of a ball under gravity, subject to collisions with an oscillating platform, and to report specific metrics of this motion.\n\nThe approach involves the numerical integration of the governing ordinary differential equations (ODEs), coupled with an event detection mechanism to handle the discrete impacts. The solution is constructed methodologically, beginning with the physical model and proceeding to the numerical algorithm.\n\nThe state of the ball at any time $t$ is described by its vertical position $y(t)$ and velocity $v(t)$. The state vector is $\\mathbf{x}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$. According to Newton's Second Law for a body in a uniform gravitational field, the equations of motion are:\n$$\n\\dot{\\mathbf{x}}(t) = \\frac{d\\mathbf{x}}{dt} = \\begin{bmatrix} v(t) \\\\ -g \\end{bmatrix}\n$$\nwhere $g$ is the acceleration due to gravity. This is a system of first-order ODEs.\n\nThe platform's motion is prescribed as a sinusoidal function of time:\n$$\ny_{p}(t) = A \\sin(\\omega t)\n$$\nwhere $A$ is the amplitude and $\\omega = 2\\pi f$ is the angular frequency. The platform's velocity is the time derivative of its position:\n$$\nv_{p}(t) = \\dot{y}_{p}(t) = A \\omega \\cos(\\omega t)\n$$\n\nAn impact event occurs when the ball makes contact with the platform. The problem specifies two conditions for a valid impact:\n$1$. The position of the ball equals the position of the platform: $y(t) = y_{p}(t)$.\n$2$. The ball is approaching the platform from above. This implies that the relative velocity, $v(t) - v_{p}(t)$, is negative just before impact.\n\nThese conditions are captured by a scalar event function, $E(t, \\mathbf{x}(t)) = y(t) - y_{p}(t)$. An impact corresponds to a root of this function, $E(t, \\mathbf{x}(t))=0$. The approach direction condition means that the event must be detected only when the function $E(t, \\mathbf{x}(t))$ is decreasing through zero.\n\nThe numerical integration of the ODE system is performed using an adaptive step-size integrator, specifically the `solve_ivp` function from the SciPy library, which is well-suited for this class of problem due to its built-in event detection capabilities. The simulation proceeds in a loop. In each step of the loop, the integrator advances the solution from the current time $t_{current}$ until either the final time $T$ is reached or an event is detected.\n\nIf an event is detected at time $t_{\\mathrm{imp}}$, the integration is stopped. The state of the ball just before impact, $\\mathbf{x}^{-}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{-}(t_{\\mathrm{imp}}) \\end{bmatrix}$, is obtained. The ball's velocity is then instantaneously updated according to the law of restitution. The coefficient of restitution $e$ is defined by:\n$$\nv_{\\mathrm{rel, post}} = -e \\cdot v_{\\mathrm{rel, pre}}\n$$\nwhere $v_{\\mathrm{rel, pre}} = v^{-} - v_{p}$ and $v_{\\mathrm{rel, post}} = v^{+} - v_{p}$ are the relative velocities before and after impact, respectively. Here, $v_{p}$ is the platform velocity at $t_{\\mathrm{imp}}$, and $v^{+}$ is the ball's velocity just after impact. This yields the update rule for the ball's velocity:\n$$\nv^{+} = v_{p}(t_{\\mathrm{imp}}) - e \\left( v^{-} - v_{p}(t_{\\mathrm{imp}}) \\right)\n$$\nThe position of the ball remains continuous through the impact, $y^{+}(t_{\\mathrm{imp}}) = y^{-}(t_{\\mathrm{imp}})$.\n\nAfter the velocity update, a check for \"sticking\" is performed. If the post-impact relative speed $|v^{+} - v_{p}(t_{\\mathrm{imp}})|$ is below a small numerical tolerance $\\varepsilon_{v}$, the ball is considered to have stuck to the platform. In this case, the simulation of ballistic motion is terminated. For all subsequent times $t  t_{\\mathrm{imp}}$, the ball's trajectory is kinematically determined by the platform's motion, $y(t) = y_{p}(t)$. The final height at time $T$ is then simply $y(T) = y_p(T)$.\n\nIf the ball does not stick, the integrator is reinitialized with the new state $\\mathbf{x}^{+}(t_{\\mathrm{imp}}) = \\begin{bmatrix} y(t_{\\mathrm{imp}}) \\\\ v^{+} \\end{bmatrix}$, and the time is advanced by a small offset from $t_{\\mathrm{imp}}$ to prevent the event from being detected again immediately. The integration loop then continues.\n\nThis process is repeated until the simulation time $t$ reaches the final time $T$. Special care is taken for the boundary case where an impact occurs at the initial time $t=0$, by performing an impact-update calculation before starting the main integration loop.\n\nThe required outputs—the total number of impacts $N$, the times of the first and last impacts ($t_{\\mathrm{first}}$, $t_{\\mathrm{last}}$), and the final ball height $y(T)$—are collected during this process. If no impacts occur, $N$ is $0$, and $t_{\\mathrm{first}}$ and $t_{\\mathrm{last}}$ are reported as $-1.0$. The numerical tolerances for the ODE solver (`rtol`, `atol`) are set to a small value, $10^{-12}$, to ensure high accuracy in both the trajectory and the event time localization. The sticking tolerance $\\varepsilon_v$ is set to $10^{-8}$.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(g, A, f, e, y0, v0, T):\n        \"\"\"\n        Solves the bouncing ball problem for a single set of parameters.\n        \"\"\"\n        omega = 2.0 * np.pi * f\n        sticking_tolerance = 1e-8\n        time_offset = 1e-12\n\n        # Define platform kinematics\n        def platform_pos(t):\n            if A == 0.0:\n                return 0.0\n            return A * np.sin(omega * t)\n\n        def platform_vel(t):\n            if A == 0.0:\n                return 0.0\n            return A * omega * np.cos(omega * t)\n\n        # Define ODE system for the ball\n        def dynamics(t, state):\n            # state = [y, v]\n            return [state[1], -g]\n\n        # Define event function for impact detection\n        def impact_event(t, state):\n            # Event function is zero when ball height equals platform height\n            return state[0] - platform_pos(t)\n        \n        impact_event.terminal = True  # Stop integration at event\n        impact_event.direction = -1   # Trigger only when function is decreasing\n\n        # Initialize simulation variables\n        t_current = 0.0\n        state_current = np.array([y0, v0], dtype=float)\n        impact_times = []\n        is_sticking = False\n\n        # Handle potential impact at t=0, which solve_ivp might ignore.\n        # Check if positions match and relative velocity is negative.\n        if np.isclose(state_current[0], platform_pos(0.0)):\n            v_rel_initial = state_current[1] - platform_vel(0.0)\n            if v_rel_initial  0:\n                impact_times.append(0.0)\n                v_minus = state_current[1]\n                v_p = platform_vel(0.0)\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                if abs(v_plus - v_p)  sticking_tolerance:\n                    is_sticking = True\n                    t_current = 0.0\n                else:\n                    state_current[1] = v_plus\n                    t_current += time_offset\n\n        # Main simulation loop\n        while t_current  T and not is_sticking:\n            sol = solve_ivp(\n                dynamics,\n                (t_current, T),\n                state_current,\n                events=impact_event,\n                dense_output=True,\n                rtol=1e-12,\n                atol=1e-12\n            )\n            \n            t_current = sol.t[-1]\n            state_current = sol.y[:, -1]\n\n            # Check if an event was found\n            if sol.status == 1 and sol.t_events[0].size > 0:\n                t_event = sol.t_events[0][0]\n                impact_times.append(t_event)\n                \n                # State right before impact\n                state_at_event = sol.sol(t_event)\n                v_minus = state_at_event[1]\n                v_p = platform_vel(t_event)\n                \n                # Apply restitution law\n                v_plus = v_p - e * (v_minus - v_p)\n                \n                # Check for sticking\n                if abs(v_plus - v_p)  sticking_tolerance:\n                    is_sticking = True\n                    t_current = t_event # Set time for final height calculation\n                    break\n                \n                # Re-initialize state for next integration segment\n                t_current = t_event + time_offset\n                state_current[0] = state_at_event[0]\n                state_current[1] = v_plus\n                \n                if t_current >= T:\n                    break\n        \n        # Calculate final reported values\n        N = len(impact_times)\n        t_first = -1.0 if N == 0 else impact_times[0]\n        t_last = -1.0 if N == 0 else impact_times[-1]\n        \n        if is_sticking:\n            y_final = platform_pos(T)\n        else:\n            y_final = state_current[0]\n\n        return [\n            N,\n            round(t_first, 6),\n            round(t_last, 6),\n            round(y_final, 6)\n        ]\n\n    test_cases = [\n        (9.81, 0.10, 1.5, 0.8, 1.0, 0.0, 3.0),\n        (9.81, 0.05, 2.0, 0.9, 0.0, -1.0, 1.0),\n        (9.81, 0.05, 1.0, 0.8, -0.5, 2.0, 0.5),\n        (9.81, 0.0, 0.0, 0.0, 1.0, 0.0, 2.0)\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        results.append(result)\n    \n    # Format the final output string exactly as required, with no extra spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2390644"}, {"introduction": "Our final practice delves into the fascinating world of nonlinear dynamics by using event detection to explore the complex behavior of a dripping faucet. This advanced model involves a non-autonomous system where both the dynamics and the event condition depend on the drop's growing mass, leading to a sequence of discrete detachment events [@problem_id:2419756]. By analyzing the time intervals between these events, you will uncover the period-doubling route to chaos, demonstrating how a sophisticated, event-driven simulation can reveal deep physical principles hidden within everyday phenomena.", "problem": "You are asked to build a complete, runnable program that numerically models a dripping faucet through the lens of a damped driven oscillator. The model is constructed from Newton’s second law, under the following simplifying and widely used assumptions: while a drop remains attached to the faucet, it behaves as a point mass connected to a linear spring and damper, subject to a constant gravitational force. The faucet adds mass at a constant flow rate, and the drop detaches when the elongation exceeds a mass-dependent rupture threshold. After detachment, a small residue remains as the seed of the next drop. This setting is a standard computational physics exercise and leads to a non-autonomous ordinary differential equations (ODEs) with state resets. The goal is to simulate the dynamics as the flow rate changes and to extract the number of distinct inter-drip times after transients, thereby revealing a period-doubling sequence.\n\nStart from Newton’s second law and the definitions of linear damping and linear elasticity. While the drop is attached, assume the following:\n- The position of the drop relative to the faucet is a scalar displacement $x(t)$ measured downward, with velocity $v(t) = \\frac{dx}{dt}$.\n- The instantaneous mass $m(t)$ increases at a constant inflow rate $q$, i.e., $\\frac{dm}{dt} = q$.\n- The forces on the drop are due to gravity, a linear spring, and a linear damper, with coefficients $g$, $\\kappa$, and $\\gamma$, respectively.\n- The newly added mass is assumed to attach with negligible relative momentum effect, giving a commonly used approximation where the left-hand side uses $m(t)\\,x''(t)$ without an additional jet-momentum term.\n\nUnder these assumptions, the governing equations while attached are\n$$\n\\frac{dx}{dt} = v, \\quad \n\\frac{dv}{dt} = \\frac{m(t)\\,g - \\gamma\\,v - \\kappa\\,x}{m(t)}, \\quad\n\\frac{dm}{dt} = q.\n$$\nA rupture (detachment) occurs when the elongation $x(t)$ reaches a threshold $x_{\\mathrm{break}}(m)$ from below, with\n$$\nx_{\\mathrm{break}}(m) = x_0 - \\beta\\,m,\n$$\nwhere $x_0$ and $\\beta$ are positive constants. At detachment time $t_d$, the state is reset to model a remnant (residual) mass sticking to the faucet neck and a relaxed, motionless initial condition for the next drop:\n$$\nx(t_d^+) = 0, \\quad v(t_d^+) = 0, \\quad m(t_d^+) = \\alpha\\,m(t_d^-),\n$$\nwhere $0  \\alpha  1$ is the residual-mass fraction and the superscripts $^-$ and $^+$ denote limits from before and after the event, respectively.\n\nYour tasks are:\n1) From Newton’s second law, justify the above ODE system and reset rule under the stated assumptions. Clarify how the variable mass enters the acceleration equation and why the chosen simplification is appropriate in this context.\n2) Design and implement a robust event-driven numerical integrator to:\n   - Integrate the ODE until the rupture event $x(t) - x_{\\mathrm{break}}(m(t)) = 0$ is detected with increasing $x$.\n   - Apply the reset rule and continue simulating to generate a long sequence of drip times.\n3) For each specified flow rate $q$, compute the inter-drip times $\\Delta t_n = t_{n} - t_{n-1}$. Discard an initial transient and then determine the number of distinct inter-drip times present within a tolerance, which is an integer diagnostic of the period-$k$ behavior (e.g., $k=1$ for period-1, $k=2$ for period-2 after a period-doubling, etc.). Use a tolerance that combines absolute and relative components to avoid false distinctions due to numerical noise.\n4) Use the following dimensionless parameters for the oscillator and rupture model, and specify the test suite of flow rates:\n   - Oscillator parameters: $\\kappa = 1.0$, $\\gamma = 0.05$, $g = 0.34$.\n   - Rupture parameters: $x_0 = 0.50$, $\\beta = 0.10$, $\\alpha = 0.30$.\n   - Initial conditions at the very start: $x(0) = 0$, $v(0) = 0$, $m(0) = 0.40$.\n   - Flow-rate test suite (four cases): $q \\in \\{\\,0.010,\\,0.025,\\,0.050,\\,0.080\\,\\}$.\n   - Integrate long enough to observe at least $N_{\\mathrm{total}} = 60$ drips per case, discarding the first $N_{\\mathrm{trans}} = 30$ as transient, and analyzing the next $N_{\\mathrm{keep}} = 30$ drips.\n   - Use a detection tolerance that clusters inter-drip times $\\Delta t$ into distinct groups using the rule “same group if $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$” with $\\varepsilon_{\\mathrm{abs}}=10^{-3}$ and $\\varepsilon_{\\mathrm{rel}}=10^{-3}$.\n5) Your program must produce a single line of output containing the results as a comma-separated list of integers enclosed in square brackets (e.g., [1,2,4,1]), where each integer is the counted number of distinct inter-drip times for the corresponding flow rate in the order given above.\n\nThe problem must be solved in purely mathematical and algorithmic terms so that it is implementable in any programming language. All quantities above are dimensionless, so no physical unit conversion is required. Ensure scientific realism in parameters and discuss in your solution why the approach captures the period-doubling sequence. The final answers for each test case are integers that quantify the distinct inter-drip times found after transients.", "solution": "The problem presented is a valid exercise in computational physics. It is scientifically sound, well-posed, and all necessary parameters and conditions are specified. It represents a standard simplification of a complex physical phenomenon—the dripping faucet—into a non-autonomous system of ordinary differential equations with state resets, a model known to exhibit period-doubling bifurcations and chaos. We shall proceed with a rigorous derivation and algorithmic design.\n\nFirst, we must justify the governing equations from fundamental principles. The system described is a point mass whose mass $m(t)$ changes with time. Newton's second law for a body of variable mass is most generally stated as the rate of change of momentum $\\vec{p}$ being equal to the net external force $\\vec{F}_{\\mathrm{ext}}$, i.e., $\\vec{F}_{\\mathrm{ext}} = \\frac{d\\vec{p}}{dt}$. In our one-dimensional system, the momentum is $p(t) = m(t)v(t)$, where $v(t) = \\frac{dx}{dt}$ is the velocity. Applying the product rule for differentiation, we get:\n$$\n\\frac{dp}{dt} = \\frac{d(mv)}{dt} = m(t)\\frac{dv}{dt} + v(t)\\frac{dm}{dt} = m(t)a(t) + v(t)q\n$$\nwhere $a(t) = \\frac{dv}{dt}$ is the acceleration and $\\frac{dm}{dt} = q$ is the constant mass inflow rate. The term $v(t)q$ represents the force required to accelerate the incoming fluid (which is assumed to have zero initial vertical velocity) to the current velocity $v(t)$ of the drop. The problem statement directs us to use a common simplification where this \"jet-momentum\" term is neglected. This is a reasonable approximation if the velocity $v(t)$ is small or if the primary dynamics are dominated by other forces, which is often the case. Under this simplification, Newton's second law reduces to:\n$$\nm(t)a(t) \\approx F_{\\mathrm{ext}}\n$$\nThe external forces acting on the mass are gravity ($F_g = m(t)g$), the restoring force of a linear spring ($F_s = -\\kappa x$), and a linear viscous damping force ($F_d = -\\gamma v$). The spring constant is $\\kappa$, the damping coefficient is $\\gamma$, and $g$ is the acceleration due to gravity. The displacement $x$ is measured downwards from the faucet, so the gravitational force is positive. The sum of these forces is:\n$$\nF_{\\mathrm{ext}} = m(t)g - \\kappa x - \\gamma v\n$$\nEquating this with the simplified expression for the rate of change of momentum gives the equation of motion for the drop:\n$$\nm(t)\\frac{dv}{dt} = m(t)g - \\kappa x - \\gamma v\n$$\nDividing by the instantaneous mass $m(t)$ yields the acceleration:\n$$\n\\frac{dv}{dt} = g - \\frac{\\gamma}{m(t)}v - \\frac{\\kappa}{m(t)}x\n$$\nThis is precisely the equation provided. This equation, combined with the definitions $\\frac{dx}{dt} = v$ and $\\frac{dm}{dt} = q$, forms a system of three coupled, first-order, non-autonomous ordinary differential equations. The system is non-autonomous because the coefficients of $v$ and $x$ in the acceleration equation depend explicitly on time through the mass $m(t) = m(0) + qt$.\n\nThe simulation proceeds by integrating this system until a rupture event occurs. The condition for rupture is that the elongation $x(t)$ reaches a mass-dependent threshold $x_{\\mathrm{break}}(m) = x_0 - \\beta m$. The physical intuition is that as the drop gets heavier, surface tension is less able to support a large elongation. The event function is therefore $ G(t, x, m) = x(t) - x_{\\mathrm{break}}(m(t)) = 0$. We are interested in the event where $x(t)$ crosses this threshold from below, so we must detect a zero-crossing in the increasing direction.\n\nUpon detachment at a time $t_d$, the system state is reset. The new drop begins with zero displacement and velocity, $x(t_d^+) = 0$ and $v(t_d^+) = 0$. This is a simplification that assumes the remnant fluid settles instantly to a quiescent state. Crucially, not all mass detaches. A fraction $\\alpha$ of the drop's mass at rupture, $m(t_d^-)$, remains attached to the faucet: $m(t_d^+) = \\alpha m(t_d^-)$. This remnant mass $m(t_d^+)$ serves as the initial condition for the next drop and provides a \"memory\" between successive drip events. It is this memory, coupled with the nonlinear nature of the reset mechanism and the driving force of the mass influx, that allows the system to exhibit complex dynamics. The mass of the $n$-th drop at its formation, $m_n(0)$, depends on the mass of the $(n-1)$-th drop at its rupture, $m_{n-1}(t_{\\text{rupture}})$. This creates a mapping from one drip to the next, which for certain parameter regimes, such as the flow rate $q$, undergoes a period-doubling cascade, a hallmark of the route to chaos. For a low flow rate $q$, the system settles into a period-$1$ limit cycle, where each drop is identical and the time between drips is constant. As $q$ is increased, the system may bifurcate to a period-$2$ cycle, where inter-drip times (and drop sizes) alternate between two distinct values. Further increases in $q$ can lead to period-$4$, period-$8$, and eventually chaotic behavior where the inter-drip times appear random. Our task is to count these distinct inter-drip times for given values of $q$.\n\nThe algorithm is as follows:\n1.  Define a function for the system of ODEs: $\\frac{dY}{dt} = F(t, Y)$, where $Y = [x, v, m]^T$.\n2.  Define an event function for the rupture condition $x - (x_0 - \\beta m) = 0$. This function must be terminal and detect crossing from negative to positive values.\n3.  For each flow rate $q$ in the test suite:\n    a. Initialize the state vector $Y_0 = [0, 0, 0.40]^T$, current time $t_{\\mathrm{current}} = 0$, and a list to store drip times, `drip_times`.\n    b. Loop $N_{\\mathrm{total}} = 60$ times to collect data for $60$ drips.\n        i. Use a numerical ODE solver (such as `scipy.integrate.solve_ivp`) to integrate the system from $t_{\\mathrm{current}}$ with the current state, until the rupture event is triggered.\n        ii. Record the event time $t_{\\mathrm{event}}$. Add it to `drip_times`.\n        iii. Update the state vector according to the reset rules: $x_{\\mathrm{new}} = 0$, $v_{\\mathrm{new}} = 0$, $m_{\\mathrm{new}} = \\alpha \\cdot m_{\\mathrm{event}}$, where $m_{\\mathrm{event}}$ is the mass at the time of rupture. The new current time is $t_{\\mathrm{current}} = t_{\\mathrm{event}}$.\n    c. Compute the inter-drip times $\\Delta t_i = \\text{drip\\_times}[i] - \\text{drip\\_times}[i-1]$ for $i=1, \\dots, N_{\\mathrm{total}}-1$. We also need the first interval $\\text{drip\\_times}[0] - 0$. This yields $N_{\\mathrm{total}}$ intervals.\n    d. Discard the first $N_{\\mathrm{trans}} = 30$ intervals as transient dynamics.\n    e. Analyze the subsequent $N_{\\mathrm{keep}} = 30$ intervals. To count the number of distinct values, sort the intervals and iterate through the sorted list, counting groups of values that are close to each other based on the specified tolerance: $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$. A simple way is to count how many times an element is significantly different from the previous one in the sorted list.\n    f. Record this count as the result for the given $q$.\n4.  Format the final list of counts as specified.\nThis robust, event-driven approach correctly models the physics and allows for the accurate determination of the system's periodic behavior.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically models a dripping faucet to observe period-doubling.\n\n    The model treats a growing water drop as a damped, driven harmonic oscillator\n    with variable mass. The system is described by a non-autonomous ODE with\n    state resets upon drop detachment. This function simulates the dynamics for\n    a set of flow rates and determines the periodicity of the drip intervals.\n    \"\"\"\n\n    # Define physical and numerical parameters as per the problem statement.\n    # Oscillator parameters\n    kappa = 1.0  # Spring constant\n    gamma = 0.05 # Damping coefficient\n    g = 0.34     # Gravitational acceleration\n\n    # Rupture and reset parameters\n    x0 = 0.50    # Rupture threshold constant\n    beta = 0.10  # Rupture threshold mass dependency\n    alpha = 0.30 # Residual mass fraction\n\n    # Initial conditions for the very first drop\n    x_init = 0.0\n    v_init = 0.0\n    m_init = 0.40\n\n    # Simulation control\n    N_total = 60  # Total number of drips to simulate per case\n    N_trans = 30  # Number of transient drips to discard\n    \n    # Tolerance for clustering inter-drip times\n    eps_abs = 1e-3\n    eps_rel = 1e-3\n    \n    # Test suite of flow rates\n    test_cases = [0.010, 0.025, 0.050, 0.080]\n\n    results = []\n\n    # ODE system definition: dy/dt = f(t, y)\n    # y = [x, v, m]\n    def ode_system(t, y, q_val):\n        x, v, m = y\n        # Avoid division by zero if mass is ever zero, though m_init > 0.\n        if m = 0:\n            return [0.0, 0.0, q_val]\n        \n        dxdt = v\n        dvdt = g - (gamma * v / m) - (kappa * x / m)\n        dmdt = q_val\n        return [dxdt, dvdt, dmdt]\n\n    # Event function: fires when x(t) = x_break(m(t))\n    # x_break(m) = x0 - beta * m\n    def rupture_event(t, y, q_val):\n        x, v, m = y\n        return x - (x0 - beta * m)\n    \n    rupture_event.terminal = True  # Stop integration at the event\n    rupture_event.direction = 1    # Event triggers when x is increasing\n\n    # Main loop over each flow rate\n    for q_flow in test_cases:\n        \n        # Initialize state for this test case\n        current_time = 0.0\n        y_current = np.array([x_init, v_init, m_init])\n        \n        drip_times = []\n\n        # Simulate N_total drips\n        for _ in range(N_total):\n            # Define a sufficiently long time span for the next drip\n            t_span = (current_time, current_time + 100.0)\n            \n            # Integrate until the next rupture event\n            sol = solve_ivp(\n                fun=lambda t, y: ode_system(t, y, q_flow),\n                t_span=t_span,\n                y0=y_current,\n                events=lambda t, y: rupture_event(t, y, q_flow),\n                dense_output=True,\n                max_step=0.1\n            )\n            \n            # Check if an event was found\n            if sol.t_events[0].size > 0:\n                event_time = sol.t_events[0][0]\n                drip_times.append(event_time)\n                \n                # State at the moment of rupture\n                y_event = sol.sol(event_time)\n                m_rupture = y_event[2]\n                \n                # Apply reset rules\n                current_time = event_time\n                y_current = np.array([0.0, 0.0, alpha * m_rupture])\n            else:\n                # Should not happen with given parameters and t_span\n                # Break if no drip is found in the time window\n                break\n\n        # Analyze the collected drip times\n        if len(drip_times)  N_total:\n             # If simulation failed, append an error code (e.g., -1)\n             results.append(-1)\n             continue\n        \n        # Calculate inter-drip times\n        all_times = np.insert(np.array(drip_times), 0, 0.0)\n        inter_drip_times = np.diff(all_times)\n\n        # Discard transients and keep the part for analysis\n        analysis_times = inter_drip_times[N_trans:]\n\n        if len(analysis_times) == 0:\n            results.append(0)\n            continue\n        \n        # Cluster the inter-drip times to count distinct values\n        sorted_times = np.sort(analysis_times)\n        \n        num_distinct_times = 1\n        # The first time interval starts the first cluster\n        cluster_representative = sorted_times[0]\n        \n        for i in range(1, len(sorted_times)):\n            dt_current = sorted_times[i]\n            dt_prev = sorted_times[i-1]\n            \n            # Check if current time is \"far\" from previous one using the tolerance rule\n            tolerance = max(eps_abs, eps_rel * max(abs(dt_current), abs(dt_prev)))\n            if abs(dt_current - dt_prev) > tolerance:\n                num_distinct_times += 1\n        \n        results.append(num_distinct_times)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419756"}]}