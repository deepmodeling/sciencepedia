{"hands_on_practices": [{"introduction": "Our first practice moves beyond the standard simple harmonic oscillator (SHO) to a more dynamic system where the mass itself changes over time. This scenario, which could hypothetically model a rocket on a spring expelling fuel, transforms the familiar constant-coefficient differential equation into one with a time-dependent term, $m(t)\\ddot{x} + kx = 0$. This exercise [@problem_id:2420164] is fundamental to developing the skill of translating a physical system into a system of first-order ODEs and solving it using standard numerical library functions, a cornerstone of computational modeling.", "problem": "A point mass attached to a linear spring moves along one dimension under the restoring force of the spring. The mass is not constant and varies with time: $m(t) > 0$. The expelled mass leaves with the same instantaneous velocity as the remaining mass, so there is no thrust. There are no other forces. Use International System of Units (SI units): position in meters, mass in kilograms, time in seconds, and spring constant in newtons per meter. Time is measured in seconds.\n\nFrom first principles, the dynamics follow Newton’s second law applied to the remaining mass with the restoring force of the spring as the only force. The ejected mass leaves with no relative velocity to the mass, so the force balance is the spring force and the inertial term of the remaining mass. Use this physical model to compute the motion $x(t)$ for the following test suite, each with initial conditions and a specified mass function $m(t)$.\n\nTest suite:\n1. Constant mass (reference case):\n   - Spring constant: $k = 4\\,\\mathrm{N/m}$\n   - Mass: $m(t) = m_0$ with $m_0 = 1\\,\\mathrm{kg}$\n   - Initial conditions at $t = 0$: $x(0) = 0.1\\,\\mathrm{m}$, $v(0) = 0\\,\\mathrm{m/s}$\n   - Final time: $t_{\\mathrm{end}} = \\pi\\,\\mathrm{s}$\n2. Linearly decreasing mass:\n   - Spring constant: $k = 2\\,\\mathrm{N/m}$\n   - Mass: $m(t) = m_0 - \\beta t$ with $m_0 = 2\\,\\mathrm{kg}$ and $\\beta = 0.1\\,\\mathrm{kg/s}$\n   - Initial conditions at $t = 0$: $x(0) = 0\\,\\mathrm{m}$, $v(0) = 1.0\\,\\mathrm{m/s}$\n   - Final time: $t_{\\mathrm{end}} = 5\\,\\mathrm{s}$\n3. Exponential mass loss to a residual mass:\n   - Spring constant: $k = 10\\,\\mathrm{N/m}$\n   - Mass: $m(t) = m_{\\mathrm{res}} + (m_0 - m_{\\mathrm{res}})\\exp(-\\alpha t)$ with $m_0 = 5\\,\\mathrm{kg}$, $m_{\\mathrm{res}} = 1\\,\\mathrm{kg}$, and $\\alpha = 1\\,\\mathrm{s^{-1}}$\n   - Initial conditions at $t = 0$: $x(0) = 0.2\\,\\mathrm{m}$, $v(0) = -0.5\\,\\mathrm{m/s}$\n   - Final time: $t_{\\mathrm{end}} = 3\\,\\mathrm{s}$\n4. Rapid early mass drop (smooth and bounded below):\n   - Spring constant: $k = 3\\,\\mathrm{N/m}$\n   - Mass: $m(t) = m_{\\mathrm{res}} + (m_0 - m_{\\mathrm{res}})\\exp\\!\\left(-\\left(\\frac{t}{t_c}\\right)^2\\right)$ with $m_0 = 3\\,\\mathrm{kg}$, $m_{\\mathrm{res}} = 1.5\\,\\mathrm{kg}$, and $t_c = 0.2\\,\\mathrm{s}$\n   - Initial conditions at $t = 0$: $x(0) = 0.05\\,\\mathrm{m}$, $v(0) = 0\\,\\mathrm{m/s}$\n   - Final time: $t_{\\mathrm{end}} = 2\\,\\mathrm{s}$\n\nYour task is to write a complete, runnable program that, for each test case, computes the position $x(t_{\\mathrm{end}})$ in meters and velocity $v(t_{\\mathrm{end}})$ in meters per second. Each pair should be rounded to six decimal places.\n\nFinal output format:\n- Produce a single line of output containing a list of four lists, one per test case, in the order given above.\n- Each inner list must be of the form $[x(t_{\\mathrm{end}}), v(t_{\\mathrm{end}})]$, with both entries rounded to six decimal places, expressed in meters and meters per second, respectively.\n- For example, the format must be exactly like $[[x_1,v_1],[x_2,v_2],[x_3,v_3],[x_4,v_4]]$ where each $x_i$ and $v_i$ is a decimal number rounded to six places.\n\nAll computations and results must be in SI units. Angles do not appear in this problem. Percentages are not used in this problem. The provided test suite covers a constant-mass reference, a slow linear mass decrease, an exponential approach to a residual mass, and a rapid initial drop while remaining strictly positive. The outputs are required to be real numbers.", "solution": "The problem statement presented is subjected to rigorous validation and is determined to be valid. It is scientifically grounded, mathematically well-posed, objective, and provides a complete and consistent set of information required for a solution. The physical model, while a simplification of real-world scenarios, is clearly defined and mathematically self-consistent. Therefore, a solution will be provided.\n\nThe physical system described is a one-dimensional harmonic oscillator with a time-varying mass $m(t)$. The equation of motion is derived from Newton's second law for a system with variable mass. The total momentum of the body at time $t$ is given by $\\mathbf{p}(t) = m(t)\\mathbf{v}(t)$. According to Newton's second law, the time rate of change of the system's momentum is equal to the net external force, $\\mathbf{F}_{\\mathrm{ext}}$.\n\nThe general form of this law for a variable-mass body is $\\mathbf{F}_{\\mathrm{ext}} = \\frac{d\\mathbf{p}}{dt} = \\frac{d(m\\mathbf{v})}{dt} = m\\frac{d\\mathbf{v}}{dt} + \\frac{dm}{dt}\\mathbf{v}$. However, this form is valid only in specific reference frames and requires careful consideration of the momentum carried by the ejected mass. A more general and robust formulation is the Tsiolkovsky rocket equation: $\\mathbf{F}_{\\mathrm{ext}} + \\mathbf{u}\\frac{dm}{dt} = m\\frac{d\\mathbf{v}}{dt}$, where $\\mathbf{u}$ is the velocity of the ejected mass relative to the main body's velocity $\\mathbf{v}$.\n\nThe problem specifies that \"The expelled mass leaves with the same instantaneous velocity as the remaining mass, so there is no thrust.\" This statement implies that the velocity of the ejected mass in the inertial frame is identical to the velocity of the main body at the moment of ejection. Consequently, their relative velocity is zero, $\\mathbf{u} = 0$. Substituting this condition into the general equation yields $\\mathbf{F}_{\\mathrm{ext}} = m(t)\\frac{d\\mathbf{v}}{dt}$.\n\nThe only external force acting on the mass is the linear restoring force from the spring, which is given by Hooke's Law: $F_{x} = -kx$, where $k$ is the spring constant and $x$ is the displacement from equilibrium. Therefore, the one-dimensional equation of motion is:\n$$\nm(t)\\frac{d^2x}{dt^2} = -kx(t)\n$$\nThis can be rearranged into the standard form for a second-order linear ordinary differential equation (ODE):\n$$\n\\ddot{x}(t) + \\frac{k}{m(t)}x(t) = 0\n$$\nThis equation describes oscillations where the angular frequency, $\\omega(t) = \\sqrt{k/m(t)}$, varies with time. For the general forms of $m(t)$ provided, an analytical solution is not readily available, which necessitates a numerical approach.\n\nTo solve this ODE numerically, we first convert the second-order equation into a system of two first-order ODEs. We define a state vector $\\mathbf{y}(t)$ as:\n$$\n\\mathbf{y}(t) = \\begin{pmatrix} y_1(t) \\\\ y_2(t) \\end{pmatrix} = \\begin{pmatrix} x(t) \\\\ \\dot{x}(t) \\end{pmatrix}\n$$\nwhere $y_1$ is the position and $y_2$ is the velocity $v(t)$. The time evolution of this state vector is described by the system:\n$$\n\\frac{d\\mathbf{y}}{dt} = \\begin{pmatrix} \\dot{y_1}(t) \\\\ \\dot{y_2}(t) \\end{pmatrix} = \\begin{pmatrix} y_2(t) \\\\ -\\frac{k}{m(t)}y_1(t) \\end{pmatrix}\n$$\nEach test case constitutes an initial value problem (IVP), with the initial state $\\mathbf{y}(0) = [x(0), v(0)]^T$ being provided.\n\nThis system of ODEs is solved using a high-fidelity numerical integrator. The `solve_ivp` function from the SciPy library is an appropriate tool, as it implements robust, adaptive step-size algorithms like the Dormand-Prince (RK45) method. This choice ensures that the solution is computed with high accuracy and numerical stability. To guarantee that the numerical error is significantly smaller than the required output precision of six decimal places, strict relative and absolute error tolerances ($rtol=10^{-9}$ and $atol=10^{-12}$, respectively) are specified for the solver.\n\nThe computational procedure is as follows:\n1. For each of the four test cases, the corresponding parameters ($k$), mass function ($m(t)$), initial conditions ($x_0$, $v_0$), and final time ($t_{\\mathrm{end}}$) are defined.\n2. The function representing the right-hand side of the ODE system, $\\mathbf{f}(t, \\mathbf{y})$, is implemented.\n3. The `solve_ivp` function is called to integrate the system over the time interval $[0, t_{\\mathrm{end}}]$, starting from the initial state $\\mathbf{y}(0)$.\n4. The solver is configured to return the state vector only at the final time $t_{\\mathrm{end}}$.\n5. The resulting position $x(t_{\\mathrm{end}})$ and velocity $v(t_{\\mathrm{end}})$ are extracted from the solution.\n6. These two values are rounded to six decimal places as specified in the problem statement.\n7. The process is repeated for all test cases, and the final results are aggregated and formatted into the required string representation of a list of lists.\n\nFor the first test case (constant mass), the equation simplifies to the standard simple harmonic oscillator, $\\ddot{x} + \\omega^2 x = 0$, with $\\omega = \\sqrt{k/m} = \\sqrt{4/1} = 2\\,\\mathrm{rad/s}$. The analytical solution for the given initial conditions ($x(0)=0.1$, $v(0)=0$) is $x(t) = 0.1\\cos(2t)$. At $t_{\\mathrm{end}}=\\pi$, the exact solution is $x(\\pi) = 0.1 \\cos(2\\pi) = 0.1$ and $v(\\pi) = -0.2 \\sin(2\\pi) = 0$. This known result serves as a crucial benchmark to verify the correctness of the numerical implementation.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes the final position and velocity for a simple harmonic oscillator\n    with time-varying mass for four different test cases.\n    \"\"\"\n    # Define test cases using a list of dictionaries for clarity.\n    # Each dictionary contains all parameters for a single simulation.\n    test_cases = [\n        # 1. Constant mass (reference case)\n        {\n            \"k\": 4.0,\n            \"mass_func\": lambda t: 1.0,\n            \"ic\": [0.1, 0.0],\n            \"t_end\": np.pi,\n        },\n        # 2. Linearly decreasing mass\n        {\n            \"k\": 2.0,\n            \"mass_func\": lambda t: 2.0 - 0.1 * t,\n            \"ic\": [0.0, 1.0],\n            \"t_end\": 5.0,\n        },\n        # 3. Exponential mass loss to a residual mass\n        {\n            \"k\": 10.0,\n            \"mass_func\": lambda t: 1.0 + (5.0 - 1.0) * np.exp(-1.0 * t),\n            \"ic\": [0.2, -0.5],\n            \"t_end\": 3.0,\n        },\n        # 4. Rapid early mass drop\n        {\n            \"k\": 3.0,\n            \"mass_func\": lambda t: 1.5 + (3.0 - 1.5) * np.exp(-(t / 0.2)**2),\n            \"ic\": [0.05, 0.0],\n            \"t_end\": 2.0,\n        }\n    ]\n\n    all_results = []\n\n    # Iterate through each test case and solve the ODE\n    for case in test_cases:\n        k = case[\"k\"]\n        mass_func = case[\"mass_func\"]\n        ic = case[\"ic\"]\n        t_span = (0.0, case[\"t_end\"])\n\n        # Define the system of first-order ODEs: y' = f(t, y)\n        # where y = [x, v] is the state vector [position, velocity].\n        def system_rhs(t, y):\n            x, v = y\n            m_t = mass_func(t)\n            # The equation of motion is m(t)*x'' + k*x = 0\n            # So, x'' = dv/dt = -(k/m(t)) * x\n            dxdt = v\n            dvdt = -(k / m_t) * x\n            return [dxdt, dvdt]\n\n        # Use solve_ivp for numerical integration.\n        # RK45 is the default adaptive method (Dormand-Prince).\n        # Tighter tolerances are used for higher accuracy to ensure the\n        # six-decimal-place requirement is met reliably.\n        sol = solve_ivp(\n            system_rhs,\n            t_span,\n            ic,\n            method='RK45',\n            t_eval=[case[\"t_end\"]], # We only need the solution at the final time\n            rtol=1e-9,\n            atol=1e-12\n        )\n\n        # The solution 'sol.y' is a 2x1 array containing [x_final, v_final]\n        final_state = sol.y[:, -1]\n        \n        # Round the results to six decimal places as specified.\n        x_final = round(final_state[0], 6)\n        v_final = round(final_state[1], 6)\n        \n        # Python's round() can produce -0.0, which we normalize to 0.0 for consistency.\n        if x_final == -0.0:\n            x_final = 0.0\n        if v_final == -0.0:\n            v_final = 0.0\n            \n        all_results.append([x_final, v_final])\n\n    # Format the final output string exactly as required: [[x1,v1],[x2,v2],...]\n    # This construction ensures no spaces are included, matching the format.\n    inner_strs = [f\"[{x},{v}]\" for x, v in all_results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2420164"}, {"introduction": "In our next exercise, we explore the simple harmonic oscillator from the perspective of an accelerating, non-inertial reference frame. This introduces a 'fictitious' inertial force, transforming the problem into a forced harmonic oscillator, $m\\ddot{x} + kx = -m a_{\\mathrm{F}}(t)$. This practice [@problem_id:2420174] requires you to implement the Velocity Verlet algorithm, a powerful symplectic integrator prized for its excellent long-term energy conservation properties. By completing the varied test cases, you will gain hands-on experience with a workhorse algorithm of molecular dynamics and astrophysics and learn to quantify simulation results through physically meaningful diagnostics.", "problem": "Consider a one-dimensional mass–spring system observed from a uniformly translating reference point whose origin undergoes a prescribed time-dependent acceleration. Let $x_{\\mathrm{I}}(t)$ denote the inertial coordinate of the mass, and let $X_{\\mathrm{F}}(t)$ denote the inertial coordinate of the accelerating frame’s origin with frame acceleration $a_{\\mathrm{F}}(t)=d^{2}X_{\\mathrm{F}}/dt^{2}$. Define the frame-relative coordinate $x(t)=x_{\\mathrm{I}}(t)-X_{\\mathrm{F}}(t)$. The mass has mass $m$ and is attached to a linear spring of stiffness $k$ whose other end is rigidly anchored to the accelerating frame’s origin, so that the spring force in the frame is proportional to $-x(t)$. Using Newton’s Second Law and the definition of $x(t)$, the equation of motion in the accelerating frame is a forced simple harmonic oscillator of the form\n$$\nm\\,\\frac{d^{2}x}{dt^{2}} + k\\,x = -\\,m\\,a_{\\mathrm{F}}(t).\n$$\nAngles must be in $\\mathrm{rad}$, time in $\\mathrm{s}$, masses in $\\mathrm{kg}$, distances in $\\mathrm{m}$, accelerations in $\\mathrm{m/s^{2}}$, and stiffness in $\\mathrm{N/m}$.\n\nTask. Write a complete, runnable program that:\n- Integrates the equation of motion numerically using a second-order, time-reversible symplectic method (the velocity Verlet scheme) for the four test cases specified below.\n- For each test case, computes a single scalar diagnostic as defined below, using only the simulated trajectory. Unless otherwise stated, use the last $20\\%$ of the simulated time interval as the “end window” over which time-averaged quantities are evaluated to approximate steady behavior. Interpret “time average” as the discrete average over the sampled time points in the window.\n\nNumerical integration requirements:\n- Use the velocity Verlet method with a fixed time step $\\Delta t$:\n  1. Given $x_{n}$, $v_{n}$, $a_{n}$ at time $t_{n}$, update position\n  $$\n  x_{n+1} = x_{n} + v_{n}\\,\\Delta t + \\tfrac{1}{2}a_{n}\\,\\Delta t^{2}.\n  $$\n  2. Compute acceleration at the new step as\n  $$\n  a_{n+1} = -\\frac{k}{m}\\,x_{n+1} - a_{\\mathrm{F}}(t_{n+1}).\n  $$\n  3. Update velocity\n  $$\n  v_{n+1} = v_{n} + \\tfrac{1}{2}\\,(a_{n}+a_{n+1})\\,\\Delta t.\n  $$\n- Initialize $a_{0}=-\\frac{k}{m}\\,x_{0}-a_{\\mathrm{F}}(0)$.\n- The total number of time steps is $N=\\lfloor T/\\Delta t \\rfloor$ and the simulation runs from $t=0$ to $t=N\\,\\Delta t \\approx T$.\n\nDiagnostics to compute:\n- For “time average” of position on the end window, compute $\\overline{x}_{\\mathrm{end}} = \\frac{1}{M}\\sum_{j} x_{j}$ over the last $M$ samples.\n- For “oscillation amplitude” on the end window, compute the half peak-to-peak amplitude $A_{\\mathrm{pp}} = \\tfrac{1}{2}\\left(\\max x_{j} - \\min x_{j}\\right)$ over that window.\n- For “relative energy drift,” define the mechanical energy in the frame as $E(t)=\\tfrac{1}{2}m v^{2}(t)+\\tfrac{1}{2}k x^{2}(t)$ and report the absolute relative change between the final and initial energies, i.e., $\\left|E(T)-E(0)\\right|/E(0)$, expressed as a pure number (decimal, no unit).\n- For “frequency-response amplitude” at a known drive frequency $\\Omega$, use the end window data $\\{(t_{j},x_{j})\\}$ to compute the projections\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\sin(\\Omega t_{j})\\,\\Delta t,\\quad\nB = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\cos(\\Omega t_{j})\\,\\Delta t,\n$$\nwhere $T_{\\mathrm{w}}$ is the duration of the end window, and report $\\sqrt{A^{2}+B^{2}}$.\n\nTest suite. Run the following four cases. In all cases, use initial conditions $x(0)=x_{0}$ and $v(0)=v_{0}$ and piecewise-smooth $a_{\\mathrm{F}}(t)$ as specified:\n\n- Case $1$ (constant-acceleration frame; steady offset). Parameters: $m=1\\,\\mathrm{kg}$, $k=4\\,\\mathrm{N/m}$, $a_{\\mathrm{F}}(t)=a_{0}$ with $a_{0}=1\\,\\mathrm{m/s^{2}}$, $x_{0}=0\\,\\mathrm{m}$, $v_{0}=0\\,\\mathrm{m/s}$, $T=20\\,\\mathrm{s}$, $\\Delta t=0.005\\,\\mathrm{s}$. Diagnostic to output: $\\overline{x}_{\\mathrm{end}}$ in $\\mathrm{m}$.\n- Case $2$ (inertial frame; energy check). Parameters: $m=1\\,\\mathrm{kg}$, $k=9\\,\\mathrm{N/m}$, $a_{\\mathrm{F}}(t)=0\\,\\mathrm{m/s^{2}}$, $x_{0}=0.1\\,\\mathrm{m}$, $v_{0}=0\\,\\mathrm{m/s}$, $T=20\\,\\mathrm{s}$, $\\Delta t=0.005\\,\\mathrm{s}$. Diagnostic to output: $\\left|E(T)-E(0)\\right|/E(0)$ as a decimal (no unit).\n- Case $3$ (step-acceleration frame; oscillation about shifted equilibrium). Parameters: $m=1\\,\\mathrm{kg}$, $k=4\\,\\mathrm{N/m}$, $a_{\\mathrm{F}}(t)=a_{0}\\,H(t)$ with $a_{0}=1\\,\\mathrm{m/s^{2}}$ and $H(t)$ the Heaviside step function satisfying $H(t)=0$ for $t<0$ and $H(t)=1$ for $t\\ge 0$, $x_{0}=0\\,\\mathrm{m}$, $v_{0}=0\\,\\mathrm{m/s}$, $T=20\\,\\mathrm{s}$, $\\Delta t=0.005\\,\\mathrm{s}$. Diagnostic to output: $A_{\\mathrm{pp}}$ in $\\mathrm{m}$ computed on the end window.\n- Case $4$ (sinusoidally accelerating frame; off-resonant response). Parameters: $m=1\\,\\mathrm{kg}$, $k=4\\,\\mathrm{N/m}$, $a_{\\mathrm{F}}(t)=A\\,\\sin(\\Omega t)$ with $A=1\\,\\mathrm{m/s^{2}}$ and $\\Omega=1.5\\,\\mathrm{rad/s}$, $x_{0}=0\\,\\mathrm{m}$, $v_{0}=0\\,\\mathrm{m/s}$, $T=60\\,\\mathrm{s}$, $\\Delta t=0.005\\,\\mathrm{s}$. Diagnostic to output: the frequency-response amplitude $\\sqrt{A^{2}+B^{2}}$ in $\\mathrm{m}$ computed at the known drive frequency $\\Omega$ using the end window.\n\nFinal output format. Your program should produce a single line of output containing the four results, in the order of Cases $1$ through $4$, as a comma-separated list enclosed in square brackets, for example, $[\\overline{x}_{\\mathrm{end}},\\,\\text{drift},\\,A_{\\mathrm{pp}},\\,\\text{amp}]$. Express the first, third, and fourth results in $\\mathrm{m}$ and the second as a pure decimal (no unit). Format each number to exactly $6$ digits after the decimal point.", "solution": "The problem presented is a well-posed initial value problem in classical mechanics, specifically concerning the dynamics of a forced simple harmonic oscillator. The problem is scientifically sound, with all parameters, equations, initial conditions, and numerical procedures explicitly and unambiguously defined. The specified task is to perform a numerical integration using the velocity Verlet method and compute specific diagnostics for four distinct physical scenarios. The problem is valid and a complete solution can be constructed.\n\nThe governing equation of motion for the mass's position $x(t)$ relative to the accelerating frame is given by Newton's second law, which includes an inertial force term:\n$$\nm\\,\\frac{d^{2}x}{dt^{2}} + k\\,x = -m\\,a_{\\mathrm{F}}(t)\n$$\nThis can be rewritten as a standard second-order ordinary differential equation (ODE) for the acceleration, $a(t) = d^2x/dt^2$:\n$$\na(t) = -\\frac{k}{m}\\,x(t) - a_{\\mathrm{F}}(t)\n$$\nThis ODE must be solved numerically, starting from the initial conditions $x(0) = x_0$ and $v(0) = v_0$, where $v(t) = dx/dt$.\n\nThe core of the solution is the numerical integration of this equation of motion. The problem mandates the use of the velocity Verlet algorithm, a second-order, time-reversible, and symplectic integrator. Symplectic integrators are particularly well-suited for Hamiltonian systems, such as conservative mechanical systems, because they do not exhibit secular energy drift over long integration times. Instead, the error in the total energy remains bounded. This property is explicitly tested in Case 2.\n\nThe velocity Verlet algorithm proceeds in discrete time steps of size $\\Delta t$. Given the state $(x_n, v_n, a_n)$ at time $t_n$, the state at the next time step $t_{n+1} = t_n + \\Delta t$ is computed as follows:\n1.  First, the position is updated to the full next time step using the current velocity and acceleration:\n    $$\n    x_{n+1} = x_{n} + v_{n}\\,\\Delta t + \\frac{1}{2}a_{n}\\,\\Delta t^{2}\n    $$\n2.  Next, the acceleration $a_{n+1}$ is computed at the new position $x_{n+1}$ and new time $t_{n+1}$:\n    $$\n    a_{n+1} = -\\frac{k}{m}\\,x_{n+1} - a_{\\mathrm{F}}(t_{n+1})\n    $$\n3.  Finally, the velocity is updated using the average of the old and new accelerations, which makes the method time-symmetric and ensures its second-order accuracy:\n    $$\n    v_{n+1} = v_{n} + \\frac{1}{2}\\,(a_{n}+a_{n+1})\\,\\Delta t\n    $$\nThe simulation is initialized at $t_0=0$ with $x_0$, $v_0$, and an initial acceleration $a_0 = -\\frac{k}{m}x_0 - a_{\\mathrm{F}}(0)$. The process is repeated for $N = \\lfloor T/\\Delta t \\rfloor$ steps, generating a time series of position $x_j$, velocity $v_j$, and time $t_j$ for $j=0, 1, \\dots, N$.\n\nThe overall algorithm to obtain the final results is as follows:\n1.  For each of the four test cases, define the specific parameters ($m, k, T, \\Delta t$), initial conditions ($x_0, v_0$), and the time-dependent frame acceleration function $a_{\\mathrm{F}}(t)$.\n2.  Implement a general-purpose simulation function that executes the velocity Verlet integration loop as described above, storing the time, position, and velocity at each step.\n3.  Execute this simulation for each test case to generate the trajectory data $(t_j, x_j, v_j)$.\n4.  For each case, apply the specified diagnostic calculation to the generated trajectory. The \"end window\" for time-averaging diagnostics refers to the final $20\\%$ of the data points, corresponding to the time interval $[0.8T, T]$.\n\nThe specific diagnostics are calculated as:\n-   **Case 1: Time-averaged position $\\overline{x}_{\\mathrm{end}}$**. This is the arithmetic mean of the position values $x_j$ within the end window. It measures the steady-state equilibrium position. Analytically, for a constant force, the equilibrium is at $x_{\\mathrm{eq}} = -m a_0 / k = -(1\\,\\mathrm{kg})(1\\,\\mathrm{m/s^2}) / (4\\,\\mathrm{N/m}) = -0.25\\,\\mathrm{m}$.\n-   **Case 2: Relative energy drift**. The mechanical energy in the frame is $E(t) = \\frac{1}{2}mv^2(t) + \\frac{1}{2}kx^2(t)$. The drift is $|E(t_N) - E(t_0)|/E(t_0)$. For this case, $a_{\\mathrm{F}}(t)=0$, so the system is conservative, and this diagnostic measures the numerical integrator's ability to conserve energy.\n-   **Case 3: Oscillation amplitude $A_{\\mathrm{pp}}$**. This is half the difference between the maximum and minimum position values within the end window. The system starts from rest at the origin and is subjected to a constant force, causing it to oscillate about the new equilibrium point. The analytical amplitude of this oscillation is $|x_0 - x_{\\mathrm{eq}}| = |0 - (-0.25\\,\\mathrm{m})| = 0.25\\,\\mathrm{m}$.\n-   **Case 4: Frequency-response amplitude**. The trajectory data in the end window is projected onto sinusoidal basis functions at the driving frequency $\\Omega$ to find the amplitude of the steady-state response. The sums $A = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\sin(\\Omega t_{j})\\,\\Delta t$ and $B = \\frac{2}{T_{\\mathrm{w}}}\\sum_{j} x_{j}\\,\\cos(\\Omega t_{j})\\,\\Delta t$ are discrete approximations of the Fourier coefficients. The amplitude is $\\sqrt{A^2+B^2}$. The theoretical steady-state amplitude is $A_{\\mathrm{theory}}=|A_{\\mathrm{forcing}}|/|\\omega_0^2-\\Omega^2|$, where $\\omega_0=\\sqrt{k/m}$ and $A_{\\mathrm{forcing}}$ is the amplitude of the acceleration term. For this case, $A_{\\mathrm{theory}} = (1\\,\\mathrm{m/s^2}) / |(2\\,\\mathrm{rad/s})^2 - (1.5\\,\\mathrm{rad/s})^2| = 1/1.75 \\approx 0.571428\\,\\mathrm{m}$.\n\nThe final implementation will encapsulate these steps in a single Python script.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the four test cases for a forced simple harmonic oscillator\n    using the velocity Verlet method and computes specified diagnostics.\n    \"\"\"\n\n    def run_simulation(m, k, a_F_func, x0, v0, T, dt):\n        \"\"\"\n        Integrates the equation of motion using the velocity Verlet scheme.\n        \n        Equation: m*d^2x/dt^2 + k*x = -m*a_F(t)\n                  a(t) = -(k/m)*x(t) - a_F(t)\n        \n        Args:\n            m (float): Mass in kg.\n            k (float): Spring stiffness in N/m.\n            a_F_func (callable): Frame acceleration function a_F(t) in m/s^2.\n            x0 (float): Initial position in m.\n            v0 (float): Initial velocity in m/s.\n            T (float): Total simulation time in s.\n            dt (float): Time step in s.\n\n        Returns:\n            tuple: (t, x, v) arrays for time, position, and velocity.\n        \"\"\"\n        N = int(T / dt)\n        \n        t = np.linspace(0, N * dt, N + 1)\n        x = np.zeros(N + 1)\n        v = np.zeros(N + 1)\n        a = np.zeros(N + 1)\n\n        # Initial conditions\n        x[0] = x0\n        v[0] = v0\n        a[0] = -(k / m) * x[0] - a_F_func(t[0])\n\n        # Velocity Verlet integration loop\n        for n in range(N):\n            # 1. Update position\n            x[n+1] = x[n] + v[n] * dt + 0.5 * a[n] * dt**2\n            \n            # 2. Compute acceleration at the new step\n            a[n+1] = -(k / m) * x[n+1] - a_F_func(t[n+1])\n            \n            # 3. Update velocity\n            v[n+1] = v[n] + 0.5 * (a[n] + a[n+1]) * dt\n            \n        return t, x, v\n\n    # --- Test Cases ---\n\n    results = []\n\n    # Case 1: Constant-acceleration frame; steady offset\n    params1 = {'m': 1.0, 'k': 4.0, 'a_F_func': lambda t: 1.0, \n               'x0': 0.0, 'v0': 0.0, 'T': 20.0, 'dt': 0.005}\n    t1, x1, v1 = run_simulation(**params1)\n    N1 = int(params1['T'] / params1['dt'])\n    start_index1 = int(0.8 * N1)\n    x1_end = x1[start_index1:]\n    x_bar_end = np.mean(x1_end)\n    results.append(x_bar_end)\n\n    # Case 2: Inertial frame; energy check\n    params2 = {'m': 1.0, 'k': 9.0, 'a_F_func': lambda t: 0.0, \n               'x0': 0.1, 'v0': 0.0, 'T': 20.0, 'dt': 0.005}\n    t2, x2, v2 = run_simulation(**params2)\n    m2, k2 = params2['m'], params2['k']\n    E = 0.5 * m2 * v2**2 + 0.5 * k2 * x2**2\n    E0 = E[0]\n    Ef = E[-1]\n    if E0 == 0:\n        rel_energy_drift = 0.0\n    else:\n        rel_energy_drift = np.abs(Ef - E0) / E0\n    results.append(rel_energy_drift)\n    \n    # Case 3: Step-acceleration frame; oscillation about shifted equilibrium\n    params3 = {'m': 1.0, 'k': 4.0, 'a_F_func': lambda t: 1.0, # H(t)=1 for t>=0\n               'x0': 0.0, 'v0': 0.0, 'T': 20.0, 'dt': 0.005}\n    t3, x3, v3 = run_simulation(**params3)\n    N3 = int(params3['T'] / params3['dt'])\n    start_index3 = int(0.8 * N3)\n    x3_end = x3[start_index3:]\n    A_pp = 0.5 * (np.max(x3_end) - np.min(x3_end))\n    results.append(A_pp)\n\n    # Case 4: Sinusoidally accelerating frame; off-resonant response\n    A_force = 1.0\n    Omega = 1.5\n    params4 = {'m': 1.0, 'k': 4.0, 'a_F_func': lambda t: A_force * np.sin(Omega * t), \n               'x0': 0.0, 'v0': 0.0, 'T': 60.0, 'dt': 0.005}\n    t4, x4, v4 = run_simulation(**params4)\n    N4 = int(params4['T'] / params4['dt'])\n    start_index4 = int(0.8 * N4)\n    \n    t4_end = t4[start_index4:]\n    x4_end = x4[start_index4:]\n    \n    Tw = params4['T'] * 0.2\n    dt4 = params4['dt']\n\n    # Projections\n    A_proj_sum_term = x4_end * np.sin(Omega * t4_end)\n    B_proj_sum_term = x4_end * np.cos(Omega * t4_end)\n    \n    A_proj = (2.0 / Tw) * np.sum(A_proj_sum_term) * dt4\n    B_proj = (2.0 / Tw) * np.sum(B_proj_sum_term) * dt4\n    \n    freq_response_amp = np.sqrt(A_proj**2 + B_proj**2)\n    results.append(freq_response_amp)\n\n\n    # Final print statement in the exact required format.\n    # Format each number to exactly 6 digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2420174"}, {"introduction": "Our final practice delves into one of the most critical aspects of a numerical simulation: stability. We will investigate a seemingly plausible but fundamentally flawed integration scheme for the undamped oscillator, which can cause the numerical energy to grow explosively. This problem [@problem_id:2439910] provides a practical lesson in analyzing numerical stability by calculating the spectral radius, $\\rho(G)$, of the system's amplification matrix. You will discover firsthand how an unstable scheme behaves and explore the counterintuitive idea of adding an 'unphysical' modeling term (damping) to mitigate a purely numerical (discretization) error.", "problem": "A one-dimensional mass-spring system that is physically undamped is governed by the second-order Ordinary Differential Equation (ODE) $m \\ddot{x}(t) + k x(t) = 0$, where $m$ is the mass and $k$ is the spring constant. Consider the first-order form with state $(x,v)$ where $x$ is displacement and $v$ is velocity:\n- $x'(t) = v(t)$,\n- $v'(t) = -\\frac{k}{m} x(t)$.\n\nThe numerical scheme under investigation updates the state in discrete time using a linear one-step map that includes an unphysical viscous term of magnitude $\\gamma \\ge 0$:\n- $x_{n+1} = x_{n} + h\\, v_{n}$,\n- $v_{n+1} = v_{n} + h\\left(-\\frac{k}{m} x_{n} - \\frac{\\gamma}{m} v_{n}\\right)$,\nwhere $h$ is the time step. This update can be written as a matrix multiplication $\\begin{bmatrix}x_{n+1} \\\\ v_{n+1}\\end{bmatrix} = G \\begin{bmatrix}x_n \\\\ v_n\\end{bmatrix}$ with\n$$\nG = \\begin{bmatrix}\n1 & h\\\\\n- h\\,\\omega_0^2 & 1 - h\\,\\frac{\\gamma}{m}\n\\end{bmatrix}, \\quad \\omega_0 = \\sqrt{\\frac{k}{m}}.\n$$\nDefine the spectral radius $\\rho(G)$ as the maximum modulus of the eigenvalues of $G$. Define the discrete mechanical energy at step $n$ as\n$$\nE_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2.\n$$\nThe true undamped system ($\\gamma = 0$ in the continuum ODE) conserves energy, so $E_{\\text{true}}(T) = E_0$ for any physical time $T$. To quantify the combined modeling and discretization error introduced by the unphysical damping and time-stepping, define the relative energy error at the final time $T$ as\n$$\n\\varepsilon = \\frac{E_N - E_0}{E_0}, \\quad N = \\frac{T}{h},\n$$\nwhere $N$ is an integer number of steps.\n\nYour program must, for each test case below, compute:\n- the spectral radius $\\rho(G)$,\n- a stability flag $s$ equal to $1$ if $\\rho(G) < 1$ and equal to $0$ otherwise,\n- the relative energy error $\\varepsilon$ at time $T$ obtained by iterating the given update for exactly $N$ steps from the initial condition $x(0) = 1.0$ and $v(0) = 0.0$.\n\nAll parameters have the following physical units: $m$ in kilograms, $k$ in newtons per meter, $\\gamma$ in kilogram per second, $h$ and $T$ in seconds. The outputs $\\rho(G)$ and $\\varepsilon$ are dimensionless.\n\nUse the following test suite, where each case specifies $(m,k,\\gamma,h,T)$:\n- Case $1$: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $0$ $,$ $0.1$ $,$ $10$ $\\,)$.\n- Case $2$: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $0.2$ $,$ $0.1$ $,$ $10$ $\\,)$.\n- Case $3$: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $0$ $,$ $1.0$ $,$ $10$ $\\,)$.\n- Case $4$: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $1.5$ $,$ $1.0$ $,$ $10$ $\\,)$.\n- Case $5$: $(m,k,\\gamma,h,T) = (\\,$ $1$ $,$ $1$ $,$ $1.0$ $,$ $1.0$ $,$ $10$ $\\,)$.\n\nFinal output format:\n- For each case, output a list $[\\rho, s, \\varepsilon]$ where $\\rho$ and $\\varepsilon$ are rounded to $6$ decimal places, and $s$ is an integer $0$ or $1$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with one sublist per case in the same order as above. For example: $[\\,[\\rho_1,s_1,\\varepsilon_1],[\\rho_2,s_2,\\varepsilon_2],\\dots\\,]$.", "solution": "The problem statement has been validated and is deemed to be scientifically grounded, well-posed, and objective. It presents a standard exercise in computational physics concerning the analysis of a numerical integration scheme for a simple harmonic oscillator. The problem is self-contained, with all necessary parameters, initial conditions, and definitions provided. There are no contradictions, ambiguities, or factual inaccuracies. We may therefore proceed with a solution.\n\nThe task is to compute three quantities for each given parameter set $(m, k, \\gamma, h, T)$: the spectral radius $\\rho(G)$ of the amplification matrix $G$, a stability flag $s$, and the relative energy error $\\varepsilon$ after a simulation of duration $T$.\n\nFirst, we address the calculation of the spectral radius, $\\rho(G)$, and the stability flag, $s$. The numerical scheme is given as a linear one-step map:\n$$\n\\begin{bmatrix}x_{n+1} \\\\ v_{n+1}\\end{bmatrix} = G \\begin{bmatrix}x_n \\\\ v_n\\end{bmatrix}\n$$\nwhere $G$ is the amplification matrix, defined as:\n$$\nG = \\begin{bmatrix}\n1 & h\\\\\n- h\\,\\omega_0^2 & 1 - h\\,\\frac{\\gamma}{m}\n\\end{bmatrix}, \\quad \\omega_0 = \\sqrt{\\frac{k}{m}}\n$$\nThe stability of this linear iterative process is determined by the eigenvalues of $G$. The system is asymptotically stable if and only if the spectral radius, $\\rho(G)$, is strictly less than $1$. The spectral radius is defined as the maximum of the absolute values (moduli) of the eigenvalues of $G$:\n$$\n\\rho(G) = \\max_i |\\lambda_i|\n$$\nwhere $\\lambda_i$ are the solutions to the characteristic equation $\\det(G - \\lambda I) = 0$. This equation is:\n$$\n\\lambda^2 - \\text{Tr}(G)\\lambda + \\det(G) = 0\n$$\nwhere the trace $\\text{Tr}(G) = 2 - h\\frac{\\gamma}{m}$ and the determinant $\\det(G) = 1 - h\\frac{\\gamma}{m} + h^2\\omega_0^2$. The eigenvalues are then found using the quadratic formula. For each test case, we construct the matrix $G$ and compute its eigenvalues numerically. The spectral radius $\\rho(G)$ is then determined. The stability flag $s$ is assigned based on this value:\n$$\ns = \\begin{cases} 1 & \\text{if } \\rho(G) < 1 \\\\ 0 & \\text{if } \\rho(G) \\ge 1 \\end{cases}\n$$\n\nNext, we compute the relative energy error, $\\varepsilon$. The discrete mechanical energy at step $n$ is defined as $E_n = \\frac{1}{2} m v_n^2 + \\frac{1}{2} k x_n^2$. The initial state is given as $(x_0, v_0) = (1.0, 0.0)$, so the initial energy is:\n$$\nE_0 = \\frac{1}{2} m (0.0)^2 + \\frac{1}{2} k (1.0)^2 = \\frac{1}{2} k\n$$\nThe simulation runs for a total time $T$ with a time step $h$, which corresponds to $N = T/h$ steps. Since the update rule is a linear map, the state at the final step $N$ is given by:\n$$\n\\begin{bmatrix}x_{N} \\\\ v_{N}\\end{bmatrix} = G^N \\begin{bmatrix}x_0 \\\\ v_0\\end{bmatrix}\n$$\nwhere $G^N$ is the matrix $G$ raised to the power of $N$. This provides an efficient method to find the final state $(x_N, v_N)$ without performing an explicit loop for $N$ iterations. After computing the final state, the final energy $E_N$ is calculated as:\n$$\nE_N = \\frac{1}{2} m v_N^2 + \\frac{1}{2} k x_N^2\n$$\nThe relative energy error $\\varepsilon$ quantifies the deviation from the true system's energy conservation principle and is calculated as:\n$$\n\\varepsilon = \\frac{E_N - E_0}{E_0}\n$$\nThis quantity captures the combined effect of the discretization error from the Forward Euler scheme and the modeling error from the artificial damping term $\\gamma$.\n\nThe overall procedure for each test case is to first construct $G$, compute its eigenvalues to find $\\rho(G)$ and $s$, then compute $G^N$ to find the final state $(x_N,v_N)$, and finally calculate the energies $E_N$ and $E_0$ to determine $\\varepsilon$. The requested outputs are then collected and formatted.", "answer": "```python\n# Full and runnable Python 3 code.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases.\n    For each case, it computes the spectral radius rho(G), a stability flag s,\n    and the relative energy error epsilon.\n    \"\"\"\n    test_cases = [\n        # (m, k, gamma, h, T)\n        (1.0, 1.0, 0.0, 0.1, 10.0),\n        (1.0, 1.0, 0.2, 0.1, 10.0),\n        (1.0, 1.0, 0.0, 1.0, 10.0),\n        (1.0, 1.0, 1.5, 1.0, 10.0),\n        (1.0, 1.0, 1.0, 1.0, 10.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, k, gamma, h, T = case\n        \n        # 1. Compute spectral radius and stability flag\n        omega0_sq = k / m\n        G = np.array([\n            [1.0, h],\n            [-h * omega0_sq, 1.0 - h * gamma / m]\n        ], dtype=np.float64)\n        \n        eigenvalues = np.linalg.eigvals(G)\n        rho = np.max(np.abs(eigenvalues))\n        s = 1 if rho < 1.0 else 0\n        \n        # 2. Compute relative energy error\n        x0 = 1.0\n        v0 = 0.0\n        \n        E0 = 0.5 * m * v0**2 + 0.5 * k * x0**2\n        \n        # Ensure N is an integer, handling potential float inaccuracies\n        N = int(round(T / h))\n        \n        state_initial = np.array([x0, v0], dtype=np.float64)\n\n        if N == 0:\n            state_final = state_initial\n        else:\n            # Efficiently compute G^N * state_initial\n            G_N = np.linalg.matrix_power(G, N)\n            state_final = G_N @ state_initial\n        \n        xN, vN = state_final[0], state_final[1]\n        \n        EN = 0.5 * m * vN**2 + 0.5 * k * xN**2\n        \n        # Avoid division by zero if E0 is 0\n        if E0 == 0:\n            eps = 0.0 if EN == 0 else float('inf')\n        else:\n            eps = (EN - E0) / E0\n            \n        # 3. Format results as specified\n        rho_rounded = round(rho, 6)\n        eps_rounded = round(eps, 6)\n        \n        results.append(f\"[{rho_rounded},{s},{eps_rounded}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2439910"}]}