{"hands_on_practices": [{"introduction": "The first step in mastering the shooting method is to understand the direct relationship between your initial guess—the \"shot\"—and where it \"lands\" at the other boundary. This exercise guides you through analytically solving a simple Initial Value Problem (IVP) to create a function, $y(1;s_g)$, that explicitly maps the initial slope guess, $s_g$, to the solution's value at the end of the interval. By studying this function, you will gain insight into how the shooting method works and appreciate one of its key numerical challenges: sensitivity to the initial guess.", "problem": "Consider a Boundary Value Problem (BVP), which is a differential equation with conditions specified at the boundaries of its domain. The specific BVP is defined by the second-order ordinary differential equation $y'' - k^2 y = 0$ on the domain $x \\in [0, 1]$, with boundary conditions $y(0) = 1$ and $y(1) = 1$. The parameter $k$ is a positive real constant.\n\nThe shooting method is a numerical technique to solve this BVP. It works by converting the BVP into an Initial Value Problem (IVP). An initial slope, $s_g = y'(0)$, is guessed. Then, the IVP consisting of the differential equation $y'' - k^2 y = 0$ and the initial conditions $y(0)=1$ and $y'(0)=s_g$ is solved to find the value of the solution at $x=1$. This value is compared to the desired boundary condition $y(1)=1$, and the guess $s_g$ is adjusted in an iterative process. For large values of $k$, this method becomes highly sensitive to the initial guess $s_g$.\n\nTo understand this sensitivity analytically, let $y(x; s_g)$ denote the solution to the IVP for a given initial slope guess $s_g$. Find a closed-form analytic expression for the value of this solution at the right boundary, $y(1; s_g)$. Your answer should be in terms of $k$, $s_g$, and hyperbolic functions.", "solution": "We solve the linear homogeneous ODE with constant coefficients $y''-k^{2}y=0$. The characteristic equation is $r^{2}-k^{2}=0$, giving roots $r=\\pm k$. A convenient real basis of solutions is $\\cosh(kx)$ and $\\sinh(kx)$, so the general solution is\n$$\ny(x)=C\\cosh(kx)+D\\sinh(kx).\n$$\nImposing the initial condition $y(0)=1$ gives\n$$\ny(0)=C\\cosh(0)+D\\sinh(0)=C=1,\n$$\nso $C=1$. Differentiating yields\n$$\ny'(x)=kD\\cosh(kx)+kC\\sinh(kx).\n$$\nUsing $y'(0)=s_{g}$ gives\n$$\ny'(0)=kD\\cosh(0)+kC\\sinh(0)=kD=s_{g},\n$$\nso $D=\\frac{s_{g}}{k}$. Therefore the IVP solution is\n$$\ny(x;s_{g})=\\cosh(kx)+\\frac{s_{g}}{k}\\sinh(kx).\n$$\nEvaluating at the right boundary $x=1$ gives\n$$\ny(1;s_{g})=\\cosh(k)+\\frac{s_{g}}{k}\\sinh(k).\n$$\nThis is the required closed-form expression in terms of $k$, $s_{g}$, and hyperbolic functions.", "answer": "$$\\boxed{\\cosh(k)+\\frac{s_{g}}{k}\\sinh(k)}$$", "id": "2209816"}, {"introduction": "Having established the function that connects our initial guess to the boundary outcome, the next logical step is to systematically correct our guess. This practice moves from analysis to algorithm, demonstrating how to apply a root-finding method—in this case, the secant method—to iteratively refine the initial slope. By using the function you conceptually explored in the previous practice, you will perform a concrete step in \"zeroing in\" on the correct initial conditions that solve the full Boundary Value Problem (BVP).", "problem": "A one-dimensional fin of length $L=2.0$ m is attached to a hot surface to dissipate heat into the surrounding environment. The steady-state temperature profile along the fin, $T(x)$, is governed by the second-order ordinary differential equation:\n$$ T''(x) = \\gamma (T(x) - T_{env}) $$\nwhere $x$ is the distance in meters from the base of the fin. The physical parameters are given as:\n-   Heat transfer coefficient: $\\gamma = 0.09 \\text{ m}^{-2}$\n-   Ambient temperature: $T_{env} = 20.0$ °C\n\nThe temperature at the base of the fin is fixed, and the temperature at the tip is also known. These boundary conditions are:\n-   Base temperature: $T(0) = 150.0$ °C\n-   Tip temperature: $T(2.0) = 50.0$ °C\n\nYour task is to apply the shooting method to find a better approximation for the initial temperature gradient, $s = T'(0)$. You will employ the secant method as the root-finding algorithm. Given two initial guesses for the gradient, $s_0 = -10.0$ °C/m and $s_1 = -30.0$ °C/m, calculate the next approximation, $s_2$.\n\nTo find the temperature at the end of the fin for a given initial gradient, you should use the analytical solution of the resulting initial value problem.\n\nExpress your final answer in °C/m. Round your answer to three significant figures.", "solution": "We reduce the boundary value problem to an initial value problem via the standard shooting method. Define the excess temperature $\\theta(x) = T(x) - T_{env}$. The governing equation and initial conditions become\n$$\n\\theta''(x) = \\gamma\\,\\theta(x), \\quad \\theta(0) = T(0) - T_{env}, \\quad \\theta'(0) = s,\n$$\nwith $\\gamma>0$. Let $\\lambda = \\sqrt{\\gamma}$. The general solution is\n$$\n\\theta(x) = C \\cosh(\\lambda x) + D \\sinh(\\lambda x).\n$$\nApplying the initial conditions at $x=0$ gives $C = \\theta(0) = T(0) - T_{env}$ and $\\theta'(x) = \\lambda\\big(C \\sinh(\\lambda x) + D \\cosh(\\lambda x)\\big)$, so $\\theta'(0) = \\lambda D = s$, hence $D = \\frac{s}{\\lambda}$. Therefore,\n$$\nT(x;s) = T_{env} + \\theta(x) = T_{env} + \\big(T(0) - T_{env}\\big)\\cosh(\\lambda x) + \\frac{s}{\\lambda}\\sinh(\\lambda x).\n$$\nThe residual for the tip boundary condition at $x=L$ is\n$$\nf(s) = T(L;s) - T(L) = \\big[T_{env} + \\big(T(0) - T_{env}\\big)\\cosh(\\lambda L) + \\tfrac{s}{\\lambda}\\sinh(\\lambda L)\\big] - T(L).\n$$\nWith the given data $L=2.0$, $\\gamma=0.09$, $T_{env}=20.0$, $T(0)=150.0$, $T(L)=50.0$, we have $\\lambda=\\sqrt{\\gamma}=0.3$ and\n$$\nf(s) = -30 + 130\\,\\cosh(0.6) + \\frac{s}{0.3}\\,\\sinh(0.6).\n$$\nUsing $\\cosh(0.6) = \\frac{\\exp(0.6)+\\exp(-0.6)}{2} \\approx 1.185465218242$ and $\\sinh(0.6) = \\frac{\\exp(0.6)-\\exp(-0.6)}{2} \\approx 0.636653582148$, this simplifies to the linear form\n$$\nf(s) \\approx 124.11047837146 + 2.12217860716\\,s.\n$$\nEvaluate at the given guesses $s_{0}=-10.0$ and $s_{1}=-30.0$:\n$$\nf(s_{0}) \\approx 124.11047837146 + 2.12217860716(-10.0) = 102.88869229986,\n$$\n$$\nf(s_{1}) \\approx 124.11047837146 + 2.12217860716(-30.0) = 60.44512015666.\n$$\nApply the secant method for the next iterate:\n$$\ns_{2} = s_{1} - f(s_{1})\\,\\frac{s_{1}-s_{0}}{f(s_{1}) - f(s_{0})}\n= -30.0 - 60.44512015666\\,\\frac{-20.0}{60.44512015666 - 102.88869229986}.\n$$\nCompute the denominator $60.44512015666 - 102.88869229986 = -42.44357214320$, so\n$$\ns_{2} \\approx -30.0 - \\frac{-1208.9024031332}{-42.44357214320} \\approx -58.4825791536.\n$$\nBecause $f(s)$ is linear in $s$, this secant step yields the exact root for the shooting residual. Rounding to three significant figures gives $-58.5$ in the required units.", "answer": "$$\\boxed{-58.5}$$", "id": "2220751"}, {"introduction": "Real-world problems are often nonlinear and lack simple analytical solutions, demanding more sophisticated numerical tools. This advanced practice elevates the shooting method by incorporating Newton's method for root-finding, a quadratically convergent and highly efficient algorithm. To implement it, you will derive and solve a 'sensitivity equation,' which describes how the solution changes in response to small changes in the initial slope. This exercise represents a capstone, guiding you to build a complete, robust, and efficient solver for challenging nonlinear BVPs, a powerful tool in any computational scientist's arsenal.", "problem": "Consider a nonlinear, steady, one-dimensional conduction model written as an ordinary differential equation (ODE) boundary value problem (BVP) on the closed interval $[0,1]$:\n$$\ny''(x) + \\lambda \\sinh\\!\\big(y(x)\\big) = 0,\\quad x \\in [0,1],\n$$\nwith boundary conditions\n$$\ny(0) = \\alpha,\\qquad y(1) = \\beta,\n$$\nwhere $\\lambda$, $\\alpha$, and $\\beta$ are given real constants, and $\\sinh(\\cdot)$ is the hyperbolic sine function. All quantities are nondimensional (no physical units). The shooting method reformulates the BVP as an initial value problem (IVP) parametrized by the unknown initial slope $s = y'(0)$:\n$$\ny'(x) = v(x),\\qquad v'(x) = -\\lambda \\sinh\\!\\big(y(x)\\big),\\qquad y(0)=\\alpha,\\quad v(0)=s.\n$$\nDefine the terminal mismatch function\n$$\n\\Phi(s) := y(1;s) - \\beta,\n$$\nwhere $y(1;s)$ denotes the state $y$ at $x=1$ obtained by integrating the IVP with the parameter $s$. The numerical objective is to find $s^\\star$ such that $\\Phi(s^\\star)=0$.\n\nTask:\n- Starting from the definitions of an initial value problem and the shooting formulation, and using only standard calculus of variations and the chain rule, derive the linear sensitivity (variational) ODE satisfied by $z(x) := \\partial y(x;s)/\\partial s$ and its initial conditions at $x=0$. Explain why this sensitivity enables the use of Newton’s method to update $s$.\n- Implement a robust Newton iteration for the root finding of $\\Phi(s)=0$ that uses the sensitivity equation to evaluate the derivative $\\Phi'(s)$. At each Newton step, integrate the coupled state–sensitivity IVP from $x=0$ to $x=1$ to obtain both $y(1;s)$ and $z(1;s) = \\partial y(1;s)/\\partial s$. Use these to compute the Newton update for $s$. You may employ a simple backtracking line search to improve robustness if needed.\n- Use a deterministic, adaptive ODE integrator with rigorous local error control to integrate the coupled ODE system. Ensure the absolute and relative tolerances are tight enough to resolve the solution and the sensitivity to at least $10^{-10}$ in the terminal residual $|\\Phi(s)|$.\n- Use the following test suite of parameter sets $(\\lambda,\\alpha,\\beta)$:\n  1. $(\\lambda,\\alpha,\\beta)=(5.0,0.0,0.0)$\n  2. $(\\lambda,\\alpha,\\beta)=(1.0,0.0,1.0)$\n  3. $(\\lambda,\\alpha,\\beta)=(10.0,0.0,0.2)$\n  4. $(\\lambda,\\alpha,\\beta)=(0.01,0.0,0.5)$\n  5. $(\\lambda,\\alpha,\\beta)=(2.5,0.2,-0.3)$\n- For each parameter set, compute the Newton-converged initial slope $s^\\star$ such that $|\\Phi(s^\\star)| \\le 10^{-10}$.\n\nFinal output format:\n- Your program must produce a single line of output containing a Python-style list of floating-point numbers, one per test case, in the same order as the test suite. Each number must be the corresponding converged initial slope $s^\\star$, formatted with exactly $8$ digits after the decimal point. For example, print the string $[s\\_1,s\\_2,s\\_3,s\\_4,s\\_5]$ with each $s\\_k$ rounded to $8$ decimal places and no additional whitespace or text anywhere.", "solution": "The problem as stated is a mathematically and computationally well-defined task. It is a standard nonlinear boundary value problem (BVP) from the field of mathematical physics, and its reformulation via the shooting method is a canonical technique. The problem is self-contained, scientifically grounded, and its parameters are specified, allowing for a unique numerical solution to be found for a given initial guess. The problem is therefore deemed valid. The solution proceeds by first principles.\n\nThe BVP is defined by the second-order ordinary differential equation (ODE):\n$$\ny''(x) + \\lambda \\sinh(y(x)) = 0, \\quad x \\in [0,1]\n$$\nwith Dirichlet boundary conditions:\n$$\ny(0) = \\alpha, \\quad y(1) = \\beta\n$$\n\nThe shooting method transforms this BVP into an initial value problem (IVP). We introduce a state vector with components $y(x)$ and its derivative $v(x) = y'(x)$. The second-order ODE is rewritten as a system of two first-order ODEs:\n$$\n\\begin{cases}\ny'(x) = v(x) \\\\\nv'(x) = -\\lambda \\sinh(y(x))\n\\end{cases}\n$$\nThe boundary condition at $x=0$, $y(0)=\\alpha$, is used as an initial condition. The second initial condition, $v(0)=y'(0)$, is unknown. We designate this unknown initial slope as a parameter, $s$:\n$$\ny(0) = \\alpha, \\quad v(0) = s\n$$\nThe solution of this IVP depends on the choice of $s$, which we denote as $y(x;s)$. The objective of the shooting method is to find the specific value of the parameter, $s^\\star$, such that the solution satisfies the second boundary condition at $x=1$:\n$$\ny(1; s^\\star) = \\beta\n$$\nThis is a root-finding problem for the terminal mismatch function $\\Phi(s)$:\n$$\n\\Phi(s) := y(1;s) - \\beta = 0\n$$\n\nTo solve $\\Phi(s)=0$ using Newton's method, we require the derivative of $\\Phi(s)$ with respect to $s$. The Newton iteration is given by:\n$$\ns_{k+1} = s_k - \\frac{\\Phi(s_k)}{\\Phi'(s_k)}\n$$\nThe derivative $\\Phi'(s)$ is computed as:\n$$\n\\Phi'(s) = \\frac{d}{ds} \\left( y(1;s) - \\beta \\right) = \\frac{\\partial y(1;s)}{\\partial s}\n$$\nTo find this partial derivative, we derive the sensitivity equations. Let $z(x;s) = \\frac{\\partial y(x;s)}{\\partial s}$ and $w(x;s) = \\frac{\\partial v(x;s)}{\\partial s}$. We differentiate the IVP system with respect to the parameter $s$, applying the chain rule and noting that the order of differentiation with respect to $x$ and $s$ can be interchanged:\n$$\n\\frac{\\partial}{\\partial s} (y') = \\frac{d}{dx}\\left(\\frac{\\partial y}{\\partial s}\\right) = z'(x)\n$$\nFrom the first ODE, $y' = v$, we have:\n$$\nz'(x) = \\frac{\\partial v(x;s)}{\\partial s} = w(x)\n$$\nFrom the second ODE, $v' = -\\lambda \\sinh(y)$, we have:\n$$\n\\frac{\\partial}{\\partial s} (v') = \\frac{d}{dx}\\left(\\frac{\\partial v}{\\partial s}\\right) = w'(x)\n$$\n$$\nw'(x) = \\frac{\\partial}{\\partial s} \\left( -\\lambda \\sinh(y(x;s)) \\right) = -\\lambda \\cosh(y(x;s)) \\cdot \\frac{\\partial y(x;s)}{\\partial s} = -\\lambda \\cosh(y(x;s)) z(x)\n$$\nThis yields a system of linear ODEs for the sensitivities $z(x)$ and $w(x)$:\n$$\n\\begin{cases}\nz'(x) = w(x) \\\\\nw'(x) = -\\lambda \\cosh(y(x;s)) z(x)\n\\end{cases}\n$$\nThis is equivalent to the second-order linear variational equation for $z(x)$:\n$$\nz''(x) + \\lambda \\cosh(y(x;s)) z(x) = 0\n$$\nThe initial conditions for this system are found by differentiating the original initial conditions with respect to $s$:\n$$\nz(0) = \\frac{\\partial y(0)}{\\partial s} = \\frac{\\partial \\alpha}{\\partial s} = 0 \\quad (\\text{since } \\alpha \\text{ is a constant})\n$$\n$$\nw(0) = \\frac{\\partial v(0)}{\\partial s} = \\frac{\\partial s}{\\partial s} = 1\n$$\nThe derivative required for Newton's method is $\\Phi'(s) = z(1;s)$. To find this value, we must solve a coupled system of four first-order ODEs. Let the state vector be $\\mathbf{u}(x) = [y(x), v(x), z(x), w(x)]^T$. The coupled system is:\n$$\n\\mathbf{u}'(x) = \\frac{d}{dx} \\begin{bmatrix} y \\\\ v \\\\ z \\\\ w \\end{bmatrix} = \\begin{bmatrix} v \\\\ -\\lambda \\sinh(y) \\\\ w \\\\ -\\lambda \\cosh(y) z \\end{bmatrix}\n$$\nwith the initial condition at $x=0$ for a given trial slope $s_k$:\n$$\n\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T\n$$\nThe algorithm for the Newton-based shooting method is as follows:\n1.  Select an initial guess for the slope, $s_0$.\n2.  For $k=0, 1, 2, \\dots$ until convergence:\n    a. Define the initial condition vector $\\mathbf{u}(0) = [\\alpha, s_k, 0, 1]^T$.\n    b. Integrate the coupled four-dimensional ODE system from $x=0$ to $x=1$ using a high-precision adaptive ODE solver.\n    c. From the numerical solution at $x=1$, extract the terminal state $\\mathbf{u}(1) = [y(1;s_k), v(1;s_k), z(1;s_k), w(1;s_k)]^T$.\n    d. Evaluate the mismatch function: $\\Phi(s_k) = y(1;s_k) - \\beta$.\n    e. Check for convergence: if $|\\Phi(s_k)|$ is below a specified tolerance (e.g., $10^{-10}$), the iteration is complete, and $s^\\star = s_k$.\n    f. Evaluate the derivative: $\\Phi'(s_k) = z(1;s_k)$.\n    g. Compute the Newton update: $\\Delta s = - \\Phi(s_k) / \\Phi'(s_k)$.\n    h. To enhance robustness, a backtracking line search may be used. The update is applied as $s_{k+1} = s_k + \\gamma \\Delta s$, where $\\gamma \\in (0, 1]$ is reduced from $\\gamma=1$ until a sufficient decrease in the residual $|\\Phi(s)|$ is observed.\n    i. Update the slope: $s_{k+1} = s_k + \\gamma \\Delta s$.\n\nFor the given test cases, the initial guess $s_0 = \\beta - \\alpha$ is a reasonable choice, as it corresponds to the slope of a linear interpolant between the boundaries. However, for the symmetric case $(\\lambda=5.0, \\alpha=0.0, \\beta=0.0)$, this guess is $s_0=0$. This leads to the trivial solution $y(x)=0$, which is indeed a valid solution since $\\Phi(0) = 0 - 0 = 0$. To find a non-trivial solution, a non-zero initial guess, such as $s_0=1.0$, must be used. For all other specified cases, $s_0 = \\beta - \\alpha$ is a suitable non-zero guess.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the nonlinear BVP using the Newton-shooting method with sensitivity analysis.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, alpha, beta)\n        (5.0, 0.0, 0.0),\n        (1.0, 0.0, 1.0),\n        (10.0, 0.0, 0.2),\n        (0.01, 0.0, 0.5),\n        (2.5, 0.2, -0.3),\n    ]\n\n    results = []\n\n    def solve_bvp_for_case(lambda_val, alpha, beta):\n        \"\"\"\n        Computes the converged initial slope s* for a single set of parameters.\n        \"\"\"\n        \n        def coupled_ode(t, u, lambda_p):\n            \"\"\"\n            Defines the coupled state-sensitivity ODE system.\n            u = [y, v, z, w]\n            y' = v\n            v' = -lambda * sinh(y)\n            z' = w\n            w' = -lambda * cosh(y) * z\n            \"\"\"\n            y, v, z, w = u\n            y_dot = v\n            v_dot = -lambda_p * np.sinh(y)\n            z_dot = w\n            w_dot = -lambda_p * np.cosh(y) * z\n            return [y_dot, v_dot, z_dot, w_dot]\n\n        # Initial guess for the slope s = y'(0)\n        if lambda_val == 5.0 and alpha == 0.0 and beta == 0.0:\n            # For the symmetric case, s=0 gives the trivial solution y=0.\n            # To find a non-trivial solution, a non-zero guess is required.\n            s = 1.0\n        else:\n            # For other cases, the slope of the line connecting boundaries is a reasonable guess.\n            s = beta - alpha\n            \n        max_iter = 30\n        tolerance = 1e-10\n        ode_atol = 1e-13\n        ode_rtol = 1e-13\n\n        for i in range(max_iter):\n            # 1. Integrate the coupled system for the current guess s\n            u0 = np.array([alpha, s, 0.0, 1.0])\n            sol = solve_ivp(\n                fun=coupled_ode,\n                t_span=[0, 1],\n                y0=u0,\n                method='DOP853',\n                args=(lambda_val,),\n                atol=ode_atol,\n                rtol=ode_rtol\n            )\n            \n            # Check for integration failures\n            if sol.status != 0:\n                # Handle integration failure, e.g., by stopping.\n                # In a robust implementation, one might try another guess or method.\n                break\n\n            u1 = sol.y[:, -1]\n            y1, _, z1, _ = u1\n\n            # 2. Evaluate the residual (mismatch) and check for convergence\n            phi = y1 - beta\n            if abs(phi) < tolerance:\n                break\n                \n            # 3. Evaluate the derivative of the mismatch function\n            phi_prime = z1\n            if abs(phi_prime) < 1e-14:\n                # Derivative is too small; Newton's method may fail or diverge.\n                break\n\n            # 4. Compute the Newton update step\n            ds = -phi / phi_prime\n\n            # 5. Apply step with a simple backtracking line search for robustness\n            gamma = 1.0\n            max_backtrack = 10\n            s_next = s + gamma * ds\n            \n            for j in range(max_backtrack):\n                u0_next = np.array([alpha, s_next, 0.0, 1.0])\n                sol_next = solve_ivp(\n                    fun=coupled_ode,\n                    t_span=[0, 1],\n                    y0=u0_next,\n                    method='DOP853',\n                    args=(lambda_val,),\n                    atol=ode_atol,\n                    rtol=ode_rtol,\n                )\n                \n                if sol_next.status != 0:\n                     # If integration fails during line search, reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n                    continue\n\n                y1_next = sol_next.y[0, -1]\n                phi_next = y1_next - beta\n                \n                if abs(phi_next) < abs(phi):\n                    # Step accepted, break line search\n                    break\n                else:\n                    # Reduce step size\n                    gamma *= 0.5\n                    s_next = s + gamma * ds\n            \n            s = s_next\n            \n        return s\n\n    for case in test_cases:\n        lambda_val, alpha, beta = case\n        s_star = solve_bvp_for_case(lambda_val, alpha, beta)\n        results.append(s_star)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2437831"}]}