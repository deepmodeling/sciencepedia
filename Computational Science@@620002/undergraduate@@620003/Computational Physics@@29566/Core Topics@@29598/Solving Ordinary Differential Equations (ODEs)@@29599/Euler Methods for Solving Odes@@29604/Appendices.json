{"hands_on_practices": [{"introduction": "The forward Euler method is appealing for its simplicity, but this simplicity hides a critical pitfall: conditional stability. We will explore this concept using a simple RC circuit, a system that physically exhibits smooth exponential decay. By simulating this circuit with different time steps in this practice [@problem_id:2390244], you will see firsthand how an inappropriate choice of $\\Delta t$ can lead to non-physical oscillations and instability, a purely numerical artifact that underscores the importance of choosing your integration parameters wisely.", "problem": "A resistor-capacitor circuit consists of a resistor with resistance $R$ (in $\\Omega$) and a capacitor with capacitance $C$ (in $\\mathrm{F}$) connected to a voltage source $V_{\\text{in}}(t)$ (in $\\mathrm{V}$). The capacitor voltage $V(t)$ (in $\\mathrm{V}$) satisfies the first-order ordinary differential equation\n$$\n\\frac{dV}{dt} = \\frac{1}{RC}\\big(V_{\\text{in}}(t)-V(t)\\big),\n$$\nwith initial condition $V(0)=V_{\\text{init}}$. Consider the case where $V_{\\text{in}}(t)$ is constant and equal to $V_0$ (a direct-current step), and the case where $V_{\\text{in}}(t)$ is constant and equal to $0$. Discretize time with a uniform step size $h$ (in $\\mathrm{s}$), form a sequence of times $t_n = nh$ for $n\\in\\{0,1,2,\\dots,N\\}$ with $N=\\lfloor T_{\\text{end}}/h \\rfloor$, and approximate $V(t_n)$ by a sequence $V_n$ generated by the explicit one-step update with step size $h$. For each parameter set below, simulate from $t=0$ to $t=T_{\\text{end}}$ and compute the following quantities:\n\n1. A boolean $b_{\\text{osc}}$ that is $\\text{True}$ if and only if there exists at least one sign change in the sequence of errors $e_n$ defined by $e_n = V_n - V_0$ when $V_{\\text{in}}(t)=V_0$ is used, or by $e_n = V_n$ when $V_{\\text{in}}(t)=0$ is used, for $n\\in\\{0,1,\\dots,N\\}$. Treat values $|e_n|\\le \\varepsilon$ as zero for sign-change detection, where $\\varepsilon=10^{-12}$ (in $\\mathrm{V}$).\n2. A boolean $b_{\\text{conv}}$ that is $\\text{True}$ if and only if the sequence is numerically convergent by the end of the simulation, defined here as simultaneously satisfying $|V_N - V_{N-1}| \\le \\tau$ and $\\max_{0\\le n\\le N} |V_n| \\le V_{\\max}$, where $\\tau=10^{-6}$ (in $\\mathrm{V}$) and $V_{\\max}=10^{6}$ (in $\\mathrm{V}$).\n3. A float $V_{\\text{final}}$ equal to $V_N$ (in $\\mathrm{V}$), rounded to six decimal places. If $\\max_{0\\le n\\le N} |V_n| > V_{\\max}$ at any time in the simulation, report $V_{\\text{final}}$ as the special floating-point value $\\mathrm{NaN}$.\n\nPhysical constants and units must be used consistently: $R$ in $\\Omega$, $C$ in $\\mathrm{F}$, time in $\\mathrm{s}$, and voltage in $\\mathrm{V}$. Angles do not appear. All booleans must be literal logical values and all floats must be decimal numbers as defined. No percentages are to be reported.\n\nTest suite (each tuple lists $(R,C,V_0,V_{\\text{init}},h,T_{\\text{end}})$):\n\n- Case $1$ (baseline, monotone approach): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=0.1\\,\\mathrm{s},\\; T_{\\text{end}}=5\\,\\mathrm{s})$.\n- Case $2$ (boundary factor): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=1.0\\,\\mathrm{s},\\; T_{\\text{end}}=5\\,\\mathrm{s})$.\n- Case $3$ (oscillatory yet decaying): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=1.5\\,\\mathrm{s},\\; T_{\\text{end}}=40\\,\\mathrm{s})$.\n- Case $4$ (oscillatory and non-convergent within horizon): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=2.5\\,\\mathrm{s},\\; T_{\\text{end}}=20\\,\\mathrm{s})$.\n- Case $5$ (free decay from a charged capacitor): $(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=0\\,\\mathrm{V},\\; V_{\\text{init}}=5\\,\\mathrm{V},\\; h=1.5\\,\\mathrm{s},\\; T_{\\text{end}}=40\\,\\mathrm{s})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes a bracketed triple in the order $[b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}]$. The overall output format must be\n$[ [b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}], [b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}], \\dots ]$\nwith no additional text. For example, a valid output with two hypothetical cases would be $[[\\text{True},\\text{False},3.000000],[\\text{False},\\text{True},5.000000]]$.", "solution": "The problem presented is a well-posed initial value problem (IVP) for a first-order linear ordinary differential equation (ODE) modeling an RC circuit. The problem is scientifically grounded, formally specified, and objective. It requires the numerical solution of the ODE using a prescribed discretization scheme and the calculation of specific metrics related to the numerical solution's behavior. The problem is valid and a solution will be provided.\n\nThe governing ODE for the capacitor voltage $V(t)$ is:\n$$\n\\frac{dV}{dt} = \\frac{1}{RC} \\left( V_{\\text{in}}(t) - V(t) \\right)\n$$\nwith the initial condition $V(0) = V_{\\text{init}}$.\n\nThe problem specifies an \"explicit one-step update,\" which for a first-order ODE corresponds to the Forward Euler method. The time domain is discretized into steps of size $h$, such that $t_n = nh$. The voltage at time $t_n$, denoted $V(t_n)$, is approximated by the sequence $V_n$. The Forward Euler update rule for an ODE $\\frac{dy}{dt} = f(t,y)$ is $y_{n+1} = y_n + h f(t_n, y_n)$.\n\nFor the given RC circuit ODE, the function is $f(t, V) = \\frac{1}{RC}(V_{\\text{in}}(t) - V)$. In each test case, the input voltage $V_{\\text{in}}(t)$ is a constant, which we denote $V_{\\text{in,const}}$ (equal to $V_0$ or $0$). The update rule for $V_n$ is therefore:\n$$\nV_{n+1} = V_n + h \\left( \\frac{1}{RC} (V_{\\text{in,const}} - V_n) \\right)\n$$\nLet the time constant of the circuit be $\\tau_{RC} = RC$. The equation can be rearranged to highlight its structure as a linear recurrence relation:\n$$\nV_{n+1} = V_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\nTo analyze the stability and oscillatory behavior of this numerical scheme, we study the evolution of the error, $e_n$, defined as the deviation from the steady-state voltage, $V_{\\text{in,const}}$.\n$$\ne_n = V_n - V_{\\text{in,const}}\n$$\nSubstituting $V_n = e_n + V_{\\text{in,const}}$ into the update rule:\n$$\ne_{n+1} + V_{\\text{in,const}} = (e_n + V_{\\text{in,const}}) \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n$$\ne_{n+1} = e_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) - V_{\\text{in,const}} + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n$$\ne_{n+1} = e_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right)\n$$\nThis is a geometric progression for the error, $e_n = e_0 \\alpha^n$, where the initial error is $e_0 = V_{\\text{init}} - V_{\\text{in,const}}$ and the stability factor is $\\alpha = 1 - h/\\tau_{RC}$. The behavior of the numerical solution is determined by the value of $\\alpha$:\n1.  $0 < \\alpha < 1$ (i.e., $0 < h/\\tau_{RC} < 1$): The error $e_n$ decays monotonically to zero without changing sign. The numerical solution approaches the steady state monotonically. This implies $b_{\\text{osc}} = \\text{False}$.\n2.  $-1 < \\alpha \\le 0$ (i.e., $1 \\le h/\\tau_{RC} < 2$): The error $e_n$ alternates in sign at each step, while its magnitude decays. The numerical solution oscillates around the steady state as it converges. This implies $b_{\\text{osc}} = \\text{True}$.\n3.  $\\alpha \\le -1$ (i.e., $h/\\tau_{RC} \\ge 2$): The magnitude of the error, $|e_n|$, does not decay. If $\\alpha = -1$, the magnitude is constant. If $\\alpha < -1$, the magnitude grows exponentially. The numerical solution is unstable. This implies $b_{\\text{osc}} = \\text{True}$ (as the sign alternates) but the solution will not converge.\n\nThe algorithm to solve the problem for each parameter set is as follows:\n1.  Calculate constants for the simulation: the time constant $\\tau_{RC} = R \\times C$, and the total number of steps $N = \\lfloor T_{\\text{end}}/h \\rfloor$.\n2.  Identify the constant input voltage $V_{\\text{in,const}}$.\n3.  Initialize an array `voltages` of size $N+1$ with the initial condition `voltages[0]` $= V_{\\text{init}}$.\n4.  Iterate from $n=0$ to $N-1$ to generate the sequence $V_n$ using the update rule $V_{n+1} = V_n(1 - h/\\tau_{RC}) + V_{\\text{in,const}}(h/\\tau_{RC})$.\n5.  During the simulation, track the maximum absolute voltage, $\\max_{0\\le n\\le N} |V_n|$, to check against the divergence threshold $V_{\\max} = 10^6\\,\\mathrm{V}$.\n6.  After the simulation, calculate the required quantities:\n    a.  **$b_{\\text{osc}}$**: Create the error sequence $e_n = V_n - V_{\\text{in,const}}$ (or $e_n=V_n$ if $V_{\\text{in,const}}=0$). Iterate through the errors. A sign change is recorded if for any two consecutive non-zero errors (where non-zero is defined as $|e_n| > \\varepsilon = 10^{-12}\\,\\mathrm{V}$), their signs are opposite.\n    b.  **$b_{\\text{conv}}$**: Check if the divergence condition was met. If $\\max|V_n| > V_{\\max}$, convergence is false. Otherwise, check if the final change in voltage is within tolerance: $|V_N - V_{N-1}| \\le \\tau = 10^{-6}\\,\\mathrm{V}$. Both conditions must be met for $b_{\\text{conv}}$ to be $\\text{True}$.\n    c.  **$V_{\\text{final}}$**: If the solution has diverged ($\\max|V_n| > V_{\\max}$), the value is the special floating-point number $\\mathrm{NaN}$. Otherwise, it is the final voltage $V_N$. The result is formatted to six decimal places upon printing.\n\nThis procedure is applied to each of the five test cases to produce the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RC circuit problem for all test cases using the Forward Euler method.\n    \"\"\"\n    \n    # Each tuple lists (R, C, V0, V_init, h, T_end)\n    test_cases = [\n        (1e3, 1e-3, 5.0, 0.0, 0.1, 5.0),\n        (1e3, 1e-3, 5.0, 0.0, 1.0, 5.0),\n        (1e3, 1e-3, 5.0, 0.0, 1.5, 40.0),\n        (1e3, 1e-3, 5.0, 0.0, 2.5, 20.0),\n        (1e3, 1e-3, 0.0, 5.0, 1.5, 40.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(simulate_rc_circuit(case))\n    \n    # Format the final output string as a list of lists.\n    # The str() representation of a list is already '[...]'.\n    # For floats, format to 6 decimal places. NaN is handled correctly.\n    formatted_results = []\n    for res in results:\n        b_osc, b_conv, v_final = res\n        if np.isnan(v_final):\n            v_final_str = 'nan'\n        else:\n            v_final_str = f\"{v_final:.6f}\"\n        formatted_results.append(f\"[{b_osc},{b_conv},{v_final_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef simulate_rc_circuit(params):\n    \"\"\"\n    Simulates one RC circuit case and calculates the required metrics.\n    \"\"\"\n    R, C, V0, V_init, h, T_end = params\n    \n    # Physical and numerical constants from the problem statement\n    RC = R * C\n    N = int(T_end / h)\n    eps = 1e-12\n    tau = 1e-6\n    V_max = 1e6\n    \n    # The constant input voltage is V0, unless V0=0, then it's a free decay.\n    V_in_const = V0\n\n    voltages = np.zeros(N + 1)\n    voltages[0] = V_init\n    \n    max_abs_V = abs(V_init)\n    is_diverged = False\n    \n    # Stability factor and terms for the recurrence relation\n    alpha = 1.0 - h / RC\n    beta = V_in_const * (h / RC)\n\n    # Simulation loop using the Forward Euler method\n    for n in range(N):\n        voltages[n+1] = voltages[n] * alpha + beta\n        \n        # Track maximum absolute voltage for divergence check\n        current_abs_v = abs(voltages[n+1])\n        if current_abs_v > max_abs_V:\n            max_abs_V = current_abs_v\n    \n    # Check for divergence after the simulation is complete\n    if max_abs_V > V_max:\n        is_diverged = True\n        \n    # --- 1. Oscillation Check (b_osc) ---\n    b_osc = False\n    errors = voltages - V_in_const\n\n    def get_sign(val):\n        if val > eps:\n            return 1\n        if val  -eps:\n            return -1\n        return 0\n\n    last_sign = get_sign(errors[0])\n    for i in range(1, N + 1):\n        current_sign = get_sign(errors[i])\n        if last_sign * current_sign  0:\n            b_osc = True\n            break\n        if current_sign != 0:\n            last_sign = current_sign\n\n    # --- 2. Convergence Check (b_conv) ---\n    b_conv = False\n    if not is_diverged:\n        # Check if the final step size is within the convergence tolerance\n        if abs(voltages[N] - voltages[N-1]) = tau:\n            b_conv = True\n\n    # --- 3. Final Voltage (V_final) ---\n    if is_diverged:\n        V_final = np.nan\n    else:\n        V_final = voltages[N]\n        \n    return [b_osc, b_conv, V_final]\n\nsolve()\n```", "id": "2390244"}, {"introduction": "Beyond simple stability, a good numerical integrator should respect the underlying geometry of the physical system it models. For conservative Hamiltonian systems, like the harmonic oscillator, this includes preserving the volume of phase space, a principle enshrined in Liouville's theorem. This exercise [@problem_id:2390251] challenges you to apply the forward Euler method to a harmonic oscillator and track the evolution of a small area in its phase space, discovering that the method systematically fails this fundamental test and revealing its non-symplectic nature. This motivates the need for geometric integrators in computational physics.", "problem": "Consider the one-dimensional harmonic oscillator with Hamiltonian $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k q^2}{2}$, where $q$ is the generalized coordinate and $p$ is the conjugate momentum. The exact Hamiltonian flow in phase space $(q,p)$ satisfies Hamilton’s equations $\\dot{q}=\\dfrac{\\partial H}{\\partial p}$ and $\\dot{p}=-\\dfrac{\\partial H}{\\partial q}$, which define an ordinary differential equation (ODE) system.\n\nDefine a discrete-time map $(q_n,p_n)\\mapsto(q_{n+1},p_{n+1})$ by the forward (explicit) time discretization of Hamilton’s equations with time step $h$:\n- $q_{n+1}=q_n+h\\,\\dfrac{p_n}{m}$,\n- $p_{n+1}=p_n-h\\,k\\,q_n$.\n\nLet the initial patch in phase space be the axis-aligned rectangle centered at $(q_0,p_0)$ with side lengths $\\delta q$ and $\\delta p$. Its four corner points are\n- $(q_0-\\delta q/2,\\;p_0-\\delta p/2)$,\n- $(q_0+\\delta q/2,\\;p_0-\\delta p/2)$,\n- $(q_0+\\delta q/2,\\;p_0+\\delta p/2)$,\n- $(q_0-\\delta q/2,\\;p_0+\\delta p/2)$,\nlisted in counterclockwise order. The initial area is $A_0=\\delta q\\,\\delta p$.\n\nFor each parameter set below, evolve each of the four corners under the discrete-time map for exactly $N$ steps to obtain their images, which form a quadrilateral in the $(q,p)$-plane. Compute the area $A_N$ of this quadrilateral using the vertices in the same counterclockwise order as listed above after evolution, and report the area ratio $R=A_N/A_0$ (dimensionless). Use the same $(q_0,p_0,\\delta q,\\delta p)$ for all test cases:\n- $q_0=0.3$,\n- $p_0=-0.5$,\n- $\\delta q=10^{-3}$,\n- $\\delta p=10^{-3}$.\n\nTest suite (each case is $(m,k,h,N)$):\n- Case $1$: $(m,k,h,N)=(1,\\;1,\\;0.1,\\;100)$.\n- Case $2$: $(m,k,h,N)=(1,\\;1,\\;0.0,\\;10)$.\n- Case $3$: $(m,k,h,N)=(2,\\;8,\\;0.05,\\;400)$.\n- Case $4$: $(m,k,h,N)=(1,\\;4,\\;0.45,\\;5)$.\n\nYour program must compute $R$ for each case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each $R$ rounded to six decimal places (for example, $[2.000000,1.500000]$). All reported values are dimensionless; do not include units, angle units, or percentage signs. The final output must be exactly one line in the specified format.", "solution": "The problem statement is subjected to validation.\n\nStep 1: Extract Givens\n- Hamiltonian: $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k q^2}{2}$\n- Hamilton’s equations: $\\dot{q}=\\dfrac{\\partial H}{\\partial p} = \\dfrac{p}{m}$ and $\\dot{p}=-\\dfrac{\\partial H}{\\partial q} = -kq$\n- Discrete-time map (forward Euler):\n  - $q_{n+1}=q_n+h\\,\\dfrac{p_n}{m}$\n  - $p_{n+1}=p_n-h\\,k\\,q_n$\n- Initial phase space patch: an axis-aligned rectangle centered at $(q_0,p_0)$ with side lengths $\\delta q$ and $\\delta p$.\n- Initial corner points (counterclockwise):\n  - $(q_0-\\delta q/2,\\;p_0-\\delta p/2)$\n  - $(q_0+\\delta q/2,\\;p_0-\\delta p/2)$\n  - $(q_0+\\delta q/2,\\;p_0+\\delta p/2)$\n  - $(q_0-\\delta q/2,\\;p_0+\\delta p/2)$\n- Initial area: $A_0=\\delta q\\,\\delta p$\n- Task: Evolve the four corner points for $N$ steps, compute the area $A_N$ of the resulting quadrilateral, and report the ratio $R=A_N/A_0$.\n- Fixed initial parameters: $q_0=0.3$, $p_0=-0.5$, $\\delta q=10^{-3}$, $\\delta p=10^{-3}$.\n- Test cases for $(m,k,h,N)$:\n  - Case 1: $(1,\\;1,\\;0.1,\\;100)$\n  - Case 2: $(1,\\;1,\\;0.0,\\;10)$\n  - Case 3: $(2,\\;8,\\;0.05,\\;400)$\n  - Case 4: $(1,\\;4,\\;0.45,\\;5)$\n\nStep 2: Validate Using Extracted Givens\n- **Scientifically Grounded**: The problem describes the harmonic oscillator, a fundamental system in classical mechanics. It employs Hamilton's equations, a standard formulation of classical dynamics. The numerical method, explicit (forward) Euler, is a well-known, albeit simple, technique for solving ordinary differential equations. The premises are scientifically sound.\n- **Well-Posed**: All necessary parameters ($m, k, h, N, q_0, p_0, \\delta q, \\delta p$) are provided. The instructions for calculating the result are explicit and unambiguous. A unique, meaningful solution exists for each test case.\n- **Objective**: The problem is stated in precise mathematical and algorithmic terms, free of subjectivity or ambiguity.\n\nStep 3: Verdict and Action\nThe problem is valid. It is a well-defined exercise in computational physics, specifically concerning the properties of a numerical integrator applied to a Hamiltonian system. A solution will be provided.\n\nThe problem asks for a numerical computation by tracking four vertices. However, a more fundamental analysis reveals the underlying principle. The discrete-time map is a linear transformation. Let the state vector be $\\mathbf{x}_n = \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}$. The map can be written in matrix form:\n$$\n\\mathbf{x}_{n+1} = \\begin{pmatrix} q_{n+1} \\\\ p_{n+1} \\end{pmatrix} = \\begin{pmatrix} q_n + h \\frac{p_n}{m} \\\\ p_n - h k q_n \\end{pmatrix} = \\begin{pmatrix} 1  h/m \\\\ -hk  1 \\end{pmatrix} \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}\n$$\nLet this one-step evolution matrix be $M = \\begin{pmatrix} 1  h/m \\\\ -hk  1 \\end{pmatrix}$. This is a linear map. A fundamental theorem of linear algebra states that a linear transformation scales all areas in the plane by a constant factor, equal to the absolute value of the determinant of the transformation matrix.\n\nThe determinant of the one-step matrix $M$ is:\n$$\n\\det(M) = (1)(1) - \\left(\\frac{h}{m}\\right)(-hk) = 1 + \\frac{h^2 k}{m}\n$$\nSince $h \\ge 0$, $k  0$, and $m  0$ (except for Case $2$ where $h=0$), we have $\\det(M) \\ge 1$. The area of any region in phase space is multiplied by this factor at each step.\n\nAfter $N$ steps, the total transformation is given by the matrix $M^N$. The total area scaling factor is $\\det(M^N)$. Using the property that the determinant of a matrix product is the product of the determinants, we have:\n$$\n\\det(M^N) = (\\det(M))^N\n$$\nThe ratio of the final area $A_N$ to the initial area $A_0$ is precisely this scaling factor. Therefore, the area ratio $R$ is given by the exact analytical expression:\n$$\nR = \\frac{A_N}{A_0} = \\left(1 + \\frac{h^2 k}{m}\\right)^N\n$$\nThis result is independent of the initial shape, its area $A_0$, or its position $(q_0, p_0)$, as long as the transformation is linear. The fact that the area is not conserved (i.e., $\\det(M) \\neq 1$) is a known deficiency of the explicit Euler method when applied to Hamiltonian systems. A proper symplectic integrator would preserve phase space area, meaning its determinant would be exactly $1$.\n\nThe problem requires a numerical simulation by evolving the four corners. While this is less elegant than the analytical derivation, it must be implemented as instructed. The procedure is as follows:\n\n1.  Initialize the four corner points $(q, p)$ of the rectangle:\n    - $P_1 = (q_0 - \\delta q/2, p_0 - \\delta p/2)$\n    - $P_2 = (q_0 + \\delta q/2, p_0 - \\delta p/2)$\n    - $P_3 = (q_0 + \\delta q/2, p_0 + \\delta p/2)$\n    - $P_4 = (q_0 - \\delta q/2, p_0 + \\delta p/2)$\n\n2.  For each corner point, iterate the map $N$ times. For $n$ from $0$ to $N-1$:\n    - $q_{n+1} = q_n + \\frac{h}{m} p_n$\n    - $p_{n+1} = p_n - h k q_n$\n    It is crucial to use $q_n$ in the update for $p_{n+1}$, not the newly computed $q_{n+1}$.\n\n3.  After $N$ steps, we obtain the four final vertices of a parallelogram: $P'_1=(q'_1, p'_1)$, $P'_2=(q'_2, p'_2)$, $P'_3=(q'_3, p'_3)$, and $P'_4=(q'_4, p'_4)$.\n\n4.  The area $A_N$ of this transformed quadrilateral can be calculated using the Shoelace formula for a polygon with vertices $(q_i, p_i)$ listed in order:\n    $$\n    A_N = \\frac{1}{2} \\left| \\sum_{i=1}^{4} (q_i p_{i+1} - q_{i+1} p_i) \\right|\n    $$\n    where the index $i+1$ is taken modulo $4$ (so $(q_5, p_5) = (q_1, p_1)$). Because the transformation is linear, the final quadrilateral is a parallelogram, and its area can also be found from the magnitude of the cross product of the vectors representing adjacent sides, for example, $|\\det(P'_2 - P'_1, P'_4 - P'_1)|$.\n\n5.  The initial area is $A_0 = \\delta q \\cdot \\delta p = (10^{-3}) \\cdot (10^{-3}) = 10^{-6}$.\n\n6.  The required ratio is $R = A_N / A_0$. The numerical result from this procedure must agree with the analytical formula derived above. This confirms the correctness of the implementation.\n\nWe now apply this to the given test cases.\n\n- **Case 1**: $(m,k,h,N) = (1, 1, 0.1, 100)$\n  $R = \\left(1 + \\frac{(0.1)^2 (1)}{1}\\right)^{100} = (1.01)^{100} \\approx 2.704814$\n\n- **Case 2**: $(m,k,h,N) = (1, 1, 0.0, 10)$\n  With $h=0.0$, the map is the identity: $q_{n+1}=q_n$ and $p_{n+1}=p_n$. The points do not move. The area does not change.\n  $R = \\left(1 + \\frac{(0.0)^2 (1)}{1}\\right)^{10} = (1)^{10} = 1.0$\n\n- **Case 3**: $(m,k,h,N) = (2, 8, 0.05, 400)$\n  $R = \\left(1 + \\frac{(0.05)^2 (8)}{2}\\right)^{400} = (1 + \\frac{0.0025 \\cdot 8}{2})^{400} = (1 + 0.01)^{400} \\approx 53.593453$\n\n- **Case 4**: $(m,k,h,N) = (1, 4, 0.45, 5)$\n  $R = \\left(1 + \\frac{(0.45)^2 (4)}{1}\\right)^{5} = (1 + 0.2025 \\cdot 4)^{5} = (1 + 0.81)^{5} = (1.81)^{5} \\approx 19.344930$\n\nThe implementation will follow the specified numerical procedure.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the phase space area ratio for a harmonic oscillator\n    evolved with the explicit Euler method.\n    \"\"\"\n\n    # Define the fixed initial parameters for the phase space patch.\n    q0 = 0.3\n    p0 = -0.5\n    dq = 1e-3\n    dp = 1e-3\n\n    # The initial area of the rectangle.\n    A0 = dq * dp\n\n    # Define the four initial corner points of the rectangle in counterclockwise order.\n    # The shape is (4, 2) where each row is a (q, p) coordinate.\n    initial_corners = np.array([\n        [q0 - dq / 2, p0 - dp / 2],\n        [q0 + dq / 2, p0 - dp / 2],\n        [q0 + dq / 2, p0 + dp / 2],\n        [q0 - dq / 2, p0 + dp / 2]\n    ])\n\n    test_cases = [\n        # Case 1: (m, k, h, N)\n        (1.0, 1.0, 0.1, 100),\n        # Case 2\n        (1.0, 1.0, 0.0, 10),\n        # Case 3\n        (2.0, 8.0, 0.05, 400),\n        # Case 4\n        (1.0, 4.0, 0.45, 5)\n    ]\n\n    results = []\n    for m, k, h, N in test_cases:\n        # Start with a fresh copy of the initial corners for each test case.\n        corners = np.copy(initial_corners)\n\n        # Evolve the four corner points for N steps.\n        for _ in range(N):\n            q_n = corners[:, 0]\n            p_n = corners[:, 1]\n            \n            # Apply the explicit Euler update rules.\n            # It's crucial to use the old q_n and p_n for both updates.\n            q_np1 = q_n + h * p_n / m\n            p_np1 = p_n - h * k * q_n\n            \n            # Update the corners for the next iteration.\n            corners[:, 0] = q_np1\n            corners[:, 1] = p_np1\n        \n        final_corners = corners\n        \n        # Calculate the area of the final quadrilateral using the Shoelace formula.\n        # This formula works for any simple polygon.\n        # Area = 0.5 * |(x1y2 + x2y3 + ... + xny1) - (y1x2 + y2x3 + ... + ynx1)|\n        # A vectorized implementation using np.roll is efficient.\n        q = final_corners[:, 0]\n        p = final_corners[:, 1]\n        \n        # We use np.roll to get the next vertex in the sequence.\n        # np.roll(p, -1) gets [p2, p3, p4, p1]\n        term1 = np.sum(q * np.roll(p, -1))\n        # np.roll(q, -1) gets [q2, q3, q4, q1]\n        term2 = np.sum(p * np.roll(q, -1))\n        \n        A_N = 0.5 * np.abs(term1 - term2)\n        \n        # Calculate the area ratio R.\n        # For h=0, A_N might be extremely close but not exactly A0 due to float precision.\n        # However, A0 is also very small, so division is safe.\n        if A0 == 0:\n            area_ratio = 1.0 if A_N == 0 else np.inf\n        else:\n            area_ratio = A_N / A0\n            \n        results.append(f\"{area_ratio:.6f}\")\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2390251"}, {"introduction": "Having seen the explicit Euler method's failure to preserve phase space geometry, we now introduce a powerful and simple alternative: the semi-implicit Euler, or Euler-Cromer, method. This method is a simple symplectic integrator designed for excellent long-term stability in Hamiltonian systems. In this practice [@problem_id:2390259], you will simulate the classic Kepler two-body problem, and by comparing the long-term energy drift against the explicit Euler method, you will witness the dramatic improvement offered by this subtle change in the algorithm.", "problem": "Consider a Newtonian two-body system modeling a comet of negligible mass orbiting a central massive body. Work in non-dimensional gravitational units where the product of the gravitational constant and the central mass is normalized to $G M = 1$, and the comet mass is $m = 1$. The motion is confined to a plane, and the position vector is $\\mathbf{x}(t) \\in \\mathbb{R}^2$ with velocity $\\mathbf{v}(t) = d\\mathbf{x}/dt$. The fundamental laws to be used are Newton’s second law and the inverse-square gravitational force, which imply the first-order system\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}.\n$$\nThe total mechanical energy (the Hamiltonian) in these units is\n$$\nH(\\mathbf{x},\\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert},\n$$\nwhich is constant in time for the continuous dynamics.\n\nYour task is to design and implement two first-order time-stepping integrators for this ordinary differential equation (ODE) based only on the core definitions $d\\mathbf{x}/dt = \\mathbf{v}$ and $d\\mathbf{v}/dt = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$:\n- A standard explicit Euler integrator that advances position using the velocity evaluated at the current time level.\n- A semi-implicit Euler integrator (also called Euler–Cromer) that advances velocity using acceleration at the current position and then advances position using the updated velocity within the same step.\n\nFrom first principles, derive the update logic for each method by discretizing time in steps of size $\\Delta t$ and consistently applying the definitions above to construct the step-to-step advances. Do not introduce any extraneous approximations beyond this explicit time discretization, and ensure that both methods use the same force evaluation $\\mathbf{a}(\\mathbf{x}) = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$ at the start of each step.\n\nUse the following test suite. For each case, integrate for a prescribed number of orbital periods $P$ using a fixed time step $\\Delta t$. The orbital period for a Keplerian ellipse with semi-major axis $a$ in these units is $T = 2\\pi a^{3/2}$. The initial states are chosen to be on either a circular orbit or at aphelion of an ellipse, with the initial velocity perpendicular to the radius vector and directed for prograde motion. All quantities are dimensionless in these units.\n\n- Test case $1$ (circular “happy path”): $a = 1$, $e = 0$, initial state $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.01$, $P = 50$.\n- Test case $2$ (moderately eccentric comet): $a = 1$, $e = 0.6$, initial state at aphelion $\\mathbf{x}_0 = (1.6, 0)$, $\\mathbf{v}_0 = (0, 0.5)$, $\\Delta t = 0.001$, $P = 20$.\n- Test case $3$ (highly eccentric comet): $a = 1$, $e = 0.9$, initial state at aphelion $\\mathbf{x}_0 = (1.9, 0)$, $\\mathbf{v}_0 \\approx (0, 0.22941573387)$, $\\Delta t = 0.0005$, $P = 5$.\n- Test case $4$ (boundary time step, circular): $a = 1$, $e = 0$, initial state $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.05$, $P = 5$.\n\nFor each test case, compute the relative terminal energy drift for each integrator,\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H(\\mathbf{x}_N,\\mathbf{v}_N) - H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|}{\\left| H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|},\n$$\nwhere $N = \\left\\lceil \\frac{P \\, T}{\\Delta t} \\right\\rceil$ is the number of steps taken, and then return the ratio\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}.\n$$\nThis ratio $r$ is dimensionless. A value $r  1$ indicates that the semi-implicit Euler (Euler–Cromer) method exhibits smaller absolute energy drift than the standard explicit Euler over the same duration.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of the $r$ values for test cases $1$–$4$ in order, enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4]$. The entries must be floating-point numbers. No physical units appear in the output because all quantities are non-dimensional by construction.\n\nYour implementation must be completely self-contained and must not read any input. The answer for each test case is a single floating-point number $r$. The set of four outputs must appear on one line following the format above. Ensure numerical stability by using standard double-precision arithmetic throughout and by faithfully implementing the two requested integrators as derived from the stated fundamental laws and definitions.", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of classical mechanics, specifically the Kepler problem, and is mathematically well-posed as an initial value problem for a system of ordinary differential equations. The parameters and objectives are defined with precision, containing no contradictions, ambiguities, or factual inaccuracies. The task is a standard exercise in computational physics, requiring the derivation and comparison of two fundamental numerical integrators.\n\nWe proceed with the derivation and solution.\n\nThe system is described by a set of first-order ordinary differential equations (ODEs) for the position vector $\\mathbf{x}(t) \\in \\mathbb{R}^2$ and velocity vector $\\mathbf{v}(t) \\in \\mathbb{R}^2$:\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}) = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}\n$$\nHere, $\\mathbf{a}(\\mathbf{x})$ is the acceleration due to gravity, with the gravitational parameter $G M$ set to $1$.\n\nWe will discretize time with a constant time step $\\Delta t$. Let the state of the system at time $t_n = n \\Delta t$ be $(\\mathbf{x}_n, \\mathbf{v}_n)$. We seek to find the state $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$ at time $t_{n+1} = t_n + \\Delta t$.\n\n**Derivation of the Standard Explicit Euler Integrator**\n\nThe explicit, or forward, Euler method approximates the derivatives using the values at the current time level, $t_n$.\nThe discrete approximation of the first ODE is:\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{x}}{dt} \\right|_{t_n} = \\mathbf{v}_n\n$$\nSimilarly, for the second ODE:\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t_n} = \\mathbf{a}(\\mathbf{x}_n)\n$$\nRearranging these expressions gives the update rules for the explicit Euler method. First, the acceleration $\\mathbf{a}_n$ is computed from the current position $\\mathbf{x}_n$. Then, both position and velocity are advanced using the state at time $t_n$.\n\nThe update logic for a single step is:\n1.  Compute acceleration: $\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  Update velocity: $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  Update position: $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n \\Delta t$\n\nThe critical feature is that the new position $\\mathbf{x}_{n+1}$ is calculated using the old velocity $\\mathbf{v}_n$, not the newly computed velocity $\\mathbf{v}_{n+1}$.\n\n**Derivation of the Semi-Implicit Euler (Euler–Cromer) Integrator**\n\nThe semi-implicit Euler method, also known as the Euler-Cromer method, introduces a subtle but crucial modification. The update for the velocity is performed first, and this newly computed velocity is then immediately used to update the position. This \"mixing\" of time levels within a single step defines its semi-implicit nature.\n\nThe update for velocity remains the same as the explicit method:\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\mathbf{a}(\\mathbf{x}_n) \\implies \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\Delta t\n$$\nHowever, the position update uses the new velocity $\\mathbf{v}_{n+1}$:\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\mathbf{v}_{n+1}\n$$\n\nThe update logic for a single step is:\n1.  Compute acceleration: $\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  Update velocity: $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  Update position: $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1} \\Delta t$\n\nThis method is a simple symplectic integrator. For Hamiltonian systems like the Kepler problem, such integrators exhibit superior long-term stability, particularly concerning energy conservation. They do not conserve energy exactly but the energy error typically remains bounded, oscillating around the true value, whereas the explicit Euler method often leads to a secular drift in energy.\n\n**Simulation and Evaluation Methodology**\n\nFor each test case, we perform two simulations, one with each integrator.\nThe initial state is $(\\mathbf{x}_0, \\mathbf{v}_0)$.\nThe total integration time is specified by the number of orbital periods, $P$. The period $T$ for a Keplerian orbit with semi-major axis $a$ is $T = 2\\pi a^{3/2}$.\nThe total number of required steps is $N = \\lceil (P \\cdot T) / \\Delta t \\rceil$.\n\nThe conserved quantity for the continuous system is the mechanical energy, or Hamiltonian:\n$$\nH(\\mathbf{x}, \\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert}\n$$\nWe calculate the initial energy $H_0 = H(\\mathbf{x}_0, \\mathbf{v}_0)$. After $N$ steps, we obtain the final state $(\\mathbf{x}_N, \\mathbf{v}_N)$ and calculate the final energy $H_N = H(\\mathbf{x}_N, \\mathbf{v}_N)$.\n\nThe performance of each integrator is quantified by the relative terminal energy drift, $\\delta$:\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H_N - H_0 \\right|}{\\left| H_0 \\right|}\n$$\nThe problem requires the computation of the ratio $r$ of these drifts for the two methods:\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}\n$$\nA value of $r  1$ indicates that the semi-implicit Euler-Cromer method provides better long-term energy conservation than the standard explicit Euler method for the given parameters. The implementation will follow these derivations precisely.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using explicit Euler and semi-implicit Euler\n    methods and computes the ratio of their energy drifts.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # case 1: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.01, P=50\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.01, 'P': 50},\n        # case 2: a=1, e=0.6, x0=(1.6,0), v0=(0,0.5), dt=0.001, P=20\n        {'a': 1.0, 'x0': np.array([1.6, 0.0]), 'v0': np.array([0.0, 0.5]), 'dt': 0.001, 'P': 20},\n        # case 3: a=1, e=0.9, x0=(1.9,0), v0=(0, ~0.2294), dt=0.0005, P=5\n        {'a': 1.0, 'x0': np.array([1.9, 0.0]), 'v0': np.array([0.0, 0.22941573387]), 'dt': 0.0005, 'P': 5},\n        # case 4: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.05, P=5\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.05, 'P': 5},\n    ]\n\n    results = []\n\n    def hamiltonian(x, v):\n        \"\"\"Computes the Hamiltonian (total energy) of the system.\"\"\"\n        r_norm = np.linalg.norm(x)\n        v_norm_sq = np.dot(v, v)\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def run_explicit_euler(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the standard explicit Euler method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Store old velocity for position update\n            v_old = v\n            # Update velocity\n            v = v + a * dt\n            # Update position using old velocity\n            x = x + v_old * dt\n        return x, v\n\n    def run_euler_cromer(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the semi-implicit Euler-Cromer method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Update velocity\n            v = v + a * dt\n            # Update position using new velocity\n            x = x + v * dt\n        return x, v\n        \n    for case in test_cases:\n        a = case['a']\n        x0 = case['x0']\n        v0 = case['v0']\n        dt = case['dt']\n        P = case['P']\n\n        # Calculate orbital period and number of steps\n        T = 2.0 * np.pi * a**(1.5)\n        N = int(np.ceil(P * T / dt))\n\n        # Initial energy\n        H0 = hamiltonian(x0, v0)\n\n        # Run Explicit Euler simulation\n        x_N_euler, v_N_euler = run_explicit_euler(x0, v0, N, dt)\n        H_N_euler = hamiltonian(x_N_euler, v_N_euler)\n        delta_euler = np.abs(H_N_euler - H0) / np.abs(H0)\n\n        # Run Euler-Cromer simulation\n        x_N_cromer, v_N_cromer = run_euler_cromer(x0, v0, N, dt)\n        H_N_cromer = hamiltonian(x_N_cromer, v_N_cromer)\n        delta_cromer = np.abs(H_N_cromer - H0) / np.abs(H0)\n\n        # Calculate the ratio of energy drifts\n        # Handle the case where delta_euler is zero to avoid division by zero\n        if delta_euler == 0.0:\n            # If Euler has no drift, and Cromer does, ratio is infinity.\n            # If neither has drift, ratio is undefined, but 1.0 is a neutral choice.\n            # In practice, with finite precision, this is unlikely.\n            r = 1.0 if delta_cromer == 0.0 else np.inf\n        else:\n            r = delta_cromer / delta_euler\n        \n        results.append(r)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390259"}]}