{"hands_on_practices": [{"introduction": "Our journey into practical spectral analysis begins with the most fundamental of random signals: white noise. In theory, a white noise process contains equal power at all frequencies, resulting in a \"flat\" power spectral density (PSD). This exercise [@problem_id:2428968] provides a concrete way to test this concept by generating a signal that mimics random coin flips, computing its PSD, and quantifying the flatness of the resulting spectrum. Mastering this workflow is the first step toward analyzing more complex signals.", "problem": "Consider a discrete-time stochastic process obtained by sampling an independent and identically distributed sequence of fair coin flips and mapping outcomes to two fixed amplitudes. Let the sampling interval be $\\Delta t$ in seconds, so the sampling frequency is $1/\\Delta t$ in hertz. Let $N$ be the number of samples. Let the two outcome amplitudes be $a$ and $b$, treated as dimensionless. Let the generated sequence be $s[n] \\in \\{a,b\\}$ for $n \\in \\{0,1,\\dots,N-1\\}$, and define the zero-mean sequence $x[n] = s[n] - \\bar{s}$ where $\\bar{s}$ is the sample mean of $s[n]$. Define the discrete Fourier transform $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}$ for integer $k \\in \\{0,1,\\dots,N-1\\}$, and define the single-sided power spectral density estimate (with units amplitude squared per hertz) for even $N$ at the positive frequency bins by\n$$\n\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} \\left| X[k] \\right|^2 \\quad \\text{for} \\quad k \\in \\{1,2,\\dots,N/2-1\\}.\n$$\nDefine the flatness metric to be the coefficient of variation of the estimated power spectral density over the positive frequency bins excluding the direct current bin and the Nyquist bin,\n$$\nF = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)},\n$$\nwhich is dimensionless. A white process exhibits a flat spectrum, so for increasing $N$ one expects $F$ to decrease.\n\nTo ensure deterministic test cases across implementations, the sequence $s[n]$ must be generated by transforming a uniform pseudo-random number generator defined as follows. Let an integer linear congruential generator produce a sequence $\\{x_n\\}$ by $x_{n+1} = (a_{\\mathrm{LCG}} x_n) \\bmod m$ with $a_{\\mathrm{LCG}} = 16807$ and $m = 2147483647$, starting from seed $x_0$ which is a strictly positive integer less than $m$. Define $u_n = x_n / m$ and set $s[n] = a$ if $u_n < 0.5$, and $s[n] = b$ otherwise. All arithmetic in the spectral estimation steps must be carried out in real or complex floating-point, and no additional windowing or averaging beyond what is stated above should be applied.\n\nImplement a program that, for each specified test case, generates $s[n]$, constructs $x[n]$, computes $\\widehat{S}[k]$ for $k \\in \\{1,2,\\dots,N/2-1\\}$, and outputs the flatness metric $F$ as a floating-point number. Frequencies should be interpreted in hertz, and the power spectral density in amplitude squared per hertz, but the reported $F$ is dimensionless. Angles, if any appear in intermediate computations, must be in radians.\n\nUse the following test suite of parameter values, where each test case is a tuple $(N,\\Delta t,a,b,x_0)$:\n- Test case $1$: $(4096, 1.0 \\times 10^{-3}, 0, 1, 12345)$.\n- Test case $2$: $(256, 1.0 \\times 10^{-3}, 0, 1, 67890)$.\n- Test case $3$: $(65536, 1.0 \\times 10^{-4}, -1, 1, 13579)$.\n- Test case $4$: $(8192, 1.0, 0, 1, 24680)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above. For example, the output format must be exactly like $[r_1,r_2,r_3,r_4]$, where each $r_j$ is the computed floating-point value of $F$ for test case $j$.", "solution": "The problem is validated as follows.\n\n**Step 1: Extract Givens**\n-   Stochastic Process: A discrete-time sequence $s[n]$ for $n \\in \\{0,1,\\dots,N-1\\}$ derived from i.i.d. fair coin flips mapped to amplitudes $a$ and $b$.\n-   Sampling Parameters: Sampling interval $\\Delta t$ in seconds; number of samples $N$.\n-   Signal Generation: A linear congruential generator (LCG) is defined by $x_{n+1} = (a_{\\mathrm{LCG}} x_n) \\bmod m$ with $a_{\\mathrm{LCG}} = 16807$ and $m = 2147483647$. A seed $x_0$ is a positive integer less than $m$. The sequence $u_n = x_n / m$ is generated, and $s[n] = a$ if $u_n < 0.5$, otherwise $s[n] = b$.\n-   Zero-Mean Signal: $x[n] = s[n] - \\bar{s}$, where $\\bar{s} = \\frac{1}{N}\\sum_{n=0}^{N-1} s[n]$.\n-   Discrete Fourier Transform (DFT): $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}$ for $k \\in \\{0,1,\\dots,N-1\\}$.\n-   Power Spectral Density (PSD) Estimate: For even $N$, the single-sided PSD estimate is $\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} \\left| X[k] \\right|^2$ for $k \\in \\{1,2,\\dots,N/2-1\\}$.\n-   Flatness Metric: $F = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}$.\n-   Test Cases $(N,\\Delta t,a,b,x_0)$:\n    1.  $(4096, 1.0 \\times 10^{-3}, 0, 1, 12345)$\n    2.  $(256, 1.0 \\times 10^{-3}, 0, 1, 67890)$\n    3.  $(65536, 1.0 \\times 10^{-4}, -1, 1, 13579)$\n    4.  $(8192, 1.0, 0, 1, 24680)$\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is assessed against the validation criteria.\n-   **Scientifically Grounded**: The problem describes the procedure for power spectral density estimation of a discrete signal, a standard topic in digital signal processing and computational physics. The signal model (a Bernoulli process) and the analysis tools (DFT, periodogram) are fundamental concepts. The specified LCG is a well-documented generator. The problem is firmly based on established scientific and mathematical principles.\n-   **Well-Posed**: All parameters, constants, and computational steps are explicitly and unambiguously defined. The use of a specific pseudo-random number generator with a given seed ensures that the signal generation is deterministic, leading to a unique, computable solution for each test case.\n-   **Objective**: The problem is stated in precise, objective, mathematical language, free of subjective claims. The definitions are formal and allow for a single, correct interpretation of the required calculations.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. It is self-contained, scientifically sound, and well-posed. The task is a standard computational exercise in signal analysis. A solution will be provided.\n\n**Principle-Based Solution Design**\n\nThe problem requires the computation of a statistical metric, the flatness $F$, for the estimated power spectral density (PSD) of a deterministically generated stochastic signal. The solution is constructed by following the sequence of physical and mathematical definitions provided.\n\n**1. Signal Generation**\nThe foundation of the problem is the generation of a discrete-time signal $s[n]$. This signal is designed to mimic a random process. It is generated using a specific Linear Congruential Generator (LCG), a common algorithm for producing sequences of pseudo-random numbers. The LCG is defined by the recurrence relation:\n$$\nx_{i+1} = (a_{\\mathrm{LCG}} \\cdot x_i) \\pmod m\n$$\nwhere the multiplier is $a_{\\mathrm{LCG}} = 16807$ and the modulus is $m = 2147483647$. Starting with a given seed $x_0$, we generate a sequence of $N$ states $x_1, x_2, \\dots, x_N$. These integer states are then normalized to produce uniform deviates $u_n = x_{n+1}/m$ for $n \\in \\{0, 1, \\dots, N-1\\}$. A binary mapping based on a threshold of $0.5$ transforms this uniform sequence into the two-level signal $s[n]$ with amplitudes $a$ and $b$:\n$$\ns[n] = \\begin{cases} a & \\text{if } u_n < 0.5 \\\\ b & \\text{if } u_n \\ge 0.5 \\end{cases}\n$$\n\n**2. Signal Conditioning**\nThe raw signal $s[n]$ has a non-zero mean, which corresponds to a large DC component ($k=0$) in its frequency spectrum. To analyze the fluctuating (AC) part of the signal, this DC offset is removed. We compute the sample mean $\\bar{s} = \\frac{1}{N}\\sum_{n=0}^{N-1} s[n]$ and create a zero-mean signal $x[n]$:\n$$\nx[n] = s[n] - \\bar{s}\n$$\nThis step ensures that the power at zero frequency, $X[0]$, is zero, focusing the analysis on the dynamic properties of the signal.\n\n**3. Spectral Analysis via Discrete Fourier Transform**\nThe frequency content of the discrete signal $x[n]$ is revealed by its Discrete Fourier Transform (DFT), $X[k]$:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi k n / N}\n$$\nThe magnitude squared of the DFT coefficients, $|X[k]|^2$, is known as the periodogram, which is proportional to the power of the signal at the discrete frequency corresponding to index $k$. For computational efficiency, the DFT is calculated using the Fast Fourier Transform (FFT) algorithm.\n\n**4. Power Spectral Density Estimation**\nThe periodogram must be correctly scaled to represent a physical power spectral density, which has units of power per unit frequency (here, amplitude$^2$/Hz). For a real-valued signal of finite length $N$, the single-sided PSD estimate $\\widehat{S}[k]$ for positive frequencies away from DC ($k=0$) and the Nyquist frequency ($k=N/2$) is given by:\n$$\n\\widehat{S}[k] = \\frac{2\\,\\Delta t}{N} |X[k]|^2\n$$\nThe factor of $2$ accounts for folding the power from the negative frequencies (which are redundant for a real signal) onto the positive frequencies. The factor $\\Delta t / N$ converts the units from amplitude$^2$ per DFT bin to amplitude$^2$ per Hz, since the frequency resolution of the DFT is $\\Delta f = 1/(N\\Delta t)$. This calculation is performed for the frequency indices $k \\in \\{1, 2, \\dots, N/2 - 1\\}$.\n\n**5. Flatness Metric Calculation**\nThe process being modeled is an approximation of a white noise process, which theoretically has a flat power spectrum (equal power at all frequencies). The flatness of the estimated spectrum is quantified by the flatness metric $F$, defined as the coefficient of variation (the ratio of the standard deviation to the mean) of the set of computed PSD values $\\{\\widehat{S}[k]\\}$.\n$$\nF = \\frac{\\operatorname{std}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}{\\operatorname{mean}\\left(\\{\\widehat{S}[k]\\}_{k=1}^{N/2-1}\\right)}\n$$\nA value of $F$ close to $0$ would imply a nearly constant (flat) spectrum, whereas larger values indicate significant variation in power across the frequency bins. For a periodogram estimate of white noise, the values $\\widehat{S}[k]$ at different frequencies are approximately independent and exponentially distributed, for which the theoretical coefficient of variation is $1$. The sample coefficient of variation $F$ is an estimate of this value.\n\nThe implementation will systematically execute these five steps for each test case specified in the problem statement.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the power spectral density flatness problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        (4096, 1.0e-3, 0.0, 1.0, 12345),\n        (256, 1.0e-3, 0.0, 1.0, 67890),\n        (65536, 1.0e-4, -1.0, 1.0, 13579),\n        (8192, 1.0, 0.0, 1.0, 24680),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, delta_t, a, b, x0 = case\n        result = calculate_flatness(N, delta_t, a, b, x0)\n        results.append(result)\n\n    # Format the output as a comma-separated list in brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_flatness(N, delta_t, a, b, x0):\n    \"\"\"\n    Calculates the spectral flatness metric F for a given set of parameters.\n\n    Args:\n        N (int): Number of samples.\n        delta_t (float): Sampling interval in seconds.\n        a (float): First outcome amplitude.\n        b (float): Second outcome amplitude.\n        x0 (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        float: The computed flatness metric F.\n    \"\"\"\n    \n    # LCG parameters from the problem statement\n    A_LCG = 16807\n    M = 2147483647\n\n    # Step 1: Generate the signal sequence s[n] using the LCG.\n    # The LCG generates N states x_1, ..., x_N from the seed x_0.\n    # These states are used to generate s[0], ..., s[N-1].\n    s = np.zeros(N, dtype=np.float64)\n    x_current = x0\n    for n in range(N):\n        x_current = (A_LCG * x_current) % M\n        u_n = x_current / M\n        if u_n < 0.5:\n            s[n] = a\n        else:\n            s[n] = b\n\n    # Step 2: Create the zero-mean sequence x[n].\n    s_mean = np.mean(s)\n    x = s - s_mean\n\n    # Step 3: Compute the Discrete Fourier Transform (DFT).\n    #\n    # np.fft.fft provides an efficient implementation (FFT).\n    X = np.fft.fft(x)\n\n    # Step 4: Compute the single-sided Power Spectral Density (PSD) estimate.\n    # The problem specifies the range for k from 1 to N/2 - 1.\n    # In Python's 0-based indexing, this corresponds to the slice [1:N//2].\n    # N is guaranteed to be even in all test cases.\n    N_div_2 = N // 2\n    \n    # Extract the relevant DFT components.\n    X_pos = X[1:N_div_2]\n    \n    # Calculate the PSD S_hat[k] = (2 * dt / N) * |X[k]|^2.\n    S_hat = (2 * delta_t / N) * np.abs(X_pos)**2\n\n    # Step 5: Compute the flatness metric F.\n    # F is the coefficient of variation (std/mean) of the PSD values.\n    # np.std uses a divisor of M (number of elements) by default (ddof=0),\n    # which is appropriate here.\n    mean_S = np.mean(S_hat)\n    std_S = np.std(S_hat)\n\n    # Handle the case where the mean is zero to avoid division by zero.\n    if mean_S == 0:\n        return 0.0\n\n    F = std_S / mean_S\n    return F\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2428968"}, {"introduction": "In the real world, we can only observe signals for a finite amount of time. This seemingly simple constraint introduces a critical artifact known as spectral leakage. This exercise [@problem_id:2429045] demonstrates how a pure sinusoid's energy appears to \"leak\" into neighboring frequency bins when we analyze a finite segment. You will then explore how applying a smooth window function, such as a Hann window, can dramatically reduce this distortion, a vital technique for obtaining accurate spectral estimates from any finite data record.", "problem": "You are given a pure sinusoid sampled uniformly in time, and your task is to demonstrate spectral leakage via power spectral density estimation using the Discrete Fourier Transform (DFT). Begin from fundamental definitions: the Discrete Fourier Transform (DFT) of a discrete-time sequence $x[n]$ of length $N$ is $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi kn/N}$, where $k \\in \\{0,1,\\dots,N-1\\}$, and $j$ is the imaginary unit. The sampling frequency is $F_s$ so that the sampling interval is $\\Delta t = 1/F_s$, and the DFT frequency resolution is $\\Delta f = F_s/N$. Windowing is defined by a real sequence $w[n]$ applied pointwise to $x[n]$, producing $x_w[n]=w[n]x[n]$. Use the conservation of energy in discrete time (Parseval’s relation) together with these definitions to construct a one-sided periodogram estimator of the power spectral density (PSD) with proper window power normalization. All trigonometric arguments must be in radians.\n\nYour program must:\n- Construct the discrete-time signal $x[n] = \\sin(2\\pi f_0 n / F_s)$ for $n \\in \\{0,1,\\dots,N-1\\}$.\n- Apply a chosen window $w[n]$ (either a rectangular window $w[n]=1$ or a Hann window, $w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$) to form $x_w[n]=w[n]x[n]$.\n- Compute an $N$-point DFT (no zero-padding) and form a one-sided periodogram PSD estimate $P[k]$ for frequencies $f_k = k \\Delta f$ with $k \\in \\{0,1,\\dots,\\tfrac{N}{2}\\}$, using window power normalization based on the average squared window. Ensure that the one-sided spectrum correctly accounts for the discarded negative-frequency content by doubling the power for bins strictly between direct current (DC) and the Nyquist frequency when $N$ is even.\n- Define the leakage ratio $\\mathcal{L}$ as the fraction of total one-sided spectral power that lies outside the main lobe around the peak, where the main lobe is operationally defined as the set of frequency bins whose PSD is within $-6$ decibels of the peak value. In symbols: find the peak bin index $k_{\\max}$ such that $P[k_{\\max}]$ is maximal; define the main-lobe index set $\\mathcal{M} = \\{k : 10 \\log_{10}(P[k]/P[k_{\\max}]) \\ge -6\\}$; then compute the leakage ratio as $\\mathcal{L} = 1 - \\frac{\\sum_{k \\in \\mathcal{M}} P[k]}{\\sum_{k} P[k]}$. The decibel conversion uses $10 \\log_{10}(\\cdot)$ applied to power ratios.\n- For each test case, output the leakage ratio as a floating-point number. The sinusoid amplitude is $1$.\n\nTest suite:\n- Case $1$ (non-integer-bin, rectangular window): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.5 \\,\\mathrm{Hz}$, window type “rectangular”.\n- Case $2$ (non-integer-bin, Hann window): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.5 \\,\\mathrm{Hz}$, window type “Hann”.\n- Case $3$ (exact-bin, rectangular window): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.0 \\,\\mathrm{Hz}$, window type “rectangular”.\n- Case $4$ (small offset, rectangular window): $F_s = 1024 \\,\\mathrm{Hz}$, $N = 1024$, $f_0 = 128.01 \\,\\mathrm{Hz}$, window type “rectangular”.\n- Case $5$ (short record, non-integer-bin, rectangular window): $F_s = 256 \\,\\mathrm{Hz}$, $N = 256$, $f_0 = 50.3 \\,\\mathrm{Hz}$, window type “rectangular”.\n\nAngle unit requirement: all angles used in trigonometric functions must be in radians.\n\nFinal output format:\n- Your program should produce a single line of output containing the leakage ratios for the five cases in the order listed above, formatted as a comma-separated list enclosed in square brackets, with each leakage ratio rounded to six decimal places, for example, “$[0.123456,0.234567,0.345678,0.456789,0.567890]$”.", "solution": "The problem presented is a valid and well-posed exercise in computational physics, specifically in the domain of digital signal processing. It requires the calculation of spectral leakage from a periodogram estimate of a pure sinusoidal signal under different conditions. The provided definitions are standard and self-consistent, enabling a direct and unambiguous solution.\n\nThe solution proceeds systematically, beginning from first principles.\n\n**1. Signal and Windowing Model**\n\nThe discrete-time signal is a pure sinusoid of amplitude $A=1$, sampled at a frequency $F_s$ over $N$ points. The signal is defined as:\n$$x[n] = \\sin\\left(\\frac{2\\pi f_0 n}{F_s}\\right), \\quad n \\in \\{0, 1, \\dots, N-1\\}$$\nwhere $f_0$ is the frequency of the sinusoid.\n\nThis signal is then multiplied by a window function $w[n]$ to produce the windowed signal $x_w[n]$:\n$$x_w[n] = w[n] x[n]$$\nThe problem specifies two window types:\n- **Rectangular window**: $w[n] = 1$ for all $n$.\n- **Hann window**: $w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$.\n\n**2. Power Spectrum Estimation**\n\nThe core of the problem is to construct a properly normalized, one-sided power spectrum. We begin with the Discrete Fourier Transform (DFT) of the windowed signal:\n$$X_w[k] = \\sum_{n=0}^{N-1} x_w[n] e^{-j 2\\pi kn/N}$$\n\nTo ensure the estimated power is independent of the window function's gain, we must normalize the spectrum. Parseval's theorem for discrete signals relates the signal's energy in the time domain to its energy in the frequency domain:\n$$\\sum_{n=0}^{N-1} |x_w[n]|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\nThe average power of the windowed signal over the $N$ samples is $P_{\\text{avg},w} = \\frac{1}{N} \\sum_{n=0}^{N-1} |x_w[n]|^2$. Therefore:\n$$P_{\\text{avg},w} = \\frac{1}{N^2} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\nThe average power of the original signal $x[n]$ is related to that of the windowed signal. For a sinusoidal signal, the windowing process scales the power by a factor equal to the mean square of the window function. The estimated average power of the original signal, $P_{\\text{avg},x}$, is thus:\n$$P_{\\text{avg},x} = \\frac{P_{\\text{avg},w}}{\\frac{1}{N}\\sum_{n=0}^{N-1} w[n]^2} = \\frac{N}{\\sum_{n=0}^{N-1} w[n]^2} P_{\\text{avg},w}$$\nLet's denote the sum of squared window weights as $S_2 = \\sum_{n=0}^{N-1} w[n]^2$. The total estimated power of the original signal is:\n$$P_{\\text{total}} = P_{\\text{avg},x} = \\frac{N}{S_2} \\left( \\frac{1}{N^2} \\sum_{k=0}^{N-1} |X_w[k]|^2 \\right) = \\frac{1}{S_2 N} \\sum_{k=0}^{N-1} |X_w[k]|^2$$\nFor a real-valued input signal $x[n]$, the DFT is conjugate symmetric: $X_w[k] = X_w^*[N-k]$. This implies $|X_w[k]|^2 = |X_w[N-k]|^2$. We can construct a one-sided power spectrum $P[k]$ for $k \\in \\{0, 1, \\dots, N/2\\}$ that preserves the total power. The summation over the two-sided spectrum can be re-written (for even $N$):\n$$\\sum_{k=0}^{N-1} |X_w[k]|^2 = |X_w[0]|^2 + |X_w[N/2]|^2 + 2\\sum_{k=1}^{N/2-1} |X_w[k]|^2$$\nWe define the one-sided power spectrum $P[k]$ such that its sum equals the total average power $P_{\\text{total}}$. The components of $P[k]$ are the power contained in each frequency bin $k$:\n$$P[k] = \\begin{cases} \\frac{1}{S_2 N} |X_w[k]|^2 & \\text{for } k=0 \\text{ and } k=N/2 \\\\ \\frac{2}{S_2 N} |X_w[k]|^2 & \\text{for } k=1, 2, \\dots, N/2-1 \\end{cases}$$\nThe sum $\\sum_{k=0}^{N/2} P[k]$ correctly yields the total average power of the original signal. Given $x[n]$ is a sinusoid with amplitude $A=1$, its true average power is $A^2/2 = 1/2$. Our estimator $\\sum P[k]$ will approximate this value.\n\n**3. Leakage Ratio Calculation**\n\nThe spectral leakage ratio $\\mathcal{L}$ is defined as the fraction of total power lying outside the main lobe of the spectral peak.\nFirst, we find the maximum value of the power spectrum, $P_{\\max} = \\max_k P[k]$. The main lobe is operationally defined as the set of frequency bins $\\mathcal{M}$ whose power is within $-6$ decibels of the peak:\n$$\\mathcal{M} = \\left\\{k \\mid 10 \\log_{10}\\left(\\frac{P[k]}{P_{\\max}}\\right) \\ge -6\\right\\}$$\nThis inequality is equivalent to $P[k] \\ge P_{\\max} \\cdot 10^{-0.6}$.\n\nThe total power in the main lobe is $P_{\\text{lobe}} = \\sum_{k \\in \\mathcal{M}} P[k]$. The total power across the entire spectrum is $P_{\\text{total}} = \\sum_{k=0}^{N/2} P[k]$.\nThe leakage ratio is then computed as:\n$$\\mathcal{L} = 1 - \\frac{P_{\\text{lobe}}}{P_{\\text{total}}}$$\n\nThis procedure is implemented for each test case to determine the leakage ratio under the specified conditions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the spectral leakage ratio for a sinusoidal signal under various\n    windowing and frequency conditions.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Fs, N, f0, window_type)\n        (1024.0, 1024, 128.5, \"rectangular\"),\n        (1024.0, 1024, 128.5, \"Hann\"),\n        (1024.0, 1024, 128.0, \"rectangular\"),\n        (1024.0, 1024, 128.01, \"rectangular\"),\n        (256.0, 256, 50.3, \"rectangular\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        Fs, N, f0, window_type = case\n        \n        # 1. Signal Generation\n        # Construct the time vector for N samples.\n        n = np.arange(N)\n        # Generate the sinusoidal signal with amplitude 1.\n        x = np.sin(2 * np.pi * f0 * n / Fs)\n\n        # 2. Windowing\n        # Apply the specified window function.\n        if window_type == \"rectangular\":\n            w = np.ones(N)\n        elif window_type == \"Hann\":\n            # Per problem: w[n] = 1/2 * (1 - cos(2*pi*n / (N-1)))\n            w = 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1)))\n        \n        x_w = x * w\n\n        # 3. N-point DFT\n        # Compute the DFT of the windowed signal.\n        X_w = np.fft.fft(x_w, n=N)\n\n        # 4. One-sided Power Spectrum Estimation\n        # All test cases have even N. The one-sided spectrum has N/2 + 1 points.\n        num_freq_bins = N // 2 + 1\n        X_w_mag_sq = np.abs(X_w[0:num_freq_bins])**2\n        \n        # Calculate the sum of squares of the window for normalization.\n        S2 = np.sum(w**2)\n        \n        # Initialize the power spectrum array.\n        P = np.zeros(num_freq_bins)\n        \n        # Normalization ensures the sum of P[k] approximates the true signal power (0.5).\n        # Normalization constant for DC and Nyquist bins.\n        norm_const_dc_nyquist = 1.0 / (S2 * N)\n        # Normalization constant for other bins (doubled for one-sided spectrum).\n        norm_const_other = 2.0 / (S2 * N)\n\n        # Calculate power for bins from k=1 to k=N/2 - 1.\n        P[1:-1] = norm_const_other * X_w_mag_sq[1:-1]\n        \n        # Calculate power for DC (k=0) and Nyquist (k=N/2) bins.\n        P[0] = norm_const_dc_nyquist * X_w_mag_sq[0]\n        P[-1] = norm_const_dc_nyquist * X_w_mag_sq[-1]\n\n        # 5. Leakage Ratio Calculation\n        P_total = np.sum(P)\n        \n        # Handle the ideal case where total power is numerically zero.\n        if P_total < 1e-15:\n            leakage_ratio = 0.0\n        else:\n            P_max = np.max(P)\n            # Main lobe is defined as all bins within -6 dB of the peak value.\n            # This corresponds to a linear magnitude ratio of 10^(-6/10).\n            db_threshold_ratio = 10**(-6.0 / 10.0)\n            main_lobe_mask = P >= P_max * db_threshold_ratio\n            \n            # Sum the power within the main lobe.\n            P_lobe = np.sum(P[main_lobe_mask])\n            \n            # Leakage ratio is the fraction of power outside the main lobe.\n            leakage_ratio = 1.0 - (P_lobe / P_total)\n            \n        results.append(leakage_ratio)\n\n    # Final print statement in the exact required format.\n    # Format each result to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2429045"}, {"introduction": "Beyond simply identifying the frequency content of a signal, the PSD is a powerful tool for diagnosing how signals are transformed by physical systems. This practice explores the phenomenon of nonlinear frequency mixing, where new frequencies are generated when a signal passes through a nonlinear medium. By squaring a signal composed of two sinusoids and analyzing the resulting PSD, you will learn to detect the predicted sum ($f_1 + f_2$) and difference ($|f_1 - f_2|$) frequencies, a key diagnostic skill in fields from radio engineering to nonlinear optics [@problem_id:2429016].", "problem": "You will implement and analyze a nonlinear frequency-mixing experiment in the discrete-time domain using power spectral density estimation. The underlying fundamental base you must rely on consists of: the definition of the Fourier transform as a linear transform connecting time-domain and frequency-domain descriptions, the Nyquist sampling theorem that constrains resolvable frequencies for a given sampling rate, the definition of power spectral density (PSD) as the Fourier transform of the autocorrelation function (Wiener–Khinchin theorem), and the property that multiplication in the time domain corresponds to convolution in the frequency domain. No other pre-derived or shortcut formulas may be used in your derivation. Angles must be in radians.\n\nConstruct a discrete-time signal that is a sum of two sinusoids with user-specified frequencies, sample rate, and phases. Add zero-mean white Gaussian noise, square the noisy signal, estimate the one-sided power spectral density (PSD) of the squared signal using Welch’s method, and detect the spectral peaks corresponding to the sum and difference frequencies predicted by nonlinear mixing.\n\nTasks and constraints:\n- Signal model and units:\n  - Let the sampling frequency be $f_s$ in $\\mathrm{Hz}$ and the number of samples be $N$ (dimensionless). Define the discrete time instants as $t_n = n / f_s$ in $\\mathrm{s}$ for $n \\in \\{0,1,\\dots,N-1\\}$.\n  - Construct a clean signal $x[n] = A_1 \\sin\\!\\left(2\\pi f_1 t_n + \\phi_1\\right) + A_2 \\sin\\!\\left(2\\pi f_2 t_n + \\phi_2\\right)$, where $A_1$ and $A_2$ are amplitudes (dimensionless), $f_1$ and $f_2$ are frequencies in $\\mathrm{Hz}$, and $\\phi_1,\\phi_2$ are phases in $\\mathrm{rad}$.\n  - Add zero-mean white Gaussian noise $\\eta[n]$ with standard deviation $\\sigma_n$ (dimensionless) to form $u[n] = x[n] + \\eta[n]$.\n  - Form the squared signal $y[n] = \\left(u[n]\\right)^2$.\n- PSD estimation:\n  - Estimate the one-sided PSD $S_{yy}(f)$ using Welch’s method with a Hann window. Use a segment length $L$ equal to the largest power of two that does not exceed $N/2$, but at least $256$ samples. Use $0.5$ overlap of the segment length. Use density scaling so that $S_{yy}(f)$ has units of signal power per $\\mathrm{Hz}$.\n  - The frequency axis must be in $\\mathrm{Hz}$.\n- Peak detection for nonlinear mixing:\n  - Define the theoretical target frequencies $f_{\\mathrm{sum}} = f_1 + f_2$ and $f_{\\mathrm{diff}} = |f_1 - f_2|$, both in $\\mathrm{Hz}$. Ensure all specified cases satisfy $f_{\\mathrm{sum}} \\le f_s/2$ so that the sum component is not beyond the Nyquist frequency.\n  - Let the Welch frequency-bin spacing be $\\Delta f = f_s / L$. For each target $f_0 \\in \\{f_{\\mathrm{sum}}, f_{\\mathrm{diff}}\\}$, search for the dominant PSD peak within a symmetric frequency window of half-width $w = \\max\\{5, 3\\Delta f\\}$ in $\\mathrm{Hz}$ around $f_0$. If $f_0 = 0$, search over $[0, w]$.\n  - Let the tolerance for a correct detection be $\\tau = \\max\\{\\Delta f, 0.5\\}$ in $\\mathrm{Hz}$. Report a detection boolean that is true if the absolute difference between the estimated peak location $\\hat f$ and the target $f_0$ is at most $\\tau$.\n- Output specification:\n  - For each test case, return a list containing four values: the estimated sum-frequency peak $\\hat f_{\\mathrm{sum}}$ in $\\mathrm{Hz}$ rounded to three decimals, the estimated difference-frequency peak $\\hat f_{\\mathrm{diff}}$ in $\\mathrm{Hz}$ rounded to three decimals, the detection boolean for the sum component, and the detection boolean for the difference component.\n  - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The top-level list must contain one such four-element list per test case. For example, the overall output must look like $[[\\hat f_{\\mathrm{sum}}^{(1)}, \\hat f_{\\mathrm{diff}}^{(1)}, \\mathrm{det}_{\\mathrm{sum}}^{(1)}, \\mathrm{det}_{\\mathrm{diff}}^{(1)}], \\dots ]$.\n- Angle unit: All angles must be in $\\mathrm{rad}$. All frequencies must be expressed in $\\mathrm{Hz}$.\n\nTest suite:\nFor each test case, the parameter tuple is $(f_s, N, f_1, f_2, A_1, A_2, \\sigma_n, \\mathrm{seed})$ with the following values:\n- Case $1$: $(2000, 4096, 123, 278, 1.0, 0.8, 0.2, 42)$, so $f_{\\mathrm{sum}} = 401$ and $f_{\\mathrm{diff}} = 155$.\n- Case $2$: $(1200, 4096, 280, 300, 1.0, 1.0, 0.15, 7)$, so $f_{\\mathrm{sum}} = 580$ and $f_{\\mathrm{diff}} = 20$.\n- Case $3$: $(1000, 4096, 200, 200, 0.7, 0.7, 0.1, 0)$, so $f_{\\mathrm{sum}} = 400$ and $f_{\\mathrm{diff}} = 0$.\n- Case $4$: $(2000, 16384, 245, 250, 0.9, 1.0, 0.3, 123)$, so $f_{\\mathrm{sum}} = 495$ and $f_{\\mathrm{diff}} = 5$.\n\nRequirements:\n- Implement your solution as a complete, runnable program that constructs the signals, computes the PSD estimates with the specified Welch configuration, searches for peaks near $f_{\\mathrm{sum}}$ and $f_{\\mathrm{diff}}$ as specified, and outputs the results in the exact format described. Use the provided seeds for random number generation to ensure reproducibility.", "solution": "The problem presented is a well-defined exercise in computational physics and signal processing. It requires the implementation of a numerical experiment to demonstrate the phenomenon of nonlinear frequency mixing. Before proceeding to the computational solution, it is imperative to establish the theoretical foundations upon which the analysis rests. The problem statement is deemed valid, as it is scientifically grounded, self-contained, and algorithmically specified. A minor ambiguity regarding signal phases is resolved by adopting the standard convention of setting them to zero, as the power spectrum of the resulting signal is largely insensitive to this choice under the specified conditions.\n\nThe core of the problem lies in the squaring of a composite sinusoidal signal, which is a nonlinear operation. Let us first analyze the effect of this operation in the absence of noise. The signal is given by $x[n] = A_1 \\sin(2\\pi f_1 t_n + \\phi_1) + A_2 \\sin(2\\pi f_2 t_n + \\phi_2)$. For simplicity and without loss of generality for this power spectrum analysis, we set the phases $\\phi_1=0$ and $\\phi_2=0$. Writing $\\omega_i = 2\\pi f_i$ and $t_n = n/f_s$, the squared signal is:\n$$\ny[n] = (x[n])^2 = \\left( A_1 \\sin(\\omega_1 t_n) + A_2 \\sin(\\omega_2 t_n) \\right)^2\n$$\nExpanding this expression yields:\n$$\ny[n] = A_1^2 \\sin^2(\\omega_1 t_n) + A_2^2 \\sin^2(\\omega_2 t_n) + 2 A_1 A_2 \\sin(\\omega_1 t_n) \\sin(\\omega_2 t_n)\n$$\nWe apply standard trigonometric identities: $\\sin^2\\theta = \\frac{1}{2}(1 - \\cos(2\\theta))$ and $\\sin\\alpha\\sin\\beta = \\frac{1}{2}(\\cos(\\alpha-\\beta) - \\cos(\\alpha+\\beta))$. Substituting these gives:\n$$\ny[n] = \\frac{A_1^2}{2} (1 - \\cos(2\\omega_1 t_n)) + \\frac{A_2^2}{2} (1 - \\cos(2\\omega_2 t_n)) + A_1 A_2 \\left(\\cos((\\omega_1 - \\omega_2)t_n) - \\cos((\\omega_1 + \\omega_2)t_n)\\right)\n$$\nCollecting terms based on their frequency content, we find:\n$$\ny[n] = \\underbrace{\\frac{A_1^2 + A_2^2}{2}}_{\\text{DC component at } 0\\,\\mathrm{Hz}} - \\underbrace{\\frac{A_1^2}{2}\\cos(2\\omega_1 t_n) - \\frac{A_2^2}{2}\\cos(2\\omega_2 t_n)}_{\\text{Second harmonics at } 2f_1, 2f_2} + \\underbrace{A_1 A_2 \\cos((\\omega_1 - \\omega_2)t_n)}_{\\text{Difference frequency at } |f_1-f_2|} - \\underbrace{A_1 A_2 \\cos((\\omega_1 + \\omega_2)t_n)}_{\\text{Sum frequency at } f_1+f_2}\n$$\nThis derivation rigorously shows that the nonlinear squaring operation generates new spectral components. Specifically, we expect to see power concentrated at the sum frequency, $f_{\\mathrm{sum}} = f_1+f_2$, and the difference frequency, $f_{\\mathrm{diff}} = |f_1-f_2|$. The problem mandates the detection of these two components.\n\nThe introduction of additive white Gaussian noise, $\\eta[n]$, modifies the signal to be squared: $u[n] = x[n] + \\eta[n]$. The resulting signal is $y[n] = u[n]^2 = x[n]^2 + 2x[n]\\eta[n] + \\eta[n]^2$. The term $x[n]^2$ contains the deterministic peaks derived above. The cross-term $2x[n]\\eta[n]$ and the noise-squared term $\\eta[n]^2$ contribute to a broadened noise floor in the power spectrum, which complicates peak detection. The $\\eta[n]^2$ term, being the square of a zero-mean Gaussian process, has a non-zero mean $\\mathbb{E}[\\eta[n]^2] = \\sigma_n^2$, which adds to the DC component of $y[n]$.\n\nTo estimate the power spectral density (PSD), $S_{yy}(f)$, we employ Welch's method as specified. This method mitigates the high variance inherent in simpler estimators like the periodogram. The procedure is as follows:\n$1$. The signal $y[n]$ of length $N$ is partitioned into overlapping segments of length $L$.\n$2$. Each segment is multiplied by a window function—in this case, a Hann window—to reduce spectral leakage caused by the finite segment length.\n$3$. The Fast Fourier Transform (FFT) is computed for each windowed segment, and the squared magnitude of the result provides a periodogram for that segment.\n$4$. The final PSD estimate is obtained by averaging these periodograms across all segments. Normalization is applied to yield a one-sided PSD in units of power per Hertz.\n\nThe computational implementation will proceed with the following steps for each test case:\n$1$. **Signal Generation**: A discrete time vector $t_n$ is created. The noise-free signal $x[n]$ is synthesized using the provided parameters. Zero-mean Gaussian noise $\\eta[n]$ is generated using the specified seed and standard deviation $\\sigma_n$, and added to $x[n]$ to form $u[n]$. The final signal for analysis is $y[n] = u[n]^2$.\n$2$. **PSD Estimation**: The segment length $L$ is determined as the largest power of $2$ not exceeding $N/2$, with a minimum of $256$. The `scipy.signal.welch` function is used to compute the one-sided PSD, $S_{yy}(f)$, configured with a Hann window, $50\\%$ overlap, and 'density' scaling.\n$3$. **Peak Detection**: For each target frequency $f_0 \\in \\{f_{\\mathrm{sum}}, f_{\\mathrm{diff}}\\}$, where $f_{\\mathrm{sum}} = f_1+f_2$ and $f_{\\mathrm{diff}} = |f_1-f_2|$, a search for the maximum PSD value is conducted. The search is performed within a frequency window $[f_0 - w, f_0 + w]$, where the half-width $w = \\max\\{5, 3\\Delta f\\}$ and $\\Delta f = f_s/L$ is the frequency resolution of the Welch estimate. For the special case $f_0=0$, the search window is $[0, w]$.\n$4$. **Result Validation**: The frequency $\\hat{f}$ corresponding to the detected peak is compared against the theoretical target $f_0$. A detection is considered successful if $|\\hat{f} - f_0| \\le \\tau$, where the tolerance $\\tau = \\max\\{\\Delta f, 0.5\\}$.\n$5$. **Output Formatting**: The discovered peak frequencies $\\hat{f}_{\\mathrm{sum}}$ and $\\hat{f}_{\\mathrm{diff}}$ (rounded to three decimal places) and their corresponding boolean detection statuses are collected and formatted as specified.\n\nThis structured approach ensures that the analysis is performed in strict accordance with the problem's requirements and is grounded in established signal processing principles.", "answer": "```python\nimport numpy as np\nfrom scipy.signal import welch\n\ndef solve():\n    \"\"\"\n    Implements and analyzes a nonlinear frequency-mixing experiment.\n    \"\"\"\n    # Test cases: (fs, N, f1, f2, A1, A2, sigma_n, seed)\n    test_cases = [\n        (2000, 4096, 123, 278, 1.0, 0.8, 0.2, 42),\n        (1200, 4096, 280, 300, 1.0, 1.0, 0.15, 7),\n        (1000, 4096, 200, 200, 0.7, 0.7, 0.1, 0),\n        (2000, 16384, 245, 250, 0.9, 1.0, 0.3, 123),\n    ]\n\n    results = []\n\n    def find_peak(freqs, syy, f_target, w, tau):\n        \"\"\"\n        Searches for a peak in the PSD within a specified window and validates it.\n        \"\"\"\n        if f_target == 0:\n            search_min, search_max = 0.0, w\n        else:\n            search_min, search_max = f_target - w, f_target + w\n        \n        search_indices = np.where((freqs >= search_min) & (freqs <= search_max))[0]\n        \n        if len(search_indices) == 0:\n            f_peak = -1.0  # Sentinel for not found\n            detected = False\n        else:\n            peak_idx_local = np.argmax(syy[search_indices])\n            peak_idx_global = search_indices[peak_idx_local]\n            f_peak = freqs[peak_idx_global]\n            detected = abs(f_peak - f_target) <= tau\n            \n        return f_peak, detected\n\n    for case in test_cases:\n        fs, N, f1, f2, A1, A2, sigma_n, seed = case\n        \n        # As phases are not specified, they are set to 0 radians.\n        phi1, phi2 = 0.0, 0.0\n\n        # Step 1: Signal Generation\n        t = np.arange(N) / fs\n        x_n = A1 * np.sin(2 * np.pi * f1 * t + phi1) + A2 * np.sin(2 * np.pi * f2 * t + phi2)\n        \n        rng = np.random.default_rng(seed)\n        eta_n = rng.normal(loc=0.0, scale=sigma_n, size=N)\n        u_n = x_n + eta_n\n        \n        y_n = u_n**2\n        \n        # Step 2: PSD Estimation using Welch's method\n        l0 = 1 << int(np.log2(N / 2))\n        L = max(l0, 256)\n        n_overlap = L // 2\n        \n        freqs, Syy = welch(\n            y_n,\n            fs=fs,\n            window='hann',\n            nperseg=L,\n            noverlap=n_overlap,\n            scaling='density',\n            return_onesided=True\n        )\n        \n        # Step 3 & 4: Peak Detection and Validation\n        f_sum_target = f1 + f2\n        f_diff_target = abs(f1 - f2)\n        \n        delta_f = fs / L\n        w = max(5, 3 * delta_f)\n        tau = max(delta_f, 0.5)\n        \n        f_sum_peak, sum_detected = find_peak(freqs, Syy, f_sum_target, w, tau)\n        f_diff_peak, diff_detected = find_peak(freqs, Syy, f_diff_target, w, tau)\n\n        results.append([\n            round(f_sum_peak, 3), \n            round(f_diff_peak, 3), \n            sum_detected, \n            diff_detected\n        ])\n\n    # Final print statement in the exact required format.\n    inner_strs = []\n    for res in results:\n        f_sum_p, f_diff_p, s_det, d_det = res\n        inner_strs.append(f\"[{f_sum_p},{f_diff_p},{str(s_det).lower()},{str(d_det).lower()}]\")\n    print(f\"[{','.join(inner_strs)}]\")\n\nsolve()\n```", "id": "2429016"}]}