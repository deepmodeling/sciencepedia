{"hands_on_practices": [{"introduction": "We begin our exploration with a familiar visual illusion: the \"wagon-wheel effect,\" where a rapidly spinning wheel with true rotational frequency $f_{rot}$ appears to rotate slowly or even backward when filmed at a camera frame rate of $f_{fps}$. This phenomenon is a perfect real-world example of temporal aliasing, where discrete sampling can misinterpret high-frequency motion. This first practice challenges you to build a computational model that predicts the perceived rotation from first principles, providing a strong and memorable intuition for how aliasing works. [@problem_id:2373299]", "problem": "You are asked to model temporal aliasing (the \"wagon-wheel effect\") as a sampling problem of a rotating phase. Consider a rigid wheel with a single distinguishable marker on its rim, rotating at constant rotation frequency $f_{rot}$ in hertz (cycles per second). An ideal camera samples the wheelâ€™s state at uniform intervals with frame rate $f_{fps}$ in hertz, with instantaneous exposures (no motion blur). The angular phase of the marker is $\\phi(t) = 2\\pi f_{rot} t + \\phi_0$, with $\\phi_0 = 0$ without loss of generality. Let the sampling times be $t_n = n/f_{fps}$ for integer $n$. The frame-to-frame phase increment is $\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$, which is the same for all $n$.\n\nAssume the human perceptual system selects the smallest-magnitude frame-to-frame change that is consistent with the sampled images, i.e., the unique representative $\\Delta \\phi^{*}$ that is congruent to $\\Delta \\phi$ modulo $2\\pi$ and lies in the interval $(-\\pi, \\pi]$. Define the perceived continuous-time rotation frequency (in hertz) as $f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$, and the perceived direction as the integer $s \\in \\{-1, 0, +1\\}$ given by $s = \\operatorname{sgn}(\\Delta \\phi^{*})$, with the convention that $s = 0$ when $f_{perc} = 0$ exactly. This convention deterministically resolves the boundary case $\\Delta \\phi \\equiv \\pi \\pmod{2\\pi}$ by taking $\\Delta \\phi^{*} = +\\pi$.\n\nYour task is to write a complete, runnable program that:\n- For each test case below, takes $f_{rot}$ and $f_{fps}$ as inputs (both in hertz).\n- Computes the perceived frequency $f_{perc}$ in hertz and the perceived direction $s$ using only the principles and definitions stated above.\n- Expresses $f_{perc}$ in hertz rounded to $6$ decimal places.\n- Returns, for each test case, a list of the form $[f_{perc}, s]$.\n\nPhysical units: All frequencies must be expressed in hertz (Hz). Angles are handled internally in radians. Directions must be the integers $-1$, $0$, or $+1$. Round $f_{perc}$ to $6$ decimal places.\n\nTest suite of parameter values (happy path, edge, and boundary cases), each given as $(f_{rot}, f_{fps})$ in hertz:\n- Case $1$: $(2.3,\\, 24.0)$\n- Case $2$: $(23.0,\\, 24.0)$\n- Case $3$: $(12.0,\\, 24.0)$\n- Case $4$: $(48.0,\\, 24.0)$\n- Case $5$: $(-1.2,\\, 24.0)$\n- Case $6$: $(103.0,\\, 24.0)$\n- Case $7$: $(0.49,\\, 24.0)$\n- Case $8$: $(31.0,\\, 30.0)$\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element is itself a list $[f_{perc}, s]$ for one test case, where $f_{perc}$ is a float written with exactly $6$ decimal places and $s$ is an integer. For example, the overall structure must look like $[[f_1, s_1],[f_2, s_2],\\ldots]$ with the specified numeric formatting, such as $[[2.300000,1],[1.000000,-1],\\ldots]$. No additional text should be printed.", "solution": "The problem statement has been subjected to a rigorous validation process.\n\nThe givens are:\n- Angular phase of a marker on a rotating wheel: $\\phi(t) = 2\\pi f_{rot} t$, where $f_{rot}$ is the rotation frequency in hertz.\n- Sampling times by a camera with frame rate $f_{fps}$: $t_n = n/f_{fps}$ for integer $n \\ge 0$.\n- Frame-to-frame phase increment: $\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n)$.\n- Perceived phase increment, $\\Delta \\phi^{*}$, is the unique representative of $\\Delta \\phi$ congruent modulo $2\\pi$ such that $\\Delta \\phi^{*} \\in (-\\pi, \\pi]$.\n- Perceived frequency: $f_{perc} = \\dfrac{f_{fps}}{2\\pi}\\,|\\Delta \\phi^{*}|$.\n- Perceived direction: $s = \\operatorname{sgn}(\\Delta \\phi^{*})$, with $s=0$ if $\\Delta \\phi^{*} = 0$.\n\nThe validation confirms that the problem is scientifically grounded, well-posed, and objective. It provides a clear, formal model of the temporal aliasing phenomenon, based on fundamental principles of signal sampling theory. All terms are unambiguously defined, and the required computations are mathematically sound and lead to a unique solution. The problem is therefore deemed valid, and a solution is derived as follows.\n\nThe analysis begins by deriving the frame-to-frame phase increment, $\\Delta \\phi$. Substituting the expressions for the phase $\\phi(t)$ and the sampling times $t_n$ into the definition of $\\Delta \\phi$:\n$$\n\\Delta \\phi = \\phi(t_{n+1}) - \\phi(t_n) = 2\\pi f_{rot} \\left(\\frac{n+1}{f_{fps}}\\right) - 2\\pi f_{rot} \\left(\\frac{n}{f_{fps}}\\right)\n$$\nSimplifying the expression yields a constant phase increment:\n$$\n\\Delta \\phi = 2\\pi f_{rot} \\left(\\frac{n+1-n}{f_{fps}}\\right) = 2\\pi \\frac{f_{rot}}{f_{fps}}\n$$\nThe core of the problem lies in the perceptual model, which maps the true phase increment $\\Delta \\phi$ to its perceived counterpart $\\Delta \\phi^{*}$. This is a mathematical wrapping operation. We must find an integer $k$ representing the number of full $2\\pi$ rotations that are perceptually discarded, such that:\n$$\n\\Delta \\phi^{*} = \\Delta \\phi - 2\\pi k\n$$\nand $\\Delta \\phi^{*}$ falls within the specified principal interval $(-\\pi, \\pi]$.\n\nTo systematically find $k$, we can work with normalized frequencies and phases. Let $x$ be the ratio of the rotation frequency to the sampling frequency:\n$$\nx = \\frac{f_{rot}}{f_{fps}}\n$$\nThe normalized phase increment is $\\frac{\\Delta \\phi}{2\\pi} = x$. We seek a normalized perceived phase increment $p = \\frac{\\Delta \\phi^{*}}{2\\pi}$ such that $p = x - k$ for some integer $k$ and $p \\in (-0.5, 0.5]$.\nThis inequality for $p$ can be rewritten in terms of $x$ and $k$:\n$$\n-0.5 < x - k \\le 0.5\n$$\nRearranging for $k$ gives the condition:\n$$\nx - 0.5 \\le k < x + 0.5\n$$\nThe unique integer $k$ satisfying this condition for any real number $x$ is given by the ceiling function:\n$$\nk = \\lceil x - 0.5 \\rceil\n$$\nWith $k$ determined, the normalized perceived phase increment $p$ is calculated as $p = x - k$.\n\nThe perceived frequency $f_{perc}$ is defined as $f_{perc} = \\frac{f_{fps}}{2\\pi} |\\Delta \\phi^{*}|$. Substituting $\\Delta \\phi^{*} = 2\\pi p$:\n$$\nf_{perc} = \\frac{f_{fps}}{2\\pi} |2\\pi p| = f_{fps} |p| = f_{fps} \\left| \\frac{f_{rot}}{f_{fps}} - k \\right|\n$$\nThe perceived direction $s$ is the sign of the perceived phase increment:\n$$\ns = \\operatorname{sgn}(\\Delta \\phi^{*}) = \\operatorname{sgn}(2\\pi p) = \\operatorname{sgn}(p)\n$$\nBy convention, $\\operatorname{sgn}(0) = 0$, which correctly handles the case of a stationary perceived image ($f_{perc} = 0$).\n\nThe complete computational algorithm for a given pair $(f_{rot}, f_{fps})$ is as follows:\n$1$. Calculate the frequency ratio $x = f_{rot} / f_{fps}$.\n$2$. Determine the integer number of full rotations to subtract, $k = \\lceil x - 0.5 \\rceil$.\n$3$. Compute the normalized perceived phase increment $p = x - k$.\n$4$. Calculate the perceived frequency $f_{perc} = f_{fps} |p|$.\n$5$. Determine the perceived direction $s = \\operatorname{sgn}(p)$.\n$6$. Round $f_{perc}$ to $6$ decimal places and return the pair $[f_{perc}, s]$.\nThis algorithm is now implemented to solve for the provided test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the perceived frequency and direction of a rotating object\n    subject to temporal aliasing, based on the wagon-wheel effect model.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (f_rot, f_fps) in hertz.\n    test_cases = [\n        (2.3, 24.0),     # Case 1\n        (23.0, 24.0),    # Case 2\n        (12.0, 24.0),    # Case 3\n        (48.0, 24.0),    # Case 4\n        (-1.2, 24.0),    # Case 5\n        (103.0, 24.0),   # Case 6\n        (0.49, 24.0),    # Case 7\n        (31.0, 30.0),    # Case 8\n    ]\n\n    # A list to store the string-formatted results for each case.\n    results_str_list = []\n\n    for case in test_cases:\n        f_rot, f_fps = case\n\n        # Step 1: Calculate the frequency ratio x.\n        # This represents the number of rotations per sample period.\n        x = f_rot / f_fps\n\n        # Step 2: Determine the integer number of full rotations k to subtract.\n        # The logic k = ceil(x - 0.5) ensures that the remainder p = x - k\n        # falls into the interval (-0.5, 0.5], which corresponds to a\n        # phase increment in (-pi, pi].\n        k = np.ceil(x - 0.5)\n\n        # Step 3: Compute the normalized perceived phase increment p.\n        p = x - k\n\n        # Step 4: Calculate the perceived frequency f_perc.\n        # This is the magnitude of the perceived rotation rate.\n        f_perc = f_fps * np.abs(p)\n\n        # Step 5: Determine the perceived direction s.\n        # This is the sign of the perceived phase increment.\n        # np.sign(0) correctly returns 0.\n        s = int(np.sign(p))\n\n        # Step 6: Format the result for the current case as a string '[f_perc,s]'\n        # f_perc is formatted to exactly 6 decimal places.\n        case_result_str = f\"[{f_perc:.6f},{s}]\"\n        results_str_list.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The final output is a single line: a list of lists.\n    print(f\"[{','.join(results_str_list)}]\")\n\nsolve()\n```", "id": "2373299"}, {"introduction": "In computational physics, we often need to reduce the sampling rate of a signal, a process known as downsampling or decimation. A naive approach of simply discarding samples can introduce severe aliasing artifacts that corrupt the data. This essential practice [@problem_id:2373295] demonstrates the critical importance of applying an anti-aliasing filter *before* downsampling, allowing you to quantify the spectral error introduced by an incorrect processing order and master a crucial technique for handling experimental and simulation data.", "problem": "A discrete-time signal is formed from a finite-duration, uniformly sampled sum of cosines, and two processing orders are applied: low-pass filter then downsample, and downsample then low-pass filter. The task is to quantify how the order of operations affects the final spectrum, using a mathematically ideal low-pass filter defined on the Discrete Fourier Transform (DFT) grid. This problem concerns aliasing and the Nyquist criterion in computational physics.\n\nGiven a sampling frequency $F_{s}$ in hertz (Hz), a duration $T$ in seconds (s), and a list of tone components $\\{(A_{i}, f_{i})\\}$ with amplitude $A_{i}$ (dimensionless) and frequency $f_{i}$ in hertz (Hz), define the continuous-time signal\n$$\ns(t) = \\sum_{i} A_{i}\\cos\\!\\big(2\\pi f_{i} t\\big),\n$$\nand the discrete-time signal sampled at $F_{s}$ for duration $T$,\n$$\nx[n] = s\\!\\left(\\frac{n}{F_{s}}\\right), \\quad n=0,1,\\dots,N-1, \\quad N = \\lfloor F_{s} T \\rfloor.\n$$\nLet $M$ be a positive integer downsampling factor. Define the new sampling frequency after downsampling as $F_{s}^{(\\downarrow)} = F_{s}/M$ and the corresponding new Nyquist frequency as $F_{\\mathrm{N,new}} = \\frac{F_{s}}{2M}$ in hertz (Hz).\n\nDefine an ideal low-pass filter $H$ on the DFT grid as follows. For a sequence $u[n]$ of length $L$, let $U[k]$ be its $L$-point DFT, with bin-centered frequencies in hertz (Hz) given by $f_{k} = \\frac{k}{L}F_{s}^{(u)}$ for $k=0,\\dots,L-1$ interpreted using the standard centered frequency assignment for the DFT via $\\mathrm{fftfreq}$, where $F_{s}^{(u)}$ is the sampling frequency of $u[n]$. The ideal low-pass filter with cutoff $f_{c}$ in hertz (Hz), inclusive of the boundary, is defined on the DFT grid by the frequency response\n$$\nH(f) = \\begin{cases}\n1, & |f|\\le f_{c},\\\\\n0, & |f|> f_{c},\n\\end{cases}\n$$\napplied by multiplying $U[k]$ by $H(f_{k})$ and transforming back with the inverse DFT. This definition enforces a brick-wall response on the DFT frequency bins.\n\nTwo processing orders are to be applied to $x[n]$:\n1. Filter-then-downsample: Let $f_{c} = F_{s}/(2M)$. Form $x_{\\mathrm{F}}[n]$ by applying the ideal low-pass filter with cutoff $f_{c}$ at sampling frequency $F_{s}$ to $x[n]$. Then form\n$$\ny_{A}[m] = x_{\\mathrm{F}}[mM], \\quad m=0,1,\\dots,\\left\\lfloor\\frac{N}{M}\\right\\rfloor-1.\n$$\n2. Downsample-then-filter: First form $x_{\\downarrow}[m] = x[mM]$ with sampling frequency $F_{s}^{(\\downarrow)}=F_{s}/M$. Then apply the same ideal low-pass filter definition at sampling frequency $F_{s}^{(\\downarrow)}$ with cutoff $f_{c} = F_{s}/(2M)$ to obtain $y_{B}[m]$.\n\nFor each of $y_{A}[m]$ and $y_{B}[m]$ of common length $L = \\left\\lfloor N/M \\right\\rfloor$, compute their $L$-point Discrete Fourier Transform (DFT), denoted $Y_{A}[k]$ and $Y_{B}[k]$. Let the magnitude spectra be $|Y_{A}[k]|$ and $|Y_{B}[k]|$. Define the normalized spectral difference\n$$\nR = \\frac{\\left\\|\\,|Y_{B}| - |Y_{A}|\\,\\right\\|_{2}}{\\left\\|\\,|Y_{A}|\\,\\right\\|_{2}},\n$$\nwhere $\\|\\cdot\\|_{2}$ is the Euclidean norm over the $L$ DFT bins. This $R$ is dimensionless and quantifies how the order of operations affects the final spectrum.\n\nTest Suite. Use the following three test cases to cover a general case, a boundary case at the new Nyquist frequency, and a no-aliasing edge case. All durations and frequencies are provided in seconds (s) and hertz (Hz), respectively. The amplitudes are dimensionless. Angles inside trigonometric functions are in radians.\n\n- Case 1 (general, with above-new-Nyquist content):\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$.\n  - Components $\\{(A_{i}, f_{i})\\}$: $(1.0, 100)$, $(0.6, 400)$, $(0.8, 700)$, $(0.5, 900)$.\n\n- Case 2 (boundary at the new Nyquist and additional above-new-Nyquist content):\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$.\n  - Components $\\{(A_{i}, f_{i})\\}$: $(1.0, 512)$, $(0.8, 200)$, $(0.7, 900)$.\n\n- Case 3 (no-aliasing edge case; all tones safely below the new Nyquist):\n  - $F_{s} = 4096$ Hz, $T = 1$ s, $M=4$.\n  - Components $\\{(A_{i}, f_{i})\\}$: $(1.0, 80)$, $(0.5, 200)$, $(0.7, 350)$.\n\nRequired Program Output. For each case, compute the value of $R$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases given, with each value rounded to six decimal places (for example, \"[$0.123456,0.000000,1.234568$]\"). The output values are dimensionless floats.", "solution": "The problem statement has been rigorously validated and is determined to be sound. It is scientifically grounded in the principles of digital signal processing, specifically concerning aliasing and the Nyquist-Shannon sampling theorem. It is well-posed, objective, and provides a complete, consistent set of definitions and data to arrive at a unique, verifiable solution. We may proceed.\n\nThe core of this problem lies in demonstrating the fundamental principle of decimation (downsampling) in digital signal processing: to prevent aliasing, a signal must be low-pass filtered *before* its sampling rate is reduced. The problem requires a quantitative comparison of two processing orders: a correct one (filter-then-downsample) and an incorrect one (downsample-then-filter).\n\nLet us denote the initial discrete signal as $x[n]$, with sampling frequency $F_s$ and length $N$. The downsampling factor is $M$. The target sampling frequency is $F_{s}^{(\\downarrow)} = F_s/M$, and the corresponding Nyquist frequency is $F_{\\mathrm{N,new}} = F_{s}^{(\\downarrow)}/2 = F_s/(2M)$.\n\nPath A: Filter-then-Downsample\nThis procedure represents the correct method for decimation.\n1.  **Anti-aliasing Filter**: The signal $x[n]$ is first processed by an ideal low-pass filter with cutoff frequency $f_c = F_{\\mathrm{N,new}}$. This step, known as anti-aliasing filtering, removes all frequency components from the signal that lie above the new Nyquist frequency. The filtered signal, $x_{\\mathrm{F}}[n]$, is guaranteed to be band-limited to the range $[-F_{\\mathrm{N,new}}, F_{\\mathrm{N,new}}]$. Mathematically, if $X[k]$ is the Discrete Fourier Transform (DFT) of $x[n]$, the filtered spectrum is $X_{\\mathrm{F}}[k] = X[k] H(f_k)$, where $H(f_k)$ is unity for $|f_k| \\le f_c$ and zero otherwise.\n2.  **Downsampling**: The filtered signal $x_{\\mathrm{F}}[n]$ is then downsampled by a factor of $M$ to produce $y_A[m] = x_{\\mathrm{F}}[mM]$. Because all frequencies that could cause aliasing have been removed beforehand, the spectrum of $y_A[m]$ is a clean, scaled representation of the original signal's low-frequency content. The spectrum $|Y_A[k]|$ will only contain peaks corresponding to the original signal tones $(A_i, f_i)$ for which $|f_i| \\le F_{\\mathrm{N,new}}$.\n\nPath B: Downsample-then-Filter\nThis procedure illustrates the consequence of ignoring the anti-aliasing requirement.\n1.  **Downsampling**: The original signal $x[n]$ is immediately downsampled to produce $x_{\\downarrow}[m] = x[mM]$. In the frequency domain, this operation causes spectral folding, or aliasing. The original spectrum, which extends up to $\\pm F_s/2$, is replicated and summed. Any frequency component $f_i$ in the original signal is mapped to a new, apparent frequency $f_{\\text{alias}}$ in the baseband $[-F_{\\mathrm{N,new}}, F_{\\mathrm{N,new}}]$. This aliased frequency is given by $f_{\\text{alias}} = f_i \\pmod{F_{s}^{(\\downarrow)}}$, with appropriate interpretation for negative frequencies. Specifically, a high-frequency component $|f_i| > F_{\\mathrm{N,new}}$ will be indistinguishably superimposed onto a lower frequency.\n2.  **Filtering**: The now-aliased signal $x_{\\downarrow}[m]$ is processed by the same ideal low-pass filter. However, the filter cannot distinguish between the original in-band components and the new, aliased components that have been folded into its passband. It will pass all of them. The resulting signal $y_B[m]$ will therefore contain not only the original low-frequency tones but also the aliased artifacts of the original high-frequency tones. The spectrum $|Y_B[k]|$ will exhibit peaks corresponding to original tones with $|f_i| \\le F_{\\mathrm{N,new}}$ as well as peaks at the aliased frequencies of tones for which $|f_i| > F_{\\mathrm{N,new}}$.\n\nQuantitative Comparison\nThe normalized spectral difference, $R = \\left\\|\\,|Y_{B}| - |Y_{A}|\\,\\right\\|_{2} / \\left\\|\\,|Y_{A}|\\,\\right\\|_{2}$, quantifies the error introduced by improper processing.\n-   If the original signal contains energy at frequencies $|f_i| > F_{\\mathrm{N,new}}$, path B will introduce aliased components that are absent in path A. This will result in $|Y_B| \\neq |Y_A|$ and consequently $R > 0$. This is expected for Cases 1 and 2.\n-   If the original signal is already band-limited such that all its components satisfy $|f_i| \\le F_{\\mathrm{N,new}}$, the anti-aliasing filter in path A has no effect on the signal content. Downsampling will not cause aliasing. The filter in path B will also pass the entire signal. In this ideal scenario, $y_A[m]$ and $y_B[m]$ will be identical, their spectra will match, and $R$ will be zero. This is the expectation for Case 3, with any deviation from zero attributable to finite-precision arithmetic.\n\nThe algorithm proceeds by implementing these two paths for each test case, computing the final spectra $|Y_A[k]|$ and $|Y_B[k]|$, and then evaluating the metric $R$. The implementation will use the `scipy.fft` library for efficient computation of DFTs, inverse DFTs, and the associated frequency grids.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general, with above-new-Nyquist content)\n        (4096, 1, 4, [(1.0, 100), (0.6, 400), (0.8, 700), (0.5, 900)]),\n        # Case 2 (boundary at the new Nyquist and additional above-new-Nyquist content)\n        (4096, 1, 4, [(1.0, 512), (0.8, 200), (0.7, 900)]),\n        # Case 3 (no-aliasing edge case; all tones safely below the new Nyquist)\n        (4096, 1, 4, [(1.0, 80), (0.5, 200), (0.7, 350)]),\n    ]\n\n    results = []\n    for case in test_cases:\n        Fs, T, M, components = case\n        R = calculate_spectral_difference(Fs, T, M, components)\n        results.append(f\"{R:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_spectral_difference(Fs, T, M, components):\n    \"\"\"\n    Calculates the normalized spectral difference R for a given set of parameters.\n\n    Args:\n        Fs (int): Sampling frequency in Hz.\n        T (int): Signal duration in seconds.\n        M (int): Downsampling factor.\n        components (list): A list of tuples (A_i, f_i) representing signal components.\n\n    Returns:\n        float: The calculated normalized spectral difference R.\n    \"\"\"\n    # Define signal and processing parameters\n    N = int(np.floor(Fs * T))\n    L = int(np.floor(N / M))\n    fc = Fs / (2 * M)\n\n    # Generate the initial discrete-time signal x[n]\n    n = np.arange(N)\n    t = n / Fs\n    x = np.zeros(N, dtype=np.float64)\n    for A, f in components:\n        x += A * np.cos(2 * np.pi * f * t)\n\n    # --- Path A: Filter-then-downsample ---\n    # 1A. Apply ideal low-pass filter to x[n]\n    X = fft(x)\n    freqs_N = fftfreq(N, d=1/Fs)\n    h_mask_A = np.abs(freqs_N) <= fc\n    X_F = X * h_mask_A\n    x_F = np.real(ifft(X_F))\n    \n    # 2A. Downsample the filtered signal\n    y_A = x_F[::M]\n\n    # --- Path B: Downsample-then-filter ---\n    # 1B. Downsample the original signal x[n]\n    x_down = x[::M]\n    Fs_down = Fs / M\n    \n    # 2B. Apply ideal low-pass filter to the downsampled signal\n    X_down = fft(x_down)\n    freqs_L = fftfreq(L, d=1/Fs_down)\n    h_mask_B = np.abs(freqs_L) <= fc\n    X_down_filtered = X_down * h_mask_B\n    y_B = np.real(ifft(X_down_filtered))\n\n    # --- Compute Final Spectra and Metric R ---\n    # DFT of the final signals y_A and y_B\n    Y_A = fft(y_A)\n    Y_B = fft(y_B)\n\n    # Magnitude spectra\n    abs_YA = np.abs(Y_A)\n    abs_YB = np.abs(Y_B)\n\n    # Euclidean norms\n    norm_A = np.linalg.norm(abs_YA)\n    \n    # Avoid division by zero if signal A is null\n    if norm_A == 0:\n        return np.inf if np.linalg.norm(abs_YB) > 0 else 0.0\n\n    norm_diff = np.linalg.norm(abs_YB - abs_YA)\n    \n    R = norm_diff / norm_A\n    return R\n\nsolve()\n```", "id": "2373295"}, {"introduction": "Aliasing does more than just create misleading frequencies; it can undermine the physical integrity of a simulation. In this final practice, we will investigate a simulation of a vibrating string, which is composed of numerous harmonics of a fundamental frequency $f_0$, each with a specific energy. By sampling the system at a rate that violates the Nyquist criterion, you will observe how energy from high-frequency modes erroneously \"leaks\" into lower-frequency bands, leading to an unphysical inflation of energy in the resolved part of the spectrum. [@problem_id:2373303]", "problem": "Consider an idealized one-dimensional vibrating string whose displacement at a fixed point is modeled as the superposition of harmonics of a fundamental frequency. Let the continuous-time signal be\n$$\ns(t) = \\sum_{n=1}^{H} a_n \\cos\\!\\big(2\\pi n f_0 t\\big),\n$$\nwith amplitudes $a_n = 1/n$, fundamental frequency $f_0$ in hertz, and $H$ the highest harmonic index. Over any time interval that is an integer multiple of the fundamental period, the time average of cross terms of distinct harmonics is zero, and the time average of $\\cos^2$ is $1/2$. Hence, the exact time-averaged energy in any resolved band that includes harmonics $\\{n: n f_0 \\le f_{\\mathrm{res}}\\}$ is\n$$\nE_{\\mathrm{true,low}} = \\frac{1}{2}\\sum_{\\substack{n=1 \\\\ n f_0 \\le f_{\\mathrm{res}}}}^{H} a_n^2.\n$$\nYou will compare this continuous-time resolved-band energy with the resolved-band energy obtained from discrete-time sampling and ideal low-pass reconstruction using the Fast Fourier Transform (FFT, Fast Fourier Transform). When a discrete time step $\\Delta t$ is used, samples are $s_k = s(k \\Delta t)$ for $k=0,1,\\dots,N-1$ with total duration $T = N \\Delta t$. The discrete-time representation admits only frequencies up to the Nyquist limit, and frequencies in the continuous signal above this limit become indistinguishable from certain lower frequencies when sampled; this is aliasing. When aliasing occurs, energy from high-frequency modes can appear at lower frequencies in the sampled data, which artificially inflates the energy measured in the resolved band and violates energy conservation in the resolved modes.\n\nTask: Implement a program that, for a specified set of physical and numerical parameters, constructs $s(t)$, samples it, isolates the resolved band via an ideal filter implemented in the frequency domain, and computes the ratio\n$$\nR = \\frac{E_{\\mathrm{disc,low}}}{E_{\\mathrm{true,low}}},\n$$\nwhere $E_{\\mathrm{disc,low}}$ is the time-averaged energy computed from the ideal low-pass filtered discrete signal reconstructed from the sampled data. A value $R \\approx 1$ indicates faithful resolution without aliasing contamination of the resolved band, while $R > 1$ reveals that high-frequency modes have aliased into the resolved band.\n\nUse only rational derivations from the following fundamental base:\n- Definition of time-averaged energy as the time average of $s(t)^2$ over an integer number of fundamental periods.\n- Orthogonality of distinct harmonics over integer periods and the identity $\\langle \\cos^2(\\cdot)\\rangle = 1/2$.\n- The concept that discrete-time sampling restricts resolvable frequencies and that discrete spectra are periodic in frequency.\n\nProgram requirements:\n- Construct $s(t)$ with $a_n = 1/n$.\n- For each test case, sample $s(t)$ at uniform step $\\Delta t$ over duration $T$ that is an integer number of seconds, so that frequency bins are at integer multiples of $1/T$.\n- Compute $E_{\\mathrm{true,low}}$ from the analytic sum above.\n- Compute $E_{\\mathrm{disc,low}}$ as follows:\n  1. Compute the discrete Fourier transform of the sampled data using an FFT implementation.\n  2. Zero out all Fourier components with frequencies strictly greater than $f_{\\mathrm{res}}$ (ideal low-pass in the discrete spectrum).\n  3. Inverse transform to the time domain and compute the time average of the squared reconstructed signal over the entire duration.\n- Report the ratio $R$ for each test case.\n\nUnits and conventions to use:\n- Time in seconds, frequency in hertz, and angles in radians.\n\nTest suite:\nUse the following parameter set for all test cases unless otherwise noted:\n- Fundamental frequency $f_0 = 50$ hertz.\n- Highest harmonic index $H = 40$.\n- Amplitudes $a_n = 1/n$ for $n = 1,2,\\dots,H$.\n- Total duration $T = 2.0$ seconds.\n- Resolved-band cutoff $f_{\\mathrm{res}} = 700$ hertz.\n\nEvaluate the following four sampling time steps $\\Delta t$ (all in seconds):\n1. $\\Delta t_1 = 1/20000$ (a very small time step, well below any aliasing threshold for the chosen $H$).\n2. $\\Delta t_2 = 1/6000$ (a small time step, still safely resolving all included harmonics).\n3. $\\Delta t_3 = 1/2000$ (a larger time step, such that some harmonics exceed the resolvable range and alias).\n4. $\\Delta t_4 = 1/1600$ (an even larger time step, closer to the aliasing boundary for the resolved band).\n\nRequired final output format:\n- Your program should produce a single line of output containing the four ratios $R$ corresponding to the four $\\Delta t$ values, as a comma-separated list enclosed in square brackets (e.g., \"[1.000000,1.000000,1.234567,1.345678]\"). Each ratio must be a floating-point number rounded to six digits after the decimal point.", "solution": "The problem as stated is subjected to validation.\n\nStep 1: Extract Givens.\n- Continuous-time signal: $s(t) = \\sum_{n=1}^{H} a_n \\cos(2\\pi n f_0 t)$.\n- Amplitudes: $a_n = 1/n$.\n- Fundamental frequency: $f_0$.\n- Highest harmonic index: $H$.\n- Exact time-averaged energy in resolved band: $E_{\\mathrm{true,low}} = \\frac{1}{2}\\sum_{\\substack{n=1 \\\\ n f_0 \\le f_{\\mathrm{res}}}}^{H} a_n^2$.\n- Sampling: $s_k = s(k \\Delta t)$ for $k=0,1,\\dots,N-1$.\n- Total duration: $T = N \\Delta t$.\n- Target ratio: $R = E_{\\mathrm{disc,low}} / E_{\\mathrm{true,low}}$.\n- Procedure for $E_{\\mathrm{disc,low}}$:\n    1. Compute the discrete Fourier transform (FFT) of sampled data.\n    2. Zero out Fourier components with frequencies strictly greater than $f_{\\mathrm{res}}$.\n    3. Inverse transform to the time domain.\n    4. Compute the time average of the squared reconstructed signal.\n- Test suite parameters:\n    - $f_0 = 50$ hertz.\n    - $H = 40$.\n    - $a_n = 1/n$ for $n = 1, \\dots, H$.\n    - $T = 2.0$ seconds.\n    - $f_{\\mathrm{res}} = 700$ hertz.\n- Four sampling time steps for evaluation:\n    1. $\\Delta t_1 = 1/20000$ s.\n    2. $\\Delta t_2 = 1/6000$ s.\n    3. $\\Delta t_3 = 1/2000$ s.\n    4. $\\Delta t_4 = 1/1600$ s.\n\nStep 2: Validate Using Extracted Givens.\n- **Scientifically Grounded**: The problem is based on the fundamental principles of digital signal processing, specifically the Fourier transform, the Nyquist-Shannon sampling theorem, and the phenomenon of aliasing. These concepts are standard in physics and engineering. The model of a vibrating string and the formula for time-averaged energy are correct. The problem is scientifically sound.\n- **Well-Posed**: The problem is defined with precision. It provides a clear mathematical model for the signal, a specific algorithm for its analysis, and a complete set of parameters for computation. A unique numerical result can be determined for each test case.\n- **Objective**: The problem statement uses objective, technical language, free of subjectivity or ambiguity.\n- **Incomplete or Contradictory Setup**: The problem is self-contained. All necessary parameters ($f_0$, $H$, $T$, $f_{\\mathrm{res}}$, and $\\Delta t$ values) are provided. Derived quantities like the number of samples $N$ are calculable from the givens ($N = T/\\Delta t$). There are no contradictions.\n- **Unrealistic or Infeasible**: The physical and numerical parameters are realistic for a computational demonstration of aliasing.\n- **Ill-Posed or Poorly Structured**: The problem is clearly structured and poses a non-trivial question that requires direct application of the specified principles.\n\nStep 3: Verdict and Action.\nThe problem is valid. It is a well-posed, scientifically grounded exercise in computational physics. A solution will be provided.\n\nThe task is to investigate the phenomenon of aliasing by comparing the energy content of a signal's low-frequency band as computed from a discrete-time representation with its exact continuous-time counterpart. The ratio of these two energies, $R$, serves as the metric for aliasing-induced contamination. A value of $R > 1$ indicates that energy from unresolved high-frequency components has been erroneously mapped into the resolved low-frequency band due to insufficient sampling rate.\n\nFirst, we establish the ground truth, the analytical time-averaged energy of the low-frequency portion of the continuous signal, $E_{\\mathrm{true,low}}$. The signal is $s(t) = \\sum_{n=1}^{H} a_n \\cos(2\\pi n f_0 t)$. The time average of $s(t)^2$ over an interval that is an integer multiple of the fundamental period $1/f_0$ simplifies due to the orthogonality of the cosine basis functions. The time average of $\\cos(2\\pi n f_0 t) \\cos(2\\pi m f_0 t)$ is zero for $n \\ne m$, and the time average of $\\cos^2(2\\pi n f_0 t)$ is $1/2$. Consequently, the total average power, or \"time-averaged energy,\" is $\\frac{1}{2} \\sum_{n=1}^{H} a_n^2$. The problem defines the resolved band as containing all harmonics with frequencies up to $f_{\\mathrm{res}}$. The frequency of the $n$-th harmonic is $n f_0$. Therefore, the harmonics included in the resolved band are those with index $n$ such that $n f_0 \\le f_{\\mathrm{res}}$, or $n \\le f_{\\mathrm{res}}/f_0$. Given $f_{\\mathrm{res}} = 700$ Hz and $f_0 = 50$ Hz, the highest harmonic index in the resolved band is $n_{\\mathrm{max,res}} = \\lfloor 700/50 \\rfloor = 14$. The true energy in this band is therefore:\n$$\nE_{\\mathrm{true,low}} = \\frac{1}{2}\\sum_{n=1}^{14} a_n^2 = \\frac{1}{2}\\sum_{n=1}^{14} \\left(\\frac{1}{n}\\right)^2\n$$\nThis quantity is constant across all test cases and serves as our reference.\n\nNext, we address the discrete-time analysis for each specified sampling time step $\\Delta t$. The sampling frequency is $f_s = 1/\\Delta t$. The Nyquist frequency, $f_{\\mathrm{Nyquist}} = f_s / 2$, defines the maximum frequency that can be uniquely represented. Any frequency component $f$ in the original signal $s(t)$ where $f > f_{\\mathrm{Nyquist}}$ will be aliased to a lower frequency $f_{\\mathrm{alias}}$ in the range $[0, f_{\\mathrm{Nyquist}}]$. The relationship is $f_{\\mathrm{alias}} = |f - m f_s|$ for the integer $m$ that minimizes this absolute difference.\n\nThe computational procedure for each $\\Delta t$ is as follows:\n1.  Determine the number of samples $N = T / \\Delta t$.\n2.  Generate the discrete time series $t_k = k \\Delta t$ for $k = 0, \\dots, N-1$.\n3.  Construct the sampled signal $s_k = s(t_k) = \\sum_{n=1}^{H=40} \\frac{1}{n} \\cos(2\\pi n f_0 t_k)$.\n4.  Compute the Discrete Fourier Transform (DFT) of $s_k$, denoted $S_j$, using a Fast Fourier Transform (FFT) algorithm. The frequencies corresponding to the DFT indices $j$ are given by $f_j = j/T$ for $j=0, \\ldots, N-1$ (with negative frequencies occupying the upper half of the index range).\n5.  Perform ideal low-pass filtering in the frequency domain. This is achieved by setting to zero all coefficients $S_j$ for which the corresponding frequency $|f_j|$ is strictly greater than the cutoff $f_{\\mathrm{res}}$. Let the resulting filtered spectrum be $S_{j, \\text{filtered}}$.\n6.  Compute the time-averaged energy of the filtered signal, $E_{\\mathrm{disc,low}}$. While one could perform an inverse FFT to obtain the filtered time-domain signal and then compute its mean square, a more direct and numerically robust method is to apply Parseval's theorem. For the DFT normalization used in standard scientific libraries, the time-averaged power is given by:\n$$\nE_{\\mathrm{disc,low}} = \\frac{1}{N} \\sum_{k=0}^{N-1} |s_{k, \\text{low}}|^2 = \\frac{1}{N^2} \\sum_{j=0}^{N-1} |S_{j, \\text{filtered}}|^2\n$$\nThis calculation is performed in the frequency domain, avoiding the computational expense and potential precision loss of an inverse transform.\n\nFinally, the ratio $R = E_{\\mathrm{disc,low}} / E_{\\mathrm{true,low}}$ is computed for each $\\Delta t$.\n\nLet us analyze the expected outcome for the given test cases. The highest frequency present in the continuous signal is $f_{\\mathrm{max}} = H \\cdot f_0 = 40 \\times 50 \\text{ Hz} = 2000 \\text{ Hz}$.\n- For $\\Delta t_1 = 1/20000$ s, $f_s=20000$ Hz and $f_{\\mathrm{Nyquist}} = 10000$ Hz. Since $f_{\\mathrm{max}} < f_{\\mathrm{Nyquist}}$, no aliasing occurs. We expect $R \\approx 1.0$.\n- For $\\Delta t_2 = 1/6000$ s, $f_s=6000$ Hz and $f_{\\mathrm{Nyquist}} = 3000$ Hz. As $f_{\\mathrm{max}} < f_{\\mathrm{Nyquist}}$, no aliasing occurs. We expect $R \\approx 1.0$.\n- For $\\Delta t_3 = 1/2000$ s, $f_s=2000$ Hz and $f_{\\mathrm{Nyquist}} = 1000$ Hz. Here, $f_{\\mathrm{max}} > f_{\\mathrm{Nyquist}}$. Harmonics with frequencies above $1000$ Hz (i.e., for $n > 1000/50=20$) will alias. Some of this aliased energy will fall into the resolved band ($[0, 700 \\text{ Hz}]$), causing $E_{\\mathrm{disc,low}}$ to be larger than $E_{\\mathrm{true,low}}$. We expect $R > 1.0$. For example, the harmonic $n=27$ has frequency $f=1350$ Hz. It aliases to $f_{\\mathrm{alias}} = |1350 - 2000| = 650$ Hz, which lies within the resolved band.\n- For $\\Delta t_4 = 1/1600$ s, $f_s=1600$ Hz and $f_{\\mathrm{Nyquist}} = 800$ Hz. Aliasing will occur for harmonics with frequencies above $800$ Hz (i.e., for $n > 800/50 = 16$). More harmonics will alias into the resolved band compared to the previous case. For example, the harmonic $n=19$ with $f=950$ Hz aliases to $f_{\\mathrm{alias}} = |950 - 1600|=650$ Hz. We expect $R > 1.0$, and it is likely that the ratio will be greater than in the third case.\nThe implementation will now follow this logic.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, fftfreq\n\ndef solve():\n    \"\"\"\n    Computes the ratio of measured to true low-band energy in a sampled signal\n    to demonstrate the effects of aliasing.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a value for the sampling time step delta_t in seconds.\n    test_cases = [\n        1/20000.0,\n        1/6000.0,\n        1/2000.0,\n        1/1600.0,\n    ]\n\n    # Fixed physical and numerical parameters\n    f0 = 50.0  # Fundamental frequency in Hz\n    H = 40     # Highest harmonic index\n    T = 2.0    # Total duration in seconds\n    f_res = 700.0 # Resolved-band cutoff frequency in Hz\n\n    # --- Step 1: Calculate the true, continuous-time low-band energy ---\n    # The resolved band includes harmonics n where n*f0 <= f_res.\n    n_max_res = int(f_res / f0)\n    \n    # Amplitudes are a_n = 1/n. The energy contribution is (1/2)*a_n^2.\n    n_series_res = np.arange(1, n_max_res + 1)\n    amplitudes_sq_res = (1.0 / n_series_res)**2\n    e_true_low = 0.5 * np.sum(amplitudes_sq_res)\n\n    results = []\n    # --- Step 2: Loop through each test case (each delta_t) ---\n    for dt in test_cases:\n        # Determine sampling parameters\n        N = int(T / dt)  # Total number of samples\n        \n        # Generate time vector for sampling\n        t = np.arange(N) * dt\n        \n        # Construct the sampled signal s(t)\n        s = np.zeros(N)\n        for n in range(1, H + 1):\n            a_n = 1.0 / n\n            s += a_n * np.cos(2 * np.pi * n * f0 * t)\n            \n        # --- Step 3: Analyze the sampled signal using FFT ---\n        \n        # Compute the Discrete Fourier Transform (DFT) of the signal\n        S = fft(s)\n        \n        # Get the frequency bins corresponding to the DFT components\n        freqs = fftfreq(N, d=dt)\n        \n        # Apply an ideal low-pass filter in the frequency domain.\n        # Create a copy of the spectrum and zero out components with frequencies\n        # strictly greater than f_res.\n        S_filtered = S.copy()\n        S_filtered[np.abs(freqs) > f_res] = 0.0\n        \n        # Compute the discrete-time, low-band energy using Parseval's theorem.\n        # The time-averaged energy (average power) is (1/N^2) * sum(|S_j|^2).\n        e_disc_low = np.sum(np.abs(S_filtered)**2) / (N**2)\n        \n        # Calculate the ratio R\n        ratio = e_disc_low / e_true_low\n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    # Each ratio is formatted to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2373303"}]}