{"hands_on_practices": [{"introduction": "The journey from a continuous, real-world measurement to a digital signal begins with quantization, the process of mapping a vast range of analog values to a finite set of digital levels. This exercise simulates this fundamental step, allowing you to directly observe and quantify the resulting quantization noise. By calculating the Signal-to-Quantization-Noise Ratio (SQNR), you will gain a practical understanding of how an instrument's bit depth limits the fidelity of your data. [@problem_id:2438146]", "problem": "A continuous-time sinusoidal signal representing a single-tone test input is defined by the function $x(t) = A \\sin(2 \\pi f_{0} t + \\varphi)$ with amplitude $A$, frequency $f_{0}$, and phase $\\varphi = 0$ radians. The signal is sampled uniformly in time at sampling frequency $f_{s}$ for a duration $T$, producing $N = \\lfloor f_{s} T \\rfloor$ discrete-time samples $x[n] = x(t_{n})$ at times $t_{n} = n / f_{s}$ for $n = 0, 1, \\ldots, N-1$. The samples are then digitized by an ideal, uniform, mid-tread quantizer with $B$ bits and full-scale peak amplitude $L$ (in volts), as follows. Define $K = 2^{B-1} - 1$ and step size $\\Delta = L / K$. The reconstruction levels are $k \\Delta$ for integer $k$ satisfying $-K \\leq k \\leq K$. The quantized sample $y_{q}[n]$ is obtained by first mapping $x[n]$ to the nearest level $k \\Delta$ via rounding and then saturating to the extreme levels when necessary:\n$$\nk[n] = \\mathrm{clip}\\left(\\mathrm{round}\\left(\\frac{x[n]}{\\Delta}\\right), -K, K\\right), \\quad y_{q}[n] = k[n] \\Delta,\n$$\nwhere $\\mathrm{round}(\\cdot)$ denotes rounding to the nearest integer and $\\mathrm{clip}(u, a, b)$ limits $u$ to the interval $[a, b]$. The quantization error is $e[n] = y_{q}[n] - x[n]$. Using the sampled data, define the average signal power and average error power as\n$$\nP_{s} = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]^{2}, \\quad P_{e} = \\frac{1}{N} \\sum_{n=0}^{N-1} e[n]^{2},\n$$\nand the signal-to-quantization-noise ratio (SQNR) in decibels as\n$$\n\\mathrm{SQNR} = 10 \\log_{10}\\left(\\frac{P_{s}}{P_{e}}\\right).\n$$\nAll angles must be in radians. Voltages must be in volts.\n\nYour task is to compute $\\mathrm{SQNR}$ for each parameter set in the test suite below. For each test case, the amplitude is specified relative to the full-scale peak amplitude as a multiple of $L$; that is, use the absolute amplitude $A$ equal to the specified multiple times $L$. Express the final $\\mathrm{SQNR}$ values in decibels as floating-point numbers rounded to exactly six digits after the decimal point.\n\nTest suite (each case is a tuple $(B, f_{0}, f_{s}, T, L, \\text{amplitude multiple})$):\n- Case $1$: $(16, 1234, 48000, 1.0, 1.0, 0.9)$\n- Case $2$: $(12, 1000, 44100, 0.5, 2.0, 0.8)$\n- Case $3$: $(8, 5000, 96000, 0.25, 1.0, 0.5)$\n- Case $4$: $(3, 200, 8000, 1.0, 1.0, 0.95)$\n- Case $5$: $(16, 3000, 48000, 0.75, 1.0, 0.01)$\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets with no spaces, in the same order as the test suite (for example, \"[r1,r2,r3,r4,r5]\"), where each $r_i$ is the $\\mathrm{SQNR}$ of case $i$, rounded to exactly six digits after the decimal point.", "solution": "The problem statement is subjected to validation and is found to be valid. It is a well-posed problem in digital signal processing, providing a clear and complete set of definitions, parameters, and constraints. All parameters are physically and computationally reasonable, and the underlying principles are scientifically sound. The task is to compute the Signal-to-Quantization-Noise Ratio (SQNR) for a set of given scenarios. We proceed with the solution.\n\nThe core of the problem is the simulation of a signal acquisition chain, which consists of sampling and quantization. The solution is obtained by algorithmically executing the steps defined in the problem for each test case.\n\n1.  **Signal Generation**:\n    The continuous-time signal is a pure sinusoid defined as $x(t) = A \\sin(2 \\pi f_{0} t)$, since the phase $\\varphi$ is given as $0$. The amplitude $A$ is determined from the quantizer's full-scale peak amplitude $L$ and the specified amplitude multiple, such that $A = (\\text{amplitude multiple}) \\times L$.\n    This signal is sampled uniformly at a frequency $f_{s}$ for a duration $T$. The total number of discrete samples is $N = \\lfloor f_{s} T \\rfloor$. The samples are taken at time instances $t_{n} = n/f_{s}$ for $n = 0, 1, \\ldots, N-1$. The resulting discrete-time signal is:\n    $$x[n] = x(t_{n}) = A \\sin\\left(2 \\pi f_{0} \\frac{n}{f_{s}}\\right)$$\n\n2.  **Quantizer Definition**:\n    The system uses a uniform mid-tread quantizer with $B$ bits of resolution and a full-scale peak amplitude of $L$ volts. The number of positive (and negative) quantization levels is determined by $K = 2^{B-1} - 1$. The total number of reconstruction levels is $2K+1$. The quantization step size, $\\Delta$, which is the voltage difference between adjacent reconstruction levels, is given by:\n    $$\\Delta = \\frac{L}{K}$$\n    The reconstruction levels are then $\\{k\\Delta \\mid k \\in \\{-K, -K+1, \\ldots, K-1, K\\}\\}$.\n\n3.  **Quantization Process and Error Calculation**:\n    Each sample $x[n]$ is mapped to the nearest reconstruction level. This is a two-step process. First, the sample's voltage is normalized by the step size $\\Delta$, and the result is rounded to the nearest integer. This integer is then clipped to ensure it stays within the range of valid level indices $[-K, K]$. The resulting index is $k[n]$:\n    $$k[n] = \\mathrm{clip}\\left(\\mathrm{round}\\left(\\frac{x[n]}{\\Delta}\\right), -K, K\\right)$$\n    The quantized sample $y_{q}[n]$ is then reconstructed by scaling this index back by the step size:\n    $$y_{q}[n] = k[n] \\Delta$$\n    The quantization error for each sample is the difference between the quantized value and the original sample value:\n    $$e[n] = y_{q}[n] - x[n]$$\n\n4.  **Power and SQNR Calculation**:\n    The average power of the original discrete-time signal, $P_{s}$, and the average power of the quantization error signal, $P_{e}$, are computed by averaging the square of their respective sample values over all $N$ samples:\n    $$P_{s} = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]^{2}$$\n    $$P_{e} = \\frac{1}{N} \\sum_{n=0}^{N-1} e[n]^{2}$$\n    Finally, the Signal-to-Quantization-Noise Ratio (SQNR) is computed in decibels (dB) using the formula:\n    $$\\mathrm{SQNR} = 10 \\log_{10}\\left(\\frac{P_{s}}{P_{e}}\\right)$$\n    This entire procedure is implemented computationally for each parameter set provided in the test suite. The numerical results are rounded to six decimal places as required.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Signal-to-Quantization-Noise Ratio (SQNR) for a series\n    of test cases involving a sampled and quantized sinusoidal signal.\n    \"\"\"\n    # Test suite: each case is a tuple (B, f0, fs, T, L, amplitude_multiple)\n    test_cases = [\n        (16, 1234, 48000, 1.0, 1.0, 0.9),\n        (12, 1000, 44100, 0.5, 2.0, 0.8),\n        (8, 5000, 96000, 0.25, 1.0, 0.5),\n        (3, 200, 8000, 1.0, 1.0, 0.95),\n        (16, 3000, 48000, 0.75, 1.0, 0.01)\n    ]\n\n    results = []\n\n    for case in test_cases:\n        B, f0, fs, T, L, amp_multiple = case\n\n        # Step 1: Signal Generation\n        # Amplitude of the sinusoidal signal\n        A = amp_multiple * L\n        # Number of samples, N = floor(fs * T)\n        N = int(fs * T)\n        # Time vector\n        t = np.arange(N) / fs\n        # Discrete-time signal x[n]\n        x_n = A * np.sin(2 * np.pi * f0 * t)\n\n        # Step 2: Quantizer Definition\n        # K determines the number of quantization levels on one side of zero\n        K = (2**(B - 1)) - 1\n        # Quantization step size\n        delta = L / K\n\n        # Step 3: Quantization Process\n        # Normalize signal and round to nearest integer to get level index\n        # np.round() implements rounding to the nearest integer, with .5 cases\n        # rounded to the nearest even integer.\n        k_n_unclipped = np.round(x_n / delta)\n        # Clip the indices to the valid range [-K, K]\n        k_n = np.clip(k_n_unclipped, -K, K)\n        # Reconstruct the quantized signal\n        y_q_n = k_n * delta\n\n        # Calculate the quantization error signal\n        e_n = y_q_n - x_n\n\n        # Step 4: Power and SQNR Calculation\n        # Average signal power\n        Ps = np.mean(x_n**2)\n        # Average error (noise) power\n        Pe = np.mean(e_n**2)\n        \n        # The problem setup ensures Pe > 0 for the given test cases.\n        # Otherwise, an if Pe == 0 check would be needed.\n        sqnr = 10 * np.log10(Ps / Pe)\n\n        results.append(sqnr)\n\n    # Format the final results as a comma-separated list of strings,\n    # with each number rounded to exactly six decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2438146"}, {"introduction": "Before a signal is quantized, it must first be sampled at discrete time intervals. If this sampling is not performed carefully, a high-frequency signal can masquerade as a lower-frequency oneâ€”a phenomenon known as aliasing. This practice provides a clear demonstration of aliasing by having you analyze a signal in the frequency domain, revealing how operations like downsampling can create these 'ghost' frequencies that corrupt your data. [@problem_id:2438167]", "problem": "A finite-length, discrete-time signal is defined as a sum of cosine components on Discrete Fourier Transform (DFT) bin frequencies. Let $N$ be a positive even integer and let $n \\in \\{0,1,\\dots,N-1\\}$. The signal is\n$$\nx[n] = \\sum_{k=1}^{K} A_k \\cos\\!\\left(\\omega_k n + \\varphi_k\\right),\n$$\nwhere each angular frequency is of the form $\\omega_k = \\dfrac{2\\pi m_k}{N}$ with integer $m_k \\in \\{0,1,\\dots,N-1\\}$, amplitudes $A_k &gt; 0$ are real, and phases $\\varphi_k$ are real numbers measured in radians. Consider the reconstruction from even-indexed samples only, defined by\n$$\ny[n] =\n\\begin{cases}\nx[n], & \\text{if $n$ is even},\\\\\n0, & \\text{if $n$ is odd}.\n\\end{cases}\n$$\nDefine the length-$N$ Discrete Fourier Transform (DFT) of a sequence $z[n]$ as\n$$\nZ[m] = \\sum_{n=0}^{N-1} z[n]\\, e^{-i\\,2\\pi\\, m n / N},\\quad m \\in \\{0,1,\\dots,N-1\\}.\n$$\nLet $X[m]$ and $Y[m]$ denote the DFTs of $x[n]$ and $y[n]$, respectively. Let the set of original spectral bins be\n$$\n\\mathcal{S} = \\bigcup_{k=1}^{K} \\left\\{\\, m_k,\\; (-m_k)\\bmod N \\,\\right\\},\n$$\nwith duplicates removed. Define the signal-bin power as\n$$\nP_{\\text{signal}} = \\sum_{m \\in \\mathcal{S}} \\left| Y[m] \\right|^2,\n$$\nthe total power as\n$$\nP_{\\text{total}} = \\sum_{m=0}^{N-1} \\left| Y[m] \\right|^2,\n$$\nand the aliasing-artifact power as\n$$\nP_{\\text{alias}} = P_{\\text{total}} - P_{\\text{signal}}.\n$$\nThe required performance metric is the aliasing-to-signal power ratio,\n$$\nR = \\frac{P_{\\text{alias}}}{P_{\\text{signal}}},\n$$\nwhich is dimensionless. All angles must be interpreted in radians.\n\nYour task is to write a complete program that, for each test case below, constructs $x[n]$, forms $y[n]$ from even-indexed samples only, computes $Y[m]$, and outputs the ratio $R$ as a floating-point number rounded to six digits after the decimal point.\n\nTest suite (each case is a tuple $(N,\\; \\{m_k\\},\\; \\{A_k\\},\\; \\{\\varphi_k\\})$):\n- Case $1$: $(1024,\\; \\{50\\},\\; \\{1.0\\},\\; \\{0.0\\})$.\n- Case $2$: $(1024,\\; \\{30,\\,100\\},\\; \\{1.0,\\,0.8\\},\\; \\{0.0,\\,0.3\\})$.\n- Case $3$: $(1024,\\; \\{256\\},\\; \\{1.0\\},\\; \\{0.7\\})$.\n- Case $4$: $(1024,\\; \\{0\\},\\; \\{1.2\\},\\; \\{0.0\\})$.\n- Case $5$: $(1024,\\; \\{60,\\,572\\},\\; \\{1.0,\\,0.5\\},\\; \\{0.0,\\,1.0\\})$.\n\nYour program must produce a single line of output containing the five ratios in order as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5]$, where each $r_j$ is rounded to six digits after the decimal point. No physical units are involved. All angles are in radians. The final output must exactly match this single-line format.", "solution": "The problem posed is a well-defined exercise in discrete signal processing, concerning the spectral analysis of a signal after a specific form of downsampling. It is scientifically grounded, logically consistent, and all necessary parameters are provided. Thus, the problem is valid, and a solution is presented below.\n\nLet the discrete-time signal of length $N$ be denoted by $x[n]$, where $n \\in \\{0, 1, \\dots, N-1\\}$. The signal is a superposition of $K$ cosine components:\n$$\nx[n] = \\sum_{k=1}^{K} A_k \\cos(\\omega_k n + \\varphi_k)\n$$\nEach angular frequency is a multiple of the fundamental DFT frequency, $\\omega_k = \\frac{2\\pi m_k}{N}$, with $m_k$ being an integer bin index.\n\nUsing Euler's identity, $e^{i\\theta} = \\cos(\\theta) + i\\sin(\\theta)$, we can express the cosine function as:\n$$\n\\cos(\\theta) = \\frac{e^{i\\theta} + e^{-i\\theta}}{2}\n$$\nThe signal $x[n]$ can therefore be written in terms of complex exponentials:\n$$\nx[n] = \\sum_{k=1}^{K} \\frac{A_k}{2} \\left( e^{i(\\frac{2\\pi m_k n}{N} + \\varphi_k)} + e^{-i(\\frac{2\\pi m_k n}{N} + \\varphi_k)} \\right) = \\sum_{k=1}^{K} \\left( \\frac{A_k e^{i\\varphi_k}}{2} e^{i\\frac{2\\pi m_k n}{N}} + \\frac{A_k e^{-i\\varphi_k}}{2} e^{-i\\frac{2\\pi m_k n}{N}} \\right)\n$$\nThe length-$N$ Discrete Fourier Transform (DFT), $X[m]$, of $x[n]$ is defined as:\n$$\nX[m] = \\sum_{n=0}^{N-1} x[n]\\, e^{-i\\frac{2\\pi mn}{N}}\n$$\nGiven the DFT of a complex exponential, $\\sum_{n=0}^{N-1} e^{i\\frac{2\\pi k_0 n}{N}} e^{-i\\frac{2\\pi mn}{N}} = N \\delta[m - k_0]$, where $\\delta[\\cdot]$ is the discrete impulse, the DFT of $x[n]$ is a series of impulses located at the bins $\\pm m_k$ (modulo $N$):\n$$\nX[m] = \\sum_{k=1}^{K} \\left( \\frac{N A_k e^{i\\varphi_k}}{2} \\delta[m - m_k] + \\frac{N A_k e^{-i\\varphi_k}}{2} \\delta[m - ((-m_k) \\pmod N)] \\right)\n$$\nThe spectrum $X[m]$ is non-zero only for $m$ belonging to the set of original spectral bins, $\\mathcal{S} = \\bigcup_{k=1}^{K} \\{m_k, (-m_k) \\pmod N\\}$.\n\nThe signal $y[n]$ is formed by setting the odd-indexed samples of $x[n]$ to zero:\n$$\ny[n] = x[n] \\cdot p[n], \\quad \\text{where} \\quad p[n] = \\frac{1 + (-1)^n}{2} = \\frac{1 + e^{i\\pi n}}{2}\n$$\nThe sequence $p[n]$ acts as a sampling function. The DFT of a product of two sequences is the circular convolution of their individual DFTs, scaled by $1/N$. The DFT of $p[n]$ is $P[m] = \\frac{N}{2} (\\delta[m] + \\delta[m - N/2])$, since $e^{i\\pi n} = e^{i\\frac{2\\pi(N/2)n}{N}}$ and $N$ is even.\nThe DFT of $y[n]$, denoted $Y[m]$, is then:\n$$\nY[m] = \\frac{1}{N} (X * P)[m] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] P[(m-k) \\pmod N]\n$$\nSubstituting the expression for $P[m]$ yields the well-known aliasing formula for this operation:\n$$\nY[m] = \\frac{1}{N} \\left( X[m] \\cdot \\frac{N}{2} + X[(m - N/2) \\pmod N] \\cdot \\frac{N}{2} \\right) = \\frac{1}{2} \\left( X[m] + X[(m - N/2) \\pmod N] \\right)\n$$\nThis fundamental relationship shows that the spectrum $Y[m]$ at a given frequency bin $m$ is the average of the original spectrum $X[m]$ at bin $m$ and the original spectrum at bin $(m - N/2) \\pmod N$. This is a manifestation of aliasing. The energy from frequency components at $m'$ is folded to $m = (m' \\pm N/2) \\pmod N$.\n\nTo solve the problem, we will implement a direct simulation for each test case according to the problem definitions:\n1.  For a given set of parameters $(N, \\{m_k\\}, \\{A_k\\}, \\{\\varphi_k\\})$, construct the signal $x[n]$ for $n=0, 1, \\dots, N-1$.\n2.  Construct the signal $y[n]$ by setting $y[n] = x[n]$ for even $n$ and $y[n]=0$ for odd $n$.\n3.  Compute the DFT $Y[m] = \\text{DFT}\\{y[n]\\}$ using a standard Fast Fourier Transform (FFT) algorithm.\n4.  Construct the set of signal bins $\\mathcal{S}$ from the given $\\{m_k\\}$.\n5.  Calculate the total power in the spectrum of $y[n]$ as $P_{\\text{total}} = \\sum_{m=0}^{N-1} |Y[m]|^2$.\n6.  Calculate the power concentrated in the original signal bins as $P_{\\text{signal}} = \\sum_{m \\in \\mathcal{S}} |Y[m]|^2$.\n7.  The aliasing-artifact power is the difference: $P_{\\text{alias}} = P_{\\text{total}} - P_{\\text{signal}}$.\n8.  The final metric is the ratio $R = P_{\\text{alias}} / P_{\\text{signal}}$. A potential division by zero is handled, although it does not occur in the provided test cases.\n9.  The computed value of $R$ for each case is rounded to six decimal places as required.\n\nThis procedure accurately models the physical and mathematical process described and will yield the correct numerical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... No scipy functions beyond fft which is in numpy are needed.\n\ndef solve():\n    \"\"\"\n    Solves the signal processing problem for a suite of test cases.\n    For each case, it computes the aliasing-to-signal power ratio R.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, {m_k}, {A_k}, {phi_k})\n    test_cases = [\n        (1024, [50], [1.0], [0.0]),\n        (1024, [30, 100], [1.0, 0.8], [0.0, 0.3]),\n        (1024, [256], [1.0], [0.7]),\n        (1024, [0], [1.2], [0.0]),\n        (1024, [60, 572], [1.0, 0.5], [0.0, 1.0]),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, m_k_list, A_k_list, phi_k_list = case\n        \n        # Step 1: Construct the signal x[n]\n        n_indices = np.arange(N)\n        x = np.zeros(N, dtype=float)\n        for m_k, A_k, phi_k in zip(m_k_list, A_k_list, phi_k_list):\n            omega_k = (2 * np.pi * m_k) / N\n            x += A_k * np.cos(omega_k * n_indices + phi_k)\n            \n        # Step 2: Construct the signal y[n] from even-indexed samples\n        y = np.zeros(N, dtype=float)\n        y[::2] = x[::2]\n        \n        # Step 3: Compute the DFT of y[n]\n        Y = np.fft.fft(y)\n        \n        # Step 4: Define the set of original spectral bins S\n        S = set()\n        for m_k in m_k_list:\n            S.add(m_k)\n            S.add((-m_k) % N)\n            \n        # Step 5: Calculate total power\n        P_total = np.sum(np.abs(Y)**2)\n        \n        # Step 6: Calculate signal-bin power\n        P_signal = 0.0\n        for m in S:\n            P_signal += np.abs(Y[m])**2\n            \n        # Step 7: Calculate aliasing-artifact power\n        P_alias = P_total - P_signal\n        \n        # Step 8: Calculate the ratio R\n        # Handle the case where P_signal might be zero to avoid division by zero.\n        if P_signal == 0:\n            # If there is no signal power but there is alias power, the ratio is infinite.\n            # If there is no alias power either, the ratio is undefined, which we can treat as 0.\n            R = np.inf if P_alias > 0 else 0.0\n        else:\n            R = P_alias / P_signal\n            \n        # Append the rounded result. Add a small epsilon for rounding stability,\n        # especially for values extremely close to x.5 * 10^-n.\n        results.append(round(R + 1e-9, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2438167"}, {"introduction": "Experimental data is almost always contaminated by noise, which poses a significant challenge for analysis, especially for operations like differentiation that amplify high-frequency fluctuations. This practical exercise explores a powerful strategy for overcoming this issue: applying a Gaussian smoothing filter before computing the derivative. By comparing the accuracy of this two-step method to direct differentiation, you will confront the critical trade-off between noise reduction and preserving the true signal features. [@problem_id:2438105]", "problem": "You are provided with a synthetic time series model for a scalar experimental measurement with additive noise, discretely sampled in time. Let the sampling frequency be $f_s = 1000$ in $\\text{s}^{-1}$, the number of samples be $N = 4096$, and the sampling interval be $\\Delta t = 1/f_s$. Define the continuous-time underlying signal $x(t)$ and its exact time derivative $x'(t)$ by\n$$\nx(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\cos(2\\pi f_2 t) + A_3 t,\n$$\nwith $A_1 = 1$, $f_1 = 5$ in $\\text{s}^{-1}$, $A_2 = 0.3$, $f_2 = 40$ in $\\text{s}^{-1}$, and $A_3 = 0.2$ in $\\text{s}^{-1}$. Angles are in radians. The exact derivative is\n$$\nx'(t) = 2\\pi f_1 A_1 \\cos(2\\pi f_1 t) - 2\\pi f_2 A_2 \\sin(2\\pi f_2 t) + A_3.\n$$\nLet the discrete sampling times be $t_n = n \\Delta t$ for integers $n \\in \\{0,1,\\dots,N-1\\}$. The measured discrete-time signal $y[n]$ is defined as\n$$\ny[n] = x(t_n) + \\eta[n],\n$$\nwhere $\\eta[n]$ are independent and identically distributed zero-mean Gaussian random variables with standard deviation $\\sigma_{\\eta}$ in the same units as $x(t)$. Use a fixed pseudorandom number generator seed equal to $S = 1337$ for reproducibility of $\\eta[n]$ across all test cases.\n\nYour task is to estimate the time derivative of the noisy measurement by two methods and compare their accuracy against the exact derivative $x'(t_n)$:\n1. Direct central differencing on the noisy data:\n$$\n\\widehat{d}_{\\text{direct}}[n] = \\frac{y[n+1] - y[n-1]}{2\\Delta t},\n$$\ndefined for $n \\in \\{1,2,\\dots,N-2\\}$.\n2. Gaussian smoothing followed by the same central differencing:\n   - Define the discrete zero-phase Gaussian kernel with standard deviation $\\sigma_g$ in samples as\n   $$\n   g[k] = \\frac{\\exp\\!\\left(-\\frac{k^2}{2\\sigma_g^2}\\right)}{\\sum_{m=-K}^{K} \\exp\\!\\left(-\\frac{m^2}{2\\sigma_g^2}\\right)},\n   $$\n   where $K = \\lceil 3\\sigma_g \\rceil$ and $k \\in \\{-K,-K+1,\\dots,0,\\dots,K-1,K\\}$. If $\\sigma_g = 0$, define $g[0] = 1$ and $g[k] = 0$ for $k \\neq 0$.\n   - Define the smoothed signal as the discrete convolution\n   $$\n   z[n] = \\sum_{k=-K}^{K} g[k]\\, y[n-k],\n   $$\n   with the understanding that indices outside $\\{0,\\dots,N-1\\}$ are handled implicitly by considering only the valid samples where subsequent differencing is well-defined and comparing errors only for $n \\in \\{1,2,\\dots,N-2\\}$.\n   - Apply the same central difference to $z[n]$:\n   $$ \n   \\widehat{d}_{\\text{smooth}}[n] = \\frac{z[n+1] - z[n-1]}{2\\Delta t},\n   $$\n   for $n \\in \\{1,2,\\dots,N-2\\}$.\n\nFor each method, quantify the accuracy using the relative root-mean-square error (rRMSE):\n$$\n\\mathrm{rRMSE}_{\\text{method}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{n=n_{\\min}}^{n_{\\max}}\\left(\\widehat{d}_{\\text{method}}[n] - x'(t_n)\\right)^2}}{\\sqrt{\\frac{1}{M}\\sum_{n=n_{\\min}}^{n_{\\max}} \\left(x'(t_n)\\right)^2}},\n$$\nwhere $n_{\\min} = 1$, $n_{\\max} = N-2$, and $M = n_{\\max}-n_{\\min}+1$. This quantity is dimensionless. Also compute the improvement factor\n$$\n\\rho = \\frac{\\mathrm{rRMSE}_{\\text{direct}}}{\\mathrm{rRMSE}_{\\text{smooth}}}.\n$$\n\nImplement a complete, runnable program that constructs the signal and noise as defined, applies the two estimation methods, and computes the metrics for each of the following test cases. Each test case is uniquely specified by $(\\sigma_{\\eta}, \\sigma_g)$ where $\\sigma_{\\eta}$ is the noise standard deviation and $\\sigma_g$ is the Gaussian kernel standard deviation in samples:\n- Case $1$: $(\\sigma_{\\eta}, \\sigma_g) = (0.5, 0.0)$.\n- Case $2$: $(\\sigma_{\\eta}, \\sigma_g) = (0.5, 2.0)$.\n- Case $3$: $(\\sigma_{\\eta}, \\sigma_g) = (2.0, 4.0)$.\n- Case $4$: $(\\sigma_{\\eta}, \\sigma_g) = (0.0, 4.0)$.\n\nAll final numerical outputs must be unitless and expressed as decimal floats. For each test case, return a list containing three values $[\\mathrm{rRMSE}_{\\text{direct}}, \\mathrm{rRMSE}_{\\text{smooth}}, \\rho]$, each rounded to exactly $6$ decimal places. Your program should produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a bracketed, comma-separated list. For example, the format must be\n\"[ [d1,s1,r1],[d2,s2,r2],[d3,s3,r3],[d4,s4,r4] ]\"\nwith each $d_i$, $s_i$, and $r_i$ replaced by the corresponding rounded decimal values.", "solution": "The problem presented is a well-defined exercise in computational physics, specifically in the domain of signal processing of experimental data. It requires the estimation of the time derivative of a noisy signal using two distinct methods and a quantitative comparison of their accuracy. The problem is scientifically grounded, objective, and provides all necessary information for a unique solution to be computed. It is therefore deemed valid.\n\nI will proceed with the solution by first constructing the signal and its derivative, then implementing the two estimation methods, and finally calculating the specified error metrics for each test case.\n\n**1. Preliminaries: Signal and System Definition**\n\nThe problem provides a set of fixed parameters for the simulation.\n- Sampling frequency: $f_s = 1000$ s$^{-1}$\n- Number of samples: $N = 4096$\n- Sampling interval: $\\Delta t = 1/f_s = 0.001$ s\n- Time vector: $t_n = n \\Delta t$ for $n \\in \\{0, 1, \\dots, N-1\\}$\n- Pseudorandom number generator seed: $S = 1337$\n\nThe continuous-time signal $x(t)$ is a sum of two sinusoids and a linear trend:\n$$\nx(t) = A_1 \\sin(2\\pi f_1 t) + A_2 \\cos(2\\pi f_2 t) + A_3 t\n$$\nwith parameters $A_1 = 1.0$, $f_1 = 5.0$ s$^{-1}$, $A_2 = 0.3$, $f_2 = 40.0$ s$^{-1}$, and $A_3 = 0.2$ s$^{-1}$.\n\nThe exact time derivative is given by:\n$$\nx'(t) = 2\\pi f_1 A_1 \\cos(2\\pi f_1 t) - 2\\pi f_2 A_2 \\sin(2\\pi f_2 t) + A_3\n$$\n\nThe measured signal $y[n]$ is the discrete-time clean signal $x(t_n)$ corrupted by additive white Gaussian noise $\\eta[n]$ with standard deviation $\\sigma_{\\eta}$:\n$$\ny[n] = x(t_n) + \\eta[n]\n$$\n\n**2. Derivative Estimation Methods**\n\nThe core of the task is to compare two methods for estimating the derivative $x'(t_n)$. Both methods are evaluated over the interval $n \\in \\{1, 2, \\dots, N-2\\}$.\n\n**Method 1: Direct Central Differencing**\n\nThis method approximates the derivative using a standard central difference formula applied directly to the noisy data $y[n]$:\n$$\n\\widehat{d}_{\\text{direct}}[n] = \\frac{y[n+1] - y[n-1]}{2\\Delta t}\n$$\nThis calculation is straightforward. However, applying a difference operator to a noisy signal is known to amplify the noise. The variance of the noise component in the derivative estimate is proportional to $\\sigma_{\\eta}^2 / (\\Delta t)^2$, which can be substantial for small $\\Delta t$.\n\n**Method 2: Smoothing followed by Central Differencing**\n\nThis method attempts to mitigate noise amplification by first applying a low-pass filter to the signal $y[n]$ and then differentiating the smoothed result.\n\n- **Smoothing**: The smoothing is performed via discrete convolution with a zero-phase Gaussian kernel $g[k]$.\n  - The kernel width is controlled by the parameter $\\sigma_g$ (in units of samples).\n  - The kernel is defined for $k \\in \\{-K, \\dots, K\\}$, where $K = \\lceil 3\\sigma_g \\rceil$.\n  - The formula is:\n    $$\n    g[k] = \\frac{\\exp\\!\\left(-\\frac{k^2}{2\\sigma_g^2}\\right)}{Z}, \\quad \\text{where } Z = \\sum_{m=-K}^{K} \\exp\\!\\left(-\\fracm^2}{2\\sigma_g^2}\\right)\n    $$\n  - A special case is defined for $\\sigma_g = 0$, where the kernel becomes a discrete delta function, $g[0]=1$ and $g[k]=0$ for $k \\neq 0$. In this case, convolution with $g[k]$ does not change the signal.\n  - The smoothed signal is $z[n] = (y * g)[n] = \\sum_{k=-K}^{K} g[k] y[n-k]$. This is a standard convolution operation. To produce an output $z[n]$ of the same length as $y[n]$, we use a 'same' convolution mode, which implicitly handles boundary effects by padding the input signal (typically with zeros). These boundary effects will introduce errors near the start and end of the smoothed signal $z[n]$.\n\n- **Differentiation**: The same central difference formula is then applied to the smoothed signal $z[n]$:\n  $$\n  \\widehat{d}_{\\text{smooth}}[n] = \\frac{z[n+1] - z[n-1]}{2\\Delta t}\n  $$\n\nThis two-step process embodies a classic trade-off: the smoothing filter reduces noise (variance) but can also distort the underlying signal by attenuating its higher-frequency components, introducing a systematic error (bias). The optimal choice of $\\sigma_g$ depends on the signal's frequency content and the noise level.\n\n**3. Error Quantification**\n\nThe accuracy of each method is measured by the relative root-mean-square error (rRMSE). This metric compares the RMS of the estimation error to the RMS of the true derivative signal over the evaluation interval $n \\in \\{1, \\dots, N-2\\}$.\n\n$$\n\\mathrm{rRMSE}_{\\text{method}} = \\frac{\\sqrt{\\frac{1}{M}\\sum_{n=1}^{N-2}\\left(\\widehat{d}_{\\text{method}}[n] - x'(t_n)\\right)^2}}{\\sqrt{\\frac{1}{M}\\sum_{n=1}^{N-2} \\left(x'(t_n)\\right)^2}}\n$$\nwhere $M = N-2$.\n\nThe improvement factor $\\rho$ quantifies the performance gain of the smoothed method over the direct method:\n$$\n\\rho = \\frac{\\mathrm{rRMSE}_{\\text{direct}}}{\\mathrm{rRMSE}_{\\text{smooth}}}\n$$\nA value of $\\rho > 1$ indicates that smoothing improved the derivative estimate.\n\n**4. Implementation Strategy**\n\nThe solution will be implemented in Python using the `numpy` library for numerical operations and array handling, and `scipy.signal` for the convolution. A single function will execute the entire pipeline for each test case specified.\n\n- **Initialization**: Set up all constants and the pseudorandom number generator with the specified seed.\n- **Signal Generation**: Generate the discrete time vector `t`, the clean signal `x`, and the exact derivative `x_prime`.\n- **Main Loop**: Iterate through the provided test cases $(\\sigma_{\\eta}, \\sigma_g)$.\n- **Inside the Loop**:\n  1. Generate the noise vector $\\eta$ scaled by $\\sigma_{\\eta}$ and add it to `x` to create the noisy signal `y`.\n  2. **Method 1**: Compute `d_direct_est` by applying central differencing to `y`.\n  3. **Method 2**:\n     - If $\\sigma_g > 0$, construct the Gaussian kernel `g`, then compute the smoothed signal `z` using `scipy.signal.convolve(y, g, mode='same')`.\n     - If $\\sigma_g = 0$, set `z = y`.\n     - Compute `d_smooth_est` by applying central differencing to `z`.\n  4. **Error Calculation**:\n     - Define the target derivative `d_exact` by slicing `x_prime` to match the evaluation interval.\n     - Compute the RMS of the errors for both methods and the RMS of the exact derivative signal.\n     - Calculate $\\mathrm{rRMSE}_{\\text{direct}}$, $\\mathrm{rRMSE}_{\\text{smooth}}$, and $\\rho$.\n  5. Store the rounded results for the current test case.\n- **Output**: Format the collected results into the specified string format and print to standard output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the signal processing problem as defined.\n    Constructs a synthetic signal, adds noise, and compares two methods\n    for estimating its time derivative.\n    \"\"\"\n    # Define problem constants\n    f_s = 1000.0  # Sampling frequency in s^-1\n    N = 4096      # Number of samples\n    dt = 1.0 / f_s  # Sampling interval in s\n\n    A1 = 1.0\n    f1 = 5.0      # s^-1\n    A2 = 0.3\n    f2 = 40.0     # s^-1\n    A3 = 0.2      # s^-1\n\n    S = 1337      # Pseudorandom number generator seed\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sigma_eta, sigma_g)\n        (0.5, 0.0),\n        (0.5, 2.0),\n        (2.0, 4.0),\n        (0.0, 4.0),\n    ]\n\n    # Generate time vector, clean signal, and its exact derivative\n    t = np.arange(N) * dt\n    x = (A1 * np.sin(2 * np.pi * f1 * t) +\n         A2 * np.cos(2 * np.pi * f2 * t) +\n         A3 * t)\n    x_prime = (2 * np.pi * f1 * A1 * np.cos(2 * np.pi * f1 * t) -\n               2 * np.pi * f2 * A2 * np.sin(2 * np.pi * f2 * t) +\n               A3)\n\n    # Initialize the random number generator\n    rng = np.random.default_rng(seed=S)\n    \n    results = []\n    \n    # Process each test case\n    for sigma_eta, sigma_g in test_cases:\n        # Generate the noisy measurement\n        # The problem statement implies the stochastic process should be reproducible,\n        # which is achieved by using the same generator instance over the loop.\n        noise = sigma_eta * rng.standard_normal(N)\n        y = x + noise\n\n        # Method 1: Direct central differencing\n        # Valid for n in {1, ..., N-2}, resulting in N-2 points\n        d_direct_est = (y[2:] - y[:-2]) / (2 * dt)\n\n        # Method 2: Gaussian smoothing followed by central differencing\n        if sigma_g == 0.0:\n            z = y  # No smoothing\n        else:\n            # Define the discrete zero-phase Gaussian kernel\n            K = int(np.ceil(3 * sigma_g))\n            k = np.arange(-K, K + 1)\n            kernel_vals = np.exp(-k**2 / (2 * sigma_g**2))\n            g = kernel_vals / np.sum(kernel_vals)\n            \n            # Convolve the signal with the kernel\n            # 'same' mode ensures output length is N, with boundary effects\n            z = signal.convolve(y, g, mode='same')\n        \n        # Apply central difference to the smoothed signal\n        d_smooth_est = (z[2:] - z[:-2]) / (2 * dt)\n\n        # Quantify accuracy using relative RMS error\n        # The evaluation range is n in {1, ..., N-2}, so we slice the exact derivative\n        d_exact_eval = x_prime[1:-1]\n        \n        # Denominator for rRMSE: RMS of the exact derivative\n        rms_exact_deriv = np.sqrt(np.mean(d_exact_eval**2))\n\n        # Calculate rRMSE for the direct method\n        rms_err_direct = np.sqrt(np.mean((d_direct_est - d_exact_eval)**2))\n        rRMSE_direct = rms_err_direct / rms_exact_deriv\n\n        # Calculate rRMSE for the smoothed method\n        rms_err_smooth = np.sqrt(np.mean((d_smooth_est - d_exact_eval)**2))\n        rRMSE_smooth = rms_err_smooth / rms_exact_deriv\n        \n        # Handle potential division by zero if rRMSE_smooth is zero\n        if rRMSE_smooth == 0.0:\n            # This can happen in noise-free cases if the method is perfect.\n            # If direct is also zero, improvement is 1. Otherwise, infinite.\n            # Given the nature of the problem, this is unlikely.\n            rho = 1.0 if rRMSE_direct == 0.0 else np.inf\n        else:\n            rho = rRMSE_direct / rRMSE_smooth\n            \n        case_result = [\n            round(rRMSE_direct, 6),\n            round(rRMSE_smooth, 6),\n            round(rho, 6)\n        ]\n        results.append(case_result)\n\n    # Format the final output string as per requirements\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n\n```", "id": "2438105"}]}