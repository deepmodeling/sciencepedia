{"hands_on_practices": [{"introduction": "The journey into the frequency domain begins with a firm grasp of the Discrete Fourier Transform's fundamental definition. This first practice exercise is designed to build that foundation by having you compute a small-scale DFT by hand. By directly applying the summation formula [@problem_id:2213509], you will engage with the core mechanics of the transform, reinforcing your understanding of how a time-domain signal is decomposed into its constituent frequency components.", "problem": "In digital signal processing, the Discrete Fourier Transform (DFT) is a fundamental tool used to decompose a finite sequence of data points into its constituent frequency components.\n\nConsider a discrete-time complex signal represented by the sequence of $N=4$ samples: $x_0 = 1$, $x_1 = 2i$, $x_2 = 3$, and $x_3 = -i$, where $i = \\sqrt{-1}$.\n\nThe $N$-point DFT of a sequence $x_n$ (where $n=0, 1, \\dots, N-1$) is a sequence $X_k$ (where $k=0, 1, \\dots, N-1$) given by the analysis equation:\n$$X_k = \\sum_{n=0}^{N-1} x_n \\exp\\left(-i \\frac{2\\pi nk}{N}\\right)$$\nCompute the 4-point DFT sequence $X_k = [X_0, X_1, X_2, X_3]$ for the given signal $x_n$. Your final answer should be a sequence of four complex numbers, presented as a single row matrix.", "solution": "We use the DFT analysis equation for $N=4$:\n$$X_{k}=\\sum_{n=0}^{3}x_{n}\\exp\\left(-i\\frac{2\\pi nk}{4}\\right), \\quad k=0,1,2,3.$$\nDefine the primitive $4$th root of unity $W=\\exp\\left(-i\\frac{2\\pi}{4}\\right)=\\exp(-i\\frac{\\pi}{2})=-i$. Then $W^{0}=1$, $W^{1}=-i$, $W^{2}=-1$, $W^{3}=i$, and $W^{4}=1$.\n\nFor $k=0$:\n$$X_{0}=x_{0}W^{0\\cdot 0}+x_{1}W^{1\\cdot 0}+x_{2}W^{2\\cdot 0}+x_{3}W^{3\\cdot 0}=1+2i+3+(-i)=4+i.$$\n\nFor $k=1$:\n$$X_{1}=x_{0}W^{0}+x_{1}W^{1}+x_{2}W^{2}+x_{3}W^{3}=1+(2i)(-i)+3(-1)+(-i)(i)=1+2-3+1=1.$$\n\nFor $k=2$:\n$$X_{2}=x_{0}W^{0}+x_{1}W^{2}+x_{2}W^{4}+x_{3}W^{6}=1+(2i)(-1)+3(1)+(-i)(-1)=(1+3)+(-2i+i)=4-i.$$\n\nFor $k=3$:\n$$X_{3}=x_{0}W^{0}+x_{1}W^{3}+x_{2}W^{6}+x_{3}W^{9}=1+(2i)(i)+3(-1)+(-i)(-i)=1-2-3-1=-5.$$\n\nTherefore, the $4$-point DFT sequence is\n$$\\begin{pmatrix}4+i & 1 & 4-i & -5\\end{pmatrix}.$$", "answer": "$$\\boxed{\\begin{pmatrix}4+i & 1 & 4-i & -5\\end{pmatrix}}$$", "id": "2213509"}, {"introduction": "When we sample a continuous signal, we are only capturing snapshots of its behavior, which can sometimes be misleading. This exercise explores the critical concept of aliasing, a phenomenon where high-frequency signals can impersonate lower frequencies in the sampled data [@problem_id:2387236]. Understanding aliasing is not just an academic formality; it is essential for correctly interpreting the results of any DFT and avoiding severe errors in data analysis and physical simulations.", "problem": "Consider a continuous-time sinusoid $x(t) = \\sin\\!\\big(2\\pi f\\, t + \\phi\\big)$ sampled uniformly at sampling frequency $f_s$, so that samples are taken at times $t_n = n/f_s$ for integer $n$. The resulting discrete-time sequence is $x[n] = x(t_n)$. In computational physics, the Discrete Fourier Transform (DFT) is applied to $x[n]$ to analyze frequency content. Select the option that specifies two different sinusoids, one low-frequency and one high-frequency, that produce exactly identical samples $x[n]$ for all integer $n$ when sampled at $f_s$, thereby demonstrating aliasing below the Nyquist rate.\n\nAssume throughout that the sampling frequency is $f_s = 200\\,\\text{Hz}$, amplitudes are equal to $1$, and phases are as stated in each option. The Nyquist frequency is $f_s/2$.\n\nA. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 30\\, t\\big)$ and $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 230\\, t\\big)$\n\nB. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 30\\, t\\big)$ and $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 170\\, t\\big)$\n\nC. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 40\\, t\\big)$ and $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 240\\, t + \\pi/3\\big)$\n\nD. $x_{\\text{low}}(t) = \\sin\\!\\big(2\\pi \\cdot 75\\, t\\big)$ and $x_{\\text{high}}(t) = \\sin\\!\\big(2\\pi \\cdot 275\\, t + \\pi\\big)$", "solution": "The problem statement will first be validated for scientific soundness and consistency.\n\n### Step 1: Extract Givens\n- Continuous-time sinusoid: $x(t) = \\sin(2\\pi f t + \\phi)$\n- Sampling frequency: $f_s$\n- Sampling times: $t_n = n/f_s$ for integer $n$\n- Discrete-time sequence: $x[n] = x(t_n)$\n- Topic: Discrete Fourier Transform (DFT) in computational physics, specifically demonstrating aliasing.\n- Task: Identify which option presents two different sinusoids (low-frequency and high-frequency) that produce \"exactly identical samples $x[n]$ for all integer $n$\".\n- Specific values:\n    - Sampling frequency $f_s = 200\\,\\text{Hz}$.\n    - Amplitudes are equal to $1$.\n    - Phases $\\phi$ are as stated in each option.\n- Definition: Nyquist frequency is $f_s/2$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the required criteria.\n- **Scientifically Grounded**: The problem concerns the phenomenon of aliasing, a fundamental and well-established concept in digital signal processing, which is a core component of computational physics. The mathematical framework is based on standard Fourier analysis and trigonometry. The problem is scientifically sound.\n- **Well-Posed**: The problem is clearly stated. It asks to find a specific pair of functions from a finite list of options that satisfy a precisely defined mathematical condition (producing identical sample sequences). A unique solution among the choices is expected. The problem is well-posed.\n- **Objective**: The problem is described using precise mathematical language and objective parameters ($f_s$, signal form, frequencies, phases). There is no subjective or ambiguous terminology.\n- **Other Flaws**: The problem statement is complete, consistent, and contains no factual errors or unrealistic values. The phrase \"aliasing below the Nyquist rate\" is understood in context to mean a high-frequency signal appearing as an alias with a frequency below the Nyquist frequency, which is standard terminology for the result of aliasing.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. A solution will be derived.\n\nA continuous-time signal $x(t) = \\sin(2\\pi f t + \\phi)$ when sampled at a frequency $f_s$ results in the discrete-time sequence $x[n] = x(t_n) = \\sin(2\\pi f \\frac{n}{f_s} + \\phi)$.\n\nTwo distinct continuous-time sinusoids, $x_1(t) = \\sin(2\\pi f_1 t + \\phi_1)$ and $x_2(t) = \\sin(2\\pi f_2 t + \\phi_2)$, will produce identical sample sequences, i.e., $x_1[n] = x_2[n]$ for all integers $n$, if their respective arguments in the discrete domain are appropriately related. The discrete-time sequences are:\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_1}{f_s}n + \\phi_1\\right)$\n$x_2[n] = \\sin\\left(2\\pi \\frac{f_2}{f_s}n + \\phi_2\\right)$\n\nFor these two sequences to be identical, one of two primary conditions must be met, based on the properties of the sine function.\n\n**Condition I: Non-inverting Aliasing**\nThe arguments are equivalent modulo $2\\pi$. This occurs if the frequencies are related by $f_1 = f_2 + k f_s$ for some non-zero integer $k$. In this case:\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_2+kf_s}{f_s}n + \\phi_1\\right) = \\sin\\left(2\\pi \\frac{f_2}{f_s}n + 2\\pi k n + \\phi_1\\right)$\nSince $k$ and $n$ are integers, $2\\pi k n$ is an integer multiple of $2\\pi$. Because the sine function is periodic with period $2\\pi$, this simplifies to:\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_2}{f_s}n + \\phi_1\\right)$\nFor $x_1[n]$ to be identical to $x_2[n]$, the phases must be equal: $\\phi_1 \\equiv \\phi_2 \\pmod{2\\pi}$.\n\n**Condition II: Inverting Aliasing**\nThe arguments are related by the identity $\\sin(\\theta) = \\sin(\\pi - \\theta)$. This occurs if the frequencies are related by $f_1 = -f_2 + k f_s$ for some non-zero integer $k$. In this case:\n$x_1[n] = \\sin\\left(2\\pi \\frac{-f_2+kf_s}{f_s}n + \\phi_1\\right) = \\sin\\left(-2\\pi \\frac{f_2}{f_s}n + 2\\pi k n + \\phi_1\\right) = \\sin\\left(-2\\pi \\frac{f_2}{f_s}n + \\phi_1\\right)$\nUsing the identity $\\sin(-x) = \\sin(x+\\pi)$, we get:\n$x_1[n] = \\sin\\left(2\\pi \\frac{f_2}{f_s}n - \\phi_1 + \\pi\\right)$\nFor $x_1[n]$ to be identical to $x_2[n]$, the resulting phases must be equal: $-\\phi_1 + \\pi \\equiv \\phi_2 \\pmod{2\\pi}$, which is equivalent to $\\phi_1 + \\phi_2 \\equiv \\pi \\pmod{2\\pi}$.\n\nWe are given $f_s = 200\\,\\text{Hz}$. We test each option against these two conditions. In all options, $f_1$ will be $f_{\\text{high}}$ and $f_2$ will be $f_{\\text{low}}$.\n\n**A. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 30\\, t)$ and $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 230\\, t)$**\nHere, $f_{\\text{low}} = 30\\,\\text{Hz}$, $\\phi_{\\text{low}} = 0$, and $f_{\\text{high}} = 230\\,\\text{Hz}$, $\\phi_{\\text{high}} = 0$.\n- Test Condition I: Does $f_{\\text{high}} = f_{\\text{low}} + k f_s$ for an integer $k$?\n$230 = 30 + k(200) \\implies 200 = k(200) \\implies k=1$. Yes.\n- Test phase requirement for Condition I: Does $\\phi_{\\text{high}} = \\phi_{\\text{low}}$?\n$0 = 0$. Yes.\nBoth parts of Condition I are satisfied. The samples are identical.\nVerdict: **Correct**.\n\n**B. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 30\\, t)$ and $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 170\\, t)$**\nHere, $f_{\\text{low}} = 30\\,\\text{Hz}$, $\\phi_{\\text{low}} = 0$, and $f_{\\text{high}} = 170\\,\\text{Hz}$, $\\phi_{\\text{high}} = 0$.\n- Test Condition I: Does $f_{\\text{high}} = f_{\\text{low}} + k f_s$?\n$170 = 30 + k(200) \\implies 140 = k(200) \\implies k = 0.7$. Not an integer. Condition I fails.\n- Test Condition II: Does $f_{\\text{high}} = -f_{\\text{low}} + k f_s$?\n$170 = -30 + k(200) \\implies 200 = k(200) \\implies k=1$. Yes.\n- Test phase requirement for Condition II: Does $\\phi_{\\text{high}} + \\phi_{\\text{low}} = \\pi$?\n$0 + 0 = 0 \\neq \\pi$. Phase requirement fails.\nThe samples are not identical. In this case, $x_{\\text{high}}[n] = -x_{\\text{low}}[n]$.\nVerdict: **Incorrect**.\n\n**C. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 40\\, t)$ and $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 240\\, t + \\pi/3)$**\nHere, $f_{\\text{low}} = 40\\,\\text{Hz}$, $\\phi_{\\text{low}} = 0$, and $f_{\\text{high}} = 240\\,\\text{Hz}$, $\\phi_{\\text{high}} = \\pi/3$.\n- Test Condition I: Does $f_{\\text{high}} = f_{\\text{low}} + k f_s$?\n$240 = 40 + k(200) \\implies 200 = k(200) \\implies k=1$. Yes.\n- Test phase requirement for Condition I: Does $\\phi_{\\text{high}} = \\phi_{\\text{low}}$?\n$\\pi/3 \\neq 0$. Phase requirement fails.\n- Test Condition II: Does $f_{\\text{high}} = -f_{\\text{low}} + k f_s$?\n$240 = -40 + k(200) \\implies 280 = k(200) \\implies k=1.4$. Not an integer.\nThe samples are not identical.\nVerdict: **Incorrect**.\n\n**D. $x_{\\text{low}}(t) = \\sin(2\\pi \\cdot 75\\, t)$ and $x_{\\text{high}}(t) = \\sin(2\\pi \\cdot 275\\, t + \\pi)$**\nHere, $f_{\\text{low}} = 75\\,\\text{Hz}$, $\\phi_{\\text{low}} = 0$, and $f_{\\text{high}} = 275\\,\\text{Hz}$, $\\phi_{\\text{high}} = \\pi$.\n- Test Condition I: Does $f_{\\text{high}} = f_{\\text{low}} + k f_s$?\n$275 = 75 + k(200) \\implies 200 = k(200) \\implies k=1$. Yes.\n- Test phase requirement for Condition I: Does $\\phi_{\\text{high}} = \\phi_{\\text{low}}$?\n$\\pi \\neq 0$. Phase requirement fails.\n- Test Condition II: Does $f_{\\text{high}} = -f_{\\text{low}} + k f_s$?\n$275 = -75 + k(200) \\implies 350 = k(200) \\implies k=1.75$. Not an integer.\nThe samples are not identical.\nVerdict: **Incorrect**.", "answer": "$$\\boxed{A}$$", "id": "2387236"}, {"introduction": "While direct DFT calculation is instructive, its $\\mathcal{O}(N^2)$ complexity is prohibitive for real-world datasets. This hands-on capstone project challenges you to implement the revolutionary Cooley-Tukey Fast Fourier Transform (FFT) algorithm, which reduces the complexity to $\\mathcal{O}(N \\log N)$ [@problem_id:2387187]. By building the algorithm from scratch and using it to verify fundamental properties like the convolution theorem and Parseval's identity, you will gain invaluable practical experience and a deep appreciation for the engine that powers modern signal processing.", "problem": "Let $N$ be a positive integer of the form $N = 2^m$ for some nonnegative integer $m$. For a length-$N$ complex-valued sequence $x = \\{x_n\\}_{n=0}^{N-1}$, the discrete Fourier transform (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ is defined by\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\nand the inverse discrete Fourier transform (IDFT) is defined by\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\nwhere all angles are in radians.\n\nWrite a complete program that, without calling any library Fourier transform routines, computes the DFT and IDFT for sequences of length $N = 2^m$. Your program must also verify the following fundamental properties against explicit test cases using only these definitions:\n\n- Circular convolution theorem: For sequences $a$ and $b$ of length $N$, their length-$N$ circular convolution $c$ defined by $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$ satisfies $C_k = A_k B_k$, where $A$, $B$, and $C$ are the DFTs of $a$, $b$, and $c$, respectively.\n- Parseval identity (with the above normalization): $\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$.\n\nYour program must implement its own fast algorithm to compute the DFT and IDFT for $N = 2^m$, and must include a direct $\\mathcal{O}(N^2)$ DFT for verification. Use a numerical tolerance $\\varepsilon = 10^{-9}$ where boolean validations are required. All angles must be interpreted in radians.\n\nUse the following test suite, and produce the outputs in the order given below:\n\n- Test $1$ (DFT correctness versus direct DFT, happy path): Let $N = 8$ and $x = [0,1,2,3,4,3,2,1]$. Compute $X$ using your fast implementation and $\\tilde{X}$ using the direct DFT. Output a boolean equal to $\\text{True}$ if $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $2$ (Inverse transform recovery): Using the same $N$ and $x$ as in Test $1$, compute $x'$ by applying your IDFT to $X$ from your fast implementation. Output a boolean equal to $\\text{True}$ if $\\max_n |x'_n - x_n| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $3$ (Circular convolution via frequency domain): Let $N = 8$, $a = [1,2,3,0,0,0,0,0]$, and $b = [0,1,0,0,0,0,0,0]$. Compute the length-$N$ circular convolution $c$ directly from its definition. Separately, compute $\\hat{c}$ by taking the DFTs of $a$ and $b$, multiplying pointwise, and applying the IDFT. Output the scalar $\\max_n |c_n - \\hat{c}_n|$ as a floating-point number.\n- Test $4$ (Parseval identity): Let $N = 16$ and $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$ for $n = 0,1,\\dots,15$. Compute $X$ by your fast implementation. Output the scalar $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ as a floating-point number.\n- Test $5$ (Edge case $N=1$): Let $N = 1$ and $x = [3 + 4i]$. Compute $X$ and then $x'$ via IDFT. Output a boolean equal to $\\text{True}$ if $|x'_0 - x_0| \\le \\varepsilon$, otherwise $\\text{False}$.\n- Test $6$ (Smallest nontrivial size $N=2$): Let $N = 2$ and $x = [1,-1]$. Compute $X$ by your fast implementation. The exact DFT under the given convention is $[0,2]$. Output the scalar $\\max_k |X_k - [0,2]_k|$ as a floating-point number.\n\nFinal output format: Your program should produce a single line of output containing the six results, in order, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4,r_5,r_6]$. All boolean entries must be either $\\text{True}$ or $\\text{False}$, and all real-valued entries must be printed in standard decimal or scientific notation. No other text should be printed.", "solution": "The problem presented is a well-posed and scientifically sound exercise in computational physics, specifically in the area of signal processing. It requires the implementation and verification of the Discrete Fourier Transform (DFT), its inverse (IDFT), and fundamental associated theorems. The problem is complete, objective, and its resolution is verifiable. We will proceed with the solution.\n\nThe core of the problem is the computation of the DFT, $X$, for a given discrete, complex-valued sequence, $x = \\{x_n\\}_{n=0}^{N-1}$, of length $N$. The definition is given as:\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\nA direct implementation of this formula involves two nested loops, one for each index $k$ from $0$ to $N-1$ and one for each index $n$ from $0$ to $N-1$. This leads to a computational complexity of $\\mathcal{O}(N^2)$, which is inefficient for large $N$. For verification purposes, such a direct method will be implemented.\n\nThe problem specifies that $N$ is a power of two, i.e., $N = 2^m$ for some non-negative integer $m$. This structure is key for employing a Fast Fourier Transform (FFT) algorithm, specifically the Cooley-Tukey decimation-in-time algorithm. This algorithm reduces the complexity from $\\mathcal{O}(N^2)$ to $\\mathcal{O}(N \\log N)$. The principle is one of divide and conquer. The length-$N$ DFT is recursively broken down into two length-$(N/2)$ DFTs.\n\nLet the sequence $x_n$ be split into its even-indexed elements, forming a sequence $x'_m = x_{2m}$, and its odd-indexed elements, forming a sequence $x''_m = x_{2m+1}$, each of length $N/2$. The DFT sum can be rewritten as:\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\nLet $X'_k$ and $X''_k$ be the length-$(N/2)$ DFTs of $x'_m$ and $x''_m$, respectively. The expressions above become:\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\nwhere $W_N^k = e^{-2\\pi i k/N}$ is the \"twiddle factor\". For $k$ in the first half of the indices, $0 \\le k < N/2$, we have:\n$$\nX_k = X'_k + W_N^k X''_k\n$$\nFor the second half, where the index is $k+N/2$ for $0 \\le k < N/2$, we use the properties $X'_{k+N/2} = X'_k$, $X''_{k+N/2} = X''_k$, and $W_N^{k+N/2} = -W_N^k$. This yields:\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\nThis recursive definition allows the construction of the full DFT. The recursion terminates at the base case $N=1$, where the DFT of a sequence $\\{x_0\\}$ is simply $\\{X_0\\} = \\{x_0\\}$. Our implementation will follow this recursive structure.\n\nThe Inverse Discrete Fourier Transform (IDFT) is defined as:\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\nA separate implementation is not necessary. We can relate the IDFT to the forward DFT. Observe the following derivation:\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\nThe right-hand side is the DFT of the complex-conjugated sequence $\\{\\overline{X_k}\\}_{k=0}^{N-1}$. Therefore, we can find $x_n$ by computing the DFT of $\\overline{X}$, taking the complex conjugate of the result, and scaling by $1/N$. That is, $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$. This allows us to use our efficient FFT implementation to compute the inverse transform (IFFT) as well.\n\nThe problem further requires verification of two fundamental theorems.\n\nFirst, the circular convolution theorem. The circular convolution $c$ of two length-$N$ sequences, $a$ and $b$, is given by $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$. The theorem states that the DFT of the convolution is the pointwise product of the individual DFTs: $C_k = A_k B_k$. Thus, one can compute $c$ via the frequency domain: $c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$, where $\\odot$ denotes element-wise multiplication. We will test this by computing $c$ both directly and via the frequency domain route and comparing the results.\n\nSecond, Parseval's identity. For the given DFT normalization, the identity is:\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\nThis theorem relates the total energy of a signal in the time domain to its energy in the frequency domain. We will verify this for a specific test signal.\n\nThe program will proceed by first defining the necessary functions: a direct $\\mathcal{O}(N^2)$ DFT, a recursive $\\mathcal{O}(N \\log N)$ FFT, an IFFT based on the FFT, and a direct circular convolution function. Then, it will execute the $6$ specified test cases using these functions and a numerical tolerance of $\\varepsilon = 10^{-9}$ for comparisons. The results will be collected and printed in the required format.", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N = 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}]}