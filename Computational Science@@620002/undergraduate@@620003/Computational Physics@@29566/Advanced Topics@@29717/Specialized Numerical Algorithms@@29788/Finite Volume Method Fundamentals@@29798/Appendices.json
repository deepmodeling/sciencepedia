{"hands_on_practices": [{"introduction": "The guarantee of conservation is the hallmark of the Finite Volume Method, ensuring that physical quantities like mass or energy are conserved at the discrete level. This exercise provides a concrete understanding of this core principle by asking you to build a scheme that is *intentionally* non-conservative. By deriving and then simulating the predictable error growth from a small, systematic flux mismatch, you will gain a deeper appreciation for why strict flux bookkeeping at cell interfaces is paramount [@problem_id:2394360].", "problem": "You are to analyze and implement a one-dimensional Finite Volume Method (FVM) that deliberately violates conservation by a small amount per face and quantify the resulting global mass error growth. Consider the linear advection equation in one spatial dimension,\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\non a periodic domain $[0,L]$ with constant advection speed $a  0$. Use a uniform mesh with $N$ control volumes of width $\\Delta x = L/N$ and denote the cell average in cell $i$ at time level $n$ by $U_i^n$. The FVM semi-discrete balance for each cell is\n$$\n\\frac{d U_i}{d t} = - \\frac{1}{\\Delta x} \\left( F_{i+\\frac{1}{2}}^{(i)} - F_{i-\\frac{1}{2}}^{(i)} \\right),\n$$\nand the forward Euler time discretization is\n$$\nU_i^{n+1} = U_i^{n} - \\frac{\\Delta t}{\\Delta x} \\left( F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n} \\right).\n$$\nFor the base numerical flux, use first-order upwind for $a0$:\n$$\n\\widehat{F}_{i+\\frac{1}{2}}^n = a\\, U_i^n.\n$$\nIntroduce a deliberate non-conservative perturbation as follows: at each face $i+\\tfrac{1}{2}$, use two different flux values for its two neighboring cells so that the left cell $i$ uses\n$$\nF_{i+\\frac{1}{2}}^{(i),n} = \\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon,\n$$\nand the right cell $i+1$ uses\n$$\nF_{i+\\frac{1}{2}}^{(i+1),n} = \\widehat{F}_{i+\\frac{1}{2}}^n,\n$$\nwhere $\\epsilon$ is a small constant bias, identical for all faces and time steps. This choice makes the discrete scheme intentionally non-conservative by a fixed mismatch $\\epsilon$ at every face per time step. Use periodic indexing for all face quantities.\n\nTasks:\n1. From the integral form of conservation, the FVM update, and the above non-conservative flux construction, derive from first principles a closed-form expression for the global mass drift\n$$\n\\Delta M(T) = M(T) - M(0), \\quad M(t) \\equiv \\sum_{i=0}^{N-1} U_i(t)\\,\\Delta x,\n$$\nas a function of the number of faces $N_{\\text{faces}}$, the bias $\\epsilon$, and the final time $T$, assuming constant $\\epsilon$ in time and space and that the time step $\\Delta t$ and the number of steps $n_{\\text{steps}}$ satisfy $T = n_{\\text{steps}} \\Delta t$. Express $\\Delta M(T)$ in terms of $N_{\\text{faces}}$, $\\epsilon$, and $T$.\n\n2. Implement a program that:\n   - Initializes the solution at cell centers $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ with\n     $$\n     U_i^0 = \\sin\\left( \\frac{2\\pi x_i}{L} \\right) + 0.5.\n     $$\n   - Uses the above non-conservative fluxes with explicit Euler time stepping and periodic boundaries to advance the solution for $n_{\\text{steps}}$ steps with $\\Delta t = \\text{CFL}\\,\\Delta x/a$, where $\\text{CFL}\\in(0,1]$ is a prescribed Courant–Friedrichs–Lewy number.\n   - Computes the measured global mass drift $\\Delta M_{\\text{meas}} = M(T) - M(0)$ and compares it against the analytically predicted drift $\\Delta M_{\\text{pred}}$ from Task $1$.\n\n3. For each test case below, return the scalar difference\n$$\n\\delta = \\Delta M_{\\text{meas}} - \\Delta M_{\\text{pred}},\n$$\nas a floating-point number.\n\nAll quantities are dimensionless. Angles are in radians. There are no physical units to convert.\n\nTest suite (each tuple is $(N, L, a, \\epsilon, \\text{CFL}, n_{\\text{steps}})$):\n- Case A: $(50, 1.0, 1.0, 1.0\\times 10^{-6}, 0.6, 100)$.\n- Case B: $(1, 1.0, 1.0, 2.0\\times 10^{-7}, 0.4, 1000)$.\n- Case C: $(10, 2.0, 0.5, -1.0\\times 10^{-6}, 0.8, 250)$.\n- Case D: $(37, 1.5, 1.0, 0.0, 0.7, 123)$.\n\nAdditional specifications:\n- Use periodic boundaries and $N_{\\text{faces}}=N$ for all test cases.\n- Ensure stability by using $a0$ and $\\text{CFL}\\leq 1$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[r_A,r_B,r_C,r_D]\"), where each $r_\\cdot$ is the $\\delta$ corresponding to the specified test case, printed as a standard floating-point number.", "solution": "We begin from the integral conservation law for a scalar quantity over a control volume. For a uniform grid with cell width $\\Delta x$ and cell index $i$, the integral form for the one-dimensional linear advection equation with constant speed $a$ yields the semi-discrete Finite Volume Method (FVM)\n$$\n\\frac{dU_i}{dt} = -\\frac{1}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{(i)} - F_{i-\\frac{1}{2}}^{(i)} \\right),\n$$\nwhere $F_{i+\\frac{1}{2}}^{(i)}$ denotes the numerical flux used by cell $i$ at its right face $i+\\tfrac{1}{2}$, and $F_{i-\\frac{1}{2}}^{(i)}$ is the numerical flux used by cell $i$ at its left face $i-\\tfrac{1}{2}$. The forward Euler time discretization reads\n$$\nU_i^{n+1} = U_i^{n} - \\frac{\\Delta t}{\\Delta x}\\left( F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n} \\right).\n$$\nFor a conservative FVM, one enforces that each internal face $i+\\tfrac{1}{2}$ contributes a single flux value used with opposite sign by its two neighboring cells such that global conservation is guaranteed by telescoping when summing over all cells. Here, we deliberately violate this by defining, at each face $i+\\tfrac{1}{2}$, two distinct flux usages:\n- For the left cell $i$, we take\n$$\nF_{i+\\frac{1}{2}}^{(i),n} = \\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon,\n$$\n- For the right cell $i+1$, we take\n$$\nF_{i+\\frac{1}{2}}^{(i+1),n} = \\widehat{F}_{i+\\frac{1}{2}}^n,\n$$\nwith a constant bias $\\epsilon$ per face per time step. The base flux $\\widehat{F}_{i+\\frac{1}{2}}^n$ is the standard upwind flux for $a0$,\n$$\n\\widehat{F}_{i+\\frac{1}{2}}^n = a\\,U_i^n,\n$$\nwhich is consistent and conservative when used identically for both neighboring cells. Under periodic boundaries and uniform spacing, there are $N$ faces, which we denote collectively as the set of faces.\n\nGlobal mass at time level $n$ is\n$$\nM^n = \\sum_{i=0}^{N-1} U_i^n \\,\\Delta x.\n$$\nSumming the update over all cells,\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right)\n= -\\frac{\\Delta t}{\\Delta x}\\sum_{i=0}^{N-1}\\left(F_{i+\\frac{1}{2}}^{(i),n} - F_{i-\\frac{1}{2}}^{(i),n}\\right).\n$$\nReindex the second sum via $j=i-1$ to obtain\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right)\n= -\\frac{\\Delta t}{\\Delta x}\\sum_{\\text{faces}}\\left(F_{\\text{face}}^{(\\text{left}),n} - F_{\\text{face}}^{(\\text{right}),n}\\right).\n$$\nBy our construction,\n$$\nF_{\\text{face}}^{(\\text{left}),n} - F_{\\text{face}}^{(\\text{right}),n} = \\epsilon,\n$$\nfor every face at every time level. Therefore,\n$$\n\\sum_{i=0}^{N-1}\\left(U_i^{n+1} - U_i^n\\right) = -\\frac{\\Delta t}{\\Delta x} \\sum_{\\text{faces}} \\epsilon = -\\frac{\\Delta t}{\\Delta x}\\, N_{\\text{faces}}\\,\\epsilon.\n$$\nMultiplying both sides by $\\Delta x$ yields the global mass change per time step\n$$\nM^{n+1} - M^n = -\\Delta t\\, N_{\\text{faces}}\\,\\epsilon.\n$$\nThis shows that the mass drift per step is independent of the solution values and spatial discretization width, depending only on the number of faces, the time step, and the bias $\\epsilon$. Over $n_{\\text{steps}}$ steps with constant $\\Delta t$, the total drift is\n$$\n\\Delta M(T) \\equiv M(T) - M(0) = \\sum_{n=0}^{n_{\\text{steps}}-1} \\left(M^{n+1}-M^n\\right) = - n_{\\text{steps}} \\Delta t \\, N_{\\text{faces}}\\, \\epsilon = - T\\, N_{\\text{faces}}\\, \\epsilon,\n$$\nsince $T = n_{\\text{steps}}\\Delta t$. Under periodic boundary conditions on a uniform mesh, $N_{\\text{faces}} = N$. Hence,\n$$\n\\Delta M(T) = - T\\, N\\, \\epsilon.\n$$\n\nAlgorithmic design for the simulation:\n- Initialize $U_i^0 = \\sin\\left(\\frac{2\\pi x_i}{L}\\right) + 0.5$ at cell centers $x_i = \\left(i+\\tfrac{1}{2}\\right)\\Delta x$ for $i=0,\\dots,N-1$.\n- Choose $\\Delta t = \\text{CFL}\\,\\Delta x / a$ with $a0$ and $\\text{CFL}\\leq 1$ to satisfy the usual upwind stability restriction.\n- At each time step, compute the base upwind fluxes $\\widehat{F}_{i+\\frac{1}{2}}^n = a\\,U_i^n$ for $i=0,\\dots,N-1$ with periodic indexing. Apply the non-conservative usage by updating each cell with\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t}{\\Delta x}\\left[ \\left(\\widehat{F}_{i+\\frac{1}{2}}^n + \\epsilon\\right) - \\widehat{F}_{i-\\frac{1}{2}}^n \\right],\n$$\nwhere indices are taken modulo $N$.\n- After $n_{\\text{steps}}$ steps, compute the measured global mass drift $\\Delta M_{\\text{meas}} = M(T) - M(0)$ with $M(t) = \\sum_i U_i(t)\\Delta x$ and compare to the predicted $\\Delta M_{\\text{pred}} = - T\\,N\\,\\epsilon$ to obtain $\\delta = \\Delta M_{\\text{meas}} - \\Delta M_{\\text{pred}}$.\n\nThe program should run the specified test suite with:\n- Case A: $(N, L, a, \\epsilon, \\text{CFL}, n_{\\text{steps}}) = (50, 1.0, 1.0, 1.0\\times 10^{-6}, 0.6, 100)$,\n- Case B: $(1, 1.0, 1.0, 2.0\\times 10^{-7}, 0.4, 1000)$,\n- Case C: $(10, 2.0, 0.5, -1.0\\times 10^{-6}, 0.8, 250)$,\n- Case D: $(37, 1.5, 1.0, 0.0, 0.7, 123)$,\n\nand output a single line in the format \"[r_A,r_B,r_C,r_D]\" where each $r_\\cdot$ is the floating-point $\\delta$ for that case. Since the analysis is exact for the stated construction, the differences should be near zero up to floating-point roundoff.", "answer": "```python\nimport numpy as np\n\ndef run_case(N, L, a, eps, CFL, n_steps):\n    # Spatial discretization\n    N = int(N)\n    dx = L / N\n    # Time step from CFL condition (assume a  0 as per problem statement)\n    dt = CFL * dx / a\n    # Initialize solution: U_i^0 = sin(2*pi*x_i/L) + 0.5 at cell centers\n    i = np.arange(N)\n    x = (i + 0.5) * dx\n    U = np.sin(2.0 * np.pi * x / L) + 0.5\n\n    # Initial mass\n    M0 = dx * np.sum(U)\n\n    # Time stepping with non-conservative flux usage\n    for _ in range(n_steps):\n        # Base upwind fluxes at faces: F_hat[i] = a * U[i] for a  0\n        F_hat = a * U.copy()\n        # Update: U^{n+1} = U^n - (dt/dx) * [ (F_hat[i] + eps) - F_hat[i-1] ]\n        # periodic indexing: F_hat[i-1] corresponds to np.roll(F_hat, 1)[i]\n        U = U - (dt / dx) * ((F_hat + eps) - np.roll(F_hat, 1))\n\n    # Final mass\n    M_end = dx * np.sum(U)\n\n    # Measured mass drift\n    dM_meas = M_end - M0\n    # Predicted mass drift: - T * N * eps, with T = n_steps * dt\n    T = n_steps * dt\n    dM_pred = - T * N * eps\n\n    # Return difference\n    return dM_meas - dM_pred\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (N, L, a, eps, CFL, n_steps)\n    test_cases = [\n        (50, 1.0, 1.0, 1.0e-6, 0.6, 100),    # Case A\n        (1, 1.0, 1.0, 2.0e-7, 0.4, 1000),    # Case B\n        (10, 2.0, 0.5, -1.0e-6, 0.8, 250),   # Case C\n        (37, 1.5, 1.0, 0.0, 0.7, 123),       # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        N, L, a, eps, CFL, n_steps = case\n        delta = run_case(N, L, a, eps, CFL, n_steps)\n        # For stable output, represent as a float string with sufficient precision\n        results.append(f\"{delta:.12e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394360"}, {"introduction": "While a conservative scheme correctly tracks the total amount of a quantity, its accuracy in representing the quantity's distribution is a separate concern. First-order schemes, though simple and robust, often introduce an artificial smearing effect known as numerical diffusion. This practice challenges you to implement a first-order upwind scheme and directly measure this smearing, giving you a quantitative handle on one of the most important sources of error in computational fluid dynamics [@problem_id:2394306].", "problem": "Consider the linear advection equation in one spatial dimension,\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\n$$\non a periodic domain of length $L$, that is $x \\in [0,L)$ with periodic boundary conditions. The advection speed $a$ is a positive constant. Starting from the integral conservation law and the definition of finite volume averages on a uniform grid, derive a first-order, explicit, conservative finite volume method that is consistent with the physics of information propagation for $a0$.\n\nYou will investigate numerical diffusion by simulating the advection of a block step function and quantifying the smearing of the interface over time. Use a uniform mesh of $N$ cells with spatial step $\\Delta x = L/N$ and cell centers $x_i = (i+\\tfrac{1}{2})\\Delta x$, for $i=0,1,\\dots,N-1$. Let the initial condition be the block\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [x_L, x_R),\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\nwith $x_L = 0.2\\,L$ and $x_R = 0.7\\,L$. Evolve the solution using a first-order finite volume scheme with an explicit time step $\\Delta t$ chosen to satisfy a prescribed Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$. Use the same constant $\\nu$ for all time steps of a given simulation. Let the simulation run for a prescribed final time $T$; use an integer number of time steps $n = \\text{round}(T/\\Delta t)$ so that the simulated time is $t_n = n\\,\\Delta t$.\n\nDefine the \"smearing width\" of a descending interface at time $t_n$ as the minimal spatial distance (measured along the periodic domain) from the point where the cell-centered profile crosses the level $\\theta_{\\text{hi}} = 0.9$ downward to the subsequent point where it crosses the level $\\theta_{\\text{lo}} = 0.1$ downward. Compute these crossing points using linear interpolation of the cell-centered values between neighboring cell centers. In the presence of multiple descending interfaces (due to periodicity), compute the smearing width around each descending interface and report the minimal width. Express the width in the same dimensionless length units as $L$.\n\nImplement the simulation and the width measurement in a single program. For each test case below, output the measured smearing width at time $t_n$, rounded to $8$ decimal places.\n\nUse the following test suite, with parameters $(N,\\ \\nu,\\ T,\\ a,\\ L)$:\n- Case $1$: $(200,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $2$: $(200,\\ 0.9,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $3$: $(200,\\ 0.2,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $4$: $(50,\\ 0.5,\\ 0.2,\\ 1.0,\\ 1.0)$.\n- Case $5$: $(200,\\ 1.0,\\ 0.2,\\ 1.0,\\ 1.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, it should look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5],\n$$\nwhere each $\\text{result}_k$ is the smearing width for case $k$ rounded to $8$ decimal places. No other output is permitted.", "solution": "We start from the integral conservation form of the advection equation,\n$$\n\\partial_t u(x,t) + \\partial_x f(u) = 0,\\quad f(u) = a u,\\quad a0.\n$$\nLet $\\mathcal{C}_i = [x_{i-\\tfrac{1}{2}}, x_{i+\\tfrac{1}{2}}]$ be a control volume of uniform width $\\Delta x = x_{i+\\tfrac{1}{2}} - x_{i-\\tfrac{1}{2}}$, with cell center $x_i = (i+\\tfrac{1}{2})\\Delta x$ and periodic indexing. Define the cell average\n$$\n\\bar{u}_i(t) = \\frac{1}{\\Delta x}\\int_{\\mathcal{C}_i} u(x,t)\\,dx.\n$$\nIntegrating the conservation law over $\\mathcal{C}_i$ gives\n$$\n\\frac{d}{dt}\\left( \\int_{\\mathcal{C}_i} u(x,t)\\,dx \\right) + \\left[ f(u(x_{i+\\tfrac{1}{2}},t)) - f(u(x_{i-\\tfrac{1}{2}},t)) \\right] = 0,\n$$\nor equivalently,\n$$\n\\frac{d\\bar{u}_i}{dt} = -\\frac{1}{\\Delta x}\\left( f_{i+\\tfrac{1}{2}} - f_{i-\\tfrac{1}{2}} \\right),\n$$\nwhere $f_{i\\pm \\tfrac{1}{2}}$ are the fluxes through the cell faces. A first-order explicit time discretization with time step $\\Delta t$ yields\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left( \\hat{f}_{i+\\tfrac{1}{2}}^n - \\hat{f}_{i-\\tfrac{1}{2}}^n \\right),\n$$\nwith a numerical flux $\\hat{f}_{i+\\tfrac{1}{2}}^n$ consistent with the physics. For linear advection with $a0$, information propagates from left to right, and the exact Riemann solution at each interface depends only on the left state. The Godunov upwind numerical flux is therefore\n$$\n\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n\\quad\\text{for }a0.\n$$\nIntroducing the Courant–Friedrichs–Lewy (CFL) number $\\nu = a\\,\\Delta t/\\Delta x$, the update simplifies to the first-order upwind scheme\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\nu\\left(\\bar{u}_i^n - \\bar{u}_{i-1}^n\\right),\\quad a0,\n$$\nwith periodic indexing on $i$.\n\nTo relate this discrete method to a continuous process and expose numerical diffusion, we perform a modified equation analysis. Denote $\\bar{u}_i^n \\approx u(x_i,t^n)$ with $t^n = n\\Delta t$. A Taylor expansion in time gives\n$$\n\\bar{u}_i^{n+1} - \\bar{u}_i^n = \\Delta t\\,u_t(x_i,t^n) + \\mathcal{O}(\\Delta t^2).\n$$\nA Taylor expansion in space for the backward difference yields\n$$\n\\bar{u}_i^n - \\bar{u}_{i-1}^n = \\Delta x\\,u_x(x_i,t^n) - \\frac{\\Delta x^2}{2}u_{xx}(x_i,t^n) + \\frac{\\Delta x^3}{6}u_{xxx}(x_i,t^n) + \\mathcal{O}(\\Delta x^4).\n$$\nSubstituting into the scheme gives\n$$\n\\Delta t\\,u_t = -\\nu\\left[ \\Delta x\\,u_x - \\frac{\\Delta x^2}{2}u_{xx} + \\frac{\\Delta x^3}{6}u_{xxx} + \\cdots \\right] + \\mathcal{O}(\\Delta t^2).\n$$\nDividing by $\\Delta t$ and recalling $\\nu = a\\Delta t/\\Delta x$,\n$$\nu_t + a\\,u_x = \\frac{a\\,\\Delta x}{2}(1 - \\nu)\\,u_{xx} - \\frac{a\\,\\Delta x^2}{6}\\left(1 - 3\\nu + 2\\nu^2\\right)u_{xxx} + \\cdots.\n$$\nThe leading correction is a diffusion term with an effective (artificial) diffusion coefficient\n$$\nD_{\\text{num}} = \\frac{a\\,\\Delta x}{2}(1 - \\nu).\n$$\nThus for $0\\nu1$, the first-order upwind method introduces numerical diffusion that smears discontinuities over a width that grows like $\\sqrt{D_{\\text{num}}\\,t}$, whereas for $\\nu=1$ the leading diffusive term vanishes and the method reduces to a pure shift operator on the grid.\n\nTo quantify smearing for a step, we define the $10$–$90$ thickness. Consider a descending interface where $u$ drops from values near $1$ to values near $0$. Let $\\theta_{\\text{hi}} = 0.9$ and $\\theta_{\\text{lo}} = 0.1$. On the piecewise-constant cell-centered profile $\\{\\bar{u}_i^n\\}$, we determine the approximate positions where $u=\\theta$ by linear interpolation between neighboring cell centers. Specifically, for a pair of neighboring indices $(i,i+1)$ on a descending front with $\\bar{u}_i^n \\ge \\theta  \\bar{u}_{i+1}^n$,\n$$\nx(\\theta) \\approx x_i + \\Delta x \\frac{\\bar{u}_i^n - \\theta}{\\bar{u}_i^n - \\bar{u}_{i+1}^n}.\n$$\nWe collect all downward $\\theta_{\\text{hi}}$ crossings and all downward $\\theta_{\\text{lo}}$ crossings across the domain (with periodic wrap), and for each $\\theta_{\\text{hi}}$ crossing we determine the distance along the periodic coordinate to the subsequent $\\theta_{\\text{lo}}$ crossing. The minimal such distance, denoted $w_{10\\text{–}90}$, is the measured smearing width. This width is reported in the same length units as $L$.\n\nAlgorithmic design:\n- Spatial discretization: uniform cells, periodic boundary conditions, first-order upwind flux $\\hat{f}_{i+\\tfrac{1}{2}}^n = a\\,\\bar{u}_i^n$ for $a0$.\n- Time stepping: forward Euler with fixed $\\Delta t$ satisfying a prescribed $\\nu = a\\,\\Delta t/\\Delta x$; advance for $n=\\text{round}(T/\\Delta t)$ steps.\n- Initialization: block $u(x,0)=1$ on $[0.2L, 0.7L)$ and $0$ elsewhere on $[0,L)$, sampled at cell centers.\n- Width measurement: compute $w_{10\\text{–}90}$ using linear interpolation of cell-centered values and minimal downstream distance between $\\theta_{\\text{hi}}$ and $\\theta_{\\text{lo}}$ crossings along descending interfaces; use periodic unwrapping to handle interfaces near $x=0$.\n\nQualitative expectations based on $D_{\\text{num}}$: for fixed $a$, $L$, and $T$, finer grids (smaller $\\Delta x$) reduce $D_{\\text{num}}$ and thus reduce smearing; larger $\\nu$ (closer to $1$) also reduces $D_{\\text{num}}$, yielding narrower interfaces; at $\\nu=1$, the leading diffusive term vanishes and the interface is limited essentially to a grid-scale thickness. The program implements the scheme and measurement precisely and outputs, for each specified test case $(N,\\nu,T,a,L)$, the smearing width $w_{10\\text{–}90}(t_n)$ rounded to $8$ decimal places, aggregated as a single list on one line as required.", "answer": "```python\nimport numpy as np\n\ndef upwind_fvm_step(u, nu):\n    \"\"\"\n    First-order upwind finite volume update for a  0:\n    u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n), with periodic indexing.\n    \"\"\"\n    return u - nu * (u - np.roll(u, 1))\n\ndef initialize_block(N, L, xL_frac=0.2, xR_frac=0.7):\n    \"\"\"\n    Initialize u(x,0) = 1 on [x_L, x_R) and 0 elsewhere on [0,L), sampled at cell centers.\n    x_L = xL_frac * L, x_R = xR_frac * L.\n    \"\"\"\n    dx = L / N\n    x = (np.arange(N) + 0.5) * dx\n    xL = xL_frac * L\n    xR = xR_frac * L\n    u0 = np.where((x = xL)  (x  xR), 1.0, 0.0)\n    return x, u0\n\ndef interpolate_crossing_pos(x_i, x_ip1, u_i, u_ip1, theta, L):\n    \"\"\"\n    Linear interpolation between (x_i, u_i) and (x_ip1, u_ip1) to find x where u=theta.\n    The positions x_i and x_ip1 are assumed to be neighbors on a uniform periodic grid.\n    Returns position wrapped into [0, L).\n    \"\"\"\n    # Handle periodic wrap for positions if necessary (assume uniform spacing)\n    # For uniform grid, x_ip1 - x_i = dx and we do not need special position handling for periodicity;\n    # after computing the position, wrap into [0, L).\n    denom = (u_i - u_ip1)\n    if denom == 0.0:\n        return None\n    frac = (u_i - theta) / denom\n    # x along the straight line between centers\n    xi = x_i + (x_ip1 - x_i) * frac\n    # Wrap into [0, L)\n    xi_wrapped = xi % L\n    return xi_wrapped\n\ndef measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1):\n    \"\"\"\n    Measure the 10-90 smearing width on descending interfaces using linear interpolation\n    between neighboring cell centers. Returns the minimal width among all descending interfaces.\n    \"\"\"\n    N = len(u)\n    dx = L / N\n    # Build arrays of theta_hi and theta_lo crossing positions for descending fronts\n    hi_positions = []\n    lo_positions = []\n    for i in range(N):\n        ip1 = (i + 1) % N\n        u_i = u[i]\n        u_ip1 = u[ip1]\n        # Descending segment if u_i  u_ip1 (strict to avoid degenerate flat segments)\n        if u_i  u_ip1:\n            # theta_hi crossing: u_i = theta_hi  u_ip1\n            if (u_i = theta_hi) and (u_ip1  theta_hi):\n                xi = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_hi, L)\n                if xi is not None:\n                    hi_positions.append(xi)\n            # theta_lo crossing: u_i = theta_lo  u_ip1\n            if (u_i = theta_lo) and (u_ip1  theta_lo):\n                xl = interpolate_crossing_pos(x[i], x[ip1], u_i, u_ip1, theta_lo, L)\n                if xl is not None:\n                    lo_positions.append(xl)\n\n    # Sort positions\n    hi_positions = np.sort(np.array(hi_positions, dtype=float)) if len(hi_positions)  0 else np.array([], dtype=float)\n    lo_positions = np.sort(np.array(lo_positions, dtype=float)) if len(lo_positions)  0 else np.array([], dtype=float)\n\n    if hi_positions.size == 0 or lo_positions.size == 0:\n        # No descending interfaces detected; width undefined. Return 0.0 as fallback.\n        return 0.0\n\n    # For each hi crossing, find the next downstream lo crossing (with periodicity)\n    widths = []\n    for h in hi_positions:\n        # Compute downstream distances to all lo positions with periodic wrap\n        dists = []\n        for l in lo_positions:\n            d = l - h\n            if d  0:\n                d += L\n            dists.append(d)\n        if len(dists)  0:\n            widths.append(min(dists))\n    if len(widths) == 0:\n        return 0.0\n    return float(min(widths))\n\ndef simulate_and_measure(N, nu, T, a, L):\n    \"\"\"\n    Run the first-order upwind FVM for linear advection with given parameters and\n    measure the 10-90 smearing width at time ~ T.\n    \"\"\"\n    dx = L / N\n    dt = nu * dx / a\n    # Number of steps to approximate T with fixed dt\n    nsteps = int(np.round(T / dt))\n    # Initialize\n    x, u = initialize_block(N, L, xL_frac=0.2, xR_frac=0.7)\n    # Time-stepping\n    for _ in range(nsteps):\n        u = upwind_fvm_step(u, nu)\n    # Measure width\n    width = measure_smearing_width(u, x, L, theta_hi=0.9, theta_lo=0.1)\n    return width\n\ndef solve():\n    # Define the test cases: (N, nu, T, a, L)\n    test_cases = [\n        (200, 0.5, 0.2, 1.0, 1.0),  # Case 1\n        (200, 0.9, 0.2, 1.0, 1.0),  # Case 2\n        (200, 0.2, 0.2, 1.0, 1.0),  # Case 3\n        (50,  0.5, 0.2, 1.0, 1.0),  # Case 4\n        (200, 1.0, 0.2, 1.0, 1.0),  # Case 5\n    ]\n\n    results = []\n    for N, nu, T, a, L in test_cases:\n        width = simulate_and_measure(N, nu, T, a, L)\n        # Round to 8 decimal places as required\n        results.append(width)\n\n    # Final print statement in the exact required format with rounding\n    print(\"[\" + \",\".join(f\"{w:.8f}\" for w in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2394306"}, {"introduction": "Building on the fundamentals of discretization and flux balancing, this practice elevates the challenge to a two-dimensional, steady-state problem governed by the Poisson equation. You will construct a complete Finite Volume Method solver for heat conduction, incorporating boundary conditions and internal heat sources from first principles. This capstone exercise synthesizes core FVM concepts and applies them to a classic problem in computational physics and engineering, simulating a realistic physical system [@problem_id:2394364].", "problem": "You are tasked with constructing a complete, runnable program that applies the Finite Volume Method (FVM) to compute the steady-state temperature field in a two-dimensional rectangular domain with fixed temperature (Dirichlet) boundary conditions and internal, position-dependent heat sources. The physical model is steady heat conduction with a constant thermal conductivity. Your program must implement a control-volume discretization from first principles and solve the resulting linear system for a set of specified test cases.\n\nThe continuous model is given by the steady-state energy conservation law over any control volume, which for constant thermal conductivity reduces to the Poisson-type equation\n$$\n\\nabla \\cdot \\left( k \\, \\nabla T \\right) + q(x,y) = 0,\n$$\nin the domain\n$$\n\\Omega = \\{(x,y) \\mid 0 \\le x \\le L_x,\\; 0 \\le y \\le L_y\\},\n$$\nwhere $T$ is the temperature, $k$ is the constant thermal conductivity, and $q(x,y)$ is the volumetric heat source density. Dirichlet boundary conditions fix the temperature on the entire boundary $\\partial\\Omega$:\n$$\nT(0,y) = T_L,\\quad T(L_x,y) = T_R,\\quad T(x,0) = T_B,\\quad T(x,L_y) = T_T.\n$$\n\nDiscretization requirements:\n- Divide the domain into $N_x \\times N_y$ rectangular control volumes of uniform sizes $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. Place the unknown temperature $T_{i,j}$ at each cell center $(x_i,y_j)$ with $x_i = (i+\\tfrac{1}{2})\\Delta x$ and $y_j = (j+\\tfrac{1}{2})\\Delta y$, for integers $i \\in \\{0,\\dots,N_x-1\\}$ and $j \\in \\{0,\\dots,N_y-1\\}$.\n- Starting from the integral conservation law over a generic control volume and applying the divergence theorem, derive a discrete balance for each cell that uses diffusive fluxes through its faces. For interior faces, approximate the normal derivative by a centered two-point difference over the distance between adjacent cell centers. For boundary-adjacent faces with fixed boundary temperatures, impose the boundary at the face and approximate the normal derivative across a half-cell distance (from the cell center to the boundary face).\n- Assemble the resulting linear system for all $N_x N_y$ unknowns and solve it numerically.\n\nOutput requirements:\nFor each test case, your program must compute the following three quantities:\n1. The temperature at the control volume whose center is closest to $(L_x/2, L_y/2)$, denoted $T_{\\mathrm{center}}$ (in Kelvin).\n2. The area-averaged temperature over the domain, computed as the arithmetic mean of all cell-center temperatures for a uniform grid, denoted $T_{\\mathrm{avg}}$ (in Kelvin).\n3. The maximum temperature over all cell centers, denoted $T_{\\mathrm{max}}$ (in Kelvin).\n\nExpress all temperatures in Kelvin and round each reported float to $6$ decimal places.\n\nTest suite:\nUse the following three test cases, each specified completely.\n\n- Test case A (Gaussian source, isothermal boundary):\n  - Domain sizes: $L_x = 1.0\\,\\mathrm{m}$, $L_y = 1.0\\,\\mathrm{m}$.\n  - Grid: $N_x = 51$, $N_y = 51$.\n  - Thermal conductivity: $k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$.\n  - Boundary temperatures: $T_L = 300.0\\,\\mathrm{K}$, $T_R = 300.0\\,\\mathrm{K}$, $T_B = 300.0\\,\\mathrm{K}$, $T_T = 300.0\\,\\mathrm{K}$.\n  - Source: \n    $$\n    q(x,y) = A \\exp\\!\\big(-\\alpha\\big[(x-x_c)^2+(y-y_c)^2\\big]\\big),\\quad\n    A = 1.0\\times 10^6\\,\\mathrm{W\\,m^{-3}},\\;\\alpha = 80.0,\\;x_c = 0.5,\\;y_c = 0.5.\n    $$\n\n- Test case B (no source, left-right temperature difference):\n  - Domain sizes: $L_x = 1.0\\,\\mathrm{m}$, $L_y = 1.0\\,\\mathrm{m}$.\n  - Grid: $N_x = 51$, $N_y = 51$.\n  - Thermal conductivity: $k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$.\n  - Boundary temperatures: $T_L = 300.0\\,\\mathrm{K}$, $T_R = 400.0\\,\\mathrm{K}$, $T_B = 300.0\\,\\mathrm{K}$, $T_T = 300.0\\,\\mathrm{K}$.\n  - Source: $q(x,y) = 0$.\n\n- Test case C (Gaussian sink near corner, isothermal boundary):\n  - Domain sizes: $L_x = 1.0\\,\\mathrm{m}$, $L_y = 1.0\\,\\mathrm{m}$.\n  - Grid: $N_x = 51$, $N_y = 51$.\n  - Thermal conductivity: $k = 10.0\\,\\mathrm{W\\,m^{-1}\\,K^{-1}}$.\n  - Boundary temperatures: $T_L = 300.0\\,\\mathrm{K}$, $T_R = 300.0\\,\\mathrm{K}$, $T_B = 300.0\\,\\mathrm{K}$, $T_T = 300.0\\,\\mathrm{K}$.\n  - Source:\n    $\n    q(x,y) = A \\exp\\!\\big(-\\alpha\\big[(x-x_c)^2+(y-y_c)^2\\big]\\big),\\;\n    A = -7.0\\times 10^5\\,\\mathrm{W\\,m^{-3}},\\;\\alpha = 60.0,\\;x_c = 0.25,\\;y_c = 0.75.\n    $\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the three test cases as a comma-separated list of three sublists, each sublist containing the three floats in the order $[T_{\\mathrm{center}}, T_{\\mathrm{avg}}, T_{\\mathrm{max}}]$, with each float rounded to $6$ decimal places. The line must look like:\n  $$\n  [[t_{A,\\mathrm{center}},t_{A,\\mathrm{avg}},t_{A,\\mathrm{max}}],[t_{B,\\mathrm{center}},t_{B,\\mathrm{avg}},t_{B,\\mathrm{max}}],[t_{C,\\mathrm{center}},t_{C,\\mathrm{avg}},t_{C,\\mathrm{max}}]]\n  $$\nwith no additional text.", "solution": "The user requests a solution to a two-dimensional, steady-state heat conduction problem using the Finite Volume Method (FVM). The problem is first validated to ensure its scientific and logical integrity.\n\n### Problem Validation\n\n**1. Extracted Givens:**\n- **Governing Equation:** The steady-state heat conduction equation for a constant thermal conductivity, $k$, is given as a Poisson-type equation: $\\nabla \\cdot (k \\nabla T) + q(x,y) = 0$.\n- **Domain:** A rectangular domain $\\Omega = \\{(x,y) \\mid 0 \\le x \\le L_x,\\; 0 \\le y \\le L_y\\}$.\n- **Boundary Conditions:** Dirichlet conditions are specified on all four boundaries: $T(0,y) = T_L$, $T(L_x,y) = T_R$, $T(x,0) = T_B$, and $T(x,L_y) = T_T$.\n- **Discretization:** The domain is divided into a uniform grid of $N_x \\times N_y$ control volumes. The cell dimensions are $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. The unknown temperature $T_{i,j}$ is located at the cell center $(x_i, y_j) = ((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y)$.\n- **Numerical Method:** The problem demands a control-volume discretization based on the integral conservation law. Fluxes are to be approximated using centered differences for interior faces and half-cell differences for boundary faces.\n- **Outputs Required:** For each test case, compute $T_{\\mathrm{center}}$, $T_{\\mathrm{avg}}$, and $T_{\\mathrm{max}}$.\n- **Test Cases:** Three specific test cases (A, B, C) are fully defined with all necessary parameters for domain size, grid resolution, thermal conductivity, boundary temperatures, and source term functions.\n\n**2. Validation Analysis:**\n- **Scientific Grounding:** The problem is based on the fundamental principle of energy conservation applied to heat conduction, a core topic in physics and engineering. The governing equation is a standard elliptic partial differential equation (Poisson's equation). The physical parameters provided are realistic. The problem is scientifically sound.\n- **Well-Posedness:** The problem is a well-posed boundary value problem. For a linear elliptic PDE with Dirichlet boundary conditions, a unique and stable solution is guaranteed to exist. The specified FVM discretization leads to a diagonally dominant linear system, which also guarantees a unique numerical solution.\n- **Objectivity and Completeness:** The problem is stated in objective, mathematical terms. All data necessary for solving the problem—governing equation, domain, boundary conditions, material properties, source terms, and discretization parameters—are explicitly provided. The problem is self-contained and unambiguous.\n\n**3. Verdict and Action:**\nThe problem is deemed **valid**. It is a standard, well-defined problem in computational physics. A solution will be provided.\n\n### Discretization using the Finite Volume Method\n\nThe analysis begins with the integral form of the governing equation over a generic control volume $V_{i,j}$ centered at $(x_i, y_j)$ with volume $\\Delta V = \\Delta x \\Delta y \\cdot 1$:\n$$\n\\int_{V_{i,j}} \\left( \\nabla \\cdot (k \\, \\nabla T) + q(x,y) \\right) dV = 0\n$$\nApplying the divergence theorem to the first term and approximating the source term as constant over the cell, we get:\n$$\n\\oint_{\\partial V_{i,j}} (k \\, \\nabla T) \\cdot \\mathbf{n} \\, ds + \\bar{q}_{i,j} \\Delta x \\Delta y = 0\n$$\nwhere $\\partial V_{i,j}$ is the boundary of the control volume, $\\mathbf{n}$ is the outward unit normal vector, and $\\bar{q}_{i,j} = q(x_i, y_j)$. The integral represents the net heat flux leaving the control volume. The conservation principle states that the net heat outflow must be balanced by the heat generated within the volume. The heat flux vector is defined as $\\mathbf{J} = -k \\nabla T$. Therefore, the sum of heat outflows through the four faces (east, west, north, south) must equal the total heat generation:\n$$\n(\\text{Flux}_{e} + \\text{Flux}_{w} + \\text{Flux}_{n} + \\text{Flux}_{s})_{\\text{out}} = q(x_i, y_j) \\Delta x \\Delta y\n$$\nLet $T_{i,j}$ be the temperature at the center of the control volume $V_{i,j}$. Its neighbors are $T_{i \\pm 1, j}$ and $T_{i, j \\pm 1}$.\n\n**1. Interior Control Volume:**\nFor an interior cell, the fluxes are approximated using centered differences between adjacent cell centers:\n- East face (e): Flux$_{e} = k \\frac{T_{i,j} - T_{i+1,j}}{\\Delta x} \\Delta y$\n- West face (w): Flux$_{w} = k \\frac{T_{i,j} - T_{i-1,j}}{\\Delta x} \\Delta y$\n- North face (n): Flux$_{n} = k \\frac{T_{i,j} - T_{i,j+1}}{\\Delta y} \\Delta x$\n- South face (s): Flux$_{s} = k \\frac{T_{i,j} - T_{i,j-1}}{\\Delta y} \\Delta x$\n\nSubstituting into the balance equation and dividing by $\\Delta x \\Delta y$:\n$$\nk \\frac{T_{i,j}-T_{i+1,j}}{(\\Delta x)^2} + k \\frac{T_{i,j}-T_{i-1,j}}{(\\Delta x)^2} + k \\frac{T_{i,j}-T_{i,j+1}}{(\\Delta y)^2} + k \\frac{T_{i,j}-T_{i,j-1}}{(\\Delta y)^2} = q_{i,j}\n$$\nRearranging to form a linear equation for $T_{i,j}$:\n$$\n\\left(\\frac{2k}{(\\Delta x)^2} + \\frac{2k}{(\\Delta y)^2}\\right)T_{i,j} - \\frac{k}{(\\Delta x)^2}T_{i+1,j} - \\frac{k}{(\\Delta x)^2}T_{i-1,j} - \\frac{k}{(\\Delta y)^2}T_{i,j+1} - \\frac{k}{(\\Delta y)^2}T_{i,j-1} = q_{i,j}\n$$\n\n**2. Boundary Control Volume:**\nFor a control volume adjacent to a boundary, the flux calculation is modified. Consider a cell $(0,j)$ near the left boundary where $T(0,y) = T_L$. The distance from the cell center $x_0 = \\Delta x/2$ to the boundary at $x=0$ is $\\Delta x/2$.\nThe outflow through the west face is:\n$$\n\\text{Flux}_{w} = k \\frac{T_{0,j} - T_L}{\\Delta x / 2} \\Delta y\n$$\nThe energy balance for cell $(0,j)$ becomes:\n$$\nk \\frac{T_{0,j}-T_{1,j}}{\\Delta x} \\Delta y + k \\frac{T_{0,j}-T_L}{\\Delta x/2} \\Delta y + \\text{(N/S fluxes)} = q_{0,j} \\Delta x \\Delta y\n$$\nDividing by $\\Delta x \\Delta y$ and rearranging gives the algebraic equation:\n$$\n\\left(\\frac{3k}{(\\Delta x)^2} + \\frac{2k}{(\\Delta y)^2}\\right)T_{0,j} - \\frac{k}{(\\Delta x)^2}T_{1,j} - \\frac{k}{(\\Delta y)^2}T_{0,j+1} - \\frac{k}{(\\Delta y)^2}T_{0,j-1} = q_{0,j} + \\frac{2k}{(\\Delta x)^2}T_L\n$$\nAnalogous equations are derived for cells adjacent to the other three boundaries (right, top, bottom) and for corner cells, which are adjacent to two boundaries.\n\n**3. Linear System Assembly:**\nThe discrete equations for all $N = N_x \\times N_y$ control volumes form a large linear system of equations, $A\\mathbf{T} = \\mathbf{b}$, where $\\mathbf{T}$ is the vector of unknown cell-center temperatures. A single index $p = i + j \\times N_x$ is used to map the 2D grid of temperatures $T_{i,j}$ to the 1D vector $\\mathbf{T}$. The coefficient matrix $A$ is assembled based on the derived equations. For a cell $(i,j)$ with index $p$:\n- The diagonal element $A_{p,p}$ contains the coefficient of $T_{i,j}$.\n- The off-diagonal elements $A_{p, p\\pm1}$ and $A_{p, p\\pm N_x}$ contain the coefficients of the neighboring temperatures.\n- The right-hand-side vector element $b_p$ contains the source term $q_{i,j}$ and any contributions from the boundary conditions.\nThis system is then solved to find the temperature field. The resulting matrix $A$ is sparse, banded, and diagonally dominant, which ensures a unique solution can be found efficiently.\nThe required outputs—$T_{\\mathrm{center}}$, $T_{\\mathrm{avg}}$, and $T_{\\mathrm{max}}$—are calculated from the resulting temperature field.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve_case(Lx, Ly, Nx, Ny, k, T_bcs, q_func):\n    \"\"\"\n    Solves the 2D steady-state heat conduction problem for one test case.\n\n    Args:\n        Lx (float): Domain size in x-direction.\n        Ly (float): Domain size in y-direction.\n        Nx (int): Number of control volumes in x-direction.\n        Ny (int): Number of control volumes in y-direction.\n        k (float): Thermal conductivity.\n        T_bcs (dict): Dictionary of boundary temperatures {'L', 'R', 'B', 'T'}.\n        q_func (callable): Function for the heat source q(x, y).\n\n    Returns:\n        list: A list containing [T_center, T_avg, T_max].\n    \"\"\"\n    dx = Lx / Nx\n    dy = Ly / Ny\n    \n    # Coefficients from discretization\n    Cx = k / dx**2\n    Cy = k / dy**2\n\n    N = Nx * Ny\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n\n    # Cell center coordinates\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n\n    # Assemble matrix A and vector b\n    for j in range(Ny):\n        for i in range(Nx):\n            p = i + j * Nx  # 1D index for the current cell (i, j)\n            x, y = x_centers[i], y_centers[j]\n\n            # Diagonal element initialization (from interior point stencil)\n            A[p, p] = 2 * Cx + 2 * Cy\n            b[p] = q_func(x, y)\n\n            # West neighbor (i-1, j) or Left boundary\n            if i  0:\n                A[p, p - 1] = -Cx\n            else:  # Left boundary at x=0\n                A[p, p] += Cx\n                b[p] += 2 * Cx * T_bcs['L']\n\n            # East neighbor (i+1, j) or Right boundary\n            if i  Nx - 1:\n                A[p, p + 1] = -Cx\n            else:  # Right boundary at x=Lx\n                A[p, p] += Cx\n                b[p] += 2 * Cx * T_bcs['R']\n\n            # South neighbor (i, j-1) or Bottom boundary\n            if j  0:\n                A[p, p - Nx] = -Cy\n            else:  # Bottom boundary at y=0\n                A[p, p] += Cy\n                b[p] += 2 * Cy * T_bcs['B']\n\n            # North neighbor (i, j+1) or Top boundary\n            if j  Ny - 1:\n                A[p, p + Ny] = -Cy\n            else:  # Top boundary at y=Ly\n                A[p, p] += Cy\n                b[p] += 2 * Cy * T_bcs['T']\n\n    # Solve the linear system A * T = b\n    T_vector = linalg.solve(A, b)\n    T_field = T_vector.reshape((Ny, Nx))\n\n    # Calculate required outputs\n    center_ix = Nx // 2\n    center_iy = Ny // 2\n    T_center = T_field[center_iy, center_ix]\n    T_avg = np.mean(T_field)\n    T_max = np.max(T_field)\n\n    return [T_center, T_avg, T_max]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver, and print results.\n    \"\"\"\n    # Define source functions for each case\n    def q_A(x, y):\n        A = 1.0e6\n        alpha = 80.0\n        xc, yc = 0.5, 0.5\n        return A * np.exp(-alpha * ((x - xc)**2 + (y - yc)**2))\n\n    def q_B(x, y):\n        return 0.0\n\n    def q_C(x, y):\n        A = -7.0e5\n        alpha = 60.0\n        xc, yc = 0.25, 0.75\n        return A * np.exp(-alpha * ((x - xc)**2 + (y - yc)**2))\n\n    test_cases = [\n        # Test case A\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 300.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_A},\n        # Test case B\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 400.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_B},\n        # Test case C\n        {'Lx': 1.0, 'Ly': 1.0, 'Nx': 51, 'Ny': 51, 'k': 10.0,\n         'T_bcs': {'L': 300.0, 'R': 300.0, 'B': 300.0, 'T': 300.0},\n         'q_func': q_C}\n    ]\n\n    results = []\n    for case in test_cases:\n        case_results = solve_case(\n            case['Lx'], case['Ly'], case['Nx'], case['Ny'],\n            case['k'], case['T_bcs'], case['q_func']\n        )\n        results.append(case_results)\n\n    # Format the final output string exactly as specified\n    formatted_results = []\n    for res_case in results:\n        formatted_case = [f\"{val:.6f}\" for val in res_case]\n        formatted_results.append(f\"[{','.join(formatted_case)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2394364"}]}