{"hands_on_practices": [{"introduction": "Before diving into complex numerical implementations, it is crucial to build intuition with a case that can be solved analytically. This first practice [@problem_id:2408430] examines the evolution of a simple circular interface moving with a constant normal speed $F$. By solving the level set equation for this fundamental scenario, you will directly see how the PDE formulation captures the geometric concept of a shrinking or expanding circle, providing a solid foundation for the more complex problems to follow.", "problem": "Consider the motion of a closed interface in two spatial dimensions represented implicitly by a Level Set Method (LSM). The interface at time $t$ is the zero level set of a function $\\phi(x,y,t)$ that evolves according to the Partial Differential Equation (PDE)\n$$\\phi_t + F \\lvert \\nabla \\phi \\rvert = 0,$$\nwhere $F$ is a spatially and temporally constant normal speed with units of meters per second. The initial condition is the signed distance to a circle of radius $R_0$ centered at the origin,\n$$\\phi(x,y,0) = \\sqrt{x^2 + y^2} - R_0,$$\nso that the initial zero level set $\\{\\phi=0\\}$ is the circle of radius $R_0$. Distances are in meters, time is in seconds, and $F$ is in meters per second.\n\nFor each test case specified by parameters $(R_0, F, t)$:\n- Compute the radius $R(t)$ of the zero level set at time $t$, in meters.\n- Compute the area $A(t)$ enclosed by the zero level set at time $t$, in square meters, defined as $A(t) = \\pi \\, R(t)^2$.\n- Compute the collapse time $T_c$ in seconds, defined as the earliest time $t \\ge 0$ for which the radius becomes zero. If the interface never collapses (for example, if $F \\ge 0$), return $-1.0$ for $T_c$. If $R_0 = 0$, define $T_c = 0.0$.\n\nAll outputs must be expressed in the units specified, rounded to six decimal places. The required final output format is a single line containing a comma-separated list of per-test-case results, enclosed in square brackets, where each per-test-case result is itself a list in the form $[R(t), A(t), T_c]$.\n\nUse the following test suite:\n- Test 1 (shrinking, before collapse): $(R_0, F, t) = (1.0, -0.2, 3.0)$.\n- Test 2 (shrinking, exactly at collapse): $(R_0, F, t) = (1.0, -0.5, 2.0)$.\n- Test 3 (shrinking, after collapse): $(R_0, F, t) = (0.75, -3.0, 1.0)$.\n- Test 4 (expanding, no collapse): $(R_0, F, t) = (0.6, 0.05, 10.0)$.\n- Test 5 (already collapsed initially): $(R_0, F, t) = (0.0, -1.0, 0.5)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example:\n\"[ [R1,A1,Tc1],[R2,A2,Tc2],...[R5,A5,Tc5] ]\"\nwith each numerical entry rounded to six decimal places.", "solution": "The problem requires an analytical solution for the evolution of a circular interface governed by the level set equation. The problem statement is scientifically sound, well-posed, and contains all necessary information. It is a standard application of the Level Set Method for which an analytical solution can be derived. Therefore, the problem is valid.\n\nThe evolution of the level set function $\\phi(x,y,t)$ is described by the Hamilton-Jacobi partial differential equation:\n$$ \\phi_t + F |\\nabla \\phi| = 0 $$\nwhere $\\phi_t = \\frac{\\partial \\phi}{\\partial t}$ and $\\nabla \\phi$ is the gradient of $\\phi$ with respect to spatial variables $(x,y)$. $F$ is a constant normal velocity.\n\nThe initial condition specifies the interface as a circle of radius $R_0$ centered at the origin. The function $\\phi(x,y,0)$ is given as the signed distance function to this circle:\n$$ \\phi(x,y,0) = \\sqrt{x^2 + y^2} - R_0 $$\nThe zero level set $\\{\\phi=0\\}$ is indeed the circle $x^2 + y^2 = R_0^2$.\n\nDue to the radial symmetry of the initial condition and the constant, spatially uniform velocity $F$, the evolving interface will remain a circle for all time $t \\ge 0$. The radius of this circle, let us call it $R(t)$, will be a function of time. We can thus propose an ansatz for the solution $\\phi(x,y,t)$ that preserves the form of a signed distance function to a circle of time-dependent radius $R(t)$:\n$$ \\phi(x,y,t) = \\sqrt{x^2 + y^2} - R(t) $$\nFor this to be consistent with the initial condition, we must have $R(0) = R_0$.\n\nWe now substitute this ansatz into the PDE. First, we compute the necessary derivatives. Let $r = \\sqrt{x^2+y^2}$. Then $\\phi(r, t) = r - R(t)$.\nThe partial derivative with respect to time $t$ is:\n$$ \\phi_t = \\frac{\\partial}{\\partial t} \\left( \\sqrt{x^2 + y^2} - R(t) \\right) = - \\frac{dR}{dt} = -R'(t) $$\nThe gradient of $\\phi$ is:\n$$ \\nabla \\phi = \\left( \\frac{\\partial \\phi}{\\partial x}, \\frac{\\partial \\phi}{\\partial y} \\right) = \\left( \\frac{x}{\\sqrt{x^2+y^2}}, \\frac{y}{\\sqrt{x^2+y^2}} \\right) = \\left( \\frac{x}{r}, \\frac{y}{r} \\right) $$\nThe magnitude of the gradient is:\n$$ |\\nabla \\phi| = \\sqrt{\\left(\\frac{x}{r}\\right)^2 + \\left(\\frac{y}{r}\\right)^2} = \\sqrt{\\frac{x^2+y^2}{r^2}} = 1 $$\nThis is a fundamental property of a signed distance function: its gradient has unit magnitude (except at the origin, which is a single point).\n\nSubstituting these expressions for $\\phi_t$ and $|\\nabla \\phi|$ into the level set equation gives:\n$$ -R'(t) + F(1) = 0 $$\n$$ R'(t) = F $$\nThis is a simple first-order ordinary differential equation for $R(t)$. We can solve it by integrating with respect to time from $0$ to $t$:\n$$ \\int_0^t R'(\\tau) d\\tau = \\int_0^t F d\\tau $$\n$$ R(t) - R(0) = F t $$\nUsing the initial condition $R(0) = R_0$, we obtain the solution for the evolution of the radius:\n$$ R(t) = R_0 + F t $$\nA physical radius cannot be negative. If $R_0 + F t$ becomes negative, it signifies that the interface has collapsed and vanished. In this case, the radius of the (now non-existent) zero level set is $0$. Therefore, the physically correct radius of the interface at time $t$ is:\n$$ R(t) = \\max(0, R_0 + F t) $$\n\nWith this analytical solution for $R(t)$, we can determine the other required quantities.\n\n1.  **Radius $R(t)$**: The radius in meters at time $t$ is given by $R(t) = \\max(0, R_0 + F t)$.\n\n2.  **Area $A(t)$**: The area in square meters enclosed by the circular interface is $A(t) = \\pi R(t)^2$.\n\n3.  **Collapse Time $T_c$**: This is the earliest time $t \\ge 0$ at which $R(t)=0$.\n    We set $R_0 + F t = 0$, which gives $t = -R_0/F$.\n    This calculation must be interpreted according to the given rules:\n    -   If $R_0=0$, the circle is already collapsed. The problem specifies $T_c = 0.0$.\n    -   If $R_0  0$ and $F \\ge 0$, the radius is non-decreasing and will never reach $0$. The problem specifies $T_c = -1.0$.\n    -   If $R_0  0$ and $F  0$, the circle is shrinking. The collapse will occur at the positive time $T_c = -R_0/F$.\n\nThese derived formulae are now applied to each test case.\n- **Test 1**: $(R_0, F, t) = (1.0, -0.2, 3.0)$.\n  $R(3.0) = \\max(0, 1.0 + (-0.2)(3.0)) = \\max(0, 0.4) = 0.4$ m.\n  $A(3.0) = \\pi (0.4)^2 = 0.16\\pi \\approx 0.502655$ m$^2$.\n  $T_c = -1.0 / (-0.2) = 5.0$ s.\n\n- **Test 2**: $(R_0, F, t) = (1.0, -0.5, 2.0)$.\n  $R(2.0) = \\max(0, 1.0 + (-0.5)(2.0)) = \\max(0, 0.0) = 0.0$ m.\n  $A(2.0) = \\pi (0.0)^2 = 0.0$ m$^2$.\n  $T_c = -1.0 / (-0.5) = 2.0$ s.\n\n- **Test 3**: $(R_0, F, t) = (0.75, -3.0, 1.0)$.\n  $T_c = -0.75 / (-3.0) = 0.25$ s.\n  Since $t=1.0  T_c=0.25$, the circle has already collapsed.\n  $R(1.0) = \\max(0, 0.75 + (-3.0)(1.0)) = \\max(0, -2.25) = 0.0$ m.\n  $A(1.0) = \\pi (0.0)^2 = 0.0$ m$^2$.\n\n- **Test 4**: $(R_0, F, t) = (0.6, 0.05, 10.0)$.\n  $R(10.0) = \\max(0, 0.6 + (0.05)(10.0)) = \\max(0, 1.1) = 1.1$ m.\n  $A(10.0) = \\pi (1.1)^2 = 1.21\\pi \\approx 3.801327$ m$^2$.\n  Since $F \\ge 0$, the interface never collapses, so $T_c = -1.0$ s.\n\n- **Test 5**: $(R_0, F, t) = (0.0, -1.0, 0.5)$.\n  Since $R_0=0$, the problem states $T_c=0.0$ s.\n  $R(0.5) = \\max(0, 0.0 + (-1.0)(0.5)) = \\max(0, -0.5) = 0.0$ m.\n  $A(0.5) = \\pi (0.0)^2 = 0.0$ m$^2$.\n\nThe implementation will codify these analytical results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the level set problem for a circular interface.\n\n    The problem describes a circular interface evolving with a constant normal\n    speed F. The radius R(t) of the circle at time t can be found by\n    solving the ODE R'(t) = F with initial condition R(0) = R0.\n    This gives R_candidate(t) = R0 + F*t.\n\n    The physical radius cannot be negative, so R(t) = max(0, R0 + F*t).\n    The area is A(t) = pi * R(t)^2.\n    The collapse time Tc is the time when R(t) first becomes 0.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (R0, F, t)\n        (1.0, -0.2, 3.0),  # Test 1: shrinking, before collapse\n        (1.0, -0.5, 2.0),  # Test 2: shrinking, exactly at collapse\n        (0.75, -3.0, 1.0), # Test 3: shrinking, after collapse\n        (0.6, 0.05, 10.0), # Test 4: expanding, no collapse\n        (0.0, -1.0, 0.5),  # Test 5: already collapsed initially\n    ]\n\n    results = []\n    for case in test_cases:\n        R0, F, t = case\n\n        # 1. Compute the radius R(t)\n        # The radius evolution is R(t) = R0 + F*t, but physical radius is non-negative.\n        R_t = max(0.0, R0 + F * t)\n\n        # 2. Compute the area A(t)\n        A_t = np.pi * R_t**2\n\n        # 3. Compute the collapse time T_c\n        # As per problem definition:\n        # If R0 = 0, Tc = 0.0\n        # If R0  0 and F = 0, never collapses, Tc = -1.0\n        # If R0  0 and F  0, collapses at Tc = -R0 / F\n        if R0 == 0.0:\n            T_c = 0.0\n        elif F = 0.0:\n            T_c = -1.0\n        else: # R0  0 and F  0\n            T_c = -R0 / F\n\n        # Round all results to six decimal places\n        R_t_rounded = round(R_t, 6)\n        A_t_rounded = round(A_t, 6)\n        T_c_rounded = round(T_c, 6)\n\n        # Format the result for a single case as requested: [R,A,Tc]\n        # with no spaces.\n        case_result_str = (\n            f\"[{R_t_rounded},{A_t_rounded},{T_c_rounded}]\"\n        )\n        results.append(case_result_str)\n\n    # Final print statement in the exact required format:\n    # \"[ [R1,A1,Tc1],[R2,A2,Tc2],... ]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2408430"}, {"introduction": "This exercise [@problem_id:2408442] marks the transition from analytical solutions to a full numerical simulation, a core skill in computational physics. You will model an interface that deforms and splits into two, driven by a spatially-varying velocity field that mimics cellular division. This practice will require you to implement a robust monotone upwind scheme to handle the evolution, manage numerical stability through the CFL condition, and use periodic reinitialization to maintain a well-behaved level set function, showcasing the method's power in handling complex topological changes.", "problem": "You are asked to implement a Level Set Method (LSM) simulation to model the splitting of a closed interface that initially coincides with an ellipse. The evolution is governed by a spatially dependent normal speed. You must derive a stable, monotone, first-order upwind (Godunov-type) discretization of the Hamilton–Jacobi Partial Differential Equation (PDE) and implement it in code. The objective is to test whether the evolving interface undergoes topological change (splitting), quantified as the number of connected components of the interior phase at the end of the simulation. All quantities here are dimensionless; no physical units are required.\n\nThe evolution of the level set function is given by the PDE\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0,\n$$\nwhere $\\phi(x,y,t)$ is a scalar field such that the evolving interface is the zero isocontour $\\{\\phi = 0\\}$ and the interior is $\\{\\phi \\le 0\\}$. The speed field is spatially dependent and is prescribed as\n$$\nF(x,y) = \\beta - \\alpha \\exp\\!\\left(-\\frac{y^2}{s^2}\\right).\n$$\nHere, $\\alpha$, $\\beta$, and $s$ are strictly positive parameters. The domain is the square $[-1,1] \\times [-1,1]$ discretized on a uniform Cartesian grid.\n\nInitial condition:\n- The initial interface is an ellipse given implicitly by\n$$\n\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1,\n$$\nand the initial level set field $\\phi(x,y,0)$ must be constructed so that $\\phi \\le 0$ inside the ellipse and $\\phi  0$ outside. For numerical stability, you must reinitialize $\\phi$ to a signed distance function at $t=0$ and periodically during the simulation. Reinitialization can be done by any consistent method that produces a field approximating the signed distance to the zero level set; a common approach uses the Euclidean Distance Transform (EDT) computed on the binary interior mask $\\{\\phi \\le 0\\}$.\n\nDiscretization and stability requirements:\n- Derive and implement a first-order monotone upwind (Godunov) approximation of $\\lvert \\nabla \\phi \\rvert$ that is consistent with the sign of $F(x,y)$, using one-sided finite differences on a uniform grid with spacings $\\Delta x$ and $\\Delta y$.\n- Use an explicit forward Euler time integrator with a time step $\\Delta t$ satisfying a Courant–Friedrichs–Lewy (CFL) stability constraint derived from the characteristic speed of the Hamilton–Jacobi PDE. You must choose\n$$\n\\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert},\n$$\nwith a constant $\\mathrm{CFL}$ such that $0  \\mathrm{CFL} \\le 1$.\n- Apply homogeneous Neumann boundary conditions (zero normal derivative) numerically by using appropriate one-sided differences or value replication at the boundary.\n\nTopological query:\n- At the end of each simulation, compute the number of connected components of the interior set $\\{\\phi \\le 0\\}$ using $4$-connectivity on the grid.\n\nYour program must implement the following and produce the required outputs for the specified test suite. No user input is allowed; all parameters are embedded in the code.\n\nImplementation requirements:\n- Construct the uniform grid on $[-1,1] \\times [-1,1]$ with $N \\times N$ nodes, $N \\ge 5$, with grid spacings $\\Delta x = \\Delta y = \\frac{2}{N-1}$.\n- Initialize $\\phi(x,y,0)$ from the ellipse with semi-axes $a$ and $b$ so that $\\phi \\le 0$ inside. Then, reinitialize to a signed-distance field at $t=0$.\n- Evolve $\\phi$ using the PDE $\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0$, a monotone upwind Godunov discretization of $\\lvert \\nabla \\phi \\rvert$, and forward Euler time integration with stable $\\Delta t$ determined from the CFL condition.\n- Reinitialize $\\phi$ periodically during time stepping to maintain $\\lvert \\nabla \\phi \\rvert \\approx 1$ near the interface.\n- After the final time step, compute the number of connected components of $\\{\\phi \\le 0\\}$ with $4$-connectivity.\n\nTest suite:\nRun the simulation for each of the following parameter sets; report the number of connected interior components at the final time for each case.\n\n- Case A (intended to split into two): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 220$, reinitialization every $\\;5\\;$ steps.\n- Case B (intended to remain one component): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.1$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 220$, reinitialization every $\\;5\\;$ steps.\n- Case C (borderline, insufficient time to split): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 0.35$, $\\beta = 0.25$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 100$, reinitialization every $\\;5\\;$ steps.\n- Case D (strong splitting): $N = 101$, $a = 0.7$, $b = 0.3$, $\\alpha = 1.3$, $\\beta = 0.20$, $s = 0.2$, $\\mathrm{CFL} = 0.5$, number of Euler steps $= 260$, reinitialization every $\\;5\\;$ steps.\n\nFinal output specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the same order as the test cases above. Each entry is an integer equal to the number of connected interior components. For example, a valid output would be of the form\n$\n[\\;n_A, n_B, n_C, n_D\\;]\n$\nwhere $n_A$, $n_B$, $n_C$, and $n_D$ are integers.\n\nConstraints and notes:\n- You must not use any external data or user input.\n- All variables, functions, operators, and numbers appearing as mathematics in this specification are written in LaTeX.\n- The algorithm must be derived from core definitions of the Level Set Method, Hamilton–Jacobi equations, monotone upwind discretization, and the Courant–Friedrichs–Lewy condition.", "solution": "The problem presented is a well-posed initial boundary value problem in computational physics, requiring the simulation of a moving interface using the Level Set Method. The problem is scientifically grounded, formally specified, and objective. It contains all necessary information to proceed with a numerical solution. Therefore, the problem is deemed valid.\n\nThe task is to solve the Level Set equation, which is a type of Hamilton-Jacobi Partial Differential Equation (PDE):\n$$\n\\phi_t + F(x,y)\\lvert \\nabla \\phi \\rvert = 0\n$$\nThe function $\\phi(x,y,t)$ is the level set function, whose zero isocontour $\\phi=0$ represents the moving interface. The region where $\\phi \\le 0$ is defined as the \"interior\" of the closed interface. The function $F(x,y)$ is the speed of the interface in the direction of its outward normal.\n\nThe solution involves discretizing this PDE in space and time and evolving an initial condition.\n\n1.  **Domain and Grid Discretization**\n    The computational domain is a square $[-1,1] \\times [-1,1]$. We introduce a uniform Cartesian grid with $N \\times N$ nodes. The coordinates of the grid nodes $(x_i, y_j)$ are given by:\n    $$\n    x_i = -1 + i \\Delta x, \\quad i = 0, \\ldots, N-1\n    $$\n    $$\n    y_j = -1 + j \\Delta y, \\quad j = 0, \\ldots, N-1\n    $$\n    where the grid spacings are $\\Delta x = \\Delta y = \\frac{2}{N-1}$. The level set function is represented by its values $\\phi_{i,j}(t) \\approx \\phi(x_i, y_j, t)$ on this grid.\n\n2.  **Initial Condition and Reinitialization**\n    The initial interface is an ellipse defined by $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$. A simple choice for the initial level set function is $\\phi(x,y,0) = \\frac{x^2}{a^2} + \\frac{y^2}{b^2} - 1$.\n    For numerical stability and accuracy, the level set function should ideally be a signed distance function (SDF), meaning it satisfies $|\\nabla\\phi| = 1$. The initial function is not an SDF. Therefore, we must reinitialize it at $t=0$ and periodically thereafter.\n    Reinitialization is performed as follows:\n    - Create a binary mask distinguishing the interior ($\\phi \\le 0$) from the exterior ($\\phi  0$).\n    - Compute the Euclidean distance from every grid point to the nearest point of the opposite region. This is done using a fast Euclidean Distance Transform (EDT) algorithm.\n    - The new $\\phi$ is constructed by assigning negative distances to interior points and positive distances to exterior points. Specifically, $\\phi_{\\text{new}} = \\text{dist}_{\\text{out}} - \\text{dist}_{\\text{in}}$, where $\\text{dist}_{\\text{in}}$ is the distance to the exterior for points in the interior, and $\\text{dist}_{\\text{out}}$ is the distance to the interior for points in the exterior.\n\n3.  **Spatial Discretization: First-Order Godunov Scheme**\n    The PDE is a Hamilton-Jacobi equation of the form $\\phi_t + H(\\nabla \\phi) = 0$, with Hamiltonian $H(\\nabla \\phi) = F(x,y)|\\nabla \\phi|$. Such equations can develop shocks or corners in the solution, requiring a numerical scheme that correctly handles the direction of information propagation (upwinding). A Godunov-type scheme achieves this by using a numerical Hamiltonian that is monotone.\n    For the Hamiltonian $H(p,q) = F\\sqrt{p^2+q^2}$, where $p=\\phi_x$ and $q=\\phi_y$, the Godunov numerical Hamiltonian $H_{num}$ for a grid function $\\phi_{i,j}$ takes the form:\n    $$\n    H_{num} = F_{i,j}^+ \\sqrt{D_x^{\\text{upw},+}{}^2 + D_y^{\\text{upw},+}{}^2} + F_{i,j}^- \\sqrt{D_x^{\\text{upw},-}{}^2 + D_y^{\\text{upw},-}{}^2}\n    $$\n    where $F_{i,j}^+ = \\max(F_{i,j}, 0)$ and $F_{i,j}^- = \\min(F_{i,j}, 0)$. The terms $D$ represent squared norms of upwind gradients.\n    - If $F  0$ (expansion), information propagates from the interior ($\\phi0$) to the exterior ($\\phi0$). The scheme must look \"upwind\" into the interior.\n    - If $F  0$ (contraction), information propagates from the exterior to the interior. The scheme must look \"upwind\" into the exterior.\n\n    Let $\\phi_x^- = (\\phi_{i,j} - \\phi_{i-1,j})/\\Delta x$ be the backward difference and $\\phi_x^+ = (\\phi_{i+1,j} - \\phi_{i,j})/\\Delta x$ be the forward difference, and similarly for $y$. The Godunov scheme is expressed as:\n    $$\n    H_{num}(\\phi_{i,j}) = \\max(F_{i,j}, 0) \\sqrt{A} + \\min(F_{i,j}, 0) \\sqrt{B}\n    $$\n    with\n    $$\n    A = [\\max(\\phi_x^-, 0)]^2 + [\\min(\\phi_x^+, 0)]^2 + [\\max(\\phi_y^-, 0)]^2 + [\\min(\\phi_y^+, 0)]^2\n    $$\n    $$\n    B = [\\max(\\phi_x^+, 0)]^2 + [\\min(\\phi_x^-, 0)]^2 + [\\max(\\phi_y^+, 0)]^2 + [\\min(\\phi_y^-, 0)]^2\n    $$\n    This formulation correctly selects the difference directions based on the sign of the local derivatives and the sign of the speed field $F$.\n\n4.  **Time Discretization and Stability**\n    We use an explicit forward Euler scheme to update the solution in time:\n    $$\n    \\frac{\\phi_{i,j}^{n+1} - \\phi_{i,j}^n}{\\Delta t} + H_{num}(\\phi_{i,j}^n) = 0 \\implies \\phi_{i,j}^{n+1} = \\phi_{i,j}^n - \\Delta t \\cdot H_{num}(\\phi_{i,j}^n)\n    $$\n    This scheme is stable only if the time step $\\Delta t$ satisfies the Courant-Friedrichs-Lewy (CFL) condition. For this Hamilton-Jacobi equation, the characteristic speed is $\\max_{x,y}|F(x,y)|$. The CFL condition is:\n    $$\n    \\Delta t \\le \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n    The problem specifies using a CFL number, $0  \\mathrm{CFL} \\le 1$, such that:\n    $$\n    \\Delta t = \\mathrm{CFL} \\times \\frac{\\min(\\Delta x, \\Delta y)}{\\max\\limits_{x,y}\\lvert F(x,y)\\rvert}\n    $$\n\n5.  **Boundary Conditions**\n    Homogeneous Neumann boundary conditions, $\\frac{\\partial \\phi}{\\partial n} = 0$, are applied, where $n$ is the outward normal to the domain boundary. For a first-order scheme, this can be implemented by setting the value in a \"ghost cell\" outside the domain equal to the value at the boundary cell adjacent to it. This effectively makes the one-sided finite difference across the boundary equal to zero. Numerically, this is achieved by padding the $\\phi$ grid with the edge values before computing spatial derivatives.\n\n6.  **Topological Analysis**\n    After the final time step, the topology of the evolved interface is determined. This is done by analyzing the interior set $S = \\{(i,j) | \\phi_{i,j} \\le 0\\}$. We count the number of connected components in this set using a standard labeling algorithm with $4$-connectivity (considering only up, down, left, right neighbors as connected). The number of distinct labels assigned corresponds to the number of separate objects.\n\nThe implementation will follow these steps for each test case provided in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to run the Level Set Method simulations for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: (N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq)\n        (101, 0.7, 0.3, 1.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case B:\n        (101, 0.7, 0.3, 0.1, 0.25, 0.2, 0.5, 220, 5),\n        # Case C:\n        (101, 0.7, 0.3, 0.35, 0.25, 0.2, 0.5, 100, 5),\n        # Case D:\n        (101, 0.7, 0.3, 1.3, 0.20, 0.2, 0.5, 260, 5),\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(N, a, b, alpha, beta, s, CFL, num_steps, reinit_freq):\n    \"\"\"\n    Executes a single LSM simulation for a given set of parameters.\n    \"\"\"\n    # 1. Grid setup\n    domain_size = 2.0\n    dx = domain_size / (N - 1)\n    dy = dx  # Square grid\n    x = np.linspace(-1.0, 1.0, N)\n    y = np.linspace(-1.0, 1.0, N)\n    X, Y = np.meshgrid(x, y)\n\n    # 2. Initial condition: Ellipse\n    phi = (X**2 / a**2) + (Y**2 / b**2) - 1.0\n\n    # 3. Reinitialization to Signed Distance Function (SDF)\n    def reinitialize(p, grid_spacing):\n        mask_in = p = 0\n        dist_in = ndimage.distance_transform_edt(mask_in, sampling=[grid_spacing, grid_spacing])\n        dist_out = ndimage.distance_transform_edt(~mask_in, sampling=[grid_spacing, grid_spacing])\n        return dist_out - dist_in\n    \n    phi = reinitialize(phi, dx)\n    \n    # 4. Speed field F(x,y)\n    F = beta - alpha * np.exp(-(Y**2) / s**2)\n    max_F_abs = np.max(np.abs(F))\n\n    # 5. Time step from CFL condition\n    dt = CFL * dx / max_F_abs\n\n    # 6. Main evolution loop\n    for step in range(num_steps):\n        # Apply Neumann boundary conditions via padding\n        phi_padded = np.pad(phi, pad_width=1, mode='edge')\n\n        # Compute one-sided differences on the interior grid\n        # These correspond to derivatives on the original phi grid\n        phi_x_m = (phi_padded[1:-1, 1:-1] - phi_padded[1:-1, :-2]) / dx\n        phi_x_p = (phi_padded[1:-1, 2:]   - phi_padded[1:-1, 1:-1]) / dx\n        phi_y_m = (phi_padded[1:-1, 1:-1] - phi_padded[:-2, 1:-1]) / dy\n        phi_y_p = (phi_padded[2:,   1:-1] - phi_padded[1:-1, 1:-1]) / dy\n\n        # Godunov numerical Hamiltonian H\n        F_pos = np.maximum(F, 0)\n        F_neg = np.minimum(F, 0)\n        \n        # Gradient term for F  0 (upwind from interior)\n        grad_norm_sq_up = (np.maximum(phi_x_m, 0)**2 + \n                           np.minimum(phi_x_p, 0)**2 + \n                           np.maximum(phi_y_m, 0)**2 + \n                           np.minimum(phi_y_p, 0)**2)\n        \n        # Gradient term for F  0 (upwind from exterior)\n        grad_norm_sq_down = (np.maximum(phi_x_p, 0)**2 + \n                             np.minimum(phi_x_m, 0)**2 + \n                             np.maximum(phi_y_p, 0)**2 + \n                             np.minimum(phi_y_m, 0)**2)\n\n        H = F_pos * np.sqrt(grad_norm_sq_up) + F_neg * np.sqrt(grad_norm_sq_down)\n\n        # Forward Euler time update\n        phi -= dt * H\n\n        # Periodic reinitialization\n        if (step + 1) % reinit_freq == 0:\n            phi = reinitialize(phi, dx)\n\n    # 7. Topological query: count connected components\n    # The set {phi = 0} represents the interior\n    interior_mask = phi = 0\n    # ndimage.label default structure gives 4-connectivity for 2D\n    _, num_components = ndimage.label(interior_mask)\n    \n    return num_components\n\nsolve()\n```", "id": "2408442"}, {"introduction": "Our final practice [@problem_id:2408479] tackles one of the most significant applications of level set methods: modeling curvature-driven flow. Here, the interface velocity is not prescribed but is dictated by the interface's own geometry, specifically its mean curvature $\\kappa$. This type of evolution is fundamental to phenomena like surface tension in fluid dynamics and noise reduction in image processing. You will implement a numerical scheme to simulate the coalescence and extinction of droplets, gaining hands-on experience with a physically rich, second-order, non-linear evolution equation.", "problem": "You are asked to formulate, discretize, and implement a two-dimensional level set method to simulate the curvature-driven evolution of moving interfaces that represent fluid droplets under surface tension. The computational setting is purely mathematical and dimensionless. Your task is to derive the governing equation from core definitions, propose a stable numerical scheme, and implement a complete, runnable program that solves the problem for a given set of test cases. The goal is to demonstrate that a level set method naturally handles topological change, including coalescence after contact and extinction.\n\nStart from the following foundational base:\n- The interface at time $t$ is the zero contour of a level set function $ \\phi(\\mathbf{x}, t) $, with $ \\mathbf{x} = (x, y) $, and the interior (fluid) region is $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, t)  0 \\} $. The outward unit normal to the interface is $ \\mathbf{n} = \\nabla \\phi / \\lvert \\nabla \\phi \\rvert $.\n- The curvature (in two dimensions) is defined as $ \\kappa = \\nabla \\cdot \\mathbf{n} $.\n- Under surface tension-driven motion, the normal velocity is proportional to curvature with a minus sign, that is $ V_n = - \\sigma \\, \\kappa $, where $ \\sigma  0 $ is a constant capillary coefficient.\n\nTask 1. Derive, from these definitions, the evolution equation for the level set function $ \\phi(\\mathbf{x}, t) $ that follows from normal motion with velocity $ V_n $ along the normal $ \\mathbf{n} $. Express the equation in terms of $ \\phi $, $ \\kappa $, and spatial derivatives of $ \\phi $ only. Then express $ \\kappa $ explicitly in terms of $ \\phi $.\n\nTask 2. Design a stable and consistent explicit finite difference scheme to solve the derived evolution equation on a uniform Cartesian grid covering the unit square. Your design constraints:\n- Use a uniform grid with $ N \\times N $ points over $ [0,1] \\times [0,1] $ with $ N $ specified below in the test suite.\n- Use central differences to approximate spatial derivatives needed to compute curvature $ \\kappa $ as a divergence of the normalized gradient of $ \\phi $.\n- Use an upwind Godunov numerical Hamiltonian to approximate $ \\lvert \\nabla \\phi \\rvert $ in the advective term of the Hamilton–Jacobi equation $ \\phi_t + V_n \\lvert \\nabla \\phi \\rvert = 0 $.\n- Enforce a Courant–Friedrichs–Lewy (CFL) condition based on the parabolic scaling of curvature-driven motion. Choose a time step $ \\Delta t $ that satisfies a stability restriction of the form $ \\Delta t \\le C \\, \\min(\\Delta x, \\Delta y)^2 / \\sigma $, with a dimensionless constant $ C $ chosen for stability.\n- Impose homogeneous Neumann boundary conditions (zero normal derivative) for $ \\phi $ on all sides of the unit square.\n- Periodically reinitialize $ \\phi $ toward a signed distance function by integrating a suitable artificial-time Hamilton–Jacobi equation for a few pseudo-time steps, using an upwind discretization and a regularized sign function built from the current $ \\phi $. You must state the reinitialization equation you use and how you discretize it.\n\nTask 3. Initialization and test suite. Implement the following initial interfaces and run the simulation until the specified final times. All quantities are dimensionless. The capillary coefficient is $ \\sigma = 1 $. The grid resolution is $ N = 128 $, uniformly spaced over $ [0,1] \\times [0,1] $. For each case, construct $ \\phi(\\mathbf{x}, 0) $ as the signed distance to the union of the specified disks, with negative values inside the union. Each disk is defined by its center $ (x_c, y_c) $ and radius $ R $ via the Euclidean distance. For the union of two disks, set the initial level set as the pointwise minimum of the signed distances to each disk.\n- Case A (overlapping two-droplet coalescence after contact): two identical disks with centers $ (0.35, 0.50) $ and $ (0.65, 0.50) $ and radius $ R = 0.18 $, final time $ T = 0.006 $. These disks overlap initially, representing two droplets that have just contacted; surface tension should smooth the neck into a single connected droplet.\n- Case B (separated two droplets): two identical disks with centers $ (0.25, 0.50) $ and $ (0.75, 0.50) $ and radius $ R = 0.18 $, final time $ T = 0.006 $. The disks are initially disjoint; without external forcing, they should remain disjoint during curvature-driven evolution over this time horizon.\n- Case C (single small droplet extinction): one disk with center $ (0.50, 0.50) $ and radius $ R = 0.07 $, final time $ T = 0.003 $. Under curvature-driven flow, a sufficiently small circle should shrink to extinction by the final time.\n\nTask 4. Post-processing and measurable outputs. At the final time of each case, compute the number of connected components of the set $ \\{ \\mathbf{x} : \\phi(\\mathbf{x}, T)  0 \\} $ using $4$-connectivity on the grid. Your program must produce a single line of output containing the numbers of connected components for the three cases, in order A, B, C, as a comma-separated list enclosed in square brackets, for example $ [n_A, n_B, n_C] $. The output values must be integers.\n\nAngle units do not apply. All variables are dimensionless, so no physical unit conversion is required.\n\nYour program must be fully self-contained, deterministic, and must not require any user input. It must adhere to the execution environment specified later and produce exactly one line of output in the specified format. The design choices for discretization, time stepping, boundary conditions, and reinitialization must be consistent with your derivation in Task 1 and the constraints above, and they must be documented in code comments within your program.", "solution": "The problem posed is a well-defined computational physics task grounded in the established principles of the level set method and the physical model of curvature-driven interface motion. All parameters, conditions, and objectives are specified with sufficient clarity and rigor to permit a unique and verifiable solution. The problem is therefore deemed valid and I shall proceed with its resolution.\n\nThe solution is structured according to the four tasks outlined in the problem statement.\n\nTask 1: Derivation of the Governing Equation\n\nThe interface is defined as the zero level set of a function $ \\phi(\\mathbf{x}, t) $, where $ \\mathbf{x} \\in \\mathbb{R}^2 $.\nFor any point $ \\mathbf{x}(t) $ that remains on the interface, we have $ \\phi(\\mathbf{x}(t), t) = 0 $. Differentiating this with respect to time $ t $ using the material derivative gives:\n$$\n\\frac{d}{dt}\\phi(\\mathbf{x}(t), t) = \\frac{\\partial \\phi}{\\partial t} + \\nabla \\phi \\cdot \\frac{d\\mathbf{x}}{dt} = 0\n$$\nThe velocity of the point on the interface is $ \\mathbf{v} = d\\mathbf{x}/dt $. The problem states that the interface moves only in its normal direction with a specified normal velocity $ V_n $. The velocity vector is thus $ \\mathbf{v} = V_n \\mathbf{n} $. Substituting this into the previous equation yields:\n$$\n\\phi_t + \\nabla \\phi \\cdot (V_n \\mathbf{n}) = 0\n$$\nwhere $ \\phi_t $ is the partial derivative of $ \\phi $ with respect to $ t $. The outward unit normal vector $ \\mathbf{n} $ is defined as $ \\mathbf{n} = \\nabla \\phi / |\\nabla \\phi| $. Substituting this expression for $ \\mathbf{n} $ gives:\n$$\n\\phi_t + V_n \\nabla \\phi \\cdot \\frac{\\nabla \\phi}{|\\nabla \\phi|} = 0 \\implies \\phi_t + V_n \\frac{|\\nabla \\phi|^2}{|\\nabla \\phi|} = 0\n$$\nThis simplifies to the general level set equation for an interface moving with normal velocity $ V_n $:\n$$\n\\phi_t + V_n |\\nabla \\phi| = 0\n$$\nThe problem specifies curvature-driven motion, where the normal velocity is proportional to the local curvature $ \\kappa $, given by $ V_n = -\\sigma \\kappa $. Substituting this into the level set equation provides the evolution equation for $ \\phi $:\n$$\n\\phi_t - \\sigma \\kappa |\\nabla \\phi| = 0\n$$\nThis is the required evolution equation.\n\nNext, we express the curvature $ \\kappa $ in terms of the level set function $ \\phi $. The curvature is the divergence of the unit normal vector: $ \\kappa = \\nabla \\cdot \\mathbf{n} $.\n$$\n\\kappa = \\nabla \\cdot \\left( \\frac{\\nabla \\phi}{|\\nabla \\phi|} \\right) = \\nabla \\cdot \\left( \\frac{(\\phi_x, \\phi_y)}{\\sqrt{\\phi_x^2 + \\phi_y^2}} \\right)\n$$\nwhere subscripts denote partial differentiation. Applying the divergence operator yields the explicit expression for curvature in two dimensions:\n$$\n\\kappa = \\frac{\\partial}{\\partial x}\\left(\\frac{\\phi_x}{|\\nabla\\phi|}\\right) + \\frac{\\partial}{\\partial y}\\left(\\frac{\\phi_y}{|\\nabla\\phi|}\\right)\n$$\nExpanding this using the quotient rule for differentiation results in:\n$$\n\\kappa = \\frac{\\phi_{xx}\\phi_y^2 - 2\\phi_x\\phi_y\\phi_{xy} + \\phi_{yy}\\phi_x^2}{(\\phi_x^2 + \\phi_y^2)^{3/2}}\n$$\nThis completes the derivation.\n\nTask 2: Design of a Numerical Scheme\n\nWe discretize the domain $ [0,1] \\times [0,1] $ with a uniform Cartesian grid of $ N \\times N $ points, such that $ x_i = i h, y_j = j h $ for $ i, j = 0, \\dots, N-1 $, with grid spacing $ h = 1/(N-1) $. Let $ \\phi^n_{i,j} $ denote the numerical approximation of $ \\phi(x_i, y_j, n\\Delta t) $.\n\nThe evolution equation $ \\phi_t - \\sigma \\kappa |\\nabla \\phi| = 0 $ is advanced in time using an explicit forward Euler method. The equation is treated as a Hamilton-Jacobi equation $ \\phi_t + V_{ij} |\\nabla\\phi|_{ij} = 0 $, where the effective velocity is $ V_{ij} = -\\sigma\\kappa_{ij} $. As stipulated, we use a hybrid scheme:\n1.  **Curvature $ \\kappa $**: This term involves second derivatives and is computed using central differences for stability. Numerically, it is more robust to compute $ \\kappa $ as the divergence of the normal field rather than using the fully expanded formula with second derivatives directly.\n    First, we compute the components of the gradient $ \\nabla\\phi $ using second-order central differences:\n    $$\n    (\\phi_x)_{i,j} \\approx \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}, \\quad (\\phi_y)_{i,j} \\approx \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}\n    $$\n    The normal vector components $ (n_x, n_y) $ are then computed:\n    $$\n    (n_x)_{i,j} = \\frac{(\\phi_x)_{i,j}}{\\sqrt{(\\phi_x)^2_{i,j} + (\\phi_y)^2_{i,j} + \\epsilon^2}}, \\quad (n_y)_{i,j} = \\frac{(\\phi_y)_{i,j}}{\\sqrt{(\\phi_x)^2_{i,j} + (\\phi_y)^2_{i,j} + \\epsilon^2}}\n    $$\n    where $ \\epsilon $ is a small regularization parameter (e.g., $ \\epsilon=h $) to prevent division by zero. Finally, the curvature $ \\kappa $ is computed as the divergence of the normal field, again using central differences:\n    $$\n    \\kappa_{i,j} = \\frac{(n_x)_{i+1,j} - (n_x)_{i-1,j}}{2h} + \\frac{(n_y)_{i,j+1} - (n_y)_{i,j-1}}{2h}\n    $$\n2.  **Advective Term $ V_n |\\nabla \\phi| $**: The term $ |\\nabla \\phi| $ is discretized using a first-order upwind Godunov-type scheme. The update rule for $ \\phi $ is:\n    $$\n    \\frac{\\phi^{n+1}_{i,j} - \\phi^n_{i,j}}{\\Delta t} = - \\left( \\max(V^n_{i,j}, 0)\\nabla^+_{i,j} + \\min(V^n_{i,j}, 0)\\nabla^-_{i,j} \\right)\n    $$\n    where $ V^n_{i,j} = -\\sigma \\kappa^n_{i,j} $. The upwinded gradient magnitudes, $ \\nabla^+ $ and $ \\nabla^- $, are given by:\n    $$\n    \\nabla^+_{i,j} = \\sqrt{ \\max((D_x^-\\phi)^2, (D_x^+\\phi)^2) + \\max((D_y^-\\phi)^2, (D_y^+\\phi)^2) } (\\text{simplified version})\n    $$\n    A more standard Godunov scheme is:\n    $$\n    \\nabla^+_{i,j} = \\left[ \\max(D_x^-\\phi, 0)^2 + \\min(D_x^+\\phi, 0)^2 + \\max(D_y^-\\phi, 0)^2 + \\min(D_y^+\\phi, 0)^2 \\right]^{1/2}\n    $$\n    $$\n    \\nabla^-_{i,j} = \\left[ \\max(D_x^+\\phi, 0)^2 + \\min(D_x^-\\phi, 0)^2 + \\max(D_y^+\\phi, 0)^2 + \\min(D_y^-\\phi, 0)^2 \\right]^{1/2}\n    $$\n    where $ D_x^\\pm, D_y^\\pm $ are the standard forward and backward first-order finite differences. For example, $ D_x^+\\phi_{i,j} = (\\phi_{i+1,j} - \\phi_{i,j})/h $.\n3.  **Boundary Conditions**: Homogeneous Neumann conditions ($ \\partial\\phi/\\partial\\mathbf{n}_{\\text{bdy}} = 0 $) are enforced using ghost cells. For a central difference stencil at a boundary point (e.g., $ i=0 $), the ghost point value is set to enforce the condition. For $ (\\phi_x)_{0,j} = (\\phi_{1,j} - \\phi_{-1,j})/(2h) = 0 $, we set $ \\phi_{-1,j} = \\phi_{1,j} $.\n4.  **Time Step**: Motion by mean curvature is a stiff, parabolic-like problem. An explicit scheme requires a stringent time step constraint for stability, which scales with the square of the grid spacing:\n    $$\n    \\Delta t \\le C \\frac{h^2}{\\sigma}\n    $$\n    where $ h = \\min(\\Delta x, \\Delta y) $. A conservative stability constant $ C=0.2 $ is chosen.\n5.  **Reinitialization**: The level set function can become distorted over time. To maintain its signed distance property ($ |\\nabla\\phi|=1 $), it is periodically reinitialized. This is done by solving the following Hamilton-Jacobi equation to steady-state in a pseudo-time $ \\tau $:\n    $$\n    \\phi_{\\tau} + \\text{sgn}(\\phi_0) (|\\nabla \\phi| - 1) = 0\n    $$\n    where $ \\phi_0 $ is the level set function before reinitialization. The sign function is regularized as $ \\text{sgn}(\\phi_0) \\approx \\phi_0 / \\sqrt{\\phi_0^2 + h^2} $. This equation is solved for a few pseudo-time steps using a forward Euler method and the same upwind scheme for $ |\\nabla\\phi| $ as in the main evolution, with a pseudo-time step $ \\Delta \\tau $ satisfying its own CFL condition, $ \\Delta\\tau \\le h $.\n\nTask 3  4: Implementation, Test Cases, and Post-processing\n\nThe numerical scheme described above is implemented in Python using the `numpy` and `scipy` libraries. The initial conditions for each test case are constructed by defining $ \\phi(\\mathbf{x}, 0) $ as the signed distance to the specified geometric shapes. The simulation is run for the specified duration. At the final time $ T $, the set of points where $ \\phi(\\mathbf{x}, T)  0 $ is identified. The number of connected components within this set is determined using a labeling algorithm from `scipy.ndimage` with $ 4 $-connectivity.\n\n- Case A (Overlapping): The two initial disks overlap, forming a single connected region. Curvature-driven flow will smooth the \"neck\" between them, causing the shape to become more compact and elliptical. The number of connected components is expected to be $ 1 $ throughout.\n- Case B (Separated): The two disks are initially separate. Under curvature flow, both will shrink in place. As they are sufficiently far apart, they will not merge within the given time. The number of connected components is expected to remain $ 2 $.\n- Case C (Extinction): A single small circular droplet shrinks under curvature. The analytical solution for the radius of a circle evolving under mean curvature flow is $ R(t) = \\sqrt{R_0^2 - 2\\sigma t} $. For $ R_0=0.07 $ and $ \\sigma=1 $, the extinction time is $ t_{\\text{ext}} = R_0^2/(2\\sigma) = 0.07^2/2 = 0.00245 $. Since the final time $ T=0.003 $ is greater than $ t_{\\text{ext}} $, the droplet is expected to vanish completely. The number of connected components will be $ 0 $.\n\nThe expected output based on this analysis is the list `[1, 2, 0]`. The following implementation will verify this numerically.", "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label\n\ndef solve():\n    \"\"\"\n    Solves the curvature-driven flow problem using the level set method.\n    \"\"\"\n\n    # --- Simulation parameters ---\n    N = 128  # Grid resolution\n    SIGMA = 1.0  # Capillary coefficient\n    DOMAIN_SIZE = 1.0\n    CFL_C = 0.2  # CFL constant for main evolution\n    REINIT_FREQ = 25  # Reinitialization frequency (in time steps)\n    REINIT_STEPS = 5  # Number of pseudo-time steps for reinitialization\n\n    # --- Grid setup ---\n    h = DOMAIN_SIZE / (N - 1)\n    x = np.linspace(0, DOMAIN_SIZE, N)\n    y = np.linspace(0, DOMAIN_SIZE, N)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n    \n    # --- Time step calculation ---\n    # Parabolic scaling for curvature flow: dt ~ h^2\n    dt = CFL_C * h**2 / SIGMA\n\n    # --- Test cases as defined in the problem ---\n    test_cases = [\n        {\n            'name': 'A',\n            'T_final': 0.006,\n            'shapes': [\n                {'type': 'disk', 'center': (0.35, 0.50), 'radius': 0.18},\n                {'type': 'disk', 'center': (0.65, 0.50), 'radius': 0.18}\n            ]\n        },\n        {\n            'name': 'B',\n            'T_final': 0.006,\n            'shapes': [\n                {'type': 'disk', 'center': (0.25, 0.50), 'radius': 0.18},\n                {'type': 'disk', 'center': (0.75, 0.50), 'radius': 0.18}\n            ]\n        },\n        {\n            'name': 'C',\n            'T_final': 0.003,\n            'shapes': [\n                {'type': 'disk', 'center': (0.50, 0.50), 'radius': 0.07}\n            ]\n        }\n    ]\n\n    results = []\n\n    # --- Helper functions for numerical scheme ---\n\n    def apply_neumann(phi_grid):\n        \"\"\"Applies homogeneous Neumann boundary conditions using ghost cells.\"\"\"\n        # This implementation reflects values across the boundary, which is\n        # equivalent to setting the normal derivative to zero for a central\n        # difference scheme. phi[-1] = phi[1], phi[N] = phi[N-2]\n        padded = np.pad(phi_grid, 1, mode='symmetric')\n        return padded\n\n    def reinitialize(phi):\n        \"\"\"\n        Reinitializes the level set function phi to be a signed distance function.\n        Solves phi_tau + sgn(phi_0) * ( |grad(phi)| - 1 ) = 0.\n        \"\"\"\n        phi_0 = phi.copy()\n        # Regularized sign function\n        sign = phi_0 / np.sqrt(phi_0**2 + h**2)\n        \n        # CFL for reinitialization (hyperbolic)\n        dt_reinit = 0.5 * h\n        \n        phi_reinit = phi.copy()\n\n        for _ in range(REINIT_STEPS):\n            padded_phi = apply_neumann(phi_reinit)\n            \n            # First-order upwind/downwind stencils\n            dx_p = (padded_phi[2:, 1:-1] - padded_phi[1:-1, 1:-1]) / h\n            dx_m = (padded_phi[1:-1, 1:-1] - padded_phi[:-2, 1:-1]) / h\n            dy_p = (padded_phi[1:-1, 2:] - padded_phi[1:-1, 1:-1]) / h\n            dy_m = (padded_phi[1:-1, 1:-1] - padded_phi[1:-1, :-2]) / h\n\n            # Godunov scheme for gradient magnitude\n            grad_norm_p = np.sqrt(np.maximum(dx_m, 0)**2 + np.minimum(dx_p, 0)**2 +\n                                  np.maximum(dy_m, 0)**2 + np.minimum(dy_p, 0)**2)\n            grad_norm_m = np.sqrt(np.maximum(dx_p, 0)**2 + np.minimum(dx_m, 0)**2 +\n                                  np.maximum(dy_p, 0)**2 + np.minimum(dy_m, 0)**2)\n\n            # Update based on sign\n            update = - (np.maximum(sign, 0) * (grad_norm_p - 1) + \n                        np.minimum(sign, 0) * (grad_norm_m - 1))\n            \n            phi_reinit += dt_reinit * update\n\n        return phi_reinit\n\n    for case in test_cases:\n        # --- Initialization ---\n        phi_list = []\n        for shape in case['shapes']:\n            if shape['type'] == 'disk':\n                xc, yc = shape['center']\n                R = shape['radius']\n                phi_disk = np.sqrt((xx - xc)**2 + (yy - yc)**2) - R\n                phi_list.append(phi_disk)\n        \n        # For multiple shapes, the initial phi is the minimum of individual signed distances\n        phi = np.min(np.array(phi_list), axis=0) if len(phi_list)  1 else phi_list[0]\n        \n        # --- Time evolution loop ---\n        t = 0.0\n        step_count = 0\n        while t  case['T_final']:\n            # Reinitialize periodically\n            if step_count % REINIT_FREQ == 0:\n                phi = reinitialize(phi)\n\n            padded_phi = apply_neumann(phi)\n\n            # --- Calculate curvature k ---\n            # Central differences for gradient\n            phi_x = (padded_phi[2:, 1:-1] - padded_phi[:-2, 1:-1]) / (2 * h)\n            phi_y = (padded_phi[1:-1, 2:] - padded_phi[1:-1, :-2]) / (2 * h)\n            \n            # Regularized gradient magnitude\n            magn_grad = np.sqrt(phi_x**2 + phi_y**2 + h**2)\n\n            # Normal vector field\n            nx = phi_x / magn_grad\n            ny = phi_y / magn_grad\n            \n            padded_nx = apply_neumann(nx)\n            padded_ny = apply_neumann(ny)\n\n            # Divergence of the normal field (curvature)\n            nx_x = (padded_nx[2:, 1:-1] - padded_nx[:-2, 1:-1]) / (2 * h)\n            ny_y = (padded_ny[1:-1, 2:] - padded_ny[1:-1, :-2]) / (2 * h)\n            kappa = nx_x + ny_y\n\n            # --- Calculate upwind gradient norms for the advection term ---\n            # Using the main phi grid for this\n            dx_p = (padded_phi[2:, 1:-1] - padded_phi[1:-1, 1:-1]) / h\n            dx_m = (padded_phi[1:-1, 1:-1] - padded_phi[:-2, 1:-1]) / h\n            dy_p = (padded_phi[1:-1, 2:] - padded_phi[1:-1, 1:-1]) / h\n            dy_m = (padded_phi[1:-1, 1:-1] - padded_phi[1:-1, :-2]) / h\n\n            grad_norm_p = np.sqrt(np.maximum(dx_m, 0)**2 + np.minimum(dx_p, 0)**2 +\n                                  np.maximum(dy_m, 0)**2 + np.minimum(dy_p, 0)**2)\n            grad_norm_m = np.sqrt(np.maximum(dx_p, 0)**2 + np.minimum(dx_m, 0)**2 +\n                                  np.maximum(dy_p, 0)**2 + np.minimum(dy_m, 0)**2)\n\n            # --- Update phi ---\n            # Effective velocity for Hamilton-Jacobi formulation\n            V = -SIGMA * kappa\n            \n            # The problem is phi_t + V * |nabla phi| = 0\n            # Update is phi_new = phi_old - dt * (V * |nabla phi|)\n            update_term = - (np.maximum(V, 0) * grad_norm_p + np.minimum(V, 0) * grad_norm_m)\n\n            phi += dt * update_term\n\n            t += dt\n            step_count += 1\n            \n        # --- Post-processing: Count connected components ---\n        mask = phi  0\n        # 4-connectivity structure\n        structure = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]])\n        _, num_components = label(mask, structure=structure)\n        results.append(num_components)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2408479"}]}