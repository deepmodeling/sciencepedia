{"hands_on_practices": [{"introduction": "The power of the Particle-Mesh Ewald method lies in its elegant use of Fourier space to handle long-range interactions. This practice hones your understanding of these fundamentals by challenging you to re-derive the PME reciprocal-space kernel for a different physical system: two-dimensional electrostatics, where the potential is logarithmic. By working through this derivation [@problem_id:2424403], you will solidify your grasp of how the Poisson equation and the choice of screening function directly shape the final algorithm in reciprocal space.", "problem": "Consider $N$ point charges with charges $\\{q_{j}\\}_{j=1}^{N}$ at positions $\\{\\mathbf{r}_{j}\\}_{j=1}^{N}$ in a two-dimensional square domain of side length $L$ with periodic boundary conditions. Assume overall charge neutrality, $\\sum_{j=1}^{N} q_{j} = 0$. The fundamental interaction is logarithmic: the potential $\\phi(\\mathbf{r})$ satisfies the two-dimensional Poisson equation $\\Delta \\phi(\\mathbf{r}) = -2\\pi \\rho(\\mathbf{r})$, so that the pair potential between two unit charges is proportional to $-\\ln r$, where $r = |\\mathbf{r}|$. In the Particleâ€“Mesh Ewald (PME) method, one introduces a Gaussian screening charge density for each point charge with width (Ewald) parameter $\\alpha > 0$, given by\n$$\n\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\,\\exp\\!\\big(-\\alpha^{2} r^{2}\\big),\n$$\nand defines the long-range potential as the periodic solution of the screened Poisson equation with source $\\rho_{G} * \\rho$, where $*$ denotes convolution and $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} q_{j}\\,\\delta(\\mathbf{r}-\\mathbf{r}_{j})$ is the microscopic charge density.\n\nLet the two-dimensional discrete Fourier modes be $\\mathbf{k} = \\frac{2\\pi}{L}(m_{x}, m_{y})$ with $(m_{x}, m_{y}) \\in \\mathbb{Z}^{2}$, and define, for a periodic function $f(\\mathbf{r})$ on the domain, the Fourier coefficients\n$$\n\\hat{f}(\\mathbf{k}) = \\int_{[0,L)^{2}} f(\\mathbf{r})\\,\\exp\\!\\big(-i\\,\\mathbf{k}\\cdot\\mathbf{r}\\big)\\,d^{2}\\mathbf{r}\n\\quad\\text{and}\\quad\nf(\\mathbf{r}) = \\frac{1}{L^{2}} \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k})\\,\\exp\\!\\big(i\\,\\mathbf{k}\\cdot\\mathbf{r}\\big).\n$$\nDenote $k = |\\mathbf{k}|$. In reciprocal space, the PME long-range potential is written in terms of a kernel $\\hat{G}(\\mathbf{k})$ as $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$ for $\\mathbf{k} \\neq \\mathbf{0}$. Derive the exact closed-form analytic expression for $\\hat{G}(\\mathbf{k})$ in terms of $\\alpha$ and $k$ for $\\mathbf{k} \\neq \\mathbf{0}$. Your final answer must be a single expression in terms of $k$ and $\\alpha$. Do not include the $\\mathbf{k} = \\mathbf{0}$ mode. No numerical evaluation is required.", "solution": "The problem statement is subjected to validation.\n\nStep 1: Extracted Givens.\n- A system of $N$ point charges with charges $\\{q_{j}\\}_{j=1}^{N}$ at positions $\\{\\mathbf{r}_{j}\\}_{j=1}^{N}$.\n- The domain is a two-dimensional square of side length $L$ with periodic boundary conditions.\n- The system is charge neutral: $\\sum_{j=1}^{N} q_{j} = 0$.\n- The two-dimensional Poisson equation is given as $\\Delta \\phi(\\mathbf{r}) = -2\\pi \\rho(\\mathbf{r})$.\n- The microscopic charge density is $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} q_{j}\\,\\delta(\\mathbf{r}-\\mathbf{r}_{j})$.\n- A Gaussian screening charge density is defined as $\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\,\\exp(-\\alpha^{2} r^{2})$, with $r = |\\mathbf{r}|$.\n- The long-range potential source is the convolution $\\rho_{G} * \\rho$.\n- Discrete Fourier modes are $\\mathbf{k} = \\frac{2\\pi}{L}(m_{x}, m_{y})$ for $(m_{x}, m_{y}) \\in \\mathbb{Z}^{2}$.\n- Fourier transform conventions are provided: $\\hat{f}(\\mathbf{k}) = \\int_{[0,L)^{2}} f(\\mathbf{r})\\,\\exp(-i\\,\\mathbf{k}\\cdot\\mathbf{r})\\,d^{2}\\mathbf{r}$ and $f(\\mathbf{r}) = \\frac{1}{L^{2}} \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k})\\,\\exp(i\\,\\mathbf{k}\\cdot\\mathbf{r})$.\n- The relationship for the long-range potential in reciprocal space is given as $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$ for $\\mathbf{k} \\neq \\mathbf{0}$, where $k=|\\mathbf{k}|$.\n- The objective is to derive the expression for the kernel $\\hat{G}(\\mathbf{k})$.\n\nStep 2: Validation Using Extracted Givens.\nThe problem is scientifically grounded. It describes the mathematical formulation of the reciprocal-space part of the Particle-Mesh Ewald (PME) method for two-dimensional systems with logarithmic interactions, which is a standard and well-established technique in computational physics. The Poisson equation, charge densities, and Fourier transform conventions are all standard and internally consistent.\n\nThe problem is well-posed. It asks for the derivation of a specific mathematical quantity, the Fourier-space kernel $\\hat{G}(\\mathbf{k})$, based on a clear set of definitions and physical equations. The exclusion of the $\\mathbf{k}=\\mathbf{0}$ mode is a critical and correct specification that avoids the singularity in the Green's function of the Poisson operator and ensures a well-defined problem under the given charge neutrality condition.\n\nThe problem is objective and its terms are precise. It contains no subjective claims, ambiguities, or missing information that would prevent a rigorous derivation.\n\nStep 3: Verdict and Action.\nThe problem is deemed **valid**. We proceed with the derivation.\n\nThe long-range component of the potential, $\\phi^{\\mathrm{LR}}(\\mathbf{r})$, is defined as the solution to the screened Poisson equation. The source for this equation is the convolution of the microscopic charge density, $\\rho(\\mathbf{r})$, with the Gaussian screening density, $\\rho_{G}(\\mathbf{r})$. Let us denote this long-range source density as $\\rho^{\\mathrm{LR}}(\\mathbf{r}) = (\\rho * \\rho_{G})(\\mathbf{r})$. The governing equation is therefore:\n$$\n\\Delta \\phi^{\\mathrm{LR}}(\\mathbf{r}) = -2\\pi \\rho^{\\mathrm{LR}}(\\mathbf{r})\n$$\nTo solve this equation, we transform it into Fourier space. The Fourier transform of the Laplacian operator $\\Delta$ acting on a function is multiplication by $-k^{2}$ in reciprocal space, where $k = |\\mathbf{k}|$. Applying the Fourier transform to both sides of the equation yields:\n$$\n\\widehat{\\Delta \\phi^{\\mathrm{LR}}}(\\mathbf{k}) = -k^{2} \\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})\n$$\nThe right-hand side becomes:\n$$\n\\mathcal{F}\\{-2\\pi \\rho^{\\mathrm{LR}}(\\mathbf{r})\\} = -2\\pi \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\nThus, the Poisson equation in Fourier space is:\n$$\n-k^{2} \\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = -2\\pi \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\nFor $\\mathbf{k} \\neq \\mathbf{0}$, we can solve for $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})$:\n$$\n\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\nNext, we utilize the convolution theorem, which states that the Fourier transform of a convolution of two functions is the product of their individual Fourier transforms. The source $\\rho^{\\mathrm{LR}}$ is a convolution, so its Fourier transform is:\n$$\n\\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) \\hat{\\rho}_{G}(\\mathbf{k})\n$$\nHere, $\\hat{\\rho}(\\mathbf{k})$ is the Fourier transform of the microscopic charge density and $\\hat{\\rho}_{G}(\\mathbf{k})$ is the Fourier transform of the Gaussian screening density. Substituting this into the expression for $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})$ gives:\n$$\n\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}_{G}(\\mathbf{k}) \\hat{\\rho}(\\mathbf{k})\n$$\nThe problem statement defines the reciprocal-space potential via the kernel $\\hat{G}(\\mathbf{k})$ as $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$. By direct comparison, we identify the kernel as:\n$$\n\\hat{G}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}_{G}(\\mathbf{k})\n$$\nThe final step is to compute the Fourier transform of the screening density $\\rho_{G}(\\mathbf{r})$. Since $\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\exp(-\\alpha^{2} r^{2})$ is a rapidly decaying function, its Fourier transform is computed by integrating over all space $\\mathbb{R}^{2}$:\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\int_{\\mathbb{R}^{2}} \\frac{\\alpha^{2}}{\\pi}\\exp(-\\alpha^{2} r^{2}) \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}) d^{2}\\mathbf{r}\n$$\nWriting this in Cartesian coordinates, with $\\mathbf{r} = (x,y)$ and $\\mathbf{k} = (k_{x}, k_{y})$, the integral separates:\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\left( \\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} x^{2} - i k_{x} x) dx \\right) \\left( \\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} y^{2} - i k_{y} y) dy \\right)\n$$\nThis is a standard Gaussian integral of the form $\\int_{-\\infty}^{\\infty} \\exp(-ax^{2} - bx) dx = \\sqrt{\\frac{\\pi}{a}}\\exp(\\frac{b^{2}}{4a})$. For the $x$-integral, we have $a=\\alpha^{2}$ and $b=ik_{x}$. The result is:\n$$\n\\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} x^{2} - i k_{x} x) dx = \\sqrt{\\frac{\\pi}{\\alpha^{2}}} \\exp\\left(\\frac{(ik_{x})^{2}}{4\\alpha^{2}}\\right) = \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{x}^{2}}{4\\alpha^{2}}\\right)\n$$\nThe integral over $y$ is identical in form. Combining the results for the $x$ and $y$ integrals:\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\left( \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{x}^{2}}{4\\alpha^{2}}\\right) \\right) \\left( \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{y}^{2}}{4\\alpha^{2}}\\right) \\right)\n$$\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\frac{\\pi}{\\alpha^{2}} \\exp\\left(-\\frac{k_{x}^{2} + k_{y}^{2}}{4\\alpha^{2}}\\right) = \\exp\\left(-\\frac{k^{2}}{4\\alpha^{2}}\\right)\n$$\nThis is the well-known result that the Fourier transform of a normalized Gaussian is another Gaussian.\n\nFinally, we substitute this back into our expression for the kernel $\\hat{G}(\\mathbf{k})$:\n$$\n\\hat{G}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\exp\\left(-\\frac{k^{2}}{4\\alpha^{2}}\\right)\n$$\nThis is the required closed-form expression for the reciprocal-space PME kernel for $\\mathbf{k} \\neq \\mathbf{0}$.", "answer": "$$\n\\boxed{\\frac{2\\pi}{k^2} \\exp\\left(-\\frac{k^2}{4\\alpha^2}\\right)}\n$$", "id": "2424403"}, {"introduction": "Grid-based methods, central to PME, are not limited to solving for electrostatic potentials; they are a versatile tool for analyzing simulation data. This exercise [@problem_id:2424437] guides you in applying the particle-to-mesh assignment technique to compute local continuum properties, namely the mass density and the configurational stress-tensor field. This practice is invaluable for learning how to bridge the gap between discrete particle data and continuous field descriptions, a common task in advanced simulation analysis.", "problem": "You are asked to derive and implement a particle-to-mesh algorithm, in the spirit of the Particleâ€“Mesh Ewald (PME) method, to compute local fields from particle data in a periodic cubic domain. The objective is to compute the mass density field and the configurational stress-tensor field on a uniform mesh by depositing particle and pairwise quantities using the same compact-support assignment functions commonly used in Particleâ€“Mesh Ewald (PME). The approach must be derived from fundamental definitions of microscopic fields and then discretized onto a mesh using a first-order B-spline assignment (also known as cloud-in-cell). All quantities are in reduced, dimensionless units.\n\nFundamental base:\n- The microscopic mass density is defined by the distribution $ \\rho(\\mathbf{r}) = \\sum_{i=1}^{N} m_i \\, \\delta(\\mathbf{r} - \\mathbf{r}_i) $, where $ m_i $ and $ \\mathbf{r}_i $ are the mass and position of particle $ i $, and $ \\delta(\\cdot) $ is the Dirac delta function.\n- The Irvingâ€“Kirkwood (IK) configurational stress tensor field for static configurations (zero velocities) is defined by $ \\boldsymbol{\\sigma}(\\mathbf{r}) = - \\dfrac{1}{2} \\sum_{i \\neq j} \\int_{0}^{1} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} \\, \\delta\\!\\left(\\mathbf{r} - \\mathbf{r}_i + s \\, \\mathbf{r}_{ij}\\right) \\, ds $, where $ \\mathbf{r}_{ij} $ is the minimum-image separation vector from particle $ i $ to $ j $, $ \\mathbf{F}_{ij} $ is the force on $ i $ due to $ j $, and $ \\otimes $ denotes the outer product.\n\nTask 1 (derivation): Starting from the above definitions, replace the Dirac delta $ \\delta(\\cdot) $ by a separable, compact-support assignment function $ W(\\mathbf{r}) = w(x) \\, w(y) \\, w(z) $ that is the first-order cardinal B-spline (cloud-in-cell) used in Particleâ€“Mesh Ewald (PME). Explicitly derive the discrete mesh formulas for:\n- The grid mass density values $ \\rho_{i,j,k} $ at mesh nodes indexed by integers $ (i,j,k) $ on a uniform grid in a periodic cube of side length $ L $ with $ N \\times N \\times N $ nodes and spacing $ h = L/N $. Your discrete formula must satisfy exact mass conservation in the sense that $ \\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 = \\sum_{\\ell=1}^{N_p} m_\\ell $, where $ N_p $ is the number of particles.\n- The grid configurational stress-tensor values $ \\boldsymbol{\\sigma}_{i,j,k} $ using the midpoint approximation to the Irvingâ€“Kirkwood line integral, i.e., deposit each pair contribution at the midpoint along the minimum-image segment between the two particles. Show that the volume integral $ \\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} \\, h^3 $ equals the global virial tensor $ \\mathbf{W} = - \\dfrac{1}{2} \\sum_{i \\neq j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} $ when the same assignment function $ W $ is used for deposition.\n\nTask 2 (algorithm design): Using your derived discrete formulas,\n- Implement periodic boundary conditions on a cube of side length $ L $ with minimum-image separation $ \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i - L \\, \\mathrm{round}\\!\\left((\\mathbf{r}_j - \\mathbf{r}_i)/L\\right) $, applied component-wise.\n- Use a Lennardâ€“Jones pair force truncated at cutoff $ r_c $, with potential $ U(r) = 4 \\, \\varepsilon \\left[ \\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6 \\right] $ and force $ \\mathbf{F}(r) = - \\dfrac{dU}{dr} \\, \\hat{\\mathbf{r}} $, and evaluate forces only for pairs with $ r < r_c $. Do not apply tail corrections or shifting; use the straightforward truncation. Assume zero velocities so that the kinetic part of the stress is identically zero.\n\nTask 3 (implementation and outputs): Write a complete, runnable program that:\n- Builds the mesh and deposits mass density and configurational stress-tensor using the first-order B-spline assignment (cloud-in-cell).\n- For each test case below, computes three scalar diagnostics:\n  1) The total mass on the mesh, $ M_{\\mathrm{grid}} = \\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 $.\n  2) The maximum grid density value $ \\max_{i,j,k} \\rho_{i,j,k} $.\n  3) The Frobenius norm of the difference between the volume-integrated mesh stress and the analytic global virial tensor, $ \\left\\| \\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} \\, h^3 - \\mathbf{W} \\right\\|_F $.\n\nAll quantities are dimensionless. Angles are not used. No percentages are used.\n\nTest suite:\n- Case A (general multi-particle): $ L = 1.0 $, $ N = 8 $, $ \\varepsilon = 1.0 $, $ \\sigma = 0.2 $, $ r_c = 0.5 $. Particles: masses $ [1.0, 2.0, 1.5] $, positions $ \\{ [0.2, 0.3, 0.4], [0.8, 0.1, 0.9], [0.5, 0.5, 0.5] \\} $.\n- Case B (boundary wrap single particle): same $ L, N, \\varepsilon, \\sigma, r_c $. Particles: masses $ [1.0] $, positions $ \\{ [0.99, 0.01, 0.49] \\} $.\n- Case C (minimum-image close pair): same $ L, N, \\varepsilon, \\sigma, r_c $. Particles: masses $ [1.0, 1.0] $, positions $ \\{ [0.95, 0.5, 0.5], [0.05, 0.5, 0.5] \\} $.\n- Case D (empty system): same $ L, N, \\varepsilon, \\sigma, r_c $. Particles: masses $ [\\,] $, positions $ \\{ \\, \\} $.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the order\n  $ [ M_{\\mathrm{grid}}^{(A)}, \\max \\rho^{(A)}, \\Delta \\sigma^{(A)}, M_{\\mathrm{grid}}^{(B)}, \\max \\rho^{(B)}, \\Delta \\sigma^{(B)}, M_{\\mathrm{grid}}^{(C)}, \\max \\rho^{(C)}, \\Delta \\sigma^{(C)}, M_{\\mathrm{grid}}^{(D)}, \\max \\rho^{(D)}, \\Delta \\sigma^{(D)} ] $,\n  where $ \\Delta \\sigma $ denotes the Frobenius norm of the stress discrepancy defined above. For example, the format must look like $ [r_1,r_2,\\dots,r_{12}] $ with $ 12 $ floating-point numbers.", "solution": "The problem presented is a well-defined task in computational physics, requiring the derivation and implementation of a particle-to-mesh algorithm for calculating mass density and configurational stress fields. It is scientifically grounded in the principles of statistical mechanics and standard numerical methods (Particle-Mesh). The problem is self-contained, providing all necessary definitions, parameters, and test data. Therefore, the problem is deemed valid and a full solution is warranted.\n\nThe derivation and implementation will proceed in two stages as requested: first, the derivation of the discrete formulas from the provided continuous definitions, and second, the development of a numerical algorithm to compute the required diagnostic quantities.\n\n### Task 1: Derivation of Discrete Mesh Formulas\n\nWe are given a periodic cubic domain of side length $L$ with a uniform grid of $N \\times N \\times N$ nodes, resulting in a grid spacing of $h = L/N$.\n\n#### 1.1. Mass Density Field\n\nThe microscopic mass density is defined as:\n$$\n\\rho(\\mathbf{r}) = \\sum_{p=1}^{N_p} m_p \\, \\delta(\\mathbf{r} - \\mathbf{r}_p)\n$$\nwhere $m_p$ and $\\mathbf{r}_p$ are the mass and position of particle $p$, and $\\delta(\\cdot)$ is the Dirac delta function.\n\nTo discretize this, we replace the Dirac delta with a continuous, compact-support assignment function $W(\\mathbf{r})$. The resulting smoothed density field $\\rho_{\\text{smooth}}(\\mathbf{r})$ is:\n$$\n\\rho_{\\text{smooth}}(\\mathbf{r}) = \\sum_{p=1}^{N_p} m_p \\, W(\\mathbf{r} - \\mathbf{r}_p)\n$$\nThe problem specifies the first-order cardinal B-spline (Cloud-in-Cell or CIC) assignment function. This function is separable, $W(\\mathbf{r}) = w(x)w(y)w(z)$. For a grid spacing $h$, the one-dimensional kernel is a triangular (or \"hat\") function:\n$$\nw(u) = \\frac{1}{h} \\max\\left(0, 1 - \\frac{|u|}{h}\\right)\n$$\nThe factor of $1/h$ ensures that $\\int_{-\\infty}^{\\infty} w(u) \\, du = 1$, making $\\int_{\\mathbb{R}^3} W(\\mathbf{r}) \\, d^3\\mathbf{r} = 1$.\n\nThe standard procedure in Particle-Mesh methods, which guarantees mass conservation, defines the grid-based density $\\rho_{i,j,k}$ not by sampling $\\rho_{\\text{smooth}}(\\mathbf{r})$ but by assigning mass to the grid. Let $M_{i,j,k}$ be the total mass assigned to the grid node $\\mathbf{r}_{i,j,k} = (ih, jh, kh)$. The density at this node is defined as:\n$$\n\\rho_{i,j,k} = \\frac{M_{i,j,k}}{h^3}\n$$\nThe mass $M_{i,j,k}$ is computed by distributing the mass of each particle $m_p$ to its neighboring grid nodes according to a dimensionless weighting function derived from the B-spline. Let a particle be at position $\\mathbf{r}_p$. Its scaled position is $\\mathbf{s}_p = \\mathbf{r}_p/h$. Let $\\mathbf{n}_p = (\\lfloor s_p^x \\rfloor, \\lfloor s_p^y \\rfloor, \\lfloor s_p^z \\rfloor)$ be the integer index of the grid node nearest to the particle in the negative direction (the \"base\" node). The particle's fractional position within this base cell is $\\mathbf{u}_p = \\mathbf{s}_p - \\mathbf{n}_p$.\n\nThe CIC scheme distributes the particle's mass $m_p$ to the $2^3=8$ grid nodes forming the cell that contains the particle. The weight for a node at an offset $(\\delta_x, \\delta_y, \\delta_z)$ from $\\mathbf{n}_p$ (where $\\delta_x, \\delta_y, \\delta_z \\in \\{0, 1\\}$) is:\n$$\nS(\\mathbf{u}_p, \\boldsymbol{\\delta}) = \\big( (1-u_p^x)^{1-\\delta_x}(u_p^x)^{\\delta_x} \\big) \\big( (1-u_p^y)^{1-\\delta_y}(u_p^y)^{\\delta_y} \\big) \\big( (1-u_p^z)^{1-\\delta_z}(u_p^z)^{\\delta_z} \\big)\n$$\nThe mass assigned from particle $p$ to grid node $\\mathbf{k} = \\mathbf{n}_p + \\boldsymbol{\\delta}$ is $m_p S(\\mathbf{u}_p, \\boldsymbol{\\delta})$. The total mass at node $\\mathbf{k}$ is the sum over all particles:\n$$\nM_{\\mathbf{k}} = \\sum_{p=1}^{N_p} m_p S(\\mathbf{u}_p, \\boldsymbol{\\delta}_{\\mathbf{k},p})\n$$\nwhere $\\boldsymbol{\\delta}_{\\mathbf{k},p}$ is the relative index of node $\\mathbf{k}$ from particle $p$'s base node.\n\n**Mass Conservation Proof:** We must show that $\\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 = \\sum_{p=1}^{N_p} m_p$.\nSubstituting the definition of $\\rho_{i,j,k}$:\n$$\n\\sum_{i,j,k} \\rho_{i,j,k} h^3 = \\sum_{i,j,k} \\left( \\frac{M_{i,j,k}}{h^3} \\right) h^3 = \\sum_{i,j,k} M_{i,j,k}\n$$\nThis is the total mass assigned to all grid nodes. By swapping the order of summation:\n$$\n\\sum_{i,j,k} M_{i,j,k} = \\sum_{i,j,k} \\sum_{p=1}^{N_p} (\\text{mass from } p \\to i,j,k) = \\sum_{p=1}^{N_p} m_p \\left( \\sum_{i,j,k} \\text{weights for } p \\right)\n$$\nFor any particle $p$, the sum of its assignment weights over all grid nodes is $\\sum_{\\delta_x,\\delta_y,\\delta_z \\in \\{0,1\\}} S(\\mathbf{u}_p, \\boldsymbol{\\delta}) = 1$. This is because $\\sum_{\\delta_x=0}^1 (1-u_p^x)^{1-\\delta_x}(u_p^x)^{\\delta_x} = (1-u_p^x)+u_p^x = 1$, and this holds for each dimension. Therefore, the sum of weights is $1 \\times 1 \\times 1 = 1$.\nThus, we prove the conservation law:\n$$\n\\sum_{i,j,k} \\rho_{i,j,k} h^3 = \\sum_{p=1}^{N_p} m_p (1) = \\sum_{p=1}^{N_p} m_p\n$$\n\n#### 1.2. Configurational Stress-Tensor Field\n\nThe Irving-Kirkwood configurational stress tensor for static configurations is:\n$$\n\\boldsymbol{\\sigma}(\\mathbf{r}) = - \\frac{1}{2} \\sum_{i \\neq j} \\int_{0}^{1} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} \\, \\delta(\\mathbf{r} - \\mathbf{r}_i - s \\mathbf{r}_{ij}) \\, ds\n$$\nwhere $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ is the minimum-image separation vector and $\\mathbf{F}_{ij}$ is the force on particle $i$ due to particle $j$. The symbol $\\otimes$ denotes the outer product.\n\nWe replace $\\delta(\\cdot)$ with the assignment function $W(\\cdot)$ and use the midpoint approximation for the integral. The integral $\\int_0^1 f(s) ds$ is approximated as $f(1/2)$. This sets $s=1/2$. The location of deposition for the pair $(i,j)$ becomes $\\mathbf{r}_i + \\frac{1}{2}\\mathbf{r}_{ij} = \\frac{\\mathbf{r}_i+\\mathbf{r}_j}{2}$, which is the midpoint of the segment connecting the particles.\nThe smoothed stress field is approximated as:\n$$\n\\boldsymbol{\\sigma}_{\\text{smooth}}(\\mathbf{r}) \\approx - \\frac{1}{2} \\sum_{i \\neq j} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) W(\\mathbf{r} - (\\mathbf{r}_i+\\mathbf{r}_j)/2)\n$$\nThe sum over $i \\neq j$ counts each pair interaction twice. Consider the contribution from the interaction between particles $i$ and $j$. The terms are for $(i,j)$ and $(j,i)$. The quantity deposited for this single interaction is:\n$$\n\\mathbf{T}_{ij} = -\\frac{1}{2} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) - \\frac{1}{2} (\\mathbf{r}_{ji} \\otimes \\mathbf{F}_{ji})\n$$\nUsing Newton's third law, $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$, and the vector identity $\\mathbf{r}_{ji} = -\\mathbf{r}_{ij}$, the second term becomes $-\\frac{1}{2} ((-\\mathbf{r}_{ij}) \\otimes (-\\mathbf{F}_{ij})) = -\\frac{1}{2} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij})$. Therefore:\n$$\n\\mathbf{T}_{ij} = -(\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) = \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ji}\n$$\nThis tensor quantity, representing the full contribution from the pair interaction, is deposited at the single location $\\mathbf{r}_{mid} = (\\mathbf{r}_i+\\mathbf{r}_j)/2$.\n\nAnalogous to the mass density, we define the gridded stress tensor $\\boldsymbol{\\sigma}_{i,j,k}$ as the total deposited stress-dyadic at node $(i,j,k)$, which we denote $\\boldsymbol{\\Sigma}_{i,j,k}$, divided by the cell volume $h^3$:\n$$\n\\boldsymbol{\\sigma}_{i,j,k} = \\frac{\\boldsymbol{\\Sigma}_{i,j,k}}{h^3}\n$$\nHere, $\\boldsymbol{\\Sigma}_{i,j,k}$ is computed by summing the contributions from all unique pairs $(i<j)$. For each pair, the quantity $\\mathbf{T}_{ij} = \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ji}$ is distributed to the $8$ grid cells surrounding its midpoint $\\mathbf{r}_{mid}$ using the same CIC weighting scheme as for mass.\n\n**Virial Equivalence Proof:** We must show that $\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3$ equals the global virial tensor $\\mathbf{W} = - \\frac{1}{2} \\sum_{i \\neq j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}$.\nThe volume-integrated mesh stress is:\n$$\n\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3 = \\sum_{i,j,k} \\left( \\frac{\\boldsymbol{\\Sigma}_{i,j,k}}{h^3} \\right) h^3 = \\sum_{i,j,k} \\boldsymbol{\\Sigma}_{i,j,k}\n$$\nThis is the sum of all deposited dyadics over the entire grid. By changing the summation order from nodes to pairs:\n$$\n\\sum_{i,j,k} \\boldsymbol{\\Sigma}_{i,j,k} = \\sum_{p<q} \\left( \\sum_{i,j,k} \\text{dyadic from pair } (p,q) \\to i,j,k \\right)\n$$\nThe term in the parenthesis for a single pair $(p,q)$ is $\\mathbf{T}_{pq}$ multiplied by the sum of its assignment weights over all grid nodes. As established for mass, this sum is exactly $1$.\n$$\n\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3 = \\sum_{p<q} \\mathbf{T}_{pq} (1) = \\sum_{p<q} \\mathbf{r}_{pq} \\otimes \\mathbf{F}_{qp}\n$$\nNow we analyze the analytic global virial $\\mathbf{W}$:\n$$\n\\mathbf{W} = - \\frac{1}{2} \\sum_{i \\neq j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} = - \\frac{1}{2} \\sum_{i<j} \\left( (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) + (\\mathbf{r}_{ji} \\otimes \\mathbf{F}_{ji}) \\right)\n$$\nUsing $\\mathbf{r}_{ji}=-\\mathbf{r}_{ij}$ and $\\mathbf{F}_{ji}=-\\mathbf{F}_{ij}$, the term for $(j,i)$ is $\\mathbf{r}_{ji} \\otimes \\mathbf{F}_{ji} = (-\\mathbf{r}_{ij}) \\otimes (-\\mathbf{F}_{ij}) = \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}$. So the expression in the parenthesis is $2(\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij})$.\n$$\n\\mathbf{W} = - \\frac{1}{2} \\sum_{i<j} 2 (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) = - \\sum_{i<j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} = \\sum_{i<j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ji}\n$$\nThis is precisely the result obtained from summing the gridded stress. Therefore, the discrete formulation exactly conserves the global virial:\n$$\n\\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} h^3 = \\mathbf{W}\n$$\nThe numerical implementation should show a difference equal to zero, up to floating-point precision.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the particle-to-mesh problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general multi-particle)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0, 2.0, 1.5]),\n            \"positions\": np.array([[0.2, 0.3, 0.4], [0.8, 0.1, 0.9], [0.5, 0.5, 0.5]])\n        },\n        # Case B (boundary wrap single particle)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0]),\n            \"positions\": np.array([[0.99, 0.01, 0.49]])\n        },\n        # Case C (minimum-image close pair)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0, 1.0]),\n            \"positions\": np.array([[0.95, 0.5, 0.5], [0.05, 0.5, 0.5]])\n        },\n        # Case D (empty system)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([]),\n            \"positions\": np.array([])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        N_grid = case[\"N_grid\"]\n        epsilon = case[\"epsilon\"]\n        sigma = case[\"sigma\"]\n        r_c = case[\"r_c\"]\n        masses = case[\"masses\"]\n        positions = case[\"positions\"]\n        \n        num_particles = len(masses)\n        h = L / N_grid\n        h_inv = 1.0 / h\n\n        # Initialize grids for deposited mass (M_k) and stress (Sigma_k)\n        mass_grid = np.zeros((N_grid, N_grid, N_grid))\n        stress_grid = np.zeros((N_grid, N_grid, N_grid, 3, 3))\n        \n        # --- Mass Deposition ---\n        if num_particles > 0:\n            for p_idx in range(num_particles):\n                m_p = masses[p_idx]\n                r_p = positions[p_idx]\n                \n                s_p = r_p * h_inv\n                base_idx = np.floor(s_p).astype(int)\n                frac_coord = s_p - base_idx\n                \n                # Cloud-in-Cell (CIC) weights\n                w = np.zeros((2, 3))\n                w[0, :] = 1.0 - frac_coord\n                w[1, :] = frac_coord\n\n                for di in range(2):\n                    for dj in range(2):\n                        for dk in range(2):\n                            weight = w[di, 0] * w[dj, 1] * w[dk, 2]\n                            grid_idx = (base_idx + np.array([di, dj, dk])) % N_grid\n                            mass_grid[grid_idx[0], grid_idx[1], grid_idx[2]] += m_p * weight\n        \n        # --- Stress Deposition and Analytic Virial ---\n        analytic_virial = np.zeros((3, 3))\n\n        if num_particles > 1:\n            for i in range(num_particles):\n                for j in range(i + 1, num_particles):\n                    # Minimum image convention\n                    r_ij_raw = positions[j] - positions[i]\n                    r_ij = r_ij_raw - L * np.round(r_ij_raw / L)\n                    r_sq = np.dot(r_ij, r_ij)\n                    \n                    if 0  r_sq  r_c**2:\n                        r = np.sqrt(r_sq)\n                        \n                        # Lennard-Jones force calculation\n                        # F_ji = force on particle j due to i\n                        s_over_r_2 = (sigma / r)**2\n                        s_over_r_6 = s_over_r_2**3\n                        s_over_r_12 = s_over_r_6**2\n                        \n                        force_magnitude = 24.0 * epsilon / r * (2.0 * s_over_r_12 - s_over_r_6)\n                        F_ji = (force_magnitude / r) * r_ij\n                        \n                        # Contribution to analytic virial: r_ij (x) F_ji\n                        virial_pair = np.outer(r_ij, F_ji)\n                        analytic_virial += virial_pair\n                        \n                        # Deposition onto grid at midpoint\n                        r_mid = positions[i] + 0.5 * r_ij\n                        # Ensure midpoint is within [0, L)\n                        r_mid = r_mid - L * np.floor(r_mid / L)\n\n                        s_mid = r_mid * h_inv\n                        base_idx = np.floor(s_mid).astype(int)\n                        frac_coord = s_mid - base_idx\n                        \n                        w = np.zeros((2, 3))\n                        w[0, :] = 1.0 - frac_coord\n                        w[1, :] = frac_coord\n\n                        for di in range(2):\n                            for dj in range(2):\n                                for dk in range(2):\n                                    weight = w[di, 0] * w[dj, 1] * w[dk, 2]\n                                    grid_idx = (base_idx + np.array([di, dj, dk])) % N_grid\n                                    stress_grid[grid_idx[0], grid_idx[1], grid_idx[2]] += virial_pair * weight\n\n        # --- Calculate Diagnostics ---\n        \n        # 1. Total mass on the mesh\n        # M_grid = sum(rho_ijk * h^3) = sum( (M_ijk/h^3) * h^3 ) = sum(M_ijk)\n        total_mass_grid = np.sum(mass_grid)\n        \n        # 2. Maximum grid density value\n        # rho_ijk = M_ijk / h^3\n        if num_particles > 0:\n            rho_grid_density = mass_grid / (h**3)\n            max_rho = np.max(rho_grid_density)\n        else:\n            max_rho = 0.0\n\n        # 3. Frobenius norm of stress difference\n        # W_grid = sum(sigma_ijk * h^3) = sum( (Sigma_ijk/h^3) * h^3 ) = sum(Sigma_ijk)\n        grid_virial = np.sum(stress_grid, axis=(0, 1, 2))\n        stress_diff = grid_virial - analytic_virial\n        stress_norm = np.linalg.norm(stress_diff, 'fro')\n        \n        results.extend([total_mass_grid, max_rho, stress_norm])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "2424437"}, {"introduction": "While standard PME is designed for fully periodic systems, many real-world problems involve mixed or non-periodic boundary conditions, such as systems at interfaces or in confinement. This advanced practice [@problem_id:2424449] addresses this challenge by having you implement a PME-like solver for charges confined between two conducting plates. You will learn to replace the standard 3D FFT solver with a more general mixed spectral method, combining Fourier and Sine Transforms to correctly enforce the physical boundary conditions.", "problem": "You are asked to implement, from first principles, a simplified Particleâ€“Mesh Ewald (PME) long-range electrostatics calculation for point charges confined between two parallel grounded conducting plates. The plates are parallel to the $xy$ plane and located at $z=0$ and $z=L_z$, imposing Dirichlet boundary conditions $\\,\\phi(x,y,0)=\\phi(x,y,L_z)=0\\,$ on the electrostatic potential. The system is periodic in the $x$ and $y$ directions with box lengths $L_x$ and $L_y$. Your goal is to compute the electric forces on the particles due solely to the mesh-based long-range field, using a discrete Poisson solver that respects these boundary conditions.\n\nFundamental base:\n- Start from Gaussâ€™s law in differential form and the electrostatic constitutive relation in vacuum: $\\nabla\\cdot \\mathbf{E} = \\rho/\\varepsilon_0$ and $\\mathbf{E}=-\\nabla\\phi$, which combine to Poissonâ€™s equation $\\nabla^2 \\phi = -\\rho/\\varepsilon_0$.\n- Use a regular Cartesian mesh with spacings $\\Delta x=L_x/N_x$, $\\Delta y=L_y/N_y$, and $\\Delta z=L_z/(N_z-1)$, where $N_x$, $N_y$ are the number of grid points in $x$ and $y$ (periodic), and $N_z$ is the number of grid points in $z$ including the two boundary planes at $z=0$ and $z=L_z$ (Dirichlet). The interior set of planes is indexed by $k=1,\\dots,N_z-2$.\n- Use Cloud-in-Cell (CIC) for charge assignment to the mesh and for field interpolation back to particle positions, both consistent with the mesh.\n- Solve the discrete Poisson equation with a mixed spectral method: discrete Fourier transform (periodic) in $x$ and $y$ and discrete sine transform (Dirichlet) in $z$. For the $x$ and $y$ directions, the discrete Laplacian eigenvalues are $\\lambda_x(p) = \\left(2\\cos\\left(2\\pi p/N_x\\right)-2\\right)/\\Delta x^2$ for $p=0,\\dots,N_x-1$ and $\\lambda_y(q) = \\left(2\\cos\\left(2\\pi q/N_y\\right)-2\\right)/\\Delta y^2$ for $q=0,\\dots,N_y-1$. For the $z$ direction with Dirichlet boundary conditions, using the discrete sine basis on interior nodes, the eigenvalues are $\\lambda_z(m) = \\left(2\\cos\\left(\\pi m/(N_z-1)\\right)-2\\right)/\\Delta z^2$ for $m=1,\\dots,N_z-2$. The total eigenvalue is $\\lambda(p,q,m)=\\lambda_x(p)+\\lambda_y(q)+\\lambda_z(m)$.\n- In spectral space, solve $\\lambda\\,\\Phi = -\\widehat{\\rho}/\\varepsilon_0$ for $\\Phi$, where $\\widehat{\\rho}$ is the transformed charge density on the interior $z$ planes and $\\Phi$ is the transformed potential on those interior planes. Then invert the transforms to obtain $\\phi$ on the whole mesh with $\\phi=0$ on the boundary planes by construction.\n- Compute the electric field components by finite differences, using periodic differences in $x$ and $y$ and central differences in the $z$ interior; on the $z$ boundaries, use one-sided second-order differences to approximate $\\partial\\phi/\\partial z$ consistently with the Dirichlet boundary condition.\n\nNumerical and physical specifications:\n- Use the vacuum permittivity $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$.\n- All particle charges must be in Coulombs, positions in meters, and the force output in Newtons.\n- You will compute only the mesh-based long-range forces from solving the Poisson equation on the mesh with the stated boundary conditions. Do not include any explicit short-range or self-interaction corrections; the purpose is to test the correct incorporation of the conducting plates via the boundary conditions in the mesh solve.\n\nAlgorithmic requirements:\n- Implement CIC assignment of each point charge $q_\\ell$ at position $\\mathbf{r}_\\ell$ to its eight nearest mesh nodes. In $x$ and $y$, use periodic wrap. In $z$, restrict deposition to interior planes $k=1,\\dots,N_z-2$ by clamping the interpolation index so that no charge is deposited on the boundary nodes $k=0$ or $k=N_z-1$; normalize the weights so they sum to $1$ in $z$ despite the clamping near the plates.\n- Solve the discrete Poisson equation on the mesh via the mixed spectral method described above using the eigenvalues given. Use the discrete sine transform of type $I$ with orthonormal normalization on the $z$ interior.\n- Compute the electric field $\\mathbf{E}=-\\nabla\\phi$ on all mesh nodes, using:\n  - $E_x(i,j,k) = -\\left(\\phi(i+1,j,k)-\\phi(i-1,j,k)\\right)/(2\\Delta x)$ with periodic wrap in $i$,\n  - $E_y(i,j,k) = -\\left(\\phi(i,j+1,k)-\\phi(i,j-1,k)\\right)/(2\\Delta y)$ with periodic wrap in $j$,\n  - $E_z(i,j,0) = -\\left(-3\\phi(i,j,0)+4\\phi(i,j,1)-\\phi(i,j,2)\\right)/(2\\Delta z)$,\n  - $E_z(i,j,N_z-1) = -\\left(3\\phi(i,j,N_z-1)-4\\phi(i,j,N_z-2)+\\phi(i,j,N_z-3)\\right)/(2\\Delta z)$,\n  - $E_z(i,j,k) = -\\left(\\phi(i,j,k+1)-\\phi(i,j,k-1)\\right)/(2\\Delta z)$ for $k=1,\\dots,N_z-2$.\n- Interpolate $\\mathbf{E}$ from the mesh to each particle position using the same CIC weights and the same clamping strategy in $z$, then compute the force $\\mathbf{F}_\\ell = q_\\ell \\mathbf{E}(\\mathbf{r}_\\ell)$.\n\nTest suite:\nUse the following common mesh and box parameters for all test cases:\n- $N_x=N_y=16$, $N_z=32$.\n- $L_x=L_y=4.0\\times 10^{-9}\\,\\mathrm{m}$, $L_z=4.0\\times 10^{-9}\\,\\mathrm{m}$.\n\nLet $e=1.602176634\\times 10^{-19}\\,\\mathrm{C}$. Define four test cases:\n\n- Case $1$ (symmetry check): One particle with $q=+e$ at $\\left(L_x/2,\\,L_y/2,\\,L_z/2\\right)$.\n- Case $2$ (near-plate attraction): One particle with $q=+e$ at $\\left(0.7L_x,\\,0.3L_y,\\,0.5\\times 10^{-9}\\,\\mathrm{m}\\right)$.\n- Case $3$ (dipole across mid-plane): Two particles, $q_1=+e$ at $\\left(L_x/2-0.3\\times 10^{-9}\\,\\mathrm{m},\\,L_y/2,\\,L_z/2+0.4\\times 10^{-9}\\,\\mathrm{m}\\right)$ and $q_2=-e$ at $\\left(L_x/2+0.3\\times 10^{-9}\\,\\mathrm{m},\\,L_y/2,\\,L_z/2-0.4\\times 10^{-9}\\,\\mathrm{m}\\right)$.\n- Case $4$ (two like charges near opposite plates): Two particles, $q_1=+e$ at $\\left(L_x/3,\\,L_y/3,\\,0.6\\times 10^{-9}\\,\\mathrm{m}\\right)$ and $q_2=+e$ at $\\left(2L_x/3,\\,2L_y/3,\\,L_z-0.6\\times 10^{-9}\\,\\mathrm{m}\\right)$.\n\nFinal output specification:\n- Your program must compute, for each case in order, the force components $(F_x,F_y,F_z)$ in Newtons on each particle in the order they are listed for that case.\n- Aggregate the results across all cases into a single flat list of floating-point numbers in the order\n  $\\left[F_{x,1}^{(1)},F_{y,1}^{(1)},F_{z,1}^{(1)},F_{x,1}^{(2)},F_{y,1}^{(2)},F_{z,1}^{(2)},\\dots\\right]$, where the superscript indicates the case and the subscript the particle index within that case.\n- Express each number in Newtons, rounded to $6$ significant figures.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\").", "solution": "The user requires an implementation of a simplified Particle-Mesh Ewald (PME) method for calculating long-range electrostatic forces on point charges between two grounded conducting plates. The problem is to be solved from first principles, following a detailed set of algorithmic and physical specifications.\n\n### Problem Validation\n\nFirst, the problem statement is subjected to rigorous validation.\n\n**1. Extraction of Givens:**\n- **Physics**: Poisson's equation $\\nabla^2 \\phi = -\\rho/\\varepsilon_0$ with mixed boundary conditions: periodic in $x$ and $y$, and Dirichlet ($\\phi=0$) at $z=0$ and $z=L_z$.\n- **Discretization**: A regular Cartesian mesh of size $N_x \\times N_y \\times N_z$ on a box of size $L_x \\times L_y \\times L_z$. Grid spacings are $\\Delta x=L_x/N_x$, $\\Delta y=L_y/N_y$, $\\Delta z=L_z/(N_z-1)$.\n- **Numerical Method**:\n    - Cloud-in-Cell (CIC) for charge assignment and field interpolation, with a specific \"clamping\" and \"normalization\" rule for the $z$-direction near the boundaries.\n    - A mixed spectral solver: 2D Discrete Fourier Transform (DFT) for $xy$-planes and a Discrete Sine Transform (DST) for the $z$-direction on interior grid points ($k=1, \\dots, N_z-2$).\n    - Specific formulas for the discrete Laplacian eigenvalues ($\\lambda_x, \\lambda_y, \\lambda_z$) in the transform space are provided.\n    - The electric field $\\mathbf{E} = -\\nabla\\phi$ is calculated using specified finite difference stencils (central for interior, second-order one-sided for boundaries).\n- **Parameters**: Values for $\\varepsilon_0$, $e$, box dimensions ($L_x, L_y, L_z$), and mesh dimensions ($N_x, N_y, N_z$) are given.\n- **Test Cases**: Four specific configurations of point charges are defined.\n- **Output**: A single flat list of all force components for all particles, formatted to $6$ significant figures.\n\n**2. Validation Assessment:**\n- **Scientifically Grounded:** The problem is firmly rooted in classical electrostatics and established numerical methods for solving partial differential equations in computational physics. The proposed method is a valid, albeit simplified, variant of PME tailored for slab geometry.\n- **Well-Posed:** The problem is well-posed. The use of a mixed spectral method to solve the Poisson equation with the given boundary conditions leads to a unique solution for the potential. The specified eigenvalues of the discrete Laplacian, $\\lambda(p,q,m) = \\lambda_x(p) + \\lambda_y(q) + \\lambda_z(m)$, are always non-zero. Specifically, $\\lambda_x(p) \\le 0$, $\\lambda_y(q) \\le 0$, and $\\lambda_z(m)  0$ for the given index ranges, ensuring their sum is always strictly negative. This guarantees that the division in spectral space is always defined.\n- **Objective and Complete:** The problem is stated in precise, objective language. All necessary parameters, equations, and algorithmic steps are provided. A slight ambiguity in the \"clamping\" procedure for CIC is resolved by interpreting it as a mapping of out-of-bounds grid indices to the nearest valid interior indices ($1$ or $N_z-2$), a procedure that is specified to be used consistently for both charge assignment and field interpolation, thus preserving algorithmic self-consistency.\n- **No other flaws detected:** The problem is not scientifically unsound, non-formalizable, contradictory, unrealistic, or unverifiable.\n\n**3. Verdict:**\nThe problem is **valid**. A complete solution can be constructed following the specified procedure.\n\n### Solution Derivation\n\nThe solution follows the outlined algorithm. The core steps are: (1) charge assignment to the mesh, (2) solving the Poisson equation on the mesh, (3) calculating the electric field from the potential, and (4) interpolating the field back to the particle positions to find the force.\n\n**1. Grid and Parameters Setup**\nWe define the simulation box and mesh parameters. Box dimensions are $L_x, L_y, L_z$ and mesh dimensions are $N_x, N_y, N_z$. The grid spacings are $\\Delta x = L_x/N_x$, $\\Delta y = L_y/N_y$, and $\\Delta z = L_z/(N_z-1)$. The physical constants $\\varepsilon_0$ and $e$ are used as specified.\n\n**2. Charge Assignment (CIC)**\nFor each particle with charge $q_\\ell$ at position $\\mathbf{r}_\\ell = (x_\\ell, y_\\ell, z_\\ell)$, we map its charge onto the grid.\nFirst, we compute the particle's fractional coordinates and base grid indices:\n- $u_x = x_\\ell / \\Delta x$, $i_{base} = \\lfloor u_x \\rfloor \\pmod{N_x}$, $d_x = u_x - \\lfloor u_x \\rfloor$\n- $u_y = y_\\ell / \\Delta y$, $j_{base} = \\lfloor u_y \\rfloor \\pmod{N_y}$, $d_y = u_y - \\lfloor u_y \\rfloor$\n- $u_z = z_\\ell / \\Delta z$, $k_{base} = \\lfloor u_z \\rfloor$, $d_z = u_z - k_{base}$\n\nThe charge $q_\\ell$ is distributed to the $8$ nearest grid points. The weight for a grid point $(i_{base}+di, j_{base}+dj, k_{base}+dk)$ where $di, dj, dk \\in \\{0, 1\\}$ is $w_x(di)w_y(dj)w_z(dk)$, where $w_x(0) = 1-d_x$, $w_x(1)=d_x$, and so on for $y,z$.\nThe charge is deposited onto an interior grid $\\rho$ of size $N_x \\times N_y \\times (N_z-2)$, corresponding to physical planes $k=1, \\dots, N_z-2$. As per the problem's \"clamping\" instruction, any deposition targeted for a $z$-index $k$ outside the range $[1, N_z-2]$ is redirected to the nearest valid index. This is implemented by clamping the target indices: $k_{target} = \\text{clip}(k, 1, N_z-2)$. Finally, the charge grid is divided by the cell volume $V_{cell} = \\Delta x \\Delta y \\Delta z$ to obtain charge density.\n\n**3. Solving the Poisson Equation in Spectral Space**\nThe discrete Poisson equation is solved using a mixed spectral approach.\nThe charge density grid $\\rho(i, j, k')$ (where $k' = k-1$ is the index on the interior grid, $k' \\in [0, N_z-3]$) is transformed as follows:\n- A 2D Fast Fourier Transform (FFT) is applied along the $x$ and $y$ axes.\n- A special Discrete Sine Transform (DST) is applied along the $z$ axis. The problem implies a DST based on the eigenfunctions $\\sin(\\frac{\\pi m k}{N_z-1})$ for interior points $k=1, \\dots, N_z-2$. This is a specific type of DST, which we implement via matrix multiplication with the orthonormal transform matrix $S_{mk} = \\sqrt{\\frac{2}{N_z-1}} \\sin(\\frac{\\pi m k}{N_z-1})$.\n\nThe transformed density $\\widehat{\\rho}(p,q,m)$ now resides in the spectral domain. We construct a grid of the Laplacian eigenvalues $\\lambda(p,q,m) = \\lambda_x(p) + \\lambda_y(q) + \\lambda_z(m)$ using the provided formulae:\n$$ \\lambda_x(p) = \\frac{2\\cos(2\\pi p/N_x) - 2}{\\Delta x^2}, \\quad p \\in [0, N_x-1] $$\n$$ \\lambda_y(q) = \\frac{2\\cos(2\\pi q/N_y) - 2}{\\Delta y^2}, \\quad q \\in [0, N_y-1] $$\n$$ \\lambda_z(m) = \\frac{2\\cos(\\pi m/(N_z-1)) - 2}{\\Delta z^2}, \\quad m \\in [1, N_z-2] $$\nThe transformed potential $\\Phi$ is then found by algebraic division:\n$$ \\Phi(p,q,m) = -\\frac{\\widehat{\\rho}(p,q,m)}{\\varepsilon_0 \\lambda(p,q,m)} $$\nThis division is well-defined since $\\lambda(p,q,m)  0$.\nThe real-space potential on the interior grid, $\\phi(i,j,k')$, is recovered by applying the inverse transforms: an inverse DST (which is the same as the forward DST since the matrix $S$ is symmetric and orthogonal), followed by a 2D inverse FFT. The full potential grid $\\phi$ of size $N_x \\times N_y \\times N_z$ is formed by padding the interior solution with zeros for the boundary planes $k=0$ and $k=N_z-1$, satisfying the Dirichlet condition.\n\n**4. Electric Field Calculation**\nThe electric field $\\mathbf{E} = -\\nabla\\phi$ is computed on the full grid using finite differences as specified:\n- $E_x, E_y$: Central differences with periodic boundary conditions. For instance, $E_x(i,j,k) = -(\\phi_{i+1,j,k} - \\phi_{i-1,j,k})/(2\\Delta x)$.\n- $E_z$: Central difference for interior points $k \\in [1, N_z-2]$, and second-order one-sided stencils at the boundaries $k=0$ and $k=N_z-1$, which account for the $\\phi=0$ boundary condition.\n$$ E_z(i,j,0) = -\\frac{4\\phi_{i,j,1} - \\phi_{i,j,2}}{2\\Delta z} $$\n$$ E_z(i,j,N_z-1) = -\\frac{-4\\phi_{i,j,N_z-2} + \\phi_{i,j,N_z-3}}{2\\Delta z} $$\n\n**5. Force Interpolation**\nThe electric field $\\mathbf{E}$ is interpolated from the grid back to each particle's position $\\mathbf{r}_\\ell$ using the same CIC weights and $z$-clamping logic as in the charge assignment step. This ensures consistency and conserves momentum. The force on the particle is then $\\mathbf{F}_\\ell = q_\\ell \\mathbf{E}(\\mathbf{r}_\\ell)$.\n\n**Case 1: Sanity Check**\nFor a single charge at the exact center of the box, $(L_x/2, L_y/2, L_z/2)$, the force must be zero due to symmetry. Both the periodic images in $x, y$ and the image charges induced by the conducting plates in $z$ will exert forces that cancel out perfectly at this central point. The implementation must reproduce this $\\mathbf{F}=(0,0,0)$ result, serving as a critical validation of the code's correctness.", "answer": "```python\nimport numpy as np\n\ndef format_to_sig_figs(value, sig_figs):\n    \"\"\"Formats a number to a specified number of significant figures.\"\"\"\n    if value == 0:\n        return '0.0'\n    \n    # Use 'g' format specifier which is designed for significant figures\n    # and handles scientific notation appropriately.\n    return f\"{value:.{sig_figs}g}\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the PME problem for the given test cases.\n    \"\"\"\n    # Physical and numerical constants\n    EPS0 = 8.854187817e-12  # F/m\n    E_CHARGE = 1.602176634e-19  # C\n\n    # Common mesh and box parameters\n    NX, NY, NZ = 16, 16, 32\n    LX, LY, LZ = 4.0e-9, 4.0e-9, 4.0e-9\n\n    test_cases_defs = [\n        # Case 1: Symmetry check\n        {\"charges\": [E_CHARGE], \"positions\": np.array([[LX / 2, LY / 2, LZ / 2]])},\n        # Case 2: Near-plate attraction\n        {\"charges\": [E_CHARGE], \"positions\": np.array([[0.7 * LX, 0.3 * LY, 0.5e-9]])},\n        # Case 3: Dipole across mid-plane\n        {\n            \"charges\": [E_CHARGE, -E_CHARGE],\n            \"positions\": np.array([\n                [LX / 2 - 0.3e-9, LY / 2, LZ / 2 + 0.4e-9],\n                [LX / 2 + 0.3e-9, LY / 2, LZ / 2 - 0.4e-9]\n            ]),\n        },\n        # Case 4: Two like charges near opposite plates\n        {\n            \"charges\": [E_CHARGE, E_CHARGE],\n            \"positions\": np.array([\n                [LX / 3, LY / 3, 0.6e-9],\n                [2 * LX / 3, 2 * LY / 3, LZ - 0.6e-9]\n            ]),\n        },\n    ]\n\n    all_forces = []\n\n    for case_def in test_cases_defs:\n        forces = compute_pme_forces(\n            case_def[\"charges\"],\n            case_def[\"positions\"],\n            (LX, LY, LZ),\n            (NX, NY, NZ),\n            EPS0,\n        )\n        all_forces.extend(forces.flatten())\n\n    # Format results to 6 significant figures\n    formatted_results = [format_to_sig_figs(f, 6) for f in all_forces]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_pme_forces(charges, positions, L, N, eps0):\n    \"\"\"\n    Computes mesh-based electrostatic forces using the specified PME algorithm.\n    \"\"\"\n    LX, LY, LZ = L\n    NX, NY, NZ = N\n    \n    dx = LX / NX\n    dy = LY / NY\n    dz = LZ / (NZ - 1)\n    \n    # 1. Charge Assignment (CIC)\n    rho = np.zeros((NX, NY, NZ - 2))\n    \n    # Store weights for force interpolation\n    particle_weights = []\n\n    for idx, (q, pos) in enumerate(zip(charges, positions)):\n        weights_info = {}\n        # Fractional coordinates and base indices\n        ux, uy, uz = pos[0] / dx, pos[1] / dy, pos[2] / dz\n        \n        ix_base, iy_base, iz_base = int(np.floor(ux)), int(np.floor(uy)), int(np.floor(uz))\n        dx_frac, dy_frac, dz_frac = ux - ix_base, uy - iy_base, uz - iz_base\n        \n        weights_info['bases'] = (ix_base, iy_base, iz_base)\n        weights_info['fracs'] = (dx_frac, dy_frac, dz_frac)\n        \n        # Distribute charge to 8 nearest grid points\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    i = (ix_base + di) % NX\n                    j = (iy_base + dj) % NY\n                    k_physical = iz_base + dk\n                    \n                    # Clamp z-index to interior planes [1, NZ-2]\n                    k_clamped = np.clip(k_physical, 1, NZ - 2)\n                    k_rho = k_clamped - 1 # Index for rho array\n\n                    wx = (1 - dx_frac) if di == 0 else dx_frac\n                    wy = (1 - dy_frac) if dj == 0 else dy_frac\n                    wz = (1 - dz_frac) if dk == 0 else dz_frac\n                    \n                    rho[i, j, k_rho] += q * wx * wy * wz\n\n        particle_weights.append(weights_info)\n\n    rho /= (dx * dy * dz)  # Convert to charge density\n\n    # 2. Solve Poisson Equation\n    # 2a. Fourier transform in x, y\n    rho_hat_xy = np.fft.fft2(rho, axes=(0, 1))\n\n    # 2b. Custom Discrete Sine Transform in z\n    N_interior = NZ - 2\n    S = np.zeros((N_interior, N_interior))\n    m_vals = np.arange(1, N_interior + 1)\n    k_vals = np.arange(1, N_interior + 1)\n    arg = np.pi * m_vals[:, None] * k_vals[None, :] / (NZ - 1)\n    S = np.sqrt(2.0 / (NZ - 1)) * np.sin(arg)\n\n    # Einstein summation for applying DST matrix to all (i,j) slices\n    rho_hat = np.einsum('ijk,lk->ijl', rho_hat_xy, S, optimize=True)\n\n    # 2c. Solve in spectral space\n    p = np.fft.fftfreq(NX) * NX\n    q = np.fft.fftfreq(NY) * NY\n    m = np.arange(1, NZ - 1)\n\n    lambda_x = (2 * np.cos(2 * np.pi * p / NX) - 2) / dx**2\n    lambda_y = (2 * np.cos(2 * np.pi * q / NY) - 2) / dy**2\n    lambda_z = (2 * np.cos(np.pi * m / (NZ - 1)) - 2) / dz**2\n\n    lambda_total = (lambda_x[:, None, None] + lambda_y[None, :, None] + lambda_z[None, None, :])\n    \n    # Avoid division by zero (although lambda_total is never zero here)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        phi_hat = -rho_hat / (eps0 * lambda_total)\n    \n    # 2d. Inverse transforms\n    # Inverse DST (S is its own inverse)\n    phi_xy = np.einsum('ijk,lk->ijl', phi_hat, S, optimize=True)\n    \n    # Inverse FFT\n    phi_interior = np.fft.ifft2(phi_xy, axes=(0, 1)).real\n    \n    phi = np.zeros((NX, NY, NZ))\n    phi[:, :, 1:-1] = phi_interior\n\n    # 3. Calculate Electric Field\n    Ex = - (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * dx)\n    Ey = - (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dy)\n    \n    Ez = np.zeros_like(phi)\n    # Interior\n    Ez[:, :, 1:-1] = - (phi[:, :, 2:] - phi[:, :, :-2]) / (2 * dz)\n    # Boundaries (phi is 0 on boundaries)\n    Ez[:, :, 0] = - (4 * phi[:, :, 1] - phi[:, :, 2]) / (2 * dz)\n    Ez[:, :, -1] = - (-4 * phi[:, :, -2] + phi[:, :, -3]) / (2 * dz)\n\n    # 4. Interpolate Field and Calculate Force\n    forces = np.zeros((len(charges), 3))\n    for idx, (q, weights_info) in enumerate(zip(charges, particle_weights)):\n        # Retrieve weights and indices for this particle\n        ix_base, iy_base, iz_base = weights_info['bases']\n        dx_frac, dy_frac, dz_frac = weights_info['fracs']\n        \n        E_particle = np.zeros(3)\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    i = (ix_base + di) % NX\n                    j = (iy_base + dj) % NY\n                    k_physical = iz_base + dk\n                    \n                    # Use the same clamping on the FULL field grid\n                    k_clamped = np.clip(k_physical, 0, NZ-1)\n                    # Note: Original problem described clamping to interior [1, NZ-2]\n                    # This could be interpreted for interpolation as well. Let's be consistent\n                    # with the charge assignment clamping that operated on k in [1, NZ-2].\n                    # Let's re-read: \"interpolate E from the mesh... using the same CIC weights and\n                    # the same clamping strategy in z.\" The field E is defined on the full grid,\n                    # so clamping indices can be done on the full grid. Let's use the same clamping\n                    # logic as for charge deposition for full consistency.\n                    k_interp_idx = np.clip(k_physical, 1, NZ-2)\n\n                    wx = (1 - dx_frac) if di == 0 else dx_frac\n                    wy = (1 - dy_frac) if dj == 0 else dy_frac\n                    wz = (1 - dz_frac) if dk == 0 else dz_frac\n                    \n                    weight = wx * wy * wz\n                    E_particle[0] += Ex[i, j, k_interp_idx] * weight\n                    E_particle[1] += Ey[i, j, k_interp_idx] * weight\n                    E_particle[2] += Ez[i, j, k_interp_idx] * weight\n        \n        forces[idx, :] = q * E_particle\n        \n    return forces\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2424449"}]}