{"hands_on_practices": [{"introduction": "Chaotic systems are defined by their sensitive dependence on initial conditions, making long-term prediction of a single trajectory impossible. However, we can shift our perspective from individual paths to their collective, statistical behavior. This exercise [@problem_id:2403543] explores the concept of an invariant density, which describes the probability of finding the system in a particular state over a long period, revealing a hidden order within the chaos.", "problem": "Consider the one-dimensional logistic map defined by the recurrence $x_{n+1} = r\\,x_n(1 - x_n)$ with $r = 4$ and an initial condition $x_0 \\in (0,1)$. For $r = 4$, this discrete-time dynamical system is known to exhibit chaotic behavior on the unit interval. The invariant density $p(x)$ of values visited by the iterates is given by $p(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$ for $x \\in (0,1)$ and $p(x) = 0$ otherwise. For a given positive integer $B$, define a uniform partition of $[0,1]$ into $B$ bins with edges $0 = e_0 < e_1 < \\dots < e_B = 1$, where $e_k = \\frac{k}{B}$, and interpret the bins as half-open intervals $[e_k, e_{k+1})$ for $k = 0,1,\\dots,B-2$ and the last bin as $[e_{B-1}, e_B]$. For a specified nonnegative integer burn-in $M$ and a positive integer sample size $N$, produce the sequence of iterates $\\{x_{M+1}, x_{M+2}, \\dots, x_{M+N}\\}$ and form the empirical bin-probability vector $\\mathbf{p}^{\\text{emp}} \\in \\mathbb{R}^B$ whose $k$-th component is the fraction of these $N$ values that fall into bin $k$. Let the theoretical bin-probability vector $\\mathbf{p}^{\\text{th}} \\in \\mathbb{R}^B$ be defined by\n$$\np^{\\text{th}}_k = \\int_{e_k}^{e_{k+1}} p(x)\\,dx \\quad \\text{for } k = 0,1,\\dots,B-1,\n$$\nwhere $p(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}$ and the angle unit for any inverse trigonometric function used to evaluate the integral must be in radians. Use only the mathematical definitions above. For each test case below, compute the scalar quantity\n$$\nE = \\sum_{k=0}^{B-1} \\left| p^{\\text{emp}}_k - p^{\\text{th}}_k \\right|,\n$$\nwhich is the $\\ell^1$ distance between the empirical and theoretical bin-probability vectors.\n\nYour program must compute $E$ for each of the following test cases. In each tuple, the parameters are given as $(N, M, B, x_0)$ with $r=4$ fixed:\n\n- Test 1: $(N=\\;200000,\\; M=\\;5000,\\; B=\\;400,\\; x_0=\\;0.123456789)$.\n- Test 2: $(N=\\;100000,\\; M=\\;1000,\\; B=\\;200,\\; x_0=\\;10^{-12})$.\n- Test 3: $(N=\\;\\;\\;5000,\\; M=\\;\\;500,\\; B=\\;\\;50,\\; x_0=\\;0.37)$.\n- Test 4: $(N=\\;100000,\\; M=\\;1000,\\; B=\\;200,\\; x_0=\\;0.999999123)$.\n\nAll iterates and calculations are dimensionless. Express angles in radians where applicable. The required final output is a single line containing the four values of $E$ corresponding to the tests above, each rounded to six decimal places, as a comma-separated list enclosed in square brackets, for example, $[e_1,e_2,e_3,e_4]$ where each $e_i$ is a decimal number with six digits after the decimal point. Your program must produce exactly this single-line format as its only output.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded, well-posed, and objective. It presents a standard computational exercise in the study of chaotic dynamical systems, specifically the ergodic properties of the logistic map. All definitions, parameters, and conditions required for a unique solution are provided without ambiguity or contradiction. We shall proceed directly to the solution.\n\nThe problem requires the computation of the $\\ell^1$ distance, denoted by $E$, between an empirically generated probability distribution and its theoretical counterpart for the logistic map. The logistic map is given by the recurrence relation:\n$$\nx_{n+1} = r x_n (1 - x_n)\n$$\nwith the parameter $r$ fixed at $r=4$. For each test case defined by a tuple $(N, M, B, x_0)$, where $N$ is the sample size, $M$ is the burn-in count, $B$ is the number of bins, and $x_0$ is the initial condition, we must perform the following steps.\n\nFirst, we must generate the empirical data. Starting with the initial condition $x_0 \\in (0,1)$, we iterate the map. The first $M$ iterates are discarded to allow the system's state to converge to the attractor, effectively removing transient effects from the initial condition. Subsequently, we generate and store $N$ iterates, forming the set $\\{x_{M+1}, x_{M+2}, \\dots, x_{M+N}\\}$.\n\nSecond, we construct the empirical probability vector, $\\mathbf{p}^{\\text{emp}} \\in \\mathbb{R}^B$. The interval $[0,1]$ is partitioned into $B$ uniform bins. The bin edges are $e_k = k/B$ for $k \\in \\{0, 1, \\dots, B\\}$. The $k$-th bin (for $k \\in \\{0, 1, ..., B-1\\}$) is the interval $[e_k, e_{k+1})$. A special case is made for the rightmost boundary, such that the final bin is inclusive, $[e_{B-1}, e_B]$. We count the number of generated iterates, $c_k$, that fall into each bin $k$. The empirical probability for bin $k$ is then given by the fraction:\n$$\np^{\\text{emp}}_k = \\frac{c_k}{N}\n$$\n\nThird, we must determine the theoretical probability vector, $\\mathbf{p}^{\\text{th}} \\in \\mathbb{R}^B$. For the logistic map with $r=4$, the invariant probability density function for the iterates is known to be:\n$$\np(x) = \\frac{1}{\\pi\\sqrt{x(1-x)}}\n$$\nfor $x \\in (0,1)$. The theoretical probability of an iterate falling into bin $k$ is the integral of this density function over the bin's interval:\n$$\np^{\\text{th}}_k = \\int_{e_k}^{e_{k+1}} p(x) \\,dx = \\int_{k/B}^{(k+1)/B} \\frac{1}{\\pi\\sqrt{x(1-x)}} \\,dx\n$$\nThis integral can be evaluated analytically. Let $F(x)$ be the antiderivative of $p(x)$. We perform the substitution $x = \\sin^2(\\theta)$, for which $dx = 2\\sin(\\theta)\\cos(\\theta)\\,d\\theta$. With this substitution, the indefinite integral becomes:\n$$\nF(x) = \\int \\frac{1}{\\pi\\sqrt{\\sin^2(\\theta)(1-\\sin^2(\\theta))}} (2\\sin(\\theta)\\cos(\\theta)\\,d\\theta) = \\int \\frac{2}{\\pi} \\,d\\theta = \\frac{2}{\\pi}\\theta + C\n$$\nSubstituting back $\\theta = \\arcsin(\\sqrt{x})$, we obtain the antiderivative:\n$$\nF(x) = \\frac{2}{\\pi}\\arcsin(\\sqrt{x})\n$$\nBy the fundamental theorem of calculus, the theoretical probability for bin $k$ is:\n$$\np^{\\text{th}}_k = F(e_{k+1}) - F(e_k) = \\frac{2}{\\pi} \\left( \\arcsin\\left(\\sqrt{\\frac{k+1}{B}}\\right) - \\arcsin\\left(\\sqrt{\\frac{k}{B}}\\right) \\right)\n$$\nAll angles from the inverse sine function are in radians, as specified.\n\nFinally, we compute the required error metric $E$, which is the $\\ell^1$ distance between the two probability vectors:\n$$\nE = \\sum_{k=0}^{B-1} \\left| p^{\\text{emp}}_k - p^{\\text{th}}_k \\right|\n$$\nThis procedure is algorithmically implemented and applied to each of the four specified test cases. The results are then formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the formatted result.\n    \"\"\"\n\n    def calculate_error(N, M, B, x0):\n        \"\"\"\n        Calculates the error metric E for a single test case.\n\n        Args:\n            N (int): Sample size.\n            M (int): Burn-in count.\n            B (int): Number of bins.\n            x0 (float): Initial condition.\n\n        Returns:\n            float: The calculated L1 error E.\n        \"\"\"\n        r = 4.0\n\n        # Step 1: Generate the sequence of iterates for the logistic map.\n        # Use float64 for precision.\n        x = np.float64(x0)\n        \n        # Burn-in phase to let the system settle onto the attractor.\n        for _ in range(M):\n            x = r * x * (1.0 - x)\n\n        # Sampling phase.\n        iterates = np.zeros(N, dtype=np.float64)\n        for i in range(N):\n            x = r * x * (1.0 - x)\n            iterates[i] = x\n\n        # Step 2: Calculate the empirical probability vector p_emp.\n        # np.histogram correctly handles the half-open intervals on the right,\n        # which matches the problem's specification.\n        counts, _ = np.histogram(iterates, bins=B, range=(0.0, 1.0))\n        p_emp = counts / N\n\n        # Step 3: Calculate the theoretical probability vector p_th.\n        # The bin edges are e_k = k/B.\n        bin_edges = np.linspace(0.0, 1.0, B + 1, dtype=np.float64)\n        \n        # The antiderivative is F(x) = (2/pi) * arcsin(sqrt(x)).\n        # We evaluate F at all bin edges.\n        F_at_edges = (2.0 / np.pi) * np.arcsin(np.sqrt(bin_edges))\n        \n        # p_th_k = F(e_{k+1}) - F(e_k). This is vectorized for efficiency.\n        p_th = F_at_edges[1:] - F_at_edges[:-1]\n\n        # Step 4: Calculate the L1 error metric E.\n        E = np.sum(np.abs(p_emp - p_th))\n        \n        return E\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200000, 5000, 400, 0.123456789),\n        (100000, 1000, 200, 10**-12),\n        (5000, 500, 50, 0.37),\n        (100000, 1000, 200, 0.999999123),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, B, x0 = case\n        result = calculate_error(N, M, B, x0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2403543"}, {"introduction": "The principles of chaotic dynamics extend beyond real-valued maps into the rich world of the complex plane. The Mandelbrot set is a famous example, acting as a parameter-space map for the family of functions $z_{n+1} = z_n^2 + c$. This practice [@problem_id:2403617] involves implementing the classic escape-time algorithm to determine which parameters $c$ lead to bounded orbits, thereby constructing the boundary of this iconic fractal set.", "problem": "Implement a complete, runnable program to explore the Mandelbrot set by testing for which complex parameters $c \\in \\mathbb{C}$ the critical orbit of the complex quadratic map remains bounded. The complex quadratic map is defined by the iteration $z_{n+1} = f_c(z_n) = z_n^2 + c$, with the critical initial condition $z_0 = 0$. The Mandelbrot set is the set of all parameters $c$ such that the orbit $\\{z_n\\}_{n=0}^{\\infty}$ is bounded.\n\nUse the following fundamental base:\n- The iteration rule $z_{n+1} = z_n^2 + c$ defines a discrete-time dynamical system on $\\mathbb{C}$.\n- The modulus of a complex number $z$ is $|z| = \\sqrt{\\operatorname{Re}(z)^2 + \\operatorname{Im}(z)^2}$.\n- If $|z_n|$ ever exceeds a fixed escape radius $R$ during the iteration, then the orbit diverges to infinity. For the quadratic family $z^2 + c$, it is a well-tested and standard fact that taking $R = 2$ suffices: if $|z_n| > 2$ for some $n$, then the orbit of $z$ diverges to infinity.\n\nYour task is to:\n1. Implement a function that, for a given parameter $c$, iterates $z_{n+1} = z_n^2 + c$ starting from $z_0 = 0$, and returns a boolean indicating whether the orbit stays bounded, according to the following numerical criterion:\n   - Use the escape radius $R = 2$.\n   - Use a maximum number of iterations $N = 10000$.\n   - Declare the orbit as unbounded if there exists $n \\in \\{0,1,2,\\dots,N-1\\}$ such that $|z_n| > R$. Otherwise, declare it bounded.\n2. Apply your function to the test suite of parameters listed below and compute the boolean result for each parameter, where $\\mathrm{True}$ means “bounded within $N$ iterations” and $\\mathrm{False}$ means “escaped within $N$ iterations.”\n3. The imaginary unit is $i = \\sqrt{-1}$ and any complex number should be interpreted in radians for arguments in the complex exponential. There are no physical units in this problem.\n\nTest suite (evaluate in this exact order):\n- $c_1 = 0 + 0 i$\n- $c_2 = -1 + 0 i$\n- $c_3 = -2 + 0 i$\n- $c_4 = 0.25 + 0 i$\n- $c_5 = 1 + 0 i$\n- $c_6 = 0.26 + 0 i$\n- $c_7 = 0.28 + 0.207846 i$\n- $c_8 = 0.5 + 0.5 i$\n\nDesign for coverage:\n- $c_1$ is a simple interior point.\n- $c_2$ yields a known bounded period-$2$ cycle for the critical orbit.\n- $c_3$ and $c_4$ are boundary cases on the real axis.\n- $c_5$ and $c_6$ are exterior points on the real axis (with $c_6$ close to the cusp).\n- $c_7$ is an interior non-real point, constructed to lie in the main cardioid.\n- $c_8$ is a non-real point that escapes rapidly.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of booleans enclosed in square brackets. For example, the output must look like $[\\mathrm{True},\\mathrm{False},\\dots]$ but with no spaces after commas in the actual output string. Specifically, your program must produce exactly one line:\n- A single string representing a Python-style list of $8$ boolean values in the same order as the test suite, such as $[\\mathrm{True},\\mathrm{True},\\dots]$.\n\nNo user input is required and no external files should be read or written. All computations must be done using standard double-precision complex arithmetic. Angles, when implicitly involved in complex arithmetic, are in radians. There are no physical units to report. The final program must be self-contained and deterministic.", "solution": "The problem statement has been critically examined and is determined to be **valid**. It is scientifically grounded in the established mathematical theory of complex dynamical systems, is well-posed with a clear and complete set of definitions and constraints, and is expressed with objective, formal language. The task is to implement a standard algorithm for determining membership in the Mandelbrot set for a given set of parameters.\n\nThe problem revolves around the iteration of the complex quadratic map, defined as:\n$$\nz_{n+1} = f_c(z_n) = z_n^2 + c\n$$\nwhere $z_n$ and $c$ are complex numbers, $z, c \\in \\mathbb{C}$. This equation defines a discrete-time dynamical system for each parameter $c$.\n\nThe Mandelbrot set, denoted $\\mathcal{M}$, is the set of all parameters $c$ for which the orbit of the critical point $z_0 = 0$ remains bounded. The critical point is the point where the derivative of the map is zero, $f_c'(z) = 2z = 0$, which yields $z=0$. The behavior of this critical orbit, $\\{z_n\\}_{n=0}^{\\infty}$ where $z_0=0$, is fundamental to the structure of the system.\n\nA key theorem in complex dynamics provides a practical criterion for boundedness. It states that if the modulus of any iterate, $|z_n|$, exceeds the value $2$, the orbit is guaranteed to diverge to infinity. Consequently, the orbit is bounded if and only if $|z_n| \\le 2$ for all $n \\ge 0$.\n\nThis provides a basis for a numerical algorithm to test for membership in $\\mathcal{M}$. Since we cannot perform an infinite number of iterations, we use a finite-step approximation. For a given parameter $c$, we iterate the map starting from $z_0 = 0$ for a maximum of $N$ steps. If at any step $k < N$, the condition $|z_k| > R$ is met, where $R=2$ is the escape radius, we classify the orbit as unbounded and conclude that $c \\notin \\mathcal{M}$. If the modulus does not exceed $R$ after $N$ iterations, we declare the orbit to be bounded, providing an approximation that $c \\in \\mathcal{M}$.\n\nThe specific parameters for this problem are:\n-   Initial condition: $z_0 = 0 + 0i$.\n-   Maximum number of iterations: $N = 10000$.\n-   Escape radius: $R = 2$.\n\nThe algorithm to be implemented is as follows:\n\nFor a given complex parameter $c$:\n1.  Initialize the complex variable $z$ to $z_0 = 0$.\n2.  Iterate for $n$ from $0$ to $N - 1$:\n    a.  Check the escape condition: is $|z| > R$? Note that this is computationally equivalent and more efficient to check as $|z|^2 > R^2$, which in our case is $\\operatorname{Re}(z)^2 + \\operatorname{Im}(z)^2 > 4$. If this condition is met, the orbit is unbounded. The function terminates and returns $\\mathrm{False}$.\n    b.  If the escape condition is not met, update $z$ using the rule $z \\leftarrow z^2 + c$.\n3.  If the loop completes without the escape condition ever being satisfied, the orbit is considered bounded for the purposes of this numerical test. The function terminates and returns $\\mathrm{True}$.\n\nThis procedure will be applied to each of the $8$ complex parameters specified in the test suite:\n-   $c_1 = 0 + 0i$\n-   $c_2 = -1 + 0i$\n-   $c_3 = -2 + 0i$\n-   $c_4 = 0.25 + 0i$\n-   $c_5 = 1 + 0i$\n-   $c_6 = 0.26 + 0i$\n-   $c_7 = 0.28 + 0.207846i$\n-   $c_8 = 0.5 + 0.5i$\n\nThe final output will be a list of boolean values, one for each parameter, indicating the result of the boundedness test.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Mandelbrot set membership problem for a given test suite.\n    \"\"\"\n\n    def is_bounded(c, max_iter=10000, radius=2.0):\n        \"\"\"\n        Tests if the orbit of z_n+1 = z_n^2 + c starting from z_0 = 0 remains\n        bounded within a given number of iterations.\n\n        Args:\n            c (complex): The parameter of the quadratic map.\n            max_iter (int): The maximum number of iterations.\n            radius (float): The escape radius.\n\n        Returns:\n            bool: True if the orbit is bounded within max_iter, False otherwise.\n        \"\"\"\n        z = np.complex128(0)\n        # It is more efficient to compare squared moduli to avoid sqrt.\n        radius_sq = radius * radius\n\n        for _ in range(max_iter):\n            # Check the escape condition using squared modulus.\n            if z.real**2 + z.imag**2 > radius_sq:\n                return False\n            # Update z\n            z = z*z + c\n        \n        # If the loop completes, the orbit is considered bounded.\n        return True\n\n    # Define the test cases from the problem statement.\n    # We use np.complex128 to be explicit about using double-precision complex numbers.\n    test_cases = [\n        np.complex128(0, 0),          # c_1\n        np.complex128(-1, 0),         # c_2\n        np.complex128(-2, 0),         # c_3\n        np.complex128(0.25, 0),       # c_4\n        np.complex128(1, 0),          # c_5\n        np.complex128(0.26, 0),       # c_6\n        np.complex128(0.28, 0.207846),# c_7\n        np.complex128(0.5, 0.5)        # c_8\n    ]\n\n    results = []\n    for c_param in test_cases:\n        result = is_bounded(c_param)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The output format is a string representing a Python list of booleans,\n    # with no spaces after commas. e.g., [True,False,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403617"}, {"introduction": "One of the most remarkable discoveries in chaos theory is the principle of universality, which states that different systems can exhibit identical quantitative features as they transition to chaos. This exercise [@problem_id:2403605] guides you through the numerical detection of period-doubling bifurcations in the logistic map. By analyzing the geometric scaling of the attractor, you will compute an approximation of the Feigenbaum constant $\\alpha$, a universal value that appears in a wide variety of physical and mathematical systems.", "problem": "Write a complete program that, without any user input, automatically analyzes the logistic map to detect period-doubling bifurcations and compute an estimate of the Feigenbaum spatial-scaling constant. The logistic map is defined by the iteration $x_{n+1} = f_{r}(x_{n})$ with $f_{r}(x) = r x (1 - x)$ for a control parameter $r \\in \\mathbb{R}$ and state $x \\in [0,1]$. Use only numerical procedures grounded in definitions and well-tested facts from dynamical systems. Your solution must adhere to the following requirements.\n\n1. Fundamental definitions to use:\n- The logistic map $f_{r}(x) = r x (1-x)$.\n- A period-$p$ orbit is a set $\\{x_{0}, x_{1}, \\dots, x_{p-1}\\}$ with $f_{r}^{p}(x_{0}) = x_{0}$ and $p$ minimal, where $f_{r}^{p}$ denotes $p$-fold composition of $f_{r}$.\n- A period-doubling bifurcation occurs at parameter values $r_{n}$ where the attracting orbit’s minimal period changes from $2^{n-1}$ to $2^{n}$.\n- The critical point of $f_{r}$ is $x_{c} = 1/2$ (where $df_{r}/dx = 0$).\n- For each $n \\in \\mathbb{N}$, the superstable parameter $r_{n}^{*}$ within the period-$2^{n}$ window is defined by $f_{r}^{2^{n}}(x_{c}) = x_{c}$, which ensures that the period-$2^{n}$ cycle includes $x_{c}$ and is therefore superstable.\n- The diameter $d_{n}$ is defined at $r_{n}^{*}$ by $d_{n} = \\left| f_{r_{n}^{*}}^{2^{n-1}}(x_{c}) - x_{c} \\right|$.\n- The Feigenbaum spatial-scaling constant $\\alpha$ (magnitude) is the limit $\\alpha = \\lim_{n \\to \\infty} \\dfrac{d_{n-1}}{d_{n}}$.\n\n2. Program tasks:\n- Implement a robust numerical detector for the minimal period of the attracting orbit at a given $r$ using direct iteration. From an initial condition $x_{0}$, iterate $N_{\\text{trans}}$ transient steps to approach the attractor and then collect $N_{\\text{keep}}$ subsequent samples. Determine the smallest $p$ in the set $\\{1, 2, 4, 8, 16, 32, 64\\}$ such that the orbit is $p$-periodic to within a uniform tolerance $\\varepsilon$ over the kept samples. Concretely, verify approximate periodicity by checking that $\\max_{k} \\left| x_{k+p} - x_{k} \\right| < \\varepsilon$ over all indices $k$ for which both $x_{k}$ and $x_{k+p}$ are available. If no such $p$ is detected, report $0$ as “no period detected up to the tested maximum.”\n- Scan parameters $r$ on a uniform grid over the interval $[2.8, 4.0]$ with step size $10^{-3}$ to classify minimal periods and detect period-doubling windows. A period-$2^{n}$ window is a maximal contiguous interval in which the detected minimal period equals $2^{n}$. Use these windows to estimate bifurcation locations by their left endpoints.\n- Independently of window endpoints, compute the superstable parameters $r_{n}^{*}$ for $n \\in \\{1,2,3,4,5\\}$ by solving the scalar equation $f_{r}^{2^{n}}(x_{c}) - x_{c} = 0$ on an interval $[a_{n}, b_{n}]$ that you must construct numerically so that it brackets a root. Use $a_{1} = 3.0$, $b_{1} = 3.5$, and for $n \\ge 2$ choose $a_{n} = r_{n-1}^{*}$ and $b_{n} = 3.6$. Within $[a_{n}, b_{n}]$, locate a sign change of the function $g_{n}(r) = f_{r}^{2^{n}}(x_{c}) - x_{c}$ using a uniform subgrid and then apply a robust bracketing root-finder to obtain $r_{n}^{*}$.\n- Compute the diameters $d_{n} = \\left| f_{r_{n}^{*}}^{2^{n-1}}(x_{c}) - x_{c} \\right|$ for $n \\in \\{1,2,3,4,5\\}$ and form the sequence of Feigenbaum constant approximants $\\alpha_{n} = d_{n-1}/d_{n}$ for $n \\in \\{2,3,4,5\\}$.\n\n3. Numerical details that must be respected:\n- Use $x_{c} = 1/2$.\n- Use initial condition $x_{0} = 0.123456789$ for period detection.\n- Use $N_{\\text{trans}} = 1500$, $N_{\\text{keep}} = 512$, and $\\varepsilon = 10^{-7}$ for the periodicity test.\n- In the scan for minimal period, use the grid $r \\in [2.8, 4.0]$ with step $10^{-3}$ exactly.\n- In the root-bracketing subgrid for each $n$, use at least $200$ uniformly spaced samples to find a sign change of $g_{n}(r)$ inside $[a_{n}, b_{n}]$ before invoking a bracketing root-finder.\n\n4. Test suite and required outputs:\n- Test case $1$ (happy path): Compute $\\alpha_{5} = d_{4}/d_{5}$ and output it as a float rounded to $4$ decimals.\n- Test case $2$ (bifurcation location): From the period scan, report the left endpoint of the first detected period-$2$ window as an approximation to the first bifurcation $r_{1}$. Output it as a float rounded to $3$ decimals.\n- Test case $3$ (coverage inside a stable window): Using the periodicity detector, compute the minimal period at $r = 3.2$ and output it as an integer.\n- Test case $4$ (edge in a chaotic region): Using the periodicity detector, compute the minimal period at $r = 4.0$ and output it as an integer, with $0$ indicating that no period up to $64$ was detected.\n\n5. Final output format:\n- Your program should produce a single line of output containing the results of Test cases $1$ through $4$ as a comma-separated list enclosed in square brackets, for example, $[\\alpha_{5}, r_{1}^{\\text{est}}, p(r{=}3.2), p(r{=}4.0)]$, where each entry is given in the type and rounding specified above. No other text should be printed.\n- No physical units or angles are involved; all quantities are dimensionless real numbers or integers as specified.", "solution": "The problem presented is a well-posed task in computational physics, specifically in the domain of nonlinear dynamics and chaos theory. It requires the numerical investigation of the logistic map, defined by the iterative equation $x_{n+1} = f_r(x_n) = r x_n (1 - x_n)$, for a state $x \\in [0, 1]$ and a control parameter $r \\in \\mathbb{R}$. The objectives are to implement algorithms for period detection, locate bifurcation points, calculate superstable parameters, and ultimately estimate the Feigenbaum spatial-scaling constant $\\alpha$. The problem is scientifically sound, with all definitions and parameters being standard in the field. Therefore, we proceed with the solution.\n\nThe solution is constructed through a series of modular functions, each corresponding to a specific task outlined in the problem statement.\n\nFirst, we require a robust method for determining the minimal period of an attracting orbit for a given parameter $r$. The algorithm proceeds as follows: starting from an initial condition $x_0 = 0.123456789$, we iterate the logistic map for $N_{\\text{trans}} = 1500$ steps. This initial phase, known as the transient, is discarded to ensure that the subsequent states lie on or very near the attractor. We then collect the next $N_{\\text{keep}} = 512$ points of the orbit, $\\{x_k\\}_{k=1}^{N_{\\text{keep}}}$. To determine the minimal period, we test for periodicity against a set of candidate periods $p \\in \\{1, 2, 4, 8, 16, 32, 64\\}$. For each $p$, we check if the condition $\\max_{k} |x_{k+p} - x_k| < \\varepsilon$ is met, where the tolerance is $\\varepsilon = 10^{-7}$. The maximum is taken over all indices $k$ such that both $x_k$ and $x_{k+p}$ are within our collected sample. The smallest value of $p$ that satisfies this criterion is identified as the minimal period of the attracting orbit. If no such $p$ is found, we conclude that the orbit is not periodic with any of the tested periods, which may indicate chaotic behavior, and return a period of $0$.\n\nSecond, to approximate the location of the first period-doubling bifurcation, $r_1$, we perform a systematic scan of the parameter $r$. We create a uniform grid of $r$ values in the interval $[2.8, 4.0]$ with a step of $10^{-3}$. For each $r$ on this grid, we invoke the period detection algorithm described above. The problem defines a period-$2$ window as a contiguous range of $r$ values where the minimal period is found to be $2$. The first bifurcation point $r_1$, where the stable period-$1$ orbit gives way to a stable period-$2$ orbit, is estimated as the left endpoint of the first such detected window. This corresponds to the smallest $r$ in our grid for which the detected period is $2$.\n\nThird, a more precise method is employed to find the specific parameter values $r_n^*$ at which the period-$2^n$ orbits are superstable. An orbit is superstable when it includes the critical point of the map, $x_c = 1/2$, where the map's derivative is zero. The condition for a superstable period-$2^n$ orbit is thus $f_r^{2^n}(x_c) = x_c$. This translates to finding the roots of the function $g_n(r) = f_r^{2^n}(x_c) - x_c = 0$ for $n \\in \\{1, 2, 3, 4, 5\\}$. To solve this equation for $r_n^*$, we use a bracketing root-finding algorithm. As stipulated, for $n=1$, we search within the interval $[3.0, 3.5]$. For $n \\ge 2$, the search interval is $[r_{n-1}^*, 3.6]$. Within each primary interval, we first identify a tighter bracket $[a, b]$ where $g_n(a) \\cdot g_n(b) < 0$ by sampling the function $g_n(r)$ on a uniform subgrid of at least $200$ points. Once such a bracket is secured, a robust numerical solver, specifically Brent's method, is used to find the root $r_n^*$ with high precision.\n\nFourth, with the superstable parameters $r_n^*$ in hand, we can compute the sequence of approximants to the Feigenbaum constant $\\alpha$. This constant governs the scaling of the attractor's geometry near the accumulation point of period-doubling bifurcations. The approximants are based on the diameters $d_n$ of the attractor at these superstable points, defined as $d_n = |f_{r_n^*}^{2^{n-1}}(x_c) - x_c|$. This value represents the distance between the critical point $x_c$ and its image after $2^{n-1}$ iterations of the map, evaluated at the superstable parameter $r_n^*$. The ratio of successive diameters, $\\alpha_n = d_{n-1}/d_n$, forms a sequence that converges to $\\alpha$. The program computes this sequence up to $n=5$ to find the value of $\\alpha_5 = d_4/d_5$.\n\nFinally, the implemented functions are employed to address the four specific test cases. The first test case requires the calculation of $\\alpha_5$. The second test case requires the estimation of the first bifurcation point $r_1$ from the parameter scan. The third and fourth test cases require applying the period detector to specific $r$ values, $r=3.2$ (stable period-$2$ window) and $r=4.0$ (chaotic regime), respectively. The results are collected, formatted to the specified precision, and presented in the required list format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing the required numerical analyses of the logistic map.\n    \"\"\"\n    # Define problem constants and numerical parameters as specified.\n    XC = 0.5\n    X0 = 0.123456789\n    N_TRANS = 1500\n    N_KEEP = 512\n    TOL = 1e-7\n\n    def iterate_map(r, x, n_iter):\n        \"\"\"Iterates the logistic map f_r(x) = r*x*(1-x) for n_iter steps.\"\"\"\n        for _ in range(n_iter):\n            x = r * x * (1.0 - x)\n        return x\n\n    def detect_period(r, x0, n_trans, n_keep, tol):\n        \"\"\"\n        Detects the minimal period of the attractor for a given parameter r.\n        It checks for periods in {1, 2, 4, ..., 64}.\n        Returns 0 if no period is detected up to the maximum.\n        \"\"\"\n        x = x0\n        # Discard transients to let the orbit settle on the attractor.\n        x = iterate_map(r, x, n_trans)\n        \n        # Collect subsequent points that are assumed to be on the attractor.\n        orbit = np.zeros(n_keep)\n        for i in range(n_keep):\n            x = iterate_map(r, x, 1)\n            orbit[i] = x\n            \n        # Test for minimal period p in increasing order.\n        possible_periods = [2**i for i in range(7)]  # {1, 2, 4, 8, 16, 32, 64}\n        for p in possible_periods:\n            if n_keep > p:\n                max_diff = 0.0\n                for k in range(n_keep - p):\n                    diff = np.abs(orbit[k+p] - orbit[k])\n                    if diff > max_diff:\n                        max_diff = diff\n                \n                if max_diff < tol:\n                    return p\n        return 0\n\n    def g_n_func(r, n, xc):\n        \"\"\"Computes the function g_n(r) = f_r^{2^n}(xc) - xc for root finding.\"\"\"\n        p = 2**n\n        x_final = iterate_map(r, xc, p)\n        return x_final - xc\n\n    def find_superstable_r(n, r_start_bracket, r_end_bracket, xc):\n        \"\"\"\n        Finds the superstable parameter r_n* by finding the root of g_n(r).\n        \"\"\"\n        # Search for a sign change on a subgrid to find a tight bracket.\n        subgrid_size = 201\n        r_grid = np.linspace(r_start_bracket, r_end_bracket, subgrid_size)\n        g_vals = np.array([g_n_func(r, n, xc) for r in r_grid])\n        \n        root_bracket = None\n        for i in range(len(g_vals) - 1):\n            if np.sign(g_vals[i]) != np.sign(g_vals[i+1]):\n                root_bracket = (r_grid[i], r_grid[i+1])\n                break\n        \n        if root_bracket is None:\n            raise ValueError(f\"Could not find a root bracket for n={n} in [{r_start_bracket}, {r_end_bracket}]\")\n        \n        # Use a robust bracketing root-finder to get the precise value of r_n*.\n        r_superstable = brentq(g_n_func, root_bracket[0], root_bracket[1], args=(n, xc))\n        return r_superstable\n\n    def calculate_alpha5(xc):\n        \"\"\"\n        Calculates the 5th approximant to the Feigenbaum constant alpha, alpha_5 = d_4/d_5.\n        \"\"\"\n        n_max = 5\n        r_superstable = {}\n        diameters = {}\n        \n        # Calculate r_n* for n=1,...,5.\n        # n = 1 case uses the specified initial bracket.\n        r_superstable[1] = find_superstable_r(1, 3.0, 3.5, xc)\n        \n        # n > 1 cases use the recursive bracket [r_{n-1}*, 3.6].\n        for n in range(2, n_max + 1):\n            r_start_bracket = r_superstable[n-1]\n            r_end_bracket = 3.6\n            r_superstable[n] = find_superstable_r(n, r_start_bracket, r_end_bracket, xc)\n\n        # Calculate diameters d_n = |f_{r_n*}^{2^{n-1}}(xc) - xc|.\n        for n in range(1, n_max + 1):\n            r_n_star = r_superstable[n]\n            p_diam = 2**(n-1)\n            x_final = iterate_map(r_n_star, xc, p_diam)\n            diameters[n] = np.abs(x_final - xc)\n            \n        alpha_5 = diameters[4] / diameters[5]\n        return alpha_5\n\n    def scan_bifurcation_point(x0, n_trans, n_keep, tol):\n        \"\"\"\n        Scans r on a grid to find the left endpoint of the first period-2 window,\n        which serves as an estimate for the first bifurcation point r_1.\n        \"\"\"\n        num_steps = int(round((4.0 - 2.8) / 1e-3)) + 1\n        r_values = np.linspace(2.8, 4.0, num_steps)\n        \n        for r in r_values:\n            period = detect_period(r, x0, n_trans, n_keep, tol)\n            if period == 2:\n                return r\n        return None\n\n    # --- Execute Test Cases ---\n    \n    # Test case 1: Compute alpha_5 = d_4/d_5.\n    alpha_5_val = calculate_alpha5(XC)\n    result1 = round(alpha_5_val, 4)\n    \n    # Test case 2: Estimate r_1 from the period scan.\n    r1_est = scan_bifurcation_point(X0, N_TRANS, N_KEEP, TOL)\n    result2 = round(r1_est, 3)\n    \n    # Test case 3: Compute minimal period at r = 3.2.\n    result3 = detect_period(3.2, X0, N_TRANS, N_KEEP, TOL)\n    \n    # Test case 4: Compute minimal period at r = 4.0.\n    result4 = detect_period(4.0, X0, N_TRANS, N_KEEP, TOL)\n\n    test_cases = [result1, result2, result3, result4]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, test_cases))}]\")\n\nsolve()\n```", "id": "2403605"}]}