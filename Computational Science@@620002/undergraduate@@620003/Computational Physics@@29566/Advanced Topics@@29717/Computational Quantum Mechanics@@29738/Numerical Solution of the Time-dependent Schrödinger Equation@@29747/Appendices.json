{"hands_on_practices": [{"introduction": "Finding the ground state of a quantum system is a central task in physics and chemistry, providing the baseline for understanding its properties and behavior. The imaginary time evolution method offers a powerful way to achieve this by transforming the time-dependent Schrödinger equation into a diffusion-like equation in which any arbitrary initial state robustly decays towards the lowest-energy eigenstate. This exercise introduces the widely used split-step Fourier method to implement this technique, allowing you to find both the ground state wave function and its corresponding energy for a non-trivial double-well potential, thereby building a foundational skill for quantum simulations [@problem_id:2421305].", "problem": "Consider the one-dimensional time-dependent Schrödinger equation (TDSE) for a particle of mass $m$ in a potential $V(x)$,\n$$\ni \\hbar \\,\\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; \\left[-\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2} + V(x)\\right]\\psi(x,t).\n$$\nLet the potential be a symmetric double-well of the form\n$$\nV(x) \\;=\\; a \\,\\bigl(x^2 - b^2\\bigr)^2,\n$$\nwith parameters $a \\gt 0$ and $b \\ge 0$. Work in the unit system where $\\hbar = 1$ and $m=1$, so energies must be reported in the corresponding energy unit implied by these choices. You are to determine the ground-state wavefunction $\\psi_0(x)$ and the corresponding ground-state energy $E_0$ by solving the TDSE under the substitution $t \\rightarrow -i \\tau$, and by enforcing normalization of the evolving state at all times. The computational domain is the finite interval $x \\in [-L, L]$ with $L = 10$, discretized on a uniform grid of $N = 1024$ points. Use a square-integrable initial condition that is nonzero everywhere on the grid; specifically, initialize at $\\tau = 0$ with the normalized Gaussian\n$$\n\\psi(x,0) \\;\\propto\\; \\exp\\!\\left(-\\frac{x^2}{2\\sigma^2}\\right), \\quad \\sigma = 1.0.\n$$\nEvolve in imaginary time with a fixed step $\\Delta \\tau = 10^{-3}$ and continue until the change in the computed energy between successive convergence checks is less than $10^{-9}$ in absolute value, or until a maximum of $2\\times 10^4$ steps is reached. At convergence (or upon reaching the maximum number of steps), report the computed ground-state energy $E_0$.\n\nUnits and numerical conventions:\n- Use $\\hbar = 1$ and $m=1$; express all energies in these units.\n- Angle arguments to any trigonometric or exponential functions are in radians by mathematical convention.\n\nTest suite:\nCompute and report the ground-state energy $E_0$ for each of the following parameter pairs $(a,b)$:\n1. $(a,b) = (1.0,\\,1.0)$\n2. $(a,b) = (1.0,\\,1.5)$\n3. $(a,b) = (5.0,\\,1.0)$\n4. $(a,b) = (0.5,\\,0.0)$\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of decimal numbers enclosed in square brackets and ordered exactly as the test suite above. Each number must be rounded to six decimal places. For example, a valid output line has the form\n$[e_1,e_2,e_3,e_4]$\nwith no spaces.", "solution": "The problem posed is a well-defined exercise in computational quantum mechanics and is therefore valid. It asks for the ground-state energy of a particle in a one-dimensional double-well potential by solving the Schrödinger equation in imaginary time. This is a standard and robust method for finding the ground state of a quantum system.\n\nThe fundamental equation is the time-dependent Schrödinger equation (TDSE):\n$$\ni \\hbar \\frac{\\partial \\psi(x,t)}{\\partial t} = H \\psi(x,t)\n$$\nwhere the Hamiltonian operator is $H = T + V$, with the kinetic energy operator $T = -\\frac{\\hbar^2}{2m}\\frac{\\partial^2}{\\partial x^2}$ and the potential energy operator $V = V(x)$. The problem specifies the units $\\hbar=1$ and $m=1$, and the potential $V(x) = a(x^2 - b^2)^2$.\n\nThe method of imaginary time evolution involves the substitution $t \\rightarrow -i\\tau$. The TDSE transforms into a diffusion-like equation in the imaginary time coordinate $\\tau$:\n$$\n\\frac{\\partial \\psi(x,\\tau)}{\\partial \\tau} = -H \\psi(x,\\tau)\n$$\nThe formal solution to this equation over a small time step $\\Delta\\tau$ is given by\n$$\n\\psi(x, \\tau + \\Delta\\tau) = e^{-H\\Delta\\tau} \\psi(x,\\tau).\n$$\nTo understand why this process yields the ground state, we expand an arbitrary initial state $\\psi(x,0)$ in the complete basis of energy eigenfunctions $\\{\\psi_n(x)\\}$ of the Hamiltonian $H$, for which $H\\psi_n = E_n\\psi_n$:\n$$\n\\psi(x,0) = \\sum_{n=0}^{\\infty} c_n \\psi_n(x)\n$$\nThe evolution in imaginary time is then\n$$\n\\psi(x,\\tau) = e^{-H\\tau} \\psi(x,0) = \\sum_{n=0}^{\\infty} c_n e^{-H\\tau} \\psi_n(x) = \\sum_{n=0}^{\\infty} c_n e^{-E_n\\tau} \\psi_n(x).\n$$\nThis can be rewritten as:\n$$\n\\psi(x,\\tau) = c_0 e^{-E_0\\tau} \\psi_0(x) + c_1 e^{-E_1\\tau} \\psi_1(x) + \\dots\n$$\nSince the ground-state energy $E_0$ is the lowest energy ($E_n > E_0$ for $n > 0$), the term $e^{-E_0\\tau}$ decays more slowly than all other terms $e^{-E_n\\tau}$. Consequently, as $\\tau \\rightarrow \\infty$, the wavefunction becomes dominated by the ground-state component, provided the initial state has a non-zero overlap with it ($c_0 \\neq 0$).\n$$\n\\lim_{\\tau\\to\\infty} \\psi(x,\\tau) \\propto \\psi_0(x)\n$$\nThe overall amplitude decays as $e^{-E_0\\tau}$. To extract the wavefunction $\\psi_0(x)$, the state must be renormalized at each step.\n\nThe numerical implementation of the evolution operator $e^{-H\\Delta\\tau}$ is achieved using the split-step Fourier method. Since the kinetic ($T$) and potential ($V$) operators do not commute, we cannot simply write $e^{-(T+V)\\Delta\\tau} = e^{-T\\Delta\\tau}e^{-V\\Delta\\tau}$. Instead, we use a symmetric second-order Trotter-Suzuki decomposition (Strang splitting), which is accurate to order $(\\Delta\\tau)^2$:\n$$\ne^{-H\\Delta\\tau} = e^{-(T+V)\\Delta\\tau} \\approx e^{-V\\Delta\\tau/2} e^{-T\\Delta\\tau} e^{-V\\Delta\\tau/2}\n$$\nThe algorithm for a single time step $\\Delta\\tau$ proceeds as follows:\n1.  Propagate the wavefunction by half a step under the potential operator. This is a simple multiplication in position space: $\\psi'(x) = e^{-V(x)\\Delta\\tau/2} \\psi(x)$.\n2.  Propagate by a full step under the kinetic operator. This operation is simple in momentum space, where the kinetic operator is diagonal. We transform the wavefunction to momentum space using the Fast Fourier Transform (FFT), $\\tilde{\\psi}'(k) = \\mathcal{F}\\{\\psi'(x)\\}$.\n3.  In momentum space, the propagation is a multiplication: $\\tilde{\\psi}''(k) = e^{-T(k)\\Delta\\tau} \\tilde{\\psi}'(k)$, where $T(k) = \\frac{\\hbar^2 k^2}{2m} = \\frac{k^2}{2}$ in the given units.\n4.  Transform the result back to position space using the inverse FFT: $\\psi''(x) = \\mathcal{F}^{-1}\\{\\tilde{\\psi}''(k)\\}$.\n5.  Propagate by the remaining half step under the potential operator: $\\psi(x, \\tau+\\Delta\\tau) = e^{-V(x)\\Delta\\tau/2} \\psi''(x)$.\n6.  Finally, re-normalize the wavefunction to unity: $\\psi \\leftarrow \\psi / \\sqrt{\\int |\\psi|^2 dx}$.\n\nThis sequence is repeated until the energy converges. The ground-state energy $E_0$ is the expectation value of the Hamiltonian for the converged ground-state wavefunction $\\psi_0$:\n$$\nE_0 = \\langle \\psi_0 | H | \\psi_0 \\rangle = \\int_{-\\infty}^{\\infty} \\psi_0^*(x) H \\psi_0(x) dx\n$$\nNumerically, the term $H\\psi_0$ is computed as $(T+V)\\psi_0$. The application of the kinetic operator $T\\psi_0 = -\\frac{1}{2}\\frac{\\partial^2\\psi_0}{\\partial x^2}$ is again efficiently performed in Fourier space: $T\\psi_0 = \\mathcal{F}^{-1} \\{ \\frac{k^2}{2} \\mathcal{F}\\{\\psi_0\\} \\}$. The integral is then computed as a sum over the discrete grid points. The process is terminated when the absolute difference between energy values from successive checks falls below the specified tolerance of $10^{-9}$.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve for the ground-state energy for the given test cases.\n    \"\"\"\n    test_cases = [\n        (1.0, 1.0),\n        (1.0, 1.5),\n        (5.0, 1.0),\n        (0.5, 0.0),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        energy = find_ground_state_energy(a, b)\n        results.append(energy)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef find_ground_state_energy(a, b):\n    \"\"\"\n    Calculates the ground-state energy for a given double-well potential V(x) = a(x^2 - b^2)^2.\n\n    The calculation uses the imaginary time evolution method with a split-step Fourier\n    transform algorithm to solve the time-dependent Schrödinger equation.\n\n    Args:\n        a (float): The 'a' parameter of the potential.\n        b (float): The 'b' parameter of the potential.\n\n    Returns:\n        float: The computed ground-state energy.\n    \"\"\"\n    # System parameters and constants (hbar=1, m=1)\n    L = 10.0\n    N = 1024\n    dx = 2 * L / N\n    x = np.linspace(-L, L, num=N, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n\n    # Potential energy array\n    V = a * (x**2 - b**2)**2\n\n    # Kinetic energy in momentum space\n    T_k = k**2 / 2.0\n\n    # Imaginary time evolution parameters\n    dtau = 1.0e-3\n    max_steps = 20000\n    convergence_tol = 1.0e-9\n    check_interval = 100\n\n    # Initial wavefunction: a normalized Gaussian\n    sigma = 1.0\n    psi = np.exp(-x**2 / (2 * sigma**2))\n    norm = np.sqrt(np.sum(np.abs(psi)**2) * dx)\n    psi = psi / norm\n\n    # Split-step propagation operators\n    V_op_half = np.exp(-V * dtau / 2.0)\n    T_op = np.exp(-T_k * dtau)\n\n    E_old = 0.0\n    E_final = 0.0\n\n    for step in range(1, max_steps + 1):\n        # Strang splitting for one time step\n        # 1. Half step in potential\n        psi *= V_op_half\n        \n        # 2. Full step in kinetic (in momentum space)\n        psi_k = np.fft.fft(psi)\n        psi_k *= T_op\n        psi = np.fft.ifft(psi_k)\n        \n        # 3. Second half step in potential\n        psi *= V_op_half\n\n        # Normalize the wavefunction\n        norm = np.sqrt(np.sum(np.abs(psi)**2) * dx)\n        psi /= norm\n\n        # Check for convergence at specified intervals\n        if step % check_interval == 0:\n            # Calculate energy E = <psi|H|psi>\n            # H_psi = (T + V) * psi\n            # T*psi is computed using FFT: IFFT(T_k * FFT(psi))\n            psi_k = np.fft.fft(psi)\n            T_psi = np.fft.ifft(T_k * psi_k)\n            H_psi = T_psi + V * psi\n            \n            E_new = np.real(np.sum(np.conj(psi) * H_psi) * dx)\n\n            if np.abs(E_new - E_old) < convergence_tol:\n                E_final = E_new\n                break\n            \n            E_old = E_new\n    else:\n        # If the loop completes without converging, calculate the energy one last time.\n        psi_k = np.fft.fft(psi)\n        T_psi = np.fft.ifft(T_k * psi_k)\n        H_psi = T_psi + V * psi\n        E_final = np.real(np.sum(np.conj(psi) * H_psi) * dx)\n\n    return E_final\n    \nsolve()\n```", "id": "2421305"}, {"introduction": "Understanding how wave packets interact with potential barriers is key to comprehending quantum tunneling, a purely quantum mechanical phenomenon with profound real-world applications from scanning tunneling microscopy to nuclear fusion. Instead of performing a computationally intensive, full time-dependent simulation, the total tunneling probability of a wave packet can be determined more elegantly by integrating the energy-dependent transmission coefficient over the packet's initial energy distribution. This practice challenges you to implement this efficient approach, which masterfully connects the concepts of time-dependent dynamics with stationary-state scattering theory, thus sharpening your physical intuition and expanding your computational problem-solving toolkit [@problem_id:2432557].", "problem": "Consider a one-dimensional non-relativistic particle governed by the time-dependent Schrödinger equation in nondimensionalized units where Planck’s constant divided by $2\\pi$ is $1$ and the mass is $1$. The equation is\n$$\ni \\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t),\n$$\nwith a square barrier potential\n$$\nV(x) \\;=\\; \\begin{cases}\nV_0, & \\text{for } -\\frac{a}{2} \\le x \\le \\frac{a}{2}, \\\\[4pt]\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThe barrier parameters are fixed to $V_0 = 5$ and $a = 1.5$. The initial state at time $t=0$ is a normalized Gaussian wave packet incident from the left with mean wave number $k_0 = 2.0$ and momentum spread (standard deviation) $\\Delta k > 0$. In position representation, it is specified by\n$$\n\\psi(x,0) \\;=\\; \\frac{1}{(2\\pi \\sigma_x^2)^{1/4}} \\exp\\!\\Big(-\\frac{(x-x_0)^2}{4\\sigma_x^2}\\Big)\\,\\exp(i k_0 x),\n$$\nwith $\\Delta k = \\frac{1}{2\\sigma_x}$ and an arbitrary $x_0 \\ll -\\frac{a}{2}$ chosen so that the wave packet is initially well to the left of the barrier. The tunneling probability of the wave packet is defined as the total probability that is found for $x > \\frac{a}{2}$ in the long-time limit $t \\to \\infty$ after the scattering has fully completed. All quantities are dimensionless; the final answers should be pure numbers without units.\n\nTask: For each specified value of $\\Delta k$ in the test suite below, compute the tunneling probability of the wave packet through the barrier described above, assuming the barrier is static and the evolution is governed entirely by the Schrödinger dynamics given.\n\nTest suite (values of $\\Delta k$ to evaluate): $\\{0.05,\\;0.10,\\;0.20,\\;0.50,\\;0.70\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., [r1,r2,r3,r4,r5]), where each entry corresponds to the tunneling probability for the corresponding $\\Delta k$ in the order listed above. Each reported result must be a real number in the closed interval $[0,1]$.", "solution": "The problem statement is subjected to validation.\n\nStep 1: Extracted Givens\n- Governing Equation: One-dimensional time-dependent Schrödinger equation: $i \\frac{\\partial \\psi(x,t)}{\\partial t} = -\\frac{1}{2}\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} + V(x)\\psi(x,t)$.\n- Constants: $\\hbar = 1$, mass $m = 1$.\n- Potential: Square barrier, $V(x) = V_0$ for $-\\frac{a}{2} \\le x \\le \\frac{a}{2}$, and $V(x)=0$ otherwise.\n- Barrier Parameters: $V_0 = 5$, $a = 1.5$.\n- Initial State ($t=0$): A normalized Gaussian wave packet, $\\psi(x,0) = \\frac{1}{(2\\pi \\sigma_x^2)^{1/4}} \\exp(-\\frac{(x-x_0)^2}{4\\sigma_x^2})\\exp(i k_0 x)$.\n- Wave Packet Parameters: Mean wave number $k_0 = 2.0$, momentum spread $\\Delta k > 0$.\n- Relation: $\\Delta k = \\frac{1}{2\\sigma_x}$.\n- Initial Position: $x_0 \\ll -\\frac{a}{2}$.\n- Definition of Tunneling Probability: $P_{tunnel} = \\lim_{t \\to \\infty} \\int_{a/2}^{\\infty} |\\psi(x,t)|^2 dx$.\n- Task: Compute $P_{tunnel}$ for each $\\Delta k$ in the test suite.\n- Test Suite: $\\Delta k \\in \\{0.05, 0.10, 0.20, 0.50, 0.70\\}$.\n\nStep 2: Validation Using Extracted Givens\nThe problem is scientifically grounded, describing the quantum tunneling of a wave packet, a cornerstone of quantum mechanics. It is well-posed, with a specified governing equation, initial condition, and a clear definition for the quantity to be computed. The condition $x_0 \\ll -a/2$ is a standard requirement in scattering problems, ensuring the initial state does not overlap with the interaction region, and does not invalidate the problem. All parameters are clearly defined and physically consistent. The problem does not violate any of the invalidity criteria.\n\nStep 3: Verdict and Action\nThe problem is valid. A solution will be provided.\n\nThe task is to compute the probability that a quantum wave packet tunnels through a potential barrier. A direct numerical simulation of the time-dependent Schrödinger equation is possible, for instance, using a split-step Fourier method. However, for the given parameters, this approach is problematic. The wave packets corresponding to larger values of $\\Delta k$ are narrow in position space and will spread significantly during the long time evolution required for the scattering process to complete. This necessitates an exceptionally large spatial grid to prevent the wave function from reaching the boundaries and causing unphysical wrap-around effects, making the direct simulation computationally intensive and numerically delicate.\n\nA more robust and elegant method is to use the principles of stationary-state scattering theory. The initial wave packet $\\psi(x,0)$ can be represented as a superposition of plane waves (momentum eigenstates) via a Fourier transform. The momentum-space representation of the initial wave packet is also a Gaussian:\n$$\n\\phi(k) = \\mathcal{F}\\{\\psi(x,0)\\} \\propto \\exp\\left(-\\sigma_x^2 (k-k_0)^2\\right)\n$$\nThe corresponding probability distribution in momentum space is\n$$\n|\\phi(k)|^2 = \\frac{1}{\\sqrt{2\\pi(\\Delta k)^2}} \\exp\\left(-\\frac{(k-k_0)^2}{2(\\Delta k)^2}\\right)\n$$\nwhere $\\Delta k = 1/(2\\sigma_x)$ is the standard deviation of the momentum distribution, as given.\n\nEach momentum component $k$ of the wave packet corresponds to a plane wave with a definite energy $E(k) = \\frac{\\hbar^2 k^2}{2m}$. Since we work in units where $\\hbar=1$ and $m=1$, this simplifies to $E(k) = k^2/2$. For each such plane wave, the probability of transmission through a square barrier is given by a standard analytical formula, the transmission coefficient $T(E)$.\n\nFor an incident particle with energy $E$ and a square barrier of height $V_0$ and width $a$, the transmission coefficient $T(E)$ is given by:\n1. For $E  V_0$ (tunneling):\n$$ T(E) = \\left[ 1 + \\frac{V_0^2}{4E(V_0-E)} \\sinh^2(\\kappa a) \\right]^{-1}, \\quad \\text{where } \\kappa = \\sqrt{2m(V_0-E)}/\\hbar = \\sqrt{2(V_0-E)} $$\n2. For $E > V_0$ (over-barrier scattering):\n$$ T(E) = \\left[ 1 + \\frac{V_0^2}{4E(E-V_0)} \\sin^2(q a) \\right]^{-1}, \\quad \\text{where } q = \\sqrt{2m(E-V_0)}/\\hbar = \\sqrt{2(E-V_0)} $$\n3. For the special case $E = V_0$:\n$$ T(E=V_0) = \\left[ 1 + \\frac{m V_0 a^2}{2\\hbar^2} \\right]^{-1} = \\left[ 1 + \\frac{V_0 a^2}{2} \\right]^{-1} $$\n\nThe total tunneling probability for the entire wave packet is the expectation value of the transmission coefficient $T(E(k))$ over the momentum distribution of the wave packet. Since the wave packet is incident from the left, only components with positive momentum $k>0$ are moving towards the barrier and can contribute to transmission. Thus, the integral is taken over $k \\in [0, \\infty)$:\n$$\nP_{tunnel} = \\int_{0}^{\\infty} |\\phi(k)|^2 \\, T(E(k)) \\, dk\n$$\nSubstituting the expressions for $|\\phi(k)|^2$ and $E(k)$, we obtain the integral to be computed:\n$$\nP_{tunnel} = \\int_{0}^{\\infty} \\frac{1}{\\sqrt{2\\pi(\\Delta k)^2}} \\exp\\left(-\\frac{(k-k_0)^2}{2(\\Delta k)^2}\\right) T\\left(\\frac{k^2}{2}\\right) \\, dk\n$$\nThis integral cannot be solved analytically due to the complexity of $T(E(k))$. However, it can be computed with high precision using numerical quadrature methods. This approach is computationally efficient and avoids the difficulties of a full time-dependent simulation.\n\nThe algorithm is as follows:\n1. For each value of $\\Delta k$ from the test suite $\\{0.05, 0.10, 0.20, 0.50, 0.70\\}$:\n2. Define the integrand function, which takes a momentum value $k$ and computes the product of the momentum probability density and the corresponding transmission coefficient $T(k^2/2)$.\n3. Use a numerical integration routine, such as `scipy.integrate.quad`, to compute the definite integral of this function from $k=0$ to a sufficiently large upper limit (e.g., $k_0 + 10 \\Delta k$, where the Gaussian tail is negligible).\n4. Store the resulting probability.\n5. Report the collected results in the specified format.\nThe fixed parameters are $V_0=5$, $a=1.5$, and $k_0=2.0$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Solves the quantum tunneling problem for a Gaussian wave packet.\n\n    The solution calculates the tunneling probability by integrating the\n    energy-dependent transmission coefficient T(E) over the energy\n    distribution of the initial wave packet. This avoids a full\n    time-dependent simulation, which is computationally intensive and\n    numerically challenging for the given parameters.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [0.05, 0.10, 0.20, 0.50, 0.70]\n\n    # Fixed parameters of the physical system\n    V0 = 5.0     # Barrier height\n    a = 1.5      # Barrier width\n    k0 = 2.0     # Mean wave number of the packet\n    hbar = 1.0   # Reduced Planck constant\n    m = 1.0      # Particle mass\n\n    def transmission_coefficient(E, V0, a):\n        \"\"\"\n        Calculates the transmission coefficient T(E) for a square barrier.\n        Handles three cases: E  V0 (tunneling), E  V0 (scattering), and E = V0.\n        \"\"\"\n        # A particle with zero or negative energy cannot be incident from the left\n        # and reach the barrier, so its transmission probability is zero.\n        if E = 0:\n            return 0.0\n\n        # Case 1: E is exactly V0. This is the limit of the other two cases.\n        if np.isclose(E, V0):\n            return 1.0 / (1.0 + (m * V0 * a**2) / (2 * hbar**2))\n        \n        # Case 2: E  V0 (classical tunneling region)\n        elif E  V0:\n            kappa = np.sqrt(2 * m * (V0 - E)) / hbar\n            sinh_term = np.sinh(kappa * a)\n            denom = 1.0 + (V0**2 * sinh_term**2) / (4 * E * (V0 - E))\n            return 1.0 / denom\n        \n        # Case 3: E  V0 (classical over-barrier region)\n        else: # E  V0\n            q = np.sqrt(2 * m * (E - V0)) / hbar\n            sin_term = np.sin(q * a)\n            denom = 1.0 + (V0**2 * sin_term**2) / (4 * E * (E - V0))\n            return 1.0 / denom\n\n    results = []\n    for delta_k in test_cases:\n        \n        def integrand(k):\n            \"\"\"\n            The function to be integrated over momentum k.\n            It's the product of the momentum probability distribution and the\n            transmission coefficient T(E(k)).\n            \"\"\"\n            # Energy as a function of momentum k\n            E = (hbar**2 * k**2) / (2 * m)\n            \n            # Probability density of the momentum distribution (Gaussian)\n            norm_factor = 1.0 / (np.sqrt(2 * np.pi) * delta_k)\n            prob_density_k = norm_factor * np.exp(-((k - k0)**2) / (2 * delta_k**2))\n            \n            # Transmission coefficient for energy E\n            T_E = transmission_coefficient(E, V0, a)\n            \n            return prob_density_k * T_E\n\n        # The integration is performed from k=0 to infinity.\n        # We integrate from k=0 because only right-moving components (k0)\n        # can interact with the barrier.\n        # quad integrates from the lower limit to the upper limit (inf).\n        tunneling_probability, _ = integrate.quad(integrand, 0, np.inf)\n        \n        results.append(tunneling_probability)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "2432557"}, {"introduction": "The Franck-Condon principle is fundamental to molecular spectroscopy, explaining the intensity patterns observed in vibronic transitions and allowing us to probe the geometry of molecules in different electronic states. This principle stems from the sudden approximation: an electronic transition occurs so rapidly that the nuclear wave function is momentarily \"frozen,\" and its projection onto the final vibrational eigenstates dictates the likelihood of observing each possible transition. This advanced practice allows you to model this key spectroscopic principle, reinforcing your understanding of eigenstate projections and highlighting the crucial scientific practice of validating numerical results against a known analytical model [@problem_id:2466142].", "problem": "You are to model the Franck–Condon (FC) principle for a one-dimensional diatomic vibrational mode by projecting the ground vibrational state of a harmonic oscillator onto the eigenstates of a second, identical harmonic potential that is displaced in coordinate but not in curvature. The FC principle arises from the time-dependent Schrödinger equation (TDSE), which implies that under a sudden change of the potential (a vertical electronic transition), the nuclear wavefunction is unchanged at time $t=0$, so the probability to observe a vibrational quantum number $n$ on the final potential is given by the squared magnitude of the projection (overlap integral) between the initial state and the final Hamiltonian’s $n$-th eigenstate. The time-independent Schrödinger equation (TISE) provides the eigenfunctions of the harmonic oscillator that form the basis for the projection. Work in reduced units where $m=1$ and $\\hbar=1$, and consider only identical curvatures, so the angular frequency $\\omega$ is the same before and after displacement.\n\nStarting from the TDSE postulate that time evolution under a sudden potential change leaves the state unchanged at $t=0$, and from the orthonormality and completeness of harmonic oscillator eigenfunctions defined by the TISE, derive the expression for the projection coefficients in terms of overlap integrals. Then connect this to a computational procedure that:\n- Computes the Franck–Condon factors $P_n$ for $n=0,1,\\dots,n_{\\max}$ by evaluating the squared overlap magnitude $\\left|\\langle \\psi_n^{(\\mathrm{final})} \\mid \\psi_0^{(\\mathrm{initial})}\\rangle\\right|^2$ using numerical quadrature on a sufficiently wide real-space grid, where $\\psi_0^{(\\mathrm{initial})}(x)$ is the ground state of the initial harmonic oscillator with frequency $\\omega$, and $\\psi_n^{(\\mathrm{final})}(x)$ is the $n$-th eigenstate of the final harmonic oscillator potential of the same frequency $\\omega$ but displaced by $\\Delta x$ in coordinate.\n- Independently derives and uses a closed-form analytical expression for the same projection probabilities appropriate for identical curvatures and a coordinate displacement, expressed in terms of a dimensionless displacement parameter constructed from $\\omega$ and $\\Delta x$.\n- Compares the analytical probabilities to the numerical quadrature results.\n\nYour program must implement both the numerical projection by real-space integration and the analytical expression, and for each test case it must report four real-valued diagnostics:\n1) the partial normalization $\\sum_{n=0}^{n_{\\max}} P_n$ using the analytical expression,\n2) the mean vibrational quantum number $\\langle n\\rangle = \\left(\\sum_{n=0}^{n_{\\max}} n P_n\\right)\\big/\\left(\\sum_{n=0}^{n_{\\max}} P_n\\right)$ from the analytical expression,\n3) the analytical $P_{n^\\ast}$ for a specified target level $n^\\ast$,\n4) the maximum absolute difference $\\max_{0\\le n \\le \\min(n_{\\max},N_{\\mathrm{cmp}})} \\left|P_n^{\\mathrm{(analytic)}} - P_n^{\\mathrm{(numeric)}}\\right|$ between analytical and numerical probabilities, where $N_{\\mathrm{cmp}}$ is a small positive integer you choose to bound the numerical comparison cost.\n\nImportant implementation details and constraints:\n- Use the one-dimensional harmonic oscillator eigenfunctions from the TISE as an orthonormal basis. The initial state is the ground state centered at $x=0$. The final eigenstates are those of the same harmonic oscillator but centered at $x=\\Delta x$. Assume $m=1$ and $\\hbar=1$ throughout, so the harmonic length scale is set by $\\omega$.\n- The numerical quadrature must use a uniform real-space grid spanning a symmetric interval $[-L,L]$ that is wide enough to render truncation errors negligible for the reported diagnostics. The grid resolution must be sufficiently fine to resolve the largest $n$ you compare numerically. You may select $L$ and the number of grid points based on $\\omega$, $\\Delta x$, and $n_{\\max}$.\n- All outputs are dimensionless probabilities or moments thereof; therefore, no physical units are required in the output.\n- Round each reported float to $8$ decimal places before output.\n- Your program must not read any input; it must run as-is and print the required final output line.\n\nTest suite:\nFor each tuple $(\\omega,\\Delta x,n_{\\max},n^\\ast)$ below, compute and report the diagnostics described above, in the order specified.\n\n- Case A (general): $(\\omega=\\;1.0,\\;\\Delta x=\\;1.2,\\;n_{\\max}=\\;14,\\;n^\\ast=\\;5)$\n- Case B (boundary, zero displacement): $(\\omega=\\;1.0,\\;\\Delta x=\\;0.0,\\;n_{\\max}=\\;10,\\;n^\\ast=\\;3)$\n- Case C (edge, large displacement): $(\\omega=\\;0.5,\\;\\Delta x=\\;3.5,\\;n_{\\max}=\\;30,\\;n^\\ast=\\;3)$\n- Case D (second general): $(\\omega=\\;1.8,\\;\\Delta x=\\;0.9,\\;n_{\\max}=\\;18,\\;n^\\ast=\\;1)$\n\nFinal output format:\nYour program should produce a single line of output containing a comma-separated Python-style list with one element per test case, where each element is a list of the four rounded floats in the order described. For example, the output format must be\n[[sumA,meanA,PA,errA],[sumB,meanB,PB,errB],[sumC,meanC,PC,errC],[sumD,meanD,PD,errD]]\nwith no extra whitespace requirements beyond standard list formatting. The values themselves must be rounded to $8$ decimal places.", "solution": "The posed problem is subjected to rigorous validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- **Physical Model**: One-dimensional diatomic vibrational mode modeled by two harmonic oscillator potentials.\n- **Initial State**: Ground vibrational state, $\\psi_0^{(\\mathrm{initial})}(x)$, of a harmonic oscillator with potential $V_{\\mathrm{initial}}(x) = \\frac{1}{2} m \\omega^2 x^2$. The oscillator is centered at $x=0$.\n- **Final States**: Eigenstates, $\\psi_n^{(\\mathrm{final})}(x)$, of a harmonic oscillator with potential $V_{\\mathrm{final}}(x) = \\frac{1}{2} m \\omega^2 (x-\\Delta x)^2$. The oscillator has the same frequency $\\omega$ but is displaced by $\\Delta x$.\n- **Fundamental Principles**:\n    - The time-dependent Schrödinger equation (TDSE) and its implication for a \"sudden\" potential change (Franck-Condon principle), where the wavefunction is continuous at $t=0$.\n    - The time-independent Schrödinger equation (TISE) provides the orthonormal and complete set of harmonic oscillator eigenfunctions, $\\psi_n(x)$.\n- **Constants and Units**: Reduced units are employed, with mass $m=1$ and reduced Planck constant $\\hbar=1$.\n- **Tasks**:\n    1.  Derive the expression for projection coefficients (overlap integrals).\n    2.  Compute Franck-Condon factors, $P_n = \\left|\\langle \\psi_n^{(\\mathrm{final})} \\mid \\psi_0^{(\\mathrm{initial})}\\rangle\\right|^2$ for $n=0, 1, \\dots, n_{\\max}$, using numerical quadrature on a real-space grid.\n    3.  Derive and use a closed-form analytical expression for $P_n$ in terms of $\\omega$ and $\\Delta x$.\n    4.  Compare the analytical and numerical results.\n- **Required Outputs (Diagnostics)**: For each test case, report four values:\n    1.  Partial normalization: $\\sum_{n=0}^{n_{\\max}} P_n$ (analytical).\n    2.  Mean vibrational quantum number: $\\langle n\\rangle = \\left(\\sum_{n=0}^{n_{\\max}} n P_n\\right)\\big/\\left(\\sum_{n=0}^{n_{\\max}} P_n\\right)$ (analytical).\n    3.  Specific probability: $P_{n^\\ast}$ for a given $n^\\ast$ (analytical).\n    4.  Maximum absolute difference: $\\max_{0\\le n \\le \\min(n_{\\max},N_{\\mathrm{cmp}})} \\left|P_n^{\\mathrm{(analytic)}} - P_n^{\\mathrm{(numeric)}}\\right|$, where $N_{\\mathrm{cmp}}$ is a chosen integer.\n- **Implementation Constraints**: Use a uniform real-space grid $[-L, L]$ for numerical integration. Round all output floats to $8$ decimal places. The code must be self-contained.\n- **Test Cases**:\n    - A: $(\\omega=1.0, \\Delta x=1.2, n_{\\max}=14, n^\\ast=5)$\n    - B: $(\\omega=1.0, \\Delta x=0.0, n_{\\max}=10, n^\\ast=3)$\n    - C: $(\\omega=0.5, \\Delta x=3.5, n_{\\max}=30, n^\\ast=3)$\n    - D: $(\\omega=1.8, \\Delta x=0.9, n_{\\max}=18, n^\\ast=1)$\n\n### Step 2: Validate Using Extracted Givens\nThe problem is evaluated against the validation criteria.\n- **Scientifically Grounded**: The problem is fundamentally based on the Schrödinger equation, the quantum harmonic oscillator, and the Franck-Condon principle, which are standard, well-established concepts in quantum mechanics and computational chemistry. It is scientifically sound.\n- **Well-Posed**: The problem is well-posed. It specifies a clear physical model, asks for the calculation of uniquely defined quantities ($P_n$ and their moments), and provides all necessary parameters.\n- **Objective**: The problem is stated in objective, formal language, free of subjective or ambiguous terminology.\n- **Flaw Checklist**: The problem does not exhibit any of the defined flaws. It is not scientifically unsound, non-formalizable, incomplete, unrealistic, ill-posed, or unverifiable. The setup is a canonical textbook exercise in quantum dynamics.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be developed and presented.\n\n### Theoretical Foundation and Solution Derivation\nThe theoretical foundation of the Franck-Condon principle lies in the Born-Oppenheimer approximation and the time-dependent Schrödinger equation (TDSE). An electronic transition in a molecule occurs on a timescale much faster than nuclear motion. This is the \"sudden approximation.\" According to the TDSE, if the Hamiltonian changes suddenly, the system's wavefunction does not have time to change. Therefore, immediately after the transition at time $t=0$, the nuclear wavefunction is identical to the initial nuclear wavefunction, which we take to be the ground vibrational state of the initial electronic potential, $\\psi_0^{(\\mathrm{initial})}(x)$.\n\nThis state, $\\psi_0^{(\\mathrm{initial})}(x)$, is not, in general, an eigenstate of the new Hamiltonian, $H_{\\mathrm{final}}$. It is a superposition of the eigenstates of $H_{\\mathrm{final}}$, denoted $\\psi_n^{(\\mathrm{final})}(x)$. We can express the initial state in the basis of the final states:\n$$\n\\psi_0^{(\\mathrm{initial})}(x) = \\sum_{n=0}^{\\infty} c_n \\psi_n^{(\\mathrm{final})}(x)\n$$\nThe coefficients $c_n$ are the projection of the initial state onto the final eigenstates. Leveraging the orthonormality of the final eigenstates, $\\langle \\psi_m^{(\\mathrm{final})} | \\psi_n^{(\\mathrm{final})} \\rangle = \\delta_{mn}$, we find the coefficients by computing the overlap integral:\n$$\nc_n = \\langle \\psi_n^{(\\mathrm{final})} | \\psi_0^{(\\mathrm{initial})} \\rangle = \\int_{-\\infty}^{\\infty} \\left(\\psi_n^{(\\mathrm{final})}(x)\\right)^* \\psi_0^{(\\mathrm{initial})}(x) \\, dx\n$$\nThe probability of observing the molecule in the final vibrational state $n$ is the Franck-Condon factor, $P_n$, given by the squared magnitude of the projection coefficient:\n$$\nP_n = |c_n|^2 = |\\langle \\psi_n^{(\\mathrm{final})} | \\psi_0^{(\\mathrm{initial})} \\rangle|^2\n$$\nThe eigenfunctions $\\psi_n(x)$ are solutions to the time-independent Schrödinger equation (TISE) for the one-dimensional harmonic oscillator, $H\\psi_n = E_n\\psi_n$. With $m=1$ and $\\hbar=1$, the Hamiltonian is $H = -\\frac{1}{2}\\frac{d^2}{dx^2} + \\frac{1}{2}\\omega^2 (x-x_0)^2$. The normalized eigenfunctions are:\n$$\n\\psi_n(x; x_0, \\omega) = \\mathcal{N}_n H_n(\\alpha_c(x - x_0)) e^{-\\frac{1}{2}\\alpha_c^2 (x-x_0)^2}\n$$\nwhere $\\alpha_c = \\sqrt{\\omega}$, $H_n(y)$ are the physicists' Hermite polynomials, and the normalization constant is $\\mathcal{N}_n = \\left(\\frac{\\alpha_c}{\\sqrt{\\pi} 2^n n!}\\right)^{1/2}$.\nThe initial state is $\\psi_0^{(\\mathrm{initial})}(x) = \\psi_0(x; x_0=0, \\omega)$, and the final states are $\\psi_n^{(\\mathrm{final})}(x) = \\psi_n(x; x_0=\\Delta x, \\omega)$.\n\n**Analytical Solution**:\nThe overlap integral $\\langle \\psi_n^{(\\mathrm{final})} | \\psi_0^{(\\mathrm{initial})} \\rangle$ can be evaluated analytically. This is a standard result, often derived using ladder operators or the generating function for Hermite polynomials. The result is a Poisson distribution for the probabilities $P_n$:\n$$\nP_n = e^{-S} \\frac{S^n}{n!}\n$$\nHere, $S$ is the dimensionless Huang-Rhys factor, which represents the expected vibrational excitation quantum number. It is defined in terms of the displacement $\\Delta x$ and the oscillator frequency $\\omega$. In the specified reduced units ($m=1, \\hbar=1$):\n$$\nS = \\frac{\\omega (\\Delta x)^2}{2}\n$$\nThis analytical expression will be used to compute the first three diagnostics.\n\n**Numerical Solution**:\nA direct numerical evaluation of the overlap integral provides an independent method for calculating the Franck-Condon factors. The integral is approximated by a sum over a discrete real-space grid. Let the grid be defined by points $x_i$ over an interval $[-L, L]$ with a uniform spacing $\\Delta x_{\\mathrm{grid}}$. The overlap integral $c_n$ is computed using a numerical quadrature rule, such as the trapezoidal rule:\n$$\nc_n = \\int_{-L}^{L} \\psi_n(x; \\Delta x, \\omega) \\psi_0(x; 0, \\omega) \\, dx \\approx \\sum_{i} \\psi_n(x_i; \\Delta x, \\omega) \\psi_0(x_i; 0, \\omega) \\Delta x_{\\mathrm{grid}}\n$$\nThe numerical probability is then $P_n^{\\mathrm{(numeric)}} = |c_n|^2$. The grid parameters $L$ and the number of points must be chosen to be sufficiently large to ensure convergence, i.e., to minimize both truncation error (from the finite interval) and discretization error. For robustness across all test cases, a wide grid defined by $L=25$ and a fine resolution of $N_{\\text{points}}=16384$ are chosen.\n\n**Computational Diagnostics**:\nThe four required quantities are computed as follows:\n1.  **Partial Normalization**: The sum of analytical probabilities up to $n_{\\max}$: $\\sum_{n=0}^{n_{\\max}} P_n$. For a sufficiently large $n_{\\max}$ relative to the mean $S$, this sum should approach $1$.\n2.  **Mean Vibrational Quantum Number**: The mean of the truncated distribution: $\\langle n\\rangle = (\\sum_{n=0}^{n_{\\max}} n P_n) / (\\sum_{n=0}^{n_{\\max}} P_n)$. For large $n_{\\max}$, this should approach $S$.\n3.  **Specific Probability**: The analytical probability $P_{n^\\ast}$ for the target level $n^\\ast$.\n4.  **Maximum Absolute Difference**: The maximum discrepancy between the analytical and numerical probabilities over a limited set of states, $\\max_{0\\le n \\le \\min(n_{\\max},N_{\\mathrm{cmp}})} |P_n^{\\mathrm{(analytic)}} - P_n^{\\mathrm{(numeric)}}|$. For the comparison, a practical upper limit of $N_{\\mathrm{cmp}}=10$ is chosen. This serves as a verification of the numerical implementation against the exact analytical solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hermite, factorial\n\ndef solve():\n    \"\"\"\n    Main solver function to compute and print Franck-Condon analysis results.\n    \"\"\"\n    \n    test_cases = [\n        # (omega, delta_x, n_max, n_star)\n        (1.0, 1.2, 14, 5),   # Case A\n        (1.0, 0.0, 10, 3),   # Case B\n        (0.5, 3.5, 30, 3),   # Case C\n        (1.8, 0.9, 18, 1),   # Case D\n    ]\n\n    all_results = []\n    for case in test_cases:\n        omega, delta_x, n_max, n_star = case\n        diagnostics = compute_diagnostics(omega, delta_x, n_max, n_star)\n        rounded_diagnostics = [round(d, 8) for d in diagnostics]\n        all_results.append(rounded_diagnostics)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a Python list of lists.\n    # The problem description's code template implies a no-space compact format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\n\ndef ho_wavefunction(n: int, x: np.ndarray, omega: float, x0: float = 0.0) - np.ndarray:\n    \"\"\"\n    Computes the 1D quantum harmonic oscillator wavefunction psi_n(x).\n    Units are reduced: m=1, hbar=1.\n    \n    Args:\n        n: Vibrational quantum number.\n        x: Coordinate array.\n        omega: Angular frequency.\n        x0: Center of the potential.\n        \n    Returns:\n        An array of wavefunction values at each point in x.\n    \"\"\"\n    # Defensive check for factorial domain\n    if n  0:\n        raise ValueError(\"Quantum number n must be non-negative.\")\n    \n    # Pre-calculate constants to avoid re-computation\n    alpha_c = np.sqrt(omega) # alpha_c = sqrt(m*omega/hbar) with m=1, hbar=1\n    \n    # Normalization constant N_n = (alpha_c / (sqrt(pi) * 2^n * n!))^(1/2)\n    # N_n = (omega/pi)^(1/4) * (2^n * n!)^(-1/2)\n    try:\n        fact_n = factorial(n)\n        if np.isinf(fact_n):\n             # For very large n, use log-gamma, but for n=30, this path is not taken.\n             # This is a safeguard not strictly needed for the problem's n_max.\n             log_norm_factor = 0.25 * np.log(omega / np.pi) - 0.5 * (n * np.log(2) + np.log(fact_n))\n             norm_factor = np.exp(log_norm_factor)\n        else:\n             norm_factor = (omega / np.pi)**0.25 / np.sqrt(2**n * fact_n)\n    except (ValueError, OverflowError):\n        # Fallback for very large n, not triggered by test cases\n        log_fact_n = np.log(factorial(n)) if n  1 else 0.0\n        log_norm_factor = 0.25 * np.log(omega/np.pi) - 0.5 * (n * np.log(2) + log_fact_n)\n        norm_factor = np.exp(log_norm_factor)\n\n    # Argument for Hermite polynomial and Gaussian\n    arg = alpha_c * (x - x0)\n    \n    # Physicists' Hermite polynomials from SciPy\n    H_n_poly = hermite(n)\n    H_n_vals = H_n_poly(arg)\n    \n    # Gaussian part of the wavefunction\n    gaussian_part = np.exp(-0.5 * arg**2)\n    \n    return norm_factor * H_n_vals * gaussian_part\n\n\ndef compute_diagnostics(omega: float, delta_x: float, n_max: int, n_star: int) - list:\n    \"\"\"\n    Computes the four required diagnostics for a given test case.\n    \n    Args:\n        omega: Angular frequency.\n        delta_x: Displacement of the final potential.\n        n_max: Maximum vibrational quantum number for sums.\n        n_star: Target vibrational level for specific probability.\n        \n    Returns:\n        A list of four float values: [partial_norm, mean_n, p_n_star, max_abs_diff].\n    \"\"\"\n    \n    # --- 1. Analytical Calculations ---\n    \n    # Huang-Rhys factor S = omega * (delta_x)^2 / 2\n    S = 0.5 * omega * delta_x**2\n    \n    p_analytic = np.zeros(n_max + 1)\n    if S == 0.0:\n        p_analytic[0] = 1.0 # P_n = delta_{n,0}\n    else:\n        # Use iterative method P_n = P_{n-1} * S / n to avoid large S^n and n!\n        p_analytic[0] = np.exp(-S)\n        for n in range(1, n_max + 1):\n            p_analytic[n] = p_analytic[n - 1] * S / n\n\n    # Diagnostic 1: Partial normalization\n    partial_norm = np.sum(p_analytic)\n    \n    # Diagnostic 2: Mean vibrational quantum number\n    n_vals = np.arange(n_max + 1)\n    # Handle division by zero if partial_norm is zero (though unlikely here)\n    if partial_norm  1e-12:\n        mean_n = np.sum(n_vals * p_analytic) / partial_norm\n    else:\n        mean_n = 0.0\n\n    # Diagnostic 3: Analytical P_n*\n    if n_star  n_max:\n        # If n* is out of range, calculate it anway if possible\n        if S == 0.0:\n             p_n_star = 0.0\n        else:\n             p_n_star = np.exp(-S) * (S**n_star) / factorial(n_star)\n    else:\n        p_n_star = p_analytic[n_star]\n\n    # --- 2. Numerical Calculations and Comparison ---\n    \n    # Define a robust real-space grid\n    L = 25.0\n    N_points = 16384\n    x_grid, dx_grid = np.linspace(-L, L, N_points, retstep=True)\n    \n    # Initial state wavefunction (ground state at x0=0)\n    psi0_initial = ho_wavefunction(0, x_grid, omega, x0=0.0)\n    \n    # Diagnostic 4: Maximum absolute difference\n    max_abs_diff = 0.0\n    N_cmp = 10  # Upper limit for numerical comparison as chosen in the design\n    \n    for n in range(min(n_max, N_cmp) + 1):\n        # Final state wavefunction (n-th state at x0=delta_x)\n        psin_final = ho_wavefunction(n, x_grid, omega, x0=delta_x)\n        \n        # Calculate overlap integral using trapezoidal rule\n        integrand = psin_final * psi0_initial  # Wavefunctions are real\n        overlap = np.trapz(integrand, x=x_grid)\n        \n        # Numerical probability\n        p_numeric = np.abs(overlap)**2\n        \n        # Compare with analytical probability\n        diff = np.abs(p_analytic[n] - p_numeric)\n        if diff  max_abs_diff:\n            max_abs_diff = diff\n            \n    return [partial_norm, mean_n, p_n_star, max_abs_diff]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2466142"}]}