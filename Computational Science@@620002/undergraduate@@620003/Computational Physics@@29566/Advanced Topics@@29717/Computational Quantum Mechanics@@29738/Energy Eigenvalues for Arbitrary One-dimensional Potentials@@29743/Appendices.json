{"hands_on_practices": [{"introduction": "A cornerstone of computational quantum mechanics is the transformation of the continuous Schrödinger equation into a discrete matrix eigenvalue problem. In this exercise, you will implement this fundamental \"matrix method\" by discretizing the kinetic energy operator using finite differences and representing the potential on a grid. This approach allows you to directly compute the energy spectrum and wavefunctions for a particle in a \"W\"-shaped potential, providing a robust framework for solving for energy eigenvalues in arbitrary one-dimensional wells [@problem_id:2388919]. You will also explore the elegant connection between the symmetry of the potential and the parity of the resulting wavefunctions.", "problem": "You are asked to compute low-lying energy eigenvalues and diagnose the symmetry of the corresponding eigenfunctions for a one-dimensional quantum particle moving in a double-well potential that resembles the letter “W.” The goal is to implement a numerical procedure starting from the time-independent Schrödinger equation and to design a program that outputs clearly specified, quantitative results for a small test suite of parameter values.\n\nBegin from the time-independent Schrödinger equation for a particle of mass $m$ and reduced Planck constant $\\hbar$,\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2 \\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\nand work in dimensionless units where $\\hbar^2/(2m) = 1$, so the equation becomes\n$$\n-\\,\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\nImpose homogeneous Dirichlet boundary conditions $\\psi(-L)=\\psi(L)=0$ on a finite domain $x\\in[-L,L]$ that is sufficiently large so the bound-state wavefunctions decay to negligible values at the boundaries. Construct a uniform grid on $[-L,L]$ and derive a discrete matrix eigenvalue problem using a standard central-difference approximation for the second derivative. Solve the resulting symmetric tridiagonal matrix eigenproblem to obtain the lowest few eigenvalues $E$ and corresponding normalized eigenvectors $\\psi$. Ensure that the numerical method is stable and converged for the given parameters.\n\nDefine the “W”-shaped potential as a quartic double-well with an optional small linear tilt,\n$$\nV(x) = a\\,(x^2 - b^2)^2 + \\varepsilon\\,x,\n$$\nwhich has two minima at $x=\\pm b$ for $\\varepsilon=0$ and a central barrier at $x=0$. Use a symmetric grid about $x=0$ so that parity can be tested directly.\n\nTo analyze the symmetry of each eigenfunction $\\psi(x)$, characterize it by the expectation value of the parity operator $\\hat{P}$ defined by $(\\hat{P}\\psi)(x)=\\psi(-x)$, namely\n$$\n\\langle \\hat{P} \\rangle = \\frac{\\int_{-L}^{L}\\psi(x)\\,\\psi(-x)\\,dx}{\\int_{-L}^{L}|\\psi(x)|^2\\,dx}.\n$$\nFor a perfectly even eigenfunction, $\\langle \\hat{P} \\rangle = +1$, for a perfectly odd eigenfunction, $\\langle \\hat{P} \\rangle = -1$, and for symmetry-broken states, $\\langle \\hat{P} \\rangle$ will deviate from $\\pm 1$. On a uniform grid with symmetric nodes and normalized eigenvectors, approximate this expectation value by the discrete inner product of the eigenvector with its reversed copy, appropriately normalized.\n\nAll energies must be reported in the chosen dimensionless units where $\\hbar^2/(2m)=1$, and all final numerical results must be rounded to $6$ decimal places.\n\nImplement a complete program that:\n1. Builds the tridiagonal Hamiltonian matrix corresponding to the discretized operator $-\\,d^2/dx^2 + V(x)$ on the interior grid points with homogeneous Dirichlet boundary conditions at $x=\\pm L$.\n2. Computes the lowest $4$ eigenvalues and normalized eigenvectors.\n3. Computes the parity expectation values $\\langle \\hat{P} \\rangle$ for these $4$ eigenvectors as described above.\n4. Produces a single line of output aggregating the results for each test case in the specified format.\n\nUse the following three test cases, each with the same numerical discretization parameters:\n- Domain half-length $L = 6$, number of interior grid points $N = 1200$ (uniform grid on $[-L, L]$, excluding the boundaries in the discrete operator).\n- Potential parameters $(a,b,\\varepsilon)$:\n  1. $(a,b,\\varepsilon)=(1.0,\\,1.0,\\,0.0)$, symmetric double well.\n  2. $(a,b,\\varepsilon)=(1.0,\\,1.0,\\,0.05)$, weakly tilted double well.\n  3. $(a,b,\\varepsilon)=(0.5,\\,1.5,\\,0.0)$, wider and softer symmetric double well.\n\nFor each test case, your program must compute the lowest $4$ energies and the corresponding $4$ parity expectation values. Round all reported numbers to $6$ decimal places. Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list containing first the $4$ energies followed by the $4$ parity expectation values, for example:\n[[E0,E1,E2,E3,P0,P1,P2,P3],[...for case 2...],[...for case 3...]]\nwhere each $E_k$ and $P_k$ is a floating-point number rounded to $6$ decimals. All energies are in the dimensionless units defined by $\\hbar^2/(2m)=1$.", "solution": "We begin from the time-independent Schrödinger equation for a one-dimensional particle,\n$$\n-\\frac{\\hbar^2}{2m}\\frac{d^2 \\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\nAdopting the dimensionless convention $\\hbar^2/(2m)=1$, this reduces to\n$$\n-\\,\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\nWe confine the computation to a finite domain $x\\in[-L,L]$ and impose homogeneous Dirichlet boundary conditions $\\psi(-L)=\\psi(L)=0$. The bound-state wavefunctions of sufficiently confining potentials decay rapidly, so choosing $L$ large ensures negligible boundary error.\n\nTo discretize, we place a uniform grid of $N$ interior points on $[-L,L]$, excluding the endpoints to enforce $\\psi(\\pm L)=0$ directly. Let the grid spacing be $\\Delta x = 2L/(N+1)$, and let the interior nodes be\n$$\nx_i = -L + i\\,\\Delta x,\\quad i=1,2,\\dots,N.\n$$\nUsing the standard central-difference (second-order accurate) approximation for the second derivative,\n$$\n\\psi''(x_i) \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2},\n$$\nthe differential operator $-\\,d^2/dx^2$ maps to a tridiagonal matrix with main diagonal entries $2/(\\Delta x)^2$ and off-diagonal entries $-1/(\\Delta x)^2$. The potential $V(x)$ contributes additively to the main diagonal as $V(x_i)$. Thus, the discrete Hamiltonian acting on the vector $\\boldsymbol{\\psi} = (\\psi_1,\\dots,\\psi_N)^\\top$ is the $N\\times N$ symmetric tridiagonal matrix\n$$\nH = T + U,\\quad T = \\frac{1}{(\\Delta x)^2}\\,\\mathrm{tridiag}(-1,\\,2,\\,-1),\\quad U=\\mathrm{diag}\\big(V(x_1),\\dots,V(x_N)\\big).\n$$\nThe discrete eigenproblem\n$$\nH\\,\\boldsymbol{\\psi} = E\\,\\boldsymbol{\\psi}\n$$\napproximates the continuum bound-state problem. Because $H$ is real symmetric and strictly diagonally dominant for confining $V(x)$, its spectrum is real and the lowest eigenpairs approximate the true energies and eigenfunctions. We compute the lowest $4$ eigenvalues using a tridiagonal eigensolver to obtain efficiency and numerical stability.\n\nWe choose the “W”-shaped potential as\n$$\nV(x) = a\\,(x^2 - b^2)^2 + \\varepsilon\\,x,\n$$\nwith parameters $(a,b,\\varepsilon)$ specified per test case. For $\\varepsilon=0$, the potential is even and supports eigenfunctions of definite parity (even or odd). For $\\varepsilon\\neq 0$, parity symmetry is broken and the eigenfunctions are neither purely even nor purely odd.\n\nTo quantify symmetry, we compute the expectation value of the parity operator $\\hat{P}$ defined by $(\\hat{P}\\psi)(x)=\\psi(-x)$:\n$$\n\\langle \\hat{P} \\rangle = \\frac{\\int_{-L}^{L} \\psi(x)\\,\\psi(-x)\\,dx}{\\int_{-L}^{L}|\\psi(x)|^2\\,dx}.\n$$\nOn a symmetric, uniform grid with nodes $\\{x_i\\}_{i=1}^N$ and normalized eigenvector components $\\{\\psi_i\\}_{i=1}^N$ in the Euclidean sense (so that $\\sum_i |\\psi_i|^2 = 1$), the discrete approximation uses the reversed index to implement $x\\mapsto -x$. Because both numerator and denominator carry the same uniform quadrature weight $\\Delta x$, the factor cancels in the ratio. Therefore, we compute\n$$\n\\langle \\hat{P} \\rangle \\approx \\sum_{i=1}^{N} \\psi_i\\,\\psi_{N+1-i},\n$$\nwhich equals $+1$ for an exactly even state, $-1$ for an exactly odd state, and deviates towards $0$ as symmetry is progressively broken or as numerical errors accumulate. The eigenvectors returned by standard symmetric eigensolvers are orthonormal in the Euclidean norm, ensuring the denominator is $1$.\n\nAlgorithm summary:\n1. Select $L$ and $N$; compute $\\Delta x = 2L/(N+1)$ and interior grid points $x_i$.\n2. For each test case, evaluate $V(x_i)$ and assemble the main diagonal $d_i = 2/(\\Delta x)^2 + V(x_i)$ and the off-diagonal elements $e_i = -1/(\\Delta x)^2$.\n3. Use a tridiagonal symmetric eigensolver to compute the lowest $4$ eigenpairs $\\{(E_k,\\boldsymbol{\\psi}^{(k)})\\}_{k=0}^3$.\n4. For each eigenvector, compute the parity expectation $\\langle \\hat{P} \\rangle_k \\approx \\sum_i \\psi^{(k)}_i \\psi^{(k)}_{N+1-i}$.\n5. Round all $E_k$ and $\\langle \\hat{P} \\rangle_k$ to $6$ decimal places.\n6. Output a single line with a list of three lists, one for each test case, in the format [E0,E1,E2,E3,P0,P1,P2,P3] for each case.\n\nNumerical parameters and test suite:\n- Use $L=6$ and $N=1200$ for all cases.\n- Three potentials $(a,b,\\varepsilon)$:\n  1. $(1.0,\\,1.0,\\,0.0)$ symmetric double well.\n  2. $(1.0,\\,1.0,\\,0.05)$ weakly tilted well.\n  3. $(0.5,\\,1.5,\\,0.0)$ symmetric, wider wells.\n\nAll outputs are dimensionless energies and parity expectations in the units where $\\hbar^2/(2m)=1$, rounded to $6$ decimals. The final program constructs the Hamiltonian, solves for the lowest $4$ eigenpairs, computes parity diagnostics, and prints the results as a single line in the specified aggregated format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Execution environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef compute_spectrum_and_parity(a, b, eps, L=6.0, N=1200, k=4):\n    # Uniform grid setup: N interior points between -L and L\n    dx = 2.0 * L / (N + 1)\n    x = np.linspace(-L + dx, L - dx, N)\n\n    # Define the W-shaped double-well potential with optional tilt\n    V = a * (x**2 - b**2)**2 + eps * x\n\n    # Build tridiagonal Hamiltonian H = T + V:\n    # T main diagonal: 2/dx^2, off-diagonals: -1/dx^2\n    t_main = (2.0 / dx**2) * np.ones(N)\n    t_off = (-1.0 / dx**2) * np.ones(N - 1)\n\n    # Add potential to main diagonal\n    d = t_main + V\n    e = t_off\n\n    # Solve for the lowest k eigenpairs of the symmetric tridiagonal matrix\n    # eigh_tridiagonal returns eigenvalues in ascending order\n    w, v = eigh_tridiagonal(d, e, select='i', select_range=(0, k - 1))\n\n    # Ensure eigenvectors are column-wise (N x k). eigh_tridiagonal guarantees this.\n    # Compute parity expectation <P> = sum_i psi_i * psi_{N+1-i}\n    # Since eigenvectors are Euclidean-normalized (sum psi_i^2 = 1), no extra normalization factor needed.\n    parities = []\n    for j in range(k):\n        vec = v[:, j]\n        p = float(np.dot(vec, vec[::-1]))\n        parities.append(p)\n\n    # Round results to 6 decimals as required\n    energies_rounded = [float(f\"{val:.6f}\") for val in w]\n    parities_rounded = [float(f\"{val:.6f}\") for val in parities]\n\n    # Return combined list [E0,E1,E2,E3,P0,P1,P2,P3]\n    return energies_rounded + parities_rounded\n\ndef solve():\n    # Define the test cases from the problem statement: (a, b, eps)\n    test_cases = [\n        (1.0, 1.0, 0.0),   # symmetric double well\n        (1.0, 1.0, 0.05),  # weakly tilted well\n        (0.5, 1.5, 0.0),   # wider, softer symmetric double well\n    ]\n\n    # Fixed numerical parameters\n    L = 6.0\n    N = 1200\n    k = 4\n\n    results = []\n    for a, b, eps in test_cases:\n        res = compute_spectrum_and_parity(a, b, eps, L=L, N=N, k=k)\n        results.append(res)\n\n    # Format the final output exactly as a single line of comma-separated lists.\n    # Each inner list: [E0,E1,E2,E3,P0,P1,P2,P3], numbers rounded to 6 decimals.\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n\n    output = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2388919"}, {"introduction": "Beyond matrix diagonalization, the \"shooting method\" offers a powerful and intuitive alternative for finding energy eigenvalues. This technique reframes the eigenvalue problem as a boundary value problem, where you \"shoot\" a solution from an initial point with a trial energy, aiming to hit a target boundary condition far away. This practice guides you through implementing the shooting method using a Runge-Kutta integrator for the Schrödinger equation and a secant method root-finder to converge on the correct energy eigenvalues for an anharmonic oscillator [@problem_id:2422745]. Mastering this technique adds a versatile tool for solving second-order ODEs to your computational repertoire.", "problem": "Consider the one-dimensional, time-independent Schrödinger equation for a particle of mass $m$ moving in the anharmonic potential $V(x) = \\tfrac{1}{2} m \\omega^2 x^2 + \\tfrac{1}{4} \\lambda x^4$. The fundamental law is\n$$\n-\\frac{\\hbar^2}{2 m} \\frac{d^2 \\psi}{d x^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\nwhere $\\hbar$ is the reduced Planck constant, $\\psi(x)$ is the bound-state wavefunction, and $E$ is the energy eigenvalue. Adopt the standard harmonic oscillator scales for nondimensionalization: length $x_0 = \\sqrt{\\hbar/(m \\omega)}$ and energy $E_0 = \\hbar \\omega$. Define the dimensionless coordinate $\\xi = x / x_0$, the dimensionless energy $\\varepsilon = E / E_0$, and the dimensionless anharmonicity parameter $\\alpha = \\lambda \\hbar /(m^2 \\omega^3)$. Show that the Schrödinger equation reduces to the dimensionless form\n$$\n-\\frac{1}{2}\\,\\frac{d^2 \\psi}{d \\xi^2} + \\left(\\tfrac{1}{2}\\,\\xi^2 + \\tfrac{1}{4}\\,\\alpha\\,\\xi^4\\right)\\psi(\\xi) = \\varepsilon\\,\\psi(\\xi),\n$$\nand equivalently to the initial-value form\n$$\n\\frac{d \\psi}{d \\xi} = \\phi,\\qquad \\frac{d \\phi}{d \\xi} = \\left(\\xi^2 + \\tfrac{1}{2}\\,\\alpha\\,\\xi^4 - 2 \\varepsilon\\right)\\psi,\n$$\nwhere $\\phi = d\\psi/d\\xi$.\n\nUse the physical parity of bound states in an even potential to set initial conditions at $\\xi = 0$. For the lowest even state, impose $\\psi(0) = 1$ and $\\phi(0) = 0$. For the lowest odd state, impose $\\psi(0) = 0$ and $\\phi(0) = 1$. In both cases, the overall normalization is arbitrary and does not affect the energy eigenvalue.\n\nYour task is to compute the two lowest bound-state energies, namely the lowest even state and the lowest odd state, by implementing a shooting method that treats $\\varepsilon$ as an unknown parameter and uses an open root-finding scheme to enforce the boundary condition at a finite domain cutoff. Specifically:\n\n- Integrate from $\\xi = 0$ to a finite boundary $\\xi = L$ with $L = 10$ using a fixed uniform step size $h = 0.005$ on the system above. Use a standard, explicit numerical integrator that respects smoothness (for example, a fourth-order Runge–Kutta scheme) to produce $\\psi(L;\\varepsilon)$ for a given trial $\\varepsilon$ and parity.\n- Define the shooting residual as $F(\\varepsilon) = \\psi(L;\\varepsilon)$ for the given parity. The correct eigenvalue satisfies $F(\\varepsilon) = 0$, since a normalizable bound state decays so that $\\psi$ is negligibly small at a sufficiently large but finite $L$.\n- Use an open root-finding method, specifically the secant method (which uses only function values), to solve $F(\\varepsilon) = 0$ for $\\varepsilon$. Do not use bracketing methods. Terminate the secant iteration when either $|\\Delta \\varepsilon| < 10^{-10}$ or $|F(\\varepsilon)| < 10^{-8}$, or when a maximum of $50$ iterations is reached.\n\nReport all energies in the nondimensional unit $E_0 = \\hbar \\omega$, that is, report $\\varepsilon$ directly. Round each reported energy to $6$ decimal places.\n\nTest suite and coverage:\n- Use the following three parameter sets $(m,\\omega,\\lambda)$ to define $\\alpha = \\lambda \\hbar /(m^2 \\omega^3)$ under the nondimensionalization with $\\hbar = 1$.\n  - Case A (harmonic limit, boundary case): $(m,\\omega,\\lambda) = (1,1,0)$.\n  - Case B (weak anharmonicity, happy path): $(m,\\omega,\\lambda) = (1,1,0.2)$.\n  - Case C (moderate anharmonicity): $(m,\\omega,\\lambda) = (1,1,0.5)$.\nFor each case, compute and return the lowest even-state energy and the lowest odd-state energy in units of $E_0$. Thus the program produces $2$ numbers per case, for a total of $6$ numbers.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: [even_A, odd_A, even_B, odd_B, even_C, odd_C], where each entry is the corresponding computed $\\varepsilon$ rounded to $6$ decimal places.\n- No other output is permitted.", "solution": "The problem presented is a standard, well-posed exercise in computational quantum mechanics. It is scientifically sound, internally consistent, and contains all necessary information for a unique solution to be determined. The initial task is to validate the provided nondimensionalization of the time-independent Schrödinger equation. I shall proceed with this derivation first, before detailing the numerical solution.\n\n**1. Nondimensionalization of the Schrödinger Equation**\n\nThe starting point is the one-dimensional, time-independent Schrödinger equation for a particle of mass $m$ in the potential $V(x)$:\n$$\n-\\frac{\\hbar^2}{2m} \\frac{d^2 \\psi}{d x^2} + \\left(\\frac{1}{2} m \\omega^2 x^2 + \\frac{1}{4} \\lambda x^4\\right)\\psi(x) = E\\,\\psi(x)\n$$\nWe are given the characteristic scales for length, $x_0 = \\sqrt{\\hbar/(m \\omega)}$, and energy, $E_0 = \\hbar \\omega$. We introduce the dimensionless variables $\\xi = x/x_0$ and $\\varepsilon = E/E_0$.\n\nThe chain rule gives the transformation for the derivatives:\n$$\n\\frac{d}{dx} = \\frac{d\\xi}{dx} \\frac{d}{d\\xi} = \\frac{1}{x_0} \\frac{d}{d\\xi}\n$$\n$$\n\\frac{d^2}{dx^2} = \\frac{d}{dx}\\left(\\frac{1}{x_0} \\frac{d}{d\\xi}\\right) = \\frac{1}{x_0^2} \\frac{d^2}{d\\xi^2}\n$$\nSubstituting $x = \\xi x_0$, $E = \\varepsilon E_0$, and the second derivative into the original equation yields:\n$$\n-\\frac{\\hbar^2}{2m} \\left(\\frac{1}{x_0^2} \\frac{d^2 \\psi}{d\\xi^2}\\right) + \\left(\\frac{1}{2} m \\omega^2 (x_0 \\xi)^2 + \\frac{1}{4} \\lambda (x_0 \\xi)^4\\right)\\psi = (\\varepsilon E_0)\\psi\n$$\nTo simplify, we divide the entire equation by the energy scale $E_0 = \\hbar \\omega$:\n$$\n-\\frac{\\hbar^2}{2m E_0 x_0^2} \\frac{d^2 \\psi}{d\\xi^2} + \\left(\\frac{m \\omega^2 x_0^2}{2 E_0} \\xi^2 + \\frac{\\lambda x_0^4}{4 E_0} \\xi^4\\right)\\psi = \\varepsilon\\psi\n$$\nNow, we evaluate the coefficients using the definitions of $x_0$ and $E_0$:\n- Coefficient of the second derivative term:\n$$\n-\\frac{\\hbar^2}{2m (\\hbar\\omega) (\\hbar/(m\\omega))} = -\\frac{\\hbar^2 m \\omega}{2m \\hbar^2 \\omega} = -\\frac{1}{2}\n$$\n- Coefficient of the $\\xi^2$ term:\n$$\n\\frac{m \\omega^2 (\\hbar/(m\\omega))}{2 (\\hbar\\omega)} = \\frac{m \\omega^2 \\hbar}{2 m \\omega \\hbar \\omega} = \\frac{1}{2}\n$$\n- Coefficient of the $\\xi^4$ term:\n$$\n\\frac{\\lambda x_0^4}{4 E_0} = \\frac{\\lambda (\\hbar/(m\\omega))^2}{4 (\\hbar\\omega)} = \\frac{\\lambda \\hbar^2}{4 m^2 \\omega^2 \\hbar \\omega} = \\frac{\\lambda \\hbar}{4 m^2 \\omega^3} = \\frac{1}{4} \\alpha\n$$\nwhere $\\alpha = \\lambda \\hbar / (m^2 \\omega^3)$ is the dimensionless anharmonicity parameter.\n\nAssembling these coefficients, we arrive at the required dimensionless equation, which is hereby validated:\n$$\n-\\frac{1}{2}\\,\\frac{d^2 \\psi}{d \\xi^2} + \\left(\\frac{1}{2}\\,\\xi^2 + \\frac{1}{4}\\,\\alpha\\,\\xi^4\\right)\\psi(\\xi) = \\varepsilon\\,\\psi(\\xi)\n$$\nTo convert this second-order ordinary differential equation (ODE) into a system of first-order ODEs, we first isolate the second derivative:\n$$\n\\frac{d^2 \\psi}{d \\xi^2} = 2 \\left(\\frac{1}{2}\\,\\xi^2 + \\frac{1}{4}\\,\\alpha\\,\\xi^4 - \\varepsilon\\right)\\psi = \\left(\\xi^2 + \\frac{1}{2}\\,\\alpha\\,\\xi^4 - 2\\varepsilon\\right)\\psi\n$$\nBy defining $\\phi(\\xi) = d\\psi/d\\xi$, we obtain the system:\n$$\n\\frac{d\\psi}{d\\xi} = \\phi(\\xi)\n$$\n$$\n\\frac{d\\phi}{d\\xi} = \\left(\\xi^2 + \\frac{1}{2}\\,\\alpha\\,\\xi^4 - 2\\varepsilon\\right)\\psi(\\xi)\n$$\nThis system is also validated.\n\n**2. Numerical Methodology**\n\nThe problem is to find the energy eigenvalues $\\varepsilon$ for which the wavefunction $\\psi(\\xi)$ is physically admissible, meaning it is normalizable. This requires that $\\psi(\\xi) \\to 0$ as $\\xi \\to \\pm\\infty$. The problem is solved using the shooting method.\n\nThe potential $V(x)$ is an even function, so its eigenfunctions must have definite parity (either even or odd). We can exploit this symmetry by integrating from $\\xi=0$ outwards.\n- For **even states**, $\\psi(-\\xi) = \\psi(\\xi)$, which implies the derivative at the origin is zero: $\\phi(0) = d\\psi/d\\xi|_{\\xi=0} = 0$. We can set $\\psi(0) = 1$ due to the linearity of the Schrödinger equation.\n- For **odd states**, $\\psi(-\\xi) = -\\psi(\\xi)$, which implies $\\psi(0)=0$. To obtain a non-trivial solution, we must have a non-zero slope, so we set the derivative $\\phi(0) = 1$.\n\nThe shooting method consists of treating the energy $\\varepsilon$ as a variable parameter. For a trial value of $\\varepsilon$, we solve the initial value problem from $\\xi=0$ up to a sufficiently large boundary $\\xi=L$. The physical condition $\\psi(\\xi \\to \\infty) = 0$ is approximated by the numerical condition $\\psi(L) = 0$. We therefore define a residual function $F(\\varepsilon) = \\psi(L; \\varepsilon)$, and the problem reduces to finding the roots of $F(\\varepsilon) = 0$.\n\nThe algorithm is as follows:\n1.  **Define the ODE system**: A function will represent the right-hand side of the first-order system for a state vector $\\mathbf{y} = [\\psi, \\phi]^T$.\n    $$ \\frac{d\\mathbf{y}}{d\\xi} = f(\\xi, \\mathbf{y}; \\varepsilon, \\alpha) = \\begin{bmatrix} \\phi \\\\ (\\xi^2 + \\frac{1}{2}\\alpha\\xi^4 - 2\\varepsilon)\\psi \\end{bmatrix} $$\n2.  **Integrate the ODEs**: The problem requires an explicit numerical integrator. A standard fourth-order Runge-Kutta (RK4) method is appropriate and will be implemented. Starting with the initial state $\\mathbf{y}(0)$ based on the desired parity, the system is integrated from $\\xi=0$ to $\\xi=L=10$ with a step size of $h=0.005$. The result of this integration is the value of $\\psi(L)$ for the chosen $\\varepsilon$. This function $\\varepsilon \\mapsto \\psi(L; \\varepsilon)$ is our shooting function $F(\\varepsilon)$.\n3.  **Find the Root**: The problem specifies using the secant method, an open root-finding scheme, to solve $F(\\varepsilon) = 0$. Given two initial guesses for the energy, $\\varepsilon_{k-1}$ and $\\varepsilon_k$, the next approximation $\\varepsilon_{k+1}$ is found by the recurrence relation:\n    $$ \\varepsilon_{k+1} = \\varepsilon_k - F(\\varepsilon_k) \\frac{\\varepsilon_k - \\varepsilon_{k-1}}{F(\\varepsilon_k) - F(\\varepsilon_{k-1})} $$\n    The iteration proceeds until one of the specified convergence criteria is met: $|\\varepsilon_{k+1} - \\varepsilon_k| < 10^{-10}$, $|F(\\varepsilon_{k+1})| < 10^{-8}$, or a maximum of $50$ iterations is exceeded. The initial guesses for $\\varepsilon$ must be chosen judiciously. For the harmonic case ($\\alpha=0$), the exact eigenvalues are $\\varepsilon_n = n + 1/2$. The lowest even state corresponds to $n=0$ ($\\varepsilon_0=0.5$) and the lowest odd state to $n=1$ ($\\varepsilon_1=1.5$). These values serve as excellent starting points for our guesses. For $\\alpha > 0$, the potential well becomes steeper, which increases the energy levels. Therefore, initial guesses for the anharmonic cases should be chosen to be slightly higher than their harmonic counterparts.\n\n4.  **Compute for All Cases**: The entire procedure is repeated for each of the three values of $\\alpha$ derived from the test cases, and for both even and odd parity, to find the six required energy eigenvalues.\n\nThe implementation will consist of a main driver function that loops through the parameter sets and parities. This function will call a secant method solver, which in turn will repeatedly call an RK4 integration routine to evaluate the shooting function $F(\\varepsilon)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the two lowest bound-state energies for an anharmonic oscillator\n    using a shooting method with a secant root-finder.\n    \"\"\"\n    \n    # Problem Constants\n    L = 10.0\n    h = 0.005\n    \n    # Secant Method Parameters\n    MAX_ITER = 50\n    TOL_EPS = 1e-10\n    TOL_F = 1e-8\n\n    def get_derivatives(xi, state, epsilon, alpha):\n        \"\"\"\n        Computes the derivatives for the ODE system.\n        state = [psi, phi], where phi = d(psi)/d(xi)\n        \"\"\"\n        psi, phi = state\n        d_psi_d_xi = phi\n        d_phi_d_xi = (xi**2 + 0.5 * alpha * xi**4 - 2.0 * epsilon) * psi\n        return np.array([d_psi_d_xi, d_phi_d_xi])\n\n    def solve_ode_rk4(initial_state, epsilon, alpha):\n        \"\"\"\n        Solves the ODE system from xi=0 to xi=L using RK4.\n        Returns the final value of psi(L).\n        This is the shooting function F(epsilon).\n        \"\"\"\n        state = np.array(initial_state, dtype=float)\n        num_steps = int(L / h)\n        \n        for i in range(num_steps):\n            xi = i * h\n            \n            k1 = h * get_derivatives(xi, state, epsilon, alpha)\n            k2 = h * get_derivatives(xi + 0.5 * h, state + 0.5 * k1, epsilon, alpha)\n            k3 = h * get_derivatives(xi + 0.5 * h, state + 0.5 * k2, epsilon, alpha)\n            k4 = h * get_derivatives(xi + h, state + k3, epsilon, alpha)\n            \n            state += (k1 + 2.0 * k2 + 2.0 * k3 + k4) / 6.0\n            \n        return state[0] # Return psi(L)\n\n    def find_energy_secant(initial_state, e_guesses, alpha):\n        \"\"\"\n        Finds the energy eigenvalue using the secant method.\n        \"\"\"\n        e_prev, e_curr = e_guesses\n        f_prev = solve_ode_rk4(initial_state, e_prev, alpha)\n        f_curr = solve_ode_rk4(initial_state, e_curr, alpha)\n\n        for _ in range(MAX_ITER):\n            if abs(f_curr) < TOL_F:\n                return e_curr\n            \n            delta_e = e_curr - e_prev\n            if abs(delta_e) < TOL_EPS:\n                return e_curr\n            \n            # Avoid division by zero or a very small number\n            if abs(f_curr - f_prev) < 1e-15:\n                # If function values are too close, the method may fail.\n                # This indicates either convergence or a problem.\n                # For this problem, it's likely convergence.\n                return e_curr\n            \n            e_next = e_curr - f_curr * delta_e / (f_curr - f_prev)\n            \n            e_prev, e_curr = e_curr, e_next\n            f_prev, f_curr = f_curr, solve_ode_rk4(initial_state, e_curr, alpha)\n            \n        return e_curr\n\n    # Define the test cases from the problem statement.\n    # We set hbar = 1, so alpha = lambda / (m^2 * omega^3)\n    test_cases = [\n        # Case A: (m, omega, lambda) = (1, 1, 0)\n        (1.0, 1.0, 0.0),\n        # Case B: (m, omega, lambda) = (1, 1, 0.2)\n        (1.0, 1.0, 0.2),\n        # Case C: (m, omega, lambda) = (1, 1, 0.5)\n        (1.0, 1.0, 0.5),\n    ]\n\n    results = []\n    \n    # Initial conditions for even and odd states\n    ic_even = [1.0, 0.0]  # psi(0)=1, phi(0)=0\n    ic_odd = [0.0, 1.0]   # psi(0)=0, phi(0)=1\n\n    # Initial guesses for energy eigenvalues (e_prev, e_curr)\n    # Based on QHO energies (0.5, 1.5) and perturbation theory\n    # (energy increases with alpha)\n    guesses = {\n        'A': {'even': (0.4, 0.6), 'odd': (1.4, 1.6)},\n        'B': {'even': (0.5, 0.7), 'odd': (1.6, 1.8)},\n        'C': {'even': (0.6, 0.8), 'odd': (1.7, 1.9)},\n    }\n    case_labels = ['A', 'B', 'C']\n\n    for i, case in enumerate(test_cases):\n        m, omega, lamb = case\n        case_label = case_labels[i]\n        \n        # In the problem, hbar=1 for test cases\n        alpha = lamb / (m**2 * omega**3)\n        \n        # Lowest even state energy\n        e_guesses_even = guesses[case_label]['even']\n        even_energy = find_energy_secant(ic_even, e_guesses_even, alpha)\n        results.append(f\"{even_energy:.6f}\")\n        \n        # Lowest odd state energy\n        e_guesses_odd = guesses[case_label]['odd']\n        odd_energy = find_energy_secant(ic_odd, e_guesses_odd, alpha)\n        results.append(f\"{odd_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2422745"}, {"introduction": "We now advance from analyzing given potentials to the creative task of designing them. This practice challenges you to solve an \"inverse problem\": engineering a potential well with a predetermined number of bound states. To do this efficiently, you will employ the Sturm sequence method, a clever algorithm that counts matrix eigenvalues below a certain threshold without having to compute them explicitly. By combining this counting technique with a bisection search, you will determine the precise depth a \"funnel\" potential needs to trap a specific number of quantum states [@problem_id:2388915], a task that mirrors real-world design challenges in quantum engineering.", "problem": "Design and implement a program that, using first principles of quantum mechanics and numerical analysis, constructs a one-parameter family of one-dimensional \"funnel\" potentials and automatically tunes the depth parameter to yield a specified number of bound states. Work in dimensionless units where $\\hbar^{2}/(2m)=1$, so the time-independent Schrödinger equation reads\n$$\n- \\frac{d^{2}\\psi(x)}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x).\n$$\nA bound state is defined as an energy eigenvalue $E$ strictly less than $0$, assuming $V(x)\\to 0$ as $|x|\\to\\infty$. Consider the smooth \"funnel\" potential family\n$$\nV(x;V_{0},b,p) = -\\frac{V_{0}}{1+\\left(\\frac{|x|}{b}\\right)^{p}},\n$$\nwith depth parameter $V_{0}>0$, width scale $b>0$, and shape parameter $p>0$. On a finite interval $[-L,L]$ with $L\\gg b$, impose homogeneous Dirichlet boundary conditions $\\psi(-L)=\\psi(L)=0$, and discretize the operator on a uniform grid with spacing $h$ using the standard centered second-order finite-difference approximation for the second derivative. This yields a real symmetric tridiagonal Hamiltonian matrix whose diagonal entries are $a_{i} = 2/h^{2} + V(x_{i})$ and whose off-diagonal entries are $-1/h^{2}$. Use the Sylvester law of inertia and the Sturm sequence characterization for symmetric tridiagonal matrices to count, for a given $V_{0}$, the number of eigenvalues strictly below a threshold $\\lambda=0$. Then, using only the monotonicity of the spectrum with respect to the well depth $V_{0}$, implement a robust bisection procedure that finds the smallest $V_{0}$ such that the number of eigenvalues $E<0$ equals a target $N_{\\mathrm{target}}$.\n\nFundamental base you may use includes: the time-independent Schrödinger equation, the definition of bound states as $E<0$ for potentials vanishing at infinity, the finite-difference approximation, and the Sturm sequence/inertia method for counting eigenvalues below a shift.\n\nPhysical units: all quantities are to be treated as dimensionless due to the choice $\\hbar^{2}/(2m)=1$. The program must report $V_{0}$ values (dimensionless) rounded to six decimal places.\n\nDiscretization requirements:\n- Choose $L$ as $L=\\alpha\\,b$ with a fixed $\\alpha$ sufficiently large to approximate the $|x|\\to\\infty$ boundary, and $h$ as $h=\\beta\\,b$ with a fixed $\\beta$ sufficiently small to resolve the bound-state wavefunctions. For this assignment, use $\\alpha = 20$ and $\\beta = 0.01$.\n- Use the interior grid points only in constructing the tridiagonal Hamiltonian with Dirichlet boundary conditions at $x=\\pm L$.\n\nAlgorithmic requirements:\n- Implement a function that, given arrays of the main diagonal $a_{i}$ and the constant off-diagonal magnitude $|b_{\\mathrm{FD}}|=1/h^{2}$, returns the count of eigenvalues strictly below $\\lambda=0$ using the Sturm recursion\n$$\nd_{1} = a_{1}-\\lambda,\\quad d_{k} = (a_{k}-\\lambda) - \\frac{b_{\\mathrm{FD}}^{2}}{d_{k-1}}\\quad\\text{for }k\\ge 2,\n$$\nand counts how many $d_{k}$ are negative. Implement numerical safeguards for divisions when $|d_{k-1}|$ becomes very small without changing the sign unnecessarily.\n- Implement a bisection routine on $V_{0}$ that brackets and then isolates the smallest $V_{0}$ such that the count of eigenvalues below $0$ equals $N_{\\mathrm{target}}$. Start from $V_{0,\\mathrm{low}}=0$ and increase $V_{0,\\mathrm{high}}$ by factors of $2$ until the bracket condition is met. Terminate when the interval width is below a tolerance $\\varepsilon_{V}$; for this assignment use $\\varepsilon_{V}=10^{-8}$.\n\nTest suite and required output:\n- Use the following test cases, each specified by $(N_{\\mathrm{target}}, b, p)$, all in dimensionless units:\n    - Case A (happy path): $(5, 1.0, 2.0)$.\n    - Case B (wide funnel): $(5, 2.0, 2.0)$.\n    - Case C (steep core): $(5, 1.0, 6.0)$.\n    - Case D (narrow funnel): $(5, 0.5, 2.0)$.\n- For each case, compute and return the minimal $V_{0}$ that yields exactly $N_{\\mathrm{target}}$ bound states according to the above procedure, using $L=\\alpha\\,b$ with $\\alpha=20$ and $h=\\beta\\,b$ with $\\beta=0.01$. The final program output must be a single line containing a comma-separated list of the four $V_{0}$ values, each rounded to six decimal places, enclosed in square brackets, for example, \"[vA,vB,vC,vD]\".", "solution": "The problem posed is a well-defined exercise in computational quantum mechanics, requiring the determination of a potential parameter $V_0$ that yields a specific number of bound states. The problem is scientifically grounded, internally consistent, and requires no information beyond what is provided. It is therefore valid and permits a rigorous solution.\n\nThe physical basis is the one-dimensional time-independent Schrödinger equation, which in the specified dimensionless units where $\\hbar^2/(2m)=1$ is given by:\n$$\n- \\frac{d^{2}\\psi(x)}{dx^{2}} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\nThe potential under consideration is the \"funnel\" potential $V(x; V_0, b, p) = -V_0 / (1 + (|x|/b)^p)$. A bound state is a solution with an energy eigenvalue $E < 0$. Solving this eigenvalue problem for an arbitrary potential necessitates a numerical approach. The specified method involves discretizing the problem on a finite spatial domain.\n\nThe continuous domain of the variable $x$ is replaced by a finite interval $[-L, L]$, where $L$ is chosen to be sufficiently large ($L = \\alpha b$ with $\\alpha=20$) to approximate the infinite domain. Homogeneous Dirichlet boundary conditions, $\\psi(-L) = \\psi(L) = 0$, are imposed. The interval is discretized into a uniform grid with spacing $h = \\beta b$ (with $\\beta=0.01$). The grid points are $x_i = -L + i \\cdot h$ for $i=0, 1, \\dots, N_{\\mathrm{grid}}$, where $N_{\\mathrm{grid}} = 2L/h$. The solution $\\psi(x)$ is sought at the $M = N_{\\mathrm{grid}}-1$ interior points.\n\nThe second derivative operator is approximated using the second-order central difference scheme:\n$$\n\\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_i} \\approx \\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{h^2}\n$$\nwhere $\\psi_i \\equiv \\psi(x_i)$. Substituting this into the Schrödinger equation transforms the differential equation into a matrix eigenvalue equation $H\\vec{\\psi} = E\\vec{\\psi}$. Here, $H$ is a real, symmetric, tridiagonal matrix of size $M \\times M$ with elements:\n-   Diagonal: $a_i = \\frac{2}{h^2} + V(x_i)$ for $i=1, \\dots, M$.\n-   Off-diagonal: $b_{i, i\\pm 1} = -\\frac{1}{h^2}$.\n\nThe objective is to find the number of eigenvalues of $H$ that are less than $0$. Instead of the computationally expensive full diagonalization, the problem specifies the use of the Sturm sequence method. This method, based on Sylvester's law of inertia, determines the number of eigenvalues of a symmetric tridiagonal matrix below a given shift $\\lambda$ in $O(M)$ operations. The number of eigenvalues less than $\\lambda$ is equal to the number of negative terms in the sequence $\\{d_k\\}_{k=1}^M$ calculated by the recurrence:\n$$\nd_1 = a_1 - \\lambda\n$$\n$$\nd_k = (a_k - \\lambda) - \\frac{b_{\\mathrm{FD}}^2}{d_{k-1}}, \\quad \\text{for } k=2, \\dots, M\n$$\nwhere $b_{\\mathrm{FD}} = -1/h^2$ is the off-diagonal element. For this problem, the shift is $\\lambda=0$. To handle cases where a term $d_{k-1}$ is numerically zero, it is replaced by a small positive number to prevent division by zero without incorrectly altering the sign count. This procedure yields the number of bound states, $N(V_0)$, for a given potential depth $V_0$.\n\nThe number of bound states, $N(V_0)$, is a monotonically non-decreasing function of $V_0$, a consequence of the variational principle of quantum mechanics. This crucial property allows the use of a bisection search algorithm to efficiently find the minimal $V_0$ for which $N(V_0) = N_{\\mathrm{target}}$. The search procedure is:\n1.  **Bracketing**: An interval $[V_{0,\\mathrm{low}}, V_{0,\\mathrm{high}}]$ containing the target $V_0$ is found. We initiate with $V_{0,\\mathrm{low}} = 0$, for which $N(0)=0$. The upper bound $V_{0,\\mathrm{high}}$ is found by starting with a guess (e.g., $V_{0,\\mathrm{high}}=1.0$) and repeatedly doubling it until $N(V_{0,\\mathrm{high}}) \\ge N_{\\mathrm{target}}$.\n2.  **Bisection**: The interval is iteratively refined. At each step, the midpoint $V_{0,\\mathrm{mid}} = (V_{0,\\mathrm{low}} + V_{0,\\mathrm{high}})/2$ is tested. If $N(V_{0,\\mathrm{mid}}) < N_{\\mathrm{target}}$, the potential is not yet deep enough, so we update $V_{0,\\mathrm{low}} = V_{0,\\mathrm{mid}}$. If $N(V_{0,\\mathrm{mid}}) \\ge N_{\\mathrm{target}}$, the potential is sufficiently deep, so we update $V_{0,\\mathrm{high}} = V_{0,\\mathrm{mid}}$ to continue searching for the minimal value.\nThis process is repeated until the interval width $(V_{0,\\mathrm{high}} - V_{0,\\mathrm{low}})$ is below the specified tolerance $\\varepsilon_V = 10^{-8}$. The final answer is the resulting upper bound, $V_{0,\\mathrm{high}}$.\n\nThe algorithm is implemented to process each test case provided, $(N_{\\mathrm{target}}, b, p)$, and reports the calculated $V_0$ values rounded to six decimal places in the required format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It orchestrates the calculation of V0 for each case and prints the final result.\n    \"\"\"\n\n    # Global constants defined in the problem statement\n    ALPHA = 20.0\n    BETA = 0.01\n    EPSILON_V = 1e-8\n    # Small number to safeguard against division by zero in the Sturm sequence.\n    STURM_SAFEGUARD = 1e-30\n\n    def sturm_count_eigenvalues_below_shift(diag, off_diag_sq, shift):\n        \"\"\"\n        Counts the number of eigenvalues of a symmetric tridiagonal matrix\n        that are strictly less than a given shift.\n\n        Args:\n            diag (np.ndarray): The main diagonal of the matrix.\n            off_diag_sq (float): The square of the constant off-diagonal element.\n            shift (float): The energy threshold for counting eigenvalues.\n\n        Returns:\n            int: The number of eigenvalues less than the shift.\n        \"\"\"\n        count = 0\n        \n        # Initialize the first term of the Sturm sequence\n        d_prev = diag[0] - shift\n        if d_prev < 0:\n            count += 1\n        \n        # Safeguard for d_prev being numerically zero\n        if abs(d_prev) < STURM_SAFEGUARD:\n            d_prev = STURM_SAFEGUARD\n        \n        # Iterate through the rest of the sequence\n        for i in range(1, len(diag)):\n            d_k = (diag[i] - shift) - off_diag_sq / d_prev\n            if d_k < 0:\n                count += 1\n            \n            # Safeguard for d_k being numerically zero\n            if abs(d_k) < STURM_SAFEGUARD:\n                d_k = STURM_SAFEGUARD\n            \n            d_prev = d_k\n            \n        return count\n\n    def get_bound_state_count(V0, b, p):\n        \"\"\"\n        Sets up the discrete Hamiltonian and counts the number of bound states (E < 0).\n\n        Args:\n            V0 (float): The depth parameter of the potential.\n            b (float): The width parameter of the potential.\n            p (float): The shape parameter of the potential.\n\n        Returns:\n            int: The number of bound states for the given potential.\n        \"\"\"\n        # 1. Define discretization parameters based on b\n        L = ALPHA * b\n        h = BETA * b\n        \n        # 2. Set up the spatial grid (interior points only)\n        num_interior_points = int(round(2 * L / h)) - 1\n        x = np.linspace(-L + h, L - h, num_interior_points)\n        \n        # 3. Calculate the potential on the grid\n        V = -V0 / (1.0 + (np.abs(x) / b)**p)\n        \n        # 4. Define the Hamiltonian matrix elements\n        h_sq = h * h\n        diagonal = 2.0 / h_sq + V\n        off_diagonal_squared = (1.0 / h_sq)**2\n        \n        # 5. Count eigenvalues below the bound state threshold (E=0)\n        return sturm_count_eigenvalues_below_shift(diagonal, off_diagonal_squared, 0.0)\n\n    def find_minimal_V0(N_target, b, p):\n        \"\"\"\n        Finds the smallest V0 that produces exactly N_target bound states\n        using a bisection search algorithm.\n\n        Args:\n            N_target (int): The target number of bound states.\n            b (float): The width parameter of the potential.\n            p (float): The shape parameter of the potential.\n\n        Returns:\n            float: The minimal V0 value.\n        \"\"\"\n        # Phase 1: Bracket the solution\n        V_low = 0.0\n        \n        # For N_target=0, V0=0 is the trivial solution.\n        # For N_target > 0, V0=0 gives 0 states.\n        if N_target == 0:\n            return 0.0\n\n        # Start with a reasonable guess for V_high and expand until it's large enough.\n        V_high = 1.0\n        while get_bound_state_count(V_high, b, p) < N_target:\n            V_low = V_high\n            V_high *= 2.0\n            # Safety break to prevent an infinite loop in unforeseen circumstances.\n            if V_high > 1e6:\n                raise RuntimeError(\"Bracketing search for V0 failed to converge.\")\n\n        # Phase 2: Bisection to find the precise V0\n        while (V_high - V_low) > EPSILON_V:\n            V_mid = V_low + (V_high - V_low) / 2.0\n            \n            # Prevent getting stuck if precision limit is reached\n            if V_mid == V_low or V_mid == V_high:\n                break\n            \n            num_states = get_bound_state_count(V_mid, b, p)\n            \n            if num_states < N_target:\n                # Potential well is not deep enough\n                V_low = V_mid\n            else: # num_states >= N_target\n                # Potential is deep enough, this could be the answer, or a smaller V0 works\n                V_high = V_mid\n                \n        # V_high is the upper bound of the final interval, representing the smallest V0\n        # that yields N_target states.\n        return V_high\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (N_target, b, p)\n        (5, 1.0, 2.0),  # Case A: happy path\n        (5, 2.0, 2.0),  # Case B: wide funnel\n        (5, 1.0, 6.0),  # Case C: steep core\n        (5, 0.5, 2.0),  # Case D: narrow funnel\n    ]\n\n    results = []\n    for case in test_cases:\n        N_target, b, p = case\n        V0_result = find_minimal_V0(N_target, b, p)\n        results.append(V0_result)\n\n    # Format and print the final output as a single line\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2388915"}]}