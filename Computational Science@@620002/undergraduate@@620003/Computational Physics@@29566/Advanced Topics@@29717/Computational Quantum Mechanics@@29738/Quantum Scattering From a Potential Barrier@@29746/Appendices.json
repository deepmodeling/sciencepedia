{"hands_on_practices": [{"introduction": "While textbook problems often use idealized, sharp potential steps, many physical systems feature smooth potential changes. This practice [@problem_id:2432197] challenges you to move beyond these simple models by solving the Schrödinger equation for a more realistic, continuous potential barrier. By implementing a numerical 'shooting method', you will gain hands-on experience in directly integrating the wave equation and extracting a key physical observable—the scattering phase shift—from the solution's asymptotic behavior.", "problem": "Compute the scattering phase shifts for a nonrelativistic quantum particle in one dimension incident from the left on a smooth step (soft-edged) potential given by the logistic form. Use the time-independent Schrödinger equation as the starting point. Work entirely in dimensionless units defined by choosing the reduced Planck constant squared divided by twice the mass as unity, that is, set $\\hbar^2/(2m)=1$ so that the stationary Schrödinger equation reduces to\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\nor equivalently\n$$\n\\psi''(x) = \\left(V(x)-E\\right)\\psi(x).\n$$\nThe smooth potential is\n$$\nV(x) = \\frac{V_0}{1+\\exp\\left(-a\\,(x-x_0)\\right)},\n$$\nwith real parameters $V_0$, $a0$, and $x_0$. The potential asymptotes to $V(x\\to -\\infty)\\to 0$ and $V(x\\to +\\infty)\\to V_0$. A particle of energy $E0$ is incident from the left. In the far-left asymptotic region, the wavefunction behaves as a superposition of an incoming right-moving plane wave and a reflected left-moving plane wave,\n$$\n\\psi(x\\to -\\infty) \\sim e^{i k x} + r\\,e^{-i k x},\\quad k=\\sqrt{E}.\n$$\nIn the far-right asymptotic region, the wavefunction behaves as a transmitted right-moving plane wave for $EV_0$,\n$$\n\\psi(x\\to +\\infty) \\sim t\\,e^{i q x},\\quad q=\\sqrt{E-V_0},\n$$\nand as an evanescent decay for $0EV_0$,\n$$\n\\psi(x\\to +\\infty) \\sim t\\,e^{-\\kappa x},\\quad \\kappa=\\sqrt{V_0-E}.\n$$\nDefine the scattering phase shift $\\delta(E)$ in radians as follows:\n- For $0EV_0$, define $\\delta(E)=\\arg\\left(r(E)\\right)$, the argument of the complex reflection amplitude $r(E)$.\n- For $EV_0$, define $\\delta(E)=\\arg\\left(t(E)\\right)$, the argument of the complex transmission amplitude $t(E)$.\n\nTask: Derive, implement, and compute $\\delta(E)$ by numerically solving the Schrödinger equation and matching to the appropriate asymptotic form. Your derivation must start only from the Schrödinger equation, the stated asymptotic behaviors, and conservation of probability current. You must not invoke any closed-form expression for $r$ or $t$ for this potential. Use a robust numerical method to integrate the second-order ordinary differential equation and to extract the complex amplitudes by asymptotic matching. Angles must be reported in radians. Your program must be fully self-contained, take no input, and print the final results as specified below.\n\nFor numerical implementation details:\n- Work in the dimensionless units stated above (no physical unit conversion is required).\n- Use a finite computational domain $[L,R]$ with $L=x_0-W$ and $R=x_0+W$, taking $W=12/a$ so that $V(x)$ is exponentially close to its asymptotes at $x=L$ and $x=R$.\n- Integrate from $x=L$ to $x=R$ and determine $r$ (and $t$ when needed) by enforcing the appropriate right-asymptotic condition.\n\nTest suite: Evaluate and output the phase shifts for the following four cases in this exact order. Each case is a tuple of $(V_0,a,x_0,E)$.\n- Case $1$: $(V_0,a,x_0,E)=\\left(1.0,\\,1.5,\\,0.0,\\,0.2\\right)$.\n- Case $2$: $(V_0,a,x_0,E)=\\left(1.0,\\,0.7,\\,-1.0,\\,0.95\\right)$.\n- Case $3$: $(V_0,a,x_0,E)=\\left(1.0,\\,2.0,\\,0.5,\\,1.5\\right)$.\n- Case $4$: $(V_0,a,x_0,E)=\\left(0.5,\\,3.0,\\,0.0,\\,0.05\\right)$.\n\nSpecification of the required output:\n- The final output must be a single line containing a Python-style list of four floating-point numbers, each equal to the corresponding $\\delta(E)$ for the four cases, in radians, rounded to six digits after the decimal point, and in the same order as listed above. For example, the output must have the form\n$[d_1,d_2,d_3,d_4]$\nwith commas and no spaces.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a standard task in computational quantum mechanics that can be solved using established numerical methods. Proceeding with the solution.\n\nThe fundamental principle is the one-dimensional, time-independent Schrödinger equation, which in the specified dimensionless units ($\\hbar^2/(2m)=1$) is given by:\n$$\n\\psi''(x) = \\left(V(x) - E\\right)\\psi(x)\n$$\nHere, $\\psi(x)$ is the complex-valued wavefunction, $E$ is the particle's energy, and $V(x)$ is the smooth step potential:\n$$\nV(x) = \\frac{V_0}{1 + \\exp(-a(x - x_0))}\n$$\nwhere $V_0$, $a0$, and $x_0$ are real parameters.\n\nTo facilitate numerical solution, this second-order ordinary differential equation (ODE) is converted into a system of two first-order ODEs. We define a state vector $\\mathbf{y}(x)$ as:\n$$\n\\mathbf{y}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}\n$$\nThe corresponding first-order system is:\n$$\n\\frac{d}{dx}\\mathbf{y}(x) = \\begin{pmatrix} \\psi'(x) \\\\ (V(x) - E)\\psi(x) \\end{pmatrix}\n$$\nThis system is solved numerically using a shooting method. We integrate from the right boundary $x=R$ to the left boundary $x=L$ of the computational domain $[L, R]$. This backward integration is chosen for its superior numerical stability, particularly for evanescent solutions. The domain is defined by $L=x_0-W$ and $R=x_0+W$, with $W=12/a$, which ensures that $V(L) \\approx 0$ and $V(R) \\approx V_0$, validating the use of asymptotic forms as boundary conditions.\n\nThe analytical approach differs depending on the relationship between the particle energy $E$ and the potential step height $V_0$.\n\nRegime 1: Total Reflection ($0  E  V_0$)\nFor energies below the potential step, the particle cannot propagate in the region $x \\to +\\infty$. The wavefunction must decay exponentially: $\\psi(x) \\sim t\\,e^{-\\kappa x}$, where $\\kappa = \\sqrt{V_0 - E}$. We begin the numerical integration at $x=R$ by setting the initial conditions based on this asymptotic form. As the overall normalization constant is arbitrary at this stage, we can set the coefficient $t=1$. The initial state vector at $x=R$ is therefore real:\n$$\n\\mathbf{y}(R) = \\begin{pmatrix} \\psi(R) \\\\ \\psi'(R) \\end{pmatrix} = \\begin{pmatrix} e^{-\\kappa R} \\\\ -\\kappa e^{-\\kappa R} \\end{pmatrix}\n$$\nWith these real initial conditions and a real potential $V(x)$, the numerical integration of the ODE system from $x=R$ to $x=L$ yields a real-valued solution, providing real values for $\\psi_{num}(L)$ and $\\psi'_{num}(L)$. In the left asymptotic region ($x \\to -\\infty$), the wavefunction is a superposition of an incident wave $e^{ikx}$ and a reflected wave $r e^{-ikx}$, where $k=\\sqrt{E}$. We match our computed real solution at $x=L$ to the general complex form $C(e^{ikx} + r e^{-ikx})$ for some complex constant $C$. This gives the system:\n$$\n\\psi_{num}(L) = C (e^{ikL} + r e^{-ikL})\n$$\n$$\n\\psi'_{num}(L) = C (i k e^{ikL} - i k r e^{-ikL})\n$$\nSolving this system of two equations for the single unknown $r$ (by eliminating $C$) yields the reflection amplitude:\n$$\nr = e^{2ikL} \\frac{i k \\psi_{num}(L) - \\psi'_{num}(L)}{i k \\psi_{num}(L) + \\psi'_{num}(L)}\n$$\nThe phase shift, as defined for this regime, is the argument of this complex number: $\\delta(E) = \\arg(r)$. Conservation of probability current dictates $|r|=1$, a property that is mathematically guaranteed by the derived expression for $r$.\n\nRegime 2: Transmission ($E  V_0$)\nWhen the energy exceeds the potential step, the particle can propagate in all space. The wavefunction in the right asymptotic region is a transmitted plane wave, $\\psi(x) \\sim t\\,e^{iqx}$, where $q = \\sqrt{E-V_0}$. To determine the transmission amplitude $t$, we normalize the incident wave to have unit amplitude. We start by integrating a trial solution $\\psi_{num}(x)$, defined by setting its transmitted part to $e^{iqx}$. The corresponding initial conditions at $x=R$ are complex:\n$$\n\\mathbf{y}(R) = \\begin{pmatrix} \\psi(R) \\\\ \\psi'(R) \\end{pmatrix} = \\begin{pmatrix} e^{iqR} \\\\ iq e^{iqR} \\end{pmatrix}\n$$\nIntegrating backwards to $x=L$ provides the complex values $\\psi_{num}(L)$ and $\\psi'_{num}(L)$. In the left asymptotic region, this numerical solution has the form $\\psi_{num}(x) \\sim A_{num} e^{ikx} + B_{num} e^{-ikx}$, where $A_{num}$ is the amplitude of the right-moving component and $B_{num}$ is the amplitude of the left-moving component. We solve for these coefficients by matching at $x=L$:\n$$\n\\psi_{num}(L) = A_{num} e^{ikL} + B_{num} e^{-ikL}\n$$\n$$\n\\psi'_{num}(L) = i k A_{num} e^{ikL} - i k B_{num} e^{-ikL}\n$$\nSolving for the incident amplitude $A_{num}$ gives:\n$$\nA_{num} = \\frac{1}{2} e^{-ikL} \\left( \\psi_{num}(L) + \\frac{\\psi'_{num}(L)}{ik} \\right)\n$$\nThe true physical wavefunction is obtained by normalizing our numerical solution such that the incident amplitude is unity: $\\psi_{phys}(x) = \\psi_{num}(x) / A_{num}$. Consequently, the transmission amplitude is $t=1/A_{num}$. The phase shift for this regime is defined as $\\delta(E) = \\arg(t)$.\n\nThe algorithm for each test case $(V_0, a, x_0, E)$ is to first determine the physical regime by comparing $E$ and $V_0$, then set the appropriate initial conditions at $x=R$, integrate the ODE system numerically to $x=L$, and finally use the resulting values of $\\psi(L)$ and $\\psi'(L)$ to compute either $r$ or $t$ and extract the required phase shift.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Main function to compute phase shifts for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (V0, a, x0, E)\n        (1.0, 1.5, 0.0, 0.2),\n        (1.0, 0.7, -1.0, 0.95),\n        (1.0, 2.0, 0.5, 1.5),\n        (0.5, 3.0, 0.0, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        phase_shift = calculate_phase_shift(*case)\n        results.append(f\"{phase_shift:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\ndef calculate_phase_shift(v0, a, x0, e):\n    \"\"\"\n    Calculates the scattering phase shift for a particle in a logistic potential.\n    \n    The function solves the time-independent Schrödinger equation numerically using a\n    shooting method, integrating backwards in space from a region where the\n    asymptotic solution is simple. It then matches the solution at the other\n    end of the domain to find the reflection or transmission amplitude and\n    computes the corresponding phase shift.\n\n    Args:\n        v0 (float): Potential step height V_0.\n        a (float): Steepness of the potential.\n        x0 (float): Center of the potential step.\n        e (float): Energy of the incident particle.\n\n    Returns:\n        float: The scattering phase shift in radians.\n    \"\"\"\n    # Define the potential function V(x)\n    def potential(x):\n        return v0 / (1.0 + np.exp(-a * (x - x0)))\n\n    # Define the system of first-order ODEs: y' = f(x, y)\n    # y[0] = psi(x), y[1] = psi'(x)\n    def schrodinger_odes(x, y):\n        psi, psi_prime = y\n        # The second derivative of psi is (V(x) - E) * psi\n        psi_double_prime = (potential(x) - e) * psi\n        return [psi_prime, psi_double_prime]\n\n    # Set up the computational domain [L, R]\n    w = 12.0 / a\n    x_l = x0 - w\n    x_r = x0 + w\n    \n    # Define integration span (backwards from R to L)\n    t_span = [x_r, x_l]\n\n    # Incident wave number\n    k = np.sqrt(e)\n\n    if e  v0:\n        # Regime 1: Total reflection (0  E  V0)\n        kappa = np.sqrt(v0 - e)\n        \n        # Initial conditions at x_r for a decaying real exponential\n        psi_r = np.exp(-kappa * x_r)\n        psi_prime_r = -kappa * psi_r\n        y0 = [psi_r, psi_prime_r]\n        \n        # Solve the Initial Value Problem from R to L\n        sol = solve_ivp(schrodinger_odes, t_span, y0, method='RK45', rtol=1e-9, atol=1e-9)\n        \n        # Extract solution at x_l. sol.y[:, -1] is the state at the final time point.\n        psi_l, psi_prime_l = sol.y[:, -1]\n        \n        # Calculate reflection coefficient r\n        # r = exp(2ikL) * (ik*psi_L - psi'_L) / (ik*psi_L + psi'_L)\n        numerator = 1j * k * psi_l - psi_prime_l\n        denominator = 1j * k * psi_l + psi_prime_l\n        r = np.exp(2j * k * x_l) * (numerator / denominator)\n        \n        # Phase shift is the argument of r\n        delta = np.angle(r)\n        \n    else:  # E >= V0\n        # Regime 2: Transmission (E > V0)\n        q = np.sqrt(e - v0)\n        \n        # Initial conditions at x_r for a forward-propagating complex plane wave\n        psi_r = np.exp(1j * q * x_r)\n        psi_prime_r = 1j * q * psi_r\n        y0 = [psi_r, psi_prime_r]\n        \n        # Solve the IVP from R to L\n        sol = solve_ivp(schrodinger_odes, t_span, y0, method='RK45', rtol=1e-9, atol=1e-9)\n        \n        # Extract complex solution at x_l\n        psi_l_num, psi_prime_l_num = sol.y[:, -1]\n\n        # Calculate the incident amplitude A_num by matching at x_l\n        # A_num = 0.5 * exp(-ikL) * (psi_L + psi'_L / (ik))\n        a_num = 0.5 * np.exp(-1j * k * x_l) * (psi_l_num + psi_prime_l_num / (1j * k))\n        \n        # Transmission coefficient t = 1 / A_num\n        t = 1.0 / a_num\n        \n        # Phase shift is the argument of t\n        delta = np.angle(t)\n\n    return delta\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2432197"}, {"introduction": "Analyzing complex structures like semiconductor superlattices or photonic crystals requires methods that can handle layered or spatially varying potentials. The transfer matrix method, explored in this practice [@problem_id:2432228], provides an elegant and powerful tool by composing the effects of individual potential slices into a single matrix. This exercise guides you in implementing this cornerstone technique of mesoscopic physics to calculate the transmission spectrum for a barrier with a complex internal structure, a skill essential for modeling modern nanoscale devices.", "problem": "A nonrelativistic quantum particle of mass $m$ in one dimension, described by the time-independent Schrödinger equation, scatters from a finite barrier region of length $L$ within which the potential energy is a base barrier of height $V_0$ with a superimposed sinusoidal ripple. The barrier occupies $x \\in [0,L]$ with potential $V(x) = V_0 + A \\sin(k x)$, while the potential is zero outside the barrier, $V(x) = 0$ for $x  0$ and $x  L$. Use nondimensional units defined by $\\hbar^2/(2m) = 1$ so that energies and lengths are dimensionless and the local wave number satisfies $q(x) = \\sqrt{E - V(x)}$ with the principal branch of the complex square root for classically forbidden regions. The particle is incident from the left with energy $E  0$, and the quantity of interest is the transmission coefficient $T(E)$, defined as the ratio of the transmitted to incident probability current far from the barrier.\n\nStarting from the time-independent Schrödinger equation\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\nand the definition of the probability current $J(x)$, as well as continuity of the wavefunction $\\psi(x)$ and its first derivative $d\\psi/dx$ at interfaces between regions of constant potential, derive a numerically stable computational method to obtain the transmission coefficient $T(E)$ for the given barrier. Your derivation must begin from these fundamental elements and reach an algorithm that composes the effect of many thin uniform slices of the barrier to connect asymptotic wave amplitudes on the left and right, enforcing incidence from the left only. Treat classically forbidden slices using complex-valued local wave numbers and ensure correct flux normalization between the asymptotic regions. You must handle the presence of turning points by employing a numerically robust procedure that avoids singularities when $E \\approx V(x)$ at a slice boundary.\n\nImplement your method as a complete, runnable program that:\n- Discretizes the barrier $[0,L]$ into $N$ thin slices of equal width and approximates $V(x)$ as constant in each slice (evaluate $V(x)$ at slice centers).\n- Composes $2\\times 2$ transfer operations that enforce continuity across slice interfaces and propagation within slices to obtain the overall mapping between incoming and outgoing plane-wave amplitudes.\n- Computes the transmission coefficient $T(E)$ from the composed mapping with proper current normalization. Use a small positive imaginary regulator $+\\mathrm{i}\\eta$ added to energy $E$ (with $\\eta$ strictly positive and $\\eta \\ll 1$) in the numerical evaluation of local wave numbers to avoid singularities at $E \\approx V(x)$ and to implement the correct outgoing-wave condition.\n- Uses a fixed barrier length $L = 1$.\n- Uses a sufficiently fine discretization $N$ to resolve the ripple for the largest $k$ in the test suite while maintaining numerical stability. Choose a single $N$ that you use for all test cases.\n\nYour program must compute $T(E)$ for each energy in the specified test suite below, rounding each reported transmission to $6$ decimal places.\n\nTest suite (each test case is a tuple of $(V_0,A,k,L,\\{E\\text{ list}\\})$ in the units defined above; here $L=1$ in all cases):\n- Case $1$ (happy path, moderate ripple): $(V_0,A,k,L,{E}) = (0.5, 0.1, $16\\pi$, 1, {$0.2$, $0.5$, $0.8$, $1.2$})\\,$.\n- Case $2$ (boundary, no ripple reduces to square barrier): $(V_0,A,k,L,{E}) = (0.6, 0.0, $6\\pi$, 1, {$0.2$, $0.61$, $1.0$})\\,$.\n- Case $3$ (edge, rapid ripple): $(V_0,A,k,L,{E}) = (0.4, 0.2, $40\\pi$, 1, {$0.3$, $0.7$})\\,$.\n- Case $4$ (edge, ripple without base barrier): $(V_0,A,k,L,{E}) = (0.0, 0.3, $8\\pi$, 1, {$0.05$, $0.2$, $0.5$})\\,$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of the transmissions for the energies in that case, in the same order as listed above. For example, the output must look like\n$[[$t_{1,1}$,$t_{1,2}$,\\dots],[$t_{2,1}$,\\dots],\\dots]$,\nwith each $t_{i,j}$ a float rounded to $6$ decimal places.", "solution": "The problem presented is a standard exercise in one-dimensional quantum scattering theory, and its formulation is scientifically sound, well-posed, and complete. It is therefore deemed a valid problem. We proceed with a rigorous derivation of the numerical solution based on the transfer matrix method, as stipulated.\n\nOur starting point is the time-independent Schrödinger equation for a particle of mass $m$ with energy $E$ in a potential $V(x)$:\n$$\n-\\frac{\\hbar^2}{2m} \\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\nUsing the specified nondimensional units where $\\hbar^2/(2m) = 1$, the equation simplifies to:\n$$\n-\\frac{d^2\\psi(x)}{dx^2} + V(x)\\,\\psi(x) = E\\,\\psi(x) \\quad \\implies \\quad \\frac{d^2\\psi(x)}{dx^2} + (E - V(x))\\,\\psi(x) = 0\n$$\nLet us define the local wave number $q(x) = \\sqrt{E - V(x)}$. The problem specifies the use of a small positive imaginary regulator, $\\eta$, so we replace $E$ with a complex energy $E_{comp} = E + i\\eta$. This ensures that the local wave number $q(x) = \\sqrt{E_{comp} - V(x)}$ is never zero, addressing potential singularities at classical turning points where $E = V(x)$. The principal branch of the complex square root is used.\n\nThe core of the numerical method is to discretize the barrier region $x \\in [0, L]$ into $N$ contiguous slices of equal width $\\Delta x = L/N$. Within each slice $j$, extending from $x_j = j\\Delta x$ to $x_{j+1} = (j+1)\\Delta x$, we approximate the potential $V(x)$ as a constant, $V_j$, evaluated at the slice's midpoint: $V_j = V(x_j + \\Delta x/2)$. Consequently, the local wave number is also constant within each slice, denoted as $q_j = \\sqrt{E_{comp} - V_j}$.\n\nIn a slice $j$ with constant potential, the Schrödinger equation is a simple harmonic oscillator equation:\n$$\n\\frac{d^2\\psi(x)}{dx^2} + q_j^2\\,\\psi(x) = 0\n$$\nThe general solution for $\\psi(x)$ within this slice is a linear combination of oscillations or exponential functions, which can be expressed in terms of the initial conditions at the start of the slice, $x_j$. The state of the system at any point $x$ can be described by a vector containing the wavefunction and its derivative: $\\vec{\\Psi}(x) = \\begin{pmatrix} \\psi(x) \\\\ \\psi'(x) \\end{pmatrix}$.\n\nThe solution at $x$ within the slice, given the state at $x_j$, is:\n$$\n\\psi(x) = \\psi(x_j)\\cos(q_j(x-x_j)) + \\frac{\\psi'(x_j)}{q_j}\\sin(q_j(x-x_j))\n$$\n$$\n\\psi'(x) = -q_j\\psi(x_j)\\sin(q_j(x-x_j)) + \\psi'(x_j)\\cos(q_j(x-x_j))\n$$\nEvaluating this at the end of the slice, $x = x_{j+1} = x_j + \\Delta x$, we obtain a linear relationship between the state vectors at the slice boundaries: $\\vec{\\Psi}(x_{j+1}) = P_j \\vec{\\Psi}(x_j)$. The matrix $P_j$ is the propagation or transfer matrix for slice $j$:\n$$\nP_j = \\begin{pmatrix} \\cos(q_j \\Delta x)  \\frac{\\sin(q_j \\Delta x)}{q_j} \\\\ -q_j \\sin(q_j \\Delta x)  \\cos(q_j \\Delta x) \\end{pmatrix}\n$$\nThe use of the complex regulator $\\eta$ ensures $q_j \\neq 0$, so the term $\\sin(q_j \\Delta x)/q_j$ is always well-defined.\n\nSince the wavefunction $\\psi(x)$ and its derivative $\\psi'(x)$ must be continuous everywhere, the state vector $\\vec{\\Psi}(x)$ is continuous across the boundaries between slices. Therefore, to find the relationship between the state at $x=0$ and $x=L$, we simply compose the transfer matrices for all slices in order:\n$$\n\\vec{\\Psi}(L) = P_{N-1} P_{N-2} \\cdots P_1 P_0 \\vec{\\Psi}(0)\n$$\nLet the total transfer matrix for the barrier be $M = P_{N-1} P_{N-2} \\cdots P_0$. Then $\\vec{\\Psi}(L) = M \\vec{\\Psi}(0)$. The determinant of each $P_j$ is $\\cos^2(q_j \\Delta x) + \\sin^2(q_j \\Delta x) = 1$, so the total matrix $M$ is also unimodular, $\\det(M)=1$.\n\nNext, we relate the state vectors at the boundaries of the barrier to the asymptotic plane wave solutions. The particle is incident from the left.\nFor $x  0$ (Region I), $V(x)=0$. The wavefunction is a superposition of an incident wave and a reflected wave:\n$\\psi_I(x) = A e^{i k_0 x} + B e^{-i k_0 x}$, where $k_0 = \\sqrt{E_{comp}}$.\nFor $x  L$ (Region III), $V(x)=0$. The wavefunction consists only of a transmitted wave:\n$\\psi_{III}(x) = C e^{i k_0 (x-L)}$. The phase is chosen for convenience at $x=L$.\n\nFrom these forms, we evaluate the state vectors at $x=0$ and $x=L$:\nAt $x=0$: $\\psi(0) = A+B$ and $\\psi'(0) = i k_0 (A-B)$.\nAt $x=L$: $\\psi(L) = C$ and $\\psi'(L) = i k_0 C$.\n\nWe can now express the asymptotic amplitudes $(A, B)$ in terms of the transmitted amplitude $C$ by inverting the total transfer matrix relation: $\\vec{\\Psi}(0) = M^{-1} \\vec{\\Psi}(L)$. Since $\\det(M)=1$, the inverse is simple:\n$M^{-1} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix}$.\nSubstituting the boundary conditions:\n$$\n\\begin{pmatrix} A+B \\\\ i k_0 (A-B) \\end{pmatrix} = \\begin{pmatrix} M_{22}  -M_{12} \\\\ -M_{21}  M_{11} \\end{pmatrix} \\begin{pmatrix} C \\\\ i k_0 C \\end{pmatrix}\n$$\nThis yields two linear equations:\n$1) \\: A+B = (M_{22} - i k_0 M_{12}) C$\n$2) \\: A-B = \\frac{1}{i k_0}(-M_{21} + i k_0 M_{11}) C$\n\nAdding these two equations eliminates $B$ and gives an expression for $2A$:\n$$\n2A = \\left( (M_{11} + M_{22}) - i k_0 M_{12} - \\frac{M_{21}}{i k_0} \\right) C\n$$\nThe transmission coefficient $T$ is the ratio of the transmitted probability current to the incident probability current. For plane waves $e^{ikx}$, the current is proportional to $k$. Since the wave number $k_0$ is the same in the incident and transmitted regions, $T$ simplifies to the ratio of squared amplitudes: $T = |C/A|^2$. From the expression for $2A$, we find $C/A$:\n$$\n\\frac{C}{A} = \\frac{2}{M_{11} + M_{22} - i k_0 M_{12} + i \\frac{M_{21}}{k_0}}\n$$\nThe transmission coefficient is therefore:\n$$\nT(E) = \\left| \\frac{2}{M_{11} + M_{22} - i k_0 M_{12} + i M_{21}/k_0} \\right|^2\n$$\nThis formula, combined with the procedure for calculating the total transfer matrix $M$, provides a complete and numerically stable algorithm to compute the transmission coefficient for any given energy $E$.\n\nThe algorithm for implementation is as follows:\n$1$. For a given set of parameters $(V_0, A, k, L, E)$, set numerical constants $N$ (number of slices) and $\\eta$ (regulator). A value of $N=1000$ is sufficient to resolve the fastest oscillations in the potential, and $\\eta=10^{-8}$ is a suitable regulator.\n$2$. Create the grid of $N$ slice midpoints and compute the potential $V_j$ for each slice.\n$3$. For each energy $E$, compute $E_{comp} = E + i\\eta$ and the corresponding wave numbers $k_0$ and $q_j$ for all slices.\n$4$. Initialize the total transfer matrix $M$ to the $2 \\times 2$ identity matrix.\n$5$. Iterate from $j=0$ to $N-1$, calculating the slice matrix $P_j$ using its formula, and update the total matrix via left-multiplication: $M_{new} = P_j \\cdot M_{old}$. This correctly computes the product $M = P_{N-1} \\cdots P_0$.\n$6$. Using the elements of the final matrix $M$ and the wave number $k_0$, compute $T(E)$ from the derived formula.\n$7$. Repeat for all energies in the test case.\n$8$. Format the results as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum scattering problem for the specified test cases.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    test_cases = [\n        (0.5, 0.1, 16.0 * np.pi, 1.0, [0.2, 0.5, 0.8, 1.2]),\n        (0.6, 0.0, 6.0 * np.pi, 1.0, [0.2, 0.61, 1.0]),\n        (0.4, 0.2, 40.0 * np.pi, 1.0, [0.3, 0.7]),\n        (0.0, 0.3, 8.0 * np.pi, 1.0, [0.05, 0.2, 0.5]),\n    ]\n    \n    # Global numerical parameters\n    N = 1000  # Number of slices for discretization\n    eta = 1e-8  # Small imaginary regulator for energy\n\n    all_results = []\n    for V0, A, k_ripple, L, E_list in test_cases:\n        case_results = []\n        dx = L / N\n        x_centers = (np.arange(N) + 0.5) * dx\n        V_slices = V0 + A * np.sin(k_ripple * x_centers)\n\n        for E in E_list:\n            if E = 0:\n                # For E=0 and V(x)>=0 far away, T=0. Handle E=0 separately\n                # to avoid issues if V_slices contains negative values near E=0.\n                # The problem statement specifies E > 0, but E=0.05 is close.\n                # A small positive E is fine with the general method.\n                if E == 0.0:\n                    case_results.append(0.0)\n                    continue\n\n            E_comp = E + 1j * eta\n            \n            # Wavenumber in asymptotic regions (V=0)\n            k0 = np.sqrt(E_comp)\n            \n            # Wavenumbers in each slice of the barrier\n            q_slices = np.sqrt(E_comp - V_slices)\n            \n            # Initialize total transfer matrix as the identity matrix\n            M_total = np.identity(2, dtype=np.complex128)\n            \n            # Compose the total transfer matrix by multiplying slice matrices\n            # M_total = P_{N-1} * ... * P_1 * P_0\n            for j in range(N):\n                qj = q_slices[j]\n                \n                # Pre-calculate cos and sin for the slice propagation matrix\n                cos_qdx = np.cos(qj * dx)\n                sin_qdx = np.sin(qj * dx)\n                \n                # Propagation matrix for slice j\n                # Pj = [[cos(qj*dx), sin(qj*dx)/qj],\n                #       [-qj*sin(qj*dx), cos(qj*dx)]]\n                Pj = np.array([\n                    [cos_qdx, sin_qdx / qj],\n                    [-qj * sin_qdx, cos_qdx]\n                ], dtype=np.complex128)\n                \n                # Left-multiply to build up the total matrix P_{j} * ... * P_{0}\n                M_total = Pj @ M_total\n            \n            # Extract elements of the total transfer matrix M\n            M11, M12, M21, M22 = M_total[0, 0], M_total[0, 1], M_total[1, 0], M_total[1, 1]\n            \n            # Calculate C/A using the derived formula\n            # C/A = 2 / (M11 + M22 - i*k0*M12 + i*M21/k0)\n            C_over_A = 2.0 / (M11 + M22 - 1j * k0 * M12 + 1j * M21 / k0)\n            \n            # Transmission coefficient T = |C/A|^2\n            transmission = np.abs(C_over_A)**2\n            \n            case_results.append(transmission)\n            \n        all_results.append(case_results)\n    \n    # Format the final output string as specified\n    # Example: [[0.123456,0.789012],[0.456789,...]]\n    outer_list_str = []\n    for res_list in all_results:\n        inner_list_str = ','.join([f\"{t:.6f}\" for t in res_list])\n        outer_list_str.append(f\"[{inner_list_str}]\")\n    \n    final_output = f\"[{','.join(outer_list_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2432228"}, {"introduction": "Stationary scattering reveals the probabilities of outcomes, but a full dynamic picture requires solving the time-dependent Schrödinger equation. This advanced practice [@problem_id:2432194] introduces the powerful split-operator Fast Fourier Transform (FFT) method to simulate the real-time evolution of a quantum wave packet. Your challenge is to design a time-varying potential that acts as a \"quantum boomerang,\" providing a tangible and engaging goal for mastering the simulation of quantum dynamics.", "problem": "You must write a complete, runnable program that numerically simulates quantum scattering from a time-dependent potential in one spatial dimension and evaluates whether a designed potential acts as a \"quantum boomerang\" that catches a wave packet and sends it back toward its origin. Start from the time-dependent Schrödinger equation for a non-relativistic particle in one dimension,\n$$\ni \\hbar \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\left[ -\\frac{\\hbar^2}{2m}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t).\n$$\nUse non-dimensionalized natural units with reduced Planck constant $\\hbar = 1$ and mass $m = 1$, so that the equation becomes\n$$\ni \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\left[ -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t).\n$$\nThe computational domain is periodic of length $L$, with $x \\in [-L/2, L/2)$ discretized on a uniform grid of $N_x$ points, spatial step $\\Delta x = L/N_x$, and time step $\\Delta t$. Use a split-operator (Strang) method based on the operator factorization valid to second order in $\\Delta t$:\n$$\ne^{-i \\Delta t \\,\\left(T+V\\right)} \\;\\approx\\; e^{-i \\frac{\\Delta t}{2} V(t+\\Delta t/2)} \\; e^{-i \\Delta t \\, T} \\; e^{-i \\frac{\\Delta t}{2} V(t+\\Delta t/2)},\n$$\nwhere the kinetic operator is $T = -\\frac{1}{2}\\,\\partial_x^2$ and the potential operator is multiplication by $V(x,t)$. Implement $e^{-i \\Delta t \\, T}$ in Fourier space using the wave number grid $k_n = \\frac{2\\pi}{L} n$ with $n \\in \\{-N_x/2,\\dots,N_x/2-1\\}$ (as returned by a standard Fast Fourier Transform definition), so that plane waves evolve by a phase $e^{-i \\Delta t \\, k^2 / 2}$. To avoid unphysical wrap-around from periodic boundaries, include a weak complex absorbing layer near both domain edges by adding an imaginary potential $-i \\eta(x)$ to $V(x,t)$, where $\\eta(x) \\ge 0$ is a smooth function nonzero only within a boundary layer of width $L_{\\text{abs}}$ near $x \\approx \\pm L/2$.\n\nThe initial state must be a normalized Gaussian wave packet,\n$$\n\\psi(x,0) \\;=\\; \\left(\\frac{1}{\\pi \\sigma_0^2}\\right)^{1/4} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma_0^2} \\right) \\exp\\!\\left( i k_0 (x-x_0) \\right),\n$$\nwith parameters given below. Let the designed time-dependent potential be a moving harmonic trap intended to catch and carry the packet back:\n$$\nV(x,t) \\;=\\; \\frac{1}{2}\\,\\Omega^2 \\, \\big(x - x_c(t)\\big)^2 \\, A(t) \\;-\\; i\\,\\eta(x).\n$$\nHere $\\Omega$ is the trap angular frequency (controlling confinement strength), $x_c(t)$ is the trap center, and $A(t)$ is a smooth envelope that ramps the trap on and off. Define the trap center as a piecewise-linear trajectory that first co-moves with the initial wave packet and then reverses to return it toward its origin:\n$$\nx_c(t) \\;=\\;\n\\begin{cases}\nx_0 + k_0 \\, t,  0 \\le t \\le t_{\\text{turn}},\\\\\nx_0 + k_0 \\, t_{\\text{turn}} \\;-\\; u_{\\text{return}}\\,\\big(t - t_{\\text{turn}}\\big),  t  t_{\\text{turn}}.\n\\end{cases}\n$$\nDefine the smooth on/off envelope as the product of independent rise and fall ramps,\n$$\nA(t) \\;=\\; R_{\\text{on}}(t)\\,R_{\\text{off}}(t),\n$$\nwith\n$$\nR_{\\text{on}}(t) \\;=\\;\n\\begin{cases}\n0,  t  t_{\\text{on}},\\\\\n\\sin^2\\!\\Big( \\dfrac{\\pi}{2} \\,\\dfrac{t - t_{\\text{on}}}{\\Delta_{\\text{on}}} \\Big),  t_{\\text{on}} \\le t \\le t_{\\text{on}} + \\Delta_{\\text{on}},\\\\\n1,  t  t_{\\text{on}} + \\Delta_{\\text{on}},\n\\end{cases}\n\\qquad\nR_{\\text{off}}(t) \\;=\\;\n\\begin{cases}\n1,  t  t_{\\text{off,start}},\\\\\n\\cos^2\\!\\Big( \\dfrac{\\pi}{2} \\,\\dfrac{t - t_{\\text{off,start}}}{\\Delta_{\\text{off}}} \\Big),  t_{\\text{off,start}} \\le t \\le t_{\\text{off,start}} + \\Delta_{\\text{off}},\\\\\n0,  t  t_{\\text{off,start}} + \\Delta_{\\text{off}}.\n\\end{cases}\n$$\nThe absorber profile must be\n$$\n\\eta(x) \\;=\\; \\eta_0 \\left[ \\Theta\\!\\big(x_L - x\\big)\\,\\left(\\frac{x_L-x}{L_{\\text{abs}}}\\right)^m + \\Theta\\!\\big(x - x_R\\big)\\,\\left(\\frac{x - x_R}{L_{\\text{abs}}}\\right)^m \\right],\n$$\nwith $x_L = -\\frac{L}{2} + L_{\\text{abs}}$, $x_R = \\frac{L}{2} - L_{\\text{abs}}$, $\\Theta$ the Heaviside step, and $m \\in \\mathbb{N}$ an even integer.\n\nYou must simulate the time evolution up to a final time $T$ and compute, for each specified parameter set, the fraction of probability found at the end to the left of a fixed threshold position $x_{\\text{th}}$:\n$$\nP_{\\text{left}} \\;=\\; \\frac{\\displaystyle \\int_{-\\frac{L}{2}}^{x_{\\text{th}}}\\! |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{-\\frac{L}{2}}^{\\frac{L}{2}}\\! |\\psi(x,T)|^2 \\, dx}.\n$$\nInterpret $P_{\\text{left}}$ as a diagnostic: a value near $1$ indicates a successful \"boomerang\" return toward the origin, while a value near $0$ indicates failure to return.\n\nUse the following fixed numerical parameters for all runs, stated in the non-dimensional units above: domain length $L = 200$, grid size $N_x = 1024$, time step $\\Delta t = 0.03$, final time $T = 45$, absorber width $L_{\\text{abs}} = 30$, absorber strength $\\eta_0 = 0.01$, absorber power $m = 2$, threshold $x_{\\text{th}} = -20$. Initial wave packet parameters: center $x_0 = -30$, width $\\sigma_0 = 2$, and wave number $k_0 = 1$.\n\nImplement the three test cases below. Except where explicitly stated, all parameters are the shared values above. Each case specifies the trap parameters $(\\Omega, t_{\\text{on}}, \\Delta_{\\text{on}}, t_{\\text{turn}}, u_{\\text{return}}, t_{\\text{off,start}}, \\Delta_{\\text{off}})$:\n\n- Case A (intended success, adiabatic capture and return): $\\Omega = 0.5$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 10$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 35$, $\\Delta_{\\text{off}} = 10$.\n\n- Case B (weak trap, intended failure to capture): $\\Omega = 0.05$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 10$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 35$, $\\Delta_{\\text{off}} = 10$.\n\n- Case C (strong but abruptly switched trap, intended partial/non-adiabatic capture): $\\Omega = 0.5$, $t_{\\text{on}} = 2$, $\\Delta_{\\text{on}} = 1$, $t_{\\text{turn}} = 24$, $u_{\\text{return}} = 1.2$, $t_{\\text{off,start}} = 44$, $\\Delta_{\\text{off}} = 1$.\n\nYour program must compute $P_{\\text{left}}$ for each case and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C], with each value rounded to exactly six digits after the decimal point and expressed as a decimal (not a percentage). For example, the output format must be like\n$[0.812345,0.012300,0.456700]$.", "solution": "The problem presented is a valid and well-posed exercise in computational quantum mechanics. It requires the numerical solution of the one-dimensional time-dependent Schrödinger equation (TDSE) to simulate the dynamics of a quantum wave packet interacting with a time-varying potential. The problem is scientifically grounded, providing a precise mathematical formulation, a standard and robust numerical method (split-operator FFT), and a complete set of parameters for implementation. There are no contradictions, ambiguities, or missing information. I will now proceed with a detailed description of the solution methodology.\n\nThe governing equation is the TDSE in non-dimensional units where $\\hbar=1$ and the particle mass $m=1$:\n$$ i \\,\\frac{\\partial}{\\partial t} \\psi(x,t) \\;=\\; \\hat{H}(t) \\psi(x,t) \\;=\\; \\left[ -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x,t) \\right] \\psi(x,t) $$\nHere, $\\hat{H}(t)$ is the time-dependent Hamiltonian, which is a sum of the kinetic energy operator $\\hat{T} = -\\frac{1}{2}\\partial_x^2$ and the potential energy operator $\\hat{V}(t)$ (multiplication by $V(x,t)$).\n\nThe formal solution over a small time step $\\Delta t$ is given by the action of the time-evolution operator, $\\psi(t+\\Delta t) = \\hat{U}(t+\\Delta t, t) \\psi(t)$. Since $\\hat{T}$ and $\\hat{V}(t)$ do not commute, and $\\hat{H}(t)$ is time-dependent, we use an approximation for $\\hat{U}$. The problem specifies the second-order symmetric Strang splitting method, which approximates the evolution operator as:\n$$ \\hat{U}(t+\\Delta t, t) \\approx e^{-i \\frac{\\Delta t}{2} \\hat{V}(t+\\frac{\\Delta t}{2})} \\; e^{-i \\Delta t \\, \\hat{T}} \\; e^{-i \\frac{\\Delta t}{2} \\hat{V}(t+\\frac{\\Delta t}{2})} $$\nThis formula dictates the algorithm for propagating the wave function $\\psi(x)$ from time $t_n$ to $t_{n+1} = t_n + \\Delta t$:\n1.  **First Potential Step:** Apply the potential operator for half a time step. This is a multiplication in position space. The potential is evaluated at the midpoint of the time interval, $t_n + \\Delta t/2$, to maintain second-order accuracy.\n    $$ \\psi'(x) = e^{-i \\frac{\\Delta t}{2} V(x, t_n + \\frac{\\Delta t}{2})} \\psi(x, t_n) $$\n2.  **Kinetic Step:** Apply the kinetic operator for a full time step. This operation is most efficiently performed in Fourier (momentum) space. The kinetic operator $\\hat{T} = -\\frac{1}{2}\\partial_x^2$ becomes a simple multiplication by $\\frac{k^2}{2}$ in the Fourier domain. The procedure is:\n    a.  Compute the forward Fast Fourier Transform (FFT) of the wave function: $\\tilde{\\psi}'(k) = \\mathcal{F}[\\psi'(x)]$.\n    b.  Multiply by the kinetic phase factor: $\\tilde{\\psi}''(k) = e^{-i \\Delta t \\frac{k^2}{2}} \\tilde{\\psi}'(k)$.\n    c.  Compute the inverse FFT: $\\psi''(x) = \\mathcal{F}^{-1}[\\tilde{\\psi}''(k)]$.\n3.  **Second Potential Step:** Apply the potential operator for the second half of the time step, using the same midpoint potential as in the first step.\n    $$ \\psi(x, t_{n+1}) = e^{-i \\frac{\\Delta t}{2} V(x, t_n + \\frac{\\Delta t}{2})} \\psi''(x) $$\nThis three-step sequence constitutes one iteration of the time evolution. It is repeated from $t=0$ to the final time $T$.\n\nThe simulation is performed on a discrete grid. The spatial domain $x \\in [-L/2, L/2)$ is discretized into $N_x$ points with spacing $\\Delta x = L/N_x$. The corresponding wave number grid for the FFT is given by $k_n = \\frac{2\\pi}{L} n$ for integers $n \\in \\{-N_x/2, \\dots, N_x/2-1\\}$, which can be conveniently generated using standard numerical library functions like `numpy.fft.fftfreq`.\n\nThe components of the simulation are constructed as follows:\n- **Initial State:** The initial wave function at $t=0$ is a Gaussian wave packet:\n  $$ \\psi(x,0) \\;=\\; \\left(\\frac{1}{\\pi \\sigma_0^2}\\right)^{1/4} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma_0^2} \\right) \\exp\\!\\left( i k_0 (x-x_0) \\right) $$\n  This function is evaluated on the discrete spatial grid `x` to initialize the simulation.\n- **Time-Dependent Potential:** The potential $V(x,t)$ has two parts: a real part representing the moving harmonic trap and an imaginary part for the absorbing boundaries.\n  $$ V(x,t) \\;=\\; \\underbrace{\\frac{1}{2}\\,\\Omega^2 \\, \\big(x - x_c(t)\\big)^2 \\, A(t)}_{V_{\\text{trap}}(x,t)} \\;-\\; i\\,\\underbrace{\\eta(x)}_{\\text{absorber}} $$\n  The absorber $\\eta(x)$ is static and is designed to be a polynomial function that smoothly turns on near the domain edges $x = \\pm L/2$ to prevent unphysical reflections from the periodic boundaries. The trap part requires computing the trap center $x_c(t)$ and amplitude $A(t)$ at each time step, which are defined by piecewise functions as specified in the problem statement. These functions will be implemented to evaluate their values at the required time $t_n + \\Delta t/2$.\n\nFinally, after evolving the system to the final time $T$, the quantity of interest, $P_{\\text{left}}$, is computed. This is the ratio of the integrated probability density for $x  x_{\\text{th}}$ to the total integrated probability density over the entire domain.\n$$ P_{\\text{left}} \\;=\\; \\frac{\\displaystyle \\int_{-\\frac{L}{2}}^{x_{\\text{th}}}\\! |\\psi(x,T)|^2 \\, dx}{\\displaystyle \\int_{-\\frac{L}{2}}^{\\frac{L}{2}}\\! |\\psi(x,T)|^2 \\, dx} $$\nThe integrals are approximated by numerical summation over the discrete grid points. The denominator is the total norm of the wave function at time $T$, which will be less than its initial value of $1$ due to absorption by the imaginary potential. The numerator is a similar sum, but restricted to grid points $x_j  x_{\\text{th}}$.\n\nThe program will be structured to execute this simulation for each of the three test cases, collecting the calculated $P_{\\text{left}}$ for each. The final output will be a formatted list of these values.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the quantum boomerang problem by simulating the Time-Dependent\n    Schrödinger Equation using the split-operator method.\n    \"\"\"\n\n    # --- Fixed Numerical and Physical Parameters ---\n    L = 200.0         # Domain length\n    Nx = 1024         # Number of grid points\n    dt = 0.03         # Time step\n    T_final = 45.0    # Final time\n    L_abs = 30.0      # Absorber width\n    eta0 = 0.01       # Absorber strength\n    m_abs = 2         # Absorber power (must be even integer)\n    x_th = -20.0      # Threshold position for P_left calculation\n\n    # --- Initial Wave Packet Parameters ---\n    x0 = -30.0        # Initial position\n    sigma0 = 2.0      # Initial width\n    k0 = 1.0          # Initial wave number\n\n    # --- Test Cases ---\n    # Parameters: (Omega, t_on, Delta_on, t_turn, u_return, t_off_start, Delta_off)\n    test_cases = [\n        # Case A: Intended success\n        (0.5, 2.0, 10.0, 24.0, 1.2, 35.0, 10.0),\n        # Case B: Weak trap, intended failure\n        (0.05, 2.0, 10.0, 24.0, 1.2, 35.0, 10.0),\n        # Case C: Abrupt trap, partial capture\n        (0.5, 2.0, 1.0, 24.0, 1.2, 44.0, 1.0),\n    ]\n\n    # --- Spatial and Wave Number Grids ---\n    dx = L / Nx\n    x = np.linspace(-L / 2, L / 2, Nx, endpoint=False)\n    k = 2 * np.pi * np.fft.fftfreq(Nx, d=dx)\n\n    # --- Kinetic Energy Operator in Fourier Space ---\n    T_op_fourier = np.exp(-1j * (k**2 / 2.0) * dt)\n    \n    # --- Helper Functions for Time-Dependent Potential ---\n    \n    def get_trap_center(t, t_turn, u_return):\n        if t = t_turn:\n            return x0 + k0 * t\n        else:\n            return x0 + k0 * t_turn - u_return * (t - t_turn)\n\n    def get_envelope_A(t, t_on, Delta_on, t_off_start, Delta_off):\n        # On-ramp\n        if t  t_on:\n            R_on = 0.0\n        elif t = t_on + Delta_on:\n            R_on = np.sin(0.5 * np.pi * (t - t_on) / Delta_on)**2\n        else:\n            R_on = 1.0\n        \n        # Off-ramp\n        if t  t_off_start:\n            R_off = 1.0\n        elif t = t_off_start + Delta_off:\n            R_off = np.cos(0.5 * np.pi * (t - t_off_start) / Delta_off)**2\n        else:\n            R_off = 0.0\n            \n        return R_on * R_off\n\n    # --- Absorber Potential ---\n    xL = -L / 2 + L_abs\n    xR = L / 2 - L_abs\n    eta = np.zeros_like(x)\n    \n    left_mask = x  xL\n    eta[left_mask] = eta0 * ((xL - x[left_mask]) / L_abs)**m_abs\n\n    right_mask = x > xR\n    eta[right_mask] = eta0 * ((x[right_mask] - xR) / L_abs)**m_abs\n\n    V_absorber = -1j * eta\n\n    results = []\n    \n    for case_params in test_cases:\n        Omega, t_on, Delta_on, t_turn, u_return, t_off_start, Delta_off = case_params\n\n        # --- Initial Wave Function ---\n        norm_factor = (1.0 / (np.pi * sigma0**2))**0.25\n        psi = norm_factor * np.exp(-(x - x0)**2 / (2 * sigma0**2)) * np.exp(1j * k0 * (x-x0))\n        \n        # --- Time Evolution Loop ---\n        num_steps = int(T_final / dt)\n        for i in range(num_steps):\n            t_mid = (i + 0.5) * dt\n            \n            # --- Construct Potential at Mid-Step Time ---\n            xc_t = get_trap_center(t_mid, t_turn, u_return)\n            A_t = get_envelope_A(t_mid, t_on, Delta_on, t_off_start, Delta_off)\n            V_trap = 0.5 * Omega**2 * (x - xc_t)**2 * A_t\n            V_total = V_trap + V_absorber\n            \n            V_op = np.exp(-1j * V_total * dt / 2.0)\n            \n            # --- Split-Operator Steps ---\n            # 1. Half-step in potential\n            psi = V_op * psi\n            \n            # 2. Full-step in kinetic energy (in Fourier space)\n            psi_f = np.fft.fft(psi)\n            psi_f = T_op_fourier * psi_f\n            psi = np.fft.ifft(psi_f)\n            \n            # 3. Second half-step in potential\n            psi = V_op * psi\n            \n        # --- Calculate P_left ---\n        prob_density = np.abs(psi)**2\n        total_prob = np.sum(prob_density) * dx\n        \n        left_region_mask = x  x_th\n        left_prob = np.sum(prob_density[left_region_mask]) * dx\n        \n        p_left = left_prob / total_prob if total_prob > 1e-12 else 0.0\n        results.append(f\"{p_left:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2432194"}]}