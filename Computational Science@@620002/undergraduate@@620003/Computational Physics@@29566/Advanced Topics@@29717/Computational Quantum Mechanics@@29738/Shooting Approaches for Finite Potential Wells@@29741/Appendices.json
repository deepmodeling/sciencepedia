{"hands_on_practices": [{"introduction": "The shooting method is a powerful numerical technique for solving boundary value problems, such as finding the energy eigenstates of a quantum system. It cleverly reframes the problem as an initial value problem, where we can guess a parameter (in this case, the energy $E$) and integrate the governing equation across a domain. In this foundational exercise, you will implement a shooting method from first principles by discretizing the time-independent Schrödinger equation on a spatial lattice, which provides a straightforward recurrence relation to \"shoot\" the wavefunction from one boundary to the other until the desired boundary condition at the far end is satisfied [@problem_id:2437421].", "problem": "You must write a complete, runnable program that, starting from first principles, numerically solves the one-dimensional, time-independent Schrödinger equation for a particle in a finite square potential well by discretizing space on a lattice and performing a shooting method on the resulting set of difference equations. Work in reduced, dimensionless units where $\\hbar^2/(2m)=1$, so that the governing equation is\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\nwith the finite square well potential\n$$\nV(x) = \\begin{cases}\n-D, & |x| \\le a,\\\\\n0, & |x| > a,\n\\end{cases}\n$$\nfor given half-width $a>0$ and depth $D>0$. Use a finite computational domain $x \\in [-L, L]$ with homogeneous Dirichlet boundary conditions $\\psi(-L)=0$ and $\\psi(L)=0$. All quantities are dimensionless in these reduced units, so no physical units are required in the final answers.\n\nStarting from this differential equation and these boundary conditions, derive a consistent second-order central-difference discretization on a uniform lattice $x_i = x_{\\min} + i\\,\\Delta x$ with $\\Delta x = (x_{\\max}-x_{\\min})/(N-1)$ and $N \\ge 3$, and implement a shooting approach that advances the difference equation from the left boundary $x_{\\min}=-L$ to the right boundary $x_{\\max}=L$ for a trial energy $E$. Use the boundary value at the left edge and a nonzero initial slope to start the recurrence, and define a mismatch function as the terminal value of $\\psi$ at the right boundary. Then bracket and refine the bound-state energies $E<0$ as the simple zeros of this mismatch function within the interval $(-D, 0)$, using a robust bracketing method (for example, bisection) on subintervals where the mismatch function changes sign. Implement numerical safeguards (such as rescaling the solution when needed) to prevent overflow during the shooting iterations. Your program must:\n- Construct the potential $V(x)$ for each test case.\n- Discretize the equation on the lattice and implement the shooting method on the resulting difference equation.\n- Scan the energy interval $(-D,0)$ on a coarse grid to identify sign changes of the mismatch function, then apply a bracketing root-finding method to converge each root to a tight tolerance.\n- Return, for each test case, the list of bound-state energies found, sorted in ascending order (from the most negative to the least negative), rounded to six decimals.\n\nTest suite. Use the following parameter sets, which together exercise a typical deep well with multiple bound states, a shallow well near threshold, and a narrow deep well:\n- Case $1$: $a=1.0$, $D=25.0$, $L=10a$, $N=2001$, coarse energy scan resolution $M=600$ sample points over $(-D,0)$.\n- Case $2$: $a=1.0$, $D=1.0$, $L=12a$, $N=2001$, coarse energy scan resolution $M=600$.\n- Case $3$: $a=0.3$, $D=50.0$, $L=10a$, $N=2001$, coarse energy scan resolution $M=600$.\n\nNumerical and algorithmic constraints:\n- Use a uniform lattice and a second-order central difference to derive the discrete update. Do not use closed-form transcendental quantization conditions; the objective is to implement the lattice shooting method.\n- Use homogeneous Dirichlet boundary conditions at $x=\\pm L$.\n- Implement bracketing plus bisection on intervals where the mismatch function changes sign.\n- To stabilize the recurrence, include a rescaling step if $|\\psi|$ grows beyond a large threshold. This rescaling must preserve the sign of the wavefunction at the right boundary and therefore does not affect root bracketing.\n- Round each reported energy to six decimals before output.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of floats for one test case. For example, an output with two test cases might look like $[[e_{1,1},e_{1,2}], [e_{2,1}]]$, except here you must provide the three test cases specified above.", "solution": "The user has provided a valid, well-posed problem in computational quantum mechanics. The task is to find the bound-state energy eigenvalues of a particle in a one-dimensional finite square potential well by implementing a numerical shooting method.\n\nThe problem is governed by the time-independent Schrödinger equation (TISE) in reduced dimensionless units where $\\hbar^2/(2m)=1$:\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\nThe potential $V(x)$ is a finite square well of depth $D>0$ and half-width $a>0$:\n$$\nV(x) = \\begin{cases}\n-D, & |x| \\le a,\\\\\n0, & |x| > a,\n\\end{cases}\n$$\nThe problem is solved on a finite computational domain $x \\in [-L, L]$ with homogeneous Dirichlet boundary conditions $\\psi(-L)=0$ and $\\psi(L)=0$. The energies of interest are for bound states, which satisfy $-D < E < 0$.\n\nThe solution is constructed following these steps: discretization of the governing equation, implementation of the shooting method to frame it as a root-finding problem, and application of a robust root-finding algorithm to determine the energy eigenvalues.\n\nFirst, we discretize the Schrödinger equation. The continuous spatial coordinate $x$ is replaced by a uniform lattice of $N$ points, $x_i = -L + i\\Delta x$ for $i=0, 1, \\dots, N-1$, where the grid spacing is $\\Delta x = 2L/(N-1)$. The second derivative of the wavefunction, $\\psi''(x)$, is approximated at each grid point $x_i$ using a second-order accurate central difference formula:\n$$\n\\psi''(x_i) \\approx \\frac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{(\\Delta x)^2}\n$$\nLetting $\\psi_i = \\psi(x_i)$ and $V_i = V(x_i)$, we substitute this approximation into the TISE:\n$$\n-\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2} + V_i \\psi_i = E \\psi_i\n$$\nThis is a linear difference equation. To implement the shooting method, we rearrange it into a recurrence relation that allows us to compute $\\psi_{i+1}$ from the two preceding values, $\\psi_i$ and $\\psi_{i-1}$:\n$$\n\\psi_{i+1} - 2\\psi_i + \\psi_{i-1} = -(\\Delta x)^2 (V_i - E)\\psi_i \\\\\n\\psi_{i+1} = (2 - (\\Delta x)^2 (E - V_i))\\psi_i - \\psi_{i-1}\n$$\nThis recurrence relation forms the core of our numerical integration.\n\nNext, we apply the shooting method. The problem is a two-point boundary value problem with conditions $\\psi_0=0$ and $\\psi_{N-1}=0$. The shooting method treats this as an initial value problem. We fix a trial energy $E$, enforce the left boundary condition, and integrate or \"shoot\" across the domain to the right boundary. The value at the right boundary is then checked.\n\nThe initial conditions for the recurrence are $\\psi_0$ and $\\psi_1$. The left boundary condition gives $\\psi_0 = 0$. The second value, $\\psi_1$, determines the initial slope of the wavefunction, $\\psi'(-L) \\approx (\\psi_1-\\psi_0)/\\Delta x = \\psi_1/\\Delta x$. Since a zero slope would result in the trivial solution $\\psi(x)=0$, we must choose a non-zero value for $\\psi_1$. The linearity of the TISE means that the overall normalization of the wavefunction is arbitrary, so any small, non-zero choice is valid. We choose $\\psi_1 = \\Delta x$, which corresponds to an initial slope of $1$.\n\nFor a given trial energy $E$, we iterate the recurrence relation from $i=1$ to $N-2$ to compute the entire wavefunction. The value at the right boundary, $\\psi_{N-1}$, will generally not be zero. We define a mismatch function $f(E)$ as this terminal value:\n$$\nf(E) = \\psi_{N-1}(E)\n$$\nThe energy eigenvalues are the specific values of $E$ for which this function is zero, i.e., $f(E)=0$, satisfying the right boundary condition.\n\nA critical issue in this procedure is numerical stability. In classically forbidden regions ($V(x) > E$), the true solution decays exponentially. However, the numerical recurrence also admits an exponentially growing solution. Due to finite floating-point precision, this growing component will eventually dominate and cause overflow. To counteract this, we introduce a rescaling step. During the iteration, if the magnitude of the wavefunction value $|\\psi_i|$ exceeds a large threshold, we divide the preceding and current values by this threshold. This keeps the numbers within a manageable range without changing the sign of the wavefunction or the location of its zeros, thus preserving the integrity of the root-finding process.\n\nFinally, we find the roots of $f(E)$. We are interested in energies in the interval $(-D, 0)$.\n1.  A coarse grid of $M$ energy points is spaced uniformly over $(-D, 0)$. The mismatch function $f(E)$ is evaluated at each of these points.\n2.  We scan the results for sign changes between adjacent energy points. An interval $[E_j, E_{j+1}]$ where $f(E_j) \\cdot f(E_{j+1}) < 0$ is guaranteed by the Intermediate Value Theorem to contain at least one root.\n3.  For each such bracketed interval, we apply the bisection method. This is an iterative algorithm that repeatedly halves the search interval while ensuring the root remains bracketed, robustly converging to the energy eigenvalue with a desired numerical tolerance.\n\nThis systematic procedure, combining discretization, shooting, numerical stabilization, and robust root-finding, is implemented to solve for the bound-state energies for each of the provided test cases. The discovered energies for each case are then sorted in ascending order and formatted as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A strict Russian professor does not tolerate floating-point overflow.\n# RESCALE_THRESHOLD prevents the wavefunction from growing uncontrollably\n# in classically forbidden regions.\nRESCALE_THRESHOLD = 1e10\n\n# Tolerance for the bisection root-finding method.\nBISECTION_TOL = 1e-12\n\ndef create_potential(x: np.ndarray, a: float, D: float) -> np.ndarray:\n    \"\"\"\n    Constructs the finite square well potential V(x).\n    \n    Args:\n        x (np.ndarray): Array of spatial coordinates.\n        a (float): Half-width of the well.\n        D (float): Depth of the well.\n\n    Returns:\n        np.ndarray: The potential V(x) at each point in x.\n    \"\"\"\n    V = np.zeros_like(x)\n    V[np.abs(x) <= a] = -D\n    return V\n\ndef bisection(f, a: float, b: float, tol: float = BISECTION_TOL) -> float | None:\n    \"\"\"\n    Finds a root of function f in the interval [a, b] using the bisection method.\n    \n    Args:\n        f (callable): The function for which to find a root.\n        a (float): The lower bound of the interval.\n        b (float): The upper bound of the interval.\n        tol (float): The desired tolerance for the root.\n\n    Returns:\n        float | None: The root if found, otherwise None.\n    \"\"\"\n    fa = f(a)\n    if fa == 0.0:\n        return a\n    fb = f(b)\n    if fb == 0.0:\n        return b\n    if fa * fb > 0:\n        # A change of sign is required to guarantee a root.\n        return None\n\n    while (b - a) > tol:\n        c = a + (b - a) / 2.0\n        fc = f(c)\n        if fc == 0.0:\n            return c\n        if fa * fc < 0:\n            b = c\n        else:\n            a = c\n            fa = fc  # Optimization: reuse f(c) as the new f(a)\n    return (a + b) / 2.0\n\ndef solve_case(a: float, D: float, L: float, N: int, M: int) -> list[float]:\n    \"\"\"\n    Solves for the bound-state energies of the finite potential well for one case.\n    \n    Args:\n        a (float): Half-width of the well.\n        D (float): Depth of the well.\n        L (float): Half-width of the computational domain.\n        N (int): Number of points in the spatial grid.\n        M (int): Number of points in the coarse energy scan.\n\n    Returns:\n        list[float]: A sorted list of bound-state energies, rounded to 6 decimals.\n    \"\"\"\n    # 1. Setup the spatial grid and potential\n    x = np.linspace(-L, L, N)\n    delta_x = x[1] - x[0]\n    V = create_potential(x, a, D)\n\n    # 2. Define the mismatch function using a factory pattern\n    def mismatch_function_factory(V_grid, n_points, dx):\n        def mismatch(E: float) -> float:\n            \"\"\"\n            Calculates the value of the wavefunction at the right boundary psi(L)\n            for a given trial energy E.\n            \"\"\"\n            # The recurrence relation is:\n            # psi_{i+1} = (2 + (dx^2)*(V_i - E))*psi_i - psi_{i-1}\n            # The term g_i = (dx^2)*(V_i - E) is pre-calculated.\n            g = dx**2 * (V_grid - E)\n            \n            # Initial conditions: psi_0 = 0, psi_1 = dx (for initial slope of 1)\n            p_prev = 0.0\n            p_curr = dx\n            \n            # Use recurrence to \"shoot\" across the grid\n            for i in range(1, n_points - 1):\n                p_next = (2.0 + g[i]) * p_curr - p_prev\n                \n                p_prev = p_curr\n                p_curr = p_next\n\n                # Stabilization: Rescale to prevent overflow\n                if abs(p_curr) > RESCALE_THRESHOLD:\n                    p_prev /= RESCALE_THRESHOLD\n                    p_curr /= RESCALE_THRESHOLD\n            \n            return p_curr  # Mismatch is the value at x=L\n        return mismatch\n\n    mismatch = mismatch_function_factory(V, N, delta_x)\n\n    # 3. Coarse energy scan to find intervals containing roots\n    # Epsilon prevents scanning E=-D or E=0, where solutions might be special.\n    epsilon = 1e-9\n    E_scan = np.linspace(-D + epsilon, -epsilon, M)\n    m_vals = np.array([mismatch(E) for E in E_scan])\n\n    # 4. Find brackets where the mismatch function changes sign\n    root_brackets = []\n    for i in range(M - 1):\n        if m_vals[i] * m_vals[i+1] < 0:\n            root_brackets.append((E_scan[i], E_scan[i+1]))\n\n    # 5. Refine each root using the bisection method\n    energies = []\n    for e_low, e_high in root_brackets:\n        energy = bisection(mismatch, e_low, e_high, tol=BISECTION_TOL)\n        if energy is not None:\n            energies.append(energy)\n    \n    # 6. Sort and round the final results\n    return [round(e, 6) for e in sorted(energies)]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1: Deep well, multiple states\n        {'a': 1.0, 'D': 25.0, 'L_factor': 10.0, 'N': 2001, 'M': 600},\n        # Case 2: Shallow well, near threshold\n        {'a': 1.0, 'D': 1.0, 'L_factor': 12.0, 'N': 2001, 'M': 600},\n        # Case 3: Narrow, deep well\n        {'a': 0.3, 'D': 50.0, 'L_factor': 10.0, 'N': 2001, 'M': 600},\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case['a'] * case['L_factor']\n        result = solve_case(case['a'], case['D'], L, case['N'], case['M'])\n        results.append(result)\n\n    # Format the final output string to match the problem specification,\n    # specifically producing a list of lists of floats without extra spaces.\n    # For example: [[-24.51,-23.05],[-0.6],[-48.24,-43.12]]\n    formatted_results = [str(res).replace(' ', '') for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2437421"}, {"introduction": "A deep understanding of a system's underlying physical principles can lead to more elegant and efficient computational algorithms. This practice focuses on a key property of the symmetric potentials we are studying: their eigenfunctions must possess definite parity, meaning they are either purely even or purely odd. While this exercise employs the matrix diagonalization method to compute the eigenfunctions, its primary purpose is to let you numerically verify this fundamental symmetry principle [@problem_id:2388895], an insight that we will leverage to build a more sophisticated shooting algorithm in the next practice.", "problem": "Write a complete, runnable program that, starting from the time-independent Schrödinger equation in one spatial dimension,\n$$\n\\hat{H}\\,\\psi(x) \\;=\\; E\\,\\psi(x),\\qquad \\hat{H} \\;=\\; -\\,\\frac{\\hbar^2}{2m}\\,\\frac{d^2}{dx^2} \\;+\\; V(x),\n$$\ncomputes the lowest $K$ energy eigenvalues and associated orthonormal eigenfunctions for several specified potentials on a finite interval with vanishing boundary values, and then quantitatively verifies the statement: for any symmetric potential satisfying $V(x)=V(-x)$, the eigenfunctions must have definite parity (even or odd). Use units with reduced Planck’s constant $\\hbar = 1$ and mass $m = 1$, and take the spatial domain to be $x \\in [-L,L]$ with $L = 8$, imposing boundary conditions $\\psi(-L)=\\psi(L)=0$. You must produce results for the first $K=6$ bound states by increasing energy (i.e., the six smallest energy eigenvalues, counting multiplicity) for each potential listed in the test suite below.\n\nFor each computed eigenfunction $\\psi_n(x)$, define the normalized parity correlator\n$$\np_n \\;=\\; \\frac{\\int_{-L}^{L} \\psi_n(x)\\,\\psi_n(-x)\\,dx}{\\int_{-L}^{L} |\\psi_n(x)|^2\\,dx}.\n$$\nAn eigenfunction has definite parity if and only if $|p_n|=1$. Numerically, declare that $\\psi_n(x)$ has definite parity if $|p_n|\\ge \\tau$ with the threshold $\\tau = 0.99$. For each potential, report the list of $K$ booleans $b_n$ where $b_n$ is true if $|p_n|\\ge \\tau$ and false otherwise.\n\nTest suite (evaluate in the order listed):\n- Case A (symmetric, harmonic oscillator): $V(x)=\\tfrac{1}{2}\\,\\omega^2 x^2$ with $\\omega=1$.\n- Case B (symmetric, quartic double well): $V(x)=x^4 - 2x^2$.\n- Case C (symmetric, finite square well): $V(x) = -V_0$ if $|x|<a$ and $V(x)=0$ otherwise, with $V_0=5$ and $a=1.5$.\n- Case D (non-symmetric control): $V(x)=\\tfrac{1}{2}\\,\\omega^2 x^2 + c\\,x$ with $\\omega=1$ and $c=1$.\n\nAll computations must be carried out in the units specified above; distances are dimensionless in this formulation, and energies should be interpreted in the same dimensionless system. Angles do not appear. Your program must output a single line containing a list of four inner lists (one per case, in the order A, B, C, D), each inner list holding $K=6$ booleans in the order of increasing eigenvalue, formatted as a comma-separated list enclosed in square brackets with no spaces anywhere. Concretely, your program should produce exactly one line of the form\n[[booleans_case_A,booleans_case_B,booleans_case_C,booleans_case_D]]\nwhere each booleans_case_A is itself a bracketed, comma-separated list of $K=6$ values true or false (in the programming language’s boolean literals), for example:\n[[true,true,true,true,true,true],[...],[...],[...]]\nbut using your language’s canonical boolean capitalization. The answer for each test case must therefore be a list of $K=6$ boolean values, and the final output is a list of these lists printed on a single line, with no additional characters or spaces.", "solution": "The problem statement is evaluated and found to be valid. It is scientifically grounded in the principles of quantum mechanics, specifically the time-independent Schrödinger equation. The problem is well-posed, objective, and contains all necessary information for a unique numerical solution. The task is to compute the lowest energy eigenstates for several one-dimensional potentials and to verify the relationship between a potential's symmetry and the parity of its eigenfunctions.\n\nThe governing equation is the one-dimensional time-independent Schrödinger equation:\n$$ \\hat{H}\\psi(x) = E\\psi(x) $$\nwhere $E$ is the energy eigenvalue and $\\psi(x)$ is the corresponding eigenfunction. The Hamiltonian operator $\\hat{H}$ is given by:\n$$ \\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x) $$\nThe problem specifies units where the reduced Planck constant $\\hbar=1$ and the mass $m=1$. Thus, the Hamiltonian simplifies to:\n$$ \\hat{H} = -\\frac{1}{2}\\frac{d^2}{dx^2} + V(x) $$\nThe system is confined to a finite interval $x \\in [-L, L]$ with $L=8$, subject to vanishing boundary conditions $\\psi(-L) = \\psi(L) = 0$. This configuration is equivalent to a particle in an infinite square well of width $2L$ with an additional potential $V(x)$ inside.\n\nTo solve this eigenvalue problem numerically, we employ the finite difference method. The spatial domain $[-L, L]$ is discretized into $N+1$ equidistant points $x_j = -L + j \\cdot \\Delta x$, for $j=0, 1, \\dots, N$. The grid spacing is $\\Delta x = \\frac{2L}{N}$. The value of the eigenfunction at a grid point $x_j$ is denoted by $\\psi_j = \\psi(x_j)$. The boundary conditions imply $\\psi_0 = 0$ and $\\psi_N = 0$. We must solve for the function values at the $N-1$ interior points.\n\nThe second-order derivative in the kinetic energy term is approximated using a $3$-point central difference formula:\n$$ \\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_j} \\approx \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2} $$\nSubstituting this approximation into the Schrödinger equation for each interior grid point $x_j$ (for $j=1, \\dots, N-1$) yields a system of linear equations:\n$$ -\\frac{1}{2}\\left(\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2}\\right) + V(x_j)\\psi_j = E\\psi_j $$\nThis can be rearranged into the standard form of a matrix eigenvalue problem, $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$. Here, $\\vec{\\psi}$ is a column vector of the unknown function values $(\\psi_1, \\psi_2, \\dots, \\psi_{N-1})^T$, and $\\mathbf{H}$ is a real, symmetric, tridiagonal matrix of size $(N-1) \\times (N-1)$. Its elements are defined as:\n$$\n\\mathbf{H}_{j,k} =\n\\begin{cases}\n\\frac{1}{(\\Delta x)^2} + V(x_j) & \\text{if } j=k \\\\\n-\\frac{1}{2(\\Delta x)^2} & \\text{if } j=k\\pm 1 \\\\\n0 & \\text{otherwise}\n\\end{cases}\n$$\nThe solution to this matrix equation provides the discrete approximations of the energy eigenvalues $E_n$ and the corresponding eigenfunctions $\\vec{\\psi}_n$. For this computation, a numerically stable and efficient algorithm designed for symmetric tridiagonal matrices, specifically `scipy.linalg.eigh_tridiagonal`, is utilized. We seek the $K=6$ lowest eigenvalues and their associated eigenvectors.\n\nThe problem requires verification of a theorem of quantum mechanics: for a symmetric potential $V(x)=V(-x)$, the Hamiltonian $\\hat{H}$ commutes with the parity operator $\\mathcal{P}$ (where $\\mathcal{P}f(x) = f(-x)$), and thus, they share a common set of eigenfunctions. Consequently, the eigenfunctions of $\\hat{H}$ can be chosen to have definite parity, meaning they are either even ($\\psi(-x) = \\psi(x)$) or odd ($\\psi(-x) = -\\psi(x)$), provided the energy levels are not degenerate. For degenerate levels, one can always construct a basis of eigenfunctions with definite parity.\n\nTo quantitatively assess the parity of a numerically computed eigenfunction $\\psi_n(x)$, the normalized parity correlator $p_n$ is calculated:\n$$ p_n = \\frac{\\int_{-L}^{L} \\psi_n(x)\\,\\psi_n(-x)\\,dx}{\\int_{-L}^{L} |\\psi_n(x)|^2\\,dx} $$\nFor a true even function, $p_n=1$, and for a true odd function, $p_n=-1$. For any function with definite parity, $|p_n|=1$. In the discrete numerical approximation, the integrals are replaced by sums over the grid points. The grid is constructed symmetrically about $x=0$ by choosing an odd number of total points ($N+1$), ensuring that $x_{N-j} = -x_j$. The correlator becomes:\n$$ p_n \\approx \\frac{\\sum_{j=0}^{N} \\psi_{n,j} \\psi_{n, N-j}}{\\sum_{j=0}^{N} |\\psi_{n,j}|^2} $$\nwhere $\\psi_{n,j}$ are the components of the full discrete eigenfunction vector, including the zero boundaries. The eigenvectors returned by the numerical solver are normalized such that the denominator sum is $1$. The calculation simplifies to the dot product of the eigenvector with its reversed version.\nAn eigenfunction is considered to have definite parity if $|p_n| \\ge \\tau$, with the given threshold $\\tau = 0.99$.\n\nThe algorithm proceeds as follows: for each of the $4$ potential cases, the corresponding Hamiltonian matrix is constructed and diagonalized to find the lowest $K=6$ eigen-pairs. For each resulting eigenfunction, the parity correlator $p_n$ is computed and compared against the threshold $\\tau$ to generate a boolean value. The final output is a list containing the $4$ lists of these boolean results.\n\nThe first $3$ potentials (Cases A, B, C) are symmetric, so their eigenfunctions are expected to have definite parity, yielding a list of `True` values. The fourth potential (Case D) is non-symmetric, so its eigenfunctions are not expected to have definite parity, which should result in a list of `False` values. This provides a clear test of both the physical principle and the numerical implementation. A sufficiently fine grid (e.g., using $N=2000$ intervals, meaning $N+1=2001$ points) is used to ensure high accuracy and minimize numerical artifacts.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-independent Schrödinger equation for several potentials,\n    and verifies the parity of the resulting eigenfunctions.\n    \"\"\"\n    \n    # Global parameters as defined in the problem statement\n    L = 8.0\n    K = 6\n    tau = 0.99\n    \n    # Numerical parameters for the finite difference method\n    # Use an odd number of points to have a grid point at x=0\n    num_points = 2001 \n    \n    # Define the potential functions for the test suite\n    def potential_A(x):\n        # Symmetric harmonic oscillator: V(x) = 1/2 * omega^2 * x^2 with omega=1\n        omega = 1.0\n        return 0.5 * omega**2 * x**2\n\n    def potential_B(x):\n        # Symmetric quartic double well: V(x) = x^4 - 2x^2\n        return x**4 - 2.0 * x**2\n\n    def potential_C(x):\n        # Symmetric finite square well\n        V0 = 5.0\n        a = 1.5\n        return np.where(np.abs(x) < a, -V0, 0.0)\n\n    def potential_D(x):\n        # Non-symmetric control: V(x) = 1/2 * omega^2 * x^2 + c*x\n        omega = 1.0\n        c = 1.0\n        return 0.5 * omega**2 * x**2 + c * x\n\n    test_cases = [potential_A, potential_B, potential_C, potential_D]\n\n    all_results = []\n\n    # Setup the spatial grid\n    # Grid spans from -L to L with num_points total points\n    x_grid = np.linspace(-L, L, num_points)\n    dx = x_grid[1] - x_grid[0]\n    \n    # We solve on the interior grid, excluding the boundaries\n    interior_x_grid = x_grid[1:-1]\n    num_interior_points = len(interior_x_grid)\n\n    # Pre-calculate constant kinetic energy terms\n    kinetic_diag = 1.0 / dx**2\n    kinetic_offdiag = -1.0 / (2.0 * dx**2)\n\n    for pot_func in test_cases:\n        # Evaluate the potential on the interior grid\n        V = pot_func(interior_x_grid)\n        \n        # Construct the tridiagonal Hamiltonian matrix components\n        # Diagonal elements: H_jj = T_jj + V_j\n        diagonal = kinetic_diag + V\n        \n        # Off-diagonal elements (constant for this stencil)\n        off_diagonal = np.full(num_interior_points - 1, kinetic_offdiag)\n        \n        # Solve the eigenvalue problem for the lowest K eigenvalues/eigenvectors.\n        # eigh_tridiagonal returns them sorted by eigenvalue.\n        _, eigenvectors = eigh_tridiagonal(diagonal, off_diagonal, select='i', select_range=(0, K - 1))\n        \n        case_booleans = []\n        for i in range(K):\n            # Get the i-th eigenvector (column)\n            eigenvector = eigenvectors[:, i]\n            \n            # Construct the full wavefunction on the grid, including boundaries\n            # where psi is zero.\n            psi_full = np.concatenate(([0.0], eigenvector, [0.0]))\n            \n            # The eigenvectors from eigh_tridiagonal are L2-normalized to 1.\n            # The denominator of the parity correlator is sum(|psi|^2), which is 1.\n            # So, p_n is just the numerator.\n            # The numerator is the dot product of psi(x) with psi(-x).\n            # On our symmetric grid, psi(-x) corresponds to the reversed vector.\n            p_n = np.dot(psi_full, psi_full[::-1])\n            \n            # Check if the absolute value of the parity correlator meets the threshold\n            has_definite_parity = abs(p_n) >= tau\n            case_booleans.append(has_definite_parity)\n            \n        all_results.append(case_booleans)\n\n    # Format the final output string as per the problem specification\n    string_lists = []\n    for bool_list in all_results:\n        # Convert list of booleans [True, False] to string \"[true,false]\"\n        string_lists.append(f\"[{','.join(map(str, bool_list)).lower()}]\")\n    \n    # Combine the case results into the final format \"[[...],[...],...]\"\n    final_output = f\"[{','.join(string_lists)}]\"\n    \n    # Print the single-line result\n    print(final_output)\n\nsolve()\n```", "id": "2388895"}, {"introduction": "With a grasp of the basic shooting method and the parity of wavefunctions, we can now construct a more advanced and efficient solver. This exercise [@problem_id:2437420] applies the principle of definite parity by integrating the Schrödinger equation outwards from the center of the symmetric potential, effectively splitting the problem into two simpler cases for even and odd states. You will also implement a more physically robust mismatch condition based on the asymptotic logarithmic derivative of the wavefunction, a powerful technique that enhances the accuracy and stability of the shooting method.", "problem": "You are asked to design and implement a parallel shooting method to compute bound-state eigenvalues of the one-dimensional finite square well in non-dimensional units where the reduced Planck constant squared over twice the particle mass is unity, that is, $\\hbar^2/(2m)=1$. Consider the time-independent Schrödinger equation for a stationary state wavefunction $u(x)$,\n$$\n-\\frac{d^2 u}{dx^2} + V(x)\\,u(x) = E\\,u(x),\n$$\nwhich can be written equivalently as\n$$\n\\frac{d^2 u}{dx^2} = \\big(V(x)-E\\big)\\,u(x).\n$$\nThe potential $V(x)$ is a finite square well of depth $V_0>0$ and half-width $a>0$,\n$$\nV(x) = \\begin{cases}\n-\\,V_0, & |x|\\le a,\\\\\n0, & |x|>a.\n\\end{cases}\n$$\nBound states have energies $E$ strictly between $-V_0$ and $0$, i.e., $-V_0 < E < 0$. Because the potential is even, eigenfunctions have definite parity. For even-parity states, impose initial conditions at $x=0$ as $u(0)=1$, $u'(0)=0$. For odd-parity states, impose $u(0)=0$, $u'(0)=1$. These initial conditions fix an arbitrary normalization suitable for a shooting approach.\n\nFundamental base and numerical principle. In the asymptotic region $x\\to+\\infty$ where $V(x)=0$ and $E<0$, a bound-state solution decays as $u(x)\\propto e^{-\\kappa x}$ with decay constant $\\kappa=\\sqrt{-E}$. Therefore, for a correct eigenvalue $E$, the logarithmic derivative satisfies $u'(x)/u(x)\\to -\\kappa$ for large $x$. Using this, define a mismatch function at a large but finite $x_{\\max}>a$,\n$$\nF(E) \\equiv \\frac{u'(x_{\\max})}{u(x_{\\max})} + \\sqrt{-E},\n$$\ncomputed by integrating the initial-value problem from $x=0$ to $x_{\\max}$ for a specified parity. Eigenvalues correspond to zeros of $F(E)$.\n\nParallel scheme design requirement. Partition the energy interval $(-V_0,0)$ into $P$ independent subranges. Assign each subrange to a separate processor that, independently and in parallel, performs the following for both parities:\n- samples $F(E)$ on a grid within its assigned subrange to locate sign changes indicating potential zeros,\n- refines each sign change by a robust root-finding method that only uses function sign information (for example, bisection),\n- returns the list of refined roots (candidate eigenvalues) found in that subrange.\n\nAfter all processors finish, merge and sort all candidates, remove duplicates within a small tolerance (to handle subrange boundaries), and output the unique set of eigenvalues for the test case. Use only real arithmetic. Angles do not appear; no angle unit is required. All physical quantities are non-dimensional. Express all eigenvalues in the same non-dimensional energy unit implied by $\\hbar^2/(2m)=1$, rounded to six decimal places.\n\nImplementation constraints.\n- Use a fixed-step explicit integrator to advance the system $\\frac{d}{dx}\\begin{pmatrix}u\\\\u'\\end{pmatrix}=\\begin{pmatrix}u' \\\\ (V(x)-E)u\\end{pmatrix}$ from $x=0$ to $x=x_{\\max}$ for a given $E$ and parity. Choose $x_{\\max}$ sufficiently large that the asymptotic region $V(x)=0$ is well sampled.\n- For numerical stability, you may renormalize $(u,u')$ by a constant factor during integration; this does not alter the logarithmic derivative.\n- While scanning $E$, avoid using any analytic transcendental conditions for the finite well; the algorithm must proceed from the initial-value integration and sign changes of $F(E)$ only.\n\nTest suite. Your program must compute and report eigenvalues for each of the following parameter sets, each treated as an independent test case:\n- Case A (happy path): $V_0=50.0$, $a=1.0$, $P=8$.\n- Case B (near-threshold shallow well): $V_0=2.0$, $a=1.0$, $P=4$.\n- Case C (wider and moderately deep well): $V_0=20.0$, $a=2.0$, $P=10$.\n\nFor every case:\n- Use $x_{\\max}=20.0$.\n- Use a fixed integration step $\\Delta x=0.02$.\n- In each subrange, sample $F(E)$ at $M=60$ equally spaced energies to detect sign changes, then refine each bracket by bisection until either the bracket width is below $\\varepsilon_E=10^{-6}$ or $|F(E)|<\\varepsilon_F=10^{-6}$.\n- When merging candidates across subranges and parities, treat two energies $E_1$ and $E_2$ as identical if $|E_1-E_2|<\\delta_{\\text{merge}}=10^{-3}$.\n\nFinal output specification. Your program should produce a single line of output containing the results for the three test cases as a list of lists, where each inner list contains the sorted eigenvalues (ascending) for that case, rounded to six decimal places. The format must be a single line with a comma-separated list enclosed in square brackets and the inner lists also enclosed in square brackets. For example, an output with two cases might look like $[[e_{1,1},e_{1,2}],[e_{2,1}]]$. Your program must print exactly one such line.\n\nThe expected data type for each individual number is a float. No percentages or angles appear, so no special unit instruction beyond the specified non-dimensional energy unit is needed. The design covers:\n- a general case (Case A),\n- a shallow bound case near the $E\\to 0$ boundary (Case B),\n- a wider well with multiple states (Case C).", "solution": "The problem statement is assessed to be valid. It is scientifically sound, well-posed, and provides a complete and consistent specification for a numerical task in computational quantum mechanics. The problem is free of contradictions, ambiguities, and factual errors. We may therefore proceed with the solution.\n\nThe problem requires the computation of bound-state energy eigenvalues for a one-dimensional finite square well potential. The governing equation is the time-independent Schrödinger equation (TISE) in non-dimensional units where $\\hbar^2/(2m) = 1$:\n$$\n-\\frac{d^2 u}{dx^2} + V(x)u(x) = E u(x)\n$$\nThe potential $V(x)$ is given by:\n$$\nV(x) = \\begin{cases}\n-V_0, & |x| \\le a \\\\\n0, & |x| > a\n\\end{cases}\n$$\nwhere $V_0 > 0$ is the well depth and $a > 0$ is the half-width. Bound states correspond to solutions where the wavefunction $u(x)$ is square-integrable, which for this potential requires the energy $E$ to be in the range $-V_0 < E < 0$.\n\nThe TISE is a second-order ordinary differential equation (ODE). To solve it as an initial value problem (IVP), we rewrite it as a system of two first-order ODEs. Let $\\mathbf{y}(x) = \\begin{pmatrix} u(x) \\\\ u'(x) \\end{pmatrix}$. The system is then:\n$$\n\\frac{d\\mathbf{y}}{dx} = \\frac{d}{dx}\\begin{pmatrix} u \\\\ u' \\end{pmatrix} = \\begin{pmatrix} u' \\\\ (V(x) - E)u \\end{pmatrix}\n$$\nSince the potential $V(x)$ is an even function ($V(x) = V(-x)$), the eigenfunctions $u(x)$ must have definite parity (either even or odd). This allows us to solve the problem by integrating only over the domain $x \\ge 0$ with appropriate initial conditions at $x=0$:\n- For even-parity states: $u(0) = 1$, $u'(0) = 0$.\n- For odd-parity states: $u(0) = 0$, $u'(0) = 1$.\nThe normalization is arbitrary and is chosen for convenience in the shooting method.\n\nThe core of the shooting method is to find the values of $E$ for which the solution of this IVP satisfies the boundary condition at infinity. For a bound state, $u(x)$ must decay to zero as $x \\to \\infty$. In the region $|x| > a$, the potential $V(x)=0$, and the TISE becomes $\\frac{d^2 u}{dx^2} = -E u(x)$. With $E < 0$, the general solution is $u(x) = A e^{\\kappa x} + B e^{-\\kappa x}$, where $\\kappa = \\sqrt{-E} > 0$. For the solution to be bounded as $x \\to +\\infty$, the coefficient of the growing exponential, $A$, must be zero. Thus, the solution must asymptotically behave as $u(x) \\propto e^{-\\kappa x}$. This implies that the logarithmic derivative of the wavefunction must satisfy:\n$$\n\\frac{u'(x)}{u(x)} \\to -\\kappa = -\\sqrt{-E} \\quad \\text{as } x \\to \\infty\n$$\nWe can define a mismatch function, $F(E)$, which measures how much the solution for a trial energy $E$ fails to satisfy this boundary condition at a large but finite matching point, $x_{\\max} > a$:\n$$\nF(E) = \\frac{u'(x_{\\max})}{u(x_{\\max})} + \\sqrt{-E}\n$$\nThe energy eigenvalues are precisely the roots of the equation $F(E) = 0$.\n\nThe specified algorithm is a parallel shooting method designed to find these roots. The total energy search interval $(-V_0, 0)$ is partitioned into $P$ smaller, independent subranges. For each subrange, and for each parity, a search is conducted as follows:\n1.  **ODE Integration**: To evaluate $F(E)$ for a given energy $E$, the system of first-order ODEs is integrated from $x=0$ to $x=x_{\\max}$ using a fixed-step explicit Euler integrator. Given the state $(u_n, u'_n)$ at step $x_n$, the state at $x_{n+1} = x_n + \\Delta x$ is approximated by:\n    $$\n    u_{n+1} = u_n + \\Delta x \\cdot u'_n\n    $$\n    $$\n    u'_{n+1} = u'_n + \\Delta x \\cdot (V(x_n) - E) u_n\n    $$\n    During integration, the solution vector $(u, u')$ can grow very large, leading to floating-point overflow. To ensure numerical stability, the vector is renormalized at each step if its magnitude becomes large, which does not affect the logarithmic derivative.\n\n2.  **Root Bracketing**: Within each subrange, the function $F(E)$ is sampled at $M$ equidistant points. A sign change between two consecutive points, $F(E_i) \\cdot F(E_{i+1}) < 0$, indicates the presence of a root in the interval $[E_i, E_{i+1}]$. This interval is called a bracket.\n\n3.  **Root Refinement**: Each bracket is passed to a bisection algorithm. Bisection is a robust root-finding method that repeatedly halves the interval while keeping the root bracketed. The process continues until the interval width is smaller than a tolerance $\\varepsilon_E$ or the absolute value of the mismatch function is smaller than a tolerance $\\varepsilon_F$.\n\n4.  **Result Aggregation**: After all subranges are processed for both parities, the collected eigenvalues are merged. The list of candidates is sorted, and duplicates arising from roots found near subrange boundaries are removed by considering two energies $E_1$ and $E_2$ to be identical if $|E_1 - E_2|$ is less than a merging tolerance $\\delta_{\\text{merge}}$.\n\nThis procedure is applied to the three test cases using the specified numerical parameters: $x_{\\max}=20.0$, $\\Delta x=0.02$, $M=60$, $\\varepsilon_E=10^{-6}$, $\\varepsilon_F=10^{-6}$, and $\\delta_{\\text{merge}}=10^{-3}$. The final results are the sorted, unique eigenvalues for each case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # (V0, a, P)\n        (50.0, 1.0, 8),   # Case A\n        (2.0, 1.0, 4),    # Case B\n        (20.0, 2.0, 10),  # Case C\n    ]\n\n    # Common numerical parameters from the problem statement\n    params = {\n        'x_max': 20.0,\n        'dx': 0.02,\n        'M': 60,\n        'tol_E': 1e-6,\n        'tol_F': 1e-6,\n        'tol_merge': 1e-3,\n    }\n\n    all_results = []\n    for V0, a, P in test_cases:\n        eigenvalues = _find_eigenvalues_for_case(V0, a, P, **params)\n        all_results.append([f\"{eig:.6f}\" for eig in eigenvalues])\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join([\"[\" + \",\".join(map(str, res)) + \"]\" for res in all_results]) + \"]\"\n    print(output_str)\n\n\ndef _potential(x, V0, a):\n    \"\"\"Calculates the finite square well potential V(x).\"\"\"\n    if abs(x) <= a:\n        return -V0\n    return 0.0\n\n\ndef _integrate_schrodinger(E, parity, V0, a, x_max, dx):\n    \"\"\"\n    Integrates the Schrodinger equation for a given energy and parity.\n    Uses a fixed-step explicit Euler method.\n    \"\"\"\n    # Initial conditions at x=0\n    if parity == 'even':\n        u, du_dx = 1.0, 0.0\n    else:  # odd\n        u, du_dx = 0.0, 1.0\n    \n    # Renormalization threshold to prevent overflow\n    renorm_threshold = 1e20\n\n    x_points = np.arange(0, x_max, dx)\n    for x in x_points:\n        # Explicit Euler step\n        u_new = u + dx * du_dx\n        du_dx_new = du_dx + dx * (_potential(x, V0, a) - E) * u\n        u, du_dx = u_new, du_dx_new\n\n        # Renormalization to maintain numerical stability\n        if abs(u) > renorm_threshold or abs(du_dx) > renorm_threshold:\n            norm = np.sqrt(u**2 + du_dx**2)\n            if norm > 0:\n                u /= norm\n                du_dx /= norm\n\n    return u, du_dx\n\n\ndef _mismatch_function_F(E, parity, V0, a, x_max, dx):\n    \"\"\"\n    Calculates the mismatch function F(E) for the shooting method.\n    \"\"\"\n    if E >= 0:\n        # Bound states must have E < 0, handle edge case of E approaching 0.\n        return np.inf\n\n    u_xmax, du_dx_xmax = _integrate_schrodinger(E, parity, V0, a, x_max, dx)\n\n    if abs(u_xmax) < 1e-30:  # Avoid division by zero, indicates a vertical asymptote\n        return np.inf\n\n    kappa = np.sqrt(-E)\n    return du_dx_xmax / u_xmax + kappa\n\n\ndef _bisection(func, E1, E2, tol_E, tol_F):\n    \"\"\"\n    Performs bisection to find a root of func in the bracket [E1, E2].\n    \"\"\"\n    f1 = func(E1)\n    f2 = func(E2)\n\n    if f1 * f2 >= 0:\n        return None  # Not a valid bracket\n\n    if f1 > f2: # Ensure E1 is the lower bound of F\n        E1, E2 = E2, E1\n        \n    while (E2 - E1) > tol_E:\n        E_mid = (E1 + E2) / 2.0\n        f_mid = func(E_mid)\n\n        if abs(f_mid) < tol_F:\n            return E_mid\n\n        if f_mid < 0:\n            E1 = E_mid\n        else:\n            E2 = E_mid\n            \n    return (E1 + E2) / 2.0\n\n\ndef _find_eigenvalues_for_case(V0, a, P, x_max, dx, M, tol_E, tol_F, tol_merge):\n    \"\"\"\n    Implements the full parallel shooting algorithm for a single test case.\n    The \"parallel\" aspect is simulated by iterating through independent subranges.\n    \"\"\"\n    E_min_total, E_max_total = -V0, 0.0\n    subrange_width = (E_max_total - E_min_total) / P\n    \n    candidate_eigenvalues = []\n\n    # This loop simulates P processors working in parallel\n    for i in range(P):\n        E_sub_min = E_min_total + i * subrange_width\n        E_sub_max = E_min_total + (i + 1) * subrange_width\n        \n        # This inner loop covers both parities for each subrange\n        for parity in ['even', 'odd']:\n            \n            # Create a lambda for the function to be solved in this sub-problem\n            mismatch_func = lambda E: _mismatch_function_F(E, parity, V0, a, x_max, dx)\n\n            # Sample F(E) on a grid to find sign changes (brackets)\n            # Use M points strictly inside the subrange to avoid boundary issues\n            energy_grid = np.linspace(E_sub_min, E_sub_max, M + 2)[1:-1]\n            F_values = [mismatch_func(E) for E in energy_grid]\n\n            for j in range(len(energy_grid) - 1):\n                if F_values[j] * F_values[j+1] < 0:\n                    # Found a bracket, refine it with bisection\n                    E1, E2 = energy_grid[j], energy_grid[j+1]\n                    root = _bisection(mismatch_func, E1, E2, tol_E, tol_F)\n                    if root is not None:\n                        candidate_eigenvalues.append(root)\n\n    # Merge results: sort and remove duplicates\n    if not candidate_eigenvalues:\n        return []\n\n    candidate_eigenvalues.sort()\n    \n    unique_eigenvalues = [candidate_eigenvalues[0]]\n    for i in range(1, len(candidate_eigenvalues)):\n        if abs(candidate_eigenvalues[i] - unique_eigenvalues[-1]) > tol_merge:\n            unique_eigenvalues.append(candidate_eigenvalues[i])\n            \n    return unique_eigenvalues\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2437420"}]}